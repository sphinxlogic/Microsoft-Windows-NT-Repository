Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i069:  umoria4 - single player dungeon simulation (ver. 5.5), Part37/39
Message-ID: <3433@master.CNA.TEK.COM>
Date: 22 Aug 92 22:15:59 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1771
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 69
Archive-name: umoria4/Part37
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 37 (of 39)."
# Contents:  amiga/makefile atari_st/Makefile
#   atari_st/curscomp/cursinc.h atari_st/porting.txt doc/moria.6
#   doc/moria.man misc/funckeys.c misc/haggle.sug source/rnd.c
#   source/staffs.c source/variable.c util/map.c util/monster.cng
#   util/weapons/mkallwpn.lst util/weapons/weapon.lst
# Wrapped by billr@saab on Thu Aug 20 09:11:36 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'amiga/makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'amiga/makefile'\"
else
echo shar: Extracting \"'amiga/makefile'\" \(3420 characters\)
sed "s/^X//" >'amiga/makefile' <<'END_OF_FILE'
X# This makefile is for Aztec C 5.0 for the Amiga.
X# It will not work with either an earlier version of Aztec C or with Lattice.
X
X
X# BINDIR is the directory where the moria binary while be put
X# LIBDIR is where the other files (score, news, hours) will be put
X# LIBDIR must be the same directory defined in config.h
XBINDIR = moria:
XLIBDIR = moria:
X
X# -bd = stack depth checking, -md = large data model, -so = optimized
XCFLAGS = -so -md -mr -DAMIGA
X# CFLAGS = -md -mr -DAMIGA
X
XCC = cc
XSRCS = main.c misc1.c misc2.c misc3.c misc4.c store1.c files.c io.c \
X	create.c desc.c generate.c sets.c dungeon.c creature.c death.c \
X	eat.c help.c magic.c potions.c prayer.c save.c staffs.c wands.c \
X	scrolls.c spells.c wizard.c store2.c signals.c moria1.c moria2.c \
X	moria3.c moria4.c monsters.c treasure.c variable.c rnd.c recall.c \
X	amiga.c player.c tables.c timer.c
X
XOBJS = main.o misc1.o misc2.o misc3.o misc4.o store1.o files.o io.o \
X	create.o desc.o generate.o sets.o dungeon.o creature.o death.o \
X	eat.o help.o magic.o potions.o prayer.o save.o staffs.o wands.o \
X	scrolls.o spells.o wizard.o store2.o signals.o moria1.o moria2.o \
X	moria3.o moria4.o monsters.o treasure.o variable.o rnd.o recall.o \
X	amiga.o player.o tables.o timer.o
X
XLIBFILES = hours news origcmds.hlp owizcmds.hlp roglcmds.hlp rwizcmds.hlp \
X	scores version.hlp welcome.hlp
X
Xmoria : $(OBJS)
X	ln +q +ss -o moria $(OBJS) $(DETACH) -lcurses32 -lml -lcl
X
X# you must define BINDIR and LIBDIR before installing
X# assumes that BINDIR and LIBDIR exist
Xinstall:
X	copy moria $(BINDIR)
X	copy files/* $(LIBDIR)
X
Xclean:
X	delete *.o
X	delete moria
X
Xcreate.o: constant.h types.h externs.h config.h
Xcreature.o: constant.h types.h externs.h config.h
Xdeath.o: constant.h types.h externs.h config.h
Xdesc.o: constant.h types.h externs.h config.h
Xdungeon.o: constant.h types.h externs.h config.h
Xeat.o: constant.h types.h externs.h config.h
Xfiles.o: constant.h types.h externs.h config.h
Xgenerate.o: constant.h types.h externs.h config.h
Xhelp.o: constant.h types.h externs.h config.h
Xio.o: constant.h types.h externs.h config.h
Xmagic.o: constant.h types.h externs.h config.h
Xmain.o: constant.h types.h externs.h config.h
Xmisc1.o: constant.h types.h externs.h config.h
Xmisc2.o: constant.h types.h externs.h config.h
Xmisc3.o: constant.h types.h externs.h config.h
Xmisc4.o: constant.h types.h externs.h config.h
Xmonsters.o: constant.h types.h config.h
Xmoria1.o: constant.h types.h externs.h config.h
Xmoria2.o: constant.h types.h externs.h config.h
Xmoria3.o: constant.h types.h externs.h config.h
Xmoria4.o: constant.h types.h externs.h config.h
Xplayer.o: constant.h types.h config.h
Xpotions.o: constant.h types.h externs.h config.h
Xprayer.o: constant.h types.h externs.h config.h
Xrecall.o: constant.h config.h types.h externs.h
Xrnd.o: constant.h types.h
Xsave.o: constant.h types.h externs.h config.h
Xscrolls.o: constant.h types.h externs.h config.h
Xsets.o: constant.h config.h
Xsignals.o: constant.h types.h externs.h config.h
Xspells.o: constant.h types.h externs.h config.h
Xstaffs.o: constant.h types.h externs.h config.h
Xstore1.o: constant.h types.h externs.h config.h
Xstore2.o: constant.h types.h externs.h config.h
Xtables.o: constant.h types.h config.h
Xtreasure.o: constant.h types.h config.h
Xunix.o: constant.h config.h types.h externs.h
Xvariable.o: constant.h types.h config.h
Xwands.o: constant.h types.h externs.h config.h
Xwizard.o: constant.h types.h externs.h config.h
END_OF_FILE
if test 3420 -ne `wc -c <'amiga/makefile'`; then
    echo shar: \"'amiga/makefile'\" unpacked with wrong size!
fi
# end of 'amiga/makefile'
fi
if test -f 'atari_st/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'atari_st/Makefile'\"
else
echo shar: Extracting \"'atari_st/Makefile'\" \(3841 characters\)
sed "s/^X//" >'atari_st/Makefile' <<'END_OF_FILE'
X# The MWC Makefile.
X
X# BINDIR is the directory where the moria binary will be put
X# LIBDIR is where the other files (scoreboard, news, hours) will be put
X# LIBDIR must be the same directory defined in config.h
X# this was clipped from the link command: -lcurses -ltermcap
XBINDIR = /usr/public/
XLIBDIR = /usr/public/moriadir/
X
XCFLAGS = -A -V -VCSD
XCC = cc
X
XSRCS = main.c misc1.c misc2.c misc3.c misc4.c store1.c files.c io.c \
X	create.c desc.c generate.c sets.c dungeon.c creature.c death.c \
X	eat.c help.c magic.c potions.c prayer.c save.c staffs.c wands.c \
X	scrolls.c spells.c wizard.c store2.c signals.c moria1.c moria2.c \
X	moria3.c moria4.c monsters.c treasure.c variable.c rnd.c recall.c \
X	atarist.c player.c tables.c
X
XOBJS = main.o misc1.o misc2.o misc3.o misc4.o store1.o files.o io.o \
X	create.o desc.o generate.o sets.o dungeon.o creature.o death.o \
X	eat.o help.o magic.o potions.o prayer.o save.o staffs.o wands.o \
X	scrolls.o spells.o wizard.o store2.o signals.o moria1.o moria2.o \
X	moria3.o moria4.o monsters.o treasure.o variable.o rnd.o recall.o \
X	atarist.o curses.o player.o tables.o
X
XLIBFILES = moria_hours moria_help moria_orig_help moria_wiz_help \
X	moria_orig_wiz_help moria_man
X
Xmoria : $(OBJS)
X	$(CC) -o moria $(CFLAGS) $(OBJS)
X
Xlibfiles: $(LIBFILES)
X	chmod 444 $(LIBFILES)
X	cp $(LIBFILES) $(LIBDIR)
X
X$(BINDIR):
X	mkdir $(BINDIR)
X	chmod 755 $(BINDIR)
X
X$(LIBDIR):
X	mkdir $(LIBDIR)
X	chmod 711 $(LIBDIR)
X
X$(LIBDIR)/moria_hours: moria_hours
X	chmod 644 moria_hours
X	cp moria_hours $(LIBDIR)
X
Xlintout : $(SRCS)
X	lint $(SRCS) -lcurses -ltermcap > lintout
X
Xlintout2 : $(SRCS)
X	lint -bach $(SRCS) -lcurses -ltermcap > lintout
X
XTAGS : $(SRCS)
X	ctags -x $(SRCS) > TAGS
X
X# you must define BINDIR and LIBDIR before installing
Xinstall:
X	cp moria $(BINDIR)
X	cp Moria_hours $(LIBDIR)
X	cp Moria_news $(LIBDIR)
X	cp Highscores $(LIBDIR)
X	chmod 4511 $(BINDIR)/moria
X	chmod 644 $(LIBDIR)/Highscores
X	chmod 444 $(LIBDIR)/Moria_news
X	chmod 444 $(LIBDIR)/Moria_hours
X	chmod 555 $(LIBDIR)
X
Xclean:
X	rm -r *.o
X	rm -i moria
X
Xcreate.o: constant.h types.h externs.h config.h
Xcreature.o: constant.h types.h externs.h config.h
Xdeath.o: constant.h types.h externs.h config.h
Xdesc.o: constant.h types.h externs.h config.h
Xdungeon.o: constant.h types.h externs.h config.h
Xeat.o: constant.h types.h externs.h config.h
Xfiles.o: constant.h types.h externs.h config.h
Xgenerate.o: constant.h types.h externs.h config.h
Xhelp.o: constant.h types.h externs.h config.h
Xio.o: constant.h types.h externs.h config.h
Xmagic.o: constant.h types.h externs.h config.h
Xmain.o: constant.h types.h externs.h config.h
Xmisc1.o: constant.h types.h externs.h config.h
Xmisc2.o: constant.h types.h externs.h config.h
Xmisc3.o: constant.h types.h externs.h config.h
Xmisc4.o: constant.h types.h externs.h config.h
Xmonsters.o: constant.h types.h config.h
Xmoria1.o: constant.h types.h externs.h config.h
Xmoria2.o: constant.h types.h externs.h config.h
Xmoria3.o: constant.h types.h externs.h config.h
Xmoria4.o: constant.h types.h externs.h config.h
Xplayer.o: constant.h types.h config.h
Xpotions.o: constant.h types.h externs.h config.h
Xprayer.o: constant.h types.h externs.h config.h
Xrecall.o: constant.h config.h types.h externs.h
Xrnd.o: constant.h types.h
Xsave.o: constant.h types.h externs.h config.h
Xscrolls.o: constant.h types.h externs.h config.h
Xsets.o: constant.h config.h
Xsignals.o: constant.h types.h externs.h config.h
Xspells.o: constant.h types.h externs.h config.h
Xstaffs.o: constant.h types.h externs.h config.h
Xstore1.o: constant.h types.h externs.h config.h
Xstore2.o: constant.h types.h externs.h config.h
Xtables.o: constant.h types.h config.h
Xtreasure.o: constant.h types.h config.h
Xatarist.o: constant.h config.h types.h externs.h
Xvariable.o: constant.h types.h config.h
Xwands.o: constant.h types.h externs.h config.h
Xwizard.o: constant.h types.h externs.h config.h
END_OF_FILE
if test 3841 -ne `wc -c <'atari_st/Makefile'`; then
    echo shar: \"'atari_st/Makefile'\" unpacked with wrong size!
fi
# end of 'atari_st/Makefile'
fi
if test -f 'atari_st/curscomp/cursinc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'atari_st/curscomp/cursinc.h'\"
else
echo shar: Extracting \"'atari_st/curscomp/cursinc.h'\" \(4206 characters\)
sed "s/^X//" >'atari_st/curscomp/cursinc.h' <<'END_OF_FILE'
X/****************************************************************************/
X/*                                                                          */
X/*   CURSINC.H                    include file for the CURSES module itself */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* This source and resulting object may be modified, used or distributed by */
X/* anyone who so desires under the following conditions :                   */
X/*                                                                          */
X/*  1) This notice and the copyright notice shall not be removed or         */
X/*     changed.                                                             */
X/*  2) No credit shall be taken for this source and resulting objects       */
X/*  3) This source or resulting objects is not to be traded, sold or        */
X/*     used for personal gain or profit.                                    */
X/*  4) Inclusion of this source or resulting objects in commercially        */
X/*     available packages is forbidden without written consent of the       */
X/*     author of this source.                                               */
X/*                                                                          */
X/****************************************************************************/
X
X/* Original author :  
X    Rene van't Veen
X    Debussystraat 27
X    1817 GL Alkmaar
X    The Netherlands
X
X   Extensive modifications for speed and clarity by :
X    Hildo Biersma
X    Tollensstraat 138
X    2513 GE Den Haag
X    Holland
X
X   The original copyright notices still apply - refer to CURSES.C */
X
Xtypedef unsigned char bool;
Xtypedef short         int16;
Xtypedef long          int32;
X
X#define OK          1
X#define ERR         0
X#define TRUE        1
X#define FALSE       0
X#define _SUBWIN     01
X#define _ENDLINE    02
X#define _FULLWIN    04
X#define _SCROLLWIN  010
X#define _STANDOUT   0200
X#define WINDOW      struct _win_st
X
X#define TOUCHED     0x0200
X#define STANDOUT    0x0100
X
X#define mvwaddch(w,y,x,c)   { wmove(w,y,x); waddch(w,c); }
X#define mvwaddstr(w,y,x,s)  { wmove(w,y,x); waddstr(w,s); }
X#define clearok(w,f)        { w->_clear = (w->_flags & _FULLWIN) \
X                              ? f : w->_clear; }
X#define getyx(w,y,x)        { y = w->_cury; x = w->_curx; }
X
Xstruct _win_st 
X{
X  int16 _cury, _curx;
X  int16 _maxy, _maxx;
X  int16 _begy, _begx;
X  int16 _flags;
X  bool  _clear;
X  bool  _leave;
X  bool  _scroll;
X  int16 **_y;
X  int16 *_firstch;
X  int16 *_lastch;
X  int16 *_yend;
X};
X
X/* prototypes of functions in curses.c */
XWINDOW *initscr ( void );
Xvoid endwin ( void );
XWINDOW *newwin ( int l , int c , int by , int bx );
Xvoid delwin ( WINDOW *w );
Xint mvwin ( WINDOW *w , int y , int x );
Xvoid touchwin ( WINDOW *w );
XWINDOW *subwin ( WINDOW *w , int l , int c , int by , int bx );
Xvoid leaveok ( WINDOW *w , bool f );
Xvoid scrollok ( WINDOW *w , bool f );
Xvoid nl ( void );
Xvoid nonl ( void );
Xvoid longname ( char *termbuf , char *name );
Xint  curaddch( char c );
Xint  waddch ( WINDOW *w , char c );
Xint  waddstr ( WINDOW *w , char *s );
Xvoid box ( WINDOW *w , char v , char h );
Xvoid wclear ( WINDOW *w );
Xvoid wclrtobot ( WINDOW *w );
Xvoid wclrtoeol ( WINDOW *w );
Xint  wdelch ( WINDOW *w );
Xint  wdeleteln ( WINDOW *w );
Xvoid werase ( WINDOW *w );
Xint  winsch ( WINDOW *w , char c );
Xvoid winsertln ( WINDOW *w );
Xint  wmove ( WINDOW *w , int y , int x );
Xvoid overlay ( WINDOW *v , WINDOW *w );
Xvoid overwrite ( WINDOW *v , WINDOW *w );
Xvoid wstandout ( WINDOW *w );
Xvoid wstandend ( WINDOW *w );
Xvoid raw ( void );
Xvoid noraw ( void );
Xvoid crmode ( void );
Xvoid nocrmode ( void );
Xvoid echo ( void );
Xvoid noecho ( void );
Xlong wgetch ( WINDOW *w );
Xint  wgetstr ( WINDOW *w , char *s );
Xvoid cur_refresh( void );
Xvoid wrefresh ( WINDOW *w );
Xvoid mvcur ( int ly , int lx , int ny , int nx );
Xvoid _movcur ( int16 y , int16 x );
Xint  scroll ( WINDOW *w );
X/* end of prototypes for curses.c */
X
X/****************END OF SOURCE CURSINC.H************************************/
END_OF_FILE
if test 4206 -ne `wc -c <'atari_st/curscomp/cursinc.h'`; then
    echo shar: \"'atari_st/curscomp/cursinc.h'\" unpacked with wrong size!
fi
# end of 'atari_st/curscomp/cursinc.h'
fi
if test -f 'atari_st/porting.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'atari_st/porting.txt'\"
else
echo shar: Extracting \"'atari_st/porting.txt'\" \(3050 characters\)
sed "s/^X//" >'atari_st/porting.txt' <<'END_OF_FILE'
X
XItems marked '*' should no longer be necessary.
XItems marked '?' should be unnecessary, but probably aren't.  I don't
X  understand why they were necessary in the first place.  - Jim Wilson
X
X---------------
X
XPorting the new version of Moria to the Atari ST with TC - by Hildo Biersma
X
XI : Preliminary work
X1) Get the new archive through FTP
X2) Split in files to get it on 720K disks
X3) Reassembly, uncompress, untar
X4) Make a copy of the sources to the MORIATRY folder
X
XII : Starting to do the port
X*1) Build a project file from the file MAKEFILE.TC => MORIA.PRJ
X2) Build a TC configuration file with standard macro GEMDOS,
X    standard options -P -G, linker stack size 16K => TC_MORIA.CFG
X3) Filter all files through UNIX-to-DOS, or load/save from Tempus
X?4) In order to make use of compiler warning level 2, build a list of
X    proper ANSI-C prototypes in EXTERNS.H => EXTERNS.H
X5) Edit CONFIG.H to define ATARIST_TC
X*6) Change fseed in DEATH.C to fseek (typing error)
X?7) Edit all files that use static functions to add proper ANSI-C prototypes
X    (the semi-prototypes at #if defined(LINT_ARGS) are a good template for
X    doing this). This is needed in the following files :
X    CREATE.C, CREATURE.C, DEATH.C, DESC.C, DUNGEON.C,
X    GENERATE.C, MAIN.C, MISC1.C, MISC2.C, MORIA1.C, MORIA2.C,
X    RECALL.C, SAVE.C, SPELLS.C, STORE1.C and STORE2.C
X*8) Edit files to add #include <stdlib.h> to make sure functions
X    like abs() are prototyped. This is needed for :
X    CREATURE.C, DEATH.C, DESC.C, DUNGEON.C, FILES.C, IO.C,
X    MORIA1.C, MORIA2.C, STORE2.C, WIZARD.C and ATARIST.TC
X   This can of course best be done with an #ifdef ATARIST_TC
X*9) GENERATE.C needs an #include <string.h> to prototype memset()
X*10) IO.C gives two compile-time errors; this is because mwaddstr and
X      mwaddch are macro's that don't properly return values. The checks
X      that are done, if (mwaddstr(..) == ERR) and if (mwaddch(..) == ERR)
X      are not needed, as both functions never return an error on the ST 
X      anyway. So you can do an #ifdef ATARIST_TC and use just the function 
X      call; the if, error message and exit stuff can all be removed.
X*12) IO.C needs to have <ext.h> included to define sleep()
X*13) In CONFIG.H, the "#define index strchr" is not done for the Atari ST;
X      it should be, so add "|| ATARIST_TC" to the #ifdef just above.
X*14) In SAVE.C, there is a #ifdef MSDOS before the definition of t_ptr
X      in lines 127-128. This should of course be :
X      #if defined(MSDOS) || defined(ATARI_ST)
X    Same thing in line 681. Also, around line 722, where savefile ownership
X      is checked, there is an ATARIST_MWC which should be an ATARI_ST, as
X      chmod is a dummy function on both the ATARI TC and ATARI MWC versions.
X    Finally, time.h must be included to prototype time().
X?15) Add a #define ATARIST_MWC in SIGNALS.C to avoid using signals in
X      the same way as the MWC version.
X15) Now do a make to compile and link Moria. You now have a working copy of
X      Moria. Finishing and polishing make take a while longer. 
END_OF_FILE
if test 3050 -ne `wc -c <'atari_st/porting.txt'`; then
    echo shar: \"'atari_st/porting.txt'\" unpacked with wrong size!
fi
# end of 'atari_st/porting.txt'
fi
if test -f 'doc/moria.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/moria.6'\"
else
echo shar: Extracting \"'doc/moria.6'\" \(3509 characters\)
sed "s/^X//" >'doc/moria.6' <<'END_OF_FILE'
X.TH MORIA 6 "" "Local"
X\" By default, this man page assumes moria was compiled with the original
X\" command set.  If you are using the rogue like command set, then delete
X\" the first three characters on the following line.
X\" .ds O ROGUE_LIKE
X.if '\*(Bd'' .ds Bd moria
X.SH NAME
Xmoria \- a dungeon game
X.SH SYNOPSIS
X.B \*(Bd
X[
X.B \-o
X] [
X.B \-r
X] [
X.B \-s
X] [
X.B \-S
X] [
X.B \-n
X] [
X.B \-w
X] [ savefile ]
X.SH DESCRIPTION
X.I Moria\^
Xplays a dungeon game with you.
XIt lets you generate a character,
Xlets you buy equipment,
Xand lets you wander in a fathomless dungeon
Xwhile finding treasure and being attacked by monsters
Xand fellow adventurers.
XTyping
X.B ?
Xgives you a list of commands.
X.PP
XThe ultimate object of
X.I moria
Xis to kill the Balrog,
Xwhich dwells on the 50th level of the
Xdungeon, 2,500 feet underground.
XMost players never even reach the Balrog,
Xand those that do seldom live to tell about it.
X.PP
XFor a more complete description of the game,
Xread the document
X.I The Dungeons of Moria.
X.PP
XBy default,
X.I moria
Xwill save and restore games from a file
Xcalled moria.save in your home directory.  If the environment
Xvariable MORIA_SAV is defined, then
X.I moria
Xwill use that
Xfile name instead of the default.  If MORIA_SAV is not a complete
Xpath name, then the savefile will be created or restored from the
Xcurrent directory.  You can also explicitly specify a savefile
Xon the command line.
X.PP
XIf you use the \fB\-n\fP option,
X.I moria
Xwill create a new game,
Xignoring any savefile which may already exist.
XThis works best when a savefile name is specified on the
Xcommand line, as this will prevent
X.I moria
Xfrom trying to overwrite the default savefile
X(if it exists) when you try to save your game.
X.PP
XYou move in various directions
X.ie '\*O'ROGUE_LIKE' the same way you do in \fIrogue\fP(6).
X.el by pressing the numeric keypad keys, VMS-style.
XIf you specify
X.if '\*O'ROGUE_LIKE' \fB\-o\fP, you move by pressing the numeric keypad
X.ie '\*O'ROGUE_LIKE' keys, VMS-style.
X.el \fB\-r\fP, you move the same way you do in \fIrogue\fP(6).
XYou can also specify
X.ie '\*O'ROGUE_LIKE' \fB\-r\fP to force the \fIrogue\fP(6) like command set.
X.el \fB\-o\fP to force the VMS-style command set.
XThese options will override defaults stored in the savefile.  If these
Xoptions are given multiple times, only the last one will take effect.
X.PP
XIf you specify
X.BR \-s ,
X.I moria
Xprints all of the scores in the score file and exits.
XOn a multiuser system, if you specify
X.BR \-S ,
X.I moria
Xprints prints only those scores belonging to you and then exits.
X.PP
XIf you specify \fB\-w\fP,
X.I moria
Xwill start up in wizard mode.
XYou can resurrect a dead character by using this option when starting
Xthe game.  Resurrected characters are teleported to the town level
Xand given zero hitpoints.
XWizard mode is intended for debugging the game, and for experimenting
Xwith new features.  Any other use is considered cheating.
XGames played with wizard mode are not scored.
X.SH AUTHORS
XThe original version of Moria was written in VMS/Pascal by Robert
XAlan Koeneke, Jimmey Wayne Todd,
XGary McAdoo, and others at the University of Oklahoma.
XThis version was written by Jim Wilson at the University of California,
XBerkeley, and released with minor revisions by David Grabiner at Harvard
XUniversity.
X.SH BUGS
X.PP
XA suspended game that gets a hangup signal will die without creating a
Xsave file.
X
XRerolling with a % at the class prompt not implemented.
X
XFor a more comprehensive list, see the ERRORS file in the source
Xdistribution.
END_OF_FILE
if test 3509 -ne `wc -c <'doc/moria.6'`; then
    echo shar: \"'doc/moria.6'\" unpacked with wrong size!
fi
# end of 'doc/moria.6'
fi
if test -f 'doc/moria.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/moria.man'\"
else
echo shar: Extracting \"'doc/moria.man'\" \(3544 characters\)
sed "s/^X//" >'doc/moria.man' <<'END_OF_FILE'
X
X
X
XMORIA(6)                 GAMES AND DEMOS                 MORIA(6)
X
X
X
XNAME
X     moria - a dungeon game
X
XSYNOPSIS
X     moria [ -o ] [ -r ] [ -s ] [ -S ] [ -n ] [ -w ] [ savefile ]
X
XDESCRIPTION
X     Moria plays a dungeon game with you.  It lets you generate a
X     character,  lets you buy equipment, and lets you wander in a
X     fathomless dungeon while finding treasure and being attacked
X     by  monsters  and  fellow adventurers.  Typing ? gives you a
X     list of commands.
X
X     The ultimate object of moria is to kill  the  Balrog,  which
X     dwells  on  the 50th level of the dungeon, 2,500 feet under-
X     ground.  Most players never even reach the Balrog, and those
X     that do seldom live to tell about it.
X
X     For a more complete description of the game, read the  docu-
X     ment The Dungeons of Moria.
X
X     By default, moria will save and restore games  from  a  file
X     called  moria.save  in your home directory.  If the environ-
X     ment variable MORIA_SAV is defined, then moria will use that
X     file  name  instead  of  the default.  If MORIA_SAV is not a
X     complete path name, then the savefile  will  be  created  or
X     restored  from  the  current directory.  You can also expli-
X     citly specify a savefile on the command line.
X
X     If you use the -n option, moria  will  create  a  new  game,
X     ignoring  any  savefile which may already exist.  This works
X     best when a savefile name is specified on the command  line,
X     as  this  will  prevent  moria  from trying to overwrite the
X     default savefile (if it exists) when you try  to  save  your
X     game.
X
X     You move in  various  directions  by  pressing  the  numeric
X     keypad  keys,  VMS-style.   If  you specify -r, you move the
X     same way you do in rogue(6).  You can  also  specify  -o  to
X     force  the  VMS-style command set.  These options will over-
X     ride defaults stored in the savefile.  If these options  are
X     given multiple times, only the last one will take effect.
X
X     If you specify -s, moria prints all of  the  scores  in  the
X     score file and exits.  On a multiuser system, if you specify
X     -S, moria prints prints only those scores belonging  to  you
X     and then exits.
X
X     If you specify -w, moria will start up in wizard mode.   You
X     can  resurrect  a  dead  character by using this option when
X     starting the game.  Resurrected characters are teleported to
X     the  town  level  and  given zero hitpoints.  Wizard mode is
X
X
X
XLocal                     Last change:                          1
X
X
X
X
X
X
XMORIA(6)                 GAMES AND DEMOS                 MORIA(6)
X
X
X
X     intended for debugging the game, and for experimenting  with
X     new  features.  Any other use is considered cheating.  Games
X     played with wizard mode are not scored.
X
XAUTHORS
X     The original version of Moria was written in  VMS/Pascal  by
X     Robert  Alan  Koeneke,  Jimmey  Wayne Todd, Gary McAdoo, and
X     others at the University  of  Oklahoma.   This  version  was
X     written  by  Jim  Wilson  at  the  University of California,
X     Berkeley, and released with minor revisions  by  David  Gra-
X     biner at Harvard University.
X
XBUGS
X     A suspended game that gets a hangup signal will die  without
X     creating a save file.
X
X     Rerolling with a % at the class prompt not implemented.
X
X     For a more comprehensive list, see the ERRORS  file  in  the
X     source distribution.
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
XLocal                     Last change:                          2
X
X
X
END_OF_FILE
if test 3544 -ne `wc -c <'doc/moria.man'`; then
    echo shar: \"'doc/moria.man'\" unpacked with wrong size!
fi
# end of 'doc/moria.man'
fi
if test -f 'misc/funckeys.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/funckeys.c'\"
else
echo shar: Extracting \"'misc/funckeys.c'\" \(3169 characters\)
sed "s/^X//" >'misc/funckeys.c' <<'END_OF_FILE'
X/* call e_inkey() in dungeon.c instead of inkey() */
X
Xint keypadon;
X
X/* e_inkey
X * This inkey processes function keys also (using map_keypad)
X */
X
X/* Gets single character from keyboard and returns a character.  If the key
X * pressed is a function key, it processes the key without waiting on the
X * escape.  At this time it processes function keys by using map_keypad and
X * needs funckeys.h.  If you don't want ANY escape processing, use inkey().
X * If you are using this function, Escape will need to be pressed twice to get
X * an escape.
X */
X
Xe_inkey(ch)
X     char *ch;
X{
X
X  put_qio();			/* Dump IO buffer		 */
X  if (!keypadon) {
X    *ch = getch();
X    return;
X  }
X  if ((*ch = getch()) != ESC)
X    return;
X  /* we now have an escape, if a [ does not follow it, send back a null */
X  if ((*ch = getch()) != FCHAR ) {
X    if (*ch == ESC)
X      return;
X    *ch = INPUT_ERROR;
X    return;
X  }
X  map_keypad(ch);
X}
X
X/* map_keypad is sun specific still.  It should not be hard to change it for
X * any keypad.  It needs funckeys.h to work and is only called from e_inkey().
X * This seems to be too slow, and we are getting some processing errors that
X * look like short teleportation.
X */
X
Xmap_keypad(ch)
X
X     char *ch;
X{
X  int             c;
X  int             key, rawkey, n;
X  char            side;
X
X
X
X#if SUN
X
X  switch (c = getch()) {
X  case 'A':
X    side = 'r';
X    key = 8;
X    break;
X
X  case 'B':
X    side = 'r';
X    key = 14;
X    break;
X
X  case 'C':
X    side = 'r';
X    key = 12;
X    break;
X
X  case 'D':
X    side = 'r';
X    key = 10;
X    break;
X
X  default:
X    rawkey = c - '0';
X
X    for (n = 0; c = getch(), n < 3; n++) {
X      if (c == 'z')
X	break;
X      else if (c < '0' || c > '9') {
X	*ch = INPUT_ERROR;
X	return;
X      } else
X	rawkey = rawkey * 10 + c - '0';
X
X    }
X    if (c != 'z') {
X      *ch = INPUT_ERROR;
X      return;
X    } else if (rawkey >= 208 && rawkey <= 222) {
X      side = 'r';
X      key = rawkey - 207;
X
X    } else if (rawkey >= 192 && rawkey <= 201) {
X      side = 'l';
X      key = rawkey - 191;
X    } else if (rawkey >= 224 && rawkey <= 232) {
X      side = 'f';
X      key = rawkey - 223;
X    } else {
X      *ch = INPUT_ERROR;
X      return;
X    }
X    break;
X  }
X  if (side == 'r')
X    *ch = rkeys[key];
X  else if (side == 'l')
X    *ch = lkeys[key];
X  else if (side == 'f')
X    *ch = fkeys[key];
X  else
X    *ch = INPUT_ERROR;
X#endif
X}
X
X/* Prompts (optional) and returns False if ESC is the input character.  escp
X * is a boolean option that allows you to decide if you want function key
X * processing or not.
X *
X * If the prompt is NULL or empty, nothing is printed and nothing is erase.
X */
Xget_com(prompt, command, escp)
X     char *prompt;
X     char *command;
X     int escp;
X{
X  int             com_val;
X  int             res;
X  int             do_erase;
X
X  if ((prompt != NULL) && (strlen(prompt) > 0)) {
X    oprint(prompt);
X    do_erase = TRUE;
X  } else
X    do_erase = FALSE;
X
X  if (escp)
X    inkey(command);
X  else
X    e_inkey(command);
X  com_val = *command;
X  switch (com_val) {
X  case ESC:
X    res = FALSE;
X    break;
X  default:
X    res = TRUE;
X    break;
X  }
X  if (do_erase == TRUE)
X    erase_line(msg_line, msg_line);
X  return (res);
X}
END_OF_FILE
if test 3169 -ne `wc -c <'misc/funckeys.c'`; then
    echo shar: \"'misc/funckeys.c'\" unpacked with wrong size!
fi
# end of 'misc/funckeys.c'
fi
if test -f 'misc/haggle.sug' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/haggle.sug'\"
else
echo shar: Extracting \"'misc/haggle.sug'\" \(3206 characters\)
sed "s/^X//" >'misc/haggle.sug' <<'END_OF_FILE'
XFrom ghudson@cie.uoregon.edu Tue Mar  6 17:09:23 1990
XReceived: from oregon.uoregon.edu by ernie.Berkeley.EDU (5.61/1.36)
X	id AA19401; Tue, 6 Mar 90 17:09:11 -0800
XReceived: from cie.uoregon.edu by oregon.uoregon.edu; Tue, 6 Mar 90 17:07 PST
XReceived: by cie.uoregon.edu (MC 2.0/SMI-4.0.1.2(JQJ)) id AA09277; Tue, 6 Mar
X 90 17:07:48 PST
XDate: Tue, 6 Mar 90 17:07:48 PST
XFrom: ghudson@cie.uoregon.edu
XSubject: Re: Haggling
XTo: wilson@ernie.Berkeley.EDU
XMessage-Id: <9003070107.AA09277@cie.uoregon.edu>
XX-Envelope-To: wilson@ernie.Berkeley.EDU
XStatus: RO
X
X> Drat.  This will ahve to be fixed somehow, maybe by setting a bit in each
X> individual object when bought/sold, so that it can only contribute to the
X> good/bad bargain counts once.
X     Reasonable.  Shouldn't take too much coding.
X     Since this is getting so complex, you might try to put in some clue as
Xto how good of a bargainer you are, e.g. when you start bargaining, you have
Xa small (10%-20%) chance of getting a message like:
XThe merchant looks at you distatesfully
XThe merchant eyes you with a hint of respect
X     Something like that.
X     Now, on to our (3*bad + 20) formula:
X     Simplified, this could be algorythm'd like so:
Xptr = 20;
Xcase <bad bargain> pointer += 3;
Xcase <good bargain> pointer -= 1;
Xif (ptr == 0) <don't bargain>
X     Okay, that was of course a mishhash of something slightly resembling
XC code, but you get the idea.  But I don't like how if you missed the final
Xoffer by one gold piece, your pointer goes up by three, even if the item
Xwas worth some 900 to start with.  I'd think it'd be better if that was
Xmore like:
Xcase <bad bargain> pointer += (price paid - low price) / low price * 10
X     So you lose one point for each 10% over the final value that you paid.
X     This isn't particularly accurate, unfortunately, but that might be
Xremedied by a (float) ptr.
X     (I just realized that "ptr" is a pretty dumb name for what should be
Xcalled "counter" or something.  Sorry...)
X
X     Back to our spoiler solution, do note that one could still buy a bunch
Xof junk and still up (down, via my algorythm) your counter, even though you
Xdidn't need the item.  I really don't have a solution, other than expanding
Xthe code so that each price range (increments of about a hundred, so the
Xfirst few would be 10-100, 11-200, 201-300 and the last few would be 801-900
Xand 901-1000 or 901-999, however you work it) gets a separate counter.  Natur-
Xally, this would have to be accompanied by a decrease of the original counter
Xvalue to 10 or 5 or so (or a different value for each range, since players
Xwill buy a lot more items in the 10-100 range).
X
X> Thanks for the warning.
X     Just came to my mind.  It isn't quite so bad, since items under 10 gp
Xfinal price don't count, so one couldn't up your counter by buying flasks of
Xoil or something.
X
XGreg Hudson
Xghudson@cie.uoregon.edu
X"Though the Earth, and all inferior Creatures be common to all Men, yet every
XMan has a Property in his own Person.  This no Body has any Right to but
Xhimself." -- John Locke, _Two Treatises of Government_, 2nd Treatise
XI am blatantly close-minded and refuse to admit it.
XThere are missionaries aplenty, but few enlightened.  Believe me.
X
END_OF_FILE
if test 3206 -ne `wc -c <'misc/haggle.sug'`; then
    echo shar: \"'misc/haggle.sug'\" unpacked with wrong size!
fi
# end of 'misc/haggle.sug'
fi
if test -f 'source/rnd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/rnd.c'\"
else
echo shar: Extracting \"'source/rnd.c'\" \(3146 characters\)
sed "s/^X//" >'source/rnd.c' <<'END_OF_FILE'
X/* source/rnd.c: random number generator
X
X   Copyright (c) 1989-92 James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X
X/* Define this to compile as a standalone test */
X/* #define TEST_RNG */
X
X/* This alg uses a prime modulus multiplicative congruential generator
X   (PMMLCG), also known as a Lehmer Grammer, which satisfies the following
X   properties
X
X   (i)	 modulus: m - a large prime integer
X   (ii)	 multiplier: a - an integer in the range 2, 3, ..., m - 1
X   (iii) z[n+1] = f(z[n]), for n = 1, 2, ...
X   (iv)	 f(z) = az mod m
X   (v)	 u[n] = z[n] / m, for n = 1, 2, ...
X
X   The sequence of z's must be initialized by choosing an initial seed
X   z[1] from the range 1, 2, ..., m - 1.  The sequence of z's is a pseudo-
X   random sequence drawn without replacement from the set 1, 2, ..., m - 1.
X   The u's form a psuedo-random sequence of real numbers between (but not
X   including) 0 and 1.
X
X   Schrage's method is used to compute the sequence of z's.
X   Let m = aq + r, where q = m div a, and r = m mod a.
X   Then f(z) = az mod m = az - m * (az div m) =
X	     = gamma(z) + m * delta(z)
X   Where gamma(z) = a(z mod q) - r(z div q)
X   and	 delta(z) = (z div q) - (az div m)
X
X   If r < q, then for all z in 1, 2, ..., m - 1:
X   (1) delta(z) is either 0 or 1
X   (2) both a(z mod q) and r(z div q) are in 0, 1, ..., m - 1
X   (3) absolute value of gamma(z) <= m - 1
X   (4) delta(z) = 1 iff gamma(z) < 0
X
X   Hence each value of z can be computed exactly without overflow as long
X   as m can be represented as an integer.
X */
X
X/* a good random number generator, correct on any machine with 32 bit
X   integers, this algorithm is from:
X
XStephen K. Park and Keith W. Miller, "Random Number Generators:
X	Good ones are hard to find", Communications of the ACM, October 1988,
X	vol 31, number 10, pp. 1192-1201.
X
X   If this algorithm is implemented correctly, then if z[1] = 1, then
X   z[10001] will equal 1043618065
X
X   Has a full period of 2^31 - 1.
X   Returns integers in the range 1 to 2^31-1.
X */
X
X#define RNG_M 2147483647L  /* m = 2^31 - 1 */
X#define RNG_A 16807L
X#define RNG_Q 127773L	   /* m div a */
X#define RNG_R 2836L	   /* m mod a */
X
X/* 32 bit seed */
Xstatic int32u rnd_seed;
X
Xint32u get_rnd_seed ()
X{
X  return rnd_seed;
X}
X
Xvoid set_rnd_seed (seedval)
Xint32u seedval;
X{
X  /* set seed to value between 1 and m-1 */
X
X  rnd_seed = (seedval % (RNG_M - 1)) + 1;
X}
X
X/* returns a pseudo-random number from set 1, 2, ..., RNG_M - 1 */
Xint32 rnd ()
X{
X  register long low, high, test;
X
X  high = rnd_seed / RNG_Q;
X  low = rnd_seed % RNG_Q;
X  test = RNG_A * low - RNG_R * high;
X  if (test > 0)
X    rnd_seed = test;
X  else
X    rnd_seed = test + RNG_M;
X  return rnd_seed;
X}
X
X#ifdef TEST_RNG
X
Xmain ()
X{
X  long i, random;
X
X  set_rnd_seed (0L);
X
X  for (i = 1; i < 10000; i++)
X    (void) rnd ();
X
X  random = rnd ();
X  printf ("z[10001] = %ld, should be 1043618065\n", random);
X  if (random == 1043618065L)
X    printf ("success!!!\n");
X}
X
X#endif
END_OF_FILE
if test 3146 -ne `wc -c <'source/rnd.c'`; then
    echo shar: \"'source/rnd.c'\" unpacked with wrong size!
fi
# end of 'source/rnd.c'
fi
if test -f 'source/staffs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/staffs.c'\"
else
echo shar: Extracting \"'source/staffs.c'\" \(3989 characters\)
sed "s/^X//" >'source/staffs.c' <<'END_OF_FILE'
X/* source/staffs.c: staff code
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#ifdef USG
X#include <string.h>
X#else
X#include <strings.h>
X#endif
X
X
X/* Use a staff.					-RAK-	*/
Xvoid use()
X{
X  int32u i;
X  int j, k, item_val, chance, y, x;
X  register int ident;
X  register struct misc *m_ptr;
X  register inven_type *i_ptr;
X
X  free_turn_flag = TRUE;
X  if (inven_ctr == 0)
X    msg_print("But you are not carrying anything.");
X  else if (!find_range(TV_STAFF, TV_NEVER, &j, &k))
X    msg_print("You are not carrying any staffs.");
X  else if (get_item(&item_val, "Use which staff?", j, k, CNIL, CNIL))
X    {
X      i_ptr = &inventory[item_val];
X      free_turn_flag = FALSE;
X      m_ptr = &py.misc;
X      chance = m_ptr->save + stat_adj(A_INT) - (int)i_ptr->level - 5
X	+ (class_level_adj[m_ptr->pclass][CLA_DEVICE] * m_ptr->lev / 3);
X      if (py.flags.confused > 0)
X	chance = chance / 2;
X      if ((chance < USE_DEVICE) && (randint(USE_DEVICE - chance + 1) == 1))
X	chance = USE_DEVICE; /* Give everyone a slight chance */
X      if (chance <= 0)	chance = 1;
X      if (randint(chance) < USE_DEVICE)
X	msg_print("You failed to use the staff properly.");
X      else if (i_ptr->p1 > 0)
X	{
X	  i = i_ptr->flags;
X	  ident = FALSE;
X	  (i_ptr->p1)--;
X	  while (i != 0)
X	    {
X	      j = bit_pos(&i) + 1;
X	      /* Staffs.				*/
X	      switch(j)
X		{
X		case 1:
X		  ident = light_area(char_row, char_col);
X		  break;
X		case 2:
X		  ident = detect_sdoor();
X		  break;
X		case 3:
X		  ident = detect_trap();
X		  break;
X		case 4:
X		  ident = detect_treasure();
X		  break;
X		case 5:
X		  ident = detect_object();
X		  break;
X		case 6:
X		  teleport(100);
X		  ident = TRUE;
X		  break;
X		case 7:
X		  ident = TRUE;
X		  earthquake();
X		  break;
X		case 8:
X		  ident = FALSE;
X		  for (k = 0; k < randint(4); k++)
X		    {
X		      y = char_row;
X		      x = char_col;
X		      ident |= summon_monster(&y, &x, FALSE);
X		    }
X		  break;
X		case 10:
X		  ident = TRUE;
X		  destroy_area(char_row, char_col);
X		  break;
X		case 11:
X		  ident = TRUE;
X		  starlite(char_row, char_col);
X		  break;
X		case 12:
X		  ident = speed_monsters(1);
X		  break;
X		case 13:
X		  ident = speed_monsters(-1);
X		  break;
X		case 14:
X		  ident = sleep_monsters2();
X		  break;
X		case 15:
X		  ident = hp_player(randint(8));
X		  break;
X		case 16:
X		  ident = detect_invisible();
X		  break;
X		case 17:
X		  if (py.flags.fast == 0)
X		    ident = TRUE;
X		  py.flags.fast += randint(30) + 15;
X		  break;
X		case 18:
X		  if (py.flags.slow == 0)
X		    ident = TRUE;
X		  py.flags.slow += randint(30) + 15;
X		  break;
X		case 19:
X		  ident = mass_poly();
X		  break;
X		case 20:
X		  if (remove_curse())
X		    {
X		      if (py.flags.blind < 1)
X			msg_print("The staff glows blue for a moment..");
X		      ident = TRUE;
X		    }
X		  break;
X		case 21:
X		  ident = detect_evil();
X		  break;
X		case 22:
X		  if ((cure_blindness()) || (cure_poison()) ||
X		      (cure_confusion()))
X		    ident = TRUE;
X		  break;
X		case 23:
X		  ident = dispel_creature(CD_EVIL, 60);
X		  break;
X		case 25:
X		  ident = unlight_area(char_row, char_col);
X		  break;
X		case 32:
X		  /* store bought flag */
X		  break;
X		default:
X		  msg_print("Internal error in staffs()");
X		  break;
X		}
X	      /* End of staff actions.		*/
X	    }
X	  if (ident)
X	    {
X	      if (!known1_p(i_ptr))
X		{
X		  m_ptr = &py.misc;
X		  /* round half-way case up */
X		  m_ptr->exp += (i_ptr->level + (m_ptr->lev >> 1)) /
X		    m_ptr->lev;
X		  prt_experience();
X
X		  identify(&item_val);
X		  i_ptr = &inventory[item_val];
X		}
X	    }
X	  else if (!known1_p(i_ptr))
X	    sample (i_ptr);
X	  desc_charges(item_val);
X	}
X      else
X	{
X	  msg_print("The staff has no charges left.");
X	  if (!known2_p(i_ptr))
X	    add_inscribe(i_ptr, ID_EMPTY);
X	}
X    }
X}
END_OF_FILE
if test 3989 -ne `wc -c <'source/staffs.c'`; then
    echo shar: \"'source/staffs.c'\" unpacked with wrong size!
fi
# end of 'source/staffs.c'
fi
if test -f 'source/variable.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/variable.c'\"
else
echo shar: Extracting \"'source/variable.c'\" \(3525 characters\)
sed "s/^X//" >'source/variable.c' <<'END_OF_FILE'
X/* source/variable.c: Global variables */
X
Xchar *copyright[5] = {
X"Copyright (c) 1989-92 James E. Wilson, Robert A. Keoneke",
X"",
X"This software may be copied and distributed for educational, research, and",
X"not for profit purposes provided that this copyright and statement are",
X"included in all such copies."};
X
X#include <stdio.h>
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X
X/* Save the store's last increment value.  */
Xint16 last_store_inc;
X
X/* a horrible hack: needed because compact_monster() can be called from
X   creatures() via summon_monster() and place_monster() */
Xint hack_monptr = -1;
X
Xint weapon_heavy = FALSE;
Xint pack_heavy = FALSE;
Xvtype died_from;
Xint32 birth_date;
X
Xvtype savefile;			/* The savefile to use. */
X
Xint16 total_winner = FALSE;
Xint32 max_score = 0;
Xint character_generated = 0;	/* don't save score until char gen finished */
Xint character_saved = 0;	/* prevents save on kill after save_char() */
XFILE *highscore_fp;		/* File pointer to high score file */
Xint32u randes_seed;		/* for restarting randes_state */
Xint32u town_seed;		/* for restarting town_seed */
Xint16 cur_height,cur_width;	/* Cur dungeon size    */
Xint16 dun_level = 0;		/* Cur dungeon level   */
Xint16 missile_ctr = 0;		/* Counter for missiles */
Xint msg_flag;			/* Set with first msg  */
Xvtype old_msg[MAX_SAVE_MSG];	/* Last message	      */
Xint16 last_msg = 0;		/* Where last is held */
Xint death = FALSE;		/* True if died	      */
Xint find_flag;			/* Used in MORIA for .(dir) */
Xint free_turn_flag;		/* Used in MORIA, do not move creatures  */
Xint command_count;		/* Gives repetition of commands. -CJS- */
Xint default_dir = FALSE;	/* Use last direction for repeated command */
Xint32 turn = -1;		/* Cur turn of game    */
Xint wizard = FALSE;		/* Wizard flag	      */
Xint to_be_wizard = FALSE;	/* used during startup, when -w option used */
Xint16 panic_save = FALSE;	/* this is true if playing from a panic save */
Xint16 noscore = FALSE;		/* Don't log the game. -CJS- */
X
Xint rogue_like_commands;	/* set in config.h/main.c */
X
X/* options set via the '=' command */
Xint find_cut = TRUE;
Xint find_examine = TRUE;
Xint find_bound = FALSE;
Xint find_prself = FALSE;
Xint prompt_carry_flag = FALSE;
Xint show_weight_flag = FALSE;
Xint highlight_seams = FALSE;
Xint find_ignore_doors = FALSE;
Xint sound_beep_flag = TRUE;
Xint display_counts = TRUE;
X
Xchar doing_inven = FALSE;	/* Track inventory commands. -CJS- */
Xint screen_change = FALSE;	/* Track screen updates for inven_commands. */
Xchar last_command = ' ';  	/* Memory of previous command. */
X
X/* these used to be in dungeon.c */
Xint new_level_flag;		/* Next level when true	 */
Xint teleport_flag;		/* Handle teleport traps  */
Xint player_light;		/* Player carrying light */
Xint eof_flag = FALSE;		/* Used to signal EOF/HANGUP condition */
Xint light_flag = FALSE;		/* Track if temporary light about player.  */
X
Xint wait_for_more = FALSE;	/* used when ^C hit during -more- prompt */
Xint closing_flag = FALSE;	/* Used for closing   */
X
X/*  Following are calculated from max dungeon sizes		*/
Xint16 max_panel_rows,max_panel_cols;
Xint panel_row,panel_col;
Xint panel_row_min,panel_row_max;
Xint panel_col_min,panel_col_max;
Xint panel_col_prt,panel_row_prt;
X
X#ifdef MAC
Xcave_type (*cave)[MAX_WIDTH];
X#else
Xcave_type cave[MAX_HEIGHT][MAX_WIDTH];
X#endif
X
X#ifdef MAC
Xrecall_type *c_recall;
X#else
Xrecall_type c_recall[MAX_CREATURES];	/* Monster memories */
X#endif
X
X/* See atarist/st-stuff.c */
X#if defined(atarist) && defined(__GNUC__)
Xchar extended_file_name[80];
X#endif
END_OF_FILE
if test 3525 -ne `wc -c <'source/variable.c'`; then
    echo shar: \"'source/variable.c'\" unpacked with wrong size!
fi
# end of 'source/variable.c'
fi
if test -f 'util/map.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/map.c'\"
else
echo shar: Extracting \"'util/map.c'\" \(3021 characters\)
sed "s/^X//" >'util/map.c' <<'END_OF_FILE'
X/* this used to be in files.c, this is not a working program */
X
X/* Output dungeon section sizes					*/
X#define OUTPAGE_HEIGHT 44     /* 44 lines of dungeon per section       */
X#define OUTPAGE_WIDTH  99     /* 100 columns of dungeon per section    */
X
X/* deleted in favor of improved Map and Where commands */
X/* Prints dungeon map to external file			-RAK-	 */
Xprint_map()
X{
X  register int i, j, m, n;
X  register k, l;
X  register i7, i8;
X  char dun_line[MAX_WIDTH+1];
X  char *dun_ptr;
X  static vtype filename1 = "MORIAMAP.DAT";
X  vtype filename2;
X  char tmp_str[80];
X  FILE *file1;
X  static int page_width = OUTPAGE_WIDTH;
X  static int page_height = OUTPAGE_HEIGHT;
X
X  /* this allows us to strcat each character in the inner loop,
X     instead of using the expensive sprintf */
X  (void) sprintf (tmp_str, "File name [%s]: ", filename1);
X  prt(tmp_str, 0, 0);
X  if (get_string(filename2, 0, strlen(tmp_str), 64))
X    {
X      if (strlen(filename2) > 0)
X	(void) strcpy(filename1, filename2);
X      if ((file1 = fopen(filename1, "w")) == NULL)
X	{
X	  (void) sprintf(dun_line, "Cannot open file %s", filename1);
X	  prt(dun_line, 0, 0);
X	  return;
X	}
X      (void) sprintf(tmp_str, "section width (default = %d char):",
X		     page_width);
X      prt(tmp_str, 0, 0);
X      (void) get_string(tmp_str, 0, strlen(tmp_str), 10);
X      page_width = atoi(tmp_str);
X      if (page_width < 10)
X	page_width = 10;
X
X      (void) sprintf(tmp_str, "section height (default = %d lines):",
X		     page_height);
X      prt(tmp_str, 0, 0);
X      (void) get_string(tmp_str, 0, strlen(tmp_str), 10);
X      page_height = atoi(tmp_str);
X      if (page_height < 10)
X	page_height = 10;
X
X      prt("Writing Moria Dungeon Map...", 0, 0);
X      put_qio();
X
X      i = 0;
X      i7 = 0;
X      do
X	{
X	  j = 0;
X	  k = i + page_height - 1;
X	  if (k >= cur_height)
X	    k = cur_height - 1;
X	  i7++;
X	  i8 = 0;
X	  do
X	    {
X	      l = j + page_width - 1;
X	      if (l >= cur_width)
X		l = cur_width - 1;
X	      i8++;
X	      (void) fprintf(file1, "%c\n", CTRL('L'));
X	      (void) fprintf(file1, "Section[%d,%d];     ", i7, i8);
X	      (void) fprintf(file1, "Depth : %d (feet)\n\n   ",
X			     (dun_level * 50));
X	      for (m = j; m <= l; m++)
X		{
X		  n = (m / 100);
X		  (void) fprintf(file1, "%d", n);
X		}
X	      (void) fputs("\n   ", file1);
X	      for (m = j; m <= l; m++)
X		{
X		  n = (m / 10) - (m / 100) * 10;
X		  (void) fprintf(file1, "%d", n);
X		}
X	      (void) fputs("\n   ", file1);
X	      for (m = j; m <= l; m++)
X		{
X		  n = m - (m / 10) * 10;
X		  (void) fprintf(file1, "%d", n);
X		}
X	      (void) fprintf(file1, "\n");
X	      for (m = i; m <= k; m++)
X		{
X		  (void) sprintf(dun_line, "%2d ", m);
X		  dun_ptr = &dun_line[3];
X		  for (n = j; n <= l; n++)
X		    *dun_ptr++ = loc_symbol(m, n);
X		  *dun_ptr++ = '\n';
X		  *dun_ptr++ = '\0';
X		  (void) fputs(dun_line, file1);
X		}
X	      j += page_width;
X	    }
X	  while (j < cur_width);
X	  i += page_height;
X	}
X      while (i < cur_height);
X      (void) fclose(file1);
X      prt("Completed.", 0, 0);
X    }
X}
END_OF_FILE
if test 3021 -ne `wc -c <'util/map.c'`; then
    echo shar: \"'util/map.c'\" unpacked with wrong size!
fi
# end of 'util/map.c'
fi
if test -f 'util/monster.cng' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/monster.cng'\"
else
echo shar: Extracting \"'util/monster.cng'\" \(3702 characters\)
sed "s/^X//" >'util/monster.cng' <<'END_OF_FILE'
XFrom djgrabin@phoenix.Princeton.EDU Mon Nov 27 12:37:32 1989
XReceived: from Princeton.EDU by ernie.Berkeley.EDU (5.61/1.36)
X	id AA09548; Mon, 27 Nov 89 12:35:31 -0800
XReceived: from phoenix.Princeton.EDU by Princeton.EDU (5.58+++/2.25/mailrelay)
X	id AA03654; Mon, 27 Nov 89 14:42:43 EST
XReceived: by phoenix.Princeton.EDU (5.61/1.95)
X	id AA27562; Mon, 27 Nov 89 14:38:54 -0500
XDate: Mon, 27 Nov 89 14:38:54 -0500
XFrom: djgrabin@phoenix.Princeton.EDU (David Joseph Grabiner)
XMessage-Id: <8911271938.AA27562@phoenix.Princeton.EDU>
XTo: wilson@ernie.Berkeley.EDU
XSubject: Corrections to the monster dictionary
XStatus: RO
X
X
XI have now made the changes I mentioned to you before, plus a few more
Xwhich I discovered in the process.  My current monster dictionary has
X161 monsters changed from the original 4.87 copy.  I can send you a copy
Xof either my dictionary or the diffs if you want them.  However, since
Xyour dictionary is in a different form, and I have a different definition
Xof "monster," I would suggest that, if you do use my files, you use them
Xonly for reference.
X
XAnyway, here is my current list of changes.
X
X!is a definite bug;
X*has been changed.
X
XOK, even though they seem wrong:
XSinging, happy drunk moving 20+40+75 random
XAncient red dragon having maximum treasure.
XGreen ooze not moving.  This is obviously intentional.
X
XRandom movement:
XSome ants are 20%, others aren't.
XHuge brown bat 75%, four others are 20%.
X*!Giant fire and giant lightning bat should both be 20% or both be 40%.
X Long-eared, red, lightning changed to 40, huge brown left alone.
X*!Giant black centipede should not be 75%, should be 20%.
X*Fire elemental is 40%, fire spirit and earth spirit not random.
X All of these made 20.
X*Moaning spirit is 20%, banshee is 20% and 40%.
X Moaning spirit made 20+40.
X*Clear and bloodshot icky-things should be 40%.
X*Killer beetles vary; should they all be 20%?
XShould squint-eyed rogue be 20% random?
X*!Giant black scorpion should be 20%.
X*!Giant brown tick should be 20%.
X
XDoors:
X*Fire spirit cannot open doors, fire elemental can and shouldn't.
X*Should golems be able to open doors?
X*!Oozes shouldn't open doors.
X*!Spirit troll should open doors.
X
XPicking up objects:
X*!Earth spirit should pick up objects, water elemental shouldn't.
X*!Warrior shouldn't unless all people do.
X
XTreasure:
X*!Scruffy-looking hobbit should carry gold as well as objects.
XWhy don't quasits carry gold?
X*!Mature green dragon should be 60+90+2d2, not 60+90+1d2.
X*!Orc warrior and ogre mage should be 90, like other o's.
X*Seedy-looking human 1d2 but nasty little gnome only 90, should be 1d2?
X*!Berzerker should be 1d2, not 60; ninja should be 1d2, not 60+90.
X*Black knight should be 1d2; sorceror increased to 60+90+1d2, to be
X consistent with liches.
X*Should ordinary troll be 60+90, like other trolls?
X
XSpell frequency:
X*!Ancient white is the weakest ancient dragon, should be 9 like ancient green.
X*!Moaning spirit should be 15, like other ghosts.
X*!Orc shaman is 5, ogre mage is 6 and should be 5 or less.
X*Should necromancer be 3 rather than 2, since sorceror is 3?
X
X*!Silver jelly and rot jelly shouldn't be harmed by cold.
X
XWhy are nagas harmed by poison?
X
XAcid:
X*Should flesh golem really be harmed by acid?
X*Should green jelly, green worm mass really be harmed by acid?
X
XBlue light:
X*Why are flesh golem, giant clear ant, black ooze harmed by light?
X*!Rot jelly should be harmed by blue light.
X*!Cloud giant should not be.
XShould giant purple worm be harmed, like other worms?
X*Should all undead, or all intelligent undead, be harmed?
X (Changed to harm L,W,V,G, and spirit troll, not M,s,z.)
X
X*Should it be possible to charm/sleep quasits?
X
X*!White dragon bat should not be seen by infravision.
X
END_OF_FILE
if test 3702 -ne `wc -c <'util/monster.cng'`; then
    echo shar: \"'util/monster.cng'\" unpacked with wrong size!
fi
# end of 'util/monster.cng'
fi
if test -f 'util/weapons/mkallwpn.lst' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/weapons/mkallwpn.lst'\"
else
echo shar: Extracting \"'util/weapons/mkallwpn.lst'\" \(1408 characters\)
sed "s/^X//" >'util/weapons/mkallwpn.lst' <<'END_OF_FILE'
XAwl-Pike                      |
XBacksword                     |
XBall and Chain                |
XBastard Sword                 |
XBattle Axe (Balestarius)      |
XBattle Axe (European)         |
XBeaked Axe                    |
XBroad Axe                     |
XBroadsword                    |
XCat-O-Nine Tails              |
XCutlass                       |
XDagger (Bodkin)               |
XDagger (Main Gauche)          |
XDagger (Misercorde)           |
XDagger (Stiletto)             |
XExecutioner's Sword           |
XFauchard                      |
XFlail                         |
XFoil                          |
XGlaive                        |
XHalberd                       |
XJavelin                       |
XKatana                        |
XLance                         |
XLongsword                     |
XLucerne Hammer                |
XMace                          |
XMace (Lead filled)            |
XMorningstar                   |
XPike                          |
XRapier                        |
XSabre                         |
XSmall Sword                   |
XSpear                         |
XThrusting Sword (Baselard)    |
XThrusting Sword (Bilbo)       |
XTwo Handed Great Flail        |
XTwo Handed Sword (Claymore)   |
XTwo Handed Sword (Espadon)    |
XTwo Handed Sword (Flamberge)  |
XTwo Handed Sword (No-Dachi)   |
XTwo Handed Sword (Zweihander) |
XWar Hammer                    |
XWooden Club                   |
END_OF_FILE
if test 1408 -ne `wc -c <'util/weapons/mkallwpn.lst'`; then
    echo shar: \"'util/weapons/mkallwpn.lst'\" unpacked with wrong size!
fi
# end of 'util/weapons/mkallwpn.lst'
fi
if test -f 'util/weapons/weapon.lst' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/weapons/weapon.lst'\"
else
echo shar: Extracting \"'util/weapons/weapon.lst'\" \(3411 characters\)
sed "s/^X//" >'util/weapons/weapon.lst' <<'END_OF_FILE'
X         Name                Symbol   Price  Weight   Damage  Level
X           V                   V        V      V	V       V
XAwl-Pike                      '/'      340    160      1d8	8
XBacksword                     '|'       60     95      1d9	7
XBall and Chain                '\'      200    150      2d4     20
XBastard Sword                 '|'      350    140      3d4     14
XBattle Axe (Balestarius)      '\'      500    180      2d8     30
XBattle Axe (European)         '\'      334    170      3d4     13
XBeaked Axe                    '/'      408    180      2d6     15
XBroad Axe                     '\'      304    160      2d6     17
XBroadsword                    '|'      255    150      2d5	9
XCat-O-Nine Tails              '\'       14     40      1d4	3
XCutlass                       '|'       85    110      1d7	7
XDagger (Bodkin)               '|'       10     20      1d4	1
XDagger (Main Gauche)          '|'       25     30      1d5	2
XDagger (Misercorde)           '|'       10     15      1d4	0
XDagger (Stiletto)             '|'       10     12      1d4	0
XExecutioner's Sword           '|'      850    260      4d5     40
XFauchard                      '/'      376    170      1d10    17
XFlail                         '\'      353    150      2d6     12
XFoil                          '|'       35     30      1d5	2
XGlaive                        '/'      363    190      2d6     20
XHalberd                       '/'      430    190      3d4     22
XJavelin                       '/'       18     30      1d4	4
XKatana                        '|'      400    120      3d4     18
XLance                         '/'      230    300      2d8     10
XLongsword                     '|'      300    130      1d10    12
XLucerne Hammer                '/'      376    120      2d5     11
XMace                          '\'      130    120      2d4	6
XMace (Lead filled)            '\'      502    180      3d4     15
XMorningstar                   '\'      396    150      2d6     10
XPike                          '/'      358    160      2d5     15
XRapier                        '|'       42     40      1d6	4
XSabre                         '|'       50     50      1d7	5
XSmall Sword                   '|'       48     75      1d6	5
XSpear                         '/'       36     50      1d6	5
XThrusting Sword (Baselard)    '|'       80    100      1d7	5
XThrusting Sword (Bilbo)       '|'       60     80      1d6	4
XTwo Handed Great Flail        '\'      590    280      3d6     45
XTwo Handed Sword (Claymore)   '|'      775    200      3d6     30
XTwo Handed Sword (Espadon)    '|'      655    180      3d6     35
XTwo Handed Sword (Flamberge)  '|'     1000    240      4d5     45
XTwo Handed Sword (No-Dachi)   '|'      675    200      4d4     45
XTwo Handed Sword (Zweihander) '|'     1000    280      4d6     50
XWar Hammer                    '\'      225    120      3d3	5
XWooden Club                   '\'        1    100      1d3	0
X
X
X
XHoly Avenger:  (HA)
Xincrease strength (P1), slay evil, slay undead, sustain stat (P1),
Xsee invisible
X
XDefender:  (DF)
Xstealth, regeneration, resist fire, resist acid, resist cold,
Xresist lightning, free action, see invisible, feather fall
X
XSlay Monster:  (SM)
Xslay monster, see invisible
X
XHelmet of the Magi:  (0x01380008)
Xincrease intelligence (P1), resist fire, resist acid, resist cold,
Xsee invisible
X
XAmulet of the Magi:  (0x01800040)
Xfree action, see invisible, searching
END_OF_FILE
if test 3411 -ne `wc -c <'util/weapons/weapon.lst'`; then
    echo shar: \"'util/weapons/weapon.lst'\" unpacked with wrong size!
fi
# end of 'util/weapons/weapon.lst'
fi
echo shar: End of archive 37 \(of 39\).
cp /dev/null ark37isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
