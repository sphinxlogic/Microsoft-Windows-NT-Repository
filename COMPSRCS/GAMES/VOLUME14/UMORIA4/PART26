Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i058:  umoria4 - single player dungeon simulation (ver. 5.5), Part26/39
Message-ID: <3422@master.CNA.TEK.COM>
Date: 22 Aug 92 22:13:27 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1705
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 58
Archive-name: umoria4/Part26
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 26 (of 39)."
# Contents:  OOChanges.2 source/misc1.c vms/moria.opt
# Wrapped by billr@saab on Thu Aug 20 09:11:33 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'OOChanges.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'OOChanges.2'\"
else
echo shar: Extracting \"'OOChanges.2'\" \(28159 characters\)
sed "s/^X//" >'OOChanges.2' <<'END_OF_FILE'
Xseveral spelling errors in CJS code
Xmisc1.c: forgot to change magic_treasure code when changed subvals a couple
X	of days ago for wands/staffs/amulets/rings
Xexterns.h, files.c, misc2.c, types.h: wrote new stat code, all stat bugs
X	fixed now, 6 stat values now, get_dis_stat() eliminated, new function
X	modify_stat(),
Xmisc2.c: get_obj_num changed, to increase probability of getting higher
X	level objects
Xmisc1.c, treasur1.c: had to change gain stat bits, the low 6 order bits of
X	treasure flags, because changed the order earlier
X---------------- 10/11
Xall: changed all 4 or less case switch statements except for one large one
X	in generate.c to nested if statements, this is smaller and faster
X---------------- 10/12
Xdungeon.c, generate.c, moria1.c: new_spot moved from dungeon to generate
X	because alloc_mon and place_win_mon use character position, fixed
X	minor new_spot bug
Xconstants.c, misc2.c, dungeon.c: bst_stat() can not call prt_stat, changed
X	to set py.flags.status, new stat change flags defined, and stat
X	print code added to dungeon.c
Xcreature.c: many duplicate disturb/strcat/msg_print brought outside the
X	switch statement in mon_cast_spell
Xall: changed all unlite_spot() calls to lite_spot() calls, changed
X	'if (test_light()) lite_spot()' code to just call lite_spot, this
X	fixes many subtle bugs, mostly dealing with mon vis to infravision,
X	unlite_spot code deleted
Xfiles.c, misc2.c: added stat_adj(A_INT) to srh which was wrong
Xmisc2.c, spells.c, moria1.c, types.h: id_stat() and hid_stat[] eliminated
X	no more hidden stat values, display arg dropped from bst_stat()
Xfiles.c, misc2.c: hex values replaced with constants
X----------------- 10/14
Xconstants.h, store1.c: increased store turn around from 4 (avg 2.5)
X	to 9 (avg 5), changed store_main() to always call store create/destroy
X	regardless of bounds, lowered values of bounds MIN and MAX
X--------------- 10/18
Xmoria2.c: when open chest, clear TR_CURSED flag, which just also happens to be
X	monster win flag, to prevent easy wins
Xconstants.h, misc1.c->wizard.c: replaced remaining hex magic numbers with
X	manifest constants
Xdungeon.c: added code that gives a player a chance of noticing that items
X	in inventory/equipment list are magical, the chance is much higher
X	for warriors than for magi
X--------------- 10/19
Xdungeon.c: ^P^P did not clear the line with the pause_line message
Xmisc2.c: prt_state() did not clear all 3 digits of repeat counts
Xall: moved lots of procedures around to increase number of static fuctions,
X	also made sure every C file less than 60K
Xcreate.c, extern.h, misc2.c, spells.c, variables.c: change way that mhp
X	are calculated, new function calc_hitpoints(), new array player_hp[]
X	which contains player mhp for each level
Xextern.h, main.c, misc2.c, potions.c, spells.c: change way that cmana are
X	calculated, new function calc_mana(), called whenever gain level,
X	lose level, or learn/forget spells
Xextern.h, main.c, misc2.c, spells.c: change the way that spells are learned
X	and lost, learn_spell/learn_prayer deleted, new function calc_spells,
X	new spell type state forgotten, new var spell_forgotten, etc.
X-------------------- 10/20
Xmonsters.c: made spirit troll into 'G', made invisible, pickup, carrys obj,
X	added drain wisdom attack, added drain intelligence attack to green
X	glutton ghost
Xall: moved all msg_print(NULL) calls into io.c, specifically, clear_screen(),
X	erase_line() and prt()
Xmoria2.c, spells.c: two places that called test_light to see if monster or
X	moving object lit were wrong, changed to eliminate check of fm
Xcreature.c: update_mon() failed when hallucinating, changed print(cchar,...)
X	to lite_spot() call
Xvariables.c: adjusted call stat adjustments, mainly to make priest harder,
X	gave priest negative str adjust, inc expfact from 10% to 20%
Xmisc2.c: new funcs prt_int() and prt_long(), same as prt_num/prt_lnum()
X	except no string argument, ": " moved into prt_num/prt_lnum string
Xspells.c: all wands now have limits on range
Xmonsters.c: doubled Balrog eye sight from 20->40, evil iggy from 20->30
Xeat.c: increase hp gain for 22/23/24, increase hp loss for 27
Xconstant.c, eat.c, potions.c, scrolls.c, staffs.c, treasur2.c wands.c:
X	eliminate store bought flag, only gain exp when use an item if the
X	use identifies the item
X----------------- 10/23
Xmagic.c, wands.c: spell/wand damage did not match
Xcreature.c: monster stuck door bashing got sign of i_ptr->p1 wrong
Xrecall.c: change corrosive gases to poison gases
Xexterns.h, moria1.c: draw_block(), minmax(), maxmin() deleted, minmax and
X	maxmin calls were unnecessary, draw_block only called from one
X	place, sub2_move_light combined with sub1_move_light,
X	sub4_move_light combined with sub3_move_light,
Xcreature.c: fix mon_move() so that creatures that never move increment their
X	r_attack[0] when standing next to the player, for Quylthulgs
Xspells.c: detect object and detect treasure set tl, which could also light up
X	monsters, they now set fm
X----------------- 10/24
Xspells.c: can not gain exp by disarming traps created by a scroll
Xtypes.h, magic.c, prayer.c, variable.c, misc2.c, constant.h: removed sname
X	from spell_type since it was a trivial value, changed sexp from 16
X	bits to 8 by dividing value by 4, saves about 310 bytes
Xmany files: eliminated long stretches of blanks in strings, remove repeated
X	chars from strings, typically " : ", saves over 1K of data size
X--------------- 10/25
Xspells.c: aiming a ball type wand/spell at a 1-thick wall resulted in damage
X	to creatures on the other side of the wall, now it doesn't
Xmisc2.c: inc_stat changed so that player gains 1/6 to 1/3 of the distance
X	from the max 18/100 stat, 0 to 100 takes 13 gain stat potions,
X	dec_stat changed so that player loses 1/4 to 1/2 of the distance
X	from the max 18/100 stat, 100 to 0 takes 13 lose stat potions
Xmisc2.c: print_spells() modified so that spell are always listed with the
X	same letter, i.e. the letter does not depend on whether or not
X	you know the spells that precede it
X--------------- 10/26
Xdeath.c: day string was size 11 should be 12
Xdungeon.c: make 'magik' detect same chance for each class, need to set
X	i_ptr = &inventory[INVEN_LIGHT] before testing player_light,
X	this could cause the light to go off permanently
Xmisc2.c: calc_mana and calc_spells use p_prt->lev - class[].first_spell_lev-1
X	instead of just the player lev
Xtypes.h, variable.c: add new field to class info, first level in which the
X	player can learn a spell, used immediately above
Xvariable.c: green glutton ghost no longer drains int
Xmisc2.c: print 'welcome to level message' before learning spells
X--------------- 10/28
Xconfig.h, externs.h, dungeon.c, wizard.c: version info put in a help file,
X	game_version() function deleted
Xfiles.c: removed obsolete print_map() and print_monster() code
Xtreasur1.c: made ring of WOE decrease wisdom, to balance ring of stupidity,
X	removed trailing ^ secret symbols which made no sense, changed
X	constant values from known2 to known1, such as ring of lordly protect
X	armor class values
Xstore1.c, store2.c, externs.h, types.h: add storenice feature by Dan Berstein,
X	if (good bargain > 3 * bad bagains + 20) then always get final price
X	in that store, two new functions, noneedtobargain() and updatebargain()
Xmoria1.c: fixed wear command so that it prints inven letter of item removed,
X	and equip letter of item worn, added extra param to remove()
Xgenerate.c, moria1.c, moria2.c, types.h: added an 'lr' flag to cave_type,
X	this is set for every space in or next to a room, lr is true for
X	lit rooms, and false for dark rooms, find_light() function deleted
X	as it was no longer necessary, twall lights spots that have lr set
Xmoria1.c, moria2.c: decrease search chances if hallucinating, decrease
X	disarm chances if hallucinating, look fails completely
Xeat.c: print message "You feel drugged." for mushroom of hallucination
Xmoria1.c: eliminate unnecessary in_bounds() calls
Xio.c: check to make sure tabs are all 8 character apart
Xtreasur2.c: made object_ident array bss
Xmisc2.c, moria1.c: fix calc_bonuses() so that it when wielding heavy bonuses,
X	it subtracts the weight penalty from dis_th (display to hit),
X	check_strength() modified to call calc_bonuses()
Xmisc1.c: fixed compact_objects() and compact_monster() so that they update
X	screen when deleting objects/monsters
Xcreature.c, spells.c: put message in aggravate_monster(), took out redundant
X	mesasge in creature.c
Xmoria2.c: modify py_attack(), inven_throw() and py_bash() to make it more
X	difficult to hit monsters which are not lit
X---------------- 10/31
Xmoria1.c: sub3_move_light() modified so that it does not print @ when in find
X	mode
Xrecall.c: had an 'i == 11 | i == 18' which should have been a ||
X	printed out 11st,12nd,13rd levels incorrectly, now uses 'th'
Xmoria1.c: fix see_wall, it assumed walls are # which is not true for PC/Atari
Xspells.c: breath() could do damage on the other side of walls, added an los()
X	call to prevent this
Xmoria1.c: area_affect treated 'potential corner' and 'branching side corridor'
X	identically, which is wrong, added see_nothing() so that these could
X	be handled separately
X---------------------- 11/1
Xmoria1.c: when wearing object and must remove current object, fix code to
X	use inven_check_num to see it is possible; in wear code, when remove
X	old object check to see if inven_ctr increases before actually
X	increasing wear_high
Xconstants.h, misc2.c, moria1.c, store1.c, store2.c, treasure1.c, treasure2.c:
X	change definition of subval 192 so it can be used for torches, it
X	only stacks with others if have same p1 value, but it is always
X	treated as a single object, change ITEM_* definitions in constant.h
X	to match new definition, fix all code fragments that test subvals
Xdesc.c: change to use new ITEM_ definition
Xmoria1.c: fixed the potential corner/corridor intersection bug in the find
X	code again, except this time it works better than the original code
X------------------------------ 11/3
Xvariables.c: decrease priestly HP bonus from 3 to 2
Xmoria1.c: fixed wear code bug, called inven_check_num() with item not slot
X----------------- 11/4
Xmoria2.c: in tunnel(), print message if player tries to dig with hands
Xmoria2.c: several places where object/treasure picked up did not clear
X	c_ptr->fm, this is necessary since it might be set by detect spell
X--------------- 11/7
Xmoria1.c: fixed find_init so that moves straight into a corner would
X	correctly run around the corner
Xmoria1.c: changed the examine potential corner code in area_affect(), it
X	would run into rooms if corridor entrance next to a wall, at least
X	it doesn't do that for lighted rooms anymore
X----------------- 11/8
Xprayer.c: in remove curse spell, only clear flag for items that are
X	wielded or worn
Xio.c: truncate strings at col 79 instead of 80 if BUGGY_CURSES defined
Xmoria1.c: print weights in show_inven and show_equip at col 71 not 72
Xio.c, misc1.c, moria1.c: change highlight mode for walls to display '%'
X	instead, this is much more portable that original code that used
X	standout mode and the high character bit, changed print(),loc_symbol(),
X	and see_wall()
Xhelp.c: change help documentation for % character
Xwizard.c: modify wizard_create and change_character functions, add whitespace,
X	exit if get_string fails (i.e. typing ESCAPE exits), modify get_string
X	limits to more reasonable values, remove switch for setting tchar
Xmoria_wiz_help, moria_owiz_help: correct errors in command list
Xdeath.c: add msg_print(NULL) after show_inven() in print_tomb() so that
X	inventory can't	accidentally scroll of screen before exiting
Xcreature.c, moria2.c, spells.c: can't call prt_experience() in mon_take_hit()
X	as this gives "new level" message before "killed monster", move prt_exp
X	calls to after msg_print at everyplace that calls mon_take_hit()
Xdungeon.c: modified repeat count code so that can edit the number entered
X	leave cursor on msg line while entering repeat count
Xmoria2.c: change summon_object() so that it will only create objects within
X	los of point where monster dies
X--------------- 11/9
Xstore1.c: stacking code in store_check_num() and store_carry() did not
X	handle torches correctly, changed to be the same as inven_check_num
X	code in moria2.c
Xwizard.c: fixed mistake in change_character(), put *tmp_str != '\0' test
X	in inside if statement, not outside one
Xexterns.h, misc2.c, moria2.c: fix printing of spell characters from get_spell,
X	print_spells changed consec TRUE to nonconsec == -1 for consecutive
X	case, otherwise spells start with nonconsec=='a', added new arg to
X	get_spells() first_spell which becomes nonconsec when call print_spell
Xwizard.c: move 'gold' from end of change_character to right after 'mana'
X	since it is more frequently used than the rest
Xmisc2.c: alloc_object(), fix it so that objects are not created underneath
X	the player, this was a problem for rubble and traps
Xmisc1.c: allow sling ammo to be enchanted in magic_treasure()
Xstore1.c: fix search_list() call for ammo in item_value(), was passing 1 ?!?
X	instead of correct subval
Xtreasur2.c: subval for spike wrong, change from 192 to 193
Xmisc1.c: remove see invisible from slay monster arrows, since it doesn't make
X	sense
Xvariable.c: change blows_table entry for STR/W .5-.7 and DEX 10-18 from one
X	to two, the value of one made things too difficult for low level mages
Xmonsters.c: for all monsters which used to be sleep value of 1 (old style),
X	change their new style sleep values from 0 to 1
Xrecall.c: stupid typo, change CM_CARRY_OBJ|CM_CARRY_OBJ to ..OBJ|CM_CARRY_GOLD
X---------------- 11/10
Xmoria2.c: disarm() had signs switched for trap chances, "tot - 100 + level"
X	changed to "tot + 100 - level"
Xvariable.c: change "tin plated" to "tin-plated" and etc.
X----------------- 11/13
Xsave.c: changes to get the save code working again
Xmoria2.c: when move onto a trap, instead of restoring confused count, should
X	increment it by the old value, since the trap may have set it
Xgenerate.c: for type 2 rooms, make them dark below level 25, not 30
Xmoria2.c: when close a door, print "Something" instead of monster name if
X	the monster blocking the door is invisible
Xmoria2.c: in tunnel(), make the digging chance for non digging weapons equal
X	to their max damage + tohit bonus instead of proportional to weight,
X	the old code made lances better for digging than shovels
Xmoria2.c: change py_bash() chance, make it a function of monster hp +
X	monsters average max hp instead of level
X--------------- 11/15
Xsave.c, undef.c: restore_stats function eliminated, replaced by call to read
X	py.stats from file, other fixes to get restore code working
Xcreature.c: if creature never moves, kill it if it happens to be in a wall
X	instead of moving it out of the wall
Xgenerate.c: everywhere that TMP1_WALL is used, must also set fopen FALSE
X	so that place_object(), vault_monster() etc will work correctly
Xprayer.c: removed cure_blindness() and cure_confusion() from Holy Word spell,
X	since could not pray while blind/confused
Xsignals.c, io.c, externs.h: eliminate redundant definition of signal() in
X	signals.c, also eliminate suspend_handler and assignment to it from
X	signal(), make suspend() non-static
Xmoria2.c: in look(), put blind and image tests before get_alldir()
Xmoria2.c: in look() change [y to recall] to [(r)ecall]
Xcreature.c, externs.h, generate.c, misc1.c, monsters.c, moria1.c, moria2.c,
X	save.c, spells.c, types.h, constant.h: change m_list from linked list
X	to a linear list, muptr deleted, monster_type nptr field deleted,
X	function pushm deleted, now all scans of m_list go from mfptr (which
X	always points at last element) to MON_MINIX == 2
Xmisc1.c: compact_monster no longer calls prt_map(), which is unnecessary
X--------------- 11/16
Xeat.c: fixed restore charisma mushroom, print 'stops' instead of 'starts'
Xmoria2.c: fix calculation of avg_max_hp in py_bash(), didn't check CD_MAX_HP
Xmonsters.c: spirit troll too hard to hit when can't be seen, lower AC 56->40
Xtreasure2.c: fixed scare_monster trap, the subtype value was wrong 63->99,
X	and the level needed 100 added to it
Xmisc2.: fix get_spells(), must add first_spell to *sn instead of subtracting
X	from spell[i]
Xcreature.c: in mon_move, return immediately if creature is killed because it
X	is in rock
X---------- 11/17
Xexterns.h, spells.c, scrolls.c, prayer.c, staffs.c: change dispell_creature()
X	to dispel_creature()
Xspells.c: dispel_creature uses m_ptr->ml after calling mon_take_hit() which
X	is wrong, now save value before calling mon_take_hit()
Xmoria2.c: turn find_flag into a counter, when it reaches 100, exit find mode
X	with message "You stop running to catch your breath.", prevents
X	infinite loop
Xgenerate.c: fixes to help prevent isolated rooms, in build_tunnel() make
X	sure tunnel has gone at least 10 spaces from start before stop it,
X	in cave_gen(), copy [yx]loc[0] to [yx]loc[k] so that can build tunnel
X	from last room to first
Xspells.c: light_line() called lower_monster_name() which is wrong, change
X	to monster_name() call
Xexterns.h, creature.c, moria2.c, spells.c: removed seen argument from
X	mon_take_hit, as it was used inconsistently, only get credit for a
X	kill if monster is visible when killed
Xsave.c, dungeon.c: call disturb in save_char() to turn off searching and
X	resting, remove search_off call in dungeon.c as is no longer needed
Xvariable.c: remove initialized data for py and old_msg since were (mostly)
X	zero, set f_ptr->food and f_ptr->food_digested in main.c
Xconstant.h: delete some unused constants, rearrange the order of a few others
X------------ 11/18
Xvariables.c, externs.h, monsters.c, treasure2.c, save.c: every variable
X	written to save file needs definate size, can not be just 'int',
X	also spell_forgotten now read/written
X-------------- 11/20
Xspells.c: sleep_monsters1() did not set NO_SLEEP info for monster memory
Xexterns.h, moria1.c: changed new_spot to accept short pointers since
X	char_row and char_col are now shorts
Xcreatures.c, spells.c: multiply_monster(), removed slp parameter since it was
X	always FALSE, added monptr, to fix the m_list bug
Xcreatures.c: new m_list code fails when call delete monster from within
X	creatures(), fixed it by changing some calls to delete_monster()
X	to call delete_monster() only if the dead monster is between the
X	current monster and mfptr, otherwise, call fix1_delete_monster()
Xexterns.h, creatures.c, spells.c: breath() has new argument monptr, to fix
X	the m_list bug
Xexterns.h, creatures.c, spells.c: two new functions, fix1_delete_monster()
X	and fix2_delete_monster() which together equal delete_monster,
X	these are called from within creatures() when a monster is killed
Xmany: eliminate the fopen field since I had 5 bitfields in the cave structure,
X	and it is much easier to only save 4, added a BLOCKED_CORR case for
X	secret/closed/locked/stuck doors and rubble, all code that used
X	to test fopen now tests fval, most code that used to set fopen is
X	now gone since it was redundant with fval setting code
Xmoria2.c: fixed disarm() so that if there is a valid trap to disarm, it will
X	print "Something/monster_name is in the way!" just like close door."
Xgenerate.c: place_stairs() could place them on the boundary, make sure
X	that x/y can never be 0 or cur_xx-1, also, in town_gen(), call place_
X	boundary() before place_stairs(), looks better, though not necessary
Xmoria2.c: fixed openobject() so that if there is something to open, it will
X	print an message just like closeobject if there is a monster in the way
Xsave.c: fix another save file problem, noscorefile defined as int in get_char,
X	just eliminated it and use noscore instead
X--------------------------- 11/22
Xmoria2.c: fix1_delete_monster() has to set m_ptr->hp to -1
Xcreature.c: monster eating code checked monster exp wrong, was using cptr
X	to index into the c_list
Xcreature.c: in creatures(), call fix2_delete_monster if hp < 0
Xmoria2.c, spells.c: dragon breath, wand bolts, wand balls, and thrown objects
X	were visible even when blind, added checks, only print them if can see
Xmoria2.c: tunnel(), print message "* is in the way" if there is a monster
X	in the spot where the player is trying to tunnel
X-------------- 11/23
Xsave.c: player_hp was not saved/restored, total_winner and panic_save were not
X	restored
X------------- 11/27
Xmoria2.c: in tunnel, add the weapon damage to its digging ability
Xcreate.c: get_history(), clear the history strings before writing them with
X	new values, to get rid of old strings
Xvariable.c: for background strings, change "1st child" to "first child"
Xstore2.c: add parameter to get_haggle() last_offer, in sell_haggle and
X	purchase_haggle must set new_offer to 0, in get_haggle only allow
X	incremental bid if new_offer == last_offer, i.e. at least one previous
X	bid has been made
Xdungeon.c: in main loop, call creatures(FALSE) to light/unlight creatures
X	when ever player_light value changes
X---------- 11/28
Xsave.c: new save code, to reduce size of save file, and to make the savefiles
X	portable
Xconstant.h, desc.c, generate.c, misc1.c, misc2.c, moria2.c, save.c:
X	changed the t_list from a linked list into a linear array of entries,
X	just like the previous m_list change, new constant MIN_TRIX,
X	all pusht calls changed to delete_object where ever appropriate, etc.
X---------- 11/29
Xmisc1.c: increase p1 value for crowns of seeing by multiplying by 5
X----------- 12/4
Xcreatures.c: change stealth code, instead of randint(10) < stl, it now cubes
X	randint(64) and compares against 1 << (17 - stl), the result is that
X	a change of one in stl always decreases monster notice chance by 80%,
X	and perfect stealth is impossible
Xwizard.c: allow wizard to enter any stealth between -1 and 17
Xsave.c: extensive changes to save code competed, save files are now xor
X	encrypted, and are supposedly portable, all savefile protection code
X	is gone
X---------- 12/5
Xsave.c, undef.c, misc1.c: fix a few lint errors
Xchanged version number to 5.0.8 and release the sources
Xcreature.c: changed stealth code, amount monster woken by from 100 to 125
X	(used to be 75 before 12/4)
X-------- 12/6
Xspells.c, creature.c: changed the way wall building wands work again,
X	kill creature if it never moves, otherwise do a little damage,
X	if creature can not move out of rock in mon_move, then do more damage
X	and remove the wall ontop of the creature
Xvarious: check use of "?", especially in get_check() and verify() prompts,
X	verify changed to replace the period with a question mark
Xspells.c, creature.c, misc1.c: breath(), update_mon(), and loc_symbol()
X	changed to use blind status bit instead of blind counter, this
X	helps make the display look better, i.e. nothing disappears until
X	blindness takes affect in dungeon.c
Xmonsters.c: more monster fixes from DJG
Xmonsters.c, misc1.c, moria2.c, treasur1.c: change (SM) to (SA),
X	slay monster to slay animal
Xmonsters.c: set the new 'animal' bit correctly for all monsters
Xrecall.c: change 'unnatural creature' to 'natural creature', change a few
X	constants to defines
Xsave.c: add error exits to every loop/array index in the get_char()
X	routine to prevent crashes due to bad save files
Xstore1.c: in item_value, set value to zero if known cursed, this prevents
X	store from buying known cursed items
X------------ 12/7
Xstore2.c: remove switches in prt_comment*() functions, replace with table
X	look up to get proper string, saves much code space
Xcreature.c: changed stealth code again, if resting/paralyzed monster has a
X	chance of noticing once every 50 turns instead of never like before,
X	change 64 to 1024, and 17 to 29 for a better distribution
Xconstant.h, save.c: read noscore variable from savefile of dead character, now
X	only read/write noscore for live characters, changed patch_level to
X	9 so that old savefiles can still be read
Xsave.c: in get_char(), the loop error prevention code was missing two gotos
Xstore2.c: get_haggle(), when check for valid first use of incremental haggle,
X	ignore leading spaces in the string
Xmoria2.c: add_food() should increment slow value, not just set it when bloated
Xsave.c: when can't create savefile, test for from_savefile before giving
X	wizard message "Overwrite old?", when exit in wizard mode do the
X	"readable to all?" check after closing the file
Xsave.c: from_savefile set wrong, should always be set if have read from a file
X	not just when a complete character is read
Xmoria2.c: bash(), do not put character off balance if bash is successful
Xmisc2.c: get_spell(), instead of beeping for unknown spell, print a message
Xrecall.c: for monsters with sleep value of 0, could never learn that fact,
X	change it so that this will be known if have killed 10 of them
X-----12/9
Xdungeon.c: call disturb when player takes poison damage, or starvation
X	damage
Xvariable.c: change the three doors from 'a ...' to '& ...', needed because
X	of wall-to-mud wand
Xwizard.c: create_object wrong, was calling popt() then delete_object() then
X	setting c_ptr->tptr, this fails because the delete objects will move
X	the location (in t_list) of the just created object will change
Xtreasur2.c: change 'nothing' item to be stackable, so that it can be safely
X	picked up
Xsave.c: was calling store_maint before objects were reidentified, this caused
X	stores to end up with multple entries for stackable identified items
Xexterns.h, misc2.c: new function inven_check_weight(), check toosee whether
X	picking up an object will change the players speed
Xmoria2.c: carry(), if picking up an object would slow you down, prompt with
X	question "Exceed your weight limit?" to give player a choice
Xmoria2.c, misc1.c: only show rock types in look() if highlight_seams option
X	is set, also change option text from "highlight" to "HL and notice"
Xspells.c: in fire_bolt() and fire_ball(), set recall info if monster takes
X	extra damage because of weakness or reduced damage because of breath,
X	in dispel_creature() set EVIL/UNDEAD flag if creature hurt,
X	in turn_undead() set UNDEAD if creature hurt, in drain_life() set
X	CD_UNDEAD if creature not hurt
Xrecall.c: "may carry one or two treasures" needs the plural, but the others
X	remain singular/collective
X------------- 12/11
Xcreature.c: stealth value changed again from 125 to 100
Xwizard.c, variable.c: change rogue base stealth from 4 to 5, let wizard set
X	stealth to 18
Xmonster.c: white worm mass sleep value from 10 to 1, crystal ooze 60 -> 1
Xcreature.c: in drain mana spell, if r1 greater than cmana, then set r1
X	equal to cmana to limit creature's hp gain
Xrecall.c: when print out creature attacks, exit loop if i >= 4, caused
X	problems for umber hulk, etc. which have 4 attacks
Xstore1.c: instead of destroying all single stackable objects, only destroy
X	one half on average (randint(number)), makes store 1 and 5 inventories
X	look better, oil is much more common, identify a little more common
Xtreasure2.c: accidentally change blank_treasure tval earlier, set tval
X	back to 0, and set subval to 64
Xstore1.c: change store_carry(), for group items, must update scost; for any
X	stackable item, set ipos so that inventory will scroll to show it;
X	let group items (except torches) stack over 24 since each group is
X	created with a set number to begin with; ipos must be set to -1 at
X	start not 0;
Xstore2.c: store_sell(), pass a pointer to cur_top instead of just its value,
X	if sold object not on the page shown, scroll to show the object
X------------ 12/13
Xrecall.c: only print out known attacks, i.e. check r_attack, change i to count
X	from 0 to 3, fixes bug with knowdamage(), add variable j to count
X	attacks actually printed out
Xsave.c: put limit on number of times store inventory changed in get_char()
Xstore2.c: rewrite incremental haggle code again, add new parameter 'num_offer'
X	to receive_offer, change get_offer parm last_offer to num_offer, only
X	allow inc haggle if num_offer != 0; must reset new_offer after
X	rejected offer in recieve_offer and sell/purchase_haggle
X------------ 12/14
Xmisc2.c, lots: change way spell learning works, new command 'G'ain magic
X	spells, new function gain_spells() in misc2.c formerly part of
X	calc_spells(), new status flag PY_STUDY controls printing of 'Study'
X	in status line, new field py.flags.new_spells number of spells can
X	learn
Xorigcmds.hlp, roglcmds.hlp: document the 'M'ap and 'G'ain magic commands
Xvariables.c, potions.c: remove potion of learning as it is no longer useful
END_OF_FILE
if test 28159 -ne `wc -c <'OOChanges.2'`; then
    echo shar: \"'OOChanges.2'\" unpacked with wrong size!
fi
# end of 'OOChanges.2'
fi
if test -f 'source/misc1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/misc1.c'\"
else
echo shar: Extracting \"'source/misc1.c'\" \(24413 characters\)
sed "s/^X//" >'source/misc1.c' <<'END_OF_FILE'
X/* source/misc1.c: misc utility and initialization code, magic objects code
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#ifdef __TURBOC__
X#include	<stdlib.h>
X#endif
X
X#ifdef Pyramid
X#include <sys/time.h>
X#else
X#include <time.h>
X#endif
X#if !defined(GEMDOS) && !defined(MAC) && !defined(AMIGA)
X#ifndef VMS
X#include <sys/types.h>
X#else
X#include <types.h>
X#endif
X#endif
X
X#if !defined(ATARIST_MWC) && !defined(MAC) && !defined(VMS) && !defined(AMIGA)
Xlong time();
X#endif
Xstruct tm *localtime();
X
X#if defined(LINT_ARGS)
Xstatic void compact_objects(void);
X#endif
X
X
X/* gets a new random seed for the random number generator */
Xvoid init_seeds(seed)
Xint32u seed;
X{
X  register int32u clock_var;
X
X  if (seed == 0)
X#ifdef MAC
X    clock_var = time((time_t *)0);
X#else
X    clock_var = time((long *)0);
X#endif
X  else
X    clock_var = seed;
X  randes_seed = (int32) clock_var;
X
X  clock_var += 8762;
X  town_seed = (int32) clock_var;
X
X  clock_var += 113452L;
X  set_rnd_seed(clock_var);
X  /* make it a little more random */
X  for (clock_var = randint(100); clock_var != 0; clock_var--)
X    (void) rnd();
X}
X
X/* holds the previous rnd state */
Xstatic int32u old_seed;
X
X/* change to different random number generator state */
Xvoid set_seed(seed)
Xint32u seed;
X{
X  old_seed = get_rnd_seed ();
X
X  /* want reproducible state here */
X  set_rnd_seed (seed);
X}
X
X
X/* restore the normal random generator state */
Xvoid reset_seed()
X{
X  set_rnd_seed (old_seed);
X}
X
X
X/* Check the day-time strings to see if open		-RAK-	*/
Xint check_time()
X{
X#ifdef MORIA_HOU
X  long clock_var;
X  register struct tm *tp;
X
X#ifdef MAC
X  clock_var = time((time_t *)0);
X#else
X  clock_var = time((long *)0);
X#endif
X  tp = localtime(&clock_var);
X  if (days[tp->tm_wday][tp->tm_hour+4] == 'X')
X    return TRUE;
X  else
X    return FALSE;
X#else
X  return TRUE;
X#endif
X}
X
X
X/* Generates a random integer x where 1<=X<=MAXVAL	-RAK-	*/
Xint randint(maxval)
Xint maxval;
X{
X  register long randval;
X
X  randval = rnd ();
X  return ((int)(randval % maxval) + 1);
X}
X
X/* Generates a random integer number of NORMAL distribution -RAK-*/
Xint randnor(mean, stand)
Xint mean, stand;
X{
X  register int tmp, offset, low, iindex, high;
X
X#if 0
X  /* alternate randnor code, slower but much smaller since no table */
X  /* 2 per 1,000,000 will be > 4*SD, max is 5*SD */
X  tmp = damroll(8, 99);	 /* mean 400, SD 81 */
X  tmp = (tmp - 400) * stand / 81;
X  return tmp + mean;
X#endif
X
X  tmp = randint(MAX_SHORT);
X
X  /* off scale, assign random value between 4 and 5 times SD */
X  if (tmp == MAX_SHORT)
X    {
X      offset = 4 * stand + randint(stand);
X
X      /* one half are negative */
X      if (randint(2) == 1)
X	offset = -offset;
X
X      return mean + offset;
X    }
X
X  /* binary search normal normal_table to get index that matches tmp */
X  /* this takes up to 8 iterations */
X  low = 0;
X  iindex = NORMAL_TABLE_SIZE >> 1;
X  high = NORMAL_TABLE_SIZE;
X  while (TRUE)
X    {
X      if ((normal_table[iindex] == tmp) || (high == (low+1)))
X	break;
X      if (normal_table[iindex] > tmp)
X	{
X	  high = iindex;
X	  iindex = low + ((iindex - low) >> 1);
X	}
X      else
X	{
X	  low = iindex;
X	  iindex = iindex + ((high - iindex) >> 1);
X	}
X    }
X
X  /* might end up one below target, check that here */
X  if (normal_table[iindex] < tmp)
X    iindex = iindex + 1;
X
X  /* normal_table is based on SD of 64, so adjust the index value here,
X     round the half way case up */
X  offset = ((stand * iindex) + (NORMAL_TABLE_SD >> 1)) / NORMAL_TABLE_SD;
X
X  /* one half should be negative */
X  if (randint(2) == 1)
X    offset = -offset;
X
X  return mean + offset;
X}
X
X
X/* Returns position of first set bit			-RAK-	*/
X/*     and clears that bit */
Xint bit_pos(test)
Xint32u *test;
X{
X  register int i;
X  register int32u mask = 0x1;
X
X  for (i = 0; i < sizeof(*test)*8; i++) {
X    if (*test & mask) {
X      *test &= ~mask;
X      return(i);
X    }
X    mask <<= 1;
X  }
X
X  /* no one bits found */
X  return(-1);
X}
X
X/* Checks a co-ordinate for in bounds status		-RAK-	*/
Xint in_bounds(y, x)
Xint y, x;
X{
X  if ((y > 0) && (y < cur_height-1) && (x > 0) && (x < cur_width-1))
X    return(TRUE);
X  else
X    return(FALSE);
X}
X
X
X/* Calculates current boundaries				-RAK-	*/
Xvoid panel_bounds()
X{
X  panel_row_min = panel_row*(SCREEN_HEIGHT/2);
X  panel_row_max = panel_row_min + SCREEN_HEIGHT - 1;
X  panel_row_prt = panel_row_min - 1;
X  panel_col_min = panel_col*(SCREEN_WIDTH/2);
X  panel_col_max = panel_col_min + SCREEN_WIDTH - 1;
X  panel_col_prt = panel_col_min - 13;
X}
X
X
X/* Given an row (y) and col (x), this routine detects  -RAK-	*/
X/* when a move off the screen has occurred and figures new borders.
X   Force forcses the panel bounds to be recalculated, useful for 'W'here. */
Xint get_panel(y, x, force)
Xint y, x, force;
X{
X  register int prow, pcol;
X  register int panel;
X
X  prow = panel_row;
X  pcol = panel_col;
X  if (force || (y < panel_row_min + 2) || (y > panel_row_max - 2))
X    {
X      prow = ((y - SCREEN_HEIGHT/4)/(SCREEN_HEIGHT/2));
X      if (prow > max_panel_rows)
X	prow = max_panel_rows;
X      else if (prow < 0)
X	prow = 0;
X    }
X  if (force || (x < panel_col_min + 3) || (x > panel_col_max - 3))
X    {
X      pcol = ((x - SCREEN_WIDTH/4)/(SCREEN_WIDTH/2));
X      if (pcol > max_panel_cols)
X	pcol = max_panel_cols;
X      else if (pcol < 0)
X	pcol = 0;
X    }
X  if ((prow != panel_row) || (pcol != panel_col))
X    {
X      panel_row = prow;
X      panel_col = pcol;
X      panel_bounds();
X      panel = TRUE;
X      /* stop movement if any */
X      if (find_bound)
X	end_find();
X    }
X  else
X    panel = FALSE;
X  return(panel);
X}
X
X
X/* Tests a given point to see if it is within the screen -RAK-	*/
X/* boundaries.							  */
Xint panel_contains(y, x)
Xregister int y, x;
X{
X  if ((y >= panel_row_min) && (y <= panel_row_max) &&
X      (x >= panel_col_min) && (x <= panel_col_max))
X    return (TRUE);
X  else
X    return (FALSE);
X}
X
X
X/* Distance between two points				-RAK-	*/
Xint distance(y1, x1, y2, x2)
Xint y1, x1, y2, x2;
X{
X  register int dy, dx;
X
X  dy = y1 - y2;
X  if (dy < 0)
X    dy = -dy;
X  dx = x1 - x2;
X  if (dx < 0)
X    dx = -dx;
X
X  return ((((dy + dx) << 1) - (dy > dx ? dx : dy)) >> 1);
X}
X
X/* Checks points north, south, east, and west for a wall -RAK-	*/
X/* note that y,x is always in_bounds(), i.e. 0 < y < cur_height-1, and
X   0 < x < cur_width-1	*/
Xint next_to_walls(y, x)
Xregister int y, x;
X{
X  register int i;
X  register cave_type *c_ptr;
X
X  i = 0;
X  c_ptr = &cave[y-1][x];
X  if (c_ptr->fval >= MIN_CAVE_WALL)
X    i++;
X  c_ptr = &cave[y+1][x];
X  if (c_ptr->fval >= MIN_CAVE_WALL)
X    i++;
X  c_ptr = &cave[y][x-1];
X  if (c_ptr->fval >= MIN_CAVE_WALL)
X    i++;
X  c_ptr = &cave[y][x+1];
X  if (c_ptr->fval >= MIN_CAVE_WALL)
X    i++;
X
X  return(i);
X}
X
X
X/* Checks all adjacent spots for corridors		-RAK-	*/
X/* note that y, x is always in_bounds(), hence no need to check that
X   j, k are in_bounds(), even if they are 0 or cur_x-1 is still works */
Xint next_to_corr(y, x)
Xregister int y, x;
X{
X  register int k, j, i;
X  register cave_type *c_ptr;
X
X  i = 0;
X  for (j = y - 1; j <= (y + 1); j++)
X    for (k = x - 1; k <= (x + 1); k++)
X      {
X	c_ptr = &cave[j][k];
X	/* should fail if there is already a door present */
X	if (c_ptr->fval == CORR_FLOOR
X	    && (c_ptr->tptr == 0 || t_list[c_ptr->tptr].tval < TV_MIN_DOORS))
X	  i++;
X      }
X  return(i);
X}
X
X
X/* generates damage for 2d6 style dice rolls */
Xint damroll(num, sides)
Xint num, sides;
X{
X  register int i, sum = 0;
X
X  for (i = 0; i < num; i++)
X    sum += randint(sides);
X  return(sum);
X}
X
Xint pdamroll(array)
Xint8u *array;
X{
X  return damroll((int)array[0], (int)array[1]);
X}
X
X
X/* A simple, fast, integer-based line-of-sight algorithm.  By Joseph Hall,
X   4116 Brewster Drive, Raleigh NC 27606.  Email to jnh@ecemwl.ncsu.edu.
X
X   Returns TRUE if a line of sight can be traced from x0, y0 to x1, y1.
X
X   The LOS begins at the center of the tile [x0, y0] and ends at
X   the center of the tile [x1, y1].  If los() is to return TRUE, all of
X   the tiles this line passes through must be transparent, WITH THE
X   EXCEPTIONS of the starting and ending tiles.
X
X   We don't consider the line to be "passing through" a tile if
X   it only passes across one corner of that tile. */
X
X/* Because this function uses (short) ints for all calculations, overflow
X   may occur if deltaX and deltaY exceed 90. */
X
Xint los(fromY, fromX, toY, toX)
Xint fromY, fromX, toY, toX;
X{
X  register int tmp, deltaX, deltaY;
X
X  deltaX = toX - fromX;
X  deltaY = toY - fromY;
X
X  /* Adjacent? */
X  if ((deltaX < 2) && (deltaX > -2) && (deltaY < 2) && (deltaY > -2))
X    return TRUE;
X
X  /* Handle the cases where deltaX or deltaY == 0. */
X  if (deltaX == 0)
X    {
X      register int p_y;	/* y position -- loop variable	*/
X
X      if (deltaY < 0)
X	{
X	  tmp = fromY;
X	  fromY = toY;
X	  toY = tmp;
X	}
X      for (p_y = fromY + 1; p_y < toY; p_y++)
X	if (cave[p_y][fromX].fval >= MIN_CLOSED_SPACE)
X	  return FALSE;
X      return TRUE;
X    }
X  else if (deltaY == 0)
X    {
X      register int px;	/* x position -- loop variable	*/
X
X      if (deltaX < 0)
X	{
X	  tmp = fromX;
X	  fromX = toX;
X	  toX = tmp;
X	}
X      for (px = fromX + 1; px < toX; px++)
X	if (cave[fromY][px].fval >= MIN_CLOSED_SPACE)
X	  return FALSE;
X      return TRUE;
X    }
X
X  /* Now, we've eliminated all the degenerate cases.
X     In the computations below, dy (or dx) and m are multiplied by a
X     scale factor, scale = abs(deltaX * deltaY * 2), so that we can use
X     integer arithmetic. */
X
X  {
X    register int px,	/* x position				*/
X     p_y,		/* y position				*/
X     scale2;		/* above scale factor / 2		*/
X    int scale,		/* above scale factor			*/
X     xSign,		/* sign of deltaX			*/
X     ySign,		/* sign of deltaY			*/
X     m;			/* slope or 1/slope of LOS		*/
X
X    scale2 = abs(deltaX * deltaY);
X    scale = scale2 << 1;
X    xSign = (deltaX < 0) ? -1 : 1;
X    ySign = (deltaY < 0) ? -1 : 1;
X
X    /* Travel from one end of the line to the other, oriented along
X       the longer axis. */
X
X    if (abs(deltaX) >= abs(deltaY))
X      {
X	register int dy;		/* "fractional" y position	*/
X	/* We start at the border between the first and second tiles,
X	   where the y offset = .5 * slope.  Remember the scale
X	   factor.  We have:
X
X	   m = deltaY / deltaX * 2 * (deltaY * deltaX)
X	     = 2 * deltaY * deltaY. */
X
X	dy = deltaY * deltaY;
X	m = dy << 1;
X	px = fromX + xSign;
X
X	/* Consider the special case where slope == 1. */
X	if (dy == scale2)
X	  {
X	    p_y = fromY + ySign;
X	    dy -= scale;
X	  }
X	else
X	  p_y = fromY;
X
X	while (toX - px)
X	  {
X	    if (cave[p_y][px].fval >= MIN_CLOSED_SPACE)
X	      return FALSE;
X
X	    dy += m;
X	    if (dy < scale2)
X	      px += xSign;
X	    else if (dy > scale2)
X	      {
X		p_y += ySign;
X		if (cave[p_y][px].fval >= MIN_CLOSED_SPACE)
X		  return FALSE;
X		px += xSign;
X		dy -= scale;
X	      }
X	    else
X	      {
X		/* This is the case, dy == scale2, where the LOS
X		   exactly meets the corner of a tile. */
X		px += xSign;
X		p_y += ySign;
X		dy -= scale;
X	      }
X	  }
X	return TRUE;
X      }
X    else
X      {
X	register int dx;		/* "fractional" x position	*/
X	dx = deltaX * deltaX;
X	m = dx << 1;
X
X	p_y = fromY + ySign;
X	if (dx == scale2)
X	  {
X	    px = fromX + xSign;
X	    dx -= scale;
X	  }
X	else
X	  px = fromX;
X
X	while (toY - p_y)
X	  {
X	    if (cave[p_y][px].fval >= MIN_CLOSED_SPACE)
X	      return FALSE;
X	    dx += m;
X	    if (dx < scale2)
X	      p_y += ySign;
X	    else if (dx > scale2)
X	      {
X		px += xSign;
X		if (cave[p_y][px].fval >= MIN_CLOSED_SPACE)
X		  return FALSE;
X		p_y += ySign;
X		dx -= scale;
X	      }
X	    else
X	      {
X		px += xSign;
X		p_y += ySign;
X		dx -= scale;
X	      }
X	  }
X	return TRUE;
X      }
X  }
X}
X
X
X/* Returns symbol for given row, column			-RAK-	*/
Xunsigned char loc_symbol(y, x)
Xint y, x;
X{
X  register cave_type *cave_ptr;
X  register struct flags *f_ptr;
X
X  cave_ptr = &cave[y][x];
X  f_ptr = &py.flags;
X
X  if ((cave_ptr->cptr == 1) && (!find_flag || find_prself))
X    return '@';
X  else if (f_ptr->status & PY_BLIND)
X    return ' ';
X  else if ((f_ptr->image > 0) && (randint (12) == 1))
X    return randint (95) + 31;
X  else if ((cave_ptr->cptr > 1) && (m_list[cave_ptr->cptr].ml))
X    return c_list[m_list[cave_ptr->cptr].mptr].cchar;
X  else if (!cave_ptr->pl && !cave_ptr->tl && !cave_ptr->fm)
X    return ' ';
X  else if ((cave_ptr->tptr != 0)
X	   && (t_list[cave_ptr->tptr].tval != TV_INVIS_TRAP))
X    return t_list[cave_ptr->tptr].tchar;
X  else if (cave_ptr->fval <= MAX_CAVE_FLOOR)
X    {
X#ifdef MSDOS
X      return floorsym;
X#else
X      return '.';
X#endif
X    }
X  else if (cave_ptr->fval == GRANITE_WALL || cave_ptr->fval == BOUNDARY_WALL
X	   || highlight_seams == FALSE)
X    {
X#ifdef MSDOS
X      return wallsym;
X#else
X#ifndef ATARI_ST
X      return '#';
X#else
X      return (unsigned char)240;
X#endif
X#endif
X    }
X  else	/* Originally set highlight bit, but that is not portable, now use
X	   the percent sign instead. */
X    {
X      return '%';
X    }
X}
X
X
X/* Tests a spot for light or field mark status		-RAK-	*/
Xint test_light(y, x)
Xint y, x;
X{
X  register cave_type *cave_ptr;
X
X  cave_ptr = &cave[y][x];
X  if (cave_ptr->pl || cave_ptr->tl || cave_ptr->fm)
X    return(TRUE);
X  else
X    return(FALSE);
X}
X
X
X/* Prints the map of the dungeon			-RAK-	*/
Xvoid prt_map()
X{
X  register int i, j, k;
X  register unsigned char tmp_char;
X
X  k = 0;
X  for (i = panel_row_min; i <= panel_row_max; i++)  /* Top to bottom */
X    {
X      k++;
X      erase_line (k, 13);
X      for (j = panel_col_min; j <= panel_col_max; j++)	/* Left to right */
X	{
X	  tmp_char = loc_symbol(i, j);
X	  if (tmp_char != ' ')
X	    print(tmp_char, i, j);
X	}
X    }
X}
X
X
X/* Compact monsters					-RAK-	*/
X/* Return TRUE if any monsters were deleted, FALSE if could not delete any
X   monsters.  */
Xint compact_monsters()
X{
X  register int i;
X  int cur_dis, delete_any;
X  register monster_type *mon_ptr;
X#ifdef ATARIST_MWC
X  int32 holder;
X#endif
X
X  msg_print("Compacting monsters...");
X
X  cur_dis = 66;
X  delete_any = FALSE;
X  do
X    {
X      for (i = mfptr - 1; i >= MIN_MONIX; i--)
X	{
X	  mon_ptr = &m_list[i];
X	  if ((cur_dis < mon_ptr->cdis) && (randint(3) == 1))
X	    {
X	      /* Never compact away the Balrog!! */
X#ifdef ATARIST_MWC
X	      if (c_list[mon_ptr->mptr].cmove & (holder = CM_WIN))
X#else
X	      if (c_list[mon_ptr->mptr].cmove & CM_WIN)
X#endif
X		/* Do nothing */
X		;
X	      /* in case this is called from within creatures(), this is a
X		 horrible hack, the m_list/creatures() code needs to be
X		 rewritten */
X	      else if (hack_monptr < i)
X		{
X		  delete_monster(i);
X		  delete_any = TRUE;
X		}
X	      else
X		/* fix1_delete_monster() does not decrement mfptr, so
X		   don't set delete_any if this was called */
X		fix1_delete_monster(i);
X	    }
X	}
X      if (!delete_any)
X	{
X	  cur_dis -= 6;
X	  /* Can't delete any monsters, return failure.  */
X	  if (cur_dis < 0)
X	    return FALSE;
X	}
X    }
X  while (!delete_any);
X  return TRUE;
X}
X
X
X/* Add to the players food time				-RAK-	*/
Xvoid add_food(num)
Xint num;
X{
X  register struct flags *p_ptr;
X  register int extra, penalty;
X
X  p_ptr = &py.flags;
X  if (p_ptr->food < 0)	p_ptr->food = 0;
X  p_ptr->food += num;
X  if (p_ptr->food > PLAYER_FOOD_MAX)
X    {
X      msg_print("You are bloated from overeating.");
X
X      /* Calculate how much of num is responsible for the bloating.
X	 Give the player food credit for 1/50, and slow him for that many
X	 turns also.  */
X      extra = p_ptr->food - PLAYER_FOOD_MAX;
X      if (extra > num)
X	extra = num;
X      penalty = extra / 50;
X
X      p_ptr->slow += penalty;
X      if (extra == num)
X	p_ptr->food = p_ptr->food - num + penalty;
X      else
X	p_ptr->food = PLAYER_FOOD_MAX + penalty;
X    }
X  else if (p_ptr->food > PLAYER_FOOD_FULL)
X    msg_print("You are full.");
X}
X
X
X/* Returns a pointer to next free space			-RAK-	*/
X/* Returns -1 if could not allocate a monster.  */
Xint popm()
X{
X  if (mfptr == MAX_MALLOC)
X    {
X      if (! compact_monsters())
X	return -1;
X    }
X  return (mfptr++);
X}
X
X
X/* Gives Max hit points					-RAK-	*/
Xint max_hp(array)
Xint8u *array;
X{
X  return(array[0] * array[1]);
X}
X
X
X/* Places a monster at given location			-RAK-	*/
Xint place_monster(y, x, z, slp)
Xregister int y, x, z;
Xint slp;
X{
X  register int cur_pos;
X  register monster_type *mon_ptr;
X
X  cur_pos = popm();
X  if (cur_pos == -1)
X    return FALSE;
X  mon_ptr = &m_list[cur_pos];
X  mon_ptr->fy = y;
X  mon_ptr->fx = x;
X  mon_ptr->mptr = z;
X  if (c_list[z].cdefense & CD_MAX_HP)
X    mon_ptr->hp = max_hp(c_list[z].hd);
X  else
X    mon_ptr->hp = pdamroll(c_list[z].hd);
X  /* the c_list speed value is 10 greater, so that it can be a int8u */
X  mon_ptr->cspeed = c_list[z].speed - 10 + py.flags.speed;
X  mon_ptr->stunned = 0;
X  mon_ptr->cdis = distance(char_row, char_col,y,x);
X  mon_ptr->ml = FALSE;
X  cave[y][x].cptr = cur_pos;
X  if (slp)
X    {
X      if (c_list[z].sleep == 0)
X	mon_ptr->csleep = 0;
X      else
X	mon_ptr->csleep = (c_list[z].sleep * 2) +
X	  randint((int)c_list[z].sleep*10);
X    }
X  else
X    mon_ptr->csleep = 0;
X  return TRUE;
X}
X
X
X/* Places a monster at given location			-RAK-	*/
Xvoid place_win_monster()
X{
X  register int y, x, cur_pos;
X  register monster_type *mon_ptr;
X
X  if (!total_winner)
X    {
X      cur_pos = popm();
X      /* Check for case where could not allocate space for the win monster,
X	 this should never happen.  */
X      if (cur_pos == -1)
X	abort();
X      mon_ptr = &m_list[cur_pos];
X      do
X	{
X	  y = randint(cur_height-2);
X	  x = randint(cur_width-2);
X	}
X      while ((cave[y][x].fval >= MIN_CLOSED_SPACE) || (cave[y][x].cptr != 0)
X	     || (cave[y][x].tptr != 0) ||
X	      (distance(y,x,char_row, char_col) <= MAX_SIGHT));
X      mon_ptr->fy = y;
X      mon_ptr->fx = x;
X      mon_ptr->mptr = randint(WIN_MON_TOT) - 1 + m_level[MAX_MONS_LEVEL];
X      if (c_list[mon_ptr->mptr].cdefense & CD_MAX_HP)
X	mon_ptr->hp = max_hp(c_list[mon_ptr->mptr].hd);
X      else
X	mon_ptr->hp = pdamroll(c_list[mon_ptr->mptr].hd);
X      /* the c_list speed value is 10 greater, so that it can be a int8u */
X      mon_ptr->cspeed = c_list[mon_ptr->mptr].speed - 10 + py.flags.speed;
X      mon_ptr->stunned = 0;
X      mon_ptr->cdis = distance(char_row, char_col,y,x);
X      cave[y][x].cptr = cur_pos;
X      mon_ptr->csleep = 0;
X    }
X}
X
X
X/* Return a monster suitable to be placed at a given level.  This makes
X   high level monsters (up to the given level) slightly more common than
X   low level monsters at any given level.   -CJS- */
Xint get_mons_num (level)
Xint level;
X{
X  register int i, j, num;
X
X  if (level == 0)
X    i = randint (m_level[0]) - 1;
X  else
X    {
X      if (level > MAX_MONS_LEVEL)
X	level = MAX_MONS_LEVEL;
X      if (randint (MON_NASTY) == 1)
X	{
X	  i = randnor (0, 4);
X	  level = level + abs(i) + 1;
X	  if (level > MAX_MONS_LEVEL)
X	    level = MAX_MONS_LEVEL;
X	}
X      else
X	{
X	  /* This code has been added to make it slightly more likely to
X	     get the higher level monsters. Originally a uniform
X	     distribution over all monsters of level less than or equal to the
X	     dungeon level. This distribution makes a level n monster occur
X	     approx 2/n% of the time on level n, and 1/n*n% are 1st level. */
X
X	  num = m_level[level] - m_level[0];
X	  i = randint (num) - 1;
X	  j = randint (num) - 1;
X	  if (j > i)
X	    i = j;
X	  level = c_list[i + m_level[0]].level;
X	}
X      i = randint(m_level[level]-m_level[level-1]) - 1 + m_level[level-1];
X    }
X  return i;
X}
X
X
X/* Allocates a random monster				-RAK-	*/
Xvoid alloc_monster(num, dis, slp)
Xint num, dis;
Xint slp;
X{
X  register int y, x, i;
X  int l;
X
X  for (i = 0; i < num; i++)
X    {
X      do
X	{
X	  y = randint(cur_height-2);
X	  x = randint(cur_width-2);
X	}
X      while (cave[y][x].fval >= MIN_CLOSED_SPACE || (cave[y][x].cptr != 0) ||
X	     (distance(y, x, char_row, char_col) <= dis));
X
X      l = get_mons_num (dun_level);
X      /* Dragons are always created sleeping here, so as to give the player a
X	 sporting chance.  */
X      if (c_list[l].cchar == 'd' || c_list[l].cchar == 'D')
X	slp = TRUE;
X      /* Place_monster() should always return TRUE here.  It does not
X	 matter if it fails though.  */
X      (void) place_monster(y, x, l, slp);
X    }
X}
X
X
X/* Places creature adjacent to given location		-RAK-	*/
Xint summon_monster(y, x, slp)
Xint *y, *x;
Xint slp;
X{
X  register int i, j, k;
X  int l, summon;
X  register cave_type *cave_ptr;
X
X  i = 0;
X  summon = FALSE;
X  l = get_mons_num (dun_level + MON_SUMMON_ADJ);
X  do
X    {
X      j = *y - 2 + randint(3);
X      k = *x - 2 + randint(3);
X      if (in_bounds(j, k))
X	{
X	  cave_ptr = &cave[j][k];
X	  if (cave_ptr->fval <= MAX_OPEN_SPACE && (cave_ptr->cptr == 0))
X	    {
X	      /* Place_monster() should always return TRUE here.  */
X	      if (!place_monster(j, k, l, slp))
X		return FALSE;
X	      summon = TRUE;
X	      i = 9;
X	      *y = j;
X	      *x = k;
X	    }
X	}
X      i++;
X    }
X  while (i <= 9);
X  return(summon);
X}
X
X
X/* Places undead adjacent to given location		-RAK-	*/
Xint summon_undead(y, x)
Xint *y, *x;
X{
X  register int i, j, k;
X  int l, m, ctr, summon;
X  register cave_type *cave_ptr;
X
X  i = 0;
X  summon = FALSE;
X  l = m_level[MAX_MONS_LEVEL];
X  do
X    {
X      m = randint(l) - 1;
X      ctr = 0;
X      do
X	{
X	  if (c_list[m].cdefense & CD_UNDEAD)
X	    {
X	      ctr = 20;
X	      l	 = 0;
X	    }
X	  else
X	    {
X	      m++;
X	      if (m > l)
X		ctr = 20;
X	      else
X		ctr++;
X	    }
X	}
X      while (ctr <= 19);
X    }
X  while(l != 0);
X  do
X    {
X      j = *y - 2 + randint(3);
X      k = *x - 2 + randint(3);
X      if (in_bounds(j, k))
X	{
X	  cave_ptr = &cave[j][k];
X	  if (cave_ptr->fval <= MAX_OPEN_SPACE && (cave_ptr->cptr == 0))
X	    {
X	      /* Place_monster() should always return TRUE here.  */
X	      if (! place_monster(j, k, m, FALSE))
X		return FALSE;
X	      summon = TRUE;
X	      i = 9;
X	      *y = j;
X	      *x = k;
X	    }
X	}
X      i++;
X    }
X  while(i <= 9);
X  return(summon);
X}
X
X
X/* If too many objects on floor level, delete some of them-RAK-	*/
Xstatic void compact_objects()
X{
X  register int i, j;
X  int ctr, cur_dis, chance;
X  register cave_type *cave_ptr;
X
X  msg_print("Compacting objects...");
X
X  ctr = 0;
X  cur_dis = 66;
X  do
X    {
X      for (i = 0; i < cur_height; i++)
X	for (j = 0; j < cur_width; j++)
X	  {
X	    cave_ptr = &cave[i][j];
X	    if ((cave_ptr->tptr != 0)
X		&& (distance(i, j, char_row, char_col) > cur_dis))
X	      {
X		switch(t_list[cave_ptr->tptr].tval)
X		  {
X		  case TV_VIS_TRAP:
X		    chance = 15;
X		    break;
X		  case TV_INVIS_TRAP:
X		  case TV_RUBBLE:
X		  case TV_OPEN_DOOR: case TV_CLOSED_DOOR:
X		    chance = 5;
X		    break;
X		  case TV_UP_STAIR: case TV_DOWN_STAIR:
X		  case TV_STORE_DOOR:
X		    /* stairs, don't delete them */
X		    /* shop doors, don't delete them */
X		    chance = 0;
X		    break;
X		  case TV_SECRET_DOOR: /* secret doors */
X		    chance = 3;
X		    break;
X		  default:
X		    chance = 10;
X		  }
X		if (randint (100) <= chance)
X		  {
X		    (void) delete_object(i, j);
X		    ctr++;
X		  }
X	      }
X	  }
X      if (ctr == 0)  cur_dis -= 6;
X    }
X  while (ctr <= 0);
X  if (cur_dis < 66)  prt_map();
X}
X
X/* Gives pointer to next free space			-RAK-	*/
Xint popt()
X{
X  if (tcptr == MAX_TALLOC)
X    compact_objects();
X  return (tcptr++);
X}
X
X
X/* Pushs a record back onto free space list		-RAK-	*/
X/* Delete_object() should always be called instead, unless the object in
X   question is not in the dungeon, e.g. in store1.c and files.c */
Xvoid pusht(x)
Xregister int8u x;
X{
X  register int i, j;
X
X  if (x != tcptr - 1)
X    {
X      t_list[x] = t_list[tcptr - 1];
X
X      /* must change the tptr in the cave of the object just moved */
X      for (i = 0; i < cur_height; i++)
X	for (j = 0; j < cur_width; j++)
X	  if (cave[i][j].tptr == tcptr - 1)
X	    cave[i][j].tptr = x;
X    }
X  tcptr--;
X  invcopy(&t_list[tcptr], OBJ_NOTHING);
X}
X
X
X/* Boolean : is object enchanted	  -RAK- */
Xint magik(chance)
Xint chance;
X{
X  if (randint(100) <= chance)
X    return(TRUE);
X  else
X    return(FALSE);
X}
X
X
X/* Enchant a bonus based on degree desired -RAK- */
Xint m_bonus(base, max_std, level)
Xint base, max_std, level;
X{
X  register int x, stand_dev, tmp;
X
X  stand_dev = (OBJ_STD_ADJ * level / 100) + OBJ_STD_MIN;
X  /* Check for level > max_std since that may have generated an overflow.  */
X  if (stand_dev > max_std || level > max_std)
X    stand_dev = max_std;
X  /* abs may be a macro, don't call it with randnor as a parameter */
X  tmp = randnor(0, stand_dev);
X  x = (abs(tmp) / 10) + base;
X  if (x < base)
X    return(base);
X  else
X    return(x);
X}
END_OF_FILE
if test 24413 -ne `wc -c <'source/misc1.c'`; then
    echo shar: \"'source/misc1.c'\" unpacked with wrong size!
fi
# end of 'source/misc1.c'
fi
if test -f 'vms/moria.opt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/moria.opt'\"
else
echo shar: Extracting \"'vms/moria.opt'\" \(754 characters\)
sed "s/^X//" >'vms/moria.opt' <<'END_OF_FILE'
XMAIN.OBJ, -
XCREATE.OBJ, -
XCREATURE.OBJ, -
XDEATH.OBJ, -
XDESC.OBJ, -
XDUNGEON.OBJ, -
XEAT.OBJ, -
XFILES.OBJ, -
XGENERATE.OBJ, -
XGETCH.OBJ, -
XHELP.OBJ, -
XIO.OBJ, -
XMAGIC.OBJ, -
XMISC1.OBJ, -
XMISC2.OBJ, -
XMISC3.OBJ, -
XMISC4.OBJ, -
XMONSTERS.OBJ, -
XMORIA1.OBJ, -
XMORIA2.OBJ, -
XMORIA3.OBJ, -
XMORIA4.OBJ, -
XPLAYER.OBJ, -
XPOTIONS.OBJ, -
XPRAYER.OBJ, -
XRECALL.OBJ, -
XRND.OBJ, -
XSAVE.OBJ, -
XSCROLLS.OBJ, -
XSETS.OBJ, -
XSIGNALS.OBJ, -
XSPELLS.OBJ, -
XSTAFFS.OBJ, -
XSTORE1.OBJ, -
XSTORE2.OBJ, -
XTABLES.OBJ, -
XTREASURE.OBJ, -
XUEXIT.OBJ, -
XVARIABLE.OBJ, -
XWANDS.OBJ, -
XWIZARD.OBJ, -
XSYS$LIBRARY:VAXCRTl/share
X! ^ char input
X!         ^ small stubs for cbreak(), nocbreak()
X!                  ^ small stub for exit() call
X!                           ^ links us with the RTLibrary
END_OF_FILE
if test 754 -ne `wc -c <'vms/moria.opt'`; then
    echo shar: \"'vms/moria.opt'\" unpacked with wrong size!
fi
# end of 'vms/moria.opt'
fi
echo shar: End of archive 26 \(of 39\).
cp /dev/null ark26isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
