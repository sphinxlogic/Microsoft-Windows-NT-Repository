Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i062:  umoria4 - single player dungeon simulation (ver. 5.5), Part30/39
Message-ID: <3426@master.CNA.TEK.COM>
Date: 22 Aug 92 22:14:17 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2230
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 62
Archive-name: umoria4/Part30
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 30 (of 39)."
# Contents:  mac/dumpres/TestDR.c mac/macio.c source/create.c
#   source/main.c source/types.h
# Wrapped by billr@saab on Thu Aug 20 09:11:34 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'mac/dumpres/TestDR.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/dumpres/TestDR.c'\"
else
echo shar: Extracting \"'mac/dumpres/TestDR.c'\" \(1358 characters\)
sed "s/^X//" >'mac/dumpres/TestDR.c' <<'END_OF_FILE'
X/* mac/dumpres/TestDR.c: test driver for resource dumping code
X
X   Copyright (c) 1989-1991 Curtis McCauley, James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include <StdIO.h>
X
X#ifndef THINK_C
X#include <Resources.h>
X#endif
X
X#include "DumpRes.h"
X
Xtypedef struct {
X	char *name;
X	int x, y, z;
X} Test;
X
XTest table[5] = {
X	{ "Huron", 1, 2, 3 },
X	{ "Ontario", 4, 5, 6 },
X	{ "Michigan", 7, 8, 9 },
X	{ "Erie", 10, 11, 12 },
X	{ "Superior", 13, 14, 15 }
X};
X
XTest *data;
X
Xvoid MyStrProc(ptr, proc)
Xchar *ptr;
Xvoid (*proc)(char **);
X
X{
X	(*proc)(&((Test *) ptr)->name);
X	return;
X}
X
Xmain()
X
X{
X	short resFile;
X	long i, rc;
X
X	DumpRes(
X		"DumpResTest.rsrc",
X		'TEST', 256, "Test Data", 0,
X		(char *) table, 5, sizeof(Test),
X		MyStrProc
X	);
X
X	resFile = OpenResFile("\pDumpResTest.rsrc");
X
X	if (resFile != -1) {
X
X		data = NULL;
X
X		rc = LoadRes(
X			(char **) &data),
X			'TEST', 256,
X			5, sizeof(Test),
X			MyStrProc
X		);
X
X		if (rc)
X			for (i = 0; i < 5; i++)
X				fprintf(stderr, "%s : %d %d %d\n",
X					data[i].name, data[i].x, data[i].y,
X					data[i].z);
X
X		else
X			fprintf(stderr, "LoadRes failed.\n");
X
X		CloseResFile(resFile);
X
X	}
X
X	else
X		fprintf(stderr, "Unable to open file for LoadRes testing.\n");
X
X	return(0);
X}
END_OF_FILE
if test 1358 -ne `wc -c <'mac/dumpres/TestDR.c'`; then
    echo shar: \"'mac/dumpres/TestDR.c'\" unpacked with wrong size!
fi
# end of 'mac/dumpres/TestDR.c'
fi
if test -f 'mac/macio.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/macio.c'\"
else
echo shar: Extracting \"'mac/macio.c'\" \(12528 characters\)
sed "s/^X//" >'mac/macio.c' <<'END_OF_FILE'
X/* mac/macio.c: terminal I/O code for the macintosh
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#ifdef THINK_C
X#include "ScrnMgr.h"
X#else
X#include <scrnmgr.h>
X#endif
X
X#include <ctype.h>
X#include <string.h>
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X
Xvoid exit();
Xunsigned sleep();
X
X/* Attributes of normal and hilighted characters */
X#define ATTR_NORMAL	attrNormal
X#define ATTR_HILITED	attrReversed
X
X/* initializes curses routines */
Xvoid init_curses()
X{
X  /* Primary initialization is done in mac.c since game is restartable */
X  /* Only need to clear the screen here */
X  Rect scrn;
X
X  scrn.left = scrn.top = 0;
X  scrn.right = SCRN_COLS;
X  scrn.bottom = SCRN_ROWS;
X  EraseScreen(&scrn);
X  UpdateScreen();
X}
X
X/* Set up the terminal into a suitable state for moria.	 -CJS- */
Xvoid moriaterm()
X/* Nothing to do on Mac */
X{
X}
X
X/* Dump IO to buffer					-RAK-	*/
Xvoid put_buffer(out_str, row, col)
Xchar *out_str;
Xint row, col;
X{
X  /* The screen manager handles writes past the edge ok */
X  DSetScreenCursor(col, row);
X  DWriteScreenStringAttr(out_str, ATTR_NORMAL);
X}
X
X/* Dump the IO buffer to terminal			-RAK-	*/
Xvoid put_qio()
X{
X  screen_change = TRUE;	   /* Let inven_command know something has changed. */
X  UpdateScreen();
X}
X
X/* Put the terminal in the original mode.			   -CJS- */
Xvoid restore_term()
X/* Nothing to do on Mac */
X{
X}
X
Xvoid shell_out()
X{
X  alert_error("This command is not implemented on the Macintosh.");
X}
X
X/* Returns a single character input from the terminal.	This silently -CJS-
X   consumes ^R to redraw the screen and reset the terminal, so that this
X   operation can always be performed at any input prompt.  inkey() never
X   returns ^R.	*/
Xchar inkey()
X/* The Mac does not need ^R, so it just consumes it */
X/* This routine does nothing special with direction keys */
X/* Just returns their keypad ascii value (e.g. '0'-'9') */
X/* Compare with inkeydir() below */
X{
X  char ch;
X  int dir;
X  int shift_flag, ctrl_flag;
X
X  put_qio();
X  command_count = 0;
X
X  do {
X    macgetkey(&ch, FALSE);
X  } while (ch == CTRL('R'));
X
X  dir = extractdir(ch, &shift_flag, &ctrl_flag);
X  if (dir != -1)
X    ch = '0' + dir;
X
X  return(ch);
X}
X
Xchar inkeydir()
X/* The Mac does not need ^R, so it just consumes it */
X/* This routine translates the direction keys in rogue-like mode */
X{
X  char ch;
X  int dir;
X  int shift_flag, ctrl_flag;
X  static char tab[9] = {
X	'b',		'j',		'n',
X	'h',		'.',		'l',
X	'y',		'k',		'u'
X  };
X  static char shifttab[9] = {
X	'B',		'J',		'N',
X	'H',		'.',		'L',
X	'Y',		'K',		'U'
X  };
X  static char ctrltab[9] = {
X	CTRL('B'),	CTRL('J'),	CTRL('N'),
X	CTRL('H'),	'.',		CTRL('L'),
X	CTRL('Y'),	CTRL('K'),	CTRL('U')
X  };
X
X  put_qio();
X  command_count = 0;
X
X  do {
X    macgetkey(&ch, FALSE);
X  } while (ch == CTRL('R'));
X
X  dir = extractdir(ch, &shift_flag, &ctrl_flag);
X
X  if (dir != -1) {
X    if (!rogue_like_commands) {
X      ch = '0' + dir;
X    }
X    else {
X      if (ctrl_flag)
X	ch = ctrltab[dir - 1];
X      else if (shift_flag)
X	ch = shifttab[dir - 1];
X      else
X	ch = tab[dir - 1];
X    }
X  }
X
X  return(ch);
X}
X
X/* Flush the buffer					-RAK-	*/
Xvoid flush()
X{
X/* Removed put_qio() call.  Reduces flashing.  Doesn't seem to hurt. */
X  FlushScreenKeys();
X}
X
X/* Clears given line of text				-RAK-	*/
Xvoid erase_line(row, col)
Xint row;
Xint col;
X{
X  Rect line;
X
X  if (row == MSG_LINE && msg_flag)
X    msg_print(NULL);
X
X  line.left = col;
X  line.top = row;
X  line.right = SCRN_COLS;
X  line.bottom = row + 1;
X  DEraseScreen(&line);
X}
X
X/* Clears screen */
Xvoid clear_screen()
X{
X  Rect area;
X
X  if (msg_flag)
X    msg_print(NULL);
X
X  area.left = area.top = 0;
X  area.right = SCRN_COLS;
X  area.bottom = SCRN_ROWS;
X  DEraseScreen(&area);
X}
X
Xvoid clear_from (row)
Xint row;
X{
X  Rect area;
X
X  area.left = 0;
X  area.top = row;
X  area.right = SCRN_COLS;
X  area.bottom = SCRN_ROWS;
X  DEraseScreen(&area);
X}
X
X/* Outputs a char to a given interpolated y, x position	-RAK-	*/
X/* sign bit of a character used to indicate standout mode. -CJS */
Xvoid print(ch, row, col)
Xchar ch;
Xint row;
Xint col;
X{
X  char cnow, anow, cnew, anew;
X
X  row -= panel_row_prt;/* Real co-ords convert to screen positions */
X  col -= panel_col_prt;
X
X  if (ch & 0x80) {
X    cnew = ch & ~0x80;
X    anew = ATTR_HILITED;
X  }
X  else {
X    cnew = ch;
X    anew = ATTR_NORMAL;
X  }
X
X  GetScreenCharAttr(&cnow, &anow, col, row);	/* Check current */
X
X  if ((cnow != ch) || (anow != anew))	/* If char is already set, ignore op */
X    DSetScreenCharAttr(cnew, anew, col, row);
X}
X
X/* Moves the cursor to a given interpolated y, x position	-RAK-	*/
Xvoid move_cursor_relative(row, col)
Xint row;
Xint col;
X{
X  row -= panel_row_prt;/* Real co-ords convert to screen positions */
X  col -= panel_col_prt;
X
X  DSetScreenCursor(col, row);
X}
X
X/* Print a message so as not to interrupt a counted command. -CJS- */
Xvoid count_msg_print(p)
Xchar *p;
X{
X  int i;
X
X  i = command_count;
X  msg_print(p);
X  command_count = i;
X}
X
X/* Outputs a line to a given y, x position		-RAK-	*/
Xvoid prt(str_buff, row, col)
Xchar *str_buff;
Xint row;
Xint col;
X{
X  Rect line;
X
X  if (row == MSG_LINE && msg_flag)
X    msg_print(NULL);
X
X  line.left = col;
X  line.top = row;
X  line.right = SCRN_COLS;
X  line.bottom = row + 1;
X  DEraseScreen(&line);
X
X  put_buffer(str_buff, row, col);
X}
X
X/* move cursor to a given y, x position */
Xvoid move_cursor(row, col)
Xint row, col;
X{
X  DSetScreenCursor(col, row);
X}
X
X/* Outputs message to top line of screen				*/
X/* These messages are kept for later reference.	 */
Xvoid msg_print(str_buff)
Xchar *str_buff;
X{
X  register int old_len;
X  char in_char;
X  Rect line;
X
X  if (msg_flag)
X    {
X      old_len = strlen(old_msg[last_msg]) + 1;
X      /* ensure that the complete -more- message is visible. */
X      if (old_len > 73)
X	old_len = 73;
X      put_buffer(" -more-", MSG_LINE, old_len);
X      /* let sigint handler know that we are waiting for a space */
X      wait_for_more = 1;
X      do
X	{
X	  in_char = inkey();
X	}
X      while ((in_char != ' ') && (in_char != ESCAPE) && (in_char != '\n') &&
X	     (in_char != '\r'));
X      wait_for_more = 0;
X    }
X  line.left = 0;
X  line.top = MSG_LINE;
X  line.right = SCRN_COLS;
X  line.bottom = MSG_LINE+1;
X  DEraseScreen(&line);
X
X  /* Make the null string a special case.  -CJS- */
X  if (str_buff)
X    {
X      put_buffer(str_buff, MSG_LINE, 0);
X      command_count = 0;
X      last_msg++;
X      if (last_msg >= MAX_SAVE_MSG)
X	last_msg = 0;
X      (void) strncpy(old_msg[last_msg], str_buff, VTYPESIZ);
X      old_msg[last_msg][VTYPESIZ - 1] = '\0';
X      msg_flag = TRUE;
X    }
X  else
X    msg_flag = FALSE;
X}
X
X/* Used to verify a choice - user gets the chance to abort choice.  -CJS- */
Xint get_check(prompt)
Xchar *prompt;
X{
X  int res;
X  long x, y;
X
X  prt(prompt, 0, 0);
X  GetScreenCursor(&x, &y);
X  if (x > 73)
X    DSetScreenCursor(73, y);
X  DWriteScreenStringAttr(" [y/n]", ATTR_NORMAL);
X  do
X    {
X      res = inkey();
X    }
X  while(res == ' ');
X  erase_line(0, 0);
X  if (res == 'Y' || res == 'y')
X    return TRUE;
X  else
X    return FALSE;
X}
X
X/* Prompts (optional) and returns ord value of input char	*/
X/* Function returns false if <ESCAPE> is input	*/
Xint get_com(prompt, command)
Xchar *prompt;
Xchar *command;
X{
X  int res;
X
X  if (prompt)
X    prt(prompt, 0, 0);
X  *command = inkey();
X  if (*command == 0 || *command == ESCAPE)
X    res = FALSE;
X  else
X    res = TRUE;
X  erase_line(MSG_LINE, 0);
X  return(res);
X}
X
X/* Same as get_com(), but translates direction keys from keypad */
Xint get_comdir(prompt, command)
Xchar *prompt;
Xchar *command;
X{
X  int res;
X
X  if (prompt)
X    prt(prompt, 0, 0);
X  *command = inkeydir();
X  if (*command == 0 || *command == ESCAPE)
X    res = FALSE;
X  else
X    res = TRUE;
X  erase_line(MSG_LINE, 0);
X  return(res);
X}
X
X/* Gets a string terminated by <RETURN>		*/
X/* Function returns false if <ESCAPE> is input	*/
Xint get_string(in_str, row, column, slen)
Xchar *in_str;
Xint row, column, slen;
X{
X  register int start_col, end_col, i;
X  char *p;
X  int flag, abort;
X  Rect area;
X
X  abort = FALSE;
X  flag	= FALSE;
X  area.left = column;
X  area.top = row;
X  area.right = column + slen;
X  area.bottom = row + 1;
X  DEraseScreen(&area);
X  DSetScreenCursor(column, row);
X  start_col = column;
X  end_col = column + slen - 1;
X  if (end_col > 79)
X    {
X      slen = 80 - column;
X      end_col = 79;
X    }
X  p = in_str;
X  do
X    {
X      i = inkey();
X      switch(i)
X	{
X	case ESCAPE:
X	  abort = TRUE;
X	  break;
X	case CTRL('J'): case CTRL('M'):
X	  flag	= TRUE;
X	  break;
X	case DELETE: case CTRL('H'):
X	  if (column > start_col)
X	    {
X	      column--;
X	      put_buffer(" ", row, column);
X	      move_cursor(row, column);
X	      *--p = '\0';
X	    }
X	  break;
X	default:
X	  if (!isprint(i) || column > end_col)
X	    bell();
X	  else
X	    {
X	      DSetScreenCursor(column, row);
X	      DWriteScreenCharAttr((char) i, ATTR_NORMAL);
X	      *p++ = i;
X	      column++;
X	    }
X	  break;
X	}
X    }
X  while ((!flag) && (!abort));
X  if (abort)
X    return(FALSE);
X  /* Remove trailing blanks	*/
X  while (p > in_str && p[-1] == ' ')
X    p--;
X  *p = '\0';
X  return(TRUE);
X}
X
X/* Pauses for user response before returning		-RAK-	*/
Xvoid pause_line(prt_line)
Xint prt_line;
X{
X  prt("[Press any key to continue.]", prt_line, 23);
X  (void) inkey();
X  erase_line(prt_line, 0);
X}
X
X/* Pauses for user response before returning		-RAK-	*/
X/* NOTE: Delay is for players trying to roll up "perfect"	*/
X/*	characters.  Make them wait a bit.			*/
Xvoid pause_exit(prt_line, delay)
Xint prt_line;
Xint delay;
X{
X  char dummy;
X
X  prt("[Press any key to continue, or Q to exit.]", prt_line, 10);
X  dummy = inkey();
X  if (dummy == 'Q')
X    {
X      erase_line(prt_line, 0);
X      if (delay > 0)  (void) sleep((unsigned)delay);
X      exit_game();
X    }
X  erase_line(prt_line, 0);
X}
X
Xvoid save_screen()
X{
X  mac_save_screen();
X}
X
Xvoid restore_screen()
X{
X  mac_restore_screen();
X}
X
Xvoid bell()
X{
X  put_qio();
X  if (! sound_beep_flag)
X    return;
X  mac_beep();
X}
X
X/* definitions used by screen_map() */
X/* index into border character array */
X#define TL 0	/* top left */
X#define TR 1
X#define BL 2
X#define BR 3
X#define HE 4	/* horizontal edge */
X#define VE 5
X
X/* Display highest priority object in the RATIO by RATIO area */
X#define	RATIO 3
X
Xvoid screen_map()
X{
X  register int	i, j;
X  static int8u border[6] = {
X    '+', '+', '+', '+', '-', '|'	/* normal chars */
X  };
X  int8u map[MAX_WIDTH / RATIO + 1];
X  int8u tmp;
X  int priority[256];
X  int row, orow, col, myrow, mycol = 0;
X
X  for (i = 0; i < 256; i++)
X    priority[i] = 0;
X  priority['<'] = 5;
X  priority['>'] = 5;
X  priority['@'] = 10;
X  priority['#'] = -5;
X  priority['.'] = -10;
X  priority['\''] = -3;
X  priority[' '] = -15;
X
X  save_screen();
X  clear_screen();
X  DSetScreenCursor(0, 0);
X  DWriteScreenCharAttr(border[TL], ATTR_NORMAL);
X  for (i = 0; i < MAX_WIDTH / RATIO; i++)
X    DWriteScreenCharAttr(border[HE], ATTR_NORMAL);
X  DWriteScreenCharAttr(border[TR], ATTR_NORMAL);
X  orow = -1;
X  map[MAX_WIDTH / RATIO] = '\0';
X  for (i = 0; i < MAX_HEIGHT; i++)
X    {
X      row = i / RATIO;
X      if (row != orow)
X	{
X	  if (orow >= 0)
X	    {
X	      DSetScreenCursor(0, orow+1);
X	      DWriteScreenCharAttr(border[VE], ATTR_NORMAL);
X	      DWriteScreenString((char *)map);
X	      DWriteScreenCharAttr(border[VE], ATTR_NORMAL);
X	    }
X	  for (j = 0; j < MAX_WIDTH / RATIO; j++)
X	    map[j] = ' ';
X	  orow = row;
X	}
X      for (j = 0; j < MAX_WIDTH; j++)
X	{
X	  col = j / RATIO;
X	  tmp = loc_symbol(i, j);
X	  /* Attributes are not handled correctly by DWriteScreenString */
X	  /* Also, no special priority for the vein character */
X	  if (tmp & 0x80)
X	    tmp &= ~0x80;
X	  if (priority[map[col]] < priority[tmp])
X	    map[col] = tmp;
X	  if (map[col] == '@')
X	    {
X	      mycol = col + 1; /* account for border */
X	      myrow = row + 1;
X	    }
X	}
X    }
X  if (orow >= 0)
X    {
X      DSetScreenCursor(0, orow+1);
X      DWriteScreenCharAttr(border[VE], ATTR_NORMAL);
X      DWriteScreenString((char *)map);
X      DWriteScreenCharAttr(border[VE], ATTR_NORMAL);
X    }
X  DSetScreenCursor(0, orow + 2);
X  DWriteScreenCharAttr(border[BL], ATTR_NORMAL);
X  for (i = 0; i < MAX_WIDTH / RATIO; i++)
X    DWriteScreenCharAttr(border[HE], ATTR_NORMAL);
X  DWriteScreenCharAttr(border[BR], ATTR_NORMAL);
X  DSetScreenCursor(23, 23);
X  DWriteScreenStringAttr("Hit any key to continue", ATTR_NORMAL);
X  if (mycol > 0)
X    DSetScreenCursor(mycol, myrow);
X  (void) inkey();
X  restore_screen();
X}
END_OF_FILE
if test 12528 -ne `wc -c <'mac/macio.c'`; then
    echo shar: \"'mac/macio.c'\" unpacked with wrong size!
fi
# end of 'mac/macio.c'
fi
if test -f 'source/create.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/create.c'\"
else
echo shar: Extracting \"'source/create.c'\" \(12803 characters\)
sed "s/^X//" >'source/create.c' <<'END_OF_FILE'
X/* source/create.c: create a player character
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#ifdef __TURBOC__
X#include	<stdio.h>
X#endif /* __TURBOC__ */
X 
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#ifdef USG
X#ifndef ATARIST_MWC
X#include <string.h>
X#endif
X#else
X#include <strings.h>
X#endif
X
X#if defined(LINT_ARGS)
Xstatic void get_stats(void);
Xstatic void change_stat(int, int16);
Xstatic void get_all_stats(void);
Xstatic void choose_race(void);
Xstatic void print_history(void);
Xstatic void get_history(void);
Xstatic void get_sex(void);
Xstatic void get_ahw(void);
Xstatic void get_class(void);
Xstatic int monval(int8u);
Xstatic void get_money(void);
X#endif
X
X/* Generates character's stats				-JWT-	*/
Xstatic void get_stats()
X{
X  register int i, tot;
X  int dice[18];
X
X  do
X    {
X      tot = 0;
X      for (i = 0; i < 18; i++)
X	{
X	  dice[i] = randint (3 + i % 3);  /* Roll 3,4,5 sided dice once each */
X	  tot += dice[i];
X	}
X    }
X  while (tot <= 42 || tot >= 54);
X
X  for (i = 0; i < 6; i++)
X    py.stats.max_stat[i] = 5 + dice[3*i] + dice[3*i+1] + dice[3*i+2];
X}
X
X
X/* Changes stats by given amount				-JWT-	*/
Xstatic void change_stat(stat, amount)
Xint stat;
Xint16 amount;
X{
X  register int i;
X  register int tmp_stat;
X
X  tmp_stat = py.stats.max_stat[stat];
X  if (amount < 0)
X    for (i = 0; i > amount; i--)
X      {
X	if (tmp_stat > 108)
X	  tmp_stat--;
X	else if (tmp_stat > 88)
X	  tmp_stat += -randint(6) - 2;
X	else if (tmp_stat > 18)
X	  {
X	    tmp_stat += -randint(15) - 5;
X	    if (tmp_stat < 18)
X	      tmp_stat = 18;
X	  }
X	else if (tmp_stat > 3)
X	  tmp_stat--;
X      }
X  else
X    for (i = 0; i < amount; i++)
X      {
X	if (tmp_stat < 18)
X	  tmp_stat++;
X	else if (tmp_stat < 88)
X	  tmp_stat += randint(15) + 5;
X	else if (tmp_stat < 108)
X	  tmp_stat += randint(6) + 2;
X	else if (tmp_stat < 118)
X	  tmp_stat++;
X      }
X  py.stats.max_stat[stat] = tmp_stat;
X}
X
X
X/* generate all stats and modify for race. needed in a separate module so
X   looping of character selection would be allowed     -RGM- */
Xstatic void get_all_stats ()
X{
X  register player_type *p_ptr;
X  register race_type *r_ptr;
X  register int j;
X
X  p_ptr = &py;
X  r_ptr = &race[p_ptr->misc.prace];
X  get_stats ();
X  change_stat (A_STR, r_ptr->str_adj);
X  change_stat (A_INT, r_ptr->int_adj);
X  change_stat (A_WIS, r_ptr->wis_adj);
X  change_stat (A_DEX, r_ptr->dex_adj);
X  change_stat (A_CON, r_ptr->con_adj);
X  change_stat (A_CHR, r_ptr->chr_adj);
X  for (j = 0; j < 6; j++)
X    {
X      py.stats.cur_stat[j] = py.stats.max_stat[j];
X      set_use_stat (j);
X    }
X
X  p_ptr->misc.srh    = r_ptr->srh;
X  p_ptr->misc.bth    = r_ptr->bth;
X  p_ptr->misc.bthb   = r_ptr->bthb;
X  p_ptr->misc.fos    = r_ptr->fos;
X  p_ptr->misc.stl    = r_ptr->stl;
X  p_ptr->misc.save   = r_ptr->bsav;
X  p_ptr->misc.hitdie = r_ptr->bhitdie;
X  p_ptr->misc.lev    = 1;
X  p_ptr->misc.ptodam = todam_adj();
X  p_ptr->misc.ptohit = tohit_adj();
X  p_ptr->misc.ptoac  = 0;
X  p_ptr->misc.pac    = toac_adj();
X  p_ptr->misc.expfact = r_ptr->b_exp;
X  p_ptr->flags.see_infra = r_ptr->infra;
X}
X
X
X/* Allows player to select a race			-JWT-	*/
Xstatic void choose_race()
X{
X  register int j, k;
X  int l, m, exit_flag;
X  char s;
X  char tmp_str[80];
X  register player_type *p_ptr;
X  register race_type *r_ptr;
X
X  j = 0;
X  k = 0;
X  l = 2;
X  m = 21;
X  clear_from (20);
X  put_buffer("Choose a race (? for Help):", 20, 2);
X  do
X    {
X      (void) sprintf(tmp_str, "%c) %s", k+'a', race[j].trace);
X      put_buffer(tmp_str, m, l);
X      k++;
X      l += 15;
X      if (l > 70)
X	{
X	  l = 2;
X	  m++;
X	}
X      j++;
X    }
X  while (j < MAX_RACES);
X  exit_flag = FALSE;
X  do
X    {
X      move_cursor (20, 30);
X      s = inkey();
X      j = s - 'a';
X      if ((j < MAX_RACES) && (j >= 0))
X	exit_flag = TRUE;
X      else if (s == '?')
X	helpfile (MORIA_WELCOME);
X      else
X	bell ();
X    }
X  while (!exit_flag);
X
X  p_ptr = &py;
X  r_ptr = &race[j];
X  p_ptr->misc.prace  = j;
X  put_buffer(r_ptr->trace, 3, 15);
X}
X
X
X/* Will print the history of a character			-JWT-	*/
Xstatic void print_history()
X{
X  register int i;
X
X  put_buffer("Character Background", 14, 27);
X  for (i = 0; i < 4; i++)
X    prt(py.misc.history[i], i+15, 10);
X}
X
X
X/* Get the racial history, determines social class	-RAK-	*/
X/* Assumptions:	Each race has init history beginning at		*/
X/*		(race-1)*3+1					*/
X/*		All history parts are in ascending order	*/
Xstatic void get_history()
X{
X  int hist_ptr, cur_ptr, test_roll, flag;
X  register int start_pos, end_pos, cur_len;
X  int line_ctr, new_start, social_class;
X  char history_block[240];
X  register background_type *b_ptr;
X
X  /* Get a block of history text				*/
X  hist_ptr = py.misc.prace*3 + 1;
X  history_block[0] = '\0';
X  social_class = randint(4);
X  cur_ptr = 0;
X  do
X    {
X      flag = FALSE;
X      do
X	{
X	  if (background[cur_ptr].chart == hist_ptr)
X	    {
X	      test_roll = randint(100);
X	      while (test_roll > background[cur_ptr].roll)
X		cur_ptr++;
X	      b_ptr = &background[cur_ptr];
X	      (void) strcat(history_block, b_ptr->info);
X	      social_class += b_ptr->bonus - 50;
X	      if (hist_ptr > b_ptr->next)
X		cur_ptr = 0;
X	      hist_ptr = b_ptr->next;
X	      flag = TRUE;
X	    }
X	  else
X	    cur_ptr++;
X	}
X      while (!flag);
X    }
X  while (hist_ptr >= 1);
X
X  /* clear the previous history strings */
X  for (hist_ptr = 0; hist_ptr < 4; hist_ptr++)
X    py.misc.history[hist_ptr][0] = '\0';
X
X  /* Process block of history text for pretty output	*/
X  start_pos = 0;
X  end_pos   = strlen(history_block) - 1;
X  line_ctr  = 0;
X  flag = FALSE;
X  while (history_block[end_pos] == ' ')
X    end_pos--;
X  do
X    {
X      while (history_block[start_pos] == ' ')
X	start_pos++;
X      cur_len = end_pos - start_pos + 1;
X      if (cur_len > 60)
X	{
X	  cur_len = 60;
X	  while (history_block[start_pos+cur_len-1] != ' ')
X	    cur_len--;
X	  new_start = start_pos + cur_len;
X	  while (history_block[start_pos+cur_len-1] == ' ')
X	    cur_len--;
X	}
X      else
X	flag = TRUE;
X      (void) strncpy(py.misc.history[line_ctr], &history_block[start_pos],
X		     cur_len);
X      py.misc.history[line_ctr][cur_len] = '\0';
X      line_ctr++;
X      start_pos = new_start;
X    }
X  while (!flag);
X
X  /* Compute social class for player			*/
X  if (social_class > 100)
X    social_class = 100;
X  else if (social_class < 1)
X    social_class = 1;
X  py.misc.sc = social_class;
X}
X
X
X/* Gets the character's sex				-JWT-	*/
Xstatic void get_sex()
X{
X  register int exit_flag;
X  char c;
X
X  exit_flag = FALSE;
X  clear_from (20);
X  put_buffer("Choose a sex (? for Help):", 20, 2);
X  put_buffer("m) Male       f) Female", 21, 2);
X  do
X    {
X      move_cursor (20, 29);
X      /* speed not important here */
X      c = inkey();
X      if (c == 'f' || c == 'F')
X	{
X	  py.misc.male = FALSE;
X	  put_buffer("Female", 4, 15);
X	  exit_flag = TRUE;
X	}
X      else if (c == 'm' || c == 'M')
X	{
X	  py.misc.male = TRUE;
X	  put_buffer("Male", 4, 15);
X	  exit_flag = TRUE;
X	}
X      else if (c == '?')
X	helpfile (MORIA_WELCOME);
X      else
X	bell ();
X    }
X  while (!exit_flag);
X}
X
X
X/* Computes character's age, height, and weight		-JWT-	*/
Xstatic void get_ahw()
X{
X  register int i;
X
X  i = py.misc.prace;
X  py.misc.age = race[i].b_age + randint((int)race[i].m_age);
X  if (py.misc.male)
X    {
X      py.misc.ht = randnor((int)race[i].m_b_ht, (int)race[i].m_m_ht);
X      py.misc.wt = randnor((int)race[i].m_b_wt, (int)race[i].m_m_wt);
X    }
X  else
X    {
X      py.misc.ht = randnor((int)race[i].f_b_ht, (int)race[i].f_m_ht);
X      py.misc.wt = randnor((int)race[i].f_b_wt, (int)race[i].f_m_wt);
X    }
X  py.misc.disarm = race[i].b_dis + todis_adj();
X}
X
X
X/* Gets a character class				-JWT-	*/
Xstatic void get_class()
X{
X  register int i, j;
X  int k, l, m, min_value, max_value;
X  int cl[MAX_CLASS], exit_flag;
X  register struct misc *m_ptr;
X  register player_type *p_ptr;
X  class_type *c_ptr;
X  char tmp_str[80], s;
X  int32u mask;
X
X  for (j = 0; j < MAX_CLASS; j++)
X    cl[j] = 0;
X  i = py.misc.prace;
X  j = 0;
X  k = 0;
X  l = 2;
X  m = 21;
X  mask = 0x1;
X  clear_from (20);
X  put_buffer("Choose a class (? for Help):", 20, 2);
X  do
X    {
X      if (race[i].rtclass & mask)
X	{
X	  (void) sprintf(tmp_str, "%c) %s", k+'a', class[j].title);
X	  put_buffer(tmp_str, m, l);
X	  cl[k] = j;
X	  l += 15;
X	  if (l > 70)
X	    {
X	      l = 2;
X	      m++;
X	    }
X	  k++;
X	}
X      j++;
X      mask <<= 1;
X    }
X  while (j < MAX_CLASS);
X  py.misc.pclass = 0;
X  exit_flag = FALSE;
X  do
X    {
X      move_cursor (20, 31);
X      s = inkey();
X      j = s - 'a';
X      if ((j < k) && (j >= 0))
X	{
X	  py.misc.pclass = cl[j];
X	  c_ptr = &class[py.misc.pclass];
X	  exit_flag = TRUE;
X	  clear_from (20);
X	  put_buffer(c_ptr->title, 5, 15);
X
X	  /* Adjust the stats for the class adjustment		-RAK-	*/
X	  p_ptr = &py;
X	  change_stat (A_STR, c_ptr->madj_str);
X	  change_stat (A_INT, c_ptr->madj_int);
X	  change_stat (A_WIS, c_ptr->madj_wis);
X	  change_stat (A_DEX, c_ptr->madj_dex);
X	  change_stat (A_CON, c_ptr->madj_con);
X	  change_stat (A_CHR, c_ptr->madj_chr);
X	  for(i = 0; i < 6; i++)
X	    {
X	      p_ptr->stats.cur_stat[i] = p_ptr->stats.max_stat[i];
X	      set_use_stat(i);
X	    }
X
X	  p_ptr->misc.ptodam = todam_adj();	/* Real values		*/
X	  p_ptr->misc.ptohit = tohit_adj();
X	  p_ptr->misc.ptoac  = toac_adj();
X	  p_ptr->misc.pac    = 0;
X	  p_ptr->misc.dis_td = p_ptr->misc.ptodam; /* Displayed values	*/
X	  p_ptr->misc.dis_th = p_ptr->misc.ptohit;
X	  p_ptr->misc.dis_tac= p_ptr->misc.ptoac;
X	  p_ptr->misc.dis_ac = p_ptr->misc.pac + p_ptr->misc.dis_tac;
X
X	  /* now set misc stats, do this after setting stats because
X	     of con_adj() for hitpoints */
X	  m_ptr = &py.misc;
X	  m_ptr->hitdie += c_ptr->adj_hd;
X	  m_ptr->mhp = con_adj() + m_ptr->hitdie;
X	  m_ptr->chp = m_ptr->mhp;
X	  m_ptr->chp_frac = 0;
X
X	  /* initialize hit_points array */
X	  /* put bounds on total possible hp, only succeed if it is within
X	     1/8 of average value */
X	  min_value = (MAX_PLAYER_LEVEL*3/8 * (m_ptr->hitdie-1)) +
X	    MAX_PLAYER_LEVEL;
X	  max_value = (MAX_PLAYER_LEVEL*5/8 * (m_ptr->hitdie-1)) +
X	    MAX_PLAYER_LEVEL;
X	  player_hp[0] = m_ptr->hitdie;
X	  do
X	    {
X	      for (i = 1; i < MAX_PLAYER_LEVEL; i++)
X		{
X#ifdef AMIGA		/* Stupid Aztec C 5.0 bug work around CBG */
X		  player_hp[i] = player_hp[i-1] + randint ((int)m_ptr->hitdie);
X#else
X		  player_hp[i] = randint((int)m_ptr->hitdie);
X		  player_hp[i] += player_hp[i-1];
X#endif
X		}
X	    }
X	  while ((player_hp[MAX_PLAYER_LEVEL-1] < min_value) ||
X		 (player_hp[MAX_PLAYER_LEVEL-1] > max_value));
X
X	  m_ptr->bth += c_ptr->mbth;
X	  m_ptr->bthb += c_ptr->mbthb;	/*RAK*/
X	  m_ptr->srh += c_ptr->msrh;
X	  m_ptr->disarm += c_ptr->mdis;
X	  m_ptr->fos += c_ptr->mfos;
X	  m_ptr->stl += c_ptr->mstl;
X	  m_ptr->save += c_ptr->msav;
X	  m_ptr->expfact += c_ptr->m_exp;
X	}
X      else if (s == '?')
X	helpfile (MORIA_WELCOME);
X      else
X	bell ();
X    }
X  while (!exit_flag);
X}
X
X
X/* Given a stat value, return a monetary value, which affects the amount
X   of gold a player has. */
Xstatic int monval (i)
Xint8u i;
X{
X  return 5 * ((int)i - 10);
X}
X
X
Xstatic void get_money()
X{
X  register int tmp, gold;
X  register int8u *a_ptr;
X
X  a_ptr = py.stats.max_stat;
X  tmp = monval (a_ptr[A_STR]) + monval (a_ptr[A_INT])
X      + monval (a_ptr[A_WIS]) + monval (a_ptr[A_CON])
X      + monval (a_ptr[A_DEX]);
X
X  gold = py.misc.sc*6 + randint (25) + 325;	/* Social Class adj */
X  gold -= tmp;					/* Stat adj */
X  gold += monval (a_ptr[A_CHR]);		/* Charisma adj	*/
X  if (!py.misc.male)
X    gold += 50;			/* She charmed the banker into it! -CJS- */
X  if (gold < 80)
X    gold = 80;			/* Minimum */
X  py.misc.au = gold;
X}
X
X
X/* ---------- M A I N  for Character Creation Routine ---------- */
X/*							-JWT-	*/
Xvoid create_character()
X{
X  register int exit_flag = 1;
X  register char c;
X
X  put_character();
X  choose_race();
X  get_sex();
X
X  /* here we start a loop giving a player a choice of characters -RGM- */
X  get_all_stats ();
X  get_history();
X  get_ahw();
X  print_history();
X  put_misc1();
X  put_stats();
X
X  clear_from (20);
X  put_buffer("Hit space to reroll or ESC to accept characteristics: ", 20, 2);
X  do
X    {
X      move_cursor (20, 56);
X      c = inkey();
X      if (c == ESCAPE)
X	exit_flag = 0;
X      else if (c == ' ')
X	{
X	  get_all_stats ();
X	  get_history();
X	  get_ahw();
X	  print_history();
X	  put_misc1();
X	  put_stats();
X	}
X      else
X	bell ();
X    }		    /* done with stats generation */
X  while (exit_flag == 1);
X
X  get_class();
X  get_money();
X  put_stats();
X  put_misc2();
X  put_misc3();
X  get_name();
X
X  /* This delay may be reduced, but is recommended to keep players	*/
X  /* from continuously rolling up characters, which can be VERY	*/
X  /* expensive CPU wise.						*/
X  pause_exit(23, PLAYER_EXIT_PAUSE);
X}
END_OF_FILE
if test 12803 -ne `wc -c <'source/create.c'`; then
    echo shar: \"'source/create.c'\" unpacked with wrong size!
fi
# end of 'source/create.c'
fi
if test -f 'source/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/main.c'\"
else
echo shar: Extracting \"'source/main.c'\" \(12154 characters\)
sed "s/^X//" >'source/main.c' <<'END_OF_FILE'
X/* UNIX Moria Version 5.x
X   source/main.c: initialization, main() function and main loop
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X
X/* Original copyright message follows. */
X
X/* Moria Version 4.8	COPYRIGHT (c) Robert Alan Koeneke		*/
X/*									 */
X/*	 I lovingly dedicate this game to hackers and adventurers	 */
X/*	 everywhere...							 */
X/*									 */
X/*									 */
X/*	 Designer and Programmer : Robert Alan Koeneke			 */
X/*				   University of Oklahoma		 */
X/*									 */
X/*	 Assistant Programmers	 : Jimmey Wayne Todd			 */
X/*				   University of Oklahoma		 */
X/*									 */
X/*				   Gary D. McAdoo			 */
X/*				   University of Oklahoma		 */
X/*									 */
X/*	 UNIX Port		 : James E. Wilson			 */
X/*				   UC Berkeley				 */
X/*				   wilson@kithrup.com			 */
X/*									 */
X/*	 MSDOS Port		 : Don Kneller				 */
X/*				   1349 - 10th ave			 */
X/*				   San Francisco, CA 94122		 */
X/*				   kneller@cgl.ucsf.EDU			 */
X/*				   ...ucbvax!ucsfcgl!kneller		 */
X/*				   kneller@ucsf-cgl.BITNET		 */
X/*									 */
X/*	 BRUCE Moria		 : Christopher Stuart			 */
X/*				   Monash University			 */
X/*				   Melbourne, Victoria, AUSTRALIA	 */
X/*				   cjs@moncsbruce.oz			 */
X/*									 */
X/*       Amiga Port              : Corey Gehman                          */
X/*                                 Clemson University                    */
X/*                                 cg377170@eng.clemson.edu              */
X/*									 */
X/*	 Version 5.5		 : David Grabiner			 */
X/*				   Harvard University			 */
X/*				   grabiner@math.harvard.edu		 */
X/*                                                                       */
X/*	 Moria may be copied and modified freely as long as the above	 */
X/*	 credits are retained.	No one who-so-ever may sell or market	 */
X/*	 this software in any form without the expressed written consent */
X/*	 of the author Robert Alan Koeneke.				 */
X/*									 */
X
X#ifdef __TURBOC__
X#include	<io.h>
X#include	<stdio.h>
X#include	<stdlib.h>
X#endif /* __TURBOC__ */
X 
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#ifndef USG
X#include <sys/types.h>
X#include <sys/param.h>
X#endif
X
X#ifdef USG
X#ifndef ATARIST_MWC
X#include <string.h>
X#else
X#include "string.h"
X#endif
X#else
X#include <strings.h>
X#endif
X
X#include <ctype.h>
X
X#ifdef Pyramid
X#include <sys/time.h>
X#else
X#include <time.h>
X#endif
X
X#ifndef VMS
X#ifndef MAC
X#ifndef GEMDOS
X#ifndef AMIGA
Xlong time();
X#endif
X#endif
Xchar *getenv();
X#endif
X#endif
X
X#ifndef MAC
X#ifndef AMIGA
X#ifdef USG
X#if !defined(MSDOS) && !defined(ATARIST_TC)
Xunsigned short getuid(), getgid();
X#endif
X#else
X#ifndef SECURE
X#ifdef BSD4_3
Xuid_t getuid(), getgid();
X#else  /* other BSD versions */
Xint getuid(), getgid();
X#endif
X#endif
X#endif
X#endif
X#endif
X
X#ifndef VMS
X#ifndef MAC
X#if defined(ultrix) || defined(USG)
Xvoid perror();
X#endif
X#endif
X#endif
X
X#ifndef VMS
X#ifndef MAC
X#ifdef USG
Xvoid exit();
X#endif
X#endif
X#endif
X
X/*
X#if defined(atarist) && defined(__GNUC__)
Xlong _stksize = 64*1024;
X#endif
X*/
X
X#ifdef ATARIST_MWC
Xlong _stksize = 18000;		/*(SAJ) for MWC	*/
X#endif
X
X#ifdef __TURBOC__
Xunsigned _stklen = 0x3fff;	/* increase stack from 4K to 16K */
X#endif
X
X#if defined(LINT_ARGS)
Xstatic void char_inven_init(void);
Xstatic void init_m_level(void);
Xstatic void init_t_level(void);
X#if (COST_ADJ != 100)
Xstatic void price_adjust(void);
X#endif
X#else
Xstatic void char_inven_init();
Xstatic void init_m_level();
Xstatic void init_t_level();
X#if (COST_ADJ != 100)
Xstatic void price_adjust();
X#endif
X#endif
X
X/* Initialize, restore, and get the ball rolling.	-RAK-	*/
X#ifdef MAC
X/* This is just a subroutine for the Mac version */
X/* only options passed in are -orn */
X/* save file name is never passed */
Xint moria_main(argc, argv)
Xint argc;
Xchar *argv[];
X#else
Xint main(argc, argv)
Xint argc;
Xchar *argv[];
X#endif
X{
X  int32u seed;
X  int generate;
X  int result;
X#ifndef MAC
X  char *p;
X#endif
X  int new_game = FALSE;
X  int force_rogue_like = FALSE;
X  int force_keys_to;
X
X  /* default command set defined in config.h file */
X  rogue_like_commands = ROGUE_LIKE;
X
X#ifdef SECURE
X  Authenticate();
X#endif
X
X#ifdef MSDOS
X  msdos_init();		/* find out where everything is */
X#endif
X
X  /* call this routine to grab a file pointer to the highscore file */
X  /* and prepare things to relinquish setuid privileges */
X  init_scorefile();
X
X#ifndef SECURE
X#if !defined(MSDOS) && !defined(ATARIST_MWC) && !defined(MAC)
X#if !defined(AMIGA) && !defined(ATARIST_TC)
X#if !defined(atarist)
X  if (0 != setuid(getuid()))
X    {
X      perror("Can't set permissions correctly!  Setuid call failed.\n");
X      exit(0);
X    }
X  if (0 != setgid(getgid()))
X    {
X      perror("Can't set permissions correctly!  Setgid call failed.\n");
X      exit(0);
X    }
X#endif
X#endif
X#endif
X#endif
X
X  /* use curses */
X  init_curses();
X
X#ifdef VMS
X  /* Bizarre, but yes this really is needed to make moria work correctly
X     under VMS.  */
X  restore_screen ();
X#endif
X
X  /* catch those nasty signals */
X  /* must come after init_curses as some of the signal handlers use curses */
X  init_signals();
X
X  seed = 0; /* let wizard specify rng seed */
X  /* check for user interface option */
X  for (--argc, ++argv; argc > 0 && argv[0][0] == '-'; --argc, ++argv)
X    switch (argv[0][1])
X      {
X      case 'N':
X      case 'n': new_game = TRUE; break;
X      case 'O':
X      case 'o':
X	/* rogue_like_commands may be set in get_char(), so delay this
X	   until after read savefile if any */
X	force_rogue_like = TRUE;
X	force_keys_to = FALSE;
X	break;
X      case 'R':
X      case 'r':
X	force_rogue_like = TRUE;
X	force_keys_to = TRUE;
X	break;
X#ifndef MAC
X      case 'S': display_scores(TRUE); exit_game();
X      case 's': display_scores(FALSE); exit_game();
X      case 'W':
X      case 'w':
X	to_be_wizard = TRUE;
X
X	if (isdigit((int)argv[0][2]))
X	  seed = atoi(&argv[0][2]);
X	break;
X      default: (void) printf("Usage: moria [-norsw] [savefile]\n");
X	exit_game();
X#endif
X      }
X
X#ifndef MAC
X  /* Check operating hours			*/
X  /* If not wizard  No_Control_Y	       */
X  read_times();
X#endif
X
X  /* Some necessary initializations		*/
X  /* all made into constants or initialized in variables.c */
X
X#if (COST_ADJ != 100)
X  price_adjust();
X#endif
X
X  /* Grab a random seed from the clock		*/
X  init_seeds(seed);
X
X  /* Init monster and treasure levels for allocate */
X  init_m_level();
X  init_t_level();
X
X  /* Init the store inventories			*/
X  store_init();
X
X#ifndef MAC
X  /* On Mac, if -n is passed, no savefile is used */
X  /* If -n is not passed, the calling routine will know savefile name,
X     hence, this code is not necessary */
X
X  /* Auto-restart of saved file */
X  if (argv[0] != CNIL)
X    (void) strcpy (savefile, argv[0]);
X  else if ((p = getenv("MORIA_SAV")) != CNIL)
X    (void) strcpy(savefile, p);
X  else if ((p = getenv("HOME")) != CNIL)
X#if defined(ATARIST_MWC) || defined(ATARIST_TC)
X    (void) sprintf(savefile, "%s\\%s", p, MORIA_SAV);
X#else
X#ifdef VMS
X    (void) sprintf(savefile, "%s%s", p, MORIA_SAV);
X#else
X    (void) sprintf(savefile, "%s/%s", p, MORIA_SAV);
X#endif
X#endif
X  else
X    (void) strcpy(savefile, MORIA_SAV);
X#endif
X
X/* This restoration of a saved character may get ONLY the monster memory. In
X   this case, get_char returns false. It may also resurrect a dead character
X   (if you are the wizard). In this case, it returns true, but also sets the
X   parameter "generate" to true, as it does not recover any cave details. */
X
X  result = FALSE;
X#ifdef MAC
X  if ((new_game == FALSE) && get_char(&generate))
X#else
X  if ((new_game == FALSE) && !access(savefile, 0) && get_char(&generate))
X#endif
X    result = TRUE;
X
X  /* enter wizard mode before showing the character display, but must wait
X     until after get_char in case it was just a resurrection */
X  if (to_be_wizard)
X    if (!enter_wiz_mode())
X      exit_game();
X
X  if (result)
X    {
X      change_name();
X
X      /* could be restoring a dead character after a signal or HANGUP */
X      if (py.misc.chp < 0)
X	death = TRUE;
X    }
X  else
X    {	  /* Create character	   */
X      create_character();
X#ifdef MAC
X      birth_date = time ((time_t *)0);
X#else
X      birth_date = time ((long *)0);
X#endif
X      char_inven_init();
X      py.flags.food = 7500;
X      py.flags.food_digested = 2;
X      if (class[py.misc.pclass].spell == MAGE)
X	{	  /* Magic realm   */
X	  clear_screen(); /* makes spell list easier to read */
X	  calc_spells(A_INT);
X	  calc_mana(A_INT);
X	}
X      else if (class[py.misc.pclass].spell == PRIEST)
X	{	  /* Clerical realm*/
X	  calc_spells(A_WIS);
X	  clear_screen(); /* force out the 'learn prayer' message */
X	  calc_mana(A_WIS);
X	}
X      /* prevent ^c quit from entering score into scoreboard,
X	 and prevent signal from creating panic save until this point,
X	 all info needed for save file is now valid */
X      character_generated = 1;
X      generate = TRUE;
X    }
X
X  if (force_rogue_like)
X    rogue_like_commands = force_keys_to;
X
X  magic_init();
X
X  /* Begin the game				*/
X  clear_screen();
X  prt_stat_block();
X  if (generate)
X    generate_cave();
X
X  /* Loop till dead, or exit			*/
X  while(!death)
X    {
X      dungeon();				  /* Dungeon logic */
X
X#ifndef MAC
X      /* check for eof here, see inkey() in io.c */
X      /* eof can occur if the process gets a HANGUP signal */
X      if (eof_flag)
X	{
X	  (void) strcpy(died_from, "(end of input: saved)");
X	  if (!save_char())
X	    {
X	      (void) strcpy(died_from, "unexpected eof");
X	    }
X	  /* should not reach here, by if we do, this guarantees exit */
X	  death = TRUE;
X	}
X#endif
X
X      if (!death) generate_cave();	       /* New level	*/
X    }
X
X  exit_game();		/* Character gets buried. */
X  /* should never reach here, but just in case */
X  return (0);
X}
X
X/* Init players with some belongings			-RAK-	*/
Xstatic void char_inven_init()
X{
X  register int i, j;
X  inven_type inven_init;
X
X  /* this is needed for bash to work right, it can't hurt anyway */
X  for (i = 0; i < INVEN_ARRAY_SIZE; i++)
X    invcopy(&inventory[i], OBJ_NOTHING);
X
X  for (i = 0; i < 5; i++)
X    {
X      j = player_init[py.misc.pclass][i];
X      invcopy(&inven_init, j);
X      /* this makes it known2 and known1 */
X      store_bought(&inven_init);
X      /* must set this bit to display tohit/todam for stiletto */
X      if (inven_init.tval == TV_SWORD)
X	inven_init.ident |= ID_SHOW_HITDAM;
X      (void) inven_carry(&inven_init);
X    }
X
X  /* wierd place for it, but why not? */
X  for (i = 0; i < 32; i++)
X    spell_order[i] = 99;
X}
X
X
X/* Initializes M_LEVEL array for use with PLACE_MONSTER	-RAK-	*/
Xstatic void init_m_level()
X{
X  register int i, k;
X
X  for (i = 0; i <= MAX_MONS_LEVEL; i++)
X    m_level[i] = 0;
X
X  k = MAX_CREATURES - WIN_MON_TOT;
X  for (i = 0; i < k; i++)
X    m_level[c_list[i].level]++;
X
X  for (i = 1; i <= MAX_MONS_LEVEL; i++)
X#ifdef AMIGA  /* fix a stupid MANX Aztec C 5.0 bug again */
X    m_level[i] = m_level[i] + m_level[i-1];
X#else
X    m_level[i] += m_level[i-1];
X#endif
X}
X
X
X/* Initializes T_LEVEL array for use with PLACE_OBJECT	-RAK-	*/
Xstatic void init_t_level()
X{
X  register int i, l;
X  int tmp[MAX_OBJ_LEVEL+1];
X
X  for (i = 0; i <= MAX_OBJ_LEVEL; i++)
X    t_level[i] = 0;
X  for (i = 0; i < MAX_DUNGEON_OBJ; i++)
X    t_level[object_list[i].level]++;
X  for (i = 1; i <= MAX_OBJ_LEVEL; i++)
X#ifdef AMIGA  /* fix a stupid MANX Aztec C 5.0 bug again */
X    t_level[i] = t_level[i] + t_level[i-1];
X#else
X    t_level[i] += t_level[i-1];
X#endif
X
X  /* now produce an array with object indexes sorted by level, by using
X     the info in t_level, this is an O(n) sort! */
X  /* this is not a stable sort, but that does not matter */
X  for (i = 0; i <= MAX_OBJ_LEVEL; i++)
X    tmp[i] = 1;
X  for (i = 0; i < MAX_DUNGEON_OBJ; i++)
X    {
X      l = object_list[i].level;
X      sorted_objects[t_level[l] - tmp[l]] = i;
X      tmp[l]++;
X    }
X}
X
X
X#if (COST_ADJ != 100)
X/* Adjust prices of objects				-RAK-	*/
Xstatic void price_adjust()
X{
X  register int i;
X
X  /* round half-way cases up */
X  for (i = 0; i < MAX_OBJECTS; i++)
X    object_list[i].cost = ((object_list[i].cost * COST_ADJ) + 50) / 100;
X}
X#endif
END_OF_FILE
if test 12154 -ne `wc -c <'source/main.c'`; then
    echo shar: \"'source/main.c'\" unpacked with wrong size!
fi
# end of 'source/main.c'
fi
if test -f 'source/types.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/types.h'\"
else
echo shar: Extracting \"'source/types.h'\" \(13447 characters\)
sed "s/^X//" >'source/types.h' <<'END_OF_FILE'
X/* source/types.h: global type declarations
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
Xtypedef unsigned long  int32u;
Xtypedef long	       int32;
Xtypedef unsigned short int16u;
Xtypedef short	       int16;
Xtypedef unsigned char  int8u;
X/* some machines will not accept 'signed char' as a type, and some accept it
X   but still treat it like an unsigned character, let's just avoid it,
X   any variable which can ever hold a negative value must be 16 or 32 bits */
X
X#define VTYPESIZ	80
X#define BIGVTYPESIZ	160
Xtypedef char vtype[VTYPESIZ];
X/* note that since its output can easily exceed 80 characters, objdes must
X   always be called with a bigvtype as the first paramter */
Xtypedef char bigvtype[BIGVTYPESIZ];
Xtypedef char stat_type[7];
X
X/* Many of the character fields used to be fixed length, which greatly
X   increased the size of the executable.  I have replaced many fixed
X   length fields with variable length ones. */
X
X/* all fields are given the smallest possbile type, and all fields are
X   aligned within the structure to their natural size boundary, so that
X   the structures contain no padding and are minimum size */
X
X/* bit fields are only used where they would cause a large reduction in
X   data size, they should not be used otherwise because their use
X   results in larger and slower code */
X
Xtypedef struct creature_type
X{
X  char *name;		/* Descrip of creature	*/
X  int32u cmove;		/* Bit field		*/
X  int32u spells;	/* Creature spells	*/
X  int16u cdefense;	/* Bit field		*/
X  int16u mexp;		/* Exp value for kill	*/
X  int8u sleep;		/* Inactive counter/10	*/
X  int8u aaf;		/* Area affect radius	*/
X  int8u ac;		/* AC			*/
X  int8u speed;		/* Movement speed+10	*/
X  int8u cchar;		/* Character rep.	*/
X  int8u hd[2];		/* Creatures hit die	*/
X  int8u damage[4];	/* Type attack and damage*/
X  int8u level;		/* Level of creature	*/
X} creature_type;
X
Xtypedef struct m_attack_type	/* Monster attack and damage types */
X  {
X    int8u attack_type;
X    int8u attack_desc;
X    int8u attack_dice;
X    int8u attack_sides;
X  } m_attack_type;
X
Xtypedef struct recall_type	/* Monster memories. -CJS- */
X  {
X    int32u r_cmove;
X    int32u r_spells;
X    int16u r_kills, r_deaths;
X    int16u r_cdefense;
X    int8u r_wake, r_ignore;
X    int8u r_attacks[MAX_MON_NATTACK];
X  } recall_type;
X
Xtypedef struct monster_type
X{
X  int16 hp;		/* Hit points		*/
X  int16 csleep;		/* Inactive counter	*/
X  int16 cspeed;		/* Movement speed	*/
X  int16u mptr;		/* Pointer into creature*/
X  /* Note: fy, fx, and cdis constrain dungeon size to less than 256 by 256 */
X  int8u fy;		/* Y Pointer into map	*/
X  int8u fx;		/* X Pointer into map	*/
X  int8u cdis;		/* Cur dis from player	*/
X  int8u ml;
X  int8u stunned;
X  int8u confused;
X} monster_type;
X
Xtypedef struct treasure_type
X{
X  char *name;		/* Object name		*/
X  int32u flags;		/* Special flags	*/
X  int8u tval;		/* Category number	*/
X  int8u tchar;		/* Character representation*/
X  int16 p1;		/* Misc. use variable	*/
X  int32 cost;		/* Cost of item		*/
X  int8u subval;		/* Sub-category number	*/
X  int8u number;		/* Number of items	*/
X  int16u weight;	/* Weight		*/
X  int16 tohit;		/* Plusses to hit	*/
X  int16 todam;		/* Plusses to damage	*/
X  int16 ac;		/* Normal AC		*/
X  int16 toac;		/* Plusses to AC	*/
X  int8u damage[2];	/* Damage when hits	*/
X  int8u level;		/* Level item first found */
X} treasure_type;
X
X/* only damage, ac, and tchar are constant; level could possibly be made
X   constant by changing index instead; all are used rarely */
X/* extra fields x and y for location in dungeon would simplify pusht() */
X/* making inscrip a pointer and mallocing space does not work, there are
X   two many places where inven_types are copied, which results in dangling
X   pointers, so we use a char array for them instead */
X#define INSCRIP_SIZE 13  /* notice alignment, must be 4*x + 1 */
Xtypedef struct inven_type
X{
X  int16u index;		/* Index to object_list */
X  int8u name2;		/* Object special name  */
X  char inscrip[INSCRIP_SIZE]; /* Object inscription   */
X  int32u flags;		/* Special flags	*/
X  int8u tval;		/* Category number	*/
X  int8u tchar;		/* Character representation*/
X  int16 p1;		/* Misc. use variable	*/
X  int32 cost;		/* Cost of item		*/
X  int8u subval;		/* Sub-category number	*/
X  int8u number;		/* Number of items	*/
X  int16u weight;	/* Weight		*/
X  int16 tohit;		/* Plusses to hit	*/
X  int16 todam;		/* Plusses to damage	*/
X  int16 ac;		/* Normal AC		*/
X  int16 toac;		/* Plusses to AC	*/
X  int8u damage[2];	/* Damage when hits	*/
X  int8u level;		/* Level item first found */
X  int8u ident;		/* Identify information */
X} inven_type;
X
X#define PLAYER_NAME_SIZE 27
X
Xtypedef struct player_type
X{
X  struct misc
X    {
X      char name[PLAYER_NAME_SIZE];	/* Name of character	*/
X      int8u male;	/* Sex of character	*/
X      int32 au;		/* Gold			*/
X      int32 max_exp;	/* Max experience	*/
X      int32 exp;	/* Cur experience	*/
X      int16u exp_frac;	/* Cur exp fraction * 2^16 */
X      int16u age;	/* Characters age	*/
X      int16u ht;	/* Height		*/
X      int16u wt;	/* Weight		*/
X      int16u lev;	/* Level		*/
X      int16u max_dlv;	/* Max level explored	*/
X      int16 srh;	/* Chance in search	*/
X      int16 fos;	/* Frenq of search	*/
X      int16 bth;	/* Base to hit		*/
X      int16 bthb;	/* BTH with bows	*/
X      int16 mana;	/* Mana points		*/
X      int16 mhp;	/* Max hit pts		*/
X      int16 ptohit;	/* Plusses to hit	*/
X      int16 ptodam;	/* Plusses to dam	*/
X      int16 pac;	/* Total AC		*/
X      int16 ptoac;	/* Magical AC		*/
X      int16 dis_th;	/* Display +ToHit	*/
X      int16 dis_td;	/* Display +ToDam	*/
X      int16 dis_ac;	/* Display +ToAC	*/
X      int16 dis_tac;	/* Display +ToTAC	*/
X      int16 disarm;	/* % to Disarm		*/
X      int16 save;	/* Saving throw		*/
X      int16 sc;		/* Social Class		*/
X      int16 stl;	/* Stealth factor	*/
X      int8u pclass;	/* # of class		*/
X      int8u prace;	/* # of race		*/
X      int8u hitdie;	/* Char hit die		*/
X      int8u expfact;	/* Experience factor	*/
X      int16 cmana;	/* Cur mana pts		*/
X      int16u cmana_frac; /* Cur mana fraction * 2^16 */
X      int16 chp;	/* Cur hit pts		*/
X      int16u chp_frac;	/* Cur hit fraction * 2^16 */
X      char history[4][60]; /* History record	*/
X    } misc;
X  /* Stats now kept in arrays, for more efficient access. -CJS- */
X  struct stats
X    {
X      int8u max_stat[6];	/* What is restored */
X      int8u cur_stat[6];	/* What is natural */
X      int16 mod_stat[6];	/* What is modified, may be +/- */
X      int8u use_stat[6];	/* What is used */
X    } stats;
X  struct flags
X    {
X      int32u status;		/* Status of player    */
X      int16 rest;		/* Rest counter	       */
X      int16 blind;		/* Blindness counter   */
X      int16 paralysis;		/* Paralysis counter   */
X      int16 confused;		/* Confusion counter   */
X      int16 food;		/* Food counter	       */
X      int16 food_digested;	/* Food per round      */
X      int16 protection;		/* Protection fr. evil */
X      int16 speed;		/* Cur speed adjust    */
X      int16 fast;		/* Temp speed change   */
X      int16 slow;		/* Temp speed change   */
X      int16 afraid;		/* Fear		       */
X      int16 poisoned;		/* Poisoned	       */
X      int16 image;		/* Hallucinate	       */
X      int16 protevil;		/* Protect VS evil     */
X      int16 invuln;		/* Increases AC	       */
X      int16 hero;		/* Heroism	       */
X      int16 shero;		/* Super Heroism       */
X      int16 blessed;		/* Blessed	       */
X      int16 resist_heat;	/* Timed heat resist   */
X      int16 resist_cold;	/* Timed cold resist   */
X      int16 detect_inv;		/* Timed see invisible */
X      int16 word_recall;	/* Timed teleport level*/
X      int16 see_infra;		/* See warm creatures  */
X      int16 tim_infra;		/* Timed infra vision  */
X      int8u see_inv;		/* Can see invisible   */
X      int8u teleport;		/* Random teleportation*/
X      int8u free_act;		/* Never paralyzed     */
X      int8u slow_digest;	/* Lower food needs    */
X      int8u aggravate;		/* Aggravate monsters  */
X      int8u fire_resist;	/* Resistance to fire  */
X      int8u cold_resist;	/* Resistance to cold  */
X      int8u acid_resist;	/* Resistance to acid  */
X      int8u regenerate;		/* Regenerate hit pts  */
X      int8u lght_resist;	/* Resistance to light */
X      int8u ffall;		/* No damage falling   */
X      int8u sustain_str;	/* Keep strength       */
X      int8u sustain_int;	/* Keep intelligence   */
X      int8u sustain_wis;	/* Keep wisdom	       */
X      int8u sustain_con;	/* Keep constitution   */
X      int8u sustain_dex;	/* Keep dexterity      */
X      int8u sustain_chr;	/* Keep charisma       */
X      int8u confuse_monster;	/* Glowing hands.    */
X      int8u new_spells;		/* Number of spells can learn. */
X    } flags;
X} player_type;
X
Xtypedef struct spell_type
X{  /* spell name is stored in spell_names[] array at index i, +31 if priest */
X  int8u slevel;
X  int8u smana;
X  int8u sfail;
X  int8u sexp;	/* 1/4 of exp gained for learning spell */
X} spell_type;
X
Xtypedef struct race_type
X{
X  char	*trace;		/* Type of race			*/
X  int16 str_adj;	/* adjustments			*/
X  int16 int_adj;
X  int16 wis_adj;
X  int16 dex_adj;
X  int16 con_adj;
X  int16 chr_adj;
X  int8u b_age;	       /* Base age of character		*/
X  int8u m_age;	       /* Maximum age of character	*/
X  int8u m_b_ht;	      /* base height for males		*/
X  int8u m_m_ht;	      /* mod height for males		*/
X  int8u m_b_wt;	      /* base weight for males		*/
X  int8u m_m_wt;	      /* mod weight for males		*/
X  int8u f_b_ht;	      /* base height females		*/
X  int8u f_m_ht;	      /* mod height for females	*/
X  int8u f_b_wt;	      /* base weight for female	*/
X  int8u f_m_wt;	      /* mod weight for females	*/
X  int16 b_dis;	       /* base chance to disarm		*/
X  int16 srh;	       /* base chance for search	*/
X  int16 stl;	       /* Stealth of character		*/
X  int16 fos;	       /* frequency of auto search	*/
X  int16 bth;	       /* adj base chance to hit	*/
X  int16 bthb;	       /* adj base to hit with bows	*/
X  int16 bsav;	       /* Race base for saving throw	*/
X  int8u bhitdie;	       /* Base hit points for race	*/
X  int8u infra;	       /* See infra-red			*/
X  int8u b_exp;	       /* Base experience factor	*/
X  int8u rtclass;       /* Bit field for class types	*/
X} race_type;
X
Xtypedef struct class_type
X{
X  char *title;		/* type of class		*/
X  int8u adj_hd;		/* Adjust hit points		*/
X  int8u mdis;		/* mod disarming traps		*/
X  int8u msrh;		/* modifier to searching	*/
X  int8u mstl;		/* modifier to stealth		*/
X  int8u mfos;		/* modifier to freq-of-search	*/
X  int8u mbth;		/* modifier to base to hit	*/
X  int8u mbthb;		/* modifier to base to hit - bows*/
X  int8u msav;		/* Class modifier to save	*/
X  int16 madj_str;	/* Class modifier for strength	*/
X  int16 madj_int;	/* Class modifier for intelligence*/
X  int16 madj_wis;	/* Class modifier for wisdom	*/
X  int16 madj_dex;	/* Class modifier for dexterity */
X  int16 madj_con;	/* Class modifier for constitution*/
X  int16 madj_chr;	/* Class modifier for charisma	*/
X  int8u spell;		/* class use mage spells	*/
X  int8u m_exp;		/* Class experience factor	*/
X  int8u first_spell_lev;/* First level where class can use spells. */
X} class_type;
X
Xtypedef struct background_type
X{
X  char *info;		/* History information		*/
X  int8u roll;		/* Die roll needed for history	*/
X  int8u chart;		/* Table number			*/
X  int8u next;		/* Pointer to next table	*/
X  int8u bonus;		/* Bonus to the Social Class+50	*/
X} background_type;
X
Xtypedef struct cave_type
X{
X#ifdef AMIGA
X  /* This reduces the size from 64 bits to 32 bits. */
X  unsigned int cptr : 8;
X  unsigned int tptr : 8;
X  unsigned int fval : 8;
X#else
X  int8u cptr;
X  int8u tptr;
X  int8u fval;
X#endif
X#if !defined(MSDOS) && !defined(ATARIST_MWC)
X  unsigned int lr : 1;  /* room should be lit with perm light, walls with
X			   this set should be perm lit after tunneled out */
X  unsigned int fm : 1;	/* field mark, used for traps/doors/stairs, object is
X			   hidden if fm is FALSE */
X  unsigned int pl : 1;	/* permanent light, used for walls and lighted rooms */
X  unsigned int tl : 1;	/* temporary light, used for player's lamp light,etc.*/
X#else
X#ifndef __TURBOC__
X  /* this is not legal ANSI C, this is a MSC extension, which will use 1 byte
X     for the bitfields whereas MSC uses 2 bytes for the bitfields above */
X  /* this is also a MWC extension on the Atari ST */
X  unsigned char lr : 1;
X  unsigned char fm : 1;
X  unsigned char pl : 1;
X  unsigned char tl : 1;
X#else
X  unsigned lr : 1;
X  unsigned fm : 1;
X  unsigned pl : 1;
X  unsigned tl : 1;
X#endif
X#endif
X} cave_type;
X
Xtypedef struct owner_type
X{
X  char *owner_name;
X  int16 max_cost;
X  int8u max_inflate;
X  int8u min_inflate;
X  int8u haggle_per;
X  int8u owner_race;
X  int8u insult_max;
X} owner_type;
X
Xtypedef struct inven_record
X{
X  int32 scost;
X  inven_type sitem;
X} inven_record;
X
Xtypedef struct store_type
X{
X  int32 store_open;
X  int16 insult_cur;
X  int8u owner;
X  int8u store_ctr;
X  int16u good_buy;
X  int16u bad_buy;
X  inven_record store_inven[STORE_INVEN_MAX];
X} store_type;
X
X/* 64 bytes for this structure */
Xtypedef struct high_scores
X{
X  int32 points;
X  int32 birth_date;
X  int16 uid;
X  int16 mhp;
X  int16 chp;
X  int8u dun_level;
X  int8u lev;
X  int8u max_dlv;
X  int8u sex;
X  int8u race;
X  int8u class;
X  char name[PLAYER_NAME_SIZE];
X  char died_from[25];
X} high_scores;
END_OF_FILE
if test 13447 -ne `wc -c <'source/types.h'`; then
    echo shar: \"'source/types.h'\" unpacked with wrong size!
fi
# end of 'source/types.h'
fi
echo shar: End of archive 30 \(of 39\).
cp /dev/null ark30isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
