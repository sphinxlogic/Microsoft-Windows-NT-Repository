Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i052:  umoria4 - single player dungeon simulation (ver. 5.5), Part20/39
Message-ID: <3416@master.CNA.TEK.COM>
Date: 22 Aug 92 22:12:17 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2135
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 52
Archive-name: umoria4/Part20
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 20 (of 39)."
# Contents:  atari_st/Makefile.tc mac/moria.r source/store2.c
# Wrapped by billr@saab on Thu Aug 20 09:11:31 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'atari_st/Makefile.tc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'atari_st/Makefile.tc'\"
else
echo shar: Extracting \"'atari_st/Makefile.tc'\" \(3833 characters\)
sed "s/^X//" >'atari_st/Makefile.tc' <<'END_OF_FILE'
X# BINDIR is the directory where the moria binary will be put
X# LIBDIR is where the other files (scoreboard, news, hours) will be put
X# LIBDIR must be the same directory defined in config.h
X# this was clipped from the link command: -lcurses -ltermcap
XBINDIR = \umoria
XLIBDIR = \umorie\files
X
XCFLAGS = -DGEMDOS -O
XCC = cc
X
XSRCS = main.c misc1.c misc2.c misc3.c misc4.c store1.c files.c io.c \
X	create.c desc.c generate.c sets.c dungeon.c creature.c death.c \
X	eat.c help.c magic.c potions.c prayer.c save.c staffs.c wands.c \
X	scrolls.c spells.c wizard.c store2.c signals.c moria1.c moria2.c \
X	moria3.c moria4.c monsters.c treasure.c variable.c rnd.c recall.c \
X	atarist.c player.c tables.c
X
XOBJS = main.o misc1.o misc2.o misc3.o misc4.o store1.o files.o io.o \
X	create.o desc.o generate.o sets.o dungeon.o creature.o death.o \
X	eat.o help.o magic.o potions.o prayer.o save.o staffs.o wands.o \
X	scrolls.o spells.o wizard.o store2.o signals.o moria1.o moria2.o \
X	moria3.o moria4.o monsters.o treasure.o variable.o rnd.o recall.o \
X	atarist.o curses.o player.o tables.o
X
XLIBFILES = moria_hours moria_help moria_orig_help moria_wiz_help \
X	moria_orig_wiz_help moria_man
X
Xmoria : $(OBJS)
X#	$(CC) -o moria $(CFLAGS) $(OBJS)
X#	\tc\tlink -C=moria.lnk
X
Xlibfiles: $(LIBFILES)
X	chmod 444 $(LIBFILES)
X	cp $(LIBFILES) $(LIBDIR)
X
X$(BINDIR):
X	mkdir $(BINDIR)
X	chmod 755 $(BINDIR)
X
X$(LIBDIR):
X	mkdir $(LIBDIR)
X	chmod 711 $(LIBDIR)
X
X$(LIBDIR)/moria_hours: moria_hours
X	chmod 644 moria_hours
X	cp moria_hours $(LIBDIR)
X
Xlintout : $(SRCS)
X	lint $(SRCS) -lcurses -ltermcap > lintout
X
Xlintout2 : $(SRCS)
X	lint -bach $(SRCS) -lcurses -ltermcap > lintout
X
XTAGS : $(SRCS)
X	ctags -x $(SRCS) > TAGS
X
X# you must define BINDIR and LIBDIR before installing
Xinstall:
X	cp moria $(BINDIR)
X	cp Moria_hours $(LIBDIR)
X	cp Moria_news $(LIBDIR)
X	cp Highscores $(LIBDIR)
X	chmod 4511 $(BINDIR)/moria
X	chmod 644 $(LIBDIR)/Highscores
X	chmod 444 $(LIBDIR)/Moria_news
X	chmod 444 $(LIBDIR)/Moria_hours
X	chmod 555 $(LIBDIR)
X
Xclean:
X	rm -r *.o
X	rm -i moria
X
Xcreate.o: constant.h types.h externs.h config.h
Xcreature.o: constant.h types.h externs.h config.h
Xdeath.o: constant.h types.h externs.h config.h
Xdesc.o: constant.h types.h externs.h config.h
Xdungeon.o: constant.h types.h externs.h config.h
Xeat.o: constant.h types.h externs.h config.h
Xfiles.o: constant.h types.h externs.h config.h
Xgenerate.o: constant.h types.h externs.h config.h
Xhelp.o: constant.h types.h externs.h config.h
Xio.o: constant.h types.h externs.h config.h
Xmagic.o: constant.h types.h externs.h config.h
Xmain.o: constant.h types.h externs.h config.h
Xmisc1.o: constant.h types.h externs.h config.h
Xmisc2.o: constant.h types.h externs.h config.h
Xmisc3.o: constant.h types.h externs.h config.h
Xmisc4.o: constant.h types.h externs.h config.h
Xmonsters.o: constant.h types.h config.h
Xmoria1.o: constant.h types.h externs.h config.h
Xmoria2.o: constant.h types.h externs.h config.h
Xmoria3.o: constant.h types.h externs.h config.h
Xmoria4.o: constant.h types.h externs.h config.h
Xplayer.o: constant.h types.h config.h
Xpotions.o: constant.h types.h externs.h config.h
Xprayer.o: constant.h types.h externs.h config.h
Xrecall.o: constant.h config.h types.h externs.h
Xrnd.o: constant.h types.h
Xsave.o: constant.h types.h externs.h config.h
Xscrolls.o: constant.h types.h externs.h config.h
Xsets.o: constant.h config.h
Xsignals.o: constant.h types.h externs.h config.h
Xspells.o: constant.h types.h externs.h config.h
Xstaffs.o: constant.h types.h externs.h config.h
Xstore1.o: constant.h types.h externs.h config.h
Xstore2.o: constant.h types.h externs.h config.h
Xtables.o: constant.h types.h config.h
Xtreasure.o: constant.h types.h config.h
Xatarist.o: constant.h config.h types.h externs.h
Xvariable.o: constant.h types.h config.h
Xwands.o: constant.h types.h externs.h config.h
Xwizard.o: constant.h types.h externs.h config.h
END_OF_FILE
if test 3833 -ne `wc -c <'atari_st/Makefile.tc'`; then
    echo shar: \"'atari_st/Makefile.tc'\" unpacked with wrong size!
fi
# end of 'atari_st/Makefile.tc'
fi
if test -f 'mac/moria.r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/moria.r'\"
else
echo shar: Extracting \"'mac/moria.r'\" \(19941 characters\)
sed "s/^X//" >'mac/moria.r' <<'END_OF_FILE'
X/* mac/moria.r: MacMoria resources, for Mac functionality
X
X   Copyright (c) 1989-92 Curtis McCauley, James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include "Types.r"
X
Xinclude "ScrnMgr.rsrc";
X
Xtype 'MRIA' as 'STR ';
X
Xtype 'CNFG' (256 : 257) {
X	longint;
X};
X
Xtype 'TEXT' {
X	string;
X};
X
Xresource 'MRIA' (0) {
X	"Moria 5.4 for the Macintosh"
X};
X
Xresource 'BNDL' (128, purgeable) {
X	'MRIA',
X	0,
X	{ /* array TypeArray: 2 elements */
X		/* [1] */
X		'ICN#',
X		{ /* array IDArray: 3 elements */
X			/* [1] Application */
X			0, 128,
X			/* [2] Save file */
X			1, 129,
X			/* [3] Aux files */
X			2, 130
X		},
X		/* [2] */
X		'FREF',
X		{ /* array IDArray: 5 elements */
X			/* [1] Appilication */
X			0, 128,
X			/* [2] Save file */
X			1, 129,
X			/* [3] Info files */
X			2, 130,
X			/* [4] Score file */
X			3, 131,
X			/* [5] Config file */
X			4, 132
X		}
X	}
X};
X
Xresource 'FREF' (128, "Application", purgeable) {
X	'APPL',
X	0,
X	""
X};
X
Xresource 'FREF' (129, "Save Files", purgeable) {
X	'SAVE',
X	1,
X	""
X};
X
Xresource 'FREF' (130, "Info Files", purgeable) {
X	'TEXT',
X	2,
X	""
X};
X
Xresource 'FREF' (131, "Score File", purgeable) {
X	'SCOR',
X	2,
X	""
X};
X
Xresource 'FREF' (132, "Config File", purgeable) {
X	'CNFG',
X	2,
X	""
X};
X
Xresource 'ICON' (128, "Application", purgeable) {
X	$"00 01 00 00 00 02 80 00 00 04 40 00 00 08 20 00"
X	$"00 10 10 00 00 22 08 00 00 45 04 00 00 88 82 00"
X	$"01 05 15 00 02 02 A8 80 04 40 40 40 08 A8 80 20"
X	$"11 15 00 10 24 8A 00 28 40 51 3F 44 91 20 C0 8A"
X	$"40 00 80 51 24 41 30 22 10 01 C8 14 09 1E 7F 8F"
X	$"04 02 30 07 02 41 00 07 01 00 80 07 00 80 60 07"
X	$"00 40 1F E7 00 20 02 1F 00 10 04 07 00 08 08 00"
X	$"00 04 10 00 00 02 20 00 00 01 40 00 00 00 80"
X};
X
Xresource 'ICON' (256, "Command Set", purgeable) {
X	$"00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
X	$"00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
X	$"00 00 00 00 7F FF FF FE 80 00 00 01 9A AA AA A9"
X	$"80 00 00 01 95 55 55 59 80 00 00 01 9A AA AA A9"
X	$"80 00 00 01 85 7F FF 51 80 00 00 01 80 00 00 01"
X	$"7F FF FF FE"
X};
X
Xresource 'ICON' (257, "TEXT Editor", purgeable) {
X	$"0F FF FE 00 08 00 03 00 08 00 02 80 08 00 02 40"
X	$"08 00 02 20 08 00 02 10 08 00 03 F8 08 00 00 08"
X	$"08 00 00 08 08 07 C0 08 08 0F E0 08 08 18 30 08"
X	$"08 30 18 08 08 20 18 08 08 00 18 08 08 00 30 08"
X	$"08 00 60 08 08 00 C0 08 08 01 80 08 08 01 80 08"
X	$"08 01 80 08 08 01 80 08 08 00 00 08 08 01 80 08"
X	$"08 03 C0 08 08 01 80 08 08 00 00 08 08 00 00 08"
X	$"08 00 00 08 08 00 00 08 08 00 00 08 0F FF FF F8"
X};
X
Xresource 'ICN#' (128, "Application", purgeable) {
X	{ /* array: 2 elements */
X		/* [1] */
X		$"00 01 00 00 00 02 80 00 00 04 40 00 00 08 20 00"
X		$"00 10 10 00 00 22 08 00 00 45 04 00 00 88 82 00"
X		$"01 05 15 00 02 02 A8 80 04 40 40 40 08 A8 80 20"
X		$"11 15 00 10 24 8A 00 28 40 51 3F 44 91 20 C0 8A"
X		$"40 00 80 51 24 41 30 22 10 01 C8 14 09 1E 7F 8F"
X		$"04 02 30 07 02 41 00 07 01 00 80 07 00 80 60 07"
X		$"00 40 1F E7 00 20 02 1F 00 10 04 07 00 08 08 00"
X		$"00 04 10 00 00 02 20 00 00 01 40 00 00 00 80",
X		/* [2] */
X		$"00 01 00 00 00 03 80 00 00 07 C0 00 00 0F E0 00"
X		$"00 1F F0 00 00 3F F8 00 00 7F FC 00 00 FF FE 00"
X		$"01 FF FF 00 03 FF FF 80 07 FF FF C0 0F FF FF E0"
X		$"1F FF FF F0 3F FF FF F8 7F FF FF FC FF FF FF FE"
X		$"7F FF FF FF 3F FF FF FE 1F FF FF FC 0F FF FF FF"
X		$"07 FF FF FF 03 FF FF FF 01 FF FF FF 00 FF FF FF"
X		$"00 7F FF FF 00 3F FE 1F 00 1F FC 07 00 0F F8 00"
X		$"00 07 F0 00 00 03 E0 00 00 01 C0 00 00 00 80"
X	}
X};
X
Xresource 'ICN#' (129, "Save Files", purgeable) {
X	{ /* array: 2 elements */
X		/* [1] */
X		$"0F FF FE 00 08 00 03 00 08 00 02 80 08 00 02 40"
X		$"08 00 02 20 08 00 02 10 08 00 03 F8 08 00 00 08"
X		$"08 00 00 08 08 7F FE 08 08 FF FF 08 09 80 01 88"
X		$"09 9F F9 88 09 B0 09 88 09 B1 29 88 09 92 A9 88"
X		$"09 91 29 88 09 B0 49 88 09 B0 09 88 09 9F F9 88"
X		$"09 80 01 88 09 FF FF 88 09 FF FF 88 09 80 01 88"
X		$"08 00 00 08 09 12 64 88 09 B5 55 48 09 55 65 C8"
X		$"09 15 55 48 09 12 55 48 08 00 00 08 0F FF FF F8",
X		/* [2] */
X		$"0F FF FE 00 0F FF FF 00 0F FF FF 80 0F FF FF C0"
X		$"0F FF FF E0 0F FF FF F0 0F FF FF F8 0F FF FF F8"
X		$"0F FF FF F8 0F FF FF F8 0F FF FF F8 0F FF FF F8"
X		$"0F FF FF F8 0F FF FF F8 0F FF FF F8 0F FF FF F8"
X		$"0F FF FF F8 0F FF FF F8 0F FF FF F8 0F FF FF F8"
X		$"0F FF FF F8 0F FF FF F8 0F FF FF F8 0F FF FF F8"
X		$"0F FF FF F8 0F FF FF F8 0F FF FF F8 0F FF FF F8"
X		$"0F FF FF F8 0F FF FF F8 0F FF FF F8 0F FF FF F8"
X	}
X};
X
Xresource 'ICN#' (130, "Aux Files", purgeable) {
X	{ /* array: 2 elements */
X		/* [1] */
X		$"0F FF FE 00 08 00 03 00 08 00 02 80 09 FB AE 40"
X		$"08 00 02 20 08 00 02 10 09 F7 7B F8 08 00 00 08"
X		$"08 00 00 08 09 BB ED C8 08 00 00 08 08 00 00 08"
X		$"09 F7 B7 C8 08 00 00 08 08 00 00 08 09 B5 FD C8"
X		$"08 00 00 08 08 00 00 08 09 77 B6 C8 08 00 00 08"
X		$"08 00 00 08 09 EB B7 48 08 00 00 08 08 00 00 08"
X		$"08 00 00 08 09 12 64 88 09 B5 55 48 09 55 65 C8"
X		$"09 15 55 48 09 12 55 48 08 00 00 08 0F FF FF F8",
X		/* [2] */
X		$"0F FF FE 00 0F FF FF 00 0F FF FF 80 0F FF FF C0"
X		$"0F FF FF E0 0F FF FF F0 0F FF FF F8 0F FF FF F8"
X		$"0F FF FF F8 0F FF FF F8 0F FF FF F8 0F FF FF F8"
X		$"0F FF FF F8 0F FF FF F8 0F FF FF F8 0F FF FF F8"
X		$"0F FF FF F8 0F FF FF F8 0F FF FF F8 0F FF FF F8"
X		$"0F FF FF F8 0F FF FF F8 0F FF FF F8 0F FF FF F8"
X		$"0F FF FF F8 0F FF FF F8 0F FF FF F8 0F FF FF F8"
X		$"0F FF FF F8 0F FF FF F8 0F FF FF F8 0F FF FF F8"
X	}
X};
X
Xresource 'DLOG' (128, "About", purgeable) {
X	{46, 26, 304, 274},
X	dBoxProc,
X	invisible,
X	noGoAway,
X	0x0,
X	128,
X	""
X};
X
Xresource 'DITL' (128, "About", purgeable) {
X	{	/* array DITLarray: 4 elements */
X		/* [1] */
X		{224, 192, 247, 235},
X		Button {
X			enabled,
X			"OK"
X		},
X		/* [2] */
X		{232, 224, 241, 233},
X		UserItem {
X			disabled
X		},
X		/* [3] */
X		{16, 8, 248, 184},
X		StaticText {
X			disabled,
X			"Moria for the Macintosh\n"
X			"Version 5.4\n"
X			"Programmers:\n"
X			"Robert Alan Koeneke\n"
X			"Jimmey Wayne Todd\n\n"
X			"UNIX Port:\n"
X			"James E. Wilson\n\n"
X			"Macintosh Port:\n"
X			"Curtis W. McCauley"
X		},
X		/* [4] */
X		{16, 195, 48, 227},
X		Icon {
X			disabled,
X			128
X		}
X	}
X};
X
Xresource 'STR ' (128, "About Title", purgeable) {
X	"About Moria\311"
X};
X
Xresource 'CNFG' (256, "Command Set", purgeable) {
X	'-o\0x00\0x00'
X};
X
Xresource 'DLOG' (256, "Command Set", purgeable) {
X	{42, 34, 218, 404},
X	dBoxProc,
X	invisible,
X	noGoAway,
X	0x0,
X	256,
X	""
X};
X
Xresource 'DITL' (256, "Command Set", purgeable) {
X	{	/* array DITLarray: 9 elements */
X		/* [1] */
X		{24, 296, 48, 352},
X		Button {
X			enabled,
X			"OK"
X		},
X		/* [2] */
X		{64, 296, 88, 352},
X		Button {
X			enabled,
X			"Cancel"
X		},
X		/* [3] */
X		{40, 24, 56, 200},
X		RadioButton {
X			enabled,
X			"Rogue-Like Commands"
X		},
X		/* [4] */
X		{64, 24, 80, 200},
X		RadioButton {
X			enabled,
X			"Original Commands"
X		},
X		/* [5] */
X		{112, 72, 168, 352},
X		StaticText {
X			disabled,
X			"Choose the desired command set.  The change "
X			"will take effect when you start the next game."
X		},
X		/* [6] */
X		{16, 16, 96, 232},
X		UserItem {
X			disabled
X		},
X		/* [7] */
X		{8, 24, 24, 104},
X		StaticText {
X			enabled,
X			"Choose One"
X		},
X		/* [8] */
X		{32, 336, 40, 344},
X		UserItem {
X			disabled
X		},
X		/* [9] */
X		{112, 16, 144, 48},
X		Icon {
X			disabled,
X			256
X		}
X	}
X};
X
Xresource 'CNFG' (257, "TEXT Editor", purgeable) {
X	'MACA'
X};
X
Xresource 'DLOG' (257, "TEXT Editor", purgeable) {
X	{42, 34, 226, 426},
X	dBoxProc,
X	invisible,
X	noGoAway,
X	0x0,
X	257,
X	""
X};
X
Xresource 'DITL' (257, "TEXT Editor", purgeable) {
X	{	/* array DITLarray: 11 elements */
X		/* [1] */
X		{24, 320, 48, 376},
X		Button {
X			enabled,
X			"OK"
X		},
X		/* [2] */
X		{64, 320, 88, 376},
X		Button {
X			enabled,
X			"Cancel"
X		},
X		/* [3] */
X		{40, 24, 56, 200},
X		RadioButton {
X			enabled,
X			"MacWrite"
X		},
X		/* [4] */
X		{64, 24, 80, 176},
X		RadioButton {
X			enabled,
X			"Microsoft Word"
X		},
X		/* [5] */
X		{88, 24, 104, 176},
X		RadioButton {
X			enabled,
X			"Other:  File Creator"
X		},
X		/* [6] */
X		{88, 176, 104, 240},
X		EditText {
X			disabled,
X			""
X		},
X		/* [7] */
X		{136, 72, 176, 376},
X		StaticText {
X			disabled,
X			"Choose what kind of documents you want Moria "
X			"to create when it prints to a file."
X		},
X		/* [8] */
X		{16, 8, 120, 264},
X		UserItem {
X			disabled
X		},
X		/* [9] */
X		{8, 24, 24, 104},
X		StaticText {
X			enabled,
X			"Choose One"
X		},
X		/* [10] */
X		{32, 360, 40, 368},
X		UserItem {
X			disabled
X		},
X		/* [11] */
X		{136, 16, 168, 48},
X		Icon {
X			disabled,
X			257
X		}
X	}
X};
X
Xresource 'DLOG' (258, "Save, Quit, or Cancel", purgeable) {
X	{40, 40, 168, 318},
X	dBoxProc,
X	invisible,
X	noGoAway,
X	0x0,
X	258,
X	""
X};
X
Xresource 'DITL' (258, "Save, Quit, or Cancel", purgeable) {
X	{	/* array DITLarray: 6 elements */
X		/* [1] */
X		{64, 16, 84, 76},
X		Button {
X			enabled,
X			"Save"
X		},
X		/* [2] */
X		{96, 16, 116, 76},
X		Button {
X			enabled,
X			"Quit"
X		},
X		/* [3] */
X		{96, 200, 116, 260},
X		Button {
X			enabled,
X			"Cancel"
X		},
X		/* [4] */
X		{64, 200, 80, 216},
X		UserItem {
X			disabled
X		},
X		/* [5] */
X		{8, 56, 48, 264},
X		StaticText {
X			disabled,
X			"What do you want to do with the game in progress?"
X		},
X		/* [6] */
X		{8, 16, 40, 48},
X		Icon {
X			disabled,
X			0
X		}
X	}
X};
X
Xresource 'MENU' (129, "File") {
X	129,
X	textMenuProc,
X	0x7FFFFFC3,
X	enabled,
X	"File",
X	{	/* array: 7 elements */
X		/* [1] */
X		"New", noIcon, "N", "", plain,
X		/* [2] */
X		"Open\311", noIcon, "O", "", plain,
X		/* [3] */
X		"-", noIcon, "", "", plain,
X		/* [4] */
X		"Save", noIcon, "S", "", plain,
X		/* [5] */
X		"Save As\311", noIcon, "", "", plain,
X		/* [6] */
X		"-", noIcon, "", "", plain,
X		/* [7] */
X		"Quit", noIcon, "Q", "", plain
X	}
X};
X
Xresource 'MENU' (229, "File (No Keys)") {
X	229,
X	textMenuProc,
X	0x7FFFFFC3,
X	enabled,
X	"File",
X	{	/* array: 7 elements */
X		/* [1] */
X		"New", noIcon, "", "", plain,
X		/* [2] */
X		"Open\311", noIcon, "", "", plain,
X		/* [3] */
X		"-", noIcon, "", "", plain,
X		/* [4] */
X		"Save", noIcon, "", "", plain,
X		/* [5] */
X		"Save As\311", noIcon, "", "", plain,
X		/* [6] */
X		"-", noIcon, "", "", plain,
X		/* [7] */
X		"Quit", noIcon, "", "", plain
X	}
X};
X
Xresource 'MENU' (133, "Moria") {
X	133,
X	textMenuProc,
X	0x7FFFFF17,
X	enabled,
X	"Moria",
X	{	/* array: 5 elements */
X		/* [1] */
X		"Help\311", noIcon, "H", "", plain,
X		/* [2] */
X		"Command Set\311", noIcon, "", "", plain,
X		/* [3] */
X		"TEXT Editor\311", noIcon, "", "", plain,
X		/* [4] */
X		"-", noIcon, "", "", plain,
X		/* [5] */
X		"High Scores\311", noIcon, "", "", plain
X	}
X};
X
Xresource 'MENU' (233, "Moria (No Keys)") {
X	233,
X	textMenuProc,
X	0x7FFFFF17,
X	enabled,
X	"Moria",
X	{	/* array: 5 elements */
X		/* [1] */
X		"Help\311", noIcon, "", "", plain,
X		/* [2] */
X		"Command Set\311", noIcon, "", "", plain,
X		/* [3] */
X		"TEXT Editor\311", noIcon, "", "", plain,
X		/* [4] */
X		"-", noIcon, "", "", plain,
X		/* [5] */
X		"High Scores\311", noIcon, "", "", plain
X	}
X};
X
Xresource 'DLOG' (512, "Mac Help", purgeable) {
X	{40, 34, 310, 496},
X	dBoxProc,
X	invisible,
X	noGoAway,
X	0x0,
X	512,
X	""
X};
X
Xresource 'DITL' (512, "Mac Help", purgeable) {
X	{	/* array DITLarray: 6 elements */
X		/* [1] */
X		{16, 392, 36, 452},
X		Button {
X			enabled,
X			"Ok"
X		},
X		/* [2] */
X		{24, 432, 32, 440},
X		UserItem {
X			disabled
X		},
X		/* [3] */
X		{48, 8, 264, 440},
X		UserItem {
X			disabled
X		},
X		/* [4] */
X		{48, 439, 264, 455},
X		Control {
X			enabled,
X			512
X		},
X		/* [5] */
X		{8, 52, 40, 380},
X		StaticText {
X			disabled,
X			"Moria for the Macintosh Version 5.4"
X		},
X		/* [6] */
X		{8, 8, 40, 40},
X		Icon {
X			disabled,
X			128
X		}
X	}
X};
X
Xresource 'CNTL' (512, "Mac Help Scroll Bar", purgeable) {
X	{0, 0, 216, 16},
X	0,
X	visible,
X	0,
X	0,
X	scrollBarProc,
X	0,
X	""
X};
X
Xresource 'TEXT' (512, "Mac Help", purgeable) {
X	"This is an beta version of Mac Moria, implementation 2.0b1, which is "
X	"based on the Umoria 5.4 sources.  Please send comments and bug repor"
X	"ts to wilson@toad.com (Jim Wilson).\n\n"
X	"Users of previous versions o"
X	"f Mac Moria should discard the old program.  Otherwise, the Finder mig"
X	"ht get confused when you double-click on a saved game to start Moria.\n"
X	"\n*****************************\n\nMoria is a dungeon exploration game.  "
X	"The name comes from \322The Lord of the Rings\323 trilogy written by J. R"
X	". R. Tolkien.  Moria is pronounced with the accent on the first syllable,"
X	" e.g. MORE-ee-ah.  For details on the game itself, please read the Mor"
X	"ia Docs file that is distributed along with Moria.\n\nMoria was original"
X	"ly written for VAX/VMS systems.  As such,  it is heavily dependent on "
X	"the keyboard for game play.  The mouse is not used at all, except for "
X	"standard things like menus and dialogs.  To get a list of the availabl"
X	"e keyboard commands, hit the \324?\325 key while playing the game.\n\nSome"
X	" of the commands are specified as being control characters, i.e.  saving t"
X	"he game is ^X.  To type these characters hold down the control key and"
X	" then press the appropriate character key.  If you do not have a contr"
X	"ol key, use the command key (apple/cloverleaf key) instead of the cont"
X	"rol key.  If you prefer, you may enter these commands using two keystr"
X	"okes, by first typing the '^' key followed by the letter.\n\nThe game al"
X	"so uses the escape key (ESC) quite a bit.  If you do not have an escap"
X	"e key on your keyboard, you can use the ` key or the Clear key on the "
X	"numeric keypad instead.  An escape can also by typed as ^[, i.e. contr"
X	"ol (or command) left bracket.\n\nFile Menu\n\nThe game fully supports the "
X	"standard Macintosh file menu.  Use New to start playing a new game,  o"
X	"r Open to restart a previous game.   Save As will always ask you for t"
X	"he name of the file to save your character in.  Save will usually save"
X	" the game in a file with the same name as the name of the current char"
X	"acter.  If you are playing a new game, or have changed the name of you"
X	"r character, Save will instead ask you for the name of the save file. "
X	" The Quit option, of course, is used to exit the game.\n\nA game can onl"
X	"y be saved at the point where it is your turn to move.  At all other t"
X	"imes the Save command will not be available.\n\nThe File Menu is disable"
X	"d while saving and restoring games.  There is no cause for alarm if you "
X	"see this occur.  After the operation is completed, there will be a prompt"
X	" that says \322press any key to continue\323.  After you press a key, t"
X	"he File Menu will be reenabled.\n\nIf your character dies, or you decide"
X	" to stop running him, you will be prompted via a standard file dialog "
X	"for the name of a file in which to save his memories.  Pressing cancel"
X	" will avoid saving the memories.\n\nEdit Menu\n\nThe Edit Menu items are n"
X	"ot used by the game.  The Edit menu is disabled unless there is a Desk"
X	" Accessory open.\n\nScreen/FontSize Menu\n\nIf you have a color system, th"
X	"e Color item allows you to choose the background and foreground colors"
X	" of the game window.  The game must use a constant width font, so only"
X	" the Monaco font is supported.  You can, however, specify which point "
X	"size that you want to use.  The menu will list every point size availa"
X	"ble on your Macintosh for the Monaco font.\n\nAdvanced users can choose "
X	"a different font by using ResEdit or a similar program to edit the STR"
X	" \"Font Name\" resource.\n\nMoria Menu\n\nHelp brings up this dialog.\n\n"
X	"Command Set allows you to choose between the original Moria command set "
X	"and an optional command set similar to the UNIX game Rogue.  The main dif"
X	"ference between the two is that the original command set uses the nume"
X	"ric keypad for movement, whereas the Rogue-like command set uses the \324"
X	"hjkl\325 keys for, respectively, left down up and right.  The program wil"
X	"l remember your setting and use it as a default the next time you star"
X	"t a new character.  The command set can be chosen for the current char"
X	"acter by using the set options ('=') command.\n\nNote that the numeric k"
X	"eypad, if your system has one, is always available for indicating dire"
X	"ctions, regardless of the command set chosen.  The arrow keys will wor"
X	"k as well.\n\nText Editor allows you to choose the type of TEXT file cre"
X	"ated by Moria, that is, it allows you to specify which application wil"
X	"l be used by the Finder when you open a TEXT file created by Moria.  Y"
X	"ou can choose MacWrite or Microsoft Word files.  You can also specify "
X	"the signature of the desired application if you prefer something else."
X	"\n\nHigh Scores displays all of the scores stored in the scorefile.  You"
X	" can clear these scores by just deleting the High Scores file.  This f"
X	"eature is not implemented.\n\nConfiguration Info\n\nMoria is fully Multifi"
X	"nder compatible/aware.  It requires 450 K of memory under Multifinder."
X	"  The game will run on any Macintosh with 1 Megabyte or more of memory"
X	".\n\nMoria comes with a documentation file, called Moria Docs.  The Mori"
X	"a Docs file is an explanation of the game system.  Please remember to "
X	"always distribute this file with the game, since it contains much impo"
X	"rtant information.\n\nMoria will create two files when it is run.  The H"
X	"igh Scores file keeps a list of the scores of all of the previous game"
X	"s.  If this file is not present, a new one will be created in the fold"
X	"er which contains the game.  This file can be kept either in the folde"
X	"r that contains the application, or in the System Folder.\n\nMoria also "
X	"creates a file called Moria Config in the System Folder.  This file co"
X	"ntains all of the configuration info for Moria, such as the size and l"
X	"ocation of windows, the font size, the command set, etc.  This file mu"
X	"st remain in the Sytem Folder.\n\nThe text displayed when Moria starts u"
X	"p is stored in the data fork of this program.  You can edit it with mo"
X	"st text editors by first changing the file type of the program from 'A"
X	"PPL' to 'TEXT' with ResEdit.  Remember to change the file type back ag"
X	"ain when you are through.  Be careful not to disturb the lines which b"
X	"egin with a '#'.\n\0x00"
X};
X
Xtype 'DFPR' {
X	unsigned hex integer = $600A;					/* branch around header */
X	unsigned hex integer;							/* flags */
X	unsigned literal longint;						/* resource type */
X	integer;										/* resource id */
X	integer;										/* version */
X	unsigned hex integer = $4EF9;					/* jump instruction */
X	unsigned hex longint = $0;						/* target address for jump */
X};
X
Xtype 'LDEF' as 'DFPR';
X
Xresource 'LDEF' (514, "High Scores", purgeable) {
X	$0, 'LDEF', 514, 0
X};
X
Xresource 'DITL' (514, "High Scores", purgeable) {
X	{	/* array DITLarray: 5 elements */
X		/* [1] */
X		{15, 422, 35, 482},
X		Button {
X			enabled,
X			"Ok"
X		},
X		/* [2] */
X		{24, 464, 32, 472},
X		UserItem {
X			disabled
X		},
X		/* [3] */
X		{48, 2, 281, 490},
X		UserItem {
X			disabled
X		},
X		/* [4] */
X		{8, 56, 40, 336},
X		StaticText {
X			disabled,
X			"Moria High Scores\n"
X			"Positions ^0 to ^1"
X		},
X		/* [5] */
X		{8, 8, 40, 40},
X		Icon {
X			disabled,
X			128
X		}
X	}
X};
X
Xresource 'DLOG' (514, "High Scores", purgeable) {
X	{40, 34, 327, 526},
X	dBoxProc,
X	invisible,
X	noGoAway,
X	0x0,
X	514,
X	""
X};
X
Xresource 'DITL' (1024, "General Error", purgeable) {
X	{	/* array DITLarray: 2 elements */
X		/* [1] */
X		{80, 304, 100, 364},
X		Button {
X			enabled,
X			"Ok"
X		},
X		/* [2] */
X		{7, 68, 71, 364},
X		StaticText {
X			disabled,
X			"^0"
X		}
X	}
X};
X
Xresource 'ALRT' (1024, "General Error", purgeable) {
X	{42, 42, 148, 416},
X	1024,
X	{	/* array: 4 elements */
X		/* [1] */
X		OK, visible, sound1,
X		/* [2] */
X		OK, visible, sound1,
X		/* [3] */
X		OK, visible, sound1,
X		/* [4] */
X		OK, visible, sound1
X	}
X};
X
Xresource 'SIZE' (-1) {
X	dontSaveScreen,
X	acceptSuspendResumeEvents,
X	enableOptionSwitch,
X	canBackground,
X	multiFinderAware,
X	backgroundAndForeground,
X	dontGetFrontClicks,
X	ignoreChildDiedEvents,
X	not32BitCompatible,
X	reserved,
X	reserved,
X	reserved,
X	reserved,
X	reserved,
X	reserved,
X	reserved,
X	375 * 1024,
X	375 * 1024
X};
END_OF_FILE
if test 19941 -ne `wc -c <'mac/moria.r'`; then
    echo shar: \"'mac/moria.r'\" unpacked with wrong size!
fi
# end of 'mac/moria.r'
fi
if test -f 'source/store2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/store2.c'\"
else
echo shar: Extracting \"'source/store2.c'\" \(29309 characters\)
sed "s/^X//" >'source/store2.c' <<'END_OF_FILE'
X/* source/store2.c: store code, entering, command interpreter, buying, selling
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#ifdef __TURBOC__
X#include	<stdio.h>
X#include	<stdlib.h>
X#endif /* __TURBOC__ */
X 
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#ifdef USG
X#ifndef ATARIST_MWC
X#include <string.h>
X#endif
X#else
X#include <strings.h>
X#endif
X
X#if defined(LINT_ARGS)
Xstatic void prt_comment1(void);
Xstatic void prt_comment2(int32, int32, int);
Xstatic void prt_comment3(int32, int32, int);
Xstatic void prt_comment4(void);
Xstatic void prt_comment5(void);
Xstatic void prt_comment6(void);
Xstatic void display_commands(void);
Xstatic void haggle_commands(int);
Xstatic void display_inventory(int, int);
Xstatic void display_cost(int, int);
Xstatic void store_prt_gold(void);
Xstatic void display_store(int, int);
Xstatic int get_store_item(int *, char *, int, int);
Xstatic int increase_insults(int);
Xstatic void decrease_insults(int);
Xstatic int haggle_insults(int);
Xstatic int get_haggle(char *, int32 *, int);
Xstatic int receive_offer(int, char *, int32 *, int32, int, int);
Xstatic int purchase_haggle(int, int32 *, struct inven_type *);
Xstatic int sell_haggle(int, int32 *, struct inven_type *);
Xstatic int store_purchase(int, int *);
Xstatic int store_sell(int, int *);
X#endif
X
X#ifdef ATARIST_TC
X/* Include this to get prototypes for standard library functions.  */
X#include <stdlib.h>
X#endif
X
Xlong atol();
X
Xstatic char *comment1[14] = {
X  "Done!",  "Accepted!",  "Fine.",  "Agreed!",  "Ok.",  "Taken!",
X  "You drive a hard bargain, but taken.",
X  "You'll force me bankrupt, but it's a deal.",  "Sigh.  I'll take it.",
X  "My poor sick children may starve, but done!",  "Finally!  I accept.",
X  "Robbed again.",  "A pleasure to do business with you!",
X  "My spouse will skin me, but accepted."
X  };
X
Xstatic char *comment2a[3] = {
X  "%A2 is my final offer; take it or leave it.",
X  "I'll give you no more than %A2.",
X  "My patience grows thin.  %A2 is final."
X  };
X
Xstatic char *comment2b[16] = {
X  "%A1 for such a fine item?  HA!  No less than %A2.",
X  "%A1 is an insult!  Try %A2 gold pieces.",
X  "%A1?!?  You would rob my poor starving children?",
X  "Why, I'll take no less than %A2 gold pieces.",
X  "Ha!  No less than %A2 gold pieces.",
X  "Thou knave!  No less than %A2 gold pieces.",
X  "%A1 is far too little, how about %A2?",
X  "I paid more than %A1 for it myself, try %A2.",
X  "%A1?  Are you mad?!?  How about %A2 gold pieces?",
X  "As scrap this would bring %A1.  Try %A2 in gold.",
X  "May the fleas of 1000 orcs molest you.  I want %A2.",
X  "My mother you can get for %A1, this costs %A2.",
X  "May your chickens grow lips.  I want %A2 in gold!",
X  "Sell this for such a pittance?  Give me %A2 gold.",
X  "May the Balrog find you tasty!  %A2 gold pieces?",
X  "Your mother was a Troll!  %A2 or I'll tell."
X  };
X
Xstatic char *comment3a[3] = {
X  "I'll pay no more than %A1; take it or leave it.",
X  "You'll get no more than %A1 from me.",
X  "%A1 and that's final."
X  };
X
Xstatic char *comment3b[15] = {
X  "%A2 for that piece of junk?  No more than %A1.",
X  "For %A2 I could own ten of those.  Try %A1.",
X  "%A2?  NEVER!  %A1 is more like it.",
X  "Let's be reasonable. How about %A1 gold pieces?",
X  "%A1 gold for that junk, no more.",
X  "%A1 gold pieces and be thankful for it!",
X  "%A1 gold pieces and not a copper more.",
X  "%A2 gold?  HA!  %A1 is more like it.",  "Try about %A1 gold.",
X  "I wouldn't pay %A2 for your children, try %A1.",
X  "*CHOKE* For that!?  Let's say %A1.",  "How about %A1?",
X  "That looks war surplus!  Say %A1 gold.",
X  "I'll buy it as scrap for %A1.",
X  "%A2 is too much, let us say %A1 gold."
X  };
X
Xstatic char *comment4a[5] = {
X  "ENOUGH!  You have abused me once too often!",
X  "THAT DOES IT!  You shall waste my time no more!",
X  "This is getting nowhere.  I'm going home!",
X  "BAH!  No more shall you insult me!",
X  "Begone!  I have had enough abuse for one day."
X  };
X
Xstatic char *comment4b[5] = {
X  "Out of my place!",  "out... Out... OUT!!!",  "Come back tomorrow.",
X  "Leave my place.  Begone!",  "Come back when thou art richer."
X  };
X
Xstatic char *comment5[10] = {
X  "You will have to do better than that!",  "That's an insult!",
X  "Do you wish to do business or not?",  "Hah!  Try again.",
X  "Ridiculous!",  "You've got to be kidding!",  "You'd better be kidding!",
X  "You try my patience.",  "I don't hear you.",
X  "Hmmm, nice weather we're having."
X  };
X
Xstatic char *comment6[5] = {
X  "I must have heard you wrong.",  "What was that?",
X  "I'm sorry, say that again.",  "What did you say?",
X  "Sorry, what was that again?"
X  };
X
X
Xextern int16 last_store_inc;
X
X/* Comments vary.					-RAK-	*/
X/* Comment one : Finished haggling				*/
Xstatic void prt_comment1()
X{
X  msg_print(comment1[randint(14)-1]);
X}
X
X
X/* %A1 is offer, %A2 is asking.		*/
Xstatic void prt_comment2(offer, asking, final)
Xint32 offer, asking; int final;
X{
X  vtype comment;
X
X  if (final > 0)
X    (void) strcpy(comment, comment2a[randint(3)-1]);
X  else
X    (void) strcpy(comment, comment2b[randint(16)-1]);
X
X  insert_lnum(comment, "%A1", offer, FALSE);
X  insert_lnum(comment, "%A2", asking, FALSE);
X  msg_print(comment);
X}
X
X
Xstatic void prt_comment3(offer, asking, final)
Xint32 offer, asking; int final;
X{
X  vtype comment;
X
X  if (final > 0)
X    (void) strcpy (comment, comment3a[randint(3)-1]);
X  else
X    (void) strcpy (comment, comment3b[randint(15)-1]);
X
X  insert_lnum(comment, "%A1", offer, FALSE);
X  insert_lnum(comment, "%A2", asking, FALSE);
X  msg_print(comment);
X}
X
X
X/* Kick 'da bum out.					-RAK-	*/
Xstatic void prt_comment4()
X{
X  register int tmp;
X
X  tmp = randint(5) - 1;
X  msg_print(comment4a[tmp]);
X  msg_print(comment4b[tmp]);
X}
X
X
Xstatic void prt_comment5()
X{
X  msg_print(comment5[randint(10)-1]);
X}
X
X
Xstatic void prt_comment6()
X{
X  msg_print (comment6[randint(5)-1]);
X}
X
X
X/* Displays the set of commands				-RAK-	*/
Xstatic void display_commands()
X{
X  prt("You may:", 20, 0);
X  prt(" p) Purchase an item.           b) Browse store's inventory.", 21, 0);
X  prt(" s) Sell an item.               i/e/t/w/x) Inventory/Equipment Lists.",
X      22, 0);
X  prt("ESC) Exit from Building.        ^R) Redraw the screen.", 23, 0);
X}
X
X
X/* Displays the set of commands				-RAK-	*/
Xstatic void haggle_commands(typ)
Xint typ;
X{
X  if (typ == -1)
X    prt("Specify an asking-price in gold pieces.", 21, 0);
X  else
X    prt("Specify an offer in gold pieces.", 21, 0);
X  prt("ESC) Quit Haggling.", 22, 0);
X  erase_line (23, 0);	/* clear last line */
X}
X
X
X/* Displays a store's inventory				-RAK-	*/
Xstatic void display_inventory(store_num, start)
Xint store_num, start;
X{
X  register store_type *s_ptr;
X  register inven_type *i_ptr;
X  register int i, j, stop;
X  bigvtype out_val1, out_val2;
X  int32 x;
X
X  s_ptr = &store[store_num];
X  i = (start % 12);
X  stop = ((start / 12) + 1) * 12;
X  if (stop > s_ptr->store_ctr)	stop = s_ptr->store_ctr;
X  while (start < stop)
X    {
X      i_ptr = &s_ptr->store_inven[start].sitem;
X      x = i_ptr->number;
X      if ((i_ptr->subval >= ITEM_SINGLE_STACK_MIN)
X	  && (i_ptr->subval <= ITEM_SINGLE_STACK_MAX))
X	i_ptr->number = 1;
X      objdes(out_val1, i_ptr, TRUE);
X      i_ptr->number = x;
X      (void) sprintf(out_val2, "%c) %s", 'a'+i, out_val1);
X      prt(out_val2, i+5, 0);
X      x = s_ptr->store_inven[start].scost;
X      if (x <= 0)
X	{
X	  int32 value = -x;
X	  value = value * chr_adj() / 100;
X	  if (value <= 0)
X	    value = 1;
X	  (void) sprintf(out_val2, "%9ld", value);
X	}
X      else
X	(void) sprintf(out_val2,"%9ld [Fixed]", x);
X      prt(out_val2, i+5, 59);
X      i++;
X      start++;
X    }
X  if (i < 12)
X    for (j = 0; j < (11 - i + 1); j++)
X      erase_line (j+i+5, 0); /* clear remaining lines */
X  if (s_ptr->store_ctr > 12)
X    put_buffer("- cont. -", 17, 60);
X  else
X    erase_line (17, 60);
X}
X
X
X/* Re-displays only a single cost			-RAK-	*/
Xstatic void display_cost(store_num, pos)
Xint store_num, pos;
X{
X  register int i;
X  register int32 j;
X  vtype out_val;
X  register store_type *s_ptr;
X
X  s_ptr = &store[store_num];
X  i = (pos % 12);
X  if (s_ptr->store_inven[pos].scost < 0)
X    {
X      j = - s_ptr->store_inven[pos].scost;
X      j = j * chr_adj() / 100;
X      (void) sprintf(out_val, "%ld", j);
X    }
X  else
X    (void) sprintf(out_val, "%9ld [Fixed]", s_ptr->store_inven[pos].scost);
X  prt(out_val, i+5, 59);
X}
X
X
X/* Displays players gold					-RAK-	*/
Xstatic void store_prt_gold()
X{
X  vtype out_val;
X
X  (void) sprintf(out_val, "Gold Remaining : %ld", py.misc.au);
X  prt(out_val, 18, 17);
X}
X
X
X/* Displays store					-RAK-	*/
Xstatic void display_store(store_num, cur_top)
Xint store_num, cur_top;
X{
X  register store_type *s_ptr;
X
X  s_ptr = &store[store_num];
X  clear_screen();
X  put_buffer(owners[s_ptr->owner].owner_name, 3, 9);
X  put_buffer("Item", 4, 3);
X  put_buffer("Asking Price", 4, 60);
X  store_prt_gold();
X  display_commands();
X  display_inventory(store_num, cur_top);
X}
X
X
X/* Get the ID of a store item and return it's value	-RAK-	*/
Xstatic int get_store_item(com_val, pmt, i, j)
Xint *com_val;
Xchar *pmt;
Xregister int i, j;
X{
X  char command;
X  vtype out_val;
X  register int flag;
X
X  *com_val = -1;
X  flag = FALSE;
X  (void) sprintf(out_val, "(Items %c-%c, ESC to exit) %s", i+'a', j+'a', pmt);
X  while (get_com(out_val, &command))
X    {
X      command -= 'a';
X      if (command >= i && command <= j)
X	{
X	  flag = TRUE;
X	  *com_val = command;
X	  break;
X	}
X      bell();
X    }
X  erase_line(MSG_LINE, 0);
X  return(flag);
X}
X
X
X/* Increase the insult counter and get angry if too many -RAK-	*/
Xstatic int increase_insults(store_num)
Xint store_num;
X{
X  register int increase;
X  register store_type *s_ptr;
X
X  increase = FALSE;
X  s_ptr = &store[store_num];
X  s_ptr->insult_cur++;
X  if (s_ptr->insult_cur > owners[s_ptr->owner].insult_max)
X    {
X      prt_comment4();
X      s_ptr->insult_cur = 0;
X      s_ptr->good_buy = 0;
X      s_ptr->bad_buy = 0;
X      s_ptr->store_open = turn + 2500 + randint(2500);
X      increase = TRUE;
X    }
X  return(increase);
X}
X
X
X/* Decrease insults					-RAK-	*/
Xstatic void decrease_insults(store_num)
Xint store_num;
X{
X  register store_type *s_ptr;
X
X  s_ptr = &store[store_num];
X  if (s_ptr->insult_cur != 0)
X    s_ptr->insult_cur--;
X}
X
X
X/* Have insulted while haggling				-RAK-	*/
Xstatic int haggle_insults(store_num)
Xint store_num;
X{
X  register int haggle;
X
X  haggle = FALSE;
X  if (increase_insults(store_num))
X    haggle = TRUE;
X  else
X    {
X      prt_comment5();
X      msg_print (CNIL); /* keep insult separate from rest of haggle */
X    }
X  return(haggle);
X}
X
X
Xstatic int get_haggle(comment, new_offer, num_offer)
Xchar *comment;
Xint32 *new_offer;
Xint num_offer;
X{
X  register int32 i;
X  vtype out_val, default_offer;
X  register int flag, clen;
X  int orig_clen;
X  register char *p;
X  int increment;
X
X  flag = TRUE;
X  increment = FALSE;
X  clen = strlen(comment);
X  orig_clen = clen;
X  if (num_offer == 0)
X    last_store_inc = 0;
X  i = 0;
X  do
X    {
X      prt(comment, 0, 0);
X      if (num_offer && last_store_inc != 0)
X	{
X	  (void) sprintf (default_offer, "[%c%d] ",
X			  (last_store_inc < 0) ? '-' : '+',
X			  abs (last_store_inc));
X	  prt (default_offer, 0, orig_clen);
X	  clen = orig_clen + strlen (default_offer);
X	}
X      if (!get_string(out_val, 0, clen, 40))
X	flag = FALSE;
X      for (p = out_val; *p == ' '; p++)
X	;
X      if (*p == '+' || *p == '-')
X	increment = TRUE;
X      if (num_offer && increment)
X	{
X	  i = atol (out_val);
X	  /* Don't accept a zero here.  Turn off increment if it was zero
X	     because a zero will not exit.  This can be zero if the user
X	     did not type a number after the +/- sign.  */
X	  if (i == 0)
X	    increment = FALSE;
X	  else
X	    last_store_inc = i;
X	}
X      else if (num_offer && *out_val == '\0')
X	{
X	  i = last_store_inc;
X	  increment = TRUE;
X	}
X      else
X	i = atol (out_val);
X
X      /* don't allow incremental haggling, if player has not made an offer
X	 yet */
X      if (flag && num_offer == 0 && increment)
X	{
X	  msg_print("You haven't even made your first offer yet!");
X	  i = 0;
X	  increment = FALSE;
X	}
X    }
X  while (flag && (i == 0));
X  if (flag)
X    {
X      if (increment)
X	*new_offer += i;
X      else
X	*new_offer = i;
X    }
X  else
X    erase_line (0, 0);
X  return(flag);
X}
X
X
Xstatic int receive_offer(store_num, comment, new_offer, last_offer,
X			 num_offer, factor)
Xint store_num;
Xchar *comment;
Xregister int32 *new_offer, last_offer;
Xint num_offer, factor;
X{
X  register int flag;
X  register int receive;
X
X  receive = 0;
X  flag = FALSE;
X  do
X    {
X      if (get_haggle(comment, new_offer, num_offer))
X	{
X	  if (*new_offer*factor >= last_offer*factor)
X	    flag = TRUE;
X	  else if (haggle_insults(store_num))
X	    {
X	      receive = 2;
X	      flag = TRUE;
X	    }
X	  else
X	    /* new_offer rejected, reset new_offer so that incremental
X	       haggling works correctly */
X	    *new_offer = last_offer;
X	}
X      else
X	{
X	  receive = 1;
X	  flag = TRUE;
X	}
X    }
X  while (!flag);
X  return(receive);
X}
X
X
X/* Haggling routine					-RAK-	*/
Xstatic int purchase_haggle(store_num, price, item)
Xint store_num;
Xint32 *price;
Xinven_type *item;
X{
X  int32 max_sell, min_sell, max_buy;
X  int32 cost, cur_ask, final_ask, min_offer;
X  int32 last_offer, new_offer;
X  int32 x1, x2, x3;
X  int32 min_per, max_per;
X  register int flag, loop_flag;
X  char *comment;
X  vtype out_val;
X  int purchase, num_offer, final_flag, didnt_haggle;
X  register store_type *s_ptr;
X  register owner_type *o_ptr;
X
X  flag = FALSE;
X  purchase = 0;
X  *price = 0;
X  final_flag = 0;
X  didnt_haggle = FALSE;
X  s_ptr = &store[store_num];
X  o_ptr = &owners[s_ptr->owner];
X  cost = sell_price(store_num, &max_sell, &min_sell, item);
X  max_sell = max_sell * chr_adj() / 100;
X  if (max_sell <= 0)  max_sell = 1;
X  min_sell = min_sell * chr_adj() / 100;
X  if (min_sell <= 0)  min_sell = 1;
X  /* cast max_inflate to signed so that subtraction works correctly */
X  max_buy  = cost * (200 - (int)o_ptr->max_inflate) / 100;
X  if (max_buy <= 0) max_buy = 1;
X  min_per  = o_ptr->haggle_per;
X  max_per  = min_per * 3;
X  haggle_commands(1);
X  cur_ask   = max_sell;
X  final_ask = min_sell;
X  min_offer = max_buy;
X  last_offer = min_offer;
X  new_offer = 0;
X  num_offer = 0; /* this prevents incremental haggling on first try */
X  comment = "Asking";
X
X  /* go right to final price if player has bargained well */
X  if (noneedtobargain(store_num, final_ask))
X    {
X      msg_print("After a long bargaining session, you agree upon the price.");
X      cur_ask = min_sell;
X      comment = "Final offer";
X      didnt_haggle = TRUE;
X
X      /* Set up automatic increment, so that a return will accept the
X	 final price.  */
X      last_store_inc = min_sell;
X      num_offer = 1;
X    }
X
X  do
X    {
X      do
X	{
X	  loop_flag = TRUE;
X	  (void) sprintf(out_val, "%s :  %ld", comment, cur_ask);
X	  put_buffer(out_val, 1, 0);
X	  purchase = receive_offer(store_num, "What do you offer? ",
X				   &new_offer, last_offer, num_offer, 1);
X	  if (purchase != 0)
X	    flag = TRUE;
X	  else
X	    {
X	      if (new_offer > cur_ask)
X		{
X		  prt_comment6();
X		  /* rejected, reset new_offer for incremental haggling */
X		  new_offer = last_offer;
X
X		  /* If the automatic increment is large enough to overflow,
X		     then the player must have made a mistake.  Clear it
X		     because it is useless.  */
X		  if (last_offer + last_store_inc > cur_ask)
X		    last_store_inc = 0;
X		}
X	      else if (new_offer == cur_ask)
X		{
X		  flag = TRUE;
X		  *price = new_offer;
X		}
X	      else
X		loop_flag = FALSE;
X	    }
X	}
X      while (!flag && loop_flag);
X      if (!flag)
X	{
X	  x1 = (new_offer - last_offer) * 100 / (cur_ask - last_offer);
X	  if (x1 < min_per)
X	    {
X	      flag = haggle_insults(store_num);
X	      if (flag)	 purchase = 2;
X	    }
X	  else if (x1 > max_per)
X	    {
X	      x1 = x1 * 75 / 100;
X	      if (x1 < max_per)	 x1 = max_per;
X	    }
X	  x2 = x1 + randint(5) - 3;
X	  x3 = ((cur_ask - new_offer) * x2 / 100) + 1;
X	  /* don't let the price go up */
X	  if (x3 < 0)
X	    x3 = 0;
X	  cur_ask -= x3;
X	  if (cur_ask < final_ask)
X	    {
X	      cur_ask = final_ask;
X	      comment = "Final Offer";
X	      /* Set the automatic haggle increment so that RET will give
X		 a new_offer equal to the final_ask price.  */
X	      last_store_inc = final_ask - new_offer;
X	      final_flag++;
X	      if (final_flag > 3)
X		{
X		  if (increase_insults(store_num))
X		    purchase = 2;
X		  else
X		    purchase = 1;
X		  flag = TRUE;
X		}
X	    }
X	  else if (new_offer >= cur_ask)
X	    {
X	      flag = TRUE;
X	      *price = new_offer;
X	    }
X	  if (!flag)
X	    {
X	      last_offer = new_offer;
X	      num_offer++; /* enable incremental haggling */
X	      erase_line (1, 0);
X	      (void) sprintf(out_val, "Your last offer : %ld", last_offer);
X	      put_buffer(out_val, 1, 39);
X	      prt_comment2(last_offer, cur_ask, final_flag);
X
X	      /* If the current increment would take you over the store's
X		 price, then decrease it to an exact match.  */
X	      if (cur_ask - last_offer < last_store_inc)
X		last_store_inc = cur_ask - last_offer;
X	    }
X	}
X    }
X  while (!flag);
X
X  /* update bargaining info */
X  if ((purchase == 0) && (!didnt_haggle))
X    updatebargain(store_num, *price, final_ask);
X
X  return(purchase);
X}
X
X
X/* Haggling routine					-RAK-	*/
Xstatic int sell_haggle(store_num, price, item)
Xint store_num;
Xint32 *price;
Xinven_type *item;
X{
X  int32 max_sell, max_buy, min_buy;
X  int32 cost, cur_ask, final_ask, min_offer;
X  int32 last_offer, new_offer;
X  int32 max_gold;
X  int32 x1, x2, x3;
X  int32 min_per, max_per;
X  register int flag, loop_flag;
X  char *comment;
X  vtype out_val;
X  register store_type *s_ptr;
X  register owner_type *o_ptr;
X  int sell, num_offer, final_flag, didnt_haggle;
X
X  flag = FALSE;
X  sell = 0;
X  *price = 0;
X  final_flag = 0;
X  didnt_haggle = FALSE;
X  s_ptr = &store[store_num];
X  cost = item_value(item);
X  if (cost < 1)
X    {
X      sell = 3;
X      flag = TRUE;
X    }
X  else
X    {
X      o_ptr = &owners[s_ptr->owner];
X      cost = cost * (200 - chr_adj()) / 100;
X      cost = cost * (200 - rgold_adj[o_ptr->owner_race][py.misc.prace]) / 100;
X      if (cost < 1)  cost = 1;
X      max_sell = cost * o_ptr->max_inflate / 100;
X      /* cast max_inflate to signed so that subtraction works correctly */
X      max_buy  = cost * (200 - (int)o_ptr->max_inflate) / 100;
X      min_buy  = cost * (200 - o_ptr->min_inflate) / 100;
X      if (min_buy < 1) min_buy = 1;
X      if (max_buy < 1) max_buy = 1;
X      if (min_buy < max_buy)  min_buy = max_buy;
X      min_per  = o_ptr->haggle_per;
X      max_per  = min_per * 3;
X      max_gold = o_ptr->max_cost;
X    }
X  if (!flag)
X    {
X      haggle_commands(-1);
X      num_offer = 0; /* this prevents incremental haggling on first try */
X      if (max_buy > max_gold)
X	{
X	  final_flag= 1;
X	  comment = "Final Offer";
X	  /* Disable the automatic haggle increment on RET.  */
X	  last_store_inc = 0;
X	  cur_ask   = max_gold;
X	  final_ask = max_gold;
X	  msg_print("I am sorry, but I have not the money to afford such \
Xa fine item.");
X	  didnt_haggle = TRUE;
X	}
X      else
X	{
X	  cur_ask   = max_buy;
X	  final_ask = min_buy;
X	  if (final_ask > max_gold)
X	    final_ask = max_gold;
X	  comment = "Offer";
X
X	  /* go right to final price if player has bargained well */
X          if (noneedtobargain(store_num, final_ask))
X	    {
X	      msg_print("After a long bargaining session, you agree upon \
Xthe price.");
X              cur_ask = final_ask;
X	      comment = "Final offer";
X	      didnt_haggle = TRUE;
X
X	      /* Set up automatic increment, so that a return will accept the
X		 final price.  */
X	      last_store_inc = final_ask;
X	      num_offer = 1;
X            }
X	}
X      min_offer = max_sell;
X      last_offer = min_offer;
X      new_offer = 0;
X      if (cur_ask < 1)	cur_ask = 1;
X      do
X	{
X	  do
X	    {
X	      loop_flag = TRUE;
X	      (void) sprintf(out_val, "%s :  %ld", comment, cur_ask);
X	      put_buffer(out_val, 1, 0);
X	      sell = receive_offer(store_num, "What price do you ask? ",
X				 &new_offer, last_offer, num_offer, -1);
X	      if (sell != 0)
X		flag   = TRUE;
X	      else
X		{
X		  if (new_offer < cur_ask)
X		    {
X		      prt_comment6();
X		      /* rejected, reset new_offer for incremental haggling */
X		      new_offer = last_offer;
X
X		      /* If the automatic increment is large enough to
X			 overflow, then the player must have made a mistake.
X			 Clear it because it is useless.  */
X		      if (last_offer + last_store_inc < cur_ask)
X			last_store_inc = 0;
X		    }
X		  else if (new_offer == cur_ask)
X		    {
X		      flag = TRUE;
X		      *price = new_offer;
X		    }
X		  else
X		    loop_flag = FALSE;
X		}
X	    }
X	  while (!flag && loop_flag);
X	  if (!flag)
X	    {
X	      x1 = (last_offer - new_offer) * 100 / (last_offer - cur_ask);
X	      if (x1 < min_per)
X		{
X		  flag = haggle_insults(store_num);
X		  if (flag)  sell = 2;
X		}
X	      else if (x1 > max_per)
X		{
X		  x1 = x1 * 75 / 100;
X		  if (x1 < max_per)  x1 = max_per;
X		}
X	      x2 = x1 + randint(5) - 3;
X	      x3 = ((new_offer - cur_ask) * x2 / 100) + 1;
X	      /* don't let the price go down */
X	      if (x3 < 0)
X		x3 = 0;
X	      cur_ask += x3;
X	      if (cur_ask > final_ask)
X		{
X		  cur_ask = final_ask;
X		  comment = "Final Offer";
X		  /* Set the automatic haggle increment so that RET will give
X		     a new_offer equal to the final_ask price.  */
X		  last_store_inc = final_ask - new_offer;
X		  final_flag++;
X		  if (final_flag > 3)
X		    {
X		      if (increase_insults(store_num))
X			sell = 2;
X		      else
X			sell = 1;
X		      flag = TRUE;
X		    }
X		}
X	      else if (new_offer <= cur_ask)
X		{
X		  flag = TRUE;
X		  *price = new_offer;
X		}
X	      if (!flag)
X		{
X		  last_offer = new_offer;
X		  num_offer++; /* enable incremental haggling */
X		  erase_line (1, 0);
X		  (void) sprintf(out_val, "Your last bid %ld", last_offer);
X		  put_buffer(out_val, 1, 39);
X		  prt_comment3(cur_ask, last_offer, final_flag);
X
X		  /* If the current decrement would take you under the store's
X		     price, then increase it to an exact match.  */
X		  if (cur_ask - last_offer > last_store_inc)
X		    last_store_inc = cur_ask - last_offer;
X		}
X	    }
X	}
X      while (!flag);
X    }
X
X  /* update bargaining info */
X  if ((sell == 0) && (!didnt_haggle))
X    updatebargain(store_num, *price, final_ask);
X
X  return(sell);
X}
X
X
X/* Buy an item from a store				-RAK-	*/
Xstatic int store_purchase(store_num, cur_top)
Xint store_num;
Xint *cur_top;
X{
X  int32 price;
X  register int i, choice;
X  bigvtype out_val, tmp_str;
X  register store_type *s_ptr;
X  inven_type sell_obj;
X  register inven_record *r_ptr;
X  int item_val, item_new, purchase;
X
X  purchase = FALSE;
X  s_ptr = &store[store_num];
X  /* i == number of objects shown on screen	*/
X  if (*cur_top == 12)
X    i = s_ptr->store_ctr - 1 - 12;
X  else if (s_ptr->store_ctr > 11)
X    i = 11;
X  else
X    i = s_ptr->store_ctr - 1;
X  if (s_ptr->store_ctr < 1)
X    msg_print("I am currently out of stock.");
X      /* Get the item number to be bought		*/
X  else if (get_store_item(&item_val,
X			  "Which item are you interested in? ", 0, i))
X    {
X      item_val = item_val + *cur_top;	/* TRUE item_val	*/
X      take_one_item(&sell_obj, &s_ptr->store_inven[item_val].sitem);
X      if (inven_check_num(&sell_obj))
X	{
X	  if (s_ptr->store_inven[item_val].scost > 0)
X	    {
X	      price = s_ptr->store_inven[item_val].scost;
X	      choice = 0;
X	    }
X	  else
X	    choice = purchase_haggle(store_num, &price, &sell_obj);
X	  if (choice == 0)
X	    {
X	      if (py.misc.au >= price)
X		{
X		  prt_comment1();
X		  decrease_insults(store_num);
X		  py.misc.au -= price;
X		  item_new = inven_carry(&sell_obj);
X		  i = s_ptr->store_ctr;
X		  store_destroy(store_num, item_val, TRUE);
X		  objdes(tmp_str, &inventory[item_new], TRUE);
X		  (void) sprintf(out_val, "You have %s (%c)",
X				   tmp_str, item_new+'a');
X		  prt(out_val, 0, 0);
X		  check_strength();
X		  if (*cur_top >= s_ptr->store_ctr)
X		    {
X		      *cur_top = 0;
X		      display_inventory(store_num, *cur_top);
X		    }
X		  else
X		    {
X		      r_ptr = &s_ptr->store_inven[item_val];
X		      if (i == s_ptr->store_ctr)
X			{
X			  if (r_ptr->scost < 0)
X			    {
X			      r_ptr->scost = price;
X			      display_cost(store_num, item_val);
X			    }
X			}
X		      else
X			display_inventory(store_num, item_val);
X		    }
X		  store_prt_gold();
X		}
X	      else
X		{
X		  if (increase_insults(store_num))
X		    purchase = TRUE;
X		  else
X		    {
X		      prt_comment1();
X		      msg_print("Liar!  You have not the gold!");
X		    }
X		}
X	    }
X	  else if (choice == 2)
X	    purchase = TRUE;
X
X	  /* Less intuitive, but looks better here than in purchase_haggle. */
X	  display_commands();
X	  erase_line (1, 0);
X	}
X      else
X	prt("You cannot carry that many different items.", 0, 0);
X    }
X  return(purchase);
X}
X
X
X/* Sell an item to the store				-RAK-	*/
Xstatic int store_sell(store_num, cur_top)
Xint store_num, *cur_top;
X{
X  int item_val, item_pos;
X  int32 price;
X  bigvtype out_val, tmp_str;
X  inven_type sold_obj;
X  register int sell, choice, flag;
X  char mask[INVEN_WIELD];
X  int counter, first_item, last_item;
X
X  sell = FALSE;
X  first_item = inven_ctr;
X  last_item = -1;
X  for (counter = 0; counter < inven_ctr; counter++)
X    {
X#ifdef MAC
X      flag = store_buy(store_num, (inventory[counter].tval));
X#else
X      flag = (*store_buy[store_num])(inventory[counter].tval);
X#endif
X      mask[counter] = flag;
X      if (flag)
X	{
X	  if (counter < first_item)
X	    first_item = counter;
X	  if (counter > last_item)
X	    last_item = counter;
X	} /* end of if (flag) */
X    } /* end of for (counter) */
X  if (last_item == -1)
X    msg_print("You have nothing to sell to this store!");
X  else if (get_item(&item_val, "Which one? ", first_item, last_item, mask,
X		    "I do not buy such items."))
X    {
X      take_one_item(&sold_obj, &inventory[item_val]);
X      objdes(tmp_str, &sold_obj, TRUE);
X      (void) sprintf(out_val, "Selling %s (%c)", tmp_str, item_val+'a');
X      msg_print(out_val);
X      if (store_check_num(&sold_obj, store_num))
X	{
X	  choice = sell_haggle(store_num, &price, &sold_obj);
X	  if (choice == 0)
X	    {
X	      prt_comment1();
X	      decrease_insults(store_num);
X	      py.misc.au += price;
X	      /* identify object in inventory to set object_ident */
X	      identify(&item_val);
X	      /* retake sold_obj so that it will be identified */
X	      take_one_item(&sold_obj, &inventory[item_val]);
X	      /* call known2 for store item, so charges/pluses are known */
X	      known2(&sold_obj);
X	      inven_destroy(item_val);
X	      objdes(tmp_str, &sold_obj, TRUE);
X	      (void) sprintf(out_val, "You've sold %s", tmp_str);
X	      msg_print(out_val);
X	      store_carry(store_num, &item_pos, &sold_obj);
X	      check_strength();
X	      if (item_pos >= 0)
X		{
X		  if (item_pos < 12)
X		    if (*cur_top < 12)
X		      display_inventory(store_num, item_pos);
X		    else
X		      {
X			*cur_top = 0;
X			display_inventory(store_num, *cur_top);
X		      }
X		  else if (*cur_top > 11)
X		    display_inventory(store_num, item_pos);
X		  else
X		    {
X		      *cur_top = 12;
X		      display_inventory(store_num, *cur_top);
X		    }
X		}
X	      store_prt_gold();
X	    }
X	  else if (choice == 2)
X	    sell = TRUE;
X	  else if (choice == 3)
X	    {
X	      msg_print("How dare you!");
X	      msg_print("I will not buy that!");
X	      sell = increase_insults(store_num);
X	    }
X	  /* Less intuitive, but looks better here than in sell_haggle. */
X	  erase_line (1, 0);
X	  display_commands();
X	}
X      else
X	msg_print("I have not the room in my store to keep it.");
X    }
X  return(sell);
X}
X
X
X/* Entering a store					-RAK-	*/
Xvoid enter_store(store_num)
Xint store_num;
X{
X  int cur_top, tmp_chr;
X  char command;
X  register int exit_flag;
X  register store_type *s_ptr;
X
X  s_ptr = &store[store_num];
X  if (s_ptr->store_open < turn)
X    {
X      exit_flag = FALSE;
X      cur_top = 0;
X      display_store(store_num, cur_top);
X      do
X	{
X	  move_cursor (20, 9);
X	  /* clear the msg flag just like we do in dungeon.c */
X	  msg_flag = FALSE;
X	  if (get_com(CNIL, &command))
X	    {
X	      switch(command)
X		{
X		case 'b':
X		  if (cur_top == 0)
X		    if (s_ptr->store_ctr > 12)
X		      {
X			cur_top = 12;
X			display_inventory(store_num, cur_top);
X		      }
X		    else
X		      msg_print("Entire inventory is shown.");
X		  else
X		    {
X		      cur_top = 0;
X		      display_inventory(store_num, cur_top);
X		    }
X		  break;
X		case 'E': case 'e':	 /* Equipment List	*/
X		case 'I': case 'i':	 /* Inventory		*/
X		case 'T': case 't':	 /* Take off		*/
X		case 'W': case 'w':	/* Wear			*/
X		case 'X': case 'x':	/* Switch weapon		*/
X		  tmp_chr = py.stats.use_stat[A_CHR];
X		  do
X		    {
X		      inven_command(command);
X		      command = doing_inven;
X		    }
X		  while (command);
X		  /* redisplay store prices if charisma changes */
X		  if (tmp_chr != py.stats.use_stat[A_CHR])
X		    display_inventory(store_num, cur_top);
X		  free_turn_flag = FALSE;	/* No free moves here. -CJS- */
X		  break;
X		case 'p':
X		  exit_flag = store_purchase(store_num, &cur_top);
X		  break;
X		case 's':
X		  exit_flag = store_sell(store_num, &cur_top);
X		  break;
X		default:
X		  bell();
X		  break;
X		}
X	    }
X	  else
X	    exit_flag = TRUE;
X	}
X      while (!exit_flag);
X      /* Can't save and restore the screen because inven_command does that. */
X      draw_cave();
X    }
X  else
X    msg_print("The doors are locked.");
X}
END_OF_FILE
if test 29309 -ne `wc -c <'source/store2.c'`; then
    echo shar: \"'source/store2.c'\" unpacked with wrong size!
fi
# end of 'source/store2.c'
fi
echo shar: End of archive 20 \(of 39\).
cp /dev/null ark20isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
