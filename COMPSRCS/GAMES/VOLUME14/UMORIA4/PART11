Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i043:  umoria4 - single player dungeon simulation (ver. 5.5), Part11/39
Message-ID: <3401@master.CNA.TEK.COM>
Date: 20 Aug 92 18:03:52 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2464
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 43
Archive-name: umoria4/Part11
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 11 (of 39)."
# Contents:  mac/scrnmgr/ScrnMgr.c.1 util/mc/symtab.c
# Wrapped by billr@saab on Thu Aug 20 09:11:28 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'mac/scrnmgr/ScrnMgr.c.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/scrnmgr/ScrnMgr.c.1'\"
else
echo shar: Extracting \"'mac/scrnmgr/ScrnMgr.c.1'\" \(41420 characters\)
sed "s/^X//" >'mac/scrnmgr/ScrnMgr.c.1' <<'END_OF_FILE'
X/* mac/scrnmgr/ScrnMgr.c: a screen management package for the Mac
X
X   Copyright (c) 1989-1991 Curtis McCauley, James E. Wilson
X
X   You may copy this subroutine package freely, modify it as you desire,
X   and distribute it at will, as long as the copyright notice in the source
X   material is not disturbed, excepting that no one may use this package or
X   any part of it for commercial purposes of any kind without the express
X   written consent of its author. */
X
X/*	Think C port by Benjamin Schreiber, 1991.  */
X
X#ifndef THINK_C
X
X#include <Types.h>
X#include <OSUtils.h>
X#include <Files.h>
X#include <Quickdraw.h>
X#include <Windows.h>
X#include <Memory.h>
X#include <Controls.h>
X#include <Resources.h>
X#include <Desk.h>
X#include <Dialogs.h>
X#include <Events.h>
X#include <Fonts.h>
X#include <Menus.h>
X#include <OSEvents.h>
X#include <SegLoad.h>
X#include <TextEdit.h>
X#include <ToolUtils.h>
X#include <Packages.h>
X#include <Retrace.h>
X#include <Script.h>
X#include <Traps.h>
X#include <SysEqu.h>
X
X#include <StdDef.h>
X#include <String.h>
X#include <Strings.h>
X
X#else
X
X/* defined(THINK_C) */
X
X#include <VRetraceMgr.h>
X#include <ScriptMgr.h>
X#include <MultiFinder.h>	/* This may not be necessary.  */
X
X#include <string.h>
X#include <stddef.h>
X
X#define p2cstr	PtoCstr		/* Correct difference in names.  */
X#define c2pstr	CtoPstr
X
Xtypedef char Str63[64];
X
X/* Cover up error in THINK C library.  */
X#define ok	OK
X#define cancel	Cancel
X#define normal	0
X
X#endif
X
X
X#include "ScrnMgr.h"
X
X#define osEvent					app4Evt
X#define suspendResumeMessage	1
X#define resumeMask				1
X
X#define infoResType			(ResType) 'INFO'
X#define infoResID			1
X
X#define ABS(i)				((i < 0) ? -i : i)
X
X#define menuBarID1			128
X#define menuBarID2			228
X
X#define appleID				128
X#define fileID1				129
X#define fileID2				229
X#define editID1				130
X#define editID2				230
X#define screenID			131
X#define fontSizeID			132
X#define appID1				133
X#define appID2				233
X
X#define aboutItem			1
X
X#define openItem			1
X#define closeItem			2
X#define quitItem			4
X
X#define undoItem			1
X#define cutItem				3
X#define copyItem			4
X#define pasteItem			5
X#define clearItem			6
X
X#define colorsItem			1
X
X#define aboutDlgID			128
X#define aboutDfltBorder		2
X
X#define aboutStrID			128
X
X#define colorsDlgID			129
X#define colorsDfltBorder	23
X#define foregroundRect		19
X#define backgroundRect		20
X#define foreColors			3
X#define backColors			11
X
X#define yesOrNoDlgID		130
X#define yesOrNoDfltBorder	3
X#define yesOrNoText			4
X
X#define fontNameID			129
X
X#define fontSizeCount		50
X#define minFontSize			1
X#define maxFontSize			100
X#define dfltFontSize		9
X
X#define acurID				128
X
X#define titleMargin			20
X#define titleMinHgt			8
X#define titleMinWid			8
X#define titleDfltLeft		32
X#define titleDfltTop		64
X
X#define ESC					'\x1B'
X#define BACKQUOTE			'\x60'
X
Xtypedef struct Info {
X	Rect bounds;
X	short size;
X	long colorStdFore;
X	long colorStdBack;
X} Info, *InfoPtr;
X
Xtypedef struct Acur {
X	short frames;
X	short next;
X	union {
X		struct { short id; short fill; } cursID;
X		Cursor **cursHandle;
X	} table[1];
X} Acur, *AcurPtr, **AcurHandle;
X
Xtypedef struct Evt {
X	char keycode;
X	char modifiers;
X	char ascii;
X	short h;
X	short v;
X} Evt, *EvtPtr;
X
X#define qSize			32
X
Xtypedef struct SaveScreenRec {
X	struct SaveScreenRec **link;	/* link to previous saved screen		*/
X	char **chars;					/* handle to saved character buffer		*/
X	char **attrs;					/* handle to saved attribute buffer		*/
X	Point cursor;					/* saved cursor location				*/
X} SaveScreenRec, *SaveScreenPtr, **SaveScreenHandle;
X
Xtypedef struct ScreenRec {
X    WindowPtr window;				/* the screen window					*/
X	EventRecord event;				/* the last event						*/
X	SysEnvRec env;					/* the outside world					*/
X	long wneImplemented;			/* do we have WaitNextEvent?			*/
X	long backgrounding;				/* are we in the background?			*/
X	long reconfigFlag;				/* true if user want to change options	*/
X	long colorFlag;					/* true if multiple colors supported	*/
X	long cmdKeyFlag;				/* true if cmd key equivalents ok		*/
X	long mouseFlag;					/* true if mouse clicks are captured	*/
X	long escMapFlag;				/* true if backquote maps to escape		*/
X	long waitFlag;					/* true if in wait						*/
X	long waitRate;					/* how fast to spin the cursor			*/
X	long colorStdFore;				/* standard foreground color			*/
X	long colorStdBack;				/* standard background color			*/
X	long windowW;					/* its content width in pixels			*/
X	long windowH;					/* its content height in pixels			*/
X	short txFont;					/* the font number in use				*/
X	short txSize;					/* the font size in use					*/
X	short txNum;					/* index into fontSizes table + 1		*/
X	short **fontSizes;				/* a table of available sizes			*/
X    FontInfo info;					/* font info for the current font		*/
X    Point cursor;					/* cursor location in char coords		*/
X    Point charPDims;				/* char cell size in pixels				*/
X    Point scrnCDims;				/* screen size in chars					*/
X	Point origin;					/* logical origin of screen for drawing */
X	Rect stdStateGRect;				/* original standard state				*/
X    Rect scrnCRect;					/* screen bounds in chars				*/
X    Rect scrnLRect;					/* screen bounds in pixels				*/
X    Rect scrnXLRect;				/* screen bounds in pixels plus margin	*/
X	Rect sizeLimitPRect;			/* limits to growth						*/
X	Rect dragLimitGRect;			/* limits to movement					*/
X	Rect hScrollPRect;				/* horiz scroll bar bounds				*/
X	Rect vScrollPRect;				/* vert scroll bar bounds				*/
X	Rect growPRect;					/* grow icon bounds						*/
X	Rect picPRect;					/* picture area bounds					*/
X	Rect picLRect;					/* drawing is clipped here (pic area)	*/
X	Rect drawLRect;					/* drawing is clipped here (screen area)*/
X	Rect drawXCRect;				/* rect to draw in char coords			*/
X	Rect drawXLRect;				/* rect to draw in pixel coords			*/
X	Rect mouseCRect;				/* watch mouse activity in this area	*/
X	Rect mouseLRect;				/* watch mouse activity in this area	*/
X	ControlHandle hScrollHandle;	/* handle to horiz scroll control		*/
X	ControlHandle vScrollHandle;	/* handle to vert scroll control		*/
X	short infoResFile;				/* ref no of resource file				*/
X	Handle infoHandle;				/* handle to info resource				*/
X	Handle versHandle;				/* handle to vers. string, for about dlg */
X    char **chars;					/* handle to character buffer			*/
X    char **attrs;					/* handle to attribute buffer			*/
X	short **updLeft;				/* handle to left margin for updates	*/
X	short **updRight;				/* handle to right margin for updates	*/
X	long keyFlush;					/* tick count at last key flush			*/
X	long mouseFlush;				/* tick count at last mouse flush		*/
X	long qBegin;					/* index to first elem in queue			*/
X	long qEnd;						/* index to next elem to be stored		*/
X	Evt qBuffer[qSize];				/* queue of keystrokes					*/
X	long cursorLevel;				/* greater than zero when cursor visible*/
X	long cursorColor;				/* color of cursor lines				*/
X	long cursorLines;				/* number of lines in cursor			*/
X	long cursorBlink;				/* ticks between cursor blinks			*/
X	long cursorStatus;				/* non-zero when cursor in on screen	*/
X	long cursorChangeTick;			/* when to change cursor status			*/
X	void (*aboutProc)(void);		/* what to call when about is selected  */
X	void (*quitProc)(void);			/* what to call when quit is selected   */
X	void (*fileMenuProc)(long item);/* file menu handler					*/
X	void (*appMenuProc)(long item);	/* app menu handler						*/
X	long quitReturns;				/* true if quit proc will always return */
X	AcurHandle acur;				/* table of cursors						*/
X	VBLTask vbl;					/* for animating said cursors			*/
X	SaveScreenHandle stack;			/* stack of saved screens				*/
X} ScreenRec;
X
XScreenRec theScreen;
X
Xstatic long colors[8] = {
X	whiteColor, blackColor,
X	redColor, greenColor, blueColor,
X	cyanColor, magentaColor, yellowColor
X};
X
Xstatic void DisposeStackTop()
X
X{
X	SaveScreenHandle next;
X
X	if (theScreen.stack != NULL) {
X
X		next = (*theScreen.stack)->link;
X
X		DisposHandle((Handle) (*theScreen.stack)->chars);
X		DisposHandle((Handle) (*theScreen.stack)->attrs);
X
X		DisposHandle((Handle) theScreen.stack);
X
X		theScreen.stack = next;
X
X	}
X
X	return;
X}
X
Xstatic long WNETest(envp)
XSysEnvRec *envp;
X
X{
X#ifndef THINK_C
X	long hasWNE;
X
X	if (envp->machineType < 0)
X		hasWNE = false;
X
X	else
X		hasWNE =
X		NGetTrapAddress(_WaitNextEvent, ToolTrap) != GetTrapAddress(_Unimplemented);
X
X	return(hasWNE);
X#else
X	return 0;
X#endif
X}
X
Xstatic long NoEscTest(envp)
XSysEnvRec *envp;
X
X{
X	long hasNoEsc;
X
X	switch (envp->keyBoardType) {
X
X		case envAExtendKbd:
X		case envStandADBKbd:
X			hasNoEsc = false;
X			break;
X
X		default:
X			hasNoEsc = true;
X			break;
X
X	}
X
X	return(hasNoEsc);
X}
X
Xstatic void FlushQueue()
X
X{
X	theScreen.qBegin = theScreen.qEnd = 0;
X	return;
X}
X
Xstatic void PushQueue(keycode, modifiers, ascii, h, v)
Xchar keycode;
Xchar modifiers;
Xchar ascii;
Xshort h;
Xshort v;
X
X{
X	long end;
X	EvtPtr next;
X
X	end = (theScreen.qEnd + 1) & (qSize - 1);
X	if (end != theScreen.qBegin) {
X		next = &theScreen.qBuffer[theScreen.qEnd];
X		next->keycode = keycode;
X		next->modifiers = modifiers;
X		next->ascii = ascii;
X		next->h = h;
X		next->v = v;
X		theScreen.qEnd = end;
X	}
X	else {
X		/* should I beep? */
X	}
X
X	return;
X}
X
Xstatic long LenQueue()
X
X{
X	return(ABS(theScreen.qEnd - theScreen.qBegin));
X}
X
Xstatic long PopQueue(keycode, modifiers, ascii, h, v)
Xchar *keycode;
Xchar *modifiers;
Xchar *ascii;
Xshort *h;
Xshort *v;
X
X{
X	long flag;
X	EvtPtr next;
X
X	if (theScreen.qEnd != theScreen.qBegin) {
X		flag = true;
X		next = &theScreen.qBuffer[theScreen.qBegin];
X		if (keycode != NULL) *keycode = next->keycode;
X		if (modifiers != NULL) *modifiers = next->modifiers;
X		if (ascii != NULL ) *ascii = next->ascii;
X		if (h != NULL ) *h = next->h;
X		if (v != NULL ) *v = next->v;
X		theScreen.qBegin = (theScreen.qBegin + 1) & (qSize - 1);
X	}
X	else {
X		flag = false;
X	}
X
X	return(flag);
X}
X
Xstatic int GtoC(gh, gv, ch, cv)
Xshort gh, gv;
Xshort *ch, *cv;
X
X{
X	int flag;
X	Point temp;
X
X	temp.h = gh;
X	temp.v = gv;
X
X	SetOrigin(theScreen.origin.h, theScreen.origin.v);
X	GlobalToLocal(&temp);
X	SetOrigin(0, 0);
X
X	if ( PtInRect(temp, &theScreen.mouseLRect)
X	    && PtInRect(temp, &theScreen.picLRect) ) {
X		flag = true;
X		*ch = temp.h / theScreen.charPDims.h;
X		*cv = temp.v / theScreen.charPDims.v;
X	}
X	else
X		flag = false;
X
X	return(flag);
X}
X
Xstatic void DefaultCursor()
X
X{
X	theScreen.cursorLevel = 0;
X	theScreen.cursorColor = attrColorBlack;
X	theScreen.cursorLines = 2;
X	theScreen.cursorBlink = 0;
X	theScreen.cursorStatus = 0;
X	theScreen.cursorChangeTick = 0;
X
X	return;
X}
X
Xstatic void Prolog()
X
X{
X#ifdef THINK_C
X	InitGraf(&thePort);
X#else
X	InitGraf(&qd.thePort);
X#endif
X	InitFonts();
X	FlushEvents(everyEvent, 0);
X	InitWindows();
X	InitMenus();
X	TEInit();
X	InitDialogs(NULL);
X	InitCursor();
X
X	return;
X}
X
Xstatic void LoadCursors()
X
X{
X	short i, count;
X	Cursor **c;
X
X	theScreen.acur = (AcurHandle) GetResource('acur', acurID);
X
X	count = (*theScreen.acur)->frames;
X
X	for (i = 0; i < count; i++) {
X		c = GetCursor((*theScreen.acur)->table[i].cursID.id);
X		(*theScreen.acur)->table[i].cursHandle = c;
X	}
X
X	return;
X}
X
Xstatic long GetFontSizes()
X
X{
X	long i, j;
X	short fsize, sizes[fontSizeCount];
X	char **fname;
X
X	fname = (char **) GetString(fontNameID);
X
X	if (fname == NULL)
X		theScreen.txFont = 0;
X	else {
X		HLock(fname);
X		GetFNum(*fname, &theScreen.txFont);
X		HUnlock(fname);
X	}
X
X	for (i = 0, fsize = minFontSize;
X		 (i < fontSizeCount) && (fsize < maxFontSize);
X		 fsize++)
X		if (RealFont(theScreen.txFont, fsize))
X			sizes[i++] = fsize;
X
X	if (i == 0)
X		sizes[i++] = dfltFontSize;
X
X	theScreen.fontSizes = (short **) NewHandle(sizeof(short) * (i + 1));
X
X	if (theScreen.fontSizes != NULL)
X		for (j = 0; j < i; j++)
X			(*theScreen.fontSizes)[j] = sizes[j];
X
X	(*theScreen.fontSizes)[i++] = 0;
X
X	return(theScreen.fontSizes != NULL);
X}
X
Xstatic void SetUpMenus()
X
X{
X	long i, n, offset;
X	Handle h;
X	MenuHandle appMenuHndl, fontMenuHndl;
X	Str255 ftitle;
X
X	SetMenuBar(GetNewMBar(theScreen.cmdKeyFlag ? menuBarID1 : menuBarID2));
X	AddResMenu(GetMHandle(appleID), (ResType) 'DRVR');
X	if (theScreen.colorFlag || !theScreen.env.hasColorQD) {
X		InsertMenu(GetMenu(fontSizeID), 0);
X		fontMenuHndl = GetMHandle(fontSizeID);
X		offset = 1;
X	}
X	else {
X		InsertMenu(GetMenu(screenID), 0);
X		fontMenuHndl = GetMHandle(screenID);
X		offset = 3;
X	}
X
X	h = (Handle) GetString(aboutStrID);
X	if (h != NULL) {
X		MoveHHi(h);
X		HLock(h);
X		SetItem(GetMHandle(appleID), aboutItem, *h);
X		HUnlock(h);
X	}
X
X	for (i = 0; n = (*theScreen.fontSizes)[i]; i++) {
X		NumToString(n, ftitle);
X		(void) c2pstr(strcat(p2cstr((char *)ftitle), " point"));
X		AppendMenu(fontMenuHndl, ftitle);
X		if (n == theScreen.txSize) {
X			theScreen.txNum = i + offset;
X			CheckItem(fontMenuHndl, theScreen.txNum, true);
X		}
X	}
X
X	if (theScreen.appMenuProc != NULL) {
X		appMenuHndl = GetMenu(theScreen.cmdKeyFlag ? appID1 : appID2);
X		if (appMenuHndl != NULL) InsertMenu(appMenuHndl, 0);
X	}
X
X	DrawMenuBar();
X
X	return;
X}
X
Xstatic void LoadInfo(resourceFile, rfCreator, rfType)
XStr255 resourceFile;
XOSType rfCreator, rfType;
X
X{
X	ResType dfltType;
X	short dfltID;
X	Str63 dfltName;
X	short saveVol;
X
X	(void) GetVol(NULL, &saveVol);
X	(void) SetVol(NULL, theScreen.env.sysVRefNum);
X
X	(void) Create(resourceFile, 0, rfCreator, rfType);
X	CreateResFile(resourceFile);
X
X	theScreen.infoResFile = OpenResFile(resourceFile);
X
X	theScreen.infoHandle = GetResource(infoResType, infoResID);
X
X	if ( (theScreen.infoResFile != -1) &&
X	     (theScreen.infoResFile != HomeResFile(theScreen.infoHandle)) ) {
X		GetResInfo(theScreen.infoHandle, &dfltID, &dfltType, dfltName);
X		DetachResource(theScreen.infoHandle);
X		AddResource(theScreen.infoHandle, dfltType, dfltID, dfltName);
X	}
X
X	(void) SetVol(NULL, saveVol);
X
X	return;
X}
X
Xstatic void UseInfo(boundsRectPtr, sizePtr, colorStdForePtr, colorStdBackPtr)
XRect *boundsRectPtr;
Xshort *sizePtr;
Xlong *colorStdForePtr;
Xlong *colorStdBackPtr;
X
X{
X	InfoPtr theInfo;
X
X	LoadResource(theScreen.infoHandle);
X
X	theInfo = (InfoPtr) *theScreen.infoHandle;
X
X	*boundsRectPtr = theInfo->bounds;
X	*sizePtr = theInfo->size;
X
X	if (theScreen.env.hasColorQD) {
X		*colorStdForePtr = theInfo->colorStdFore;
X		*colorStdBackPtr = theInfo->colorStdBack;
X	}
X	else {
X		*colorStdForePtr = attrColorBlack;
X		*colorStdBackPtr = attrColorWhite;
X	}
X
X	return;
X}
X
Xstatic void SaveInfo()
X
X{
X	Point topLeft, bottomRight;
X	InfoPtr theInfo;
X
X	if (theScreen.infoResFile == -1) return;
X
X	LoadResource(theScreen.infoHandle);
X	HLock(theScreen.infoHandle);
X
X	theInfo = (InfoPtr) *theScreen.infoHandle;
X
X#ifdef THINK_C
X	topLeft.h = thePort->portRect.left;
X	topLeft.v = thePort->portRect.top;
X
X	bottomRight.h = thePort->portRect.right;
X	bottomRight.v = thePort->portRect.bottom;
X#else
X	topLeft.h = qd.thePort->portRect.left;
X	topLeft.v = qd.thePort->portRect.top;
X
X	bottomRight.h = qd.thePort->portRect.right;
X	bottomRight.v = qd.thePort->portRect.bottom;
X#endif
X
X	LocalToGlobal(&topLeft);
X	LocalToGlobal(&bottomRight);
X
X	if ( (topLeft.h     != theInfo->bounds.left)   ||
X		 (topLeft.v     != theInfo->bounds.top)    ||
X		 (bottomRight.h != theInfo->bounds.right)  ||
X		 (bottomRight.v != theInfo->bounds.bottom)    ) {
X
X		theInfo->bounds.left   = topLeft.h;
X		theInfo->bounds.top    = topLeft.v;
X		theInfo->bounds.right  = bottomRight.h;
X		theInfo->bounds.bottom = bottomRight.v;
X		ChangedResource(theScreen.infoHandle);
X
X	}
X
X	if ( theScreen.txSize != theInfo->size ) {
X
X		theInfo->size = theScreen.txSize;
X		ChangedResource(theScreen.infoHandle);
X
X	}
X
X	if ( (theScreen.colorStdFore != theInfo->colorStdFore) ||
X	     (theScreen.colorStdBack != theInfo->colorStdBack)    ) {
X
X		theInfo->colorStdFore = theScreen.colorStdFore;
X		theInfo->colorStdBack = theScreen.colorStdBack;
X		ChangedResource(theScreen.infoHandle);
X
X	}
X
X	HUnlock(theScreen.infoHandle);
X
X	return;
X}
X
Xstatic void AdjustPortBounds(bounds)
XRect *bounds;
X
X{
X	long repos;
X	long wid, hgt;
X	Rect test, sect;
X#ifndef THINK_C
X	GDHandle gdh;
X#endif
X
X	test.left = bounds->left;
X	test.top = bounds->top - titleMargin;
X	test.right = bounds->right;
X	test.bottom = bounds->top;
X
X#ifdef THINK_C			/* Ignore color issues. -- BS  */
X
X	(void) SectRect (&screenBits.bounds, &test, &sect);
X	wid = sect.right - sect.left;
X	hgt = sect.bottom - sect.top;
X	if ((wid < titleMinWid) || (hgt < titleMinHgt))
X		OffsetRect (bounds,
X			(screenBits.bounds.left + titleDfltLeft) - bounds->left\,
X			(screenBits.bounds.top + titleDfltTop) - bounds->top);
X
X#else
X
X	repos = true;
X
X	if (!theScreen.env.hasColorQD) {
X
X		(void) SectRect(&qd.screenBits.bounds, &test, &sect);
X		wid = sect.right - sect.left;
X		hgt = sect.bottom - sect.top;
X		if ( (wid >= titleMinWid) && (hgt >= titleMinHgt) ) repos = false;
X
X	}
X
X	else {
X
X		gdh = GetDeviceList();
X
X		while ( (gdh != NULL) && (repos) ) {
X
X			if ( ((*gdh)->gdFlags && (1 << screenDevice)) &&
X					((*gdh)->gdFlags && (1 << screenActive)) ) {
X
X				(void) SectRect(&(*gdh)->gdRect, &test, &sect);
X				wid = sect.right - sect.left;
X				hgt = sect.bottom - sect.top;
X				if ( (wid >= titleMinWid) && (hgt >= titleMinHgt) ) repos = false;
X
X			}
X
X			gdh = GetNextDevice(gdh);
X
X		}
X
X	}
X
X	if (repos)
X		OffsetRect(bounds,
X			(qd.screenBits.bounds.left + titleDfltLeft) - bounds->left,
X			(qd.screenBits.bounds.top + titleDfltTop) - bounds->top);
X#endif
X
X	return;
X}
X
Xstatic void SetScreenParameters()
X
X{
X	long stdWid, stdHgt;
X	Rect stdState;
X	WStateData **zoomInfo;
X
X    GetFontInfo(&theScreen.info);
X    theScreen.charPDims.h = theScreen.info.widMax;
X    theScreen.charPDims.v = theScreen.info.ascent
X						 + theScreen.info.descent
X						 + theScreen.info.leading;
X
X    theScreen.scrnCRect.left = 0;
X    theScreen.scrnCRect.right = theScreen.scrnCDims.h;
X    theScreen.scrnCRect.top = 0;
X    theScreen.scrnCRect.bottom = theScreen.scrnCDims.v;
X
X    theScreen.scrnLRect = theScreen.scrnCRect;
X    theScreen.scrnLRect.right *= theScreen.charPDims.h;
X    theScreen.scrnLRect.bottom *= theScreen.charPDims.v;
X
X    theScreen.scrnXLRect = theScreen.scrnLRect;
X    InsetRect(&theScreen.scrnXLRect, -4, -4);
X
X	theScreen.sizeLimitPRect.left = 64;
X	theScreen.sizeLimitPRect.top = 64;
X
X	theScreen.sizeLimitPRect.right =
X		theScreen.scrnXLRect.right - theScreen.scrnXLRect.left + 16;
X	if (theScreen.sizeLimitPRect.right < 65) theScreen.sizeLimitPRect.right = 65;
X
X	theScreen.sizeLimitPRect.bottom =
X		theScreen.scrnXLRect.bottom - theScreen.scrnXLRect.top + 16;
X	if (theScreen.sizeLimitPRect.bottom < 65)
X	  theScreen.sizeLimitPRect.bottom = 65;
X
X#ifdef THINK_C
X	theScreen.dragLimitGRect = screenBits.bounds;
X#else
X	theScreen.dragLimitGRect = qd.screenBits.bounds;
X#endif
X	theScreen.dragLimitGRect.top += GetMBarHeight();
X	InsetRect(&theScreen.dragLimitGRect, -4, -4);
X
X	stdState = theScreen.stdStateGRect;
X	stdWid = stdState.right - stdState.left - theScreen.sizeLimitPRect.right + 1;
X	stdHgt = stdState.bottom - stdState.top
X	  - theScreen.sizeLimitPRect.bottom + 1;
X
X	if (stdWid > 0) {
X		InsetRect(&stdState, stdWid / 2, 0);
X		stdState.right -= stdWid % 2;
X	}
X
X	if (stdHgt > 0) {
X		InsetRect(&stdState, 0, stdHgt / 2);
X		stdState.bottom -= stdHgt % 2;
X	}
X
X	zoomInfo = (WStateData **) ((WindowPeek) theScreen.window)->dataHandle;
X	(*zoomInfo)->stdState = stdState;
X
X	theScreen.mouseLRect = theScreen.mouseCRect;
X	theScreen.mouseLRect.left *= theScreen.charPDims.h;
X	theScreen.mouseLRect.top *= theScreen.charPDims.v;
X	theScreen.mouseLRect.right *= theScreen.charPDims.h;
X	theScreen.mouseLRect.bottom *= theScreen.charPDims.v;
X
X	return;
X}
X
Xstatic void SetScreenPortSize()
X
X{
X	long oldW, oldH;
X	long newW, newH;
X
X	oldW = theScreen.window->portRect.right;
X	oldH = theScreen.window->portRect.bottom;
X
X	if (oldW > theScreen.sizeLimitPRect.right-1)
X		newW = theScreen.sizeLimitPRect.right-1;
X	else if (oldW < theScreen.sizeLimitPRect.left)
X		newW = theScreen.sizeLimitPRect.left;
X	else
X		newW = oldW;
X
X	if (oldH > theScreen.sizeLimitPRect.bottom-1)
X		newH = theScreen.sizeLimitPRect.bottom-1;
X	else if (oldH < theScreen.sizeLimitPRect.top)
X		newH = theScreen.sizeLimitPRect.top;
X	else
X		newH = oldH;
X
X	if ( (newW != oldW) || (newH != oldH) )
X		SizeWindow(theScreen.window, newW, newH, true);
X
X	return;
X}
X
Xstatic void SetScreenPortRects()
X
X{
X	ClipRect(&theScreen.window->portRect);
X
X	theScreen.windowW = theScreen.window->portRect.right;
X	theScreen.windowH =	theScreen.window->portRect.bottom;
X
X	theScreen.vScrollPRect =
X	theScreen.hScrollPRect =
X	theScreen.growPRect    =
X	theScreen.picPRect     = theScreen.window->portRect;
X
X	theScreen.vScrollPRect.right += 1;
X	theScreen.vScrollPRect.top -= 1;
X	theScreen.vScrollPRect.left = theScreen.vScrollPRect.right - 16;
X	theScreen.vScrollPRect.bottom -= 14;
X
X	theScreen.hScrollPRect.bottom += 1;
X	theScreen.hScrollPRect.left -= 1;
X	theScreen.hScrollPRect.top = theScreen.hScrollPRect.bottom - 16;
X	theScreen.hScrollPRect.right -= 14;
X
X	theScreen.growPRect.top = theScreen.growPRect.bottom - 15;
X	theScreen.growPRect.left = theScreen.growPRect.right - 15;
X	theScreen.growPRect.bottom += 1;
X	theScreen.growPRect.right += 1;
X
X	theScreen.picPRect.right -= 15;
X	theScreen.picPRect.bottom -= 15;
X
X	return;
X}
X
Xstatic void SetScreenDrawRects()
X
X{
X	theScreen.picLRect = theScreen.picPRect;
X	OffsetRect(&theScreen.picLRect, theScreen.origin.h, theScreen.origin.v);
X
X	SectRect(&theScreen.picLRect, &theScreen.scrnLRect, &theScreen.drawLRect);
X
X	theScreen.drawXCRect = theScreen.drawLRect;
X	theScreen.drawXCRect.right += theScreen.charPDims.h - 1;
X	theScreen.drawXCRect.bottom += theScreen.charPDims.v - 1;
X	theScreen.drawXCRect.left /= theScreen.charPDims.h;
X	theScreen.drawXCRect.right /= theScreen.charPDims.h;
X	theScreen.drawXCRect.top /= theScreen.charPDims.v;
X	theScreen.drawXCRect.bottom /= theScreen.charPDims.v;
X
X	theScreen.drawXLRect = theScreen.drawXCRect;
X	theScreen.drawXLRect.left *= theScreen.charPDims.h;
X	theScreen.drawXLRect.right *= theScreen.charPDims.h;
X	theScreen.drawXLRect.top *= theScreen.charPDims.v;
X	theScreen.drawXLRect.bottom *= theScreen.charPDims.v;
X
X	return;
X}
X
Xstatic int RepositionScreen(deltaH, deltaV)
Xint deltaH, deltaV;
X
X{
X	int changed;
X	int newH, newV;
X	int min, max;
X	RgnHandle updtRgn;
X
X	newH = GetCtlValue(theScreen.hScrollHandle) + deltaH;
X	if (newH < (min = GetCtlMin(theScreen.hScrollHandle))) newH = min;
X	if (newH > (max = GetCtlMax(theScreen.hScrollHandle))) newH = max;
X
X	newV = GetCtlValue(theScreen.vScrollHandle) + deltaV;
X	if (newV < (min = GetCtlMin(theScreen.vScrollHandle))) newV = min;
X	if (newV > (max = GetCtlMax(theScreen.vScrollHandle))) newV = max;
X
X	if ( (newH != theScreen.origin.h) || (newV != theScreen.origin.v) ) {
X		if (newH != theScreen.origin.h)
X			SetCtlValue(theScreen.hScrollHandle, newH);
X		if (newV != theScreen.origin.v)
X			SetCtlValue(theScreen.vScrollHandle, newV);
X		updtRgn = NewRgn();
X		ScrollRect(&theScreen.picPRect,
X			theScreen.origin.h - newH,
X			theScreen.origin.v - newV,
X			updtRgn);
X		InvalRgn(updtRgn);
X		DisposeRgn(updtRgn);
X		theScreen.origin.h = newH;
X		theScreen.origin.v = newV;
X		SetScreenDrawRects();
X		changed = true;
X	}
X
X	else
X		changed = false;
X
X	return(changed);
X}
X
X/* ARGH!  This routine needs error checking code. */
X
Xlong InitScreenMgr(h, v, title, resFile, rfCreator, rfType, fileMenuProc,
X		  appMenuProc, colorFlag)
Xlong h, v;
Xchar *title;
Xchar *resFile;
XOSType rfCreator, rfType;
Xvoid (*fileMenuProc)(long item);
Xvoid (*appMenuProc)(long item);
Xlong colorFlag;
X
X{
X    long bytes, i;
X	Rect bounds;
X	WStateData **zoomInfo;
X	Str63 pstrTitle, pstrResFile;
X
X	Prolog();
X
X	SysEnvirons(curSysEnvVers, &theScreen.env);
X
X	theScreen.wneImplemented = WNETest(&theScreen.env);
X
X	theScreen.escMapFlag = NoEscTest(&theScreen.env);
X
X	theScreen.backgrounding = false;
X
X#if 1
X    {
X      char keys[128];
X      GetKeys ((KeyMap *) &keys);
X      theScreen.reconfigFlag = keys[7] & 0x04;
X    }
X#else
X	theScreen.reconfigFlag = ((char *) KeyMapLM)[7] & 0x04;
X#endif
X
X	strncpy(pstrTitle, title, 63);
X	strncpy(pstrResFile, resFile, 63);
X	pstrTitle[63] = '\0';
X	pstrResFile[63] = '\0';
X	c2pstr(pstrTitle);
X	c2pstr(pstrResFile);
X
X	LoadInfo(pstrResFile, rfCreator, rfType);
X
X	UseInfo(&bounds,
X		&theScreen.txSize,
X		&theScreen.colorStdFore,
X		&theScreen.colorStdBack);
X
X	theScreen.versHandle = GetResource (rfCreator, 0);
X
X	AdjustPortBounds(&bounds);
X
X	LoadCursors();
X
X	theScreen.waitFlag = false;
X
X	theScreen.txNum = -1;
X
X	theScreen.fileMenuProc = fileMenuProc;
X	theScreen.appMenuProc = appMenuProc;
X
X	theScreen.colorFlag = colorFlag;
X
X	switch (theScreen.env.keyBoardType) {
X
X		/* These are the old machines that we know.  */
X		case envUnknownKbd:
X		case envMacKbd:
X		case envMacAndPad:
X		case envMacPlusKbd:
X		  theScreen.cmdKeyFlag = false;
X		  break;
X
X		case envAExtendKbd:
X		case envStandADBKbd:
X		case 10:		/* Mac Classic.  */
X		  /* Anything else is probably new and has ctrl.  */
X		default:
X		  theScreen.cmdKeyFlag = true;
X
X	}
X
X	theScreen.mouseFlag = false;
X	theScreen.mouseCRect.left	=
X	theScreen.mouseCRect.top	=
X	theScreen.mouseCRect.right	=
X	theScreen.mouseCRect.bottom	= 0;
X
X    bytes = h * v;
X    theScreen.chars = (char **) NewHandle(bytes);
X    theScreen.attrs = (char **) NewHandle(bytes);
X
X    memset(*theScreen.chars, ' ', bytes);
X    memset(*theScreen.attrs, attrNormal, bytes);
X
X	bytes = v * sizeof(short);
X    theScreen.updLeft  = (short **) NewHandle(bytes);
X    theScreen.updRight = (short **) NewHandle(bytes);
X
X	for (i = 0; i < v; i++) {
X		(*theScreen.updLeft)[i] = h;
X		(*theScreen.updRight)[i] = 0;
X	}
X
X    theScreen.cursor.h = 0;
X    theScreen.cursor.v = 0;
X
X    theScreen.scrnCDims.h = h;
X    theScreen.scrnCDims.v = v;
X
X	FlushQueue();
X
X	DefaultCursor();
X
X	GetFontSizes();
X
X	SetUpMenus();
X
X    theScreen.window = NewWindow(NULL, &bounds, pstrTitle,
X								 false, zoomDocProc,
X								 (WindowPtr) -1, true, 0);
X
X    SetPort(theScreen.window);
X
X	zoomInfo = (WStateData **) ((WindowPeek) theScreen.window)->dataHandle;
X	theScreen.stdStateGRect = (*zoomInfo)->stdState;
X
X    TextFont(theScreen.txFont);
X    TextSize(theScreen.txSize);
X
X	SetScreenParameters();
X	SetScreenPortSize();
X	SetScreenPortRects();
X
X	theScreen.origin.h = theScreen.scrnXLRect.left;
X	theScreen.origin.v = theScreen.scrnXLRect.top;
X
X	SetScreenDrawRects();
X
X	theScreen.hScrollHandle = NewControl(theScreen.window,
X		&theScreen.hScrollPRect, "", true,
X		theScreen.origin.h,
X		theScreen.scrnXLRect.left,
X		theScreen.scrnXLRect.right - theScreen.picPRect.right,
X		scrollBarProc, 0L);
X	theScreen.vScrollHandle = NewControl(theScreen.window,
X		&theScreen.vScrollPRect, "", true,
X		theScreen.origin.v,
X		theScreen.scrnXLRect.top,
X		theScreen.scrnXLRect.bottom - theScreen.picPRect.bottom,
X		scrollBarProc, 0L);
X
X	ShowWindow(theScreen.window);
X	EraseRect(&theScreen.picPRect);
X
X	theScreen.aboutProc = NULL;
X	theScreen.quitProc = NULL;
X
X	theScreen.keyFlush = theScreen.mouseFlush = TickCount();
X
X	theScreen.stack = NULL;
X
X    return(scrnErrOk);
X}
X
Xstatic void ChangeScreenFontSize(num)
Xlong num;
X
X{
X	Point oldCharPDims;
X
X	DisposeControl(theScreen.hScrollHandle);
X	DisposeControl(theScreen.vScrollHandle);
X
X	oldCharPDims = theScreen.charPDims;
X
X	theScreen.txSize = (*theScreen.fontSizes)[num];
X
X    TextSize(theScreen.txSize);
X
X	SetScreenParameters();
X	SetScreenPortSize();
X	SetScreenPortRects();
X
X	theScreen.origin.h *= theScreen.charPDims.h;
X	theScreen.origin.h /= oldCharPDims.h;
X	if (theScreen.origin.h < theScreen.scrnXLRect.left)
X		theScreen.origin.h = theScreen.scrnXLRect.left;
X	if (theScreen.origin.h > theScreen.scrnXLRect.right
X	    - theScreen.picPRect.right)
X		theScreen.origin.h = theScreen.scrnXLRect.right - theScreen.picPRect.right;
X	theScreen.origin.v *= theScreen.charPDims.v;
X	theScreen.origin.v /= oldCharPDims.v;
X	if (theScreen.origin.v < theScreen.scrnXLRect.top)
X		theScreen.origin.v = theScreen.scrnXLRect.top;
X	if (theScreen.origin.v > theScreen.scrnXLRect.bottom -
X	    theScreen.picPRect.bottom)
X		theScreen.origin.v = theScreen.scrnXLRect.bottom
X		  - theScreen.picPRect.bottom;
X
X	SetScreenDrawRects();
X
X	theScreen.hScrollHandle = NewControl(theScreen.window,
X		&theScreen.hScrollPRect, "", true,
X		theScreen.origin.h,
X		theScreen.scrnXLRect.left,
X		theScreen.scrnXLRect.right - theScreen.picPRect.right,
X		scrollBarProc, 0L);
X	theScreen.vScrollHandle = NewControl(theScreen.window,
X		&theScreen.vScrollPRect, "", true,
X		theScreen.origin.v,
X		theScreen.scrnXLRect.top,
X		theScreen.scrnXLRect.bottom - theScreen.picPRect.bottom,
X		scrollBarProc, 0L);
X
X	InvalRect(&theScreen.picPRect);
X	InvalRect(&theScreen.growPRect);
X
X	return;
X}
X
Xvoid CloseScreenMgr()
X
X{
X	SaveInfo();
X
X	while (theScreen.stack != NULL)
X		DisposeStackTop();
X
X	DisposHandle((Handle) theScreen.fontSizes);
X
X    DisposHandle((Handle) theScreen.chars);
X    DisposHandle((Handle) theScreen.attrs);
X
X    DisposeWindow(theScreen.window);
X
X    return;
X}
X
Xpascal void DrawDefaultBorder(theWindow, theItem)
XWindowPtr theWindow;
Xshort theItem;
X
X{
X	short itsType;
X	Handle itsHandle;
X	Rect itsRect;
X
X	GetDItem((DialogPtr) theWindow, theItem, &itsType, &itsHandle, &itsRect);
X	PenSize(3, 3);
X	ForeColor(redColor);
X	FrameRoundRect(&itsRect, 16, 16);
X	ForeColor(blackColor);
X	PenSize(1, 1);
X
X	return;
X}
X
Xpascal void DrawGroupRect(theWindow, theItem)
XWindowPtr theWindow;
Xshort theItem;
X
X{
X	short itsType;
X	Handle itsHandle;
X	Rect itsRect;
X
X	GetDItem((DialogPtr) theWindow, theItem, &itsType, &itsHandle, &itsRect);
X	FrameRect(&itsRect);
X
X	return;
X}
X
Xstatic void DoAboutDialog()
X
X{
X	DialogPtr theDialog;
X	short itemHit;
X	short itsType;
X	Handle itsHandle;
X	Rect itsRect;
X	long h, v;
X
X	theDialog = GetNewDialog(aboutDlgID, nil, (WindowPtr) -1);
X
X	CenterScreenDLOG(aboutDlgID, fixThird, fixThird, &h, &v);
X	MoveWindow((WindowPtr) theDialog, (short) h, (short) v, false);
X
X	GetDItem(theDialog, ok, &itsType, &itsHandle, &itsRect);
X	InsetRect(&itsRect, -4, -4);
X
X	SetDItem(theDialog, aboutDfltBorder, userItem,
X		 (Handle) DrawDefaultBorder, &itsRect);
X
X	if (theScreen.versHandle) {
X	  MoveHHi (theScreen.versHandle);
X	  HLock (theScreen.versHandle);
X	  ParamText(*(theScreen.versHandle), nil, nil, nil);
X	  }
X
X	ShowWindow((WindowPtr) theDialog);
X
X	do {
X		ModalDialog(nil, &itemHit);
X	} while (itemHit != ok);
X
X	if (theScreen.versHandle)
X	  HUnlock(theScreen.versHandle);
X
X	DisposDialog(theDialog);
X
X	return;
X}
X
Xstatic void DoColorsDialog()
X
X{
X	DialogPtr theDialog;
X	long saveForeColor, saveBackColor;
X	short itemHit;
X	short itsType;
X	Handle itsHandle, fgHandle, bgHandle;
X	Rect itsRect;
X	GrafPtr savePort;
X	long redrawFlag;
X	long h, v;
X
X	theDialog = GetNewDialog(colorsDlgID, nil, (WindowPtr) -1);
X
X	CenterScreenDLOG(colorsDlgID, fixHalf, fixThird, &h, &v);
X	MoveWindow((WindowPtr) theDialog, (short) h, (short) v, false);
X
X	GetDItem(theDialog, ok, &itsType, &itsHandle, &itsRect);
X	InsetRect(&itsRect, -4, -4);
X
X	SetDItem(theDialog, colorsDfltBorder, userItem,
X		 (Handle) DrawDefaultBorder, &itsRect);
X
X	GetDItem(theDialog, foregroundRect, &itsType, &itsHandle, &itsRect);
X	SetDItem(theDialog, foregroundRect, itsType, (Handle) DrawGroupRect,
X		 &itsRect);
X	GetDItem(theDialog, backgroundRect, &itsType, &itsHandle, &itsRect);
X	SetDItem(theDialog, backgroundRect, itsType, (Handle) DrawGroupRect,
X		 &itsRect);
X
X	GetDItem(theDialog, foreColors+theScreen.colorStdFore, &itsType,
X		 &fgHandle, &itsRect);
X	SetCtlValue((ControlHandle) fgHandle, true);
X
X	GetDItem(theDialog, backColors+theScreen.colorStdBack, &itsType,
X		 &bgHandle, &itsRect);
X	SetCtlValue((ControlHandle) bgHandle, true);
X
X	ShowWindow((WindowPtr) theDialog);
X
X	saveForeColor = theScreen.colorStdFore;
X	saveBackColor = theScreen.colorStdBack;
X
X	do {
X		redrawFlag = false;
X		ModalDialog(nil, &itemHit);
X		if ( (itemHit >= foreColors) &&
X			(itemHit <= (foreColors+7)) &&
X			(itemHit != (foreColors+theScreen.colorStdFore)) ) {
X				theScreen.colorStdFore = itemHit - foreColors;
X				SetCtlValue((ControlHandle) fgHandle, false);
X				GetDItem(theDialog, foreColors+theScreen.colorStdFore,
X					&itsType, &fgHandle, &itsRect);
X				SetCtlValue((ControlHandle) fgHandle, true);
X				redrawFlag = true;
X		}
X		else if ( (itemHit >= backColors) &&
X			(itemHit <= (backColors+7)) &&
X			(itemHit != (backColors+theScreen.colorStdBack)) ) {
X				theScreen.colorStdBack = itemHit - backColors;
X				SetCtlValue((ControlHandle) bgHandle, false);
X				GetDItem(theDialog, backColors+theScreen.colorStdBack,
X					&itsType, &bgHandle, &itsRect);
X				SetCtlValue((ControlHandle) bgHandle, true);
X				redrawFlag = true;
X		}
X		if (redrawFlag) {
X			GetPort(&savePort);
X			SetPort(theScreen.window);
X			InvalRect(&theScreen.picPRect);
X			UpdateScreen();
X			SetPort(savePort);
X		}
X	} while ( (itemHit != ok) && (itemHit != cancel) );
X
X	if (itemHit == cancel)
X		if ( (theScreen.colorStdFore != saveForeColor) ||
X			(theScreen.colorStdBack != saveBackColor) ) {
X			theScreen.colorStdFore = saveForeColor;
X			theScreen.colorStdBack = saveBackColor;
X			GetPort(&savePort);
X			SetPort(theScreen.window);
X			InvalRect(&theScreen.picPRect);
X			UpdateScreen();
X			SetPort(savePort);
X		}
X
X	DisposDialog(theDialog);
X
X	return;
X}
X
Xstatic void DoAppleMenu(item)
Xlong item;
X
X{
X	GrafPtr savePort;
X	Str255 daName;
X
X	switch (item) {
X
X		case aboutItem:		if (theScreen.aboutProc != NULL)
X								(*theScreen.aboutProc)();
X							else
X								DoAboutDialog();
X							break;
X
X		default:			GetItem(GetMHandle(appleID), item, daName);
X							GetPort(&savePort);
X							OpenDeskAcc(daName);
X							SetPort(savePort);
X							break;
X
X	}
X
X	return;
X}
X
Xstatic void DoFileMenu(item)
Xlong item;
X
X{
X	switch (item) {
X
X		case closeBoxItem:	HideWindow(theScreen.window);
X							break;
X
X		case openItem:		ShowWindow(theScreen.window);
X							break;
X
X		case closeItem:		HideWindow(theScreen.window);
X							break;
X
X		case quitItem:		if (theScreen.quitProc != NULL) {
X								if (!theScreen.quitReturns) HiliteMenu(0);
X								(*theScreen.quitProc)();
X							}
X							break;
X
X	}
X
X	return;
X}
X
Xstatic void DoEditMenu(item)
Xlong item;
X
X{
X	switch (item) {
X
X		case undoItem:
X		case cutItem:
X		case copyItem:
X		case pasteItem:
X		case clearItem:		SystemEdit(item-1);
X							break;
X
X	}
X
X	return;
X}
X
Xstatic void DoFontChange(hndl, item, offset)
XMenuHandle hndl;
Xlong item, offset;
X
X{
X	if (item != theScreen.txNum) {
X		if (theScreen.txNum > 0)
X			CheckItem(hndl, theScreen.txNum, false);
X		ChangeScreenFontSize(item - offset);
X		theScreen.txNum = item;
X		CheckItem(hndl, theScreen.txNum, true);
X	}
X
X	return;
X}
X
Xstatic void DoScreenMenu(item)
Xlong item;
X
X{
X	switch (item) {
X
X		case colorsItem:	DoColorsDialog();
X							break;
X
X		default:			DoFontChange(GetMHandle(screenID), item, 3);
X							break;
X
X	}
X
X	return;
X}
X
Xstatic void DoFontSizeMenu(item)
Xlong item;
X
X{
X	DoFontChange(GetMHandle(fontSizeID), item, 1L);
X	return;
X}
X
Xstatic void DoMenuItem(select)
Xlong select;
X
X{
X	long menuID, menuItem;
X
X	menuID = HiWord(select);
X	menuItem = LoWord(select);
X
X	switch (menuID) {
X
X		case appleID:		DoAppleMenu(menuItem);
X							break;
X
X		case fileID1:
X		case fileID2:		if (theScreen.fileMenuProc != NULL)
X								(*theScreen.fileMenuProc)(menuItem);
X							else
X								DoFileMenu(menuItem);
X							break;
X
X		case editID1:
X		case editID2:		DoEditMenu(menuItem);
X							break;
X
X		case screenID:		DoScreenMenu(menuItem);
X							break;
X
X		case fontSizeID:	DoFontSizeMenu(menuItem);
X							break;
X
X		case appID1:
X		case appID2:		if (theScreen.appMenuProc != NULL)
X								(*theScreen.appMenuProc)(menuItem);
X							break;
X
X	}
X
X	HiliteMenu(0);
X
X	return;
X}
X
Xstatic void DoDrag(whichWindow, cursorLoc)
XWindowPtr whichWindow;
XPoint *cursorLoc;
X
X{
X	if (whichWindow == theScreen.window)
X		DragWindow(whichWindow, *cursorLoc, &theScreen.dragLimitGRect);
X
X	return;
X}
X
Xstatic void HandlePreGrow(oldWidth, oldHeight, newWidth, newHeight)
Xlong oldWidth, oldHeight, newWidth, newHeight;
X
X{
X	if (newWidth > oldWidth) {
X		InvalRect(&theScreen.vScrollPRect);
X		InvalRect(&theScreen.growPRect);
X	}
X	if (newHeight > oldHeight) {
X		InvalRect(&theScreen.hScrollPRect);
X		InvalRect(&theScreen.growPRect);
X	}
X	return;
X}
X
Xstatic void HandlePostGrow(oldWidth, oldHeight, newWidth, newHeight)
Xlong oldWidth, oldHeight, newWidth, newHeight;
X
X{
X	if ( (newWidth < oldWidth) || (newHeight < oldHeight) )
X		InvalRect(&theScreen.growPRect);
X	HideControl(theScreen.hScrollHandle);
X	HideControl(theScreen.vScrollHandle);
X	if (newWidth != oldWidth) {
X		MoveControl(theScreen.vScrollHandle,
X			theScreen.vScrollPRect.left, theScreen.vScrollPRect.top);
X		SizeControl(theScreen.hScrollHandle,
X			theScreen.hScrollPRect.right - theScreen.hScrollPRect.left,
X			theScreen.hScrollPRect.bottom - theScreen.hScrollPRect.top);
X		SetCtlMax(theScreen.hScrollHandle,
X			theScreen.scrnXLRect.right - theScreen.picPRect.right);
X	}
X	if (newHeight != oldHeight) {
X		MoveControl(theScreen.hScrollHandle,
X			theScreen.hScrollPRect.left, theScreen.hScrollPRect.top);
X		SizeControl(theScreen.vScrollHandle,
X			theScreen.vScrollPRect.right - theScreen.vScrollPRect.left,
X			theScreen.vScrollPRect.bottom - theScreen.vScrollPRect.top);
X		SetCtlMax(theScreen.vScrollHandle,
X			theScreen.scrnXLRect.bottom - theScreen.picPRect.bottom);
X	}
X	RepositionScreen(0, 0);
X	ShowControl(theScreen.hScrollHandle);
X	ShowControl(theScreen.vScrollHandle);
X	ValidRect(&theScreen.hScrollPRect);
X	ValidRect(&theScreen.vScrollPRect);
X	return;
X}
X
Xstatic void DoGrow(whichWindow, cursorLoc)
XWindowPtr whichWindow;
XPoint *cursorLoc;
X
X{
X	long newSize;
X	long oldWidth, oldHeight;
X	long newWidth, newHeight;
X
X	if (whichWindow == theScreen.window) {
X		oldWidth = theScreen.windowW;
X		oldHeight = theScreen.windowH;
X		newSize = GrowWindow(whichWindow, *cursorLoc, &theScreen.sizeLimitPRect);
X		if (newSize) {
X			newWidth = LoWord(newSize);
X			newHeight = HiWord(newSize);
X			HandlePreGrow(oldWidth, oldHeight, newWidth, newHeight);
X			SizeWindow(whichWindow, newWidth, newHeight, true);
X			SetScreenPortRects();
X			SetScreenDrawRects();
X			HandlePostGrow(oldWidth, oldHeight, newWidth, newHeight);
X		}
X
X	}
X
X	return;
X}
X
Xstatic void DoZoom(whichWindow, part)
XWindowPtr whichWindow;
Xlong part;
X
X{
X	WStateData **zoomInfo;
X	Rect newSize;
X	long oldWidth, oldHeight;
X	long newWidth, newHeight;
X
X	if (whichWindow == theScreen.window) {
X		oldWidth = theScreen.windowW;
X		oldHeight = theScreen.windowH;
X		zoomInfo = (WStateData **) ((WindowPeek) whichWindow)->dataHandle;
X		if (part == inZoomIn)
X			newSize = ((*zoomInfo)->userState);
X		else
X			newSize = ((*zoomInfo)->stdState);
X		newWidth = newSize.right - newSize.left;
X		newHeight = newSize.bottom - newSize.top;
X		HandlePreGrow(oldWidth, oldHeight, newWidth, newHeight);
X		EraseRect(&theScreen.window->portRect);
X		ZoomWindow(whichWindow, part, false);
X		SetScreenPortRects();
X		SetScreenDrawRects();
X		HandlePostGrow(oldWidth, oldHeight, newWidth, newHeight);
X	}
X
X	return;
X}
X
Xstatic pascal void ActOnScroll(theControl, partCode)
XControlHandle theControl;
Xshort partCode;
X
X{
X	int delta;
X
X	if (theControl == theScreen.hScrollHandle) {
X
X		switch (partCode) {
X			case inUpButton:
X				delta = -theScreen.charPDims.h;
X				break;
X			case inDownButton:
X				delta = theScreen.charPDims.h;
X				break;
X			case inPageUp:
X				delta = theScreen.charPDims.h - theScreen.picPRect.right;
X				break;
X			case inPageDown:
X				delta = theScreen.picPRect.right - theScreen.charPDims.h;
X				break;
X			default:
X				delta = 0;
X				break;
X		}
X
X		if (delta)
X			if (RepositionScreen(delta, 0)) UpdateScreen();
X
X	}
X
X	if (theControl == theScreen.vScrollHandle) {
X
X		switch (partCode) {
X			case inUpButton:
X				delta = -theScreen.charPDims.v;
X				break;
X			case inDownButton:
X				delta = theScreen.charPDims.v;
X				break;
X			case inPageUp:
X				delta = theScreen.charPDims.v - theScreen.picPRect.bottom;
X				break;
X			case inPageDown:
X				delta = theScreen.picPRect.bottom - theScreen.charPDims.v;
X				break;
X			default:
X				delta = 0;
X				break;
X		}
X
X		if (delta)
X			if (RepositionScreen(0, delta)) UpdateScreen();
X
X	}
X
X	return;
X}
X
Xstatic void DoHScroll(cursorLoc, thePart)
XPoint *cursorLoc;
Xlong thePart;
X
X{
X	switch (thePart) {
X
X		case inUpButton:
X		case inDownButton:
X		case inPageUp:
X		case inPageDown:
X			TrackControl(theScreen.hScrollHandle, *cursorLoc, (ProcPtr) ActOnScroll);
X			break;
X
X		case inThumb:
X			TrackControl(theScreen.hScrollHandle, *cursorLoc, NULL);
X			break;
X
X	}
X
X	RepositionScreen(0, 0);
X
X	return;
X}
X
Xstatic void DoVScroll(cursorLoc, thePart)
XPoint *cursorLoc;
Xlong thePart;
X
X{
X	switch (thePart) {
X
X		case inUpButton:
X		case inDownButton:
X		case inPageUp:
X		case inPageDown:
X			TrackControl(theScreen.vScrollHandle, *cursorLoc, (ProcPtr) ActOnScroll);
X			break;
X
X		case inThumb:
X			TrackControl(theScreen.vScrollHandle, *cursorLoc, NULL);
X			break;
X
X	}
X
X	RepositionScreen(0, 0);
X
X	return;
X}
X
Xstatic void DoCharClick()
X
X{
X	int reversed;
X	short h, v;
X	char c, an, ar;
X	char modifiers;
X	Rect charCell;
X	Point mouse;
X	void GetScreenCharAttr(), XSetScreenCharAttr(), UpdateScreen();
X
X	if ( (theScreen.event.when > theScreen.mouseFlush)		&&
X			(theScreen.window == FrontWindow())				&&
X			(((WindowPeek) theScreen.window)->visible) ) {
X
X		if (GtoC(theScreen.event.where.h, theScreen.event.where.v, &h, &v)) {
X
X			modifiers = (char) ((theScreen.event.modifiers & 0xF0) >> 8);
X			modifiers |= maskModMouse;
X
X			charCell.left = charCell.right = h;
X			charCell.top = charCell.bottom = v;
X			charCell.right++;
X			charCell.bottom++;
X
X			charCell.left *= theScreen.charPDims.h;
X			charCell.top *= theScreen.charPDims.v;
X			charCell.right *= theScreen.charPDims.h;
X			charCell.bottom *= theScreen.charPDims.v;
X
X			OffsetRect(&charCell, -theScreen.origin.h, -theScreen.origin.v);
X
X			GetScreenCharAttr(&c, &an, h, v);
X			ar = (an & maskAttrFlags) | (MakeAttr(AttrBack(an), AttrFore(an)));
X
X			XSetScreenCharAttr(false, c, ar, h, v);
X			UpdateScreen();
X			reversed = true;
X
X			while (StillDown()) {
X				GetMouse(&mouse);
X				if (reversed) {
X					if (!PtInRect(mouse, &charCell)) {
X						XSetScreenCharAttr(false, c, an, h, v);
X						UpdateScreen();
X						reversed = false;
END_OF_FILE
if test 41420 -ne `wc -c <'mac/scrnmgr/ScrnMgr.c.1'`; then
    echo shar: \"'mac/scrnmgr/ScrnMgr.c.1'\" unpacked with wrong size!
fi
# end of 'mac/scrnmgr/ScrnMgr.c.1'
fi
if test -f 'util/mc/symtab.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/mc/symtab.c'\"
else
echo shar: Extracting \"'util/mc/symtab.c'\" \(12398 characters\)
sed "s/^X//" >'util/mc/symtab.c' <<'END_OF_FILE'
X/* util/mc/st_symtab.c: routines for managing symbol tables
X *
X * Copyright (c) 1989 by Joseph Hall.
X * All rights reserved except as stated below.
X *
X * Jim Wilson and any other holders of copyright on substantial portions
X * of Moria are granted rights to use, modify, and distribute this program
X * as they see fit, so long as the terms of its use, modification and/or
X * distribution are no less restrictive than those applying to Moria,
X * version 5.0 or later, itself, and so long as this use is related to
X * the further development of Moria.
X *
X * Anyone having any other use in mind for this code should contact the
X * author at 4116 Brewster Dr., Raleigh NC 27606 (jnh@ecemwl.ncsu.edu).
X */
X
X
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X
X#ifdef ANSI_LIBS
X#include <stdlib.h>
X#else
Xextern char *malloc();
Xextern char *calloc();
Xextern void free();
Xextern void cfree();
X#endif
X
X#include "st.h"
X
X/* #define _TESTING_ */
X
X/*
X * There's a symbol table containing all the names of the symbol tables,
X * and of course it contains its own name ...
X *
X * "tnt" stands for "Table Name Table" ...
X */
Xstatic st_Table_Pt  tnt_P = NULL;
X
X/*
X * If there are a lot of symbol tables around you might want to increase
X * TNT_SIZE.  For best results use a prime number.
X */
X
X#define	TNT_SIZE    11
X
X/*
X * Names of basic generic types.
X */
X
X#define NAMES 7
X
X/*
X * Hash--
X *	Simple, stupid hash function.  Why be great, you know, when you can
X * be adequate so easily?
X */
Xstatic int Hash(s, mod)
Xregister char *s;
Xint mod;
X{
X    register int h = 0;
X
X    while (*s)
X	h += (unsigned) *s++;
X
X    return h % mod;
X}
X
X
X/*
X * LookupSym--
X *	Search for a name in a table.  Returns NULL if not found.
X */
Xstatic st_Entry_Pt LookupSym(st_P, name)
Xst_Table_Pt st_P;
Xchar *name;
X{
X    st_Entry_Pt	entry_P;
X    int		h;
X
X    h = Hash(name, st_P->size);
X
X    for (entry_P = st_P->tab_A[h]; entry_P; entry_P = entry_P->next_P)
X	if (!strncmp(entry_P->name, name, ST_MAX_SYM_LEN))
X	    break;
X
X    return entry_P;
X}
X
X
X
X/*
X * AddSym--
X *	Add a name to a table and return a pointer to the new entry.
X * ASSUMES THAT NAME DOESN'T EXIST ALREADY IN TABLE (check with LookupSym
X * above before calling here).
X */
Xstatic st_Entry_Pt AddSym(st_P, name)
Xst_Table_Pt st_P;
Xchar *name;
X
X{
X    int		h;
X    st_Entry_Pt	new_P;
X
X    h = Hash(name, st_P->size);
X
X    new_P = (st_Entry_Pt) malloc(sizeof(st_Entry_t));
X     strncpy(new_P->name, name, ST_MAX_SYM_LEN - 1);
X    new_P->name[ST_MAX_SYM_LEN - 1] = 0;
X    new_P->next_P = st_P->tab_A[h];
X    st_P->tab_A[h] = new_P;
X
X    st_P->entryCt++;
X
X    return new_P;
X
X}
X
X
X/*
X * St_NewTable--
X *	Create a new symbol table header.  Returns NULL if name isn't
X * unique with respect to the symbol tables currently in existence.
X */
Xst_Table_Pt St_NewTable(name, size)
Xchar *name;
Xint size;
X{
X    st_Table_Pt	st_P;
X    generic_t	gval;
X
X    /*
X     * Create the name table if doesn't already exist.  Obviously we
X     * can't use St_NewTable for this ...
X     */
X
X    if (!tnt_P) {
X	tnt_P = (st_Table_Pt) malloc(sizeof(st_Table_t));
X
X	 strncpy(tnt_P->name, "_TNT_", ST_MAX_SYM_LEN - 1);
X	tnt_P->name[ST_MAX_SYM_LEN - 1] = 0;
X	tnt_P->size = TNT_SIZE;
X	tnt_P->tab_A = (st_Entry_Pt *) calloc(TNT_SIZE, sizeof(st_Entry_Pt));
X	tnt_P->entryCt = 0;
X
X	gval.v = (char *) tnt_P;
X	 St_DefSym(tnt_P, "_TNT_", GEN_TYPE_VOID_PTR, gval);
X
X    }
X
X    /*
X     * See if the new table name is unique.
X     */
X
X    if (LookupSym(tnt_P, name))
X	return NULL;
X
X    /*
X     * Create the new table.
X     */
X
X    st_P = (st_Table_Pt) malloc(sizeof(st_Table_t));
X
X     strncpy(st_P->name, name, ST_MAX_SYM_LEN - 1);
X    st_P->name[ST_MAX_SYM_LEN - 1] = 0;
X    st_P->size = size;
X    st_P->tab_A = (st_Entry_Pt *) calloc((unsigned) size,
X					 sizeof(st_Entry_Pt));
X    st_P->entryCt = 0;
X
X    /*
X     * Add the name of the new table to the "table name table" now.
X     * gval.v is a pointer to the new table.
X     */
X
X    gval.v = (char *) st_P;
X     St_DefSym(tnt_P, name, GEN_TYPE_VOID_PTR, gval);
X
X    return st_P;
X}
X
X
X
X
X/*
X * St_DelTable--
X *	Delete a symbol table and associated storage.  If entries in the
X * table point to dynamically allocated objects, the user must free these
X * objects before calling this routine, else the pointers to those objects
X * will be lost.  (** NOTE: this feature has been removed from the version
X * accompanying the monster compiler, since it isn't needed --jnh **)
X */
Xvoid St_DelTable(st_P)
Xst_Table_Pt st_P;
X{
X    st_Entry_Pt entry_P;
X    int		i;
X
X    if (!st_P)
X	return;
X
X    for (i = 0; i < st_P->size; i++)
X	for (entry_P = st_P->tab_A[i]; entry_P; entry_P = entry_P->next_P) {
X	    free((char *) entry_P);
X	}
X
X    if (strncmp(st_P->name, "_TNT_", ST_MAX_SYM_LEN))
X	 St_DelSym(tnt_P, st_P->name);
X
X    cfree((char *) st_P->tab_A);
X    cfree((char *) st_P);
X
X    return;
X
X}
X
X
X
X
X/*
X * St_ListTable--
X *	Returns an unsorted list of symbols in the table.  The list will be
X * terminated with a NULL pointer.  This routine frees the storage used by
X * the last call to St_ListTable or St_SListTable; a call with a NULL
X * argument is a convenient way to free storage allocated by a previous call.
X */
Xchar **St_ListTable(st_P)
Xst_Table_Pt st_P;
X{
X
X    st_Entry_Pt entry_P;
X    int		i, j;
X    static char	**list_A = NULL,
X		*chars_P = NULL;
X
X    if (list_A) {
X	free((char *) list_A);
X	free((char *) chars_P);
X	list_A = NULL;
X	chars_P = NULL;
X    }
X
X    if (!st_P)
X	return NULL;
X
X    list_A = (char **) malloc(sizeof(char *) * (st_P->entryCt + 1));
X    chars_P = (char *) malloc(sizeof(char) * ST_MAX_SYM_LEN * st_P->entryCt);
X
X    for (i = 0; i < st_P->entryCt; i++)
X	list_A[i] = chars_P + ST_MAX_SYM_LEN * i;
X    list_A[st_P->entryCt] = NULL;
X
X    j = 0;
X    for (i = 0; i < st_P->size; i++)
X	for (entry_P = st_P->tab_A[i]; entry_P; entry_P = entry_P->next_P)
X	     strcpy(list_A[j++], entry_P->name);
X
X    list_A[st_P->entryCt] = NULL;
X
X    return list_A;
X
X}
X
X
X/*
X * St_SListTable--
X *	Returns a sorted list of symbols in a table.  Otherwise is exactly
X * like St_ListTable, above.
X */
Xchar **St_SListTable(st_P)
Xst_Table_Pt st_P;
X{
X    char    **list_A;
X
X    if (!(list_A = St_ListTable(st_P)))
X	return NULL;
X
X    qsort(*list_A, st_P->entryCt, sizeof(char) * ST_MAX_SYM_LEN, strcmp);
X
X    return list_A;
X}
X
X
X
X/*
X * St_GetSym--
X *	Look for a symbol in a table.  Return type and ptr to val if found.
X */
Xint St_GetSym(st_P, name, type_P, gval_P)
Xst_Table_Pt st_P;
Xchar *name;
Xint *type_P;
Xgeneric_Pt gval_P;
X{
X    st_Entry_Pt	entry_P;
X
X    if (!st_P)
X	return ST_NULL_TABLE;
X
X    if (!(entry_P = LookupSym(st_P, name)))
X	return ST_SYM_NOT_FOUND;
X
X    *type_P = entry_P->type;
X    *gval_P = entry_P->gval;
X
X    return ST_SYM_FOUND;
X}
X
X
X
X/*
X * St_DefSym--
X *	Add a symbol to a table.  Returns ST_SYM_FOUND and does nothing if
X * name is already in table.
X */
Xint St_DefSym(st_P, name, type, gval)
Xst_Table_Pt st_P;
Xchar *name;
Xint type;
Xgeneric_t gval;
X{
X    st_Entry_Pt entry_P;
X
X    if (!st_P)
X	return ST_NULL_TABLE;
X
X    if (LookupSym(st_P, name))
X	return ST_SYM_FOUND;
X
X    entry_P = AddSym(st_P, name);
X
X    /*
X     * Assign data.
X     */
X
X    entry_P->type = type;
X    entry_P->gval = gval;
X
X    return ST_SYM_NOT_FOUND;
X
X}
X
X
X/*
X * St_ReplSym--
X *	Add or supersede a symbol in a table.
X */
Xint St_ReplSym(st_P, name, type, gval)
Xst_Table_Pt st_P;
Xchar *name;
Xint type;
Xgeneric_t gval;
X{
X    st_Entry_Pt entry_P;
X    int		status;
X
X    if (!st_P)
X	return ST_NULL_TABLE;
X
X    if (!(entry_P = LookupSym(st_P, name))) {
X	entry_P = AddSym(st_P, name);
X	status = ST_SYM_NOT_FOUND;
X    } else {
X	status = ST_SYM_FOUND;
X    }
X
X    /*
X     * Assign data.
X     */
X
X    entry_P->type = type;
X    entry_P->gval = gval;
X
X    return status;
X}
X
X
X
X
X/*
X * St_DelSym--
X *	Delete a symbol from the table.
X */
Xint St_DelSym(st_P, name)
Xst_Table_Pt st_P;
Xchar *name;
X{
X    st_Entry_Pt	entry_P, last_P;
X    int		h;
X
X    if (!st_P)
X	return ST_NULL_TABLE;
X
X    h = Hash(name, st_P->size);
X
X    for (last_P = NULL, entry_P = st_P->tab_A[h]; entry_P;
X				last_P = entry_P, entry_P = entry_P->next_P)
X	if (!strncmp(entry_P->name, name, ST_MAX_SYM_LEN))
X	    break;
X
X    if (!entry_P)
X	return ST_SYM_NOT_FOUND;
X
X    if (last_P)
X	last_P->next_P = entry_P->next_P;
X    else
X	st_P->tab_A[h] = NULL;
X
X    cfree((char *) entry_P);
X    st_P->entryCt--;
X
X    return ST_SYM_FOUND;
X}
X
X
X
X/*
X * St_GetTable--
X *	Get a table by name
X */
Xst_Table_Pt St_GetTable(name)
Xchar *name;
X{
X    int		type;
X    generic_t	gval;
X
X    if (!tnt_P)
X	return NULL;
X
X    if (St_GetSym(tnt_P, name, &type, &gval) != ST_SYM_FOUND)
X	return NULL;
X
X    return (st_Table_Pt) gval.v;
X}
X
X
X/* -Jim Wilson-
X * St_TableSize--
X *	Returns the number of entries in the table.
X */
Xint St_TableSize(st_P)
Xst_Table_Pt st_P;
X{
X  return st_P->entryCt;
X}
X
X
X/*
X * St_DumpTable--
X *	Dump a table (for debugging or utility purposes)
X */
Xvoid St_DumpTable(output_F, st_P)
XFILE *output_F;
Xst_Table_Pt st_P;
X{
X    st_Entry_Pt	entry_P;
X    int		bucket;
X
X    if (!st_P) {
X	 fprintf(output_F, "Table ptr is NULL.\n");
X	return;
X    }
X
X     fprintf(output_F, "Dumping table '%s', size = %d, count = %d\n",
X				st_P->name, st_P->size, st_P->entryCt);
X
X    for (bucket = 0; bucket < st_P->size; bucket++) {
X
X	 fprintf(output_F, " Bucket %d:\n", bucket);
X
X	entry_P = st_P->tab_A[bucket];
X
X	if (!entry_P) {
X	     fprintf(output_F, "  empty\n");
X	    continue;
X	}
X
X	while (entry_P) {
X
X	    switch(entry_P->type) {
X
X	    case GEN_TYPE_INT:
X		 fprintf(output_F, "  '%s' = %d (int)\n", entry_P->name,
X							entry_P->gval.i);
X		break;
X
X	    case GEN_TYPE_LONG:
X		 fprintf(output_F, "  '%s' = %ld (long)\n", entry_P->name,
X							entry_P->gval.l);
X		break;
X
X	    case GEN_TYPE_FLOAT:
X		 fprintf(output_F, "  '%s' = %e (float)\n", entry_P->name,
X							entry_P->gval.f);
X		break;
X
X	    case GEN_TYPE_DOUBLE:
X		 fprintf(output_F, "  '%s' = %e (double)\n",
X				entry_P->name, entry_P->gval.d);
X		break;
X
X	    case GEN_TYPE_CHAR:
X		 fprintf(output_F, "  '%s' = '%c'/%d (char)\n",
X					    entry_P->name,
X					    entry_P->gval.c, entry_P->gval.c);
X		break;
X
X	    case GEN_TYPE_STRING:
X		if (entry_P->gval.s)
X		     fprintf(output_F, "  '%s' = '%s' (string)\n",
X					entry_P->name, entry_P->gval.s);
X		else
X		     fprintf(output_F, "  '%s' = NULL (string)\n",
X							    entry_P->name);
X		break;
X
X	    case GEN_TYPE_STRING_A:
X
X		if (!entry_P->gval.s_A) {
X		     fprintf(output_F, "  '%s' = NULL (string array)\n",
X							    entry_P->name);
X		} else {
X		    char	**s_A;
X		     fprintf(output_F, "  '%s' is string array:\n",
X							    entry_P->name);
X		    for (s_A = entry_P->gval.s_A; *s_A; s_A++)
X			 fprintf(output_F, "    '%s'\n", *s_A);
X		}
X		break;
X
X	    case GEN_TYPE_VOID_PTR:
X		if (entry_P->gval.v)
X		     fprintf(output_F, "  '%s' is user type (void ptr)\n",
X							    entry_P->name);
X		else
X	 fprintf(output_F, "  '%s' is NULL user type (void ptr)\n",
X							    entry_P->name);
X		break;
X
X	    default:
X	 fprintf(output_F, "  '%s' is unknown type\n", entry_P->name);
X		break;
X
X	    }
X
X	    entry_P = entry_P->next_P;
X
X	}
X
X    }
X
X    return;
X}
X
X
X
X#ifdef _TESTING_
X
Xmain()
X{
X    st_Table_Pt	st_P;
X    generic_t	gval;
X    int		type;
X    static char *s_A[] = {"Joe", "Bloe", NULL};
X    char	**list_A;
X
X    st_P = St_NewTable("Test", 3);
X
X    gval.i = 10;
X     St_DefSym(st_P, "A", GEN_TYPE_INT, gval);
X
X    gval.d = 3.14;
X     St_DefSym(st_P, "PI", GEN_TYPE_DOUBLE, gval);
X
X    gval.i = 1;
X     St_DefSym(st_P, "ONE", GEN_TYPE_INT, gval);
X
X    gval.s = "Testing!";
X     St_DefSym(st_P, "TESTING", GEN_TYPE_STRING, gval);
X
X    gval.c = 7;
X     St_DefSym(st_P, "BELL", GEN_TYPE_CHAR, gval);
X
X    gval.s_A = s_A;
X     St_DefSym(st_P, "JOE BLOE", GEN_TYPE_STRING_A, gval);
X
X     St_GetSym(st_P, "A", &type, &gval);
X     printf("A = %d, type = %d\n", gval.i, type);
X
X     St_GetSym(st_P, "PI", &type, &gval);
X     printf("PI = %f, type = %d\n", gval.d, type);
X
X    St_DumpTable(stdout, St_GetTable("Test"));
X
X     St_DelSym(st_P, "TESTING");
X
X    St_DumpTable(stdout, St_GetTable("Test"));
X
X     St_DelSym(st_P, "PI");
X
X    gval.s = "Joe Bloe";
X     St_ReplSym(st_P, "JOE BLOE", GEN_TYPE_STRING, gval);
X    gval.s = "Jane Bloe";
X     St_ReplSym(st_P, "JANE BLOE", GEN_TYPE_STRING, gval);
X
X    St_DumpTable(stdout, St_GetTable("Test"));
X
X    list_A = St_ListTable(St_GetTable("Test"));
X
X    while (*list_A)
X	 printf("'%s'\n", *list_A++);
X
X    list_A = St_SListTable(St_GetTable("Test"));
X
X    while (*list_A)
X	 printf("'%s'\n", *list_A++);
X
X    return 0;
X}
X
X#endif
END_OF_FILE
if test 12398 -ne `wc -c <'util/mc/symtab.c'`; then
    echo shar: \"'util/mc/symtab.c'\" unpacked with wrong size!
fi
# end of 'util/mc/symtab.c'
fi
echo shar: End of archive 11 \(of 39\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
