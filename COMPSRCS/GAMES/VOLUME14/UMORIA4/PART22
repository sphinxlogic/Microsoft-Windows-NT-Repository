Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i054:  umoria4 - single player dungeon simulation (ver. 5.5), Part22/39
Message-ID: <3418@master.CNA.TEK.COM>
Date: 22 Aug 92 22:12:36 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2292
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 54
Archive-name: umoria4/Part22
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 22 (of 39)."
# Contents:  source/death.c source/externs.h
# Wrapped by billr@saab on Thu Aug 20 09:11:32 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'source/death.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/death.c'\"
else
echo shar: Extracting \"'source/death.c'\" \(23954 characters\)
sed "s/^X//" >'source/death.c' <<'END_OF_FILE'
X/* source/death.c: code executed when player dies
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X/* Must read this before externs.h, as some global declarations use FILE. */
X#include <stdio.h>
X
X#ifndef STDIO_LOADED
X#define STDIO_LOADED
X#endif
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X
X#ifdef Pyramid
X#include <sys/time.h>
X#else
X#include <time.h>
X#endif
X
X#include <ctype.h>
X
X#ifndef USG
X/* only needed for Berkeley UNIX */
X#include <sys/param.h>
X#include <sys/types.h>
X#include <sys/file.h>
X#endif
X
X#ifdef MSDOS
X#include <io.h>
X#else
X#if !defined(ATARIST_MWC) && !defined(MAC) && !defined(AMIGA)
X#if !defined(ATARIST_TC)
X#ifndef VMS
X#include <pwd.h>
X#else
X#include <file.h>
X#endif
X#endif
X#endif
X#endif
X
X#ifdef VMS
Xunsigned int getuid(), getgid();
X#else
X#ifdef unix
X#ifdef USG
Xunsigned short getuid(), getgid();
X#else
X#ifndef SECURE
X#ifdef BSD4_3
Xuid_t getuid(), getgid();
X#else  /* other BSD versions */
Xint getuid(), getgid();
X#endif
X#endif
X#endif
X#endif
X#endif
X
X#ifdef USG
X#ifndef ATARIST_MWC
X#include <string.h>
X#ifndef VMS
X#ifndef ATARIST_TC
X#include <fcntl.h>
X#endif
X#endif
X#endif
X#else
X#include <strings.h>
X#endif
X
X/* This must be included after fcntl.h, which has a prototype for `open'
X   on some systems.  Otherwise, the `open' prototype conflicts with the
X   `topen' declaration.  */
X#include "externs.h"
X
X#ifndef BSD4_3
X#ifndef ATARIST_TC
Xlong lseek();
X#endif /* ATARTIST_TC */
X#else
Xoff_t lseek();
X#endif
X
X#if defined(USG) || defined(VMS) || defined(atarist)
X#ifndef L_SET
X#define L_SET 0
X#endif
X#ifndef L_INCR
X#define L_INCR 1
X#endif
X#endif
X
X#ifndef VMS
X#ifndef MAC
X#if defined(ultrix) || defined(USG)
Xvoid exit ();
X#endif
X#endif
X#endif
X
X#if defined(LINT_ARGS)
Xstatic void date(char *);
Xstatic char *center_string(char *, char *);
Xstatic void print_tomb(void);
Xstatic void kingly(void);
X#endif
X
X#ifdef ATARIST_TC
X/* Include this to get prototypes for standard library functions.  */
X#include <stdlib.h>
X#endif
X
X#ifndef VMS
X#ifndef MAC
X#if !defined(ATARIST_MWC) && !defined(AMIGA)
Xlong time();
X#endif
X#endif
X#endif
X
Xstatic void date(day)
Xchar *day;
X{
X  register char *tmp;
X#ifdef MAC
X  time_t clockvar;
X#else
X  long clockvar;
X#endif
X
X#ifdef MAC
X  clockvar = time((time_t *) 0);
X#else
X  clockvar = time((long *) 0);
X#endif
X  tmp = ctime(&clockvar);
X  tmp[10] = '\0';
X  (void) strcpy(day, tmp);
X}
X
X/* Centers a string within a 31 character string		-JWT-	 */
Xstatic char *center_string(centered_str, in_str)
Xchar *centered_str;
Xchar *in_str;
X{
X  register int i, j;
X
X  i = strlen(in_str);
X  j = 15 - i/2;
X  (void) sprintf (centered_str, "%*s%s%*s", j, "", in_str, 31 - i - j, "");
X  return centered_str;
X}
X
X
X#ifndef __TURBOC__
X#if (defined(USG) || defined(atarist)) && !defined(VMS)
X#if !defined(AMIGA) && !defined(MAC) && !defined(ATARIST_TC)
X
X#include <sys/stat.h>
X#include <errno.h>
X
X/* The following code is provided especially for systems which		-CJS-
X   have no flock system call. It has never been tested.		*/
X
X#define LOCK_EX	1
X#define LOCK_SH	2
X#define LOCK_NB	4
X#define LOCK_UN	8
X
X/* An flock HACK.  LOCK_SH and LOCK_EX are not distinguished.  DO NOT release
X   a lock which you failed to set!  ALWAYS release a lock you set! */
Xstatic int flock(f, l)
Xint f, l;
X{
X  struct stat sbuf;
X  char lockname[80];
X
X  if (fstat (f, &sbuf) < 0)
X    return -1;
X#ifdef atarist
X  (void) sprintf (lockname, (char *)prefix_file((char *)"moria.%d"),
X		  sbuf.st_ino);
X#else
X  (void) sprintf (lockname, "/tmp/moria.%d", sbuf.st_ino);
X#endif
X  if (l & LOCK_UN)
X    return unlink(lockname);
X
X  while (open (lockname, O_WRONLY|O_CREAT|O_EXCL, 0644) < 0)
X    {
X      if (errno != EEXIST)
X	return -1;
X      if (stat(lockname, &sbuf) < 0)
X	return -1;
X      /* Locks which last more than 10 seconds get deleted. */
X      if (time((long *)0) - sbuf.st_mtime > 10)
X	{
X	  if (unlink(lockname) < 0)
X	    return -1;
X	}
X      else if (l & LOCK_NB)
X	return -1;
X      else
X	(void) sleep(1);
X    }
X  return 0;
X}
X#endif
X#endif
X#endif
X
Xvoid display_scores(show_player)
Xint show_player;
X{
X  register int i, rank;
X  high_scores score;
X  char input;
X  char string[100];
X  int8u version_maj, version_min, patch_level;
X#if defined(unix) || defined(VMS)
X  int16 player_uid;
X#endif
X
X#if defined(MSDOS) || defined(VMS) || defined(AMIGA) || defined(MAC)
X#if defined(MAC) || defined(MSDOS)
X  if ((highscore_fp = fopen(MORIA_TOP, "rb")) == NULL)
X#else
X  if ((highscore_fp = fopen(MORIA_TOP, "r")) == NULL)
X#endif
X    {
X      (void) sprintf (string, "Error opening score file \"%s\"\n", MORIA_TOP);
X      msg_print(string);
X      msg_print(CNIL);
X      return;
X    }
X#endif
X
X#ifndef BSD4_3
X  (void) fseek(highscore_fp, (long)0, L_SET);
X#else
X  (void) fseek(highscore_fp, (off_t)0, L_SET);
X#endif
X
X  /* Read version numbers from the score file, and check for validity.  */
X  version_maj = getc (highscore_fp);
X  version_min = getc (highscore_fp);
X  patch_level = getc (highscore_fp);
X  /* Support score files from 5.2.2 to present.  */
X  if (feof (highscore_fp))
X    /* An empty score file. */
X    ;
X  else if ((version_maj != CUR_VERSION_MAJ)
X	   || (version_min > CUR_VERSION_MIN)
X	   || (version_min == CUR_VERSION_MIN && patch_level > PATCH_LEVEL)
X	   || (version_min == 2 && patch_level < 2)
X	   || (version_min < 2))
X    {
X      msg_print("Sorry. This scorefile is from a different version of \
Xumoria.");
X      msg_print (CNIL);
X#if defined(MSDOS) || defined(VMS) || defined(AMIGA) || defined(MAC)
X      (void) fclose (highscore_fp);
X#endif
X      return;
X    }
X
X#ifdef unix
X  player_uid = getuid ();
X#else
X#ifdef VMS
X  player_uid = (getgid()*1000) + getuid();
X#else
X  /* Otherwise player_uid is not used.  */
X#endif
X#endif
X
X  /* set the static fileptr in save.c to the highscore file pointer */
X  set_fileptr(highscore_fp);
X
X  rank = 1;
X  rd_highscore(&score);
X  while (!feof(highscore_fp))
X    {
X      i = 1;
X      clear_screen();
X      /* Put twenty scores on each page, on lines 2 through 21. */
X      while (!feof(highscore_fp) && i < 21)
X	{
X	  /* Only show the entry if show_player false, or if the entry
X	     belongs to the current player.  */
X	  if (! show_player ||
X#if defined(unix) || defined(VMS)
X	      score.uid == player_uid
X#else
X	      /* Assume microcomputers should always show every entry. */
X	      TRUE
X#endif
X	      )
X	    {
X	      (void) sprintf(string,
X			   "%-4d%8ld %-19.19s %c %-10.10s %-7.7s%3d %-22.22s",
X			     rank, score.points, score.name, score.sex,
X			     race[score.race].trace, class[score.class].title,
X			     score.lev, score.died_from);
X	      prt(string, ++i, 0);
X	    }
X	  rank++;
X	  rd_highscore(&score);
X	}
X      prt("Rank  Points Name              Sex Race       Class  Lvl Killed By"
X	  , 0, 0);
X      erase_line (1, 0);
X      prt("[Press any key to continue.]", 23, 23);
X      input = inkey();
X      if (input == ESCAPE)
X	break;
X    }
X#if defined(MSDOS) || defined(VMS) || defined(AMIGA) || defined(MAC)
X  (void) fclose (highscore_fp);
X#endif
X}
X
X
Xint duplicate_character ()
X{
X  /* Only check for duplicate characters under unix and VMS.  */
X#if !defined (unix) && !defined(VMS)
X  return FALSE;
X
X#else /* ! unix && ! VMS */
X
X  high_scores score;
X  int8u version_maj, version_min, patch_level;
X  int16 player_uid;
X#if defined(MSDOS) || defined(VMS) || defined(AMIGA) || defined(MAC)
X  char string[80];
X#endif
X
X#if defined(MSDOS) || defined(VMS) || defined(AMIGA) || defined(MAC)
X#if defined(MAC) || defined(MSDOS)
X  if ((highscore_fp = fopen(MORIA_TOP, "rb")) == NULL)
X#else
X  if ((highscore_fp = fopen(MORIA_TOP, "r")) == NULL)
X#endif
X    {
X      (void) sprintf (string, "Error opening score file \"%s\"\n", MORIA_TOP);
X      msg_print(string);
X      msg_print(CNIL);
X      return FALSE;
X    }
X#endif
X
X#ifndef BSD4_3
X  (void) fseek(highscore_fp, (long)0, L_SET);
X#else
X  (void) fseek(highscore_fp, (off_t)0, L_SET);
X#endif
X
X  /* Read version numbers from the score file, and check for validity.  */
X  version_maj = getc (highscore_fp);
X  version_min = getc (highscore_fp);
X  patch_level = getc (highscore_fp);
X  /* Support score files from 5.2.2 to present.  */
X  if (feof (highscore_fp))
X    /* An empty score file.  */
X    return FALSE;
X  if ((version_maj != CUR_VERSION_MAJ)
X      || (version_min > CUR_VERSION_MIN)
X      || (version_min == CUR_VERSION_MIN && patch_level > PATCH_LEVEL)
X      || (version_min == 2 && patch_level < 2)
X      || (version_min < 2))
X    {
X      msg_print("Sorry. This scorefile is from a different version of \
Xumoria.");
X      msg_print (CNIL);
X#if defined(MSDOS) || defined(VMS) || defined(AMIGA) || defined(MAC)
X      (void) fclose (highscore_fp);
X#endif
X      return FALSE;
X    }
X
X  /* set the static fileptr in save.c to the highscore file pointer */
X  set_fileptr(highscore_fp);
X
X#ifdef unix
X  player_uid = getuid ();
X#else
X#ifdef VMS
X  player_uid = (getgid()*1000) + getuid();
X#else
X  player_uid = 0;
X#endif
X#endif
X
X  rd_highscore(&score);
X  while (!feof(highscore_fp))
X    {
X      if (score.uid == player_uid && score.birth_date == birth_date
X	  && score.class == py.misc.pclass && score.race == py.misc.prace
X	  && score.sex == (py.misc.male ? 'M' : 'F')
X	  && strcmp (score.died_from, "(saved)"))
X	return TRUE;
X
X      rd_highscore(&score);
X    }
X#if defined(MSDOS) || defined(VMS) || defined(AMIGA) || defined(MAC)
X  (void) fclose (highscore_fp);
X#endif
X
X  return FALSE;
X#endif  /* ! unix && ! VMS */
X}
X
X
X
X/* Prints the gravestone of the character		-RAK-	 */
Xstatic void print_tomb()
X{
X  vtype str, tmp_str;
X  register int i;
X  char day[11];
X  register char *p;
X#ifdef MAC
X  char func;
X  int ok;
X#endif
X
X  clear_screen();
X  put_buffer ("_______________________", 1, 15);
X  put_buffer ("/", 2, 14);
X  put_buffer ("\\         ___", 2, 38);
X  put_buffer ("/", 3, 13);
X  put_buffer ("\\ ___   /   \\      ___", 3, 39);
X  put_buffer ("/            RIP            \\   \\  :   :     /   \\", 4, 12);
X  put_buffer ("/", 5, 11);
X  put_buffer ("\\  : _;,,,;_    :   :", 5, 41);
X  (void) sprintf (str, "/%s\\,;_          _;,,,;_",
X		  center_string (tmp_str, py.misc.name));
X  put_buffer (str, 6, 10);
X  put_buffer ("|               the               |   ___", 7, 9);
X  if (!total_winner)
X    p = title_string ();
X  else
X    p = "Magnificent";
X  (void) sprintf (str, "| %s |  /   \\", center_string (tmp_str, p));
X  put_buffer (str, 8, 9);
X  put_buffer ("|", 9, 9);
X  put_buffer ("|  :   :", 9, 43);
X  if (!total_winner)
X    p = class[py.misc.pclass].title;
X  else if (py.misc.male)
X    p = "*King*";
X  else
X    p = "*Queen*";
X  (void) sprintf(str,"| %s | _;,,,;_   ____", center_string (tmp_str, p));
X  put_buffer (str, 10, 9);
X  (void) sprintf (str, "Level : %d", (int) py.misc.lev);
X  (void) sprintf (str,"| %s |          /    \\",
X		  center_string (tmp_str, str));
X  put_buffer (str, 11, 9);
X  (void) sprintf(str, "%ld Exp", py.misc.exp);
X  (void) sprintf(str,"| %s |          :    :", center_string (tmp_str, str));
X  put_buffer (str, 12, 9);
X  (void) sprintf(str, "%ld Au", py.misc.au);
X  (void) sprintf(str,"| %s |          :    :", center_string (tmp_str, str));
X  put_buffer (str, 13, 9);
X  (void) sprintf(str, "Died on Level : %d", dun_level);
X  (void) sprintf(str,"| %s |         _;,,,,;_", center_string (tmp_str, str));
X  put_buffer (str, 14, 9);
X  put_buffer ("|            killed by            |", 15, 9);
X  p = died_from;
X  i = strlen (p);
X  p[i] = '.';  /* add a trailing period */
X  p[i+1] = '\0';
X  (void) sprintf(str, "| %s |", center_string (tmp_str, p));
X  put_buffer (str, 16, 9);
X  p[i] = '\0';	 /* strip off the period */
X  date(day);
X  (void) sprintf(str, "| %s |", center_string (tmp_str, day));
X  put_buffer (str, 17, 9);
X  put_buffer ("*|   *     *     *    *   *     *  | *", 18, 8);
X  put_buffer ("________)/\\\\_)_/___(\\/___(//_\\)/_\\//__\\\\(/_|_)_______",
X	      19, 0);
X
X retry:
X  flush();
X#ifdef MAC
X  /* On Mac, file_character() gets file name via std file dialog */
X  /* So, the prompt for character record cannot be made to do double duty */
X  put_buffer ("('F' - Save record in file / 'Y' - Display record on screen \
X/ 'N' - Abort)", 23, 0);
X  put_buffer ("Character record [F/Y/N]?", 22, 0);
X  do
X    {
X      func = inkey();
X      switch (func)
X	{
X	case 'f': case 'F':
X	  func = 'F';
X	  ok = TRUE;
X	  break;
X	case 'y': case 'Y':
X	  func = 'Y';
X	  ok = TRUE;
X	  break;
X	case 'n': case 'N':
X	  func = 'N';
X	  ok = TRUE;
X	  break;
X	default:
X	  bell();
X	  ok = FALSE;
X	  break;
X	}
X    }
X  while (!ok);
X  if (func != 'N')
X#else
X  put_buffer ("(ESC to abort, return to print on screen, or file name)",
X	      23, 0);
X  put_buffer ("Character record?", 22, 0);
X  if (get_string (str, 22, 18, 60))
X#endif
X    {
X      for (i = 0; i < INVEN_ARRAY_SIZE; i++)
X	{
X	  known1(&inventory[i]);
X	  known2(&inventory[i]);
X	}
X      calc_bonuses ();
X#ifdef MAC
X      if (func == 'F')
X	{
X	  if (!file_character())
X	    goto retry;
X	}
X#else
X      if (str[0])
X	{
X	  if (!file_character (str))
X	    goto retry;
X	}
X#endif
X      else
X	{
X	  clear_screen ();
X	  display_char ();
X	  put_buffer ("Type ESC to skip the inventory:", 23, 0);
X	  if (inkey() != ESCAPE)
X	    {
X	      clear_screen ();
X	      msg_print ("You are using:");
X	      (void) show_equip (TRUE, 0);
X	      msg_print (CNIL);
X	      msg_print ("You are carrying:");
X	      clear_from (1);
X	      (void) show_inven (0, inven_ctr-1, TRUE, 0, CNIL);
X	      msg_print (CNIL);
X	    }
X	}
X    }
X}
X
X
X/* Calculates the total number of points earned		-JWT-	 */
Xint32 total_points()
X{
X  int32 total;
X  int i;
X
X  total = py.misc.max_exp + (100 * py.misc.max_dlv);
X  total += py.misc.au / 100;
X  for (i = 0; i < INVEN_ARRAY_SIZE; i++)
X    total += item_value(&inventory[i]);
X  total += dun_level*50;
X
X  /* Don't ever let the score decrease from one save to the next.  */
X  if (max_score > total)
X    return max_score;
X
X  return total;
X}
X
X
X/* Enters a players name on the top twenty list		-JWT-	 */
Xstatic void highscores()
X{
X  high_scores old_entry, new_entry, entry;
X  int i;
X  char *tmp;
X  int8u version_maj, version_min, patch_level;
X  long curpos;
X#if defined(VMS) || defined(MSDOS) || defined(AMIGA) || defined(MAC)
X  char string[100];
X#endif
X
X  clear_screen();
X
X  if (noscore)
X    return;
X
X  if (panic_save == 1)
X    {
X      msg_print("Sorry, scores for games restored from panic save files \
Xare not saved.");
X      return;
X    }
X
X  new_entry.points = total_points();
X  new_entry.birth_date = birth_date;
X#ifdef unix
X  new_entry.uid = getuid();
X#else
X#ifdef VMS
X  new_entry.uid = (getgid()*1000) + getuid();
X#else
X  new_entry.uid = 0;
X#endif
X#endif
X  new_entry.mhp = py.misc.mhp;
X  new_entry.chp = py.misc.chp;
X  new_entry.dun_level = dun_level;
X  new_entry.lev = py.misc.lev;
X  new_entry.max_dlv = py.misc.max_dlv;
X  new_entry.sex = (py.misc.male ? 'M' : 'F');
X  new_entry.race = py.misc.prace;
X  new_entry.class = py.misc.pclass;
X  (void) strcpy(new_entry.name, py.misc.name);
X  tmp = died_from;
X  if ('a' == *tmp)
X    {
X      if ('n' == *(++tmp))
X	{
X	  tmp++;
X	}
X      while (isspace(*tmp))
X	{
X	  tmp++;
X	}
X    }
X  (void) strcpy(new_entry.died_from, tmp);
X
X  /*  First, get a lock on the high score file so no-one else tries */
X  /*  to write to it while we are using it, on VMS and IBMPCs only one
X      process can have the file open at a time, so we just open it here */
X#if defined(MSDOS) || defined(VMS) || defined(AMIGA) || defined(MAC)
X#if defined(MAC) || defined(MSDOS)
X  if ((highscore_fp = fopen(MORIA_TOP, "rb+")) == NULL)
X#else
X  if ((highscore_fp = fopen(MORIA_TOP, "r+")) == NULL)
X#endif
X    {
X      (void) sprintf (string, "Error opening score file \"%s\"\n", MORIA_TOP);
X      msg_print(string);
X      msg_print(CNIL);
X      return;
X    }
X#else
X#ifdef ATARIST_TC
X  /* 'lock' always succeeds on the Atari ST */
X#else
X  if (0 != flock((int)fileno(highscore_fp), LOCK_EX))
X    {
X      msg_print("Error gaining lock for score file");
X      msg_print(CNIL);
X      return;
X    }
X#endif
X#endif
X
X  /* Search file to find where to insert this character, if uid != 0 and
X     find same uid/sex/race/class combo then exit without saving this score */
X  /* Seek to the beginning of the file just to be safe. */
X#ifndef BSD4_3
X  (void) fseek(highscore_fp, (long)0, L_SET);
X#else
X  (void) fseek(highscore_fp, (off_t)0, L_SET);
X#endif
X
X  /* Read version numbers from the score file, and check for validity.  */
X  version_maj = getc (highscore_fp);
X  version_min = getc (highscore_fp);
X  patch_level = getc (highscore_fp);
X  /* If this is a new scorefile, it should be empty.  Write the current
X     version numbers to the score file.  */
X  if (feof (highscore_fp))
X    {
X      /* Seek to the beginning of the file just to be safe. */
X#ifndef BSD4_3
X      (void) fseek(highscore_fp, (long)0, L_SET);
X#else
X      (void) fseek(highscore_fp, (off_t)0, L_SET);
X#endif
X
X      (void) putc (CUR_VERSION_MAJ, highscore_fp);
X      (void) putc (CUR_VERSION_MIN, highscore_fp);
X      (void) putc (PATCH_LEVEL, highscore_fp);
X
X      /* must fseek() before can change read/write mode */
X#ifndef BSD4_3
X#ifdef ATARIST_TC
X      /* no fseek relative to current position allowed */
X      (void) fseek (highscore_fp, (long)ftell (highscore_fp), L_SET);
X#else
X      (void) fseek(highscore_fp, (long)0, L_INCR);
X#endif
X#else
X      (void) fseek(highscore_fp, (off_t)0, L_INCR);
X#endif
X    }
X  /* Support score files from 5.2.2 to present.  */
X  else if ((version_maj != CUR_VERSION_MAJ)
X	   || (version_min > CUR_VERSION_MIN)
X	   || (version_min == CUR_VERSION_MIN && patch_level > PATCH_LEVEL)
X	   || (version_min == 2 && patch_level < 2)
X	   || (version_min < 2))
X    {
X      /* No need to print a message, a subsequent call to display_scores()
X	 will print a message.  */
X#if defined(MSDOS) || defined(VMS) || defined(AMIGA) || defined(MAC)
X      (void) fclose (highscore_fp);
X#endif
X      return;
X    }
X
X  /* set the static fileptr in save.c to the highscore file pointer */
X  set_fileptr(highscore_fp);
X
X  i = 0;
X  curpos = ftell (highscore_fp);
X  rd_highscore(&old_entry);
X  while (!feof(highscore_fp))
X    {
X      if (new_entry.points >= old_entry.points)
X	break;
X      /* under unix and VMS, only allow one sex/race/class combo per person,
X	 on single user system, allow any number of entries, but try to
X	 prevent multiple entries per character by checking for case when
X	 birthdate/sex/race/class are the same, and died_from of scorefile
X	 entry is "(saved)" */
X      else if (((new_entry.uid != 0 && new_entry.uid == old_entry.uid)
X		|| (new_entry.uid == 0 &&!strcmp(old_entry.died_from,"(saved)")
X		    && new_entry.birth_date == old_entry.birth_date))
X	       && new_entry.sex == old_entry.sex
X	       && new_entry.race == old_entry.race
X	       && new_entry.class == old_entry.class)
X	{
X#if defined(MSDOS) || defined(VMS) || defined(AMIGA) || defined(MAC)
X	  (void) fclose (highscore_fp);
X#endif
X	  return;
X	}
X      else if (++i >= SCOREFILE_SIZE)
X	{
X	  /* only allow one thousand scores in the score file */
X#if defined(MSDOS) || defined(VMS) || defined(AMIGA) || defined(MAC)
X	  (void) fclose (highscore_fp);
X#endif
X	  return;
X	}
X      curpos = ftell (highscore_fp);
X      rd_highscore(&old_entry);
X    }
X
X  if (feof(highscore_fp))
X    {
X      /* write out new_entry at end of file */
X#ifndef BSD4_3
X      (void) fseek (highscore_fp, curpos, L_SET);
X#else
X      (void) fseek (highscore_fp, (off_t)curpos, L_SET);
X#endif
X      wr_highscore(&new_entry);
X    }
X  else
X    {
X      entry = new_entry;
X      while (!feof(highscore_fp))
X	{
X#ifndef BSD4_3
X#ifdef ATARIST_TC || defined(__TURBOC__)
X	  /* No fseek with negative offset allowed.  */
X	  (void) fseek(highscore_fp, (long)ftell(highscore_fp) -
X		       sizeof(high_scores) - sizeof (char), L_SET);
X#else
X	  (void) fseek(highscore_fp,
X		       -(long)sizeof(high_scores)-(long)sizeof(char),
X		       L_INCR);
X#endif
X#else
X	  (void) fseek(highscore_fp,
X		       -(off_t)sizeof(high_scores)-(off_t)sizeof(char),
X		       L_INCR);
X#endif
X	  wr_highscore(&entry);
X	  /* under unix and VMS, only allow one sex/race/class combo per
X	     person, on single user system, allow any number of entries, but
X	     try to prevent multiple entries per character by checking for
X	     case when birthdate/sex/race/class are the same, and died_from of
X	     scorefile entry is "(saved)" */
X	  if (((new_entry.uid != 0 && new_entry.uid == old_entry.uid)
X		|| (new_entry.uid == 0 &&!strcmp(old_entry.died_from,"(saved)")
X		    && new_entry.birth_date == old_entry.birth_date))
X	      && new_entry.sex == old_entry.sex
X	      && new_entry.race == old_entry.race
X	      && new_entry.class == old_entry.class)
X	    break;
X	  entry = old_entry;
X	  /* must fseek() before can change read/write mode */
X#ifndef BSD4_3
X#ifdef ATARIST_TC
X	  /* No fseek relative to current position allowed.  */
X	  (void) fseek(highscore_fp, (long)ftell(highscore_fp), L_SET);
X#else
X	  (void) fseek(highscore_fp, (long)0, L_INCR);
X#endif
X#else
X	  (void) fseek(highscore_fp, (off_t)0, L_INCR);
X#endif
X	  curpos = ftell (highscore_fp);
X	  rd_highscore(&old_entry);
X	}
X      if (feof(highscore_fp))
X	{
X#ifndef BSD4_3
X	  (void) fseek (highscore_fp, curpos, L_SET);
X#else
X	  (void) fseek (highscore_fp, (off_t)curpos, L_SET);
X#endif
X	  wr_highscore(&entry);
X	}
X    }
X
X#if !defined(VMS) && !defined(MSDOS) && !defined(AMIGA) && !defined(MAC)
X#ifdef ATARIST_TC
X  /* Flock never called for Atari ST with TC.  */
X#else
X  (void) flock((int)fileno(highscore_fp), LOCK_UN);
X#endif
X#else
X  (void) fclose (highscore_fp);
X#endif
X}
X
X
X/* Change the player into a King!			-RAK-	 */
Xstatic void kingly()
X{
X  register struct misc *p_ptr;
X  register char *p;
X
X  /* Change the character attributes.		 */
X  dun_level = 0;
X  (void) strcpy(died_from, "Ripe Old Age");
X  p_ptr = &py.misc;
X  (void) restore_level ();
X  p_ptr->lev += MAX_PLAYER_LEVEL;
X  p_ptr->au += 250000L;
X  p_ptr->max_exp += 5000000L;
X  p_ptr->exp = p_ptr->max_exp;
X
X  /* Let the player know that he did good.	 */
X  clear_screen();
X  put_buffer("#", 1, 34);
X  put_buffer("#####", 2, 32);
X  put_buffer("#", 3, 34);
X  put_buffer(",,,  $$$  ,,,", 4, 28);
X  put_buffer(",,=$   \"$$$$$\"   $=,,", 5, 24);
X  put_buffer(",$$        $$$        $$,", 6, 22);
X  put_buffer("*>         <*>         <*", 7, 22);
X  put_buffer("$$         $$$         $$", 8, 22);
X  put_buffer("\"$$        $$$        $$\"", 9, 22);
X  put_buffer("\"$$       $$$       $$\"", 10, 23);
X  p = "*#########*#########*";
X  put_buffer(p, 11, 24);
X  put_buffer(p, 12, 24);
X  put_buffer("Veni, Vidi, Vici!", 15, 26);
X  put_buffer("I came, I saw, I conquered!", 16, 21);
X  if (p_ptr->male)
X    put_buffer("All Hail the Mighty King!", 17, 22);
X  else
X    put_buffer("All Hail the Mighty Queen!", 17, 22);
X  flush();
X  pause_line(23);
X}
X
X
X/* Handles the gravestone end top-twenty routines	-RAK-	 */
Xvoid exit_game ()
X{
X#ifdef MAC
X  /* Prevent strange things from happening */
X  enablefilemenu(FALSE);
X#endif
X
X  /* What happens upon dying.				-RAK-	 */
X  msg_print(CNIL);
X  flush ();  /* flush all input */
X  nosignals ();	 /* Can't interrupt or suspend. */
X  /* If the game has been saved, then save sets turn back to -1, which
X     inhibits the printing of the tomb.	 */
X  if (turn >= 0)
X    {
X      if (total_winner)
X	kingly();
X      print_tomb();
X    }
X  if (character_generated && !character_saved)
X#ifdef MAC
X    (void) save_char (TRUE);		/* Save the memory at least. */
X#else
X    (void) save_char ();		/* Save the memory at least. */
X#endif
X  /* add score to scorefile if applicable */
X  if (character_generated)
X    {
X      /* Clear character_saved, strange thing to do, but it prevents inkey()
X	 from recursively calling exit_game() when there has been an eof
X	 on stdin detected.  */
X      character_saved = FALSE;
X      highscores();
X      display_scores (TRUE);
X    }
X  erase_line (23, 0);
X  restore_term ();
X#ifdef MAC
X  /* Undo what has been done */
X  enablefilemenu(TRUE);
X  /* Long jump back into the Mac wrapper, in lieu of exit () */
X  goback();
X#else
X  exit (0);
X#endif
X}
END_OF_FILE
if test 23954 -ne `wc -c <'source/death.c'`; then
    echo shar: \"'source/death.c'\" unpacked with wrong size!
fi
# end of 'source/death.c'
fi
if test -f 'source/externs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/externs.h'\"
else
echo shar: Extracting \"'source/externs.h'\" \(29501 characters\)
sed "s/^X//" >'source/externs.h' <<'END_OF_FILE'
X/* source/externs.h: declarations for global variables and initialized data
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X/* VMS requires that this be in externs.h, not files.c; this prevents a
X   'psect' error for the variable errno */
X#include <errno.h>
X
X/* Atari TC requires prototypes, but does not have __STDC__.
X   Hence, we check for ATARIST_TC here, and define LINT_ARGS if true.  */
X#ifdef ATARIST_TC
X#define LINT_ARGS
X#endif
X
X/* This causes more trouble than it is worth, and very few systems still
X   have this bug in their include files.  */
X#if 0
X/* many systems don't define these anywhere */
X#ifndef NeXT
X#ifndef AMIGA
X#if !defined(atarist) || !defined(__GNUC__)
X#ifndef __TURBOC__
X#if defined(USG) || defined(DGUX)
Xextern int sprintf();
X#else
Xextern char *sprintf();
X#endif
X#endif
X#endif
X#endif
X#endif
X#endif
X
X/* to avoid 'psect' problem with VMS declaration of errno */
X#ifndef VMS
Xextern int errno;
X#endif
X
Xextern char *copyright[5];
X
X/* horrible hack: needed because compact_monster() can be called from deep
X   within creatures() via place_monster() and summon_monster() */
Xextern int hack_monptr;
X
Xextern vtype died_from;
Xextern vtype savefile;			/* The save file. -CJS- */
Xextern int32 birth_date;
X
X/* These are options, set with set_options command -CJS- */
Xextern int rogue_like_commands;
Xextern int find_cut;			/* Cut corners on a run */
Xextern int find_examine;		/* Check corners on a run */
Xextern int find_prself;			/* Print yourself on a run (slower) */
Xextern int find_bound;			/* Stop run when the map shifts */
Xextern int prompt_carry_flag;		/* Prompt to pick something up */
Xextern int show_weight_flag;		/* Display weights in inventory */
Xextern int highlight_seams;		/* Highlight magma and quartz */
Xextern int find_ignore_doors;		/* Run through open doors */
Xextern int sound_beep_flag;		/* Beep for invalid character */
Xextern int display_counts;		/* Display rest/repeat counts */
X
X/* global flags */
Xextern int new_level_flag;	  /* Next level when true  */
Xextern int teleport_flag;	/* Handle teleport traps  */
Xextern int eof_flag;		/* Used to handle eof/HANGUP */
Xextern int player_light;      /* Player carrying light */
Xextern int find_flag;	/* Used in MORIA	      */
Xextern int free_turn_flag;	/* Used in MORIA	      */
Xextern int weapon_heavy;	/* Flag if the weapon too heavy -CJS- */
Xextern int pack_heavy;		/* Flag if the pack too heavy -CJS- */
Xextern char doing_inven;	/* Track inventory commands */
Xextern int screen_change;	/* Screen changes (used in inven_commands) */
X
Xextern int character_generated;	 /* don't save score until char gen finished*/
Xextern int character_saved;	 /* prevents save on kill after save_char() */
X#if defined(STDIO_LOADED)
Xextern FILE *highscore_fp;	/* High score file pointer */
X#endif
Xextern int command_count;	/* Repetition of commands. -CJS- */
Xextern int default_dir;		/* Use last direction in repeated commands */
Xextern int16 noscore;		/* Don't score this game. -CJS- */
Xextern int32u randes_seed;    /* For encoding colors */
Xextern int32u town_seed;	    /* Seed for town genera*/
Xextern int16 dun_level;	/* Cur dungeon level   */
Xextern int16 missile_ctr;	/* Counter for missiles */
Xextern int msg_flag;	/* Set with first msg  */
Xextern vtype old_msg[MAX_SAVE_MSG];	/* Last messages -CJS- */
Xextern int16 last_msg;			/* Where in the array is the last */
Xextern int death;	/* True if died	      */
Xextern int32 turn;	/* Cur trun of game    */
Xextern int wizard;	/* Wizard flag	      */
Xextern int to_be_wizard;
Xextern int16 panic_save; /* this is true if playing from a panic save */
X
Xextern int wait_for_more;
X
Xextern char days[7][29];
Xextern int closing_flag;	/* Used for closing   */
X
Xextern int16 cur_height, cur_width;	/* Cur dungeon size    */
X/*  Following are calculated from max dungeon sizes		*/
Xextern int16 max_panel_rows, max_panel_cols;
Xextern int panel_row, panel_col;
Xextern int panel_row_min, panel_row_max;
Xextern int panel_col_min, panel_col_max;
Xextern int panel_col_prt, panel_row_prt;
X
X/*  Following are all floor definitions				*/
X#ifdef MAC
Xextern cave_type (*cave)[MAX_WIDTH];
X#else
Xextern cave_type cave[MAX_HEIGHT][MAX_WIDTH];
X#endif
X
X/* Following are player variables				*/
Xextern player_type py;
X#ifdef MACGAME
Xextern char *(*player_title)[MAX_PLAYER_LEVEL];
Xextern race_type *race;
Xextern background_type *background;
X#else
Xextern char *player_title[MAX_CLASS][MAX_PLAYER_LEVEL];
Xextern race_type race[MAX_RACES];
Xextern background_type background[MAX_BACKGROUND];
X#endif
Xextern int32u player_exp[MAX_PLAYER_LEVEL];
Xextern int16u player_hp[MAX_PLAYER_LEVEL];
Xextern int16 char_row;
Xextern int16 char_col;
X
Xextern int8u rgold_adj[MAX_RACES][MAX_RACES];
X
Xextern class_type class[MAX_CLASS];
Xextern int16 class_level_adj[MAX_CLASS][MAX_LEV_ADJ];
X
X/* Warriors don't have spells, so there is no entry for them. */
X#ifdef MACGAME
Xextern spell_type (*magic_spell)[31];
X#else
Xextern spell_type magic_spell[MAX_CLASS-1][31];
X#endif
Xextern char *spell_names[62];
Xextern int32u spell_learned;	/* Bit field for spells learnt -CJS- */
Xextern int32u spell_worked;	/* Bit field for spells tried -CJS- */
Xextern int32u spell_forgotten;	/* Bit field for spells forgotten -JEW- */
Xextern int8u spell_order[32];	/* remember order that spells are learned in */
Xextern int16u player_init[MAX_CLASS][5];
Xextern int16 total_winner;
Xextern int32 max_score;
X
X/* Following are store definitions				*/
X#ifdef MACGAME
Xextern owner_type *owners;
X#else
Xextern owner_type owners[MAX_OWNERS];
X#endif
X#ifdef MAC
Xextern store_type *store;
X#else
Xextern store_type store[MAX_STORES];
X#endif
Xextern int16u store_choice[MAX_STORES][STORE_CHOICES];
X#ifndef MAC
Xextern int (*store_buy[MAX_STORES])();
X#endif
X
X/* Following are treasure arrays	and variables			*/
X#ifdef MACGAME
Xextern treasure_type *object_list;
X#else
Xextern treasure_type object_list[MAX_OBJECTS];
X#endif
Xextern int8u object_ident[OBJECT_IDENT_SIZE];
Xextern int16 t_level[MAX_OBJ_LEVEL+1];
Xextern inven_type t_list[MAX_TALLOC];
Xextern inven_type inventory[INVEN_ARRAY_SIZE];
Xextern char *special_names[SN_ARRAY_SIZE];
Xextern int16 sorted_objects[MAX_DUNGEON_OBJ];
Xextern int16 inven_ctr;		/* Total different obj's	*/
Xextern int16 inven_weight;	/* Cur carried weight	*/
Xextern int16 equip_ctr;	/* Cur equipment ctr	*/
Xextern int16 tcptr;	/* Cur treasure heap ptr	*/
X
X/* Following are creature arrays and variables			*/
X#ifdef MACGAME
Xextern creature_type *c_list;
X#else
Xextern creature_type c_list[MAX_CREATURES];
X#endif
Xextern monster_type m_list[MAX_MALLOC];
Xextern int16 m_level[MAX_MONS_LEVEL+1];
Xextern m_attack_type monster_attacks[N_MONS_ATTS];
X#ifdef MAC
Xextern recall_type *c_recall;
X#else
Xextern recall_type c_recall[MAX_CREATURES];	/* Monster memories. -CJS- */
X#endif
Xextern monster_type blank_monster;	/* Blank monster values	*/
Xextern int16 mfptr;	/* Cur free monster ptr	*/
Xextern int16 mon_tot_mult;	/* # of repro's of creature	*/
X
X/* Following are arrays for descriptive pieces			*/
X#ifdef MACGAME
Xextern char **colors;
Xextern char **mushrooms;
Xextern char **woods;
Xextern char **metals;
Xextern char **rocks;
Xextern char **amulets;
Xextern char **syllables;
X#else
Xextern char *colors[MAX_COLORS];
Xextern char *mushrooms[MAX_MUSH];
Xextern char *woods[MAX_WOODS];
Xextern char *metals[MAX_METALS];
Xextern char *rocks[MAX_ROCKS];
Xextern char *amulets[MAX_AMULETS];
Xextern char *syllables[MAX_SYLLABLES];
X#endif
X
Xextern int8u blows_table[7][6];
X
Xextern int16u normal_table[NORMAL_TABLE_SIZE];
X
X/* Initialized data which had to be moved from some other file */
X/* Since these get modified, macrsrc.c must be able to access them */
X/* Otherwise, game cannot be made restartable */
X/* dungeon.c */
Xextern char last_command;  /* Memory of previous command. */
X/* moria1.c */
X/* Track if temporary light about player.  */
Xextern int light_flag;
X
X#ifdef MSDOS
Xextern int8u	floorsym, wallsym;
Xextern int	ansi, saveprompt;
Xextern char	moriatop[], moriasav[];
X#endif
X
X/* function return values */
X/* only extern functions declared here, static functions declared inside
X   the file that defines them */
X#if defined(LINT_ARGS)
X/* these prototypes can be used by MSC and TC for type checking of arguments
X   WARNING: note that this does not work for all ANSI C compilers, e.g. Gnu C,
X   will give error messages if you use these prototypes.
X   This is due to differing interpretations of the ANSI C standard,
X   specifically how to handle promotion of parameters.  In my reading of
X   the standard, I believe that Gnu C's behaviour is correct.  */
X
X#ifdef ATARI_ST
X/* atarist.c */
Xint check_input(int microsec);
Xvoid user_name(char * buf);
Xint access(char * name, int dum);
Xvoid chmod(char * name, int mode); /* dummy function */
X#endif
X
X/* create.c */
Xvoid create_character(void);
X
X/* creature.c */
Xvoid update_mon(int);
Xint multiply_monster(int, int, int, int);
Xvoid creatures(int);
X
X/* death.c */
Xvoid display_scores(int);
Xint duplicate_character(void);
Xint32 total_points(void);
Xvoid exit_game(void);
X
X/* desc.c */
Xint is_a_vowel(char);
Xvoid magic_init(void);
Xint16 object_offset(struct inven_type *);
Xvoid known1(struct inven_type *);
Xint known1_p(struct inven_type *);
Xvoid known2(struct inven_type *);
Xint known2_p(struct inven_type *);
Xvoid clear_known2(struct inven_type *);
Xvoid clear_empty(inven_type *);
Xvoid store_bought(inven_type *);
Xint store_bought_p(inven_type *);
Xvoid sample(struct inven_type *);
Xvoid identify(int *);
Xvoid unmagic_name(struct inven_type *);
Xvoid objdes(char *, struct inven_type *, int);
Xvoid invcopy(inven_type *, int);
Xvoid desc_charges(int);
Xvoid desc_remain(int);
X
X/* dungeon.c */
Xvoid dungeon(void);
X
X/* eat.c */
Xvoid eat(void);
X
X/* files.c */
Xvoid init_scorefile(void);
Xvoid read_times(void);
Xvoid helpfile(char *);
Xvoid print_objects(void);
X#ifdef MAC
Xint file_character(void);
X#else
Xint file_character(char *);
X#endif
X
X/* generate.c */
Xvoid generate_cave(void);
X
X#ifdef VMS
X/* getch.c */
Xint kbhit (void);
Xvoid user_name (char *);
Xvoid vms_crmode (void);
Xvoid vms_nocrmode (void);
Xint opengetch (void);
Xint closegetch (void);
Xchar vms_getch (void);
X#endif
X
X/* help.c */
Xvoid ident_char(void);
X
X/* io.c */
X#ifdef SIGTSTP
Xint suspend(void);
X#endif
Xvoid init_curses(void);
Xvoid moriaterm(void);
Xvoid put_buffer(char *, int, int);
Xvoid put_qio(void);
Xvoid restore_term(void);
Xvoid shell_out(void);
Xchar inkey(void);
Xvoid flush(void);
Xvoid erase_line(int, int);
Xvoid clear_screen(void);
Xvoid clear_from(int);
Xvoid print(char, int, int);
Xvoid move_cursor_relative(int, int);
Xvoid count_msg_print(char *);
Xvoid prt(char *, int, int);
Xvoid move_cursor(int, int);
Xvoid msg_print(char *);
Xint get_check(char *);
Xint get_com(char *, char *);
Xint get_string(char *, int, int, int);
Xvoid pause_line(int);
Xvoid pause_exit(int, int);
Xvoid save_screen(void);
Xvoid restore_screen(void);
Xvoid bell(void);
Xvoid screen_map(void);
X
X/* magic.c */
Xvoid cast(void);
X
X/* main.c */
Xint main(int, char **);
X
X/* misc1.c */
Xvoid init_seeds(int32u);
Xvoid set_seed(int32u);
Xvoid reset_seed(void);
Xint check_time(void);
Xint randint(int);
Xint randnor(int, int);
Xint bit_pos(int32u *);
Xint in_bounds(int, int);
Xvoid panel_bounds(void);
Xint get_panel(int, int, int);
Xint panel_contains(int, int);
Xint distance(int, int, int, int);
Xint next_to_wall(int, int);
Xint next_to_corr(int, int);
Xint damroll(int, int);
Xint pdamroll(unsigned char *);
Xint los(int, int, int, int);
Xunsigned char loc_symbol(int, int);
Xint test_light(int, int);
Xvoid prt_map(void);
Xint compact_monsters(void);
Xvoid add_food(int);
Xint popm(void);
Xint max_hp(unsigned char *);
Xint place_monster(int, int, int, int);
Xvoid place_win_monster(void);
Xint get_mons_num(int);
Xvoid alloc_monster(int, int, int);
Xint summon_monster(int * ,int *, int);
Xint summon_undead(int *, int *);
Xint popt(void);
Xvoid pusht(int8u);
Xint magik(int);
Xint m_bonus(int, int, int);
X
X/* misc2.c */
Xvoid magic_treasure(int, int);
Xvoid set_options(void);
X
X/* misc3.c */
Xvoid place_trap(int, int, int);
Xvoid place_rubble(int, int);
Xvoid place_gold(int, int);
Xint get_obj_num(int);
Xvoid place_object(int, int);
Xvoid alloc_object(int (*)(), int, int);
Xvoid random_object(int, int, int);
Xvoid cnv_stat(int8u, char *);
Xvoid prt_stat(int);
Xvoid prt_field(char *, int, int);
Xint stat_adj(int);
Xint chr_adj(void);
Xint con_adj(void);
Xchar *title_string(void);
Xvoid prt_title(void);
Xvoid prt_level(void);
Xvoid prt_cmana(void);
Xvoid prt_mhp(void);
Xvoid prt_chp(void);
Xvoid prt_pac(void);
Xvoid prt_gold(void);
Xvoid prt_depth(void);
Xvoid prt_hunger(void);
Xvoid prt_blind(void);
Xvoid prt_confused(void);
Xvoid prt_afraid(void);
Xvoid prt_poisoned(void);
Xvoid prt_state(void);
Xvoid prt_speed(void);
Xvoid prt_study(void);
Xvoid prt_winner(void);
Xint8u modify_stat(int, int16);
Xvoid set_use_stat(int);
Xint inc_stat(int);
Xint dec_stat(int);
Xint res_stat(int);
Xvoid bst_stat(int, int);
Xint tohit_adj(void);
Xint toac_adj(void);
Xint todis_adj(void);
Xint todam_adj(void);
Xvoid prt_stat_block(void);
Xvoid draw_cave(void);
Xvoid put_character(void);
Xvoid put_stats(void);
Xchar *likert(int, int);
Xvoid put_misc1(void);
Xvoid put_misc2(void);
Xvoid put_misc3(void);
Xvoid display_char(void);
Xvoid get_name(void);
Xvoid change_name(void);
Xvoid inven_destroy(int);
Xvoid take_one_item(struct inven_type *, struct inven_type *);
Xvoid inven_drop(int, int);
Xint inven_damage(int (*)(), int);
Xint weight_limit(void);
Xint inven_check_num(struct inven_type *);
Xint inven_check_weight(struct inven_type *);
Xvoid check_strength(void);
Xint inven_carry(struct inven_type *);
Xint spell_chance(int);
Xvoid print_spells(int *, int, int, int);
Xint get_spell(int *, int, int *, int *, char *, int);
Xvoid calc_spells(int);
Xvoid gain_spells(void);
Xvoid calc_mana(int);
Xvoid prt_experience(void);
Xvoid calc_hitpoints(void);
Xvoid insert_str(char *, char *, char *);
Xvoid insert_lnum(char *, char *, int32, int);
Xint enter_wiz_mode(void);
Xint attack_blows(int, int *);
Xint tot_dam(struct inven_type *, int, int);
Xint critical_blow(int, int, int, int);
Xint mmove(int, int *, int *);
Xint player_saves(void);
Xint find_range(int, int, int *, int *);
Xvoid teleport(int);
X
X/* misc4.c */
Xvoid scribe_object(void);
Xvoid add_inscribe(struct inven_type *, int8u);
Xvoid inscribe(struct inven_type *, char *);
Xvoid check_view(void);
X
X/* monsters.c */
X
X/* moria1.c */
Xvoid change_speed(int);
Xvoid py_bonuses(struct inven_type *, int);
Xvoid calc_bonuses(void);
Xint show_inven(int, int, int, int, char *);
Xchar *describe_use(int);
Xint show_equip(int, int);
Xvoid takeoff(int, int);
Xint verify(char *, int);
Xvoid inven_command(char);
Xint get_item(int *, char *, int, int, char *, char *);
Xint no_light(void);
Xint get_dir(char *, int *);
Xint get_alldir(char *, int *);
Xvoid move_rec(int, int, int, int);
Xvoid light_room(int, int);
Xvoid lite_spot(int, int);
Xvoid move_light(int, int, int, int);
Xvoid disturb(int, int);
Xvoid search_on(void);
Xvoid search_off(void);
Xvoid rest(void);
Xvoid rest_off(void);
Xint test_hit(int, int, int, int, int);
Xvoid take_hit(int, char *);
X
X/* moria2.c */
Xvoid change_trap(int, int);
Xvoid search(int, int, int);
Xvoid find_init(int);
Xvoid find_run(void);
Xvoid end_find(void);
Xvoid area_affect(int, int, int);
Xint minus_ac(int32u);
Xvoid corrode_gas(char *);
Xvoid poison_gas(int, char *);
Xvoid fire_dam(int, char *);
Xvoid cold_dam(int, char *);
Xvoid light_dam(int, char *);
Xvoid acid_dam(int, char *);
X
X/* moria3.c */
Xint cast_spell(char * ,int, int *, int *);
Xvoid delete_monster(int);
Xvoid fix1_delete_monster(int);
Xvoid fix2_delete_monster(int);
Xint delete_object(int, int);
Xint32u monster_death(int, int, int32u);
Xint mon_take_hit(int, int);
Xvoid py_attack(int, int);
Xvoid move_char(int, int);
Xvoid chest_trap(int, int);
Xvoid openobject(void);
Xvoid closeobject(void);
Xint twall(int, int, int, int);
X
X/* moria4.c */
Xvoid tunnel(int);
Xvoid disarm_trap(void);
Xvoid look(void);
Xvoid throw_object(void);
Xvoid bash(void);
X
X#ifdef MSDOS
X/* ms_misc.c */
Xvoid user_name(char *);
Xchar *getlogin(void);
X#ifdef __TURBOC__
Xvoid sleep(unsigned);
X#else
Xunsigned int sleep(int);
X#endif
Xvoid error(char *, ...);
Xvoid warn(char *, ...);
Xvoid msdos_init(void);
Xvoid msdos_raw(void);
Xvoid msdos_noraw(void);
Xint bios_getch(void);
Xint msdos_getch(void);
Xvoid bios_clear(void);
Xvoid msdos_intro(void);
Xvoid bios_clear(void);
X#endif
X
X/* potions.c */
Xvoid quaff(void);
X
X/* prayer.c */
Xvoid pray(void);
X
X/* recall.c */
Xint bool_roff_recall(int);
Xint roff_recall(int);
X
X/* rnd.c */
Xint32u get_rnd_seed(void);
Xvoid set_rnd_seed(int32u);
Xint32 rnd(void);
X
X/* save.c */
X#ifdef MAC
Xint save_char(int);
X#else
Xint save_char(void);
X#endif
Xint _save_char(char *);
Xint get_char(int *);
X#if defined(STDIO_LOADED)
Xvoid set_fileptr(FILE *);
X#endif
Xvoid wr_highscore(high_scores *);
Xvoid rd_highscore(high_scores *);
X
X/* scrolls.c */
Xvoid read_scroll(void);
X
X/* sets.c */
Xint set_room(int);
Xint set_corr(int);
Xint set_floor(int);
Xint set_corrodes(inven_type *);
Xint set_flammable(inven_type *);
Xint set_frost_destroy(inven_type *);
Xint set_acid_affect(inven_type *);
Xint set_lightning_destroy(inven_type *);
Xint set_null(inven_type *);
Xint set_acid_destroy(inven_type *);
Xint set_fire_destroy(inven_type *);
Xint general_store(int);
Xint armory(int);
Xint weaponsmith(int);
Xint temple(int);
Xint alchemist(int);
Xint magic_shop(int);
X#ifdef MAC
Xint store_buy(int, int);
X#endif
X
X/* signals.c */
Xvoid nosignals(void);
Xvoid signals(void);
Xvoid init_signals(void);
Xvoid ignore_signals(void);
Xvoid default_signals(void);
Xvoid restore_signals(void);
X
X/* spells.c */
Xvoid monster_name(char *, struct monster_type *, struct creature_type *);
Xvoid lower_monster_name(char *, struct monster_type *,
X			struct creature_type *);
Xint sleep_monsters1(int, int);
Xint detect_treasure(void);
Xint detect_object(void);
Xint detect_trap(void);
Xint detect_sdoor(void);
Xint detect_invisible(void);
Xint light_area(int, int);
Xint unlight_area(int, int);
Xvoid map_area(void);
Xint ident_spell(void);
Xint aggravate_monster(int);
Xint trap_creation(void);
Xint door_creation(void);
Xint td_destroy(void);
Xint detect_monsters(void);
Xvoid light_line(int, int, int);
Xvoid starlite(int, int);
Xint disarm_all(int, int, int);
Xvoid get_flags(int, int32u *, int *, int (**)());
Xvoid fire_bolt(int, int, int, int, int, char *);
Xvoid fire_ball(int, int, int, int, int, char *);
Xvoid breath(int, int, int, int, char *, int);
Xint recharge(int);
Xint hp_monster(int, int, int, int);
Xint drain_life(int, int, int);
Xint speed_monster(int, int, int, int);
Xint confuse_monster(int, int, int);
Xint sleep_monster(int, int, int);
Xint wall_to_mud(int, int, int);
Xint td_destroy2(int, int, int);
Xint poly_monster(int, int, int);
Xint build_wall(int, int, int);
Xint clone_monster(int, int, int);
Xvoid teleport_away(int, int);
Xvoid teleport_to(int, int);
Xint teleport_monster(int, int, int);
Xint mass_genocide(void);
Xint genocide(void);
Xint speed_monsters(int);
Xint sleep_monsters2(void);
Xint mass_poly(void);
Xint detect_evil(void);
Xint hp_player(int);
Xint cure_confusion(void);
Xint cure_blindness(void);
Xint cure_poison(void);
Xint remove_fear(void);
Xvoid earthquake(void);
Xint protect_evil(void);
Xvoid create_food(void);
Xint dispel_creature(int, int);
Xint turn_undead(void);
Xvoid warding_glyph(void);
Xvoid lose_str(void);
Xvoid lose_int(void);
Xvoid lose_wis(void);
Xvoid lose_dex(void);
Xvoid lose_con(void);
Xvoid lose_chr(void);
Xvoid lose_exp(int32);
Xint slow_poison(void);
Xvoid bless(int);
Xvoid detect_inv2(int);
Xvoid destroy_area(int, int);
Xint enchant(int16 *, int16);
Xint remove_curse(void);
Xint restore_level(void);
X
X/* staffs.c */
Xvoid use(void);
X
X/* store1.c */
Xint32 item_value(struct inven_type *);
Xint32 sell_price(int, int32 *, int32 *, struct inven_type *);
Xint store_check_num(struct inven_type *, int);
Xvoid store_carry(int, int *, struct inven_type *);
Xvoid store_destroy(int, int, int);
Xvoid store_init(void);
Xvoid store_maint(void);
Xint noneedtobargain(int, int32);
Xvoid updatebargain(int, int32, int32);
X
X/* store2.c */
Xvoid enter_store(int);
X
X/* treasur1.c */
X
X/* treasur2.c */
X
X#ifdef VMS
X/* uexit.c */
Xvoid uexit (int);
X#endif
X
X#ifdef unix
X/* unix.c */
Xint check_input(int);
X#if 0
Xint system_cmd(char *);
X#endif
Xvoid user_name(char *);
Xint tilde(char *, char *);
X/* only declare this if stdio.h has been previously included, STDIO_LOADED
X   is defined after stdio.h is included */
X#if defined(STDIO_LOADED)
XFILE *tfopen(char *, char *);
X#endif
Xint topen(char *, int, int);
X#endif
X
X/* variable.c */
X
X/* wands.c */
Xvoid aim(void);
X
X/* wizard.c */
Xvoid wizard_light(void);
Xvoid change_character(void);
Xvoid wizard_create(void);
X
X#else
X/* !defined (LINT_ARGS) */
X
X#ifdef ATARI_ST
X/* atarist.c */
Xint check_input ();
Xvoid user_name ();
Xint access ();
Xvoid chmod ();
X#endif
X
X/* create.c */
Xvoid create_character();
X
X/* creature.c */
Xvoid update_mon();
Xint multiply_monster();
Xvoid creatures();
X
X/* death.c */
Xvoid display_scores();
Xint duplicate_character();
Xint32 total_points();
Xvoid exit_game();
X
X/* desc.c */
Xint is_a_vowel();
Xvoid magic_init();
Xint16 object_offset();
Xvoid known1();
Xint known1_p();
Xvoid known2();
Xint known2_p();
Xvoid clear_known2();
Xvoid clear_empty();
Xvoid store_bought();
Xint store_bought_p();
Xvoid sample();
Xvoid identify();
Xvoid unmagic_name();
Xvoid objdes();
Xvoid invcopy();
Xvoid desc_charges();
Xvoid desc_remain();
X
X/* dungeon.c */
Xvoid dungeon();
X
X/* eat.c */
Xvoid eat();
X
X/* files.c */
Xvoid init_scorefile();
Xvoid read_times();
Xvoid helpfile();
Xvoid print_objects();
Xint file_character();
X
X/* generate.c */
Xvoid generate_cave();
X
X#ifdef VMS
X/* getch.c */
Xint kbhit ();
Xvoid user_name ();
Xvoid vms_crmode ();
Xvoid vms_nocrmode ();
Xint opengetch ();
Xint closegetch ();
Xchar vms_getch ();
X#endif
X
X/* help.c */
Xvoid ident_char();
X
X/* io.c */
X#ifdef SIGTSTP
Xint suspend();
X#endif
Xvoid init_curses();
Xvoid moriaterm();
Xvoid put_buffer();
Xvoid put_qio();
Xvoid restore_term();
Xvoid shell_out();
Xchar inkey();
Xvoid flush();
Xvoid erase_line();
Xvoid clear_screen();
Xvoid clear_from();
Xvoid print();
Xvoid move_cursor_relative();
Xvoid count_msg_print();
Xvoid prt();
Xvoid move_cursor();
Xvoid msg_print();
Xint get_check();
Xint get_com();
Xint get_string();
Xvoid pause_line();
Xvoid pause_exit();
Xvoid save_screen();
Xvoid restore_screen();
Xvoid bell();
Xvoid screen_map();
X
X/* magic.c */
Xvoid cast();
X
X/* main.c */
Xint main();
X
X/* misc1.c */
Xvoid init_seeds();
Xvoid set_seed();
Xvoid reset_seed();
Xint check_time();
Xint randint();
Xint randnor();
Xint bit_pos();
Xint in_bounds();
Xvoid panel_bounds();
Xint get_panel();
Xint panel_contains();
Xint distance();
Xint next_to_walls();
Xint next_to_corr();
Xint damroll();
Xint pdamroll();
Xint los();
Xunsigned char loc_symbol();
Xint test_light();
Xvoid prt_map();
Xint compact_monsters();
Xvoid add_food();
Xint popm();
Xint max_hp();
Xint place_monster();
Xvoid place_win_monster();
Xint get_mons_num();
Xvoid alloc_monster();
Xint summon_monster();
Xint summon_undead();
Xint popt();
Xvoid pusht();
Xint magik();
Xint m_bonus();
X
X/* misc2.c */
Xvoid magic_treasure();
Xvoid set_options();
X
X/* misc3.c */
Xvoid place_trap();
Xvoid place_rubble();
Xvoid place_gold();
Xint get_obj_num();
Xvoid place_object();
Xvoid alloc_object();
Xvoid random_object();
Xvoid cnv_stat();
Xvoid prt_stat();
Xvoid prt_field();
Xint stat_adj();
Xint chr_adj();
Xint con_adj();
Xchar *title_string();
Xvoid prt_title();
Xvoid prt_level();
Xvoid prt_cmana();
Xvoid prt_mhp();
Xvoid prt_chp();
Xvoid prt_pac();
Xvoid prt_gold();
Xvoid prt_depth();
Xvoid prt_hunger();
Xvoid prt_blind();
Xvoid prt_confused();
Xvoid prt_afraid();
Xvoid prt_poisoned();
Xvoid prt_state();
Xvoid prt_speed();
Xvoid prt_study();
Xvoid prt_winner();
Xint8u modify_stat();
Xvoid set_use_stat();
Xint inc_stat();
Xint dec_stat();
Xint res_stat();
Xvoid bst_stat();
Xint tohit_adj();
Xint toac_adj();
Xint todis_adj();
Xint todam_adj();
Xvoid prt_stat_block();
Xvoid draw_cave();
Xvoid put_character();
Xvoid put_stats();
Xchar *likert();
Xvoid put_misc1();
Xvoid put_misc2();
Xvoid put_misc3();
Xvoid display_char();
Xvoid get_name();
Xvoid change_name();
Xvoid inven_destroy();
Xvoid take_one_item();
Xvoid inven_drop();
Xint inven_damage();
Xint weight_limit();
Xint inven_check_num();
Xint inven_check_weight();
Xvoid check_strength();
Xint inven_carry();
Xint spell_chance();
Xvoid print_spells();
Xint get_spell();
Xvoid calc_spells();
Xvoid gain_spells();
Xvoid calc_mana();
Xvoid prt_experience();
Xvoid calc_hitpoints();
Xvoid insert_str();
Xvoid insert_lnum();
Xint enter_wiz_mode();
Xint attack_blows();
Xint tot_dam();
Xint critical_blow();
Xint mmove();
Xint player_saves();
Xint find_range();
Xvoid teleport();
X
X/* misc4.c */
Xvoid scribe_object();
Xvoid add_inscribe();
Xvoid inscribe();
Xvoid check_view();
X
X/* monsters.c */
X
X/* moria1.c */
Xvoid change_speed();
Xvoid py_bonuses();
Xvoid calc_bonuses();
Xint show_inven();
Xchar *describe_use();
Xint show_equip();
Xvoid takeoff();
Xint verify();
Xvoid inven_command();
Xint get_item();
Xint no_light();
Xint get_dir();
Xint get_alldir();
Xvoid move_rec();
Xvoid light_room();
Xvoid lite_spot();
Xvoid move_light();
Xvoid disturb();
Xvoid search_on();
Xvoid search_off();
Xvoid rest();
Xvoid rest_off();
Xint test_hit();
Xvoid take_hit();
X
X/* moria2.c */
Xvoid change_trap();
Xvoid search();
Xvoid find_init();
Xvoid find_run();
Xvoid end_find();
Xvoid area_affect();
Xint minus_ac();
Xvoid corrode_gas();
Xvoid poison_gas();
Xvoid fire_dam();
Xvoid cold_dam();
Xvoid light_dam();
Xvoid acid_dam();
X
X/* moria3.c */
Xint cast_spell();
Xvoid delete_monster();
Xvoid fix1_delete_monster();
Xvoid fix2_delete_monster();
Xint delete_object();
Xint32u monster_death();
Xint mon_take_hit();
Xvoid py_attack();
Xvoid move_char();
Xvoid chest_trap();
Xvoid openobject();
Xvoid closeobject();
Xint twall();
X
X/* moria4.c */
Xvoid tunnel();
Xvoid disarm_trap();
Xvoid look();
Xvoid throw_object();
Xvoid bash();
X
X#ifdef MSDOS
X/* ms_misc.c */
Xvoid user_name();
Xchar *getlogin();
X#ifdef __TURBOC__
Xvoid sleep();
X#else
Xunsigned int sleep();
X#endif
X#if 0
Xvoid error();
Xvoid warn();
X#else
X/* Because an empty parameter list in a declaration can not match a parameter
X   list with an elipsis in a definition.  */
Xvoid error (char *fmt, ...);
Xvoid warn (char *fmt, ...);
X#endif
Xvoid msdos_init();
Xvoid msdos_raw();
Xvoid msdos_noraw();
Xint bios_getch();
Xint msdos_getch();
Xvoid bios_clear();
Xvoid msdos_intro();
Xvoid bios_clear();
X#endif
X
X/* potions.c */
Xvoid quaff();
X
X/* prayer.c */
Xvoid pray();
X
X/* recall.c */
Xint bool_roff_recall();
Xint roff_recall();
X
X/* rnd.c */
Xint32u get_rnd_seed();
Xvoid set_rnd_seed();
Xint32 rnd();
X
X/* save.c */
Xint save_char();
Xint _save_char();
Xint get_char();
X#if defined(STDIO_LOADED)
Xvoid set_fileptr();
X#endif
Xvoid wr_highscore();
Xvoid rd_highscore();
X
X/* scrolls.c */
Xvoid read_scroll();
X
X/* sets.c */
Xint set_room();
Xint set_corr();
Xint set_floor();
Xint set_corrodes();
Xint set_flammable();
Xint set_frost_destroy();
Xint set_acid_affect();
Xint set_lightning_destroy();
Xint set_null();
Xint set_acid_destroy();
Xint set_fire_destroy();
Xint general_store();
Xint armory();
Xint weaponsmith();
Xint temple();
Xint alchemist();
Xint magic_shop();
X#ifdef MAC
Xint store_buy();
X#endif
X
X/* signals.c */
Xvoid nosignals();
Xvoid signals();
Xvoid init_signals();
Xvoid ignore_signals();
Xvoid default_signals();
Xvoid restore_signals();
X
X/* spells.c */
Xvoid monster_name();
Xvoid lower_monster_name();
Xint sleep_monsters1();
Xint detect_treasure();
Xint detect_object();
Xint detect_trap();
Xint detect_sdoor();
Xint detect_invisible();
Xint light_area();
Xint unlight_area();
Xvoid map_area();
Xint ident_spell();
Xint aggravate_monster();
Xint trap_creation();
Xint door_creation();
Xint td_destroy();
Xint detect_monsters();
Xvoid light_line();
Xvoid starlite();
Xint disarm_all();
Xvoid get_flags();
Xvoid fire_bolt();
Xvoid fire_ball();
Xvoid breath();
Xint recharge();
Xint hp_monster();
Xint drain_life();
Xint speed_monster();
Xint confuse_monster();
Xint sleep_monster();
Xint wall_to_mud();
Xint td_destroy2();
Xint poly_monster();
Xint build_wall();
Xint clone_monster();
Xvoid teleport_away();
Xvoid teleport_to();
Xint teleport_monster();
Xint mass_genocide();
Xint genocide();
Xint speed_monsters();
Xint sleep_monsters2();
Xint mass_poly();
Xint detect_evil();
Xint hp_player();
Xint cure_confusion();
Xint cure_blindness();
Xint cure_poison();
Xint remove_fear();
Xvoid earthquake();
Xint protect_evil();
Xvoid create_food();
Xint dispel_creature();
Xint turn_undead();
Xvoid warding_glyph();
Xvoid lose_str();
Xvoid lose_int();
Xvoid lose_wis();
Xvoid lose_dex();
Xvoid lose_con();
Xvoid lose_chr();
Xvoid lose_exp();
Xint slow_poison();
Xvoid bless();
Xvoid detect_inv2();
Xvoid destroy_area();
Xint enchant();
Xint remove_curse();
Xint restore_level();
X
X/* staffs.c */
Xvoid use();
X
X/* store1.c */
Xint32 item_value();
Xint32 sell_price();
Xint store_check_num();
Xvoid store_carry();
Xvoid store_destroy();
Xvoid store_init();
Xvoid store_maint();
Xint noneedtobargain();
Xvoid updatebargain();
X
X/* store2.c */
Xvoid enter_store();
X
X/* treasur1.c */
X
X/* treasur2.c */
X
X#ifdef VMS
X/* uexit.c */
Xvoid uexit ();
X#endif
X
X#ifdef unix
X/* unix.c */
Xint check_input();
X#if 0
Xint system_cmd();
X#endif
Xvoid user_name();
Xint tilde();
X/* only declare this if stdio.h has been previously included, STDIO_LOADED
X   is defined after stdio.h is included  */
X#if defined(STDIO_LOADED)
XFILE *tfopen();
X#endif
Xint topen();
X#endif
X
X/* variable.c */
X
X/* wands.c */
Xvoid aim();
X
X/* wizard.c */
Xvoid wizard_light();
Xvoid change_character();
Xvoid wizard_create();
X
X#endif
X
X#ifdef unix
X/* call functions which expand tilde before calling open/fopen */
X#define open topen
X#define fopen tfopen
X#endif
X
X/* st-stuff.c for the atari ST */
X#if defined(atarist) && defined(__GNUC__)
Xextern char extended_file_name[80];
X#endif
END_OF_FILE
if test 29501 -ne `wc -c <'source/externs.h'`; then
    echo shar: \"'source/externs.h'\" unpacked with wrong size!
fi
# end of 'source/externs.h'
fi
echo shar: End of archive 22 \(of 39\).
cp /dev/null ark22isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
