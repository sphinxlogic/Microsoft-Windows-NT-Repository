Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i057:  umoria4 - single player dungeon simulation (ver. 5.5), Part25/39
Message-ID: <3421@master.CNA.TEK.COM>
Date: 22 Aug 92 22:13:14 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1955
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 57
Archive-name: umoria4/Part25
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 25 (of 39)."
# Contents:  doc/moria2.txt.2 source/spells.c.2
# Wrapped by billr@saab on Thu Aug 20 09:11:32 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/moria2.txt.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/moria2.txt.2'\"
else
echo shar: Extracting \"'doc/moria2.txt.2'\" \(26116 characters\)
sed "s/^X//" >'doc/moria2.txt.2' <<'END_OF_FILE'
X
X          A character must wield a torch or lamp in order to supply his own
X          light.   Once  a  torch  or  lamp  has only 50 or less turns left
X          before burning out, the message "Your  light  is  growing  faint"
X
X
X
X
X
X
X
X
X
X          The Dungeons of Moria                                Page 28
X
X
X          will  be  displayed  at  random intervals.  Once a torch is burnt
X          out, it is useless and can be dropped.  A lamp or lantern can  be
X          refilled  with  oil  by  using the Fill `F' command.  You must of
X          course be carrying extra oil to refill a lantern.
X
X
X          8.  Attacking and Being Attacked
X
X          Attacking is simple in moria.  If you move into a  creature,  you
X          attack  him.  You can attack from a distance by firing a missile,
X          or by magical means such as aiming a wand.  Creatures  attack  in
X          the  same  way,  if  they  move  into you, they attack you.  Some
X          creatures can also cast spells from a distance,  and  others  can
X          breathe fire or worse on you from a distance.
X
X          Creatures moving in walls can not be attacked by wands and  other
X          magic  attacks  normally  stopped  by  walls.   You  can attack a
X          creature in a wall normally though by trying  to  move  into  the
X          wall  space containing the creature.  However, in order to attack
X          an invisible creature in a wall, you must tunnel  into  the  wall
X          containing  the creature.  If you just try to move into the wall,
X          you will bump your head and look quite silly.
X
X          If you are wielding a weapon, the damage for the weapon  is  used
X          when  you  hit  a  creature.  Otherwise you get two fist strikes.
X          Very strong creatures can do a lot of damage with their  fists...
X          You  may  have  a primary weapon, and a secondary weapon which is
X          kept on your belt or shoulder for immediate use.  You can  switch
X          between your primary and secondary weapons with the exchange com-
X          mand.  Be sure to wield the proper weapon when fighting.  Hitting
X          a  dragon  over the head with a bow will simply make him mad, and
X          get you killed.
X
X          Missile weapons, such as bows,  can  be  wielded,  and  then  the
X          proper  missile,  in  this case an arrow, can be fired across the
X          room into a target.  Missiles can be used without the proper mis-
X          sile  weapon,  but used together they have a greater range and do
X          far more damage.
X
X          Hits and misses are determined by ability  to  hit  versus  armor
X          class.   A  hit  is a strike that does some damage; a miss may in
X          fact reach a target, but fails to do any  damage.   Higher  armor
X          classes make it harder to do damage, and so lead to more misses.
X
X
X          8.1.  Monster Memories.
X
X          There are hundreds of different creatures in the mines of  moria,
X          many  of which look the same on the screen.  The exact species of
X          a creature can be discovered by looking at it.  It is  also  very
X          difficult to keep track of the capabilities of various creatures.
X          Rather than forcing you to keep notes, moria automatically  keeps
X          track  of  your  experiences with a particular creature.  This is
X          called the  monster  memory.   Your monster  memory  recalls  the
X
X
X
X
X
X
X
X
X
X          The Dungeons of Moria                                Page 29
X
X
X          particular attacks of each creature (whether or not technically a
X          monster) which you have suffered, as well  as  recalling  if  you
X          have  observed  them  to  multiply  or  move erratically, or drop
X          treasure, or many other attributes.
X
X          If you have killed enough of a particular creature,  or  suffered
X          enough attacks, recalling the monster memory may also provide you
X          with information not otherwise available, such as a  armor  class
X          or  hit dice.  These are not explained, but may be useful to give
X          the relative danger of each creature.  This memory can be  passed
X          on  to  a new character even after you die, by means of a reduced
X          save file.
X
X
X          8.2.  Your Weapon
X
X          Carrying a weapon in your backpack does you no  good.   You  must
X          wield  a  weapon  before  it can be used in a fight.  A secondary
X          weapon can be kept by wielding it and  then  using  the  exchange
X          command.   A  secondary  weapon is not in use, simply ready to be
X          switched with the current weapon if needed.
X
X          Weapons have two main characteristics, their ability to  hit  and
X          their  ability  to  do  damage, expressed as `(+#,+#)'.  A normal
X          weapon would be `(+0,+0)'.  Many weapons in  moria  have  magical
X          bonuses  to  hit  and/or do damage.  Some weapons are cursed, and
X          have penalties that hurt the player.  Cursed  weapons  cannot  be
X          unwielded until the curse is lifted.
X
X          Moria assumes that your youth in the rough environment  near  the
X          dungeons has taught you the relative merits of different weapons,
X          and displays as part of their description the damage  dice  which
X          define their capabilities.  The ability to damage is added to the
X          dice roll for that weapon.  The dice used for a given  weapon  is
X          displayed  as `#d#'.  The first number indicates how many dice to
X          roll, and the second indicates how many sides they have.  A "2d6"
X          weapon will give damage from 2 to 12, plus any damage bonus.  The
X          weight of a weapon is also a consideration.   Heavy  weapons  may
X          hit  harder,  but they are also harder to use.  Depending on your
X          strength and the weight of the weapon, you may get  several  hits
X          in one turn.
X
X          Missile booster weapons, such as bows, have their characteristics
X          added  to those of the missile used, if the proper weapon/missile
X          combination is used.  Also, these weapons will multiply the  base
X          damage  of  the missile by a number from 2 to 4, depending on the
X          strength of the weapon.  This multiplier is displayed as `(*#)'.
X
X          Although you receive any magical bonuses an  unidentified  weapon
X          may possess when you wield it, those bonuses will not be added in
X          to the displayed values of to-hit and to-dam  on  your  character
X          sheet.   You must identify the weapon before the displayed values
X          reflect the real values used.
X
X
X
X
X
X
X
X
X
X
X          The Dungeons of Moria                                Page 30
X
X
X          Finally, some rare weapons have  special  abilities.   These  are
X          called  ego  weapons,  and  are feared by great and meek.  An ego
X          sword must be wielded to receive benefit of its abilities.
X
X          Special weapons are denoted by the following abbreviations:
X
X          DF - Defender.
X               A magical weapon that actually helps the wielder defend him-
X               self,  thus  increasing  his/her armor class, and protecting
X               him/her against damage from fire,  frost,  acid,  lightning,
X               and falls.  This weapon also will increase your stealth, let
X               you see invisible creatures, protect you  from  paralyzation
X               attacks, and help you regenerate hit points and mana faster.
X               As a result of the regerenation ability,  you  will  use  up
X               food faster than normal while wielding such a weapon.
X
X          FB - Frost Brand.
X               A magical weapon of ice that delivers  a  cold  critical  to
X               heat  based creatures.  It will inflict one and a half times
X               the normal damage when used against a heat based creature.
X
X          FT - Flame Tongue.
X               A magical weapon of flame that delivers a heat  critical  to
X               cold  based creatures.  It will inflict one and a half times
X               the normal damage when used against cold based  or  inflamm-
X               able creatures.
X
X          HA - Holy Avenger.
X               A Holy Avenger is one of the most powerful  of  weapons.   A
X               Holy  Avenger  will  increase  your  strength and your armor
X               class.  This weapon will do extra damage when  used  against
X               evil  and undead creatures, and will also give you the abil-
X               ity to see invisible creatures.
X
X          SD - Slay Dragon.
X               A Slay Dragon weapon is a special purpose weapon whose  sole
X               intent  is  to  destroy  dragon-kind.   Therefore, when used
X               against a dragon, the amount of damage done  is  four  times
X               the normal amount.
X
X          SE - Slay Evil.
X               A Slay Evil weapon is a special purpose  weapon  whose  sole
X               intent  is  to destroy all forms of evil.  When used against
X               an evil creature, either alive or undead,  the  damage  done
X               twice the normal amount.
X
X          SM - Slay Animal.
X               A Slay Animal weapon is a special purpose weapon whose  sole
X               intent is to destroy all the dangerous animals in the world.
X               An animal is any creature natural to the  world.   Therefore
X               an  orc  would not be an animal, but a giant snake would be.
X               This will inflict twice the normal  amount  of  damage  when
X               used against an animal.
X
X
X
X
X
X
X
X
X
X
X          The Dungeons of Moria                                Page 31
X
X
X          SU - Slay Undead.
X               A Slay Undead weapon is a special purpose weapon whose  sole
X               intent  is  to  destroy all forms of undead.  This weapon is
X               hated and feared by the intelligent  undead,  for  a  single
X               blow  from  this  weapon will inflict three times the normal
X               amount of damage.  This weapon also gives you the ability to
X               see  invisible creatures, which is especially useful against
X               undead, since many of them are normally invisible.
X
X
X          8.3.  Body and Shield Bashes
X
X          Weight is the primary factor in being able to bash something, but
X          strength plays a role too.  After bashing, a character may be off
X          balance for several rounds depending upon his dexterity.
X
X          Doors can be broken down by bashing them.  Once a door is  bashed
X          open, it is forever useless and cannot be closed.
X
X          Chests too may be bashed open, but be warned  that  the  careless
X          smashing  of  a  chest  often ruins the contents.  Bashing open a
X          chest will not disarm any traps it may contain,  but  does  allow
X          the strong and ignorant to see what is inside.
X
X          Finally, a creature may be bashed.   If  a  shield  is  currently
X          being  worn,  the  bash is a shield bash and will do more damage.
X          In either case, a bash may throw an opponent off  balance  for  a
X          number of rounds, allowing a player to get in a free hit or more.
X          If the player is thrown off balance, his opponent  may  get  free
X          hits on him.  This is a risky attack.
X
X
X          8.4.  Your Armor Class
X
X          Armor class is a number that describes the amount and the quality
X          of armor being worn.  Armor class will generally run from about 0
X          to 60, but could become negative  or  greater  than  60  in  rare
X          cases.
X
X          The larger your armor class, the more protective it is.  A  nega-
X          tive armor class would actually help get you hit.  Armor protects
X          you in three manners.  One, it makes you harder  to  be  hit  for
X          damage.   A  hit  for no damage is the same as a miss.  Two, good
X          armor will absorb some of the damage that  your  character  would
X          have  taken.  An armor class of 30 would absorb 15% of any damage
X          meant for him.  Three, acid damage is  reduced  by  wearing  body
X          armor.   It is obvious that a high armor class is a must for sur-
X          viving the lower levels of moria.
X
X          Each piece of armor has an armor class adjustment, and a  magical
X          bonus.   Armor  bought  in  town will have these values displayed
X          with their description.  Armor that is found within  the  dungeon
X          must  be  identified  before these values will be displayed.  All
X          armor always has the base armor class  displayed,  to  which  the
X
X
X
X
X
X
X
X
X
X          The Dungeons of Moria                                Page 32
X
X
X          bonus is added.  It is always possible to figure this out anyway,
X          by watching the effect it has on your displayed armor class.
X
X          Armor class values are always displayed between a set of brackets
X          as  `[#]' or `[#,+#]'.  The first value is the armor class of the
X          item.  The second number is the magical bonus of the  item  which
X          is only displayed if known, and will always have a sign preceding
X          the value.  There are a few cases where the form `[+#]' is  used,
X          meaning the object has no armor class, only a magical armor bonus
X          if worn.
X
X          Some pieces of armor will possess special  abilities  denoted  by
X          the following abbreviations:
X
X          RA - Resist Acid.
X               A character using such an object will take  only  one  third
X               normal  damage  from any acid thrown upon him.  In addition,
X               armor so enchanted will resist the acid's effects and not be
X               damaged by it.
X
X          RC - Resist Cold.
X               A character using a resist cold object will  take  only  one
X               third damage from frost and cold.
X
X          RF - Resist Fire.
X               A character using a resist fire object will  take  only  one
X               third damage from heat and fire.
X
X          RL - Resist Lightning.
X               A character using a resist lightning object will  take  only
X               one third damage from electrical attacks.
X
X          R - Resistance.
X               A character wearing armor with this ability will have resis-
X               tance  to  Acid,  Cold,  Fire, and Lightning as explained in
X               each part above.
X
X
X          8.5.  Crowns
X
X          Some crowns also have special magical abilities that improve your
X          chances in a battle.
X
X          Crown of Might
X               This is the great crown of the warriors.   The  wearer  will
X               have  an increased strength, dexterity, and constituion, and
X               will also be immune to any foe's attempt to slow or paralyze
X               him or her.
X
X          Crown of the Magi
X                This is the great crown of the wizards.   The  wearer  will
X               have  an  increased  intelligence,  and  will  also be given
X               resistance against fire, frost, acid, and lightning.
X
X
X
X
X
X
X
X
X
X
X          The Dungeons of Moria                                Page 33
X
X
X          Crown of Lordliness
X               This is the great crown of the  priests.   The  wearer  will
X               have an increased wisdom and charisma.
X
X          Crown of Seeing
X               This is the great crown of the rogues.  The wearer  will  be
X               able  to  see  even  invisible  creatures,  and will have an
X               increased ability to locate traps and secret doors.
X
X          Crown of Regeneration
X               This crown will help you regenerate hit points and mana more
X               quickly  than  normal,  allowing  you to fight longer before
X               needing to rest.  You will use of food  faster  than  normal
X               while   wearing  this  crown  because  of  the  regenerative
X               effects.
X
X          Crown of Beauty
X               This  crown  looks  impressive,  and  will   increase   your
X               charisma, but is otherwise not useful.
X
X
X          9.  Objects Found In The Dungeon
X
X          The mines are full of objects just waiting to be  picked  up  and
X          used.   How did they get there?  Well, the main source for useful
X          items are all the foolish adventurers  that  proceeded  into  the
X          dungeon  before  you.  They get killed, and the helpful creatures
X          scatter the various treasure throughout the dungeon.  Most cursed
X          items  are placed there by the joyful evil sorcerers, who enjoy a
X          good joke when it gets you killed.
X
X          You pick up objects by moving on top of them.  You can  carry  up
X          to 22 different items in your backpack while wearing and wielding
X          many others.  Although you are limited to 22 different items, you
X          may be carrying several items of each kind restricted only by the
X          amount of weight your character can carry.  Your weight limit  is
X          determined  by your strength.  Only one object may occupy a given
X          floor location, which may or may not also contain  one  creature.
X          Doors, traps, and staircases are considered objects for this pur-
X          pose.
X
X          If you try to carry more weight than your limit,  you  will  move
X          more  slowly  than  normal  until  you drop the extra weight.  If
X          picking up an object would take you over your weight limit,  then
X          you will be asked whether you really want to pick it up.  It is a
X          good idea to leave the object alone if you  are  fleeing  from  a
X          monster.
X
X          Many objects found within the dungeon have special  commands  for
X          their  use.   Wands  must  be Aimed, staves must be Used, scrolls
X          must be Read, and potions must be Quaffed.  In any case, you must
X          first  be  able  to  carry an object before you can use it.  Some
X          objects, such as chests, are very complex.  Chests contain  other
X          objects  and  may  be  trapped,  and/or locked.  Read the list of
X
X
X
X
X
X
X
X
X
X          The Dungeons of Moria                                Page 34
X
X
X          player commands carefully for a further understanding of chests.
X
X          One item in particular will be discussed  here.   The  scroll  of
X          "Word  of  Recall"  can be found within the dungeon, or bought at
X          the temple in town.  It acts in two manners, depending upon  your
X          current  location.   If read within the dungeon, it will teleport
X          you back to town.  If read in town, it  will  teleport  you  back
X          down to the deepest level of the dungeon one which your character
X          has previously been.  This makes the scroll very useful for  get-
X          ting  back  to  the  deeper levels of moria.  Once the scroll has
X          been read it takes a while for the spell to act, so don't  expect
X          it to save you in a crisis.
X
X          The game provides some automatic inscriptions to  help  you  keep
X          track  of  your possessions.  Wands and staves which are known to
X          be empty will be inscribed with "empty".  Objects which have been
X          tried  at  least  once,  but  haven't been identified yet will be
X          inscribed  with  "tried".   Cursed  objects  are  inscribed  with
X          "damned".   Also,  occasionally you will notice that something in
X          your inventory or equipment list seems to be magical.  High level
X          characters  are  much  more  likely to notice this than beginning
X          characters.  When you do notice this, the item in  question  will
X          be inscribed with "magik".
X
X          And lastly, a final warning: not all objects are what they  seem.
X          Skeletons  lying  peacefully about the dungeon have been known to
X          get up...
X
X
X          9.1.  Cursed Objects
X
X          Some objects, mainly armor and weapons, have had curses laid upon
X          them.   These  horrible  objects  will look like any other normal
X          item, but will detract from your character's stats  or  abilities
X          if  worn.   They will also be impossible to remove until a remove
X          curse is done.
X
X          If you wear or wield a cursed item,  you  will  immediately  feel
X          something wrong.  The item will also be inscribed "damned".
X
X
X          9.2.  Mining
X
X          Much of the treasure within the dungeon can be found only by min-
X          ing  it  out  of  the walls.  Many rich strikes exist within each
X          level, but must  be  found  and  mined.   Quartz  veins  are  the
X          richest,  yielding the most metals and gems, but magma veins will
X          have some hordes hidden within.
X
X          Mining is virtually impossible without a pick or  shovel.   Picks
X          and  shovels  have  an  additional  magical  ability expressed as
X          `(+#)'.  The higher the number, the better  the  magical  digging
X          ability of the tool.  A pick or shovel also has pluses to hit and
X          damage, and can be used as a weapon.
X
X
X
X
X
X
X
X
X
X          The Dungeons of Moria                                Page 35
X
X
X          When a vein of quartz or magma is located, the  character  should
X          wield  his  pick or shovel and begin digging out a section.  When
X          that section is removed, he should locate another section of  the
X          vein,  and  begin  the process again.  Since granite rock is much
X          harder to dig through, it is  much  faster  to  follow  the  vein
X          exactly  and  dig  around  the  granite.   There is an option for
X          highlighting magma and quartz.
X
X          If the character has a scroll or staff of treasure  location,  he
X          can  immediately  locate  all  strikes  of treasure within a vein
X          shown on the screen.  This makes mining much easier and more pro-
X          fitable.
X
X          It is sometimes possible to get a character  trapped  within  the
X          dungeon  by  using  various magical spells and items.  So it is a
X          very good idea to always carry some kind of  digging  tool,  even
X          when you are not planning on tunneling for treasure.
X
X
X          9.3.  Staircases, Secret Doors, Passages, and Rooms
X
X          Staircases are the manner in which you get deeper, or  climb  out
X          of  the  dungeon.  The symbols for the up and down staircases are
X          the same as the commands to use them.  A  `<'  represents  an  up
X          staircase  and  a `>' represents a down staircase.  You must move
X          your character over the staircase before you can use them.
X
X          Each level has at least one up staircase, and at least  two  down
X          staircases.   There are no exceptions to this rule.  You may have
X          trouble finding some well hidden secret doors, but the stairs are
X          there.
X
X          Many secret doors are used within  the  dungeon  to  confuse  and
X          demoralize  adventurers  foolish  enough to enter.  But with some
X          luck, and lots of concentration, you can find these secret doors.
X          Secret  doors  will  sometimes  hide  rooms or corridors, or even
X          entire sections of that level of  the  dungeon.   Sometimes  they
X          simply hide small empty closets or even dead ends.
X
X          Creatures in the dungeon will generally know and use these secret
X          doors.   If  they  leave  one  open, you will be able to go right
X          through it.  If they close it behind them you will have to search
X          for  the  catch first.  Once a secret door has been discovered by
X          you, it is drawn as a known door and no more  searching  will  be
X          required to use it.
X
X
X          10.  Winning The Game
X
X          Once your character has progressed into killing dragons with  but
X          a mean glance and snap of his fingers, he may be ready to take on
X          the Balrog.  The Balrog will appear on most  levels  after  level
X          49, so don't go down there until you are ready for him.
X
X
X
X
X
X
X
X
X
X
X          The Dungeons of Moria                                Page 36
X
X
X          The Balrog cannot be killed in some of the easier methods used on
X          normal  creatures.   Because  of  the  Balrog's  cunning, he will
X          teleport away to another level if a spell such as destruction  is
X          used  upon  him,  and  the  Balrog  cannot be polymorphed, slept,
X          charmed, or genocided.  Magical spells like coldball  are  effec-
X          tive  against him as are weapons, but he is difficult to kill and
X          if allowed to escape for a time can heal himself.
X
X          If you should actually survive the attempt of killing the Balrog,
X          you  will  receive the status of WINNER.  Since you have defeated
X          the toughest creature alive, your character is  ready  to  retire
X          and  cannot  be  saved.   When  you quit the game, your character
X          receives a surprise bonus score.
X
X
X          11.  Upon Death and Dying
X
X          If your character falls below 0 hit points, he has died and  can-
X          not  be  restored.   A  tombstone  showing information about your
X          character will be displayed.  You are also  permitted  to  get  a
X          record  of  your  character,  and all your equipment (identified)
X          either on the screen or in a file.
X
X          Your character will leave behind a reduced save file, which  con-
X          tains only the monster memory and your option choices.  It may be
X          restored, in which case the new character is generated exactly as
X          if  the file was not there, but the new player will find his mon-
X          ster memory containing all the experience of past incarnations.
X
X
X          12.  Wizards
X
X          There are rumors of moria Wizards which,  if  asked  nicely,  can
X          explain  details  of  the  moria  game  that  seem complicated to
X          beginners.
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
END_OF_FILE
if test 26116 -ne `wc -c <'doc/moria2.txt.2'`; then
    echo shar: \"'doc/moria2.txt.2'\" unpacked with wrong size!
fi
# end of 'doc/moria2.txt.2'
fi
if test -f 'source/spells.c.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/spells.c.2'\"
else
echo shar: Extracting \"'source/spells.c.2'\" \(28204 characters\)
sed "s/^X//" >'source/spells.c.2' <<'END_OF_FILE'
X    }
X  while (!flag);
X  return(confuse);
X}
X
X
X/* Sleep a creature.					-RAK-	*/
Xint sleep_monster(dir, y, x)
Xint dir, y, x;
X{
X  int flag, dist, sleep;
X  register cave_type *c_ptr;
X  register monster_type *m_ptr;
X  register creature_type *r_ptr;
X  vtype out_val, m_name;
X
X  sleep = FALSE;
X  flag = FALSE;
X  dist = 0;
X  do
X    {
X      (void) mmove(dir, &y, &x);
X      dist++;
X      c_ptr = &cave[y][x];
X      if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)
X	flag = TRUE;
X      else if (c_ptr->cptr > 1)
X	{
X	  m_ptr = &m_list[c_ptr->cptr];
X	  r_ptr = &c_list[m_ptr->mptr];
X	  flag = TRUE;
X	  monster_name (m_name, m_ptr, r_ptr);
X	  if ((randint(MAX_MONS_LEVEL) < r_ptr->level) ||
X	      (CD_NO_SLEEP & r_ptr->cdefense))
X	    {
X	      if (m_ptr->ml && (r_ptr->cdefense & CD_NO_SLEEP))
X		c_recall[m_ptr->mptr].r_cdefense |= CD_NO_SLEEP;
X	      (void) sprintf(out_val, "%s is unaffected.", m_name);
X	      msg_print(out_val);
X	    }
X	  else
X	    {
X	      m_ptr->csleep = 500;
X	      sleep = TRUE;
X	      (void) sprintf(out_val, "%s falls asleep.", m_name);
X	      msg_print(out_val);
X	    }
X	}
X    }
X  while (!flag);
X  return(sleep);
X}
X
X
X/* Turn stone to mud, delete wall.			-RAK-	*/
Xint wall_to_mud(dir, y, x)
Xint dir, y, x;
X{
X  int i, wall, dist;
X  bigvtype out_val, tmp_str;
X  register int flag;
X  register cave_type *c_ptr;
X  register monster_type *m_ptr;
X  register creature_type *r_ptr;
X  vtype m_name;
X
X  wall = FALSE;
X  flag = FALSE;
X  dist = 0;
X  do
X    {
X      (void) mmove(dir, &y, &x);
X      dist++;
X      c_ptr = &cave[y][x];
X      /* note, this ray can move through walls as it turns them to mud */
X      if (dist == OBJ_BOLT_RANGE)
X	flag = TRUE;
X      if ((c_ptr->fval >= MIN_CAVE_WALL) && (c_ptr->fval != BOUNDARY_WALL))
X	{
X	  flag = TRUE;
X	  (void) twall(y, x, 1, 0);
X	  if (test_light(y, x))
X	    {
X	      msg_print("The wall turns into mud.");
X	      wall = TRUE;
X	    }
X	}
X      else if ((c_ptr->tptr != 0) && (c_ptr->fval >= MIN_CLOSED_SPACE))
X	{
X	  flag = TRUE;
X	  if (panel_contains(y, x) && test_light(y, x))
X	    {
X	      objdes(tmp_str, &t_list[c_ptr->tptr], FALSE);
X	      (void) sprintf(out_val, "The %s turns into mud.", tmp_str);
X	      msg_print(out_val);
X	      wall = TRUE;
X	    }
X	  (void) delete_object(y, x);
X	}
X      if (c_ptr->cptr > 1)
X	{
X	  m_ptr = &m_list[c_ptr->cptr];
X	  r_ptr = &c_list[m_ptr->mptr];
X	  if (CD_STONE & r_ptr->cdefense)
X	    {
X	      monster_name (m_name, m_ptr, r_ptr);
X	      i = mon_take_hit((int)c_ptr->cptr, 100);
X	      /* Should get these messages even if the monster is not
X		 visible.  */
X	      if (i >= 0)
X		{
X		  c_recall[i].r_cdefense |= CD_STONE;
X		  (void) sprintf(out_val, "%s dissolves!", m_name);
X		  msg_print(out_val);
X		  prt_experience(); /* print msg before calling prt_exp */
X		}
X	      else
X		{
X		  c_recall[m_ptr->mptr].r_cdefense |= CD_STONE;
X		  (void) sprintf(out_val, "%s grunts in pain!",m_name);
X		  msg_print(out_val);
X		}
X	      flag = TRUE;
X	    }
X	}
X    }
X  while (!flag);
X  return(wall);
X}
X
X
X/* Destroy all traps and doors in a given direction	-RAK-	*/
Xint td_destroy2(dir, y, x)
Xint dir, y, x;
X{
X  register int destroy2, dist;
X  register cave_type *c_ptr;
X  register inven_type *t_ptr;
X
X  destroy2 = FALSE;
X  dist= 0;
X  do
X    {
X      (void) mmove(dir, &y, &x);
X      dist++;
X      c_ptr = &cave[y][x];
X      /* must move into first closed spot, as it might be a secret door */
X      if (c_ptr->tptr != 0)
X	{
X	  t_ptr = &t_list[c_ptr->tptr];
X	  if ((t_ptr->tval == TV_INVIS_TRAP) || (t_ptr->tval == TV_CLOSED_DOOR)
X	      || (t_ptr->tval == TV_VIS_TRAP) || (t_ptr->tval == TV_OPEN_DOOR)
X	      || (t_ptr->tval == TV_SECRET_DOOR))
X	    {
X	      if (delete_object(y, x))
X		{
X		  msg_print("There is a bright flash of light!");
X		  destroy2 = TRUE;
X		}
X	    }
X	  else if (t_ptr->tval == TV_CHEST)
X	    {
X	      msg_print("Click!");
X	      t_ptr->flags &= ~(CH_TRAPPED|CH_LOCKED);
X	      destroy2 = TRUE;
X	      t_ptr->name2 = SN_UNLOCKED;
X	      known2(t_ptr);
X	    }
X	}
X    }
X  while ((dist <= OBJ_BOLT_RANGE) || c_ptr->fval <= MAX_OPEN_SPACE);
X  return(destroy2);
X}
X
X
X/* Polymorph a monster					-RAK-	*/
X/* NOTE: cannot polymorph a winning creature (BALROG)		 */
Xint poly_monster(dir, y, x)
Xint dir, y, x;
X{
X  int dist, flag, poly;
X  register cave_type *c_ptr;
X  register creature_type *r_ptr;
X  register monster_type *m_ptr;
X  vtype out_val, m_name;
X
X  poly = FALSE;
X  flag = FALSE;
X  dist = 0;
X  do
X    {
X      (void) mmove(dir, &y, &x);
X      dist++;
X      c_ptr = &cave[y][x];
X      if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)
X	flag = TRUE;
X      else if (c_ptr->cptr > 1)
X	{
X	  m_ptr = &m_list[c_ptr->cptr];
X	  r_ptr = &c_list[m_ptr->mptr];
X	  if (randint(MAX_MONS_LEVEL) > r_ptr->level)
X	    {
X	      flag = TRUE;
X	      delete_monster((int)c_ptr->cptr);
X	      /* Place_monster() should always return TRUE here.  */
X	      poly = place_monster(y, x,
X				   randint(m_level[MAX_MONS_LEVEL]-m_level[0])
X				   - 1 + m_level[0], FALSE);
X	      /* don't test c_ptr->fm here, only pl/tl */
X	      if (poly && panel_contains(y, x) && (c_ptr->tl || c_ptr->pl))
X		poly = TRUE;
X	    }
X	  else
X	    {
X	      monster_name (m_name, m_ptr, r_ptr);
X	      (void) sprintf(out_val, "%s is unaffected.", m_name);
X	      msg_print(out_val);
X	    }
X	}
X    }
X  while (!flag);
X  return(poly);
X}
X
X
X/* Create a wall.					-RAK-	*/
Xint build_wall(dir, y, x)
Xint dir, y, x;
X{
X  register int i;
X  int build, damage, dist, flag;
X  register cave_type *c_ptr;
X  register monster_type *m_ptr;
X  register creature_type *r_ptr;
X  vtype m_name, out_val;
X#ifdef ATARIST_MWC
X  int32u holder;
X#endif
X
X  build = FALSE;
X  dist = 0;
X  flag = FALSE;
X  do
X    {
X      (void) mmove(dir, &y, &x);
X      dist++;
X      c_ptr = &cave[y][x];
X      if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)
X	flag = TRUE;
X      else
X	{
X	  if (c_ptr->tptr != 0)
X	    (void) delete_object(y, x);
X	  if (c_ptr->cptr > 1)
X	    {
X	      /* stop the wall building */
X	      flag = TRUE;
X	      m_ptr = &m_list[c_ptr->cptr];
X	      r_ptr = &c_list[m_ptr->mptr];
X
X#ifdef ATARIST_MWC
X	      if (!(r_ptr->cmove & (holder = CM_PHASE)))
X#else
X	      if (!(r_ptr->cmove & CM_PHASE))
X#endif
X		{
X		  /* monster does not move, can't escape the wall */
X		  if (r_ptr->cmove & CM_ATTACK_ONLY)
X		    damage = 3000; /* this will kill everything */
X		  else
X		    damage = damroll (4, 8);
X
X		  monster_name (m_name, m_ptr, r_ptr);
X		  (void) sprintf (out_val, "%s wails out in pain!", m_name);
X		  msg_print (out_val);
X		  i = mon_take_hit((int)c_ptr->cptr, damage);
X		  if (i >= 0)
X		    {
X		      (void) sprintf (out_val, "%s is embedded in the rock.",
X				      m_name);
X		      msg_print (out_val);
X		      prt_experience();
X		    }
X		}
X	      else if (r_ptr->cchar == 'E' || r_ptr->cchar == 'X')
X		{
X		  /* must be an earth elemental or an earth spirit, or a Xorn
X		     increase its hit points */
X		  m_ptr->hp += damroll(4, 8);
X		}
X	    }
X	  c_ptr->fval  = MAGMA_WALL;
X	  c_ptr->fm = FALSE;
X	  /* Permanently light this wall if it is lit by player's lamp.  */
X	  c_ptr->pl = (c_ptr->tl || c_ptr->pl);
X	  lite_spot(y, x);
X	  i++;
X	  build = TRUE;
X	}
X    }
X  while (!flag);
X  return(build);
X}
X
X
X/* Replicate a creature					-RAK-	*/
Xint clone_monster(dir, y, x)
Xint dir, y, x;
X{
X  register cave_type *c_ptr;
X  register int dist, flag;
X
X  dist = 0;
X  flag = FALSE;
X  do
X    {
X      (void) mmove(dir, &y, &x);
X      dist++;
X      c_ptr = &cave[y][x];
X      if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)
X	flag = TRUE;
X      else if (c_ptr->cptr > 1)
X	{
X	  m_list[c_ptr->cptr].csleep = 0;
X	  /* monptr of 0 is safe here, since can't reach here from creatures */
X	  return multiply_monster(y, x, (int)m_list[c_ptr->cptr].mptr, 0);
X	}
X    }
X  while (!flag);
X  return(FALSE);
X}
X
X
X/* Move the creature record to a new location		-RAK-	*/
Xvoid teleport_away(monptr, dis)
Xint monptr, dis;
X{
X  register int yn, xn, ctr;
X  register monster_type *m_ptr;
X
X  m_ptr = &m_list[monptr];
X  ctr = 0;
X  do
X    {
X      do
X	{
X	  yn = m_ptr->fy + (randint(2*dis+1) - (dis + 1));
X	  xn = m_ptr->fx + (randint(2*dis+1) - (dis + 1));
X	}
X      while (!in_bounds(yn, xn));
X      ctr++;
X      if (ctr > 9)
X	{
X	  ctr = 0;
X	  dis += 5;
X	}
X    }
X  while ((cave[yn][xn].fval >= MIN_CLOSED_SPACE) || (cave[yn][xn].cptr != 0));
X  move_rec((int)m_ptr->fy, (int)m_ptr->fx, yn, xn);
X  lite_spot((int)m_ptr->fy, (int)m_ptr->fx);
X  m_ptr->fy = yn;
X  m_ptr->fx = xn;
X  /* this is necessary, because the creature is not currently visible
X     in its new position */
X  m_ptr->ml = FALSE;
X  m_ptr->cdis = distance (char_row, char_col, yn, xn);
X  update_mon (monptr);
X}
X
X
X/* Teleport player to spell casting creature		-RAK-	*/
Xvoid teleport_to(ny, nx)
Xint ny, nx;
X{
X  int dis, ctr, y, x;
X  register int i, j;
X  register cave_type *c_ptr;
X
X  dis = 1;
X  ctr = 0;
X  do
X    {
X      y = ny + (randint(2*dis+1) - (dis + 1));
X      x = nx + (randint(2*dis+1) - (dis + 1));
X      ctr++;
X      if (ctr > 9)
X	{
X	  ctr = 0;
X	  dis++;
X	}
X    }
X  while (!in_bounds(y, x) || (cave[y][x].fval >= MIN_CLOSED_SPACE)
X	 || (cave[y][x].cptr >= 2));
X  move_rec(char_row, char_col, y, x);
X  for (i = char_row-1; i <= char_row+1; i++)
X    for (j = char_col-1; j <= char_col+1; j++)
X      {
X	c_ptr = &cave[i][j];
X	c_ptr->tl = FALSE;
X	lite_spot(i, j);
X      }
X  lite_spot(char_row, char_col);
X  char_row = y;
X  char_col = x;
X  check_view();
X  /* light creatures */
X  creatures(FALSE);
X}
X
X
X/* Teleport all creatures in a given direction away	-RAK-	*/
Xint teleport_monster(dir, y, x)
Xint dir, y, x;
X{
X  register int flag, result, dist;
X  register cave_type *c_ptr;
X
X  flag = FALSE;
X  result = FALSE;
X  dist = 0;
X  do
X    {
X      (void) mmove(dir, &y, &x);
X      dist++;
X      c_ptr = &cave[y][x];
X      if ((dist > OBJ_BOLT_RANGE) || c_ptr->fval >= MIN_CLOSED_SPACE)
X	flag = TRUE;
X      else if (c_ptr->cptr > 1)
X	{
X	  m_list[c_ptr->cptr].csleep = 0; /* wake it up */
X	  teleport_away((int)c_ptr->cptr, MAX_SIGHT);
X	  result = TRUE;
X	}
X    }
X  while (!flag);
X  return(result);
X}
X
X
X/* Delete all creatures within max_sight distance	-RAK-	*/
X/* NOTE : Winning creatures cannot be genocided			 */
Xint mass_genocide()
X{
X  register int i, result;
X  register monster_type *m_ptr;
X  register creature_type *r_ptr;
X#ifdef ATARIST_MWC
X  int32u holder;
X#endif
X
X  result = FALSE;
X  for (i = mfptr - 1; i >= MIN_MONIX; i--)
X    {
X      m_ptr = &m_list[i];
X      r_ptr = &c_list[m_ptr->mptr];
X#ifdef ATARIST_MWC
X      if ((m_ptr->cdis <= MAX_SIGHT) &&
X	  ((r_ptr->cmove & (holder = CM_WIN)) == 0))
X#else
X      if ((m_ptr->cdis <= MAX_SIGHT) && ((r_ptr->cmove & CM_WIN) == 0))
X#endif
X	{
X	  delete_monster(i);
X	  result = TRUE;
X	}
X    }
X  return(result);
X}
X
X/* Delete all creatures of a given type from level.	-RAK-	*/
X/* This does not keep creatures of type from appearing later.	 */
X/* NOTE : Winning creatures can not be genocided. */
Xint genocide()
X{
X  register int i, killed;
X  char typ;
X  register monster_type *m_ptr;
X  register creature_type *r_ptr;
X  vtype out_val;
X#ifdef ATARIST_MWC
X  int32u holder;
X#endif
X
X  killed = FALSE;
X  if (get_com("Which type of creature do you wish exterminated?", &typ))
X    for (i = mfptr - 1; i >= MIN_MONIX; i--)
X      {
X	m_ptr = &m_list[i];
X	r_ptr = &c_list[m_ptr->mptr];
X	if (typ == c_list[m_ptr->mptr].cchar)
X#ifdef ATARIST_MWC
X	  if ((r_ptr->cmove & (holder = CM_WIN)) == 0)
X#else
X	  if ((r_ptr->cmove & CM_WIN) == 0)
X#endif
X	    {
X	      delete_monster(i);
X	      killed = TRUE;
X	    }
X	  else
X	    {
X	      /* genocide is a powerful spell, so we will let the player
X		 know the names of the creatures he did not destroy,
X		 this message makes no sense otherwise */
X	      (void) sprintf(out_val, "The %s is unaffected.", r_ptr->name);
X	      msg_print(out_val);
X	    }
X      }
X  return(killed);
X}
X
X
X/* Change speed of any creature .			-RAK-	*/
X/* NOTE: cannot slow a winning creature (BALROG)		 */
Xint speed_monsters(spd)
Xint spd;
X{
X  register int i, speed;
X  register monster_type *m_ptr;
X  register creature_type *r_ptr;
X  vtype out_val, m_name;
X
X  speed = FALSE;
X  for (i = mfptr - 1; i >= MIN_MONIX; i--)
X    {
X      m_ptr = &m_list[i];
X      r_ptr = &c_list[m_ptr->mptr];
X      monster_name (m_name, m_ptr, r_ptr);
X
X      if ((m_ptr->cdis > MAX_SIGHT) ||
X	  !los(char_row, char_col, (int)m_ptr->fy, (int)m_ptr->fx))
X	/* do nothing */
X	;
X      else if (spd > 0)
X	{
X	  m_ptr->cspeed += spd;
X	  m_ptr->csleep = 0;
X	  if (m_ptr->ml)
X	    {
X	      speed = TRUE;
X	      (void) sprintf (out_val, "%s starts moving faster.", m_name);
X	      msg_print (out_val);
X	    }
X	}
X      else if (randint(MAX_MONS_LEVEL) > r_ptr->level)
X	{
X	  m_ptr->cspeed += spd;
X	  m_ptr->csleep = 0;
X	  if (m_ptr->ml)
X	    {
X	      (void) sprintf (out_val, "%s starts moving slower.", m_name);
X	      msg_print (out_val);
X	      speed = TRUE;
X	    }
X	}
X      else if (m_ptr->ml)
X	{
X	  m_ptr->csleep = 0;
X	  (void) sprintf(out_val, "%s is unaffected.", m_name);
X	  msg_print(out_val);
X	}
X    }
X  return(speed);
X}
X
X
X/* Sleep any creature .		-RAK-	*/
Xint sleep_monsters2()
X{
X  register int i, sleep;
X  register monster_type *m_ptr;
X  register creature_type *r_ptr;
X  vtype out_val, m_name;
X
X  sleep = FALSE;
X  for (i = mfptr - 1; i >= MIN_MONIX; i--)
X    {
X      m_ptr = &m_list[i];
X      r_ptr = &c_list[m_ptr->mptr];
X      monster_name (m_name, m_ptr, r_ptr);
X      if ((m_ptr->cdis > MAX_SIGHT) || 
X	  !los(char_row, char_col, (int)m_ptr->fy, (int)m_ptr->fx))
X	/* do nothing */
X	;
X      else if ((randint(MAX_MONS_LEVEL) < r_ptr->level) ||
X	  (CD_NO_SLEEP & r_ptr->cdefense))
X	{
X	  if (m_ptr->ml)
X	    {
X	      if (r_ptr->cdefense & CD_NO_SLEEP)
X		c_recall[m_ptr->mptr].r_cdefense |= CD_NO_SLEEP;
X	      (void) sprintf(out_val, "%s is unaffected.", m_name);
X	      msg_print(out_val);
X	    }
X	}
X      else
X	{
X	  m_ptr->csleep = 500;
X	  if (m_ptr->ml)
X	    {
X	      (void) sprintf(out_val, "%s falls asleep.", m_name);
X	      msg_print(out_val);
X	      sleep = TRUE;
X	    }
X	}
X    }
X  return(sleep);
X}
X
X
X/* Polymorph any creature that player can see.	-RAK-	*/
X/* NOTE: cannot polymorph a winning creature (BALROG)		 */
Xint mass_poly()
X{
X  register int i;
X  int y, x, mass;
X  register monster_type *m_ptr;
X  register creature_type *r_ptr;
X#ifdef ATARIST_MWC
X  int32u holder;
X#endif
X
X  mass = FALSE;
X  for (i = mfptr - 1; i >= MIN_MONIX; i--)
X    {
X      m_ptr = &m_list[i];
X      if (m_ptr->cdis <= MAX_SIGHT)
X	{
X	  r_ptr = &c_list[m_ptr->mptr];
X#ifdef ATARIST_MWC
X	  if ((r_ptr->cmove & (holder = CM_WIN)) == 0)
X#else
X	  if ((r_ptr->cmove & CM_WIN) == 0)
X#endif
X	    {
X	      y = m_ptr->fy;
X	      x = m_ptr->fx;
X	      delete_monster(i);
X	      /* Place_monster() should always return TRUE here.  */
X	      mass = place_monster(y, x,
X				   randint(m_level[MAX_MONS_LEVEL]-m_level[0])
X				   - 1 + m_level[0], FALSE);
X	    }
X	}
X    }
X  return(mass);
X}
X
X
X/* Display evil creatures on current panel		-RAK-	*/
Xint detect_evil()
X{
X  register int i, flag;
X  register monster_type *m_ptr;
X
X  flag = FALSE;
X  for (i = mfptr - 1; i >= MIN_MONIX; i--)
X    {
X      m_ptr = &m_list[i];
X      if (panel_contains((int)m_ptr->fy, (int)m_ptr->fx) &&
X	  (CD_EVIL & c_list[m_ptr->mptr].cdefense))
X	{
X	  m_ptr->ml = TRUE;
X	  /* works correctly even if hallucinating */
X	  print((char)c_list[m_ptr->mptr].cchar, (int)m_ptr->fy,
X		(int)m_ptr->fx);
X	  flag = TRUE;
X	}
X    }
X  if (flag)
X    {
X      msg_print("You sense the presence of evil!");
X      msg_print(CNIL);
X      /* must unlight every monster just lighted */
X      creatures(FALSE);
X    }
X  return(flag);
X}
X
X
X/* Change players hit points in some manner		-RAK-	*/
Xint hp_player(num)
Xint num;
X{
X  register int res;
X  register struct misc *m_ptr;
X
X  res = FALSE;
X  m_ptr = &py.misc;
X  if (m_ptr->chp < m_ptr->mhp)
X    {
X      m_ptr->chp += num;
X      if (m_ptr->chp > m_ptr->mhp)
X	{
X	  m_ptr->chp = m_ptr->mhp;
X	  m_ptr->chp_frac = 0;
X	}
X      prt_chp();
X
X      num = num / 5;
X      if (num < 3) {
X	if (num == 0) msg_print("You feel a little better.");
X	else	      msg_print("You feel better.");
X      } else {
X	if (num < 7) msg_print("You feel much better.");
X	else	     msg_print("You feel very good.");
X      }
X      res = TRUE;
X    }
X  return(res);
X}
X
X
X/* Cure players confusion				-RAK-	*/
Xint cure_confusion()
X{
X  register int cure;
X  register struct flags *f_ptr;
X
X  cure = FALSE;
X  f_ptr = &py.flags;
X  if (f_ptr->confused > 1)
X    {
X      f_ptr->confused = 1;
X      cure = TRUE;
X    }
X  return(cure);
X}
X
X
X/* Cure players blindness				-RAK-	*/
Xint cure_blindness()
X{
X  register int cure;
X  register struct flags *f_ptr;
X
X  cure = FALSE;
X  f_ptr = &py.flags;
X  if (f_ptr->blind > 1)
X    {
X      f_ptr->blind = 1;
X      cure = TRUE;
X    }
X  return(cure);
X}
X
X
X/* Cure poisoning					-RAK-	*/
Xint cure_poison()
X{
X  register int cure;
X  register struct flags *f_ptr;
X
X  cure = FALSE;
X  f_ptr = &py.flags;
X  if (f_ptr->poisoned > 1)
X    {
X      f_ptr->poisoned = 1;
X      cure = TRUE;
X    }
X  return(cure);
X}
X
X
X/* Cure the players fear				-RAK-	*/
Xint remove_fear()
X{
X  register int result;
X  register struct flags *f_ptr;
X
X  result = FALSE;
X  f_ptr = &py.flags;
X  if (f_ptr->afraid > 1)
X    {
X      f_ptr->afraid = 1;
X      result = TRUE;
X    }
X  return(result);
X}
X
X
X/* This is a fun one.  In a given block, pick some walls and	*/
X/* turn them into open spots.  Pick some open spots and turn	 */
X/* them into walls.  An "Earthquake" effect.	       -RAK-   */
Xvoid earthquake()
X{
X  register int i, j;
X  register cave_type *c_ptr;
X  register monster_type *m_ptr;
X  register creature_type *r_ptr;
X  int damage, tmp;
X  vtype out_val, m_name;
X#ifdef ATARIST_MWC
X  int32u holder;
X#endif
X
X  for (i = char_row-8; i <= char_row+8; i++)
X    for (j = char_col-8; j <= char_col+8; j++)
X      if (((i != char_row) || (j != char_col)) &&
X	  in_bounds(i, j) && (randint(8) == 1))
X	{
X	  c_ptr = &cave[i][j];
X	  if (c_ptr->tptr != 0)
X	    (void) delete_object(i, j);
X	  if (c_ptr->cptr > 1)
X	    {
X	      m_ptr = &m_list[c_ptr->cptr];
X	      r_ptr = &c_list[m_ptr->mptr];
X
X#ifdef ATARIST_MWC
X	      if (!(r_ptr->cmove & (holder = CM_PHASE)))
X#else
X	      if (!(r_ptr->cmove & CM_PHASE))
X#endif
X		{
X		  if(r_ptr->cmove & CM_ATTACK_ONLY)
X		    damage = 3000; /* this will kill everything */
X		  else
X		    damage = damroll (4, 8);
X
X		  monster_name (m_name, m_ptr, r_ptr);
X		  (void) sprintf (out_val, "%s wails out in pain!", m_name);
X		  msg_print (out_val);
X		  i = mon_take_hit((int)c_ptr->cptr, damage);
X		  if (i >= 0)
X		    {
X		      (void) sprintf (out_val, "%s is embedded in the rock.",
X				      m_name);
X		      msg_print (out_val);
X		      prt_experience();
X		    }
X		}
X	      else if (r_ptr->cchar == 'E' || r_ptr->cchar == 'X')
X		{
X		  /* must be an earth elemental or an earth spirit, or a Xorn
X		     increase its hit points */
X		  m_ptr->hp += damroll(4, 8);
X		}
X	    }
X
X	  if ((c_ptr->fval >= MIN_CAVE_WALL) && (c_ptr->fval != BOUNDARY_WALL))
X	    {
X	      c_ptr->fval  = CORR_FLOOR;
X	      c_ptr->pl = FALSE;
X	      c_ptr->fm = FALSE;
X	    }
X	  else if (c_ptr->fval <= MAX_CAVE_FLOOR)
X	    {
X	      tmp = randint(10);
X	      if (tmp < 6)
X		c_ptr->fval  = QUARTZ_WALL;
X	      else if (tmp < 9)
X		c_ptr->fval  = MAGMA_WALL;
X	      else
X		c_ptr->fval  = GRANITE_WALL;
X
X	      c_ptr->fm = FALSE;
X	    }
X	  lite_spot(i, j);
X	}
X}
X
X
X/* Evil creatures don't like this.		       -RAK-   */
Xint protect_evil()
X{
X  register int res;
X  register struct flags *f_ptr;
X
X  f_ptr = &py.flags;
X  if (f_ptr->protevil == 0)
X    res = TRUE;
X  else
X    res = FALSE;
X  f_ptr->protevil += randint(25) + 3*py.misc.lev;
X  return(res);
X}
X
X
X/* Create some high quality mush for the player.	-RAK-	*/
Xvoid create_food()
X{
X  register cave_type *c_ptr;
X
X  c_ptr = &cave[char_row][char_col];
X  if (c_ptr->tptr != 0)
X    {
X      /* take no action here, don't want to destroy object under player */
X      msg_print ("There is already an object under you.");
X      /* set free_turn_flag so that scroll/spell points won't be used */
X      free_turn_flag = TRUE;
X    }
X  else
X    {
X      place_object(char_row, char_col);
X      invcopy(&t_list[c_ptr->tptr], OBJ_MUSH);
X    }
X}
X
X
X/* Attempts to destroy a type of creature.  Success depends on	*/
X/* the creatures level VS. the player's level		 -RAK-	 */
Xint dispel_creature(cflag, damage)
Xint cflag;
Xint damage;
X{
X  register int i;
X  int k, dispel;
X  register monster_type *m_ptr;
X  register creature_type *r_ptr;
X  vtype out_val, m_name;
X
X  dispel = FALSE;
X  for (i = mfptr - 1; i >= MIN_MONIX; i--)
X    {
X      m_ptr = &m_list[i];
X      if ((m_ptr->cdis <= MAX_SIGHT) &&
X	  (cflag & c_list[m_ptr->mptr].cdefense) &&
X	  los(char_row, char_col, (int)m_ptr->fy, (int)m_ptr->fx))
X	{
X	  r_ptr = &c_list[m_ptr->mptr];
X	  c_recall[m_ptr->mptr].r_cdefense |= cflag;
X	  monster_name (m_name, m_ptr, r_ptr);
X	  k = mon_take_hit (i, randint(damage));
X	  /* Should get these messages even if the monster is not
X	     visible.  */
X	  if (k >= 0)
X	    (void) sprintf(out_val, "%s dissolves!", m_name);
X	  else
X	    (void) sprintf(out_val, "%s shudders.", m_name);
X	  msg_print(out_val);
X	  dispel = TRUE;
X	  if (k >= 0)
X	    prt_experience();
X	}
X    }
X  return(dispel);
X}
X
X
X/* Attempt to turn (confuse) undead creatures.	-RAK-	*/
Xint turn_undead()
X{
X  register int i, turn_und;
X  register monster_type *m_ptr;
X  register creature_type *r_ptr;
X  vtype out_val, m_name;
X
X  turn_und = FALSE;
X  for (i = mfptr - 1; i >= MIN_MONIX; i--)
X    {
X      m_ptr = &m_list[i];
X      r_ptr = &c_list[m_ptr->mptr];
X      if ((m_ptr->cdis <= MAX_SIGHT) &&
X	  (CD_UNDEAD & r_ptr->cdefense) &&
X	  (los(char_row, char_col, (int)m_ptr->fy, (int)m_ptr->fx)))
X	{
X	  monster_name (m_name, m_ptr, r_ptr);
X	  if (((py.misc.lev+1) > r_ptr->level) ||
X	      (randint(5) == 1))
X	    {
X	      if (m_ptr->ml)
X		{
X		  (void) sprintf(out_val, "%s runs frantically!", m_name);
X		  msg_print(out_val);
X		  turn_und = TRUE;
X		  c_recall[m_ptr->mptr].r_cdefense |= CD_UNDEAD;
X		}
X	      m_ptr->confused = TRUE;
X	    }
X	  else if (m_ptr->ml)
X	    {
X	      (void) sprintf(out_val, "%s is unaffected.", m_name);
X	      msg_print(out_val);
X	    }
X	}
X    }
X  return(turn_und);
X}
X
X
X/* Leave a glyph of warding. Creatures will not pass over! -RAK-*/
Xvoid warding_glyph()
X{
X  register int i;
X  register cave_type *c_ptr;
X
X  c_ptr = &cave[char_row][char_col];
X  if (c_ptr->tptr == 0)
X    {
X      i = popt();
X      c_ptr->tptr = i;
X      invcopy(&t_list[i], OBJ_SCARE_MON);
X    }
X}
X
X
X/* Lose a strength point.				-RAK-	*/
Xvoid lose_str()
X{
X  if (!py.flags.sustain_str)
X    {
X      (void) dec_stat (A_STR);
X      msg_print("You feel very sick.");
X    }
X  else
X    msg_print("You feel sick for a moment,  it passes.");
X}
X
X
X/* Lose an intelligence point.				-RAK-	*/
Xvoid lose_int()
X{
X  if (!py.flags.sustain_int)
X    {
X      (void) dec_stat(A_INT);
X      msg_print("You become very dizzy.");
X    }
X  else
X    msg_print("You become dizzy for a moment,  it passes.");
X}
X
X
X/* Lose a wisdom point.					-RAK-	*/
Xvoid lose_wis()
X{
X  if (!py.flags.sustain_wis)
X    {
X      (void) dec_stat(A_WIS);
X      msg_print("You feel very naive.");
X    }
X  else
X    msg_print("You feel naive for a moment,  it passes.");
X}
X
X
X/* Lose a dexterity point.				-RAK-	*/
Xvoid lose_dex()
X{
X  if (!py.flags.sustain_dex)
X    {
X      (void) dec_stat(A_DEX);
X      msg_print("You feel very sore.");
X    }
X  else
X    msg_print("You feel sore for a moment,  it passes.");
X}
X
X
X/* Lose a constitution point.				-RAK-	*/
Xvoid lose_con()
X{
X  if (!py.flags.sustain_con)
X    {
X      (void) dec_stat(A_CON);
X      msg_print("You feel very sick.");
X    }
X  else
X    msg_print("You feel sick for a moment,  it passes.");
X}
X
X
X/* Lose a charisma point.				-RAK-	*/
Xvoid lose_chr()
X{
X  if (!py.flags.sustain_chr)
X    {
X      (void) dec_stat(A_CHR);
X      msg_print("Your skin starts to itch.");
X    }
X  else
X    msg_print("Your skin starts to itch, but feels better now.");
X}
X
X
X/* Lose experience					-RAK-	*/
Xvoid lose_exp(amount)
Xint32 amount;
X{
X  register int i;
X  register struct misc *m_ptr;
X  register class_type *c_ptr;
X
X  m_ptr = &py.misc;
X  if (amount > m_ptr->exp)
X    m_ptr->exp = 0;
X  else
X    m_ptr->exp -= amount;
X  prt_experience();
X
X  i = 0;
X  while ((player_exp[i] * m_ptr->expfact / 100) <= m_ptr->exp)
X    i++;
X  /* increment i once more, because level 1 exp is stored in player_exp[0] */
X  i++;
X
X  if (m_ptr->lev != i)
X    {
X      m_ptr->lev = i;
X
X      calc_hitpoints();
X      c_ptr = &class[m_ptr->pclass];
X      if (c_ptr->spell == MAGE)
X	{
X	  calc_spells(A_INT);
X	  calc_mana(A_INT);
X	}
X      else if (c_ptr->spell == PRIEST)
X	{
X	  calc_spells(A_WIS);
X	  calc_mana(A_WIS);
X	}
X      prt_level();
X      prt_title();
X    }
X}
X
X
X/* Slow Poison						-RAK-	*/
Xint slow_poison()
X{
X  register int slow;
X  register struct flags *f_ptr;
X
X  slow = FALSE;
X  f_ptr = &py.flags;
X  if (f_ptr->poisoned > 0)
X    {
X      f_ptr->poisoned = f_ptr->poisoned / 2;
X      if (f_ptr->poisoned < 1)	f_ptr->poisoned = 1;
X      slow = TRUE;
X      msg_print("The effect of the poison has been reduced.");
X    }
X  return(slow);
X}
X
X
X/* Bless						-RAK-	*/
Xvoid bless(amount)
Xint amount;
X{
X  py.flags.blessed += amount;
X}
X
X
X/* Detect Invisible for period of time			-RAK-	*/
Xvoid detect_inv2(amount)
Xint amount;
X{
X  py.flags.detect_inv += amount;
X}
X
X
Xstatic void replace_spot(y, x, typ)
Xint y, x, typ;
X{
X  register cave_type *c_ptr;
X
X  c_ptr = &cave[y][x];
X  switch(typ)
X    {
X    case 1: case 2: case 3:
X      c_ptr->fval  = CORR_FLOOR;
X      break;
X    case 4: case 7: case 10:
X      c_ptr->fval  = GRANITE_WALL;
X      break;
X    case 5: case 8: case 11:
X      c_ptr->fval  = MAGMA_WALL;
X      break;
X    case 6: case 9: case 12:
X      c_ptr->fval  = QUARTZ_WALL;
X      break;
X    }
X  c_ptr->pl = FALSE;
X  c_ptr->fm = FALSE;
X  c_ptr->lr = FALSE;  /* this is no longer part of a room */
X  if (c_ptr->tptr != 0)
X    (void) delete_object(y, x);
X  if (c_ptr->cptr > 1)
X    delete_monster((int)c_ptr->cptr);
X}
X
X
X/* The spell of destruction.				-RAK-	*/
X/* NOTE : Winning creatures that are deleted will be considered	 */
X/*	  as teleporting to another level.  This will NOT win the*/
X/*	  game.						       */
Xvoid destroy_area(y, x)
Xregister int y, x;
X{
X  register int i, j, k;
X
X  if (dun_level > 0)
X    {
X      for (i = (y-15); i <= (y+15); i++)
X	for (j = (x-15); j <= (x+15); j++)
X	  if (in_bounds(i, j) && (cave[i][j].fval != BOUNDARY_WALL))
X	    {
X	      k = distance(i, j, y, x);
X	      if (k == 0) /* clear player's spot, but don't put wall there */
X		replace_spot(i, j, 1);
X	      else if (k < 13)
X		replace_spot(i, j, randint(6));
X	      else if (k < 16)
X		replace_spot(i, j, randint(9));
X	    }
X    }
X  msg_print("There is a searing blast of light!");
X  py.flags.blind += 10 + randint(10);
X}
X
X
X/* Enchants a plus onto an item.			-RAK-	*/
Xint enchant(plusses, limit)
Xint16 *plusses;
Xint16 limit; /* maximum bonus allowed; usually 10, but weapon's maximum damage
X		when enchanting melee weapons to damage */
X{
X  register int chance, res;
X  
X  if (limit <= 0) /* avoid randint(0) call */
X    return(FALSE);
X  chance = 0;
X  res = FALSE;
X  if (*plusses > 0)
X    {
X      chance = *plusses;
X      if (randint(100) == 1) /* very rarely allow enchantment over limit */
X	chance = randint(chance) - 1;
X    }
X  if (randint(limit) > chance)
X    {
X      *plusses += 1;
X      res = TRUE;
X    }
X  return(res);
X}
X
X
X/* Removes curses from items in inventory		-RAK-	*/
Xint remove_curse()
X{
X  register int i, result;
X  register inven_type *i_ptr;
X#ifdef ATARIST_MWC
X  int32u holder = TR_CURSED;
X#endif
X
X  result = FALSE;
X  for (i = INVEN_WIELD; i <= INVEN_OUTER; i++)
X    {
X      i_ptr = &inventory[i];
X#ifdef ATARIST_MWC
X      if (holder & i_ptr->flags)
X#else
X      if (TR_CURSED & i_ptr->flags)
X#endif
X	{
X#ifdef ATARIST_MWC
X	  i_ptr->flags &= ~holder;
X#else
X	  i_ptr->flags &= ~TR_CURSED;
X#endif
X	  calc_bonuses();
X	  result = TRUE;
X	}
X    }
X  return(result);
X}
X
X
X/* Restores any drained experience			-RAK-	*/
Xint restore_level()
X{
X  register int restore;
X  register struct misc *m_ptr;
X
X  restore = FALSE;
X  m_ptr = &py.misc;
X  if (m_ptr->max_exp > m_ptr->exp)
X    {
X      restore = TRUE;
X      msg_print("You feel your life energies returning.");
X      /* this while loop is not redundant, ptr_exp may reduce the exp level */
X      while (m_ptr->exp < m_ptr->max_exp)
X	{
X	  m_ptr->exp = m_ptr->max_exp;
X	  prt_experience();
X	}
X    }
X  return(restore);
X}
END_OF_FILE
if test 28204 -ne `wc -c <'source/spells.c.2'`; then
    echo shar: \"'source/spells.c.2'\" unpacked with wrong size!
fi
# end of 'source/spells.c.2'
fi
echo shar: End of archive 25 \(of 39\).
cp /dev/null ark25isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
