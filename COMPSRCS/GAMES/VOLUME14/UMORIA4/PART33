Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i065:  umoria4 - single player dungeon simulation (ver. 5.5), Part33/39
Message-ID: <3429@master.CNA.TEK.COM>
Date: 22 Aug 92 22:14:59 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2070
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 65
Archive-name: umoria4/Part33
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 33 (of 39)."
# Contents:  doc/ERRORS ibmpc/tcio.c mac/MakeFile.hqx mac/miscrsrc.hqx
#   mac/scrnmgr/ScrnMgr.r source/potions.c unix/unix.c
# Wrapped by billr@saab on Thu Aug 20 09:11:35 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/ERRORS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/ERRORS'\"
else
echo shar: Extracting \"'doc/ERRORS'\" \(746 characters\)
sed "s/^X//" >'doc/ERRORS' <<'END_OF_FILE'
Xmoria.ms should:
X
Xthe backslashes in the direction table don't show up in the output for
Xsome reason
X
Xexplain non obvious spells/prayers, many of the priest spells are confusing,
Xreally should have a general section on spells explaining the 'G' command,
Xhow int/wis and level affects number of spells/prayers, how area effect
Xspells work, centering before casting an area effect spell is very useful
Xand perhaps other stuff about spells/magic
X
Xexplain the special inventory/equipment mode?
X
Xexplain how misc abilities depend on level, give table of class versus
Xability showing the relative gain per level values
X
Xmention too-heavy weapons?
X
Xsays nothing about levels and EXP
Xshould mention that level 40 is the highest level that can be reached
END_OF_FILE
if test 746 -ne `wc -c <'doc/ERRORS'`; then
    echo shar: \"'doc/ERRORS'\" unpacked with wrong size!
fi
# end of 'doc/ERRORS'
fi
if test -f 'ibmpc/tcio.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ibmpc/tcio.c'\"
else
echo shar: Extracting \"'ibmpc/tcio.c'\" \(8922 characters\)
sed "s/^X//" >'ibmpc/tcio.c' <<'END_OF_FILE'
X/* ibmpc/tcio.c: terminal I/O code for Turbo C
X
X   Copyright (c) 1989-92 James E. Wilson, Eric Vaitl
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X/* This I/O module doesn't need PCcurses.  You may also need to make some
X   changes to ms_misc.c.  */
X
X#include <alloc.h>  /* malloc() */
X#include <ctype.h>
X#include <dos.h>
X#include <stdlib.h>  /* getenv() */
X#include <stdio.h> /* putch */
X#include <process.h> /* spawnl() */
X#include <conio.h> /* window(), gotoxy() */
X
X#ifdef __TURBOC__
X#include	<string.h>
X#endif /* __TURBOC__ */
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#define MSG_LEN  73
X#define LINES 25
X#define COLS 80
X
Xstatic void *savescr; /* pointer to a saved screen */
X
Xvoid init_curses(void){
X  if((savescr=malloc(LINES*COLS*2))==NULL){
X    puts("Out of memory in init_curses()");
X    exit(1);
X  }
X  clrscr();
X  msdos_raw();
X}
X
X
Xint get_string(char *in_str,int row,int column,int slen)
X{
X  register int start_col, end_col, i;
X  char *p;
X  int flag, aborted;
X
X  aborted = FALSE;
X  flag  = FALSE;
X  gotoxy(column+1,row+1);
X  for (i = slen; i > 0; i--)
X    putch(' ');
X  gotoxy(column+1,row+1);
X  start_col = column;
X  end_col = column + slen - 1;
X  if (end_col > 79)
X    {
X      slen = 80 - column;
X      end_col = 79;
X  }
X  p = in_str;
X  do
X    {
X      i = inkey();
X      switch(i)
X        {
X          case ESCAPE:
X          aborted = TRUE;
X          break;
X        case CTRL('J'): case CTRL('M'):
X          flag  = TRUE;
X          break;
X        case DELETE: case CTRL('H'):
X          if (column > start_col)
X            {
X              column--;
X              put_buffer(" ", row, column);
X              move_cursor(row, column);
X              *--p = '\0';
X          }
X          break;
X        default:
X          if (!isprint(i) || column > end_col)
X            bell();
X          else
X            {
X              gotoxy(column+1,row+1);
X              putch((char) i);
X              *p++ = i;
X              column++;
X          }
X          break;
X      }
X  }
X  while ((!flag) && (!aborted));
X  if (aborted)
X    return(FALSE);
X  /* Remove trailing blanks     */
X  while (p > in_str && p[-1] == ' ')
X    p--;
X  *p = '\0';
X  return(TRUE);
X}
X
Xvoid put_buffer(char *out_str,int row,int col){
X  vtype tmp_str;
X  if (col>79) col=79;
X  strncpy(tmp_str,out_str,79-col);
X  tmp_str[79-col]='\0';
X  gotoxy(col+1,row+1);
X  cputs(tmp_str);
X}
X
Xvoid put_qio(void){
X/* nothing to do */
X}
X
Xvoid restore_term(void){
X  fflush(stdout);
X  clear_screen();
X  msdos_noraw();
X}
X
Xvoid shell_out(void){
X  char *comspec;
X#ifndef __TURBOC__
X  char key;
X  int val;
X  char *str;
X#endif /* __TURBOC__ */
X  save_screen();
X  clear_screen();
X  puts("[Entering DOS shell, type exit to return to game.]");
X  msdos_noraw();
X  ignore_signals();
X  if((comspec=getenv("COMSPEC")) ==NULL ||
X    spawnl(P_WAIT,comspec,comspec,(char *)NULL)<0){
X    puts("Sorry, there seems to be a problem with shell_out()");
X    printf("comspec = %s\n",comspec);
X    flush();
X    puts("Hit a key to continue");
X    while(!kbhit())
X      ;
X  }
X  restore_signals();
X  restore_screen();
X}
X
Xvoid save_screen(void){
X  gettext(1,1,COLS,LINES,savescr);
X}
X
Xvoid restore_screen(void){
X  puttext(1,1,COLS,LINES,savescr);
X}
X
Xvoid clear_screen(void){
X  window(1,1,COLS,LINES);
X/*
XI think later I might want to define seperate windows, so the above line
Xis definsive code.
X*/
X  clrscr();
X}
X
Xvoid clear_from(int row){
X  window(1,row+1,COLS,LINES);
X  clrscr();
X  window(1,1,COLS,LINES);
X}
X
Xvoid flush(void){
X  while(kbhit())
X    getch();
X}
X
Xvoid erase_line(int row, int col){
X  if(row==MSG_LINE&&msg_flag)
X    msg_print(NULL);
X  gotoxy(col+1,row+1);
X  clreol();
X}
X
Xchar inkey(void){
X  int i;
X
X  command_count=0;
X  while(TRUE){
X    i=msdos_getch();
X    if(i==EOF){
X      eof_flag++;
X      msg_flag=FALSE;
X      if(!character_generated||character_saved) exit_game();
X      disturb(1,0);
X      if(eof_flag>100){
X        panic_save=1;
X        strcpy(died_from,"(end of input: panic saved)");
X        if(!save_char()){
X          strcpy(died_from,"panic: unexpected eof");
X          death=TRUE;
X        }
X        exit_game();
X      }
X    return ESCAPE;
X  }
X  if(i!=CTRL('R'))
X    return (char) i;
X  msdos_raw();
X    break;
X  }
X  return (CTRL('R'));
X}
X
Xvoid print(char ch, int row, int col){
X  row -= panel_row_prt;
X  col-=panel_col_prt;
X  gotoxy(col+1,row+1);
X  putchar((int)ch);
X}
X
Xvoid move_cursor_relative(int row, int col){
X  row-=panel_row_prt;
X  col-=panel_col_prt;
X  gotoxy(col+1,row+1);
X}
X
Xvoid count_msg_print(char *p){
X  int i;
X  i=command_count;
X  msg_print(p);
X  command_count=i;
X}
X
Xvoid prt(char* str_buff,int row, int col){
X  if (row==MSG_LINE&&msg_flag)
X    msg_print(NULL);
X  gotoxy(col+1,row+1);
X  clreol();
X  put_buffer(str_buff,row,col);
X}
X
Xvoid move_cursor(int row,int col){
X  gotoxy(col+1,row+1);
X}
X
Xvoid msg_print(char* str_buff){
X  register int old_len;
X  char in_char;
X  if(msg_flag){
X    old_len=strlen(old_msg[last_msg])+1;
X    if (old_len>MSG_LEN)
X      old_len=MSG_LEN;
X    put_buffer("-more-",MSG_LINE, old_len);
X    wait_for_more=1;
X    do{
X      in_char=inkey();
X    }while((in_char!=' ')&&(in_char!=ESCAPE)&&(in_char!='\n')&&
X	   (in_char!='\r'));
X    wait_for_more=0;
X  }
X  gotoxy(1,MSG_LINE+1);
X  clreol();
X  if(str_buff){
X    put_buffer(str_buff,MSG_LINE,0);
X    command_count=0;
X    if(++last_msg>=MAX_SAVE_MSG) last_msg=0;
X    strncpy(old_msg[last_msg],str_buff,VTYPESIZ);
X    old_msg[last_msg][VTYPESIZ-1]='\0';
X    msg_flag=TRUE;
X  }else
X    msg_flag=FALSE;
X}
X
Xint get_check(char*prompt){
X  int res;
X  prt(prompt,0,0);
X  if(wherex()>MSG_LEN +1) gotoxy(74,1);
X  cputs(" [y/n]");
X  do{
X    res=inkey();
X  }while(res==' ');
X  erase_line(0,0);
X  if(res=='Y'||res=='y')
X    return(TRUE);
X  else
X    return(FALSE);
X}
X
Xint get_com(char *prompt,char *command){
X  int res;
X  if(prompt)
X    prt(prompt,0,0);
X  *command=inkey();
X  if(*command==ESCAPE)
X    res=FALSE;
X  else
X    res=TRUE;
X  erase_line(MSG_LINE,0);
X  return(res);
X}
Xvoid bell(void){
X  if (! sound_beep_flag)
X    return;
X
X  putchar('\007');
X}
X
X/* the rest is just modified -ev- */
X
X/* definitions used by screen_map() */
X/* index into border character array */
X#define TL 0    /* top left */
X#define TR 1
X#define BL 2
X#define BR 3
X#define HE 4    /* horizontal edge */
X#define VE 5
X
X/* character set to use */
X#   define CH(x)        (screen_border[1][x])
X
X  /* Display highest priority object in the RATIO by RATIO area */
X#define RATIO 3
X
Xvoid screen_map()
X{
X    register int  i, j;
X  static int8u screen_border[2][6] = {
X      {'+', '+', '+', '+', '-', '|'},     /* normal chars */
X    {201, 187, 200, 188, 205, 186}      /* graphics chars */
X};
X  int8u map[MAX_WIDTH / RATIO + 1];
X  int8u tmp;
X  int priority[256];
X  int row, orow, col, myrow, mycol = 0;
X  char prntscrnbuf[80];
X
X  for (i = 0; i < 256; i++)
X    priority[i] = 0;
X  priority['<'] = 5;
X  priority['>'] = 5;
X  priority['@'] = 10;
X  priority[wallsym] = -5;
X  priority[floorsym] = -10;
X  priority['\''] = -3;
X  priority[' '] = -15;
X
X  save_screen();
X  clear_screen();
X  gotoxy(1,1);
X  putch(CH(TL));
X  for (i = 0; i < MAX_WIDTH / RATIO; i++)
X    putch(CH(HE));
X  putch(CH(TR));
X  orow = -1;
X  map[MAX_WIDTH / RATIO] = '\0';
X  for (i = 0; i < MAX_HEIGHT; i++)
X    {
X        row = i / RATIO;
X      if (row != orow)
X        {
X            if (orow >= 0)
X            {
X               sprintf(prntscrnbuf,"%c%s%c",CH(VE), map, CH(VE));
X               gotoxy(1,orow+2);
X               cputs(prntscrnbuf);
X          }
X          for (j = 0; j < MAX_WIDTH / RATIO; j++)
X            map[j] = ' ';
X          orow = row;
X      }
X      for (j = 0; j < MAX_WIDTH; j++)
X        {
X            col = j / RATIO;
X          tmp = loc_symbol(i, j);
X          if (priority[map[col]] < priority[tmp])
X            map[col] = tmp;
X          if (map[col] == '@')
X            {
X                mycol = col + 1; /* account for border */
X              myrow = row + 1;
X          }
X      }
X  }
X  if (orow >= 0)
X    {
X      sprintf(prntscrnbuf,"%c%s%c",CH(VE), map, CH(VE));
X      gotoxy(1,orow+2);
X      cputs(prntscrnbuf);
X  }
X  gotoxy(1,orow+3);
X  putch(CH(BL));
X  for (i = 0; i < MAX_WIDTH / RATIO; i++)
X    putch(CH(HE));
X  putch(CH(BR));
X  gotoxy(24,24);
X  cputs("Hit any key to continue");
X  if (mycol > 0)
X    gotoxy(mycol+1, myrow+1);
X  inkey();
X  restore_screen();
X}
X
Xvoid pause_exit(int prt_line, int delay)
X{
X    char dummy;
X
X#ifdef __TURBOC__
X  /* Otherwise, TURBO C complains that delay is never used.  */
X  dummy = (char) delay;
X#endif
X  prt("[Press any key to continue, or Q to exit.]", prt_line, 10);
X  dummy = inkey();
X  if (dummy == 'Q')
X    {
X      erase_line(prt_line, 0);
X      exit_game();
X  }
X  erase_line(prt_line, 0);
X}
X
Xvoid pause_line(int prt_line)
X{
X  prt("[Press any key to continue.]", prt_line, 23);
X  (void) inkey();
X  erase_line(prt_line, 0);
X}
X
END_OF_FILE
if test 8922 -ne `wc -c <'ibmpc/tcio.c'`; then
    echo shar: \"'ibmpc/tcio.c'\" unpacked with wrong size!
fi
# end of 'ibmpc/tcio.c'
fi
if test -f 'mac/MakeFile.hqx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/MakeFile.hqx'\"
else
echo shar: Extracting \"'mac/MakeFile.hqx'\" \(8517 characters\)
sed "s/^X//" >'mac/MakeFile.hqx' <<'END_OF_FILE'
X(This file must be converted with BinHex 4.0)
X:#%eKDf9'D@aP!&4&@&408&-J!3!!!"E0!!!"IRGE3dp`G'P[ER-J23N*,@)b)#e
Xc)(Y%C@CKG@adI5!YC#"038-J,@eLCb"[EL!YFhPY)'pZ$3e5Fh*M6h"dD@pZFb!
Xp#5eL-L!YE5!YC#"58e*$)#eN)%e"3`d0,Q-ZE`N*#F3*,Q-0#AY$I5"l3dp`G'P
X[ER0p)(Y%CA"%DA*pHd4PCQ&eE(4p,Q-J,@mJHe4KFQG%DA*pHd4PCQ&eE(4p,Q-
XZE`d*$5jbFh*M,Qm*#3R%#5jM$3Pl3hdJHe*cFQ02F(4TEfjcI5"l4'9`4'PbIAY
X%C@CKG@adI5jM)#e[)(Y8BA*R4'PbIAY%C@CKG@adI5jbFh*M,Qm0#3e2BQTPBh4
Xc)$d*#@eKBbjM,QmJYJd*#3N*E@&MBfpZCLjM,QmJYJd*#3N*E@&MD'9XF#jM,Qm
XJYJd*#3N*E@&MFf0[FQ8ZBbj[),B0#3N*#@eKBh*cFQ-ZBbj[),B0#3N*#@eKD@i
XZBbj[),B0#3N*#@0bC@&dC5jM,QmJYJd*#3N*Bh*PBA4eFQ8ZBbj[),B0#3N*#@4
XPBA4S,Q-ZEb#f$3N*#3PNCA0M,Q-ZEb#f$3N*#3PNG@jRC@pZ,Q-ZEb#f$3N*#3P
XPBA3ZBbj[),B0#3N*#@CTE'9c,Q-ZEb#f$3N*#3PRC@jPFQ&dC5jM,QmJYJd*#3N
X*D'9XF#jM,QmJYJd*#3N*E@&MD@mZBbj[),B0#3N*#@eKCfPM,Q-ZEb#f$3N*#3P
XYDA0M-5jM,QmJYJd*#3N*E@PcBc)ZBbj[),B0#3N*#@e[ER0dCA*c,Q-ZEb#f$3N
X*#3PYEh*TB6%ZBbj[),B0#3N*#@e[FQPK-LjM,QmJYJd*#3N*F'aKH@9b,Q-ZEb#
Xf$3N*#3P`Eh4TEfjc,Q-ZEb#f$3N*#3P`FQ&jCA)ZBbj[),B0#3N*#A*PBf&XE#j
XM,QmJYJd*#3N*FQjN,Q-ZEb#f$3N*#3PcBACP,Q-ZEb#f$3N*#3PcBh*[E'ac,Q-
XZEb#f$3N*#3PcCA4c,Q-ZEb#f$3N*#3PcD@GZB@ac,Q-ZEb#f$3N*#3PcF'9XE(-
XZBbj[),B0#3N*#A0dB@CQFbjM,QmJYJd*#3N*Fh4[FQ8a,Q-ZEb#f$3N*#3PcG'p
XbC6)ZBbj[),B0#3N*#A4KBQaPFbjM,QmJYJd*#3N*G(*PBA0eFQ8ZBbj[),B0#3N
X*#A9ZC'9Q,Q-ZEb#f$3N*#3PfBA*TB@*XC5jM,QmJYJd*#3N*Gf&ZC(-ZBbj[),B
X0#3N*#AGTHQ&bC#jM,Qm0#3N*#3e5Fh*MFb!p#3N*E@&MC'&dB5jbFh*M,QmJYJd
X*#3N*E@&MFR0bBbjbFh*M,QmJYJd*#3N*E@pZFh4PFR-ZFR0bBbj[),B0#3N*#A"
XXBAPPFLjbFh*M,QmJYJd*#3N*G'&LE'9c,R*cFQ-ZEb#f$3N*#3PdFQ9KFh9bC5j
XbFh*M,QmJYJd*#3N*GQ&bD@&LE'8ZFR0bBbj[$3N*#3N09'9iG(-J23N*#@jPGh-
XJYJd*#3N*Eh*TCf0YC(-ZD'a`),B0#3N*#@phDATME@4c,QKXF##f$3N*#3PbEfG
XXBfeNFbjSE(!JYJd*#3N*FRGTHQ0YC(-ZD'a`),B0#3N*#ACPFR0TEfiZD'a`),B
X0#3N*#AGPE'0[E@8ZD'a`$3N*#3N0)b"+9cSJ3e*eER4TE@8ZEb"KEQ3J3dPZG'9
XbCQ&MC5j[)'4PE'9dC@3JBA-J55"hBA-JG'pXC#"dD'&d)(4SCANJBA*P)'pLFfp
XXCA4P$8e[FQPK#3N*a-3*He*cFQ0cI3d*6'PZDb!YE@&`)#eh)#ed)#G08&08*b!
XYBb!R69"6)#Hf$3N*,A0c)$)`-$!`-#!YFh*d),B0#3Pl8R0bBh0p),B0#3NLHd0
X-D@*bBA*TCA0p)N4eEA"5CA-ZEb#f$3N*)RY-D@*bBA*TCA0p)R0dG@*c,QmJYJd
X*#5*l6'PLFQ&bD@9cI5*5G@jdD@eP,QmJYJd*#5*l6'PLFQ&bD@9cI5**ER4PFQC
XKBf8ZEb#f$3N*)RY$6'PLFQ&bD@9cI5*6G'4$6'PL,QmJYJd*#5*l3daTBR*KFQP
XPFhdL3e0"6N9-D@)ZEb#f$3N*)RY$6'PLFQ&bD@9cI5*0BA4S,QmJYJd*#5*l6'P
XLFQ&bD@9cI5*8EfpX6'PLFbj[),B0#3Nq)'eKBf4KG'%ZE@&`$3P-D@jV,NpeG#"
X0Eh*TB3d*4'9XCA4P)%aTEQXZ6h9d$3e0Eh*TB5!*#3R%a#!*HdpLDQ9MG(0p$3P
X-D@jV)#eYBA!J,AFJ,A3J*d&38%`R)#eM)#G08NP"*lB0#3NYH#"YEh*TB5jiFQ9
XQ),B0#3NYFhPY)'pZ),B0#3NYEb"0Eh*TB5#f$3N*,A*K)$de-L#f$3N*,A0R)%e
XKD@ipE@&M,'eKD@iXFQjN,(0TCfjKE(-XG@jNC@BXE@&MFR0bBb#f$3N*,A*K)%e
XKD@ip06)JYJd*#5ecCb"*6ceYB@0TEb#f$3N*,A*K)%P2268b),B0#3NYFfFJ3A"
X`6@9ZG6eYB@0SC@a`,'eKBf0[EQBXE@&MFf0[FQ8JYJd*#5ebB5""F("0C@je26-
Xb),B0#3NYFfFJ3h*PBA4P2@0bC@&dC5#f$3N*,A*K)%0bC@&dC6dc-L#f$3N*,A0
XR)%0bC@&dGA*P2@0bC@&dGA*P),B0#3NYFQ%J3h*PBA4eFQ8p-c)JYJd*#5ecCb"
X%C@&dD$eNC@&dD##f$3N*,A*K)%4PBA4S26-b),B0#3NYFfFJ4(9ZCf9[EMeNG@j
XRC@pZ),B0#3NYFQ%J4(9ZCf9[EMde-L#f$3N*,A0R)%9KG$ePBA3JYJd*#5ebB5"
X&BA3p-c)JYJd*#5ecCb"'D@aPFceQD@aPFb#f$3N*,A*K)%CTE'9c26-b),B0#3N
XYFfFJ4f9ZCA*KG'8pCf9ZCA*KG'8JYJd*#5ebB5"(C@jPFQ&dC6dc-L#f$3N*,A0
XR)%KPE(!pD'9XF##f$3N*,A*K)%KPE(!p-c)JYJd*#5ecCb"0B@GTBceYB@GTBb#
Xf$3N*,A*K)%eKCfPM26-b),B0#3NYFfFJ6@PcBc%pE@PcBc%XC'9cBbacCA4c),B
X0#3NYFQ%J6@PcBc%p06)JYJd*#5ecCb"0DA0M-MeYDA0M-L#f$3N*,A*K)%eTFf-
Xb268b),B0#3NYFfFJ6@pbD@%a2@e[FQPK-5#f$3N*,A*K)%e[FQPK-6de-L#f$3N
X*,A0R)%e[FQPK-MeYEh*TB6)JYJd*#5ebB5"0Eh*TB6)p06)JYJd*#5ecCb"3FQ&
XjCA)pF(*KH@9b),B0#3NYFQ%J8(*KH@9b26-b),B0#3NYFfFJ8'pdD@pZFce`Eh4
XTEfjc),B0#3NYFQ%J8'pdD@pZFcdc-L#f$3N*,A0R)&*PBf&XE$ebC@0KE'`JYJd
X*#5ebB5"5C@0KE'`p-c)JYJd*#5ecCb"6BACP2A0KGQ8JYJd*#5ebB5"6BACP26-
Xb),B0#3NYFfFJ8f0bEfaXFcecBh*[E'ac),B0#3NYFQ%J8f0bEfaXFcdc-L#f$3N
X*,A0R)&0`C@aXFcecF'9XE(-JYJd*#5ebB5"6F'9XE(-p06)JYJd*#5ecCb"6G'&
XQCR-pFh4KCQCc),B0#3NYFQ%J8h4KCQCc26-b),B0#3NYFfFJ8h4[FQ8pFh4[FQ8
Xa,(0dEh*P-L#f$3N*,A*K)&0dEh*P26-b),B0#3NYFfFJ9f&ZC(-pGf&ZC(-JYJd
X*#5ebB5"AB@jNFcdc-L#f$3N*,A0R)&GTHQ&bC$ehDATKFQ3JYJd*#5ebB5"ADAT
XKFQ3p-c)JYJd*#AY2BQTPBh4cI5#f$3N*)RY$6'PLFQ&bD@9cI5*6Bh*Z6@Gb,Qm
XJYJd*#5*l3daTBR*KFQPPFhdL4(9YF&*PFbj[),B0#3NLHd0-D@*bBA*TCA0p)N0
X5G@jdD@eP,QmJYJd*#5*l6'PLFQ&bD@9cI5**ER4PFQCKBf8ZEb#f$3N*)RY$6'P
XLFQ&bD@9cI5*6G'4$6'PL,QmJYJd*#5*l3daTBR*KFQPPFhdL3e0"6N9-D@)ZEb#
Xf$3N*)RY$6'PLFQ&bD@9cI5*0BA4S,QmJYJd*#5*l3daTBR*KFQPPFhdL3dPZG'9
XbCQ&MC5j[),B0#3Nq)'e[FQPK,QeKF!d*8f9d4QPXC5!YB5"#)%e[FQPK$3e0Eh*
XTB3N*#F6%#@e[FQPK,R)0#9*PHL"YEh*TB5jb)#eKF("PEQ3J,@mJ6@pbD@%J,A-
XJHe**EQ0XG@4PFhd0#3e0Eh*TB3N*#F6%#AY8CAKdFhd0#8C[FL"'D@aP6Q&YC5"
XTEL"l9'9iG(0p$3N*5@BJ)RY'D@aP6Q&YCAdL)$eq)#r&1LM&+DJa,`d*#3P&BfK
X[)#)MHkJaI5)0#3P&E(0P$3N*#89MD'mJ)L0l4QPXC8jKE@9p)Jd*#89ZC!d*#80
XKG'9ZBA4P)#*l4QPXC8jKE@9p)Jd*4@jN)(`J4@jdB@)J,@3J1#!YG#!`)$iJ6@p
XbD@%0#90PG%CTE'8J,@-J*de558%R)#ed)#G"8&"-*b"0Eh*TB3d*$5-J4QPXCA-
XJGbp[)#)ZD#)JC'9`C@jNC@jMD@9c)#dY$5-*E@&MBfpZCLjM$5-*E@&MD'9XF#j
XM$3eYB@-ZBbj[#3N*#F3*BfpZFh4KER3ZD#"MEfjQD@FZD#"dHA"PFbjS)'9iG'9
XbER-ZD#"YB@0bFh*M,QJ0E@&MFf0[FQ8ZBbj[#3R%#@0[ER0dB@jd,QJJBfpZCQP
XR,QJJG(P`CA-ZD#"PH(4PFQjc,QJ0E@&MFR0bBbjM,Qm*#3R%#@0[ER0dB@jd,QJ
XJBfpZCQPR,QJJG(P`CA-ZD#"PH(4PFQjc,QJJE@&MFR0bBbjS$3eYB@PZ,Q-ZE`N
X*#F3*BfpZFh4KER3ZD#"MEfjQD@FZD#"dHA"PFbjS)'9iG'9bER-ZD!eMFQ9KG'8
XZBbj[#3N*a!PMEfjcG'&ZG#jS)'0[EQCTCbjS)(4jF'9c,QJJCAKdCA*ZFbjS$@0
XbC@&dGA*P,Q-ZE`N*a!PMEfjcG'&ZG#jS)'0[EQCTCbjS)(4jF'9c,QJJCAKdCA*
XZFbjS$@4PBA4S,Q-ZE`N*#F3*BfpZFh4KER3ZD#"MEfjQD@FZD#"dHA"PFbjS)'9
XiG'9bER-ZD!eNCA0M,Q-ZE`N*#F3*BfpZFh4KER3ZD#"MEfjQD@FZD#"dHA"PFbj
XS)'9iG'9bER-ZD!eNG@jRC@pZ,Q-ZE`N*#F3*BfpZFh4KER3ZD#"MEfjQD@FZD#"
XdHA"PFbjS)'9iG'9bER-ZD!ePBA3ZBbj[#3N*#F3*BfpZFh4KER3ZD#"MEfjQD@F
XZD#"dHA"PFbjS)'9iG'9bER-ZD!eQD@aPFbjM,Qm*#3R%#@0[ER0dB@jd,QJJBfp
XZCQPR,QJJG(P`CA-ZD#"PH(4PFQjc,QJ0Cf9ZCA*KG'8ZBbj[#3R%#@0[ER0dB@j
Xd,QJJBfpZCQPR,QJJG(P`CA-ZD#"PH(4PFQjc,QJ0D'9XF#jM,Qm*#3R%#@0[ER0
XdB@jd,QJJBfpZCQPR,QJJG(P`CA-ZD#"PH(4PFQjc,QJ0E@&MD@mZBbj[#3N*a!P
XMEfjcG'&ZG#jS)'0[EQCTCbjS)(4jF'9c,QJJCAKdCA*ZFbjS$@eKCfPM,Q-ZE`N
X*#F3*BfpZFh4KER3ZD#"MEfjQD@FZD#"dHA"PFbjS)'9iG'9bER-ZD!eYDA0M-5j
XM,Qm*#3R%#@0[ER0dB@jd,QJJBfpZCQPR,QJJG(P`CA-ZD#"PH(4PFQjc,QJ0E@P
XcBc)ZBbj[#3N*a!PMEfjcG'&ZG#jS)'0[EQCTCbjS)(4jF'9c,QJJCAKdCA*ZFbj
XS$@e[ER0dCA*c,Q-ZE`N*a!PMEfjcG'&ZG#jS)'0[EQCTCbjS)(4jF'9c,QJ0E@p
XbD@%a,Q-ZE`N*#F3*BfpZFh4KER3ZD#"MEfjQD@FZD#"dHA"PFbjS)'9iG'9bER-
XZD!eYEh*TB6)ZBbj[#3N*a!PMEfjcG'&ZG#jS)'0[EQCTCbjS)(4jF'9c,QJJCAK
XdCA*ZFbjS$A"XBAPPFLjM,Qm*#3R%#@0[ER0dB@jd,QJJBfpZCQPR,QJJG(P`CA-
XZD!e`Eh4TEfjc,Q-ZE`N*#F3*BfpZFh4KER3ZD#"MEfjQD@FZD#"dHA"PFbjS)'9
XiG'9bER-ZD!e`FQ&jCA)ZBbj[#3N*a!PMEfjcG'&ZG#jS)'0[EQCTCbjS)(4jF'9
Xc,QJJCAKdCA*ZFbjS$A*PBf&XE#jM,Qm*#3R%#@0[ER0dB@jd,QJJBfpZCQPR,QJ
XJG(P`CA-ZD#"PH(4PFQjc,QJ0FQjN,Q-ZE`N*#3R%#@0[ER0dB@jd,QJJ)#!J)#!
XJ)#!JG(P`CA-ZD!ecBACP,Q-ZE`N*#F3*BfpZFh4KER3ZD#"MEfjQD@FZD#"dHA"
XPFbjS)'9iG'9bER-ZD!ecBh*[E'ac,Q-ZE`N*#F3*BfpZFh4KER3ZD#"MEfjQD@F
XZD#"dHA"PFbjS)'9iG'9bER-ZD!ecCA4c,Q-ZE`N*#F3*BfpZFh4KER3ZD#"MEfj
XQD@FZD!ecD@GZB@ac,Q-ZE`N*#F3*BfpZFh4KER3ZD#"MEfjQD@FZD#"dHA"PFbj
XS)'9iG'9bER-ZD!ecF'9XE(-ZBbj[#3N*a!PMEfjcG'&ZG#jS)'0[EQCTCbjS)(4
XjF'9c,QJJCAKdCA*ZFbjS$A0dB@CQFbjM,Qm*#3R%#@0[ER0dB@jd,QJJBfpZCQP
XR,QJJG(P`CA-ZD#"PH(4PFQjc,QJ0Fh4[FQ8a,Q-ZE`N*#F3*BfpZFh4KER3ZD#"
XMEfjQD@FZD#"dHA"PFbjS)'9iG'9bER-ZD!ecG'pbC6)ZBbj[#3N*a!PMEfjcG'&
XZG#jS)'0[EQCTCbjS)(4jF'9c,QJJCAKdCA*ZFbjS$A4KBQaPFbjM,Qm*#3R%#@0
X[ER0dB@jd,QJJBfpZCQPR,QJJG(P`CA-ZD!edFQ9KFh9bC5jM,Qm*#F3*BfpZFh4
XKER3ZD#"MEfjQD@FZD#"dHA"PFbjS$A9ZC'9Q,Q-ZE`N*#F3*BfpZFh4KER3ZD#"
XMEfjQD@FZD#"dHA"PFbjS)'9iG'9bER-ZD!efBA*TB@*XC5jM,Qm*#F3*BfpZFh4
XKER3ZD#"MEfjQD@FZD#"dHA"PFbjS$AGKEQ4c,Q-ZE`N*#F3*BfpZFh4KER3ZD#"
XMEfjQD@FZD#"dHA"PFbjS)'9iG'9bER-ZD!ehDATKFQ3ZBbj[#3N*a!PMEfjcG'&
XZG#jS)'0[EQCTCbjS)(4jF'9c,QJJCAKdCA*ZFbjS$3eYB@0NBA4K,R*cFQ-ZE`N
X*a!NJ)#!J)#!J)#!J)#!J)#!J)#!J)#!J)#!J)#!J)#!J)#!J)#!J)'eKBh*cFQ-
XZD!eYB@0bFh*M,R*cFQ-ZE`N*a!PMEfjcG'&ZG#jS)'0[EQCTCbjS)(4jF'9c,QJ
XJCAKdCA*ZFbjS)'eKBh*cFQ-ZD!eYEfjcG'9bFbjbFh*M,Qm*#F3*BfpZFh4KER3
XZD#"MEfjQD@FZD#"dHA"PFbjS$A"XBAPPFLjbFh*M,Qm*#F3*BfpZFh4KER3ZD#"
XMEfjQD@FZD#"dHA"PFbjS$A4KBQaPFbjbFh*M,Qm*#F3*BfpZFh4KER3ZD#"MEfj
XQD@FZD#"dHA"PFbjS$A4bC@&cGA*P,R*cFQ-ZE`N*a!PMEfjcG'&ZG#jS)'0[EQC
XTCbjS)(4jF'9c,QJ0GQ&bD@&LE'8ZFR0bBbj[#3R%#@0[ER0dB@jd,QJJBfpZCQP
XR,QJJG(P`CA-ZD!fU&J!!!3!!!!&-!!!!6!!!!$)!!!!F!%!!3!#D!F3!!3%!!!!
X!!!!!!))(3fpZCQPbE3K0B@YP4QPXC5d#!!!!9%9B9%e38b!"!!!!!%!!!!!!!!"
X849K869"6)!%!!!!!3!!!!!!!!!!!!!!!!!!!!!!!!++&Jjm!!"E0!!!"IJ#$!!!
X!!*3!"`!!!!!!M!%!!*i"4J3$6Q9h!!!!!!!!TJ%!!,J"4J3'3f&ZBf9X!!!!!!#
X0!!i!R3#kL!Y1CAFJ9fPZC'ph1J!!!!!!!"S!h`!Z!9Z!!!!!!!!!0!%!!%B"4J3
X&4@TPBh3!!!!!!!"1!3!!B!&'"!9%FQPfC3!!!!!!!!")!!P0EfjKBfm!!!!!!!!
X!!!!!!!!!!!!!!!!!!!!!!!!!!!!'!!3!2J!2!G-#F`!q!!m"d`*cSS@5q3!!&Xd
X!!"E0!!!6e`%!!!!"!!!!!8`!!!"-!!!!-J!Z#8!)&J!!!"`!-J!!69"68J!!!!S
X$lIrr!!!!!!![$)42eJ:
END_OF_FILE
if test 8517 -ne `wc -c <'mac/MakeFile.hqx'`; then
    echo shar: \"'mac/MakeFile.hqx'\" unpacked with wrong size!
fi
# end of 'mac/MakeFile.hqx'
fi
if test -f 'mac/miscrsrc.hqx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/miscrsrc.hqx'\"
else
echo shar: Extracting \"'mac/miscrsrc.hqx'\" \(8821 characters\)
sed "s/^X//" >'mac/miscrsrc.hqx' <<'END_OF_FILE'
X(This file must be converted with BinHex 4.0)
X:%NeKBde[FQPK,QeTFf-ZFR0bB`"bFh*M8P0&4!%!!!!!!!!!'5,RM3!!!!!"!!!
X!'0`!!"IF!!!!4J!!#'%(D'9KC'9bF`%!!!!!&3!!#'F!!!!!SkTl%`!!%NeKBde
X[FQPK,QeTFf-ZFR0bBfm#!!!!FR0bBe*6483!!(*cFQ058d9%!3!!!!$!!!!!!!!
X!!!!!!!!!!!!!!!!!T48J)`!!!!!!!"NL!!!"!!!!!!!)D!!!!!!!!!!!!!!!!!!
X!)ai!!#3!S*Q#Ck$H'l8!!!!!33!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X!b98!%J!!!!!!!!!!!!!!!!d!!!!)B3GcEh9bBf9c!3!!!!!V!!!)D3!!!!#MURX
XR!!!!!!"5!"J"*`!!&pK8D'Pc)'Pc)&9YEh*TB5!e,M-Z-5!SEh)JD@BJH@pe)("
XbC@CPFL`J6@&M6@pbD@%J05ic,M%T,Je3E'9KFf8JFf9ZC#"MEfeYC@jdFb"KEQ3
XJBR9R)(*PF'pbG(-JG'mJ$AGTE(0[EN"PFQjTC5j#CA*VC@aPH5j&4&8J+%TTE5"
XAD@acEfiT)'pb$@*c3'0c,Q*bB@jNC@Pc,Q9NG5!S3Q9ZDQ&YD@iJ8f0SFQ9TBQ9
Xb+5i0$99cCA*c)'pQ)("bCACTEh9c)(CPFR0TEfjc)'pQ)%eKBb"0Eh*TB5"cD'p
XeE'3JC'PcBf&bC#"dD'8J$@pXC#"`FQpRFQ&Y,L!J6h4SCA*hDA0P,#"dD'8J4QP
XZC'9b)'eTCfKd)'GPG#"MEfjQGA0PC#"hD'9Z)!ejEh8JC'peBQaP,@0XD@0V)'p
XZ)'%JFf&fC@3JCf&YC5"dEb"cG'&bG#"0Eh*TB5i0$5SU+LSU+LSU+LSU+LSU+LS
XU+LSU+LSU+LSU+LSU$3e0Eh*TB5"TFb"K)'4eEQGPEfiJCAK`E'pbBA4TEfiJCf&
XYC5iJ)&4SC5"ZB@eP)'0[E@9c)'CbEfdJ$G*8D'8J6'pbC#"[CL"dD'8J8QPZCh2
X6)(4bD@a[ChNJGh*TG(4PEL"LH5"+,L"5,L"5,L!09'pXDfPPELiJ)%e[FQPK)'P
Xc)("bEfj[G@jMC@3JGfPdD#"dD'8JB@0MC@jd)'pZ)(4SC5"QDA*cG#!0FhPXE'&
XLE'8X)'8ZCbiJ68p545ePC5eKD#iJ)%C[FL"NCA4KD@ac)'pZ)(4SC5"RB@eP)'P
XdFf9XCL`J$A"XC@&cC5"bC@&N)(4SC5"0Eh*TB5"%Ef0c)'CTE'8JG'KKG#"TFb"
XNDA0dFQPLGA4PC#"KE'pZCb!0GfPdD#"0Eh*TB5i0$8e[FQPK)(GKFb"[FQPRD@j
XKE'aj)(GbDA4dC@iJCQpb)&C"@#p@69-JFhPcG'9YFbiJ)%&c)(0eBfJX)!eTG#"
XTFb"SC@&fD@aj)'4PF'9ZC'9ZG#"[EL"dD'8JDf9jBQpKFQ3JCQpb)'GKE@8JF'a
XKH5iJ)!e8D'8JE@peFf8JDA-JEQpd)(9cC@3JBA3JB@aX,#"PH'0PF(3JCQpb)(0
XdB@jNBA*N)(4SD@jRFb!0E'PVC5"YC@jeFb"KEQ3JC'PKE'pRFbiJ)&4[)'GPG#"
XK)'aTFh3JEfBJG'KP)'&fB@PXB@*XC5!0Df9jBQpKFQ3JBfpYE@&ZC(-X)'KTG#"
XdD'8Je$r9)'YPH5"hD'PXC5"`E'&jD@jR)(4SC5"RB@eP,Jd08fpYC5"[CL"dD'8
XJBfpYE@&ZC(-JBA*P)(0`C@0TCQPPC#"KFb"LC@PZCb"MEfjdFQpX)!eMD'&bB@0
XdCA*c,#"T,Q8Z)(0KGQPZCb"dD'8JCf&YC5"TFb"H@#iJ)&4[)(4jF'8JG'KPFf8
XJ$@0SBA*KBh4PFR-JD'pXC#"NEhGZ)(4SC5"MEfjdFQpX)'YPH5"KEQ3JG'KPEL"
X`FQ9cFb"dD'8J$@&`F(*[F(*TBA4P)'0SBA*KBh4PFL"VCANZ)#"*CL"jEh8JC'm
XJEQpd)'KKGQ8JB5"MEfjdFQpX)!eVCANX)(9cC5"dD'8JBfpYE@&ZC#"VCANJ+'&
X`F'aP,f0XEhCPFQaPB@BJDf9j+5"TER0dC@&N)!e[CL"dD'8JBfpZG(*[E#"VCAN
XZ)#"*CL"jEh8JF(*PCQ9b,#"jEh8JE@&j)'9ZG'9b)(4SCA0P)!eMEfeYB@jNFb"
XeFfPZCb"dGfmJDf9jFh4bEfYPFb`JBRNJCQPbFh3JG(P`D@jR)(4SC5!RALFJ$@Y
XPH5"QEfaXEhGPC#"LH5"dD'8JE'9dG'9b,Jd09'KP)'GKE@8JB@acEb"eFf9c)(4
XSC5"PFf0KF'8JDf9j)#K&8d-T)(&eDA4P)'%JBQPd,L!J$8PQ)(P[G5"NEb"ZEh3
XJD'&fC5"KEL"PFf0KF'8JDf9j)'pZ)(P[GA)JDf9jBQpKFQ3X)(P[G5!0Bf&Z)(9
XcC5"dD'8JB#"VCANJEh)JG'KP)%0XC@&b)'YPH5"[EL"dD'8JER9YCA*TBb"VCAP
X`B@3J$@PZFh4PB@3Z)#""EL"PFf0KF'8JBf&Z)'&XFfmJBRNJG(P`C@3JBA-JAPX
XX)'NZC5iJBfpZG(*[E#!0+'pb)'0[E@eKEQ3T)'aPCR3JBR*KBfYPG#i0$8CTE'8
XJ6@9ZG3dY,5dY,5dY,5d09'KP)'GKE@8JCR9XE(NJFh9`F'pbG(-JG'KP)(0dB@j
XNBA*N)%eKBfPZG'pcD#"QD@aP)'ePER8Z)#!09A0P)%jPGb"dEb"cG'&bG#"`E'&
XjD@jR)'%JEQ9h)'GKE@8X)'pb)%p`C@iJG'mJFQ9cG'&bG#"K)!e`FQ9fD@peFb"
XRB@eP,L!J)&0KGQ8J3A-JGfPXE#"KE(GKHA-JBA0V)(P[G5"QEh)JG'KP)'jKE@8
XJ$@pQ)(4SC5"QD@aP)(4[)(0KGQ8JH@peFL"MD'&bB@0dCA)JD@iZ)#"6BACP)(G
XTE'`JGA0eB@aXH5!0Ff&fC5"dD'8JCf&YC5"TEL"K)'CTE'8JGfPdD#"dD'8JFf&
XYC5"ZB@eP)'&c)(4SC5"ZB@eP)'pQ)!edD'8JBh9bFQ9ZG#"MD'&bB@0dCA)Z)#"
X*CL"jEh8JBA*P)("XBAPTEQFJB5"ZCAFJCf&YC5`JEh)J$@KKGQ8JBfKKEQGPC#"
XdD'8JEQ&YC5"[CL"jEh9b)'0SBA*KBh4PFL`J8f&fC5"hD@aX)'PZFh4PB@3J$@&
XcDb"jEh8JCQpb)(4SC5"ZB@eP)'pQ)(4SC5"cBACP)'CTE'8Z)#"8D'8J8A9TG#"
X[F(4TEfiX)!e[CL"MEh9bFf8X)'Pc)(9cC@3JG'mJCAKTG#"dD'8JCf&YC5i0$8%
XJCf&YC5"MB@iJEfjXH5"LC5"cBACPC#"KG#"dD'8JF'pTER3JGfKPFQ8JDA3JDA-
XJH@peFL!0G(9bEL"dEb"YEhCP,L!J3A3JB@aX)'pdD'9b)(4TE@9c)(4SC5"6BAC
XP)'0[E@eKEQ3JGfPXE#!0EQpd)'*P)'&fB@PXB@*XC5i0$94SC5"'D@aP)%ePER8
XJDA-JC'PcB@*XC@3JGfKTE'8JFf&fD@jR)'&ZC#"bCA0dEh*TEQFJCf&YCA-Z)!e
X8D'9bC5"TFb"ZEb"MBA9cC5"QEh)JB@aKFQdJD@BJH@pe)(0PC5"dD'Pc)'pMBh9
Xb,L!J3@CdCA)J$A4SC5"[F'9bBA4TEfiJDA-JBfpYF'aPG'9N,#"dD'9bC5"hD@a
XX)'*P)'%JF(*[EA"d)(4SBA3J$A0KHA-JdR"bCA0c)'&ZH5"VCANJG'mJBfpZG'P
XZG@A6,L!J3@CdCA)JH@pe)("bCA0c)'%JDf9j,#!0G'KP)%CTE'8J6@9ZG5"hD@a
XX)'*P)(*PC@jKBQaPC#i0$8PQ)(P[GA)JBfKKFQ&MG'9b)'4TCA-X)'pb)(P[G5"
XNC@0TC'8JG'mJFh4[F#"bG@jZD@jR)'KTE5`J$AP[G5"hD@aX)'*P)("bEfe`G'9
XN)(CTB5"K)(0dB@jNBA*N)'CTE'8JC'PKE'pR)'C[FL"dD'8J$@jKE@8JEfBJB5"
XQD@aP)'PZ)(GSD@0S)(4[)(0KGQ8JD'Pc)'ePE@pbD@9c,L!J8(*PFh0TEQFJ$@0
XKEQ0PE#"hD@aX)'&fEfPN)(0KGQPZCb"dD'8JE@9YEh*TCA-Z$3e&C'Pd)%ePER8
X0,5dY,5dY,5dY$94SC5"&C'Pd)%ePER8JDA4PEA-JBA*P)'j[G#"eFf9N)'*j)(4
XSC5"RB@eP,L!J9'KP)%9NDA3J$@ePER8JDA-JC'PcB@*XC@3JG@jXCA0c)(4SCA*
XP)'Pc)'%J4'9cDb""Bf0PFh0[FRNJEh"PELi0$90MFQ9PELp'Efjd8fPkC5"0C@j
Xe$5dY,5dY,5dY,5dY,5dY,5dY,5dY$8PQ)(P[G5"SBACP)'%JBfpXEh)JFhPcG'9
XY,#"dD'8J3fpXEh)JDA4PE5"KE'a[Gh-JH@pe)(4[)!eMD'p[Ff8JG'KP)'*KBfY
XRFQpeEQ3JB@jN)'C[FQ9RFQpeEQ3JBfpXEh*c)'pQ)(4SC5"RB@eP)!ehD@jNEhF
XZ)#"8D'8JCf&YC5"YGA0d)(9cC5"K)'0[ER0dB@jd)(GTC(4S)'C[ER3X)(0[)'p
XZE(NJ$A4SC5"0EfjKBfmJCQpZG#"TFb"cGA"`Eh*dC@3Z)#"CEh8JBf&Z,#"SEhG
XPGQ9b,#"cF'9MD@Cj)!ehD'PMD#"`EfPZG#"cDATP)(4SBA3JH@pe)(GKER3JG'm
XJGA0P,L!J9'KP)'ePER8JGfPXE#"XDA0d)!ePGQ9bH5"`EfPZG#"cDATP)'&fB@P
XXB@*XC5"[EL"jEh9b)%eKBfPZG'pcD#"QEh)JG'KP)!e0EfjKBfmJCQpZG#i0$8&
XNGQ&ZBf9N)(9cCA*c)'0KEL"MD'p[Ff8JB5"ND@CQCA*PER3JCQpZG#"LH5"eFfP
XZCb!08Q9c4@4TG#"[FL"K)(0TE@PXBA)JF(*[Ch*KE5"dEb"PC'Pd)(4SC5"69&)
XJFQ9cEh9bBf8Z$3e0Eh*TB5"0C@je$5dY,5dY,5dY,5d05'9XF#"LFQPZCh-JGA!
XJG'KTFb"ND@&XEfFZ$3e$EfeYB@jN)&0PG#"KE'a[Gh-JH@pe)(4[)'0SEfpcC5"
XLCA4hC@9Z)(4SC5"[FQPRD@jKE#!06@pbD@%JBfpYE@&ZC#"cCA3JB@jN)'&Z)'p
X`G'P[EQ&X)'0[E@eKEQ3JFf9d)(0TE@PXBA)JG'mJ$A4SC5"96NPB)'GKE@8J8Qp
XRG@8Z)#"8D'8JE@&TEL"ND@CQCA*PEQ0P)'*PG(GPC@iJG'KP)(4hEb!0DA-JG'K
XKG#"dD'8JEh*TCfPZB@`JBfpYE@&ZC#"cCA3JGA0PFb"dD'8JER9YCA*TBb"VCAP
X`B@3J$@C[FL"YEhCPE@9ZG#`JGfKPFQ9KFb"dD'8J8QpRG@8YE'PVC5"MEfeYB@j
XN)(0PG#"eFf9c)(4SC5!0e'KUDfc9)'YPHA-JCQpb,#"bCA0`C@0dDACPE(NX)'a
XPCR3JC'phEL"eF#"KEQ3JFQPRD(3Z)#!09'KP)("bEfGbB@dJGfPXE#"bC@ePE@*
XPFL"jEh9b)(0PG(4TEQFJB@jN)(9cC5"TG#"KFb"K)!eNC@CKG@ad)(4SC5"ZCAK
Xd)(4TE@8JH@pe)(0dBA*d)'%JEQ9h)'0SBA*KBh4PFLiJ)&4SC5!0BfpYE@&ZC#"
XcCA3JBf&Z)'*P)'0SEh0PEL"QEh)JG'KP)'0eFR*PER3JBfKKFQ&MG'9b)'*j)!e
XeFfPZCb"dD'8JFf9d)'p`G'P[ER-J+#Fp*bNJBfpYE@&ZC#i0$8j[G'8JG'KKG#"
XdD'8JER9YCA*TBb"VCAP`B@3X)'PQ)(P[GA)JFhPcG'9Y)'KKFb"[EQ8X)'Pc)!e
XKE(GKHA-JBACKD@aKBQaP)'C[FL"TEQ4TBf&dD@jR)'4TFQ9MG'P[ER-X)(*PCf&
XbC'aPFh-JEfBJ$A4SC5"MEfeYB@jN)(0PG#"MD'pcC@iZ)#"8D'8JBA*bEhFJDf9
XjFb"hD@aX)(G[FQXJBA-JGf9XE#i0$94PH(3J4@4TG'pb)'&XE'phFb"jEh8JG'm
XJBfK[Eh0P)(4SC5"dHA"P)'pQ)&4&@&3JCQPXC5!0Bh*PBA4PC#"LH5"0Eh*TB5`
XJG'KKG#"TFb`JDA3JB@aXEhGc)(P[G5"dEb"cF'9MD@Cj)(GSD@0S)!eKF("XD@0
XKG'P[EL"hD@aX)'*P)(9cC@3JBRNJG'KP)%CTEQ4PFL"hD'9Z)(P[G5"[F'9Z)'%
XJ$94&@&3JCQPXC5"MFQ9KG'9N)'*j)%e[FQPK,L!J@@pe)'0KEL"MD'p[Ff8J6@&
XM9h*TG'8JEh)J$8eTBh*[FfpQG#"AEh*N)'CTE'9c,L!J@@pe)'0KEL"KE(0[)(0
X`C@0TCRNJG'KP)(0TCfjKG(9bC5!0EfBJG'KP)'4PFfPbC@3JBA"`E'PMBA4TEfi
XJD@BJH@pe)("bC@CPFL"cEfePG'KTEQFJC@acC5i0$8KTCfJJ8f0[FQ9c)'4TFh"
XXBAPc)'&XE#"[CL"dD'8JFf0[FQ9c)(0dEh*PC#"TEL"dD'8J$A0MEh*PCQPXC5i
XJ)&P[G5"MB@iJBfaPBA)JG'KPFf8JFf0[FQ9c)'*j)'TeFh3JC'9XCA4TEQFJ$A4
XSC5")D@GS)&0MEh*PFb"QD@aP,L!J9'KTFb"QC@&dGA*P)'Pc)'j[G#"TEA"XC@e
XPER4PC#i0$80[EQCTCh9bBA4TEfiJ5@jQE`dY,5dY,5dY,5dY,5dY,5dY,5d06@p
XbD@%JDA-JCR9XE(NJ6A9XG'PQD@jNCA)JBfpYF'&dD@*XC5pKGf&bC5iJ)%Pd)(*
XPFA9TFQ9c)!dd06!J5b"[CL"YC@e[FRNJG@jNCA)J6A9XG'PQD@jNCA)Z)#"8D'8
XJCf&YC5"hD@aX)(*eEL"[EL!0B@jj)%eKBfPZG'pcD#"hDA4S)$%J6@9RB@*jG'8
XJEh)JE@pbC5"[CL"YC@e[FRNZ$3e0Eh*TB5"MEfePFb"hDA4S)'%JC'pMG@ePER4
XKG'P[EL"QD@aP,#"MB@aXC@3J6@pbD@%J4'pMFbiJ)!e8D'8J6@pbD@%J4'pMFb"
XQD@aP)'Pc)'&Z)'9iF'aKEQ&dD@pZ)'pQ)(4SC5"RB@eP)(0jFh4PE5iJ)!e3E'9
XKFf8JFQ9YC@eLCA)JG'mJB@ahBAPc)'4TFh4bD@*eG'8JG'KTFb"QD@aP)(GTG'J
XJG'KP)!eRB@eP,#"cD@jMC5"TG#"MEfjdB@PZFb"YG@0S)'PYF'pbG'&ZG#"TEQC
X[FQeKG'P[ELi0$8e[FQPK)(GTE'`JBh*PBA4P)(4hEb"QD@aPFb"hD'9Z)'Pd)'P
Xc)(*eELiJ)&4SC5")D@GS)!e6BfpbCA-JCQPXC5"VC@9`Fb"K)'aTFh3JEfBJG'K
XP)(0MEh*PFb"[CL"KE'`JEfBJG'KP)!e`FQ9fD@peFb"RB@ePFbiJ)%PQ)(4SDA-
XJCQPXC5"TFb"ZEh3JF(*PFf9ZG#`JB5"ZCAFJEfjP)!ehD@aX)'*P)'0bC@&dC@3
XJD@iJG'KP)'C[E'4PFL"hD'PMD#"MEfjdB@PZFb"dD'8JCf&YC5iJ)!e8D'Pc)'C
XTE'8JBf&Z)'*P)'YPF(3JC@PdD'9b)'PZ)(4SC5"QEfaNCA)JG'KKG#"MEfjdB@P
XZFb!0G'KP)'&`F'aTBf&dD@pZ,#"[FL"TEL"dD'8J8hPcG'9Y)%C[E'4PFLi0$8e
X[FQPK)'&XFfmJBh*PBA4PFb"K)'CTE'8JBf&XE'9N)040Eh*TB5"$EfjQD@I9)'P
XZ)(4SC5!08hPcG'9Y)%C[E'4PFLiJ)&4SDA-JCQPXC5"MEfjdB@PZFb"KE'`JEfB
XJG'KP)'0[EQCTCbd0GA*KG'P[EL"TEQC[)'C[FL"0Eh*TB5`JFh9MD#"KFb"dD'8
XJFfPkC5"KEQ3JE'pMBA4TEfiJEfBJ$AGTEQ4[Gh-X)(4SC5"QEfjd)(0THQ8X)(4
XSC5"MEfeYB@jN)(0PG#`JCA4M,L!J9'KTFb"QD@aP)!eYGA0d)(*PE@&TEL"TEL"
XdD'8J8hPdC@dJ4QpXC'9b,Jd09'KP)(4PH(3JC'PcF'aKH@9N)(GSC@iJ6@pbD@%
XJFh4KFR4c)(9`)'Pc)(0dEh*PC#"TEL"dD'8J$@4KG'%JCQpbDb"[CL"dD'Pc)("
XbEfGbB@dZ)#"CEh8JBf&Z)'9NDA3JDA3JGfPdD#"YEh0d)!edCAKd)'9NDA4[FR-
XJBRNJCQPbFh3JBfKKEQGTEQFJG'KP)'CTE'8JG(P`C5"[CL"dD'8J$A"bEfGbB@d
XJCR*[E5!R39"36#FJG'mJ*e4&@&3R)(GTG'JJ8Q9c4@4TG#iJ)&*PE@9YBQ9b)(4
X[)!eMD'&ZCf8JG'KP)'CTE'8JG(P`C5"LB@0V)'&RB@PZ)(GSC@iJH@pe)'&bC5"
XdD(*[G@GS,L!J3Q8J$@0KFQ9QG@`JEQpd)(4[)'4TFh4eFQ)JG'KP)'aTEQ9c)(G
XSD@0S)'*PCfPZ)(GTG'JJB5!R)bFZ$3!!!3!!!"MF!!!Ah!!!!%B!-e*)"B3!!!!
XF!$)!!&4&@&3!!!!+!J!!!#!!!!!!-e&!%deKBb"0Eh*TB5")C@a`)&4PH(5QV!:
END_OF_FILE
if test 8821 -ne `wc -c <'mac/miscrsrc.hqx'`; then
    echo shar: \"'mac/miscrsrc.hqx'\" unpacked with wrong size!
fi
# end of 'mac/miscrsrc.hqx'
fi
if test -f 'mac/scrnmgr/ScrnMgr.r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/scrnmgr/ScrnMgr.r'\"
else
echo shar: Extracting \"'mac/scrnmgr/ScrnMgr.r'\" \(8279 characters\)
sed "s/^X//" >'mac/scrnmgr/ScrnMgr.r' <<'END_OF_FILE'
X/* mac/scrnmgr/ScrnMgr.r: resources for scrnmgr code
X
X   Copyright (c) 1989-1991 Curtis McCauley, James E. Wilson
X
X   You may copy this subroutine package freely, modify it as you desire,
X   and distribute it at will, as long as the copyright notice in the source
X   material is not disturbed, excepting that no one may use this package or
X   any part of it for commercial purposes of any kind without the express
X   written consent of its author. */
X
X#include "Types.r"
X
Xtype 'INFO'	{
X	rect;
X	integer;
X	longint white, black, red, green, blue, cyan, magenta, yellow;
X	longint white, black, red, green, blue, cyan, magenta, yellow;
X};
X
Xtype 'acur' {
X	integer = $$Countof(cursors);
X	integer = 0;
X	array cursors {
X		integer;
X		integer = 0;
X	};
X};
X
Xresource 'acur' (128, "Rotating Watch") {
X	{ 256, 257, 258, 259, 260, 261, 262, 263 }
X};
X
Xresource 'CURS' (256) {
X	$"3F 00 3F 00 3F 00 3F 00 40 80 84 40 84 40 84 60"
X	$"9C 60 80 40 80 40 40 80 3F 00 3F 00 3F 00 3F",
X	$"3F 00 3F 00 3F 00 3F 00 7F 80 FF C0 FF C0 FF C0"
X	$"FF C0 FF C0 FF C0 7F 80 3F 00 3F 00 3F 00 3F",
X	{8, 8}
X};
X
Xresource 'CURS' (257) {
X	$"3F 00 3F 00 3F 00 3F 00 40 80 80 40 81 40 82 60"
X	$"9C 60 80 40 80 40 40 80 3F 00 3F 00 3F 00 3F",
X	$"3F 00 3F 00 3F 00 3F 00 7F 80 FF C0 FF C0 FF C0"
X	$"FF C0 FF C0 FF C0 7F 80 3F 00 3F 00 3F 00 3F",
X	{8, 8}
X};
X
Xresource 'CURS' (258) {
X	$"3F 00 3F 00 3F 00 3F 00 40 80 80 40 80 40 80 60"
X	$"9F 60 80 40 80 40 40 80 3F 00 3F 00 3F 00 3F",
X	$"3F 00 3F 00 3F 00 3F 00 7F 80 FF C0 FF C0 FF C0"
X	$"FF C0 FF C0 FF C0 7F 80 3F 00 3F 00 3F 00 3F",
X	{8, 8}
X};
X
Xresource 'CURS' (259) {
X	$"3F 00 3F 00 3F 00 3F 00 40 80 80 40 80 40 80 60"
X	$"9C 60 82 40 80 40 40 80 3F 00 3F 00 3F 00 3F",
X	$"3F 00 3F 00 3F 00 3F 00 7F 80 FF C0 FF C0 FF C0"
X	$"FF C0 FF C0 FF C0 7F 80 3F 00 3F 00 3F 00 3F",
X	{8, 8}
X};
X
Xresource 'CURS' (260) {
X	$"3F 00 3F 00 3F 00 3F 00 40 80 80 40 80 40 80 60"
X	$"9C 60 84 40 84 40 40 80 3F 00 3F 00 3F 00 3F",
X	$"3F 00 3F 00 3F 00 3F 00 7F 80 FF C0 FF C0 FF C0"
X	$"FF C0 FF C0 FF C0 7F 80 3F 00 3F 00 3F 00 3F",
X	{8, 8}
X};
X
Xresource 'CURS' (261) {
X	$"3F 00 3F 00 3F 00 3F 00 40 80 80 40 80 40 80 60"
X	$"9C 60 88 40 90 40 40 80 3F 00 3F 00 3F 00 3F",
X	$"3F 00 3F 00 3F 00 3F 00 7F 80 FF C0 FF C0 FF C0"
X	$"FF C0 FF C0 FF C0 7F 80 3F 00 3F 00 3F 00 3F",
X	{8, 8}
X};
X
Xresource 'CURS' (262) {
X	$"3F 00 3F 00 3F 00 3F 00 40 80 80 40 80 40 80 60"
X	$"BC 60 80 40 80 40 40 80 3F 00 3F 00 3F 00 3F",
X	$"3F 00 3F 00 3F 00 3F 00 7F 80 FF C0 FF C0 FF C0"
X	$"FF C0 FF C0 FF C0 7F 80 3F 00 3F 00 3F 00 3F",
X	{8, 8}
X};
X
Xresource 'CURS' (263) {
X	$"3F 00 3F 00 3F 00 3F 00 40 80 80 40 90 40 88 60"
X	$"9C 60 80 40 80 40 40 80 3F 00 3F 00 3F 00 3F",
X	$"3F 00 3F 00 3F 00 3F 00 7F 80 FF C0 FF C0 FF C0"
X	$"FF C0 FF C0 FF C0 7F 80 3F 00 3F 00 3F 00 3F",
X	{8, 8}
X};
X
Xresource 'STR ' (128, "About Title", purgeable) {
X	"About ScrnMgr\311"
X};
X
Xresource 'STR ' (129, "Font Name", purgeable) {
X	"Monaco"
X};
X
Xresource 'DLOG' (128, "About", purgeable) {
X	{44, 26, 162, 314},
X	dBoxProc,
X	invisible,
X	noGoAway,
X	0x0,
X	128,
X	""
X};
X
Xresource 'DLOG' (129, "Colors", purgeable) {
X	{56, 32, 228, 364},
X	dBoxProc,
X	invisible,
X	noGoAway,
X	0x0,
X	129,
X	""
X};
X
Xresource 'DLOG' (130, "Yes or No", purgeable) {
X	{40, 40, 142, 300},
X	dBoxProc,
X	invisible,
X	noGoAway,
X	0x0,
X	130,
X	""
X};
X
Xresource 'DITL' (128, "About", purgeable) {
X	{ /* array DITLarray: 4 elements */
X		/* [1] */
X		{73, 103, 97, 191},
X		Button {
X			enabled,
X			"OK"
X		},
X		/* [2] */
X		{80, 158, 89, 167},
X		UserItem {
X			disabled
X		},
X		/* [3] */
X		{16, 8, 32, 273},
X		StaticText {
X			enabled,
X			"ScrnMgr: Version 1.0 22 July 1989"
X		},
X		/* [4] */
X		{40, 8, 56, 120},
X		StaticText {
X			enabled,
X			"Curtis McCauley"
X		}
X	}
X};
X
Xresource 'DITL' (129, "Colors", purgeable) {
X	{ /* array DITLarray: 23 elements */
X		/* [1] */
X		{40, 256, 60, 316},
X		Button {
X			enabled,
X			"OK"
X		},
X		/* [2] */
X		{88, 256, 108, 316},
X		Button {
X			enabled,
X			"Cancel"
X		},
X		/* [3] */
X		{32, 32, 48, 112},
X		RadioButton {
X			enabled,
X			"White"
X		},
X		/* [4] */
X		{48, 32, 64, 112},
X		RadioButton {
X			enabled,
X			"Black"
X		},
X		/* [5] */
X		{64, 32, 80, 112},
X		RadioButton {
X			enabled,
X			"Red"
X		},
X		/* [6] */
X		{80, 32, 96, 112},
X		RadioButton {
X			enabled,
X			"Green"
X		},
X		/* [7] */
X		{96, 32, 112, 112},
X		RadioButton {
X			enabled,
X			"Blue"
X		},
X		/* [8] */
X		{112, 32, 128, 112},
X		RadioButton {
X			enabled,
X			"Cyan"
X		},
X		/* [9] */
X		{128, 32, 144, 112},
X		RadioButton {
X			enabled,
X			"Magenta"
X		},
X		/* [10] */
X		{144, 32, 160, 112},
X		RadioButton {
X			enabled,
X			"Yellow"
X		},
X		/* [11] */
X		{32, 152, 48, 232},
X		RadioButton {
X			enabled,
X			"White"
X		},
X		/* [12] */
X		{48, 152, 64, 232},
X		RadioButton {
X			enabled,
X			"Black"
X		},
X		/* [13] */
X		{64, 152, 80, 232},
X		RadioButton {
X			enabled,
X			"Red"
X		},
X		/* [14] */
X		{80, 152, 96, 232},
X		RadioButton {
X			enabled,
X			"Green"
X		},
X		/* [15] */
X		{96, 152, 112, 232},
X		RadioButton {
X			enabled,
X			"Blue"
X		},
X		/* [16] */
X		{112, 152, 128, 232},
X		RadioButton {
X			enabled,
X			"Cyan"
X		},
X		/* [17] */
X		{128, 152, 144, 232},
X		RadioButton {
X			enabled,
X			"Magenta"
X		},
X		/* [18] */
X		{144, 152, 160, 232},
X		RadioButton {
X			enabled,
X			"Yellow"
X		},
X		/* [19] */
X		{16, 16, 168, 120},
X		UserItem {
X			disabled
X		},
X		/* [20] */
X		{16, 136, 168, 240},
X		UserItem {
X			disabled
X		},
X		/* [21] */
X		{8, 24, 24, 104},
X		StaticText {
X			disabled,
X			"Foreground"
X		},
X		/* [22] */
X		{8, 144, 24, 224},
X		StaticText {
X			disabled,
X			"Background"
X		},
X		/* [23] */
X		{48, 296, 56, 304},
X		UserItem {
X			disabled
X		}
X	}
X};
X
Xresource 'DITL' (130, "Yes or No", purgeable) {
X	{ /* array DITLarray: 5 elements */
X		/* [1] */
X		{16, 184, 36, 244},
X		Button {
X			enabled,
X			"Yes"
X		},
X		/* [2] */
X		{64, 184, 84, 244},
X		Button {
X			enabled,
X			"No"
X		},
X		/* [3] */
X		{19, 227, 33, 241},
X		UserItem {
X			disabled
X		},
X		/* [4] */
X		{9, 48, 89, 168},
X		StaticText {
X			disabled,
X			"Are you sure?"
X		},
X		/* [5] */
X		{8, 8, 40, 40},
X		Icon {
X			disabled,
X			0
X		}
X	}
X};
X
Xresource 'MENU' (128, "Apple") {
X	128,
X	textMenuProc,
X	0x7FFFFFFD,
X	enabled,
X	apple,
X	{	/* array: 2 elements */
X		/* [1] */
X		"About ScrnMgr\311", noIcon, "", "", plain,
X		/* [2] */
X		"-", noIcon, "", "", plain
X	}
X};
X
Xresource 'MENU' (129, "File") {
X	129,
X	textMenuProc,
X	0x7FFFFFFB,
X	enabled,
X	"File",
X	{	/* array: 4 elements */
X		/* [1] */
X		"Open", noIcon, "O", "", plain,
X		/* [2] */
X		"Close", noIcon, "W", "", plain,
X		/* [3] */
X		"-", noIcon, "", "", plain,
X		/* [4] */
X		"Quit", noIcon, "Q", "", plain
X	}
X};
X
Xresource 'MENU' (130, "Edit") {
X	130,
X	textMenuProc,
X	0x7FFFFFC0,
X	enabled,
X	"Edit",
X	{	/* array: 6 elements */
X		/* [1] */
X		"Undo", noIcon, "Z", "", plain,
X		/* [2] */
X		"-", noIcon, "", "", plain,
X		/* [3] */
X		"Cut", noIcon, "X", "", plain,
X		/* [4] */
X		"Copy", noIcon, "C", "", plain,
X		/* [5] */
X		"Paste", noIcon, "V", "", plain,
X		/* [6] */
X		"Clear", noIcon, "", "", plain
X	}
X};
X
Xresource 'MENU' (229, "File (No Keys)") {
X	129,
X	textMenuProc,
X	0x7FFFFFFB,
X	enabled,
X	"File",
X	{	/* array: 4 elements */
X		/* [1] */
X		"Open", noIcon, "", "", plain,
X		/* [2] */
X		"Close", noIcon, "", "", plain,
X		/* [3] */
X		"-", noIcon, "", "", plain,
X		/* [4] */
X		"Quit", noIcon, "", "", plain
X	}
X};
X
Xresource 'MENU' (230, "Edit (No Keys)") {
X	130,
X	textMenuProc,
X	0x7FFFFFC0,
X	enabled,
X	"Edit",
X	{	/* array: 6 elements */
X		/* [1] */
X		"Undo", noIcon, "", "", plain,
X		/* [2] */
X		"-", noIcon, "", "", plain,
X		/* [3] */
X		"Cut", noIcon, "", "", plain,
X		/* [4] */
X		"Copy", noIcon, "", "", plain,
X		/* [5] */
X		"Paste", noIcon, "", "", plain,
X		/* [6] */
X		"Clear", noIcon, "", "", plain
X	}
X};
X
Xresource 'MENU' (131, "Screen") {
X	131,
X	textMenuProc,
X	0x7FFFFFFD,
X	enabled,
X	"Screen",
X	{	/* array: 2 elements */
X		/* [1] */
X		"Colors\311", noIcon, "", "", plain,
X		/* [2] */
X		"-", noIcon, "", "", plain,
X	}
X};
X
Xresource 'MENU' (132, "FontSize") {
X	132,
X	textMenuProc,
X	allEnabled,
X	enabled,
X	"FontSize",
X	{	/* array: 0 elements */
X	}
X};
X
Xresource 'MBAR' (128, "Main Menu") {
X	{	/* array MenuArray: 3 elements */
X		/* [1] */
X		128,
X		/* [2] */
X		129,
X		/* [3] */
X		130
X	}
X};
X
Xresource 'MBAR' (228, "Main Menu (No Keys)") {
X	{	/* array MenuArray: 3 elements */
X		/* [1] */
X		128,
X		/* [2] */
X		229,
X		/* [3] */
X		230
X	}
X};
X
Xresource 'INFO' (1, "Screen Info") {
X	{ 50, 10, 250, 310 },
X	9,
X	black,
X	white
X};
END_OF_FILE
if test 8279 -ne `wc -c <'mac/scrnmgr/ScrnMgr.r'`; then
    echo shar: \"'mac/scrnmgr/ScrnMgr.r'\" unpacked with wrong size!
fi
# end of 'mac/scrnmgr/ScrnMgr.r'
fi
if test -f 'source/potions.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/potions.c'\"
else
echo shar: Extracting \"'source/potions.c'\" \(8512 characters\)
sed "s/^X//" >'source/potions.c' <<'END_OF_FILE'
X/* source/potions.c: code for potions
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#ifdef USG
X#include <string.h>
X#else
X#include <strings.h>
X#endif
X
X/* Potions for the quaffing				-RAK-	*/
Xvoid quaff()
X{
X  int32u i, l;
X  int j, k, item_val;
X  int ident;
X  register inven_type *i_ptr;
X  register struct misc *m_ptr;
X  register struct flags *f_ptr;
X#if 0
X  /* used by ifdefed out learn_spell potion */
X  register class_type *c_ptr;
X#endif
X
X  free_turn_flag = TRUE;
X  if (inven_ctr == 0)
X    msg_print("But you are not carrying anything.");
X  else if (!find_range(TV_POTION1, TV_POTION2, &j, &k))
X    msg_print("You are not carrying any potions.");
X  else if (get_item(&item_val, "Quaff which potion?", j, k, CNIL, CNIL))
X    {
X      i_ptr = &inventory[item_val];
X      i = i_ptr->flags;
X      free_turn_flag = FALSE;
X      ident = FALSE;
X      if (i == 0)
X	{
X	  msg_print ("You feel less thirsty.");
X	  ident = TRUE;
X	}
X      else while (i != 0)
X	{
X	  j = bit_pos(&i) + 1;
X	  if (i_ptr->tval == TV_POTION2)
X	    j += 32;
X	  /* Potions						*/
X	  switch(j)
X	    {
X	    case 1:
X	      if (inc_stat (A_STR))
X		{
X		  msg_print("Wow!  What bulging muscles!");
X		  ident = TRUE;
X		}
X	      break;
X	    case 2:
X	      ident = TRUE;
X	      lose_str();
X	      break;
X	    case 3:
X	      if (res_stat (A_STR))
X		{
X		  msg_print("You feel warm all over.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 4:
X	      if (inc_stat (A_INT))
X		{
X		  msg_print("Aren't you brilliant!");
X		  ident = TRUE;
X		}
X	      break;
X	    case 5:
X	      ident = TRUE;
X	      lose_int();
X	      break;
X	    case 6:
X	      if (res_stat (A_INT))
X		{
X		  msg_print("You have have a warm feeling.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 7:
X	      if (inc_stat (A_WIS))
X		{
X		  msg_print("You suddenly have a profound thought!");
X		  ident = TRUE;
X		}
X	      break;
X	    case 8:
X	      ident = TRUE;
X	      lose_wis();
X	      break;
X	    case 9:
X	      if (res_stat (A_WIS))
X		{
X		  msg_print("You feel your wisdom returning.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 10:
X	      if (inc_stat (A_CHR))
X		{
X		  msg_print("Gee, ain't you cute!");
X		  ident = TRUE;
X		}
X	      break;
X	    case 11:
X	      ident = TRUE;
X	      lose_chr();
X	      break;
X	    case 12:
X	      if (res_stat (A_CHR))
X		{
X		  msg_print("You feel your looks returning.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 13:
X	      ident = hp_player(damroll(2, 7));
X	      break;
X	    case 14:
X	      ident = hp_player(damroll(4, 7));
X	      break;
X	    case 15:
X	      ident = hp_player(damroll(6, 7));
X	      break;
X	    case 16:
X	      ident = hp_player(1000);
X	      break;
X	    case 17:
X	      if (inc_stat (A_CON))
X		{
X		  msg_print("You feel tingly for a moment.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 18:
X	      m_ptr = &py.misc;
X	      if (m_ptr->exp < MAX_EXP)
X		{
X		  l = (m_ptr->exp / 2) + 10;
X		  if (l > 100000L)  l = 100000L;
X		  m_ptr->exp += l;
X		  msg_print("You feel more experienced.");
X		  prt_experience();
X		  ident = TRUE;
X		}
X	      break;
X	    case 19:
X	      f_ptr = &py.flags;
X	      if (!f_ptr->free_act)
X		{
X		  /* paralysis must == 0, otherwise could not drink potion */
X		  msg_print("You fall asleep.");
X		  f_ptr->paralysis += randint(4) + 4;
X		  ident = TRUE;
X		}
X	      break;
X	    case 20:
X	      f_ptr = &py.flags;
X	      if (f_ptr->blind == 0)
X		{
X		  msg_print("You are covered by a veil of darkness.");
X		  ident = TRUE;
X		}
X	      f_ptr->blind += randint(100) + 100;
X	      break;
X	    case 21:
X	      f_ptr = &py.flags;
X	      if (f_ptr->confused == 0)
X		{
X		  msg_print("Hey!  This is good stuff!  * Hick! *");
X		  ident = TRUE;
X		}
X	      f_ptr->confused += randint(20) + 12;
X	      break;
X	    case 22:
X	      f_ptr = &py.flags;
X	      if (f_ptr->poisoned == 0)
X		{
X		  msg_print("You feel very sick.");
X		  ident = TRUE;
X		}
X	      f_ptr->poisoned += randint(15) + 10;
X	      break;
X	    case 23:
X	      if (py.flags.fast == 0)
X		ident = TRUE;
X	      py.flags.fast += randint(25) + 15;
X	      break;
X	    case 24:
X	      if (py.flags.slow == 0)
X		ident = TRUE;
X	      py.flags.slow += randint(25) + 15;
X	      break;
X	    case 26:
X	      if (inc_stat (A_DEX))
X		{
X		  msg_print("You feel more limber!");
X		  ident = TRUE;
X		}
X	      break;
X	    case 27:
X	      if (res_stat (A_DEX))
X		{
X		  msg_print("You feel less clumsy.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 28:
X	      if (res_stat (A_CON))
X		{
X		  msg_print("You feel your health returning!");
X		  ident = TRUE;
X		}
X	      break;
X	    case 29:
X	      ident = cure_blindness();
X	      break;
X	    case 30:
X	      ident = cure_confusion();
X	      break;
X	    case 31:
X	      ident = cure_poison();
X	      break;
X#if 0
X	    case 33:
X	      /* this is no longer useful, now that there is a 'G'ain magic
X		 spells command */
X	      m_ptr = &py.misc;
X	      c_ptr = &class[m_ptr->pclass];
X	      if (c_ptr->spell == MAGE)
X		{
X		  calc_spells(A_INT);
X		  calc_mana(A_INT);
X		}
X	      else if (c_ptr->spell == PRIEST)
X		{
X		  calc_spells(A_WIS);
X		  calc_mana(A_WIS);
X		}
X	      else
X		{
X		  /* A warrior learns something about his equipment. -CJS- */
X		  inven_type *w_ptr;
X		  vtype tmp_str;
X		  extern char *describe_use ();
X
X		  for (k = 22; k < INVEN_ARRAY_SIZE; k++)
X		    {
X		      w_ptr = &inventory[k];
X		      if (w_ptr->tval != TV_NOTHING && enchanted (w_ptr))
X			{
X			  (void) sprintf (tmp_str,
X				  "There's something about what you are %s...",
X					  describe_use(k));
X			  msg_print (tmp_str);
X			  add_inscribe(w_ptr, ID_MAGIK);
X			  ident = TRUE;
X			}
X		    }
X		}
X	      break;
X#endif
X	    case 34:
X	      if (py.misc.exp > 0)
X		{
X		  int32 m, scale;
X		  msg_print("You feel your memories fade.");
X		  /* Lose between 1/5 and 2/5 of your experience */
X		  m = py.misc.exp / 5;
X		  if (py.misc.exp > MAX_SHORT)
X		    {
X		      scale = MAX_LONG / py.misc.exp;
X		      m += (randint((int)scale) * py.misc.exp) / (scale * 5);
X		    }
X		  else
X		    m += randint((int)py.misc.exp) / 5;
X		  lose_exp(m);
X		  ident = TRUE;
X		}
X	      break;
X	    case 35:
X	      f_ptr = &py.flags;
X	      (void) cure_poison();
X	      if (f_ptr->food > 150)  f_ptr->food = 150;
X	      f_ptr->paralysis = 4;
X	      msg_print("The potion makes you vomit!");
X	      ident = TRUE;
X	      break;
X	    case 36:
X	      if (py.flags.invuln == 0)
X		ident = TRUE;
X	      py.flags.invuln += randint(10) + 10;
X	      break;
X	    case 37:
X	      if (py.flags.hero == 0)
X		ident = TRUE;
X	      py.flags.hero += randint(25) + 25;
X	      break;
X	    case 38:
X	      if (py.flags.shero == 0)
X		ident = TRUE;
X	      py.flags.shero += randint(25) + 25;
X	      break;
X	    case 39:
X	      ident = remove_fear();
X	      break;
X	    case 40:
X	      ident = restore_level();
X	      break;
X	    case 41:
X	      f_ptr = &py.flags;
X	      if (f_ptr->resist_heat == 0)
X		ident = TRUE;
X	      f_ptr->resist_heat += randint(10) + 10;
X	      break;
X	    case 42:
X	      f_ptr = &py.flags;
X	      if (f_ptr->resist_cold == 0)
X		ident = TRUE;
X	      f_ptr->resist_cold += randint(10) + 10;
X	      break;
X	    case 43:
X	      if (py.flags.detect_inv == 0)
X		ident = TRUE;
X	      detect_inv2(randint(12)+12);
X	      break;
X	    case 44:
X	      ident = slow_poison();
X	      break;
X	    case 45:
X	      ident = cure_poison();
X	      break;
X	    case 46:
X	      m_ptr = &py.misc;
X	      if (m_ptr->cmana < m_ptr->mana)
X		{
X		  m_ptr->cmana = m_ptr->mana;
X		  ident = TRUE;
X		  msg_print("Your feel your head clear.");
X		  prt_cmana();
X		}
X	      break;
X	    case 47:
X	      f_ptr = &py.flags;
X	      if (f_ptr->tim_infra == 0)
X		{
X		  msg_print("Your eyes begin to tingle.");
X		  ident = TRUE;
X		}
X	      f_ptr->tim_infra += 100 + randint(100);
X	      break;
X	    default:
X	      msg_print ("Internal error in potion()");
X	      break;
X	    }
X	  /* End of Potions.					*/
X	}
X      if (ident)
X	{
X	  if (!known1_p(i_ptr))
X	    {
X	      m_ptr = &py.misc;
X	      /* round half-way case up */
X	      m_ptr->exp += (i_ptr->level + (m_ptr->lev >> 1)) / m_ptr->lev;
X	      prt_experience();
X
X	      identify(&item_val);
X	      i_ptr = &inventory[item_val];
X	    }
X	}
X      else if (!known1_p(i_ptr))
X	sample (i_ptr);
X
X      add_food(i_ptr->p1);
X      desc_remain(item_val);
X      inven_destroy(item_val);
X    }
X}
END_OF_FILE
if test 8512 -ne `wc -c <'source/potions.c'`; then
    echo shar: \"'source/potions.c'\" unpacked with wrong size!
fi
# end of 'source/potions.c'
fi
if test -f 'unix/unix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'unix/unix.c'\"
else
echo shar: Extracting \"'unix/unix.c'\" \(8383 characters\)
sed "s/^X//" >'unix/unix.c' <<'END_OF_FILE'
X/* unix/unix.c: UNIX dependent code.					-CJS-
X
X   Copyright (c) 1989-92 James E. Wilson, Christopher J. Stuart
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X
X/* defines NULL */
X#include <stdio.h>
X/* defines CTRL */
X#include <sys/ioctl.h>
X/* defines TRUE and FALSE */
X#include <curses.h>
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X
X#ifdef unix
X
X#if defined(SYS_V) && defined(lint)
X/* for AIX, prevent hundreds of unnecessary lint errors, must define before
X   signal.h is included */
X#define _h_IEEETRAP
Xtypedef struct { int stuff; } fpvmach;
X#endif
X
X#include <signal.h>
X
X#ifdef M_XENIX
X#include <sys/types.h>
X#include <sys/select.h>
X/* For various selects from TCP/IP.  */
X#define bzero(addr,n)	memset((char *)addr, 0, n)
X#endif
X
X#ifndef USG
X#include <sys/time.h>
X#include <sys/resource.h>
X#include <sys/types.h>
X#include <sys/param.h>
X#endif
X
X#ifdef USG
X#include <string.h>
X#if 0
X/* Used to include termio.h here, but this is unnecessary because it is
X   included in curses.h, and some systems fail when it gets included
X   twice.  */
X#include <termio.h>
X#endif
X#include <fcntl.h>
X#else
X#include <strings.h>
X#if defined(atarist) && defined(__GNUC__)
X/* doesn't have <sys/wait.h> */
X#else
X#include <sys/wait.h>
X#endif
X#endif
X
X/* This must be included after fcntl.h, which has a prototype for `open'
X   on some systems.  Otherwise, the `open' prototype conflicts with the
X   `topen' declaration.  */
X#include "externs.h"
X
X#include <pwd.h>
X#include <sys/errno.h>
X
X#ifdef USG
Xstruct passwd *getpwuid();
Xstruct passwd *getpwnam();
X#endif
X
X#if defined(SYS_V) && defined(lint)
Xstruct screen { int dumb; };
X#endif
X
X/* Fooling lint. Unfortunately, c defines all the TIO constants to be long,
X   and lint expects them to be int. Also, ioctl is sometimes called with just
X   two arguments. The following definition keeps lint happy. It may need to be
X   reset for different systems. */
X#ifdef lint
X#ifdef Pyramid
X/* Pyramid makes constants greater than 65535 into long! Gakk! -CJS- */
X/*ARGSUSED*/
X/*VARARGS2*/
Xstatic Ioctl(i, l, p) long l; char *p; { return 0; }
X#else
X/*ARGSUSED*/
X/*VARARGS2*/
Xstatic Ioctl(i, l, p) char *p; { return 0; }
X#endif
X#define ioctl	    Ioctl
X#endif
X
X/* Provides for a timeout on input. Does a non-blocking read, consuming the
X   data if any, and then returns 1 if data was read, zero otherwise.
X
X   Porting:
X
X   In systems without the select call, but with a sleep for
X   fractional numbers of seconds, one could sleep for the time
X   and then check for input.
X
X   In systems which can only sleep for whole number of seconds,
X   you might sleep by writing a lot of nulls to the terminal, and
X   waiting for them to drain, or you might hack a static
X   accumulation of times to wait. When the accumulation reaches a
X   certain point, sleep for a second. There would need to be a
X   way of resetting the count, with a call made for commands like
X   run or rest. */
Xint check_input(microsec)
Xint microsec;
X{
X#if defined(USG) && !defined(M_XENIX)
X  int arg, result;
X#else
X  struct timeval tbuf;
X  int ch;
X#if defined(BSD4_3) || defined(M_XENIX)
X  fd_set smask;
X#else
X  int smask;
X#endif
X#endif
X
X  /* Return true if a read on descriptor 1 will not block. */
X#if !defined(USG) || defined(M_XENIX)
X  tbuf.tv_sec = 0;
X  tbuf.tv_usec = microsec;
X#if defined(BSD4_3) || defined(M_XENIX)
X  FD_ZERO(&smask);
X  FD_SET(fileno(stdin), &smask);
X  if (select(1, &smask, (fd_set *)0, (fd_set *)0, &tbuf) == 1)
X#else
X  smask = 1;  /* i.e. (1 << 0) */
X  if (select(1, &smask, (int *)0, (int *)0, &tbuf) == 1)
X#endif
X    {
X      ch = getch();
X      /* check for EOF errors here, select sometimes works even when EOF */
X      if (ch == -1)
X	{
X	  eof_flag++;
X	  return 0;
X	}
X      return 1;
X    }
X  else
X    return 0;
X#else /* SYS V code follows */
X  if (microsec != 0 && (turn & 0x7F) == 0)
X    (void) sleep (1); /* mod 128, sleep one sec every 128 turns */
X  /* Can't check for input, but can do non-blocking read, so... */
X  /* Ugh! */
X  arg = 0;
X  arg = fcntl(0, F_GETFL, arg);
X  arg |= O_NDELAY;
X  (void) fcntl(0, F_SETFL, arg);
X
X  result = getch();
X
X  arg = 0;
X  arg = fcntl(0, F_GETFL, arg);
X  arg &= ~O_NDELAY;
X  (void) fcntl(0, F_SETFL, arg);
X  if (result == -1)
X    return 0;
X  else
X    return 1;
X#endif
X}
X
X#if 0
X/* This is not used, however, this should be compared against shell_out
X   in io.c */
X
X/* A command for the operating system. Standard library function
X   'system' is unsafe, as it leaves various file descriptors
X   open. This also is very careful with signals and interrupts,
X   and does rudimentary job control, and puts the terminal back
X   in a standard mode. */
Xint system_cmd(p)
Xchar *p;
X{
X  int pgrp, pid, i, mask;
X  union wait w;
X  extern char *getenv();
X
X  mask = sigsetmask(~0);	/* No interrupts. */
X  restore_term();		/* Terminal in original state. */
X  /* Are we in the control terminal group? */
X  if (ioctl(0, TIOCGPGRP, (char *)&pgrp) < 0 || pgrp != getpgrp(0))
X    pgrp = -1;
X  pid = fork();
X  if (pid < 0)
X    {
X      (void) sigsetmask(mask);
X      moriaterm();
X      return -1;
X    }
X  if (pid == 0)
X    {
X      (void) sigsetmask(0);	/* Interrupts on. */
X      /* Transfer control terminal. */
X      if (pgrp >= 0)
X	{
X	  i = getpid();
X	  (void) ioctl(0, TIOCSPGRP, (char *)&i);
X	  (void) setpgrp(i, i);
X	}
X      for(i = 2; i < 30; i++)
X	(void) close(i);	/* Close all but standard in and out.*/
X      (void) dup2(1, 2);	/* Make standard error as standard out. */
X      if (p == 0 || *p == 0)
X	{
X	  p = getenv("SHELL");
X	  if (p)
X	    execl(p, p, 0);
X	  execl("/bin/sh", "sh", 0);
X	}
X      else
X	execl("/bin/sh", "sh", "-c", p, 0);
X      _exit(1);
X    }
X  /* Wait for child termination. */
X  for(;;)
X    {
X      i = wait3(&w, WUNTRACED, (struct rusage *)0);
X      if (i == pid)
X	{
X	  if (WIFSTOPPED(w))
X	    {
X	      /* Stop outselves, if child stops. */
X	      (void) kill(getpid(), SIGSTOP);
X	      /* Restore the control terminal, and restart subprocess. */
X	      if (pgrp >= 0)
X		(void) ioctl(0, TIOCSPGRP, (char *)&pid);
X	      (void) killpg(pid, SIGCONT);
X	    }
X	  else
X	    break;
X	}
X    }
X  /* Get the control terminal back. */
X  if (pgrp >= 0)
X    (void) ioctl(0, TIOCSPGRP, (char *)&pgrp);
X  (void) sigsetmask(mask);	/* Interrupts on. */
X  moriaterm();			/* Terminal in moria mode. */
X  return 0;
X}
X#endif
X
X#ifdef USG
Xunsigned short getuid();
X#else
X#ifndef SECURE
X#ifdef BSD4_3
Xuid_t getuid();
X#else  /* other BSD versions */
Xint getuid();
X#endif
X#endif
X#endif
X
X/* Find a default user name from the system. */
Xvoid user_name(buf)
Xchar *buf;
X{
X  extern char *getlogin();
X  char pwline[256];
X  register char *p;
X
X  p = getlogin();
X  if (p && p[0])
X    (void) strcpy(buf, p);
X  else
X    {
X      (void) getpw((int)getuid(), pwline);
X      p = index(pwline, ':');
X      if (p)
X	*p = 0;
X      (void) strcpy(buf, pwline);
X    }
X  if (!buf[0])
X    (void) strcpy(buf, "X");	/* Gotta have some name */
X}
X
X/* expands a tilde at the beginning of a file name to a users home
X   directory */
Xint tilde(file, exp)
Xchar *file, *exp;
X{
X  *exp = '\0';
X  if (file)
X    {
X      if (*file == '~')
X	{
X	  char user[128];
X	  struct passwd *pw = NULL;
X	  int i = 0;
X
X	  user[0] = '\0';
X	  file++;
X	  while (*file != '/' && i < sizeof(user))
X	    user[i++] = *file++;
X	  user[i] = '\0';
X	  if (i == 0)
X	    {
X	      char *login = (char *) getlogin();
X
X	      if (login != NULL)
X		(void) strcpy (user, login);
X	      else if ((pw = getpwuid(getuid())) == NULL)
X		return 0;
X	    }
X	  if (pw == NULL && (pw = getpwnam(user)) == NULL)
X	    return 0;
X	  (void) strcpy (exp, pw->pw_dir);
X	}
X      (void) strcat(exp, file);
X      return 1;
X    }
X  return 0;
X}
X
X/* undefine these so that tfopen and topen will work */
X#undef fopen
X#undef open
X
X/* open a file just as does fopen, but allow a leading ~ to specify a home
X   directory */
XFILE *tfopen(file, mode)
Xchar *file;
Xchar *mode;
X{
X  char buf[1024];
X  extern int errno;
X
X  if (tilde(file, buf))
X    return (fopen(buf, mode));
X  errno = ENOENT;
X  return NULL;
X}
X
X/* open a file just as does open, but expand a leading ~ into a home directory
X   name */
Xint topen(file, flags, mode)
Xchar *file;
Xint flags, mode;
X{
X  char buf[1024];
X  extern int errno;
X
X  if (tilde(file, buf))
X    return (open(buf, flags, mode));
X  errno = ENOENT;
X  return -1;
X}
X#endif
END_OF_FILE
if test 8383 -ne `wc -c <'unix/unix.c'`; then
    echo shar: \"'unix/unix.c'\" unpacked with wrong size!
fi
# end of 'unix/unix.c'
fi
echo shar: End of archive 33 \(of 39\).
cp /dev/null ark33isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
