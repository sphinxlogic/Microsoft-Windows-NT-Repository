Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i067:  umoria4 - single player dungeon simulation (ver. 5.5), Part35/39
Message-ID: <3431@master.CNA.TEK.COM>
Date: 22 Aug 92 22:15:28 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1707
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 67
Archive-name: umoria4/Part35
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 35 (of 39)."
# Contents:  atari_st/curscomp/curses.h doc/exp.doc mac/Install.hqx
#   mac/dumpres/DumpRes.c mac/machelp.c misc/moria.msg source/help.c
#   util/printit/pr_items.c util/weapons/calchits.c
# Wrapped by billr@saab on Thu Aug 20 09:11:35 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'atari_st/curscomp/curses.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'atari_st/curscomp/curses.h'\"
else
echo shar: Extracting \"'atari_st/curscomp/curses.h'\" \(6490 characters\)
sed "s/^X//" >'atari_st/curscomp/curses.h' <<'END_OF_FILE'
X/****************************************************************************/
X/*                                                                          */
X/*   CURSES.H                      include file for programs using CURSES   */
X/*                                                                          */
X/****************************************************************************/
X/*                                                                          */
X/* This source and resulting object may be modified, used or distributed by */
X/* anyone who so desires under the following conditions :                   */
X/*                                                                          */
X/*  1) This notice and the copyright notice shall not be removed or         */
X/*     changed.                                                             */
X/*  2) No credit shall be taken for this source and resulting objects       */
X/*  3) This source or resulting objects is not to be traded, sold or        */
X/*     used for personal gain or profit.                                    */
X/*  4) Inclusion of this source or resulting objects in commercially        */
X/*     available packages is forbidden without written consent of the       */
X/*     author of this source.                                               */
X/*                                                                          */
X/****************************************************************************/
X
X#include "stdio.h"
X
Xtypedef unsigned char bool;
Xtypedef short         int16;
Xtypedef long          int32;
X
X#define OK          1
X#define ERR         0
X#define TRUE        1
X#define FALSE       0
X#define _SUBWIN     01
X#define _ENDLINE    02
X#define _FULLWIN    04
X#define _SCROLLWIN  010
X#define _STANDOUT   0200
X#define WINDOW      struct _win_st
X
X#define TOUCHED     0x0200
X#define STANDOUT    0x0100
X
X/* prototypes of functions in curses.c */
XWINDOW *initscr ( void );
Xvoid endwin ( void );
XWINDOW *newwin ( int l , int c , int by , int bx );
Xvoid delwin ( WINDOW *w );
Xint mvwin ( WINDOW *w , int y , int x );
Xvoid touchwin ( WINDOW *w );
XWINDOW *subwin ( WINDOW *w , int l , int c , int by , int bx );
Xvoid leaveok ( WINDOW *w , bool f );
Xvoid scrollok ( WINDOW *w , bool f );
Xvoid nl ( void );
Xvoid nonl ( void );
Xvoid longname ( char *termbuf , char *name );
Xint  waddch ( WINDOW *w , char c );
Xint  waddstr ( WINDOW *w , char *s );
Xvoid box ( WINDOW *w , char v , char h );
Xvoid wclear ( WINDOW *w );
Xvoid wclrtobot ( WINDOW *w );
Xvoid wclrtoeol ( WINDOW *w );
Xint  wdelch ( WINDOW *w );
Xint  wdeleteln ( WINDOW *w );
Xvoid werase ( WINDOW *w );
Xint  winsch ( WINDOW *w , char c );
Xvoid winsertln ( WINDOW *w );
Xint  wmove ( WINDOW *w , int y , int x );
Xvoid overlay ( WINDOW *v , WINDOW *w );
Xvoid overwrite ( WINDOW *v , WINDOW *w );
Xvoid wstandout ( WINDOW *w );
Xvoid wstandend ( WINDOW *w );
Xvoid raw ( void );
Xvoid noraw ( void );
Xvoid crmode ( void );
Xvoid nocrmode ( void );
Xvoid echo ( void );
Xvoid noecho ( void );
Xlong wgetch ( WINDOW *w );
Xint  wgetstr ( WINDOW *w , char *s );
Xvoid wrefresh ( WINDOW *w );
Xvoid mvcur ( int ly , int lx , int ny , int nx );
Xvoid _movcur ( int16 y , int16 x );
Xint  scroll ( WINDOW *w );
X/* end of prototypes for curses.c */
X
X#define addch(c)            waddch(stdscr, c)
X#if 0
X/* The original code, does not return error codes properly.  */
X#define mvaddch(y,x,c)      { wmove(stdscr,y,x) ; waddch(stdscr,c) ; }
X#define mvwaddch(w,y,x,c)   { wmove(w,y,x) ; waddch(w,c) ; }
X#else
X#define mvaddch(y,x,c)      (wmove(stdscr,y,x) == ERR ? ERR : waddch(stdscr,c))
X#define mvwaddch(w,y,x,c)   (wmove(w,y,x) == ERR ? ERR : waddch(w,c))
X#endif
X#define addstr(s)           waddstr(stdscr,s)
X#if 0
X/* The original code, does not return error codes properly.  */
X#define mvaddstr(y,x,s)     { wmove(stdscr,y,x) ; waddstr(stdscr,s) ; }
X#define mvwaddstr(w,y,x,s)  { wmove(w,y,x) ; waddstr(w,s) ; }
X#else
X#define mvaddstr(y,x,s)     (wmove(stdscr,y,x) == ERR ? ERR :waddstr(stdscr,s))
X#define mvwaddstr(w,y,x,s)  (wmove(w,y,x) == ERR ? ERR : waddstr(w,s))
X#endif
X#define clear()             wclear(stdscr)
X#define clearok(w,f)        { w->_clear = (w->_flags & _FULLWIN) ? f : \
X                              w->_clear ; }
X#define clrtobot()          wclrtobot(stdscr)
X#define clrtoeol()          wclrtoeol(stdscr)
X#define delch()             wdelch(stdscr)
X#define mvdelch(y,x)        { wmove(stdscr,y,x) ; wdelch(stdscr) ; }
X#define mvwdelch(w,y,x)     { wmove(w,y,x) ; wdelch(w) ; }
X#define deleteln()          wdeleteln(stdscr)
X#define mvdeleteln(y,x)     { wmove(stdscr,y,x) ; wdeleteln(stdscr) ; }
X#define mvwdeleteln(w,y,x)  { wmove(w,y,x) ; wdeleteln(w) ; }
X#define erase()             werase(stdscr)
X#define insch(c)            winsch(stdscr,c)
X#define mvinsch(y,x,c)      { wmove(stdscr,y,x) ; winsch(stdscr,c) ; }
X#define mvwinsch(w,y,x,c)   { wmove(w,y,x) ; winsch(w,c) ; }
X#define insertln()          winsertln(stdscr)
X#define mvinsertln(y,x)     { wmove(stdscr,y,x) ; winsertln(stdscr) ; }
X#define mvwinsertln(w,y,x)  { wmove(w,y,x) ; winsertln(w) ; }
X#define move(y,x)           wmove(stdscr,y,x)
X#define refresh()           wrefresh(stdscr)
X#define standout()          wstandout(stdscr)
X#define standend()          wstandend(stdscr)
X#define getch()             wgetch(stdscr)
X#define mvgetch(y,x)        ( wmove(stdscr,y,x) , wgetch(stdscr) )
X#define mvwgetch(w,y,x)     ( wmove(w,y,x) , wgetch(w) )
X#define getstr(s)           wgetstr(stdscr,s)
X#define mvgetstr(y,x,s)     { wmove(stdscr,y,x) ; wgetstr(stdscr,s) ; }
X#define mvwgetstr(w,y,x,s)  { wmove(w,y,x) ; wgetstr(w,s) ; }
X#define getyx(w,y,x)        { y = w->_cury ; x = w->_curx ; }
X#define inch()              ( stdscr->_y[stdscr->_cury][stdscr->_curx])
X#define mvinch(y,x)         ( wmove(stdscr,y,x) , \
X                              stdscr->_y[stdscr->_cury][stdscr->_curx])
X#define mvwinch(w,y,x)      ( wmove(w,y,x) , w4->_y[w->_cury][w->_curx])
X#define winch(w)            (w->_y[w->_cury][w->_curx])
X
Xstruct _win_st 
X{
X  int16 _cury, _curx ;
X  int16 _maxy, _maxx ;
X  int16 _begy, _begx ;
X  int16 _flags ;
X  bool  _clear ;
X  bool  _leave ;
X  bool  _scroll ;
X  int16 **_y ;
X  int16 *_firstch ;
X  int16 *_lastch ;
X  int16 *_yend;
X};
X
Xextern WINDOW *curscr;
Xextern WINDOW *stdscr;
Xextern char   *Def_term;
Xextern bool   My_term;
Xextern char   *ttytype;
Xextern int    LINES;
Xextern int    COLS;
X/****************END OF SOURCE CURSES.H************************************/
END_OF_FILE
if test 6490 -ne `wc -c <'atari_st/curscomp/curses.h'`; then
    echo shar: \"'atari_st/curscomp/curses.h'\" unpacked with wrong size!
fi
# end of 'atari_st/curscomp/curses.h'
fi
if test -f 'doc/exp.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/exp.doc'\"
else
echo shar: Extracting \"'doc/exp.doc'\" \(6074 characters\)
sed "s/^X//" >'doc/exp.doc' <<'END_OF_FILE'
XAddendum to the Moria manual
X
XProposed Contribution.  Written by Mike Marcelais
X                                   North Carolina School of
X                                         Science And Math
X                                   mrm@odin.ncssm.edu
X                                   games@odin.ncssm.edu
X
X1.  Experience
X
XAll characters receive experience during the game.  Experience
Xdetermines your level, which determines hit points, mana points,
Xspells, abilities, etc.  The amount of experience required to 
Xadvance a level is a base value (shown below) plus a penalty
Xfor race and class.
X
X1.1  Calculating Experience Levels
X
XBase Experience
X
XLv   Exp to Adv     Lv   Exp to Adv     Lv   Exp to Adv
X 1      10          14    1,400         27      35,000
X 2      25          15    1,800         28      50,000
X 3      45          16    2,300         29      75,000
X 4      70          17    2,900         30     100,000
X 5     100          18    3,600         31     150,000
X 6     140          19    4,400         32     200,000
X 7     200          20    5,400         33     300,000
X 8     280          21    6,800         34     400,000
X 9     380          22    8,400         35     500,000
X10     500          23   10,200         36     750,000
X11     650          24   12,500         37   1,500,000
X12     850          25   17,500         38   2,500,000
X13   1,100          26   25,000         39   5,000,000
X
XMaximum level is 40 and maximum experience is 9,999,999
X
XThere are percent penalties for various races and classes to
Xhelp even them out.  The table below lists all the penalties.
X
X      Human       0%     Warrior    0%
X      Half-Elf   10%     Mage      30%
X      Elf        20%     Priest    20%
X      Halfling   10%     Rogue      0%
X      Gnome      25%     Ranger    40%
X      Dwarf      20%     Paladin   35%
X      Half-Orc   10%
X      Half-Troll 20%
X
XFor example:  For a 10'th level Gnomish Mage to achieve 11'th level
Xneeds:
X           500 *  1.25 * 1.30 = 812.5
X         (base) (gnome) (mage)
X
XNote:  Even for the worst case (Gnomish Ranger) it is still possible
Xto achieve the 40th level.  (5,000,000*1.25*1.40=8,750,000 experience)
X
XThe program internally keeps experience out to the fourth decimal place
Xeven though it only displays the integer portion on the screen.
X
X1.2  Getting Experience
X
XThere are many ways to gain experience.  This list shows a few.
X
X1.  Defeating monsters
X2.  Disarming traps
X3.  Picking locks
X4.  Using a scroll, potion, staff, wand, or rod for the first time
X      and discovering what it did.
X5.  Casting a spell successfully for the first time.
X6.  Drinking a potion of gain experience or gain level
X
X1.3  Titles
X
XEach experience level has a title which is displayed under your name
Xand class.  Below is a listing of all the titles for each level and
Xclass.
X
X   Warrior      Mage         Priest       Rogue        Ranger       Paladin
X 1 Rookie       Novice       Believer     Vagabond     Runner(1st)  Gallant
X 2 Private      Apprentice   Acolyte(1st) Footpad      Runner(2nd)  Keeper(1st)
X 3 Soldier      Trickster-1  Acolyte(2nd) Cutpurse     Runner(3rd)  Keeper(2nd)
X 4 Mercenary    Trickster-2  Acolyte(3rd) Robber       Strider(1st) Keeper(3rd)
X 5 Veteran(1st) Trickster-3  Adept(1st)   Burglar      Strider(2nd) Keeper(4th)
X 6 Veteran(2nd) Cabalist-1   Adept(2nd)   Filcher      Strider(3rd) Keeper(5th)
X 7 Veteran(3rd) Cabalist-2   Adept(3rd)   Sharper      Scout(1st)   Keeper(6th)
X 8 Warrior(1st) Cabalist-3   Priest(1st)  Magsman      Scout(2nd)   Keeper(7th)
X 9 Warrior(2nd) Visionist    Priest(2nd)  Common Rogue Scout(3rd)   Keeper(8th)
X10 Warrior(3rd) Phantasmist  Priest(3rd)  Rogue(1st)   Scout(4th)   Keeper(9th)
X11 Warrior(4th) Shadowist    Priest(4th)  Rogue(2nd)   Scout(5th)   Protector-1
X12 Swordsman-1  Spellbinder  Priest(5th)  Rogue(3rd)   Courser(1st) Protector-2
X13 Swordsman-2  Illusionist  Priest(6th)  Rogue(4th)   Courser(2nd) Protector-3
X14 Swordsman-3  Evoker(1st)  Priest(7th)  Rogue(5th)   Courser(3rd) Protector-4
X15 Hero         Evoker(2nd)  Priest(8th)  Rogue(6th)   Courser(4th) Protector-5
X16 Swashbuckler Evoker(3rd)  Priest(9th)  Rogue(7th)   Courser(5th) Protector-6
X17 Myrmidon     Evoker(4th)  Curate(1st)  Rogue(8th)   Tracker(1st) Protector-7
X18 Champion-1   Conjurer     Curate(2nd)  Rogue(9th)   Tracker(2nd) Protector-8
X19 Champion-2   Theurgist    Curate(3rd)  Master Rogue Tracker(3rd) Defender-1
X20 Champion-3   Thaumaturge  Curate(4th)  Expert Rogue Tracker(4th) Defender-2
X21 Superhero    Magician     Curate(5th)  Senior Rogue Tracker(5th) Defender-3
X22 Knight       Enchanter    Curate(6th)  Chief Rogue  Tracker(6th) Defender-4
X23 Superior Knt Warlock      Curate(7th)  Prime Rogue  Tracker(7th) Defender-5
X24 Gallant Knt Sorcerer     Curate(8th)  Low Thief    Tracker(8th) Defender-6
X25 Knt Errant   Necromancer  Curate(9th)  Thief(1st)   Tracker(9th) Defender-7
X26 Guardian Knt Mage(1st)    Canon(1st)   Thief(2nd)   Guide(1st)   Defender-8
X27 Baron        Mage(2nd)    Canon(2nd)   Thief(3rd)   Guide(2nd)   Warder(1st)
X28 Duke         Mage(3rd)    Canon(3rd)   Thief(4th)   Guide(3rd)   Warder(2nd)
X29 Lord(1st)    Mage(4th)    Canon(4th)   Thief(5th)   Guide(4th)   Warder(3rd)
X30 Lord(2nd)    Mage(5th)    Canon(5th)   Thief(6th)   Guide(5th)   Warder(4th)
X31 Lord(3rd)    Wizard(1st)  Low Lama     Thief(7th)   Guide(6th)   Warder(5th)
X32 Lord(4th)    Wizard(2nd)  Lama-1       Thief(8th)   Guide(7th)   Warder(6th)
X33 Lord(5th)    Wizard(3rd)  Lama-2       Thief(9th)   Guide(8th)   Warder(7th)
X34 Lord(6th)    Wizard(4th)  Lama-3       High Thief   Guide(9th)   Warder(8th)
X35 Lord(7th)    Wizard(5th)  High Lama    Master Thief Pathfinder-1 Warder(9th)
X36 Lord(8th)    Wizard(6th)  Great Lama   Executioner  Pathfinder-2 Guardian
X37 Lord(9th)    Wizard(7th)  Patriarch    Low Assassin Pathfinder-3 Chevalier
X38 Lord Gallant Wizard(8th)  High Priest  Assassin     Ranger       Justiciar
X39 Lord Keeper  Wizard(9th)  Great Priest High AssassinHigh Ranger  Paladin
X40 Lord Noble   Wizard Lord  Noble Priest Guildmaster  Ranger Lord  High Lord
END_OF_FILE
if test 6074 -ne `wc -c <'doc/exp.doc'`; then
    echo shar: \"'doc/exp.doc'\" unpacked with wrong size!
fi
# end of 'doc/exp.doc'
fi
if test -f 'mac/Install.hqx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/Install.hqx'\"
else
echo shar: Extracting \"'mac/Install.hqx'\" \(4447 characters\)
sed "s/^X//" >'mac/Install.hqx' <<'END_OF_FILE'
X(This file must be converted with BinHex 4.0)
X:"dPZFh4KE'`!9%9B9%e38b!"!!!!#a%!!!&q)bdM#8PZGQpMBA4TEfik#3P*ER0
XdB@aX)'4TFh4bD@*eG'P[EN4TFQ9MG'pbH5"LG@PXC%4TFQ9MG'pbH3dM$5-*9'K
XTFb"cBh*TF(3JFQ9QEh*YBA4c)'&XE#"QD@aPFb"bC@0PDACPC#"KFb"`BA*d)'p
XQ)(4SC5"cEh9bBf8JC'PcG(*TBR9dD@pZ$5-*CQpb)%e[FQPK,L!J5A3JG'KPEL"
XYEhCPFb"[EQaj)(4SC5"QD@aPFb"ZC@0PFh0KFRNJCQpb)'*eD@aND@jR)(4SC5"
XRB@eP)'PZG'm0)`PK)'*eD@aN)'4TFQ9MG'pbH5!SF'pcFfPLE(NJBh*PBA4TEQF
XJDA3T,JdM$5-*9d&56NP14cS*9'KTFb"cBh*TF(3JFh9QCQ9bFb"QFQpY)'%JEQ&
XcG(NJCQpbE5"[CL"cC@aQ,A*PCQ9bC@jMC5iJ)&4[)(GTG#`0)`N*#3P[EQ8JEfB
XJDA4c)("eFR"[Ff9c)'Pc)(4[)(*PCQpbE@&d)'&XE#"dCAKd)'CTE'9c)'PZ)(4
XSC5"YEh*TB3dM#3N*#A0[GA*MC5"bC@aPBA0P,#"KEQ3JDA3JDA-JDA4cC@aQ)'%
XJG'9iG#"QD@aP)'PZ)(4SC5"YEh*TB5"cEh9bBf80)`N*#3PbC@aPBA0P,L!J9'm
XJBAC[D@3JG'KP)("[G'9ZG'PKE#"dFQpeBQaP)(4SDA-JBh*PBA4PFb`JC(9`E'P
XMBA4P$5-*#3N*G'KTFb"QD@aP)'PZG'mJFfpYC5"ZEfiYE@pbD@%JC'PbC@0dEh*
Xj)#Kl69"AI5"TFb"K)'G[Ef3JBfK[D@0P+5`0)`N*#3PbG@iJG'KP)'0[F(NX)(4
XSC@iJC'9XCA4P)'Pd)'&QG'9b)'0[EA"XCA4TEfiZ$3dM#80SC@0V)(4SC5"eFf&
XRC5i05@BJ+%j[G#!LHc&p)LNJI(`J+%j[G#!LHc*p)LN0#89MD'mJ)L-M)b"l-(d
Xk)&9cB@GP)#dJHc"p)'4TFh4bD@*eG'P[EN4TFL"LG@PXC%4TFL)0#89iDA3J-3e
X&EQ30$5-*9(*j)(4[)'4PG'9bE@PZC5"hD'&d)'4TFQ9MG'pbH5"dD'8JE@pbD@%
XJC'PbC@0dEh*j)'Pc,Je*CL"1Eh3J)Q"&H'PcG(-J,@3J)RXaI5*J)Jd*4@0SEb!
XL5@jcG'&XE$SJYL*l-Aff)L"TFb"ZEh3JB5"NDA*PBh4[FRNZ)Jd*4AKTG#!a$89
XZC!e6CA3J6faN4'Pb)#*J4'PbC@0dEh*j)#eaB#)04'PbC@0dEh*j)#*l-AdL$90
XPG#"%DA0d4'Pb)#*J4'PbC@0dEh*j)#eaB#)04'PbC@0dEh*j)#*l6faN4'PbI5)
X0$5-*3fKPBfXJG'mJFf9P)'PQ)(4SDA-JC'PbC@0dEh*j)'0[G@aN)'*P)(*TCfK
Xd,Je*CL"1Eh3J)Q"&H'PcG(-J,@BJ)RY%DA0d4'PbI5*YB@-k5@jcG'&XE'!L$3P
X&BfK[)#)M)b-JHc"p1L#f)RY%DA0d4'PbIEBL)'Pc)'j[G#"dD'8JE@pbD@%JC'P
XbC@0dEh*j,L)0#89iDA3J-3e&EQ30$5-*3h*PBA4P)(4SC5"LG@PXC#"NDA*PBh4
X[FRNJD@BJEQ9MCA0cBA*j,Je*CL"1Eh3J)Q"&H'PcG(-J,@3J)RXbI5*J)Jd*6Q9
Xh4QpXC'9b)#*l-RdL$89ZC!d0)`P(CA3JG'KP)'*eD@aN)'4TFQ9MG'pbH5"`BA4
XS,Je6CA3J6faN4'Pb)#*J4'PbC@0dEh*j)#eaB#)04'PbC@0dEh*j)#*l-RdL$90
XPG#"#G@PXC%4TFL!LB%4TFQ9MG'pbH5!YF@!L$84TFQ9MG'pbH5!LHdpXC%4TFRd
XL$3dM#80KE'0eE'&dC5"dD'8JC'9QBA9XG#"hD@jNEhFJF'pcDA4TEfiJB@jN)(0
XTHQ8Z$5-*5@BJ6Q9h9fPZC'ph8Q9MG#"fBA*TB@*XC5"SBA-JBQ9PEL"cCA3JBRN
XJGA0PFL`JGA0P)'Pd,JdM#8pdD'9bGfPcC5"NC@CKG@ad)(4[)(4SC5"08&FJ)R0
XdB@jNBA*N)L"cDATP,Je*CL!LHdjPGeGTEQ4[Ge*PBh4p)L!pIL![+-8TU$!X+-8
XTU$%X+-8TU$)X+-8TU$-[$3P6CA3J9fPZ9'p`)(ZS-(d0#90PG#"AD@j-C@Cd)(Z
XS-Ad0#89fB@aeBA4P)&GTENKPD@GSG#!p)(ZS-RdJ,5"lU$"p$3P&GQ&XG@&dC5"
XAD@jAD@4dD#!p)(ZS-hdJ,5"lU$&p$89XFf80#90PG#"AD@j8Eh!J-6!0#90PG#"
XAD@j-C@Cd)$%`$3P6CA3J9fPZ5'9TCfKd)$)h-!d*8f9d)&GTEPGTC(4S)$3h-!e
X&EQ30$5-*4f9d)'C[ER3JB@jN)(0THQ8JD@jQEbi05@BJ6Qpd)#*l4QpZG(dL$3P
X6CA3J4QpZG#"0EfjKBfm04@jN$8PQ)%j[G#!LHdC[ER46DATPI5)0#90PG#"'Efj
Xd8fPkC5!j$89ZC!d0)`P(Eb"dD(*[G@GS)'&XE#"QD@aPFb"TEL"NDA0dFQPLGA4
XTEfiZ$5-*8f9d)'CTE'8JBh*PBA4[FL`JGfPZC'ph)("[FfPdD@pZ,#"KEQ3JG'&
XL)(0THQ8JCQpb)'9KBfJZ$8C[FL"'D@aP6Q&YC5"TEL"J4QPXCA-J,A)J,@BJ,@m
XJ,A-J)RY%DA0d4'PbI5*J$3P*CL!LHdCTE'91B@ePI5)J2AiJ,hY%DA0d4'PbI@e
XKBcV&,`d*#8PQ)#*l4QPXC8jKE@9p)L!K25!LHd4TFh4%DA*pE@&M1QeKBfP[,Q-
XL$3N*#90PG#"8B@)J0!d*#89XFf80#3N*8f9d)&4KBL!i$3N*4@jN$3P&E(0P$3N
X*8f9d)&4KBL!i$3P&EQ30#90PG%CTE'8J,@-J*de38b!R)#ed)#G849K8*b!LHdC
XTE'91B@ePI5)0#8p`C@iJ,A3J)RY'D@aP6Q&YCAdL$3P*CL!LB%e[GQ9AD@jNEhG
XJ)L!KIL![6@pfC9GTEQ4[Gb"l9fPZ6'9QG(dJHeGTEP4[F(h&,`d*#8e[GQ9AD@j
XNEhFJHeGTENaPCR4p)(YAD@j8Eh"p$3P&EQ30#8PQ)#*J8fPkC9GTEQ4[Gf!L)#&
Xq)#p6DATP9fPZC'ph)(YAD@jAD@4dD(dJHeGTENKPD@GSG(h&,`d*#90THQ9AD@j
XNEhFJHeGTEPGTC(4SI5"l9fPZ5'9TCfKdI3d*4@jN$3P'Eh*YBA3J,@BJ)RY'Efj
XdI5)J,A-J)RY'Efjd8fPkCAdL)#ed)#*l9'&LI5)0#80XEh0P$89ZC!d0)`P0EhC
XP)'jPC@4PC#"QD@aPFb"dEb"dD'8JBR9TE'3JC'PbC@0dEh*j,Je6CA3J4NaTFh3
XJ)L)08f9d)%C-DA0d)#*l4NaTFh4p)'"'D@aPFb!YCL!YEb!YFb!LHd4TFh4%DA*
Xp)QeKBf!L$90PG#"'6'PcG#!LHdC-DA0dI5"J4QPXCA-J,@BJ,@mJ,A-J)RY%DA0
Xd4'PbI5*cEh9bBf9J)Je6CA3J4NaTFh3J)RY'6'PcG(dJB%CTE'9c)#eQ)#e[)#e
Xc)#*l4'PcG%4TFRdLCQPXCA-kE@&MB#)08f9d)%C-DA0d)#*l4NaTFh4p)'"'D@a
XPFb!YCL!YEb!YFb!LHd4TFh4%DA*p)QCTE'9cB#)05@BJ)RY'6'PcG(dL$3P0EhC
XP)#eZ#AY'6'PcG(d*)RY#G@PXC%4TFRdL$89ZC!d0D*-!!!%!!!!"6!!!!%`!!!!
XbG(*TFb"SD@GS)(0MEh*PF`e'E6SJ8h"PBh4bG@dJ5'm(5@jcG'&XE!)!!!"849K
X869"6)!%!!!!!!!!!!!"8XJ!!9%9B9%e38b!"!!!!!!!!!#cb!!!!!!!!!!!!!!!
X!!!+L$"cl!!!,%3!!!AiJF'aKH@9bFb"QD@jN)(4SBA3JG'KPDA)J6@&M)%P*)(0
XMEh*P)'Pc)'a[Gf9b)(4SB@iJG'KPDA)JFf0[FQ9c)'C[FJedD'8JBQaKBfXYB@j
XN,AGSDA4P)(CPFR0TEfjc,L!J55"KG(4bD@*eG'8JG'KTFb"dEb"NDA0dFQ&MG'P
X[!!!!5!!*6@pZB@0[!!-!13!$!$S!!`*2!!-#93!1!!!!$J!*!!i!"J!%!$i!$`(
X6!R-!2J!2!G-#Fk)0eV!!!!!!!!!!!!!!"fi"!!!!!3!!!!&-!!!!6!!!!$)!(X5
Xd"lJ!!!!F!$)!!%e38e)!!!!+!qhrr`!!!!!!(mH%TZN:
END_OF_FILE
if test 4447 -ne `wc -c <'mac/Install.hqx'`; then
    echo shar: \"'mac/Install.hqx'\" unpacked with wrong size!
fi
# end of 'mac/Install.hqx'
fi
if test -f 'mac/dumpres/DumpRes.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/dumpres/DumpRes.c'\"
else
echo shar: Extracting \"'mac/dumpres/DumpRes.c'\" \(5368 characters\)
sed "s/^X//" >'mac/dumpres/DumpRes.c' <<'END_OF_FILE'
X/* mac/dumpres/DumpRes.c: convert C data to resources and dump to file
X
X   Copyright (c) 1989-1991 Curtis McCauley, James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include <StdIO.h>
X#include <String.h>
X#ifndef THINK_C
X#include <Strings.h>
X#endif
X#include <SetJmp.h>
X
X#ifndef THINK_C
X#include <Types.h>
X#include <Memory.h>
X#include <OSUtils.h>
X#include <Resources.h>
X#include <Files.h>
X#endif
X
X#include "DumpRes.h"
X
X#ifdef THINK_C
X#define p2cstr(x)	(char *)PtoCstr((char *)x)
X#define c2pstr(x)	(char *)CtoPstr((char *)x)
X#endif
X
X#define rsrcCreator					'RSED'
X#define rsrcType					'rsrc'
X
X#define strType						'STR#'
X
X#define errDataHandle				1
X#define errStrHandle				2
X#define errStrLen					3
X#define errOpenResFile				4
X#define errAddData					5
X#define errAddStr					6
X#define errCloseResFile				7
X
Xstatic char *errtab[7] = {
X	"Unable to move data into handle",
X	"Unable to allocate string handle",
X	"String too long",
X	"Failure opening resource file",
X	"Failure adding data resource",
X	"Failure adding string resource",
X	"Failure closing resource file"
X};
X
Xstatic jmp_buf abort;
X
Xstatic unsigned long strLen;
Xstatic short strCount;
Xstatic char *strLoc;
X
Xstatic void SumStr(ptr)
Xchar **ptr;
X
X{
X	strLen += strlen(*ptr) + 1;
X	return;
X}
X
Xstatic void AddStr(ptr)
Xchar **ptr;
X
X{
X	unsigned len;
X
X	len = strlen(*ptr);
X	if (len > 255) longjmp(abort, errStrLen);
X
X	strcpy(strLoc, *ptr);
X	c2pstr(strLoc);
X
X	strLoc += len + 1;
X
X	strCount++;
X
X	return;
X}
X
Xstatic void NxtString(ptr)
Xchar **ptr;
X
X{
X	*ptr = strLoc;
X	strLoc += strlen(p2cstr(strLoc)) + 1;
X
X	return;
X}
X
Xvoid DumpRes(fileName, resType, resID, resName, resAttrs, elemPtr, elemCnt,
X	     elemSiz, strProc)
Xchar *fileName;
Xlong resType;
Xlong resID;
Xchar *resName;
Xlong resAttrs;
Xchar *elemPtr;
Xunsigned long elemCnt, elemSiz;
Xvoid (*strProc)(char *elem, void (*proc)(char **str));
X
X{
X	Handle dataHandle, strHandle, oldHandle;
X	OSErr err;
X	Str255 pFileName, pResName;
X	short resFile;
X	char *anElem;
X	long errno;
X	unsigned long i;
X
X	if ((errno = setjmp(abort)) != 0) {
X		fprintf(stderr, "Error dumping to resource %s to file %s.\n",
X			resName, fileName);
X		fprintf(stderr, "%s\n", errtab[errno - 1]);
X		exit(1);
X	}
X
X	strncpy((char *)pFileName, fileName, 255);
X	pFileName[255] = '\0';
X	c2pstr(pFileName);
X
X	strncpy((char *)pResName, resName, 255);
X	pResName[255] = '\0';
X	c2pstr(pResName);
X
X	err = PtrToHand(elemPtr, &dataHandle, elemCnt * elemSiz);
X	if (err != noErr) longjmp(abort, errDataHandle);
X
X	if (strProc != NULL) {
X
X		strLen = sizeof(short);
X		anElem = elemPtr;
X		for (i = 0; i < elemCnt; i++) {
X			(*strProc)(anElem, SumStr);
X			anElem += elemSiz;
X		}
X
X		strHandle = NewHandle(strLen);
X		if (MemError() != noErr) longjmp(abort, errStrHandle);
X
X		strCount = 0;
X		strLoc = (char *) *strHandle + sizeof(short);
X		anElem = elemPtr;
X		for (i = 0; i < elemCnt; i++) {
X			(*strProc)(anElem, AddStr);
X			anElem += elemSiz;
X		}
X
X		*((short *) *strHandle) = strCount;
X
X	}
X
X	else
X		strHandle = NULL;
X
X	(void) Create(pFileName, 0, rsrcCreator, rsrcType);
X	CreateResFile(pFileName);
X
X	resFile = OpenResFile(pFileName);
X	if (resFile == -1) longjmp(abort, errOpenResFile);
X
X	oldHandle = Get1Resource(resType, (short) resID);
X	if (oldHandle != NULL) {
X		RmveResource(oldHandle);
X		DisposHandle(oldHandle);
X	}
X
X	oldHandle = Get1Resource(strType, (short) resID);
X	if (oldHandle != NULL) {
X		RmveResource(oldHandle);
X		DisposHandle(oldHandle);
X	}
X
X	AddResource(dataHandle, resType, (short) resID, pResName);
X	if (ResError() != noErr) longjmp(abort, errAddData);
X
X	SetResAttrs(dataHandle, resAttrs | resChanged);
X
X	if (strHandle != NULL) {
X
X		AddResource(strHandle, strType, (short) resID, pResName);
X		if (ResError() != noErr) longjmp(abort, errAddStr);
X
X		SetResAttrs(strHandle, resAttrs | resChanged);
X
X	}
X
X	CloseResFile(resFile);
X	if (ResError() != noErr) longjmp(abort, errCloseResFile);
X
X	return;
X}
X
Xlong LoadRes(memPtr, resType, resID, elemCnt, elemSiz, strProc)
Xchar **memPtr;
Xlong resType;
Xlong resID;
Xunsigned long elemCnt, elemSiz;
Xvoid (*strProc)(char *elem, void (*proc)(char **str));
X
X{
X	Handle dataHandle, strHandle;
X	unsigned long dataLen, strLen;
X	char *elemPtr, *anElem;
X	long i;
X
X	dataHandle = GetResource(resType, resID);
X	if (dataHandle == NULL) return(false);
X
X	MoveHHi(dataHandle);
X	HLock(dataHandle);
X
X	dataLen = GetHandleSize(dataHandle);
X
X	if (strProc != NULL) {
X
X		strHandle = GetResource(strType, resID);
X		if (strHandle == NULL) return(false);
X
X		MoveHHi(strHandle);
X		HLock(strHandle);
X
X		strLen = GetHandleSize(strHandle);
X
X	}
X
X	else {
X
X		strHandle = NULL;
X		strLen = 0;
X
X	}
X
X	if (*memPtr == NULL) {
X
X		elemPtr = NewPtr(dataLen + strLen);
X		if (elemPtr == NULL) return(false);
X
X	}
X
X	else {
X
X		elemPtr = *memPtr;
X		if (GetPtrSize(elemPtr) < (dataLen + strLen)) return(false);
X
X	}
X
X	if (strHandle != NULL) {
X
X		BlockMove(*strHandle, elemPtr + dataLen, strLen);
X
X		HUnlock(strHandle);
X		ReleaseResource(strHandle);
X
X	}
X
X	BlockMove(*dataHandle, elemPtr, dataLen);
X
X	HUnlock(dataHandle);
X	ReleaseResource(dataHandle);
X
X	if (strHandle != NULL) {
X		strLoc = elemPtr + dataLen + sizeof(short);
X		anElem = elemPtr;
X		for (i = 0; i < elemCnt; i++) {
X			(*strProc)(anElem, NxtString);
X			anElem += elemSiz;
X		}
X	}
X
X	*memPtr = elemPtr;
X
X	return(true);
X}
END_OF_FILE
if test 5368 -ne `wc -c <'mac/dumpres/DumpRes.c'`; then
    echo shar: \"'mac/dumpres/DumpRes.c'\" unpacked with wrong size!
fi
# end of 'mac/dumpres/DumpRes.c'
fi
if test -f 'mac/machelp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/machelp.c'\"
else
echo shar: Extracting \"'mac/machelp.c'\" \(5404 characters\)
sed "s/^X//" >'mac/machelp.c' <<'END_OF_FILE'
X/* mac/machelp.c -- support code for mac like help system
X
X   Copyright (c) 1989-1991 Curtis McCauley, James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#ifndef THINK_C
X#include <Types.h>
X#include <Resources.h>
X#include <Events.h>
X#include <Quickdraw.h>
X#include <TextEdit.h>
X#include <Controls.h>
X#include <Dialogs.h>
X
X#include <ScrnMgr.h>
X#else
X#include <stddef.h>
X#include "ScrnMgr.h"
X#endif
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X
X#define textType				'TEXT'
X#define textID					512
X
X#define macHelpDlgID			512
X#define dfltBorder				2
X#define textBox					3
X#define scrollBar				4
X
X#define codeEnter				0x03
X#define codeReturn				0x0D
X
X#ifdef THINK_C
X/* Cover up error in THINK C library.  */
X#define ok	OK
X#define cancel	Cancel
X#endif
X
Xstatic ControlHandle okButton;
X
Xstatic ControlHandle myScrollBar;
Xstatic short scrollMin, scrollMax;
Xstatic short pageLines;
X
Xstatic TEHandle myTEHandle;
X
Xstatic pascal void ActOnScroll(theControl, partCode)
XControlHandle theControl;
Xshort partCode;
X
X{
X	short delta;
X	short newVal, origVal;
X
X	if (theControl != myScrollBar) return;
X
X	switch (partCode) {
X		case inUpButton:
X			delta = -1;
X			break;
X		case inDownButton:
X			delta = 1;
X			break;
X		case inPageUp:
X			delta = -pageLines;
X			break;
X		case inPageDown:
X			delta = pageLines;
X			break;
X		default:
X			delta = 0;
X			break;
X	}
X
X	if (delta) {
X		origVal = GetCtlValue(myScrollBar);
X		newVal = origVal + delta;
X		if (newVal < scrollMin) newVal = scrollMin;
X		if (newVal > scrollMax) newVal = scrollMax;
X		if (newVal != origVal) {
X			delta = newVal - origVal;
X			SetCtlValue(myScrollBar, newVal);
X			TEScroll(0, -delta * (*myTEHandle)->lineHeight, myTEHandle);
X		}
X	}
X
X	return;
X}
X
Xstatic void DoHScroll(where, part)
XPoint where;
Xshort part;
X
X{
X	short origVal, newVal;
X
X	switch (part) {
X
X		case inUpButton:
X		case inDownButton:
X		case inPageUp:
X		case inPageDown:
X			TrackControl(myScrollBar, where, (ProcPtr) ActOnScroll);
X			break;
X
X		case inThumb:
X			origVal = GetCtlValue(myScrollBar);
X			TrackControl(myScrollBar, where, NULL);
X			newVal = GetCtlValue(myScrollBar);
X			if (newVal != origVal)
X				TEScroll(0, (origVal - newVal) * (*myTEHandle)->lineHeight, myTEHandle);
X			break;
X
X	}
X
X	return;
X}
X
Xstatic pascal Boolean MacHelpFilter(theDialog, theEvent, itemHit)
XDialogPtr theDialog;
XEventRecord *theEvent;
Xshort *itemHit;
X
X{
X	GrafPtr oldPort;
X	Point localPt;
X	WindowPtr theWindow;
X	ControlHandle theControl;
X	Boolean handled;
X	char key;
X	short part;
X
X	handled = false;
X
X	switch (theEvent->what) {
X
X		case keyDown:
X			key = theEvent->message & charCodeMask;
X			if ( (key == codeEnter) || (key == codeReturn) ) {
X				handled = true;
X				HiliteControl(okButton, inButton);
X				*itemHit = ok;
X			}
X			break;
X
X		case mouseDown:
X			part = FindWindow(theEvent->where, &theWindow);
X			if ( (theWindow == (WindowPtr) theDialog) && (part == inContent) ) {
X				GetPort(&oldPort);
X				SetPort((GrafPtr) theWindow);
X				localPt = theEvent->where;
X				GlobalToLocal(&localPt);
X				part = FindControl(localPt, theWindow, &theControl);
X				if (theControl == myScrollBar) {
X					handled = true;
X					DoHScroll(localPt, part);
X					*itemHit = scrollBar;
X				}
X				SetPort(oldPort);
X			}
X			break;
X
X	}
X
X	return(handled);
X}
X
Xstatic pascal void DrawTextBox(theWindow, theItem)
XWindowPtr theWindow;
Xshort theItem;
X
X{
X	short itsType;
X	Handle itsHandle;
X	Rect itsRect;
X
X	GetDItem((DialogPtr) theWindow, theItem, &itsType, &itsHandle, &itsRect);
X	FrameRect(&itsRect);
X
X	TEUpdate(&theWindow->portRect, myTEHandle);
X
X	return;
X}
X
Xvoid DoMacHelp()
X
X{
X	GrafPtr oldPort;
X	DialogPtr theDialog;
X	Handle itsHandle;
X	Handle textHandle;
X	Handle versionHandle;
X	short itemHit;
X	short itsType;
X	Rect itsRect;
X	Rect textRect;
X	int32 h, v;
X
X	theDialog = GetNewDialog(macHelpDlgID, nil, (WindowPtr) -1);
X
X	GetPort(&oldPort);
X	SetPort((GrafPtr) theDialog);
X
X	CenterScreenDLOG(macHelpDlgID, fixHalf, fixThird, &h, &v);
X	MoveWindow((WindowPtr) theDialog, (short) h, (short) v, false);
X
X	GetDItem(theDialog, ok, &itsType, (Handle *) &okButton, &itsRect);
X	InsetRect(&itsRect, -4, -4);
X
X	SetDItem(theDialog, dfltBorder, userItem, (Handle) DrawDefaultBorder,
X		 &itsRect);
X
X	GetDItem(theDialog, scrollBar, &itsType, (Handle *) &myScrollBar, &itsRect);
X
X	GetDItem(theDialog, textBox, &itsType, &itsHandle, &textRect);
X	SetDItem(theDialog, textBox, userItem, (Handle) DrawTextBox, &textRect);
X	InsetRect(&textRect, 4, 4);
X
X	myTEHandle = TENew(&textRect, &textRect);
X
X	textHandle = GetResource(textType, textID);
X	DetachResource(textHandle);
X
X	(*myTEHandle)->hText = textHandle;
X	(*myTEHandle)->txFont = monaco;
X	(*myTEHandle)->txSize = 9;
X	TECalText(myTEHandle);
X
X	pageLines = (textRect.bottom - textRect.top) / (*myTEHandle)->lineHeight;
X
X	scrollMin = 0;
X	scrollMax = (*myTEHandle)->nLines - pageLines;
X	if (scrollMax < 0) scrollMax = 0;
X
X	SetCtlMin(myScrollBar, scrollMin);
X	SetCtlMax(myScrollBar, scrollMax);
X
X	/* Get the version string.  */
X	versionHandle = GetResource(MORIA_FCREATOR, 0);
X	HLock(versionHandle);
X	ParamText(*versionHandle, NULL, NULL, NULL);
X
X	ShowWindow((WindowPtr) theDialog);
X
X	do {
X		ModalDialog(MacHelpFilter, &itemHit);
X	} while (itemHit != ok);
X
X	HUnlock(versionHandle);
X	TEDispose(myTEHandle);
X
X	SetPort(oldPort);
X
X	DisposDialog(theDialog);
X
X	return;
X}
END_OF_FILE
if test 5404 -ne `wc -c <'mac/machelp.c'`; then
    echo shar: \"'mac/machelp.c'\" unpacked with wrong size!
fi
# end of 'mac/machelp.c'
fi
if test -f 'misc/moria.msg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/moria.msg'\"
else
echo shar: Extracting \"'misc/moria.msg'\" \(6087 characters\)
sed "s/^X//" >'misc/moria.msg' <<'END_OF_FILE'
XFrom boyne@hplvla.hp.com Tue Feb 27 08:03:46 1990
XReceived: from hp-sde.sde.hp.com by ernie.Berkeley.EDU (5.61/1.36)
X	id AA19235; Tue, 27 Feb 90 08:03:44 -0800
XReceived: from hp-lvld.lvld.hp.com by hp-sde.sde.hp.com with SMTP
X	(15.11.1.3/15.5+IOS 3.13) id AA03131; Tue, 27 Feb 90 08:03:15 pst
XReceived: from hplvla.HP.COM by hplisa.lvld.hp.com; Tue, 27 Feb 90 09:04:05mst
XReceived: from hplvre.HP.COM by hplvla.HP.COM; Tue, 27 Feb 90 09:04:43 mst
XReceived: by hplvre.HP.COM; Tue, 27 Feb 90 09:04:41 mst
XDate: Tue, 27 Feb 90 09:04:41 mst
XFrom: Art Boyne <boyne@hplvla.hp.com>
XMessage-Id: <9002271604.AA19981@hplvre.HP.COM>
XTo: wilson@ernie.Berkeley.EDU
XSubject: Re: Hmmmmm (actually enchanting plusses)
XStatus: RO
X
X
X> >	I have an odd little question to ask...  how does one increase the
X> > first `plus' on a pick or shovel?  The two enchantment scrolls (Damage and
X> > To-Hit) seem to increase the second set of pluses, and have no effect on
X> > the first.
X>
X> This is a possibility.  However, it has to be done carefully to avoid
X> problems.  There must be a limit on how high digging ability can be increase
X> just like weapons/armor are effectively limited to +10.  I think +10 is
X> ridiculously high for digging though, perhaps limiting it to 5 would be OK.
X
XActually, I have found on several occasions Gnomish Shovels (+6), but never
Xanything higher (both in umoria 4.87 and PC-MORIA 4.873).  So perhaps +6
Xshould be the asymptotic limit, with decreasing chance of success for each
X+, similar to enchanting weapon.
X
X>Also, if this were allowed, then creatures should be allowed to 'disenchant'
X>the digging ability of weapons, and there should be traps/scrolls/whatever
X>that reduce the digging ability.  And there are probably some other changes
X>needed as well that don't come immediately to mind.
X
XCertainly - disenchanter creatures could affect digging ability, and (see
Xbelow) the enchantments on rings, etc.  Digging ability could also be reduced
Xby repeatedly digging through "hard" rock - say up to a 1% chance based on
Xwhat you are digging through.
X
X>>You can't.  Period.  This is another feature I would like to see changed,
X>>along with being able to increase the enchantment of rings, etc.
X>
X>I am very leary about adding this, because rings are permanent magic items.
X>In particular, letting someone enchant a ring of speed to +2 or higher will
X>seriously unbalance the game, as this is an incredible advantage for a
X>player.
X
XAgain, allowing disenchanter creatures to affect this would overcome the
Ximbalance.  Also, there could be a small chance that an enchant item scroll
Xcould destroy the item.  In fact, this should probably be the case even
Xfor the existing enchant weapon/armor scrolls, since right now you have
X*nothing* to lose by trying 100 times to get an extra + on weapons/armor.
X
XAlso, I still would like to see a very small chance that enchanting
Xweapons/armor would produce a special weapon (SD/SU/SE/SM/HA/DF) or
Xspecial armor (RC/RA/RL/RF/R).  Again, this would be counterbalanced
Xby the (slightly greater?) chance of destroying the item.  Perhaps,
Xtoo, disenchanter creatures could be allowed to remove the special
Xattributes.
X
XArt Boyne, boyne@hplvla.hp.com
X
XFrom ucbvax!decwrl!ames!think!samsung!usc!cs.utexas.edu!tut.cis.ohio-state.ed
XStatus: RO
X
XArticle 4487 of rec.games.moria:
XPath: ucbvax!decwrl!ames!think!samsung!usc!cs.utexas.edu!tut.cis.ohio-state.e
X>From: dtate@unix.cis.pitt.edu (David M Tate)
XNewsgroups: rec.games.moria
XSubject: Re: Enhancements to Umoria5.0 : the One Ring
XKeywords: One Ring
XMessage-ID: <22578@unix.cis.pitt.edu>
XDate: 27 Feb 90 16:46:31 GMT
XReferences: <1990Feb22.005217.22427@cs.rochester.edu> <562@auvax.AthabascaU.CA
XReply-To: dtate@unix.cis.pitt.edu (David M Tate)
XDistribution: all
XOrganization: Univ. of Pittsburgh, Comp & Info Services
XLines: 47
X
XIn article <562@auvax.AthabascaU.CA> kevinc@cs.AthabascaU.CA (Kevin Crocker)
X>
X>Remember, at least some of the Elven rings still existed, the Dwarven
X>rings are presumably lost in the Mines of Moria, HINT!, HINT!, and of
X>course the Nine walk abroad but are but wraiths of doom.
X>
X>All kinds of interesting thoughts appear.
X>
XActually, if I remember my Ring-lore correctly, the seven were all taken by
XSauron.  The last was the ring of Thrain, which was taken from Thror (or was
Xit Thrain?) by Sauron in the dungeons of Dol Guldor.  No more Rings of Power
Xfloating around in Moria.  The only rings still "available" are the three
Xrings (Narya, Nenya, Vilya) of the Elves, made by Celebrimbor. But I'm getting
Xpedantic...
X
XI, too, would love to see an even-more-Tolkienish descendant of Moria...if you
Xget tired of Moria, maybe you could bash your way across Mirkwood to deal with
XSmaug or the Necromancer.  Having Nazgul would add some spice, too.  And for
Xartifacts, you could find a palantir, which would let you look at any desired
Xportion of the level as if you were in the room(s), but from a distance.
X
XOf course, I'm sure Jim Wilson is reading these postings and saying "Yeah, in
Xyour dreams." :-)
X
XI do like the idea of having more "special attribute" items, good and bad.
XYou could actually make the choices a lot harder by mixing them up: what would
X*you* do if you found Boots [3,+7] (R) of Noise?  Or ego weapons with both
Xgood and bad side effects (remember "Bessman's Flailing Hammer", in Larn?).
XItems of invisibility would be great, too.
X
XAny chance of getting Alter-ego Weapons?  A dagger (-2,-4) of Summon Undead?
XOr something that *increases* susceptibility to certain breath/trap attacks,
Xlike a ring (or armor) of Susceptibility to Cold/Fire/Poison/Acid/Lightning?
X
XHow about being able to buy lightning rods in the general store?  Plant one in
Xthe floor, and all lightning attacks (dragon, wand, whatever) get drawn to it.
XJust don't stand too close!
X
Xetc.
X
X
X
X--
X        David M. Tate       | "It made the basses of their being throb in
X  dtate@unix.cis.pitt.edu   |  witching chords, and their thin blood pulse
X                            |  pizzicati of Hosanna..."
X "A Man for all Seasonings" |                     -- Wallace Stevens
X
X
END_OF_FILE
if test 6087 -ne `wc -c <'misc/moria.msg'`; then
    echo shar: \"'misc/moria.msg'\" unpacked with wrong size!
fi
# end of 'misc/moria.msg'
fi
if test -f 'source/help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/help.c'\"
else
echo shar: Extracting \"'source/help.c'\" \(6400 characters\)
sed "s/^X//" >'source/help.c' <<'END_OF_FILE'
X/* source/help.c: identify a symbol
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X
Xvoid ident_char()
X{
X  char command, query;
X  register int i, n;
X
X  if (get_com("Enter character to be identified :", &command))
X    switch(command)
X      {
X	/* every printing ASCII character is listed here, in the order in which
X	   they appear in the ASCII character set */
X      case ' ': prt("  - An open pit.", 0, 0); break;
X      case '!': prt("! - A potion.", 0, 0); break;
X      case '"': prt("\" - An amulet, periapt, or necklace.", 0, 0); break;
X      case '#': prt("# - A stone wall.", 0, 0); break;
X      case '$': prt("$ - Treasure.", 0, 0); break;
X      case '%':
X	if (highlight_seams == TRUE)
X	  prt("% - A magma or quartz vein.", 0, 0);
X	else
X	  prt("% - Not used.", 0, 0);
X	break;
X      case '&': prt("& - Treasure chest.", 0, 0); break;
X      case '\'': prt("' - An open door.", 0, 0); break;
X      case '(': prt("( - Soft armor.", 0, 0); break;
X      case ')': prt(") - A shield.", 0, 0); break;
X      case '*': prt("* - Gems.", 0, 0); break;
X      case '+': prt("+ - A closed door.", 0, 0); break;
X      case ',': prt(", - Food or mushroom patch.", 0, 0); break;
X      case '-': prt("- - A wand", 0, 0); break;
X      case '.': prt(". - Floor.", 0, 0); break;
X      case '/': prt("/ - A pole weapon.", 0, 0); break;
X	/* case '0': prt("0 - Not used.", 0, 0); break; */
X      case '1': prt("1 - Entrance to General Store.", 0, 0); break;
X      case '2': prt("2 - Entrance to Armory.", 0, 0); break;
X      case '3': prt("3 - Entrance to Weaponsmith.", 0, 0); break;
X      case '4': prt("4 - Entrance to Temple.", 0, 0); break;
X      case '5': prt("5 - Entrance to Alchemy shop.", 0, 0); break;
X      case '6': prt("6 - Entrance to Magic-Users store.", 0, 0); break;
X	/* case '7': prt("7 - Not used.", 0, 0); break; */
X	/* case '8': prt("8 - Not used.", 0, 0); break; */
X	/* case '9': prt("9 - Not used.", 0, 0);  break;*/
X      case ':': prt(": - Rubble.", 0, 0); break;
X      case ';': prt("; - A loose rock.", 0, 0); break;
X      case '<': prt("< - An up staircase.", 0, 0); break;
X      case '=': prt("= - A ring.", 0, 0); break;
X      case '>': prt("> - A down staircase.", 0, 0); break;
X      case '?': prt("? - A scroll.", 0, 0); break;
X      case '@': prt(py.misc.name, 0, 0); break;
X      case 'A': prt("A - Giant Ant Lion.", 0, 0); break;
X      case 'B': prt("B - The Balrog.", 0, 0); break;
X      case 'C': prt("C - Gelatinous Cube.", 0, 0); break;
X      case 'D': prt("D - An Ancient Dragon (Beware).", 0, 0); break;
X      case 'E': prt("E - Elemental.", 0, 0); break;
X      case 'F': prt("F - Giant Fly.", 0, 0); break;
X      case 'G': prt("G - Ghost.", 0, 0); break;
X      case 'H': prt("H - Hobgoblin.", 0, 0); break;
X	/* case 'I': prt("I - Invisible Stalker.", 0, 0); break; */
X      case 'J': prt("J - Jelly.", 0, 0); break;
X      case 'K': prt("K - Killer Beetle.", 0, 0); break;
X      case 'L': prt("L - Lich.", 0, 0); break;
X      case 'M': prt("M - Mummy.", 0, 0); break;
X	/* case 'N': prt("N - Not used.", 0, 0); break; */
X      case 'O': prt("O - Ooze.", 0, 0); break;
X      case 'P': prt("P - Giant humanoid.", 0, 0); break;
X      case 'Q': prt("Q - Quylthulg (Pulsing Flesh Mound).", 0, 0); break;
X      case 'R': prt("R - Reptile.", 0, 0); break;
X      case 'S': prt("S - Giant Scorpion.", 0, 0); break;
X      case 'T': prt("T - Troll.", 0, 0); break;
X      case 'U': prt("U - Umber Hulk.", 0, 0); break;
X      case 'V': prt("V - Vampire.", 0, 0); break;
X      case 'W': prt("W - Wight or Wraith.", 0, 0); break;
X      case 'X': prt("X - Xorn.", 0, 0); break;
X      case 'Y': prt("Y - Yeti.", 0, 0); break;
X	/* case 'Z': prt("Z - Not used.", 0, 0); break; */
X      case '[': prt("[ - Hard armor.", 0, 0); break;
X      case '\\': prt("\\ - A hafted weapon.", 0, 0); break;
X      case ']': prt("] - Misc. armor.", 0, 0); break;
X      case '^': prt("^ - A trap.", 0, 0); break;
X      case '_': prt("_ - A staff.", 0, 0); break;
X	/* case '`': prt("` - Not used.", 0, 0); break; */
X      case 'a': prt("a - Giant Ant.", 0, 0); break;
X      case 'b': prt("b - Giant Bat.", 0, 0); break;
X      case 'c': prt("c - Giant Centipede.", 0, 0); break;
X      case 'd': prt("d - Dragon.", 0, 0); break;
X      case 'e': prt("e - Floating Eye.", 0, 0); break;
X      case 'f': prt("f - Giant Frog.", 0, 0); break;
X      case 'g': prt("g - Golem.", 0, 0); break;
X      case 'h': prt("h - Harpy.", 0, 0); break;
X      case 'i': prt("i - Icky Thing.", 0, 0); break;
X      case 'j': prt("j - Jackal.", 0, 0); break;
X      case 'k': prt("k - Kobold.", 0, 0); break;
X      case 'l': prt("l - Giant Louse.", 0, 0); break;
X      case 'm': prt("m - Mold.", 0, 0); break;
X      case 'n': prt("n - Naga.", 0, 0); break;
X      case 'o': prt("o - Orc or Ogre.", 0, 0); break;
X      case 'p': prt("p - Person (Humanoid).", 0, 0); break;
X      case 'q': prt("q - Quasit.", 0, 0); break;
X      case 'r': prt("r - Rodent.", 0, 0); break;
X      case 's': prt("s - Skeleton.", 0, 0); break;
X      case 't': prt("t - Giant Tick.", 0, 0); break;
X	/* case 'u': prt("u - Not used.", 0, 0); break; */
X	/* case 'v': prt("v - Not used.", 0, 0); break; */
X      case 'w': prt("w - Worm or Worm Mass.", 0, 0); break;
X	/* case 'x': prt("x - Not used.", 0, 0); break; */
X      case 'y': prt("y - Yeek.", 0, 0); break;
X      case 'z': prt("z - Zombie.", 0, 0); break;
X      case '{': prt("{ - Arrow, bolt, or bullet.", 0, 0); break;
X      case '|': prt("| - A sword or dagger.", 0, 0); break;
X      case '}': prt("} - Bow, crossbow, or sling.", 0, 0); break;
X      case '~': prt("~ - Miscellaneous item.", 0, 0); break;
X      default:	prt("Not Used.", 0, 0); break;
X      }
X
X  /* Allow access to monster memory. -CJS- */
X  n = 0;
X  for (i = MAX_CREATURES-1; i >= 0; i--)
X    if ((c_list[i].cchar == command) && bool_roff_recall (i))
X      {
X	if (n == 0)
X	  {
X	    put_buffer ("You recall those details? [y/n]", 0, 40);
X	    query = inkey();
X	    if (query != 'y' && query != 'Y')
X	      break;
X	    erase_line (0, 40);
X	    save_screen ();
X	  }
X	n++;
X	query = roff_recall (i);
X	restore_screen ();
X	if (query == ESCAPE)
X	  break;
X      }
X}
END_OF_FILE
if test 6400 -ne `wc -c <'source/help.c'`; then
    echo shar: \"'source/help.c'\" unpacked with wrong size!
fi
# end of 'source/help.c'
fi
if test -f 'util/printit/pr_items.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/printit/pr_items.c'\"
else
echo shar: Extracting \"'util/printit/pr_items.c'\" \(5222 characters\)
sed "s/^X//" >'util/printit/pr_items.c' <<'END_OF_FILE'
X/* util/printit/pr_items.c: pretty print item/treasure info
X
X   Copyright (c) 1990-1992: Carlton Hommel, James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X
Xextern treasure_type object_list[];
X
Xmain()
X{
X    int i;
X    treasure_type *t;
X
X    printf("[tval,sub] p1\tLvl   $ lbs\t  Dam [+, +]\t[AC,+]\tChar Name");
X    printf("\tFlags\n");
X    for (i=0; i<MAX_OBJECTS; i++) {
X	t = &object_list[i];
X	call_it(t);
X    }
X    return 0;
X}
X
Xcall_it(t)
Xtreasure_type *t;
X{
X    printf("[%2d,%3d] ", t->tval, t->subval);
X
X    if (t->p1)
X	 printf("%d\t", t->p1);
X    else printf(" \t");
X
X    printf("%2d %4ld %3d\t", t->level, t->cost, t->weight);
X
X    if (t->damage[0] || t->damage[1])
X	printf("%2dd%d ", t->damage[0], t->damage[1]);
X    else printf("     ");
X
X    if (t->tohit || t->todam)
X	 printf("[%d, %d]\t", t->tohit, t->todam);
X    else printf("      \t");
X
X    if (t->ac!=0 || t->toac!=0)
X	printf("{%d, %d}\t", t->ac, t->toac);
X    else printf("      \t");
X
X    printf("'%c' \"%s\"\t",
X	t->tchar, t->name);
X
X    print_flags(t->tval, t->flags);
X
X    printf("\n");
X}
X
Xprint_flags(tval, flags)
Xchar tval;
Xunsigned long flags;
X{
X    int count;
X    unsigned long mask;
X
X    if (flags == 0)
X	return;
X
X    if (tval==80) {
X	printf("<");
X	for (count=0,mask=0x01; count<32; mask <<= 1, count++) {
X	    switch (flags & mask) {
X	    case 0x00000001: printf("poison(lvl+rnd(10)) ");		break;
X	    case 0x00000002: printf("blind(10*lvl+rnd(250)+100) ");	break;
X	    case 0x00000004: printf("fear(lvl+rnd(10) ");		break;
X	    case 0x00000008: printf("confused(lvl+rnd(10) ");		break;
X	    case 0x00000010: printf("hallucinate(25*lvl+rnd(200)+200) ");break;
X	    case 0x00000020: printf("cure_poison ");			break;
X	    case 0x00000040: printf("cure_blindness ");		break;
X	    case 0x00000080: printf("cure_fear ");		break;
X	    case 0x00000100: printf("cure_confuse ");		break;
X	    case 0x00000200: printf("lose_str ");		break;
X	    case 0x00000400: printf("lose_con ");		break;
X	    case 0x00000800: printf("lose_int ");		break;
X	    case 0x00001000: printf("lose_wis ");		break;
X	    case 0x00002000: printf("lose_dex ");		break;
X	    case 0x00004000: printf("lose_chr ");		break;
X	    case 0x00008000: printf("rest_str ");		break;
X	    case 0x00010000: printf("rest_con ");		break;
X	    case 0x00020000: printf("rest_int ");		break;
X	    case 0x00040000: printf("rest_wis ");		break;
X	    case 0x00080000: printf("rest_dex ");		break;
X	    case 0x00100000: printf("rest_chr ");		break;
X	    case 0x00200000: printf("hp+(rnd(6)) ");		break;
X	    case 0x00400000: printf("hp+(rnd(12)) ");		break;
X	    case 0x00800000: printf("hp+(rnd(18)) ");		break;
X	    case 0x01000000: printf("hp+(rnd(3d6)) ");		break;
X	    case 0x02000000: printf("hp+(rnd(3d12)) ");		break;
X	    case 0x04000000: printf("hp-(rnd(18)) ");		break;
X	    case 0x08000000: printf("hp-(rnd(8)) ");		break;
X	    case 0x10000000: printf("hp-(rnd(2d8))  ");		break;
X	    case 0x20000000: printf("hp-(rnd(3d8))  ");		break;
X	    case 0x40000000: printf("??? ");			break;
X	    case 0x80000000: printf("??? ");			break;
X	    }
X	}
X	printf(">");
X    }
X    else
X    if (tval>=TV_MIN_WEAR && tval<=TV_MAX_WEAR) {
X	printf("<");
X	for (count=0,mask=0x01; count<32; mask <<= 1, count++) {
X	    switch (flags & mask) {
X	    case TR_STR:		printf("Strength ");		break;
X	    case TR_INT:		printf("Intelligence ");	break;
X	    case TR_WIS:		printf("Wisdom ");		break;
X	    case TR_DEX:		printf("Dexterity ");		break;
X	    case TR_CON:		printf("Constitution ");	break;
X	    case TR_CHR:		printf("Charisma ");		break;
X	    case TR_SEARCH:		printf("Searching ");		break;
X	    case TR_SLOW_DIGEST:	printf("Slow_digestion ");	break;
X	    case TR_STEALTH:		printf("Stealth ");		break;
X	    case TR_AGGRAVATE:		printf("Aggravation ");		break;
X	    case TR_TELEPORT:		printf("Teleportation ");	break;
X	    case TR_REGEN:		printf("Regeneration ");	break;
X	    case TR_SPEED:		printf("Speed ");		break;
X	    case TR_SLAY_DRAGON:	printf("Slay_Dragon ");		break;
X	    case TR_SLAY_ANIMAL:	printf("Slay_Animal ");		break;
X	    case TR_SLAY_EVIL:		printf("Slay_Evil ");		break;
X	    case TR_SLAY_UNDEAD:	printf("Slay_Undead ");		break;
X	    case TR_FROST_BRAND:	printf("Cold_Brand ");		break;
X	    case TR_FLAME_TONGUE:	printf("Flame_Brand ");		break;
X	    case TR_RES_FIRE:		printf("Resist_Fire ");		break;
X	    case TR_RES_ACID:		printf("Resist_Acid ");		break;
X	    case TR_RES_COLD:		printf("Resist_Cold ");		break;
X	    case TR_SUST_STAT:		printf("Sustain_Stat ");	break;
X	    case TR_FREE_ACT:		printf("Free_Action ");		break;
X	    case TR_SEE_INVIS:		printf("See_Invisible ");	break;
X	    case TR_RES_LIGHT:		printf("Resist_Lightning ");	break;
X	    case TR_FFALL:		printf("Feather_Fall ");	break;
X	    case TR_BLIND:		printf("Blindness ");		break;
X	    case TR_TIMID:		printf("Timidness ");		break;
X	    case TR_TUNNEL:		printf("Tunneling ");		break;
X	    case TR_INFRA:		printf("Infra_vision ");	break;
X	    case TR_CURSED:		printf("Cursed ");		break;
X	    }
X	}
X	printf(">");
X    }
X}
END_OF_FILE
if test 5222 -ne `wc -c <'util/printit/pr_items.c'`; then
    echo shar: \"'util/printit/pr_items.c'\" unpacked with wrong size!
fi
# end of 'util/printit/pr_items.c'
fi
if test -f 'util/weapons/calchits.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/weapons/calchits.c'\"
else
echo shar: Extracting \"'util/weapons/calchits.c'\" \(5835 characters\)
sed "s/^X//" >'util/weapons/calchits.c' <<'END_OF_FILE'
X/* util/weapons/calchits.c: calculates relative weapon effectiveness
X
X   Copyright (c) 1989-1992 Wayne Schlitt, James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include <stdio.h>
X
X#define	max(a,b)	( (a) > (b) ? (a) : (b) )
X#define min(a,b)	( (a) < (b) ? (a) : (b) )
X#define fabs(a)		( (a) < 0 ? -(a) : (a) )
X
Xchar blows_table[7][6] = {
X/* STR/W:	   9  18  67 107 117 118   : DEX */
X/* <2 */	{  1,  1,  1,  1,  1,  1 },
X/* <3 */	{  1,  1,  1,  1,  2,  2 },
X/* <4 */	{  1,  1,  1,  2,  2,  3 },
X/* <5 */	{  1,  1,  2,  2,  3,  3 },
X/* <7 */	{  1,  2,  2,  3,  3,  4 },
X/* <9 */	{  1,  2,  2,  3,  4,  4 },
X/* >9 */	{  2,  2,  3,  3,  4,  4 }
X};
X
X
X/* Weapon weight VS strength and dexterity		-RAK-	*/
Xvoid attack_blows(weight, cstr, cdex, max_blows, real_blows, adj_weight )
X    int weight, cstr, cdex;
X    int *max_blows, *real_blows;
X    int *adj_weight;
X{
X  int dex_index, str_index;
X
X    if ((cstr*15) < weight)
X    {
X	*max_blows = 0;
X	*real_blows = 0;
X	*adj_weight = 0.0;
X    }
X    else
X    {
X	if      (cdex <  10)  dex_index = 0;
X	else if (cdex <  19)  dex_index = 1;
X	else if (cdex <  68)  dex_index = 2;
X	else if (cdex < 108)  dex_index = 3;
X	else if (cdex < 118)  dex_index = 4;
X	else                  dex_index = 5;
X	*adj_weight = ((cstr*10)/weight);
X	if      (*adj_weight < 2)  str_index = 0;
X	else if (*adj_weight < 3)  str_index = 1;
X	else if (*adj_weight < 4)  str_index = 2;
X	else if (*adj_weight < 5)  str_index = 3;
X	else if (*adj_weight < 7)  str_index = 4;
X	else if (*adj_weight < 9)  str_index = 5;
X	else                       str_index = 6;
X	*max_blows = blows_table[6][dex_index];
X	*real_blows = blows_table[str_index][dex_index];
X    }
X
X}
X
X
X#define calc_chance(low,high,weight) \
X    max( 0., min( (high - low), \
X		 (high - low) - (high - (650. + weight)) \
X		 ) \
X	) / 650.
X
X
X/* Critical hits, Nasty way to die...			-RAK-	*/
Xint critical_blow(weight, plus, dam, player_level)
X    int weight, player_level;
X    double plus, dam;
X{
X    int critical;
X
X    int		added_dam;
X    double	chance_critical, chance_dam, total_chance;
X
X    int		debug = 0;
X
X
X    critical = dam;
X    chance_critical = ( (int)(weight+5*plus+3*player_level) ) / 5000.;
X
X    if( debug ) printf( "chance_critical=%g  chance_dam=(", chance_critical );
X
X    chance_dam = calc_chance( weight, 400., weight );
X    if( debug ) printf( "%g", chance_dam );
X    total_chance = chance_dam;
X    added_dam  = (2*dam +  5) * chance_dam;
X
X    chance_dam = calc_chance( 400., 700., weight );
X    if( debug ) printf( "+%g", chance_dam );
X    total_chance += chance_dam;
X    added_dam += (3*dam + 10) * chance_dam;
X
X    chance_dam = calc_chance( 700., 900., weight );
X    if( debug ) printf( "+%g", chance_dam );
X    total_chance += chance_dam;
X    added_dam += (4*dam + 15) * chance_dam;
X
X    chance_dam = calc_chance( 900., 2000., weight );
X    if( debug ) printf( "+%g)  ", chance_dam );
X    total_chance += chance_dam;
X    added_dam += (5*dam + 20) * chance_dam;
X
X    if( debug ) printf( "added_dam = %d\n", added_dam );
X
X    if( fabs( total_chance - 1. ) > 1e-14 )
X    {
X	printf( "ERROR:  total_chance=%g (%g)\n",
X	       total_chance, total_chance - 1. );
X	exit( 1 );
X    }
X
X    return( critical + added_dam * chance_critical );
X
X}
X
X
Xint get_stat( stat )
X    int		*stat;
X{
X    int		tmp, c;
X
X
X    if( 1 != scanf( " %d", &tmp ) )
X	return( 0 );
X
X    *stat = tmp;
X
X    if( tmp == 18 )
X    {
X	c = getchar();
X	if( c == '/' )
X	{
X	    if( 1 != scanf( "%d", &tmp ) )
X		return( 0 );
X	    *stat += tmp;
X	}
X	else
X	    ungetc(c, stdin);
X
X    }
X
X    return( 1 );
X}
X
X
X
X
X
X#define MWEAPONS 100
X
Xint main()
X{
X    int		cstr, cdex, player_level;
X
X    int		weight[MWEAPONS];
X    double	to_hit[MWEAPONS], to_dam[MWEAPONS], weapon_dam[MWEAPONS];
X
X    int		num_weapons, i;
X
X    int		max_blows, real_blows;
X    int		adj_weight;
X    double	avg_dam, critical;
X
X    int		num_die, die_sides;
X
X
X    printf( "Enter level of your character: " );
X    if( 1 != scanf( " %d", &player_level ) )
X    {
X	putchar( '\n');
X	exit( 1 );
X    }
X
X
X    printf( "Enter number of weapons: " );
X    if( 1 != scanf( " %d", &num_weapons ) )
X    {
X	putchar( '\n');
X	exit( 1 );
X    }
X
X
X    for( i = 0; i < num_weapons; i++ )
X    {
X	printf( "Enter weight, weapon_dam, to_hit, to_dam for weapon #%d: ",
X	       i );
X	if( 5 != scanf( " %d %dd%d %lf %lf",
X		       &weight[i], &num_die, &die_sides,
X		       &to_hit[i], &to_dam[i] )
X	   )
X	{
X	    putchar( '\n');
X	    exit( 1 );
X	}
X
X	weapon_dam[i] = ( num_die * die_sides + num_die )/2.;
X    }
X
X
X    while( 1 )
X    {
X	printf( "Enter cstr, cdex: " );
X	if( !get_stat( &cstr ) || !get_stat( &cdex ) )
X	{
X	    putchar( '\n');
X	    exit( 1 );
X	}
X
X
X	if( cstr == 0 && cdex == 0 )
X	    break;
X
X	printf( "  Weapon | Max blows | Blows | weight ratio | hp of dam |");
X	printf( " w/ critical |\n" );
X
X	for( i = 0; i < num_weapons; i++ )
X	{
X	    attack_blows( weight[i], cstr, cdex,
X			 &max_blows, &real_blows, &adj_weight );
X#if 0
X	    /* multiply to dam bonuses by max/real number of hits */
X	    if (real_blows != 0)
X	      avg_dam = (int) (real_blows*(weapon_dam[i]+
X				 (max_blows * (int)to_dam[i] / real_blows)));
X	    else
X	      avg_dam = 0;
X	    critical = critical_blow( weight[i], to_hit[i], avg_dam,
X				     player_level );
X#else
X	    /* this is the old way, to_dam added after critical */
X	    avg_dam = (int) (real_blows*weapon_dam[i]);
X	    critical = critical_blow( weight[i], to_hit[i], avg_dam,
X				     player_level );
X	    avg_dam += (int) real_blows*to_dam[i];
X	    critical += (int) real_blows*to_dam[i];
X#endif
X
X	    printf( "  %4d   | %6d    | %4d  | %8d     | %6g    |  %7g    |\n",
X		   i, max_blows, real_blows, adj_weight, avg_dam, critical );
X	}
X	printf( "\n" );
X    }
X    return( 0 );
X}
X
END_OF_FILE
if test 5835 -ne `wc -c <'util/weapons/calchits.c'`; then
    echo shar: \"'util/weapons/calchits.c'\" unpacked with wrong size!
fi
# end of 'util/weapons/calchits.c'
fi
echo shar: End of archive 35 \(of 39\).
cp /dev/null ark35isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
