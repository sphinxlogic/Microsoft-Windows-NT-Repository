Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i066:  umoria4 - single player dungeon simulation (ver. 5.5), Part34/39
Message-ID: <3430@master.CNA.TEK.COM>
Date: 22 Aug 92 22:15:14 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2321
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 66
Archive-name: umoria4/Part34
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 34 (of 39)."
# Contents:  doc/history files/rwizcmds.hlp ibmpc/ms_ansi.c
#   mac/macrsrc.c mac/moria.ro mac/scrnmgr/ScrnMgr.h
#   mac/scrnmgr/ScrnTest.c source/signals.c
# Wrapped by billr@saab on Thu Aug 20 09:11:35 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/history' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/history'\"
else
echo shar: Extracting \"'doc/history'\" \(7027 characters\)
sed "s/^X//" >'doc/history' <<'END_OF_FILE'
X
XA History of Moria: written by Jim Wilson
X	This history is somewhat biased towards the Umoria versions because
X	those are the versions that I am most familiar with; info for the
X	VMS versions, in particular, may be inaccurate.
X
XMoria 4.8:
X	The last version developed by the original authors, R.A. Koeneke,
X	etc., at the Univ Oklahoma.  This is written in VMS Pascal, and
X	is only available for VAX/VMS systems.  All other versions of moria
X	are based on this program.  (Sometimes referred to as VMS Moria	4.8.)
X
XMoria UB 5.0:
X	This version was developed at Univ Buffalo, hence the UB in the name.
X	This is also written in VMS Pascal, and is only available for VAX/VMS
X	systems.  Some of the distinguishing features of this version are:
X	a Black Market where one can purchase highly enchanted magic items at
X	100 times normal value, monsters on the town level worth negative
X	experience (Mother and Baby, Small Child), `shadow' Balrogs start
X	appearing at level 50 with the `real' Balrog at level 1200 (this makes
X	it a bit difficult to win).  There are also some new items, and many
X	more new monsters.  (Sometimes referred to as VMS Moria 5.0 or
X	Moria 5.0.  Should not be confused with Umoria 5.x.)  This is based
X	on the Moria 4.8 sources.
XMoria UB 5.1:
X	The latest version of UB Moria.  This version is not available outside
X	Univ Buffalo as yet, and I do not know what any of the new features
X	are.  Only available for VAX/VMS systems.
X
XVMS Moria 6.0:
X	This version was under development at Villanova by Rick Greene.
X	However, it was never completed and was never released.  I believe
X	that it was abandoned because Rick lost computer and/or network access.
X	This was based on the Moria UB 5.0 sources.
X
XImoria:
X	This version was developed at the Univ. Washington.  It is written
X	in VMS Pascal, and is only available for VAX/VMX systems.  This
X	version has never been officially released outside U. Washington.
X	I know very little about this version, but have been told by people
X	at U Washington that it is far superior to any other Moria version
X	that currently exists.  It has many new monsters, new objects,
X	new races, new classes, new terrain types (like water), etc.
X	Unfortunately, the authors have never shown any serious intent
X	to release the sources, they are simply unavailable.  I believe
X	that it is based on the Moria 4.8 sources.
XImoria 4.9:
X	The latest version of Imoria.  I do not know anything about this
X	version.
X
XPC-Moria 4.00+:
X	This version is a port of the Moria 4.8 Pascal sources to the IBM-PC
X	by John W. DeBoskey.  This is a faithful port of the original game,
X	unfortunately, this version has quite a few bugs and hence is not
X	as good as the unrelated PC-Moria 4.87 version.
X
XUmoria (UNIX Moria) 4.83/4.85/4.87:
X	This version was developed by Jim Wilson at UC Berkeley.
X	It is written in UNIX/C and is much more portable than the original
X	sources.  These sources, at one time or another, were ported to VMS,
X	IBM-PC, Atari ST, Amiga, Macintosh, Apple IIGS, VM/SP, Archimedes,
X	are probably others too.  This version fixes very many bugs, spelling
X	errors, and inconsistencies in the original Moria 4.8 sources.
X	This version has no help facility like the original program.  It has
X	character rerolling (in the later versions), but few other changes
X	from the original game.  (This version has many names, e.g.
X	Umoria 4.87, UNIX Moria 4.87, PC-Moria 4.83, PC-Moria 4.873, Mac Moria
X	4.87, etc.  Just about anything with a .83/.85/.87 in the name is
X	a version of this program.)  This is based on the Moria 4.8 sources.
X
XPC-Moria 4.83/4.873:
X	This version was developed by Don Kneller, based on the Umoria sources.
X	These sources are identical except that they will compile on machines
X	with 16 bit integers, had many changes to reduce program size,
X	and introduced the reduced map display.  (Note: PC-Moria 4.83 is
X	extremely buggy, and is unplayable.  I strongly recommend that you
X	upgrade to a newer version if you are still playing it.)
X
XAmiga Moria v3.0:
X	This version was written by Richard and Bryan Henderson of Kettering,
X	Ohio.  It is based on the Umoria 4.85 sources.  This version
X	has bitmapped graphics, unlike the ascii graphics of all other
X	versions.  It has weapons of Godly Might (which make one practically
X	invicible) and some other changes that make it far far easier than
X	all other Moria versions.  It also has several new monsters, such
X	as Lavender Leprechauns.  Sources for this version were never
X	released.
X
XBRUCE Moria:
X	This version was developed by Christopher J. Stuart at Monash
X	University, Clayton, Victoria Australia.  This version has many
X	great new features: monster memories, look any direction code,
X	settable options, better run/find code, can center character on
X	screen, stat code rewritten to fix bugs, rudimentory help facility
X	added, plus many other enhancements.  This was considered an
X	experimental version, and source never publicly released.  This
X	was based on the Umoria 4.85 sources.
X
XUMoria 5.x:
X	This version is under developement by Jim Wilson at Cygnus Support.
X	It has unified source for the UNIX/IBM-PC/Atari/Mac/VMS/Amiga ports
X	of Umoria 4.87.  It includes many new features borrowed from BRUCE
X	Moria, many more bug fixes, all floating point code eliminated,
X	many changes that affect play balance (hopefully for the better),
X	many type/structure changes to reduce game size and allow fixes for
X	pervasive bugs.  See the doc/FEATURES.NEW file for a list of most
X	user visible changes.  (Sometimes called Umoria 5.0, Moria 5.0,
X	Moria 5.x.  Should not be confused with Moria UB 5.0.)
XUmoria 5.5:
X	The latest version of Umoria 5.x.
X
XVertical position indicates roughly when the versions were made available,
Xalthough the scale is not very accurate.
X
X
X1983                            Moria 1.0
X                                   |
X1985                            Moria 4.8
X                                  /  \
X1987            UMoria 4.83 ------    ----------------------\
X                   /  \                       |              \
X                  /    ------- PC-Moria 4.83  |              |
X            UMoria 4.85            |          |              |
X              /  | \               |          |         Moria UB 5.0
X1988   /------   |  ------         |          |              |
X      /          |    UMoria 4.87  |          |              |
X     |       BRUCE Moria  |   \    |          |              |
X Amiga Moria     |        |   PC-Moria 4.873  |              |---\
X (surviving)     |     	  |      /            |              |    \
X1989             |   /----------/             |              |  VMS Moria 6.0
X                 |  /                         |              |   (defunct)
X1990         Umoria 5.0	       	              |              |
X                 |                       Imoria 4.9     Moria UB 5.1
X                 |                            |              |
X1992         Umoria 5.5               (alive and well)  (alive and well)
X                 |
X           (alive and well)
END_OF_FILE
if test 7027 -ne `wc -c <'doc/history'`; then
    echo shar: \"'doc/history'\" unpacked with wrong size!
fi
# end of 'doc/history'
fi
if test -f 'files/rwizcmds.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'files/rwizcmds.hlp'\"
else
echo shar: Extracting \"'files/rwizcmds.hlp'\" \(376 characters\)
sed "s/^X//" >'files/rwizcmds.hlp' <<'END_OF_FILE'
X*  - Wizard light.
X:  - Map area.
X\  - Wizard Help.
X^A - Remove Curse and Cure all maladies.
X^D - Down/Up n levels.
X^E - Change character.
X^F - Delete monsters.
X^G - Allocate treasures.
X^I - Identify.
X^O - Print random objects sample.
X^T - Teleport player.
X^W - Wizard password on/off.
X@  - Create any object *CAN CAUSE FATAL ERROR*
X+  - Gain experience.
X&  - Summon monster.
END_OF_FILE
if test 376 -ne `wc -c <'files/rwizcmds.hlp'`; then
    echo shar: \"'files/rwizcmds.hlp'\" unpacked with wrong size!
fi
# end of 'files/rwizcmds.hlp'
fi
if test -f 'ibmpc/ms_ansi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ibmpc/ms_ansi.c'\"
else
echo shar: Extracting \"'ibmpc/ms_ansi.c'\" \(6468 characters\)
sed "s/^X//" >'ibmpc/ms_ansi.c' <<'END_OF_FILE'
X/* ibmpc/ms_ansi.c: a set of routines to provide either PCcurses or ANSI output
X
X   Copyright (c) 1989-92 James E. Wilson, Don Kneller
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include <curses.h>
X#include <stdio.h>
X
X#if defined(MSDOS) && defined(ANSI)
X
X#ifdef LINT_ARGS
Xstatic int curses_move(int, int);
Xstatic char *getent(char *,char * *,int );
Xstatic void initansistr(void);
Xstatic int ansi_initscr(void);
Xstatic int ansi_endwin(void);
Xstatic int ansi_addch(int );
Xstatic int ansi_mvaddstr(int ,int ,char *);
Xstatic int ansi_mvprintw(int ,int ,char *,int ,int ,int ,int );
Xstatic int ansi_move(int ,int );
Xstatic int ansi_move_tgoto(int ,int );
Xstatic int ansi_clrtobot(void);
Xstatic int ansi_clrtoeol(void);
Xstatic int ansi_mvaddch(int ,int ,char );
Xstatic int ansi_clear(void);
Xstatic int ansi_refresh(void);
Xstatic int ansi_noop(void);
Xint ansi_prep(int ,int, int);
X#else
Xstatic int	ansi_addch(), ansi_mvaddstr(), ansi_mvprintw(), ansi_move(),
X		ansi_move_tgoto(),
X		ansi_clrtobot(), ansi_clrtoeol(), ansi_mvaddch(), ansi_endwin(),
X		ansi_refresh(), ansi_clear(), ansi_noop(), ansi_initscr();
Xint ansi_prep();
X#endif
X
Xextern char *tgetstr();
Xextern char *getenv();
Xextern char *tgoto();
X
X/* Must supply a functional form of the PCcurses "move" routine */
Xstatic int
Xcurses_move(y, x)
Xint	y, x;
X{
X	return wmove(stdscr, y, x);
X}
X
X/* Default is for curses to be used */
Xint	(*output_addch)() = addch;
Xint	(*output_mvaddstr)() = mvaddstr;
Xint	(*output_mvprintw)() = mvprintw;
Xint	(*output_move)() = curses_move;
Xint	(*output_endwin)() = endwin;
Xint	(*output_clrtobot)() = clrtobot;
Xint	(*output_clrtoeol)() = clrtoeol;
Xint	(*output_mvaddch)() = mvaddch;
Xint	(*output_initscr)() = initscr;
Xint	(*output_refresh)() = refresh;
Xint	(*output_clear)() = clear;
X
Xint	(*output_nocrmode)() = nocrmode;
Xint	(*output_crmode)() = crmode;
Xint	(*output_nonl)() = nonl;
Xint	(*output_nl)() = nl;
Xint	(*output_noecho)() = noecho;
Xint	(*output_echo)() = echo;
Xint	ansi;
Xint	LI;
X
X#define LEFTFIELD	-10;
X#define	NEED		1
X
Xstatic int	moveopt = 1;
Xstatic char	*CE, *CL, *CM, *DO, *LE, *ND, *TE, *TI, *UP;
Xstatic int	currow = 0;
Xstatic int	curcol = LEFTFIELD;
X
Xstatic char	*
Xgetent(str, tbufp, need)
Xchar	*str, **tbufp;
Xint	need;
X{
X	char	*value;
X
X	if ((value = tgetstr(str, tbufp)) == NULL && need == NEED)
X		error("termcap:  Moria needs %s\n", str);
X	return value;
X}
X
Xstatic void
Xinitansistr()
X{
X	static	char tbuf[512];
X	char	temp[1024], *tbufp, *term;
X
X	if ((term = getenv("TERM")) == NULL)
X		term = "ibmpc-mono";
X	if (tgetent(temp, term) < 1)
X		error("Unknown terminal type: %s.", term);
X	tbufp = tbuf;
X	LE = getent("le", &tbufp, NEED);
X	CE = getent("ce", &tbufp, NEED);
X	CL = getent("cl", &tbufp, NEED);
X	CM = getent("cm", &tbufp, NEED);
X	ND = getent("nd", &tbufp, NEED);
X	TE = getent("te", &tbufp, !NEED);
X	TI = getent("ti", &tbufp, !NEED);
X	UP = getent("up", &tbufp, NEED);
X	DO = getent("do", &tbufp, NEED);
X	LI = tgetnum("li");
X	if (LI <= 0)
X		LI = 24;
X}
X
Xansi_prep(check_ansi, domoveopt, truetgoto)
Xint	check_ansi;
Xint	domoveopt;
Xint	truetgoto;
X{
X	moveopt = domoveopt;
X
X	/* Check for ANSI.SYS */
X	if (check_ansi) {
X		/* Clear the input queue */
X		while (kbhit())
X			(void) getch();
X
X		/* Send out the DSR string */
X		fputs("\033[6n", stdout);
X		fflush(stdout);
X
X		/* Is there anything in the input?  If so ANSI responded. */
X		if (kbhit()) {
X			while (kbhit())
X				(void) getch();
X		}
X		else {
X			putchar('\n');
X			error("ANSI.SYS not installed!  See MORIA.DOC for details!\n");
X		}
X	}
X
X	/* get the ANSI strings */
X	initansistr();
X
X	/* change function pointers to ANSI versions */
X	output_addch = ansi_addch;
X	output_mvaddstr = ansi_mvaddstr;
X	output_mvprintw = ansi_mvprintw;
X	if (truetgoto)
X		output_move = ansi_move_tgoto;
X	else
X		output_move = ansi_move;
X	output_clrtobot = ansi_clrtobot;
X	output_clrtoeol = ansi_clrtoeol;
X	output_mvaddch = ansi_mvaddch;
X	output_refresh = ansi_refresh;
X	output_clear = ansi_clear;
X	output_initscr = ansi_initscr;
X	output_endwin = ansi_endwin;
X
X	output_nocrmode =
X	output_crmode =
X	output_nonl =
X	output_nl =
X	output_noecho =
X	output_echo = ansi_noop;
X
X	ansi = 1;
X}
X
Xstatic int
Xansi_initscr()
X{
X	if (TI != NULL)
X		fputs(TI, stdout);
X	return OK;
X}
X
Xstatic int
Xansi_endwin()
X{
X	if (TI != NULL)
X		fputs(TE, stdout);
X	return OK;
X}
X
Xstatic int
Xansi_addch(ch)
Xint	ch;
X{
X	putc(ch, stdout);
X	curcol++;
X	return OK;
X}
X
Xstatic int
Xansi_mvaddstr(row, col, str)
Xint	row, col;
Xchar	*str;
X{
X	(void) ansi_move(row, col);
X	fputs(str, stdout);
X	curcol = LEFTFIELD;
X	return OK;
X}
X
Xstatic int
Xansi_mvprintw(row, col, fmt, a1, a2, a3, a4)
Xint	row, col;
Xchar	*fmt;
Xint	a1, a2, a3, a4;	/* large enough for %c%s%c of files.c ! */
X{
X	(void) ansi_move(row, col);
X	fprintf(stdout, fmt, a1, a2, a3, a4);
X	curcol = LEFTFIELD;
X	return OK;
X}
X
X#define abs(x)	((x) < 0 ? -(x) : (x))
X
X/* For a bit more speed, don't use tgoto() from termcap */
Xstatic int
Xansi_move(row, col)
Xint	row, col;
X{
X	if (moveopt && abs(currow - row) < 3 && abs(curcol - col) < 3) {
X		while (row > currow)
X			fputs(DO, stdout), currow++;
X		while (row < currow)
X			fputs(UP, stdout), currow--;
X		while (col > curcol)
X			fputs(ND, stdout), curcol++;
X		while (col < curcol)
X			fputs(LE, stdout), curcol--;
X	}
X	else
X		fprintf(stdout, "\033[%d;%dH\0__cursor motion__", row+1,col+1);
X	currow = row;
X	curcol = col;
X	return OK;
X}
X
X/* Use tgoto (which is rather slow) */
Xstatic int
Xansi_move_tgoto(row, col)
Xint	row, col;
X{
X	if (moveopt && abs(currow - row) < 3 && abs(curcol - col) < 3) {
X		while (row > currow)
X			fputs(DO, stdout), currow++;
X		while (row < currow)
X			fputs(UP, stdout), currow--;
X		while (col > curcol)
X			fputs(ND, stdout), curcol++;
X		while (col < curcol)
X			fputs(LE, stdout), curcol--;
X	}
X	else {
X		fputs(tgoto(CM, col, row), stdout);
X	}
X	currow = row;
X	curcol = col;
X	return OK;
X}
X
Xstatic int
Xansi_clrtobot()
X{
X	ansi_clrtoeol();
X	ansi_move(++currow, 0);
X	ansi_clrtoeol();
X	for (; currow <= LI; currow++) {
X		fputs(DO, stdout);
X		ansi_clrtoeol();
X	}
X	curcol = LEFTFIELD;
X	return OK;
X}
X
Xstatic int
Xansi_clrtoeol()
X{
X	fputs(CE, stdout);
X	return OK;
X}
X
Xstatic int
Xansi_mvaddch(row, col, ch)
Xint	row, col;
Xchar	ch;
X{
X	ansi_move(row, col);
X	putchar(ch);
X	curcol++;
X	return OK;
X}
X
Xstatic int
Xansi_clear()
X{
X	fputs(CL, stdout);
X	return OK;
X}
X
Xstatic int
Xansi_refresh()
X{
X	fflush(stdout);
X	return OK;
X}
X
Xstatic int
Xansi_noop()
X{
X	return OK;
X}
X#endif
END_OF_FILE
if test 6468 -ne `wc -c <'ibmpc/ms_ansi.c'`; then
    echo shar: \"'ibmpc/ms_ansi.c'\" unpacked with wrong size!
fi
# end of 'ibmpc/ms_ansi.c'
fi
if test -f 'mac/macrsrc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/macrsrc.c'\"
else
echo shar: Extracting \"'mac/macrsrc.c'\" \(7982 characters\)
sed "s/^X//" >'mac/macrsrc.c' <<'END_OF_FILE'
X/* mac/macrsrc.c: code for handling C data as resources
X
X   Copyright (c) 1989-92 Curtis McCauley, James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include <stdio.h>
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X#include "macrsrc.h"
X
Xrestable_type restable[MAX_RESOURCES] = {
X#ifndef RSRC_PART2
X	{
X		#ifdef RSRC
X			(char *) object_list, "Object List",
X		#else
X			(char **) &object_list, NULL,
X		#endif
X		treasureRsrc, object_list_id,
X		MAX_OBJECTS, sizeof(treasure_type),
X		treasure_strproc,
X		TRUE									},
X#endif
X#ifndef RSRC_PART1
X	{
X		#ifdef RSRC
X			(char *) background, "Background Table",
X		#else
X			(char **) &background, NULL,
X		#endif
X		backgroundRsrc, background_id,
X		MAX_BACKGROUND, sizeof(background_type),
X		background_strproc,
X		TRUE									},
X	{
X		#ifdef RSRC
X			(char *) magic_spell, "Magic Spells",
X		#else
X			(char **) &magic_spell, NULL,
X		#endif
X		spellRsrc, magic_spell_id,
X		(MAX_CLASS-1) * 31, sizeof(spell_type),
X		NULL,
X		TRUE									},
X	{
X		#ifdef RSRC
X			(char *) player_title, "Player Titles",
X		#else
X			(char **) &player_title, NULL,
X		#endif
X		charPtrRsrc, player_title_id,
X		MAX_CLASS * MAX_PLAYER_LEVEL, sizeof(char *),
X		char_ptr_strproc,
X		TRUE									},
X	{
X		#ifdef RSRC
X			(char *) race, "Race List",
X		#else
X			(char **) &race, NULL,
X		#endif
X		raceRsrc, race_id,
X		MAX_RACES, sizeof(race_type),
X		race_strproc,
X		TRUE									},
X	{
X		#ifdef RSRC
X			(char *) c_list, "Creature List",
X		#else
X			(char **) &c_list, NULL,
X		#endif
X		monsterRsrc, c_list_id,
X		MAX_CREATURES, sizeof(creature_type),
X		creature_strproc,
X		TRUE									},
X	{
X		#ifdef RSRC
X			(char *) owners, "Owner List",
X		#else
X			(char **) &owners, NULL,
X		#endif
X		ownerRsrc, owners_id,
X		MAX_OWNERS, sizeof(owner_type),
X		owner_strproc,
X		TRUE									},
X	{
X		#ifdef RSRC
X			(char *) colors, "Colors",
X		#else
X			(char **) &colors, NULL,
X		#endif
X		charPtrRsrc, colors_id,
X		MAX_COLORS, sizeof(char *),
X		char_ptr_strproc,
X		TRUE									},
X	{
X		#ifdef RSRC
X			(char *) mushrooms, "Mushrooms",
X		#else
X			(char **) &mushrooms, NULL,
X		#endif
X		charPtrRsrc, mushrooms_id,
X		MAX_MUSH, sizeof(char *),
X		char_ptr_strproc,
X		TRUE									},
X	{
X		#ifdef RSRC
X			(char *) woods, "Woods",
X		#else
X			(char **) &woods, NULL,
X		#endif
X		charPtrRsrc, woods_id,
X		MAX_WOODS, sizeof(char *),
X		char_ptr_strproc,
X		TRUE									},
X	{
X		#ifdef RSRC
X			(char *) metals, "Metals",
X		#else
X			(char **) &metals, NULL,
X		#endif
X		charPtrRsrc, metals_id,
X		MAX_METALS, sizeof(char *),
X		char_ptr_strproc,
X		TRUE									},
X	{
X		#ifdef RSRC
X			(char *) rocks, "Rocks",
X		#else
X			(char **) &rocks, NULL,
X		#endif
X		charPtrRsrc, rocks_id,
X		MAX_ROCKS, sizeof(char *),
X		char_ptr_strproc,
X		TRUE									},
X	{
X		#ifdef RSRC
X			(char *) amulets, "Amulets",
X		#else
X			(char **) &amulets, NULL,
X		#endif
X		charPtrRsrc, amulets_id,
X		MAX_AMULETS, sizeof(char *),
X		char_ptr_strproc,
X		TRUE									},
X	{
X		#ifdef RSRC
X			(char *) syllables, "Syllables",
X		#else
X			(char **) &syllables, NULL,
X		#endif
X		charPtrRsrc, syllables_id,
X		MAX_SYLLABLES, sizeof(char *),
X		char_ptr_strproc,
X		TRUE								}
X#endif
X};
X
X#ifdef MACGAME
Xmemtable_type memtable[MAX_PTRS] = {
X	{ (char **) &cave,
X		MAX_HEIGHT * MAX_WIDTH, sizeof(cave_type),
X		TRUE										},
X	{ (char **) &store,
X		MAX_STORES, sizeof(store_type),
X		TRUE										},
X	{ (char **) &c_recall,
X		MAX_CREATURES, sizeof(recall_type),
X		TRUE										},
X};
X#endif
X
X#ifndef RSRC_PART1
Xrestart_type restart_vars[MAX_RESTART] = {
X
X	/* treasure.c */
X	{ (char *) &inven_ctr, 				sizeof(inven_ctr)				},
X	{ (char *) &inven_weight, 			sizeof(inven_weight)			},
X	{ (char *) &equip_ctr, 				sizeof(equip_ctr)				},
X
X	/* variable.c */
X	{ (char *) &weapon_heavy, 			sizeof(weapon_heavy)			},
X	{ (char *) &pack_heavy, 			sizeof(pack_heavy)				},
X	{ (char *) &total_winner, 			sizeof(total_winner)			},
X	{ (char *) &character_generated,	sizeof(character_generated)		},
X	{ (char *) &character_saved, 		sizeof(character_saved)			},
X	{ (char *) &dun_level, 				sizeof(dun_level)				},
X	{ (char *) &missile_ctr, 			sizeof(missile_ctr)				},
X	{ (char *) &last_msg, 				sizeof(last_msg)				},
X	{ (char *) &death, 					sizeof(death)					},
X	{ (char *) &default_dir, 			sizeof(default_dir)				},
X	{ (char *) &turn, 					sizeof(turn)					},
X	{ (char *) &wizard, 				sizeof(wizard)					},
X	{ (char *) &panic_save, 			sizeof(panic_save)				},
X	{ (char *) &noscore, 				sizeof(noscore)					},
X	{ (char *) &find_cut, 				sizeof(find_cut)				},
X	{ (char *) &find_examine, 			sizeof(find_examine)			},
X	{ (char *) &find_bound, 			sizeof(find_bound)				},
X	{ (char *) &find_prself, 			sizeof(find_prself)				},
X	{ (char *) &prompt_carry_flag, 		sizeof(prompt_carry_flag)		},
X	{ (char *) &show_weight_flag, 		sizeof(show_weight_flag)		},
X	{ (char *) &highlight_seams, 		sizeof(highlight_seams)			},
X	{ (char *) &find_ignore_doors, 		sizeof(find_ignore_doors)		},
X	{ (char *) &doing_inven, 			sizeof(doing_inven)				},
X	{ (char *) &screen_change, 			sizeof(screen_change)			},
X	{ (char *) &eof_flag,				sizeof (eof_flag)				},
X	{ (char *) &wait_for_more, 			sizeof(wait_for_more)			},
X	{ (char *) &spell_learned, 			sizeof(spell_learned)			},
X	{ (char *) &spell_worked, 			sizeof(spell_worked)			},
X	{ (char *) &spell_forgotten, 		sizeof(spell_forgotten)			},
X
X	/* moved to variable.c from elsewhere */
X	{ (char *) &last_command,			sizeof(last_command)			},
X	{ (char *) &light_flag,				sizeof(light_flag)				}
X
X};
X#endif
X
X#ifdef MACGAME
Xclrtable_type clrtable[MAX_CLRS] = {
X
X	/* these are not initialized, but probably ought to be */
X
X	/* treasure.c */
X	{ (char *) &object_ident, 			sizeof(object_ident)			},
X	{ (char *) &t_level, 				sizeof(t_level)					},
X	{ (char *) &t_list, 				sizeof(t_list)					},
X	{ (char *) &inventory, 				sizeof(inventory)				},
X
X	/* monsters.c */
X	{ (char *) &m_level, 				sizeof(m_level)					},
X	{ (char *) &m_list, 				sizeof(m_list)					},
X
X	/* variable.c */
X	{ (char *) &panel_row, 				sizeof(panel_row)				},
X	{ (char *) &panel_col, 				sizeof(panel_col)				},
X	{ (char *) &panel_row_min, 			sizeof(panel_row_min)			},
X	{ (char *) &panel_row_max, 			sizeof(panel_row_max)			},
X	{ (char *) &panel_col_min, 			sizeof(panel_col_min)			},
X	{ (char *) &panel_col_max, 			sizeof(panel_col_max)			},
X	{ (char *) &panel_row_prt, 			sizeof(panel_row_prt)			},
X	{ (char *) &panel_col_prt, 			sizeof(panel_col_prt)			},
X	{ (char *) &py,						sizeof(py)						},
X	{ (char *) &max_score,				sizeof (max_score)				}
X
X};
X#endif
X
X/* String procs are used by the DumpRes package to make sure that	*/
X/* char *'s imbedded in the stucts are dumped or loaded properly.	*/
X/* All that is required is to pass a pointer to the pointer to the	*/
X/* supplied subroutine for each char * field in the struct.			*/
X
Xvoid treasure_strproc(ptr, proc)
Xchar *ptr;
Xvoid (*proc)(char **str);
X
X{
X	(*proc)(&((treasure_type *) ptr)->name);
X	return;
X}
X
Xvoid creature_strproc(ptr, proc)
Xchar *ptr;
Xvoid (*proc)(char **str);
X
X{
X	(*proc)(&((creature_type *) ptr)->name);
X	return;
X}
X
Xvoid race_strproc(ptr, proc)
Xchar *ptr;
Xvoid (*proc)(char **str);
X
X{
X	(*proc)(&((race_type *) ptr)->trace);
X	return;
X}
X
Xvoid background_strproc(ptr, proc)
Xchar *ptr;
Xvoid (*proc)(char **str);
X
X{
X	(*proc)(&((background_type *) ptr)->info);
X	return;
X}
X
Xvoid owner_strproc(ptr, proc)
Xchar *ptr;
Xvoid (*proc)(char **str);
X
X{
X	(*proc)(&((owner_type *) ptr)->owner_name);
X	return;
X}
X
X/* This is for arrays of char *'s, which can be treated essentially	*/
X/* as structs with a single field - the char *.  It is inefficient,	*/
X/* since the array of char *'s, garbage data, is created as a		*/
X/* resource along with the STR# resource, but has the advantage of	*/
X/* not requiring special casing.									*/
X
Xvoid char_ptr_strproc(ptr, proc)
Xchar *ptr;
Xvoid (*proc)(char **str);
X
X{
X	(*proc)((char **) ptr);
X	return;
X}
END_OF_FILE
if test 7982 -ne `wc -c <'mac/macrsrc.c'`; then
    echo shar: \"'mac/macrsrc.c'\" unpacked with wrong size!
fi
# end of 'mac/macrsrc.c'
fi
if test -f 'mac/moria.ro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/moria.ro'\"
else
echo shar: Extracting \"'mac/moria.ro'\" \(8153 characters\)
sed "s/^X//" >'mac/moria.ro' <<'END_OF_FILE'
X/NOSCROLL
XMacMoria.rsrc
XRSRCMRIA
X
X* #include "Types.r"
X
XINCLUDE ScrnMgr.rsrc
XINCLUDE MacMoria.dump.rsrc
XINCLUDE MacMoria.misc.rsrc
X
X* type 'MRIA' as 'STR ';
X
X* type 'CNFG' (256 : 257) {
X* 	longint;
X* };
X
X*type 'TEXT' {
X*	string;
X*};
X
X*resource 'MRIA' (0) {
X*	"Moria 5.4 for the Macintosh"
X*};
X
XTYPE MRIA = GNRL
X , 0
X.P
XMoria 5.4 for the Macintosh
X
X
XTYPE BNDL
XMRIA, 128 (32)
XMRIA 0
XICN#
X0 128 1 129 2 130
XFREF
X0 128 1 129 2 130 3 131 4 132
X			;;/* [1] Appilication */
X			;;/* [2] Save file */
X			;;/* [3] Info files */
X			;;/* [4] Score file */
X			;;/* [5] Config file */
X
XTYPE FREF
XApplication, 128 (32)
XAPPL 0
X
XTYPE FREF
XSave Files, 129 (32)
XSAVE 1
X
XTYPE FREF
XInfo Files, 130 (32)
XTEXT 2
X
XTYPE FREF
XScore File, 131 (32)
XSCOR 2
X
XTYPE FREF
XConfig File, 132 (32)
XCNFG 2
X
X
XTYPE ICON = GNRL
XApplication, 128 (32)
X.H
X 0001 0000 0002 8000 0004 4000 0008 2000
X 0010 1000 0022 0800 0045 0400 0088 8200
X 0105 1500 0202 A880 0440 4040 08A8 8020
X 1115 0010 248A 0028 4051 3F44 9120 C08A
X 4000 8051 2441 3022 1001 C814 091E 7F8F
X 0402 3007 0241 0007 0100 8007 0080 6007
X 0040 1FE7 0020 021F 0010 0407 0008 0800
X 0004 1000 0002 2000 0001 4000 0000 8000
X
X
XTYPE ICON = GNRL
XCommand Set, 256 (32)
X.H
X 0000 0000 0000 0000 0000 0000 0000 0000
X 0000 0000 0000 0000 0000 0000 0000 0000
X 0000 0000 7FFF FFFE 8000 0001 9AAA AAA9
X 8000 0001 9555 5559 8000 0001 9AAA AAA9
X 8000 0001 857F FF51 8000 0001 8000 0001
X 7FFF FFFE 0000 0000 0000 0000 0000 0000
X 0000 0000 0000 0000 0000 0000 0000 0000
X 0000 0000 0000 0000 0000 0000 0000 0000
X
X
XTYPE ICON = GNRL
XTEXT Editor, 257 (32)
X.H
X 0FFF FE00 0800 0300 0800 0280 0800 0240
X 0800 0220 0800 0210 0800 03F8 0800 0008
X 0800 0008 0807 C008 080F E008 0818 3008
X 0830 1808 0820 1808 0800 1808 0800 3008
X 0800 6008 0800 C008 0801 8008 0801 8008
X 0801 8008 0801 8008 0800 0008 0801 8008
X 0803 C008 0801 8008 0800 0008 0800 0008
X 0800 0008 0800 0008 0800 0008 0FFF FFF8
X
X
XTYPE ICN# = GNRL
XApplication, 128 (32)
X.H
X*		/* [1] */
X 0001 0000 0002 8000 0004 4000 0008 2000
X 0010 1000 0022 0800 0045 0400 0088 8200
X 0105 1500 0202 A880 0440 4040 08A8 8020
X 1115 0010 248A 0028 4051 3F44 9120 C08A
X 4000 8051 2441 3022 1001 C814 091E 7F8F
X 0402 3007 0241 0007 0100 8007 0080 6007
X 0040 1FE7 0020 021F 0010 0407 0008 0800
X 0004 1000 0002 2000 0001 4000 0000 8000
X*		/* [2] */
X 0001 0000 0003 8000 0007 C000 000F E000
X 001F F000 003F F800 007F FC00 00FF FE00
X 01FF FF00 03FF FF80 07FF FFC0 0FFF FFE0
X 1FFF FFF0 3FFF FFF8 7FFF FFFC FFFF FFFE
X 7FFF FFFF 3FFF FFFE 1FFF FFFC 0FFF FFFF
X 07FF FFFF 03FF FFFF 01FF FFFF 00FF FFFF
X 007F FFFF 003F FE1F 001F FC07 000F F800
X 0007 F000 0003 E000 0001 C000 0000 8000
X
XTYPE ICN# = GNRL
XSave Files, 129 (32)
X.H
X*		/* [1] */
X 0FFF FE00 0800 0300 0800 0280 0800 0240
X 0800 0220 0800 0210 0800 03F8 0800 0008
X 0800 0008 087F FE08 08FF FF08 0980 0188
X 099F F988 09B0 0988 09B1 2988 0992 A988
X 0991 2988 09B0 4988 09B0 0988 099F F988
X 0980 0188 09FF FF88 09FF FF88 0980 0188
X 0800 0008 0912 6488 09B5 5548 0955 65C8
X 0915 5548 0912 5548 0800 0008 0FFF FFF8
X*		/* [2] */
X 0FFF FE00 0FFF FF00 0FFF FF80 0FFF FFC0
X 0FFF FFE0 0FFF FFF0 0FFF FFF8 0FFF FFF8
X 0FFF FFF8 0FFF FFF8 0FFF FFF8 0FFF FFF8
X 0FFF FFF8 0FFF FFF8 0FFF FFF8 0FFF FFF8
X 0FFF FFF8 0FFF FFF8 0FFF FFF8 0FFF FFF8
X 0FFF FFF8 0FFF FFF8 0FFF FFF8 0FFF FFF8
X 0FFF FFF8 0FFF FFF8 0FFF FFF8 0FFF FFF8
X 0FFF FFF8 0FFF FFF8 0FFF FFF8 0FFF FFF8
X
XTYPE ICN# = GNRL
XAux Files, 130 (32)
X.H
X*		/* [1] */
X 0FFF FE00 0800 0300 0800 0280 09FB AE40
X 0800 0220 0800 0210 09F7 7BF8 0800 0008
X 0800 0008 09BB EDC8 0800 0008 0800 0008
X 09F7 B7C8 0800 0008 0800 0008 09B5 FDC8
X 0800 0008 0800 0008 0977 B6C8 0800 0008
X 0800 0008 09EB B748 0800 0008 0800 0008
X 0800 0008 0912 6488 09B5 5548 0955 65C8
X 0915 5548 0912 5548 0800 0008 0FFF FFF8
X*		/* [2] */
X 0FFF FE00 0FFF FF00 0FFF FF80 0FFF FFC0
X 0FFF FFE0 0FFF FFF0 0FFF FFF8 0FFF FFF8
X 0FFF FFF8 0FFF FFF8 0FFF FFF8 0FFF FFF8
X 0FFF FFF8 0FFF FFF8 0FFF FFF8 0FFF FFF8
X 0FFF FFF8 0FFF FFF8 0FFF FFF8 0FFF FFF8
X 0FFF FFF8 0FFF FFF8 0FFF FFF8 0FFF FFF8
X 0FFF FFF8 0FFF FFF8 0FFF FFF8 0FFF FFF8
X 0FFF FFF8 0FFF FFF8 0FFF FFF8 0FFF FFF8
X
X
XTYPE DLOG
XAbout, 128 (32)
XAbout UMoria
X46 26 304 274
XInvisible NoGoAway
X0
X0
X128
X
X
XTYPE DITL
XAbout, 128
X4
X
Xbutton
X224 192 247 235
XOK
X
XuserItem disabled
X232 224 241 233
X
XstaticText disabled
X16 8 248 184
X^0\0D\0D++
XProgrammers:\0D++
X  Robert Alan Koeneke\0D++
X  Jimmey Wayne Todd\0D\0D++
XUNIX Port:\0D++
X  James E. Wilson\0D\0D++
XMacintosh Port:\0D++
X  Curtis W. McCauley\0D++
X  Benjamin E. Schreiber
X
XiconItem disabled
X16 195 48 227
X128
X
X
XTYPE STR
XAbout Title, 128
XAbout Moria\C9
X
X
XTYPE CNFG = GNRL
XCommand Set, 256 (32)
X.S
X-o\00\00
X
X
XTYPE DLOG
XCommand Set, 256 (32)
XCommand Set
X42 34 218 404
XInvisible NoGoAway
X0
X0
X256
X
X
XTYPE DITL
XCommand Set, 256 (32)
X9
X
Xbutton
X24 296 48 352
XOK
X
Xbutton
X64 296 88 352
XCancel
X
XradioButton
X40 24 56 200
XRogue-Like Commands
X
XradioButton
X64 24 80 200
XOriginal Commands
X
XstaticText disabled
X112 72 168 352
XChoose the desired command set.  The change will take effect when you start the next game.
X
XuserItem disabled
X16 16 96 232
X
XstaticText
X8 24 24 104
XChoose one
X
XuserItem disabled
X32 336 40 344
X
XiconItem disabled
X112 16 144 48
X256
X
X
XTYPE CNFG = GNRL
XTEXT Editor, 257 (32)
X.S
XMACA
X
X
XTYPE DLOG
XTEXT Editor, 257 (32)
XTEXT Editor
X42 34 226 426
XInvisible NoGoAway
X0
X0
X257
X
X
XTYPE DITL
XTEXT Editor, 257 (32)
X11
X
Xbutton
X24 320 48 376
XOK
X
Xbutton
X64 320 88 376
XCancel
X
XradioButton
X40 24 56 200
XMacWrite
X
XradioButton
X64 24 80 176
XMicrosoft Word
X
XradioButton
X88 24 104 176
XOther:  File Creator
X
XeditText disabled
X88 176 104 240
X
X
XstaticText disabled
X136 72 176 376
XChoose what kind of documents you want Moria to create ++
Xwhen it prints to a file
X
XuserItem disabled
X16 8 120 264
X
XstaticText
X8 24 24 104
XChoose One
X
XuserItem disabled
X32 360 40 368
X
XiconItem disabled
X136 16 168 48
X257
X
X
XTYPE DLOG
XSave Quit or Cancel, 258 (32)
XSave Quit or Cancel
X40 40 168 318
XInvisible NoGoAway
X0
X0
X258
X
X
XTYPE DITL
XSave Quit or Cancel, 258 (32)
X6
X
Xbutton
X64 16 84 76
XSave
X
Xbutton
X96 16 116 76
XQuit
X
Xbutton
X96 200 116 260
XCancel
X
XuserItem disabled
X64 200 80 216
X
XstaticText disabled
X8 56 48 264
XWhat do you want to do with the game in progress?
X
XiconItem disabled
X8 16 40 48
X0
X
X
X
XTYPE MENU
XFile, 129
XFile
XNew/N
XOpen\C9/O
X(-
XSave/S
XSave As\C9
X(-
XQuit/Q
X
X
XTYPE MENU
XFile (No Keys), 229
XFile
XNew
XOpen\C9
X(-
XSave
XSave As\C9
X(-
XQuit
X
X
XTYPE MENU
XMoria, 133
XMoria
XHelp\C9/H
XCommand Set\C9
XTEXT Editor\C9
X(-
XHigh Scores\C9
X
X
XTYPE MENU
XMoria (No keys), 233
XMoria
XHelp\C9
XCommand Set\C9
XTEXT Editor\C9
X(-
XHigh Scores\C9
X
X
XTYPE DLOG
XMac Help, 512 (32)
XHelp
X40 34 310 496
XInvisible NoGoAway
X0
X0
X512
X
X
XTYPE DITL
XMac Help, 512 (32)
X6
X
Xbutton
X16 392 36 452
XOK
X
XuserItem disabled
X24 432 32 440
X
XuserItem disabled
X48 8 264 440
X
XctrlItem
X48 439 264 455
X512
X
XstaticText Disabled
X8 52 40 380
X^0
X
XiconItem disabled
X8 8 40 40
X128
X
X
XTYPE CNTL
XMac Help Scroll Bar, 512 (32)
XScroll
X0 0 216 16
XVisible
X16
X0
X0 0 0
X
X
X*type 'DFPR' {
X*	unsigned hex integer = $600A;					/* branch around header */
X*	unsigned hex integer;							/* flags */
X*	unsigned literal longint;						/* resource type */
X*	integer;										/* resource id */
X*	integer;										/* version */
X*	unsigned hex integer = $4EF9;					/* jump instruction */
X*	unsigned hex longint = $0;						/* target address for jump */
X*};
X
X*type 'LDEF' as 'DFPR';
X
XTYPE LDEF = GNRL
XHigh Scores, 514 (32)
X.H
X600A
X0000
X.S
XLDEF
X.I
X514
X0
X.H
X4EF9
X0000
X
X
XTYPE DLOG
XHigh Scores, 514 (32)
XHigh Scores
X40 34 327 526
XInvisible NoGoAway
X0
X0
X514
X
XTYPE DITL
XHigh Scores, 514 (32)
X5
X
Xbutton
X15 422 35 482
XOK
X
XuserItem Disabled
X24 464 32 472
X
XuserItem Disabled
X48 2 281 490
X
XstaticText Disabled
X8 56 40 336
XMoria High Scores\0D Positions ^0 to ^1
X
XiconItem Disabled
X8 8 40 40
X128
X
X
XTYPE ALRT
XGeneral Error, 1024 (32)
X42 42 148 416
X1024
X7777
X
XTYPE DITL
XGeneral Error, 1024 (32)
X2
X
Xbutton
X80 304 100 364
XOK
X
XstaticText Disabled
X7 68 71 364
X^0
X
X
X*resource 'SIZE' (-1) {
X*	dontSaveScreen,
X*	acceptSuspendResumeEvents,
X*	enableOptionSwitch,
X*	canBackground,
X*	multiFinderAware,
X*	backgroundAndForeground,
X*	dontGetFrontClicks,
X*	ignoreChildDiedEvents,
X*	not32BitCompatible,
X*	reserved,
X*	reserved,
X*	reserved,
X*	reserved,
X*	reserved,
X*	reserved,
X*	reserved,
X*	375 * 1024,
X*	375 * 1024
X*};
END_OF_FILE
if test 8153 -ne `wc -c <'mac/moria.ro'`; then
    echo shar: \"'mac/moria.ro'\" unpacked with wrong size!
fi
# end of 'mac/moria.ro'
fi
if test -f 'mac/scrnmgr/ScrnMgr.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/scrnmgr/ScrnMgr.h'\"
else
echo shar: Extracting \"'mac/scrnmgr/ScrnMgr.h'\" \(7454 characters\)
sed "s/^X//" >'mac/scrnmgr/ScrnMgr.h' <<'END_OF_FILE'
X/* mac/scrnmgr/ScrnMgr.h: definitions for scrnmgr code
X
X   Copyright (c) 1989-1991 Curtis McCauley, James E. Wilson
X
X   You may copy this subroutine package freely, modify it as you desire,
X   and distribute it at will, as long as the copyright notice in the source
X   material is not disturbed, excepting that no one may use this package or
X   any part of it for commercial purposes of any kind without the express
X   written consent of its author. */
X
X#ifndef __SCRNMGR__
X
X#define __SCRNMGR__
X
X#ifdef THINK_C
X#include <MacTypes.h>
X#else
X#include <Types.h>
X#endif
X
X#ifdef THINK_C
X#define nil 0				/* Think C doesn't have nil. -- BS  */
X#endif
X
X#define MakeAttr(f, b)		(char) ((f<<3) | b)
X
X#define AttrFore(a)			(char) ((a>>3) & 0x7)
X#define AttrBack(a)			(char) (a & 0x7)
X
X#define attrColorWhite		0
X#define attrColorBlack		1
X#define attrColorRed		2
X#define attrColorGreen		3
X#define attrColorBlue		4
X#define attrColorCyan		5
X#define attrColorMagenta	6
X#define attrColorYellow		7
X
X#define attrColorBack		0
X#define attrColorFore		1
X
X#define attrNormal	    	MakeAttr(attrColorFore, attrColorBack)
X#define attrReversed		MakeAttr(attrColorBack, attrColorFore)
X
X#define attrUnderlined		0x80
X#define attrItalicized		0x40
X
X#define twoColor			0
X#define multiColor			1
X
X#define maskAttrFlags		0xC0
X#define maskAttrColors		0x3F
X
X#define maskModCommand		0x01
X#define maskModShift		0x02
X#define maskModCapsLock		0x04
X#define maskModOption		0x08
X#define maskModControl		0x10
X#define maskModMouse		0x80
X
X#define fixHalf				0x8000
X#define fixThird			0x5555
X#define fixQuarter			0x4000
X#define fixFifth			0x3333
X#define fixSixth			0x2AAA
X#define fixSeventh			0x2492
X#define fixEighth			0x2000
X#define fixNinth			0x1C71
X#define fixTenth			0x1999
X
X#define akNormal			0
X#define akStop				1
X#define akNote				2
X#define akCaution			3
X
X#define closeBoxItem		0
X
X#define scrnErrOk			0
X#define scrnErrNoMem		-1
X
Xlong InitScreenMgr(long h, long v, char *title,
X	char *resFile, OSType rfCreator, OSType rfType,
X	void (*fileMenuProc)(long item),
X	void (*appMenuProc)(long item),
X	long multiColorFlag);
X
Xvoid IdleScreenMgr(void);
X
Xvoid ShowScreen(long visible);
X
Xvoid CloseScreenMgr(void);
X
Xvoid SetScreenQuitProc(void (*quitProc)(void), long willReturnFlag);
X
Xvoid SetScreenAboutProc(void (*aboutProc)(void));
X
Xvoid XSetScreenChar(int d, char c, long h, long v);
Xvoid XSetScreenBuffer(int d, char *buffer, long rowBytes, Rect *area,
X		      long h, long v);
Xvoid XSetScreenString(int d, char *str, long h, long v);
X
Xvoid XSetScreenCharAttr(int d, char c, char a, long h, long v);
Xvoid XSetScreenBufferAttr(int d, char *buffer, char a, long rowBytes,
X			  Rect *area, long h, long v);
Xvoid XSetScreenStringAttr(int d, char *str, char a, long h, long v);
X
Xvoid XSetScreenImage(int d, char *c, char *a, long rowBytes, Rect *area,
X		     long h, long v);
X
Xvoid XWriteScreenChar(int d, char c);
Xvoid XWriteScreenBuffer(int d, char *buffer, long rowBytes, Rect *area);
Xvoid XWriteScreenString(int d, char *str);
X
Xvoid XWriteScreenCharAttr(int d, char c, char a);
Xvoid XWriteScreenBufferAttr(int d, char *buffer, char a, long rowBytes,
X			    Rect *area);
Xvoid XWriteScreenStringAttr(int d, char *str, char a);
X
Xvoid XWriteScreenImage(int d, char *c, char *a, long rowBytes, Rect *area);
X
Xvoid XFillScreen(int d, char c, char a, Rect *area);
Xvoid XEraseScreen(int d, Rect *area);
X
Xvoid XScrollScreen(int d, long dh, long dv, Rect *area, char a);
X
Xvoid XMoveScreenCursor(int d, long h, long v);
Xvoid XSetScreenCursor(int d, long h, long v);
X
X#define SetScreenChar(c, h, v)						XSetScreenChar(0, c, h, v)
X#define SetScreenBuffer(b, rb, area, h, v)	\
X		XSetScreenBuffer(0, b, rb, area, h, v)
X#define SetScreenString(str, h, v)					XSetScreenString(0, str, h, v)
X
X#define SetScreenCharAttr(c, a, h, v)				XSetScreenCharAttr(0, c, a, h, v)
X#define SetScreenBufferAttr(b, a, rb, area, h, v)	\
X		XSetScreenBufferAttr(0, b, a, rb, area, h, v)
X#define SetScreenStringAttr(str, a, h, v)		\
X		XSetScreenStringAttr(0, str, a, h, v)
X
X#define SetScreenImage(c, a, rb, area, h, v)		\
X		XSetScreenImage(0, c, a, rb, area, h, v)
X
X#define WriteScreenChar(c)							XWriteScreenChar(0, c)
X#define WriteScreenBuffer(b, rb, area)				XWriteScreenBuffer(0, b, rb, area)
X#define WriteScreenString(str)						XWriteScreenString(0, str)
X
X#define WriteScreenCharAttr(c, a)					XWriteScreenCharAttr(0, c, a)
X#define WriteScreenBufferAttr(b, a, rb, area)		\
X		XWriteScreenBufferAttr(0, b, a, rb, area)
X#define WriteScreenStringAttr(str, a)				XWriteScreenStringAttr(0, str, a)
X
X#define WriteScreenImage(c, a, rb, area)		\
X		XWriteScreenImage(0, c, a, rb, area)
X
X#define FillScreen(c, a, area)						XFillScreen(0, c, a, area)
X#define EraseScreen(area)							XEraseScreen(0, area)
X
X#define ScrollScreen(dh, dv, area, a)				XScrollScreen(0, dh, dv, area, a)
X
X#define MoveScreenCursor(h, v)						XMoveScreenCursor(0, h, v)
X#define SetScreenCursor(h, v)						XSetScreenCursor(0, h, v)
X
X#define DSetScreenChar(c, h, v)						XSetScreenChar(1, c, h, v)
X#define DSetScreenBuffer(b, rb, area, h, v)		\
X		XSetScreenBuffer(1, b, rb, area, h, v)
X#define DSetScreenString(str, h, v)					XSetScreenString(1, str, h, v)
X
X#define DSetScreenCharAttr(c, a, h, v)				XSetScreenCharAttr(1, c, a, h, v)
X#define DSetScreenBufferAttr(b, a, rb, area, h, v)	\
X		XSetScreenBufferAttr(1, b, a, rb, area, h, v)
X#define DSetScreenStringAttr(str, a, h, v)		\
X		XSetScreenStringAttr(1, str, a, h, v)
X
X#define DSetScreenImage(c, a, rb, area, h, v)		\
X		XSetScreenImage(1, c, a, rb, area, h, v)
X
X#define DWriteScreenChar(c)							XWriteScreenChar(1, c)
X#define DWriteScreenBuffer(b, rb, area)				XWriteScreenBuffer(1, b, rb, area)
X#define DWriteScreenString(str)						XWriteScreenString(1, str)
X
X#define DWriteScreenCharAttr(c, a)					XWriteScreenCharAttr(1, c, a)
X#define DWriteScreenBufferAttr(b, a, rb, area)		\
X		XWriteScreenBufferAttr(1, b, a, rb, area)
X#define DWriteScreenStringAttr(str, a)				XWriteScreenStringAttr(1, str, a)
X
X#define DWriteScreenImage(c, a, rb, area)		\
X		XWriteScreenImage(1, c, a, rb, area)
X
X#define DFillScreen(c, a, area)						XFillScreen(1, c, a, area)
X#define DEraseScreen(area)							XEraseScreen(1, area)
X
X#define DScrollScreen(dh, dv, area, a)				XScrollScreen(1, dh, dv, area, a)
X
X#define DMoveScreenCursor(h, v)						XMoveScreenCursor(1, h, v)
X#define DSetScreenCursor(h, v)						XSetScreenCursor(1, h, v)
X
Xvoid DefineScreenCursor(long color, long lines, long blinkRate);
Xvoid HideScreenCursor(void);
Xvoid ShowScreenCursor(void);
X
Xvoid UpdateScreen(void);
X
Xvoid FlushScreenKeys(void);
Xlong CountScreenKeys(void);
Xint GetScreenKeys(char *keyCode, char *modifiers, char *ascii, short *h,
X		  short *v);
X
Xvoid EnableScreenMouse(long flag);
Xvoid ClipScreenMouse(Rect *clip);
X
Xvoid GetScreenCharAttr(char *c, char *a, long h, long v);
Xvoid GetScreenImage(char *c, char *a, long rowBytes, Rect *area, long h,
X		    long v);
X
Xvoid GetScreenCursor(long *h, long *v);
X
Xlong YesOrNo(char *question);
Xlong DoScreenALRT(long id, long kind, Fixed hRatio, Fixed vRatio);
X
Xvoid GetScreenBounds(Rect *bounds);
X
Xvoid CenterScreenDLOG(long id, Fixed hRatio, Fixed vRatio, long *h, long *v);
X
Xpascal void DrawDefaultBorder();
Xpascal void DrawGroupRect();
X
Xvoid ConfigScreenMgr(long force, ResType theType, long theID,
X		     long (*ConfigProc)(Handle theData));
X
Xvoid BeginScreenWait(long rate);
Xvoid EndScreenWait(void);
X
XHandle GetFileMHandle(void);
XHandle GetAppMHandle(void);
X
Xlong PushScreen(void);
Xvoid PopScreen(void);
X
X#endif
END_OF_FILE
if test 7454 -ne `wc -c <'mac/scrnmgr/ScrnMgr.h'`; then
    echo shar: \"'mac/scrnmgr/ScrnMgr.h'\" unpacked with wrong size!
fi
# end of 'mac/scrnmgr/ScrnMgr.h'
fi
if test -f 'mac/scrnmgr/ScrnTest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/scrnmgr/ScrnTest.c'\"
else
echo shar: Extracting \"'mac/scrnmgr/ScrnTest.c'\" \(6460 characters\)
sed "s/^X//" >'mac/scrnmgr/ScrnTest.c' <<'END_OF_FILE'
X/* mac/scrnmgr/ScrnTest.c: test driver for scrnmgr code
X
X   Copyright (c) 1989-1991 Curtis McCauley, James E. Wilson
X
X   You may copy this subroutine package freely, modify it as you desire,
X   and distribute it at will, as long as the copyright notice in the source
X   material is not disturbed, excepting that no one may use this package or
X   any part of it for commercial purposes of any kind without the express
X   written consent of its author. */
X
X/* Mac interface files required only for the call to TickCount() */
X
X#ifndef THINK_C
X#include <Types.h>
X#include <Quickdraw.h>
X#include <Events.h>
X#else
X#define NULL 0
X#endif
X
X#include "ScrnMgr.h"
X
Xstatic long done;
X
X/*	This routine handles the items in the application menu.  It gets called
X	by the screen manager whenever the user selects from that menu with the
X	appropriate item number. */
X
X/* 	Spins the watch cursor for n seconds, rotating the hands 4 times a
X	second. */
X
Xstatic void Wait(n)
Xint n;
X
X{
X	long tick;
X
X	tick = TickCount() + n * 60L;
X
X	BeginScreenWait(15);
X	while (TickCount() < tick)
X	  SystemTask ();
X	EndScreenWait();
X
X	return;
X}
X
Xstatic void DoAppMenu(theItem)
Xlong theItem;
X
X{
X	long i;
X#ifndef USE_PUSH
X	char save_chars[80*25], save_attrs[80*25];
X	long save_cursor_h, save_cursor_v;
X	Rect screen;
X#endif
X
X	switch (theItem) {
X
X		case 1:
X			/* X out every character cell on the screen, with immediate updates. */
X#ifdef USE_PUSH
X			if (PushScreen() == scrnErrOk) {
X				for (i = 0; i < 25*79; i++) {
X					SetScreenChar('x', i % 79, i % 25);
X					UpdateScreen();
X				}
X				Wait(10);
X				PopScreen();
X			}
X			break;
X#else
X			screen.left = screen.top = 0;
X			screen.right = 80;
X			screen.bottom = 25;
X			GetScreenImage(save_chars, save_attrs, 80, &screen, 0, 0);
X			GetScreenCursor(&save_cursor_h, &save_cursor_v);
X			for (i = 0; i < 25*79; i++) {
X				SetScreenChar('x', i % 79, i % 25);
X				UpdateScreen();
X			}
X			Wait(10);
X			SetScreenImage(save_chars, save_attrs, 80, &screen, 0, 0);
X			SetScreenCursor(save_cursor_h, save_cursor_v);
X			break;
X#endif
X
X		case 2:
X			/* Test the alert package. */
X			DoScreenALRT(1024, akNote, fixHalf, fixHalf);
X			break;
X
X	}
X
X	return;
X}
X
X/*	This routine gets called when the user selects quit from the file
X	menu.  It was installed with a call to SetScreenQuitProc(). */
X
Xstatic void Quit()
X
X{
X	if (YesOrNo("Are you certain that you want to quit the test?")) {
X		done = true;
X	}
X
X	return;
X}
X
X/*	All this routine does is to put some characters in the screen buffer. */
X
Xstatic void RunSomeTests()
X
X{
X	long i;
X	Rect area;
X	char msg[80];
X
X	/* Fill the whole screen with blanks. */
X	area.left = 0;
X	area.top = 0;
X	area.right = 80;
X	area.bottom = 25;
X	FillScreen(' ', MakeAttr(attrColorBlack, attrColorWhite), &area);
X
X	/* Put up a humorous message. */
X	SetScreenCursor(0, 0);
X	WriteScreenString("Hello, world --");
X	SetScreenCursor(10, 2);
X	WriteScreenStringAttr("This is a test",
X			      MakeAttr(attrColorRed,
X				       attrColorWhite) | attrUnderlined);
X	WriteScreenString(" of the Screen Manager.");
X	SetScreenCursor(10, 3);
X	WriteScreenString("This is only a ");
X	WriteScreenStringAttr("test",
X			      MakeAttr(attrColorWhite,
X				       attrColorBlack) | attrItalicized);
X	WriteScreenString(".  If this had been");
X	SetScreenCursor(10, 4);
X	WriteScreenString("an actual run, the program would bomb.");
X
X	/* Show all the screen colors on a black background. */
X	SetScreenCursor(0, 10);
X	for (i = 0; i < 8; i++)
X		WriteScreenCharAttr('a'+i, MakeAttr(i, attrColorBlack));
X
X	/* Fill a subsection of the screen with white asterisks on a red
X	   background. */
X	area.left = 11;
X	area.top = 11;
X	area.right = 16;
X	area.bottom = 16;
X	FillScreen('*', MakeAttr(attrColorWhite, attrColorRed), &area);
X
X	/* Show the pixel bounds of the entire display screen, minus the
X	   menu bar. */
X	GetScreenBounds(&area);
X	sprintf(msg, "Bounds: %d %d %d %d", area.top, area.left,
X		area.bottom, area.right);
X	SetScreenString(msg, 0, 18);
X
X	return;
X}
X
X/*	The big picture. */
X
Xint main()
X
X{
X	char keycode, modifiers, ascii;
X	int h, v;
X	long i;
X	Rect scrollRect1, scrollRect2;
X	char coords[6], hex[6];
X
X	/* This flag gets set in the quit proc. */
X	done = false;
X
X	/* Put the screen up on the monitor. */
X	InitScreenMgr(80, 25, "This is a Test",
X		"ScrnMgrConfig", '????', '????',
X		NULL, DoAppMenu,
X		multiColor);
X
X	/* Point to the quit proc.  Indicate that the quit proc always returns. */
X	SetScreenQuitProc(Quit, true);
X
X	/* Configure the screen cursor.  It does not flash. */
X	DefineScreenCursor(attrColorBlack, 2, 0);
X	ShowScreenCursor();
X
X	/* Put some characters in the buffer. */
X	RunSomeTests();
X
X	/* Layout some rects for keyboard input. */
X	scrollRect1.left = 60;
X	scrollRect1.top = 0;
X	scrollRect1.right = 70;
X	scrollRect1.bottom = 1;
X
X	scrollRect2.left = 60;
X	scrollRect2.top = 0;
X	scrollRect2.right = 70;
X	scrollRect2.bottom = 10;
X
X	/* Detect mouse clicks in the specified area. */
X	ClipScreenMouse(&scrollRect2);
X	EnableScreenMouse(true);
X
X	i = 0;
X
X	while (!done) {
X
X		/* Very important.  Allows screen manager to update the
X		   screen if any characters have been stuffed in the buffer,
X		   to pull any keystrokes off the event queue, etc. */
X		IdleScreenMgr();
X
X		/* Look for keyboard or mouse input. */
X		if (GetScreenKeys(&keycode, &modifiers, &ascii, &h, &v)) {
X
X			/* Is is not a mouse click?  Then it is a keystroke. */
X			if (!(modifiers & maskModMouse)) {
X				/* Scroll top line one char to the left.
X				   Filling in with white on green. */
X				ScrollScreen(-1, 0, &scrollRect1,
X					     MakeAttr(attrColorWhite,
X						      attrColorGreen));
X				/* Put the character on the screen to the top right. */
X				SetScreenChar(ascii, 69, 0);
X				/* If top line has been filled, scroll lines down. */
X				if (!(++i % 10)) {
X					ScrollScreen(0, 1, &scrollRect2,
X						     MakeAttr(attrColorWhite,
X							      attrColorGreen));
X					UpdateScreen();
X				}
X				/* Show the keycodes entered. */
X				sprintf(hex, "%2.2X %2.2X",
X					(int)(unsigned char) ascii,
X					(int)(unsigned char) keycode);
X				SetScreenString(hex, 40, 24);
X				/* If the char 'D' has been typed, go into a wait.  Notice that the D does
X				not appear on the screen until the wait has ended, at the IdleScreenMgr
X				call. */
X				if (ascii == 'D') Wait(30);
X			}
X
X			/* Otherwise, it is a mouse click.  Show the coordinates. */
X			else {
X				sprintf(coords, "%2.2d %2.2d", h, v);
X				SetScreenString(coords, 0, 24);
X			}
X
X		}
X	}
X
X	/* Clean up. */
X	CloseScreenMgr();
X
X	return(0);
X}
END_OF_FILE
if test 6460 -ne `wc -c <'mac/scrnmgr/ScrnTest.c'`; then
    echo shar: \"'mac/scrnmgr/ScrnTest.c'\" unpacked with wrong size!
fi
# end of 'mac/scrnmgr/ScrnTest.c'
fi
if test -f 'source/signals.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/signals.c'\"
else
echo shar: Extracting \"'source/signals.c'\" \(7840 characters\)
sed "s/^X//" >'source/signals.c' <<'END_OF_FILE'
X/* source/signals.c: signal handlers
X
X   Copyright (c) 1989-92 James E. Wilson, Christopher J. Stuart
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X/* This signal package was brought to you by		-JEW-  */
X/* Completely rewritten by				-CJS- */
X
X/* To find out what system we're on.  */
X
X#include <stdio.h>
X
X#include "config.h"
X#include "constant.h"
X
X/* Signals have no significance on the Mac */
X
X#ifdef MAC
X
Xvoid nosignals()
X{
X}
X
Xvoid signals()
X{
X}
X
Xvoid init_signals()
X{
X}
X
X#else /* a non-Mac system */
X
X#ifdef ATARIST_MWC
X/* need these for atari st, but for unix, must include signals.h first,
X   or else suspend won't be properly declared */
X#include "types.h"
X#include "externs.h"
X#endif
X
X/* skip most of the file on an ATARI ST */
X/* commented away most single handling for Atari ST TC too, as this
X   doesn't work as it should.  */
X#if !defined(ATARIST_MWC) && !defined(ATARIST_TC)
X
X#if defined(SYS_V) && defined(lint)
X/* for AIX, prevent hundreds of unnecessary lint errors, define before
X   signal.h is included */
X#define _h_IEEETRAP
Xtypedef struct { int stuff; } fpvmach;
X#endif
X
X/* must include before externs.h, because that uses SIGTSTP */
X#include <signal.h>
X
X#include "types.h"
X#include "externs.h"
X
X#ifndef USG
X/* only needed for Berkeley UNIX */
X#include <sys/types.h>
X#include <sys/param.h>
X#endif
X
X#ifdef USG
X#ifndef ATARIST_MWC
X#include <string.h>
X#endif
X#else
X#include <strings.h>
X#endif
X
X#ifndef VMS
X#ifdef USG
Xvoid exit();
X#ifdef __TURBOC__
Xvoid sleep();
X#else
Xunsigned sleep();
X#endif
X#endif
X#endif
X
Xstatic int error_sig = -1;
Xstatic int signal_count = 0;
X
X/*ARGSUSED*/
X#ifndef USG
Xstatic int signal_handler(sig, code, scp)
Xint sig, code;
Xstruct sigcontext *scp;
X{
X  int smask;
X
X  smask = sigsetmask(0) | (1 << sig);
X#else
X#if defined(__TURBOC__) || defined(AMIGA)
Xstatic void signal_handler(sig)
X#else
Xstatic int signal_handler(sig)
X#endif
Xint sig;
X{
X#endif
X
X  if(error_sig >= 0)	/* Ignore all second signals. */
X    {
X      if(++signal_count > 10)	/* Be safe. We will die if persistent enough. */
X	(void) signal(sig, SIG_DFL);
X      return;
X    }
X  error_sig = sig;
X
X  /* Allow player to think twice. Wizard may force a core dump. */
X  if (sig == SIGINT
X#if !defined(MSDOS) && !defined(AMIGA) && !defined(ATARIST_TC)
X      || sig == SIGQUIT
X#endif
X      )
X    {
X      if (death)
X	(void) signal(sig, SIG_IGN);		/* Can't quit after death. */
X      else if (!character_saved && character_generated)
X	{
X	  if (!get_check("Really commit *Suicide*?"))
X	    {
X	      if (turn > 0)
X		disturb(1, 0);
X	      erase_line(0, 0);
X	      put_qio();
X	      error_sig = -1;
X#ifdef USG
X	      (void) signal(sig, signal_handler);/* Have to restore handler. */
X#else
X	      (void) sigsetmask(smask);
X#endif
X	      /* in case control-c typed during msg_print */
X	      if (wait_for_more)
X		put_buffer(" -more-", MSG_LINE, 0);
X	      put_qio();
X	      return;		/* OK. We don't quit. */
X	    }
X	  (void) strcpy(died_from, "Interrupting");
X	}
X      else
X	(void) strcpy(died_from, "Abortion");
X      prt("Interrupt!", 0, 0);
X      death = TRUE;
X      exit_game();
X    }
X  /* Die. */
X  prt(
X"OH NO!!!!!!  A gruesome software bug LEAPS out at you. There is NO defense!",
X      23, 0);
X  if (!death && !character_saved && character_generated)
X    {
X      panic_save = 1;
X      prt("Your guardian angel is trying to save you.", 0, 0);
X      (void) sprintf(died_from,"(panic save %d)",sig);
X      if (!save_char())
X	{
X	  (void) strcpy(died_from, "software bug");
X	  death = TRUE;
X	  turn = -1;
X	}
X    }
X  else
X    {
X      death = TRUE;
X      (void) _save_char(savefile);	/* Quietly save the memory anyway. */
X    }
X  restore_term();
X#if !defined(MSDOS) && !defined(AMIGA) && !defined(ATARIST_TC)
X  /* always generate a core dump */
X  (void) signal(sig, SIG_DFL);
X  (void) kill(getpid(), sig);
X  (void) sleep(5);
X#endif
X  exit(1);
X}
X
X#endif /* ATARIST_MWC, ATARIST_TC */
X
X#ifndef USG
Xstatic int mask;
X#endif
X
Xvoid nosignals()
X{
X#if !defined(ATARIST_MWC) && !defined(ATARIST_TC)
X#ifdef SIGTSTP
X#if defined(atarist) && defined(__GNUC__)
X  (void) signal(SIGTSTP, (__Sigfunc)SIG_IGN);
X#else
X  (void) signal(SIGTSTP, SIG_IGN);
X#endif
X#ifndef USG
X  mask = sigsetmask(0);
X#endif
X#endif
X  if (error_sig < 0)
X    error_sig = 0;
X#endif
X}
X
Xvoid signals()
X{
X#if !defined(ATARIST_MWC) && !defined(ATARIST_TC)
X#ifdef SIGTSTP
X#if defined(atarist) && defined(__GNUC__)
X  (void) signal(SIGTSTP, (__Sigfunc)suspend);
X#else
X  (void) signal(SIGTSTP, suspend);
X#endif
X#ifndef USG
X  (void) sigsetmask(mask);
X#endif
X#endif
X  if (error_sig == 0)
X    error_sig = -1;
X#endif
X}
X
X
Xvoid init_signals()
X{
X#if !defined(ATARIST_MWC) && !defined(ATARIST_TC)
X  /* No signals for Atari ST compiled with MWC or TC.  */
X  (void) signal(SIGINT, signal_handler);
X
X#if defined(atarist) && defined(__GNUC__)
X  /* Atari ST compiled with GNUC has most signals, but we need a cast
X     in every call to signal.  */
X  (void) signal(SIGINT, (__Sigfunc)signal_handler);
X  (void) signal(SIGQUIT, (__Sigfunc)signal_handler);
X  (void) signal(SIGTSTP,(__Sigfunc)SIG_IGN);
X  (void) signal(SIGILL, (__Sigfunc)signal_handler);
X  (void) signal(SIGHUP, (__Sigfunc)SIG_IGN);
X  (void) signal(SIGTRAP,(__Sigfunc)signal_handler);
X  (void) signal(SIGIOT, (__Sigfunc)signal_handler);
X  (void) signal(SIGEMT, (__Sigfunc)signal_handler);
X  (void) signal(SIGKILL, (__Sigfunc)signal_handler);
X  (void) signal(SIGBUS, (__Sigfunc)signal_handler);
X  (void) signal(SIGSEGV, (__Sigfunc)signal_handler);
X  (void) signal(SIGSYS, (__Sigfunc)signal_handler);
X  (void) signal(SIGTERM,(__Sigfunc)signal_handler);
X  (void) signal(SIGPIPE, (__Sigfunc)signal_handler);
X
X#else
X  /* Everybody except the atari st.  */
X  (void) signal(SIGINT, signal_handler);
X  (void) signal(SIGFPE, signal_handler);
X
X#if defined(MSDOS)
X  /* many fewer signals under MSDOS */
X#else
X
X#ifdef AMIGA
X/*  (void) signal(SIGINT, signal_handler); */
X  (void) signal(SIGTERM, signal_handler);
X  (void) signal(SIGABRT, signal_handler);
X/*  (void) signal(SIGFPE, signal_handler); */
X  (void) signal(SIGILL, signal_handler);
X  (void) signal(SIGSEGV, signal_handler);
X
X#else
X
X  /* Everybody except Atari, MSDOS, and Amiga.  */
X  /* Ignore HANGUP, and let the EOF code take care of this case. */
X  (void) signal(SIGHUP, SIG_IGN);
X  (void) signal(SIGQUIT, signal_handler);
X  (void) signal(SIGILL, signal_handler);
X  (void) signal(SIGTRAP, signal_handler);
X  (void) signal(SIGIOT, signal_handler);
X#ifdef SIGEMT  /* in BSD systems */
X  (void) signal(SIGEMT, signal_handler);
X#endif
X#ifdef SIGDANGER /* in SYSV systems */
X  (void) signal(SIGDANGER, signal_handler);
X#endif
X  (void) signal(SIGKILL, signal_handler);
X  (void) signal(SIGBUS, signal_handler);
X  (void) signal(SIGSEGV, signal_handler);
X  (void) signal(SIGSYS, signal_handler);
X  (void) signal(SIGTERM, signal_handler);
X  (void) signal(SIGPIPE, signal_handler);
X#ifdef SIGXCPU	/* BSD */
X  (void) signal(SIGXCPU, signal_handler);
X#endif
X#ifdef SIGPWR /* SYSV */
X  (void) signal(SIGPWR, signal_handler);
X#endif
X#endif
X#endif
X#endif
X#endif
X}
X
Xvoid ignore_signals()
X{
X#if !defined(ATARIST_MWC)
X  (void) signal(SIGINT, SIG_IGN);
X#ifdef SIGQUIT
X  (void) signal(SIGQUIT, SIG_IGN);
X#endif
X#endif
X}
X
Xvoid default_signals()
X{
X#if !defined(ATARIST_MWC)
X  (void) signal(SIGINT, SIG_DFL);
X#ifdef SIGQUIT
X  (void) signal(SIGQUIT, SIG_DFL);
X#endif
X#endif
X}
X
Xvoid restore_signals()
X{
X#if !defined(ATARIST_MWC)
X#if defined(atarist) && defined(__GNUC__)
X  (void) signal(SIGINT, (__Sigfunc)signal_handler);
X#else
X  (void) signal(SIGINT, signal_handler);
X#endif
X#ifdef SIGQUIT
X#if defined(atarist) && defined(__GNUC__)
X  (void) signal(SIGQUIT, (__Sigfunc)signal_handler);
X#else
X  (void) signal(SIGQUIT, signal_handler);
X#endif
X#endif
X#endif
X}
X
X#endif /* big Mac conditional */
END_OF_FILE
if test 7840 -ne `wc -c <'source/signals.c'`; then
    echo shar: \"'source/signals.c'\" unpacked with wrong size!
fi
# end of 'source/signals.c'
fi
echo shar: End of archive 34 \(of 39\).
cp /dev/null ark34isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
