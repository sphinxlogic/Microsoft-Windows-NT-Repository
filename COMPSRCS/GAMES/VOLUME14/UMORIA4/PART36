Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i068:  umoria4 - single player dungeon simulation (ver. 5.5), Part36/39
Message-ID: <3432@master.CNA.TEK.COM>
Date: 22 Aug 92 22:15:42 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2430
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 68
Archive-name: umoria4/Part36
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 36 (of 39)."
# Contents:  mac/macconf.c mac/scrnmgr/ScrnMgr.ro
#   mac/scrnmgr/ScrnTest.r source/eat.c source/magic.c source/sets.c
#   source/wands.c util/mcheck.inf util/scores/print.c vms/Makefile
#   vms/getch.c
# Wrapped by billr@saab on Thu Aug 20 09:11:36 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'mac/macconf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/macconf.c'\"
else
echo shar: Extracting \"'mac/macconf.c'\" \(4470 characters\)
sed "s/^X//" >'mac/macconf.c' <<'END_OF_FILE'
X/* mac/macconf.c: configuration routines
X
X   Copyright (c) 1989-1991 Curtis McCauley, James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#ifndef THINK_C
X#include <Types.h>
X#include <Quickdraw.h>
X#include <Controls.h>
X#include <Dialogs.h>
X
X#include <ScrnMgr.h>
X#else
X#include "ScrnMgr.h"
X#endif
X
X#include "constant.h"
X#include "types.h"
X
X#define rogueFlag				'-r\0\0'
X#define originalFlag			'-o\0\0'
X
X#define cmdsetDlgID				256
X#define cmdsetRogue				3
X#define cmdsetOriginal			4
X#define cmdsetGrpRect			6
X#define cmdsetDfltBrdr			8
X
X#define teDlgID					257
X#define teFCFirst				3
X#define teFCLast				5
X#define teFCCount				(teFCLast - teFCFirst + 1)
X#define teFCOther				6
X#define teGrpRect				8
X#define teDfltBrdr				10
X
X#ifdef THINK_C
X/* Cover up error in THINK C library.  */
X#define ok	OK
X#define cancel	Cancel
X#endif
X
Xint32 GetCommandSet(hndl)
Xint32 **hndl;
X
X{
X	DialogPtr theDialog;
X	short theItem;
X	Handle theHandle;
X	short itemHit;
X	short itsType;
X	Handle itsHandle;
X	Rect itsRect;
X	int32 h, v;
X
X	theDialog = GetNewDialog(cmdsetDlgID, nil, (WindowPtr) -1);
X
X	CenterScreenDLOG(cmdsetDlgID, fixHalf, fixThird, &h, &v);
X	MoveWindow((WindowPtr) theDialog, (short) h, (short) v, false);
X
X	GetDItem(theDialog, ok, &itsType, &itsHandle, &itsRect);
X	InsetRect(&itsRect, -4, -4);
X
X	SetDItem(theDialog, cmdsetDfltBrdr, userItem,
X		 (Handle) DrawDefaultBorder, &itsRect);
X
X	GetDItem(theDialog, cmdsetGrpRect, &itsType, &itsHandle, &itsRect);
X	SetDItem(theDialog, cmdsetGrpRect, itsType, (Handle) DrawGroupRect,
X		 &itsRect);
X
X	theItem = (**hndl == originalFlag) ? cmdsetOriginal : cmdsetRogue;
X	GetDItem(theDialog, theItem, &itsType, &theHandle, &itsRect);
X	SetCtlValue((ControlHandle) theHandle, true);
X
X	ShowWindow((WindowPtr) theDialog);
X
X	do {
X		ModalDialog(nil, &itemHit);
X		if ((itemHit != theItem)
X		    && ((itemHit == cmdsetOriginal) || (itemHit == cmdsetRogue))) {
X			SetCtlValue((ControlHandle) theHandle, false);
X			theItem = itemHit;
X			GetDItem(theDialog, theItem, &itsType, &theHandle, &itsRect);
X			SetCtlValue((ControlHandle) theHandle, true);
X		}
X	} while ( (itemHit != ok) && (itemHit != cancel) );
X
X	if (itemHit == ok)
X		**hndl = (theItem == cmdsetOriginal) ? originalFlag : rogueFlag;
X
X	DisposDialog(theDialog);
X
X	return(itemHit == ok);
X}
X
Xint32 GetTextEditor(hndl)
Xint32 **hndl;
X
X{
X	DialogPtr theDialog;
X	short theItem;
X	Handle theHandle, fcHandle;
X	short itemHit;
X	short itsType;
X	Handle itsHandle;
X	Rect itsRect;
X	int32 h, v;
X	char *p, *q;
X	Str255 fc;
X	static int32 editors[teFCCount-1] = { 'MACA', 'MSWD' };
X
X	theDialog = GetNewDialog(teDlgID, nil, (WindowPtr) -1);
X
X	CenterScreenDLOG(teDlgID, fixHalf, fixThird, &h, &v);
X	MoveWindow((WindowPtr) theDialog, (short) h, (short) v, false);
X
X	GetDItem(theDialog, ok, &itsType, &itsHandle, &itsRect);
X	InsetRect(&itsRect, -4, -4);
X
X	SetDItem(theDialog, teDfltBrdr, userItem, (Handle) DrawDefaultBorder,
X		 &itsRect);
X
X	GetDItem(theDialog, teGrpRect, &itsType, &itsHandle, &itsRect);
X	SetDItem(theDialog, teGrpRect, itsType, (Handle) DrawGroupRect, &itsRect);
X
X	GetDItem(theDialog, teFCOther, &itsType, &fcHandle, &itsRect);
X
X	for (theItem = 0; theItem < teFCCount-1; theItem++)
X		if (**hndl == editors[theItem])
X			break;
X
X	theItem += teFCFirst;
X	GetDItem(theDialog, theItem, &itsType, &theHandle, &itsRect);
X	SetCtlValue((ControlHandle) theHandle, true);
X
X	if (theItem == teFCLast) {
X		p = (char *)fc;
X		q = (char *) *hndl;
X		*p++ = 4;
X		*p++ = *q++;
X		*p++ = *q++;
X		*p++ = *q++;
X		*p = *q;
X		SetIText(fcHandle, fc);
X	}
X
X	ShowWindow((WindowPtr) theDialog);
X
X	do {
X
X		do {
X			ModalDialog(nil, &itemHit);
X			if ( (itemHit != theItem) && (itemHit >= teFCFirst)
X			    && (itemHit <= teFCLast) ) {
X				SetCtlValue((ControlHandle) theHandle, false);
X				theItem = itemHit;
X				GetDItem(theDialog, theItem, &itsType, &theHandle, &itsRect);
X				SetCtlValue((ControlHandle) theHandle, true);
X			}
X		} while ( (itemHit != ok) && (itemHit != cancel) );
X
X		if (itemHit == ok) {
X			if (theItem != teFCLast)
X				**hndl = editors[theItem - teFCFirst];
X			else {
X				GetIText(fcHandle, fc);
X				p = (char *) *hndl;
X				q = (char *)fc + 1;
X				*p++ = (fc[0] > 0) ? *q++ : ' ';
X				*p++ = (fc[0] > 1) ? *q++ : ' ';
X				*p++ = (fc[0] > 2) ? *q++ : ' ';
X				*p = (fc[0] > 3) ? *q : ' ';
X			}
X		}
X
X	} while (!ok);
X
X	DisposDialog(theDialog);
X
X	return(itemHit == ok);
X}
END_OF_FILE
if test 4470 -ne `wc -c <'mac/macconf.c'`; then
    echo shar: \"'mac/macconf.c'\" unpacked with wrong size!
fi
# end of 'mac/macconf.c'
fi
if test -f 'mac/scrnmgr/ScrnMgr.ro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/scrnmgr/ScrnMgr.ro'\"
else
echo shar: Extracting \"'mac/scrnmgr/ScrnMgr.ro'\" \(4878 characters\)
sed "s/^X//" >'mac/scrnmgr/ScrnMgr.ro' <<'END_OF_FILE'
XScrnMgr.rsrc
X????????
X
X*/*	Copyright (C) Curtis McCauley, 1989.  All rights reserved.
X*
X*	You may copy this subroutine package freely, modify it as you desire,
X*	and distribute it at will, as long as the copyright notice in the source
X*	material is not disturbed, excepting that no one may use this package or
X*	any part of it for commercial purposes of any kind without the express
X*	written consent of its author. */
X*
X* TC 4.0 Version by Benjamin Schreiber, 1991
X*
X*#include "Types.r"
X*
X*type 'INFO'	{
X*	rect;
X*	integer;
X*	longint white, black, red, green, blue, cyan, magenta, yellow;
X*	longint white, black, red, green, blue, cyan, magenta, yellow;
X*};
X*
X*type 'acur' {
X*	integer = $$Countof(cursors);
X*	integer = 0;
X*	array cursors {
X*		integer;
X*		integer = 0;
X*	};
X*};
X
XTYPE acur = GNRL
XRotating Watch, 128
X.I
X8
X0
X256 0  ;; union { struct { short id, fill; }; Handle cursHandle };
X257 0
X258 0
X259 0
X260 0
X261 0
X262 0
X263 0
X
X
XTYPE CURS = GNRL
X	,256
X.H
X 3F00 3F00 3F00 3F00 4080 8440 8440 8460
X 9C60 8040 8040 4080 3F00 3F00 3F00 3F00
X 3F00 3F00 3F00 3F00 7F80 FFC0 FFC0 FFC0
X FFC0 FFC0 FFC0 7F80 3F00 3F00 3F00 3F00
X.I
X8 8
X
X
XTYPE CURS = GNRL
X	,257
X.H
X 3F00 3F00 3F00 3F00 4080 8040 8140 8260
X 9C60 8040 8040 4080 3F00 3F00 3F00 3F00
X 3F00 3F00 3F00 3F00 7F80 FFC0 FFC0 FFC0
X FFC0 FFC0 FFC0 7F80 3F00 3F00 3F00 3F00
X.I
X8 8
X
X
XTYPE CURS = GNRL
X	,258
X.H
X 3F00 3F00 3F00 3F00 4080 8040 8040 8060
X 9F60 8040 8040 4080 3F00 3F00 3F00 3F00
X 3F00 3F00 3F00 3F00 7F80 FFC0 FFC0 FFC0
X FFC0 FFC0 FFC0 7F80 3F00 3F00 3F00 3F00
X.I
X8 8
X
X
XTYPE CURS = GNRL
X	,259
X.H
X 3F00 3F00 3F00 3F00 4080 8040 8040 8060
X 9C60 8240 8040 4080 3F00 3F00 3F00 3F00
X 3F00 3F00 3F00 3F00 7F80 FFC0 FFC0 FFC0
X FFC0 FFC0 FFC0 7F80 3F00 3F00 3F00 3F00
X.I
X8 8
X
X
XTYPE CURS = GNRL
X	,260
X.H
X 3F00 3F00 3F00 3F00 4080 8040 8040 8060
X 9C60 8440 8440 4080 3F00 3F00 3F00 3F00
X 3F00 3F00 3F00 3F00 7F80 FFC0 FFC0 FFC0
X FFC0 FFC0 FFC0 7F80 3F00 3F00 3F00 3F00
X.I
X8 8
X
X
XTYPE CURS = GNRL
X	,261
X.H
X 3F00 3F00 3F00 3F00 4080 8040 8040 8060
X 9C60 8840 9040 4080 3F00 3F00 3F00 3F00
X 3F00 3F00 3F00 3F00 7F80 FFC0 FFC0 FFC0
X FFC0 FFC0 FFC0 7F80 3F00 3F00 3F00 3F00
X.I
X8 8
X
X
XTYPE CURS = GNRL
X	,262
X.H
X 3F00 3F00 3F00 3F00 4080 8040 8040 8060
X BC60 8040 8040 4080 3F00 3F00 3F00 3F00
X 3F00 3F00 3F00 3F00 7F80 FFC0 FFC0 FFC0
X FFC0 FFC0 FFC0 7F80 3F00 3F00 3F00 3F00
X.I
X8 8
X
X
XTYPE CURS = GNRL
X	,263
X.H
X 3F00 3F00 3F00 3F00 4080 8040 9040 8860
X 9C60 8040 8040 4080 3F00 3F00 3F00 3F00
X 3F00 3F00 3F00 3F00 7F80 FFC0 FFC0 FFC0
X FFC0 FFC0 FFC0 7F80 3F00 3F00 3F00 3F00
X.I
X8 8
X
X
XTYPE STR
XAbout Title, 128 (32)
XAbout ScrnMgr\C9
X
XTYPE STR
XFont Name, 129 (32)
XMonaco
X
XTYPE DLOG
X"About", 128
X"About ScrnMgr"		;; Huh?
X44 26 162 314
XInvisible NoGoAway
X0					;; dBoxProc (I think)
X0					;; Refcon
X128					;; DITL ID
X
XTYPE DLOG
XColors, 129
XColors
X56 32 228 364
XInvisible NoGoAway
X0
X0
X129
X
XTYPE DLOG
XYes or No, 130 (32)
XYes or No
X40 40 142 300
XInvisible NoGoAway
X0
X0
X130
X
XTYPE DITL
XAbout, 128 (32)
X4
X
Xbutton
X73 103 97 191
XOK
X
XuserItem disabled
X80 158 89 167
X
XstaticText
X16 8 32 273
XScrnMgr: Version 1.0.1 b1 4 January 1991
X
XstaticText
X40 8 56 273
XCurtis McCauley, Benjamin Schreiber
X
X
XTYPE DITL
XColors, 129 (32)
X23
X
Xbutton
X40 256 60 316
XOK
X
Xbutton
X88 256 108 316
XCancel
X
XradioButton
X32 32 48 112
XWhite
X
XradioButton
X48 32 64 112
XBlack
X
XradioButton
X64 32 80 112
XRed
X
XradioButton
X80 32 96 112
XGreed
X
XradioButton
X96 32 112 112
XBlue
X
XradioButton
X112 32 128 112
XCyan
X
XradioButton
X128 32 144 112
XMagenta
X
XradioButton
X144 32 160 112
XYellow
X
XradioButton
X32 152 48 232
XWhite
X
XradioButton
X48 152 64 232
XBlack
X
XradioButton
X64 152 80 232
XRed
X
XradioButton
X80 152 96 232
XGreen
X
XradioButton
X96 152 112 232
XBlue
X
XradioButton
X112 152 128 232
XCyan
X
XradioButton
X128 152 144 232
XMagenta
X
XradioButton
X144 152 160 232
XYellow
X
XuserItem disabled
X16 16 168 120
X
XuserItem disabled
X16 136 168 240
X
XstaticText disabled
X8 24 24 104
XForeground
X
XstaticText disabled
X8 144 24 224
XBackground
X
XuserItem disabled
X48 296 56 304
X
X
XTYPE DITL
XYes or No, 130 (32)
X5
X
Xbutton
X16 184 36 244
XYes
X
Xbutton
X64 184 84 244
XNo
X
XuserItem disabled
X19 227 33 241
X
XstaticText disabled
X9 48 89 168
XAre you sure?
X
XiconItem disabled
X8 8 40 40
X0
X
X
XTYPE MENU
XApple, 128
X\14
XAbout ScrnMgr\C9
X(-
X
X
XTYPE MENU
XFile, 129
XFile
XOpen/O
XClose/W
X(-
XQuit/Q
X
X
XTYPE MENU
XEdit, 130
XEdit
X(Undo/Z
X(-
X(Cut/X
X(Copy/C
X(Paste/V
X(Clear
X
X
XTYPE MENU
XFile (No Keys), 229
XFile
XOpen
XClose
X(-
XQuit
X
X
XTYPE MENU
XEdit (No Keys), 230
XEdit
X(Undo
X(-
X(Cut
X(Copy
X(Paste
X(Clear
X
X
XTYPE MENU
XScreen, 131
XScreen
XColors\C9
X(-
X
X
XTYPE MENU
XFontSize, 132
XFontSize
X
X
XTYPE MBAR = GNRL
XMain Menu, 128
X.I
X3    ;; 3 items
X128  ;; apple
X129  ;; file
X130  ;; edit
X
X
XTYPE MBAR = GNRL
XMain Menu (No Keys), 228
X.I
X3
X128
X229
X230
X
X
XTYPE INFO = GNRL
XScreen Info, 1
X.I
X46 4 333 507    ;; Size of window - this will give 24x80 in monaco 9 pt
X9               ;; Point size to use (font in 'STR ' 129)
X.L
X0 				;; Black (Foreground)
X1				;; White (Background)
X
END_OF_FILE
if test 4878 -ne `wc -c <'mac/scrnmgr/ScrnMgr.ro'`; then
    echo shar: \"'mac/scrnmgr/ScrnMgr.ro'\" unpacked with wrong size!
fi
# end of 'mac/scrnmgr/ScrnMgr.ro'
fi
if test -f 'mac/scrnmgr/ScrnTest.r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/scrnmgr/ScrnTest.r'\"
else
echo shar: Extracting \"'mac/scrnmgr/ScrnTest.r'\" \(1871 characters\)
sed "s/^X//" >'mac/scrnmgr/ScrnTest.r' <<'END_OF_FILE'
X/* mac/scrnmgr/ScrnTest.r: resources for scrnmgr test driver
X
X   Copyright (C) 1989-1991 Curtis McCauley, James E. Wilson
X
X   You may copy this subroutine package freely, modify it as you desire,
X   and distribute it at will, as long as the copyright notice in the source
X   material is not disturbed, excepting that no one may use this package or
X   any part of it for commercial purposes of any kind without the express
X   written consent of its author. */
X
X#include "Types.r"
X
Xinclude "ScrnMgr.rsrc";
X
Xresource 'STR ' (128, "About Title", purgeable) {
X	"About ScrnTest\311"
X};
X
Xresource 'DITL' (1024, "Dummy Alert", purgeable) {
X	{	/* array DITLarray: 2 elements */
X		/* [1] */
X		{88, 224, 108, 284},
X		Button {
X			enabled,
X			"Ok"
X		},
X		/* [2] */
X		{8, 64, 72, 288},
X		StaticText {
X			disabled,
X			"This is a dummy alert."
X		}
X	}
X};
X
Xresource 'ALRT' (1024, "Dummy Alert", purgeable) {
X	{40, 42, 158, 352},
X	1024,
X	{	/* array: 4 elements */
X		/* [1] */
X		OK, visible, sound1,
X		/* [2] */
X		OK, visible, sound1,
X		/* [3] */
X		OK, visible, sound1,
X		/* [4] */
X		OK, visible, sound1
X	}
X};
X
Xresource 'MENU' (133, "ScrnTest") {
X	133,
X	textMenuProc,
X	allEnabled,
X	enabled,
X	"ScrnTest",
X	{	/* array: 2 elements */
X		/* [1] */
X		"X Out", noIcon, "", "", plain,
X		/* [2] */
X		"Dummy Alert", noIcon, "A", "", plain
X	}
X};
X
Xresource 'MENU' (233, "ScrnTest (No Keys)") {
X	233,
X	textMenuProc,
X	allEnabled,
X	enabled,
X	"ScrnTest",
X	{	/* array: 2 elements */
X		/* [1] */
X		"X Out", noIcon, "", "", plain,
X		/* [2] */
X		"Dummy Alert", noIcon, "", "", plain
X	}
X};
X
Xresource 'SIZE' (-1) {
X	dontSaveScreen,
X	acceptSuspendResumeEvents,
X	enableOptionSwitch,
X	canBackground,
X	multiFinderAware,
X	backgroundAndForeground,
X	dontGetFrontClicks,
X	ignoreChildDiedEvents,
X	not32BitCompatible,
X	reserved,
X	reserved,
X	reserved,
X	reserved,
X	reserved,
X	reserved,
X	reserved,
X	128 * 1024,
X	128 * 1024
X};
END_OF_FILE
if test 1871 -ne `wc -c <'mac/scrnmgr/ScrnTest.r'`; then
    echo shar: \"'mac/scrnmgr/ScrnTest.r'\" unpacked with wrong size!
fi
# end of 'mac/scrnmgr/ScrnTest.r'
fi
if test -f 'source/eat.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/eat.c'\"
else
echo shar: Extracting \"'source/eat.c'\" \(5068 characters\)
sed "s/^X//" >'source/eat.c' <<'END_OF_FILE'
X/* source/eat.c: food code
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#ifdef USG
X#include <string.h>
X#else
X#include <strings.h>
X#endif
X
X/* Eat some food.					-RAK-	*/
Xvoid eat()
X{
X  int32u i;
X  int j, k, item_val, ident;
X  register struct flags *f_ptr;
X  register struct misc *m_ptr;
X  register inven_type *i_ptr;
X#ifdef ATARIST_MWC
X  int32u holder;
X#endif
X
X  free_turn_flag = TRUE;
X  if (inven_ctr == 0)
X    msg_print("But you are not carrying anything.");
X  else if (!find_range(TV_FOOD, TV_NEVER, &j, &k))
X    msg_print("You are not carrying any food.");
X  else if (get_item(&item_val, "Eat what?", j, k, CNIL, CNIL))
X    {
X      i_ptr = &inventory[item_val];
X      free_turn_flag = FALSE;
X      i = i_ptr->flags;
X      ident = FALSE;
X      while (i != 0)
X	{
X	  j = bit_pos(&i) + 1;
X	  /* Foods					*/
X	  switch(j)
X	    {
X	    case 1:
X	      f_ptr = &py.flags;
X	      f_ptr->poisoned += randint(10) + i_ptr->level;
X	      ident = TRUE;
X	      break;
X	    case 2:
X	      f_ptr = &py.flags;
X	      f_ptr->blind += randint(250) + 10*i_ptr->level + 100;
X	      draw_cave();
X	      msg_print("A veil of darkness surrounds you.");
X	      ident = TRUE;
X	      break;
X	    case 3:
X	      f_ptr = &py.flags;
X	      f_ptr->afraid += randint(10) + i_ptr->level;
X	      msg_print("You feel terrified!");
X	      ident = TRUE;
X	      break;
X	    case 4:
X	      f_ptr = &py.flags;
X	      f_ptr->confused += randint(10) + i_ptr->level;
X	      msg_print("You feel drugged.");
X	      ident = TRUE;
X	      break;
X	    case 5:
X	      f_ptr = &py.flags;
X	      f_ptr->image += randint(200) + 25*i_ptr->level + 200;
X	      msg_print("You feel drugged.");
X	      ident = TRUE;
X	      break;
X	    case 6:
X	      ident = cure_poison();
X	      break;
X	    case 7:
X	      ident = cure_blindness();
X	      break;
X	    case 8:
X	      f_ptr = &py.flags;
X	      if (f_ptr->afraid > 1)
X		{
X		  f_ptr->afraid = 1;
X		  ident = TRUE;
X		}
X	      break;
X	    case 9:
X	      ident = cure_confusion();
X	      break;
X	    case 10:
X	      ident = TRUE;
X	      lose_str();
X	      break;
X	    case 11:
X	      ident = TRUE;
X	      lose_con();
X	      break;
X#if 0  /* 12 through 15 are not used */
X	    case 12:
X	      ident = TRUE;
X	      lose_int();
X	      break;
X	    case 13:
X	      ident = TRUE;
X	      lose_wis();
X	      break;
X	    case 14:
X	      ident = TRUE;
X	      lose_dex();
X	      break;
X	    case 15:
X	      ident = TRUE;
X	      lose_chr();
X	      break;
X#endif
X	    case 16:
X	      if (res_stat (A_STR))
X		{
X		  msg_print("You feel your strength returning.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 17:
X	      if (res_stat (A_CON))
X		{
X		  msg_print("You feel your health returning.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 18:
X	      if (res_stat (A_INT))
X		{
X		  msg_print("Your head spins a moment.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 19:
X	      if (res_stat (A_WIS))
X		{
X		  msg_print("You feel your wisdom returning.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 20:
X	      if (res_stat (A_DEX))
X		{
X		  msg_print("You feel more dextrous.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 21:
X	      if (res_stat (A_CHR))
X		{
X		  msg_print("Your skin stops itching.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 22:
X	      ident = hp_player(randint(6));
X	      break;
X	    case 23:
X	      ident = hp_player(randint(12));
X	      break;
X	    case 24:
X	      ident = hp_player(randint(18));
X	      break;
X#if 0  /* 25 is not used */
X	    case 25:
X	      ident = hp_player(damroll(3, 6));
X	      break;
X#endif
X	    case 26:
X	      ident = hp_player(damroll(3, 12));
X	      break;
X	    case 27:
X	      take_hit(randint(18), "poisonous food.");
X	      ident = TRUE;
X	      break;
X#if 0 /* 28 through 30 are not used */
X	    case 28:
X	      take_hit(randint(8), "poisonous food.");
X	      ident = TRUE;
X	      break;
X	    case 29:
X	      take_hit(damroll(2, 8), "poisonous food.");
X	      ident = TRUE;
X	      break;
X	    case 30:
X	      take_hit(damroll(3, 8), "poisonous food.");
X	      ident = TRUE;
X	      break;
X#endif
X	    default:
X	      msg_print("Internal error in eat()");
X	      break;
X	    }
X	  /* End of food actions.				*/
X	}
X      if (ident)
X	{
X	  if (!known1_p(i_ptr))
X	    {
X	      /* use identified it, gain experience */
X	      m_ptr = &py.misc;
X	      /* round half-way case up */
X	      m_ptr->exp += (i_ptr->level + (m_ptr->lev >> 1)) / m_ptr->lev;
X	      prt_experience();
X
X	      identify (&item_val);
X	      i_ptr = &inventory[item_val];
X	    }
X	}
X      else if (!known1_p(i_ptr))
X	sample (i_ptr);
X      add_food(i_ptr->p1);
X#ifdef ATARIST_MWC
X      py.flags.status &= ~(holder = PY_WEAK|PY_HUNGRY);
X#else
X      py.flags.status &= ~(PY_WEAK|PY_HUNGRY);
X#endif
X      prt_hunger();
X      desc_remain(item_val);
X      inven_destroy(item_val);
X    }
X}
END_OF_FILE
if test 5068 -ne `wc -c <'source/eat.c'`; then
    echo shar: \"'source/eat.c'\" unpacked with wrong size!
fi
# end of 'source/eat.c'
fi
if test -f 'source/magic.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/magic.c'\"
else
echo shar: Extracting \"'source/magic.c'\" \(5184 characters\)
sed "s/^X//" >'source/magic.c' <<'END_OF_FILE'
X/* source/magic.c: code for mage spells
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X
X/* Throw a magic spell					-RAK-	*/
Xvoid cast()
X{
X  int i, j, item_val, dir;
X  int choice, chance, result;
X  register struct flags *f_ptr;
X  register struct misc *p_ptr;
X  register inven_type *i_ptr;
X  register spell_type *m_ptr;
X#ifdef ATARIST_MWC
X  int32u holder;
X#endif
X
X  free_turn_flag = TRUE;
X  if (py.flags.blind > 0)
X    msg_print("You can't see to read your spell book!");
X  else if (no_light())
X    msg_print("You have no light to read by.");
X  else if (py.flags.confused > 0)
X    msg_print("You are too confused.");
X  else if (class[py.misc.pclass].spell != MAGE)
X    msg_print("You can't cast spells!");
X  else if (!find_range(TV_MAGIC_BOOK, TV_NEVER, &i, &j))
X    msg_print("But you are not carrying any spell-books!");
X  else if (get_item(&item_val, "Use which spell-book?", i, j, CNIL, CNIL))
X    {
X      result = cast_spell("Cast which spell?", item_val, &choice, &chance);
X      if (result < 0)
X	msg_print("You don't know any spells in that book.");
X      else if (result > 0)
X	{
X	  m_ptr = &magic_spell[py.misc.pclass-1][choice];
X	  free_turn_flag = FALSE;
X
X	  if (randint(100) < chance)
X	    msg_print("You failed to get the spell off!");
X	  else
X	    {
X	      /* Spells.  */
X	      switch(choice+1)
X		{
X		case 1:
X		  if (get_dir(CNIL, &dir))
X		    fire_bolt(GF_MAGIC_MISSILE, dir, char_row, char_col,
X			      damroll(2, 6), spell_names[0]);
X		  break;
X		case 2:
X		  (void) detect_monsters();
X		  break;
X		case 3:
X		  teleport(10);
X		  break;
X		case 4:
X		  (void) light_area(char_row, char_col);
X		  break;
X		case 5:
X		  (void) hp_player(damroll(4, 4));
X		  break;
X		case 6:
X		  (void) detect_sdoor();
X		  (void) detect_trap();
X		  break;
X		case 7:
X		  if (get_dir(CNIL, &dir))
X		    fire_ball(GF_POISON_GAS, dir, char_row, char_col, 12,
X			      spell_names[6]);
X		  break;
X		case 8:
X		  if (get_dir(CNIL, &dir))
X		    (void) confuse_monster(dir, char_row, char_col);
X		  break;
X		case 9:
X		  if (get_dir(CNIL, &dir))
X		    fire_bolt(GF_LIGHTNING, dir, char_row, char_col,
X			      damroll(4, 8), spell_names[8]);
X		  break;
X		case 10:
X		  (void) td_destroy();
X		  break;
X		case 11:
X		  if (get_dir(CNIL, &dir))
X		    (void) sleep_monster(dir, char_row, char_col);
X		  break;
X		case 12:
X		  (void) cure_poison();
X		  break;
X		case 13:
X		  teleport((int)(py.misc.lev*5));
X		  break;
X		case 14:
X		  for (i = 22; i < INVEN_ARRAY_SIZE; i++)
X		    {
X		      i_ptr = &inventory[i];
X#ifdef ATARIST_MWC
X		      i_ptr->flags = (i_ptr->flags & ~(holder = TR_CURSED));
X#else
X		      i_ptr->flags = (i_ptr->flags & ~TR_CURSED);
X#endif
X		    }
X		  break;
X		case 15:
X		  if (get_dir(CNIL, &dir))
X		    fire_bolt(GF_FROST, dir, char_row, char_col,
X			      damroll(6, 8), spell_names[14]);
X		  break;
X		case 16:
X		  if (get_dir(CNIL, &dir))
X		    (void) wall_to_mud(dir, char_row, char_col);
X		  break;
X		case 17:
X		  create_food();
X		  break;
X		case 18:
X		  (void) recharge(20);
X		  break;
X		case 19:
X		  (void) sleep_monsters1(char_row, char_col);
X		  break;
X		case 20:
X		  if (get_dir(CNIL, &dir))
X		    (void) poly_monster(dir, char_row, char_col);
X		  break;
X		case 21:
X		  (void) ident_spell();
X		  break;
X		case 22:
X		  (void) sleep_monsters2();
X		  break;
X		case 23:
X		  if (get_dir(CNIL, &dir))
X		    fire_bolt(GF_FIRE, dir, char_row, char_col,
X			      damroll(9, 8), spell_names[22]);
X		  break;
X		case 24:
X		  if (get_dir(CNIL, &dir))
X		    (void)speed_monster(dir, char_row, char_col, -1);
X		  break;
X		case 25:
X		  if (get_dir(CNIL, &dir))
X		    fire_ball(GF_FROST, dir, char_row, char_col, 48,
X			      spell_names[24]);
X		  break;
X		case 26:
X		  (void) recharge(60);
X		  break;
X		case 27:
X		  if (get_dir(CNIL, &dir))
X		    (void) teleport_monster(dir, char_row, char_col);
X		  break;
X		case 28:
X		  f_ptr = &py.flags;
X		  f_ptr->fast += randint(20) + py.misc.lev;
X		  break;
X		case 29:
X		  if (get_dir(CNIL, &dir))
X		    fire_ball(GF_FIRE, dir, char_row, char_col, 72,
X			      spell_names[28]);
X		  break;
X		case 30:
X		  destroy_area(char_row, char_col);
X		  break;
X		case 31:
X		  (void) genocide();
X		  break;
X		default:
X		  break;
X		}
X	      /* End of spells.				     */
X	      if (!free_turn_flag)
X		{
X		  p_ptr = &py.misc;
X		  if ((spell_worked & (1L << choice)) == 0)
X		    {
X		      p_ptr->exp += m_ptr->sexp << 2;
X		      spell_worked |= (1L << choice);
X		      prt_experience();
X		    }
X		}
X	    }
X	  p_ptr = &py.misc;
X	  if (!free_turn_flag)
X	    {
X	      if (m_ptr->smana > p_ptr->cmana)
X		{
X		  msg_print("You faint from the effort!");
X		  py.flags.paralysis =
X		    randint((int)(5*(m_ptr->smana-p_ptr->cmana)));
X		  p_ptr->cmana = 0;
X		  p_ptr->cmana_frac = 0;
X		  if (randint(3) == 1)
X		    {
X		      msg_print("You have damaged your health!");
X		      (void) dec_stat (A_CON);
X		    }
X		}
X	      else
X		p_ptr->cmana -= m_ptr->smana;
X	      prt_cmana();
X	    }
X	}
X    }
X}
END_OF_FILE
if test 5184 -ne `wc -c <'source/magic.c'`; then
    echo shar: \"'source/magic.c'\" unpacked with wrong size!
fi
# end of 'source/magic.c'
fi
if test -f 'source/sets.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/sets.c'\"
else
echo shar: Extracting \"'source/sets.c'\" \(5213 characters\)
sed "s/^X//" >'source/sets.c' <<'END_OF_FILE'
X/* source/sets.c: code to emulate the original Pascal sets
X
X   Copyright (c) 1989-92 James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X
Xint set_room(element)
Xregister int element;
X{
X  if ((element == DARK_FLOOR) || (element == LIGHT_FLOOR))
X    return(TRUE);
X  return(FALSE);
X}
X
Xint set_corr(element)
Xregister int element;
X{
X  if (element == CORR_FLOOR || element == BLOCKED_FLOOR)
X    return(TRUE);
X  return(FALSE);
X}
X
Xint set_floor(element)
Xint element;
X{
X  if (element <= MAX_CAVE_FLOOR)
X    return(TRUE);
X  else
X    return(FALSE);
X}
X
Xint set_corrodes(item)
Xinven_type *item;
X{
X  switch(item->tval)
X    {
X    case TV_SWORD: case TV_HELM: case TV_SHIELD: case TV_HARD_ARMOR:
X    case TV_WAND:
X      return (TRUE);
X    }
X  return(FALSE);
X}
X
X
Xint set_flammable(item)
Xinven_type *item;
X{
X  switch(item->tval)
X    {
X    case TV_ARROW: case TV_BOW: case TV_HAFTED: case TV_POLEARM:
X    case TV_BOOTS: case TV_GLOVES: case TV_CLOAK: case TV_SOFT_ARMOR:
X      /* Items of (RF) should not be destroyed.  */
X      if (item->flags & TR_RES_FIRE)
X	return FALSE;
X      else
X	return TRUE;
X
X    case TV_STAFF: case TV_SCROLL1: case TV_SCROLL2:
X      return TRUE;
X    }
X  return(FALSE);
X}
X
X
Xint set_frost_destroy(item)
Xinven_type *item;
X{
X  if ((item->tval == TV_POTION1) || (item->tval == TV_POTION2)
X      || (item->tval == TV_FLASK))
X    return(TRUE);
X  return(FALSE);
X}
X
X
Xint set_acid_affect(item)
Xinven_type *item;
X{
X  switch(item->tval)
X    {
X    case TV_MISC: case TV_CHEST:
X      return TRUE;
X    case TV_BOLT: case TV_ARROW:
X    case TV_BOW: case TV_HAFTED: case TV_POLEARM: case TV_BOOTS:
X    case TV_GLOVES: case TV_CLOAK: case TV_SOFT_ARMOR:
X      if (item->flags & TR_RES_ACID)
X	return (FALSE);
X      else
X	return (TRUE);
X    }
X  return(FALSE);
X}
X
X
Xint set_lightning_destroy(item)
Xinven_type *item;
X{
X  if ((item->tval == TV_RING) || (item->tval == TV_WAND)
X      || (item->tval == TV_SPIKE))
X    return(TRUE);
X  else
X    return(FALSE);
X}
X
X
X/*ARGSUSED*/	/* to shut up lint about unused argument */
X#ifdef __TURBOC__
X	#pragma argused
X#endif
Xint set_null(item)
Xinven_type *item;
X#if defined(MAC) && !defined(THINK_C)
X	#pragma unused(item)
X#endif
X{
X  return(FALSE);
X}
X
X
Xint set_acid_destroy(item)
Xinven_type *item;
X{
X  switch(item->tval)
X    {
X    case TV_ARROW: case TV_BOW: case TV_HAFTED: case TV_POLEARM:
X    case TV_BOOTS: case TV_GLOVES: case TV_CLOAK: case TV_HELM:
X    case TV_SHIELD: case TV_HARD_ARMOR: case TV_SOFT_ARMOR:
X      if (item->flags & TR_RES_ACID)
X	return FALSE;
X      else
X	return TRUE;
X    case TV_STAFF:
X    case TV_SCROLL1: case TV_SCROLL2: case TV_FOOD: case TV_OPEN_DOOR:
X    case TV_CLOSED_DOOR:
X      return(TRUE);
X    }
X  return(FALSE);
X}
X
X
Xint set_fire_destroy(item)
Xinven_type *item;
X{
X  switch(item->tval)
X    {
X    case TV_ARROW: case TV_BOW: case TV_HAFTED: case TV_POLEARM:
X    case TV_BOOTS: case TV_GLOVES: case TV_CLOAK: case TV_SOFT_ARMOR:
X      if (item->flags & TR_RES_FIRE)
X	return FALSE;
X      else
X	return TRUE;
X    case TV_STAFF: case TV_SCROLL1: case TV_SCROLL2: case TV_POTION1:
X    case TV_POTION2: case TV_FLASK: case TV_FOOD: case TV_OPEN_DOOR:
X    case TV_CLOSED_DOOR:
X      return(TRUE);
X    }
X  return(FALSE);
X}
X
X
Xint general_store(element)
Xint element;
X{
X  switch(element)
X    {
X    case TV_DIGGING: case TV_BOOTS: case TV_CLOAK: case TV_FOOD:
X    case TV_FLASK: case TV_LIGHT: case TV_SPIKE:
X      return(TRUE);
X    }
X  return(FALSE);
X}
X
X
Xint armory(element)
Xint element;
X{
X  switch(element)
X    {
X    case TV_BOOTS: case TV_GLOVES: case TV_HELM: case TV_SHIELD:
X    case TV_HARD_ARMOR: case TV_SOFT_ARMOR:
X      return(TRUE);
X    }
X  return(FALSE);
X}
X
X
Xint weaponsmith(element)
Xint element;
X{
X  switch(element)
X    {
X    case TV_SLING_AMMO: case TV_BOLT: case TV_ARROW: case TV_BOW:
X    case TV_HAFTED: case TV_POLEARM: case TV_SWORD:
X      return(TRUE);
X    }
X  return(FALSE);
X}
X
X
Xint temple(element)
Xint element;
X{
X  switch(element)
X    {
X    case TV_HAFTED: case TV_SCROLL1: case TV_SCROLL2: case TV_POTION1:
X    case TV_POTION2: case TV_PRAYER_BOOK:
X      return(TRUE);
X    }
X  return(FALSE);
X}
X
X
Xint alchemist(element)
Xint element;
X{
X  switch(element)
X    {
X    case TV_SCROLL1: case TV_SCROLL2: case TV_POTION1: case TV_POTION2:
X      return(TRUE);
X    }
X  return(FALSE);
X}
X
X
Xint magic_shop(element)
Xint element;
X{
X  switch(element)
X    {
X    case TV_AMULET: case TV_RING: case TV_STAFF: case TV_WAND:
X    case TV_SCROLL1: case TV_SCROLL2: case TV_POTION1: case TV_POTION2:
X    case TV_MAGIC_BOOK:
X      return(TRUE);
X    }
X  return(FALSE);
X}
X
X#ifdef MAC
X/* The last time tried, MPW failed to handle the initialized array of
X   function pointers properly.  hence, this hack. */
Xint store_buy(storeno, element)
Xint storeno;
Xint element;
X{
X  switch (storeno)
X    {
X    case 0: return(general_store(element));
X    case 1: return(armory(element));
X    case 2: return(weaponsmith(element));
X    case 3: return(temple(element));
X    case 4: return(alchemist(element));
X    case 5: return(magic_shop(element));
X    }
X  return(FALSE);
X}
X#endif
END_OF_FILE
if test 5213 -ne `wc -c <'source/sets.c'`; then
    echo shar: \"'source/sets.c'\" unpacked with wrong size!
fi
# end of 'source/sets.c'
fi
if test -f 'source/wands.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/wands.c'\"
else
echo shar: Extracting \"'source/wands.c'\" \(4757 characters\)
sed "s/^X//" >'source/wands.c' <<'END_OF_FILE'
X/* source/wands.c: wand code
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#ifdef USG
X#ifndef ATARIST_MWC
X#include <string.h>
X#endif
X#else
X#include <strings.h>
X#endif
X
X/* Wands for the aiming.				*/
Xvoid aim()
X{
X  int32u i;
X  register int l, ident;
X  int item_val, j, k, chance, dir;
X  register inven_type *i_ptr;
X  register struct misc *m_ptr;
X
X  free_turn_flag = TRUE;
X  if (inven_ctr == 0)
X    msg_print("But you are not carrying anything.");
X  else if (!find_range(TV_WAND, TV_NEVER, &j, &k))
X    msg_print("You are not carrying any wands.");
X  else if (get_item(&item_val, "Aim which wand?", j, k, CNIL, CNIL))
X    {
X      i_ptr = &inventory[item_val];
X      free_turn_flag = FALSE;
X      if (get_dir(CNIL, &dir))
X	{
X	  if (py.flags.confused > 0)
X	    {
X	      msg_print("You are confused.");
X	      do
X		{
X		  dir = randint(9);
X		}
X	      while (dir == 5);
X	    }
X	  ident = FALSE;
X	  m_ptr = &py.misc;
X	  chance = m_ptr->save + stat_adj(A_INT) - (int)i_ptr->level
X	    + (class_level_adj[m_ptr->pclass][CLA_DEVICE] * m_ptr->lev / 3);
X	  if (py.flags.confused > 0)
X	    chance = chance / 2;
X	  if ((chance < USE_DEVICE) && (randint(USE_DEVICE - chance + 1) == 1))
X	    chance = USE_DEVICE; /* Give everyone a slight chance */
X	  if (chance <= 0)  chance = 1;
X	  if (randint(chance) < USE_DEVICE)
X	    msg_print("You failed to use the wand properly.");
X	  else if (i_ptr->p1 > 0)
X	    {
X	      i = i_ptr->flags;
X	      (i_ptr->p1)--;
X	      while (i != 0)
X		{
X		  j = bit_pos(&i) + 1;
X		  k = char_row;
X		  l = char_col;
X		  /* Wands			 */
X		  switch(j)
X		    {
X		    case 1:
X		      msg_print("A line of blue shimmering light appears.");
X		      light_line(dir, char_row, char_col);
X		      ident = TRUE;
X		      break;
X		    case 2:
X		      fire_bolt(GF_LIGHTNING, dir, k, l, damroll(4, 8),
X				spell_names[8]);
X		      ident = TRUE;
X		      break;
X		    case 3:
X		      fire_bolt(GF_FROST, dir, k, l, damroll(6, 8),
X				spell_names[14]);
X		      ident = TRUE;
X		      break;
X		    case 4:
X		      fire_bolt(GF_FIRE, dir, k, l, damroll(9, 8),
X				spell_names[22]);
X		      ident = TRUE;
X		      break;
X		    case 5:
X		      ident = wall_to_mud(dir, k, l);
X		      break;
X		    case 6:
X		      ident = poly_monster(dir, k, l);
X		      break;
X		    case 7:
X		      ident = hp_monster(dir, k, l, -damroll(4, 6));
X		      break;
X		    case 8:
X		      ident = speed_monster(dir, k, l, 1);
X		      break;
X		    case 9:
X		      ident = speed_monster(dir, k, l, -1);
X		      break;
X		    case 10:
X		      ident = confuse_monster(dir, k, l);
X		      break;
X		    case 11:
X		      ident = sleep_monster(dir, k, l);
X		      break;
X		    case 12:
X		      ident = drain_life(dir, k, l);
X		      break;
X		    case 13:
X		      ident = td_destroy2(dir, k, l);
X		      break;
X		    case 14:
X		      fire_bolt(GF_MAGIC_MISSILE, dir, k, l, damroll(2, 6),
X				spell_names[0]);
X		      ident = TRUE;
X		      break;
X		    case 15:
X		      ident = build_wall(dir, k, l);
X		      break;
X		    case 16:
X		      ident = clone_monster(dir, k, l);
X		      break;
X		    case 17:
X		      ident = teleport_monster(dir, k, l);
X		      break;
X		    case 18:
X		      ident = disarm_all(dir, k, l);
X		      break;
X		    case 19:
X		      fire_ball(GF_LIGHTNING, dir, k, l, 32, "Lightning Ball");
X		      ident = TRUE;
X		      break;
X		    case 20:
X		      fire_ball(GF_FROST, dir, k, l, 48, "Cold Ball");
X		      ident = TRUE;
X		      break;
X		    case 21:
X		      fire_ball(GF_FIRE, dir, k, l, 72, spell_names[28]);
X		      ident = TRUE;
X		      break;
X		    case 22:
X		      fire_ball(GF_POISON_GAS, dir, k, l, 12, spell_names[6]);
X		      ident = TRUE;
X		      break;
X		    case 23:
X		      fire_ball(GF_ACID, dir, k, l, 60, "Acid Ball");
X		      ident = TRUE;
X		      break;
X		    case 24:
X		      i = 1L << (randint(23) - 1);
X		      break;
X		    default:
X		      msg_print("Internal error in wands()");
X		      break;
X		    }
X		  /* End of Wands.		    */
X		}
X	      if (ident)
X		{
X		  if (!known1_p(i_ptr))
X		    {
X		      m_ptr = &py.misc;
X		      /* round half-way case up */
X		      m_ptr->exp += (i_ptr->level +(m_ptr->lev >> 1)) /
X			m_ptr->lev;
X		      prt_experience();
X
X		      identify(&item_val);
X		      i_ptr = &inventory[item_val];
X		    }
X		}
X	      else if (!known1_p(i_ptr))
X		sample (i_ptr);
X	      desc_charges(item_val);
X	    }
X	  else
X	    {
X	      msg_print("The wand has no charges left.");
X	      if (!known2_p(i_ptr))
X		add_inscribe(i_ptr, ID_EMPTY);
X	    }
X	}
X    }
X}
END_OF_FILE
if test 4757 -ne `wc -c <'source/wands.c'`; then
    echo shar: \"'source/wands.c'\" unpacked with wrong size!
fi
# end of 'source/wands.c'
fi
if test -f 'util/mcheck.inf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/mcheck.inf'\"
else
echo shar: Extracting \"'util/mcheck.inf'\" \(5237 characters\)
sed "s/^X//" >'util/mcheck.inf' <<'END_OF_FILE'
X
XGoal: write a little program that will check the monster file for consistency,
X	since I am tired of doing this manually; the comments below detail
X	everything that the program will verify
X
X****************
X
XCreature classification scheme
X
Xdragon: d, D
X	never invisible, can't open doors, never phase, never eats others,
X	never pick up objects, never multiply, carry objects/gold, breath
X	weapons, cast spells, hurt by slay dragon, hurt by slay evil, can be
X	slept, seen by infravision, young/mature 20% random movement
X
Xhumanoid: h, H, k, n, o, p, P, T, U, y, Y
X	can open doors, never eats others, all that carry treasure pick up obj,
X	never multiply, h/U/Y and some people don't carry treasure,
X	some cast spells, no breath weapons, all except some humans evil,
X	hurt by slay evil, can be slept, seen by infravision, never random
X	movement (except 0 level humans which are all 20% random)
X
Xundead: G, L, M, s, V, W, Z
X	only G invisible, all except s/Z open doors, only G/W phase,
X	never eats others, only G picks up objects, never multiply,
X	only s/Z do not carry objects/gold, some cast spells,
X	no breath weapons, all evil except s/Z, hurt by slay evil,
X	hurt by slay undead, can't be slept, never seen by infravision,
X	G very random movement, W 20% random movement, others never random
X	movement
X
Xanimal: a, A, b, c, f, F, j, K, l, r, R, S, t, w
X	only one of a/c invisible, can't open doors, never phase,
X	only A eats others, never pick up objects, only a/b/F/l/r/w multiply,
X	never carry objects or gold, never cast spells, some breath weapons,
X	not evil, hurt by slay animal, can be slept, mammals seen by
X	infravision, most have 20% random movement
X
Xdemons: B, p(Evil Iggy), q
X	always invisible, only B can phase, only B eats others, always pick up
X	objects, never multiply, carry objects/gold, cast spells, only B
X	breath weapon, all evil, hurt by slay evil, can not be slept, not seen
X	by infravision, never random movement
X
Xquylthulg: Q
X	in a class by itself, almost exactly the same as demon except not
X	evil and does not carry objects/gold, should be in class other
X
Xother: C, e, E, g, i, J, m, O, X, $, ','
X	some can be invisible, never open doors, only X phase,
X	only C/E/i/O eats others, only C/E/i/O pick up objects, only
X	O/',' multiply, only C/i/O carry objects/gold, $ carries only
X	gold, no breath weapons, not evil (all brainless
X	creatures), not hurt by any special weapon, can't be slept,
X	never seen with infravision, brainless creatures,
X	some drain mana/exp/etc., fire/air elementals (includes invisible
X	stalker) move quickly, golems are animated and should never move
X	randomly, the rest never move or move slowly/randomly if they do
X
XMiscellaneous overriding factors:
X	if invisible, not seen by infravision
X	if invisible, not hurt by blue light
X	if frost attack, not seen by infravion
X	if frost attack, not hurt by cold
X	if frost attack, hurt by fire
X	if fire attack, seen by infravision
X	if fire attack, not hurt by fire
X	if fire attack, hurt by frost
X	if fire&frost attack, not hurt by fire nor cold, infravision depends
X		on class
X	if acid attack, not hurt by acid
X	if poison/corrosion gas attack, not hurt by poison
X	if lightning attack, not hurt by blue light
X	if lungless, can not breathe/spit damage
X	if invisible can not gaze damage
X	if stone-to-mud hurt, not cold/fire hurt
X	if not move and brainless, in general, not carry objects/gold
X	if move and brainless, in general, carry objects/gold only if pick
X		up objects
X
XPossible changes:
X	examine vulnerability list for errors, changes, things that don't
X		make sense, additions, etc...
X	need to classify lungless creatures here somewhere
X	creatures without limbs should not claw for damage
X	creatures without mouths should not bite for damage
X
XSpecial vulnerabilities for each class:
Xa: none
XA: cold, fire
Xb: fire, poison, blue light
XB: none
Xc: none
XC: fire
Xd: none
XD: none
Xe: blue light
XE: cold(fire), fire(water), stone-to-mud(earth), none (stalker,air)
Xf: acid, fire
XF: cold, fire, poison
Xg: cold, fire, acid, blue light(flesh)
Xg: stone-to-mud (clay/stone)
Xg: acid (iron)
XG: none
Xh: cold, fire
XH: cold, fire
Xi: none
XI: {no monster}
Xj: cold, fire
XJ: fire, acid, blue light
Xk: cold, fire
XK: none
Xl: cold, fire, acid, poison, blue light
XL: none
Xm: fire, acid
XM: fire
Xn: fire, poison, acid
XN: {no monster}
Xo: cold, fire
XO: fire, acid
Xp: fire, cold
XP: stone-to-mud (stone)
XP: cold, fire (all except stone)
Xq: none
XQ: none
Xr: cold, fire, poison
XR: cold, fire, acid
Xs: none
XS: none
Xt: fire
XT: fire
Xu: {no monster}
XU: fire, blue light
Xv: {no monster}
XV: fire, blue light
Xw: cold, fire, acid, blue light
XW: fire, blue light
Xx: {no monster}
XX: stone-to-mud
Xy: cold, fire
XY: fire
Xz: fire
XZ: {no monster}
X$: none
X,: fire, acid
X
XObvious errors in monster.c file:
XHere is a list of errors in the monster.c file, assuming that the above
Xclassification scheme is used.	I have not examined the entire list.
X
Xsquint-eyed rogue should move 20% randomly
X
Xspirit troll should not be type 'T',
X	since this is not an undead type, should carry objects depending on
X		which type it is changed to
X	if make zombie must remove phase ability
X	if make ghost must make invisible
X
Xcreeping coins: touch for normal damage, bite for poison damage
X
Xdepends: pick_up_obj, movement
END_OF_FILE
if test 5237 -ne `wc -c <'util/mcheck.inf'`; then
    echo shar: \"'util/mcheck.inf'\" unpacked with wrong size!
fi
# end of 'util/mcheck.inf'
fi
if test -f 'util/scores/print.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/scores/print.c'\"
else
echo shar: Extracting \"'util/scores/print.c'\" \(4599 characters\)
sed "s/^X//" >'util/scores/print.c' <<'END_OF_FILE'
X/* util/scores/print.c: standalone program to print score file
X
X   Copyright (c) 1991 James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include <stdio.h>
X
X#include "../../source/config.h"
X#include "../../source/constant.h"
X#include "../../source/types.h"
X#include "../../source/externs.h"
X
X#if defined(USG) || defined(VMS)
X#ifndef L_SET
X#define L_SET 0
X#endif
X#ifndef L_INCR
X#define L_INCR 1
X#endif
X#endif
X
X#undef fopen
X
X#ifndef USG
X/* only needed for Berkeley UNIX */
X#include <sys/param.h>
X#include <sys/types.h>
X#include <sys/file.h>
X#endif
X
Xextern race_type race[MAX_RACES];
Xextern class_type class[MAX_CLASS];
X
XFILE *highscore_fp;
XFILE *fileptr;
Xint8u xor_byte;
X
Xvoid set_fileptr();
X
Xmain(argc, argv)
X     int argc;
X     char *argv[];
X{
X  register int i, rank;
X  high_scores score;
X  char string[100];
X  int8u version_maj, version_min, patch_level;
X  int16 player_uid;
X
X  if (argc != 2)
X    {
X      printf ("Usage: print scorefile\n");
X      exit (-2);
X    }
X
X  if ((highscore_fp = fopen (argv[1], "r")) == NULL)
X    {
X      printf ("Error opening score file \"%s\"\n", MORIA_TOP);
X      exit (-1);
X    }
X
X#ifdef MSDOS
X  (void) setmode (fileno(highscore_fp), O_BINARY);
X#endif
X
X#ifndef BSD4_3
X  (void) fseek(highscore_fp, (long)0, L_SET);
X#else
X  (void) fseek(highscore_fp, (off_t)0, L_SET);
X#endif
X
X  /* Read version numbers from the score file, and check for validity.  */
X  version_maj = getc (highscore_fp);
X  version_min = getc (highscore_fp);
X  patch_level = getc (highscore_fp);
X  /* Support score files from 5.2.2 to present.  */
X  if (feof (highscore_fp))
X    {
X      printf ("The scorefile is empty.\n");
X      exit (-1);
X    }
X  else if ((version_maj != CUR_VERSION_MAJ)
X      || (version_min > CUR_VERSION_MIN)
X      || (version_min == CUR_VERSION_MIN && patch_level > PATCH_LEVEL)
X      || (version_min == 2 && patch_level < 2)
X      || (version_min < 2))
X    {
X      printf("Sorry. This scorefile is from a different version of umoria.\n");
X      exit (-1);
X    }
X
X#ifdef unix
X  player_uid = getuid ();
X#else
X#ifdef VMS
X  player_uid = (getgid()*1000) + getuid();
X#else
X  player_uid = 0;
X#endif
X#endif
X
X  /* set the static fileptr in save.c to the highscore file pointer */
X  set_fileptr(highscore_fp);
X
X  rank = 1;
X  rd_highscore(&score);
X  printf("Rank  Points Name              Sex Race       Class  Lvl Killed By\n");
X  while (!feof(highscore_fp))
X    {
X      i = 1;
X      /* Put twenty scores on each page, on lines 2 through 21. */
X      while (!feof(highscore_fp) && i < 21)
X	{
X	  (void) sprintf(string,
X			 "%-4d%8ld %-19.19s %c %-10.10s %-7.7s%3d %-22.22s\n",
X			 rank, score.points, score.name, score.sex,
X			 race[score.race].trace, class[score.class].title,
X			 score.lev, score.died_from);
X	  printf (string, ++i);
X	  rank++;
X	  rd_highscore(&score);
X	}
X    }
X
X  /* Success.  */
X  exit (0);
X}
X
Xstatic void rd_byte(ptr)
Xint8u *ptr;
X{
X  int8u c;
X
X  c = getc(fileptr) & 0xFF;
X  *ptr = c ^ xor_byte;
X  xor_byte = c;
X}
X
Xstatic void rd_short(ptr)
Xint16u *ptr;
X{
X  int8u c;
X  int16u s;
X
X  c = (getc(fileptr) & 0xFF);
X  s = c ^ xor_byte;
X  xor_byte = (getc(fileptr) & 0xFF);
X  s |= (int16u)(c ^ xor_byte) << 8;
X  *ptr = s;
X}
X
Xstatic void rd_long(ptr)
Xint32u *ptr;
X{
X  register int32u l;
X  register int8u c;
X
X  c = (getc(fileptr) & 0xFF);
X  l = c ^ xor_byte;
X  xor_byte = (getc(fileptr) & 0xFF);
X  l |= (int32u)(c ^ xor_byte) << 8;
X  c = (getc(fileptr) & 0xFF);
X  l |= (int32u)(c ^ xor_byte) << 16;
X  xor_byte = (getc(fileptr) & 0xFF);
X  l |= (int32u)(c ^ xor_byte) << 24;
X  *ptr = l;
X}
X
Xstatic void rd_bytes(ch_ptr, count)
Xint8u *ch_ptr;
Xregister int count;
X{
X  register int i;
X  register int8u *ptr;
X  register int8u c;
X
X  ptr = ch_ptr;
X  for (i = 0; i < count; i++)
X    {
X      c = (getc(fileptr) & 0xFF);
X      *ptr++ = c ^ xor_byte;
X      xor_byte = c;
X    }
X}
X
X/* set the local fileptr to the scorefile fileptr */
Xvoid set_fileptr(file)
XFILE *file;
X{
X  fileptr = file;
X}
X
Xvoid rd_highscore(score)
Xhigh_scores *score;
X{
X  /* Read the encryption byte.  */
X  rd_byte (&xor_byte);
X
X  rd_long((int32u *)&score->points);
X  rd_long((int32u *)&score->birth_date);
X  rd_short((int16u *)&score->uid);
X  rd_short((int16u *)&score->mhp);
X  rd_short((int16u *)&score->chp);
X  rd_byte(&score->dun_level);
X  rd_byte(&score->lev);
X  rd_byte(&score->max_dlv);
X  rd_byte(&score->sex);
X  rd_byte(&score->race);
X  rd_byte(&score->class);
X  rd_bytes((int8u *)score->name, PLAYER_NAME_SIZE);
X  rd_bytes((int8u *)score->died_from, 25);
X}
END_OF_FILE
if test 4599 -ne `wc -c <'util/scores/print.c'`; then
    echo shar: \"'util/scores/print.c'\" unpacked with wrong size!
fi
# end of 'util/scores/print.c'
fi
if test -f 'vms/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/Makefile'\"
else
echo shar: Extracting \"'vms/Makefile'\" \(4426 characters\)
sed "s/^X//" >'vms/Makefile' <<'END_OF_FILE'
X# COPTS = /nowarning
XCOPTS =
X
XOBJS1 = create.obj creature.obj death.obj desc.obj dungeon.obj eat.obj \
X	files.obj generate.obj getch.obj help.obj io.obj magic.obj main.obj \
X	misc1.obj misc2.obj misc3.obj misc4.obj monsters.obj
XOBJS2 = moria1.obj moria2.obj moria3.obj moria4.obj player.obj potions.obj \
X	prayer.obj recall.obj rnd.obj save.obj scrolls.obj sets.obj \
X	signals.obj spells.obj staffs.obj store1.obj store2.obj tables.obj
XOBJS3 =  treasure.obj uexit.obj variable.obj wands.obj wizard.obj
X
Xmoria : $(OBJS1) $(OBJS2) $(OBJS3)
X	link moria/opt
X
Xcreate.obj : create.c constant.h types.h externs.h config.h
X	cc $(COPTS) create.c /obj=create.obj
X
Xcreature.obj : creature.c constant.h types.h externs.h config.h
X	cc $(COPTS) creature.c /obj=creature.obj
X
Xdeath.obj : death.c constant.h types.h externs.h config.h
X	cc $(COPTS) death.c /obj=death.obj
X
Xdesc.obj : desc.c constant.h types.h externs.h config.h
X	cc $(COPTS) desc.c /obj=desc.obj
X
Xdungeon.obj : dungeon.c constant.h types.h externs.h config.h
X	cc $(COPTS) dungeon.c /obj=dungeon.obj
X
Xeat.obj : eat.c constant.h types.h externs.h config.h
X	cc $(COPTS) eat.c /obj=eat.obj
X
Xfiles.obj : files.c constant.h types.h externs.h config.h
X	cc $(COPTS) files.c /obj=files.obj
X
Xgenerate.obj : generate.c constant.h types.h externs.h config.h
X	cc $(COPTS) generate.c /obj=generate.obj
X
Xgetch.obj : getch.c
X	cc $(COPTS) getch.c /obj=getch.obj
X
Xhelp.obj : help.c constant.h types.h externs.h config.h
X	cc $(COPTS) help.c /obj=help.obj
X
Xio.obj : io.c constant.h types.h externs.h config.h
X	cc $(COPTS) io.c /obj=io.obj
X
Xmagic.obj : magic.c constant.h types.h externs.h config.h
X	cc $(COPTS) magic.c /obj=magic.obj
X
Xmain.obj : main.c constant.h types.h externs.h config.h
X	cc $(COPTS) main.c /obj=main.obj
X
Xmisc1.obj : misc1.c constant.h types.h externs.h config.h
X	cc $(COPTS) misc1.c /obj=misc1.obj
X
Xmisc2.obj : misc2.c constant.h types.h externs.h config.h
X	cc $(COPTS) misc2.c /obj=misc2.obj
X
Xmisc3.obj : misc3.c constant.h types.h externs.h config.h
X	cc $(COPTS) misc3.c /obj=misc3.obj
X
Xmisc4.obj : misc4.c constant.h types.h externs.h config.h
X	cc $(COPTS) misc4.c /obj=misc4.obj
X
Xmonsters.obj : monsters.c constant.h types.h config.h
X	cc $(COPTS) monsters.c /obj=monsters.obj
X
Xmoria1.obj : moria1.c constant.h types.h externs.h config.h
X	cc $(COPTS) moria1.c /obj=moria1.obj
X
Xmoria2.obj : moria2.c constant.h types.h externs.h config.h
X	cc $(COPTS) moria2.c /obj=moria2.obj
X
Xmoria3.obj : moria3.c constant.h types.h externs.h config.h
X	cc $(COPTS) moria3.c /obj=moria3.obj
X
Xmoria4.obj : moria4.c constant.h types.h externs.h config.h
X	cc $(COPTS) moria4.c /obj=moria4.obj
X
Xplayer.obj : player.c constant.h types.h config.h
X	cc $(COPTS) player.c /obj=player.obj
X
Xpotions.obj : potions.c constant.h types.h externs.h config.h
X	cc $(COPTS) potions.c /obj=potions.obj
X
Xprayer.obj : prayer.c constant.h types.h externs.h config.h
X	cc $(COPTS) prayer.c /obj=prayer.obj
X
Xrecall.obj : recall.c constant.h types.h externs.h config.h
X	cc $(COPTS) recall.c /obj=recall.obj
X
Xrnd.obj : rnd.c constant.h types.h
X	cc $(COPTS) rnd.c /obj=rnd.obj
X
Xsave.obj : save.c constant.h types.h externs.h config.h
X	cc $(COPTS) save.c /obj=save.obj
X
Xscrolls.obj : scrolls.c constant.h types.h externs.h config.h
X	cc $(COPTS) scrolls.c /obj=scrolls.obj
X
Xsets.obj : sets.c constant.h config.h
X	cc $(COPTS) sets.c /obj=sets.obj
X
Xsignals.obj : signals.c constant.h types.h externs.h config.h
X	cc $(COPTS) signals.c /obj=signals.obj
X
Xspells.obj : spells.c constant.h types.h externs.h config.h
X	cc $(COPTS) spells.c /obj=spells.obj
X
Xstaffs.obj : staffs.c constant.h types.h externs.h config.h
X	cc $(COPTS) staffs.c /obj=staffs.obj
X
Xstore1.obj : store1.c constant.h types.h externs.h config.h
X	cc $(COPTS) store1.c /obj=store1.obj
X
Xstore2.obj : store2.c constant.h types.h externs.h config.h
X	cc $(COPTS) store2.c /obj=store2.obj
X
Xtables.obj : tables.c constant.h types.h config.h
X	cc $(COPTS) tables.c /obj=tables.obj
X
Xtreasure.obj : treasure.c constant.h types.h config.h
X	cc $(COPTS) treasure.c /obj=treasure.obj
X
Xuexit.obj : uexit.c constant.h types.h config.h
X	cc $(COPTS) uexit.c /obj=uexit.obj
X
Xvariable.obj : variable.c constant.h types.h externs.h config.h
X	cc $(COPTS) variable.c /obj=variable.obj
X
Xwands.obj : wands.c constant.h types.h externs.h config.h
X	cc $(COPTS) wands.c /obj=wands.obj
X
Xwizard.obj : wizard.c constant.h types.h externs.h config.h
X	cc $(COPTS) wizard.c /obj=wizard.obj
X
X
END_OF_FILE
if test 4426 -ne `wc -c <'vms/Makefile'`; then
    echo shar: \"'vms/Makefile'\" unpacked with wrong size!
fi
# end of 'vms/Makefile'
fi
if test -f 'vms/getch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/getch.c'\"
else
echo shar: Extracting \"'vms/getch.c'\" \(4982 characters\)
sed "s/^X//" >'vms/getch.c' <<'END_OF_FILE'
X/* vms/getch.c: input routines for VMS, integrated with smcurses for VMS
X
X   Copyright (c) 1986-92 Joshua Delahunty, James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include <iodef.h>
X#include <ssdef.h>
X#include <descrip.h>
X#include <stdio.h>
X
X#ifndef TRUE
X# define TRUE 1
X# define FALSE 0
X#endif
X
X/* the type of keyboard read we're doing */
X#define FUNC IO$_TTYREADALL|IO$M_NOECHO|IO$M_TRMNOECHO
X
X	static $DESCRIPTOR(chan, "tt:");
X	static char ungotch;
X	static unsigned short int kb_chan = 0;	/* channel # */
X	static unsigned short int	charwaiting = FALSE,
X					crmode_status = TRUE,
X					echo_status = FALSE;
X
X/* This code was tested and worked on a VAX 11/785 running VMS 5.2.
X   contributed by Ralph Waters, rwaters@jabba.ess.harris.com.  */
X
X/* Returns 1 is a character has been pressed, 0 otherwise.  */
Xint kbhit()
X{
X  /* sys$qiow ( [efn] ,chan ,func [,iosb] [,astadr] [,astprm]
X		[,p1] [,p2] [,p3] [,p4] [,p5] [,p6] )			*/
X
X  /* The sys$qiow call with the IO$_SENSEMODE|IO$M_TYPEAHDCNT function
X     will return the following in p1:
X
X     31        24 23        16 15                     0
X     ------------|------------|------------------------
X     | reserved  |   first    | number of characters  |
X     |           | character  | in type-ahead buffer  |
X     |-----------|------------|-----------------------|
X     |                    reserved                    |
X     |                                                |
X     --------------------------------------------------
X  */
X
X  struct qio_return_type {
X	 unsigned short int type_ahead_count;	/* type-ahead count */
X	 unsigned char first_char;		/* first character in buffer */
X	 unsigned char b_reserved;		/* reserved byte */
X	 unsigned long int l_reserved; }	/* reserved long word */
X    qio_return;
X
X  sys$qiow (0, kb_chan, (IO$_SENSEMODE | IO$M_TYPEAHDCNT), 0, 0, 0,
X	    &qio_return, 0, 0, 0, 0, 0);
X  if (qio_return.type_ahead_count > 0)
X    return(1);
X  else
X    return(0);
X}
X
X/* Another useful function courtesy of Ralph Waters.  */
X#include <jpidef.h>
X
X/* Stores the user's login name in the argument buf.  */
Xvoid user_name(buf)
Xchar *buf;
X{
X  /* sys$getjpiw ( [efn], [pidadr], [prcnam], itmlst [,iosb]
X                   [,astadr] [,astprm]					*/
X
X  long int return_length;
X  struct getjpi_itmlst_type {
X    unsigned short int buffer_length;	/* length of return buffer */
X    unsigned short int item_code;		/* item code to getjpi about */
X    unsigned long int buffer_address;	/* address of return data */
X    unsigned long int return_length_addr; }	/*actual size of return data */
X  getjpi_itmlst;
X
X  getjpi_itmlst.buffer_length = 12;	/* VMS usernames are 12 chars */
X  getjpi_itmlst.item_code = JPI$_USERNAME;
X  getjpi_itmlst.buffer_address = buf;
X  getjpi_itmlst.return_length_addr = &return_length;
X
X  sys$getjpiw (0, 0, 0, &getjpi_itmlst, 0, 0, 0);
X
X  return;
X}
X
X/* After calling this, vms_getch() returns unbuffered single chars.  */
Xvoid vms_crmode()	/* Character-Return MODE */
X{
X	if(kb_chan == 0)
X		opengetch();
X
X	crmode_status = TRUE;
X}
X
X/* After calling this, vms_getch() returns echoed, buffered characters.  */
Xvoid vms_nocrmode()	/* NO Character-Return MODE */
X{
X	if(kb_chan != 0)
X		closegetch();
X
X	crmode_status = FALSE;
X}
X
X/* Sets up terminal for getch() calls, returns VMS status code.  */
Xint opengetch()	/* does the actual assignment work */
X{
X	/* assign channel on keyboard */
X	return(sys$assign(&chan,&kb_chan,0,0));
X}
X
X/* Undoes affects of above, returns VMS status code for the operation.  */
Xint closegetch()	/* performs the actual deassignment work */
X{
X	int rv;
X
X	if(kb_chan != 0) {
X		/* deassign keyboard channel */
X		rv = sys$dassgn(kb_chan);
X		kb_chan = 0;
X		return(rv);
X	}
X}
X
X/* Returns an [optionally] unbuffered [non-]echoed input character.
X
X   If crmode_status is not set, then the code returns one character from
X   the buffered input.
X   If crmode_status is set, then the code returns an `ungot' character if
X   one exists, otherwise it tries to read one unbuffered character from the
X   keyboard.  If echo_status is set, then the character will be echoed
X   before returning.  */
Xchar vms_getch()
X{
X	int rv;
X	char kb_buf;				/* buffer for input char */
X
X	if(crmode_status) {
X
X		if(!charwaiting) {
X
X			/* open channel if it hasn't been done already */
X			if (kb_chan == 0)
X				opengetch();
X
X			/* que an i/o request for a character and wait */
X			rv = sys$qiow(0,kb_chan,FUNC,0,0,0,&kb_buf,1,0,0,0,0);
X
X			/* indicate if something is amiss */
X			if(rv != SS$_NORMAL) {
X				printf("?");
X				exit(rv);
X			}
X
X		} else { /* charwaiting */
X
X			kb_buf = ungotch;
X			charwaiting = FALSE;
X		}
X
X		/* massage for getchar() compatibility */
X		if (kb_buf == '\r') kb_buf='\n';
X
X		/* echo char if we're supposed to */
X		if (echo_status) putchar(kb_buf);
X
X		return(kb_buf);
X
X	} else	/* nocrmode */
X
X		return(getchar());
X
X}
END_OF_FILE
if test 4982 -ne `wc -c <'vms/getch.c'`; then
    echo shar: \"'vms/getch.c'\" unpacked with wrong size!
fi
# end of 'vms/getch.c'
fi
echo shar: End of archive 36 \(of 39\).
cp /dev/null ark36isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
