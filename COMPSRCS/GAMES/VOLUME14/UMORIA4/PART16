Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i048:  umoria4 - single player dungeon simulation (ver. 5.5), Part16/39
Message-ID: <3406@master.CNA.TEK.COM>
Date: 20 Aug 92 18:05:13 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2562
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 48
Archive-name: umoria4/Part16
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 16 (of 39)."
# Contents:  ibmpc/TERMCAP mac/mac.c source/constant.h
# Wrapped by billr@saab on Thu Aug 20 09:11:30 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ibmpc/TERMCAP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ibmpc/TERMCAP'\"
else
echo shar: Extracting \"'ibmpc/TERMCAP'\" \(1337 characters\)
sed "s/^X//" >'ibmpc/TERMCAP' <<'END_OF_FILE'
X# Termcap file for PC MORIA.  This file will only be necessary if you
X# are using the "ANSI" option in MORIA.CNF (see README for details).
X# For PCs, ATs and clones, there is no reason to use the "ANSI" option
X# and this file can be safely discarded.  For DEC Rainbow users, this
X# file is required.  It must be either in the current directory, in
X# directory \ETC, or somewhere on the PATH for MORIA to find it
X#
X# Monochrome IBMPC.
X#	This is a termcap for the NANSI.SYS device driver.
X#	It is the same as the ANSI termcap, except NANSI supports
X#	line insert (al) and delete (dl) while ANSI does not.
X#
Xibmpc-mono:\
X	:co#80:\
X	:li#24:\
X	:cl=\E[2J:\
X	:bs:\
X	:ho=\E[H:\
X	:cm=\E[%i%2;%2H:\
X	:up=\E[A:\
X	:do=\E[B:\
X	:nd=\E[C:\
X	:le=\E[D:\
X	:ce=\E[K:\
X	:ti=\E[m:\
X	:te=\E[m:\
X	:so=\E[1m:\
X	:se=\E[m:\
X	:us=\E[1m:\
X	:ue=\E[m:\
X	:al=\E[L:\
X	:dl=\E[M:
X#
X# Color IBMPC.
X#	This is a termcap for the NANSI.SYS device driver.
X#	It is the same as the ANSI termcap, except NANSI supports
X#	line insert (al) and delete (dl) while ANSI does not.
X#
X#	Gratiously supplied by Darren Friedlein.
X#
Xibmpc-color:\
X	:co#80:\
X	:li#24:\
X	:cl=\E[2J:\
X	:bs:\
X	:ho=\E[H:\
X	:cm=\E[%i%2;%2H:\
X	:up=\E[A:\
X	:do=\E[B:\
X	:nd=\E[C:\
X	:le=\E[D:\
X	:ce=\E[K:\
X	:ti=\E[44;37m\E1m:\
X	:te=\E[0m:\
X	:so=\E[31m:\
X	:se=\E[37m:\
X	:us=\E[33m:\
X	:ue=\E[37m:\
X	:al=\E[L:\
X	:dl=\E[M:
END_OF_FILE
if test 1337 -ne `wc -c <'ibmpc/TERMCAP'`; then
    echo shar: \"'ibmpc/TERMCAP'\" unpacked with wrong size!
fi
# end of 'ibmpc/TERMCAP'
fi
if test -f 'mac/mac.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/mac.c'\"
else
echo shar: Extracting \"'mac/mac.c'\" \(30757 characters\)
sed "s/^X//" >'mac/mac.c' <<'END_OF_FILE'
X/* mac/mac.c: mac support code
X
X   Copyright (c) 1989-1991 Curtis McCauley, James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#ifndef THINK_C
X#include <types.h>
X#include <controls.h>
X#include <dialogs.h>
X#include <memory.h>
X#include <resources.h>
X#include <files.h>
X#include <segload.h>
X#include <packages.h>
X#include <menus.h>
X#include <osutils.h>
X#include <sysequ.h>
X
X#include <scrnmgr.h>
X#include <dumpres.h>
X
X#else
X
X#include "ScrnMgr.h"
X#include "DumpRes.h"
X
X#define c2pstr(x)	(char *)CtoPstr((char *)x)
X#define p2cstr(x)	(char *)PtoCstr((char *)x)
X
X#endif
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#ifndef THINK_C
X#include <strings.h>
X#endif
X#include <setjmp.h>
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X#include "macrsrc.h"
X
Xlong GetCommandSet(Handle theData);
Xlong GetTextEditor(Handle theData);
X
Xvoid DoMacHelp(void), DoKillsDlg(void);
X
Xstatic long game_flag;
Xstatic long exit_code;
X
Xstatic short savedir, applvrefnum;
X
Xstatic char **save_chars, **save_attrs;
Xstatic long save_cursor_h, save_cursor_v;
X
X#define PATHLEN					256
X
X#define TAB_WIDTH				8
X
X#define CODE_IGNORE				0
X#define CODE_PASSTHRU			1
X#define CODE_KEYPAD				2
X#define CODE_ARROW				3
X#define CODE_ENTER				4
X
Xstatic unsigned char codetable[0x80] = {
X	/*				0	1	2	3	4	5	6	7	8	9	A	B	C	D	E	F	*/
X	/*				-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	-	*/
X	/* [00] */		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,
X	/* [10] */		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,
X	/* [20] */		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,
X	/* [30] */		0,	1,	1,	1,	1,	1,	1,	0,	0,	0,	0,	0,	0,	0,	0,	1,
X	/* [40] */		1,	1,	3,	1,	1,	1,	3,	1,	3,	1,	1,	1,	4,	3,	1,	1,
X	/* [50] */		1,	1,	1,	2,	2,	2,	2,	2,	2,	2,	1,	2,	2,	1,	1,	1,
X	/* [60] */		0,	0,	0,	0,	0,	0,	1,	0,	1,	0,	1,	0,	1,	0,	1,	0,
X	/* [70] */		1,	0,	0,	0,	0,	0,	0,	0,	0,	0,	0,	3,	3,	3,	3,	1
X};
X
X#define ARROW_UP_1				0x4D
X#define ARROW_DOWN_1			0x48
X#define ARROW_LEFT_1			0x46
X#define ARROW_RIGHT_1			0x42
X
X#define ARROW_UP_2				0x7E
X#define ARROW_DOWN_2			0x7D
X#define ARROW_LEFT_2			0x7B
X#define ARROW_RIGHT_2			0x7C
X
X#define CMDSET_TYPE				'CNFG'
X#define CMDSET_ID				256
X
X#define TE_TYPE					'CNFG'
X#define TE_ID					257
X
X#define SPIN_TICKS				15
X
Xstatic long editor, cmdsetopt;
X
Xstatic jmp_buf jb;
X
X#define ABOUT_DLOG_ID			128
X
X#define FM_NEW					1
X#define FM_OPEN					2
X#define FM_SAVE					4
X#define FM_SAVE_AS				5
X#define FM_QUIT					7
X
X#define AM_HELP					1
X#define AM_CMD_SET				2
X#define AM_TEXT_ED				3
X#define AM_SCORES				5
X
X#define KEY_UNKNOWN				0xFF
X#define KEY_DIR					0x90
X#define KEY_DIR_SHIFT			0xA0
X#define KEY_DIR_CONTROL			0xB0
X
X#define NEXT_FINDER				1
X#define NEXT_NEW				2
X#define NEXT_OPEN				3
X#define NEXT_WAIT				4
X#define NEXT_QUIT				5
X
Xlong savefileset;
Xchar savefilename[64];
Xshort savefilevol;
X
X#define sqc_dlg_id				258
X#define sqc_save_item			1
X#define sqc_quit_item			2
X#define sqc_cancel_item			3
X#define sqc_defbrd_item			4
X
X#define code_enter				0x03
X#define code_return				0x0D
X
X#define errAlrtID				1024
X
Xstatic short sqcdefault_item;
Xstatic Handle sqcdefault_handle;
X
Xstatic long save_cmd_level, file_menu_level, app_menu_level;
Xstatic long save_cmd_enabled, file_menu_enabled, app_menu_enabled;
X
X#if 0
X/* this stuff is no longer used */
X
X#define malloc_zone_size		0x1000
X
Xstatic THz malloc_zone;
X
Xvoid init_malloc_zone()
X
X{
X	THz theOldZone;
X
X	theOldZone = GetZone();
X
X	InitZone(NULL, 64, (Ptr)((long) malloc_zone + malloc_zone_size),
X		 (Ptr) malloc_zone);
X
X	SetZone(theOldZone);
X
X	return;
X}
X
Xvoid *mac_malloc(n)
Xunsigned n;
X
X{
X	THz theOldZone;
X	void *theNewPtr;
X
X	theOldZone = GetZone();
X	SetZone(malloc_zone);
X
X	theNewPtr = (void *) NewPtrClear((Size) n);
X
X	SetZone(theOldZone);
X
X	return(theNewPtr);
X}
X
Xvoid mac_free(p)
Xvoid *p;
X
X{
X#if 0
X	THz theOldZone;
X
X	theOldZone = GetZone();
X	SetZone(malloc_zone);
X
X	DisposPtr((Ptr) p);
X
X	SetZone(theOldZone);
X#else
X#pragma unused(p)
X#endif
X
X	return;
X}
X
X#endif
X
Xlong mac_time()
X
X{
X	long now;
X
X	GetDateTime((unsigned long *) &now);
X	return(now);
X}
X
Xvoid alert_error(message)
Xchar *message;
X
X{
X	Str255 pstr;
X
X	strncpy((char *)pstr, message, 255);
X	pstr[255] = '\0';
X	(void) c2pstr(pstr);
X
X	ParamText(pstr, NULL, NULL, NULL);
X
X	DoScreenALRT(errAlrtID, akStop, fixHalf, fixHalf);
X
X	return;
X}
X
Xvoid fatal_error(message)
Xchar *message;
X
X{
X	alert_error(message);
X	exit(0);
X}
X
Xchar *truncstr(pstr, wid)
Xchar *pstr;
Xshort wid;
X
X{
X	unsigned char len;
X
X	if (StringWidth(pstr) > wid) {
X		len = (unsigned char) pstr[0];
X		if (len > 0) pstr[len] = '\311';
X		while ( (len > 1) && (StringWidth(pstr) > wid) ) {
X			pstr[0] = (char) --len;
X			pstr[len] = '\311';
X		}
X	}
X
X	return(pstr);
X}
X
Xvoid idle()
X
X{
X	long redraw;
X
X	redraw = FALSE;
X
X	if ((!save_cmd_enabled) && (save_cmd_level > 0)) {
X		EnableItem((MenuHandle) GetFileMHandle(), FM_SAVE);
X		EnableItem((MenuHandle) GetFileMHandle(), FM_SAVE_AS);
X		save_cmd_enabled = TRUE;
X	}
X	else if ((save_cmd_enabled) && (save_cmd_level <= 0)) {
X		DisableItem((MenuHandle) GetFileMHandle(), FM_SAVE);
X		DisableItem((MenuHandle) GetFileMHandle(), FM_SAVE_AS);
X		save_cmd_enabled = FALSE;
X	}
X
X	if ((!file_menu_enabled) && (file_menu_level > 0)) {
X		EnableItem((MenuHandle) GetFileMHandle(), 0);
X		file_menu_enabled = TRUE;
X		redraw = TRUE;
X	}
X	else if ((file_menu_enabled) && (file_menu_level <= 0)) {
X		DisableItem((MenuHandle) GetFileMHandle(), 0);
X		file_menu_enabled = FALSE;
X		redraw = TRUE;
X	}
X
X	if ((!app_menu_enabled) && (app_menu_level > 0)) {
X		EnableItem((MenuHandle) GetAppMHandle(), 0);
X		app_menu_enabled = TRUE;
X		redraw = TRUE;
X	}
X	else if ((app_menu_enabled) && (app_menu_level <= 0)) {
X		DisableItem((MenuHandle) GetAppMHandle(), 0);
X		app_menu_enabled = FALSE;
X		redraw = TRUE;
X	}
X
X	if (redraw)
X		DrawMenuBar();
X
X	IdleScreenMgr();
X}
X
Xint macgetkey(ch, nowait)
Xchar *ch;
Xint nowait;
X
X{
X	char keycode, modifiers, ascii;
X	short h, v;
X
X	do {
X
X		if (nowait) {
X			idle();
X			if (!GetScreenKeys(&keycode, &modifiers, &ascii, &h, &v))
X				return(FALSE);
X		}
X		else {
X			do {
X				idle();
X			} while (!GetScreenKeys(&keycode, &modifiers, &ascii, &h, &v));
X		}
X
X	} while ( (modifiers & maskModMouse) ||
X			  (codetable[keycode] == CODE_IGNORE) );
X
X	if (ascii > 0x7F) ascii = KEY_UNKNOWN;
X
X	switch (codetable[keycode]) {
X
X		case CODE_KEYPAD:
X			if ((ascii >= '1') && (ascii <= '9')) {
X				ascii -= '0';
X				if (modifiers & maskModControl)
X					ascii += KEY_DIR_CONTROL;
X				else if (modifiers & maskModShift)
X					ascii += KEY_DIR_SHIFT;
X				else
X					ascii += KEY_DIR;
X			}
X			break;
X
X		case CODE_ARROW:
X			switch (keycode) {
X				case ARROW_UP_1: case ARROW_UP_2:
X					ascii = 8;
X					break;
X				case ARROW_DOWN_1: case ARROW_DOWN_2:
X					ascii = 2;
X					break;
X				case ARROW_LEFT_1: case ARROW_LEFT_2:
X					ascii = 4;
X					break;
X				case ARROW_RIGHT_1: case ARROW_RIGHT_2:
X					ascii = 6;
X					break;
X				default:
X					ascii = 5;
X					break;
X			}
X			if (modifiers & maskModControl)
X				ascii += KEY_DIR_CONTROL;
X			else if (modifiers & maskModShift)
X				ascii += KEY_DIR_SHIFT;
X			else
X				ascii += KEY_DIR;
X			break;
X
X		case CODE_ENTER:
X			ascii = '\r';
X			break;
X
X	}
X
X	if (ch != NULL) *ch = ascii;
X
X	return(TRUE);
X}
X
Xint extractdir(ch, shift_flag, ctrl_flag)
Xchar ch;
Xint *shift_flag;
Xint *ctrl_flag;
X
X{
X	long rc;
X
X	if ((ch & 0xF0) == KEY_DIR) {
X		*shift_flag = FALSE;
X		*ctrl_flag = FALSE;
X		rc = ch & 0x0F;
X	}
X	else if ((ch & 0xF0) == KEY_DIR_SHIFT) {
X		*shift_flag = TRUE;
X		*ctrl_flag = FALSE;
X		rc = ch & 0x0F;
X	}
X	else if ((ch & 0xF0) == KEY_DIR_CONTROL) {
X		*shift_flag = FALSE;
X		*ctrl_flag = TRUE;
X		rc = ch & 0x0F;
X	}
X	else
X		rc = -1;
X
X	return(rc);
X}
X
Xvoid mac_save_screen()
X
X{
X	Rect screen;
X
X	screen.left = screen.top = 0;
X	screen.right = SCRN_COLS;
X	screen.bottom = SCRN_ROWS;
X
X	HLock((Handle) save_chars);
X	HLock((Handle) save_attrs);
X
X	GetScreenImage(*save_chars, *save_attrs, SCRN_COLS, &screen, 0, 0);
X	GetScreenCursor(&save_cursor_h, &save_cursor_v);
X
X	HUnlock((Handle) save_chars);
X	HUnlock((Handle) save_attrs);
X
X	return;
X}
X
X/* This restore routine only touches as much of the screen as necessary. */
X
Xvoid mac_restore_screen()
X
X{
X	Rect screen;
X	long v;
X	char chars[SCRN_COLS], attrs[SCRN_COLS];
X	char *c, *a, *c1, *c2, *a1, *a2;
X
X	HLock((Handle) save_chars);
X	HLock((Handle) save_attrs);
X
X	c = *save_chars;
X	a = *save_attrs;
X
X	screen.top = 0;
X	screen.bottom = 1;
X
X	for (v = 0; v < SCRN_ROWS; v++) {
X
X		screen.left = 0;
X		screen.right = SCRN_COLS;
X
X		GetScreenImage(chars, attrs, SCRN_COLS, &screen, 0, v);
X
X		c1 = chars;
X		c2 = c;
X
X		a1 = attrs;
X		a2 = a;
X
X		while (screen.left < SCRN_COLS) {
X			if (*c1++ != *c2++) break;
X			if (*a1++ != *a2++) break;
X			++screen.left;
X		}
X
X		c1 = chars + SCRN_COLS;
X		c2 = c + SCRN_COLS;
X
X		a1 = attrs + SCRN_COLS;
X		a2 = a + SCRN_COLS;
X
X		while (screen.right > screen.left) {
X			if (*--c1 != *--c2) break;
X			if (*--a1 != *--a2) break;
X			--screen.right;
X		}
X
X		if (screen.right > screen.left)
X			DSetScreenImage(c, a, SCRN_COLS, &screen, screen.left, v);
X
X		c += SCRN_COLS;
X		a += SCRN_COLS;
X
X	}
X
X	DSetScreenCursor(save_cursor_h, save_cursor_v);
X
X	HUnlock((Handle) save_chars);
X	HUnlock((Handle) save_attrs);
X
X	return;
X}
X
Xvoid mac_beep()
X
X{
X	SysBeep(15);
X	return;
X}
X
Xvoid macbeginwait()
X
X{
X	BeginScreenWait(SPIN_TICKS);
X	return;
X}
X
Xvoid macendwait()
X
X{
X	EndScreenWait();
X	return;
X}
X
XOSErr GetDirID(wdVRefNum, vRefNum, dirID)
Xshort wdVRefNum;
Xshort *vRefNum;
Xlong *dirID;
X
X{
X	OSErr err;
X	WDPBRec wdpb;
X
X	wdpb.ioNamePtr = NULL;
X	wdpb.ioVRefNum = wdVRefNum;
X	wdpb.ioWDIndex = 0;
X	wdpb.ioWDProcID = 0;
X	wdpb.ioWDVRefNum = 0;
X	err = PBGetWDInfo(&wdpb, false);
X
X	if (!err) {
X		*vRefNum = wdpb.ioWDVRefNum;
X		*dirID = wdpb.ioWDDirID;
X	}
X
X	return(err);
X}
X
XOSErr MakePath(vRefNum, dirID, fName, pathName)
Xshort vRefNum;
Xlong dirID;
Xchar *fName;
Xchar *pathName;
X
X{
X	char buf[PATHLEN], *bufptr;
X	long len;
X	OSErr err;
X	Str255 vNameBuf;
X	CInfoPBRec cipb;
X
X	bufptr = buf + PATHLEN;
X
X	*--bufptr = '\0';
X
X	if (fName != NULL) {
X		len = strlen(fName);
X		strncpy(bufptr -= len, fName, len);
X	}
X
X	cipb.dirInfo.ioNamePtr = vNameBuf;
X	cipb.dirInfo.ioVRefNum = vRefNum;
X	cipb.dirInfo.ioFDirIndex = -1;
X
X	do {
X		cipb.dirInfo.ioDrDirID = dirID;
X		err = PBGetCatInfo(&cipb, false);
X		if (!err) {
X			*--bufptr = ':';
X			len = strlen(p2cstr(vNameBuf));
X			strncpy(bufptr -= len, (char *)vNameBuf, len);
X			dirID = cipb.dirInfo.ioDrParID;
X		}
X	} while ( (!err) && (dirID != fsRtParID) );
X
X	strcpy(pathName, bufptr);
X
X	return(err);
X}
X
Xvoid checkdebugger()
X
X{
X#ifndef THINK_C
X#if 1
X	char keys[128];
X
X	GetKeys ((KeyMap *) &keys);
X	if (keys[4] & 0x80) Debugger();		/* if command key is down */
X#else
X	if (((char *) KeyMapLM)[6] & 0x80) Debugger();			/* if command key is down */
X#endif
X#endif
X
X	return;
X}
X
Xstatic void getstack(request)
Xlong request;
X
X{
X	long cursize;
X#ifdef THINK_C
X	Ptr newlimit;
X#else
X	long newlimit;
X#endif
X
X	/* An extra level of indirection is apparently needed by MPW C
X	   for accessing system globals.  */
X#ifdef THINK_C
X	cursize = (((long *) CurStackBase) - ((long *) ApplLimit)) - 8;
X	if (cursize < request) {
X		newlimit = (Ptr)(((long *) CurStackBase - request) - 8);
X		if (newlimit > HeapEnd)
X			ApplLimit = newlimit;
X	}
X#else
X	cursize = (*((int *) CurStackBase) - *((int *) ApplLimit)) - 8;
X	if (cursize < request) {
X		newlimit = (*((int *) CurStackBase) - request) - 8;
X		if (newlimit > *((int *) HeapEnd)) *((int *) ApplLimit) = newlimit;
X	}
X#endif
X
X	return;
X}
X
Xvoid sfposition(vrefnum)
Xshort vrefnum;
X
X{
X	short v;
X	long d;
X
X	GetDirID(vrefnum, &v, &d);
X#ifdef THINK_C
X	SFSaveDisk = -v;
X	CurDirStore = d;
X#else
X	*((short *) SFSaveDisk) = -v;
X	*((int *) CurDirStore) = d;
X#endif
X
X	return;
X}
X
Xlong doputfile(prompt, fname, vrefnum)
Xchar *prompt;
Xchar *fname;
Xshort *vrefnum;
X
X{
X	char p[256], f[256];
X	SFReply reply;
X	Point loc;
X	long h, v;
X
X	CenterScreenDLOG(putDlgID, fixHalf, fixThird, &h, &v);
X
X	loc.h = (short) h;
X	loc.v = (short) v;
X
X	strncpy(p, prompt, 255);
X	strncpy(f, fname, 255);
X	p[255] = '\0';
X	f[255] = '\0';
X	c2pstr(p);
X	c2pstr(f);
X
X	SFPutFile(loc, p, f, NULL, &reply);
X
X	if (reply.good) {
X		p2cstr(reply.fName);
X		strcpy(fname, (char *)reply.fName);
X		*vrefnum = reply.vRefNum;
X	}
X
X	return(reply.good);
X}
X
Xint asksavegame(ask)
Xint ask;
X
X{
X	int rc;
X
X	if (!ask && savefileset)
X		rc = TRUE;
X
X	else {
X		rc = doputfile("Save game as:", savefilename, &savefilevol);
X		if (rc) savefileset = TRUE;
X	}
X
X	return(rc);
X}
X
Xstatic pascal Boolean savefilefilter(pb)
XParmBlkPtr pb;
X
X{
X	OSType fdtype, fdcreator;
X
X	fdtype = pb->fileParam.ioFlFndrInfo.fdType;
X	fdcreator = pb->fileParam.ioFlFndrInfo.fdCreator;
X
X	return(!((fdcreator == MORIA_FCREATOR) && (fdtype == SAVE_FTYPE)));
X}
X
Xint dogetfile(fname, vrefnum)
Xchar *fname;
Xshort *vrefnum;
X
X{
X	SFTypeList types;
X	SFReply reply;
X	Point loc;
X	long h, v;
X
X	CenterScreenDLOG(getDlgID, fixHalf, fixThird, &h, &v);
X
X	loc.h = (short) h;
X	loc.v = (short) v;
X
X	types[0] = SAVE_FTYPE;
X
X	SFGetFile(loc, NULL, savefilefilter, 1, types, NULL, &reply);
X
X	if (reply.good) {
X		p2cstr(reply.fName);
X		strcpy(fname, (char *)reply.fName);
X		*vrefnum = reply.vRefNum;
X	}
X
X	return(reply.good);
X}
X
Xstatic pascal Boolean sqcfilter(dlg, evt, item)
XDialogPtr dlg;
XEventRecord *evt;
Xshort *item;
X
X{
X#pragma unused(dlg)
X	Boolean rc;
X	char key;
X
X	rc = FALSE;
X
X	if (evt->what == keyDown) {
X		key = evt->message & charCodeMask;
X		if ( (key == code_enter) || (key == code_return) ) {
X			rc = TRUE;
X			HiliteControl((ControlHandle) sqcdefault_handle, inButton);
X			*item = sqcdefault_item;
X		}
X	}
X
X	return(rc);
X}
X
Xshort currentdirectory()
X
X{
X	short vrefnum;
X
X	(void) GetVol(NULL, &vrefnum);
X	return(vrefnum);
X}
X
Xvoid changedirectory(vrefnum)
Xshort vrefnum;
X
X{
X	(void) GetVol(NULL, &savedir);
X	(void) SetVol(NULL, vrefnum);
X	return;
X}
X
Xvoid appldirectory()
X
X{
X	(void) GetVol(NULL, &savedir);
X	(void) SetVol(NULL, applvrefnum);
X	return;
X}
X
Xvoid restoredirectory()
X
X{
X	(void) SetVol(NULL, savedir);
X	return;
X}
X
Xvoid mac_helpfile(filename, wait)
Xchar *filename;
Xint wait;
X
X{
X	Str255 temp, temp2;	/* Buffer for line and tab-expanded line.  */
X	short apRefNum;
X	Handle apParam;
X	FILE *file;
X	int i, j, done;
X	char ch;
X	char *cp;		/* Source for tab expansion.  */
X	Rect area;
X
X	GetAppParms(temp, &apRefNum, &apParam);
X
X	appldirectory();
X	/* Ordinarily, the misc files are stored in the data fork of
X	   the application.  */
X#if 1
X	file = fopen(p2cstr(temp), "r");
X#else
X	file = fopen("MacMoria.files", "r");
X#endif
X	restoredirectory();
X
X	if (file != NULL) {
X
X		while (!feof(file))
X			if (fgets ((char *)temp, 255, file) != NULL)
X				if (temp[0] == '#')
X					if (strstr((char *)temp, filename) != NULL)
X						break;
X
X		if (feof(file)) {
X			(void) fclose(file);
X			file = NULL;
X		}
X
X	}
X
X	if (file == NULL) {
X		sprintf((char *)temp, "Cannot find text file: %s", filename);
X		alert_error(temp);
X	}
X
X	else {
X
X		area.left = area.top = 0;
X		area.right = SCRN_COLS;
X		area.bottom = SCRN_ROWS;
X
X		if (wait)
X			mac_save_screen();
X
X		done = FALSE;
X
X		while ((!done) && (!feof(file))) {
X			DEraseScreen(&area);
X			for (i = 0; (!done) && (i < SCRN_ROWS - 1); i++)
X				if ((fgets((char *)temp, 255, file) != NULL) && (temp[0] != '#')) {
X					/* Remove the trailing \n and
X					   expand tabs.  */
X				  	for (cp = (char *) temp, j = 0;
X					     *cp != '\n'; cp++)
X					  {
X					    if ((temp2[j] = *cp) == '\t')
X					      {
X						do
X						  {
X						    temp2[j++] = ' ';
X						  }
X						while (j % TAB_WIDTH != 0);
X					      }
X					    else
X					      j++;
X					  }
X					temp2[j] = '\0';
X					DSetScreenString((char *)temp2, 0, i);
X					}
X				else
X					done = TRUE;
X			if (wait) {
X				DSetScreenCursor(20, SCRN_ROWS - 1);
X				DWriteScreenString(
X					done ?
X						"[Press any key to continue.]" :
X						"[Press any key for next page or ESC to abort.]");
X				macgetkey(&ch, FALSE);
X				if (ch == ESCAPE)
X					done = TRUE;
X			}
X		}
X
X		if (wait)
X			mac_restore_screen();
X
X		fclose(file);
X
X	}
X
X	return;
X}
X
Xchar *nextstring(loc)
Xchar **loc;
X
X{
X	char *str;
X	unsigned char len;
X
X	len = *((unsigned char *) (*loc));
X	str = p2cstr(*loc);
X	*loc += len + 1;
X
X	return(str);
X}
X
X#if 0
X/* no longer used */
Xlong allocmalloczone(restart)
Xlong restart;
X
X{
X	long rc;
X
X	if (!restart) {
X		malloc_zone = (THz) NewPtr(malloc_zone_size);
X		rc = malloc_zone != NULL;
X	}
X	else
X		rc = TRUE;
X
X	if (rc && !restart)
X		init_malloc_zone();
X
X	return(rc);
X}
X#endif
X
Xint allocsavearea(restart)
Xint restart;
X
X{
X	int rc;
X
X	if (!restart) {
X		save_chars = (char **) NewHandle(SCRN_ROWS * SCRN_COLS);
X		save_attrs = (char **) NewHandle(SCRN_ROWS * SCRN_COLS);
X		rc = (save_chars != NULL) && (save_attrs != NULL);
X	}
X	else
X		rc = TRUE;
X
X	return(rc);
X}
X
Xint setupmem(restart)
Xint restart;
X
X{
X	int i;
X	memtable_type *m;
X
X	for (i = 0, m = memtable; i < MAX_PTRS; i++, m++) {
X
X		if (!restart) {
X			*m->memPtr = (char *) NewPtrClear(m->elemCnt * m->elemSiz);
X			if (*m->memPtr == NULL) return(FALSE);
X		}
X
X		else if (m->restartFlag) {
X			memset(*m->memPtr, 0, m->elemCnt * m->elemSiz);
X		}
X
X	}
X
X	return(TRUE);
X}
X
Xint getresources(restart)
Xint restart;
X
X{
X	int i, rc;
X	restable_type *r;
X
X	for (i = 0, r = restable; i < MAX_RESOURCES; i++, r++) {
X
X		if (!restart) *r->memPtr = NULL;
X
X		if ( (!restart) || (r->restartFlag) ) {
X
X			rc = LoadRes(
X				r->memPtr,
X				r->resType, r->resID,
X				r->elemCnt, r->elemSiz,
X				r->strProc);
X
X			if (!rc) return(FALSE);
X
X		}
X
X	}
X
X	return(TRUE);
X}
X
Xint getrestart(restart)
Xint restart;
X
X{
X	int i, rc;
X	unsigned size;
X	char *p, *q;
X
X	if (restart) {
X
X		size = 0;
X		for (i = 0; i < MAX_RESTART; i++) size += restart_vars[i].size;
X
X		p = NULL;
X
X		rc = LoadRes(
X			&p,
X			restartRsrc, restart_id,
X			1, size,
X			NULL);
X
X		if (!rc) return(FALSE);
X
X		q = p;
X		for (i = 0; i < MAX_RESTART; i++) {
X			BlockMove(q, restart_vars[i].ptr, restart_vars[i].size);
X			q += restart_vars[i].size;
X		}
X
X		DisposPtr(p);
X
X	}
X
X	return(TRUE);
X}
X
Xint clearvars(restart)
Xint restart;
X
X{
X	int i;
X	clrtable_type *c;
X
X	if (restart)
X		for (i = 0, c = clrtable; i < MAX_CLRS; i++, c++)
X			memset(c->ptr, 0, c->size);
X
X	return(TRUE);
X}
X
X#ifndef THINK_C
Xunsigned sleep(time)
Xunsigned time;
X
X{
X#pragma unused(time)
X	idle();
X	return(0);
X}
X#endif
X
Xchar *makefilename(buffer, suffix, append)
Xchar *buffer, *suffix;
Xint append;
X
X
X{
X	long len;
X	char *p;
X
X	len = strlen(py.misc.name) + ((append) ? strlen(suffix)+3 : 0);
X
X	if ( (strlen(py.misc.name) == 0) || (len > 31) )
X		strcpy(buffer, suffix);
X
X	else {
X		strcpy(buffer, py.misc.name);
X		if (append) {
X			strcat(buffer, "'s ");
X			strcat(buffer, suffix);
X		}
X		for (p = buffer; *p; p++)
X			if (*p == ':') *p = '.';
X	}
X
X	return(buffer);
X}
X
Xvoid initsavedefaults()
X
X{
X	savefileset = FALSE;
X
X	(void) makefilename(savefilename, "Save File", FALSE);
X	savefilevol = currentdirectory();
X
X	return;
X}
X
Xvoid setsavedefaults(name, vol)
Xchar *name;
Xshort vol;
X
X{
X	savefileset = TRUE;
X
X	strncpy(savefilename, name, 63);
X	savefilename[63] = '\0';
X
X	savefilevol = vol;
X
X	return;
X}
X
Xint getsavedefaults(name, vol)
Xchar *name;
Xshort *vol;
X
X{
X	strcpy(name, savefilename);
X	*vol = savefilevol;
X
X	return(savefileset);
X}
X
Xint getfinderfile()
X
X{
X	short message, count, i;
X	AppFile appfile;
X
X	CountAppFiles(&message, &count);
X
X	for (i = 1; i <= count; i++) {
X		GetAppFiles(i, &appfile);
X		if (appfile.fType == SAVE_FTYPE) break;
X	}
X
X	if (i <= count) {
X		setsavedefaults(p2cstr(appfile.fName), appfile.vRefNum);
X	}
X
X	return(i <= count);
X}
X
Xlong setfileinfo(fname, vrefnum, ftype)
Xchar *fname;
Xshort vrefnum;
Xlong ftype;
X
X{
X	long fcreator;
X	char temp[64];
X	FileParam pb;
X	OSErr err;
X
X	fcreator = (ftype != INFO_FTYPE) ? MORIA_FCREATOR : editor;
X
X	strcpy(temp, fname);
X	(void) c2pstr(temp);
X
X	pb.ioCompletion = NULL;
X	pb.ioNamePtr = (unsigned char *)temp;
X	pb.ioVRefNum = vrefnum;
X	pb.ioFVersNum = 0;
X	pb.ioFDirIndex = 0;
X
X	err = PBGetFInfo((ParmBlkPtr) &pb, FALSE);
X
X	if (err == noErr) {
X		pb.ioFlFndrInfo.fdType = ftype;
X		pb.ioFlFndrInfo.fdCreator = fcreator;
X		err = PBSetFInfo((ParmBlkPtr) &pb, FALSE);
X	}
X
X	return(err == noErr);
X}
X
X#if 0
Xlong getfileage(fname, vrefnum)
Xchar *fname;
Xshort vrefnum;
X
X{
X	char temp[64];
X	FileParam pb;
X	OSErr err;
X	long age;
X
X	strcpy(temp, fname);
X	(void) c2pstr(temp);
X
X	pb.ioCompletion = NULL;
X	pb.ioNamePtr = temp;
X	pb.ioVRefNum = vrefnum;
X	pb.ioFVersNum = 0;
X	pb.ioFDirIndex = 0;
X
X	err = PBGetFInfo((ParmBlkPtr) &pb, FALSE);
X
X	if (err == noErr) {
X		GetDateTime((unsigned long *) &age);
X		age -= pb.ioFlMdDat;
X	}
X	else
X		age = 0;
X
X	return(age);
X}
X#endif
X
Xvoid benediction()
X
X{
X	Rect scrn;
X
X	scrn.left = 0;
X	scrn.top = SCRN_ROWS-1;
X	scrn.right = SCRN_COLS;
X	scrn.bottom = SCRN_ROWS;
X
X	EraseScreen(&scrn);
X
X	SetScreenCursor(0, SCRN_ROWS-1);
X	WriteScreenString("Please select a command from the file menu...");
X
X	return;
X}
X
Xvoid setsavecmdstatus(val, init)
Xint val, init;
X
X{
X	save_cmd_level = val;
X
X	if (init)
X		save_cmd_enabled = val > 0;
X
X	return;
X}
X
Xvoid enablesavecmd(flag)
Xint flag;
X
X{
X	save_cmd_level += flag ? 1 : -1;
X	return;
X}
X
Xvoid setfilemenustatus(val, init)
Xint val, init;
X
X{
X	file_menu_level = val;
X
X	if (init)
X		file_menu_enabled = val > 0;
X
X	return;
X}
X
Xvoid enablefilemenu(flag)
Xint flag;
X
X{
X	file_menu_level += flag ? 1 : -1;
X	return;
X}
X
Xvoid setappmenustatus(val, init)
Xint val, init;
X
X{
X	app_menu_level = val;
X
X	if (init)
X		app_menu_enabled = val > 0;
X
X	return;
X}
X
Xvoid enableappmenu(flag)
Xint flag;
X
X{
X	app_menu_level += flag ? 1 : -1;
X	return;
X}
X
Xvoid savequitorcancel(next)
Xint next;
X
X{
X	DialogPtr thedialog;
X	short itemhit;
X	short itstype;
X	Rect itsrect;
X	long h, v;
X	long saveOk, dialogFinished;
X
X	thedialog = GetNewDialog(sqc_dlg_id, nil, (WindowPtr) -1);
X
X	CenterScreenDLOG(sqc_dlg_id, fixHalf, fixThird, &h, &v);
X	MoveWindow((WindowPtr) thedialog, (short) h, (short) v, false);
X
X	if ((save_cmd_level > 0) && !total_winner) {
X		sqcdefault_item = sqc_save_item;
X		saveOk = true;
X	}
X	else {
X		sqcdefault_item = sqc_quit_item;
X		saveOk = false;
X	}
X
X	GetDItem(thedialog, sqcdefault_item, &itstype, &sqcdefault_handle, &itsrect);
X	InsetRect(&itsrect, -4, -4);
X
X	SetDItem(thedialog, sqc_defbrd_item, userItem,
X		 (Handle) DrawDefaultBorder, &itsrect);
X
X	ShowWindow((WindowPtr) thedialog);
X
X	do {
X		ModalDialog(sqcfilter, &itemhit);
X		if ( (!saveOk) && (itemhit == sqc_save_item) ) {
X			if (total_winner)
X				alert_error("Sorry.  Since you are a total \
Xwinner, you cannot save this game.  Your character must be retired.");
X			else
X				alert_error("Sorry.  You cannot save at this \
Xpoint in the game.  It must be your turn to move in order to save.");
X			dialogFinished = false;
X		}
X		else
X			dialogFinished = (itemhit == sqc_save_item) ||
X						(itemhit == sqc_quit_item) ||
X						(itemhit == sqc_cancel_item);
X	} while (!dialogFinished);
X
X	DisposDialog(thedialog);
X
X	switch (itemhit) {
X
X		case sqc_save_item:
X			if (asksavegame(FALSE)) {
X				HiliteMenu(0);
X				(void) strcpy (died_from, "(saved)");
X				exit_code = next;
X				if (save_char(FALSE))
X					exit_game();
X				/* Should only get here if save_char fails */
X				UnloadSeg(save_char);
X				UnloadSeg(exit_game);
X				exit_code = NEXT_WAIT;
X				(void) strcpy (died_from, "(alive and well)");
X			}
X			break;
X
X		case sqc_quit_item:
X			HiliteMenu(0);
X			death = TRUE;
X			(void) strcpy(died_from, "Quitting.");
X			exit_code = next;
X			exit_game();
X			/* Should never get here */
X			UnloadSeg(exit_game);
X			exit_code = NEXT_WAIT;
X			(void) strcpy (died_from, "(alive and well)");
X			death = FALSE;
X			break;
X
X		default:
X			HiliteMenu(0);
X			break;
X
X	}
X
X	return;
X}
X
Xvoid loaddata(restart)
Xint restart;
X{
X	if (
X#if 0
X	    		(!allocmalloczone(restart))	||
X#endif
X			(!allocsavearea(restart))	||
X			(!setupmem(restart))		||
X			(!getresources(restart))	||
X			(!getrestart(restart))		||
X			(!clearvars(restart))			)
X
X				fatal_error("Insufficient memory to play Moria.  Sorry.");
X
X	return;
X}
X
Xvoid goback()
X
X{
X	longjmp(jb, exit_code);
X}
X
Xint startfinder()
X
X{
X	int next;
X	int argc;
X	long local_cmdsetopt;
X	char *argv[2];
X
X	if ((next = setjmp(jb)) != 0) return(next);
X
X	clear_screen();
X
X	local_cmdsetopt = cmdsetopt;
X
X	argc = 0;
X	argv[argc++] = NULL;
X	argv[argc++] = (char *) &local_cmdsetopt;
X
X	game_flag = TRUE;
X	exit_code = NEXT_WAIT;
X
X	moria_main(argc, argv);
X
X	/* should never get here */
X	return(NEXT_WAIT);
X}
X
Xint startnew()
X
X{
X	int next;
X	int argc;
X	long local_cmdsetopt, local_newgameopt;
X	char *argv[3];
X
X	if ((next = setjmp(jb)) != 0) return(next);
X
X	clear_screen();
X
X	local_cmdsetopt = cmdsetopt;
X	local_newgameopt = '-n\0\0';
X
X	argc = 0;
X	argv[argc++] = NULL;
X	argv[argc++] = (char *) &local_cmdsetopt;
X	argv[argc++] = (char *) &local_newgameopt;
X
X	game_flag = TRUE;
X	exit_code = NEXT_WAIT;
X
X	moria_main(argc, argv);
X
X	/* should never get here */
X	return(NEXT_WAIT);
X}
X
Xint startopen()
X
X{
X	int next;
X	int argc;
X	long local_cmdsetopt;
X	char *argv[2];
X
X	if ((next = setjmp(jb)) != 0) return(next);
X
X	clear_screen();
X
X	if (dogetfile(savefilename, &savefilevol)) {
X
X		savefileset = TRUE;
X
X		local_cmdsetopt = cmdsetopt;
X
X		argc = 0;
X		argv[argc++] = NULL;
X		argv[argc++] = (char *) &local_cmdsetopt;
X
X		game_flag = TRUE;
X		exit_code = NEXT_WAIT;
X
X		moria_main(argc, argv);
X
X	}
X
X	/* should not get here unless user cancels standard file dialog */
X	return(NEXT_WAIT);
X}
X
Xint waitforchoice()
X
X{
X	int next;
X
X	if ((next = setjmp(jb)) != 0) return(next);
X
X	game_flag = FALSE;
X
X	benediction();
X
X	do {
X		idle();
X	} while(TRUE);
X
X	return(NEXT_WAIT);
X}
X
Xvoid dofmnew()
X
X{
X	if (game_flag && character_generated)
X		savequitorcancel(NEXT_NEW);
X
X	else {
X		HiliteMenu(0);
X		exit_code = NEXT_NEW;
X		goback();
X	}
X
X	return;
X}
X
Xvoid dofmopen()
X
X{
X	if (game_flag && character_generated)
X		savequitorcancel(NEXT_OPEN);
X
X	else {
X		HiliteMenu(0);
X		exit_code = NEXT_OPEN;
X		goback();
X	}
X
X	return;
X}
X
Xvoid dofmsave(ask)
Xint ask;
X
X{
X	if (game_flag && character_generated && total_winner) {
X		alert_error("Sorry.  Since you are a total winner, you cannot\
X save this game.  Your character must be retired.");
X		HiliteMenu(0);
X	}
X	else if (game_flag && character_generated && asksavegame(ask)) {
X		HiliteMenu(0);
X		(void) strcpy (died_from, "(saved)");
X		if (save_char(FALSE))
X			exit_game();
X		/* Should only get here if save_char fails */
X		UnloadSeg(save_char);
X		UnloadSeg(exit_game);
X		(void) strcpy (died_from, "(alive and well)");
X	}
X	else
X		HiliteMenu(0);
X
X	return;
X}
X
Xvoid dofmquit()
X
X{
X	if (game_flag && character_generated)
X		savequitorcancel(NEXT_QUIT);
X
X	else {
X		HiliteMenu(0);
X		exit_code = NEXT_QUIT;
X		goback();
X	}
X
X	return;
X}
X
Xvoid dofilemenu(item)
Xlong item;
X
X{
X	switch (item) {
X
X		case FM_NEW:		dofmnew();
X							break;
X
X		case FM_OPEN:		dofmopen();
X							break;
X
X		case FM_SAVE:		dofmsave(FALSE);
X							break;
X
X		case FM_SAVE_AS:	dofmsave(TRUE);
X							break;
X
X		case FM_QUIT:		dofmquit();
X							break;
X
X		case closeBoxItem:	if (file_menu_level > 0) dofmquit();
X							break;
X
X		default:			HiliteMenu(0);
X							break;
X
X	}
X
X	return;
X}
X
Xvoid doappmenu(item)
Xlong item;
X
X{
X	switch (item) {
X
X		case AM_HELP:		DoMacHelp();
X							UnloadSeg(DoMacHelp);
X							break;
X
X		case AM_CMD_SET:	ConfigScreenMgr(TRUE, CMDSET_TYPE,
X							CMDSET_ID, GetCommandSet);
X							UnloadSeg(GetCommandSet);
X							cmdsetopt = **((long **) GetResource(CMDSET_TYPE, CMDSET_ID));
X							HiliteMenu(0);
X							break;
X
X		case AM_TEXT_ED:	ConfigScreenMgr(TRUE, TE_TYPE, TE_ID, GetTextEditor);
X							UnloadSeg(GetTextEditor);
X							editor = **((long **) GetResource(TE_TYPE, TE_ID));
X							HiliteMenu(0);
X							break;
X
X		case AM_SCORES:		DoScoresDlg();
X							UnloadSeg(DoScoresDlg);
X							break;
X
X		default:			HiliteMenu(0);
X							break;
X
X	}
X
X	return;
X}
X
Xvoid unloadsegments()
X
X{
X#ifndef THINK_C
X	extern void create_character(),
X		creatures(),
X		exit_game(),
X		eat(),
X		file_character(),
X		generate_cave(),
X		ident_char(),
X		cast(),
X		pray(),
X		quaff(),
X		roff_recall(),
X		save_char(),
X		read_scroll(),
X		use(),
X		store_init(),
X		aim(),
X		wizard_light();
X
X	UnloadSeg(create_character);			/* Create			*/
X	UnloadSeg(creatures);					/* Creature			*/
X	UnloadSeg(exit_game);					/* Death			*/
X	UnloadSeg(eat);							/* Eat				*/
X	UnloadSeg(file_character);				/* Files			*/
X	UnloadSeg(generate_cave);				/* Generate			*/
X	UnloadSeg(ident_char);					/* Help				*/
X	UnloadSeg(cast);						/* Magic			*/
X	UnloadSeg(pray);						/* Prayer			*/
X	UnloadSeg(quaff);						/* Potions			*/
X	UnloadSeg(roff_recall);					/* Recall			*/
X	UnloadSeg(save_char);					/* Save				*/
X	UnloadSeg(read_scroll);					/* Scrolls			*/
X	UnloadSeg(use);							/* Staffs			*/
X	UnloadSeg(store_init);					/* Store			*/
X	UnloadSeg(aim);							/* Wands			*/
X	UnloadSeg(wizard_light);				/* Wizard			*/
X#endif
X
X	return;
X}
X
Xvoid salutation()
X
X{
X	mac_helpfile(MORIA_MOR, FALSE);
X}
X
Xint main()
X
X{
X	int next, savedgame, restart_flag;
X#ifndef THINK_C
X	extern void _DataInit();
X#endif
X
X	checkdebugger();
X
X#ifndef THINK_C
X	UnloadSeg(_DataInit);
X#endif
X
X	getstack(0x7000L);
X
X  	MaxApplZone();
X
X	/* Do this early to prevent fragmentation */
X	loaddata(FALSE);
X
X	InitScreenMgr(SCRN_COLS, SCRN_ROWS,
X		"Moria", "Moria Config",
X		MORIA_FCREATOR, CONFIG_FTYPE,
X		dofilemenu, doappmenu,
X		twoColor);
X
X	/* Get permanently set options */
X	/* If user has not set them yet, a dialog will be invoked */
X	/* Otherwise, they will be loaded from the preferences file */
X
X	ConfigScreenMgr(FALSE, CMDSET_TYPE, CMDSET_ID, GetCommandSet);
X#ifndef THINK_C
X	UnloadSeg(GetCommandSet);
X#endif
X	cmdsetopt = **((long **) GetResource(CMDSET_TYPE, CMDSET_ID));
X
X	ConfigScreenMgr(FALSE, TE_TYPE, TE_ID, GetTextEditor);
X#ifndef THINK_C
X	UnloadSeg(GetTextEditor);
X#endif
X	editor = **((long **) GetResource(TE_TYPE, TE_ID));
X
X	DefineScreenCursor(attrColorFore, 2, GetCaretTime());
X	ShowScreenCursor();
X
X	/* Save the application volume */
X	GetVol(NULL, &applvrefnum);
X
X	/* These should be based up the menu resources */
X	setsavecmdstatus(0, TRUE);
X	setfilemenustatus(1, TRUE);
X	setappmenustatus(1, TRUE);
X
X	restart_flag = FALSE;
X
X	initsavedefaults ();
X
X	/* Find out if user has started from a saved game */
X	savedgame = getfinderfile();
X
X	if (savedgame) {
X		enablefilemenu(FALSE);
X		salutation();
X		pause_line(23);
X		enablefilemenu(TRUE);
X		next = NEXT_FINDER;
X	}
X	else {
X		salutation();
X		next = NEXT_WAIT;
X	}
X
X	do {
X		setsavecmdstatus(0, FALSE);
X		setfilemenustatus(1, FALSE);
X		setappmenustatus(1, FALSE);
X		switch (next) {
X			case NEXT_FINDER:
X				if (restart_flag) loaddata(TRUE);
X				next = startfinder();
X				unloadsegments();
X				restart_flag = TRUE;
X				break;
X			case NEXT_NEW:
X				if (restart_flag) loaddata(TRUE);
X				next = startnew();
X				unloadsegments();
X				restart_flag = TRUE;
X				break;
X			case NEXT_OPEN:
X				if (restart_flag) loaddata(TRUE);
X				next = startopen();
X				unloadsegments();
X				restart_flag = TRUE;
X				break;
X			case NEXT_WAIT:
X				next = waitforchoice();
X				break;
X			default:
X				msg_print("What was that?");
X				next = NEXT_WAIT;
X				break;
X		}
X	} while (next != NEXT_QUIT);
X
X	CloseScreenMgr();
X
X	/* That's all, folks... */
X	return(0);
X}
END_OF_FILE
if test 30757 -ne `wc -c <'mac/mac.c'`; then
    echo shar: \"'mac/mac.c'\" unpacked with wrong size!
fi
# end of 'mac/mac.c'
fi
if test -f 'source/constant.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/constant.h'\"
else
echo shar: Extracting \"'source/constant.h'\" \(20967 characters\)
sed "s/^X//" >'source/constant.h' <<'END_OF_FILE'
X/* source/constant.h: global constants used by Moria
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X/*Note to the Wizard:					- RAK -	 */
X/*	 Tweaking these constants can *GREATLY* change the game. */
X/*	 Two years of constant tuning have generated these	 */
X/*	 values.  Minor adjustments are encouraged, but you must */
X/*	 be very careful not to unbalance the game.  Moria was	 */
X/*	 meant to be challenging, not a give away.  Many	 */
X/*	 adjustments can cause the game to act strangely, or even*/
X/*	 cause errors.						 */
X
X/*Addendum:							- JEW -
X  I have greatly expanded the number of defined constants.  However, if
X  you change anything below, without understanding EXACTLY how the game
X  uses the number, the program may stop working correctly.  Modify the
X  constants at your own risk. */
X
X#define CONSTANT_H_INCLUDED
X#ifndef CONFIG_H_INCLUDED
XConstant.h should always be included after config.h, because it uses
Xsome of the system defines set up there.
X#endif
X
X/* Current version number of Moria				*/
X#define CUR_VERSION_MAJ 5 /* version 5.5 */
X#define CUR_VERSION_MIN 5
X#define PATCH_LEVEL 0
X
X#ifndef TRUE
X#define TRUE 1
X#endif
X#ifndef FALSE
X#define FALSE 0
X#endif
X
X#define MAX_UCHAR	255
X#define MAX_SHORT	32767		/* maximum short/long signed ints */
X#define MAX_LONG	0x7FFFFFFFL
X
X/* Changing values below this line may be hazardous to your health! */
X
X/* message line location */
X#define MSG_LINE  0
X
X/* number of messages to save in a buffer */
X#define MAX_SAVE_MSG   22   /* How many messages to save -CJS- */
X
X/* Dungeon size parameters					*/
X#define MAX_HEIGHT  66	    /* Multiple of 11; >= 22 */
X#define MAX_WIDTH  198	  /* Multiple of 33; >= 66 */
X#define SCREEN_HEIGHT  22
X#define SCREEN_WIDTH   66
X#define QUART_HEIGHT (SCREEN_HEIGHT / 4)
X#define QUART_WIDTH  (SCREEN_WIDTH / 4)
X
X/* Dungeon generation values					*/
X/* Note: The entire design of dungeon can be changed by only	 */
X/*	 slight adjustments here.				 */
X#define DUN_TUN_RND	  9   /* 1/Chance of Random direction	       */
X#define DUN_TUN_CHG	 70   /* Chance of changing direction (99 max) */
X#define DUN_TUN_CON	 15   /* Chance of extra tunneling	       */
X#define DUN_ROO_MEA	 32   /* Mean of # of rooms, standard dev2     */
X#define DUN_TUN_PEN	 25   /* % chance of room doors		       */
X#define DUN_TUN_JCT	 15   /* % chance of doors at tunnel junctions */
X#define DUN_STR_DEN	 5    /* Density of streamers		       */
X#define DUN_STR_RNG	 2    /* Width of streamers		       */
X#define DUN_STR_MAG	 3    /* Number of magma streamers	       */
X#define DUN_STR_MC	 90   /* 1/x chance of treasure per magma      */
X#define DUN_STR_QUA	 2    /* Number of quartz streamers	       */
X#define DUN_STR_QC	 40   /* 1/x chance of treasure per quartz     */
X#define DUN_UNUSUAL	 300  /* Level/x chance of unusual room	       */
X
X/* Store constants						*/
X#define MAX_OWNERS	 18   /* Number of owners to choose from       */
X#define MAX_STORES	 6    /* Number of different stores	       */
X#define STORE_INVEN_MAX	 24   /* Max number of discrete objs in inven  */
X#define STORE_CHOICES	 26   /* NUMBER of items to choose stock from  */
X#define STORE_MAX_INVEN	 18   /* Max diff objs in stock for auto buy   */
X#define STORE_MIN_INVEN	 10   /* Min diff objs in stock for auto sell  */
X#define STORE_TURN_AROUND 9   /* Amount of buying and selling normally */
X#define COST_ADJ	 100  /* Adjust prices for buying and selling  */
X
X/* Treasure constants						*/
X#define INVEN_ARRAY_SIZE 34   /* Size of inventory array(Do not change)*/
X#define MAX_OBJ_LEVEL  50     /* Maximum level of magic in dungeon     */
X#define OBJ_GREAT      12     /* 1/n Chance of item being a Great Item */
X/* Note that the following constants are all related, if you change one,
X   you must also change all succeeding ones.  Also, player_init[] and
X   store_choice[] may also have to be changed. */
X#define MAX_OBJECTS    420    /* Number of objects for universe	       */
X#define MAX_DUNGEON_OBJ 344   /* Number of dungeon objects */
X#define OBJ_OPEN_DOOR	367
X#define OBJ_CLOSED_DOOR 368
X#define OBJ_SECRET_DOOR 369
X#define OBJ_UP_STAIR	370
X#define OBJ_DOWN_STAIR	371
X#define OBJ_STORE_DOOR  372
X#define OBJ_TRAP_LIST	378
X#define OBJ_RUBBLE	396
X#define OBJ_MUSH	397
X#define OBJ_SCARE_MON	398
X#define OBJ_GOLD_LIST	399
X#define OBJ_NOTHING	417
X#define OBJ_RUINED_CHEST 418
X#define OBJ_WIZARD      419
X#define OBJECT_IDENT_SIZE 448 /* 7*64, see object_offset() in desc.c,
X				 could be MAX_OBJECTS o_o() rewritten  */
X#define MAX_GOLD       18     /* Number of different types of gold     */
X/* with MAX_TALLOC 150, it is possible to get compacting objects during
X   level generation, although it is extremely rare */
X#define MAX_TALLOC     175    /* Max objects per level		       */
X#define MIN_TRIX	1     /* Minimum t_list index used		*/
X#define TREAS_ROOM_ALLOC  7   /* Amount of objects for rooms	       */
X#define TREAS_ANY_ALLOC	  2   /* Amount of objects for corridors       */
X#define TREAS_GOLD_ALLOC  2   /* Amount of gold (and gems)	       */
X
X/* Magic Treasure Generation constants				*/
X/* Note: Number of special objects, and degree of enchantments	 */
X/*	 can be adjusted here.					 */
X#define OBJ_STD_ADJ	 125  /* Adjust STD per level * 100	       */
X#define OBJ_STD_MIN	 7    /* Minimum STD			       */
X#define OBJ_TOWN_LEVEL	 7    /* Town object generation level	       */
X#define OBJ_BASE_MAGIC	 15   /* Base amount of magic		       */
X#define OBJ_BASE_MAX	 70   /* Max amount of magic		       */
X#define OBJ_DIV_SPECIAL	 6    /* magic_chance/#	 special magic	      */
X#define OBJ_DIV_CURSED	 13   /* 10*magic_chance/#  cursed items	 */
X
X/* Constants describing limits of certain objects		*/
X#define OBJ_LAMP_MAX	15000 /* Maximum amount that lamp can be filled*/
X#define OBJ_BOLT_RANGE	 18   /* Maximum range of bolts and balls      */
X#define OBJ_RUNE_PROT	 3000 /* Rune of protection resistance	       */
X
X/* Creature constants						*/
X#define MAX_CREATURES	  279 /* Number of creatures defined for univ  */
X#define N_MONS_ATTS	  215 /* Number of monster attack types.	*/
X/* with MAX_MALLOC 101, it is possible to get compacting monsters messages
X   while breeding/cloning monsters */
X#define MAX_MALLOC	  125 /* Max that can be allocated	      */
X#define MAX_MALLOC_CHANCE 160 /* 1/x chance of new monster each round  */
X#define MAX_MONS_LEVEL	   40 /* Maximum level of creatures	       */
X#define MAX_SIGHT	   20 /* Maximum dis a creature can be seen    */
X#define MAX_SPELL_DIS	   20 /* Maximum dis creat. spell can be cast  */
X#define MAX_MON_MULT	   75 /* Maximum reproductions on a level      */
X#define MON_MULT_ADJ	    7 /* High value slows multiplication       */
X#define MON_NASTY	   50 /* 1/x chance of high level creat		*/
X#define MIN_MALLOC_LEVEL   14 /* Minimum number of monsters/level      */
X#define MIN_MALLOC_TD	    4 /* Number of people on town level (day)  */
X#define MIN_MALLOC_TN	    8 /* Number of people on town level (night)*/
X#define WIN_MON_TOT	    2 /* Total number of "win" creatures       */
X#define WIN_MON_APPEAR	   50 /* Level where winning creatures begin   */
X#define MON_SUMMON_ADJ	    2 /* Adjust level of summoned creatures    */
X#define MON_DRAIN_LIFE	    2 /* Percent of player exp drained per hit */
X#define MAX_MON_NATTACK	    4 /* Max num attacks (used in mons memory) -CJS-*/
X#define MIN_MONIX	    2 /* Minimum index in m_list (1 = py, 0 = no mon)*/
X
X/* Trap constants						*/
X#define MAX_TRAP	 18  /* Number of defined traps		      */
X
X#define SCARE_MONSTER	99
X
X/* Descriptive constants					*/
X#define MAX_COLORS     49     /* Used with potions     */
X#define MAX_MUSH       22     /* Used with mushrooms   */
X#define MAX_WOODS      25     /* Used with staffs      */
X#define MAX_METALS     25     /* Used with wands       */
X#define MAX_ROCKS      32     /* Used with rings       */
X#define MAX_AMULETS    11     /* Used with amulets     */
X#define MAX_TITLES     45     /* Used with scrolls     */
X#define MAX_SYLLABLES  153    /* Used with scrolls     */
X
X/* Player constants						*/
X#define MAX_PLAYER_LEVEL  40  /* Maximum possible character level      */
X#define MAX_EXP	    9999999L  /* Maximum amount of experience -CJS- */
X#define MAX_RACES	  8   /* Number of defined races	       */
X#define MAX_CLASS	  6   /* Number of defined classes	       */
X#define USE_DEVICE	  3   /* x> Harder devices x< Easier devices   */
X#define MAX_BACKGROUND	  128 /* Number of types of histories for univ */
X#define PLAYER_FOOD_FULL 10000/* Getting full			       */
X#define PLAYER_FOOD_MAX	 15000/* Maximum food value, beyond is wasted  */
X#define PLAYER_FOOD_FAINT  300/* Character begins fainting	       */
X#define PLAYER_FOOD_WEAK  1000/* Warn player that he is getting very low*/
X#define PLAYER_FOOD_ALERT 2000/* Warn player that he is getting low    */
X#define PLAYER_REGEN_FAINT    33   /* Regen factor*2^16 when fainting	 */
X#define PLAYER_REGEN_WEAK     98   /* Regen factor*2^16 when weak	 */
X#define PLAYER_REGEN_NORMAL  197   /* Regen factor*2^16 when full	 */
X#define PLAYER_REGEN_HPBASE  1442  /* Min amount hp regen*2^16		 */
X#define PLAYER_REGEN_MNBASE  524   /* Min amount mana regen*2^16	 */
X#define PLAYER_WEIGHT_CAP 130 /* "#"*(1/10 pounds) per strength point  */
X#define PLAYER_EXIT_PAUSE 2   /* Pause time before player can re-roll  */
X
X/* class level adjustment constants */
X#define CLA_BTH		0
X#define CLA_BTHB	1
X#define CLA_DEVICE	2
X#define CLA_DISARM	3
X#define CLA_SAVE	4
X/* this depends on the fact that CLA_SAVE values are all the same, if not,
X   then should add a separate column for this */
X#define CLA_MISC_HIT	4
X#define MAX_LEV_ADJ	5
X
X/* Base to hit constants					*/
X#define BTH_PLUS_ADJ	 3    /* Adjust BTH per plus-to-hit	*/
X
X/* magic numbers for players inventory array */
X#define INVEN_WIELD 22	/* must be first item in equipment list */
X#define INVEN_HEAD  23
X#define INVEN_NECK  24
X#define INVEN_BODY  25
X#define INVEN_ARM   26
X#define INVEN_HANDS 27
X#define INVEN_RIGHT 28
X#define INVEN_LEFT  29
X#define INVEN_FEET  30
X#define INVEN_OUTER 31
X#define INVEN_LIGHT 32
X#define INVEN_AUX   33
X
X/* Attribute indexes -CJS- */
X
X#define A_STR 0
X#define A_INT 1
X#define A_WIS 2
X#define A_DEX 3
X#define A_CON 4
X#define A_CHR 5
X
X/* some systems have a non-ANSI definition of this, so undef it first */
X#undef CTRL
X#define CTRL(x)		(x & 0x1F)
X#define DELETE		0x7f
X#ifdef VMS
X#define ESCAPE        '\032'	/* Use CTRL-Z instead of ESCAPE.  */
X#else
X#define ESCAPE	      '\033'	/* ESCAPE character -CJS-  */
X#endif
X
X/* This used to be NULL, but that was technically incorrect.  CNIL is used
X   instead of null to help avoid lint errors.  */
X#ifndef CNIL
X#define CNIL (char *)0
X#endif
X
X/* Fval definitions: these describe the various types of dungeon floors and
X   walls, if numbers above 15 are ever used, then the test against
X   MIN_CAVE_WALL will have to be changed, also the save routines will have
X   to be changed. */
X#define NULL_WALL	0
X#define DARK_FLOOR	1
X#define LIGHT_FLOOR	2
X#define MAX_CAVE_ROOM	2
X#define CORR_FLOOR	3
X#define BLOCKED_FLOOR	4 /* a corridor space with cl/st/se door or rubble */
X#define MAX_CAVE_FLOOR	4
X
X#define MAX_OPEN_SPACE  3
X#define MIN_CLOSED_SPACE 4
X
X#define TMP1_WALL	8
X#define TMP2_WALL	9
X
X#define MIN_CAVE_WALL	12
X#define GRANITE_WALL	12
X#define MAGMA_WALL	13
X#define QUARTZ_WALL	14
X#define BOUNDARY_WALL	15
X
X/* Column for stats    */
X#define STAT_COLUMN	0
X
X/* Class spell types */
X#define NONE	0
X#define MAGE	1
X#define PRIEST	2
X
X/* offsets to spell names in spell_names[] array */
X#define SPELL_OFFSET	0
X#define PRAYER_OFFSET	31
X
X/* definitions for the psuedo-normal distribution generation */
X#define NORMAL_TABLE_SIZE	256
X#define NORMAL_TABLE_SD		64  /* the standard deviation for the table */
X
X/* definitions for the player's status field */
X#define PY_HUNGRY	0x00000001L
X#define PY_WEAK		0x00000002L
X#define PY_BLIND	0x00000004L
X#define PY_CONFUSED	0x00000008L
X#define PY_FEAR		0x00000010L
X#define PY_POISONED	0x00000020L
X#define PY_FAST		0x00000040L
X#define PY_SLOW		0x00000080L
X#define PY_SEARCH	0x00000100L
X#define PY_REST		0x00000200L
X#define PY_STUDY	0x00000400L
X
X#define PY_INVULN	0x00001000L
X#define PY_HERO		0x00002000L
X#define PY_SHERO	0x00004000L
X#define PY_BLESSED	0x00008000L
X#define PY_DET_INV	0x00010000L
X#define PY_TIM_INFRA	0x00020000L
X#define PY_SPEED	0x00040000L
X#define PY_STR_WGT	0x00080000L
X#define PY_PARALYSED	0x00100000L
X#define PY_REPEAT	0x00200000L
X#define PY_ARMOR	0x00400000L
X
X#define PY_STATS	0x3F000000L
X#define PY_STR		0x01000000L /* these 6 stat flags must be adjacent */
X#define PY_INT		0x02000000L
X#define PY_WIS		0x04000000L
X#define PY_DEX		0x08000000L
X#define PY_CON		0x10000000L
X#define PY_CHR		0x20000000L
X
X#define PY_HP		0x40000000L
X#define PY_MANA		0x80000000L
X
X/* definitions for objects that can be worn */
X#define TR_STATS	0x0000003FL	/* the stats must be the low 6 bits */
X#define TR_STR		0x00000001L
X#define TR_INT		0x00000002L
X#define TR_WIS		0x00000004L
X#define TR_DEX		0x00000008L
X#define TR_CON		0x00000010L
X#define TR_CHR		0x00000020L
X#define TR_SEARCH	0x00000040L
X#define TR_SLOW_DIGEST	0x00000080L
X#define TR_STEALTH	0x00000100L
X#define TR_AGGRAVATE	0x00000200L
X#define TR_TELEPORT	0x00000400L
X#define TR_REGEN	0x00000800L
X#define TR_SPEED	0x00001000L
X
X#define TR_EGO_WEAPON	0x0007E000L
X#define TR_SLAY_DRAGON	0x00002000L
X#define TR_SLAY_ANIMAL	0x00004000L
X#define TR_SLAY_EVIL	0x00008000L
X#define TR_SLAY_UNDEAD	0x00010000L
X#define TR_FROST_BRAND	0x00020000L
X#define TR_FLAME_TONGUE	0x00040000L
X
X#define TR_RES_FIRE	0x00080000L
X#define TR_RES_ACID	0x00100000L
X#define TR_RES_COLD	0x00200000L
X#define TR_SUST_STAT	0x00400000L
X#define TR_FREE_ACT	0x00800000L
X#define TR_SEE_INVIS	0x01000000L
X#define TR_RES_LIGHT	0x02000000L
X#define TR_FFALL	0x04000000L
X#define TR_BLIND	0x08000000L
X#define TR_TIMID	0x10000000L
X#define TR_TUNNEL	0x20000000L
X#define TR_INFRA	0x40000000L
X#define TR_CURSED	0x80000000L
X
X/* definitions for chests */
X#define CH_LOCKED	0x00000001L
X#define CH_TRAPPED	0x000001F0L
X#define CH_LOSE_STR	0x00000010L
X#define CH_POISON	0x00000020L
X#define CH_PARALYSED	0x00000040L
X#define CH_EXPLODE	0x00000080L
X#define CH_SUMMON	0x00000100L
X
X/* definitions for creatures, cmove field */
X#define CM_ALL_MV_FLAGS	0x0000003FL
X#define CM_ATTACK_ONLY	0x00000001L
X#define CM_MOVE_NORMAL	0x00000002L
X/* For Quylthulgs, which have no physical movement.  */
X#define CM_ONLY_MAGIC	0x00000004L
X
X#define CM_RANDOM_MOVE	0x00000038L
X#define CM_20_RANDOM	0x00000008L
X#define CM_40_RANDOM	0x00000010L
X#define CM_75_RANDOM	0x00000020L
X
X#define CM_SPECIAL	0x003F0000L
X#define CM_INVISIBLE	0x00010000L
X#define CM_OPEN_DOOR	0x00020000L
X#define CM_PHASE	0x00040000L
X#define CM_EATS_OTHER	0x00080000L
X#define CM_PICKS_UP	0x00100000L
X#define CM_MULTIPLY	0x00200000L
X
X#define CM_CARRY_OBJ	0x01000000L
X#define CM_CARRY_GOLD	0x02000000L
X#define CM_TREASURE	0x7C000000L
X#define CM_TR_SHIFT	26		/* used for recall of treasure */
X#define CM_60_RANDOM	0x04000000L
X#define CM_90_RANDOM	0x08000000L
X#define CM_1D2_OBJ	0x10000000L
X#define CM_2D2_OBJ	0x20000000L
X#define CM_4D2_OBJ	0x40000000L
X#define CM_WIN		0x80000000L
X
X/* creature spell definitions */
X#define CS_FREQ		0x0000000FL
X#define CS_SPELLS	0x0001FFF0L
X#define CS_TEL_SHORT	0x00000010L
X#define CS_TEL_LONG	0x00000020L
X#define CS_TEL_TO	0x00000040L
X#define CS_LGHT_WND	0x00000080L
X#define CS_SER_WND	0x00000100L
X#define CS_HOLD_PER	0x00000200L
X#define CS_BLIND	0x00000400L
X#define CS_CONFUSE	0x00000800L
X#define CS_FEAR		0x00001000L
X#define CS_SUMMON_MON	0x00002000L
X#define CS_SUMMON_UND	0x00004000L
X#define CS_SLOW_PER	0x00008000L
X#define CS_DRAIN_MANA	0x00010000L
X
X#define CS_BREATHE	0x00F80000L
X#define CS_BR_LIGHT	0x00080000L
X#define CS_BR_GAS	0x00100000L
X#define CS_BR_ACID	0x00200000L
X#define CS_BR_FROST	0x00400000L
X#define CS_BR_FIRE	0x00800000L
X
X/* creature defense flags */
X#define CD_DRAGON	0x0001
X#define CD_ANIMAL	0x0002
X#define CD_EVIL		0x0004
X#define CD_UNDEAD	0x0008
X#define CD_WEAKNESS	0x03F0
X#define CD_FROST	0x0010
X#define CD_FIRE		0x0020
X#define CD_POISON	0x0040
X#define CD_ACID		0x0080
X#define CD_LIGHT	0x0100
X#define CD_STONE	0x0200
X
X#define CD_NO_SLEEP	0x1000
X#define CD_INFRA	0x2000
X#define CD_MAX_HP	0x4000
X
X/* inventory stacking subvals */
X/* these never stack */
X#define ITEM_NEVER_STACK_MIN	0
X#define ITEM_NEVER_STACK_MAX	63
X/* these items always stack with others of same subval, always treated as
X   single objects, must be power of 2 */
X#define ITEM_SINGLE_STACK_MIN	64
X#define ITEM_SINGLE_STACK_MAX	192	/* see NOTE below */
X/* these items stack with others only if have same subval and same p1,
X   they are treated as a group for wielding, etc. */
X#define ITEM_GROUP_MIN		192
X#define ITEM_GROUP_MAX		255
X/* NOTE: items with subval 192 are treated as single objects, but only stack
X   with others of same subval if have the same p1 value, only used for
X   torches */
X
X/* id's used for object description, stored in object_ident */
X#define OD_TRIED	0x1
X#define OD_KNOWN1	0x2
X
X/* id's used for item description, stored in i_ptr->ident */
X#define ID_MAGIK	0x1
X#define ID_DAMD		0x2
X#define ID_EMPTY	0x4
X#define ID_KNOWN2	0x8
X#define ID_STOREBOUGHT	0x10
X#define ID_SHOW_HITDAM	0x20
X#define ID_NOSHOW_P1	0x40
X#define ID_SHOW_P1	0x80
X
X/* indexes into the special name table */
X#define SN_NULL			0
X#define SN_R			1
X#define SN_RA			2
X#define SN_RF			3
X#define SN_RC			4
X#define SN_RL			5
X#define SN_HA			6
X#define SN_DF			7
X#define SN_SA			8
X#define SN_SD			9
X#define SN_SE			10
X#define SN_SU			11
X#define SN_FT			12
X#define SN_FB			13
X#define SN_FREE_ACTION		14
X#define SN_SLAYING		15
X#define SN_CLUMSINESS		16
X#define SN_WEAKNESS		17
X#define SN_SLOW_DESCENT		18
X#define SN_SPEED		19
X#define SN_STEALTH		20
X#define SN_SLOWNESS		21
X#define SN_NOISE		22
X#define SN_GREAT_MASS		23
X#define SN_INTELLIGENCE		24
X#define SN_WISDOM		25
X#define SN_INFRAVISION		26
X#define SN_MIGHT		27
X#define SN_LORDLINESS		28
X#define SN_MAGI			29
X#define SN_BEAUTY		30
X#define SN_SEEING		31
X#define SN_REGENERATION		32
X#define SN_STUPIDITY		33
X#define SN_DULLNESS		34
X#define SN_BLINDNESS		35
X#define SN_TIMIDNESS		36
X#define SN_TELEPORTATION	37
X#define SN_UGLINESS		38
X#define SN_PROTECTION		39
X#define SN_IRRITATION		40
X#define SN_VULNERABILITY	41
X#define SN_ENVELOPING		42
X#define SN_FIRE			43
X#define SN_SLAY_EVIL		44
X#define SN_DRAGON_SLAYING	45
X#define SN_EMPTY		46
X#define SN_LOCKED		47
X#define SN_POISON_NEEDLE	48
X#define SN_GAS_TRAP		49
X#define SN_EXPLOSION_DEVICE	50
X#define SN_SUMMONING_RUNES	51
X#define SN_MULTIPLE_TRAPS	52
X#define SN_DISARMED		53
X#define SN_UNLOCKED		54
X#define SN_SLAY_ANIMAL		55
X#define SN_ARRAY_SIZE		56 /* must be at end of this list */
X
X/* defines for treasure type values (tval) */
X#define TV_NEVER	-1 /* used by find_range() for non-search */
X#define TV_NOTHING	0
X#define TV_MISC		1
X#define TV_CHEST	2
X/* min tval for wearable items, all items between TV_MIN_WEAR and TV_MAX_WEAR
X   use the same flag bits, see the TR_* defines */
X#define TV_MIN_WEAR	10
X/* items tested for enchantments, i.e. the MAGIK inscription, see the
X   enchanted() procedure */
X#define TV_MIN_ENCHANT	10
X#define TV_SLING_AMMO	10
X#define TV_BOLT		11
X#define TV_ARROW	12
X#define TV_SPIKE	13
X#define TV_LIGHT	15
X#define TV_BOW		20
X#define TV_HAFTED	21
X#define TV_POLEARM	22
X#define TV_SWORD	23
X#define TV_DIGGING	25
X#define TV_BOOTS	30
X#define TV_GLOVES	31
X#define TV_CLOAK	32
X#define TV_HELM		33
X#define TV_SHIELD	34
X#define TV_HARD_ARMOR	35
X#define TV_SOFT_ARMOR	36
X/* max tval that uses the TR_* flags */
X#define TV_MAX_ENCHANT	39
X#define TV_AMULET	40
X#define TV_RING		45
X/* max tval for wearable items */
X#define TV_MAX_WEAR	50
X#define TV_STAFF	55
X#define TV_WAND		65
X#define TV_SCROLL1	70
X#define TV_SCROLL2	71
X#define TV_POTION1	75
X#define TV_POTION2	76
X#define TV_FLASK	77
X#define TV_FOOD 	80
X#define TV_MAGIC_BOOK	90
X#define TV_PRAYER_BOOK	91
X/* objects with tval above this are never picked up by monsters */
X#define TV_MAX_OBJECT	99
X#define TV_GOLD		100
X/* objects with higher tvals can not be picked up */
X#define TV_MAX_PICK_UP	100
X#define TV_INVIS_TRAP	101
X/* objects between TV_MIN_VISIBLE and TV_MAX_VISIBLE are always visible,
X   i.e. the cave fm flag is set when they are present */
X#define TV_MIN_VISIBLE	102
X#define TV_VIS_TRAP	102
X#define TV_RUBBLE	103
X/* following objects are never deleted when trying to create another one
X   during level generation */
X#define TV_MIN_DOORS	104
X#define TV_OPEN_DOOR	104
X#define TV_CLOSED_DOOR	105
X#define TV_UP_STAIR	107
X#define TV_DOWN_STAIR	108
X#define TV_SECRET_DOOR	109
X#define TV_STORE_DOOR	110
X#define TV_MAX_VISIBLE	110
X
X/* spell types used by get_flags(), breathe(), fire_bolt() and fire_ball() */
X#define GF_MAGIC_MISSILE 0
X#define GF_LIGHTNING	1
X#define GF_POISON_GAS	2
X#define GF_ACID		3
X#define GF_FROST	4
X#define GF_FIRE		5
X#define GF_HOLY_ORB	6
X
X/* Number of entries allowed in the scorefile.  */
X#define SCOREFILE_SIZE	1000
END_OF_FILE
if test 20967 -ne `wc -c <'source/constant.h'`; then
    echo shar: \"'source/constant.h'\" unpacked with wrong size!
fi
# end of 'source/constant.h'
fi
echo shar: End of archive 16 \(of 39\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
