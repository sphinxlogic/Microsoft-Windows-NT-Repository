Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i041:  umoria4 - single player dungeon simulation (ver. 5.5), Part09/39
Message-ID: <3399@master.CNA.TEK.COM>
Date: 20 Aug 92 18:03:24 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1974
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 41
Archive-name: umoria4/Part09
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 39)."
# Contents:  amiga/ERRORS atari_st/curscomp/curses.c shortnam.sed
# Wrapped by billr@saab on Thu Aug 20 09:11:28 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'amiga/ERRORS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'amiga/ERRORS'\"
else
echo shar: Extracting \"'amiga/ERRORS'\" \(140 characters\)
sed "s/^X//" >'amiga/ERRORS' <<'END_OF_FILE'
X
XThe game tends to crash with an out of memory error if run for a very
Xlong time.  This has been reported as happening after about 2 hours.
END_OF_FILE
if test 140 -ne `wc -c <'amiga/ERRORS'`; then
    echo shar: \"'amiga/ERRORS'\" unpacked with wrong size!
fi
# end of 'amiga/ERRORS'
fi
if test -f 'atari_st/curscomp/curses.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'atari_st/curscomp/curses.c'\"
else
echo shar: Extracting \"'atari_st/curscomp/curses.c'\" \(41529 characters\)
sed "s/^X//" >'atari_st/curscomp/curses.c' <<'END_OF_FILE'
X/* This is essentially a shareware program, its usage is subject to
Xthe following conditions :
X
XPUBLIC-DOMAIN       : don't take the credit for it.
XCommercial purposes : Send 5 US-dollars or equivalent currency and return
X                      postage to me to get a written consent to use it.
X
XCURSES may be distributed to anyone, provided that the various
Xcopyright notices remain intact.
X
XBug reports and suggestions are welcome, send me e-mail.
X
XRene van't Veen                  (...!mcvax!nikhefh!u13)
XDebussystraat 27
X1817 GL Alkmaar
XThe Netherlands
X
XExtensive modifications for clarity and speed by :
XHildo Biersma
XTollensstraat 138
X2513 GE Den Haag
XHolland
XThe copyright remains with the original author */
X
X/*************************************************************************/
X/* curses: simple-minded implementation of the curses package            */
X/* Introduction                                                          */
X/*                                                                       */
X/* This source and resulting object may be modified,used or distributed  */
X/* by anyone who so desires under the following conditions :             */
X/*                                                                       */
X/*  1) This notice and the copyright notice shall not be removed or      */
X/*     changed.                                                          */
X/*  2) No credit shall be taken for this source and resulting objects    */
X/*  3) This source or resulting objects is not to be traded, sold or     */
X/*     used for personal gain or profit.                                 */
X/*  4) Inclusion of this source or resulting objects in commercially     */
X/*     available packages is forbidden without written consent of the    */
X/*     author of this source.                                            */
X/*                                                                       */
X/*************************************************************************/
X
X/**************************************************************************/
X/*                                                                        */
X/*  Some notes on the WINDOW data structure and the meaning of the flags. */
X/*                                                                        */
X/*  struct _win_st                                                        */
X/*  {                                                                     */
X/*    int16 _cury, _curx; : current cursor positions for this screen      */
X/*    int16 _maxy, _maxx; : maximum x and y positions for this screen     */
X/*    int16 _begy, _begx; : first x and y positions for this screen       */
X/*    int16 _flags;       : a collection of flags for this screen         */
X/*    bool  _clear;       : boolean - clear screen first at next update   */
X/*    bool  _leave;       : boolean - leave cursor after printing a char  */
X/*    bool  _scroll;      : boolean - scrolling allowed in this screen    */
X/*    int16 **_y;         : pointer to the screen data (see below)        */
X/*    int16 *_firstch;    : pointer to the first non-updated char         */
X/*    int16 *_lastch;     : pointer to the last non-updated char          */
X/*    int16 *_yend;       : pointer to the last char of _y                */
X/*  };                                                                    */
X/*                                                                        */
X/*  The screen data is an array of 16-bit words. The lower 8 bits is the  */
X/*  character; the next two bits, TOUCHED : 0x0200 and STANDOUT : 0x0100  */
X/*  indicate whether this character is changed since the last screen and  */
X/*  whether it should be printed in reverse. Note that, since curscr is   */
X/*  a copy of the current screen, the TOUCHED flags have no meaning; they */
X/*  may be set in a routine to keep it general. For the same reason, the  */
X/*  _firstch and _lastch pointers may be set but have no real meaning.    */
X/*  The _y pointer points to an array of pointers to words. Thus, _y[1]   */
X/*  is a pointer to line number 1. This would indicate a practical way of */
X/*  scrolling or erasing lines : just swap some pointers and don't copy   */
X/*  the contents when unnecessary. However, this wreaks havoc with the    */
X/*  _firstch and _lastch pointers; therefore this method is not used.     */
X/*                                                                        */
X/*  A subwindow is a screen that is a part of another screen and shares   */
X/*  the character data with it. Any change to the window data is a change */
X/*  to the subwindow and vice versa. The existence of subwindows is the   */
X/*  reason for the data structure of _y described above; a subwindow only */
X/*  has an array of pointers that point into the character data of the    */
X/*  screen it is a subwindow of.                                          */
X/*                                                                        */
X/*  The _flags bit of the window may contain the following flags :        */
X/*   _SUBWIN    : 01 - is this a suwindow                                 */
X/*   _ENDLINE   : 02 - end of line of window is also end of screen        */
X/*   _FULLWIN   : 04 - is this screen the full screen size                */
X/*   _SCROLLWIN : 010 - may this window be scrolled                       */
X/*   _STANDOUT  : 0200 - is reverse printing currently on for this window */
X/*                                                                        */
X/*  The _yend pointer in w is my own addition to this data structure. As  */
X/*  a much-used operation was ptr = &(w->_y[w->_maxy][w->_maxx]), it was  */
X/*  faster to do this at the creation of the window, and use it after.    */
X/*  It is also useful as a sentinel, to see when a pointer goes beyond    */
X/*  the character data.                                                   */
X/*                                                                        */
X/* I hope this makes all of the code somewhat more clear, especially the  */
X/* setting or not setting of TOUCHED on curscr and the use of pointers.   */
X/* Hildo Biersma (adress above) - please write if you have any problems.  */
X/**************************************************************************/
X
X
X/* include files */
X#ifdef ATARIST_MWC
X#include <osbind.h>	/* MWC */
X#else
X#include <tos.h>	/* TC */
X#endif
X#include <ext.h>
X#include <stdlib.h>
X#include <stddef.h>
X#include <string.h>
X#include "cursinc.h"
X/* end of include files */
X
X/* terminal states : cooked, cbreak and raw */
X/* Note that CBREAK mode has been disabled - Hildo Biersma */
X#define COOKED 0
X#define CBREAK 1
X#define RAW    2
X
X/* globals : definition of global variables */
X/* the following global variables are defined as external in curses.h */
XWINDOW      *curscr;
XWINDOW      *stdscr;
Xchar        *Def_term = "AtariST";
Xbool        My_term   = FALSE;
Xconst char  *ttytype  = "Atari ST-series computer, VT52/CURSES mode";
Xint         LINES     = 25;
Xint         COLS      = 80;
X/* end of global and externally available variables */
X
Xbool _doecho  = FALSE;
Xbool _nlmap   = FALSE;
Xbool _curini  = FALSE;
Xbool _modinp  = 0; /* set input to Un*x compatability, i.e only char's */
Xbool _csry    = 0;
Xbool _csrx    = 0;
X/* end of global variable definitions */
X
X/* initscr : initialize the curses package */
XWINDOW *initscr()
X{
X  if (_curini)
X  /* Initialized before */
X  {
X    wrefresh(curscr);
X    return(NULL);
X  };
X  _curini = TRUE;
X  curscr = newwin(0,0,0,0);
X  if (curscr == NULL)
X    return(NULL);
X  stdscr = newwin(0,0,0,0);
X  if (stdscr == NULL)
X    return(NULL);
X  /* Clear screen and home cursor */
X  Bconout(2,'\033');
X  Bconout(2,'E');
X  /* Set 'discard EOL mode' : CR + LF needed for new line */
X  Bconout(2,'\033');
X  Bconout(2,'w');
X  /* Hide cursor */
X  Bconout(2,'\033');
X  Bconout(2,'f');
X  _csry = 0;
X  _csrx = 0;
X  return(stdscr);
X}
X/* end of initscr */
X
X
X/* endwin : end of curses package */
X/* Does not seem to be used by Moria */
Xvoid endwin()
X{
X  if (!_curini)
X    return;
X  _curini = 0;
X  delwin(stdscr);
X  delwin(curscr);
X  _movcur(LINES,0);
X  /* Show cursor */
X  Bconout(2,'\033');
X  Bconout(2,'e');
X}
X/* end of endwin */
X
X
X/* newwin : create a new window for the user */
X/* l : lines; c : columns; by : begin-y; bx : begin-x */
XWINDOW *newwin(l,c,by,bx)
Xint l,c,bx,by;
X{
X  register WINDOW *tmp;
X  int16 i, nl, nc;
X  register int16 *tmpptr1,*tmpptr2; /* temp pointers for loops */
X  
X  tmp = (WINDOW *) malloc(sizeof(WINDOW));
X  if (tmp == NULL)
X    return(NULL);
X  tmp->_curx = 0;
X  tmp->_cury = 0;
X  tmp->_clear = FALSE;
X  tmp->_leave = FALSE;
X  tmp->_scroll = FALSE;
X  if (l == 0)
X    nl = LINES - by;
X  else
X    nl = l;
X  if (c == 0)
X    nc = COLS - bx;
X  else
X    nc = c;
X  if (nl < 1 || nl > LINES || nc < 1 || nc > COLS)
X  {
X    free(tmp);
X    return(NULL);
X  };
X  tmp->_maxy = nl - 1;
X  tmp->_maxx = nc - 1;
X  if (nl == LINES && nc == COLS)
X    tmp->_flags = _FULLWIN;
X  else
X    tmp->_flags = 0;
X  if (by < 0 || by >= LINES || bx < 0 || bx >= COLS)
X  {
X    free(tmp);
X    return(NULL);
X  };
X  tmp->_begy = by;
X  tmp->_begx = bx;
X  /* Allocate an array of pointers to the line-arrays */
X  tmp->_y = (int16 **) malloc(sizeof(int16 *) * (tmp->_maxy+1));
X  if (tmp->_y == NULL)
X  {
X    free(tmp);
X    return(NULL);
X  };
X  /* Allocate a block of memory to fit the whole screen */
X  tmp->_y[0] = (int16 *)malloc(sizeof(int16) * (tmp->_maxy+1)
X			       * (tmp->_maxx+1));
X  if (tmp->_y[0] == NULL)
X  {
X    free(tmp->_y);
X    free(tmp);
X    return(NULL);
X  };
X  for (i = 1; i <= tmp->_maxy; i++)
X    tmp->_y[i] = tmp->_y[0] + i * (tmp->_maxx + 1);
X  tmpptr1 = tmp->_y[0];
X  tmp->_firstch = tmpptr1;
X  tmpptr2 = &(tmp->_y[tmp->_maxy][tmp->_maxx]);
X  tmp->_yend = tmpptr2;
X  tmp->_lastch = tmpptr2;
X  for (; tmpptr1 <= tmpptr2; tmpptr1++)
X      *tmpptr1 = (' ' | TOUCHED);
X  return(tmp);
X} /* end of newwin */
X
X
X/* delwin : delete a window */
X/* Does not seem to be used by Moria */
Xvoid delwin(w)
XWINDOW *w;
X{
X  if (w == NULL)
X    return;
X  if (w->_flags & _SUBWIN)
X    free(w->_y);
X  else
X  {
X    free(w->_y[0]);
X    free(w->_y);
X  };
X  free(w);
X} /* end of delwin */
X
X
X/* mvwin : move window */
X/* Does not seem to be used by Moria */
Xint mvwin(w,y,x)
Xregister WINDOW *w;
Xint y,x;
X{
X  if (y < 0 || x < 0 || (y + w->_maxy + 1) > LINES || (x + w->_maxx + 1) > COLS)
X    return(ERR);
X  w->_begy = y;
X  w->_begx = x;
X  touchwin(w);
X  return(OK);
X} /* end of mvwin */
X
X
X/* touchwin : touch a window */
Xvoid touchwin(w)
XWINDOW *w;
X{
X  register int16 j, **tmpptr1,*tmpptr2; /* temporary pointers for loops */
X
X  w->_firstch = w->_y[0];
X  w->_lastch = w->_yend;
X  for (tmpptr1 = w->_y; *tmpptr1 <= w->_yend; tmpptr1++)
X    for (j = 0,tmpptr2 = *tmpptr1; j <= w->_maxx; j++,tmpptr2++)
X      *tmpptr2 |= TOUCHED;
X} /* end of touchwin */
X
X
X/* subwin : create a sub-window */
X/* Does not seem to be used by Moria */
XWINDOW *subwin(w,l,c,by,bx)
XWINDOW *w;
Xint l,c,by,bx;
X{
X  WINDOW *tmp;
X  int16  i, nl, nc;
X
X  /* cannot take subwindows of curscr */
X  if (w == curscr)
X    return(NULL);
X  tmp = (WINDOW *) malloc(sizeof(WINDOW));
X  if (tmp == NULL)
X    return(NULL);
X  tmp->_curx = 0;
X  tmp->_cury = 0;
X  tmp->_clear = FALSE;
X  tmp->_leave = FALSE;
X  tmp->_scroll = FALSE;
X  if (l == 0)
X    nl = LINES - by;
X  else
X    nl = l;
X  if (c == 0)
X    nc = COLS - bx;
X  else
X    nc = c;
X  if (l < 1 || l > (w->_maxy+1) || c < 1 || c > (w->_maxx+1))
X  {
X    free(tmp);
X    return(NULL);
X  };
X  tmp->_maxy = nl - 1;
X  tmp->_maxx = nc - 1;
X  if (nl == LINES && nc == COLS)
X    tmp->_flags = _FULLWIN | _SUBWIN;
X  else
X    tmp->_flags = _SUBWIN;
X  if (by < w->_begy || by >= (w->_maxy+w->_begy) ||
X      bx < w->_begx || bx >= (w->_maxx+w->_begx))
X  {
X    free(tmp);
X    return(NULL);
X  };
X  tmp->_begy = by;
X  tmp->_begx = bx;
X  tmp->_y = (int16**) malloc(sizeof(int16*) * (tmp->_maxy+1));
X  if (tmp->_y == NULL)
X  {
X    free(tmp);
X    return(NULL);
X  };
X  tmp->_y[0] = w->_y[0] + (tmp->_begy-w->_begy) * (w->_maxx+2) + 
X               (tmp->_maxx - w->_maxx);
X  for (i = 1; i <= tmp->_maxy; i++)
X    tmp->_y[i] = tmp->_y[0] + i * (w->_maxx + 2);
X  tmp->_yend = &(tmp->_y[w->_maxy][w->_maxx]);
X  /* make everything changed on first update of tmp       */
X  touchwin(tmp);
X  return(tmp);
X} /* end of subwin */
X
X
X/* leaveok : tell curses where to leave the cursor after updating */
X/* Does not seem to be used by Moria */
Xvoid leaveok(w,f)
XWINDOW *w;
Xbool f;
X{
X  w->_leave = f;
X} /* end of leaveok */
X
X
X/* scrollok : tell curses it is ok to scroll the window */
X/* Does not seem to be used by Moria */
Xvoid scrollok(w,f)
XWINDOW *w;
Xbool f;
X{
X  w->_scroll = f;
X} /* end of scrollok */
X
X
X/* nl : tell curses to map CR to CR,LF */
X/* Does not seem to be used by Moria */
Xvoid nl()
X{
X  /* Set 'Wrap at EOL' mode */
X  Bconout(2,'\033');
X  Bconout(2,'v');
X  _nlmap = 1;
X} /* end of nl */
X
X
X/* nonl : tell curses not to map CR to CR,LF */
X/* Does not seem to be used by Moria */
Xvoid nonl()
X{
X  /* Set 'Discard EOL' mode */
X  Bconout(2,'\033');
X  Bconout(2,'w');
X  _nlmap = 0;
X} /* end of nonl */
X
X
X/* longname : return the full name of the terminal */
X/* always returns the contents of ttytype in name */
X/* Does not seem to be used by Moria */
Xvoid longname(termbuf,name)
Xchar *termbuf, *name;
X{
X  strcpy(name,ttytype);
X} /* end of longname */
X
X
X/* curaddch : add a character to the current screen */
Xint curaddch(c)
Xchar c;
X{
X  int16 i, tpos, *tmpptr;
X
X  switch(c)
X  {
X    case '\n' :
X      wclrtoeol(curscr);
X      if (_nlmap)
X        wmove(curscr,curscr->_cury+1,0);
X      else
X        wmove(curscr,curscr->_cury + 1,curscr->_curx);
X      break;
X    case '\r' :
X      wmove(curscr,curscr->_cury,0);
X      break;
X    case '\t' :
X      tpos = (curscr->_curx + curscr->_begx) % 8;
X      if ((curscr->_flags & _STANDOUT))
X      {
X        /* reverse on */
X        Bconout(2,'\033');
X        Bconout(2,'p');
X      }
X      for (i = 0; i < (8 - tpos); i++)
X        Bconout(5,' ');
X      if ((curscr->_flags & _STANDOUT))
X      {
X        /* reverse off */
X        Bconout(2,'\033');
X        Bconout(2,'q');
X      }
X      break;
X    default :
X      tmpptr = &(curscr->_y[curscr->_cury][curscr->_curx]);
X      if ((curscr->_flags & _STANDOUT))
X      {
X        *tmpptr = c | STANDOUT;
X        /* reverse on */
X        Bconout(2,'\033');
X        Bconout(2,'p');
X        Bconout(5,c);
X        /* reverse off */
X        Bconout(2,'\033');
X        Bconout(2,'q');
X      }
X      else
X      {
X        *tmpptr = c;
X        Bconout(5,c);
X      };
X      _csrx++;
X  } /* end of switch */
X  return(OK);
X} /* end of curaddch */
X
X
X/* waddch : add a character to a window */
Xint waddch(w,c)
Xregister WINDOW *w;
Xchar   c;
X{
X  int16 i, tpos, *tmpptr;
X
X  if (w == curscr)
X    curaddch(c);
X  else
X  {
X    switch(c)
X    {
X      case '\n' :
X        wclrtoeol(w);
X        if (_nlmap)
X          wmove(w,w->_cury+1,0);
X        else
X          wmove(w,w->_cury+1,w->_curx);
X        break;
X      case '\r' :
X        wmove(w,w->_cury,0);
X        break;
X      case '\t' :
X        tpos = (w->_curx + w->_begx) % 8;
X        for (i = 0; i < (8 - tpos); i++)
X          waddch(w,' ');
X        break;
X      default :
X        tmpptr = &(w->_y[w->_cury][w->_curx]);
X        if ((w->_flags & _STANDOUT))
X          *tmpptr = c | (STANDOUT | TOUCHED);
X        else
X          *tmpptr = c | TOUCHED;
X        if (w->_firstch == NULL)
X        {
X          w->_firstch = tmpptr;
X          w->_lastch = tmpptr;
X        }
X        else
X        {
X          if (w->_firstch > tmpptr)
X            w->_firstch = tmpptr;
X          else
X          {
X            if (w->_lastch < tmpptr)
X              w->_lastch = tmpptr;
X          };
X        };
X        wmove(w,w->_cury,w->_curx+1);
X    } /* end of switch */
X  } /* end of if (w == curscr) */
X  return(OK);
X} /* end of waddch */
X
X
X/* waddstr : add a string of characters to a window */
Xint waddstr(w,s)
Xregister WINDOW *w;
Xregister char   *s;
X{
X  if (w == curscr)
X    while (*s != '\0')
X      curaddch(*s++);
X  else
X    while (*s != '\0')
X      waddch(w,*s++);
X  return(OK);
X} /* end of waddstr */
X
X
X/* box : draw a box around a window */
X/* w : window nr; v : vertical char; h : horizontal char */
X/* Does not seem to be used by Moria */
Xvoid box(w,v,h)
XWINDOW *w;
Xchar v,h;
X{
X  int16 i;
X
X  for (i = 0; i <= w->_maxy; i++)
X  {
X    mvwaddch(w,i,0,v);
X    mvwaddch(w,i,w->_maxx,v);
X  };
X  for (i = 1; i < w->_maxx; i++)
X  {
X    mvwaddch(w,0,i,h);
X    mvwaddch(w,w->_maxy,i,h);
X  };
X} /* end of box */
X
X
X/* wclear : clear a window */
Xvoid wclear(w)
XWINDOW *w;
X{
X  werase(w);
X  clearok(w,TRUE);
X  w->_curx = 0;
X  w->_cury = 0;
X} /* end of wclear */
X
X
X/* wclrtobot : clear a window to the bottom */
Xvoid wclrtobot(w)
XWINDOW *w;
X{
X  register int16 j, **tmpptr1, *tmpptr2; /* temporary pointers for loops */
X
X  tmpptr1 = &(w->_y[w->_cury]);
X  for (j = w->_curx, tmpptr2 = tmpptr1[w->_curx];
X       j <= w->_maxx; j++, tmpptr2++)
X    *tmpptr2 = ' ' | TOUCHED;
X  tmpptr1++;
X  for (; *tmpptr1 <= w->_yend; tmpptr1++)
X    for (j = 0,tmpptr2 = *tmpptr1; j <= w->_maxx; j++, tmpptr2++)
X      *tmpptr2 = ' ' | TOUCHED;
X  if (w == curscr)
X  {
X    /* Erase to end of page */
X    Bconout(2,'\033');
X    Bconout(2,'J');
X  }
X  else
X  {
X    tmpptr2 = &(w->_y[w->_cury][w->_curx]);
X    if (w->_firstch == NULL)
X    {
X      w->_firstch = tmpptr2;
X      w->_lastch = w->_yend;
X    }
X    else
X    {
X      if (w->_firstch > tmpptr2)
X        w->_firstch = tmpptr2;
X      w->_lastch = w->_yend;
X    };
X  };
X} /* end of wclrtobot */
X
X
X/* wclrtoeol : clear a window to the end of the line */
Xvoid wclrtoeol(w)
XWINDOW *w;
X{
X  int16 i, *tmpptr2;
X  register int16 *tmpptr1; /* Temporary pointer for loops */
X
X  for (i = w->_curx, tmpptr1 = &(w->_y[w->_cury][w->_curx]);
X       i <= w->_maxx; i++, tmpptr1++)
X    *tmpptr1 = ' ' | TOUCHED;
X  if (w == curscr)
X  {
X    /* Clear to end of line */
X    Bconout(2,'\033');
X    Bconout(2,'K');
X  }
X  else
X  {
X    tmpptr1 = &(w->_y[w->_cury][w->_curx]);
X    tmpptr2 = &(w->_y[w->_cury][w->_maxx]);
X    if (w->_firstch == NULL)
X    {
X      w->_firstch = tmpptr1;
X      w->_lastch = tmpptr2;
X    }
X    else
X    {
X      if (w->_firstch > tmpptr1)
X        w->_firstch = tmpptr1;
X      if (w->_lastch < tmpptr2)
X        w->_lastch = tmpptr2;
X    };
X  };
X} /* end of wclrtoeo */
X
X
X/* wdelch : delete a character on a window */
X/* Does not seem to be used by Moria */
Xint wdelch(w)
XWINDOW *w;
X{
X  int16 *tmpptr3;
X  register int16 *tmpptr1, *tmpptr2; /* temporary pointers for loops */
X
X  tmpptr3 = &(w->_y[w->_cury][w->_maxx]);
X  for (tmpptr1 = &(w->_y[w->_cury][w->_curx]), tmpptr2 = tmpptr1 + 1;
X       tmpptr1 < tmpptr3;
X       tmpptr1++, tmpptr2++)
X    *tmpptr1 = *tmpptr2 | TOUCHED;
X  *tmpptr3 = ' ' | TOUCHED;
X  tmpptr1 = &(w->_y[w->_cury][w->_curx]);
X  if (w == curscr)
X  {
X    /* Clear to end of line */
X    Bconout(2,'\033');
X    Bconout(2,'K');
X    for (; tmpptr1 <= tmpptr3; tmpptr1++)
X    {
X      Bconout(5,(*tmpptr1 & 0xff));
X      _csrx++;
X    };
X    _movcur(w->_cury,w->_curx);
X  }
X  else
X  {
X    if (w->_firstch == NULL)
X    {
X      w->_firstch = tmpptr1;
X      w->_lastch = tmpptr3;
X    }
X    else
X    {
X      if (w->_firstch > tmpptr1)
X        w->_firstch = tmpptr1;
X      if (w->_lastch < tmpptr3)
X        w->_lastch = tmpptr3;
X    };
X  };
X  return(OK);
X} /* end of wdelch */
X
X
X/* wdeleteln : delete a line from a window */
X/* Does not seem to be used by Moria */
Xint wdeleteln(w)
XWINDOW *w;
X{
X  int16 i,j;
X  register int16 **tmpptr1, *tmpptr2, *tmpptr3; 
X  /* temporary pointers for loops */
X
X  for (i = w->_cury + 1, tmpptr1 = &(w->_y[w->_cury]);
X       i <= w->_maxy;
X       i++, tmpptr1++)
X    for (j = 0, tmpptr2 = *tmpptr1, tmpptr3 = *(tmpptr1 + 1);
X         j <= w->_maxx;
X         j++, tmpptr2++, tmpptr3++)
X      *tmpptr2 = *tmpptr3 | TOUCHED;
X  for (tmpptr2 = w->_y[w->_maxy]; tmpptr2 <= w->_yend; tmpptr2++)
X    *tmpptr2 = ' ' | TOUCHED;
X  if (w == curscr)
X  {
X    /* Delete line */
X    Bconout(2,'\033');
X    Bconout(2,'M');
X    _csrx = 0;
X    _movcur(w->_cury,w->_curx);
X  }
X  else
X  {
X    tmpptr2 = w->_y[w->_cury];
X    if (w->_firstch == NULL)
X    {
X      w->_firstch = tmpptr2;
X      w->_lastch = w->_yend;
X    }
X    else
X    {
X      if (w->_firstch > tmpptr2)
X        w->_firstch = tmpptr2;
X      w->_lastch = w->_yend;
X    };
X  };
X  return(OK);
X} /* end of wdeleteln */
X
X
X/* werase : erase a window */
Xvoid werase(w)
Xregister WINDOW *w;
X{
X  register int16 j, **tmpptr1, *tmpptr2;
X
X  for (tmpptr1 = w->_y; *tmpptr1 <= w->_yend; tmpptr1++)
X    for (j = 0, tmpptr2 = *tmpptr1; j <= w->_maxx; j++, tmpptr2++)
X      *tmpptr2 = (' ' | TOUCHED);
X  if (w == curscr)
X  {
X    /* Clear screen and home cursor */
X    Bconout(2,'\033');
X    Bconout(2,'E');
X    _csry = 0;
X    _csrx = 0;
X    _movcur(curscr->_cury,curscr->_curx);
X  }
X  else
X  {
X    w->_firstch = w->_y[0];
X    w->_lastch = w->_yend;
X  };
X} /* end of werase */
X
X
X/* winsch : insert a character */
X/* Does not seem to be used by Moria */
Xint winsch(w,c)
XWINDOW *w;
Xchar c;
X{
X  int16 *tmpptr2, *tmpptr3;
X  register int16 *tmpptr1; /* temporary pointer for loops */
X
X  tmpptr2 = &(w->_y[w->_cury][w->_curx]);
X  tmpptr3 = &(w->_y[w->_cury][w->_maxx]);
X  for (tmpptr1 = tmpptr3; tmpptr1 > tmpptr2; tmpptr1--)
X    *tmpptr1 = *(tmpptr1 - 1) | TOUCHED;
X  if (w == curscr)
X  {
X    /* Clear to end of line */
X    Bconout(2,'\033');
X    Bconout(2,'K');
X    for (tmpptr1 = tmpptr2; tmpptr1 <= tmpptr3; tmpptr1++)
X    {
X      Bconout(5,(*tmpptr1 & 0xff));
X      _csrx++;
X    };
X    _movcur(w->_cury,w->_curx);
X  }
X  else
X  {
X    if (w->_firstch == NULL)
X    {
X      w->_firstch = tmpptr2;
X      w->_lastch = tmpptr3;
X    }
X    else
X    {
X      if (w->_firstch > tmpptr2)
X        w->_firstch = tmpptr2;
X      if (w->_lastch < tmpptr3)
X        w->_lastch = tmpptr3;
X    };
X  };
X  mvwaddch(w,w->_cury,w->_curx,c);
X  return(OK);
X} /* end of winsch */
X
X
X/* winsertln : insert a line in a window */
X/* Does not seem to be used by Moria */
Xvoid winsertln(w)
XWINDOW *w;
X{
X  int16 i, **tmpptr1, **tmpptr2;
X  register int16 j, *tmpptr3, *tmpptr4;
X
X  for (i = w->_maxy - 1, tmpptr1 = &(w->_y[w->_maxy]), 
X       tmpptr2 = &(w->_y[w->_maxy - 1]); i >= w->_cury; 
X       --i, --tmpptr1, --tmpptr2)
X  {
X    for (j = 0, tmpptr3 = *tmpptr1, tmpptr4 = *tmpptr2;
X         j <= w->_maxx; j++, tmpptr3++, tmpptr4++)
X      *tmpptr3 = *tmpptr4 | TOUCHED;
X  };
X  for (j = 0, tmpptr3 = w->_y[w->_cury]; j <= w->_maxx; j++, tmpptr3++)
X    *tmpptr3 = ' ' | TOUCHED;
X  if (w == curscr)
X  {
X    /* Insert line */
X    Bconout(2,'\033');
X    Bconout(2,'L');
X    _csrx = 0;
X    _movcur(w->_cury,w->_curx);
X  }
X  else
X  {
X    if (w->_firstch == NULL)
X      w->_firstch = w->_y[w->_cury];
X    else
X    {
X      if (w->_firstch > w->_y[w->_cury])
X        w->_firstch = w->_y[w->_cury];
X    };
X    w->_lastch = w->_yend;
X  };
X} /* end of winsertln */
X
X
X/* wmove : move the cursor of the window to a location */
Xint wmove(w,y,x)
XWINDOW *w;
Xint y,x;
X{
X  int16 i;
X
X  if (x < 0)
X  {
X    w->_curx = 0;
X    return(ERR);
X  }
X  else
X    if (x > w->_maxx)
X    {
X      w->_curx = w->_maxx;
X      return(ERR);
X    }
X    else
X      w->_curx = x;
X  if (y < 0)
X    {
X      w->_cury = 0;
X      return(ERR);
X    }
X  else
X    if (y > w->_maxy)
X    {
X      if (w->_scroll)
X      {
X        for (i = w->_maxy; i < y; i++)
X          scroll(w);
X      };
X      w->_cury = w->_maxy;
X      return(ERR);
X    }
X    else
X      w->_cury = y;
X  if (w == curscr)
X    _movcur(y,x);
X  return(OK);
X} /* end of wmove */
X
X
X/* overlay: overlay two windows, ie : copy all non-space chars of v     */
X/* onto the corresponding char of w.                                    */
X/* Does not seem to be used by Moria */
Xvoid overlay(v,w)
XWINDOW *v, *w;
X{
X  int16 i, j;
X  /* temporary pointers for loops */
X  register int16 **tmpptr1, **tmpptr2, *tmpptr3, *tmpptr4;
X
X  for (i = 0, tmpptr1 = v->_y, tmpptr2 = w->_y;
X       i <= v->_maxy && i <= w->_maxy;
X       i++, tmpptr1++, tmpptr2++)
X    for (j = 0, tmpptr3 = *tmpptr1, tmpptr4 = *tmpptr2;
X         j <= v->_maxx && j <= w->_maxx;
X         j++, tmpptr3++, tmpptr4++)
X      if ((*tmpptr3 & 0xff) != 0x20)
X        *tmpptr4 = *tmpptr3 | TOUCHED;
X  if (w == curscr)
X    wrefresh(curscr);
X  else
X  {
X    w->_firstch = w->_y[0];
X    w->_lastch = w->_yend;
X  };
X} /* end of overlay */
X
X
X/* overwrite : overwrite two windows. */
Xvoid overwrite(v,w)
XWINDOW *v, *w;
X{
X  int16 j;
X  /* temporary pointers for loops */
X  register int16 **tmpptr1, **tmpptr2, *tmpptr3, *tmpptr4;
X
X  for (tmpptr1 = w->_y, tmpptr2 = v->_y;
X       *tmpptr1 <= w->_yend && *tmpptr2 <= v->_yend;
X       tmpptr1++, tmpptr2++)
X    for (j = 0, tmpptr3 = *tmpptr1, tmpptr4 = *tmpptr2;
X         j <= w->_maxx && j <= v->_maxx;
X         j++, tmpptr3++, tmpptr4++)
X      *tmpptr3 = *tmpptr4 | TOUCHED;
X  if (w == curscr)
X    wrefresh(curscr);
X  else
X  {
X    w->_firstch = w->_y[0];
X    w->_lastch = w->_yend;
X  };
X} /* end of overwrite */
X
X
X/* wstandout : set the standout flag for a window */
X/* In the real curses, this returns FALSE or a pointer to a capability flag.
X   Right here, it is a void function. */
Xvoid wstandout(w)
XWINDOW *w;
X{
X  w->_flags |= _STANDOUT;
X} /* end of wstandout */
X
X
X/* wstandend : end standout mode */
X/* In the real curses, this returns FALSE or a pointer to a capability flag.
X   Right here, it is a void function. */
Xvoid wstandend(w)
XWINDOW *w;
X{
X  w->_flags &= ~_STANDOUT;
X} /* end of wstandend */
X
X
X/* raw : set terminal in raw mode */
X/* Does not seem to be used by Moria */
Xvoid raw()
X{
X  /*
X  * raw mode means :
X  * when getting a character from the keyboard, return everything
X  * including keyboard shift state.
X  */
X  /* Note on RAW / COOKED / CBREAK : CBREAK mode has been cut out. */
X  /* RAW means    : full return of getch() values.                 */
X  /* COOKED means : return lower byte of getch() values only.      */
X  
X  _modinp = RAW;
X} /* end of raw */
X
X
X/* noraw : reset terminal from raw mode into cooked mode */
Xvoid noraw()
X{
X  /* See note above for RAW / COOKED / CBREAK */
X  _modinp = COOKED;
X} /* end of noraw */
X
X
X/* crmode: set terminal in cbreak mode */
X/* Note that CBREAK mode has been cut out - CBREAK now is the same as RAW */
X/* This had been done to avoid having programs quit when pressing CTRL-C. */
Xvoid crmode()
X{
X  _modinp = CBREAK;
X} /* end of crmode */
X
X
X/* nocrmode : reset terminal from cbreak into cooked mode */
Xvoid nocrmode()
X{
X  _modinp = COOKED;
X} /* end of nocrmode */
X
X
X/* echo : set curses to echo characters on input */
Xvoid echo()
X{
X  _doecho = TRUE;
X} /* end of echo */
X
X
X/* noecho : set curses not to echo characters on input */
Xvoid noecho()
X{
X  _doecho = FALSE;
X} /* end of noecho */
X
X
X/* wgetch : get a character from the terminal */
X/* WARNING : wgetch returns a 32-bit value, not a char although only */
X/* the lowest 8 bits may actually be transmitted. */
X/* Watch out for this bit of skulduggery : while getch is defined as */
X/* wgetch in the main program, in this routine wgetch makes use of   */
X/* getch. The difference between getch and wgetch is that wgetch     */
X/* displays a cursor and echoes (if wished) the input character.     */
X/* The cbreak mode has been cut out as I dislike being thrown out of */
X/* a program if I accidentally press CTRL-C.                         */
Xlong wgetch(w)
XWINDOW *w;
X{
X  int32 retval;
X
X  /* Show cursor */
X  Bconout(2,'\033');
X  Bconout(2,'e');
X  retval = getch();
X  if (_modinp == COOKED)
X    retval &= 0x00ff;
X  /* Hide cursor */
X  Bconout(2,'\033');
X  Bconout(2,'f');
X  if (_doecho)
X    waddch(w,(char)(0x00ff & retval));
X  return(retval);
X} /* end of wgetch */
X
X
X/* wgetstr : get a string from the terminal */
X/* I do not know whether this really works. The if's seem wrong to me - HB */
X/* Does not seem to be used by Moria */
Xint wgetstr(w,s)
XWINDOW *w;
Xchar   *s;
X{
X  int16 ox, oy;
X  bool reset, end;
X  char c;
X  int i;
X
X  reset = FALSE;
X  getyx(w,oy,ox);
X  if (_modinp == COOKED && _doecho == TRUE)
X  {
X    reset = TRUE;
X    _doecho = FALSE;
X  };
X  i = 0;
X  for (end = FALSE; !end; i++)
X  {
X    switch (_modinp)
X    {
X      case COOKED:
X        c = (char) wgetch(w);
X        if (c != 0x0d && c != 0x0a && c != 0x04 && c != 0)
X        {
X          s[i] = '\0';
X          end = TRUE;
X          break;
X        };
X        /* receive a backspace */
X        if (c == 0x08)
X        {
X          if (i != 0)
X          {
X            --i;
X            s[i] = 0;
X            if (reset)
X            mvwaddstr(w,oy,ox,s);
X          };
X          break;
X        };
X        /* receive control U or line kill */
X        if (c == 0x13)
X        {
X          i = 0;
X          if (reset)
X          wmove(w,oy,ox);
X          break;
X        };
X        s[i] = c;
X        if (reset)
X          waddch(w,c);
X        break;
X      case CBREAK:
X        c = (char) wgetch(w);
X        if (c != 0x0d && c != 0x0a && c != 0x04 && c != 0)
X        {
X          s[i] = '\0';
X          end = TRUE;
X          break;
X        };
X        s[i] = c;
X        break;
X      case RAW:
X        c = (char) wgetch(w);
X        if (c != 0x0d && c != 0x0a && c != 0x04 && c != 0)
X        {
X          s[i] = '\0';
X          end = TRUE;
X          break;
X        };
X        s[i] = c;
X        break;
X    };
X  };
X  if (reset)
X  _doecho = TRUE;
X  return(OK);
X} /* end of wgetstr */
X
X
X/* cur_refresh : refresh the current screen only. This is a simple and */
X/* relatively dumb routine that is called from wrefresh() only.        */
Xvoid cur_refresh()
X{
X  register int16 i, j, **tmpptr1, *tmpptr2;
X  
X  for (i = 0, tmpptr1 = curscr->_y; i < LINES; i++, tmpptr1++)
X  {
X    _movcur(i,0);
X    for (j = 0, tmpptr2 = *tmpptr1; j < COLS; j++ ,tmpptr2++)
X    {
X      if ((*tmpptr2 & STANDOUT))
X      {
X        /* reverse on */
X        Bconout(2,'\033');
X        Bconout(2,'p');
X        Bconout(5,(*tmpptr2 & 0xff));
X        /* reverse off */
X        Bconout(2,'\033');
X        Bconout(2,'q');
X      }
X      else
X        Bconout(5,(*tmpptr2 & 0xff));
X      _csrx++;
X    };
X  };
X  _movcur(curscr->_cury, curscr->_curx);
X} /* end of cur_refresh */
X
X/* wrefresh (new version) : refresh a window on the screen            */
X/* This should be an int function and return ERR or OK; but as Moria  */
X/* expects to see the void version, that's what it is.                */
X/* Sorry if you find this routine a bit hard to understand, what with */
X/* the pointer stuff and all that. If you have any problems, please   */
X/* read the comments on the data structure above. wrefresh() prints   */
X/* all chars marked as TOUCHED and different from the current curscr. */
X/* It also removes all TOUCHED marks from the window. If you like a   */
X/* good bit of horror, then look below this routine : the original    */
X/* source appears below (commented out). Enjoy the original code !    */
Xvoid wrefresh(w)
Xregister WINDOW *w;
X{
X           int16 **winptr1, **curptr1, curline, c;
X  register int16 *winptr2, *curptr2, curpos, linelength;
X
X  if (w == curscr)
X  {
X    if (w->_clear)
X    {
X      werase(w);
X      w->_clear = FALSE;
X      /* next statement is return at end of routine */
X    }
X    else
X    {
X      cur_refresh(); /* dumb routine : refresh the current screen */
X      /* next statement is return at end of routine */
X    }
X  }
X  else /* ie : w != curscr */
X  {
X    if (curscr->_clear)
X    {
X      werase(curscr);
X      curscr->_clear = FALSE;
X      /* Note that both curscr and w might have _clear set; so reset */
X      /* w->_clear too, or it might affect the next wrefresh() call. */
X      w->_clear = FALSE;
X    }
X    else /* ie : w != curscr and !curscr->_clear */
X    {
X      if (w->_clear)
X      {
X        /* no need to actually clear the curscr; just touch window w. This */
X        /* will set w->_firstch to the beginning of w, w->_lastch to the   */
X        /* end of w, and make all characters touched. This will ensure all */
X        /* characters of w that differ from curscr will be printed,        */
X        /* whether window w is the size of curscr or not.                  */
X        touchwin(w);
X        w->_clear = FALSE;
X      }
X    }
X    /* Copy all chars from _firstch to _lastch and print them.           */
X    /* curline : current line in curscr - initial value is first line    */
X    /* curpos : current char in curscr - initial value is first char     */
X    /* winptr1, curptr1 : pointer to current line in window, curscr      */
X    /* winptr2, curptr2 : pointer to current char in window, curscr      */
X    if (w->_firstch == NULL) /* ie : no changes */
X    {
X      curscr->_cury = w->_cury + w->_begy;
X      curscr->_curx = w->_curx + w->_begx;
X      _movcur(curscr->_cury, curscr->_curx);
X      /* next statement is return */
X    }
X    else /* w->_firstch != NULL : changes have appeared */
X    {
X      curline = (int16) ((w->_firstch - w->_y[0]) / (w->_maxx + 1));
X      winptr1 = &(w->_y[curline]);
X      winptr2 = w->_firstch;
X      curline += w->_begy;
X      curptr1 = &(curscr->_y[curline]);
X      curpos = (winptr2 - *winptr1) + w->_begx;
X      /* Sorry about the parentheses below - they are necessary. */
X      /* curptr2 is the address of word nr curpos in the line that */
X      /* curptr1 points to - ie curptr2 = curscr->_y[curline][curpos] */
X      curptr2 = &((*curptr1)[curpos]);
X      linelength = w->_maxx + w->_begx;
X      if (linelength > COLS)
X        linelength = COLS;
X      while (winptr2 <= w->_lastch)
X      {
X        if (*winptr2 & TOUCHED)
X        {
X          /* logical AND *winptr2 with 0x01ff, which is ~TOUCHED plus the */
X          /* the unused bits above TOUCHED that might accidentally be set */
X          /* by the processor. Would AND with ~TOUCHED were it not that I */
X          /* need to AND c with 0x01ff anyway - this way saves some time. */
X          c = (*winptr2 &= 0x01ff);
X          if ((*curptr2 & 0x01ff) != c)
X          {
X            *curptr2 = c;
X            _movcur(curline,curpos);
X            /* Note that _movcur sets _csrx to curpos and _csry to curline */
X            if ((c & STANDOUT))
X            {
X              /* reverse on */
X              Bconout(2,'\033');
X              Bconout(2,'p');
X              Bconout(5,(c & 0xff));
X              /* reverse off */
X              Bconout(2,'\033');
X              Bconout(2,'q');
X            }
X            else
X              Bconout(5,(c & 0xff));
X            /* We just printed a char, so cursor pos. has changed - also */
X            /* change _csrx. (_csry still is correct.)                   */
X            _csrx++;
X          }; /* end of if chars are different on window and curscr */
X        }; /* end of if TOUCHED char */
X        /* Now update all counters for next loop of while */
X        if ((++curpos) <= linelength)
X        {
X          /* line not yet finished */
X          winptr2++;
X          curptr2++;
X        }
X        else
X        {
X          /* line finished - goto next line --> update all counters */
X          curpos = w->_begx;
X          winptr2 = *(++winptr1);
X          curptr1++;
X          /* curptr2 is the address of word nr curpos in the line that */
X          /* the just increased curptr1 points to. */
X          /* Sorry about the parentheses - they are necessary here. */
X          curptr2 = &((*curptr1)[curpos]);
X          curline++;
X        }
X      }; /* end of while */
X      w->_firstch = NULL;
X      w->_lastch = NULL;
X      if (w->_leave)
X      {
X        w->_curx = _csrx - w->_begx;
X        w->_cury = _csry - w->_begy;
X        curscr->_cury = _csry;
X        curscr->_curx = _csrx;
X      }
X      else
X      {
X        curscr->_cury = w->_cury + w->_begy;
X        curscr->_curx = w->_curx + w->_begx;
X        _movcur(curscr->_cury, curscr->_curx);
X      };
X    }
X  } /* End of else : w != curscr */
X  return;
X} /* end of wrefresh : new version */
X
X
X/* HORROR CODE STARTS HERE - NOT FOR SENSITIVE PROGRAMMERS OR YOUNGSTERS  */
X/* As promised above, the original wrefresh() code. The only changes that */
X/* have been made are in the tabs and { } placement. This code does OK on */
X/* just one or two changed chars, but is far too slow on a whole screen.  */
X/* #[wrefresh: refresh a window on the screen */
X/* commenting out starts here
Xvoid wrefresh(w)
XWINDOW *w ;
X{
X  WORD i,j,k,l ;
X  WORD c, *ptr ;
X
X  ERR = 0 ;
X  OK = 1 ;
X  if ( w != curscr && curscr->_clear )
X  {
X    Bconout(2,'\033') ;
X    Bconout(2,'E') ;
X    _csry = 0 ;
X    _csrx = 0 ;
X    for ( i = 0 ; i < LINES ; i++ )
X    {
X      for ( j = 0 ; j < COLS ; j++ )
X        curscr->_y[i][j] = ' ' ;
X    } ;
X    curscr->_clear = 0 ;
X  } ;
X  if ( w->_clear )
X  {
X    if ( ( w->_flags & _FULLWIN ) )
X    {
X      Bconout(2,'\033') ;
X      Bconout(2,'E') ;
X      _csry = 0 ;
X      _csrx = 0 ;
X      for ( i = 0 ; i < LINES ; i++ )
X      {
X        for ( j = 0 ; j < COLS ; j++ )
X          curscr->_y[i][j] = ' ' ;
X      } ;
X    } ;
X    w->_firstch = w->_y[0] ;
X    w->_lastch = &(w->_y[w->_maxy][w->_maxx]) ;
X    w->_clear = 0 ;
X  } ;
X  if ( w != curscr )
X  {
X    if ( w->_firstch != 0 )
X    {
X      if ( w->_flags & _SUBWIN )
X      {
X        for ( i = 0 ; i <= w->_maxy ; i++ )
X        {
X          ptr = w->_y[i] ;
X          if ( ptr >= w->_firstch && ptr <= w->_lastch )
X          {
X            for ( j = 0 ; j <= w->_maxx ; j++ )
X            {
X              c = ptr[j] ;
X              k = i + w->_begy ;
X              l = j + w->_begx ;
X              if ( ( c & TOUCHED ) && ( k >= 0 && k < LINES && l >= 0 
X                    && l < COLS ) )
X              {
X                ptr[j] = c & ~TOUCHED ;
X                if ( ( curscr->_y[k][l] & 0x01ff ) != ( c & 0x01ff ) )
X                {
X                  curscr->_y[k][l] = c ;
X                  _movcur(k,l) ;
X                  if ( ( c & STANDOUT ) )
X                  {
X                    Bconout(2,'\033') ;
X                    Bconout(2,'p') ;
X                    Bconout(5,(c & 0xff)) ;
X                    Bconout(2,'\033') ;
X                    Bconout(2,'q') ;
X                  }
X                  else
X                  {
X                    Bconout(5,( c & 0xff )) ;
X                  } ;
X                  _csry = k ;
X                  _csrx = l + 1 ;
X                } ;
X              } ;
X            } ;
X          } ;
X        } ;
X      }
X      else
X      {
X        for ( ptr = w->_firstch ; ptr <= w->_lastch ; ptr++ )
X        {
X          c = *ptr ;
X          if ( c & TOUCHED )
X          {
X            k = ( WORD ) ( ptr - w->_y[0] ) ;
X            k = k / (  w->_maxx + 1 ) ;
X            l = ( WORD ) ( ptr - w->_y[k] ) + w->_begx ;
X            k = k + w->_begy ;
X            if ( k >= 0 && k < LINES && l >= 0 && l < COLS )
X            {
X              *ptr = c & ~TOUCHED ;
X              if ( ( curscr->_y[k][l] & 0x01ff ) != ( c & 0x01ff ) )
X              {
X                curscr->_y[k][l] = c ;
X                _movcur(k,l) ;
X                if ( ( c & STANDOUT ) )
X                {
X                  Bconout(2,'\033') ;
X                  Bconout(2,'p') ;
X                  Bconout(5,(c & 0xff)) ;
X                  Bconout(2,'\033') ;
X                  Bconout(2,'q') ;
X                }
X                else
X                {
X                  Bconout(5,( c & 0xff )) ;
X                } ;
X                _csry = k ;
X                _csrx = l + 1 ;
X              } ;
X            } ;
X          } ;
X        } ;
X      } ;
X      w->_firstch = 0 ;
X      w->_lastch = 0 ;
X      if ( w->_leave )
X      {
X        w->_curx = _csrx - w->_begx ;
X        w->_cury = _csry - w->_begy ;
X        curscr->_cury = _csry ;
X        curscr->_curx = _csrx ;
X      }
X      else
X      {
X        curscr->_cury = w->_cury + w->_begy ;
X        curscr->_curx = w->_curx + w->_begx ;
X        _movcur(curscr->_cury, curscr->_curx) ;
X      } ;
X    }
X    else
X    {
X      curscr->_cury = w->_cury + w->_begy ;
X      curscr->_curx = w->_curx + w->_begx ;
X      _movcur(curscr->_cury, curscr->_curx) ;
X    } ;
X  }
X  else
X  {
X    Bconout(2,'\033') ;
X    Bconout(2,'H') ;
X    _csry = 0 ;
X    _csrx = 0 ;
X    for ( i = 0 ; i < LINES ; i++ )
X    {
X      for ( j = 0 ; j < COLS ; j++ )
X      {
X        c = w->_y[i][j] ;
X        if ( ( c & STANDOUT ) )
X        {
X          Bconout(2,'\033') ;
X          Bconout(2,'p') ;
X          Bconout(5,(c & 0xff)) ;
X          Bconout(2,'\033') ;
X          Bconout(2,'q') ;
X        }
X        else
X        {
X          Bconout(5,(c & 0xff)) ;
X        } ;
X        _csrx++ ;
X      } ;
X      _movcur(i+1,0) ;
X    } ;
X    _movcur( curscr->_cury, curscr->_curx) ;
X  } ;
X}
XEnd of commenting out */
X/* #]wrefresh: */
X/* END OF HORROR CODE - CHILDREN CAN OPEN THEIR EYES NOW */
X
X
X/* mvcur : move cursor in standard curses manner */
X/* Does not seem to be used by Moria */
Xvoid mvcur(ly,lx,ny,nx)
Xint ly,lx,ny,nx;
X{
X  _movcur((int16) ny,(int16) nx);
X} /* end of mvcur */
X
X
X/* _movcur : move cursor */
Xvoid _movcur(y,x)
Xregister int16 y,x;
X{
X  if (_csry == y && _csrx == x)
X    return;
X  /* Set cursor position */
X  Bconout(2,'\033');
X  Bconout(2,'Y');
X  Bconout(2,y + ' ');
X  Bconout(2,x + ' ');
X  _csry = y;
X  _csrx = x;
X} /* end of _movcur */
X
X
X/* scroll : scroll a window upward one line */
Xint scroll(w)
XWINDOW *w;
X{
X           int16 **tmpptr1, **tmpptr2;
X  register int16 j, *tmpptr3, *tmpptr4; /* temp pointers for loops */
X
X  for (tmpptr1 = w->_y, tmpptr2 = &(w->_y[1]);
X       *tmpptr2 < w->_yend; 
X       tmpptr1++, tmpptr2++)
X  {
X    for (j = 0, tmpptr3 = *tmpptr1, tmpptr4 = *tmpptr2;
X         j <= w->_maxx;
X         j++, tmpptr3++, tmpptr4++)
X    {
X      *tmpptr3 = *tmpptr4;
X    }
X  }
X  for (tmpptr3 = w->_y[w->_maxy]; tmpptr3 <= w->_yend; tmpptr3++)
X    *tmpptr3 = ' ';
X  if (w == curscr)
X    wrefresh(curscr);
X  else
X  {
X    w->_firstch = w->_y[0];
X    w->_lastch = w->_yend;
X  };
X  return(OK);
X} /* end of scroll */
X/* end of the curses source */
END_OF_FILE
if test 41529 -ne `wc -c <'atari_st/curscomp/curses.c'`; then
    echo shar: \"'atari_st/curscomp/curses.c'\" unpacked with wrong size!
fi
# end of 'atari_st/curscomp/curses.c'
fi
if test -f 'shortnam.sed' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'shortnam.sed'\"
else
echo shar: Extracting \"'shortnam.sed'\" \(11015 characters\)
sed "s/^X//" >'shortnam.sed' <<'END_OF_FILE'
Xs/CM_CARRY_GOLD/ACM_CARRY_GOLD/g
Xs/CM_CARRY_OBJ/BCM_CARRY_OBJ/g
Xs/CS_BR_FIRE/ACS_BR_FIRE/g
Xs/CS_BR_FROST/BCS_BR_FROST/g
Xs/CS_SUMMON_MON/ACS_SUMMON_MON/g
Xs/CS_SUMMON_UND/BCS_SUMMON_UND/g
Xs/CS_TEL_LONG/ACS_TEL_LONG/g
Xs/CS_TEL_SHORT/BCS_TEL_SHORT/g
Xs/CS_TEL_TO/CCS_TEL_TO/g
Xs/CUR_VERSION_MAJ/ACUR_VERSION_MAJ/g
Xs/CUR_VERSION_MIN/BCUR_VERSION_MIN/g
Xs/DUN_STR_DEN/ADUN_STR_DEN/g
Xs/DUN_STR_MAG/BDUN_STR_MAG/g
Xs/DUN_STR_MC/CDUN_STR_MC/g
Xs/DUN_STR_QC/DDUN_STR_QC/g
Xs/DUN_STR_QUA/EDUN_STR_QUA/g
Xs/DUN_STR_RNG/FDUN_STR_RNG/g
Xs/DUN_TUN_CHG/ADUN_TUN_CHG/g
Xs/DUN_TUN_CON/BDUN_TUN_CON/g
Xs/DUN_TUN_JCT/CDUN_TUN_JCT/g
Xs/DUN_TUN_PEN/DDUN_TUN_PEN/g
Xs/DUN_TUN_RND/EDUN_TUN_RND/g
Xs/ID_SHOW_HITDAM/AID_SHOW_HITDAM/g
Xs/ID_SHOW_P1/BID_SHOW_P1/g
Xs/INVEN_ARM/AINVEN_ARM/g
Xs/INVEN_ARRAY_SIZE/BINVEN_ARRAY_SIZE/g
Xs/INVEN_AUX/CINVEN_AUX/g
Xs/INVEN_HANDS/AINVEN_HANDS/g
Xs/INVEN_HEAD/BINVEN_HEAD/g
Xs/INVEN_LEFT/AINVEN_LEFT/g
Xs/INVEN_LIGHT/BINVEN_LIGHT/g
Xs/ITEM_GROUP_MAX/AITEM_GROUP_MAX/g
Xs/ITEM_GROUP_MIN/BITEM_GROUP_MIN/g
Xs/ITEM_NEVER_STACK_MAX/AITEM_NEVER_STACK_MAX/g
Xs/ITEM_NEVER_STACK_MIN/BITEM_NEVER_STACK_MIN/g
Xs/ITEM_SINGLE_STACK_MAX/AITEM_SINGLE_STACK_MAX/g
Xs/ITEM_SINGLE_STACK_MIN/BITEM_SINGLE_STACK_MIN/g
Xs/MAX_CAVE_FLOOR/AMAX_CAVE_FLOOR/g
Xs/MAX_CAVE_ROOM/BMAX_CAVE_ROOM/g
Xs/MAX_MALLOC/AMAX_MALLOC/g
Xs/AMAX_MALLOC_CHANCE/BMAX_MALLOC_CHANCE/g
Xs/MAX_MONS_LEVEL/AMAX_MONS_LEVEL/g
Xs/MAX_MON_MULT/BMAX_MON_MULT/g
Xs/MAX_MON_NATTACK/CMAX_MON_NATTACK/g
Xs/MAX_OBJECTS/AMAX_OBJECTS/g
Xs/MAX_OBJ_LEVEL/BMAX_OBJ_LEVEL/g
Xs/MIN_MALLOC_LEVEL/AMIN_MALLOC_LEVEL/g
Xs/MIN_MALLOC_TD/BMIN_MALLOC_TD/g
Xs/MIN_MALLOC_TN/CMIN_MALLOC_TN/g
Xs/MORIA_HELP/AMORIA_HELP/g
Xs/MORIA_HOU/BMORIA_HOU/g
Xs/MORIA_ORIG_HELP/AMORIA_ORIG_HELP/g
Xs/MORIA_OWIZ_HELP/BMORIA_OWIZ_HELP/g
Xs/MORIA_SAV/AMORIA_SAV/g
Xs/AMORIA_SAVE/BMORIA_SAVE/g
Xs/AMORIA_SAV_NAME/CMORIA_SAV_NAME/g
Xs/MORIA_TOP/AMORIA_TOP/g
Xs/AMORIA_TOP_NAME/BMORIA_TOP_NAME/g
Xs/MORIA_WELCOME/AMORIA_WELCOME/g
Xs/MORIA_WIZ_HELP/BMORIA_WIZ_HELP/g
Xs/NORMAL_TABLE_SD/ANORMAL_TABLE_SD/g
Xs/NORMAL_TABLE_SIZE/BNORMAL_TABLE_SIZE/g
Xs/OBJ_BASE_MAGIC/AOBJ_BASE_MAGIC/g
Xs/OBJ_BASE_MAX/BOBJ_BASE_MAX/g
Xs/OBJ_DIV_CURSED/AOBJ_DIV_CURSED/g
Xs/OBJ_DIV_SPECIAL/BOBJ_DIV_SPECIAL/g
Xs/OBJ_STD_ADJ/AOBJ_STD_ADJ/g
Xs/OBJ_STD_MIN/BOBJ_STD_MIN/g
Xs/PLAYER_EXIT_PAUSE/APLAYER_EXIT_PAUSE/g
Xs/PLAYER_FOOD_ALERT/BPLAYER_FOOD_ALERT/g
Xs/PLAYER_FOOD_FAINT/CPLAYER_FOOD_FAINT/g
Xs/PLAYER_FOOD_FULL/DPLAYER_FOOD_FULL/g
Xs/PLAYER_FOOD_MAX/EPLAYER_FOOD_MAX/g
Xs/PLAYER_FOOD_WEAK/FPLAYER_FOOD_WEAK/g
Xs/PLAYER_REGEN_FAINT/GPLAYER_REGEN_FAINT/g
Xs/PLAYER_REGEN_HPBASE/HPLAYER_REGEN_HPBASE/g
Xs/PLAYER_REGEN_MNBASE/IPLAYER_REGEN_MNBASE/g
Xs/PLAYER_REGEN_NORMAL/JPLAYER_REGEN_NORMAL/g
Xs/PLAYER_REGEN_WEAK/KPLAYER_REGEN_WEAK/g
Xs/PLAYER_WEIGHT_CAP/LPLAYER_WEIGHT_CAP/g
Xs/SCREEN_HEIGHT/ASCREEN_HEIGHT/g
Xs/SCREEN_WIDTH/BSCREEN_WIDTH/g
Xs/SN_SLAYING/ASN_SLAYING/g
Xs/SN_SLAY_ANIMAL/BSN_SLAY_ANIMAL/g
Xs/SN_SLAY_EVIL/CSN_SLAY_EVIL/g
Xs/SN_SLOWNESS/ASN_SLOWNESS/g
Xs/SN_SLOW_DESCENT/BSN_SLOW_DESCENT/g
Xs/STORE_MAX_INVEN/ASTORE_MAX_INVEN/g
Xs/STORE_MIN_INVEN/BSTORE_MIN_INVEN/g
Xs/TR_RES_ACID/ATR_RES_ACID/g
Xs/TR_RES_COLD/BTR_RES_COLD/g
Xs/TR_RES_FIRE/CTR_RES_FIRE/g
Xs/TR_RES_LIGHT/DTR_RES_LIGHT/g
Xs/TR_SLAY_ANIMAL/ATR_SLAY_ANIMAL/g
Xs/TR_SLAY_DRAGON/BTR_SLAY_DRAGON/g
Xs/TR_SLAY_EVIL/CTR_SLAY_EVIL/g
Xs/TR_SLAY_UNDEAD/DTR_SLAY_UNDEAD/g
Xs/TV_MAX_ENCHANT/ATV_MAX_ENCHANT/g
Xs/TV_MAX_OBJECT/BTV_MAX_OBJECT/g
Xs/TV_MAX_PICK_UP/CTV_MAX_PICK_UP/g
Xs/TV_MAX_VISIBLE/DTV_MAX_VISIBLE/g
Xs/TV_MAX_WEAR/ETV_MAX_WEAR/g
Xs/TV_MIN_DOORS/ATV_MIN_DOORS/g
Xs/TV_MIN_ENCHANT/BTV_MIN_ENCHANT/g
Xs/TV_MIN_VISIBLE/CTV_MIN_VISIBLE/g
Xs/TV_MIN_WEAR/DTV_MIN_WEAR/g
Xs/TV_POTION1/ATV_POTION1/g
Xs/TV_POTION2/BTV_POTION2/g
Xs/TV_SCROLL1/ATV_SCROLL1/g
Xs/TV_SCROLL2/BTV_SCROLL2/g
Xs/WIN_MON_APPEAR/AWIN_MON_APPEAR/g
Xs/WIN_MON_TOT/BWIN_MON_TOT/g
Xs/aggravate/Aaggravate/g
Xs/Aaggravate_monster/Baggravate_monster/g
Xs/attack_blows/Aattack_blows/g
Xs/attack_desc/Battack_desc/g
Xs/attack_dice/Cattack_dice/g
Xs/attack_sides/Dattack_sides/g
Xs/attack_type/Eattack_type/g
Xs/background/Abackground/g
Xs/Abackground_type/Bbackground_type/g
Xs/change_character/Achange_character/g
Xs/change_name/Bchange_name/g
Xs/change_speed/Cchange_speed/g
Xs/change_trap/Dchange_trap/g
Xs/character_generated/Acharacter_generated/g
Xs/character_saved/Bcharacter_saved/g
Xs/confuse_monster/Aconfuse_monster/g
Xs/confused/Bconfused/g
Xs/create_character/Acreate_character/g
Xs/create_food/Bcreate_food/g
Xs/creature_type/Acreature_type/g
Xs/creatures/Bcreatures/g
Xs/default_dir/Adefault_dir/g
Xs/default_signals/Bdefault_signals/g
Xs/delete_monster/Adelete_monster/g
Xs/delete_object/Bdelete_object/g
Xs/detect_evil/Adetect_evil/g
Xs/detect_inv/Bdetect_inv/g
Xs/detect_inv2/Cdetect_inv2/g
Xs/detect_invisible/Ddetect_invisible/g
Xs/detect_monsters/Edetect_monsters/g
Xs/detect_object/Fdetect_object/g
Xs/detect_sdoor/Gdetect_sdoor/g
Xs/detect_trap/Hdetect_trap/g
Xs/detect_treasure/Idetect_treasure/g
Xs/disarm_all/Adisarm_all/g
Xs/disarm_trap/Bdisarm_trap/g
Xs/insert_lnum/Ainsert_lnum/g
Xs/insert_num/Binsert_num/g
Xs/insert_str/Cinsert_str/g
Xs/insult_cur/Ainsult_cur/g
Xs/insult_max/Binsult_max/g
Xs/inven_carry/Ainven_carry/g
Xs/inven_check_num/Binven_check_num/g
Xs/inven_check_weight/Cinven_check_weight/g
Xs/inven_command/Dinven_command/g
Xs/inven_ctr/Einven_ctr/g
Xs/inven_damage/Ainven_damage/g
Xs/inven_destroy/Binven_destroy/g
Xs/inven_drop/Cinven_drop/g
Xs/inven_throw/Ainven_throw/g
Xs/inven_type/Binven_type/g
Xs/log_max_dlv/Alog_max_dlv/g
Xs/log_max_exp/Blog_max_exp/g
Xs/magic_shop/Amagic_shop/g
Xs/magic_spell/Bmagic_spell/g
Xs/max_panel_cols/Amax_panel_cols/g
Xs/max_panel_rows/Bmax_panel_rows/g
Xs/monster_attacks/Amonster_attacks/g
Xs/monster_death/Bmonster_death/g
Xs/monster_name/Cmonster_name/g
Xs/monster_type/Dmonster_type/g
Xs/move_cursor/Amove_cursor/g
Xs/Amove_cursor_relative/Bmove_cursor_relative/g
Xs/msdos_init/Amsdos_init/g
Xs/msdos_intro/Bmsdos_intro/g
Xs/next_to_corr/Anext_to_corr/g
Xs/next_to_wall/Bnext_to_wall/g
Xs/next_to_walls/Cnext_to_walls/g
Xs/object_ident/Aobject_ident/g
Xs/object_list/Bobject_list/g
Xs/panel_col/Apanel_col/g
Xs/Apanel_col_max/Bpanel_col_max/g
Xs/Apanel_col_min/Cpanel_col_min/g
Xs/Apanel_col_prt/Dpanel_col_prt/g
Xs/panel_contains/Epanel_contains/g
Xs/panel_row/Apanel_row/g
Xs/Apanel_row_max/Bpanel_row_max/g
Xs/Apanel_row_min/Cpanel_row_min/g
Xs/Apanel_row_prt/Dpanel_row_prt/g
Xs/player_exp/Aplayer_exp/g
Xs/player_hp/Bplayer_hp/g
Xs/player_init/Cplayer_init/g
Xs/player_light/Dplayer_light/g
Xs/player_saves/Eplayer_saves/g
Xs/player_type/Fplayer_type/g
Xs/protect_evil/Aprotect_evil/g
Xs/protection/Bprotection/g
Xs/prt_stat/Aprt_stat/g
Xs/Aprt_stat_block/Bprt_stat_block/g
Xs/Aprt_state/Cprt_state/g
Xs/put_misc1/Aput_misc1/g
Xs/put_misc2/Bput_misc2/g
Xs/put_misc3/Cput_misc3/g
Xs/remove_curse/Aremove_curse/g
Xs/remove_fear/Bremove_fear/g
Xs/resist_cold/Aresist_cold/g
Xs/resist_heat/Bresist_heat/g
Xs/restore_level/Arestore_level/g
Xs/restore_screen/Brestore_screen/g
Xs/restore_signals/Crestore_signals/g
Xs/restore_term/Drestore_term/g
Xs/screen_change/Ascreen_change/g
Xs/screen_map/Bscreen_map/g
Xs/search_flag/Asearch_flag/g
Xs/search_off/Bsearch_off/g
Xs/search_on/Csearch_on/g
Xs/set_acid_affect/Aset_acid_affect/g
Xs/set_acid_destroy/Bset_acid_destroy/g
Xs/set_corr/Aset_corr/g
Xs/Aset_corrodes/Bset_corrodes/g
Xs/sleep_monster/Asleep_monster/g
Xs/Asleep_monsters1/Bsleep_monsters1/g
Xs/Asleep_monsters2/Csleep_monsters2/g
Xs/speed_monster/Aspeed_monster/g
Xs/Aspeed_monsters/Bspeed_monsters/g
Xs/store_bought/Astore_bought/g
Xs/Astore_bought_p/Bstore_bought_p/g
Xs/store_buy/Cstore_buy/g
Xs/store_carry/Astore_carry/g
Xs/store_check_num/Bstore_check_num/g
Xs/store_choice/Cstore_choice/g
Xs/store_ctr/Dstore_ctr/g
Xs/store_init/Astore_init/g
Xs/store_inven/Bstore_inven/g
Xs/summon_monster/Asummon_monster/g
Xs/summon_object/Bsummon_object/g
Xs/summon_undead/Csummon_undead/g
Xs/sustain_chr/Asustain_chr/g
Xs/sustain_con/Bsustain_con/g
Xs/sustain_dex/Csustain_dex/g
Xs/sustain_int/Dsustain_int/g
Xs/sustain_str/Esustain_str/g
Xs/sustain_wis/Fsustain_wis/g
Xs/td_destroy/Atd_destroy/g
Xs/Atd_destroy2/Btd_destroy2/g
Xs/teleport/Ateleport/g
Xs/Ateleport_away/Bteleport_away/g
Xs/Ateleport_flag/Cteleport_flag/g
Xs/Ateleport_monster/Dteleport_monster/g
Xs/Ateleport_to/Eteleport_to/g
Xs/wizard_create/Awizard_create/g
Xs/wizard_light/Bwizard_light/g
Xs/generate_cave/Bgenerate_cave/g
Xs/compact_monsters/Acompact_monsters/g
Xs/compact_objects/Bcompact_objects/g
Xs/spell_choice/Aspell_choice/g
Xs/spell_type/Bspell_type/g
Xs/spell_names/Cspell_names/g
Xs/spell_worked/Dspell_worked/g
Xs/spell_order/Espell_order/g
Xs/spell_chance/Fspell_chance/g
Xs/spell_char/Gspell_char/g
Xs/spell_forgotten/Hspell_forgotten/g
Xs/spell_learned/Ispell_learned/g
Xs/spell_worked/Jspell_worked/g
Xs/place_monster/Aplace_monster/g
Xs/place_boundary/Bplace_boundary/g
Xs/place_streamer/Cplace_streamer/g
Xs/place_open_door/Dplace_open_door/g
Xs/place_broken_door/Eplace_broken_door/g
Xs/place_closed_door/Fplace_closed_door/g
Xs/place_locked_door/Gplace_locked_door/g
Xs/place_stuck_door/Hplace_stuck_door/g
Xs/place_secret_door/Iplace_secret_door/g
Xs/place_door/Jplace_door/g
Xs/place_up_stairs/Kplace_up_stairs/g
Xs/place_down_stairs/Lplace_down_stairs/g
Xs/place_stairs/Mplace_stairs/g
Xs/place_gold/Nplace_gold/g
Xs/place_trap/Oplace_trap/g
Xs/place_object/Pplace_object/g
Xs/place_win_monster/Qplace_win_monster/g
Xs/place_rubble/Rplace_rubble/g
Xs/build_type1/Abuild_type1/g
Xs/build_type2/Bbuild_type2/g
Xs/build_type3/Cbuild_type3/g
Xs/version_maj/Aversion_maj/g
Xs/version_min/Bversion_min/g
Xs/rd_shorts/Ard_shorts/g
Xs/wr_shorts/Awr_shorts/g
Xs/purchase_haggle/Bpurchase_haggle/g
Xs/prt_comment1/Aprt_comment1/g
Xs/prt_comment2/Bprt_comment2/g
Xs/prt_comment3/Cprt_comment3/g
Xs/prt_comment4/Dprt_comment4/g
Xs/prt_comment5/Eprt_comment5/g
Xs/prt_comment6/Fprt_comment6/g
Xs/comment1/Acomment1/g
Xs/comment2a/Bcomment2a/g
Xs/comment2b/Ccomment2b/g
Xs/comment3a/Dcomment3a/g
Xs/comment3b/Ecomment3b/g
Xs/comment4a/Fcomment4a/g
Xs/comment4b/Gcomment4b/g
Xs/comment5/Hcomment5/g
Xs/display_char/Adisplay_char/g
Xs/display_scores/Bdisplay_scores/g
Xs/display_commands/Cdisplay_commands/g
Xs/display_inventory/Ddisplay_inventory/g
Xs/display_cost/Edisplay_cost/g
Xs/display_store/Fdisplay_cost/g
Xs/signal_handler/Asignal_handler/g
Xs/new_mana/Anew_mana/g
Xs/Anew_mana_frac/Bnew_mana_frac/g
Xs/find_breakleft/Afind_breakleft/g
Xs/find_breakright/Bfind_breakright/g
Xs/map_diag1/Amap_diag1/g
Xs/map_diag2/Bmap_diag2/g
Xs/You feel Bconfused/You feel confused/g
Xs/appears Bconfused/appears confused/g
Xs/rune of Bprotection/rune of protection/g
Xs/You feel less Bconfused now/You feel less confused now/g
Xs/error in Bmove_cursor_relative/error in move_cursor_relative/g
Xs/You are too Bconfused/You are too confused/g
Xs/You hit a Ateleport trap!/You hit a teleport trap!/g
Xs/You are Bconfused/You are confused/g
Xs/kill weaker Bcreatures/kill weaker creatures/g
Xs/Ateleport short distances/teleport short distances/g
Xs/Ateleport long distances/teleport long distances/g
Xs/Ateleport its prey/teleport its prey/g
Xs/of these Bcreatures/of these creatures/g
Xs/invisible Bcreatures!/invisible creatures!/g
Xs/envelops several Bcreatures!/envelops several creatures!/g
Xs/You are Bconfused/You are confused/g
END_OF_FILE
if test 11015 -ne `wc -c <'shortnam.sed'`; then
    echo shar: \"'shortnam.sed'\" unpacked with wrong size!
fi
# end of 'shortnam.sed'
fi
echo shar: End of archive 9 \(of 39\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
