Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i055:  umoria4 - single player dungeon simulation (ver. 5.5), Part23/39
Message-ID: <3419@master.CNA.TEK.COM>
Date: 22 Aug 92 22:12:46 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1703
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 55
Archive-name: umoria4/Part23
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 23 (of 39)."
# Contents:  doc/moria1.ms.2 source/desc.c util/scores/delete.c
# Wrapped by billr@saab on Thu Aug 20 09:11:32 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/moria1.ms.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/moria1.ms.2'\"
else
echo shar: Extracting \"'doc/moria1.ms.2'\" \(29377 characters\)
sed "s/^X//" >'doc/moria1.ms.2' <<'END_OF_FILE'
XIf you choose not to die, \fImoria\fP merely continues as before, except that
Xresting, running, repeated commands, etc will be terminated.
XYou can suspend the game with control-Z, and return to the original
Xcommand shell.  In this case, \fImoria\fP is not terminated, and may be
Xrestarted at any time from the shell.  Alternatively, the special
Xcommand `!' is available to run any normal shell command.  When it is
Xcomplete, \fImoria\fP will restart.
X.LP
XFor many input requests or queries, the special character ESCAPE
Xwill abort the command.  For the \*Q\-more\-\*U message prompts, any
Xof SPACE, ESCAPE, RETURN (control-m), or LINEFEED (control-j)
Xcan be used to continue after pausing to read the displayed message.
X.LP
XIt is possible to give control character commands in two key stroke,
Xby typing a `^' followed by the appropriate letter of the alphabet.
XThis is useful when running \fImoria\fP in circumstances where control
Xcharacters are intercepted by some external process, or by the
Xoperating system.
X.NH 2
XDirection.
X.LP
XFor the original style command set,
Xa direction is given by a digit which is in the appropriate
Xorientation on your keypad.  For the rogue like command set,
Xa direction is given by one of the letters `hykulnjb'.  Again,
Xthe relative position of the keys on the keyboard gives a clue
Xas to the direction.
XThe digit `5' for the original commands, and the period `.'
Xfor rogue like commands, is a null direction indicator.
XThis is only allowed in a movement command (to stay in one place)
Xor in a look command (to look in all directions).
X.RS
X.KS
X.TS
Xtab(^);
Xc s s
Xn n n.
XOriginal Directions
X.sp
X\0\\\\\&^\0|\&\0^\0\&/
X7^8^9
X.sp
X\-\0 4^ ^6\&\0\0\-
X.sp
X1^2^3
X\0/\0\&^\0|\&\0^\0\&\\\\
X.TE
X.KE
X.KS
X.TS
Xtab(^);
Xc s s
Xn n n.
XRogue-like Directions
X.sp
X\0\\\\\&^\0|\&\0^\0\&/
Xy\&^k\&^u\&
X.sp
X\-\0 h\&^ ^l\&\0\0\-
X.sp
Xb\&^j\&^n\&
X\0/\0\&^\0|\&\0^\0\&\\\\
X.TE
X.KE
X.RE
X.LP
XMovement is accomplished by specifying a direction immediately.
XSimply press the appropriate key and you character will move
Xone step in that direction.
XYou can only move onto
Xand through floor spots, and only if they contain no creatures or
Xobstructing objects such as a closed door.
X.LP
XOther commands that require a direction will prompt for it.
X.LP
XMoving your character one step at a time can be time
Xconsuming and boring, so a faster method has been supplied.
XFor the original style command set, by
Xusing the Run command `.', you may move in a direction until
Xsomething interesting happens.  For instance, by pressing the
Xperiod key `.' followed by the direction 8, your character would
Xcontinue to move up the screen, only coming to a stop after at
Xleast one condition is satisfied.
XFor the rogue like command set, typing a shifted directional letter
Xwill move you in that direction until something interesting happens.
XThe stopping conditions are described more completely in
Xthe run command description below.
X
X.NH 2
XCommand counts.
X.LP
XSome commands can be executed a fixed number of times by preceding
Xthem with a count.  Counted commands will execute until the count
Xexpires, or until you type any character, or until something significant
Xhappens, such as being attacked.  Thus, a counted command doesn't work
Xto attack another creature.  While the command is being repeated,
Xthe number of times left to be repeated will flash by on the command
Xline at the bottom of the screen.
X.LP
XTo give a count to a command in the rogue like mode, type the number
Xin digits, then the command.  A count of zero defaults to a count of
X99.
X.LP
XTo give a count to a command in the original mode, type a `#', followed
Xby the digits.  To count a movement command (which is itself a digit),
Xtype a space after the number, and you will then be prompted for the
Xcommand.
X.LP
XCounted commands are very useful for searching or tunneling, as they
Xautomatically terminate on success, or if you are attacked.
XYou may also terminate a counted command, or a Run command, by typing
Xany character.  This character is ignored, but it is safest to use
Xa SPACE or ESCAPE which are always ignored as commands.
X
X.NH 2
XSelection of objects.
X.LP
XMany commands will also prompt for a particular object to be used.
XFor example, the command to read a scroll will ask you which of the scrolls
Xthat you are carrying that you wish to read.
XIn such cases, the selection is made by typing a letter of the alphabet.
XThe prompt will indicate the possible letters, and will also allow you
Xto type the key `*', which causes all of the available options to
Xbe described.
X.LP
XThe particular object may be selected by an upper case or a lower case
Xletter.  If lower case is used, the selection takes place immediately.
XIf upper case is used, then the particular option is described, and you
Xare given the option of confirming or retracting that choice.
XUpper case selection is thus safer, but requires an extra key stroke.
X
X.NH 2
XCommand descriptions
X.LP
XIn the following command descriptions, the original style key is
Xgiven.  If the rogue like key for that command is different, then it
Xwill be shown inside the braces following the command name.
X.IP "B <Dir> - Bash. {f - force}"
XThe bash command includes breaking open doors and chests, or
Xbashing an opponent.  Your bashing ability increases with
Xweight and strength.  In addition,
Xwhen bashing an opponent, you will either perform a body bash, or,
Xif wielding a shield, perform a shield bash which is more
Xeffective.
X.sp
XBashing a door can throw you off balance, but this
Xwill not generally be a problem.  Doors that have been jammed
Xclosed with spikes can only be opened by bashing.  Locked doors
Xmay also be bashed open.  Bashing a door open will
Xpermanently break it.
X.sp
XBashing a creature affects both you and the opponent.
XDepending on your dexterity, you may or may
Xnot be thrown off balance allowing free moves to your opponent.
XIf the bash is successful, your opponent may be thrown
Xoff balance, thus giving you some free
Xhits or a chance to run.  Huge creatures such as ancient dragons
Xwill be difficult or impossible to bash successfully.
X.sp
XA player automatically performs a shield bash instead of a
Xbody bash, if he is currently wearing a shield.  A shield bash
Xadds the damage of a shield to that of the bash, so it is more
Xeffective.  Size and material both affect the damage
Xthat a shield will do.
X.sp
XYou can apply a count to this command, but if you are thrown off
Xbalance, the count will be reset straight away.
X.IP "C  - Print character (to screen or file)."
XThis command allows the player to either display his
Xcharacter on the terminal screen, or to print an entire character
Xinfo listing to a file.  The character's history, equipment,
Xand inventory list are also included if you chose to print it to a file.
X.IP "D <Dir> - Disarm a trap."
XYou can attempt to disarm floor traps, or trapped chests.
XIf you fail to disarm a trap, there is a chance that you blunder
Xand set it off.  You can only disarm a trap on a chest after
Xfinding it with the search command.  This command can have a count.
X.IP "E  - Eat some food."
XA character must eat occasionally to remain effective.  As a
Xcharacter grows hungry, a message will appear at the bottom of
Xthe screen saying \*QHungry\*U.  If a character remains hungry long
Xenough, he will become weak and eventually start fainting.
XEventually, you will die of starvation if you do not eat.
X.IP "F  - Fill a lamp or lantern with oil."
XIf your character is currently using a lamp for light, and
Xif he has a flask of oil in inventory, he may refill the lamp by
Xusing this command.  A lamp is capable of a maximum of 15000 turns
Xof light, and each flask has 7500 turns of oil contained in it.
X.IP "G  - Gain new spells."
XTo actually learn new spells, you must use this command.
XWhen you are able to learn some spells, the word \*QStudy\*U
Xwill appear on the status line at the bottom of the screen.
XMages, rogues, and rangers must have the magic books containing
Xnew spells to be able to learn them.  Priests and Paladins are
Xgiven their prayers by their gods, and hence do not need a holy
Xbook before learning the spells in it.
X.IP "L  - Location on map. {W - where}"
XThe location command allows you to look at all parts of the
Xcurrent dungeon level.  The displayed view of the dungeon is
Xshifted to bring your current position as close to the center
Xas possible.  You may then shift the displayed map in any of the eight
Xpossible directions.  Each shift moves your view point by one
Xhalf screen.  The top line displays a map section number, each map
Xsection having a height and width one half that of the display, and
Xindicates the direction of the display from your current position.
XIf you exit this command while you are not on the display, then the
Xdisplay is centered again.
X.IP "M  - Map shown reduced size."
XThis command will show the entire map, reduced by a factor of nine,
Xon the screen.  Since nine places map into every character on the screen,
Xonly the major dungeon features will be visible.  This is especially
Xuseful for finding where the stairs are in relation to your current
Xposition.  It is also useful for identifying unexplored areas.
X.IP "R  - Rest for a number of turns."
XYou may rest one turn with the null movement command.  Resting for
Xlonger periods of time is accomplished by using the Rest command,
Xfollowed by the number of turns you want to rest your character.
XResting will continue until the specified duration has expired,
Xor something to wake the character happens, such as a creature
Xwandering by, or getting hungry, or some disability like
Xblindness expiring.
XIt is sometimes a good idea to rest a beat up
Xcharacter until he regains some of his hit points, but be sure to
Xhave plenty of food if you rest often.
X.sp
XIf you have accidentally entered in a rest period too large,
Xor change your mind about the resting period, you may wake your
Xcharacter up by typing any character.  Space is best, since if the
Xrest ends just before the character is typed, the space is ignored
Xas a command.
X.sp
XIt is also possible to rest by typing the count first, and using
Xeither the Rest or the null movement command.
X.sp
XIf you type `*' for the rest count, your character will rest until both
Xhp and mana reach their maximum values.  As above, you will immediately
Xstop resting if anything interesting happens.
X.IP "S  - Search mode toggle. {#}"
XThe Searching toggle will take you into and out of
Xsearch mode.  When first pressed, the message \*QSearching\*U will
Xappear at the bottom of the screen.  You are now taking
Xtwo turns for each command, one for the command and one turn to
Xsearch.  This means that you are taking twice the
Xtime to move about the dungeon, and therefore twice the food.  If
Xa creature should happen by or attack you, search mode will
Xautomatically shut off.  You may also turn off search mode
Xby again pressing the `S' {or #} key.
X.IP "T <Dir> - Tunnel through rock. {control-<Dir>}"
XTunneling (Mining) is a very useful art.  There are four
Xkinds of rock present in the dungeons of \fImoria\fP: Permanent Rock,
XGranite Rock, Magma Intrusion, and Quartz Veins.  Permanent Rock
Xis exactly that, permanent.  Granite is very hard, therefore hard
Xto dig through, and contains no valuable metals.  Magma and
XQuartz veins are softer and sometimes bear valuable metals and
Xgems, shown as a `$' or a `*' character.  You can tell if the
Xmetal or gems are embedded into the wall by trying to move onto
Xthem.  If you can't move over them, you'll have to dig them out.
XThere is an option which causes magma and quartz to be displayed
Xdifferently than other rock types.
X.sp
XTunneling can be VERY difficult by hand, so when you dig be
Xsure to wield either a shovel or a pick.  Magical shovels and
Xpicks can be found which allow the wielder to dig much faster
Xthan normal, and a good strength also helps.
X.sp
XTunneling can have a count.
X.IP "V  - View scoreboard."
XThis command will display the contents of the score board on the
Xscreen.  On a multiuser system, typing `V' again will show only those
Xscores from the score board that are yours.
X.IP "a <Dir> - Aim a wand. {z - zap}"
XWands must be aimed in a direction to be used.  Wands are
Xmagical devices and therefore use the Magical Devices ability of
Xthe player.  They will either affect the first object/creature
Xencountered, or affect anything in a given direction, depending
Xupon the wand.  An obstruction such as door or wall will generally
Xstop the effects of a wand from traveling further.
X.IP "b  - Browse a book. {P - peruse}"
XYou can only read a book if you are of its realm.
XTherefore a magic user could read a magic book, but not a holy
Xbook.  Warriors will not be able to read either kind of book.
XWhen the browse command is used, all of the spells or prayers
Xcontained therein are displayed, along with information such as
Xtheir level, the amount of mana used up in casting them, and whether
Xor not you know the spell or prayer.  There
Xare a total of 31 different magical spells in four books, and 31
Xdifferent prayers in four books.
X.IP "c <Dir> - Close a door."
XNonintelligent and certain other creatures will not be able
Xto open a door.  Therefore shutting doors can be a life saver.
XYou must be adjacent to an open door, and you cannot close broken
Xdoors.  Bashing a door open will break it.
X.IP "d  - Drop an object from your inventory."
XYou can drop an object onto the floor beneath you if
Xthat floor spot does not already contain an object.
XDoors and traps are considered objects in this sense.  If you
Xhave several objects of the same kind, you will be prompted
Xfor dropping one or all of them.  It is possible to directly drop things
Xwhich you are wielding or wearing.
X.IP "e  - Display a list of equipment being used."
XUse the Equipment command to display a list of objects
Xcurrently being used by your character.  Each object
Xhas a specific place where it is placed, and that only one object
Xof each type may be used at any one time, excepting rings of
Xwhich two can be worn, one on each hand.
X.IP "f <Dir> - Fire/Throw an object/use a missile weapon. {t - throw}"
XYou may throw any object carried by your character.
XDepending upon the weight of an object, it may travel across a
Xroom or drop down beside you.  If you throw an object such as an
Xarrow, only one will be used at a time.
X.sp
XIf you throw at a creature, your chance of hitting the
Xcreature is determined by your pluses to hit, your ability at
Xthrowing, and the object's pluses to hit.  Once the creature is
Xhit, the object may or may not do any actual damage to it.
XCertain objects in the dungeon can do great amounts of damage
Xwhen thrown, but it's for you to figure out the obscure ones.
XOil flasks are considered to be lit before thrown, therefore they
Xwill do fire damage to a creature if they hit it.
X.sp
XTo use a bow with arrows, simply wield the bow and throw the
Xarrows.  Extra pluses to damage and hitting are gained by
Xwielding the proper weapon and throwing the corresponding ammo.
XA heavy crossbow with bolts for example, is a killer...
X.IP "i  - Display a list of objects being carried."
XThis command displays a list of all objects being
Xcarried, but not currently in use.  You may carry up to 22
Xdifferent kinds of objects, not including those in your equipment
Xlist.  Depending upon your strength, you will be able carry many
Xidentical objects before hitting your weight limit.
X.IP "j <Dir> - Jam a door with an iron spike. {S - spike}"
XMost humanoid and many intelligent creatures can simply open
Xa closed door, and can eventually get through a locked door.
XTherefore you may spike a door in order to jam it.  Each spike
Xused on a door will increase its strength, although the more
Xspikes you add, the less effect each additional spike has.
XIt is very easy to
Xjam a door so much as to make it impossible for your character to
Xbash it down, so spike doors wisely.  The bigger a
Xcreature is, the easier it can bash a door down.  Therefore twenty
Xor more spikes might be necessary to slow down a dragon, where
Xone spike would slow down a kobold.  This command can be counted.
X.IP "l <Dir> - Look in a direction. {x - examine}"
XThe Look command is useful in identifying the exact type of
Xobject or creature shown on the screen.  Also, if a creature is
Xon top of an object, the look command will describe both.  You
Xcan see creatures and objects up to 200 feet away (20 spaces).
XYou may freely use the Look command without the
Xcreatures getting a move on you.
X.sp
XLooking in a particular direction sees everything within a cone
Xof vision which just overlaps the cones of the two adjacent directions.
XLooking with the null direction `5' (or `.') sees everything which there
Xis to be seen.
X.sp
XYou are also able to access your monster memories with this command.
XIf you see a creature, you are prompted to ask if you wish to see
Xa short paragraph of information about your experiences with that
Xcreature.  See also the section on being attacked.
X.IP "m  - Cast a magic spell."
XTo cast a spell, a character must have previously learned it,
Xand must also have in the inventory a magical book from which the
Xspell may be read.
XEach spell has a chance of failure which starts out fairly large
Xbut decreases as a character gains levels.  If a character does
Xnot have enough mana, the chance of failure is greatly increased,
Xand he gambles on losing a point of constitution.  You will be
Xprompted for confirmation before trying to cast a spell when you
Xdon't have enough mana.  Since a
Xcharacter must read the spell from a book, he cannot be blind or
Xconfused when casting a spell, and there must be some light
Xpresent.
X.IP "o <Dir> - Open a door, chest, or lock."
XTo open an object such as a door or chest you must use the
XOpen command.  If the object is locked, the Open command will
Xattempt to pick the lock, based on your ability at disarming.
XIf an object is trapped and you open it, the trap will
Xbe set off.
XThis command can be counted, you may need several tries to get it
Xopen.
X.IP "p  - Read a prayer."
XTo pay effectively, a character must have learned the prayer,
Xand must also have in the inventory a holy book from which
Xthe prayer may be read.
XEach prayer has a chance of being ignored which starts out fairly large
Xbut decreases as a
Xcharacter gains levels.  If a character does not have enough
Xmana, the chance of failure is greatly increased, and he
Xgambles on losing a point of constitution.  You will be prompted
Xfor confirmation before trying to pray when you don't have enough mana.
XSince a character
Xmust read the prayer from a book, he cannot be blind or confused
Xwhen praying, and there must be some light present.
X.IP "q  - Quaff a potion."
XTo drink a potion use the Quaff command.  A potion affects
Xthe player in some manner.  The effects of the potion may be
Ximmediately noticed, or they may be subtle and unnoticed.
X.IP "r  - Read a scroll."
XTo read a scroll use the Read command.  A scroll spell has
Xan area affect, except in a few cases such as identify scrolls
Xwhich act on other objects.  Two scrolls, the identify
Xscroll and the recharge scroll, have titles which can be read
Xwithout setting them off, and by pressing ESCAPE can be saved
Xfor future use.
X.IP "s  - Search general area one turn."
XThe Search command can be used to locate hidden traps and
Xsecret doors about the player.  More than a single turn
Xof searching will be required in most cases.  You should always
Xsearch a chest before trying to open it because they are
Xgenerally trapped.
XThis command can be counted, which is useful if you are really sure
Xof finding something eventually.  A counted search ends as soon as
Xanything is found.
X.IP "t  - Take off a piece of equipment. {T}"
XUse the Take Off command to remove an object from use, and
Xreturn it to your inventory.  Occasionally you will run into a
Xcursed item which cannot be removed.  Cursed items are always
Xbad, and can only be taken off after removing the curse.
X.IP "u  - Use a staff. {Z - Zap}"
XThe Use command will activate a staff.  Like scrolls, most
Xstaffs have an area affect.  Because staffs are generally more
Xpowerful than most other items, they are also harder to use
Xcorrectly.
X.IP "v  - Display current version of game."
XThe Version command displays the credits for the current
Xversion of \fImoria\fP.
X.IP "w  - Wear or wield an item being carried."
XTo wear or wield an object in your inventory, use the
XWear/Wield command.  If an object is already in use for the same
Xfunction, it is automatically removed first.  An
Xobject's bonuses cannot be gained until it is worn or wielded.
X.IP "x  - Exchange primary and secondary weapons. {X}"
XA secondary weapon is any weapon which may be needed often.
XInstead of searching through your inventory, you may use the
Xexchange command to keep the weapon ready.  For instance, if you
Xwanted to use your bow most of the time, but needed a sword for
Xclose combat, you could wield your sword, use the exchange
Xcommand to make it the secondary weapon, then wield your bow.  If
Xthe sword was suddenly needed, simply use the exchange command to
Xswitch between the bow and the sword.
X.IP "/  - Identify a character shown on screen."
XUse the identify command to find out what a character
Xdisplayed on the screen stands for.  For instance, by
Xpressing `/.', you can find out that the `.' stands for a floor spot.
XWhen used with a creature, the identify command will tell you
Xonly what class of creature the symbol stands for, not the
Xspecific creature, therefore use the look command for this
Xinformation.
X.sp
XIf you identify the character for a creature in your monster memory,
Xyou are also prompted to ask if you wish to see a paragraph of
Xinformation on those creatures identified by the given character.
XSeveral creatures may be identified in this way.
XTyping ESCAPE after the paragraph for any creature will abort back to
Xcommand level.  See also the section on being attacked.
X.IP "?  - Display a list of commands."
XThe ? command displays a quick reference help page
Xon the screen.
X.IP "\-  - Move without pickup."
XThis is followed by a move command, and causes you to move over any
Xobject without picking it up.
XYou can associate a count with this command.
X.IP "=  - Set options."
XThis is a free move, to set various \fImoria\fP options.
XThe available options are:
X.IP " (1)"
XCut known corners when running.  This is on by default, and the only reason
Xfor switching it off would be if you had the search flag on and wished to
Xlook for doors in the extremity of every corner.
X.IP " (2)"
XExamine potential corners when running.  This is on by default, and allows
Xyou to run along an unknown curving corridor.  If, however, you are running
Xfrom a creature, and wish to stop at an unknown corner to make a considered
Xdecision, then you may wish to switch this option off.
X.IP " (3)"
XPrint self during a run.  This is off by default, which gives faster screen
Xupdating.
X.IP " (4)"
XStop when map sector changes.  This is off by default, but can be switched
Xon if you wish to stop running whenever a new part of the dungeon appears
Xin view.
X.IP " (5)"
XTreat open doors as empty space while running.  This is off by default, in
Xwhich case you stop when ever you run up to an open door.
X.IP " (6)"
XPrompt to pick up objects.  This is off by default, in which case stepping
Xover an object automatically causes you to pick it up.  With the option
Xon, you get prompted in all such cases with a description of the object
Xto see if you really want to take it.
X.IP " (7)"
XRogue like command set.  This option controls the command set in use.  It
Xis off by default.
X.IP " (8)"
XShow weights in inventory.  This is off by default: switching it on causes
Xthe inventory and equipment listings to include the weight of all objects.
XThis may be useful to know if your pack is getting too heavy.
X.IP " (9)"
XHighlight mineral seams.  This is off by default.  Switching it on causes
Xquartz and magma to be displayed as `%' instead of `#'.
XThis is handy when mining.
XSetting this option does not immediately highlight all minerals,
Xbut only those which are subsequently displayed.  To display all minerals,
Xjust move the map around a bit with the `Where' (or `Locate') command.
X.IP " (10)"
XBeep for invalid character.  This is on by default.  When on, the program
Xwill beep for most invalid characters, such as trying to choose a spell
Xthat you haven't learned yet.  When off, there are no such beeps.
X.IP " (11)"
XDisplay rest/repeat counts.  This is on by default.  When on, the program
Xwill progessively display the remaining turns left while resting, and
Xfor repeated commands.  For those trying to play over a 2400 bps or less
Xconnection, or for those playing on very slow microcomputers, turning this
Xoff will make resting and repeated commands work much faster.
X.IP
XThe setting of all these options persist in your savefile, even after you
Xdie.
X.IP "^P  - Previous message."
XThe Control-P command will
Xredisplay the last message printed on the message line at the
Xtop of your screen.
XA second such command will display all of the saved messages.
XYou may also give this command a count to specify the number
Xof previous messages to display.  At present, only 22 messages are saved.
X.IP "^K  - Quit the game without saving. {Q}"
XTo exit the game without saving your character (i.e. kill him/her)
Xuse the
XControl-K command.  Once exited in this manner, your character
Xis nonrecoverable.
X.IP "^X  - Save your character and exit the game."
XTo save your game so that it can be restarted later, use the
XControl-X command.  Save files will also be generated if the game
Xcrashes due to a system error.  When you die, a reduced save file
Xis produced containing only your monster memory, and your option
Xsettings.
X.IP "{  - Inscribe an object."
XThis command can be used to inscribe any short string on an object.
XInscriptions are limited to twelve characters.
XThe inscription applies only to the particular object, it is not
Xautomatically transferred to all similar objects.
XUnder certain circumstances, \fImoria\fP will itself inscribe objects: if they
Xhave been discovered to be cursed or enchanted, or if they have been
Xsampled without being identified.
XIn this last case, \fImoria\fP does in fact carefully inscribe every such
Xitem.
X.IP "!  - Shell out of game."
XUse the Shell command `!' to temporarily exit the game to
Xexecute UNIX or MSDOS commands.  You may reenter the game by typing exit
Xto end the spawned process.  This is not implemented in the
XMacintosh version.
X.IP "<  - Go up an up staircase."
XIf you move onto an up staircase you may use the `<' command
Xto go up one level.  There is always one staircase going up on
Xevery level except for the town level (this does not mean it's
Xeasy to find).  Going up a staircase will always take you to a
Xnew dungeon area except for the town level, which remains the
Xsame for the duration of your character.
X.IP ">  - Go down a down staircase."
XIf you are on top of a down staircase you may use the `>'
Xcommand to go down one level.  There are always two or three
Xstaircases going down on each level, except the town level which
Xhas only one.  Going down will always take you to a new dungeon
Xarea.
X.IP ". <Dir> - Move in direction. {shift<Dir>}"
XThe Run command will move you in the indicated
Xdirection until either you have to make a choice as between two
Xdirections, or something interesting happens.  There are options
Xwhich determine behaviour at corners, and at screen boundaries.
XMore precisely, the conditions which stop a run are as follows:
X.IP (1)
XA creature appears on the screen, one already on the screen moves,
Xor a creature attacks you or casts a spell at you.
X.IP (2)
XYou move next to an object, or a feature such as a door or trap.
X.IP (3)
XYou come to the end of open space, or the end of a passage, or
Xa junction of passages, or a hole in a wall.
X.IP (4)
XCorners are more complex.  A corner allows a choice between adjacent
Xrectangular and diagonal directions.  If you can see walls which ensure
Xthat the diagonal gives a faster traversal, then action is determined
Xby the \*Qcut corners\*U options.
XIf it is set, then you move diagonally through the corner.  This gives
Xyou maximum speed (as is nice if you are fleeing a hidden creature).
XOn the other hand, this option should not be set if you want
Xmore careful coverage (as when you are searching) so that you
Xtake two moves through the corner.
X.IP (5)
XAt a potential corner, where walls are not yet visible ahead of the
Xrectangular direction, the \*Qexamine corners\*U option is considered.
XIf set, you will move straight into the corner, which will light up
Xall the corner and so determine where you can go from there.  This
Xallows you to follow corners in new passages.  If the option is not set,
Xyou stop.  This allows highly cautious running where you want to stop
Xat all potential choice points.
X.IP (6)
XIf you move off the screen while running, then a new section of the dungeon
Xis display and the run continues.  However, if the \*Qstop when
Xmap changes\*U option
Xis set, you will stop.  Again, this is an option for nervous players, after
Xall, there may be a dragon on the new screen.
X.IP (7)
XAnything typed during a run causes the run to stop.  The character
Xcausing this to occur is ignored.  It is best to use a space,
Xwhich is ignored as a command, just in case the run stops just before
Xyou type the character.
X.IP (8)
XVarious changes of state, such as recovery from fear or loss of heroism,
Xwill stop a run.
END_OF_FILE
if test 29377 -ne `wc -c <'doc/moria1.ms.2'`; then
    echo shar: \"'doc/moria1.ms.2'\" unpacked with wrong size!
fi
# end of 'doc/moria1.ms.2'
fi
if test -f 'source/desc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/desc.c'\"
else
echo shar: Extracting \"'source/desc.c'\" \(17810 characters\)
sed "s/^X//" >'source/desc.c' <<'END_OF_FILE'
X/* source/desc.c: handle object descriptions, mostly string handling code
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#ifdef __TURBOC__
X#include	<stdio.h>
X#include	<stdlib.h>
X#endif /* __TURBOC__ */
X 
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#ifdef USG
X#ifndef ATARIST_MWC
X#include <string.h>
X#endif
X#else
X#include <strings.h>
X#endif
X
X#if defined(LINT_ARGS)
Xstatic void unsample(struct inven_type *);
X#else
Xstatic void unsample();
X#endif
X
X#ifdef ATARIST_TC
X/* Include this to get prototypes for standard library functions.  */
X#include <stdlib.h>
X#endif
X
Xchar titles[MAX_TITLES][10];
X
X/* Object descriptor routines					*/
X
Xint is_a_vowel(ch)
Xchar ch;
X{
X  switch(ch)
X    {
X    case 'a': case 'e': case 'i': case 'o': case 'u':
X    case 'A': case 'E': case 'I': case 'O': case 'U':
X      return(TRUE);
X    default:
X      return(FALSE);
X    }
X}
X
X/* Initialize all Potions, wands, staves, scrolls, etc.	*/
Xvoid magic_init()
X{
X  register int h, i, j, k;
X  register char *tmp;
X  vtype string;
X
X  set_seed(randes_seed);
X
X  /* The first 3 entries for colors are fixed, (slime & apple juice, water) */
X  for (i = 3; i < MAX_COLORS; i++)
X    {
X      j = randint(MAX_COLORS - 3) + 2;
X      tmp = colors[i];
X      colors[i] = colors[j];
X      colors[j] = tmp;
X    }
X  for (i = 0; i < MAX_WOODS; i++)
X    {
X      j = randint(MAX_WOODS) - 1;
X      tmp = woods[i];
X      woods[i] = woods[j];
X      woods[j] = tmp;
X    }
X  for (i = 0; i < MAX_METALS; i++)
X    {
X      j = randint(MAX_METALS) - 1;
X      tmp = metals[i];
X      metals[i] = metals[j];
X      metals[j] = tmp;
X    }
X  for (i = 0; i < MAX_ROCKS; i++)
X    {
X      j = randint(MAX_ROCKS) - 1;
X      tmp = rocks[i];
X      rocks[i] = rocks[j];
X      rocks[j] = tmp;
X    }
X  for (i = 0; i < MAX_AMULETS; i++)
X    {
X      j = randint(MAX_AMULETS) - 1;
X      tmp = amulets[i];
X      amulets[i] = amulets[j];
X      amulets[j] = tmp;
X    }
X  for (i = 0; i < MAX_MUSH; i++)
X    {
X      j = randint(MAX_MUSH) - 1;
X      tmp = mushrooms[i];
X      mushrooms[i] = mushrooms[j];
X      mushrooms[j] = tmp;
X    }
X  for (h = 0; h < MAX_TITLES; h++)
X    {
X      string[0] = '\0';
X      k = randint(2) + 1;
X      for (i = 0; i < k; i++)
X	{
X	  for (j = randint(2); j > 0; j--)
X	    (void) strcat(string, syllables[randint(MAX_SYLLABLES) - 1]);
X	  if (i < k-1)
X	    (void) strcat(string, " ");
X	}
X      if (string[8] == ' ')
X	string[8] = '\0';
X      else
X	string[9] = '\0';
X      (void) strcpy(titles[h], string);
X    }
X  reset_seed();
X}
X
Xint16 object_offset(t_ptr)
Xinven_type *t_ptr;
X{
X  switch (t_ptr->tval)
X    {
X    case TV_AMULET:	return(0);
X    case TV_RING:	return(1);
X    case TV_STAFF:	return(2);
X    case TV_WAND:	return(3);
X    case TV_SCROLL1:
X    case TV_SCROLL2:	return(4);
X    case TV_POTION1:
X    case TV_POTION2:	return(5);
X    case TV_FOOD:
X      if ((t_ptr->subval & (ITEM_SINGLE_STACK_MIN - 1)) < MAX_MUSH)
X	return(6);
X      return(-1);
X    default:  return(-1);
X    }
X}
X
X/* Remove "Secret" symbol for identity of object			*/
Xvoid known1(i_ptr)
Xinven_type *i_ptr;
X{
X  int16 offset;
X  int8u indexx;
X
X  if ((offset = object_offset(i_ptr)) < 0)
X    return;
X  offset <<= 6;
X  indexx = i_ptr->subval & (ITEM_SINGLE_STACK_MIN - 1);
X  object_ident[offset + indexx] |= OD_KNOWN1;
X  /* clear the tried flag, since it is now known */
X  object_ident[offset + indexx] &= ~OD_TRIED;
X}
X
Xint known1_p(i_ptr)
Xinven_type *i_ptr;
X{
X  int16 offset;
X  int8u indexx;
X
X  /* Items which don't have a 'color' are always known1, so that they can
X     be carried in order in the inventory.  */
X  if ((offset = object_offset(i_ptr)) < 0)
X    return OD_KNOWN1;
X  if (store_bought_p(i_ptr))
X    return OD_KNOWN1;
X  offset <<= 6;
X  indexx = i_ptr->subval & (ITEM_SINGLE_STACK_MIN - 1);
X  return(object_ident[offset + indexx] & OD_KNOWN1);
X}
X
X/* Remove "Secret" symbol for identity of plusses			*/
Xvoid known2(i_ptr)
Xinven_type *i_ptr;
X{
X  unsample(i_ptr);
X  i_ptr->ident |= ID_KNOWN2;
X}
X
Xint known2_p(i_ptr)
Xinven_type *i_ptr;
X{
X  return (i_ptr->ident & ID_KNOWN2);
X}
X
Xvoid clear_known2(i_ptr)
Xinven_type *i_ptr;
X{
X  i_ptr->ident &= ~ID_KNOWN2;
X}
X
Xvoid clear_empty(i_ptr)
Xinven_type *i_ptr;
X{
X  i_ptr->ident &= ~ID_EMPTY;
X}
X
Xvoid store_bought(i_ptr)
Xinven_type *i_ptr;
X{
X  i_ptr->ident |= ID_STOREBOUGHT;
X  known2(i_ptr);
X}
X
Xint store_bought_p(i_ptr)
Xinven_type *i_ptr;
X{
X  return (i_ptr->ident & ID_STOREBOUGHT);
X}
X
X/*	Remove an automatically generated inscription.	-CJS- */
Xstatic void unsample(i_ptr)
Xinven_type *i_ptr;
X{
X  int16 offset;
X  int8u indexx;
X
X  /* used to clear ID_DAMD flag, but I think it should remain set */
X  i_ptr->ident &= ~(ID_MAGIK|ID_EMPTY);
X  if ((offset = object_offset(i_ptr)) < 0)
X    return;
X  offset <<= 6;
X  indexx = i_ptr->subval & (ITEM_SINGLE_STACK_MIN - 1);
X  object_ident[offset + indexx] &= ~OD_TRIED;
X}
X
X/* unquote() is no longer needed */
X
X/* Somethings been sampled -CJS- */
Xvoid sample (i_ptr)
Xinven_type *i_ptr;
X{
X  int16 offset;
X  int8u indexx;
X
X  if ((offset = object_offset(i_ptr)) < 0)
X    return;
X  offset <<= 6;
X  indexx = i_ptr->subval & (ITEM_SINGLE_STACK_MIN - 1);
X  object_ident[offset + indexx] |= OD_TRIED;
X}
X
X/* Somethings been identified					*/
X/* extra complexity by CJS so that it can merge store/dungeon objects
X   when appropriate */
Xvoid identify(item)
Xint *item;
X{
X  register int i, x1, x2;
X  int j;
X  register inven_type *i_ptr, *t_ptr;
X#ifdef ATARIST_MWC
X  int32u holder;
X#endif
X
X  i_ptr = &inventory[*item];
X
X#ifdef ATARIST_MWC
X  if (i_ptr->flags & (holder = TR_CURSED))
X#else
X  if (i_ptr->flags & TR_CURSED)
X#endif
X    add_inscribe(i_ptr, ID_DAMD);
X
X  if (!known1_p(i_ptr))
X    {
X      known1(i_ptr);
X      x1 = i_ptr->tval;
X      x2 = i_ptr->subval;
X      if (x2 < ITEM_SINGLE_STACK_MIN || x2 >= ITEM_GROUP_MIN)
X	/* no merging possible */
X	;
X      else
X	for (i = 0; i < inven_ctr; i++)
X	  {
X	    t_ptr = &inventory[i];
X	    if (t_ptr->tval == x1 && t_ptr->subval == x2 && i != *item
X		&& ((int)t_ptr->number + (int)i_ptr->number < 256))
X	      {
X		/* make *item the smaller number */
X		if (*item > i)
X		  {
X		    j = *item; *item = i; i = j;
X		  }
X	  msg_print ("You combine similar objects from the shop and dungeon.");
X
X		inventory[*item].number += inventory[i].number;
X		inven_ctr--;
X		for (j = i; j < inven_ctr; j++)
X		  inventory[j] = inventory[j+1];
X		invcopy(&inventory[j], OBJ_NOTHING);
X	      }
X	  }
X    }
X}
X
X/* If an object has lost magical properties,
X * remove the appropriate portion of the name.	       -CJS-
X */
Xvoid unmagic_name(i_ptr)
Xinven_type *i_ptr;
X{
X  i_ptr->name2 = SN_NULL;
X}
X
X/* defines for p1_use, determine how the p1 field is printed */
X#define IGNORED  0
X#define CHARGES  1
X#define PLUSSES  2
X#define LIGHT    3
X#define FLAGS    4
X#define Z_PLUSSES 5
X
X/* Returns a description of item for inventory			*/
X/* pref indicates that there should be an article added (prefix) */
X/* note that since out_val can easily exceed 80 characters, objdes must
X   always be called with a bigvtype as the first paramter */
Xvoid objdes(out_val, i_ptr, pref)
Xchar *out_val;
Xregister inven_type *i_ptr;
Xint pref;
X{
X  /* base name, modifier string*/
X  register char *basenm, *modstr;
X  bigvtype tmp_val;
X  vtype tmp_str, damstr;
X  int indexx, p1_use, modify, append_name, tmp;
X
X  indexx = i_ptr->subval & (ITEM_SINGLE_STACK_MIN - 1);
X  basenm = object_list[i_ptr->index].name;
X  modstr = CNIL;
X  damstr[0] = '\0';
X  p1_use = IGNORED;
X  modify = (known1_p(i_ptr) ? FALSE : TRUE);
X  append_name = FALSE;
X  switch(i_ptr->tval)
X    {
X    case  TV_MISC:
X    case  TV_CHEST:
X      break;
X    case  TV_SLING_AMMO:
X    case  TV_BOLT:
X    case  TV_ARROW:
X      (void) sprintf(damstr, " (%dd%d)", i_ptr->damage[0], i_ptr->damage[1]);
X      break;
X    case  TV_LIGHT:
X      p1_use = LIGHT;
X      break;
X    case  TV_SPIKE:
X      break;
X    case  TV_BOW:
X      if (i_ptr->p1 == 1 || i_ptr->p1 == 2)
X	tmp = 2;
X      else if (i_ptr->p1 == 3 || i_ptr->p1 == 5)
X	tmp = 3;
X      else if (i_ptr->p1 == 4 || i_ptr->p1 == 6)
X	tmp = 4;
X      else
X	tmp = -1;
X      (void) sprintf (damstr, " (x%d)", tmp);
X      break;
X    case  TV_HAFTED:
X    case  TV_POLEARM:
X    case  TV_SWORD:
X      (void) sprintf(damstr, " (%dd%d)", i_ptr->damage[0], i_ptr->damage[1]);
X      p1_use = FLAGS;
X      break;
X    case  TV_DIGGING:
X      p1_use = Z_PLUSSES;
X      (void) sprintf(damstr, " (%dd%d)", i_ptr->damage[0], i_ptr->damage[1]);
X      break;
X    case  TV_BOOTS:
X    case  TV_GLOVES:
X    case  TV_CLOAK:
X    case  TV_HELM:
X    case  TV_SHIELD:
X    case  TV_HARD_ARMOR:
X    case  TV_SOFT_ARMOR:
X      break;
X    case  TV_AMULET:
X      if (modify)
X	{
X	  basenm = "& %s Amulet";
X	  modstr = amulets[indexx];
X	}
X      else
X	{
X	  basenm = "& Amulet";
X	  append_name = TRUE;
X	}
X      p1_use = PLUSSES;
X      break;
X    case  TV_RING:
X      if (modify)
X	{
X	  basenm = "& %s Ring";
X	  modstr = rocks[indexx];
X	}
X      else
X	{
X	  basenm = "& Ring";
X	  append_name = TRUE;
X	}
X      p1_use = PLUSSES;
X      break;
X    case  TV_STAFF:
X      if (modify)
X	{
X	  basenm = "& %s Staff";
X	  modstr = woods[indexx];
X	}
X      else
X	{
X	  basenm = "& Staff";
X	  append_name = TRUE;
X	}
X      p1_use = CHARGES;
X      break;
X    case  TV_WAND:
X      if (modify)
X	{
X	  basenm = "& %s Wand";
X	  modstr = metals[indexx];
X	}
X      else
X	{
X	  basenm = "& Wand";
X	  append_name = TRUE;
X	}
X      p1_use = CHARGES;
X      break;
X    case  TV_SCROLL1:
X    case  TV_SCROLL2:
X      if (modify)
X	{
X	  basenm =  "& Scroll~ titled \"%s\"";
X	  modstr = titles[indexx];
X	}
X      else
X	{
X	  basenm = "& Scroll~";
X	  append_name = TRUE;
X	}
X      break;
X    case  TV_POTION1:
X    case  TV_POTION2:
X      if (modify)
X	{
X	  basenm = "& %s Potion~";
X	  modstr = colors[indexx];
X	}
X      else
X	{
X	  basenm = "& Potion~";
X	  append_name = TRUE;
X	}
X      break;
X    case  TV_FLASK:
X      break;
X    case  TV_FOOD:
X      if (modify)
X	{
X	  if (indexx <= 15)
X	    basenm = "& %s Mushroom~";
X	  else if (indexx <= 20)
X	    basenm = "& Hairy %s Mold~";
X	  if (indexx <= 20)
X	    modstr = mushrooms[indexx];
X	}
X      else
X	{
X	  append_name = TRUE;
X	  if (indexx <= 15)
X	    basenm = "& Mushroom~";
X	  else if (indexx <= 20)
X	    basenm = "& Hairy Mold~";
X	  else
X	    /* Ordinary food does not have a name appended.  */
X	    append_name = FALSE;
X	}
X      break;
X    case  TV_MAGIC_BOOK:
X      modstr = basenm;
X      basenm = "& Book~ of Magic Spells %s";
X      break;
X    case  TV_PRAYER_BOOK:
X      modstr = basenm;
X      basenm = "& Holy Book~ of Prayers %s";
X      break;
X    case TV_OPEN_DOOR:
X    case TV_CLOSED_DOOR:
X    case TV_SECRET_DOOR:
X    case TV_RUBBLE:
X      break;
X    case TV_GOLD:
X    case TV_INVIS_TRAP:
X    case TV_VIS_TRAP:
X    case TV_UP_STAIR:
X    case TV_DOWN_STAIR:
X      (void) strcpy(out_val, object_list[i_ptr->index].name);
X      (void) strcat(out_val, ".");
X      return;
X    case TV_STORE_DOOR:
X      (void) sprintf(out_val, "the entrance to the %s.",
X		     object_list[i_ptr->index].name);
X      return;
X    default:
X      (void) strcpy(out_val, "Error in objdes()");
X      return;
X    }
X  if (modstr != CNIL)
X    (void) sprintf(tmp_val, basenm, modstr);
X  else
X    (void) strcpy(tmp_val, basenm);
X  if (append_name)
X    {
X      (void) strcat(tmp_val, " of ");
X      (void) strcat(tmp_val, object_list[i_ptr->index].name);
X    }
X  if (i_ptr->number != 1)
X    {
X      insert_str(tmp_val, "ch~", "ches");
X      insert_str(tmp_val, "~", "s");
X    }
X  else
X    insert_str(tmp_val, "~", CNIL);
X  if (!pref)
X    {
X      if (!strncmp("some", tmp_val, 4))
X	(void) strcpy(out_val, &tmp_val[5]);
X      else if (tmp_val[0] == '&')
X	/* eliminate the '& ' at the beginning */
X	(void) strcpy(out_val, &tmp_val[2]);
X      else
X	(void) strcpy(out_val, tmp_val);
X    }
X  else
X    {
X      if (i_ptr->name2 != SN_NULL && known2_p(i_ptr))
X	{
X	  (void) strcat(tmp_val, " ");
X	  (void) strcat(tmp_val, special_names[i_ptr->name2]);
X	}
X      if (damstr[0] != '\0')
X	(void) strcat(tmp_val, damstr);
X      if (known2_p(i_ptr))
X	{
X	  /* originally used %+d, but several machines don't support it */
X	  if (i_ptr->ident & ID_SHOW_HITDAM)
X	    (void) sprintf(tmp_str, " (%c%d,%c%d)",
X			   (i_ptr->tohit < 0) ? '-' : '+', abs(i_ptr->tohit),
X			   (i_ptr->todam < 0) ? '-' : '+', abs(i_ptr->todam));
X	  else if (i_ptr->tohit != 0)
X	    (void) sprintf(tmp_str, " (%c%d)",
X			   (i_ptr->tohit < 0) ? '-' : '+', abs(i_ptr->tohit));
X	  else if (i_ptr->todam != 0)
X	    (void) sprintf(tmp_str, " (%c%d)",
X			   (i_ptr->todam < 0) ? '-' : '+', abs(i_ptr->todam));
X	  else
X	    tmp_str[0] = '\0';
X	  (void) strcat(tmp_val, tmp_str);
X	}
X      /* Crowns have a zero base AC, so make a special test for them. */
X      if (i_ptr->ac != 0 || (i_ptr->tval == TV_HELM))
X	{
X	  (void) sprintf(tmp_str, " [%d", i_ptr->ac);
X	  (void) strcat(tmp_val, tmp_str);
X	  if (known2_p(i_ptr))
X	    {
X	      /* originally used %+d, but several machines don't support it */
X	      (void) sprintf(tmp_str, ",%c%d",
X			     (i_ptr->toac < 0) ? '-' : '+', abs(i_ptr->toac));
X	      (void) strcat(tmp_val, tmp_str);
X	    }
X	  (void) strcat(tmp_val, "]");
X	}
X      else if ((i_ptr->toac != 0) && known2_p(i_ptr))
X	{
X	  /* originally used %+d, but several machines don't support it */
X	  (void) sprintf(tmp_str, " [%c%d]",
X			 (i_ptr->toac < 0) ? '-' : '+', abs(i_ptr->toac));
X	  (void) strcat(tmp_val, tmp_str);
X	}
X
X      /* override defaults, check for p1 flags in the ident field */
X      if (i_ptr->ident & ID_NOSHOW_P1)
X	p1_use = IGNORED;
X      else if (i_ptr->ident & ID_SHOW_P1)
X	p1_use = Z_PLUSSES;
X      tmp_str[0] = '\0';
X      if (p1_use == LIGHT)
X	(void) sprintf(tmp_str, " with %d turns of light", i_ptr->p1);
X      else if (p1_use == IGNORED)
X	;
X      else if (known2_p(i_ptr))
X	{
X	  if (p1_use == Z_PLUSSES)
X	  /* originally used %+d, but several machines don't support it */
X	    (void) sprintf(tmp_str, " (%c%d)",
X			   (i_ptr->p1 < 0) ? '-' : '+', abs(i_ptr->p1));
X	  else if (p1_use == CHARGES)
X	    (void) sprintf(tmp_str, " (%d charges)", i_ptr->p1);
X	  else if (i_ptr->p1 != 0)
X	    {
X	      if (p1_use == PLUSSES)
X	        (void) sprintf(tmp_str, " (%c%d)",
X			       (i_ptr->p1 < 0) ? '-' : '+', abs(i_ptr->p1));
X	      else if (p1_use == FLAGS)
X		{
X		  if (i_ptr->flags & TR_STR)
X		    (void) sprintf(tmp_str, " (%c%d to STR)",
X				   (i_ptr->p1 < 0) ? '-' : '+',abs(i_ptr->p1));
X		  else if (i_ptr->flags & TR_STEALTH)
X		    (void) sprintf(tmp_str, " (%c%d to stealth)",
X				   (i_ptr->p1 < 0) ? '-' : '+',abs(i_ptr->p1));
X		}
X	    }
X	}
X      (void) strcat(tmp_val, tmp_str);
X
X      /* ampersand is always the first character */
X      if (tmp_val[0] == '&')
X	{
X	  /* use &tmp_val[1], so that & does not appear in output */
X	  if (i_ptr->number > 1)
X	    (void) sprintf(out_val, "%d%s", (int)i_ptr->number, &tmp_val[1]);
X	  else if (i_ptr->number < 1)
X	    (void) sprintf(out_val, "%s%s", "no more", &tmp_val[1]);
X	  else if (is_a_vowel(tmp_val[2]))
X	    (void) sprintf(out_val, "an%s", &tmp_val[1]);
X	  else
X	    (void) sprintf(out_val, "a%s", &tmp_val[1]);
X	}
X      /* handle 'no more' case specially */
X      else if (i_ptr->number < 1)
X	{
X	  /* check for "some" at start */
X	  if (!strncmp("some", tmp_val, 4))
X	    (void) sprintf(out_val, "no more %s", &tmp_val[5]);
X	  /* here if no article */
X	  else
X	    (void) sprintf(out_val, "no more %s", tmp_val);
X	}
X      else
X	(void) strcpy(out_val, tmp_val);
X
X      tmp_str[0] = '\0';
X      if ((indexx = object_offset(i_ptr)) >= 0)
X	{
X	  indexx = (indexx <<= 6) +
X	    (i_ptr->subval & (ITEM_SINGLE_STACK_MIN - 1));
X	  /* don't print tried string for store bought items */
X	  if ((object_ident[indexx] & OD_TRIED) && !store_bought_p(i_ptr))
X	    (void) strcat(tmp_str, "tried ");
X	}
X      if (i_ptr->ident & (ID_MAGIK|ID_EMPTY|ID_DAMD))
X	{
X	  if (i_ptr->ident & ID_MAGIK)
X	    (void) strcat(tmp_str, "magik ");
X	  if (i_ptr->ident & ID_EMPTY)
X	    (void) strcat(tmp_str, "empty ");
X	  if (i_ptr->ident & ID_DAMD)
X	    (void) strcat(tmp_str, "damned ");
X	}
X      if (i_ptr->inscrip[0] != '\0')
X	(void) strcat(tmp_str, i_ptr->inscrip);
X      else if ((indexx = strlen(tmp_str)) > 0)
X	  /* remove the extra blank at the end */
X	  tmp_str[indexx-1] = '\0';
X      if (tmp_str[0])
X	{
X	  (void) sprintf(tmp_val, " {%s}", tmp_str);
X	  (void) strcat(out_val, tmp_val);
X	}
X      (void) strcat(out_val, ".");
X    }
X}
X
Xvoid invcopy(to, from_index)
Xregister inven_type *to;
Xint from_index;
X{
X  register treasure_type *from;
X
X  from = &object_list[from_index];
X  to->index	= from_index;
X  to->name2     = SN_NULL;
X  to->inscrip[0] = '\0';
X  to->flags     = from->flags;
X  to->tval      = from->tval;
X  to->tchar     = from->tchar;
X  to->p1        = from->p1;
X  to->cost	= from->cost;
X  to->subval    = from->subval;
X  to->number    = from->number;
X  to->weight    = from->weight;
X  to->tohit     = from->tohit;
X  to->todam     = from->todam;
X  to->ac        = from->ac;
X  to->toac      = from->toac;
X  to->damage[0] = from->damage[0];
X  to->damage[1] = from->damage[1];
X  to->level     = from->level;
X  to->ident	= 0;
X}
X
X
X/* Describe number of remaining charges.		-RAK-	*/
Xvoid desc_charges(item_val)
Xint item_val;
X{
X  register int rem_num;
X  vtype out_val;
X
X  if (known2_p(&inventory[item_val]))
X    {
X      rem_num = inventory[item_val].p1;
X      (void) sprintf(out_val, "You have %d charges remaining.", rem_num);
X      msg_print(out_val);
X    }
X}
X
X
X/* Describe amount of item remaining.			-RAK-	*/
Xvoid desc_remain(item_val)
Xint item_val;
X{
X  bigvtype out_val, tmp_str;
X  register inven_type *i_ptr;
X
X  i_ptr = &inventory[item_val];
X  i_ptr->number--;
X  objdes(tmp_str, i_ptr, TRUE);
X  i_ptr->number++;
X  /* the string already has a dot at the end. */
X  (void) sprintf(out_val, "You have %s", tmp_str);
X  msg_print(out_val);
X}
END_OF_FILE
if test 17810 -ne `wc -c <'source/desc.c'`; then
    echo shar: \"'source/desc.c'\" unpacked with wrong size!
fi
# end of 'source/desc.c'
fi
if test -f 'util/scores/delete.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/scores/delete.c'\"
else
echo shar: Extracting \"'util/scores/delete.c'\" \(5947 characters\)
sed "s/^X//" >'util/scores/delete.c' <<'END_OF_FILE'
X/* util/scores/delete.c: standalone program to delete record from scorefile
X
X   Copyright (c) 1991 James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include <stdio.h>
X
X#include "../../source/config.h"
X#include "../../source/constant.h"
X#include "../../source/types.h"
X#include "../../source/externs.h"
X
X#if defined(USG) || defined(VMS)
X#ifndef L_SET
X#define L_SET 0
X#endif
X#ifndef L_INCR
X#define L_INCR 1
X#endif
X#endif
X
X#undef fopen
X
X#ifndef USG
X/* only needed for Berkeley UNIX */
X#include <sys/param.h>
X#include <sys/types.h>
X#include <sys/file.h>
X#endif
X
Xextern race_type race[MAX_RACES];
Xextern class_type class[MAX_CLASS];
X
XFILE *highscore_fp;
XFILE *fileptr;
Xint8u xor_byte;
X
Xvoid set_fileptr();
X
Xmain(argc, argv)
X     int argc;
X     char *argv[];
X{
X  register int i, rank;
X  high_scores score;
X  int8u version_maj, version_min, patch_level;
X  int delete_number;
X
X  if (argc != 3)
X    {
X      printf ("Usage: delete scorefile index > newscore\n");
X      exit (-2);
X    }
X
X  if ((highscore_fp = fopen (argv[1], "r")) == NULL)
X    {
X      printf ("Error opening score file \"%s\"\n", MORIA_TOP);
X      exit (-1);
X    }
X
X  if ((delete_number = atoi (argv[2])) <= 0)
X    {
X      printf ("Index must be a positive number.\n");
X      printf ("Usage: delete scorefile index\n");
X      exit (-2);
X    }
X
X#ifdef MSDOS
X  (void) setmode (fileno(highscore_fp), O_BINARY);
X#endif
X
X#ifndef BSD4_3
X  (void) fseek(highscore_fp, (long)0, L_SET);
X#else
X  (void) fseek(highscore_fp, (off_t)0, L_SET);
X#endif
X
X  /* Read version numbers from the score file, and check for validity.  */
X  version_maj = getc (highscore_fp);
X  version_min = getc (highscore_fp);
X  patch_level = getc (highscore_fp);
X  /* Support score files from 5.2.2 to present.  */
X  if (feof (highscore_fp))
X    {
X      printf ("The scorefile is empty.\n");
X      exit (-1);
X    }
X  else if ((version_maj != CUR_VERSION_MAJ)
X      || (version_min > CUR_VERSION_MIN)
X      || (version_min == CUR_VERSION_MIN && patch_level > PATCH_LEVEL)
X      || (version_min == 2 && patch_level < 2)
X      || (version_min < 2))
X    {
X      printf("Sorry. This scorefile is from a different version of umoria.\n");
X      exit (-1);
X    }
X
X  (void) putc (version_maj, stdout);
X  (void) putc (version_min, stdout);
X  (void) putc (patch_level, stdout);
X
X  /* set the static fileptr in save.c to the highscore file pointer */
X  set_fileptr(highscore_fp);
X
X  rank = 1;
X  rd_highscore(&score);
X  while (!feof(highscore_fp))
X    {
X      i = 1;
X      /* Put twenty scores on each page, on lines 2 through 21. */
X      while (!feof(highscore_fp) && i < 21)
X	{
X	  if (rank != delete_number)
X	    {
X	      set_fileptr (stdout);
X	      wr_highscore (&score);
X	      set_fileptr (highscore_fp);
X	    }
X	  rank++;
X	  rd_highscore(&score);
X	}
X    }
X
X  /* Success.  */
X  exit (0);
X}
X
Xstatic void wr_byte(c)
Xint8u c;
X{
X  xor_byte ^= c;
X  (void) putc((int)xor_byte, fileptr);
X}
X
Xstatic void wr_short(s)
Xint16u s;
X{
X  xor_byte ^= (s & 0xFF);
X  (void) putc((int)xor_byte, fileptr);
X  xor_byte ^= ((s >> 8) & 0xFF);
X  (void) putc((int)xor_byte, fileptr);
X}
X
Xstatic void wr_long(l)
Xregister int32u l;
X{
X  xor_byte ^= (l & 0xFF);
X  (void) putc((int)xor_byte, fileptr);
X  xor_byte ^= ((l >> 8) & 0xFF);
X  (void) putc((int)xor_byte, fileptr);
X  xor_byte ^= ((l >> 16) & 0xFF);
X  (void) putc((int)xor_byte, fileptr);
X  xor_byte ^= ((l >> 24) & 0xFF);
X  (void) putc((int)xor_byte, fileptr);
X}
X
Xstatic void wr_bytes(c, count)
Xint8u *c;
Xregister int count;
X{
X  register int i;
X  register int8u *ptr;
X
X  ptr = c;
X  for (i = 0; i < count; i++)
X    {
X      xor_byte ^= *ptr++;
X      (void) putc((int)xor_byte, fileptr);
X    }
X}
X
Xstatic void rd_byte(ptr)
Xint8u *ptr;
X{
X  int8u c;
X
X  c = getc(fileptr) & 0xFF;
X  *ptr = c ^ xor_byte;
X  xor_byte = c;
X}
X
Xstatic void rd_short(ptr)
Xint16u *ptr;
X{
X  int8u c;
X  int16u s;
X
X  c = (getc(fileptr) & 0xFF);
X  s = c ^ xor_byte;
X  xor_byte = (getc(fileptr) & 0xFF);
X  s |= (int16u)(c ^ xor_byte) << 8;
X  *ptr = s;
X}
X
Xstatic void rd_long(ptr)
Xint32u *ptr;
X{
X  register int32u l;
X  register int8u c;
X
X  c = (getc(fileptr) & 0xFF);
X  l = c ^ xor_byte;
X  xor_byte = (getc(fileptr) & 0xFF);
X  l |= (int32u)(c ^ xor_byte) << 8;
X  c = (getc(fileptr) & 0xFF);
X  l |= (int32u)(c ^ xor_byte) << 16;
X  xor_byte = (getc(fileptr) & 0xFF);
X  l |= (int32u)(c ^ xor_byte) << 24;
X  *ptr = l;
X}
X
Xstatic void rd_bytes(ch_ptr, count)
Xint8u *ch_ptr;
Xregister int count;
X{
X  register int i;
X  register int8u *ptr;
X  register int8u c;
X
X  ptr = ch_ptr;
X  for (i = 0; i < count; i++)
X    {
X      c = (getc(fileptr) & 0xFF);
X      *ptr++ = c ^ xor_byte;
X      xor_byte = c;
X    }
X}
X
X/* set the local fileptr to the scorefile fileptr */
Xvoid set_fileptr(file)
XFILE *file;
X{
X  fileptr = file;
X}
X
Xvoid wr_highscore(score)
Xhigh_scores *score;
X{
X  /* Save the encryption byte for robustness.  */
X  wr_byte(xor_byte);
X
X  wr_long((int32u) score->points);
X  wr_long((int32u) score->birth_date);
X  wr_short((int16u) score->uid);
X  wr_short((int16u) score->mhp);
X  wr_short((int16u) score->chp);
X  wr_byte(score->dun_level);
X  wr_byte(score->lev);
X  wr_byte(score->max_dlv);
X  wr_byte(score->sex);
X  wr_byte(score->race);
X  wr_byte(score->class);
X  wr_bytes((int8u *)score->name, PLAYER_NAME_SIZE);
X  wr_bytes((int8u *)score->died_from, 25);
X}
X
Xvoid rd_highscore(score)
Xhigh_scores *score;
X{
X  /* Read the encryption byte.  */
X  rd_byte (&xor_byte);
X
X  rd_long((int32u *)&score->points);
X  rd_long((int32u *)&score->birth_date);
X  rd_short((int16u *)&score->uid);
X  rd_short((int16u *)&score->mhp);
X  rd_short((int16u *)&score->chp);
X  rd_byte(&score->dun_level);
X  rd_byte(&score->lev);
X  rd_byte(&score->max_dlv);
X  rd_byte(&score->sex);
X  rd_byte(&score->race);
X  rd_byte(&score->class);
X  rd_bytes((int8u *)score->name, PLAYER_NAME_SIZE);
X  rd_bytes((int8u *)score->died_from, 25);
X}
END_OF_FILE
if test 5947 -ne `wc -c <'util/scores/delete.c'`; then
    echo shar: \"'util/scores/delete.c'\" unpacked with wrong size!
fi
# end of 'util/scores/delete.c'
fi
echo shar: End of archive 23 \(of 39\).
cp /dev/null ark23isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
