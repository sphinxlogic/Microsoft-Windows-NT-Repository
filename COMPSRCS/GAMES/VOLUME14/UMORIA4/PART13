Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i045:  umoria4 - single player dungeon simulation (ver. 5.5), Part13/39
Message-ID: <3403@master.CNA.TEK.COM>
Date: 20 Aug 92 18:04:22 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2138
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 45
Archive-name: umoria4/Part13
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 13 (of 39)."
# Contents:  CHANGES ibmpc/make/makefile.top source/io.c
# Wrapped by billr@saab on Thu Aug 20 09:11:29 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CHANGES'\"
else
echo shar: Extracting \"'CHANGES'\" \(15638 characters\)
sed "s/^X//" >'CHANGES' <<'END_OF_FILE'
X::::::: 1991 ::::::::
X---------- 1/4
Xspells.c: light_area(), always light area immediately next to player even if
X	in a room, could be standing on the edge of a room
Xmonsters.c: Grave Wight, no longer has confusion spell, no other wight/wraith
X	has it
Xmisc2.c: get_spell(), when enter invalid character, print "You don't know
X	that prayer." instead of "spell" for priests/etc.
Xcreature.c: make_attack(), creatures which are repelled should not be confused
X	because they did not hit the player
Xdeath.c: exit_game(), delete #ifndef TURBOC around the restore_term() call
Xio.c: restore_term(), delete the call to clear() in the MSDOS code, it was
X	trying to use curses after curses had been exited
X---------- 1/22
Xfiles.c: call pause_line(23) after printing hours file
Xconstant.h, config.h: constant.h should always be included before config.h,
X	because some systems redefine constants in config.h
Xrnd.c: include config.h after constant.h
Xmain.c, misc2.c, save.c, signals.c: include constants.h before config.h
Xmisc2.c, vms/getch.c: new function user_name() for VMS, fix get_name()
X	in misc2.c to call it
X------- 1/30
Xmoria2.c: hit_trap(), add msg_print(CNIL) for the trap door case
X-------- 2/4
Xio.c: for ATARIST_MWC, use 240 instead of '#' for walls
Xsave.c: for ATARIST_MWC, convert 240 to '#' when saving, and '#' to 240
X	when loading, to avoid conversion problems
X--------- 2/8
Xcreate.c: monval(), cast i to int, otherwise some compilers do the arithmetic
X	with unsigned characters
X--------- 2/19
Xmakefile: add new macro CURSES, define it for BSD/SYS V/and Xenix
Xconfig.h: add config info for XENIX, define SYS_V and unix, only undefine
X	register for MSC versions less than 600 (6.00?)
Xcreature.c: mon_move, comment out register decl for r_ptr for XENIX systems
X	to avoid a compiler bug
Xmisc2.c: place_gold, comment out register decl for t_ptr for XENIX systems
X	to avoid a compiler bug
Xunix.c: ifdef out include of termio.h, for XENIX add include of sys/types.h
X	and define bzero as memset, test for unix or M_XENIX at the top
XMakefile: add optional commands to install target which chown/chgrp everythin
X	to bin, and put pointer to it at the top
X---------- 2/25
Xutil/score: Two new utilities, prscore to print scorefiles, and delscore to
X	delete one entry from a scorefile.
Xconfig.h: add MORIA_* macros for the Atari ST with GCC
Xdeath.c, externs.h, io.c, main.c, signals.c, variable.c: Apply Atari ST/GCC
X	patches from Scott Kolodzieski.
X-------- 3/1
Xdeath.c: Amiga must open/close scorefile like MSDOS&VMS
Xio.c: init_curses(),restore_term(), fix bugs in AMIGA code,
X	add code to release resources
Xamiga/*: updated versions of amiga source files, from
X	cg37717@lion.eng.clemson.edu, Corey Gehman
Xatari_st/curscomp: complete rewrite of the curses code by Hildo Biersma
Xstore2.c: get_haggle(), do not accept an increment value of zero, turn off
X	increment flag instead of accepting it
X-------- 3/2
Xstore2.c: store_purchase(), store_prt_gold call was inside `if' now after,
X	did not update gold if store had 13 items and you bought the 13th
X-------- 3/11
Xmoria1.c: sub3_move_light(), don't print over old location if find_flag
X	is true, unless find_prself is also true, this speeds up movement
X	in find mode by eliminating unnecessary drawing of characters
Xmoria2.c: hit_trap(), call move_light() for the teleport trap case, to light
X	up the trap
Xmisc1.c, save.c, treasure.c: change ATARIST_MWC ifdefs for using graphic
X	character to ATARI_ST which is true for both MWC and TC
Xio.c: remove all ATARIST_MWC diffs which were needed for the old non-standard
X	curses, change the rest to be ATARI_ST, since both MWC and TC need them
X-------- 3/14
Xsource/*: add Mac THINK C support
Xmac/dumpres/*: add Mac THINK C support
Xmac/scrnmgr/*: add Mac Think C support
Xmoria1.c: find_init(), when !light_flag and !find_prself, must erase the
X	player's '@', because sub3_move_light() won't, see 3/11 change above
X------- 3/15
Xmac/*: add Mac THINK C support
X*: put file name and 1991 copyrights in all source files
X------- 3/23
Xsave.c: prevent resurrection of a total winner character
Xconstants.h, creature.c, monsters.c, recall.c: add new flag CM_ONLY_MAGIC,
X	set this flag in creature.c, check the flag in recall.c, allows
X	recall to print movement speed for Quylthulgs
Xcreature.c: when a wand is drained of charges, inscribe it as {empty} if
X	it is not known2
X-------- 3/24
Xfiles.c, ibmpc/ms_misc.c: ifdefed out msdos_intro(), since that routine is
X	obsolete now
Xdoc/moria.6: add -S option to list at the top
Xibmpc/CONFIG.DOC: update for Umoria 5.x, remove kneller's address, and put in
X	my address
X------- 3/25
Xconfig.h, constant.h, */*.c: move VMS definition for ESCAPE from config.h
X	to constant.h, now all files include config.h before constant.h
X*: linted all sources files, changed version numbers to 5.3
X------- 3/30
Xvms/*, ibmpc/ms_misc.c, config.h, death.c, dungeon.c, externs.h, files.c,
Xio.c, save.c: merge in changes from Ralph Waters, which are needed to compile
X	the sources under VMS and IBM-PC/Turbo C.
Xmoria2.c, store2.c, *.c: get_item(), show_inven() take new parameter mask,
X	if mask is non-zero, they only list items indicated by mask array,
X	store_sell() calculates a mask based on what store will buy
Xstore2.c: purchase_haggle(), sell_haggle(), if the auto increment is larger
X	than the difference between the store's offer and the player's offer,
X	then set the auto increment to the exact difference
Xdungeon.c, externs.h, moria1.c, moria2.c, variable.c: eliminate search_flag,
X	it was redundant, replace all uses with (py.flags.status & PY_SEARCH)
Xtables.c: remove good armor items from armory, to force players to search for
X	them in the dungeons, hard leather boots, iron helm, partial plate,
X	full plate
Xmisc1.c: alloc_monster(), always create dragons sleeping here, to give the
X	player a sporting chance
Xmoria1.c: inven_command(), when pack not empty and show_weights flag true,
X	display capacity along with weigth carried on first line of inventory
Xspells.c: build_wall(), permanently light walls created within range of
X	player's lamp
Xspells.c: earthquake(), fix it to act just like build_wall when a monster is
X	trapped in a wall
Xcreature.c, externs.h: movement_rate(), now static
X*: release 5.3.1 sources
X------- 4/27
Xms_misc.c, externs.h: change declarations of warn() to match definition,
X	change declaration and definition of error() to match warn(),
Xexterns.h: fix declarations for sleep(), find_init(), show_inven(), get_item()
Xdeath.c: display_scores(), don't set player_uid for non UNIX/VMS system
X	duplicate_character(), ifdef out code which is unreachable for non
X	UNIX/VMS system, make all returns have a value
Xsets.c: set_null(), add a #pragma argused for TURBO C
Xms_misc.c: fix three lines that had an assignment inside an if
Xexterns.h: add prototypes/declarations for VMS files getch.c and uexit.c
Xmoria1.c: see_wall(), change ATARIST_MWC ifdef to ATARI_ST
Xatari_st/curscomp/curses.c: winsch(), first loop ran in wrong direction
Xexterns.h: add declarations for atari st functions
Xatari_st/moria.prj: new file, TC project file for Umoria
Xdeath.c: highscores (), change fseed to fseek, typing error
Xcreature.c, death.c, desc.c, dungeon.c, files.c, io.c, moria1.c, moria2.c,
X	store2.c, wizard.c, atarist.c: include stdlib.h if ATARIST_TC to get
X	prototypes for standard library functions
Xgenerate.c: for ATARIST_TC, include <string.h>
Xatarist/curscomp/curses.h: change mvadd* macros from compound statements to
X	conditional expressions, so that all returns values are error checked
Xio.c: for ATARIST_TC, include ext.h to properly define (?) sleep
Xconfig.h: for ATARIST_TC, define index strchr
Xsave.c: sv_write()/get_char(), define t_ptr for both MSDOS and ATARI_ST;
X	get_char(), change ATARIST_MWC ifdef around chmod call to ATARI_ST
X	include time.h for ATARIST_TC
Xunix/Makefile: change ONWER to OWNER
Xcreature.c: creatures(), give moves to monsters trapped in rock, so that they
X	will die/dig out immediately, mon_move() if a monster in rock is
X	already dead, don't kill it again
X*: update address info in all files
Xio.c: change __GNU_C_ to __GNUC__
Xconfig.h: the test for undefining 'register' was wrong, it was undefing it
X	for all non-MSC compilers
Xmoria2.c: tunnel(), heavy weapon code wrong, eliminate >>2 of penalty, add
X	penalty instead of subtracting it
Xhelp.c: ident_char(), add period after Giant Frog.
Xmonsters.c: novice priest, change sleep from 10 to 5 to match other novice 'p'
Xmoria1.c, store2.c, *.c: get_item() new parameter 'message', when invalid
X	letter hit, print this message if non-zero instead of beeping,
X	store_sell() pass message "I do not buy such items.", fix all other
X	callers to pass CNIL
X-------- 4/28
Xmisc2.c, files.c: put_misc2(), file_character(), when player at max level,
X	don't print a number for Exp to Adv, instead print ******
Xio.c: msg_print(), put multiple messages on the same line if they are short
X	enough
X------- 5/22
Xexterns.h: ifdef out declaration of sprintf for NeXT
Xio.c (init_curses): correct atarist/GNUC code for signal call, ifdef was wrong
X------- 7/6
Xspells.c (unlight_area): Unlight all floor spaces with `lr' set, instead of
X	just the room floors spaces.  This darkens the doorways.
Xmoria1.c (light_room): Add code to set the fm flag, necessary so that the
X	above fix does not unlight doors that it shouldn't.
Xio.c (msg_print): Don't combine NULL messages with other messages.
Xsave.c (get_char): Use msg_print when printing the `departed spirit' message.
X-------- 7/26
Xstore2.c (purchase_haggle, sell_haggle): If the automatic increment plus the
X	last offer passes the shop keepers current ask, then clear the incr.
X-------- 10/5
X*: Add changes needed to prevent warnings from the IBM-PC TURBO C compiler.
Xmisc[1234].c, moria[1234].c: misc[12].c and moria[12].c were each split into
X	two files, because they were too large for TURBO C's integrated
X	environment
X*: adjust all makefiles, externs.h, etc to account for new moria/misc files
XTCCONFIG.TCU, TCPICK.TCU: new files, uuencoded copies of Turbo C setup files
Xconfig.h, ms_misc.c: New define USING_TCIO, used to prevent including curses.h
X	in ms_misc.c.  Defaults to defined if using TURBOC on an IBM-PC.
Xio.c: delete special purpose AMIGA code, it now uses curses
Xamiga/amiga.h: Deleted.
Xamiga/amiga.c: Delete all curses stubs.
X-------- 10/6
Xmacrsrc.h: change type of resType, ResID to long
Xmacrsrc.c: eliminated search_flag from macrsrc.c (see 3/30 changes)
Xconfig.h: put back switches RSRC, RSRC_PART1 and RSRC_PART2
XScrnMgr.ro: changed def of MBAR #228 (fixes crash on Mac Plus) and INFO #1
X	(Make default window be full screen)
XScrnMgr.c: check for reconfig flag enabled for THINK_C, add recognition
X	of MacClassic (and LC?) keyboard, now assumes unknown keyboard type
X	has control key, other misc cleanups
Xmoria.ro: changes version string
Xmacconf.c: config.h included for consistency
Xmac.c: added support for 8-column tabs
Xmac/Install.doc: new file, installation instructions for THINK C
Xmacconf.c, machelp.c, macscore.c scrnmgr.c: covered up error in THINK C
X	includes files OK/Cancel for ok/cancel
Xdeath.c, save.c: delete setmode calls for IBM-PC, instead open files in binary
X	mode
X--------- 10/12
X*: Changed version number to 5.4.
Xsave.c: change code to accept savefiles with version numbers greater than the
X	version number of the game, savefile format frozen as of 5.2.2
Xexterns.h: ifdef out the troublesome sprintf declaration
Xconfig.h: force `unix' to be defined for unix systems, since some stupid
X	systems (e.g. AIX) don't already define it
X--------- 10/15
Xexterns.h, moria4.c, ms_misc.c: correct typos discovered under MSDOS
X--------- 10/19
Xspells.doc, exp.doc: New documentation files.
X--------- 10/26
Xvms/uexit.c, externs.h, io.c, signals.c: Define uexit as void, and ifdef out
X	exit declarations when VMS.
Xvms/moria.opt: add misc[34].obj and moria[34].obj
Xibmpc/ms_misc.c: correct typo in error()
Xpr_items.c, pr_monst.c: main now returns 0
XCONFIG.DOC, TERMCAP, ms_ansi.c: use le/do instead of obsolete bc/xd
Xdragon.inf: moved from util/weapons to doc, and updated it to be accurate
Xspoilers: Update from USENET FAQ posting.
X--------- 11/17
Xio.c: ifdef out code checking for 8 char TABS, because it assumes that the
X	screen is exactly 80 characters wide
Xmoria[12].[ms/txt]: Correct a few typos.
X*: Fix all file permissions.
X::::::: 1992 ::::::::
XMaintenance taken over by David Grabiner
X--------- 7/16
Xmoria4.c: bash(), use random direction if player is confused
Xspells.c: fire_ball(), fire_bolt(), don't update recall if monster not lit;
X	this can happen if bolt hits an invisible monster
Xspells.c: speed_monsters(), sleep_monsters2(), dispel_creature(), 
X	turn_undead(), only affect creatures within MAX_SIGHT 
Xspells.c: mass_poly(), area of effect should be <= MAX_SIGHT, was <
Xspells.c: destroy_area(), remove light from player's spot
Xgenerate.c: build_tunnel(), added code from Richard Wesson to allow
X	tunnel to go through wall that is only two spaces thick,
X	otherwise two adjacent treasure rooms could not be connected
Xspells.c: enchant(), add new variable limit, chance of failure is now
X	(plusses/limit), with very slight chance of success over limit
Xscrolls.c: when enchanting melee weapons to damage, set limit to weapon's
X	maximum damage, otherwise use 10 to give behavior similar to old method
Xmisc2.c: magic_treasure(), make standard deviation of damage bonus on a melee 
X	weapon proportional to weapon's maximum damage; these changes mean
X	that daggers can no longer become powerful weapons
Xtreasure.c: the Zweihander has now become a great weapon, value increased from
X	1000 to 1500
Xexterns.h: fix declaration for enchant()
Xstaffs.c, wands.c: give everyone a slight chance to use difficult wands and
X	staffs, otherwise a warrior will never be able to use many items
X--------- 7/23
Xdeath.c: print_tomb(), insert msg_print(CNIL) so that "You are using:" and
X	"You are carrying:" don't get combined as one message; this made it
X	impossible to see the equipment list
Xstore2.c: haggle_insults(), insert msg_print(CNIL) so that insult is always
X	recognizable
Xstore2.c: purchase_haggle() and sell_haggle(), new variable didnt_haggle,
X	don't call updatebargain if no haggle
Xstore1.c: noneedtobargain(), changed to sliding scale, (good-3*bad) must
X	be more than 5 + (price/50) to skip haggling, so that haggling for
X	cheap items is over quickly, but can still eventually skip
X	haggle for all items
Xstore1.c: updatebargain(), now update for all items worth >9 gold, instead
X	of just 10-999, since it is now possible to skip haggling for more
X	valuable items as well
X--------- 7/25
Xmoria4.c: bash(), unsuccessful bash takes a turn; otherwise, you can
X	attempt to bash in different directions while confused or to locate
X	invisible monsters; eliminate variable no_bash
X--------- 7/27
Xcheck all above changes
Xmoria4.c: bash(), get "You bash at empty space" method when bashing a
X	wall, corrected to "nothing interesting	happens"; this also
X	prevents bashing from locating a secret door
X--------- 8/9
Xmerge in all changes from 5.4.0 to 5.4.1
Xcreature.c: update attack information only if monster is visible; update
X	death information even if monster is not visible, since
X	information will be on tombstone
X*: change version number to 5.5.0
X--------- 8/12
Xspells.c: enchant(), guard against randint(0) if called with limit of 0
X	(it shouldn't be).
Xmoria4.c: throw_object(), py_bash(), don't do negative damage
Xshortnam.sed, spells.c: fire_ball(), fix spelling of "envelops"
Xdoc/faq: remove old spoilers file, and put current FAQ here instead
X*: put my name (DJG) in credits as contact
X*: change copyright date in all source files to 1992
X---------- 8/13
Xrelease umoria 5.5.0
END_OF_FILE
if test 15638 -ne `wc -c <'CHANGES'`; then
    echo shar: \"'CHANGES'\" unpacked with wrong size!
fi
# end of 'CHANGES'
fi
if test -f 'ibmpc/make/makefile.top' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ibmpc/make/makefile.top'\"
else
echo shar: Extracting \"'ibmpc/make/makefile.top'\" \(1420 characters\)
sed "s/^X//" >'ibmpc/make/makefile.top' <<'END_OF_FILE'
XMODEL =		L
X
XOP =		M
X
XREDIR =		w$(OP)
X
XOPFLAG =	-DMSDOS=1 -DPC_CURSES=1 -DANSI=1
X
XOBJ =		o$(OP)
X
XFLAG =		-A$(MODEL) -Zp -W3 -Os -Gs -Gt32 -I.. $(OPFLAG)
X
XCFLAG =		$(FLAG)
X
XLFLAG =		/STACK:16383 /E $(MODEL)curses
X
XSRC1 =	\
X	ibmpc\ms_ansi.c\
X	ibmpc\ms_misc.c\
X	misc\flock.c\
X	misc\funckeys.c\
X	misc\nomacio.c\
X	source\create.c\
X	source\creature.c\
X	source\death.c\
X	source\desc.c\
X	source\dungeon.c
X
XSRC2 =	\
X	source\eat.c\
X	source\files.c\
X	source\generate.c\
X	source\help.c\
X	source\io.c\
X	source\magic.c\
X	source\main.c\
X	source\misc1.c\
X	source\misc2.c\
X	source\monsters.c
X
XSRC3 =	\
X	source\moria1.c\
X	source\moria2.c\
X	source\potions.c\
X	source\prayer.c\
X	source\recall.c\
X	source\rnd.c\
X	source\save.c\
X	source\scrolls.c\
X	source\sets.c\
X	source\signals.c
X
XSRC4 =	\
X	source\spells.c\
X	source\staffs.c\
X	source\store1.c\
X	source\store2.c\
X	source\treasure.c\
X	source\undef.c\
X	source\variable.c\
X	source\wands.c\
X	source\wizard.c
X
Xtags:	$(SRC1) $(SRC2) $(SRC3) $(SRC4)
X	ctags -o sgat ibmpc\*.c misc\*.c source\*.c
X	sort -u sgat > tags
X	rm -f sgat
X
Xall:
X	cd ibmpc
X	make MODEL=$(MODEL) OP=$(OP) OBJ=$(OBJ) REDIR=$(REDIR) \
X		FLAG="$(FLAG)" ibmpc.mak
X	cd ..\misc
X	make MODEL=$(MODEL) OP=$(OP) OBJ=$(OBJ) REDIR=$(REDIR) \
X		FLAG="$(FLAG)" misc.mak
X	cd ..\source
X	make MODEL=$(MODEL) OP=$(OP) OBJ=$(OBJ) REDIR=$(REDIR) \
X		FLAG="$(FLAG)" source.mak
X	cd ..\$(OBJ)
X	cl $(CFLAG) -Feumoria.exe *.$(OBJ) /link $(LFLAG);
X	cd ..
X
END_OF_FILE
if test 1420 -ne `wc -c <'ibmpc/make/makefile.top'`; then
    echo shar: \"'ibmpc/make/makefile.top'\" unpacked with wrong size!
fi
# end of 'ibmpc/make/makefile.top'
fi
if test -f 'source/io.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/io.c'\"
else
echo shar: Extracting \"'source/io.c'\" \(35784 characters\)
sed "s/^X//" >'source/io.c' <<'END_OF_FILE'
X/* source/io.c: terminal I/O code, uses the curses package
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include <stdio.h>
X#ifndef STDIO_LOADED
X#define STDIO_LOADED
X#endif
X
X#include "config.h"
X
X#if defined(atarist) && defined(__GNUC__)
X#include <osbind.h>
X#endif
X
X#ifdef MSDOS
X#include <process.h>
X#endif
X
X#ifdef AMIGA
X/* detach from cli process */
Xlong _stack = 30000;
Xlong _priority = 0;
Xlong _BackGroundIO = 1;
Xchar *_procname = "Moria";
X#endif
X
X#if defined(NLS) && defined(lint)
X/* for AIX, don't let curses include the NL stuff */
X#undef NLS
X#endif
X
X#if !defined(GEMDOS)
X#ifdef MAC
X#ifdef THINK_C
X#include "ScrnMgr.h"
X#else
X#include <scrnmgr.h>
X#endif
X#else
X#include <curses.h>
X#endif
X#else	/* GEMDOS i.e. Atari ST */
X#include "curses.h"
Xlong wgetch();
X#ifdef ATARIST_TC
X#include <tos.h>	/* TC */
X#include <ext.h>
X#else
X#include <osbind.h>	/* MWC */
X#endif
Xchar *getenv();
X#endif
X
X/* These are included after curses.h to avoid redefintion warnings for
X   TRUE, FALSE, and NULL.  */
X
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#include <ctype.h>
X
X#if defined(SYS_V) && defined(lint)
X/* for AIX, prevent hundreds of unnecessary lint errors, must define before
X   signal.h is included */
X#define _h_IEEETRAP
Xtypedef struct { int stuff; } fpvmach;
X#endif
X
X#if defined(MSDOS)
X#if defined(ANSI)
X#include "ms_ansi.h"
X#endif
X#else /* not msdos */
X#if !defined(ATARI_ST) && !defined(MAC) && !defined(AMIGA)
X#ifndef VMS
X#include <sys/ioctl.h>
X#endif
X#include <signal.h>
X#endif
X#endif
X
X#ifndef USG
X/* only needed for Berkeley UNIX */
X#include <sys/param.h>
X#include <sys/file.h>
X#include <sys/types.h>
X#endif
X
X#ifdef USG
X#ifndef ATARI_ST
X#include <string.h>
X#else
X#include "string.h"
X#endif
X#if 0
X/* Used to include termio.h here, but that caused problems on some systems,
X   as curses.h includes it also above.  */
X#if !defined(MAC) && !defined(MSDOS) && !defined(ATARI_ST)
X#if !defined(AMIGA) && !defined(VMS)
X#include <termio.h>
X#endif
X#endif
X#endif
X#else /* ! USG */
X#include <strings.h>
X#if defined(atarist) && defined(__GNUC__)
X/* doesn't have sys/wait.h */
X#else
X#include <sys/wait.h>
X#endif
X#endif
X
X#ifdef ATARIST_TC
X/* Include this to get prototypes for standard library functions.  */
X#include <stdlib.h>
X#endif
X
X#if defined(SYS_V) && defined(lint)
Xstruct screen { int dumb; };
X#endif
X
X/* Fooling lint. Unfortunately, c defines all the TIO.	  -CJS-
X   constants to be long, and lint expects them to be int. Also,
X   ioctl is sometimes called with just two arguments. The
X   following definition keeps lint happy. It may need to be
X   reset for different systems.	 */
X#ifndef MAC
X#ifdef lint
X#ifdef Pyramid
X/* Pyramid makes constants greater than 65535 into long! Gakk! -CJS- */
X/*ARGSUSED*/
X/*VARARGS2*/
Xstatic Ioctl(i, l, p) long l; char *p; { return 0; }
X#else
X/*ARGSUSED*/
X/*VARARGS2*/
Xstatic Ioctl(i, l, p) char *p; { return 0; }
X#endif
X#define ioctl	    Ioctl
X#endif
X
X#if !defined(USG) && defined(lint)
X/* This use_value hack is for curses macros which return a value,
X   but don't shut up about it when you try to tell them (void).	 */
X/* only needed for Berkeley UNIX */
Xint Use_value;
X#define use_value   Use_value +=
X#else
X#define use_value
X#endif
X
X#if defined(SYS_V) && defined(lint)
X/* This use_value2 hack is for curses macros which use a conditional
X   expression, and which say null effect even if you cast to (void). */
X/* only needed for SYS V */
Xint Use_value2;
X#define use_value2  Use_value2 +=
X#else
X#define use_value2
X#endif
X
X#endif
X
X#ifndef MAC
Xchar *getenv();
X#endif
X
X#ifndef VMS
X#ifdef USG
Xvoid exit();
X#if defined(__TURBOC__)
Xvoid sleep();
X#else
X#ifndef AMIGA
Xunsigned sleep();
X#endif
X#endif
X#endif
X#endif
X
X#ifdef ultrix
Xvoid exit();
Xvoid sleep();
X#endif
X
X#if !defined(MAC) && !defined(MSDOS) && !defined(ATARI_ST) && !defined(VMS)
X#ifndef AMIGA
X#ifdef USG
Xstatic struct termio save_termio;
X#else
Xstatic struct ltchars save_special_chars;
Xstatic struct sgttyb save_ttyb;
Xstatic struct tchars save_tchars;
Xstatic int save_local_chars;
X#endif
X#endif
X#endif
X
X#ifndef MAC
Xstatic int curses_on = FALSE;
Xstatic WINDOW *savescr;		/* Spare window for saving the screen. -CJS-*/
X#ifdef VMS
Xstatic WINDOW *tempscr;		/* Spare window for VMS CTRL('R'). */
X#endif
X#endif
X
X#ifdef MAC
X/* Attributes of normal and hilighted characters */
X#define ATTR_NORMAL	attrNormal
X#define ATTR_HILITED	attrReversed
X#endif
X
X#ifndef MAC
X#ifdef SIGTSTP
X/* suspend()							   -CJS-
X   Handle the stop and start signals. This ensures that the log
X   is up to date, and that the terminal is fully reset and
X   restored.  */
Xint suspend()
X{
X#ifdef USG
X  /* for USG systems with BSDisms that have SIGTSTP defined, but don't
X     actually implement it */
X#else
X  struct sgttyb tbuf;
X  struct ltchars lcbuf;
X  struct tchars cbuf;
X  int lbuf;
X  long time();
X
X  py.misc.male |= 2;
X  (void) ioctl(0, TIOCGETP, (char *)&tbuf);
X  (void) ioctl(0, TIOCGETC, (char *)&cbuf);
X  (void) ioctl(0, TIOCGLTC, (char *)&lcbuf);
X#if !defined(atarist) && !defined(__GNUC__)
X  (void) ioctl(0, TIOCLGET, (char *)&lbuf);
X#endif
X  restore_term();
X  (void) kill(0, SIGSTOP);
X  curses_on = TRUE;
X  (void) ioctl(0, TIOCSETP, (char *)&tbuf);
X  (void) ioctl(0, TIOCSETC, (char *)&cbuf);
X  (void) ioctl(0, TIOCSLTC, (char *)&lcbuf);
X#if !defined(atarist) && !defined(__GNUC__)
X  (void) ioctl(0, TIOCLSET, (char *)&lbuf);
X#endif
X  (void) wrefresh(curscr);
X  py.misc.male &= ~2;
X#endif
X  return 0;
X}
X#endif
X#endif
X
X/* initializes curses routines */
Xvoid init_curses()
X#ifdef MAC
X{
X  /* Primary initialization is done in mac.c since game is restartable */
X  /* Only need to clear the screen here */
X  Rect scrn;
X
X  scrn.left = scrn.top = 0;
X  scrn.right = SCRN_COLS;
X  scrn.bottom = SCRN_ROWS;
X  EraseScreen(&scrn);
X  UpdateScreen();
X}
X#else
X{
X  int i, y, x;
X
X#ifdef AMIGA
X  if (opentimer() == 0)
X    {
X      (void) printf ("Could not open timer device.\n");
X      exit (1);
X    }
X#endif
X
X#ifndef USG
X  (void) ioctl(0, TIOCGLTC, (char *)&save_special_chars);
X  (void) ioctl(0, TIOCGETP, (char *)&save_ttyb);
X  (void) ioctl(0, TIOCGETC, (char *)&save_tchars);
X#if !defined(atarist) && !defined(__GNUC__)
X  (void) ioctl(0, TIOCLGET, (char *)&save_local_chars);
X#endif
X#else
X#if !defined(VMS) && !defined(MSDOS) && !defined(ATARI_ST)
X#ifndef AMIGA
X  (void) ioctl(0, TCGETA, (char *)&save_termio);
X#endif
X#endif
X#endif
X
X  /* PC curses returns ERR */
X#if defined(USG) && !defined(PC_CURSES) && !defined(AMIGA)
X  if (initscr() == NULL)
X#else
X  if (initscr() == ERR)
X#endif
X    {
X      (void) printf("Error allocating screen in curses package.\n");
X      exit(1);
X    }
X  if (LINES < 24 || COLS < 80)	 /* Check we have enough screen. -CJS- */
X    {
X      (void) printf("Screen too small for moria.\n");
X      exit (1);
X    }
X#ifdef SIGTSTP
X#if defined(atarist) && defined(__GNUC__)
X  (void) signal (SIGTSTP, (__Sigfunc)suspend);
X#else
X  (void) signal (SIGTSTP, suspend);
X#endif
X#endif
X  if (((savescr = newwin (0, 0, 0, 0)) == NULL)
X#ifdef VMS
X      || ((tempscr = newwin (0, 0, 0, 0)) == NULL))
X#else
X    )
X#endif
X    {
X      (void) printf ("Out of memory in starting up curses.\n");
X      exit_game();
X    }
X  (void) clear();
X  (void) refresh();
X  moriaterm ();
X
X#if 0
X  /* This assumes that the terminal is 80 characters wide, which is not
X     guaranteed to be true.  */
X
X  /* check tab settings, exit with error if they are not 8 spaces apart */
X  (void) move(0, 0);
X  for (i = 1; i < 10; i++)
X    {
X      (void) addch('\t');
X      getyx(stdscr, y, x);
X      if (y != 0 || x != i*8)
X	break;
X    }
X  if (i != 10)
X    {
X      msg_print("Tabs must be set 8 spaces apart.");
X      exit_game();
X    }
X#endif
X}
X#endif
X
X/* Set up the terminal into a suitable state for moria.	 -CJS- */
Xvoid moriaterm()
X#ifdef MAC
X/* Nothing to do on Mac */
X{
X}
X#else
X{
X#if !defined(MSDOS) && !defined(ATARI_ST) && !defined(VMS)
X#ifndef AMIGA
X#ifdef USG
X  struct termio tbuf;
X#else
X  struct ltchars lbuf;
X  struct tchars buf;
X#endif
X#endif
X#endif
X
X  curses_on = TRUE;
X#ifndef BSD4_3
X  use_value crmode();
X#else
X#ifdef VMS
X  use_value vms_crmode ();
X#else
X  use_value cbreak();
X#endif
X#endif
X  use_value noecho();
X  /* can not use nonl(), because some curses do not handle it correctly */
X#ifdef MSDOS
X  msdos_raw();
X#else
X#ifdef AMIGA
X  init_color (0,   0,   0,   0);	/* pen 0 - black */
X  init_color (1,1000,1000,1000);	/* pen 1 - white */
X  init_color (2,   0, 300, 700);	/* pen 2 - blue */
X  init_color (3,1000, 500,   0);	/* pen 3 - orange */
X#else
X#if !defined(ATARI_ST) && !defined(VMS)
X#ifdef USG
X  (void) ioctl(0, TCGETA, (char *)&tbuf);
X  /* disable all of the normal special control characters */
X  tbuf.c_cc[VINTR] = (char)3; /* control-C */
X  tbuf.c_cc[VQUIT] = (char)-1;
X  tbuf.c_cc[VERASE] = (char)-1;
X  tbuf.c_cc[VKILL] = (char)-1;
X  tbuf.c_cc[VEOF] = (char)-1;
X
X  /* don't know what these are for */
X  tbuf.c_cc[VEOL] = (char)-1;
X#ifdef VEOL2
X  tbuf.c_cc[VEOL2] = (char)-1;
X#endif
X
X  /* stuff needed when !icanon, i.e. cbreak/raw mode */
X  tbuf.c_cc[VMIN] = 1;  /* Input should wait for at least 1 char */
X  tbuf.c_cc[VTIME] = 0; /* no matter how long that takes. */
X
X  (void) ioctl(0, TCSETA, (char *)&tbuf);
X#else
X  /* disable all of the special characters except the suspend char, interrupt
X     char, and the control flow start/stop characters */
X  (void) ioctl(0, TIOCGLTC, (char *)&lbuf);
X  lbuf.t_suspc = (char)26; /* control-Z */
X  lbuf.t_dsuspc = (char)-1;
X  lbuf.t_rprntc = (char)-1;
X  lbuf.t_flushc = (char)-1;
X  lbuf.t_werasc = (char)-1;
X  lbuf.t_lnextc = (char)-1;
X  (void) ioctl(0, TIOCSLTC, (char *)&lbuf);
X
X  (void) ioctl (0, TIOCGETC, (char *)&buf);
X  buf.t_intrc = (char)3; /* control-C */
X  buf.t_quitc = (char)-1;
X  buf.t_startc = (char)17; /* control-Q */
X  buf.t_stopc = (char)19; /* control-S */
X  buf.t_eofc = (char)-1;
X  buf.t_brkc = (char)-1;
X  (void) ioctl(0, TIOCSETC, (char *)&buf);
X#endif
X#endif
X#endif
X#endif
X
X#ifdef ATARIST_TC
X  raw ();
X#endif
X}
X#endif
X
X
X/* Dump IO to buffer					-RAK-	*/
Xvoid put_buffer(out_str, row, col)
Xchar *out_str;
Xint row, col;
X#ifdef MAC
X{
X  /* The screen manager handles writes past the edge ok */
X  DSetScreenCursor(col, row);
X  DWriteScreenStringAttr(out_str, ATTR_NORMAL);
X}
X#else
X{
X  vtype tmp_str;
X
X  /* truncate the string, to make sure that it won't go past right edge of
X     screen */
X  if (col > 79)
X    col = 79;
X  (void) strncpy (tmp_str, out_str, 79 - col);
X  tmp_str [79 - col] = '\0';
X
X  if (mvaddstr(row, col, tmp_str) == ERR)
X    {
X      abort();
X      /* clear msg_flag to avoid problems with unflushed messages */
X      msg_flag = 0;
X      (void) sprintf(tmp_str, "error in put_buffer, row = %d col = %d\n",
X		     row, col);
X      prt(tmp_str, 0, 0);
X      bell();
X      /* wait so user can see error */
X      (void) sleep(2);
X    }
X}
X#endif
X
X
X/* Dump the IO buffer to terminal			-RAK-	*/
Xvoid put_qio()
X{
X  screen_change = TRUE;	   /* Let inven_command know something has changed. */
X#ifdef MAC
X  UpdateScreen();
X#else
X  (void) refresh();
X#endif
X}
X
X/* Put the terminal in the original mode.			   -CJS- */
Xvoid restore_term()
X#ifdef MAC
X/* Nothing to do on Mac */
X{
X}
X#else
X{
X#ifdef AMIGA
X  closetimer ();
X#endif
X
X  if (!curses_on)
X    return;
X  put_qio();  /* Dump any remaining buffer */
X#ifdef MSDOS
X  (void) sleep(2);   /* And let it be read. */
X#endif
X#ifdef VMS
X  clear_screen();
X  pause_line(15);
X#endif
X  /* this moves curses to bottom right corner */
X  mvcur(stdscr->_cury, stdscr->_curx, LINES-1, 0);
X  endwin();  /* exit curses */
X  (void) fflush (stdout);
X#ifdef MSDOS
X  msdos_noraw();
X#endif
X  /* restore the saved values of the special chars */
X#ifdef USG
X#if !defined(MSDOS) && !defined(ATARI_ST) && !defined(VMS)
X#ifndef AMIGA
X  (void) ioctl(0, TCSETA, (char *)&save_termio);
X#endif
X#endif
X#else
X  (void) ioctl(0, TIOCSLTC, (char *)&save_special_chars);
X  (void) ioctl(0, TIOCSETP, (char *)&save_ttyb);
X  (void) ioctl(0, TIOCSETC, (char *)&save_tchars);
X#if !defined(atarist) && !defined(__GNUC__)
X  (void) ioctl(0, TIOCLSET, (char *)&save_local_chars);
X#endif
X#endif
X  curses_on = FALSE;
X}
X#endif
X
X
Xvoid shell_out()
X#if defined(atarist) && defined(__GNUC__)
X{ char fail_message[80], arg_list[1], *p;
X  int  escape_code;
X
X  save_screen();
X  clear_screen();
X  use_value nocbreak();         /* Must remember to reset terminal modes   */
X  use_value echo();             /* or shell i/o will be quite messed up!   */
X
X  p = (char *)getenv("SHELL");
X  if (p != (char *)NULL)
X    { put_buffer("Escaping to Shell\n",0,0);
X      put_qio();
X      arg_list[0]=0;
X      escape_code = Pexec(0,p,arg_list,0);   /* Launch the shell.          */
X
X      if (escape_code != 0)
X         { sprintf(fail_message,"Pexec() error code = %d\n",escape_code);
X           put_buffer(fail_message,0,0);
X           put_qio();
X	   sleep(5);
X	 }
X    }
X  use_value cbreak();        /* Reset the terminal back to CBREAK/NOECHO   */
X  use_value noecho();
X  clear_screen();            /* Do not want shell data on screen.          */
X  restore_screen();
X}
X
X#else
X
X#ifdef MAC
X{
X  alert_error("This command is not implemented on the Macintosh.");
X}
X#else
X#if defined(AMIGA) || defined(ATARIST_TC)
X{
X  put_buffer("This command is not implemented.\n", 0, 0);
X}
X#else
X#ifdef VMS /* TPP */
X{
X  int val, istat;
X  char *str;
X
X  save_screen();
X  /* clear screen and print 'exit' message */
X  clear_screen();
X  put_buffer("[Entering subprocess, type 'EOJ' to resume your game.]\n",
X	     0, 0);
X  put_qio();
X
X  use_value vms_nocrmode();
X  use_value echo();
X  ignore_signals();
X
X  istat = lib$spawn();
X  if (!istat)
X    lib$signal (istat);
X
X  restore_signals();
X  use_value vms_crmode();
X  use_value noecho();
X  /* restore the cave to the screen */
X  restore_screen();
X  put_buffer("Welcome back to UMoria.\n", 0, 0);
X  save_screen();
X  clear_screen();
X  put_qio();
X  restore_screen();
X  (void) wrefresh(curscr);
X}
X#else
X{
X#ifdef USG
X#if !defined(MSDOS) && !defined(ATARI_ST) && !defined(AMIGA)
X  struct termio tbuf;
X#endif
X#else
X  struct sgttyb tbuf;
X  struct ltchars lcbuf;
X  struct tchars cbuf;
X  int lbuf;
X#endif
X#ifdef MSDOS
X  char	*comspec, key;
X#else
X#ifdef ATARI_ST
X  char comstr[80];
X  char *str;
X  extern char **environ;
X#else
X  int val;
X  char *str;
X#endif
X#endif
X
X  save_screen();
X  /* clear screen and print 'exit' message */
X  clear_screen();
X#ifndef ATARI_ST
X  put_buffer("[Entering shell, type 'exit' to resume your game.]\n",0,0);
X#else
X  put_buffer("[Escaping to shell]\n",0,0);
X#endif
X  put_qio();
X
X#ifdef USG
X#if !defined(MSDOS) && !defined(ATARI_ST) && !defined(AMIGA)
X  (void) ioctl(0, TCGETA, (char *)&tbuf);
X#endif
X#else
X  (void) ioctl(0, TIOCGETP, (char *)&tbuf);
X  (void) ioctl(0, TIOCGETC, (char *)&cbuf);
X  (void) ioctl(0, TIOCGLTC, (char *)&lcbuf);
X  (void) ioctl(0, TIOCLGET, (char *)&lbuf);
X#endif
X  /* would call nl() here if could use nl()/nonl(), see moriaterm() */
X#ifndef BSD4_3
X  use_value nocrmode();
X#else
X#ifdef VMS
X  use_value vms_nocrmode ();
X#else
X  use_value nocbreak();
X#endif
X#endif
X#ifdef MSDOS
X  use_value msdos_noraw();
X#endif
X  use_value echo();
X  ignore_signals();
X#ifdef MSDOS		/*{*/
X  if ((comspec = getenv("COMSPEC")) == CNIL
X  ||  spawnl(P_WAIT, comspec, comspec, CNIL) < 0) {
X	clear_screen();	/* BOSS key if shell failed */
X	put_buffer("M:\\> ", 0, 0);
X	do {
X	  key = inkey();
X	} while (key != '!');
X  }
X
X#else		/* MSDOS }{*/
X#ifndef ATARI_ST
X  val = fork();
X  if (val == 0)
X    {
X#endif
X      default_signals();
X#ifdef USG
X#if !defined(MSDOS) && !defined(ATARI_ST) && !defined(AMIGA)
X      (void) ioctl(0, TCSETA, (char *)&save_termio);
X#endif
X#else
X      (void) ioctl(0, TIOCSLTC, (char *)&save_special_chars);
X      (void) ioctl(0, TIOCSETP, (char *)&save_ttyb);
X      (void) ioctl(0, TIOCSETC, (char *)&save_tchars);
X      (void) ioctl(0, TIOCLSET, (char *)&save_local_chars);
X#endif
X#ifndef MSDOS
X      /* close scoreboard descriptor */
X      /* it is not open on MSDOS machines */
X      (void) fclose(highscore_fp);
X#endif
X      if (str = getenv("SHELL"))
X#ifndef ATARI_ST
X	(void) execl(str, str, (char *) 0);
X#else
X	system(str);
X#endif
X      else
X#ifndef ATARI_ST
X	(void) execl("/bin/sh", "sh", (char *) 0);
X#endif
X      msg_print("Cannot execute shell.");
X#ifndef ATARI_ST
X      exit(1);
X    }
X  if (val == -1)
X    {
X      msg_print("Fork failed. Try again.");
X      return;
X    }
X#ifdef USG
X  (void) wait((int *) 0);
X#else
X  (void) wait((union wait *) 0);
X#endif
X#endif /* ATARI_ST */
X#endif		 /* MSDOS }*/
X  restore_signals();
X  /* restore the cave to the screen */
X  restore_screen();
X#ifndef BSD4_3
X  use_value crmode();
X#else
X#ifdef VMS
X  use_value vms_crmode ();
X#else
X  use_value cbreak();
X#endif
X#endif
X  use_value noecho();
X  /* would call nonl() here if could use nl()/nonl(), see moriaterm() */
X#ifdef MSDOS
X  msdos_raw();
X#endif
X  /* disable all of the local special characters except the suspend char */
X  /* have to disable ^Y for tunneling */
X#ifdef USG
X#if !defined(MSDOS) && !defined(ATARI_ST)
X  (void) ioctl(0, TCSETA, (char *)&tbuf);
X#endif
X#else
X  (void) ioctl(0, TIOCSLTC, (char *)&lcbuf);
X  (void) ioctl(0, TIOCSETP, (char *)&tbuf);
X  (void) ioctl(0, TIOCSETC, (char *)&cbuf);
X  (void) ioctl(0, TIOCLSET, (char *)&lbuf);
X#endif
X  (void) wrefresh(curscr);
X}
X#endif
X#endif
X#endif
X#endif
X
X/* Returns a single character input from the terminal.	This silently -CJS-
X   consumes ^R to redraw the screen and reset the terminal, so that this
X   operation can always be performed at any input prompt.  inkey() never
X   returns ^R.	*/
Xchar inkey()
X#ifdef MAC
X/* The Mac does not need ^R, so it just consumes it */
X/* This routine does nothing special with direction keys */
X/* Just returns their keypad ascii value (e.g. '0'-'9') */
X/* Compare with inkeydir() below */
X{
X  char ch;
X  int dir;
X  int shift_flag, ctrl_flag;
X
X  put_qio();
X  command_count = 0;
X
X  do {
X    macgetkey(&ch, FALSE);
X  } while (ch == CTRL('R'));
X
X  dir = extractdir(ch, &shift_flag, &ctrl_flag);
X  if (dir != -1)
X    ch = '0' + dir;
X
X  return(ch);
X}
X#else
X{
X  int i;
X#ifdef VMS
X  vtype tmp_str;
X#endif
X
X  put_qio();			/* Dump IO buffer		*/
X  command_count = 0;  /* Just to be safe -CJS- */
X  while (TRUE)
X    {
X#ifdef MSDOS
X      i = msdos_getch();
X#else
X#ifdef VMS
X      i = vms_getch ();
X#else
X      i = getch();
X#if defined(atarist) && defined(__GNUC__)
X/* for some reason a keypad number produces an initial negative number. */
X      if (i<0) i = getch();
X#endif
X#endif
X#endif
X
X#ifdef VMS
X      if (i == 27) /* if ESCAPE key, then we probably have a keypad key */
X	{
X	  i = vms_getch();
X	  if (i == 'O') /* Now it is definitely a numeric keypad key */
X	    {
X	      i = vms_getch();
X	      switch (i)
X		{
X		  case 'p': i = '0'; break;
X		  case 'q' : i = '1'; break;
X		  case 'r' : i = '2'; break;
X		  case 's' : i = '3'; break;
X		  case 't' : i = '4'; break;
X		  case 'u' : i = '5'; break;
X		  case 'v' : i = '6'; break;
X		  case 'w' : i = '7'; break;
X		  case 'x' : i = '8'; break;
X		  case 'y' : i = '9'; break;
X		  case 'm' : i = '-'; break;
X		  case 'M' : i = 10; break; /* Enter = RETURN */
X		  case 'n' : i = '.'; break;
X		  default : while (kbhit()) (void) vms_getch();
X		  }
X	    }
X	  else
X	    {
X	      while (kbhit())
X		(void) vms_getch();
X	    }
X	}
X#endif /* VMS */
X
X      /* some machines may not sign extend. */
X      if (i == EOF)
X	{
X	  eof_flag++;
X	  /* avoid infinite loops while trying to call inkey() for a -more-
X	     prompt. */
X	  msg_flag = FALSE;
X
X	  (void) refresh ();
X	  if (!character_generated || character_saved)
X	    exit_game();
X	  disturb(1, 0);
X	  if (eof_flag > 100)
X	    {
X	      /* just in case, to make sure that the process eventually dies */
X	      panic_save = 1;
X	      (void) strcpy(died_from, "(end of input: panic saved)");
X	      if (!save_char())
X		{
X		  (void) strcpy(died_from, "panic: unexpected eof");
X		  death = TRUE;
X		}
X	      exit_game();
X	    }
X	  return ESCAPE;
X	}
X      if (i != CTRL('R'))
X	return (char)i;
X#ifdef VMS
X      /* Refresh does not work right under VMS, so use a brute force. */
X      overwrite (stdscr, tempscr);
X      clear_screen();
X      put_qio();
X      overwrite (tempscr, stdscr);
X      touchwin (stdscr);
X      (void) wrefresh (stdscr);
X#endif
X      (void) wrefresh (curscr);
X      moriaterm();
X    }
X}
X#endif
X
X
X#ifdef MAC
Xchar inkeydir()
X/* The Mac does not need ^R, so it just consumes it */
X/* This routine translates the direction keys in rogue-like mode */
X/* Compare with inkeydir() below */
X{
X  char ch;
X  int dir;
X  int shift_flag, ctrl_flag;
X  static char tab[9] = {
X	'b',		'j',		'n',
X	'h',		'.',		'l',
X	'y',		'k',		'u'
X  };
X  static char shifttab[9] = {
X	'B',		'J',		'N',
X	'H',		'.',		'L',
X	'Y',		'K',		'U'
X  };
X  static char ctrltab[9] = {
X	CTRL('B'),	CTRL('J'),	CTRL('N'),
X	CTRL('H'),	'.',		CTRL('L'),
X	CTRL('Y'),	CTRL('K'),	CTRL('U')
X  };
X
X  put_qio();
X  command_count = 0;
X
X  do {
X    macgetkey(&ch, FALSE);
X  } while (ch == CTRL('R'));
X
X  dir = extractdir(ch, &shift_flag, &ctrl_flag);
X
X  if (dir != -1) {
X    if (!rogue_like_commands) {
X      ch = '0' + dir;
X    }
X    else {
X      if (ctrl_flag)
X	ch = ctrltab[dir - 1];
X      else if (shift_flag)
X	ch = shifttab[dir - 1];
X      else
X	ch = tab[dir - 1];
X    }
X  }
X
X  return(ch);
X}
X#endif
X
X
X/* Flush the buffer					-RAK-	*/
Xvoid flush()
X#ifdef MAC
X{
X/* Removed put_qio() call.  Reduces flashing.  Doesn't seem to hurt. */
X  FlushScreenKeys();
X}
X#else
X{
X#if defined(MSDOS)
X  while (kbhit())
X	(void) getch();
X#else
X#ifdef VMS
X  while (kbhit ())
X    (void) vms_getch();
X#else
X  /* the code originally used ioctls, TIOCDRAIN, or TIOCGETP/TIOCSETP, or
X     TCGETA/TCSETAF, however this occasionally resulted in loss of output,
X     the happened especially often when rlogin from BSD to SYS_V machine,
X     using check_input makes the desired effect a bit clearer */
X  /* wierd things happen on EOF, don't try to flush input in that case */
X  if (!eof_flag)
X    while (check_input(0));
X#endif
X#endif
X
X  /* used to call put_qio() here to drain output, but it is not necessary */
X}
X#endif
X
X
X/* Clears given line of text				-RAK-	*/
Xvoid erase_line(row, col)
Xint row;
Xint col;
X#ifdef MAC
X{
X  Rect line;
X
X  if (row == MSG_LINE && msg_flag)
X    msg_print(CNIL);
X
X  line.left = col;
X  line.top = row;
X  line.right = SCRN_COLS;
X  line.bottom = row + 1;
X  DEraseScreen(&line);
X}
X#else
X{
X  if (row == MSG_LINE && msg_flag)
X    msg_print(CNIL);
X  (void) move(row, col);
X  clrtoeol();
X}
X#endif
X
X
X/* Clears screen */
Xvoid clear_screen()
X#ifdef MAC
X{
X  Rect area;
X
X  if (msg_flag)
X    msg_print(CNIL);
X
X  area.left = area.top = 0;
X  area.right = SCRN_COLS;
X  area.bottom = SCRN_ROWS;
X  DEraseScreen(&area);
X}
X#else
X{
X  if (msg_flag)
X    msg_print(CNIL);
X#ifdef VMS
X  /* Clear doesn't work right under VMS, so use brute force. */
X  (void) clearok (stdscr, TRUE);
X  (void) wclear(stdscr);
X  (void) clearok (stdscr, FALSE);
X#else
X  (void) clear();
X#endif
X}
X#endif
X
Xvoid clear_from (row)
Xint row;
X#ifdef MAC
X{
X  Rect area;
X
X  area.left = 0;
X  area.top = row;
X  area.right = SCRN_COLS;
X  area.bottom = SCRN_ROWS;
X  DEraseScreen(&area);
X}
X#else
X{
X  (void) move(row, 0);
X  clrtobot();
X}
X#endif
X
X
X/* Outputs a char to a given interpolated y, x position	-RAK-	*/
X/* sign bit of a character used to indicate standout mode. -CJS */
Xvoid print(ch, row, col)
Xchar ch;
Xint row;
Xint col;
X#ifdef MAC
X{
X  char cnow, anow;
X
X  row -= panel_row_prt;/* Real co-ords convert to screen positions */
X  col -= panel_col_prt;
X
X  GetScreenCharAttr(&cnow, &anow, col, row);	/* Check current */
X
X  /* If char is already set, ignore op */
X  if ((cnow != ch) || (anow != ATTR_NORMAL))
X    DSetScreenCharAttr(ch & 0x7F,
X		       (ch & 0x80) ? attrReversed : attrNormal,
X		       col, row);
X}
X#else
X{
X  vtype tmp_str;
X
X  row -= panel_row_prt;/* Real co-ords convert to screen positions */
X  col -= panel_col_prt;
X  if (mvaddch (row, col, ch) == ERR)
X    {
X      abort();
X      /* clear msg_flag to avoid problems with unflushed messages */
X      msg_flag = 0;
X      (void) sprintf(tmp_str, "error in print, row = %d col = %d\n",
X		     row, col);
X      prt(tmp_str, 0, 0);
X      bell ();
X      /* wait so user can see error */
X      (void) sleep(2);
X    }
X}
X#endif
X
X
X/* Moves the cursor to a given interpolated y, x position	-RAK-	*/
Xvoid move_cursor_relative(row, col)
Xint row;
Xint col;
X#ifdef MAC
X{
X  row -= panel_row_prt;/* Real co-ords convert to screen positions */
X  col -= panel_col_prt;
X
X  DSetScreenCursor(col, row);
X}
X#else
X{
X  vtype tmp_str;
X
X  row -= panel_row_prt;/* Real co-ords convert to screen positions */
X  col -= panel_col_prt;
X  if (move (row, col) == ERR)
X    {
X      abort();
X      /* clear msg_flag to avoid problems with unflushed messages */
X      msg_flag = 0;
X      (void) sprintf(tmp_str,
X		     "error in move_cursor_relative, row = %d col = %d\n",
X		     row, col);
X      prt(tmp_str, 0, 0);
X      bell();
X      /* wait so user can see error */
X      (void) sleep(2);
X    }
X}
X#endif
X
X
X/* Print a message so as not to interrupt a counted command. -CJS- */
Xvoid count_msg_print(p)
Xchar *p;
X{
X  int i;
X
X  i = command_count;
X  msg_print(p);
X  command_count = i;
X}
X
X
X/* Outputs a line to a given y, x position		-RAK-	*/
Xvoid prt(str_buff, row, col)
Xchar *str_buff;
Xint row;
Xint col;
X#ifdef MAC
X{
X  Rect line;
X
X  if (row == MSG_LINE && msg_flag)
X    msg_print(CNIL);
X
X  line.left = col;
X  line.top = row;
X  line.right = SCRN_COLS;
X  line.bottom = row + 1;
X  DEraseScreen(&line);
X
X  put_buffer(str_buff, row, col);
X}
X#else
X{
X  if (row == MSG_LINE && msg_flag)
X    msg_print(CNIL);
X  (void) move(row, col);
X  clrtoeol();
X  put_buffer(str_buff, row, col);
X}
X#endif
X
X
X/* move cursor to a given y, x position */
Xvoid move_cursor(row, col)
Xint row, col;
X#ifdef MAC
X{
X  DSetScreenCursor(col, row);
X}
X#else
X{
X  (void) move (row, col);
X}
X#endif
X
X
X/* Outputs message to top line of screen				*/
X/* These messages are kept for later reference.	 */
Xvoid msg_print(str_buff)
Xchar *str_buff;
X{
X  register int old_len, new_len;
X  int combine_messages = FALSE;
X  char in_char;
X#ifdef MAC
X  Rect line;
X#endif
X
X  if (msg_flag)
X    {
X      old_len = strlen(old_msg[last_msg]) + 1;
X
X      /* If the new message and the old message are short enough, we want
X	 display them together on the same line.  So we don't flush the old
X	 message in this case.  */
X	 
X      if (str_buff)
X	new_len = strlen (str_buff);
X      else
X	new_len = 0;
X
X      if (! str_buff || (new_len + old_len + 2 >= 73))
X	{
X	  /* ensure that the complete -more- message is visible. */
X	  if (old_len > 73)
X	    old_len = 73;
X	  put_buffer(" -more-", MSG_LINE, old_len);
X	  /* let sigint handler know that we are waiting for a space */
X	  wait_for_more = 1;
X	  do
X	    {
X	      in_char = inkey();
X	    }
X	  while ((in_char != ' ') && (in_char != ESCAPE) && (in_char != '\n')
X		 && (in_char != '\r'));
X	  wait_for_more = 0;
X	}
X      else
X	combine_messages = TRUE;
X    }
X
X  if (! combine_messages)
X    {
X#ifdef MAC
X      line.left = 0;
X      line.top = MSG_LINE;
X      line.right = SCRN_COLS;
X      line.bottom = MSG_LINE+1;
X      DEraseScreen(&line);
X#else
X      (void) move(MSG_LINE, 0);
X      clrtoeol();
X#endif
X    }
X
X  /* Make the null string a special case.  -CJS- */
X  if (str_buff)
X    {
X      command_count = 0;
X      msg_flag = TRUE;
X
X      /* If the new message and the old message are short enough, display
X	 them on the same line.  */
X      
X      if (combine_messages)
X	{
X	  put_buffer (str_buff, MSG_LINE, old_len + 2);
X	  strcat (old_msg[last_msg], "  ");
X	  strcat (old_msg[last_msg], str_buff);
X	}
X      else
X	{
X	  put_buffer(str_buff, MSG_LINE, 0);
X	  last_msg++;
X	  if (last_msg >= MAX_SAVE_MSG)
X	    last_msg = 0;
X	  (void) strncpy(old_msg[last_msg], str_buff, VTYPESIZ);
X	  old_msg[last_msg][VTYPESIZ - 1] = '\0';
X	}
X    }
X  else
X    msg_flag = FALSE;
X}
X
X
X/* Used to verify a choice - user gets the chance to abort choice.  -CJS- */
Xint get_check(prompt)
Xchar *prompt;
X{
X  int res;
X#ifdef MAC
X  long y, x;		/* ??? Should change to int or short.  */
X#else
X  int y, x;
X#endif
X
X  prt(prompt, 0, 0);
X#ifdef MAC
X  GetScreenCursor(&x, &y);
X#else
X  getyx(stdscr, y, x);
X#if defined(lint)
X  /* prevent message 'warning: y is unused' */
X  x = y;
X#endif
X#ifdef LINT_ARGS
X  /* prevent message about y never used for MSDOS systems */
X  res = y;
X#endif
X#endif
X
X  if (x > 73)
X    (void) move(0, 73);
X#ifdef MAC
X  DWriteScreenStringAttr(" [y/n]", ATTR_NORMAL);
X#else
X  (void) addstr(" [y/n]");
X#endif
X  do
X    {
X      res = inkey();
X    }
X  while(res == ' ');
X  erase_line(0, 0);
X  if (res == 'Y' || res == 'y')
X    return TRUE;
X  else
X    return FALSE;
X}
X
X/* Prompts (optional) and returns ord value of input char	*/
X/* Function returns false if <ESCAPE> is input	*/
Xint get_com(prompt, command)
Xchar *prompt;
Xchar *command;
X{
X  int res;
X
X  if (prompt)
X    prt(prompt, 0, 0);
X  *command = inkey();
X  if (*command == ESCAPE)
X    res = FALSE;
X  else
X    res = TRUE;
X  erase_line(MSG_LINE, 0);
X  return(res);
X}
X
X#ifdef MAC
X/* Same as get_com(), but translates direction keys from keypad */
Xint get_comdir(prompt, command)
Xchar *prompt;
Xchar *command;
X{
X  int res;
X
X  if (prompt)
X    prt(prompt, 0, 0);
X  *command = inkeydir();
X  if (*command == ESCAPE)
X    res = FALSE;
X  else
X    res = TRUE;
X  erase_line(MSG_LINE, 0);
X  return(res);
X}
X#endif
X
X
X/* Gets a string terminated by <RETURN>		*/
X/* Function returns false if <ESCAPE> is input	*/
Xint get_string(in_str, row, column, slen)
Xchar *in_str;
Xint row, column, slen;
X{
X  register int start_col, end_col, i;
X  char *p;
X  int flag, aborted;
X#ifdef MAC
X  Rect area;
X#endif
X
X  aborted = FALSE;
X  flag	= FALSE;
X#ifdef MAC
X  area.left = column;
X  area.top = row;
X  area.right = column + slen;
X  area.bottom = row + 1;
X  DEraseScreen(&area);
X  DSetScreenCursor(column, row);
X#else
X  (void) move(row, column);
X  for (i = slen; i > 0; i--)
X    (void) addch(' ');
X  (void) move(row, column);
X#endif
X  start_col = column;
X  end_col = column + slen - 1;
X  if (end_col > 79)
X    {
X      slen = 80 - column;
X      end_col = 79;
X    }
X  p = in_str;
X  do
X    {
X      i = inkey();
X      switch(i)
X	{
X	case ESCAPE:
X	  aborted = TRUE;
X	  break;
X	case CTRL('J'): case CTRL('M'):
X	  flag	= TRUE;
X	  break;
X	case DELETE: case CTRL('H'):
X	  if (column > start_col)
X	    {
X	      column--;
X	      put_buffer(" ", row, column);
X	      move_cursor(row, column);
X	      *--p = '\0';
X	    }
X	  break;
X	default:
X	  if (!isprint(i) || column > end_col)
X	    bell();
X	  else
X	    {
X#ifdef MAC
X	      DSetScreenCursor(column, row);
X	      DWriteScreenCharAttr((char) i, ATTR_NORMAL);
X#else
X	      use_value2 mvaddch(row, column, (char)i);
X#endif
X	      *p++ = i;
X	      column++;
X	    }
X	  break;
X	}
X    }
X  while ((!flag) && (!aborted));
X  if (aborted)
X    return(FALSE);
X  /* Remove trailing blanks	*/
X  while (p > in_str && p[-1] == ' ')
X    p--;
X  *p = '\0';
X  return(TRUE);
X}
X
X
X/* Pauses for user response before returning		-RAK-	*/
Xvoid pause_line(prt_line)
Xint prt_line;
X{
X  prt("[Press any key to continue.]", prt_line, 23);
X  (void) inkey();
X  erase_line(prt_line, 0);
X}
X
X
X/* Pauses for user response before returning		-RAK-	*/
X/* NOTE: Delay is for players trying to roll up "perfect"	*/
X/*	characters.  Make them wait a bit.			*/
Xvoid pause_exit(prt_line, delay)
Xint prt_line;
Xint delay;
X{
X  char dummy;
X
X  prt("[Press any key to continue, or Q to exit.]", prt_line, 10);
X  dummy = inkey();
X  if (dummy == 'Q')
X    {
X      erase_line(prt_line, 0);
X#ifndef MSDOS		/* PCs are slow enough as is  -dgk */
X      if (delay > 0)  (void) sleep((unsigned)delay);
X#else
X      /* prevent message about delay unused */
X      dummy = delay;
X#endif
X#ifdef MAC
X      enablefilemenu(FALSE);
X      exit_game();
X      enablefilemenu(TRUE);
X#else
X      exit_game();
X#endif
X    }
X  erase_line(prt_line, 0);
X}
X
X#ifdef MAC
Xvoid save_screen()
X{
X  mac_save_screen();
X}
X
Xvoid restore_screen()
X{
X  mac_restore_screen();
X}
X#else
Xvoid save_screen()
X{
X  overwrite(stdscr, savescr);
X}
X
Xvoid restore_screen()
X{
X  overwrite(savescr, stdscr);
X  touchwin(stdscr);
X}
X#endif
X
Xvoid bell()
X{
X  put_qio();
X
X  /* The player can turn off beeps if he/she finds them annoying.  */
X  if (! sound_beep_flag)
X    return;
X
X#ifdef MAC
X  mac_beep();
X#else
X  (void) write(1, "\007", 1);
X#endif
X}
X
X/* definitions used by screen_map() */
X/* index into border character array */
X#define TL 0	/* top left */
X#define TR 1
X#define BL 2
X#define BR 3
X#define HE 4	/* horizontal edge */
X#define VE 5
X
X/* character set to use */
X#ifdef MSDOS
X# ifdef ANSI
X#   define CH(x)	(ansi ? screen_border[0][x] : screen_border[1][x])
X# else
X#   define CH(x)	(screen_border[1][x])
X# endif
X#else
X#   define CH(x)	(screen_border[0][x])
X#endif
X
X  /* Display highest priority object in the RATIO by RATIO area */
X#define	RATIO 3
X
Xvoid screen_map()
X{
X  register int	i, j;
X  static int8u screen_border[2][6] = {
X    {'+', '+', '+', '+', '-', '|'},	/* normal chars */
X    {201, 187, 200, 188, 205, 186}	/* graphics chars */
X  };
X  int8u map[MAX_WIDTH / RATIO + 1];
X  int8u tmp;
X  int priority[256];
X  int row, orow, col, myrow, mycol = 0;
X#ifndef MAC
X  char prntscrnbuf[80];
X#endif
X
X  for (i = 0; i < 256; i++)
X    priority[i] = 0;
X  priority['<'] = 5;
X  priority['>'] = 5;
X  priority['@'] = 10;
X#ifdef MSDOS
X  priority[wallsym] = -5;
X  priority[floorsym] = -10;
X#else
X#ifndef ATARI_ST
X  priority['#'] = -5;
X#else
X  priority[(unsigned char)240] = -5;
X#endif
X  priority['.'] = -10;
X#endif
X  priority['\''] = -3;
X  priority[' '] = -15;
X
X  save_screen();
X  clear_screen();
X#ifdef MAC
X  DSetScreenCursor(0, 0);
X  DWriteScreenCharAttr(CH(TL), ATTR_NORMAL);
X  for (i = 0; i < MAX_WIDTH / RATIO; i++)
X    DWriteScreenCharAttr(CH(HE), ATTR_NORMAL);
X  DWriteScreenCharAttr(CH(TR), ATTR_NORMAL);
X#else
X  use_value2 mvaddch(0, 0, CH(TL));
X  for (i = 0; i < MAX_WIDTH / RATIO; i++)
X    (void) addch(CH(HE));
X  (void) addch(CH(TR));
X#endif
X  orow = -1;
X  map[MAX_WIDTH / RATIO] = '\0';
X  for (i = 0; i < MAX_HEIGHT; i++)
X    {
X      row = i / RATIO;
X      if (row != orow)
X	{
X	  if (orow >= 0)
X	    {
X#ifdef MAC
X	      DSetScreenCursor(0, orow+1);
X	      DWriteScreenCharAttr(CH(VE), ATTR_NORMAL);
X	      DWriteScreenString((char *) map);
X	      DWriteScreenCharAttr(CH(VE), ATTR_NORMAL);
X#else
X	      /* can not use mvprintw() on ibmpc, because PC-Curses is horribly
X		 written, and mvprintw() causes the fp emulation library to be
X		 linked with PC-Moria, makes the program 10K bigger */
X	      (void) sprintf(prntscrnbuf,"%c%s%c",CH(VE), map, CH(VE));
X	      use_value2 mvaddstr(orow+1, 0, prntscrnbuf);
X#endif
X	    }
X	  for (j = 0; j < MAX_WIDTH / RATIO; j++)
X	    map[j] = ' ';
X	  orow = row;
X	}
X      for (j = 0; j < MAX_WIDTH; j++)
X	{
X	  col = j / RATIO;
X	  tmp = loc_symbol(i, j);
X	  if (priority[map[col]] < priority[tmp])
X	    map[col] = tmp;
X	  if (map[col] == '@')
X	    {
X	      mycol = col + 1; /* account for border */
X	      myrow = row + 1;
X	    }
X	}
X    }
X  if (orow >= 0)
X    {
X#ifdef MAC
X      DSetScreenCursor(0, orow+1);
X      DWriteScreenCharAttr(CH(VE), ATTR_NORMAL);
X      DWriteScreenString((char *) map);
X      DWriteScreenCharAttr(CH(VE), ATTR_NORMAL);
X#else
X      (void) sprintf(prntscrnbuf,"%c%s%c",CH(VE), map, CH(VE));
X      use_value2 mvaddstr(orow+1, 0, prntscrnbuf);
X#endif
X    }
X#ifdef MAC
X  DSetScreenCursor(0, orow + 2);
X  DWriteScreenCharAttr(CH(BL), ATTR_NORMAL);
X  for (i = 0; i < MAX_WIDTH / RATIO; i++)
X    DWriteScreenCharAttr(CH(HE), ATTR_NORMAL);
X  DWriteScreenCharAttr(CH(BR), ATTR_NORMAL);
X#else
X  use_value2 mvaddch(orow + 2, 0, CH(BL));
X  for (i = 0; i < MAX_WIDTH / RATIO; i++)
X    (void) addch(CH(HE));
X  (void) addch(CH(BR));
X#endif
X
X#ifdef MAC
X  DSetScreenCursor(23, 23);
X  DWriteScreenStringAttr("Hit any key to continue", ATTR_NORMAL);
X  if (mycol > 0)
X    DSetScreenCursor(mycol, myrow);
X#else
X  use_value2 mvaddstr(23, 23, "Hit any key to continue");
X  if (mycol > 0)
X    (void) move(myrow, mycol);
X#endif
X  (void) inkey();
X  restore_screen();
X}
END_OF_FILE
if test 35784 -ne `wc -c <'source/io.c'`; then
    echo shar: \"'source/io.c'\" unpacked with wrong size!
fi
# end of 'source/io.c'
fi
echo shar: End of archive 13 \(of 39\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
