Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i061:  umoria4 - single player dungeon simulation (ver. 5.5), Part29/39
Message-ID: <3425@master.CNA.TEK.COM>
Date: 22 Aug 92 22:14:05 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1428
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 61
Archive-name: umoria4/Part29
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 29 (of 39)."
# Contents:  OOChanges.1 source/scrolls.c util/showmon.c
# Wrapped by billr@saab on Thu Aug 20 09:11:34 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'OOChanges.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'OOChanges.1'\"
else
echo shar: Extracting \"'OOChanges.1'\" \(27455 characters\)
sed "s/^X//" >'OOChanges.1' <<'END_OF_FILE'
X:::::1987 Fixes:::::
X87 fixes deleted, see the 4.85 or 4.87 sources
X:::::1988 Fixes:::::
X88 fixes deleted, see the 4.88 sources
X:::::1989 Fixes:::::
X---------------------  2/26
Xall files: merged the umoria and PC-Moria sources
Xcreature.c: get_moves(), 12 numbers were wrong for monster movement
Xwizard.c: a few more int to bigint_t changes needed in wizard mode commands
Xfiles.c: fix columns in monster dictionary so that everything lines up
Xmisc2.c, moria2.c: line up columns for print_new_spells() and examine_book()
X8 files: replace == with = in comments and strings
Xmagic.c, misc1.c, misc2.c, moria2.c, signals.c: missing/misplaced breaks
Xmonsters.c: 2 grey snakes, renamed one to green
Xmisc1.c: compact_objects, stmt which decrements cur_dis in wrong place
Xspells.c: disarm_all should not set traps to zero, should just clear trap
X	bits
Xmoria2.c: in jamdoor() i_ptr->p1 should be t_ptr->p1
Xmoria2.c: in place_trap(), covered pits should transform to open pits
Xmoria2.c: mon_take_hit(), int i should be bigint_t i
Xio.c: more prompt will now accept space/escape/return/linefeed
Xio.c: EOF code did not work on machine with unsigned characters
X------------------------ 2/27
Xsave.c: missing controlz calls on error returns
Xcreature.c: don't let non-moving creature move if glyph prevented it
X	from attacking
Xcreature.c: give monsters a chance to recover from Bash, depends on
X	square of monster level
Xmoria2.c: give monsters a chance to ignore bash, function of hitpoints
X	and level
Xspells.c: fixed restore_level, needed while loop
Xmoria2.c: monster_multiply(), i=18 statement in wrong place, would not
X	always multiply monster when it should
X--------------------- 3/2
Xmoria1.c: get_panel(), add one to y and x on lines 945/950, prevent scrolling
X	while inside rooms
X--------------------- 3/9
Xwizard.c: tmp_val = -999; for gold changed to tmp_lval
Xsignals.c: added SIGXCPU to list of signals that cause panic save
Xspells.c: call monster_name before mon_take_hit in fire_bolt()
Xmoria2.c: move_char (), stop before attacking a creature
Xdungeon.c: added move_char (5) to see_infra and see_invis setting and clearing
X--------------------- 3/10
Xcreature.c: added take_hit (0, ddesc) line to every monster spell, ensure
X	that player leaves resting/find/search modes
Xpotions.c: remove chp += mhp code from gain const potion, now chp = mhp
Xmoria2.c: change monster_death(), summon_object 4d2 instead of 4d3
X	so that comments match code
Xcreature.c: make_move(), prevent monster from moving again after opening
X	a door, also, make chance of opening locked door dependant on monster
X	level
Xmonsters.c: giant red ant lion, not hurt by fire, move&attack normally
X--------------------- 5/5
Xgenerate.c: fixed error in generation of type 3 (subtype 3) rooms
Xmisc2.c, config.c: added alternate wizard code/definitions
Xtreasur1.c: restore mana potion made more valuable (35 -> 350)
X	    staff of speed value increased   (800 -> 1000)
X	    ring of sustain charisma level changed (7 -> 44)
X	    ring of stupidity level decreased  (20 -> 7)
X	    potion of gain strength value increased  (200 -> 300)
Xvariable.c: halfling clan elder had 0% chance
X	    gave warrior higher base to hit chance than paladin
Xstore1.c: digging tools must be identified before price is adjusted
Xmisc1.c:  do not adjust cost of digging tools based on value of p1
X	  change all mods to fields toac/todam/tohit to be += or -=
X	  several items (mostly cursed items) needed %P1 added to name
X	  for digging tools, inc p1 instead of replacing it, so that tools
X	     will still have same minimum values as specified in treasur1.c
Xmonsters.c: Forest Wight should be able to open doors.
X	    Grey Wraith should not drain mana
Xmoria1.c: fix stealth so that it uses the value of p1
Xtreasur2.c: change 'a's to '&'s for doors
Xspells.c: word of destruction should not put wall over character
X	  Could not use wand of drain life at a distance
Xmoria2.c: when in find mode, attack if run into creature only if can't see it
X-------------------------5/7
Xmoria1.c,moria2.c: remove heavy weapon message from test_hit and put it in
X  py_attack instead
Xspells.c: teleport_away now calls unlite_spot if necessary, fixes bug that
X    I thought had been fixed 3/28/88
Xsave.c: for MSDOS: when restore save file, must search object list for secret
X    doors/traps, and convert the '#/.' char to wallsym/floorsym, when save
X    file, must do the reverse translation
Xspells.c: unlight_area() was really messed up, is much shorter now, will
X	always print "darkness" message now if it should
Xmisc1.c: cleaned up prt_map(), probably much faster now
Xmoria1.c: cleaned up light_room(), draw_block(), sub2_move_light(),
X	they are probably much faster now
Xall:  changed print(char *, int, int) to print(char, int, int) in io.c
Xmisc1.c: crown of the magi, now has RL instead of see invisible
X---------------------- 5/8
Xall: checked uses of fm/pl/tl for consistency,eliminate extra parens/tests/etc
Xdeath.c: changed call to exit(1) to exit_game instead,
Xio.c, dungeon.c: new function move_cursor_relative to position cursor on map
X--------------------- 5/13
XMoria.doc: added changes to bring it up-to-date, ran through Spell again
X--------------------- 5/18
Xspells.c: polymorph monster spell incorrect, missing an else flag = TRUE line
Xmoria2.c: fix setting of reset_flag in find mode in move_char() routine
XMoria.doc: created MacWrite version for Macintosh, plus some more editing
X	corrections
X--------------------- 5/29
Xdeath.c, externs.h, files.c, io.c, misc2.c, moria2.c: eliminated the function
X	pad, replaced most calls with printf %-30s formats
Xdeath.c: rewrote fill_str and renamed it to center_string, previously was
X	returning pointer to local variable
Xdeath.c: eliminated dprint, replaced it with calls to put_buffer
Xsignals.c: suspend handler now saves/restore special local chars (^R, ^W, etc)
Xgenerate.c: rewrote blank_cave, should be a bit faster now
Xexterns.h, io.c, misc1.c, variable.c: eliminate used_line array, no longer
X	call erase_line in prt_map in misc1.c
Xmisc2.c, moria1.c, store2.c: make sure cursor is always in the right
X	place after an inkey call
Xcreate.c, misc2.c: rewrite put_character and associated routines, line up
X	columns, eliminate strcat/strcpy calls
Xfiles.c: rewrote file_character so that it matches put_character, etc.
Xio.c: fixed put_buffer so that it won't print past right edge of screen
Xfiles.c, misc1.c, moria1.c, ms_misc1.c: loc_symbol rewritten, now checks
X	values of pl/tl/fm, did not correctly handle monsters which were
X	visible, but were not in a lighted spot
Xmoria1.c, io.c: rest() only erases MSG_LINE now if original 'hit ... to quit'
X	message displayed, new function in io.c erase_non_msg does this
Xmisc1.c: magic_treasure(), fixed helms which had wrong else level of cursed
X	items, added cursed rings of searching, set p1 value for amulet of magi
X---------------------- 5/30
Xtreasure1.c, treasure2.c: three axes changed from type 21 to 22, this prevents
X	the Priest shop from buying these weapons
X--------------------- 6/2
Xcreature.c, moria1.c, moria2.c, spells.c, types.h: massive reorganization
X	of the way that visible monsters are handled, now ml is set if and
X	only if the creature is visible on screen
Xcreature.c, externs.h, moria2.c: procedure check_mon_lite removed, calls to
X	it replaced by calls to update_mon ()
Xmisc1.c: delete unused code
Xcreature.c, moria2.c: two places needed to test fm in addition to pl and tl
Xspells.c: need to set fm/tl/pl before call to lite_spot/change_trap, eliminate
X	some unncessary calls to lite_spot, eliminate unneccsary clearing of fm
X------------------------- 6/8
Xdungeon.c, moria1.c, moria2.c: allow searching while blind, decrease chance of
X	successs if blind or have no light
Xmoria1.c, moria2.c, store2.c: change prt("", x, y) to erase_line (x, y)
Xmisc2.c: replace all "\0" with just ""
Xio.c, moria2.c, scrolls.c, store2.c: add '.' to end of sentences
Xdungeon.c, misc2.c, moria2.c, scrolls.c, store2.c: add msg_flag = FALSE after
X	lots of msg_prints, to make sure never get " -more" message line
Xcreature.c, dungeon.c, spells.c, staff.c: don't print 'light' message if blind
Xmoria2.c: disarm_trap(), make no_light and blind same penalty, increase
X	blind/no_light and confused penalties
Xmoria1.c: rewrote area_affect, delete redundant code, don't stop at doorway
X	if no_light and it is unlit
Xgenerate.c: fixed error in build_tunnel, stack points could overrun stack
X------------------------ 6/9
Xmoria1.c: change test_hit so that always miss 1/20, and always hit 1/20
Xmoria1.c, moria2.c, spells.c: changed fval incorrectly when manipulating
X	doors, only change to corr_floor2 if next_to4 a room space
Xcreature.c: in get_moves, change 1.732 to 2, makes it faster, also can no
X	longer circle monsters by moving in a diamond shape
Xdeath.c, io.c, files.c, main.c: for MSDOS, don't leave the highscore_fd file
X	open permanently
Xsave.c: save value of total_winner, in case of a forced call to save_char()
Xall, types.h: deleted MSDOS ifdefs, the bytlint/byteint/wordint/worlint type
X	definitions were confusing, so changed all to int8/int8u/int16u/int16
Xgenerate.c: rewrote loops to try to speed up level generation
X---------------- 6/12
Xmisc1.c: for items with duplicates in treasure1.c, set level of all equal
X	to that of lowest
Xtreasur2.c: several items did not match same item in treasure1.c
X----------------- 6/13
Xtreasur2.c: wands/staffs in store now have same level as those in dungeon
Xdungeon.c, misc2.c, moria1.c, ms_misc.c, store2.c: removed some ASCII
X	dependencies
X------------------ 6/16
Xexterns.h, constants.c, generate.c, misc1.c: fixes to make level generation
X	faster, rearrange order build_tunnel makes comparisons, call
X	correct_dir directly instead of through rand_dir, rewrite loops,
X	rewrite next_to4, rewrite next_to8
Xexterns.h, files.c, misc1.c, moria1.c, ms_misc.c: loc_symbol returns char
X== the following are due to CJS (Bruce Moria)
Xcreate.c: in get_money(), charisma was subtracted and added, now only add
Xdesc.c: unquote() did not work at all, rewrote the whole thing
X	in identify, string[0] == 'T' should be string[1]
Xmoria1.c: area_affect, for direction 1, the 3 should be a 2
Xmisc2.c, moria2.c, scrolls.c, spells.c, store2.c: change msg_print(" ") to ""
Xstore2.c: eliminate erase_line/display_commands at end of purchase_haggle
Xconfig.h: for defined(Pyramid), define ultrix
Xeat.c: py.stats.intel to s_ptr->intel
Xcreature.c:  in make_move(), set m_ptr at begining of function,
X	  in mon_move(), set m_ptr at begining of function,
X	test cmove before calling randint in mon_move()
X	change if (randint(10) > py.misc.stl) to && (randint(...))
Xdungeon.c: move random teleport outside innermost loop, put with other checks
X== end CJS fixes ==
Xcreature.c: collapse a large number of if (...) if (...) constructions
X	to if (... && ...)
Xconstant.h, desc.c, externs.h, generate.c, misc1.c, rnd.c, save.c,variables.c:
X	all versions now use rnd(), rnd does not use SYSV calling conventions
X	anymore	BSD random() states eliminated
Xgenerate.c: added code to build_tunnel to prevent infinite loops
X--------------- 6/19
X*.c: collapse a large number of if (...) if (...) constructions
X	to if (... && ...), delete unneeded braces
X---------------- 6/21
Xcreature.c, spells.c: build_wall and earthquake, now kill monster if it can
X	not move through walls, and it can not move out of the way of the new
X	wall, also, does more damage to those that escape, in creature.c,
X	if in wall, must escape to empty space
X----------------- 7/17
Xmain.c: added a setbuf call, for buffered output
X------------------ 8/4
Xmerging changes due to Christopher J Stuart...zillions of changes
Xstat structure changed
Xexterns.h: move functions definitions for lint to here
Xcreate.c: help functions sorta' added, money now more dependent on stats,
X	  really good/bad characters eliminated, etc...
X------------------ 8/8
Xcreature.c: new function disturb used, stop attacks if player dead, add
X	message for two attacks which had no message, confuse-monster only
X	works if monster actually hits, door bashing different and noisy too!,
X	creatures only eat lower level creatures, monster drawing changed,
X	monster memory added, etc...
X------------------ 8/9
Xdesc.c: eliminate lots of unnecessary strcpy/strlen/etc calls, can inscribe
X	objects, store/dungeon objects will be merged in the inventory when
X	objects are identified, if curse a special object it loses its
X	special ability, %d code for damage, %a code for armor, etc...
Xeat.c: misc changes...
X----------------- 8/11
Xhelp.c: moved help text into files, added monster recall info, etc...
X----------------- 8/14
XMoria.doc: editing changes, removed lots of unnecessary hyphens
Xio.c: rebuilt it (accidentally deleted current version)
Xdeath.c: scoring procedures moved elsewhere, print_tomb more efficient and
X	uses far less stack, final char display different, upon_death
X	changed to exit_game, etc...
Xgenerate.c: added STATIC and void
Xmagic.c: reduce indentation, increase spell damage, 7 dam/mana for Magic
X	Missle, 4 d/m for balls, 5 d/m for bolts, etc...
Xmisc1.c: crowns higher chance of magic, monster dist changed to increase
X	chance of higher level monsters, unnecessary uid/eid calls deleted,
X	m_level changed to include level[0] monsters, highlighting for ores,
X	disappear percentages for objects in compact_obj() modified, '!'
X	char added to magic descriptions, damage added to bows
X------------------- 8/15
Xmisc2.c: print message if gold/object created under player, stat handling
X	completely changed, new func title_strings, search/rest/paralysis/count
X	message print changed, new func prt_speed(), new stat functions, can
X	hide stat changes if unknown, get_name uses loginname if none entered,
X	change_name can print to file, inven drop/carry/etc changed to be
X	a little simpler, new func join_names, spell_chance/learn_spell/etc
X	chnaged to be a little simpler, get_spell with capital letter verifies
X	choice, etc...
X---------------------- 8/16
Xmonsters.c: no change
Xtreasure1.c: %d added to weapons, %a added to armor, plus to dam added to
X	bows, mage's guide should be mages' guide?? appostrophe removed
X---------------------- 8/17
Xtreasure2.c: change & in traps to a/an, scroll/potion subvals changed to 200
X	plus value in treasure1.c, etc...
Xpotions.c: every potion prints message, ident true only if something noticable
X	happens, greatly reduce indentation, stat handling different, etc...
Xprayer.c: reduce indentation greatly, use up mana if prayer fails, etc...
Xscrolls.c: reduce indentation, only ident if something noticable happens,
X	for identify must search for new location of scroll, etc...
Xsets.c: ifdef out unused functions
Xdungeon.c: add command counts, use new func disturb(), double regen if
X	searching, damage if really hungry, messages for protevil resist_heat
X	and resist_cold, new code for quiting rest mode, move teleport code
X	outside inner loop, add code to check strength/weight, find mode
X	done differently now, allow ^char for control characters, all
X	command chars translated to rogue_like chars, new commands = (options)
X	{ (inscribe) V (view scores) M deleted but W improved : (map area)
X	rogue-like summon ^S -> &, etc...
X---------------------- 8/24
Xfiles.c: init_scorefile deleted, intro->read_times, don't modify argv,
X	new func helpfile, print_map deleted, print_monsters deleted,
X	file_character now takes filename as argument, etc...
Xio.c: lint defs, new suspend function, much better curses handling,
X	new func moriaterm and restore_term, inkey does refresh on ^R, flush
X	should work now, new funct get_check, save_screen, restore_screen,
X	etc...
Xconstant.h: add defs for STATIC, ESCAPE, stats, increase treasure in
X	streamers, change store min and turnaround amount, MAX_MON_NATTACK,
X	MAX_EXP
Xwands.c: inscribe wand if empty, reduce indentation, etc...
Xstaffs.c: inscribe staff if empty, reduce indentation, etc...
Xspells.c: identify- update stats if affected, allow ident of equip items;
X	better light_line messages; when set pl false, must set fm false also;
X	misc, etc...
X------------------- 8/29
Xmoria1.c: new function enchanted(), part of py_bonuses split into
X	calc_bonuses, cur_char1/2 deleted, complete rewrite of inven_command
X	routines, new functions check_weight/verify, can display weights,
X	get_item can show either inven or equip, options added, run code
X	completely rewritten, misc, etc...
X--------------- 8/30
Xstore1.c: item_value has *item->number removed, many routines changed to pass
X	item pointer, identify removed from store_carry, known1/2 put in
X	store_create, store_maint alg changed, etc...
Xstore2.c: clean up handling of msg_flag, incremental haggling in get_haggle(),
X	display_command moved from purchase/sell_haggle to store_purchase/sell,
X	enter_store code cleaned up, etc...
Xconfig.h: misc...
Xexterns.h: add new variables, delete old variables, rearrange stuff, etc...
Xtypes.h: added logging structure and recall structure, etc...
Xvariables.c: add new variables, delete old variables, rearrange stuff,
X	remove learn from spell structure, change titles so none shared
X	between classes, etc...
X-------------- 8/31
Xmoria2.c: weight bug fixed, py_attack did not decrement inven_weight when
X	inven_wield was a missile, and the player was carrying more than one
X	of them
X-------------- 9/1
Xmoria2.c: carry has pickup option, new functions for inscribing objects,
X	summon_objects returns type/number of objects created, ditto
X	monster death, new function check_view, add todam for using bow/arrow,
X	bashing changes, new sub py_bash extracted from old bash code,
X	jamdoor p1 values changed successive spikes have smaller effect,
X	etc...
X------------- 9/2
Xmain.c: add bruce moria comment, new options, read environment variables, etc.
Xwizard.c: wizard can change weight and speed of character, etc...
Xunix.c: new file, contains UNIX specific code for user_name, check_input, and
X	system()
Xsignals.c: completely rewritten to be much nicer, same functionality
Xrecall.c: new file, for printing out monster memory info
Xsave.c: completely rewritten, same functionality, I think
X------------- 9/7
Xlint on mips machine
X------------- 9/8
Xlint on AIX (SYS V)
X------------- 9/9
Xlint on ultrix
X------------- 9/11
Xfix anonymous errors in order to get the program to compile...
Xio.c, ms_misc.c: put screen_map in io.c, and made it a default feature
Xsignals.c, main.c, io.c: on EOF, the program now returns ESCAPE char until
X	exits dungeon(), then saves with no penalty
X------------ 9/12
Xexterns.h, desc.c, variables.c, types.h: mushrooms/colors/rocks/etc changed to
X	char pointers instead of char arrays, saves space, make random init
X	faster, change player title to char pointers also
Xmoria1.c, potions.c, misc2.c, eat.c, dungeon.c, creature.c: cleanup handling
X	of chp and cmana, call prt_c* only once every time they change
Xdungeon.c: set pointers only once at start of procedure
Xeat.c: reduce indentation
Xio.c, dungeon.c: remove msg_flag = FALSE line from inkey and put it in
X	dungeon.c where get command
X------------ 9/14
Xcreature.c: change put_qio calls to just setting screen_change to true
Xdungeon.c: remove superfluous erase_line and put_qio calls
Xmany: make character numbers more clear, 'a' for 97, DELETE for 127, etc...
Xdesc.c: objdes() bug with ins_buf handling, now clear ins_buf if none
Xmany, moria1.c: made "Which dir?" default for get_dir()
X-------------- 9/15
Xmisc1.c, monsters.c, treasur[12].c, many others: changed all hit ponts from
X	strings to a char array of size two, changed damroll to take two
X	characters instead of a string, this eliminates most all scanf calls
X-------------- 9/18
Xmonsters.c, creature.c, types.h: replaced strings containing monster attacks
X	with 4 byte array containing index into a monster attack table,
X	this eliminates the rest of the scanf calls, and saves space
Xcreature.c: many duplicate damroll calls in make_attack collapsed into
X	a single damroll call
Xmoria2.c: in chest_trap(), moved exploding chest trap to end to avoid
X	dangling pointer problem; in twall, only light spot if c_ptr->tl
X	is true;
Xwizard.c, recall.c, desc.c, files.c: changes to fix handling of new damage
X	types for monsters and weapons
X---------------- 9/19
Xmany files: eliminated redundant trap_lista, fixed place_trap so that it
X	no longer takes a typ parameter, change_type no longer calls
X	place_trap, negative level values for traps all made positive
X	and diasrm_object() changed appropriately
Xexterns.h, dungeon.c, misc2.c, moria1.c, variables.c: eliminated print_stat
X	variable since it was not used very much
X---------------- 9/21
Xcreate.c, externs.h, variable.c: eliminated bit_array variable
Xvariable.c: eliminated names of unused Rogue class spells
Xmany files...: changed the floor/wall definitions from variables to constants,
X	changed the values to make tests easier, all fval comparisons now use
X	manifest constants, door type floors eliminated since new find/run
X	code made them unnecessary
Xconstant.h, misc2.c, externs.h, variable.c: changed var stat_column to
X	constant, eliminated password variables
Xmany files: changed moria_flag to new_level_flag, and reset_flag to
X	free_turn_flag
X------------- 9/23
Xmerged Xenix diffs and Atari ST diffs
Xtreasure1.c: potion of sleep no longer cures blindness
Xwands.c: wand of wonder was wrong had 2 << randint() instead of 1 << randint()
Xeat.c, potions.c, scrolls.c, staffs.c, treasur2.c, wands.c: added store
X	bought flag 0x80000000 to all food/potion/scroll/staff/wand objects
X	in treasure2.c, modifed the code so that these objects do not give
X	experience when used
Xall files: removed all floating point code except for randnor() and los()
Xmany files: hp_player(-damage,"") calls did not work, change them all to
X	direct calls to take_hit(damage),  hp_player string parameter
X	removed since no longer used
X------------- 9/25
Xconstant.h, config.h, externs.h, variable.c, misc1.c, misc2.c, potions.c:
X	floating point randnor code replaced by integer on that uses a table,
X	definition of MAXINT removed so there are now no differences between
X	16 bit and 32 bit versions of moria, MAXSHORT and MAXLONG defined
XMakefile, misc1.c, externs.h: calls to floor removed, math library no longer
X	used!!, DONT_DEFINE_CLASS def for SUN4 no longer needed
X------------- 9/27
Xmisc1.c: replaced los code with an integer arithmetic version by jnh (Joseph
X	Hall), moria now uses no floating point numbers
Xdungeon.c, files.c, moria1.c, store2.c, wizard.c: removed all sscanf calls
X	except for those in ms_misc.c, and one "%lx" in wizard.c
X------------ 9/28
Xtreasure1.c, treasure2.c, types.h: change subval and number to 8 bit integers,
X	move flags after name, move number before weight, save 12 bytes per
Xconstants.h, etc: INVEN_MAX definition removed, INVEN_ARRAY_SIZE 1 smaller
Xvariable.c: store_choice now array of 8 bit integers
Xmonsters.c, treasure2.c: change t_level and m_level to array of 16 bit ints
Xmany: interpretation of subval changed to fit it into byte, new range uses
X	p1 to decide whether stacking permitted, torches can now stack
Xcreate.c, types.h: changed size of history from 400 to 240 characters,
X	also print as lines of 60 instead of lines of 70
Xvariable.c, misc2.c, types.h: changed definition of spell_type from 12 to 6
X	bytes, new array spell_names to prevent duplicate strings,
X	no longer have entry for warriors
Xvariable.c, types.h: human female too light, made 150 from 120, also changed
X	every base/mod field from 16 bits to 8 bits
Xtypes.h, variable.c: in background_type, change next and bonus fields to
X	8 bit integers, added 50 to bonus to make it positive
X----------------- 9/29
Xmonsters.c: massive changes to monster file to fix inconsistencies
X----------------- 9/30
Xset.c: make flasks of oil vulnerable to frost and fire, like potions
Xmoria2.c: if set off a trap, temp set confused to zero to ensure that player
X	will move onto the trap instead of in random direction
Xio.c, externs.h: confirm() no longer used, deleted
Xtreasur1.c, treasur2.c: give non overlapping subvals to potions/scrolls,
X	duplicate ones caused problems for giving random names
Xdesc.c, treasur1.c: %M for mushrooms changed to %m
Xrecall.c: fix printing of monster hit points, two numbers instead of a string
Xmoria2.c: new look code from bruce moria, look in arcs so that can see
X	anything on the screen, allows access to monster memories
Xgenerate.c, misc2.c, moria1.c, moria2.c: various fixes to reduce code size,
X	increase speed, etc...
Xmisc1.c, etc...: popm and popt no longer take a pointer, instead return int,
X	pusht takes an int8u now instead of an int as a parameter
X---------------- 10/1
Xall: added copyright notice to every *.[ch] file
X--------------- 10/3
Xconfig.h, creature.c, recall.c, save.c: fixed a few bugs picked up by the
X	ultrix compiler
Xdungeon.c: disabled the save command
X-------------- 10/6
Xcreate.c, files.c, dungeon.c, main.c, save.c: wrote helpfile function,
X	changed calling sequence so that caller does not have to do anything
Xconstant.h, desc.c, variables.c: eliminated lots of excess colors/rocks/etc.
X	eliminated all duplicates except between potions and mushrooms
Xtypes.h: fixed _frac problem with exp and chp, had to be unsigned shorts
Xmisc1.c: made traps invisible again
Xmoria1.c, moria2.c, store2.c: replaced strcpy(string, "constant") code with
X	p = "constant" where possible
Xtreasure1.c, treasure2.c: changed subvals for wands/staffs/amulets so that
X	they start at zero, and don't have any missing numbers
Xspells.c: teleport_away() must clear m_ptr->ml before calling update_mon()
Xmoria1.c, spells.c: check lite_spot() calls, eliminate unnecessary ones
Xdeath.c, misc2.c, wizard.c: eliminated lots of unnecessary blanks in string
X	constants
X--------------- 10/7
Xmisc1.c, moria2.c, treasure1.c, treasure2.c: fixed lamp/torch subvals, again
X	can not let torches have subval >= 64, the torch wield code will
X	not work
Xstore1.c: don't let items with subval >= 192 stack in stores, they are
X	always handled as a group anyways
Xspells.c: fire_bolt and fire_ball fixed in regards creature lighting
Xvariable.c: store_choice for temple wrong because broad aze renumbered
X	earlier, changed 13-15 to 12-14
Xconstant.h, dungeon.c, moria1.c: added print ac flag to status field,
X	calc_bonus sets flag, prevent printing AC while in store
Xcreate.c: dis_ac must have dis_tac added to it
Xspells.c: detect_monster evil and insivible now set m_ptr->ml when
X	print monster on screen, then creature() will correctly erase them
X--------------------- 10/8
Xtypes.h: fixed _frac problem with cmana, had to be unsigned short
Xmoria1.c: in inven_command wear code, print 'too heavy' message after
X	print wielding message
Xstore1.c: item_value, must multiply value by item->number before returning
Xstore1.c: sell_price return zero if item should not be put into store
Xmonsters.c: disenchanter bat sleep set from 0 to 1
Xall: eliminated all unnecessary elipses
Xconstants.h, creature.c, dungeon.c, eat.c: new defines for the creature
X	move, spell, and defense fields, eliminated all hex constants from
X	the 3 c files
X------------ 10/9
Xmoria2.c: fixed falling rock trap in move_char(), step back so that
X	player is not under the rubble
Xvariable.c: put copyright message in string, so that it appears in executable
Xspells.c: create_trap modified to light up trap, in case it is an open pit
Xall:replace prt calls with put_buffer where ever possible, because it's faster
Xexterns.h, io.c, signals.c: put ignore/default/restore_signal code back in
Xwizard.c: rewrote the version info
Xdungeon.c, moria2.c, signals.c: modified to use get_check() for consistency
X------------ 10/10
END_OF_FILE
if test 27455 -ne `wc -c <'OOChanges.1'`; then
    echo shar: \"'OOChanges.1'\" unpacked with wrong size!
fi
# end of 'OOChanges.1'
fi
if test -f 'source/scrolls.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/scrolls.c'\"
else
echo shar: Extracting \"'source/scrolls.c'\" \(13819 characters\)
sed "s/^X//" >'source/scrolls.c' <<'END_OF_FILE'
X/* source/scrolls.c: scroll code
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#ifdef __TURBOC__
X#include	<stdio.h>
X#endif /* __TURBOC__ */
X 
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#ifdef USG
X#include <string.h>
X#else
X#include <strings.h>
X#endif
X
X/* Scrolls for the reading				-RAK-	*/
Xvoid read_scroll()
X{
X  int32u i;
X  int j, k, item_val, y, x;
X  int tmp[6], flag, used_up;
X  bigvtype out_val, tmp_str;
X  register int ident, l;
X  register inven_type *i_ptr;
X  register struct misc *m_ptr;
X#ifdef ATARIST_MWC
X  int32u holder = TR_CURSED;
X#endif
X
X  free_turn_flag = TRUE;
X  if (py.flags.blind > 0)
X    msg_print("You can't see to read the scroll.");
X  else if (no_light())
X    msg_print("You have no light to read by.");
X  else if (py.flags.confused > 0)
X    msg_print("You are too confused to read a scroll.");
X  else if (inven_ctr == 0)
X    msg_print("You are not carrying anything!");
X  else if (!find_range(TV_SCROLL1, TV_SCROLL2, &j, &k))
X    msg_print ("You are not carrying any scrolls!");
X  else if (get_item(&item_val, "Read which scroll?", j, k, CNIL, CNIL))
X    {
X      i_ptr = &inventory[item_val];
X      free_turn_flag = FALSE;
X      used_up = TRUE;
X      i = i_ptr->flags;
X      ident = FALSE;
X
X      while (i != 0)
X	{
X	  j = bit_pos(&i) + 1;
X	  if (i_ptr->tval == TV_SCROLL2)
X	    j += 32;
X
X	  /* Scrolls.			*/
X	  switch(j)
X	    {
X	    case 1:
X	      i_ptr = &inventory[INVEN_WIELD];
X	      if (i_ptr->tval != TV_NOTHING)
X		{
X		  objdes(tmp_str, i_ptr, FALSE);
X		  (void) sprintf(out_val, "Your %s glows faintly!", tmp_str);
X		  msg_print(out_val);
X		  if (enchant(&i_ptr->tohit, 10))
X		    {
X#ifdef ATARIST_MWC
X		      i_ptr->flags &= ~holder;
X#else
X		      i_ptr->flags &= ~TR_CURSED;
X#endif
X		      calc_bonuses();
X		    }
X		  else
X		    msg_print("The enchantment fails.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 2:
X	      i_ptr = &inventory[INVEN_WIELD];
X	      if (i_ptr->tval != TV_NOTHING)
X		{
X		  objdes(tmp_str, i_ptr, FALSE);
X		  (void) sprintf(out_val, "Your %s glows faintly!", tmp_str);
X		  msg_print(out_val);
X		  if ((i_ptr->tval >= TV_HAFTED)&&(i_ptr->tval <= TV_DIGGING))
X		    j = i_ptr->damage[0] * i_ptr->damage[1];
X		  else /* Bows' and arrows' enchantments should not be limited
X			  by their low base damages */
X		    j = 10; 
X		  if (enchant(&i_ptr->todam, j))
X		    {
X#ifdef ATARIST_MWC
X		      i_ptr->flags &= ~holder;
X#else
X		      i_ptr->flags &= ~TR_CURSED;
X#endif
X		      calc_bonuses ();
X		    }
X		  else
X		    msg_print("The enchantment fails.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 3:
X	      k = 0;
X	      l = 0;
X	      if (inventory[INVEN_BODY].tval != TV_NOTHING)
X		tmp[k++] = INVEN_BODY;
X	      if (inventory[INVEN_ARM].tval != TV_NOTHING)
X		tmp[k++] = INVEN_ARM;
X	      if (inventory[INVEN_OUTER].tval != TV_NOTHING)
X		tmp[k++] = INVEN_OUTER;
X	      if (inventory[INVEN_HANDS].tval != TV_NOTHING)
X		tmp[k++] = INVEN_HANDS;
X	      if (inventory[INVEN_HEAD].tval != TV_NOTHING)
X		tmp[k++] = INVEN_HEAD;
X	      /* also enchant boots */
X	      if (inventory[INVEN_FEET].tval != TV_NOTHING)
X		tmp[k++] = INVEN_FEET;
X
X	      if (k > 0)  l = tmp[randint(k)-1];
X#ifdef ATARIST_MWC
X	      if (holder & inventory[INVEN_BODY].flags)
X		l = INVEN_BODY;
X	      else if (holder & inventory[INVEN_ARM].flags)
X		l = INVEN_ARM;
X	      else if (holder & inventory[INVEN_OUTER].flags)
X		l = INVEN_OUTER;
X	      else if (holder & inventory[INVEN_HEAD].flags)
X		l = INVEN_HEAD;
X	      else if (holder & inventory[INVEN_HANDS].flags)
X		l = INVEN_HANDS;
X	      else if (holder & inventory[INVEN_FEET].flags)
X		l = INVEN_FEET;
X#else
X	      if (TR_CURSED & inventory[INVEN_BODY].flags)
X		l = INVEN_BODY;
X	      else if (TR_CURSED & inventory[INVEN_ARM].flags)
X		l = INVEN_ARM;
X	      else if (TR_CURSED & inventory[INVEN_OUTER].flags)
X		l = INVEN_OUTER;
X	      else if (TR_CURSED & inventory[INVEN_HEAD].flags)
X		l = INVEN_HEAD;
X	      else if (TR_CURSED & inventory[INVEN_HANDS].flags)
X		l = INVEN_HANDS;
X	      else if (TR_CURSED & inventory[INVEN_FEET].flags)
X		l = INVEN_FEET;
X#endif
X
X	      if (l > 0)
X		{
X		  i_ptr = &inventory[l];
X		  objdes(tmp_str, i_ptr, FALSE);
X		  (void) sprintf(out_val, "Your %s glows faintly!", tmp_str);
X		  msg_print(out_val);
X		  if (enchant(&i_ptr->toac, 10))
X		    {
X#ifdef ATARIST_MWC
X		      i_ptr->flags &= ~holder;
X#else
X		      i_ptr->flags &= ~TR_CURSED;
X#endif
X		      calc_bonuses ();
X		    }
X		  else
X		    msg_print("The enchantment fails.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 4:
X	      msg_print("This is an identify scroll.");
X	      ident = TRUE;
X	      used_up = ident_spell();
X
X	      /* The identify may merge objects, causing the identify scroll
X		 to move to a different place.	Check for that here.  It can
X		 move arbitrarily far if an identify scroll was used on
X		 another identify scroll, but it always moves down. */
X	      while (i_ptr->tval != TV_SCROLL1 || i_ptr->flags != 0x00000008)
X		{
X		  item_val--;
X		  i_ptr = &inventory[item_val];
X		}
X	      break;
X	    case 5:
X	      if (remove_curse())
X		{
X		  msg_print("You feel as if someone is watching over you.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 6:
X	      ident = light_area(char_row, char_col);
X	      break;
X	    case 7:
X	      for (k = 0; k < randint(3); k++)
X		{
X		  y = char_row;
X		  x = char_col;
X		  ident |= summon_monster(&y, &x, FALSE);
X		}
X	      break;
X	    case 8:
X	      teleport(10);
X	      ident = TRUE;
X	      break;
X	    case 9:
X	      teleport(100);
X	      ident = TRUE;
X	      break;
X	    case 10:
X	      dun_level += (-3) + 2*randint(2);
X	      if (dun_level < 1)
X		dun_level = 1;
X	      new_level_flag = TRUE;
X	      ident = TRUE;
X	      break;
X	    case 11:
X	      if (py.flags.confuse_monster == 0)
X		{
X		  msg_print("Your hands begin to glow.");
X		  py.flags.confuse_monster = TRUE;
X		  ident = TRUE;
X		}
X	      break;
X	    case 12:
X	      ident = TRUE;
X	      map_area();
X	      break;
X	    case 13:
X	      ident = sleep_monsters1(char_row, char_col);
X	      break;
X	    case 14:
X	      ident = TRUE;
X	      warding_glyph();
X	      break;
X	    case 15:
X	      ident = detect_treasure();
X	      break;
X	    case 16:
X	      ident = detect_object();
X	      break;
X	    case 17:
X	      ident = detect_trap();
X	      break;
X	    case 18:
X	      ident = detect_sdoor();
X	      break;
X	    case 19:
X	      msg_print("This is a mass genocide scroll.");
X	      ident = mass_genocide();
X	      break;
X	    case 20:
X	      ident = detect_invisible();
X	      break;
X	    case 21:
X	      ident = aggravate_monster(20);
X	      if (ident)
X		msg_print("There is a high pitched humming noise.");
X	      break;
X	    case 22:
X	      ident = trap_creation();
X	      break;
X	    case 23:
X	      ident = td_destroy();
X	      break;
X	    case 24:
X	      ident = door_creation();
X	      break;
X	    case 25:
X	      msg_print("This is a Recharge-Item scroll.");
X	      ident = TRUE;
X	      used_up = recharge(60);
X	      break;
X	    case 26:
X	      msg_print("This is a genocide scroll.");
X	      ident = genocide();
X	      break;
X	    case 27:
X	      ident = unlight_area(char_row, char_col);
X	      break;
X	    case 28:
X	      ident = protect_evil();
X	      break;
X	    case 29:
X	      ident = TRUE;
X	      create_food();
X	      break;
X	    case 30:
X	      ident = dispel_creature(CD_UNDEAD, 60);
X	      break;
X	    case 33:
X	      i_ptr = &inventory[INVEN_WIELD];
X	      if (i_ptr->tval != TV_NOTHING)
X		{
X		  objdes(tmp_str, i_ptr, FALSE);
X		  (void) sprintf(out_val, "Your %s glows brightly!", tmp_str);
X		  msg_print(out_val);
X		  flag = FALSE;
X		  for (k = 0; k < randint(2); k++)
X		    if (enchant(&i_ptr->tohit, 10))
X		      flag = TRUE;
X		  if ((i_ptr->tval >= TV_HAFTED)&&(i_ptr->tval <= TV_DIGGING))
X		    j = i_ptr->damage[0] * i_ptr->damage[1];
X		  else /* Bows' and arrows' enchantments should not be limited
X			  by their low base damages */
X		    j = 10; 
X		  for (k = 0; k < randint(2); k++)
X		    if (enchant(&i_ptr->todam, j))
X		      flag = TRUE;
X		  if (flag)
X		    {
X#ifdef ATARIST_MWC
X		      i_ptr->flags &= ~holder;
X#else
X		      i_ptr->flags &= ~TR_CURSED;
X#endif
X		      calc_bonuses ();
X		    }
X		  else
X		    msg_print("The enchantment fails.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 34:
X	      i_ptr = &inventory[INVEN_WIELD];
X	      if (i_ptr->tval != TV_NOTHING)
X		{
X		  objdes(tmp_str, i_ptr, FALSE);
X		  (void)sprintf(out_val,"Your %s glows black, fades.",tmp_str);
X		  msg_print(out_val);
X		  unmagic_name(i_ptr);
X		  i_ptr->tohit = -randint(5) - randint(5);
X		  i_ptr->todam = -randint(5) - randint(5);
X		  /* Must call py_bonuses() before set (clear) flags, and
X		     must call calc_bonuses() after set (clear) flags, so that
X		     all attributes will be properly turned off. */
X		  py_bonuses(i_ptr, -1);
X		  i_ptr->flags = TR_CURSED;
X		  calc_bonuses ();
X		  ident = TRUE;
X		}
X	      break;
X	    case 35:
X	      k = 0;
X	      l = 0;
X	      if (inventory[INVEN_BODY].tval != TV_NOTHING)
X		tmp[k++] = INVEN_BODY;
X	      if (inventory[INVEN_ARM].tval != TV_NOTHING)
X		tmp[k++] = INVEN_ARM;
X	      if (inventory[INVEN_OUTER].tval != TV_NOTHING)
X		tmp[k++] = INVEN_OUTER;
X	      if (inventory[INVEN_HANDS].tval != TV_NOTHING)
X		tmp[k++] = INVEN_HANDS;
X	      if (inventory[INVEN_HEAD].tval != TV_NOTHING)
X		tmp[k++] = INVEN_HEAD;
X	      /* also enchant boots */
X	      if (inventory[INVEN_FEET].tval != TV_NOTHING)
X		tmp[k++] = INVEN_FEET;
X
X	      if (k > 0)  l = tmp[randint(k)-1];
X#ifdef ATARIST_MWC
X	      if (holder & inventory[INVEN_BODY].flags)
X		l = INVEN_BODY;
X	      else if (holder & inventory[INVEN_ARM].flags)
X		l = INVEN_ARM;
X	      else if (holder & inventory[INVEN_OUTER].flags)
X		l = INVEN_OUTER;
X	      else if (holder & inventory[INVEN_HEAD].flags)
X		l = INVEN_HEAD;
X	      else if (holder & inventory[INVEN_HANDS].flags)
X		l = INVEN_HANDS;
X	      else if (holder & inventory[INVEN_FEET].flags)
X		l = INVEN_FEET;
X#else
X	      if (TR_CURSED & inventory[INVEN_BODY].flags)
X		l = INVEN_BODY;
X	      else if (TR_CURSED & inventory[INVEN_ARM].flags)
X		l = INVEN_ARM;
X	      else if (TR_CURSED & inventory[INVEN_OUTER].flags)
X		l = INVEN_OUTER;
X	      else if (TR_CURSED & inventory[INVEN_HEAD].flags)
X		l = INVEN_HEAD;
X	      else if (TR_CURSED & inventory[INVEN_HANDS].flags)
X		l = INVEN_HANDS;
X	      else if (TR_CURSED & inventory[INVEN_FEET].flags)
X		l = INVEN_FEET;
X#endif
X
X	      if (l > 0)
X		{
X		  i_ptr = &inventory[l];
X		  objdes(tmp_str, i_ptr, FALSE);
X		  (void) sprintf(out_val,"Your %s glows brightly!", tmp_str);
X		  msg_print(out_val);
X		  flag = FALSE;
X		  for (k = 0; k < randint(2) + 1; k++)
X		    if (enchant(&i_ptr->toac, 10))
X		      flag = TRUE;
X		  if (flag)
X		    {
X#ifdef ATARIST_MWC
X		      i_ptr->flags &= ~holder;
X#else
X		      i_ptr->flags &= ~TR_CURSED;
X#endif
X		      calc_bonuses ();
X		    }
X		  else
X		    msg_print("The enchantment fails.");
X		  ident = TRUE;
X		}
X	      break;
X	    case 36:
X	      if ((inventory[INVEN_BODY].tval != TV_NOTHING)
X		  && (randint(4) == 1))
X		k = INVEN_BODY;
X	      else if ((inventory[INVEN_ARM].tval != TV_NOTHING)
X		       && (randint(3) ==1))
X		k = INVEN_ARM;
X	      else if ((inventory[INVEN_OUTER].tval != TV_NOTHING)
X		       && (randint(3) ==1))
X		k = INVEN_OUTER;
X	      else if ((inventory[INVEN_HEAD].tval != TV_NOTHING)
X		       && (randint(3) ==1))
X		k = INVEN_HEAD;
X	      else if ((inventory[INVEN_HANDS].tval != TV_NOTHING)
X		       && (randint(3) ==1))
X		k = INVEN_HANDS;
X	      else if ((inventory[INVEN_FEET].tval != TV_NOTHING)
X		       && (randint(3) ==1))
X		k = INVEN_FEET;
X	      else if (inventory[INVEN_BODY].tval != TV_NOTHING)
X		k = INVEN_BODY;
X	      else if (inventory[INVEN_ARM].tval != TV_NOTHING)
X		k = INVEN_ARM;
X	      else if (inventory[INVEN_OUTER].tval != TV_NOTHING)
X		k = INVEN_OUTER;
X	      else if (inventory[INVEN_HEAD].tval != TV_NOTHING)
X		k = INVEN_HEAD;
X	      else if (inventory[INVEN_HANDS].tval != TV_NOTHING)
X		k = INVEN_HANDS;
X	      else if (inventory[INVEN_FEET].tval != TV_NOTHING)
X		k = INVEN_FEET;
X	      else
X		k = 0;
X
X	      if (k > 0)
X		{
X		  i_ptr = &inventory[k];
X		  objdes(tmp_str, i_ptr, FALSE);
X		  (void)sprintf(out_val,"Your %s glows black, fades.",tmp_str);
X		  msg_print(out_val);
X		  unmagic_name(i_ptr);
X		  i_ptr->flags = TR_CURSED;
X		  i_ptr->toac = -randint(5) - randint(5);
X		  calc_bonuses ();
X		  ident = TRUE;
X		}
X	      break;
X	    case 37:
X	      ident = FALSE;
X	      for (k = 0; k < randint(3); k++)
X		{
X		  y = char_row;
X		  x = char_col;
X		  ident |= summon_undead(&y, &x);
X		}
X	      break;
X	    case 38:
X	      ident = TRUE;
X	      bless(randint(12)+6);
X	      break;
X	    case 39:
X	      ident = TRUE;
X	      bless(randint(24)+12);
X	      break;
X	    case 40:
X	      ident = TRUE;
X	      bless(randint(48)+24);
X	      break;
X	    case 41:
X	      ident = TRUE;
X	      if (py.flags.word_recall == 0)
X		py.flags.word_recall = 25 + randint(30);
X	      msg_print("The air about you becomes charged.");
X	      break;
X	    case 42:
X	      destroy_area(char_row, char_col);
X	      ident = TRUE;
X	      break;
X	    default:
X	      msg_print("Internal error in scroll()");
X	      break;
X	    }
X	  /* End of Scrolls.			       */
X	}
X      i_ptr = &inventory[item_val];
X      if (ident)
X	{
X	  if (!known1_p(i_ptr))
X	    {
X	      m_ptr = &py.misc;
X	      /* round half-way case up */
X	      m_ptr->exp += (i_ptr->level +(m_ptr->lev >> 1)) / m_ptr->lev;
X	      prt_experience();
X
X	      identify(&item_val);
X	      i_ptr = &inventory[item_val];
X	    }
X	}
X      else if (!known1_p(i_ptr))
X	sample (i_ptr);
X      if (used_up)
X	{
X	  desc_remain(item_val);
X	  inven_destroy(item_val);
X	}
X    }
X}
END_OF_FILE
if test 13819 -ne `wc -c <'source/scrolls.c'`; then
    echo shar: \"'source/scrolls.c'\" unpacked with wrong size!
fi
# end of 'source/scrolls.c'
fi
if test -f 'util/showmon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/showmon.c'\"
else
echo shar: Extracting \"'util/showmon.c'\" \(11673 characters\)
sed "s/^X//" >'util/showmon.c' <<'END_OF_FILE'
X/* this used to be in files.c, this is not a working program */
X
X/* move to cheat.c file */
X/* Prints a listing of monsters				-RAK-	 */
Xprint_monsters()
X{
X  register int i;
X  int j, xpos, attype, adesc, adice, asides, count;
X  register FILE *file1;
X  vtype out_val, filename1;
X  char *attstr;
X  register creature_type *c_ptr;
X  register char *string;
X
X  prt("File name: ", 0, 0);
X  if (get_string(filename1, 0, 11, 64))
X    {
X      if (strlen(filename1) == 0)
X	(void) strcpy(filename1, "MORIAMON.DAT");
X      if ((file1 = fopen(filename1, "w")) != NULL)
X	{
X	  prt("Writing Monster Dictionary...", 0, 0);
X	  put_qio();
X	  for (i = 0; i < MAX_CREATURES; i++)
X	    {
X	      c_ptr = &c_list[i];
X	      /* Begin writing to file				       */
X	      (void) fprintf(file1, "------------------------------------");
X	      (void) fprintf(file1, "--------\n");
X	      (void) fprintf(file1, "%3d  %-31s     (%c)\n", i, c_ptr->name,
X			     c_ptr->cchar);
X	      (void) fprintf(file1, "     Speed =%3d  Level     =%3d  Exp =%6u\n",
X		      c_ptr->speed-10, c_ptr->level, c_ptr->mexp);
X	      (void) fprintf(file1, "     AC    =%3d  Eye-sight =%3d  HD  =%6s\n",
X		      c_ptr->ac, c_ptr->aaf, c_ptr->hd);
X	      if (CM_WIN & c_ptr->cmove)
X		(void) fprintf(file1, "     Creature is a ***Win Creature***\n");
X	      if (CM_EATS_OTHER) & c_ptr->cmove)
X		(void) fprintf(file1, "     Creature Eats/kills other creatures.\n");
X	      if (CD_DRAGON & c_ptr->cdefense)
X		(void) fprintf(file1, "     Creature is a dragon.\n");
X	      if (CD_ANIMAL & c_ptr->cdefense)
X		(void) fprintf(file1, "     Creature is an animal.\n");
X	      if (CD_EVIL & c_ptr->cdefense)
X		(void) fprintf(file1, "     Creature is evil.\n");
X	      if (CD_UNDEAD & c_ptr->cdefense)
X		(void) fprintf(file1, "     Creature is undead.\n");
X	      if (CD_FROST & c_ptr->cdefense)
X		(void) fprintf(file1, "     Creature harmed by cold.\n");
X	      if (CD_FIRE & c_ptr->cdefense)
X		(void) fprintf(file1, "     Creature harmed by fire.\n");
X	      if (CD_POISON & c_ptr->cdefense)
X		(void) fprintf(file1, "     Creature harmed by poison.\n");
X	      if (CD_ACID & c_ptr->cdefense)
X		(void) fprintf(file1, "     Creature harmed by acid.\n");
X	      if (CD_LIGHT & c_ptr->cdefense)
X		(void) fprintf(file1, "     Creature harmed by blue light.\n");
X	      if (CD_STONE & c_ptr->cdefense)
X		(void) fprintf(file1, "     Creature harmed by Stone-to-Mud.\n");
X	      if (CD_NO_SLEEP & c_ptr->cdefense)
X		(void) fprintf(file1, "     Creature cannot be charmed or slept.\n");
X	      if (CD_INFRA & c_ptr->cdefense)
X		(void) fprintf(file1, "     Creature seen with Infra-Vision.\n");
X	      if (CD_MAX_HP & c_ptr->cdefense)
X		(void) fprintf(file1, "     Creature has MAX hit points.\n");
X	      if (CM_INVISIBLE & c_ptr->cmove)
X		(void) fprintf(file1, "     Creature is invisible.\n");
X	      if (CM_PICKS_UP & c_ptr->cmove)
X		(void) fprintf(file1, "     Creature picks up objects.\n");
X	      if (CM_MULTIPLY & c_ptr->cmove)
X		(void) fprintf(file1, "     Creature multiplies.\n");
X	      if (CM_CARRY_OBJ & c_ptr->cmove)
X		(void) fprintf(file1, "     Carries object(s).\n");
X	      if (CM_CARRY_GOLD & c_ptr->cmove)
X		(void) fprintf(file1, "     Carries gold, gems, etc.\n");
X	      if (CM_60_RANDOM & c_ptr->cmove)
X		(void) fprintf(file1, "       Has object/gold 60%% of time.\n");
X	      if (CM_90_RANDOM & c_ptr->cmove)
X		(void) fprintf(file1, "       Has object/gold 90%% of time.\n");
X	      if (CM_1D2_OBJ & c_ptr->cmove)
X		(void) fprintf(file1, "       Has 1d2 object(s)/gold.\n");
X	      if (CM_2D2_OBJ & c_ptr->cmove)
X		(void) fprintf(file1, "       Has 2d2 object(s)/gold.\n");
X	      if (CM_4D2_OBJ & c_ptr->cmove)
X		(void) fprintf(file1, "       Has 4d2 object(s)/gold.\n");
X	      /*
X	       * Creature casts spells / Breathes Dragon
X	       * breath.
X	       */
X	      if (c_ptr->spells != 0)
X		{
X		  (void) fprintf(file1, "   --Spells/Dragon Breath =\n");
X		  (void) fprintf(file1, "       Casts spells 1 out of %d turns.\n",
X			  (int)(CS_FREQ & c_ptr->spells));
X		  if (CS_TEL_SHORT & c_ptr->spells)
X		    (void) fprintf(file1, "       Can teleport short.\n");
X		  if (CS_TEL_LONG & c_ptr->spells)
X		    (void) fprintf(file1, "       Can teleport long.\n");
X		  if (CS_TEL_TO & c_ptr->spells)
X		    (void) fprintf(file1, "       Teleport player to itself.\n");
X		  if (CS_LGHT_WND & c_ptr->spells)
X		    (void) fprintf(file1, "       Cause light wounds.\n");
X		  if (CS_SER_WND & c_ptr->spells)
X		    (void) fprintf(file1, "       Cause serious wounds.\n");
X		  if (CS_HOLD_PER & c_ptr->spells)
X		    (void) fprintf(file1, "       Hold person.\n");
X		  if (CS_BLIND & c_ptr->spells)
X		    (void) fprintf(file1, "       Cause blindness.\n");
X		  if (CS_CONFUSE & c_ptr->spells)
X		    (void) fprintf(file1, "       Cause confusion.\n");
X		  if (CS_FEAR & c_ptr->spells)
X		    (void) fprintf(file1, "       Cause fear.\n");
X		  if (CS_SUMMON_MON & c_ptr->spells)
X		    (void) fprintf(file1, "       Summon a monster.\n");
X		  if (CS_SUMMON_UND & c_ptr->spells)
X		    (void) fprintf(file1, "       Summon an undead.\n");
X		  if (CS_SLOW_PER & c_ptr->spells)
X		    (void) fprintf(file1, "       Slow person.\n");
X		  if (CS_DRAIN_MANA & c_ptr->spells)
X		    (void) fprintf(file1, "       Drains mana for healing.\n");
X		  if (0x00020000L & c_ptr->spells)
X		    (void) fprintf(file1, "       **Unknown spell value**\n");
X		  if (0x00040000L & c_ptr->spells)
X		    (void) fprintf(file1, "       **Unknown spell value**\n");
X		  if (CS_BR_LIGHT & c_ptr->spells)
X		    (void) fprintf(file1, "       Breathes Lightning Dragon Breath.\n");
X		  if (CS_BR_GAS & c_ptr->spells)
X		    (void) fprintf(file1, "       Breathes Gas Dragon Breath.\n");
X		  if (CS_BR_ACID & c_ptr->spells)
X		    (void) fprintf(file1, "       Breathes Acid Dragon Breath.\n");
X		  if (CS_BR_FROST & c_ptr->spells)
X		    (void) fprintf(file1, "       Breathes Frost Dragon Breath.\n");
X		  if (CS_BR_FIRE & c_ptr->spells)
X		    (void) fprintf(file1, "       Breathes Fire Dragon Breath.\n");
X		}
X	      /* Movement for creature				       */
X	      (void) fprintf(file1, "   --Movement =\n");
X	      if ((CM_ALL_MV_FLAGS & c_ptr->cmove) == 0)
X		(void) fprintf(file1, "       Do not move.\n");
X	      if (CM_ATTACK_ONLY & c_ptr->cmove)
X		(void) fprintf(file1, "       Move only to attack.\n");
X	      if (CM_MOVE_NORMAL & c_ptr->cmove)
X		(void) fprintf(file1, "       Move and attack normally.\n");
X	      if (CM_20_RANDOM & c_ptr->cmove)
X		(void) fprintf(file1, "       20%% random movement.\n");
X	      if (CM_40_RANDOM & c_ptr->cmove)
X		(void) fprintf(file1, "       40%% random movement.\n");
X	      if (CM_75_RANDOM & c_ptr->cmove)
X		(void) fprintf(file1, "       75%% random movement.\n");
X	      if (CM_OPEN_DOOR & c_ptr->cmove)
X		(void) fprintf(file1, "       Can open doors.\n");
X	      if (CM_PHASE & c_ptr->cmove)
X		(void) fprintf(file1, "       Can phase through walls.\n");
X
X	      (void) fprintf(file1, "   --Creature attacks =\n");
X	      attstr = c_ptr->damage;
X	      count = 0;
X	      while (*attstr != 0 && count < 4)
X		{
X		  attype = monster_attacks[*attstr].attack_type;
X		  adesc = monster_attacks[*attstr].attack_desc;
X		  adice = monster_attacks[*attstr].attack_dice;
X		  asides = monster_attacks[*attstr].attack_sides;
X		  attstr++;
X		  count++;
X		  out_val[0] = '\0';
X		  switch (adesc)
X		    {
X		    case 0:
X		      (void) strcpy(out_val, "       No hits for ");
X		      break;
X		    case 1:
X		      (void) strcpy(out_val, "       Hits for ");
X		      break;
X		    case 2:
X		      (void) strcpy(out_val, "       Bites for ");
X		      break;
X		    case 3:
X		      (void) strcpy(out_val, "       Claws for ");
X		      break;
X		    case 4:
X		      (void) strcpy(out_val, "       Stings for ");
X		      break;
X		    case 5:
X		      (void) strcpy(out_val, "       Touches for ");
X		      break;
X		    case 6:
X		      (void) strcpy(out_val, "       Kicks for ");
X		      break;
X		    case 7:
X		      (void) strcpy(out_val, "       Gazes for ");
X		      break;
X		    case 8:
X		      (void) strcpy(out_val, "       Breathes for ");
X		      break;
X		    case 9:
X		      (void) strcpy(out_val, "       Spits for ");
X		      break;
X		    case 10:
X		      (void) strcpy(out_val, "       Wails for ");
X		      break;
X		    case 11:
X		      (void) strcpy(out_val, "       Embraces for ");
X		      break;
X		    case 12:
X		      (void) strcpy(out_val, "       Crawls on you for ");
X		      break;
X		    case 13:
X		      (void) strcpy(out_val, "       Shoots spores for ");
X		      break;
X		    case 14:
X		      (void) strcpy(out_val, "       Begs for money for ");
X		      break;
X		    case 15:
X		      (void) strcpy(out_val, "       Slimes you for ");
X		      break;
X		    case 16:
X		      (void) strcpy(out_val, "       Crushes you for ");
X		      break;
X		    case 17:
X		      (void) strcpy(out_val, "       Tramples you for ");
X		      break;
X		    case 18:
X		      (void) strcpy(out_val, "       Drools on you for ");
X		      break;
X		    case 19:
X		      (void) strcpy(out_val, "       Insults you for ");
X		      break;
X		    case 99:
X		      (void) strcpy(out_val, "       Is repelled.");
X		      break;
X		    default:
X		      (void) strcpy(out_val, "     **Unknown value** ");
X		      break;
X		    }
X		  switch (attype)
X		    {
X		    case 0:
X		      (void) strcat(out_val, "no damage.");
X		      break;
X		    case 1:
X		      (void) strcat(out_val, "normal damage.");
X		      break;
X		    case 2:
X		      (void) strcat(out_val, "lowering strength.");
X		      break;
X		    case 3:
X		      (void) strcat(out_val, "confusion.");
X		      break;
X		    case 4:
X		      (void) strcat(out_val, "fear.");
X		      break;
X		    case 5:
X		      (void) strcat(out_val, "fire damage.");
X		      break;
X		    case 6:
X		      (void) strcat(out_val, "acid damage.");
X		      break;
X		    case 7:
X		      (void) strcat(out_val, "cold damage.");
X		      break;
X		    case 8:
X		      (void) strcat(out_val, "lightning damage.");
X		      break;
X		    case 9:
X		      (void) strcat(out_val, "corrosion damage.");
X		      break;
X		    case 10:
X		      (void) strcat(out_val, "blindness.");
X		      break;
X		    case 11:
X		      (void) strcat(out_val, "paralyzation.");
X		      break;
X		    case 12:
X		      (void) strcat(out_val, "stealing money.");
X		      break;
X		    case 13:
X		      (void) strcat(out_val, "stealing object.");
X		      break;
X		    case 14:
X		      (void) strcat(out_val, "poison damage.");
X		      break;
X		    case 15:
X		      (void) strcat(out_val, "lose dexterity.");
X		      break;
X		    case 16:
X		      (void) strcat(out_val, "lose constitution.");
X		      break;
X		    case 17:
X		      (void) strcat(out_val, "lose intelligence.");
X		      break;
X		    case 18:
X		      (void) strcat(out_val, "lose wisdom.");
X		      break;
X		    case 19:
X		      (void) strcat(out_val, "lose experience.");
X		      break;
X		    case 20:
X		      (void) strcat(out_val, "aggravates monsters.");
X		      break;
X		    case 21:
X		      (void) strcat(out_val, "disenchants objects.");
X		      break;
X		    case 22:
X		      (void) strcat(out_val, "eating food.");
X		      break;
X		    case 23:
X		      (void) strcat(out_val, "eating light source.");
X		      break;
X		    case 24:
X		      (void) strcat(out_val, "absorbing charges.");
X		      break;
X		    case 99:
X		      (void) strcat(out_val, "blank message.");
X		      break;
X		    default:
X		      (void) strcat(out_val, "**Unknown value**");
X		      break;
X		    }
X		  (void) fprintf(file1, "%s (%dd%d)\n", out_val, adice,asides);
X		}
X	      for (j = 0; j < 2; j++)
X		(void) fprintf(file1, "\n");
X	    }
X	  /* End writing to file				   */
X	  (void) fclose(file1);
X	  prt("Completed.", 0, 0);
X	}
X    }
X}
END_OF_FILE
if test 11673 -ne `wc -c <'util/showmon.c'`; then
    echo shar: \"'util/showmon.c'\" unpacked with wrong size!
fi
# end of 'util/showmon.c'
fi
echo shar: End of archive 29 \(of 39\).
cp /dev/null ark29isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
