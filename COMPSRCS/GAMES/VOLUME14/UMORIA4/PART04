Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i036:  umoria4 - single player dungeon simulation (ver. 5.5), Part04/39
Message-ID: <3394@master.CNA.TEK.COM>
Date: 20 Aug 92 18:02:29 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2285
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 36
Archive-name: umoria4/Part04
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 39)."
# Contents:  atari_st/curscomp/curses.txt source/dungeon.c
# Wrapped by billr@saab on Thu Aug 20 09:11:26 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'atari_st/curscomp/curses.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'atari_st/curscomp/curses.txt'\"
else
echo shar: Extracting \"'atari_st/curscomp/curses.txt'\" \(2869 characters\)
sed "s/^X//" >'atari_st/curscomp/curses.txt' <<'END_OF_FILE'
XCURSES.TXT - some documentation for ST-Curses.
X
XThis text should come together with three other files :
X  CURSES.C  - C code for the ST-Curses package
X  CURSES.H  - include file for programs using curses
X  CURSINC.H - include file for CURSES.C
X  
XCurses is a computer and terminal-independent screen package for character-
Xbased programs. Curses originated in the UNIX world and many programs written
Xfor UNIX require a version of curses. This is ST-curses, a port of Curses for
Xthe Atari ST in monochrome or medium resolution. This text has been written by
XHildo Biersma (address below), but I did not originally write the ST-Curses
Xpackage. However, I did an almost complete rewrite for reasons of clarity and
Xspeed; I am therefore including some documentation with it, too.
X
XThis version was written for use with Turbo-C 2.0; some changes may be needed
Xif you intend to use it with Mark Williams C, GNU C or other compiler.
XThroughout all of the code in CURSES.C I have included a number of comments that
Xshould make the code understandable and therefore (I hope) maintainable.
XYou should take special notice of the explanation of the *WINDOW data structure
Xthat appears as a header in CURSES.C.
X
XST-Curses was originally written by :
X  Rene van't Veen
X  Debussystraat 27
X  1817 GL Alkmaar
X  The Netherlands
Xwhom I do not personally know. Thanks, Rene.
X
XRene made ST-Curses available as a shareware program. That is, you can use it
Xfor own programs as long as you do not remove the copyright. For commercial use
Xyou are supposed to make a donation of US $5 or equivalent. Please read the
Xheader in CURSES.C for more details. Also note that the copyright remains with
XRene, even though the code has been extensively modified by me.
X
XSome bugs may remain in the code; especially the wgetstr routine looks suspect.
XI used ST-Curses in a version of the game Moria and can assure you that all
Xroutines used by Moria work fine. Modifications to the code have mostly been to
Xuse pointers and more pointers instead of array dereferencing. The net result
Xhas been that the compiled code is some 200 bytes smaller and, depending on the 
Xroutine, 2 through 10 times faster. I also ensured that the routine type (void,
Xinteger etc) was more in line with the original ('real') UNIX curses. For an
Xidea of what I've done, I included the old version of the routine wrefresh()
Xalong with the new code (commented out in CURSES.C).
X
XPlease note that I do not take any responsibility for this code. It may or may
Xnot contain any bugs; it may or may not have been optimized completely. In my
Xown opinion, it works pretty good and quite fast enough for my purposes.
XShould you have any problems with the code or discover any bugs, please contact
Xme - I'll do what I can to help. 
X
XGood luck and greetings from :
X  Hildo Biersma
X  Tollensstraat 138
X  2513 GE Den Haag
X  Holland (Europe).
END_OF_FILE
if test 2869 -ne `wc -c <'atari_st/curscomp/curses.txt'`; then
    echo shar: \"'atari_st/curscomp/curses.txt'\" unpacked with wrong size!
fi
# end of 'atari_st/curscomp/curses.txt'
fi
if test -f 'source/dungeon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/dungeon.c'\"
else
echo shar: Extracting \"'source/dungeon.c'\" \(49774 characters\)
sed "s/^X//" >'source/dungeon.c' <<'END_OF_FILE'
X/* source/dungeon.c: the main command interpreter, updating player status
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#ifdef __TURBOC__
X#include	<conio.h>
X#include	<stdio.h>
X#include	<stdlib.h>
X#endif /* __TURBOC__ */
X 
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#ifdef USG
X#ifndef ATARIST_MWC
X#include <string.h>
X#endif
X#else
X#include <strings.h>
X#endif
X
X#if defined(LINT_ARGS)
Xstatic char original_commands(char);
Xstatic void do_command(char);
Xstatic int valid_countcommand(char);
Xstatic void regenhp(int);
Xstatic void regenmana(int);
Xstatic int enchanted(inven_type *);
Xstatic void examine_book(void);
Xstatic void go_up(void);
Xstatic void go_down(void);
Xstatic void jamdoor(void);
Xstatic void refill_lamp(void);
X#else
Xstatic char original_commands();
Xstatic void do_command();
Xstatic int valid_countcommand();
Xstatic void regenhp();
Xstatic void regenmana();
Xstatic int enchanted();
Xstatic void examine_book();
Xstatic void go_up();
Xstatic void go_down();
Xstatic void jamdoor();
Xstatic void refill_lamp();
X#endif
X
X#ifdef ATARIST_TC
X/* Include this to get prototypes for standard library functions.  */
X#include <stdlib.h>
X#endif
X
X/* Moria game module					-RAK-	*/
X/* The code in this section has gone through many revisions, and */
X/* some of it could stand some more hard work.	-RAK-	       */
X
X/* It has had a bit more hard work.			-CJS- */
X
Xvoid dungeon()
X{
X  int find_count, i;
X  int regen_amount;	    /* Regenerate hp and mana*/
X  char command;		/* Last command		 */
X  register struct misc *p_ptr;
X  register inven_type *i_ptr;
X  register struct flags *f_ptr;
X#ifdef ATARIST_WMC
X  int32u holder;
X#endif
X
X  /* Main procedure for dungeon.			-RAK-	*/
X  /* Note: There is a lot of preliminary magic going on here at first*/
X
X  /* init pointers. */
X  f_ptr = &py.flags;
X  p_ptr = &py.misc;
X
X  /* Check light status for setup	   */
X  i_ptr = &inventory[INVEN_LIGHT];
X  if (i_ptr->p1 > 0)
X    player_light = TRUE;
X  else
X    player_light = FALSE;
X  /* Check for a maximum level		   */
X  if (dun_level > p_ptr->max_dlv)
X    p_ptr->max_dlv = dun_level;
X
X  /* Reset flags and initialize variables  */
X  command_count = 0;
X  find_count = 0;
X  new_level_flag    = FALSE;
X  find_flag	= FALSE;
X  teleport_flag = FALSE;
X  mon_tot_mult	= 0;
X  cave[char_row][char_col].cptr = 1;
X  /* Ensure we display the panel. Used to do this with a global var. -CJS- */
X  panel_row = panel_col = -1;
X  /* Light up the area around character	   */
X  check_view ();
X  /* must do this after panel_row/col set to -1, because search_off() will
X     call check_view(), and so the panel_* variables must be valid before
X     search_off() is called */
X  if (py.flags.status & PY_SEARCH)
X    search_off();
X  /* Light,  but do not move critters	    */
X  creatures(FALSE);
X  /* Print the depth			   */
X  prt_depth();
X#if 0
X  /* This can't be right.  */
X#ifdef ATARIST_MWC
X  prt_map();
X#endif
X#endif
X
X  /* Loop until dead,  or new level		*/
X  do
X    {
X      /* Increment turn counter			*/
X      turn++;
X#ifndef MAC
X      /* The Mac ignores the game hours file		*/
X      /* Check for game hours			       */
X      if (((turn % 250) == 1) && !check_time())
X	if (closing_flag > 4)
X	  {
X	    msg_print("The gates to Moria are now closed.");
X	    (void) strcpy (died_from, "(closing gate: saved)");
X	    if (!save_char())
X	      {
X		(void) strcpy (died_from, "a slammed gate");
X		death = TRUE;
X	      }
X	    exit_game();
X	  }
X	else
X	  {
X	    disturb (0, 0);
X	    closing_flag++;
X	    msg_print("The gates to Moria are closing.");
X	    msg_print("Please finish up or save your game.");
X	  }
X#endif
X
X      /* turn over the store contents every, say, 1000 turns */
X      if ((dun_level != 0) && ((turn % 1000) == 0))
X	store_maint();
X
X      /* Check for creature generation		*/
X      if (randint(MAX_MALLOC_CHANCE) == 1)
X	alloc_monster(1, MAX_SIGHT, FALSE);
X      /* Check light status			       */
X      i_ptr = &inventory[INVEN_LIGHT];
X      if (player_light)
X	if (i_ptr->p1 > 0)
X	  {
X	    i_ptr->p1--;
X	    if (i_ptr->p1 == 0)
X	      {
X		player_light = FALSE;
X		msg_print("Your light has gone out!");
X		disturb (0, 1);
X		/* unlight creatures */
X		creatures(FALSE);
X	      }
X	    else if ((i_ptr->p1 < 40) && (randint(5) == 1) &&
X		     (py.flags.blind < 1))
X	      {
X		disturb (0, 0);
X		msg_print("Your light is growing faint.");
X	      }
X	  }
X	else
X	  {
X	    player_light = FALSE;
X	    disturb (0, 1);
X	    /* unlight creatures */
X	    creatures(FALSE);
X	  }
X      else if (i_ptr->p1 > 0)
X	{
X	  i_ptr->p1--;
X	  player_light = TRUE;
X	  disturb (0, 1);
X	  /* light creatures */
X	  creatures(FALSE);
X	}
X
X      /* Update counters and messages			*/
X      /* Check food status	       */
X      regen_amount = PLAYER_REGEN_NORMAL;
X      if (f_ptr->food < PLAYER_FOOD_ALERT)
X	{
X	  if (f_ptr->food < PLAYER_FOOD_WEAK)
X	    {
X	      if (f_ptr->food < 0)
X		regen_amount = 0;
X	      else if (f_ptr->food < PLAYER_FOOD_FAINT)
X		regen_amount = PLAYER_REGEN_FAINT;
X	      else if (f_ptr->food < PLAYER_FOOD_WEAK)
X		regen_amount = PLAYER_REGEN_WEAK;
X	      if ((PY_WEAK & f_ptr->status) == 0)
X		{
X		  f_ptr->status |= PY_WEAK;
X		  msg_print("You are getting weak from hunger.");
X		  disturb (0, 0);
X		  prt_hunger();
X		}
X	      if ((f_ptr->food < PLAYER_FOOD_FAINT) && (randint(8) == 1))
X		{
X		  f_ptr->paralysis += randint(5);
X		  msg_print("You faint from the lack of food.");
X		  disturb (1, 0);
X		}
X	    }
X	  else if ((PY_HUNGRY & f_ptr->status) == 0)
X	    {
X	      f_ptr->status |= PY_HUNGRY;
X	      msg_print("You are getting hungry.");
X	      disturb (0, 0);
X	      prt_hunger();
X	    }
X	}
X      /* Food consumption	*/
X      /* Note: Speeded up characters really burn up the food!  */
X      if (f_ptr->speed < 0)
X	f_ptr->food -=	f_ptr->speed*f_ptr->speed;
X      f_ptr->food -= f_ptr->food_digested;
X      if (f_ptr->food < 0)
X	{
X	  take_hit (-f_ptr->food/16, "starvation");   /* -CJS- */
X	  disturb(1, 0);
X	}
X      /* Regenerate	       */
X      if (f_ptr->regenerate)  regen_amount = regen_amount * 3 / 2;
X      if ((py.flags.status & PY_SEARCH) || f_ptr->rest != 0)
X	regen_amount = regen_amount * 2;
X      if ((py.flags.poisoned < 1) && (p_ptr->chp < p_ptr->mhp))
X	regenhp(regen_amount);
X      if (p_ptr->cmana < p_ptr->mana)
X	regenmana(regen_amount);
X      /* Blindness	       */
X      if (f_ptr->blind > 0)
X	{
X	  if ((PY_BLIND & f_ptr->status) == 0)
X	    {
X	      f_ptr->status |= PY_BLIND;
X	      prt_map();
X	      prt_blind();
X	      disturb (0, 1);
X	      /* unlight creatures */
X	      creatures (FALSE);
X	    }
X	  f_ptr->blind--;
X	  if (f_ptr->blind == 0)
X	    {
X#ifdef ATARIST_MWC
X	      f_ptr->status &= ~(holder = PY_BLIND);
X#else
X	      f_ptr->status &= ~PY_BLIND;
X#endif
X	      prt_blind();
X	      prt_map();
X	      /* light creatures */
X	      disturb (0, 1);
X	      creatures(FALSE);
X	      msg_print("The veil of darkness lifts.");
X	    }
X	}
X      /* Confusion	       */
X      if (f_ptr->confused > 0)
X	{
X	  if ((PY_CONFUSED & f_ptr->status) == 0)
X	    {
X	      f_ptr->status |= PY_CONFUSED;
X	      prt_confused();
X	    }
X	  f_ptr->confused--;
X	  if (f_ptr->confused == 0)
X	    {
X#ifdef ATARIST_MWC
X	      f_ptr->status &= ~(holder = PY_CONFUSED);
X#else
X	      f_ptr->status &= ~PY_CONFUSED;
X#endif
X	      prt_confused();
X	      msg_print("You feel less confused now.");
X	      if (py.flags.rest != 0)
X		rest_off ();
X	    }
X	}
X      /* Afraid		       */
X      if (f_ptr->afraid > 0)
X	{
X	  if ((PY_FEAR & f_ptr->status) == 0)
X	    {
X	      if ((f_ptr->shero+f_ptr->hero) > 0)
X		f_ptr->afraid = 0;
X	      else
X		{
X		  f_ptr->status |= PY_FEAR;
X		  prt_afraid();
X		}
X	    }
X	  else if ((f_ptr->shero+f_ptr->hero) > 0)
X	    f_ptr->afraid = 1;
X	  f_ptr->afraid--;
X	  if (f_ptr->afraid == 0)
X	    {
X#ifdef ATARIST_MWC
X	      f_ptr->status &= ~(holder = PY_FEAR);
X#else
X	      f_ptr->status &= ~PY_FEAR;
X#endif
X	      prt_afraid();
X	      msg_print("You feel bolder now.");
X	      disturb (0, 0);
X	    }
X	}
X      /* Poisoned	       */
X      if (f_ptr->poisoned > 0)
X	{
X	  if ((PY_POISONED & f_ptr->status) == 0)
X	    {
X	      f_ptr->status |= PY_POISONED;
X	      prt_poisoned();
X	    }
X	  f_ptr->poisoned--;
X	  if (f_ptr->poisoned == 0)
X	    {
X#ifdef ATARIST_MWC
X	      f_ptr->status &= ~(holder = PY_POISONED);
X#else
X	      f_ptr->status &= ~PY_POISONED;
X#endif
X	      prt_poisoned();
X	      msg_print("You feel better.");
X	      disturb (0, 0);
X	    }
X	  else
X	    {
X	      switch(con_adj())
X		{
X		case -4:  i = 4;  break;
X		case -3:
X		case -2:  i = 3;  break;
X		case -1:  i = 2;  break;
X		case 0:	  i = 1;  break;
X		case 1: case 2: case 3:
X		  i = ((turn % 2) == 0);
X		  break;
X		case 4: case 5:
X		  i = ((turn % 3) == 0);
X		  break;
X		case 6:
X		  i = ((turn % 4) == 0);
X		  break;
X		}
X	      take_hit (i, "poison");
X	      disturb (1, 0);
X	    }
X	}
X      /* Fast		       */
X      if (f_ptr->fast > 0)
X	{
X	  if ((PY_FAST & f_ptr->status) == 0)
X	    {
X	      f_ptr->status |= PY_FAST;
X	      change_speed(-1);
X	      msg_print("You feel yourself moving faster.");
X	      disturb (0, 0);
X	    }
X	  f_ptr->fast--;
X	  if (f_ptr->fast == 0)
X	    {
X#ifdef ATARIST_MWC
X	      f_ptr->status &= ~(holder = PY_FAST);
X#else
X	      f_ptr->status &= ~PY_FAST;
X#endif
X	      change_speed(1);
X	      msg_print("You feel yourself slow down.");
X	      disturb (0, 0);
X	    }
X	}
X      /* Slow		       */
X      if (f_ptr->slow > 0)
X	{
X	  if ((PY_SLOW & f_ptr->status) == 0)
X	    {
X	      f_ptr->status |= PY_SLOW;
X	      change_speed(1);
X	      msg_print("You feel yourself moving slower.");
X	      disturb (0, 0);
X	    }
X	  f_ptr->slow--;
X	  if (f_ptr->slow == 0)
X	    {
X#ifdef ATARIST_MWC
X	      f_ptr->status &= ~(holder = PY_SLOW);
X#else
X	      f_ptr->status &= ~PY_SLOW;
X#endif
X	      change_speed(-1);
X	      msg_print("You feel yourself speed up.");
X	      disturb (0, 0);
X	    }
X	}
X      /* Resting is over?      */
X      if (f_ptr->rest > 0)
X	{
X	  f_ptr->rest--;
X	  if (f_ptr->rest == 0)		      /* Resting over	       */
X	    rest_off();
X	}
X      else if (f_ptr->rest < 0)
X	{
X	  /* Rest until reach max mana and max hit points.  */
X	  f_ptr->rest++;
X	  if ((p_ptr->chp == p_ptr->mhp && p_ptr->cmana == p_ptr->mana)
X	      || f_ptr->rest == 0)
X	    rest_off();
X	}
X
X      /* Check for interrupts to find or rest. */
X#ifdef MAC
X      /* On Mac, checking for input is expensive, since it involves handling
X	 events, so we only check in multiples of 16 turns. */
X      if (!(turn & 0xF) && ((command_count > 0) || find_flag
X			     || (f_ptr->rest != 0)))
X	if (macgetkey(CNIL, TRUE))
X	  disturb(0, 0);
X#else
X      if ((command_count > 0 || find_flag || f_ptr->rest != 0)
X#if defined(MSDOS) || defined(VMS)
X	  && kbhit()
X#else
X	  && (check_input (find_flag ? 0 : 10000))
X#endif
X	  )
X	{
X#ifdef MSDOS
X	  (void) msdos_getch();
X#endif
X#ifdef VMS
X	  /* Get and ignore the key used to interrupt resting/running.  */
X	  (void) vms_getch ();
X#endif
X	  disturb (0, 0);
X	}
X#endif
X
X      /* Hallucinating?	 (Random characters appear!)*/
X      if (f_ptr->image > 0)
X	{
X	  end_find ();
X	  f_ptr->image--;
X	  if (f_ptr->image == 0)
X	    prt_map ();	 /* Used to draw entire screen! -CJS- */
X	}
X      /* Paralysis	       */
X      if (f_ptr->paralysis > 0)
X	{
X	  /* when paralysis true, you can not see any movement that occurs */
X	  f_ptr->paralysis--;
X	  disturb (1, 0);
X	}
X      /* Protection from evil counter*/
X      if (f_ptr->protevil > 0)
X	{
X	  f_ptr->protevil--;
X	  if (f_ptr->protevil == 0)
X	    msg_print ("You no longer feel safe from evil.");
X	}
X      /* Invulnerability	*/
X      if (f_ptr->invuln > 0)
X	{
X	  if ((PY_INVULN & f_ptr->status) == 0)
X	    {
X	      f_ptr->status |= PY_INVULN;
X	      disturb (0, 0);
X	      py.misc.pac += 100;
X	      py.misc.dis_ac += 100;
X	      prt_pac();
X	      msg_print("Your skin turns into steel!");
X	    }
X	  f_ptr->invuln--;
X	  if (f_ptr->invuln == 0)
X	    {
X#ifdef ATARIST_MWC
X	      f_ptr->status &= ~(holder = PY_INVULN);
X#else
X	      f_ptr->status &= ~PY_INVULN;
X#endif
X	      disturb (0, 0);
X	      py.misc.pac -= 100;
X	      py.misc.dis_ac -= 100;
X	      prt_pac();
X	      msg_print("Your skin returns to normal.");
X	    }
X	}
X      /* Heroism       */
X      if (f_ptr->hero > 0)
X	{
X	  if ((PY_HERO & f_ptr->status) == 0)
X	    {
X	      f_ptr->status |= PY_HERO;
X	      disturb (0, 0);
X	      p_ptr->mhp += 10;
X	      p_ptr->chp += 10;
X	      p_ptr->bth += 12;
X	      p_ptr->bthb+= 12;
X	      msg_print("You feel like a HERO!");
X	      prt_mhp();
X	      prt_chp();
X	    }
X	  f_ptr->hero--;
X	  if (f_ptr->hero == 0)
X	    {
X#ifdef ATARIST_MWC
X	      f_ptr->status &= ~(holder = PY_HERO);
X#else
X	      f_ptr->status &= ~PY_HERO;
X#endif
X	      disturb (0, 0);
X	      p_ptr->mhp -= 10;
X	      if (p_ptr->chp > p_ptr->mhp)
X		{
X		  p_ptr->chp = p_ptr->mhp;
X		  p_ptr->chp_frac = 0;
X		  prt_chp();
X		}
X	      p_ptr->bth -= 12;
X	      p_ptr->bthb-= 12;
X	      msg_print("The heroism wears off.");
X	      prt_mhp();
X	    }
X	}
X      /* Super Heroism */
X      if (f_ptr->shero > 0)
X	{
X	  if ((PY_SHERO & f_ptr->status) == 0)
X	    {
X	      f_ptr->status |= PY_SHERO;
X	      disturb (0, 0);
X	      p_ptr->mhp += 20;
X	      p_ptr->chp += 20;
X	      p_ptr->bth += 24;
X	      p_ptr->bthb+= 24;
X	      msg_print("You feel like a SUPER HERO!");
X	      prt_mhp();
X	      prt_chp();
X	    }
X	  f_ptr->shero--;
X	  if (f_ptr->shero == 0)
X	    {
X#ifdef ATARIST_MWC
X	      f_ptr->status &= ~(holder = PY_SHERO);
X#else
X	      f_ptr->status &= ~PY_SHERO;
X#endif
X	      disturb (0, 0);
X	      p_ptr->mhp -= 20;
X	      if (p_ptr->chp > p_ptr->mhp)
X		{
X		  p_ptr->chp = p_ptr->mhp;
X		  p_ptr->chp_frac = 0;
X		  prt_chp();
X		}
X	      p_ptr->bth -= 24;
X	      p_ptr->bthb-= 24;
X	      msg_print("The super heroism wears off.");
X	      prt_mhp();
X	    }
X	}
X      /* Blessed       */
X      if (f_ptr->blessed > 0)
X	{
X	  if ((PY_BLESSED & f_ptr->status) == 0)
X	    {
X	      f_ptr->status |= PY_BLESSED;
X	      disturb (0, 0);
X	      p_ptr->bth += 5;
X	      p_ptr->bthb+= 5;
X	      p_ptr->pac += 2;
X	      p_ptr->dis_ac+= 2;
X	      msg_print("You feel righteous!");
X	      prt_pac();
X	    }
X	  f_ptr->blessed--;
X	  if (f_ptr->blessed == 0)
X	    {
X#ifdef ATARIST_MWC
X	      f_ptr->status &= ~(holder = PY_BLESSED);
X#else
X	      f_ptr->status &= ~PY_BLESSED;
X#endif
X	      disturb (0, 0);
X	      p_ptr->bth -= 5;
X	      p_ptr->bthb-= 5;
X	      p_ptr->pac -= 2;
X	      p_ptr->dis_ac -= 2;
X	      msg_print("The prayer has expired.");
X	      prt_pac();
X	    }
X	}
X      /* Resist Heat   */
X      if (f_ptr->resist_heat > 0)
X	{
X	  f_ptr->resist_heat--;
X	  if (f_ptr->resist_heat == 0)
X	    msg_print ("You no longer feel safe from flame.");
X	}
X      /* Resist Cold   */
X      if (f_ptr->resist_cold > 0)
X	{
X	  f_ptr->resist_cold--;
X	  if (f_ptr->resist_cold == 0)
X	    msg_print ("You no longer feel safe from cold.");
X	}
X      /* Detect Invisible      */
X      if (f_ptr->detect_inv > 0)
X	{
X#ifdef ATARIST_MWC
X	  if (((holder = PY_DET_INV) & f_ptr->status) == 0)
X#else
X	  if ((PY_DET_INV & f_ptr->status) == 0)
X#endif
X	    {
X#ifdef ATARIST_MWC
X	      f_ptr->status |= holder;
X#else
X	      f_ptr->status |= PY_DET_INV;
X#endif
X	      f_ptr->see_inv = TRUE;
X	      /* light but don't move creatures */
X	      creatures (FALSE);
X	    }
X	  f_ptr->detect_inv--;
X	  if (f_ptr->detect_inv == 0)
X	    {
X#ifdef ATARIST_MWC
X	      f_ptr->status &= ~holder;
X#else
X	      f_ptr->status &= ~PY_DET_INV;
X#endif
X	      /* may still be able to see_inv if wearing magic item */
X	      calc_bonuses();
X	      /* unlight but don't move creatures */
X	      creatures (FALSE);
X	    }
X	}
X      /* Timed infra-vision    */
X      if (f_ptr->tim_infra > 0)
X	{
X#ifdef ATARIST_MWC
X	  if (((holder = PY_TIM_INFRA) & f_ptr->status) == 0)
X#else
X	  if ((PY_TIM_INFRA & f_ptr->status) == 0)
X#endif
X	    {
X#ifdef ATARIST_MWC
X	      f_ptr->status |= holder;
X#else
X	      f_ptr->status |= PY_TIM_INFRA;
X#endif
X	      f_ptr->see_infra++;
X	      /* light but don't move creatures */
X	      creatures (FALSE);
X	    }
X	  f_ptr->tim_infra--;
X	  if (f_ptr->tim_infra == 0)
X	    {
X#ifdef ATARIST_MWC
X	      f_ptr->status &= ~holder;
X#else
X	      f_ptr->status &= ~PY_TIM_INFRA;
X#endif
X	      f_ptr->see_infra--;
X	      /* unlight but don't move creatures */
X	      creatures (FALSE);
X	    }
X	}
X	/* Word-of-Recall  Note: Word-of-Recall is a delayed action	 */
X      if (f_ptr->word_recall > 0)
X	if (f_ptr->word_recall == 1)
X	  {
X	    new_level_flag = TRUE;
X	    f_ptr->paralysis++;
X	    f_ptr->word_recall = 0;
X	    if (dun_level > 0)
X	      {
X		dun_level = 0;
X		msg_print("You feel yourself yanked upwards!");
X	      }
X	    else if (py.misc.max_dlv != 0)
X	      {
X		dun_level = py.misc.max_dlv;
X		msg_print("You feel yourself yanked downwards!");
X	      }
X	  }
X	else
X	  f_ptr->word_recall--;
X
X      /* Random teleportation  */
X      if ((py.flags.teleport) && (randint(100) == 1))
X	{
X	  disturb (0, 0);
X	  teleport(40);
X	}
X
X      /* See if we are too weak to handle the weapon or pack.  -CJS- */
X#ifdef ATARIST_MWC
X      if (py.flags.status & (holder = PY_STR_WGT))
X#else
X      if (py.flags.status & PY_STR_WGT)
X#endif
X	check_strength();
X      if (py.flags.status & PY_STUDY)
X	prt_study();
X#ifdef ATARIST_MWC
X      if (py.flags.status & (holder = PY_SPEED))
X#else
X      if (py.flags.status & PY_SPEED)
X#endif
X	{
X#ifdef ATARIST_MWC
X	  py.flags.status &= ~holder;
X#else
X	  py.flags.status &= ~PY_SPEED;
X#endif
X	  prt_speed();
X	}
X#ifdef ATARIST_MWC
X      if ((py.flags.status & (holder = PY_PARALYSED))
X	  && (py.flags.paralysis < 1))
X#else
X      if ((py.flags.status & PY_PARALYSED) && (py.flags.paralysis < 1))
X#endif
X	{
X	  prt_state();
X#ifdef ATARIST_MWC
X	  py.flags.status &= ~holder;
X#else
X	  py.flags.status &= ~PY_PARALYSED;
X#endif
X	}
X      else if (py.flags.paralysis > 0)
X	{
X	  prt_state();
X#ifdef ATARIST_MWC
X	  py.flags.status |= (holder = PY_PARALYSED);
X#else
X	  py.flags.status |= PY_PARALYSED;
X#endif
X	}
X      else if (py.flags.rest != 0)
X	prt_state();
X
X#ifdef ATARIST_MWC
X      if ((py.flags.status & (holder = PY_ARMOR)) != 0)
X#else
X      if ((py.flags.status & PY_ARMOR) != 0)
X#endif
X	{
X	  prt_pac();
X#ifdef ATARIST_MWC
X	  py.flags.status &= ~holder;
X#else
X	  py.flags.status &= ~PY_ARMOR;
X#endif
X	}
X#ifdef ATARIST_MWC
X      if ((py.flags.status & (holder = PY_STATS)) != 0)
X#else
X      if ((py.flags.status & PY_STATS) != 0)
X#endif
X	{
X	  for (i = 0; i < 6; i++)
X#ifdef ATARIST_MWC
X	    if (((holder = PY_STR) << i) & py.flags.status)
X#else
X	    if ((PY_STR << i) & py.flags.status)
X#endif
X	      prt_stat(i);
X#ifdef ATARIST_MWC
X	  py.flags.status &= ~(holder = PY_STATS);
X#else
X	  py.flags.status &= ~PY_STATS;
X#endif
X	}
X#ifdef ATARIST_MWC
X      if (py.flags.status & (holder = PY_HP))
X#else
X      if (py.flags.status & PY_HP)
X#endif
X	{
X	  prt_mhp();
X	  prt_chp();
X#ifdef ATARIST_MWC
X	  py.flags.status &= ~holder;
X#else
X	  py.flags.status &= ~PY_HP;
X#endif
X	}
X#ifdef ATARIST_MWC
X      if (py.flags.status & (holder = PY_MANA))
X#else
X      if (py.flags.status & PY_MANA)
X#endif
X	{
X	  prt_cmana();
X#ifdef ATARIST_MWC
X	  py.flags.status &= ~holder;
X#else
X	  py.flags.status &= ~PY_MANA;
X#endif
X	}
X
X      /* Allow for a slim chance of detect enchantment -CJS- */
X      /* for 1st level char, check once every 2160 turns
X	 for 40th level char, check once every 416 turns */
X      if (((turn & 0xF) == 0) && (f_ptr->confused == 0)
X	  && (randint((int)(10 + 750 / (5 + py.misc.lev))) == 1))
X	{
X	  vtype tmp_str;
X
X	  for (i = 0; i < INVEN_ARRAY_SIZE; i++)
X	    {
X	      if (i == inven_ctr)
X		i = 22;
X	      i_ptr = &inventory[i];
X	      /* if in inventory, succeed 1 out of 50 times,
X		 if in equipment list, success 1 out of 10 times */
X	      if ((i_ptr->tval != TV_NOTHING) && enchanted(i_ptr) &&
X		  (randint(i < 22 ? 50 : 10) == 1))
X		{
X		  extern char *describe_use();
X
X		  (void) sprintf(tmp_str,
X				 "There's something about what you are %s...",
X				 describe_use(i));
X		  disturb(0, 0);
X		  msg_print(tmp_str);
X		  add_inscribe(i_ptr, ID_MAGIK);
X		}
X	    }
X	}
X
X      /* Check the state of the monster list, and delete some monsters if
X	 the monster list is nearly full.  This helps to avoid problems in
X	 creature.c when monsters try to multiply.  Compact_monsters() is
X	 much more likely to succeed if called from here, than if called
X	 from within creatures().  */
X      if (MAX_MALLOC - mfptr < 10)
X	(void) compact_monsters ();
X
X      if ((py.flags.paralysis < 1) &&	     /* Accept a command?     */
X	  (py.flags.rest == 0) &&
X	  (!death))
X	/* Accept a command and execute it				 */
X	{
X	  do
X	    {
X#ifdef ATARIST_MWC
X	      if (py.flags.status & (holder = PY_REPEAT))
X#else
X	      if (py.flags.status & PY_REPEAT)
X#endif
X		prt_state ();
X	      default_dir = FALSE;
X	      free_turn_flag = FALSE;
X
X	      if (find_flag)
X		{
X		  find_run();
X		  find_count--;
X		  if (find_count == 0)
X		    end_find();
X		  put_qio();
X		}
X	      else if (doing_inven)
X		inven_command (doing_inven);
X	      else
X		{
X		  /* move the cursor to the players character */
X		  move_cursor_relative (char_row, char_col);
X		  if (command_count > 0)
X		    {
X		      msg_flag = FALSE;
X		      default_dir = TRUE;
X		    }
X		  else
X		    {
X		      msg_flag = FALSE;
X#ifdef MAC
X		      unloadsegments();
X		      enablesavecmd(TRUE);
X		      command = inkeydir();
X		      enablesavecmd(FALSE);
X#else
X		      command = inkey();
X#endif
X		      i = 0;
X		      /* Get a count for a command. */
X		      if ((rogue_like_commands
X			   && command >= '0' && command <= '9')
X			  || (!rogue_like_commands && command == '#'))
X			{
X			  char tmp[8];
X
X			  prt("Repeat count:", 0, 0);
X			  if (command == '#')
X			    command = '0';
X			  i = 0;
X			  while (TRUE)
X			    {
X			      if (command == DELETE || command == CTRL('H'))
X				{
X				  i = i / 10;
X				  (void) sprintf(tmp, "%d", i);
X				  prt (tmp, 0, 14);
X				}
X			      else if (command >= '0' && command <= '9')
X				{
X			          if (i > 99)
X				    bell ();
X				  else
X				    {
X				      i = i * 10 + command - '0';
X				      (void) sprintf (tmp, "%d", i);
X				      prt (tmp, 0, 14);
X				    }
X				}
X			      else
X				break;
X#ifdef MAC
X			      command = inkeydir();
X#else
X			      command = inkey();
X#endif
X			    }
X			  if (i == 0)
X			    {
X			      i = 99;
X			      (void) sprintf (tmp, "%d", i);
X			      prt (tmp, 0, 14);
X			    }
X			  /* a special hack to allow numbers as commands */
X			  if (command == ' ')
X			    {
X			      prt ("Command:", 0, 20);
X#ifdef MAC
X			      command = inkeydir();
X#else
X			      command = inkey();
X#endif
X			    }
X			}
X		      /* Another way of typing control codes -CJS- */
X		      if (command == '^')
X			{
X			  if (command_count > 0)
X			    prt_state();
X			  if (get_com("Control-", &command))
X			    {
X			      if (command >= 'A' && command <= 'Z')
X				command -= 'A' - 1;
X			      else if (command >= 'a' && command <= 'z')
X				command -= 'a' - 1;
X			      else
X				{
X			       msg_print("Type ^ <letter> for a control char");
X				  command = ' ';
X				}
X			    }
X			  else
X			    command = ' ';
X			}
X		      /* move cursor to player char again, in case it moved */
X		      move_cursor_relative (char_row, char_col);
X		      /* Commands are always converted to rogue form. -CJS- */
X		      if (rogue_like_commands == FALSE)
X			command = original_commands (command);
X		      if (i > 0)
X			{
X			  if (!valid_countcommand(command))
X			    {
X			      free_turn_flag = TRUE;
X			      msg_print ("Invalid command with a count.");
X			      command = ' ';
X			    }
X			  else
X			    {
X			      command_count = i;
X			      prt_state ();
X			    }
X			}
X		    }
X		  /* Flash the message line. */
X		  erase_line(MSG_LINE, 0);
X		  move_cursor_relative(char_row, char_col);
X		  put_qio();
X
X		  do_command (command);
X		  /* Find is counted differently, as the command changes. */
X		  if (find_flag)
X		    {
X		      find_count = command_count - 1;
X		      command_count = 0;
X		    }
X		  else if (free_turn_flag)
X		    command_count = 0;
X		  else if (command_count)
X		    command_count--;
X		}
X	      /* End of commands				     */
X	    }
X	  while (free_turn_flag && !new_level_flag && !eof_flag);
X	}
X      else
X	{
X	  /* if paralyzed, resting, or dead, flush output */
X	  /* but first move the cursor onto the player, for aesthetics */
X	  move_cursor_relative (char_row, char_col);
X	  put_qio ();
X	}
X
X      /* Teleport?		       */
X      if (teleport_flag)  teleport(100);
X      /* Move the creatures	       */
X      if (!new_level_flag)  creatures(TRUE);
X      /* Exit when new_level_flag is set   */
X    }
X  while (!new_level_flag && !eof_flag);
X}
X
X
Xstatic char original_commands(com_val)
Xchar com_val;
X{
X  int dir_val;
X
X  switch(com_val)
X    {
X    case CTRL('K'):	/*^K = exit    */
X      com_val = 'Q';
X      break;
X    case CTRL('J'):
X    case CTRL('M'):
X      com_val = '+';
X      break;
X    case CTRL('P'):	/*^P = repeat  */
X    case CTRL('W'):	/*^W = password*/
X    case CTRL('X'):	/*^X = save    */
X    case ' ':
X    case '!':
X    case '$':
X      break;
X    case '.':
X      if (get_dir(CNIL, &dir_val))
X	switch (dir_val)
X	  {
X	  case 1:    com_val = 'B';    break;
X	  case 2:    com_val = 'J';    break;
X	  case 3:    com_val = 'N';    break;
X	  case 4:    com_val = 'H';    break;
X	  case 6:    com_val = 'L';    break;
X	  case 7:    com_val = 'Y';    break;
X	  case 8:    com_val = 'K';    break;
X	  case 9:    com_val = 'U';    break;
X	  default:   com_val = ' ';    break;
X	  }
X      else
X	com_val = ' ';
X      break;
X    case '/':
X    case '<':
X    case '>':
X    case '-':
X    case '=':
X    case '{':
X    case '?':
X    case 'A':
X      break;
X    case '1':
X      com_val = 'b';
X      break;
X    case '2':
X      com_val = 'j';
X      break;
X    case '3':
X      com_val = 'n';
X      break;
X    case '4':
X      com_val = 'h';
X      break;
X    case '5':	/* Rest one turn */
X      com_val = '.';
X      break;
X    case '6':
X      com_val = 'l';
X      break;
X    case '7':
X      com_val = 'y';
X      break;
X    case '8':
X      com_val = 'k';
X      break;
X    case '9':
X      com_val = 'u';
X      break;
X    case 'B':
X      com_val = 'f';
X      break;
X    case 'C':
X    case 'D':
X    case 'E':
X    case 'F':
X    case 'G':
X      break;
X    case 'L':
X      com_val = 'W';
X      break;
X    case 'M':
X      break;
X    case 'R':
X      break;
X    case 'S':
X      com_val = '#';
X      break;
X    case 'T':
X      if (get_dir(CNIL, &dir_val))
X	switch (dir_val)
X	  {
X	  case 1:    com_val = CTRL('B');    break;
X	  case 2:    com_val = CTRL('J');    break;
X	  case 3:    com_val = CTRL('N');    break;
X	  case 4:    com_val = CTRL('H');    break;
X	  case 6:    com_val = CTRL('L');    break;
X	  case 7:    com_val = CTRL('Y');    break;
X	  case 8:    com_val = CTRL('K');    break;
X	  case 9:    com_val = CTRL('U');    break;
X	  default:   com_val = ' ';	     break;
X	  }
X      else
X	com_val = ' ';
X      break;
X    case 'V':
X      break;
X    case 'a':
X      com_val = 'z';
X      break;
X    case 'b':
X      com_val = 'P';
X      break;
X    case 'c':
X    case 'd':
X    case 'e':
X      break;
X    case 'f':
X      com_val = 't';
X      break;
X    case 'h':
X      com_val = '?';
X      break;
X    case 'i':
X      break;
X    case 'j':
X      com_val = 'S';
X      break;
X    case 'l':
X      com_val = 'x';
X      break;
X    case 'm':
X    case 'o':
X    case 'p':
X    case 'q':
X    case 'r':
X    case 's':
X      break;
X    case 't':
X      com_val = 'T';
X      break;
X    case 'u':
X      com_val = 'Z';
X      break;
X    case 'v':
X    case 'w':
X      break;
X    case 'x':
X      com_val = 'X';
X      break;
X
X      /* wizard mode commands follow */
X    case CTRL('A'): /*^A = cure all */
X      break;
X    case CTRL('B'):	/*^B = objects */
X      com_val = CTRL('O');
X      break;
X    case CTRL('D'):	/*^D = up/down */
X      break;
X    case CTRL('H'):	/*^H = wizhelp */
X      com_val = '\\';
X      break;
X    case CTRL('I'):	/*^I = identify*/
X      break;
X    case CTRL('L'):	/*^L = wizlight*/
X      com_val = '*';
X      break;
X    case ':':
X    case CTRL('T'):	/*^T = teleport*/
X    case CTRL('E'):	/*^E = wizchar */
X    case CTRL('F'):	/*^F = genocide*/
X    case CTRL('G'):	/*^G = treasure*/
X    case '@':
X    case '+':
X      break;
X    case CTRL('U'):	/*^U = summon  */
X      com_val = '&';
X      break;
X    default:
X      com_val = '~';  /* Anything illegal. */
X      break;
X    }
X  return com_val;
X}
X
X
Xstatic void do_command(com_val)
Xchar com_val;
X{
X  int dir_val, do_pickup;
X  int y, x, i, j;
X  vtype out_val, tmp_str;
X  register struct flags *f_ptr;
X
X  /* hack for move without pickup.  Map '-' to a movement command. */
X  if (com_val == '-')
X    {
X      do_pickup = FALSE;
X      i = command_count;
X      if (get_dir(CNIL, &dir_val))
X	{
X	  command_count = i;
X	  switch (dir_val)
X	    {
X	    case 1:    com_val = 'b';	 break;
X	    case 2:    com_val = 'j';	 break;
X	    case 3:    com_val = 'n';	 break;
X	    case 4:    com_val = 'h';	 break;
X	    case 6:    com_val = 'l';	 break;
X	    case 7:    com_val = 'y';	 break;
X	    case 8:    com_val = 'k';	 break;
X	    case 9:    com_val = 'u';	 break;
X	    default:   com_val = '~';	 break;
X	    }
X	}
X      else
X	com_val = ' ';
X    }
X  else
X    do_pickup = TRUE;
X
X  switch(com_val)
X    {
X    case 'Q':	/* (Q)uit		(^K)ill */
X      flush();
X      if (get_check("Do you really want to quit?"))
X	{
X	  new_level_flag = TRUE;
X	  death = TRUE;
X	  (void) strcpy(died_from, "Quitting");
X	}
X      free_turn_flag = TRUE;
X      break;
X    case CTRL('P'):	/* (^P)revious message. */
X      if (command_count > 0)
X	{
X	  i = command_count;
X	  if (i > MAX_SAVE_MSG)
X	    i = MAX_SAVE_MSG;
X	  command_count = 0;
X	}
X      else if (last_command != CTRL('P'))
X	i = 1;
X      else
X	i = MAX_SAVE_MSG;
X      j = last_msg;
X      if (i > 1)
X	{
X	  save_screen();
X	  x = i;
X	  while (i > 0)
X	    {
X	      i--;
X	      prt(old_msg[j], i, 0);
X	      if (j == 0)
X		j = MAX_SAVE_MSG-1;
X	      else
X		j--;
X	    }
X	  erase_line (x, 0);
X	  pause_line(x);
X	  restore_screen();
X	}
X      else
X	{
X	  /* Distinguish real and recovered messages with a '>'. -CJS- */
X	  put_buffer(">", 0, 0);
X	  prt(old_msg[j], 0, 1);
X	}
X      free_turn_flag = TRUE;
X      break;
X    case CTRL('W'):	/* (^W)izard mode */
X      if (wizard)
X	{
X	  wizard = FALSE;
X	  msg_print("Wizard mode off.");
X	}
X      else if (enter_wiz_mode())
X	msg_print("Wizard mode on.");
X      prt_winner();
X      free_turn_flag = TRUE;
X      break;
X    case CTRL('X'):	/* e(^X)it and save */
X      if (total_winner)
X	{
X       msg_print("You are a Total Winner,  your character must be retired.");
X	  if (rogue_like_commands)
X	    msg_print("Use 'Q' to when you are ready to quit.");
X	  else
X	    msg_print ("Use <Control>-K when you are ready to quit.");
X	}
X      else
X	{
X	  (void) strcpy (died_from, "(saved)");
X	  msg_print ("Saving game...");
X#ifdef MAC
X	  if (save_char (TRUE))
X	    exit_game();
X#else
X	  if (save_char ())
X	    exit_game();
X#endif
X	  (void) strcpy (died_from, "(alive and well)");
X	}
X      free_turn_flag = TRUE;
X      break;
X    case '=':		/* (=) set options */
X      save_screen();
X      set_options();
X      restore_screen();
X      free_turn_flag = TRUE;
X      break;
X    case '{':		/* ({) inscribe an object    */
X      scribe_object ();
X      free_turn_flag = TRUE;
X      break;
X    case '!':		/* (!) escape to the shell */
X    case '$':
X#ifdef SECURE
X      msg_print("Sorry, inferior shells are not allowed from Moria.");
X#else
X      shell_out();
X#endif
X      free_turn_flag = TRUE;
X      break;
X    case ESCAPE:	/* (ESC)   do nothing. */
X    case ' ':		/* (space) do nothing. */
X      free_turn_flag = TRUE;
X      break;
X    case 'b':		/* (b) down, left	(1) */
X      move_char(1, do_pickup);
X      break;
X    case 'j':		/* (j) down		(2) */
X      move_char(2, do_pickup);
X      break;
X    case 'n':		/* (n) down, right	(3) */
X      move_char(3, do_pickup);
X      break;
X    case 'h':		/* (h) left		(4) */
X      move_char(4, do_pickup);
X      break;
X    case 'l':		/* (l) right		(6) */
X      move_char(6, do_pickup);
X      break;
X    case 'y':		/* (y) up, left		(7) */
X      move_char(7, do_pickup);
X      break;
X    case 'k':		/* (k) up		(8) */
X      move_char(8, do_pickup);
X      break;
X    case 'u':		/* (u) up, right	(9) */
X      move_char(9, do_pickup);
X      break;
X    case 'B':		/* (B) run down, left	(. 1) */
X      find_init(1);
X      break;
X    case 'J':		/* (J) run down		(. 2) */
X      find_init(2);
X      break;
X    case 'N':		/* (N) run down, right	(. 3) */
X      find_init(3);
X      break;
X    case 'H':		/* (H) run left		(. 4) */
X      find_init(4);
X      break;
X    case 'L':		/* (L) run right	(. 6) */
X      find_init(6);
X      break;
X    case 'Y':		/* (Y) run up, left	(. 7) */
X      find_init(7);
X      break;
X    case 'K':		/* (K) run up		(. 8) */
X      find_init(8);
X      break;
X    case 'U':		/* (U) run up, right	(. 9) */
X      find_init(9);
X      break;
X    case '/':		/* (/) identify a symbol */
X      ident_char();
X      free_turn_flag = TRUE;
X      break;
X    case '.':		/* (.) stay in one place (5) */
X      move_char (5, do_pickup);
X      if (command_count > 1)
X	{
X	  command_count--;
X	  rest();
X	}
X      break;
X    case '<':		/* (<) go down a staircase */
X      go_up();
X      break;
X    case '>':		/* (>) go up a staircase */
X      go_down();
X      break;
X    case '?':		/* (?) help with commands */
X      if (rogue_like_commands)
X	helpfile(MORIA_HELP);
X      else
X	helpfile(MORIA_ORIG_HELP);
X      free_turn_flag = TRUE;
X      break;
X    case 'f':		/* (f)orce		(B)ash */
X      bash();
X      break;
X    case 'C':		/* (C)haracter description */
X      save_screen();
X      change_name();
X      restore_screen();
X      free_turn_flag = TRUE;
X      break;
X    case 'D':		/* (D)isarm trap */
X      disarm_trap();
X      break;
X    case 'E':		/* (E)at food */
X      eat();
X      break;
X    case 'F':		/* (F)ill lamp */
X      refill_lamp();
X      break;
X    case 'G':		/* (G)ain magic spells */
X      gain_spells();
X      break;
X    case 'V':		/* (V)iew scores */
X      if (last_command != 'V')
X	i = TRUE;
X      else
X	i = FALSE;
X      save_screen();
X      display_scores(i);
X      restore_screen();
X      free_turn_flag = TRUE;
X      break;
X    case 'W':		/* (W)here are we on the map	(L)ocate on map */
X      if ((py.flags.blind > 0) || no_light())
X	msg_print("You can't see your map.");
X      else
X	{
X	  int cy, cx, p_y, p_x;
X
X	  y = char_row;
X	  x = char_col;
X	  if (get_panel(y, x, TRUE))
X	    prt_map();
X	  cy = panel_row;
X	  cx = panel_col;
X	  for(;;)
X	    {
X	      p_y = panel_row;
X	      p_x = panel_col;
X	      if (p_y == cy && p_x == cx)
X		tmp_str[0] = '\0';
X	      else
X		(void) sprintf(tmp_str, "%s%s of",
X			       p_y < cy ? " North" : p_y > cy ? " South" : "",
X			       p_x < cx ? " West" : p_x > cx ? " East" : "");
X	      (void) sprintf(out_val,
X	   "Map sector [%d,%d], which is%s your sector. Look which direction?",
X			     p_y, p_x, tmp_str);
X	      if (!get_dir(out_val, &dir_val))
X		break;
X/*								      -CJS-
X// Should really use the move function, but what the hell. This
X// is nicer, as it moves exactly to the same place in another
X// section. The direction calculation is not intuitive. Sorry.
X*/
X	      for(;;){
X		x += ((dir_val-1)%3 - 1) * SCREEN_WIDTH/2;
X		y -= ((dir_val-1)/3 - 1) * SCREEN_HEIGHT/2;
X		if (x < 0 || y < 0 || x >= cur_width || y >= cur_width)
X		  {
X		    msg_print("You've gone past the end of your map.");
X		    x -= ((dir_val-1)%3 - 1) * SCREEN_WIDTH/2;
X		    y += ((dir_val-1)/3 - 1) * SCREEN_HEIGHT/2;
X		    break;
X		  }
X		if (get_panel(y, x, TRUE))
X		  {
X		    prt_map();
X		    break;
X		  }
X	      }
X	    }
X	  /* Move to a new panel - but only if really necessary. */
X	  if (get_panel(char_row, char_col, FALSE))
X	    prt_map();
X	}
X      free_turn_flag = TRUE;
X      break;
X    case 'R':		/* (R)est a while */
X      rest();
X      break;
X    case '#':		/* (#) search toggle	(S)earch toggle */
X      if (py.flags.status & PY_SEARCH)
X	search_off();
X      else
X	search_on();
X      free_turn_flag = TRUE;
X      break;
X    case CTRL('B'):		/* (^B) tunnel down left	(T 1) */
X      tunnel(1);
X      break;
X    case CTRL('M'):		/* cr must be treated same as lf. */
X    case CTRL('J'):		/* (^J) tunnel down		(T 2) */
X      tunnel(2);
X      break;
X    case CTRL('N'):		/* (^N) tunnel down right	(T 3) */
X      tunnel(3);
X      break;
X    case CTRL('H'):		/* (^H) tunnel left		(T 4) */
X      tunnel(4);
X      break;
X    case CTRL('L'):		/* (^L) tunnel right		(T 6) */
X      tunnel(6);
X      break;
X    case CTRL('Y'):		/* (^Y) tunnel up left		(T 7) */
X      tunnel(7);
X      break;
X    case CTRL('K'):		/* (^K) tunnel up		(T 8) */
X      tunnel(8);
X      break;
X    case CTRL('U'):		/* (^U) tunnel up right		(T 9) */
X      tunnel(9);
X      break;
X    case 'z':		/* (z)ap a wand		(a)im a wand */
X      aim();
X      break;
X    case 'M':
X      screen_map();
X      free_turn_flag = TRUE;
X      break;
X    case 'P':		/* (P)eruse a book	(B)rowse in a book */
X      examine_book();
X      free_turn_flag = TRUE;
X      break;
X    case 'c':		/* (c)lose an object */
X      closeobject();
X      break;
X    case 'd':		/* (d)rop something */
X      inven_command('d');
X      break;
X    case 'e':		/* (e)quipment list */
X      inven_command('e');
X      break;
X    case 't':		/* (t)hrow something	(f)ire something */
X      throw_object();
X      break;
X    case 'i':		/* (i)nventory list */
X      inven_command('i');
X      break;
X    case 'S':		/* (S)pike a door	(j)am a door */
X      jamdoor();
X      break;
X    case 'x':		/* e(x)amine surrounds	(l)ook about */
X      look();
X      free_turn_flag = TRUE;
X      break;
X    case 'm':		/* (m)agic spells */
X      cast();
X      break;
X    case 'o':		/* (o)pen something */
X      openobject();
X      break;
X    case 'p':		/* (p)ray */
X      pray();
X      break;
X    case 'q':		/* (q)uaff */
X      quaff();
X      break;
X    case 'r':		/* (r)ead */
X      read_scroll();
X      break;
X    case 's':		/* (s)earch for a turn */
X      search(char_row, char_col, py.misc.srh);
X      break;
X    case 'T':		/* (T)ake off something	(t)ake off */
X      inven_command('t');
X      break;
X    case 'Z':		/* (Z)ap a staff	(u)se a staff */
X      use();
X      break;
X    case 'v':		/* (v)ersion of game */
X      helpfile(MORIA_VER);
X      free_turn_flag = TRUE;
X      break;
X    case 'w':		/* (w)ear or wield */
X      inven_command('w');
X      break;
X    case 'X':		/* e(X)change weapons	e(x)change */
X      inven_command('x');
X      break;
X    default:
X      if (wizard)
X	{
X	  free_turn_flag = TRUE; /* Wizard commands are free moves*/
X	  switch(com_val)
X	    {
X	    case CTRL('A'):	/*^A = Cure all*/
X	      (void) remove_curse();
X	      (void) cure_blindness();
X	      (void) cure_confusion();
X	      (void) cure_poison();
X	      (void) remove_fear();
X	      (void) res_stat(A_STR);
X	      (void) res_stat(A_INT);
X	      (void) res_stat(A_WIS);
X	      (void) res_stat(A_CON);
X	      (void) res_stat(A_DEX);
X	      (void) res_stat(A_CHR);
X	      f_ptr = &py.flags;
X	      if (f_ptr->slow > 1)
X		f_ptr->slow = 1;
X	      if (f_ptr->image > 1)
X		f_ptr->image = 1;
X	      break;
X	    case CTRL('E'):	/*^E = wizchar */
X	      change_character();
X	      erase_line(MSG_LINE, 0);
X	      break;
X	    case CTRL('F'):	/*^F = genocide*/
X	      (void) mass_genocide();
X	      break;
X	    case CTRL('G'):	/*^G = treasure*/
X	      if (command_count > 0)
X		{
X		  i = command_count;
X		  command_count = 0;
X		}
X	      else
X		i = 1;
X	      random_object(char_row, char_col, i);
X	      prt_map();
X	      break;
X	    case CTRL('D'):	/*^D = up/down */
X	      if (command_count > 0)
X		{
X		  if (command_count > 99)
X		    i = 0;
X		  else
X		    i = command_count;
X		  command_count = 0;
X		}
X	      else
X		{
X		  prt("Go to which level (0-99) ? ", 0, 0);
X		  i = -1;
X		  if (get_string(tmp_str, 0, 27, 10))
X		    i = atoi(tmp_str);
X		}
X	      if (i > -1)
X		{
X		  dun_level = i;
X		  if (dun_level > 99)
X		    dun_level = 99;
X		  new_level_flag = TRUE;
X		}
X	      else
X		erase_line(MSG_LINE, 0);
X	      break;
X	    case CTRL('O'):	/*^O = objects */
X	      print_objects();
X	      break;
X	    case '\\': /* \ wizard help */
X	      if (rogue_like_commands)
X		helpfile(MORIA_WIZ_HELP);
X	      else
X		helpfile(MORIA_OWIZ_HELP);
X	      break;
X	    case CTRL('I'):	/*^I = identify*/
X	      (void) ident_spell();
X	      break;
X	    case '*':
X	      wizard_light();
X	      break;
X	    case ':':
X	      map_area();
X	      break;
X	    case CTRL('T'):	/*^T = teleport*/
X	      teleport(100);
X	      break;
X	    case '+':
X	      if (command_count > 0)
X		{
X		  py.misc.exp = command_count;
X		  command_count = 0;
X		}
X	      else if (py.misc.exp == 0)
X		py.misc.exp = 1;
X	      else
X		py.misc.exp = py.misc.exp * 2;
X	      prt_experience();
X	      break;
X	    case '&':	/*& = summon  */
X	      y = char_row;
X	      x = char_col;
X	      (void) summon_monster(&y, &x, TRUE);
X	      creatures(FALSE);
X	      break;
X	    case '@':
X	      wizard_create();
X	      break;
X	    default:
X	      if (rogue_like_commands)
X		prt("Type '?' or '\\' for help.", 0, 0);
X	      else
X		prt("Type '?' or ^H for help.", 0, 0);
X	    }
X	}
X      else
X	{
X	  prt("Type '?' for help.", 0, 0);
X	  free_turn_flag = TRUE;
X	}
X    }
X  last_command = com_val;
X}
X
X/* Check whether this command will accept a count.     -CJS-  */
Xstatic int valid_countcommand(c)
Xchar c;
X{
X  switch(c)
X    {
X    case 'Q':
X    case CTRL('W'):
X    case CTRL('X'):
X    case '=':
X    case '{':
X    case '/':
X    case '<':
X    case '>':
X    case '?':
X    case 'C':
X    case 'E':
X    case 'F':
X    case 'G':
X    case 'V':
X    case '#':
X    case 'z':
X    case 'P':
X    case 'c':
X    case 'd':
X    case 'e':
X    case 't':
X    case 'i':
X    case 'x':
X    case 'm':
X    case 'p':
X    case 'q':
X    case 'r':
X    case 'T':
X    case 'Z':
X    case 'v':
X    case 'w':
X    case 'W':
X    case 'X':
X    case CTRL('A'):
X    case '\\':
X    case CTRL('I'):
X    case '*':
X    case ':':
X    case CTRL('T'):
X    case CTRL('E'):
X    case CTRL('F'):
X    case CTRL('S'):
X    case CTRL('Q'):
X      return FALSE;
X    case CTRL('P'):
X    case ESCAPE:
X    case ' ':
X    case '-':
X    case 'b':
X    case 'f':
X    case 'j':
X    case 'n':
X    case 'h':
X    case 'l':
X    case 'y':
X    case 'k':
X    case 'u':
X    case '.':
X    case 'B':
X    case 'J':
X    case 'N':
X    case 'H':
X    case 'L':
X    case 'Y':
X    case 'K':
X    case 'U':
X    case 'D':
X    case 'R':
X    case CTRL('Y'):
X    case CTRL('K'):
X    case CTRL('U'):
X    case CTRL('L'):
X    case CTRL('N'):
X    case CTRL('J'):
X    case CTRL('B'):
X    case CTRL('H'):
X    case 'S':
X    case 'o':
X    case 's':
X    case CTRL('D'):
X    case CTRL('G'):
X    case '+':
X      return TRUE;
X    default:
X      return FALSE;
X    }
X}
X
X
X/* Regenerate hit points				-RAK-	*/
Xstatic void regenhp(percent)
Xint percent;
X{
X  register struct misc *p_ptr;
X  register int32 new_chp, new_chp_frac;
X  int old_chp;
X
X  p_ptr = &py.misc;
X  old_chp = p_ptr->chp;
X  new_chp = ((long)p_ptr->mhp) * percent + PLAYER_REGEN_HPBASE;
X  p_ptr->chp += new_chp >> 16;	/* div 65536 */
X  /* check for overflow */
X  if (p_ptr->chp < 0 && old_chp > 0)
X    p_ptr->chp = MAX_SHORT;
X  new_chp_frac = (new_chp & 0xFFFF) + p_ptr->chp_frac; /* mod 65536 */
X  if (new_chp_frac >= 0x10000L)
X    {
X      p_ptr->chp_frac = new_chp_frac - 0x10000L;
X      p_ptr->chp++;
X    }
X  else
X    p_ptr->chp_frac = new_chp_frac;
X
X  /* must set frac to zero even if equal */
X  if (p_ptr->chp >= p_ptr->mhp)
X    {
X      p_ptr->chp = p_ptr->mhp;
X      p_ptr->chp_frac = 0;
X    }
X  if (old_chp != p_ptr->chp)
X    prt_chp();
X}
X
X
X/* Regenerate mana points				-RAK-	*/
Xstatic void regenmana(percent)
Xint percent;
X{
X  register struct misc *p_ptr;
X  register int32 new_mana, new_mana_frac;
X  int old_cmana;
X
X  p_ptr = &py.misc;
X  old_cmana = p_ptr->cmana;
X  new_mana = ((long)p_ptr->mana) * percent + PLAYER_REGEN_MNBASE;
X  p_ptr->cmana += new_mana >> 16;  /* div 65536 */
X  /* check for overflow */
X  if (p_ptr->cmana < 0 && old_cmana > 0)
X    p_ptr->cmana = MAX_SHORT;
X  new_mana_frac = (new_mana & 0xFFFF) + p_ptr->cmana_frac; /* mod 65536 */
X  if (new_mana_frac >= 0x10000L)
X    {
X      p_ptr->cmana_frac = new_mana_frac - 0x10000L;
X      p_ptr->cmana++;
X    }
X  else
X    p_ptr->cmana_frac = new_mana_frac;
X
X  /* must set frac to zero even if equal */
X  if (p_ptr->cmana >= p_ptr->mana)
X    {
X      p_ptr->cmana = p_ptr->mana;
X      p_ptr->cmana_frac = 0;
X    }
X  if (old_cmana != p_ptr->cmana)
X    prt_cmana();
X}
X
X
X/* Is an item an enchanted weapon or armor and we don't know?  -CJS- */
X/* only returns true if it is a good enchantment */
Xstatic int enchanted (t_ptr)
Xregister inven_type *t_ptr;
X{
X#ifdef ATARIST_MWC
X  int32u holder;
X#endif
X
X  if (t_ptr->tval < TV_MIN_ENCHANT || t_ptr->tval > TV_MAX_ENCHANT
X#ifdef ATARIST_MWC
X      || t_ptr->flags & (holder = TR_CURSED))
X#else
X      || t_ptr->flags & TR_CURSED)
X#endif
X    return FALSE;
X  if (known2_p(t_ptr))
X    return FALSE;
X  if (t_ptr->ident & ID_MAGIK)
X    return FALSE;
X  if (t_ptr->tohit > 0 || t_ptr->todam > 0 || t_ptr->toac > 0)
X    return TRUE;
X  if ((0x4000107fL & t_ptr->flags) && t_ptr->p1 > 0)
X    return TRUE;
X  if (0x07ffe980L & t_ptr->flags)
X    return TRUE;
X
X  return FALSE;
X}
X
X
X/* Examine a Book					-RAK-	*/
Xstatic void examine_book()
X{
X  int32u j;
X  int i, k, item_val, flag;
X  int spell_index[31];
X  register inven_type *i_ptr;
X  register spell_type *s_ptr;
X
X  if (!find_range(TV_MAGIC_BOOK, TV_PRAYER_BOOK, &i, &k))
X    msg_print("You are not carrying any books.");
X  else if (py.flags.blind > 0)
X    msg_print("You can't see to read your spell book!");
X  else if (no_light())
X    msg_print("You have no light to read by.");
X  else if (py.flags.confused > 0)
X    msg_print("You are too confused.");
X  else if (get_item(&item_val, "Which Book?", i, k, CNIL, CNIL))
X    {
X      flag = TRUE;
X      i_ptr = &inventory[item_val];
X      if (class[py.misc.pclass].spell == MAGE)
X	{
X	  if (i_ptr->tval != TV_MAGIC_BOOK)
X	    flag = FALSE;
X	}
X      else if (class[py.misc.pclass].spell == PRIEST)
X	{
X	  if (i_ptr->tval != TV_PRAYER_BOOK)
X	    flag = FALSE;
X	}
X      else
X	flag = FALSE;
X
X      if (!flag)
X	msg_print("You do not understand the language.");
X      else
X	{
X	  i = 0;
X	  j = inventory[item_val].flags;
X	  while (j)
X	    {
X	      k = bit_pos(&j);
X	      s_ptr = &magic_spell[py.misc.pclass-1][k];
X	      if (s_ptr->slevel < 99)
X		{
X		  spell_index[i] = k;
X		  i++;
X		}
X	    }
X	  save_screen();
X	  print_spells(spell_index, i, TRUE, -1);
X	  pause_line(0);
X	  restore_screen();
X	}
X    }
X}
X
X
X/* Go up one level					-RAK-	*/
Xstatic void go_up()
X{
X  register cave_type *c_ptr;
X  register int no_stairs = FALSE;
X
X  c_ptr = &cave[char_row][char_col];
X  if (c_ptr->tptr != 0)
X    if (t_list[c_ptr->tptr].tval == TV_UP_STAIR)
X      {
X	dun_level--;
X	new_level_flag = TRUE;
X	msg_print("You enter a maze of up staircases.");
X	msg_print("You pass through a one-way door.");
X      }
X    else
X      no_stairs = TRUE;
X  else
X    no_stairs = TRUE;
X
X  if (no_stairs)
X    {
X      msg_print("I see no up staircase here.");
X      free_turn_flag = TRUE;
X    }
X}
X
X
X/* Go down one level					-RAK-	*/
Xstatic void go_down()
X{
X  register cave_type *c_ptr;
X  register int no_stairs = FALSE;
X
X  c_ptr = &cave[char_row][char_col];
X  if (c_ptr->tptr != 0)
X    if (t_list[c_ptr->tptr].tval == TV_DOWN_STAIR)
X      {
X	dun_level++;
X	new_level_flag = TRUE;
X	msg_print("You enter a maze of down staircases.");
X	msg_print("You pass through a one-way door.");
X      }
X    else
X      no_stairs = TRUE;
X  else
X    no_stairs = TRUE;
X
X  if (no_stairs)
X    {
X      msg_print("I see no down staircase here.");
X      free_turn_flag = TRUE;
X    }
X}
X
X
X/* Jam a closed door					-RAK-	*/
Xstatic void jamdoor()
X{
X  int y, x, dir, i, j;
X  register cave_type *c_ptr;
X  register inven_type *t_ptr, *i_ptr;
X  char tmp_str[80];
X
X  free_turn_flag = TRUE;
X  y = char_row;
X  x = char_col;
X  if (get_dir(CNIL, &dir))
X    {
X      (void) mmove(dir, &y, &x);
X      c_ptr = &cave[y][x];
X      if (c_ptr->tptr != 0)
X	{
X	  t_ptr = &t_list[c_ptr->tptr];
X	  if (t_ptr->tval == TV_CLOSED_DOOR)
X	    if (c_ptr->cptr == 0)
X	      {
X		if (find_range(TV_SPIKE, TV_NEVER, &i, &j))
X		  {
X		    free_turn_flag = FALSE;
X		    count_msg_print("You jam the door with a spike.");
X		    if (t_ptr->p1 > 0)
X		      t_ptr->p1 = -t_ptr->p1;	/* Make locked to stuck. */
X		    /* Successive spikes have a progressively smaller effect.
X		       Series is: 0 20 30 37 43 48 52 56 60 64 67 70 ... */
X		    t_ptr->p1 -= 1 + 190 / (10 - t_ptr->p1);
X		    i_ptr = &inventory[i];
X		    if (i_ptr->number > 1)
X		      {
X			i_ptr->number--;
X			inven_weight -= i_ptr->weight;
X		      }
X		    else
X		      inven_destroy(i);
X		  }
X		else
X		  msg_print("But you have no spikes.");
X	      }
X	    else
X	      {
X		free_turn_flag = FALSE;
X		(void) sprintf(tmp_str, "The %s is in your way!",
X			       c_list[m_list[c_ptr->cptr].mptr].name);
X		msg_print(tmp_str);
X	      }
X	  else if (t_ptr->tval == TV_OPEN_DOOR)
X	    msg_print("The door must be closed first.");
X	  else
X	    msg_print("That isn't a door!");
X	}
X      else
X	msg_print("That isn't a door!");
X    }
X}
X
X
X/* Refill the players lamp				-RAK-	*/
Xstatic void refill_lamp()
X{
X  int i, j;
X  register int k;
X  register inven_type *i_ptr;
X
X  free_turn_flag = TRUE;
X  k = inventory[INVEN_LIGHT].subval;
X  if (k != 0)
X    msg_print("But you are not using a lamp.");
X  else if (!find_range(TV_FLASK, TV_NEVER, &i, &j))
X    msg_print("You have no oil.");
X  else
X    {
X      free_turn_flag = FALSE;
X      i_ptr = &inventory[INVEN_LIGHT];
X      i_ptr->p1 += inventory[i].p1;
X      if (i_ptr->p1 > OBJ_LAMP_MAX)
X	{
X	  i_ptr->p1 = OBJ_LAMP_MAX;
X	  msg_print ("Your lamp overflows, spilling oil on the ground.");
X	  msg_print("Your lamp is full.");
X	}
X      else if (i_ptr->p1 > OBJ_LAMP_MAX/2)
X	msg_print ("Your lamp is more than half full.");
X      else if (i_ptr->p1 == OBJ_LAMP_MAX/2)
X	msg_print ("Your lamp is half full.");
X      else
X	msg_print ("Your lamp is less than half full.");
X      desc_remain(i);
X      inven_destroy(i);
X    }
X}
END_OF_FILE
if test 49774 -ne `wc -c <'source/dungeon.c'`; then
    echo shar: \"'source/dungeon.c'\" unpacked with wrong size!
fi
# end of 'source/dungeon.c'
fi
echo shar: End of archive 4 \(of 39\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
