Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i064:  umoria4 - single player dungeon simulation (ver. 5.5), Part32/39
Message-ID: <3428@master.CNA.TEK.COM>
Date: 22 Aug 92 22:14:46 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1957
Approved: billr@saab.CNA.TEK.COM

Submitted-by: grabiner@math.harvard.edu (David Grabiner)
Posting-number: Volume 14, Issue 64
Archive-name: umoria4/Part32
Supersedes: umoria3: Volume 9, Issue 55-97; Volume 10, Issue 15-17
Environment: Curses, Unix, Mac, MS-DOS, Atari-ST, Amiga, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 32 (of 39)."
# Contents:  ibmpc/TCCONFIG.TCU mac/macscore.c misc/damage.chg
#   misc/wex.msg source/config.h source/wizard.c
# Wrapped by billr@saab on Thu Aug 20 09:11:35 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ibmpc/TCCONFIG.TCU' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ibmpc/TCCONFIG.TCU'\"
else
echo shar: Extracting \"'ibmpc/TCCONFIG.TCU'\" \(2402 characters\)
sed "s/^X//" >'ibmpc/TCCONFIG.TCU' <<'END_OF_FILE'
XA uuencoded copy of a TCCONFIG.TCU file.
X
Xbegin 640 TCCONFIG.TC
XM5'5R8F\@0R!#;VYF:6=U<F%T:6]N($9I;&4@&@ !#1(7 1H  @$!  (  0 "
XM  (  0 #  (  @ $  $   4  0  !@ !   (  $ !0D  @ !  T  @    X 
XM @   !$  0 $$@ "  $ $P " !D %  "  $ %0 "  $ %@ "  ( %P "    
XM&  "    9  !  %E  $  68  0 !9P !  %H  $  6D  0 !:@ !  %K  $ 
XM 6P  0 !;0 !  %N  $  6\  0 !<  !  %Q  $  7(  0 !<P !  %T  $ 
XM 74  0 !=@ !  %W  $  7@  0 !>0 !  %Z  $  7L  0  ?  !  %]  $ 
XM 7X  0  ?P !  &   $  8(  0  A  !  "%  $  <@  0 !R0 !  #*  $ 
XM LL  0  S  !  #-  $  ,X  0 !SP !  #0  $ &=$  0!DT@ ! "#5  $ 
XM -<  0  V  !  #9  $  =H  0 !VP !  #<  $  -T  0 !W@ !  '?  $ 
XM .   0  X0 !  #B  $  2P!1  N                                
XM                                                         "T!
XM@ !$.EQ455)"3UQ#7$E.0TQ51$4                                 
XM                                                            
XM                                                     "X!@ !$
XM.EQ455)"3UQ#7$Q)0@                                          
XM                                                            
XM                                                 "\!4 !534]2
XM24$N4%)*                                                    
XM                                         # !!  S,@  ,0$% #(U
XM    ,@$% #$P,   ,P%_ $U31$]3                                
XM                                                            
XM                                                            
XM           T 1X *@                                      -0$>
XM "H                                      #8!'@ J            
XM                           W 1X *@                          
XM            . $> "H                                      #D!
XM'@ J                                       Z 1X *@          
XM                            .P$> "H                         
XM             #P!'@ J                                       ]
XM 8                                                          
XM                                                            
XM                                                       ^ 00 
XM-    #\!4 !40U!)0TLN5$,                                     
XM                                                         $ !
XM1 !$.EQ455)"3UQ#7$))3@                                      
XM                                 $$!4                       
XM                                                            
X9                         /__ @ :    
X 
Xend
END_OF_FILE
if test 2402 -ne `wc -c <'ibmpc/TCCONFIG.TCU'`; then
    echo shar: \"'ibmpc/TCCONFIG.TCU'\" unpacked with wrong size!
fi
# end of 'ibmpc/TCCONFIG.TCU'
fi
if test -f 'mac/macscore.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/macscore.c'\"
else
echo shar: Extracting \"'mac/macscore.c'\" \(10176 characters\)
sed "s/^X//" >'mac/macscore.c' <<'END_OF_FILE'
X/* mac/macscore.c: scorefile code
X
X   Copyright (c) 1989-1991 Curtis McCauley, James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#include <stdio.h>
X
X#ifndef THINK_C
X#include <Types.h>
X#include <Resources.h>
X#include <Events.h>
X#include <Quickdraw.h>
X#include <Fonts.h>
X#include <Controls.h>
X#include <Dialogs.h>
X#include <TextEdit.h>
X#include <Lists.h>
X#include <Packages.h>
X#include <Files.h>
X#include <SysEqu.h>
X#include <Errors.h>
X
X#include <String.h>
X#include <Strings.h>
X
X#include <ScrnMgr.h>
X
X#else
X
X#include <string.h>
X
X#include "ScrnMgr.h"
X
X#define p2cstr(x)	(char *)PtoCstr((char *)x)
X#define c2pstr(x)	(char *)CtoPstr((char *)x)
X
X#endif
X
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#define maxEntries				100
X
X#define horizIndent				4				/* same as std LDEF 0 */
X
X#define ldefType				'LDEF'
X#define ldefID					514
X
X#define scoresDlgID				514
X#define dfltBorder				2
X#define listBox					3
X#define titleBox				4
X
X#define codeEnter				0x03
X#define codeReturn				0x0D
X
X#ifdef THINK_C
X/* Cover up error in THINK C library.  */
X#define ok	OK
X#define cancel	Cancel
X#endif
X
Xtypedef struct LDEFRec {
X	short braInstruction;
X	short flags;
X	int32 resType;
X	short resID;
X	short version;
X	short jmpInstuction;
X#ifdef THINK_C
X	void (*defProc)();
X#else
X	pascal void (*defProc)();
X#endif
X} LDEFRec, *LDEFPtr, **LDEFHandle;
X
Xstatic short scoresRefNum;
X
Xstatic short lastVisTop;
Xstatic Rect titleRect;
X
Xstatic ControlHandle okButton;
X
Xstatic ListHandle theList;
X
Xvoid CreateScoreFile()
X
X{
X	Str255 fileName;
X	OSErr err;
X
X	strncpy((char *)fileName, MORIA_TOP, 255);
X	fileName[255] = '\0';
X	(void) c2pstr(fileName);
X
X	appldirectory();
X	err = FSOpen(fileName, 0, &scoresRefNum);
X	if (err == noErr)
X		(void) FSClose(scoresRefNum);
X	else
X		err = Create(fileName, 0, MORIA_FCREATOR, SCORE_FTYPE);
X	restoredirectory();
X
X	if (err != noErr)
X		alert_error("Ooops!  Could not create the high scores \
Xfile.  Disk may be locked.");
X
X	return;
X}
X
Xvoid EnterScoreFile(theScore)
Xint32 *theScore;
X
X{
X#if 0
X	Str255 fileName;
X	OSErr err;
X	Boolean bump, append;
X	int32 i, pos, count;
X	int32 prev, next;
X	char message[80];
X
X	strncpy(fileName, MORIA_TOP, 255);
X	fileName[255] = '\0';
X	(void) c2pstr(fileName);
X
X	appldirectory();
X	err = FSOpen(fileName, 0, &scoresRefNum);
X	restoredirectory();
X
X	if (err != noErr) {
X		alert_error("Sorry.  High scores file could not be opened.");
X		return;
X	}
X
X	bump = false;
X	append = false;
X
X	prev = *theScore;
X
X	for (i = 0, pos = 0; i < maxEntries; pos += sizeof(int32), i++) {
X
X		count = sizeof(int32);
X		err = FSRead(scoresRefNum, &count, (Ptr) &next);
X
X		if (err == noErr)
X			bump = (bump) || (prev.points >= next.points);
X		else if (err == eofErr)
X			append = true;
X		else
X			break;
X
X		if ( (!bump) && (!append) ) continue;
X
X		SetFPos(scoresRefNum, fsFromStart, pos);
X
X		count = sizeof(int32);
X		err = FSWrite(scoresRefNum, &count, (Ptr) &prev);
X
X		if ( (err != noErr) || (append) ) break;
X
X		prev = next;
X
X	}
X
X	(void) FSClose(scoresRefNum);
X
X	if (err != noErr) {
X		sprintf(message, "Bad news.  Error %d while updating scores file.", err);
X		alert_error(message);
X	}
X
X	return;
X#else
X#pragma unused(theScore)
X#endif
X}
X
Xstatic void Init(list)
XListHandle list;
X
X{
X	GrafPtr thePort;
X	FontInfo fi;
X	short saveFont, saveSize;
X
X	GetPort(&thePort);
X
X	saveFont = thePort->txFont;
X	saveSize = thePort->txSize;
X
X	TextFont(monaco);
X	TextSize(9);
X
X	GetFontInfo(&fi);
X
X	TextFont(saveFont);
X	TextSize(saveSize);
X
X	(*list)->indent.v = fi.ascent;
X	(*list)->indent.h = horizIndent;
X
X	return;
X}
X
Xstatic void Draw(scoreptr, clip, indent)
Xint32 *scoreptr;
XRect *clip;
XPoint indent;
X
X{
X#if 0
X	char line[80];
X	GrafPtr thePort;
X	short saveFont, saveSize;
X
X	if (scoreptr != NULL) {
X		(void) sprintf(line, "%-7d%-15.15s%-10.10s%-10.10s%-5d%-25.25s%5d",
X						(int32) scoreptr->points, scoreptr->name,
X						race[scoreptr->prace].trace, class[scoreptr->pclass].title,
X						(int32) scoreptr->lev, scoreptr->died_from, scoreptr->dun_level);
X		(void) c2pstr(line);
X	}
X	else
X		(void) c2pstr(strcpy(line, "No Scores\311"));
X
X	GetPort(&thePort);
X
X	saveFont = thePort->txFont;
X	saveSize = thePort->txSize;
X
X	TextFont(monaco);
X	TextSize(9);
X
X	PenNormal();
X	EraseRect(clip);
X
X	MoveTo(clip->left + indent.h, clip->top + indent.v);
X	DrawString(line);
X
X	TextFont(saveFont);
X	TextSize(saveSize);
X
X	return;
X#else
X#pragma unused(scoreptr, clip, indent)
X#endif
X}
X
Xstatic pascal void HighScoresLDEF(msg, select, clip, cno, dataOffset,
X				  dataLen, list)
Xshort msg;
XBoolean select;
XRect *clip;
XCell cno;
Xshort dataOffset, dataLen;
XListHandle list;
X
X{
X#ifndef THINK_C
X	#pragma unused(select, cno, dataLen)
X#endif
X	short offset;
X	int32 count;
X	int32 score;
X
X	switch (msg) {
X
X		case lInitMsg:
X			Init(list);
X			break;
X
X		case lDrawMsg:
X			offset = *((short *) (*(*list)->cells + dataOffset));
X			if (offset == -1) {
X				Draw(NULL, clip, (*list)->indent);
X			}
X			else {
X				count = sizeof(int32);
X				(void) SetFPos(scoresRefNum, fsFromStart, (int32) offset);
X				(void) FSRead(scoresRefNum, &count, (Ptr) &score);
X				Draw(&score, clip, (*list)->indent);
X			}
X			break;
X
X	}
X
X	return;
X}
X
Xstatic void InvalScoreRange()
X
X{
X	char from[8], to[8];
X	short first, last;
X
X	first = (*theList)->visible.top + 1;
X	last = (*theList)->visible.bottom;
X	if (last > (*theList)->dataBounds.bottom)
X	  last = (*theList)->dataBounds.bottom;
X
X	NumToString(first, from);
X	NumToString(last, to);
X
X	ParamText(from, to, NULL, NULL);
X
X	InvalRect(&titleRect);
X
X	lastVisTop = (*theList)->visible.top;
X
X	return;
X}
X
Xstatic pascal Boolean ScoresDlgFilter(theDialog, theEvent, itemHit)
XDialogPtr theDialog;
XEventRecord *theEvent;
Xshort *itemHit;
X
X{
X	GrafPtr oldPort;
X	Point localPt;
X	WindowPtr theWindow;
X	ControlHandle theControl;
X	Boolean handled;
X	char key;
X	short part;
X
X	handled = false;
X
X	switch (theEvent->what) {
X
X		case keyDown:
X			key = theEvent->message & charCodeMask;
X			if ( (key == codeEnter) || (key == codeReturn) ) {
X				handled = true;
X				HiliteControl(okButton, inButton);
X				*itemHit = ok;
X			}
X			break;
X
X		case mouseDown:
X			part = FindWindow(theEvent->where, &theWindow);
X			if ( (theWindow == (WindowPtr) theDialog) && (part == inContent) ) {
X				GetPort(&oldPort);
X				SetPort((GrafPtr) theWindow);
X				localPt = theEvent->where;
X				GlobalToLocal(&localPt);
X				part = FindControl(localPt, theWindow, &theControl);
X				if (theControl == (*theList)->vScroll) {
X					handled = true;
X					(void) LClick(localPt, theEvent->modifiers, theList);
X					if ((*theList)->visible.top != lastVisTop) InvalScoreRange();
X					*itemHit = listBox;
X				}
X				SetPort(oldPort);
X			}
X			break;
X
X	}
X
X	return(handled);
X}
X
Xstatic pascal void DrawListBox(theWindow, theItem)
XWindowPtr theWindow;
Xshort theItem;
X
X{
X	GrafPtr thePort;
X	short saveFont, saveSize;
X	short itsType;
X	Handle itsHandle;
X	Rect itsRect;
X
X	GetDItem((DialogPtr) theWindow, theItem, &itsType, &itsHandle, &itsRect);
X
X	GetPort(&thePort);
X
X	saveFont = thePort->txFont;
X	saveSize = thePort->txSize;
X
X	TextFont(monaco);
X	TextSize(9);
X
X	MoveTo(itsRect.left + (*theList)->indent.h + 1,
X	       itsRect.top + (*theList)->indent.v);
X	DrawString("\pPoints Name           Race      Class     Lv   Killed \
XBy                Dun Lv");
X
X	TextFont(saveFont);
X	TextSize(saveSize);
X
X	itsRect.top += (*theList)->cellSize.v;
X	FrameRect(&itsRect);
X
X	EraseRect(&(*theList)->rView);
X	LUpdate(theWindow->visRgn, theList);
X
X	return;
X}
X
Xvoid DoScoresDlg()
X
X{
X	Str255 fileName;
X	OSErr err;
X	int32 bytes;
X	short entries;
X	GrafPtr oldPort;
X	FontInfo fi;
X	short saveFont, saveSize;
X	DialogPtr theDialog;
X	Handle itsHandle;
X	Handle ldef;
X	short itemHit;
X	short itsType;
X	Rect itsRect;
X	Rect listRect, cellRect;
X	Point cellSize;
X	int32 i;
X	int32 h, v;
X	Point cno;
X	short offset;
X
X	CreateScoreFile();
X
X	strncpy((char *)fileName, MORIA_TOP, 255);
X	fileName[255] = '\0';
X	(void) c2pstr(fileName);
X
X	appldirectory();
X	err = FSOpen(fileName, 0, &scoresRefNum);
X	restoredirectory();
X
X	if (err != noErr) {
X		alert_error("Sorry.  High scores file could not be opened.");
X		return;
X	}
X
X	(void) GetEOF(scoresRefNum, &bytes);
X	entries = bytes / sizeof(int32);
X
X	theDialog = GetNewDialog(scoresDlgID, nil, (WindowPtr) -1);
X
X	GetPort(&oldPort);
X	SetPort((GrafPtr) theDialog);
X
X	saveFont = theDialog->txFont;
X	saveSize= theDialog->txSize;
X
X	TextFont(monaco);
X	TextSize(9);
X
X	GetFontInfo(&fi);
X
X	TextFont(saveFont);
X	TextSize(saveSize);
X
X	CenterScreenDLOG(scoresDlgID, fixHalf, fixHalf, &h, &v);
X	MoveWindow((WindowPtr) theDialog, (short) h, (short) v, false);
X
X	GetDItem(theDialog, ok, &itsType, (Handle *) &okButton, &itsRect);
X	InsetRect(&itsRect, -4, -4);
X
X	SetDItem(theDialog, dfltBorder, userItem, (Handle) DrawDefaultBorder,
X		 &itsRect);
X
X	GetDItem(theDialog, titleBox, &itsType, &itsHandle, &titleRect);
X
X	GetDItem(theDialog, listBox, &itsType, &itsHandle, &listRect);
X
X	SetPt(&cellSize, listRect.right - listRect.left - 2,
X	      fi.ascent + fi.descent + fi.leading);
X
X	listRect.bottom =
X		listRect.top +
X		((listRect.bottom - listRect.top - 2) / cellSize.v) * cellSize.v +
X		2;
X
X	SetDItem(theDialog, listBox, userItem, (Handle) DrawListBox, &listRect);
X
X	InsetRect(&listRect, 1, 1);
X	listRect.top += cellSize.v;
X	listRect.right -= 15;
X
X	ldef = GetResource(ldefType, ldefID);
X	MoveHHi(ldef);
X	HLock(ldef);
X
X	(*((LDEFHandle) ldef))->defProc = HighScoresLDEF;
X
X	SetRect(&cellRect, 0, 0, 1, entries ? entries : 1);
X
X	theList = LNew(
X		&listRect, &cellRect, cellSize,
X		ldefID, (WindowPtr) theDialog,
X		false, false, false, true);
X
X	if (!entries) {
X		offset = -1;
X		SetPt(&cno, 0, 0);
X		LSetCell((Ptr) &offset, (short) sizeof(offset), cno, theList);
X	}
X	else {
X		for (i = 0, offset = 0; i < entries; i++, offset += sizeof(int32)) {
X			SetPt(&cno, 0, i);
X			LSetCell((Ptr) &offset, (short) sizeof(offset), cno, theList);
X		}
X	}
X
X	LDoDraw(true, theList);
X
X	InvalScoreRange();
X
X	ShowWindow((WindowPtr) theDialog);
X
X	do {
X		ModalDialog(ScoresDlgFilter, &itemHit);
X	} while (itemHit != ok);
X
X	LDispose(theList);
X
X	HUnlock(ldef);
X
X	SetPort(oldPort);
X
X	DisposDialog(theDialog);
X
X	(void) FSClose(scoresRefNum);
X
X	return;
X}
END_OF_FILE
if test 10176 -ne `wc -c <'mac/macscore.c'`; then
    echo shar: \"'mac/macscore.c'\" unpacked with wrong size!
fi
# end of 'mac/macscore.c'
fi
if test -f 'misc/damage.chg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/damage.chg'\"
else
echo shar: Extracting \"'misc/damage.chg'\" \(10400 characters\)
sed "s/^X//" >'misc/damage.chg' <<'END_OF_FILE'
XFrom grabiner@zariski.harvard.edu Sun Nov 18 11:55:11 1990
XReceived: from ernie.Berkeley.EDU by ylem.berkeley.edu (5.61/1.34)
X	id AA19024; Sun, 18 Nov 90 11:55:09 -0800
XReceived: from brauer.harvard.edu by ernie.Berkeley.EDU (5.63/1.41)
X	id AA04665; Sun, 18 Nov 90 12:02:59 -0800
XDate: Sun, 18 Nov 90 15:03:18 EST
XFrom: grabiner@zariski.harvard.edu (David Grabiner)
XMessage-Id: <9011182003.AA02675@brauer.harvard.edu>
XTo: wilson@ernie.Berkeley.EDU
XSubject: Patch file fixed; now it compiles
XStatus: RO
X
X
XI made some stupid typos in the patch file I sent you Friday.  Now
XI have compiled the program with the revise patch file, and checked
Xthat it works.  Here is the corrected patch file.
X
X*** misc2.c.~1~	Fri Nov 16 22:08:51 1990
X--- misc2.c	Sat Nov 17 00:10:07 1990
X***************
X*** 981,987 ****
X  	}
X      }
X    prt_num("+ To Hit    ", m_ptr->dis_th,  9, 1);
X!   prt_num("+ To Damage ", m_ptr->dis_td, 10, 1);
X    prt_num("+ To AC     ", m_ptr->dis_tac, 11, 1);
X    prt_num("  Total AC  ", m_ptr->dis_ac, 12, 1);
X  }
X--- 981,987 ----
X  	}
X      }
X    prt_num("+ To Hit    ", m_ptr->dis_th,  9, 1);
X!   prt_num("Damage Bonus", m_ptr->dis_td, 10, 1);
X    prt_num("+ To AC     ", m_ptr->dis_tac, 11, 1);
X    prt_num("  Total AC  ", m_ptr->dis_ac, 12, 1);
X  }
X***************
X*** 2253,2260 ****
X--- 2253,2273 ----
X      }
X  }
X
X+ /* Add damage bonus to weapon damage			-DJG-	*/
X+ /* Damage bonuses have greater effect on larger weapon damages,
X+    so that daggers are not the best weapons in the game.	*/
X+ int add_dam_bonus(dam, bonus)
X+ register int dam, bonus;
X+ {
X+   /* Add 2 to dam, multiply by 1+(bonus/9), round off, subtract 2;
X+      thus bonus is added unchanged to a damage of 7 points, halved
X+      on 1d4 damage, and nearly doubled on 4d6 damage */
X+   return ((((dam+2) * (18+(2*bonus)) + 9) / 18) - 2);
X+ }
X
X  /* Special damage due to magical abilities of object	-RAK-	*/
X+ /* Multipliers have been reduced here, but they now apply to
X+    magical bonuses as well				-DJG-	*/
X  int tot_dam(i_ptr, tdam, monster)
X  register inven_type *i_ptr;
X  register int tdam;
X***************
X*** 2280,2286 ****
X        /* Slay Dragon  */
X        if ((m_ptr->cdefense & CD_DRAGON) && (i_ptr->flags & TR_SLAY_DRAGON))
X  	{
X! 	  tdam = tdam * 4;
X  	  r_ptr->r_cdefense |= CD_DRAGON;
X  	}
X        /* Slay Undead  */
X--- 2293,2299 ----
X        /* Slay Dragon  */
X        if ((m_ptr->cdefense & CD_DRAGON) && (i_ptr->flags & TR_SLAY_DRAGON))
X  	{
X! 	  tdam = tdam * 5 / 2;
X  	  r_ptr->r_cdefense |= CD_DRAGON;
X  	}
X        /* Slay Undead  */
X***************
X*** 2292,2298 ****
X  	       && (i_ptr->flags & TR_SLAY_UNDEAD))
X  #endif
X  	{
X! 	  tdam = tdam * 3;
X  	  r_ptr->r_cdefense |= CD_UNDEAD;
X  	}
X        /* Slay Animal  */
X--- 2305,2311 ----
X  	       && (i_ptr->flags & TR_SLAY_UNDEAD))
X  #endif
X  	{
X! 	  tdam = tdam * 2;
X  	  r_ptr->r_cdefense |= CD_UNDEAD;
X  	}
X        /* Slay Animal  */
X***************
X*** 2299,2311 ****
X        else if ((m_ptr->cdefense & CD_ANIMAL)
X  	       && (i_ptr->flags & TR_SLAY_ANIMAL))
X  	{
X! 	  tdam = tdam * 2;
X  	  r_ptr->r_cdefense |= CD_ANIMAL;
X  	}
X        /* Slay Evil     */
X        else if ((m_ptr->cdefense & CD_EVIL) && (i_ptr->flags & TR_SLAY_EVIL))
X  	{
X! 	  tdam = tdam * 2;
X  	  r_ptr->r_cdefense |= CD_EVIL;
X  	}
X        /* Frost	       */
X--- 2312,2324 ----
X        else if ((m_ptr->cdefense & CD_ANIMAL)
X  	       && (i_ptr->flags & TR_SLAY_ANIMAL))
X  	{
X! 	  tdam = tdam * 3 / 2;
X  	  r_ptr->r_cdefense |= CD_ANIMAL;
X  	}
X        /* Slay Evil     */
X        else if ((m_ptr->cdefense & CD_EVIL) && (i_ptr->flags & TR_SLAY_EVIL))
X  	{
X! 	  tdam = tdam * 3 / 2;
X  	  r_ptr->r_cdefense |= CD_EVIL;
X  	}
X        /* Frost	       */
X***************
X*** 2317,2323 ****
X  	       && (i_ptr->flags & TR_FROST_BRAND))
X  #endif
X  	{
X! 	  tdam = tdam * 3 / 2;
X  	  r_ptr->r_cdefense |= CD_FROST;
X  	}
X        /* Fire	      */
X--- 2330,2336 ----
X  	       && (i_ptr->flags & TR_FROST_BRAND))
X  #endif
X  	{
X! 	  tdam = tdam * 5 / 4;
X  	  r_ptr->r_cdefense |= CD_FROST;
X  	}
X        /* Fire	      */
X***************
X*** 2329,2335 ****
X  	       && (i_ptr->flags & TR_FLAME_TONGUE))
X  #endif
X  	{
X! 	  tdam = tdam * 3 / 2;
X  	  r_ptr->r_cdefense |= CD_FIRE;
X  	}
X      }
X--- 2342,2348 ----
X  	       && (i_ptr->flags & TR_FLAME_TONGUE))
X  #endif
X  	{
X! 	  tdam = tdam * 5 / 4;
X  	  r_ptr->r_cdefense |= CD_FIRE;
X  	}
X      }
X*** moria2.c.~1~	Fri Nov 16 21:59:04 1990
X--- moria2.c	Sat Nov 17 00:10:04 1990
X***************
X*** 751,756 ****
X--- 751,757 ----
X  	  if (i_ptr->tval != TV_NOTHING)
X  	    {
X  	      k = pdamroll(i_ptr->damage);
X+ 	      k = add_dam_bonus(k, p_ptr->ptodam);
X  	      k = tot_dam(i_ptr, k, monptr);
X  	      k = critical_blow((int)i_ptr->weight, tot_tohit, k, CLA_BTH);
X  	    }
X***************
X*** 757,765 ****
X  	  else			      /* Bare hands!?  */
X  	    {
X  	      k = damroll(1, 1);
X  	      k = critical_blow(1, 0, k, CLA_BTH);
X  	    }
X- 	  k += p_ptr->ptodam;
X  	  if (k < 0)  k = 0;
X
X  	  if (py.flags.confuse_monster)
X--- 758,766 ----
X  	  else			      /* Bare hands!?  */
X  	    {
X  	      k = damroll(1, 1);
X+ 	      k = add_dam_bonus(k, p_ptr->ptodam);
X  	      k = critical_blow(1, 0, k, CLA_BTH);
X  	    }
X  	  if (k < 0)  k = 0;
X
X  	  if (py.flags.confuse_monster)
X*** treasure.c.~1~	Fri Nov 16 23:53:35 1990
X--- treasure.c	Sat Nov 17 00:10:06 1990
X***************
X*** 169,175 ****
X  {"& Small Sword"		,0x00000000L,	TV_SWORD, '|',	/* 49*/
X      0,	  48,	22,   1,  75,	0,   0,	 0,   0, {1,6}	,  5},
X  {"& Two-Handed Sword (Zweihander)",0x00000000L,	TV_SWORD, '|',	/* 50*/
X!     0,	1000,	23,   1, 280,	0,   0,	 0,   0, {4,6}	, 50},
X  {"& Broken sword"		,0x00000000L,	TV_SWORD, '|',	/* 51*/
X      0,	   0,	24,   1,  75,  -2,  -2,	 0,   0, {1,1}	,  0},
X  {"& Ball and Chain"		,0x00000000L,	TV_HAFTED, '\\',/* 52*/
X--- 169,175 ----
X  {"& Small Sword"		,0x00000000L,	TV_SWORD, '|',	/* 49*/
X      0,	  48,	22,   1,  75,	0,   0,	 0,   0, {1,6}	,  5},
X  {"& Two-Handed Sword (Zweihander)",0x00000000L,	TV_SWORD, '|',	/* 50*/
X!     0,	1500,	23,   1, 280,	0,   0,	 0,   0, {4,6}	, 50},
X  {"& Broken sword"		,0x00000000L,	TV_SWORD, '|',	/* 51*/
X      0,	   0,	24,   1,  75,  -2,  -2,	 0,   0, {1,1}	,  0},
X  {"& Ball and Chain"		,0x00000000L,	TV_HAFTED, '\\',/* 52*/
X
XFrom grabiner@math.harvard.edu Sun Nov 25 14:41:25 1990
XReceived: from zariski.harvard.edu by ylem.berkeley.edu (5.61/1.34)
X	id AA01764; Sun, 25 Nov 90 14:41:22 -0800
XDate: Sun, 25 Nov 90 17:52:59 EST
XFrom: grabiner@math.harvard.edu (David Grabiner)
XMessage-Id: <9011252252.AA04462@zariski.harvard.edu>
XTo: wilson@ylem.berkeley.edu
XSubject: Re:  When damage bonuses get added in
XStatus: RO
X
X>	In this patch, I also rewrote the damage code to add all bonuses and
X>	then multiply, and compensated for the strengthening of ego weapons by
X>	halving the extra multiplier; thus, in my patch, a SD weapon does 2.5x
X>	damage, instead of 4x, and a FT does 1.25x, not 1.5x.
X>
X>This instantly makes all current spoilers obsolete, and will confuse a hell
X>of a lot of people.
X
XThese same people have been confused by the present system.  Until I
Xchecked the source code two weeks ago, I assumed that 2x damage meant 2x
Xdamage, so that a blow which would have done 15 would do 45 if the
Xweapon was SU.  I proposed this change in order to keep the actual
Xeffects, rather than the multipliers, comparable.
X
X>On the other hand, reducing the pluses for EGO weapons
X>seems less confusing since it won't obsolete the spoilers list and is less
X>noticable to the players.  I would like a good reason before making your
X>change; I will have to think about this.  A change of this magnutude
X>should probably include a change to the minor version number, i.e. 5.3.0
X>to make it easier to remember where the change occurs.
X
XIf the pluses for ego weapons are reduced, the effect won't be that
Xgreat, because you can always enchant an ego weapon up to about +8.
XAlso, strength and ring of increase damage bonuses will still be
Xmultiplied.
X
XIn particular, SU and SD will become much more powerful no matter what
Xis done.  A typical SD, say 2d6, +8, does 15 normally, 36 to dragons,
Xunder the old system.  It would do 36 to dragons under the new system
Xeven if its damage bonus were reduced to +2 (adding -3 instead of +3
Xwhen the ego weapon was generated), and at +2, it would be very easy to
Xenchant.  And this does not even consider the fact that SD weapons are
Xusually wielded by players who have high strength and damage bonuses
Xfrom other items.
X
XIt would be possible just to weaken ego weapons by removing all of their
Xextra bonuses to hit and damage, except for DF's, which aren't helped by
Xthe change at all and thus should keep their bonuses, and HA's, which
Xmight keep +2 to hit and +2 to damage.  This would still strengthen all
Xego weapons except DF's significantly.  We might compensate for such a
Xchange by removing the 3/2 multiplier for the chance of ego weapons, but
Xwe have still given a great reward to the player who finds a HA.
X
XThe only sensible alternative I can see is to leave the old system for
Xcalculating damage, and to compute the added damage bonus with my
Xfunction, then multiply for ego weapons and critical hits, and then add
Xin the added damage bonus.
X
X>Also, your patch makes it much harder for people to figure out how two
X>weapons compare, because the damage formula is now more complicated,
X>and can not be easily calculated from the info available on screen.
X>Fixing the damage shown by the 'C' command would help, that should be easy.
X
XThe damage should probably be displayed as
X
XDamage Bonus: +8(+12)
X
Xwith the +8 the sum of all your bonuses, and the +12 the rounded-off
Xbonus as it applies to the average damage of your current weapon (or
Xto 1d1 if you have no weapon wielded).
X
X>Or maybe use a simpler formula, for example a +1 weapons does 10% more
X>damage than normal (minimum of 1 extra damage point), and a +10 weapon
X>does twice normal damage, although this is probably far too much of a
X>difference between light and heavy weapons.
X
XI thought of this before, and rejected it because this had too great an
Xeffect on daggers.  That's why I included the 2-point offset, so that a
X+9 weapon doubles the quantity (damage+2).
X
XDavid Grabiner, grabiner@zariski.harvard.edu
X"We are sorry, but the number you have dialed is imaginary."
X"Please rotate your phone 90 degrees and try again."
XDisclaimer: I speak for no one and no one speaks for me...
X
END_OF_FILE
if test 10400 -ne `wc -c <'misc/damage.chg'`; then
    echo shar: \"'misc/damage.chg'\" unpacked with wrong size!
fi
# end of 'misc/damage.chg'
fi
if test -f 'misc/wex.msg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/wex.msg'\"
else
echo shar: Extracting \"'misc/wex.msg'\" \(10662 characters\)
sed "s/^X//" >'misc/wex.msg' <<'END_OF_FILE'
XFrom @MCC.COM:wex@MCC.COM Tue Sep 29 07:05:44 1987
XReceived: from MCC.COM by ji.Berkeley.EDU (5.58/1.25)
X	id AA07225; Tue, 29 Sep 87 07:05:40 PDT
XReceived: from milano.SW.MCC.COM by MCC.COM with TCP; Tue 29 Sep 87 09:06:24-CDT
XReceived: from banzai-inst by milano.SW.MCC.COM (5.52/STP1.51) 
X	id AA19878; Tue, 29 Sep 87 09:05:12 CDT
XDate: Tue, 29 Sep 87 09:04:58 CDT
XFrom: Buckaroo Banzai <wex@MCC.COM>
XMessage-Id: <8709291404.AA11679@banzai-inst.SW.MCC.COM>
XReceived: by banzai-inst.SW.MCC.COM (3.2/STP1.14) 
X	id AA11679; Tue, 29 Sep 87 09:04:58 CDT
XTo: wilson@ji.Berkeley.EDU
XIn-Reply-To: James E. Wilson's message of Mon, 28 Sep 87 20:11:15 PDT <8709290311.AA03868@ji.Berkeley.EDU>
XSubject: UNIX Moria
XStatus: RO
X
XNo, I haven't looked at your sources yet.  There are some serious bugs
Xin the original, which I hope you caught (naturally, I didn't keep a
Xlist of them :-( ).  I, too, corrected the zillions of spelling
Xmistakes.  Mine doesn't pass lint or run on SYS V.  I haven't decided
Xhow to deal with the rogue-ists who want to use h,j,k,l, etc.
X
XI do have a help program and an extended help library.  I've also made
Xsome changes to make the game better.  EG:
X
X   - you can now recover items from thieving monsters.
X
X   - when monsters drop treasures, they are dropped where the player
X   can recover them, instead of inside walls.
X
X   - priests' spells are a little better - they now have
X   Word-Of-Recall as a high-level spell.
X
X   - breath weapons, fireballs, etc. now affect everyone in the blast
X   radius, including the player and monsters.
X
X   - monsters are now a little smarter about which spells they use (eg
X   no fireballs from range 1; no teleport-to-me spells from range 1).
X
X   - a number of useful hints/noises have been added (eg. a
X   multiplying monster now goes 'POP'; some potions have helpful
X   messages - not giveaways; just enough so that they don't all appear
X   to be no-ops).
X
X   - there are error traps and messages (eg lots of places where there
X   was no 'default' case on a switch) so that the game doesn't do
X   funny things.
X
X   - the shops' inventories have been fixed up so that more and more-
X   useful items are available  (shop inventories can now be multiple
X   pages instead of just two).
X
X   - there's a Yes/No prompt for accepting a character or re-rolling.
X
X   - the save file is expanded so that the monster list is kept; as it
X   was, you could escape a monster by saving and restoring.
X
X   - there was a bug whereby if you were carrying 10 +2,+2 arrows and
X   picked up 10 +0,+0 arrows you'd end up with 20 +2,+2 arrows.
X   That's fixed.  There was a bug whereby if you ever got too many
X   treasures on a level, the game could go into an infinite loop.
X
XThere are others, but I can't remember them off the top.  I assume the
Xmoria files are on ji.berkeley.edu?  What directory?
X
X--Alan
X
XFrom @MCC.COM:wex@MCC.COM Tue Sep 29 12:12:25 1987
XReceived: from MCC.COM by ji.Berkeley.EDU (5.58/1.25)
X	id AA10246; Tue, 29 Sep 87 12:12:21 PDT
XReceived: from milano.SW.MCC.COM by MCC.COM with TCP; Tue 29 Sep 87 14:12:48-CDT
XReceived: from banzai-inst by milano.SW.MCC.COM (5.52/STP1.51) 
X	id AA22469; Tue, 29 Sep 87 14:08:46 CDT
XDate: Tue, 29 Sep 87 14:08:33 CDT
XFrom: Buckaroo Banzai <wex@MCC.COM>
XMessage-Id: <8709291908.AA12132@banzai-inst.SW.MCC.COM>
XReceived: by banzai-inst.SW.MCC.COM (3.2/STP1.14) 
X	id AA12132; Tue, 29 Sep 87 14:08:33 CDT
XTo: wilson@ji.Berkeley.EDU
XIn-Reply-To: James E. Wilson's message of Tue, 29 Sep 87 11:11:15 PDT <8709291811.AA09240@ji.Berkeley.EDU>
XSubject: UNIX Moria
XStatus: RO
X
XIn some ways, I've made the game "easier," but I think it's more
Xbalanced.  EG: there's zillions of monsters that drain ST, DX, CO, so
XI made elven waybread restore those things.  I also found that priest
Xhad a huge advantage with Sense Invisible, so I made a Ring of See
XInvisible available in the Mages' shop.  (Of course, it's still
Xrandom, so it doesn't appear most of the time, but there's a chance.)
XThere are a couple of other minor tweaks like that.
X
XThe reroll-character option was the first request I got from my
Xplaytesters.  I sort of agree - some days I want to play a mage and
Xit's stupid for me to have to quit lots of games.
X
XAnother *major* change:  I've improved the scoring algorithm.  It used
Xto count just gold and exp.  Now I add in a bunch of other things.
XThe total score is higher, and the overall effect is to reward smart
Xplay (eg if you've spent all your gold to improve your weapon to +4,+4
XI now recognize and reward that as if you still had the gold).
X
XWe should get together and merge our ideas if possible, no?
X
X--Alan
X
XFrom @MCC.COM:wex@MCC.COM Wed Sep 30 09:02:55 1987
XReceived: from MCC.COM by ji.Berkeley.EDU (5.58/1.25)
X	id AA21194; Wed, 30 Sep 87 09:02:52 PDT
XReceived: from milano.SW.MCC.COM by MCC.COM with TCP; Wed 30 Sep 87 11:02:14-CDT
XReceived: from banzai-inst by milano.SW.MCC.COM (5.52/STP1.51) 
X	id AA12165; Wed, 30 Sep 87 11:02:08 CDT
XDate: Wed, 30 Sep 87 11:01:54 CDT
XFrom: Buckaroo Banzai <wex@MCC.COM>
XMessage-Id: <8709301601.AA14128@banzai-inst.SW.MCC.COM>
XReceived: by banzai-inst.SW.MCC.COM (3.2/STP1.14) 
X	id AA14128; Wed, 30 Sep 87 11:01:54 CDT
XTo: wilson@ji.Berkeley.EDU
XIn-Reply-To: James E. Wilson's message of Tue, 29 Sep 87 14:05:51 PDT <8709292105.AA11513@ji.Berkeley.EDU>
XSubject: UNIX Moria
XStatus: RO
X
XGot the files transferred and compiled.  You haven't reorganized them,
XI see.  I got bloody tired of trying to figure out which routines were
Xin what file (main, moria1, moria2, misc1, misc2?? - BLEAH) and
Xrestructured the code into more logical modules.  The sizes even out
Xbetter, too.
X
XYou also seem to have the problem that's been plaguing me - monsters
Xaren't always visible when they ought to be, especially in dark rooms
Xand corridors.  I think there's something wrong in draw_block().
XDrat!  I was hoping you'd solved that one.
X
XCan I transfer you a copy of my code so you can see what I've done?
XI can also ship you the help files and program that runs on them.
X
XAlso, how do I get into wizard mode on your moria?  ^p doesn't seem to
Xdo it, as it does on mine.
X
X--Alan
X
X
XFrom @MCC.COM:wex@MCC.COM Wed Sep 30 15:19:08 1987
XReceived: from MCC.COM by ji.Berkeley.EDU (5.58/1.25)
X	id AA25694; Wed, 30 Sep 87 15:19:04 PDT
XReceived: from milano.SW.MCC.COM by MCC.COM with TCP; Wed 30 Sep 87 17:18:31-CDT
XReceived: from banzai-inst by milano.SW.MCC.COM (5.52/STP1.51) 
X	id AA20759; Wed, 30 Sep 87 17:18:27 CDT
XDate: Wed, 30 Sep 87 17:18:12 CDT
XFrom: Buckaroo Banzai <wex@MCC.COM>
XMessage-Id: <8709302218.AA16205@banzai-inst.SW.MCC.COM>
XReceived: by banzai-inst.SW.MCC.COM (3.2/STP1.14) 
X	id AA16205; Wed, 30 Sep 87 17:18:12 CDT
XTo: wilson@ji.Berkeley.EDU
XIn-Reply-To: James E. Wilson's message of Wed, 30 Sep 87 11:21:20 PDT <8709301821.AA23038@ji.Berkeley.EDU>
XSubject: UNIX Moria
XStatus: RO
X
XHokay - the files are in place.  The source file is pretty massive; I
Xhad to segment it into three pieces in order to fit it through our
Xgateway machine.  Just cat the segments together before unsharing.
XIt's not compressed or anything.
X
XThe best thing to do is copy all the shar files to the directory you
Xwant to install in, then unshar moria.shar first.  There's a README
Xthat explains how to compile and install.  The wizard passwords are a
Xlittle hidden (just enough so that someone with the strings program
Xcan't find them easily).  They are DeadlyBalrog and MoriaDungeon.
XCapitals count, no carriage return needed.
X
X--Alan
X
XFrom @MCC.COM:wex@MCC.COM Wed Sep 30 11:35:53 1987
XReceived: from MCC.COM by ji.Berkeley.EDU (5.58/1.25)
X	id AA23167; Wed, 30 Sep 87 11:35:49 PDT
XReceived: from milano.SW.MCC.COM by MCC.COM with TCP; Wed 30 Sep 87 13:35:31-CDT
XReceived: from banzai-inst by milano.SW.MCC.COM (5.52/STP1.51) 
X	id AA17587; Wed, 30 Sep 87 13:35:26 CDT
XDate: Wed, 30 Sep 87 13:35:12 CDT
XFrom: Buckaroo Banzai <wex@MCC.COM>
XMessage-Id: <8709301835.AA14738@banzai-inst.SW.MCC.COM>
XReceived: by banzai-inst.SW.MCC.COM (3.2/STP1.14) 
X	id AA14738; Wed, 30 Sep 87 13:35:12 CDT
XTo: wilson@ji.Berkeley.EDU
XIn-Reply-To: James E. Wilson's message of Wed, 30 Sep 87 11:21:20 PDT <8709301821.AA23038@ji.Berkeley.EDU>
XSubject: UNIX Moria
XStatus: RO
X
X> >You also seem to have the problem that's been plaguing me - monsters
X> >aren't always visible when they ought to be, especially in dark rooms
X> >and corridors.  I think there's something wrong in draw_block().
X> >Drat!  I was hoping you'd solved that one.
X> I have never noticed this.  Could you be a little more specific?
X> How can I reproduce this?
X
XGo to any dark room (preferrably with a human character so infravision
Xdoesn't mess things up) and wander around.  Sometimes you'll be right
Xnext to a monster but be unable to see it.  It also happens in
Xcorridors, if you bump into a monster unexpectedly.  You get messages
Xlike "You hit it," when you should get messages with the monster's
Xname.
X
XI've tracked the problem down to the 'ml' field in the monster record.
XY'see, draw_block() redraws the area around the player, but doesn't
Xalways set that field when it should.  I'd like to find a VMS version
Xto play with and see if it works, but I haven't been able to get the
XVMS code I have to run, and I don't know the wizard passwords for it
Xeither :-(
X
XRe: passwords.  Nope.  I just went back and tried again - ^p and ^P
Xdon't ask for the password.  I've compiled it on my Sun3 - have you
Xtried it on that machine yet?
X
X> >The rogue-command interface is really kludgey - I'm going to hold off
X> >installing that in my code for a while.
X> Yeah, sort of, but it IS nice if you don't have a numeric keypad.
X
XI guess.  it didn't take me long to adjust, but then I don't play
Xrogue/hack much anymore.  I'm thinking of including a patch to handle
Xthe Sun's keypad (which generates weird escape-strings).
X
X> The signals are some of the most important code.  I never would have
X> gotten any serious playtesters if they lost games due to bugs.
X> I had some people fighting the Balrog even with buggy versions of the
X> game, because they did not have to start all over again every time the
X> program crashed.  (anecdotal evidence: my first game of xconq was lost
X> due to a floating point exception, I immediately added signal handlers
X> to save games before core dumping, this proved useful during my second game :-)
X
XI guess.  I was too embarrassed to let other people use the code while
Xit crashed like that.  For myself, I just used wizard mode and dbx to
Xregenerate games that got blown away by bugs.  Want to ship me your
Xdiffs to xconq?  I'm getting tired of having it core dump on me all
Xthe time.
X
XI will try putting my files on ucbarpa and let you know when they're
Xthere.
X
X--Alan
X
END_OF_FILE
if test 10662 -ne `wc -c <'misc/wex.msg'`; then
    echo shar: \"'misc/wex.msg'\" unpacked with wrong size!
fi
# end of 'misc/wex.msg'
fi
if test -f 'source/config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/config.h'\"
else
echo shar: Extracting \"'source/config.h'\" \(9787 characters\)
sed "s/^X//" >'source/config.h' <<'END_OF_FILE'
X/* source/config.h: configuration definitions
X
X   Copyright (c) 1989-92 James E. Wilson
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#define CONFIG_H_INCLUDED
X#ifdef CONSTANT_H_INCLUDED
XConstant.h should always be included after config.h, because it uses
Xsome of the system defines set up here.
X#endif
X
X/* Person to bother if something goes wrong.  */
X/* Recompile files.c and misc2.c if this changes.  */
X#define WIZARD	"David Grabiner"
X/* The wizard password and wizard uid are no longer used.  */
X
X
X/* System definitions.  You must define one of these as appropriate for
X   the system you are compiling moria on.  */
X
X/* No system definition is needed for 4.3BSD, SUN OS, DG/UX.  */
X
X/* If you are compiling on an ultrix/4.2BSD/Dynix/etc. version of UNIX,
X   define this.  It is not needed for SUNs.  */
X/* #ifndef ultrix
X#define ultrix
X#endif */
X
X/* If you are compiling under IBM's AIX 3.0, then you can either define
X   SYS_V, or you can define nothing (thus compiling as if on a BSD system)
X   but you must comment out the AIX LFLAG line in the Makefile so that
X   moria will be linked with -lbsd.  */
X
X/* If you are compiling on a SYS V version of UNIX, define this.  */
X/* #define SYS_V */
X
X/* If you are compiling on a SYS III version of UNIX, define this.
X   The SYS_III support may not be complete.  I do not know if this works.  */
X/* #define SYS_III */
X
X/* If you are compiling on an ATARI ST with Mark Williams C, define this.  */
X/* #define ATARIST_MWC */
X
X/* If you are compiling on an Atari ST with GCC, you do not need to define
X   anything.  */
X
X/* If you are compiling on an Atari ST with TC, define this.  */
X/* #define ATARIST_TC */
X
X/* If you are compiling on a Macintosh with MPW C 3.0, define this.  */
X/* #define MAC */
X
X/* If we are in Think C, then we must be on a mac.  */
X#ifdef THINK_C
X#define MAC
X#endif
X
X/* For Xenix systems, define SYS_V and unix.  */
X#ifdef M_XENIX
X#define SYS_V
X#define unix
X#endif
X
X/* If you are compiling under VMS, define this.  */
X/* #define VMS */
X
X/* If you are using the tcio.c file instead of io.c, then define this.
X   The tcio.c file uses TURBO C builtin functions instead of curses library
X   calls.  It only works if you are using TURBO C.
X   The default is to assume you are using it if you are using TURBO C
X   on an IBM-PC.  */
X#if defined(MSDOS) && defined(__TURBOC__)
X#define USING_TCIO
X#endif
X
X
X/* Files used by moria, set these to valid pathnames for your system.  */
X
X#ifdef MSDOS
X/* Files which can be in a varying place */
X#define MORIA_SAV	moriasav
X#define MORIA_TOP	moriatop
X#define MORIA_MOR	"news"
X#define MORIA_TOP_NAME	"scores"
X#define MORIA_SAV_NAME	"MORIA.SAV"
X#define MORIA_CNF_NAME	"MORIA.CNF"
X#define MORIA_HELP	"roglcmds.hlp"
X#define MORIA_ORIG_HELP	"origcmds.hlp"
X#define MORIA_WIZ_HELP	"rwizcmds.hlp"
X#define MORIA_OWIZ_HELP	"owizcmds.hlp"
X#define MORIA_WELCOME	"welcome.hlp"
X#define MORIA_VER	"version.hlp"
X
X#else
X#ifdef MAC
X
X/* These files are concatenated into the data fork of the app */
X/* The names are retained to find the appropriate text */
X#define MORIA_MOR	"news"
X#define MORIA_HELP	"roglcmds.hlp"
X#define MORIA_ORIG_HELP	"origcmds.hlp"
X#define MORIA_WIZ_HELP	"rwizcmds.hlp"
X#define MORIA_OWIZ_HELP	"owizcmds.hlp"
X#define MORIA_WELCOME	"welcome.hlp"
X#define MORIA_VER	"version.hlp"
X/* Do not know what will happen with these yet */
X#define MORIA_TOP	"Moria High Scores"
X/* File types and creators for the Mac */
X#define MORIA_FCREATOR	'MRIA'
X#define SAVE_FTYPE	'SAVE'
X#define INFO_FTYPE	'TEXT'
X#define SCORE_FTYPE	'SCOR'
X#define CONFIG_FTYPE	'CNFG'
X
X/* Options for building resources:
X   THINK C doesn't have -D switch, so we need to define this stuff here.
X   Uncomment RSRC when building DumpRes1 or DumpRes2; uncomment RSRC_PARTn
X   as appropriate.  When building application, comment all of them.
X   I don't think any of this is necessary for MPW C -- BS.  */
X#ifdef THINK_C
X/* #define RSRC */	/* This copy is for creating resources.  */
X
X/* THINK C can only take 32K data, so we need to dump the resources in
X   two parts.  */
X/* #define RSRC_PART1 */
X/* #define RSRC_PART2 */
X#endif
X
X#else
X
X#ifdef VMS
X#define MORIA_SAV	"moria.sav"
X/* These 3 files need a dot at the end to prevent VMS from deciding that
X   they are *.DAT files or anything else equally wierd. */
X#define MORIA_HOU	"moria:hours."
X#define MORIA_MOR	"moria:news."
X#define MORIA_TOP	"moria:scores."
X#define MORIA_HELP	"moria:roglcmds.hlp"
X#define MORIA_ORIG_HELP "moria:origcmds.hlp"
X#define MORIA_WIZ_HELP  "moria:rwizcmds.hlp"
X#define MORIA_OWIZ_HELP "moria:owizcmds.hlp"
X#define MORIA_WELCOME	"moria:welcome.hlp"
X#define MORIA_VER	"moria:version.hlp"
X
X#else
X
X#ifdef AMIGA
X#define MORIA_SAV 	"moria.sav"
X#define MORIA_HOU	"moria:hours"
X#define MORIA_MOR	"moria:news"
X#define MORIA_TOP	"moria:scores"
X#define MORIA_HELP	"moria:roglcmds.hlp"
X#define MORIA_ORIG_HELP "moria:origcmds.hlp"
X#define MORIA_WIZ_HELP  "moria:rwizcmds.hlp"
X#define MORIA_OWIZ_HELP "moria:owizcmds.hlp"
X#define MORIA_WELCOME	"moria:welcome.hlp"
X#define MORIA_VER	"moria:version.hlp"
X
X#else
X#if defined(GEMDOS)
X/* Atari ST */
X#define MORIA_SAV	"moria.sav"
X#define MORIA_HOU	"files\\hours"
X#define MORIA_MOR	"files\\news"
X#define MORIA_TOP	"files\\scores"
X#define MORIA_HELP	"files\\roglcmds.hlp"
X#define MORIA_ORIG_HELP	"files\\origcmds.hlp"
X#define MORIA_WIZ_HELP	"files\\rwizcmds.hlp"
X#define MORIA_OWIZ_HELP	"files\\owizcmds.hlp"
X#define MORIA_WELCOME	"files\\welcome.hlp"
X#define MORIA_VER	"files\\version.hlp"
X
X#else
X#if defined(atarist) && defined(__GNUC__)
X/* atari-st compiled with gnu-c  */
X
X#define MORIA_SAV	"moria.save"
X#define MORIA_HOU	(char *)prefix_file("files/hours")
X#define MORIA_MOR	(char *)prefix_file("files/news")
X#define MORIA_TOP	(char *)prefix_file("files/scores")
X#define MORIA_HELP	(char *)prefix_file("files/roglcmds.hlp")
X#define MORIA_ORIG_HELP	(char *)prefix_file("files/origcmds.hlp")
X#define MORIA_WIZ_HELP	(char *)prefix_file("files/rwizcmds.hlp")
X#define MORIA_OWIZ_HELP	(char *)prefix_file("files/owizcmds.hlp")
X#define MORIA_WELCOME	(char *)prefix_file("files/welcome.hlp")
X#define MORIA_VER	(char *)prefix_file("files/version.hlp")
X
X#else
X
X/* This must be unix.  */
X#define MORIA_SAV	"moria.save"
X#define MORIA_HOU	"/home/zariski/grabiner/moria/files/hours"
X#define MORIA_MOR	"/home/zariski/grabiner/moria/files/news"
X#define MORIA_TOP	"/home/zariski/grabiner/moria/files/scores"
X#define MORIA_HELP	"/home/zariski/grabiner/moria/files/roglcmds.hlp"
X#define MORIA_ORIG_HELP	"/home/zariski/grabiner/moria/files/origcmds.hlp"
X#define MORIA_WIZ_HELP	"/home/zariski/grabiner/moria/files/rwizcmds.hlp"
X#define MORIA_OWIZ_HELP	"/home/zariski/grabiner/moria/files/owizcmds.hlp"
X#define MORIA_WELCOME	"/home/zariski/grabiner/moria/files/welcome.hlp"
X#define MORIA_VER	"/home/zariski/grabiner/moria/files/version.hlp"
X
X#endif
X#endif
X#endif
X#endif
X#endif
X#endif
X
X
X/* This sets the default user interface.  */
X/* To use the original key bindings (keypad for movement) set ROGUE_LIKE
X   to FALSE; to use the rogue-like key bindings (vi style movement)
X   set ROGUE_LIKE to TRUE.  */
X/* If you change this, you only need to recompile main.c.  */
X#define ROGUE_LIKE FALSE
X
X
X/* For the ANDREW distributed file system, define this to ensure that
X   the program is secure with respect to the setuid code, this prohibits
X   inferior shells.  It also does not relinquish setuid priviledges at the
X   start, but instead calls the ANDREW library routines bePlayer(), beGames(),
X   and Authenticate().  */
X/* #define SECURE */
X
X
X
X/* System dependent defines follow.  You should not need to change anything
X   below.  */
X
X#ifdef ATARIST_TC
X#define USG
X#include <stdio.h>	/* Needed for TC ...printf */
X#endif
X
X#if defined(ATARIST_TC) || defined(ATARIST_MWC)
X#define ATARI_ST
X#endif
X
X/* Substitute strchr for index on USG versions of UNIX.  */
X#if defined(SYS_V) || defined(MSDOS) || defined(MAC) || defined(VMS)
X#define index strchr
X#endif
X#ifdef ATARIST_TC
X#define index strchr
X#endif
X
X#ifdef SYS_III
Xchar *index();
X#endif
X
X/* Define USG for many systems, this is basically to select SYS V style
X   system calls (as opposed to BSD style).  */
X#if defined(SYS_III) || defined(SYS_V) || defined(MSDOS) || defined(MAC)
X#ifndef USG
X#define USG
X#endif
X#endif
X
X#if defined(ATARIST_MWC) || defined(AMIGA) || defined(VMS)
X#define USG
X#endif
X
X#ifdef AMIGA
X#ifndef ultrix
X#define ultrix
X#endif
X#endif
X
X/* Pyramid runs 4.2BSD-like UNIX version */
X#if defined(Pyramid)
X#define ultrix
X#endif
X
X#if defined(_MSC_VER) && (_MSC_VER < 600)
X#define register      /* MSC 4.0 still has a problem with register bugs ... */
X#endif
X
X#ifdef MAC
X#ifdef RSRC
X#define MACRSRC		/* Defined if we are building the resources.  */
X#else
X#define MACGAME		/* Defined if we are building the game.  */
X#endif
X#endif
X
X#ifdef MAC
X/* Screen dimensions */
X#define SCRN_ROWS	24
X#define SCRN_COLS	80
X#endif
X
X#ifdef VMS
X#define unlink delete
X#define index strchr
X#define exit uexit
X/* In constants.h, ESCAPE is defined to be the CTRL-Z key, instead of the
X   escape key.  */
X#endif
X
X#if defined(SYS_V) && defined(lint)
X/* Define this to prevent <string.h> from including <NLchar.h> on a PC/RT
X   running AIX.  This prevents a bunch of lint errors.  */
X#define RTPC_NO_NLS
X#endif
X
X#ifdef SECURE
Xextern int PlayerUID;
X#define getuid() PlayerUID
X#define geteuid() PlayerUID
X#endif
X
X#ifdef THINK_C
X/* Apparently, THINK C is only happy if this is defined.  This can not
X   be defined in general, because some systems have include files which
X   merely test whether STDC is defined, they do not test the value.  */
X/* Check how standard we are: Some code tests value of __STDC__.  */
X#ifndef __STDC__
X#define __STDC__	0
X#endif
X#endif
END_OF_FILE
if test 9787 -ne `wc -c <'source/config.h'`; then
    echo shar: \"'source/config.h'\" unpacked with wrong size!
fi
# end of 'source/config.h'
fi
if test -f 'source/wizard.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/wizard.c'\"
else
echo shar: Extracting \"'source/wizard.c'\" \(9196 characters\)
sed "s/^X//" >'source/wizard.c' <<'END_OF_FILE'
X/* source/wizard.c: Version history and info, and wizard mode debugging aids.
X
X   Copyright (c) 1989-92 James E. Wilson, Robert A. Koeneke
X
X   This software may be copied and distributed for educational, research, and
X   not for profit purposes provided that this copyright and statement are
X   included in all such copies. */
X
X#ifdef __TURBOC__
X#include	<stdio.h>
X#include	<stdlib.h>
X#endif /* __TURBOC__ */
X 
X#include "config.h"
X#include "constant.h"
X#include "types.h"
X#include "externs.h"
X
X#ifdef USG
X#ifndef ATARIST_MWC
X#include <string.h>
X#endif
X#else
X#include <strings.h>
X#endif
X
X#ifdef ATARIST_TC
X/* Include this to get prototypes for standard library functions.  */
X#include <stdlib.h>
X#endif
X
Xlong atol();
X
X/* Light up the dungeon					-RAK-	*/
Xvoid wizard_light()
X{
X  register cave_type *c_ptr;
X  register int k, l, i, j;
X  int flag;
X
X  if (cave[char_row][char_col].pl)
X    flag = FALSE;
X  else
X    flag = TRUE;
X  for (i = 0; i < cur_height; i++)
X    for (j = 0; j < cur_width; j++)
X      if (cave[i][j].fval <= MAX_CAVE_FLOOR)
X	for (k = i-1; k <= i+1; k++)
X	  for (l = j-1; l <= j+1; l++)
X	    {
X	      c_ptr = &cave[k][l];
X	      c_ptr->pl = flag;
X	      if (!flag)
X		c_ptr->fm = FALSE;
X	    }
X  prt_map();
X}
X
X
X/* Wizard routine for gaining on stats			-RAK-	*/
Xvoid change_character()
X{
X  register int tmp_val;
X  register int32 tmp_lval;
X  int8u *a_ptr;
X  vtype tmp_str;
X  register struct misc *m_ptr;
X
X  a_ptr = py.stats.max_stat;
X  prt("(3 - 118) Strength     = ", 0, 0);
X  if (get_string(tmp_str, 0, 25, 3))
X    {
X      tmp_val = atoi(tmp_str);
X      if ((tmp_val > 2) && (tmp_val < 119))
X	{
X	  a_ptr[A_STR] = tmp_val;
X	  (void) res_stat(A_STR);
X	}
X    }
X  else
X    return;
X
X  prt("(3 - 118) Intelligence = ", 0, 0);
X  if (get_string(tmp_str, 0, 25, 3))
X    {
X      tmp_val = atoi(tmp_str);
X      if ((tmp_val > 2) && (tmp_val < 119))
X	{
X	  a_ptr[A_INT] = tmp_val;
X	  (void) res_stat(A_INT);
X	}
X    }
X  else
X    return;
X
X  prt("(3 - 118) Wisdom       = ", 0, 0);
X  if (get_string(tmp_str, 0, 25, 3))
X    {
X      tmp_val = atoi(tmp_str);
X      if ((tmp_val > 2) && (tmp_val < 119))
X	{
X	  a_ptr[A_WIS] = tmp_val;
X	  (void) res_stat(A_WIS);
X	}
X    }
X  else
X    return;
X
X  prt("(3 - 118) Dexterity    = ", 0, 0);
X  if (get_string(tmp_str, 0, 25, 3))
X    {
X      tmp_val = atoi(tmp_str);
X      if ((tmp_val > 2) && (tmp_val < 119))
X	{
X	  a_ptr[A_DEX] = tmp_val;
X	  (void) res_stat(A_DEX);
X	}
X    }
X  else
X    return;
X
X  prt("(3 - 118) Constitution = ", 0, 0);
X  if (get_string(tmp_str, 0, 25, 3))
X    {
X      tmp_val = atoi(tmp_str);
X      if ((tmp_val > 2) && (tmp_val < 119))
X	{
X	  a_ptr[A_CON] = tmp_val;
X	  (void) res_stat(A_CON);
X	}
X    }
X  else
X    return;
X
X  prt("(3 - 118) Charisma     = ", 0, 0);
X  if (get_string(tmp_str, 0, 25, 3))
X    {
X      tmp_val = atoi(tmp_str);
X      if ((tmp_val > 2) && (tmp_val < 119))
X	{
X	  a_ptr[A_CHR] = tmp_val;
X	  (void) res_stat(A_CHR);
X	}
X    }
X  else
X    return;
X
X  m_ptr = &py.misc;
X  prt("(1 - 32767) Hit points = ", 0, 0);
X  if (get_string(tmp_str, 0, 25, 5))
X    {
X      tmp_val = atoi(tmp_str);
X      if ((tmp_val > 0) && (tmp_val <= MAX_SHORT))
X	{
X	  m_ptr->mhp  = tmp_val;
X	  m_ptr->chp  = tmp_val;
X	  m_ptr->chp_frac = 0;
X	  prt_mhp();
X	  prt_chp();
X	}
X    }
X  else
X    return;
X
X  prt("(0 - 32767) Mana       = ", 0, 0);
X  if (get_string(tmp_str, 0, 25, 5))
X    {
X      tmp_val = atoi(tmp_str);
X      if ((tmp_val > -1) && (tmp_val <= MAX_SHORT) && (*tmp_str != '\0'))
X	{
X	  m_ptr->mana  = tmp_val;
X	  m_ptr->cmana = tmp_val;
X	  m_ptr->cmana_frac = 0;
X	  prt_cmana();
X	}
X    }
X  else
X    return;
X
X  (void) sprintf(tmp_str, "Current=%ld  Gold = ", m_ptr->au);
X  tmp_val = strlen(tmp_str);
X  prt(tmp_str, 0, 0);
X  if (get_string(tmp_str, 0, tmp_val, 7))
X    {
X      tmp_lval = atol(tmp_str);
X      if (tmp_lval > -1 && (*tmp_str != '\0'))
X	{
X	  m_ptr->au = tmp_lval;
X	  prt_gold();
X	}
X    }
X  else
X    return;
X
X  (void) sprintf(tmp_str, "Current=%d  (0-200) Searching = ", m_ptr->srh);
X  tmp_val = strlen(tmp_str);
X  prt(tmp_str, 0, 0);
X  if (get_string(tmp_str, 0, tmp_val, 3))
X    {
X      tmp_val = atoi(tmp_str);
X      if ((tmp_val > -1) && (tmp_val < 201) && (*tmp_str != '\0'))
X	m_ptr->srh  = tmp_val;
X    }
X  else
X    return;
X
X  (void) sprintf(tmp_str, "Current=%d  (-1-18) Stealth = ", m_ptr->stl);
X  tmp_val = strlen(tmp_str);
X  prt(tmp_str, 0, 0);
X  if (get_string(tmp_str, 0, tmp_val, 3))
X    {
X      tmp_val = atoi(tmp_str);
X      if ((tmp_val > -2) && (tmp_val < 19) && (*tmp_str != '\0'))
X	m_ptr->stl  = tmp_val;
X    }
X  else
X    return;
X
X  (void) sprintf(tmp_str, "Current=%d  (0-200) Disarming = ", m_ptr->disarm);
X  tmp_val = strlen(tmp_str);
X  prt(tmp_str, 0, 0);
X  if (get_string(tmp_str, 0, tmp_val, 3))
X    {
X      tmp_val = atoi(tmp_str);
X      if ((tmp_val > -1) && (tmp_val < 201) && (*tmp_str != '\0'))
X	m_ptr->disarm = tmp_val;
X    }
X  else
X    return;
X
X  (void) sprintf(tmp_str, "Current=%d  (0-100) Save = ", m_ptr->save);
X  tmp_val = strlen(tmp_str);
X  prt(tmp_str, 0, 0);
X  if (get_string(tmp_str, 0, tmp_val, 3))
X    {
X      tmp_val = atoi(tmp_str);
X      if ((tmp_val > -1) && (tmp_val < 201) && (*tmp_str != '\0'))
X	m_ptr->save = tmp_val;
X    }
X  else
X    return;
X
X  (void) sprintf(tmp_str, "Current=%d  (0-200) Base to hit = ", m_ptr->bth);
X  tmp_val = strlen(tmp_str);
X  prt(tmp_str, 0, 0);
X  if (get_string(tmp_str, 0, tmp_val, 3))
X    {
X      tmp_val = atoi(tmp_str);
X      if ((tmp_val > -1) && (tmp_val < 201) && (*tmp_str != '\0'))
X	m_ptr->bth  = tmp_val;
X    }
X  else
X    return;
X
X  (void) sprintf(tmp_str, "Current=%d  (0-200) Bows/Throwing = ",
X		 m_ptr->bthb);
X  tmp_val = strlen(tmp_str);
X  prt(tmp_str, 0, 0);
X  if (get_string(tmp_str, 0, tmp_val, 3))
X    {
X      tmp_val = atoi(tmp_str);
X      if ((tmp_val > -1) && (tmp_val < 201) && (*tmp_str != '\0'))
X	m_ptr->bthb = tmp_val;
X    }
X  else
X    return;
X
X  (void) sprintf(tmp_str, "Current=%d  Weight = ", m_ptr->wt);
X  tmp_val = strlen(tmp_str);
X  prt(tmp_str, 0, 0);
X  if (get_string(tmp_str, 0, tmp_val, 3))
X    {
X      tmp_val = atoi(tmp_str);
X      if (tmp_val > -1 && (*tmp_str != '\0'))
X	m_ptr->wt = tmp_val;
X    }
X  else
X    return;
X
X  while(get_com("Alter speed? (+/-)", tmp_str))
X    {
X      if (*tmp_str == '+')
X	change_speed(-1);
X      else if (*tmp_str == '-')
X	change_speed(1);
X      else
X	break;
X      prt_speed();
X    }
X}
X
X
X/* Wizard routine for creating objects			-RAK-	*/
Xvoid wizard_create()
X{
X  register int tmp_val;
X  int32 tmp_lval;
X  vtype tmp_str;
X  register inven_type *i_ptr;
X  inven_type forge;
X  register cave_type *c_ptr;
X  char pattern[4];
X
X  msg_print("Warning: This routine can cause a fatal error.");
X  i_ptr = &forge;
X  i_ptr->index = OBJ_WIZARD;
X  i_ptr->name2 = 0;
X  inscribe(i_ptr, "wizard item");
X  i_ptr->ident = ID_KNOWN2|ID_STOREBOUGHT;
X
X  prt("Tval   : ", 0, 0);
X  if (!get_string(tmp_str, 0, 9, 3))
X    return;
X  tmp_val = atoi(tmp_str);
X  i_ptr->tval = tmp_val;
X
X  prt("Tchar  : ", 0, 0);
X  if (!get_string(tmp_str, 0, 9, 1))
X    return;
X  i_ptr->tchar = tmp_str[0];
X
X  prt("Subval : ", 0, 0);
X  if (!get_string(tmp_str, 0, 9, 5))
X    return;
X  tmp_val = atoi(tmp_str);
X  i_ptr->subval = tmp_val;
X
X  prt("Weight : ", 0, 0);
X  if (!get_string(tmp_str, 0, 9, 5))
X    return;
X  tmp_val = atoi(tmp_str);
X  i_ptr->weight = tmp_val;
X
X  prt("Number : ", 0, 0);
X  if (!get_string(tmp_str, 0, 9, 5))
X    return;
X  tmp_val = atoi(tmp_str);
X  i_ptr->number = tmp_val;
X
X  prt("Damage (dice): ", 0, 0);
X  if (!get_string(tmp_str, 0, 15, 3))
X    return;
X  tmp_val = atoi(tmp_str);
X  i_ptr->damage[0] = tmp_val;
X
X  prt("Damage (sides): ", 0, 0);
X  if (!get_string(tmp_str, 0, 16, 3))
X    return;
X  tmp_val = atoi(tmp_str);
X  i_ptr->damage[1] = tmp_val;
X
X  prt("+To hit: ", 0, 0);
X  if (!get_string(tmp_str, 0, 9, 3))
X    return;
X  tmp_val = atoi(tmp_str);
X  i_ptr->tohit = tmp_val;
X
X  prt("+To dam: ", 0, 0);
X  if (!get_string(tmp_str, 0, 9, 3))
X    return;
X  tmp_val = atoi(tmp_str);
X  i_ptr->todam = tmp_val;
X
X  prt("AC     : ", 0, 0);
X  if (!get_string(tmp_str, 0, 9, 3))
X    return;
X  tmp_val = atoi(tmp_str);
X  i_ptr->ac = tmp_val;
X
X  prt("+To AC : ", 0, 0);
X  if (!get_string(tmp_str, 0, 9, 3))
X    return;
X  tmp_val = atoi(tmp_str);
X  i_ptr->toac = tmp_val;
X
X  prt("P1     : ", 0, 0);
X  if (!get_string(tmp_str, 0, 9, 5))
X    return;
X  tmp_val = atoi(tmp_str);
X  i_ptr->p1 = tmp_val;
X
X  prt("Flags (In HEX): ", 0, 0);
X  if (!get_string(tmp_str, 0, 16, 8))
X    return;
X  /* can't be constant string, this causes problems with the GCC compiler
X     and some scanf routines */
X  (void) strcpy (pattern, "%lx");
X  (void) sscanf(tmp_str, pattern, &tmp_lval);
X  i_ptr->flags = tmp_lval;
X
X  prt("Cost : ", 0, 0);
X  if (!get_string(tmp_str, 0, 9, 8))
X    return;
X  tmp_lval = atol(tmp_str);
X  i_ptr->cost = tmp_lval;
X
X  prt("Level : ", 0, 0);
X  if (!get_string(tmp_str, 0, 10, 3))
X    return;
X  tmp_val = atoi(tmp_str);
X  i_ptr->level = tmp_val;
X
X  if (get_check("Allocate?"))
X    {
X      /* delete object first if any, before call popt */
X      c_ptr = &cave[char_row][char_col];
X      if (c_ptr->tptr != 0)
X	(void) delete_object(char_row, char_col);
X
X      tmp_val = popt();
X      t_list[tmp_val] = forge;
X      c_ptr->tptr = tmp_val;
X      msg_print("Allocated.");
X    }
X  else
X    msg_print("Aborted.");
X}
END_OF_FILE
if test 9196 -ne `wc -c <'source/wizard.c'`; then
    echo shar: \"'source/wizard.c'\" unpacked with wrong size!
fi
# end of 'source/wizard.c'
fi
echo shar: End of archive 32 \(of 39\).
cp /dev/null ark32isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 39 archives.
    echo "Now run "bldfiles.sh" to build split files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
