Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i087:  okbridge2 - computer-mediated bridge game, Part09/14
Message-ID: <3526@master.CNA.TEK.COM>
Date: 7 Sep 92 21:42:24 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1758
Approved: billr@saab.CNA.TEK.COM

Submitted-by: mclegg@cs.UCSD.EDU (Matthew Clegg)
Posting-number: Volume 14, Issue 87
Archive-name: okbridge2/Part09
Supersedes: okbridge: Volume 13, Issue 16-22
Environment: BSD-derived Unix, NeXT, curses, sockets



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 14)."
# Contents:  commands.h okbridge.help protocol.c
# Wrapped by billr@saab on Mon Sep  7 14:33:37 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'commands.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'commands.h'\"
else
echo shar: Extracting \"'commands.h'\" \(8888 characters\)
sed "s/^X//" >'commands.h' <<'END_OF_FILE'
X/* commands.h
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X * This module implements the commands which are available through the
X * input processor.
X *
X */
X
X/*
X *   /ALERT
X *     Alerts your partner's last bid.  If you are playing in FORMAL mode,
X *     the alert is displayed to your opponents only.  Otherwise, the alert
X *     will be displayed to everyone.  Same as ^A.
X *
X *   /ASSIGN <player-name> NORTH|EAST|SOUTH|WEST|OBS
X *     Assigns a player to a given seat.  Can only be used before the
X *     first hand has been dealt or between hands.
X *
X *   /BELL [ON|OFF]
X *     By default, the okbridge program rings the terminal's bell whenever
X *     it requests input from you.  However, this can be disabled by
X *     typing '/BELL OFF'.  The state of the bell can be toggled with ^G.
X *
X *   /CC [NS|EW|MY|BOTH]
X *     Displays the convention card of the specified team(s).
X *     By default, displays the convention card of the opponents.
X *
X *   /CLAIM [n]
X *     This command 'claims' n additional tricks for the declarer.
X *     If n is omitted, then all remaining tricks are claimed.
X *     The other players are shown the declarer's hand and are
X *     asked whether or not they agree to the declarer's request.
X *     If both agree, then the hand is ended early.  This command can
X *     be used only by the declarer and only when it is declarer's or
X *     dummy's turn to play.
X *
X *   /DEFAULT [ON | OFF]
X *     This command controls whether or not defaults will be provided
X *     for bids, plays and questions.  This mode can be toggled with ^D.
X *
X *   /DISCONNECT <player-name>
X *     Closes the connection to the named player.
X *     <player-name> can either be the name of a player (e.g., Worf)
X *     or the name of position (e.g., SOUTH).
X *
X *   /FORMAL [OFF|ON]
X *     Specifies whether formal playing rules will be used or queries which
X *     playing rules are currently use.  In formal play, talk messages
X *     are displayed only to the opponents, alerts are not displayed to the
X *     partner of the alerter, and the dummy is not revealed to anyone
X *     until the opening lead has been made.
X *
X *   /HELP [topic]
X *     Type '/HELP' alone to obtain general help, or type
X *     '/HELP topic' to obtain help about a particular topic.
X *
X *   /LHB <message>
X *     Sends a message to the person who appears to the left of you in the
X *     bidding display.  Same as the /RHO command.
X *
X *   /LHO <message>
X *     Sends a message to the person who will play or bid immediately
X *     after you.  Same as the /RHB command.
X *
X *   /LOG [filename]
X *     Typing '/LOG filename' causes this hand and subsequent hands
X *     to be written to the file with name 'filename'.  Omitting
X *     'filename' causes the current log file to be closed.
X *     Adding a plus sign '+' to the beginning of 'filename' causes
X *     the playing record to be appended to the end of the file.
X *
X *   /NAME <new-name>
X *     Changes your name to <new-name>.
X *
X *   /OPP <message>
X *     Sends a message which will be seen only by the opponents.
X *
X *   /PING
X *     Sends an invisible message to each of the other players, which is
X *     automatically echoed.  Reports the round-trip communication time.
X *
X *   /PROMPT [ON|OFF]
X *     By default, the dummy is asked to press RETURN after the end
X *     of each trick.  This allows the dummy to see each trick as
X *     it is played.  This prompting can be disabled by typing
X *     '/PROMPT OFF' (convenient if you need to run to the wc :-)
X *     The prompt mode can be toggled with ^P.
X *
X *   /QUIT
X *     Terminates the program.
X *
X *   /REVIEW
X *     Displays the bidding for review.  This is intended to be used
X *     during the playing mode.  This command can be abbreviated with ^B.
X *
X *   /REVEAL [<player-name> | NORTH | EAST | SOUTH | WEST | NE | NS | NW |
X *           SE | SW | EW]
X *     This command can only be used by an observer while others are playing.
X *     In this case, the observer enters SPECTATOR mode and the named hands
X *     are revealed.  In SPECTATOR mode, the observer can have complete
X *     information about the game, but may not talk.  SPECTATOR mode is
X *     not available in formal play.  If the name of the player is
X *     omitted, then all hands are revealed.
X *
X *   /RHB <message>
X *     Sends a message to the person who appears to the right of you in
X *     the bidding display.  Same as the /LHO command.
X *
X *   /RHO <message>
X *     Sends a message to the person who bids or plays immediately before
X *     you.  Same as the /LHB command.
X *
X *   /RESET
X *     Resets the program to its initial state.
X *
X *   /SCORE RUBBER|CHICAGO|DUPLICATE|EMAIL|IMP
X *     Selects a scoring mode.  Can only be used before the first hand
X *     has been dealt or between hands.
X *
X *   /SEAT NORTH|EAST|SOUTH|WEST|OBS
X *   /EAST, /NORTH, /OBS, /OBSERVER, /SOUTH, /WEST
X *     Selects a seat.  Can only be used before the first hand or between
X *     hands.  Only one person may sit in the seats north, east, south, west,
X *     but there may be many observers.
X *
X *   /SETCC [<your-convention-card>]
X *     Enters one line of text as your convention card.  This card will
X *     then be announced to your partner and the opponents as the convention
X *     card for your team.  Omitting convention card from this command will
X *     cause your current convention card to be announced to your partner
X *     and opponents.
X *
X *   /SKIP
X *     Ends the current hand immediately, without recording a score for it.
X *     This command is useful in case the connection to one of the
X *     players is lost.
X *
X *   /SPEC [<player-name> | NORTH | EAST | SOUTH | WEST | NE | NS | NW |
X *         SE | SW | EW]
X *     Enters SPECTATOR mode.  In SPECTATOR mode, an observer can see the
X *     hands of the players, but the spectator is not allowed to talk.
X *     The parameters identify the hand(s) which are to be revealed to
X *     the spectator.  SPECTATOR mode is not available during formal play.
X *     (This command is actually the same as the /REVEAL command.)
X *
X *   /TALK message
X *     Sends a short message to the other players.  This command can be used
X *     when the program is waiting for you to enter a bid or a play.
X *     Not needed if the word 'TALK' is displayed to the left of the cursor.
X *
X *   /TIMER [ON|OFF]
X *     Controls whether or not the timer will displayed after each
X *     bid and play.
X *
X *   /WAKEUP [<player-name> | ALL]
X *     Sends a wakeup signal to the named player, or to all players if
X *     "ALL" is specified.  The wakeup signal rings the terminal bell and
X *     prints the words "WAKE UP" in the talk box.  If the name of the
X *     player is omitted, then the signal is sent to your partner.
X *
X *   /WHO
X *     Gives a short list of the other players and their respective seats.
X *
X *   /WHOIS [<player-name>]
X *     Inquires about a specific player.  If the player has listed his/her
X *     full name and email address in the .okbridgerc file, then this
X *     information is given.  If <player-name> is omitted, then inquires
X *     about both of the opponents.
X *
X *   /ZLOG [filename]
X *     This command is similar to the /LOG command in that it also opens
X *     a log file, but the format of the log file is more compact.
X *
X */
X
Xvoid Parse_Input_Command ();
X/* Parses the command contained in the buffer command_buf and executes
X   the corresponding command.  If an error occurs, then displays an
X   appropriate message in the status line. 
X*/
X
Xint Parse_Server_Command ();
X/* void Parse_Server_Command (void *command_buf); */
X/* On entry, command_buf should contain a special request to the server
X   made by a client.  Parses the command and executes it.  Returns 0 if
X   the command was parsed correctly, and 1 if an error occurs.  In the
X   latter case, the error message is placed in the Parser_Error_Buf.
X*/
X
X/* The following procedures are made visible because they can be invoked
X   by control characters: */
X
Xvoid Review_Bidding ();
X/* Generates a review of the bidding. */
X
Xvoid Wakeup_player ();
X/* Sends a wakeup message to the named player. */
X
X
END_OF_FILE
if test 8888 -ne `wc -c <'commands.h'`; then
    echo shar: \"'commands.h'\" unpacked with wrong size!
fi
# end of 'commands.h'
fi
if test -f 'okbridge.help' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'okbridge.help'\"
else
echo shar: Extracting \"'okbridge.help'\" \(23044 characters\)
sed "s/^X//" >'okbridge.help' <<'END_OF_FILE'
X# okbridge.help -- help file for the okbridge program
X#  
X# Copyright (C) 1990-1992 by Matthew Clegg
X#
X# This program may be copied and distributed freely, provided that this
X# is not done for commercial advantage.  Neither this program nor any of its
X# derivatives may be distributed or used in any way for commercial
X# advantage without the explicit written permission of Matthew Clegg.
X# If you modify this program, then include a notice stating plainly that
X# your program is derived from the okbridge program and is not the same
X# as the original okbridge program.
X#
X# Use this program at your own risk.  I cannot accept responsibility for
X# for any damage which may be attributable by this program.
X# 
X# I welcome any suggestions for improvement, and I would be especially
X# happy to receive improved source code.  If you have comments or
X# suggestions, or if you would like to join the okbridge mailing list,
X# then write to
X#
X#   mclegg@cs.ucsd.edu
X# 
X#
X# The help information in this file is organized as a series of topics.
X# The first entry in the file is interpreted to be the main topic, 
X# i.e., it is the entry which is displayed if no particular keyword 
X# is given.  Each topic entry has a header line which contains an 
X# identifying keyword and a descriptive phrase.  This is followed 
X# by the body of the entry and is terminated by an end-of-entry line.  
X#
X# The format of an entry is
X#
X# <keyword> <phrase>
X# help text
X# more help text
X# ...
X# last help text
X# --
X#
X# Comment lines such as this one are not printed in the help display.
X# A page break is given by placing the '^' character on a line by itself.
X#
Xmain      	A general description of the program
X
X                    Welcome to OKBRIDGE, version 1.7
X 
X
X     This is a computer-moderated bridge program.  It allows four
Xpeople at different locations on the Internet to play bridge together.
XThe computer shuffles the cards and communicates bids and plays between
Xthe players.
X
X     The help system is organized as a series of topics, each
Xidentified by a keyword.  To obtain information on a particular topic,
Xjust type '/HELP topic'.  If this is your first time playing okbridge,
Xthen you may wish to take a look at the "starting" topic.
X 
X     Good luck at the bridge table!
X
X--
Xbidding 	information on how to enter a bid
X
X		      Information about Bidding
X                      ----------- ----- -------
X
XThe format of a bid is one of the following:
X
X     <level> <trump>
X     DOUBLE               (or X)
X     REDOUBLE             (or XX)
X     PASS                 (or P)
X
Xwhere 
X     <level> is either 1, 2, 3, 4, 5, 6, or 7
X     <suit>  is one of C, D, H, S, N or NT.
X
XThere should be no space between the <level> and the <suit>.
XYou may alert your own bids by typing an exclamation mark "!" after the bid.
XThe alert will be displayed to the opponents but not to your partner.
X
Xexamples
X     P, 1C!, 1S, 1N, 1NT, X!, DOUBLE, XX, 2c!, 4nt!
X--
Xcommands  	Commands for controlling the program
X
X     /ALERT
X       Alerts your partner's last bid.  If you are playing in FORMAL mode,
X       the alert is displayed to your opponents only.  Otherwise, the alert
X       will be displayed to everyone.  Same as ^A.
X
X     /AUTOPASS [ON|OFF]
X       During PRACTICE mode, this command controls whether or not PASS 
X       bids are automatically supplied by the moderator for absent players.  
X
X     /BELL [ON|OFF]
X       By default, the okbridge program rings the terminal's bell whenever
X       it requests input from you.  However, this can be disabled by
X       typing '/BELL OFF'.  The state of the bell can be toggled with ^G.
X
X     /CC [NS|EW|MY|BOTH]
X       Displays the convention card of the specified team(s).
X       By default, displays the convention card of the opponents.
X
X     /CCDEF [<Concention Card Name>] [<Convention-Card>]
X       Stores or displays a named convention card in the internal database.
X^
X     /CLS
X       Clears the talk window.
X
X     /CLAIM [n]
X       This command 'claims' n additional tricks for the declarer.
X       If n is omitted, then all remaining tricks are claimed.
X       The other players are shown the declarer's hand and are
X       asked whether or not they agree to the declarer's request.
X       If both agree, then the hand is ended early.  This command can
X       be used only by the declarer.
X
X     /CONNECT <server_ip> [<port-number>]
X       Attempts to connect to a server at the given address and port.
X       If the port number is omitted, 1729 is assumed.
X
X     /DEFAULT [ON | OFF]
X       This command controls whether or not defaults will be provided
X       for bids, plays and questions.  This mode can be toggled with ^D.
X
X     /EMAIL <your-email-address>
X       Specifies your email address for display to other players.
X^
X     /FULLNAME <your-full-name>
X       Specifies your full name for display to other players.
X
X     /HELP [topic]
X       Type '/HELP' alone to obtain general help, or type
X       '/HELP topic' to obtain help about a particular topic.
X
X     /LHB <message>
X       Sends a message to the person who appears to the left of you in the
X       bidding display.  Same as the /RHO command.
X
X     /LHO <message>
X       Sends a message to the person who will play or bid immediately
X       after you.  Same as the /RHB command.
X
X     /LOAD <filename>
X       Loads a set of email duplicate boards from the given file.
X       Begins playing the first board in the file.
X^
X     /LOG [filename]
X       Typing '/LOG filename' causes this hand and subsequent hands
X       to be written to the file with name 'filename'.  Omitting
X       'filename' causes the current log file to be closed.
X       Adding a plus sign '+' to the beginning of 'filename' causes
X       the playing record to be appended to the end of the file.
X
X     /NAME <new-name>
X       Changes your name to <new-name>
X
X     /OPP <message>
X       Sends a message which will be seen only by the opponents.
X
X     /PAUSE
X       During play, uses the entire screen for a talk window.
X
X     /PING
X       Sends an invisible message to each of the other players, which is
X       automatically echoed.  Reports the round-trip communication time.
X^
X     /PRACTICE [ON|OFF]
X       Enters PRACTICE playing mode.  In this mode, two or three players
X       can practice their bidding and play.  OKbridge will automatically
X       generate "PASS" bids for absent players.  During the play, the
X       hands will be revealed to all of the players for discussion and play.
X
X     /PROMPT [ON|OFF]
X       By default, the dummy is asked to press RETURN after the end
X       of each trick.  This allows the dummy to see each trick as
X       it is played.  This prompting can be disabled by typing
X       '/PROMPT OFF' (convenient if you need to run to the wc :-)
X       The prompt mode can be toggled with ^P.
X
X     /QUIT
X       Terminates the program.
X
X     /REPLAY <replay-file>
X       Loads a set of email duplicate boards from the specified file
X       and begins playing them.  After the last board has been played,
X       saves the boards along with the results of play back to the
X       same file.
X^
X     /REVIEW
X       Displays the bidding for review.  This is intended to be used
X       during the playing mode.  This command can be abbreviated with ^B.
X
X     /RHB <message>
X       Sends a message to the person who appears to the right of you in
X       the bidding display.  Same as the /LHO command.
X
X     /RHO <message>
X       Sends a message to the person who bids or plays immediately before
X       you.  Same as the /LHB command.
X
X     /SAVE [<filename>]
X       Saves the boards which have been played (and/or downloaded) in
X       email duplicate format to the given file.  If the filename is
X       omitted, then saves the boards to the file last specified in a
X       /LOAD command.
X^
X     /SEAT NORTH|EAST|SOUTH|WEST|OBS
X     /EAST, /NORTH, /OBS, /OBSERVER, /SOUTH, /WEST
X       Selects a seat.  Can only be used before the first hand or between
X       hands.  Only one person may sit in the seats north, east, south, west,
X       but there may be many observers.
X
X     /SETCC [<your-convention-card>|<convention-card-name>]
X       Enters one line of text as your convention card.  This card will
X       then be announced to your partner and the opponents as the convention
X       card for your team.  Omitting convention card from this command will
X       cause your current convention card to be announced to your partner
X       and opponents.  If you specify a single word convention card,
X       and this word is the name of a convention card previously specified
X       by the /CCDEF command, the convention card will be set to the card 
X       which corresponds to the name given.
X
X     /SPEC [<player-name> | NORTH | EAST | SOUTH | WEST | NE | NS | NW |
X           SE | SW | EW]
X       Enters SPECTATOR mode.  In SPECTATOR mode, an observer can see the
X       hands of the players, but the spectator is not allowed to talk.
X       The parameters identify the hand(s) which are to be revealed to
X       the spectator.  SPECTATOR mode is not available during formal play.
X^
X     /TALK message
X       Sends a short message to the other players.  This command can be used
X       when the program is waiting for you to enter a bid or a play.  
X       Not needed if the word 'TALK' is displayed to the left of the cursor.
X
X     /WAKEUP [<player-name> | ALL]
X       Sends a wakeup signal to the named player, or to all players if
X       "ALL" is specified.  The wakeup signal rings the terminal bell and
X       prints the words "WAKE UP" in the talk box.  If the name of the
X       player is omitted, then the signal is sent to your partner.
X
X     /WHO
X       Gives a short list of the other players and their respective seats.
X
X     /WHOIS [<player-name>]
X       Inquires about a specific player.  If the player has listed his/her
X       full name and email address in the .okbridgerc file, then this
X       information is given.  If <player-name> is omitted, then inquires
X       about both of the opponents.
X
X     /ZLOG [filename]
X       Writes a more compact log file than the /LOG command.
X--
Xcontrols	Special control characters recognized by the program
XSpecial control characters recognized by the program
X------- ------- ---------- ---------- -- --- -------
X
X ^A   Alerts partner's last bid.
X ^B   When used during the play of a hand, the bidding is displayed
X      for review.
X ^C   Quits the program.  (The program requests confirmation first.)
X ^D   Toggles the default input mode.  See the /DEFAULT command.
X ^G   Toggles the bell.  See the /BELL command.
X ^P   Toggles the prompt.  See the /PROMPT command.
X ^R   Refreshes the screen.
X ^T   Switches between bidding/playing and talk mode.
X ^U   Erases the current input.
X ^W   Sends a wakeup signal to your partner.
X ^X   Exits the program immediately (only if compiled in debug mode).
X
X TAB  Switches between bidding/playing and talk mode (same as ^T).
X
XIn addition, if you press RETURN without typing anything, the program will
Xsupply a default input, which can then be entered by pressing RETURN again.
X
X--
Xcopyright 	Copyright notice for the program
X	            Copyright Notice
X                    --------- ------
X
X          Copyright (C) 1990-1992 by Matthew Clegg
X		   All Rights Reserved
X
XOKbridge is made available as a free service to the Internet.
XAccordingly, the following restrictions are placed on its use:
X
X1.  OKbridge may not be modified in any way without the explicit 
X    permission of Matthew Clegg.  
X
X2.  OKbridge may not be used in any way for commercial advantage.
X    It may not be placed on for-profit networks or on for-profit
X    computer systems.  It may not be bundled as part of a package
X    or service provided by a for-profit organization.
X
XIf you have questions about restrictions on the use of OKbridge,
Xwrite to mclegg@cs.ucsd.edu.
X
XDISCLAIMER:  The user of OKbridge accepts full responsibility for any
Xdamage which may be caused by OKbridge.
X
X--
Xftp	        Where okbridge can be obtained on the internet
X
X			  Obtaining Okbridge
X			  --------- --------
X
XThe source code for okbridge can be obtained by anonymous ftp from the
Xfollowing two locations.  These are the 'official' archive sites for
Xokbridge, and so you will always be able to find the latest version here.
XOkbridge is also available in the comp.sources.games archives.
X
X                     North America             Europe
X                     ----- -------             ------
X   Machine Name      suned.cs.yale.edu         nic.funet.fi
X   IP Number         128.36.21.1               128.214.6.100
X   Directory         pub/okbridge              pub/unix/games
X   Filename          okbridge-1.7.tar.Z        okbridge-1.7A.tar.Z
X
X
X--
Xgps             Global Playing Service
X
XThe Global Playing Service (GPS) is a worldwide database of currently
Xplaying tables.  In the near future, it will also be used for organizing
Xcompetitive games.  The following commands can be used for accessing
Xthe GPS:
X
X  /TABLES
X    Lists the currently playing tables.
X
X  /JOIN [<name>]
X    Joins the table being served by <name>.  If <name> is omitted,
X    then the first table in the list provided by the /TABLES command
X    is joined.
X
X  /SERVE
X    Begins serving a table.  The table will be advertised to the GPS
X    automatically, so that other players may join.
X
X^
XThe Global Player Service also supports a form of duplicate play.   
XIt maintains a database of boards which have been played by other 
Xfoursomes.  These boards can be downloaded, played and scored competitively.
X
X  /DUP [MP|IMP|END]
X    Used by the server to initiate (or end) GPS duplicate play.  The MP
X    parameter is specified to play match point boards, while the IMP
X    parameter is given to play IMP boards.  The default is IMP
X    play.  After each board is downloaded and played, you will be able to
X    see the results of play by other foursomes.
X
X  /RESULTS [<results-file>]
X    Downloads all of the GPS duplicate boards which have been played by
X    the local player.  The results of play for each board are then displayed.
X    If <results-file> is specified, then the results are saved to the given
X    file in email duplicate format.  A more verbose record of the play can
X    then be produced with the oktally command.  WARNING:  If you play often,
X    then you should specify the <results-file> and examine it using oktally.
X
X  /SCOREBOARD
X    Displays the top ten scores in match point and IMP play.
X^
XIn addition, there are the following GPS-related commands:
X
X  /PLAYERS [<name>]
X    Lists the names of all of the players currently at the table
X    served by <name>.  If name is omitted, then lists the lists the
X    players at all of the tables.
X
X  /CONNECT <host_name> [<port_number>]
X    Connects to the table being served at <host_name> with port <port_number>.
X    If <port_number> is omitted, then 1729 is assumed.
X
X  /PERISH
X    Disconnects from the GPS.  If we are serving a table, this table
X    is deleted from the GPS database.
X
X  /PUBLISH
X    Reconnects to the GPS.  If we are serving a table, this table is
X    re-advertised to the GPS.
X--
Xinput     	General info about entering input
X			  How to Enter Input
X			  --- -- ----- -----
X
XDuring normal operation, the okbridge program is always in one of
Xthree 'input modes'.  The input which you type is interpreted according
Xto the input mode.  The input mode is displayed at the beginning of the 
Xline containing the cursor.  The input modes are
X
XMode	   Interpretation
X----	   --------------
XBID	   The program is expecting you to enter your bid.
XPLAY	   The program is expecting you to enter the card you wish to play.
XTALK	   Any text that you enter will be transmitted to the other players.
X
XAs you type your text, you may use the backspace key to erase the last
Xcharacter.  Press the <TAB> key to switch between input modes.
X
XThere are number of commands which can be given to the program in any 
Xinput mode.  For information on these commands, type '/help commands'.
XAlso, there are a number of special control-characters which are
Xrecognized by the program.  For information about these, type 
X'/help controls.'
X--
Xmaillist        Information about the okbridge mailing lists
X
X		      The Okbridge Mailing List
X                      --- -------- ------- ----
X
X   The address of the OKbridge mailing list is
X
X     okbridge@cs.ucsd.edu
X
X   To subscribe to this list, send a message to listserv@cs.ucsd.edu 
X   containing the single line
X
X     ADD okbridge
X
X   To cancel your subscription to the OKbridge mailing list, send a
X   message to listserv@cs.ucsd.edu containing the single line
X
X     DELETE okbridge
X
X--
Xplaying   Information about how to enter a play
X		      Information about Playing
X		      ----------- ----- -------
X
XA card is played by writing
X     <suit> <rank> or <rank> <suit>
X
Xwhere
X     <suit>  is one of C, D, H or S
X     <rank>  is one of
X	     2, 3, ..., 9, T (for Ten), J (for Jack), Q (for Queen),
X	     K (for King), A (for Ace)
X
XIf the <suit> is omitted, then the lowest card of the specified <rank>
Xis played.  Similarly, if the <rank> is omitted, then the lowest card in
Xthe given <suit> is played.  In no trump contracts, the suits are ranked
X  clubs < diamonds < hearts < spades.
XFor suit contracts, the trump suit is always the highest ranked suit.
X
XExamples of legal plays:
X  2C, 3D, H4, S6, TC, DJ, QH, SA, C, D, H, S, 2, 3, 9, T, J, K, Q, A
X
X--
Xserver          Commands which can only be used by the server
X
X     /ASSIGN <player-name> NORTH|EAST|SOUTH|WEST|OBS
X       Assigns a player to a given seat.  Can only be used before the
X       first hand has been dealt or between hands.
X
X     /DISCONNECT <player-name>
X       Closes the connection to the named player.  
X       <player-name> can either be the name of a player (e.g., Worf)
X       or the name of position (e.g., SOUTH).
X
X     /FORMAL [OFF|ON]
X       Specifies whether formal playing rules will be used or queries which
X       playing rules are currently use.  In formal play, talk messages
X       are displayed only to the opponents, alerts are not displayed to the
X       partner of the alerter, and the dummy is not revealed to anyone
X       until the opening lead has been made.
X
X^
X     /RESET
X       Resets the program to its initial state. 
X
X     /SCORE RUBBER|DUPLICATE|MP|IMP|CLEAR
X        Selects a scoring mode.  If the selected scoring mode is different 
X        from the current scoring mode, then skips the current hand.  
X        Using '/SCORE CLEAR' will clear the scoreboard.
X
X     /SKIP [n]
X       Ends the current hand immediately, without recording a score for it.
X       This command is useful in case the connection to one of the 
X       players is lost.  The number n specifies a number of hands
X       (including the current one) to skip.
X
X--
Xslam      	A special message when a slam is made
X
X
X
X
X     Oh, what a beautiful mornin'!
X     Oh, what a beautiful day!
X     I got a beautiful feelin'
X     Ev'rything's goin' my way.
X     Oh, what a beautiful day.
X
X     ...
X
X              
X	      words by Oscar Hammerstein II
X              from the musical, _Oklahoma_
X
X--
Xstarting        How to start a bridge game using okbridge
X
XTo begin with, okbridge requires four players who wish to play bridge
Xwith each other.  One of the players must volunteer to be the
X'server.'  The 'server' will be the central communications point and
Xalso will have control over some of the aspects of the game, such as
Xthe type of scoring which will be used.  The server should provide to
Xthe other players the internet name of the machine he/she will be
Xusing.  
X
XTo begin the game, the server will generally type
X  okbridge -n <name>
Xwhere <name> is an eight character identifying name.  
X
XThe other players (called clients) will type
X  okbridge -n <name> -s <server-machine>
Xwhere <name> again is an eight character identifying name and
X<server-machine> is the internet name of the machine which the
Xserver is using.  If the server has already started okbridge,
Xthen a connection should be established fairly quickly.
X^
X
XAfter all of the players have connected, the players must choose
Xseats.  The seats are named NORTH, EAST, SOUTH, WEST, with NORTH and
XSOUTH being partners and EAST and WEST being partners.  Choose a
Xseat by typing '/<seat>', where <seat> is the name of the seat
Xyou would like to have.
X
XAfter the seats have been chosen, the server can deal the cards
Xsimply by pressing RETURN.  From this point, the use of the program
Xshould be fairly obvious.
X
X--
Xstdam           Standard american conventions
X		    Standard American Conventions
X		    -------- -------- -----------
X
XA Standard American convention card always begins with the keyword SA.
XThe next keyword on the convention card identifies the major bidding
Xsystem you use:
X
XTrad        -- "Traditional" Standard American (This is the default)
X	       Follows _Goren's Bridge Complete_ by Charles Goren
XGoren       -- Follows _Goren's New Bridge Complete_
XYellow_Card -- Follows ACBL Standard Yellow Card System
X
XA series of modifiers may follow the keyword identifying the major
Xsystem.  Modifiers can be negated by putting an exclamation point in
Xfront, i.e., !Ger indicates that the Gerber convention is NOT in use.
XPoint ranges can be specified by giving the range as in 1NT:15-17 and
Xalso by giving the negation of the range as in Mic/Unu!11-15.  A plus
Xsign '+' appearing just after the initial Standard American SA
Xidentifier indicates that other conventions are used that could not be
Xlisted on the convention card.
X
X^
XThe following modifiers may be specified:
X
X5cm       -- Open with a 5-card major.
X1NT:15-7  -- 15-17 hcp for a 1nt opening.
XWk2, Str2 -- An opening 2 bid is weak (resp. strong).
XStm       --*Stayman convention
XGer       --*Gerber convention
XRKC       --*Roman keycard blackwood
XJac       --*Jacoby transfers
XMic/Unu   --*Michaels and Unusual NT
XNegX-3S   -- negative doubles through three spades.
X2/1       -- two-over-one bids forcing to game.
X2LU       -- 2 Lower Unbid (replacement for Unu)
XInv       -- Inverted minors
XSpl       -- Splinters
XSPr       -- Suit preference discards
XRCnt      -- Reverse Count
X
X* indicates that the bid is alertable.  Note that doubles and cue bids
X  are not considered alertable.
X
X^
XExample convention cards
X
XCC SA  Yellow_Card !Jac
X  -- Specifies that the bidder follows the ACBL Yellow Card with the
X     exception that Jacoby transfers are not used.
X
XCC SA  5cm 1NT:15-7 Wk2 Stm Ger RKC
X  -- Specifies a bidding system which is traditional except that
X     the bidder opens with a 5 card major, opens 2 of a suit with a weak
X     hand, 1nt with 15-17 hcp, and uses Stayman Gerber and Roman Keycard
X     Blackwood
X     
XCC SA+ 5cm 1NT:16-8 Wk2 Stm Jac Ger !RKC NegX-3S Mic/Unu!11-15
X  -- Similar to above, except that Roman Keycard Blackwood is NOT used,
X     negative doubles are allowed through 3S, and Michaels/Unusual no trump
X     bids may be made except with a point count in the range 11-15.
X     The plus sign after SA indicates that additional unlisted conventions
X     are also used.
X
X
X
X
END_OF_FILE
if test 23044 -ne `wc -c <'okbridge.help'`; then
    echo shar: \"'okbridge.help'\" unpacked with wrong size!
fi
# end of 'okbridge.help'
fi
if test -f 'protocol.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'protocol.c'\"
else
echo shar: Extracting \"'protocol.c'\" \(19876 characters\)
sed "s/^X//" >'protocol.c' <<'END_OF_FILE'
X/* command.c -- Command processor for communications between client
X * and server.
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X
X#define PROTOCOL
X#include "types.h"
X#include "protocol.h"
X#include "state.h"
X#include "parser.h"
X
X#ifdef GCC
Xextern sscanf ();
X#endif
X
Xvoid 
X  Parse_ack (), 
X  Parse_alert (), 
X  Parse_begin (), 
X  Parse_bid (), 
X  Parse_board (),
X  Parse_claim (),
X  Parse_claimreq (),
X  Parse_claimresp (),
X  Parse_cc (), 
X  Parse_comment (), 
X  Parse_connerr (), 
X  Parse_deal (),
X  Parse_echo (), 
X  Parse_email (),
X  Parse_end (), 
X  Parse_fullname (),
X  Parse_hello (), 
X  Parse_mode (),
X  Parse_name (), 
X  Parse_ping (), 
X  Parse_play (), 
X  Parse_playreq (),
X  Parse_quit (), 
X  Parse_reconnect (),
X  Parse_record (),
X  Parse_registry (),
X  Parse_reset (),
X  Parse_seat (), 
X  Parse_seaterr (), 
X  Parse_seatpos (), 
X  Parse_seatreq (),
X  Parse_servereq (),
X  Parse_score (), 
X  Parse_skip (), 
X  Parse_skipack (),
X  Parse_spec (),
X  Parse_table (),
X  Parse_tablereq (),
X  Parse_talk (), 
X  Parse_userec (),
X  Parse_wakeup (),
X  Parse_who (), 
X  Parse_whois (), 
X  Parse_whoresp ();
X
Xstatic Command_Descriptor Commands [] = {
X  {"ACK",    {{F_NAME, "<player-name>"}, 
X	      {F_KEYWORD | F_OPTIONAL, PARSER_SEATS}, NOP},  Parse_ack},
X  {"ALERT",  C_KEY("OPP|ALL"), Parse_alert},
X  {"BEGIN",  C_EMPTY, Parse_begin},
X  {"BID",    {{F_BID, "<bid-name>"}, {F_KEYWORD | F_OPTIONAL, "ALERT"},
X		NOP}, Parse_bid},
X  {"BOARD",  {{F_NAME, "<board-name>"}, {F_INT, "<board-number>"}, NOP},
X              Parse_board},
X
X  {"CC",     C_PARAM(F_STRING, "<convention-card>"), Parse_cc},
X  {"CLAIM",  C_INT("<no-tricks>"), Parse_claim},
X  {"CLAIMREQ",  C_INT("<no-tricks>"), Parse_claimreq},
X  {"CLAIMRESP", C_KEY("REJECT|ACCEPT"), Parse_claimresp},
X  {"COMMENT",C_STRING("<message>"), Parse_comment},
X
X  {"CONNERR",C_STRING("<error-message>"), Parse_connerr},
X  {"DEAL",   C_EMPTY, Parse_deal},
X  {"ECHO",   C_PARAM(F_NAME, "<ping-source>"), Parse_echo},
X  {"EMAIL",  C_STRING("<email-address>"), Parse_email},
X  {"END",    C_EMPTY, Parse_end},
X
X  {"FULLNAME", C_STRING("<full-name>"), Parse_fullname},
X  {"HELLO",  {{F_NAME, "<version>"}, {F_NAME, "<player-name>"}, 
X	      {F_KEYWORD | F_OPTIONAL, PARSER_SEATS}}, Parse_hello},
X  {"MODE",   C_KEY("CLUB|PRACTICE|FORMAL"), Parse_mode},
X  {"NAME",   C_PARAM(F_NAME, "<new-player-name>"), Parse_name},
X  {"PING",   C_EMPTY, Parse_ping},
X
X  {"PLAY",   C_PARAM(F_CARD, "<card-name>"), Parse_play},
X  {"PLAYREQ", {{F_CARD, "<card-name>"}, {F_INT, "<sequence-number>"}, NOP}, 
X     Parse_play},
X  {"QUIT",   C_EMPTY, Parse_quit},
X  {"RECONNECT", {{F_NAME, "<ip-number>"}, {F_INT, "<port-number>"},
X		   {F_KEYWORD, PARSER_SEATS}}, Parse_reconnect},
X  {"RECORD", {{F_NAME, "<board-name>"}, {F_INT, "<board-number>"}, NOP}, 
X              Parse_record},
X
X  {"REGISTRY", C_PARAM(F_NAME, "<identification>"), Parse_registry},
X  {"RESET",  C_EMPTY, Parse_reset},
X  {"SCORE",  {{F_STRING, "<current-scores>"}, NOP, NOP}, Parse_score},
X  {"SEAT",   {{F_KEYWORD, PARSER_SEATS}, {F_KEYWORD, PARSER_SEATS},
X		{F_NAME, "<player-name>"}}, Parse_seat},
X  {"SEATERR",{{F_KEYWORD | F_OPTIONAL, PARSER_SEATS},
X              {F_KEYWORD | F_OPTIONAL, PARSER_SEATS},
X	      {F_KEYWORD | F_OPTIONAL, PARSER_SEATS}}, Parse_seaterr},
X
X  {"SEATPOS", {{F_KEYWORD, PARSER_SEATS}, NOP, NOP}, Parse_seatpos},
X  {"SEATREQ", C_SEAT, Parse_seatreq},
X  {"SERVEREQ",C_PARAM(F_STRING, "<server-command>"), Parse_servereq},
X  {"SKIP",    C_EMPTY, Parse_skip},
X  {"SKIPACK",C_EMPTY, Parse_skipack},
X
X  {"SPEC",   C_EMPTY, Parse_spec},
X  {"TABLE",    C_INT("<table-number>"), Parse_table},
X  {"TABLEREQ", C_INT("<requested-table-number>"), Parse_tablereq},
X  {"TALK",   {{F_KEYWORD, "LHO|RHO|OPPS|SPEC|ALL"}, {F_STRING, "<message>"}, 
X		NOP}, Parse_talk},
X  {"USEREC", {{F_STRING, "<player-names>"}, NOP, NOP}, Parse_userec},
X
X  {"WAKEUP", C_PARAM(F_NAME, "<player-name> | ALL"), Parse_wakeup},
X  {"WHO",    C_EMPTY, Parse_who},
X  {"WHOIS",  C_PARAM(F_NAME, "<player-name>"), Parse_whois},
X  {"WHORESP",{{F_NAME, "<recipient>"}, {F_STRING, "<ident>"}, NOP},
X     Parse_whoresp},
X  END_PARSE_TABLE
X};
X
X
Xstatic char send_buffer [132];
Xstatic player_command p;
X
Xvoid Send_ack (t, player_name, pos)
X     Table_ptr t; name_buffer player_name; int pos;
X{
X  sprintf (send_buffer, "ACK %s %s", player_name,
X	   (pos < 4)? seat_names[pos]: "");
X  send_message (t, CMD_ACK, send_buffer);
X}
X
Xvoid Send_alert (t, notify_partner)
X     Table_ptr t; int notify_partner;
X{
X  sprintf (send_buffer, "ALERT %s", notify_partner? "ALL": "OPP");
X  send_message (t, CMD_ALERT, send_buffer);
X}
X
Xvoid Send_begin (t)
X     Table_ptr t;
X{
X  send_message (t, CMD_BEGIN, "BEGIN");
X}
X
Xvoid Send_bid (t, bid, alert)
X     Table_ptr t;
X     int bid;
X     int alert;
X{
X  sprintf (send_buffer, "BID %s %s", bid_names[bid],  alert? "ALERT": "");
X  send_message (t, CMD_BID, send_buffer);
X}
X
Xvoid Send_board (t, b)
X     Table_ptr t; board_ptr b;
X{
X  Message m;
X
X  sprintf (send_buffer, "BOARD %s %d", b->source, b->serial_no);
X  m = send_message (t, CMD_BOARD, send_buffer);
X  m->p.data.board.record = b;
X  if (client_mode) 
X    Transmit_board (t, b);
X  
X}
X
Xvoid Send_claim (t, no_tricks)
X     Table_ptr t; int no_tricks;
X{
X  sprintf (send_buffer, "CLAIM %d", no_tricks);
X  send_message (t, CMD_CLAIM, send_buffer);
X}
X
Xvoid Send_claimreq (t, no_tricks)
X     Table_ptr t; int no_tricks;
X{
X  sprintf (send_buffer, "CLAIMREQ %d", no_tricks);
X  send_message (t, CMD_CLAIMREQ, send_buffer);
X}
X
Xvoid Send_claimresp (t, resp)
X     Table_ptr t; int resp;
X{
X  sprintf (send_buffer, "CLAIMRESP %s", resp? "ACCEPT": "REJECT");
X  send_message (t, CMD_CLAIMRESP, send_buffer);
X}
X
Xvoid Send_cc (t, convention_card)
X     Table_ptr t; char *convention_card;
X{
X  sprintf (send_buffer, "CC %s", convention_card);
X  send_message (t, CMD_CC, send_buffer);
X}
X
Xvoid Send_comment (t, comment)
X     Table_ptr t; message_buffer comment;
X{
X  sprintf (send_buffer, "COMMENT %s", comment);
X  send_message (t, CMD_COMMENT, send_buffer);
X}
X
Xvoid Send_deal (t)
X     Table_ptr t;
X{
X  send_message (t, CMD_DEAL, "DEAL");
X}
X
Xvoid Send_echo (t, ping_source)
X     Table_ptr t; name_buffer ping_source;
X{
X  sprintf (send_buffer, "ECHO %s", ping_source);
X  send_message (t, CMD_ECHO, send_buffer);
X}
X
Xvoid Send_email (t, email_addr)
X     Table_ptr t; char *email_addr;
X{
X  sprintf (send_buffer, "EMAIL %s", email_addr);
X  send_message (t, CMD_EMAIL, send_buffer);
X}
X
Xvoid Send_end (t)
X     Table_ptr t;
X{
X  send_message (t, CMD_END, "END");
X}
X
Xvoid Send_fullname (t, fullname)
X     Table_ptr t; message_buffer fullname;
X{
X  sprintf (send_buffer, "FULLNAME %s", fullname);
X  send_message (t, CMD_FULLNAME, send_buffer);
X}
X
Xvoid Send_hello (t, version, player_name, seat_pos)
X     Table_ptr t; name_buffer version, player_name; int seat_pos;
X{
X  sprintf (send_buffer, "HELLO %s %s %s", version, player_name,
X	   (seat_pos < 4)? seat_names[seat_pos]: "OBS");
X  send_message (t, CMD_HELLO, send_buffer);
X}
X
Xvoid Send_mode (t, m)
X     Table_ptr t; int m;
X{
X  switch (m) {
X  case CLUB_PLAYING_MODE: 
X    send_message (t, CMD_MODE, "MODE CLUB");
X    break;
X  case PRACTICE_PLAYING_MODE:
X    send_message (t, CMD_MODE, "MODE PRACTICE");
X    break;
X  case FORMAL_PLAYING_MODE:
X    send_message (t, CMD_MODE, "MODE FORMAL");
X    break;
X  }
X}
X
Xvoid Send_name (t, n)
X     Table_ptr t; char *n;
X{
X  sprintf (send_buffer, "NAME %s", n);
X  send_message (t, CMD_NAME, send_buffer);
X}
X
Xvoid Send_ping (t)
X     Table_ptr t;
X{
X  send_message (t, CMD_PING, "PING");
X}
X
Xvoid Send_play (t, play)
X     Table_ptr t; int play;
X{
X  sprintf (send_buffer, "PLAY %s", card_names[play]);
X  send_message (t, CMD_PLAY, send_buffer);
X}
X
Xvoid Send_playreq (t, play, playno)
X     Table_ptr t; int play, playno;
X{
X  sprintf (send_buffer, "PLAYREQ %s %d", card_names[play], playno);
X  send_message (t, CMD_PLAYREQ, send_buffer);
X}
X
Xvoid Send_quit (t)
X     Table_ptr t;
X{
X  send_message (t, CMD_QUIT, "QUIT");
X}
X
Xvoid Send_reconnect (t, c, ip, port, seat)
X     Table_ptr t;
X     Connection c;
X     char *ip;
X     int port;
X     int seat;
X{
X  sprintf (send_buffer, "RECONNECT %s %d %s", ip, port, seat_names[seat]);
X  send_private_message (c, send_buffer);
X}
X
Xvoid Send_record (t, b, p)
X     Table_ptr t;
X     board_ptr b;
X     play_ptr p;
X{
X  Message m;
X
X  sprintf (send_buffer, "RECORD %s %d", b->source, b->serial_no);
X  m = send_message (t, CMD_RECORD, send_buffer);
X  m->p.data.record.play = p;
X  if (client_mode)
X    Transmit_play_record (t, p);
X
X}
X
Xvoid Send_registry (t, id)
X     Table_ptr t; char *id;
X{
X  sprintf (send_buffer, "REGISTRY %s", id);
X  send_message (t, CMD_REGISTRY, send_buffer);
X}
X
Xvoid Send_reset (t)
X     Table_ptr t;
X{
X  send_message (t, CMD_RESET, "RESET");
X}
X
Xvoid Send_score (t, above, below)
X     Table_ptr t; int above[]; int below[];
X{
X  sprintf (send_buffer, "SCORE %d %d %d %d",
X	   above[0], above[1], below[0], below[1]);
X  send_server_message (t, CMD_SCORE, send_buffer);
X}
X
Xvoid Send_seat (t, oldseat, newseat, name)
X     Table_ptr t; int oldseat, newseat; char *name; 
X{
X  sprintf (send_buffer, "SEAT %s %s %s", seat_names[oldseat], 
X	   seat_names[newseat], name);
X  send_message (t, CMD_SEAT, send_buffer);
X}
X
Xvoid Send_seaterr (t, message)
X     Table_ptr t; message_buffer message;
X{
X  sprintf (send_buffer, "SEATERR %s", message);
X  send_message (t, CMD_SEATERR, send_buffer);
X}
X
Xvoid Send_seatreq (t, seat)
X     Table_ptr t; int seat;
X{
X  sprintf (send_buffer, "SEATREQ %s", seat_names[seat]);
X  send_message (t, CMD_SEAT, send_buffer);
X}
X
Xvoid Send_servereq (t, request)
X     Table_ptr t; char *request;
X{
X  sprintf (send_buffer, "SERVEREQ %s", request);
X  send_message (t, CMD_SERVEREQ, send_buffer);
X}
X
Xvoid Send_skip (t)
X     Table_ptr t;
X{
X  send_message (t, CMD_SKIP, "SKIP");
X}
X
Xvoid Send_skipack (t)
X     Table_ptr t;
X{
X  send_message (t, CMD_SKIPACK, "SKIPACK");
X}
X
Xvoid Send_spec (t)
X     Table_ptr t;
X{
X  send_message (t, CMD_SPEC, "SPEC");
X}
X
Xvoid Send_table (t, c, table_no)
X     Table_ptr t;
X     Connection c;
X     int table_no;
X{
X  sprintf (send_buffer, "TABLE %d", table_no);
X  send_private_message (c, send_buffer);
X}
X
Xvoid Send_tablereq (t, table_no)
X     Table_ptr t;
X     int table_no;
X{
X  sprintf (send_buffer, "TABLEREQ %d", table_no);
X  send_message (t, CMD_TABLEREQ, send_buffer);
X}
X
Xstatic char *talk_rcpts [] = {"LHO", "RHO", "OPPS", "SPEC", "ALL"};
X
Xvoid Send_talk (t, destination, message)
X     Table_ptr t; int destination; message_buffer message;
X{
X
X  sprintf (send_buffer, "TALK %s %s", talk_rcpts[destination], message);
X  send_message (t, CMD_TALK, send_buffer);
X}
X
Xvoid Send_userec (t, n, e, s, w)
X     Table_ptr t;
X     char *n;
X     char *e;
X     char *s;
X     char *w;
X{
X  sprintf (send_buffer, "USEREC %s %s %s %s", n, e, s, w);
X  send_message (t, CMD_USEREC, send_buffer);
X}
X
Xvoid Send_wakeup (t, p)
X     Table_ptr t; char *p;
X{
X  sprintf (send_buffer, "WAKEUP %s", p);
X  send_message (t, CMD_WAKEUP, send_buffer);
X}
X
Xvoid Send_who (t)
X     Table_ptr t;
X{
X  send_message (t, CMD_WHO, "WHO");
X}
X
Xvoid Send_whois (t, p)
X     Table_ptr t; char *p;
X{
X  sprintf (send_buffer, "WHOIS %s", p);
X  send_message (t, CMD_WHOIS, send_buffer);
X}
X
Xvoid Send_whoresp (t, r, i)
X     Table_ptr t; char *r, *i;
X{
X  sprintf (send_buffer, "WHORESP %s %s", r, i);
X  send_message (t, CMD_WHORESP, send_buffer);
X}
X
Xvoid Parse_ack (player_name, pos)
X     char *player_name; int *pos;
X{
X  p->command = CMD_ACK;
X  Lcopy (player_name, p->data.ack.player_name, NAME_LENGTH);
X  p->data.ack.position = (pos == NULL)? 4: *pos;
X}
X
Xvoid Parse_alert (notify_all)
X     int *notify_all;
X{
X  p->command = CMD_ALERT;
X  p->data.alert = *notify_all;
X}
X
Xvoid Parse_begin ()
X{
X  p->command = CMD_BEGIN;
X}
X
Xvoid Parse_bid (bid, alert)
X     int *bid, *alert;
X{
X  p->command = CMD_BID;
X  p->data.bid.level = *bid;
X  p->data.bid.alert = (alert == NULL)? 0: 1;
X}
X
Xvoid Parse_board (name, no)
X     char *name; int *no;
X{
X  p->command = CMD_BOARD;
X  Lcopy (name, p->data.board.board_name, NAME_LENGTH);
X  p->data.board.board_no = *no;
X}
X
Xvoid Parse_cc (convention_card)
X     char *convention_card;
X{
X  p->command = CMD_CC;
X  Lcopy (convention_card, p->data.cc, MESSAGE_LENGTH);
X}
X
Xvoid Parse_claim (no_tricks)
X     int *no_tricks;
X{
X  p->command = CMD_CLAIM;
X  p->data.claim.no_tricks = *no_tricks;
X}
X
Xvoid Parse_claimreq (no_tricks)
X     int *no_tricks;
X{
X  p->command = CMD_CLAIMREQ;
X  p->data.claimreq.no_tricks = *no_tricks;
X}
X
Xvoid Parse_claimresp (resp)
X     int *resp;
X{
X  p->command = CMD_CLAIMRESP;
X  p->data.claimresp = *resp;
X}
X
Xvoid Parse_comment (message)
X     char *message;
X{
X  p->command = CMD_COMMENT;
X  Lcopy (message, p->data.comment, MESSAGE_LENGTH);
X}
X
Xvoid Parse_connerr (message)
X     char *message;
X{
X  p->command = CMD_CONNERR;
X  Lcopy (message, p->data.connerr, MESSAGE_LENGTH);
X}
X
Xvoid Parse_deal ()
X{
X  p->command = CMD_DEAL;
X}
X
Xvoid Parse_echo (ping_source)
X     char *ping_source;
X{
X  p->command = CMD_ECHO;
X  Lcopy (ping_source, p->data.echo.ping_source, NAME_LENGTH);
X}
X
Xvoid Parse_email (email_addr)
X     char *email_addr;
X{
X  p->command = CMD_EMAIL;
X  Lcopy (email_addr, p->data.email.addr, MESSAGE_LENGTH);
X}
X
Xvoid Parse_end ()
X{
X  p->command = CMD_END;
X}
X
Xvoid Parse_fullname (fullname)
X     char *fullname;
X{
X  p->command = CMD_FULLNAME;
X  Lcopy (fullname, p->data.fullname.name, MESSAGE_LENGTH);
X}
X
Xvoid Parse_hello (version, player_name, pos)
X     char *version, *player_name; int *pos;
X{
X  p->command = CMD_HELLO;
X  Lcopy (version, p->data.hello.version, NAME_LENGTH);
X  Lcopy (player_name, p->data.hello.player_name, NAME_LENGTH);
X  p->data.hello.seat_req = (pos == NULL)? 4: *pos;
X}
X
Xvoid Parse_mode (m)
X     int *m;
X{
X  p->command = CMD_MODE;
X  p->data.mode = *m;
X}
X
Xvoid Parse_name (c)
X     char *c;
X{
X  p->command = CMD_NAME;
X  Lcopy (c, p->data.name.new_name, NAME_LENGTH);
X}
X
Xvoid Parse_ping ()
X{
X  p->command = CMD_PING;
X}
X
Xvoid Parse_play (play)
X     int *play;
X{
X  p->command = CMD_PLAY;
X  p->data.play = *play;
X}
X
Xvoid Parse_playreq (play, seqno)
X     int *play, *seqno;
X{
X  p->command = CMD_PLAYREQ;
X  p->data.playreq.card = *play;
X  p->data.playreq.play_no = *seqno;
X}
X
Xvoid Parse_quit ()
X{
X  p->command = CMD_QUIT;
X}
X
Xvoid Parse_reconnect (ip, port, seat)
X     char *ip; int *port; int *seat;
X{
X  p->command = CMD_RECONNECT;
X  Lcopy (ip, p->data.reconnect.ip, NAME_LENGTH);
X  p->data.reconnect.port = *port;
X  p->data.reconnect.seat = *seat;
X}
X
X
Xvoid Parse_record (name, no)
X     char *name; int *no;
X{
X  p->command = CMD_RECORD;
X  Lcopy (name, p->data.record.board_name, NAME_LENGTH);
X  p->data.record.board_no = *no;
X  p->data.record.play = NULL;
X}
X
Xvoid Parse_registry (id)
X     char *id;
X{
X  p->command = CMD_REGISTRY;
X  Lcopy (id, p->data.registry.id, MESSAGE_LENGTH);
X}
X
Xvoid Parse_reset ()
X{
X  p->command = CMD_RESET;
X}
X
Xvoid Parse_seat (old, new, name)
X     int *old, *new; char *name;
X{
X  p->command = CMD_SEAT;
X  p->data.seat.old_pos = *old;
X  p->data.seat.new_pos = *new;
X  Lcopy (name, p->data.seat.player_name, NAME_LENGTH);
X}
X
Xvoid Parse_seaterr (free0, free1, free2)
X     int *free0, *free1, *free2;
X{
X  p->command = CMD_SEATERR;
X  p->data.seaterr.free_seats[0] = (free0 == NULL)? 4: *free0;
X  p->data.seaterr.free_seats[1] = (free1 == NULL)? 4: *free1;
X  p->data.seaterr.free_seats[2] = (free2 == NULL)? 4: *free2;
X}
X
Xvoid Parse_seatpos (s)
X     int *s;
X{
X  p->command = CMD_SEATPOS;
X  p->data.seatpos = *s;
X}
X
Xvoid Parse_seatreq (s)
X     int *s;
X{
X  p->command = CMD_SEATREQ;
X  p->data.seatreq = *s;
X}
X
Xvoid Parse_score (current_scores)
X     char *current_scores;
X{
X  p->command = CMD_SCORE;
X  sscanf (current_scores, "%d %d %d %d", 
X	  p->data.score.above + 0, p->data.score.above + 1,
X	  p->data.score.below + 0, p->data.score.below + 1);
X}
X
Xvoid Parse_servereq (request)
X     char *request;
X{
X  p->command = CMD_SERVEREQ;
X  Lcopy (request, p->data.servereq.command, MESSAGE_LENGTH);
X}
X
Xvoid Parse_skip ()
X{
X  p->command = CMD_SKIP;
X}
X
Xvoid Parse_skipack ()
X{
X  p->command = CMD_SKIPACK;
X}
X
Xvoid Parse_spec ()
X{
X  p->command = CMD_SPEC;
X}
X
Xvoid Parse_table (table_no)
X     int *table_no;
X{
X  p->command = CMD_TABLE;
X  p->data.table = *table_no;
X}
X
Xvoid Parse_tablereq (table_no)
X     int *table_no;
X{
X  p->command = CMD_TABLEREQ;
X  p->data.tablereq = *table_no;
X}
X
Xvoid Parse_talk (recpts, message)
X     int *recpts; char *message;
X{
X  p->command = CMD_TALK;
X  p->data.talk.recipients = *recpts;
X  Lcopy (message, p->data.talk.message, MESSAGE_LENGTH);
X}
X
Xvoid Parse_userec (player_names)
X     char *player_names;
X{
X  char north_buf[80], east_buf[80], south_buf[80], west_buf[80];
X
X  p->command = CMD_USEREC;
X  sscanf (player_names, "%s %s %s %s", north_buf, east_buf, 
X	  south_buf, west_buf);
X  Lcopy (north_buf, p->data.userec.north, NAME_LENGTH);
X  Lcopy (east_buf,  p->data.userec.east,  NAME_LENGTH);
X  Lcopy (south_buf, p->data.userec.south, NAME_LENGTH);
X  Lcopy (west_buf,  p->data.userec.west,  NAME_LENGTH);
X}
X
Xvoid Parse_wakeup (c)
X     char *c;
X{
X  p->command = CMD_WAKEUP;
X  Lcopy (c, p->data.wakeup.recipient, NAME_LENGTH);
X}
X
Xvoid Parse_who ()
X{
X  p->command = CMD_WHO;
X}
X
Xvoid Parse_whois (n)
X     char *n;
X{
X  p->command = CMD_WHOIS;
X  Lcopy (n, p->data.whois.name, NAME_LENGTH);
X}
X
Xvoid Parse_whoresp (r, i)
X     char *r, *i;
X{
X  p->command = CMD_WHORESP;
X  Lcopy (r, p->data.whoresp.recipient, NAME_LENGTH);
X  Lcopy (i, p->data.whoresp.message, MESSAGE_LENGTH);
X}
X
Xint Parse_Command_for_Client (pc)
X     player_command pc;
X{
X  int i, n;
X  p = pc;
X
X  switch (p->command_text[0]) {
X  case 'N':
X    p->player_no = PLAYER_NORTH; break;
X  case 'E':
X    p->player_no = PLAYER_EAST;  break;
X  case 'S':
X    p->player_no = PLAYER_SOUTH; break;
X  case 'W':
X    p->player_no = PLAYER_WEST;  break;
X  case 'M':
X    p->player_no = PLAYER_SERVER; break;
X  case 'O':
X    p->player_no = PLAYER_OBS;   break;
X  default:
X    p->command = CMD_ERROR;
X    sprintf (p->data.error.message, 
X	     "ERROR IN MESSAGE SOURCE");
X    return (-1);
X  }
X
X  i = 2;
X  while ((p->command_text[i] != '\0') && !isspace(p->command_text[i])) i++;
X  while ((p->command_text[i] != '\0') && isspace(p->command_text[i])) i++;
X  n = 0;
X  while (p->command_text[i] && !isspace(p->command_text[i])) {
X    if (n < NAME_LENGTH-1)
X      p->player_name[n++] = p->command_text[i];
X    i++;
X  }
X  p->player_name[n] = '\0';
X
X  if (Parse_Command (Commands, CMD_MAX-1, p->command_text+i)) {
X    p->command = CMD_ERROR;
X    Lcopy (Parser_Error_Buf, p->data.error.message, MESSAGE_LENGTH);
X    return (-1);
X  }
X  return (0);
X
X}
X
Xint Parse_Command_for_Server (pc)
X     player_command pc;
X{
X  int i, n;
X  p = pc;
X
X  i = 0;
X  while ((p->command_text[i] != '\0') && isspace(p->command_text[i])) i++;
X  n = 0;
X  while (p->command_text[i] && !isspace(p->command_text[i])) {
X    if (n < NAME_LENGTH-1)
X      p->player_name[n++] = p->command_text[i];
X    i++;
X  }
X  p->player_name[n] = '\0';
X
X  if (Parse_Command (Commands, CMD_MAX-1, p->command_text+i)) {
X    p->command = CMD_ERROR;
X    Lcopy (Parser_Error_Buf, p->data.error.message, MESSAGE_LENGTH);
X    return (-1);
X  }
X  return (0);
X
X}
X
Xvoid Initialize_protocols ()
X/* Initializes the array of message attributes. */
X{
X  ;
X}
END_OF_FILE
if test 19876 -ne `wc -c <'protocol.c'`; then
    echo shar: \"'protocol.c'\" unpacked with wrong size!
fi
# end of 'protocol.c'
fi
echo shar: End of archive 9 \(of 14\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
