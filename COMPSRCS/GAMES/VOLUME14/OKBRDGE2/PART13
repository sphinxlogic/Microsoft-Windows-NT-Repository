Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i091:  okbridge2 - computer-mediated bridge game, Part13/14
Message-ID: <3530@master.CNA.TEK.COM>
Date: 7 Sep 92 21:43:17 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1733
Approved: billr@saab.CNA.TEK.COM

Submitted-by: mclegg@cs.UCSD.EDU (Matthew Clegg)
Posting-number: Volume 14, Issue 91
Archive-name: okbridge2/Part13
Supersedes: okbridge: Volume 13, Issue 16-22
Environment: BSD-derived Unix, NeXT, curses, sockets



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 13 (of 14)."
# Contents:  gps.h gps_info.h input.h okbridgerc okshuffle.c scoring.h
#   socket.c socket.h state.h terminal.c terminal.h
# Wrapped by billr@saab on Mon Sep  7 14:33:38 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'gps.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gps.h'\"
else
echo shar: Extracting \"'gps.h'\" \(4847 characters\)
sed "s/^X//" >'gps.h' <<'END_OF_FILE'
X/* GPS_client.h -- global playing service, client interface.
X
X   Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X
X   OKbridge is made available as a free service to the Internet.
X   Accordingly, the following restrictions are placed on its use:
X
X   1.  OKbridge may not be modified in any way without the explicit 
X       permission of Matthew Clegg.  
X
X   2.  OKbridge may not be used in any way for commercial advantage.
X       It may not be placed on for-profit networks or on for-profit
X       computer systems.  It may not be bundled as part of a package
X       or service provided by a for-profit organization.
X
X   If you have questions about restrictions on the use of OKbridge,
X   write to mclegg@cs.ucsd.edu.
X
X   DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X   damage which may be caused by OKbridge.
X
X
X   The global playing service is a global database of player information.
X   In the initial implementation, it will contain only information
X   about currently playing tables.  At a later date, we will add
X   capabilities for downloading sets of boards and playing competitively.
X
X   Unfortunately, this module is not re-entrant.  This can be a bit of a
X   pain since the GPS_read_line procedure calls Wait_for_input in
X   input.c, which in turn calls Wait_for_event in network.c.
X*/
X
X#ifdef GPS
X
X  int Use_GPS = 1;      
X    /* A boolean flag indicating that we will provide information about 
X       our table to the GPS. */
X
X  int GPS_unavailable = 0;  
X    /* A boolean flag indicating that an error occurred last time we tried
X       to access the GPS. */
X
X  int GPS_socket = 0;
X    /* If nonzero, the socket descriptor of our currently open connection. */
X
X  int GPS_request_in_progress = 0;
X    /* A boolean flag which indicates that a GPS operation is currently
X       being serviced.  This flag is used by the network module when
X       setting up the select flags and also to detect if we experienced 
X       a reset during our last request. */
X
X#else
X
X  extern int Use_GPS, GPS_unavailable, GPS_socket, GPS_request_in_progress;
X
X#endif
X
X
Xvoid GPS_Get_Message_of_the_Day ();
X/* void GPS_Get_Message_of_the_Day (); */
X/* Contacts the GPS and prints out the "message of the day". */
X
Xint GPS_Get_Server_IP ();
X/* int GPS_Get_Server_IP (char *server_name, char *location, int *port); */
X/* Searches the list of currently playing tables for a server whose name
X   matches server_name.  If one is found, then copies the corresponding
X   location and port to the buffers provided by the caller, and returns 0.
X   If no match is found, returns 0.
X*/
X
Xvoid GPS_Broadcast_Server ();
X/* void Broadcast_Server (void); */
X/* Sends a message to the global player service notifying it that we
X   are serving a table.  Sends the names of each of the players at the
X   table in the message.
X*/
X
Xvoid GPS_Broadcast_Server_Silently ();
X/* Same as GPS_Broadcast_Server but does not print an error message if
X   we are not using the GPS or if the GPS was found to be unavailable
X   in a previous call.
X*/
X
Xvoid GPS_Advertise_Message ();
X/* void GPS_Advertise_Message (char *message); */
X/* If we are in server mode, then displays the given message along with
X   our table announcement in the tables display. */
X
Xvoid GPS_List_Tables ();
X/* void GPS_List_Tables (void); */
X/* Contacts the GPS for a list of the currently playing tables.
X   Lists the tables at the terminal.
X*/
X
Xvoid GPS_List_Players ();
X/* void GPS_List_Players (char *server); */
X/* Lists the players at the given table. */
X
Xvoid GPS_End_Server_Mode ();
X/* void GPS_End_Server_Mode (); */
X/* Informs the GPS that we are no longer serving a table. */
X
Xvoid GPS_Reset ();
X/* void GPS_Reset (); */
X/* Resets the state of our GPS connection. */
X
Xvoid GPS_Directory ();
X/* void GPS_Directory (void); */
X/* Returns a listing of the email duplicate files which are available. */
X
Xvoid GPS_Download ();
X/* void GPS_Download (char *download_file); */
X/* Downloads the specified file from the global player service. */
X
Xvoid GPS_Dup ();
X/* void GPS_Dup (int scoring_mode); */
X/* Initiates gps duplicate mode.  Scoring mode should be either 
X * MP_SCORING or IMP_SCORING.
X */
X
XBoard *GPS_Get_Next_Board ();
X/* void GPS_Get_Next_Board (void); */
X/* Downloads the next duplicate board from the GPS. */
X
Xvoid GPS_Upload_Play_Record ();
X/* void GPS_Upload_Play_Record (Play_record *p); */
X/* Uploads the play record p for the current email board to the GPS. */
X
XBoard *GPS_Download_Results ();
X/* Board *GPS_Download_Results (char *player_name); */
X/* Downloads the all of the recorded results in the GPS for the given 
X * player.  Returns a list of boards or NULL if no results are available.
X */
X
Xvoid GPS_Send_Playing_Time ();
X/* void  GPS_Send_Playing_Time (long seconds); */
X/* Sends the playing time for the local player in seconds to the GPS. */
END_OF_FILE
if test 4847 -ne `wc -c <'gps.h'`; then
    echo shar: \"'gps.h'\" unpacked with wrong size!
fi
# end of 'gps.h'
fi
if test -f 'gps_info.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gps_info.h'\"
else
echo shar: Extracting \"'gps_info.h'\" \(1478 characters\)
sed "s/^X//" >'gps_info.h' <<'END_OF_FILE'
X/* GPS_info.h -- Information about the global playing service.
X * 
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X * This module defines common information which is used by both
X * the client and the server side of the global playing service.
X *
X */
X
X#define GPS_REQUEST_MARKER    "-EOR-"
X#define GPS_RESPONSE_MARKER   "-EOF-"
X
X#ifdef GPS
X
X/*char *GPS_IP  = "reciprocity"; */
X  char *GPS_IP  = "132.239.51.7";
X    /* The IP name or number where the GPS server is believed to reside. */
X
X  int  GPS_port = 2001;
X    /* The port number of the GPS server. */
X
X  char *GPS_version = "1.1";
X    /* The current GPS version number. */
X
X#else
X
X  extern char *GPS_IP;
X  extern int  GPS_port;
X  extern char *GPS_version;
X
X#endif
END_OF_FILE
if test 1478 -ne `wc -c <'gps_info.h'`; then
    echo shar: \"'gps_info.h'\" unpacked with wrong size!
fi
# end of 'gps_info.h'
fi
if test -f 'input.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'input.h'\"
else
echo shar: Extracting \"'input.h'\" \(6194 characters\)
sed "s/^X//" >'input.h' <<'END_OF_FILE'
X/* input.h -- interface for input module of bridge game.
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X * This file defines the routines for handling the player-input
X * in the bridge game.
X *
X */
X
X/* The input module handles keyboard input.  This includes reading
X * characters from the keyboard, assembling them into buffers, and
X * creating messages from completed input requests.
X *
X * There are three input buffers, called the talk buffer, the play
X * buffer and the query buffer.  The talk buffer gathers characters
X * for talk messages which will be transmitted to the other players.
X * The play buffer gathers bids and plays which will be transmitted
X * to the others.  And the query buffer gathers responses to yes/no
X * questions which may be asked at times.
X *
X * At any given time, one or more of the input buffers will be "active".
X * This means that characters can be added to the buffer.  There will
X * always be exactly one buffer which is "in focus".  This is the buffer
X * in which the next character will be placed.  Characters can be
X * erased from a buffer by pressing backspace or delete.  The entire
X * contents of a buffer can be erased by pressing escape (see Note).  A 
X * buffer will be processed when return is pressed.  And one can switch
X * between buffers by pressing return.  In addition, the following
X * characters have special meaning:
X *
X * ^A   Alerts partner's last bid.
X * ^B   When used during the play of a hand, the bidding is displayed
X *      for review.
X * ^C   Quits the program.  (The program requests confirmation first.)
X * ^D   Toggles the default input mode.  See the /DEFAULT command.
X * ^G   Toggles the bell.  See the /BELL command.
X * ^P   Toggles the prompt.  See the /PROMPT command.
X * ^R   Refreshes the screen.
X * ^T   Returns to talk mode if you have been asked to bid or play.
X * ^W   Sends a wakeup signal to your partner.
X * ^X   Exits the program immediately (only if compiled in debug mode).
X *
X * Note:  The escape key actually has a dual meaning.  During normal input,
X * it will cause the buffer which is in focus to be erased.  But during
X * pause mode, it signals the program that the pause is over.
X *
X * The input processor may be placed in the following modes:
X *
X * TALK_INPUT:  Only the talk buffer is active.
X * BID_INPUT:   The talk and play buffers are active.  When return is
X *  pressed in the play buffer, the text is interpreted as a bid which
X *  if legal is transmitted to the other players.
X * PLAY_INPUT:  The talk and play buffers are active.  When return is
X *  pressed in the play buffer, the text is interpreted as a play which
X *  if legal is transmitted to the other players.
X * QUERY_INPUT: The talk and query buffers are active.  When return is
X *  is pressed in the query buffer, the text is interpreted as a yes/no
X *  answer.
X *
X * If the input text in the talk or play buffer begins with a slash '/',
X * then it is interpreted as a command.  Commands all begin with a
X * keyword and may be followed by one or more parameters, separated
X * by spaces.  For a list of the available commands, see the "command"
X * module.
X */
X
X#define TALK_INPUT    0
X#define BID_INPUT     1
X#define PLAY_INPUT    2
X#define QUERY_INPUT   3
X
X#ifdef _INPUT_
X  int input_mode = TALK_INPUT;  /* The current input mode, as defined above. */
X#else
X  extern int input_mode;
X#endif
X
X
Xvoid Initialize_Input ();
X/* This routine should be called once when the program first begins,
X * in order to set up the input buffers correctly.
X */
X
Xvoid Reinitialize_Input ();
X/* Clears all of the input buffers. */
X
Xvoid Set_Input_Mode ();
X/* Sets the input mode to the given mode.  Redisplays the talk and
X * query buffers, if appropriate.  If the new mode is BID_INPUT (resp.
X * PLAY_INPUT), the set of legal bids (resp. plays) is computed and
X * the default bid (play) is also computed.
X */
X
Xvoid Refresh_Input_Buffers ();
X/* Redisplays any input which may be present in the input buffers.
X * Places the cursor at the end of the current input buffer.
X */
X
Xvoid Clear_Focus_Buffer ();
X/* Clears the focus buffer and places the cursor at the beginning of
X * the line.
X */
X
Xint Talking ();
X/* Returns TRUE if the focus is currently on the talk buffer. */
X
Xvoid Compute_Default_Play ();
X/* Computes the default play for the local player, based upon the informaion
X * contained in Local_board and Local_play. 
X */
X
Xvoid Clear_Default_Play ();
X/* Clears a default play which may have been set earlier. */
X
Xvoid Accept_Keyboard_Characters ();
X/* If any keyboard characters are available, then reads them and adds
X * them to the current focus buffer.  This may result in a change of
X * state of the program or in messages being transmitted to the other
X * players.
X */
X
Xvoid Pause ();
X/* Displays the given message on the status line, and waits for the
X * user to press the escape key.  Returns after escape has been pressed.
X */
X
Xint  Ask ();
X/* Presents the question to the player and asks for a response.
X * Returns 1 if 'y' was entered and '0' otherwise.
X */
X
Xvoid Press_Return_to_Continue ();
X/* Prints the message on the status line and then waits for the user
X   to press return.
X */
X
Xint Reserved_message ();
X/* Compares the given message to the list of card and bid names.  If a
X   match is found, then returns true.  Otherwise, returns false.
X   The purpose of this routine is to discourage players from sending
X   talk messages which reveal intended bids or plays.
X*/
END_OF_FILE
if test 6194 -ne `wc -c <'input.h'`; then
    echo shar: \"'input.h'\" unpacked with wrong size!
fi
# end of 'input.h'
fi
if test -f 'okbridgerc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'okbridgerc'\"
else
echo shar: Extracting \"'okbridgerc'\" \(6117 characters\)
sed "s/^X//" >'okbridgerc' <<'END_OF_FILE'
X# .okbridgerc
X# 
X# This is an example startup file for the okbridge program.
X# When okbridge first starts up, it searches for the .okbridgerc
X# startup file.  The current working directory is first searched,
X# and if this fails, then the home directory is searched.
X#
X# Comment lines in the .okbridgerc file begin with a pound sign '#'.
X# Noncomment lines contain a keyword and a value associated to that
X# keyword.  The possible keyword, value pairs are described below.
X#
X
X# AUTOSAVE      ON | OFF
X# 	Specifies that we will save the options specified by the user
X#	during play of the program to the file .okdefaults after the
X#	program terminates.
X#
X# AUTOSAVE OFF
X
X# BELL		ON | OFF
X#	When requesting input (a bid or a play), the terminal's
X#	bell is rung by default.  However, this can be disabled
X#	by specifying 'BELL OFF'.  This has the same effect as the
X#	'/BELL OFF' command.
X# BELL OFF
X
X# CC           <convention-card>
X#      This is a one line description of the conventions which you
X#      like to use. 
X#
X# CC SA 5cm 1NT:15-17 Wk2 Stm Ger RKC !Jac
X
X# CCDEF        <card-name> <convention-card>
X#      Used to specify a set of named convention cards.  These cards
X#      can then be called up using the /SETCC <card-name> command.
X#
X# CCDEF basic   SA  5cm 1NT:15-7 Wk2 Stm Ger RKC
X# CCDEF simple SA 5cm 1NT:15-7 Wk2 Stm Ger RKC -X4D Mic/2nu!11-15 Inv
X# CCDEF fancy   SA+ 5cm 1NT:16-8 Wk2 Stm Jac Ger !RKC NegX-3S Mic/Unu!11-15
X# CCDEF klingon 3H bids are wild
X# CC simple
X
X#  DEFAULT         ON | OFF
X#       This controls whether or not default inputs will be provided
X#       for bids, plays and questions.
X#  DEFAULT OFF
X
X# EMAIL        <email-address>
X#      This should be your email address.  It is currently used only for
X#      identification purposes.
X#
X# EMAIL mclegg@cs.ucsd.edu
X
X# ESCKEY       <decimal-key-code>
X#      Specifies the key which will be recognized when the program
X#      presents the message "PRESS <ESC> TO CONTINUE."  This should
X#      be a decimal number representing the key code.  If your terminal
X#      does not have an ESC key, then a recommended setting is the
X#      TAB key (code 9).  The RETURN key has code 10, and the ESC
X#      key (the default) has code 27.
X
X# FULLNAME     <your-full-name>
X#      This field is used only for identification purposes, and should
X#      contain your full name as you would wish it to be displayed to others.
X#
X# FULLNAME  Matthew Clegg, University of California
X
X# GPS           ON | OFF
X#	Controls whether or not we will contact the Global Player Service
X#       automatically when the program starts up.
X#
X# GPS OFF
X
X# GPS_IP	<ip-name-or-number-of-GPS> [<GPS-port>]
X#	Specifies the Internet name or number of the GPS
X#
X# GPS_IP 132.239.51.7 2001
X
X# HELPFILE	<directory-name>
X#   This field specifies the location of the okbridge help file.
X#
X# HELPFILE /usr/local/games/okbridge.help
X 
X#   LOG		<filename>
X#	If this statement is present in the startup file, then
X#	the hands will automatically be logged to the given filename.
X#
XLOG okbridge.log
X
X# MY_IP        <local-IP-name-number>
X#      This field specifies the IP number of the local player.
X#      Usually, this okbridge can determine the IP number correctly
X#      a call to gethostbyname(), but on some systems, this will
X#      not give correct results.
X#
X# MY_IP         132.239.51.6
X
X#  NAME		<local-player-name>
X#	This field specifies the name that will be used to identify
X#	the local player to the other players.
X#
X# NAME matt
X
X#  PORT		<positive-integer>
X#	This field specifies the internet port number that will be
X#	used for communications with the server.
X#
X# PORT 1122
X
X#  PROMPT 	OFF | ON
X#	The value of this field is only relevant in hands where the
X#	local player is the dummy.  In this case, the dummy is
X#	ordinarily prompted to press RETURN at the end of each trick.
X#	This allows the dummy to see the cards that are played as they
X#	are played.  However, if 'PROMPT NO' is specified, then the
X#	dummy will not be prompted.
X# PROMPT OFF
X
X#  SCORING	RUBBER | DUPLICATE | MP | IMP
X#	This field is only relevant if the local player is north.
X#	In this case, the SCORING field determines the type of scoring
X#	that will be used by default in the game.
X# SCORING MP
X
X#  SEAT 	NORTH | EAST | SOUTH | WEST | OBS
X#	This field specifies the local player's position.
X#
XSEAT north
X
X#  SERVER	ME | <internet-name-or-number>
X#	If the value of this field is 'ME', then the local player
X#	will assume the role of server.  If the value of this field
X#	is anything else, then it is interpreted as an internet name
X#	or number of the machine where the server is running.
X# SERVER reciprocity
X
X#  TIMER        ON | OFF
X#       This controls whether or not the timer will automatically
X#       be displayed showing the amount of time spent by the local
X#       player and by all players on the current hand.
X# 
XTIMER ON
X
X# TIMEZONE     <timezone-string>
X#      This is a string which specifies the name of the time zone of
X#      the local player.  Usually, this can be determined from looking
X#      at the tm_zone field of the structure returned by the localtime()
X#      system call, but some systems do not have this field.
X# TIMEZONE     PDT
X
X#  ZLOG         <filename>
X#       This command is similar to the LOG command, in that it opens
X#       a file for recording play, but the format of the file is 
X#       different.
XZLOG okbridge.zlog
X
X# The following two options are only relevant if the position is
X# north and the scoring mode is email.  In this case, these commands
X# can be used to automatically load and store email duplicate boards.
X#
X#   LOAD        <filename>
X#        Causes the boards stored in the email duplicate file
X#        named <filename> to be automatically loaded at the beginning
X#        of the program.
X#
X#   REPLAY      <filename>
X#        Also causes the boards stored in the email duplicate file
X#        named <filename> to be automatically loaded at the beginning
X#        of the program.  After they have been played, the boards along
X#        with the results of play are automatically saved back to the
X#        same file.
END_OF_FILE
if test 6117 -ne `wc -c <'okbridgerc'`; then
    echo shar: \"'okbridgerc'\" unpacked with wrong size!
fi
# end of 'okbridgerc'
fi
if test -f 'okshuffle.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'okshuffle.c'\"
else
echo shar: Extracting \"'okshuffle.c'\" \(3739 characters\)
sed "s/^X//" >'okshuffle.c' <<'END_OF_FILE'
X/* shuffle.c -- generate shuffles for use in email duplicate play.
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X * Format of command:
X *   
X *   okshuffle [nboards] [-n board-names] [-r] [-d] [-i] [-m]
X *
X * where
X *   nboards 
X *     is the number of boards to generate.  If omitted, nboards
X *     defaults to 4.
X *
X *   -n board-names
X *     a brief (max 10 chars) name which will be used to identify the
X *     boards.  If this is omitted, then a name is invented which is based
X *     on the current date.
X *
X *   -r, -d, -i, -m
X *     specifies the scoring mode to be respectively rubber, duplicate,
X *     imp or mp.  The default scoring mode is imp.
X *
X * Writes the encoded boards to standard output.
X *
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/time.h>
X#include <errno.h>
X#include <string.h>
X
X#define _BRIDGE_
X
X#include "types.h"
X#include "boards.h"
X#include "state.h"
X
X#ifdef GCC
Xextern fprintf ();
Xextern time_t time ();
X#endif
X
Xextern char *malloc ();
Xextern char *strdup ();
X
Xextern int errno;
Xextern char *sys_errlist[];
Xextern void exit ();
Xextern int  atoi ();
Xextern void srand ();
X
Xstatic void parameter_error (msg)
X     char *msg;
X{
X  fprintf (stderr, "shuffle: error in parameters: %s\n", msg);
X  fprintf (stderr, "shuffle: usage: shuffle [nboards] [-m initial_message]\n");
X  exit (1);
X}
X
Xvoid main (argc, argv)
X     int argc; char *argv[];
X{
X  int i, nboards, know_nboards, print_date;
X  char *board_name;
X  char error_buf[80];
X/*  time_t time_value; */
X  Board *b;
X
X  nboards = 4;
X  know_nboards = 0;
X  print_date = 0;
X  scoring_mode = IMP_SCORING;
X  board_name = NULL;
X
X  for (i = 1; i < argc; i++) {
X    if (!strcmp(argv[i], "-d"))
X      scoring_mode = DUPLICATE_SCORING;
X    else if (!strcmp(argv[i], "-i"))
X      scoring_mode = IMP_SCORING;
X    else if (!strcmp(argv[i], "-m"))
X      scoring_mode = MP_SCORING;
X    else if (!strcmp(argv[i], "-r"))
X      scoring_mode = RUBBER_SCORING;
X    else if (!strcmp(argv[i], "-n")) {
X      i++;
X      if (i < argc)
X	board_name = strdup (argv[i]);
X      else
X	parameter_error ("board_name missing");
X    } else if (!know_nboards) {
X      nboards = atoi (argv[i]);
X      know_nboards = 1;
X      if (nboards <= 0) {
X	sprintf (error_buf, "expected integer nboards, but got %s", argv[i]);
X	parameter_error (error_buf);
X      }
X    } else
X      parameter_error ("too many parameters");
X  }
X
X
X  srand (time(NULL));
X
X/*
X  if (print_date) {
X    time (&time_value);
X    sprintf (date_buffer, "THIS HAND WAS SHUFFLED ON %s", ctime(&time_value));
X    if (date_buffer[strlen(date_buffer)-1] == '\n')
X      date_buffer[strlen(date_buffer)-1] = '\0';
X  }
X*/
X
X  b = NULL;
X  for (i = 0; i < nboards; i++) {
X    if (scoring_mode == RUBBER_SCORING)
X      b = Generate_Random_Rubber_Board (b, NULL);
X    else
X      b = Generate_Random_Match_Board (scoring_mode, b);
X    if (board_name != NULL)
X      b->source = strdup (board_name);
X    Record_Played_Board (b);
X  }
X
X  Write_Email_Duplicate_File (stdout);
X}
END_OF_FILE
if test 3739 -ne `wc -c <'okshuffle.c'`; then
    echo shar: \"'okshuffle.c'\" unpacked with wrong size!
fi
# end of 'okshuffle.c'
fi
if test -f 'scoring.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scoring.h'\"
else
echo shar: Extracting \"'scoring.h'\" \(5309 characters\)
sed "s/^X//" >'scoring.h' <<'END_OF_FILE'
X/* scoring.h -- scoring functions for the bridge program.
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X * This file defines the functions used for computing scores.
X * We provide functions for scoring according to the rules of
X * rubber bridge as well as according to the rules of Chicago style
X * bridge.  Instead of being passed parameters, these functions
X * obtain most of their information from the global variables
X * defined in globals.h.
X *
X * I would like to thank Tom Kronmiller for supplying the code
X * for scoring according to the Chicago rules and David Morrison
X * for supplying the MIMP scoring code.
X */
X 
Xextern int MIMP_scoring_vuln [];
Xextern int MIMP_scoring_nonvuln [];
X
X/*  All of the routines in this module use the same set of parameters:
X *  
X *  vul     := a boolean flag which if true indicates that the declaring
X *             side was vulnerable.
X *  level   := the level of the contract.
X *  suit    := the trump suit (or SUIT_NOTRUMP).
X *  doubled := is 0 for an undoubled contract, 1 for a doubled contract,
X *             and 2 for a redoubled contract.
X *  made    := If the contract was made, then the number of tricks made
X *             minus 6.  Otherwise, the negative of the number of tricks set.
X *  hcp     := Number of highcard points held by the declaring side.
X */
X
X
Xextern int Rubber_score_above ();
X/* int Rubber_score_above (vul, level, suit, doubled, made); */
X/* Computes the above-the-line score for the current contract, assuming
X   the contract was made. */
X
Xextern int Rubber_score_below ();
X/* int Rubber_score_below (vul, level, suit, doubled, made); */
X/* Computes the below-the-line score for the current contract,
X * assuming the contract was made. */
X
Xextern int Rubber_score_set ();
X/* int Rubber_score_set (vul, level, suit, doubled, made); */
X/* Computes the penalty score for the current contract assuming that
X * the contract was set.  
X */
X
Xextern int Chicago_score_made ();
X/* int Chicago_score_made (vul, level, suit, doubled, made); */
X/* Computes the score for the current contract under the Chicago scoring
X * system, assuming that it was made.
X *
X * Original version by Tom Kronmiller.
X */
X
Xextern int Chicago_score_set ();
X/* int Chicago_score_set (vul, level, suit, doubled, made); */
X/* Computes the score for the given contract under the Chicago scoring
X * system, assuming that it was set.
X *
X * Original version by Tom Kronmiller.
X */
X
Xextern int Duplicate_score_made ();
X/* int Duplicate_score_made (vul, level, suit, doubled, made); */
X/* Computes the score for the given contract under the rules of
X * duplicate scoring. 
X */
X
Xextern int Duplicate_score_set ();
X/* int Duplicate_score_set (vul, level, suit, doubled, made); */
X/* Computes the score for the given contract under the rules of
X * duplicate scoring, assuming that it was set.
X */
X
Xint IMP_rating ();
X/* Returns the number of IMPs awarded for the given score difference. 
X * The score is computed according International Match Point Scale of
X * the ACBL (1988).
X */
X
Xextern int Simulated_IMP_score_made ();
X/* int Simulated_IMP_score_made (vul, level, suit, doubled, made, hcp); */
X/* Computes the simulated IMP score for the  contract assuming that it 
X * was made.
X *
X * The Simulated IMP scoring system awards a score which is based on how
X * well the declaring team but offset by their number of highcard points.
X * The duplicate score for the declaring team is computed and then 
X * converted to a corresponding number of IMP points.  From this is
X * subtracted the excess number of highcard points above twenty of
X * the declaring team.  If the declaring team has fewer than 20 hcp,
X * then the deficit is added to the IMP score.
X */
X
Xextern int Simulated_IMP_score_set ();
X/* int Simulated_IMP_score_set (vul, level, suit, doubled, made, hcp); */
X/* Computes the simulated IMP score for the given contract assuming that 
X * it was set.
X */
X
Xextern int MIMP_score_made ();
X/* int MIMP_score_made (vul, level, suit, doubled, made, hcp); */
X/* Computes the MIMP score for the given contract, assuming it was made. 
X * 
X * The MIMP system is similar to spirit to the simulated IMP system,
X * in that the number of points awarded is offset by the highcard holdings
X * of the declaring side.  For a detailed description of the MIMP system,
X * see the article by Gary Greene in the May/June 1990 issue of 
X * Bridge Today.
X */
X
Xextern int MIMP_score_set ();
X/* int MIMP_score_set (vul, level, suit, doubled, made, hcp); */
X/* Computes the MIMP score for the given contract, assuming it was set. */
X
X
END_OF_FILE
if test 5309 -ne `wc -c <'scoring.h'`; then
    echo shar: \"'scoring.h'\" unpacked with wrong size!
fi
# end of 'scoring.h'
fi
if test -f 'socket.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'socket.c'\"
else
echo shar: Extracting \"'socket.c'\" \(7124 characters\)
sed "s/^X//" >'socket.c' <<'END_OF_FILE'
X/* socket.c -- routines for establishing socket connections
X *             over the Internet.
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X */
X
X#include <ctype.h>
X#include <sys/errno.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <arpa/inet.h>
X#include <netdb.h>
X#include <stdio.h>
X#include <string.h>
X#include <sys/time.h>
X#ifdef AIX
X#include <sys/select.h>
X#include <time.h>
X#endif
X
X#include "fds.h"
X
Xextern int errno;
Xextern char *sys_errlist[];
X/* extern int htons (); */
Xextern void sleep (), close ();
Xextern int read (), write ();
Xextern int select ();
Xextern int socket ();
Xextern connect ();
Xextern setsockopt ();
Xextern bind ();
Xextern listen ();
X
Xchar socket_error [80];
X  /* An error message buffer for recording socket errors. */
X
Xint client_init(host, portnum, retry_limit)
X     char *host;
X     int portnum;
X     int retry_limit;
X/* Attempts to establish a connection with the host identified by the
X * string 'host' at port 'portnum'.  If the connection is established,
X * then returns the socket number.  Otherwise, returns -1 and places
X * an error message in socket_error.
X *
X * This routine was adapted from a routine of the same name
X * written by Jarkko Oikarinen of the University of Oulu as part
X * of the Internet Relay Chat package.
X * 
X */
X{
X  int sock, notrys;
X  static struct hostent *hp;
X  static struct sockaddr_in server;
X  int server_avail;
X
X
X  notrys = 0;
X  while (notrys < retry_limit) {
X  /* FIX:  jtrim@duorion.cair.du.edu -- 3/4/89 
X     and jto@tolsun.oulu.fi -- 3/7/89 */
X
X    sock = socket(AF_INET, SOCK_STREAM, 0);
X
X    if (sock < 0) {
X      sprintf (socket_error, "error opening socket: %s",
X	       sys_errlist [errno]);
X      return (-1);
X    }
X    server.sin_family = AF_INET;
X    
X    /* MY FIX -- jtrim@duorion.cair.du.edu   (2/10/89) */
X    if ( isdigit(*host))
X      {
X	server.sin_addr.s_addr = inet_addr(host);
X      }
X    else
X      { 
X	hp = gethostbyname(host);
X	if (hp == 0) {
X	  sprintf(socket_error, "%s: unknown host", host);
X	  return (-1);
X	}
X	bcopy(hp->h_addr, &server.sin_addr, hp->h_length);
X      }
X    server.sin_port = htons(portnum);
X    /* End Fix */
X    
X    server_avail = connect(sock, (struct sockaddr *) &server, sizeof(server));
X    if (server_avail) {
X            close (sock);
X	    sprintf (socket_error, "connection error: %s", 
X		     sys_errlist [errno]);
X	    notrys++;
X	    if (errno == EINTR) return (-1);
X	    if (notrys < retry_limit)
X	      sleep (5);
X    } else
X      return(sock);
X  }
X  sprintf (socket_error, "CAN'T SEEM TO CONNECT TO SERVER -- GIVING UP");
X  return (-1);
X}
X
Xint open_port(portnum)
X     int portnum;
X/* Opens a socket port for listening.  If successful, returns the
X * number of socket which has been established.  If unsuccessful,
X * returns -1 and places an error string in socket_error.
X *
X * This routine was adapted from a routine of the same name
X * written by Jarkko Oikarinen of the University of Oulu as part
X * of the Internet Relay Chat package.
X * 
X */
X{
X  int sock, i;
X  static struct sockaddr_in server;
X  /* At first, open a new socket */
X  sock = socket(AF_INET, SOCK_STREAM, 0);
X  if (sock < 0) {
X    sprintf (socket_error, "error opening socket: %s",
X	     sys_errlist[errno]);
X    return(-1);
X  }
X
X  i = 1;
X  if(setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(char *)&i,sizeof(i)) < 0) {
X    sprintf (socket_error, "error setting REUSE option on socket: %s",
X	     sys_errlist[errno]);
X    return(-1);
X  }
X 
X  /* Bind a port to listen for new connections */
X  server.sin_family = AF_INET;
X  server.sin_addr.s_addr = INADDR_ANY;
X  server.sin_port = htons(portnum);
X  if (bind(sock, (struct sockaddr *) (&server), sizeof(server))) {
X    sprintf (socket_error, "error binding stream socket: %s",
X	     sys_errlist[errno]);
X    close (sock);
X    return(-1);
X  }
X
X  if(listen(sock, 3)) {
X    sprintf (socket_error, "error listening on socket: %s",
X	     sys_errlist[errno]);
X    close (sock);
X    return (-1);
X  }
X
X  return(sock);
X}
X
Xint fd_readln (fd, buf, buflen)
Xint fd; char *buf; int buflen;
X/* Reads characters from the socket fd until a newline character \n
X * is detected.  Copies up to buflen-1 characters into buf, and
X * terminates the string with a null byte.  Returns the number of
X * bytes read.  -1 is returned if the socket is closed or if an
X * exceptional condition has occurred on the socket. 
X */
X{
X	int buflog, readlog;
X	char chbuf[2];
X
X	buf[0] = '\0';
X	readlog = read (fd, chbuf, 1);
X	if (readlog == 0)
X	  sprintf (socket_error, "EOF on read from socket");
X	else if (readlog < 0)
X	  sprintf (socket_error, "socket read error: %s",
X		   sys_errlist[errno]);
X	if (readlog <= 0) return (-1);
X	buflog = 0;
X	while ((chbuf[0] != '\015') && (chbuf[0] != '\0')) {
X		if (buflog < buflen-1)
X			buf[buflog++] = chbuf[0];
X		readlog = read (fd, chbuf, 1);
X		if (readlog <= 0) {
X		  buf[0] = '\0';
X		  if (readlog < 0)
X		    sprintf (socket_error, "socket read error: %s",
X			     sys_errlist[errno]);
X		  else
X		    sprintf (socket_error, "EOF on read from socket");
X		  return (readlog);
X		}
X	}
X	if (chbuf[0] != '\0')
X	  readlog = read (fd, chbuf, 1);
X	buf[buflog] = '\0';
X	return (buflog);
X}
X
Xint fd_writeln (fd, buf)
X     int fd; char *buf;
X/* Writes the contents of the buffer to the file descriptor fd, terminating
X   it by a newline character.  Returns the actual number of bytes written,
X   or -1 if an error occurs.
X*/
X{
X  int n = strlen (buf);
X  int cc = write (fd, buf, n);
X  int cr;
X
X  if (cc < n)
X    return (cc);
X
X  cr = write (fd, "\015\n", 2);
X  if (cr < 0)
X    return (cr);
X  else 
X    return (n + cr);
X}
X
Xint Check_for_data (fd)
X     int fd;
X/* Checks the socket descriptor fd to see if any incoming data has
X   arrived.  If yes, then returns 1.  If no, then returns 0.
X   If an error, returns -1 and stores the error message in socket_error.
X*/
X{
X  int status;                 /* return code from Select call. */
X  struct fd_set wait_set;     /* A set representing the connections that
X				 have been established. */
X  struct timeval tm;          /* A timelimit of zero for polling for new
X				 connections. */
X
X  FD_ZERO (&wait_set);
X  FD_SET (fd, &wait_set);
X
X  tm.tv_sec = 0;
X  tm.tv_usec = 0;
X  status = select (FD_SETSIZE, &wait_set, (fd_set *) 0, (fd_set *) 0, &tm);
X
X  if (status < 0)
X    sprintf (socket_error, "Error in select: %s", sys_errlist[errno]);
X
X  return (status);
X
X}
END_OF_FILE
if test 7124 -ne `wc -c <'socket.c'`; then
    echo shar: \"'socket.c'\" unpacked with wrong size!
fi
# end of 'socket.c'
fi
if test -f 'socket.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'socket.h'\"
else
echo shar: Extracting \"'socket.h'\" \(2844 characters\)
sed "s/^X//" >'socket.h' <<'END_OF_FILE'
X/* socket.h -- routines for establishing connections over the internet.
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X */
X
X
Xextern int client_init ();
X/* int client_init(char *host, int portnum, int retry_limit); */
X/* Attempts to establish a connection with the host identified by the
X * string 'host' at port 'portnum'.  If the connection is established,
X * then returns the socket number.  Otherwise, returns -1 and places
X * an error message in socket_error.
X *
X * This routine was adapted from a routine of the same name
X * written by Jarkko Oikarinen of the University of Oulu as part
X * of the Internet Relay Chat package.
X * 
X */
X
Xextern int open_port ();
X/* int open_port(int portnum); */
X/* Opens a socket port for listening.  If successful, returns the
X * number of socket which has been established.  If unsuccessful,
X * returns -1 and places an error string in socket_error.
X *
X * This routine was adapted from a routine of the same name
X * written by Jarkko Oikarinen of the University of Oulu as part
X * of the Internet Relay Chat package.
X * 
X */
X
Xextern int fd_readln ();
X/* int fd_readln (int fd, char *buf, int buflen) */
X/* Reads characters from the socket fd until a newline character \n
X * is detected.  Copies up to buflen-1 characters into buf, and
X * terminates the string with a null byte.  Returns the number of
X * bytes read.  -1 is returned if the socket is closed or if an
X * exceptional condition has occurred on the socket. 
X */
X
Xextern int fd_writeln ();
X/* int fd_writeln (int fd, char *buf) */
X/* Writes the contents of the buffer to the file descriptor fd, terminating
X * it by a newline character.  Returns the actual number of bytes written,
X * or -1 if an error occurs.  NOTE:  In a normal write, the number of
X * bytes written is equal to the length of buf plus one.
X */
X
Xextern int Check_for_data ();
X/* int Check_for_data (int fd) */
X/* Checks the socket descriptor fd to see if any incoming data has
X * arrived.  If yes, then returns 1.  If no, then returns 0.
X * If an error, returns -1 and stores the error message in socket_error.
X */
END_OF_FILE
if test 2844 -ne `wc -c <'socket.h'`; then
    echo shar: \"'socket.h'\" unpacked with wrong size!
fi
# end of 'socket.h'
fi
if test -f 'state.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'state.h'\"
else
echo shar: Extracting \"'state.h'\" \(5589 characters\)
sed "s/^X//" >'state.h' <<'END_OF_FILE'
X/* state.h -- global data values.
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X * This file contains the definitions of all of the global variables.
X * These variables represent the state of the current game.  It seems
X * to be more convenient to make them global variables than to store
X * them locally and pass them as parameters to various procedures.
X *
X * The definition _BRIDGE_ is used to distinguish the external
X * references to these variables from the actual definitions.  The module
X * which defines these variables should give a definition to _BRIDGE_
X * before including this file.
X */
X
X#ifndef TYPES_INCLUDED
X#include "types.h"
X#endif
X
X#ifndef NETWORK_INCLUDED
X#include "network.h"
X#endif
X
X#ifdef _BRIDGE_
X 
X	/* Variables used to control the behavior of the local copy
X	   of the program: */
X
X        int prompt_dummy = 1;    /* true if the dummy should be prompted
X				    after each play. */
X
X        int default_plays=1;     /* true if default plays are allowed. */
X
X        int autopass_mode = 1;   /* true if the moderator should automatically
X				    generate PASS bids for absent players
X				    during PRACTICE play. */
X
X        int local_player;        /* the seat assigned to the local player. */
X
X        char *local_player_name; /* the nickname of the local player. */
X        char *local_player_full_name = NULL;
X          /* The name of the local player as specified with the FULLNAME
X	     field in the .okbridgerc file. */
X        char *local_player_email = NULL;
X          /* The email address of the local player as specified with the
X             EMAIL field in the .okbridgerc file. */
X
X        char *local_cc;
X          /* The convention card of the local player as specified with the
X             CC field in the .okbridgerc file. */
X        char *conventions[2] = {NULL, NULL};
X          /* The convention cards of NS and EW, respectively. */
X 
X	/* Information regarding the current hand: */
X        struct Table_struct *Local_table;
X          /* The table where we are sitting. */
X        struct Board_struct *Local_board;
X          /* The current board being played. */
X        struct Play_record_struct *Local_play;
X          /* The record of the plays which have been made in the current
X	     board. */
X
X        /* Information about the hands which are visible: */
X        int spectator_mode;     /* true if the observer has been shown
X                                   any hands. */
X        int revealed_bidder;    /* the bidder which is currently revealed to
X                                   the spectator. */
X        int revealed_hands[4];  /* the hands which have been revealed to
X				   the player. */
X
X        int scoring_mode;       /* the scoring mode which will be used
X				   in shuffling new boards. */
X
X	int hands_played;	/* the number of hands that have been
X				   played so far. */
X 
X        /* Additional variables used for maintaining global state: */
X        int claim_responses,    /* number of responses received so far
X				   to a claim request. */
X            claim_accepted;     /* true if neither defender has rejected
X				   the claim. */
X
X        /* Information pertaining to email duplicate play: */
X        char *email_filename = NULL;   
X                                /* the filename where we will save the
X				   hands that have been played. */
X
X        int replay_mode = 0;    /* TRUE if we should automatically save
X				   the hands back to the email_file after
X				   we have finished playing them. */
X
X        int gps_duplicate_mode = 0;  
X                                /* TRUE if we are playing GPS duplicate. */
X
X#else
X 
X        extern int prompt_dummy;
X        extern int default_plays;
X        extern int formal_mode;
X        extern int autopass_mode;
X        extern int local_player;
X        extern char *local_player_name;
X        extern char *local_player_full_name;
X        extern char *local_player_email;
X
X        extern char *local_cc;
X        extern char *conventions[];
X 
X	/* Information regarding the current hand: */
X        extern struct Table_struct *Local_table;
X        extern struct Board_struct *Local_board;
X        extern struct Play_record_struct *Local_play;
X
X
X        /* Information about the spectator: */
X        extern int spectator_mode, 
X                   revealed_bidder,
X                   revealed_hands[4];
X
X	/* Information regarding the current trick being played: */
X	extern int  leader,
X		    no_plays,
X		    plays [];
X 
X	/* Scoring information: */
X	extern int  scoring_mode,
X		    hands_played;
X 
X        /* Additional variables used for maintaining global state: */
X        extern int  claim_responses, claim_accepted;
X
X        /* Information pertaining to email duplicate play: */
X        extern char *email_filename;
X        extern int  replay_mode;
X        extern int  gps_duplicate_mode;
X
X#endif
END_OF_FILE
if test 5589 -ne `wc -c <'state.h'`; then
    echo shar: \"'state.h'\" unpacked with wrong size!
fi
# end of 'state.h'
fi
if test -f 'terminal.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'terminal.c'\"
else
echo shar: Extracting \"'terminal.c'\" \(4251 characters\)
sed "s/^X//" >'terminal.c' <<'END_OF_FILE'
X/* terminal
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X */
X 
X#include <ctype.h>
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/time.h>
X#include <curses.h>
X
X#ifdef AIX
X#include <sys/select.h>
X#ifndef TIOCGWINSZ
X#include <termios.h>
X#endif
X#endif
X
X#ifdef HPUX
X#ifndef TIOCGWINSZ
X#include <sys/termio.h>
X#endif
X#endif
X
X#define _TERMINAL_
X#include "terminal.h"
X#include "fds.h"
X
X#ifdef GCC
Xextern printf ();
X#endif
X
Xextern int ioctl ();
X/* extern int exit (); */
Xextern int stty ();
Xextern int select ();
Xextern void bzero ();
Xextern int read ();
X
Xextern int endwin ();
Xextern int wmove ();
Xextern int waddstr ();
Xextern int wrefresh ();
Xextern int wclear ();
X
Xint cursor_x, cursor_y;   /* The current position of the input cursor. */
Xint terminal_lines, terminal_cols; 
X  /* The size of the terminal screen. */
X 
Xvoid Initialize_Terminal ()
X/* To be called once at the beginning of the program. */
X{
X#ifdef TIOCGWINSZ
X  struct winsize size;
X#endif
X
X#ifdef SUNOS
X        newterm (getenv("TERM"), stdout, stdin);
X#else
X	initscr ();
X#endif
X/*
X 	terminal_lines = curscr->_maxy;
X	terminal_cols = curscr->_maxx;
X*/
X#ifdef TIOCGWINSZ
X  if (ioctl(0, TIOCGWINSZ, &size) < 0) {
X    terminal_lines = 24; 
X    terminal_cols = 80;
X  } else {
X    terminal_lines = size.ws_row;
X    if (terminal_lines == 0) terminal_lines = 24;
X    terminal_cols = size.ws_col;
X    if (terminal_cols == 0) terminal_cols = 80;
X  }
X#else
X  terminal_lines = 24;
X  terminal_cols  = 80;
X#endif
X
X#ifdef DEBUG
X  if ((terminal_lines < 24) || (terminal_cols < 80)) {
X    endwin ();
X    printf ("ERROR! The terminal window appears to small for okbridge.\n");
X    printf ("Lines = %d, Columns = %d\n", terminal_lines, terminal_cols);
X    exit (1);
X  }
X#endif
X
X#ifdef ultrix
X	crmode ();
X#else
X	cbreak ();
X#endif
X	noecho ();
X	nonl ();
X}
X 
X
Xvoid Reinitialize_Terminal ()
X/* Reconstructs the terminal state.  To be used after a SIGWINCH has
X   been detected. */
X{
X#ifdef SUNOS
X  endwin();
X  Initialize_Terminal ();
X#endif
X ;
X}
X 
Xvoid print (row, col, message)
X	int row, col; char *message;
X/* (1,1) specifies the upper left corner of the screen. */
X{
X	mvaddstr (row-1, col-1, message);
X}
X
Xvoid restore_cursor ()
X{
X  move (cursor_y, cursor_x);
X  refresh ();
X}
X
Xint char_avail ()
X/* Returns TRUE if a character is available from the keyboard. */
X{
X	struct fd_set wait_set;
X	struct timeval tm;
X
X	restore_cursor ();
X	FD_ZERO (&wait_set);
X	FD_SET (fileno(stdin), &wait_set);
X	tm.tv_sec = tm.tv_usec = 0;
X        select (FD_SETSIZE, &wait_set, NULL, NULL, &tm);
X        return (FD_ISSET(fileno(stdin), &wait_set));
X}
X 
Xint input_char ()
X/* Returns the next input character from the keyboard.
X   (The character is echo'ed if it is not a control character.) */
X{
X	int log;
X	char chbuf[2];
X 
X	restore_cursor ();
X	log = 0;
X	while (log < 1) log = read (0, chbuf, 1);
X
X	return (chbuf[0]);
X}
X 
Xvoid set_cursor (row, col)
X	int row, col;
X/* Places the cursor at the specified (row, col). */
X{
X        cursor_x = col-1;
X	cursor_y = row-1;
X	restore_cursor ();
X}
X 
Xvoid clear_screen ()
X{
X  clear ();
X  refresh ();
X}
X 
Xvoid ring_bell ()
X/* void ring_bell (void); */
X/* Rings the terminal's bell */
X{
X  if (!bell_is_on)
X    return;
X
X#ifdef SUNOS
X        flash ();
X	beep ();
X#else
X        putchar ('\007');
X        putchar ('\007');
X#endif
X	restore_cursor ();
X}
X
Xvoid Reset_Terminal ()
X/* To be called at the end of the program to reset the terminal to its
X   initial operating mode. */
X{
X	clear_screen ();
X	endwin ();
X}
X 
END_OF_FILE
if test 4251 -ne `wc -c <'terminal.c'`; then
    echo shar: \"'terminal.c'\" unpacked with wrong size!
fi
# end of 'terminal.c'
fi
if test -f 'terminal.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'terminal.h'\"
else
echo shar: Extracting \"'terminal.h'\" \(2844 characters\)
sed "s/^X//" >'terminal.h' <<'END_OF_FILE'
X/* terminal
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X * The TERMINAL module serves as one of the main interfaces to the
X * operating system, the other interface being the NETWORK module.
X * This module provides primitives for outputting text to the screen
X * and reading characters from the keyboard.  We assume that
X * the screen has at least 24 lines and 80 columns, that the cursor
X * is addressable, and that it is possible to check in advance whether
X * or not a character is available from the keyboard.
X */
X
X#ifdef _TERMINAL_
X
X  int bell_is_on = 1; /* A boolean variable indicating that the bell
X			 should be rung when the ring_bell () procedure
X			 is called. */
X
X#else
X
X  extern int bell_is_on;
X
X#endif
X
Xextern int terminal_lines, terminal_cols;
X  /* The number of lines and columns in the terminal display. */
X 
Xextern void Initialize_Terminal ();
X/* To be called once at the beginning of the program. */
X
Xextern void Reinitialize_Terminal ();
X/* Reconstructs the terminal state.  To be used after a SIGWINCH has
X   been detected. */
X 
Xextern void print ();
X/* void print (int row, int col, char *message); */
X/* (1,1) specifies the upper left corner of the screen. */
X 
Xextern int char_avail ();
X/* int char_avail (void); */
X/* Returns TRUE if a character is available from the keyboard. */
X 
Xextern int input_char ();
X/* int input_char (void); */
X/* Returns the next input character from the keyboard. */
X 
Xextern void set_cursor ();
X/* void set_cursor (int row, int col); */
X/* Places the cursor at the specified (row, col). */
X
Xextern void restore_cursor ();
X/* void restore_cursor (void); */
X/* Restores the cursor to its location as of the last call to set_cursor. */
X 
Xextern void clear_screen ();
X/* void clear_screen (void); */
X/* Clears the screen and places the cursor in the upper left corner. */
X 
Xextern void ring_bell ();
X/* void ring_bell (void); */
X/* Rings the terminal's bell */
X
Xextern void Reset_Terminal ();
X/* void Reset_Terminal (void); */
X/* To be called at the end of the program to reset the terminal to its
X   initial operating mode. */
END_OF_FILE
if test 2844 -ne `wc -c <'terminal.h'`; then
    echo shar: \"'terminal.h'\" unpacked with wrong size!
fi
# end of 'terminal.h'
fi
echo shar: End of archive 13 \(of 14\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
