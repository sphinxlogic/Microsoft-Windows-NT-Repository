Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i090:  okbridge2 - computer-mediated bridge game, Part12/14
Message-ID: <3529@master.CNA.TEK.COM>
Date: 7 Sep 92 21:43:04 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1919
Approved: billr@saab.CNA.TEK.COM

Submitted-by: mclegg@cs.UCSD.EDU (Matthew Clegg)
Posting-number: Volume 14, Issue 90
Archive-name: okbridge2/Part12
Supersedes: okbridge: Volume 13, Issue 16-22
Environment: BSD-derived Unix, NeXT, curses, sockets



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 14)."
# Contents:  Makefile ccdef.c cipher.c display.h help.c scoring.c
# Wrapped by billr@saab on Mon Sep  7 14:33:38 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(7691 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# makefile for Okbridge 1.7
X#
X# Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X# 
X# OKbridge is made available as a free service to the Internet.
X# Accordingly, the following restrictions are placed on its use:
X# 
X# 1.  OKbridge may not be modified in any way without the explicit 
X#     permission of Matthew Clegg.  
X# 
X# 2.  OKbridge may not be used in any way for commercial advantage.
X#     It may not be placed on for-profit networks or on for-profit
X#     computer systems.  It may not be bundled as part of a package
X#     or service provided by a for-profit organization.
X# 
X# If you have questions about restrictions on the use of OKbridge,
X# write to mclegg@cs.ucsd.edu.
X# 
X# DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X# damage which may be caused by OKbridge.
X# 
X
X
X# In general the okbridge program can be compiled simply by
X# typing 'make'.  If you are planning to install okbridge in
X# a public directory, then you may want to first change the
X# values of the variables OKBRIDGE_DIR and OKBRIDGE_HELPFILE.
X# Then, type 'make install'.
X
XOKBRIDGE_DIR = /usr/local/games
XOKBRIDGE_HELPFILE = /usr/local/games/okbridge.help
XINSTALL = /usr/bin/install
X
X# Thanks to George Ferguson of the University of Rochester, we now have
X# a set of manual pages for okbridge.  To install these, change the
X# following definitions as appropriate and type "make install.man"
XMANDIR = /usr/local/man/man6
XMANEXT = 6
X
X# MACHINE SPECIFIC INFORMATION:
X#
X# Okbridge has been compiled and run successfully on the following systems:
X#
X#   Machine              OS                 Changes to Makefile
X#   -------              --                 -------------------
X#   Decstation 3100,5000 ULTRIX V4.0 & 4.2  none
X#   HP 400 apollo        4.3 bsd            PWCOMMENT = -DNO_PWCOMMENT
X#   IBM RS/6000          AIX 3.1            MACHINE_FLAGS = -DAIX
X#   IBM RT               Modified BSD       none
X#   NeXTStation          NextStep 2.1       none
X#   Sun Sparcstation     SunOS 4.1.x        none
X#   Vax 2000 & 3100      BSD UNIX 4.3       none
X#
X#
X# If you are compiling with SunOS (version 4.0 or later), then you may wish
X# to uncomment the following two lines.  This slightly alters the behavior
X# of the curses interface.
X#MACHINE_FLAGS = -DSUNOS
X#CC = /usr/5bin/cc
X#
X# If you are compiling this program on a machine which is
X# running IBM's AIX operating system, then uncomment the
X# next line:
X#MACHINE_FLAGS = -DAIX
X#
X# If you are running on an HP/UX system, you may need to uncomment
X# the following line:
X#MACHINE_FLAGS = -DHPUX
X#
X# If you are compiling this program on a machine which does not
X# have strcasecmp and strncasecmp, then you will need to uncomment
X# the following line (this is not necessary if you are using
X# SunOS or a recent version of Ultrix):
X#STRCASECMP = -DNO_STRCASECMP
X#
X# A few machines do not provide the name of the time zone when returning
X# the system time through the localtime() call.  Typically, this will
X# cause a compile time error in network.c near line 600.  If you have such 
X# a machine, then you will want to uncomment the following line:
X#TIMEZONE = -DNO_TM_ZONE
X#
X# Some other machines do not store the 'gecos' field in the password file
X# file entry.  If the player has not specified his/her name using the
X# FULLNAME field in the .okbridgerc file, then we try to extract his
X# name from the gecos field.  This is used in listing the current bridge
X# players in the GPS.  If your machine cannot compile this code, then
X# you will get a compile time error in network.c near line 500.  You
X# should then uncomment the following line:
X#PWCOMMENT = -DNO_PWCOMMENT
X#
X
XFLAGS = $(STRCASECMP) $(TIMEZONE) $(MACHINE_FLAGS) $(PW_COMMENT)
X
X# The following flags may be useful if you have modified the okbridge
X# program and you need assistance debugging it:
X#
X# CFLAGS = -g -DDEBUG -DLOGFILE -DMDEBUG
X# MFLAGS = /usr/lib/debug/malloc.o
X#
X# CFLAGS = $(FLAGS) -g -DDEBUG -DLOGFILE
X# CFLAGS = $(FLAGS) -g -DDEBUG
X# CFLAGS = -g
X# CC = gcc
XCFLAGS = -O $(FLAGS)
X
X# Sun people might like to define this to get pure executables.
X#  pure = all code is in the binary
X#  non-pure = code may use shared libs, and be demand-paged
X# The advatages about pure code, is that you needn't worry about having the
X# right version of the shared libs (important if run different versions 
X# of the os), and if you store the binary on NFS, you aren't swapping
X# code over the network.  Disadvantages is that the size of pure code is
X# bigger, and might use more virtual mem (not using shared libs).
X#
X# For gcc on SunOS
X# LDFLAGS= -static -n
X# For cc on SunOS
X# LDFLAGS= -Bstatic -n
X
XOBJ = 	bridge.o input.o display.o terminal.o network.o help.o scoring.o\
X 	boards.o cipher.o rc.o protocol.o parser.o nonstd.o socket.o\
X	gps.o ccdef.o commands.o conversation.o cs.o log.o
X
XSHUFFLEOBJ = okshuffle.o nonstd.o boards.o cipher.o scoring.o
X
XTALLYOBJ = oktally.o nonstd.o boards.o cipher.o scoring.o log.o
X
XGPSOBJ = gps_server.o socket.o boards.o nonstd.o cipher.o scoring.o
XGPSSRC = ../gps-1.1/gps_server.c
XGPS    = ../gps-1.1/gps_server
X
Xall:	okbridge okshuffle oktally
X
Xokbridge:	$(OBJ)
X	$(CC) $(LDFLAGS) -o okbridge $(OBJ) -lcurses -ltermcap $(MFLAGS)
X
Xokshuffle:	$(SHUFFLEOBJ) types.h boards.h
X	$(CC) $(LDFLAGS) -o okshuffle $(SHUFFLEOBJ)
X
Xoktally:	$(TALLYOBJ) types.h
X	$(CC) $(LDFLAGS) -o oktally $(TALLYOBJ)
X
Xgps_server:	$(GPSOBJ) $(GPSSRC)
X	$(CC) $(LDFLAGS) -o gps_server $(GPSOBJ) 
X	cp gps_server $(GPS)
X
Xinstall: install.bin install.help
X
Xinstall.bin:	okbridge okshuffle oktally
X	strip okbridge
X	strip okshuffle
X	strip oktally
X	$(INSTALL) okbridge $(OKBRIDGE_DIR)/okbridge
X	$(INSTALL) okshuffle $(OKBRIDGE_DIR)
X	$(INSTALL) oktally $(OKBRIDGE_DIR)
X
Xinstall.help:
X	$(INSTALL) -c -m 644 okbridge.help $(OKBRIDGE_HELPFILE)
X
Xinstall.man:
X	install -c -m 0644 okbridge.man $(MANDIR)/okbridge.$(MANEXT)
X	install -c -m 0644 okshuffle.man $(MANDIR)/okshuffle.$(MANEXT)
X	install -c -m 0644 oktally.man $(MANDIR)/oktally.$(MANEXT)
X
Xclean:
X	rm -f *.o 
X	rm -f *~
X	rm -f tmp*
X	rm -f *.log
X	rm -f *.zlog
X	rm -f *.orig
X
Xveryclean:	clean
X	rm -f okbridge okshuffle oktally gps_server helpfile.h core tags TAGS
X
Xdistrib:	veryclean
X		csh -f < MkDistrib
X
Xbridge.o:	bridge.c state.h types.h network.h protocol.h\
X                display.h input.h terminal.h help.h scoring.h parser.h\
X		conversation.h
X
Xboards.o:	boards.c boards.h types.h cipher.h boards.h socket.h\
X		parser.h protocol.h network.h scoring.h
X
Xccdef.o:	ccdef.c
X
Xcipher.o:	cipher.h cipher.c
X
Xcommands.o:	commands.h commands.c types.h parser.h state.h terminal.h \
X		display.h input.h gps.h network.h
X
Xconversation.o:	conversation.h conversation.c types.h protocol.h network.h
X
Xcs.o:		cs.h cs.c socket.h state.h types.h network.h protocol.h gps.h
X
Xdisplay.o:	display.h display.c terminal.h types.h state.h
X
Xgps.o:		gps.h gps_info.h parser.h gps.c conversation.h
X
Xgps_server.o:   $(GPSSRC) types.h boards.h gps_info.h socket.h
X	        cp $(GPSSRC) gps_server.c
X	        $(CC) -c $(CFLAGS) gps_server.c
X	        rm gps_server.c
X
Xhelp.o:		help.h help.c types.h input.h terminal.h helpfile.h
X
Xinput.o:	input.h input.c network.h terminal.h display.h\
X		help.h input.h protocol.h state.h types.h conversation.h
X
Xlog.o:		log.h log.c boards.h
X
Xnetwork.o:	network.h network.c state.h types.h protocol.h socket.h
X
Xnonstd.o:	nonstd.c
X
Xparser.o:	parser.h parser.c
X
Xprotocol.o:     protocol.h parser.h protocol.c types.h
X
Xrc.o:		rc.h rc.c types.h parser.h state.h network.h
X
Xscoring.o:	scoring.h scoring.c state.h types.h
X
Xsocket.o:	socket.h socket.c
X
Xstartup.o:	state.h types.h parser.h
X
Xterminal.o:	terminal.h terminal.c
X
Xhelpfile.h:
X		echo 'char *help_file_name="'$(OKBRIDGE_HELPFILE)'";' \
X		> helpfile.h
X
END_OF_FILE
if test 7691 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'ccdef.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ccdef.c'\"
else
echo shar: Extracting \"'ccdef.c'\" \(7370 characters\)
sed "s/^X//" >'ccdef.c' <<'END_OF_FILE'
X/*
X * ccfile.c  Routines to support the file of convention cards for use with
X * okbridge.
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X * This module written by Jonathan Segal, and is donated to the okbridge
X * elder (i.e. Matt Clegg) to do with as he will.
X *
X *
X * This is quite simple, actually- it is a simple name-value pair table.
X *
X * Since this is fused onto an existing system, it uses global variables.
X *  
X */
X
X#include <ctype.h>
X#include <stdio.h>
X#include <string.h>
X/* #include <malloc.h> */
X
Xextern char *strdup ();
Xextern void free ();
Xextern char *realloc (), *malloc ();
X
X#define	MAX_LENGTH	256
X
Xtypedef struct cc_el
X{
X  char *ccname;
X  char *ccvalue;
X} cc_el;
X
X#define NEW_CC_BLOCK_SIZE  5
X
X/*
X  The convention card table is a NULL-terminated array of cc_els
X  */
X
Xstatic cc_el *cc = 0;                                  /* base table pointer */
Xstatic int max_num_ccs = 0;                /* referent for memory allocation */
Xstatic int num_ccs = 0;                        /* current number of used ccs */
X
X
X/*
X  forward declarations */
Xvoid Free_CCs(/*_ void _*/);
Xstatic int Get_Some_CCs(/*_ void _*/);
Xstatic cc_el *Find_CC(/*_ char *name _*/);
Xstatic int Add_CC_Definition(/*_ char *n, char *v _*/);
Xstatic void Display_CC(/*_ char *ccname, void (*display_cc)() _*/);
X
X/*------------------------------Get_CC_Value---------------------------------*/
Xchar *Get_CC_Value(/*_ char *c _*/);
X/*
X  This functions is passed a cc candidate.  If this string only contains one
X  word, and this word is a name in the cc table, the value of the cc will be
X  returned (note the value is from the table, so may need to be strduped.
X  Otherwise, it will simply return its parameter.
X
X*/
X
Xchar *Get_CC_Value( c )
Xchar *c;
X{
X  char *n;
X  cc_el *cp;
X
X  for (n = c; *n && !isspace(*n); ++n);                 /* check if one word */
X  if (*n)                                              /* more than one word */
X    return (c);
X  
X  cp = Find_CC(c);
X
X  if (!cp)                                             /* named CC not found */
X  {
X    return (c);
X  }
X  
X  else
X  {
X    return (cp->ccvalue);
X  }
X}
X
X/*---------------------------------Define_CC---------------------------------*/
Xint Define_CC(/*_ char *ccdef, void (*display_cc)() _*/);
X/*
X  this will parse the ccdef string -- if the
X*/
X
Xint Define_CC( ccdef, display_cc )
Xchar *ccdef;
Xvoid (*display_cc)();
X{
X  char *n, *v;
X  char buf[MAX_LENGTH];
X  
X  for (n = ccdef; *n && isspace(*n); ++n)
X    ;                                             /* skip to first non-white */
X  if (!*n)
X  {
X    return (1);
X  }
X
X  for(v = n; *v && !isspace(*v) ; ++v)
X    ;                                               /* skip to first white */
X  if (!*v)
X  {
X    Display_CC(n, display_cc);
X    return(0);
X  }
X  
X  *v = '\0';                                        /* null terminate name */
X  for (++v; *v && isspace(*v); ++v)
X    ;
X  if (!*v)
X  {
X    Display_CC(n, display_cc);
X    return (0);
X  }
X  if (Add_CC_Definition(n,v))
X  {
X    return (1);
X  }
X  else
X  {
X    if (display_cc)
X    {
X      sprintf(buf,"CC defined: %s",n);
X      (*display_cc)(buf);
X    }
X    return (0);
X  }
X}
X
X/*--------------------------------Display_CC---------------------------------*/
X/*
X  Display the CC with the specified name
X*/
X
Xstatic void Display_CC( n, display_cc )
Xchar  *n;
Xvoid (*display_cc)();
X{
X  cc_el *cp;
X  char linebuf[MAX_LENGTH];
X
X  if (!display_cc)
X    return;                           /* do nothing with no display function */
X  /* display the cc */
X  if (cp = Find_CC(n))
X  {
X    sprintf(linebuf,"%s = %s",cp->ccname, cp->ccvalue);
X    (*display_cc)(linebuf);
X  }
X  else
X  {
X    sprintf(linebuf, "%s IS UNDEFINED AS A CONVENTION CARD", n);
X    (*display_cc)(linebuf);
X  }
X}    
X
X/*-----------------------------Add_CC_Definition-----------------------------*/
X/*
X  Add a new cc definition to the CC table
X*/
X
Xstatic int Add_CC_Definition( n, v )
Xchar *n;
Xchar *v;
X{
X  cc_el *cp;
X  /* first see if we have a redefinition */
X
X  if (cp = Find_CC(n))
X  {
X    char *old_val = cp->ccvalue;
X    if (!(cp->ccvalue = strdup(v)))
X    {
X      cp->ccvalue = old_val;
X      return (1);
X    }
X    free(old_val);
X    return (0);
X  }
X
X  /* we're adding a new one */
X  if (num_ccs >= max_num_ccs &&  Get_Some_CCs())
X  {
X    return (1);                                /* we're out of room for more */
X  }
X    
X  /* now n is pointing to name, v is pointing to value */
X  
X  if (!(cc[num_ccs].ccname = strdup(n)))
X    return (1);                                             /* no more room! */
X  if (!(cc[num_ccs].ccvalue = strdup(v)))
X  {
X    free(cc[num_ccs].ccname);                               /* no more room! */
X    cc[num_ccs].ccname = (char *) NULL;
X    return (1);
X  }
X  ++num_ccs;
X  return (0);
X}
X
X/*------------------------------Display_All_CCs------------------------------*/
Xvoid Display_All_CCs(/*_ void (*display)() _*/);
X/*
XEnter function description here
X*/
X
Xvoid Display_All_CCs( display )
Xvoid (*display)();
X{
X  cc_el *cp;
X  char   linebuf[MAX_LENGTH];
X
X  if (!cc)
X  {
X    (*display) ("NO NAMED CONVENTION CARDS HAVE BEEN DEFINED.");
X    return;
X  }
X  for (cp = cc; cp->ccname; ++cp)
X  {
X    sprintf(linebuf,"%s = %s",cp->ccname, cp->ccvalue);
X    (*display)(linebuf);
X  }
X}
X
X
X
X/*---------------------------------Free_CCs----------------------------------*/
X/*
X  Empty the CC table, freeing the memory each CC.
X*/
X
Xvoid Free_CCs()
X{
X  cc_el *cp = cc;
X
X  if (!cc)
X    return;
X  while (cp->ccname)
X  {
X    free(cp->ccname);
X    free(cp->ccvalue);
X  }
X
X  cc->ccname = cc->ccvalue = (char *) NULL;
X  num_ccs = 0;
X  
X}
X
X/*-------------------------------Get_Some_CCs--------------------------------*/
X/*
X  Increase the CC table size.  Returns 1 on success, 0 on failure.
X*/
X
Xstatic int Get_Some_CCs()
X{
X  cc_el *newcc;
X
X  max_num_ccs += NEW_CC_BLOCK_SIZE;
X
X  if (cc)
X  {
X    newcc = (cc_el *) realloc(cc, sizeof(cc_el) * (max_num_ccs + 1));
X                                         /* add one for the null termination */
X  }
X  else
X  {
X    newcc = (cc_el *) malloc(sizeof(cc_el) * (max_num_ccs + 1));
X  }
X  if (!newcc)
X  {
X    max_num_ccs -= NEW_CC_BLOCK_SIZE;
X    return (1);
X  }
X  else
X  {
X    cc = newcc;
X    return (0);
X  }
X}
X
X/*----------------------------------Find_CC----------------------------------*/
X/*
X  Search the cc table for a CC named name
X
X  return the element found, NULL if none.
X*/
X
Xstatic cc_el *Find_CC( name )
Xchar *name;
X{
X  cc_el *cp;
X  if (!cc)
X  {
X    return (NULL);
X  }
X  
X  for (cp = cc; cp->ccname; ++cp)
X  {
X    if (!strcmp(cp->ccname, name))
X    {
X      /* a match! */
X      return (cp);
X    }
X  }
X  /* no match */
X  return (NULL);
X  
X}
X
END_OF_FILE
if test 7370 -ne `wc -c <'ccdef.c'`; then
    echo shar: \"'ccdef.c'\" unpacked with wrong size!
fi
# end of 'ccdef.c'
fi
if test -f 'cipher.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cipher.c'\"
else
echo shar: Extracting \"'cipher.c'\" \(7397 characters\)
sed "s/^X//" >'cipher.c' <<'END_OF_FILE'
X/* cipher.c
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X * This file implements procedures for a very simple cipher which
X * is used to encode crucial parts of the files which contain
X * email duplicate hands.
X *
X * The intention of this cipher is to make the contents
X * of an email duplicate file non-obvious.  This cipher is certainly
X * not intended to be difficult to break -- it is simply intended to
X * allow email duplicate files to be manipulated (e.g., mailed, copied,
X * etc.) without having their contents revealed.
X *
X * The cipher that we use is based upon the following principles:
X *    1.  Only the 64 characters a-zA-Z0-9+- are encoded.
X *        This defines a function h(c) for characters c which is 0
X *        if c is not coded and which is a unique integer in the
X *        range [1,64] if c is coded.
X *    2.  An initial permutation p the integers [1,64] is chosen.
X *    3.  Given a string s, a permuted string s' is computed according
X *        to the following formula:
X *
X *	  s'[i] =  s[i]  				if h[s[i]] = 0,
X *		   h^-1 [ p[ (h[s[i]] + i) mod 64 ]]    otherwise.
X *
X *  	  In other words, the encoding of a character is determined
X *        by a fixed permutation and by its index in the string.
X *
X * An email duplicate file begins with a header line identifying the
X * fact that it is an email duplicate file.  The following line contains
X * the permutation which has been used to encode the file.  The
X * succeeding lines are a mixture of plain-text and coded lines.
X * Coded lines begin with an exclamation point '!'.
X */
X
X#include <stdio.h>
X#include <string.h>
X
X#include "cipher.h"
X
Xextern char *malloc ();
X
X#ifdef GCC
Xextern int  fgetc ();
Xextern fprintf ();
X#endif
X
X/* extern long random (); */
Xextern int rand ();
X#define random(n) ((rand () / 64) % n)
X
Xstatic  int cipher_mapping [128];	/* the function h above. */
Xstatic  int cipher_unmapping [128];	/* h^-1, where defined  */
Xstatic  int mapping_is_initialized = 0;
X
X#define LINEBUF_SIZE  128
Xstatic char line_buf[LINEBUF_SIZE];
X
Xstatic void Initialize_Cipher_Mapping ()
X{
X	int i;
X
X	for (i = 0; i < 128; i++)
X	  cipher_mapping[i] = 0;
X	for (i = 0; i < CIPHER_SIZE1; i++)
X	  cipher_unmapping[i] = 0;
X
X	for (i = 'A'; i <= 'Z'; i++)
X		cipher_mapping[i] = i - 'A' + 1;
X	for (i = 'a'; i <= 'z'; i++)
X		cipher_mapping[i] = i - 'a' + 26 + 1;
X	for (i = '0'; i <= '9'; i++)
X		cipher_mapping[i] = i - '0' + 52 + 1;
X	cipher_mapping['+'] = 63;
X	cipher_mapping['-'] = 64;
X
X	for (i = 0; i < 128; i++)
X		if (cipher_mapping[i])
X			cipher_unmapping[cipher_mapping[i]] = i;
X}
X
Xstatic int Read_Line (f, buf, buflen)
X	FILE *f; char *buf; int buflen;
X/* Reads a line of up to buflen characters from the file f into
X   the buffer buf.  Returns the number of characters read, or -1
X   if EOF reached.
X*/
X{
X	int n, ch;
X
X	if (fgets(buf, buflen, f) == NULL)
X	  return (-1);
X
X	n = strlen(buf);
X	if ((n >= buflen) && (buf[n-1] != '\n'))
X	  do
X	    { ch = fgetc (f); }
X	  while ((ch != '\n') && (ch != EOF));
X	else
X	  buf[--n] = '\0';
X
X	return (n);
X}
X
Xint Read_Cipher_Descriptor (f, c)
X     FILE *f;
X     Cipher *c;
X/*  Reads a cipher descriptor from the file f.  Returns 0 if successful
X    or 1 if an error occurred. */
X{
X  char code_buffer[80];
X  int i, n;
X
X  if (!mapping_is_initialized)
X    Initialize_Cipher_Mapping ();
X
X  n = Read_Line (f, code_buffer, 80);
X  if (n < CIPHER_SIZE)
X    return (1);
X
X  for (i = 0; i < CIPHER_SIZE; i++)
X    c->encoding[i+1] = cipher_mapping[(int) code_buffer[i]];
X  for (i = 1; i < CIPHER_SIZE1; i++)
X    c->decoding[c->encoding[i]] = i;
X  return (0);
X}
X
Xvoid Write_Cipher_Descriptor (f, c)
X     FILE *f;
X     Cipher *c;
X/* Writes the cipher descriptor c to the file f. */
X{
X  char code_buffer[CIPHER_SIZE1];
X  int i;
X
X  for (i = 0; i < CIPHER_SIZE; i++)
X    code_buffer[i] = cipher_unmapping[c->encoding[i+1]];
X  code_buffer[CIPHER_SIZE] = '\0';
X  fprintf (f, "%s\n", code_buffer);
X}
X
Xvoid Create_Cipher_Descriptor (f, c)
X     FILE *f;
X     Cipher *c;
X/* Fills the structure c with a randomly generated cipher descriptor. */
X{
X  int i, t, r;
X
X  if (!mapping_is_initialized)
X    Initialize_Cipher_Mapping ();
X
X  c->encoding[0] = c->decoding[0] = 0;
X
X  for (i = 1; i < CIPHER_SIZE1; i++) 
X    c->encoding [i] = i;
X  for (i = 1; i < CIPHER_SIZE; i++) {
X    r = random (CIPHER_SIZE + 1 - i);
X    t = c->encoding[i+r]; 
X    c->encoding[i+r] = c->encoding[i];
X    c->encoding[i] = t;
X  };
X  
X  for (i = 1; i < CIPHER_SIZE1; i++)
X    c->decoding[c->encoding[i]] = i;
X
X}
X
Xvoid Encode_String (c, source, dest)
X     Cipher *c;
X     char *source;
X     char *dest;
X/* Encodes the string in source, placing the result in dest.
X   If c == NULL, then simply copies source to dest. */
X{
X  int i, base_code;
X  
X  if (c == NULL) {
X    strcpy (dest, source);
X    return;
X  }
X    
X  for (i = 0; source[i] != '\0'; i++)
X    if ((base_code = cipher_mapping[(int) (source[i])]) != 0)
X      dest[i] = cipher_unmapping 
X	[c->encoding [(base_code + 3*i) % CIPHER_SIZE + 1]];
X    else
X      dest[i] = source[i];
X  dest[i] = '\0';
X  
X}
X
Xvoid Decode_String (c, source, dest)
X     Cipher *c;
X     char *source;
X     char *dest;
X/* Decodes the string in source, placing the result in dest.
X   If c == NULL, then simply copies source to dest. */
X{
X  int i, p, base_code;
X
X  if (c == NULL) {
X    strcpy (dest, source);
X    return;
X  }
X
X  for (i = 0; source[i] != '\0'; i++)
X    if ((base_code = cipher_mapping[(int) (source[i])]) != 0) {
X      p = (c->decoding[base_code] + 3*CIPHER_SIZE - 3*i)
X	% CIPHER_SIZE - 1;
X      if (p == 0) p = CIPHER_SIZE;
X      dest[i] = cipher_unmapping[p];
X    } else
X      dest[i] = source[i];
X
X  dest[i] = '\0';
X}
X
Xvoid Write_Ciphered_Line (f, c, buf)
X     FILE *f;
X     Cipher *c;
X     char *buf;
X/* Encodes buf using the cipher c and writes it to the file f. 
X   The first character written to the file is an exclamation point '!' */
X{
X  if (c == NULL)
X    fprintf (f, "%s\n", buf);
X  else {
X    Encode_String (c, buf, line_buf);
X    fprintf (f, "!%s\n", line_buf);
X  }
X}
X
Xint Read_Ciphered_Line (f, c, buf, buflen)
X     FILE *f;
X     Cipher *c;
X     char *buf;
X     int buflen;
X/* Reads a line of up to buflen characters from the file f and decodes
X   the line using the cipher c.  If the first character of the line
X   is not an exclamation point '!', then the line is assumed to be
X   in plain text.  Returns the number of characters read or -1 if
X   end of file reached.
X*/
X{
X  int n;
X
X  buf[0] = '\0';
X  n = Read_Line (f, line_buf, buflen);
X  if (n <= 0)
X    return (n);
X
X  if (line_buf[0] == '!') {
X    Decode_String (c, line_buf+1, buf);
X    return (n-1);
X  } else {
X    strcpy (buf, line_buf);
X    return (n);
X  }
X  
X}
END_OF_FILE
if test 7397 -ne `wc -c <'cipher.c'`; then
    echo shar: \"'cipher.c'\" unpacked with wrong size!
fi
# end of 'cipher.c'
fi
if test -f 'display.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'display.h'\"
else
echo shar: Extracting \"'display.h'\" \(9932 characters\)
sed "s/^X//" >'display.h' <<'END_OF_FILE'
X/* display.h
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X * The DISPLAY module for the bridge program is responsible for
X * presenting the information regarding various aspects of the
X * game to the screen.  The organization of the screen is embedded
X * within this module, and there are entry points for giving
X * updates to the screen at each step of the game.
X *
X * This module does not make any calls to the operating system
X * directly.  Instead, all of its output functions are channeled
X * through the TERMINAL module.
X *
X */
X
X/*
X  The display can be in one of four modes:
X    TALK:  In this mode, almost the entire screen is used for displaying
X           talk messages between the players.  
X    BID:   This is the display mode used during bidding.  
X    PLAY:  This is the display mode used during play.  
X    SCORE: This display mode is used for displaying the history of scores
X           or the results of competitive play.
X    HELP:  This mode is used for displaying help screens.
X    MANUAL:In this mode, the display is given only minimal support by
X           the display module.  Refresh requests are not honored.
X           The status line is at the bottom of the screen.
X
X  In the latter three score modes, the lower 6 lines of the display are
X  reserved for talk messages between the players.  In the BID and PLAY
X  modes, an area in the upper right corner of the display is used for
X  a scoring panel.  The scoring panel contains information such as the
X  current vulnerabilities, the number of tricks which have been played
X  form each side, and the total score of each side.
X*/
X
X#define TALK_DISPLAY      0
X#define BIDDING_DISPLAY   1
X#define PLAYING_DISPLAY   2
X#define SCORING_DISPLAY   3
X#define HELP_DISPLAY      4
X#define MANUAL_DISPLAY    5
X
X#ifdef _DISPLAY_
X  int display_mode = TALK_DISPLAY; /* The current display mode. */
X#else
X  extern int display_mode;
X#endif
X
Xextern void Initialize_Display ();
X/* Should be called once when the program starts up. */
X 
Xextern void Reset_Display ();
X/* Redraws the main features of the screen.  Used in the process
X   of doing a 'refresh'. */
X 
Xextern void Refresh_Display ();
X/* Updates the entire screen. */
X
Xextern void Refresh_Player_Names ();
X/* Redraws the player names.  Useful in case one of the players has changed
X   position. */
X
Xextern void Set_Display_Mode ();
X/* void Set_Display_Mode (int mode); */
X/* Sets the display mode.  If the mode is different than the current mode,
X   then redraws the screen appropriately.
X*/
X 
Xextern void Display_Player_Position ();
X/* Displays okbridge header and the seat in which the local player
X   is sitting. */
X 
X/* The scoring display gives information about the following attributes
X * for each side:
X *
X * -- The number of tricks taken in the current hand.
X * -- The current 'above the line' score.
X * -- The current 'below the line' score.
X * -- The vulnerabilities of each side.
X *
X */
X 
Xextern void Display_Tricks_Taken      ();
Xextern void Display_Above_Line_Points ();
Xextern void Display_Below_Line_Points ();
Xextern void Display_Vulnerabilities   ();
Xextern void Display_Total_Time ();
X 
X 
X/* The bidding display is given as four columns, similar to that found
X * in many bridge books.  At the top of each column is printed the
X * name of the corresponding player.
X *
X * Before bidding can begin, the bidding display must be initialized.
X * Then, for each bid, that bid must be shown on the display.  And after
X * the bids have been made, the contract must be displayed.  Thus,
X * we have the following procedures:
X *
X * Display_Bidding_Board:  Called to initialize the bidding display.
X *   This procedure should be called once at the beginning of the bidding.
X *
X * Display_Hand_for_Bidding: Called to show what the local player is
X *   holding.  This procedure should be called once after the call to
X *   Display_Bidding_Board.
X *
X * Display_Bidder:  Called to show whose turn it is to bid now.
X *
X * Display_Bid:  Called to show a player's bid.  The current round of
X *   bidding and the player who has bid are passed as input parameters,
X *   but the actual bid is read from the global variable 'bids'.
X *
X * Clear_Bidding_Board:  Called to erase the bidding display.  This should
X *   be called once after the auction has concluded.
X *
X * Display_Contract:  To be called after the auction is over.  This
X *   procedure displays the contract which has been determined by the
X *   bidding.
X */
X 
Xextern void Display_Bidding_Board ();
Xextern void Display_Hand_for_Bidding ();
Xextern void Display_Bidder ();
Xextern void Display_Bid ();
Xextern void Clear_Bidding_Board ();
Xextern void Display_Contract ();
X 
X 
X/* The playing board is a separate display which runs during the play
X * of the hands.  In the center of the screen is displayed a large square
X * which is supposed to represent the tabletop, and the cards which are
X * played are shown on this table top.
X *
X * The playing proceeds also in a series of stages.  First, there is an
X * initial call to draw the playing board.  Then, in each trick there are
X * calls to show the cards which have been played.  At the end of each
X * trick, there is a final call to clear the cards from the playing board.
X * And after all of the tricks have been played, the playing board is
X * cleared.  Thus, we have the following procedures:
X *
X * Display_Playing_Board:  called initially to draw the playing board.
X *
X * Display_Hand:  called at the beginning of each trick to display the
X *   contents of the (local) player's hand.  The player whose hand is to
X *   be displayed is passed as input.
X *
X * Display_Player: called before each card is played to display whose
X *   it is to play next.
X *
X * Display_Play:  called after each card has been played to display the
X *   card on the tabletop.  The player and the card are passed as input.
X *
X * Clear_Hand:  called intermittently to erase a player's hand from
X *   the display.
X *
X * Clear_Plays:  called at the end of each trick to clear the cards from
X *   the tabletop.
X *
X * Clear_Playing_Board:  called after all of the tricks have been played
X *   to clear the 'playing board' from the screen.
X *
X */
X 
Xextern void Display_Playing_Board ();
Xextern void Display_Partial_Hand ();
Xextern void Display_Hand ();
Xextern void Display_Player ();
Xextern void Display_Play ();
Xextern void Clear_Plays  ();
Xextern void Clear_Hand ();
Xextern void Clear_Playing_Board ();
X
X
X/* If a hand is been played by multiple tables, then we can display 
X * the records of play for each table to the user.  
X *
X * First, we setup the scoring display with a call to Setup_Scoring_Display.
X * This displays the first page of scores.  
X *
X * The function More_Scores_to_Display () returns TRUE when not all of
X * the scores have yet been displayed.
X *
X * And the function Display_More_Scores () displays the next page of scores.
X */
X
Xextern void Display_First_Page_of_Scores ();
X/* void Display_First_Page_of_Scores (Board *b); */
X/* Initiales the scoring display and displays the first page of results from
X * board b. 
X */
X
Xextern int More_Scores_to_Display ();
X/* int More_Scores_to_Display (void); */
X/* Returns true if not all of the results have been displayed from the
X * board which is currently being displayed. 
X */
X
Xextern void Display_More_Scores ();
X/* void Display_More_Scores (void); */
X/* Displays the next page of scores for the board b. */
X
X
X 
X/* One line of the display is reserved for displaying special messages about
X * the status of the game.  The following two procedures are given for
X * manipulating this display.
X */
X 
Xextern void Status ();
X/* void Status (char *status_message); */
X/* Displays the given status message. */
X
Xextern void Clear_Status ();
X/* void Clear_Status (void); */
X/* Clears the status display. */
X 
Xextern void Lock_Status ();
X/* void Lock_Status (char *message); */
X/* Locks the message into the status display.  If the status display is 
X   already locked, pushes the current message onto a stack, to be redisplayed
X   when Unlock_Status is called.
X*/
X
Xextern void Unlock_Status ();
X/* void Unlock_Status (void); */
X/* Unlocks the status display.  Redisplays the previous message on the
X   stack of status messages.  */
X 
Xextern void Reset_Status ();
X/* void Reset_Status (void); */
X/* Clears all messages from the stack of status messages and resets the
X   status display. */
X
Xextern void Refresh_Status_Display ();
X/* void Refresh_Status_Display (void); */
X/* Redisplays the contents of the status buffer. */
X
X
X/* The bottom part of the screen is used for the exchange of comments
X * between the players.  The following procedures are used for managing
X * this part of the display.
X *
X * During startup, the entire screen is devoted to a comments display.
X */
Xextern void Initialize_Player_Comments ();
Xextern void Reinitialize_Player_Comments ();
Xextern void Display_Player_Comment ();
Xextern void Refresh_Player_Comments ();
Xextern void Clear_Comment_Display ();
X
Xextern void Moderator_Comment ();
X /* displays a comment from the MODERATOR. */
Xextern void Network_Comment ();
X /* displays a comment from the NETWORK. */
X
Xextern void Suspend_Comment_Display ();
Xextern void Continue_Comment_Display ();
X
END_OF_FILE
if test 9932 -ne `wc -c <'display.h'`; then
    echo shar: \"'display.h'\" unpacked with wrong size!
fi
# end of 'display.h'
fi
if test -f 'help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help.c'\"
else
echo shar: Extracting \"'help.c'\" \(7995 characters\)
sed "s/^X//" >'help.c' <<'END_OF_FILE'
X/* help.c -- help functions for the bridge program.
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X */
X 
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X
X#ifndef SEEK_SET
X#define SEEK_SET  0
X#endif
X 
X#include "types.h"
X#include "input.h"
X#include "terminal.h"
X#include "display.h"
X 
X/* char *help_file_name = "okbridge.help"; */
X#include "helpfile.h"
X
Xextern strcasecmp (), fseek ();
X 
Xextern int errno;
Xextern char *sys_errlist[];
Xextern char *strdup();
Xextern char *getenv ();
Xextern char *malloc ();
Xextern int  input_help_topic ();
X
X
Xtypedef struct help_entry_struct {
X	char	*topic;
X	char	*description;
X	long int file_offset;
X	struct help_entry_struct *next;
X} *help_entry;
X 
Xstatic help_entry main_topic = NULL;
XFILE *help_file = NULL;
X
Xlong int current_page = -1;
X  /* The offset into the help file of the current page being displayed,
X     or -1 if we are not displaying any page. */
X
X 
Xvoid display_topics (message)
X	char *message;
X/* Displays the list of topics, with the given message as the top line.
X . Does not display the main topic.
X */
X{
X	int i;
X	help_entry e;
X	char msg_buf[80];
X 
X	clear_screen ();
X	print (1,1,message);
X	if (main_topic == NULL) {
X		print (3,1,"The help system is empty.");
X	} else {
X		i = 3;
X		for (e = main_topic->next; e != NULL; e = e->next) {
X		  if (strcasecmp(e->topic, "slam")) {
X			sprintf (msg_buf, "%-10s -- %s",e->topic,
X				e->description);
X			print (i++, 1, msg_buf);
X		      }
X		}
X	}
X}
X 
Xstatic int read_help_line (buf, buflen)
X	char *buf; int buflen;
X/* Reads a line from the help file.  Returns the number of characters
X   read of -1 if EOF is encountered.  Skips lines beginning with a '#'. 
X*/
X{
X	int i, ch;
X 
X	do {
X		ch = getc(help_file);
X		i = 0;
X		while ((ch != '\n') && (ch != EOF)) {
X			if (i < buflen-1) buf[i++] = ch;
X			ch = getc(help_file);
X		}
X		buf[i] = '\0';
X		if (ch == EOF) return (-1);
X		while ((i > 0) && isspace(buf[i-1])) buf[--i] = '\0';
X	} while (buf[0] == '#');
X	return (i);
X}
X 
Xstatic void display_help_entry (e)
X	help_entry e;
X/* Displays the help_entry e. */
X{
X	char line[81];
X	int lines_on_page, log;
X
X	lines_on_page = 0;
X	current_page = e->file_offset;
X	fseek (help_file, e->file_offset, SEEK_SET);
X	log = read_help_line (line, 81);
X	while ((log >= 0) && strcmp(line, "--")) {
X		if ((lines_on_page > terminal_lines-2) || (line[0] == '^')) {
X		        Press_Return_to_Continue ("");
X			current_page = ftell (help_file);
X			clear_screen ();
X			lines_on_page = 0;
X 			if (line[0] == '^') line[0] = ' ';
X		}
X		print (++lines_on_page, 1, line);
X		log = read_help_line (line, 81);
X	}
X	Press_Return_to_Continue ("");
X}
X
Xstatic FILE *open_helpfile ()
X/* Tries to open the helpfile with given name from the help_directory.
X * If an error, prints an error message and returns NULL.  Otherwise,
X * returns a pointer to the opened file.
X */
X{
X	char filename_buf [80], msg_buf[80], *envhelpdir;
X	FILE *fp;
X 
X	if ((envhelpdir = getenv("OKBRIDGE_HELPFILE")) != NULL)
X		sprintf (filename_buf, "%s", envhelpdir);
X	else
X		sprintf (filename_buf, "%s", help_file_name);
X
X	fp = fopen (filename_buf, "r");
X	if (fp == NULL)
X		fp = fopen ("okbridge.help", "r");
X
X	if (fp == NULL) {
X		sprintf (msg_buf, "Error opening helpfile %s", filename_buf);
X		print (3, 1, msg_buf);
X		sprintf (msg_buf, "System reports error: %s",
X				sys_errlist[errno]);
X		print (4, 1, msg_buf);
X		Press_Return_to_Continue ("");
X	}
X	return (fp);
X}
X 
X 
Xstatic help_entry find_help_topic (topic)
X	char *topic;
X/* Looks for the help entry with the associated topic.  If it is found,
X * returns a pointer to the corresponding record.  Otherwise, returns NULL.
X */
X{
X	help_entry e;
X 
X	e = main_topic;
X	while (e != NULL) {
X		if (!strcasecmp(e->topic, topic))
X			return (e);
X		e = e->next;
X	}
X	return (e);
X}
X 
Xstatic help_entry read_new_help_entry ()
X/* Reads a help entry from the help_file.  Allocates a help_entry record
X . and records the pertinent information in that record.  Returns the
X . allocated record or NULL if the end of file is reached.
X */
X{
X	char line_buf[81];
X	help_entry e;
X	char *curpos, *keypos, *descpos;
X	int log;
X
X	log = read_help_line (line_buf, 81);
X	if (log < 0)
X		return (NULL);
X
X	for (keypos = line_buf; isspace(*keypos); keypos++);
X	for (curpos = keypos;(*curpos != '\0') && !isspace(*curpos);curpos++);
X	for (descpos = curpos; isspace(*descpos); descpos++);
X
X	e = (help_entry) malloc(sizeof(struct help_entry_struct));
X	*curpos = '\0';
X	e->topic = strdup (keypos);
X	e->description = strdup (descpos);
X	e->file_offset = ftell (help_file);
X	e->next = NULL;
X
X	do
X	  log = read_help_line (line_buf, 81);
X	while 
X	  ((log >= 0) && strcmp(line_buf, "--"));
X
X	return (e);
X
X}
X
X 
Xvoid initialize_help_system ()
X/* Called once at the beginning of the program to read the file of help
X * topics.
X */
X{
X	help_entry e;
X 
X	help_file = open_helpfile ();
X	if (help_file == NULL) return;
X 
X	e = main_topic = read_new_help_entry ();
X	while (e != NULL) {
X		e->next = read_new_help_entry ();
X		e = e->next;
X	}
X
X}
X 
Xvoid Browse_help_topics ();
X 
Xvoid display_help (topic)
X	char *topic;
X/* Displays help on the given topic.  This consists of looking up the
X * help file associated to this topic and displaying the contents of this
X * file on the screen.  If the topic string is empty, then displays first
X * the contents of the main topic file, and then displays a list of the
X * topics.  If there is no help on the given topic, then displays a list
X * of topics.
X */
X{
X  help_entry he;
X  char line_buf[81];
X  
X  if (main_topic == NULL)
X    return;
X  
X  clear_screen ();
X  if (strlen(topic) == 0) {
X    display_help_entry (main_topic);
X  } else if ((he = find_help_topic(topic)) != NULL)
X    display_help_entry (he);
X  else {
X    sprintf (line_buf, "%s  %s",
X	     "There is no help for this topic.",
X	     "The available topics are");
X    display_topics (line_buf);
X    Press_Return_to_Continue ("");
X  }
X  
X}
X
Xvoid browse_help (topic)
X     char *topic;
X/* Displays help on the given topic.  Afterwards, displays a list of
X * topics along with a request to enter the name of a new topic.
X */
X{
X  help_entry he;
X  char line_buf[81];
X  int no_topic = 0;
X  
X  if (main_topic == NULL)
X    return;
X  
X  clear_screen ();
X  if (strlen(topic) == 0) {
X    display_help_entry (main_topic);
X  } else if ((he = find_help_topic(topic)) != NULL)
X    display_help_entry (he);
X  else 
X    no_topic = 1;
X  
X  display_topics ("LIST OF HELP TOPICS");
X  print (terminal_lines-1, 1, "HELP");
X  Refresh_Status_Display ();
X  
X  if (no_topic) {
X    sprintf (line_buf, "THERE IS NO HELP FOR THE TOPIC %s", topic);
X    print (terminal_lines-2, 1, line_buf);
X    ring_bell ();
X  }
X}
X
Xvoid Refresh_Help_Display ()
X/* Redisplays the current screen of help information. */
X{
X  char line[81];
X  int lines_on_page, log;
X
X  if (current_page < 0) {
X    display_topics ("LIST OF HELP TOPICS");
X    return;
X  }
X  
X  lines_on_page = 0;
X  fseek (help_file, current_page, SEEK_SET);
X  log = read_help_line (line, 81);
X  while ((log >= 0) && strcmp(line, "--")) {
X    if ((lines_on_page > terminal_lines-2) || (line[0] == '^'))
X      return;
X    print (++lines_on_page, 1, line);
X    log = read_help_line (line, 81);
X  }
X  
X}
X
Xvoid Clear_Help_Display ()
X/* Returns the help system to its initial state. */
X{
X  current_page = -1;
X}
END_OF_FILE
if test 7995 -ne `wc -c <'help.c'`; then
    echo shar: \"'help.c'\" unpacked with wrong size!
fi
# end of 'help.c'
fi
if test -f 'scoring.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scoring.c'\"
else
echo shar: Extracting \"'scoring.c'\" \(9823 characters\)
sed "s/^X//" >'scoring.c' <<'END_OF_FILE'
X/* scoring.c -- scoring functions for the bridge program.
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X * This file defines the functions used for computing scores.
X * We provide functions for scoring according to the rules of
X * rubber bridge as well as according to the rules of Chicago style
X * bridge.  Instead of being passed parameters, these functions
X * obtain most of their information from the global variables
X * defined in globals.h.
X *
X * I would like to thank Tom Kronmiller for supplying the code
X * for scoring according to the Chicago rules.  Thanks Tom!
X */
X 
X#include "types.h"
X 
Xstatic int  first_trick   [] = {20, 20, 30, 30, 40};
Xstatic int  subseq_tricks [] = {20, 20, 30, 30, 30};
X
X
X/*  All of the routines in this module use the same set of parameters:
X *  
X *  vul     := a boolean flag which if true indicates that the declaring
X *             side was vulnerable.
X *  level   := the level of the contract.
X *  suit    := the trump suit (or SUIT_NOTRUMP).
X *  doubled := is 0 for an undoubled contract, 1 for a doubled contract,
X *             and 2 for a redoubled contract.
X *  made    := If the contract was made, then the number of tricks made
X *             minus 6.  Otherwise, the negative of the number of tricks set.
X *  hcp     := Number of highcard points held by the declaring side.
X */
X
Xint Rubber_score_above (vul, level, suit, doubled, made)
X     int vul, level, suit, doubled, made;
X/* Computes the above-the-line score for the current contract, assuming
X   the contract was made. */
X{
X  int above = 0;  /* computed above-the-line points. */
X
X  if (doubled) {
X    above = 100 * (made - level);
X    if (vul)         above *= 2;
X    if (doubled > 1) above *= 2;
X    above += 50;
X  } else
X    above = subseq_tricks[suit] * (made - level);
X
X  if (level == 6)
X    above += vul? 750: 500;
X  else if (level == 7)
X    above += vul? 1500: 1000;
X  return (above);
X	
X}
X
Xint Rubber_score_below (vul, level, suit, doubled, made)
X     int vul, level, suit, doubled, made;
X/* Computes the below-the-line score for the current contract,
X * assuming the contract was made. */
X{
X  int below = 0;  /* computed below-the-line points. */
X
X  below  = first_trick[suit] + 
X    (level - 1) * subseq_tricks[suit];
X  if (doubled > 1)
X    below *= 4;
X  else if (doubled)
X    below *= 2;
X  return (below);
X}
X
X
Xint Rubber_score_set (vul, level, suit, doubled, made)
X     int vul, level, suit, doubled, made;
X/* Computes the penalty score for the current contract assuming that
X * the contract was set.  
X */
X{
X  int penalty = 0;  /* computed penalty points. */
X  int down = -made - 1;
X
X  if (doubled) {
X    if (vul) penalty = 200 + 300 * down;
X    else     penalty = 100 + 200 * down;
X    if (doubled > 1) penalty *= 2;
X  } else {
X    if (vul) penalty = 100 + 100 * down;
X    else     penalty =  50 +  50 * down;
X  }
X  return (penalty);
X}
X
X
Xint Chicago_score_made (vul, level, suit, doubled, made)
X     int vul, level, suit, doubled, made;
X/* Computes the score for the current contract under the Chicago scoring
X * system, assuming that it was made.
X *
X * Original version by Tom Kronmiller.
X */
X{
X	int result = 0, perTrick;
X	int extra = made - level;
X
X	/* How much is making the bid worth? */
X	perTrick = (MINOR(suit))? 20:30;
X	result = perTrick * level;
X	if (suit == SUIT_NOTRUMP)	result += 10;
X	if (doubled > 1)                result *= 4;
X	else if (doubled == 1)          result *= 2;
X	  
X	/* Was it a game we made? */
X	if (result >= 100)		result += (!vul)? 300:500;
X/*	else					result += 50; */
X
X	/* Was it a slam we made? */
X	if (level == 6)		result += (!vul)? 500:750;
X	if (level == 7)		result += (!vul)? 1000:1500;
X
X	/* Were we insulted by a double? */
X	if (doubled > 1)                  result += 100;
X	else if (doubled == 1)            result += 50;
X
X	/* How much do we get for overtricks? */
X	if (doubled > 1)
X	        result += (extra * 100) * (vul? 4: 2);
X	else if (doubled == 1)
X	        result += (extra * 100) * (vul? 2: 1);
X	else
X		result += extra * perTrick;
X
X	return (result);
X}
X
X
Xint Chicago_score_set (vul, level, suit, doubled, made)
X     int vul, level, suit, doubled, made;
X/* Computes the score for the given contract under the Chicago scoring
X * system, assuming that it was set.
X *
X * Original version by Tom Kronmiller.
X */
X{
X	int result = 0;
X	int down =  -made;
X
X	if (!doubled)
X	{
X		result = 50 * down;
X		if (vul) result *= 2;
X	}
X	else
X	{
X		switch (down)
X		{
X			case 1:
X				result = (!vul)? 100:200;
X				break;
X			case 2:
X				result = (!vul)? 300:500;
X				break;
X			case 3:
X				result = (!vul)? 500:800;
X				break;
X			default:
X				result = 500 + (300*(down-3)) 
X				  + ((!vul)? 0:300);
X				break;
X		}
X		if (doubled > 1) result *= 2;
X	}
X	return (result);
X}
X
Xint Duplicate_score_made (vul, level, suit, doubled, made)
X     int vul, level, suit, doubled, made;
X/* Computes the score for the given contract under the rules of
X * duplicate scoring. 
X */
X{
X	int score;
X
X	if (made == 0)
X	  return (0);
X
X	score = Chicago_score_made (vul, level, suit, doubled, made);
X	if (score < 300)
X		score += 50;
X	return (score);
X	
X}
X
Xint Duplicate_score_set (vul, level, suit, doubled, made)
X     int vul, level, suit, doubled, made;
X/* Computes the score for the given contract under the rules of
X * duplicate scoring, assuming that it was set.
X */
X{
X  return (Chicago_score_set(vul, level, suit, doubled, made));
X}
X
X
Xstatic int IMP_conversion_table [] = {
X    20,   50,   90,  130,  170,  220,  270,  320,  370,  430, 
X   500,  600,  750,  900, 1100, 1300, 1500, 1750, 2000, 2250,
X  2500, 3000, 3500, 4000, 99999};
X
Xint IMP_rating (score_diff)
X     int score_diff;
X/* Returns the number of IMPs awarded for the given score difference. */
X{
X  int imps = 0;
X
X  if (score_diff < 0)
X    return (-IMP_rating(-score_diff));
X
X  for (imps = 0; IMP_conversion_table[imps] <= score_diff; imps++);
X  return (imps + imps);
X}
X
Xstatic int IMP_score_conversion (pt, highcard_points)
X     int pt, highcard_points;
X/* Computes a 'simulated IMP' score.  This score is computed by looking
X   up the IMP_rating of the pt score of the declaring team, and subtracting
X   from this the number of highcard points over 20.
X*/
X{
X  return (IMP_rating(pt) - (highcard_points - 20));
X}
X
Xint Simulated_IMP_score_made (vul, level, suit, doubled, made, hcp)
X     int vul, level, suit, doubled, made, hcp;
X/* Computes the simulated IMP score for the given contract assuming that 
X * it was made.
X */
X{
X	int score;
X
X	score =
X	  IMP_score_conversion
X	    (Duplicate_score_made (vul, level, suit, doubled, made), hcp);
X
X	return (score);
X	
X}
X
Xint Simulated_IMP_score_set (vul, level, suit, doubled, made, hcp)
X     int vul, level, suit, doubled, made, hcp;
X/* Computes the simulated IMP score for the given contract assuming that 
X * it was set.
X */
X{
X	int score;
X
X	score =
X	  IMP_score_conversion
X	    (-Duplicate_score_set(vul, level, suit, doubled, made), hcp);
X
X	return (score);
X}
X
Xint MIMP_scoring_vuln [] = {
X    -2100, -2100, -2100, -2100, -1850, -1650, -1500, -1400, -1100, -950,
X    -800, -750, -700, -650, -600, -450, -300, -150, -100, -50,
X    0, 50, 100, 150, 300, 450, 600, 650, 700, 750,
X    800, 950, 1100, 1400, 1500, 1650, 1850, 2100, 2100, 2100,
X    2100
X};
X
Xint MIMP_scoring_nonvuln [] = {
X    -1500, -1500, -1500, -1500, -1300, -1150, -1050, -950, -800, -700,
X    -600, -550, -500, -450, -400, -300, -200, -150, -100, -50,
X    0, 50, 100, 150, 200, 300, 400, 450, 500, 550,
X    600, 700, 800, 950, 1050, 1150, 1300, 1500, 1500, 1500,
X    1500
X};
X
Xint MIMP_score_conversion (score, vulnerable, highcard_points)
X     int score, vulnerable, highcard_points;
X/* This code contributed by David Morrison. */
X{
X    /* If you think the code calculating the score here is magic, you
X     * are *right*.
X     */
X
X    if (vulnerable) { score -= MIMP_scoring_vuln[highcard_points]; }
X    else { score -= MIMP_scoring_nonvuln[highcard_points]; }
X
X    /* If I had a good description of the algorithm, and its
X     * justification, it would go here.  For now, you'll just have to
X     * accept the code.
X     */
X
X    if ( (score <= 600) && (score >= -600) ) {
X        score *= 2;
X    } else {
X	if (score > 600) {
X	    score += 600;
X	} else {
X	    score -= 600;
X	}
X    }
X
X    if (score >= 0)
X      score = (score + 25) / 50;
X    else
X      score = (score - 25) / 50;
X
X    return (score);
X
X}
X
Xint MIMP_score_made (vul, level, suit, doubled, made, hcp)
X     int vul, level, suit, doubled, made, hcp;
X/* Computes the MIMP score for the given contract assuming that 
X * it was made.
X *
X * This code contributed by David Morrison.
X */
X{
X  int score;
X
X  score =
X    MIMP_score_conversion
X      (Duplicate_score_made (vul, level, suit, doubled, made), vul, hcp);
X
X  return (score);
X	
X}
X
Xint MIMP_score_set (vul, level, suit, doubled, made, hcp)
X     int vul, level, suit, doubled, made, hcp;
X/* Computes the MIMP score for the given contract assuming that 
X * it was set.
X *
X * This code contributed by David Morrison.
X */
X{
X  int score;
X
X  score =
X    MIMP_score_conversion
X      (-Duplicate_score_set(vul, level, suit, doubled, made), vul, hcp);
X  
X  return (score);
X}
X
END_OF_FILE
if test 9823 -ne `wc -c <'scoring.c'`; then
    echo shar: \"'scoring.c'\" unpacked with wrong size!
fi
# end of 'scoring.c'
fi
echo shar: End of archive 12 \(of 14\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
