Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i082:  okbridge2 - computer-mediated bridge game, Part04/14
Message-ID: <3521@master.CNA.TEK.COM>
Date: 7 Sep 92 21:41:24 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2016
Approved: billr@saab.CNA.TEK.COM

Submitted-by: mclegg@cs.UCSD.EDU (Matthew Clegg)
Posting-number: Volume 14, Issue 82
Archive-name: okbridge2/Part04
Supersedes: okbridge: Volume 13, Issue 16-22
Environment: BSD-derived Unix, NeXT, curses, sockets



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 14)."
# Contents:  commands.c rc.h
# Wrapped by billr@saab on Mon Sep  7 14:33:36 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'commands.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'commands.c'\"
else
echo shar: Extracting \"'commands.c'\" \(44917 characters\)
sed "s/^X//" >'commands.c' <<'END_OF_FILE'
X/* commands.c
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X * This module implements the commands which are available through the
X * input processor.
X *
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <sys/time.h>
X
X#include "types.h"
X#include "parser.h"
X#include "state.h"
X#include "terminal.h"
X#include "display.h"
X#include "input.h"
X#include "gps.h"
X#include "help.h"
X#include "conversation.h"
X
X/* extern fclose (), strcasecmp (), gettimeofday (); */
X
Xextern int errno;
Xextern char *sys_errlist[];
Xextern char *strdup();
Xextern void free ();
X
Xextern int  pause_mode;
X
Xextern void Assign_seat ();
Xextern void Broadcast_seat_assignment ();
Xextern void Generate_reset ();
Xextern void Broadcast_Comment ();
Xextern void Quit_program ();
X
X/* The following structures define the set of commands which are available
X   to the local player.
X */
X
X
Xenum
X{
X  INPUT_ERROR = 0,
X
X  INPUT_ALERT,
X  INPUT_ASSIGN,
X  INPUT_AUTOPASS,
X  INPUT_BELL,
X  INPUT_CC,
X
X  INPUT_CCDEF,                                                        /* JAS */
X  INPUT_CLAIM,
X  INPUT_CLS,
X  INPUT_CONNECT,
X  INPUT_DEFAULT,
X
X  INPUT_DISCONNECT,
X  INPUT_DL,
X  INPUT_DOWNLOAD,
X  INPUT_DUP,
X  INPUT_EAST,
X
X  INPUT_EMAIL,
X  INPUT_FORMAL,
X  INPUT_FULLNAME,
X  INPUT_HELP,
X  INPUT_JOIN,
X
X  INPUT_LHB,
X  INPUT_LHO,
X  INPUT_LOAD,
X  INPUT_LOG,
X  INPUT_MESSAGE,
X
X  INPUT_NAME,
X  INPUT_NORTH,
X  INPUT_OBS,
X  INPUT_OBSERVE,
X  INPUT_OPP,
X
X  INPUT_PAUSE,
X  INPUT_PERISH,
X  INPUT_PING,
X  INPUT_PLAYERS,
X  INPUT_PRACTICE,
X
X  INPUT_PROMPT,
X  INPUT_PUBLISH,
X  INPUT_QUIT,
X  INPUT_REPLAY,
X  INPUT_RESET,
X
X  INPUT_RESULTS,
X  INPUT_REVEAL,
X  INPUT_REVIEW,
X  INPUT_RHB,
X  INPUT_RHO,
X
X  INPUT_SAVE,
X  INPUT_SCORE,
X  INPUT_SCOREBOARD,
X  INPUT_SEAT,
X  INPUT_SERVE,
X
X  INPUT_SETCC,
X  INPUT_SKIP,
X  INPUT_SOUTH,
X  INPUT_SPEC,
X  INPUT_TABLE,
X
X  INPUT_TABLES,
X  INPUT_TIMER,
X  INPUT_WAKEUP,
X  INPUT_WEST,
X  INPUT_WHO,
X
X  INPUT_WHOIS,
X  INPUT_ZLOG,
X
X  INPUT_MAX
X    };
X
Xstatic void 
X  Parse_alert_input (), 
X  Parse_assign_input (), 
X  Parse_autopass_input (),
X  Parse_bell_input (), 
X  Parse_cc_input (),
X
X  Parse_ccdef_input (),                                              /* JAS */
X  Parse_claim_input (),
X  Parse_cls_input (),
X  Parse_connect_input (),
X  Parse_default_input(), 
X
X  Parse_disconnect_input (), 
X  Parse_download_input (),
X  Parse_dup_input (),
X  Parse_east_input (), 
X  Parse_email_input (),
X
X  Parse_formal_input (),
X  Parse_fullname_input (),
X  Parse_help_input (), 
X  Parse_join_input (),
X
X  Parse_lho_input (), 
X  Parse_load_input (), 
X  Parse_log_input (),  
X  Parse_message_input (),
X  Parse_name_input (), 
X
X  Parse_north_input (), 
X  Parse_observe_input (),
X  Parse_opp_input (),
X  Parse_pause_input (),
X
X  Parse_perish_input (),
X  Parse_ping_input (), 
X  Parse_players_input (),
X  Parse_practice_input (),
X  Parse_prompt_input (),
X
X  Parse_publish_input (),
X  Parse_quit_input (), 
X  Parse_replay_input (), 
X  Parse_reset_input (), 
X  Parse_results_input (),
X
X  Parse_reveal_input (), 
X  Parse_review_input(), 
X  Parse_rho_input (), 
X  Parse_save_input (), 
X  Parse_score_input (), 
X
X  Parse_scoreboard_input(),
X  Parse_seat_input (), 
X  Parse_serve_input (),
X  Parse_setcc_input (), 
X  Parse_skip_input (),
X
X  Parse_south_input (), 
X  Parse_table_input (),
X  Parse_tables_input (),
X  Parse_timer_input (),
X  Parse_wakeup_input (), 
X
X  Parse_west_input (),
X  Parse_who_input (), 
X  Parse_whois_input (), 
X  Parse_zlog_input ();
X
Xstatic Command_Descriptor Input_Commands [] = {
X  {"ALERT",  C_EMPTY, Parse_alert_input},
X  {"ASSIGN", {{F_NAME, "<player-name>"}, A_SEAT, NOP}, Parse_assign_input},
X  {"AUTOPASS", C_STATE, Parse_autopass_input},
X  {"BELL",   C_STATE, Parse_bell_input},
X  {"CC",     C_PARAM(F_KEYWORD|F_OPTIONAL, "NS|EW|MY|BOTH"), Parse_cc_input},
X
X  {"CCDEF", C_PARAM(F_STRING | F_OPTIONAL, "<cc-def>"), Parse_ccdef_input},
X  {"CLAIM",  C_PARAM(F_INT | F_OPTIONAL, "<no-tricks>"), Parse_claim_input},
X  {"CLS",    C_EMPTY, Parse_cls_input},
X  {"CONNECT",{{F_FILENAME | F_OPTIONAL, "<server-name>"},
X	      {F_INT | F_OPTIONAL, "<port-number>"}, NOP}, 
X     Parse_connect_input},
X  {"DEFAULT", C_STATE, Parse_default_input},
X
X  {"DISCONNECT", C_PARAM(F_NAME, "<player-name>"), Parse_disconnect_input},
X  {"DL",     C_PARAM(F_FILENAME | F_OPTIONAL, "<email-file>"), 
X     Parse_download_input},
X  {"DOWNLOAD",C_PARAM(F_FILENAME | F_OPTIONAL, "<email-file>"), 
X     Parse_download_input},
X  {"DUP",     {{F_KEYWORD | F_OPTIONAL, "MP|IMP|END"}, NOP, NOP}, 
X     Parse_dup_input},
X  {"EAST",   C_EMPTY, Parse_east_input},
X
X  {"EMAIL",  C_PARAM (F_STRING, "<email-address>"), Parse_email_input},
X  {"FORMAL", C_STATE, Parse_formal_input},
X  {"FULLNAME", C_PARAM (F_STRING, "<full-name>"), Parse_fullname_input},
X  {"HELP",   C_PARAM(F_NAME | F_OPTIONAL, "<help-topic-name>"), 
X     Parse_help_input},
X  {"JOIN",   C_PARAM(F_NAME | F_OPTIONAL, "<name-of-server>"), 
X     Parse_join_input},
X
X  {"LHB",    C_PARAM(F_STRING, "<message>"), Parse_rho_input},
X  {"LHO",    C_PARAM(F_STRING, "<message>"), Parse_lho_input},
X  {"LOAD",   C_PARAM(F_FILENAME, "<board-file>"), Parse_load_input},
X  {"LOG",    C_PARAM(F_FILENAME | F_OPTIONAL, "<logfile>"), Parse_log_input},
X  {"MESSAGE",C_PARAM(F_STRING | F_OPTIONAL, "<GPS-message>"), 
X     Parse_message_input},
X
X  {"NAME",   C_PARAM(F_NAME, "<player-name>"), Parse_name_input},
X  {"NORTH",  C_EMPTY, Parse_north_input},
X  {"OBS",    C_EMPTY, Parse_observe_input},
X  {"OBSERVE",C_EMPTY, Parse_observe_input},
X  {"OPP",    C_PARAM(F_STRING, "<message>"), Parse_opp_input},
X
X  {"PAUSE",  C_EMPTY, Parse_pause_input},
X  {"PERISH", C_EMPTY, Parse_perish_input},
X  {"PING",   C_EMPTY, Parse_ping_input},
X  {"PLAYERS",C_PARAM(F_NAME | F_OPTIONAL, "<name-of-server>"), 
X     Parse_players_input},
X  {"PRACTICE", C_STATE, Parse_practice_input},
X  {"PROMPT", C_STATE, Parse_prompt_input},
X
X  {"PUBLISH",C_EMPTY, Parse_publish_input},
X  {"QUIT",   C_EMPTY, Parse_quit_input},
X  {"REPLAY", C_PARAM(F_FILENAME, "<board-file>"), Parse_replay_input},
X  {"RESET",  C_EMPTY, Parse_reset_input},
X  {"RESULTS", C_PARAM(F_FILENAME | F_OPTIONAL, "<results-file-name>"), 
X     Parse_results_input},
X
X  {"REVEAL", C_PARAM(F_NAME | F_OPTIONAL, "<player-name>"),
X     Parse_reveal_input},
X  {"REVIEW", C_EMPTY, Parse_review_input},
X  {"RHB",    C_PARAM(F_STRING, "<message>"), Parse_lho_input},
X  {"RHO",    C_PARAM(F_STRING, "<message>"), Parse_rho_input},
X  {"SAVE",   C_PARAM(F_FILENAME | F_OPTIONAL, "<board-file>"), 
X     Parse_save_input},
X
X  {"SCORE",  C_PARAM(F_KEYWORD, PARSER_SCORE), Parse_score_input},
X  {"SCOREBOARD", C_EMPTY, Parse_scoreboard_input},
X  {"SEAT",   C_SEAT, Parse_seat_input},
X  {"SERVE",  C_PARAM(F_INT | F_OPTIONAL, "<port-number>"), Parse_serve_input},
X  {"SETCC",  C_PARAM(F_STRING | F_OPTIONAL, "<convention-card>"), 
X     Parse_setcc_input},
X
X  {"SKIP",   C_PARAM(F_INT | F_OPTIONAL, "<skip-count>"), Parse_skip_input},
X  {"SOUTH",  C_EMPTY, Parse_south_input},
X  {"SPEC",   C_PARAM(F_NAME | F_OPTIONAL, "<player-name>"),
X     Parse_reveal_input},
X  {"TABLE",  C_PARAM(F_INT, "<table-number>"), Parse_table_input},
X  {"TABLES", C_EMPTY, Parse_tables_input},
X
X  {"TIMER",  C_STATE, Parse_timer_input},
X  {"WAKEUP", C_PARAM(F_NAME | F_OPTIONAL, "<player-name> | ALL"), 
X     Parse_wakeup_input},
X  {"WEST",   C_EMPTY, Parse_west_input},
X  {"WHO",    C_EMPTY, Parse_who_input},
X  {"WHOIS",  C_PARAM(F_NAME | F_OPTIONAL, "<player-name>"), Parse_whois_input},
X
X  {"ZLOG",   C_PARAM(F_FILENAME | F_OPTIONAL, "<logfile>"), Parse_zlog_input},
X  END_PARSE_TABLE
X};
X
Xchar *autoload_file = NULL;     /* The name of the file from which we
X				   will initially try to load a sequence
X				   of boards, if we are north in email mode. */
Xchar *autosave_file = NULL;     /* The name of the file to which we will
X				   automatically save the boards that we
X				   have played. */
X
Xint claim_in_progress = 0;      /* TRUE if we are currently processing a
X				   claim request.  This blocks us from making
X				   another claim. */
X
Xextern FILE *logfile;
Xextern FILE *zhang_logfile;
X
Xextern char *email_error_message;
Xextern int server_mode;
X
Xextern char *Get_CC_Value();                                          /* JAS */
Xextern int Define_CC();                                               /* JAS */
Xextern void Display_All_CCs();                                        /* JAS */
X
Xextern int No_connections ();
X
Xextern int timer_is_on;
Xextern struct timeval ping_start;
X
Xstatic char msg_buf[100];         /* A buffer for error messages. */
X
Xstatic void load_email_file (filename)
X     char *filename;
X/* Attempts to read a sequence of deals from the email duplicate file
X . with name filename.
X */
X{
X  FILE *f = fopen (filename, "r");
X  int status;
X
X  if (f == NULL) {
X    sprintf (msg_buf, "COULD NOT OPEN FILE %s: %s", filename, 
X	     sys_errlist[errno]);
X    Status (msg_buf);
X    return;
X  }
X
X  Clear_All_Boards ();
X  if (gps_duplicate_mode)
X    GPS_Dup ("END");
X  gps_duplicate_mode = 0;
X  status = Load_Email_Duplicate_File (f);
X  fclose (f);
X  if (status == 1) {
X    sprintf (msg_buf, "%s IS NOT AN EMAIL DUPLICATE FILE.", filename);
X    Status (msg_buf);
X    replay_mode = 0;
X  } else if (status) {
X    sprintf (msg_buf, "ERROR READING %s.", filename);
X    Status (msg_buf);
X    replay_mode = 0;
X  } else {
X    Send_skip (Local_table);
X    sprintf (msg_buf, "LOADED EMAIL BOARDS FROM %s.", filename);
X    Moderator_Comment (msg_buf);
X    email_filename = strdup (filename);
X  }
X
X}
X
Xstatic void save_email_file (filename)
X     char *filename;
X{
X  FILE *f = fopen (filename, "w");
X
X  if (f == NULL) {
X    sprintf (msg_buf, "COULD NOT OPEN FILE %s: %s", filename, 
X	     sys_errlist[errno]);
X    Status (msg_buf);
X    return;
X  }
X
X  Write_Email_Duplicate_File (f);
X  fclose (f);
X
X  sprintf (msg_buf, "SAVED EMAIL BOARDS TO %s.", filename);
X  Moderator_Comment (msg_buf);
X}
X
Xvoid Review_Bidding ()
X/* Generates a review of the bidding. */
X{
X  int mode = Local_table->game_mode;
X  int current_input_mode = input_mode;
X  int current_display_mode = display_mode;
X
X  if (FORMAL(Local_table))
X    Status ("THE BIDDING CANNOT BE REVIEW DURING FORMAL PLAY.");
X  else if ((mode == PLAYING_MODE) || (mode == SCORING_MODE)) {
X    Set_Display_Mode (BIDDING_DISPLAY);
X    Set_Input_Mode (TALK_INPUT);
X    Pause ("PRESS <ESC> TO RETURN TO PLAY ...");
X    Set_Display_Mode (current_display_mode);
X    Set_Input_Mode (current_input_mode);
X  } else 
X    Status ("THE BIDDING CANNOT BE REVIEWED NOW.");
X  
X  Refresh_Input_Buffers ();
X}
X
Xstatic int Partner_has_bid (t, b, p, player)
X     Table t;
X     Board *b;
X     Play_record *p;
X     int player;
X/* Returns true if the partner of p has bid. */
X{
X  int partner = player_partner[player];
X  int i, bidder;
X
X  if (p->no_bids > 3)
X    return (1);
X
X  bidder = b->dealer;
X  for (i = 0; i < p->no_bids; i++)
X    if (bidder == partner)
X      return (1);
X    else
X      bidder = player_next [bidder];
X
X  return (0);
X}
X
Xstatic void Parse_alert_input ()
X/* ALERT
X . Sends an alert message showing that partner's most recent bid is unusual.
X */
X{
X  if (IS_OBSERVER(local_player))
X    Status ("OBSERVERS MAY NOT USE THE ALERT COMMAND.");
X  else if (Local_table->game_mode != BIDDING_MODE)
X    Status ("YOU MAY ONLY ALERT DURING BIDDING MODE.");
X  else if (!Partner_has_bid (Local_table,Local_board,Local_play,local_player))
X    Status ("YOUR PARTNER HAS NOT BID YET.");
X  else
X    Send_alert (Local_table, !FORMAL(Local_table));
X
X}
X
Xstatic void Parse_assign_input (player, seat)
X     char *player; int *seat;
X{
X  Connection c;
X
X  if (!server_mode) {
X    Status ("ONLY THE SERVER CAN USE THE /ASSIGN COMMAND.");
X    return;
X  }
X
X  FOREACH_PLAYER(c, Local_table) {
X    if (!strcasecmp(player, c->player_name))
X      break;
X  }
X
X  if (c == NULL) {
X    sprintf (msg_buf, "THERE IS NO PLAYER NAMED %s", player);
X    Status (msg_buf);
X    return;
X  }
X
X  if (IS_PLAYER(*seat) && OCCUPIED(Local_table, *seat)) {
X    sprintf (msg_buf, "THE %s SEAT IS ALREADY OCCUPIED.", seat_names[*seat]);
X    Status (msg_buf);
X    return;
X  }
X
X  sprintf (msg_buf, "%s %s SEATREQ %s", seat_names[c->seat], c->player_name,
X	   seat_names[*seat]);
X  loopback_message_unformatted (c->table, c, msg_buf);
X}
X
Xstatic void Parse_autopass_input (a)
X     int *a;
X/* AUTOPASS [ON|OFF]
X . The AUTOPASS command controls whether or not the moderator will 
X . automatically provide "PASS" bids for absent players during practice mode.
X */
X{
X  if (client_mode) {
X    Status ("ONLY THE SERVER MAY SPECIFY THE AUTOPASS MODE.");
X    return;
X  }
X
X  if (a != NULL) autopass_mode = *a;
X  sprintf (msg_buf, "AUTOPASS MODE IS NOW %s.", autopass_mode? "ON": "OFF");
X  Moderator_Comment (msg_buf);
X}
X
Xstatic void Parse_bell_input (b)
X     int *b;
X/* BELL [ON|OFF]
X . The BELL command updates the state of the bell and/or displays its
X . current state.  
X */
X{
X  if (b != NULL) bell_is_on = *b;
X  sprintf (msg_buf, "THE BELL IS NOW %s.", bell_is_on? "ON": "OFF");
X  Moderator_Comment (msg_buf);
X  ring_bell ();
X}
X
X
Xstatic void Parse_cc_input (whose)
X     int *whose;
X{
X  int they;
X
X  if (whose == NULL) {
X    if (local_player < 4) {
X      they = side_of(player_next[local_player]);
X      if (conventions[they] == NULL)
X	Status ("THEY HAVE NOT SPECIFIED THEIR CONVENTION CARD YET.");
X      else
X	Status (conventions[they]);
X    } else {
X      if ((conventions[0] == NULL) && (conventions[1] == NULL))
X	Status
X	  ("NEITHER SIDE HAS SPECIFIED A CONVENTION CARD YET.");
X      else {
X	if (conventions[0] != NULL)
X	  Display_Player_Comment (COMMENT_PUBLIC, "N-S", conventions[0]);
X	if (conventions[1] != NULL)
X	  Display_Player_Comment (COMMENT_PUBLIC, "E-W", conventions[1]);
X      }
X    }
X  } else {
X    if (*whose < 2) {
X      if (conventions[*whose] == NULL) {
X	sprintf (msg_buf, "%s %s", *whose? "E-W": "N-S",
X		 "HAVE NOT SPECIFIED THEIR CONVENTION CARD YET.");
X	Status (msg_buf);
X      } else
X	Status (conventions[*whose]);
X    } else if (*whose == 2) {
X      if (local_cc == NULL)
X	Status ("YOU HAVE NOT SPECIFIED YOUR CONVENTION CARD YET.");
X      else
X	Status (local_cc);
X    } else {
X      if ((conventions[0] == NULL) && (conventions[1] == NULL))
X	Status
X	  ("NEITHER SIDE HAS SPECIFIED A CONVENTION CARD YET.");
X      else {
X	if (conventions[0] != NULL)
X	  Display_Player_Comment (COMMENT_PUBLIC, "N-S", conventions[0]);
X	if (conventions[1] != NULL)
X	  Display_Player_Comment (COMMENT_PUBLIC, "E-W", conventions[1]);
X      }
X    }
X  }
X
X}
X
X
Xstatic void Parse_ccdef_input(cc)                                 /* JAS */
X     char *cc;
X{
X  if (!cc)
X  {
X    Display_All_CCs(Moderator_Comment);
X  }
X  else
X  {
X    if (Define_CC(cc, Status))
X    {
X      /* returns 1 on error */
X      sprintf (msg_buf, "ERROR DEFINING CC: %s", cc);
X      Status (msg_buf);
X    }
X  }
X}
X
Xstatic int  Claim_responses_received_event ()
X{
X  return (claim_responses == 2);
X}
X
Xstatic void Parse_claim_input (n)
X     int *n;
X/* CLAIM [n]
X . The CLAIM command is used by declarer to finish the hand early,
X . claiming an additional number of tricks.  If n is omitted, then
X . all remaining tricks are claimed.
X */
X{
X  int tricks_claimed;
X  int tricks_played = Local_play->tricks[0] + Local_play->tricks[1];
X
X  if (Local_table->game_mode != PLAYING_MODE) {
X    Status ("YOU MAY ONLY CLAIM DURING THE PLAY OF THE HAND.");
X    return;
X  } else if ((Local_table->playing_mode != PRACTICE_PLAYING_MODE) &&
X	     (Local_play->declarer != local_player)) {
X    Status ("ONLY THE DECLARER MAY MAKE A CLAIM.");
X    return;
X  } else if (claim_in_progress) {
X    Status ("A CLAIM IS ALREADY IN PROGRESS.  YOU MUST WAIT TO CLAIM AGAIN.");
X    return;
X  }
X
X  if (n == NULL)
X    tricks_claimed = 13 - tricks_played;
X  else if (*n >= 0)
X    tricks_claimed = *n;
X  else
X    tricks_claimed = 13 - tricks_played + *n;
X
X  if ((tricks_claimed < 0) || (tricks_claimed + tricks_played > 13)) {
X    sprintf (msg_buf, "ILLEGAL CLAIM -- YOU MAY CLAIM UP TO %d TRICKS.",
X	     13 - tricks_played);
X    Status (msg_buf);
X    return;
X  }
X
X  if (Local_table->playing_mode == PRACTICE_PLAYING_MODE) {
X    Send_claim (Local_table, tricks_claimed);
X    return;
X  }
X
X  claim_in_progress = 1;
X  Send_claimreq (Local_table, tricks_claimed);
X  Status ("WAITING FOR A REPLY TO YOUR CLAIM ...");
X  Clear_Focus_Buffer ();
X  Set_Input_Mode (TALK_INPUT);
X
X  Refresh_Input_Buffers ();
X  Wait_for_event_at_game_level (Claim_responses_received_event);
X
X  Set_Input_Mode (PLAY_INPUT);
X
X  if (claim_accepted) {
X    Clear_Status ();
X    Send_claim (Local_table, tricks_claimed);
X  }
X
X  claim_in_progress = 0;
X}
X
Xstatic void Parse_cls_input ()
X{
X  Clear_Comment_Display ();
X}
X
Xstatic void Parse_connect_input (s, p)
X     char *s; int *p;
X/* CONNECT [server] [ip]
X . The CONNECT command is used by a client to establish a connection
X . with a server. 
X */
X{
X
X  if ((s == NULL) && (server_name == NULL)) {
X    Status ("YOU MUST SPECIFY THE SERVER TO WHICH TO CONNECT.");
X    return;
X  }
X
X  if (server_mode && (No_connections(Local_table) > 1)) {
X    Moderator_Comment 
X      ("WARNING! THIS WILL DISCONNECT THE PLAYERS AT THIS TABLE!");
X    if (!Ask("ARE YOU SURE YOU WISH TO DO THIS? "))
X	return;
X  } else if (client_mode && (Local_table->game_mode != STARTUP_MODE) &&
X	     IS_PLAYER(local_player)) {
X    Moderator_Comment
X      ("WARNING! THIS WILL DISCONNECT YOU FROM THIS TABLE!");
X    if (!Ask("ARE YOU SURE YOU WISH TO DO THIS? "))
X      return;
X  }
X
X  if (client_mode)
X    Send_quit (Local_table);
X
X  if (p != NULL)
X    network_port = *p;
X  else
X    network_port = DEFAULT_PORT;
X
X  if (s != NULL)
X    server_name = strdup (s);
X
X  Generate_reset (RESET_CONNECT);
X}
X
X/*
Xstatic void Parse_deal_input (d)
X     int *d;
X.* DEAL [n]
X . If we are the server in email duplicate mode, then deals n hands
X . for play.  If n is negative, then deals continuously, i.e., until
X . the program is terminated or a reset is given.  If n is zero, then
X . deals 16 hands.
X *.
X{
X  if (total_no_deals < 0)
X    Moderator_Comment ("ENTERING CONTINUOUS DEAL MODE.");
X  else {
X    sprintf (msg_buf, "BEGINNING A SEQUENCE OF %d DEALS.", total_no_deals);
X    Moderator_Comment (msg_buf);
X  }
X  replaying_mode = 0;
X  current_board = NULL;
X}
X*/
X
Xstatic void Parse_default_input (d)
X     int *d;
X/* DEFAULT [ON|OFF]
X . The DEFAULT command controls whether or not default inputs will be
X . automatically provided for the user.  
X */
X{
X  if (d != NULL) default_plays = *d;
X  sprintf (msg_buf, "DEFAULT MODE IS NOW %s", default_plays? "ON": "OFF");
X  Moderator_Comment (msg_buf);
X}
X
Xstatic void Parse_download_input (d)
X     char *d;
X/* DOWNLOAD [<email-filename>]
X . Downloads an email duplicate file from the GPS or requests a list of
X . the available email duplicate files.
X */
X{
X  if (d == NULL)
X    GPS_Directory ();
X  else
X    GPS_Download (d);
X}
X
Xstatic void Parse_dup_input (mode)
X     int *mode;
X/* DUP [MP|IMP|END]
X . Initiates or terminates GPS duplicate mode.
X */
X{
X  if (!server_mode) {
X    Status ("ONLY THE SERVER MAY REQUEST GPS DUPLICATE MODE.");
X    return;
X  }
X
X  if ((mode != NULL) && (*mode == 2)) {
X    if (gps_duplicate_mode) {
X      GPS_Dup ("END");
X      gps_duplicate_mode = 0;
X      if ((Local_table->game_mode == BIDDING_MODE) ||
X	  (Local_table->game_mode == PLAYING_MODE))
X	Send_skip (Local_table);
X    }
X    return;
X  }
X
X  Local_table->playing_mode = CLUB_PLAYING_MODE;
X  if ((mode == NULL) || (*mode == 1))
X    GPS_Dup ("IMP");
X  else
X    GPS_Dup ("MP");
X  gps_duplicate_mode = 1;
X
X  Local_table->above_line[SIDE_NS] = Local_table->above_line[SIDE_EW] = 0;
X  Local_table->below_line[SIDE_NS] = Local_table->below_line[SIDE_EW] = 0;
X
X  if ((Local_table->game_mode != STARTUP_MODE) &&
X      (Local_table->game_mode != SCORING_MODE))
X    Send_skip (Local_table);
X}
X     
Xstatic void Parse_disconnect_input (player)
X     char *player;
X{
X  Connection p;
X
X  if (!server_mode) {
X    Status ("THE DISCONNECT COMMAND CAN ONLY BE USED BY THE SERVER.");
X    return;
X  }
X
X  if (!strcasecmp(player, "NORTH"))
X    p = Local_table->Seats[PLAYER_NORTH].connection;
X  else if (!strcasecmp(player, "EAST"))
X    p = Local_table->Seats[PLAYER_EAST].connection;
X  else if (!strcasecmp(player, "SOUTH"))
X    p = Local_table->Seats[PLAYER_SOUTH].connection;
X  else if (!strcasecmp(player, "WEST"))
X    p = Local_table->Seats[PLAYER_WEST].connection;
X  else {
X    FOREACH_CONNECTION (p)
X      if (!strcasecmp(player, p->player_name))
X	break;
X    if (p == NULL) {
X      sprintf (msg_buf, "THERE IS NO PLAYER NAMED %s", player);
X      Status (msg_buf);
X      return;
X    }
X  }
X
X  if (p == NULL) {
X    sprintf (msg_buf, "THE %s SEAT IS NOT CURRENTLY OCCUPIED.", player);
X    Status (msg_buf);
X    return;
X  }
X
X  if (p->local) {
X    Status ("YOU CANNOT DISCONNECT YOURSELF!");
X    return;
X  }
X
X  sprintf (msg_buf, "THE CONNECTION WITH %s HAS BEEN CLOSED.",p->player_name);
X  close_connection (p);
X  Broadcast_Comment (msg_buf);
X}
X
Xstatic void Parse_email_input (a)
X     char *a;
X/* EMAIL <email-address>
X * Specifies the local player's email address.
X */
X{
X  if (local_player_email != NULL)
X    free (local_player_email);
X
X  local_player_email = strdup (a);
X  sprintf (msg_buf, "YOUR EMAIL ADDRESS IS NOW %s.", a);
X  Status (msg_buf);
X  Send_email (Local_table, local_player_email);
X}
X
Xstatic void Set_playing_mode (m)
X     int m;
X/* If m is -1, then displays the current playing mode.  Otherwise,
X * if we are the server, then sets the current playing mode to *m.
X */
X{
X  Clear_Focus_Buffer ();
X
X  if ((m == -1) || (m == Local_table->playing_mode)) {
X    switch (Local_table->playing_mode) {
X    case CLUB_PLAYING_MODE:
X      Status ("WE ARE PLAYING CLUB STYLE BRIDGE.");
X      return;
X    case PRACTICE_PLAYING_MODE:
X      Status ("WE ARE PLAYING PRACTICE HANDS.");
X      return;
X    case FORMAL_PLAYING_MODE:
X      Status ("WE ARE PLAYING FORMAL BRIDGE.");
X      return;
X    }
X  }
X
X  if (client_mode) {
X    Status ("ONLY THE SERVER MAY CHANGE THE PLAYING MODE.");
X    return;
X  }
X
X  if ((Local_table->game_mode == BIDDING_MODE) || 
X      (Local_table->game_mode == PLAYING_MODE))
X    if (!Ask("THIS WILL END THE CURRENT HAND.  DO YOU WISH TO DO THIS? "))
X      return;
X
X  Local_table->playing_mode = m;
X  Send_skip (Local_table);
X}
X
Xstatic void Parse_formal_input (f)
X     int *f;
X/* FORMAL [ON|OFF]
X . The formal command controls whether talk messages are sent to all of
X . the other players or just to the opponents.
X */
X{
X  if (f == NULL)
X    Set_playing_mode (FORMAL_PLAYING_MODE);
X  else
X    Set_playing_mode (*f? FORMAL_PLAYING_MODE: CLUB_PLAYING_MODE);
X}
X
Xstatic void Parse_fullname_input (f)
X     char *f;
X/* FULLNAME <player-full-name>
X * Specifies the player's full name. 
X */
X{
X  if (local_player_full_name != NULL)
X    free (local_player_full_name);
X
X  local_player_full_name = strdup (f);
X  sprintf (User_fullname, "%s", f);
X  Status ("YOUR FULL NAME HAS BEEN SET.");
X  Send_fullname (Local_table, User_fullname);
X}
X
Xstatic int Exit_help_mode_event ()
X{
X  return (!pause_mode);
X}
X
Xstatic void Parse_help_input (t)
X     char *t;
X/* HELP [<help-topic-name>]
X . Gives help on the named topic, or a general description of the program
X . if no topic is specified.
X */
X{
X  int input_save = input_mode;
X  int display_save = display_mode;
X
X  Clear_Focus_Buffer ();
X  Set_Display_Mode (HELP_DISPLAY);
X  Set_Input_Mode (TALK_INPUT);
X  if (t != NULL)
X    display_help (t);
X  else {
X    Lock_Status ("TYPE THE NAME OF A TOPIC OR PRESS <ESC> TO EXIT HELP.");
X    browse_help ("");
X    Refresh_Input_Buffers ();
X    pause_mode = 1;
X    Wait_for_event_at_game_level (Exit_help_mode_event);
X    Unlock_Status ();
X  }
X  Set_Display_Mode (display_save);
X  Set_Input_Mode (input_save);
X
X}
X
Xstatic void Parse_join_input (s)
X     char *s;
X/* JOIN [<server-name>]
X . Joins the table being served by the named person.  If the server-name
X . is omitted, then joins the most recently opened table.
X */
X{
X  char server_ip_buf[60];
X  int server_port, status;
X
X  status = GPS_Get_Server_IP (s, server_ip_buf, &server_port);
X  if (status) {
X    if (s == NULL)
X      Status ("THERE ARE NO TABLES CURRENTLY BEING SERVED.");
X    else
X      Status ("NO TABLE IS BEING HOSTED BY THAT PERSON.");
X    return;
X  }
X
X  if (server_mode && (No_connections(Local_table) > 1)) {
X    Moderator_Comment 
X      ("WARNING! THIS WILL DISCONNECT THE PLAYERS AT THIS TABLE!");
X    if (!Ask("ARE YOU SURE YOU WISH TO DO THIS? "))
X	return;
X  } else if (client_mode && (Local_table->game_mode != STARTUP_MODE) &&
X	     IS_PLAYER(local_player)) {
X    Moderator_Comment
X      ("WARNING! THIS WILL DISCONNECT YOU FROM THIS TABLE!");
X    if (!Ask("ARE YOU SURE YOU WISH TO DO THIS? "))
X      return;
X  }
X
X  if (client_mode)
X    Send_quit (Local_table);
X
X  network_port = server_port;
X  server_name = strdup (server_ip_buf);
X
X  Generate_reset (RESET_CONNECT);
X}
X
Xstatic void Parse_lho_input (m)
X     char *m;
X/* LHO <message>
X . Sends a message to the left-hand opponent.
X */
X{
X  if (IS_OBSERVER(local_player))
X    Status ("PRIVATE MESSAGES CANNOT BE SENT BY AN OBSERVER.");
X  else {
X    Display_Player_Comment (COMMENT_PRIVATE, local_player_name, m);
X    Send_talk (Local_table, TALK_RCPT_LHO, m);
X  }
X}
X
Xstatic void Parse_load_input (f)
X     char *f;
X/* LOAD <filename>
X . The LOAD command is used by the server to LOAD a sequence of email
X . boards from a file.  
X */
X{
X  if (client_mode) {
X    Status ("CLIENTS CANNOT LOAD EMAIL BOARDS.");
X    return;
X  }
X
X  if (gps_duplicate_mode)
X    GPS_Dup ("END");
X  replay_mode = gps_duplicate_mode = 0;
X  load_email_file (f);
X}
X
Xstatic void Parse_log_input (f)
X     char *f;
X/* LOG <filename>
X . The LOG command opens a file to which the results of play will be
X . recorded, or it closes a currently open logfile if no filename is
X . specified.  
X */
X{
X  char *filename;
X
X  if (f == NULL) {
X    if (logfile == NULL)
X      Moderator_Comment ("THERE IS NO OPEN LOGFILE.");
X    else {
X      fclose (logfile);
X      logfile = NULL;
X      Moderator_Comment ("THE LOG FILE HAS BEEN CLOSED.");
X    }
X    return;
X  } else {
X    if (logfile != NULL) fclose (logfile);
X    if (f[0] == '+') {
X      filename = f + 1;
X      logfile = fopen (filename, "a");
X    } else {
X      filename = f;
X      logfile = fopen (filename, "w");
X    }
X    if (logfile == NULL) {
X      sprintf (msg_buf, "%s ERROR OPENING %s",
X	       sys_errlist[errno], filename);
X      Moderator_Comment (msg_buf);
X    } else {
X      sprintf (msg_buf, "NOW LOGGING TO %s", filename);
X      Moderator_Comment (msg_buf);
X    }
X  }
X}
X
Xstatic void Parse_message_input (m)
X     char *m;
X/* MESSAGE [<GPS-message>]
X *  If we are in server mode, sends a message to the GPS which will be
X *  displayed with our table announcement.
X */
X{
X  if (!server_mode) {
X    Status 
X      ("YOU CANNOT SEND A GPS MESSAGE UNLESS YOU ARE IN SERVER MODE.");
X    return;
X  }
X
X  if (GPS_unavailable || !Use_GPS) {
X    Status
X      ("THE GLOBAL PLAYER SERVICE IS CURRENTLY UNAVAILABLE.");
X    return;
X  }
X
X  GPS_Advertise_Message (m);
X}
X
Xstatic void Parse_name_input (m)
X     char *m;
X/* NAME <new-name>
X *   changes the name of the local player to <new-name>
X */
X{
X  char *s;
X
X  if (spectator_mode) {
X    Status ("YOU CANNOT CHANGE YOUR NAME DURING SPECTATOR MODE.");
X    return;
X  }
X
X  s = strdup (m);
X  if (strlen(s) > 8) s[8] = '\0';
X
X  Clear_Focus_Buffer ();
X  Send_name (Local_table, s);
X  GPS_Change_Name (local_player_name, s);
X  local_player_name = s;
X  sprintf (Local_Player_Connection->player_name, "%s", s);
X
X/*
X  if (IS_PLAYER(local_player)) {
X    sprintf (PLAYER_NAME(Local_table, local_player), "%s", s);
X  } else {
X    sprintf (msg_buf, "YOUR NEW NAME IS %s", local_player_name);
X    Moderator_Comment (msg_buf);
X  }
X*/
X}
X
Xstatic void Parse_opp_input (m)
X     char *m;
X/* OPP <message>
X . Sends a message to (both of) the opponents.
X */
X{
X  if (IS_OBSERVER(local_player))
X    Status ("PRIVATE MESSAGES CANNOT BE SENT BY AN OBSERVER.");
X  else {
X/*    Display_Player_Comment (COMMENT_FORMAL, local_player_name, m); */
X    Send_talk (Local_table, TALK_RCPT_OPPS, m);
X  }
X}
X
Xstatic void Parse_pause_input ()
X/* PAUSE
X . Returns to full screen talk mode if we are not already there.
X */
X{
X  int d = display_mode;
X  int i = input_mode;
X  
X  Clear_Focus_Buffer ();
X  if (display_mode != TALK_DISPLAY) {
X    Set_Display_Mode (TALK_DISPLAY);
X    Set_Input_Mode (TALK_INPUT);
X    Pause ("");
X    Set_Display_Mode (d);
X    Set_Input_Mode (i);
X  }
X  Clear_Status ();
X}
X
Xstatic void Parse_perish_input ()
X/* PERISH
X . Discontinues use of the GPS.  If we are a server, we will delete
X . our table from the database.
X */
X{
X  if (server_mode)
X    GPS_End_Server_Mode ();
X
X  Use_GPS = 0;
X}
X
Xstatic void Parse_ping_input ()
X/* PING
X . Sends a message to each of the other players, which is automatically
X . echoed.  The time delay until the echo's are received is reported.
X */
X{
X  gettimeofday (&ping_start, NULL);
X  Send_ping (Local_table);
X}
X
Xstatic void Parse_players_input (s)
X     char *s;
X/* PLAYERS <table-name>
X . Lists the players at the given table.
X */
X{
X  Clear_Focus_Buffer ();
X  GPS_List_Players (s);
X}
X
Xstatic void Parse_practice_input (p)
X     int *p;
X/* PRACTICE [ON|OFF]
X . Practice mode is used for partnerships to practice bidding and planning
X . play.
X */
X{
X  if (p == NULL)
X    Set_playing_mode (PRACTICE_PLAYING_MODE);
X  else
X    Set_playing_mode (*p? PRACTICE_PLAYING_MODE: CLUB_PLAYING_MODE);
X}
X
Xstatic void Parse_prompt_input (p)
X     int *p;
X/* PROMPT [ON|OFF]
X . Changes or displays whether the dummy is always prompted after each
X . trick has been played.
X */
X{
X  if (p != NULL) prompt_dummy = *p;
X  sprintf (msg_buf,  "THE DUMMY %s BE PROMPTED AFTER EACH TRICK",
X	   prompt_dummy? "WILL": "WILL NOT");
X  Moderator_Comment (msg_buf);
X}
X
Xstatic void Parse_publish_input ()
X/* PUBLISH
X . Resumes use of the GPS.  If we are a server, publishes our table
X . in the global GPS database.
X */
X{
X  Use_GPS = 1;
X  GPS_unavailable = 0;
X
X  if (server_mode)
X    GPS_Broadcast_Server ();
X}
X
Xstatic void Parse_quit_input ()
X/* QUIT
X . Terminates the program.
X */
X{
X  Quit_program ();
X}
X
Xstatic void Parse_replay_input (f)
X     char *f;
X/* REPLAY <filename>
X . Loads a sequence of email boards from the file f.  After they have been
X . played, writes the results back to f.
X */
X{
X  if (client_mode) {
X    Status ("CLIENTS CANNOT LOAD EMAIL BOARDS.");
X    return;
X  }
X
X  replay_mode = 1;
X  if (gps_duplicate_mode)
X    GPS_Dup ("END");
X  gps_duplicate_mode = 0;
X  load_email_file (f);
X}
X
Xstatic void Parse_reset_input ()
X/* RESET
X . Resets the state of the program.
X */
X{
X  Connection c;
X  Table t;
X
X  if (client_mode) {
X    Status ("CLIENTS MAY NOT USE THE /RESET COMMAND.");
X    return;
X  }
X
X  for (t = Table_List; t != NULL; t = t->next)
X    Send_reset (t);
X
X  FOREACH_CONNECTION (c)
X    if (!c->local)
X      Assign_seat (c->table, c, PLAYER_OBS);
X
X}
X
Xstatic void Parse_results_input (results_file)
X     char *results_file;
X{
X  FILE *rf;
X  Cipher c;
X  Board *results_list, *b;
X  int current_display_mode = display_mode;
X  int current_input_mode = input_mode;
X
X  if (results_file != NULL) {
X    rf = fopen (results_file, "w");
X    if (rf == NULL) {
X      sprintf (msg_buf, "ERROR OPENING RESULTS FILE %s: %s", results_file,
X	       sys_errlist[errno]);
X      Status (msg_buf);
X      return;
X    }
X  } else
X    rf = NULL;
X
X  Clear_Focus_Buffer ();
X  Status ("DOWNLOADING RESULTS OF PLAY FROM GPS ...");
X  restore_cursor ();
X  results_list = GPS_Download_Results (local_player_name);
X  Clear_Status ();
X
X  if (results_list == NULL) {
X    Status ("NO RESULTS ARE AVAILABLE FOR YOU.");
X    if (rf != NULL)
X      fclose (rf);
X    return;
X  }
X
X  if (rf != NULL) {
X    sprintf (msg_buf, "WRITING RESULTS OF DUPLICATE PLAY TO %s ...", 
X	     results_file);
X    Moderator_Comment (msg_buf);
X
X    Write_Email_Header (rf);
X    Create_Cipher_Descriptor (rf, &c);
X    Write_Cipher_Descriptor (rf, &c);
X
X    for (b = results_list; b != NULL; b = b->next)
X      Write_Email_Board (rf, &c, b);
X
X    fclose (rf);
X
X    if (!Ask("DO YOU WISH TO SEE A DISPLAY OF THE RESULTS? ")) {
X      Erase_board_list (&results_list);
X      return;
X    }
X  }
X
X  for (b = results_list; b != NULL; b = b->next) {
X    if ((b->play_records != NULL) && (b->play_records->next != NULL)) {
X      Display_First_Page_of_Scores (b);
X      Pause ("PRESS <ESC> TO SEE THE NEXT PAGE OF RESULTS ...");
X      while (More_Scores_to_Display ()) {
X	Display_More_Scores ();
X	Pause ("PRESS <ESC> TO SEE THE NEXT PAGE OF RESULTS ...");
X      }
X    }
X  }
X
X  Erase_board_list (&results_list);
X  Set_Display_Mode (current_display_mode);
X  Set_Input_Mode (current_input_mode);
X}
X
Xstatic void Reveal_hand (position)
X     int position;
X/* Reveals to the observer the contents of the hand held by 'position' */
X{
X  hand h;
X
X  if (!spectator_mode) {
X    spectator_mode = 1;
X    Send_spec (Local_table);
X    if (!PRACTICE(Local_table))
X      Status ("YOU MAY ONLY TALK TO OTHER SPECTATORS NOW.");
X    Display_Player_Position ();
X  }
X    
X  revealed_bidder = position;
X  revealed_hands[position] = 1;
X  
X  if (Local_table->game_mode == PLAYING_MODE)
X    Display_Hand (position);
X  else if (Local_table->game_mode == BIDDING_MODE) {
X    Generate_holdings (Local_board, Local_play->play_list, 0, position, h);
X    Display_Hand_for_Bidding (position, h);
X  }
X
X}
X
Xstatic void Parse_reveal_input (player)
X     char *player;
X{
X  int i, known;
X  int game_mode = Local_table->game_mode;
X
X  if (IS_PLAYER(local_player)) {
X    if (game_mode != PLAYING_MODE) {
X      Status ("YOU MAY NOT ENTER SPECTATOR MODE IF YOU ARE PLAYING.");
X      return;
X    } else if (local_player != player_partner[Local_play->declarer]) {
X      Status 
X	("ONLY THE OBSERVER AND THE DUMMY MAY SEE OTHER PLAYER'S HANDS!");
X      return;
X    }
X  }
X
X  if ((game_mode != BIDDING_MODE) && (game_mode != PLAYING_MODE)) {
X    Status ("YOU WILL NOT BE ABLE TO SEE ANYTHING UNTIL NEXT HAND.");
X    return;
X  }
X
X  if (FORMAL(Local_table)) {
X    Status ("YOU MAY NOT SEE THE PLAYER'S HANDS DURING FORMAL PLAY.");
X    return;
X  }
X
X  if (player == NULL) {
X    Reveal_hand (PLAYER_WEST);
X    Reveal_hand (PLAYER_SOUTH);
X    Reveal_hand (PLAYER_EAST);
X    Reveal_hand (PLAYER_NORTH);
X  } else if (!strcasecmp(player, "NORTH") || !strcasecmp(player, "N"))
X    Reveal_hand (PLAYER_NORTH);
X  else if (!strcasecmp(player, "EAST") || !strcasecmp(player, "E"))
X    Reveal_hand (PLAYER_EAST);
X  else if (!strcasecmp(player, "SOUTH") || !strcasecmp(player, "S"))
X    Reveal_hand (PLAYER_SOUTH);
X  else if (!strcasecmp(player, "WEST") || !strcasecmp(player, "W"))
X    Reveal_hand (PLAYER_WEST);
X  else if (!strcasecmp(player, "NE") || !strcasecmp(player, "EN")) {
X    Reveal_hand (PLAYER_EAST);
X    Reveal_hand (PLAYER_NORTH);
X  } else if (!strcasecmp(player, "NS") || !strcasecmp(player, "SN")) {
X    Reveal_hand (PLAYER_SOUTH);
X    Reveal_hand (PLAYER_NORTH);
X  } else if (!strcasecmp(player, "NW") || !strcasecmp(player, "WN")) {
X    Reveal_hand (PLAYER_WEST);
X    Reveal_hand (PLAYER_NORTH);
X  } else if (!strcasecmp(player, "SE") || !strcasecmp(player, "ES")) {
X    Reveal_hand (PLAYER_SOUTH);
X    Reveal_hand (PLAYER_EAST);
X  } else if (!strcasecmp(player, "SW") || !strcasecmp(player, "WS")) {
X    Reveal_hand (PLAYER_WEST);
X    Reveal_hand (PLAYER_SOUTH);
X  } else if (!strcasecmp(player, "EW") || !strcasecmp(player, "WE")) {
X    Reveal_hand (PLAYER_WEST);
X    Reveal_hand (PLAYER_EAST);
X  } else {
X    known = 0;
X    for (i = 0; i < 4; i++)
X      if (OCCUPIED(Local_table, i) && 
X	  !strcasecmp(player, PLAYER_NAME(Local_table, i))) {
X	Reveal_hand (i);
X	known = 1;
X      }
X    if (!known) {
X      sprintf (msg_buf, "THERE IS NO PLAYER NAMED %s", player);
X      Status (msg_buf);
X      return;
X    }
X  }
X
X}
X
Xstatic void Parse_review_input ()
X{
X  Clear_Focus_Buffer ();
X  Review_Bidding ();
X}
X
Xstatic void Parse_rho_input (m)
X     char *m;
X/* RHO <message>
X . Sends a message to the right-hand opponent.
X */
X{
X  if (IS_OBSERVER(local_player))
X    Status ("PRIVATE MESSAGES CANNOT BE SENT BY AN OBSERVER.");
X  else {
X    Display_Player_Comment (COMMENT_PRIVATE, local_player_name, m);
X    Send_talk (Local_table, TALK_RCPT_RHO, m);
X  }
X}
X     
Xstatic void Parse_save_input (f)
X     char *f;
X/* SAVE <filename>
X . Saves the sequence of boards that have been played to the file f.
X */
X{
X  if ((f == NULL) && (email_filename == NULL)) {
X    Status ("YOU MUST SPECIFY THE NAME OF THE EMAIL SAVE FILE.");
X    return;
X  } else if (f == NULL)
X    save_email_file (email_filename);
X  else
X    save_email_file (f);
X}
X
Xstatic void Parse_score_input (s)
X     int *s;
X/* SCORE RUBBER|DUPLICATE|IMP|MP|CLEAR
X . Chooses a scoring mode.  Can be used by the server.
X */
X{
X  if (client_mode) {
X    Status ("ONLY THE SERVER MAY CHANGE THE SCORING MODE.");
X    return;
X  }
X
X  if ((*s == scoring_mode) && !gps_duplicate_mode) return;
X
X  if (*s != CLEAR_SCORING) {
X    scoring_mode = *s;
X    if (gps_duplicate_mode) {
X      GPS_Dup ("END");
X      gps_duplicate_mode = 0;
X    }
X  }
X
X  Local_table->above_line[SIDE_NS] = Local_table->above_line[SIDE_EW] = 0;
X  Local_table->below_line[SIDE_NS] = Local_table->below_line[SIDE_EW] = 0;
X  switch (scoring_mode) {
X  case RUBBER_SCORING:
X    Moderator_Comment ("WE ARE PLAYING RUBBER BRIDGE.");
X    break;
X  case DUPLICATE_SCORING:
X    Moderator_Comment ("WE ARE PLAYING DUPLICATE BRIDGE.");
X    break;
X  case IMP_SCORING:
X    Moderator_Comment ("WE ARE PLAYING IMP BRIDGE.");
X    break;
X  case MP_SCORING:
X    Moderator_Comment ("WE ARE PLAYING MATCH POINT BRIDGE.");
X    break;
X  case CLEAR_SCORING:
X    Moderator_Comment ("THE SCORES HAVE BEEN CLEARED.");
X    break;
X  }
X  if ((Local_table->game_mode != STARTUP_MODE) &&
X      (Local_table->game_mode != SCORING_MODE))
X    Send_skip (Local_table);
X
X}
X
Xstatic void Parse_scoreboard_input ()
X/* SCOREBOARD
X . Displays the GPS scoreboard.
X */
X{
X  Clear_Focus_Buffer ();
X  GPS_Display_Scoreboard ();
X}
X
Xstatic void Parse_seat_input (s)
X     int *s;
X/* SEAT NORTH|EAST|SOUTH|WEST|OBS
X . Requests the given seat for the local player.
X */
X{
X/*  CHECK_ENABLED (INPUT_SEAT); */
X
X  if (spectator_mode) {
X    Status ("YOU CANNOT CHANGE YOUR SEAT IN SPECTATOR MODE.");
X    return;
X  }
X
X  Send_seatreq (Local_table, *s);
X}
X
Xstatic void Parse_east_input ()
X{
X  int i = PLAYER_EAST;
X
X  Parse_seat_input (&i);
X}
X
Xstatic void Parse_north_input ()
X{
X  int i = PLAYER_NORTH;
X
X  Parse_seat_input (&i);
X}
X
Xstatic void Parse_observe_input ()
X{
X  int i = PLAYER_OBS;
X
X  Parse_seat_input (&i);
X}
X
Xstatic void Parse_south_input ()
X{
X  int i = PLAYER_SOUTH;
X
X  Parse_seat_input (&i);
X}
X
Xstatic void Parse_west_input ()
X{
X  int i = PLAYER_WEST;
X
X  Parse_seat_input (&i);
X}
X
Xstatic void Parse_serve_input (p)
X     int *p;
X/* SERVE [<port-number>]
X . Enters Server mode.
X */
X{
X  if (client_mode && (Local_table->game_mode != STARTUP_MODE) &&
X      IS_PLAYER(local_player)) {
X    Moderator_Comment
X      ("WARNING! THIS WILL DISCONNECT YOU FROM THIS TABLE!");
X    if (!Ask("ARE YOU SURE YOU WISH TO DO THIS? "))
X      return;
X  } else if (server_mode) {
X    Status ("YOU ARE ALREADY SERVING A TABLE.");
X    GPS_Broadcast_Server ();
X    return;
X  }
X
X  if (p != NULL)
X    network_port = *p;
X  else
X    network_port = DEFAULT_PORT;
X
X  if (client_mode)
X    Send_quit (Local_table);
X
X  Generate_reset (RESET_SERVE);
X}
X
Xstatic void Parse_setcc_input (cc)
X     char *cc;
X{
X  /*
X    JAS -- should we be "free"ing the old local_cc?
X    */
X  if (cc != NULL)
X    local_cc = strdup (Get_CC_Value(cc));                             /* JAS */
X
X  if ((local_player < 4) && (local_cc != NULL)) {
X    Send_cc (Local_table, local_cc);
X    conventions[side_of(local_player)] = strdup(local_cc);
X    sprintf (msg_buf, "%s: %s", (side_of(local_player) == SIDE_NS)? 
X	     "N-S": "E-W", local_cc);
X  } else if (local_cc == NULL)
X    Status ("YOUR CONVENTION CARD IS EMPTY.");
X}
X
Xstatic void Parse_skip_input (n)
X     int *n;
X/* SKIP [n]
X . Ends the current hand prematurely, and skips the next n-1 hands.
X */
X{
X  int i;
X  Board *b;
X
X  if ((n != NULL) && !server_mode) {
X    Status ("ONLY THE SERVER MAY SPECIFY A SKIP COUNT.");
X    return;
X  } else if (IS_OBSERVER(local_player)) {
X    Status ("OBSERVERS MAY NOT USE THE /SKIP COMMAND.");
X    return;
X  }
X
X  Send_skip (Local_table);
X
X  if (n != NULL) {
X    sprintf (msg_buf, "SKIPPED %d HANDS.", *n);
X    for (i = 1; i < *n; i++) {
X      b = Next_Unplayed_Board ();
X      if (b == NULL) {
X	sprintf (msg_buf, "ALL UNPLAYED BOARDS HAVE BEEN SKIPPED.");
X	break;
X      }
X      Record_Played_Board (b);
X    }
X    Moderator_Comment (msg_buf);
X  }
X
X}
X
Xstatic void Parse_table_input (table_no)
X     int *table_no;
X/* TABLE table-no
X . Requests to switch to the given table.
X */
X{
X  Send_tablereq (Local_table, *table_no);
X}
X
Xstatic void Parse_tables_input ()
X/* TABLES
X . Lists the tables which are currently playing.
X */
X{
X  Clear_Focus_Buffer ();
X  GPS_List_Tables ();
X}
X
Xstatic void Parse_timer_input (tm)
X     int *tm;
X{
X  timer_is_on = (tm == NULL)? timer_is_on: *tm;
X  sprintf (msg_buf, "THE TIMER IS %s.", timer_is_on? "ON": "OFF");
X  if (timer_is_on)
X    Display_timer ();
X  else
X    Display_Total_Time ("", "");
X  Status (msg_buf);
X}
X
Xvoid Wakeup_player (player)
X     char *player;
X{
X
X  if (IS_OBSERVER(local_player) && !server_mode) {
X    Status ("THE WAKEUP COMMAND CANNOT BE USED BY AN OBSERVER.");
X    return;
X  }
X
X  if (FORMAL(Local_table))
X    player = "ALL";
X  else if (player == NULL) {
X    if (!OCCUPIED(Local_table, player_partner[local_player])) {
X      Status ("YOU HAVE NO PARTNER TO WAKE UP!");
X      return;
X    }
X    player = PLAYER_NAME(Local_table, player_partner[local_player]);
X  }
X  
X  Send_wakeup (Local_table, player);
X  sprintf (msg_buf, "SENDING WAKEUP SIGNAL TO %s ...", player);
X  Status (msg_buf);
X
X}
X
Xstatic void Parse_wakeup_input (player)
X     char *player;
X{
X  Wakeup_player (player); 
X}
X
Xstatic void Parse_who_input ()
X/* WHO
X . Generates a short listing of the players who are currently connected.
X */
X{
X  Send_who (Local_table);
X}
X
Xstatic void Parse_whois_input (p)
X     char *p;
X/* WHOIS [<player-name>]
X . Asks for the identity of the given player.  If we are sitting at the
X . table, then omitting <player-name> causes both of the opponents to
X . be identified.
X */
X{
X  int opp1, opp2;
X  Connection c;
X
X  if ((p == NULL) && (local_player >= 4)) {
X    Send_whois (Local_table, "*ALL*");
X/*    Status ("ERROR: YOU MUST SPECIFY THE NAME OF A PLAYER"); */
X  } else if (p == NULL) {
X    opp1 = side_of(player_next[local_player]);
X    opp2 = player_partner[opp1];
X    if (OCCUPIED(Local_table, opp1))
X      Send_whois (Local_table, PLAYER_NAME(Local_table, opp1));
X    if (OCCUPIED(Local_table, opp2))
X      Send_whois (Local_table, PLAYER_NAME(Local_table, opp2));
X  } else
X    Send_whois (Local_table, p);
X}
X
Xstatic void Parse_zlog_input (f)
X     char *f;
X/* ZLOG <filename>
X . The ZLOG command opens or closes a file for recording the play in
X . Zhang's format. 
X */
X{
X  char *filename;
X
X  if (f == NULL) {
X    if (zhang_logfile == NULL)
X      Moderator_Comment ("THERE IS NO OPEN ZLOGFILE.");
X    else {
X      fclose (zhang_logfile);
X      zhang_logfile = NULL;
X      Moderator_Comment ("THE ZLOGFILE HAS BEEN CLOSED.");
X    }
X    return;
X  } else {
X    if (zhang_logfile != NULL) fclose (zhang_logfile);
X    if (f[0] == '+') {
X      filename = f + 1;
X      zhang_logfile = fopen (filename, "a");
X    } else {
X      filename = f;
X      zhang_logfile = fopen (filename, "w");
X    }
X    if (zhang_logfile == NULL) {
X      sprintf (msg_buf, "%s ERROR OPENING %s",
X	       sys_errlist[errno], filename);
X      Moderator_Comment (msg_buf);
X    } else {
X      sprintf (msg_buf, "NOW ZLOGGING TO %s", filename);
X      Moderator_Comment (msg_buf);
X    }
X  }
X}
X
Xint Parse_Server_Command (command_buf)
X     char *command_buf;
X/* On entry, command_buf should contain a special request to the server
X   made by a client.  Parses the command and executes it.  Returns 0 if
X   the command was parsed correctly, and 1 if an error occurs.  In the
X   latter case, the error message is placed in the Parser_Error_Buf.
X*/
X{
X  return (Parse_Command (Input_Commands, INPUT_MAX-1, command_buf));
X}
X
Xvoid Parse_Input_Command (command_buf)
X     char *command_buf;
X/* Parses the command contained in the buffer command_buf and executes
X   the corresponding command.  If an error occurs, then displays an
X   appropriate message in the status line. 
X*/
X{
X  if (Parse_Command(Input_Commands, INPUT_MAX-1, command_buf+1))
X    Status (Parser_Error_Buf);
X}
END_OF_FILE
if test 44917 -ne `wc -c <'commands.c'`; then
    echo shar: \"'commands.c'\" unpacked with wrong size!
fi
# end of 'commands.c'
fi
if test -f 'rc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rc.h'\"
else
echo shar: Extracting \"'rc.h'\" \(6555 characters\)
sed "s/^X//" >'rc.h' <<'END_OF_FILE'
X/* rc.h -- Routines for reading/writing okbridge initialization files.
X *
X ! Copyright (C) 1990-1992 by Matthew Clegg.  All Rights Reserved
X ! 
X ! OKbridge is made available as a free service to the Internet.
X ! Accordingly, the following restrictions are placed on its use:
X ! 
X ! 1.  OKbridge may not be modified in any way without the explicit 
X !     permission of Matthew Clegg.  
X ! 
X ! 2.  OKbridge may not be used in any way for commercial advantage.
X !     It may not be placed on for-profit networks or on for-profit
X !     computer systems.  It may not be bundled as part of a package
X !     or service provided by a for-profit organization.
X ! 
X ! If you have questions about restrictions on the use of OKbridge,
X ! write to mclegg@cs.ucsd.edu.
X ! 
X ! DISCLAIMER:  The user of OKbridge accepts full responsibility for any
X ! damage which may be caused by OKbridge.
X *
X */
X
X/*
X * This module contains procedures for reading the okbridge startup
X * files.  Each line in this file is either a comment line
X * or a (field, value) pair.  Comment lines begin with the pound sign
X * '#' character.  Field, value pairs are of the format
X *	<Field-name>	<value>
X *
X * The fields which are currently recognized are as follows:
X *
X * AUTOSAVE     ON | OFF
X * 	Specifies that we will save the options specified by the user
X *	during play of the program to the file .okdefaults after the
X *	program terminates.
X *
X * BELL		ON | OFF
X *	When requesting input (a bid or a play), the terminal's
X *	bell is rung by default.  However, this can be disabled
X *	by specifying 'BELL OFF'.  This has the same effect as the
X *	'/BELL OFF' command.
X *
X * CC           <convention-card>
X *      This is a one line description of the conventions which you
X *      like to use. 
X *
X **** The following command added by jsegal 5-14-92.
X * CCDEF       <ccname> <convention-card>
X *      This command will define a named CC.  It must be before
X *      the CC line of the startup if that line specifies a named CC.
X *
X * DEFAULT      ON | OFF
X *      This controls whether or not default inputs will be provided for
X *      bids, plays and questions.
X *
X * EMAIL        <email-address>
X *      This should be your email address.  It is currently used only for
X *      identification purposes.
X *
X * ESCKEY       <decimal-key-code>
X *      Specifies the key which will be recognized when the program
X *      presents the message "PRESS <ESC> TO CONTINUE."  This should
X *      be a decimal number representing the key code.  For example,
X *      the <RETURN> key has code 13, and the ESC key (the default)
X *      has code 27.
X *
X * FULLNAME     <your-full-name>
X *      This field is used only for identification purposes, and should
X *      contain your full name as you would wish it to be displayed to others.
X *
X * GPS           ON | OFF
X *	Controls whether or not we will contact the Global Player Service
X *       automatically when the program starts up.
X *
X * GPS_IP	<ip-name-or-number-of-GPS> [<GPS-port>]
X *	Specifies the Internet name or number of the GPS
X *
X * HELPFILE	<directory-name>
X *	This field specifies the directory to be used for reading
X *	the okbridge help files.
X *
X * LOAD         <email-duplicate-filename>
X *      This field is only valid if the position is north and the
X *      scoring mode is email duplicate.  In this case, okbridge will
X *      automatically read a set of email duplicate boards from the
X *      named file.
X *
X * LOG		<filename>
X *	If this statement is present in the startup file, then
X *	the hands will automatically be logged to the given filename.
X *      If the first character of <filename> is '+', then logs the
X *      hands to the end of the file rather than erasing the old file.
X *
X * MY_IP        <local-IP-number>
X *      This field specifies the IP number of the local player.
X *      Usually, okbridge can determine the IP number correctly
X *      a call to gethostbyname(), but on some systems, this will
X *      not give correct results.
X *
X * NAME		<local-player-name>
X *	This field specifies the name that will be used to identify
X *	the local player to the other players.
X *
X * PORT		<positive-integer>
X *	This field specifies the internet port number that will be
X *	used for communications with the server.
X *
X * PROMPT 	NO | YES
X *	The value of this field is only relevant in hands where the
X *	local player is the dummy.  In this case, the dummy is
X *	ordinarily prompted to press RETURN at the end of each trick.
X *	This allows the dummy to see the cards that are played as they
X *	are played.  However, if 'PROMPT NO' is specified, then the
X *	dummy will not be prompted.
X *
X * REPLAY       <email-duplicate-filename>
X *      This field is only valid if the position is north and the
X *      scoring mode is email duplicate.  In this case, a set of
X *      boards will automatically be read from the named file.
X *      After they have been played, the results will automatically
X *      be written back to the file from which the boards were read.
X *
X * SCORING	RUBBER | CHICAGO | DUPLICATE | EMAIL | IMP
X *	This field is only relevant if the local player is north.
X *	In this case, the SCORING field determines the type of scoring
X *	that will be used by default in the game.
X *
X * SEAT 	NORTH | EAST | SOUTH | WEST
X *	This field specifies the local player's position.
X *
X * SERVER	ME | <internet-name-or-number>
X *	If the value of this field is 'ME', then the local player
X *	will assume the role of server.  If the value of this field
X *	is anything else, then it is interpreted as an internet name
X *	or number of the machine where the server is running.
X *
X * TIMER        ON | OFF
X *      This controls whether or not the timer will automatically
X *      be displayed showing the amount of time spent by the local
X *      player and by all players on the current hand.
X *
X * TIMEZONE     <timezone-string>
X *      This is a string which specifies the name of the time zone of
X *      the local player.  Usually, this can be determined from looking
X *      at the tm_zone field of the structure returned by the localtime()
X *      system call, but some systems do not have this field.
X *
X * ZLOG         <filename>
X *      This command is similar to the LOG command, in that it opens
X *      a file for recording play, but the format of the file is 
X *      different.
X */
X
Xvoid Read_Initialization_File ();
X/* Reads an initialization file.  If the file cannot be found, then does
X   nothing. */
X
Xvoid Write_Initialization_File ();
X/* Writes the current program settings to the given file. */
END_OF_FILE
if test 6555 -ne `wc -c <'rc.h'`; then
    echo shar: \"'rc.h'\" unpacked with wrong size!
fi
# end of 'rc.h'
fi
echo shar: End of archive 4 \(of 14\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
