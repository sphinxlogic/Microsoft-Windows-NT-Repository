Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i077:  xbattle - multi-player battle strategy game for X-Windows, Part06/07
Message-ID: <3516@master.CNA.TEK.COM>
Date: 7 Sep 92 21:23:32 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2035
Approved: billr@saab.CNA.TEK.COM

Submitted-by: slehar@cns.bu.edu
Posting-number: Volume 14, Issue 77
Archive-name: xbattle/Part06
Environment: Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 7)."
# Contents:  parse.c tutorial2
# Wrapped by billr@saab on Mon Sep  7 14:18:50 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'parse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'parse.c'\"
else
echo shar: Extracting \"'parse.c'\" \(32059 characters\)
sed "s/^X//" >'parse.c' <<'END_OF_FILE'
X#include <stdio.h>
X  
X/**** x include files ****/
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xatom.h>
X#include <X11/keysym.h>
X#include <X11/keysymdef.h>
X
X#include "extern.h"
X
X/*************************************************************************/
X/**	get_displaynames						**/
X/** extract the display names from the command line arguments		**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xget_displaynames(displayname,colorarray,rcolorarray,argc,argv)
X  char displayname[MAXPLAYERS][80],
X       *argv[];
X  int argc,
X      colorarray[MAXPLAYERS],
X      rcolorarray[MAXHUES];
X{
X  int i, j, k,
X      extra,
X      index=0, count=0,
X      primary, secondary,
X      colon,
X      sidetaken[MAXSIDES+1];
X
X  char *ptr;
X
X  char line[100];
X
X  nplayers = 0;
X  for (j=1;j<=MAXSIDES; j++)
X    sidetaken[j] = FALSE;
X
X  for (j=0;j<MAXHUES; j++)
X    rcolorarray[j] = NOT_TAKEN;
X
X  /**** initialize message strings ****/
X  sprintf (messagestr,"");
X
X  for (i=0; i<MAXPLAYERS; i++)
X  {
X    winopen[i] = TRUE;
X    winwatch[i] = FALSE;
X  }
X
X  /**** set other displays ****/
X  for (i=1; i<argc; )
X  {
X    if (goodoption(argv[i]))
X    {
X      extra = installoption (argc, argv, i, GLOBAL);
X      i += extra;
X    }
X    else
X    {
X      primary = -1;
X      for (j=1;j<=MAXHUES && primary<0; j++)
X      {
X        /**** find primary (c1) color ****/
X        if (matchstr(&(argv[i][1]), huename[j]))
X        {
X          primary = j;
X          secondary = -1;
X
X          /**** find secondary (c2) color ****/
X          if (strlen(argv[i]) <= strlen(huename[j])+1)
X          {
X            /**** no secondary color ****/
X          }
X          else
X          {
X            ptr = &(argv[i][1+strlen(huename[primary])]);
X            for (k=1;k<=MAXHUES; k++)
X            {
X              if (matchstr(ptr,grayname[k]))
X              {
X                secondary = k;
X              }
X            }
X          }
X
X          if (argv[i+1][0] == '{')
X          {
X            i+=2;
X            while (argv[i][0] != '}')
X            {
X              if (goodoption(argv[i]))
X              {
X                if (rcolorarray[primary] != NOT_TAKEN)
X                  extra = installoption (argc, argv, i, rcolorarray[primary]);
X                else
X                  extra = installoption (argc, argv, i, count);
X                i += extra;
X              }
X              else
X              {
X                printf ("BAD OPTION IN BRACKETS\n");
X                exit (0);
X              }
X            }
X          }
X
X          if(strcmp(argv[i+1],"me") == 0)
X            strcpy(displayname[index],"");
X          else
X          {
X            /**** if no :x.y given in display name add :0.0 ****/
X            colon = FALSE;
X            for (k=0; k<strlen(argv[i+1]); k++)
X              if (argv[i+1][k] == ':')
X                colon = TRUE;
X            strcpy (line, argv[i+1]);
X            if (!colon)
X              strcat (line, ":0.0");
X  
X            strcpy(displayname[index],line);
X          }
X  
X          if (strcmp(argv[i+1],"you") == 0)
X          {
X            /**** dummy player ****/
X          }
X          else
X          {
X            /**** set up player to color mapping ****/
X            if (!sidetaken[primary])
X            {
X              colorarray[index]=count;
X              rcolorarray[primary]=count;
X            }
X            else
X            {
X              for (k=0; k<count; k++)
X                if (sidemap[k] == primary)
X                  colorarray[index]=k;
X            }
X            index++;
X          }
X  
X          /**** set up side to color mapping ****/
X          if (!sidetaken[primary])
X          {
X            sidemap[count] = primary;
X            if (secondary >= 0)
X              color2bw[primary] = secondary;
X  
X            if (secondary < 0 && primary > WHITE)
X            {
X              lettermap[count][0] = huename[primary][0] - 'a' + 'A';
X              lettermap[count][1] = '\0';
X            }
X            else
X              lettermap[count][0] = FALSE;
X  
X            count++;
X          }
X          sidetaken[primary] = TRUE;
X        }
X      }
X      if (primary == -1)
X      {
X        printf ("Invalid command    : %s\n", argv[i]);
X        i++;
X      }
X      else
X        i+=2;
X    }
X  }
X
X  nplayers = index;
X  nsides = count;
X  none = nsides;
X  dark = nsides+1;
X  light = nsides+2;
X
X  if (nsides < 1 && !is_arg("-replay",argc,argv))
X  {
X    printf (usage);
X    exit (0);
X  }
X}
X
X
X/*************************************************************************/
X/**	init_defaults							**/
X/** initialize default option values					**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xinit_defaults()
X{
X  int i, j;
X
X  char str[100];
X
X  for (i=0; i<MAXSIDES; i++)
X  {
X    slowfactor[i] = SLOWFACTOR;
X    artillery[i] = 0;
X    paratroops[i] = 0;
X    bases[i] = 0;
X    rbases[i] = 0;
X    militia[i] = 0;
X    armies[i] = 0;
X    firepower[i] = FIREPOWER / (1.0 + gamespeed/5.0);
X    forest[i] = 0;
X    hillfactor[i] = 0;
X    decayrate[i] = 0;
X    eroderate[i] = 0;
X    viewrange[i] = VIEWRANGE;
X    squaresize[i] = SQUARESIZE;
X    enable_fill[i] = FALSE;
X    enable_dig[i] = FALSE;
X    enable_scuttle[i] = FALSE;
X    enable_build[i] = FALSE;
X    enable_personalmarch[i] = FALSE;
X    marchrate[i] = MARCH;
X    enable_artillery[i] = FALSE;
X    enable_paratroops[i] = FALSE;
X    enable_grid[i] = TRUE;
X    enable_manpos[i] = FALSE;
X    enable_hidden[i] = FALSE;
X    enable_disrupt[i] = FALSE;
X    enable_map[i] = FALSE;
X    enable_basemap[i] = FALSE;
X    enable_localmap[i] = FALSE;
X    enable_personalhorizon[i] = FALSE;
X    enable_personalbound[i] = FALSE;
X    enable_erode[i] = FALSE;
X    enable_digin[i] = FALSE;
X    enable_repeat[i] = FALSE;
X    enable_reserve[i] = FALSE;
X    enable_attack[i] = FALSE;
X    enable_nospigot[i] = FALSE;
X
X    for (j=0; j<4; j++)
X      dir[i][j] = 0;
X    dirtype[i] = FORCE;
X  }
X  delay = 5000;
X  seed = getpid() + time(NULL);
X  maxviewrange = 0;
X  enable_anylocalmap = FALSE;
X  enable_bound = FALSE;
X  enable_march = FALSE;
X  enable_edit = FALSE;
X  enable_area = FALSE;
X  fillnumber = 1;
X  directions = 4;
X
X  sprintf(str,"seed=%d ",seed);
X  strcat(messagestr,str);
X}
X
X
X/*************************************************************************/
X/**	installoption							**/
X/** install current option						**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xinstalloption (argc, argv, pos, side)
X  int argc;
X  char *argv[];
X  int pos,
X      side;
X{
X  double djunk,
X         atof();
X  int i, j,
X      extra,
X      ijunk;
X
X  char str[80],
X       filename[80],
X       line[80];
X
X  strcpy (line, argv[pos]);
X
X  if (strcmp(line,"-seed") == 0)
X    return (2);
X
X  if (strcmp(line,"-hills") == 0)
X  {
X    djunk = atof (argv[pos+1]);
X    enable_hills = TRUE;
X    enable_terrain = TRUE;
X    sprintf(str,"hills=%d ", (int)(djunk));
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X    {
X      for (i=0; i<MAXSIDES; i++)
X        hillfactor[i] = djunk*0.2;
X    }
X    else
X      hillfactor[side] = djunk*0.2;
X
X    return (2);
X  }
X
X  if (strcmp(line,"-forest") == 0)
X  {
X    djunk = atof (argv[pos+1]);
X    enable_forest = TRUE;
X    enable_terrain = TRUE;
X    sprintf(str,"forest=%d ", (int)(djunk));
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X    {
X      for (i=0; i<MAXSIDES; i++)
X        forest[i] = djunk*0.2;
X    }
X    else
X      forest[side] = djunk*0.2;
X
X    return (2);
X  }
X
X  if (strcmp(line,"-sea") == 0)
X    return (2);
X
X  if (strcmp(line,"-move") == 0)
X  {
X    djunk = atof (argv[pos+1]);
X    sprintf(str,"move=%d ", (int)(djunk));
X    strcat(messagestr,str);
X    if (side == GLOBAL)
X    {
X      for (i=0; i<MAXSIDES; i++)
X        slowfactor[i] = (10.0-djunk)*0.6;
X    }
X    else
X      slowfactor[side] = (10.0-djunk)*0.6;
X    return (2);
X  }
X
X  if (strcmp(line,"-digin") == 0)
X  {
X    djunk = atof (argv[pos+1]);
X    sprintf(str,"digin=%d ", (int)(djunk));
X    strcat(messagestr,str);
X    if (side == GLOBAL)
X    {
X      for (i=0; i<MAXSIDES; i++)
X      {
X        enable_digin[i] = TRUE;
X        shuntval[i] = djunk;
X      }
X    }
X    else
X    {
X      enable_digin[side] = TRUE;
X      shuntval[side] = djunk;
X    }
X    return (2);
X  }
X
X  if (strcmp(line,"-guns") == 0)
X  {
X    djunk = atof (argv[pos+1]);
X    sprintf(str,"guns=%d ", (int)(djunk));
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X      {
X        enable_artillery[i] = TRUE;
X        artillery[i] = djunk*0.05;
X      }
X    else
X    {
X      artillery[side] = djunk*0.05;
X      enable_artillery[side] = TRUE;
X    }
X    return (2);
X  }
X
X  if (strcmp(line,"-para") == 0)
X  {
X    djunk = atof (argv[pos+1]);
X    sprintf(str,"para=%d ", (int)(djunk));
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X      {
X        paratroops[i] = djunk*0.05;
X        enable_paratroops[i] = TRUE;
X      }
X    else
X    {
X      paratroops[side] = djunk*0.05;
X      enable_paratroops[side] = TRUE;
X    }
X    return (2);
X  }
X
X  if (strcmp(line,"-farms") == 0)
X    return (2); 
X
X  if (strcmp(line,"-hex") == 0)
X    return (1); 
X
X  if (strcmp(line,"-border") == 0)
X    return (1); 
X
X  if (strcmp(line,"-towns") == 0)
X    return (2);
X
X  if (strcmp(line,"-bases") == 0)
X  {
X    enable_bases = TRUE;
X    ijunk = atoi (argv[pos+1]);
X    sprintf(str,"bases=%d ", ijunk);
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        bases[i] = ijunk;
X    else
X      bases[side] = ijunk;
X    return (2);
X  }
X
X  if (strcmp(line,"-rbases") == 0)
X  {
X    enable_rbases = TRUE;
X    ijunk = atoi (argv[pos+1]);
X    sprintf(str,"rbases=%d ", ijunk);
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        rbases[i] = ijunk;
X    else
X      rbases[side] = ijunk;
X    return (2);
X  }
X
X  if (strcmp(line,"-armies") == 0)
X  {
X    enable_armies = TRUE;
X    ijunk = atoi (argv[pos+1]);
X    sprintf(str,"armies=%d ", ijunk);
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        armies[i] = ijunk;
X    else
X      armies[side] = ijunk;
X    return (2);
X  }
X
X  if (strcmp(line,"-militia") == 0)
X  {
X    enable_militia = TRUE;
X    djunk = atof (argv[pos+1]);
X    sprintf(str,"militia=%d ", (int)(djunk));
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        militia[i] = djunk;
X    else
X      militia[side] = djunk;
X    return (2);
X  }
X
X  if (strcmp(line,"-speed") == 0)
X    return (2);
X
X  if (strcmp(line,"-fight") == 0)
X  {
X    djunk = atof (argv[pos+1]);
X    sprintf(str,"fight=%d ", (int)(djunk));
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        firepower[i] = (djunk)/(1.0+(gamespeed/5.0));
X    else
X      firepower[side] = (djunk)/(1.0+(gamespeed/5.0));
X    return (2);
X  }
X
X  if (strcmp(line,"-decay") == 0)
X  {
X    enable_decay = TRUE;
X    djunk = atof (argv[pos+1]);
X    sprintf(str,"decay=%d ", (int)(djunk));
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        decayrate[i] = djunk/(10.0*(double)(MAXVAL));
X    else
X      decayrate[side] = djunk/(10.0*(double)(MAXVAL));
X
X    return (2);
X  }
X
X
X  if (strcmp(line,"-erode") == 0)
X  {
X    djunk = atof (argv[pos+1]);
X    sprintf(str,"erode=%d ", (int)(djunk));
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X    {
X      for (i=0; i<MAXSIDES; i++)
X      {
X        enable_erode[i] = TRUE;
X        eroderate[i] = djunk*10.0;
X      }
X    }
X    else
X    {
X      enable_erode[side] = TRUE;
X      eroderate[side] = djunk*10.0;
X    }
X
X    return (2);
X  }
X
X  if (strcmp(line,"-fill") == 0)
X  {
X    djunk = atof (argv[pos+1]);
X    sprintf(str,"fill=%d ", (int)(djunk));
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X    {
X      for (i=0; i<MAXSIDES; i++)
X      {
X        enable_fill[i] = TRUE;
X        fillnumber = (int)(djunk);
X      }
X    }
X    else
X    {
X      enable_fill[side] = TRUE;
X      fillnumber = (int)(djunk);
X    }
X
X    return (2);
X  }
X
X  if (strcmp(line,"-dig") == 0)
X  {
X    djunk = atof (argv[pos+1]);
X    sprintf(str,"dig=%d ", (int)(djunk));
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X    {
X      for (i=0; i<MAXSIDES; i++)
X      {
X        enable_dig[i] = TRUE;
X        fillnumber = (int)(djunk);
X      }
X    }
X    else
X    {
X      enable_dig[side] = TRUE;
X      fillnumber = (int)(djunk);
X    }
X    return (2);
X  }
X
X  if (strcmp(line,"-scuttle") == 0)
X  {
X    strcat(messagestr,"scuttle ");
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        enable_scuttle[i] = TRUE;
X    else
X      enable_scuttle[side] = TRUE;
X    return (1);
X  }
X
X  if (strcmp(line,"-build") == 0)
X  {
X    ijunk = atoi (argv[pos+1]);
X    sprintf(str,"build=%d ", ijunk);
X    strcat(messagestr,str);
X
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X      {
X        enable_build[i] = TRUE;
X        buildrate[i] = 23040/ijunk;
X        scuttlerate[i] = MAXVAL/ijunk;
X      }
X    else
X    {
X      enable_build[side] = TRUE;
X      buildrate[side] = 23040/ijunk;
X      scuttlerate[side] = MAXVAL/ijunk;
X    }
X    return (2);
X  }
X
X  if (strcmp(line,"-march") == 0)
X  {
X    ijunk = atoi (argv[pos+1]);
X    enable_march = TRUE;
X    sprintf(str,"march=%d ", ijunk);
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X      {
X        enable_personalmarch[i] = TRUE;
X        marchrate[i] = ijunk;
X      }
X    else
X    {
X      enable_personalmarch[side] = TRUE;
X      marchrate[side] = ijunk;
X    }
X    return (2);
X  }
X
X  if (strcmp(line,"-reserve") == 0)
X  {
X    strcat(messagestr,"reserve ");
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        enable_reserve[i] = TRUE;
X    else
X      enable_reserve[side] = TRUE;
X    return (1);
X  }
X
X  if (strcmp(line,"-bound") == 0)
X  {
X    strcat(messagestr,"bound ");
X    enable_bound = TRUE;
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        enable_personalbound[i] = TRUE;
X    else
X      enable_personalbound[side] = TRUE;
X    return (1);
X  }
X
X  if (strcmp(line,"-area") == 0)
X  {
X    strcat(messagestr,"area ");
X    enable_area = TRUE;
X    return (1);
X  }
X
X  if (strcmp(line,"-repeat") == 0)
X  {
X    strcat(messagestr,"repeat ");
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        enable_repeat[i] = TRUE;
X    else
X      enable_repeat[side] = TRUE;
X    return (1);
X  }
X
X  if (strcmp(line,"-attack") == 0)
X  {
X    strcat(messagestr,"attack ");
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        enable_attack[i] = TRUE;
X    else
X      enable_attack[side] = TRUE;
X    return (1);
X  }
X
X  if (strcmp(line,"-nospigot") == 0)
X  {
X    strcat(messagestr,"nospigot ");
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        enable_nospigot[i] = TRUE;
X    else
X      enable_nospigot[side] = TRUE;
X    return (1);
X  }
X
X  if (strcmp(line,"-wrap") == 0)
X  {
X    enable_anywrap = TRUE;
X    strcat(messagestr,"wrap ");
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X      {
X        enable_wrap[i] = TRUE;
X      }
X    else
X      enable_wrap[side] = TRUE;
X
X    return (1);
X  }
X
X  if (strcmp(line,"-nogrid") == 0)
X  {
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X      {
X        enable_grid[i] = FALSE;
X      }
X    else
X      enable_grid[side] = FALSE;
X    return (1);
X  }
X
X  if (strcmp(line,"-horizon") == 0)
X  {
X    enable_horizon = TRUE;
X    if (pos < argc-1)
X    {
X      if (argv[pos+1][0] >= '0' && argv[pos+1][0] <= '9')
X      {
X        ijunk = atoi (argv[pos+1]);
X        extra = 2;
X      }
X      else
X      {
X        ijunk = VIEWRANGE;
X        extra = 1;
X      }
X    }
X    else
X    {
X      ijunk = VIEWRANGE;
X      extra = 1;
X    }
X    sprintf(str,"horizon=%d ", ijunk);
X    strcat(messagestr,str);
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X      {
X        viewrange[i] = ijunk;
X        enable_personalhorizon[i] = TRUE;
X      }
X    else
X    {
X      viewrange[side] = ijunk;
X      enable_personalhorizon[side] = TRUE;
X    }
X
X    return (extra);
X  }
X
X  if (strcmp(line,"-hidden") == 0)
X  {
X    strcat(messagestr,"hidden ");
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        enable_hidden[i] = TRUE;
X    else
X      enable_hidden[side] = TRUE;
X    return (1);
X  }
X
X  if (strcmp(line,"-map") == 0)
X  {
X    strcat(messagestr,"map ");
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        enable_map[i] = TRUE;
X    else
X      enable_map[side] = TRUE;
X    return (1);
X  }
X
X  if (strcmp(line,"-basemap") == 0)
X  {
X    strcat(messagestr,"basemap ");
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        enable_basemap[i] = TRUE;
X    else
X      enable_basemap[side] = TRUE;
X    return (1);
X  }
X
X  if (strcmp(line,"-localmap") == 0)
X  {
X    strcat(messagestr,"localmap ");
X    enable_anylocalmap = TRUE;
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        enable_localmap[i] = TRUE;
X    else
X      enable_localmap[side] = TRUE;
X    return (1);
X  }
X
X  if (strcmp(line,"-disrupt") == 0)
X  {
X    strcat(messagestr,"disrupt ");
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        enable_disrupt[i] = TRUE;
X    else
X      enable_disrupt[side] = TRUE;
X    return (1);
X  }
X
X  if (strcmp(line,"-board") == 0)
X    return (2);
X
X  if (strcmp(line,"-boardx") == 0)
X    return (2);
X
X  if (strcmp(line,"-boardy") == 0)
X    return (2);
X
X  if (strcmp(line,"-square") == 0)
X  {
X    ijunk = atoi (argv[pos+1]);
X
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X        squaresize[i] = ijunk;
X    else
X      squaresize[side] = ijunk;
X    return (2);
X  }
X
X  if (strcmp(line,"-manpos") == 0)
X  {
X    if (side == GLOBAL)
X      for (i=0; i<MAXSIDES; i++)
X      {
X        enable_manpos[i] = TRUE;
X      }
X    else
X        enable_manpos[side] = TRUE;
X    return (1);
X  }
X
X  if (strcmp(line,"-store") == 0)
X  {
X    if (!stringval ("-store",argc,argv,filename))
X      return (1);
X    else
X      return (2);
X  }
X
X  if (strcmp(line,"-replay") == 0)
X  {
X    if (!stringval ("-replay",argc,argv,filename))
X      return (1);
X    else
X      return (2);
X  }
X
X  if (strcmp(line,"-load") == 0)
X  {
X    if (!stringval ("-load",argc,argv,filename))
X      return (1);
X    else
X      return (2);
X  }
X
X  if (strcmp(line,"-edit") == 0)
X  {
X    if (!stringval ("-edit",argc,argv,filename))
X      return (1);
X    else
X      return (2);
X  }
X
X  if (strcmp(line,"-options") == 0)
X  {
X    if (pos == argc-1)
X    {
X      strcpy (filename, "default.xbo");
X      extra = 1;
X    }
X    else if (argv[pos+1][0] == '-' || argv[pos+1][0] == '}')
X    {
X      strcpy (filename, "default.xbo");
X      extra = 1;
X    }
X    else
X    {
X      strcpy (filename, argv[pos+1]);
X      extra = 2;
X    }
X
X    loadoptions (filename, side);
X
X    return (extra);
X  }
X}
X
X
X/*************************************************************************/
X/**	loadoptions							**/
X/** load options from file						**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xloadoptions(filename, side)
X  char filename[];
X  int side;
X{
X  int ptr1,
X      ptr2;
X      
X  char line[100],
X       *option[3],
X       junkdisplayname[MAXPLAYERS][80];
X
X  FILE *fpopts,
X       *fopen();
X
X  option[0] = (char *)(malloc(50*sizeof(char)));
X  option[1] = (char *)(malloc(50*sizeof(char)));
X  option[2] = (char *)(malloc(50*sizeof(char)));
X
X  if ((fpopts = fopen (filename, "r")) == NULL)
X  {
X    printf ("Unable to open option file %s\n", filename);
X    exit (0);
X  }
X
X  while (fgets (line, 100, fpopts) != NULL)
X  {
X    option[0][0] = '\0';
X
X    for (ptr1=0; line[ptr1] != ' ' && line[ptr1] != '\0' && line[ptr1] != '\n'; ptr1++)
X      option[1][ptr1] = line[ptr1];
X    option[1][ptr1] = '\0';  
X
X    for (; line[ptr1] == ' ' && line[ptr1] != '\0' && line[ptr1] != '\n'; ptr1++);
X
X    for (ptr2=0; line[ptr1] != '\0' && line[ptr1] != '\n'; ptr1++, ptr2++)
X      option[2][ptr2] = line[ptr1];
X    option[2][ptr2] = '\0';  
X
X    if (option[2][0] == '\0')
X    {
X      strcpy (option[2], "-blah");
X    }
X
X    if (goodoption(option[1]))
X    {
X      installoption (3, option, 1, side);
X      init_options (junkdisplayname, 3, option);
X    }
X    else
X    {
X      printf ("illegal argument in option file:   %s\n", line);
X    }
X  }
X
X  fclose (fpopts);
X}
X
X
X/*************************************************************************/
X/**	goodoption							**/
X/** Return TRUE if string is valid option				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xgoodoption(line)
X  char line[];
X{
X  int i, j,
X      valid,
X      allvalid,
X      ptr;
X
X  valid = FALSE;
X  for (i=0; i<NOPTS && !valid; i++)
X  {
X    if (strcmp(line,options[i]) == 0)
X    {
X      valid = TRUE;
X    }
X  }
X  return (valid);
X}
X
X
X/*************************************************************************/
X/**	checkoptions							**/
X/** Make sure all command line arguments are valid			**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xcheckoptions(argc,argv)
X  int argc;
X  char *argv[];
X{
X  int i, j,
X      valid,
X      allvalid,
X      inbracket,
X      ptr;
X
X  char lastside[100];
X
X  ptr = 1;
X  allvalid = TRUE;
X  inbracket = FALSE;
X
X  while (ptr < argc)
X  {
X    valid = FALSE;
X    for (i=0; i<NOPTS && !valid; i++)
X    {
X      if (strcmp(argv[ptr],options[i]) == 0)
X      {
X        valid = TRUE;
X        if (i < POPTS)
X        {
X          if (ptr+1 == argc)
X          {
X            allvalid = FALSE; 
X            printf ("missing argument:     %s\n", argv[ptr]); 
X            ptr++;
X          }
X          else if (argv[ptr+1][0] == '-' || (inbracket && argv[ptr+1][0] == '}'))
X          {
X            allvalid = FALSE; 
X            printf ("missing argument:     %s\n", argv[ptr]); 
X            ptr++;
X          }
X          else
X            ptr += 2;
X        }
X        else if (i < POPTS + PVOPTS)
X        {
X          if (ptr+1 == argc)
X            ptr++;
X          else if (argv[ptr+1][0] == '-' || (inbracket && argv[ptr+1][0] == '}'))
X            ptr++;
X          else
X            ptr += 2;
X        }
X        else
X        {
X          if (ptr+1 != argc)
X          {
X            if (argv[ptr+1][0] != '-' && !(inbracket && argv[ptr+1][0] == '}'))
X            {
X              allvalid = FALSE; 
X              printf ("extra argument:       %s %s\n", argv[ptr], argv[ptr+1]); 
X              ptr += 2;
X            }
X            else
X              ptr++;
X          }
X          else
X            ptr++;
X        }
X      }
X    }
X
X    if (!valid && inbracket)
X    {
X      if (argv[ptr][0] == '}')
X      {
X        valid = TRUE;
X        if (ptr+1 == argc)
X        {
X          allvalid = FALSE;
X          printf ("missing screen name:  %s\n", lastside);
X          ptr++;
X        }      
X        else if (argv[ptr+1][0] == '-')
X        {
X          allvalid = FALSE;
X          printf ("missing screen name:  %s\n", lastside);
X          ptr++;
X        }      
X        else
X        {
X          ptr+=2;
X        }
X
X        inbracket = FALSE;
X      }
X    }
X    else if (!valid)
X    {
X      for (j=1; j<=MAXHUES && !valid; j++)
X      {
X        if (matchstr(&(argv[ptr][1]), huename[j]))
X        {
X          valid = TRUE;
X          if (ptr+1 == argc)
X          {
X            allvalid = FALSE; 
X            printf ("missing argument:     %s\n", argv[ptr]); 
X            ptr++;
X          }
X          else if (argv[ptr+1][0] == '-')
X          {
X            allvalid = FALSE; 
X            printf ("missing argument:     %s\n", argv[ptr]); 
X            ptr++;
X          }
X          else
X          {
X            if (argv[ptr+1][0] == '{')
X            {
X              inbracket = TRUE;
X              strcpy (lastside, argv[ptr]);
X            }
X            ptr += 2;
X          }
X        }
X      }
X    }
X
X    if (!valid)
X    {
X      allvalid = FALSE; 
X      if (ptr+1 == argc)
X      {
X        printf ("illegal argument:     %s\n", argv[ptr]); 
X        ptr++;
X      }
X      else if (argv[ptr+1][0] == '-')
X      {
X        printf ("illegal argument:     %s\n", argv[ptr]); 
X        ptr++;
X      }
X      else
X      {
X        printf ("illegal argument:     %s %s\n", argv[ptr], argv[ptr+1]); 
X        ptr += 2;
X      }
X    }
X  }
X
X  if (inbracket)
X  {
X    allvalid = FALSE;
X    printf ("incomplete side:      %s\n", lastside);
X  }
X
X  if (!allvalid)
X    exit (0);
X}
X      
X
X/*************************************************************************/
X/**     storeparameters                                                 **/
X/**  store relevant game parameters at head of storage file		**/
X/**     Greg Lesher (lesher@park.bu.edu)                                **/
X/*************************************************************************/
Xstoreparameters ()
X{
X  int i;
X
X  fprintf (fpout, "%c", squaresize[0]);
X  fprintf (fpout, "%c", boardsizex);
X  fprintf (fpout, "%c", boardsizey);
X  fprintf (fpout, "%c", enable_hex);
X  fprintf (fpout, "%c", enable_hills);
X  fprintf (fpout, "%c", enable_forest);
X  fprintf (fpout, "%c", enable_sea);
X  fprintf (fpout, "%c", enable_terrain);
X  fprintf (fpout, "%c", nsides);
X  fprintf (fpout, "%c", fillnumber);
X  for (i=0; i<nsides; i++)
X    fprintf (fpout, "%c", sidemap[i]);
X  for (i=0; i<nsides; i++)
X    fprintf (fpout, "%c", color2bw[sidemap[i]]);
X}
X
X
X/*************************************************************************/
X/**     loadparameters                                                  **/
X/**  load relevant game parameters from replay file			**/
X/**     Greg Lesher (lesher@park.bu.edu)                                **/
X/*************************************************************************/
Xloadparameters (displayname)
X  char displayname[MAXPLAYERS][80];
X{
X  int i;
X
X  squaresize[0] = getc (fpout);
X  boardsizex = getc (fpout);
X  boardsizey = getc (fpout);
X  enable_hex = getc (fpout);
X  enable_hills = getc (fpout);
X  enable_forest = getc (fpout);
X  enable_sea = getc (fpout);
X  enable_terrain = getc (fpout);
X  nsides = getc (fpout);
X  fillnumber = getc (fpout);
X  for (i=0; i<nsides; i++)
X    sidemap[i] = getc(fpout);
X  for (i=0; i<nsides; i++)
X    color2bw[sidemap[i]] = getc (fpout);
X
X  for (i=0; i<nsides; i++)
X    lettermap[i][0] = FALSE;
X
X  colorarray[0] = 0;
X
X  /**** if no command line display names ****/
X  if (nplayers == 0)
X  {
X    nplayers = 1;
X    strcpy (displayname[0], "");
X  }
X
X  none = nsides;
X  dark = nsides+1;
X  light = nsides+2;
X}
X
X
X/*************************************************************************/
X/**	init_options							**/
X/** initialize the game board options using global variables		**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/*************************************************************************/
Xinit_options(displayname,argc,argv)
X  char displayname[MAXPLAYERS][80];
X  int argc;
X  char *argv[];
X{
X  int i,
X      pos;
X  char str[80];
X  extern double doubleval();
X
X  /**** set random seed ****/
X  if (is_arg("-seed",argc,argv))
X  {
X    seed = intval("-seed",argc,argv);
X    strcat(messagestr,str);
X  } 
X
X  if (is_arg("-sea",argc,argv))
X  {
X    enable_sea = TRUE;
X    sprintf(str,"sea=%2.0f ",doubleval("-sea",argc,argv));
X    strcat(messagestr,str);
X    enable_terrain = TRUE;
X    sea = 20.0 - 2.0*doubleval("-sea",argc,argv);
X    if (sea <= 0.0)
X      sea = 2.0;
X  }
X
X  /**** farms ****/
X  if (is_arg("-farms",argc,argv))
X  {
X    enable_farms = TRUE;
X    farms = doubleval("-farms",argc,argv);
X
X    sprintf(str,"farms=%2.0f ",doubleval("-farms",argc,argv));
X    strcat(messagestr,str);
X  }
X
X  /**** border ****/
X  if (is_arg("-border",argc,argv))
X  {
X    enable_border = TRUE;
X  }
X
X  /**** hex ****/
X  if (is_arg("-hex",argc,argv))
X  {
X    enable_hex = TRUE;
X    directions = 6;
X  }
X
X  /**** town ****/
X  if (is_arg("-towns",argc,argv))
X  {
X    enable_towns = TRUE;
X    towns = doubleval("-towns",argc,argv);
X
X    sprintf(str,"towns=%d ", (int)(towns));
X    strcat(messagestr,str);
X  }
X
X  /**** game speed ****/
X  if (is_arg("-speed",argc,argv))
X  {
X    gamespeed = doubleval("-speed",argc,argv);
X    if (gamespeed == 0.0)
X      gamespeed = 0.5;
X    delay = (int)(25000.0/gamespeed + 0.5);
X
X    sprintf(str,"speed=%3.1f ",doubleval("-speed",argc,argv));
X    strcat(messagestr,str);
X  }
X
X  if (is_arg("-board",argc,argv))
X  {
X    boardsizex = intval("-board",argc,argv);
X    boardsizey = boardsizex;
X  }
X
X  if (is_arg("-boardx",argc,argv))
X    boardsizex = intval("-boardx",argc,argv);
X
X  if (is_arg("-boardy",argc,argv))
X    boardsizey = intval("-boardy",argc,argv);
X
X  /**** set up program for file storage ****/
X  if (is_arg("-store",argc,argv))
X  {
X    enable_storage = TRUE;
X    if (!stringval ("-store",argc,argv,storagename))
X      strcpy (storagename, "xbattle.xba");
X    strcat(messagestr,"store ");
X  }
X
X  if (is_arg("-load",argc,argv))
X  {
X    enable_load = TRUE;
X    if (!stringval ("-load",argc,argv,mapname))
X      strcpy (mapname, "xbattle.xbt");
X    strcat(messagestr,"load ");
X  }
X
X  if (is_arg("-edit",argc,argv))
X  {
X    enable_edit = TRUE;
X    if (!stringval ("-edit",argc,argv,mapname))
X      strcpy (mapname, "xbattle.xbt");
X    strcat(messagestr,"edit ");
X  }
X
X  /**** set up program for replay ****/
X  if (is_arg("-replay",argc,argv))
X  {
X    enable_replay = TRUE;
X    if (!stringval ("-replay",argc,argv,replayname))
X      strcpy (replayname, "xbattle.xba");
X
X    strcpy (messagestr, " REPLAY    REPLAY    REPLAY    REPLAY    REPLAY    REPLAY    REPLAY    REPLAY    REPLAY     REPLAY    REPLAY    REPLAY    REPLAY    REPLAY    REPLAY    REPLAY");
X  }
X}
X
X
X/*************************************************************************/
X/**	clean_options							**/
X/** clean up incongruous options					**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xclean_options(displayname)
X  char displayname[MAXPLAYERS][80];
X{
X  int i;
X
X  double full, base,
X         offset, factor,
X         sqrt();
X
X  FILE *fptemp,
X       *fopen();
X      
X  for (i=0; i<nsides; i++)
X  {
X    if (enable_map[i] || enable_localmap[i])
X    {
X      enable_horizon = TRUE;
X      enable_personalhorizon[i] = TRUE;
X    }
X
X    if (enable_localmap[i])
X    {
X      enable_map[i] = TRUE;
X      enable_basemap[i] = FALSE;
X    }
X  }
X
X  if (enable_horizon)
X  { 
X    for (i=0; i<nsides; i++)
X      if (enable_personalhorizon[i])
X        if (viewrange[i] > maxviewrange)
X          maxviewrange = viewrange[i];
X  }
X
X  if (enable_storage)
X  {
X    if ((fpout = fopen (storagename, "w")) == NULL)
X    {
X      printf ("Cannot open storage file %s\n", filename);
X      exit (0);
X    }
X    storeparameters ();
X  }
X
X  if (enable_replay)
X  {
X    if ((fpout = fopen (replayname, "r")) == NULL)
X    {
X      printf ("Cannot open replay file %s\n", filename);
X      exit (0);
X    }
X    loadparameters (displayname);
X  }
X
X  if (enable_load && !enable_edit)
X  {
X    if ((fptemp = fopen (mapname, "r")) == NULL)
X    {
X      printf ("Cannot open map file %s\n", mapname);
X      exit (0);
X    }
X
X    fread (&boardsizex, sizeof(int), 1, fptemp);
X    fread (&boardsizey, sizeof(int), 1, fptemp);
X    fread (&enable_hex, sizeof(int), 1, fptemp);
X    fread (&enable_hills, sizeof(int), 1, fptemp);
X    fread (&enable_forest, sizeof(int), 1, fptemp);
X    fread (&enable_sea, sizeof(int), 1, fptemp);
X    fread (&enable_terrain, sizeof(int), 1, fptemp);
X
X    fclose (fptemp);
X  }
X
X  if (enable_hex)
X  {
X    squaresize[0] = squaresize[0]/2;
X
X    if (squaresize[0]%2 == 1)
X      squaresize[0] -= 1;
X  }
X
X  if (enable_area)
X  {
X    full = ((double)(MAXVAL))/((MAXVAL+4)*(MAXVAL+4));
X
X    offset = 0.18;
X    factor = sqrt(full*MAXVAL)/(sqrt(full*MAXVAL)-offset); 
X
X
X    for (i=0; i<=MAXVAL+4; i++)
X    {
X      areavalue[i] = (sqrt(full*(float)i)-offset)*factor;
X      if (areavalue[i] < 0.0)
X        areavalue[i] = 0.0;
X    }
X  }
X  else
X  {
X    for (i=0; i<=MAXVAL+4; i++)
X      areavalue[i] =  ((double)(i)) / (MAXVAL + 4);
X  }
X
X#if MULTITEXT
X  for (i=0; i<nsides; i++)
X    strcpy (personal_messagestr[i], messagestr);
X#endif
X}
X
END_OF_FILE
if test 32059 -ne `wc -c <'parse.c'`; then
    echo shar: \"'parse.c'\" unpacked with wrong size!
fi
# end of 'parse.c'
fi
if test -f 'tutorial2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tutorial2'\"
else
echo shar: Extracting \"'tutorial2'\" \(19904 characters\)
sed "s/^X//" >'tutorial2' <<'END_OF_FILE'
X#! /bin/sh
X
Xecho "=================== XBATTLE TUTORIAL 2 ========================" 
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho "I will presume that  you have  already  done the first tutorial,"
Xecho "and  hopefully played  a few games   with some of   your friends"
Xecho "before trying out  this tutorial.   Here we will  show you  some"
Xecho "more advanced things you can do with xbattle."
X
Xecho
X
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho "First, we  will   introduce  guns  and   paratroops.  These  are"
Xecho "particularly  handy when you have  seas  that cannot be crossed,"
Xecho "and can  also be used  for commando attacks or to  break  supply"
Xecho "lines behind enemy lines.  Guns are aimed with the  mouse in the"
Xecho "game square from which you wish to shoot, and the  direction and"
Xecho "distance of your cursor click from the center of the game square"
Xecho "determines the azimuth and range of  the shot.  For  example, if"
Xecho "the mouse is in position A below,  i.e. just above  center, then"
Xecho "the shot will  fall  at short range to  the  north.   Position B"
Xecho "represents a long range shot to the north, and C, a medium range"
Xecho "shot to the south  east.  The shot is  triggered by striking the"
Xecho "'g'  key on the  keyboard (g for  'guns') while aiming  with the"
Xecho "mouse."
X
Xecho "              GAME SQUARE"
Xecho "	   =============================="
Xecho "	   ||             B             ||"
Xecho "	   ||                           ||"
Xecho "	   ||                           ||"
Xecho "	   ||                           ||"
Xecho "	   ||                           ||"
Xecho "	   ||             A             ||"
Xecho "	   ||                           ||"
Xecho "	   ||            -|-            ||"
Xecho "	   ||                           ||"
Xecho "	   ||                           ||"
Xecho "	   ||                           ||"
Xecho "	   ||                           ||"
Xecho "	   ||                   C       ||"
Xecho "	   ||                           ||"
Xecho "	   ||                           ||"
Xecho "	   ||                           ||"
Xecho "	   =============================="
X
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho "Paratroops  are  launched in exactly  the same way,  except this"
Xecho "time you use  the 'p' key  (p for paratroops).  Every shot costs"
Xecho "one troop, and will kill  one troop in  the enemy square,  while"
Xecho "every paratroop  costs  3  troops from  the  source  square, and"
Xecho "arrives in the enemy square as a normal troop.  Be  careful with"
Xecho "the  guns, because they  can kill  your troops  as  well  as the"
Xecho "enemy's.   Guns  and  paratroops  are  called   with the command"
Xecho "options '-guns' and '-para', each with an argument that controls"
Xecho "the maximum range (in game squares).  For  example, try  out the"
Xecho "following game."
X
Xecho
Xecho "> xbattle -black me -white you -board 10 -square 64 -militia 5  -rbases 1 -guns 5 -para 5"
Xecho
X
Xecho
Xecho "hit RETURN to start the game"
Xread p1
X
Xxbattle -black me -white you -board 10 -square 64 -militia 5  -rbases 1  -guns 5 -para 5 &
X
Xecho
Xecho "hit RETURN to continue after game"
Xread p1
Xclear
X
Xecho "Another set of options allow you to build and destroy the supply"
Xecho "bases.  The option '-build <n>' lets you  build them by pointing"
Xecho "to a game square which is completely full of troops and pressing"
Xecho "the 'b' key (b for build).  This operation will cost you all the"
Xecho "troops in  the square, and  will only build  a partial base- the"
Xecho "operation will have to be repeated a number of times  before the"
Xecho "base is complete and can go into production.   The total cost of"
Xecho "building a base is <n> full troop squares.  "
X
Xecho
X
Xecho "Bases can be scuttled (destroyed) with the '-scuttle' option (no"
Xecho "argument) by  again positioning   the  cursor on the    base and"
Xecho "pressing the 's' key  (s for  scuttle).  Again, you will have to"
Xecho "have some troops in the square,  and it may take several scuttle"
Xecho "operations  to completely  destroy it, but  each operation costs"
Xecho "only a single  troop,  and  is thus  much cheaper  than building"
Xecho "them.  A base can be scuttled to  prevent it falling  into enemy"
Xecho "hands."
X
Xecho
X
Xecho "Try building and scuttling a few bases in the next example.  Try"
Xecho "doing a partial scuttle and then rebuilding again."
Xecho
Xecho "> xbattle -black me -white you -board 10 -square 64 -hex -militia 5  -rbases 1  -build 4 -scuttle"
X
X
Xecho
Xecho "hit RETURN to start the game"
Xread p1
X
Xxbattle -black me -white you -board 10 -square 64 -hex -militia 5  -rbases 1  -build 4 -scuttle &
X
Xecho
Xecho "hit RETURN to continue after game"
Xread p1
Xclear
X
Xecho "Another way you can modify the game board during the  game is to"
Xecho "fill or  dig, to raise  or lower the  elevation.  When used with"
Xecho "'-sea', digging  creates a new square  of sea, while filling can"
Xecho "fill one in.  Each operation costs  <n>  full troop squares, and"
Xecho "is performed by putting  the cursor in  that square  and hitting"
Xecho "'d' to dig.  To fill  in a sea, the troops  cannot march into it"
Xecho "first,  so you must  do the next  best  thing- march your troops"
Xecho "next to  the sea  and then command  them to  march into  it   by"
Xecho "clicking a command vector to point to the sea,  then hit the 'f'"
Xecho "key to fill  in.  The arguments for dig  and fill  must have the"
Xecho "same value."
Xecho
Xecho "Try digging and filling a few seas in the next example.  "
Xecho
X
Xecho "> xbattle -black me -white you -board 10 -square 64 -militia 5  -rbases 1  -sea 2 -dig 4 -fill 4"
X
Xecho
Xecho "hit RETURN to start the game"
Xread p1
X
Xxbattle -black me -white you -board 10 -square 64 -militia 5  -rbases 1  -sea 2 -dig 4 -fill 4 &
X
Xecho
Xecho "hit RETURN to continue after game"
Xread p1
Xclear
X
Xecho "When used with the '-hills' option, the  digging and filling can"
Xecho "be used to  lower  or raise the   elevation to  create defensive"
Xecho "fortifications.  In this  case, each  dig or fill costs only one"
Xecho "full  troop square regardless of  the  value you  supply for the"
Xecho "arguments -dig  and   -fill.   You must supply  dummy  arguments"
Xecho "nevertheless.  Try this out in the next example."
Xecho
Xecho "> xbattle -black me -white you -board 10 -square 64 -militia 5  -rbases 1  -hills 9 -dig 5 -fill 5 &"
X
X
Xecho
Xecho "hit RETURN to start the game"
Xread p1
X
Xxbattle -black me -white you -board 10 -square 64 -militia 5  -rbases 1  -hills 9 -dig 2 -fill 2 &
X
Xecho
Xecho "hit RETURN to continue after game"
Xread p1
Xclear
X
Xecho "You can bias a game to favor a player with less experience.  Not"
Xecho "all xbattle parameters can be biased, but a good many can.  Here"
Xecho "is an example."
Xecho
Xecho "> xbattle -options tribal.xbo -black { -fight 9 -move 9 } me -white me -board 10 -manpos"
Xecho
X
Xecho "In this example the arguments  in the {braces}  between '-black'"
Xecho "and 'me' apply only to black, not  to white.  In this  case, the"
Xecho "black troops will move quickly  and have an  increased  fighting"
Xecho "strength compared to white, who  has the default values of these"
Xecho "parameters.  Note the spaces on either side  of the '{' and '}'."
Xecho "Xbattle  options  are evaluated  sequentially,   therefore later"
Xecho "options can overwrite   earlier options. If you wished  to set a"
Xecho "default '-fight  3' for  all players except  black,  this option"
Xecho "would have to be placed first in  the sequence in order to avoid"
Xecho "overwriting the  biased  options set   for black.  Try   out the"
Xecho "difference between these fight and move settings."
X
Xecho
Xecho "hit RETURN to start the game"
Xread p1
X
Xxbattle -options tribal.xbo -black { -fight 9 -move 9 } me -white me -board 10  -manpos&
X
Xecho
Xecho "hit RETURN to continue after game"
Xread p1
Xclear
X
Xecho "Another  interesting dynamic parameter  called '-digin' dictates"
Xecho "that  troops moving through open  country  move faster than when"
Xecho "they  have to 'trip  over'  each other.  With this parameter, it"
Xecho "takes  time for your troops  to 'dig in' at the  front; the more"
Xecho "troops there are  in a square, the  slower the new  troops enter"
Xecho "that square, rather like  the charging  of a capacitor.  Another"
Xecho "option called 'hidden' makes the troop command vectors invisible"
Xecho "to the   enemy, so that   the enemy  can only see    your  troop"
Xecho "deployment, not  your marching   orders.  Another option  called"
Xecho "'disrupt' will cause  your  troops to forget all  their marching"
Xecho "orders as soon  as they are   under attack.  This will  make you"
Xecho "have to  repeat your orders to them  when they panic in the heat"
Xecho "of  battle.  These options  can all be biased,  as shown in  the"
Xecho "next example.  Note that in  this case,  all three options serve"
Xecho "to hinder black; his  troop convoys are  sluggish, he cannot see"
Xecho "white's command vectors, and his supply lines can be cut  with a"
Xecho "single momentary attack by white."
Xecho
Xecho "> xbattle -options tribal.xbo -black { -digin 9 -hidden } me -white { -disrupt } me -board 10  -manpos&"
X
Xecho
Xecho "hit RETURN to start the game"
Xread p1
X
Xxbattle -options tribal.xbo -black { -digin 9 -hidden } me -white { -disrupt } me -board 10  -manpos&
X
Xecho
Xecho "hit RETURN to continue after game"
Xread p1
Xclear
X
Xecho "There are a few alternative  ways  to command groups of your men"
Xecho "to  march  simultaneously.   One is   controlled  by the  option"
Xecho "'-march <n>'  whereby you  command your troops to start marching"
Xecho "in a particular direction and continue until told  to stop.  The"
Xecho "speed  is set  with the  argument <n>.  To  march  your  troops,"
Xecho "position your mouse and hold down the shift key as you click.  A"
Xecho "march command is displayed as a  double command vector, and such"
Xecho "commands can be  set up on  empty  game  squares  to steer  your"
Xecho "troops in more complex paths.  The  stop command can also be set"
Xecho "by clicking in the center  of the square,  and is displayed as a"
Xecho "small box.  If  the march is commenced  with  a shift-leftmouse,"
Xecho "the troops will split if they cross another supply line, whereas"
Xecho "when set with  the  middle mouse, they  will cross  over   other"
Xecho "supply lines.  Try out the march option in the following game."
Xecho
Xecho "> xbattle -black me -militia 3 -march 5"
Xecho
Xecho "hit RETURN to start the game"
Xread p1
X
Xxbattle -black me -militia 3 -march 5&
X
Xecho
Xecho "hit RETURN to continue after game"
Xread p1
Xclear
X
Xecho "Another  way to give  group commands to your troops  is with the"
Xecho "'bound'  option.  When this option  is active, you can  give the"
Xecho "same movement command   to  all  the troops  within  a  bounding"
Xecho "rectangle defined as follows.  Click the  mouse, for instance to"
Xecho "'march east' in a particular square, but hold the mouse down and"
Xecho "drag it diagonally across other gamesquares to the square at the"
Xecho "opposite corner of the  bounding rectangle before  releasing the"
Xecho "button.   All the troops within  the    rectangle will obey  the"
Xecho "command.  Try this option in the following game."
Xecho
Xecho "> xbattle -black me -militia 3 -bound"
Xecho
Xecho "hit RETURN to start the game"
Xread p1
X
Xxbattle -black me -militia 3 -bound&
X
Xecho
Xecho "hit RETURN to continue after game"
Xread p1
Xclear
X
Xecho "If  you have  played an interesting game  you may wish to review"
Xecho "the action afterwards to learn from your  mistakes.  This can be"
Xecho "done with the '-store' option, which  will save all the graphics"
Xecho "commands to a file.  The file can  be reviewed with  the -replay"
Xecho "option.  The stored  file can be  enormous, especially for  long"
Xecho "games on a  large  board, so   be careful.   If your    quota is"
Xecho "exceeded during the game,  xbattle will quietly stop  writing to"
Xecho "the store file,  but the game will  continue uninterrupted.  You"
Xecho "will just miss the tail end of the battle on the replay."
Xecho
Xecho "We will  try to store a game  in the next  example-   move  your"
Xecho "armies around the board in interesting formations, and then exit"
Xecho "the game as usual.  Then we will watch the replay."
Xecho
Xecho "> xbattle -black me -white you -board 10 -farms 5 -militia 5 -store xbattle.xba"
Xecho
X
Xecho
Xecho "hit RETURN to start the game"
Xread p1
X
X
Xxbattle -black me -white you -board 13 -farms 5 -militia 5 -store xbattle.xba&
X
Xecho
Xecho "hit RETURN to continue after game"
Xread p1
Xclear
X
Xecho "To replay the game, all you have to  do is  give a display name,"
Xecho "the other options will not be needed.  To flag the  display name"
Xecho "you will have to give a dummy team color,  for example '-black',"
Xecho "although this  argument will  actually be  ignored, so you could"
Xecho "just as well have used '-white', or '-red' for that matter.  You"
Xecho "must however give the display name on which the  replay is to be"
Xecho "viewed."
X
Xecho
X
Xecho "The replay file stores none of the actual game  parameters, only"
Xecho "the  graphics commands,  and  in  replay mode xbattle   does not"
Xecho "respond to any of the normal commands, it is  even impossible to"
Xecho "quit from the replay after it is done (sorry- we have not gotten"
Xecho "around to  that yet)  so you will have to  kill the window  some"
Xecho "other way, or  just hide it  behind another  window for now.  We"
Xecho "will   use  the  '-manpos' option  so  you can place  the window"
Xecho "conveniently."
X
Xecho
Xecho "> xbattle -black me -manpos -replay xbattle.xba"
Xecho
X
Xecho
Xecho "hit RETURN to start the replay"
Xread p1
X
Xxbattle -black me -manpos -replay xbattle.xba&
X
Xecho
Xecho "hit RETURN to continue after game"
Xread p1
Xclear
X
Xecho "The replayed  game board  will  not respond to any commands, not"
Xecho "even the control-c exit key, so you will have to dispose of it's"
Xecho "xwindow by other means (such as a  kill  window command, or kill"
Xecho "the process)."
Xecho
Xecho "We  will  now  delete  the  saved file  to conserve  disk space."
Xecho "Remember to do this, since these files can be very big.  On unix"
Xecho "systems it is convenient to save your games to /tmp/xbattle.xba,"
Xecho "the system temporary directory."
X
Xecho
Xecho "> rm xbattle.xba"
Xecho
X
Xrm xbattle.xba
X
Xecho
Xecho "It is also possible to save the state  of  the game at any point"
Xecho "during the combat, and to continue the game from that point some"
Xecho "time in the future.  This is done by pressing 'control-p' in the"
Xecho "text  area      during   the game.    The  game  will   continue"
Xecho "uninterrupted, and the  only  acknowledgement  you will see is a"
Xecho "print out of some game  statistics on the  window where the game"
Xecho "was started.  Later we will show you how to resume the game."
X
Xecho
X
Xecho "In the  next example, do some  moves,  then press 'control-p' in"
Xecho "the text area, then do  some more moves  and then exit normally."
Xecho "You will see that when we load the game state file the game will"
Xecho "resume from the point where you pressed the control-p."
X
Xecho
Xecho "> xbattle -black me -white you -board 10 -farms 5 -militia 5"
Xecho
X
Xecho
Xecho "hit RETURN to start the game"
Xread p1
X
Xxbattle -black me -white you -board 10 -farms 5 -militia 5
X
Xecho
Xecho "hit RETURN to continue after game"
Xread p1
Xclear
X
Xecho "Now, we will resume the game from the point where  you saved it."
Xecho "by using  the '-load' option.  This  option sets several options"
Xecho "automatically from the file, but  must have other options set in"
Xecho "the  command  line to   match  the original  parameters that the"
Xecho "original  game used.   Read the  manual very   carefully on this"
Xecho "subject, as  it gets  quite complicated.  In future  releases of"
Xecho "xbattle we will probably have cleaned this up somewhat."
X
Xecho
Xecho "> xbattle -black me -white you -board 10 -load"
X
Xecho
Xecho "hit RETURN to start the replay"
Xread p1
X
Xxbattle -black me -white you -board 10 -load&
X
Xecho
Xecho "hit RETURN to continue after the resumed game"
Xread p1
Xclear
X
Xecho "It  is possible  to  edit the  stored file  and  to change  many"
Xecho "features of the terrain,  or to set  up new armies, and create a"
Xecho "whole battle scenario in advance.  This is done with the command"
Xecho "option '-edit', which completely redefines the xbattle controls,"
Xecho "and disables all normal playing.  When editing an existing file,"
Xecho "you must be very careful to call exactly  the same options as in"
Xecho "the original file- number of teams and team colors, hills, seas,"
Xecho "board size, square size, etc. otherwise  unexpected things might"
Xecho "happen.  The edit feature is brand new, and still has a few bugs"
Xecho "in it.  Let  us therefore edit a completely  new file, and allow"
Xecho "for hills, seas, and two armies.  "
X
Xecho
X
Xecho "When you start this game, place the window to  the  side so that"
Xecho "you  will be  able to see  the  menu that  describes the editing"
Xecho "commands.  Try them out, and  remember to finish with 'd'  (dump"
Xecho "to file) and 'e' (exit).  Afterwards,  we will play  on your new"
Xecho "terrain map."
X
Xecho
Xecho "> xbattle -edit -manpos -black me -white you -board 10 -hills 5 -sea 5"
Xecho
Xecho "hit RETURN to start the editing"
Xread p1
X
Xxbattle -edit -manpos -black me -white you -board 10 -hills 5 -sea 5&
X
Xecho "EDIT MODE COMMANDS"
Xecho "=================="
Xecho
Xecho "      left button:     lower terrain by one notch (sea lowest)"
Xecho "      middle button:   raise  terrain  by  one  notch  (sea lowest)"
Xecho "      right button:    toggle between lowest and mid terrain"
Xecho ""
Xecho "      c:    create city (growth = 100)"
Xecho "      t:    create town (growth = 80)"
Xecho "      v:    create village (growth = 60)"
Xecho "      k:    increase size of city by 5 percent"
Xecho "      j:    decrease size of city by 5 percent"
Xecho "      s:   scuttle city - remove 36 degrees of arc"
Xecho "      b:    build city - add 36 degrees of arc"
Xecho ""
Xecho "      0-9:  create troop square with troops of current color"
Xecho "      [:    decrease troop amount by 1"
Xecho "      ]:    increase troop amount by 1"
Xecho "      r:    change current color"
Xecho "      f:    change color of existent troop square"
Xecho "      d:    dump board with name <filename>"
Xecho "      l:    load board with name <filename>"
Xecho "      e:    exit"
Xecho ""
Xecho " FINISH EDITING with 'd' (dump) followed by 'e' (exit)"
Xecho
Xecho "hit RETURN after editing"
Xread p1
Xclear
X
Xecho "And now we will play on the game board you just created by using"
Xecho "the    '-load'   option.    This   looks for   the  file  called"
Xecho "'xbattle.xbt', unless it is given another filename."
X
Xecho
Xecho ">  xbattle -load -black me -white you  -board 10 -hills 5 -sea 5"
X
Xecho
Xecho "hit RETURN to start the game"
Xread p1
X
Xxbattle -load -black me -white you  -board 10 -hills 5 -sea 5&
X
Xecho
Xecho "hit RETURN to continue after game"
Xread p1
Xclear
X
Xecho "You have  now been introduced to  just about all of  the options"
Xecho "available  in xbattle.  We have  skipped over  some  of the more"
Xecho "obscure variations of the horizon option (map, basemap, localmap"
Xecho "etc.) but you can read about these  in  the man page  if you are"
Xecho "interested. Also in the man page is a description of a number of"
Xecho "different compile-time options sent  in  by xbattlers around the"
Xecho "world, including different  mouse button definitions,  different"
Xecho "text lines, different command vectors, and so forth.  Finally, I"
Xecho "encourage  you to try  'skirmish.xbo', an options file used with"
Xecho "the   '-options'  argument.  This   creates  a  fast paced  game"
Xecho "employing a  good   many   of the   options  introduced  in this"
Xecho "tutorial.  Try your own variations, and above all,"
Xecho
Xecho "           Happy xbattling!"
X
Xecho "================= END OF XBATTLE TUTORIAL ==================="
END_OF_FILE
if test 19904 -ne `wc -c <'tutorial2'`; then
    echo shar: \"'tutorial2'\" unpacked with wrong size!
fi
chmod +x 'tutorial2'
# end of 'tutorial2'
fi
echo shar: End of archive 6 \(of 7\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
