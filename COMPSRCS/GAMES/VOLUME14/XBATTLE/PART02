Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i073:  xbattle - multi-player battle strategy game for X-Windows, Part02/07
Message-ID: <3512@master.CNA.TEK.COM>
Date: 7 Sep 92 21:22:52 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1658
Approved: billr@saab.CNA.TEK.COM

Submitted-by: slehar@cns.bu.edu
Posting-number: Volume 14, Issue 73
Archive-name: xbattle/Part02
Environment: Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 7)."
# Contents:  main.c patchlevel.h tribal.xbo
# Wrapped by billr@saab on Mon Sep  7 14:18:49 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(48734 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X#include <stdio.h>
X  
X/**** x include files ****/
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xatom.h>
X#include <X11/keysym.h>
X#include <X11/keysymdef.h>
X
X#include "global.h"
X
X#if UNIX
X#include <sys/types.h>
X#include <sys/time.h>
X#endif
X
X/*************************************************************************/
X/**	xbattle								**/
X/**									**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/**     Greg Lesher (lesher@park.bu.edu)				**/
X/** with horizon and sea contribution from				**/
X/**     Mark Lauer (elric@cs.su.oz.au)                                  **/
X/**									**/
X/*************************************************************************/
X
Xmain(argc,argv)
X  int argc;
X  char *argv[];
X{ 
X  int i,j,t,p,
X      winxsize[MAXSIDES],
X      winysize[MAXSIDES];
X
X  long eventmask;
X  XEvent event;
X  char displayname[MAXPLAYERS][80],
X       gtitle[20], htitle[20];
X  square_type *board;
X#if UNIX
X  int fd, maxfd;
X  int selectback;
X  unsigned long newtime, oldtime, targettime;
X  fd_set rfds, disp_fds;
X  struct timeval tval;
X  struct timeval tp_old;
X  struct timezone tzp;
X#endif
X  
X  /**** getarg functions ****/
X  int intval(),is_arg();
X  double doubleval();
X  int stringval();
X
X  /**** parse the command line ****/
X
X  init_defaults();
X  checkoptions(argc,argv);
X  get_displaynames(displayname,colorarray,rcolorarray,argc,argv);
X  init_options(displayname,argc,argv);
X  clean_options (displayname);
X
X  if (enable_hex)
X  {
X    init_hex (squaresize[0]);
X
X    for (i=0; i<nsides; i++)
X    {
X      for (j=0; j<nsides; j++)
X#if MULTITEXT
X      textyh[i][j]=boardsizey*2*hex_vert + hex_vert + 12 + 16*j,
X#else
X      textyh[i][j]=boardsizey*2*hex_vert + hex_vert + 12,
X      textyl[i][j]=boardsizey*2*hex_vert + hex_vert + 28;
X#endif
X
X      winxsize[i] = (boardsizex-1)*3*(hex_halfside) + 2*hex_side;
X
X#if MULTITEXT
X      winysize[i] = boardsizey*2*hex_vert + hex_vert + nsides*TEXTSIZE;
X#else
X      winysize[i] = boardsizey*2*hex_vert + hex_vert + 2*TEXTSIZE;
X#endif
X    }
X  }
X  else
X  { 
X    for (i=0; i<nsides; i++)
X    {
X      for (j=0; j<nsides; j++)
X#if MULTITEXT
X      textyh[i][j]=boardsizey*squaresize[i]+12+16*j,
X#else
X      textyh[i][j]=boardsizey*squaresize[i]+12,
X      textyl[i][j]=boardsizey*squaresize[i]+28;
X#endif
X
X      winxsize[i] = boardsizex*squaresize[i];
X#if MULTITEXT
X      winysize[i] = boardsizey*squaresize[i] + nsides*TEXTSIZE;
X#else
X      winysize[i] = boardsizey*squaresize[i] + 2*TEXTSIZE;
X#endif
X    }
X  } 
X
X  /**** allocate the boards ****/
X  board  = (square_type *)(malloc(boardsizex*boardsizey*sizeof(square_type)));
X
X  init_board (board);
X  
X  /**** open x windows ****/
X#if UNIX
X  maxfd = 0;
X  FD_ZERO(&disp_fds);
X#endif
X
X  if (enable_bound)
X    eventmask = ButtonPressMask|ButtonReleaseMask|ButtonMotionMask|KeyPressMask|ExposureMask;
X  else
X    eventmask = ButtonPressMask|ButtonMotionMask|KeyPressMask|ExposureMask;
X
X  for (p=0; p<nplayers; p++)
X  {
X    xwindow[p]  = (xwindow_type*)malloc(sizeof(xwindow_type));
X
X    strcpy (gtitle, graytitle[color2bw[sidemap[colorarray[p]]]]);
X    strcpy (htitle, huetitle[sidemap[colorarray[p]]]);
X
X    if (lettermap[colorarray[p]][0])
X      strcpy (gtitle, htitle);
X
X    if (enable_manpos[colorarray[p]])
X      open_xwindow(xwindow[p],displayname[p],-1,-1,
X		          winxsize[colorarray[p]],winysize[colorarray[p]],
X                          gtitle, htitle, eventmask,squaresize[colorarray[p]]);
X    else
X      open_xwindow(xwindow[p],displayname[p],XPOS,YPOS,
X		          winxsize[colorarray[p]],winysize[colorarray[p]],
X                          gtitle, htitle, eventmask,squaresize[colorarray[p]]);
X
X#if UNIX
X    if ((fd = ConnectionNumber (xwindow[p]->display)) > maxfd)
X      maxfd = fd;
X    FD_SET (fd, &disp_fds); 
X#endif
X  }  
X
X  if (enable_edit)
X    edit_board(board);
X
X  /**** replay game ****/
X  if (enable_replay)
X    replaygame(squaresize[0], board);
X  
X  /************* main event loop *************/
X#if UNIX
X  XSetIOErrorHandler(1);
X  gettimeofday (&tp_old, &tzp);
X  oldtime = (tp_old.tv_sec%10000)*1000000 + tp_old.tv_usec;
X  targettime = oldtime + (delay/10000)*1000000 + (delay%10000)*100;
X
X  while (TRUE)
X  {
X    /**** check for events ****/
X    rfds = disp_fds;
X
X    tval.tv_sec = (targettime-oldtime)/1000000;
X    tval.tv_usec = (targettime-oldtime)%1000000;
X
X    selectback = select (maxfd+1, &rfds, NULL, NULL, &tval);
X
X    gettimeofday (&tp_old, &tzp);
X    newtime = (tp_old.tv_sec%10000)*1000000 + tp_old.tv_usec;
X
X    if (newtime < oldtime)
X      targettime = newtime - 1;
X
X    switch (selectback)
X    {
X      case -1:
X        perror("select()");
X        exit (1);
X        break;
X
X      case 0:
X        for (i=0; i<nplayers; i++)
X        {
X          if (winopen[i])
X          {
X            XFlush(xwindow[i]->display);
X            while (XEventsQueued(xwindow[i]->display, QueuedAfterReading) > 0)
X            {
X	      XNextEvent(xwindow[i]->display, &event);
X	      process_event(event,board,colorarray,i);
X            }
X
X#if MULTIFLUSH
X            XFlush(xwindow[i]->display);
X#endif
X          }
X        }
X        break;
X
X      default:
X        for (i=0; i<nplayers; i++)
X        {
X          if (winopen[i])
X          {
X            if (FD_SET(fd = ConnectionNumber(xwindow[i]->display), &rfds))
X            {
X              while (winopen[i] &&
X                    XEventsQueued(xwindow[i]->display, QueuedAfterReading) > 0)
X         
X              {
X	        XNextEvent(xwindow[i]->display, &event);
X	        process_event(event,board,colorarray,i);
X              }
X
X#if MULTIFLUSH
X              XFlush(xwindow[i]->display);
X#endif
X
X              if (!winopen[i])
X                FD_CLR (fd, &disp_fds);
X            }
X          }
X        }
X        break;
X    }
X
X    if (newtime > targettime)
X    {
X      if (enable_march)
X        march(board);
X      update_board(board);
X      targettime = newtime + (delay/10000)*1000000 + (delay%10000)*100;
X    }
X    oldtime = newtime;  
X  }
X#else
X  t = 0;
X  while (TRUE)
X  {
X    /**** check for events ****/
X    for (i=0; i<nplayers; i++)
X    {
X      if (!winopen[i])
X        continue;
X      if (XEventsQueued(xwindow[i]->display, QueuedAfterReading) > 0)
X      {
X	XNextEvent(xwindow[i]->display, &event);
X	process_event(event,board,colorarray,i);
X      }
X      else
X        XFlush(xwindow[i]->display);
X    }
X    
X    /**** update the game board ****/
X    if (t++>delay)
X    {
X      t = 0;
X      if (enable_march)
X        march(board);
X      update_board(board);
X    }
X  }
X#endif
X}
X
X
X 
X/*************************************************************************/
X/**	process_event							**/
X/** Process the x event from the xwindow of 'player'			**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xprocess_event(event,board,colorarray,player)
X  XEvent event;
X  square_type *board;
X  int colorarray[MAXPLAYERS], player;
X{
X  int i, j, k, x, y,
X      xpos, ypos,
X      textcount,
X      limit,
X      tdir[DIRS],
X      xlow, xhigh, ylow, yhigh,
X      status,
X      color,
X      control,
X      shift;
X  char text[10],
X       line[10];
X  double val;
X  KeySym key;
X  char keyvector[32];
X  unsigned int bitindex,
X               byteindex;
X  KeyCode code;
X  square_type *square2;
X  
X  /**** Process events ****/
X  switch (event.type)
X  {
X    /**** process expose event ****/
X    case Expose:
X      drawboard(board, player, FALSE);
X      break;
X    
X    /**** process button presses ****/
X    case ButtonPress:
X
X      if (winwatch[player])
X        break;
X
X#if PAUSE
X      if (paused)
X        break;
X#endif
X      
X      /**** left button ****/
X      switch (event.xbutton.button)
X      {
X        case Button1:
X        case Button2:
X          shift = event.xbutton.state & ShiftMask;
X
X          if (enable_personalmarch[colorarray[player]] && shift)
X          {
X            oldx[player] = -1;
X            oldy[player] = -1;
X
X            getsquare(event.xbutton.x,event.xbutton.y,&x,&y,tdir,squaresize[colorarray[player]],board,shift);
X               
X            color = colorarray[player];
X
X            if (enable_sea && SQUARE(board,x,y)->color==none && SQUARE(board,x,y)->value[none]<=0)
X              break;
X            else if (SQUARE(board,x,y)->color == color &&
X                                     SQUARE(board,x,y)->value[color] > 0) 
X            {
X              SQUARE(board,x,y)->anymarch = ACTIVE;
X              SQUARE(board,x,y)->marchcolor = color;
X              SQUARE(board,x,y)->marchcount = 0;
X            }
X            else
X            {
X              SQUARE(board,x,y)->march[color] = PASSIVE;
X            }
X
X            for (i=0; i<directions; i++)
X              SQUARE(board,x,y)->marchdir[color][i] = 0;
X
X            if (event.xbutton.button == Button1)
X              SQUARE(board,x,y)->marchtype[color] = SET;
X            else
X              SQUARE(board,x,y)->marchtype[color] = FORCE;
X
X            for (i=0; i<directions; i++)
X              if (tdir[i])
X              {
X                SQUARE(board,x,y)->marchdir[color][i] = 1;
X                i = 5;
X              }
X            if (SQUARE(board,x,y)->march[color] == PASSIVE)
X              outdated[x][y] = ALL;
X            break;
X          }
X
X          getsquare(event.xbutton.x,event.xbutton.y,&x,&y,dir[player],squaresize[colorarray[player]],
X                                                              board,shift);
X
X          if (enable_personalbound[colorarray[player]])
X          {
X            oldx[player] = x;
X            oldy[player] = y;
X            break;
X          }
X        
X          /**** move ****/
X          if (SQUARE(board,x,y)->color == colorarray[player] ||
X               (!enable_disrupt[colorarray[player]] && SQUARE(board,x,y)->color==FIGHT &&
X                                SQUARE(board,x,y)->oldcolor == colorarray[player]))
X          {
X#if VARMOUSE
X            if (event.xbutton.button == Button1)
X            {
X	      moveon(SQUARE(board, x,y),dir[player]);
X              dirtype[player] = SET;
X            }
X            else
X            {
X	      moveoff(SQUARE(board, x,y),dir[player]);
X              dirtype[player] = FORCE;
X            }
X#else
X            if (event.xbutton.button == Button1)
X            {
X	      setmove(SQUARE(board, x,y),dir[player]);
X              dirtype[player] = SET;
X            }
X            else
X            {
X	      forcemove(SQUARE(board, x,y),dir[player]);
X              dirtype[player] = FORCE;
X            }
X#endif
X
X            dumpsquare (board, SQUARE(board,x,y));
X          }
X
X          if (enable_personalmarch[colorarray[player]])
X            if (SQUARE(board,x,y)->march[colorarray[player]] || SQUARE(board,x,y)->anymarch)
X            {
X              if (SQUARE(board,x,y)->anymarch == ACTIVE &&
X                             SQUARE(board,x,y)->marchcolor == colorarray[player])
X              {
X                SQUARE(board,x,y)->anymarch = FALSE;
X                SQUARE(board,x,y)->march[colorarray[player]] = FALSE;
X              }
X              else
X              {
X                SQUARE(board,x,y)->march[colorarray[player]] = FALSE;
X                outdated[x][y] = ALL;
X                dumpsquare (board, SQUARE(board,x,y));
X              }
X            }
X
X          break;
X  
X        case Button3:
X  
X          if (enable_artillery[colorarray[player]] || enable_paratroops[colorarray[player]] ||
X                                              enable_repeat[colorarray[player]])
X          {
X            getsquare(event.xbutton.x,event.xbutton.y,&x,&y,tdir,squaresize[colorarray[player]], board,shift);
X
X            if (SQUARE(board,x,y)->color == colorarray[player])
X            {
X              shift = event.xbutton.state & ShiftMask;
X              control = event.xbutton.state & ControlMask;
X
X              if (shift && enable_paratroops[colorarray[player]])
X                para (board, event.xbutton.x, event.xbutton.y, x, y, colorarray);
X              else if (control && enable_artillery[colorarray[player]])
X                fire (board, event.xbutton.x, event.xbutton.y, x, y, colorarray);
X              else if (enable_repeat[colorarray[player]]) 
X              {
X#if VARMOUSE
X                if (dirtype[player] == SET)
X	          moveon(SQUARE(board, x,y),dir[player]);
X                else
X	          moveoff(SQUARE(board, x,y),dir[player]);
X#else
X                if (dirtype[player] == SET)
X	          setmove(SQUARE(board, x,y),dir[player]);
X                else
X	          forcemove(SQUARE(board, x,y),dir[player]);
X#endif
X              dumpsquare (board, SQUARE(board,x,y));
X              }
X            }
X          }
X          break;
X      }
X      break;
X
X    case ButtonRelease:
X      if (!enable_personalbound[colorarray[player]])
X        break;
X
X      if ((oldx[player] == -1) && (oldy[player] == -1))
X        break;
X
X      getsquare(event.xbutton.x,event.xbutton.y,&x,&y,tdir,squaresize[colorarray[player]], board,shift);
X
X      if (y >= boardsizey)
X        y = boardsizey-1;
X      if (x >= boardsizex)
X        x = boardsizex-1;
X
X      if (oldx[player] < x)
X      {
X        xlow = oldx[player]; 
X        xhigh = x;
X      }
X      else
X      {
X        xlow = x;
X        xhigh = oldx[player]; 
X      }
X
X      if (oldy[player] < y)
X      {
X        ylow = oldy[player]; 
X        yhigh = y;
X      }
X      else
X      {
X        ylow = y;
X        yhigh = oldy[player]; 
X      }
X
X      switch (event.xbutton.button)
X      {
X        case Button1:
X        case Button2:
X
X          for (i=xlow; i<=xhigh; i++)
X          {
X            for (j=ylow; j<=yhigh; j++)
X            {
X              if (SQUARE(board,i,j)->color == colorarray[player] ||
X                     (!enable_disrupt[colorarray[player]] && SQUARE(board,i,j)->color==FIGHT &&
X                     SQUARE(board,i,j)->oldcolor == colorarray[player]))
X              {
X#if VARMOUSE
X                if (event.xbutton.button == Button1)
X	          moveon(SQUARE(board, i,j),dir[player]);
X                else
X	          moveoff(SQUARE(board, i,j),dir[player]);
X#else
X                if (event.xbutton.button == Button1)
X	          setmove(SQUARE(board, i,j),dir[player]);
X                else
X	          forcemove(SQUARE(board, i,j),dir[player]);
X#endif
X
X                dumpsquare (board, SQUARE(board,i,j));
X
X              }
X            }
X          }
X
X          break;
X
X        case Button3:
X          break;
X      }
X      break;
X  
X      /**** process key press events ****/
X    case KeyPress:
X      textcount = XLookupString(&event, text, 10, &key, NULL);
X      if (textcount != 0)
X      {
X        if ((enable_hex && (event.xbutton.y < boardsizey*2*hex_vert + hex_vert)) ||
X               (!enable_hex && (event.xbutton.y < boardsizey*squaresize[colorarray[player]])))
X        {
X          getsquare(event.xbutton.x,event.xbutton.y,&x,&y,dir[player],
X                                     squaresize[colorarray[player]], board,shift);
X          if (winwatch[player])
X            break;
X          switch (text[0])
X          {
X#if PAUSE
X            case CTRLS:
X              paused = TRUE;
X              break;
X            case CTRLQ:
X              paused = FALSE;
X              break;
X#endif
X            case 'a':
X            case 'A':
X              color = colorarray[player];
X
X              if (!enable_attack[color])
X                break;
X
X              if (SQUARE(board,x,y)->color == none || SQUARE(board,x,y)->color == color)
X                break;
X
X              for (i=0; i<directions; i++)
X                tdir[i] = 0;
X
X              for (i=0; i<directions; i++)
X              {
X                square2 = SQUARE(board,x,y)->connect[i];
X
X                if (square2 != SQUARE(board,x,y) && square2->color == color)
X                {
X                  tdir[(i+directions/2)%directions] = 1;
X                  forcemove (square2, tdir);
X                  tdir[(i+directions/2)%directions] = 0;
X                }
X              }
X
X              break;
X
X            case 'z':
X            case 'Z':
X              color = colorarray[player];
X              if (SQUARE(board,x,y)->color == color)
X              {
X                for (i=0; i<directions; i++)
X                  tdir[i] = 0;
X                forcemove (SQUARE(board,x,y), tdir);
X              }
X              break;
X
X            case 'p':
X            case 'P':
X              if (!enable_paratroops[colorarray[player]])
X                break;
X
X              getsquare(event.xbutton.x,event.xbutton.y,&x,&y,tdir,squaresize[colorarray[player]], board,shift);
X              if (SQUARE(board,x,y)->color == colorarray[player])
X                para (board, event.xbutton.x, event.xbutton.y, x, y, colorarray);
X              break;
X
X            case 'g':
X            case 'G':
X              if (!enable_artillery[colorarray[player]])
X                break;
X
X              getsquare(event.xbutton.x,event.xbutton.y,&x,&y,tdir,squaresize[colorarray[player]], board,shift);
X              if (SQUARE(board,x,y)->color == colorarray[player])
X                fire (board, event.xbutton.x, event.xbutton.y, x, y, colorarray);
X              break;
X
X            case 'd':
X            case 'D':
X              if (!enable_dig[colorarray[player]])
X                break;
X
X              if (SQUARE(board,x,y)->color == colorarray[player])
X              {
X                if (SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] > digcost &&
X                          SQUARE(board,x,y)->growth < 60 )
X                {
X                  if (SQUARE(board,x,y)->move == 0)
X                  {
X                    SQUARE(board,x,y)->value[none] -= 1; 
X
X                    if (enable_sea)
X                      SQUARE(board,x,y)->value[none] = 1 - fillnumber; 
X                    else if (SQUARE(board,x,y)->value[none] < 0) 
X                      SQUARE(board,x,y)->value[none] = 0; 
X
X                    SQUARE(board,x,y)->angle = 0;
X                    SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] = 0; 
X                    SQUARE(board,x,y)->move = 0;
X                    for (k=0; k<directions; k++)
X                      SQUARE(board,x,y)->dir[k] = 0;
X                    SQUARE(board,x,y)->lowbound = 0;
X                    outdatehorizon (board, x, y, SQUARE(board,x,y)->color);
X                    SQUARE(board,x,y)->color = none; 
X                    outdated[x][y] = ALL;
X                  }
X                  else if (SQUARE(board,x,y)->move == 1)  /** dig partially filled square **/
X                  {
X                    for (i=0; i<directions; i++)
X                    {
X                      if (SQUARE(board,x,y)->dir[i])
X                        square2 = SQUARE(board,x,y)->connect[i];
X                    }
X
X                    if (square2->color == none && square2->value[none] < 0)
X                    {
X                      square2->value[none] += 1;
X
X                      SQUARE(board,x,y)->move = 0;
X                      SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] = 0;
X                      for (k=0; k<8; k++)
X                        SQUARE(board,x,y)->dir[k] = 0;
X                      SQUARE(board,x,y)->lowbound = 0;
X                      outdatehorizon (board, square2->x, square2->x, ALL);
X                      outdated[x][y] = ALL;
X                      outdated[square2->x][square2->y] = ALL;
X                    }
X                  }
X                }
X              }
X              break;
X  
X            case 'f':
X            case 'F':
X              if (!enable_fill[colorarray[player]])
X                break;
X              if (SQUARE(board,x,y)->color == colorarray[player])
X              {
X                if (SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] > fillcost &&
X                          SQUARE(board,x,y)->move <= 1)
X                {
X                  if (SQUARE(board,x,y)->move == 1)
X                  {
X                    for (i=0; i<directions; i++)
X                    {
X                      if (SQUARE(board,x,y)->dir[i])
X                        square2 = SQUARE(board,x,y)->connect[i];
X                    }
X
X                    if (square2->color == none && square2->value[none] <= 0)
X                    {
X                      square2->value[none] -= 1;
X
X                      if (square2->value[none] <= (-fillnumber))
X                        square2->value[none] = 1;
X
X                      SQUARE(board,x,y)->move = 0;
X                      SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] = 0;
X                      for (k=0; k<directions; k++)
X                        SQUARE(board,x,y)->dir[k] = 0;
X                      SQUARE(board,x,y)->lowbound = 0;
X                      outdatehorizon (board, square2->x, square2->y, ALL);
X                      outdated[x][y] = ALL;
X                      outdated[square2->y][square2->y] = ALL;
X                    }
X                  }
X                  else if (enable_hills || enable_forest)
X                  {
X                    if (enable_hills)
X                      limit = NHILLTONES-1;
X                    else if (enable_forest)
X                      limit = NHILLTONES-1;
X                    else if (enable_sea)
X                      break;
X
X                    if (SQUARE(board,x,y)->value[none] < limit)
X                    {
X                      SQUARE(board,x,y)->value[none] += 1;
X
X                      SQUARE(board,x,y)->move = 0;
X                      SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] = 0;
X                      for (k=0; k<8; k++)
X                        SQUARE(board,x,y)->dir[k] = 0;
X                      SQUARE(board,x,y)->lowbound = 0;
X                      outdatehorizon (board, x, y, ALL);
X                      outdated[x][y] = ALL;
X                    }
X                  }
X                }
X              }
X              break;
X
X            case 's':
X            case 'S':
X              if (!enable_scuttle[colorarray[player]])
X                break;
X              if (SQUARE(board,x,y)->color == colorarray[player])
X              {
X                if (SQUARE(board,x,y)->growth >= 60 && !enable_build[colorarray[player]])
X                {
X                  val = SQUARE(board,x,y)->value[SQUARE(board,x,y)->color];
X                 
X                  SQUARE(board,x,y)->growth -= val; 
X                  SQUARE(board,x,y)->oldgrowth = SQUARE(board,x,y)->growth;
X
X                  if (SQUARE(board,x,y)->growth < 60)
X                  {
X                    SQUARE(board,x,y)->growth = 0;
X                    SQUARE(board,x,y)->oldgrowth = 0;
X                    SQUARE(board,x,y)->angle = 0;
X                  }
X
X                  SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] -= val/2;
X
X                  outdatehorizon (board, x, y, SQUARE(board,x,y)->color);
X                  outdated[x][y] = ALL;
X                }
X                else if (enable_build[colorarray[player]] && SQUARE(board,x,y)-> angle > 0 &&
X                  SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] >= scuttlerate[colorarray[player]])
X                {
X                  SQUARE(board,x,y)->angle -= buildrate[colorarray[player]];
X                  SQUARE(board,x,y)->growth = 0;
X                  if (SQUARE(board,x,y)->angle < 40)
X                  {
X                    SQUARE(board,x,y)->angle = 0; 
X                    SQUARE(board,x,y)->growth = 0; 
X                    SQUARE(board,x,y)->oldgrowth = 0; 
X                  }
X    
X                  SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] -= scuttlerate[colorarray[player]]; 
X                  if (SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] <= 0)
X                  {
X                      SQUARE(board,x,y)->move = 0;
X                      SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] = 0; 
X                      for (k=0; k<directions; k++)
X                        SQUARE(board,x,y)->dir[k] = 0;
X                      SQUARE(board,x,y)->lowbound = 0;
X                  }
X
X                  outdatehorizon (board, x, y, SQUARE(board,x,y)->color);
X                  outdated[x][y] = ALL;
X                }
X              }
X              break;
X  
X            case 'b':
X            case 'B':
X              if (!enable_build[colorarray[player]])
X                break;
X              if (SQUARE(board,x,y)->color == colorarray[player])
X              {
X                if (SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] > (MAXVAL-2) &&
X                      SQUARE(board,x,y)->angle < 23040)
X                {
X                  if (SQUARE(board,x,y)->oldgrowth < 55)
X                    SQUARE(board,x,y)->oldgrowth = 100;
X                  SQUARE(board,x,y)->angle += buildrate[colorarray[player]];
X                  if (SQUARE(board,x,y)->angle >= 23000)
X                  {
X                    SQUARE(board,x,y)->angle = 23040; 
X                    SQUARE(board,x,y)->growth = SQUARE(board,x,y)->oldgrowth;
X                  }
X  
X                  SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] = 0; 
X                  SQUARE(board,x,y)->lowbound = 0;
X                  outdatehorizon (board, x, y, SQUARE(board,x,y)->color);
X                  outdated[x][y] = ALL;
X                }
X              }
X              break;
X
X            case '0':
X            case '1':
X            case '2':
X            case '3':
X            case '4':
X            case '5':
X            case '6':
X            case '7':
X            case '8':
X            case '9':
X              if (!enable_reserve[colorarray[player]])
X                break;
X              if (SQUARE(board,x,y)->color == colorarray[player])
X              {
X                val = (double)(text[0] - '0')*MAXVAL/10.0;
X                SQUARE(board,x,y)->lowbound = (int)(val);
X
X                status = xwindow[player]->drawletter[player];
X                strcpy (line, xwindow[player]->letter[player]);
X
X                xwindow[player]->drawletter[player] = TRUE;
X
X                text[1] = '\0';
X                strcpy (xwindow[player]->letter[player], text);
X
X                drawsquare(xwindow[player],SQUARE(board,x,y),colorarray[player],
X                                                       squaresize[colorarray[player]]);
X
X                strcpy (xwindow[player]->letter[player], line);
X                xwindow[player]->drawletter[player] = status;
X              }
X              break;
X  
X            default:
X              break;
X          }
X        }
X        else
X          print_message(text,textcount,colorarray[player],player,board);
X      }
X      break;
X  }
X}
X
X
X/*************************************************************************/
X/**	dumpsquare							**/
X/** oft used routine for drawing updated square to all screens		**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
X
Xdumpsquare (board, square)
X  square_type *board,
X              *square;
X{
X  int i;
X
X  for (i=0; i<nplayers; i++)
X  {
X    if (!winopen[i])
X      continue;
X    /**** draw if visible to player i ****/
X    if (visible(board,colorarray[i],square->x,square->y))
X    {
X      if (enable_hidden[colorarray[i]])
X      {
X        if (square->color == colorarray[i])
X          drawsquare(xwindow[i],square,colorarray[i],squaresize[colorarray[i]]);
X      }
X      else
X        drawsquare(xwindow[i],square,colorarray[i],squaresize[colorarray[i]]);
X    }
X  }
X  /**** store if necessary ****/
X  if (enable_storage)
X    storedrawsquare(square,squaresize[0]);
X}
X
X
X/*************************************************************************/
X/**	getsquare							**/
X/** gets the board square corresponding to the window position		**/
X/** and the direction from center within that square.  CSIZE is the 	**/
X/** minimum distance from the center of the square for the move to be	**/
X/** encoded.								**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/*************************************************************************/
Xgetsquare(winx,winy,boardx,boardy,dir,squaresize, board, shift)
X  int winx,winy,
X      *boardx,*boardy,
X      dir[DIRS],
X      squaresize,
X      shift;
X  square_type *board;
X{
X  int i, j,
X      done,
X      dx, dy,
X      row_even, col_even,
X      modx, mody,
X      xdiff, ydiff,
X      xoff, yoff,
X      xpos, ypos,
X      col1, col2, row1, row2,
X      min, minpos_i, minpos_j;
X
X  double temp;
X
X  if (enable_hex)
X  {
X    modx = (winx + hex_halfside)/(hex_side + hex_halfside);
X    mody = (winy)/(hex_vert);
X
X    if (mody%2 == 0)
X      row_even = TRUE;
X    else
X      row_even = FALSE;
X
X    if (modx%2 == 0)
X      col_even = TRUE;
X    else
X      col_even = FALSE;
X
X    col1 = modx - 1;
X    col2 = modx;
X
X    if (!row_even)
X    {
X      row1 = mody/2;
X      row2 = row1;
X    }
X    else
X    {
X      if (col_even)
X      {
X        row1 = mody/2 - 1;
X        row2 = mody/2;
X      }
X      else
X      {
X        row1 = mody/2;
X        row2 = mody/2 - 1;
X      }
X    }
X
X    xpos = modx*(hex_side + hex_halfside) + hex_quarterside;
X    ypos = mody*hex_vert + hex_halfvert;
X
X    xoff = winx - xpos;
X    yoff = ypos - winy;
X
X    temp = xoff * hex_slope;  
X
X    if ((!col_even && !row_even) || (col_even && row_even))
X    {
X      if (yoff > temp)
X      {
X        *boardx = col1;
X        *boardy = row1;
X      }
X      else
X      {
X        *boardx = col2;
X        *boardy = row2;
X      }
X    }
X    else
X    {
X      temp = -temp;
X
X      if (yoff > temp)
X      {
X        *boardx = col2;
X        *boardy = row2;
X      }
X      else
X      {
X        *boardx = col1;
X        *boardy = row1;
X      }
X    }
X
X    for (i=0; i<directions; i++)
X      dir[i] = 0;
X
X    done = FALSE;
X    if (*boardx < 0)
X    {
X      *boardx = 0;
X      done = TRUE;
X    }
X    else if (*boardx > boardsizex-1)
X    {
X      *boardx = boardsizex-1;
X      done = TRUE;
X    }
X
X    if (*boardy < 0)
X    {
X      *boardy = 0;
X      done = TRUE;
X    }
X    else if (*boardy > boardsizey-1)
X    {
X      *boardy = boardsizey-1;
X      done = TRUE;
X    }
X  
X    if (done)
X      return;
X
X    xoff = winx - SQUARE(board, *boardx, *boardy)->xpos + hex_side;
X    yoff = SQUARE(board, *boardx, *boardy)->ypos - winy + hex_vert;
X
X    if (hex_chart[xoff][yoff][0] >= 0)
X    {
X      dir[hex_chart[xoff][yoff][0]] = 1;
X      if (shift && hex_chart[xoff][yoff][1] >= 0)
X        dir[hex_chart[xoff][yoff][1]] = 1;
X    }
X  }
X  else
X  {
X    /**** compute board position & relative position ****/
X    *boardx = winx/squaresize;
X    *boardy = (winy)/squaresize;
X    dx = winx%squaresize - (squaresize/2);
X    dy = (winy)%squaresize - (squaresize/2);
X  
X    /**** encode relative position as dir ****/
X    if (dy<(-CSIZE)) dir[UP   ] = 1; else dir[UP   ] = 0;
X    if (dy > CSIZE)  dir[DOWN ] = 1; else dir[DOWN ] = 0;
X    if (dx > CSIZE)  dir[RIGHT] = 1; else dir[RIGHT] = 0;
X    if (dx<(-CSIZE)) dir[LEFT ] = 1; else dir[LEFT ] = 0;
X
X    if (abs(dx) < CSIZE && abs(dy) < CSIZE)
X      for (i=0; i<directions; i++)
X        dir[i] = 0;
X  }
X}
X
X
X/*************************************************************************/
X/**	removeplayer (player)						**/
X/**  Remove player from the game.  If all players have been removed     **/
X/**  then quit the game.						**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xremoveplayer (player, board)
X  int player;
X  square_type *board;
X{
X  int i, j,
X      done,
X      limit;
X
X  char line[512];
X
X  winopen[player] = FALSE;
X  done = TRUE;
X  for (i=0; i<nplayers; i++)
X    if (winopen[i] && !winwatch[i])
X      done = FALSE;
X  
X  /**** free up all constructs ****/
X  for (j=0; j<nsides; j++)
X    XFreeGC(xwindow[player]->display, xwindow[player]->hue[j]);
X  XFreeGC(xwindow[player]->display, xwindow[player]->hue[none]);
X  XFreeGC(xwindow[player]->display, xwindow[player]->hue[dark]);
X  XFreeGC(xwindow[player]->display, xwindow[player]->hue[light]);
X
X  if (enable_terrain)
X  {
X    if (enable_hills)
X      limit = NHILLTONES;
X    else if (enable_forest)
X     limit = NFORESTTONES;
X    else if (enable_sea)
X      limit = NSEATONES;
X
X    for (j=0; j<limit; j++)
X      XFreePixmap(xwindow[player]->display, xwindow[player]->terrain[j]);
X  }
X
X  /**** remove player from game ****/
X  close_xwindow(xwindow[player]);
X
X  if (done)
X  {
X    for (i=0; i<nplayers; i++)
X    {
X      if (winopen[i])
X      {
X        removeplayer (i, board);
X      }
X    }
X
X    if (enable_storage || enable_replay)
X    {
X      if (enable_storage)
X        fprintf (fpout, "Q00");
X      fclose (fpout);
X    }
X    exit (0);
X  }
X  else
X  {
X    sprintf (line, "%s has quit the game", huename[sidemap[colorarray[player]]]);
X/**
X    sprintf (line, "%s (%s) has quit the game", huename[sidemap[colorarray[player]]],
X   			grayname[color2bw[sidemap[colorarray[player]]]]); 
X**/
X
X    print_message(line,strlen(line),colorarray[player],player,board);
X
X    for (i=0; i<nplayers; i++)
X      if (winopen[i])
X        XBell(xwindow[i]->display,100);
X  }
X}
X
X
Xgamestats (board)
X  square_type *board;
X{
X  int i, j,
X      color,
X      force[MAXSIDES],
X      area[MAXSIDES];
X
X  for (i=0; i<nsides; i++)
X  {
X    force[i] = 0;
X    area[i] = 0;
X  }
X
X  for (i=0; i<boardsizex; i++)
X    for (j=0; j<boardsizey; j++)
X    {
X      color = SQUARE(board,i,j)->color;
X      if (color != FIGHT && color != none)
X      {
X        force[color] += SQUARE(board,i,j)->value[color];
X        area[color]++;
X      }
X    }
X
X  for (i=0; i<nsides; i++)
X    printf ("%s:  %3d squares   %5d force\n", huename[sidemap[i]], area[i], force[i]);
X  printf ("\n");
X}
X
X
X/*************************************************************************/
X/**	replaygame							**/
X/** 	replay game from file (non-functionally)			**/	
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xreplaygame(squaresize,board)
X  int squaresize;
X  square_type *board;
X{
X  int i, j, k, l,
X      ipos, jpos,
X      count, done,
X      arg1, arg2, arg3, arg4,
X      hafpsize, hafc,
X      hafsquare,
X      offset, terrain_type;
X
X  static int xrand, yrand;
X
X  char type;
X
X  square_type *square;
X
X  hafsquare = squaresize/2;
X  done = FALSE;
X
X  for (count=0; !done; count++)
X  {
X    /**** This is the hack to get REPLAY message to work.  Note that the ****/
X    /**** number of loops to drawtime (500 below) appears to have an     ****/
X    /**** allowable minimum of 2 or 3 hundred.  We're confounded.        ****/
X
X    if (count == 500)
X    {
X      for (k=0; k<nplayers; k++)
X      {
X#if MULTITEXT
X        for (l=0; l<nsides; l++)
X          XDrawImageString(xwindow[k]->display,xwindow[k]->window,
X       	               xwindow[k]->hue[light],
X		       TEXTX,textyh[l],
X		       messagestr,strlen(messagestr));
X#else
X        XDrawImageString(xwindow[k]->display,xwindow[k]->window,
X       	               xwindow[k]->hue[light],
X		       TEXTX,textyh[0],
X		       messagestr,strlen(messagestr));
X        XDrawImageString(xwindow[k]->display,xwindow[k]->window,
X		       xwindow[k]->hue[light],
X		       TEXTX,textyl[0],
X		       messagestr,strlen(messagestr));
X#endif
X        XSync (xwindow[k]->display, 0);
X        XFlush(xwindow[k]->display);
X      }
X    }
X
X    /**** load command and arguments ****/
X    type = fgetc (fpout); 
X    i = fgetc (fpout);
X    j = fgetc (fpout);
X    square = SQUARE(board,i,j);
X    if (enable_hex)
X    {
X      ipos = square->xpos;
X      jpos = square->ypos;
X    }
X    else
X    {
X      ipos = i*squaresize;
X      jpos = j*squaresize;
X    }
X
X    if (type == 'A' || type == 'a' || type == 'D' || type == 'E' || type == 'F' || type == 'G' ||
X        type == 'H' || type == 'I')
X    {
X      arg1 = fgetc (fpout);
X
X      if (type == 'D' || type == 'E' || type == 'G' || type == 'H' || type == 'I' || type == 'F')
X        arg2 = fgetc (fpout);
X
X      if (type == 'E')
X      {
X        arg3 = fgetc (fpout);
X        arg4 = fgetc (fpout);
X      }
X    }
X
X    /**** for each window ****/
X    for (k=0; k<nplayers; k++)
X    {
X      switch (type)
X      {
X        case 'A':
X          terrain_type = arg1; 
X          if (terrain_type > 128)
X            terrain_type = terrain_type - 256;
X
X          if (enable_hex)
X          {
X            offset = -2 * terrain_type;
X
X            if (terrain_type < 0)
X            {
X              double_copy (xwindow[k], square, colorarray[k], squaresize, terrain_type, 0);
X              terrain_type = 0;
X            }
X            else
X              offset = 0;
X
X            if (terrain_type == 1 && !enable_hills && !enable_forest)
X              XFillArc (xwindow[k]->display,xwindow[k]->window, xwindow[k]->hue[none],
X                     ipos-(hex_vert-1), jpos-(hex_vert-1), 2*(hex_vert-1), 2*(hex_vert-1), 0, 23040);
X            else
X              double_copy (xwindow[k], square, colorarray[k], squaresize, terrain_type, offset);
X          }
X          else
X          {
X            offset = ((double)(-terrain_type) * squaresize)/(2*fillnumber);
X
X            if (terrain_type < 0)
X              terrain_type = 0;
X            else
X              offset = 0;
X
X            if (offset != 0)
X              XCopyArea (xwindow[k]->display, xwindow[k]->terrain[1], xwindow[k]->window,
X                  xwindow[k]->hue[dark], 0, 0, squaresize, squaresize, ipos, jpos);
X
X            XCopyArea (xwindow[k]->display, xwindow[k]->terrain[terrain_type], xwindow[k]->window,
X                          xwindow[k]->hue[dark], 0, 0, squaresize-2*offset, squaresize-2*offset,
X                          ipos+offset, jpos+offset);
X          }
X          break;
X
X        case 'B':
X          if (enable_hex)
X          {
X            XFillArc (xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[none],
X                 ipos-(hex_vert-1), jpos-(hex_vert-1), 2*(hex_vert-1), 2*(hex_vert-1), 0, 23040);
X          }
X          else
X            XFillRectangle(xwindow[k]->display,xwindow[k]->window, xwindow[k]->hue[none],
X                     ipos, jpos, squaresize, squaresize);
X          break;
X
X        case 'b':
X          if (enable_hex)
X            blanksquare(xwindow[k], square, colorarray[k], squaresize, TRUE);
X          XSync (xwindow[k]->display, 0);
X          break;
X  
X        case 'C':
X          XDrawRectangle(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[dark],
X                     ipos+hafsquare-CSIZE, jpos+hafsquare-CSIZE, 2*CSIZE, 2*CSIZE);
X          break;
X  
X        case 'D':
X          hafpsize = arg1/2;
X          if (enable_hex)
X          {
X            XFillArc (xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg2],
X                            ipos-hafpsize, jpos-hafpsize, arg1, arg1, 0, 23040);
X
X          }
X          else
X          {
X            XDrawRectangle(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[dark],
X                       ipos+hafsquare-CSIZE, jpos+hafsquare-CSIZE, 2*CSIZE, 2*CSIZE);
X
X            XFillRectangle(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg2],
X                       ipos+hafsquare-hafpsize, jpos+hafsquare-hafpsize, arg1, arg1);
X          }
X          break;
X  
X        case 'E':
X
X          if (enable_hex)
X          {
X            hafpsize = arg1/2;
X            XFillArc (xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg2],
X                      ipos-hafpsize, jpos-hafpsize, arg1, arg1, 0, 23040);
X            hafpsize = arg3/2;
X            XFillArc (xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg4],
X                      ipos-hafpsize, jpos-hafpsize, arg3, arg3, 0, 23040);
X          }
X          else
X          {
X            hafpsize = arg1/2;
X            XFillRectangle(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg2],
X                       ipos+hafsquare-hafpsize,
X                       jpos+hafsquare-hafpsize, arg1, arg1);
X            hafpsize = arg3/2;
X            XFillRectangle(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg4],
X                       ipos+hafsquare-hafpsize,
X                       jpos+hafsquare-hafpsize, arg3, arg3);
X          }
X          break;
X  
X        case 'F':
X  
X          if (enable_hex)
X          {
X            hafc = arg1/2;
X
X            XDrawArc(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[dark],
X                     ipos-hafc, jpos-hafc, arg1, arg1, 0, (arg2*23040)/255);
X
X            XDrawArc(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[dark],
X                     ipos-hafc + 1, jpos-hafc + 1, arg1 - 2, arg1 - 2, 0, (arg2*23040)/255);
X          }
X          else
X          {
X            hafc = (squaresize-arg1)/2;
X            XDrawArc(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[dark],
X                       ipos+hafc, jpos+hafc,
X                       arg1, arg1, 0, (arg2*23040)/255);
X  
X            XDrawArc(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[dark],
X                       ipos+hafc + 1, jpos+hafc + 1,
X                       arg1 - 2, arg1 - 2, 0, (arg2*23040)/255);
X          }
X  
X          break;
X  
X        case 'G':
X          if (enable_hex)
X          {
X            if (arg2 == 'u')
X            {
X              XDrawLine(xwindow[k]->display,xwindow[k]->window, xwindow[k]->hue[arg1],
X                                     ipos, jpos, ipos, jpos - hex_vert + 2);
X              XDrawLine(xwindow[k]->display,xwindow[k]->window, xwindow[k]->hue[arg1],
X                                     ipos+1, jpos, ipos+1, jpos - hex_vert + 2);
X              XDrawLine(xwindow[k]->display,xwindow[k]->window, xwindow[k]->hue[arg1],
X                                     ipos-1, jpos, ipos-1, jpos - hex_vert + 2);
X            }
X            if (arg2 == 'd')
X            {
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                                     ipos, jpos, ipos, jpos + hex_vert - 2);
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                                     ipos+1, jpos, ipos+1, jpos + hex_vert - 2);
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                                     ipos-1, jpos, ipos-1, jpos + hex_vert - 2);
X
X            }
X            if (arg2 == 'R')
X            {
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                           ipos, jpos, ipos + hex_3quarterside - 1, jpos - hex_halfvert + 1);
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                           ipos+1, jpos, ipos+1 + hex_3quarterside - 1, jpos - hex_halfvert + 1);
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                           ipos, jpos-1, ipos+1 + hex_3quarterside - 1, jpos-1 - hex_halfvert + 1);
X            }
X            if (arg2 == 'r')
X            {
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                           ipos, jpos, ipos + hex_3quarterside - 1, jpos + hex_halfvert - 1);
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                           ipos+1, jpos, ipos+1 + hex_3quarterside - 1, jpos + hex_halfvert - 1);
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                           ipos, jpos+1, ipos + hex_3quarterside - 1, jpos+1 + hex_halfvert - 1);
X            }
X            if (arg2 == 'L')
X            {
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                           ipos, jpos, ipos - hex_3quarterside + 1, jpos - hex_halfvert + 1);
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                           ipos-1, jpos, ipos-1 - hex_3quarterside + 1, jpos - hex_halfvert + 1);
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                           ipos, jpos-1, ipos - hex_3quarterside + 1, jpos-1 - hex_halfvert + 1);
X            }
X            if (arg2 == 'l')
X            {
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                           ipos, jpos, ipos - hex_3quarterside + 1, jpos + hex_halfvert - 1);
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                           ipos-1, jpos, ipos-1 - hex_3quarterside + 1, jpos + hex_halfvert - 1);
X              XDrawLine(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg1],
X                           ipos, jpos+1, ipos - hex_3quarterside + 1, jpos+1 + hex_halfvert - 1);
X
X            }
X          }
X          else
X          {
X            ipos = ipos+hafsquare;
X            jpos = jpos+hafsquare;
X            if (arg2 == 'u')
X            {
X              XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg1],
X                       ipos-1, jpos, ipos-1, jpos-hafsquare);
X              XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg1],
X                       ipos, jpos, ipos, jpos-hafsquare);
X              XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg1],
X                       ipos+1, jpos, ipos+1, jpos-hafsquare);
X            }
X            else if (arg2 == 'd')
X            {
X              XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg1],
X                       ipos-1, jpos, ipos-1, jpos+hafsquare-1);
X              XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg1],
X                       ipos, jpos, ipos, jpos+hafsquare-1);
X              XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg1],
X                       ipos+1, jpos, ipos+1, jpos+hafsquare-1);
X  
X            }
X            else if (arg2 == 'r')
X            {
X              XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg1],
X                       ipos, jpos-1, ipos+hafsquare-1, jpos-1);
X              XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg1],
X                       ipos, jpos, ipos+hafsquare-1, jpos);
X              XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg1],
X                       ipos, jpos+1, ipos+hafsquare-1, jpos+1);
X            }
X            else if (arg2 == 'l')
X            {
X              XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg1],
X                       ipos, jpos-1, ipos-hafsquare, jpos-1);
X              XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg1],
X                       ipos, jpos, ipos-hafsquare, jpos);
X              XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg1],
X                       ipos, jpos+1, ipos-hafsquare, jpos+1);
X            }
X          }
X          break;
X  
X        case 'H':
X          if (enable_hex)
X          {
X            xrand = (xrand+2938345)%hex_side;
X            yrand = (yrand+2398321)%hex_side;
X
X            hafc = arg1/2;
X
X            XFillArc(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg2],
X                     ipos - hafc + xrand - hex_halfside,
X                     jpos - hafc + yrand - hex_halfside,
X                     arg1, arg1, 0, 23040);
X          }
X          else
X          {
X            xrand = (xrand+2938345)%(squaresize/2);
X            yrand = (yrand+2398321)%(squaresize/2);
X  
X            hafc = (squaresize-arg1)/2; 
X  
X            XFillArc(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg2],
X                     ipos+hafc+xrand-squaresize/4, jpos+hafc+yrand-squaresize/4,
X                     arg1, arg1, 0, 23040);
X          }
X          break;
X  
X        case 'I':
X          if (enable_hex)
X          {
X            xrand = (xrand+2938345)%hex_side;
X            yrand = (yrand+2398321)%hex_side;
X
X            hafc = arg1/2;
X
X            XFillArc(xwindow[k]->display, xwindow[k]->window, xwindow[k]->hue[arg2],
X                     ipos - hafc + xrand - hex_halfside, jpos - hafc + yrand - hex_halfside,
X                     arg1, arg1, 0, 11520);
X          }
X          else
X          {
X            xrand = (xrand+2938345)%(squaresize/2);
X            yrand = (yrand+2398321)%(squaresize/2);
X  
X            hafc = (squaresize-arg1)/2; 
X  
X            XFillArc(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[arg2],
X                     ipos+hafc+xrand-squaresize/4,
X                     jpos+hafc+yrand-squaresize/4,
X                     arg1, arg1, 0, 11520);
X          }
X          break;
X
X        case 'J':
X          XSync (xwindow[k]->display, 0);
X          break;
X  
X        case 'Q':
X          XSync (xwindow[k]->display, 0);
X          done = TRUE;
X          break;
X  
X        default:
X          /**** try to recover from bad input ****/
X          printf ("%c %d %d %d %d\n", type, i, j, arg1, arg2);
X          while (type < 'A' || type > 'J' && type != 'Q')
X            type = fgetc(fpout);
X          ungetc (type, fpout);
X          printf ("TROUBLE\n");
X          exit (0);
X          break;
X      }
X      /**** make sure window is flushed regularly ****/
X      if ((count % 15) == 0)
X        XSync (xwindow[k]->display, 0);
X    }
X  }
X
X  while (TRUE);
X}
X
END_OF_FILE
if test 48734 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(4 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X4.0
END_OF_FILE
if test 4 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
if test -f 'tribal.xbo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tribal.xbo'\"
else
echo shar: Extracting \"'tribal.xbo'\" \(95 characters\)
sed "s/^X//" >'tribal.xbo' <<'END_OF_FILE'
X-decay 2
X-sea 8
X-square 32
X-board 24
X-farms 7
X-militia 10
X-repeat
X-fill 4
X-dig 4
X-area
X-attack
END_OF_FILE
if test 95 -ne `wc -c <'tribal.xbo'`; then
    echo shar: \"'tribal.xbo'\" unpacked with wrong size!
fi
# end of 'tribal.xbo'
fi
echo shar: End of archive 2 \(of 7\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
