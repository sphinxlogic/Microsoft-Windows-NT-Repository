Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i076:  xbattle - multi-player battle strategy game for X-Windows, Part05/07
Message-ID: <3515@master.CNA.TEK.COM>
Date: 7 Sep 92 21:23:18 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1742
Approved: billr@saab.CNA.TEK.COM

Submitted-by: slehar@cns.bu.edu
Posting-number: Volume 14, Issue 76
Archive-name: xbattle/Part05
Environment: Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 7)."
# Contents:  global.h init.c
# Wrapped by billr@saab on Mon Sep  7 14:18:50 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'global.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'global.h'\"
else
echo shar: Extracting \"'global.h'\" \(11098 characters\)
sed "s/^X//" >'global.h' <<'END_OF_FILE'
X#include <stdio.h>
X  
X/**** x include files ****/
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xatom.h>
X#include <X11/keysym.h>
X#include <X11/keysymdef.h>
X
X#include "extern.h"
X
X/**** global variables ****/
Xxwindow_type *xwindow[MAXPLAYERS];
X
Xint colorarray[MAXPLAYERS],
X    rcolorarray[MAXHUES],
X    sidemap[MAXPLAYERS];
X
Xchar lettermap[MAXSIDES][2];
X
Xint winopen[MAXPLAYERS],
X    winwatch[MAXPLAYERS];
X
XFILE *fpout, *fopen();
Xchar filename[50];
X
X/**** default mappings from color to b/w ****/
Xint color2bw[MAXHUES+1] = {NONE,
X                           BLACK,
X                           GRAY3,
X                           GRAY2,
X                           GRAY1,
X                           WHITE,
X                           BLACK,
X                           WHITE,
X                           BLACK,
X                           WHITE,
X                           BLACK,
X                           WHITE};
X
Xdouble 	sea,	
X 	farms,			
X	gamespeed=5.0,
X	towns;
X
Xdouble	slowfactor[MAXSIDES],
X        artillery[MAXSIDES],
X        paratroops[MAXSIDES],
X        firepower[MAXSIDES],
X        militia[MAXSIDES],
X        hillfactor[MAXSIDES],	
X	forest[MAXSIDES],	
X        areavalue[MAXVAL+5],
X	decayrate[MAXSIDES],
X	eroderate[MAXSIDES],
X        shuntval[MAXSIDES];
X
Xint     delay=10000,
X	boardsizex=BOARDSIZE,
X	boardsizey=BOARDSIZE;
X
Xint 	nplayers,
X	nsides,	
X	none,	
X	dark,
X 	light,
X        maxviewrange,
X	fillcost=MAXVAL-2,	
X	digcost=MAXVAL-2,
X        fillnumber,
X        directions,
X        paused=FALSE,
X        dir[MAXPLAYERS][DIRS],
X        dirtype[MAXPLAYERS],
X        oldx[MAXPLAYERS],
X        oldy[MAXPLAYERS],
X	seed;
X
Xint	armies[MAXSIDES],
X        bases[MAXSIDES],
X        rbases[MAXSIDES],
X        buildrate[MAXSIDES],
X        scuttlerate[MAXSIDES],
X        marchrate[MAXSIDES],
X	viewrange[MAXSIDES],
X	squaresize[MAXSIDES],
X        textyh[MAXSIDES][MAXSIDES],
X        textyl[MAXSIDES][MAXSIDES];
X
Xint 	enable_anywrap    = FALSE,
X        enable_horizon    = FALSE,
X        enable_march      = FALSE,
X        enable_bound      = FALSE,
X	enable_hills      = FALSE,
X	enable_forest     = FALSE,
X	enable_sea        = FALSE,
X	enable_border     = FALSE,
X	enable_terrain    = FALSE,
X        enable_decay	  = FALSE,
X        enable_area	  = FALSE,
X        enable_anylocalmap = FALSE,
X        enable_storage	  = FALSE,
X        enable_replay     = FALSE,
X        enable_hex        = FALSE,
X        enable_edit       = FALSE,
X        enable_load       = FALSE,
X        enable_farms      = FALSE,
X        enable_armies     = FALSE,
X        enable_militia    = FALSE,
X        enable_bases      = FALSE,
X        enable_rbases     = FALSE,
X        enable_towns      = FALSE;
X
Xint	enable_dig[MAXSIDES],
X   	enable_fill[MAXSIDES],
X   	enable_scuttle[MAXSIDES],
X   	enable_build[MAXSIDES],
X	enable_artillery[MAXSIDES],
X	enable_paratroops[MAXSIDES],
X        enable_personalmarch[MAXSIDES],
X        enable_grid[MAXSIDES],
X        enable_manpos[MAXSIDES],
X        enable_wrap[MAXSIDES],
X	enable_hidden[MAXSIDES],
X	enable_attack[MAXSIDES],
X	enable_nospigot[MAXSIDES],
X        enable_disrupt[MAXSIDES],
X        enable_personalhorizon[MAXSIDES],
X        enable_personalbound[MAXSIDES],
X        enable_erode[MAXSIDES],
X        enable_repeat[MAXSIDES],
X        enable_map[MAXSIDES],
X        enable_basemap[MAXSIDES],
X        enable_localmap[MAXSIDES],
X        enable_reserve[MAXSIDES],
X        enable_digin[MAXSIDES];
X
Xchar outdated[MAXBOARDSIZE][MAXBOARDSIZE],
X     oldvalue[MAXBOARDSIZE][MAXBOARDSIZE];
X
Xint hex_side,
X    hex_halfside,
X    hex_quarterside,
X    hex_3quarterside,
X    hex_vert,
X    hex_halfvert,
X    hex_chart[2*MAXSQUARESIZE][2*MAXSQUARESIZE][2],
X    hex_horizon_even[200][2], hex_horizon_odd[200][2],
X    hex_horizon_number;
Xdouble hex_slope;
XXPoint hex_points[7];
X
Xdouble drand48();
Xvoid srand48();
X
Xchar graytitle[MAXSIDES+1][40] = {"blank",
X                                  "xbattle BLACK SIDE",
X                                  "xbattle DARK SIDE",
X                                  "xbattle GRAY2 SIDE",
X                                  "xbattle LIGHT SIDE",
X                                  "xbattle WHITE SIDE"};
Xchar huetitle[MAXSIDES+1][40] = {"blank",
X                                 "xbattle BLACK SIDE",
X                                 "xbattle DARK SIDE",
X                                 "xbattle GRAY2 SIDE",
X                                 "xbattle LIGHT SIDE",
X                                 "xbattle WHITE SIDE",
X                                 "xbattle RED SIDE",
X                                 "xbattle CYAN SIDE",
X                                 "xbattle MAGENTA SIDE",
X                                 "xbattle GREEN SIDE",
X                                 "xbattle BLUE SIDE",
X                                 "xbattle YELLOW SIDE"};
X
Xchar grayname[MAXHUES+1][10] = {"blank",
X                                "black",
X                                "dark",
X                                "gray2",
X                                "light",
X                                "white",
X                                "junk",
X                                "junk",
X                                "junk",
X                                "junk",
X                                "junk",
X                                "junk"};
Xchar huename[MAXHUES+1][10] = {"blank",
X			       "black",
X                               "dark",
X                               "gray2",
X                               "light",
X                               "white",
X                               "red",
X                               "cyan",
X                               "magenta",
X                               "green",
X                               "blue",
X                               "yellow"};
X
Xchar messagestr[512],
X     personal_messagestr[MAXSIDES][512],
X     storagename[100],
X     replayname[100],
X     mapname[100],
X     blankline[]   = {"                                                                                          "};
X
Xint palette[MAXSIDES+1][3] = {{210, 220, 150},
X			      {  0,   0,   0},
X			      {140, 140, 140},
X			      {160, 160, 160},
X			      {180, 180, 180},
X			      {255, 255, 255},
X			      {255,   0,   0},
X			      {100, 255, 210},
X			      {255,   0, 255},
X			      {130, 255,   0},
X			      {  0,   0, 175},
X			      {250, 250, 130}};
X
Xdouble hillslope[3] = {5.0, -9.0, 0.0};
Xdouble hillintersect[3] = {175.0, 220.0, 100};
X
Xint hillpalette[3] =   {165, 170,  90},
X    forestpalette[3] = {  0, 130,   0},
X    seapalette[3] =    { 80, 152, 224};
X/**
X    seapalette[3] =    {  0,   0, 150};
X**/
X
Xchar *usage = "\
XUSAGE: xbattle\n\
X                -<c1>      <display>      display name side uses color c1 with\n\
X                                          default color to b/w mapping\n\
X                -<c1><c2>  <display>      display name side uses color c1 with\n\
X                                          b/w terminals using b/w shade c2\n\
X                -hex                      Use hexagonal display \n\
X                -bases     <n>            number of bases per side\n\
X                -rbases    <n>            number of randomly placed bases per side\n\
X                -armies    <n>            initial number of armies per side\n\
X                -militia   <n>            density of random militia\n\
X                -hills     <1-10>         hill steepness\n\
X                -forest    <1-10>         forest thickness\n\
X                -sea       <1-10>         sea density\n\
X                -farms     <1-10>         max farm production rate\n\
X                -decay     <1-10>         troop decay rate\n\
X                -erode     <1-10>         empty square erode rate\n\
X                -towns     <1-10>         density of towns\n\
X                -guns      <1-10>         range of artillery\n\
X                -para      <1-10>         range of paratroopers\n\
X                -fight     <1-10>         fire power\n\
X                -speed     <1-10>         game speed\n\
X                -move      <1-10>         terrain roughness\n\
X                -digin     <1-10>         enable shunting\n\
X                -seed      <n>            random number seed for hills etc\n\
X                -horizon   <n>            limit range of vision to n spaces\n\
X                -map                      no preknown map -  drawn during play \n\
X                -basemap                  remember position of towns/bases/rbases \n\
X                -localmap                 no terrain memory \n\
X                -dig       <n>            allow digging of sea, n full squares \n\
X                -fill      <n>            allow filling of sea, n full squares \n\
X                -scuttle                  allow scuttling of bases \n\
X                -reserve                  allow troop reserves \n\
X                -build     <n>            build base with <n> segments \n\
X                -march     <n>            allow troop march, speed <n> \n\
X                -hidden	                  obscure enemy movement arrows\n\
X                -area	                  use areal display mode for square size\n\
X                -bound	                  allow bounding box\n\
X                -repeat	                  allow repeat of last command via right button\n\
X                -disrupt                  attack disrupts movement\n\
X                -wrap                     wraparound mode\n\
X                -border                   border of sea\n\
X                -nogrid                   do not draw grid\n\
X                -manpos                   do not automatically position screen\n\
X                -square    <n>            size of game square in pixels\n\
X                -board     <n>            number of game squares on a side\n\
X                -boardx    <n>            number of game squares on x side\n\
X                -boardy    <n>            number of game squares on y side\n\
X                -store     <file>         store game in <file> for replay\n\
X                -replay    <file>         replay game in <file>\n\
X                -options   <file>         use options from <file>\n\
X                -load      <file>         use map from <file>\n\
X                -edit      <file>         enter terrain editing mode\n";
X
Xchar options[NOPTS][10] = 	{"-bases",
X				 "-rbases",
X				 "-armies",
X				 "-militia",
X				 "-hills",
X				 "-forest",
X				 "-sea",
X				 "-farms",
X				 "-decay",
X				 "-erode",
X				 "-towns",
X				 "-guns",
X				 "-para",
X				 "-march",
X				 "-fight",
X				 "-speed",
X				 "-move",
X				 "-digin",
X				 "-seed",
X				 "-dig",
X				 "-fill",
X				 "-square",
X				 "-board",
X				 "-boardx",
X				 "-boardy",
X				 "-build",	/** end of non flags **/
X				 "-horizon",
X				 "-options",
X				 "-load",
X				 "-edit",
X				 "-store",
X				 "-replay",     /** end of variable flags **/
X				 "-hex",
X				 "-map",
X				 "-basemap",
X				 "-localmap",
X				 "-scuttle",
X                                 "-reserve",
X				 "-hidden",
X				 "-area",
X				 "-disrupt",
X				 "-bound",
X				 "-repeat",
X				 "-wrap",
X				 "-border",
X				 "-attack",
X				 "-nospigot",
X				 "-nogrid",
X				 "-manpos"};
END_OF_FILE
if test 11098 -ne `wc -c <'global.h'`; then
    echo shar: \"'global.h'\" unpacked with wrong size!
fi
# end of 'global.h'
fi
if test -f 'init.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'init.c'\"
else
echo shar: Extracting \"'init.c'\" \(34283 characters\)
sed "s/^X//" >'init.c' <<'END_OF_FILE'
X#include <stdio.h>
X  
X/**** x include files ****/
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xatom.h>
X#include <X11/keysym.h>
X#include <X11/keysymdef.h>
X
X#include "extern.h"
X
X/*************************************************************************/
X/**	initboard							**/
X/** Initialize the squares of the game board				**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/*************************************************************************/
Xinit_board(board)
X  square_type *board;
X{
X  int i, j, k,
X      even;
X
X  /**** initialize random number generator ****/
X#if NODRAND48
X  srand((long)seed);
X#else
X  srand48((long)seed);
X#endif
X
X  printf ("seed: %d\n", seed);
X
X  /**** initialize the board values ****/
X  for (j=0; j<boardsizey; j++)
X  {
X    even = TRUE;
X
X    for (i=0; i<boardsizex; i++)
X    {
X      SQUARE(board,i,j)->x           = i;
X      SQUARE(board,i,j)->y           = j;
X      SQUARE(board,i,j)->color       = none;
X      SQUARE(board,i,j)->oldcolor    = none;
X      SQUARE(board,i,j)->value[none] = 0;
X      for (k=0; k<(nsides+2); k++)
X        SQUARE(board,i,j)->value[k]  = 0;
X      SQUARE(board,i,j)->lowbound    = 0;
X      SQUARE(board,i,j)->growth      = 0;
X      SQUARE(board,i,j)->oldgrowth   = 0;
X      SQUARE(board,i,j)->angle       = 0;
X      SQUARE(board,i,j)->age         = 0;
X      SQUARE(board,i,j)->anymarch    = FALSE;
X      for (k=0; k<nsides; k++)
X        SQUARE(board,i,j)->march[k]  = FALSE;
X      SQUARE(board,i,j)->move        = 0;
X      for (k=0; k<directions; k++)
X        SQUARE(board,i,j)->dir[k]    = 0;
X
X      for (k=0; k<nsides; k++)
X        SQUARE(board,i,j)->seen[k]   = TRUE;
X
X      /** define centers **/
X
X      if (enable_hex)
X      {
X        if (even)
X          SQUARE(board,i,j)->ypos = j*2*hex_vert + hex_vert;
X        else
X          SQUARE(board,i,j)->ypos = j*2*hex_vert + 2*hex_vert;
X
X        SQUARE(board,i,j)->xpos = hex_side + i*(3*hex_side/2);
X
X        even = !even;
X      }
X      else
X      {
X        SQUARE(board,i,j)->xpos = i * squaresize[0] + squaresize[0]/2;
X        SQUARE(board,i,j)->ypos = j * squaresize[0] + squaresize[0]/2;
X      }
X    }
X  }
X
X  if (enable_hex)
X    set_hex_connections (board);
X  else
X    set_square_connections (board);
X
X  if (enable_edit)
X  {
X    for (i=0; i<boardsizex; i++)
X      for (j=0; j<boardsizey; j++)
X      {
X        if (enable_hills)
X          SQUARE(board,i,j)->value[none] = NHILLTONES/2;
X        else if (enable_forest)
X          SQUARE(board,i,j)->value[none] = NFORESTTONES/2;
X        else if (enable_sea)
X          SQUARE(board,i,j)->value[none] = 1;
X      }
X
X    return;
X  }
X
X  if (enable_load)
X  {
X    load_board (board, mapname, FALSE);
X  }
X  else
X  {
X    if (enable_terrain)
X      init_hills(board, seed);
X  }
X
X  if (enable_farms)
X    init_farms(board, farms);
X
X  if (enable_towns)
X    init_towns(board,towns,seed);
X
X  if (enable_bases)
X    init_bases(board,bases);
X
X  if (enable_rbases)
X    init_rbases(board,rbases,seed);
X
X  if (enable_armies)
X    init_armies(board,armies);
X
X  if (enable_militia)
X    init_militia(board,militia,seed);
X
X  init_unseen(board);
X
X  if (enable_horizon && enable_hex)
X    init_horizon (board);
X}
X
X
X/*************************************************************************/
X/**	init_horizon							**/
X/** Initialize horizon for hexagonal board				**/
X/**	Greg Lesher (lesher@cns.bu.edu)					**/
X/*************************************************************************/
Xinit_horizon (board)
X  square_type *board;
X{
X  int i, j, k,
X      ibase, jbase,
X      half,
X      index;
X
X  square_type *square;
X
X  half = boardsizex/2;
X  if (half%2 == 0)
X    square = SQUARE (board, half, boardsizey/2);
X  else
X    square = SQUARE (board, half+1, boardsizey/2);
X
X  ibase = square->x;
X  jbase = square->y;
X
X  index = 0;
X
X  for (i=0; i<viewrange[0]; i++)
X  {
X    square = square->connect[HEX_UP];
X
X    for (j=0; j<6; j++)
X    {
X      for (k=0; k<(i+1); k++)
X      {
X        square = square->connect[(HEX_RIGHT_DOWN+j)%6];
X
X        hex_horizon_even[index][0] = square->x - ibase;
X        hex_horizon_even[index][1] = square->y - jbase;
X        index++;
X      }
X    }
X  }
X
X  if (half%2 == 0)
X    square = SQUARE (board, half+1, boardsizey/2);
X  else
X    square = SQUARE (board, half, boardsizey/2);
X
X  ibase = square->x;
X  jbase = square->y;
X
X  index = 0;
X
X  for (i=0; i<viewrange[0]; i++)
X  {
X    square = square->connect[HEX_UP];
X
X    for (j=0; j<6; j++)
X    {
X      for (k=0; k<(i+1); k++)
X      {
X        square = square->connect[(HEX_RIGHT_DOWN+j)%6];
X
X        hex_horizon_odd[index][0] = square->x - ibase;
X        hex_horizon_odd[index][1] = square->y - jbase;
X        index++;
X      }
X    }
X  }
X
X  hex_horizon_number = index;
X}
X
X
X/*************************************************************************/
X/**	init_hex							**/
X/** Initialize array for use in getsquare with hexagonal board		**/
X/**	Greg Lesher (lesher@cns.bu.edu)					**/
X/*************************************************************************/
Xinit_hex (squaresize)
X  int squaresize;
X{
X  int i, j,
X      int_angle, mod_angle;
X
X  double xpos, ypos,
X         angle,
X         atan2();
X
X  hex_side = squaresize;
X  hex_halfside = hex_side/2;
X  hex_quarterside = hex_side/4;
X  hex_3quarterside = (3*hex_side)/4;
X  hex_vert = (int)(SQ3D2 * hex_side + 0.5);
X  hex_halfvert = hex_vert/2;
X
X  hex_slope = ((double)(hex_vert))/hex_halfside;
X
X  hex_points[0].x = 0;
X  hex_points[0].y = 0;
X
X  hex_points[1].x = hex_side;
X  hex_points[1].y = 0;
X
X  hex_points[2].x = hex_halfside;
X  hex_points[2].y = hex_vert;
X
X  hex_points[3].x = -hex_halfside;
X  hex_points[3].y = hex_vert;
X
X  hex_points[4].x = -hex_side;
X  hex_points[4].y = 0;
X
X  hex_points[5].x = -hex_halfside;
X  hex_points[5].y = -hex_vert;
X
X  hex_points[6].x = hex_halfside;
X  hex_points[6].y = -hex_vert;
X
X  for (i=0; i<2*hex_side; i++)
X  {
X    for (j=0; j<2*hex_side; j++)
X    {
X      xpos = i - hex_side;
X      ypos = j - hex_side;
X
X      if ((i - hex_side) == 0)
X      {
X        if (ypos > 0)
X          angle = 90.0;
X        else
X          angle = 270.0;
X      }
X      else
X      {
X        angle = atan2 (ypos, xpos);
X        angle = angle * 180.0 / 3.1415927;
X      }
X      
X      if (angle < 0)
X        angle = 360.0 + angle;
X
X      int_angle = (int)(angle + 0.5);
X      mod_angle = int_angle/60;
X
X      switch (mod_angle)
X      {
X        case 0:
X          hex_chart[i][j][0] = HEX_RIGHT_UP;
X          break;
X        case 1:
X          hex_chart[i][j][0] = HEX_UP;
X          break;
X        case 2:
X          hex_chart[i][j][0] = HEX_LEFT_UP;
X          break;
X        case 3:
X          hex_chart[i][j][0] = HEX_LEFT_DOWN;
X          break;
X        case 4:
X          hex_chart[i][j][0] = HEX_DOWN;
X          break;
X        case 5:
X          hex_chart[i][j][0] = HEX_RIGHT_DOWN;
X          break;
X      }
X
X      hex_chart[i][j][1] = -1;
X      mod_angle = int_angle/15;
X
X      switch (mod_angle)
X      {
X        case 0:
X          hex_chart[i][j][1] = HEX_RIGHT_DOWN;
X          break;
X        case 3:
X          hex_chart[i][j][1] = HEX_UP;
X          break;
X        case 4:
X          hex_chart[i][j][1] = HEX_RIGHT_UP;
X          break;
X        case 7:
X          hex_chart[i][j][1] = HEX_LEFT_UP;
X          break;
X        case 8:
X          hex_chart[i][j][1] = HEX_UP;
X          break;
X        case 11:
X          hex_chart[i][j][1] = HEX_LEFT_DOWN;
X          break;
X        case 12:
X          hex_chart[i][j][1] = HEX_LEFT_UP;
X          break;
X        case 15:
X          hex_chart[i][j][1] = HEX_DOWN;
X          break;
X        case 16:
X          hex_chart[i][j][1] = HEX_LEFT_DOWN;
X          break;
X        case 19:
X          hex_chart[i][j][1] = HEX_RIGHT_DOWN;
X          break;
X        case 20:
X          hex_chart[i][j][1] = HEX_DOWN;
X          break;
X        case 23:
X          hex_chart[i][j][1] = HEX_RIGHT_UP;
X          break;
X      }
X
X      if (xpos*xpos + ypos*ypos < 2*CSIZE*CSIZE)
X        hex_chart[i][j][0] = -1;
X
X      if (xpos*xpos + ypos*ypos < 2*CSIZE*CSIZE)
X        hex_chart[i][j][1] = -1;
X    }
X  }
X}
X
X
X/*************************************************************************/
X/**	set_square_connections						**/
X/** Initialize connections for square board				**/
X/**	Greg Lesher (lesher@cns.bu.edu)					**/
X/*************************************************************************/
Xset_square_connections (board)
X  square_type *board;
X{
X  int i, j;
X
X  for (j=0; j<boardsizey; j++)
X  {
X    for (i=0; i<boardsizex; i++)
X    {
X
X      if (j != 0)
X        SQUARE(board,i,j)->connect[UP] = SQUARE(board,i,j-1);
X      else
X        SQUARE(board,i,j)->connect[UP] = SQUARE(board,i,j);
X
X      if (j != boardsizey-1)
X        SQUARE(board,i,j)->connect[DOWN] = SQUARE(board,i,j+1);
X      else
X        SQUARE(board,i,j)->connect[DOWN] = SQUARE(board,i,j);
X
X      if (i != 0)
X        SQUARE(board,i,j)->connect[LEFT] = SQUARE(board,i-1,j);
X      else
X        SQUARE(board,i,j)->connect[LEFT] = SQUARE(board,i,j);
X
X      if (i != boardsizex-1)
X        SQUARE(board,i,j)->connect[RIGHT] = SQUARE(board,i+1,j);
X      else
X        SQUARE(board,i,j)->connect[RIGHT] = SQUARE(board,i,j);
X    }
X  }
X
X  if (enable_anywrap)
X  {
X    for (i=0; i<boardsizex; i++)
X    {
X      SQUARE(board,i,0)->connect[UP] = SQUARE(board,i,boardsizey-1);
X      SQUARE(board,i,boardsizey-1)->connect[DOWN] = SQUARE(board,i,0);
X    }
X
X    for (j=0; j<boardsizey; j++)
X    {
X      SQUARE(board,0,j)->connect[LEFT] = SQUARE(board,boardsizex-1,j);
X      SQUARE(board,boardsizex-1,j)->connect[RIGHT] = SQUARE(board,0,j);
X    }
X  }
X}
X
X
X/*************************************************************************/
X/**	set_hex_connections						**/
X/** Initialize connections for hexagonal board				**/
X/**	Greg Lesher (lesher@cns.bu.edu)					**/
X/*************************************************************************/
Xset_hex_connections (board)
X  square_type *board;
X
X{
X  int i, j,
X      even;
X
X  for (j=0; j<boardsizey; j++)
X  {
X    even = TRUE;
X
X    for (i=0; i<boardsizex; i++)
X    {
X      if (j != 0)
X        SQUARE(board,i,j)->connect[HEX_UP] = SQUARE(board,i,j-1);
X      else
X        SQUARE(board,i,j)->connect[HEX_UP] = SQUARE(board,i,j);
X
X      if (j != boardsizey-1)
X        SQUARE(board,i,j)->connect[HEX_DOWN] = SQUARE(board,i,j+1);
X      else
X        SQUARE(board,i,j)->connect[HEX_DOWN] = SQUARE(board,i,j);
X
X      if (i != 0)
X      {
X        if (j != 0)
X        {
X          if (even)
X            SQUARE(board,i,j)->connect[HEX_LEFT_UP] = SQUARE(board,i-1,j-1);
X          else
X            SQUARE(board,i,j)->connect[HEX_LEFT_UP] = SQUARE(board,i-1,j);
X        }
X        else if (!even)
X          SQUARE(board,i,j)->connect[HEX_LEFT_UP] = SQUARE(board,i-1,j);
X        else
X          SQUARE(board,i,j)->connect[HEX_LEFT_UP] = SQUARE(board,i,j);
X
X        if (j != boardsizey-1)
X        {
X          if (even)
X            SQUARE(board,i,j)->connect[HEX_LEFT_DOWN] = SQUARE(board,i-1,j);
X          else
X            SQUARE(board,i,j)->connect[HEX_LEFT_DOWN] = SQUARE(board,i-1,j+1);
X        }
X        else if (even)
X          SQUARE(board,i,j)->connect[HEX_LEFT_DOWN] = SQUARE(board,i-1,j);
X        else
X          SQUARE(board,i,j)->connect[HEX_LEFT_DOWN] = SQUARE(board,i,j);
X      }
X      else
X      {
X        SQUARE(board,i,j)->connect[HEX_LEFT_UP] = SQUARE(board,i,j);
X        SQUARE(board,i,j)->connect[HEX_LEFT_DOWN] = SQUARE(board,i,j);
X      }
X
X      if (i != boardsizex-1)
X      {
X        if (j != 0)
X        {
X          if (even)
X            SQUARE(board,i,j)->connect[HEX_RIGHT_UP] = SQUARE(board,i+1,j-1);
X          else
X            SQUARE(board,i,j)->connect[HEX_RIGHT_UP] = SQUARE(board,i+1,j);
X        }
X        else if (!even)
X          SQUARE(board,i,j)->connect[HEX_RIGHT_UP] = SQUARE(board,i+1,j);
X        else
X          SQUARE(board,i,j)->connect[HEX_RIGHT_UP] = SQUARE(board,i,j);
X
X        if (j != boardsizey-1)
X        {
X          if (even)
X            SQUARE(board,i,j)->connect[HEX_RIGHT_DOWN] = SQUARE(board,i+1,j);
X          else
X            SQUARE(board,i,j)->connect[HEX_RIGHT_DOWN] = SQUARE(board,i+1,j+1);
X        }
X        else if (even)
X          SQUARE(board,i,j)->connect[HEX_RIGHT_DOWN] = SQUARE(board,i+1,j);
X        else
X          SQUARE(board,i,j)->connect[HEX_RIGHT_DOWN] = SQUARE(board,i,j);
X
X      }
X      else
X      {
X        SQUARE(board,i,j)->connect[HEX_RIGHT_UP] = SQUARE(board,i,j);
X        SQUARE(board,i,j)->connect[HEX_RIGHT_DOWN] = SQUARE(board,i,j);
X      }
X
X      even = !even;
X    }
X  }
X
X  if (enable_anywrap)
X  {
X    for (i=0; i<boardsizex; i++)
X    {
X      SQUARE(board,i,0)->connect[HEX_UP] = SQUARE(board,i,boardsizey-1);
X      SQUARE(board,i,boardsizey-1)->connect[HEX_DOWN] = SQUARE(board,i,0);
X
X      if (i%2 == 1)
X      {
X        if (i!=0)
X          SQUARE(board,i,0)->connect[HEX_LEFT_UP] = SQUARE(board,i-1,boardsizey-1);
X
X        if (i!=boardsizex-1)
X          SQUARE(board,i,0)->connect[HEX_RIGHT_UP] = SQUARE(board,i+1,boardsizey-1);
X
X        if (i!=0)
X          SQUARE(board,i,boardsizey-1)->connect[HEX_LEFT_DOWN] = SQUARE(board,i-1,0);
X
X        if (i!=boardsizex-1)
X          SQUARE(board,i,boardsizey-1)->connect[HEX_RIGHT_DOWN] = SQUARE(board,i+1,0);
X      }
X    }
X
X    if (boardsizex%2 == 0)
X    {
X      for (j=0; j<boardsizey; j++)
X      {
X        if (j==0)
X          SQUARE(board,0,j)->connect[HEX_LEFT_UP] = SQUARE(board,boardsizex-1,boardsizey-1);
X        else
X          SQUARE(board,0,j)->connect[HEX_LEFT_UP] = SQUARE(board,boardsizex-1,j-1);
X
X        SQUARE(board,0,j)->connect[HEX_LEFT_DOWN] = SQUARE(board,boardsizex-1,j);
X
X        SQUARE(board,boardsizex-1,j)->connect[HEX_RIGHT_UP] = SQUARE(board,0,j);
X
X        if (j == boardsizey-1)
X          SQUARE(board,boardsizex-1,j)->connect[HEX_RIGHT_DOWN] = SQUARE(board,0,0);
X        else
X          SQUARE(board,boardsizex-1,j)->connect[HEX_RIGHT_DOWN] = SQUARE(board,0,j+1);
X      }
X    }
X  }
X}
X
X
X/*************************************************************************/
X/**	init_unseen							**/
X/** Make all squares unseen						**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xinit_unseen (board)
X  square_type *board;
X{
X  int i, j, k;
X
X  for (i=0; i<boardsizex; i++)
X    for (j=0; j<boardsizey; j++)
X      for (k=0; k<nsides; k++)
X        if (enable_map[k] || enable_localmap[k])
X          SQUARE(board,i,j)->seen[k] = FALSE;
X}
X
X
X/*************************************************************************/
X/**	init_hills							**/
X/** set the hills on the game board.  Hills take energy  to climb, but	**/
X/** return it again on the way down,  so they can  be used to tactical	**/
X/** advantage.								**/
X/**									**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xinit_hills(board,seed)
X  square_type *board;
X  int seed;
X{
X  int i, j,
X      offset;
X  double limit;
X
X  if (enable_hills)
X    limit = (double)(NHILLTONES);
X  if (enable_forest)
X    limit = (double)(NFORESTTONES);
X  else if (enable_sea && !enable_hills && !enable_forest)
X    limit = sea;
X
X  /**** set initial random values ****/
X  for (i=0; i<boardsizex; i++)
X  {
X    for (j=0; j<boardsizey; j++)
X    {
X      SQUARE(board,i,j)->value[none] = (int)(drand48()*limit);
X    }
X  }
X
X  if (enable_border && enable_sea)
X  {
X    for (i=0; i<boardsizex; i++)
X    {
X     SQUARE(board,i,0)->value[none] = 0;
X     SQUARE(board,i,boardsizey-1)->value[none] = 0;
X    }
X    for (j=0; j<boardsizey; j++)
X    {
X     SQUARE(board,0, j)->value[none] = 0;
X     SQUARE(board,boardsizex-1,j)->value[none] = 0;
X    }
X
X    offset = 2;
X  }
X  else
X    offset = 1;
X  
X  
X
X  /**** smooth out the hills ****/
X  for (j=offset; j<boardsizey-offset; j++)
X  {
X    for (i=offset; i<boardsizex-offset; i++)
X    {
X      if (SQUARE(board,i,j+1)->value[none] == SQUARE(board,i,j-1)->value[none])
X	SQUARE(board,i,j)->value[none] = SQUARE(board,i,j-1)->value[none];
X      if (SQUARE(board,i+1,j)->value[none] == SQUARE(board,i-1,j)->value[none])
X	SQUARE(board,i,j)->value[none] = SQUARE(board,i-1,j)->value[none];
X    }
X  }
X
X  /**** if just sea enabled, flatten all hills to 2nd lowest level ****/
X  if (enable_sea && !enable_hills && !enable_forest)
X    for (i=0; i<boardsizex; i++)
X      for (j=0; j<boardsizey; j++)
X        if (SQUARE(board,i,j)->value[none] == 0)
X          SQUARE(board,i,j)->value[none] = 0;
X        else
X          SQUARE(board,i,j)->value[none] = 1;
X}
X
X
X/*************************************************************************/
X/**	init_towns							**/
X/** set the towns on the game board.  Towns are sources of troops, and	**/
X/** appear as circles  whose radius  is  proportional  to the  rate of	**/
X/** troop production.		  					**/
X/**									**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xinit_towns(board,val,seed)
X  square_type *board;
X  double val;
X  int seed;
X{
X  int i, j;
X
X  /**** set the random towns ****/
X  for (i=0; i<boardsizex; i++)
X  {
X    for (j=0; j<boardsizey; j++)
X    {
X      if (drand48() <= val/40.0)
X      {
X         if (!(enable_sea && SQUARE(board,i,j)->value[none] <= 0))
X         {
X	   SQUARE(board,i,j)->growth =  (int)(drand48()*40.0+0.5)+60;
X	   SQUARE(board,i,j)->oldgrowth = SQUARE(board,i,j)->growth;
X	   SQUARE(board,i,j)->angle = 23040; 
X         }
X       }
X    }
X  }
X}
X
X
X/*************************************************************************/
X/**	init_farms							**/
X/** set the  farms on  the   game board.  Farms   produce troops  at a	**/
X/** constant slow rate val, and  must be cultivated  in large areas to	**/
X/** be effective.							**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/*************************************************************************/
Xinit_farms(board,val)
X  square_type *board;
X  double val;
X{
X  int i, j;
X
X  /**** set growth values ****/
X  for (i=0; i<boardsizex; i++)
X  {
X    for (j=0; j<boardsizey; j++)
X    {
X      if (!(enable_sea && SQUARE(board,i,j)->value[none] <= 0))
X      {
X        if (SQUARE(board,i,j)->growth < 50);
X          SQUARE(board,i,j)->growth = (int)val;
X      }
X    }
X  }
X}
X
X
X/*************************************************************************/
X/**	init_bases							**/
X/** set the bases on the game board.  Bases provide a steady supply of	**/
X/** a large  number  of troops, and thus   are   of enormous strategic	**/
X/** advantage.								**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xinit_bases(board,n)
X  square_type *board;
X  int n[];
X{
X  int i, sep[MAXSIDES];
X  
X  /**** separation between bases ****/
X  for (i=0; i<nsides; i++)
X    sep[i] = (boardsizex-n[i])/2;
X
X  /**** initialize the bases ****/
X  if (nsides >= 1)
X  {
X    for (i=sep[0]; i<sep[0]+n[0]; i++)
X    {
X      if (!(enable_sea && SQUARE(board,i,1)->value[none] <= 0))
X      {
X        SQUARE(board,i,1)->color  = 0;
X        SQUARE(board,i,1)->value[0]  = 1;
X        SQUARE(board,i,1)->growth = 100;
X        SQUARE(board,i,1)->oldgrowth = 100;
X        SQUARE(board,i,1)->angle = 23040; 
X      }
X    }
X  }
X
X  if (nsides >= 2)
X  {
X    for (i=sep[1]; i<sep[1]+n[1]; i++)
X    {
X      if (!(enable_sea && SQUARE(board,i,boardsizey-2)->value[none] <= 0))
X      {
X        SQUARE(board,i,boardsizey-2)->color  = 1;
X        SQUARE(board,i,boardsizey-2)->value[1]  = 1;
X        SQUARE(board,i,boardsizey-2)->growth = 100;
X        SQUARE(board,i,boardsizey-2)->oldgrowth = 100;
X        SQUARE(board,i,boardsizey-2)->angle = 23040; 
X      }
X    }
X  }
X
X  if (nsides >= 3)
X  {
X    for (i=sep[2]; i<sep[2]+n[2]; i++)
X    {
X      if (!(enable_sea && SQUARE(board,1,i)->value[none] <= 0))
X      {
X        SQUARE(board,1,i)->color  = 2;
X        SQUARE(board,1,i)->value[2]  = 1;
X        SQUARE(board,1,i)->growth = 100;
X        SQUARE(board,1,i)->oldgrowth = 100;
X        SQUARE(board,1,i)->angle = 23040; 
X      }
X    }
X  }
X
X  if (nsides >= 4)
X  {
X    for (i=sep[3]; i<sep[3]+n[3]; i++)
X    {
X      if (!(enable_sea && SQUARE(board,boardsizex-2,i)->value[none] <= 0))
X      {
X        SQUARE(board,boardsizex-2,i)->color  = 3;
X        SQUARE(board,boardsizex-2,i)->value[3]  = 1;
X        SQUARE(board,boardsizex-2,i)->growth = 100;
X        SQUARE(board,boardsizex-2,i)->oldgrowth = 100;
X        SQUARE(board,boardsizex-2,i)->angle = 23040; 
X      }
X    }
X  }
X}
X
X
X/*************************************************************************/
X/**	init_rbases							**/
X/** set the bases on the game board.  Bases provide a steady supply of	**/
X/** a large  number  of troops, and thus   are   of enormous strategic	**/
X/** advantage.								**/
X/**	Mark Lauer (elric@cs.su.oz.au)					**/
X/** Modified to handle multiple players					**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xinit_rbases(board,n,seed)
X  square_type *board;
X  int n[],
X      seed;
X{
X  int i, j, k, l, x, y,
X      i1, i2, j1, j2,
X      range,
X      maxn,
X      done,
X      count;
X
X  /**** create randomly placed bases for each side ****/
X
X  maxn = 0;
X  for (i=0; i<nsides; i++)
X    if (n[i] > maxn)
X      maxn = n[i];
X
X  if (maxviewrange < BASERANGE)
X    range = BASERANGE;
X  else
X    range = maxviewrange;
X
X  for (k=0; k<maxn; k++)
X  {
X    for (l=0; l<nsides; l++)
X    {
X      if (k >= n[l])
X        continue;
X
X      count = 0;
X      do
X      {
X        done = TRUE;
X        i = (int)(drand48()*boardsizex);
X        j = (int)(drand48()*boardsizey);
X
X        if (SQUARE(board,i,j)->growth > 50 || (enable_sea && SQUARE(board,i,j)->value[none] <= 0))
X          done = FALSE+FALSE;
X
X        i1 = i-range;
X        i2 = i+range;
X        j1 = j-range;
X        j2 = j+range;
X
X        /**** search for nearby squares of color color ****/
X        if (enable_anywrap)
X        {
X          for (x=i1; x<=i2; x++)
X            for (y=j1; y<=j2; y++)
X              if (SQUARE(board,MODX(x),MODY(y))->color != l &&
X                               SQUARE(board,MODX(x),MODY(y))->color != none) 
X                done = FALSE;
X        }
X        else
X        {
X          i1 = (i1<0) ? 0 : i1;
X          i2 = (i2>boardsizex-1) ? boardsizex-1 : i2;
X          j1 = (j1<0) ? 0 : j1;
X          j2 = (j2>boardsizey-1) ? boardsizey-1 : j2;
X
X          for (x=i1; x<=i2; x++)
X            for (y=j1; y<=j2; y++)
X              if (SQUARE(board,x,y)->color != l && SQUARE(board,x,y)->color != none)
X                done = FALSE;
X        }
X        count++;
X
X        if (count > 50 && done!=(FALSE+FALSE))
X          done = TRUE;
X
X      } while (!done);
X
X      SQUARE(board,i,j)->color = l;
X      SQUARE(board,i,j)->value[l] = 1;
X      SQUARE(board,i,j)->growth = 100;
X      SQUARE(board,i,j)->oldgrowth = 100;
X      SQUARE(board,i,j)->angle = 23040; 
X    }
X  }
X}
X
X
X/*************************************************************************/
X/**	init_armies							**/
X/** set the armies on the game board					**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xinit_armies(board,n)
X  square_type *board;
X  int n[];
X{
X  int i, sep[MAXSIDES];
X  
X  for (i=0; i<nsides; i++)
X    sep[i] = (boardsizex-n[i])/2;
X
X  /**** initialize armies for each side ****/
X
X  if (nsides >= 1)
X  {
X    for (i=sep[0]; i<sep[0]+n[0]; i++)
X    {
X      if (!(enable_sea && SQUARE(board,i,2)->value[none] <= 0))
X      {
X        SQUARE(board,i,2)->color  = 0;
X        SQUARE(board,i,2)->value[0]  = MAXVAL;
X      }
X    }
X  }
X
X  if (nsides >= 2)
X  {
X    for (i=sep[1]; i<sep[1]+n[1]; i++)
X    {
X      if (!(enable_sea && SQUARE(board,i,boardsizey-3)->value[none] <= 0))
X      {
X        SQUARE(board,i,boardsizey-3)->color  = 1;
X        SQUARE(board,i,boardsizey-3)->value[1]  = MAXVAL;
X      }
X    }
X  }
X
X  if (nsides >= 3)
X  {
X    for (i=sep[2]; i<sep[2]+n[2]; i++)
X    {
X      if (!(enable_sea && SQUARE(board,2,i)->value[none] <= 0))
X      {
X        SQUARE(board,2,i)->color  = 2;
X        SQUARE(board,2,i)->value[2]  = MAXVAL;
X      }
X    }
X  }
X
X  if (nsides >= 4)
X  {
X    for (i=sep[3]; i<sep[3]+n[3]; i++)
X    {
X      if (!(enable_sea && SQUARE(board,boardsizex-3,i)->value[none] <= 0))
X      {
X        SQUARE(board,boardsizex-3,i)->color  = 3;
X        SQUARE(board,boardsizex-3,i)->value[3]  = MAXVAL;
X      }
X    }
X  }
X}
X
X
X/*************************************************************************/
X/**	init_militia							**/
X/** set random militia on the game board. 				**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xinit_militia(board,val,seed)
X  square_type *board;
X  double val[];
X  int seed;
X{
X  int i, j, k, l,
X      scramble;
X
X  double roll,
X         thresh;
X
X  scramble = 0;
X  thresh = 1.0/((double)(nsides));
X
X  /**** set the random militia ****/
X  for (i=0; i<boardsizex; i++)
X  {
X    for (j=0; j<boardsizey; j++)
X    {
X      scramble += 217;
X
X      for (k=0; k<nsides; k++)
X      {
X        l = (scramble+k)%nsides;
X
X        if (drand48() <= val[l]/40.0)
X        {
X          if (!(enable_sea && SQUARE(board,i,j)->value[none] <= 0))
X          {
X	    SQUARE(board,i,j)->color =  l;
X	    SQUARE(board,i,j)->value[l]  = (int)(drand48()*(double)MAXVAL);
X            k = nsides;
X          }
X        }
X      }
X    }
X  }
X}
X
X
Xedit_board (board)
X  square_type *board;
X{
X  XEvent event;
X
X  int i,
X      player,
X      currentcolor,
X      value,
X      x, y,
X      textcount,
X      tdir[DIRS];
X
X  char text[20];
X
X  KeySym key;
X
X  square_type *square;
X
X  player = 0;
X  currentcolor = colorarray[player];
X
X  drawboard (board, player, TRUE);
X
X  while (TRUE)
X  {
X    XNextEvent(xwindow[player]->display, &event);
X
X    getsquare(event.xbutton.x,event.xbutton.y,&x,&y,tdir,squaresize[colorarray[player]], board, FALSE);
X    square = SQUARE(board,x,y);
X
X    switch (event.type)
X    {
X      case Expose:
X        drawboard (board, player, TRUE);
X        break;
X
X      case ButtonPress:
X        switch (event.xbutton.button)
X        {
X          case Button1:
X          case Button2:
X          case Button3:
X            if (event.xbutton.button == Button1)
X              square->value[none] -= 1;
X            else if (event.xbutton.button == Button2)
X              square->value[none] += 1;
X            else
X            {
X              if (square->value[none] != 0)
X                square->value[none] = 0;
X              else
X              {
X                if (enable_hills)
X                  square->value[none] = NHILLTONES/2;
X                else if (enable_forest)
X                  square->value[none] = NFORESTTONES/2;
X                else if (enable_sea)
X                  square->value[none] = 1;
X              }
X            }
X
X            if (square->value[none] < 0)
X              square->value[none] = 0;
X            else if (enable_hills)
X            {
X              if (square->value[none] >= NHILLTONES)
X                square->value[none] = NHILLTONES-1;
X            }
X            else if (enable_forest)
X            {
X              if (square->value[none] >= NFORESTTONES)
X                square->value[none] = NFORESTTONES-1;
X            }
X            else if (enable_sea)
X            {
X              if (square->value[none] >= NSEATONES)
X                square->value[none] = NSEATONES-1;
X            }
X            else
X              square->value[none] = 0;
X
X            if (enable_sea && square->value[none] == 0)
X            {
X              if (square->color != none)
X              {
X                square->value[square->color] = 0;
X                square->color = none;
X              }
X
X              square->growth = 0;
X              square->oldgrowth = 0;
X              square->angle = 0;
X            }
X
X            drawsquare(xwindow[player], square, colorarray[player],
X                                        squaresize[colorarray[player]]);
X            break;
X        } 
X        break;
X
X      case KeyPress:
X        
X        textcount = XLookupString(&event, text, 10, &key, NULL);
X        if (textcount == 0)
X          break;
X
X        switch (text[0])
X        {
X          case 'c':
X          case 't':
X          case 'v':
X            if (enable_sea && square->value[none] <= 0)
X              break;
X          
X            if (text[0] == 'c')
X              square->growth = 100;
X            else if (text[0] == 't')
X              square->growth = 80;
X            else
X              square->growth = 60;
X
X            square->oldgrowth = square->growth;
X            square->angle = 23040;
X            break;
X
X          case 's':
X            if (square->oldgrowth > 50)
X            {
X              square->growth = 0;
X              square->angle -= 2304;
X
X              if (square->angle < 10)
X              {
X                square->growth = 0;
X                square->oldgrowth = 0;
X                square->angle = 0;
X              }
X            }
X            break;
X
X          case 'b':
X            if (square->oldgrowth > 50)
X            {
X              square->angle += 2304;
X
X              if (square->angle > 23030)
X              {
X                square->growth = square->oldgrowth;
X                square->angle = 23040;
X              }
X            }
X            break;
X
X          case 'j':
X            if (square->growth > 50)
X            {
X              square->growth *= 0.95;
X              square->oldgrowth = square->growth;
X            }
X
X            if (square->growth < 60)
X            {
X              square->growth = 0;
X              square->oldgrowth = 0;
X              square->angle = 0;
X            }
X            break;
X
X          case 'k':
X            if (square->growth > 50)
X            {
X              square->growth *= 1.05;
X              square->oldgrowth = square->growth;
X            }
X
X            if (square->growth > 100)
X            {
X              square->growth = 100;
X              square->oldgrowth = 100;
X            }
X            break;
X
X          case 'r':
X            currentcolor += 1;
X            if (currentcolor >= nsides)
X              currentcolor = 0;
X            break;
X
X          case 'f':
X            if (square->color != none)
X            {
X              value = square->value[square->color];
X              square->value[square->color] = 0;
X              square->color += 1;
X              if (square->color >= nsides)
X                square->color = 0;
X              square->value[square->color] = value;
X            }
X            break;
X
X          case '1':
X          case '2':
X          case '3':
X          case '4':
X          case '5':
X          case '6':
X          case '7':
X          case '8':
X          case '9':
X          case '0':
X          case '[':
X          case ']':
X            if (enable_sea && square->value[none] <= 0)
X              break;
X
X            if (square->color == none)
X              square->color = currentcolor;
X
X            if (text[0] == ']')
X              square->value[square->color] += 1;
X            else if (text[0] == '[')
X            {
X              if (square->value[square->color] > 0)
X                square->value[square->color] -= 1;
X            }
X            else
X              square->value[square->color] = (text[0] - '0')*MAXVAL/9;
X
X            if (square->value[square->color] == 0)
X              square->color = none;
X            else if (square->value[square->color] > MAXVAL)
X                square->value[square->color] = MAXVAL;
X            break;
X
X          case 'd':
X            dump_board (board, mapname);
X            drawboard (board, player, TRUE);
X            break;
X
X          case 'l':
X            load_board (board, mapname, TRUE);
X            drawboard (board, player, TRUE);
X            break;
X
X          case 'e':
X            exit (0);
X            break;
X        }
X
X        drawsquare(xwindow[player], square, colorarray[player],
X                                        squaresize[colorarray[player]]);
X
X        break;
X    }
X  }
X}
X
X
Xdump_board (board, filename)
X  square_type *board;
X  char filename[];
X{
X  int i, j;
X
X  FILE *fp,
X       *fopen();
X
X  if ((fp = fopen (filename, "w")) == NULL)
X  {
X    printf ("Unable to open map file: %s\n", filename);
X    exit (0);
X  }
X
X  fwrite (&boardsizex, sizeof(int), 1, fp);
X  fwrite (&boardsizey, sizeof(int), 1, fp);
X  fwrite (&enable_hex, sizeof(int), 1, fp);
X  fwrite (&enable_hills, sizeof(int), 1, fp);
X  fwrite (&enable_forest, sizeof(int), 1, fp);
X  fwrite (&enable_sea, sizeof(int), 1, fp);
X  fwrite (&enable_terrain, sizeof(int), 1, fp);
X  fwrite (&none, sizeof(int), 1, fp);
X
X  for (i=0; i<boardsizex; i++)
X    for (j=0; j<boardsizey; j++)
X      fwrite (SQUARE(board,i,j), sizeof(square_type), 1, fp);
X
X  fwrite (&nplayers, sizeof(int), 1, fp);
X
X  fclose (fp);
X}
X
X
Xload_board (board, filename, friendly)
X  square_type *board;
X  char filename[];
X  int friendly;
X{
X  int i, j,
X      temp_enable_hills,
X      temp_enable_forest,
X      temp_enable_sea,
X      temp_enable_terrain,
X      temp_none;
X
X  FILE *fp,
X       *fopen();
X
X  if ((fp = fopen (filename, "r")) == NULL)
X  {
X    printf ("Unable to open map file: %s\n", filename);
X    exit (0);
X  }
X
X  fread (&boardsizex, sizeof(int), 1, fp);
X  fread (&boardsizey, sizeof(int), 1, fp);
X  fread (&enable_hex, sizeof(int), 1, fp);
X  fread (&temp_enable_hills, sizeof(int), 1, fp);
X  fread (&temp_enable_forest, sizeof(int), 1, fp);
X  fread (&temp_enable_sea, sizeof(int), 1, fp);
X  fread (&temp_enable_terrain, sizeof(int), 1, fp);
X  fread (&temp_none, sizeof(int), 1, fp);
X
X  for (i=0; i<boardsizex; i++)
X    for (j=0; j<boardsizey; j++)
X      fread (SQUARE(board,i,j), sizeof(square_type), 1, fp);
X
X  for (i=0; i<boardsizex; i++)
X    for (j=0; j<boardsizey; j++)
X    {
X      SQUARE(board,i,j)->value[none] = SQUARE(board,i,j)->value[temp_none];
X
X      if (none > temp_none)
X        SQUARE(board,i,j)->value[temp_none] = 0;
X
X      if (SQUARE(board,i,j)->color > none)
X      {
X        SQUARE(board,i,j)->value[SQUARE(board,i,j)->color] = 0;
X        SQUARE(board,i,j)->color = none; 
X      }
X      else if (SQUARE(board,i,j)->color == temp_none)
X      {
X        SQUARE(board,i,j)->color = none; 
X      }
X    }
X
X  if (!friendly)
X  {
X    enable_hills = temp_enable_hills;
X    enable_forest = temp_enable_forest;
X    enable_sea = temp_enable_sea;
X    enable_terrain = temp_enable_terrain;
X  }
X
X  fclose (fp);
X}
END_OF_FILE
if test 34283 -ne `wc -c <'init.c'`; then
    echo shar: \"'init.c'\" unpacked with wrong size!
fi
# end of 'init.c'
fi
echo shar: End of archive 5 \(of 7\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
