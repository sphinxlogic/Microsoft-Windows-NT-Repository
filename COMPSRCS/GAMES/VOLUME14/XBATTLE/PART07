Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i078:  xbattle - multi-player battle strategy game for X-Windows, Part07/07
Message-ID: <3517@master.CNA.TEK.COM>
Date: 7 Sep 92 21:23:46 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1377
Approved: billr@saab.CNA.TEK.COM

Submitted-by: slehar@cns.bu.edu
Posting-number: Volume 14, Issue 78
Archive-name: xbattle/Part07
Environment: Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 7)."
# Contents:  tutorial1 utils.c
# Wrapped by billr@saab on Mon Sep  7 14:18:51 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'tutorial1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tutorial1'\"
else
echo shar: Extracting \"'tutorial1'\" \(17781 characters\)
sed "s/^X//" >'tutorial1' <<'END_OF_FILE'
X#! /bin/sh
X
Xecho "=================== XBATTLE TUTORIAL ========================" 
Xecho "hit RETURN to continue"
Xread p1
Xclear
Xecho "The xbattle  game  board is a grid  of  squares that can contain"
Xecho "troops of different colors-  or shades  of  gray if  you  have a"
Xecho "monochrome monitor.  Here is a small xbattle game board that was"
Xecho "started with the command..."
Xecho
Xecho "> xbattle -black me -board 5 -square 64 -manpos -armies 1"
X
Xxbattle -black me -board 5 -square 64  -manpos -armies 1&
X
Xecho
X
Xecho "This means- run xbattle, my color is  black, the board size is 5"
Xecho "x 5 game squares, and each game square is 64 x 64 pixels, use"
Xecho "manual positioning of the window, and give me one army."
X
Xecho
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho "The square in the  middle  represents an army  of  black troops,"
Xecho "which you can command by clicking with the mouse.  The direction"
Xecho "in which the  troops march  depends on where  in the game square"
Xecho "you click the  mouse- each  game square  is divided into regions"
Xecho "like this..."
X
Xecho
X
Xecho "              GAME SQUARE"
Xecho "	   =============================="
Xecho "	   ||        |        |        ||"
Xecho "	   || up &   | march  | up &   ||"
Xecho "	   || left   |  up    | right  ||"
Xecho "	   ||        |        |        ||"
Xecho "	   ||--------|--------|--------||"
Xecho "	   ||        |        |        ||"
Xecho "	   || march  | stop   | march  ||"
Xecho "	   || left   |        | right  ||"
Xecho "	   ||        |        |        ||"
Xecho "	   ||--------|--------|--------||"
Xecho "	   ||        |        |        ||"
Xecho "	   || down & | march  | down & ||"
Xecho "	   ||  left  |  down  | right  ||"
Xecho "	   ||        |        |        ||"
Xecho "	   =============================="
X
Xecho
X
Xecho "so,  for instance, to march  to the right,   you click near  the"
Xecho "right edge of the game square, and you will see a command vector"
Xecho "appear, pointing right.   Your  troop  square  will now  rapidly"
Xecho "shrink, and  the neighboring   square will  grow, as  the troops"
Xecho "march from one square to the next.  If you click near the corner"
Xecho "of  the game  square  the troops  will split   and  move in both"
Xecho "directions  at the same   time.   March  your troops  around the"
Xecho "little game board to get the feel of the commands."
X
Xecho
X
Xecho "Notice that the left mouse button toggles the command vectors on"
Xecho "or  off, while  the  middle mouse  button  clears   all existing"
Xecho "command vectors  and replaces them   with the new one.  Try  out"
Xecho "both these command modes.  For most practical purposes  you will"
Xecho "probably find the middle mouse to be more useful."
X
Xecho
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho "There is a text line under the game board. Commands issued while"
Xecho "the mouse is in the text area will be interpreted differently to"
Xecho "commands issued on the  game  board.  Position your mouse in the"
Xecho "text area, and  type control-c, (i.e. hold  the control  key and"
Xecho "type c) and  the game should quit.  Quit   the game  before  you"
Xecho "continue."
X
Xecho
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho
X
Xecho "Now we will start a  game with two  opposing armies,  black  and"
Xecho "white, and you can practice attacking the enemy.   The game will"
Xecho "be started with the command line..."
Xecho
Xecho "> xbattle -black me -white me -board 6 -manpos -armies 4"
Xecho
X
Xecho
Xecho "This time,  the board  is  6 x  6,  and the square   size is the"
Xecho "default size.  The argument '-armies 4' creates four  armies for"
Xecho "each team and arranges them in opposing ranks.  You will have to"
Xecho "position two windows this time, black and white, place them next"
Xecho "to each other so that you can see them both.   You will  only be"
Xecho "able to command the black  troops in the  black window, and  the"
Xecho "white troops from the white  window,  although both windows will"
Xecho "show the same game board.  Later on, you will be opening the two"
Xecho "windows on separate displays to play against an opponent on that"
Xecho "display; for now, you will be controlling both sides."
Xecho
Xecho "You  can   also   choose '-light' and    '-dark'  team colors on"
Xecho "monochrome monitors, while  color monitors will  display '-red',"
Xecho "'-green', '-blue',  '-cyan',   '-magenta', and  '-yellow'   team"
Xecho "colors as well    as the monochrome ones.  If    you are playing"
Xecho "between color  and monochrome  monitors, you  can   even  define"
Xecho "hybrid colors such as '-redblack' (color name first), which will"
Xecho "appear  red on the  color and black  on the monochrome monitors."
Xecho "Pure colors like '-red' will appear  on monochrome monitors with"
Xecho "a letter 'R' in each square."
Xecho
X
Xecho
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xxbattle -black me -white me -board 6 -manpos -armies 4&
X
Xecho "You can see the two  battle lines drawn  up opposite each other."
Xecho "Command one of the  black squares to  march into a white square."
Xecho "You will see that with  equal  initial strength, the attacker is"
Xecho "under  a disadvantage and  suffers  much more loss, although the"
Xecho "white might suffer some loss from the attack."
X
Xecho
X
Xecho "Now try something  else- in  the white window, command the white"
Xecho "troops  to  scatter all over   the  game board, splitting   into"
Xecho "smaller sections by clicking  near the  corners.   Then form the"
Xecho "remaining  black squares into a column,  and command the head of"
Xecho "the column to attack the smallest white squares one by one.  You"
Xecho "will see that  this has a  much greater effect.  During  battle,"
Xecho "both sides can suffer damage,  but when the  opposing forces are"
Xecho "unequal, the smaller force suffers  much greater  losses, so you"
Xecho "should always   strive for local  superiority   to minimize your"
Xecho "losses."
X
Xecho
X
Xecho "Try arranging flanking attacks by surrounding white squares from"
Xecho "two or more sides, and  then attacking simultaneously.  You must"
Xecho "click quickly to   assure  a  simultaneous attack in    order to"
Xecho "achieve maximum effect.  Here is another rule of xbattle- that a"
Xecho "simultaneous assault from two  or more directions  increases the"
Xecho "effectiveness of the attack.  "
X
Xecho
X
Xecho "Notice that during an attack,  both colors are displayed  in the"
Xecho "game  square in their  proper proportions, with a crossed-swords"
Xecho "battle symbol as long as the battle continues."
X
Xecho
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho "Notice that the text  area now contains two  lines, one for each"
Xecho "team.  Position your mouse in the text area and  type some keys-"
Xecho "you will see the characters appearing on both windows.  When the"
Xecho "opposing teams are  run from remote sites, the  text line can be"
Xecho "used to communicate between the windows."
X
Xecho
X
Xecho "Now, type control-c in both windows and quit the game before you"
Xecho "continue."
X
Xecho
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho "We will now experiment with resupply- in the next  game you will"
Xecho "see circles   in some  of  the   game  squares.    These circles"
Xecho "represent supply sources, and if you  capture one, it becomes an"
Xecho "endless supply of  additional troops   of your color.  The  game"
Xecho "board can soon be swamped by the excess troops if you  move them"
Xecho "around."
X
Xecho 
X
Xecho "This game was started with the command..."
X
Xecho
Xecho "> xbattle -red me -board 6 -manpos -armies 1 -towns 5"
Xecho
X
Xecho "where  the argument  -towns 5  provided  for randomly positioned"
Xecho "towns (the circles) with  randomly varying sizes with  a density"
Xecho "of  5.  Almost all arguments in  xbattle range between 0 and 10,"
Xecho "so that 5 is generally a mid value.  Notice  also that this time"
Xecho "your color is given as red.  If you are  on a color monitor, you"
Xecho "will  see  your troops as   red.  If  you   are  on a monochrome"
Xecho "monitor, they  will  be black, with  a letter 'R'  in each troop"
Xecho "square to denote the color."
Xecho
Xecho "Quit the  game  before you continue"
Xecho
X
Xxbattle -red me -board 6 -manpos -armies 1 -towns 5&
X
Xecho
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho "In the next example we  will add  a certain decay to the troops,"
Xecho "which means that the troops will consume their  provisions  at a"
Xecho "rate proportional to  the number of  troops.  That  means that a"
Xecho "single supply base can only  support a certain number of troops,"
Xecho "so that the  number of troops  will only  grow until it  reaches"
Xecho "that size.  Try to generate as many  troops as you  can from the"
Xecho "single supply base.  This game was started with the command..."
X
Xecho
Xecho "> xbattle -blueblack me -board 6 -manpos -rbases 1 -decay 10 -speed 10"
Xecho
X
Xxbattle -blueblack me -board 6 -manpos -rbases 1 -decay 10 -speed 10&
X
Xecho 
X
Xecho "In this game we use the argument '-rbases 1' which will create 1"
Xecho "full sized base for each team and position them randomly  on the"
Xecho "game  board.   Notice  also  that this  time  we   use the color"
Xecho "'blueblack', which means blue on a color monitor but black  on a"
Xecho "monochrome monitor.  The color name must come first."
X
Xecho
X
Xecho "Notice that the shorter the supply line, the larger  the size of"
Xecho "the army that can be maintained.   This is because of the losses"
Xecho "along the supply line.  Also,  troops  cut  off from the  supply"
Xecho "base will  wither   away   and  die.  In  this  example  we also"
Xecho "increased the speed of  the simulation with  the argument -speed"
Xecho "10, which  is  normally set to  the default -speed 5.   quit the"
Xecho "game before you continue"
X
Xecho
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho "In the next example we will use another form of resupply, called"
Xecho "farms.  Here, every square on the gameboard produces troops at a"
Xecho "steady rate, controlled by the size of the argument, so that the"
Xecho "larger  the area that you occupy,  the larger the  army that you"
Xecho "can sustain.  This simulation was started with the command..."
X
Xecho
Xecho "> xbattle -light me -board 6 -manpos -farms 9 -militia 9 -decay 5 -speed 10 -repeat"
Xecho
X
Xecho "and in this case we make use  of another option, called militia,"
Xecho "which creates  troops of random size in  random locations on the"
Xecho "game board.  Again, try to  create  the largest  army you can by"
Xecho "funneling the   production  of   all  the farms  into   a single"
Xecho "location.  This simulates  the large  scale dynamics of   troops"
Xecho "living  off  the fat  of    the land.  Also,   in  this game, we"
Xecho "demonstrate the -repeat option- if you corner-click one  army to"
Xecho "march north-east,  for  example,  then  rapidly click  in  other"
Xecho "squares  using the  RIGHT mouse   button, the north-east command"
Xecho "will be repeated in these squares.  For multiple repeated clicks"
Xecho "the -repeat option can save you a lot of time aiming  the mouse."
Xecho "Note also that we use the color 'light' which  means light gray."
Xecho "There are four monochrome colors, black, white, light and dark."
Xecho
Xecho "Quit the game before you continue."
X
Xxbattle -light me -board 6 -square 48 -manpos -farms 9 -militia 9 -decay 5 -speed 10 -repeat&
X
Xecho
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho "In the next examples, we will demonstrate three types of terrain"
Xecho "that can be used with xbattle-  seas,  hills, and forests.  Seas"
Xecho "are simply regions that cannot be traversed by  land troops, and"
Xecho "thus can  be  used  for  defensive strategy.   The  command line"
Xecho "argument -seas  5 will create random  seas with  a density of 5."
Xecho "We will also demonstrate the -hex  option, which creates a board"
Xecho "of hexagons rather than squares,  but the commands work  in  the"
Xecho "same way."
Xecho
Xecho "Quit the game before you continue."
X
Xecho
Xecho "> xbattle -black me -farms 5 -militia 5 -decay 5 -sea 5 -hex"
Xecho
X
Xecho
Xecho "hit RETURN to start the game"
Xread p1
Xclear
X
Xxbattle -black me -farms 5 -militia 5 -decay 5 -sea 5 -hex&
X
Xecho
Xecho "Quit the game before you continue."
Xread p1
Xclear
X
Xecho "Hills are represented  as various shades  of gray on monochrome"
Xecho "monitors, or shades  of green on  color monitors.  Progress  up"
Xecho "hills is much slower than on the level, but faster again on the"
Xecho "way  down.  The  steepness of   the hills  is  controled by the"
Xecho "argument."
Xecho "Quit the game before you continue."
X
Xecho
Xecho "> xbattle -black me -farms 5 -militia 5 -decay 5 -hills 9 -hex"
Xecho
X
Xecho
Xecho "hit RETURN to start the game"
Xread p1
Xclear
X
Xxbattle -black me -farms 5 -militia 5 -decay 5 -hills 9  -hex&
X
Xecho "wait... it takes a while to initialize the gray tones"
Xecho
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho "You may have noticed that when you run xbattle, it always prints"
Xecho "something like 'seed:  714326158'.   This is the  random  number"
Xecho "seed that xbattle uses to initialize all the random  features in"
Xecho "the game.	By default, xbattle  generates a new  seed every game."
Xecho "but you can specify a particular  seed with the parameter '-seed"
Xecho "<n>' in order to exactly recreate a particular game.  Be sure to"
Xecho "use exactly the same parameters as the original  game as well as"
Xecho "the same seed."
Xecho
Xecho
X
Xecho "Now,  we   will  demonstrate the  horizon  option  whereby enemy"
Xecho "activity is only seen when they are within a specified number of"
Xecho "game squares  from  the  nearest friendly  force,   the argument"
Xecho "determines  the  range of visibility,  in  game  squares, with a"
Xecho "default  of 2 if   no argument is supplied.   Send  out scouting"
Xecho "parties from   the magentablack   bases to search  out the  four"
Xecho "hidden  cyanwhite bases.  In   this   example we use  the  dummy"
Xecho "argument 'you' to represent a non-existant cyanwhite display for"
Xecho "the purpose of testing.  In actual play against an opponent, you"
Xecho "will have to specify an actual x display."
Xecho
Xecho "> xbattle -magentablack me -cyanwhite you -rbases 4 -horizon -hex"
Xecho
Xecho "Quit the game before you continue."
X
Xecho
Xecho "hit RETURN to start the game"
Xread p1
Xclear
X
Xxbattle -magentablack me -cyanwhite you -rbases 4 -horizon -hex&
X
Xecho
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho "You  can save   yourself the trouble  of typing  in a   bunch of"
Xecho "command options  if you  create an  options file,  and call that"
Xecho "file   when running xbattle.  A   couple   of  options files are"
Xecho "supplied   with xbattle, and you   can  create  your  own.   For"
Xecho "example, the file 'tribal.xbo' contains the options..."
Xecho
Xecho " -decay 2"
Xecho " -sea 8"
Xecho " -square 32"
Xecho " -board 24"
Xecho " -farms 7"
Xecho " -militia 10"
Xecho " -repeat"
Xecho " -fill 4"
Xecho " -dig 4"
Xecho " -area"
Xecho " -attack"
Xecho
Xecho "so you can call all these options with the command..."
Xecho
Xecho "> xbattle ... -options tribal.xbo ..."
Xecho
Xecho
Xecho "The tribal options create an interesting scenario  starting with"
Xecho "a mad rush to gain territory followed by  a plodding battle much"
Xecho "like WW1 trench warfare.  It introduces two new options, -attack"
Xecho "and -area.  The -attack  option  lets  you launch a simultaneous"
Xecho "attack on  an enemy square from  all adjacent  squares by use of"
Xecho "the 'a' key.  First surround the enemy,  then point at the enemy"
Xecho "square and   press  'a'.    The   -area  option    changes   the"
Xecho "representation of troop squares so that the number  of troops is"
Xecho "proportional to the area of the  square, rather  than the length"
Xecho "of the side, which is the default.   Practice occupying a corner"
Xecho "of the game board and clearing out all stray  enemy troops.  Two"
Xecho "more options, -dig  and -fill,   will  be discussed  in the next"
Xecho "tutorial."
Xecho
Xecho "> xbattle -black me -white you -options tribal.xbo &"
Xecho
Xecho "hit RETURN to start the game"
Xread p1
Xclear
X
Xxbattle -black me -white you -options tribal.xbo &
X
Xecho
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho "In order to play  against a  real opponent, you must specify the"
Xecho "display on which he will  be playing.  One  way to discover this"
Xecho "is by use of the unix command 'who'.  On my machine this command"
Xecho "produces a listing like this..."
Xecho
Xecho " slehar   ttyp0   Jan 10 10:19   (cnsxk.bu.edu:0.0)"
Xecho " slehar   ttyp1   Jan 10 10:19   (cnsxk.bu.edu:0.0)"
Xecho " lesher   ttyp2   Jan  7 10:05   (charles:0.0)"
Xecho " slehar   ttyp5   Jan 10 16:47   (unix:0.0)"
Xecho " slehar   ttyp6   Jan 10 16:47   (unix:0.0)"
Xecho
Xecho "which  tells   me    (slehar)  that   my   xdisplay  is   called"
Xecho "cnsxk.bu.edu:0.0, or just cnsxk.  I could start  an xbattle with"
Xecho "lesher using the command"
Xecho
Xecho "> xbattle -black me -white charles ..."
Xecho 
Xecho "supplying any command options I  might choose.  Alternatively, I"
Xecho "could use  cnsxk instead of  'me'  for my  own display."
X
Xecho
Xecho "hit RETURN to continue"
Xread p1
Xclear
X
Xecho "Play a few games with some real opponents before going on to the"
Xecho "next tutorial.  If playing against more experienced players, set"
Xecho "the  '-speed' parameter  very  low, like  1, or even  fractional"
Xecho "values like 0.5, to generate  a game  of strategy and intellect,"
Xecho "where the  manual skill of  rapid  clicking is  not the dominant"
Xecho "factor in the game.  In the next tutorial  you will learn how to"
Xecho "bias games, setting  game parameters differently for  individual"
Xecho "players."
Xecho
Xecho "       Good luck, and happy xbattling!"
Xecho
Xecho
Xecho
Xecho "================= END OF XBATTLE TUTORIAL ==================="
END_OF_FILE
if test 17781 -ne `wc -c <'tutorial1'`; then
    echo shar: \"'tutorial1'\" unpacked with wrong size!
fi
chmod +x 'tutorial1'
# end of 'tutorial1'
fi
if test -f 'utils.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils.c'\"
else
echo shar: Extracting \"'utils.c'\" \(27365 characters\)
sed "s/^X//" >'utils.c' <<'END_OF_FILE'
X#include <stdio.h>
X  
X/**** x include files ****/
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xatom.h>
X#include <X11/keysym.h>
X#include <X11/keysymdef.h>
X
X#include "extern.h"
X
X/*************************************************************************/
X/**	open_xwindow							**/
X/** arguments:								**/
X/**	struct xwindow_type *xwindow	xwindow structure		**/
X/**	int xpos,ypos			window position- negative value	**/
X/**					  means position with mouse	**/
X/**	int xsize,ysize			window dimensions		**/
X/**	char title[]			window and icon title		**/
X/**	long eventmask			event mask e.g. ButtonPressMask	**/
X/**                                			KeyPressMask	**/
X/**                                			ExposureMask	**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xopen_xwindow(xwindow,displayname,xpos,ypos,xsize,ysize,gtitle,htitle,eventmask,squaresize)
X  xwindow_type *xwindow;
X  char displayname[];
X  int xpos,ypos,xsize,ysize;
X  char gtitle[], htitle[];
X  long eventmask;
X  int squaresize;
X{
X  int i, j, k;
X  GC create_gc();
X
X  /**** visuals variables ****/
X  Visual *visual;		/* struct defining window properties 	*/
X  unsigned long valuemask;	/* mask for attributes 			*/
X  XSetWindowAttributes attrib;	/* window attributes 			*/
X  XVisualInfo vinfo;
X  XPoint hex_small_points[7];
X  double fraction, temp;
X
X  GC gc_and,
X     gc_all,
X     gc_none,
X     terrainhue[NHILLTONES];
X  static Pixmap stipple[NGREYTONES+NHILLTONES];
X  double ratio, value, increment;
X  int limit;
X
X  /**** open display and screen ****/
X  xwindow->display = XOpenDisplay(displayname);
X  if(xwindow->display == NULL)
X  {
X    printf("ERROR open_xwindow: can't open display %s\n",displayname);
X    exit(1);
X  }
X  xwindow->screen  = DefaultScreen(xwindow->display);
X
X  /**** set window position and size hints for window manager ****/
X  xwindow->hint.x = xpos;
X  xwindow->hint.y = ypos;
X  xwindow->hint.width = xsize;
X  xwindow->hint.height = ysize;
X  if (xpos < 0 || ypos < 0)
X    xwindow->hint.flags = ( PPosition | PSize);
X  else
X    xwindow->hint.flags = (USPosition | PSize);
X
X  /**** get a visual with required properties ****/
X  xwindow->depth = DefaultDepth(xwindow->display, xwindow->screen);
X
X  visual = DefaultVisual(xwindow->display,xwindow->screen);
X
X  if(xwindow->depth != 8)
X  {
X    if (XMatchVisualInfo(xwindow->display, xwindow->screen, 8, PseudoColor, &vinfo))
X    {
X      visual = vinfo.visual;
X      xwindow->depth = 8;
X    }
X  }
X
X  if (xwindow->depth != 8)
X    xwindow->depth = 1;
X
X  if(xwindow->depth == 8)
X  {
X    /**** create color map using visual ****/
X#if NEWCOLORMAP
X    xwindow->cmap = XCreateColormap(xwindow->display,
X			    RootWindow(xwindow->display, xwindow->screen),
X			    visual, AllocAll);
X#else
X    xwindow->cmap = DefaultColormap (xwindow->display, xwindow->screen);
X#endif
X    
X    /**** set attributes ****/
X    valuemask = CWBackPixel | CWBorderPixel | CWBitGravity | CWColormap;
X    attrib.background_pixel = BlackPixel(xwindow->display,xwindow->screen);
X    attrib.border_pixel = BlackPixel(xwindow->display,xwindow->screen);
X    attrib.bit_gravity = CenterGravity;
X    attrib.colormap = xwindow->cmap;
X
X    /**** create the x window ****/
X    xwindow->window = XCreateWindow(xwindow->display, 
X		      RootWindow(xwindow->display, xwindow->screen),
X		      xwindow->hint.x, xwindow->hint.y,
X		      xwindow->hint.width, xwindow->hint.height,
X		      BORDER, xwindow->depth, InputOutput, visual,
X		      valuemask, &attrib);
X  }
X  else
X  {
X    xwindow->window = XCreateSimpleWindow(xwindow->display,
X                                 DefaultRootWindow(xwindow->display),
X                                 xwindow->hint.x, xwindow->hint.y,
X                                 xwindow->hint.width, xwindow->hint.height, BORDER,
X                                 BlackPixel(xwindow->display,xwindow->screen),
X                                 WhitePixel(xwindow->display,xwindow->screen));
X  }
X
X  /**** get standard properties for window manager ****/
X  if (xwindow->depth == 8)
X    XSetStandardProperties(xwindow->display, xwindow->window, htitle, htitle,
X 			 None, NULL, None, &xwindow->hint);
X  else if (xwindow->depth == 1)
X  {
X    XSetStandardProperties(xwindow->display, xwindow->window, gtitle, gtitle, 
X 			 None, NULL, None, &xwindow->hint);
X  }
X
X  /**** set window manager hints ****/
X  xwindow->xwmh.flags = (InputHint|StateHint);  
X  xwindow->xwmh.input = TRUE;
X  xwindow->xwmh.initial_state = NormalState;
X  XSetWMHints(xwindow->display, xwindow->window, &(xwindow->xwmh));
X
X  /**** make window sensitive selected events ****/
X  XSelectInput(xwindow->display, xwindow->window, eventmask);
X
X  /**** load color map ****/
X  if(xwindow->depth == 8)
X  {
X    for (i=0 ; i<MAXCOLORS ; i++)
X    {
X      xwindow->xcolor[i].flags = 0;
X      xwindow->xcolor[i].pixel = i;
X      xwindow->xcolor[i].red = 0;
X      xwindow->xcolor[i].green = 0;
X      xwindow->xcolor[i].blue = 0;
X    }
X
X    /**** set player colors ****/
X    for (i=0; i<nsides; i++)
X    {
X      xwindow->xcolor[i].flags = DoRed | DoGreen | DoBlue;
X      xwindow->xcolor[i].pixel = i;
X      xwindow->xcolor[i].red =   palette[sidemap[i]][0]<<8;
X      xwindow->xcolor[i].green = palette[sidemap[i]][1]<<8;
X      xwindow->xcolor[i].blue =  palette[sidemap[i]][2]<<8;
X    }
X
X    /**** background color ****/
X    xwindow->xcolor[none].flags = DoRed | DoGreen | DoBlue;
X    xwindow->xcolor[none].pixel = none;
X    xwindow->xcolor[none].red =   palette[0][0]<<8;
X    xwindow->xcolor[none].green = palette[0][1]<<8;
X    xwindow->xcolor[none].blue =  palette[0][2]<<8;
X
X    /**** dark ****/
X    xwindow->xcolor[dark].flags = DoRed | DoGreen | DoBlue;
X    xwindow->xcolor[dark].pixel = dark;
X    xwindow->xcolor[dark].red =   0<<8;
X    xwindow->xcolor[dark].green = 0<<8;
X    xwindow->xcolor[dark].blue =  0<<8;
X
X    /**** light ****/
X    xwindow->xcolor[light].flags = DoRed | DoGreen | DoBlue;
X    xwindow->xcolor[light].pixel = light;
X    xwindow->xcolor[light].red =   255<<8;
X    xwindow->xcolor[light].green = 255<<8;
X    xwindow->xcolor[light].blue =  255<<8;
X
X    if (enable_terrain)
X    {
X      /**** set hill tones ****/
X      if (enable_hills)
X      {
X        increment = 5.0/((double)(NHILLTONES-1));
X        for (i=0; i<NHILLTONES; i++)
X        {
X          value = increment * i;
X          xwindow->xcolor[light+1+i].flags = DoRed | DoGreen | DoBlue;
X          xwindow->xcolor[light+1+i].pixel = light+1+i;
X
X          xwindow->xcolor[light+1+i].red =   ((int)(hillintersect[0] + hillslope[0]*value))<<8;
X          xwindow->xcolor[light+1+i].green = ((int)(hillintersect[1] + hillslope[1]*value))<<8;
X          xwindow->xcolor[light+1+i].blue =  ((int)(hillintersect[2] + hillslope[2]*value))<<8;
X
X/*** Simpler ratio method of hill determination ***/
X/***
X          ratio = ((1.25-0.75)/((double)(NHILLTONES-1)))*i + 0.75;
X
X          xwindow->xcolor[light+1+i].red =   ((int)(ratio*hillpalette[0]))<<8;
X          xwindow->xcolor[light+1+i].green = ((int)(ratio*hillpalette[1]))<<8;
X          xwindow->xcolor[light+1+i].blue =  ((int)(ratio*hillpalette[2]))<<8;
X***/
X        }
X        if (enable_sea)
X        {
X          xwindow->xcolor[light+1].flags = DoRed | DoGreen | DoBlue;
X          xwindow->xcolor[light+1].pixel = light+1;
X          xwindow->xcolor[light+1].red =   (seapalette[0])<<8;
X          xwindow->xcolor[light+1].green = (seapalette[1])<<8;
X          xwindow->xcolor[light+1].blue =  (seapalette[2])<<8;
X        }
X      }
X      /**** set forest tones ****/
X      if (enable_forest)
X      {
X        for (i=0; i<NFORESTTONES; i++)
X        {
X          xwindow->xcolor[light+1+i].flags = DoRed | DoGreen | DoBlue;
X          xwindow->xcolor[light+1+i].pixel = light+1+i;
X
X          ratio = ((1.25-0.75)/((double)(NFORESTTONES-1)))*(NFORESTTONES-1-i) + 0.75;
X
X          xwindow->xcolor[light+1+i].red =   ((int)(ratio*forestpalette[0]))<<8;
X          xwindow->xcolor[light+1+i].green = ((int)(ratio*forestpalette[1]))<<8;
X          xwindow->xcolor[light+1+i].blue =  ((int)(ratio*forestpalette[2]))<<8;
X        }
X        if (enable_sea)
X        {
X          xwindow->xcolor[light+1].flags = DoRed | DoGreen | DoBlue;
X          xwindow->xcolor[light+1].pixel = light+1;
X          xwindow->xcolor[light+1].red =   (seapalette[0])<<8;
X          xwindow->xcolor[light+1].green = (seapalette[1])<<8;
X          xwindow->xcolor[light+1].blue =  (seapalette[2])<<8;
X        }
X      }
X      /**** set sea tone(s) ****/
X      if (enable_sea && !enable_hills && !enable_forest)
X      {
X        xwindow->xcolor[light+1].flags = DoRed | DoGreen | DoBlue;
X        xwindow->xcolor[light+1].pixel = light+1;
X        xwindow->xcolor[light+1].red =   (seapalette[0])<<8;
X        xwindow->xcolor[light+1].green = (seapalette[1])<<8;
X        xwindow->xcolor[light+1].blue =  (seapalette[2])<<8;
X
X        xwindow->xcolor[light+2].flags = DoRed | DoGreen | DoBlue;
X        xwindow->xcolor[light+2].pixel = light+2;
X        xwindow->xcolor[light+2].red =   (palette[0][0])<<8;
X        xwindow->xcolor[light+2].green = (palette[0][1])<<8;
X        xwindow->xcolor[light+2].blue =  (palette[0][2])<<8;
X
X      }
X    }
X
X#if NEWCOLORMAP
X    XStoreColors(xwindow->display, xwindow->cmap, xwindow->xcolor, MAXCOLORS);
X#else
X    for (i=0; i<MAXCOLORS; i++)
X      if (!XAllocColor(xwindow->display, xwindow->cmap, &xwindow->xcolor[i] ))
X        printf ( "Warning: Couldn't allocate color cells\n");
X#endif
X
X    for (i=0; i<nsides; i++)
X      xwindow->drawletter[i] = FALSE;
X  }
X
X  /**** window mapping ****/
X  XMapRaised(xwindow->display, xwindow->window);
X
X  /**** create graphics contexts (drawing colors) ****/
X  for (j=0; j<=nsides+2; j++)
X    xwindow->hue[j] = XCreateGC(xwindow->display, xwindow->window, 0, 0);
X  xwindow->flip  = XCreateGC(xwindow->display, xwindow->window, 0, 0);
X
X  xwindow->gc_clear  = XCreateGC(xwindow->display, xwindow->window, 0, 0);
X  XSetFunction(xwindow->display, xwindow->gc_clear, GXandInverted);
X
X  xwindow->gc_or = XCreateGC(xwindow->display, xwindow->window, 0, 0);
X  XSetFunction(xwindow->display, xwindow->gc_or, GXor);
X
X  if (enable_terrain)
X  {
X    if (enable_hills)
X      limit = NHILLTONES;
X    else if (enable_forest)
X      limit = NFORESTTONES;
X    if (enable_sea && !enable_hills && !enable_forest)
X      limit = NSEATONES;
X
X    for (j=0; j<limit; j++)
X    {
X       terrainhue[j] = XCreateGC(xwindow->display, xwindow->window, 0, 0);
X       XSetFunction(xwindow->display, terrainhue[j], GXcopy);
X    }
X  }
X
X  /**** set drawing functions ****/
X  for (j=0; j<=nsides+2; j++)
X    XSetFunction(xwindow->display, xwindow->hue[j], GXcopy);
X  XSetFunction(xwindow->display, xwindow->flip,  GXinvert);
X
X  /**** set drawing colors ****/
X  if (xwindow->depth == 1)
X  { 
X    for (j=0; j<nsides; j++) {
X
X      if (color2bw[sidemap[j]] == WHITE)
X      {
X        XSetForeground(xwindow->display, xwindow->hue[j],
X                     WhitePixel(xwindow->display,xwindow->screen));
X        XSetBackground(xwindow->display, xwindow->hue[j],
X                     BlackPixel(xwindow->display,xwindow->screen));
X      }
X      else
X      {
X        XSetForeground(xwindow->display, xwindow->hue[j],
X                     BlackPixel(xwindow->display,xwindow->screen));
X        XSetBackground(xwindow->display, xwindow->hue[j],
X                     WhitePixel(xwindow->display,xwindow->screen));
X      }
X    }
X    XSetForeground(xwindow->display, xwindow->hue[none],
X                     BlackPixel(xwindow->display,xwindow->screen));
X    XSetBackground(xwindow->display, xwindow->hue[none],
X                     WhitePixel(xwindow->display,xwindow->screen));
X
X    XSetForeground(xwindow->display, xwindow->hue[dark],
X                     BlackPixel(xwindow->display,xwindow->screen));
X    XSetBackground(xwindow->display, xwindow->hue[dark],
X                     WhitePixel(xwindow->display,xwindow->screen));
X
X    XSetForeground(xwindow->display, xwindow->hue[light],
X                     WhitePixel(xwindow->display,xwindow->screen));
X    XSetBackground(xwindow->display, xwindow->hue[light],
X                     BlackPixel(xwindow->display,xwindow->screen));
X
X/**
X    XSetForeground(xwindow->display, xwindow->flip,
X                 BlackPixel(xwindow->display,xwindow->screen));
X    XSetBackground(xwindow->display, xwindow->flip,
X                 WhitePixel(xwindow->display,xwindow->screen));
X**/
X  }
X
X  /**** set colors (link GC to color) ****/
X  if (xwindow->depth == 8)
X  {
X#if NEWCOLORMAP
X    for (j=0; j<nsides; j++)
X    {
X      XSetForeground (xwindow->display, xwindow->hue[j], j);
X      XSetBackground (xwindow->display, xwindow->hue[j], nsides);
X    }
X    XSetForeground (xwindow->display, xwindow->hue[none], none);
X    XSetForeground (xwindow->display, xwindow->hue[dark], dark);
X    XSetForeground (xwindow->display, xwindow->hue[light], light);
X#else
X    for (j=0; j<nsides; j++)
X    {
X      XSetForeground (xwindow->display, xwindow->hue[j], xwindow->xcolor[j].pixel);
X      XSetBackground (xwindow->display, xwindow->hue[j], xwindow->xcolor[nsides].pixel);
X    }
X    XSetForeground (xwindow->display, xwindow->hue[none], xwindow->xcolor[none].pixel);
X    XSetForeground (xwindow->display, xwindow->hue[dark], xwindow->xcolor[dark].pixel);
X    XSetForeground (xwindow->display, xwindow->hue[light], xwindow->xcolor[light].pixel);
X#endif
X
X    if (enable_terrain)
X    {
X      for (j=0; j<limit; j++)
X      {
X#if NEWCOLORMAP
X        XSetForeground (xwindow->display, terrainhue[j], light+1+j);
X        XSetBackground (xwindow->display, terrainhue[j], none);
X#else
X        XSetForeground (xwindow->display, terrainhue[j], xwindow->xcolor[light+1+j].pixel);
X        XSetBackground (xwindow->display, terrainhue[j], xwindow->xcolor[none].pixel);
X#endif
X      }
X    }
X  }
X
X  if (xwindow->depth == 1)
X  {
X    /**** set grey stipple color ****/
X
X    init_stipple (xwindow->display, xwindow->window, stipple);
X
X    for (j=0; j<nsides; j++)
X    {
X      if (color2bw[sidemap[j]] != WHITE && color2bw[sidemap[j]] != BLACK)
X      {
X        XSetStipple(  xwindow->display, xwindow->hue[j], stipple[color2bw[sidemap[j]]-BLACK-1]);
X        XSetFillStyle(xwindow->display, xwindow->hue[j], FillOpaqueStippled);
X      }
X    }
X
X    XSetStipple(  xwindow->display, xwindow->hue[nsides], stipple[NGREYTONES/2]);
X    XSetFillStyle(xwindow->display, xwindow->hue[nsides], FillOpaqueStippled);
X  }
X
X  
X  /**** create and initialize pixmaps for terrain ****/
X  if (enable_terrain)
X  {
X    for (i=0; i<limit; i++)
X    {
X      if (enable_hex)
X      {
X        if (i == 0 && enable_sea)
X          xwindow->terrain[i] = XCreatePixmap (xwindow->display, xwindow->window,
X                                              2*fillnumber*hex_side, 6*hex_vert, xwindow->depth);
X        else
X          xwindow->terrain[i] = XCreatePixmap (xwindow->display, xwindow->window,
X                                              2*hex_side, 6*hex_vert, xwindow->depth);
X      }
X      else
X        xwindow->terrain[i] = XCreatePixmap (xwindow->display, xwindow->window,
X                                              squaresize, squaresize, xwindow->depth);
X    }
X
X    if (xwindow->depth == 8)
X    {
X      for (i=0; i<limit; i++)
X      {
X          if (enable_hex)
X            XFillRectangle(xwindow->display,xwindow->terrain[i],
X                          terrainhue[i], 0, 0, 2*hex_side, 2*hex_vert);
X          else
X            XFillRectangle(xwindow->display,xwindow->terrain[i],
X                          terrainhue[i], 0, 0, squaresize, squaresize);
X      }
X    }
X    else if (xwindow->depth == 1)
X    {
X      if (enable_hex)
X        init_terrain_pixmaps (xwindow, limit, 2*hex_side);
X      else
X        init_terrain_pixmaps (xwindow, limit, squaresize);
X   
X      if (enable_sea && !enable_hills && !enable_forest)
X      {
X        if (enable_sea)
X        {
X          if (enable_hex)
X            XFillRectangle(xwindow->display,xwindow->terrain[1],
X                   xwindow->hue[none], 0, 0, 2*hex_side, 2*hex_vert);
X          else
X            XFillRectangle(xwindow->display,xwindow->terrain[1],
X                   xwindow->hue[none], 0, 0, squaresize, squaresize);
X        }
X      }
X    }
X
X    gc_and  = XCreateGC(xwindow->display, xwindow->window, 0, 0);
X    XSetFunction(xwindow->display, gc_and, GXand);
X
X    gc_all  = XCreateGC(xwindow->display, xwindow->window, 0, 0);
X    XSetFunction(xwindow->display, gc_all, GXset);
X
X    gc_none  = XCreateGC(xwindow->display, xwindow->window, 0, 0);
X    XSetFunction(xwindow->display, gc_none, GXclear);
X
X    if (enable_hex)
X    {
X      for (i=0; i<limit; i++)
X      {
X        if (i==0 && enable_sea)
X        {
X          for (j=0; j<fillnumber; j++)
X          {
X            XCopyArea (xwindow->display, xwindow->terrain[0], xwindow->terrain[0],
X                              xwindow->hue[light], 0, 0, 2*hex_side, 2*hex_vert, 2*j*hex_side, 0);
X
X            fraction = ((double)(fillnumber-j))/(fillnumber);
X
X            hex_small_points[0].x = 2*j*hex_side + hex_halfside +
X                                               (int)((1.0-fraction)*hex_halfside + 0.5);
X            hex_small_points[0].y = 2*hex_vert + (int)((1.0-fraction)*hex_vert + 0.5);
X
X            for (k=1; k<7; k++)
X            {
X              temp = fraction*hex_points[k].x;
X              if (temp < 0)
X                hex_small_points[k].x = (int)(fraction * hex_points[k].x - 0.5);
X              else
X                hex_small_points[k].x = (int)(fraction * hex_points[k].x + 0.5);
X
X              temp = fraction*hex_points[k].y;
X              if (temp < 0)
X                hex_small_points[k].y = (int)(fraction * hex_points[k].y - 0.5);
X              else
X                hex_small_points[k].y = (int)(fraction * hex_points[k].y + 0.5);
X            }
X
X            XFillRectangle(xwindow->display,xwindow->terrain[0], gc_none,
X                                            2*j*hex_side, 2*hex_vert, 2*hex_side, 2*hex_vert);
X
X            XFillPolygon (xwindow->display, xwindow->terrain[0], gc_all,
X                                            hex_small_points, 6, Convex, CoordModePrevious);
X  
X            XCopyArea (xwindow->display, xwindow->terrain[0], xwindow->terrain[0],
X                       gc_and, 2*j*hex_side, 2*hex_vert, 2*hex_side, 2*hex_vert, 2*j*hex_side, 0);
X          }
X        }
X        else
X        {
X          hex_points[0].x = hex_halfside;
X          hex_points[0].y = 2*hex_vert;
X
X          XFillRectangle (xwindow->display,xwindow->terrain[i], gc_none,
X                                        0, 2*hex_vert, 2*hex_side, 2*hex_vert);
X
X          XFillPolygon (xwindow->display, xwindow->terrain[i], gc_all,
X                                            hex_points, 6, Convex, CoordModePrevious);
X 
X          XCopyArea (xwindow->display, xwindow->terrain[i], xwindow->terrain[i],
X                   gc_and, 0, 2*hex_vert, 2*hex_side, 2*hex_vert, 0, 0);
X
X        }
X      }
X    }
X  }
X
X  /**** load font ****/
X  xwindow->font_struct = XLoadQueryFont(xwindow->display, FONT);
X  if(xwindow->font_struct == 0)
X  {
X    printf("font %s not found, using default\n",FONT);
X    xwindow->font_struct = XQueryFont(xwindow->display,XGContextFromGC(
X                    DefaultGC(xwindow->display,xwindow->screen)));
X  }
X  else
X  {
X    for (i=0; i<nsides; i++)
X      XSetFont(xwindow->display, xwindow->hue[i], xwindow->font_struct->fid);
X    XSetFont(xwindow->display, xwindow->flip,  xwindow->font_struct->fid);
X  }
X
X  if (xwindow->depth == 1)
X  {
X    for (i=0; i<nsides; i++)
X    {
X      if (lettermap[i][0])
X      {
X        xwindow->drawletter[i] = TRUE;
X        XGetFontProperty(xwindow->font_struct, XA_QUAD_WIDTH, &xwindow->charwidth);
X        XGetFontProperty(xwindow->font_struct, XA_CAP_HEIGHT, &xwindow->charheight);
X        strcpy (xwindow->letter[i], lettermap[i]);
X      }
X      else if (enable_reserve[i])
X      {
X        XGetFontProperty(xwindow->font_struct, XA_QUAD_WIDTH, &xwindow->charwidth);
X        XGetFontProperty(xwindow->font_struct, XA_CAP_HEIGHT, &xwindow->charheight);
X      }
X      else
X        xwindow->drawletter[i] = FALSE;
X    }
X  }
X  xwindow->drawletter[none] = FALSE;
X
X  /**** map window to make it visible ****/
X  if (xwindow->depth == 8)
X    XMapWindow(xwindow->display, xwindow->window);
X}
X
X
X/*************************************************************************/
X/**	close_xwindow							**/
X/**  Close the x window							**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/*************************************************************************/
Xclose_xwindow(xwindow)
X  xwindow_type *xwindow;
X{
X  XDestroyWindow(xwindow->display,xwindow->window);
X  XCloseDisplay(xwindow->display);
X}
X
X
X/*************************************************************************/
X/**     init_stipple                                                    **/
X/**  create stipple patterns for greytoning				**/
X/**     Greg Lesher (lesher@park.bu.edu)                                **/
X/*************************************************************************/
Xinit_stipple (display, window, stipple)
X
X  Display *display;
X  Window window;
X  Pixmap stipple[];
X
X{
X  int i;
X
X  static char grey[NGREYTONES+NHILLTONES][8] = {
X    {0xAA, 0xFF, 0xAA, 0xFF, 0xAA, 0xFF, 0xAA, 0xFF},
X    {0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55},
X    {0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00}};
X
X  for (i=0; i<NGREYTONES; i++)
X    stipple[i] = XCreateBitmapFromData(display,window,grey[i],8,8);
X}
X
X
X/*************************************************************************/
X/**     init_terrain                                                    **/
X/**  yse error diffusion to emulate grayscale terrain			**/
X/**     Greg Lesher (lesher@park.bu.edu)                                **/
X/*************************************************************************/
Xinit_terrain_pixmaps (xwindow, limit, squaresize)
X  xwindow_type *xwindow;
X  int limit,
X      squaresize;
X{
X  int i, x, y,
X      enable_quasi;
X
X  double value,
X         quasi,
X         target[2*MAXSQUARESIZE+20][2*MAXSQUARESIZE+20],
X         error,
X         drand48();
X
X  if (NHILLTONES > 5)
X    enable_quasi = TRUE;
X  else
X    enable_quasi = FALSE;
X
X  /**** for each level of greytone ****/
X  for (i=0; i<limit; i++)
X  {
X    /**** compute desired graylevel in [0,1] ****/
X   
X    if (enable_forest)
X      value = 0.75 - ((0.75-0.25)/((double)(limit-1)))*(limit-1-i);
X    else
X      value = 0.75 - ((0.75-0.25)/((double)(limit-1)))*i;
X
X    if (enable_sea && i == 0)
X    {
X      value = SEAVALUE;
X      enable_quasi = TRUE;
X    }
X    else if (NHILLTONES <= 5)
X      enable_quasi = FALSE;
X
X    for (x=0; x<squaresize+20; x++)
X      for (y=0; y<squaresize+20; y++)
X        target[x][y] = value;
X
X    /**** for each square threshold and diffuse error ****/
X    for (x=0; x<squaresize+20; x++)
X    {
X      for (y=0; y<squaresize+20; y++)
X      {
X        /**** threshold and set error ****/
X        if (target[x][y] > 0.5)
X        {
X          if (x>=10 && x<squaresize+10 && y>=10 && y<squaresize+10)
X            XDrawPoint (xwindow->display, xwindow->terrain[i], xwindow->hue[dark], x-10, y-10);
X          error = target[x][y] - 1.0;
X        }
X        else
X        {
X          if (x>=10 && x<squaresize+10 && y>=10 && y<squaresize+10)
X            XDrawPoint (xwindow->display, xwindow->terrain[i], xwindow->hue[light], x-10, y-10);
X          error = target[x][y];
X        }
X
X        /**** enable randomness if over 5 levels (removes artifacts and worms) ****/
X        if (enable_quasi)
X          quasi = drand48()/20.0;
X        else
X          quasi = 0;
X
X        /**** distribute error ****/
X        if (y == 0)
X        {
X          if (x == squaresize+20-1)
X          {
X            target[x][y+1] += 1.0*error;
X          }
X          else
X          {
X            target[x][y+1] += (0.4+quasi)*error;
X            target[x+1][y] += (0.4-quasi)*error;
X            target[x+1][y+1] += 0.2*error;
X          }
X        }
X        else if (y == squaresize+20-1)
X        {
X          if (x != squaresize+20-1)
X          {
X            target[x+1][y] += (0.7+quasi)*error;
X            target[x+1][y-1] += (0.3-quasi)*error;
X          }
X        }
X        else if (x == squaresize+20-1)
X        {
X          target[x][y+1] += 1.0*error;
X        }
X        else
X        {
X          target[x][y+1] += (0.3+quasi)*error;
X          target[x+1][y] += (0.3-quasi)*error;
X          target[x+1][y+1] += 0.2*error;
X          target[x+1][y-1] += 0.2*error;
X        }
X      }
X    }
X
X    if (enable_sea && !enable_hills && !enable_forest)
X      return;
X  }
X}
X
X
X/*****************************************************************/
X/**	intval							**/
X/** returns the int value of the argument indexed by index+1	**/
X/**	Steve Lehar (slehar@park.bu.edu)			**/
X/*****************************************************************/
Xintval(str,argc,argv)
X  char str[];
X  int argc;
X  char *argv[];
X{
X  int i,
X      index=0;
X
X  for (i=1; i<argc; i++)
X  {
X    if (strcmp(argv[i],str)==0)
X      index=i;
X  }
X  if (index>0)
X    sscanf(argv[index+1],"%d",&i);
X  else
X    i=0;
X  return(i);
X}
X
X
X/*****************************************************************/
X/**	doubleval						**/
X/** returns the double value of the argument indexed by index+1	**/
X/**	Steve Lehar (slehar@park.bu.edu)			**/
X/*****************************************************************/
Xdouble doubleval(str,argc,argv)
X  char str[];
X  int argc;
X  char *argv[];
X{
X  float f;
X  int i,
X      index=0;
X
X  for (i=1; i<argc; i++)
X  {
X    if (strcmp(argv[i],str)==0)
X      index=i;
X  }
X  if (index>0)
X    sscanf(argv[index+1],"%f",&f);
X  else
X    f = 0.0;
X  return((double)(f));
X}
X
X
X/*****************************************************************/
X/**	stringval						**/
X/** sets string to the string argument indexed by index+1	**/
X/**	Greg Lesher (lesher@park.bu.edu)			**/
X/*****************************************************************/
Xint stringval(str,argc,argv,string)
X  char str[];
X  int argc;
X  char *argv[];
X  char string[];
X{
X  int i,
X      index=0;
X
X  for (i=1; i<argc; i++)
X  {
X    if (strcmp(argv[i],str)==0)
X      index=i;
X  }
X  if (index == (argc-1))
X    return (FALSE);
X  if (argv[index+1][0] == '-' || argv[index+1][0] == '}')
X    return (FALSE);
X  strcpy (string, argv[index+1]);
X  return(TRUE);
X}
X
X
X/*****************************************************************/
X/**	is_arg							**/
X/** determines wether a command line argument exists in the	**/
X/** form of str.						**/
X/**	Steve Lehar (slehar@park.bu.edu)			**/
X/*****************************************************************/
Xis_arg(str,argc,argv)
X  char str[];
X  int argc;
X  char *argv[];
X{
X  int i,
X      found=0;
X
X  for (i=1; i<argc; i++)
X  {
X    if (strcmp(argv[i],str)==0)
X      found=i;
X  }
X  return(found);
X}
X
X
X/*************************************************************************/
X/**     matchsstr                                                       **/
X/**  attempts to match first part of two input strings			**/
X/**     Greg Lesher (lesher@park.bu.edu)                                **/
X/*************************************************************************/
Xmatchstr (line, word)
X  char line[], word[];
X{
X  int i;
X
X  for (i=0; i<strlen(word); i++)
X    if (line[i] != word[i])
X      return (FALSE);
X  return (TRUE);
X}
X
X
X#if NODRAND48
Xdouble
Xdrand48()
X{
X  double temp;
X
X  temp = (double)(rand() & 0xFFFF)/((double)(0xFFFF));
X
X  return (temp);
X}
X#endif
END_OF_FILE
if test 27365 -ne `wc -c <'utils.c'`; then
    echo shar: \"'utils.c'\" unpacked with wrong size!
fi
# end of 'utils.c'
fi
echo shar: End of archive 7 \(of 7\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
