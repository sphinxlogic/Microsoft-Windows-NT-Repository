Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i075:  xbattle - multi-player battle strategy game for X-Windows, Part04/07
Message-ID: <3514@master.CNA.TEK.COM>
Date: 7 Sep 92 21:23:07 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1709
Approved: billr@saab.CNA.TEK.COM

Submitted-by: slehar@cns.bu.edu
Posting-number: Volume 14, Issue 75
Archive-name: xbattle/Part04
Environment: Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 7)."
# Contents:  draw.c extern.h
# Wrapped by billr@saab on Mon Sep  7 14:18:50 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'draw.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'draw.c'\"
else
echo shar: Extracting \"'draw.c'\" \(43247 characters\)
sed "s/^X//" >'draw.c' <<'END_OF_FILE'
X#include <stdio.h>
X  
X/**** x include files ****/
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xatom.h>
X#include <X11/keysym.h>
X#include <X11/keysymdef.h>
X
X#include "extern.h"
X
X/*************************************************************************/
X/**	drawboard							**/
X/** draw the game board							**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xdrawboard(board, player,justboard)
X  square_type *board;
X  int player,
X      justboard;
X{
X  int i, j, k;
X
X  if (winopen[player])
X  {
X    if (enable_hex)
X      XFillRectangle(xwindow[player]->display, xwindow[player]->window, xwindow[player]->hue[dark],
X                  0, 0, (boardsizex-1)*3*hex_halfside + 2*hex_side, boardsizey*2*hex_vert + hex_vert);
X
X    /**** paint the pieces ****/
X    for (i=0; i<boardsizex; i++)
X    {
X      for (j=0; j<boardsizey; j++)
X      {
X        if (enable_hex)
X	  blanksquare(xwindow[player],SQUARE(board,i,j),colorarray[player],
X                                         squaresize[colorarray[player]], TRUE);
X
X        if (visible(board,colorarray[player],i,j))
X	  drawsquare(xwindow[player],SQUARE(board,i,j),colorarray[player],
X                                         squaresize[colorarray[player]]);
X        else
X          drawblank(xwindow[player], i, j, SQUARE(board,i,j)->value[none],
X                          SQUARE(board,i,j)->seen[colorarray[player]],
X                          SQUARE(board,i,j)->growth, colorarray[player],
X                          squaresize[colorarray[player]], SQUARE(board,i,j));
X
X        if (enable_storage && player == 0)
X          storedrawsquare(SQUARE(board,i,j), squaresize[0], TRUE);
X      }
X    }
X  }
X
X  /**** write the text ****/
X
X  if (!justboard)
X  {
X    for (i=0; i<nplayers; i++)
X    {
X      XDrawImageString(xwindow[i]->display,xwindow[i]->window,
X		       xwindow[i]->hue[0],
X		       TEXTX,textyh[colorarray[i]][colorarray[i]],
X		       blankline,strlen(blankline));
X      XDrawImageString(xwindow[i]->display,xwindow[i]->window,
X		       xwindow[i]->hue[0],
X		       TEXTX,textyh[colorarray[i]][colorarray[i]],
X		       messagestr,strlen(messagestr));
X    }
X  }
X}
X
X
X/*************************************************************************/
X/**	blanksquare						  	**/
X/** Draw blank hexagon							**/ 
X/**	Greg Lesher (lesher@cns.bu.edu)					**/
X/*************************************************************************/
Xblanksquare (xwindow, square, windowcolor, squaresize, flag)
X  xwindow_type *xwindow;
X  square_type *square;
X  int windowcolor,
X      squaresize,
X      flag;
X{
X  int  xpos, ypos;
X
X  xpos = square->xpos;
X  ypos = square->ypos;
X
X  hex_points[0].x = xpos - hex_halfside;
X  hex_points[0].y = ypos - hex_vert; 
X
X  if (flag)
X    XFillPolygon(xwindow->display,xwindow->window,xwindow->hue[none],
X                               hex_points, 6, Convex, CoordModePrevious);
X  if (enable_grid[windowcolor])
X    XDrawLines(xwindow->display,xwindow->window,xwindow->hue[dark], hex_points, 7, CoordModePrevious);
X}
X
X
X/*************************************************************************/
X/**	drawmarch						  	**/
X/** Draw passive march markers						**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xdrawmarch(board)
X  square_type *board;
X{
X  int x, y, k;
X
X  for (x=0; x<boardsizex; x++)
X  {
X    for (y=0; y<boardsizey; y++)
X    {
X      if (SQUARE(board,x,y)->anymarch == ACTIVE)
X        drawmarcharrows (SQUARE(board,x,y),SQUARE(board,x,y)->marchcolor,ACTIVE);
X      else
X      {
X        for (k=0; k<nsides; k++)
X        {
X          if (SQUARE(board,x,y)->march[k] == PASSIVE)
X            if (SQUARE(board,x,y)->color == none)
X            {
X              drawmarcharrows(SQUARE(board,x,y),k,PASSIVE);
X            }
X            else if (!visible(board,k,x,y))
X              drawmarcharrows(SQUARE(board,x,y),k,PASSIVE);
X        }
X      }
X    }
X  }
X}
X
X
X/*************************************************************************/
X/**	drawmarcharrows						  	**/
X/** Draw passive march markers						**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xdrawmarcharrows (square,marchcolor,type)
X  square_type *square;
X  int marchcolor,
X      type;
X{
X  int k,
X      xpos, ypos,
X      hafsquare;
X
X  if (enable_hex)
X  {
X    xpos = square->xpos;
X    ypos = square->ypos;
X
X    for (k=0; k<nplayers; k++)
X    {
X      if (colorarray[k] == marchcolor)
X      {
X        if(square->marchdir[marchcolor][HEX_UP])
X        {
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+2, ypos, xpos+2, ypos-hex_vert+2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+3, ypos, xpos+3, ypos-hex_vert+2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-2, ypos, xpos-2, ypos-hex_vert+2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-3, ypos, xpos-3, ypos-hex_vert+2);
X        }
X        if(square->marchdir[marchcolor][HEX_DOWN])
X        {
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+2, ypos, xpos+2, ypos+hex_vert-2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+3, ypos, xpos+3, ypos+hex_vert-2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-2, ypos, xpos-2, ypos+hex_vert-2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-3, ypos, xpos-3, ypos+hex_vert-2);
X        }
X        if(square->marchdir[marchcolor][HEX_RIGHT_UP])
X        {
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-2, ypos-2, xpos+hex_3quarterside-2, ypos-hex_halfvert-2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-3, ypos-3, xpos+hex_3quarterside-3, ypos-hex_halfvert-3);
X
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+2, ypos+2, xpos+hex_3quarterside+2, ypos-hex_halfvert+2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+3, ypos+3, xpos+hex_3quarterside+3, ypos-hex_halfvert+3);
X        }
X        if(square->marchdir[marchcolor][HEX_RIGHT_DOWN])
X        {
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+2, ypos-2, xpos+hex_3quarterside+2, ypos+hex_halfvert-2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+3, ypos-3, xpos+hex_3quarterside+3, ypos+hex_halfvert-3);
X
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-2, ypos+2, xpos+hex_3quarterside-2, ypos+hex_halfvert+2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-3, ypos+3, xpos+hex_3quarterside-3, ypos+hex_halfvert+3);
X        }
X        if(square->marchdir[marchcolor][HEX_LEFT_UP])
X        {
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+2, ypos-2, xpos-hex_3quarterside+2, ypos-hex_halfvert-2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+3, ypos-3, xpos-hex_3quarterside+3, ypos-hex_halfvert-3);
X
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-2, ypos+2, xpos-hex_3quarterside-2, ypos-hex_halfvert+2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-3, ypos+3, xpos-hex_3quarterside-3, ypos-hex_halfvert+3);
X        }
X        if(square->marchdir[marchcolor][HEX_LEFT_DOWN])
X        {
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-2, ypos-2, xpos-hex_3quarterside-2, ypos+hex_halfvert-2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-3, ypos-3, xpos-hex_3quarterside-3, ypos+hex_halfvert-3);
X
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+2, ypos+2, xpos-hex_3quarterside+2, ypos+hex_halfvert+2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+3, ypos+3, xpos-hex_3quarterside+3, ypos+hex_halfvert+3);
X        }
X  
X        if (type == PASSIVE)
X          XDrawRectangle(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X              xpos-DSIZE, ypos-DSIZE, 2*DSIZE, 2*DSIZE);
X      }
X    }
X  }
X  else
X  {
X    hafsquare=squaresize[marchcolor]/2;
X    xpos = square->x*squaresize[marchcolor]+hafsquare;
X    ypos = square->y*squaresize[marchcolor]+hafsquare;
X
X    for (k=0; k<nplayers; k++)
X    {
X      if (colorarray[k] == marchcolor)
X      {
X        if(square->marchdir[marchcolor][UP])
X        {
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+2, ypos, xpos+2, ypos-hafsquare);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+3, ypos, xpos+3, ypos-hafsquare);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-2, ypos, xpos-2, ypos-hafsquare);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-3, ypos, xpos-3, ypos-hafsquare);
X        }
X        if(square->marchdir[marchcolor][DOWN])
X        {
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+2, ypos, xpos+2, ypos+hafsquare-1);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos+3, ypos, xpos+3, ypos+hafsquare-1);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-2, ypos, xpos-2, ypos+hafsquare-1);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos-3, ypos, xpos-3, ypos+hafsquare-1);
X        }
X        if(square->marchdir[marchcolor][RIGHT])
X        {
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos, ypos+2, xpos+hafsquare-1, ypos+2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos, ypos+3, xpos+hafsquare-1, ypos+3);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos, ypos-2, xpos+hafsquare-1, ypos-2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos, ypos-3, xpos+hafsquare-1, ypos-3);
X        }
X        if(square->marchdir[marchcolor][LEFT])
X        {
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos, ypos+2, xpos-hafsquare, ypos+2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos, ypos+3, xpos-hafsquare, ypos+3);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos, ypos-2, xpos-hafsquare, ypos-2);
X          XDrawLine(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X            xpos, ypos-3, xpos-hafsquare, ypos-3);
X        }
X  
X        if (type == PASSIVE)
X          XDrawRectangle(xwindow[k]->display,xwindow[k]->window,xwindow[k]->hue[marchcolor],
X              xpos-DSIZE, ypos-DSIZE, 2*DSIZE, 2*DSIZE);
X      }
X    }
X  }
X}
X
X
X/*************************************************************************/
X/**	drawsquare						  	**/
X/** Draw one square of the game board					**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xdrawsquare(xwindow,square,windowcolor,squaresize)
X  xwindow_type *xwindow;
X  square_type *square;
X  int windowcolor,
X      squaresize;
X{
X  int i, j, k,
X      offset,
X      ipos, jpos,
X      hafsquare, psize, bsize, hafpsize, psize1, hafpsize1,
X      value,
X      terrain_type,
X      max, smax, max_pos, smax_pos,
X      csize,hafc;
X  static GC onhue, offhue;
X
X  hafsquare=squaresize/2;
X
X  /**** get square coordinates ****/
X  i = square->x;
X  j = square->y;
X
X  if (enable_hex)
X  {
X    ipos = square->xpos;
X    jpos = square->ypos;
X  }
X  else
X  {
X    ipos = i*squaresize;
X    jpos = j*squaresize;
X  }
X
X  /**** set drawing color & value ****/
X
X  if (square->color == none || square->color == FIGHT)
X    value=0;
X  else
X  {
X    onhue = xwindow->hue[square->color];
X    if ((xwindow->depth==1 && color2bw[sidemap[square->color]]<=GRAY3) ||
X        (xwindow->depth==8 && sidemap[square->color]==BLACK))
X      offhue = xwindow->hue[light];
X    else
X      offhue = xwindow->hue[dark];
X    value = square->value[square->color];
X  }
X
X  if (square->color == none)
X  {
X    onhue = xwindow->hue[none];
X    offhue = xwindow->hue[dark];
X    value = 0;
X  }
X  
X  /**** compute piece size ****/
X
X  if (enable_hex)
X    bsize = 11*hex_vert/6;
X  else
X    bsize = squaresize;
X  psize = (int)(bsize * areavalue[value]);
X  hafpsize = psize/2;
X
X  /**** clear with appropriately colored square ****/
X
X  if (enable_terrain)
X  {
X    terrain_type = square->value[none];
X
X    if (enable_hex)
X    {
X      offset = -2 * square->value[none];
X
X      if (terrain_type < 0)
X      {
X        double_copy (xwindow, square, windowcolor, squaresize, terrain_type, 0);
X        terrain_type = 0;
X      }
X      else
X        offset = 0;
X
X      if (terrain_type == 1 && !enable_hills && !enable_forest)
X        XFillArc (xwindow->display,xwindow->window, xwindow->hue[none],
X	       ipos-(hex_vert-1), jpos-(hex_vert-1), 2*(hex_vert-1), 2*(hex_vert-1), 0, 23040);
X      else
X        double_copy (xwindow, square, windowcolor, squaresize, terrain_type, offset);
X    }
X    else
X    {
X      offset = ((double)(-terrain_type) * squaresize)/(2*fillnumber);
X
X      if (terrain_type < 0)
X        terrain_type = 0;
X      else
X        offset = 0;
X
X      if (offset != 0)
X        XCopyArea (xwindow->display, xwindow->terrain[1], xwindow->window,
X                    xwindow->hue[dark], 0, 0, squaresize, squaresize, i*squaresize, j*squaresize);
X
X      XCopyArea (xwindow->display, xwindow->terrain[terrain_type], xwindow->window,
X                          xwindow->hue[dark], 0, 0, squaresize-2*offset, squaresize-2*offset,
X                          i*squaresize+offset, j*squaresize+offset);
X    }
X  }
X  else
X  {
X    if (enable_hex)
X    {
X      XFillArc (xwindow->display,xwindow->window, xwindow->hue[none],
X	       ipos-(hex_vert-1), jpos-(hex_vert-1), 2*(hex_vert-1), 2*(hex_vert-1), 0, 23040);
X
X/**
X      blanksquare(xwindow, square, windowcolor, squaresize, TRUE);
X**/
X    }
X    else
X      XFillRectangle(xwindow->display,xwindow->window, xwindow->hue[none],
X		   i*squaresize,j*squaresize, squaresize, squaresize);
X  }
X
X  if (!enable_hex && enable_grid[windowcolor])
X  {
X     XDrawLine(xwindow->display,xwindow->window,xwindow->hue[dark],
X	       ipos, jpos, ipos+squaresize, jpos);
X     XDrawLine(xwindow->display,xwindow->window,xwindow->hue[dark],
X	       ipos, jpos, ipos, jpos+squaresize);
X  }
X
X  
X  /**** singularly occupied square ****/
X  if (square->color != none && square->color != FIGHT)
X  {
X
X    /**** draw center marker ****/
X    if (enable_hex)
X    {
X      XFillArc (xwindow->display,xwindow->window, onhue,
X                          ipos-hafpsize, jpos-hafpsize, psize, psize, 0, 23040);
X 
X      if (xwindow->drawletter[square->color])
X        XDrawString(xwindow->display,xwindow->window, xwindow->flip,
X                     ipos-xwindow->charwidth/2, jpos+xwindow->charheight/2,
X                     xwindow->letter[square->color], 1);
X    }
X    else
X    {
X      if (!xwindow->drawletter[square->color] && !enable_grid[windowcolor])
X          XDrawRectangle(xwindow->display,xwindow->window,xwindow->hue[dark],
X		   ipos+hafsquare-CSIZE, jpos+hafsquare-CSIZE, 2*CSIZE, 2*CSIZE);
X
X      XFillRectangle(xwindow->display,xwindow->window,onhue,
X		   ipos+hafsquare-hafpsize, jpos+hafsquare-hafpsize, psize, psize);
X
X      if (xwindow->drawletter[square->color])
X        XDrawString(xwindow->display,xwindow->window, xwindow->flip,
X                   ipos+squaresize/2-xwindow->charwidth/2, jpos+squaresize/2+xwindow->charheight/2,
X                   xwindow->letter[square->color], 1);
X    }
X
X    /**** draw arrows ****/
X    if (enable_hidden[windowcolor])
X    {
X      if (square->color == windowcolor)
X      {
X#if SHOWFLOW
X        if (value == 0)
X          drawarrows(xwindow,square,onhue,offhue,i,j,hafpsize,squaresize,TRUE);
X        else
X          drawarrows(xwindow,square,onhue,offhue,i,j,hafpsize,squaresize,FALSE);
X#else
X        drawarrows(xwindow,square,onhue,offhue,i,j,hafpsize,squaresize,FALSE);
X#endif
X      }
X    }
X    else
X    {
X#if SHOWFLOW
X      if (value == 0)
X        drawarrows(xwindow,square,onhue,offhue,i,j,hafpsize,squaresize,TRUE);
X      else
X        drawarrows(xwindow,square,onhue,offhue,i,j,hafpsize,squaresize,FALSE);
X#else
X      drawarrows(xwindow,square,onhue,offhue,i,j,hafpsize,squaresize,FALSE);
X#endif
X    }
X  }
X  else if(square->color == FIGHT)       /**** draw fight square ****/
X  {
X    /**** find two largest components of square ****/
X    max = -1;
X    smax = -1; 
X    max_pos = 0;
X    for (k=0;k<nsides;k++)
X    {
X      if (square->value[k] > max)
X      {
X        smax = max; 
X        smax_pos = max_pos;
X        max = square->value[k];
X        max_pos = k;
X      }
X      else if (square->value[k] > smax)
X      {
X        smax = square->value[k];
X        smax_pos = k;
X      }
X    }
X    onhue = xwindow->hue[max_pos];
X    offhue = xwindow->hue[smax_pos];
X    psize = (int)(bsize * areavalue[square->value[max_pos]]);
X    hafpsize = psize/2;
X    psize1 = (int)(bsize * areavalue[square->value[smax_pos]]);
X    hafpsize1 = psize1/2;
X
X    if (enable_hex)
X    {
X      XFillArc (xwindow->display,xwindow->window, onhue,
X	       ipos-hafpsize, jpos-hafpsize, psize, psize, 0, 23040);
X      XFillArc (xwindow->display,xwindow->window, offhue,
X	       ipos-hafpsize1, jpos-hafpsize1, psize1, psize1, 0, 23040);
X
X      XDrawLine(xwindow->display, xwindow->window, onhue, ipos - hex_halfside, jpos - hex_halfvert,
X                  ipos + hex_halfside, jpos + hex_halfvert);
X      XDrawLine(xwindow->display, xwindow->window, onhue, ipos - hex_halfside, jpos + hex_halfvert,
X                  ipos + hex_halfside, jpos - hex_halfvert);
X    }
X    else
X    {
X      XFillRectangle(xwindow->display,xwindow->window,onhue,
X		     ipos+hafsquare-hafpsize, jpos+hafsquare-hafpsize, psize, psize);
X      XFillRectangle(xwindow->display,xwindow->window,offhue,
X		     ipos+hafsquare-hafpsize1, jpos+hafsquare-hafpsize1, psize1, psize1);
X
X      /**** draw battle cross ****/
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos+2,jpos+2, ipos+squaresize-2,jpos+squaresize-2);
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos+squaresize-2,jpos+2, ipos+2,jpos+squaresize-2);
X    }
X  }
X
X  /**** draw circle for town or base ****/
X  if(square->angle > 0)
X  {
X
X    if (enable_hex)
X    {
X      if (square->angle < 23040)
X        csize = ((square->oldgrowth - 52)*7*hex_vert)/200;
X      else
X        csize = ((square->growth - 52)*7*hex_vert)/200;
X
X      hafc = csize/2;
X
X      XDrawArc(xwindow->display,xwindow->window,offhue,
X	       ipos-hafc, jpos-hafc, csize, csize, 0, square->angle);
X
X      XDrawArc(xwindow->display,xwindow->window,offhue,
X	       ipos-hafc + 1, jpos-hafc + 1, csize - 2, csize - 2, 0, square->angle);
X    }
X    else
X    {
X      if (square->angle < 23040)
X        csize = ((square->oldgrowth - 52)*squaresize)/50;
X      else
X        csize = ((square->growth - 52)*squaresize)/50;
X
X      hafc = (squaresize - csize)/2;
X
X      XDrawArc(xwindow->display,xwindow->window,offhue,
X               ipos+hafc, jpos+hafc, csize, csize, 0, square->angle);
X
X      XDrawArc(xwindow->display,xwindow->window,offhue,
X               ipos+hafc + 1, jpos+hafc + 1, csize - 2, csize - 2, 0, square->angle);
X    }
X  }
X}
X
X
X/*************************************************************************/
X/**	double_copy						  	**/
X/** do flickerless pixmap copy for hexagonal board			**/ 
X/**	Greg Lesher (lesher@cns.bu.edu)					**/
X/*************************************************************************/
Xdouble_copy (xwindow, square, windowcolor, squaresize, terrain_type, offset)
X  xwindow_type *xwindow;
X  square_type *square;
X  int windowcolor,
X      squaresize,
X      terrain_type,
X      offset;
X{
X  if (terrain_type < 0)
X  {
X    if (enable_hills || enable_forest)
X    {
X      double_copy (xwindow, square, windowcolor, squaresize, 1, 0);
X      if (enable_grid[windowcolor])
X        blanksquare(xwindow, square, windowcolor, squaresize, FALSE);
X    }
X    else
X      blanksquare(xwindow, square, windowcolor, squaresize, TRUE);
X    return;
X  }
X
X  XCopyArea (xwindow->display, xwindow->window, xwindow->terrain[terrain_type], xwindow->hue[light],
X                     square->xpos - hex_side, square->ypos - hex_vert, 2*hex_side, 2*hex_vert,
X                     0, 4*hex_vert);
X
X  XCopyArea (xwindow->display, xwindow->terrain[terrain_type], xwindow->terrain[terrain_type],
X                     xwindow->gc_clear, offset*hex_side, 2*hex_vert, 2*hex_side, 2*hex_vert,
X                     0, 4*hex_vert);
X
X  XCopyArea (xwindow->display, xwindow->terrain[terrain_type], xwindow->terrain[terrain_type],
X                     xwindow->gc_or, offset*hex_side, 0, 2*hex_side, 2*hex_vert,
X                     0, 4*hex_vert);
X
X  XCopyArea (xwindow->display, xwindow->terrain[terrain_type], xwindow->window, xwindow->hue[light],
X                     0, 4*hex_vert, 2*hex_side, 2*hex_vert, square->xpos - hex_side,
X                     square->ypos - hex_vert);
X
X  if (enable_grid[windowcolor])
X    blanksquare(xwindow, square, windowcolor, squaresize, FALSE);
X}
X
X
X/*************************************************************************/
X/**     drawarrows                                                      **/
X/**  Draws appropriate movement arrows					**/
X/**     Greg Lesher (lesher@park.bu.edu)                                **/
X/*************************************************************************/
Xdrawarrows(xwindow,square,onhue,offhue,i,j,hafpsize, squaresize, halfsize)
X  xwindow_type *xwindow;
X  square_type *square;
X  GC onhue, offhue;
X  int i, j,
X      hafpsize,
X      squaresize,
X      halfsize;
X{
X  int ipos, jpos,
X      vert, horiz, halfvert,
X      hafsquare;
X
X  if (enable_hex)
X  {
X    ipos = square->xpos;
X    jpos = square->ypos;
X
X    vert = hex_vert;
X    halfvert = hex_halfvert;
X    horiz = hex_3quarterside;
X
X    if (halfsize)
X    {
X      vert = vert/2;
X      halfvert = halfvert/2;
X      horiz = horiz/2;
X    }
X
X    /**** draw direction arrows ****/
X    if(square->dir[HEX_UP])
X    {
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos, jpos, ipos, jpos - vert + 2); 
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos+1, jpos, ipos+1, jpos - vert + 2); 
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos-1, jpos, ipos-1, jpos - vert + 2); 
X    }
X    if(square->dir[HEX_DOWN])
X    {
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos, jpos, ipos, jpos + vert - 2); 
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos+1, jpos, ipos+1, jpos + vert - 2); 
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos-1, jpos, ipos-1, jpos + vert - 2); 
X    }
X    if(square->dir[HEX_RIGHT_UP])
X    {
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos, jpos, ipos + horiz - 1,
X                                                jpos - halfvert + 1); 
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos+1, jpos, ipos+1 + horiz - 1,
X                                                jpos - halfvert + 1); 
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos, jpos-1, ipos+1 + horiz - 1,
X                                                jpos-1 - halfvert + 1); 
X    }
X    if(square->dir[HEX_RIGHT_DOWN])
X    {
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos, jpos, ipos + horiz - 1,
X                                                jpos + halfvert - 1); 
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos+1, jpos, ipos+1 + horiz - 1,
X                                                jpos + halfvert - 1); 
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos, jpos+1, ipos + horiz - 1,
X                                                jpos+1 + halfvert - 1); 
X    }    
X    if(square->dir[HEX_LEFT_UP])
X    {
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos, jpos, ipos - horiz + 1,
X                                                jpos - halfvert + 1); 
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos-1, jpos, ipos-1 - horiz + 1,
X                                                jpos - halfvert + 1); 
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos, jpos-1, ipos - horiz + 1,
X                                                jpos-1 - halfvert + 1); 
X    }
X    if(square->dir[HEX_LEFT_DOWN])
X    {
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos, jpos, ipos - horiz + 1,
X                                                jpos + halfvert - 1); 
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos-1, jpos, ipos-1 - horiz + 1,
X                                                jpos + halfvert - 1); 
X      XDrawLine(xwindow->display,xwindow->window,onhue, ipos, jpos+1, ipos - horiz + 1,
X                                                jpos+1 + halfvert - 1); 
X    }    
X  }
X  else
X  {
X    hafsquare=squaresize/2;
X
X    ipos = i*squaresize+hafsquare;
X    jpos = j*squaresize+hafsquare;
X
X    if (halfsize)
X      hafsquare /= 2;
X
X    /**** draw direction arrows ****/
X    if(square->dir[UP])
X    {
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos-1, jpos, ipos-1, jpos-hafsquare);
X#if INVERT
X      XDrawLine(xwindow->display,xwindow->window,offhue,
X                  ipos, jpos, ipos, jpos-hafpsize);
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos, jpos-hafpsize, ipos, jpos-hafsquare);
X#else
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos, jpos, ipos, jpos-hafsquare);
X#endif
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos+1, jpos, ipos+1, jpos-hafsquare);
X    }
X    if(square->dir[DOWN])
X    {
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos-1, jpos, ipos-1, jpos+hafsquare-1);
X#if INVERT
X      XDrawLine(xwindow->display,xwindow->window,offhue,
X                  ipos, jpos, ipos, jpos+hafpsize);
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos, jpos+hafpsize, ipos, jpos+hafsquare-1);
X#else
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos, jpos, ipos, jpos+hafsquare-1);
X#endif
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos+1, jpos, ipos+1, jpos+hafsquare-1);
X    }
X    if(square->dir[RIGHT])
X    {
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos, jpos-1, ipos+hafsquare-1, jpos-1);
X#if INVERT
X      XDrawLine(xwindow->display,xwindow->window,offhue,
X                  ipos, jpos, ipos+hafpsize, jpos);
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos+hafpsize, jpos, ipos+hafsquare-1, jpos);
X#else
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos, jpos, ipos+hafsquare-1, jpos);
X#endif
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos, jpos+1, ipos+hafsquare-1, jpos+1);
X    }
X    if(square->dir[LEFT])
X    {
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos, jpos-1, ipos-hafsquare, jpos-1);
X#if INVERT
X      XDrawLine(xwindow->display,xwindow->window,offhue,
X                  ipos, jpos, ipos-hafpsize, jpos);
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos-hafpsize, jpos, ipos-hafsquare, jpos);
X#else
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos, jpos, ipos-hafsquare, jpos);
X#endif
X      XDrawLine(xwindow->display,xwindow->window,onhue,
X                  ipos, jpos+1, ipos-hafsquare, jpos+1);
X    }
X  }
X}
X
X
X/*************************************************************************/
X/**     drawblank                                                       **/
X/**  Draws a blank square                                               **/
X/**     Mark Lauer (elric@cs.su.oz.au)                                  **/
X/**     Greg Lesher (lesher@park.bu.edu)                                **/
X/*************************************************************************/
Xdrawblank (xwindow, i, j, terrain_type, seen, growth, windowcolor, squaresize, square)
X  xwindow_type *xwindow;
X  int i, j,
X      terrain_type,
X      seen,
X      growth,
X      windowcolor,
X      squaresize;
X  square_type *square;
X{
X  int csize, hafc,
X      ipos, jpos,
X      offset;
X
X  if (enable_hex)
X  {
X    ipos = square->xpos;
X    jpos = square->ypos;
X  }
X  else
X  {
X    ipos = i*squaresize;
X    jpos = j*squaresize;
X  }
X
X  /**** clear with appropriately colored square ****/
X  if (enable_terrain)
X  {
X    if (seen && !enable_localmap[windowcolor])
X    {
X      if (enable_hex)
X      {
X        offset = -2 * square->value[none];
X
X        if (terrain_type < 0)
X        {
X          double_copy (xwindow, square, windowcolor, squaresize, terrain_type, 0);
X          terrain_type = 0;
X        }
X        else
X          offset = 0;
X
X        if (terrain_type == 1 && !enable_hills && !enable_forest)
X          XFillArc (xwindow->display,xwindow->window, xwindow->hue[none],
X	         ipos-(hex_vert-1), jpos-(hex_vert-1), 2*(hex_vert-1), 2*(hex_vert-1), 0, 23040);
X        else
X          double_copy (xwindow, square, windowcolor, squaresize, terrain_type, offset);
X      }
X      else
X      {
X        offset = ((double)(-terrain_type) * squaresize)/(2*fillnumber);
X
X        if (terrain_type < 0)
X          terrain_type = 0;
X        else
X          offset = 0;
X
X        if (offset != 0)
X          XCopyArea (xwindow->display, xwindow->terrain[1], xwindow->window,
X                      xwindow->hue[dark], 0, 0, squaresize, squaresize, ipos, jpos);
X  
X        XCopyArea (xwindow->display, xwindow->terrain[terrain_type], xwindow->window,
X                          xwindow->hue[dark], 0, 0, squaresize-2*offset, squaresize-2*offset,
X                          ipos+offset, jpos+offset);
X      }
X
X      if (enable_basemap[windowcolor] && growth > 50)
X      {
X        if (enable_hex)
X        {
X          csize = ((growth - 52)*7*hex_vert)/200;
X          hafc = csize/2;
X
X          XDrawArc(xwindow->display,xwindow->window,xwindow->hue[dark],
X	           ipos-hafc, jpos-hafc, csize, csize, 0, square->angle);
X 
X          XDrawArc(xwindow->display,xwindow->window,xwindow->hue[dark],
X	           ipos-hafc + 1, jpos-hafc + 1, csize - 2, csize - 2, 0, square->angle);
X        }
X        else
X        {
X          csize = ((growth - 52)*squaresize)/50;
X          hafc = (squaresize - csize)/2;
X          XDrawArc(xwindow->display,xwindow->window,xwindow->hue[dark],
X	           ipos+hafc, jpos+hafc, csize, csize, 0, 23040);
X
X          XDrawArc(xwindow->display,xwindow->window,xwindow->hue[dark],
X                   ipos+hafc + 1, jpos+hafc + 1, csize - 2, csize - 2, 0, 23040);
X        }
X      }
X    }
X    else
X    {
X      if (enable_hex)
X      {
X        /** Using double copy results in some aliasing due to fact that hue[none] is **/
X        /** usually drawn not copied and is a stipple.				     **/ 
X/**
X        double_copy (xwindow, square, windowcolor, squaresize, 1, 0);
X**/
X
X        blanksquare(xwindow, square, windowcolor, squaresize, TRUE);
X      }
X      else
X        XFillRectangle(xwindow->display,xwindow->window,
X                       xwindow->hue[none], ipos,jpos, squaresize, squaresize);
X    }
X  }
X  else
X  {
X     if (enable_hex) 
X     {
X        XFillArc (xwindow->display,xwindow->window, xwindow->hue[none],
X	       ipos-(hex_vert-1), jpos-(hex_vert-1), 2*(hex_vert-1), 2*(hex_vert-1), 0, 23040);
X/**
X        blanksquare(xwindow, square, windowcolor, squaresize, TRUE);
X**/
X     }
X     else
X       XFillRectangle(xwindow->display,xwindow->window,
X                     xwindow->hue[none],
X                     ipos,jpos, squaresize, squaresize);
X
X    if (enable_basemap[windowcolor])
X    {
X      if (growth > 50 && !enable_localmap[windowcolor] && seen)
X      {
X        if (enable_hex) 
X        {
X          csize = ((growth - 52)*7*hex_vert)/200;
X          hafc = csize/2;
X
X          XDrawArc(xwindow->display,xwindow->window,xwindow->hue[dark],
X	           ipos-hafc, jpos-hafc, csize, csize, 0, square->angle);
X 
X          XDrawArc(xwindow->display,xwindow->window,xwindow->hue[dark],
X	           ipos-hafc + 1, jpos-hafc + 1, csize - 2, csize - 2, 0, square->angle);
X        }
X        else
X        {
X          csize = ((growth - 52)*squaresize)/50;
X          hafc = (squaresize - csize)/2;
X
X          XDrawArc(xwindow->display,xwindow->window,xwindow->hue[dark],
X	         ipos+hafc, jpos+hafc, csize, csize, 0, 23040);
X
X          XDrawArc(xwindow->display,xwindow->window,xwindow->hue[dark],
X  	         ipos+hafc + 1, jpos+hafc + 1, csize - 2, csize - 2, 0, 23040);
X        }
X      }
X    }
X  }
X
X  if (!enable_hex && enable_grid[windowcolor])
X  {
X     XDrawLine(xwindow->display,xwindow->window,xwindow->hue[dark],
X	       ipos,jpos,
X	       ipos+squaresize,jpos);
X     XDrawLine(xwindow->display,xwindow->window,xwindow->hue[dark],
X	       ipos,jpos,
X	       ipos,jpos+squaresize);
X  }
X}
X
X
X/*************************************************************************/
X/**	storedrawsquare						  	**/
X/** Draw one square of the game board to a file				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xstoredrawsquare(square, squaresize, special_flag)
X  square_type *square;
X  int squaresize,
X      special_flag;
X{
X  int i, j, k,
X      bsize, csize, psize, psize1,
X      value,
X      max, smax, max_pos, smax_pos;
X
X  i = square->x;
X  j = square->y;
X
X  if (enable_hex)
X    bsize = 9*hex_vert/5;
X  else
X    bsize = squaresize;
X
X  if (enable_terrain)
X  {
X    if (enable_hex && special_flag)
X    {
X      if (!enable_hills && !enable_forest && square->value[none] == 1)
X        fprintf (fpout,"b%c%c",i,j);
X      else
X        fprintf (fpout,"A%c%c%c",i,j,square->value[none]);
X    }
X    else
X      fprintf (fpout,"A%c%c%c",i,j,square->value[none]);
X  }
X  else
X  {
X    if (enable_hex && special_flag)
X      fprintf (fpout,"b%c%c",i,j);
X    else
X      fprintf (fpout,"B%c%c",i,j);
X  }
X  
X  /**** singularly occupied square ****/
X  if (square->color != none && square->color != FIGHT)
X  {
X    storedrawarrows(square,i,j,square->color);
X
X    value = square->value[square->color];
X    if (value < 0)
X      value = 0;
X    psize = (int)(bsize * areavalue[value]);
X    
X    fprintf (fpout,"D%c%c%c%c",i,j,psize,square->color);
X  }
X  else if(square->color == FIGHT)
X  {
X    /**** find two largest components of square ****/
X    max = -1;
X    smax = -1; 
X    for (k=0;k<nsides;k++)
X    {
X      if (square->value[k] > max)
X      {
X        smax = max; 
X        smax_pos = max_pos;
X        max = square->value[k];
X        max_pos = k;
X      }
X      else if (square->value[k] > smax)
X      {
X        smax = square->value[k];
X        smax_pos = k;
X      }
X    }
X    psize = (int)(bsize * areavalue[square->value[max_pos]]);
X    psize1 = (int)(bsize * areavalue[square->value[smax_pos]]);
X
X    fprintf (fpout,"E%c%c%c%c%c%c",i,j,psize,max_pos,psize1,smax_pos);
X  }
X
X  /**** draw circle for town or base ****/
X  if(square->angle > 0)
X  {
X    if (enable_hex)
X    {
X      if (square->angle < 23040)
X        csize = ((square->oldgrowth - 52)*7*hex_vert)/200;
X      else
X        csize = ((square->growth - 52)*7*hex_vert)/200;
X    }
X    else
X    {
X      if (square->angle < 23040)
X        csize = ((square->oldgrowth - 52)*squaresize)/50;
X      else
X        csize = ((square->growth - 52)*squaresize)/50;
X    }
X
X    fprintf (fpout,"F%c%c%c%c",i,j,csize,(square->angle*255)/23040);
X  }
X}
X
X
X/*************************************************************************/
X/**     storedrawarrows                                                 **/
X/**  Draws appropriate movement arrows to file				**/
X/**     Greg Lesher (lesher@park.bu.edu)                                **/
X/*************************************************************************/
Xstoredrawarrows(square,i,j,colornumber)
X  square_type *square;
X  int i, j,
X      colornumber;
X{
X  if (enable_hex)
X  {
X    if(square->dir[HEX_UP])
X      fprintf (fpout,"G%c%c%cu",i,j,colornumber);
X
X    if(square->dir[HEX_DOWN])
X      fprintf (fpout,"G%c%c%cd",i,j,colornumber);
X
X    if(square->dir[HEX_RIGHT_UP])
X      fprintf (fpout,"G%c%c%cR",i,j,colornumber);
X
X    if(square->dir[HEX_RIGHT_DOWN])
X      fprintf (fpout,"G%c%c%cr",i,j,colornumber);
X
X    if(square->dir[HEX_LEFT_UP])
X      fprintf (fpout,"G%c%c%cL",i,j,colornumber);
X
X    if(square->dir[HEX_LEFT_DOWN])
X      fprintf (fpout,"G%c%c%cl",i,j,colornumber);
X  }
X  else
X  {
X    if(square->dir[UP])
X      fprintf (fpout,"G%c%c%cu",i,j,colornumber);
X
X    if(square->dir[DOWN])
X      fprintf (fpout,"G%c%c%cd",i,j,colornumber);
X
X    if(square->dir[RIGHT])
X      fprintf (fpout,"G%c%c%cr",i,j,colornumber);
X
X    if(square->dir[LEFT])
X      fprintf (fpout,"G%c%c%cl",i,j,colornumber);
X  }
X}
X
X
X/*************************************************************************/
X/**	print_message							**/
X/** Print the latest message to the screen.  The message is purposely	**/
X/** allowed to flash in order to attract attention.  Further attention	**/
X/** can be called by use of ^g to ring the bell.			**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xprint_message(text,textcount,newcolor,player,board)
X  char text[];
X  int textcount,
X      newcolor,
X      player;
X  square_type *board;
X{
X  int i,
X      scroll, scrollandprint;
X
X  static oldcolor=0,
X         veryfirst=TRUE,
X         firsttime[MAXSIDES];
X
X  char oldmessage[512],
X       line[100];
X
X  if (veryfirst)
X  {
X    for (i=0; i<MAXSIDES; i++)
X      firsttime[i] = TRUE;
X    veryfirst = FALSE;
X  }
X
X  scroll = FALSE;
X  scrollandprint = FALSE;
X
X#if !MULTITEXT
X  /**** copy old message ****/
X  strcpy (oldmessage,messagestr);
X  if (newcolor != oldcolor)
X    strcpy(messagestr,"");
X#endif
X
X  /**** remove control, shift & meta ****/
X  if (textcount==0)
X    return;
X
X  text[textcount] = 0;
X
X  if (firsttime[newcolor])
X  {
X    strcpy(personal_messagestr[newcolor], "");
X    firsttime[newcolor] = FALSE;
X  }
X  
X  switch (text[0])
X  {
X    /**** backspace ****/
X    case BACKSPACE:
X    case DELETE:
X#if MULTITEXT
X      if (strlen(personal_messagestr[newcolor]) > 0)
X        personal_messagestr[newcolor][(strlen(personal_messagestr[newcolor]))-1] =
X                                                  messagestr[(strlen(personal_messagestr[newcolor]))];
X#else
X      if (strlen(messagestr) > 0)
X        messagestr[(strlen(messagestr))-1] = messagestr[(strlen(messagestr))];
X#endif
X      break;
X
X    /**** newline ****/
X    case RETURN:
X#if MULTITEXT
X      strcpy(personal_messagestr[newcolor],"");
X#else
X      scroll = TRUE;
X#endif
X      break;
X    
X    case CTRLC:
X    case CTRLQ:
X      firsttime[newcolor] = TRUE;
X      removeplayer (player, board);
X      break;
X
X    case CTRLP:
X      gamestats (board);
X      dump_board (board, "xbattle.xbt");
X      break;
X
X    case CTRLW:
X      winwatch[player] = TRUE;
X      enable_personalhorizon[colorarray[player]] = FALSE;
X      drawboard (board, player, TRUE);
X      firsttime[newcolor] = TRUE;
X      sprintf (line, "%s has quit the game", huename[sidemap[colorarray[player]]]);
X      print_message(line,strlen(line),colorarray[player],player,board);
X      for (i=0; i<nplayers; i++)
X        if (winopen[i]) XBell(xwindow[i]->display,100);
X      break;
X
X    case CTRLG:
X      for (i=0; i<nplayers; i++)
X        if (winopen[i])
X          XBell(xwindow[i]->display,100);
X      break;
X
X    case SPACE:
X#if MULTITEXT
X      if ((strlen(personal_messagestr[newcolor]) + 1) > 511)
X      {
X        scroll = TRUE;
X      }
X      else
X        strcat(personal_messagestr[newcolor]," ");
X#else
X      if ((strlen(messagestr) + 1) > 511)
X      {
X        scroll = TRUE;
X      }
X      else
X        strcat(messagestr," ");
X#endif
X
X      break;
X
X    default:
X#if MULTITEXT
X      if ((strlen(personal_messagestr[newcolor]) + strlen(text)) > 511)
X      {
X        scroll = TRUE;
X      }
X      else
X        strcat(personal_messagestr[newcolor],text);
X#else
X      if ((strlen(messagestr) + strlen(text)) > 511)
X      {
X        scroll = TRUE;
X      }
X      else
X        strcat(messagestr,text);
X#endif
X
X      break;
X  }
X
X#if !MULTITEXT
X  if (newcolor != oldcolor)
X    scrollandprint = TRUE;
X#endif
X
X  /**** print the string on all xwindows ****/
X  for (i=0; i<nplayers; i++)
X  {
X    if (!winopen[i])
X      continue;
X#if !MULTITEXT
X    /**** scroll bottom text line up ****/
X    if (scroll || scrollandprint)
X    {
X      XDrawImageString(xwindow[i]->display,xwindow[i]->window,
X		       xwindow[i]->hue[oldcolor],
X		       TEXTX,textyh[colorarray[i]][newcolor],
X		       blankline,strlen(blankline));
X      XDrawImageString(xwindow[i]->display,xwindow[i]->window,
X		       xwindow[i]->hue[oldcolor],
X		       TEXTX,textyh[colorarray[i]][newcolor],
X		       oldmessage,strlen(oldmessage));
X      XDrawImageString(xwindow[i]->display,xwindow[i]->window,
X		       xwindow[i]->hue[newcolor],
X		       TEXTX,textyl[colorarray[i]][newcolor],
X		       blankline,strlen(blankline));
X    }
X
X    /**** print new text line ****/
X    if (scrollandprint || !scroll)
X    {
X      XDrawImageString(xwindow[i]->display,xwindow[i]->window,
X		       xwindow[i]->hue[newcolor],
X		       TEXTX,textyl[colorarray[i]][newcolor],
X		       blankline,strlen(blankline));
X      XDrawImageString(xwindow[i]->display,xwindow[i]->window,
X		       xwindow[i]->hue[newcolor],
X		       TEXTX,textyl[colorarray[i]][newcolor],
X		       messagestr,strlen(messagestr));
X    }
X#else
X    /**** print new text line ****/
X    if (scrollandprint || !scroll)
X    {
X      XDrawImageString(xwindow[i]->display,xwindow[i]->window,
X		       xwindow[i]->hue[newcolor],
X		       TEXTX,textyh[colorarray[i]][newcolor],
X		       blankline,strlen(blankline));
X      XDrawImageString(xwindow[i]->display,xwindow[i]->window,
X		       xwindow[i]->hue[newcolor],
X		       TEXTX,textyh[colorarray[i]][newcolor],
X		       personal_messagestr[newcolor],strlen(personal_messagestr[newcolor]));
X    }
X#endif
X  }
X
X#if !MULTITEXT
X  if (scrollandprint || !scroll)
X    oldcolor=newcolor;
X#endif
X
X  if (scroll)
X    strcpy(messagestr,"");
X}
END_OF_FILE
if test 43247 -ne `wc -c <'draw.c'`; then
    echo shar: \"'draw.c'\" unpacked with wrong size!
fi
# end of 'draw.c'
fi
if test -f 'extern.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extern.h'\"
else
echo shar: Extracting \"'extern.h'\" \(7347 characters\)
sed "s/^X//" >'extern.h' <<'END_OF_FILE'
X/**** game static parameters ****/
X
X#define BOARDSIZE 	15
X#define SQUARESIZE 	45
X#define MAXBOARDSIZE 	50
X#define MAXSQUARESIZE 	75
X#define TEXTSIZE 	16
X#define CSIZE 		5
X#define DSIZE 		7
X#define TEXTX 		0
X#define NGREYTONES 	3
X#define NHILLTONES 	5
X#define NFORESTTONES 	5
X#define NSEATONES 	2
X#define SEAVALUE	0.87840
X#define MAXPLAYERS 	11
X#define MAXSIDES   	11
X#define MAXHUES   	11
X
X#define NOPTS		49
X#define POPTS		26
X#define PVOPTS		6
X
X#define SET		0
X#define FORCE		1
X
X#define ACTIVE		1
X#define PASSIVE		2
X#define TEMP		3
X
X/**** game dynamic parameters ****/
X#define MAXVAL 		20
X#define FIREPOWER	5.0
X#define SLOWFACTOR  	3.0
X#define SHELL		1
X#define SHELL_COST	1
X#define PARA		1
X#define PARA_COST	3
X#define VIEWRANGE  	2
X#define BASERANGE	2
X#define MARCH		3
X#define ERODETHRESH	0.04
X
X#define SQ3D2		0.8660254
X
X/**** x window default parameters ****/
X#define FONT  		"-adobe-courier-bold-r-normal--*-100-*-*-*-*-iso8859-1"
X#define BORDER 		1
X#define XPOS		0
X#define YPOS		0
X
X/**** necessary constants ****/
X#define MAXCOLORS  	MAXSIDES+NHILLTONES+3
X#define ALL		MAXHUES+2
X#define TRUE	   	1
X#define FALSE	   	0
X#define OK		-1
X#define GLOBAL		MAXSIDES+2
X#define NOT_TAKEN	-1
X
X/**** COMPILE TIME OPTIONS ****/
X
X#define UNIX		TRUE
X#define INVERT		TRUE
X#define PAUSE		TRUE
X#define VARMOUSE	FALSE
X#define NODRAND48	FALSE
X#define SHOWFLOW	TRUE
X#define MULTITEXT	TRUE
X#define NEWCOLORMAP	FALSE
X#define MULTIFLUSH	FALSE
X
X/**** special flags ****/
X#define DIRS   		6
X
X#define HEX_UP  	0
X#define HEX_RIGHT_UP 	1
X#define HEX_RIGHT_DOWN 	2
X#define HEX_DOWN	3
X#define HEX_LEFT_DOWN 	4
X#define HEX_LEFT_UP 	5
X
X#define UP  		0
X#define DOWN	  	2
X#define RIGHT 		1
X#define LEFT  		3
X
X/**
X#define UP  		0
X#define DOWN	  	2
X#define RIGHT 		1
X#define LEFT  		3
X**/
X
X/**** board square access routine ****/
X#define SQUARE(board,x,y) ((board)+(y)*boardsizex+(x))
X
X
X/**** window structure ****/
Xtypedef struct{
X    Display 		*display;
X    Window 		window;
X    int			xsize,ysize;
X    XSizeHints 		hint;
X    XWMHints 		xwmh;
X    int 		depth,screen;
X    GC 			hue[MAXSIDES+3], flip, gc_clear, gc_or;
X    Pixmap		terrain[NHILLTONES];
X    XFontStruct 	*font_struct;
X    Colormap 		cmap;
X    XColor 		xcolor[MAXCOLORS];
X    char		drawletter[MAXSIDES+1];
X    char		letter[MAXSIDES+1][2];
X    unsigned long	charwidth, charheight;
X} xwindow_type;
X
X/**** game square structure ****/
Xtypedef struct SquareType {
X    char 		color;
X    char 		move,dir[DIRS];
X    char		anymarch, marchcolor, marchcount;
X    char		march[MAXSIDES],marchdir[MAXSIDES][DIRS],marchtype[MAXSIDES];
X    short 		value[MAXHUES+3];
X    short		lowbound;
X    char 		growth;
X    char 		oldgrowth;
X    char	 	oldcolor;
X    char		age;
X    char 		x, y;
X    int			xpos, ypos;
X    struct SquareType	*connect[DIRS];
X    char		seen[MAXSIDES];
X    int			angle;
X} square_type;
X
X/**** square colors ****/
X#define NONE  		0
X#define BLACK 		1
X#define GRAY3 		2
X#define GRAY2 		3
X#define GRAY1 		4
X#define WHITE 		5
X#define RED		6
X#define CYAN		7
X#define MAGENTA		8
X#define GREEN		9
X#define BLUE		10
X#define YELLOW		11
X#define FIGHT  		MAXHUES+1
X
X/**** wraparound routine ****/
X#define MODX(x)  (x+boardsizex)%boardsizex
X#define MODY(y)  (y+boardsizey)%boardsizey
X
X/**** ascii codes ****/
X#define RETURN 13
X#define BACKSPACE 8
X#define DELETE 127
X#define CTRLC 03
X#define CTRLQ 17
X#define CTRLG 07
X#define CTRLW 23
X#define SPACE 32
X#define CTRLF 6
X#define CTRLD 4
X#define CTRLS 19
X#define CTRLB 2
X#define CTRLP 16
X
X/**** global variables ****/
Xextern xwindow_type *xwindow[MAXPLAYERS];
X
Xextern int colorarray[MAXPLAYERS],
X           rcolorarray[MAXHUES],
X           sidemap[MAXPLAYERS];
X 
Xextern char lettermap[MAXSIDES][2];
X
Xextern int winopen[MAXPLAYERS],
X           winwatch[MAXPLAYERS];
X
Xextern FILE *fpout, *fopen();
Xextern char filename[50];
X
X/**** default mappings from color to b/w ****/
Xextern int color2bw[MAXHUES+1];
X
Xextern double 	towns,
X		sea,
X		gamespeed,
X 		farms;
X
Xextern double	slowfactor[MAXSIDES],
X		artillery[MAXSIDES],
X		paratroops[MAXSIDES],
X		firepower[MAXSIDES],
X		militia[MAXSIDES],
X		hillfactor[MAXSIDES],
X		forest[MAXSIDES],
X		areavalue[MAXVAL+5],
X		decayrate[MAXSIDES],
X		eroderate[MAXSIDES],
X                shuntval[MAXSIDES];
X
Xextern int	delay,
X		boardsizex,
X		boardsizey,
X		paused,
X		seed;
X
Xextern int 	nplayers,
X		nsides,	
X		none,
X		dark,
X		light,	
X		maxviewrange,
X		fillcost,
X		digcost,
X		fillnumber,
X		directions,
X                oldx[MAXPLAYERS],
X                oldy[MAXPLAYERS],
X                dir[MAXPLAYERS][DIRS],
X                dirtype[MAXPLAYERS];
X
Xextern int	armies[MAXSIDES],
X		bases[MAXSIDES],
X		rbases[MAXSIDES],
X		buildrate[MAXSIDES],
X		scuttlerate[MAXSIDES],
X		marchrate[MAXSIDES],
X		viewrange[MAXSIDES],
X		squaresize[MAXSIDES],
X       		textyh[MAXSIDES][MAXSIDES],
X                textyl[MAXSIDES][MAXSIDES];
X
Xextern int 	enable_anywrap,
X                enable_horizon,
X                enable_march,
X                enable_bound,
X	        enable_hills,
X	        enable_forest,
X	        enable_sea,
X	        enable_hex,
X	        enable_border,
X	        enable_terrain,
X		enable_decay,
X		enable_anylocalmap,
X                enable_storage,
X                enable_replay,
X                enable_area,
X                enable_edit,
X                enable_load,
X		enable_farms,
X		enable_towns,
X		enable_rbases,
X		enable_bases,
X		enable_militia,
X		enable_armies;
X
Xextern int 	enable_fill[MAXSIDES],
X	        enable_dig[MAXSIDES],
X	        enable_scuttle[MAXSIDES],
X	        enable_build[MAXSIDES],
X	        enable_artillery[MAXSIDES],
X	        enable_paratroops[MAXSIDES],
X                enable_personalmarch[MAXSIDES],
X                enable_grid[MAXSIDES],
X                enable_manpos[MAXSIDES],
X                enable_wrap[MAXSIDES],
X                enable_personalhorizon[MAXSIDES],
X                enable_personalbound[MAXSIDES],
X                enable_erode[MAXSIDES],
X                enable_repeat[MAXSIDES],
X                enable_map[MAXSIDES],
X                enable_basemap[MAXSIDES],
X                enable_localmap[MAXSIDES],
X	        enable_hidden[MAXSIDES],
X	        enable_attack[MAXSIDES],
X	        enable_nospigot[MAXSIDES],
X                enable_disrupt[MAXSIDES],
X		enable_reserve[MAXSIDES],
X		enable_digin[MAXSIDES];
X        
Xextern char outdated[MAXBOARDSIZE][MAXBOARDSIZE],
X            oldvalue[MAXBOARDSIZE][MAXBOARDSIZE];
X
Xdouble drand48();
Xvoid srand48();
X
Xextern char graytitle[MAXSIDES+1][40];
Xextern char huetitle[MAXSIDES+1][40];
Xextern char grayname[MAXHUES+1][10];
Xextern char huename[MAXHUES+1][10];
Xextern char personal_messagestr[MAXSIDES][512],
X            messagestr[512],
X            storagename[100],
X            replayname[100],
X            mapname[100],
X            blankline[150];
X
Xextern int palette[MAXSIDES+1][3];
Xextern double hillslope[3];
Xextern double hillintersect[3];
X
Xextern int hillpalette[3],
X           forestpalette[3],
X           seapalette[3];
X/**
X           seapalette[3] =    {  0,   0, 150};
X**/
X
Xextern char *usage;
X
Xextern char options[NOPTS][10];
X
Xextern int hex_side,
X           hex_halfside,
X           hex_quarterside,
X           hex_3quarterside,
X           hex_vert,
X           hex_halfvert,
X           hex_chart[2*MAXSQUARESIZE][2*MAXSQUARESIZE][2],
X           hex_horizon_even[200][2], hex_horizon_odd[200][2],
X           hex_horizon_number;
Xextern double hex_slope;
Xextern XPoint hex_points[7]; 
END_OF_FILE
if test 7347 -ne `wc -c <'extern.h'`; then
    echo shar: \"'extern.h'\" unpacked with wrong size!
fi
# end of 'extern.h'
fi
echo shar: End of archive 4 \(of 7\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
