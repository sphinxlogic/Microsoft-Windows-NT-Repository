Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i072:  xbattle - multi-player battle strategy game for X-Windows, Part01/07
Message-ID: <3511@master.CNA.TEK.COM>
Date: 7 Sep 92 21:22:36 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1777
Approved: billr@saab.CNA.TEK.COM

Submitted-by: slehar@cns.bu.edu
Posting-number: Volume 14, Issue 72
Archive-name: xbattle/Part01
Environment: Xlib

[From the author:
This  is the latest  version  of xbattle,  a  multi-player  concurrent
battle strategy game  in    xwindows.  Each player gets   a  gameboard
consisting of a grid of squares, some of which contain smaller colored
squares   representing   troops.   Players   command    their   troops
simultaneously using mouse clicks,  to occupy territory  and eliminate
enemy forces.]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 7)."
# Contents:  README MANIFEST Imakefile default.xbo skirmish.xbo
#   update.c
# Wrapped by billr@saab on Mon Sep  7 14:18:49 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(10048 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
Xxbattle 	concurrent multi-player battle strategy game
X
X		Steve Lehar  (slehar@cns.bu.edu)
X		Greg  Lesher (lesher@cns.bu.edu)
X
XDESCRIPTION
X
X  This is  version  4.0 of  xbattle, by    Greg Lesher,   based on the
X  original  by Steve  Lehar  released  in  1991  and including certain
X  enhancements, modifications and bug  fixes suggested  by a number of
X  contributers from all over the world.  The  new changes are outlined
X  below.   The  latest  version  can  be obtained  by anonymous ftp to
X  park.bu.edu (cd pub/xbattle) in both shar and tar.Z formats.
X
X  xbattle  is  a  concurrent  multi-player battle strategy   game that
X  captures the dynamics of a wide range  of military scenarios.  It is
X  based on X windows, which you must have installed to  run this game.
X  Players  play  from separate  displays,   and commands are  executed
X  concurrently, i.e.  the players do  not take "turns", they all issue
X  their commands simultaneously.  There can be  any number of players,
X  and each player is assigned to a color team (or black,  white & gray
X  for  monochrome monitors).  The  game  board is a matrix of  squares
X  that can be occupied by  colored troops, and the aim  of the game is
X  to eliminate the enemy from the board by  attacking squares occupied
X  enemy troops.
X
X  To get  the feel  of the  game, you can   run  the tutorials (called
X  "tutorial1" and "tutorial2") that are supplied with the game.  These
X  are shell scripts that run on unix systems and start up  a series of
X  small  example games that  you can play   around  with  to learn the
X  various options available with the game.  If  you are  not on a unix
X  system, print out  the  tutorials and type  in the  command lines by
X  hand. If you  are interested in  the philosophical and   game design
X  issues of  xbattle,  or want to  get immediate  notice of the latest
X  changes     bugs,     and    bug     fixes,  send      email      to
X  xbattle_request@park.bu.edu and  we   will  put you  on  the xbattle
X  mailing list.
X
XINSTALLATION
X
X  After unpacking  the shell archives, create  a  makefile  using  the
X  command "xmkmf", then compile using the command "make".
X
X
XDIFFERENCES BETWEEN VERSION VERSION 3.2 AND VERSION 4.0
X
X  Added option  "-hex" whereby  the  game board  comes  up as hexagons
X  instead of squares.  This makes for a more interesting geometry, but
X  slows the game down noticably.  Also, this option will not work with
X  the combination of "-horizon" AND "-wrap", among other restrictions.
X
X  Changed the options "-fill <n>" and "-dig <n>"  to take command line
X  arguments.   These options allow you  to modify the terrain, raising
X  or lowering hill elevations, or digging  and filling seas.  With the
X  new arguments, it costs  <n>  full troopsquares to completely dig or
X  fill a  sea.  A partially filled sea  is displayed  as  a sea square
X  with a square  island in the middle  whose size proportional  to the
X  number of fills left.  The  argument for  "-dig" and "-fill" must be
X  the same value, otherwise  the last argument supplied is  applied to
X  both, i.e.  the first is ignored.
X
X  Added option "-attack" whereby hitting 'a' when pointing to an enemy
X  square causes all your adjacent squares to attack that square.  This
X  helps synchronize simultaneous attacks.
X
X  Added option "-area" whereby the troop strength is represented by a
X  troop square whose area is proportional to the strength, rather than
X  the length of the side, which is the default.
X
X  Established new  default  that  grid appears automatically; replaced
X  "-grid" option with "-nogrid" option if you require no grid.
X
X  Changed the names of gray1 and gray3 to light and dark, representing
X  light and dark shades  of gray.  (Gray2,  the "stealth" color  still
X  exists, but is not documented).
X
X  Added a new feature- xbattle now  prints out  the random number seed
X  used in a particular game, to  make it easier to  reproduce the same
X  game again using the parameter "-seed <n>".
X
X  Added a new command key 'z' which cancels  all command vectors, like
X  clicking in the  center of  the  gamesquare.  This  is  particularly
X  useful with the new hex option.
X
X  Allow fractional speed settings like "-speed  0.5".  Very slow games
X  favor new players, and  make for a more  chess-like game of strategy
X  and planning rather than an arcade style shoot-em-up.
X
X  Defined  default   board and   square  sizes more   appropriate  for
X  beginners (big squares, small boards).
X
X  Changed the RGB color definitions for Cyan, Yellow and Green to more
X  pleasing combinations, although they  are no  longer the true colors
X  of those names.
X
X  Added compile time option MULTIFLUSH (default FALSE) whereby command
X  vectors are displayed immediately  after the command  is clicked, to
X  give the user  immediate confirmation of  the command.  This feature
X  noticably slows the game however.
X
X  Bug fix: Previously when  playing with  colored armies on monochrome
X  monitor  (for example color  "-red"  which appears as  black  with a
X  letter "R") the team color displayed  on the  xbattle window was the
X  monochrome color (or black, in  this example) instead  of the actual
X  color (or red).  This has now been fixed.
X
X  Bug   fix: Fixed  marching  bug which  accidentally enabled bounding
X  movement window.
X
X  Bug fix: Fixed movement bug which shortchanged fractional moves < 1.
X
X
XCOPYRIGHT
X
X  Copied   from the GNU Emacs  'copyleft'  policy.  Basically, you are
X  free to copy, modify and distribute this  program as long as  you do
X  not sell it or use it in a product that you sell.
X
X  			COPYING POLICIES
X
X  1. You may copy and  distribute  verbatim  copies of  xbattle source
Xcode as you receive it, in any medium, provided that you conspicuously
Xand  appropriately publish   on  each copy  a   valid copyright notice
X"Copyright (C)    1991 Steve  Lehar"   (or   with  whatever   year  is
Xappropriate); keep intact the notices on all  files that refer to this
XLicense Agreement  and to the  absence of  any warranty;  and give any
Xother recipients  of  the xbattle program   a  copy of  this   License
XAgreement along with  the program.   You may charge a distribution fee
Xfor the physical act of transferring a copy.
X
X  2. You may modify your copy or copies of xbattle source  code or any
Xportion of it,  and copy and distribute  such  modifications under the
Xterms of Paragraph 1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating
X    that you changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish,
X    that in whole or in part contains or is a derivative of xbattle
X    or any part thereof, to be licensed at no charge to all third
X    parties on terms identical to those contained in this License
X    Agreement (except that you may choose to grant more extensive
X    warranty protection to some or all third parties, at your option).
X
X    c) You may charge a distribution fee for the physical act of
X    transferring a copy, and you may at your option offer warranty
X    protection in exchange for a fee.
X
XMere aggregation of another unrelated program with this program (or its
Xderivative) on a volume of a storage or distribution medium does not bring
Xthe other program under the scope of these terms.
X
X  3. You may copy and distribute xbattle (or a portion or derivative of it,
Xunder Paragraph 2) in object code or executable form under the terms of
XParagraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    b) accompany it with a written offer, valid for at least three
X    years, to give any third party free (except for a nominal
X    shipping charge) a complete machine-readable copy of the
X    corresponding source code, to be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    c) accompany it with the information you received as to where the
X    corresponding source code may be obtained.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form alone.)
X
XFor an executable file, complete source code means all the source code for
Xall modules it contains; but, as a special exception, it need not include
Xsource code for modules which are standard libraries that accompany the
Xoperating system on which the executable file runs.
X
X  4. You may not copy, sublicense, distribute or transfer xbattle
Xexcept as expressly provided under this License Agreement.  Any attempt
Xotherwise to copy, sublicense, distribute or transfer xbattle is void and
Xyour rights to use xbattle under this License agreement shall be
Xautomatically terminated.  However, parties who have received computer
Xsoftware programs from you with this License Agreement will not have
Xtheir licenses terminated so long as such parties remain in full compliance.
X
X			   NO WARRANTY
X
X  BECAUSE XBATTLE IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY NO
XWARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  THE ENTIRE
XRISK AS TO THE  QUALITY AND PERFORMANCE  OF THE PROGRAM IS  WITH  YOU.
XSHOULD THE XBATTLE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
XNECESSARY SERVICING, REPAIR OR CORRECTION.
X
X IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL STEVE LEHAR OR ANY
XOTHER  PARTY  WHO MAY MODIFY AND   REDISTRIBUTE  XBATTLE  AS PERMITTED
XABOVE, BE LIABLE TO YOU FOR DAMAGES,  INCLUDING ANY LOST PROFITS, LOST
XMONIES, OR OTHER SPECIAL, INCIDENTAL  OR CONSEQUENTIAL DAMAGES ARISING
XOUT OF THE USE OR INABILITY TO USE  (INCLUDING BUT NOT LIMITED TO LOSS
XOF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
XPARTIES OR  A FAILURE  OF  THE  PROGRAM TO OPERATE  WITH  PROGRAMS NOT
XDISTRIBUTED BY STEVE LEHAR) THE PROGRAM, EVEN IF YOU HAVE BEEN ADVISED
XOF THE POSSIBILITY OF SUCH  DAMAGES, OR FOR  ANY CLAIM   BY ANY  OTHER
XPARTY.
X
END_OF_FILE
if test 10048 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(672 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Imakefile                  1	
X MANIFEST                   1	This shipping list
X README                     1	
X default.xbo                1	
X draw.c                     4	
X extern.h                   4	
X global.h                   5	
X init.c                     5	
X main.c                     2	
X parse.c                    6	
X patchlevel.h               2	
X skirmish.xbo               1	
X tribal.xbo                 2	
X tutorial1                  7	
X tutorial2                  6	
X update.c                   1	
X utils.c                    7	
X xbattle.man                3	
END_OF_FILE
if test 672 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(254 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X# @(#)Imakefile 10/1/91
X# Imakefile - xbattle
XLOCAL_LIBRARIES = $(XLIB)
X  SYS_LIBRARIES = -lm
X           SRCS = main.c init.c parse.c update.c utils.c draw.c
X           OBJS = main.o init.o parse.o update.o utils.o draw.o
X
XComplexProgramTarget(xbattle)
X
END_OF_FILE
if test 254 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'default.xbo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'default.xbo'\"
else
echo shar: Extracting \"'default.xbo'\" \(31 characters\)
sed "s/^X//" >'default.xbo' <<'END_OF_FILE'
X-decay 2
X-repeat
X-area
X-attack
END_OF_FILE
if test 31 -ne `wc -c <'default.xbo'`; then
    echo shar: \"'default.xbo'\" unpacked with wrong size!
fi
# end of 'default.xbo'
fi
if test -f 'skirmish.xbo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'skirmish.xbo'\"
else
echo shar: Extracting \"'skirmish.xbo'\" \(138 characters\)
sed "s/^X//" >'skirmish.xbo' <<'END_OF_FILE'
X-guns 5
X-para 5
X-horizon
X-decay 2
X-square 32
X-board 24
X-sea 8
X-rbases 5
X-fill 4
X-dig 4
X-scuttle
X-build 8
X-store
X-reserve
X-repeat
X-march 4
END_OF_FILE
if test 138 -ne `wc -c <'skirmish.xbo'`; then
    echo shar: \"'skirmish.xbo'\" unpacked with wrong size!
fi
# end of 'skirmish.xbo'
fi
if test -f 'update.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'update.c'\"
else
echo shar: Extracting \"'update.c'\" \(39423 characters\)
sed "s/^X//" >'update.c' <<'END_OF_FILE'
X#include <stdio.h>
X  
X/**** x include files ****/
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xatom.h>
X#include <X11/keysym.h>
X#include <X11/keysymdef.h>
X
X#include "extern.h"
X
X/*************************************************************************/
X/**	update_board							**/
X/** Update all game board values based on the values encoded in the 	**/
X/** squares, and display any square that has changed.  The xtab[] and 	**/
X/** ytab[] arrays are shuffled randomly so that each square will be 	**/
X/** updated in a random order to remove update sequence artifacts.	**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xupdate_board(board)
X  square_type *board;
X{
X  int i, j, k, l,
X      disrupt,
X      wrap,
X      swapindex, tempindex,
X      x1, y1, x2, y2;
X  static int firstime=1,
X             xtab[MAXBOARDSIZE],ytab[MAXBOARDSIZE];
X  square_type *square, *square2;
X  static unsigned int xrand=0;
X  double thresh;
X
X#if PAUSE
X  if (paused)
X    return;
X#endif
X
X  /*** initialize the tables first time ****/
X  if (firstime)
X  {
X    firstime = 0;
X    for (i=0; i<boardsizex; i++)
X       xtab[i] = i;
X    for (i=0; i<boardsizey; i++)
X       ytab[i] = i;
X
X    /**** make all squares outdated ****/
X    for (i=0; i<boardsizex; i++)
X      for (j=0; j<boardsizey; j++)
X      {
X        outdated[i][j] = ALL;
X        oldvalue[i][j] = -1;
X      }
X  }
X
X  /**** shuffle the tab tables ****/
X  for (i=0; i<boardsizex; i++)
X  {
X    swapindex = (int)(drand48()*(double)(boardsizex));
X    tempindex = xtab[i];
X    xtab[i] = xtab[swapindex];
X    xtab[swapindex] = tempindex;
X  }
X
X  for (i=0; i<boardsizey; i++)
X  {
X    swapindex = (int)(drand48()*(double)(boardsizey));
X    tempindex = ytab[i];
X    ytab[i] = ytab[swapindex];
X    ytab[swapindex] = tempindex;
X  }
X
X  /**** update the board ****/
X  for (i=0; i<boardsizex; i++)
X  {
X    for (j=0; j<boardsizey; j++)
X    {
X      x1 = xtab[i];
X      y1 = ytab[j];
X
X      /**** grow ****/
X      growsquare(SQUARE(board,x1,y1));
X
X      if (enable_decay)
X        decaysquare(SQUARE(board,x1,y1));
X
X      /**** fight ****/
X      if (SQUARE(board,x1,y1)->color == FIGHT)
X	fight(board,SQUARE(board,x1,y1));
X
X      if (SQUARE(board,x1,y1)->color != FIGHT && SQUARE(board,x1,y1)->color != none)
X      {
X        disrupt = enable_disrupt[SQUARE(board,x1,y1)->color];
X        wrap = enable_wrap[SQUARE(board,x1,y1)->color];
X        if (SQUARE(board,x1,y1)->value[SQUARE(board,x1,y1)->color] > 0)
X          SQUARE(board,x1,y1)->age = 0;
X      }
X      else
X      {
X        disrupt = FALSE;
X        wrap = enable_anywrap;
X        SQUARE(board,x1,y1)->age = 0;
X      }
X	
X      /**** if move command is active ****/
X      if (SQUARE(board,x1,y1)->move) 
X      {
X        if (SQUARE(board,x1,y1)->color!=FIGHT || !disrupt)
X        {
X          xrand = (xrand+1)%directions;
X          for (k=0; k<directions; k++)
X          {
X            l = (k+xrand)%directions;
X
X	    if (SQUARE(board,x1,y1)->dir[l])
X            {
X
X              square2 = SQUARE(board,x1,y1)->connect[l];
X
X              if (enable_sea)
X              {
X                if (square2->value[none] > 0)
X                  update_square(board,SQUARE(board,x1,y1),square2);
X              }
X              else
X                update_square(board,SQUARE(board,x1,y1),square2);
X            }
X	  }
X        }
X      }
X    }
X  }
X
X  /**** redraw all squares that have been changed ****/
X
X  for (i=0; i<boardsizex; i++)
X  {
X    for (j=0; j<boardsizey; j++)
X    {
X      x1 = xtab[i];
X      y1 = ytab[j];
X      square = SQUARE(board,x1,y1);
X
X      /**** outdate if change in value has occurred ****/
X      if (square->color != FIGHT)
X      {
X        if (square->value[square->color] != oldvalue[x1][y1])
X          outdated[x1][y1] = ALL;
X
X        square->age++;
X
X        if (enable_erode[square->color])
X        {
X          if (square->age > eroderate[square->color])
X          {
X            if (drand48() < ERODETHRESH)
X            {
X              for (k=0; k<directions; k++)
X                square->dir[k] = 0;
X              square->move = 0;
X              square->age = 0;
X              outdated[x1][y1] = ALL;
X              if (square->value[square->color] == 0)
X                square->color = none;
X            }
X          }
X        }
X      }
X
X      for (k=0;k<nplayers;k++)
X      {
X        if (!winopen[k])
X          continue;
X        if (outdated[x1][y1] == ALL || outdated[x1][y1] == colorarray[k])
X        {
X          if (visible(board,colorarray[k],x1,y1))
X            drawsquare(xwindow[k],square,colorarray[k],squaresize[colorarray[k]]);
X          else
X            drawblank(xwindow[k], x1, y1, square->value[none], square->seen[colorarray[k]],
X                          square->growth, colorarray[k], squaresize[colorarray[k]], square);
X        }
X      }
X
X      /**** make indated ****/
X      if (outdated[x1][y1] >= 0)
X      {
X        if (enable_storage)
X          storedrawsquare(square, squaresize[0], FALSE);
X        outdated[x1][y1] = OK;
X      }
X
X      /**** set old values ****/
X      if (square->color != FIGHT)
X        oldvalue[x1][y1] = square->value[square->color];
X      else
X        oldvalue[x1][y1] = -1;
X    }
X  }
X
X  if (enable_march)
X    drawmarch(board);
X}
X
X
X/*************************************************************************/
X/**	update_square							**/
X/** update the square with a move command, and the  destination square	**/
X/** into   which  it is  moving by  decrementing  the square value and	**/
X/** incrementing the destination    square value.   The influences  of	**/
X/** hills and forests are also accounted for.				**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xupdate_square(board,square1,square2)
X  square_type *board,*square1,*square2;
X{
X  int i,
X      side,
X      disrupt,
X      color1,color2,
X      surplus,
X      nmove;
X  double slope,
X         hinder,
X         shunt,
X         doublenmove;
X
X  /**** get color ****/
X  color1 = square1->color;
X  color2 = square2->color;
X
X  if (color1 == FIGHT)
X    disrupt = enable_disrupt[0];
X  else
X    disrupt = enable_disrupt[color1];
X
X  if (color1 == FIGHT && !disrupt)
X  {
X    if (color2 == none || color2 == square1->oldcolor)
X      color1 = square1->oldcolor;
X  }
X
X  surplus = square1->value[color1] - square1->lowbound;
X  if (surplus < 0)
X    surplus = 0;
X
X  /**** check value ****/
X  if (surplus == 0)
X    goto quit;
X
X  /**** compute slope and forest hinderance ****/
X
X  if (color1 != FIGHT)
X  {
X    slope = (double)(square2->value[none] - square1->value[none]) /
X      NGREYTONES * hillfactor[color1];
X    hinder = slowfactor[color1] + forest[color1] * (double)square2->value[none];
X
X    if (enable_digin[color1])
X      shunt = shuntval[color1]*((double)(square2->value[color1]))/MAXVAL + 1.0;
X    else
X      shunt = 1.0;
X  }
X  else
X  {
X    slope = (double)(square2->value[none] - square1->value[none]) /
X      NGREYTONES * hillfactor[0];
X    hinder = slowfactor[0] + forest[0] * (double)square2->value[none];
X  }
X
X  /**** advance into grey square ****/
X  if (color2 == none && color1 != FIGHT)
X  {
X    /**** compute the number to move ****/
X
X    doublenmove = (double)surplus / hinder / shunt /
X		  (double)square1->move * (1.0-slope);
X    nmove = (int)(doublenmove);
X		  
X    if (nmove > surplus)
X      nmove = surplus;
X    if (nmove + square2->value[color1] > MAXVAL)
X      nmove = MAXVAL - square2->value[color1];
X    if (nmove == 0 && doublenmove > 0.0 && drand48() < doublenmove)
X      nmove = 1;
X    if (nmove <= 0)
X      goto quit;
X
X    /**** move ****/
X    square1->value[color1] = square1->value[color1] - nmove;
X    for (i=0; i<directions; i++)
X      square1->dir[i] = square1->dir[i];
X    square2->color = color2 = color1;
X    square2->value[color2] = nmove;
X    square2->age = 0;
X
X    /**** outdate the squares (for later redrawing) ****/
X    outdated[square1->x][square1->y] = ALL;
X    outdated[square2->x][square2->y] = ALL;
X
X    /**** outdate neighboring squares if using horizon ****/
X    if (enable_horizon)
X    {
X      if (square1->value[color1] == 0)
X        outdatehorizon (board, square1->x, square1->y, color1);
X      if (square2->value[color1] > 0)
X        outdatehorizon (board, square2->x, square2->y, color1);
X    }
X
X  /**** move into friendly square ****/
X  }
X  else if (color1 == color2 && color1 != FIGHT)
X  {
X    /**** compute the number to move ****/
X
X    doublenmove = (double)surplus / hinder / shunt /
X		  (double)square1->move * (1.0-slope);
X    nmove = (int)(doublenmove);
X
X    if (nmove > surplus)
X      nmove = surplus;
X    if (nmove + square2->value[color1] > MAXVAL)
X      nmove = MAXVAL - square2->value[color1];
X    if (nmove == 0 && doublenmove > 0.0 && drand48() < doublenmove)
X      nmove = 1;
X    if (nmove <= 0)
X      goto quit;
X
X    /**** move ****/
X    square1->value[color1] = square1->value[color1] - nmove;
X    square2->value[color2] = square2->value[color1] + nmove;
X
X    /**** outdate neighboring squares if using horizon ****/
X    if (enable_horizon)
X    {
X      if (square1->value[color1] == 0)
X        outdatehorizon (board, square1->x, square1->y, color1);
X      if (square2->value[color1] == nmove && nmove>0)
X        outdatehorizon (board, square2->x, square2->y, color1);
X    }
X
X  /**** invade enemy square ****/
X  }
X  else if (color1 != color2 && color2 != none && color2 != FIGHT)
X  {
X    /**** compute the number to move ****/
X    doublenmove = (double)surplus / hinder / shunt /
X		  (double)square1->move * (1.0-slope);
X    nmove = (int)(doublenmove);
X
X    if (nmove > surplus)
X      nmove = surplus;
X    if (nmove + square2->value[color1] > MAXVAL)
X      nmove = MAXVAL - square2->value[color1];
X    if (nmove == 0 && doublenmove > 0.0 && drand48() < doublenmove)
X      nmove = 1;
X    if (nmove <= 0)
X      goto quit;
X
X    /**** immobilize the enemy ****/
X    if (disrupt)
X      for (i=0; i<directions; i++)
X        square2->dir[i] = 0;
X
X    /**** do the move ****/
X    square2->color = FIGHT;
X    square1->value[color1]  = square1->value[color1] - nmove;
X    square2->value[color1] = square2->value[color1] + nmove;
X    square2->oldcolor = color2;
X
X    /**** outdate the squares (for later redrawing) ****/
X    outdated[square1->x][square1->y] = ALL;
X    outdated[square2->x][square2->y] = ALL;
X
X    /**** outdate neighboring squares if using horizon ****/
X    if (enable_horizon)
X    {
X      if (square1->value[color1] == 0)
X        outdatehorizon (board, square1->x, square1->y, color1);
X      outdatehorizon (board, square2->x, square2->y, color1);
X    }
X
X  /**** join battle in square ****/
X  }
X  else if (color2 == FIGHT)
X  {
X    /**** compute the number to move ****/
X    doublenmove = (double)surplus / hinder / shunt /
X		  (double)square1->move * (1.0-slope);
X    nmove = (int)(doublenmove);
X
X    if (nmove > surplus)
X      nmove = surplus;
X    if (nmove + square2->value[color1] > MAXVAL)
X      nmove = MAXVAL - square2->value[color1];
X    if (nmove == 0 && doublenmove > 0.0 && drand48() < doublenmove)
X      nmove = 1;
X    if (nmove <= 0)
X      goto quit;
X
X    /**** do the move ****/
X    square1->value[color1] = square1->value[color1] - nmove;
X    square2->value[color1] = square2->value[color1] + nmove;
X
X    /**** outdate the squares (for later redrawing) ****/
X    outdated[square1->x][square1->y] = ALL;
X    outdated[square2->x][square2->y] = ALL;
X
X    /**** outdate neighboring squares if using horizon ****/
X    if (enable_horizon)
X    {
X      if (square1->value[color1] == 0)
X        outdatehorizon (board, square1->x, square1->y, color1);
X    }
X  }
X  quit:;
X}
X
X
X/*************************************************************************/
X/**	growsquare							**/
X/** every square with a grow value is incremented in each update cycle	**/
X/** by the grow value.  This applies to farms, towns and bases.		**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/*************************************************************************/
Xgrowsquare(square)
X  square_type *square;
X{
X  int activecolor;
X
X  /**** get color ****/
X  activecolor = square->color;
X  if(activecolor == none || activecolor == FIGHT) goto quit;
X
X  /**** grow square ****/
X  if(square->growth>0 && square->value[activecolor]<MAXVAL)
X  {
X    if(square->growth>50)
X      square->age = 0;
X    if(square->growth > (int)(100.0 * drand48())) 
X      square->value[activecolor] ++;
X    if(square->value[activecolor] > MAXVAL) 
X      square->value[activecolor] = MAXVAL;
X  }
X quit:;
X}
X
X
X/*************************************************************************/
X/**	decaysquare							**/
X/**	 Greg Lesher (lesher@park.bu.edu				**/
X/*************************************************************************/
Xdecaysquare(square)
X  square_type *square;
X{
X  int activecolor;
X
X  double thresh;
X
X  /**** get color ****/
X  activecolor = square->color;
X  if(activecolor == none || activecolor == FIGHT) 
X    return;
X
X  thresh = decayrate[activecolor] * square->value[activecolor];
X  if (drand48() < thresh)
X    square->value[activecolor] -= 1;
X
X  if (square->value[activecolor] < 0)
X    square->value[activecolor] = 0;
X}
X
X
X/*************************************************************************/
X/**	fight								**/
X/** Battles  occur when  opposing  forces  occupy a square  (color  ==	**/
X/** FIGHT).   The outcome of the  battle   is  determined by a   random	**/
X/** variable and a nonlinear function of the relative strengths of the	**/
X/** combatants, such that a larger unbalance  results in a much larger	**/
X/** advantage.    In  each update    cycle each  side  suffers  losses	**/
X/** determined by that function.					**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/**	Greg Lesher (lesher@park.bu.edu)				**/
X/*************************************************************************/
Xfight(board,square)
X  square_type *board,*square;
X{
X  int i,j,
X      count, pos,
X      versus[MAXSIDES];
X
X  double sideinfer[MAXSIDES],
X         sideloss[MAXSIDES];
X
X  /**** compute the number of attacking forces against each color ****/
X  for (i=0; i<nsides; i++)
X  {
X    versus[i] = 0;
X    for (j=0; j<nsides; j++)
X    {
X      if (j!=i)
X      {
X        if (square->value[j] > 0)
X          versus[i] += square->value[j];
X      }
X    }
X  }
X
X  /**** compute damages for each color ****/
X  for (i=0; i<nsides; i++)
X    if (square->value[i] > 0)
X      sideinfer[i] = (double)versus[i]/((double)square->value[i]);
X
X  for (i=0; i<nsides; i++)
X  {
X    if (square->value[i] > 0)
X    {
X      sideloss[i] = ((sideinfer[i]*sideinfer[i]) - 1.0 + drand48()*2.0) * firepower[i];
X      if (sideloss[i] < 0.0)
X        sideloss[i] = 0.0;
X    }
X    else
X      sideloss[i] = 0.0;
X    square->value[i] -= (int)(sideloss[i]+0.5);
X  }
X
X  /**** count remaining colors ****/
X  count = 0;
X  for (i=0; i<nsides; i++)
X  {
X    if (square->value[i] <= 0)
X      square->value[i] = 0;
X    else
X    {
X      count++;
X      pos = i;
X    }
X  }
X
X  /**** if there is a winner, give the square to that color ****/
X  if (count == 1)
X  {
X    square->color = pos;  
X    square->age = 0;
X    if (square->oldcolor != pos)
X    {
X      for (i=0; i<directions; i++) square->dir[i] = 0;
X      square->move = 0;
X      square->lowbound = 0;
X    }
X  }
X  else if (count == 0)
X  {
X    square->color = none;
X    square->move = 0;
X    square->lowbound = 0;
X    square->age = 0;
X    for (i=0; i<directions; i++) square->dir[i] = 0;
X  }
X
X  /**** outdate squares for later redrawing ****/
X  outdated[square->x][square->y] = ALL;
X  if (enable_horizon)
X  {
X    outdatehorizon (board, square->x, square->y, ALL);
X  }
X}
X
X
X/*************************************************************************/
X/**     march                                                           **/
X/**  handle marching 							**/
X/**     Greg Lesher (lesher@park.bu.edu)                                **/
X/*************************************************************************/
Xmarch (board)
X  square_type *board;
X{
X  int i, j,
X      x, y,
X      newx, newy,
X      color;
X
X  square_type *square, *square2;
X
X
X  for (x=0; x<boardsizex; x++)
X  {
X    for (y=0; y<boardsizey; y++)
X    {
X      square = SQUARE(board,x,y);
X      color = square->color; 
X
X      if (square->anymarch == ACTIVE)
X      {
X        if (color == none || color==FIGHT)
X          square->anymarch = FALSE;
X        else if (color != square->marchcolor)
X          square->anymarch = FALSE;
X      }
X
X      if (enable_personalmarch[color] && square->anymarch==ACTIVE)
X      {
X        square->marchcount += 1;
X        if (square->marchcount == marchrate[color]) 
X        {
X          square->anymarch = FALSE;
X          outdated[square->x][square->y] = ALL;
X
X          square->move = 0;
X          for (i=0; i<directions; i++)
X          {
X            if (square->marchtype[color] == FORCE)
X              square->dir[i] = square->marchdir[color][i];
X            else
X              square->dir[i] = square->marchdir[color][i] || square->dir[i];
X            if (square->dir[i])
X              square->move++;
X          }
X
X          for (i=0; i<directions; i++)
X          {
X            newx = x; 
X            newy = y; 
X
X            if (square->marchdir[color][i])
X            {
X              square2 = SQUARE(board,x,y)->connect[i];
X
X              if (square2->color == none || square2->color == color)
X              {
X                if (enable_sea && square2->value[none] <= 0)
X                {
X                }
X                else if (square2->march[color] == PASSIVE) 
X                {
X                   square2->anymarch = TEMP;
X                   square2->march[color] = FALSE;
X                   square2->marchcolor = color;
X                   square2->marchcount = 0;
X                }
X                else
X                {
X                  square2->anymarch = TEMP;
X                  square2->marchtype[color] = SQUARE(board,x,y)->marchtype[color];
X                  square2->marchcount = 0;
X                  square2->marchcolor = color;
X                  for (j=0; j<directions; j++)
X                    square2->marchdir[color][j] = square->marchdir[color][j];
X                }
X              }
X            }
X          }
X        }
X      }
X
X      if (color != none && color != FIGHT)
X      {
X        if (square->march[color] == PASSIVE)
X        {
X          if (square->value[color] > 0)
X          {
X            square->anymarch = ACTIVE;
X            square->march[color] = FALSE;
X            square->marchcolor = color;
X            square->marchcount = 0;
X          }
X        }
X      }
X    }
X  }
X
X  for (x=0; x<boardsizex; x++)
X    for (y=0; y<boardsizey; y++)
X      if (SQUARE(board,x,y)->anymarch == TEMP)
X        SQUARE(board,x,y)->anymarch = ACTIVE;
X}
X
X
X/*************************************************************************/
X/**     fire                                                            **/
X/**  control artillery fire						**/
X/**     Greg Lesher (lesher@park.bu.edu)                                **/
X/*************************************************************************/
Xfire (board, xpos, ypos, x, y, colorarray)
X  square_type *board;
X  int xpos, ypos,
X      x, y,
X      colorarray[];
X{
X  static int xrand, yrand;
X
X  int i,
X      tdir[DIRS],
X      xdiff, ydiff,
X      xdest, ydest,
X      xfdest, yfdest,
X      destcolor,
X      sourcecolor,
X      csize, hafc,
X      winxsize, winysize;
X
X  square_type *square;
X
X  /**** make sure shell can be afforded ****/
X  if (SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] < SHELL_COST+1)
X    return;
X  SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] -= SHELL_COST;
X
X  sourcecolor = SQUARE(board,x,y)->color;
X
X  /**** compute direction and distance of artillery shell ****/
X
X  if (enable_hex)
X  {
X    xdiff = xpos - SQUARE(board,x,y)->xpos;
X    ydiff = ypos - SQUARE(board,x,y)->ypos;
X  }
X  else
X  {
X    xdiff = xpos - (squaresize[sourcecolor]*SQUARE(board,x,y)->x+squaresize[sourcecolor]/2);
X    ydiff = ypos - (squaresize[sourcecolor]*SQUARE(board,x,y)->y+squaresize[sourcecolor]/2);
X  }
X
X  xfdest = xpos + xdiff * 40 * artillery[SQUARE(board,x,y)->color];
X  yfdest = ypos + ydiff * 40 * artillery[SQUARE(board,x,y)->color];
X
X  if (enable_wrap[sourcecolor])
X  {
X    if (enable_hex)
X    {
X      winxsize = (boardsizex-1)*3*(hex_halfside) + 2*hex_side;
X      winysize = boardsizey*2*hex_vert + hex_vert;
X    }
X    else
X    {
X      winxsize = boardsizex*squaresize[sourcecolor];
X      winysize = boardsizey*squaresize[sourcecolor];
X    }
X
X    if (xfdest > winxsize)
X      xfdest -= winxsize;
X    else if (xfdest < 0)
X      xfdest = winxsize + xfdest;
X
X    if (yfdest > winysize)
X      yfdest -= winysize;
X    else if (yfdest < 0)
X      yfdest = winysize + yfdest;
X  }
X
X  getsquare (xfdest, yfdest, &xdest, &ydest, tdir, squaresize[sourcecolor], board, FALSE);
X
X  if (xdest < 0)
X    xdest = 0;
X  else if (xdest > boardsizex-1)
X    xdest = boardsizex-1;
X
X  if (ydest < 0)
X    ydest = 0;
X  else if (ydest > boardsizey-1)
X    ydest = boardsizey-1;
X
X  /**** compute effect of artillery shell ****/
X  square = SQUARE(board,xdest,ydest);
X  destcolor = square->color;
X
X  if (destcolor != none && destcolor != FIGHT)
X  {
X    square->value[destcolor] -= SHELL;
X    if (square->value[destcolor] < 0)
X    {
X      square->color = none;
X      square->age = 0;
X      square->march[destcolor] = FALSE;
X      square->anymarch = FALSE;
X      square->value[destcolor] = 0;
X      square->move = 0;
X      square->lowbound = 0;
X      for (i=0; i<directions; i++)
X        square->dir[i] = 0;
X      if (enable_horizon)
X      {
X        outdatehorizon (board, xdest, ydest, destcolor);
X      }
X    }
X  }
X
X  /**** redraw affected squares and shell burst ****/
X
X  for (i=0; i<nplayers; i++)
X  {
X
X    csize = 10 * squaresize[colorarray[i]]/50;
X    if (enable_hex)
X      hafc = csize/2;
X    else
X      hafc = (squaresize[colorarray[i]]-csize)/2; 
X
X    if (!winopen[i])
X      continue;
X
X    if (visible(board,colorarray[i],x,y))
X    {
X      if (enable_hidden[colorarray[i]])
X      {
X        if (SQUARE(board,x,y)->color == colorarray[i])
X          drawsquare(xwindow[i],SQUARE(board,x,y),colorarray[i],squaresize[colorarray[i]]);
X      }
X      else
X       drawsquare(xwindow[i],SQUARE(board,x,y),colorarray[i],squaresize[colorarray[i]]);
X    }
X
X    if (enable_storage && !i)
X      storedrawsquare(SQUARE(board,x,y),squaresize[0], FALSE);
X
X    if (visible(board,colorarray[i],xdest,ydest))
X    {
X      if (enable_hidden[colorarray[i]])
X      {
X        if (SQUARE(board,xdest,ydest)->color == colorarray[i])
X              drawsquare(xwindow[i],SQUARE(board,xdest,ydest),colorarray[i],squaresize[colorarray[i]]);
X      }
X      else
X       drawsquare(xwindow[i],SQUARE(board,xdest,ydest),colorarray[i],squaresize[colorarray[i]]);
X
X      if (enable_hex)
X      {
X        xrand = (xrand+2938345)%hex_side;
X        yrand = (yrand+2398321)%hex_side;
X
X        XFillArc(xwindow[i]->display,xwindow[i]->window,xwindow[i]->hue[sourcecolor],
X                 SQUARE(board,xdest,ydest)->xpos - hafc + xrand - hex_halfside,
X                 SQUARE(board,xdest,ydest)->ypos - hafc + yrand - hex_halfside,
X                 csize, csize, 0, 23040);
X      }
X      else
X      {
X        xrand = (xrand+2938345)%(squaresize[colorarray[i]]/2);
X        yrand = (yrand+2398321)%(squaresize[colorarray[i]]/2);
X
X        XFillArc(xwindow[i]->display,xwindow[i]->window,xwindow[i]->hue[sourcecolor],
X                 xdest*squaresize[colorarray[i]]+hafc+xrand-squaresize[colorarray[i]]/4,
X                 ydest*squaresize[colorarray[i]]+hafc+yrand-squaresize[colorarray[i]]/4,
X                 csize, csize, 0, 23040);
X      }
X      outdated[xdest][ydest] = ALL;
X    }
X    if (enable_storage && !i)
X    {
X      storedrawsquare(SQUARE(board,xdest,ydest),squaresize[0], FALSE);
X      fprintf (fpout, "H%c%c%c%c", xdest, ydest, csize, sourcecolor);
X    }
X  }
X}
X
X
X/*************************************************************************/
X/**     para                                                            **/
X/**  control paratroopers						**/
X/**     Greg Lesher (lesher@park.bu.edu)                                **/
X/*************************************************************************/
Xpara (board, xpos, ypos, x, y, colorarray)
X  square_type *board;
X  int xpos, ypos,
X      x, y,
X      colorarray[];
X{
X  static xrand, yrand;
X
X  int i,
X      tdir[DIRS],
X      xdiff, ydiff,
X      xdest, ydest,
X      xfdest, yfdest,
X      ipos, jpos,
X      destcolor,
X      sourcecolor,
X      csize, hafc,
X      winxsize, winysize;
X
X  square_type *square;
X
X  /**** make sure that paratroopers can be afforded ****/
X  if (SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] < PARA_COST+1)
X    return;
X  SQUARE(board,x,y)->value[SQUARE(board,x,y)->color] -= PARA_COST;
X  sourcecolor = SQUARE(board,x,y)->color;
X
X  /**** compute direction and distance of paratroopers ****/
X
X  if (enable_hex)
X  {
X    xdiff = xpos - SQUARE(board,x,y)->xpos;
X    ydiff = ypos - SQUARE(board,x,y)->ypos;
X  }
X  else
X  {
X    xdiff = xpos - (squaresize[sourcecolor]*SQUARE(board,x,y)->x+squaresize[sourcecolor]/2);
X    ydiff = ypos - (squaresize[sourcecolor]*SQUARE(board,x,y)->y+squaresize[sourcecolor]/2);
X  }
X
X  xfdest = xpos + xdiff * 40 * artillery[SQUARE(board,x,y)->color];
X  yfdest = ypos + ydiff * 40 * artillery[SQUARE(board,x,y)->color];
X
X  if (enable_wrap[sourcecolor])
X  {
X    if (enable_hex)
X    {
X      winxsize = (boardsizex-1)*3*(hex_halfside) + 2*hex_side;
X      winysize = boardsizey*2*hex_vert + hex_vert;
X    }
X    else
X    {
X      winxsize = boardsizex*squaresize[sourcecolor];
X      winysize = boardsizey*squaresize[sourcecolor];
X    }
X
X    if (xfdest > winxsize)
X      xfdest -= winxsize;
X    else if (xfdest < 0)
X      xfdest = winxsize + xfdest;
X
X    if (yfdest > winysize)
X      yfdest -= winysize;
X    else if (yfdest < 0)
X      yfdest = winysize + yfdest;
X  }
X
X
X  getsquare (xfdest, yfdest, &xdest, &ydest, tdir, squaresize[sourcecolor], board);
X
X  if (xdest < 0)
X    xdest = 0;
X  else if (xdest > boardsizex-1)
X    xdest = boardsizex-1;
X
X  if (ydest < 0)
X    ydest = 0;
X  else if (ydest > boardsizey-1)
X    ydest = boardsizey-1;
X
X  /**** compute effect of paratroopers ****/
X  square = SQUARE(board,xdest,ydest);
X  destcolor = square->color;
X
X  if (enable_sea && square->value[none] <= 0)
X  {
X  }
X  else
X  {
X    if (destcolor == none || destcolor == sourcecolor)
X    {
X      square->color = sourcecolor;
X      square->age = 0;
X      square->anymarch = FALSE;
X      square->value[sourcecolor] += PARA;
X      if (square->value[sourcecolor] > MAXVAL)
X        square->value[sourcecolor] = MAXVAL;
X      if (enable_horizon && destcolor == none)
X      {
X        outdatehorizon (board, xdest, ydest, sourcecolor);
X      }
X    }
X    else if (destcolor != sourcecolor && destcolor != FIGHT)
X    {
X      square->value[sourcecolor] += PARA;
X      square->color = FIGHT;
X
X      if (enable_disrupt[sourcecolor])
X      {
X        for (i=0; i<directions; i++)
X          square->dir[i] = 0;
X        square->move = 0;
X      }
X
X      if (enable_horizon)
X      {
X        outdatehorizon (board, xdest, ydest, sourcecolor);
X      }
X    }
X    else if (destcolor == FIGHT)
X    {
X      square->value[sourcecolor] += PARA;
X      if (square->value[sourcecolor] > MAXVAL)
X        square->value[sourcecolor] = MAXVAL;
X    }
X  }
X
X  /**** redraw affected squares and parachute ****/
X
X  for (i=0; i<nplayers; i++)
X  {
X    csize = 20 * squaresize[colorarray[i]]/50;
X    if (enable_hex)
X      hafc = csize/2;
X    else
X      hafc = (squaresize[colorarray[i]]-csize)/2; 
X
X    if (!winopen[i])
X      continue;
X    if (visible(board,colorarray[i],x,y))
X    {
X      if (enable_hidden[colorarray[i]])
X      {
X        if (SQUARE(board,x,y)->color == colorarray[i])
X              drawsquare(xwindow[i],SQUARE(board,x,y),colorarray[i],squaresize[colorarray[i]]);
X      }
X      else
X       drawsquare(xwindow[i],SQUARE(board,x,y),colorarray[i],squaresize[colorarray[i]]);
X    }
X    if (enable_storage && !i)
X      storedrawsquare(SQUARE(board,x,y),squaresize[0], FALSE);
X
X    if (visible(board,colorarray[i],xdest,ydest))
X    {
X      if (enable_hidden[colorarray[i]])
X      {
X        if (SQUARE(board,xdest,ydest)->color == colorarray[i])
X              drawsquare(xwindow[i],SQUARE(board,xdest,ydest),colorarray[i],squaresize[colorarray[i]]);
X      }
X      else
X        drawsquare(xwindow[i],SQUARE(board,xdest,ydest),colorarray[i],squaresize[colorarray[i]]);
X
X      if (enable_hex)
X      {
X        xrand = (xrand+2938345)%hex_side;
X        yrand = (yrand+2398321)%hex_side;
X
X        ipos = SQUARE(board,xdest,ydest)->xpos - hafc + xrand - hex_halfside;
X        jpos = SQUARE(board,xdest,ydest)->ypos - hafc + yrand - hex_halfside;
X      }
X      else
X      {
X        xrand = (xrand+2938345)%(squaresize[colorarray[i]]/2);
X        yrand = (yrand+2398321)%(squaresize[colorarray[i]]/2);
X
X        ipos = xdest*squaresize[colorarray[i]]+hafc+xrand-squaresize[colorarray[i]]/4;
X        jpos = ydest*squaresize[colorarray[i]]+hafc+yrand-squaresize[colorarray[i]]/4;
X      }
X
X      XFillArc(xwindow[i]->display,xwindow[i]->window,xwindow[i]->hue[sourcecolor],
X               ipos, jpos, csize, csize, 0, 11520);
X
X      XDrawLine(xwindow[i]->display,xwindow[i]->window,xwindow[i]->hue[sourcecolor],
X               ipos, jpos + csize/2, ipos + csize/2, jpos + csize);
X
X      XDrawLine(xwindow[i]->display,xwindow[i]->window,xwindow[i]->hue[sourcecolor],
X               ipos + csize/2, jpos + csize, ipos + csize, jpos + csize/2);
X
X      XDrawLine(xwindow[i]->display,xwindow[i]->window,xwindow[i]->hue[sourcecolor],
X               ipos + csize/2, jpos + csize/2, ipos + csize/2, jpos + csize);
X
X      outdated[xdest][ydest] = ALL;
X    }
X    if (enable_storage && !i)
X    {
X      storedrawsquare(SQUARE(board,xdest,ydest),squaresize[0], FALSE);
X      fprintf (fpout, "I%c%c%c%c", xdest, ydest, csize, sourcecolor);
X    } 
X  }
X}
X
X
X/*************************************************************************/
X/**     visible                                                         **/
X/**  Checks viewer has controlling troops within VIEWRANGE of SQUARE    **/
X/**     Mark Lauer (elric@cs.su.oz.au)                                  **/
X/**     Greg Lesher (lesher@park.bu.edu)                                **/
X/*************************************************************************/
Xvisible(board, activecolor, x, y)
X  square_type *board;
X  int activecolor,
X      x, y;
X{
X  int i, j, i1, i2, j1, j2,
X      ipos, jpos;
X
X  /**** return TRUE if player owns square or horizon disabled ****/
X  if (!enable_personalhorizon[activecolor])
X    return (TRUE);
X  if (SQUARE(board,x,y)->color == activecolor)
X    return (TRUE);
X
X  if (!enable_hex)
X  {
X    i1 = x-viewrange[activecolor];
X    i2 = x+viewrange[activecolor];
X    j1 = y-viewrange[activecolor];
X    j2 = y+viewrange[activecolor];
X  }
X
X  /**** search for nearby squares of color color ****/
X  if (enable_wrap[activecolor])
X  {
X    for (i=i1; i<=i2; i++)
X      for (j=j1; j<=j2; j++)
X        if (SQUARE(board,MODX(i),MODY(j))->value[activecolor] > 0)
X          return (TRUE);
X  }
X  else
X  {
X    if (enable_hex)
X    {
X      for (i=0; i<hex_horizon_number; i++)
X      {
X
X        if (x%2 == 0)
X        {
X          ipos = x + hex_horizon_even[i][0];
X          jpos = y + hex_horizon_even[i][1];
X        }
X        else
X        {
X          ipos = x + hex_horizon_odd[i][0];
X          jpos = y + hex_horizon_odd[i][1];
X        }
X
X        ipos = (ipos<0) ? 0 : ipos;
X        ipos = (ipos>boardsizex-1) ? boardsizex-1 : ipos;
X        jpos = (jpos<0) ? 0 : jpos;
X        jpos = (jpos>boardsizey-1) ? boardsizey-1 : jpos;
X
X        if (SQUARE(board,ipos,jpos)->value[activecolor] > 0)
X          return (TRUE);
X      }
X    }
X    else
X    {
X      i1 = (i1<0) ? 0 : i1;
X      i2 = (i2>boardsizex-1) ? boardsizex-1 : i2;
X      j1 = (j1<0) ? 0 : j1;
X      j2 = (j2>boardsizey-1) ? boardsizey-1 : j2;
X
X      for (i=i1; i<=i2; i++)
X        for (j=j1; j<=j2; j++)
X          if (SQUARE(board,i,j)->value[activecolor] > 0)
X            return (TRUE);
X    }
X  }
X  return (FALSE);
X}
X
X
X/*************************************************************************/
X/**     outdatehorizon                                                  **/
X/**  Make area outdated for (possible) redrawing			**/
X/**     Mark Lauer (elric@cs.su.oz.au)                                  **/
X/**     Greg Lesher (lesher@park.bu.edu)                                **/
X/*************************************************************************/
Xoutdatehorizon (board, x, y, currentcolor)
X  square_type *board;
X  int x, y,
X      currentcolor;
X{
X  int i, j, i1, i2, j1, j2, ci, cj,
X      ipos, jpos,
X      range,
X      activecolor;
X
X  if (currentcolor >= nsides)
X  {
X    currentcolor = ALL;
X    range = maxviewrange;
X  }
X  else
X    range = viewrange[currentcolor]; 
X
X  i1 = x-range;
X  i2 = x+range;
X  j1 = y-range;
X  j2 = y+range;
X
X  /**** outdate VIEWRANGE area ****/
X  if (enable_anywrap)
X  {
X    for (i=i1; i<=i2; i++)
X      for (j=j1; j<=j2; j++)
X      {
X        ci = MODX(i);
X        cj = MODY(j);
X
X        /**** outdate differently colored squares ****/
X        activecolor = SQUARE(board,ci,cj)->color;
X        if (activecolor != none && activecolor != currentcolor)
X        {
X          if (outdated[ci][cj] == OK)
X            outdated[ci][cj] = currentcolor;
X          else if (outdated[ci][cj] != currentcolor)
X            outdated[ci][cj] = ALL;
X        }
X        else if (enable_anylocalmap && activecolor == none)
X        {
X          if (outdated[ci][cj] == OK)
X            outdated[ci][cj] = currentcolor;
X          else if (outdated[ci][cj] != currentcolor)
X            outdated[ci][cj] = ALL;
X        }
X        else if (activecolor == none && SQUARE(board,ci,cj)->growth > 50)
X        {
X          if (outdated[ci][cj] == OK)
X            outdated[ci][cj] = currentcolor;
X          else if (outdated[ci][cj] != currentcolor)
X            outdated[ci][cj] = ALL;
X        }
X        else if (currentcolor != ALL)
X        {
X          if (!SQUARE(board,ci,cj)->seen[currentcolor])
X          {
X            if (activecolor == none && enable_terrain) 
X            {
X              if (enable_sea && !enable_hills && !enable_forest)
X              {
X                if (SQUARE(board,ci,cj)->value[none] <= 0)
X                  outdated[ci][cj] = currentcolor;
X              }
X              else
X                outdated[ci][cj] = currentcolor;
X            }
X          }
X        }
X        
X        if (currentcolor != ALL)
X          SQUARE(board,ci,cj)->seen[currentcolor] = TRUE;
X      }
X  }
X  else
X  {
X    if (enable_hex)
X    {
X      i1 = 0;
X      i2 = 0;
X      j1 = 0;
X      j2 = hex_horizon_number-1;
X    }
X    else
X    {
X      i1 = (i1<0) ? 0 : i1;
X      i2 = (i2>boardsizex-1) ? boardsizex-1 : i2;
X      j1 = (j1<0) ? 0 : j1;
X      j2 = (j2>boardsizey-1) ? boardsizey-1 : j2;
X    }
X
X    for (i=i1; i<=i2; i++)
X      for (j=j1; j<=j2; j++)
X      {
X        if (enable_hex)
X        {
X          if (x%2 == 0)
X          {
X            ipos = x + hex_horizon_even[j][0];
X            jpos = y + hex_horizon_even[j][1];
X          }
X          else
X          {
X            ipos = x + hex_horizon_odd[j][0];
X            jpos = y + hex_horizon_odd[j][1];
X          }
X
X          ipos = (ipos<0) ? 0 : ipos;
X          ipos = (ipos>boardsizex-1) ? boardsizex-1 : ipos;
X          jpos = (jpos<0) ? 0 : jpos;
X          jpos = (jpos>boardsizey-1) ? boardsizey-1 : jpos;
X        }
X        else
X        {
X          ipos = i;
X          jpos = j;
X        }
X
X        activecolor = SQUARE(board,ipos,jpos)->color;
X        if (activecolor != none && activecolor != currentcolor)
X        {
X          if (outdated[ipos][jpos] == OK)
X            outdated[ipos][jpos] = currentcolor;
X          else if (outdated[ipos][jpos] != currentcolor)
X            outdated[ipos][jpos] = ALL;
X        }
X        else if (enable_anylocalmap && activecolor == none)
X        {
X          if (outdated[ipos][jpos] == OK)
X            outdated[ipos][jpos] = currentcolor;
X          else if (outdated[ipos][jpos] != currentcolor)
X            outdated[ipos][jpos] = ALL;
X        }
X        else if (activecolor == none && SQUARE(board,ipos,jpos)->growth > 50)
X        {
X          if (outdated[ipos][jpos] == OK)
X            outdated[ipos][jpos] = currentcolor;
X          else if (outdated[ipos][jpos] != currentcolor)
X            outdated[ipos][jpos] = ALL;
X        }
X        else if (currentcolor != ALL)
X        {
X          if (!(SQUARE(board,ipos,jpos)->seen[currentcolor]))
X          {
X            if (activecolor == none && enable_terrain) 
X            {
X              if (enable_sea && !enable_hills && !enable_forest)
X              {
X                if (SQUARE(board,ipos,jpos)->value[none] <= 0)
X                  outdated[ipos][jpos] = currentcolor;
X              }
X              else
X                outdated[ipos][jpos] = currentcolor;
X            }
X          }
X        }
X
X        if (currentcolor != ALL)
X          SQUARE(board,ipos,jpos)->seen[currentcolor] = TRUE;
X      }
X  }
X}
X
X
X#if VARMOUSE
X/*************************************************************************/
X/**   moveon                                                          	**/
X/** set the move command fields in the square                         	**/
X/**   J Greely <jgreely@cis.ohio-state.edu>                           	**/
X/*************************************************************************/
Xmoveon(square,dir)
X  square_type *square;
X  int dir[DIRS];
X{
X  int i;
X
X  /**** set direction flags ****/
X  square->move = 0;
X  for (i=0;i<directions;i++)
X  {
X    if (dir[i])
X      square->dir[i] = 1;;
X    square->move += square->dir[i];
X  }
X}
X#else
X/*************************************************************************/
X/**	setmove								**/
X/** set the move command fields in the square				**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/*************************************************************************/
Xsetmove(square,dir)
X  square_type *square;
X  int dir[DIRS];
X{
X  int i;
X
X  /**** set direction flags ****/
X  square->move = 0;
X  for (i=0;i<directions;i++)
X  {
X    if (dir[i])
X    {
X      if (square->dir[i])
X        square->dir[i] = 0;
X      else
X        square->dir[i] = 1;
X    }
X    if (square->dir[i])
X    {
X      square->move ++;
X    }
X  }
X}
X#endif
X
X
X#if VARMOUSE
X/*************************************************************************/
X/**   moveoff                                                         	**/
X/** unset the move command fields in the square				**/
X/**   J Greely <jgreely@cis.ohio-state.edu>                           	**/
X/*************************************************************************/
Xmoveoff(square,dir)
X  square_type *square;
X  int dir[DIRS];
X{
X  int i;
X
X  /**** set direction flags ****/
X  square->move = 0;
X  for (i=0;i<directions;i++)
X  {
X    if (dir[i])
X      square->dir[i] = 0;
X    square->move += square->dir[i];
X  }
X}
X#else
X/*************************************************************************/
X/**	forcemove							**/
X/** clear existing move commands and set the new one.			**/
X/**	Steve Lehar (slehar@park.bu.edu)				**/
X/*************************************************************************/
Xforcemove(square,dir)
X  square_type *square;
X  int dir[DIRS];
X{
X  int i;
X
X  /**** set direction flags ****/
X  square->move = 0;
X  for (i=0; i<directions; i++)
X  {
X    if (dir[i])
X      square->dir[i] = 1;
X    else
X      square->dir[i] = 0;
X    if (square->dir[i])
X    {
X      square->move ++;
X    }
X  }
X}
X#endif
END_OF_FILE
if test 39423 -ne `wc -c <'update.c'`; then
    echo shar: \"'update.c'\" unpacked with wrong size!
fi
# end of 'update.c'
fi
echo shar: End of archive 1 \(of 7\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
