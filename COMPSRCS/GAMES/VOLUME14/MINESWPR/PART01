Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i027:  minesweeper - Minesweeper Version 2.0 for VAX/VMS, Part01/01
Message-ID: <3322@master.CNA.TEK.COM>
Date: 4 Aug 92 19:52:09 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2680
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Jerry Jeremiah <jeremi@bode.ee.ualberta.ca>
Posting-number: Volume 14, Issue 27
Archive-name: minesweeper/Part01
Environment: VAX/VMS, VAX C

	[Although VAX specific, the code is commented where the Vax system
	 calls are in case anyone wants to try and convert it to another OS.
		-br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  README minesweeper.c
# Wrapped by billr@saab on Tue Aug  4 12:50:03 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(585 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XMineSweeper.
X
X
XThe goal is to find and flag all the mines in the minefield.
XYou win when the field is entirely cleared except for the flagged
Xmines.  You have exactly the right number of flags.
X
XThe number that shows up when you clear a spot tells how many mines
Xare on one of the eight neighbouring spots.  These are the clues you
Xhave to where the mines are.
X
XThe score calculated is approximately:
X
X        Number_of_squares_cleared_or_flagged * Number_of_mines
Xscore = ------------------------------------------------------
X             14%_of_size_of_Board * Number_of_hints_used
END_OF_FILE
if test 585 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'minesweeper.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'minesweeper.c'\"
else
echo shar: Extracting \"'minesweeper.c'\" \(55574 characters\)
sed "s/^X//" >'minesweeper.c' <<'END_OF_FILE'
X/*****************************************************************************/
X/*									     */
X/*	Troy Baker & Jerry Jeremiah	MineSweeper Version 2.0 for VAX	     */
X/*									     */
X/*	Help will be given to anyone whose name is not in the high score.    */
X/*									     */
X/*	This is version 2.0 of our minesweeper program.  Although we have    */
X/*	done extensive testing and we are not aware of any errors, if any    */
X/*	are found, bug reports may be made to jeremi@bode.ee.ualberta.ca     */
X/*									     */
X/*	If you do not want multiple versions of the high score file, you     */
X/*	may execute the following command after the game has been run once:  */
X/*									     */
X/*			set file/version=1 highscore.ms			     */
X/*									     */
X/*****************************************************************************/
X
X/*
XThe main problem with this program being portable is that several VAX-only
Xsystem services had to be used:
X
XOn a machine that does not buffer input,  getchar could have been used.
XAs it was we used a larger segment of code.
X
XOn another machine, the time will have to be called differently.  But it must
Xcome back integer.
X
XOn another machine, the terminal size will have to be called differently.
X
XThere is a function used that gets the user id for the purposes of the
Xhigh score identification.  It will have to be redone for another platform.
X
XThe escape sequenses may not work for anything but a VAX.
X*/
X
X#include stdio
X#include string
X#include jpidef
X#include descrip
X#include libdtdef
X#include ssdef
X#include iodef
X#include rmsdef
X
X#define NORMAL    "\033[0m"
X#define BOLD      "\033[1m"
X#define UNDERLINE "\033[4m"
X#define FLASH     "\033[5m"
X#define REVERSE   "\033[7m"
X
Xtypedef
X	struct entry 
X		{
X		int x;
X		int y;
X		struct entry *next;
X		}
X	STACK;
X
Xtypedef
X	struct element 
X		{
X		int cover;	/*This tells if it is selected or flagged*/
X		int board;	/*This is the mines and numbers*/
X		int stack;	/*This tells if it is on the stack*/
X		}
X	TABLE;
X
XTABLE	*game1,**game;			/*These will be our array*/
XSTACK	*bottom,*top;			/*These are our stack pointers*/
Xint     quit_flag;			
Xint	mine_total=0;			/*This is the real number of mines*/
Xint	XSIZE,YSIZE,MINES,DEBUG=0;	/*These are the command line params*/ 
Xint	slength,swidth;			/*This is the game size*/
Xint	length,width;			/*This is the terminal size*/
Xint	hint=0,HINTS=3;
Xint	view_flag;
Xint	real_flag_counter=0,flag_counter=0,counter=0;
X					/*These are our win tracking counters*/
X
X/*This uses DEC escape sequences to clear the screen.*/
X
Xclear()
X{
Xprintf("\033[0m\033[2J\033[1;1H");
X}
X
X/*This uses DEC escape sequences to locate the cursor.*/
X
Xlocate(x,y)
Xint	x,y;
X{
Xprintf("\033[%d;%dH",y+2,x+2);
X}
X
X/*This uses DEC escape sequences to make big characters.*/
X
Xbig(str)
Xchar str[]; 
X{
Xclear();
Xlocate(0,YSIZE);		
Xprintf("\033#3%s\n",str);
Xlocate(0,YSIZE+1);
Xprintf("\033#4%s",str);
Xexit(0);
X}
X
X/*This uses DEC escape sequences to turn off all other DEC escape sequences.*/
X
Xnormal()
X{
Xprintf(NORMAL);
X}                                         
X
X/*This uses DEC escape sequences to bold the characters printed after this.*/
X
Xbold()
X{
Xprintf(BOLD);
X}
X
X/*This uses DEC escape sequences to flash the characters printed after this.*/
X
Xflash()
X{
Xprintf(FLASH);
X}
X
X/*This uses DEC escape sequences to reverse the characters printed after this.*/
X
Xreverse()
X{
Xprintf(REVERSE);
X}
X
X/*This uses DEC escape sequences to underline the chars printed after this.*/
X
Xunderline()
X{
Xprintf(UNDERLINE);
X}
X
X/*This pushes a location on the stack.*/
X
Xpush(x,y)
Xint	x,y;
X{
XSTACK	*piece;
X
Xgame[x][y].stack = 1;
Xpiece = (STACK *) malloc( sizeof(STACK) );
Xpiece->x	= x;
Xpiece->y	= y;
Xpiece->next	= top;
Xtop		= piece;
X}
X
X/*This routine is accessed when there is a stack error (Never hopefully)
X  It lists the contents of the stack.*/
X
Xlinks()
X{
XSTACK *piece;
X
Xpiece = top;
Xif (atbottom(piece)!=1)
X	{
X	locate (0,YSIZE);
X	printf (">");
X	}
Xwhile (atbottom(piece)!=1)
X	{
X	printf ("%d,%d ",piece->x,piece->y);
X	piece = piece->next;
X	}
Xif (atbottom(piece)!=1)
X	{
X	printf ("\n");
X	}
X}
X
X/*Takes the top stack piece and frees the memory.*/
X
Xpop(x,y)
Xint	*x,*y;
X{
XSTACK	*piece;
X
Xpiece	= top;
Xif (isempty()!=1)
X	{
X	*x	= piece->x;
X	*y	= piece->y;
X	top	= piece->next;
X	free (piece);
X	game[*x][*y].stack = 0;
X	}
Xelse
X	{
X	links();
X	printf("Stack Error!");
X	exit(1);
X	}
X}
X
X/*Logical routine returns true if the pointer is at the bottom of the stack.*/
X
Xatbottom(ptr)
XSTACK	*ptr;
X{
Xif (ptr == bottom) return (1);
X}
X
X/*Logical routine returns true if the stack is empty.*/
X
Xisempty()
X{
Xif (top == bottom) return (1);
X}
X
X/*Creates the stack by initializing the pointers*/
X
Xcreate()
X{
Xtop = NULL;
Xbottom = NULL;
X}
X
X/*Pops the stack top, displays it, and pushes the neighbours on the stack if
X  what it popped off was a zero.  Continues until the stack is empty.  Is
X  basically a flood fill routine.*/
X
Xexpose(x,y)
Xint	x,y;
X{
X
Xif (game[x][y].cover != 'X') counter++;
Xlocate(x,y);
Xgame[x][y].cover = 'X';
Xif (game[x][y].board != 0)
X	{
X	if (view_flag == 0)
X		{
X		bold();
X		view_flag = 1;
X		}
X	else	if (view_flag != 1)
X		{
X		normal();
X		bold();
X		view_flag = 1;
X		}
X	printf ("%d",game[x][y].board);
X	}
Xelse
X	{
X	if (view_flag != 0)
X		{
X		normal();
X		view_flag = 0;
X		}
X	printf(" ");
X	}
X
Xif (game[x][y].board == 0)
X	{
X	if (x==0 && y==0)
X		{
X		if (game[x+1][y].cover==' '	&&
X		    game[x+1][y].stack==0	)   	push(x+1,y);
X		if (game[x][y+1].cover==' '	&&
X		    game[x][y+1].stack==0	)	push(x,y+1);
X		if (game[x+1][y+1].cover==' '	&&
X		    game[x+1][y+1].stack==0	)	push(x+1,y+1);
X		}
X	if (x>0 && x<XSIZE-1 && y==0)
X		{
X		if (game[x-1][y].cover==' '	&&
X		    game[x-1][y].stack==0	)	push(x-1,y);
X		if (game[x+1][y].cover==' '	&&
X		    game[x+1][y].stack==0	)	push(x+1,y);
X		if (game[x-1][y+1].cover==' '	&&
X		    game[x-1][y+1].stack==0	)	push(x-1,y+1);
X		if (game[x][y+1].cover==' '	&&
X		    game[x][y+1].stack==0	)	push(x,y+1);
X		if (game[x+1][y+1].cover==' '	&&
X		    game[x+1][y+1].stack==0	)	push(x+1,y+1);
X		}
X	if (x==XSIZE-1 && y==0)
X		{
X		if (game[x-1][y].cover==' '	&&
X		    game[x-1][y].stack==0	)	push(x-1,y);
X		if (game[x-1][y+1].cover==' '	&&
X		    game[x-1][y+1].stack==0	)	push(x-1,y+1);
X		if (game[x][y+1].cover==' '	&&
X		    game[x][y+1].stack==0	)	push(x,y+1);
X		}
X	if (x==0 && y>0 && y<YSIZE-1)
X		{
X		if (game[x][y-1].cover==' '	&&
X		    game[x][y-1].stack==0	)	push(x,y-1);
X		if (game[x+1][y-1].cover==' '	&&
X		    game[x+1][y-1].stack==0	)	push(x+1,y-1);
X		if (game[x+1][y].cover==' '	&&
X		    game[x+1][y].stack==0	)	push(x+1,y);
X		if (game[x][y+1].cover==' '	&&
X		    game[x][y+1].stack==0	)	push(x,y+1);
X		if (game[x+1][y+1].cover==' '	&&
X		    game[x+1][y+1].stack==0	)	push(x+1,y+1);
X		}
X	if (x>0 && x<XSIZE-1 && y>0 && y<YSIZE-1)
X		{
X		if (game[x-1][y-1].cover==' '	&&
X		    game[x-1][y-1].stack==0	)	push(x-1,y-1);
X		if (game[x][y-1].cover==' '	&&
X		    game[x][y-1].stack==0	)	push(x,y-1);
X		if (game[x+1][y-1].cover==' '	&&
X		    game[x+1][y-1].stack==0	)	push(x+1,y-1);
X		if (game[x-1][y].cover==' '	&&
X		    game[x-1][y].stack==0	)	push(x-1,y);
X		if (game[x+1][y].cover==' '	&&
X		    game[x+1][y].stack==0	)	push(x+1,y);
X		if (game[x-1][y+1].cover==' '	&&
X		    game[x-1][y+1].stack==0	)	push(x-1,y+1);
X		if (game[x][y+1].cover==' '	&&
X		    game[x][y+1].stack==0	)	push(x,y+1);
X		if (game[x+1][y+1].cover==' '	&&
X		    game[x+1][y+1].stack==0	)	push(x+1,y+1);
X		}
X	if (x==XSIZE-1 && y>0 && y<YSIZE-1)
X		{
X		if (game[x-1][y-1].cover==' '	&&
X		    game[x-1][y-1].stack==0	)	push(x-1,y-1);
X		if (game[x][y-1].cover==' '	&&
X		    game[x][y-1].stack==0	)	push(x,y-1);
X		if (game[x-1][y].cover==' '	&&
X		    game[x-1][y].stack==0	)	push(x-1,y);
X		if (game[x-1][y+1].cover==' '	&&
X		    game[x-1][y+1].stack==0	)	push(x-1,y+1);
X		if (game[x][y+1].cover==' '	&&
X		    game[x][y+1].stack==0	)	push(x,y+1);
X		}
X	if (x==0 && y==YSIZE-1)
X		{
X		if (game[x][y-1].cover==' '	&&
X		    game[x][y-1].stack==0	)	push(x,y-1);
X		if (game[x+1][y-1].cover==' '	&&
X		    game[x+1][y-1].stack==0	)	push(x+1,y-1);
X		if (game[x+1][y].cover==' '	&&
X		    game[x+1][y].stack==0	)	push(x+1,y);
X		}
X	if (x>0 && x<XSIZE-1 && y==YSIZE-1)
X		{
X		if (game[x-1][y-1].cover==' '	&&
X		    game[x-1][y-1].stack==0	)	push(x-1,y-1);
X		if (game[x][y-1].cover==' '	&&
X		    game[x][y-1].stack==0	)	push(x,y-1);
X		if (game[x+1][y-1].cover==' '	&&
X		    game[x+1][y-1].stack==0	)	push(x+1,y-1);
X		if (game[x-1][y].cover==' '	&&
X		    game[x-1][y].stack==0	)	push(x-1,y);
X		if (game[x+1][y].cover==' '	&&
X		    game[x+1][y].stack==0	)	push(x+1,y);
X		}
X	if (x==XSIZE-1 && y==YSIZE-1)
X		{
X		if (game[x-1][y-1].cover==' '	&&
X		    game[x-1][y-1].stack==0	)	push(x-1,y-1);
X		if (game[x][y-1].cover==' '	&&
X		    game[x][y-1].stack==0	)	push(x,y-1);
X		if (game[x-1][y].cover==' '	&&
X		    game[x-1][y].stack==0	)	push(x-1,y);
X		}
X	while (isempty()!=1)
X		{
X		pop(&x,&y);
X
X		if (game[x][y].cover != 'X') counter++;
X		locate(x,y);
X		game[x][y].cover = 'X';
X		if (game[x][y].board != 0)
X			{
X			if (view_flag == 0)
X				{
X				bold();
X				view_flag = 1;
X				}
X			else	if (view_flag != 1)
X				{
X				normal();
X				bold();
X				view_flag = 1;
X				}
X			printf ("%d",game[x][y].board);
X			}
X		else
X			{
X			if (view_flag != 0)
X				{
X				normal();
X				view_flag = 0;
X				}
X			printf(" ");
X			}
X
X		if (game[x][y].board == 0)
X			{
X			if (x==0 && y==0)
X				{
X				if (game[x+1][y].cover==' '	&&
X				    game[x+1][y].stack==0	) push(x+1,y);
X				if (game[x][y+1].cover==' '	&&
X				    game[x][y+1].stack==0	) push(x,y+1);
X				if (game[x+1][y+1].cover==' '	&&
X				    game[x+1][y+1].stack==0	) push(x+1,y+1);
X				}
X			if (x>0 && x<XSIZE-1 && y==0)
X				{
X				if (game[x-1][y].cover==' '	&&
X				    game[x-1][y].stack==0	) push(x-1,y);
X				if (game[x+1][y].cover==' '	&&
X				    game[x+1][y].stack==0	) push(x+1,y);
X				if (game[x-1][y+1].cover==' '	&&
X				    game[x-1][y+1].stack==0	) push(x-1,y+1);
X				if (game[x][y+1].cover==' '	&&
X				    game[x][y+1].stack==0	) push(x,y+1);
X				if (game[x+1][y+1].cover==' '	&&
X				    game[x+1][y+1].stack==0	) push(x+1,y+1);
X				}
X			if (x==XSIZE-1 && y==0)
X				{
X				if (game[x-1][y].cover==' '	&&
X				    game[x-1][y].stack==0	) push(x-1,y);
X				if (game[x-1][y+1].cover==' '	&&
X				    game[x-1][y+1].stack==0	) push(x-1,y+1);
X				if (game[x][y+1].cover==' '	&&
X				    game[x][y+1].stack==0	) push(x,y+1);
X				}
X			if (x==0 && y>0 && y<YSIZE-1)
X				{
X				if (game[x][y-1].cover==' '	&&
X				    game[x][y-1].stack==0	) push(x,y-1);
X				if (game[x+1][y-1].cover==' '	&&
X				    game[x+1][y-1].stack==0	) push(x+1,y-1);
X				if (game[x+1][y].cover==' '	&&
X				    game[x+1][y].stack==0	) push(x+1,y);
X				if (game[x][y+1].cover==' '	&&
X				    game[x][y+1].stack==0	) push(x,y+1);
X				if (game[x+1][y+1].cover==' '	&&
X				    game[x+1][y+1].stack==0	) push(x+1,y+1);
X				}
X			if (x>0 && x<XSIZE-1 && y>0 && y<YSIZE-1)
X				{
X				if (game[x-1][y-1].cover==' '	&&
X				    game[x-1][y-1].stack==0	) push(x-1,y-1);
X				if (game[x][y-1].cover==' '	&&
X				    game[x][y-1].stack==0	) push(x,y-1);
X				if (game[x+1][y-1].cover==' '	&&
X				    game[x+1][y-1].stack==0	) push(x+1,y-1);
X				if (game[x-1][y].cover==' '	&&
X				    game[x-1][y].stack==0	) push(x-1,y);
X				if (game[x+1][y].cover==' '	&&
X				    game[x+1][y].stack==0	) push(x+1,y);
X				if (game[x-1][y+1].cover==' '	&&
X				    game[x-1][y+1].stack==0	) push(x-1,y+1);
X				if (game[x][y+1].cover==' '	&&
X				    game[x][y+1].stack==0	) push(x,y+1);
X				if (game[x+1][y+1].cover==' '	&&
X				    game[x+1][y+1].stack==0	) push(x+1,y+1);
X				}
X			if (x==XSIZE-1 && y>0 && y<YSIZE-1)
X				{
X				if (game[x-1][y-1].cover==' '	&&
X				    game[x-1][y-1].stack==0	) push(x-1,y-1);
X				if (game[x][y-1].cover==' '	&&
X				    game[x][y-1].stack==0	) push(x,y-1);
X				if (game[x-1][y].cover==' '	&&
X				    game[x-1][y].stack==0	) push(x-1,y);
X				if (game[x-1][y+1].cover==' '	&&
X				    game[x-1][y+1].stack==0	) push(x-1,y+1);
X				if (game[x][y+1].cover==' '	&&
X				    game[x][y+1].stack==0	) push(x,y+1);
X				}
X			if (x==0 && y==YSIZE-1)
X				{
X				if (game[x][y-1].cover==' '	&&
X				    game[x][y-1].stack==0	) push(x,y-1);
X				if (game[x+1][y-1].cover==' '	&&
X				    game[x+1][y-1].stack==0	) push(x+1,y-1);
X				if (game[x+1][y].cover==' '	&&
X				    game[x+1][y].stack==0	) push(x+1,y);
X				}
X			if (x>0 && x<XSIZE-1 && y==YSIZE-1)
X				{
X				if (game[x-1][y-1].cover==' '	&&
X				    game[x-1][y-1].stack==0	) push(x-1,y-1);
X				if (game[x][y-1].cover==' '	&&
X				    game[x][y-1].stack==0	) push(x,y-1);
X				if (game[x+1][y-1].cover==' '	&&
X				    game[x+1][y-1].stack==0	) push(x+1,y-1);
X				if (game[x-1][y].cover==' '	&&
X				    game[x-1][y].stack==0	) push(x-1,y);
X				if (game[x+1][y].cover==' '	&&
X				    game[x+1][y].stack==0	) push(x+1,y);
X				}
X			if (x==XSIZE-1 && y==YSIZE-1)
X				{
X				if (game[x-1][y-1].cover==' '	&&
X				    game[x-1][y-1].stack==0	) push(x-1,y-1);
X				if (game[x][y-1].cover==' '	&&
X				    game[x][y-1].stack==0	) push(x,y-1);
X				if (game[x-1][y].cover==' '	&&
X				    game[x-1][y].stack==0	) push(x-1,y);
X				}
X		
X			}
X		}
X	}
X}
X		
X/*Run when a square is flagged (the user believes it to be a mine).*/
X
Xflag(x,y)
Xint	x,y;
X{
X
Xif (game[x][y].cover != 'X')
X	{
X	locate(x,y);
X	game[x][y].cover = 'F';
X	if (view_flag == 0)
X		{
X		reverse();
X		view_flag = 2;
X		}
X	else	if (view_flag != 2)
X		{
X		normal();
X		reverse();
X		view_flag = 2;
X		}
X	printf ("F");
X	if (game[x][y].board==9) real_flag_counter++; 
X	flag_counter++;
X
X	locate(72,length);
X	if (view_flag != 0)
X		{
X		normal();
X		view_flag = 0;
X		}
X	printf("%4d",mine_total-flag_counter);
X	}
X}
X
X/*Run when a square is unflagged (the user has changed his/her mind).*/
X
Xunflag(x,y)
Xint	x,y;
X{
X
Xlocate(x,y);
Xgame[x][y].cover = ' ';
Xif (view_flag != 0)
X	{
X	normal();
X	view_flag = 0;
X	}
Xprintf ("+");
Xif (game[x][y].board==9) real_flag_counter--; 
Xflag_counter--;
X
Xlocate(72,length);
Xif (view_flag != 0)
X	{
X	normal();
X	view_flag = 0;
X	}
Xprintf("%4d",mine_total-flag_counter);
X}
X
X/*Create an empty highscore file in the current directory*/
X
Xhighscorefile()
X{
Xchar	name[150];
Xint	context;
Xint	i;
XFILE	*fileptr;
X
Xcontext=0;
Xfind_file("highscore.ms",name,&context);
Xif (context == 0)
X	{
X	fileptr=fopen("highscore.ms","w");
X	fprintf(fileptr,"0\n");
X	fprintf(fileptr,"0\n");
X	fclose(fileptr);
X	}
X}
X
X/*
X * For a given file specification (spec) returns one file matching this
X * specification upon each call in the order they appear in the directory.
X * If (context) is equal to zero before the call, the file search will
X * start from the beginning.  If context returns a value of zero, no more
X * files were found.
X */
X
Xfind_file(spec,name,context)
X	char *spec;
X	char *name;
X	int *context;
X	{
X	int status;
X	char *c_ptr;
X	struct dsc$descriptor file_spec = {
X		149,
X		DSC$K_DTYPE_T,
X		DSC$K_CLASS_S,
X		spec };
X	struct dsc$descriptor file_name = {
X		149,
X		DSC$K_DTYPE_T,
X		DSC$K_CLASS_S,
X		name };
X
X	file_spec.dsc$w_length=strlen(spec);
X	status=lib$find_file(&file_spec,&file_name,context);
X	if(status!=RMS$_NORMAL) *context=0;
X	name[file_name.dsc$w_length]='\0';
X	c_ptr=strchr(name,' ');
X	*c_ptr='\0';
X	}
X
X/*
Xgets a string (replacing scanf) returning when a return is pressed
Xno matter whether is has only whitespace or what.  The flag allows
Xor disallows spaces and certain control chars used elsewhere to create
Xbold, reverse, flashing, or underlined text.
X*/
X
Xgetstring(char str[],int amount,int type)
X{
Xint	i=0,chflag=0,loop,maxi=0;
X
X/*The following is needed for the DEC system service that gets a key.  Will
X  have to be modified to work on non-VAX equipment*/
X
X/*===================================*/
Xchar	keyname[20];
Xint	keyid,key;
Xstruct	dsc$descriptor name = {
X	19,
X	DSC$K_DTYPE_T,
X	DSC$K_CLASS_S,
X	keyname };
X
XSMG$CREATE_VIRTUAL_KEYBOARD(&keyid);
X/*===================================*/
X
Xi=0;maxi=0;
Xfor (loop=0;loop<amount;loop++)
X	str[loop]='\0';
Xstr[strlen(str)]='\0';
X
X/*The following is needed for the DEC system service that gets a key.  Will
X  have to be modified to work on non-VAX equipment*/
X
X/*===================================*/
X	SMG$READ_KEYSTROKE(&keyid,&key);
X	SMG$KEYCODE_TO_NAME(&key,&name);
X	keyname[strlen(keyname)-strlen(strchr(keyname,' '))] = '\0';
X	if (strcmp(keyname,"")==0) strcpy(keyname," ");
X/*===================================*/
X
Xwhile (strcmp(keyname,"CTRLM")!=0)
X	{
X
X	if (	strcmp(keyname,"LEFT") == 0)
X		{
X		if (i>0)
X			{
X			i--;
X			printf("\033[D");
X			}
X		chflag=1;
X		}
X
X	if (	strcmp(keyname,"RIGHT") == 0)
X		{
X		if (i<maxi)
X			{
X			i++;
X			printf("\033[C");
X			}
X		chflag=1;
X		}
X
X	if (	keyname[0] == 127)
X		{
X		if (i>0)
X			{
X			i--;
X			printf("\033[D");
X
X			for (loop=i;loop<maxi;loop++)
X				{
X				str[loop]=str[loop+1];
X			if (	str[loop] == '\002')
X				{
X				reverse();
X				printf("B");
X				normal();
X				}
X			else	
X				{if (	str[loop] == '\006')
X					{
X					reverse();
X					printf("F");
X					normal();
X					}
X			else	
X				{if (	str[loop] == '\016')
X					{
X					reverse();
X					printf("N");
X					normal();
X					}
X			else	
X				{if (	str[loop] == '\022')
X					{
X					reverse();
X					printf("R");
X					normal();
X					}
X			else
X				{if (	str[loop] == '\025')
X					{
X					reverse();
X					printf("U");
X					normal();
X					}
X			else	
X				{if (	str[loop] == '\001')
X					{
X					reverse();
X					printf(" ");
X					normal();
X					}
X			else	printf("%c",str[loop]);
X				}}}}}}
X			
X			str[maxi]='\0';
X			printf(" ");
X
X			for (loop=maxi;loop>i;loop--)
X				printf("\033[D");
X
X			maxi--;
X			}
X		chflag=1;
X		}
X
X	if (	strcmp(keyname,"CTRLE") == 0)
X		{
X		if (i<maxi)
X			{
X			for (loop=i;loop<maxi;loop++)
X				printf("\033[C");
X			i=maxi;
X			}
X		chflag=1;
X		}
X
X	if (	strcmp(keyname,"CTRLH") == 0)
X		{
X		if (i>0)
X			{
X			for (loop=i;loop>0;loop--)
X				printf("\033[D");
X			i=0;
X			}
X		chflag=1;
X		}
X
X	if (	strcmp(keyname,"CTRLB") == 0	&&	type == 0)
X		{
X		str[i++]='\002';
X		reverse();
X		printf("B");
X		normal();
X		chflag=1;
X		}
X	if (	strcmp(keyname,"CTRLF") == 0	&&	type == 0)
X		{
X		str[i++]='\006';
X		reverse();
X		printf("F");
X		normal();
X		chflag=1;
X		}
X	if (	strcmp(keyname,"CTRLN") == 0	&&	type == 0)
X		{
X		str[i++]='\016';
X		reverse();
X		printf("N");
X		normal();
X		chflag=1;
X		}
X	if (	strcmp(keyname,"CTRLR") == 0	&&	type == 0)
X		{
X		str[i++]='\022';
X		reverse();
X		printf("R");
X		normal();
X		chflag=1;
X		}
X	if (	strcmp(keyname,"CTRLU") == 0	&&	type == 0)
X		{
X		str[i++]='\025';
X		reverse();
X		printf("U");
X		normal();
X		chflag=1;
X		}
X	if (	strcmp(keyname," ") == 0)
X		{
X		if (type == 0)
X			str[i++]='\001';
X		else
X			{
X			if (type == 1)
X				str[i++]='_';
X			else
X				str[i++]=' ';
X			}
X		printf(" ");
X		chflag=1;
X		}
X
X	if (chflag==1)
X		chflag=0;
X	else
X		{
X		for (loop=0;loop<strlen(keyname);loop++)
X			{
X			if (i<amount)
X				{
X				str[i++]=keyname[loop];
X				printf("%c",keyname[loop]);
X				}
X			}
X		chflag=0;
X		}
X
X	if (i>maxi) maxi=i;
X
X/*The following is needed for the DEC system service that gets a key.  Will
X  have to be modified to work on non-VAX equipment*/
X
X/*===================================*/
X	SMG$READ_KEYSTROKE(&keyid,&key);
X	SMG$KEYCODE_TO_NAME(&key,&name);
X	keyname[strlen(keyname)-strlen(strchr(keyname,' '))] = '\0';
X	if (strcmp(keyname,"")==0) strcpy(keyname," ");
X/*===================================*/
X	}
X}
X
X/*this adds to and from the highscore file and also displays it*/
X
Xhigh (int flag)
X{
X
Xtypedef
X	struct	HIGHSCORE	{
X			 	char			name[60];
X			 	char			username[60];
X				int			score;
X				int			games;
X				struct	HIGHSCORE	*next;
X				}
X	HISCORE;
X
XHISCORE	*hiscore,*deadscore,*list,*track,*temp,*current;
X
Xchar	name[60],username[60],dumstr[60];
Xint	score,games,dumint,chflag=0,
X	entry,i,count,add_entry,
X	entry_num,deadentry_num;
XFILE	*fileptr;
X
X/*The following is needed for the DEC system service that gets a username.  Will
X  have to be modified to work on non-VAX equipment*/
X
X/*===================================*/
Xstruct	dsc$descriptor u_name = {
X	19,
X	DSC$K_DTYPE_T,
X	DSC$K_CLASS_S,
X	name };
Xstruct	dsc$descriptor user_name = {
X	19,
X	DSC$K_DTYPE_T,
X	DSC$K_CLASS_S,
X	username };
X/*===================================*/
X
Xclear();
X
X/* (flag==3) is a test for whether the username is in the highscore file*/
X/* (flag==2) shows the highscore file*/
X/* (flag==1) is if you win*/
X/* (flag==0) is if you lose*/
X
Xif (flag!=3)
X	{
X	score	=
X	( ( real_flag_counter + counter )
X	* ( mine_total%( XSIZE * YSIZE - 4 ) )
X	/ ( XSIZE * YSIZE * 147 / 10000 * 10 + 10 )
X	/ ( hint + 1 )
X	+ 1 )
X	* (-2 * quit_flag + 1);
X	}
X	games = 1;
X
Xif (flag==2)
X	printf("You have %d points!!!\n",score * (-2 * quit_flag + 1));
Xif (flag==1)
X	printf("You won with %d points!!!\n\n",score);
Xif (flag==0)
X	{
X	if (quit_flag==1)
X		printf("You quit after accumulating %d points!!!\n\n",
X			score * (-2 * quit_flag + 1));
X	else
X		printf("You died after accumulating %d points!!!\n\n",score);
X	}
X
Xif (score==0) flag=2;
X
X/*The following is needed for the DEC system service that gets a username.  Will
X  have to be modified to work on non-VAX equipment*/
X
X/*===================================*/
X	lib$getjpi(&(JPI$_USERNAME),0,0,0,&user_name,0);
X	username[strlen(username)-strlen(strchr(username,' '))] = '\0';
X/*===================================*/
X
Xif (flag!=2 && flag!=3)
X	{
X	printf("Enter a name for the high score file: ");
X	getstring(name,40,0);
X	printf("\n");
X
X	if (strlen(name)==0)
X		{
X/*Another system service used to replace a blank string with the username*/
X/*The following is needed for the DEC system service that gets a username.  Will
X  have to be modified to work on non-VAX equipment*/
X
X/*===================================*/
X		lib$getjpi(&(JPI$_USERNAME),0,0,0,&u_name,0);
X		name[strlen(name)-strlen(strchr(name,' '))] = '\0';
X/*===================================*/
X		}
X
X	if ((current = (HISCORE *) malloc(sizeof(HISCORE))) == NULL)
X		{
X		printf ("Cannot open space.");
X		exit (1);
X		}
X
X	strcpy(current->name,name);
X	strcpy(current->username,username);
X	current->score=score;
X	current->games=games;
X	current->next=NULL;
X	}
X
Xif ((hiscore = (HISCORE *) malloc(sizeof(HISCORE))) == NULL)
X	{
X	printf ("Cannot open space.");
X	exit (1);
X	}
X
Xstrcpy(hiscore->name," ");
Xstrcpy(hiscore->username,"MineSweeper");
Xhiscore->score=0;
Xhiscore->games=0;
Xhiscore->next=NULL;
X
Xif ((deadscore = (HISCORE *) malloc(sizeof(HISCORE))) == NULL)
X	{
X	printf ("Cannot open space.");
X	exit (1);
X	}
X
Xstrcpy(deadscore->name," ");
Xstrcpy(deadscore->username,"MineSweeper");
Xdeadscore->score=0;
Xdeadscore->games=0;
Xdeadscore->next=NULL;
X
Xfileptr=fopen("highscore.ms","r");
Xif (fileptr == NULL)
X	{
X	highscorefile();
X	fileptr = fopen ("highscore.ms","r");
X	}
X
Xfscanf(fileptr,"%d",&entry_num);
X
Xlist = hiscore;
Xfor(i=0;i<entry_num;i++)
X	{
X	if ((temp = (HISCORE *) malloc(sizeof(HISCORE))) == NULL)
X		{
X		printf ("Cannot open space.  High score file is too big!");
X		exit (1);
X		}
X
X	fscanf(fileptr,"%s",&dumstr);
X	strcpy(temp->name,dumstr);
X	fscanf(fileptr,"%s",&dumstr);
X	strcpy(temp->username,dumstr);
X	fscanf(fileptr,"%d",&dumint);
X	temp->score=dumint;
X	fscanf(fileptr,"%d",&dumint);
X	temp->games=dumint;
X	temp->next=NULL;
X
X	list->next = temp;
X	list = list->next;
X	}
X
Xfscanf(fileptr,"%d",&deadentry_num);
X
Xlist = deadscore;
Xfor(i=0;i<deadentry_num;i++)
X	{
X	if ((temp = (HISCORE *) malloc(sizeof(HISCORE))) == NULL)
X		{
X		printf ("Cannot open space.  High score file is too big!");
X		exit (1);
X		}
X
X	fscanf(fileptr,"%s",&dumstr);
X	strcpy(temp->name,dumstr);
X	fscanf(fileptr,"%s",&dumstr);
X	strcpy(temp->username,dumstr);
X	fscanf(fileptr,"%d",&dumint);
X	temp->score=dumint;
X	fscanf(fileptr,"%d",&dumint);
X	temp->games=dumint;
X	temp->next=NULL;
X
X	list->next = temp;
X	list = list->next;
X	}
X
Xfclose(fileptr);
X
Xif (flag==3)
X	{
X	list=hiscore->next;
X	track=hiscore;
X	while(	list != NULL)
X 		{
X		if (strcmp(list->username,username)==0)
X			return(1);
X		list=list->next;
X		track=track->next;
X		}
X	list=deadscore->next;
X	track=deadscore;
X	while(	list != NULL)
X		{
X		if (strcmp(list->username,username)==0)
X			return(1);
X		list=list->next;
X		track=track->next;
X		}
X	return(0);
X	}
X
Xif (flag==1)
X	{
X	list=hiscore->next;
X	track=hiscore;
X	add_entry=0;
X	while(list != NULL)
X		{
X		if (strcmp(list->name,current->name)==0)
X			{
X			add_entry=1;
X			list->score = list->score + current->score; 
X			list->games++;
X			free(current);
X			current=list;
X			}
X		list=list->next;
X		track=track->next;
X		}
X	if (add_entry==0)
X		{
X		list=hiscore->next;
X		track=hiscore;
X		while(	list != NULL	&&
X			list->score > current->score)
X			{
X			list=list->next;
X			track=track->next;
X			}
X		current->next=list;
X		track->next=current;
X		}
X	}
Xif (flag==0)
X	{
X	list=hiscore->next;
X	track=hiscore;
X	while(	list != NULL)
X		{
X		if (strcmp(list->name,current->name)==0)
X			{
X			current->score = current->score + list->score;
X			current->games++;
X			temp=list;
X			list=temp->next;
X			track->next=list;
X			free(temp);
X			}
X		else
X			{
X			list=list->next;
X			track=track->next;
X			}
X		}
X
X	list=deadscore->next;
X	track=deadscore;
X	add_entry=0;
X	while(	list != NULL	&&
X		add_entry==0)
X		{
X		if (list->score>current->score)
X			{
X			list=list->next;
X			track=track->next;
X			}
X		else
X			add_entry=1;
X		}
X	current->next=list;
X	track->next=current;
X	}
X
Xif (flag!=2)
X	{
X	fileptr=fopen("highscore.ms","w");
X
X	count=0;
X	list = hiscore->next;
X	while (list != NULL)
X		{
X		count++;
X		list = list->next;
X		}
X	fprintf(fileptr,"%d\n",count);
X
X	list = hiscore->next;
X	while (list != NULL)
X		{
X		fprintf(fileptr," %s",list->name);
X		fprintf(fileptr," %s",list->username);
X		fprintf(fileptr," %d",list->score);
X		fprintf(fileptr," %d",list->games);
X		fprintf(fileptr,"\n");
X		list = list->next;
X		}
X
X	count=0;
X	list = deadscore->next;
X	while (list != NULL)
X		{
X		count++;
X		list = list->next;
X		}
X	fprintf(fileptr,"%d\n",count);
X
X	list = deadscore->next;
X	while (list != NULL)
X		{
X		fprintf(fileptr," %s",list->name);
X		fprintf(fileptr," %s",list->username);
X		fprintf(fileptr," %d",list->score);
X		fprintf(fileptr," %d",list->games);
X		fprintf(fileptr,"\n");
X		list = list->next;
X		}
X
X	fclose(fileptr);
X	}
X
Xprintf("\n");
Xprintf("		High Scores:\nStatus  Games      Score  Rank  Name\n");
X
Xcount=0;
Xlist = hiscore->next;
Xwhile (list != NULL)
X	{
X	count++;
X	if (count<4 || strcmp(list->name,current->name)==0 || flag==2)
X		{
X		normal();
X		if (list==current) bold();
X		printf("Won:    ");
X		printf("%5d ",list->games);
X		printf("%10d ",list->score);
X		printf("%5d  ",count);
X		if (list==current) normal();
X	
X		chflag=0;
X		i=0;
X		while ( (list->name)[i] != '\0')
X			{
X			if ((list->name)[i] == '\001')
X				{
X				printf(" ");
X				chflag=1;
X				}
X			if ((list->name)[i] == '\002')
X				{
X				bold();
X				chflag=1;
X				}
X			if ((list->name)[i] == '\006')
X				{
X				flash();
X				chflag=1;
X				}
X			if ((list->name)[i] == '\016')
X				{
X				normal();
X				chflag=1;
X				}
X			if ((list->name)[i] == '\022')
X				{
X				reverse();
X				chflag=1;
X				}
X			if ((list->name)[i] == '\025')
X				{
X				underline();
X				chflag=1;
X				}
X			if (chflag != 1)
X				{
X				printf("%c",(list->name)[i]);
X				}
X			chflag=0;
X			i++;
X			}
X	        printf("\n");
X		}
X	list = list->next;
X	}
X
Xcount=0;
Xlist = deadscore->next;
Xwhile (list != NULL)
X	{
X	count++;
X	if (count<4 || strcmp(list->name,current->name)==0 || flag==2)
X		{
X		normal();
X		if (list==current) bold();
X		if (list->score<0)
X			printf("Quit:   ");
X		else
X			printf("Died:   ");
X		printf("%5d ",list->games);
X		printf("%10d ",list->score * (-2 * (list->score<0) + 1));
X		printf("%5d  ",count);
X		if (list==current) normal();
X	
X		chflag=0;
X		i=0;
X		while ( (list->name)[i] != '\0')
X			{
X			if ((list->name)[i] == '\001')
X				{
X				printf(" ");
X				chflag=1;
X				}
X			if ((list->name)[i] == '\002')
X				{
X				printf(BOLD);
X				chflag=1;
X				}
X			if ((list->name)[i] == '\006')
X				{
X				printf(FLASH);
X				chflag=1;
X				}
X			if ((list->name)[i] == '\016')
X				{
X				printf(NORMAL);
X				chflag=1;
X				}
X			if ((list->name)[i] == '\022')
X				{
X				printf(REVERSE);
X				chflag=1;
X				}
X			if ((list->name)[i] == '\025')
X				{
X				printf(UNDERLINE);
X				chflag=1;
X				}
X			if (chflag != 1)
X				{
X				printf("%c",(list->name)[i]);
X				}
X			chflag=0;
X			i++;
X			}
X	        printf("\n");
X		}
X	list = list->next;
X	}
X
Xif (flag!=2) exit(0);
X}
X
X/*
Xthe following two routines clear the rest of the board if you have obviously
Xwon the game so that you don't have to clear every spoty yourself
X*/
X
Xautoclear()
X{
Xint x,y;
X
Xfor(x=0;x<XSIZE;x++)
Xfor(y=0;y<YSIZE;y++)
X	if (game[x][y].cover==' ' && game[x][y].board!=9) expose(x,y);
X}
X
Xautoflag()
X{
Xint x,y;
X
Xfor(x=0;x<XSIZE;x++)
Xfor(y=0;y<YSIZE;y++)
X	if (game[x][y].cover==' ' && game[x][y].board==9) flag(x,y);
X}
X
X/*Redraws the screen, counting for a win.*/
X
Xdraw()
X{
Xint	x,y;
Xint	no_win=0;
X
Xview_flag=0;
Xclear();
Xprintf (" ");
Xfor (x=0;x<XSIZE;x++)
X	printf ("_");
Xprintf ("\n");
Xfor (y=0;y<YSIZE;y++)
X	{
X	printf ("|");
X	for (x=0;x<XSIZE;x++)
X		{
X		if (game[x][y].board != 9	&&
X		    game[x][y].cover == 'F') no_win = 1;
X		if (game[x][y].board == 9	&&
X		    game[x][y].cover != 'F') no_win = 1;
X
X		if (game[x][y].cover == ' ')
X			{
X			if (view_flag != 0)
X				{
X				normal();
X				view_flag = 0;
X				}
X			printf ("+");
X			}
X		if (game[x][y].cover == 'X')
X			if (game[x][y].board != 0)
X				{
X				if (view_flag == 0)
X					{
X					bold();
X					view_flag = 1;
X					}
X				else	if (view_flag != 1)
X					{
X					normal();
X					bold();
X					view_flag = 1;
X					}
X				printf ("%d",game[x][y].board);
X				}
X			else
X				{
X				if (view_flag != 0)
X					{
X					normal();
X					view_flag = 0;
X					}
X				printf(" ");
X				}
X		if (game[x][y].cover == 'F')
X			{
X			if (view_flag == 0)
X				{
X				reverse();
X				view_flag = 2;
X				}
X			else	if (view_flag != 2)
X				{
X				normal();
X				reverse();
X				view_flag = 2;
X				}
X			printf ("F");
X			}
X		if (game[x][y].cover != ' '	&&
X		    game[x][y].cover != 'X'	&&
X		    game[x][y].cover != 'F')
X			{
X			if (view_flag == 0)
X				{
X				reverse();
X				flash();
X				view_flag = 3;
X				}
X			else	if (view_flag != 3)
X				{
X				normal();
X				reverse();
X				flash();
X				view_flag = 3;
X				}
X			printf("%c",game[x][y].cover);
X			}
X		}
X	if (view_flag != 0)
X		{
X		normal();
X		view_flag = 0;
X		}
X	printf ("|");
X	printf ("\n");
X	}
Xprintf (" ");
Xfor (x=0;x<XSIZE;x++)
X	printf ("~");
X
Xlocate(1,length);
Xif (view_flag != 0)
X	{
X	normal();
X	view_flag = 0;
X	}
Xprintf("Press HELP for keypad diagram or FIND for help.  ");
Xprintf("Number of mines left: %4d",mine_total-flag_counter);
X
Xif (no_win != 1)
X	{
X        high(1);
X	}
X}
X
X/*Displays the minefield when the user quits or dies.  Gives percent done.*/
X
Xshow(a,b)
Xint	a,b;
X{       
Xint	x,y,i;
Xchar	answer[80];
X
X/*The following is needed for the DEC system service that gets a key.  Will
X  have to be modified to work on non-VAX equipment*/
X
X/*===================================*/
Xint	keyid,key;
Xstruct	dsc$descriptor ans = {
X	19,
X	DSC$K_DTYPE_T,
X	DSC$K_CLASS_S,
X	answer };
X
XSMG$CREATE_VIRTUAL_KEYBOARD(&keyid);
X/*===================================*/
X
Xnormal();
Xlocate (1,length);
Xfor (i=0;i<75;i++)
X	printf(" ");
Xlocate (1,length);
Xprintf("Do you want to see the minefield? (Return = No) ");
X
X/*The following is needed for the DEC system service that gets a key.  Will
X  have to be modified to work on non-VAX equipment*/
X
X/*===================================*/
XSMG$READ_KEYSTROKE(&keyid,&key);
XSMG$KEYCODE_TO_NAME(&key,&ans);
Xanswer[strlen(answer)-strlen(strchr(answer,' '))] = '\0';
Xif (strcmp(answer,"")==0) strcpy(answer," ");
X/*===================================*/
X
Xif (answer[0]=='Y'	||
X    answer[0]=='y'	||
X    answer[0]==""	)
X	{
X	clear();
X	view_flag = 0;
X	printf (" ");
X	for (x=0;x<XSIZE;x++)
X		printf ("_");
X	printf ("\n");
X	for (y=0;y<YSIZE;y++)
X		{
X		printf ("|");
X		for (x=0;x<XSIZE;x++)
X			{
X			if (a == x && b == y && a != -1 && b != -1)
X				{
X				if (view_flag == 0)
X					{
X					reverse();
X					view_flag = 2;
X					}
X				else	if (view_flag != 2)
X					{
X					normal();
X					reverse();
X					view_flag = 2;
X					}
X				if (game[x][y].board == 9)
X					printf (" ");
X				else
X					printf ("%d",game[x][y].board);
X				}
X			else	if (game[x][y].board == 9)
X				{
X				if (view_flag == 0)
X					{
X					reverse();
X					view_flag = 2;
X					}
X				else	if (view_flag != 2)
X					{
X					normal();
X					reverse();
X					view_flag = 2;
X					}
X				if (game[x][y].cover == 'F')
X					printf ("F");
X				else
X					printf ("#");
X				}
X			else	if (game[x][y].board == 0)
X				{
X				if (game[x][y].cover == 'F')
X					{
X					if (view_flag != 3)
X						{
X						if (view_flag == 0)
X							{
X							flash();
X							view_flag = 3;
X							}
X                                                else
X							{
X							normal();
X							flash();
X							view_flag = 3;
X							}
X						}
X					}
X				else	if (view_flag != 0)
X					{
X					normal();
X					view_flag = 0;
X					}
X				printf (" ");
X				}
X			else
X				{
X				if (game[x][y].cover == 'F')
X					{
X					if (view_flag != 4)
X						{
X						if (view_flag == 0)
X							{
X							flash();
X							bold();
X							view_flag = 4;
X							}
X                                                else
X							{
X							normal();
X							flash();
X							bold();
X							view_flag = 4;
X							}
X						}
X					}
X				else
X					{
X					if (view_flag != 1)
X						{
X						if (view_flag == 0)
X							{
X							bold();
X							view_flag = 1;
X							}
X                                                else
X							{
X							normal();
X							bold();
X							view_flag = 1;
X							}
X						}
X					}
X		    		printf ("%d",game[x][y].board);
X				}
X			}
X		if (view_flag != 0)
X			{
X			normal();
X			view_flag = 0;
X			}
X		printf ("|");
X		printf ("\n");
X		}
X	printf (" ");
X	for (x=0;x<XSIZE;x++)
X		printf ("~");
X	sleep(5);
X	}
X
Xhigh(0);
Xexit(0);
X}
X
X/*Clears the arrays at the beginning of the game.*/
Xempty()
X{
Xint	x,y;
X
Xfor (y=0;y<YSIZE;y++)
X	for (x=0;x<XSIZE;x++)
X		{
X		game[x][y].cover = ' ';
X		game[x][y].board = 0;
X		game[x][y].stack = 0;
X		}
X}
X
X/*Places the mines randomly (using the system time as the seed).  Will have to
X  be modified for non-VAX equipment.*/
X
Xfill()
X{
Xint	x,y,n,m;
Xchar	date_time[24];
Xint	bin_d_t;
Xstruct	dsc$descriptor d_t = {
X	23,
X	DSC$K_DTYPE_T,
X	DSC$K_CLASS_S,
X	date_time };
X
X/*The following is needed for the DEC system service that gets the time.  Will
X  have to be modified to work on non-VAX equipment*/
X
X/*===================================*/
XLIB$DATE_TIME(&d_t);
Xdate_time[24]='\0';
Xprintf ("%s\n",date_time);
XSYS$BINTIM(&d_t,&bin_d_t);
X/*===================================*/
X
Xsleep(1);
X
Xn = 0;
Xm = 0;
X
Xif (bin_d_t == 0) bin_d_t++;
Xif (bin_d_t  < 0) bin_d_t = bin_d_t * -1;
Xsrand(bin_d_t);
X
Xif (DEBUG == 1) clear();
Xwhile	(n<MINES && m<100000)
X	{
X	x=rand()%(XSIZE*10)/10;
X	y=rand()%(YSIZE*10)/10;
X	if (game[x][y].board	!= 9	&&
X	   !	((x==0 || x==XSIZE-1)	&&
X		 (y==0 || y==YSIZE-1))	)
X		{
X		n++;
X		game[x][y].board = 9;
X		if (DEBUG == 1)
X			{
X			locate(x,y);
X			printf("+");
X			}
X		}
X	m++;
X	}
Xmine_total = n;
Xsleep(3);
X}
X
X/*Calculates the numbers based on the locations of the mines in the field.*/
Xcalc()
X{
Xint	x,y;
X
Xfor (y=0;y<YSIZE;y++)
X	{
X	for (x=0;x<XSIZE;x++)
X		{
X		if (game[x][y].board==0)
X			{
X                        if (x==0 && y==0)
X			game[x][y].board=
X			  (game[x+1][y].board == 9)+
X			  (game[x][y+1].board == 9)+
X			  (game[x+1][y+1].board == 9);
X                        if (x>0 && x<XSIZE-1 && y==0)
X			game[x][y].board=
X			  (game[x-1][y].board == 9)+
X			  (game[x+1][y].board == 9)+
X			  (game[x-1][y+1].board == 9)+
X			  (game[x][y+1].board == 9)+
X			  (game[x+1][y+1].board == 9);
X                        if (x==XSIZE-1 && y==0)
X			game[x][y].board=
X			  (game[x-1][y].board == 9)+
X			  (game[x-1][y+1].board == 9)+
X			  (game[x][y+1].board == 9);
X                        if (x==0 && y>0 && y<YSIZE-1)
X			game[x][y].board=
X			  (game[x][y-1].board == 9)+
X			  (game[x+1][y-1].board == 9)+
X			  (game[x+1][y].board == 9)+
X			  (game[x][y+1].board == 9)+
X			  (game[x+1][y+1].board == 9);
X			if (x>0 && x<XSIZE-1 && y>0 && y<YSIZE-1)
X			game[x][y].board=
X			  (game[x-1][y-1].board == 9)+
X			  (game[x][y-1].board == 9)+
X			  (game[x+1][y-1].board == 9)+
X			  (game[x-1][y].board == 9)+
X			  (game[x+1][y].board == 9)+
X			  (game[x-1][y+1].board == 9)+
X			  (game[x][y+1].board == 9)+
X			  (game[x+1][y+1].board == 9);
X			if (x==XSIZE-1 && y>0 && y<YSIZE-1)
X			game[x][y].board=
X			  (game[x-1][y-1].board == 9)+
X			  (game[x][y-1].board == 9)+
X			  (game[x-1][y].board == 9)+
X			  (game[x-1][y+1].board == 9)+
X			  (game[x][y+1].board == 9);
X			if (x==0 && y==YSIZE-1)
X			game[x][y].board=
X			  (game[x][y-1].board == 9)+
X			  (game[x+1][y-1].board == 9)+
X			  (game[x+1][y].board == 9);
X			if (x>0 && x<XSIZE-1 && y==YSIZE-1)
X			game[x][y].board=
X			  (game[x-1][y-1].board == 9)+
X			  (game[x][y-1].board == 9)+
X			  (game[x+1][y-1].board == 9)+
X			  (game[x-1][y].board == 9)+
X			  (game[x+1][y].board == 9);
X			if (x==XSIZE-1 && y==YSIZE-1)
X			game[x][y].board=
X			  (game[x-1][y-1].board == 9)+
X			  (game[x][y-1].board == 9)+
X			  (game[x-1][y].board == 9);
X			}
X		}
X	}
X}
X
X/*Help routine.*/
Xcommand_line()
X{
Xreverse();
Xprintf("Command Line Parameters.");
Xnormal();
Xbold();
Xprintf("	<key>=<number>\n");
Xnormal();
Xprintf("\n");
Xbold();
Xprintf("x or c or w	");
Xnormal();
Xprintf("The number of Columns or the Width of the field\n");
Xbold();
Xprintf("y or r or l	");
Xnormal();
Xprintf("The number of Rows or the Length of the field\n");
Xbold();
Xprintf("s      		");
Xnormal();
Xprintf("The filename of a saved game\n");
Xbold();
Xprintf("b or m		");
Xnormal();
Xprintf("The number of Mines\n");
Xbold();
Xprintf("h		");
Xnormal();
Xprintf("The number of Hints\n");
Xbold();
Xprintf("d		");
Xnormal();
Xprintf("If D=1 then display the mines as they are being buried\n");
Xbold();
Xprintf("?		");
Xnormal();
Xprintf("list of keys and brief description of game\n");
Xbold();
Xprintf("/		");
Xnormal();
Xprintf("shows the entire high score file and your current score\n");
X}
X
X/*Help routine.*/
Xkeys()
X{
Xreverse();
Xprintf("Keys.\n");
Xnormal();
Xprintf("\n");
Xbold();
Xprintf("Control-W	");
Xnormal();
Xprintf("redraw the screen\n");
Xbold();
Xprintf("q or DO		");
Xnormal();
Xprintf("quit\n");
Xbold();
Xprintf("p or INSERTHERE ");
Xnormal();
Xprintf("preserve (save) the game at the current spot\n");
Xbold();
Xprintf("s or SELECT	");
Xnormal();
Xprintf("clear the space the cursor is on\n");
Xbold();
Xprintf("d or PREVSCREEN	");
Xnormal();
Xprintf("will NOT clear the space the cursor is on, but\n");
Xprintf("		if it is already clear and the right number of\n");
Xprintf("		flags surround it, all the surrounding unflaged\n");
Xprintf("		spots will be cleared\n");
Xbold();
Xprintf("f or NEXTSCREEN	");
Xnormal();
Xprintf("flag (or if flagged then unflag) the space the cursor is on\n");
Xbold();
Xprintf("h or Return	");
Xnormal();
Xprintf("hint key: may only be used three times.  Will clear or\n");
Xprintf("		flag the space the cursor is on, whichever is appropriate\n");
Xbold();
Xprintf("i, j, k, and l	");
Xnormal();
Xprintf("cursor keys\n");
Xbold();
Xprintf("HELP		");
Xnormal();
Xprintf("keypad drawing\n");
Xbold();
Xprintf("? or FIND	");
Xnormal();
Xprintf("list of keys and brief description of game\n");
Xbold();
Xprintf("/ or REMOVE	");
Xnormal();
Xprintf("shows the entire high score file and your current score\n");
X}
X
X/*Help routine.*/
Xkeypad()
X{
Xreverse();
Xprintf("Keypad.\n");
Xnormal();
Xprintf("\n");
Xprintf("                       .-------------.---------------------------.\n");
Xprintf("                       |     HELP    |            DO             |\n");
Xprintf("                       | keypad help |         quit game         |\n");
Xprintf("                       `-------------'---------------------------'\n");
Xprintf("                       .-------------.-------------.-------------.\n");
Xprintf("                       |     FIND    | INSERT HERE |   REMOVE    |\n");
Xprintf("                       | help screen |  save game  | high scores |\n");
Xprintf(".-------------.        |-------------|-------------|-------------|\n");
Xprintf("|    RETURN   |        |    SELECT   | PREV SCREEN | NEXT SCREEN |\n");
Xprintf("|     hint    |        |    clear    | safetyclear |    flag     |\n");
Xprintf("`-----.       |        `-------------|-------------|-------------'\n");
Xprintf("      |       |                      |      UP     |              \n");
Xprintf("      |       |                      |             |              \n");
Xprintf("      `-------'        .-------------|-------------|-------------.\n");
Xprintf("                       |     LEFT    |     DOWN    |    RIGHT    |\n");
Xprintf("                       |             |             |             |\n");
Xprintf("                       `-------------`-------------'-------------'\n");
Xprintf("\n");
Xprintf("		Press ? or FIND to get nore detailed help\n");
X}
X
X/*Help routine.*/
Xinfo()
X{
Xreverse();
Xprintf("MineSweeper.\n");
Xnormal();
Xprintf("\n");
Xprintf("The goal is to find and flag all the mines in the minefield.\n");
Xprintf("You win when the field is entirely cleared except for the flagged\n");
Xprintf("mines.  You have exactly the right number of flags.\n");
Xprintf("\n");
Xprintf("The number that shows up when you clear a spot tells how many mines\n");
Xprintf("are on one of the eight neighbouring spots.  These are the clues you\n");
Xprintf("have to where the mines are.\n");
Xprintf("\n");
Xprintf("The score calculated is approximately:\n");
Xprintf("\n");
Xprintf("        Number_of_squares_cleared_or_flagged * Number_of_mines\n");
Xprintf("score = ------------------------------------------------------\n");
Xprintf("              14%_of_size_of_Board * Number_of_hints_used\n");
X}
X
X/*Help routine.*/
Xother_info()
X{
Xreverse();
Xprintf("Other Information.\n");
Xnormal();
Xprintf("\n");
Xprintf("When you die and see the minefield:\n");
Xflash();
Xprintf("n");
Xnormal();
Xprintf(" are spots that have been flagged and are not mines\n");
Xreverse();
Xprintf("#");
Xnormal();
Xprintf(" are spots that have not been flagged and are mines\n");
Xreverse();
Xprintf("F");
Xnormal();
Xprintf(" are spots that have been flagged and are mines\n");
Xreverse();
Xprintf(" ");
Xnormal();
Xprintf(" is the mine you cleared that killed you.\n");
Xprintf("\n");
Xprintf("When you enter your name for the highscore file these keys work:\n");
Xprintf("(If you do not enter a name your username is used)\n");
Xprintf("Control-N	Normal:    turns off all other codes\n");
Xprintf("Control-B	Bold:      bolds all following text until Normal\n");
Xprintf("Control-F	Flash:     flashs all following text until Normal\n");
Xprintf("Control-R	Reverse:   reverses all following text until Normal\n");
Xprintf("Control-U	Underline: underlines all following text until Normal\n");
Xprintf("\n");
Xprintf("When you put your name in the high score file, the file showed to you\n");
Xprintf("has only the top three people who won and the top three people who died,\n");
Xprintf("as well as all of the entries with the entered name.\n");
X}
X
Xhelp(int flag)
X{
Xif (flag==1) 
X	{
X	clear();
X	info();
X	printf("\n");
X	sleep(5);
X	clear();
X	keypad();
X	printf("\n");
X	sleep(5);
X	clear();
X	keys();
X	printf("\n");
X	sleep(5);
X	clear();
X	command_line();
X	printf("\n");
X	sleep(5);
X	clear();
X	other_info();
X	printf("\n");
X	sleep(5);
X	}
Xif (flag==0) 
X	{
X	clear();
X	command_line();
X	}
X}
X
X/*The following is needed for the DEC system service that gets the terminal
X  size.  Will have to be modified to work on non-VAX equipment*/
X
X/*===================================*/
X#define size 8
X
Xtermsize()
X{
Xchar buffer[size],param[20];
Xunsigned long chan;
Xchar i;
Xchar devnam[20];
Xstruct dsc$descriptor device_name = {
X	19,
X	DSC$K_DTYPE_T,
X	DSC$K_CLASS_S,
X	devnam };
X
Xstrcpy(devnam,"SYS$INPUT:");
Xdevice_name.dsc$w_length=strlen(devnam);
X
Xi=SYS$ASSIGN(&device_name,&chan,NULL,NULL,NULL);
XLIB$SIGNAL(i);
X
Xi=SYS$QIOW(NULL,chan,IO$_SENSEMODE,
X	   NULL,NULL,NULL,&buffer,size,NULL,NULL,NULL,NULL);
X
Xswidth = buffer[2];
Xslength = buffer[7];
X
Xif (swidth<1)
X	swidth = 256 + swidth;
Xif (slength<1)
X	slength = 256 + slength;
X
Xif (slength<24)
X	length=24;
Xelse
X	length=slength;
X
Xif (swidth<80)
X	width=80;
Xelse
X	width=swidth;
X
Xbuffer[2] = width-256*(width>127);
Xbuffer[7] = length-256*(length>127);
X
X	i=SYS$QIOW(NULL,chan,IO$_SETMODE,
X		   NULL,NULL,NULL,&buffer,size,NULL,NULL,NULL,NULL);
X
X}
X
X/*===================================*/
X
X/*This is the \main loop.*/
X
Xmain (argc,argv)
Xint 	argc;
Xchar	*argv[];
X{
XFILE	*fileptr;
Xchar	savename[60];
Xint	save_flag=0,skip=0;
Xint	x=0,y=0,n=0;
Xint	ix,iy,i;
Xint	hint_flag,mine_flag;
Xint	count;
Xint	getone,num;
Xchar	param[20];
X
X/*The following is needed for the DEC system service that gets a key.  Will
X  have to be modified to work on non-VAX equipment*/
X
X/*===================================*/
Xchar	keyname[20];
Xint	keyid,key;
Xstruct	dsc$descriptor name = {
X	19,
X	DSC$K_DTYPE_T,
X	DSC$K_CLASS_S,
X	keyname };
X
XSMG$CREATE_VIRTUAL_KEYBOARD(&keyid);
X/*===================================*/
X
Xtermsize();
XXSIZE=swidth-3;
Xif (XSIZE<3)
X	{
X	printf("The terminal width is too small.");
X	exit(1);
X	}
XYSIZE=slength-2;
Xif (YSIZE<1)
X	{
X	printf("The terminal height is too small.");
X	exit(1);
X	}
Xprintf("Terminal size: %d x %d\n\n",width,length);
X
X/*Parse the command line arguements.*/
Xif (argc>1)
X	{
X	for (getone=1;getone<argc;getone++)
X		{
X		sscanf (argv[getone],"%s",&param);
X		printf ("Working on parameter: %s\n",param);
X
X		if (param[0] == '/')
X			{
X			high(2);
X			exit(0);
X			}
X		if (param[0] == '?')
X			{
X			help(1);
X			exit(0);
X			}
X		if (strpbrk(param,"=")==NULL)
X			{
X			help(0);
X			exit(1);
X			}
X		if (param[1] != '=')
X			{
X			help(0);
X			exit(1);
X			}
X		if (param[0] != 'L'	&&
X		    param[0] != 'l'	&&
X		    param[0] != 'Y'	&&
X		    param[0] != 'y'	&&
X		    param[0] != 'R'	&&
X		    param[0] != 'r'	&&
X		    param[0] != 'W'	&&
X		    param[0] != 'w'	&&
X		    param[0] != 'X'	&&
X		    param[0] != 'x'	&&
X		    param[0] != 'C'	&&
X		    param[0] != 'c'	&&
X		    param[0] != 'M'	&&
X		    param[0] != 'm'	&&
X		    param[0] != 'B'	&&
X		    param[0] != 'b'	&&
X		    param[0] != 'S'	&&
X		    param[0] != 's'	&&
X		    param[0] != 'H'	&&
X		    param[0] != 'h'	&&
X		    param[0] != 'D'	&&
X		    param[0] != 'd')
X			{
X			help(0);
X			exit(1);
X			}
X		if (param[0] == 'L'	||
X		    param[0] == 'l'	||
X		    param[0] == 'R'	||
X		    param[0] == 'r'	||
X		    param[0] == 'Y'	||
X		    param[0] == 'y')
X			{
X			if (atoi(strchr(param,'=')+sizeof(char))<YSIZE)
X				{
X				YSIZE = atoi(strchr(param,'=')+sizeof(char));
X				if (YSIZE<1) YSIZE = 1;
X				}
X			printf("%d rows\n",YSIZE);
X			}
X		if (param[0] == 'W'	||
X		    param[0] == 'w'	||
X		    param[0] == 'C'	||
X		    param[0] == 'c'	||
X		    param[0] == 'X'	||
X		    param[0] == 'x')
X			{
X			if (atoi(strchr(param,'=')+sizeof(char))<XSIZE)
X				{
X				XSIZE = atoi(strchr(param,'=')+sizeof(char));
X				if (XSIZE<3) XSIZE = 3;
X				}
X			printf("%d columns\n",XSIZE);
X			}
X		if (param[0] == 'H'	||
X		    param[0] == 'h')
X			{
X			HINTS = atoi(strchr(param,'=')+sizeof(char));
X			if (HINTS<0) HINTS = 0;
X			printf("%d hints\n",HINTS);
X			hint_flag = 1;
X			}
X		if (param[0] == 'S'	||
X		    param[0] == 's')
X			{
X			strcpy(savename, strchr(param,'=')+sizeof(char));
X			printf("Restoring %s\n",savename);
X			save_flag = 1;
X			}
X		if (param[0] == 'M'	||
X		    param[0] == 'm'	||
X		    param[0] == 'B'	||
X		    param[0] == 'b')
X			{
X			MINES = atoi(strchr(param,'=')+sizeof(char));
X			if (MINES<1) MINES = 1;
X			printf("%d mines\n",MINES);
X			mine_flag = 1;
X			}
X		if (param[0] == 'D'	||
X		    param[0] == 'd')
X			{
X			DEBUG = atoi(strchr(param,'=')+sizeof(char));
X			}
X		}
X	}
X
Xif (high(3) != 1)
X	{
X	help(1);
X	clear();
X	}
Xif (mine_flag != 1)
X	{
X	MINES=XSIZE*YSIZE*147/10000*10+10;
X	printf ("\nThe number of mines for this game is projected to be %d.\n",MINES);
X	}
Xif (hint_flag != 1)
X	printf ("\nThe number of hints for this game will be %d.\n\n",HINTS);
Xif (save_flag == 1)
X	{
X	fileptr = fopen (savename,"r");
X	skip=0;
X	while (fileptr == NULL	&&	skip == 0)
X		{
X		printf("Enter the name of a game to restore:  (Return to go skip) ");
X		getstring(savename,60,1);
X		skip=0;	if (strlen(savename)==0) skip=1;
X		if (skip==0) fileptr = fopen (savename,"r");
X		printf("\n");
X		}
X	if (skip==0)
X		{
X		fscanf (fileptr,"%d",&real_flag_counter);
X		fscanf (fileptr,"%d",&flag_counter);
X		fscanf (fileptr,"%d",&counter);
X		fscanf (fileptr,"%d",&XSIZE);
X		fscanf (fileptr,"%d",&YSIZE);
X		fscanf (fileptr,"%d",&hint);
X		fscanf (fileptr,"%d",&HINTS);
X		fscanf (fileptr,"%d",&mine_total);
X		}
X	}
X
X/*Build the game board array.*/
Xif ((game = (TABLE **) malloc(XSIZE*sizeof(TABLE *))) != NULL)
X	{
X	for(i = 0; i<XSIZE; i++)
X		{
X		if ((game1 = (TABLE *) malloc(YSIZE*sizeof(TABLE))) != NULL)
X			game[i] = game1;
X		else
X			{
X			printf ("Cannot open space.  Choose a smaller size.");
X			exit (1);
X			}
X		}
X	}
Xelse
X	{
X	printf ("Cannot open space.  Chose a smaller size.");
X	exit (1);
X	}
X
Xif (save_flag == 1	&&	skip == 0)
X	{
X        for(ix=0;ix<XSIZE;ix++)
X        for(iy=0;iy<YSIZE;iy++)
X		{
X		fscanf (fileptr,"%d",&i);
X		game[ix][iy].cover=i;
X		fscanf (fileptr,"%d",&i);
X		game[ix][iy].board=i;
X		}
X	fscanf (fileptr,"%d",&x);
X	fscanf (fileptr,"%d",&y);
X	fclose(fileptr);
X	if (XSIZE>width-3 || YSIZE>length-2)
X		{
X		printf("This saved game needs a %d x %d terminal to load.\n",
X			XSIZE+3,YSIZE+2);
X		printf("Since I am not sure if your terminal can handle\n");
X		printf("this large size, you will have to set it manually.\n");
X		exit(1);
X		}
X	}
Xelse
X	{
X	create();
X	empty();
X	fill();
X	calc();
X	}
Xdraw();
X
Xlocate (x,y);
X
Xwhile ( 1)
X	{
X
X	if (	strcmp(keyname,"E2")	 == 0	||
X		strcmp(keyname,"P")	 == 0	||
X		strcmp(keyname,"p")	 == 0	)
X		{
X		locate(1,length);
X		if (view_flag != 0)
X			{
X			normal();
X			view_flag = 0;
X			}
X		for (i=0;i<75;i++)
X		printf(" ");
X		locate (1,length);
X		printf("Please enter a filename: (Return to go back) ");
X		getstring(savename,30,1);
X		locate (1,length);
X		printf("Press HELP for keypad diagram or FIND for help.  ");
X		printf("Number of mines left: %4d",mine_total-flag_counter);
X
X		skip=0;	if (strlen(savename)==0) skip=1;
X		if (skip == 0) fileptr = fopen (savename,"w");
X		if (fileptr != NULL	&&	skip == 0)
X			{
X			fprintf (fileptr,"%d\n",real_flag_counter);
X			fprintf (fileptr,"%d\n",flag_counter);
X			fprintf (fileptr,"%d\n",counter);
X			fprintf (fileptr,"%d\n",XSIZE);
X			fprintf (fileptr,"%d\n",YSIZE);
X			fprintf (fileptr,"%d\n",hint);
X			fprintf (fileptr,"%d\n",HINTS);
X			fprintf (fileptr,"%d\n",mine_total);
X 		        for(ix=0;ix<XSIZE;ix++)
X				{
X        		for(iy=0;iy<YSIZE;iy++)
X				{
X				fprintf (fileptr,"%d ",game[ix][iy].cover);
X				fprintf (fileptr,"%d ",game[ix][iy].board);
X				}
X				fprintf (fileptr,"\n");
X				}
X			fprintf (fileptr,"%d\n",x);
X			fprintf (fileptr,"%d\n",y);
X			fclose (fileptr);
X			}
X		}
X
X	if (	strcmp(keyname,"HELP")	 == 0	)
X		{
X		keypad();
X		draw();
X		}
X
X	if (	strcmp(keyname,"?")	 == 0	||
X		strcmp(keyname,"E1")	 == 0	)
X		{
X		help(1);
X		draw();
X		}
X
X	if (	strcmp(keyname,"/")	 == 0	||
X		strcmp(keyname,"E3")	 == 0	)
X		{
X		high(2);
X		printf("\n");
X		sleep(5);
X		draw();
X		}
X
X	if (	strcmp(keyname,"q")      == 0	||
X		strcmp(keyname,"Q")      == 0	||
X		strcmp(keyname,"DO")     == 0)
X			{
X			quit_flag = 1;
X			show(-1,-1);
X			}
X
X	if (	strcmp(keyname,"s")      == 0	||
X		strcmp(keyname,"S")      == 0	||
X	    	strcmp(keyname,"E4")     == 0)
X		if (game[x][y].board     != 9)
X			expose(x,y);
X		else	if (game[x][y].cover	!= 'F')
X			show(x,y);
X
X	if (   (strcmp(keyname,"h")      == 0	||
X		strcmp(keyname,"H")      == 0	||
X	    	strcmp(keyname,"CTRLM")   == 0)	&&
X		hint<HINTS)
X		if (game[x][y].board     != 9)
X			{
X			expose(x,y);
X			hint++;
X			}
X		else	if (game[x][y].cover	!= 'F')
X			{
X			flag(x,y);
X			hint++;
X			}
X
X	if (	strcmp(keyname,"d")      == 0	||
X		strcmp(keyname,"D")	 == 0	||
X	    	strcmp(keyname,"E5")     == 0)
X		{
X		if (game[x][y].cover     != ' ')
X			{
X	                if (x==0 && y==0)
X			count=
X			  (game[x+1][y].cover == 'F')+
X			  (game[x][y+1].cover == 'F')+
X			  (game[x+1][y+1].cover == 'F');
X	                if (x>0 && x<XSIZE-1 && y==0)
X			count=
X			  (game[x-1][y].cover == 'F')+
X			  (game[x+1][y].cover == 'F')+
X			  (game[x-1][y+1].cover == 'F')+
X			  (game[x][y+1].cover == 'F')+
X			  (game[x+1][y+1].cover == 'F');
X	                if (x==XSIZE-1 && y==0)
X			count=
X			  (game[x-1][y].cover == 'F')+
X			  (game[x-1][y+1].cover == 'F')+
X			  (game[x][y+1].cover == 'F');
X	                if (x==0 && y>0 && y<YSIZE-1)
X			count=
X			  (game[x][y-1].cover == 'F')+
X			  (game[x+1][y-1].cover == 'F')+
X			  (game[x+1][y].cover == 'F')+
X			  (game[x][y+1].cover == 'F')+
X			  (game[x+1][y+1].cover == 'F');
X			if (x>0 && x<XSIZE-1 && y>0 && y<YSIZE-1)
X			count=
X			  (game[x-1][y-1].cover == 'F')+
X			  (game[x][y-1].cover == 'F')+
X			  (game[x+1][y-1].cover == 'F')+
X			  (game[x-1][y].cover == 'F')+
X			  (game[x+1][y].cover == 'F')+
X			  (game[x-1][y+1].cover == 'F')+
X			  (game[x][y+1].cover == 'F')+
X			  (game[x+1][y+1].cover == 'F');
X			if (x==XSIZE-1 && y>0 && y<YSIZE-1)
X			count=
X			  (game[x-1][y-1].cover == 'F')+
X			  (game[x][y-1].cover == 'F')+
X			  (game[x-1][y].cover == 'F')+
X			  (game[x-1][y+1].cover == 'F')+
X			  (game[x][y+1].cover == 'F');
X			if (x==0 && y==YSIZE-1)
X			count=
X			  (game[x][y-1].cover == 'F')+
X			  (game[x+1][y-1].cover == 'F')+
X			  (game[x+1][y].cover == 'F');
X			if (x>0 && x<XSIZE-1 && y==YSIZE-1)
X			count=
X			  (game[x-1][y-1].cover == 'F')+
X			  (game[x][y-1].cover == 'F')+
X			  (game[x+1][y-1].cover == 'F')+
X			  (game[x-1][y].cover == 'F')+
X			  (game[x+1][y].cover == 'F');
X			if (x==XSIZE-1 && y==YSIZE-1)
X			count=
X			  (game[x-1][y-1].cover == 'F')+
X			  (game[x][y-1].cover == 'F')+
X			  (game[x-1][y].cover == 'F');
X			if (game[x][y].board == count)
X				{
X				if (x>0 && y>0)
X					if (game[x-1][y-1].cover == ' ')
X						if (game[x-1][y-1].board != 9)
X							expose(x-1,y-1);
X						else
X							show(x,y);
X				if (y>0)
X					if (game[x][y-1].cover   == ' ')
X						if (game[x][y-1].board	 != 9)
X							expose(x,y-1);
X						else
X		 					show(x,y);
X				if (x<XSIZE-1 && y>0)
X					if (game[x+1][y-1].cover == ' ')
X						if (game[x+1][y-1].board != 9)
X							expose(x+1,y-1);
X						else
X							show(x,y);
X				if (x>0)
X					if (game[x-1][y].cover   == ' ')
X						if (game[x-1][y].board   != 9)
X							expose(x-1,y);
X						else
X							show(x,y);
X				if (x<XSIZE-1)
X					if (game[x+1][y].cover   == ' ')
X						if (game[x+1][y].board   != 9)
X							expose(x+1,y);
X						else
X							show(x,y);
X				if (x>0 && y<YSIZE-1)
X					if (game[x-1][y+1].cover == ' ')
X						if (game[x-1][y+1].board != 9)
X							expose(x-1,y+1);
X						else
X							show(x,y);
X				if (y<YSIZE-1)
X					if (game[x][y+1].cover   == ' ')
X						if (game[x][y+1].board   != 9)
X							expose(x,y+1);
X						else
X							show(x,y);
X				if (x<XSIZE-1 && y<YSIZE-1)
X					if (game[x+1][y+1].cover == ' ')
X						if (game[x+1][y+1].board != 9)
X							expose(x+1,y+1);
X						else
X							show(x,y);
X				}
X			}
X		}
X	
X	if (	strcmp(keyname,"f")     == 0	||
X		strcmp(keyname,"F")     == 0	||
X		strcmp(keyname,"E6")    == 0)
X		if (game[x][y].cover    == 'F')
X			unflag(x,y);
X		else
X			flag(x,y);
X
X	if (	(strcmp(keyname,"i")     == 0	||
X		 strcmp(keyname,"I")     == 0	||
X		 strcmp(keyname,"UP")    == 0)	&& y > 0)	y = y - 1;
X
X	if (	(strcmp(keyname,"j")     == 0	||
X		 strcmp(keyname,"J")     == 0	||
X		 strcmp(keyname,"LEFT")  == 0)	&& x > 0)	x = x - 1;
X
X	if (	(strcmp(keyname,"k")     == 0	||
X		 strcmp(keyname,"K")     == 0	||
X		 strcmp(keyname,"DOWN")  == 0)	&& y < YSIZE-1)	y = y + 1;
X
X	if (	(strcmp(keyname,"l")     == 0	||
X		 strcmp(keyname,"L")     == 0	||
X		 strcmp(keyname,"RIGHT") == 0)	&& x < XSIZE-1)	x = x + 1;
X
X	if (	 strcmp(keyname,"CTRLW") == 0)
X		{
X		draw();
X		}
X
X	if (counter == XSIZE*YSIZE - mine_total)
X		{
X		autoflag();
X		}
X
X	if (real_flag_counter == mine_total)
X		{
X		autoclear();
X		}
X
X	if (counter + real_flag_counter == XSIZE*YSIZE)
X		{
X		high(1);
X		}
X
X/*The following is needed for the DEC system service that gets a key.  Will
X  have to be modified to work on non-VAX equipment*/
X
X/*===================================*/
X	locate (x,y);
X	SMG$READ_KEYSTROKE(&keyid,&key);
X	SMG$KEYCODE_TO_NAME(&key,&name);
X	keyname[strlen(keyname)-strlen(strchr(keyname,' '))] = '\0';
X	if (strcmp(keyname,"")==0) strcpy(keyname," ");
X/*===================================*/
X
X	}
X}
X
X
END_OF_FILE
if test 55574 -ne `wc -c <'minesweeper.c'`; then
    echo shar: \"'minesweeper.c'\" unpacked with wrong size!
fi
# end of 'minesweeper.c'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
