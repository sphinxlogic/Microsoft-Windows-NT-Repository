Newsgroups: vmsnet.sources.games
Path: uunet!cs.utexas.edu!torn!cunews!nrcnet0!cu23.crl.aecl.ca!wl.aecl.ca!jeremiahw
From: jeremiahw@wl.aecl.ca
Subject: Minesweeper Version 2.0 for VMS by TAB and JJ
Message-ID: <2AUG92.22263234@wl.aecl.ca>
Sender: news@cu23.crl.aecl.ca (USENET News System)
Nntp-Posting-Host: wc4.wl.aecl.ca
Organization: AECL RESEARCH
Date: Mon, 3 Aug 1992 04:26:32 GMT
Lines: 2605

/*****************************************************************************/
/*									     */
/*	Troy Baker & Jerry Jeremiah	MineSweeper Version 2.0 for VAX	     */
/*									     */
/*	Help will be given to anyone whose name is not in the high score.    */
/*									     */
/*	This is version 2.0 of our minesweeper program.  Although we have    */
/*	done extensive testing and we are not aware of any errors, if any    */
/*	are found, bug reports may be made to jeremi@bode.ee.ualberta.ca     */
/*									     */
/*	If you do not want multiple versions of the high score file, you     */
/*	may execute the following command after the game has been run once:  */
/*									     */
/*			set file/version=1 highscore.ms			     */
/*									     */
/*****************************************************************************/

/*
The main problem with this program being portable is that several VAX-only
system services had to be used:

On a machine that does not buffer input,  getchar could have been used.
As it was we used a larger segment of code.

On another machine, the time will have to be called differently.  But it must
come back integer.

On another machine, the terminal size will have to be called differently.

There is a function used that gets the user id for the purposes of the
high score identification.  It will have to be redone for another platform.

The escape sequenses may not work for anything but a VAX.
*/

#include stdio
#include string
#include jpidef
#include descrip
#include libdtdef
#include ssdef
#include iodef
#include rmsdef

#define NORMAL    "\033[0m"
#define BOLD      "\033[1m"
#define UNDERLINE "\033[4m"
#define FLASH     "\033[5m"
#define REVERSE   "\033[7m"

typedef
	struct entry 
		{
		int x;
		int y;
		struct entry *next;
		}
	STACK;

typedef
	struct element 
		{
		int cover;	/*This tells if it is selected or flagged*/
		int board;	/*This is the mines and numbers*/
		int stack;	/*This tells if it is on the stack*/
		}
	TABLE;

TABLE	*game1,**game;			/*These will be our array*/
STACK	*bottom,*top;			/*These are our stack pointers*/
int     quit_flag;			
int	mine_total=0;			/*This is the real number of mines*/
int	XSIZE,YSIZE,MINES,DEBUG=0;	/*These are the command line params*/ 
int	slength,swidth;			/*This is the game size*/
int	length,width;			/*This is the terminal size*/
int	hint=0,HINTS=3;
int	view_flag;
int	real_flag_counter=0,flag_counter=0,counter=0;
					/*These are our win tracking counters*/

/*This uses DEC escape sequences to clear the screen.*/

clear()
{
printf("\033[0m\033[2J\033[1;1H");
}

/*This uses DEC escape sequences to locate the cursor.*/

locate(x,y)
int	x,y;
{
printf("\033[%d;%dH",y+2,x+2);
}

/*This uses DEC escape sequences to make big characters.*/

big(str)
char str[]; 
{
clear();
locate(0,YSIZE);		
printf("\033#3%s\n",str);
locate(0,YSIZE+1);
printf("\033#4%s",str);
exit(0);
}

/*This uses DEC escape sequences to turn off all other DEC escape sequences.*/

normal()
{
printf(NORMAL);
}                                         

/*This uses DEC escape sequences to bold the characters printed after this.*/

bold()
{
printf(BOLD);
}

/*This uses DEC escape sequences to flash the characters printed after this.*/

flash()
{
printf(FLASH);
}

/*This uses DEC escape sequences to reverse the characters printed after this.*/

reverse()
{
printf(REVERSE);
}

/*This uses DEC escape sequences to underline the chars printed after this.*/

underline()
{
printf(UNDERLINE);
}

/*This pushes a location on the stack.*/

push(x,y)
int	x,y;
{
STACK	*piece;

game[x][y].stack = 1;
piece = (STACK *) malloc( sizeof(STACK) );
piece->x	= x;
piece->y	= y;
piece->next	= top;
top		= piece;
}

/*This routine is accessed when there is a stack error (Never hopefully)
  It lists the contents of the stack.*/

links()
{
STACK *piece;

piece = top;
if (atbottom(piece)!=1)
	{
	locate (0,YSIZE);
	printf (">");
	}
while (atbottom(piece)!=1)
	{
	printf ("%d,%d ",piece->x,piece->y);
	piece = piece->next;
	}
if (atbottom(piece)!=1)
	{
	printf ("\n");
	}
}

/*Takes the top stack piece and frees the memory.*/

pop(x,y)
int	*x,*y;
{
STACK	*piece;

piece	= top;
if (isempty()!=1)
	{
	*x	= piece->x;
	*y	= piece->y;
	top	= piece->next;
	free (piece);
	game[*x][*y].stack = 0;
	}
else
	{
	links();
	printf("Stack Error!");
	exit(1);
	}
}

/*Logical routine returns true if the pointer is at the bottom of the stack.*/

atbottom(ptr)
STACK	*ptr;
{
if (ptr == bottom) return (1);
}

/*Logical routine returns true if the stack is empty.*/

isempty()
{
if (top == bottom) return (1);
}

/*Creates the stack by initializing the pointers*/

create()
{
top = NULL;
bottom = NULL;
}

/*Pops the stack top, displays it, and pushes the neighbours on the stack if
  what it popped off was a zero.  Continues until the stack is empty.  Is
  basically a flood fill routine.*/

expose(x,y)
int	x,y;
{

if (game[x][y].cover != 'X') counter++;
locate(x,y);
game[x][y].cover = 'X';
if (game[x][y].board != 0)
	{
	if (view_flag == 0)
		{
		bold();
		view_flag = 1;
		}
	else	if (view_flag != 1)
		{
		normal();
		bold();
		view_flag = 1;
		}
	printf ("%d",game[x][y].board);
	}
else
	{
	if (view_flag != 0)
		{
		normal();
		view_flag = 0;
		}
	printf(" ");
	}

if (game[x][y].board == 0)
	{
	if (x==0 && y==0)
		{
		if (game[x+1][y].cover==' '	&&
		    game[x+1][y].stack==0	)   	push(x+1,y);
		if (game[x][y+1].cover==' '	&&
		    game[x][y+1].stack==0	)	push(x,y+1);
		if (game[x+1][y+1].cover==' '	&&
		    game[x+1][y+1].stack==0	)	push(x+1,y+1);
		}
	if (x>0 && x<XSIZE-1 && y==0)
		{
		if (game[x-1][y].cover==' '	&&
		    game[x-1][y].stack==0	)	push(x-1,y);
		if (game[x+1][y].cover==' '	&&
		    game[x+1][y].stack==0	)	push(x+1,y);
		if (game[x-1][y+1].cover==' '	&&
		    game[x-1][y+1].stack==0	)	push(x-1,y+1);
		if (game[x][y+1].cover==' '	&&
		    game[x][y+1].stack==0	)	push(x,y+1);
		if (game[x+1][y+1].cover==' '	&&
		    game[x+1][y+1].stack==0	)	push(x+1,y+1);
		}
	if (x==XSIZE-1 && y==0)
		{
		if (game[x-1][y].cover==' '	&&
		    game[x-1][y].stack==0	)	push(x-1,y);
		if (game[x-1][y+1].cover==' '	&&
		    game[x-1][y+1].stack==0	)	push(x-1,y+1);
		if (game[x][y+1].cover==' '	&&
		    game[x][y+1].stack==0	)	push(x,y+1);
		}
	if (x==0 && y>0 && y<YSIZE-1)
		{
		if (game[x][y-1].cover==' '	&&
		    game[x][y-1].stack==0	)	push(x,y-1);
		if (game[x+1][y-1].cover==' '	&&
		    game[x+1][y-1].stack==0	)	push(x+1,y-1);
		if (game[x+1][y].cover==' '	&&
		    game[x+1][y].stack==0	)	push(x+1,y);
		if (game[x][y+1].cover==' '	&&
		    game[x][y+1].stack==0	)	push(x,y+1);
		if (game[x+1][y+1].cover==' '	&&
		    game[x+1][y+1].stack==0	)	push(x+1,y+1);
		}
	if (x>0 && x<XSIZE-1 && y>0 && y<YSIZE-1)
		{
		if (game[x-1][y-1].cover==' '	&&
		    game[x-1][y-1].stack==0	)	push(x-1,y-1);
		if (game[x][y-1].cover==' '	&&
		    game[x][y-1].stack==0	)	push(x,y-1);
		if (game[x+1][y-1].cover==' '	&&
		    game[x+1][y-1].stack==0	)	push(x+1,y-1);
		if (game[x-1][y].cover==' '	&&
		    game[x-1][y].stack==0	)	push(x-1,y);
		if (game[x+1][y].cover==' '	&&
		    game[x+1][y].stack==0	)	push(x+1,y);
		if (game[x-1][y+1].cover==' '	&&
		    game[x-1][y+1].stack==0	)	push(x-1,y+1);
		if (game[x][y+1].cover==' '	&&
		    game[x][y+1].stack==0	)	push(x,y+1);
		if (game[x+1][y+1].cover==' '	&&
		    game[x+1][y+1].stack==0	)	push(x+1,y+1);
		}
	if (x==XSIZE-1 && y>0 && y<YSIZE-1)
		{
		if (game[x-1][y-1].cover==' '	&&
		    game[x-1][y-1].stack==0	)	push(x-1,y-1);
		if (game[x][y-1].cover==' '	&&
		    game[x][y-1].stack==0	)	push(x,y-1);
		if (game[x-1][y].cover==' '	&&
		    game[x-1][y].stack==0	)	push(x-1,y);
		if (game[x-1][y+1].cover==' '	&&
		    game[x-1][y+1].stack==0	)	push(x-1,y+1);
		if (game[x][y+1].cover==' '	&&
		    game[x][y+1].stack==0	)	push(x,y+1);
		}
	if (x==0 && y==YSIZE-1)
		{
		if (game[x][y-1].cover==' '	&&
		    game[x][y-1].stack==0	)	push(x,y-1);
		if (game[x+1][y-1].cover==' '	&&
		    game[x+1][y-1].stack==0	)	push(x+1,y-1);
		if (game[x+1][y].cover==' '	&&
		    game[x+1][y].stack==0	)	push(x+1,y);
		}
	if (x>0 && x<XSIZE-1 && y==YSIZE-1)
		{
		if (game[x-1][y-1].cover==' '	&&
		    game[x-1][y-1].stack==0	)	push(x-1,y-1);
		if (game[x][y-1].cover==' '	&&
		    game[x][y-1].stack==0	)	push(x,y-1);
		if (game[x+1][y-1].cover==' '	&&
		    game[x+1][y-1].stack==0	)	push(x+1,y-1);
		if (game[x-1][y].cover==' '	&&
		    game[x-1][y].stack==0	)	push(x-1,y);
		if (game[x+1][y].cover==' '	&&
		    game[x+1][y].stack==0	)	push(x+1,y);
		}
	if (x==XSIZE-1 && y==YSIZE-1)
		{
		if (game[x-1][y-1].cover==' '	&&
		    game[x-1][y-1].stack==0	)	push(x-1,y-1);
		if (game[x][y-1].cover==' '	&&
		    game[x][y-1].stack==0	)	push(x,y-1);
		if (game[x-1][y].cover==' '	&&
		    game[x-1][y].stack==0	)	push(x-1,y);
		}
	while (isempty()!=1)
		{
		pop(&x,&y);

		if (game[x][y].cover != 'X') counter++;
		locate(x,y);
		game[x][y].cover = 'X';
		if (game[x][y].board != 0)
			{
			if (view_flag == 0)
				{
				bold();
				view_flag = 1;
				}
			else	if (view_flag != 1)
				{
				normal();
				bold();
				view_flag = 1;
				}
			printf ("%d",game[x][y].board);
			}
		else
			{
			if (view_flag != 0)
				{
				normal();
				view_flag = 0;
				}
			printf(" ");
			}

		if (game[x][y].board == 0)
			{
			if (x==0 && y==0)
				{
				if (game[x+1][y].cover==' '	&&
				    game[x+1][y].stack==0	) push(x+1,y);
				if (game[x][y+1].cover==' '	&&
				    game[x][y+1].stack==0	) push(x,y+1);
				if (game[x+1][y+1].cover==' '	&&
				    game[x+1][y+1].stack==0	) push(x+1,y+1);
				}
			if (x>0 && x<XSIZE-1 && y==0)
				{
				if (game[x-1][y].cover==' '	&&
				    game[x-1][y].stack==0	) push(x-1,y);
				if (game[x+1][y].cover==' '	&&
				    game[x+1][y].stack==0	) push(x+1,y);
				if (game[x-1][y+1].cover==' '	&&
				    game[x-1][y+1].stack==0	) push(x-1,y+1);
				if (game[x][y+1].cover==' '	&&
				    game[x][y+1].stack==0	) push(x,y+1);
				if (game[x+1][y+1].cover==' '	&&
				    game[x+1][y+1].stack==0	) push(x+1,y+1);
				}
			if (x==XSIZE-1 && y==0)
				{
				if (game[x-1][y].cover==' '	&&
				    game[x-1][y].stack==0	) push(x-1,y);
				if (game[x-1][y+1].cover==' '	&&
				    game[x-1][y+1].stack==0	) push(x-1,y+1);
				if (game[x][y+1].cover==' '	&&
				    game[x][y+1].stack==0	) push(x,y+1);
				}
			if (x==0 && y>0 && y<YSIZE-1)
				{
				if (game[x][y-1].cover==' '	&&
				    game[x][y-1].stack==0	) push(x,y-1);
				if (game[x+1][y-1].cover==' '	&&
				    game[x+1][y-1].stack==0	) push(x+1,y-1);
				if (game[x+1][y].cover==' '	&&
				    game[x+1][y].stack==0	) push(x+1,y);
				if (game[x][y+1].cover==' '	&&
				    game[x][y+1].stack==0	) push(x,y+1);
				if (game[x+1][y+1].cover==' '	&&
				    game[x+1][y+1].stack==0	) push(x+1,y+1);
				}
			if (x>0 && x<XSIZE-1 && y>0 && y<YSIZE-1)
				{
				if (game[x-1][y-1].cover==' '	&&
				    game[x-1][y-1].stack==0	) push(x-1,y-1);
				if (game[x][y-1].cover==' '	&&
				    game[x][y-1].stack==0	) push(x,y-1);
				if (game[x+1][y-1].cover==' '	&&
				    game[x+1][y-1].stack==0	) push(x+1,y-1);
				if (game[x-1][y].cover==' '	&&
				    game[x-1][y].stack==0	) push(x-1,y);
				if (game[x+1][y].cover==' '	&&
				    game[x+1][y].stack==0	) push(x+1,y);
				if (game[x-1][y+1].cover==' '	&&
				    game[x-1][y+1].stack==0	) push(x-1,y+1);
				if (game[x][y+1].cover==' '	&&
				    game[x][y+1].stack==0	) push(x,y+1);
				if (game[x+1][y+1].cover==' '	&&
				    game[x+1][y+1].stack==0	) push(x+1,y+1);
				}
			if (x==XSIZE-1 && y>0 && y<YSIZE-1)
				{
				if (game[x-1][y-1].cover==' '	&&
				    game[x-1][y-1].stack==0	) push(x-1,y-1);
				if (game[x][y-1].cover==' '	&&
				    game[x][y-1].stack==0	) push(x,y-1);
				if (game[x-1][y].cover==' '	&&
				    game[x-1][y].stack==0	) push(x-1,y);
				if (game[x-1][y+1].cover==' '	&&
				    game[x-1][y+1].stack==0	) push(x-1,y+1);
				if (game[x][y+1].cover==' '	&&
				    game[x][y+1].stack==0	) push(x,y+1);
				}
			if (x==0 && y==YSIZE-1)
				{
				if (game[x][y-1].cover==' '	&&
				    game[x][y-1].stack==0	) push(x,y-1);
				if (game[x+1][y-1].cover==' '	&&
				    game[x+1][y-1].stack==0	) push(x+1,y-1);
				if (game[x+1][y].cover==' '	&&
				    game[x+1][y].stack==0	) push(x+1,y);
				}
			if (x>0 && x<XSIZE-1 && y==YSIZE-1)
				{
				if (game[x-1][y-1].cover==' '	&&
				    game[x-1][y-1].stack==0	) push(x-1,y-1);
				if (game[x][y-1].cover==' '	&&
				    game[x][y-1].stack==0	) push(x,y-1);
				if (game[x+1][y-1].cover==' '	&&
				    game[x+1][y-1].stack==0	) push(x+1,y-1);
				if (game[x-1][y].cover==' '	&&
				    game[x-1][y].stack==0	) push(x-1,y);
				if (game[x+1][y].cover==' '	&&
				    game[x+1][y].stack==0	) push(x+1,y);
				}
			if (x==XSIZE-1 && y==YSIZE-1)
				{
				if (game[x-1][y-1].cover==' '	&&
				    game[x-1][y-1].stack==0	) push(x-1,y-1);
				if (game[x][y-1].cover==' '	&&
				    game[x][y-1].stack==0	) push(x,y-1);
				if (game[x-1][y].cover==' '	&&
				    game[x-1][y].stack==0	) push(x-1,y);
				}
		
			}
		}
	}
}
		
/*Run when a square is flagged (the user believes it to be a mine).*/

flag(x,y)
int	x,y;
{

if (game[x][y].cover != 'X')
	{
	locate(x,y);
	game[x][y].cover = 'F';
	if (view_flag == 0)
		{
		reverse();
		view_flag = 2;
		}
	else	if (view_flag != 2)
		{
		normal();
		reverse();
		view_flag = 2;
		}
	printf ("F");
	if (game[x][y].board==9) real_flag_counter++; 
	flag_counter++;

	locate(72,length);
	if (view_flag != 0)
		{
		normal();
		view_flag = 0;
		}
	printf("%4d",mine_total-flag_counter);
	}
}

/*Run when a square is unflagged (the user has changed his/her mind).*/

unflag(x,y)
int	x,y;
{

locate(x,y);
game[x][y].cover = ' ';
if (view_flag != 0)
	{
	normal();
	view_flag = 0;
	}
printf ("+");
if (game[x][y].board==9) real_flag_counter--; 
flag_counter--;

locate(72,length);
if (view_flag != 0)
	{
	normal();
	view_flag = 0;
	}
printf("%4d",mine_total-flag_counter);
}

/*Create an empty highscore file in the current directory*/

highscorefile()
{
char	name[150];
int	context;
int	i;
FILE	*fileptr;

context=0;
find_file("highscore.ms",name,&context);
if (context == 0)
	{
	fileptr=fopen("highscore.ms","w");
	fprintf(fileptr,"0\n");
	fprintf(fileptr,"0\n");
	fclose(fileptr);
	}
}

/*
 * For a given file specification (spec) returns one file matching this
 * specification upon each call in the order they appear in the directory.
 * If (context) is equal to zero before the call, the file search will
 * start from the beginning.  If context returns a value of zero, no more
 * files were found.
 */

find_file(spec,name,context)
	char *spec;
	char *name;
	int *context;
	{
	int status;
	char *c_ptr;
	struct dsc$descriptor file_spec = {
		149,
		DSC$K_DTYPE_T,
		DSC$K_CLASS_S,
		spec };
	struct dsc$descriptor file_name = {
		149,
		DSC$K_DTYPE_T,
		DSC$K_CLASS_S,
		name };

	file_spec.dsc$w_length=strlen(spec);
	status=lib$find_file(&file_spec,&file_name,context);
	if(status!=RMS$_NORMAL) *context=0;
	name[file_name.dsc$w_length]='\0';
	c_ptr=strchr(name,' ');
	*c_ptr='\0';
	}

/*
gets a string (replacing scanf) returning when a return is pressed
no matter whether is has only whitespace or what.  The flag allows
or disallows spaces and certain control chars used elsewhere to create
bold, reverse, flashing, or underlined text.
*/

getstring(char str[],int amount,int type)
{
int	i=0,chflag=0,loop,maxi=0;

/*The following is needed for the DEC system service that gets a key.  Will
  have to be modified to work on non-VAX equipment*/

/*===================================*/
char	keyname[20];
int	keyid,key;
struct	dsc$descriptor name = {
	19,
	DSC$K_DTYPE_T,
	DSC$K_CLASS_S,
	keyname };

SMG$CREATE_VIRTUAL_KEYBOARD(&keyid);
/*===================================*/

i=0;maxi=0;
for (loop=0;loop<amount;loop++)
	str[loop]='\0';
str[strlen(str)]='\0';

/*The following is needed for the DEC system service that gets a key.  Will
  have to be modified to work on non-VAX equipment*/

/*===================================*/
	SMG$READ_KEYSTROKE(&keyid,&key);
	SMG$KEYCODE_TO_NAME(&key,&name);
	keyname[strlen(keyname)-strlen(strchr(keyname,' '))] = '\0';
	if (strcmp(keyname,"")==0) strcpy(keyname," ");
/*===================================*/

while (strcmp(keyname,"CTRLM")!=0)
	{

	if (	strcmp(keyname,"LEFT") == 0)
		{
		if (i>0)
			{
			i--;
			printf("\033[D");
			}
		chflag=1;
		}

	if (	strcmp(keyname,"RIGHT") == 0)
		{
		if (i<maxi)
			{
			i++;
			printf("\033[C");
			}
		chflag=1;
		}

	if (	keyname[0] == 127)
		{
		if (i>0)
			{
			i--;
			printf("\033[D");

			for (loop=i;loop<maxi;loop++)
				{
				str[loop]=str[loop+1];
			if (	str[loop] == '\002')
				{
				reverse();
				printf("B");
				normal();
				}
			else	
				{if (	str[loop] == '\006')
					{
					reverse();
					printf("F");
					normal();
					}
			else	
				{if (	str[loop] == '\016')
					{
					reverse();
					printf("N");
					normal();
					}
			else	
				{if (	str[loop] == '\022')
					{
					reverse();
					printf("R");
					normal();
					}
			else
				{if (	str[loop] == '\025')
					{
					reverse();
					printf("U");
					normal();
					}
			else	
				{if (	str[loop] == '\001')
					{
					reverse();
					printf(" ");
					normal();
					}
			else	printf("%c",str[loop]);
				}}}}}}
			
			str[maxi]='\0';
			printf(" ");

			for (loop=maxi;loop>i;loop--)
				printf("\033[D");

			maxi--;
			}
		chflag=1;
		}

	if (	strcmp(keyname,"CTRLE") == 0)
		{
		if (i<maxi)
			{
			for (loop=i;loop<maxi;loop++)
				printf("\033[C");
			i=maxi;
			}
		chflag=1;
		}

	if (	strcmp(keyname,"CTRLH") == 0)
		{
		if (i>0)
			{
			for (loop=i;loop>0;loop--)
				printf("\033[D");
			i=0;
			}
		chflag=1;
		}

	if (	strcmp(keyname,"CTRLB") == 0	&&	type == 0)
		{
		str[i++]='\002';
		reverse();
		printf("B");
		normal();
		chflag=1;
		}
	if (	strcmp(keyname,"CTRLF") == 0	&&	type == 0)
		{
		str[i++]='\006';
		reverse();
		printf("F");
		normal();
		chflag=1;
		}
	if (	strcmp(keyname,"CTRLN") == 0	&&	type == 0)
		{
		str[i++]='\016';
		reverse();
		printf("N");
		normal();
		chflag=1;
		}
	if (	strcmp(keyname,"CTRLR") == 0	&&	type == 0)
		{
		str[i++]='\022';
		reverse();
		printf("R");
		normal();
		chflag=1;
		}
	if (	strcmp(keyname,"CTRLU") == 0	&&	type == 0)
		{
		str[i++]='\025';
		reverse();
		printf("U");
		normal();
		chflag=1;
		}
	if (	strcmp(keyname," ") == 0)
		{
		if (type == 0)
			str[i++]='\001';
		else
			{
			if (type == 1)
				str[i++]='_';
			else
				str[i++]=' ';
			}
		printf(" ");
		chflag=1;
		}

	if (chflag==1)
		chflag=0;
	else
		{
		for (loop=0;loop<strlen(keyname);loop++)
			{
			if (i<amount)
				{
				str[i++]=keyname[loop];
				printf("%c",keyname[loop]);
				}
			}
		chflag=0;
		}

	if (i>maxi) maxi=i;

/*The following is needed for the DEC system service that gets a key.  Will
  have to be modified to work on non-VAX equipment*/

/*===================================*/
	SMG$READ_KEYSTROKE(&keyid,&key);
	SMG$KEYCODE_TO_NAME(&key,&name);
	keyname[strlen(keyname)-strlen(strchr(keyname,' '))] = '\0';
	if (strcmp(keyname,"")==0) strcpy(keyname," ");
/*===================================*/
	}
}

/*this adds to and from the highscore file and also displays it*/

high (int flag)
{

typedef
	struct	HIGHSCORE	{
			 	char			name[60];
			 	char			username[60];
				int			score;
				int			games;
				struct	HIGHSCORE	*next;
				}
	HISCORE;

HISCORE	*hiscore,*deadscore,*list,*track,*temp,*current;

char	name[60],username[60],dumstr[60];
int	score,games,dumint,chflag=0,
	entry,i,count,add_entry,
	entry_num,deadentry_num;
FILE	*fileptr;

/*The following is needed for the DEC system service that gets a username.  Will
  have to be modified to work on non-VAX equipment*/

/*===================================*/
struct	dsc$descriptor u_name = {
	19,
	DSC$K_DTYPE_T,
	DSC$K_CLASS_S,
	name };
struct	dsc$descriptor user_name = {
	19,
	DSC$K_DTYPE_T,
	DSC$K_CLASS_S,
	username };
/*===================================*/

clear();

/* (flag==3) is a test for whether the username is in the highscore file*/
/* (flag==2) shows the highscore file*/
/* (flag==1) is if you win*/
/* (flag==0) is if you lose*/

if (flag!=3)
	{
	score	=
	( ( real_flag_counter + counter )
	* ( mine_total%( XSIZE * YSIZE - 4 ) )
	/ ( XSIZE * YSIZE * 147 / 10000 * 10 + 10 )
	/ ( hint + 1 )
	+ 1 )
	* (-2 * quit_flag + 1);
	}
	games = 1;

if (flag==2)
	printf("You have %d points!!!\n",score * (-2 * quit_flag + 1));
if (flag==1)
	printf("You won with %d points!!!\n\n",score);
if (flag==0)
	{
	if (quit_flag==1)
		printf("You quit after accumulating %d points!!!\n\n",
			score * (-2 * quit_flag + 1));
	else
		printf("You died after accumulating %d points!!!\n\n",score);
	}

if (score==0) flag=2;

/*The following is needed for the DEC system service that gets a username.  Will
  have to be modified to work on non-VAX equipment*/

/*===================================*/
	lib$getjpi(&(JPI$_USERNAME),0,0,0,&user_name,0);
	username[strlen(username)-strlen(strchr(username,' '))] = '\0';
/*===================================*/

if (flag!=2 && flag!=3)
	{
	printf("Enter a name for the high score file: ");
	getstring(name,40,0);
	printf("\n");

	if (strlen(name)==0)
		{
/*Another system service used to replace a blank string with the username*/
/*The following is needed for the DEC system service that gets a username.  Will
  have to be modified to work on non-VAX equipment*/

/*===================================*/
		lib$getjpi(&(JPI$_USERNAME),0,0,0,&u_name,0);
		name[strlen(name)-strlen(strchr(name,' '))] = '\0';
/*===================================*/
		}

	if ((current = (HISCORE *) malloc(sizeof(HISCORE))) == NULL)
		{
		printf ("Cannot open space.");
		exit (1);
		}

	strcpy(current->name,name);
	strcpy(current->username,username);
	current->score=score;
	current->games=games;
	current->next=NULL;
	}

if ((hiscore = (HISCORE *) malloc(sizeof(HISCORE))) == NULL)
	{
	printf ("Cannot open space.");
	exit (1);
	}

strcpy(hiscore->name," ");
strcpy(hiscore->username,"MineSweeper");
hiscore->score=0;
hiscore->games=0;
hiscore->next=NULL;

if ((deadscore = (HISCORE *) malloc(sizeof(HISCORE))) == NULL)
	{
	printf ("Cannot open space.");
	exit (1);
	}

strcpy(deadscore->name," ");
strcpy(deadscore->username,"MineSweeper");
deadscore->score=0;
deadscore->games=0;
deadscore->next=NULL;

fileptr=fopen("highscore.ms","r");
if (fileptr == NULL)
	{
	highscorefile();
	fileptr = fopen ("highscore.ms","r");
	}

fscanf(fileptr,"%d",&entry_num);

list = hiscore;
for(i=0;i<entry_num;i++)
	{
	if ((temp = (HISCORE *) malloc(sizeof(HISCORE))) == NULL)
		{
		printf ("Cannot open space.  High score file is too big!");
		exit (1);
		}

	fscanf(fileptr,"%s",&dumstr);
	strcpy(temp->name,dumstr);
	fscanf(fileptr,"%s",&dumstr);
	strcpy(temp->username,dumstr);
	fscanf(fileptr,"%d",&dumint);
	temp->score=dumint;
	fscanf(fileptr,"%d",&dumint);
	temp->games=dumint;
	temp->next=NULL;

	list->next = temp;
	list = list->next;
	}

fscanf(fileptr,"%d",&deadentry_num);

list = deadscore;
for(i=0;i<deadentry_num;i++)
	{
	if ((temp = (HISCORE *) malloc(sizeof(HISCORE))) == NULL)
		{
		printf ("Cannot open space.  High score file is too big!");
		exit (1);
		}

	fscanf(fileptr,"%s",&dumstr);
	strcpy(temp->name,dumstr);
	fscanf(fileptr,"%s",&dumstr);
	strcpy(temp->username,dumstr);
	fscanf(fileptr,"%d",&dumint);
	temp->score=dumint;
	fscanf(fileptr,"%d",&dumint);
	temp->games=dumint;
	temp->next=NULL;

	list->next = temp;
	list = list->next;
	}

fclose(fileptr);

if (flag==3)
	{
	list=hiscore->next;
	track=hiscore;
	while(	list != NULL)
 		{
		if (strcmp(list->username,username)==0)
			return(1);
		list=list->next;
		track=track->next;
		}
	list=deadscore->next;
	track=deadscore;
	while(	list != NULL)
		{
		if (strcmp(list->username,username)==0)
			return(1);
		list=list->next;
		track=track->next;
		}
	return(0);
	}

if (flag==1)
	{
	list=hiscore->next;
	track=hiscore;
	add_entry=0;
	while(list != NULL)
		{
		if (strcmp(list->name,current->name)==0)
			{
			add_entry=1;
			list->score = list->score + current->score; 
			list->games++;
			free(current);
			current=list;
			}
		list=list->next;
		track=track->next;
		}
	if (add_entry==0)
		{
		list=hiscore->next;
		track=hiscore;
		while(	list != NULL	&&
			list->score > current->score)
			{
			list=list->next;
			track=track->next;
			}
		current->next=list;
		track->next=current;
		}
	}
if (flag==0)
	{
	list=hiscore->next;
	track=hiscore;
	while(	list != NULL)
		{
		if (strcmp(list->name,current->name)==0)
			{
			current->score = current->score + list->score;
			current->games++;
			temp=list;
			list=temp->next;
			track->next=list;
			free(temp);
			}
		else
			{
			list=list->next;
			track=track->next;
			}
		}

	list=deadscore->next;
	track=deadscore;
	add_entry=0;
	while(	list != NULL	&&
		add_entry==0)
		{
		if (list->score>current->score)
			{
			list=list->next;
			track=track->next;
			}
		else
			add_entry=1;
		}
	current->next=list;
	track->next=current;
	}

if (flag!=2)
	{
	fileptr=fopen("highscore.ms","w");

	count=0;
	list = hiscore->next;
	while (list != NULL)
		{
		count++;
		list = list->next;
		}
	fprintf(fileptr,"%d\n",count);

	list = hiscore->next;
	while (list != NULL)
		{
		fprintf(fileptr," %s",list->name);
		fprintf(fileptr," %s",list->username);
		fprintf(fileptr," %d",list->score);
		fprintf(fileptr," %d",list->games);
		fprintf(fileptr,"\n");
		list = list->next;
		}

	count=0;
	list = deadscore->next;
	while (list != NULL)
		{
		count++;
		list = list->next;
		}
	fprintf(fileptr,"%d\n",count);

	list = deadscore->next;
	while (list != NULL)
		{
		fprintf(fileptr," %s",list->name);
		fprintf(fileptr," %s",list->username);
		fprintf(fileptr," %d",list->score);
		fprintf(fileptr," %d",list->games);
		fprintf(fileptr,"\n");
		list = list->next;
		}

	fclose(fileptr);
	}

printf("\n");
printf("		High Scores:\nStatus  Games      Score  Rank  Name\n");

count=0;
list = hiscore->next;
while (list != NULL)
	{
	count++;
	if (count<4 || strcmp(list->name,current->name)==0 || flag==2)
		{
		normal();
		if (list==current) bold();
		printf("Won:    ");
		printf("%5d ",list->games);
		printf("%10d ",list->score);
		printf("%5d  ",count);
		if (list==current) normal();
	
		chflag=0;
		i=0;
		while ( (list->name)[i] != '\0')
			{
			if ((list->name)[i] == '\001')
				{
				printf(" ");
				chflag=1;
				}
			if ((list->name)[i] == '\002')
				{
				bold();
				chflag=1;
				}
			if ((list->name)[i] == '\006')
				{
				flash();
				chflag=1;
				}
			if ((list->name)[i] == '\016')
				{
				normal();
				chflag=1;
				}
			if ((list->name)[i] == '\022')
				{
				reverse();
				chflag=1;
				}
			if ((list->name)[i] == '\025')
				{
				underline();
				chflag=1;
				}
			if (chflag != 1)
				{
				printf("%c",(list->name)[i]);
				}
			chflag=0;
			i++;
			}
	        printf("\n");
		}
	list = list->next;
	}

count=0;
list = deadscore->next;
while (list != NULL)
	{
	count++;
	if (count<4 || strcmp(list->name,current->name)==0 || flag==2)
		{
		normal();
		if (list==current) bold();
		if (list->score<0)
			printf("Quit:   ");
		else
			printf("Died:   ");
		printf("%5d ",list->games);
		printf("%10d ",list->score * (-2 * (list->score<0) + 1));
		printf("%5d  ",count);
		if (list==current) normal();
	
		chflag=0;
		i=0;
		while ( (list->name)[i] != '\0')
			{
			if ((list->name)[i] == '\001')
				{
				printf(" ");
				chflag=1;
				}
			if ((list->name)[i] == '\002')
				{
				printf(BOLD);
				chflag=1;
				}
			if ((list->name)[i] == '\006')
				{
				printf(FLASH);
				chflag=1;
				}
			if ((list->name)[i] == '\016')
				{
				printf(NORMAL);
				chflag=1;
				}
			if ((list->name)[i] == '\022')
				{
				printf(REVERSE);
				chflag=1;
				}
			if ((list->name)[i] == '\025')
				{
				printf(UNDERLINE);
				chflag=1;
				}
			if (chflag != 1)
				{
				printf("%c",(list->name)[i]);
				}
			chflag=0;
			i++;
			}
	        printf("\n");
		}
	list = list->next;
	}

if (flag!=2) exit(0);
}

/*
the following two routines clear the rest of the board if you have obviously
won the game so that you don't have to clear every spoty yourself
*/

autoclear()
{
int x,y;

for(x=0;x<XSIZE;x++)
for(y=0;y<YSIZE;y++)
	if (game[x][y].cover==' ' && game[x][y].board!=9) expose(x,y);
}

autoflag()
{
int x,y;

for(x=0;x<XSIZE;x++)
for(y=0;y<YSIZE;y++)
	if (game[x][y].cover==' ' && game[x][y].board==9) flag(x,y);
}

/*Redraws the screen, counting for a win.*/

draw()
{
int	x,y;
int	no_win=0;

view_flag=0;
clear();
printf (" ");
for (x=0;x<XSIZE;x++)
	printf ("_");
printf ("\n");
for (y=0;y<YSIZE;y++)
	{
	printf ("|");
	for (x=0;x<XSIZE;x++)
		{
		if (game[x][y].board != 9	&&
		    game[x][y].cover == 'F') no_win = 1;
		if (game[x][y].board == 9	&&
		    game[x][y].cover != 'F') no_win = 1;

		if (game[x][y].cover == ' ')
			{
			if (view_flag != 0)
				{
				normal();
				view_flag = 0;
				}
			printf ("+");
			}
		if (game[x][y].cover == 'X')
			if (game[x][y].board != 0)
				{
				if (view_flag == 0)
					{
					bold();
					view_flag = 1;
					}
				else	if (view_flag != 1)
					{
					normal();
					bold();
					view_flag = 1;
					}
				printf ("%d",game[x][y].board);
				}
			else
				{
				if (view_flag != 0)
					{
					normal();
					view_flag = 0;
					}
				printf(" ");
				}
		if (game[x][y].cover == 'F')
			{
			if (view_flag == 0)
				{
				reverse();
				view_flag = 2;
				}
			else	if (view_flag != 2)
				{
				normal();
				reverse();
				view_flag = 2;
				}
			printf ("F");
			}
		if (game[x][y].cover != ' '	&&
		    game[x][y].cover != 'X'	&&
		    game[x][y].cover != 'F')
			{
			if (view_flag == 0)
				{
				reverse();
				flash();
				view_flag = 3;
				}
			else	if (view_flag != 3)
				{
				normal();
				reverse();
				flash();
				view_flag = 3;
				}
			printf("%c",game[x][y].cover);
			}
		}
	if (view_flag != 0)
		{
		normal();
		view_flag = 0;
		}
	printf ("|");
	printf ("\n");
	}
printf (" ");
for (x=0;x<XSIZE;x++)
	printf ("~");

locate(1,length);
if (view_flag != 0)
	{
	normal();
	view_flag = 0;
	}
printf("Press HELP for keypad diagram or FIND for help.  ");
printf("Number of mines left: %4d",mine_total-flag_counter);

if (no_win != 1)
	{
        high(1);
	}
}

/*Displays the minefield when the user quits or dies.  Gives percent done.*/

show(a,b)
int	a,b;
{       
int	x,y,i;
char	answer[80];

/*The following is needed for the DEC system service that gets a key.  Will
  have to be modified to work on non-VAX equipment*/

/*===================================*/
int	keyid,key;
struct	dsc$descriptor ans = {
	19,
	DSC$K_DTYPE_T,
	DSC$K_CLASS_S,
	answer };

SMG$CREATE_VIRTUAL_KEYBOARD(&keyid);
/*===================================*/

normal();
locate (1,length);
for (i=0;i<75;i++)
	printf(" ");
locate (1,length);
printf("Do you want to see the minefield? (Return = No) ");

/*The following is needed for the DEC system service that gets a key.  Will
  have to be modified to work on non-VAX equipment*/

/*===================================*/
SMG$READ_KEYSTROKE(&keyid,&key);
SMG$KEYCODE_TO_NAME(&key,&ans);
answer[strlen(answer)-strlen(strchr(answer,' '))] = '\0';
if (strcmp(answer,"")==0) strcpy(answer," ");
/*===================================*/

if (answer[0]=='Y'	||
    answer[0]=='y'	||
    answer[0]==""	)
	{
	clear();
	view_flag = 0;
	printf (" ");
	for (x=0;x<XSIZE;x++)
		printf ("_");
	printf ("\n");
	for (y=0;y<YSIZE;y++)
		{
		printf ("|");
		for (x=0;x<XSIZE;x++)
			{
			if (a == x && b == y && a != -1 && b != -1)
				{
				if (view_flag == 0)
					{
					reverse();
					view_flag = 2;
					}
				else	if (view_flag != 2)
					{
					normal();
					reverse();
					view_flag = 2;
					}
				if (game[x][y].board == 9)
					printf (" ");
				else
					printf ("%d",game[x][y].board);
				}
			else	if (game[x][y].board == 9)
				{
				if (view_flag == 0)
					{
					reverse();
					view_flag = 2;
					}
				else	if (view_flag != 2)
					{
					normal();
					reverse();
					view_flag = 2;
					}
				if (game[x][y].cover == 'F')
					printf ("F");
				else
					printf ("#");
				}
			else	if (game[x][y].board == 0)
				{
				if (game[x][y].cover == 'F')
					{
					if (view_flag != 3)
						{
						if (view_flag == 0)
							{
							flash();
							view_flag = 3;
							}
                                                else
							{
							normal();
							flash();
							view_flag = 3;
							}
						}
					}
				else	if (view_flag != 0)
					{
					normal();
					view_flag = 0;
					}
				printf (" ");
				}
			else
				{
				if (game[x][y].cover == 'F')
					{
					if (view_flag != 4)
						{
						if (view_flag == 0)
							{
							flash();
							bold();
							view_flag = 4;
							}
                                                else
							{
							normal();
							flash();
							bold();
							view_flag = 4;
							}
						}
					}
				else
					{
					if (view_flag != 1)
						{
						if (view_flag == 0)
							{
							bold();
							view_flag = 1;
							}
                                                else
							{
							normal();
							bold();
							view_flag = 1;
							}
						}
					}
		    		printf ("%d",game[x][y].board);
				}
			}
		if (view_flag != 0)
			{
			normal();
			view_flag = 0;
			}
		printf ("|");
		printf ("\n");
		}
	printf (" ");
	for (x=0;x<XSIZE;x++)
		printf ("~");
	sleep(5);
	}

high(0);
exit(0);
}

/*Clears the arrays at the beginning of the game.*/
empty()
{
int	x,y;

for (y=0;y<YSIZE;y++)
	for (x=0;x<XSIZE;x++)
		{
		game[x][y].cover = ' ';
		game[x][y].board = 0;
		game[x][y].stack = 0;
		}
}

/*Places the mines randomly (using the system time as the seed).  Will have to
  be modified for non-VAX equipment.*/

fill()
{
int	x,y,n,m;
char	date_time[24];
int	bin_d_t;
struct	dsc$descriptor d_t = {
	23,
	DSC$K_DTYPE_T,
	DSC$K_CLASS_S,
	date_time };

/*The following is needed for the DEC system service that gets the time.  Will
  have to be modified to work on non-VAX equipment*/

/*===================================*/
LIB$DATE_TIME(&d_t);
date_time[24]='\0';
printf ("%s\n",date_time);
SYS$BINTIM(&d_t,&bin_d_t);
/*===================================*/

sleep(1);

n = 0;
m = 0;

if (bin_d_t == 0) bin_d_t++;
if (bin_d_t  < 0) bin_d_t = bin_d_t * -1;
srand(bin_d_t);

if (DEBUG == 1) clear();
while	(n<MINES && m<100000)
	{
	x=rand()%(XSIZE*10)/10;
	y=rand()%(YSIZE*10)/10;
	if (game[x][y].board	!= 9	&&
	   !	((x==0 || x==XSIZE-1)	&&
		 (y==0 || y==YSIZE-1))	)
		{
		n++;
		game[x][y].board = 9;
		if (DEBUG == 1)
			{
			locate(x,y);
			printf("+");
			}
		}
	m++;
	}
mine_total = n;
sleep(3);
}

/*Calculates the numbers based on the locations of the mines in the field.*/
calc()
{
int	x,y;

for (y=0;y<YSIZE;y++)
	{
	for (x=0;x<XSIZE;x++)
		{
		if (game[x][y].board==0)
			{
                        if (x==0 && y==0)
			game[x][y].board=
			  (game[x+1][y].board == 9)+
			  (game[x][y+1].board == 9)+
			  (game[x+1][y+1].board == 9);
                        if (x>0 && x<XSIZE-1 && y==0)
			game[x][y].board=
			  (game[x-1][y].board == 9)+
			  (game[x+1][y].board == 9)+
			  (game[x-1][y+1].board == 9)+
			  (game[x][y+1].board == 9)+
			  (game[x+1][y+1].board == 9);
                        if (x==XSIZE-1 && y==0)
			game[x][y].board=
			  (game[x-1][y].board == 9)+
			  (game[x-1][y+1].board == 9)+
			  (game[x][y+1].board == 9);
                        if (x==0 && y>0 && y<YSIZE-1)
			game[x][y].board=
			  (game[x][y-1].board == 9)+
			  (game[x+1][y-1].board == 9)+
			  (game[x+1][y].board == 9)+
			  (game[x][y+1].board == 9)+
			  (game[x+1][y+1].board == 9);
			if (x>0 && x<XSIZE-1 && y>0 && y<YSIZE-1)
			game[x][y].board=
			  (game[x-1][y-1].board == 9)+
			  (game[x][y-1].board == 9)+
			  (game[x+1][y-1].board == 9)+
			  (game[x-1][y].board == 9)+
			  (game[x+1][y].board == 9)+
			  (game[x-1][y+1].board == 9)+
			  (game[x][y+1].board == 9)+
			  (game[x+1][y+1].board == 9);
			if (x==XSIZE-1 && y>0 && y<YSIZE-1)
			game[x][y].board=
			  (game[x-1][y-1].board == 9)+
			  (game[x][y-1].board == 9)+
			  (game[x-1][y].board == 9)+
			  (game[x-1][y+1].board == 9)+
			  (game[x][y+1].board == 9);
			if (x==0 && y==YSIZE-1)
			game[x][y].board=
			  (game[x][y-1].board == 9)+
			  (game[x+1][y-1].board == 9)+
			  (game[x+1][y].board == 9);
			if (x>0 && x<XSIZE-1 && y==YSIZE-1)
			game[x][y].board=
			  (game[x-1][y-1].board == 9)+
			  (game[x][y-1].board == 9)+
			  (game[x+1][y-1].board == 9)+
			  (game[x-1][y].board == 9)+
			  (game[x+1][y].board == 9);
			if (x==XSIZE-1 && y==YSIZE-1)
			game[x][y].board=
			  (game[x-1][y-1].board == 9)+
			  (game[x][y-1].board == 9)+
			  (game[x-1][y].board == 9);
			}
		}
	}
}

/*Help routine.*/
command_line()
{
reverse();
printf("Command Line Parameters.");
normal();
bold();
printf("	<key>=<number>\n");
normal();
printf("\n");
bold();
printf("x or c or w	");
normal();
printf("The number of Columns or the Width of the field\n");
bold();
printf("y or r or l	");
normal();
printf("The number of Rows or the Length of the field\n");
bold();
printf("s      		");
normal();
printf("The filename of a saved game\n");
bold();
printf("b or m		");
normal();
printf("The number of Mines\n");
bold();
printf("h		");
normal();
printf("The number of Hints\n");
bold();
printf("d		");
normal();
printf("If D=1 then display the mines as they are being buried\n");
bold();
printf("?		");
normal();
printf("list of keys and brief description of game\n");
bold();
printf("/		");
normal();
printf("shows the entire high score file and your current score\n");
}

/*Help routine.*/
keys()
{
reverse();
printf("Keys.\n");
normal();
printf("\n");
bold();
printf("Control-W	");
normal();
printf("redraw the screen\n");
bold();
printf("q or DO		");
normal();
printf("quit\n");
bold();
printf("p or INSERTHERE ");
normal();
printf("preserve (save) the game at the current spot\n");
bold();
printf("s or SELECT	");
normal();
printf("clear the space the cursor is on\n");
bold();
printf("d or PREVSCREEN	");
normal();
printf("will NOT clear the space the cursor is on, but\n");
printf("		if it is already clear and the right number of\n");
printf("		flags surround it, all the surrounding unflaged\n");
printf("		spots will be cleared\n");
bold();
printf("f or NEXTSCREEN	");
normal();
printf("flag (or if flagged then unflag) the space the cursor is on\n");
bold();
printf("h or Return	");
normal();
printf("hint key: may only be used three times.  Will clear or\n");
printf("		flag the space the cursor is on, whichever is appropriate\n");
bold();
printf("i, j, k, and l	");
normal();
printf("cursor keys\n");
bold();
printf("HELP		");
normal();
printf("keypad drawing\n");
bold();
printf("? or FIND	");
normal();
printf("list of keys and brief description of game\n");
bold();
printf("/ or REMOVE	");
normal();
printf("shows the entire high score file and your current score\n");
}

/*Help routine.*/
keypad()
{
reverse();
printf("Keypad.\n");
normal();
printf("\n");
printf("                       .-------------.---------------------------.\n");
printf("                       |     HELP    |            DO             |\n");
printf("                       | keypad help |         quit game         |\n");
printf("                       `-------------'---------------------------'\n");
printf("                       .-------------.-------------.-------------.\n");
printf("                       |     FIND    | INSERT HERE |   REMOVE    |\n");
printf("                       | help screen |  save game  | high scores |\n");
printf(".-------------.        |-------------|-------------|-------------|\n");
printf("|    RETURN   |        |    SELECT   | PREV SCREEN | NEXT SCREEN |\n");
printf("|     hint    |        |    clear    | safetyclear |    flag     |\n");
printf("`-----.       |        `-------------|-------------|-------------'\n");
printf("      |       |                      |      UP     |              \n");
printf("      |       |                      |             |              \n");
printf("      `-------'        .-------------|-------------|-------------.\n");
printf("                       |     LEFT    |     DOWN    |    RIGHT    |\n");
printf("                       |             |             |             |\n");
printf("                       `-------------`-------------'-------------'\n");
printf("\n");
printf("		Press ? or FIND to get nore detailed help\n");
}

/*Help routine.*/
info()
{
reverse();
printf("MineSweeper.\n");
normal();
printf("\n");
printf("The goal is to find and flag all the mines in the minefield.\n");
printf("You win when the field is entirely cleared except for the flagged\n");
printf("mines.  You have exactly the right number of flags.\n");
printf("\n");
printf("The number that shows up when you clear a spot tells how many mines\n");
printf("are on one of the eight neighbouring spots.  These are the clues you\n");
printf("have to where the mines are.\n");
printf("\n");
printf("The score calculated is approximately:\n");
printf("\n");
printf("        Number_of_squares_cleared_or_flagged * Number_of_mines\n");
printf("score = ------------------------------------------------------\n");
printf("              14%_of_size_of_Board * Number_of_hints_used\n");
}

/*Help routine.*/
other_info()
{
reverse();
printf("Other Information.\n");
normal();
printf("\n");
printf("When you die and see the minefield:\n");
flash();
printf("n");
normal();
printf(" are spots that have been flagged and are not mines\n");
reverse();
printf("#");
normal();
printf(" are spots that have not been flagged and are mines\n");
reverse();
printf("F");
normal();
printf(" are spots that have been flagged and are mines\n");
reverse();
printf(" ");
normal();
printf(" is the mine you cleared that killed you.\n");
printf("\n");
printf("When you enter your name for the highscore file these keys work:\n");
printf("(If you do not enter a name your username is used)\n");
printf("Control-N	Normal:    turns off all other codes\n");
printf("Control-B	Bold:      bolds all following text until Normal\n");
printf("Control-F	Flash:     flashs all following text until Normal\n");
printf("Control-R	Reverse:   reverses all following text until Normal\n");
printf("Control-U	Underline: underlines all following text until Normal\n");
printf("\n");
printf("When you put your name in the high score file, the file showed to you\n");
printf("has only the top three people who won and the top three people who died,\n");
printf("as well as all of the entries with the entered name.\n");
}

help(int flag)
{
if (flag==1) 
	{
	clear();
	info();
	printf("\n");
	sleep(5);
	clear();
	keypad();
	printf("\n");
	sleep(5);
	clear();
	keys();
	printf("\n");
	sleep(5);
	clear();
	command_line();
	printf("\n");
	sleep(5);
	clear();
	other_info();
	printf("\n");
	sleep(5);
	}
if (flag==0) 
	{
	clear();
	command_line();
	}
}

/*The following is needed for the DEC system service that gets the terminal
  size.  Will have to be modified to work on non-VAX equipment*/

/*===================================*/
#define size 8

termsize()
{
char buffer[size],param[20];
unsigned long chan;
char i;
char devnam[20];
struct dsc$descriptor device_name = {
	19,
	DSC$K_DTYPE_T,
	DSC$K_CLASS_S,
	devnam };

strcpy(devnam,"SYS$INPUT:");
device_name.dsc$w_length=strlen(devnam);

i=SYS$ASSIGN(&device_name,&chan,NULL,NULL,NULL);
LIB$SIGNAL(i);

i=SYS$QIOW(NULL,chan,IO$_SENSEMODE,
	   NULL,NULL,NULL,&buffer,size,NULL,NULL,NULL,NULL);

swidth = buffer[2];
slength = buffer[7];

if (swidth<1)
	swidth = 256 + swidth;
if (slength<1)
	slength = 256 + slength;

if (slength<24)
	length=24;
else
	length=slength;

if (swidth<80)
	width=80;
else
	width=swidth;

buffer[2] = width-256*(width>127);
buffer[7] = length-256*(length>127);

	i=SYS$QIOW(NULL,chan,IO$_SETMODE,
		   NULL,NULL,NULL,&buffer,size,NULL,NULL,NULL,NULL);

}

/*===================================*/

/*This is the \main loop.*/

main (argc,argv)
int 	argc;
char	*argv[];
{
FILE	*fileptr;
char	savename[60];
int	save_flag=0,skip=0;
int	x=0,y=0,n=0;
int	ix,iy,i;
int	hint_flag,mine_flag;
int	count;
int	getone,num;
char	param[20];

/*The following is needed for the DEC system service that gets a key.  Will
  have to be modified to work on non-VAX equipment*/

/*===================================*/
char	keyname[20];
int	keyid,key;
struct	dsc$descriptor name = {
	19,
	DSC$K_DTYPE_T,
	DSC$K_CLASS_S,
	keyname };

SMG$CREATE_VIRTUAL_KEYBOARD(&keyid);
/*===================================*/

termsize();
XSIZE=swidth-3;
if (XSIZE<3)
	{
	printf("The terminal width is too small.");
	exit(1);
	}
YSIZE=slength-2;
if (YSIZE<1)
	{
	printf("The terminal height is too small.");
	exit(1);
	}
printf("Terminal size: %d x %d\n\n",width,length);

/*Parse the command line arguements.*/
if (argc>1)
	{
	for (getone=1;getone<argc;getone++)
		{
		sscanf (argv[getone],"%s",&param);
		printf ("Working on parameter: %s\n",param);

		if (param[0] == '/')
			{
			high(2);
			exit(0);
			}
		if (param[0] == '?')
			{
			help(1);
			exit(0);
			}
		if (strpbrk(param,"=")==NULL)
			{
			help(0);
			exit(1);
			}
		if (param[1] != '=')
			{
			help(0);
			exit(1);
			}
		if (param[0] != 'L'	&&
		    param[0] != 'l'	&&
		    param[0] != 'Y'	&&
		    param[0] != 'y'	&&
		    param[0] != 'R'	&&
		    param[0] != 'r'	&&
		    param[0] != 'W'	&&
		    param[0] != 'w'	&&
		    param[0] != 'X'	&&
		    param[0] != 'x'	&&
		    param[0] != 'C'	&&
		    param[0] != 'c'	&&
		    param[0] != 'M'	&&
		    param[0] != 'm'	&&
		    param[0] != 'B'	&&
		    param[0] != 'b'	&&
		    param[0] != 'S'	&&
		    param[0] != 's'	&&
		    param[0] != 'H'	&&
		    param[0] != 'h'	&&
		    param[0] != 'D'	&&
		    param[0] != 'd')
			{
			help(0);
			exit(1);
			}
		if (param[0] == 'L'	||
		    param[0] == 'l'	||
		    param[0] == 'R'	||
		    param[0] == 'r'	||
		    param[0] == 'Y'	||
		    param[0] == 'y')
			{
			if (atoi(strchr(param,'=')+sizeof(char))<YSIZE)
				{
				YSIZE = atoi(strchr(param,'=')+sizeof(char));
				if (YSIZE<1) YSIZE = 1;
				}
			printf("%d rows\n",YSIZE);
			}
		if (param[0] == 'W'	||
		    param[0] == 'w'	||
		    param[0] == 'C'	||
		    param[0] == 'c'	||
		    param[0] == 'X'	||
		    param[0] == 'x')
			{
			if (atoi(strchr(param,'=')+sizeof(char))<XSIZE)
				{
				XSIZE = atoi(strchr(param,'=')+sizeof(char));
				if (XSIZE<3) XSIZE = 3;
				}
			printf("%d columns\n",XSIZE);
			}
		if (param[0] == 'H'	||
		    param[0] == 'h')
			{
			HINTS = atoi(strchr(param,'=')+sizeof(char));
			if (HINTS<0) HINTS = 0;
			printf("%d hints\n",HINTS);
			hint_flag = 1;
			}
		if (param[0] == 'S'	||
		    param[0] == 's')
			{
			strcpy(savename, strchr(param,'=')+sizeof(char));
			printf("Restoring %s\n",savename);
			save_flag = 1;
			}
		if (param[0] == 'M'	||
		    param[0] == 'm'	||
		    param[0] == 'B'	||
		    param[0] == 'b')
			{
			MINES = atoi(strchr(param,'=')+sizeof(char));
			if (MINES<1) MINES = 1;
			printf("%d mines\n",MINES);
			mine_flag = 1;
			}
		if (param[0] == 'D'	||
		    param[0] == 'd')
			{
			DEBUG = atoi(strchr(param,'=')+sizeof(char));
			}
		}
	}

if (high(3) != 1)
	{
	help(1);
	clear();
	}
if (mine_flag != 1)
	{
	MINES=XSIZE*YSIZE*147/10000*10+10;
	printf ("\nThe number of mines for this game is projected to be %d.\n",MINES);
	}
if (hint_flag != 1)
	printf ("\nThe number of hints for this game will be %d.\n\n",HINTS);
if (save_flag == 1)
	{
	fileptr = fopen (savename,"r");
	skip=0;
	while (fileptr == NULL	&&	skip == 0)
		{
		printf("Enter the name of a game to restore:  (Return to go skip) ");
		getstring(savename,60,1);
		skip=0;	if (strlen(savename)==0) skip=1;
		if (skip==0) fileptr = fopen (savename,"r");
		printf("\n");
		}
	if (skip==0)
		{
		fscanf (fileptr,"%d",&real_flag_counter);
		fscanf (fileptr,"%d",&flag_counter);
		fscanf (fileptr,"%d",&counter);
		fscanf (fileptr,"%d",&XSIZE);
		fscanf (fileptr,"%d",&YSIZE);
		fscanf (fileptr,"%d",&hint);
		fscanf (fileptr,"%d",&HINTS);
		fscanf (fileptr,"%d",&mine_total);
		}
	}

/*Build the game board array.*/
if ((game = (TABLE **) malloc(XSIZE*sizeof(TABLE *))) != NULL)
	{
	for(i = 0; i<XSIZE; i++)
		{
		if ((game1 = (TABLE *) malloc(YSIZE*sizeof(TABLE))) != NULL)
			game[i] = game1;
		else
			{
			printf ("Cannot open space.  Choose a smaller size.");
			exit (1);
			}
		}
	}
else
	{
	printf ("Cannot open space.  Chose a smaller size.");
	exit (1);
	}

if (save_flag == 1	&&	skip == 0)
	{
        for(ix=0;ix<XSIZE;ix++)
        for(iy=0;iy<YSIZE;iy++)
		{
		fscanf (fileptr,"%d",&i);
		game[ix][iy].cover=i;
		fscanf (fileptr,"%d",&i);
		game[ix][iy].board=i;
		}
	fscanf (fileptr,"%d",&x);
	fscanf (fileptr,"%d",&y);
	fclose(fileptr);
	if (XSIZE>width-3 || YSIZE>length-2)
		{
		printf("This saved game needs a %d x %d terminal to load.\n",
			XSIZE+3,YSIZE+2);
		printf("Since I am not sure if your terminal can handle\n");
		printf("this large size, you will have to set it manually.\n");
		exit(1);
		}
	}
else
	{
	create();
	empty();
	fill();
	calc();
	}
draw();

locate (x,y);

while ( 1)
	{

	if (	strcmp(keyname,"E2")	 == 0	||
		strcmp(keyname,"P")	 == 0	||
		strcmp(keyname,"p")	 == 0	)
		{
		locate(1,length);
		if (view_flag != 0)
			{
			normal();
			view_flag = 0;
			}
		for (i=0;i<75;i++)
		printf(" ");
		locate (1,length);
		printf("Please enter a filename: (Return to go back) ");
		getstring(savename,30,1);
		locate (1,length);
		printf("Press HELP for keypad diagram or FIND for help.  ");
		printf("Number of mines left: %4d",mine_total-flag_counter);

		skip=0;	if (strlen(savename)==0) skip=1;
		if (skip == 0) fileptr = fopen (savename,"w");
		if (fileptr != NULL	&&	skip == 0)
			{
			fprintf (fileptr,"%d\n",real_flag_counter);
			fprintf (fileptr,"%d\n",flag_counter);
			fprintf (fileptr,"%d\n",counter);
			fprintf (fileptr,"%d\n",XSIZE);
			fprintf (fileptr,"%d\n",YSIZE);
			fprintf (fileptr,"%d\n",hint);
			fprintf (fileptr,"%d\n",HINTS);
			fprintf (fileptr,"%d\n",mine_total);
 		        for(ix=0;ix<XSIZE;ix++)
				{
        		for(iy=0;iy<YSIZE;iy++)
				{
				fprintf (fileptr,"%d ",game[ix][iy].cover);
				fprintf (fileptr,"%d ",game[ix][iy].board);
				}
				fprintf (fileptr,"\n");
				}
			fprintf (fileptr,"%d\n",x);
			fprintf (fileptr,"%d\n",y);
			fclose (fileptr);
			}
		}

	if (	strcmp(keyname,"HELP")	 == 0	)
		{
		keypad();
		draw();
		}

	if (	strcmp(keyname,"?")	 == 0	||
		strcmp(keyname,"E1")	 == 0	)
		{
		help(1);
		draw();
		}

	if (	strcmp(keyname,"/")	 == 0	||
		strcmp(keyname,"E3")	 == 0	)
		{
		high(2);
		printf("\n");
		sleep(5);
		draw();
		}

	if (	strcmp(keyname,"q")      == 0	||
		strcmp(keyname,"Q")      == 0	||
		strcmp(keyname,"DO")     == 0)
			{
			quit_flag = 1;
			show(-1,-1);
			}

	if (	strcmp(keyname,"s")      == 0	||
		strcmp(keyname,"S")      == 0	||
	    	strcmp(keyname,"E4")     == 0)
		if (game[x][y].board     != 9)
			expose(x,y);
		else	if (game[x][y].cover	!= 'F')
			show(x,y);

	if (   (strcmp(keyname,"h")      == 0	||
		strcmp(keyname,"H")      == 0	||
	    	strcmp(keyname,"CTRLM")   == 0)	&&
		hint<HINTS)
		if (game[x][y].board     != 9)
			{
			expose(x,y);
			hint++;
			}
		else	if (game[x][y].cover	!= 'F')
			{
			flag(x,y);
			hint++;
			}

	if (	strcmp(keyname,"d")      == 0	||
		strcmp(keyname,"D")	 == 0	||
	    	strcmp(keyname,"E5")     == 0)
		{
		if (game[x][y].cover     != ' ')
			{
	                if (x==0 && y==0)
			count=
			  (game[x+1][y].cover == 'F')+
			  (game[x][y+1].cover == 'F')+
			  (game[x+1][y+1].cover == 'F');
	                if (x>0 && x<XSIZE-1 && y==0)
			count=
			  (game[x-1][y].cover == 'F')+
			  (game[x+1][y].cover == 'F')+
			  (game[x-1][y+1].cover == 'F')+
			  (game[x][y+1].cover == 'F')+
			  (game[x+1][y+1].cover == 'F');
	                if (x==XSIZE-1 && y==0)
			count=
			  (game[x-1][y].cover == 'F')+
			  (game[x-1][y+1].cover == 'F')+
			  (game[x][y+1].cover == 'F');
	                if (x==0 && y>0 && y<YSIZE-1)
			count=
			  (game[x][y-1].cover == 'F')+
			  (game[x+1][y-1].cover == 'F')+
			  (game[x+1][y].cover == 'F')+
			  (game[x][y+1].cover == 'F')+
			  (game[x+1][y+1].cover == 'F');
			if (x>0 && x<XSIZE-1 && y>0 && y<YSIZE-1)
			count=
			  (game[x-1][y-1].cover == 'F')+
			  (game[x][y-1].cover == 'F')+
			  (game[x+1][y-1].cover == 'F')+
			  (game[x-1][y].cover == 'F')+
			  (game[x+1][y].cover == 'F')+
			  (game[x-1][y+1].cover == 'F')+
			  (game[x][y+1].cover == 'F')+
			  (game[x+1][y+1].cover == 'F');
			if (x==XSIZE-1 && y>0 && y<YSIZE-1)
			count=
			  (game[x-1][y-1].cover == 'F')+
			  (game[x][y-1].cover == 'F')+
			  (game[x-1][y].cover == 'F')+
			  (game[x-1][y+1].cover == 'F')+
			  (game[x][y+1].cover == 'F');
			if (x==0 && y==YSIZE-1)
			count=
			  (game[x][y-1].cover == 'F')+
			  (game[x+1][y-1].cover == 'F')+
			  (game[x+1][y].cover == 'F');
			if (x>0 && x<XSIZE-1 && y==YSIZE-1)
			count=
			  (game[x-1][y-1].cover == 'F')+
			  (game[x][y-1].cover == 'F')+
			  (game[x+1][y-1].cover == 'F')+
			  (game[x-1][y].cover == 'F')+
			  (game[x+1][y].cover == 'F');
			if (x==XSIZE-1 && y==YSIZE-1)
			count=
			  (game[x-1][y-1].cover == 'F')+
			  (game[x][y-1].cover == 'F')+
			  (game[x-1][y].cover == 'F');
			if (game[x][y].board == count)
				{
				if (x>0 && y>0)
					if (game[x-1][y-1].cover == ' ')
						if (game[x-1][y-1].board != 9)
							expose(x-1,y-1);
						else
							show(x,y);
				if (y>0)
					if (game[x][y-1].cover   == ' ')
						if (game[x][y-1].board	 != 9)
							expose(x,y-1);
						else
		 					show(x,y);
				if (x<XSIZE-1 && y>0)
					if (game[x+1][y-1].cover == ' ')
						if (game[x+1][y-1].board != 9)
							expose(x+1,y-1);
						else
							show(x,y);
				if (x>0)
					if (game[x-1][y].cover   == ' ')
						if (game[x-1][y].board   != 9)
							expose(x-1,y);
						else
							show(x,y);
				if (x<XSIZE-1)
					if (game[x+1][y].cover   == ' ')
						if (game[x+1][y].board   != 9)
							expose(x+1,y);
						else
							show(x,y);
				if (x>0 && y<YSIZE-1)
					if (game[x-1][y+1].cover == ' ')
						if (game[x-1][y+1].board != 9)
							expose(x-1,y+1);
						else
							show(x,y);
				if (y<YSIZE-1)
					if (game[x][y+1].cover   == ' ')
						if (game[x][y+1].board   != 9)
							expose(x,y+1);
						else
							show(x,y);
				if (x<XSIZE-1 && y<YSIZE-1)
					if (game[x+1][y+1].cover == ' ')
						if (game[x+1][y+1].board != 9)
							expose(x+1,y+1);
						else
							show(x,y);
				}
			}
		}
	
	if (	strcmp(keyname,"f")     == 0	||
		strcmp(keyname,"F")     == 0	||
		strcmp(keyname,"E6")    == 0)
		if (game[x][y].cover    == 'F')
			unflag(x,y);
		else
			flag(x,y);

	if (	(strcmp(keyname,"i")     == 0	||
		 strcmp(keyname,"I")     == 0	||
		 strcmp(keyname,"UP")    == 0)	&& y > 0)	y = y - 1;

	if (	(strcmp(keyname,"j")     == 0	||
		 strcmp(keyname,"J")     == 0	||
		 strcmp(keyname,"LEFT")  == 0)	&& x > 0)	x = x - 1;

	if (	(strcmp(keyname,"k")     == 0	||
		 strcmp(keyname,"K")     == 0	||
		 strcmp(keyname,"DOWN")  == 0)	&& y < YSIZE-1)	y = y + 1;

	if (	(strcmp(keyname,"l")     == 0	||
		 strcmp(keyname,"L")     == 0	||
		 strcmp(keyname,"RIGHT") == 0)	&& x < XSIZE-1)	x = x + 1;

	if (	 strcmp(keyname,"CTRLW") == 0)
		{
		draw();
		}

	if (counter == XSIZE*YSIZE - mine_total)
		{
		autoflag();
		}

	if (real_flag_counter == mine_total)
		{
		autoclear();
		}

	if (counter + real_flag_counter == XSIZE*YSIZE)
		{
		high(1);
		}

/*The following is needed for the DEC system service that gets a key.  Will
  have to be modified to work on non-VAX equipment*/

/*===================================*/
	locate (x,y);
	SMG$READ_KEYSTROKE(&keyid,&key);
	SMG$KEYCODE_TO_NAME(&key,&name);
	keyname[strlen(keyname)-strlen(strchr(keyname,' '))] = '\0';
	if (strcmp(keyname,"")==0) strcpy(keyname," ");
/*===================================*/

	}
}

