Path: uunet!mcsun!news.funet.fi!hydra!klaava!hurtta
From: Kari.Hurtta@Helsinki.FI (Kari. E. Hurtta)
Newsgroups: vmsnet.sources.games
Subject: BSD Empire Client for VMS, part 5/8
Message-ID: <1992Apr12.182130.15441@klaava.Helsinki.FI>
Date: 12 Apr 92 18:21:30 GMT
Sender: hurtta@klaava.Helsinki.FI (Kari Hurtta)
Followup-To: vmsnet.sources.d
Organization: University of Helsinki
Lines: 1747

Archive-name: empireclient_110/part5
Author: Kari.Hurtta@Helsinki.FI (Kari E. Hurtta)
Product: Empire Client for VMS
Version: 1.10

-+-+-+-+-+-+-+-+ START OF PART 5 -+-+-+-+-+-+-+-+
X`009F_OWNED,    /* is dumped: not work with deity */
X`009F_NULL
X`009`125 dump_fields;
X
X#define LAST_DUMP_FIELD F_OWNED
X#define DEF_SECTORS 301
X#define MAX_SECTORS (128*128/2+1)
X#define INC_SECTORS (64*64/2)
X#define MAX_ROWS 500
X
Xstatic const struct FIELDS `123
X    char *text;
X    dump_fields id;
X    `125 fields`091`093 = `123
X`009`123 "x", F_x `125, `123 "y", F_y `125, `123 "des", F_des `125, `123 "sd
Ves", F_sdes `125,
X`009`123 "eff" ,F_eff `125, `123 "mob", F_mob `125,  `123 "*", F_occupied `1
V25,
X`009`123 "min", F_min `125, `123 "gold", F_gold `125, `123 "fert", F_fert `1
V25,
X`009`123 "ocontent", F_ocontent `125, `123 "uran", F_uran `125, `123 "work",
V F_work `125,
X`009`123 "avail", F_avail `125, `123 "terr", F_terr `125,  `123 "civ", F_civ
V `125,
X`009`123 "mil", F_mil `125, `123 "uw", F_uw `125, `123 "food", F_food `125,
X`009`123 "shell", F_shell `125, `123 "gun", F_gun `125, `123 "pet", F_pet `1
V25,
X`009`123 "iron", F_iron `125, `123 "dust", F_dust `125, `123 "bar", F_bar `1
V25,
X`009`123 "oil", F_oil `125, `123 "lcm",  F_lcm `125, `123 "hcm", F_hcm `125,
X`009`123 "rad", F_rad `125,`032
X`009`123 "u_del", F_u_del `125, `123 "f_del", F_f_del `125,`032
X`009`123 "s_del", F_s_del `125, `123 "g_del", F_g_del `125,
X`009`123 "p_del", F_p_del `125, `123 "i_del", F_i_del `125,
X`009`123 "d_del", F_d_del `125, `123 "b_del", F_b_del `125,
X`009`123 "o_del", F_o_del `125, `123 "l_del", F_l_del `125,
X`009`123 "h_del", F_h_del `125, `123 "r_del", F_r_del `125,
X`009`123 "u_cut", F_u_cut `125, `123 "f_cut", F_f_cut `125,
X`009`123 "s_cut", F_s_cut `125, `123 "g_cut", F_g_cut `125,
X`009`123 "p_cut", F_p_cut `125, `123 "i_cut", F_i_cut `125,
X`009`123 "d_cut", F_d_cut `125, `123 "b_cut", F_b_cut `125,
X`009`123 "o_cut", F_o_cut `125, `123 "l_cut", F_l_cut `125,
X`009`123 "h_cut", F_h_cut `125, `123 "r_cut", F_r_cut `125,
X`009`123 "dist_path", F_dist_path `125,`032
X`009`123 "dist_x", F_dist_x `125, `123 "dist_y", F_dist_y `125,
X`009`123 "u_dist", F_u_dist `125, `123 "f_dist", F_f_dist `125,
X`009`123 "s_dist", F_s_dist `125, `123 "g_dist", F_g_dist `125,
X`009`123 "p_dist", F_p_dist `125, `123 "i_dist", F_i_dist `125,
X`009`123 "d_dist", F_d_dist `125, `123 "b_dist", F_b_dist `125,
X`009`123 "o_dist", F_o_dist `125, `123 "l_dist", F_l_dist `125,
X`009`123 "h_dist", F_h_dist `125, `123 "r_dist", F_r_dist `125,
X`009`123 "own", F_own `125,   `123 "OWNED", F_OWNED `125,
X`009`123 "type", F_des `125,  `123 "shl", F_shell `125,
X`009`125;
X
Xtypedef enum `123 DF_num, DF_bool, DF_string, DF_char `125 d_field_type;
X
Xstatic const d_field_type field_types`091LAST_DUMP_FIELD+1`093 =
X    `123
X/* F_x */`009DF_num,
X/* F_y */`009DF_num,`032
X/* F_des */`009DF_char,
X/* F_sdes */`009DF_char,
X/* F_eff */`009DF_num,
X/* F_mob */`009DF_num,
X/* F_occupied */    DF_bool,
X/* F_min */`009DF_num,
X/* F_gold */`009DF_num,
X/* F_fert */`009DF_num,
X/* F_ocontent */ DF_num,
X/* F_uran */`009DF_num,`032
X/* F_work */`009DF_num,
X/* F_avail */`009DF_num,
X/* F_terr */`009DF_num,
X/* F_civ */`009DF_num,
X/* F_mil */`009DF_num,
X/* F_uw */`009DF_num,
X/* F_food */`009DF_num,`032
X/* F_shell */`009DF_num,
X/* F_gun */`009DF_num,
X/* F_pet */`009DF_num,
X/* F_iron */`009DF_num,
X/* F_dust */`009DF_num,
X/* F_bar */`009DF_num,
X/* F_oil */`009DF_num,
X/* F_lcm */`009DF_num,
X/* F_hcm */`009DF_num,
X/* F_rad */`009DF_num,
X/* F_u_del */`009DF_char,
X/* F_f_del */`009DF_char,
X/* F_s_del */`009DF_char,
X/* F_g_del */`009DF_char,
X/* F_p_del */`009DF_char,
X/* F_i_del */`009DF_char,
X/* F_d_del */`009DF_char,
X/* F_b_del */`009DF_char,
X/* F_o_del */`009DF_char,
X/* F_l_del */`009DF_char,
X/* F_h_del */`009DF_char,
X/* F_r_del */`009DF_char,
X/* F_u_cut */`009DF_num,
X/* F_f_cut */`009DF_num,
X/* F_s_cut */`009DF_num,
X/* F_g_cut */`009DF_num,
X/* F_p_cut */`009DF_num,
X/* F_i_cut */`009DF_num,
X/* F_d_cut */`009DF_num,
X/* F_b_cut */`009DF_num,
X/* F_o_cut */`009DF_num,
X/* F_l_cut */`009DF_num,
X/* F_h_cut */`009DF_num,
X/* F_r_cut */`009DF_num,`032
X/* F_dist_path */ DF_string,
X/* F_dist_x */`009DF_num,
X/* F_dist_y */`009DF_num,
X/* F_u_dist */`009DF_num,
X/* F_f_dist */`009DF_num,
X/* F_s_dist */`009DF_num,
X/* F_g_dist */`009DF_num,
X/* F_p_dist */`009DF_num,
X/* F_i_dist */`009DF_num,
X/* F_d_dist */`009DF_num,
X/* F_b_dist */`009DF_num,
X/* F_o_dist */  DF_num,
X/* F_l_dist */`009DF_num,
X/* F_h_dist */`009DF_num,
X/* F_r_dist */`009DF_num,
X/* F_own    */`009DF_num,
X/* F_OWNED */`009DF_bool `125;
X
X#define MAX_FIELD 10
X
Xtypedef union `123
X    int`009U_num;
X    int U_bool;
X    char *U_string;
X    char U_char;
X`125   U_fields;
X
Xtypedef U_fields sector_data`091LAST_DUMP_FIELD+1`093;
X
Xtypedef struct `123
X    int linecount;
X    char date`09125`093;
X    dump_fields parse_index`091MAX_ROWS`093;
X    int count;
X    int alloced;
X    sector_data *sectors;
X`125 sectors;
X
Xstatic const int    UNKNOWN_num = -999999999;
Xstatic const char * UNKNOWN_string = NULL;     `032
Xstatic const char   UNKNOWN_bool = -1;
Xstatic const char   UNKNOWN_char = '?';`009/* Well - this is unknown designa
Vtion */
X#define _JOKER_ '?'
X
Xstatic const struct COMMODITY `123
X    char C;
X    char *name;
X    dump_fields content;    /* field of commodity */
X    dump_fields thre;`009    /* field of thresold value */
X    char des;`009`009    /* designation of producer sector */
X    dump_fields ore;`009    /* field of ore for commodity */
X    float mob_mul;
X    `125 commodities `091`093 = `123
X       `009`123 'c',`009"civilian", F_civ,  F_NULL,`009
X`009    _JOKER_,   F_NULL, 1.0/5 `125,`009/* THIS MUST BE */
X`009`009`009`009`009`009/* FIRST FIELD  */
X`009`123 'm',`009"military", F_mil,  F_NULL,`009
X`009    _JOKER_,   F_NULL, 1.0/5 `125,
X`009`123 's',`009"shells",   F_shell,F_s_dist, 'i',   F_NULL,`0092.0/5 `125,
X`009`123 'g',`009"guns",`009    F_gun,  F_g_dist, 'd',   F_NULL,`0092.0/1 `1
V25,
X`009`123 'p',`009"petrol",   F_pet,  F_p_dist,`032
X`009    '%',   F_NULL,`0091.0/5`009/* ???? */ `125,
X`009`123 'i',`009"iron",`009    F_iron, F_i_dist, 'm',  F_min,`0091.0/5 `125
V,
X`009`123 'o',`009"oil",`009    F_oil,  F_o_dist, 'o',  F_ocontent, 1.0/5 `12
V5,
X`009`123 'b',`009"bars of gold",`009F_bar,F_b_dist,`009
X`009    _JOKER_,   F_NULL,`00910.0/1 `125,
X        `123 'b',`009"gold",`009    F_bar,  F_b_dist,`009
X`009    _JOKER_,   F_NULL,`00910.0/1 `125, /* DUPLICATE ENTRY !!! */
X`009`123 'd',`009"dust of cold",`009F_dust, F_d_dist,`032
X`009    'g',`009F_gold,`00910.0/1 /* ??? */ `125,
X       `009`123 'f',`009"food",`009    F_food, F_f_dist, 'a',   F_fert,`0091
V.0/5 `125,
X        `123 'r',`009"radiactive materials",`009F_rad,`009F_r_dist,`032
X`009    'u',`009    F_uran,   1.0/5 `125,
X`009`123 'u',`009"uncompensate workers",`009F_uw,`009F_u_dist,`032
X`009    _JOKER_,   F_NULL,   2.0/5 `125,
X`009`123 'u',`009"uws",`009    F_uw,   F_u_dist,`009
X`009    _JOKER_,   F_NULL,`0092.0/5 `125,  /* DUPLICATE ENTRY */
X`009`123 'l',  "light construction materials", F_lcm, F_l_dist,`032
X`009    'j',    F_NULL, 1.0/5 `125,
X`009`123 'l',`009"lcms",`009    F_lcm,  F_l_dist,`009
X`009    'j',    F_NULL,`0091.0/5 `125,  /* DUPLICATE ENTRY */
X`009`123 'h',`009"heavy construction materials", F_hcm,`032
X`009    'h',    F_h_dist, 1.0/5 `125,
X`009`123 'h',  "hcms",`009    F_hcm,  F_h_dist,`009
X`009    'h',    F_NULL, 1.0/5 `125   /* DUPLICATE ENTRY */
X    `125;
X
X#define MAX_VARS 10
X
Xtypedef struct var_type `123
X    struct varXY `123
X`009int X,Y;
X    `125 secs`091MAX_SECTORS`093;
X    int len;
X`125   var_type;
X
Xtypedef enum computed_vars `123 V_DC = MAX_VARS, V_BEACH, V_BORDER, V_LOSED,
X`009V_LAND, V_COUNTRY, V_COAST,
X
X`009/* check style variables */
X`009V_NOFOOD, V_BADDES,
X`009MAX_C_VARS `125 computed_vars;
X
Xtypedef void c_var_function(sectors *database);
X
Xstatic void V_dc(sectors *database);
Xstatic void V_beach(sectors *database);
Xstatic void V_coast(sectors *database);
Xstatic void V_border(sectors *database);
Xstatic void V_losed(sectors *database);
Xstatic void V_land(sectors *database);
Xstatic void V_country(sectors *database);
X
Xstatic void V_nofood(sectors *database);
Xstatic void V_baddes(sectors *database);
X
Xstatic struct c_var_name `123
X    char *name;
X    computed_vars id;
X    c_var_function *creator;
X    `125 c_vars`091`093 =`032
X`009`123 `123 "DC",`009`009    V_DC, V_dc `125,    /* distribution centers *
V/
X`009  `123 "distribution centers", V_DC, V_dc `125,   /* DUBLICATE ENTRY */`
V032
X`009  `123 "BEACH",                V_BEACH, V_beach `125,   /* sea beach */
X`009  `123 "sea beach",            V_BEACH, V_beach `125, /* DUBLICATE ENTRY
V */
X`009  `123 "COAST",                V_COAST, V_coast `125,   /* coast line */
X`009  `123 "coast line",           V_COAST, V_coast `125, /* DUBLICATE ENTRY
V */
X`009  `123 "BORDER",`009`009    V_BORDER, V_border `125, /* borderline */
X`009  `123 "borderline",`009    V_BORDER, V_border `125, /* DUBLICATE ENTRY
V */
X`009  `123 "LOSED",`009`009    V_LOSED, V_losed `125, /* losed sectors */
X`009  `123 "losed sectors",`009    V_LOSED, V_losed `125, /* DUBLICATE ENTRY
V */
X`009  `123 "LAND",`009`009    V_LAND, V_land `125, /* land sectors */
X`009  `123 "land sectors",`009    V_LAND, V_land `125, /* DUBLICATE ENTRY */
X`009  `123 "COUNTRY",`009`009    V_COUNTRY, V_country `125, /* player's coun
Vtry */
X`009  `123 "your country",`009    V_COUNTRY, V_country `125, /* DUBLICATE EN
VTRY */
X
X`009  /* dublicate of *check commands */
X`009  `123 "NOFOOD",`009`009    V_NOFOOD, V_nofood `125, /* foodcheck */
X`009  `123 "BADDES",`009`009    V_BADDES, V_baddes `125, /* desigcheck */
X
X
X`009`125; `032
X   `032
Xstatic var_type vars`091MAX_C_VARS`093 = `123 `123 `123 0, 0 `125, 0 `125 `1
V25;
X
X
Xstatic int stepper(char **ptr,char *buffer,
X    size_t size) /* get one field from line */
X`123
X    char *prev = buffer;
X    while (*(*ptr) == ' ') (*ptr)++;
X    while (*(*ptr) != ' ' && *(*ptr) != '\0' &&
X`009buffer < prev + size -1) *buffer++ = *(*ptr)++;
X    *buffer = '\0';
X
X    return prev != buffer;
X`125
X
Xstatic dump_fields Ref(char *buffer);
Xstatic void sort_database(sectors *database);
Xstatic void change_str_field(sector_data *secs,int pos,dump_fields F,char *p
Vtr);
Xstatic int resize_database(sectors *database, int new_size);
Xstatic void check_visual(void);;
X
Xstatic int realloc_database(sectors *database)
X`123
X    if (database -> count == database -> alloced) `123
X`009if (database -> count == MAX_SECTORS) `123
X`009    write_line("Too many sectors",E_tool,NULL);
X`009    return 0;
X`009`125 else `123
X`009    int newsize = database -> alloced + INC_SECTORS;
X`009    if (newsize > MAX_SECTORS) newsize = MAX_SECTORS;
X`009    if(!resize_database(database,newsize)) return 0;
X`009`125
X    `125
X    return 1;
X`125
X
Xstatic int parse_one_line(sectors *database, char *line)
X`123
X    char buffer`091MAX_FIELD+1`093;
X    int lc = ++(database -> linecount);
X    int i,ok,known,unknown;
X    dump_fields match,j;
X    int pos;
X    sector_data *temp;
X
X    switch(lc) `123
X    case 1:`009/* time line */
X`009strcpy(database -> date,line);
X`009return 1;
X    case 2:`009/* DUMP SECTOR */
X`009return (strstr(line,"DUMP SECTOR") != NULL);
X    case 3:`009/* field names */
X`009known = 0;
X`009unknown = 0;
X`009for (i = 0; i < MAX_ROWS; i++)`032
X`009    database -> parse_index`091i`093 = F_NULL;
X
X`009for (i = 0; stepper(&line,buffer,sizeof(buffer)) && i < MAX_ROWS; i++) `
V123
X`009    match = Ref(buffer);;
X`009    if (match == F_NULL) unknown++;
X`009    else known++;
X`009    database -> parse_index`091i`093 = match;
X`009`125
X`009sprintf(buffer,"%d known field%s, %d unknow field%s",
X`009    known, match == 1 ? "" : "s",
X`009    unknown, unknown == 1 ? "" : "s");
X`009write_line(buffer,E_tool,NULL);
X`009return 1;
X    default:`032
X`009if (strstr(line,"sector")) return 1;
X`009/* check that there is space left */
X`009if (!realloc_database(database)) return 0; `032
X`009pos = database -> count++;
X`009temp = database -> sectors;
X
X`009temp`091pos`093`091F_OWNED`093.U_bool = 1; /* not work with DEITY */
X`009ok = 1;
X`009for (i = 0; stepper(&line,buffer,sizeof(buffer)) && i < MAX_ROWS; i++) `
V123
X`009    match = database -> parse_index`091i`093;
X`009    if (match == F_NULL) /* OK */;
X`009    else switch (field_types`091match`093) `123
X`009`009case DF_num:
X`009`009    if (sscanf(buffer,"%d",
X`009`009`009&temp`091pos`093`091match`093.U_num) != 1) ok = 0;
X`009`009    break;
X`009`009case DF_string:
X`009`009    change_str_field(temp,pos,match,buffer);
X`009`009    break;`009`009   `032
X`009`009case DF_bool:
X`009`009    if (strlen(buffer) != 1) ok = 0;
X`009`009    temp`091pos`093`091match`093.U_bool = buffer`0910`093 != '.';
X`009`009    break;
X`009`009case DF_char:
X`009`009    if (strlen(buffer) != 1) ok = 0;
X`009`009    temp`091pos`093`091match`093.U_char = buffer`0910`093;
X`009`009    break;
X`009    `125
X`009`125
X`009return ok;
X    `125
X`125
X
X/* Special messages from server ********************************************
V */
X
Xstatic char *Warning`091`093 =
X    `123 "You lost your capital",
X      "new telegram waiting ...",
X      "new telegrams waiting ...",
X      "Warning: civil unrest",
X      "redesignated your capitol"
X    `125;
X
Xstatic int IsWarning (char *text)`032
X`123
X    int i;
X    for (i = 0; i < sizeof(Warning)/sizeof(char *); i++)
X`009if (strstr(text,Warning`091i`093)) `123
X`009    write_line(text,E_none,NULL);
X`009    return 1;
X`009`125
X    return 0;
X`125
X
Xstatic void message_handler(void)
X`123
X    char *command = prompts`091P_tool`093.command;
X    answer_query(command);
X`125
X
Xstatic void ask_message(char *message)
X`123
X    write_line("Query from server",E_tool,NULL);
X    ask_prompt(P_tool,message,message_handler,1);
X    change_prompt(P_tool);
X`125
X
Xstatic int was_update = 0;
Xstatic int no_btu = 0;
X
Xstatic int fatal_message(char *message)
X`123
X    if (strstr(message,"Update in progress")) `123
X`009write_line(message,E_none,NULL);
X`009was_update = 1;
X`009return 1;
X    `125`032
X    if (strstr(message,"don't have the BTU's")) `123
X`009write_line(message,E_none,NULL);
X`009no_btu = 1;
X`009return 1;
X    `125
X    if (StrEQ(message,"command failed",1) `124`124`032
X`009strstr(message,"Usage:") == message) `123
X`009write_line(message,E_none,NULL);
X`009return 1;
X    `125
X    return 0;
X`125
X
X/* Find shortest path ******************************************************
V */
X
Xstatic sector_data *Locate(sectors *database,int x, int y);
X
Xtypedef float cost_table`091MAX_SECTORS`093;
Xtypedef short int dir_table`091MAX_SECTORS`093;
X
Xstatic struct DIRECTION `123
X    char D;
X    int delta_X;
X    int delta_Y;
X    `125 directions`091`093 = `123
X`009`123 'y', -1, -1 `125,
X`009`123 'u',  1, -1 `125,
X`009`123 'g', -2,  0 `125,
X`009`123 'j',  2,  0 `125,
X`009`123 'b', -1,  1 `125,
X`009`123 'n',`0091,  1 `125 `125;
X
X#define DIR_NUM (sizeof(directions) / sizeof(struct DIRECTION))
X
X#define INFINITE_COST 10E10
X
Xstatic float Cost(sector_data *T)
X`123
X    int eff = 0,mul = 1,base = 1;
X    if (!T) return INFINITE_COST;
X    if ((*T)`091F_eff`093.U_num != UNKNOWN_num) eff = (*T)`091F_eff`093.U_nu
Vm;
X    if ((*T)`091F_des`093.U_char == UNKNOWN_char `124`124`032
X`009((*T)`091F_des`093.U_char != '-' && (*T)`091F_OWNED`093.U_bool != 1) `12
V4`124
X`009(*T)`091F_des`093.U_char == '.') return INFINITE_COST;
X    /* is this right ? */
X    if ((*T)`091F_des`093.U_char == '+') base = 0;
X    if ((*T)`091F_des`093.U_char == '-') mul = 2;
X    if ((*T)`091F_des`093.U_char == '`094') mul = 10;
X    return mul * (base + (100 - eff) / 100.0);
X`125
X
Xstatic int VD_size_x = 0;
Xstatic int VD_size_y = 0;
X
Xstatic void count_new(int X, int Y, int delta_X, int delta_Y,
X`009int *new_X, int *new_Y)
X`123
X    *new_X = X + delta_X;
X    *new_Y = Y + delta_Y;
X
X    if (VD_size_x == 0 `124`124 VD_size_y == 0) return; /* can't calculate *
V/
X
X    if (*new_X < -VD_size_x/2) *new_X += VD_size_x;
X    if (*new_X >= VD_size_x/2) *new_X -= VD_size_x;
X
X    if (*new_Y < -VD_size_y/2) *new_Y += VD_size_y;
X    if (*new_Y >= VD_size_y/2) *new_Y -= VD_size_y;
X`125
X
Xstatic void calculate_cost(sectors *database,
X`009int from_X,int from_Y,
X`009cost_table costtable, dir_table dirtable,
X`009int max_dist)
X`123
X    const int N = database -> count;
X    sector_data *T,*B = database -> sectors;
X    int i,was_touch;
X    dir_table len_table, touch_table;
X
X#define TOUCH(T,dir,cost,len) \
X    if (T && costtable`091T-B`093 > (cost) && (len) < max_dist) `123 \
X`009costtable`091T-B`093 = (cost); \
X`009dirtable`091T-B`093  = (dir); \
X`009touch_table`091T-B`093 = 1; \
X`009len_table`091T-B`093 = (len); \
X    `125
X
X    for (i = 0; i < N; i++) `123
X`009costtable`091i`093 = INFINITE_COST;
X`009dirtable`091i`093 = -1;
X`009len_table`091i`093 = 0;
X`009touch_table`091i`093 = 0;
X    `125
X
X    T = Locate(database,from_X,from_Y);
X    if (!T) `123`032
X`009char buffer`091ERROR_LEN`093;
X`009sprintf(buffer,"Sector %d,%d not found.",from_X,from_Y);
X`009write_line(buffer,E_tool,NULL);
X`009return;
X    `125
X    TOUCH(T,-1,0.0,0);
X
X    do `123 was_touch = 0;
X`009for (i = 0; i < N; i++) if (touch_table`091i`093 &&`032
X`009    /* don't continue from unowned sector */
X`009    B`091i`093`091F_OWNED`093.U_bool == 1) `123
X`009    float cost = costtable`091i`093;
X`009    short len  = len_table`091i`093;
X`009    int X = B`091i`093`091F_x`093.U_num;
X`009    int Y = B`091i`093`091F_y`093.U_num;
X`009    int dir;
X
X`009    touch_table`091i`093 = 0;`009/* reset touch */
X`009    if (X == UNKNOWN_num `124`124 Y == UNKNOWN_num) continue;
X
X`009    was_touch = 1;
X`009    for (dir = 0; dir < DIR_NUM; dir++) `123
X`009`009int new_X, new_Y;
X
X`009`009count_new(X,Y,directions`091dir`093.delta_X,directions`091dir`093.de
Vlta_Y,
X`009`009    &new_X,&new_Y);
X
X`009`009if(from_X == new_X && from_Y == new_Y) continue;
X
X`009`009T = Locate(database,new_X,new_Y);
X`009`009TOUCH(T,dir,cost + Cost(T),len+1);
X`009    `125
X`009`125
X    `125 while (was_touch);
X`125
X
Xstatic void to_head(char *buffer,char C)
X`123
X    char *ptr;
X    for (ptr = buffer + strlen(buffer); ptr >= buffer; ptr--)`032
X`009*(ptr+1) = *ptr;
X    *buffer = C;
X`125
X
Xstatic void give_path(sectors *database,dir_table dir_table,
X    char *buffer,int tpos, int *start_X, int *start_Y)
X`123
X    int X,Y,dir,sX,sY;
X    *buffer = '\0';
X    sX = X = database-> sectors`091tpos`093`091F_x`093.U_num;
X    sY = Y = database-> sectors`091tpos`093`091F_y`093.U_num;
X
X    if ( X == UNKNOWN_num `124`124 Y == UNKNOWN_num) `123
X`009write_line("Internal error(give_path): Unknown cordinate",
X`009    E_tool,NULL);
X`009*start_X = X;
X`009*start_Y = Y;
X`009return;
X    `125
X
X    do `123
X`009dir =  dir_table`091tpos`093;
X`009if (dir != -1) `123
X`009    int new_X,new_Y;
X`009    sector_data *T,*B = database -> sectors;
X
X`009    count_new(X,Y,-directions`091dir`093.delta_X,-directions`091dir`093.
Vdelta_Y,
X`009`009&new_X,&new_Y);
X`009    T = Locate(database,new_X,new_Y);
X`009    if (!T) `123
X`009`009char buffer2`091ERROR_LEN`093;
X`009`009sprintf(buffer2,"Internal error(give_path): Sector not found %d,%d (
Vfrom: %d,%d start: %d,%d path %s)",
X`009`009    new_X,new_Y,X,Y,sX,sY,buffer);
X`009`009write_line(buffer2,E_tool,NULL);
X`009`009break; /* go out from loop */
X`009    `125
X`009    to_head(buffer,directions`091dir`093.D);
X`009    X = new_X;
X`009    Y = new_Y;
X`009    tpos = T- B;
X`009`125
X    `125 while (dir != -1);`032
X    *start_X = X;
X    *start_Y = Y;   `032
X`125
X
X/* DUMP database ***********************************************************
V */
X
Xstatic const sectors NULL_DATABASE = `123 0, "", `123 0 `125, 0, NULL `125;
Xstatic sectors dump_database = `123 0, "", `123 0 `125, 0, NULL `125;
Xstatic sectors old_database = `123 0, "", `123 0 `125, 0, NULL `125;
Xstatic sectors temp_database = `123 0, "", `123 0 `125, 0, NULL `125;
X
Xstatic void call_empiretool_handler(void);
Xstatic int init_database(sectors *database);
Xstatic void reset_database(sectors *database);
Xstatic parse_dump_map(data_type D,char *line);
X
Xstatic char dump_area`091COMMAND_SIZE`093 = "";
X
Xint empiretool_cancel = 0;  /* will be set in module client */
X
Xstatic parse_dump_scan(data_type D,char *line)
X`123
X    static int error = 0;
X    if (dump_database.linecount == 0) `123
X`009dump_database.count = 0;
X    `009error = 0;
X`009if (!dump_database.sectors) `123
X`009    if(!init_database(&dump_database)) `123
X`009`009error = 1;
X`009`009return;
X`009    `125
X`009`125 else reset_database(&dump_database);
X    `125
X    if (D == D_EOD) `123
X`009if (error `124`124 dump_database.linecount == 0 `124`124 empiretool_canc
Vel) `123
X`009    error = 0;
X`009    if (empiretool_cancel) write_line("Canceled.",E_tool,NULL);
X`009    empiretool_cancel = 0;
X`009    change_prompt(P_command);
X`009`125 else `123
X`009    char buffer`091PROMPT_SIZE`093;
X`009    sprintf(buffer,"%d sector%s",
X`009`009dump_database.count, dump_database.count == 1 ? "" : "s");
X`009    write_line(buffer,E_tool,NULL);
X`009    sort_database(&dump_database);
X
X`009    /* map dump yet */
X`009    sprintf(buffer,"map %s",dump_area);
X`009    feed_command(buffer,parse_dump_map);
X`009`125
X`009dump_database.linecount = 0;`009/* is ended */
X`009check_visual();
X    `125 else if (D == D_data && IsWarning(line)) `123
X`009return; /* ok: IsWarning print message */
X    `125 else if (D == D_data && fatal_message(line)) `123
X`009error = 1;  /* COMMAND wailed */
X`009return; /* fatal_message print message */
X    `125 else if (D == D_prompt) `123
X`009ask_message(line);  /* ask from user */
X`009return;`032
X    `125 else if (error) `123
X`009return; /* skip rest */
X    `125 else if (!parse_one_line(&dump_database,line)) `123
X`009write_line("Can't parse",E_tool,line);
X`009error = 1;
X    `125
X`125
X
Xstatic start_with_dump = 1;
X
Xstatic void parse_dump_version(data_type D,char *line);
Xstatic int load_database(char *name, sectors *database, char *buffer,`032
X    int load_vd);
Xstatic int write_database(char *name,sectors *database, char *buffer);
X
X
Xvoid start_empiretool(char *param)
X`123
X    if (*param == '\0' `124`124 !strcmp(param,"?")) `123
X`009write_line("Usage: empiretool <sects>",E_none,NULL);
X`009change_prompt(P_command);
X`009return;
X    `125
X    if (empiretool_cancel) `123
X`009write_line("Canceled.",E_tool,NULL);
X`009empiretool_cancel = 0;
X`009change_prompt(P_command);
X`009return;
X    `125
X
X    disable_prompt(P_tool,1);`009    /* 1 = no error */
X
X    if (empiretool_file`0910`093) `123
X`009char buffer`091COMMAND_SIZE`093;
X`009if (!old_database.sectors) `123
X`009    if(!init_database(&old_database)) `123
X`009`009change_prompt(P_command);
X`009`009return;
X`009`125
X`009`125 else reset_database(&old_database);
X
X`009write_line("Loading empiretool database",E_tool,empiretool_file);
X
X`009if (!load_database(empiretool_file,&old_database,buffer,0)) `123
X`009    write_line("Failing to load old database",E_tool,
X`009`009empiretool_file);
X`009`125
X    `125
X
X    start_with_dump = 1;
X    strcpy(dump_area,param);`009    /* store it */
X    feed_command("version",parse_dump_version);
X`125
X
Xvoid startq_empiretool(void)
X`123
X    start_with_dump = 0;
X
X    if (!dump_database.sectors) `123
X`009if(!init_database(&dump_database)) `123
X`009    change_prompt(P_command);
X`009    return;
X    `125
X    `125 else reset_database(&dump_database);
X    check_visual();
X
X    if (empiretool_cancel) `123
X`009write_line("Canceled.",E_tool,NULL);
X`009empiretool_cancel = 0;
X`009change_prompt(P_command);
X`009return;
X    `125
X
X    disable_prompt(P_tool,1);`009    /* 1 = no error */
X
X    if (empiretool_file`0910`093) `123
X`009char buffer`091COMMAND_SIZE`093;
X`009if (!old_database.sectors) `123
X`009    if(!init_database(&old_database)) `123
X`009`009change_prompt(P_command);
X`009`009return;
X`009`125
X`009`125 else reset_database(&old_database);
X
X`009write_line("Loading empiretool database",E_tool,empiretool_file);
X
X`009if (!load_database(empiretool_file,&old_database,buffer,0)) `123
X`009    write_line("Failing to load old database",E_tool,
X`009`009empiretool_file);
X`009`125
X    `125
X
X    strcpy(dump_area,"");`009
X    feed_command("version",parse_dump_version);
X`125
X
Xvoid startl_empiretool(char *param)
X`123
X    char buffer`091COMMAND_SIZE`093;
X    start_with_dump = 0;
X
X    if (*param == '\0' `124`124 !strcmp(param,"?")) `123
X`009write_line("Usage: load file",E_none,NULL);
X`009change_prompt(P_command);
X`009return;
X    `125
X
X    if (empiretool_cancel) `123
X`009write_line("Canceled.",E_tool,NULL);
X`009empiretool_cancel = 0;
X`009change_prompt(P_command);
X`009return;
X    `125
X
X    if (!dump_database.sectors) `123
X`009if(!init_database(&dump_database)) `123
X`009    change_prompt(P_command);
X`009    return;
X`009`125
X    `125 else reset_database(&dump_database);
X
X    disable_prompt(P_tool,1);`009    /* 1 = no error */
X
X    if (empiretool_file`0910`093) `123
X`009if (!old_database.sectors) `123
X`009    if(!init_database(&old_database)) `123
X`009`009change_prompt(P_command);
X`009`009return;
X`009`125
X`009`125 else reset_database(&old_database);
X    `125
X
X    if (!load_database(param,&dump_database,buffer,1)) `123
X`009change_prompt(P_command);
X`009return;
X    `125
X
X    check_visual();
X    strcpy(dump_area,buffer);`009
X    call_empiretool_handler();
X`125
X
Xvoid finish_empiretool(void)`032
X`123
X
X    visual_quit();  /* visual_quit will change prompt to P_tool */
X    disable_prompt(P_tool,1);`009    /* 1 = no error */
X
X    if (empiretool_file`0910`093 && dump_database.sectors) `123
X`009write_line("Saving empiretool database",E_tool,empiretool_file);
X`009write_database(empiretool_file,&dump_database, dump_area);
X    `125
X
X    change_prompt(P_command);
X`125
X
X/* DUMP DATABASE routines **************************************************
V */
X
X/* INIT ... */
X
Xstatic void InitField(sector_data *secs,int pos,dump_fields F)
X`123
X    switch (field_types`091F`093) `123
X`009case DF_num:
X`009    secs`091pos`093`091F`093.U_num = UNKNOWN_num;
X`009    break;
X`009case DF_string:
X`009    secs`091pos`093`091F`093.U_string = NULL; /* UNKNOWN_string */
X`009    break;`009`009   `032
X`009case DF_bool:
X`009    secs`091pos`093`091F`093.U_bool = UNKNOWN_bool;
X`009    break;
X`009case DF_char:
X`009    secs`091pos`093`091F`093.U_char = UNKNOWN_char;
X`009    break;
X`009`125
X`125
X
Xstatic InitFields(sector_data *secs,int pos)
X`123  `032
X    dump_fields F;
X    for (F = 0; F <= LAST_DUMP_FIELD; F++) InitField(secs,pos,F);
X`125
X
Xstatic int init_database(sectors *database)
X`123
X    int pos;
X    database -> date `0910`093 = '\0';
X    database -> linecount = 0;
X    database -> alloced = 0;
X    database -> count = 0;
X    database -> sectors  =`032
X`009tool_alloc(DEF_SECTORS * sizeof(sector_data));
X
X    if (!database -> sectors) `123
X`009write_line("Can't allocate memory for dump database",E_client,NULL);
X`009return 0;
X    `125 else database -> alloced = DEF_SECTORS;
X
X    for (pos = 0; pos < DEF_SECTORS; pos++) InitFields(database -> sectors,p
Vos);
X    return 1;
X`125
X
X/* RESET ... */
X
Xstatic void ResetField(sector_data *secs,int pos,dump_fields F)
X`123
X    switch (field_types`091F`093) `123
X`009case DF_num:
X`009    secs`091pos`093`091F`093.U_num = UNKNOWN_num;
X`009    break;
X`009case DF_string:
X`009    change_str_field(secs,pos,F,UNKNOWN_string);
X`009    break;`009`009   `032
X`009case DF_bool:
X`009    secs`091pos`093`091F`093.U_bool = UNKNOWN_bool;
X`009    break;
X`009case DF_char:
X`009    secs`091pos`093`091F`093.U_char = UNKNOWN_char;
X`009    break;
X`009`125
X`125
X
Xstatic ResetFields(sector_data *secs,int pos)
X`123  `032
X    dump_fields F;
X    for (F = 0; F <= LAST_DUMP_FIELD; F++) ResetField(secs,pos,F);
X`125
X
Xstatic void reset_database(sectors *database)
X`123
X    int pos;
X    for (pos = 0; pos < database -> alloced; pos++)`032
X`009ResetFields(database -> sectors,pos);
X    database -> count = 0;
X`125
X
X/* DELETE ... */
X
Xstatic void DeleteField(sector_data *secs,int pos,dump_fields F)
X`123
X    switch (field_types`091F`093) `123
X`009case DF_num:
X`009    secs`091pos`093`091F`093.U_num = UNKNOWN_num;
X`009    break;
X`009case DF_string:
X`009    if (secs`091pos`093`091F`093.U_string) string_free(secs`091pos`093`0
V91F`093.U_string);
X`009    secs`091pos`093`091F`093.U_string = NULL;
X`009    break;`009`009   `032
X`009case DF_bool:
X`009    secs`091pos`093`091F`093.U_bool = UNKNOWN_bool;
X`009    break;
X`009case DF_char:
X`009    secs`091pos`093`091F`093.U_char = UNKNOWN_char;
X`009    break;
X`009`125
X`125
X
Xstatic DeleteFields(sector_data *secs,int pos)
X`123  `032
X    dump_fields F;
X    for (F = 0; F <= LAST_DUMP_FIELD; F++) DeleteField(secs,pos,F);
X`125
X
Xstatic void delete_database(sectors *database)
X`123
X    int pos;
X    if (database -> sectors) `123
X`009for (pos = 0; pos < database -> alloced; pos++)`032
X`009    DeleteFields(database -> sectors,pos);
X`009tool_free(database -> sectors,
X`009`009    database -> alloced * sizeof(sector_data));
X    `125
X    database -> sectors = NULL;
X    database -> alloced = 0;
X`125
X
X/* UPDATE ... */
X
Xstatic int UpdateField(sector_data *to_sector,
X`009sector_data *from_sector,dump_fields F)
X`123
X    switch (field_types`091F`093) `123
X`009case DF_num:
X`009    if ((*from_sector)`091F`093.U_num != UNKNOWN_num)
X`009`009(*to_sector)`091F`093.U_num = (*from_sector)`091F`093.U_num;
X`009    break;
X`009case DF_string:
X`009    if ((*from_sector)`091F`093.U_string != UNKNOWN_string)
X`009    change_str_field(to_sector,0,F,(*from_sector)`091F`093.U_string);
X`009    break;`009`009   `032
X`009case DF_bool:
X`009    if ((*from_sector)`091F`093.U_num != UNKNOWN_bool)
X`009`009(*to_sector)`091F`093.U_bool = (*from_sector)`091F`093.U_bool;
X`009    break;
X`009case DF_char:
X`009    if ((*from_sector)`091F`093.U_char != UNKNOWN_char)
X`009`009(*to_sector)`091F`093.U_char = (*from_sector)`091F`093.U_char;
X`009    break;
X`009`125
X`125
X
Xstatic void UpdateFields(sector_data *to_sector, sector_data *from_sector)
X`123
X    dump_fields F;
X    for (F = 0; F <= LAST_DUMP_FIELD; F++)`032
X`009UpdateField(to_sector,from_sector,F);
X`125
X
X/* (requires that database and from_db have in sorted) not just */
Xstatic void update_database(sectors *database,sectors *from_db)
X`123
X    int marks`091MAX_SECTORS`093;
X    int i,pos;
X    int add_count = 0;
X
X    for (i = 0; i < MAX_SECTORS; i++) marks`091i`093 = 0;
X
X    for (pos = 0; pos < from_db -> count; pos++) `123
X`009int X = from_db -> sectors`091pos`093`091F_x`093.U_num;
X`009int Y = from_db -> sectors`091pos`093`091F_y`093.U_num;
X`009sector_data *to_sector;
X
X`009if (X == UNKNOWN_num `124`124 Y == UNKNOWN_num) `123
X`009    char buffer`091ERROR_LEN`093;
X`009    sprintf(buffer,
X`009`009"Internal error (update_database): Unknow cordinate in %d",
X`009`009pos);
X`009    write_line(buffer,E_tool,NULL);
X`009    marks`091pos`093 = 1;  /* mark this so that will not to add target *
V/
X`009    continue;`009/* next entry */
X`009`125
X`009to_sector = Locate(database,X,Y);
X`009if (to_sector) `123
X`009    UpdateFields(to_sector,&(from_db -> sectors`091pos`093));
X`009    marks`091pos`093 = 1;
X`009`125
X    `125
X
X    for (pos = 0; pos < from_db -> count; pos++) `123
X`009int loc;
X`009if (marks`091pos`093) continue;`009/* next */
X
X`009if (!realloc_database(database)) break;`009/* don't add more */
X`009loc = database -> count++;`009/* add to end */
X
X`009UpdateFields(&(database -> sectors`091loc`093),
X`009    &(from_db -> sectors`091pos`093));
X
X`009add_count++;
X    `125
X
X    if (add_count > 0) sort_database(database);
X`125
X
X/* PACK ... (remove duplicated form sorted database) */
X
Xstatic int PackFields(sectors* database,int pos)
X`123  `032
X    sector_data *secs = database -> sectors;
X    int X = secs`091pos`093`091F_x`093.U_num;
X    int Y = secs`091pos`093`091F_y`093.U_num;
X    int i;
X    dump_fields F;
X
X    if (X == UNKNOWN_num `124`124 Y == UNKNOWN_num) `123
X`009char buffer`091ERROR_LEN`093;
X`009sprintf(buffer,"Internal error (PackFields): Unknow cordinate in %d",
X`009`009pos);
X`009write_line(buffer,E_tool,NULL);
X`009return 0;
X    `125
X
X    if (secs`091pos+1`093`091F_x`093.U_num != X `124`124 secs`091pos+1`093`0
V91F_y`093.U_num != Y)
X`009return 0;   /* can't pack */
X
X    /* pack */
X    for (F = 0; F <= LAST_DUMP_FIELD; F++)`032
X        UpdateField(&secs`091pos`093,&secs`091pos+1`093,F);
X
X    /* copy database backward */
X    for (i = pos +1; i < database -> count -1; i++) `123
X`009DeleteFields(secs,i);`009    /* remove previous context */
X
X`009for (F = 0; F <= LAST_DUMP_FIELD; F++)`032
X`009    UpdateField(&secs`091i`093,&secs`091i+1`093,F);
X    `125
X   `032
X    DeleteFields(secs,database -> count -1);`009/* delete last (is copied) *
V/
X    database -> count--;   `032
X
X    return 1;
X`125
X
Xstatic void pack_database(sectors *database)
X`123
X    int pos = 0;
X    while (pos < database -> count -1) `123
X`009if (!PackFields(database,pos)) pos++;
X    `125
X`125
X
X/* */
X
Xstatic int read_VD(FILE *FP);
Xstatic int write_VD(FILE *FP);
X
X/* LOAD ... (load from file) */
X
Xstatic int LoadField(sector_data *to_sector,
X`009char *buffer,dump_fields F)
X`123
X    switch (field_types`091F`093) `123
X`009case DF_num:
X`009    (*to_sector)`091F`093.U_num = atoi(buffer);
X`009    break;
X`009case DF_string:
X`009    change_str_field(to_sector,0,F,buffer);
X`009    break;`009`009   `032
X`009case DF_bool:
X`009    (*to_sector)`091F`093.U_bool = *buffer == '*';
X`009    break;
X`009case DF_char:
X`009    (*to_sector)`091F`093.U_char = *buffer;
X`009    break;
X`009`125
X`125
X
Xstatic int LoadFields(FILE *fp, sector_data *to_sector)`032
X`123
X    int field_count = 0;
X    char field`09130`093,*ptr,*Field;
X    dump_fields F = 0;
X    while(read_word(fp,field,sizeof(field))) `123
X`009if(ptr = strchr(field,':')) `123
X`009    Field = ptr+1;
X`009    *ptr = '\0';
X`009    F = (dump_fields) atoi(field);
X`009`125 else Field = field;
X
X`009LoadField(to_sector,Field,F);
X`009F++;
X`009field_count++;
X    `125
X    return field_count;
X`125
X
Xstatic int load_database(char *name,sectors *database, char *buffer,
X    int load_vd)
X`123
X    static const char MSG`091`093 = "Error reading from file %s";
X    char file_name`091ERROR_LEN`093,buffer2`091ERROR_LEN`093,*tmp;
X    FILE *fp = open_file(name,F_NONE);
X    if (!fp) return 0;
X    sprintf(buffer2,"Loading file %s",fgetname(fp,file_name));
X    write_line(buffer2,E_tool,NULL);
X    flush_message();`009/* and flush that message */
X
X    if (load_vd ? !read_VD(fp) : !fgets(buffer2, sizeof(buffer2),fp)) `123`0
V32
X`009sprintf(buffer2,MSG,file_name);
X`009write_C_error(buffer2);
X`009return 0;
X    `125
X
X    if(!fgets(buffer, COMMAND_SIZE -1,fp)) `123`032
X`009sprintf(buffer2,MSG,file_name);
X`009write_C_error(buffer2);
X`009return 0;
X    `125 else if (tmp = strchr(buffer,'\n')) *tmp = '\0';
X
X    if(!fgets(buffer2, sizeof(buffer2),fp)) `123`032
X`009sprintf(buffer2,MSG,file_name);
X`009write_C_error(buffer2);
X`009return 0;
X    `125 else if (tmp = strchr(buffer2,'\n')) *tmp = '\0';
X    strncpy(database -> date,buffer2,sizeof(database -> date));
X    database -> date`091sizeof(database -> date)-1`093 = '\0';
X    database -> linecount = 0;
X
X    while (!feof(fp) && !ferror(fp)) `123
X`009int loc;
X`009sector_data *to_sector;
X`009/* check that there is space left */
X`009if (!realloc_database(database)) `123
X`009    close_file(&fp);
X`009    return 0;
X`009`125
X
X`009loc = database -> count++;
X`009to_sector = &(database -> sectors`091loc`093);
X`009if (!LoadFields(fp,to_sector)) database -> count--;
X`009skip_cr(fp);
X    `125
X
X    if (ferror(fp)) `123
X`009close_file(&fp);
X`009return 0;
X    `125
X
X    close_file(&fp);
X    return 1;
X`125
X
X/* WRITE database  */
X
Xstatic void WriteField(FILE *fp,sector_data *sector,dump_fields F,
X    dump_fields *Last)
X`123
X    char buffer`091COMMAND_SIZE`093,*ptr;
X    int flag = (*Last + 1 != F),error;
X
X    switch (field_types`091F`093) `123
X`009case DF_num:
X`009    if ((*sector)`091F`093.U_num == UNKNOWN_num) return;
X`009    sprintf(buffer,"%d",(*sector)`091F`093.U_num);
X`009    ptr = buffer;
X`009    break;
X`009case DF_string:
X`009    if ((*sector)`091F`093.U_string == UNKNOWN_string) return;
X`009    ptr = (*sector)`091F`093.U_string;
X`009    break;`009`009   `032
X`009case DF_bool:
X`009    if ((*sector)`091F`093.U_bool == UNKNOWN_bool) return;
X`009    if ((*sector)`091F`093.U_bool) strcpy(buffer,"*");
X`009    else strcpy(buffer,".");
X
X`009    break;
X`009case DF_char:
X`009    if ((*sector)`091F`093.U_char == UNKNOWN_char) return;
X`009    sprintf(buffer,"%c",(*sector)`091F`093.U_char);
X`009    ptr = buffer;
X`009    break;
X`009`125
X    if (strchr(ptr,':')) flag = 1;
X
X    if (flag) error = (fprintf(fp,"%d:",F) < 0) `124`124
X`009!write_word(fp,ptr);`009    /* write_word writes psace to end */
X    else error = !write_word(fp,ptr);
X    if (error) write_C_error("Error writing to sector file");
X
X    *Last = F;
X`125
X
Xstatic void WriteFields(FILE *fp,sector_data *sector)`032
X`123
X    char field`09130`093,*ptr,*Field;
X    dump_fields F = 0,Last = 0;
X
X    for (F = 0; F <= LAST_DUMP_FIELD && !ferror(fp); F++)`032
X`009WriteField(fp, sector,F, &Last);
X    fputc('\n',fp);
X`125
X
Xstatic int write_database(char *name,sectors *database, char *buffer)
X`123
X    static const char MSG`091`093 = "Error writing to file %s";
X    char file_name`091ERROR_LEN`093,buffer2`091ERROR_LEN`093;
X    FILE *fp = open_file(name,F_WRITE);
X    int pos;
X    if (!fp) return 0;
X    sprintf(buffer2,"Writing file %s",fgetname(fp,file_name));
X    write_line(buffer2,E_tool,NULL);
X    flush_message();`009/* and flush this message immediately */
X
X    if (!write_VD(fp)) `123`032
X`009sprintf(buffer2,MSG,file_name);
X`009write_C_error(buffer2);
X`009return 0;
X    `125`032
X
X    if (fprintf(fp,"%s\n",buffer) <= 0) `123`032
X`009sprintf(buffer2,MSG,file_name);
X`009write_C_error(buffer2);
X`009return 0;
X    `125`032
X
X    if (fprintf(fp,"%s\n",database -> date) <= 0) `123`032
X`009sprintf(buffer2,MSG,file_name);
X`009write_C_error(buffer2);
X`009return 0;
X    `125`032
X
X    for (pos = 0; pos < database -> count && !ferror(fp); pos ++)`032
X`009WriteFields(fp,&(database -> sectors`091pos`093));
X
X    if (ferror(fp)) `123
X`009close_file(&fp);
X`009return 0;
X    `125
X
X    close_file(&fp);
X    return 1;
X`125
X
X/* .... */
X
Xstatic int resize_database(sectors *database, int new_size)
X`123
X    sector_data *secs =`032
X`009tool_alloc(new_size * sizeof(sector_data));
X    sector_data *old_pointer = database -> sectors;
X    if (secs) `123
X`009int pos;
X`009memcpy((void *)secs,(void *)old_pointer,
X`009    (database -> alloced)*sizeof(sector_data));
X
X`009for (pos = database -> alloced; pos < new_size; pos++)`032
X`009    InitFields(secs,pos);
X
X`009tool_free((void *)old_pointer,
X`009`009    database -> alloced * sizeof(sector_data));
X`009database -> sectors = secs;
X`009database -> alloced = new_size;
X`009return 1;
X    `125
X    write_line("Can't allocate memory for database",E_tool,NULL);
X    return 0;
X`125
X
Xstatic char *FieldName(dump_fields field);
X
Xstatic void change_str_field(sector_data *secs,int pos,dump_fields F,char *p
Vtr)
X`123
X    if(field_types`091F`093 != DF_string) `123
X`009char buffer`091ERROR_LEN`093;
X`009char buffer2`091ERROR_LEN`093;
X`009sprintf(buffer,"Internal error(change_str_field): Field %s (%d) in %d is
Vn't string_type",
X`009    FieldName(F),F,pos);
X`009if (ptr) sprintf(buffer2,"String to assign: \"%s\"",ptr);
X`009else sprintf(buffer2,"No string to assign");
X`009write_line(buffer,E_tool,buffer2);
X`009return;
X    `125
X    if (secs`091pos`093`091F`093.U_string) string_free(secs`091pos`093`091F`
V093.U_string);
X
X    if (ptr) `123
X`009secs`091pos`093`091F`093.U_string = string_alloc(ptr);
X
X`009if (!secs`091pos`093`091F`093.U_string) `123
X`009    char buffer`091ERROR_LEN`093;
X`009    char buffer2`091ERROR_LEN`093;
X`009    sprintf(buffer,"Can't allocate memory for field %s (%d) in %d for st
Vring",
X`009`009FieldName(F),F,pos);
X`009    sprintf(buffer2,"String to assign: \"%s\"",ptr);
X`009    write_line(buffer,E_tool,buffer2);
X`009    return;
X`009`125
X    `125 else secs`091pos`093`091F`093.U_string = NULL;
X`125
X
X
Xstatic char * refer_str_field(sector_data *Sector,dump_fields F)
X`123
X    static const char *RESERVED_EMPTY = "";
X    if(field_types`091F`093 != DF_string) `123
X`009char buffer`091ERROR_LEN`093;
X`009sprintf(buffer,"Internal error(refer_str_field): Field %s (%d) isn't str
Ving_type",
X`009    FieldName(F),F);
X`009write_line(buffer,E_tool,NULL);
X`009return RESERVED_EMPTY;
X    `125
X    if ((*Sector)`091F`093.U_string) return (*Sector)`091F`093.U_string;
X    else return RESERVED_EMPTY;
X`125
X
Xstatic dump_fields Ref(char *buffer)
X`123  `032
X    int j;
X    dump_fields match = F_NULL;
X    for (j = 0; j < sizeof(fields) / sizeof(struct FIELDS); j++)`032
X`009if (!strcmp(fields`091j`093.text,buffer)) match = fields`091j`093.id;
X    return match;
X`125
X
Xstatic dump_fields MatchRef(char *buffer)
X`123  `032
X    int j;
X    dump_fields match = F_NULL,refer = F_NULL;
X    int count = 0;
X    for (j = 0; j < sizeof(fields) / sizeof(struct FIELDS); j++) `123
X`009if (!strcmp(fields`091j`093.text,buffer)) match = fields`091j`093.id;
X`009if (strstr(fields`091j`093.text,buffer) == fields`091j`093.text) `123
X`009    refer = fields`091j`093.id;
X`009    count++;
X`009`125
X    `125
X    if (match != F_NULL) return match;
X    if (count > 1) `123
X`009write_line("Ambiguous field",E_tool,buffer);
X`009return F_NULL;
X    `125
X    if (count == 0) `123
X`009write_line("Unknown field",E_tool,buffer);
X`009return F_NULL;
X    `125
X    return refer;
X`125
X
Xstatic dump_fields MatchCom(char *buffer, int *result)
X`123  `032
X    int j;
X    int match = -1, refer = -1;
X    int count = 0;
X
X    if (strlen(buffer) != 1) `123
X`009for (j = 0; j < sizeof(commodities) / sizeof(struct COMMODITY); j++) `12
V3
X`009    if (!strcmp(commodities`091j`093.name,buffer)) match = j;
X`009    if (strstr(commodities`091j`093.name,buffer) == commodities`091j`093
V.name) `123
X`009`009refer = j;
X`009`009count++;
X`009    `125
X`009`125`032
X    `125 else `123`009/* look commodity letter */
X`009for (j = 0; j < sizeof(commodities) / sizeof(struct COMMODITY); j++) `12
V3
X`009    if (commodities`091j`093.C == buffer`0910`093) `123
X`009`009match = j;
X`009`009break;`009/* take first of duplicated entries */
X`009    `125
X`009`125
X    `125
X
X    if (match != -1) `123
X`009*result = match;
X`009return commodities`091match`093.content;
X    `125
X    if (count > 1) `123
X`009write_line("Ambiguous commodity",E_tool,buffer);
X`009*result = -1;
X`009return F_NULL;
X    `125
X    if (count == 0) `123
X`009write_line("Unknown commodity",E_tool,buffer);
X`009return F_NULL;
X    `125
X    *result = refer;
X    return commodities`091refer`093.content;
X`125
X
Xstatic int MatchCVar(char *buffer, int *ind)
X`123  `032
X    int j,m_ind, r_ind;
X    computed_vars match = -1,refer = -1;
X    int count = 0;
X    for (j = 0; j < sizeof(c_vars) / sizeof(struct c_var_name); j++) `123
X`009if (!strcmp(c_vars`091j`093.name,buffer)) `123
X`009    match = c_vars`091j`093.id;
X`009    m_ind = j;
X`009`125
X`009if (strstr(c_vars`091j`093.name,buffer) == c_vars`091j`093.name) `123
X`009    refer = c_vars`091j`093.id;
X`009    r_ind = j;
X`009    count++;
X`009`125
X    `125
X    if (match != -1) `123
X`009*ind = m_ind;
X
X`009return (int) match;
X    `125
X    if (count > 1) `123
X`009write_line("Ambiguous variable",E_tool,buffer);
X`009return -1;
X    `125
X    if (count == 0) `123
X`009write_line("Unknown variable",E_tool,buffer);
X`009return -1;
X    `125
X    *ind = r_ind;
X    return (int) refer;
X`125
X
Xstatic int parse_var(char *buffer, sectors *database)
X`123
X    int var,i;
X    if (buffer`0910`093 == '$' && isdigit(buffer`0911`093)) `123
X`009if(sscanf(buffer,"$%d",&var) != 1 `124`124
X`009`009var < 0 `124`124 var >= MAX_VARS) `123
X`009    write_line("Not such variable",E_tool,buffer);
X`009    return -1;
X`009`125
X`009return var;
X    `125 else if (buffer`0910`093 == '$') `123
X`009if ((var = MatchCVar(&buffer`0911`093,&i)) < 0) return -1;
X`009c_vars`091i`093.creator(database);
X`009return var;
X    `125 else `123
X`009write_line("Not such variable",E_tool,buffer);
X`009return -1;
X    `125
X`125
X
Xstatic int CompVar(struct varXY *var1, struct varXY *var2)
X`123
X    if (var1 -> Y < var2 -> Y) return -1;
X    if (var1 -> Y > var2 -> Y) return 1;
X    if (var1 -> X < var2 -> X) return -1;
X    if (var1 -> X > var2 -> X) return 1;
X    return 0;
X`125
X
Xstatic void sort_var(int var)
X`123
X    if (var <0 `124`124 var >= MAX_C_VARS) return;
X    qsort(vars`091var`093.secs,vars`091var`093.len,
X`009sizeof(struct varXY), CompVar);
X`125
X
Xstatic void clear_var(int var)`032
X`123
X    if (var <0 `124`124 var >= MAX_VARS) return;
X    vars`091var`093.len = 0;
X`125
X
Xstatic int is_in_var(int var, int X, int Y)`032
X`123
X    int i;
X    struct varXY Key;
X    if (var <0 `124`124 var >= MAX_C_VARS) return 0;
X    Key.X = X;
X    Key.Y = Y;
X    if (bsearch(&Key,vars`091var`093.secs,vars`091var`093.len,
X`009sizeof(struct varXY), CompVar)) return 1;
X    return 0;
X`125
X
Xstatic void add_to_var_i(int var, int X, int Y)
X`123
X    int i;
X    if (var <0 `124`124 var >= MAX_C_VARS) return;
X    i = vars`091var`093.len;
X    if ( i >= MAX_SECTORS) `123
X`009write_line("Internal error(add_to_var): Empiretool variable owerflow",
X`009    E_tool,NULL);
X`009return;
X    `125
X    if (is_in_var(var,X,Y)) return;
X    vars`091var`093.secs`091i`093.X = X;
X    vars`091var`093.secs`091i`093.Y = Y;
X    vars`091var`093.len = i+1;
X    if (i > 1 &&`009`009/* let's hope that values comes in order */
X`009CompVar(&vars`091var`093.secs`091i-1`093,
X`009    &vars`091var`093.secs`091i`093) != -1)
X`009    sort_var(var);`009/* ineffiecient */
X    return;
X`125
X
Xstatic void add_to_var(int var, int X, int Y)
X`123
X    if (var <0 `124`124 var >= MAX_VARS) return;
X    add_to_var_i(var,X,Y);
X`125
X
Xstatic void V_land(sectors *database)`009    /* search land */
X`123
X    int i;
X    vars`091V_LAND`093.len = 0;
X
X    for (i = 0; i < database -> count; i++) `123
X`009int X = database -> sectors`091i`093`091F_x`093.U_num;
X`009int Y = database -> sectors`091i`093`091F_y`093.U_num;
X`009char D = database -> sectors`091i`093`091F_des`093.U_char;
X
X`009if (X == UNKNOWN_num `124`124 Y == UNKNOWN_num) continue;
X`009if (D == '.' `124`124 D == '`094') continue;
X
X`009add_to_var_i(V_LAND,X,Y);
X    `125
X`125
X
Xstatic void V_country(sectors *database)`009    /* player's country */
X`123
X    int i;
X    vars`091V_COUNTRY`093.len = 0;
X
X    for (i = 0; i < database -> count; i++) `123
X`009int X = database -> sectors`091i`093`091F_x`093.U_num;
X`009int Y = database -> sectors`091i`093`091F_y`093.U_num;
X`009char D = database -> sectors`091i`093`091F_des`093.U_char;
X`009int O = database -> sectors`091i`093`091F_OWNED`093.U_bool;
X
X`009if (X == UNKNOWN_num `124`124 Y == UNKNOWN_num) continue;
X`009if (D == '.') continue;
X`009if (O == UNKNOWN_bool `124`124 !O) continue;
X
X`009add_to_var_i(V_COUNTRY,X,Y);
X    `125
X`125
X
Xstatic void V_dc(sectors *database)`009/* search distribution centers */
X`123
X    int i;
X    vars`091V_DC`093.len = 0;
X
X    for (i = 0; i < database -> count; i++) `123
X`009int distX = database -> sectors`091i`093`091F_dist_x`093.U_num;
X`009int distY = database -> sectors`091i`093`091F_dist_y`093.U_num;
X`009int X = database -> sectors`091i`093`091F_x`093.U_num;
X`009int Y = database -> sectors`091i`093`091F_y`093.U_num;
X
X`009if (distX != UNKNOWN_num && distY != UNKNOWN_num &&
X`009    (distX != X `124`124 distY != Y)) add_to_var_i(V_DC,distX,distY);
X
X    `125
X
X`125
X
Xstatic void V_beach(sectors *database)`009    /* search sea beach */
X`123
X    int i;
X    vars`091V_BEACH`093.len = 0;
X
X    for (i = 0; i < database -> count; i++) `123
X`009int X = database -> sectors`091i`093`091F_x`093.U_num;
X`009int Y = database -> sectors`091i`093`091F_y`093.U_num;
X`009char D = database -> sectors`091i`093`091F_des`093.U_char;
X`009int yes = 0;
X`009int dir;
X
X`009if (X == UNKNOWN_num `124`124 Y == UNKNOWN_num) continue;
X`009if (D == UNKNOWN_char `124`124 D == '.') continue;
X
X        for (dir = 0; dir < DIR_NUM; dir++) `123
X`009    int new_X, new_Y;
X`009    sector_data *T;
X
X`009    count_new(X,Y,directions`091dir`093.delta_X,directions`091dir`093.de
Vlta_Y,
X`009`009&new_X,&new_Y);
X
X`009    T = Locate(database,new_X,new_Y);
X`009    if (T == NULL) continue;
X
X`009    if ((*T)`091F_des`093.U_char == '.') yes = 1;
X`009`125
X
X`009if (yes) add_to_var_i(V_BEACH,X,Y);
X    `125
X`125
X
Xstatic void V_coast(sectors *database)`009    /* search coast line */
X`123
X    int i;
X    vars`091V_COAST`093.len = 0;
X
X    for (i = 0; i < database -> count; i++) `123
X`009int X = database -> sectors`091i`093`091F_x`093.U_num;
X`009int Y = database -> sectors`091i`093`091F_y`093.U_num;
X`009char D = database -> sectors`091i`093`091F_des`093.U_char;
X`009int yes = 0;
X`009int dir;
X
X`009if (X == UNKNOWN_num `124`124 Y == UNKNOWN_num) continue;
X`009if (D != '.') continue;
X
X        for (dir = 0; dir < DIR_NUM; dir++) `123
X`009    int new_X, new_Y;
X`009    sector_data *T;
X
X`009    count_new(X,Y,directions`091dir`093.delta_X,directions`091dir`093.de
Vlta_Y,
X`009`009&new_X,&new_Y);
X
X`009    T = Locate(database,new_X,new_Y);
X`009    if (T == NULL) continue;
X
X`009    if ((*T)`091F_des`093.U_char != '.') yes = 1;
X`009`125
X
X`009if (yes) add_to_var_i(V_COAST,X,Y);
X    `125
X`125
X
Xstatic void V_border(sectors *database)`009    /* search borderline */
X`123
X    int i;
X    vars`091V_BORDER`093.len = 0;
X
X    for (i = 0; i < database -> count; i++) `123
X`009int X = database -> sectors`091i`093`091F_x`093.U_num;
X`009int Y = database -> sectors`091i`093`091F_y`093.U_num;
X`009int O = database -> sectors`091i`093`091F_OWNED`093.U_bool;
X`009int yes = 0;
X`009int dir;
X
X`009if (X == UNKNOWN_num `124`124 Y == UNKNOWN_num) continue;
X`009if (O == UNKNOWN_bool `124`124 !O) continue;
X
X        for (dir = 0; dir < DIR_NUM; dir++) `123
X`009    int new_X, new_Y;
X`009    sector_data *T;
X
X`009    count_new(X,Y,directions`091dir`093.delta_X,directions`091dir`093.de
Vlta_Y,
X`009`009&new_X,&new_Y);
X
X`009    T = Locate(database,new_X,new_Y);
X`009    if (T == NULL) continue;
X
X`009    if (((*T)`091F_OWNED`093.U_bool == UNKNOWN_bool `124`124
X`009`009 ( (*T)`091F_OWNED`093.U_bool != UNKNOWN_bool &&`032
X`009`009    !(*T)`091F_OWNED`093.U_bool )
X`009`009) &&`032
X`009`009(*T)`091F_des`093.U_char != '.') yes = 1;
X`009`125
X
X`009if (yes) add_to_var_i(V_BORDER,X,Y);
X    `125
X`125
X
Xstatic void V_losed(sectors *database)`009    /* search losed sectors */
X`123
X    int i;
X    vars`091V_LOSED`093.len = 0;
X
X    if (!old_database.sectors) return;
X
X    for (i = 0; i < database -> count; i++) `123
X`009int X = database -> sectors`091i`093`091F_x`093.U_num;
X`009int Y = database -> sectors`091i`093`091F_y`093.U_num;
X`009int O = database -> sectors`091i`093`091F_OWNED`093.U_bool;
X`009int dir;
X`009sector_data *T;
X
X`009if (X == UNKNOWN_num `124`124 Y == UNKNOWN_num) continue;
X`009if (O != UNKNOWN_bool && O) continue;
X
X
X`009T = Locate(&old_database,X,Y);
X`009if (T == NULL) continue;
X
X`009 if ((*T)`091F_OWNED`093.U_bool != UNKNOWN_bool &&`032
X`009     (*T)`091F_OWNED`093.U_bool ) add_to_var_i(V_LOSED,X,Y);
X    `125
X`125
X
Xstatic void V_nofood(sectors *database)`009    /* checkfood */
X`123
X    int i;
X    vars`091V_NOFOOD`093.len = 0;
X
X    for (i = 0; i < database -> count; i++) `123
X`009int X = database -> sectors`091i`093`091F_x`093.U_num;
X`009int Y = database -> sectors`091i`093`091F_y`093.U_num;
X
X`009int yes = 0;
X`009int dir;
X`009int left;
X
X`009if (X == UNKNOWN_num `124`124 Y == UNKNOWN_num) continue;
X
X`009if (check_food(database -> sectors`091i`093,&left) > 0) yes = left < 0;
X
X`009if (yes) add_to_var_i(V_NOFOOD,X,Y);
X    `125
X`125
X
Xstatic void V_baddes(sectors *database)`009    /* desigcheck */
X`123
X    int i;
+-+-+-+-+-+-+-+-  END  OF PART 5 +-+-+-+-+-+-+-+-
