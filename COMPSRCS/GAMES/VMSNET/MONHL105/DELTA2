Newsgroups: vmsnet.sources.games
Path: uunet!stanford.edu!agate!spool.mu.edu!darwin.sura.net!paladin.american.edu!news.univie.ac.at!hp4at!mcsun!fuug!news.funet.fi!hydra!klaava!hurtta
From: Kari.Hurtta@Helsinki.FI
Subject: Delta: Monster Helsinki 1.05 to 1.06 (part 2/5)
Message-ID: <1992Dec6.171340.19023@klaava.Helsinki.FI>
Followup-To: vmsnet.sources.d
Sender: hurtta@klaava.Helsinki.FI (Kari Hurtta)
Organization: University of Helsinki
Date: Sun, 6 Dec 1992 17:13:40 GMT
Lines: 1323
Xref: uunet vmsnet.sources.games:558

Archive-name: monster_helsinki_105_to_106/part2
Author: Kari.Hurtta@Helsinki.FI
Package: Delta from Helsinki Monster 1.05 to Helsinki Monster 1.06
Environment: VMS, Pascal
Part: 2/5

-+-+-+-+-+-+-+-+ START OF PART 2 -+-+-+-+-+-+-+-+
X`09end; `7B pvar `7D
X
X    var i: integer;
X`09tmp: string_t;
X    begin
X`09with pool`5E`5Bcurrent_buffer`5D.table`5Bpos`5D do begin
X`09    case nametype of
X`09`09n_function:
X`09`09    for i := 1 to count_params(params) do
X`09`09`09walk_tree(params`5Bi`5D,current_label,
X`09`09`09`09  visited_labels,defined_vars);
X`09`09n_head: begin
X`09`09    writeln('%Error on walk_tree. Nodetype = n_head');
X`09`09    writeln('%Notify Monster Manager.');
X`09`09    goto OUT;
X`09`09    end;
X`09`09n_header: begin
X`09`09`09if name = LABEL_ID then begin
X`09`09`09    add_list(visited_labels,ns(long_name`5E));
X`09`09`09    current_label := ns(long_name`5E);
X`09`09`09end;
X`09`09`09if name in define_var_headers then begin
X`09`09`09    add_list(defined_vars,ns(long_name`5E));
X`09`09`09end;
X`09`09`09for i := 1 to count_params(params) do
X`09`09`09    walk_tree(params`5Bi`5D,current_label,
X`09`09`09`09  visited_labels,defined_vars);
X`09`09    end;
X`09`09n_const : ;
X`09`09n_error : ;
X`09`09n_comment : ;
X`09`09n_variable : begin
X`09`09    if not in_list(defined_vars,ns(long_name`5E)) then begin
X`09`09`09writeln('Warning: Variable ' + ns(long_name`5E) +`20
X`09`09`09`09' not defined');
X`09`09`09writeln('         in LABEL ' + current_label +
X`09`09`09        ' when called with following');
X`09`09`09writeln('         path: ' + visited_labels + '.');
X`09`09`09writeln;
X`09`09    end;
X`09`09end;
X`09`09n_gosub: begin
X`09`09    if not in_list(visited_labels,
X`09`09`09ns(pool`5E`5Bcurrent_buffer`5D.table`5Bname`5D.long_name`5E)) then
V begin
X`09`09`09    tmp := defined_vars;
X`09`09`09    add_list(tmp,pvar(1));
X`09`09`09    add_list(tmp,pvar(2));
X`09`09`09    add_list(tmp,pvar(3));
X`09`09`09    for i := 4 to count_params(params) do`20
X`09`09`09`09add_list(tmp,pvar(i));
X`09`09`09    walk_tree(name,current_label,visited_labels,tmp);
X`09`09    end;
X`09`09    for i := 1 to count_params(params) do
X`09`09`09walk_tree(params`5Bi`5D,current_label,
X`09`09`09    visited_labels,defined_vars);
X
X`09`09end;
X`09    end; `7B case `7D
X`09end; `7B with `7D
X`09OUT:
X    end; `7B walk_tree `7D
X`09`09`09`09
X    procedure check_variables;
X`09procedure check_one(atom: atom_t);
X`09var loc: integer;
X`09begin
X`09    loc := locate_label(atom);
X`09    if loc > 0 then walk_tree(labels`5Bloc`5D.loc,
X`09`09`09`09      '',
X`09`09`09`09      '',
X`09`09`09`09      external_vars);
X`09end; `7B check_one `7D
X    begin
X`09do_list(external_labels,check_one);
X    end; `7B check_variables `7D
X
X    procedure write_comment; forward;
X-  754,  766
X`09`09if pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.nametype =
X`09`09    pool`5E`5Bcurrent_buffer`5D.table`5Bi`5D.nametype `20
X`09`09then if pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.name =
X`09`09    pool`5E`5Bcurrent_buffer`5D.table`5Bi`5D.name`20
X`09`09then if (pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.long_name`2
V0
X`09`09`09= nil) =
X`09`09    (pool`5E`5Bcurrent_buffer`5D.table`5Bi`5D.long_name = nil)`20
X`09`09then begin
X`09`09   if pool`5E`5Bcurrent_buffer`5D.table`5Bi`5D.long_name = nil then fl
Vag`20
X`09`09`09:= true
X`09`09   else flag :=`20
X`09`09    EQ(pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.long_name`5E,
X`09`09`09pool`5E`5Bcurrent_buffer`5D.table`5Bi`5D.long_name`5E);
X-  770,  771
X`09`09`09if pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.params`5Bj`5D
V <>
X`09`09`09    pool`5E`5Bcurrent_buffer`5D.table`5Bi`5D.params`5Bj`5D then
X-  780,  780
X`09`09    with pool`5E`5Bcurrent_buffer`5D.table `5B atom_count `5D do begin
X-  804,  809
X`09    pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.params`5B1`5D := p1
V;
X`09    pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.params`5B2`5D := p2
V;
X`09    pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.params`5B3`5D := p3
V;
X`09    pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.name := 0;
X            pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.long_name := n
Vil;
X-  813,  831
X`09`09    pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.nametype `20
X`09`09`09:= n_variable;
X`09`09    new(pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.long_name,
X`09`09`09length(name)-1);
X`09`09    as(pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.long_name`5E
X`09`09`09,substr(name,2,length(name)-1));
X`09`09end;
X`09`09'"': begin
X`09`09    pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.nametype `20
X`09`09`09:= n_const;
X`09`09    if length(name) > 2 then begin
X`09`09`09new(pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.long_name,
X`09`09`09    length(name)-2);
X`09`09`09as(pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.long_name`5E,
X`09`09`09    substr(name,2,length(name)-2));
X`09`09    end else pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.long_na
Vme
X`09`09`09:= nil;
X`09`09end;
X`09`09'!':  begin
X`09`09    pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.nametype :=`20
X`09`09`09n_comment;
X`09`09    new(pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.long_name,
X`09`09`09length(name));
X`09`09    as(pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.long_name`5E,
X`09`09`09name);
X-  835,  836
X`09`09    pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.nametype := n_he
Vad;
X`09`09    new(pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.long_name,
X`09`09`09length(name));
X`09`09    as(pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.long_name`5E,
X`09`09`09name);
X-  863,  867
X`09    pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.name     := code;
X`09    pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.nametype := n_heade
Vr;
X`09    pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.params   := params;
X`09    new(pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.long_name,
X`09`09length(atom)));
X`09    as(pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.long_name`5E,ato
Vm);
X-  906,  908
X`09    pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.name := code;
X`09    pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.nametype := n_funct
Vion;
X`09    pool`5E`5Bcurrent_buffer`5D.table`5Batom_count`5D.params := params;
X- 1126, 1126
X`09    with pool`5E`5Bcurrent_buffer`5D do `09`09
X- 1133, 1133
X`09`09`09writeln(result,count:1,':0:0:0:',ns(long_name`5E))
X- 1140, 1143
X`09`09`09if long_name = nil then writeln(result,'"')
X`09`09`09else writeln(result,ns(long_name`5E),'"');
X`09`09    end;
X`09`09    n_variable: begin
X`09`09`09writeln(result,count:1,':0:0:0:_',ns(long_name`5E));
X- 1155, 1155
X`09`09`09writeln(result,':',ns(long_name`5E));
X- 1177, 1177
X- 1205
X`09check_variables;
X- 1213, 1213
X- 1224, 1227
X    for i := 1 to max_mdl_buffer do with pool`5E`5Bi`5D do begin
X`09if used > 0 then begin
X`09    if current_program = program_number then found := i;
X`09    if pool`5E`5Bbiggest`5D.time < time then biggest := i;
X- 1249, 1249
X    with pool`5E`5Bbuffer`5D do begin
X- 1368, 1369
X`09`09`09    if length(atom) > 0 then begin
X`09`09`09`09new(long_name,length(atom));
X`09`09`09`09as(long_name`5E,atom);
X`09`09`09    end else long_name := nil;
X- 1426, 1426
X    begin with pool`5E `5Bbuffer`5D do begin
X- 1430, 1430
X           else atom_name := ns(long_name`5E);
X- 1489, 1489
X`09`09    nice_print('GOSUB '+ns(table`5Bname`5D.long_name`5E));
X- 1511, 1511
X    with pool`5E`5Bbuffer`5D do begin
X- 1520, 1520
X`09    if table`5Bi`5D.long_name <> nil then line_i := ns(table`5Bi`5D.long_
Vname`5E)
X- 1567, 1570
X`09 with pool`5E`5Bbuffer`5D do begin
X`09    for i:= 1 to used do if table`5Bi`5D.nametype = n_header then
X`09`09    if table`5Bi`5D.name = 6 `7B LABEL `7D then
X`09`09`09if ns(table`5Bi`5D.long_name`5E) = label_name then`20
X- 1596, 1596
X      end; `7B eval_variable `7D                           `20
X- 1609, 1609
X      end; `7B set_variable `7D                                    `20
X- 1640
X      function e_boolean_and(params: paramtable): string_t;
X      var result: string;
X`09  bresult: boolean := true;
X`09  i: integer;
X      begin
X`09write_debug('%e_boolean_and');
X`09for i := 1 to count_params(params) do`20
X`09    if clean_spaces(eval_atom (params`5Bi`5D)) = '' then`20
X`09`09bresult := false;
X`09if bresult then result := 'TRUE'
X`09else result := '';
X        write_debug ('%e_boolean_and result: ',result);
X`09e_boolean_and := result;
X      end; `7B e_boolean_and `7D
X
X      function e_boolean_or(params: paramtable): string_t;
X      var result: string;
X`09  bresult: boolean := false;
X`09  i: integer;
X      begin
X`09write_debug('%e_boolean_or');
X`09for i := 1 to count_params(params) do`20
X`09    if clean_spaces(eval_atom (params`5Bi`5D)) > '' then`20
X`09`09bresult := true;
X`09if bresult then result := 'TRUE'
X`09else result := '';
X        write_debug ('%e_boolean_or result: ',result);
X`09e_boolean_or := result;
X      end; `7B e_boolean_or `7D
X
X      function e_or_else(params: paramtable): string_t;
X      var result: string_t := '';
X`09  i,n: integer;
X`09  cont: boolean := true;
X      begin
X        write_debug('%e_or_else');
X`09n := count_params(params);
X`09i := 1;
X`09while cont and (i <= n) do begin
X`09    result := eval_atom (params`5Bi`5D);
X`09    if result > '' then cont := false;
X`09    i := i +1;
X`09end;`20
X`09write_debug('%e_or_else result: ',result);
X`09e_or_else := result;
X      end; `7B e_or_else `7D
X
X      function e_and_then(params: paramtable): string_t;
X      var result: string_t := '';
X`09  i,n: integer;
X`09  cont: boolean := true;
X      begin
X        write_debug('%e_and_then');
X`09n := count_params(params);
X`09i := 1;
X`09while cont and (i <= n) do begin
X`09    result := eval_atom (params`5Bi`5D);
X`09    if result = '' then cont := false;
X`09    i := i +1;
X`09end;`20
X`09write_debug('%e_and_then result: ',result);
X`09e_and_then := result;
X      end; `7B e_and_then `7D
X     `20
X- 1828, 1828
X`09`09    if read_global_flag(value) then action := atom
X- 2017, 2017
X         owner := x_monster_owner(pool`5E`5Bbuffer`5D.current_program);
X- 2038, 2038
X         owner := x_monster_owner(pool`5E`5Bbuffer`5D.current_program);
X- 2063, 2063
X         owner := x_monster_owner(pool`5E`5Bbuffer`5D.current_program);
X- 2084, 2084
X         owner := x_monster_owner(pool`5E`5Bbuffer`5D.current_program);
X- 2103, 2103
X         if int_poof(monster,line_i,x_monster_owner(pool`5E`5Bbuffer`5D.curr
Vent_program),
X- 2119, 2119
X         if int_poof(myname,line_i,x_monster_owner(pool`5E`5Bbuffer`5D.curre
Vnt_program),
X- 2314, 2320
X`09     if a`5Bindex`5D in `5B'0'..'9'`5D then
X                result := result + a`5Bindex`5D
X`09     else if chartable`5Ba`5Bindex`5D`5D.kind = ct_letter then
X`09`09result := result + chartable`5Ba`5Bindex`5D`5D.lcase
X`09     else if chartable`5Ba`5Bindex`5D`5D.kind = ct_none then `7B DISCARD
V `7D
X`09     else result := result + ' ';
X- 2342, 2342
X            else if (x_monster_owner(pool`5E`5Bbuffer`5D.current_program) <>
V`20
X- 2485, 2486
X        owner  := x_monster_owner(pool`5E`5Bbuffer`5D.current_program); `7B
V get owner of this `7D
X        owner2 := x_monster_owner(pool`5E`5Bbuffer`5D.current_program,1); `7
VB and code owner `7D
X- 2502, 2502
X         getheader(pool`5E`5Bbuffer`5D.current_program);
X- 2515, 2515
X         getheader(pool`5E`5Bbuffer`5D.current_program);
X- 2537, 2537
X`09`09x_monster_owner(pool`5E`5Bbuffer`5D.current_program))
X- 2568, 2568
X`09`09x_monster_owner(pool`5E`5Bbuffer`5D.current_program))
X- 2759, 2759
X`09`09pool`5E`5Bbuffer`5D.current_program,label_name,r1,r2) then
X- 2936, 2936
X`09    ((code = pool`5E`5Bbuffer`5D.current_program) and`20
X- 3233
X`09    78: `7B boolean and `7D result := e_boolean_and(params);
X`09    79: `7B boolean or `7D result := e_boolean_or(params);
X`09    80: `7B or else `7D result := e_or_else(params);
X`09    81: `7B and then `7D result := e_and_then(params);
X- 3343, 3343
X         else with pool`5E`5Bbuffer`5D.table`5Bitem`5D do begin
X- 3361, 3364
X`09`09n_header:   eval_atom := eval_header(name,ns(long_name`5E),
X`09`09`09    params);
X`09`09n_variable: eval_atom := eval_variable(ns(long_name`5E));
X`09`09n_gosub:    eval_atom := eval_gosub(name,params);
X`09`09n_const:    if long_name = nil then eval_atom := ''
X`09`09`09    else eval_atom := ns(long_name`5E);
X- 3408, 3408
X  else current_run := pool`5E`5Bcurrent_buffer`5D.current_program;
X- 3575, 3575
X`09    with pool`5E`5Bcurrent_buffer`5D do begin `20
X- 3627, 3627
X`09    end; `7B with pool`5E `7D
X- 3746, 3746
X    with pool`5E`5Bcurrent_buffer`5D do begin
X- 3812, 3814
X    s_terminal: terminal_t;
X    count,i,errorcode,s_errorcode: integer;
X
X    function reader_file(var line: string_t): boolean;
X    begin
X`09write_debug('%reader_file');
X`09if EOF(s_file) then reader_file := false
X`09else begin
X`09    readln(s_file,line);
X`09    reader_file := true;
X`09end;
X    end; `7B reader_file `7D
X
X    function reader_terminal(var line: string_t): boolean;
X    var eof_flag : boolean;
X`09s: string;
X`09procedure leave;
X`09begin
X`09    write_debug('%leave');
X`09    eof_flag := true;
X`09end; `7B leave `7D
X    begin
X`09write_debug('%reader_terminal');
X`09eof_flag := false;
X`09grab_line('MDL> ',s,eof_handler := leave, channel := s_terminal);
X`09line := s;
X`09reader_terminal := not eof_flag;
X    end; `7B reader_terminal `7D
X
X    var read_from_terminal : boolean;
Xbegin
X    write_debug('%load');
X    if open_terminal(source,s_terminal) then begin
X`09read_from_terminal := true;
X`09s_errorcode := 0;
X    end else begin
X`09read_from_terminal := false;
X
X- 3817
X    end;
X
X- 3860, 3860
X`09    if read_from_terminal then`09parse(reader_terminal,o_file)
X`09    else begin
X`09`09reset(s_file);
X`09`09parse (reader_file,o_file);
X`09    end;
X- 3873
X`09    if read_from_terminal then close_terminal(s_terminal)
X`09    else close(s_file);
X
X- 3889, 3889
X    new(pool,max_mdl_buffer); (* max_mdl_buffer asetetaan privusers.pas:issa
V *)
X    for i := 1 to max_mdl_buffer do with pool`5E`5Bi`5D do begin
X/
$ CALL UNPACK INTERPRETER.DIF;1 1548631039
$ create 'f'
X/
$ CALL UNPACK KEYS.DIF;1 47
$ create 'f'
X-   57,   57
XPARSER.OBJ + PARSER.PEN : PARSER.PAS,GLOBAL.PEN,DATABASE.PEN,GUTS.PEN
X/
$ CALL UNPACK MAKEFILE.DIF;1 174417888
$ create 'f'
X-   25,   25
X    Create nice multiplayer game
X-   29,   29
X    Monster Helsinki 1.05u
X-   44
X     9.7.1992 `7C         `7C  Claim accepts now type argument (room, object
V,`20
X              `7C         `7C     monster, spell)
X    17.7.1992 `7C         `7C  Disown and Public accepts now also type argum
Vent
X    18.8.1992 `7C         `7C  Functions obj_here, player_here, obj_hold and
V`20
X              `7C         `7C     parse_obj moved to module PARSER
X    13.9.1992 `7C         `7C  Bug fix in disown_user
X   24.10.1992 `7C`09`09`7C  You can't longer complete fill room with monster
Vs
X   28.10.1992 `7C`09`09`7C  Flag: allow_dcl_access
X    5.12.1992 `7C`09`09`7C  chartable_charset, show charset -command
X-  335,  389
X`7B functions obj_here, player_here and obj_hold moved to module PARSER `7D
X
X`7B return the slot of an object that is HERE `7D
Xfunction find_obj(objnum: integer): integer;
Xvar
X`09i: integer;
X
Xbegin
X`09i := 1;
X`09find_obj := 0;
X`09while i <= maxobjs do begin
X`09`09if here.objs`5Bi`5D = objnum then
X`09`09`09find_obj := i;
X`09`09i := i + 1;
X-  393,  430
X`7B function parse_obj moved to module PARSER `7D
X
X`7B functions parse_pers, is_owner, room_owner, can_alter and can_make moved
V to`20
X  module CUSTOM `7D
X
X`7B procedures nice_print, print_short print_line, print_desc and make_line
X   moved to module CUSTOM `7D
X
X`7B
XReturn n as the direction number if s is a valid alias for an exit
X`7D
Xfunction lookup_alias(var n: integer; s: string): boolean;
Xvar
X`09i,poss,maybe,num: integer;
X
Xbegin
X`09gethere;
X-  435,  466
X`09for i := 1 to maxexit do begin
X`09`09if s = here.exits`5Bi`5D.alias then
X`09`09`09num := i
X`7B`09`09else if index(here.exits`5Bi`5D.alias,s) = 1 then begin
X`09`09`09maybe := maybe + 1;
X`09`09`09poss := i;
X`09`09end;`09`09`09`09`7D
X`09end;
X`09if num <> 0 then begin
X`09`09n := num;
X`09`09lookup_alias := true;
X`7B`09end else if maybe = 1 then begin
X`09`09n := poss;
X`09`09lookup_alias := true;
X`09end else if maybe > 1 then begin
X`09`09lookup_alias := false;`09`09`7D
X`09end else begin
X`09`09lookup_alias := false;
X-  470,  509
X-  655,  655
X`09if s = '?' then command_help('accept')
X`09else if lookup_dir(dir,s,true) then begin
X-  691,  691
X`09if s = '?' then command_help('refuse')
X`09else if not(is_owner) then
X- 2642, 2642
X`09if s = '?' then command_help('unlink')
X`09else if checkhide then begin
X- 2661, 2662
X- 2764, 2764
X`09`09lookup_cmd := error`09`7B "Ambiquous" `7D
X- 2899
X`09`09    n := -1;
X- 2953, 2955
X`09`09`20
X`09    if n > 0 then begin  `7B resets counters to zero `7D
X`09`09sub_counter(N_NUMROOMS,n,get_counter(N_NUMROOMS,n));
X`09`09sub_counter(N_ACCEPT,n,get_counter(N_ACCEPT,n));
X`09    end;`20
X
X- 4121
X
X`09if s = '?' then begin
X`09    command_help('summon');
X`09    goto exit_label;
X`09end;
X- 4127, 4127
X`09else if not parse_pers(vslot,vname,true) then writeln('Victim isn''t here
V.')
X- 4362, 4362
X`09`09`09log_event(targslot,E_HPOOFIN,0,0,log_name,loc);
X- 4449, 4451
X`09`09`09`09if lookup_room(loc,s,true) then
X`09`09`09`09`09xpoof(loc)
X`09`09`09`09else writeln('No room ',s,'.');
X`09`09`09end else if parse_pers(n,s,true) then
X- 4467, 4467
X            else if lookup_room(loc,s,true) then begin
X- 5832, 5933
X`09procedure claim_room;
X`09begin
X`09    getroom;
X`09    if not exact_user(oldowner,here.owner) then oldowner := 0;
X`09    if (here.owner = disowned_id) or`20
X`09`09(owner_priv and (here.owner <> system_id)) or
X`09`09manager_priv then begin `7B minor change by leino@finuha `7D
X`09`09`09`09`09`7B and hurtta@finuh `7D
X`09`09here.owner := userid;
X`09`09putroom;
X`09`09change_owner(oldowner,mylog);
X`09`09if here.hook > 0 then set_owner(here.hook,0,userid);
X`09`09getown;
X`09`09own.idents`5Blocation`5D := userid;
X`09`09putown;
X`09`09log_event(myslot,E_CLAIM,0,0);
X`09`09writeln('You are now the owner of this room.');
X`09    end else begin
X`09`09freeroom;
X`09`09if here.owner = public_id then
X`09`09    writeln('This is a public room.  You may not claim it.')
X`09`09else if here.owner = system_id then
X`09`09    writeln('The system own this room.  You may not claim it.')
X`09`09else
X`09`09    writeln('This room has an owner.');
X`09    end;
X`09end; `7B claim_room `7D
X
X`09procedure claim_object(n: integer; s: string);
X`09begin
X`09    getobjown;
X`09    freeobjown;
X`09    `7B*** Let the MM claim any object ***`7D
X`09    `7B jlaiho@finuh `7D
X`09    if ( (objown.idents`5Bn`5D = public_id)`20
X`09`09and (not owner_priv) ) then `7B minor change by leino@finuha `7D
X`09`09writeln('That is a public object.  You may DUPLICATE it, but may not C
VLAIM it.')
X`09    else if ( (objown.idents`5Bn`5D = system_id)`20
X`09`09and (not manager_priv) ) then `7B minor change by hurtta@finuha `7D
X`09`09writeln('That is a system''s object. ')
X`09    else if ( (objown.idents`5Bn`5D <> disowned_id)`20
X`09`09and (not owner_priv) ) then `7B minor change by leino@finuha `7D
X`09`09writeln('That object has an owner.')
X`09    else begin
X`09`09getobj(n);
X`09`09freeobj;
X`09`09if obj.numexist = 0 then
X`09`09    ok := true
X`09`09else begin
X`09`09    if obj_hold(n) or obj_here(n) then
X`09`09`09    ok := true
X`09`09    else
X`09`09`09    ok := false;
X`09`09end;
X                       `20
X`09`09if ok then begin
X`09`09    getobjown;
X`09`09    objown.idents`5Bn`5D := userid;
X`09`09    putobjown;
X`09`09    if obj.actindx > 0 then
X`09`09`09set_owner(obj.actindx,0,userid);
X`09`09    tmp := obj.oname;
X`09`09    log_event(myslot,E_OBJCLAIM,0,0,tmp);
X`09`09    writeln('You are now the owner of ',tmp,'.');
X`09`09end else
X`09`09`09writeln('You must have one to claim it.');
X`09`09end;
X`09end; `7B claim_object `7D
X
X`09procedure claim_monster(n: integer; s: string);
X`09begin
X`09    if parse_pers(mslot,s) then begin   `7B parse_pers make gethere `7D
X`09`09if here.people`5Bmslot`5D.kind = P_MONSTER then begin
X`09`09    code := here.people`5Bmslot`5D.parm;
X`09`09    if ( (monster_owner(code) = public_id)`20
X`09`09`09and (not owner_priv) ) then`20
X`09`09`09writeln('That is a public monster.')
X`09`09    else if ( (monster_owner(code) = system_id)`20
X`09`09`09and (not manager_priv) ) then
X`09`09`09writeln('That is a system''s monster.')
X`09`09    else if ( (monster_owner(code) <> disowned_id)`20
X`09`09`09and (not owner_priv) ) then`20
X`09`09`09writeln('That monster has an owner.')
X`09`09    else begin
X`09`09`09set_owner(code,0,userid);
X`09`09`09tmp := here.people`5Bmslot`5D.name;
X`09`09`09log_event(myslot,E_OBJCLAIM,0,0,tmp);
X`09`09`09writeln('You are now the owner of ',tmp,'.');
X`09`09    end;
X`09`09end else writeln ('That isn''t a monster.');`09`09`09
X`09    end else writeln ('That monster isn''t here.');
X`09end; `7B claim_monster `7D
X
X`09procedure claim_spell(n: integer; s: string);
X`09begin
X`09    if ( (spell_owner(n) = public_id) and (not owner_priv) ) then`20
X`09`09writeln('That is a public spell.')
X`09    else if ( (spell_owner(n) = system_id) and (not manager_priv) ) then
X`09`09writeln('That is a system''s spell.')
X`09    else if ( (spell_owner(n) <> disowned_id) and (not owner_priv) ) then
V`20
X`09`09writeln('That spell has an owner.')
X`09    else begin
X`09`09getint(N_SPELL);
X`09`09freeint;
X`09`09code := anint.int`5Bn`5D;
X`09`09set_owner(code,0,userid);
X`09`09tmp := spell_name.idents`5Bn`5D;
X`09`09log_event(myslot,E_OBJCLAIM,0,0,tmp);
X`09`09writeln('You are now the owner of ',tmp,'.');
X`09    end;
X`09end; `7B claim_spell `7D
Xlabel 0;
X    procedure leave;
X    begin
X`09writeln('QUIT');
X`09goto 0;
X    end;
X
Xvar what: shortstring;
X    ns: string;
X    g: o_type;
Xbegin
X`09ns := s;
X`09what := bite(ns);
X`09if length(s) = 0 then begin`09`7B claim this room `7D
X`09    claim_room;
X`09end else if lookup_type(g,what,false,false) then begin
X`09    if (g <> t_room) and (ns = '') then
X`09`09grab_line('Claim '+what+' what? ',ns,eof_handler := leave);
X`09    if (g <> t_room) and (ns = '') then goto 0;
X`09    case g of
X`09`09t_room: if ns = '' then claim_room
X`09`09`09else writeln('You can only claim that room (no room name).');
X`09`09t_object: if lookup_obj(n,ns,true) then claim_object(n,ns)
X`09`09`09else writeln('No object ''',ns,'''.');
X`09`09t_monster: if lookup_pers(n,ns,true) then claim_monster(n,ns)
X`09`09`09else writeln('No monster ''',ns,'''.');
X`09`09t_spell: if lookup_spell(n,ns,true) then claim_spell(n,ns)
X`09`09`09else writeln('No spell ''',ns,'''.');
X`09`09t_player: writeln('You can''t do that.');
X`09    end; `7B case `7D
X`09end else if lookup_obj(n,s) then begin
X`09    claim_object(n,s);
X`09end else if lookup_pers(n,s) then begin
X`09    claim_monster(n,s);
X`09end else if lookup_spell(n,s) then begin
X`09    claim_spell(n,s);
X`09end else writeln('There is nothing here by that name to claim.');
X    0:
X- 5940, 6020
X
X    procedure disown_room;
X    begin
X`09getroom;
X`09if not exact_user(oldowner,here.owner) then oldowner := 0;
X`09    if (here.owner = userid) or`20
X`09    (owner_priv and (here.owner <> system_id)) or
X`09    manager_priv then begin `7B minor change by leino@finuha `7D
X`09    getroom;
X`09    here.owner := disowned_id;
X`09    putroom;
X`09    change_owner(oldowner,0);
X`09    if here.hook > 0 then set_owner(here.hook,0,disowned_id);
X`09    getown;
X`09    own.idents`5Blocation`5D := disowned_id;
X`09    putown;
X`09    log_event(myslot,E_DISOWN,0,0);
X`09    writeln('You have disowned this room.');
X`09end else begin
X`09    freeroom;
X`09    if here.owner = system_id then
X`09`09writeln('Owner of this room is system.')
X`09    else writeln('You are not the owner of this room.');
X`09end;
X    end; `7B disown_room `7D
X
X    procedure disown_object(n: integer; s: string);
X    begin
X`09getobj(n);
X`09freeobj;
X`09tmp := obj.oname;
X
X`09getobjown;
X`09if (objown.idents`5Bn`5D = userid) or`20
X`09    (owner_priv and ( objown.idents`5Bn`5D <> system_id))
X`09    or manager_priv then begin
X`09    objown.idents`5Bn`5D := disowned_id;
X`09    putobjown;
X`09    if obj.actindx > 0 then set_owner(obj.actindx,0,disowned_id);
X`09    log_event(myslot,E_OBJDISOWN,0,0,tmp);
X`09    writeln('You are no longer the owner of the ',tmp,'.');
X`09end else begin
X`09    freeobjown;
X`09    if objown.idents`5Bn`5D = system_id then`20
X`09`09writeln('System is owner of this.')
X`09    else writeln('You are not the owner of any such thing.');
X`09end;
X    end; `7B disown_objects `7D
X
X    procedure disown_monster(n: integer; s: string);
X    begin
X`09if parse_pers(mslot,s) then begin   `7B parse_pers make gethere `7D
X`09    if here.people`5Bmslot`5D.kind = P_MONSTER then begin
X`09`09code := here.people`5Bmslot`5D.parm;
X`09`09if (monster_owner(code) = system_id)
X`09`09and not manager_priv then`20
X`09`09    writeln('The owner of this monster is system.') `09
X`09`09else if  (monster_owner(code) <> userid)`20
X`09`09    and not owner_priv then`20
X`09`09    writeln('You are not the owner of this monster')
X`09`09else begin
X`09`09    set_owner(code,0,disowned_id);
X`09`09    tmp := here.people`5Bmslot`5D.name;
X`09`09    log_event(myslot,E_OBJDISOWN,0,0,tmp);
X`09`09    writeln('You are no longer the owner of the ',tmp,'.');
X`09`09end;
X`09    end else writeln ('That isn''t monster.');
X`09end else writeln ('Here isn''t that monster.');
X    end; `7B disown_monster `7D
X
X    procedure disown_spell(n: integer; s: string);
X    begin
X`09if (spell_owner(n) = system_id) and not manager_priv then
X`09    writeln('The owner of this spell is system.') `09
X`09else if (spell_owner(n) <> userid) and not owner_priv then`20
X`09    writeln('You are not the owner of this spell')
X`09else begin
X`09    getint(N_SPELL);
X`09    freeint;
X`09    code := anint.int`5Bn`5D;
X`09    set_owner(code,0,disowned_id);
X`09    tmp := spell_name.idents`5Bn`5D;
X`09    log_event(myslot,E_OBJDISOWN,0,0,tmp);
X`09    writeln('You are no longer the owner of the ',tmp,'.');
X`09end;
X    end; `7B disown_spell `7D
X
Xlabel 0;
X    procedure leave;
X    begin
X`09writeln('QUIT');
X`09goto 0;
X    end;
Xvar what: shortstring;
X    ns: string;
X    g: o_type;
Xbegin
X`09ns := s;
X`09what := bite(ns);
X`09if length(s) = 0 then begin`09`7B disown this room `7D
X`09    disown_room;
X`09end else if lookup_type(g,what,false,false) then begin
X`09    if (g <> t_room) and (ns = '') then
X`09`09grab_line('Disown '+what+' what? ',ns,eof_handler := leave);
X`09    if (g <> t_room) and (ns = '') then goto 0;
X`09    case g of
X`09`09t_room: if ns = '' then disown_room
X`09`09`09else writeln('You can only disown that room (no room name).');
X`09`09t_object: if lookup_obj(n,ns,true) then disown_object(n,ns)
X`09`09`09else writeln('No object ''',ns,'''.');
X`09`09t_monster: if lookup_pers(n,ns,true) then disown_monster(n,ns)
X`09`09`09else writeln('No monster ''',ns,'''.');
X`09`09t_spell: if lookup_spell(n,ns,true) then disown_spell(n,ns)
X`09`09`09else writeln('No spell ''',ns,'''.');
X`09`09t_player: writeln('You can''t do that.');
X`09    end; `7B case `7D
X`09end else if lookup_obj(n,s) then begin
X`09    disown_object(n,s);
X`09end else if lookup_pers(n,s) then begin
X`09    disown_monster(n,s);
X`09end else if lookup_spell(n,s) then begin
X`09    disown_spell(n,s);
X`09end else writeln('You are not the owner of any such thing.');
X`090:
Xend; `7B do_disown `7D
X- 6030, 6086
X    procedure public_room;
X    begin
X`09getroom;
X`09if not exact_user(oldowner,here.owner) then oldowner := 0;
X`09here.owner := public_id;
X`09putroom;
X`09change_owner(oldowner,0);
X`09if here.hook > 0 then set_owner(here.hook,0,public_id);
X`09getown;
X`09own.idents`5Blocation`5D := public_id;
X`09putown;
X`09writeln('This room is now public.');
X    end; `7B public_room `7D
X
X    procedure public_object(n: integer; s: string);
X    begin
X`09getobj(n);
X`09freeobj;
X`09if obj.numexist = 0 then ok := true
X`09else begin
X`09    if obj_hold(n) or obj_here(n) then ok := true
X`09    else ok := false;
X`09end;
X
X`09if ok then begin
X`09    getobjown;
X`09    objown.idents`5Bn`5D := public_id;
X`09    putobjown;
X`09    if obj.actindx > 0 then
X`09`09set_owner(obj.actindx,0,public_id);
X
X`09    tmp := obj.oname;
X`09    log_event(myslot,E_OBJPUBLIC,0,0,tmp);
X`09    writeln('The ',tmp,' is now public.');
X`09end else writeln('You must have one to claim it.');
X    end; `7B public_object `7D
X
X    procedure public_monster(n: integer; s: string);
X    begin
X`09if parse_pers(mslot,s) then begin   `7B parse_pers make gethere `7D`09`09
V `20
X`09    if here.people`5Bmslot`5D.kind = P_MONSTER then begin
X`09`09code := here.people`5Bmslot`5D.parm;
X`09`09set_owner(code,0,public_id);
X`09`09tmp := here.people`5Bmslot`5D.name;
X`09`09log_event(myslot,E_OBJPUBLIC,0,0,tmp);
X`09`09writeln('The ',tmp,' is now public.');
X`09    end else writeln ('That isn''t monster.');
X`09end else writeln ('Here isn''t that monster.');
X    end; `7B public_monster `7D
X
X    procedure public_spell(n: integer; s: string);
X    begin
X`09getint(N_SPELL);
X`09freeint;
X`09code := anint.int`5Bn`5D;
X`09set_owner(code,0,public_id);
X`09tmp := spell_name.idents`5Bn`5D;
X`09log_event(myslot,E_OBJPUBLIC,0,0,tmp);
X`09writeln('The ',tmp,' is now public.');
X    end; `7B public_spell `7D
X
Xlabel 0;
X    procedure leave;
X    begin
X`09writeln('QUIT');
X`09goto 0;
X    end;
Xvar what: shortstring;
X    ns: string;
X    g: o_type;
Xbegin
X    if manager_priv then begin `7B minor change by leino@finuha `7D
X`09ns := s;
X`09what := bite(ns);
X`09if length(s) = 0 then begin
X`09    public_room;
X`09end else if lookup_type(g,what,false,false) then begin
X`09    if (g <> t_room) and (ns = '') then
X`09`09grab_line('Public '+what+' what? ',ns,eof_handler := leave);
X`09    if (g <> t_room) and (ns = '') then goto 0;
X`09    case g of
X`09`09t_room: if ns = '' then public_room
X`09`09`09else writeln('You can only public that room (no room name).');
X`09`09t_object: if lookup_obj(n,ns,true) then public_object(n,ns)
X`09`09`09else writeln('No object ''',ns,'''.');
X`09`09t_monster: if lookup_pers(n,ns,true) then public_monster(n,ns)
X`09`09`09else writeln('No monster ''',ns,'''.');
X`09`09t_spell: if lookup_spell(n,ns,true) then public_spell(n,ns)
X`09`09`09else writeln('No spell ''',ns,'''.');
X`09`09t_player: writeln('You can''t do that.');
X`09    end; `7B case `7D
X`09end else if lookup_obj(n,s) then begin
X`09    public_object(n,s);
X`09end else if lookup_pers(n,s) then begin
X`09    public_monster(n,s);
X`09    end else if lookup_spell(n,s) then begin
X`09`09public_spell(n,s);
X`09end else writeln('There is nothing here by that name to make public.');
X    end else
X`09writeln('Only the Monster Manager may make things public.');
X    0:
X- 6413, 6413
X`09`09if parse_pers(n,s,true) then begin
X- 6667, 6668
X`09if s = '?' then command_help('ping')
X`09else if s <> '' then begin
X`09`09if parse_pers(n,s,true) then begin
X- 7436, 7436
X`09else if not parse_pers(victim,s,true) then begin
X- 7514, 7514
X`09else if s = '?' then command_help('use')
X`09else if parse_obj(n,s,true) then begin
X- 7575, 7575
X`09end else if parse_pers(n,s,true) then begin
X- 7653, 7653
X`09end else if parse_obj(n,s,true) then begin
X- 7711, 7711
X`09end else if parse_obj(n,s,true) then begin
X- 8193
X`09`09s_charset: writeln('Database charset is ',
X`09`09`09    chartable_charset,'.');
X- 8398, 8414
X    if alloc_dcl_access then begin
X`09log_action (c_dcl,0);
X`09do_dcl (s);   `7B Spawn subprocess .. `7D
X`09log_event (myslot,E_DCLDONE,0,0,'');
X `20
X`09`7B check database `7D
X`09getindex (I_ASLEEP);        `20
X`09freeindex;
X`09if indx.free `5Bmylog`5D then `7B Oops ! I am in asleep ... `7D
X`09begin
X`09    WriteLn ('You are throw out from Monster-universe during your stay on
V DCL-level.');
X`09    finish_interpreter;
X`09    halt;
X`09end;
X         `20
X`09`7B Because only my process update my situation, I can suppose that
X`09    datatabase and data in memory is valid - I hope so ...        `7D
X    end else writeln('DCL access disabled !');
X- 8482
X`09    monster_count: integer;
X- 8515
X`09monster_count := 0;
X- 8519, 8524
X`09for j := 1 to maxpeople do begin
X`09    if here.people`5Bj`5D.kind = 0 then begin
X`09`09i := j;
X`09`09found := true
X`09    end else if here.people`5Bj`5D.kind <> P_PLAYER then
X`09`09monster_count := monster_count + 1;
X`09end; `7B for `7D
X
X`09`7B reserve last position for (interactive) player `7D
X`09if monster_count >= maxpeople-1 then found := false;
X
X- 8583, 8583
X               writeln('%begining to create monster');
X- 8672, 8672
X  else if parse_pers(mslot,s,true) then begin
X- 8970, 8970
X    if s = '?' then command_help('list')
X    else if s > '' then begin
X- 8995, 8995
X    if s = '?' then command_help('create')
X    else if s > '' then begin
X- 9286, 9287
X`09show`5Bs_charset`5D := 'charset';
X`09
X`09numshow := 13;
X-10575,10577
X
X`09wait(1);`09`7B try fixing event problem - yes - that isn't good `7D
X`09if not int_poof(name,nam.idents`5Bloc`5D,'',true,true) then begin
X`09    `7B FAILED !! `7D
X`09    log_event(n,E_POOFIN,0,0,name,location); `7B false event `7D
X`09end;
X`09writeln;
X/
$ CALL UNPACK MON.DIF;1 1661931861
$ create 'f'
X-   10
Xdefine syntax MONSTER_REBUILD
X   image MONSTER_IMAGE_:monster_rebuild
X-   17,   17
X      nonnegatable
X      syntax = MONSTER_REBUILD
X   qualifier FIX
X      nonnegatable
X      syntax = MONSTER_REBUILD
X-   25
X      nonnegatable
X      syntax = MONSTER_REBUILD
X-   37,   37
X   disallow (START and (BUILD or DUMP or REBUILD or FIX))
X/
$ CALL UNPACK MONSTER_CLD.DIF;2 1060059043
$ create 'f'
X-   29,   31
X    9.07.1992 `7C         `7C If reading of dump failed, mark it as invalid,
X              `7C         `7C added (incomplete) end of dump file check to e
Vnd
X   12.08.1992 `7C         `7C Dummy player_here removed (now defined in modu
Vle
X              `7C         `7C PARSER)
X    5.12.1992 `7C         `7C Warning about charset
X`7D
X
XCONST DVERSION = '1.04'; `7B DUMPER Version `7D
X-   38,   44
X    READ_vers_104: boolean;
X
X    READ_error: boolean;`20
X-  204
X    line: string;
X-  219,  220
X`09    freeline;
X`09    line := oneliner.theline;
X`09    if length(line) > 65 then begin
X`09`09    write_ITEM(f,'DESCLINEB%',substr(line,1,50));
X`09`09    line := substr(line,51,length(line)-50);
X`09    end;
X`09    write_ITEM(f,'DESCLINE%',line);
X-  229,  229
Xvar data,datab: string;
X    ok: boolean;
X-  237,  244
X    end else begin
X`09ok := false;
X`09if READ_vers_104 then`20
X`09    IF read_ITEM(f,'DESCLINEB%',datab) then ok := true;
X`09if read_ITEM(f,'DESCLINE%',data) then begin
X`09    if alloc_general(I_LINE,linenum) then begin
X`09`09if ok then data := datab + data;
X`09`09getline(linenum);
X`09`09oneliner.theline := data;
X`09`09putline;
X`09`09read_DESCLINE := true;
X`09    end else begin
X`09`09writeln('Can''t allocate space for desciption line!');
X`09`09READ_error := true;
X`09`09linenum := 0;
X`09`09read_DESCLINE := true;
X`09    end;
X`09end else begin
X`09    if ok then begin
X`09`09writeln('Partial description line readed !');
X`09`09read_ERROR := true;
X`09`09linenum := 0;
X`09`09read_DESCLINE := true;
X`09    end else read_DESCLINE := false;
X`09end;
X    end;
X-  251
X    line: string;
X-  267,  268
X`09    for i := 1 to block.desclen do begin
X`09`09line := block.lines`5Bi`5D;
X`09`09if length(line) > 70 then begin
X`09`09    write_ITEM(f,'BLOCKB%',substr(line,1,60));
X`09`09    line := substr(line,61,length(line)-60);
X`09`09end;
X`09`09write_ITEM(f,'BLOCK%',line);
X`09    end;
X-  277
X    function getit(var data: string): boolean;
X    var datab: string;
X    begin
X`09if READ_vers_104 then`20
X`09    if read_ITEM(f,'BLOCKB%',datab) then
X`09`09if read_ITEM(f,'BLOCK%',data) then begin
X`09`09    data := datab + data;
X`09`09    getit := true;
X`09`09end else begin
X`09`09    writeln('Partial block description line !');
X`09`09    read_ERROR := true;
X`09`09    data := datab;
X`09`09    getit := true;
X`09`09end
X`09    else getit := read_ITEM(f,'BLOCK%',data)
X`09else getit := read_ITEM(f,'BLOCK%',data);
X    end; `7B getit `7D
X-  293,  293
X`09    while getit(data) do begin
X-  299,  299
X`09end else begin
X`09    writeln('Can''t allocate space for description block !!');
X`09    READ_error := true;
X`09    while getit(data) do ;
X`09    code := 0;
X`09    read_BLOCK := true;
X`09end;
X-  381
X`09READ_error := READ_error or not flag;
X-  428
X`09    READ_error := true;
X-  439,  440
X`09    if name = 0 then begin
X`09`09READ_error := true;
X`09`09writeln('Reference error in class ',
X`09`09    class:1,'/',iclass:1, ' name ',data);
X`09    end;
X-  457
X`09    READ_error := true;
X-  469,  470
X`09    if name = 0 then begin
X`09`09READ_error := true;
X`09`09writeln('Overflow error in class ',
X`09`09    class:1,'/',iclass:1, ' name ',data)
X`09    end
X-  550,  551
X`09if code = 0 then begin
X`09    READ_error := true;
X`09    writeln('Overflow error in mdl store.')
X`09end else begin
X-  595
X`09READ_error := READ_error or not flag;
X-  652
X      READ_error := true;
X-  728
X      READ_error := READ_error or not flag;
X-  758
X`09READ_error := true;
X-  785
X`09READ_error := READ_error or not flag;
X-  828,  828
X`09if id = 0 then begin
X`09    READ_error := true;
X`09    writeln('Monster''s name ',data,' not found.');
X`09end;
X-  840,  847
X`09    if a = 0 then flag := false (* skip *)
X`09    else begin
X`09`09rec.holding`5Bi`5D := a;
X
X`09`09getobj(a);  `20
X`09`09obj.numexist := obj.numexist + 1;   `7B Update counter `7D
X`09`09putobj;
X
X
X`09`09i := i +1;
X`09    end;`20
X-  861
X`09READ_error := READ_error or not flag;
X-  941,  941
Xvar sp,i,owner,filler: integer;
X- 1015, 1015
X`09if sp = 0 then begin
X`09    read_INTEGER(f,'LEVEL%',filler); (* SKIP ! *)
X`09    flag := false;
X`09end
X`09else if not read_INTEGER(f,'LEVEL%',spell.level`5Bsp`5D) then flag := fal
Vse;
X- 1042
X`09READ_error := true;
X- 1064
X`09READ_error := READ_error or not flag;
X- 1095
X`09    READ_error := true;
X- 1098
X`09    READ_error := true;
X- 1126, 1126
X`09    READ_error := READ_error or not flag;
X- 1214
X`09    READ_error := true;
X- 1236
X`09READ_error := true;
X- 1320
X`09READ_error := true;
X- 1374, 1381
X`09    if intdata = 0 then begin
X`09`09read_INTEGER(f,'OBJHIDE%',intdata); (* skip ! *)
X`09`09flag := false;
X`09    end else begin
X`09`09here.objs`5Bi`5D := intdata;
X`09`09if not read_INTEGER(f,'OBJHIDE%',here.objhide`5Bi`5D) then flag := fal
Vse;
X
X`09`09getobj(here.objs`5Bi`5D);  `20
X`09`09obj.numexist := obj.numexist + 1;   `7B Update counter `7D
X`09`09putobj;
X
X`09`09i := i+1;
X`09    end;
X- 1415
X`09READ_error := READ_error or not flag;
X- 1447
X`09READ_error := true;
X- 1488
X`09READ_error := READ_error or not flag;
X- 1527
X`09READ_error := READ_error or not flag;
X- 1545
X    write_ITEM(f,'CHARSET%',chartable_charset);
X- 1611
X    dump_charset : string;
X- 1614
X    READ_error := false;
X- 1628, 1628
X    READ_vers_104 := ver >= '1.04';
X    if (ver > DVERSION) then writeln('WARNING: Unknown version!');
X
X    if not read_ITEM(f,'CHARSET%',dump_charset) then
X`09dump_charset := 'UNKNOWN';
X    if (dump_charset = 'UNKNOWN') or (chartable_charset = 'UNKNOWN') then be
Vgin
X`09writeln('WARNING: Dumped database''s charset is ',dump_charset,' and');
X`09writeln('         charset for building database is ',
X`09    chartable_charset,'.');
X    end else if (dump_charset <> chartable_charset) then begin
X`09writeln('WARNING: Dumped database''s charset is ',dump_charset,' and');
X`09writeln('         charset for building database is ',
X`09    chartable_charset,'.');
X`09writeln('         No conversions implemented.');
X    end;
X- 1775, 1775
X`09writeln(j:3,' real players and monsters readed.')
X- 1794, 1795
X    if READ_error then writeln('Error(s) detected during read !!!');
X
X    if not eof(f) then begin
X`09(* This not detect if end of dump file have one extra line,
X`09 * because read_ITEM will read it for next line check !!!!
X`09 *)
X`09writeln('Expected end of dump file NOT detected !');
X`09writeln('  (Reading of dump file out of sync ?)');
X`09error := true;
X    end;
X
X    if error or READ_error then begin
X`09writeln('Marking created database as invalid.');
X`09getglobal;
X`09global.int`5BGF_VALID`5D := 0;`09`7B FALSE `7D
X`09putglobal;
X`09writeln;
X    end;
X
Xloppu:
X    if error or READ_error then writeln('Dump file is invalid.')
X    else writeln('Database created.');
X/
$ CALL UNPACK MONSTER_DUMP.DIF;2 1633358184
$ create 'f'
X-   13,   15
X  This parameter specifies the text form equivalent of a database.  Default`
V20
X  extension is .DMP.  This parameter is required with the qualifiers /DUMP`2
V0
X  and /BUILD.`20
X `20
X-   21,   24
X  Shows the version text.  The /VERSION qualifier shows the same  text`20
X  when playing Monster.
X
X  Incompatible with /WHO.
X-   29,   32
X  Prevents or enables the start of playing after handling of other`20
X  qualifiers. Useful with /VERSION.
X
X  Incompatible with /WHO, /DUMP and /BUILD.
X-   37,   40
X  Redirects Monster's output to a file. Useful with /VERSION or`20
X  management qualifiers.
X
X  Incompatible with /FIX, /WHO, /DUMP and /BUILD.
X-   44,   44
X  These qualifiers are only for Monster Manager.
X-   48,   51
X  Builds a new database for Monster. Checks first the entries  of`20
X  MONSTER.INIT -file.
X
X  Incompatible with /FIX, /REAL_USERID, /USERID, /BATCH, /WHO, /DUMP
X-   56,   62
X  Activates the fixing system in the interactive mode. With it`20
X  Monster Manager can fix errors of database.
X
X  Incompatible with /OUTPUT, /REBUILD, /REAL_USERID, /USERID, /BATCH,`20
X  /WHO, /DUMP and /BUILD.
X
X  See also Fixing_Database.
X-   67,   70
X  Switches the debug mode on or off. Equivalent to the DEBUG command when
X  playing Monster.
X
X  Incompatible with /WHO.
X-   74,   76
X  Enables playing with another player's name.
X
X  Incompatible with /REBUILD, /FIX, /USERID, /BATCH, /WHO, /DUMP and`20
X-   81,   83
X  Runs the fixing system in the batch mode.`20
X
X  Incompatible with /REBUILD, /FIX,  /REAL_USERID,  /USERID, /BATCH,`20
X-   88,   93
X  Nearly the same as /REBUILD: reads the database from a special text`20
X  file. The dump_file parameter is required with this qualifier.
X
X  See also /DUMP.
X
X  Incompatible with /REBUILD, /FIX, /REAL_USERID,  /USERID,  /BATCH,`20
X-   98,  102
X   Creates a text form copy of the database for /BUILDing. The dump_file
X   parameter is required with this qualifier.
X
X   Incompatible with /REBUILD, /FIX, /REAL_USERID,  /USERID,  /BATCH,`20
X   /DUMP, /OUTPUT and /START.
X-  108,  111
X  Enables playing with a virtual userid. Virtual userids are independent`20
X  of real userids. They are protected with passwords.`20
X
X  Incompatible with   /REBUILD,  /FIX,  /REAL_USERID,  /BATCH,  /WHO,`20
X-  116,  119
X  Shows players currently playing Monster, but not those starting it.
X  Ideal for LOGIN.COM.                                       `20
X
X  Incompatible with other qualifiers.
+-+-+-+-+-+-+-+-  END  OF PART 2 +-+-+-+-+-+-+-+-
-- 
- K E H                                      /  El{m{ on monimutkaista
  Kari.Hurtta@Helsinki.FI
