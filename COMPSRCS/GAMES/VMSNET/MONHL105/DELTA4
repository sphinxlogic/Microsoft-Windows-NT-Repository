Newsgroups: vmsnet.sources.games
Path: uunet!europa.asd.contel.com!paladin.american.edu!news.univie.ac.at!hp4at!mcsun!news.funet.fi!hydra!klaava!hurtta
From: Kari.Hurtta@Helsinki.FI
Subject: Delta: Monster Helsinki 1.05 to 1.06 (part 4/5)
Message-ID: <1992Dec6.181345.20237@klaava.Helsinki.FI>
Followup-To: vmsnet.sources.d
Sender: hurtta@klaava.Helsinki.FI (Kari Hurtta)
Organization: University of Helsinki
Date: Sun, 6 Dec 1992 18:13:45 GMT
Lines: 1470
Xref: uunet vmsnet.sources.games:559

Archive-name: monster_helsinki_105_to_106/part4
Author: Kari.Hurtta@Helsinki.FI
Package: Delta from Helsinki Monster 1.05 to Helsinki Monster 1.06
Environment: VMS, Pascal
Part: 4/5

-+-+-+-+-+-+-+-+ START OF PART 4 -+-+-+-+-+-+-+-+
X  Returns a list of objects that were duplicated.
X
X  Requirements:
X`09- the code must be in the "privileged" mode
X
X  Errors:
X`09- the code is not in the "privileged" mode
X   `09  => no action; p1 is not evaluated; the result is
X          an empty string
X`09- an object does not have the same onowner as the code
X          and the code is not monster code
X          or
X        - an object does not have the same owner as the code and
X`09  the code does not have the "object" privilege
X          or
X        - the player cannot take any more objects
X          => the object is not duplicated
X
X  Interpretation:
X     p1, result : list
X4 destroy
X  Function: destroy (p1)
X
X  Evaluates p1.
X
X  Destroys all the objects found in the list p1. The objects`20
X  and the monster must have the same owner oror the monster
X  must have the "object" privilege.
X
X  Returns a list of the destroyed objects.
X                         `20
X  Errors:
X`09- the code is not monster code
X`09  => no action; an empty string is returned
X`09- an object and the monster does not have the same
X`09  owner and the monster does not have the "object"
X`09  privilege
X          => the object is not destroyed`20
X
X  Interpretation:
X     p1, result : list   `20
X4 pdestroy
X  Function: pdestroy (p1)
X
X  Evaluates p1.
X
X  Destroys all the objects found in the list p1 from the`20
X  player. The objects and the monster must have the same
X  owner or the monster must have the "object" privilege.
X
X  Returns a list of destroyed objects.
X
X  Requirements:
X`09- the code must be in the "privileged" mode
X
X  Errors:
X`09- the code is not in the "privileged" mode
X`09  => no action; an empty string is returned
X        - an object and the code does not have the same
X`09  owner and te code is not mosnter code
X`09  or
X`09- an object and the monster does not have the same
X`09  owner and the monster does not have the "object"
X`09  privilege
X          => the object is not destroyed`20
X
X  Interpretation:
X     p1, result : list   `20
X4 or
X  Function: or (p1,p2,p3,...)
X
X  Evaluates p1, p2, p3,...
X
X  Returns a list of items found in pN. Every item is included
X  only once.
X
X  Errors:
X   - the result list is longer than 1000 characters
X     => the result is a list containing only so many items
X     that fit into 1000 chars.`20
X
X  Interpretation:
X     pN, result : list
X4 string_head
X  Function: string head (p1)
X
X  Evaluates p1.
X
X  Returns the first word of the string p1.
X
X  Errors:
X`09- p1 is an empty string
X`09  => Ran emprty string is returned
X
X  Interpretation:
X     p1, result : string
X4 string_tail
X  Function: string tail (p1)
X
X  Evaluates p1.
X
X  Returns the tail of string p1 ( all except the first word ).
X
X  Errors:
X`09- p1 is an empty string
X`09  or
X`09- p1 contains only one word
X`09  => an empty string is returned
X
X  Interpretation:
X     p1, result : string
X4 tail
X  Function: tail (p1)
X
X  Evaluates p1.
X
X  Returns the list p1 excluding the first item.
X
X  Errors:
X`09- p1 is an epmty list
X`09  or
X`09- p1 has only one item
X`09  => an empty list/string is returned
X
X  Interpretation:
X     p1, result : list
X4 head
X  Function: head (p1)
X
X  Evaluates p1.
X
X  Returns the first item of the list p1.
X
X  Errors:
X`09- p1 is an empty list
X`09  => an empty string is returned
X
X  Interpretation:
X     p1     : list
X     result : item
X4 lookup_room
X  Function: lookup room (p1)
X
X  Evaluates p1.
X
X  Parses the items found in the list p1 to room names. If`20
X  a parsing is unsuccessfull that item is exculded from the
X  result list.
X
X  Interpretation:
X     p1, result : list
X4 lookup_player
X  Function: lookup player (p1)
X
X  Evaluates p1.
X
X  Parses ( completes ) the items in the p1 list to player
X  and monster names. If the completion of an item fails that
X  item is removed from the result list.
X
X  Interpretation:
X     p1, result : list
X4 lookup_object
X  Function: lookup object (p1)
X
X  Evaluates p1.
X
X  Parses ( completes ) the items in the list p1 to object names.
X  If the completion of an item fails that item is removed from`20
X  the result list.
X
X  Interpretation:
X     p1, result : list
X4 parse_player
X  Function: parse player (p1)
X
X  Evaluates p1.
X
X  The function offers an equivalent parameter interpretation`20
X  service as used in those monster functions where wild cards`20
X  are allowed.
X
X  Return a list of players and monsters. The list is equivalent to
X  parameter p1. ( whatever that implies, then )
X
X  Errors:
X    - p1 is empty
X    or
X    - an error occurs while interpreting p1
X    => the result is an empty string
X
X  Interpretation:
X      p1     : string
X      result : list
X4 parse_object
X  Function: parse object (p1)
X                  `20
X  Evaluates p1.
X
X  Offers an equivalent parameter interpretation service as
X  is used in those monster functions where wild cards are
X  allowed.
X
X  Returns a list of objects equivalent to p1.
X
X  Errors:
X    - p1 is empty`20
X    or
X    - there is an error while interpreting p1
X    => the result is an empty string/list
X
X  Interpretation:
X      p1     : string
X      result : list
X4 parse_room
X  Function: parse room (p1)
X
X  Evaluates p1.
X
X  The function offers an equivalent parameter interpretation service
X  as used in those monster functions where wild cards are allowed.
X
X  Returns a list of rooms equivalent to p1.
X
X  Errors:
X    - p1 is empty
X    or
X    - An error occurs while interpreting p1
X    => the result is an empty string
X
X  Interpretation:
X      p1     : string
X      result : list
X4 privilege
X  Function: privilege (p1,p2)
X
X  Evaluates p1 and p2.
X
X  All the player ( or monster ) p1 privileges found in the
X  list p2 are returned. Possible privileges are : wizard,
X  manager, experience, quota, object, poof, special and
X  monster. The "wizard" privilege means that the player is
X  the Monster Manager.
X
X  Errors:
X`09- p1 is not a player or monster name
X          => the result is an empty string/list
X        - p2 has a non-existent privilege
X          => the privilege is excluded from the`20
X             result list
X
X  Interpretation:
X     p1     : name
X     p2     : list
X     result :  list
X
X4 userid
X  Function: userid (p1)
X
X  Evaluates p1.
X
X  The function requires the "experience" privilege from the
X  monster.
X
X  Returns a list where the player names in p1 have been`20
X  substituted for their respective userids.
X
X  Errors:
X        - the code is not monster code or the monster does not
X          have the "experience" privilege
X          => the function does not evaluate p1; an empty string
X          is returned
X`09- an invalid player ( monster ) name is found
X`09  => the respective userid is excluded from the result
X`09- a monster name is found
X`09  => is included, the userid uses internal format
X
X  Interpretation:
X      p1, result : list
X4 attack
X  Function: attack (p1)
X
X  Evaluates p1.
X
X  Substracts p1 units from the player ( who triggered the
X  action ) health. However, the monster experience dictates
X  the maximum damage allowed ( p1 can be greater than what
X  is allowed in which case p1 is decreased ). The total sum
X  of subsequent attacks may not exceed the maximum damage`20
X  allowed.
X
X  Returns the attack strength.
X
X  Requirements:
X     - Monster cannot have attacked to its limit already.
X     - Player must not be protected
X     - Hooks must be in the "privileged" mode
X
X  Errors:
X     - The monster has already attacked to its limit
X       or
X     - The player is protected
X       or
X     - p1 is not a number
X       or
X     - the code is not monster code and the "privileged"`20
X       mode is off
X       => no action; an empty string/number is returned
X     - p1 is greater than the maximum attack strength
X       allowed
X       => The attack strength is the maximum allowed
X       ( it is also returned )
X     - the code is not monster code and privileged mode
X       is on
X       => no limits in attack strength
X`20
X  Interpretation:
X     p1, result : number
X
X  N.B:
X     - The function does not tell how the attack succeeded
X     ( can be found out be the function "health" )
X     - The function does not require monsters to be
X     in the "privileged" mode anymore
X4 spell_level
X  Function: spell level()
X
X  Returns the user's experience level of a spell. Can only be used
X  while executing spell code ( labels summon and learn ).
X
X  Errors:
X         - As in other spell functions
X           => an empty string is returned
X
X  Interpretation:
X     result : number
X
X  N.B:
X `09 - The spell user ( in the variable "summoner name" )
X           is different from the user executing the code
X`09   ( exception: the label "learn" )
X4 set_spell_level
X  Function: set spell level(p1)
X`20
X  Evaluates p1.
X
X  Sets the spell user's experience level ( of a spell ).`20
X  Can only be used when executing spell code ( the labels
X  "summon" and "learn" ).`20
X    Level 0           - the player does not know the spell
X    a positive number - the player knows the spell
X
X  Returns the new experience level.
X
X  Errors:
X         - As in other spell functions
X         or
X`09 - p1 is not a number
X         or
X`09 - p1 < 0
X          =>an empty string/number is returned
X
X  Interpretation:
X     p1 , result : number
X
X  N.B:
X `09 - The spell user ( in the variable "summoner name" )
X           is different from the user executing the code
X`09   ( exception: the label "learn" )
X`09 - This function is for teaching spells to players
X           ( in the label "learn" )
X`09 - The variable "book name" has the name of the book
X           ( magic book ) that triggered the label "learn" of
X           the spell
X2 Fixing_Database `20
X  Start monster with MONSTER/FIX -command.
X
X  The fixing subsystem uses file level locks to prevent other`20
X  players from playing Monster while you are fixing the database.
X
X  If someone is playing, and you want to fix the database,`20
X  it's better to shut Monster down with the  command "D" in`20
X  the subsystem menu (in system-menu).
X `20
X3 Menu
X  By typing "?" you get the following menu in /FIX -system:
X- 3939, 3940
X  The following commands make partial rebuild of the Monster database.  Afte
Vr`20
X  these command use the fixing commands to fix pointers in the database.
X- 3955, 3961
X  Recommended order: GL R O P M C F N S SP
X
X  You can use only one of these: R, O and P.  Should you need more, use`20
X  /REBUILD  instead.
X
X3 Fix_commands
X  The following commands can fix small errors in the database without disast
Ver:
X- 3973, 3973
X  Recommended order: C I N G J K L D OW
X/
$ CALL UNPACK MONSTER_E.DIF;1 1503667532
$ create 'f'
X-  344,  346
X               Claim room
X               Claim <object>
X               Claim object <object>
X               Claim <monster>
X               Claim monster <monster>
X               Claim <spell>
X               Claim spell <spell>
X-  411,  416
X               Disown room
X               Disown <object>
X               Disown object <object>
X               Disown <monster>
X               Disown monster <monster>
X               Disown <spell>
X               Disown spell <spell>
X
XDescription:   Sets ownership of <object> or <monster> or <spell>
X                  or this room to Disowned
X-  531,  531
XDescription:  Creates a new monster with name <monster>
X-  709
X              Charset             Show name of used character set
X-  782,  785
X              Public room
X              Public <object>
X              Public object <object>
X              Public <monster>
X              Public monster <monster>
X              Public <spell>
X              public spell <spell>
X/
$ CALL UNPACK MONSTER_HELP.DIF;1 170483440
$ create 'f'
X-    1,    1
X! Monster initialization file    (c) Kari Hurtta
X-   20,   20
XREBUILD_OK: true
X-   25,   26
Xroot:    DATABASE_:
Xcoderoot:DATABASE_CODE_: ! mdl database
X-   50,   50
XSorcerer,           70000,       256,      100,      80,      20,    nohidde
Vn
X-   74,   74
X! Eli suomeksi:
X! Monster on suljettu arkisin 09-17.
X
X!Playtime: ++++++++++++++++++++++++   ! Miten niin suljettu ?
X!                                       onpa taas suljettu.
X-   78
X
X
X! default chartable is Multinational
XCHARTABLE:  ! This modifies default chartable - one character per line
XEND OF CHARTABLE
X
X! Time of between database polling in VMS delta-time format
Xdatabase_poltime: 0 ::1          !  One second
X
X! Message what is written when playtime: -entry closes Monster
XCLOSED MESSAGE:
XWelcome to the game Monster!
X
XBut what now?
X
XGoodgulf the Grey appears in a puff of orange smoke!
XHe is very angry...
X
X"What are you doing here? The Dungeon is now closed!"
X
XHe waves his Iron Staff and yells "Begone!"
X
XYou disappear in a burst of multicolored light...
X
XOn wall you see announcement:
X
X**********************************************************************
X*                                                                    *
X*                    Dungeon is closed on weekdays                   *
X*                         between 09.00-17.00                        *
X*                                                                    *
X**********************************************************************
X
XEND OF MESSAGE
X
Xmdl_buffers: 20
Xallow_dcl_access: true
X/
$ CALL UNPACK MONSTER_INIT.DIF;1 1292657895
$ create 'f'
X-    6,    6
X$ scrd = F$PARSE("SYS$SCRATCH:",,,,"SYNTAX_ONLY") - ".;"
X$`20
X-   11,   12
X$ CALL SUBDIR_NAME 'scrd' MONSTER_106_WORK def_work
X$ work_directory == ""
X$ CALL ASK_DIR work_directory "Give work directory for compilation" 'def_wor
Vk'
X-   48,   50
X$ ! IF option .ne. 4 THEN CALL CHECK_FILE 'source_directory'ILMOITUS.TXT
X$ CALL CHECK_FILE 'source_directory'CLD.PROTO
X$ IF option .ne. 4 THEN CALL CHECK_FILE 'source_directory'INIT.PROTO
X$ IF option .eq. 4 THEN CALL CHECK_FILE 'source_directory'INIT.APPEND
X-   77,   82
X$ !IF option .ne. 4`20
X$ !  THEN
X$ !  COPY/LOG 'source_directory'ILMOITUS.TXT 'DBDIR'
X$ !  IF .not. $SEVERITY THEN CALL FATAL "Copy failed"
X$ !ENDIF
X$ SET FILE/PROTECTION=(W:R)/LOG 'DBDIR'MONSTER.HELP
X-   99
X$ IF option .eq. 4 THEN CALL EDIT_INIT
X-  120
X$ IF F$TRNLMN("APPEND") .nes. "" THEN CLOSE APPEND
X$ IF F$TRNLMN("INSFILE") .nes. "" THEN CLOSE INSFILE
X-  150
X$ ELSE
X$   CALL DIRNAME 'full' dname
X$   SET FILE/PROTECTION=(W:E)/LOG 'dname
X$   IF .not. $SEVERITY THEN CALL FATAL "Set file/protection failed"
X-  163,  163
X$ SUBDIR_NAME: SUBROUTINE
X-  168,  175
X-  180,  180
X$ CREATE_SUBDIR: SUBROUTINE
X$ CALL SUBDIR_NAME 'p1' 'p2' subdir_
X$ dir = subdir_
X$ IF F$PARSE(dir) .eqs. ""`20
X$ THEN`20
X$   CREATE/DIRECTORY/LOG/PROTECTION=(S:RWE,O:RWE,G:E,W:E) 'dir
X$   IF .not. $SEVERITY THEN CALL FATAL "Create/directory failed"
X$ ELSE
X$   CALL DIRNAME 'dir' dname
X$   SET FILE/PROTECTION=(W:E)/LOG 'dname
X$   IF .not. $SEVERITY THEN CALL FATAL "Set file/protection failed"
X$ ENDIF
X$ CALL DIRNAME 'dir' dirname
X$ SET FILE/ACL=(IDENTIFIER='F$USER(),access=r+w+e+d+c)/LOG 'dirname
X$ IF .not. $SEVERITY THEN CALL FATAL "Set file/acl failed"
X$ SET FILE/ACL=(IDENTIFIER='F$USER(),OPTIONS=DEFAULT,access=r+w+e+d+c)/LOG '
Vdirname
X$ IF .not. $SEVERITY THEN CALL FATAL "Set file/acl failed"
X$ SET FILE/ACL=(DEFAULT_PROTECTION,SYSTEM:RWED,OWNER:RWED,GROUP,WORLD:RW)/LO
VG 'dirname
X$ IF .not. $SEVERITY THEN CALL FATAL "Set file/acl failed"
X$ 'p3 == dir
X$ EXIT
X$ ENDSUBROUTINE
X$!
X$ DIRNAME: SUBROUTINE
X$ node = F$PARSE(p1,,,"NODE","SYNTAX_ONLY")     ! Usually empty
X-  201,  203
X$    dirname = node + disk + build + tail + name + ".DIR"
X$ ELSE
X$    dirname = node + disk + "<000000>" + name + ".DIR"
X-  243,  243
X$!
X$ APPEND_FILE: SUBROUTINE
X$ COPY/LOG 'p1 'p2
X$ IF .not. $SEVERITY THEN CALL FATAL "Backup copy failed"
X$ OPEN/ERROR=error21 from 'p1
X$ OPEN/ERROR=error22 append 'p3
X$ WRITE SYS$OUTPUT "Creating new ''P1'"
X$ OPEN/WRITE/ERROR=error23 to 'p1
X$again21:
X$ READ/END_OF_FILE=out21 from line
X$ temp=F$EDIT(line,"TRIM,UNCOMMENT")
X$ IF temp .eqs. "" THEN GOTO none21
X$ IF F$LOCATE(p4,temp) .eq. 0 THEN GOTO found21
X$none21:
X$ WRITE to line
X$ GOTO again21
X$found21:
X$ WRITE to line
X$again22:
X$ READ/END_OF_FILE=out22 append line
X$ IF F$LOCATE("%INSERT ",line) .eq. 0 .and. line .nes. ""
X$ THEN
X$    inssym = f$extract(8,F$length(line)-8,line)
X$    file_ = ins_'inssym
X$    OPEN/ERROR=error24 insfile 'file_
X$    WRITE SYS$OUTPUT "Inserting ''file_' to ''P1'"
X$again24:
X$    READ/END_OF_FILE=out24 insfile line
X$    WRITE to line
X$    GOTO again24
X$out24:
X$    CLOSE insfile
X$again25:                                   ! Skip default text
X$    READ/END_OF_FILE=out23 append line
X$    IF F$LOCATE("%ENDINSERT",line) .ne. 0 .or. line .eqs. "" THEN GOTO agai
Vn25
X$    goto out23
X$error24:
X$    WRITE SYS$OUTPUT "Can't open ''file_' - using default text for ''P1'"
X$again23:
X$    READ/END_OF_FILE=out23 append line
X$    IF F$LOCATE("%ENDINSERT",line) .eq. 0 .and. line .nes. "" THEN GOTO out
V23
X$    WRITE to line
X$    GOTO again23
X$out23:
X$ line=""                                                      ! Buggy
X$ ENDIF
X$ write to line
X$ GOTO again22
X$out22:
X$ CLOSE from
X$ CLOSE append
X$ CLOSE to
X$ EXIT`20
X$out21:
X$ CLOSE from
X$ CLOSE append
X$ CLOSE to
X$ CALL FATAL "Label ''p4' don't found from ''p1'"
X$ EXIT
X$error21:
X$ CALL FATAL "Opening of ''p1' failed"
X$ EXIT
X$error22:
X$ CLOSE from
X$ CALL FATAL "Opening of ''p3' failed"
X$ EXIT
X$error23:
X$ CLOSE from
X$ CLOSE append
X$ CALL FATAL "Creating of new ''p1' failed"
X$ EXIT
X$ ENDSUBROUTINE
X$!
X-  247,  247
X$ IF P3 .nes. "" THEN WRITE SYS$OUTPUT "Default: ",P3
X-  386
X$ WRITE SYS$OUTPUT "       and edit MONSTER.INIT"
X-  403
X$!
X$ EDIT_INIT: SUBROUTINE
X$ ins_message :== "''DBDIR'ILMOITUS.TXT"
X$ CALL APPEND_FILE 'image_directory'MONSTER.INIT -
X  'image_directory'MONSTER.INIT_OLD 'source_directory'INIT.APPEND -
X  "min_accept:"
X$ EXIT
X$ ENDSUBROUTINE
X/
$ CALL UNPACK MONSTER_INSTALL.DIF;1 1114963065
$ create 'f'
X-   23
X    9.07.1992 `7C         `7C Fixed some help text
X   12.08.1992 `7C         `7C Dummy player_here removed (now defined in modu
Vle
X              `7C         `7C   PARSER)
X   24.10.1992 `7C`09`09`7C fix_repair_location uudelleenkirjoitettu
X`09      `7C`09`09`7C fixed dummy gethere !!!!!!!!!!!!!!!!!!!!!!!!!!
X-   33,   40
Xprocedure checkevents(silent: boolean := false);
X-   44,   50
X`7B ---------- `7D
X
X`5Bglobal`5D
Xprocedure gethere(n: integer);
Xbegin
X    getroom(n);
X    freeroom;
Xend;
X-  321,  322
X`09writeln('Use the SYSTEM command in MONSTER to view and add capacity to th
Ve database');
X-  334,  334
X   writeln ('E        Leave /fix.');
X-  353,  353
X   writeln ('Q        Leave /fix');
X-  360,  360
X   writeln ('Use SYSTEM command in MONSTER to add database capacity.');
X-  704,  704
X`09writeln ('Creating of Great Hall FAILED');
X-  716,  716
X`09writeln ('Creating of Void FAILED');
X-  729,  729
X`09writeln ('Creating of Pit of Fire FAILED');
X- 1149, 1151
X    ex_indx,sleep_indx,room_indx,header_indx: indexrec;
X    locs: intrec;
X    temp: namrec;
X    c: char;
X    del_it: boolean;
X- 1173, 1173
X    for id := 1 to ex_indx.top do if not ex_indx.free`5Bid`5D then begin
X- 1178, 1219
X`09    del_it := false;
X
X`09    readv(user.idents`5Bid`5D,c,code,error := continue);`20
X`09    if statusv <> 0 then begin
X`09`09writeln('Bad monster username record #',id:1);
X`09`09writeln('    player name: ',pers.idents`5Bid`5D);
X`09`09writeln('    user name:   ',user.idents`5Bid`5D);
X`09`09del_it := true;
X`09`09code := 0;
X`09    end else begin
X`09`09found_counter := 0;
X`09`09true_loc := 0;
X`09`09loc := locs.int`5Bid`5D;
X
X`09`09for room := 1 to room_indx.top do if not room_indx.free`5Broom`5D`20
X`09`09    then begin
X`09`09    getroom(room); `7B locking `7D
X`09`09    for slot := 1 to maxpeople do begin
X`09`09`09if (here.people`5Bslot`5D.parm = code) and`20
X`09`09`09    (here.people`5Bslot`5D.kind = P_MONSTER) then begin
X`09`09`09    found_counter := found_counter +1;
X`09`09`09    true_loc := room;
X`09`09`09    if here.people`5Bslot`5D.username <>`20
X`09`09`09`09user.idents`5Bid`5D then begin`20
X`09`09`09`09writeln(pers.idents`5Bid`5D,
X`09`09`09`09    ': Bad username field in room ',
X`09`09`09`09    here.nicename,
X`09`09`09`09    ' (slot #',slot:1,') - fixed.');
X`09`09`09`09here.people`5Bslot`5D.username := user.idents`5Bid`5D;
X`09`09`09    end; `7B if `7D
X`09`09`09end; `7B if `7D
X`09`09    end; `7B slot `7D
X`09`09    putroom;       `7B storing `7D
X`09`09end; `7B room -loop `7D
X`09`09if (found_counter = 1) and (true_loc = loc) then
X`09`09    writeln(pers.idents`5Bid`5D,': ok')
X`09`09else if found_counter = 0 then begin
X`09`09    writeln(pers.idents`5Bid`5D,': not found from any room.');
X`09`09    del_it := true;
X`09`09end else if (found_counter = 1) and ( loc <> true_loc) then begin
X`09`09    writeln(pers.idents`5Bid`5D,': found from wrong location - updated
V.');
X`09`09    locs.int`5Bid`5D := true_loc;
X`09`09end else if (found_counter > 1) then begin
X`09`09    writeln(pers.idents`5Bid`5D,': duplicated monster - deleted.');
X`09`09end else writeln('%',pers.idents`5Bid`5D,': bad software error !!');
X`09    end; `7B if statusv <> 0 (parsing monster username) `7D
X`09    if del_it and (code = 0) then`20
X`09`09writeln(pers.idents`5Bid`5D,'% can''t delete it !')
X`09    else if del_it then begin`20
X`09`09writeln(pers.idents`5Bid`5D,'% deleting.');
X`09`09for room := 1 to room_indx.top do`20
X`09`09    if not room_indx.free`5Broom`5D then begin
X`09`09    getroom(room); `7B locking `7D
X`09`09    for slot := 1 to maxpeople do begin
X`09`09`09if (here.people`5Bslot`5D.parm = code) and`20
X`09`09`09(here.people`5Bslot`5D.kind = P_MONSTER) then begin
X- 1223, 1233
X`09`09`09    writeln(pers.idents`5Bid`5D,
X`09`09`09`09'% deleted from room ',here.nicename,
X`09`09`09`09' (slot #',slot:1,')');
X`09`09`09end; `7B if `7D
X`09`09    end; `7B for slot `7D
X`09`09    putroom;`09    `7B unlocking `7D
X`09`09end; `7B end of room loop `7D
X`09`09if not header_indx.free`5Bcode`5D then begin
X`09`09    header_indx.free`5Bcode`5D := true;
X`09`09    header_indx.inuse := sleep_indx.inuse - 1;`20
X`09`09    delete_program(code);
X`09`09    writeln(pers.idents`5Bid`5D,'% MDL code #',code:1,' deleted.');
X`09`09end else
X`09`09    writeln(pers.idents`5Bid`5D,
X`09`09`09'% MDL code #',code:1,' was already deleted !');
X
X- 1246, 1247
X`09    end; `7B del_it `7D
X`09end; `7B if user.idents`5Bid`5D `7D
X    end; `7B for id `7D
X- 1322, 1322
X`09    if old_value <> table`5Bobject`5D then`20
X`09`09writeln(obj.oname,' fixed: ',old_value:1,' -> ',
X`09`09table`5Bobject`5D:1);
X/
$ CALL UNPACK MONSTER_REBUILD.DIF;1 137326107
$ create 'f'
X-   20,   20
X 11.6.1990    `7C Hurtta  `7C  read_global_flag
X 12.8.1992    `7C         `7C  Dummy player_here removed (now defined in mod
Vule`20
X              `7C         `7C      PARSER
X-   25,   29
X
X`7B DUMMY for linker `7D
X`5Bglobal`5D
Xprocedure gethere(n: integer := 0);
Xbegin
X-   34,   34
Xprocedure checkevents(silent: boolean := false);
X-   38,   43
X/
$ CALL UNPACK MONSTER_WHO.DIF;1 2132369292
$ create 'f'
X- Jorma Korkiakoski translated Finnish ducumentation of MDL to English
X  (This includes only MDL functions of version 1.05). And fix (part of)
X  monster_e.hlp. (Thanks !)
X- New commands:
X`09show charset
X- New command forms:
X`09claim room
X`09claim object `7Bobject`7D
X`09claim monster `7Bmonster`7D
X`09claim spell `7Bspell`7D
X`09disown room
X`09disown object `7Bobject`7D
X`09disown monster `7Bmonster`7D
X`09disown spell `7Bspell`7D
X`09public room
X`09public object `7Bobject`7D
X`09public monster `7Bmonster`7D
X`09public spell `7Bspell`7D
X
X`09If `7Borject`7D, `7Bmonster`7D or `7Bspell`7D argument is missing, it is
V prompted.
X`09If it is ambiquous, list for possible matches are given (selection
X`09`09by number or cursor keys).
X- New MDL-functions:
X`09boolean and (arg1,arg2,...)
X`09boolean or (arg1,arg2,...)
X`09or else (arg1,arg2,...)
X`09and then (arg1,arg2,...)
X- Changed MDL-functions:
X`09get global flag(arg)
X`09strip (arg)
X- Default character set is now Dec Multinational
X- If argument of command is ambiquos, monster gives list of possible
X  matches and player can select correct one by number or by cursor keys.
X  (This not apply to all commands or all forms of commands.)
X  This is available (at least) in following commands:
X`09claim `5Bobject`7Cmonster`7Cspell`5D `7Bsomething`7D
X`09disown `5Bobject`7Cmonster`7Cspell`5D `7Bsomething`7D
X`09public `5Bobject`7Cmonster`7Cspell`5D `7Bsomething`7D
X`09custom `5Bobject`7Cmonster`5D `7Bsomething`7D
X`09get `7Bobejct`7D
X`09drop `7Bobject`7D
X`09delete `5Broom`7Cobject`7Cmonster`5D `7Bsomething`7D
X`09scan `7Bobject`7D
X`09destroy `7Bobject`7D
X`09duplicate `7Bobject`7D
X`09erase `7Bmonster`7D
X`09reset `7Bobject`7D
X`09wear `7Bobject`7D
X`09wield `7Bobject`7D
X`09set `7Bsomething`7D
X- New tables in MONSTER.INIT:
X`09CHARTABLE:   (can be empty)
X`09`7B charset ....
X`09  char ... `7D`09`09`09This table also effects to parsing of`20
X`09END OF CHARTABLE`09`09MDL and MDL function strip(...).
X
X`09CLOSED MESSAGE:`09`09`09This is same as ILMOITUS.TXT file
X`09`7Bsome text`7D`09`09`09`09in previously.
X`09END OF MESSAGE
X- New fields in MONSTER.INIT:`09`09(this is value what MONSTER_INSTALL.COM
X`09`09`09`09`09 gives)
X`09database_poltime:`09`09default "0 ::1"
X`09mdl_buffers: `09`09`09default 20
X`09dcl_access_allowed:`09`09default yes
X- Format of dump of MONSTER/DUMP is also changed little (as usual).
X`09MONSTER/REBUILD (of course) reads all previous formats.
X- MDL parser now tires check if variable is used before it defination
X`09in compile time (not easy task, because variables are defined`20
X`09dynamically).
X- MDL code loading from terminal is now handled correctly (no block
X`09Monster's event loop). So you can use "g tt:" command to
X`09enter MDL -code.
X- MDL interpreter should now be little faster (and use memory
X`09little more sensible - however number of mdl -buffers
X`09is now 20 by default instead of 5).
X- BUG fixes:
X`09- recovery routines in MONSTER/FIX destroys intergity
X`09  of database in version 1.05. Now fixed.
X`09- MONSTER/DUMP - MONSTER/REBUILD now not destroy end
X`09  of descriptions lines if these are near to 80 characters.
X        - MONSTER/REBUILD don't now crashed so easily when it
X`09  detects some errors in dumpfile.
X`09- Some other bug fixes.
$ CALL UNPACK NEW.TXT;1 1848652340
$ create 'f'
X-    1,    1
X`5Benvironment,inherit ('Global','Database','Guts') `5D
X-  112,  114
X`09myslot: `5Bglobal`5D integer := 1;`09`7B here.people`5Bmyslot`5D... is th
Vis player `7D
X
X-  218,  219
X-  230,  233
X`09`09sprime := '';
X`09`09for i := 1 to length(s) do
X`09`09`09case chartable`5Bs`5Bi`5D`5D.kind of
X`09`09`09    ct_none:    ;`09`7B DISCARD `7D
X`09`09`09    otherwise   sprime := sprime +`20
X`09`09`09`09    chartable`5Bs`5Bi`5D`5D.lcase;
X`09`09`09end; `7B case `7D
X-  241,  247
X   case chartable`5Ba`5D.kind of
X`09ct_space, ct_none:`09classify := space;
X`09otherwise case a of
X`09    '"':`09`09classify := string_c;
X`09    '(',')',',','-':`09classify := bracket;            `20
X`09    '!':`09`09classify := comment;
X`09    otherwise`09`09classify := letter;
X`09end; `7B case a `7D
X   end; `7B case chartable `7D
X-  258,  263
X`09if chartable`5Binbuf `5B1`5D`5D.kind = ct_none then  `7B DISCARD `7D
X`09else if chartable`5Binbuf `5B1`5D`5D.kind <> ct_space then begin
X`09    bf := bf + inbuf `5B1`5D;
X`09    space_f := false;
X`09end else if not space_f then begin
X`09    bf := bf + ' ';
X`09    space_f := true;
X`09end;
X`09inbuf := substr(inbuf,2,length(inbuf)-1)
X    end;     `20
X    if bf > '' then if chartable`5Bbf`5Blength(bf)`5D`5D.kind = ct_space the
Vn
X-  273
X    result,result2: shortstring;
X-  277,  277
X    if x > length (main) then result := ''
X-  285,  289
X`09result := substr(main,start,x-start);
X`09x := x +1
X    end;
X    result2 := '';
X    for i := 1 to length(result) do
X`09if chartable`5Bresult`5Bi`5D`5D.kind <> ct_none then`20
X`09    result2 := result2 + result`5Bi`5D;
X    cut_atom := result;
Xend; `7B cut_atom `7D
X
X`5Bglobal`5D
Xfunction obj_here(n: integer; nohidden: boolean := false): boolean;
Xvar
X`09i: integer;
X`09found: boolean;
X
Xbegin
X    i := 1;
X    found := false;
X    while (i <= maxobjs) and (not found) do begin
X`09if here.objs`5Bi`5D = n then begin
X`09    if not nohidden then found := true
X`09    else if here.objhide`5Bi`5D = 0 then found := true
X`09    else i := i + 1;
X`09end else i := i + 1;
X    end;
X    obj_here := found;
Xend; `7B obj_here `7D
X
X`5Bglobal`5D   `20
Xfunction player_here(id: integer; var slot: integer): boolean;
X    `7B suppose that gethere and getpers have made `7D
Xvar i: integer;
X    name: shortstring;
Xbegin
X    slot := 0;
X    name := lowcase(pers.idents`5Bid`5D);
X    for i := 1 to maxpeople do
X`09if here.people`5Bi`5D.kind > 0 then
X`09`09if lowcase(here.people`5Bi`5D.name) = name then slot := i;
X    player_here := slot > 0;
Xend; `7B player_here `7D
X
X`7B returns true if object N is being held by the player (id slot)`7D
X
Xfunction obj_hold(n: integer; slot: integer := 0): boolean;
Xvar
X`09i: integer;
X`09found: boolean;
X
Xbegin
X`09if slot = 0 then slot := myslot;
X`09
X`09if n = 0 then
X`09`09obj_hold := false
X`09else begin
X`09`09i := 1;
X`09`09found := false;
X`09`09while (i <= maxhold) and (not found) do begin
X`09`09`09if here.people`5Bslot`5D.holding`5Bi`5D = n then
X`09`09`09`09found := true
X`09`09`09else
X`09`09`09`09i := i + 1;
X`09`09end;
X`09`09obj_hold := found;
X`09end;
Xend; `7B obj_hold `7D
X
Xtype tabletype = array `5B 1.. maxroom`5D of boolean;
X     `7B used in lookup_general and in meta_scan `7D
X
Xfunction solve_ambiquous(rec: namrec; indx: indexrec;
X`09`09`09 table: tabletype; s: string;
X`09`09`09 var result: integer): boolean;
Xlabel quit_label;
X
X    procedure leave;
X    begin
X`09writeln('QUIT - no selection');
X`09solve_ambiquous := false;
X`09goto quit_label;
X    end;
X
Xvar mapping : array `5B 1 .. maxroom `5D of 1 .. maxroom;
X    count,i,current: integer;
X    line: string;
X    ok: boolean;`20
Xbegin
X    writeln('"',s,'" is ambiquous - Refer you one of following?');
X    count := 0;
X    for i := 1 to indx.top do`20
X`09if table`5Bi`5D then begin
X`09`09count := count +1;
X`09`09writeln(' ',count:3,' ',rec.idents`5Bi`5D);
X`09`09mapping`5Bcount`5D := i;
X`09end;
X    current := 0;
X    ok := false;
X    writeln('Give number (0 for nothing) or use cursor keys (UP and DOWN) fo
Vr selection.');
X    repeat
X`09if current = 0 then line := '  0'
X`09else writev(line,current:3,' ; ',rec.idents`5Bmapping`5Bcurrent`5D`5D);
X`09grab_line('selection: ',line,edit_mode := true,eof_handler := leave);
X`09if grab_next < 0 then begin
X`09    current := current -1;
X`09    if current < 0 then current := count;
X`09end else if grab_next > 0 then begin
X`09    current := current +1;
X`09    if current > count then current := 0;
X`09end else begin
X`09    readv(line,i,error:=continue);
X`09    if statusv = 0 then`20
X`09`09if (i >= 0) or (i <= count) then begin
X`09`09    current := i;
X`09`09    ok := true;
X`09    end;
X`09end;
X    until ok;
X
X    if current = 0 then solve_ambiquous := false
X    else begin
X`09result := mapping`5Bcurrent`5D;
X`09solve_ambiquous := true;
X    end;
X
X    quit_label:
Xend; `7B solve_ambiquous `7D
X
Xfunction solve_ambiquous_list (list : array `5B lower .. upper : integer `5D
X`09`09`09`09    of shortstring;
X                               table: tabletype;
X`09`09`09       s: string; var result: integer): boolean;
Xlabel quit_label;
X
X    procedure leave;
X    begin
X`09writeln('QUIT - no selection');
X`09solve_ambiquous_list := false;
X`09goto quit_label;
X    end;
X
Xvar mapping : array `5B 1 .. maxroom `5D of 1 .. maxroom;
X    count,i,current: integer;
X    line: string;
X    ok: boolean;`20
X
Xbegin
X    writeln('"',s,'" is ambiquous - Refer you one of following?');
X    count := 0;
X
X    for i := lower to upper do if table`5Bi`5D then begin
X`09 count := count +1;
X`09 writeln(' ',count:3,' ',list`5Bi`5D);
X`09 mapping`5Bcount`5D := i;
X    end;
X
X    current := 0;
X    ok := false;
X    writeln('Give number (0 for nothing) or use cursor keys (UP and DOWN) fo
Vr selection.');
X    repeat
X`09if current = 0 then line := '  0'
X`09else writev(line,current:3,' ; ',list`5Bmapping`5Bcurrent`5D`5D);
X`09grab_line('selection: ',line,edit_mode := true,eof_handler := leave);
X`09if grab_next < 0 then begin
X`09    current := current -1;
X`09    if current < 0 then current := count;
X`09end else if grab_next > 0 then begin
X`09    current := current +1;
X`09    if current > count then current := 0;
X`09end else begin
X`09    readv(line,i,error:=continue);
X`09    if statusv = 0 then`20
X`09`09if (i >= 0) or (i <= count) then begin
X`09`09    current := i;
X`09`09    ok := true;
X`09    end;
X`09end;
X    until ok;
X
X    if current = 0 then solve_ambiquous_list := false
X    else begin
X`09result := mapping`5Bcurrent`5D;
X`09solve_ambiquous_list := true;
X    end;
X
X    quit_label:
Xend; `7B solve_ambiquous_list `7D
X`09`09`09      `20
X-  295,  296
X    table: tabletype;
Xbegin
X    if debug then writeln('lookup_general: ',s);   `20
X    for i := 1 to maxroom do table`5Bi`5D := false;
X
X-  307,  309
X`09    else if (index(temp,s) = 1) or (index(temp,' '+s) > 1) then begin
X`09`09maybe := maybe + 1;
X`09`09poss := i;
X`09`09table`5Bi`5D := true;
X-  322,  328
X`09    lookup_general := solve_ambiquous(rec,indx,table,s,id);
X`09end else lookup_general := false;
X-  380
X
X`5Bglobal`5D`20
Xfunction parse_pers(var pnum: integer;s: string; help: boolean := false):`20
X    boolean;
Xvar
X`09i,poss,maybe,num: integer;
X`09pname: string;
X
X`09names: array `5B 1 .. maxpeople `5D of shortstring;
X`09table: tabletype;
Xbegin
X`09gethere;
X`09s := lowcase(s);
X`09i := 1;
X`09maybe := 0;
X`09num := 0;
X`09for i := 1 to maxpeople do begin
X`09`09table`5Bi`5D := false;
X
X`09`09if (here.people`5Bi`5D.kind > 0) and`20
X`09`09    (here.people`5Bi`5D.hiding = 0) then begin
X`09`09`09pname := lowcase(here.people`5Bi`5D.name);
X`09`09`09names `5B i `5D := here.people`5Bi`5D.name;
X
X`09`09`09if s = pname then
X`09`09`09`09num := i
X`09`09`09else if (index(pname,s) = 1) or`20
X`09`09`09        (index(pname,' '+s) > 1) then begin
X`09`09`09`09table`5Bi`5D := true;
X`09`09`09`09maybe := maybe + 1;
X`09`09`09`09poss := i;
X`09`09`09end;
X`09`09end;
X`09end;
X`09if num <> 0 then begin
X`09`09pnum := num;
X`09`09parse_pers := true;
X`09end else if maybe = 1 then begin
X`09`09pnum := poss;
X`09`09parse_pers := true;
X`09end else if maybe > 1 then begin
X`09`09pnum := 0;
X`09`09if help then parse_pers :=
X`09`09    solve_ambiquous_list(names,table,s,pnum)
X`09`09else parse_pers := false;
X`09end else begin
X`09`09pnum := 0;
X`09`09parse_pers := false;
X`09end;
Xend; `7B parse_pers `7D
X
X`7B similar to lookup_obj, but only returns true if the object is in
X  this room or is being held by the player `7D
X`7B and s may be in the middle of the objact name -- Leino@finuh `7D
X
Xfunction parse_obj (var pnum: integer;
X`09`09`09s: string; help: boolean := false): boolean;
Xvar
X`09i,poss,maybe: integer;
X
X`09table: tabletype;
X`09temp: shortstring;
X
Xbegin
X`09getobjnam;
X`09freeobjnam;
X`09getindex(I_OBJECT);
X`09freeindex;
X
X        for i := 1 to maxroom do table`5Bi`5D := false;
X
X`09s := lowcase(s);
X`09pnum := 0;
X`09maybe := 0;
X`09for i := 1 to indx.top do begin
X`09`09if not(indx.free`5Bi`5D) then begin
X`09`09`09temp := lowcase(objnam.idents`5Bi`5D);
X`09`09`09if s =  temp then begin
X`09`09`09`09if obj_here(i) or obj_hold(i) then
X`09`09`09`09    pnum := i
X`09`09`09end else if ((index(temp,s) = 1) or
X`09`09`09`09(index(temp,' '+s) > 0)) then begin
X`09`09`09    if (obj_here(i) or obj_hold(i)) then begin
X`09`09`09`09maybe := maybe + 1;
X`09`09`09`09poss := i;
X`09`09`09`09table`5Bi`5D := true;
X`09`09`09    end;
X`09`09`09end;
X`09`09end;
X`09end;
X`09if pnum <> 0 then begin
X`09`09parse_obj := true;
X`09end else if maybe = 1 then begin
X`09`09pnum := poss;
X`09`09parse_obj := true;
X`09end else if maybe > 1 then begin
X`09   if help then parse_obj := solve_ambiquous(objnam,indx,table,s,pnum)
X`09   else parse_obj := false;
X`09end else begin
X`09`09parse_obj := false;
X`09end;
Xend; `7B parse_obj `7D
X
X
X-  390,  390
X-  404
X`09temp: shortstring;
X-  411,  412
X`09    temp := clean_spaces(lowcase(name.idents`5Bi`5D));
X`09    if ((index(temp,atom) = 1) or`20
X`09`09((index(temp,' '+atom) > 0)`20
X-  423,  424
X-  443,  444
X`09    if silent then error := true
X`09    else if error then writeln('"',atom,'" is ambiquous.')
X`09    else error := not solve_ambiquous(name,indx,temp,atom,exact);
X-  555
X`09table: tabletype;
X`09temp: shortstring;
X-  562,  567
X
X`09for i := 1 to maxroom do table`5Bi`5D := false;
X
X`09for i := 1 to maxexit do begin
X`09`09temp := lowcase(direct`5Bi`5D);
X`09`09if s = temp then num := i
X`09`09else if index(temp,s) = 1 then begin
X`09`09`09maybe := maybe + 1;
X`09`09`09poss := i;
X`09`09`09table`5Bi`5D := true;
X-  579,  585
X`09    if help then lookup_dir := solve_ambiquous_list (direct,table,s,dir)
X`09    else lookup_dir := false;
X-  596,  598
X`09table: tabletype;
X`09temp: shortstring;
Xbegin
X    if debug then writeln('lookup_show: ',s);
X
X`09for i := 1 to maxroom do table`5Bi`5D := false;
X
X-  604,  608
X`09`09temp := lowcase(show`5Bi`5D);
X`09`09if s = temp then num := i
X`09`09else if index(temp,s) = 1 then begin
X`09`09`09maybe := maybe + 1;
X`09`09`09poss := i;
X`09`09`09table`5Bi`5D := true;
X-  620,  626
X`09    if help then lookup_show := solve_ambiquous_list(show,table,s,n)
X`09    else lookup_show := false;
X-  637,  637
X`09table: tabletype;
X`09temp: shortstring;
X-  644,  649
X
X`09for i := 1 to maxroom do table`5Bi`5D := false;
X
X`09for i := 1 to numset do begin
X`09`09temp := lowcase(setkey`5Bi`5D);
X`09`09if s = temp then num := i
X`09`09else if index(temp,s) = 1 then begin
X`09`09`09maybe := maybe + 1;
X`09`09`09poss := i;
X`09`09`09table`5Bi`5D := true;
X-  660,  666
X`09    if help then lookup_set := solve_ambiquous_list(setkey,table,s,n)
X`09    else lookup_set := false;
X-  681,  681
X`09`09if lowcase(nam.idents`5Bn`5D) = lowcase(s) then
X-  693,  701
X`09ident_cache: `5Bstatic`5D integer := -1;
X`09ident_last: `5Bstatic`5D string := '';
X`09cache_ok: boolean;
Xbegin
X`09`7B because INT_* routines calls so many time, we
X`09  build one item deep cache for that routine.
X`09  Cache supposes that new monster/player isn't`20
X`09  get same name as what was asked in last time or
X`09  name isn't changed.`20
X
X`09  Chance detect only if player/monster is deleted.
X`09  I think that, this is enough.
X`09`7D
X
X`09cache_ok := false;
X`09if (ident_last = s) and (ident_cache > 0) then begin
X`09    getindex(I_PLAYER);
X`09`09if ident_cache < indx.top then
X`09`09    if not indx.free`5Bident_cache`5D then cache_ok := true
X`09`09    else ident_cache := -1;
X`09    freeindex;
X`09end;
X`09`09
X`09if cache_ok then begin
X`09    n := ident_cache;
X`09    exact_pers := true;
X`09end else if lookup_pers(n,s) then begin
X`09`09if lowcase(pers.idents`5Bn`5D) = lowcase(s) then begin
X`09`09    ident_cache := n;
X`09`09    ident_last := s;
X`09`09    exact_pers := true
X`09`09end else begin
X`09`09    ident_cache := -1;
X`09`09    exact_pers := false;
X`09`09end;
X`09end else begin
X`09    ident_cache := -1;
X`09    exact_pers := false;
X`09end;
X-  726,  726
X`09`09if lowcase(objnam.idents`5Bn`5D) = lowcase(s) then
X-  739,  739
X`09names: array `5B 1 .. maxclass `5D of shortstring;
X`09table: tabletype;
X`09temp: shortstring;
X-  747,  751
X`09`09table`5Bi`5D := false;
X`09`09names`5Bi`5D := classtable`5Bi`5D.name;
X`09`09temp := lowcase(classtable`5Bi`5D.name);
X`09`09if s = temp then num := i
X`09`09else if index(temp,s) = 1 then begin
X`09`09`09maybe := maybe + 1;
X`09`09`09poss := i;
X`09`09`09table`5Bi`5D := true;
X-  763,  770
X`09    id := '<error>';
X`09    lookup_class := false;
X`09    if help then begin
X`09`09if solve_ambiquous_list(names,table,s,num) then begin
X`09`09    id := classtable`5Bnum`5D.id;
X`09`09    lookup_class := true;
X`09`09end;
X`09    end;
X-  782
X`09names: array `5B 1 .. maxpriv `5D of shortstring;
X`09table: tabletype;
X
X-  789
X`09`09table`5Bi`5D := false;
X`09`09names`5Bi`5D := privtable`5Bi`5D.name;
X-  794
X`09`09`09table`5Bi`5D := true;
X-  806,  813
X`09    id := 0;
X`09    lookup_priv := false;
X`09    if help then begin
X`09`09if solve_ambiquous_list(names,table,s,num) then begin
X`09`09    id := privtable`5Bnum`5D.value;
X`09`09    lookup_priv := true;
X`09`09end;
X`09    end;
X-  826
X`09names: array `5B 1 .. maxtype`5D of shortstring;
X`09table: tabletype;
X-  835
X`09`09names`5Bi`5D := name;
X`09`09table`5Bi`5D := false;
X-  840
X`09`09`09table`5Bi`5D := true;
X-  852,  866
X`09`09id := t_none;
X`09`09lookup_type := false;
X`09    if help then begin
X`09`09if solve_ambiquous_list(names,table,s,num) then begin
X`09`09    id := typetable`5Bnum`5D.value;
X`09`09    lookup_type := true;
X`09`09end;
X`09    end;
X-  878
X`09names: array `5B 1 .. maxflag`5D of shortstring;
X`09table: tabletype;
X-  885
X`09`09table`5Bi`5D := false;
X`09`09names`5Bi`5D := flagtable`5Bi`5D.name;
X-  902,  909
X`09    id := 0;
X`09    lookup_flag := false;
X`09    if help then begin
X`09`09if solve_ambiquous_list(names,table,s,num) then begin
X`09`09    id := flagtable`5Bnum`5D.value;
X`09`09    lookup_flag := true;
X`09`09end;
X`09    end;
X/
$ CALL UNPACK PARSER.DIF;1 463208737
$ create 'f'
X-    3
Xconst max_message_lines = 50;
X
X-    8
X    msg: array `5B1 .. max_message_lines`5D of string;
X    msg_count: 0 .. max_message_lines := 0;
X
X    alloc_dcl_access: boolean := true;
X
X-   45,   47
X-   51,   51
X`09if ok then ok := chartable`5Bline`5B1`5D`5D.kind = ct_space;
X`09if ok then line := substr(line,2,length(line)-1);
X    end;
X
X    ok := true;
X    while ok do begin
X`09ok := line > '';
X`09if ok then ok := chartable`5Bline`5Blength(line)`5D`5D.kind = ct_space;
X-   65,   68
X    procedure message(s: string);
X    begin
X`09writeln('%Error in ',path);
X`09writeln('%at line ',counter:1);
X`09writeln('%',current_line);
X`09writeln('%',s);
X`09writeln('%Notify Monster Manager.');
X`09halt;
X    end; `7B message `7D
X
X    function get_line (exact: boolean := false): string;
X    var line: string;
X`09pos,i: integer;
X`09ok,quoted: boolean;
X-   74
X`09`09counter := counter +1;
X`09`09current_line := '';
X-   79,   85
X`09`09
X`09`09if not exact then begin
X`09`09    quoted := false;
X`09`09    pos := 0;
+-+-+-+-+-+-+-+-  END  OF PART 4 +-+-+-+-+-+-+-+-
-- 
- K E H                                      /  El{m{ on monimutkaista
  Kari.Hurtta@Helsinki.FI
