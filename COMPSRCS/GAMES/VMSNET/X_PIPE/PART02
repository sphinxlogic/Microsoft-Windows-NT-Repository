Path: uunet!usc!elroy.jpl.nasa.gov!decwrl!waikato!waikato.ac.nz!cguthrey
From: cguthrey@waikato.ac.nz
Newsgroups: vmsnet.sources.games
Subject: Pipeline for VT320 (part 2/3)
Message-ID: <1993Aug5.030617.18756@waikato.ac.nz>
Date: 5 Aug 93 03:06:17 +1200
Organization: University of Waikato, Hamilton, New Zealand
Lines: 1317
Xref: uunet vmsnet.sources.games:769

-+-+-+-+-+-+-+-+ START OF PART 2 -+-+-+-+-+-+-+-+
X`1B`5B9;38H`1B(0q`1B`5B12;3Hq`1B(B`1B*
X`1B`5B9;37H`1B(0q`1B`5B12;4Hq`1B(B`1B*
X`1B`5B9;36H`1B(0q`1B`5B12;5Hq`1B(B`1B*
X`1B`5B9;35H`1B(0q`1B`5B12;6Hq`1B(B`1B*
X`1B`5B9;34H`1B(0q`1B`5B12;7Hq`1B(B`1B*
X`1B`5B9;33H`1B(0q`1B`5B12;8Hq`1B(B`1B*
X`1B`5B9;32H`1B(0q`1B`5B12;9Hq`1B(B`1B*
X`1B`5B9;31H`1B(0q`1B`5B12;10Hq`1B(B`1B*
X`1B`5B9;29H`1B(0qq`1B(B`1B*
X`1B`5B9;28H`1B(0q`1B`5B12;11Hq`1B(B`1B*
X`1B`5B9;27H`1B(0q`1B`5B12;12Hq`1B(B`1B*
X`1B`5B9;26H`1B(0q`1B`5B12;13Hq`1B(B`1B*
X`1B`5B9;25H`1B(0q`1B`5B12;14Hq`1B(B`1B*
X`1B`5B9;24H`1B(0q`1B`5B12;15Hq`1B(B`1B*
X`1B`5B9;23H`1B(0q`1B`5B12;16Hq`1B(B`1B*
X`1B`5B9;22H`1B(0q`1B`5B12;17Hq`1B(B`1B*
X`1B`5B9;21H`1B(0q`1B`5B12;18Hq`1B(B`1B*
X`1B`5B9;20H`1B(0q`1B`5B12;19Hq`1B(B`1B*
X`1B`5B9;18H`1B(0qq`1B`5B12;20Hq`1B(B`1B*
X`1B`5B9;16H`1B(0qq`1B`5B12;21Hq`1B(B`1B*
X`1B`5B9;13H`1B(0qqq`1B`5B12;22Hq`1B(B`1B*
X`1B`5B9;12H`1B(0q`1B`5B12;23Hq`1B(B`1B*
X`1B`5B9;10H`1B(0qq`1B`5B12;24Hq`1B(B`1B*
X`1B*
X`1B`5B9;40H `1B*
X`1B`5B9;39H `1B*
X`1B*
X`1B`5B9;38H `1B*
X`1B`5B9;37H `1B`5B12;1H `1B*
X`1B`5B9;36H `1B`5B12;2H `1B*
X`1B`5B9;34H  `1B*
X`1B`5B9;33H `1B`5B12;3H `1B*
X`1B`5B9;32H `1B`5B12;4H `1B*
X`1B`5B9;31H `1B`5B12;5H `1B*
X`1B`5B9;30H `1B`5B12;6H `1B*
X`1B`5B9;29H `1B`5B12;7H `1B*
X`1B`5B9;28H `1B*
X`1B`5B9;26H  `1B`5B12;8H `1B*
X`1B`5B9;25H `1B`5B12;9H `1B*
X`1B`5B9;25H`1B(0k`1B`5B12;9Hm`1B(B`1B*
X`1B`5B10;25H`1B(0x`1B`5B11;9Hx`1B(B`1B*
X`1B`5B10;9H`1B(0x`1B`5B11;25Hx`1B(B`1B*
X`1B`5B9;9H`1B(0l`1B`5B12;25Hj`1B(B`1B*
X`1B`5B14;24HChris Guthrey, 1992`1B*
X`1B`5B16;23HUniversity Of Waikato`1B*
X`1B`5B18;27HHamilton, NZ`1B*
X`1B`5B21;8HPress `5BI`5D for instructions, or any other key to begin`1B*
$ CALL UNPACK PIPELINE.INTRO;1 67909674
$ create 'f'
X`5BInherit( 'MISC' )`5D Program Pipeline;
X
X(*************************************************************************`2
V0
X   `20
XPIPELINE.PAS for VMS.
X
XCoded 3 November 92.  Chris Guthrey. University of Waikato, Hamilton,`20
X`09`09                        New Zealand.
X
X  This is not an original idea. The concept of this game is based upon
X  the X-Windows game X-Pipe.`20
X
XThis game was designed for the Waikato University Vax cluster.  There
Xis no guarantee it will work anywhere else.  It should do, as everything
Xis reasonably standard and straight forward, as far as I can tell...
X
XE-Mail: Try: c.guthrey@waikato.ac.nz
X             crg2@waikato.ac.nz
X             cguthrey@waikato.ac.nz
X
X---------------------------------------------------------------------------
X`20
XThe VT320 Soft Character Set file "PIPELINE.VT320_FONT" was created with
X"FED", the Font Editor by MASRICH@ubvms.cc.ubuffalo.edu.  Thanks for`20
Xa great utility MASRICH!
X
XI've copied all the INTERACT Library source that I've used into the`20
XMISC.PAS file, since the INTERACT Library is a bit bulky.  Thanks to`20
XPaul Denize for permission to do this.
X
X***************************************************************************)
X
X(***************************************************************************
X * This is the only terminal type recognized at the moment...   `20
X *)
XCONST
X    game_terminal_type = 'VT320';  `20
X `20
X(* The Font File was create with FED, the Font Editor for VT320s, written
X * by MASRICH@ubvms.cc.ubuffalo.edu.
X *
X * The font file contains a DECDLD sequence to "Down-Line Load a Soft
X *   Character Set" (Refer to your VT320 User Guide for details)
X *
X *  If you want to add more terminal type compatability, create a file
X *  containing a DECDLD sequence for that terminal and call it`20
X *  "PIPELINE.xxxxx_FONT" where xxxxx is the terminal type.
X *
X *   It should not be very difficult to create a VT220 character set`20
X *  definition that is   effectively similar to the VT320 character set.
X *)
XCONST
X    font_filename = 'IMAGE_DIR:PIPELINE.'+game_terminal_type+'_FONT';
X
X(************************************************************************`20
X *
X * Intro screen and instruction files.`20
X *)
XCONST
X    intro_filename = 'PIPELINE.INTRO;';
X    instruct_filename1 = 'PIPELINE.INST1;';
X    instruct_filename2 = 'PIPELINE.INST2;';
X
X    tick_sleep_time = 0.2; (* 1/5th of a second *)
X      (* this is the amount of time the process hibernates on each game
X       * cycle.
X       *)
X
X    display_count_time = 1 / tick_sleep_time;
X      (* this is used to calculate the value displayed while the game is
X       * in play.
X       *)
X
X(***************************************************************************
X * Display Constants
X *`20
X * These are constants for the positioning of various parts of the`20
X * display.`20
X *)
XCONST
X    field_width = 16;        (* The Game field is 16 squares across by   *)
X    field_length = 14;       (*  14 squares down. You should be able to  *)
X    field_topleft_x = 3;     (*  change the size of the playfield simply *)
X    field_topleft_y = 3;     (*  by modifying these values...(!)         *)
X`20
X    queue_display_x = 30;    (* This is the position for the display of  *)
X    queue_display_y = 20;    (* next pieces of pipe that will need to be *)
X                             (* placed on the game field.                *)
X
X    score_label_pos_x = 26;  (* Position for the "SCORE" label *)
X    score_label_pos_y = 2;
X    score_value_pos_x = score_label_pos_x + 7; (* ditto for the Score value
V *)
X
X    level_label_pos_x = 26;  (* The "LEVEL" label ... *)
X    level_label_pos_y = 4;
X    level_value_pos_x = level_label_pos_x + 7; (* and value positions *)
X
X    target_label_pos_x = 25; (* The "TARGET" count. This is the required  *)
X    target_label_pos_y = 6;  (* number of pipe segments that the oil must *)
X    target_value_pos_x = target_label_pos_x + 8;  (* flow through         *)
X
X    time_label_pos_x = 27;   (* Time left... *)
X    time_label_pos_y = 8;
X    time_value_pos_x = time_label_pos_x + 6;
X
X    next_label_pos_x = 26;   (* This points out the next piece in the  *)
X    next_label_pos_y = 10;   (* pieces queue                           *)
X
X(***************************************************************************
X * Character code for user-defined cursor symbol`20
X *
X * When the terminal is switched the Soft Character Set, the special symbols
X * are shown instead of the normal ascii characters
X *)
XCONST
X    cursor_char = 'z';
X
X(***************************************************************************
X * Preview Queue Size
X *
X * The preview queue is a list of pipe-segments that are shown on the size
X * of the screen so that the player knows what sequence the pieces are`20
X * coming up as. `20
X *`20
X ** preview_queue_maxsize   defines the maximum number of objects
X *                          that can be held in the queue data structure.
X *)
XCONST
X    preview_queue_maxsize = 5;
X
X(**************************************************************************
X * TYPE Definitions follow here
X *
X *)
X
X    (* Sides. This expresses the directions in which oil flows.`20
X     *)
XTYPE
X    Sides = ( North, South, East, West );
X
X    (* Side_States.`20
X     *      None = there is no entrance or exit for oil on (this) side of
X     *             the pipe. (The sides are specified as above)
X     *    InOnly = oil may enter from this side, but not exit.
X     *   OutOnly = oil may exit from this side, but not enter.
X     *     InOut = oil may enter or exit from this side of the pipe`20
X     *               (but not both at the same time, of course!)
X     *)
XTYPE
X    Side_States = ( None, InOnly, OutOnly, InOut );
X
X    (* Pipe_States.
X     *  A peice (or segment) of pipe on the game field can be either:
X     *    empty = no oil has reached the pipe
X     *     half = oil has flowed halfway through the pipe
X     *     full = the pipe is completely filled with oil.
X     *)
XTYPE
X    Pipe_states = ( empty, half, full );
X
X    (* Piece_IDs.
X     *
X     * This enumerated type is used for referencing the different types
X     * pieces (ie pipes, reserviors, etc) that are used in the game.`20
X     *)
XTYPE
X    piece_ids = (
X        vertical, horizontal, cross,`20
X        curve_UL, curve_LL, curve_UR, curve_LR,
X        vertical_1way_down, vertical_1way_up,
X        horiz_1way_left, horiz_1way_right,
X        start_valve, end_valve,
X        block, reservior, empty_space );
X
X    (* PQueueType.
X     *  This is used in the queue data structure.`20
X     *)
XTYPE
X    PQueueType = Record
X        head, tail, count, maxsize : Integer;
X        data    : array `5B1..preview_queue_maxsize`5D of Piece_Ids;
X    End;
X
X    (* PlayInfoRecord.
X     *)
XTYPE
X    PlayInfoRecord = Record
X        level,              (* level of difficulty *)
X        score,              (* score *)
X        queue_size,         (* number of pieces in the queue *)
X        crossfill_count,    (* how many cross-pipe have been filled *)
X        target_count,       (* how many pipes have been filled with oil *)
X        target,             (* required # of pipes that need to be filled *)
X        completion_bonus,   (* bonus for completing level *)
X    `09timetillOil,        (* how much time left before oil starts flowing *
V)
X        basetimetillOil,    (* ??? *)
X        oil_flow_speed      (* count-tick delay before the oil moves into th
Ve *)
X                            (*  the next half-segment of pipe.
V                *)
X                        : Integer;
X        move_delay : real;         (* ??? *)
X        is_end_valve : boolean;    (* true = pipeline must connect to an end
V *)
X                                   (*  valve before level can be completed
V   *)
X        reservior_count : integer; (* count-ticks that oil is delayed  *)
X        block_count : integer;     (* number of blocks (obstacles) on field
V  *)
X    End;
X
X(***************************************************************************
V**
X * Piece_Info_Rec
X *
X * Quite an important data structure in this game. For each of the diferent
X * piece types (as enumerated by Piece_Ids) there is a corresponding`20
X * information record describing the features of that piece.
X *`20
X * The fields in this structure are:
X *   SideInfo: Every one of the 4 sides (North,South,East,West) has a`20
X *     state (none,InOnly,OutOnly,InOut), and an Soft Character Set value
X *     for displaying on the terminal.
X *     For example, a certain peice might have an InOut state on its North
X *     side, and and InOut state on its South side. This means that the`20
X *     oil can enter from the North or South (above or below) and exit out
X *     the opposite side.`20
X *     The Half_Char shows what the peice looks like when it is only
X *     half-filled with oil from that particular direction.`20
X *     Exit_Side states the corresponding side the oil should exit from`20
X *     if it enters from this side.
X *  `20
X *  Empty_Char : The Soft Character Set value for the piece when empty
X *  Full_Char  : The Soft Character Set value for the piece when full
X *
X *)
XTYPE
X    piece_info_rec = Record
X        SideInfo: Array`5BNorth..West`5D of Record
X            State   : Side_States;
X            Half_Char   : Char;
X`09        Exit_Side : Sides;
X        End;
X        Empty_Char : Char;
X        Full_Char  : Char;
X    End;
X       `20
X(* And this array type is an array of a piece-info_rec for each of the
X *  peice types...
X *)
X    piece_info_array = Array`5Bvertical..empty_space`5D of piece_info_rec;
X
XCONST
X    nr_selectable_pieces = 24;
X
XTYPE`20
X    fillcodes = 0 .. 9 ;
X
XVAR
X    piece_info : piece_info_array;
X    cross_horiz, cross_vert, cross_full : char;
X
X    (* playfield
X     *  this data structure is a 2 dimensional array describes what peices
X     *  are displayed on the playing field -`20
X     *   piece : piece_id code for what is in the square (heck, did I mentio
Vn
X     *           (that there is a piece_id type called 'empty_space' - yep
X     *            thats the piece thats in the blank squares...)
X     *   fillcode : mainly needed for filling cross-pieces
X     *   ch : current character value on display (allows for quick re-draw
X     *        of screen without looking up the data structures)
X     *)
X    playfield : Array`5B1..field_width,1..field_length`5D of`20
X        Record`20
X            Piece : Piece_Ids;   `20
X            fillcode  : fillcodes;
X            ch    : char;
X        end;
X   `20
X    (* you guessed it: the data structure holding the next peices to be
X     *  displayed
X     *)
X    queue : PQueueType;             `20
X
X    (* playinfo: holds stuff like scores etc.`20
X     *   See the PlayInfoRecord description earlier in this file
X     *)
X    playinfo : PlayInfoRecord;
X
X    (* position of cursor within the playfield *)
X    posn_x, posn_y : integer;
X
X    (* positions of the start and end valves on the playfield *)
X    start_valve_x, start_valve_y : integer;
X    end_valve_x, end_valve_y     : integer;
X
X    (* set this to true when the target number of pipe segments have been`20
X     * filled with oil`20
X     *)
X    pipeline_complete : boolean := false;
X
X    (* current position of the head of the oil flow through the pipeline *)
X    oil_posn_x, oil_posn_y : integer;
X
X    oil_posn_side : Sides;
X    oil_posn_state : Pipe_states;
X
X    selection_array : array`5B1..nr_selectable_pieces`5D of piece_ids;
X    selection_count : integer;
X
X    (* explode_chars.  these are the Soft Character Set equivalents for the`
V20
X     * 'popping' sequence, where all the unused pieces on the playfield
X     * dissapear away
X     *)
X    explode_chars : array`5B1..4`5D of char := ('V','W','X','8');
X
X(***************************************************************************
V*
X **** PROGRAM CODE BEGINS HERE *********************************************
V*
X ***************************************************************************
V*)
X
X(***************************************************************************
X * _Upper_case : self explainatory. Returns an uppercase (if any) character
X *  value for a given character.
X *)
XFUNCTION  _Upper_case ( c : char ) : char;
XBEGIN
X  IF ( c in `5B'a'..'z'`5D ) then
X    c := chr ( ord(c) - ord('a') + ord('A') );
X  _upper_case := c;
XEND;
X
X(**************************************************************************
X * Initalises the Piece_Info array. This is where the individual`20
X * characteristics of each peice is defined.
X *)
XProcedure InitPieces;
XVAR i : piece_ids;
X    j : Sides;
XBegin
X    for i := vertical to empty_space do`20
X        for j := North to West do
X            with piece_info`5B i `5D.SideInfo`5B j `5D do begin
X                state := None;
X                Half_Char := ' ';
X                exit_side := North;
X            end;
X    piece_info`5B empty_space `5D.empty_char := '8';
X
X    with piece_info`5Bvertical`5D do begin
X        SideInfo`5BNorth`5D.state := InOut;
X        SideInfo`5BNorth`5D.Half_Char := 'A';
X        SideInfo`5BNorth`5D.exit_side := South;
X        SideInfo`5BSouth`5D.state := InOut;
X        SideInfo`5BSouth`5D.Half_Char := 'O';
X        SideInfo`5BSouth`5D.Exit_Side := North;
X        Empty_Char := 'a';
X        Full_Char := 'o';
X    end;
X    with piece_info`5B horizontal `5D do begin
X        SideInfo`5B West `5D.state := InOut;
X        SideInfo`5B West `5D.Half_Char := 'B';
X        SideInfo`5B West `5D.Exit_Side := East;
X        SideInfo`5B East `5D.state := InOut;
X        SideInfo`5B East `5D.Half_Char := 'P';
X        SideInfo`5B East `5D.Exit_Side := West;
X        Empty_Char := 'b';
X        Full_Char := 'p';
X    end;
X    cross_horiz := '6';
X    cross_vert := '7';
X    cross_full := 'q';
X    with piece_info`5B cross `5D do begin
X        SideInfo`5B North `5D.state := InOut;
X        SideInfo`5B North `5D.Half_Char := 'Q';
X        SideInfo`5B North `5D.Exit_Side := South;
X        SideInfo`5B South `5D.state := InOut;
X        SideInfo`5B South `5D.Half_Char := '0';
X        SideInfo`5B South `5D.Exit_Side := North;
X        SideInfo`5B East `5D.state := InOut;
X        SideInfo`5B East `5D.Half_Char := '1';
X        SideInfo`5B East `5D.Exit_Side := West;
X        SideInfo`5B West `5D.state := InOut;
X        SideInfo`5B West `5D.Half_Char := 'C';
X        SideInfo`5B West `5D.Exit_Side := East;
X        Empty_Char := 'c';
X        Full_Char := cross_full;
X    end;
X    with piece_info`5B curve_UL `5D do begin
X        SideInfo`5B East `5D.state := InOut;
X        SideInfo`5B East `5D.Half_Char := 'R';
X        SideInfo`5B East `5D.Exit_Side := South;
X        SideInfo`5B South `5D.state := InOut;
X        SideInfo`5B South `5D.Half_Char := 'D';
X        SideInfo`5B South `5D.Exit_Side := East;
X        Empty_Char := 'd';
X        Full_Char := 'r';
X    end;
X    with piece_info`5B curve_LL `5D do begin
X        SideInfo`5B North `5D.state := InOut;
X        SideInfo`5B North `5D.Half_Char := 'S';
X        SideInfo`5B North `5D.Exit_Side := East; `20
X        SideInfo`5B East `5D.state := InOut;`20
X        SideInfo`5B East `5D.Half_Char := 'E';
X        SideInfo`5B East `5D.Exit_Side := North;
X        Empty_Char := 'e';
X        Full_Char := 's';
X    end;
X    with piece_info`5B curve_UR `5D do begin
X        SideInfo`5B West `5D.state := InOut;
X        SideInfo`5B West `5D.Half_Char := 'T';
X        SideInfo`5B West `5D.Exit_Side := South;
X        SideInfo`5B South `5D.state := InOut;
X        SideInfo`5B South `5D.Half_Char := 'F';
X        SideInfo`5B South `5D.Exit_Side := West;
X        Empty_Char := 'f';
X        Full_Char := 't';
X    end;
X    with piece_info`5B curve_LR `5D do begin
X        SideInfo`5B North `5D.state := InOut;
X        SideInfo`5B North `5D.Half_Char := 'U';
X        SideInfo`5B North `5D.Exit_Side := West;
X        SideInfo`5B West `5D.state := InOut;
X        SideInfo`5B West `5D.Half_Char := 'G';
X        SideInfo`5B West `5D.Exit_Side := North;
X        Empty_Char := 'g';
X        Full_Char := 'u';
X    end;
X    with piece_info`5B vertical_1way_down `5D do begin
X        SideInfo`5B North `5D.state := InOnly;
X        SideInfo`5B North `5D.Half_Char := 'H';
X        SideInfo`5B North `5D.Exit_Side := South;
X        SideInfo`5B South `5D.state := OutOnly;
X        SideInfo`5B South `5D.Half_Char := 'v';
X        SideInfo`5B South `5D.Exit_Side := North;
X        Empty_Char := 'h';
X        Full_Char := 'v';
X    end;
X    with piece_info`5B vertical_1way_up `5D do begin
X        SideInfo`5B North `5D.state := OutOnly;
X        SideInfo`5B North `5D.Half_Char := 'w';
X        SideInfo`5B North `5D.Exit_Side := South;
X        SideInfo`5B South `5D.state := InOnly;
X        SideInfo`5B South `5D.Half_Char := 'I';
X        SideInfo`5B South `5D.Exit_Side := North;
X        Empty_Char := 'i';
X        Full_Char := 'w';
X    end;
X    with piece_info`5B horiz_1way_left `5D do begin
X        SideInfo`5B East `5D.state := InOnly;
X        SideInfo`5B East `5D.Half_Char := 'K';
X        SideInfo`5B East `5D.Exit_Side := West;
X        SideInfo`5B West `5D.state := OutOnly;
X        SideInfo`5B West `5D.Half_Char := 'y';
X        SideInfo`5B West `5D.Exit_Side := East;
X        Empty_Char := 'k';
X        Full_Char := 'y';
X    end;
X    with piece_info`5B horiz_1way_right `5D do begin
X        SideInfo`5B East `5D.state := OutOnly;
X        SideInfo`5B East `5D.Half_Char := 'x';
X        SideInfo`5B East `5D.Exit_Side := West;
X        SideInfo`5B West `5D.state := InOnly;
X        SideInfo`5B West `5D.Half_Char := 'J';
X        SideInfo`5B West `5D.Exit_Side := East;
X        Empty_Char := 'j';
X        Full_Char := 'x';
X    end;
X    with piece_info`5B start_valve `5D do begin
X        SideInfo`5B East `5D.state := OutOnly;
X        SideInfo`5B East `5D.Half_Char := 'L';
X        SideInfo`5B East `5D.Exit_Side := East;
X        Empty_Char := 'l';
X        Full_Char := 'L';
X    end;
X    with piece_info`5B end_valve `5D do begin
X        SideInfo`5B South `5D.state := InOnly;
X        SideInfo`5B South `5D.Half_Char := 'M';
X        Empty_Char := 'm';
X        Full_Char := 'M';
X    end;
X    with piece_info`5B block `5D do begin
X        Empty_Char := 'n';
X        Full_Char := 'n';
X    end;
X    with piece_info`5B reservior `5D do begin
X        SideInfo`5B East `5D.state := InOut;
X        SideInfo`5B East `5D.Half_Char := '5';
X        SideInfo`5B East `5D.Exit_Side := West;
X        SideInfo`5B West `5D.state := InOut;
X        SideInfo`5B West `5D.Half_Char := '4';
X        SideInfo`5B West `5D.Exit_Side := East;
X        Empty_Char := '2';
X        Full_Char := '3';
X    end;
XEnd;
X
X(***************************************************************************
X * LoadGameFont
X *  Since the font (Soft Character Set) file is simply a VT320 DECDLD escape
X *  sequence, all that needs to be done is to output the file to the termina
Vl
X *)
XProcedure LoadGameFont( filename : varying`5Bmax`5D of char );
Xvar infile : text;
X    line   : varying`5B255`5D of char;
Xbegin
X    open( infile, filename, history := old, error := continue );
X    if status(infile)<>0  then`20
X        ERROR( 'Unable to open font file.' );
X    reset( infile );
X    while not eof( infile ) do begin
X        readln( infile, line );
X        qio_write( line );
X    end;
X    close( infile );
Xend;
X
X(***************************************************************************
X * InitPlayInfo
X *   Initialise important fields in the playinfo variable
X *)
XProcedure InitPlayInfo;
XBegin
X    with playinfo do begin
X        level := 1;
X        score := 0;
X        queue_size := preview_queue_maxsize;
X    end;
XEnd;
X
X(***************************************************************************
X * ClearPlayingField `20
X *  Initialize the playfield array to initial values
X *)
XProcedure ClearPlayingField;
XVAR x,y : Integer;
XBegin
X    for x := 1 to field_width do
X        for y := 1 to field_length do begin
X            playfield`5Bx,y`5D.piece := empty_space;
X            playfield`5Bx,y`5D.fillcode := 0;
X            playfield`5Bx,y`5D.ch := piece_info`5B empty_space `5D.empty_cha
Vr;
X        end;
XEnd;
X  `20
X(***************************************************************************
X * DrawPlayingField
X *  Display a blank playfield on the terminal         `20
X *)
XProcedure DrawPlayingField;
Xvar x,y : integer;
X    st : varying`5B80`5D of char:='';
XBegin
X    for x := 1 to field_width do
X        st := st + piece_info`5B empty_space `5D.empty_char;
X    Square( field_topleft_x, field_topleft_y,`20
X            field_topleft_x+field_width+1, field_topleft_y+field_length+1 );
X    QIO_Write( VT320_g1_char_set );
X    for y := 1 to field_length do
X            qio_write( get_posn( field_topleft_x+1, field_topleft_y+y) + st
V );
X    QIO_Write( VT320_g0_char_set );
XEnd;
X
X(***************************************************************************
V*
X * Set40Screen
X *   Set terminal lines to 40 columns
X *)
XProcedure Set40Screen;
Xvar i : integer;
Xbegin
X    for i := 1 to 24 do
X        qio_write( get_posn(1,i)+VT100_wide );
Xend;
X
X(***************************************************************************
X * WriteLabels
X *  Display the labels used on the game display
X *)
XProcedure WriteLabels;
Xbegin
X    QIO_Write( get_posn( score_label_pos_x, score_label_pos_y )+'Score:' );
X    QIO_Write( get_Posn( level_label_pos_x, level_label_pos_y )+'Level:' );
X    QIO_Write( get_posn( target_label_pos_x, target_label_pos_y )+'Target:'
V );
X    QIO_Write( get_posn( time_label_pos_x, time_label_pos_y )+'Time:' );
X    QIO_Write( get_posn( next_label_pos_x, next_label_pos_y )+'Next Pieces:'
V);
X    QIO_Write( VT100_bright );
X    QIO_Write( get_posn( queue_display_x-4, queue_display_y )+'>>>' );
X    QIO_Write( get_posn( queue_display_x+2, queue_display_y )+'<<<' );
X    QIO_Write( VT100_normal );
Xend;
X
X(***************************************************************************
V*
X * DisplayTime
X *  Show the time elapsed
X *)
Xprocedure DisplayTime;
Xbegin
X    QIO_Write( get_posn( time_value_pos_x, time_label_pos_y )+
X                _Dec(playinfo.timetillOil,'0',3) );
Xend;
X
X(***************************************************************************
V**
X * UpdateScoreDisplay
X *  `20
X *   Display a new score and target count values
X *)
XProcedure UpdateScoreDisplay;
Xvar t : integer;
Xbegin
X    if playinfo.score < 0 then`20
X        playinfo.score := 0;
X    QIO_Write( get_posn( score_value_pos_x, score_label_pos_y ) +
X                _Dec(playinfo.score, '0',7 ) );
X    QIO_Write( get_posn( level_value_pos_x, level_label_pos_y ) +
X                _Dec(playinfo.level, ' ',1 ) );
X    if playinfo.target_count < playinfo.target then
X        t := playinfo.target - playinfo.target_count
X    else
X        t := 0;
X    QIO_Write(get_posn(target_value_pos_x,target_label_pos_y)+_Dec(t,' ',3)
V );
Xend;
X
X(***************************************************************************
X * InitPieceQueue
X *)
XProcedure InitPieceQueue( VAR queue : PQueueType; maxsize : Integer );
Xbegin
X    queue.count := 0;
X    queue.head := 1;
X    queue.tail := 1;
X    queue.maxsize := maxsize;
XEnd;
X
X(**************************************************************************
X * AddPieceToQueue
X *   (Will not add to an already full queue)
X *)
XProcedure AddPieceToQueue( VAR queue : PQueueType; piece : Piece_Ids );
Xbegin
X    if queue.count < queue.maxsize then begin
X        queue.data`5Bqueue.tail`5D := piece;
X        queue.tail := queue.tail + 1;
X        queue.count := queue.count + 1;
X        if queue.tail > preview_queue_maxsize then
X            queue.tail := 1;
X    end;
XEnd;
X
X(*************************************************************************
X * GetPieceFromQueue
X *  (if queue empty then return empty space piece code)
X *)
XFunction GetPieceFromQueue( VAR queue : PQueueType ) : Piece_Ids;
XVar retval : Piece_Ids;
XBegin
X    if queue.count > 0 then begin
X        retval := queue.data`5Bqueue.head`5D;
X        queue.head := queue.head + 1;
X        queue.count := queue.count - 1;
X        if queue.head > preview_queue_maxsize then
X            queue.head := 1;
X    end else`20
X        retval := empty_space;
X    GetPieceFromQueue := retval;
XEnd;
X
X(***************************************************************************
V**
X * PlaceEmptyPiece
X *   Draw an empty segment of pipe onto the playfield
X *)
XProcedure PlaceEmptyPiece( piece : piece_ids; x,y : integer );
Xbegin
X(* Places a piece on the playing field *)
X    if (x>=1) and (x<=field_width) and (y>=1) and (y<=field_length) then beg
Vin
X        qio_write( get_posn(field_topleft_x+x,field_topleft_y+y) +`20
X                    vt320_g1_char_set + piece_info`5B piece `5D.empty_char +
V`20
X                    vt320_g0_char_set );
X        playfield`5Bx,y`5D.piece := piece;
X        playfield`5Bx,y`5D.fillcode := 0;
X        playfield`5Bx,y`5D.ch := piece_info`5B piece `5D.empty_char;
X    end;
Xend;
X
X(***************************************************************************
V*
X * DrawPiece
X *   Draw any sort of piece on playfield
X *)
XProcedure DrawPiece(`20
X    piece : piece_ids;
X    state : pipe_states;
X    side  : Sides;
X    x,y   : integer );
XVar c : Char;
Xbegin
X    if (x>=1) and (x<=field_width) and (y>=1) and (y<=field_length) then beg
Vin
X        if state = half then begin
X            with piece_info`5Bpiece`5D do begin
X                if SideInfo`5B side `5D.state = None then
X                  (*  Error( 'Trying to place invalid half full side' ) *)
X                else
X                    c := SideInfo`5B side `5D.Half_Char;
X            end;
X        end else
X            if state = full then
X                c := piece_info`5B piece `5D.full_char
X            else
X                c := piece_info`5B piece `5D.empty_char;
X        qio_write( get_posn(field_topleft_x+x,field_topleft_y+y) +`20
X                   vt320_g1_char_set + c + vt320_g0_char_set );
X        playfield`5Bx,y`5D.piece := piece;
X        playfield`5Bx,y`5D.ch := c;
X    End;
XEnd;
X
X(***************************************************************************
X * DrawPieceQueue
X *  Draw the queue of next pieces of pipe
X *)
XProcedure DrawPieceQueue( queue : PQueueType );
Xvar i,j : integer;
X    p : Piece_Ids;
X    c : char;
X    q2 : PQueueType;
Xbegin
X    qio_write( vt320_g1_char_set );
X    InitPieceQueue( q2, preview_queue_maxsize );
X    for i := 0 to playinfo.queue_size-1 do begin
X        p := GetPieceFromQueue( queue );
X        AddPieceToQueue( q2, p );
X        c := piece_info`5Bp`5D.empty_char;
X        qio_write( get_posn(queue_display_x,queue_display_y-(2*i)) + c );
X    end;
X    qio_write( vt320_g0_char_set );
X    queue := q2;
Xend;
X
X(**************************************************************************
X * PositionObjects
X *  Randomly draw start and end valves, reserviors, obstacles on playfield
X *  A wee bit of checking is done to (hopefully) prevent impossible`20
X *  configurations
X *)
XProcedure PositionObjects;
Xvar ok : boolean;
X    i,x,y : integer;
Xbegin
X    start_valve_x := Random( field_width-1 ); (* can't be on rightmost col *
V)
X    start_valve_y := Random( field_length );`20
X    PlaceEmptyPiece( start_valve, start_valve_x, start_valve_y );
X    if playinfo.is_end_valve then begin
X        ok := false;
X        while not ok do begin
X            end_valve_x := Random( field_width );
X            end_valve_y := Random( field_length-1); (* can't be on bottom ro
Vw *)
X            if not (   ( start_valve_x = end_valve_x )`20
X                    or ( start_valve_y = end_valve_y ) ) then
X                ok := true;
X        end;
X    end;
X    PlaceEmptyPiece( end_valve, end_valve_x, end_valve_y );
X    for i := 1 to playinfo.block_count do begin
X        ok := false;
X        while not ok do begin
X            x := Random( field_width-2 ) + 1;
X            y := Random( field_length-2 ) + 1;
X            if PlayField`5Bx,y`5D.piece = empty_space then begin
X                PlaceEmptyPiece( block, x, y );
X                ok := true;
X            end;
X        end;
X    end;
X    for i := 1 to playinfo.reservior_count do begin
X        ok := false;
X        while not ok do begin
X            x := Random( field_width-2 ) + 1;
X            y := Random( field_length-2 ) + 1;
X            if PlayField`5Bx,y`5D.piece = empty_space then begin
X                PlaceEmptyPiece( reservior, x, y );
X                ok := true;
X            end;
X        end;
X    end;
Xend;
X
X(***************************************************************************
V*
X * RandomPipe
X *  Select a pipe at random from the current set of valid choices
X *)
XFunction RandomPipe : Piece_Ids;
Xbegin
X    RandomPipe := Selection_Array`5B Random(selection_count) `5D;
Xend;
X
X(***************************************************************************
X * PrepareLevel
X *  Begining of a new level: reset appropriate global variables`20
X *  This is where the difficulty of a level is determined.
X *`20
X * Feel free to modify these settings as you wish.
X *)
XProcedure PrepareLevel;
Xbegin
X    playinfo.target_count := 0;
X    playinfo.crossfill_count := 0;
X    playinfo.completion_bonus := (500 * playinfo.level);
X    case playinfo.level of
X     1 : begin
X            playinfo.target := 16;
X            playinfo.is_end_valve := false;
X            playinfo.reservior_count := 0;
X            playinfo.block_count := 0;
X            playinfo.oil_flow_speed := 4;
X            playinfo.basetimetilloil := 45;
X            selection_array`5B1`5D := vertical;
X            selection_array`5B2`5D := horizontal;
X            selection_array`5B3`5D := cross;
X            selection_array`5B4`5D := curve_UL;
X            selection_array`5B5`5D := curve_LL;
X            selection_array`5B6`5D := curve_UR;
X            selection_array`5B7`5D := curve_LR;
X            selection_count := 7;
X         end;
X     2 : begin
X            playinfo.target := 18;
X            playinfo.is_end_valve := false;
X            playinfo.reservior_count := 0;
X            playinfo.block_count := 0;
X            playinfo.oil_flow_speed := 4;
X            playinfo.basetimetilloil := 45;
X            selection_array`5B1`5D := vertical;
X            selection_array`5B2`5D := horizontal;
X            selection_array`5B3`5D := cross;
X            selection_array`5B4`5D := curve_UL;
X            selection_array`5B5`5D := curve_LL;
X            selection_array`5B6`5D := curve_UR;
X            selection_array`5B7`5D := curve_LR;
X            selection_count := 7;
X         end;
X     3 : begin
X            playinfo.is_end_valve := false;
X            playinfo.block_count := 0;
X            playinfo.oil_flow_speed := 3;
X            selection_array`5B1`5D := vertical;
X            selection_array`5B2`5D := horizontal;
X            selection_array`5B3`5D := cross;
X            selection_array`5B4`5D := curve_UL;
X            selection_array`5B5`5D := curve_LL;
X            selection_array`5B6`5D := curve_UR;
X            selection_array`5B7`5D := curve_LR;
X            selection_count := 7;
X
X            playinfo.target := 20;
X            playinfo.basetimetilloil := 45;
X            playinfo.reservior_count := 1;
X         end;
X     4 : begin
X            playinfo.is_end_valve := false;
X            playinfo.block_count := 0;
X            playinfo.oil_flow_speed := 3;
X            selection_array`5B1`5D := vertical;
X            selection_array`5B2`5D := horizontal;
X            selection_array`5B3`5D := cross;
X            selection_array`5B4`5D := curve_UL;
X            selection_array`5B5`5D := curve_LL;
X            selection_array`5B6`5D := curve_UR;
X            selection_array`5B7`5D := curve_LR;
X            selection_count := 7;
X
X            playinfo.target := 24;
X            playinfo.basetimetilloil := 65;
X            playinfo.reservior_count := 1;
X            playinfo.block_count := 1;
X         end;
X     5 : begin
X            playinfo.is_end_valve := true;
X            selection_array`5B8`5D := vertical_1way_down;
X            selection_array`5B9`5D := vertical_1way_up;
X            selection_array`5B10`5D := horiz_1way_left;
X            selection_array`5B11`5D := horiz_1way_right;
X            selection_array`5B12`5D := vertical;
X            selection_array`5B13`5D := horizontal;
X            selection_array`5B14`5D := curve_UL;
X            selection_array`5B15`5D := curve_LL;
X            selection_array`5B16`5D := curve_UR;
X            selection_array`5B17`5D := curve_LR;
X
X            playinfo.oil_flow_speed := 3;
X            playinfo.target := 32;
X            playinfo.basetimetilloil := 75;
X            playinfo.reservior_count := 2;
X            playinfo.block_count := 1;
X         end;
X     6 : begin
X            playinfo.is_end_valve := true;
X            selection_array`5B8`5D := vertical_1way_down;
X            selection_array`5B9`5D := vertical_1way_up;
X            selection_array`5B10`5D := horiz_1way_left;
X            selection_array`5B11`5D := horiz_1way_right;
X            selection_array`5B12`5D := vertical;
X            selection_array`5B13`5D := horizontal;
X            selection_array`5B14`5D := curve_UL;
X            selection_array`5B15`5D := curve_LL;
X            selection_array`5B16`5D := curve_UR;
X            selection_array`5B17`5D := curve_LR;
X
X            playinfo.target := 32;
X            playinfo.basetimetilloil := 75;
X            playinfo.reservior_count := 3;
X            playinfo.block_count := 2;
X
X            playinfo.oil_flow_speed := 1;
X        end;
X     7: begin
X            playinfo.is_end_valve := true;
X            selection_array`5B8`5D := vertical_1way_down;
X            selection_array`5B9`5D := vertical_1way_up;
X            selection_array`5B10`5D := horiz_1way_left;
X            selection_array`5B11`5D := horiz_1way_right;
X            selection_array`5B12`5D := vertical;
X            selection_array`5B13`5D := horizontal;
X            selection_array`5B14`5D := curve_UL;
X            selection_array`5B15`5D := curve_LL;
X            selection_array`5B16`5D := curve_UR;
X            selection_array`5B17`5D := curve_LR;
X
X            playinfo.target := 32;
X            playinfo.basetimetilloil := 75;
X            playinfo.reservior_count := 2;
X            playinfo.block_count := 2;
X
X            playinfo.oil_flow_speed := 0;
X         end;
X     otherwise begin
X            playinfo.is_end_valve := true;
X            selection_array`5B8`5D := vertical_1way_down;
X            selection_array`5B9`5D := vertical_1way_up;
X            selection_array`5B10`5D := horiz_1way_left;
X            selection_array`5B11`5D := horiz_1way_right;
X            selection_array`5B12`5D := vertical;
X            selection_array`5B13`5D := horizontal;
X            selection_array`5B14`5D := curve_UL;
X            selection_array`5B15`5D := curve_LL;
X            selection_array`5B16`5D := curve_UR;
X            selection_array`5B17`5D := curve_LR;
X
X            playinfo.target := 24;
X            playinfo.basetimetilloil := 75;
X            playinfo.reservior_count := 1;
X            playinfo.block_count := 1;
X
X            playinfo.target := playinfo.target + 4;
X            playinfo.basetimetilloil := playinfo.basetimetilloil + 15;
X            if (playinfo.level mod 2) = 0 then
X               playinfo.block_count := playinfo.block_count + 1;
X            if (playinfo.level mod 4) = 0 then
X               playinfo.reservior_count := playinfo.reservior_count + 1;
X        end;
X    end;
Xend;
X
XProcedure DestroyUnusedPieces;
Xvar x,y,i : integer;
Xbegin
X    for i := 1 to 4 do`20
X        for y := 1 to field_length do
X            for x := 1 to field_width do`20
X               if (playfield`5Bx,y`5D.piece <> empty_space) and
X                   (playfield`5Bx,y`5D.piece <> reservior) and
X                    (playfield`5Bx,y`5D.piece <> block) and
X                      (playfield`5Bx,y`5D.fillcode=0) then begin
X                    qio_write( get_posn(field_topleft_x+x,field_topleft_y+y)
V +`20
X                               vt320_g1_char_set + explode_chars`5Bi`5D +`20
X                                vt320_g0_char_set );
X                    if i = 4 then begin
X                        playfield`5Bx,y`5D.piece := empty_space;
X                        playfield`5Bx,y`5D.fillcode := 0;
X                        playfield`5Bx,y`5D.ch := piece_info`5B empty_space `
V5D.empty_char;
X                        playinfo.score := playinfo.score - 60;
X                    end;
X                    UpdateScoreDisplay;
X                end;
Xend;
X
XProcedure DeductScore( d : integer );
Xvar i : integer;
Xbegin
X    for i := 1 to (d div 100) do`20
X        qio_write( get_posn( score_value_pos_x, score_label_pos_y ) +
X                _Dec(playinfo.score-(i*100), '0',7 ) );
X    playinfo.score := playinfo.score - d;
Xend;
X
X(* Bogus routine. Not needed. Remember to delete`20
XProcedure Bonus;
Xvar i : integer;
Xbegin
X    qio_write( get_posn( 1,1)+'  Bonus: ' );
X    for i := 1 to (playinfo.completion_bonus div 100) do begin
X        qio_write( get_posn(10,24)+
X            _dec(playinfo.completion_bonus-(i*100),'0',5)+
X            get_posn( score_value_pos_x, score_label_pos_y ) +
X                _Dec(playinfo.score+(i*100), '0',7 ) );
X        sleep(0,0.1);`20
X    end;
X    playinfo.score := playinfo.score + playinfo.completion_bonus;
Xend;
X*)
X
XProcedure Congrats;
Xbegin
X    qio_write( Get_Posn(1,23)+' Congratulations! Length = '+
X                _dec(playinfo.target_count,' ',0) );
X    (* Bonus; -remove this line *)
X    sleep(0,0.5);   `20
X    qio_write( Get_Posn(1,24)+' Press any key to continue  ' );
X    qio_purge;
X    qio_1_char;
Xend;
X
XProcedure Condolences;
Xbegin
X    if (playinfo.is_end_valve <> pipeline_complete) then`20
X        qio_write(Get_Posn(1,23)+'Pipeline does not connect to end valve')
X    else if (playinfo.target_count < playinfo.target) then
X        qio_write( Get_posn(1,23)+'Game over: Pipeline is not long enough');
X    qio_write( Get_Posn(1,24)+'      Press any key to continue' );
X    qio_purge;
X    qio_1_char;
Xend;
X
XProcedure PlacePiece;
Xvar p : Piece_ids;
X    i : integer;
Xbegin
X    if playfield`5Bposn_x, posn_y`5D.fillcode <> 0 then`20
X            QIO_Write( VT100_Bell )
X    else begin
X        p := playfield`5Bposn_x, posn_y`5D.piece;
X        case p of
X            start_valve, end_valve, reservior :
X                QIO_Write( VT100_Bell );
X        otherwise`20
X            begin
X                if playfield`5B posn_x, posn_y `5D.piece <> empty_space then
V begin
X                    if playfield`5B posn_x, posn_y `5D.piece = block then
X                        DeductScore( 5000 );
X                    QIO_Write( vt320_g1_char_set );
X                    for i := 1 to 4 do begin
X                        QIO_Write( get_posn(field_topleft_x + posn_x,
X                                            field_topleft_y + posn_y ) +`20
X                                    explode_chars`5Bi`5D);
X                        sleep( 0, 0.1 );
X                    end;
X                    QIO_Write( vt320_g0_char_set );
X                    playinfo.score := playinfo.score - 20
X                end else
X                    playinfo.score := playinfo.score + 50;
X                UpdateScoreDisplay;
X                p := GetPieceFromQueue( queue );
X                PlaceEmptyPiece( p, posn_x, posn_y );
X                Posn( posn_x, posn_y );
X                AddPiecetoQueue( queue, RandomPipe );
X                DrawPieceQueue( queue );
X            end;
X        end;
X    end;
Xend;
X
XProcedure MoveCursor( c : char );
Xvar dx, dy : integer := 0;
Xbegin
X    case c of`20
X        '0' : ;
X        '1' : begin dx := -1; dy := 1; end;
X        '2' : dy := 1;
X        '3' : begin dx := 1; dy := 1; end;
X        '4' : dx := -1;`20
X        '5' : ;
X        '6' : dx := 1;`20
X        '7' : begin dx := -1; dy := -1; end;
X        '8' : dy := -1;
X        '9' : begin dx := 1; dy := -1; end;
X    otherwise
X        Error( 'Invalid character passed to MoveCursor' );
X    end;
X    if (posn_x+dx >= 1) and (posn_x+dx <= field_width) and
X        (posn_y+dy >=1) and (posn_y+dy <= field_length) then begin
X        QIO_Write( Get_Posn( field_topleft_x+posn_x, field_topleft_y+posn_y
V )+
X            VT100_normal + VT320_G1_Char_Set + playfield`5Bposn_x,posn_y`5D.
Vch  );
X        posn_x := posn_x + dx;
X        posn_y := posn_y + dy;
X        QIO_Write( Get_Posn( field_topleft_x+posn_x, field_topleft_y+posn_y
V )+
X            VT100_inverse + playfield`5Bposn_x,posn_y`5D.ch +`20
X            VT320_G0_char_set + VT100_normal + Get_Posn( 1,1 ) );
X    end;
Xend;
X
XProcedure CursorOff;
Xbegin
X    QIO_Write( Get_Posn( field_topleft_x+posn_x, field_topleft_y+posn_y )+
X            VT100_normal + VT320_G1_Char_Set + playfield`5Bposn_x,posn_y`5D.
Vch`20
X            + VT320_G0_Char_Set + Get_Posn(1,1));
Xend;
X
XProcedure StartRound;
Xvar i : integer;
Xbegin
X    posn_x := field_width div 2;
X    posn_y := field_width div 2;
X    Clear;
X    Set40Screen;
X    ClearPlayingField;
X    DrawPlayingField;
X    PrepareLevel;   `20
X    WriteLabels;
X    UpdateScoreDisplay;
X    PositionObjects;
X    oil_posn_x := start_valve_x;
X    oil_posn_y := start_valve_y;
X    oil_posn_side := East;
X    oil_posn_state := half;
X    InitPieceQueue( queue, preview_queue_maxsize );
X    for i := 1 to playinfo.queue_size do
X        AddPiecetoQueue( queue, RandomPipe );
X    DrawPieceQueue( queue );
X    (* Posn( field_topleft_x+posn_x, field_topleft_y+posn_y ); *)
X    MoveCursor( '0' );
X    pipeline_complete := false;
X    playinfo.timetillOil := playinfo.basetimetillOil;
Xend;
X
XFunction PumpOil : Boolean;
Xvar piece : piece_ids;
X    retval,ok : boolean := true;
X    fillcode : fillcodes;
X    filledcross : boolean := false;
Xbegin
X    piece := playfield`5Boil_posn_x,oil_posn_y`5D.piece;
X
X    case oil_posn_state of
X        empty : begin
X            if (piece = reservior) then begin
X                if playfield`5Boil_posn_x, oil_posn_y`5D.fillcode < 4 then b
Vegin
X                    playfield`5Boil_posn_x, oil_posn_y`5D.fillcode :=`20
X                        playfield`5Boil_posn_x, oil_posn_y`5D.fillcode + 1;
X                    ok := false;
X                end;
X            end;
X            if ok then begin           `20
X                oil_posn_state := half;`20
X                DrawPiece(  piece,
X                    oil_posn_state, oil_posn_side,`20
X                    oil_posn_x, oil_posn_y );
X                    playfield`5Boil_posn_x, oil_posn_y`5D.fillcode :=`20
X                        playfield`5Boil_posn_x, oil_posn_y`5D.fillcode + 1;
X            end;
X        end;
X        half : begin
X            if (piece = cross)  then begin
X               if (playfield`5Boil_posn_x, oil_posn_y`5D.fillcode = 1) then
V begin
X                    case oil_posn_side of
X                        North, South:piece_info`5Bcross`5D.Full_char := cros
Vs_vert;
X                        East, West  :piece_info`5Bcross`5D.Full_char := cros
Vs_horiz;
X                    end;
X                    playfield`5Boil_posn_x, oil_posn_y`5D.fillcode := 2;
X                end else begin
X                    piece_info`5B cross `5D.Full_Char := cross_full;
X                    filledcross := true;
X                end;
X            end else if (piece = reservior ) then begin
X                if playfield`5Boil_posn_x, oil_posn_y`5D.fillcode < 9 then b
Vegin
X                    playfield`5Boil_posn_x, oil_posn_y`5D.fillcode :=`20
X                        playfield`5Boil_posn_x, oil_posn_y`5D.fillcode + 1;
X                    ok := false;
X                end;
X            end else
X                playfield`5Boil_posn_x, oil_posn_y`5D.fillcode := 1;
X            if ok then begin
X                oil_posn_state := full;
X                DrawPiece(  piece,
X                    oil_posn_state, oil_posn_side,`20
X                    oil_posn_x, oil_posn_y );
X            end;
X        end;
X        full : begin
X            playinfo.target_count := playinfo.target_count + 1;
X            if playinfo.target_count > playinfo.target then
X                playinfo.score := playinfo.score + 20;
X            if piece = end_valve then begin
X                pipeline_complete := true;
X                retval := false;
X            end else begin
X                case piece of
X                    vertical, horizontal, curve_UL..curve_LR :
X                        playinfo.score := playinfo.score + 50;
X                    vertical_1way_down..horiz_1way_right :
X                        playinfo.score := playinfo.score + 75;
X                    reservior :`20
X                        playinfo.score := playinfo.score + 100;
X                    cross :
X                        if filledcross then begin
X                            playinfo.score := playinfo.score + 150;
X                            playinfo.crossfill_count :=`20
X                                playinfo.crossfill_count + 1;
X                            if playinfo.crossfill_count = 5 then begin
X                                playinfo.crossfill_count := 0;
X                                playinfo.score := playinfo.score + 500;
X                            end;
X                        end else
X                            playinfo.score := playinfo.score + 50;
X                end;
X                case piece_info`5B piece `5D.SideInfo`5Boil_posn_side`5D.Exi
Vt_side of
X                    North : begin
X                        oil_posn_y := oil_posn_y - 1;
X                        oil_posn_side := South;
X                    end;
X                    South : begin
X                        oil_posn_y := oil_posn_y + 1;
X                        oil_posn_side := North;
X                    end;
X                    East  : begin
X                        oil_posn_x := oil_posn_x + 1;
X                        oil_posn_side := West;
X                    end;
X                    West  : begin
X                        oil_posn_x := oil_posn_x - 1;
X                        oil_posn_side := East;
X                    end;
X                 end;
+-+-+-+-+-+-+-+-  END  OF PART 2 +-+-+-+-+-+-+-+-
