Path: uunet!haven.umd.edu!darwin.sura.net!gatech!nntp.msstate.edu!emory!dragon.com!cts
From: cts@dragon.com
Newsgroups: vmsnet.sources.games
Subject: Dungeon Part 20/30
Message-ID: <1992Feb24.013134.813@dragon.com>
Date: 24 Feb 92 06:31:34 GMT
Organization: Computer Projects Unlimited
Lines: 1177

-+-+-+-+-+-+-+-+ START OF PART 20 -+-+-+-+-+-+-+-+
X<1E0001F1B5000201F10201EE0201EF0201ED0201E70202EA0202D90201E60201DB0204FCF6
X<1E0001F1D3000201FBFBFBFC0201FD0201FDF70201ED0201F90201F9F9FDFE0201F2F4EE83
X<1E0001F1F1000201FC0201F90201FA0201F70201FC0201F70202FA0201F9DF0201F9F90244
X<1E0001F20F0002D29CB90201FC0201F60205FCDFFA0E0B090B03000201F70205FCFC0201B7
X<1E0001F22D00F9F70201F10201FC0201F60204FC0202E00201F7F90201FC0201F90201F817
X<1E0001F24B000201FA0201F40201F8F20201FE0201F8F9F40214FC0201F90201FA0201F7D5
X<1E0001F269000201F70201F1E6FA0201F7E30201FC0201F4F2D70E04093E03000201F302C8
X<1E0001F2870001F90201FA0201F70201E30201FC0201F70201F20E04092F01000201F4025F
X<1E0001F2A50001F70201E30201F3FC06BF00960D000001BD0DBC000100000006564150504D
X<1E0001F2C3004C490DBE0084F5010006564150504C49C2B902080002A7F70202FC0201E870
X<1E0001F2E1000201F0F0ED0202EF0201F80201F50201F30208019300020FF00201F50201C8
X<1E0001F2FF00F80201FC0201FAE80201F70201FCE50201F70201FCDD0203FCE80209FC026E
X<1E0001F31D0001E80204FC0202E40201F60201F60203FC0201F40203FCE80203FCE802033D
X<1E0001F33B00FCE80203FCFDEB0203FCE80203FCE80204FC0201ED0201FAE1F70203FCE567
X<1E0001F359000201F70201FC0201E90203FCE40201F70201FC0201F8E10201F70203FCE516
X<1E0001F377000201F70201FCE50201F70201FC0201FE0203F6F7FA0204FD0201F00201FAC0
X<1E0001F39500E1C2B90201F70203FC0203F90203F60203FA0201F60201EF0201F50201F52F
X<1E0001F3B3000201F20201F90203FC0201EFE70201F70201FC0201D30201F60201F70201AB
X<1E0001F3D100FC0201F50201ED0201FAEB0201FB0201F70201FE0201F60201F0FB0203FC70
X<1E0001F3EF000201EE0201FAEE0201F70204FC0201F10201F10201DF0201F70201FCE4027E
X<1E0001F40D0001F70201FCDFF70201E80203FC0201F10201DF0201F70201FCE40201F70278
X<1E0001F42B0001FCD3F70201EB0203FC0201ED0204E1F20201F70201FCF40201F70201FC5D
X<1E0001F44900DA0201DF0201F70201FC0201F60203FCC4B90201ED0E1B09F601000201F765
X<1E0001F46700021BFCF50201F70201FC0201F60201F70201FCD40201F70204FC0201F002C8
X<1E0001F4850001FA0201F10201F10201F9FB0202B00201FAF00201F5FA0201EF0201FCFA10
X<1E0001F4A3000201F70203FC0201F6FDF0FC0204FC000201EB0203FCE40201F70201FC029D
X<1E0001F4C10001F20201F70201FC0201F80201F70201FC0201EE0201F7F4E80203FC020181
X<1E0001F4DF00F60201F70201FC0201F0E50201F70201FCF6F7E10203FCFE0203F6F502048B
X<1E0001F4FD00FC0201F8D10201F70201FD0201FC0201FA0201EE0201E80203FC000201F062
X<1E0001F51B000201F5C3B90201F60205EF0201F30201F70201FC0201F70201FC0201F3028E
X<1E0001F5390001F20E1009AD02000201F70210F90201E70201F70205FC0201F50E0409C625
X<1E0001F5570002000201F40207FC0201C30201EE0201F20201E3E30201F4F7F70201FC023C
X<1E0001F5750001F30201E80201FB0201F60201E20201F70201FC0201F4F70201FC0201F5DE
X<1E0001F593000201FC0201F40204FC0201F7E7EB0203FC0201FA0203FE0201FCFBFCFCFBA7
X<1E0001F5B100FC0204F90203FA0201FB0201F70201FC0201EDE70201DE0201FC0201F9FB9C
X<1E0001F5CF00E70201FC0201F50201F70201FC0201FA0201F7C3B90204FCFF0203F6F502E0
X<1E0001F5ED0003FCFD0203F6FE000201000203F6E00201F70201FCF80203FCE10201F7025D
X<1E0001F60B0001FCF80204FC0201FA0201DE0201FC0201F70201F70201FC0201F50201FA24
X<1E0001F629000201FA0201E8F10201F70201FC0201F00201FAD30202F70203FC0201F0E45A
X<1E0001F647000201F60201F70205FCE30201DA0E1E099703000201F70205F90201F7020128
X<1E0001F66500FC0201F10201F70201FC0201F40203FC0201E80204FC0201E70201F70201D1
X<1E0001F68300FC0201F90E0709F700000201EB03CB02FC0201E90205FCFD000201F80201B7
X<1E0001F6A100EFE30201F125B90201EDFA0201F70202DB0201F70201FC0201F60202FB0EE4
X<1E0001F6BF000A09D50000FE0E1009D100009406BF001813000001BD0DBC0001000000063C
X<1E0001F6DD00434C4F434B440DBE009C08020006434C4F434B4419B90204000213F7020150
X<1D0001F6FB00FDE8F70201FEFE0201FEFC0201F3F9FB06BF005000000001BD0DBC000192
X<1E0001F71B000654524F4C4C500DBE00EC0802000654524F4C4C5090B90208000282F70278
X<1E0001F7390001FC0201DE0201F00201FB0201F50201FBF80201ED0201FC0201F90201F90D
X<1E0001F757000201FC0201F70201F9D50201F60201FC0201F80201FAE30201F6ED0201FC11
X<1E0001F775000203F80201F70201DA0201F50201F7E3FAF60201F7EB0201F70201FC0201FB
X<1E0001F79300F20201F70201FC0201F50201FB0201F00201E80201F60201F70201FC0201A3
X<1D0001F7B100F6E10201FCF20201F70201FC0201FFFD06BF007302000001BD0DBC0001B8
X<1E0001F7D100064359434C4F500DBE00600B0200064359434C4F506AB90204000281F7029C
X<1E0001F7EF0001FC0201E40202D40201FD0201F8F1BD0201FCEC0201F10201FC0201F802BB
X<1E0001F80D0001FC0201F30201F00201F80201EB0201FC0201F5FA0201F80201FCBD020162
X<1E0001F82B00FC0205F40201FB0208F00201FE0201F9E1F5F60E0409BC00000201F5F6F64B
X<1E0001F84900D90E0509B60000FD06BF003B02000001BD0DBC0001000000065448494546F8
X<1E0001F86700500DBE009C0D020006544849454650C3B902040002B4F70201FC0201DE02E5
X<1E0001F8850001EA0201F50201F80201ED0201FC0201F70201ED0201FC0201F60201FAE1D7
X<1E0001F8A300FE0201ECF20202F4FB0201F30201D1E90201EFFB0201FEE0FA0201FC0202F6
X<1E0001F8C100FA0201F60201EAF70201FC0201F90201FA0201F5D0DF0201FC0201F70201B6
X<1E0001F8DF00EB0201F90201F5DF0201B70201FC0201F70201F70201FC0201CF0201F402D5
X<1E0001F8FD0001F7DF0201FC0201FAED0201F6FBF7FB0201F40201FC0201D90201F4F7F98D
X<1E0001F91B00DFF50201F70201D90201F70201FC0201E70201F5EF0201FC0201E9F9020172
X<1E0001F93900FC03B900FD06BF009704000001BD0ABC000100000003414E440ABE00341231
X<1E0001F95700020003414E4406B9000202F7F606BF001300000001BD0DBC000100000006A3
X<1E0001F97500494E49524E440DBE004812020006494E49524E4407B9000203FEF8FF06BF3F
X<1E0001F994000B00000001BD0CBC0001000000054954494D450CBE00541202000549544928
X<1C0001F9B2004D4515B9000203F70201F8F40201F5F40201F5F40201F5FF06BF005702
X<1E0001F9D10001BD0EBC000100000007474554555345520EBE00AC1202000747455455534D
X<1B0001F9EF0045520BB9000206EFEDFBFCFDF8FF06BF003900000001BD0ABC00014F
X<1E0001FA0D0003524E440ABE00E812020003524E4406B9000204F7EE06BF001B00000001BD
X<1E0001FA2B00BD09BC0001000000024F5209BE0004130200024F5206B9000202F7F906BF9B
X<1E0001FA4A001000000001BD0DBC00010000000653595354454D0DBE001413020006535974
X<1D0001FA68005354454D0DB9000201ECF70201F50201F8FF06BF003100000001BD0DBC2C
X<1E0001FA8600010000000657495A4152440DBE00481302000657495A4152440CB9000213B0
X<1E0001FAA400F7FDF8FCEEFCE5FB06BF004E00000001BD0ABC000000000003584F520ABE36
X<1E0001FAC40014020003584F5214B80000140200092E20424C414E4B202E0F00000001BD55
X<000001FC000003
X<000001FC00FA09
X<00000000000000
$ CALL UNPACK DUNGEON.HEX;1 1078712267
$ create 'f'
X        .TITLE  DEHEX
X        .SBTTL  Stuart Hecht and Eric McQueen, Stevens Inst of Technology
X
X        .LIBRARY /SYS$LIBRARY:STARLET/
X        .LIBRARY /SYS$LIBRARY:LIB/
X        .IDENT   /1.1.02/
X;++
X;1.1.01
X;Updated March 9, 1898, by Susan Webb and Jerry Holliday of Lockheed Aircraf
Vt
X;Systems Co, Marietta, GA, to work for files longer than 64K.  Added lines
X;marked with ";JH".
X;--
X;++
X;1.1.02
X;Updated March 15, 1989, by Tom Allebrandi of Advanced Computer Consulting,
X;Inc, Charlottesville, VA. (ta2@acci.com)
X;
X;On March 14, 1989, I pulled this file and VMSMIT.HEX from Columbia via
X;KERMSRV. After compiling, this utility would not decode the VMSMIT file.
X;The problem was the 1.1.01 fix noted above.
X;
X;I have removed the 1.1.01 fix and coded it so that it works correctly.
X;My changes are marked ";ta2"
X;--
X
X;++
X;This will take a set hexidecimal strings created by the hexify program and
X;  recreate the source file(s).
X;--
X
X        .EXTRN  LIB$GET_INPUT
X        .EXTRN  LIB$PUT_OUTPUT
X        .EXTRN  DSC$K_DTYPE_T
X        .EXTRN  DSC$K_CLASS_S
X        .EXTRN  SS$_NORMAL
X        .MCALL  $FAB                            ; RMS calls
X        .MCALL  $RAB
X        .MCALL  $CLOSE
X        .MCALL  $CONNECT
X        .MCALL  $CREATE
X        .MCALL  $DISCONNECT
X        .MCALL  $GET
X        .MCALL  $OPEN
X        .MCALL  $WRITE
X        .MCALL  $RAB_STORE
X        .MCALL  $FAB_STORE
X
X        .SBTTL  Definitions of symbols
X
XDWRLUN  =1                              ; Disk read LUN
XDWWLUN  =5                              ; Disk write LUN
XTRUE    =1                              ; True
XFALSE   =0                              ; False
XKNORMAL =0                              ; No error
XLEFTBYTE=`5EO377*`5EO400                    ; All ones in left byte
XHEXOFFSET=7                             ; Offset to get to 'A from '9+1
XCR      =13.                            ; Carriage return
XLF      =10.                            ; Line feed
XMAX.MSG =256.                           ; Maximum number of chars from XK
XRCV.SOH =`5EA/:/                          ; Receive start of packet
XRCV.EOL =13.                            ; End of line character
XMSB     =128.                           ; Most significant bit
X; Packet types currently supported
XPKDATA  =00                             ; Data packet code
XPKRFM   =255.                           ; Record format
XPKRAT   =254.                           ; Record attributes
XPKMRS   =253.                           ; Maximum record size
XPKALQ   =252.                           ; File length(blocks)
XPKFILNM =251.                           ; File name
XPKEOF   =250.                           ; End of task file
X;
X
X
X        .SBTTL  RMS Data
X
X        .PSECT  $PLIT$,LONG
X
XDEFALT: .ASCIZ  'SYS$DISK:'             ; System default.
XDEFALN  =.-DEFALT                       ; Size of the default device.
X        .EVEN
X
X        .SBTTL  Data
X
X
XM$FILE: .BYTE   CR,LF
X        .ASCII  'Please type the file name: '
XL$FILE= .-M$FILE
X
XM$CRLF: .BYTE   CR,LF                   ; Data for carriage return/line feed
XL$CRLF  =.-M$CRLF
X
X;M$AK:
X;       .ASCII  'Y'                     ; Data for aknowledged
X
XM$NAK:
X        ;.ASCII 'N'                     ; Data for not aknowledged
X        .ASCII  'BAD CHECK SUM'         ; Data for not aknowledged
XL$NAK   =.-M$NAK
X
XM$UN:
X        ;.ASCII 'U'                     ; Data for unrecognized code
X        .ASCII  'UNKNOWN BLOCK TYPE'    ; Data for unrecognized code
XL$UN    =.-M$UN
X
XM$RMS:  .BYTE   CR,LF,LF
X        .ASCII  'RMS ERROR'
XL$RMS   =.-M$RMS
X
XM$REC:  .BYTE   CR,LF,LF
X        .ASCII  'RECEIVE ERROR - Try again.'
XL$REC   =.-M$REC
X        .EVEN
X
X
X        .SBTTL  Storage locations
X
X        .PSECT  $OWN$,LONG
X        .ALIGN  LONG
X
XMSGDSC: .BLKW   1                       ; Data block for terminal output
X        .BYTE   DSC$K_DTYPE_T
X        .BYTE   DSC$K_CLASS_S
XADDR:   .ADDRESS ADDR
XLNGADR: .BLKL   1
X
XINP_STR_D:                              ; Key string desciptor
X         .BLKL  1
XINP_BUF: .ADDRESS ADDR
X
XINP_STR_LEN: .BLKL 1                    ; Key string length
X
XWTCOUNT: .BLKL  1                       ; Number of characters written
XLENGTH: .BLKL   1                       ; Length of data portion of packet
XOPENFL: .BLKL   1                       ; Tells us if the file is open
X
XCHKSUM: .BLKL   1                       ; Checksum for the line
XADDRESS: .BLKL  1                       ; Current address
XALQLOC: .BLKW   2                       ; Storage for allocation
X
XOUT.N:  .BLKB   28.                     ; Space for output file name
XOUT.L   =.-OUT.N                        ; Length of output file name
X
XINP.N:  .BLKB   28.                     ; Space for input file name
XINP.L   =.-INP.N                        ; Length of input file name
X
X        .EVEN                           ; Need to start RDBUF on even bounda
Vry
XRDBUF:  .BLKB   MAX.MSG                 ; XK read buffer
X        .EVEN
XWTBUF:  .BLKB   512.                    ; Disk write buffer
X        .EVEN
X
X
X
X        .SBTTL  RMS Data structures
X        .ALIGN  LONG
X
XRDFAB:: $FAB    DNA=DEFALT,DNS=DEFALN,FNA=INP.N,FNS=INP.L,-
X                LCH=DWRLUN,FAC=GET,SHR=GET
X
X        .ALIGN  LONG
XRDRAB:: $RAB    FAB=RDFAB,RAC=SEQ ; Beginning of RAB block.
X
X        .ALIGN  LONG
XWTFAB:: $FAB    DNA=DEFALT,DNS=DEFALN,FNA=OUT.N,FNS=OUT.L,-
X                LCH=DWWLUN,FAC=PUT,SHR=NIL
X
XWTRAB:: $RAB    FAB=WTFAB,RAC=SEQ ; Beginning of RAB block.
X
X
X        .SBTTL  Start of program
X
X        .PSECT  $CODE$,LONG,EXE
X
XDEHEX:: .WORD   `5EM<>
XFILE:   MOVAB   M$FILE,R11              ; Output the get file name message
X        MOVZBL  #L$FILE,R12
X        MOVAB   INP.N,R10               ; Get the file name
X        MOVZBL  #INP.L,R1
X        JSB     READ
X        TSTL    R0                      ; Check for no input
X        BEQL    FILE                    ; Go back and get some
X;Open the file
X        MOVAL   RDFAB,R1                ; Put address of FAB into R1.
X        $FAB_STORE FAB=R1,FNS=R0        ; Tell RMS file name length
X        $OPEN   #RDFAB                  ; Open the file
X        JSB     RMSERR                  ; Check for file error
X        MOVAL   RDRAB,R1                ; Put address of RAB into R1.
X; Put address of user buffer and size and record buffer and size in RAB.
X        $RAB_STORE RAB=R1,UBF=RDBUF,RBF=RDBUF,USZ=#MAX.MSG,RSZ=#MAX.MSG
X        $CONNECT #RDRAB                 ; Connect to record.
X        JSB     RMSERR                  ; Check for file error
X
X
X        .SBTTL  Do the real work
X;++
X; Do the actual work
X;--
XBEGIN:  MOVAL   M$CRLF,R10              ; Get a return/linefeed and output t
Vhem
X        MOVZBL  #L$CRLF,R1
X        JSB     WRITE
X
X20$:    CLRL    WTCOUNT                 ; Initialize the pointer
X        CLRL    ADDRESS                 ; Initialize the address
X        CLRL    OPENFL                  ; Set the file to not open
X
X        .SBTTL  Main loop
X
X; Main loop to get data
XDOLIN:
X        CLRL    CHKSUM                  ; Clear the checksum
X        JSB     RECEIVE                 ; Get the line
X        JSB     CVTBIN                  ; Convert it to a real number
X        MOVL    R10,LENGTH              ; Save the length
XNAB:    JSB     CVTBIN                  ;
X        BISL    R10,R3                  ; Save a byte of the address
X        ASHL    #8.,R3,R3               ; Make room for next byte
X        SOBGEQ  LNGADR,NAB              ; If there are more than 2 bytes
X        JSB     CVTBIN                  ;
X        BISL    R10,R3                  ; Fill in the low byte of address
X
X;ta2 The fix for 1.1.01 converted two more hex values here. As of March
X;    1989, this doesn't appear to be required. The conversion has been
X;    removed.
X
X        JSB     CVTBIN                  ;ta2 Pick up the record type code
X
X        CMPL    #PKDATA,R10             ; Check to see if this is regular da
Vta
X        BNEQ    NOTDAT                  ; If not then check the special case
Vs
X; Check for end of hex file
X        TSTL    R3                      ; Check to see if the address is all
X        BNEQ    DATST                   ;  zero, if not then branch
X        TSTL    LENGTH                  ; Check to see if the length is zero
X        BNEQ    DATST                   ;  also, if not then branch
X        JMP     FINISH                  ; Must be end of hex file so finish
V up
X; Regular data to put into the file
XDATST:  TSTL    OPENFL                  ; Check to see if the file is open y
Vet
X        BNEQ    DAT1                    ; If it is then skip the open
X        JSB     OPEN                    ; Open the file
XDAT1:   CMPL    R3,ADDRESS              ; Check for null compression
X        BEQL    10$                     ; If none compressed then continue p
Vast
X        CLRL    R10                     ; Make a null
X        JSB     PUT                     ;  and put it into the file
X        INCL    ADDRESS                 ; Point to next address
X        BRW     DAT1                    ; Go see if there are any more nulls
X; Go to work on the HEX we got on the line
X10$:    MOVL    LENGTH,R2               ; Get the length
X        TSTL    R2                      ; See if there is any data
X        BEQL    30$                     ; If not then branch
X25$:    JSB     CVTBIN                  ; Convert it
X        JSB     PUT                     ; Put the character in the file
X        INCL    ADDRESS                 ; Increment the address
X        SOBGTR  R2,25$                  ; Repeat until all done
X30$:    BRW     LINDON                  ; Go finish this line
X
X
X
XNOTDAT: MOVAL   WTFAB,R5                ; Get the FAB address
X        CMPL    #PKRFM,R10              ; Check to see if this is record fmt
X        BNEQ    NOTRFM                  ; If not then don't do this stuff
X; Store the Record format (FIX, VAR, ...)
X        JSB     CVTBIN                  ;
X        $FAB_STORE FAB=R5,RFM=R10       ; Store the record format
X        BRW     LINDON                  ; Go finish this line
X
XNOTRFM: CMPL    #PKRAT,R10              ; Check to see if this is record typ
Ve
X        BNEQ    NOTRAT                  ; If not then branch
X; Store the record type (CR, ...)
X        JSB     CVTBIN                  ;
X        $FAB_STORE FAB=R5,RAT=R10       ; Store the record type
X        BRW     LINDON                  ; Go finish this line
X
XNOTRAT: CMPL    #PKMRS,R10              ; Check to see if this is max record
X        BNEQ    NOTMRS                  ;  size, branch if not
X; Get the maximum record size (512. for tasks)
X        JSB     CVTBIN                  ; Convert high order byte
X        MOVL    R10,R3                  ; Save it
X        ASHL    #8.,R3,R3               ; Shift it to the high order byte
X        JSB     CVTBIN                  ; Convert low order byte
X        BISL    R10,R3                  ; Put low order word into R3 also
X        $FAB_STORE FAB=R5,MRS=R3        ; Store the maximum record size
X        BRW     LINDON                  ; Go finish this line
X
XNOTMRS: CMPL    #PKALQ,R10              ; Check to see if this is allocation
X        BNEQ    NOTALQ                  ; If not then branch
X; Get the file length (in blocks)
X        JSB     CVTBIN                  ; Convert high order byte
X        MOVL    R10,R3                  ; Save it
X        ASHL    #8.,R3,R3               ; Shift it to the high order byte
X        JSB     CVTBIN                  ; Convert low order byte
X        BISL    R10,R3                  ; Put low order word into R3 also
X        MOVZWL  R3,ALQLOC               ; Save it
X        $FAB_STORE FAB=R5,ALQ=ALQLOC    ; Store the allocation
X        BRW     LINDON                  ; Go finish this line
X
XNOTALQ: CMPL    #PKFILNM,R10            ; Check to see if this is file name
X        BNEQ    NOTFILNM                ; If not then branch
X; Get the file name
X        MOVL    LENGTH,R2               ; Get the length
X        $FAB_STORE FAB=R5,FNS=R2        ; Store the file name length
X        MOVAB   OUT.N,R3                ; Get the output file name address
X25$:    JSB     CVTBIN                  ; Convert next character of the name
X        MOVB    R10,(R3)+               ; Save the character
X        SOBGTR  R2,25$                  ; Repeat until all done
X        MOVAB   M$CRLF,R10              ;
X        MOVZBL  #L$CRLF,R1              ;
X        JSB     WRITE                   ; Output a return/line feed
X        MOVAB   OUT.N,R10               ;
X        MOVL    LENGTH,R1               ;
X        JSB     WRITE                   ; Output the file name
X        MOVAB   M$CRLF,R10              ;
X        MOVZBL  #L$CRLF,R1              ;
X        JSB     WRITE                   ; Output a return/line feed
X        BRW     LINDON                  ; Go finish this line
X
X
X
XNOTFILNM:
X        CMPL    #PKEOF,R10              ; Check to see if this is end of tas
Vk
X        BNEQ    NOTPKEOF                ; If not then branch
X; End of ouput file record found
X        JSB     CLTSK                   ; Close the task file
X        CLRL    WTCOUNT                 ; Initialize the pointer
X        CLRL    ADDRESS                 ; Initialize the address
X        JMP     LINDON                  ; Go finish this line
X
X; Unknown code
XNOTPKEOF:                               ; Since we don't know what the code
X        MOVAB   M$UN,R10                ;   just send the unknown code text
V to
X        MOVZBL  #L$UN,R1                ;   the terminal
X        JSB     WRITE                   ;
X        JMP     DOLIN                   ; Go do next input line
X
X
X        .SBTTL  Finished with this line
X
X; Line processed without a problem
XLINDON:
X;       MOVAB   M$AK,R10                ; Get the data address of the
X                                        ;  single character
X;       MOVZBL  #1,R1                   ; Only write single char to terminal
X;       JSB     WRITE                   ; Write to the terminal
X        JMP     DOLIN                   ; Good so do next line
X
X
X        .SBTTL  Finish up
X;++
X;Finish up
X;--
XFINISH:
X; Close the file(s)
X        JSB     CLTSK                   ; Close the task file if it isn't ye
Vt
X        MOVAL   RDFAB,R1                ; Get FAB for input file
X        $CLOSE  R1                      ; Close the input file
X        JSB     RMSERR                  ; Check for file error
XEND:    MOVL    #SS$_NORMAL,R0          ; Set up successful completion
X        RET
X
X        .SBTTL  Close file
X
X;++
X; Close the output file if there is one open
X;
X; If there is an error the program stops with an RMS error
X;
X; Registers destroyed:  R0, R1
X; The OPENFL state is changed to file not open (OPENFL=0).
X;--
X
XCLTSK:  TSTL    OPENFL                  ; See if the task file is open
X        BEQL    10$                     ; If not then just return
X
X; Write last buffer if needed
X        TSTL    WTCOUNT                 ; See if there is any data not writt
Ven
X        BEQL    8$                      ; If not then branch
X        MOVAL   WTRAB,R1                ; Get the RAB address
X        $RAB_STORE RAB=R1,RSZ=WTCOUNT   ; Put its size into the RAB.
X        $WRITE  R1                      ; Put the buffer of data.
X        JSB     RMSERR                  ; Check for file error
X
X; Close the file
X8$:     MOVAL   WTFAB,R1                ; Get FAB for output file
X        $CLOSE  R1                      ; Close output file
X        JSB     RMSERR                  ; Check for file error
X        CLRL    OPENFL                  ; Set the state to file not open
X10$:    RSB                             ; Return to sender
X
X
X        .SBTTL  Output and input to/from terminal
X;++
X; Write data to terminal.
X;       R10     Address of data to output
X;       R1      Length of data
X;--
XWRITE:
X        MOVW    R1,MSGDSC               ; Store the length in the descript b
Vlk
X        MOVL    R10,ADDR                ; Store the address of the ASCII
X        PUSHAQ  MSGDSC                  ; Push the descriptor block address
X        CALLS   #1,G`5ELIB$PUT_OUTPUT     ; Do the output
X        RSB                             ; Return to sender
X
X;++
X; Read from the terminal
X;       R10     Address of buffer
X;       R1      Number of characters to read
X;       R11     Input prompt address
X;       R12     Length of prompt
X;
X;Returned:
X;       R0      Number of characters read
X;--
XREAD:
X        MOVL    R1,INP_STR_D            ; Store the buffer length in desc bl
Vock
X        MOVL    R10,INP_BUF             ; Store the buffer address in desc b
Vlk
X        MOVL    R11,ADDR                ; Store prompt address in desc block
X        MOVW    R12,MSGDSC              ; Store length in desctriptor block
X        PUSHAB  INP_STR_LEN             ; Address for string length
X        PUSHAQ  MSGDSC                  ; Push address of prompt descriptor
V blk
X        PUSHAB  INP_STR_D               ; String buffer descriptor
X        CALLS   #3,G`5ELIB$GET_INPUT      ; Get input string value
X        MOVL    INP_STR_LEN,R0          ; Get actual input length back
X        RSB                             ; Return to sender
X
X
X        .SBTTL  RMS error routine
X;++
X;Check for RMS error
X; Call with:            R0      Status of last RMS call (automatically store
Vd
X;                                 in R0 by RMS after an operation)
X;
X; Returned:             R0      Status
X; Registers destroyed:  R0
X; Program stops after error message is displayed if there is any type of err
Vor.
X;--
XRMSERR:
X        BLBC    R0,60$                  ; If error, go check it out
X        MOVL    #KNORMAL,R0             ; Set up a successful return code.
X        RSB                             ; Return to caller
X
X; Here if there is an RMS error we don't know how to handle
X60$:    PUSHL   R0                      ; Save the error code
X        MOVAB   M$RMS,R10               ; Get the address and length of the
X        MOVL    #L$RMS,R1               ;   message to output
X        JSB     WRITE                   ; Output it
X        POPL    R0                      ; Get the error code back
X        RET                             ; Exit program
X
X
X        .SBTTL  Open the output file
X;++
X; Create and open the output file and set the file open flag
X;
X; Registers destroyed:  R0, R1
X; Program stops after error message is displayed if there is any type of err
Vor.
X;--
X
XOPEN:   MOVL    #TRUE,OPENFL            ; State that the file is open
X        MOVAL   WTFAB,R1                ; Put address of FAB into R1.
X        $FAB_STORE FAB=R1,FAC=<BIO,GET> ; Set the block I/O in FAB.
X        ;$FAB_STORE FAB=R1,FOP=CTG      ; Tell RMS to make the task contiguo
Vus
X        $CREATE #WTFAB                  ; Create the file
X        JSB     RMSERR                  ; Check for file error
X        MOVAL   WTRAB,R1                ; Put address of RAB into R1.
X; Put address of user buffer and record buffer and sizes into RAB
X        $RAB_STORE RAB=R1,UBF=WTBUF,RBF=WTBUF,USZ=#512.,RSZ=#512.
X        $CONNECT #WTRAB                 ; Connect to record.
X        JSB     RMSERR                  ; Check for file error
X        RSB                             ; Return to sender
X
X        .SBTTL  Put a character to the file
X;++
X; Put a character to the output file.
X; The buffer is only written when 512. characters have been sent to the rout
Vine
X; If the file does not end on a boundary then the buffer will have to be
X; written by some other routine.
X;
X; Call with:            R10     Contains the character to be put into file
X; Registers destroyed:  R1, R10
X;
X; Program stops after error message is displayed if there is any type of err
Vor.
X;--
X
XPUT:    PUSHL   R10                     ; Save the character
X        MOVL    WTCOUNT,R10             ; Get the offset into the buffer
X        MOVB    (SP),WTBUF(R10)         ; Put the character
X        TSTL    (SP)+                   ; Restore the stack
X        INCL    WTCOUNT                 ; Increment the offset into the buff
Ver
X        CMPL    WTCOUNT,#512.           ; Check to see if we are past the en
Vd
X        BNEQ    10$                     ; If not then branch
X        MOVAL   WTRAB,R1                ; Get the RAB address
X        $RAB_STORE RAB=R1,RSZ=WTCOUNT   ; Put its size into the RAB.
X        $WRITE  R1                      ; Put the buffer of data.
X        JSB     RMSERR                  ; Check for file error
X        CLRL    WTCOUNT                 ; Clear the pointer
X10$:    RSB                             ; Return to sender
X
X        .SBTTL   Convert to binary
X;++
X; Convert 2 hexidecimal digits to binary
X; Input is from the input buffer pointed to by R4 (it is incremented twice)
X;
X; Call with:            R4      The pointer into the input buffer
X; Returned:             R10     The binary walue
X; Registers destroyed:  R10,R1
X;--
X
XCVTBIN:
X        CLRL    R10                     ; Clear R10 for the BISB
X        BISB    (R4)+,R10               ; Get the next digit
X        JSB     BIN                     ;   in place and convert to binary
X        ASHL    #4,R10,R10              ; Multiply the result by 16
X        MOVL    R10,R1                  ;  and save it
X        CLRL    R10                     ; Clear R10
X        BISB    (R4)+,R10               ; Get the next digit
X        JSB     BIN                     ; Convert to binary
X        BISL    R1,R10                  ; Set the correct bits for high orde
Vr
X        ADDL2   R10,CHKSUM              ; Add the value to the checksum
X        RSB                             ; Return to sender
X
XBIN:    CMPL    R10,#`5EA/9/              ; Check to see if above '9
X        BLEQ    1$                      ; If not then branch
X        SUBL2   #HEXOFFSET,R10          ; Subtract offset to alphabet
X1$:     SUBL2   #48.,R10                ; Make binary
X        RSB                             ; Return to sender
X
X
X        .SBTTL  Receive a line of data
X
X;++
X; This will get a line of data from the input device
X;
X; Returned:             R4      Address of start of data buffer
X; Registers destroyed:  R0, R1, R3, R4
X;
X; A checksum error will cause a NAK to be sent and input to be read again
X; A real error will cause an error message to be output and the program to s
Vtop
X;--
X
XRECEIVE:
X; Here to read from a file
X        MOVAL   RDRAB,R1                ; Get the RAB address
X        $GET    R1                      ; Get the record
X        JSB     RMSERR                  ; Check for file error
X        MOVZWL  #MAX.MSG,R3             ; Assume we got a full buffer
X; Here to check the data we got
XRECCHK: MOVAL   RDBUF,R4                ; Get the address of the information
X        CLRL    R1                      ; Clear the data start address
X80$:    BICB    #MSB,(R4)               ; Clear parity bit
X        SUBB3   #RCV.SOH,(R4)+,R0       ; Check for start of header
X        BLSS    81$                     ; If not, just keep going
X        CMPB    R0,#2                   ; There are 3 possible headers
X        BGTR    81$                     ; Not a header
X        MOVZBL  R0,LNGADR               ; Amount of extra bytes in the addre
Vss
X        MOVL    R4,R1                   ; Start of header so save it
X81$:    SOBGTR  R3,80$                  ; Repeat until done
X        TSTL    R1                      ; Check to see if we got a SOH
X        BNEQ    85$                     ; If good then skip the jump
X        JMP     RECEIVE                 ; If not then re-read
X85$:    MOVL    R1,R4                   ; Move to R4 for use
X        PUSHL   R4                      ; Save SOH pointer on stack
X
X        JSB     CVTBIN                  ; Convert all to binary to see if
X                                        ;   checksum is correct
X        MOVL    R10,R3                  ; Get the length of data
X        ADDL2   #4,R3                   ; Add the length of address and fiel
Vd
X                                        ;   type and checksum
X        ADDL2   LNGADR,R3               ; If long address, skip more bytes
X        BLSS    94$                     ; If we have a negative number then
X                                        ;   must have been a bad length
X        CMPL    R3,#MAX.MSG/2-1         ; If we got some length that is out
V of
X        BGEQ    94$                     ;   range then NAK right away
X92$:    JSB     CVTBIN                  ; Convert all to binary to see if
X        SOBGTR  R3,92$                  ;   the checksum is OK
X93$:    BICL    #LEFTBYTE,CHKSUM        ; We only want an 8 bit checksum
X        TSTL    CHKSUM                  ; Test for a zero checksum
X        BEQL    95$                     ; If OK then exit normally
X94$:    CLRL    CHKSUM                  ; Clear the checksum for the line
X        MOVAL   M$NAK,R10               ; Get the address of the message
X        MOVZBL  #L$NAK,R1               ; Only write the first character to
X        JSB     WRITE                   ;   the terminal
X        TSTL    (SP)+                   ; Pull the pointer off the stack
X        JMP     RECEIVE                 ; Try to get the line again
X
X; Return to sender
X95$:    POPL    R4                      ; Get the pointer back
X        RSB                             ; Return to sender
X
X
X        .SBTTL  End of the Dehexify
X
X        .END    DEHEX
$ CALL UNPACK VMSDEH.MAR;1 53467680
$ create 'f'
XTo:`09Dungeon Players
XFrom:`09"The Translator"
XSubj:`09Game Information
XDate:`098-OCT-80, 6-dec-85
X
X
XThis is the first (and last) source release of the PDP-11 version of`20
XDungeon.
X
XPlease note that Dungeon has been superceded by the game ZORK(tm).
XThe following is an extract from the new product announcement for
XZORK in the September, 1980 issue of the RT-11 SIG newsletter:
X
X  "'ZORK:  The Great Underground Empire - Part I' ...was developed
X   by the original authors based on their ZORK (Dungeon) game for
X   the PDP-10.  It features a greatly improved parser;  command
X   input and transcript output files;  SAVEs to any device and
X   file name;  and adaptation to different terminal types,
X   including a status line on VT100s.  Note:  this is not the
X   FORTRAN version that has been available through DECUS.  This
X   version has been completely rewritten to run efficiently on
X   small machines - up to 10 times as fast as the DECUS version.
X
X   ...ZORK runs under RT-ll, HT-ll, or RSTS/E and requires as
X   little as 20K words of memory and a single floppy disk drive.
X   The game package, consisting of an RX01-format diskette and
X   an instruction booklet, is available from Infocom, Inc.,
X   P.O. Box 120, Kendall Station, Cambridge, Ma. 02142."
X
XZORK(tm) is a trademark of Infocom, Inc.  It is available for several
Xpopular personal computers as well as for the PDP-ll.
X
X
X1.  Components
X
XDungeon is a maze-solving game for solitaire play.  It runs on any PDP-11
X(with 28KW of memory or more) or VAX-11.
X
XThe following compile and run information does not apply to the
Xf77/Unix implementation.  See the README file for information on
Xcompilation.
X
XDungeon consists of the following files:
X
X
X`09all operating systems
X`09---------------------
X
X`09DMAIN.FTN`09`09`09-program root
X`09DGAME.FTN`09`09`09-main routine
X`09DSUB.FTN`09`09`09-resident subroutines
X`09DINIT.FTN`09`09`09-initialization routine
X`09NP.FOR`09`09`09`09-parser, part 0
X`09NP1.FOR`09`09`09`09-parser, part 1
X`09NP2.FOR`09`09`09`09-parser, part 2
X`09NP3.FOR`09`09`09`09-parser, part 3
X`09GDT.FTN`09`09`09`09-game debugging tool
X`09VERBS.FTN`09`09`09-principal verbs
X`09OBJCTS.FTN`09`09`09-principal objects
X`09SVERBS.FTN`09`09`09-simple verbs
X`09DVERB1.FTN`09`09`09-auxiliary verbs, part 1
X`09DVERB2.FTN`09`09`09-auxiliary verbs, part 2
X`0C`09all operating systems (continued)
X`09---------------------------------
X
X`09ACTORS.FTN`09`09`09-character processors
X`09DEMONS.FTN`09`09`09-demon processors
X`09CLOCKR.FTN`09`09`09-clock event processors
X`09ROOMS.FOR`09`09`09-room processors
X`09NROOMS.FOR`09`09`09-new room processors
X`09SOBJS.FOR`09`09`09-simple objects
X`09NOBJS.FOR`09`09`09-new objects
X`09BALLOP.FOR`09`09`09-balloon processor
X`09LIGHTP.FOR`09`09`09-light processors
X`09VILLNS.FOR`09`09`09-villain processors
X`09DSO1.FOR`09`09`09-overlaid subroutines, part 1
X`09DSO2.FOR`09`09`09-overlaid subroutines, part 2
X`09DSO3.FOR`09`09`09-overlaid subroutines, part 3
X`09DSO4.FOR`09`09`09-overlaid subroutines, part 4
X`09DSO5.FOR`09`09`09-overlaid subroutines, part 5
X`09DSO6.FOR`09`09`09-overlaid subroutines, part 6
X`09DSO7.FOR`09`09`09-overlaid subroutines, part 7
X`09DINDX.DAT`09`09`09-initialization data base
X`09DTEXT.DAT`09`09`09-main data base `5Bbinary file`5D
X`09DUNGEO.DOC`09`09`09-this file
X
X
X`09RT11 only
X`09---------
X
X`09RTTIM.FOR`09`09`09-time subroutine
X`09RRND.MAC`09`09`09-random number generator
X`09RTCMP.COM`09`09`09-compile command file
X`09RTBLD.COM`09`09`09-link command file
X
X
X`09RSTS/E only
X`09-----------
X
X`09RTTIM.FOR`09`09`09-time subroutine
X`09RRND.MAC`09`09`09-random number generator
X`09RSTSCB.CTL`09`09`09-compile/build batch file
X
X
X`09RSX11M, RSX11M+ only
X`09--------------------
X
X`09RSXTIM.MAC`09`09`09-time subroutine
X`09RRND.MAC`09`09`09-random number generator
X`09RSXCMP.CMD`09`09`09-compile command file
X`09RSXBLD.CMD`09`09`09-task build command file
X`09D.ODL`09`09`09`09-overlay descriptor file
X
X
X`09VMS only
X`09--------
X
X`09VMSTIM.FOR`09`09`09-time subroutine
X`09VMSRND.MAC`09`09`09-random number generator
X`09VMSCMP.COM`09`09`09-compile command file
X`09VMSBLD.COM`09`09`09-link command file
X`0C2.  Installation Instructions, RT11
X
XBefore starting, please note that:
X
X  - Dungeon requires RT11 V3 or later.
X
X  - Dungeon requires Fortran-IV V2 or later, threaded code option.
X
X  - Dungeon requires 26KW of user memory (runs under SJ monitor only).
X
X  - All files (source and object) must reside on the same disk
X    (at least 2500 disk blocks are needed).
X
X  - Dungeon does not require EIS or floating point.
X
XExcept for DTEXT.DAT, all files in the distribution kit are ASCII.
XDTEXT.DAT is a binary file consisting of 76-byte fixed length records.
XIf the distribution kit consists of RT11-compatible media, then PIP
Xcan be used to transfer the files.  If the distribution kit consists
Xof DOS-compatible media, then FILEX must be used to transfer the files.
XThe /I switch (image binary) must be used to transfer DTEXT.DAT;  the
X/A (ASCII) switch should be used to transfer the other files.
X
XTo compile Dungeon, issue the following command:
X
X  .@RTCMP(cr)
X
XSeveral of the compilations will produce warning messages, but none
Xshould produce a fatal error.
X
XTo link the compiled sources, issue the following command:
X
X  .@RTBLD(cr)
X
XThe command file assumes that the Fortran-IV object time library has
Xbeen merged into the system library.  If this is not the case, edit
XRTBLD.COM and add switch /LINKLIBRARY:FORLIB.OBJ to the first command
Xline.
X
XIt is now possible to run Dungeon:
X
X  .R DUNGEO(cr)
X
XWhen invoked, Dungeon takes no more than 5-10 seconds to start up.
X
XNotes on the executable program:
X
X  - The only files needed to execute Dungeon are DUNGEO.SAV,
X    DINDX.DAT, and DTEXT.DAT.  All other files can be deleted.
X
X  - Files DINDX.DAT and DTEXT.DAT must reside on logical device SY:
X    (this can be changed with a source edit, see section 8).
X`0C3.  Installation Instructions, RSTS/E
X
XBefore starting, please note that:
X
X  - Dungeon requires RSTS/E V6C or later.
X
X  - Dungeon requires Fortran-IV V2 or later, threaded code option
X    (operation under Fortran-IV-Plus V2.5 or later will probably
X    work but is not supported).
X
X  - Dungeon requires 28KW of user memory.
X
X  - All files (source and object) must reside in the same user area
X    (at least 2500 disk blocks are needed).
X
X  - Dungeon does not require EIS or floating point.
X
XExcept for DTEXT.DAT, all files in the distribution kit are ASCII.
XDTEXT.DAT is a binary file consisting of 76-byte fixed length records.
XIf the distribution kit consists of RT11- or DOS-compatible disks,
Xthen FIT can be used to transfer the files.  For example (RT11 disk):
X
X  RUN $FIT(cr)
X  FIT>*.*/RSTS=DK:*.*/RT11(cr)
X  FIT>`5EZ
X
XIf the distribution kit consists of DOS-compatible magtape, then PIP
Xcan be used to transfer the files, providing that the magtape is
Xassigned as a DOS-label device.  For example:
X
X  ASSIGN MM0:.DOS(cr)
X  RUN $PIP(cr)
X  **.*/AS=MM:*.FTN,*.FOR,*.MAC,*.DOC,*.CTL(cr)
X  **.*/AS=MM:*.CMD,*.COM,*.ODL,DINDX.DAT(cr)
X  **.*/BL=MM:DTEXT.DAT(cr)
X  *`5EC
X  DEASS MM0:(cr)
X
XTo compile and link Dungeon, submit control file RSTSCB.CTL to the
Xbatch processor:
X
X  SUBMIT RSTSCB.CTL(cr)
X
XSeveral of the compilations will produce warning messages, but none
Xshould produce a fatal error.
X
XIt is now possible to run Dungeon:
X
X  RUN DUNGEO(cr)
X
XWhen invoked, Dungeon takes no more than 5-10 seconds to start up.
X
XNotes on the executable program:
X
X  - The only files needed to execute Dungeon are DUNGEO.SAV,
X    DINDX.DAT, and DTEXT.DAT.  All other files can be deleted.
X
X  - Files DINDX.DAT and DTEXT.DAT must reside in the user's area on
X    logical device SY: (this can be changed with a source edit, see
X    section 8).
X`0C4.  Installation Instructions, RSX11M and RSX11M+
X
XBefore starting, please note that:
X
X  - Dungeon requires RSX11M V3 (RSX11M+ V1) or later.
X
X  - Dungeon requires Fortran-IV-Plus V2.5 or later (operation under
X    Fortran-IV V2 or later will probably work but is not supported).
X
X  - Dungeon requires a 32KW user partition (mapped systems only).
X
X  - All files (source and object) must reside in the same user area
X    (at least 2500 disk blocks are needed).
X
X  - TKB should invoke BIGTKB.TSK with a large memory increment.
X
X  - The Fortran-IV-Plus object time library must be merged into
X    the system library (SYSLIB.OLB).  Further, the library must
X    be set up to invoke the short error text module ($SHORT) as
X    the default.  Task building with a separate object time library
X    produces numerous errors;  task building with a resident library
X    or the normal error text module produces an oversize task image.
X
X  - Dungeon requires EIS but not floating point.
X
XExcept for DTEXT.DAT, all files in the distribution kit are ASCII.
XDTEXT.DAT is a binary file consisting of 76-byte fixed length records.
XIf the distribution kit consists of Files-11 compatible media, then
XPIP can be used to transfer the files.  For example:
X
X  >PIP SY:*.*=MM:*.*(cr)            -requires ANSI magtape support
X
XIf the distribution kit consists of DOS- or RT11-compatible media,
Xthen FLX must be used to transfer the files.  The /IM:76. switch
X(image binary fixed length) must be used to transfer DTEXT.DAT;
Xthe /FA switch (formatted ASCII) should be used to transfer the
Xother files.  For example (DOS magtape):
X
X  >FLX(cr)
X  FLX>SY:/RS/FA=MM:*.FTN,*.FOR,*.MAC,*.DOC/DO(cr)
X  FLX>SY:/RS/FA=MM:*.CMD,*.COM,*.ODL,DINDX.DAT/DO(cr)
X  FLX>SY:/RS/IM:76.=MM:DTEXT.DAT/DO(cr)
X  FLX>`5EZ
X
XTo compile Dungeon, issue the following command:
X
X  >@RSXCMP(cr)
X
XThere should be no error messages.
X
XTo task build the compiled sources, issue the following command:
X
X  >TKB @RSXBLD(cr)
X
XIt is now possible to run Dungeon:
X
X  >RUN DUNGEON(cr)
X
XWhen invoked, Dungeon takes no more than 5-10 seconds to start up.
X`0CIf your system maintains a separate Fortran-IV-Plus object time
Xlibrary (F4POTS.OLB), then you must create a local copy of the
Xsystem library with the Fortran-IV-Plus object time library
Xmerged in and the short error text as the default.  The following
Xcommands are an example of how such a local copy could be built:
X
X  >PIP SY:*.*=LB:`5B1,1`5DSYSLIB.OLB,F4POTS.OLB(cr)`09-copy libraries
X  >LBR(cr)`09`09`09`09`09-invoke LBR
X  LBR>SHORT.OBJ=F4POTS.OLB/EX:$SHORT(cr)`09-extract $SHORT
X  LBR>F4POTS.OLB/DE:$SHORT(cr)`09`09`09-delete $SHORT
X  LBR>F4POTS.OBJ=F4POTS.OLB/EX(cr)`09`09-extract other modules
X  LBR>SYSLIB.OLB=F4POTS.OBJ(cr)`09`09`09-insert other modules
X  LBR>SYSLIB.OLB/DG:$ERTXT(cr)`09`09`09-delete dup entry
X  LBR>SYSLIB.OLB=SHORT.OBJ/RP(cr)`09`09-insert $SHORT
X  LBR>`5EZ
X  >PIP F4POTS.*;*,SHORT.OBJ;*/DE(cr)
X
XThen edit D.ODL to reference the local library instead of the
Xdefault system library:
X
X  >TEC D.ODL(cr)
X  *FS`5B1,1`5D$SY:$EX$$
X
XDungeon can now be task built as described above.
X
XNotes on the executable program:
X
X  - The only files needed to execute Dungeon are DUNGEON.TSK,
X    DINDX.DAT, and DTEXT.DAT.  All other files can be deleted.
X
X  - Files DINDX.DAT and DTEXT.DAT must reside in the user's area on
X    logical device SY: (this can be changed with a source edit, see
X    section 8).
X
X  - Exiting from Dungeon via an MCR ABOrt command instead of the QUIT
X    command will leave file DTEXT.DAT open and locked.  The file must
X    be manually unlocked before the game is next invoked:
X
X    >PIP DTEXT.DAT/UN(cr)
X`0C5.  Installation Instructions, VMS
X
XBefore starting, please note that:
X
X  - Dungeon requires VMS V1 or later.
X
X  - Dungeon requires VAX Fortran-IV V1 or later.
X
X  - All files (source and object) must reside in the user's area
X    (at least 2500 disk blocks are needed).
X
XExcept for DTEXT.DAT, all files in the distribution kit are ASCII.
XDTEXT.DAT is a binary file consisting of 76-byte fixed length records.
XIf the distribution kit consists of Files-11 compatible media, then
XCOPY can be used to transfer the files.  For example:
X
X  $ COPY MM:*.* *.*(cr)
X
XIf the distribution kit consists of DOS- or RT11-compatible media,
Xthen FLX must be used to transfer the files.  The /IM:76. switch
X(image binary fixed length) must be used to transfer DTEXT.DAT;
Xthe /FA switch (formatted ASCII) should be used to transfer the
Xother files.  For example (DOS magtape):
X
X  $ MCR FLX(cr)
X  FLX>SY:/RS/FA=MM:*.FTN,*.FOR,*.MAC,*.DOC/DO(cr)
X  FLX>SY:/RS/FA=MM:*.CMD,*.COM,*.ODL,DINDX.DAT/DO(cr)
X  FLX>SY:/RS/IM:76.=MM:DTEXT.DAT/DO(cr)
X  FLX>`5EZ
X
XTo compile Dungeon, issue the following command:
X
X  $ @VMSCMP(cr)
X
XThere should be no error messages.
X
XTo link the compiled sources, issue the following command:
X
X  $ @VMSBLD(cr)
X
XIt is now possible to run Dungeon:
X
X  $ RUN DUNGEON(cr)
X
XWhen invoked, Dungeon takes no more than 5-10 seconds to start up.
X
XNotes on the executable program:
X
X  - The only files needed to execute Dungeon are DUNGEON.EXE,
X    DINDX.DAT, and DTEXT.DAT.  All other files can be deleted.
X
X  - Files DINDX.DAT and DTEXT.DAT must reside in the user's area
X    (this can be changed with a source edit, see section 8).
X`0C6.  Warnings and Restrictions
X
XFor those familiar with the MDL version of the game on the ARPAnet,
Xthe following is a list of the major incompatabilties:
X
X`09-The first six letters of a word are considered
X`09 significant, instead of the first five.
X`09-The syntax for TELL, ANSWER, and INCANT is different.
X`09-Compound objects are not recognized.
X`09-Compound commands can be delimited with comma as well
X`09 as period.
X
XAlso, the palantir, brochure, and dead man problems are not
Ximplemented.
X
X
X7.  Abstract of Informational Printouts
X
XSUMMARY
X-------
X
X`09`09    Welcome to Dungeon!
X
X   Dungeon is a game of adventure, danger, and low cunning.  In it
Xyou will explore some of the most amazing territory ever seen by mortal
Xman.  Hardened adventurers have run screaming from the terrors contained
Xwithin.
X
X   In Dungeon, the intrepid explorer delves into the forgotten secrets
Xof a lost labyrinth deep in the bowels of the earth, searching for
Xvast treasures long hidden from prying eyes, treasures guarded by
Xfearsome monsters and diabolical traps!
X
X   No DECsystem should be without one!
X
X   Dungeon was created at the Programming Technology Division of the MIT
XLaboratory for Computer Science by Tim Anderson, Marc Blank, Bruce
XDaniels, and Dave Lebling.  It was inspired by the Adventure game of
XCrowther and Woods, and the Dungeons and Dragons game of Gygax
Xand Arneson.  The original version was written in MDL (alias MUDDLE).
XThe current version was translated from MDL into FORTRAN IV by
Xa somewhat paranoid DEC engineer who prefers to remain anonymous.
X
X   On-line information may be obtained with the commands HELP and INFO.
X`0CINFO
X----
X
XWelcome to Dungeon!
X
X   You are near a large dungeon, which is reputed to contain vast
Xquantities of treasure.   Naturally, you wish to acquire some of it.
XIn order to do so, you must of course remove it from the dungeon.  To
Xreceive full credit for it, you must deposit it safely in the trophy
Xcase in the living room of the house.
X
X   In addition to valuables, the dungeon contains various objects
Xwhich may or may not be useful in your attempt to get rich.  You may
Xneed sources of light, since dungeons are often dark, and weapons,
Xsince dungeons often have unfriendly things wandering about.  Reading
Xmaterial is scattered around the dungeon as well;  some of it
Xis rumored to be useful.
X
X   To determine how successful you have been, a score is kept.
XWhen you find a valuable object and pick it up, you receive a
Xcertain number of points, which depends on the difficulty of finding
Xthe object.  You receive extra points for transporting the treasure
Xsafely to the living room and placing it in the trophy case.  In
Xaddition, some particularly interesting rooms have a value associated
Xwith visiting them.  The only penalty is for getting yourself killed,
Xwhich you may do only twice.
X
X   Of special note is a thief (always carrying a large bag) who
Xlikes to wander around in the dungeon (he has never been seen by the
Xlight of day).  He likes to take things.  Since he steals for pleasure
Xrather than profit and is somewhat sadistic, he only takes things which
Xyou have seen.  Although he prefers valuables, sometimes in his haste
Xhe may take something which is worthless.  From time to time, he examines
Xhis take and discards objects which he doesn't like.  He may occas-
Xionally stop in a room you are visiting, but more often he just wanders
Xthrough and rips you off (he is a skilled pickpocket).
X
XHELP
X----
X
XUseful commands:
X
+-+-+-+-+-+-+-+-  END  OF PART 20 +-+-+-+-+-+-+-+-
