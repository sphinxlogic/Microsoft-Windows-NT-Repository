Path: uunet!usc!sol.ctr.columbia.edu!destroyer!cs.ubc.ca!bcsystems!spruce.pfc.forestry.ca!news.u.washington.edu!raven.alaska.edu!acad2.alaska.edu!asdmf
Newsgroups: vmsnet.sources.games
Subject: Vmsnetrek 38/47
Message-ID: <1992Nov20.203919.1@acad2.alaska.edu>
From: asdmf@acad2.alaska.edu
Date: Sat, 21 Nov 1992 00:39:19 GMT
Sender: news@raven.alaska.edu (USENET News System)
Organization: University of Alaska
Nntp-Posting-Host: acad2.alaska.edu
Lines: 628
Xref: uunet vmsnet.sources.games:538

-+-+-+-+-+-+-+-+ START OF PART 38 -+-+-+-+-+-+-+-+
X    0.3599,
X    0.3827,
X    0.4052,
X    0.4275,
X    0.4496,
X    0.4714,
X    0.4929,
X    0.5141,
X    0.5350,
X    0.5556,
X    0.5758,
X    0.5957,
X    0.6152,
X    0.6344,
X    0.6532,
X    0.6715,
X    0.6895,
X    0.7071,
X    0.7242,
X    0.7409,
X    0.7572,
X    0.7730,
X    0.7883,
X    0.8032,
X    0.8176,
X    0.8315,
X    0.8448,
X    0.8577,
X    0.8701,
X    0.8819,
X    0.8932,
X    0.9040,
X    0.9142,
X    0.9239,
X    0.9330,
X    0.9415,
X    0.9495,
X    0.9569,
X    0.9638,
X    0.9700,
X    0.9757,
X    0.9808,
X    0.9853,
X    0.9892,
X    0.9925,
X    0.9952,
X    0.9973,
X    0.9988,
X    0.9997,
X    1.0000,
X    0.9997,
X    0.9988,
X    0.9973,
X    0.9952,
X    0.9925,
X    0.9892,
X    0.9853,
X    0.9808,
X    0.9757,
X    0.9700,
X    0.9638,
X    0.9570,
X    0.9495,
X    0.9416,
X    0.9330,
X    0.9239,
X    0.9142,
X    0.9040,
X    0.8933,
X    0.8819,
X    0.8701,
X    0.8578,
X    0.8449,
X    0.8315,
X    0.8176,
X    0.8032,
X    0.7884,
X    0.7731,
X    0.7573,
X    0.7410,
X    0.7243,
X    0.7072,
X    0.6896,
X    0.6716,
X    0.6532,
X    0.6344,
X    0.6153,
X    0.5958,
X    0.5759,
X    0.5556,
X    0.5351,
X    0.5142,
X    0.4930,
X    0.4715,
X    0.4497,
X    0.4276,
X    0.4053,
X    0.3828,
X    0.3600,
X    0.3370,
X    0.3138,
X    0.2904,
X    0.2668,
X    0.2431,
X    0.2192,
X    0.1952,
X    0.1710,
X    0.1468,
X    0.1225,
X    0.0981,
X    0.0737,
X    0.0492,
X    0.0246,
X    0.0001,
X    -0.0244,
X    -0.0490,
X    -0.0735,
X    -0.0979,
X    -0.1223,
X    -0.1466,
X    -0.1709,
X    -0.1950,
X    -0.2190,
X    -0.2429,
X    -0.2666,
X    -0.2902,
X    -0.3136,
X    -0.3368,
X    -0.3598,
X    -0.3826,
X    -0.4051,
X    -0.4275,
X    -0.4495,
X    -0.4713,
X    -0.4928,
X    -0.5140,
X    -0.5349,
X    -0.5555,
X    -0.5757,
X    -0.5956,
X    -0.6151,
X    -0.6343,
X    -0.6531,
X    -0.6715,
X    -0.6895,
X    -0.7070,
X    -0.7242,
X    -0.7409,
X    -0.7571,
X    -0.7729,
X    -0.7883,
X    -0.8031,
X    -0.8175,
X    -0.8314,
X    -0.8448,
X    -0.8577,
X    -0.8700,
X    -0.8819,
X    -0.8932,
X    -0.9039,
X    -0.9142,
X    -0.9238,
X    -0.9329,
X    -0.9415,
X    -0.9495,
X    -0.9569,
X    -0.9637,
X    -0.9700,
X    -0.9757,
X    -0.9808,
X    -0.9853,
X    -0.9892,
X    -0.9925,
X    -0.9952,
X    -0.9973,
X    -0.9988,
X    -0.9997,
X    -1.0000,
X    -0.9997,
X    -0.9988,
X    -0.9973,
X    -0.9952,
X    -0.9925,
X    -0.9892,
X    -0.9853,
X    -0.9808,
X    -0.9757,
X    -0.9701,
X    -0.9638,
X    -0.9570,
X    -0.9496,
X    -0.9416,
X    -0.9330,
X    -0.9239,
X    -0.9143,
X    -0.9041,
X    -0.8933,
X    -0.8820,
X    -0.8702,
X    -0.8578,
X    -0.8449,
X    -0.8316,
X    -0.8177,
X    -0.8033,
X    -0.7884,
X    -0.7731,
X    -0.7573,
X    -0.7411,
X    -0.7244,
X    -0.7072,
X    -0.6897,
X    -0.6717,
X    -0.6533,
X    -0.6345,
X    -0.6154,
X    -0.5958,
X    -0.5759,
X    -0.5557,
X    -0.5351,
X    -0.5142,
X    -0.4930,
X    -0.4715,
X    -0.4498,
X    -0.4277,
X    -0.4054,
X    -0.3828,
X    -0.3601,
X    -0.3371,
X    -0.3138,
X    -0.2905,
X    -0.2669,
X    -0.2432,
X    -0.2193,
X    -0.1953,
X    -0.1711,
X    -0.1469,
X    -0.1226,
X    -0.0982,
X    -0.0737,
X    -0.0493,
X    -0.0247
X`125;
$ CALL UNPACK SINTAB.C;1 323794660
$ create/nolog 'f'
X/*
X * smessage.c
X */
X#include "copyright.h"
X
X#include <stdio.h>
X#include <math.h>
X#include <signal.h>
X#include <ctype.h>
X#include "Wlib.h"
X#include "defs.h"
X#include "struct.h"
X#include "data.h"
X
X#define ADDRLEN 10
X
X#define BLANKCHAR(col, n) W_ClearArea(messagew, 5+W_Textwidth*(col), 5, \
X    W_Textwidth * (n), W_Textheight, backColor);
X#define DRAWCURSOR(col) W_WriteText(messagew, 5+W_Textwidth*(col), 5, \
X    textColor, &cursor, 1, W_RegularFont);
X
Xstatic int lcount;
Xstatic char buf`09180`093;
Xstatic char cursor = '_';
X
Xchar *getaddr(), *getaddr2();
X
Xsmessage(ichar)
X    char ichar;
X`123
X    register int i;
X    char *getaddr();
X    char twochar`0912`093;
X    static char addr, *addr_str;
X
X    if (messpend == 0) `123
X`009messpend = 1;
X`009if (mdisplayed) `123
X`009    BLANKCHAR(0, lastcount);
X`009    mdisplayed = 0;
X`009`125
X`009/* Put the proper recipient in the window */
X`009if ((ichar == 't') `124`124 (ichar == 'T'))
X`009    addr = teamlet`091me->p_team`093;
X`009else
X`009    addr = ichar;
X`009addr_str = getaddr(addr);
X`009if (addr_str == 0) `123
X`009    /* print error message */
X`009    messpend = 0;
X`009    W_WarpPointer(NULL);`009/* ATM - msg warp */
X`009    return;
X`009`125
X`009W_WriteText(messagew, 5, 5, textColor, addr_str, strlen(addr_str),
X`009    W_RegularFont);
X`009lcount = ADDRLEN;
X`009DRAWCURSOR(ADDRLEN);
X`009return;
X    `125
X    switch ((unsigned char)ichar & `126(0x80)) `123
X`009case '\b':`009/* character erase */
X`009case '\177':
X`009    if (--lcount < ADDRLEN) `123
X`009`009lcount = ADDRLEN;
X`009`009break;
X`009    `125
X`009    BLANKCHAR(lcount + 1, 1);
X`009    DRAWCURSOR(lcount);
X`009    break;
X
X`009case '\027':`009/* word erase */
X`009    i = 0;
X`009    /* back up over blanks */
X`009    while (--lcount >= ADDRLEN &&
X`009`009isspace((unsigned char)buf`091lcount - ADDRLEN`093 & `126(0x80)))
X`009`009i++;
X`009    lcount++;
X`009    /* back up over non-blanks */
X`009    while (--lcount >= ADDRLEN &&
X`009`009!isspace((unsigned char)buf`091lcount - ADDRLEN`093 & `126(0x80)))
X`009`009i++;
X`009    lcount++;
X
X`009    if (i > 0) `123
X`009`009BLANKCHAR(lcount, i + 1);
X`009`009DRAWCURSOR(lcount);
X`009    `125
X`009    break;
X
X`009case '\025':`009/* kill line */
X`009case '\030':
X`009    if (lcount > ADDRLEN) `123
X`009`009BLANKCHAR(ADDRLEN, lcount - ADDRLEN + 1);
X`009`009lcount = ADDRLEN;
X`009`009DRAWCURSOR(ADDRLEN);
X`009    `125
X`009    break;
X
X`009case '\033':`009/* abort message */
X`009    BLANKCHAR(0, lcount + 1);
X`009    mdisplayed = 0;
X`009    messpend = 0;
X`009    W_WarpPointer(NULL);`009/* ATM - msg warp */
X`009    break;
X
X`009case '\r':`009/* send message */
X`009    buf`091lcount - ADDRLEN`093 = '\0';
X`009    messpend = 0;
X`009    switch (addr) `123
X`009`009case 'A':
X`009`009    pmessage(buf, 0, MALL);
X`009`009    break;
X`009`009case 'G':
X`009`009    pmessage(buf, me->p_mapchars`0911`093 - '0', MGOD);
X`009`009    break;
X`009`009case 'F':
X`009`009    pmessage(buf, FED, MTEAM);
X`009`009    break;
X`009`009case 'R':
X`009`009    pmessage(buf, ROM, MTEAM);
X`009`009    break;
X`009`009case 'K':
X`009`009    pmessage(buf, KLI, MTEAM);
X`009`009    break;
X`009`009case 'O':
X`009`009    pmessage(buf, ORI, MTEAM);
X`009`009    break;
X`009`009case '0':
X`009`009case '1':
X`009`009case '2':
X`009`009case '3':
X`009`009case '4':
X`009`009case '5':
X`009`009case '6':
X`009`009case '7':
X`009`009case '8':
X`009`009case '9':
X`009`009    pmessage(buf, addr - '0', MINDIV);
X`009`009    break;
X`009`009case 'a': case 'b': case 'c': case 'd':
X`009`009case 'e': case 'f': case 'g': case 'h':
X`009`009case 'i': case 'j': case 'k': case 'l':
X`009`009case 'm': case 'n': case 'o': case 'p':
X`009`009case 'q': case 'r': case 's': case 't':`032
X`009`009case 'u': case 'v': case 'w': case 'x':`032
X`009`009case 'y': case 'z':
X`009`009    pmessage(buf, addr - 'a' + 10, MINDIV);
X`009`009    break;
X`009`009default:
X`009`009    warning("Not legal recipient");
X`009    `125
X`009    BLANKCHAR(0, lcount + 1);
X`009    mdisplayed = 0;
X`009    lcount = 0;
X`009    break;
X
X`009default:`009/* add character */
X`009    if (lcount >= 80) `123
X`009`009W_Beep();
X`009`009break;
X`009    `125
X`009    if (iscntrl((unsigned char )ichar & `126(0x80)))
X`009`009break;
X`009    twochar`0910`093 = ichar;
X`009    twochar`0911`093 = cursor;
X`009    W_WriteText(messagew, 5 + W_Textwidth * lcount, 5, textColor,
X`009`009twochar, 2, W_RegularFont);
X`009    buf`091(lcount++) - ADDRLEN`093 = ichar;
X`009    break;
X    `125
X`125
X
Xpmessage(str, recip, group)
Xchar *str;
Xint recip;
Xint group;
X`123
X    char newbuf`091100`093;
X
X    sendMessage(str, group, recip);
X    if ((group==MTEAM && recip!=me->p_team) `124`124`032
X`009(group==MINDIV && recip!=me->p_no)) `123
X`009sprintf(newbuf, "%s  %s", getaddr2(group, recip), str);
X`009newbuf`09179`093=0;
X`009dmessage(newbuf, group, me->p_no, recip);
X    `125
X    W_WarpPointer(NULL);`009`009/* ATM - msg warp */
X`125
X
Xchar *getaddr(who)
Xchar who;
X`123
X    switch (who) `123
X    case 'A':
X`009return(getaddr2(MALL, 0));
X    case 'F':
X`009return(getaddr2(MTEAM, FED));
X    case 'R':
X`009return(getaddr2(MTEAM, ROM));
X    case 'K':
X`009return(getaddr2(MTEAM, KLI));
X    case 'O':
X`009return(getaddr2(MTEAM, ORI));
X    case 'G':
X`009return(getaddr2(MGOD, 0));
X    case '0':
X    case '1':
X    case '2':
X    case '3':
X    case '4':
X    case '5':
X    case '6':
X    case '7':
X    case '8':
X    case '9':
X`009if (isAlive(&players`091who - '0'`093)) `123
X`009    return(getaddr2(MINDIV, who-'0'));
X`009`125
X`009else `123
X`009    warning("Player is not in game");
X`009    return(0);
X`009`125
X`009break;
X    case 'a': case 'b': case 'c': case 'd':
X    case 'e': case 'f': case 'g': case 'h':
X    case 'i': case 'j': case 'k': case 'l':
X    case 'm': case 'n': case 'o': case 'p':
X    case 'q': case 'r': case 's': case 't':`032
X    case 'u': case 'v': case 'w': case 'x':`032
X    case 'y': case 'z':
X`009if (who-'a'+10 > MAXPLAYER) `123
X`009    warning("Player is not in game");
X`009    return(0);
X`009`125
X`009if (isAlive(&players`091who - 'a' + 10`093)) `123
X`009    return(getaddr2(MINDIV, who-'a'+10));
X`009`125
X`009else `123
X`009    warning("Player is not in game");
X`009    return(0);
X`009`125
X`009break;
X    default:
X`009warning("Not legal recipient");
X`009return(0);
X    `125
X`125
X
Xchar *getaddr2(flags, recip)`032
Xint flags;
Xint recip;
X`123
X    static char addrmesg`091ADDRLEN`093;
X
X    (void) sprintf(addrmesg, " %c%c->", teamlet`091me->p_team`093, shipnos`0
V91me->p_no`093);
X    switch(flags) `123
X    case MALL:
X`009(void) sprintf(&addrmesg`0915`093, "ALL");
X`009break;
X    case MGOD:
X`009(void) sprintf(&addrmesg`0915`093, "GOD");
X`009break;
X    case MTEAM:
X`009(void) sprintf(&addrmesg`0915`093, teamshort`091recip`093);
X`009break;
X    case MINDIV:
X`009(void) sprintf(&addrmesg`0915`093, "%c%c ",
X`009    teamlet`091players`091recip`093.p_team`093, shipnos`091recip`093);
X`009break;
X    `125
X    return(addrmesg);
X`125
X
X/* Send an emergency signal out to everyone. */
X
Xemergency()
X`123
X    char addrbuf`091ADDRLEN`093;
X    char ebuf`09180`093;
X
X    if (myship->s_type==STARBASE) `123
X`009sprintf(ebuf,`032
X`009    "Distress Call from %c%c (Starbase!):  %d%% damage, %d%% shields, %d
V armies!",
X`009    teamlet`091me->p_team`093, shipnos`091me->p_no`093,
X`009    (100*me->p_damage)/me->p_ship.s_maxdamage,
X`009    (100*me->p_shield)/me->p_ship.s_maxshield,
X`009    me->p_armies);
X    `125 else `123
X`009sprintf(ebuf,`032
X`009    "Distress Call from %c%c:  %d%% damage, %d%% shields, %d armies!",
X`009    teamlet`091me->p_team`093, shipnos`091me->p_no`093,
X`009    (100*me->p_damage)/me->p_ship.s_maxdamage,
X`009    (100*me->p_shield)/me->p_ship.s_maxshield,
X`009    me->p_armies);
X    `125
X    pmessage(ebuf, me->p_team, MTEAM);
X`125
$ CALL UNPACK SMESSAGE.C;1 1182574212
$ create/nolog 'f'
X/*
X * Socket.c
X *
X * Kevin P. Smith 1/29/89
X * UDP stuff v1.0 by Andy McFadden  Feb-Apr 1992
X *
X * UDP protocol v1.0
X *
X * Routines to allow connection to the xtrek server.
X */
X#include "copyright2.h"
X
X#ifndef GATEWAY
X# define USE_PORTSWAP`009`009/* instead of using recvfrom() */
X#endif
X
X#include <stdio.h>
X#include <errno.h>
X#include "TWG$TCP:`091NETDIST.INCLUDE.SYS`093types.h"
X#define  ECONNREFUSED 61
X#include <socket.h>
X#include <time.h>
X#include <in.h>
X#include <netdb.h>
X#include "Wlib.h"
X#include "defs.h"
X#include "struct.h"
X#include "data.h"
X#include "packets.h"
X
X#ifdef VMS
X#include "vmsutils.h"
X#endif
X
X#define INCLUDE_SCAN`009`009/* include Amdahl scanning beams */
X#define INCLUDE_VISTRACT`009/* include visible tractor beams */
X
X#ifdef GATEWAY
X/*
X * (these values are now defined in "main.c":)
X * char *gw_mach`009= "charon";`009`124client gateway; strcmp(serverName)
X * int   gw_serv_port`009= 5000;`009`009`124what to tell the server to use
X * int   gw_port`009= 5001;`009`009`124where we will contact gw
X * int   gw_local_port`009= 5100;`009`009`124where we expect gw to contact u
Vs
X *
X * The client binds to "5100" and sends "5000" to the server (TCP).  The
X * server sees that and sends a UDP packet to gw on port udp5000, which pass
Ves
X * it through to port udp5100 on the client.  The client-gw gets the server'
Vs
X * host and port from recvfrom.  (The client can't use the same method since
X * these sockets are one-way only, so it connect()s to gw_port (udp5001)
X * on the gateway machine regardless of what the server sends.)
X *
X * So all we need in .gwrc is:
X *`009udp 5000 5001 tde.uts 5100
X *
X * assuming the client is on tde.uts.  Note that a UDP declaration will
X * work for ANY server, but you need one per player, and the client has to
X * have the port numbers in advance.
X *
X * If we're using a standard server, we're set.  If we're running through a
X * gatewayed server, we have to do some unpleasant work on the server side..
V.
X */
X#endif
X
Xint handleMessage(), handlePhaser(), handlePlyrInfo();
Xint handlePlayer(), handleSelf(), handleStatus();
Xint handleWarning(), handleTorp(), handleTorpInfo();
Xint handlePlanet(), handleQueue(), handlePickok(), handleLogin();
Xint handlePlasmaInfo(), handlePlasma();
Xint handleKills(), handleFlags(), handlePStatus();
Xint handleMotd(), handleMask();
Xint handleBadVersion(), handlePlanetLoc();
Xint handleHostile(), handleStats(), handlePlyrLogin();
Xint handleReserved();
X#ifdef INCLUDE_SCAN
Xint handleScan();
X#endif
+-+-+-+-+-+-+-+-  END  OF PART 38 +-+-+-+-+-+-+-+-
