Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i031:  spellcast - strategy game for X11, Part05/07
Date: 14 Jul 1993 19:40:27 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2166
Approved: billr@saab.CNA.TEK.COM
Message-ID: <221nfb$rpk@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1831

Submitted-by: Andrew Plotkin <ap1i+@andrew.cmu.edu>
Posting-number: Volume 18, Issue 31
Archive-name: spellcast/part05
Environment: X11, Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 7)."
# Contents:  bitmaps/bvp.bm emonster.c xloop.c xquery.c xtext.c
# Wrapped by billr@saab on Wed Jul 14 12:32:51 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'bitmaps/bvp.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/bvp.bm'\"
else
echo shar: Extracting \"'bitmaps/bvp.bm'\" \(1577 characters\)
sed "s/^X//" >'bitmaps/bvp.bm' <<'END_OF_FILE'
X#define bvp_width 48
X#define bvp_height 48
X#define bvp_x_hot -1
X#define bvp_y_hot -1
Xstatic char bvp_bits[] = {
X0xff,0xff,0xff,0xff,0xff,0xff,0x0f,0x00,0x00,0x00,0x00,0xf0,
X0x03,0x00,0x80,0x01,0x00,0xc0,0x03,0x00,0xc0,0x01,0x00,0xc0,
X0x01,0x00,0xc6,0x03,0x00,0x80,0x01,0x00,0xc7,0x03,0x00,0x80,
X0x01,0x00,0xcf,0x03,0x00,0x80,0x01,0x00,0xcf,0x63,0x00,0x80,
X0x01,0x00,0xcf,0xe3,0x00,0x80,0x01,0x00,0xcf,0xf3,0x00,0x80,
X0x01,0x00,0xcf,0xf3,0x00,0x80,0x01,0x00,0xcf,0xf3,0x00,0x80,
X0x01,0x00,0xcf,0xf3,0x00,0x80,0x01,0x00,0xcf,0xf3,0x00,0x80,
X0x01,0x00,0xcf,0xf3,0x00,0x80,0x01,0x00,0xcf,0xf3,0x00,0x80,
X0x01,0x00,0xcf,0xf3,0x08,0x80,0x01,0x00,0xcf,0xf3,0x1c,0x80,
X0x01,0x00,0xcf,0xf3,0x1c,0x80,0x01,0x00,0xcf,0xf3,0x1c,0x80,
X0x01,0x00,0xcf,0xf3,0x1c,0x80,0xc1,0x00,0xef,0xf3,0x3c,0x80,
X0xc1,0x01,0xff,0xf7,0x3d,0x80,0xc1,0x01,0xff,0xff,0x3d,0x80,
X0xc1,0x03,0xff,0xff,0x3d,0x80,0xc1,0x03,0xff,0xff,0x3d,0x80,
X0xc1,0x87,0xff,0xff,0x3f,0x80,0xc1,0x87,0xff,0xff,0x3f,0x80,
X0x81,0x8f,0xff,0xff,0x3f,0x80,0x81,0x9f,0xff,0xff,0x3f,0x80,
X0x81,0xbf,0xff,0xff,0x3f,0x80,0x81,0xff,0xff,0xff,0x3f,0x80,
X0x01,0xff,0xff,0xff,0x3f,0x80,0x01,0xff,0xff,0xff,0x3f,0x80,
X0x01,0xfe,0xff,0xff,0x3f,0x80,0x01,0xfc,0xff,0xff,0x3f,0x80,
X0x01,0xfc,0xff,0xff,0x1f,0x80,0x01,0xf8,0xff,0xff,0x1f,0x80,
X0x01,0xf0,0xff,0xff,0x1f,0x80,0x01,0xf0,0xff,0xff,0x1f,0x80,
X0x01,0xe0,0xff,0xff,0x0f,0x80,0x01,0xe0,0xff,0xff,0x0f,0x80,
X0x01,0xc0,0xff,0xff,0x0f,0x80,0x01,0x80,0xff,0xff,0x07,0x80,
X0x03,0x80,0xff,0xff,0x07,0xc0,0x03,0x00,0xfe,0xff,0x03,0xc0,
X0x0f,0x00,0xfe,0xff,0x01,0xf0,0xff,0xff,0xff,0xff,0xff,0xff};
END_OF_FILE
if test 1577 -ne `wc -c <'bitmaps/bvp.bm'`; then
    echo shar: \"'bitmaps/bvp.bm'\" unpacked with wrong size!
fi
# end of 'bitmaps/bvp.bm'
fi
if test -f 'emonster.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'emonster.c'\"
else
echo shar: Extracting \"'emonster.c'\" \(11691 characters\)
sed "s/^X//" >'emonster.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <strings.h>
X
X#include "handwave.h"
X#include "internal.h"
X
Xstatic char bigbuf[2048];
Xstatic char bigbuf2[2048];
X
Xstatic void exec_monster_attack();
X
Xextern void InitBeing();
X
Xvoid kuruk_name()
X{
X#define NUMKURUK (23)
X
X    static char kuruk_syl[NUMKURUK][5] = {"kur", "ak", "ral", "ki", "rel", "uk",
X	"kor", "kul", "kas", "lok", "luk", "las", "mak", "mok", "mas", "mos", "ga",
X	"tha", "gul", "lug", "mag", "mog", "ug"};
X
X    int ix, new, old=(-1);
X    int numsyl = random()%3+2;
X
X    strcpy(bigbuf, "");
X
X    for (ix=0; ix<numsyl; ix++) {
X	do 
X	    new = random()%NUMKURUK;
X	while (new==old);
X	strcat(bigbuf, kuruk_syl[new]);
X	old = new;
X    }
X
X    if (random()%3==0 && numsyl<4) {
X	strcat(bigbuf, " ");
X	numsyl = random()%3+1;
X	for (ix=0; ix<numsyl; ix++) {
X	    do 
X		new = random()%NUMKURUK;
X	    while (new==old);
X	    strcat(bigbuf, kuruk_syl[new]);
X	    old = new;
X	}
X    }
X
X    for (ix=0; bigbuf[ix]; ix++) 
X	if ((ix==0 || bigbuf[ix-1]==' ') && islower(bigbuf[ix]))
X	    bigbuf[ix] = toupper(bigbuf[ix]);
X}
X
Xvoid snaffi_name()
X{
X#define NUMSNAFFI (18)
X
X    static char snaffi_syl[NUMSNAFFI][5] = {"sni", "sna", "fer", "fi", "fir",
X	"por", "per", "snu", "al", "an", "erl", "lep", "fru", "fri", "ig", "eg",
X	"thi", "tha"};
X
X    int ix, new, old=(-1);
X    int numsyl = random()%3+1;
X
X    strcpy(bigbuf, "");
X
X    for (ix=0; ix<numsyl; ix++) {
X	do 
X	    new = random()%NUMSNAFFI;
X	while (new==old);
X	strcat(bigbuf, snaffi_syl[new]);
X	old = new;
X    }
X
X    if (numsyl==1 || (random()%3==0 && numsyl<3)) {
X	strcat(bigbuf, " ");
X	numsyl = random()%2+1;
X	for (ix=0; ix<numsyl; ix++) {
X	    do 
X		new = random()%NUMSNAFFI;
X	    while (new==old);
X	    strcat(bigbuf, snaffi_syl[new]);
X	    old = new;
X	}
X    }
X
X    for (ix=0; bigbuf[ix]; ix++) 
X	if ((ix==0 || bigbuf[ix-1]==' ') && islower(bigbuf[ix]))
X	    bigbuf[ix] = toupper(bigbuf[ix]);
X}
X
Xvoid create_creature(self, type, creator)
Xstruct realgame *self;
Xint type;
Xint creator;
X{
X    struct creature *thud;
X
X    if (self->numcres+1 >= self->cre_size) {
X	self->cre_size *= 2;
X	self->cre = (struct creature *)realloc(self->cre, sizeof(struct creature) * self->cre_size);
X    }
X    thud = &self->cre[self->numcres];
X    self->numcres++;
X
X    InitBeing(thud);
X
X    thud->nocorpse = 0;
X    thud->gender = Gender_MALE;
X    thud->type = type;
X    thud->owner = creator;
X    thud->last_target = (-1);
X    thud->last_targettype = 0;
X    thud->nowm_spell = -1;
X
X    switch (type) {
X	case Creature_GOBLIN:
X	    thud->max_hitpoints = 1;
X	    snaffi_name();
X	    strcat(bigbuf, " the Goblin");
X	    break;
X	case Creature_OGRE:
X	    thud->max_hitpoints = 2;
X	    kuruk_name();
X	    strcat(bigbuf, " the Ogre");
X	    break;
X	case Creature_TROLL:
X	    thud->max_hitpoints = 3;
X	    kuruk_name();
X	    strcat(bigbuf, " the Troll");
X	    break;
X	case Creature_GIANT:
X	    thud->max_hitpoints = 4;
X	    kuruk_name();
X	    strcat(bigbuf, " the Giant");
X	    break;
X	case Creature_FIREL:
X	    thud->max_hitpoints = 3;
X	    thud->nocorpse = 1;
X	    kuruk_name();
X	    strcat(bigbuf, " the Fiery");
X	    break;
X	case Creature_ICEL:
X	    thud->max_hitpoints = 3;
X	    thud->nocorpse = 1;
X	    kuruk_name();
X	    strcat(bigbuf, " the Icy");
X	    break;
X    }
X    thud->hitpoints = thud->max_hitpoints;
X    thud->name = (char *)malloc(strlen(bigbuf)+1);
X    strcpy(thud->name, bigbuf);
X}
X
Xvoid execute_monsters(self)
Xstruct realgame *self;
X{
X    int ix, cx, jx, kx, numattacks, qtype, qnum;
X    int target, targettype;
X    struct creature *thud;
X
X    erase_queries(self);
X
X    for (ix=0; ix<self->numcres; ix++) {
X	thud = &(self->cre[ix]);
X	if (thud->alive) {
X	    /* at this point, thud->haste is 5 if haste just cast this round;
X		   3,2,1 if in effect; 4 if just cast but also previously in effect */
X	    switch (self->turntype) {
X		case Turn_TIMESTOP:
X		    if (thud->timestop==1)
X			numattacks = 1;
X		    else
X			numattacks = 0;
X		    break;
X		case Turn_NORMAL:
X		    if (thud->haste>=1 && thud->haste<=4)
X			numattacks = 2;
X		    else
X			numattacks = 1;
X		    break;
X		default:
X		    PrintMsg("ERROR: wrong type of turn in execute_monsters()\n");
X		    break;
X	    }
X	    for (jx=0; jx<numattacks; jx++) {
X		if (thud->type==Creature_FIREL || thud->type==Creature_ICEL)
X		    qtype = Qu_NoQuery;
X		else
X		    qtype = Qu_MonsterTarget;
X
X		switch (thud->nowm_spell) {
X		    case SP__CONFUSION:
X			qtype = Qu_NoQuery;
X			if (jx==0) {
X			    sprintf(bigbuf, "%s suddenly looks confused.\n", thud->name);
X			    PrintMsg(bigbuf);
X			}
X			break;
X		    case SP__PARALYSIS:
X			qtype = Qu_NoQuery;
X			if (jx==0) {
X			    sprintf(bigbuf, "%s is paralyzed and cannot attack.\n", thud->name);
X			    PrintMsg(bigbuf);
X			}
X			break;
X		    case SP__AMNESIA:
X			qtype = Qu_NoQuery;
X			if (jx==0) {
X			    sprintf(bigbuf, "%s looks around blankly.\n", thud->name);
X			    PrintMsg(bigbuf);
X			}
X			break;
X		    default:
X			break;
X		}
X		if (thud->owner<0 || thud->owner>=self->numplayers ||
X				!self->wiz[thud->owner]->alive) {
X		    qtype = Qu_NoQuery;
X		}
X
X		add_query(self, thud->owner, qtype, ix + 256*(jx+numattacks));
X	    }
X	}
X    }
X    if (self->numqueries)
X	Queries(self->numqueries, self->querylist);
X
X    for (qnum=0; qnum<self->numqueries; qnum++) {
X	jx = (int)(self->querylist[qnum].rock);
X	numattacks = jx / 256;
X	ix = jx % 256;
X	thud = &(self->cre[ix]);
X	if (thud->type==Creature_FIREL || thud->type==Creature_ICEL) {
X	    /* elementals are not affected by paralysis */
X	    for (cx=0; cx<self->numplayers; cx++) {
X		if (self->wiz[cx]->alive)
X		    exec_monster_attack(self, self->wiz[cx], cx, 1, thud);
X	    }
X	    for (cx=0; cx<self->numcres; cx++) {
X		if (self->cre[cx].alive)
X		    exec_monster_attack(self, &self->cre[cx], cx, 0, thud);
X	    }
X	}
X	else {
X	    targettype = 0;
X	    target = (-1);
X	    if (thud->nowm_spell==SP__PARALYSIS) {
X		/* no attack */
X		targettype = 0;
X	    }
X	    else if (thud->nowm_spell==SP__CONFUSION) {
X		int numtwiz, numtcre;
X		if (thud->mind_caster==1 && thud->perm.mind_spell==SP__CONFUSION &&
X				thud->perm.mind_detail!=(-1)) {
X		    /* grab from detail */
X		    targettype = thud->perm.mind_detail & QuVal_Hand_MASK;
X		    target = thud->perm.mind_detail & (~QuVal_Hand_MASK);
X		}
X		else {
X		    /* grab randomly */
X		    numtwiz = NumberOfTargets(self, QuVal_Target_Wizard);
X		    numtcre = NumberOfTargets(self, QuVal_Target_Creature);
X		    kx = random() % (numtwiz + numtcre);
X		    if (kx<numtwiz) {
X			targettype = QuVal_Target_Wizard;
X			target = IndexOfTarget((game *)self, targettype, kx) &
X					(~QuVal_Target_MASK);
X		    }
X		    else {
X			targettype = QuVal_Target_Creature;
X			kx -= numtwiz;
X			target = IndexOfTarget((game *)self, targettype, kx) &
X					(~QuVal_Target_MASK);
X		    }
X		}
X		if (thud->mind_caster==1 && thud->perm.mind_spell==SP__CONFUSION) {
X		    /* set detail */
X		    thud->perm.mind_detail = targettype | target;
X		}
X	    }
X	    else if (thud->nowm_spell==SP__AMNESIA) {
X		targettype = thud->last_targettype;
X		target = thud->last_target;
X	    }
X	    else {
X		int ival;
X		int tart = self->querylist[qnum].answer & QuVal_Target_MASK;
X		if (tart==0
X		    || (thud->owner<0 || thud->owner>=self->numplayers ||
X				!self->wiz[thud->owner]->alive)) {
X		    targettype = 0;
X		}
X		else {
X		    kx = self->querylist[qnum].answer & (~QuVal_Target_MASK);
X		    ival = IndexOfTarget((game *)self, tart, kx);
X		    target = ival & (~QuVal_Target_MASK);
X		    targettype = ival & QuVal_Target_MASK;
X		}
X	    }
X	    /*printf("### attack of %s: %d, %d\n", thud->name, targettype, target);*/
X	    thud->last_targettype = targettype;
X	    thud->last_target = target;
X	    switch (targettype) {
X		case QuVal_Target_Wizard:
X		    if (self->wiz[target]->alive)
X			exec_monster_attack(self, self->wiz[target], target, 1, thud);
X		    break;
X		case QuVal_Target_Creature:
X		    if (self->cre[target].alive)
X			exec_monster_attack(self, &self->cre[target], target, 0, thud);
X		    break;
X		default:
X		    break;
X	    }
X	}
X    }
X
X    for (ix=0; ix<self->numcres; ix++) {
X	thud = &(self->cre[ix]);
X	if (thud->alive) {
X	    /*printf("### cycling %s: %d => %d\n", thud->name, thud->mind_spell,
X			thud->nowm_spell);*/
X	    if (self->turntype==Turn_TIMESTOP && !thud->timestop) {
X		/* do not cycle */
X	    }
X	    else {
X		thud->nowm_spell  = thud->mind_spell; 
X		thud->nowm_caster = thud->mind_caster; 
X		thud->mind_spell  = (-1); 
X		thud->mind_caster = (-1);
X	    }
X	}
X    }
X}
X
Xstatic void exec_monster_attack(self, fred, cnum, wizflag, thud) /* dead not allowed */
Xstruct realgame *self;
Xunion being *fred;
Xint cnum;
Xint wizflag;
Xstruct creature *thud;
X{
X    int ix, jx;
X    int *zapl;
X
X    zapl = fred->both.zaplist;
X
X    if (fred==(union being *)thud) {
X	if (thud->type==Creature_FIREL || thud->type==Creature_ICEL) {
X	    /* say nothing */
X	}
X	else {
X	    sprintf(bigbuf, "%s refuses to attack %s.\n", thud->name,
X			pro_himself(fred->both.gender));
X	    PrintMsg(bigbuf);
X	}
X	return;
X    }
X
X    if (!(thud->type==Creature_FIREL || thud->type==Creature_ICEL)
X	&& fred->both.invisibility) {
X	sprintf(bigbuf, "%s tries to attack you, but cannot see you.\n", thud->name);
X	sprintf(bigbuf2, "%s tries to attack %s, but cannot see %s.\n", thud->name,
X			fred->both.name, pro_him(fred->both.gender));
X	if (wizflag)
X	    PrintMsg2(cnum, bigbuf, bigbuf2);
X	else
X	    PrintMsg(bigbuf2);
X	return;
X    }
X
X    if (zapl[SP__SHIELD]) {
X	sprintf(bigbuf, "The attack of %s is blocked by your Shield.\n", thud->name);
X	sprintf(bigbuf2, "The attack of %s is blocked by %s's Shield.\n", thud->name,
X			fred->both.name);
X	if (wizflag)
X	    PrintMsg2(cnum, bigbuf, bigbuf2);
X	else
X	    PrintMsg(bigbuf2);
X	return;
X    }
X
X    if (thud->type==Creature_FIREL) {
X	if (fred->both.fl_resist_heat) {
X	    sprintf(bigbuf, "%s reaches towards you, but you feel only a warm breeze.\n",
X			thud->name);
X	    sprintf(bigbuf2, "%s reaches toward %s, but cannot penetrate %s blue aura.\n",
X			thud->name, fred->both.name, pro_his(fred->both.gender));
X	    if (wizflag)
X		PrintMsg2(cnum, bigbuf, bigbuf2);
X	    else
X		PrintMsg(bigbuf2);
X	}
X	else {
X	    sprintf(bigbuf, "%s hurls tongues of fire at you.\n", thud->name);
X	    sprintf(bigbuf2, "%s hurls fire at %s.\n", thud->name, fred->both.name);
X	    if (wizflag)
X		PrintMsg2(cnum, bigbuf, bigbuf2);
X	    else
X		PrintMsg(bigbuf2);
X	    fred->both.hitpoints -= 3;
X	}
X    }
X    else if (thud->type==Creature_ICEL) {
X	if (fred->both.fl_resist_cold) {
X	    sprintf(bigbuf, "%s reaches towards you, but you feel only a chill breeze.\n",
X			thud->name);
X	    sprintf(bigbuf2, "%s reaches toward %s, but cannot penetrate %s pink aura.\n",
X			thud->name, fred->both.name, pro_his(fred->both.gender));
X	    if (wizflag)
X		PrintMsg2(cnum, bigbuf, bigbuf2);
X	    else
X		PrintMsg(bigbuf2);
X	}
X	else {
X	    sprintf(bigbuf, "%s hurls splinters of ice at you.\n", thud->name);
X	    sprintf(bigbuf2, "%s hurls ice at %s.\n", thud->name, fred->both.name);
X	    if (wizflag)
X		PrintMsg2(cnum, bigbuf, bigbuf2);
X	    else
X		PrintMsg(bigbuf2);
X	    fred->both.hitpoints -= 3;
X	}
X    }
X    else {
X	/* other creature types */
X	if (fred==(union being *)thud) {
X	    sprintf(bigbuf, "%s attacks %s!\n", thud->name,
X			pro_himself(fred->both.gender));
X	    PrintMsg(bigbuf);
X	}
X	else {
X	    sprintf(bigbuf, "%s attacks you.\n", thud->name);
X	    sprintf(bigbuf2, "%s attacks %s.\n", thud->name, fred->both.name);
X	    if (wizflag)
X		PrintMsg2(cnum, bigbuf, bigbuf2);
X	    else
X		PrintMsg(bigbuf2);
X	}
X	switch (thud->type) {
X	    case Creature_GOBLIN:
X		fred->both.hitpoints -= 1;
X		break;
X	    case Creature_OGRE:
X		fred->both.hitpoints -= 2;
X		break;
X	    case Creature_TROLL:
X		fred->both.hitpoints -= 3;
X		break;
X	    case Creature_GIANT:
X		fred->both.hitpoints -= 4;
X		break;
X	}
X    }
X}
END_OF_FILE
if test 11691 -ne `wc -c <'emonster.c'`; then
    echo shar: \"'emonster.c'\" unpacked with wrong size!
fi
# end of 'emonster.c'
fi
if test -f 'xloop.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xloop.c'\"
else
echo shar: Extracting \"'xloop.c'\" \(11673 characters\)
sed "s/^X//" >'xloop.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <string.h>
X#include <sys/time.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include "handwave.h"
X#include "spelllist.h"
X#include "xspell.h"
X
Xextern void redraw(), redraw_stats(), redraw_queries(), redraw_buttons(),
X	redraw_text(), redraw_column();
Xextern int gesture_hit();
Xvoid redraw_stats_only(), update_statlist();
Xvoid redraw_done_markers();
X
Xint blinklevel; /* in tenths of a second */
X
Xvoid mainloop()
X{
X    int pnum;
X    XEvent event;
X    int gotit, gotround;
X    struct player *py;
X    fd_set readbits;
X    int numsocks, sock;
X    int doneloop = 0;
X    char c;
X    struct timeval startround, now, pausetime;
X
X    blinklevel = 0;
X    for (pnum=0; pnum<numplayers; pnum++) {
X	players[pnum].mousestate = ms_None;
X	players[pnum].turn_blinklimit = (random() % 50) + 5;
X	players[pnum].turn_blinked = 0;
X    }
X    for (pnum=0; pnum<numplayers; pnum++)
X	update_statlist(&players[pnum]);
X    gettimeofday(&startround, NULL);
X
X    while (!doneloop) {
X	gotround = 0;
X	for (pnum=0; pnum<numplayers; pnum++) {
X	    gotit = XCheckWindowEvent(players[pnum].dpy, players[pnum].win,
X			EVENTMASK, &event);
X	    if (gotit) {
X		gotround = 1;
X		py = &(players[pnum]);
X		switch (event.type) {
X		    case Expose:
X			do {
X			    gotit = XCheckWindowEvent(players[pnum].dpy,
X					players[pnum].win, ExposureMask, &event);
X			} while (gotit);
X			py->gotexpose = 1;
X			redraw(py);
X			break;
X		    case KeyPress:
X			if (1 == XLookupString(&event, &c, 1, NULL, NULL)) {
X			    switch (c) {
X				case '\014': /* Ctrl-L */
X				    XClearArea(py->dpy, py->win, 0, 0, 0, 0, 1);
X				    break;
X				default:
X				    talk_handle_char(py, c);
X			    }
X			}
X			break;
X		    case ButtonPress:
X			if (py->mousestate != ms_None) {
X			    break;
X			}
X			if (in_gesture_box(py, event.xbutton.x, event.xbutton.y)) {
X			    py->mousestate = gesture_hit(py, event.xbutton.x,
X					event.xbutton.y, event.xbutton.button);
X			    py->mousebutton = event.xbutton.button;
X			}
X			else if (in_bbox_box(py, event.xbutton.x, event.xbutton.y)) {
X			    py->mousestate = button_hit(py, event.xbutton.x,
X					event.xbutton.y, event.xbutton.button);
X			    py->mousebutton = event.xbutton.button;
X			}
X			else if (in_scrollbar_box(&(py->sitext), event.xbutton.x,
X					event.xbutton.y)) {
X			    py->mousestate = scrollbar_hit(&(py->sitext),
X					event.xbutton.x, event.xbutton.y,
X					event.xbutton.button);
X			    py->mousebutton = event.xbutton.button;
X			}
X			else if (in_scrollbar_box(&(py->siquery), event.xbutton.x,
X					event.xbutton.y)) {
X			    py->mousestate = scrollbar_hit(&(py->siquery),
X					event.xbutton.x, event.xbutton.y,
X					event.xbutton.button);
X			    py->mousebutton = event.xbutton.button;
X			}
X			else if (in_scrollbar_box(&(py->sistats), event.xbutton.x,
X					event.xbutton.y)) {
X			    py->mousestate = scrollbar_hit(&(py->sistats),
X					event.xbutton.x, event.xbutton.y,
X					event.xbutton.button);
X			    py->mousebutton = event.xbutton.button;
X			}
X			else if (in_query_box(py, event.xbutton.x,
X					event.xbutton.y)) {
X			    py->mousestate = query_hit(py, event.xbutton.x,
X					event.xbutton.y, event.xbutton.button);
X			    py->mousebutton = event.xbutton.button;
X			}
X			else {
X			    py->mousestate = ms_None;
X			}
X			break;
X		    case MotionNotify:
X			switch (py->mousestate) {
X			    case ms_Gesture:
X				gesture_motion(py, event.xbutton.x, event.xbutton.y,
X						event.xbutton.button);
X				break;
X			    case ms_Scroll:
X				scrollbar_motion(py->scroll_active, event.xbutton.x,
X						event.xbutton.y, event.xbutton.button);
X				break;
X			    case ms_Query:
X				query_motion(py, event.xbutton.x, event.xbutton.y,
X						event.xbutton.button);
X				break;
X			    case ms_DoneBtn:
X			    case ms_SpellBtn:
X				button_motion(py, event.xbutton.x, event.xbutton.y,
X						event.xbutton.button);
X				break;
X			    default:
X				break;
X			}
X			break;
X		    case ButtonRelease:
X			if (py->mousebutton == event.xbutton.button) {
X			    switch (py->mousestate) {
X				case ms_Gesture:
X				    gesture_release(py, event.xbutton.x,
X						event.xbutton.y, event.xbutton.button);
X				    break;
X				case ms_Scroll:
X				    scrollbar_release(py->scroll_active,
X						event.xbutton.x, event.xbutton.y,
X						event.xbutton.button);
X				    break;
X				case ms_Query:
X				    query_release(py, event.xbutton.x,
X						event.xbutton.y, event.xbutton.button);
X				    break;
X				case ms_DoneBtn:
X				case ms_SpellBtn:
X				    button_release(py, event.xbutton.x,
X						event.xbutton.y, event.xbutton.button);
X				    break;
X				default:
X				    break;
X			    }
X			    py->mousestate = ms_None;
X			}
X			break;
X		    default:
X			break;
X		}
X	    }
X	}
X	doneloop = 1;
X	for (pnum=0; pnum<numplayers; pnum++) {
X	    if ((players[pnum].turn_active && !players[pnum].turn_done) ||
X			players[pnum].mousestate!=ms_None) {
X		doneloop = 0;
X		break;
X	    }
X	}
X	{
X	    /* check time */
X	    long sofar;
X	    gettimeofday(&now, NULL);
X	    sofar = (now.tv_sec - startround.tv_sec) * 10 +
X			(now.tv_usec - startround.tv_usec) / 100000;
X	    if (sofar > blinklevel) {
X		blinklevel = sofar;
X		for (pnum=0; pnum<numplayers; pnum++) 
X		    if (!players[pnum].turn_blinked
X			&& blinklevel > players[pnum].turn_blinklimit) {
X			players[pnum].turn_blinked = 1;
X			redraw_done_markers(&(players[pnum]));
X		    }
X	    }
X	}
X	if (!gotround && !doneloop) {
X	    /* no events -- wait a while */
X	    FD_ZERO(&readbits);
X	    numsocks = 0;
X	    for (pnum=0; pnum<numplayers; pnum++) {
X		sock = ConnectionNumber(players[pnum].dpy);
X		if (sock+1 > numsocks)
X		    numsocks = sock+1;
X		FD_SET(sock, &readbits);
X		XFlush(players[pnum].dpy);
X	    }
X	    pausetime.tv_sec = 0;
X	    pausetime.tv_usec = 200000; /* 1/5th of a second */
X	    (void)select(numsocks, &readbits, 0, 0, &pausetime);
X	}
X    }
X}
X
Xvoid redraw(py)
Xstruct player *py;
X{
X    redraw_text(py);
X    redraw_column(py);
X    redraw_buttons(py);
X    redraw_queries(py);
X    redraw_stats(py);
X    redraw_talk(py);
X    if (py->backstore)
X	switch (py->mousestate) {
X	    case ms_Gesture:
X		draw_gesture_menu(py);
X		break;
X	    case ms_SpellBtn:
X		draw_spelllist(py);
X		break;
X	    case ms_Query:
X		draw_query_menu(py);
X		break;
X	    default:
X		break;
X	}
X}
X
X#define STATS_X (476)
X#define STATS_Y (449)
X#define STATS_W (324)
X#define STATS_H (104)
X#define STATS_HP (244)
X
Xvoid init_stats(py)
Xstruct player *py;
X{
X    py->statlist_size = 4;
X    py->statlist = (struct statthing *)malloc(sizeof(struct statthing) * py->statlist_size);
X
X    py->sistats.nlines = 0;
X    py->sistats.visible = (STATS_H-2) / py->lineheight;
X    py->sistats.py = py;
X    py->sistats.top = 0;
X    py->sistats.lineheight = py->lineheight;
X    py->sistats.x = STATS_X;
X    py->sistats.y = STATS_Y;
X    py->sistats.h = STATS_H;
X    py->sistats.redraw = redraw_stats_only;
X}
X
Xvoid clear_stats(py)
Xstruct player *py;
X{
X    py->sistats.nlines = 0;
X    py->sistats.top = 0;
X}
X
Xvoid add_statthing(py, index, type, hp, stuff)
Xstruct player *py;
Xint index, type;
Xint hp;
Xlong stuff;
X{
X    int num;
X
X    if (py->sistats.nlines >= py->statlist_size) {
X	while (py->sistats.nlines >= py->statlist_size)
X	    py->statlist_size *= 2;
X	py->statlist = (struct statthing *)realloc(py->statlist,
X			sizeof(struct statthing) * py->statlist_size);
X    }
X    num = py->sistats.nlines;
X    py->sistats.nlines++;
X    py->statlist[num].index = index;
X    py->statlist[num].type = type;
X    py->statlist[num].hp = hp;
X    py->statlist[num].stuff = stuff;
X}
X
X#define DRAWSTAR(py)  ((py)->turn_active ? (py)->turn_done : (py)->turn_blinked)
X
Xvoid redraw_done_markers(pdone)
Xstruct player *pdone;
X{
X    int pnum, pdonenum;
X    int ix, qline;
X    int ypos;
X
X    struct player *py;
X
X    pdonenum = (pdone-players);
X    for (pnum=0; pnum<numplayers; pnum++) {
X	py = &(players[pnum]);
X	for (ix=0; ix<py->sistats.visible; ix++) {
X	    qline = py->sistats.top + ix;
X	    if (py->statlist[qline].type == QuVal_Target_Wizard
X		&& py->statlist[qline].index == pdonenum)
X		break;
X	}
X	if (ix<py->sistats.visible) {
X	    ypos = STATS_Y+ix*py->lineheight+py->lineheight;
X	    py->gotexpose = 1;
X	    if (!py->backstore) {
X		if (DRAWSTAR(pdone)) {
X		    DrawStringField(py, "*", STATS_X+4, ypos, 12);
X		}
X		else {
X		    DrawStringField(py, " ", STATS_X+4, ypos, 12);
X		}
X	    }
X	}
X    }
X}
X
Xvoid redraw_stats_only(py, baronly)
Xstruct player *py;
Xint baronly;
X{
X    int ix, qline;
X    int ypos;
X    struct statthing *st;
X    char sbuf[32];
X    struct player *other;
X
X    if (!baronly) {
X	for (ix=0; ix<py->sistats.visible; ix++) {
X	    qline = py->sistats.top + ix;
X	    if (qline<0)
X		continue;
X	    ypos = STATS_Y+ix*py->lineheight+py->lineheight;
X	    if (qline >= py->sistats.nlines) {
X		DrawStringField(py, "", STATS_X+4, ypos, STATS_W-4);
X	    }
X	    else {
X		st = &(py->statlist[qline]);
X		if (st->type==QuVal_Target_Wizard) {
X		    other = &(players[st->index]);
X		    if (DRAWSTAR(other)) {
X			DrawStringField(py, "*", STATS_X+4, ypos, 12);
X		    }
X		    else {
X			DrawStringField(py, " ", STATS_X+4, ypos, 12);
X		    }
X		    DrawStringField(py, NameOfBeing(gameval, st->type, st->index),
X				STATS_X+16, ypos, STATS_W-16);
X		}
X		else {
X		    DrawStringField(py, "", STATS_X+4, ypos, 20);
X		    DrawStringField(py, NameOfBeing(gameval, st->type, st->index),
X				STATS_X+24, ypos, STATS_W-24);
X		}
X		sprintf(sbuf, "%d %s%s%s%s%s%s%s", st->hp,
X			(st->stuff & Stuff_INVISIBLE) ? "I" : "",
X			(st->stuff & Stuff_RESIST_HEAT) ? "H" : "",
X			(st->stuff & Stuff_RESIST_COLD) ? "C" : "",
X			(st->stuff & Stuff_PROTECT_EVIL) ? "P" : "",
X			(st->stuff & Stuff_BLIND) ? "b" : "",
X			(st->stuff & Stuff_DISEASE) ? "d" : "",
X			(st->stuff & Stuff_POISON) ? "p" : "");
X		DrawStringField(py, sbuf, STATS_X+STATS_HP, ypos, STATS_W-STATS_HP);
X	    }
X	}
X    }
X
X    redraw_scrollbar(&(py->sistats));
X}
X
Xvoid redraw_stats(py)
Xstruct player *py;
X{
X    int ix;
X
X    XDrawRectangle(py->dpy, py->win, py->blackgc, STATS_X-3, STATS_Y-2,
X		STATS_W+4, STATS_H+3);
X    XDrawRectangle(py->dpy, py->win, py->blackgc, STATS_X-SCROLL_W, STATS_Y-2,
X		SCROLL_W-3, STATS_H+3);
X
X    redraw_stats_only(py, 0);
X}
X
Xstatic int statthing_pnum;
X
Xint statthing_compare(st1, st2)
Xstruct statthing *st1, *st2;
X{
X    int own1, own2;
X
X    if (st1->type==QuVal_Target_Wizard)
X	own1 = st1->index;
X    else
X	own1 = OwnerOfCreature(gameval, st1->index);
X    if (st2->type==QuVal_Target_Wizard)
X	own2 = st2->index;
X    else
X	own2 = OwnerOfCreature(gameval, st2->index);
X
X    if (own1 != own2) {
X	if (own1==(-1)) own1 = (-300);
X	else if (own1 == statthing_pnum)
X	    own1 = (-200);
X	if (own2==(-1)) own2 = (-300);
X	else if (own2 == statthing_pnum)
X	    own2 = (-200);
X	return (own1 - own2);
X    }
X
X    if (st1->type==QuVal_Target_Wizard && st2->type==QuVal_Target_Wizard)
X	return (0);
X    if (st1->type==QuVal_Target_Wizard)
X	return (-100);
X    if (st2->type==QuVal_Target_Wizard)
X	return (100);
X    return (st1->index - st2->index);
X}
X
Xvoid update_statlist(py)
Xstruct player *py;
X{
X    int ix, max, hp;
X    long stuff;
X    clear_stats(py);
X
X    max = NumberOfBeings(gameval, QuVal_Target_Wizard);
X    for (ix=0; ix<max; ix++) {
X	hp = HitPointsOfBeing(gameval, QuVal_Target_Wizard, ix);
X	stuff = StuffAboutBeing(gameval, QuVal_Target_Wizard, ix);
X	if (hp>=0)
X	    add_statthing(py, ix, QuVal_Target_Wizard, hp, stuff);
X    }
X    max = NumberOfBeings(gameval, QuVal_Target_Creature);
X    for (ix=0; ix<max; ix++) {
X	hp = HitPointsOfBeing(gameval, QuVal_Target_Creature, ix);
X	stuff = StuffAboutBeing(gameval, QuVal_Target_Creature, ix);
X	if (hp>=0)
X	    add_statthing(py, ix, QuVal_Target_Creature, hp, stuff);
X    }
X
X    statthing_pnum = py-players;
X    qsort(py->statlist, py->sistats.nlines, sizeof(struct statthing), statthing_compare);
X
X    redraw_stats_only(py, 0);
X}
END_OF_FILE
if test 11673 -ne `wc -c <'xloop.c'`; then
    echo shar: \"'xloop.c'\" unpacked with wrong size!
fi
# end of 'xloop.c'
fi
if test -f 'xquery.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xquery.c'\"
else
echo shar: Extracting \"'xquery.c'\" \(22441 characters\)
sed "s/^X//" >'xquery.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <string.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include "handwave.h"
X#include "spelllist.h"
X#include "xspell.h"
X
X#define QUERY_X  (32)
X#define QUERY_Y  (620)
X#define QUERY_W  (736)
X#define QUERY_H  (100)
X#define QUERY_AW  (450)
X
X#define QUERY_LEADING (8)
X#define QMENU_LEADING (4)
X#define QMENU_BORDER (4)
X
X#define GEST_SPACE (50)
X
Xtypedef struct _tempstring {
X    struct _tempstring *next;
X    char str[1];
X} tempstring;
X
Xstatic char *TLElementalType_Names[] = {"Fire", "Ice"};
Xstatic char *TLHand_Names[] = {"Left", "Right"};
Xstatic char *TLNoYes_Names[] = {"No", "Yes"};
Xstatic int TLZeroOne_Num[] = {0, 1};
Xstatic struct target_list TLBeing = {0, NULL, NULL, 0};
Xstatic struct target_list TLBeingNone = {0, NULL, NULL, 0};
Xstatic struct target_list TLWizard = {0, NULL, NULL, 0};
Xstatic struct target_list TLWizardNone = {0, NULL, NULL, 0};
Xstatic struct target_list TLRaiseDead = {0, NULL, NULL, 0};
Xstatic struct target_list TLElementalType = {2, TLElementalType_Names, TLZeroOne_Num, 0};
Xstatic struct target_list TLPickHand = {2, TLHand_Names, TLZeroOne_Num, 0};
Xstatic struct target_list TLNoYes = {2, TLNoYes_Names, TLZeroOne_Num, 0};
X
Xstatic tempstring *tempstringlist = NULL;
X
Xvoid redraw_queries_only();
X
Xvoid init_query(py)
Xstruct player *py;
X{
X    py->answers_size = 8;
X    py->answers = (struct answer *)malloc(sizeof(struct answer) * py->answers_size);
X    py->siquery.nlines = 0;
X    py->query_hgt = py->lineheight + QUERY_LEADING;
X    py->siquery.visible = QUERY_H / py->query_hgt;
X
X    py->TLLeftHand.size = 0;
X    py->TLLeftHand.num = 0;
X    py->TLRightHand.size = 0;
X    py->TLRightHand.num = 0;
X
X    py->siquery.py = py;
X    py->siquery.top = 0;
X    py->siquery.lineheight = py->query_hgt;
X    py->siquery.x = QUERY_X;
X    py->siquery.y = QUERY_Y;
X    py->siquery.h = QUERY_H;
X    py->siquery.redraw = redraw_queries_only;
X}
X
Xvoid flush_tempstrings()
X{
X    tempstring *pt;
X
X    while (tempstringlist) {
X	pt = tempstringlist->next;
X	free(tempstringlist);
X	tempstringlist = pt;
X    }
X}
X
Xchar *tempstring_malloc(len)
Xint len;
X{
X    tempstring *pt;
X
X    pt = (tempstring *)malloc(sizeof(tempstring) + len + 1);
X    pt->next = tempstringlist;
X    tempstringlist = pt;
X    return (pt->str);
X}
X
Xvoid clear_answers(py)
Xstruct player *py;
X{
X    py->siquery.nlines = 0;
X    py->siquery.top = 0;
X}
X
Xvoid add_answer(py, qu_str, ans_str, done_init, answer_init, qrock, introck)
Xstruct player *py;
Xchar *qu_str;
Xchar *ans_str;
Xint done_init, answer_init;
Xstruct query *qrock;
Xlong introck;
X{
X    int num;
X
X    if (py->siquery.nlines >= py->answers_size) {
X	py->answers_size *= 2;
X	py->answers = (struct answer *)realloc(py->answers,
X			sizeof(struct answer) * py->answers_size);
X    }
X    num = py->siquery.nlines;
X    py->siquery.nlines++;
X    py->answers[num].done = done_init;
X    py->answers[num].answer = answer_init;
X    py->answers[num].query = qrock;
X    py->answers[num].rock = introck;
X    strcpy(py->answers[num].qu_str, qu_str);
X    strcpy(py->answers[num].ans_str, ans_str);
X}
X
Xint DrawStringField(py, str, xpos, ypos, width)
Xstruct player *py;
Xchar *str;
Xint xpos, ypos;
Xint width;
X{
X    static XCharStruct overall;
X    int direction, ascent, descent;
X    int len = strlen(str);
X
X    XTextExtents(py->font, str, len, &direction, &ascent, &descent, &overall);
X    XDrawImageString(py->dpy, py->win, py->blackgc, xpos, ypos, str, len);
X    if (overall.width<width) {
X	XClearArea(py->dpy, py->win, xpos+overall.width, ypos-py->ascent,
X			width-overall.width, py->totalheight, 0);
X    }
X
X    return overall.width;
X}
X
Xvoid redraw_queries_only(py, baronly)
Xstruct player *py;
Xint baronly;
X{
X    int ix, qline;
X    int ypos;
X
X    if (!baronly) {
X	for (ix=0; ix<py->siquery.visible; ix++) {
X	    qline = py->siquery.top + ix;
X	    if (qline<0)
X		continue;
X	    ypos = QUERY_Y+ix*py->query_hgt+py->lineheight;
X	    if (qline >= py->siquery.nlines) {
X		DrawStringField(py, "", QUERY_X+16, ypos, QUERY_W-16);
X	    }
X	    else {
X		DrawStringField(py, py->answers[qline].qu_str, QUERY_X+16,
X				ypos, QUERY_AW-16);
X		DrawStringField(py, py->answers[qline].ans_str, QUERY_X+QUERY_AW,
X				ypos, QUERY_W-QUERY_AW);
X	    }
X	}
X    }
X
X    redraw_scrollbar(&(py->siquery));
X}
X
Xvoid redraw_queries(py)
Xstruct player *py;
X{
X    int ix;
X
X    XDrawRectangle(py->dpy, py->win, py->blackgc, QUERY_X-3, QUERY_Y-2,
X		QUERY_W+4, QUERY_H+3);
X    XDrawRectangle(py->dpy, py->win, py->blackgc, QUERY_X-SCROLL_W, QUERY_Y-2,
X		SCROLL_W-3, QUERY_H+3);
X
X    for (ix=0; ix<py->siquery.visible; ix++) {
X	if (ix!=0)
X	    XDrawLine(py->dpy, py->win, py->blackgc, QUERY_X, QUERY_Y+ix*py->query_hgt,
X			QUERY_X+QUERY_W, QUERY_Y+ix*py->query_hgt);
X    }
X    redraw_queries_only(py, 0);
X}
X
Xstatic void add_to_targetlist(tl, name, targnum)
Xstruct target_list *tl;
Xchar *name;
Xint targnum;
X{
X    int size;
X
X    if (tl->size==0) {
X	tl->size = 8;
X	tl->tnums = (int *)malloc(tl->size*sizeof(int));
X	tl->tnames = (char **)malloc(tl->size*sizeof(char *));
X    }
X
X    size = tl->num;
X    tl->num++;
X
X    if (tl->size <= size) {
X	while (tl->size <= size)
X	    tl->size *= 2;
X	tl->tnums = (int *)realloc(tl->tnums, tl->size*sizeof(int));
X	tl->tnames = (char **)realloc(tl->tnames, tl->size*sizeof(char *));
X    }
X
X    tl->tnums[size] = targnum;
X    tl->tnames[size] = name;
X}
X
Xstatic void invent_target_lists()
X{
X    int jx, numtargs;
X    char *nm, *realnm;
X    int tl;
X    long stuff;
X
X    TLBeing.num = 0;
X    TLBeingNone.num = 0;
X    TLWizard.num = 0;
X    TLWizardNone.num = 0;
X    TLRaiseDead.num = 0;
X
X    add_to_targetlist(&TLBeingNone, "nobody", 0);
X    add_to_targetlist(&TLWizardNone, "nobody", 0);
X
X    numtargs = NumberOfTargets(gameval, QuVal_Target_Wizard);
X    for (jx=0; jx<numtargs; jx++) {
X	tl = jx | QuVal_Target_Wizard;
X	realnm = NameOfTarget(gameval, QuVal_Target_Wizard, jx);
X	stuff = StuffAboutTarget(gameval, QuVal_Target_Wizard, jx);
X	if (stuff & Stuff_INVISIBLE) {
X	    nm = tempstring_malloc(sizeof(char) * (strlen(realnm) + 15));
X	    strcpy(nm, realnm);
X	    strcat(nm, " [invisible]");
X	}
X	else
X	    nm = realnm;
X	add_to_targetlist(&TLBeing, nm, tl);
X	add_to_targetlist(&TLBeingNone, nm, tl);
X	add_to_targetlist(&TLWizard, nm, tl);
X	add_to_targetlist(&TLWizardNone, nm, tl);
X	add_to_targetlist(&TLRaiseDead, nm, tl);
X    }
X
X    numtargs = NumberOfTargets(gameval, QuVal_Target_Creature);
X    for (jx=0; jx<numtargs; jx++) {
X	tl = jx | QuVal_Target_Creature;
X	realnm = NameOfTarget(gameval, QuVal_Target_Creature, jx);
X	stuff = StuffAboutTarget(gameval, QuVal_Target_Creature, jx);
X	if (stuff & Stuff_INVISIBLE) {
X	    nm = tempstring_malloc(sizeof(char) * (strlen(realnm) + 15)); 
X	    strcpy(nm, realnm);
X	    strcat(nm, " [invisible]");
X	}
X	else
X	    nm = realnm;
X	add_to_targetlist(&TLBeing, nm, tl);
X	add_to_targetlist(&TLBeingNone, nm, tl);
X	add_to_targetlist(&TLRaiseDead, nm, tl);
X    }
X
X    numtargs = NumberOfTargets(gameval, QuVal_Target_Corpse);
X    for (jx=0; jx<numtargs; jx++) {
X	tl = jx | QuVal_Target_Corpse;
X	realnm = NameOfTarget(gameval, QuVal_Target_Corpse, jx);
X	nm = tempstring_malloc(sizeof(char) * (strlen(realnm) + 10));
X	strcpy(nm, realnm);
X	strcat(nm, " [dead]");
X	add_to_targetlist(&TLRaiseDead, nm, tl);
X    }
X}
X
Xvoid XQueries(numqueries, qlist, gameval, rock)
Xint numqueries;
Xstruct query qlist[];
Xgame *gameval;
Xstruct maingame *rock;
X{
X    int ix, jx, kx;
X    char *handage;
X    int spellnum, attnum;
X    struct player *py;
X    int *hlist;
X    int gotany = 0;
X    int pnum;
X    int answer_init;
X    struct target_list *tl;
X    static qu_buf[MAXQUESTIONLENGTH], ans_buf[MAXANSWERLENGTH];
X
X    flush_tempstrings();
X
X    turnstate = State_Queries;
X    for (ix=0; ix<numplayers; ix++) {
X	py = &(players[ix]);
X	py->turn_active = 0;
X	clear_answers(py);
X    }
X
X    for (ix=0; ix<numqueries; ix++) {
X	if (qlist[ix].qtype==Qu_NoQuery)
X	    continue;
X	py = &(players[qlist[ix].player]);
X	py->turn_active = 1;
X	pnum = py-players;
X	gotany = 1;
X	switch (qlist[ix].qtype) {
X	    case Qu_LeftHand:
X	    case Qu_RightHand:
X		if (qlist[ix].qtype==Qu_LeftHand) {
X		    strcpy(qu_buf, "What spell do you want to cast with your left hand?");
X		    tl = &(py->TLLeftHand);
X		}
X		else {
X		    strcpy(qu_buf, "What spell do you want to cast with your right hand?");
X		    tl = &(py->TLRightHand);
X		}
X		hlist = (int *)qlist[ix].rock;
X		tl->num = 0;
X		for (jx=0; jx<hlist[0]; jx++) {
X		    spellnum = hlist[jx+1];
X		    if (spellnum & QuVal_Hand_Both) {
X			handage = tempstring_malloc(sizeof(char) *
X					(strlen(spelllist[spellnum &
X					(~QuVal_Hand_Both)].name) + 16));
X			sprintf(handage, "%s [both hands]",
X					spelllist[spellnum &
X					(~QuVal_Hand_Both)].name);
X		    }
X		    else
X			handage = spelllist[spellnum & (~QuVal_Hand_Both)].name;
X		    add_to_targetlist(tl, handage, jx);
X		}
X		strcpy(ans_buf, "");
X		add_answer(py, qu_buf, ans_buf, 0, 0, &(qlist[ix]), (long)hlist);
X		turnstate = State_EQueries;
X		break;
X	    case Qu_CharmGesture:
X		jx = (int)(qlist[ix].rock);
X		if (jx >= 128) {
X		    spellnum = jx - 128;
X		    jx = 1;
X		}
X		else {
X		    spellnum = jx;
X		    jx = 0;
X		}
X		sprintf(qu_buf, "What gesture do you want %s's %s hand to make?",
X				NameOfBeing(gameval, QuVal_Target_Wizard,
X				spellnum), (jx?"right":"left"));
X		strcpy(ans_buf, "");
X		add_answer(py, qu_buf, ans_buf, 0, 0, &(qlist[ix]), 0);
X		turnstate = State_EQueries;
X		break;
X	    case Qu_WhichToDelay:
X	    case Qu_WhichToPerm:
X		/* use TLRightHand and TLLeftHand, since these queries always
X		   show up by themselves */
X		if (qlist[ix].qtype == Qu_WhichToDelay) {
X		    tl = &(py->TLRightHand);
X		    sprintf(qu_buf, "Which spell do you want to delay?");
X		}
X		else {
X		    tl = &(py->TLLeftHand);
X		    sprintf(qu_buf, "Which spell do you want to make permanent?");
X		}
X		hlist = (int *)qlist[ix].rock;
X		tl->num = 0;
X		for (jx=0; hlist[jx]!=(-1); jx++) {
X		    add_to_targetlist(tl, spelllist[hlist[jx]].name, jx);
X		}
X		strcpy(ans_buf, "");
X		add_answer(py, qu_buf, ans_buf, 0, 0, &(qlist[ix]), 0);
X		turnstate = State_EQueries;
X		break;
X	    case Qu_SetOffDelay:
X		sprintf(qu_buf, "Do you want to release the %s from the Delayed Effect?",
X				spelllist[(int)qlist[ix].rock].name);
X		strcpy(ans_buf, "No");
X		add_answer(py, qu_buf, ans_buf, 1, 0, &(qlist[ix]), 0);
X		turnstate = State_EQueries;
X		break;
X	    case Qu_ParalysisHand:
X	    case Qu_CharmHand:
X		if (qlist[ix].qtype == Qu_ParalysisHand) 
X		    sprintf(qu_buf, "Which of %s's hands do you want to paralyze?",
X				NameOfBeing(gameval, QuVal_Target_Wizard,
X				qlist[ix].rock));
X		else
X		    sprintf(qu_buf, "Which of %s's hands do you want to control?",
X				NameOfBeing(gameval, QuVal_Target_Wizard,
X				qlist[ix].rock));
X		strcpy(ans_buf, "");
X		add_answer(py, qu_buf, ans_buf, 0, 0, &(qlist[ix]), 0);
X		break;
X	    case Qu_ElementalType:
X		sprintf(qu_buf, "Which type of elemental do you want to summon?");
X		strcpy(ans_buf, "");
X		add_answer(py, qu_buf, ans_buf, 0, 0, &(qlist[ix]), 0);
X		break;
X	    case Qu_MonsterTarget:
X		jx = (int)(qlist[ix].rock);
X		attnum = jx / 256;
X		spellnum = jx % 256;
X		switch (attnum) {
X		    case 1:
X			sprintf(qu_buf, "Whom do you want %s to attack?",
X					NameOfBeing(gameval, QuVal_Target_Creature,
X					spellnum));
X			break;
X		    case 2:
X			sprintf(qu_buf, "Whom do you want %s's first attack to be at?",
X					NameOfBeing(gameval, QuVal_Target_Creature,
X					spellnum));
X			break;
X		    case 3:
X			sprintf(qu_buf, "Whom do you want %s's second attack to be at?",
X					NameOfBeing(gameval, QuVal_Target_Creature,
X					spellnum));
X			break;
X		    default:
X			sprintf(qu_buf, "ERROR: Query about %d (%d)", spellnum, attnum);
X			break;
X		}
X		{
X		    int numtargs = NumberOfTargets(gameval, QuVal_Target_Wizard);
X		    strcpy(ans_buf, "nobody");
X		    answer_init = 0;
X		    for (jx=0; jx<numtargs; jx++) {
X			kx = (IndexOfTarget(gameval, QuVal_Target_Wizard, jx) &
X					~QuVal_Target_MASK);
X			if (kx != pnum) {
X			    answer_init = jx | QuVal_Target_Wizard;
X			    strcpy(ans_buf, NameOfTarget(gameval,
X					QuVal_Target_Wizard, jx));
X			    break;
X			}
X		    }
X		}
X		add_answer(py, qu_buf, ans_buf, 1, answer_init, &(qlist[ix]), 0);
X		break;
X	    case Qu_TargetBeing:
X	    case Qu_TargetBeingNone:
X	    case Qu_TargetWizard:
X	    case Qu_TargetWizardNone:
X	    case Qu_TargetRaiseDead:
X		jx = (int)(qlist[ix].rock);
X		spellnum = jx & (~QuVal_Hand_MASK);
X		if (jx & QuVal_Hand_Left)
X		    handage = "with your left hand";
X		else if (jx & QuVal_Hand_Right)
X		    handage = "with your right hand";
X		else if (jx & QuVal_Hand_Both)
X		    handage = "with both hands";
X		else
X		    handage = "from the Delayed Effect";
X		if (spellnum==SP__STAB)
X		    sprintf(qu_buf, "Who do you want to stab at (%s)?", handage);
X		else
X		    sprintf(qu_buf, "Who do you want to cast %s at (%s)?",
X				spelllist[spellnum].name, handage);
X		if (spelllist[spellnum].selfcast) {
X		    int numtargs = NumberOfTargets(gameval, QuVal_Target_Wizard);
X		    strcpy(ans_buf, "nobody");
X		    answer_init = 0;
X		    for (jx=0; jx<numtargs; jx++) {
X			kx = (IndexOfTarget(gameval, QuVal_Target_Wizard, jx) &
X					~QuVal_Target_MASK);
X			if (kx == pnum) {
X			    answer_init = jx | QuVal_Target_Wizard;
X			    strcpy(ans_buf, NameOfTarget(gameval,
X					QuVal_Target_Wizard, jx));
X			    if (StuffAboutTarget(gameval, QuVal_Target_Wizard,
X					jx) & Stuff_INVISIBLE)
X				strcat(ans_buf, " [invisible]");
X			    break;
X			}
X		    }
X		}
X		else {
X		    int numtargs = NumberOfTargets(gameval, QuVal_Target_Wizard);
X		    strcpy(ans_buf, "nobody");
X		    answer_init = 0;
X		    for (jx=0; jx<numtargs; jx++) {
X			kx = (IndexOfTarget(gameval, QuVal_Target_Wizard, jx) &
X					~QuVal_Target_MASK);
X			if (kx != pnum) {
X			    answer_init = jx | QuVal_Target_Wizard;
X			    strcpy(ans_buf, NameOfTarget(gameval,
X					QuVal_Target_Wizard, jx));
X			    if (StuffAboutTarget(gameval, QuVal_Target_Wizard,
X					jx) & Stuff_INVISIBLE)
X				strcat(ans_buf, " [invisible]");
X			    break;
X			}
X		    }
X		}
X		add_answer(py, qu_buf, ans_buf, 1, answer_init, &(qlist[ix]), 0);
X		turnstate = State_EQueries;
X		break;
X	    default:
X		break;
X	}
X    }
X
X    if (!gotany)
X	return;
X
X    invent_target_lists();
X
X    for (ix=0; ix<numplayers; ix++) {
X	py = &(players[ix]);
X	py->turn_done = !py->turn_active;
X    }
X    for (ix=0; ix<numplayers; ix++) {
X	py = &(players[ix]);
X	redraw_column(py);
X	draw_button(py, 0, 1); /* redraw turn-end button */
X	redraw_queries_only(py, 0);
X	/*update_statlist(py);*/
X    }
X    mainloop();
X    for (ix=0; ix<numplayers; ix++) {
X	py = &(players[ix]);
X	for (jx=0; jx<py->siquery.nlines; jx++) {
X	    py->answers[jx].query->answer = py->answers[jx].answer;
X	}
X    }
X}
X
Xvoid draw_query_menu(py)
Xstruct player *py;
X{
X    int ix, jx;
X    int qtype = py->answers[py->query_hit].query->qtype;
X
X    draw_frame(py, &py->query_rect);
X    if (qtype==Qu_CharmGesture) {
X	int posx, posy, hand;
X	posx = py->query_rect.x+20;
X	posy = py->query_rect.y+20;
X	hand = (strstr(py->answers[py->query_hit].qu_str, "right hand") ? 1 : 0);
X	for (jx=0; jx<2; jx++)
X	    for (ix=0; ix<4; ix++) {
X		XCopyPlane(py->dpy, py->gesturebm[hand][jx*4+ix], py->win,
X				py->blackgc, 0, 0, GEST_SIZE, GEST_SIZE,
X				posx+ix*GEST_SPACE, posy+jx*GEST_SPACE, 1);
X	    }
X    }
X    else {
X	for (ix=0; ix<py->query_tl->num; ix++) {
X	    XDrawImageString(py->dpy, py->win, py->blackgc, py->query_rect.x+16,
X			py->query_rect.y + ix*(py->lineheight+QMENU_LEADING) +
X			py->lineheight + QMENU_BORDER, py->query_tl->tnames[ix],
X			strlen(py->query_tl->tnames[ix]));
X	}
X    }
X}
X
Xint in_query_box(py, xpos, ypos)
Xstruct player *py;
Xint xpos, ypos;
X{
X    return (xpos>=QUERY_X && ypos>=QUERY_Y && xpos<QUERY_X+QUERY_W
X	    && ypos<QUERY_Y+QUERY_H);
X}
X
Xint query_hit(py, xpos, ypos, button)
Xstruct player *py;
Xint xpos, ypos;
Xint button;
X{
X    int hitq = (ypos-QUERY_Y) / py->query_hgt + py->siquery.top;
X    int ix;
X    static XCharStruct overall;
X    int direction, ascent, descent;
X
X    if (!py->turn_active || py->turn_done)
X	return ms_None;
X
X    if (hitq<0 || hitq>=py->siquery.nlines)
X	return ms_None;
X
X    if (!py->answers[hitq].query)
X	return ms_None;
X
X    switch (py->answers[hitq].query->qtype) {
X	case Qu_WhichToPerm:
X	    py->query_tl = (&(py->TLLeftHand));
X	    break;
X	case Qu_WhichToDelay:
X	    py->query_tl = (&(py->TLRightHand));
X	    break;
X	case Qu_LeftHand:
X	    py->query_tl = (&(py->TLLeftHand));
X	    break;
X	case Qu_RightHand:
X	    py->query_tl = (&(py->TLRightHand));
X	    break;
X	case Qu_ElementalType:
X	    py->query_tl = (&TLElementalType);
X	    break;
X	case Qu_MonsterTarget:
X	    py->query_tl = (&TLBeingNone);
X	    break;
X	case Qu_TargetBeing:
X	    py->query_tl = (&TLBeing);
X	    break;
X	case Qu_TargetBeingNone:
X	    py->query_tl = (&TLBeingNone);
X	    break;
X	case Qu_TargetWizard:
X	    py->query_tl = (&TLWizard);
X	    break;
X	case Qu_TargetWizardNone:
X	    py->query_tl = (&TLWizardNone);
X	    break;
X	case Qu_TargetRaiseDead:
X	    py->query_tl = (&TLRaiseDead);
X	    break;
X	case Qu_ParalysisHand:
X	case Qu_CharmHand:
X	    py->query_tl = (&TLPickHand);
X	    break;
X	case Qu_SetOffDelay:
X	    py->query_tl = (&TLNoYes);
X	    break;
X	case Qu_CharmGesture:
X	    py->query_tl = NULL;
X	    break;
X	case Qu_SaveTranscript: /* special value defined in xspell.h */
X	    py->query_tl = (&TLNoYes);
X	    break;
X	default:
X	    return ms_None;
X	    break;
X    }
X
X    py->query_hit = hitq;
X
X    if (py->answers[hitq].query->qtype==Qu_CharmGesture) {
X	py->query_rect.w = 240;
X	py->query_rect.h = 140;
X	py->query_rect.x = xpos - py->query_rect.w/2;
X	py->query_rect.y = ypos - py->query_rect.h/2;
X    }
X    else {
X	int maxwid = 0;
X	for (ix=0; ix<py->query_tl->num; ix++) {
X	    XTextExtents(py->font, py->query_tl->tnames[ix],
X			strlen(py->query_tl->tnames[ix]), &direction, &ascent,
X			&descent, &overall);
X	    if (overall.width > maxwid)
X		maxwid = overall.width;
X	}
X	py->query_rect.w = maxwid + 32 + FRAME_SHADOW;
X	py->query_rect.h = py->query_tl->num * (py->lineheight+QMENU_LEADING) +
X			2*QMENU_BORDER+FRAME_SHADOW;
X	py->query_rect.x = xpos - py->query_rect.w/2;
X	py->query_rect.y = ypos - py->query_rect.h/2;
X    }
X    py->query_sel = (-1);
X    adjust_rect(&py->query_rect);
X    backing_store(py, &py->query_rect);
X    draw_query_menu(py);
X    query_motion(py, xpos, ypos, button);
X
X    return ms_Query;
X}
X
Xint query_motion(py, xpos, ypos, button)
Xstruct player *py;
Xint xpos, ypos;
Xint button;
X{
X    int hitrow;
X    int qtype = py->answers[py->query_hit].query->qtype;
X
X    if (qtype==Qu_CharmGesture) {
X	int posx, posy, hitx, hity;
X
X	posx = py->query_rect.x+20;
X	posy = py->query_rect.y+20;
X
X	hitx = (xpos - posx + GEST_SPACE) / GEST_SPACE - 1;
X	hity = (ypos - posy + GEST_SPACE) / GEST_SPACE - 1;
X
X	if (hitx>=0 && hitx<4 && hity>=0 && hity<2)
X	    hitrow = hity*4 + hitx;
X	else
X	    hitrow = (-1);
X
X	if (hitrow==py->query_sel)
X	    return;
X
X	if (py->query_sel != (-1)) {
X	    /* erase old */
X	    hitx = py->query_sel % 4;
X	    hity = py->query_sel / 4;
X	    XDrawRectangle(py->dpy, py->win, py->whitegc, posx+hitx*GEST_SPACE-1,
X			posy+hity*GEST_SPACE-1, GEST_SIZE+1, GEST_SIZE+1);
X	    XDrawRectangle(py->dpy, py->win, py->whitegc, posx+hitx*GEST_SPACE-2,
X			posy+hity*GEST_SPACE-2, GEST_SIZE+3, GEST_SIZE+3);
X	}
X
X	py->query_sel = hitrow;
X
X	if (py->query_sel != (-1)) {
X	    /* draw new */
X	    hitx = py->query_sel % 4;
X	    hity = py->query_sel / 4;
X	    XDrawRectangle(py->dpy, py->win, py->blackgc, posx+hitx*GEST_SPACE-1,
X			posy+hity*GEST_SPACE-1, GEST_SIZE+1, GEST_SIZE+1);
X	    XDrawRectangle(py->dpy, py->win, py->blackgc, posx+hitx*GEST_SPACE-2,
X			posy+hity*GEST_SPACE-2, GEST_SIZE+3, GEST_SIZE+3);
X	}
X    }
X    else {
X	ypos -= (py->query_rect.y + QMENU_BORDER);
X	if (ypos<0 || xpos < py->query_rect.x ||
X			xpos >= py->query_rect.x+py->query_rect.w)
X	    hitrow = (-1);
X	else 
X	    hitrow = ypos / (py->lineheight+QMENU_LEADING);
X
X	if (hitrow<0 || hitrow>=py->query_tl->num)
X	    hitrow = (-1);
X
X	if (hitrow==py->query_sel)
X	    return;
X
X	if (py->query_sel != (-1)) {
X	    /* erase old */
X	    XDrawRectangle(py->dpy, py->win, py->whitegc,
X			py->query_rect.x+QMENU_BORDER, py->query_rect.y +
X			py->query_sel*(py->lineheight+QMENU_LEADING) +
X			QMENU_BORDER, py->query_rect.w-(FRAME_SHADOW+2*QMENU_BORDER),
X			py->lineheight+QMENU_LEADING);
X	}
X
X	py->query_sel = hitrow;
X
X	if (py->query_sel != (-1)) {
X	    /* draw new */
X	    XDrawRectangle(py->dpy, py->win, py->blackgc,
X			py->query_rect.x+QMENU_BORDER, py->query_rect.y +
X			py->query_sel*(py->lineheight+QMENU_LEADING) +
X			QMENU_BORDER, py->query_rect.w-(FRAME_SHADOW+2*QMENU_BORDER),
X			py->lineheight+QMENU_LEADING);
X	}
X    }
X}
X
Xint query_release(py, xpos, ypos, button)
Xstruct player *py;
Xint xpos, ypos;
Xint button;
X{
X    int qtype = py->answers[py->query_hit].query->qtype;
X    int ix, jx;
X
X    backing_restore(py);
X    if (py->query_sel != (-1)) {
X	if (qtype==Qu_CharmGesture) {
X	    py->answers[py->query_hit].answer = py->query_sel;
X	    py->answers[py->query_hit].done = 1;
X	    strcpy(py->answers[py->query_hit].ans_str, gesture_name(py->query_sel));
X	}
X	else {
X	    py->answers[py->query_hit].answer = py->query_tl->tnums[py->query_sel];
X	    py->answers[py->query_hit].done = 1;
X	    strcpy(py->answers[py->query_hit].ans_str, py->query_tl->tnames[py->query_sel]);
X	    if (qtype==Qu_LeftHand || qtype==Qu_RightHand) {
X		struct answer *ans = (&(py->answers[py->query_hit]));
X		struct answer *anso;
X		int *hlist = (int *)ans->rock;
X		int *hlisto;
X		int otherq;
X		int forceans = (-1);
X		struct target_list *othertl;
X
X		if (qtype==Qu_LeftHand) {
X		    otherq = Qu_RightHand;
X		    othertl = (&(py->TLRightHand));
X		}
X		else {
X		    otherq = Qu_LeftHand;
X		    othertl = (&(py->TLLeftHand));
X		}
X
X		for (ix=0; ix<py->siquery.nlines; ix++) {
X		    if (py->answers[ix].query->qtype == otherq) {
X			anso = (&(py->answers[ix]));
X			hlisto = (int *)anso->rock;
X			if (hlist[py->query_sel+1] & QuVal_Hand_Both) {
X			    /* force other hand to same spell */
X			    for (jx=0; jx<hlisto[0]; jx++)
X				if (hlist[py->query_sel+1] == hlisto[jx+1]) {
X				    forceans = jx;
X				    break;
X				}
X			}
X			else {
X			    /* should force other hand away from 2-handed
X			       answer, but there is no case in the game where
X			       this is a concern. */
X			}
X			if (forceans != (-1)) {
X			    /*printf("Forcing q.%d to %d\n", ix, forceans);
X			      fflush(stdout);*/
X			    py->answers[ix].answer = othertl->tnums[forceans];
X			    py->answers[ix].done = 1;
X			    strcpy(py->answers[ix].ans_str, othertl->tnames[forceans]);
X			}
X		    }
X		}
X	    }
X	}
X	redraw_queries_only(py, 0);
X    }
X}
X
END_OF_FILE
if test 22441 -ne `wc -c <'xquery.c'`; then
    echo shar: \"'xquery.c'\" unpacked with wrong size!
fi
# end of 'xquery.c'
fi
if test -f 'xtext.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xtext.c'\"
else
echo shar: Extracting \"'xtext.c'\" \(7540 characters\)
sed "s/^X//" >'xtext.c' <<'END_OF_FILE'
X#include <string.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include "handwave.h"
X#include "spelllist.h"
X#include "xspell.h"
X
X#define TEXT_WID (400)
X#define TEXT_HGT (512)
X#define TEXT_X (32)
X#define TEXT_Y (32)
X
X#define MAXLINESIZE (512) /* maximum number of chars that could possibly fit
X			     in a line. If the player uses bits1, this will
X			     probably crash. Tough. */
X
Xstatic void redraw_text_only();
Xvoid redraw_scrollbar();
X
Xvoid init_xtext(pnum)
Xint pnum;
X{
X    struct player *py = &(players[pnum]);
X    static XCharStruct overall;
X    int direction, ascent, descent;
X
X    py->cursx = 0;
X    py->sitext.nlines = 0;
X
X    XTextExtents(py->font, "pl", 2, &direction, &ascent, &descent, &overall);
X    py->lineheight = ascent+descent;
X    if (py->lineheight <= 12)
X	py->lineheight += 2;
X    else
X	py->lineheight = (int)((double)(py->lineheight)*1.17);
X
X    py->texty = TEXT_Y + ascent + 1;
X    py->textx = TEXT_X;
X    py->sitext.visible = (TEXT_HGT-2) / py->lineheight;
X
X    py->ascent = ascent;
X    py->totalheight = ascent+descent;
X    
X    py->lineindex_size = 10;
X    py->lineindex = (struct line *)malloc(sizeof(struct line)*py->lineindex_size);
X    py->linebuf_size = 2*MAXLINESIZE;
X    py->linebuf = (char *)malloc(py->linebuf_size);
X    strcpy(py->linebuf, "");
X    py->addpoint = 0;
X    py->lineindex[0].start = 0;
X
X    py->sitext.py = py;
X    py->sitext.top = 0;
X    py->sitext.lineheight = py->lineheight;
X    py->sitext.x = TEXT_X;
X    py->sitext.y = TEXT_Y;
X    py->sitext.h = TEXT_HGT;
X    py->sitext.redraw = redraw_text_only;
X}
X
Xstatic void redraw_text_only(py, baronly)
Xstruct player *py;
Xint baronly;
X{
X    int ix, sline;
X    int len, width;
X
X    if (!baronly) {
X	/* draw text */
X	for (ix=py->sitext.top; ix<=py->sitext.nlines; ix++) {
X	    sline = ix - py->sitext.top;
X	    if (sline>=py->sitext.visible)
X		break;
X	    if (ix==py->sitext.nlines) {
X		len = strlen(py->linebuf+py->lineindex[ix].start);
X	    }
X	    else {
X		len = py->lineindex[ix].len;
X	    }
X	    width = py->lineindex[ix].width;
X	    XDrawImageString(py->dpy, py->win, py->blackgc, py->textx,
X			py->texty + py->lineheight*sline,
X			py->linebuf+py->lineindex[ix].start, len);
X	    XClearArea(py->dpy, py->win, py->textx+width, py->texty +
X			py->lineheight*sline - py->ascent, TEXT_WID-width,
X			py->totalheight, 0);
X	}
X    }
X
X    redraw_scrollbar(&(py->sitext));
X}
X
Xvoid complete_line(py)
Xstruct player *py;
X{
X    int ln = py->sitext.nlines;
X    int jump;
X    static XCharStruct overall;
X    int direction, ascent, descent;
X    char *start;
X
X    if (ln+2 >= py->lineindex_size) {
X	py->lineindex_size *= 2;
X	py->lineindex = (struct line *)realloc(py->lineindex,
X			sizeof(struct line)*py->lineindex_size);
X    }
X    start = py->linebuf+py->lineindex[ln].start;
X    py->lineindex[ln].len = strlen(start);
X    XTextExtents(py->font, start, py->lineindex[ln].len, &direction, &ascent,
X		&descent, &overall);
X    py->lineindex[ln].width = overall.width;
X
X    /* set up new incomplete line */
X    py->lineindex[ln+1].start = py->lineindex[ln].start+py->lineindex[ln].len + 1;
X    /* len will not be computed until line is finished */
X    py->lineindex[ln+1].width = 0;
X    start = NULL;
X    if (py->lineindex[ln+1].start >= py->linebuf_size+MAXLINESIZE) {
X	py->linebuf_size *= 2;
X	py->linebuf = (char *)realloc(py->linebuf, py->linebuf_size);
X    }
X    strcpy(py->linebuf+py->lineindex[ln+1].start, "");
X    py->addpoint = py->lineindex[ln+1].start;
X
X    py->cursx = 0;
X    py->sitext.nlines++;
X
X    if (py->sitext.nlines-py->sitext.top == py->sitext.visible) {
X	jump = ((py->sitext.nlines-py->sitext.top) - py->sitext.visible) + 1;
X	py->sitext.top += jump;
X	if (!py->backstore)
X	    redraw_text_only(py, 0);
X    }
X    else {
X	if (!py->backstore)
X	    redraw_text_only(py, 1);
X    }
X}
X
Xvoid redraw_text(py)
Xstruct player *py;
X{
X    XDrawRectangle(py->dpy, py->win, py->blackgc, TEXT_X-3, TEXT_Y-2,
X		TEXT_WID+4, TEXT_HGT+3);
X    XDrawRectangle(py->dpy, py->win, py->blackgc, TEXT_X-SCROLL_W, TEXT_Y-2,
X		SCROLL_W-3, TEXT_HGT+3);
X    redraw_text_only(py, 0);
X}
X
Xvoid dump_text(pnum, str)
Xint pnum;
Xchar *str;
X{
X    struct player *py = &(players[pnum]);
X    char *cx, *cy;
X    int tmp;
X    char *chtmp;
X    int len, width, sline;
X    static XCharStruct overall;
X    int direction, ascent, descent;
X
X    if (!str) return;
X
X    cx = str;
X
X    while (*cx) {
X	for (cy=cx;
X	     !(*cy=='\0' || *cy=='\n' || (*cy==' ' && cy>cx && *(cy-1)!=' '));
X	     cy++);
X	len = (cy-cx);
X	XTextExtents(py->font, cx, len, &direction, &ascent, &descent, &overall);
X	width = overall.width;
X	if (width >= TEXT_WID - py->cursx) {
X	    complete_line(py);
X	}
X	sline = py->sitext.nlines - py->sitext.top;
X	if (sline>=0 && sline<py->sitext.visible) {
X	    py->gotexpose = 1;
X	    if (!py->backstore)
X		XDrawImageString(py->dpy, py->win, py->blackgc, py->textx+py->cursx,
X				py->texty + py->lineheight*sline, cx, len);
X	}
X	chtmp = py->linebuf+py->addpoint;
X	for (tmp=0; tmp<len; tmp++)
X	    chtmp[tmp] = cx[tmp];
X	chtmp[tmp] = '\0';
X	py->addpoint += len;
X	py->cursx += width;
X	py->lineindex[py->sitext.nlines].width = py->cursx;
X
X	if (*cy=='\n') {
X	    complete_line(py);
X	    cy++;
X	}
X
X	cx = cy;
X    }
X}
X
Xint in_scrollbar_box(si, xpos, ypos)
Xstruct scroll_interface *si;
Xint xpos, ypos;
X{
X    return (xpos >= si->x-SCROLL_W
X	    && xpos < si->x
X	    && ypos >= si->y
X	    && ypos < si->y+si->h);
X}
X
Xvoid redraw_scrollbar(si)
Xstruct scroll_interface *si;
X{
X    struct player *py = si->py;
X    int sbeg, send;
X
X    /* draw scrollbar */
X    if (si->nlines) {
X	sbeg = (si->top)*si->h / si->nlines;
X	send = (si->top+si->visible)*si->h / si->nlines;
X	if (send>si->h)
X	    send = si->h;
X    }
X    else {
X	sbeg = 0;
X	send = si->h;
X    }
X
X    if (sbeg>0) {
X	XFillRectangle(py->dpy, py->win, py->whitegc, si->x-SCROLL_W+2, si->y,
X			SCROLL_W-6, sbeg);
X    }
X    XFillRectangle(py->dpy, py->win, py->blackgc, si->x-SCROLL_W+2, si->y+sbeg,
X		SCROLL_W-6, send-sbeg);
X    if (send<si->h) {
X	XFillRectangle(py->dpy, py->win, py->whitegc, si->x-SCROLL_W+2,
X			si->y+send, SCROLL_W-6, si->h-send);
X    }
X}
X
Xint scrollbar_hit(si, xpos, ypos, button)
Xstruct scroll_interface *si;
Xint xpos, ypos;
Xint button;
X{
X    int sbeg, send;
X
X    if (si->nlines) {
X	sbeg = (si->top)*si->h / si->nlines;
X	send = (si->top+si->visible)*si->h / si->nlines;
X	if (send>si->h)
X	    send = si->h;
X    }
X    else {
X	sbeg = 0;
X	send = si->h;
X    }
X
X    if (ypos>=si->y+sbeg && ypos<si->y+send) {
X	si->grip = ypos - (si->y+sbeg);
X    }
X    else {
X	si->grip = (-1);
X    }
X    si->moved = 0;
X
X    si->py->scroll_active = si;
X    return ms_Scroll;
X}
X
Xint scrollbar_motion(si, xpos, ypos, button)
Xstruct scroll_interface *si;
Xint xpos, ypos;
Xint button;
X{
X    int newtop;
X
X    si->moved = 1;
X
X    if (si->grip != (-1)) {
X	newtop = (ypos-si->grip-si->y)*si->nlines / si->h;
X	if (newtop > si->nlines - si->visible + 1)
X	    newtop = si->nlines - si->visible + 1;
X	if (newtop<0)
X	    newtop = 0;
X
X	if (si->top != newtop) {
X	    si->top = newtop;
X	    (*(si->redraw))(si->py, 0);
X	}
X    }
X}
X
Xint scrollbar_release(si, xpos, ypos, button)
Xstruct scroll_interface *si;
Xint xpos, ypos;
Xint button;
X{
X    int ln;
X    int newtop;
X
X    if (!si->moved) {
X	ln = (ypos-si->y) / si->lineheight;
X	if (ln<=0)
X	    ln = 1;
X	newtop = si->top;
X	if (button==1)
X	    newtop += (ln);
X	else if (button==3)
X	    newtop -= (ln);
X
X	if (newtop > si->nlines - si->visible + 1)
X	    newtop = si->nlines - si->visible + 1;
X	if (newtop<0)
X	    newtop = 0;
X
X	if (si->top != newtop) {
X	    si->top = newtop;
X	    (*(si->redraw))(si->py, 0);
X	}
X    }
X}
END_OF_FILE
if test 7540 -ne `wc -c <'xtext.c'`; then
    echo shar: \"'xtext.c'\" unpacked with wrong size!
fi
# end of 'xtext.c'
fi
echo shar: End of archive 5 \(of 7\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
