Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i032:  spellcast - strategy game for X11, Part06/07
Date: 14 Jul 1993 19:40:33 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2112
Approved: billr@saab.CNA.TEK.COM
Message-ID: <221nfh$rpl@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1832

Submitted-by: Andrew Plotkin <ap1i+@andrew.cmu.edu>
Posting-number: Volume 18, Issue 32
Archive-name: spellcast/part06
Environment: X11, Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 7)."
# Contents:  bitmaps/base.ps bitmaps/sd2.bm espells.c handwave.h
#   internal.h main.c patchlevel.h xbutton.c xgest.c xtalk.c
# Wrapped by billr@saab on Wed Jul 14 12:32:51 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'bitmaps/base.ps' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/base.ps'\"
else
echo shar: Extracting \"'bitmaps/base.ps'\" \(5774 characters\)
sed "s/^X//" >'bitmaps/base.ps' <<'END_OF_FILE'
X%!
X
X/centershow
X   {gsave dup stringwidth pop 2 div neg 0 rmoveto
X    show 
X    grestore} def 
X
X/clapstr 288 string def
X/snapstr 288 string def
X/wavestr 288 string def
X/digitstr 288 string def
X/palmstr 288 string def
X/fingerstr 288 string def
X
Xcurrentfile clapstr readhexstring
Xffffffffffffffffffffffffffffffffffffffffffff3fffffffffff1fff
Xfffffffe1ffffffffffe1ffffffffffe1ffffffffffc3ffffffffff83fff
Xfffffff83ffffffffff87ffffffffff07ffffffffff07fffffffffe07fff
Xffffffe0ffffffffffe0ffffffffffc0ffffffffffc0ffffffffffc0ffff
Xffffffc0ffffffffffc0ffffffffffc0ffffffffff80ffffffffff80ffff
Xffffff80ffffffffff80ffffffffffc07fffffffffc07fffffffffc07fff
Xffffffc07fffffffffc07fffffffffc03fffffffffc03fffffffffc01fff
Xffffffc01fffffffffc01fffffffffc00fffffffff800fffffffff800fff
Xffffff801fffffffff001ffffffffe001ffffffffe003ffffffffc003fff
Xfffff0007fffffffe000ffffffffffffffff
Xpop pop
X
Xcurrentfile snapstr readhexstring
Xfffffffffffffffffffffffffffff7ffbffffffffbffbffffffffdffbfff
Xfffffdff7ffffffffeff7fffffffffffffffffffffffff3ffffffffff8ff
Xffffffc7f7ffffffff03fffffffff803fffffffff000ffffffffc0007fff
Xffff00007ffffffe00007e03fffc00007ffffff800607ffffff000e07fff
Xffe001e0ffffffc003c0ffffff8007c0fbffff000f80fdffff001f01feff
Xfe001e01ff7ffe003c01fffffc002001fffffc000000fffffc0000007fff
Xfc0000003ffffc0000001ffffe0000001fffff0000001fffff0000000fff
Xffc000000fffffe000000ffffff000000ffffff800000ffffffe00000fff
Xffff00000fffffff80000fffffffc0001fffffffe0001fffffffe0003fff
Xfffff8003ffffffff8007fffffffffffffff
Xpop pop
X
Xcurrentfile wavestr readhexstring
Xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
Xfffffffffffffffffffffffffffffffffffffffffffffffffffffff0ffff
Xffffffe07fffffffff807fffffffff01fffffffffc03fffffffff007ffff
Xffffc01fffffffff803fffffffff007fffffffff00fffffffffe01ffffff
Xfffc03fffffffff803fffffffff007ffffffffe007ffffffffc00fffffff
Xffc00fffffffff8007ffffffff8007ffffffff8003ffffffffc001ffffff
Xffe000fffffffff0003ffffffff8001ffffffffc000ffffffffe0007ffff
Xffff0003ffffffff8000ffffffffc0007fffffffe0003ffffffff0001fff
Xfffff0001ffffffff0000ffffffff0000ffffffff0000fffffffe0000fff
Xffffc0001fffffffc0003fffffffffffffff
Xpop pop
X
Xcurrentfile digitstr readhexstring
Xfffffffffffffffffffffffffffffffffffffffffffcfffffffffffc7fff
Xfffffff87ffffffffff87ffffffffff07ffffffffff07fffffffffe0ffff
Xffffffe0ffffffffffe0ffffffffffc1ffffffffffc1ffffffffff81ffff
Xffffff81ffffffffff03ffffffffff03fffffffffe03fffffffffc03ffff
Xffffc003ffffffffc003fffffffe0003fffffffc00021ffffffc00001fff
Xffe000003fffffe000003fffffc000003fffff8000007fffff8000007fff
Xff8000007fffff8000007fffff8000007fffff8000007fffff800000ffff
Xff800000ffffff800001ffffff800001ffffff800003ffffffc00003ffff
Xffc00007ffffffe0000ffffffff0001ffffffff0001ffffffff0007fffff
Xffe000ffffffffc000ffffffffffffffffff
Xpop pop
X
Xcurrentfile palmstr readhexstring
Xfffffffffffffffffffffffffffffe7ffffffffffe3ffffffffffc39ffff
Xfffffc38fffffffffc30ffffffff9c30ffffffff1c30ffffffff0c30ffff
Xffff0c30ffffffff0c30ffffffff0c30ffffffff0c30ffffffff0c30ffff
Xffff0c30fffffff70c30ffffffe30c30ffffffe30c30ffffffe30c30ffff
Xffe30c30ffffffc30c10ff3fffc20800fe3fffc20000fe3fffc20000fc3f
Xffc20000fc3fffc00000783fffc00000783fffc00000707fffc00000607f
Xffc00000407fffc00000007fffc0000000ffffc0000000ffffc0000001ff
Xffc0000003ffffe0000003ffffe0000007ffffe000000fffffe000000fff
Xfff000001ffffff000001ffffff000003ffffff800007ffffff800007fff
Xfffc0001fffffffe0001ffffffffffffffff
Xpop pop
X
Xcurrentfile fingerstr readhexstring
Xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
Xfffffffffffffffffffffffffffffffffffffffffffffffffffffcf87fff
Xfffff8707ffffffff0e0ffffffffc1c1fc3fffff8383f03fffff0707e07f
Xffe70e0fc0ffffc60c1f83ffff861c1f03ffff0c183e07ffff18183e0fff
Xfe18383c0ffffe30303c1ffffc3030381ffffc2060103ffffc2000003fff
Xfc0000003ffffc0000003ffffc0000007e3ffc0000007e3ffc0000007c3f
Xfc000000783ffc000000703ffc000000607ffe000000007ffe00000000ff
Xfe00000001fffe00000003fffe00000007ffff0000000fffff8000003fff
Xff8000007fffff000000fffffe000003fffffc00000ffffff800001fffff
Xf000007ffffff000007fffffffffffffffff
Xpop pop
X
X/showfinger {
Xgsave
Xtranslate 12 12 scale 
X48 48 false [ 48 0 0 -48 0 48 ] { fingerstr }
Ximagemask
Xgrestore
X} def
X
X/showpalm {
Xgsave
Xtranslate 12 12 scale 
X48 48 false [ 48 0 0 -48 0 48 ] { palmstr }
Ximagemask
Xgrestore
X} def
X
X/showdigit {
Xgsave
Xtranslate 12 12 scale 
X48 48 false [ 48 0 0 -48 0 48 ] { digitstr }
Ximagemask
Xgrestore
X} def
X
X/showsnap {
Xgsave
Xtranslate 12 12 scale 
X48 48 false [ 48 0 0 -48 0 48 ] { snapstr }
Ximagemask
Xgrestore
X} def
X
X/showwave {
Xgsave
Xtranslate 12 12 scale 
X48 48 false [ 48 0 0 -48 0 48 ] { wavestr }
Ximagemask
Xgrestore
X} def
X
X/showclap {
Xgsave
Xtranslate 12 12 scale 
X48 48 false [ 48 0 0 -48 0 48 ] { clapstr }
Ximagemask
Xgrestore
X} def
X
X/showclap2 {
Xgsave
Xtranslate 12 12 scale 
X-0.3 0 translate
X48 48 false [ 48 0 0 -48 0 48 ] { clapstr }
Ximagemask
X1.6 0 translate
X-1 1 scale
X48 48 false [ 48 0 0 -48 0 48 ] { clapstr }
Ximagemask
Xgrestore
X} def
X
X/showdigit2 {
Xgsave
Xtranslate 12 12 scale 
X-0.0 0 translate
X48 48 false [ 48 0 0 -48 0 48 ] { digitstr }
Ximagemask
X1.5 0 translate
X-1 1 scale
X48 48 false [ 48 0 0 -48 0 48 ] { digitstr }
Ximagemask
Xgrestore
X} def
X
X/showwave2 {
Xgsave
Xtranslate 12 12 scale 
X-0.0 0 translate
X48 48 false [ 48 0 0 -48 0 48 ] { wavestr }
Ximagemask
X1.55 0 translate
X-1 1 scale
X48 48 false [ 48 0 0 -48 0 48 ] { wavestr }
Ximagemask
Xgrestore
X} def
X
X/showsnap2 {
Xgsave
Xtranslate 12 12 scale 
X-0.0 0 translate
X48 48 false [ 48 0 0 -48 0 48 ] { snapstr }
Ximagemask
X1.55 0 translate
X-1 1 scale
X48 48 false [ 48 0 0 -48 0 48 ] { snapstr }
Ximagemask
Xgrestore
X} def
X
X/showpalm2 {
Xgsave
Xtranslate 12 12 scale 
X-0.2 0 translate
X48 48 false [ 48 0 0 -48 0 48 ] { palmstr }
Ximagemask
X1.6 0 translate
X-1 1 scale
X48 48 false [ 48 0 0 -48 0 48 ] { palmstr }
Ximagemask
Xgrestore
X} def
X
X/nullact {
Xpop pop
X} def
X
END_OF_FILE
if test 5774 -ne `wc -c <'bitmaps/base.ps'`; then
    echo shar: \"'bitmaps/base.ps'\" unpacked with wrong size!
fi
# end of 'bitmaps/base.ps'
fi
if test -f 'bitmaps/sd2.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/sd2.bm'\"
else
echo shar: Extracting \"'bitmaps/sd2.bm'\" \(276 characters\)
sed "s/^X//" >'bitmaps/sd2.bm' <<'END_OF_FILE'
X#define sd2_width 16
X#define sd2_height 16
X#define sd2_x_hot -1
X#define sd2_y_hot -1
Xstatic char sd2_bits[] = {
X0x00,0x00,0x80,0x04,0xc0,0x0c,0xc0,0x0c,0x60,0x0c,0x60,0x0c,
X0x70,0x1c,0x7c,0x7c,0xfe,0xfe,0xff,0xfe,0xff,0xfe,0xff,0xfe,
X0x7f,0xfc,0x7f,0xfc,0x3e,0xf8,0x1f,0xf8};
END_OF_FILE
if test 276 -ne `wc -c <'bitmaps/sd2.bm'`; then
    echo shar: \"'bitmaps/sd2.bm'\" unpacked with wrong size!
fi
# end of 'bitmaps/sd2.bm'
fi
if test -f 'espells.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'espells.c'\"
else
echo shar: Extracting \"'espells.c'\" \(5841 characters\)
sed "s/^X//" >'espells.c' <<'END_OF_FILE'
X#include <strings.h>
X
X#include "handwave.h"
X#include "internal.h"
X
X/* the following are purely for readability */
X#define P Gesture_PALM
X#define D Gesture_DIGIT
X#define F Gesture_FINGERS
X#define W Gesture_WAVE
X#define C Gesture_CLAPHALF
X#define S Gesture_SNAP
X#define P2 (Gesture_PALM | Gesture_DOUBLE)
X#define D2 (Gesture_DIGIT | Gesture_DOUBLE)
X#define F2 (Gesture_FINGERS | Gesture_DOUBLE)
X#define W2 (Gesture_WAVE | Gesture_DOUBLE)
X#define C2 (Gesture_CLAPHALF | Gesture_DOUBLE)
X#define S2 (Gesture_SNAP | Gesture_DOUBLE)
X
Xstruct spelldef spelllist[NUMSPELLS] = {
X    {4, {C2, D,  P,  W},	0, 1, "Dispel Magic"},
X    {5, {C2, S,  W,  W,  S},	0, 1, "Summon Elemental"},
X    {2, {C2, W2},		0, 1, "Magic Mirror"},
X    {5, {D,  F,  F,  D,  D},	0, 0, "Lightning Bolt"},
X    {4, {D,  F,  P,  W},	0, 1, "Cure Heavy Wounds"},
X    {3, {D,  F,  W},		0, 1, "Cure Light Wounds"},
X    {3, {D,  P,  P},		1, 0, "Amnesia"},
X    {3, {D,  S,  F},		1, 0, "Confusion"},
X    {6, {D,  S,  F,  F,  F,  C2},0, 0,"Disease"},
X    {5, {D,  W,  F,  F,  D2},	1, 0, "Blindness"},
X    {6, {D,  W,  S,  S,  S,  P},0, 1, "Delayed Effect"},
X    {6, {D,  W,  W,  F,  W,  C2},0, 1,"Raise Dead"},
X    {6, {D,  W,  W,  F,  W,  D},0, 0, "Poison"},
X    {3, {F,  F,  F},		1, 0, "Paralysis"},
X    {5, {F,  P,  S,  F,  W},	0, 1, "Summon Troll"},
X    {5, {F,  S,  S,  D,  D},	0, 0, "Fireball"},
X    {1, {P},			0, 1, "Shield"},
X    {1, {P2},			0, 0, "SURRENDER"},
X    {4, {P,  D,  W,  P},	0, 1, "Remove Enchantment"},
X    {4, {P,  P,  W2, S2},	1, 1, "Invisibility"},
X    {4, {P,  S,  D,  D},	1, 0, "Charm Monster"},
X    {4, {P,  S,  D,  F},	1, 0, "Charm Person"},
X    {4, {P,  S,  F,  W},	0, 1, "Summon Ogre"},
X    {8, {P,  W,  P,  F,  S,  S,  S,  D},0,0,"Finger of Death"},
X    {6, {P,  W,  P,  W,  W,  C2},1, 1,"Haste"},
X    {2, {S,  D},		0, 0, "Missile"},
X    {3, {S,  F,  W},		0, 1, "Summon Goblin"},
X    {3, {S,  P,  F},		0, 0, "Anti-Spell"},
X    {7, {S,  P,  F,  P,  S,  D,  W},0,1,"Permanency"},
X    {4, {S,  P,  P,  C2},	0, 1, "Time Stop"},
X    {4, {S,  S,  F,  P},	1, 1, "Resist Cold"},
X    {3, {S,  W,  D},		1, 0, "Fear"},
X    {4, {S,  W,  W,  C2},	0, 0, "Fire Storm"},
X    {4, {W,  D,  D,  C2},	0, 0, "Lightning Bolt"},
X    {3, {W,  F,  P},		0, 0, "Cause Light Wounds"},
X    {6, {W,  F,  P,  S,  F,  W},0, 1, "Summon Giant"},
X    {4, {W,  P,  F,  D},	0, 0, "Cause Heavy Wounds"},
X    {3, {W,  P,  P},		0, 0, "Counter-Spell"},
X    {4, {W,  S,  S,  C2},	0, 0, "Ice Storm"},
X    {4, {W,  W,  F,  P},	1, 1, "Resist Heat"},
X    {3, {W,  W,  P},		1, 1, "Protection From Evil"},
X    {3, {W,  W,  S},		0, 0, "Counter-Spell"},
X    {1,	{Gesture_KNIFE},	0, 0, "stab"}
X};
X
X#undef P
X#undef D
X#undef F
X#undef W
X#undef C
X#undef S
X#undef P2
X#undef D2
X#undef F2
X#undef W2
X#undef C2
X#undef S2
X
Xint reverse_sort_list[NUMSPELLS] = {
X    SP__LIGHTNING_BOLT2, SP__DISEASE, SP__TIME_STOP, SP__ICE_STORM, SP__RAISE_DEAD,
X    SP__HASTE, SP__FIRE_STORM, SP__LIGHTNING_BOLT, SP__CHARM_MONSTER, SP__FIREBALL,
X    SP__BLINDNESS, SP__CAUSE_HEAVY_WOUNDS, SP__MISSILE, SP__FINGER_OF_DEATH,
X    SP__POISON, SP__FEAR, SP__CHARM_PERSON, SP__PARALYSIS, SP__ANTI_SPELL,
X    SP__CONFUSION, SP__SHIELD, SP__SURRENDER, SP__RESIST_COLD, SP__CAUSE_LIGHT_WOUNDS,
X    SP__RESIST_HEAT, SP__AMNESIA, SP__COUNTER_SPELL, SP__DELAYED_EFFECT,
X    SP__REMOVE_ENCHANTMENT, SP__PROTECTION_FROM_EVIL, SP__INVISIBILITY,
X    SP__COUNTER_SPELL2, SP__SUMMON_ELEMENTAL, SP__MAGIC_MIRROR, SP__PERMANENCY,
X    SP__CURE_LIGHT_WOUNDS, SP__SUMMON_GOBLIN, SP__SUMMON_OGRE, SP__SUMMON_TROLL,
X    SP__SUMMON_GIANT, SP__DISPEL_MAGIC, SP__CURE_HEAVY_WOUNDS, SP__STAB
X};
Xint alphabet_sort_list[NUMSPELLS] = {
X    SP__AMNESIA, SP__ANTI_SPELL, SP__BLINDNESS, SP__CAUSE_HEAVY_WOUNDS,
X    SP__CAUSE_LIGHT_WOUNDS, SP__CHARM_MONSTER, SP__CHARM_PERSON, SP__CONFUSION,
X    SP__COUNTER_SPELL, SP__COUNTER_SPELL2, SP__CURE_HEAVY_WOUNDS,
X    SP__CURE_LIGHT_WOUNDS, SP__DELAYED_EFFECT, SP__DISEASE, SP__DISPEL_MAGIC,
X    SP__FEAR, SP__FINGER_OF_DEATH, SP__FIRE_STORM, SP__FIREBALL, SP__HASTE,
X    SP__ICE_STORM, SP__INVISIBILITY, SP__LIGHTNING_BOLT, SP__LIGHTNING_BOLT2,
X    SP__MAGIC_MIRROR, SP__MISSILE, SP__PARALYSIS, SP__PERMANENCY, SP__POISON,
X    SP__PROTECTION_FROM_EVIL, SP__RAISE_DEAD, SP__REMOVE_ENCHANTMENT,
X    SP__RESIST_COLD, SP__RESIST_HEAT, SP__SHIELD, SP__SUMMON_ELEMENTAL,
X    SP__SUMMON_GIANT, SP__SUMMON_GOBLIN, SP__SUMMON_OGRE, SP__SUMMON_TROLL,
X    SP__SURRENDER, SP__TIME_STOP, SP__STAB
X};
X
Xstatic int check_one_spell(numgests, glist, mainhand, spel)
Xint numgests;
Xstruct wizgesture *glist;
Xint mainhand;
Xstruct spelldef *spel;
X{
X    int otherhand = (1-mainhand);
X    int jx, result, pos;
X
X    for (jx=spel->length-1; jx>=0; jx--) {
X	pos = numgests - (spel->length - jx);
X	if (pos<0) {
X	    /* fell off beginning of gesture list */
X	    return 0; 
X	}
X	if (spel->gests[jx] & Gesture_DOUBLE) {
X	    result = spel->gests[jx] & (~Gesture_DOUBLE);
X	    if (!(glist[pos].did[mainhand] == result
X		  && glist[pos].did[otherhand] == result)) {
X		/* failed to do two-handed gesture */
X		return 0; 
X	    }
X	}
X	else {
X	    if (!(glist[pos].did[mainhand] == spel->gests[jx])) {
X		/* failed to do one-handed gesture */
X		 return 0; 
X	    }
X	}
X    }
X
X    return 1;
X}
X
X/* writes results into found[] (OR of MASK_LEFT and MASK_RIGHT, or else MASK_BOTH) */
Xvoid find_castspells(found, numgests, glist)
Xint *found; /* pointer to array[NUMSPELLS] */
Xint numgests;
Xstruct wizgesture *glist;
X{
X    int ix, result;
X    struct spelldef *spel;
X
X    for (ix=0; ix<NUMSPELLS; ix++) {
X	spel = &(spelllist[ix]);
X	result = 0;
X	if (check_one_spell(numgests, glist, 0, spel))
X	    result |= MASK_LEFT;
X	if (check_one_spell(numgests, glist, 1, spel))
X	    result |= MASK_RIGHT;
X	if (result && (spel->gests[spel->length-1] & Gesture_DOUBLE)) {
X	    /* spell was completed with a double-handed gesture */
X	    result = MASK_TWOHAND;
X	}
X	found[ix] = result;
X    }
X}
END_OF_FILE
if test 5841 -ne `wc -c <'espells.c'`; then
    echo shar: \"'espells.c'\" unpacked with wrong size!
fi
# end of 'espells.c'
fi
if test -f 'handwave.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'handwave.h'\"
else
echo shar: Extracting \"'handwave.h'\" \(4432 characters\)
sed "s/^X//" >'handwave.h' <<'END_OF_FILE'
X/* header file for client */
X
Xtypedef void game;
X
X#define Turn_NORMAL	(0)
X#define Turn_HASTE	(1)
X#define Turn_TIMESTOP	(2)
X
X#define Gesture_NOTHING		(0)
X#define Gesture_PALM		(1)
X#define Gesture_DIGIT		(2)
X#define Gesture_FINGERS		(3)
X#define Gesture_WAVE		(4)
X#define Gesture_CLAPHALF	(5)
X#define Gesture_SNAP		(6)
X#define Gesture_KNIFE		(7)
X
X#define Gesture_ANTISPELL	(8) /* not less than NUMGESTURES, because. */
X#define Gesture_UNCLEAR		(9) /* not less than NUMGESTURES, because. */
X
X#define NUMGESTURES		(8)
X#define Gesture_DOUBLE		(16)
X
X#define MAXPLAYERS		(8)
X
X#define Gender_NONE		(0)
X#define Gender_MALE		(1)
X#define Gender_FEMALE		(2)
X#define Gender_NEUTER		(3)
X
X#define Stuff_RESIST_HEAT	(1<<0)
X#define Stuff_RESIST_COLD	(1<<1)
X#define Stuff_PROTECT_EVIL	(1<<2)
X#define Stuff_POISON		(1<<3)
X#define Stuff_DISEASE		(1<<4)
X#define Stuff_INVISIBLE		(1<<5)
X#define Stuff_BLIND		(1<<6)
X
X#define Qu_NoQuery	(0)
X/* placeholder; to be ignored by client */
X#define Qu_LeftHand	(1)
X#define Qu_RightHand	(2)
X/* rock is an array of int. rock[0] is the list length; rock[1..len] is a spell number,
X   ORed with QuVal_Hand_Both if the spell requires both hands. Answer is an index 
X   into rock (0..len-1) */
X#define Qu_SetOffDelay	(3)
X/* rock is the spell number */
X
X#define Qu_ElementalType (4)
X/* no rock */
X
X#define Qu_ParalysisHand (5)
X#define Qu_CharmHand (6)
X/* rock is index number of target wizard */
X
X#define Qu_CharmGesture (7)
X/* rock is index number of target wizard. Answer is Gesture_*. */
X
X#define Qu_MonsterTarget (8)
X/* rock is (0 if monster gets one attack, 1 or 2 if it gets two) * 256 + monster index.
X   Answer is a wizard/creature number, ORed with QuVal_Target_*. (Or 0 for none). */
X
X#define Qu_WhichToDelay (9)
X#define Qu_WhichToPerm (10)
X/* rock is a pointer to an int array of spell numbers, terminated by -1. */
X
X/* for qtypes higher than this, it's a target picker. rock is the spell number,
X   ORed with QuVal_Hand_*. Answer is a wizard/creature/corpse number, ORed with
X   QuVal_Target_*. (Or 0 for none) */
X
X#define Qu_TargetBeing		(20)
X#define Qu_TargetBeingNone	(21)
X#define Qu_TargetWizard		(22)
X#define Qu_TargetWizardNone	(23)
X#define Qu_TargetRaiseDead	(24)
X
X
X#define QuVal_Hand_Left		(256)
X#define QuVal_Hand_Right	(512)
X#define QuVal_Hand_Both		(1024)
X#define QuVal_Hand_MASK		(QuVal_Hand_Left | QuVal_Hand_Right | QuVal_Hand_Both)
X
X#define QuVal_Target_Wizard	(256)
X#define QuVal_Target_Creature	(512)
X#define QuVal_Target_Corpse	(1024)
X#define QuVal_Target_MASK	(QuVal_Target_Wizard | QuVal_Target_Creature | QuVal_Target_Corpse)
X
X
Xstruct query {
X    int player;
X    int qtype;
X    char *rock;
X    int answer; /* to be filled in */
X};
X
Xstruct interface {
X    /* in the printing calls, any char * may be NULL */
X    void (*proc_PrintMsg)( /* char *msg, game *game, rock */ );
X    void (*proc_PrintMsg2)( /* int person1, char *msg1, char *msgelse, game *game, rock */ );  
X    void (*proc_PrintMsg3)( /* int person1, int person2, char *msg1, char *msg2,
X		char *msgelse, game *game, rock */ );
X    void (*proc_Queries)( /* int numqueries, struct query *qlist, game *game, rock */ ); 
X};
X
Xextern game *BeginGame( /* int numplayers, char **names, int *genders, struct interface *callbacks, rock */ );
X/* names is a pointer to an array of name strings. */
X
Xextern int RunTurn( /* game *game, int *moves */ );
X/* moves contains two ints for each player (left, right). The encoding is with Gesture_*. */
X
Xextern void SeeGesture( /* game *game, int player, int asker, int *buf, int size */ );
X
Xextern void FreeGame( /* game *game */ );
X
Xextern int TurnType( /* game *game */ );
Xextern int TurnPlayerActive( /* game *game, int player */ );
X
Xextern int NumberOfTargets( /* game *game, int targettype */);
Xextern char *NameOfTarget( /* game *game, int targettype, int targetnum */);
Xextern int StuffAboutTarget( /* game *game, int targettype, int targetnum */);
X/* targettype is QuVal_Target_* */
X
Xextern int NumberOfBeings( /* game *game, int targettype */);
Xextern int HitPointsOfBeing( /* game *game, int targettype, int indexnum */);
Xextern int StuffAboutBeing( /* game *game, int targettype, int indexnum */);
Xextern int OwnerOfCreature( /* game *game, int indexnum */);
Xextern char *NameOfBeing( /* game *game, int targettype, int indexnum */);
X/* targettype is QuVal_Target_* */
X
Xextern void LogInTranscript( /* game *game, char *str */);
Xextern void WriteTranscript( /* game *game, FILE *f */);
END_OF_FILE
if test 4432 -ne `wc -c <'handwave.h'`; then
    echo shar: \"'handwave.h'\" unpacked with wrong size!
fi
# end of 'handwave.h'
fi
if test -f 'internal.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'internal.h'\"
else
echo shar: Extracting \"'internal.h'\" \(4288 characters\)
sed "s/^X//" >'internal.h' <<'END_OF_FILE'
X#include "spelllist.h"
X
X#define PrintMsg(msg)   (log_text(self, msg),\
X			self->callbacks.proc_PrintMsg)((msg), self,\
X			(self->rock))
X#define PrintMsg2(person, msg1, msgelse)   (log_text(self, msgelse),\
X			self->callbacks.proc_PrintMsg2)((person), (msg1),\
X			(msgelse), self, (self->rock))
X#define PrintMsg3(person1, person2, msg1, msg2, msgelse)   (log_text(self, msgelse),\
X			self->callbacks.proc_PrintMsg3)((person1), (person2),\
X			(msg1), (msg2), (msgelse), self, (self->rock))
X#define Queries(numqueries, querylist)   (setup_targetlist(self),\
X			(self->callbacks.proc_Queries)((numqueries),\
X			(querylist), self, (self->rock)))
X
X#define MAXSPELLCHOICES (16)	/* max number of spells that could possibly be
X				invoked with one gesture */
X
Xstruct target {
X    char *name;
X    int index;
X    long stuff;
X};
X
Xstruct realgame {
X    struct interface callbacks;
X    char *rock;
X    int numplayers;
X    int turn;
X    int turntype;
X    int turnactive[MAXPLAYERS];
X
X    char *gamelog;
X    int gamelog_pos;
X    int gamelog_size;
X
X    struct wizard *wiz[MAXPLAYERS];
X    struct creature *cre;
X    int numcres, cre_size;
X
X    struct query *querylist;
X    int querylist_size;
X    int numqueries;
X
X    int numtargets[3];
X    struct target *targetlist[3];
X    int targetlist_size[3];
X
X    struct castspell *castlist, *hastelist;
X
X    /* per-round data */
X    int fl_icestorm, fl_firestorm, fl_dispelmagic;
X    int blind_array;
X};
X
Xstruct wizgesture {
X    int did[2];
X    int invisible; /* was invisible for this move? */
X    int blind; /* bit-array -- who was blind this move? */
X    int turnnum, log_hp;
X};
X
Xstruct permstats {
X    int mind_spell, mind_detail;
X    int fl_haste;
X    int fl_prot_evil;
X    int fl_resist_heat;
X    int fl_resist_cold;
X    int fl_blindness;
X    int fl_invisibility;
X};
X
Xstruct wizard {
X    int alive;
X    int hitpoints, max_hitpoints;
X    int resistant_heat, resistant_cold, prot_from_evil, haste, timestop;
X    int invisibility, blindness;
X    int poison_time, disease_time;
X    int mind_spell, mind_caster;
X    struct permstats perm;
X    char *name;
X    int gender;
X    /* per-round */
X    int zaplist[NUMSPELLS];
X    int enchant_caster, raisedead_caster, enchant_ppend;
X    int fl_resist_heat, fl_resist_cold;
X    int fl_resist_icestorm; /* due to fireball hits */
X
X    int numgests;
X    int gests_size;
X    struct wizgesture *gests;
X    int surrendered;
X    int fl_cast_lightning;
X    int hand_paralyzed;
X    int perm_time, delay_time;
X    int delay_bank;
X
X    int foundlist[NUMSPELLS];
X    int llist[MAXSPELLCHOICES], rlist[MAXSPELLCHOICES];
X};
X
Xstruct creature {
X    int alive;
X    int hitpoints, max_hitpoints;
X    int resistant_heat, resistant_cold, prot_from_evil, haste, timestop;
X    int invisibility, blindness;
X    int poison_time, disease_time;
X    int mind_spell, mind_caster;
X    struct permstats perm;
X    char *name;
X    int gender;
X    /* per-round */
X    int zaplist[NUMSPELLS];
X    int enchant_caster, raisedead_caster, enchant_ppend;
X    int fl_resist_heat, fl_resist_cold;
X    int fl_resist_icestorm; /* due to fireball hits */
X
X    int type;
X    int nocorpse;
X    int owner;
X    int last_target, last_targettype;
X    int nowm_spell, nowm_caster;
X};
X
Xunion being {
X    struct {
X	int alive;
X	int hitpoints, max_hitpoints;
X	int resistant_heat, resistant_cold, prot_from_evil, haste, timestop;
X	int invisibility, blindness;
X	int poison_time, disease_time;
X	int mind_spell, mind_caster;
X	struct permstats perm;
X	char *name;
X	int gender;
X	/* per-round */
X	int zaplist[NUMSPELLS];
X	int enchant_caster, raisedead_caster, enchant_ppend;
X	int fl_resist_heat, fl_resist_cold;
X	int fl_resist_icestorm; /* due to fireball hits */
X    } both;
X
X    struct wizard wiz;
X    struct creature cre;
X};
X
X
X#define MASK_LEFT (1)
X#define MASK_RIGHT (2)
X#define MASK_TWOHAND (4)
X
Xstruct castspell {
X    int caster;
X    int handage;
X    int spellnum;
X    int target;
X    int targettype; /* QuVal_Target_*, or 0 for nobody, or (-1) for no target required */
X    int permanent;
X    int rock;
X
X    struct castspell *next;
X};
X
X#define Creature_GOBLIN (1)
X#define Creature_OGRE   (2)
X#define Creature_TROLL  (3)
X#define Creature_GIANT  (4)
X#define Creature_ICEL   (5)
X#define Creature_FIREL  (6)
X
Xextern void setup_targetlist(); /* needed if Queries() is to be used */
END_OF_FILE
if test 4288 -ne `wc -c <'internal.h'`; then
    echo shar: \"'internal.h'\" unpacked with wrong size!
fi
# end of 'internal.h'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(11365 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/* This program is copyright 1993 by Andrew Plotkin.
X The source code may be freely copied, distributed,
X and modified, as long as this copyright notice is
X retained.
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X
X#include "handwave.h"
X#include "spelllist.h"
X#include "patchlevel.h"
X
X#include "xspell.h"
X
Xint win_wid, win_hgt;
X
Xstruct player *players;
Xint numplayers;
Xint turnstate;
X
Xgame *gameval = NULL;
X
Xstatic int defaultnum = 0;
Xstatic char *defaultnamelist[10] = {"White", "Black", "Red", "Green", "Blue",
X		"Yellow", "Orange", "Purple", "Grey", "Charteuse"};
Xstatic char *namelist[MAXPLAYERS] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
Xstatic char *displist[MAXPLAYERS] = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
Xstatic int genderlist[MAXPLAYERS] = {Gender_MALE, Gender_MALE, Gender_MALE,
X		Gender_MALE, Gender_MALE, Gender_MALE, Gender_MALE, Gender_MALE};
X
Xstatic struct query savequery = {
X    0,
X    Qu_SaveTranscript,
X    NULL,
X    0
X};
X
Xstatic void PrintMsg(), PrintMsg2(), PrintMsg3();
Xextern void redraw();
Xextern void XQueries();
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X    struct interface procs;
X    struct maingame ignorerock;
X    static char inbuf[256];
X    int whowon;
X    int ix, val;
X    struct player *py;
X    int movelist[MAXPLAYERS*2];
X
X    procs.proc_PrintMsg = PrintMsg;
X    procs.proc_PrintMsg2 = PrintMsg2;
X    procs.proc_PrintMsg3 = PrintMsg3;
X    procs.proc_Queries = XQueries;
X
X    if (argc==1) {
X	printf("usage: spellcast RemoteDisplay [ RemoteDisplay2 ... ]\n");
X	exit(12);
X    }
X
X    numplayers = 1;
X    displist[0] = NULL;
X    for (ix=1; ix<argc; ix++) {
X	if (strlen(argv[ix])!=0) {
X	    if (index(argv[ix], ':'))
X		displist[numplayers] = argv[ix];
X	    else {
X		displist[numplayers] = (char *)malloc(strlen(argv[ix])+6);
X		strcpy(displist[numplayers], argv[ix]);
X		strcat(displist[numplayers], ":0.0");
X	    }
X	}
X	else
X	    displist[numplayers] = NULL;
X	/* allow an empty argument to signify NULL display */
X	numplayers++;
X    }
X
X    if (numplayers < 2) {
X	printf("You have listed only %d players!\n", numplayers);
X	exit(12);
X    }
X    if (numplayers > MAXPLAYERS) {
X	printf("There is a maximum of %d players!\n", MAXPLAYERS);
X	exit(12);
X    }
X
X    players = (struct player *)malloc(sizeof(struct player) * numplayers);
X
X    win_wid = 832;
X    if (numplayers > 3)
X	win_wid += (numplayers-3) * (2*GEST_SIZE + 20);
X    win_hgt = 750;
X    turnstate = State_Init;
X
X    for (ix=0; ix<numplayers; ix++) {
X	val = win_init(ix);
X	if (!val) {
X	    fprintf(stderr, "spellcast: exiting.\n");
X	    exit(-1);
X	}
X    }
X
X    gameval = BeginGame(numplayers, namelist, genderlist, &procs, &ignorerock);
X
X    do {
X	val = TurnType(gameval);
X	turnstate = State_Top;
X	for (ix=0; ix<numplayers; ix++) {
X	    py = &(players[ix]);
X	    py->turn_active = TurnPlayerActive(gameval, ix); 
X	    py->turn_done = !py->turn_active;
X	}
X	for (ix=0; ix<numplayers; ix++) {
X	    py = &(players[ix]);
X	    py->gesture_chosen[0] = Gesture_NOTHING;
X	    py->gesture_chosen[1] = Gesture_NOTHING;
X	    clear_answers(py);
X	    if (py->turn_active)
X		switch (val) {
X		    case Turn_HASTE:
X			add_answer(py, "Enter your gestures for your Hastened move.",
X					"", 1, 0, NULL, 0);
X			break;
X		    case Turn_TIMESTOP:
X			add_answer(py, "Enter your gestures for your Time-Stopped move.",
X					"", 1, 0, NULL, 0);
X			break;
X		    default:
X			add_answer(py,
X"Enter your gestures for this move, at the bottom of your gesture list.",
X					"", 1, 0, NULL, 0);
X			break;
X		}
X	    else
X		switch (val) {
X		    case Turn_HASTE:
X			add_answer(py, "Other people are Hastened this turn.",
X					"", 1, 0, NULL, 0);
X			break;
X		    case Turn_TIMESTOP:
X			add_answer(py, "You are frozen in time.", "", 1, 0, NULL, 0);
X			break;
X		    default:
X			add_answer(py, "You are out of the game.", "", 1, 0, NULL, 0);
X			break;
X		}
X	    redraw_column(py);
X	    draw_button(py, 0, 1); /* redraw turn-end button */
X	    redraw_queries_only(py, 0);
X	    /*update_statlist(py);*/
X	}
X	mainloop();
X
X	for (ix=0; ix<numplayers; ix++) {
X	    struct player *py = &(players[ix]);
X	    movelist[ix*2+0] = py->gesture_chosen[0];
X	    movelist[ix*2+1] = py->gesture_chosen[1];
X	}
X	whowon = RunTurn(gameval, movelist);
X    } while (whowon < 0);
X
X    if (whowon==MAXPLAYERS)
X	sprintf(inbuf, "\n+++ The game is a draw +++\n");
X    else
X	sprintf(inbuf, "\n+++ %s has won +++\n", NameOfBeing(gameval,
X			QuVal_Target_Wizard, whowon));
X    PrintMsg(inbuf, gameval, &ignorerock);
X    LogInTranscript(gameval, inbuf);
X    LogInTranscript(gameval, "\n");
X
X    turnstate = State_End;
X    for (ix=0; ix<numplayers; ix++) {
X	py = &(players[ix]);
X	py->turn_active = 1;
X	py->turn_done = 0;
X    }
X    for (ix=0; ix<numplayers; ix++) {
X	py = &(players[ix]);
X	clear_answers(py);
X	if (ix==0)
X	    add_answer(py, "Do you want to save a transcript of this game?",
X			"No", 1, 0, &savequery, 0);
X	redraw_column(py);
X	draw_button(py, 0, 1); /* redraw turn-end button */
X	redraw_queries_only(py, 0);
X	/*update_statlist(py);*/
X    }
X    mainloop();
X
X    savequery.answer = players[0].answers[0].answer;
X    if (savequery.answer) {
X	char fname[512];
X	FILE *fl;
X
X	sprintf(fname, "%s/spellcast-%d", TRANSCRIPTDIR, getpid());
X	fl = fopen(fname, "w");
X	if (!fl) {
X	    printf("spellcast: unable to open %s for writing\n", fname);
X	    perror("spellcast: error");
X	}
X	else {
X	    WriteTranscript((game *)gameval, fl);
X	    fclose(fl);
X	    printf("Saved transcript in %s.\n", fname);
X	}
X    }
X    FreeGame(gameval);
X
X}
X
Xint win_init(pnum)
Xint pnum;
X{
X    XSetWindowAttributes attr;
X    XGCValues gcvalues;
X    char winname[256];
X    char *fontname;
X    char *name, *tmp;
X    int ix, val;
X
X    struct player *py = &(players[pnum]);
X
X    py->dpy = XOpenDisplay(displist[pnum]);
X    if (!py->dpy) {
X	fprintf(stderr, "spellcast: could not open display for player %d.\n", pnum);
X	return 0;
X    }
X
X    py->scn = DefaultScreen(py->dpy);
X    py->win = XCreateSimpleWindow(py->dpy, DefaultRootWindow(py->dpy), 100, 100,
X		win_wid, win_hgt, 1, BlackPixel(py->dpy, py->scn),
X		WhitePixel(py->dpy, py->scn));
X    py->backpm = XCreatePixmap(py->dpy, py->win, win_wid, win_hgt,
X		DefaultDepth(py->dpy, py->scn));
X    py->backstore = 0;
X
X    { /* make some window managers happy */
X	XWMHints wmhints;
X	wmhints.flags = InputHint;
X	wmhints.input = True;
X	XSetWMHints(py->dpy, py->win, &wmhints);
X    }
X
X    attr.event_mask = EVENTMASK;
X    XChangeWindowAttributes(py->dpy, py->win, CWEventMask, &attr);
X
X    tmp = XGetDefault(py->dpy, "spellcast", "name");
X    if (tmp) {
X	name = (char *)malloc(strlen(tmp)+1);
X	strcpy(name, tmp);
X	tmp = index(name, ':');
X	if (!tmp)
X	    genderlist[pnum] = Gender_MALE;
X	else {
X	    switch (*(tmp+1)) {
X		case 'f':
X		case 'F':
X		    genderlist[pnum] = Gender_FEMALE;
X		    break;
X		case 'n':
X		case 'N':
X		    genderlist[pnum] = Gender_NEUTER;
X		    break;
X		case 'x':
X		case 'X':
X		    genderlist[pnum] = Gender_NONE;
X		    break;
X		case 'm':
X		case 'M':
X		default:
X		    genderlist[pnum] = Gender_MALE;
X		    break;
X	    }
X	    *tmp = '\0';
X	}
X	tmp = name+strlen(name)-1;
X	while (tmp>name && (*tmp==' ' || *tmp=='\t'))
X	    tmp--;
X	*(tmp+1) = '\0';
X	namelist[pnum] = name;
X    }
X    else {
X	namelist[pnum] = defaultnamelist[defaultnum];
X	defaultnum++;
X    }
X
X    do {
X	val = 0;
X	if (strlen(namelist[pnum])<1)
X	    val = 1;
X	if (!strcmp(namelist[pnum], "nobody"))
X	    val = 1;
X	if (!strcmp(namelist[pnum], "Nobody"))
X	    val = 1;
X	for (ix=0; ix<pnum; ix++)
X	    if (!strcmp(namelist[pnum], namelist[ix]))
X		val = 1;
X
X	if (val) {
X	    tmp = namelist[pnum];
X	    namelist[pnum] = defaultnamelist[defaultnum];
X	    defaultnum++;
X
X	    fprintf(stderr,
X"spellcast: the name '%s' for player %d is taken. Switching to '%s'...\n",
X			tmp, pnum, namelist[pnum]);
X	}
X    } while (val);
X
X    sprintf(winname, "Spellcast: %s", namelist[pnum]);
X    XStoreName(py->dpy, py->win, winname);
X
X    XMapWindow(py->dpy, py->win);
X
X    fontname = XGetDefault(py->dpy, "spellcast", "font");
X    if (!fontname)
X	fontname = BODYFONT;
X    py->font = XLoadQueryFont(py->dpy, fontname);
X
X    if (!py->font) {
X	fprintf(stderr,
X"spellcast: could not find font %s for player %d. Switching to %s...\n",
X			fontname, pnum, BODYFONT_ALT);
X	py->font = XLoadQueryFont(py->dpy, BODYFONT_ALT);
X	if (!py->font) {
X	    fprintf(stderr,
X"spellcast: could not find font %s for player %d. Switching to %s...\n",
X			BODYFONT_ALT, pnum, BODYFONT_ALT2);
X	    py->font = XLoadQueryFont(py->dpy, BODYFONT_ALT2);
X	    if (!py->font) {
X		fprintf(stderr, "spellcast: could not find font %s for player %d.\n",
X				BODYFONT_ALT2, pnum);
X
X		return 0;
X	    }
X
X	}
X    }
X
X    gcvalues.font = py->font->fid;
X    gcvalues.foreground = BlackPixel(py->dpy, py->scn);
X    gcvalues.background = WhitePixel(py->dpy, py->scn);
X    py->blackgc = XCreateGC(py->dpy, py->win, GCForeground|GCBackground|GCFont,
X		&gcvalues);
X    XSetGraphicsExposures(py->dpy, py->blackgc, 0);
X
X    gcvalues.foreground = WhitePixel(py->dpy, py->scn);
X    gcvalues.background = BlackPixel(py->dpy, py->scn);
X    py->whitegc = XCreateGC(py->dpy, py->win, GCForeground|GCBackground|GCFont,
X		&gcvalues);
X    XSetGraphicsExposures(py->dpy, py->whitegc, 0);
X
X    init_bitmaps(py);
X    init_xtext(pnum);
X    init_query(py);
X    init_stats(py);
X    init_talk(py);
X    py->button_lit = (-1);
X    redraw(py);
X
X    return 1;
X}
X
X#define POPUP_ELBOW (8)
X
Xvoid adjust_rect(mrec)
Xstruct rect *mrec;
X{
X    if (mrec->x+mrec->w >= win_wid-POPUP_ELBOW)
X	mrec->x = win_wid-POPUP_ELBOW - mrec->w;
X    if (mrec->y+mrec->h >= win_hgt-POPUP_ELBOW)
X	mrec->y = win_hgt-POPUP_ELBOW - mrec->h;
X    if (mrec->x < POPUP_ELBOW)
X	mrec->x = POPUP_ELBOW;
X    if (mrec->y < POPUP_ELBOW)
X	mrec->y = POPUP_ELBOW;
X}
X
Xvoid backing_store(py, mrec)
Xstruct player *py;
Xstruct rect *mrec;
X{
X    py->backrec = (*mrec);
X    if (py->backstore) {
X	printf("ERROR: backing store already on\n");
X    }
X    py->backstore = 1;
X    py->gotexpose = 0;
X    XCopyArea(py->dpy, py->win, py->backpm, py->blackgc, mrec->x, mrec->y,
X		mrec->w, mrec->h, 0, 0);
X}
X
Xvoid backing_restore(py)
Xstruct player *py;
X{
X    if (!py->backstore) {
X	printf("ERROR: backing store already off\n");
X    }
X    py->backstore = 0;
X    if (py->gotexpose) {
X	XClearArea(py->dpy, py->win, py->backrec.x, py->backrec.y,
X			py->backrec.w, py->backrec.h, 0);
X	redraw(py);
X    }
X    else {
X	XCopyArea(py->dpy, py->backpm, py->win, py->blackgc, 0, 0,
X			py->backrec.w, py->backrec.h, py->backrec.x, py->backrec.y);
X    }
X}
X
Xstatic void PrintMsg(msg, gameval, rock)
Xchar *msg;
Xgame *gameval;
Xstruct maingame *rock;
X{
X    int ix;
X    if (msg) {
X	for (ix=0; ix<numplayers; ix++)
X	    dump_text(ix, msg);
X    }
X}
X
Xstatic void PrintMsg2(person1, msg1, msgelse, gameval, rock)
Xint person1;
Xchar *msg1, *msgelse;
Xgame *gameval;
Xstruct maingame *rock;
X{
X    int ix;
X
X    for (ix=0; ix<numplayers; ix++) {
X	if (ix==person1) {
X	    if (msg1)
X		dump_text(ix, msg1);
X	}
X	else {
X	    if (msgelse)
X		dump_text(ix, msgelse);
X	}
X    }
X}
X
Xstatic void PrintMsg3(person1, person2, msg1, msg2, msgelse, gameval, rock)
Xint person1, person2;
Xchar *msg1, *msg2, *msgelse;
Xgame *gameval;
Xstruct maingame *rock;
X{
X    int ix;
X
X    for (ix=0; ix<numplayers; ix++) {
X	if (ix==person1) {
X	    if (msg1)
X		dump_text(ix, msg1);
X	}
X	else if (ix==person2) {
X	    if (msg2)
X		dump_text(ix, msg2);
X	}
X	else {
X	    if (msgelse)
X		dump_text(ix, msgelse);
X	}
X    }
X}
X
END_OF_FILE
if test 11365 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(23 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X#define PATCHLEVEL "0"
END_OF_FILE
if test 23 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
if test -f 'xbutton.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xbutton.c'\"
else
echo shar: Extracting \"'xbutton.c'\" \(7415 characters\)
sed "s/^X//" >'xbutton.c' <<'END_OF_FILE'
X#include <string.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include "handwave.h"
X#include "spelllist.h"
X#include "xspell.h"
X
X#define BBOX_X (32)
X#define BBOX_Y (576)
X#define BBOX_W (2)
X#define BBOX_H (1)
X
X#define BUTTON_W (150)
X#define BUTTON_H (32)
X#define BUTTON_CORNER (3)
X#define BUTTON_SPACE (4)
X
Xvoid draw_button();
X
Xvoid DrawStringCentered(py, str, xpos, ypos)
Xstruct player *py;
Xchar *str;
Xint xpos, ypos;
X{
X    static XCharStruct overall;
X    int direction, ascent, descent;
X    int len = strlen(str);
X
X    XTextExtents(py->font, str, len, &direction, &ascent, &descent, &overall);
X    XDrawImageString(py->dpy, py->win, py->blackgc, xpos-(overall.width)/2, ypos, str, len);
X
X}
X
X/* list NUMSPELLS-1 spells (skip SP__STAB) */
Xvoid draw_spelllist(py)
Xstruct player *py;
X{
X    int ix, jx, snum, gx, val, pos;
X    int tablehgt;
X    struct spelldef *spel;
X    char *cx;
X
X#define SL_COLUMNS (2)
X    int posx = py->spelllist_rect.x+16;
X    int posy = py->spelllist_rect.y+32;
X
X    draw_frame(py, &py->spelllist_rect);
X
X    if (py->spelllist_way==1)
X	cx = "Spell List (left button: sorted by gesture)";
X    else if (py->spelllist_way==2)
X	cx = "Spell List (middle button: alphabetical sort)";
X    else
X	cx = "Spell List (right button: reversed sort by gesture)";
X
X    DrawStringCentered(py, cx, py->spelllist_rect.x+py->spelllist_rect.w/2,
X		py->spelllist_rect.y+4+py->lineheight);
X
X    tablehgt = (NUMSPELLS-1+SL_COLUMNS-1) / SL_COLUMNS;
X    for (ix=0; ix<SL_COLUMNS; ix++)
X	for (jx=0; jx<tablehgt; jx++) {
X	    if (py->spelllist_way==1)
X		snum = ix*tablehgt+jx;
X	    else if (py->spelllist_way==2)
X		snum = alphabet_sort_list[ix*tablehgt+jx];
X	    else
X		snum = reverse_sort_list[ix*tablehgt+jx];
X	    if (snum >= NUMSPELLS-1)
X		break;
X	    spel = &(spelllist[snum]);
X	    for (gx=0; gx<spel->length; gx++) {
X		val = spel->gests[gx];
X		pos = ((py->spelllist_way==3) ? (gx+(8-spel->length))*(GEST_SMALL+1)-8 :
X				gx*(GEST_SMALL+1));
X				/*spel->length-gx-1 for reversed gestures*/
X		XCopyPlane(py->dpy, py->spelllistbm [(val&Gesture_DOUBLE)?1:0]
X				[(val&(~Gesture_DOUBLE))-1], py->win, py->blackgc,
X				0, 0, GEST_SMALL, GEST_SMALL, posx+ix*300+pos,
X				posy+jx*18, 1);
X	    }
X	    if (py->spelllist_way!=3) 
X		for (gx = spel->length; gx<8; gx++) {
X		    pos = gx*(GEST_SMALL+1);
X		    XCopyPlane(py->dpy, py->spelllistbm[0][6], py->win, py->blackgc,
X				0, 0, GEST_SMALL, GEST_SMALL, posx+ix*300+pos,
X				posy+jx*18, 1);
X		}
X	    XDrawImageString(py->dpy, py->win, py->blackgc, posx+ix*300+8*(GEST_SMALL+1),
X			posy+jx*18+((GEST_SMALL+py->lineheight)/2)-2, spel->name,
X			strlen(spel->name));
X	}
X}
X
Xstatic void light_button(py, bnum)
Xstruct player *py;
Xint bnum;
X{
X    int hitx, hity;
X
X    if (py->button_lit != (-1)) {
X	hitx = py->button_lit % BBOX_W;
X	hity = py->button_lit / BBOX_W;
X	XDrawRectangle(py->dpy, py->win, py->whitegc, BBOX_X+hitx*BUTTON_W-1,
X			BBOX_Y+hity*BUTTON_H-1, BUTTON_W-BUTTON_SPACE+2,
X			BUTTON_H-BUTTON_SPACE+2);
X    }
X
X    py->button_lit = bnum;
X    if (py->button_lit != (-1)) {
X	hitx = py->button_lit % BBOX_W;
X	hity = py->button_lit / BBOX_W;
X	XDrawRectangle(py->dpy, py->win, py->blackgc, BBOX_X+hitx*BUTTON_W-1,
X			BBOX_Y+hity*BUTTON_H-1, BUTTON_W-BUTTON_SPACE+2,
X			BUTTON_H-BUTTON_SPACE+2);
X    }
X}
X
Xvoid redraw_buttons(py)
Xstruct player *py;
X{
X    int bnum;
X
X    for (bnum=0; bnum<BBOX_W*BBOX_H; bnum++) {
X	draw_button(py, bnum, 0);
X    }
X    light_button(py, py->button_lit);
X}
X
Xvoid draw_button(py, bnum, mode)
Xstruct player *py;
Xint bnum;
Xint mode; /* 0 for all, 1 for clear interior and relabel */
X{
X    int ix, jx;
X    char *cx;
X
X    static XPoint plist[9] = {
X	{0+BUTTON_CORNER, 0},
X	{BUTTON_W-BUTTON_SPACE-2*BUTTON_CORNER, 0},
X	{BUTTON_CORNER, BUTTON_CORNER},
X	{0, BUTTON_H-BUTTON_SPACE-2*BUTTON_CORNER},
X	{-BUTTON_CORNER, BUTTON_CORNER},
X	{-(BUTTON_W-BUTTON_SPACE-2*BUTTON_CORNER), 0},
X	{-BUTTON_CORNER, -BUTTON_CORNER},
X	{0, -(BUTTON_H-BUTTON_SPACE-2*BUTTON_CORNER)},
X	{BUTTON_CORNER, -BUTTON_CORNER},
X    };
X
X    ix = bnum % BBOX_W;
X    jx = bnum / BBOX_W;
X
X    if (mode==0) {
X	plist[0].x = BBOX_X + ix*BUTTON_W + BUTTON_CORNER;
X	plist[0].y = BBOX_Y + jx*BUTTON_H;
X	XDrawLines(py->dpy, py->win, py->blackgc, plist, 9, CoordModePrevious);
X    }
X
X    if (mode==1) {
X	/* clear interior */
X	XClearArea(py->dpy, py->win, BBOX_X + ix*BUTTON_W + BUTTON_CORNER,
X			BBOX_Y + jx*BUTTON_H + BUTTON_CORNER,
X			BUTTON_W-BUTTON_SPACE-2*BUTTON_CORNER,
X			BUTTON_H-BUTTON_SPACE-2*BUTTON_CORNER, 0);
X    }
X
X    switch (bnum) {
X	case 0:
X	    if (!py->turn_active)
X		cx = "please wait....";
X	    else if (turnstate == State_Top) {
X		if (!py->turn_done)
X		    cx = "End Move";
X		else
X		    cx = "Move ENDED.";
X	    }
X	    else if (turnstate == State_End) {
X		if (!py->turn_done)
X		    cx = "Quit";
X		else
X		    cx = "Wait....";
X	    }
X	    else {
X		if (!py->turn_done)
X		    cx = "End Answers";
X		else
X		    cx = "Answers ENDED.";
X	    }
X	    DrawStringCentered(py, cx, BBOX_X+ix*BUTTON_W+BUTTON_W/2,
X			BBOX_Y+jx*BUTTON_H+py->lineheight+1);
X	    break;
X	case 1:
X	    DrawStringCentered(py, "Spell List", BBOX_X+ix*BUTTON_W+BUTTON_W/2,
X			BBOX_Y+jx*BUTTON_H+py->lineheight+1);
X	    break;
X	default:
X	    break;
X    }
X
X}
X
Xint in_bbox_box(py, xpos, ypos)
Xstruct player *py;
Xint xpos, ypos;
X{
X    return (xpos >= BBOX_X
X	    && xpos < BBOX_X + BBOX_W*BUTTON_W
X	    && ypos >= BBOX_Y
X	    && ypos < BBOX_Y + BBOX_H*BUTTON_H);
X}
X
Xint button_hit(py, xpos, ypos, button)
Xstruct player *py;
Xint xpos, ypos;
Xint button;
X{
X    int hitx, hity, bnum;
X    int ix;
X
X    hitx = (xpos-BBOX_X) / BUTTON_W;
X    hity = (ypos-BBOX_Y) / BUTTON_H;
X
X    if (hitx<0 || hity<0 || hitx>=BBOX_W || hity>=BBOX_H)
X	return ms_None;
X
X    bnum = hitx + hity*BBOX_W;
X
X    switch (bnum) {
X	case 0:
X	    if (!py->turn_active)
X		return ms_None;
X	    light_button(py, bnum);
X	    return ms_DoneBtn;
X	    break;
X	case 1:
X	    py->spelllist_rect.w = 620;
X	    py->spelllist_rect.h = 420;
X	    py->spelllist_rect.x = 10;
X	    py->spelllist_rect.y = 10;
X	    py->spelllist_way = button;
X	    backing_store(py, &py->spelllist_rect);
X	    draw_spelllist(py);
X	    return ms_SpellBtn;
X	    break;
X	default:
X	    printf("ERROR: unknown button thing!\n");
X	    break;
X    }
X}
X
Xint button_motion(py, xpos, ypos, button)
Xstruct player *py;
Xint xpos, ypos;
Xint button;
X{
X    int hitx, hity, bnum;
X
X    switch (py->mousestate) {
X	case ms_DoneBtn:
X	    hitx = (xpos-BBOX_X+BUTTON_W) / BUTTON_W - 1;
X	    hity = (ypos-BBOX_Y+BUTTON_H) / BUTTON_H - 1;
X	    if (hitx==0 && hity==0) {
X		if (py->button_lit!=0)
X		    light_button(py, 0);
X	    }
X	    else {
X		if (py->button_lit!=(-1))
X		    light_button(py, (-1));
X	    }
X	    break;
X	case ms_SpellBtn:
X	default:
X	    break;
X    }
X}
X
Xint button_release(py, xpos, ypos, button)
Xstruct player *py;
Xint xpos, ypos;
Xint button;
X{
X    int ix, isok;
X
X    switch (py->mousestate) {
X	case ms_DoneBtn:
X	    isok = 1;
X	    if (turnstate==State_EQueries || turnstate==State_Queries) {
X		for (ix=0; ix<py->siquery.nlines; ix++)
X		    if (!py->answers[ix].done) {
X			isok = 0;
X			strcpy(py->answers[ix].ans_str, "<answer?>");
X			/* ### set value to scroll to? */
X		    }
X	    }
X	    if (py->button_lit==0) {
X		if (isok) {
X		    py->turn_done = !(py->turn_done);
X		    redraw_done_markers(py);
X		}
X		else
X		    redraw_queries_only(py, 0);
X		light_button(py, (-1));
X	    }
X	    draw_button(py, 0, 1);
X	    break;
X	case ms_SpellBtn:
X	    backing_restore(py);
X	    break;
X	default:
X	    break;
X    }
X}
END_OF_FILE
if test 7415 -ne `wc -c <'xbutton.c'`; then
    echo shar: \"'xbutton.c'\" unpacked with wrong size!
fi
# end of 'xbutton.c'
fi
if test -f 'xgest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgest.c'\"
else
echo shar: Extracting \"'xgest.c'\" \(11180 characters\)
sed "s/^X//" >'xgest.c' <<'END_OF_FILE'
X#include <string.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include "handwave.h"
X#include "spelllist.h"
X#include "xspell.h"
X
X#include "ba.bm"
X#include "bc.bm"
X#include "bd.bm"
X#include "bf.bm"
X#include "bk.bm"
X#include "bn.bm"
X#include "bp.bm"
X#include "bs.bm"
X#include "bu.bm"
X#include "bw.bm"
X#include "bva.bm"
X#include "bvc.bm"
X#include "bvd.bm"
X#include "bvf.bm"
X#include "bvk.bm"
X#include "bvp.bm"
X#include "bvs.bm"
X#include "bvw.bm"
X
X#include "sc.bm"
X#include "sd.bm"
X#include "sd2.bm"
X#include "sf.bm"
X#include "sf2.bm"
X#include "sp.bm"
X#include "sp2.bm"
X#include "ss.bm"
X#include "ss2.bm"
X#include "sw.bm"
X#include "sw2.bm"
X#include "sdot.bm"
X
X#define COLUMN_SIZE (8)
X#define COLUMN_X (476)
X#define COLUMN_Y (33)
X#define GEST_SPACE (50)
X
Xvoid init_bitmaps(py)
Xstruct player *py;
X{
X    py->gesturebm[0][0] = XCreatePixmapFromBitmapData(py->dpy, py->win, bn_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[0][1] = XCreatePixmapFromBitmapData(py->dpy, py->win, bp_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[0][2] = XCreatePixmapFromBitmapData(py->dpy, py->win, bd_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[0][3] = XCreatePixmapFromBitmapData(py->dpy, py->win, bf_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[0][4] = XCreatePixmapFromBitmapData(py->dpy, py->win, bw_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[0][5] = XCreatePixmapFromBitmapData(py->dpy, py->win, bc_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[0][6] = XCreatePixmapFromBitmapData(py->dpy, py->win, bs_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[0][7] = XCreatePixmapFromBitmapData(py->dpy, py->win, bk_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[0][8] = XCreatePixmapFromBitmapData(py->dpy, py->win, ba_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[0][9] = XCreatePixmapFromBitmapData(py->dpy, py->win, bu_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X
X    py->gesturebm[1][0] = XCreatePixmapFromBitmapData(py->dpy, py->win, bn_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[1][1] = XCreatePixmapFromBitmapData(py->dpy, py->win, bvp_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[1][2] = XCreatePixmapFromBitmapData(py->dpy, py->win, bvd_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[1][3] = XCreatePixmapFromBitmapData(py->dpy, py->win, bvf_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[1][4] = XCreatePixmapFromBitmapData(py->dpy, py->win, bvw_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[1][5] = XCreatePixmapFromBitmapData(py->dpy, py->win, bvc_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[1][6] = XCreatePixmapFromBitmapData(py->dpy, py->win, bvs_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[1][7] = XCreatePixmapFromBitmapData(py->dpy, py->win, bvk_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[1][8] = XCreatePixmapFromBitmapData(py->dpy, py->win, bva_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X    py->gesturebm[1][9] = XCreatePixmapFromBitmapData(py->dpy, py->win, bu_bits,
X		GEST_SIZE, GEST_SIZE, 1, 0, 1);
X
X    py->spelllistbm[0][0] = XCreatePixmapFromBitmapData(py->dpy, py->win, sp_bits,
X		GEST_SMALL, GEST_SMALL, 1, 0, 1);
X    py->spelllistbm[0][1] = XCreatePixmapFromBitmapData(py->dpy, py->win, sd_bits,
X		GEST_SMALL, GEST_SMALL, 1, 0, 1);
X    py->spelllistbm[0][2] = XCreatePixmapFromBitmapData(py->dpy, py->win, sf_bits,
X		GEST_SMALL, GEST_SMALL, 1, 0, 1);
X    py->spelllistbm[0][3] = XCreatePixmapFromBitmapData(py->dpy, py->win, sw_bits,
X		GEST_SMALL, GEST_SMALL, 1, 0, 1);
X    py->spelllistbm[0][4] = 0; /* there is no single clap */
X    py->spelllistbm[0][5] = XCreatePixmapFromBitmapData(py->dpy, py->win, ss_bits,
X		GEST_SMALL, GEST_SMALL, 1, 0, 1);
X    py->spelllistbm[0][6] = XCreatePixmapFromBitmapData(py->dpy, py->win, sdot_bits,
X		GEST_SMALL, GEST_SMALL, 1, 0, 1);
X
X    py->spelllistbm[1][0] = XCreatePixmapFromBitmapData(py->dpy, py->win, sp2_bits,
X		GEST_SMALL, GEST_SMALL, 1, 0, 1);
X    py->spelllistbm[1][1] = XCreatePixmapFromBitmapData(py->dpy, py->win, sd2_bits,
X		GEST_SMALL, GEST_SMALL, 1, 0, 1);
X    py->spelllistbm[1][2] = XCreatePixmapFromBitmapData(py->dpy, py->win, sf2_bits,
X		GEST_SMALL, GEST_SMALL, 1, 0, 1);
X    py->spelllistbm[1][3] = XCreatePixmapFromBitmapData(py->dpy, py->win, sw2_bits,
X		GEST_SMALL, GEST_SMALL, 1, 0, 1);
X    py->spelllistbm[1][4] = XCreatePixmapFromBitmapData(py->dpy, py->win, sc_bits,
X		GEST_SMALL, GEST_SMALL, 1, 0, 1);
X    py->spelllistbm[1][5] = XCreatePixmapFromBitmapData(py->dpy, py->win, ss2_bits,
X		GEST_SMALL, GEST_SMALL, 1, 0, 1);
X    py->spelllistbm[1][6] = 0; /* no double dots */
X
X}
X
Xvoid redraw_column(py)
Xstruct player *py;
X{
X    int buf[COLUMN_SIZE+1];
X    int ix, gx;
X    int vall, valr;
X    int posx, posy;
X    int pnum = py-players;
X
X    if (turnstate==State_Init) {
X	return;
X    }
X
X    for (ix=0; ix<numplayers; ix++) {
X	posx = COLUMN_X + ix*(2*GEST_SIZE + 20);
X	posy = COLUMN_Y;
X
X	DrawStringCentered(py, NameOfBeing(gameval, QuVal_Target_Wizard, ix),
X			posx+GEST_SIZE, posy-py->lineheight+py->ascent);
X
X	if (turnstate!=State_Top) {
X	    SeeGesture(gameval, ix, pnum, buf, COLUMN_SIZE);
X	    gx=0;
X	    if (turnstate==State_EQueries && ix!=pnum) {
X		buf[0] = (Gesture_UNCLEAR<<5) + Gesture_UNCLEAR;
X	    }
X	}
X	else {
X	    SeeGesture(gameval, ix, pnum, buf+1, COLUMN_SIZE);
X	    gx=1;
X	    if (ix==pnum) {
X		vall = py->gesture_chosen[0];
X		valr = py->gesture_chosen[1];
X	    }
X	    else {
X		vall = Gesture_UNCLEAR;
X		valr = Gesture_UNCLEAR;
X	    }
X	    XCopyPlane(py->dpy, py->gesturebm[0][vall], py->win, py->blackgc,
X			0, 0, GEST_SIZE, GEST_SIZE, posx,
X			posy+(GEST_SPACE)*(COLUMN_SIZE-1), 1);
X	    XCopyPlane(py->dpy, py->gesturebm[1][valr], py->win, py->blackgc,
X			0, 0, GEST_SIZE, GEST_SIZE, posx+GEST_SPACE,
X			posy+(GEST_SPACE)*(COLUMN_SIZE-1), 1);
X	}
X	for (/* gx is set */; gx<COLUMN_SIZE; gx++) {
X	    if (buf[gx]==(-1)) {
X		valr = Gesture_NOTHING;
X		vall = Gesture_NOTHING;
X	    }
X	    else {
X		valr = buf[gx] >> 5;
X		vall = buf[gx] & 31; /* 31==01111 */
X	    }
X	    XCopyPlane(py->dpy, py->gesturebm[0][vall], py->win, py->blackgc,
X			0, 0, GEST_SIZE, GEST_SIZE, posx,
X			posy+(GEST_SPACE)*(COLUMN_SIZE-(gx+1)), 1);
X	    XCopyPlane(py->dpy, py->gesturebm[1][valr], py->win, py->blackgc,
X			0, 0, GEST_SIZE, GEST_SIZE, posx+GEST_SPACE,
X			posy+(GEST_SPACE)*(COLUMN_SIZE-(gx+1)), 1);
X	}
X    }
X}
X
Xvoid draw_frame(py, mrec)
Xstruct player *py;
Xstruct rect *mrec;
X{
X    XClearArea(py->dpy, py->win, mrec->x, mrec->y, mrec->w, mrec->h, 0);
X
X    XDrawRectangle(py->dpy, py->win, py->blackgc, mrec->x, mrec->y,
X		mrec->w-FRAME_SHADOW, mrec->h-FRAME_SHADOW);
X    XDrawRectangle(py->dpy, py->win, py->blackgc, mrec->x+1, mrec->y+1,
X		mrec->w-FRAME_SHADOW-2, mrec->h-FRAME_SHADOW-2);
X    XFillRectangle(py->dpy, py->win, py->blackgc, mrec->x+mrec->w-FRAME_SHADOW,
X		mrec->y+FRAME_SHADOW, FRAME_SHADOW, mrec->h-FRAME_SHADOW);
X    XFillRectangle(py->dpy, py->win, py->blackgc, mrec->x+FRAME_SHADOW,
X		mrec->y+mrec->h-FRAME_SHADOW, mrec->w-FRAME_SHADOW, FRAME_SHADOW);
X}
X
Xvoid draw_gesture_menu(py)
Xstruct player *py;
X{
X    static char gesture_prompt[2][128];
X    int ix, jx;
X    int posx, posy;
X
X    draw_frame(py, &py->gesture_rect);
X    sprintf(gesture_prompt[0], "What gesture do you want to");
X    sprintf(gesture_prompt[1], "make with your %s hand?",
X		py->gesture_hand?"right":"left");
X    XDrawImageString(py->dpy, py->win, py->blackgc, py->gesture_rect.x+20,
X		py->gesture_rect.y+10+py->lineheight, gesture_prompt[0],
X		strlen(gesture_prompt[0]));
X    XDrawImageString(py->dpy, py->win, py->blackgc, py->gesture_rect.x+20,
X		py->gesture_rect.y+10+2*py->lineheight, gesture_prompt[1],
X		strlen(gesture_prompt[1]));
X
X    posx = py->gesture_rect.x+20;
X    posy = py->gesture_rect.y+60;
X    for (jx=0; jx<2; jx++)
X	for (ix=0; ix<4; ix++) {
X	    XCopyPlane(py->dpy, py->gesturebm[py->gesture_hand][jx*4+ix],
X			py->win, py->blackgc, 0, 0, GEST_SIZE, GEST_SIZE,
X			posx+ix*GEST_SPACE, posy+jx*GEST_SPACE, 1);
X	}
X}
X
Xint in_gesture_box(py, xpos, ypos)
Xstruct player *py;
Xint xpos, ypos;
X{
X    return (xpos >= COLUMN_X
X	    && xpos < COLUMN_X + numplayers*(2*GEST_SIZE + 20)
X	    && ypos >= COLUMN_Y
X	    && ypos < COLUMN_Y + GEST_SPACE*COLUMN_SIZE);
X}
X
Xint gesture_hit(py, xpos, ypos, button)
Xstruct player *py;
Xint xpos, ypos; /* relative to column pos */
Xint button;
X{
X    int pnum = py-players;
X    int hitcol, hitrow, hithand;
X
X    xpos -= COLUMN_X;
X    ypos -= COLUMN_Y;
X
X    if (!py->turn_active || py->turn_done)
X	return ms_None;
X
X    hitcol = xpos / (2*GEST_SIZE + 20);
X    hitrow = ypos / GEST_SPACE;
X    hithand = (xpos % (2*GEST_SIZE + 20)) / GEST_SPACE;
X    if (hithand < 0 || hithand > 1)
X	return ms_None;
X
X    if (hitrow==COLUMN_SIZE-1 && hitcol==pnum && button==1 && turnstate==State_Top) {
X	py->gesture_rect.w = 240;
X	py->gesture_rect.h = 180;
X	py->gesture_rect.x = xpos + COLUMN_X - py->gesture_rect.w/2;
X	py->gesture_rect.y = ypos + COLUMN_Y - py->gesture_rect.h/2;
X	py->gesture_hand = hithand;
X	py->gesture_sel = (-1);
X	adjust_rect(&py->gesture_rect);
X	backing_store(py, &py->gesture_rect);
X	draw_gesture_menu(py);
X	gesture_motion(py, xpos+COLUMN_X, ypos+COLUMN_Y, button);
X	return ms_Gesture;
X    }
X
X    return ms_None;
X}
X
Xint gesture_motion(py, xpos, ypos, button)
Xstruct player *py;
Xint xpos, ypos;
Xint button;
X{
X    int hitx, hity, hit;
X    int posx, posy;
X
X    posx = py->gesture_rect.x+20;
X    posy = py->gesture_rect.y+60;
X
X    hitx = (xpos - posx + GEST_SPACE) / GEST_SPACE - 1;
X    hity = (ypos - posy + GEST_SPACE) / GEST_SPACE - 1;
X
X    if (hitx>=0 && hitx<4 && hity>=0 && hity<2)
X	hit = hity*4 + hitx;
X    else
X	hit = (-1);
X
X    if (hit==py->gesture_sel)
X	return;
X
X    if (py->gesture_sel != (-1)) {
X	/* erase old */
X	hitx = py->gesture_sel % 4;
X	hity = py->gesture_sel / 4;
X	XDrawRectangle(py->dpy, py->win, py->whitegc, posx+hitx*GEST_SPACE-1,
X			posy+hity*GEST_SPACE-1, GEST_SIZE+1, GEST_SIZE+1);
X	XDrawRectangle(py->dpy, py->win, py->whitegc, posx+hitx*GEST_SPACE-2,
X			posy+hity*GEST_SPACE-2, GEST_SIZE+3, GEST_SIZE+3);
X    }
X
X    py->gesture_sel = hit;
X
X    if (py->gesture_sel != (-1)) {
X	/* draw new */
X	hitx = py->gesture_sel % 4;
X	hity = py->gesture_sel / 4;
X	XDrawRectangle(py->dpy, py->win, py->blackgc, posx+hitx*GEST_SPACE-1,
X			posy+hity*GEST_SPACE-1, GEST_SIZE+1, GEST_SIZE+1);
X	XDrawRectangle(py->dpy, py->win, py->blackgc, posx+hitx*GEST_SPACE-2,
X			posy+hity*GEST_SPACE-2, GEST_SIZE+3, GEST_SIZE+3);
X    }
X}
X
Xint gesture_release(py, xpos, ypos, button)
Xstruct player *py;
Xint xpos, ypos; /* relative to column pos */
Xint button;
X{
X    int posx, posy;
X    int pnum = py-players;
X
X    xpos -= COLUMN_X;
X    ypos -= COLUMN_Y;
X
X    backing_restore(py);
X    if (py->gesture_sel != (-1))
X	py->gesture_chosen[py->gesture_hand] = py->gesture_sel;
X
X    posx = COLUMN_X + pnum*(2*GEST_SIZE + 20);
X    posy = COLUMN_Y;
X    XCopyPlane(py->dpy, py->gesturebm[0][py->gesture_chosen[0]], py->win,
X		py->blackgc, 0, 0, GEST_SIZE, GEST_SIZE, posx,
X		posy+(GEST_SPACE)*(COLUMN_SIZE-1), 1);
X    XCopyPlane(py->dpy, py->gesturebm[1][py->gesture_chosen[1]], py->win,
X		py->blackgc, 0, 0, GEST_SIZE, GEST_SIZE, posx+GEST_SPACE,
X		posy+(GEST_SPACE)*(COLUMN_SIZE-1), 1);
X}
END_OF_FILE
if test 11180 -ne `wc -c <'xgest.c'`; then
    echo shar: \"'xgest.c'\" unpacked with wrong size!
fi
# end of 'xgest.c'
fi
if test -f 'xtalk.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xtalk.c'\"
else
echo shar: Extracting \"'xtalk.c'\" \(3542 characters\)
sed "s/^X//" >'xtalk.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include "handwave.h"
X#include "spelllist.h"
X#include "xspell.h"
X
X#define TALK_X (348)
X#define TALK_Y (576)
X#define TALK_W (448)
X#define TALK_LEADING (8)
X
Xstatic char bigbuf[2048], bigbuf2[2048];
X
Xvoid init_talk(py)
Xstruct player *py;
X{
X    py->talk_size = 128;
X    py->talk_buf = (char *)malloc(sizeof(char) * py->talk_size);
X    strcpy(py->talk_buf, "");
X    py->talk_pt = 0;
X    py->talk_xlast = (-1);
X    py->talk_x = 0;
X    py->talk_toobig = 0;
X}
X
Xvoid redraw_talk_only(py, recomp)
Xstruct player *py;
Xint recomp;
X{
X    static XCharStruct overall;
X    int direction, ascent, descent;
X    int width;
X
X    static XPoint caret[3] = {
X	{0, 0}, {2, -3}, {2, 3} 
X    };
X
X    if (recomp) {
X	XTextExtents(py->font, py->talk_buf, py->talk_pt, &direction, &ascent,
X			&descent, &overall);
X	py->talk_x = overall.width;
X    }
X
X    if (py->talk_x != py->talk_xlast) {
X	caret[0].x = TALK_X+py->talk_xlast - 2;
X	caret[0].y = TALK_Y+py->lineheight + 4;
X	XDrawLines(py->dpy, py->win, py->whitegc, caret, 3, CoordModePrevious);
X	py->talk_xlast = py->talk_x;
X    }
X
X    width = DrawStringField(py, py->talk_buf, TALK_X, TALK_Y+py->lineheight, TALK_W);
X
X    caret[0].x = TALK_X+py->talk_x - 2;
X    caret[0].y = TALK_Y+py->lineheight + 4;
X    XDrawLines(py->dpy, py->win, py->blackgc, caret, 3, CoordModePrevious);
X
X    py->talk_toobig = (width >= (TALK_W-py->lineheight));
X}
X
Xvoid redraw_talk(py)
Xstruct player *py;
X{
X    XDrawRectangle(py->dpy, py->win, py->blackgc, TALK_X-3, TALK_Y-2, TALK_W+6,
X		py->lineheight+TALK_LEADING+4);
X
X    redraw_talk_only(py, 0);
X}
X
Xstatic void ensure_talk_size(py, size)
Xstruct player *py;
Xint size;
X{
X    if (size < py->talk_size)
X	return;
X
X    while (size < py->talk_size)
X	py->talk_size *= 2;
X
X    py->talk_buf = (char *)realloc(py->talk_buf, sizeof(char) * py->talk_size);
X}
X
Xvoid talk_handle_char(py, ch)
Xstruct player *py;
Xchar ch;
X{
X    char *cp;
X    int ix;
X    int pnum;
X
X    if (isprint(ch)) {
X	if (!py->talk_toobig) {
X	    ensure_talk_size(py, strlen(py->talk_buf)+1);
X	    for (cp = &(py->talk_buf[py->talk_pt]); *cp; cp++);
X	    for (; cp >= &(py->talk_buf[py->talk_pt]); cp--)
X		*(cp+1) = *cp;
X	    py->talk_buf[py->talk_pt] = ch;
X	    py->talk_pt++;
X	    redraw_talk_only(py, 1);
X	}
X    }
X    else
X	switch (ch) {
X	    case '\n':
X	    case '\r':
X	    case '\023':
X		if (py->talk_pt) {
X		    pnum = py-players;
X		    sprintf(bigbuf, "You say \"%s\"\n", py->talk_buf);
X		    sprintf(bigbuf2, "%s says \"%s\"\n", NameOfBeing(gameval,
X				QuVal_Target_Wizard, pnum), py->talk_buf);
X		    for (ix=0; ix<numplayers; ix++)
X			if (ix==pnum)
X			    dump_text(ix, bigbuf);
X			else
X			    dump_text(ix, bigbuf2);
X		    LogInTranscript(gameval, bigbuf2);
X		}
X		py->talk_pt = 0;
X		py->talk_buf[0] = '\0';
X		redraw_talk_only(py, 1);
X		break;
X	    case '\177':
X		if (py->talk_pt) {
X		    py->talk_pt--;
X		    for (cp = &(py->talk_buf[py->talk_pt]); *cp; cp++)
X			*cp = *(cp+1);
X		    redraw_talk_only(py, 1);
X		}
X		break;
X	    case '\013':
X		py->talk_buf[py->talk_pt] = '\0';
X		redraw_talk_only(py, 1);
X		break;
X	    case '\002':
X		if (py->talk_pt) {
X		    py->talk_pt--;
X		    redraw_talk_only(py, 1);
X		}
X		break;
X	    case '\006':
X		if (py->talk_buf[py->talk_pt]) {
X		    py->talk_pt++;
X		    redraw_talk_only(py, 1);
X		}
X		break;
X	    case '\001':
X		py->talk_pt = 0;
X		redraw_talk_only(py, 1);
X		break;
X	    case '\005':
X		while (py->talk_buf[py->talk_pt])
X		    py->talk_pt++;
X		redraw_talk_only(py, 1);
X		break;
X	}
X}
END_OF_FILE
if test 3542 -ne `wc -c <'xtalk.c'`; then
    echo shar: \"'xtalk.c'\" unpacked with wrong size!
fi
# end of 'xtalk.c'
fi
echo shar: End of archive 6 \(of 7\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
