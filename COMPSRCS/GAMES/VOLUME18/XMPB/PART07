Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i007:  xmpb - multiplayer space combat for X, Part07/08
Date: 26 Jun 1993 00:33:01 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2773
Approved: billr@saab.CNA.TEK.COM
Message-ID: <20g5ft$6sq@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1797

Submitted-by: ddp@deakin.edu.au (Damien De Paoli)
Posting-number: Volume 18, Issue 7
Archive-name: xmpb/Part07
Environment: X11, Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 8)."
# Contents:  beam.npc bitmaps/bigrock bitmaps/cloud.2 bitmaps/debris.1
#   bitmaps/debris.2 bitmaps/medrock bitmaps/shortdeaddude
#   calc_angle.c calc_shields.c clear_lock.man collide.c costab.c
#   describe.c describe.man do_stars.c harry.npc john.npc ml2.npc
#   operators.h pcomp.h rad2.npc rad3.npc read_ship.c retire.c
#   retire.man save.h save_load.c shop.icon shop_ui.h sin.c sintab.c
#   thrust.c ud_win.c weapon.h
# Wrapped by billr@saab on Fri Jun 25 16:30:16 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'beam.npc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'beam.npc'\"
else
echo shar: Extracting \"'beam.npc'\" \(559 characters\)
sed "s/^X//" >'beam.npc' <<'END_OF_FILE'
XNPC
XName = BeamJack
XShip = LightHouse
XEnergyMax = 1000
XLShieldMax = 1200
XRShieldMax = 1200
XBShieldMax = 800
XSolar = 6
XShortRange = none
XEngine = none
XRepair = 9
XLongRange = 1
XJammer = 6
XTC = 1
X
XWeapons
XHLaser
XLLaser
X
Xvar 
X	num
Xend
X
XState start
X{
X	set B2 = 1;
X	choose();
X	1 -> beam;
X}
X
XState beam
X{
X	set Jamming = 0;
X	if(!EnemyAvail)
X		choose();
X
X	set B1 = 0;
X	while(EnemyAvail && Angle != EnemyAngle)
X		set TurnTo = EnemyAngle;
X	set B1 = 1;
X}
X
XProc choose
X{
X	set B1 = 0;
X	set Jamming = 1;
X	if(NumEnemies)
X	{
X		set SelectEnemy = 0;
X		return;
X	}
X}
X
XStart start
END_OF_FILE
if test 559 -ne `wc -c <'beam.npc'`; then
    echo shar: \"'beam.npc'\" unpacked with wrong size!
fi
# end of 'beam.npc'
fi
if test -f 'bitmaps/bigrock' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/bigrock'\"
else
echo shar: Extracting \"'bitmaps/bigrock'\" \(2273 characters\)
sed "s/^X//" >'bitmaps/bigrock' <<'END_OF_FILE'
X#define bigrock_width 50
X#define bigrock_height 50
Xstatic char bigrock_bits[] = {
X   0x00, 0x00, 0xce, 0xc3, 0x01, 0x00, 0x00, 0x00, 0x20, 0xce, 0xc3, 0x01,
X   0x00, 0x00, 0x00, 0xfc, 0xf1, 0xff, 0x1f, 0x00, 0x00, 0x00, 0xfe, 0xf1,
X   0xff, 0x5f, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
X   0xee, 0xff, 0xf8, 0x7f, 0x00, 0x00, 0x00, 0xef, 0x7f, 0xff, 0x7f, 0x00,
X   0x00, 0x80, 0xef, 0xbf, 0xcf, 0xbf, 0x00, 0x00, 0x88, 0xf7, 0xfb, 0xdf,
X   0xaf, 0x01, 0x00, 0xf8, 0xff, 0xff, 0xfb, 0xff, 0x07, 0x00, 0xf0, 0xbf,
X   0xff, 0xf3, 0xff, 0x27, 0x00, 0xfe, 0xff, 0xff, 0xef, 0xff, 0xf9, 0x00,
X   0xfe, 0x9f, 0xff, 0xff, 0xfc, 0xf9, 0x00, 0xfc, 0x9b, 0x7d, 0xff, 0xfb,
X   0x7f, 0x00, 0xfc, 0xbf, 0x9f, 0xff, 0xff, 0xbf, 0x01, 0x7c, 0xdf, 0xfe,
X   0xfb, 0xbf, 0xff, 0x00, 0xfc, 0x9f, 0xff, 0xfb, 0xff, 0xff, 0x01, 0xff,
X   0xff, 0xf3, 0xeb, 0xf7, 0xf3, 0x00, 0xbf, 0xff, 0xff, 0xdf, 0xef, 0xff,
X   0x00, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xff, 0x00, 0xf8, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0x00, 0xf6, 0xfb, 0xf7, 0xfb, 0xff, 0xfb, 0x00, 0xf7, 0xff,
X   0xfd, 0xff, 0xff, 0xff, 0x03, 0x3f, 0xff, 0xfe, 0xf7, 0xff, 0xff, 0x03,
X   0xff, 0xdf, 0xef, 0xbb, 0xff, 0xbf, 0x03, 0xef, 0xf7, 0xef, 0x7f, 0xfe,
X   0xf9, 0x03, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xff, 0x03, 0xbf, 0xdd, 0xff,
X   0xff, 0xff, 0xfe, 0x03, 0xfe, 0xff, 0xff, 0xfc, 0xef, 0xf9, 0x03, 0xfe,
X   0xcf, 0xfb, 0xfe, 0xe7, 0xdd, 0x03, 0xfc, 0xe7, 0xaf, 0xfe, 0xff, 0xdf,
X   0x03, 0xfe, 0xef, 0xff, 0x7b, 0xff, 0xff, 0x03, 0xfc, 0xef, 0xff, 0xff,
X   0xff, 0xfd, 0x03, 0xfc, 0xff, 0xd9, 0xbc, 0xf6, 0xff, 0x00, 0xfc, 0xff,
X   0xc3, 0xbc, 0xee, 0xfd, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xfd, 0x00,
X   0xf8, 0xd7, 0xff, 0xff, 0xff, 0xff, 0x00, 0xe0, 0xff, 0xf7, 0xff, 0xff,
X   0x07, 0x00, 0xc0, 0xff, 0x7f, 0xff, 0xff, 0x07, 0x00, 0xc0, 0xff, 0xff,
X   0xfd, 0xfd, 0x3d, 0x00, 0x80, 0xff, 0xff, 0xbf, 0xbf, 0x39, 0x00, 0x00,
X   0x7e, 0xf3, 0xfe, 0xff, 0x0f, 0x00, 0x80, 0xff, 0xf8, 0xff, 0xfe, 0x07,
X   0x00, 0x00, 0xfe, 0xff, 0xdb, 0xff, 0x01, 0x00, 0x00, 0xe6, 0xff, 0xff,
X   0xff, 0x03, 0x00, 0x00, 0xf4, 0xff, 0xff, 0xff, 0x05, 0x00, 0x00, 0xe0,
X   0xff, 0x3f, 0x1b, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x3f, 0x18, 0x00, 0x00,
X   0x00, 0x00, 0x5e, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x0f, 0x00,
X   0x00, 0x00};
END_OF_FILE
if test 2273 -ne `wc -c <'bitmaps/bigrock'`; then
    echo shar: \"'bitmaps/bigrock'\" unpacked with wrong size!
fi
# end of 'bitmaps/bigrock'
fi
if test -f 'bitmaps/cloud.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/cloud.2'\"
else
echo shar: Extracting \"'bitmaps/cloud.2'\" \(434 characters\)
sed "s/^X//" >'bitmaps/cloud.2' <<'END_OF_FILE'
X#define cloud_width 19
X#define cloud_height 19
Xstatic char cloud_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x40, 0x08, 0x00,
X   0x80, 0x08, 0x00, 0x60, 0xf8, 0x00, 0x38, 0x12, 0x03, 0x08, 0x10, 0x02,
X   0x04, 0x80, 0x02, 0x48, 0x06, 0x02, 0x28, 0x10, 0x01, 0x10, 0xe0, 0x00,
X   0x48, 0x28, 0x00, 0x10, 0x41, 0x00, 0x10, 0x42, 0x00, 0x20, 0x47, 0x00,
X   0xc0, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 434 -ne `wc -c <'bitmaps/cloud.2'`; then
    echo shar: \"'bitmaps/cloud.2'\" unpacked with wrong size!
fi
# end of 'bitmaps/cloud.2'
fi
if test -f 'bitmaps/debris.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/debris.1'\"
else
echo shar: Extracting \"'bitmaps/debris.1'\" \(437 characters\)
sed "s/^X//" >'bitmaps/debris.1' <<'END_OF_FILE'
X#define debris_width 19
X#define debris_height 19
Xstatic char debris_bits[] = {
X   0x00, 0x20, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x08, 0x03, 0x00, 0x04, 0x02,
X   0x00, 0x02, 0x01, 0x00, 0x01, 0x01, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00,
X   0x40, 0x40, 0x00, 0x20, 0x40, 0x00, 0x10, 0x20, 0x00, 0x08, 0x20, 0x00,
X   0x04, 0x10, 0x00, 0x06, 0x10, 0x00, 0x18, 0x08, 0x00, 0x60, 0x08, 0x00,
X   0x80, 0x05, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 437 -ne `wc -c <'bitmaps/debris.1'`; then
    echo shar: \"'bitmaps/debris.1'\" unpacked with wrong size!
fi
# end of 'bitmaps/debris.1'
fi
if test -f 'bitmaps/debris.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/debris.2'\"
else
echo shar: Extracting \"'bitmaps/debris.2'\" \(437 characters\)
sed "s/^X//" >'bitmaps/debris.2' <<'END_OF_FILE'
X#define debris_width 19
X#define debris_height 19
Xstatic char debris_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0xfe, 0x81, 0x00, 0x04, 0x80, 0x00,
X   0x18, 0x80, 0x00, 0x20, 0x80, 0x00, 0x40, 0x80, 0x00, 0x80, 0x80, 0x00,
X   0x00, 0x03, 0x01, 0x00, 0x04, 0x01, 0x00, 0x08, 0x01, 0x00, 0x10, 0x01,
X   0x00, 0x60, 0x01, 0x00, 0x80, 0x01, 0x00, 0x00, 0x01};
END_OF_FILE
if test 437 -ne `wc -c <'bitmaps/debris.2'`; then
    echo shar: \"'bitmaps/debris.2'\" unpacked with wrong size!
fi
# end of 'bitmaps/debris.2'
fi
if test -f 'bitmaps/medrock' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/medrock'\"
else
echo shar: Extracting \"'bitmaps/medrock'\" \(515 characters\)
sed "s/^X//" >'bitmaps/medrock' <<'END_OF_FILE'
X#define medrock_width 23
X#define medrock_height 23
Xstatic char medrock_bits[] = {
X   0x00, 0x4d, 0x00, 0xf0, 0xfe, 0x01, 0xd0, 0xff, 0x0b, 0xda, 0xdf, 0x04,
X   0xfc, 0xef, 0x0f, 0xfe, 0xff, 0x37, 0xbe, 0xfb, 0x1f, 0xbe, 0xef, 0x3f,
X   0xff, 0xff, 0x3e, 0xfc, 0xff, 0x3f, 0xfd, 0xff, 0x7f, 0xbf, 0xbd, 0x77,
X   0xff, 0xff, 0x7f, 0xfe, 0xff, 0x7e, 0xce, 0xff, 0x7f, 0xfe, 0xb4, 0x3e,
X   0xfd, 0xff, 0x3f, 0xf0, 0xff, 0x07, 0xf8, 0x3f, 0x17, 0x70, 0xfe, 0x0f,
X   0xd0, 0xff, 0x07, 0xc0, 0x3f, 0x01, 0x00, 0x19, 0x00};
END_OF_FILE
if test 515 -ne `wc -c <'bitmaps/medrock'`; then
    echo shar: \"'bitmaps/medrock'\" unpacked with wrong size!
fi
# end of 'bitmaps/medrock'
fi
if test -f 'bitmaps/shortdeaddude' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/shortdeaddude'\"
else
echo shar: Extracting \"'bitmaps/shortdeaddude'\" \(458 characters\)
sed "s/^X//" >'bitmaps/shortdeaddude' <<'END_OF_FILE'
X#define shortdeaddude_width 19
X#define shortdeaddude_height 19
Xstatic char shortdeaddude_bits[] = {
X   0x80, 0x03, 0x00, 0x40, 0x05, 0x00, 0xc0, 0x07, 0x00, 0x44, 0x04, 0x00,
X   0x88, 0x83, 0x00, 0x10, 0x61, 0x00, 0xe0, 0x1f, 0x00, 0xc0, 0x07, 0x00,
X   0xc0, 0x07, 0x00, 0xc0, 0x07, 0x00, 0x80, 0x03, 0x00, 0xc0, 0x07, 0x00,
X   0x40, 0x04, 0x00, 0x20, 0x04, 0x00, 0x20, 0x04, 0x00, 0x14, 0x28, 0x00,
X   0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 458 -ne `wc -c <'bitmaps/shortdeaddude'`; then
    echo shar: \"'bitmaps/shortdeaddude'\" unpacked with wrong size!
fi
# end of 'bitmaps/shortdeaddude'
fi
if test -f 'calc_angle.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'calc_angle.c'\"
else
echo shar: Extracting \"'calc_angle.c'\" \(847 characters\)
sed "s/^X//" >'calc_angle.c' <<'END_OF_FILE'
X/* calc_angle.c - *** put a one line description here */
X
X#if !defined(lint)
Xstatic char sccs_id[] = "@(#)calc_angle.c 1.4 92/11/24 XMPB";
X#endif
X#include <math.h>
X#include "player.h"
X
Xint calc_angles(w)
Xwinptr w;
X{
X    float na,dela;
X    int nx,ny;
X   
X	if(w->tl)
X	{
X		na = w->angle - w->max_angle_v;
X	}
X	else
X	if(w->tr)
X	{
X		na = w->angle + w->max_angle_v;
X	}
X	else
X	{
X		na = w->angle;
X	}
X	
X    if(na <0.0 ) na +=360.0;
X    dela = na-w->angle;
X    if(dela > 180.0) na -=360.0;
X    if(dela < -180.0) na+=360.0;
X
X#define FABS(x) ((x)>0.0?(x):-(x))
X#define FSGN(x)  (x>0.0?1.0:-1.0)
X
X    if(w->max_angle_v >= FABS(na-w->angle))
X    {
X        w->angle = na;
X    }
X    else
X    {
X        w->angle += FSGN(na-w->angle)*w->max_angle_v;
X    }
X	w->dela = (int)dela;
X
X    if(w->angle < 0.0) w->angle += 360.0;
X    if(w->angle >= 360.0) w->angle -=360;
X}
X
END_OF_FILE
if test 847 -ne `wc -c <'calc_angle.c'`; then
    echo shar: \"'calc_angle.c'\" unpacked with wrong size!
fi
# end of 'calc_angle.c'
fi
if test -f 'calc_shields.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'calc_shields.c'\"
else
echo shar: Extracting \"'calc_shields.c'\" \(640 characters\)
sed "s/^X//" >'calc_shields.c' <<'END_OF_FILE'
X/* calc_shields.c - *** Routines for pre calcing shield positions */
X
Xstatic char sccs_id[] = " @(#)calc_shields.c 1.2 92/11/24 XMPB";
X#include "player.h"
X
Xextern winptr first_win;
Xextern int mysintab[],mycostab[];
X
Xprecalc()
X{
X	winptr t;
X
X	t = first_win;
X	
X	while(t)
X	{
X		t->p1x = t->sx+50*mysintab[(int)t->angle]/32768;
X		t->p1y = t->sy+50*mycostab[(int)t->angle]/32768;
X		t->p2x = t->sx+40*mysintab[((int)t->angle+135)%360]/32768;
X		t->p2y = t->sy+40*mycostab[((int)t->angle+135)%360]/32768;
X		t->p3x = t->sx+40*mysintab[((int)t->angle+225)%360]/32768;
X		t->p3y = t->sy+40*mycostab[((int)t->angle+225)%360]/32768;
X	
X		t = t->next;
X	}
X}
X
END_OF_FILE
if test 640 -ne `wc -c <'calc_shields.c'`; then
    echo shar: \"'calc_shields.c'\" unpacked with wrong size!
fi
# end of 'calc_shields.c'
fi
if test -f 'clear_lock.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'clear_lock.man'\"
else
echo shar: Extracting \"'clear_lock.man'\" \(548 characters\)
sed "s/^X//" >'clear_lock.man' <<'END_OF_FILE'
X.TH Xmpb 6
X.SH NAME
Xclear_lock - clear a lock file 
X.SH SYPNOSIS
X.ta 4n
X\fIclear_lock\fR Name
X
X.SH DESCRIPTION
X
X	This program is here if you manage to break our game, or we just stuffed up again.  When you start a game, xmpb locks your characters file.  You cannot go to the shop if this lock is still there.  
X
XSo if things have gone funny, then just type:
X
Xclear_lock Name   -  Where Name is the name of the locked character.
X
X
XIf this program doesn't work:
X
XUsage: clear_lock Name
X
X
X- You have not given one parameter to the clear_lock program
X
END_OF_FILE
if test 548 -ne `wc -c <'clear_lock.man'`; then
    echo shar: \"'clear_lock.man'\" unpacked with wrong size!
fi
# end of 'clear_lock.man'
fi
if test -f 'collide.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'collide.c'\"
else
echo shar: Extracting \"'collide.c'\" \(2266 characters\)
sed "s/^X//" >'collide.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <sys/time.h>
X#include <math.h>
X
Xline_2_rect(x1,y1,x2,y2,cx,cy,w,h)
Xint x1,y1;
Xint x2,y2;
Xint cx,cy;
Xint w;
Xint h;
X{
X	int mask1,mask2;
X
X	int maxx,minx,maxy,miny;
X
X	/*
X	**	Calculate the sides of the rectangle
X	*/
X	maxx = cx + w/2;
X	minx = cx - w/2;
X	
X	maxy = cy + h/2;
X	miny = cy - h/2;
X
Xreiterate:
X
X	mask1 = 0;
X	mask2 = 0;
X
X	/*
X	**	Get the masks for the endpoints
X	*/
X	mask1 = endpmask(x1,y1,minx,maxx,miny,maxy);
X	mask2 = endpmask(x2,y2,minx,maxx,miny,maxy);
X
X	if(mask1 & mask2)
X	{
X		/*
X		**	There was no intersection
X		*/
X
X		return 0;
X	}
X	else if((mask1 == 0) && (mask2 == 0))
X	{
X		/*
X		**	Both ends inside the rectangle, so definite
X		**	collision
X		*/
X		return 1;
X	}
X	else
X	{
X		/*
X		**	There might have been an intersection
X		*/
X		if(mask1)
X		{
X			/*
X			**	Point 1 is outside the rectangle
X			*/
X			if(mask1 & 1)
X			{
X				int x,y;
X
X				x = x1; y = y1;
X
X				x1 = minx;
X
X				y1 = y + (minx - x) * (y2 - y)/(x2 - x);
X				goto reiterate;
X			}
X			if(mask1 & 2)
X			{
X				int x,y;
X
X				x = x1; y = y1;
X
X				x1 = maxx;
X
X				y1 =  y - ((x - maxx) * (y2 - y)/(x2 - x));
X				goto reiterate;
X			}
X			if(mask1 & 4)
X			{
X				int x,y;
X
X				x = x1; y = y1;
X
X				y1 = miny;
X
X				x1 = x + (miny - y) * (x2 - x)/(y2 - y);
X				goto reiterate;
X			}
X			if(mask1 & 8)
X			{
X				int x,y;
X
X				x = x1; y = y1;
X
X				y1 = miny;
X
X				x1 = x - ((y - maxy) * (x2 - x)/(y2 - y));
X				goto reiterate;
X			}
X		}
X		else
X		{
X			/*
X			**	Point 2 is outside the rectangle
X			*/
X			if(mask2 & 1)
X			{
X				int x,y;
X
X				x = x2; y = y2;
X
X				x2 = minx;
X
X				y2 = y + (minx - x) * (y1 - y)/(x1 - x);
X				goto reiterate;
X			}
X			if(mask2 & 2)
X			{
X				int x,y;
X
X				x = x2; y = y2;
X
X				x2 = maxx;
X
X				y2 = y - ((x - maxx) * (y1 - y)/(x1 - x));
X				goto reiterate;
X			}
X			if(mask2 & 4)
X			{
X				int x,y;
X
X				x = x2; y = y2;
X
X				y2 = miny;
X
X				x2 = x + (miny - y) * (x1 - x)/(y1 - y);
X				goto reiterate;
X			}
X			if(mask2 & 8)
X			{
X				int x,y;
X
X				x = x2; y = y2;
X
X				y2 = maxy;
X
X				x2 = x - ((y - maxy) * (x1 - x)/(y1 - y));
X				goto reiterate;
X			}
X		}
X	}
X}
X
Xint endpmask(x1,y1,minx,maxx,miny,maxy)
Xint x1,y1;
Xint minx,maxx;
Xint miny,maxy;
X{
X	int m = 0;
X
X	if(x1 < minx)
X		m |= 1;
X	if(x1 > maxx)
X		m |= 2;
X	if(y1 < miny)
X		m |= 4;
X	if(y1 > maxy)
X		m |= 8;
X
X	return m;
X}
END_OF_FILE
if test 2266 -ne `wc -c <'collide.c'`; then
    echo shar: \"'collide.c'\" unpacked with wrong size!
fi
# end of 'collide.c'
fi
if test -f 'costab.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'costab.c'\"
else
echo shar: Extracting \"'costab.c'\" \(2323 characters\)
sed "s/^X//" >'costab.c' <<'END_OF_FILE'
Xint mycostab[] = {
X32768,
X32763,32748,32723,32688,32643,32588,32523,32449,32364,32270,
X32165,32051,31928,31794,31651,31498,31336,31164,30982,30791,
X30591,30381,30163,29935,29697,29451,29196,28932,28659,28377,
X28087,27788,27481,27165,26841,26509,26169,25821,25465,25101,
X24730,24351,23964,23571,23170,22762,22347,21926,21497,21062,
X20621,20173,19720,19260,18794,18323,17846,17364,16876,16384,
X15886,15383,14876,14364,13848,13327,12803,12275,11743,11207,
X10668,10125,9580,9032,8480,7927,7371,6812,6252,5690,
X5126,4560,3993,3425,2855,2285,1714,1143,571,0,
X-571,-1143,-1714,-2285,-2855,-3425,-3993,-4560,-5126,-5690,
X-6252,-6812,-7371,-7927,-8480,-9032,-9580,-10125,-10668,-11207,
X-11743,-12275,-12803,-13327,-13848,-14364,-14876,-15383,-15886,-16383,
X-16876,-17364,-17846,-18323,-18794,-19260,-19720,-20173,-20621,-21062,
X-21497,-21926,-22347,-22762,-23170,-23571,-23964,-24351,-24730,-25101,
X-25465,-25821,-26169,-26509,-26841,-27165,-27481,-27788,-28087,-28377,
X-28659,-28932,-29196,-29451,-29697,-29935,-30163,-30381,-30591,-30791,
X-30982,-31164,-31336,-31498,-31651,-31794,-31928,-32051,-32165,-32270,
X-32364,-32449,-32523,-32588,-32643,-32688,-32723,-32748,-32763,-32768,
X-32763,-32748,-32723,-32688,-32643,-32588,-32523,-32449,-32364,-32270,
X-32165,-32051,-31928,-31794,-31651,-31498,-31336,-31164,-30982,-30791,
X-30591,-30381,-30163,-29935,-29697,-29451,-29196,-28932,-28659,-28377,
X-28087,-27788,-27481,-27165,-26841,-26509,-26169,-25821,-25465,-25101,
X-24730,-24351,-23964,-23571,-23170,-22762,-22347,-21926,-21497,-21062,
X-20621,-20173,-19720,-19260,-18794,-18323,-17846,-17364,-16876,-16384,
X-15886,-15383,-14876,-14364,-13848,-13327,-12803,-12275,-11743,-11207,
X-10668,-10125,-9580,-9032,-8480,-7927,-7371,-6812,-6252,-5690,
X-5126,-4560,-3993,-3425,-2855,-2285,-1714,-1143,-571,0,
X571,1143,1714,2285,2855,3425,3993,4560,5126,5690,
X6252,6812,7371,7927,8480,9032,9580,10125,10668,11207,
X11743,12275,12803,13327,13848,14364,14876,15383,15886,16384,
X16876,17364,17846,18323,18794,19260,19720,20173,20621,21062,
X21497,21926,22347,22762,23170,23571,23964,24351,24730,25101,
X25465,25821,26169,26509,26841,27165,27481,27788,28087,28377,
X28659,28932,29196,29451,29697,29935,30163,30381,30591,30791,
X30982,31164,31336,31498,31651,31794,31928,32051,32165,32270,
X32364,32449,32523,32588,32643,32688,32723,32748,32763,32768
X};
END_OF_FILE
if test 2323 -ne `wc -c <'costab.c'`; then
    echo shar: \"'costab.c'\" unpacked with wrong size!
fi
# end of 'costab.c'
fi
if test -f 'describe.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'describe.c'\"
else
echo shar: Extracting \"'describe.c'\" \(1285 characters\)
sed "s/^X//" >'describe.c' <<'END_OF_FILE'
X#include "player.h"
X#include "save.h"
X
Xint euid;
Xextern save default_save;
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	save *dude;
X	int i;
X
X	euid = geteuid();
X	/*
X    if(argc!=2) 
X    {
X        printf("Usage: %s Name\n", argv[0]);
X        exit(1);
X    }
X*/
X	argc--;
X	i=1;
X	while(i <= argc)
X	{
X		dude=load_dude(argv[i]);
X		if(dude==&(default_save))
X		{
X			struct header h;
X			FILE *fp;
X			char buf[160];
X
X			setuid(euid);
X			buf[0]=0;
X			strcpy(buf, NPCDIR);
X			strcat(buf, argv[i]);
X			strcat(buf, ".no");
X			fp=fopen(buf,"rb");
X			if(!fp)
X				fprintf(stderr, "\nNo such Combatant: %s\n", argv[i]);
X			else
X			{
X				fread(&h, sizeof(struct header),1,fp);
X				fclose(fp);
X				printf("\n=====================\n");
X				printf("Name: %s\n", h.Name);
X				printf("Ship: %s\n", h.Ship);
X				if(h.cash_earned>0)
X					printf("Value of ship: %d\n", h.cash_earned/(1+h.num_played)+350000);
X				else
X					printf("Value of ship: 350000\n");
X
X				printf("kills: %d\n", h.kills);
X				printf("=====================\n");
X			}
X		}
X		else
X		{
X
X			printf("\n=====================\n");
X			printf("Name: %s\n", dude->Name);
X			printf("Ship: %s\n", dude->Ship);
X			printf("Value of ship: %d\n", dude->ship_value);
X			printf("kills: %d\n", dude->kills);
X			printf("=====================\n");
X		}
X		i++;
X	}
X}
END_OF_FILE
if test 1285 -ne `wc -c <'describe.c'`; then
    echo shar: \"'describe.c'\" unpacked with wrong size!
fi
# end of 'describe.c'
fi
if test -f 'describe.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'describe.man'\"
else
echo shar: Extracting \"'describe.man'\" \(850 characters\)
sed "s/^X//" >'describe.man' <<'END_OF_FILE'
X.TH Xmpb 6
X.SH NAME
Xdescribe - describe your opponents
X.SH SYPNOSIS
X.ta 4n
X\fIdescribe\fR Name
X
X.SH DESCRIPTION
X
X	This is part of the Xmpb package.
X
X	The describe program is used to obtain some basic details about your opposition.  The describe program will tell you their name, ship, how much their ship is worth and how many kills they have.  This means you can describe either an opposition player, or NPC.
X
XTo use describe,
X
Xdescribe Name  -  Where Name is the name of the character to describe.
X
X
XIf this program doesn't work:
X
XUsage: describe Name
X
X
X- You have not given one parameter to the describe program
X
X
XNo such player
X
X- This is because the name given is not the same as the one you typed in when you play xmpb.  Watch out for extra spaces.  Or of course, the character might not exist.
X
X.SH SEE ALSO
X
Xxmpb(6),npcc(6),shop(6),retire(6)
END_OF_FILE
if test 850 -ne `wc -c <'describe.man'`; then
    echo shar: \"'describe.man'\" unpacked with wrong size!
fi
# end of 'describe.man'
fi
if test -f 'do_stars.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'do_stars.c'\"
else
echo shar: Extracting \"'do_stars.c'\" \(1989 characters\)
sed "s/^X//" >'do_stars.c' <<'END_OF_FILE'
X/* do_stars.c - ***  */
X
X#if !defined(lint)
Xstatic char sccs_id[] = "@(#)do_stars.c 1.9 93/04/22 XMPB";
X#endif
X#include "player.h"
X
Xdo_stars(w)
Xwinptr w;
X{
X	int i;
X
X	for(i=0;i<STARSPERPLANE;i++)
X	{
X		w->stars1[i].lx = w->stars1[i].x;
X		w->stars1[i].ly = w->stars1[i].y;
X		w->stars2[i].lx = w->stars2[i].x;
X		w->stars2[i].ly = w->stars2[i].y;
X
X		w->stars1[i].x -= w->xv/49152;
X		w->stars1[i].y += w->yv/49152;
X		w->stars1[i].x = (w->stars1[i].x+PLAYW)%PLAYW;
X		w->stars1[i].y = (w->stars1[i].y+PLAYH)%PLAYH;
X
X		w->stars2[i].x -= w->xv/32768;
X        w->stars2[i].y += w->yv/32768;
X		w->stars2[i].x = (w->stars2[i].x+PLAYW)%PLAYW;
X		w->stars2[i].y = (w->stars2[i].y+PLAYH)%PLAYH;
X	}
X}
X
Xdraw_stars(w)
Xwinptr w;
X{
X	int i;
X
X	for(i=0;i<STARSPERPLANE;i++)
X	{
X		XCopyPlane(w->theDisplay,(w->stars1[i].pm->spm),w->back_buffer,w->bbgc,0,0,w->stars1[i].pm->w,w->stars1[i].pm->h,w->stars1[i].x+OFFSET,w->stars1[i].y+OFFSET,1);
X		XCopyPlane(w->theDisplay,(w->stars2[i].pm->spm),w->back_buffer,w->bbgc,0,0,w->stars2[i].pm->w,w->stars2[i].pm->h,w->stars2[i].x+OFFSET,w->stars2[i].y+OFFSET,1);
X/*
X		XDrawPoint(w->theDisplay,w->back_buffer,w->bbgc,w->stars1[i].x,w->stars1[i].y);
X		XDrawPoint(w->theDisplay,w->back_buffer,w->bbgc,w->stars2[i].x,w->stars2[i].y);
X*/
X		XFlush(w->theDisplay);
X	}
X}
Xdraw_last_stars(w)
Xwinptr w;
X{
X	int i;
X
X	for(i=0;i<STARSPERPLANE;i++)
X	{
X		XCopyPlane(w->theDisplay,(w->stars1[i].pm->spm),w->theWindow,w->theGC,0,0,w->stars1[i].pm->w,w->stars1[i].pm->h,w->stars1[i].lx,w->stars1[i].ly,1);
X		XCopyPlane(w->theDisplay,(w->stars2[i].pm->spm),w->theWindow,w->theGC,0,0,w->stars2[i].pm->w,w->stars2[i].pm->h,w->stars2[i].lx,w->stars2[i].ly,1);
X	}
X}
X
X
Xinit_stars(w)
Xwinptr w;
X{
X	int i;
X	int c;
X
X	for(i=0;i<STARSPERPLANE;i++)
X	{
X		w->stars1[i].x = rand()%PLAYW;
X		w->stars1[i].y = rand()%PLAYH;
X		c = rand()%5;
X		c /=2;
X		w->stars1[i].pm = &(w->spm[c]);
X		w->stars2[i].x = rand()%PLAYW;
X		w->stars2[i].y = rand()%PLAYH;
X		c = rand()%5;
X		c /=2;
X		w->stars2[i].pm = &(w->spm[c]);
X	}
X}
END_OF_FILE
if test 1989 -ne `wc -c <'do_stars.c'`; then
    echo shar: \"'do_stars.c'\" unpacked with wrong size!
fi
# end of 'do_stars.c'
fi
if test -f 'harry.npc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'harry.npc'\"
else
echo shar: Extracting \"'harry.npc'\" \(2414 characters\)
sed "s/^X//" >'harry.npc' <<'END_OF_FILE'
XNPC
XName = Harry
XShip = Buster
XEnergyMax = 1000
XLShieldMax = 600
XRShieldMax = 600
XBShieldMax = 400
XSolar = 2
XShortRange = 1
XEngine = 3
XRepair = 2
XLongRange = 1
X
XWeapons 
XPulse
X
Xvar 
X	lastangle
X	lastdist
X	repairitem
Xend
X
XState start
X{
X	repairitem = 7;
X	set B2 = 1;
X
X	-> watch;
X}
X
XState watch
X{
X	if(LongState < 90 )	
X	{
X		if(Speed > 5) 
X			-> stop;
X		repairitem = LongRange;
X		repair();
X	}
X	set B1 = 0;
X	NumEnemies > 0 -> spotted;
X	repair();
X}
X
XState spotted
X{
X	set SelectEnemy = 0;
X	lastangle = EnemyAngle;
X	lastdist = EnemyDist;
X
X	-> fight;
X}
X
XProc gonna_hit
X{
X	if(XVel*XPos > 45000) return 1;
X	if(YVel*YPos > 45000) return 1;
X
X	return 0;
X}
X
XState fight
X{
X	var
X		d
X		a
X		m
X		i
X		acc
X		mina
X		maxa
X	end
X
X	!EnemyAvail -> watch;
X
X	m = EnemyDist/(50+VelAtAngle(Angle)) - 1;
X
X	if(Energy > 200 || gonna_hit())
X		set B3 = 1;
X	else
X		set B3 = 0;
X
X	a = AngleTo(EnemyXPos+m*EnemyXVel-m*XVel,EnemyYPos+m*EnemyYVel-m*YVel);
X
X	d = (Angle -a + 360)%360;
X
X	if(d < 170 || d > 190)
X		set TurnTo = a;
X
X	if(EnemyDist < 100)
X		acc = 30;
X	else
X	if(EnemyDist < 200)
X		acc = 6;
X	else
X	if(EnemyDist < 500)
X		acc = 3;
X	else
X		acc = 2;
X
X	maxa = (a+acc)%360;
X	mina = (a+360-acc)%360;
X
X	if(EnemyDist < 1000 && EnemyDist > 0 &&(Angle - 360 < maxa && Angle > mina))
X	{
X		set B1 = 1;
X	}
X	else
X		set B1 = 0;
X
X	set Balance = 1;
X	repair();
X
X	Speed > 90 -> stop;
X}
X
XState stop
X{
X	set B3 = 0;
X	set B1 = 0;
X	while(Angle != ((Direction + 180)%360))
X		set TurnTo = (Direction + 180)%360;
X	while(Speed > 4 && (EnemyDist > 500 || EnemyDist == 0))
X	{
X		set TurnTo = (Direction + 180)%360;
X		set B3 = 1;
X	}
X	set B3 = 0;
X	-> watch;
X}
X
XProc repair
X{
X	var 
X		r
X	end
X
X	if(repairitem == RepairItem && repairitem != 7) return;
X	r = RepairItem;
X	set RepairToggle = 1;
X	while(RepairItem != repairitem && RepairItem != r)
X		set RepairToggle = 1;
X	if(RepairItem == r) 
X	{
X		if(LongState < 100 && LongState != -1 && repairitem != LongRange)
X		{
X			repairitem = LongRange;
X			return;
X		}
X		if(SolarState < 100 && SolarState != -1 && repairitem != Solar)
X		{
X			repairitem = Solar;
X			return;
X		}
X		if(RepairState < 100 && RepairState != -1 && repairitem != Repair)
X		{
X			repairitem = Repair;
X			return;
X		}
X		if(EngineState < 100 && EngineState != -1 && repairitem != Engine)
X		{
X			repairitem = Engine;
X			return;
X		}
X		if(ShortState < 100 && ShortState != -1 && Energy > 300)
X		{
X			repairitem = Engine;
X			return;
X		}
X		repairitem = 7;
X	}
X	return;
X}
X
X	
XStart start
END_OF_FILE
if test 2414 -ne `wc -c <'harry.npc'`; then
    echo shar: \"'harry.npc'\" unpacked with wrong size!
fi
# end of 'harry.npc'
fi
if test -f 'john.npc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'john.npc'\"
else
echo shar: Extracting \"'john.npc'\" \(947 characters\)
sed "s/^X//" >'john.npc' <<'END_OF_FILE'
XNPC
XName = John
XShip = Walker
XEnergyMax = 1400
XLShieldMax = 900
XRShieldMax = 900
XBShieldMax = 700
XSolar = 5
XShortRange = 1
XEngine = 3
XRepair = 9
XLongRange = 9
XJammer = 9
XTC = 3
X
XWeapons
XMagneto
X
Xvar
Xend
X
XProc aim
X{
Xvar
X	aa1
X	aa2
X	num
Xend
X	num = NumEnemies;
X	set SelectEnemy = 0;
X
X	aa1 = aa2;
X	WaitFrame;
X	aa2 = EnemyAngle;
X	if(aa2 == -1)
X		aa2 = aa1;
X	else
X		set TurnTo = (EnemyAngle + (aa2 - aa1) * 4) % 360;
X
X	return;
X}
X
XProc slow
X{
Xvar
X	oldbs
Xend
X
X	set B1 = 0;
X	set TurnTo = (Direction + 180) % 360;
X	while(Speed > 5)
X	{
X		set TurnTo = (Direction + 180) % 360;
X	}
X	set B3 =0;
X	return;
X}
X
XState go_get_him
X{
X	Entry
X	{
X		aim();
X		set B3 = 1;
X	}
X
X	aim();
X	if(EnemyDist < 3000)
X	{
X		slow();
X		1 -> start;
X	}
X}
X
XState start
X{
X	set Jamming = 1;
X	NumEnemies;
X	set SelectEnemy = 0;
X	if(EnemyAvail)
X	{
X		if(EnemyDist > 3500)
X			1 -> go_get_him;
X		aim();
X		if(Energy < 100)
X			set B1 =0;
X		else
X		{
X			set Target = 1;
X			set B1 =1;
X		}
X	}
X}
X
XStart start
END_OF_FILE
if test 947 -ne `wc -c <'john.npc'`; then
    echo shar: \"'john.npc'\" unpacked with wrong size!
fi
# end of 'john.npc'
fi
if test -f 'ml2.npc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ml2.npc'\"
else
echo shar: Extracting \"'ml2.npc'\" \(1534 characters\)
sed "s/^X//" >'ml2.npc' <<'END_OF_FILE'
XNPC
XName = Rammer
XShip = BigNose
XEnergyMax = 10000
XLShieldMax = 800
XRShieldMax = 800
XBShieldMax = 600
XSolar = 9
XShortRange = 1
XEngine = 2
XRepair = 9
XLongRange = 4
XJammer = 5
XTC = none
X
XWeapons
XRail
XAtom
X
Xvar
X	num
X	last
Xend
X
XState close
X{
X	if ( ! EnemyAvail)
X		1 -> main;
X	set B1 =1;
X	if(EnemyAngle!=-1)
X	{
X		set TurnTo=AngleTo((EnemyXPos+11*EnemyXVel- 11*XVel),(EnemyYPos+11*EnemyYVel- 11*YVel));
X		last = EnemyAngle;
X	}
X	set Balance =1;
X	if (EnemyDist > 1500)
X		1 -> find;
X}
X
XState kill
X{
X	if( ! EnemyAvail)
X		1 ->main;
X	if(EnemyAngle!=-1)
X	{
X		last = EnemyAngle;
X		set TurnTo = AngleTo((EnemyXPos+9*EnemyXVel- 9*XVel),(EnemyYPos+9*EnemyYVel- 9*YVel));
X	}
X	else
X	{
X		set B3 =0;
X	}
X	if(EnemyDist < 1000)
X		1 -> close;
X	else
X		set B1 =0;
X	set Balance =1;
X	set RepairToggle =1;
X	if (EnemyDist > 3000)
X	{
X		set B1 =0;
X		1 -> find;
X	}	
X}
X
XState slowdown
X{
X	set TurnTo = (180 + Direction)%360;
X	1 -> slow;
X}
X
XState slow
X{
X	set B3 =1;
X	while (Speed > 20);
X	set B3 =0;
X	1 -> find;
X}
X	
XState find
X{
X	var
X		mod
X	end
X
X	set B3 =1;
X	set Balance =1;
X	set RepairToggle =1;
X	num = NumEnemies - 1;
X	set SelectEnemy = 0;
X	if (Speed > 50)
X	{
X		set B3 =0;
X	 	1 -> slowdown;
X	}
X	if(EnemyAngle!=-1)
X		last = EnemyAngle;
X	if (EnemyDist < 3500)
X	{
X		1 -> kill;
X	}
X	else
X	{
X		mod = EnemyDist/1000;
X		if(EnemyAvail)	
X		{
X			if(EnemyAngle!=-1)
X				set TurnTo=AngleTo((EnemyXPos+mod*EnemyXVel-mod*XVel),(EnemyYPos+mod*EnemyYVel-mod*YVel));
X			set B1 =0;
X		}
X	}
X}
X
XState main
X{
X	set B2 = 1;
X	num = NumEnemies - 1;
X	set SelectEnemy = 0;
X	1 -> find;
X}
X
XStart main
END_OF_FILE
if test 1534 -ne `wc -c <'ml2.npc'`; then
    echo shar: \"'ml2.npc'\" unpacked with wrong size!
fi
# end of 'ml2.npc'
fi
if test -f 'operators.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'operators.h'\"
else
echo shar: Extracting \"'operators.h'\" \(779 characters\)
sed "s/^X//" >'operators.h' <<'END_OF_FILE'
X#define NO_REGS 10
X
X#define ANDR 0
X#define LODI 1
X#define LODM 2
X#define STOM 3
X#define XORR 4
X#define LTER 5
X#define ORR  6
X#define JMPI 7
X#define EQR  8
X#define LTR  9
X#define GTR  10
X#define GTER 11
X#define NOTR 12
X#define JMPC 13
X#define INPR 14
X#define OUPR 15
X#define JSRC 16
X#define RET  17
X#define RETC 18
X#define ADDR 19
X#define SUBR 20
X#define MULR 21
X#define DIVR 22
X
X/* Input ports */
X#define SHIELD1PORT 1
X#define SHIELD2PORT 2
X#define SHIELD3PORT 3
X#define RADARMODEPORT 4
X
X/* Output ports */
X#define  BUTTON1PORT 1
X#define  BUTTON2PORT 2
X#define  BALANCEPORT 4
X#define  RADARPORT   5
X#define  STARTTURNLPORT 6
X
X
Xstruct ins
X{
X	int ins;
X	int o1,o2,o3;
X};
X
Xstruct comp
X{
X	int *data;
X	struct ins *text;
X	int pc;
X	int sp;
X	int stack[STACK_SIZE];
X	int regs[NO_REGS];
X};
END_OF_FILE
if test 779 -ne `wc -c <'operators.h'`; then
    echo shar: \"'operators.h'\" unpacked with wrong size!
fi
# end of 'operators.h'
fi
if test -f 'pcomp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pcomp.h'\"
else
echo shar: Extracting \"'pcomp.h'\" \(2576 characters\)
sed "s/^X//" >'pcomp.h' <<'END_OF_FILE'
X#ifndef PCOMP_H
X#define PCOMP_H
X
X#include "player.h"
X
X#define NO_REGS 10
X#define MAX_SYMB_LEN 30
X
X#define ANDR 0
X#define LODI 1
X#define LODM 2
X#define STOM 3
X#define XORR 4
X#define LTER 5
X#define ORR  6
X#define JMPI 7
X#define EQR  8
X#define LTR  9
X#define GTR  10
X#define GTER 11
X#define NOTR 12
X#define JMPC 13
X#define INPR 14
X#define OUPR 15
X#define JSRC 16
X#define RET  17
X#define RETC 18
X#define ADDR 19
X#define SUBR 20
X#define MULR 21
X#define DIVR 22
X#define MODR 23
X#define PUSHR 24
X#define POPR 25
X#define PUSHM 26
X#define POPM 27
X#define JSRI 28
X#define MOVR 29
X#define WAIT 30
X
X/* Input ports */
X#define SHIELD1PORT 1
X#define SHIELD2PORT 2
X#define SHIELD3PORT 3
X#define RADARMODEPORT 4
X#define XPOSPORT 5
X#define YPOSPORT 6
X#define XVELPORT 7
X#define YVELPORT 8
X#define ANGLEPORT 10
X#define SPEEDPORT 13
X#define ENEMYSPEEDPORT 14
X#define ENEMYDIRECTIONPORT 15
X#define ENEMYANGLEPORT 16
X#define TARGETSTATEPORT 17
X#define SOLARSTATEPORT 18
X#define JAMSTATEPORT 19
X#define SHORTSTATEPORT 20
X#define LONGSTATEPORT 21
X#define ENGINESTATEPORT 22
X#define REPAIRSTATEPORT 23
X#define CURRWEAPPORT 24
X#define ENEMYDISTPORT 25
X#define NUMENEMIESPORT 26
X#define ENERGYPORT 27
X#define ENEMYAVAILPORT 28
X#define DIRECTIONPORT 29
X#define DISTTOPORT 30
X#define ANGLETOPORT 31
X#define ENEMYXPOSPORT 32
X#define ENEMYYPOSPORT 33
X#define ENEMYXVELPORT 34
X#define ENEMYYVELPORT 35
X#define REPAIRITEMPORT 36
X#define VELATANGPORT 37
X#define CURRWEAPSTATEPORT 38
X
X/* Output ports */
X#define BUTTON1PORT 1 /* fire */
X#define BUTTON2PORT 2 /* Toggle weap */
X#define BUTTON3PORT 3 /* Thrust */
X#define BALANCEPORT 4
X#define RADARPORT   5
X#define SELECTEPORT 6
X#define CLOAKPORT 7
X#define GRABPORT 8
X#define SHIELDREGENPORT 9
X#define TURNLEFTPORT 10
X#define TURNRIGHTPORT 11
X#define QUITPORT 12
X#define TURNTOPORT 13
X#define TARGETPORT 14
X#define REPAIRTOGGLEPORT 15
X#define REPAIRSELITEMPORT 16
X
Xstruct header
X{
X	int majvers;
X	int minvers;
X	char Name[40];
X	char Ship[40];	
X	int start;
X	int no_vars;
X	int no_ins;
X	int does_have_weap[20];
X	int ls_max,rs_max,bs_max;
X	int energy_max;
X	int qual[10];
X	int num_played;
X	int cash_earned;	
X	int kills;
X};
X
Xstruct ins
X{
X	int ins;
X	int o1,o2,o3;
X};
X#define STACK_SIZE 1000
Xstruct comp
X{
X	int *data;
X	struct ins *text;
X	int pc;
X	int sp;
X	int fp;
X	int stack[STACK_SIZE];
X	int regs[NO_REGS];
X	int turnto;
X	int turnabs;
X	
X	int curr_enemy;
X	winptr ce;
X	int no_seen;
X
X	int can_see_enemy[MAXHOST];
X	int close[MAXHOST];
X	int closest[MAXHOST];
X	winptr cptr[MAXHOST];
X	char states[100][MAX_SYMB_LEN+1];
X	int no_states;
X	int stp[100];
X	char fname[100];
X};
X
X#endif
END_OF_FILE
if test 2576 -ne `wc -c <'pcomp.h'`; then
    echo shar: \"'pcomp.h'\" unpacked with wrong size!
fi
# end of 'pcomp.h'
fi
if test -f 'rad2.npc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rad2.npc'\"
else
echo shar: Extracting \"'rad2.npc'\" \(2199 characters\)
sed "s/^X//" >'rad2.npc' <<'END_OF_FILE'
XNPC
XName = rad2npc
XShip = Oldsmobile
XEnergyMax = 10000
XLShieldMax = 1200
XRShieldMax = 1200
XBShieldMax = 800
XSolar = 9
XShortRange = 1
XEngine = 2
XRepair = 9
XLongRange = 1
XJammer = 1
XTC = 1
X
XWeapons
XPulse
X
Xvar
X	u
X	d
X	l
X	r
X	angto
X	aa1
X	aa2
Xend
X
XProc dir
X{
X	if (r && u) 
X	{
X		angto=225;
X		set TurnTo = 225;
X		return;
X	}
X	if (r && d) 
X	{
X		angto=315;
X		set TurnTo = 315;
X		return;
X	}
X	if (l && u) 
X	{
X		angto=135;
X		set TurnTo = 135;
X		return;
X	}
X	if (l && d) 
X	{
X		angto=45;
X		set TurnTo = 45;
X		return;
X	}
X	if (r)
X	{
X		angto=270;
X		set TurnTo = 270;
X		return;
X	}
X	if (l)
X	{
X		angto=90;
X		set TurnTo = 90;
X		return;
X	}
X	if (d)
X	{
X		angto=0;
X		set TurnTo = 0;
X		return;
X	}
X	if (u)
X	{
X		angto=180;
X		set TurnTo = 180;
X		return;
X	}
X	return;
X}
X
X
XProc attack
X{
Xvar
X        num
X	a1
X	a2
Xend
X	set B1 = 1;
X	set B3 = 1;
X	a2 = EnemyAngle;
X	while(EnemyDist < 1000)
X	{
X		num=NumEnemies;
X		set SelectEnemy = 0;
X		set RepairToggle = 1;
X		set Balance = 1;
X
X		if(! EnemyAvail)
X		{
X			set B1 = 0;
X			set B3 = 0;
X			return;
X		}
X
X		a1 = a2;
X		a2 = EnemyAngle;
X		set TurnTo = EnemyAngle + (a2 - a1) * 4;
X	}
X	set B1 = 0;
X	set B3 = 0;
X	return;
X}
X
XProc aim
X{
Xvar
X	num
Xend
X	num = NumEnemies;
X	set SelectEnemy = 0;
X
X	aa1 = aa2;
X	aa2 = EnemyAngle;
X	set TurnTo = EnemyAngle + (aa2 - aa1) * 4;
X
X	if(EnemyDist < 1000) 
X		attack();
X	return;
X}
X
X
XProc thrust
X{
Xvar
X	num
X	i
X	thrustTime
Xend
X	num = NumEnemies;
X	set SelectEnemy = 0;
X	set B3 = 1;
X	aa2 = EnemyAngle;
X	if(EnemyDist < 2000)
X		thrustTime = 10;
X	else
X		thrustTime = EnemyDist / 600;
X	i = 0;
X	while (i < thrustTime)
X	{
X		aim();
X		i = i + 1;
X	}
X	set B3 = 0;
X	return;
X}
X
X
XProc drift
X{
Xvar
X	i
Xend
X	set B3 = 0;
X	i = 0;
X	while (i < 4)
X	{
X		aim();
X		i = i + 1;
X	}
X	return;
X}
X
X
XProc seek
X{
X	if(NumEnemies > 0)
X		thrust();
X	drift();
X	return;
X}
X
X
XState loop
X{
X	r = 0;
X	l = 0;
X	u = 0;
X	d = 0;
X
X	set RepairToggle = 1;
X	set Balance= 1;
X
X	if (XPos*XVel > 50000 && XVel > 0) r = 1;
X	if (XPos*XVel > 50000 && XVel < 0) l = 1;
X	if (YPos*YVel > 50000 && YVel > 0) u = 1;
X	if (YPos*YVel > 50000 && YVel < 0) d = 1;
X
X	if (r || l || u || d)
X	{
X		dir();
X		set B1 =0;
X		if (angto == Angle)
X		{
X			set B3 = 1;
X		}
X	}
X	else
X		seek();
X}
X
XState main
X{
X	set B2 = 1;
X	angto = -500;
X	1 -> loop;
X}
X
XStart main
END_OF_FILE
if test 2199 -ne `wc -c <'rad2.npc'`; then
    echo shar: \"'rad2.npc'\" unpacked with wrong size!
fi
# end of 'rad2.npc'
fi
if test -f 'rad3.npc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rad3.npc'\"
else
echo shar: Extracting \"'rad3.npc'\" \(2209 characters\)
sed "s/^X//" >'rad3.npc' <<'END_OF_FILE'
XNPC
XName = rad3npc
XShip = Oldsmobile
XEnergyMax = 10000
XLShieldMax = 1200
XRShieldMax = 1200
XBShieldMax = 800
XSolar = 9
XShortRange = 1
XEngine = 2
XRepair = 9
XLongRange = 1
XJammer = 1
XTC = 1
X
XWeapons
XPulse
XBomb
XRail
X
Xvar
X	u
X	d
X	l
X	r
X	angto
X	aa1
X	aa2
Xend
X
XProc dir
X{
X	if (r && u) 
X	{
X		angto=225;
X		set TurnTo = 225;
X		return;
X	}
X	if (r && d) 
X	{
X		angto=315;
X		set TurnTo = 315;
X		return;
X	}
X	if (l && u) 
X	{
X		angto=135;
X		set TurnTo = 135;
X		return;
X	}
X	if (l && d) 
X	{
X		angto=45;
X		set TurnTo = 45;
X		return;
X	}
X	if (r)
X	{
X		angto=270;
X		set TurnTo = 270;
X		return;
X	}
X	if (l)
X	{
X		angto=90;
X		set TurnTo = 90;
X		return;
X	}
X	if (d)
X	{
X		angto=0;
X		set TurnTo = 0;
X		return;
X	}
X	if (u)
X	{
X		angto=180;
X		set TurnTo = 180;
X		return;
X	}
X	return;
X}
X
X
XProc attack
X{
Xvar
X        num
X	a1
X	a2
Xend
X	set B1 = 1;
X	set B3 = 1;
X	a2 = EnemyAngle;
X	while(EnemyDist < 1000)
X	{
X		num=NumEnemies;
X		set SelectEnemy = 0;
X		set RepairToggle = 1;
X		set Balance = 1;
X
X		if(! EnemyAvail)
X		{
X			set B1 = 0;
X			set B3 = 0;
X			return;
X		}
X
X		a1 = a2;
X		a2 = EnemyAngle;
X		set TurnTo = EnemyAngle + (a2 - a1) * 4;
X	}
X	set B1 = 0;
X	set B3 = 0;
X	return;
X}
X
XProc aim
X{
Xvar
X	num
Xend
X	num = NumEnemies;
X	set SelectEnemy = 0;
X
X	aa1 = aa2;
X	aa2 = EnemyAngle;
X	set TurnTo = EnemyAngle + (aa2 - aa1) * 4;
X
X	if(EnemyDist < 1000) 
X		attack();
X	return;
X}
X
X
XProc thrust
X{
Xvar
X	num
X	i
X	thrustTime
Xend
X	num = NumEnemies;
X	set SelectEnemy = 0;
X	set B3 = 1;
X	aa2 = EnemyAngle;
X	if(EnemyDist < 2000)
X		thrustTime = 10;
X	else
X		thrustTime = EnemyDist / 600;
X	i = 0;
X	while (i < thrustTime)
X	{
X		aim();
X		i = i + 1;
X	}
X	set B3 = 0;
X	return;
X}
X
X
XProc drift
X{
Xvar
X	i
Xend
X	set B3 = 0;
X	i = 0;
X	while (i < 4)
X	{
X		aim();
X		i = i + 1;
X	}
X	return;
X}
X
X
XProc seek
X{
X	if(NumEnemies > 0)
X		thrust();
X	drift();
X	return;
X}
X
X
XState loop
X{
X	r = 0;
X	l = 0;
X	u = 0;
X	d = 0;
X
X	set RepairToggle = 1;
X	set Balance= 1;
X
X	if (XPos*XVel > 50000 && XVel > 0) r = 1;
X	if (XPos*XVel > 50000 && XVel < 0) l = 1;
X	if (YPos*YVel > 50000 && YVel > 0) u = 1;
X	if (YPos*YVel > 50000 && YVel < 0) d = 1;
X
X	if (r || l || u || d)
X	{
X		dir();
X		set B1 =0;
X		if (angto == Angle)
X		{
X			set B3 = 1;
X		}
X	}
X	else
X		seek();
X}
X
XState main
X{
X	set B2 = 1;
X	angto = -500;
X	1 -> loop;
X}
X
XStart main
END_OF_FILE
if test 2209 -ne `wc -c <'rad3.npc'`; then
    echo shar: \"'rad3.npc'\" unpacked with wrong size!
fi
# end of 'rad3.npc'
fi
if test -f 'read_ship.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'read_ship.c'\"
else
echo shar: Extracting \"'read_ship.c'\" \(1533 characters\)
sed "s/^X//" >'read_ship.c' <<'END_OF_FILE'
X/* read_ship.c - *** Routines for reading in bitmaps */
X
X#if !defined(lint)
Xstatic char sccs_id[] = "@(#)read_ship.c 1.6 92/11/17 XMPB";
X#endif
X#include "player.h"
X
Xextern int euid;
Xextern int installed;
X
X/*
X* Read the stars bitmaps for the player structure
X*/
Xread_stars(w)
Xwinptr w;
X{
X    int xh,yh;
X    
X    char *bitmapfile;
X    char *bitmapfilestartptr;
X
Xseteuid(euid);
X    /* Allocate a string to hold the bitmapfile's directory
X       and the filename. "saturn1" is the longest. */
X    if(installed)
X	{
X    	bitmapfile = (char *) malloc(strlen(BITMAPDIR)+strlen("saturn1")+1);
X		strcpy(bitmapfile,BITMAPDIR);
X	}
X	else
X	{
X    	bitmapfile = (char *) malloc(10+strlen("saturn1")+1);
X		strcpy(bitmapfile,"./bitmaps/");
X	}
X    
X    /* Set a pointer to point into the start of the string where
X       the filename will be added. Each time the filename will
X       be overwritten with a new one. */
X    if(installed)
X		bitmapfilestartptr = bitmapfile + strlen(BITMAPDIR);
X    else
X		bitmapfilestartptr = bitmapfile + 10;
X
X    strcpy(bitmapfilestartptr,"star1");
X    XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile,
X		    &(w->spm[0].w),&(w->spm[0].h),&(w->spm[0].spm),&xh,&yh);
X
X    strcpy(bitmapfilestartptr,"star2");
X    XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile,
X		    &(w->spm[1].w),&(w->spm[1].h),&(w->spm[1].spm),&xh,&yh);
X
X    strcpy(bitmapfilestartptr,"saturn1");
X    XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile,
X		    &(w->spm[2].w),&(w->spm[2].h),&(w->spm[2].spm),&xh,&yh);
Xseteuid(getuid());
X}
END_OF_FILE
if test 1533 -ne `wc -c <'read_ship.c'`; then
    echo shar: \"'read_ship.c'\" unpacked with wrong size!
fi
# end of 'read_ship.c'
fi
if test -f 'retire.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'retire.c'\"
else
echo shar: Extracting \"'retire.c'\" \(1766 characters\)
sed "s/^X//" >'retire.c' <<'END_OF_FILE'
X#include "player.h"
X#include "save.h"
X
Xint euid;
Xextern  save default_save; 
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	save *dude, temp;
X	int no;
X	char buf[160];
X	char buf2[160];
X	char pwd[MAX_NAME_SIZE];
X	FILE *fp, *fp2;
X	int dude_written;
X
X	euid = geteuid();
X	seteuid(getuid());
X
X	no =0;
X	if(argc!=2) 
X	{
X		printf("Usage: %s Name\n", argv[0]);
X		exit(1);
X	}
X	dude=load_dude(argv[1]);
X	if(dude==&default_save)
X	{
X		fprintf(stderr,"No such player\n");
X		exit(0);
X	}
X	if(getuid() != euid)
X	{
XKLUDGE:
X	printf("\nType in your passord: ");
X	gets(pwd);
X	if(strcmp(dude->password, pwd))
X		goto KLUDGE;
X	}
X	/*
X	** Save in hall of fame 
X	*/
X	
X	buf[0]=0;
X	buf2[0]=0;
X	strcpy(buf, SAVEDIR);
X	strcat(buf, "hall.of.fame");
X	strcpy(buf2, buf);
X	strcat(buf2, "2");
Xseteuid(euid);
X	fp=fopen(buf,"rb");
Xseteuid(getuid());
X	if(!fp)
X	{
Xseteuid(euid);
X		fp=fopen(buf,"wb");
Xseteuid(getuid());
X		if(!fp)
X		{
X			perror("Cannot create hall of fame\n");
X			exit(0);
X		}
X		fwrite(dude, sizeof(save), 1, fp);
X		fclose(fp);
X		exit(0);
X	}
X
X	dude_written=0;
Xseteuid(euid);
X	fp2=fopen(buf2,"wb");
Xseteuid(getuid());
X	if(!fp2)
X    {
X       perror("Cannot create hall of fame\n");
X       exit(0);
X    }
X	while(no++,fread(&temp, sizeof(save), 1, fp))
X	{
X		if(!dude_written && ((dude->kills == temp.kills && dude->credits > temp.credits) || (dude->kills > temp.kills)))
X		{
X			if(no <= 20-dude_written)
X				fwrite(dude, sizeof(save), 1, fp2);
X			dude_written=1;
X		}
X		if(no <= 20-dude_written)
X		fwrite(&temp, sizeof(save), 1, fp2);
X	}
X	if(!dude_written && no <= 20)
X		fwrite(dude, sizeof(save), 1, fp2);	
X	fclose(fp);
X	fclose(fp2);
X	unlink(buf);
X	rename(buf2, buf);
X	buf[0]=0;
X	strcpy(buf, SAVEDIR);
X	strcat(buf, argv[1]);
X	strcat(buf, ".xms");
Xseteuid(euid);
X	unlink(buf);
Xseteuid(getuid());
X}
END_OF_FILE
if test 1766 -ne `wc -c <'retire.c'`; then
    echo shar: \"'retire.c'\" unpacked with wrong size!
fi
# end of 'retire.c'
fi
if test -f 'retire.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'retire.man'\"
else
echo shar: Extracting \"'retire.man'\" \(761 characters\)
sed "s/^X//" >'retire.man' <<'END_OF_FILE'
X.TH Xmpb 6
X.SH NAME
Xretire - retire a character
X.SH SYPNOSIS
X.ta 4n
X\fIretire\fR Name
X
X.SH DESCRIPTION
X
X	This is part of the Xmpb package.
X
X	The retire program is used to retire your character when you just don't have enough cash left to fix the ship up.  When you retire a character, then they will be put into the hall of fame.
X
XTo use retire,
X
Xretire Name   - Where Name is the name of the character to retire.
X
X
XIf this program doesn't work:
X
XUsage: retire Name
X
X
X- You have not given one parameter to the retire program
X
X
XNo such player
X
X- This is because the name given is not the same as the one you typed in when you play xmpb.  Watch out for extra spaces.  Or of course, the character might not exist.
X
X.SH SEE ALSO
Xxmpb(6),npcc(6),shop(6),describe(6)
END_OF_FILE
if test 761 -ne `wc -c <'retire.man'`; then
    echo shar: \"'retire.man'\" unpacked with wrong size!
fi
# end of 'retire.man'
fi
if test -f 'save.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'save.h'\"
else
echo shar: Extracting \"'save.h'\" \(484 characters\)
sed "s/^X//" >'save.h' <<'END_OF_FILE'
X/* save.h - *** Structure for saving */
X
X/*   @(#)save.h 1.10 93/03/26 XMPB  */
X
X#define MAX_WEAPONS 20
X
Xstruct save_s
X{
X	char Name[MAX_NAME_SIZE],Ship[MAX_NAME_SIZE];
X	char password[10];
X	int energy_max;
X	int credits;   /* cash on hand and what earned */
X	int ls_max,rs_max,bs_max;
X	int quality[NUM_ITEMS+1];
X	int state[NUM_ITEMS+1];
X	int does_have_weap[MAX_WEAPONS];
X	int weap_on_status[MAX_WEAPONS];
X	int kills;
X	int ship_value;
X};
X
Xtypedef struct save_s save;
X
Xsave *load_dude();
END_OF_FILE
if test 484 -ne `wc -c <'save.h'`; then
    echo shar: \"'save.h'\" unpacked with wrong size!
fi
# end of 'save.h'
fi
if test -f 'save_load.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'save_load.c'\"
else
echo shar: Extracting \"'save_load.c'\" \(822 characters\)
sed "s/^X//" >'save_load.c' <<'END_OF_FILE'
X#include "player.h"
X#include "save.h"
X#include "save.c"
X
Xextern int euid;
Xchar fn[100];
X
Xsave *load_dude(name)
Xchar *name;
X{
X    int i;
X    FILE *fp;
X    save *temp;
X
X    strcpy(fn,SAVEDIR);
X    strcat(fn, name);
X    strcat(fn, ".xms");
X
Xseteuid(euid);
X    fp=fopen(fn, "rb");
Xseteuid(getuid());
X    if(!fp) {
X        return &(default_save);
X    }
X    temp=(save *) malloc (sizeof(save));
X    if(!temp) 
X	{
X        fprintf(stderr,"Not enough memory");
X		exit(1);
X	}
X    fread(temp, sizeof(save), 1, fp);
X    fclose(fp);
X    return temp;
X}
X
Xsave_dude(s)
Xsave *s;
X{
X	FILE *fp;
X
X	fn[0]=0;
X    strcpy(fn,SAVEDIR);
X    strcat(fn, s->Name);
X    strcat(fn, ".xms");
Xseteuid(euid);
X	fp=fopen(fn, "wb");
Xseteuid(getuid());
X	if(!fp) {
X		perror("Cannot save file");
X		exit(1);
X	}
X 	fwrite(s, sizeof(save), 1, fp);
X    fclose(fp);
X
X}
END_OF_FILE
if test 822 -ne `wc -c <'save_load.c'`; then
    echo shar: \"'save_load.c'\" unpacked with wrong size!
fi
# end of 'save_load.c'
fi
if test -f 'shop.icon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'shop.icon'\"
else
echo shar: Extracting \"'shop.icon'\" \(2190 characters\)
sed "s/^X//" >'shop.icon' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0x2000,	0x0000,	0x0000,	0x0000,
X	0x0200,	0x0000,	0x0000,	0x0000,
X	0x8000,	0x0000,	0x0000,	0x0000,
X	0x0440,	0x0000,	0x0000,	0x0000,
X	0x4008,	0x0000,	0x0000,	0x0000,
X	0x0120,	0x0000,	0x0000,	0x0000,
X	0x0800,	0x0000,	0x0000,	0x0000,
X	0x0008,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0004,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0004,	0x0000,	0x0000,	0x0000,
X	0x0002,	0x0001,	0x0000,	0x0000,
X	0x0004,	0x0006,	0x8000,	0x0000,
X	0x0002,	0x0008,	0x6000,	0x0000,
X	0x0004,	0x0010,	0x1000,	0x0000,
X	0x0002,	0x0060,	0x0800,	0x0000,
X	0x0000,	0x0080,	0x0600,	0x0000,
X	0x0007,	0x8100,	0x0100,	0x0000,
X	0x0004,	0x8600,	0x0080,	0x0000,
X	0x0004,	0x8800,	0x0040,	0x0000,
X	0x0004,	0x9000,	0x0030,	0x0000,
X	0x0004,	0xE000,	0x0008,	0x0000,
X	0x0004,	0x8000,	0x0004,	0x0000,
X	0x0005,	0x0000,	0x0003,	0x0000,
X	0x0006,	0x0000,	0x0000,	0x8000,
X	0x0018,	0x0000,	0x0000,	0x4000,
X	0x0020,	0x0000,	0x0000,	0x3000,
X	0x00C0,	0x0000,	0x0000,	0x0800,
X	0x01FF,	0xFFFF,	0xFFFF,	0xFE00,
X	0x0080,	0x0000,	0x0000,	0x0400,
X	0x0080,	0x0000,	0x0000,	0x0400,
X	0x0080,	0x0000,	0x0000,	0x0400,
X	0x009F,	0xFC00,	0x00FF,	0xE400,
X	0x0090,	0x8400,	0x0084,	0x2400,
X	0x0090,	0x8400,	0x0084,	0x2400,
X	0x0090,	0x8400,	0x0084,	0x2400,
X	0x0090,	0x8400,	0x0084,	0x2400,
X	0x009F,	0xFC00,	0x00FF,	0xE400,
X	0x0090,	0x8400,	0x0084,	0x2400,
X	0x0090,	0x8400,	0x0084,	0x2400,
X	0x0090,	0x8400,	0x0084,	0x2400,
X	0x0090,	0x8400,	0x0084,	0x2400,
X	0x009F,	0xFC00,	0x00FF,	0xE400,
X	0x0080,	0x0000,	0x0000,	0x0400,
X	0x0080,	0x00FF,	0xFC00,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x0080,	0x0080,	0x6400,	0x0400,
X	0x0080,	0x0080,	0x6400,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x0080,	0x0080,	0x0400,	0x0400,
X	0x00FF,	0xFFFF,	0xFFFF,	0xFC00,
END_OF_FILE
if test 2190 -ne `wc -c <'shop.icon'`; then
    echo shar: \"'shop.icon'\" unpacked with wrong size!
fi
# end of 'shop.icon'
fi
if test -f 'shop_ui.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'shop_ui.h'\"
else
echo shar: Extracting \"'shop_ui.h'\" \(1368 characters\)
sed "s/^X//" >'shop_ui.h' <<'END_OF_FILE'
X#ifndef	shop_HEADER
X#define	shop_HEADER
X
Xextern Attr_attribute	INSTANCE;
X
Xtypedef struct {
X	Xv_opaque	Shop;
X	Xv_opaque	controls1;
X	Xv_opaque	MenuButton;
X	Xv_opaque	canvas;
X	Xv_opaque	controls2;
X	Xv_opaque	BuyButton;
X	Xv_opaque	SellButton;
X	Xv_opaque	RepairButton;
X	Xv_opaque	ShowButton;
X    Xv_opaque   InShipLabel;
X	Xv_opaque   InShopLabel;
X} MainWinObjs;
X
Xtypedef struct {
X	Xv_opaque	pwdWin;
X	Xv_opaque	controls4;
X	Xv_opaque	pwdText;
X} pwdWinObjs;
X
Xextern pwdWinObjs	*pwdWinObjsInit();
X
Xextern Xv_opaque	pwdWin_create();
Xextern Xv_opaque	Controls4_create();
Xextern Xv_opaque	pwdWinPwdText_create();
X
Xextern MainWinObjs	*MainWinObjsInit();
X
Xextern Xv_opaque	MainWin_create();
Xextern Xv_opaque	Controls1_create();
Xextern Xv_opaque	MenuButton_create();
Xextern Xv_opaque	Canvas_create();
Xextern Xv_opaque	Controls2_create();
Xextern Xv_opaque	BuyButton_create();
Xextern Xv_opaque	SellButton_create();
Xextern Xv_opaque	RepairButton_create();
Xextern Xv_opaque	ShowButton_create();
Xextern Xv_opaque    InShipLabel_create();
Xextern Xv_opaque    InShopLabel_create();
X
X
Xstruct menu_p {
X	char menu_name[40]; 
X	char menu_item[40][40];
X	Menu MenuPointer;
X	char descr[40][480];
X	int	 cost[40];
X	struct menu_p *next;
X};
X
Xstruct menu_p *head, *curr;
X
Xint lastButtonPos;
XDisplay *disp;
XGC othergc,gc;
XXv_window win;
Xint pos, ypos;
XXv_opaque base, pwd;
X
XMainWinObjs *MainWin;
X
X#endif
END_OF_FILE
if test 1368 -ne `wc -c <'shop_ui.h'`; then
    echo shar: \"'shop_ui.h'\" unpacked with wrong size!
fi
# end of 'shop_ui.h'
fi
if test -f 'sin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sin.c'\"
else
echo shar: Extracting \"'sin.c'\" \(332 characters\)
sed "s/^X//" >'sin.c' <<'END_OF_FILE'
X/* %M% - ***  */
X
Xstatic char sccs_id[] = "%Z%%M% %I% %E% XMPB";
X#include <math.h>
X
Xmain()
X{
X
X	int i;
Xprintf("int mysintab[] = {\n");
X	for(i=0;i<361;i++)
X	{
X		double a;
X
X		a = (double)i/180.0*M_PI;
X		printf("%d",(int)(32768.0*sin(a)));
X		if(i != 360) printf(",");
X		if(i%10 == 0) printf("\n");	
X		
X	}
Xprintf("};\n");
X	return 0;
X}
X	
END_OF_FILE
if test 332 -ne `wc -c <'sin.c'`; then
    echo shar: \"'sin.c'\" unpacked with wrong size!
fi
# end of 'sin.c'
fi
if test -f 'sintab.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sintab.c'\"
else
echo shar: Extracting \"'sintab.c'\" \(2319 characters\)
sed "s/^X//" >'sintab.c' <<'END_OF_FILE'
Xint mysintab[] = {
X0,
X571,1143,1714,2285,2855,3425,3993,4560,5126,5690,
X6252,6812,7371,7927,8480,9032,9580,10125,10668,11207,
X11743,12275,12803,13327,13848,14364,14876,15383,15886,16383,
X16876,17364,17846,18323,18794,19260,19720,20173,20621,21062,
X21497,21926,22347,22762,23170,23571,23964,24351,24730,25101,
X25465,25821,26169,26509,26841,27165,27481,27788,28087,28377,
X28659,28932,29196,29451,29697,29935,30163,30381,30591,30791,
X30982,31164,31336,31498,31651,31794,31928,32051,32165,32270,
X32364,32449,32523,32588,32643,32688,32723,32748,32763,32768,
X32763,32748,32723,32688,32643,32588,32523,32449,32364,32270,
X32165,32051,31928,31794,31651,31498,31336,31164,30982,30791,
X30591,30381,30163,29935,29697,29451,29196,28932,28659,28377,
X28087,27788,27481,27165,26841,26509,26169,25821,25465,25101,
X24730,24351,23964,23571,23170,22762,22347,21926,21497,21062,
X20621,20173,19720,19260,18794,18323,17846,17364,16876,16383,
X15886,15383,14876,14364,13848,13327,12803,12275,11743,11207,
X10668,10125,9580,9032,8480,7927,7371,6812,6252,5690,
X5126,4560,3993,3425,2855,2285,1714,1143,571,0,
X-571,-1143,-1714,-2285,-2855,-3425,-3993,-4560,-5126,-5690,
X-6252,-6812,-7371,-7927,-8480,-9032,-9580,-10125,-10668,-11207,
X-11743,-12275,-12803,-13327,-13848,-14364,-14876,-15383,-15886,-16384,
X-16876,-17364,-17846,-18323,-18794,-19260,-19720,-20173,-20621,-21062,
X-21497,-21926,-22347,-22762,-23170,-23571,-23964,-24351,-24730,-25101,
X-25465,-25821,-26169,-26509,-26841,-27165,-27481,-27788,-28087,-28377,
X-28659,-28932,-29196,-29451,-29697,-29935,-30163,-30381,-30591,-30791,
X-30982,-31164,-31336,-31498,-31651,-31794,-31928,-32051,-32165,-32270,
X-32364,-32449,-32523,-32588,-32643,-32688,-32723,-32748,-32763,-32768,
X-32763,-32748,-32723,-32688,-32643,-32588,-32523,-32449,-32364,-32270,
X-32165,-32051,-31928,-31794,-31651,-31498,-31336,-31164,-30982,-30791,
X-30591,-30381,-30163,-29935,-29697,-29451,-29196,-28932,-28659,-28377,
X-28087,-27788,-27481,-27165,-26841,-26509,-26169,-25821,-25465,-25101,
X-24730,-24351,-23964,-23571,-23170,-22762,-22347,-21926,-21497,-21062,
X-20621,-20173,-19720,-19260,-18794,-18323,-17846,-17364,-16876,-16384,
X-15886,-15383,-14876,-14364,-13848,-13327,-12803,-12275,-11743,-11207,
X-10668,-10125,-9580,-9032,-8480,-7927,-7371,-6812,-6252,-5690,
X-5126,-4560,-3993,-3425,-2855,-2285,-1714,-1143,-571,0
X};
END_OF_FILE
if test 2319 -ne `wc -c <'sintab.c'`; then
    echo shar: \"'sintab.c'\" unpacked with wrong size!
fi
# end of 'sintab.c'
fi
if test -f 'thrust.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'thrust.c'\"
else
echo shar: Extracting \"'thrust.c'\" \(1070 characters\)
sed "s/^X//" >'thrust.c' <<'END_OF_FILE'
X/* thrust.c - *** Routines to incorporate thrusting */
X
Xstatic char sccs_id[] = "@(#)thrust.c 1.11 92/11/24 XMPB";
X
X#include <math.h>
X#include "player.h"
X
X
X/*
X*	Do we have enough energy to thrust
X*/
Xenough_e_to_thr(w)
Xwinptr w;
X{
X	if(w->energy_curr > THRUST_E_USE)  /* defined in player.h */
X		return 1;
X	return 0;
X}
X
X/*
X*	Decide which pictures to show when thrusting
X*/
Xupdate_thrust(w)
Xwinptr w;
X{
X	/*
X	*	If we can't thrust, don't
X	*/
X	if(!enough_e_to_thr(w) || w->state[ENGINE] < 1)
X		w->t2 = 0;
X
X	/*
X	*	If the keys to turn are off (i.e. not turning)
X	*/
X	if(w->tr == 0  && w->tl == 0)
X	{
X		if(w->t2)	/* are we thrusting	*/
X		{
X			w->t1 = 1;	/* Sides on */
X			w->t3 = 1;
X		}
X		else
X		{
X			w->t1 = 0;	/* Sides off */
X			w->t3 = 0;
X		}
X	}
X	else if(w->tl) 	/* Turning left */
X    {
X        if(w->t2)
X        {
X            w->t1 = 0;
X			w->t3 = 1;
X        }
X        else
X        {
X            w->t3 = 1;
X			w->t1 = 0;
X        }
X    }
X	else if(w->tr) 	/* Turning right */
X	{
X		if(w->t2)
X		{
X			w->t3 = 0;
X			w->t1 = 1;
X		}
X		else
X		{
X			w->t1 = 1;
X			w->t3 = 0;
X		}
X	}
X}
X
END_OF_FILE
if test 1070 -ne `wc -c <'thrust.c'`; then
    echo shar: \"'thrust.c'\" unpacked with wrong size!
fi
# end of 'thrust.c'
fi
if test -f 'ud_win.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ud_win.c'\"
else
echo shar: Extracting \"'ud_win.c'\" \(2411 characters\)
sed "s/^X//" >'ud_win.c' <<'END_OF_FILE'
X/* ud_win.c - *** Handle button presses etc. */
X
Xstatic char sccs_id[] = "@(#)ud_win.c 1.17 92/11/24 XMPB";
X
X#include "player.h"
X
Xextern int weap_energy[NO_WEAPONS];		/* what energy does the weapon use */
Xextern int load_rate[NO_WEAPONS];		/* how fast does it load */
Xextern winptr first_win;
X
X/*
X*	Do all of the firing, changing weapons, and thrusting controlled 
X*	by the mouse for all of the players
X*/
Xupdate_win_input()
X{
X	winptr t;
X
X	t = first_win;
X	while(t)
X	{
X		/*
X		*	Can't do anything if you're dead!
X		*/
X		if(t->exploding)
X			goto kludge2;
X
X		/*
X		*	They want to thrust
X		*/
X		if(t->b3)
X		{
X			t->t2 = 1;
X		}
X		else
X		{
X			t->t2 = 0;
X		}
X
X		/* 
X		*	continue loading all weapons  
X		*/
X		{
X			int i;
X		
X			for(i=0;i<NO_WEAPONS;i++)
X			{
X				if(t->load_status[i] > 0) 
X					t->load_status[i]--;
X			}
X		}
X
X		if(t->b1 && t->b2 && t->curr_weap != -1)
X		{
X			int i = t->curr_weap;
X			t->curr_weap++;
X			t->curr_weap %= NO_WEAPONS;
X
X			/*
X			*	During a "nailstorm", go to the next ready weapon
X			*/
X			while((!t->does_have_weap[t->curr_weap] || t->load_status[t->curr_weap] != 0 || t->weap_on_status[t->curr_weap] == 0) && i != t->curr_weap)
X			{
X				t->curr_weap++;
X				t->curr_weap %= NO_WEAPONS;
X			}
X			t->changed_last_frame = 1;
X		}
X		else	
X		/*
X		*	Change weapons only if we didn't change last frame
X		*/	
X		if(t->b2 && !(t->changed_last_frame) && t->curr_weap != -1)
X		{
X			int cw,noweap=0;
X			/* 
X			*	Go to the next weapon
X			*/
X			cw = t->curr_weap%NO_WEAPONS;
X			
X			t->curr_weap++;
X			t->curr_weap %= NO_WEAPONS;
X	
X			/*
X			*	Make sure the ship has the weapon
X			*/
X			while(!t->does_have_weap[t->curr_weap])
X			{
X				t->curr_weap++;
X				t->curr_weap %= NO_WEAPONS;
X				if(t->curr_weap == cw)
X				{
X					if(!t->does_have_weap[t->curr_weap]) noweap = 1;
X					break;
X				}
X			}
X			if(noweap)
X				t->curr_weap = -1;
X
X			/*
X			*	Don't allow a weapon change next frame
X			*/
X			t->changed_last_frame = 1;
X		}
X		else 
X        {
X			/*
X			*	Ok they can change next frame
X			*/
X            t->changed_last_frame = 0;
X        }
X
X		
X		/*
X		*	Fire weapons if we have enough energy and the weapon is loaded
X		*	and on
X		*/	
X		if(t->b1 && (t->load_status[t->curr_weap] == 0) && 
X			(t->energy_curr > weap_energy[t->curr_weap]) && 
X			(t->weap_on_status[t->curr_weap]) && t->curr_weap != -1)
X		{
X			fire_weapon(t);
X		}
X		
X		/*
X		*	Do the pics for thrust
X		*/
X		update_thrust(t);
Xkludge2:
X		t = t->next;
X	}
X}
END_OF_FILE
if test 2411 -ne `wc -c <'ud_win.c'`; then
    echo shar: \"'ud_win.c'\" unpacked with wrong size!
fi
# end of 'ud_win.c'
fi
if test -f 'weapon.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'weapon.h'\"
else
echo shar: Extracting \"'weapon.h'\" \(964 characters\)
sed "s/^X//" >'weapon.h' <<'END_OF_FILE'
Xchar weap_file_names[NO_WEAPONS][30] = {"pulse","bomb","seeker","","rail","massdrive", "mine","","atom","magneto","hvypulse","", "dunno", "dunno2",""};
Xchar weap_names[NO_WEAPONS][20] = 
X   {"Pulse Rifle    ",
X	"Energy Bomb    ",
X	"Seeker Bomb(T) ",
X	"Light Laser    ",
X	"Rail Gun       ",
X	"Mass Driver    ", 
X	"Mine           ",
X	"Heavy Laser    ",
X	"Atomic Spray   ",
X	"Magneto Disc(T)",
X	"Hvy Pulse Rifle",
X	"Black Death    ",
X	"Clover Launch  ",
X	"Vortex Gun     ",
X	"Missile        "};
X
Xint weap_maxlife[NO_WEAPONS] = {20,15,80,0,80,40,5000,0,30,100,30,10,35,60,100};
Xint weap_velocit[NO_WEAPONS] = {50,30,20,0,50,20,-5,0,40,40,55,40,60,50,80};
Xint weap_energy[NO_WEAPONS]  = {10,50,100,50,70,30,180,80,25,130,20,400,30,50,70};
Xint weap_damage[NO_WEAPONS] = {10,45,80,40,50,25,180,35,2,60,20,400,30,45,55};
Xint load_rate[NO_WEAPONS] = {1,3,10,4,3,2,8,9,1,18,2,400,3,4,3};
Xint weap_damage_prob[NO_WEAPONS] = {30,60,10,50,160,40,50,65,20,50,25,200,45,40,120};
END_OF_FILE
if test 964 -ne `wc -c <'weapon.h'`; then
    echo shar: \"'weapon.h'\" unpacked with wrong size!
fi
# end of 'weapon.h'
fi
echo shar: End of archive 7 \(of 8\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
