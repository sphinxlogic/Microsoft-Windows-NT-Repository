Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i001:  xmpb - multiplayer space combat for X, Part01/08
Date: 26 Jun 1993 00:31:52 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2358
Approved: billr@saab.CNA.TEK.COM
Message-ID: <20g5do$6sk@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1791

Submitted-by: ddp@deakin.edu.au (Damien De Paoli)
Posting-number: Volume 18, Issue 1
Archive-name: xmpb/Part01
Environment: X11, Xlib

[[From the author...]]
[     XMPB is a multi player space combat game for X-terms. It works best
on multiple black and white workstations.  My next aim is to get it to
run quickly on colour workstations  (when I get access to a colour station)
If you have only seen version 0.85 then there are many changes, including

	save files
	a shop
	non playing characters
	more weapons
	speed increase.


If you have seen version 1.0, then the main change is in the Imakefile
xmpb can now be run without having to install the whole program.  Also
time limits have been added to games.

Well here it is, and good luck,
Damien ]


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 8)."
# Contents:  README MANIFEST bitmaps bitmaps/debris.3 parse.y pcomp.c
# Wrapped by billr@saab on Fri Jun 25 16:30:13 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(2088 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XWHAT IS XMPB?
X
XXMPB is a multi player space combat game for X-terms. It works best
Xon multiple workstations rather than using X-terms on the same computer.
X
X
X--->>> YOU MUST DO THIS, OR IT WILL NOT COMPILE.
X
XFirst you need to cd into the bitmaps directory, then:
X	
X	uudecode title.bmp.Z.uu
X	uncompress title.bmp.Z
X	rm title.bmp.Z.uu
X
X
XCOMPILING
X
XIf you have Imake then you should be able to just type
X
X	xmkmf
X	make depend
X	make
X
XHopefully this will create a copy of xmpb, npcc, clear_lock, describe
Xand retire in your current directory.  This should mean that you can
Xrun it, but the npc's are not installed.  If you are low on disk spave
Xand want to run it from your current directory, then you can type make
Xnpcs and they will be placed into NPCDIR.  Now it wil run fully, 
Xwithout being installed.
X
XIf you don't have Imake, then I have included a standard Makefile, 
XMakefile.std.  I haven't tested this, so I don't know if it will
Xwork or not, but give it a go!
X
X
XINSTALLING
X
XTo install the npcs, and all the binaries...
X
Xtype make install
X
XNow being pessimistic, you will probably get errors.  The most
Xobvious one, is due to mkdirhier not being set correctly and the
Xsubdirectories BLASTDIR, SAVEDIR, NPCDIR, BITMAPDIR and BINDIR.
Xhave not been created.  You can simply create these directories 
Xby hand.  e.g. for my system:
X
X	mkdir /home/ddp/blast    (this is what my BLASTDIR is set to)
X	mkdir /home/ddp/blast/save    (this is what my SAVEDIR is set to)
X
Xe.t.c.
X
XOnce this works, all you need to run this fully, is the blast dir and
Xits contents.  All the stuff from the shar files can be deleted.  If 
Xyou want to keep the sources, and modify them for yourself please do,
Xbut send the changes to me as well, and I will try to add them into 
Xthe official version.
X
X
XBUGS
X
X	What are they???
X	Seriously, if you get any, mail them to me ddp@deakin.edu.au, and
X	I'll look into it.
X
X
XTODO
X
X	The obvious one is to get this to run fast on a colour machine.  At
Xthe moment this is difficult as I don't have access to one, but soon we
Xwill and then I shall fix it up.
X
X
XGood Luck,
XDamien
END_OF_FILE
if test 2088 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(3338 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Imakefile                  6	
X MANIFEST                   1	This shipping list
X Makefile.std               5	
X README                     1	
X add_host.c                 3	
X average.npc                6	
X basic.npc                  6	
X beam.npc                   7	
X bitmaps                    1	
X bitmaps/atom               8	
X bitmaps/bigrock            7	
X bitmaps/bomb               3	
X bitmaps/cloud.1            8	
X bitmaps/cloud.2            7	
X bitmaps/cloud.3            8	
X bitmaps/cloud.4            8	
X bitmaps/cloud.5            8	
X bitmaps/cloud.6            8	
X bitmaps/debris.1           7	
X bitmaps/debris.2           7	
X bitmaps/debris.3           1	
X bitmaps/dunno              8	
X bitmaps/dunno2             8	
X bitmaps/hvypulse           8	
X bitmaps/jam100             8	
X bitmaps/jam25              8	
X bitmaps/jam50              8	
X bitmaps/jam75              8	
X bitmaps/magneto            8	
X bitmaps/massdrive          8	
X bitmaps/medrock            7	
X bitmaps/mine               8	
X bitmaps/pulse              8	
X bitmaps/rail               8	
X bitmaps/saturn1            8	
X bitmaps/seeker             8	
X bitmaps/ship.0             6	
X bitmaps/shortdeaddude      7	
X bitmaps/smallrock          8	
X bitmaps/star1              8	
X bitmaps/star2              8	
X bitmaps/stipple            8	
X bitmaps/title.bmp.Z.uu     4	
X bits.c                     6	
X bits.h                     8	
X calc_angle.c               7	
X calc_shields.c             7	
X clear_lock.c               8	
X clear_lock.man             7	
X collide.c                  7	
X cos.c                      8	
X costab.c                   7	
X damage_ship.c              6	
X describe.c                 7	
X describe.man               7	
X disp_ship.c                6	
X do_stars.c                 7	
X error.c                    8	
X handle_ev.c                4	
X harry.npc                  7	
X input.c                    2	
X john.npc                   7	
X junk.c                     5	
X lex.l                      6	
X ml.npc                     6	
X ml2.npc                    7	
X mnemonics.h                8	
X nasty.npc                  6	
X npcc.man                   5	
X operators.h                7	
X parse.y                    1	
X pcomp.c                    1	
X pcomp.h                    7	
X player.h                   5	
X polygon.c                  6	
X rad1.npc                   6	
X rad2.npc                   7	
X rad3.npc                   7	
X radar.c                    4	
X read_ship.c                7	
X retire.c                   7	
X retire.man                 7	
X save.c                     8	
X save.h                     7	
X save_load.c                7	
X shop.contents              4	
X shop.icon                  7	
X shop.man                   6	
X shop_stubs.c               2	
X shop_ui.c                  5	
X shop_ui.h                  7	
X sin.c                      7	
X sintab.c                   7	
X stats.c                    5	
X test.c                     4	
X thrust.c                   7	
X ud_win.c                   7	
X update_ships.c             3	
X update_win.c               3	
X util.c                     5	
X weapon.c                   3	
X weapon.h                   7	
X xmpb.man                   2	
X xoutput.c                  5	
END_OF_FILE
if test 3338 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test ! -d 'bitmaps' ; then
    echo shar: Creating directory \"'bitmaps'\"
    mkdir 'bitmaps'
fi
if test -f 'bitmaps/debris.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/debris.3'\"
else
echo shar: Extracting \"'bitmaps/debris.3'\" \(437 characters\)
sed "s/^X//" >'bitmaps/debris.3' <<'END_OF_FILE'
X#define debris_width 19
X#define debris_height 19
Xstatic char debris_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x80, 0x03, 0x00, 0x78, 0x02, 0x80, 0x07, 0x01,
X   0x78, 0x00, 0x01, 0x07, 0x80, 0x00, 0x01, 0x40, 0x00, 0x01, 0x20, 0x00,
X   0x02, 0x20, 0x00, 0x02, 0x10, 0x00, 0x02, 0x08, 0x00, 0x02, 0x04, 0x00,
X   0x02, 0x04, 0x00, 0x02, 0x02, 0x00, 0x04, 0x01, 0x00, 0x84, 0x00, 0x00,
X   0x84, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 437 -ne `wc -c <'bitmaps/debris.3'`; then
    echo shar: \"'bitmaps/debris.3'\" unpacked with wrong size!
fi
# end of 'bitmaps/debris.3'
fi
if test -f 'parse.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'parse.y'\"
else
echo shar: Extracting \"'parse.y'\" \(25960 characters\)
sed "s/^X//" >'parse.y' <<'END_OF_FILE'
X%{
X#include <stdio.h>
X#include "player.h"
X#include "weapon.h"
X#include "mnemonics.h"
X
X#define YYSTYPE int
X#define LOCAL 1
X#define GLOBAL 2
X
X#define ANY 0
X#define PROCFLAG 1
X#define STATEFLAG 2
X
Xint euid;
Xextern char id[];
Xint errline = 1;
Xint lasterr = 0;
Xint errors =0;
Xextern FILE *yyin,*yyout;
XFILE *dfp;
Xextern char yytext[];
X
Xint does_have_weap[NO_WEAPONS];
Xint i,j;
Xint curr_type;
Xint no_vars=0;
Xint max_vars = 0;
Xint no_globals = 0;
Xint no_locals = 0;
Xchar vars[100][MAX_SYMB_LEN+1];
Xint varmem[100];
Xint no_states=0;
Xchar states[100][MAX_SYMB_LEN+1];
Xint proc[100];
Xint sp[100];
Xchar buf[100];
Xint regused[NO_REGS];
Xchar curr_state[MAX_SYMB_LEN+1];
X
Xint bps[1000];
Xint bpsp = 0;
X
Xstruct ins mem[5000];
X
Xint pointer = 0;
X
Xint bp_no=0;
Xint bpl[100];
Xint bpp[100];
Xint bp_type[100];
Xchar bpn[100][MAX_SYMB_LEN+1];
X
Xstruct header head;
X
Xint ppp;
X
X%}
X
X%token HEADER NAME SHIPNAME ENGINEL NONE SHORT PULSE LLASER RAIL BOMB SEEK
X%token HLASER HPULSE ATOM MAGNETO BDEATH PROC
X%token WEAPONS ID VAR STATE LBRACE RBRACE ARROW SET RETURN B1 B2 B3
X%token INTEGER EQIV NOTEQ GT LT GTE LTE RP LP AND OR START LONG TCL
X%token EQUALS LSHIELD RSHIELD BSHIELD REPAIRL SOLARL CLOAKL DARROW
X%token SEMICOLON BALANCE RADARCHANGE RADARMODE SELECTE CLOAKT
X%token PLUS MINUS MASS MINE MOD IF END WHILE ELSE ANGLEDIFF COMMA
X%token TIMES DIV ENERGYMAX LSHIELDMAX RSHIELDMAX BSHIELDMAX NOT
X%token TURNLEFT TURNRIGHT XPOS YPOS XVEL YVEL ANGLE TURNTO
X%token SPEED  ENEMYSPEED ENEMYANGLE TARGETSTATE SOLARSTATE 
X%token JAMSTATE SHORTSTATE LONGSTATE ENGINESTATE REPAIRSTATE CURRWEAP ENEMYDIST
X%token NUMENEMIES ENERGY GRAB REPAIRTOGGLE QUIT TARGET REPAIRSELITEM
X%token ENEMYAVAIL DIRECTION ANGLETO DISTTO ENEMYXPOS ENEMYYPOS ENEMYXVEL ENEMYYVEL
X%token REPAIRITEM IDLEL VELATANG ENTRY EXIT CURRWEAPSTATE ENEMYDIRECTION WAITFRAME
X
X%%
Xprogram     : HEADER name shipname ship VAR variables rules start_rule
X            {
X                int i;
X
X                for(i=0;i<bp_no;i++)
X                {
X                    int sp;
X
X                    sp = finds(bpn[i],ANY);
X                    if(sp == -1)
X                    {
X                        sprintf(buf,"No routine %s: referenced in line %d",bpn[i],bpl[i]);
X                        yyerror(buf);
X                    }
X                    else
X                    {
X                        mem[bpp[i]].o2 = sp;
X                    }
X                }
X				head.no_vars = max_vars;
X				head.no_ins = pointer;
X				head.num_played=0;
X				head.kills = 0;
X				head.cash_earned=0;
X				fwrite(&head,sizeof(struct header),1,yyout);
X
X				/*
X				**
X				*/
X				fwrite(mem,sizeof(struct ins),pointer,yyout);
X			if(dfp)
X			{
X				j = 0;
X				for(i=0;i<pointer;i++)
X				{
X					if(i==sp[j])
X					{
X						fprintf(dfp,"%s:%d\n",states[j],sp[j]);
X						j++;
X					}
X					switch (mem[i].ins)
X					{
X						case EQR:
X						case XORR:
X						case LTR:
X						case LTER:
X						case GTR:
X						case GTER:
X						case ANDR:	
X						case ORR:
X						case ADDR:
X						case SUBR:
X						case MODR:
X						case MULR:
X						case DIVR:
X							fprintf(dfp,"%d %s r%d <- r%d r%d\n",i,ins_name[mem[i].ins],mem[i].o1,mem[i].o2,mem[i].o3);
X							break;
X						case RET:
X							fprintf(dfp,"%d %s\n",i,ins_name[mem[i].ins]);
X							break;
X						case LODM:
X						case STOM:
X						case INPR:
X						case LODI:
X						case OUPR:
X						case JMPC:
X						case JSRC:
X							fprintf(dfp,"%d %s r%d %d\n",i,ins_name[mem[i].ins],mem[i].o1,mem[i].o2);
X							break;
X						case JMPI:
X						case JSRI:
X						case PUSHM:
X						case POPM:
X							fprintf(dfp,"%d %s %d\n",i,ins_name[mem[i].ins],mem[i].o2);
X							break;
X						case MOVR:
X							fprintf(dfp,"%d %s r%d r%d\n",i,ins_name[mem[i].ins],mem[i].o1,mem[i].o2);
X							break;
X						case PUSHR:
X						case NOTR:
X						case POPR:
X							fprintf(dfp,"%d %s r%d\n",i,ins_name[mem[i].ins],mem[i].o1);
X							break;
X			
X						default:
X							fprintf(stderr,"%d Debug error\n",i);
X					}
X				}
X			}
X			fwrite(&no_states,sizeof(int),1,yyout);
X			for(i=0;i<no_states;i++)
X			{
X				fwrite((states[i]),1,MAX_SYMB_LEN,yyout);
X				fwrite(&(sp[i]),sizeof(int),1,yyout);
X			}		
X            }
X            ;
Xname        : NAME EQUALS ID {strncpy(head.Name,id,MAX_SYMB_LEN);}
X            ;
Xshipname    : SHIPNAME EQUALS ID {strncpy(head.Ship,id,MAX_SYMB_LEN);}
X            ;
Xship        : max items weapons
X
Xitems		: solar items
X			| short items
X			| engine items
X			| repair items
X			| long items
X			| cloak items
X			| tc items
X			|
X            ;
Xengine      : ENGINEL assign {head.qual[ENGINE] = $2;}
X            ;
Xassign      : EQUALS INTEGER {$$ = $2;};
X            | EQUALS NONE    {$$ = -1;};
X            ;
X
Xshort       : SHORT assign {head.qual[SHORTRR] = $2;}
X            ;
Xtc          : TCL assign    {head.qual[TC] = $2;}
X            ;
Xlong        : LONG assign  {head.qual[LONGRR] = $2;}
X            ;
Xmax         : me max
X			| mls max
X			| mrs max
X			| mbs max
X			|
X			;
Xme          : ENERGYMAX EQUALS INTEGER {head.energy_max = $3;}
X            ;
Xmls         : LSHIELDMAX EQUALS INTEGER {head.ls_max = $3;}
X            ;
Xmrs         : RSHIELDMAX EQUALS INTEGER {head.rs_max = $3;}
X            ;
Xmbs         : BSHIELDMAX EQUALS INTEGER {head.bs_max = $3;}
X            ;
Xsolar       : SOLARL assign {head.qual[SOLAR] = $2;}
X            ;
Xcloak       : CLOAKL assign  {head.qual[CLOAK] = $2;}
X            ;
Xrepair      : REPAIRL assign  {head.qual[REPAIR] = $2;}
X            ;
X
Xweapons     : WEAPONS w_list 
X            ;
X
Xw_list      : w_name
X				{
X					if(head.does_have_weap[$1])
X					{
X						sprintf(buf,"Already has %s",weap_names[$1]);
X						yywarn(buf);
X					}
X					head.does_have_weap[$1] = 1;
X				}	 w_list
X            |
X            ;
Xw_name      : PULSE {$$ = WEAP_PULSE;};
X            | BOMB { $$ = WEAP_BOMB;};
X            | SEEK { $$ = WEAP_SEEK;};
X            | LLASER { $$ = WEAP_LIGHT_LASER;};
X            | RAIL  { $$ = WEAP_RAIL;};
X            | MASS  { $$ = WEAP_MASS;};
X            | MINE  { $$ = WEAP_MINE;};
X			| HLASER { $$ = WEAP_HEAVY_LASER;};
X			| ATOM { $$ = WEAP_SPRAY;};
X			| HPULSE { $$ = WEAP_HVYPULSE;};
X			| MAGNETO { $$ = WEAP_MAGNET;};
X			| BDEATH { $$ = WEAP_BLACK;};
X            ;
Xitem_name   :   SOLARL { $$ = SOLAR;}
X			|   SHORT  { $$ = SHORTRR;}
X			|   LONG { $$ = LONGRR;}
X			|   ENGINEL  { $$ = ENGINE;}
X			|   TCL { $$ = TC;}
X			|   CLOAKL { $$ = CLOAK;}
X			|   REPAIRL { $$ = REPAIR;}
X			;
Xvariables   : variable variables
X            | END
X            ;
X
Xvariable    : ID  
X				{
X					if(addvar(id,GLOBAL) == -1)
X					{
X						sprintf(buf,"redeclaration of %s",id);
X						yywarn(buf);
X					}
X				};
X            ;
X
Xlocvariables: locvar locvariables
X			| 
X			;
X
Xlocvar		: ID
X				{
X                        if(addvar(id,LOCAL) == -1)
X                        {
X                            sprintf(buf,"redeclaration of %s",id);
X                            yywarn(buf);
X                        }
X                      };
X			;
Xlocals		:
X			| VAR locvariables END
X			;
X
Xrules       : rule rules
X            |
X            ;
X
Xrule        : STATE ID {
X									curr_type = STATEFLAG;
X
X                                    strncpy(curr_state,id,MAX_SYMB_LEN);
X                                    curr_state[MAX_SYMB_LEN] = 0;
X                                    if(addstate(id,pointer,STATEFLAG)==-1)
X                                    {
X                                        sprintf(buf,"%s redefined",id);
X                                        yyerror(buf);
X                                    }
X                                        } LBRACE locals entry { ppp = pointer;} statements {ins(JMPI,0,ppp,0); kill_locals(); } RBRACE 
X			| PROC ID {
X									curr_type = PROCFLAG;
X
X                                    strncpy(curr_state,id,MAX_SYMB_LEN);
X                                    curr_state[MAX_SYMB_LEN] = 0;
X                                    if(addstate(id,pointer,PROCFLAG)==-1)
X                                    {
X                                        sprintf(buf,"%s redefined",id);
X                                        yyerror(buf);
X                                    }
X                                        } LBRACE locals statements RBRACE {ins(RET,0,0,0); kill_locals();
X								}
X            ;
X            ;
X
Xentry		: ENTRY LBRACE statements RBRACE
X			|
X			;
Xstatements  : statements statement
X            |
X            ;
Xifstart		: IF LP expr RP
X				{
X					ins(NOTR,$3,0,0);
X					pushbp(pointer);
X					ins(JMPC,$3,0,0);
X					regused[$3] = 0;
X				}
X			statement
X				{
X					{
X					int i;
X					
X					i = popbp();
X					mem[i].o2 = pointer;
X					pushbp(i);
X					}
X				}
X			;
Xifend		: { popbp();}
X			| ELSE 
X				{
X					mem[popbp()].o2++;
X					pushbp(pointer);
X					ins(JMPI,0,0,0);
X				}
X			statement
X				{
X					mem[popbp()].o2 = pointer;
X				}
X			;
X
Xstatement   : error SEMICOLON {yyerrok;}
X			| WAITFRAME {ins(WAIT,0,0,0);}
X			| fcall SEMICOLON {for(i=0;i<NO_REGS;i++) regused[i] = 0;}
X			| expr SEMICOLON
X			| LBRACE statements RBRACE
X			| SEMICOLON
X			| ifstart ifend
X/*
X**	While statement
X*/
X		| 	WHILE LP 
X				{
X					pushbp(pointer);
X				}
X			expr 
X				{
X					ins(NOTR,$4,0,0);
X					pushbp(pointer);
X					ins(JMPC,$4,0,0);
X					regused[$4] = 0;
X				}
X			RP statement
X				{
X					mem[popbp()].o2 = pointer+1; /*Note that 1 is the size of next*/
X					ins(JMPI,0,popbp(),0);
X				}
X		| 	ARROW ID
X                {
X                    int sp;
X
X					if(curr_type == PROCFLAG)
X						yyerror("May not change states inside procedures");
X                    sp = finds(id,STATEFLAG);
X                    if(sp == -1)
X                    {
X                        bpp[bp_no] = pointer;
X                        strncpy(bpn[bp_no],id,MAX_SYMB_LEN);
X                        bpn[bp_no][MAX_SYMB_LEN] = 0;
X                        bpl[bp_no] = errline;
X                        bp_no++;
X                        ins(JMPI,0,0,0);
X                    }
X                    else
X                    {
X                        ins(JMPI,0,sp,0);
X                    }
X                } SEMICOLON
X		| 	expr ARROW ID 
X                {
X                    int sp;
X
X					if(curr_type == PROCFLAG)
X						yyerror("May not change states inside procedures");
X                    sp = finds(id,STATEFLAG);
X                    if(sp == -1)
X                    {
X                        bpp[bp_no] = pointer;
X                        strncpy(bpn[bp_no],id,MAX_SYMB_LEN);
X                        bpn[bp_no][MAX_SYMB_LEN] = 0;
X                        bpl[bp_no] = errline;
X                        bp_no++;
X                        ins(JMPC,$1,0,0);
X                    }
X                    else
X                    {
X                        ins(JMPC,$1,sp,0);
X                    }
X                    regused[$1] = 0;
X                } SEMICOLON
X            | SET outport EQUALS expr SEMICOLON 
X                {
X                    ins(OUPR,$4,$2,0);
X                    regused[$4] = 0;
X                }
X            | RETURN SEMICOLON {
X					if(curr_type != PROCFLAG)
X						yyerror("Return can only be in procedures");
X					else ins(RET,0,0,0);}
X			| RETURN expr SEMICOLON { 
X					if(curr_type != PROCFLAG)
X						yyerror("Return can only be in procedures");
X					else
X					{
X										if($2 == 0)
X										{
X											regused[0] = 0;
X										}
X										else
X										{
X											ins(MOVR,0,$2,0);
X											regused[0] =0;	
X											regused[$2] =0;	
X										}
X										ins(RET,0,0,0);
X									}
X					}
X            ;
Xoutport     : B1  {$$ = BUTTON1PORT;}
X            | B2  {$$ = BUTTON2PORT;}
X            | B3  {$$ = BUTTON3PORT;}
X            | BALANCE {$$ = BALANCEPORT;}
X            | RADARCHANGE {$$=RADARPORT;}
X            | CLOAKT {$$=CLOAKPORT;}
X            | SELECTE {$$=SELECTEPORT;}
X            | TURNLEFT {$$=TURNLEFTPORT;}
X            | TURNRIGHT {$$=TURNRIGHTPORT;}
X			| TURNTO { $$ = TURNTOPORT;}
X			| TARGET {$$ = TARGETPORT;}
X			| QUIT {$$ = QUITPORT;}
X			| REPAIRTOGGLE {$$=REPAIRTOGGLEPORT;}
X			| REPAIRSELITEM {$$=REPAIRSELITEMPORT;}
X			| GRAB {$$ = GRABPORT;}
X            ;
X
Xinformation : inport {
X                        int r;
X                        r = getreg();
X                        ins(INPR,r,$1,0);
X                        $$ = r;
X                    }
X            | var  {
X                    int r;
X                    r = getreg();
X                    ins(LODM,r,$1,0);
X                    $$ = r;
X                   }
X			| item_name {
X					int r;
X					r = getreg();
X					ins(LODI,r, $1,0);
X					$$ = r;
X					}
X			| IDLEL {
X                    int r;
X                    r = getreg();
X                    ins(LODI,r,IDLE,0);
X                    $$ = r;
X                    }
X			| w_name {
X					int r;
X					r = getreg();
X					ins(LODI,r, $1,0);
X					$$ = r;
X					}
X            | INTEGER {
X                    int r;
X                    r = getreg();
X                    ins(LODI,r,yylval,0);
X                    $$ = r;
X                   }
X			| fcall
X            ;
X
Xfcall: ID LP RP		{
X						int ru[NO_REGS];
X						extern char id[];
X						int r;
X						int i;
X                    	int sp;
X
X						for(i=0;i<NO_REGS;i++)
X						{
X							ru[i] = regused[i];
X							if(ru[i])
X							{
X								ins(PUSHR,i,0,0);
X							}
X						}
X                    	sp = finds(id,PROCFLAG);
X                    	if(sp == -1)
X                    	{
X                        	bpp[bp_no] = pointer;
X							if(regused[0])
X								bpp[bp_no]++;
X                        	strncpy(bpn[bp_no],id,MAX_SYMB_LEN);
X                        	bpn[bp_no][MAX_SYMB_LEN] = 0;
X                       		bpl[bp_no] = errline;
X							bp_type[bp_no] = PROCFLAG;
X                        	bp_no++;
X							sp = 0;
X                    	}
X
X						if(regused[0])
X						{
X							r = getreg();
X							ins(JSRI,0,sp,0);
X							ins(MOVR,r,0,0);
X						}	
X						else
X						{
X							r = 0;
X							regused[0] = 1;
X							ins(JSRI,0,sp,0);
X						}
X						for(i=NO_REGS-1;i>=0;i--)
X							if(ru[i])
X								ins(POPR,i,0,0);
X
X						$$ = r;
X				}
X            ;
Xinport      : LSHIELD {
X                        $$ = SHIELD1PORT;
X                        }
X            | RSHIELD {
X                        $$ = SHIELD2PORT;
X                        }
X            | BSHIELD {
X                        $$ = SHIELD3PORT;
X                        }
X            | RADARMODE { $$ = RADARMODEPORT;
X                        }
X            | XPOS  { $$ = XPOSPORT;
X                    }
X            | YPOS  { $$ = YPOSPORT;
X                    }
X            | XVEL  { $$ = XVELPORT;
X                    }
X            | YVEL  { $$ = YVELPORT;
X                    }
X            | ANGLE  { $$ = ANGLEPORT;
X                    }
X			| ENERGY { $$ = ENERGYPORT;}
X			| NUMENEMIES { $$ = NUMENEMIESPORT;}
X			| ENEMYDIST {$$ = ENEMYDISTPORT;}
X			| CURRWEAP {$$ = CURRWEAPPORT;}
X			| REPAIRSTATE {$$ = REPAIRSTATEPORT;}
X			| ENGINESTATE {$$ = ENGINESTATEPORT;}
X			| LONGSTATE {$$ = LONGSTATEPORT;}
X			| SHORTSTATE {$$ = SHORTSTATEPORT;}
X			| JAMSTATE {$$ = JAMSTATEPORT;}
X			| SOLARSTATE {$$ = SOLARSTATEPORT;}
X			| TARGETSTATE {$$ = TARGETSTATEPORT;}
X			| ENEMYANGLE {$$ = ENEMYANGLEPORT;}
X			| ENEMYDIRECTION { $$ = ENEMYDIRECTIONPORT;}
X			| ENEMYSPEED { $$ = ENEMYSPEEDPORT;}
X			| SPEED { $$ = SPEEDPORT;}
X			| ENEMYAVAIL { $$ = ENEMYAVAILPORT;}
X			| DIRECTION { $$ = DIRECTIONPORT;}
X			| ANGLETO LP expr {ins(PUSHR,$3,0,0); regused[$3] = 0;} COMMA expr { ins(PUSHR,$6,0,0); regused[$6] = 0;} RP {$$ = ANGLETOPORT;}
X			| DISTTO LP expr {ins(PUSHR,$3,0,0); regused[$3] = 0;} COMMA expr { ins(PUSHR,$6,0,0); regused[$6] = 0;} RP {$$ = DISTTOPORT;}
X			| ENEMYXPOS { $$ = ENEMYXPOSPORT;}
X			| ENEMYYPOS { $$ = ENEMYYPOSPORT;}
X			| ENEMYXVEL { $$ = ENEMYXVELPORT;}
X			| ENEMYYVEL { $$ = ENEMYYVELPORT;}
X			| REPAIRITEM { $$ = REPAIRITEMPORT;}
X			| VELATANG LP expr {ins(PUSHR,$3,0,0); regused[$3]=0;} RP { $$ = VELATANGPORT;}
X			| CURRWEAPSTATE {$$ = CURRWEAPSTATEPORT;}
X            ;
Xvar         : ID {
X					extern char id[];
X                    int v;
X                    v = lookup(id);
X                    if(v == -1)
X                    {
X                        sprintf(buf,"%s undefined",id);
X                        yyerror(buf);
X                    }
X                    $$ = varmem[v];
X                    }
X            ;
X
Xstart_rule  : START ID {
X                    int sp;
X
X                    sp = finds(id,STATEFLAG);
X                    if(sp == -1)
X                    {
X                        yyerror("Start state does not exist");
X                    }
X                    else
X                    {
X						head.start = sp;
X                    }
X                    }
X            ;
X
Xexpr:	logical_or_expr
X				|	var EQUALS expr { 
X							ins(STOM,$3,$1,0);
X							regused[$3] = 0;
X							$$ = $3;
X									}
X				;
Xlogical_or_expr		:	logical_and_expr
X					| 	logical_or_expr OR logical_and_expr
X						{
X							int r;
X							r = getreg();
X							ins(ORR,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X					;
Xlogical_and_expr	:	inclusive_or_expr
X					|	logical_and_expr AND inclusive_or_expr
X						{
X							int r;
X							r = getreg();
X							ins(ANDR,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X					;
Xinclusive_or_expr:	exclusive_or_expr
X				|	inclusive_or_expr '|' exclusive_or_expr
X						{
X							int r;
X							r = getreg();
X							ins(ORR,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X				;
Xexclusive_or_expr:	and_expr
X				|	exclusive_or_expr '^' and_expr
X						{
X							int r;
X							r = getreg();
X							ins(XORR,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X				;
Xand_expr		:	equality_expr
X				|	and_expr '&' equality_expr
X						{
X							int r;
X							r = getreg();
X							ins(ANDR,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X				;
Xequality_expr	:	relational_expr
X				|	equality_expr EQIV	relational_expr
X						{
X							int r;
X							r = getreg();
X							ins(EQR,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X				|	equality_expr NOTEQ relational_expr
X						{
X							int r;
X							r = getreg();
X							ins(EQR,r,$1,$3);
X							ins(NOTR,r,0,0);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X				;
Xrelational_expr	:	additive_expr
X				|	relational_expr LT additive_expr
X						{
X							int r;
X							r = getreg();
X							ins(LTR,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X				| 	relational_expr GT additive_expr
X						{
X							int r;
X							r = getreg();
X							ins(GTR,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X				| 	relational_expr LTE additive_expr
X						{
X							int r;
X							r = getreg();
X							ins(LTER,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X				| 	relational_expr GTE additive_expr
X						{
X							int r;
X							r = getreg();
X							ins(GTER,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X				;
Xadditive_expr	:	multiplicative_expr
X				|	additive_expr PLUS multiplicative_expr
X						{
X							int r;
X							r = getreg();
X							ins(ADDR,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X				|	additive_expr MINUS multiplicative_expr
X						{
X							int r;
X							r = getreg();
X							ins(SUBR,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X				;
Xmultiplicative_expr:	unary_expr
X					| multiplicative_expr TIMES unary_expr
X						{
X							int r;
X							r = getreg();
X							ins(MULR,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X					| multiplicative_expr DIV unary_expr
X						{
X							int r;
X							r = getreg();
X							ins(DIVR,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X					| multiplicative_expr MOD unary_expr
X						{
X							int r;
X							r = getreg();
X							ins(MODR,r,$1,$3);
X							regused[$1] = 0;
X							regused[$3] = 0;
X							$$ = r;
X						}
X					;
Xunary_expr	:	primary_expr
X			|	NOT primary_expr
X						{
X							int r;
X							ins(NOTR,$2,0,0);
X							regused[$2] = 0;
X							$$ = $2;
X						}
X			|	MINUS primary_expr
X						{
X							int r;
X							r = getreg();
X							ins(SUBR,r,0,$2);
X							regused[$2] = 0;
X							$$ = r;
X						}
X			;
Xprimary_expr	:	information {$$ = $1;}
X				|	LP expr RP {$$ = $2;}
X				;
X
X%%
Xchar fn[40] = "stdin";
Xchar in[40],out[40];
Xint deb=0;
Xchar deg[40];
X
Xparse(f,d)
Xchar *f;
Xint d;
X{
X
X	int i;
X	FILE *hall_fp;
X
X
X
X	errors = 0;
X	errline = 1;
X	no_vars = 0;
X	no_globals = 0;
X	max_vars = 0;
X	no_locals = 0;
X	pointer = 0;
X	no_states = 0;
X	bpsp = 0;
X	bp_no = 0;
X	for(i=0;i<NUM_ITEMS;i++)
X	{
X		head.qual[i] = -1;
X	}
X    for(i=0;i<NO_WEAPONS;i++)
X        head.does_have_weap[i] = 0;
X    for(i=0;i<NO_REGS;i++)
X        regused[i] =0;
X	if(rindex(f,'.') && !strcmp(".npc",rindex(f,'.')))
X	{
X		*((char *)rindex(f,'.')) = '\0';
X	}
X	strcpy(in,f);
X
X	strcpy(out,NPCDIR);
X
X	if(rindex(f,'/'))
X	{
X		strcat(out,rindex(f,'/'));
X	}
X	else
X    	strcat(out,f);
X
X    strcat(in,".npc");
X    yyin = fopen(in,"r");
X    if(!yyin)
X    {
X        perror("Can't open source file");
X        return 1;
X    }
X    strcat(out,".no");
X
X	seteuid(euid);
X	hall_fp=fopen(out,"rb");
X	if(hall_fp)
X	{
X		hall_of_fame(hall_fp);
X		seteuid(euid);
X	}
X    yyout = fopen(out,"wb");
X	seteuid(getuid());
X    if(!yyout)
X    {
X        perror("Can't open output file");
X        fclose(yyin);
X        return 1;
X    }
X	if(d)
X	{
X		strcpy(deg,f);
X		strcat(deg,".deb");
X		dfp = fopen(deg,"w");
X		if(!dfp)
X		{
X			perror("Can't open debug file");
X			fclose(yyout);
X			fclose(yyin);
X			return 1;
X		}
X	}
X    strcpy(fn,in);
X	fprintf(stderr,"***%s***\n",in);
X	yyparse();	
X	fclose(yyin);
X	fclose(yyout);
X	if(d)
X	{
X		fclose(dfp);
X		dfp = NULL;
X	}
X	if(errors)
X		unlink(out);
X}
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X	extern int yydebug;
X    int i;
X	int d = 0;
X
X	euid = geteuid();
X	seteuid(getuid());
X    yyin = stdin;
X    yyout = stdout;
X
X	yydebug = 1;
X	if(argc < 2)
X	{
X		yyparse();
X		return 0;
X	}
X	for(i=1;i<argc;i++)
X	{
X		if(argv[i][0] == '-' && argv[i][1] == 'd')
X			d = 1;
X		else
X			parse(argv[i],d);
X	}
X    return 0;
X}
X
Xvoid yyerror(str)
Xchar *str;
X{
X    fprintf(stderr,"%s - Error in line %d: %s\n",fn,errline,str);
X    errors = 1;
X}
Xvoid yywarn(str)
Xchar *str;
X{
X    fprintf(stderr,"%s - Warning in line %d: %s\n",fn,errline,str);
X}
X
Xvoid emit(s)
Xchar *s;
X{
X    fprintf(yyout,"%s",s);
X}
X
Xaddvar(v,mode)
Xchar *v;
Xint mode;
X{
X    int i;
X
X	if(mode == GLOBAL)
X	{
X    	for(i=0;i<no_vars;i++)
X    	{
X        	if(!strncmp(vars[i],v,MAX_SYMB_LEN))
X        	return -1;
X    	}
X	}
X    strncpy(vars[no_vars],v,MAX_SYMB_LEN);
X    vars[no_vars][MAX_SYMB_LEN] = 0;
X	varmem[no_vars++] = max_vars++;
X	/*if(no_vars > max_vars)
X		max_vars++;
X*/
X	if(mode == GLOBAL)
X		no_globals++;
X	else
X		no_locals++;
X/*
Xfprintf(stderr, "added %s in mode %d\n", v, mode);
Xfprintf(stderr, "no_vars=%d\nmax_vars=%d\nglobs=%d\nlocs=%d\n", no_vars, max_vars, no_globals, no_locals);
X{ int i;
X	for(i=0; i < no_vars; i++)
X		printf("var[%d]=%s mem = %d\n", i, vars[i],varmem[i]);
X}
X*/
X    return 1;
X}
X
Xkill_locals()
X{
X	no_vars = no_globals;
X	no_locals=0;
X}
X
Xlookup(v)
Xchar *v;
X{
X    int i;
X
X    for(i=no_vars-1;i>=0;i--)
X    {
X        if(!strncmp(vars[i],v,MAX_SYMB_LEN))
X        return i;
X    }
X    return -1;
X}
X
Xgetreg()
X{
X    int i=0;
X    while(regused[i] && i < NO_REGS) i++;
X    if(i == NO_REGS)
X    {
X        yyerror("Out of registers");
X        return -1;
X    }
X    regused[i] = 1;
X    return i;
X}
X
Xins(i,o1,o2,o3)
Xint i,o1,o2,o3;
X{
X	if(i == NOTR && mem[pointer-1].ins == NOTR && mem[pointer-1].o1 == o1)
X	{
X		pointer--;
X		return;
X	}
X
X    mem[pointer].ins = i;
X    mem[pointer].o1 = o1;
X    mem[pointer].o2 = o2;
X    mem[pointer].o3 = o3;
X    sprintf(buf,"%d\t%s %d,%d,%d\n",pointer,ins_name[i],o1,o2,o3);
X    pointer++;
X}
X
Xaddstate(s,p,pors)
Xchar *s;
Xint p;
Xint pors;
X{
X    int i;
X
X    for(i=0;i<no_states;i++)
X    {
X        if(!strncmp(states[i],s,MAX_SYMB_LEN))
X        return -1;
X    }
X	proc[no_states] = pors;
X    sp[no_states] = p;
X    strncpy(states[no_states],s,MAX_SYMB_LEN);
X    states[no_states++][MAX_SYMB_LEN] = 0;
X    return 1;
X}
Xfinds(s,pors)
Xchar *s;
Xint pors;
X{
X    int i;
X    for(i=0;i<no_states;i++)
X    {
X        if(!strncmp(states[i],s,MAX_SYMB_LEN) && (pors == proc[i] || pors == ANY))
X		{
X        return sp[i];
X		}
X    }
X    return -1;
X}
X
Xpushbp(i)
Xint i;
X{
X	bps[bpsp++] = i;
X}
X
Xpopbp()
X{
X	return(bps[--bpsp]);
X}
X
Xhall_of_fame(npc_fp)
XFILE *npc_fp;
X{
X	char buf[160], buf2[160];
X	struct header h, head;
X	int dude_written,same;
X	FILE *fp, *fp2;
X	
X
X    buf[0]=buf2[0]=0;
X	fread(&h, sizeof(struct header), 1, npc_fp);
X	fclose(npc_fp);
X    strcpy(buf, SAVEDIR);
X    strcat(buf, "hall.of.fame.npc");
X    strcpy(buf2, buf);
X    strcat(buf2, "2");
Xseteuid(euid);
X    fp=fopen(buf,"rb");
Xseteuid(getuid());
X    if(!fp)
X    {
Xseteuid(euid);
X        fp=fopen(buf,"wb");
Xseteuid(getuid());
X        if(!fp)
X        {
X                perror("Cannot create npc hall of fame\n");
X                exit(0);
X        }
X        fwrite(&h, sizeof(struct header), 1, fp);
X        fclose(fp);
X        return;
X    }
X
X    dude_written=0;
X
Xseteuid(euid);
X	fp2=fopen(buf2, "wb");
Xseteuid(getuid());
Xif(!fp2)
X{
X	perror("Can't open temp hall of fame file");
X	exit(1);
X}
X	while(fread(&head, sizeof(struct header), 1, fp))
X	{
X		same = 0;
X		if(!strcmp(h.Name, head.Name))
X		{
X			if(!dude_written && (h.kills > head.kills || 
X				(h.kills == head.kills && h.cash_earned > head.cash_earned)))
X				fwrite(&h, sizeof(struct header), 1, fp2);
X			else
X				if(!dude_written) fwrite(&head, sizeof(struct header), 1, fp2);
X			dude_written = 1;
X			same = 1;
X		}
X		else
X		{
X			if(!dude_written && (h.kills > head.kills || 
X				(h.kills == head.kills && h.cash_earned > head.cash_earned)))
X			{
X				fwrite(&h, sizeof(struct header), 1, fp2);
X				dude_written = 1;
X			}
X		}
X		if(!same) 
X			fwrite(&head, sizeof(struct header), 1, fp2);
X	}
X    if(!dude_written)
X            fwrite(&h, sizeof(struct header), 1, fp2);     
X    fclose(fp);
X    fclose(fp2);
X    unlink(buf);
X    rename(buf2, buf);
X}
END_OF_FILE
if test 25960 -ne `wc -c <'parse.y'`; then
    echo shar: \"'parse.y'\" unpacked with wrong size!
fi
# end of 'parse.y'
fi
if test -f 'pcomp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pcomp.c'\"
else
echo shar: Extracting \"'pcomp.c'\" \(16260 characters\)
sed "s/^X//" >'pcomp.c' <<'END_OF_FILE'
X/* pcomp.c - *** routines for the psuedo computer */
Xstatic char sccs_id[] = "@(#)pcomp.c 1.1 93/01/26 XMPB";
X
X#include <math.h>	
X#include "player.h"
X#include "mnemonics.h"
X
Xextern int euid;
Xextern winptr first_win;
Xextern int mycostab[];
Xextern int num_npcs_windows;
Xextern int num_npcs_alive;
Xextern int num_alive;
X
XFILE *tfp = stdout;
X
Xstruct comp *create_comp(ds,cs,start)
Xint ds,cs,start;
X{
X	struct comp *c;
X
X	c = (struct comp *)malloc(sizeof(struct comp));
X	if(!c) 
X		return NULL;
X
X	c->data = (int *)malloc(ds*sizeof(int));
X	if(!c->data)
X	{
X		free(c);
X		return NULL;
X	}
X	c->text = (struct ins *)malloc(cs*sizeof(struct ins));
X	if(!c->text)
X	{
X		free(c->data);
X		free(c);
X		return NULL;
X	}
X	c->sp =0;
X	c->pc = start;
X	return c;
X}
X
X#define R1	c->regs[ci->o1]
X#define R2	c->regs[ci->o2]
X#define R3	c->regs[ci->o3]
X
Xexecute_ins(w,c)
Xwinptr w;
Xstruct comp *c;
X{
X	int r = 1;
X    struct ins *ci;
X
X	if(w->comp->turnto != 0 && w->comp->turnto != -500)
X	{
X/*
Xprintf("Turning to %d\n",w->comp->turnto);
X*/
X		if(w->comp->turnto > 0)
X		{
X			start_turn_right(w);
X		}
X		else
X		{
X			start_turn_left(w);
X		}	
X
X		if(w->angle_v > 15 || w->angle_v < -15)
X			stop_turn_left(w);
X
X			w->comp->turnto = w->comp->turnabs - w->angle;
X            if(w->comp->turnto > 180)
X            {
X                w->comp->turnto -= 360;
X            }
X            if(w->comp->turnto < -180)
X            {
X                w->comp->turnto += 360;
X            }
X/*
X		w->comp->turnto -= w->angle - w->comp->turnabs;
X		w->comp->turnabs = w->angle;
X*/
X	}
X	else if(w->comp->turnto != -500)
X	{
X		w->comp->turnto = -500;
X		stop_turn_left(w);
X	}
X#ifdef TRACE
Xprintf("%s\n", w->Name);
Xprintf("%d\n",c->pc);
X#endif
X	ci = &(c->text[c->pc++]);
X
X
X	switch(ci->ins)
X	{
X		case ANDR:
X			R1 = R2 & R3;
X			break;
X		case LODI:
X			R1 = ci->o2;
X			break;
X		case LODM:
X			R1 = c->data[ci->o2];
X			break;
X		case STOM:
X			c->data[ci->o2] = R1;
X			break;
X		case XORR:
X			R1 = R2 ^ R3;
X			break;
X		case LTER:
X			R1 = R2 <= R3;
X			break;
X		case ORR:
X			R1 = R2 | R3;
X			break;
X		case JMPI:
X			c->pc = ci->o2;
X			break;
X		case EQR:
X			R1 = R2 == R3;
X			break;
X		case LTR:
X			R1 = R2 < R3;
X			break;
X		case GTR:
X			R1 = R2 > R3;
X			break;
X		case GTER:
X			R1 = R2 >= R3;
X			break;
X		case NOTR:
X			R1 = !R1;
X			break;
X		case JMPC:
X			if(R1)
X			{
X				c->pc = ci->o2;
X			}
X			break;
X		case JSRC:
X			if(R1)
X			{
X				c->stack[c->sp++] = c->pc;
X				c->pc = ci->o2;
X			}
X			break;
X		case JSRI:
X			c->stack[c->sp++] = c->pc;
X			c->pc = ci->o2;
X			break;
X		case RET:
X			c->pc = c->stack[--c->sp];
X			break;
X		case RETC:
X			if(R1)
X				c->pc = c->stack[--c->sp];
X			break;
X		case MOVR:
X			R1 = R2;
X			break;
X		case ADDR:
X			R1 = R2 + R3;
X			break;
X		case SUBR:
X			R1 = R2 - R3;
X			break;
X		case MULR:
X			R1 = R2 * R3;
X			break;
X		case DIVR:
X			if(R3 == 0)
X				R1 = 0;
X			else
X			R1 = R2 / R3;
X			break;
X		case INPR:
X			R1 = input_port(w,ci->o2);
X			break;
X		case OUPR:
X			output_port(w,ci->o2,R1);
X			break;
X		case MODR:
X			if(R3 == 0)
X				R1 = 0;
X			else
X			R1 = R2 % R3;
X#ifdef TRACE
Xprintf("the mod of %d with %d is %d\n", R1, R2, R3);
X#endif
X			break;
X		case PUSHR:
X			c->stack[c->sp++] = R1;
X			break;
X		case WAIT:
X			r = 0;
X			break;
X		case POPR:
X			if(c->sp == 0)
X			{
X				printf("%s Stack Underflow instruction %d\n",w->Name,c->pc);
X				xmpb_error("");
X			}
X			 R1 = c->stack[--c->sp];
X			break;
X		case PUSHM:
X			c->stack[c->sp++] = c->data[ci->o2];
X			break;
X		case POPM:
X			if(c->sp == 0)
X			{
X				printf("%s Stack Underflow instruction %d\n",w->Name,c->pc);
X				xmpb_error("");
X			}
X			 c->data[ci->o2] = c->stack[--c->sp];
X			break;
X		default:
X			fprintf(stderr,"\n%s instruction %d opcode %d - Illegal Instruction sp = %d\n",w->Name,w->comp->pc,ci->ins,c->sp);
X			xmpb_error("\n\nExecution Halted\n");
X			break;
X	}
X#ifdef TRACE
X{ int i;
X
X	switch(ci->ins)
X	{
X		case EQR:
X    	case XORR:
X    	case LTR:
X    	case LTER:
X    	case GTR:
X    	case GTER:
X    	case ANDR:
X    	case ORR:
X    	case ADDR:
X    	case SUBR:
X    	case MODR:
X    	case MULR:
X    	case DIVR:
X        	fprintf(tfp,"%d %s r%d <- r%d r%d\n",i,ins_name[ci->ins],ci->o1,ci->o2,ci->o3);
X        	break;
X		case WAIT:
X    	case RET:
X        	fprintf(tfp,"%d %s\n",i,ins_name[ci->ins]);
X        	break;
X    	case LODM:
X    	case STOM:
X    	case INPR:
X    	case LODI:
X    	case OUPR:
X    	case JMPC:
X    	case JSRC:
X        	fprintf(tfp,"%d %s r%d %d\n",i,ins_name[ci->ins],ci->o1,ci->o2);
X        	break;
X    	case JMPI:
X    	case JSRI:
X    	case PUSHM:
X    	case POPM:
X        	fprintf(tfp,"%d %s %d\n",i,ins_name[ci->ins],ci->o2);
X        	break;
X    	case PUSHR:
X    	case NOTR:
X    	case POPR:
X        	fprintf(tfp,"%d %s r%d\n",i,ins_name[ci->ins],ci->o1);
X        	break;
X
X    	default:
X        	fprintf(stderr,"%d Trace error\n",i);
X	}
X	for(i=0; i < NO_REGS; i++)
X		printf("r[%d]=%d  ", i, w->comp->regs[i]);
X	printf("\n-------\n");
X}
X#endif
X
X	return r;
X}
X
Xint input_port(w,i)
Xwinptr w;
Xint i;
X{
X	int v;
X	switch(i)
X	{
X		case SHIELD1PORT:
X			v = w->ls_curr;
X			break;
X		case SHIELD2PORT:
X			v = w->rs_curr;
X			break;
X		case SHIELD3PORT:
X			v = w->bs_curr;
X			break;
X	 	case RADARMODEPORT:
X			v = 2 - w->short_range_radar;
X			break;
X		case XPOSPORT:
X			v = w->sx;
X			break;
X		case YPOSPORT:
X			v = w->sy;
X			break;
X		case XVELPORT:
X			v = w->xv/32768;
X			break;
X		case YVELPORT:
X			v = w->yv/32768;
X			break;
X		case ANGLEPORT:
X			v = w->angle;
X			break;
X		case TARGETSTATEPORT:
X			v = w->state[TC];
X			break;
X		case SOLARSTATEPORT:
X			v = w->state[SOLAR];
X			break;
X		case JAMSTATEPORT:
X			v = w->state[CLOAK];
X			break;
X		case SHORTSTATEPORT:
X			v = w->state[SHORTRR];
X			break;
X		case LONGSTATEPORT:
X			v = w->state[LONGRR];
X			break;
X		case ENGINESTATEPORT:
X			v = w->state[ENGINE];
X			break;
X		case REPAIRSTATEPORT:
X			v = w->state[REPAIR];
X			break;
X		case CURRWEAPPORT:
X			v = w->curr_weap;
X			break;
X		case ENERGYPORT:
X			v = w->energy_curr;
X			break;
X		case ENEMYSPEEDPORT:
X			if(w->comp->curr_enemy == -1 || !w->comp->ce || !cansee(w,w->comp->ce)) 
X			{
X				v = 0;
X			}
X			else
X				v = (int)(sqrt((double)(w->comp->ce->xv/32768*w->comp->ce->xv/32768)+(double)(w->comp->ce->yv/32768*w->comp->ce->yv/32768)));
X			break;
X		case SPEEDPORT:
X			v = (int)(sqrt((double)(w->xv/32768*w->xv/32768)+(double)(w->yv/32768*w->yv/32768)));
X			break;
X		case NUMENEMIESPORT:
X		{
X			winptr t;
X			int i,j,k,l,d;
X			int relx,rely;
X
X			t = first_win;
X			i = 0;
X			l = 0;
X			while(t)
X			{
X				if(t == w)
X					goto argh;
X				{
X					relx = w->sx - t->sx;
X					rely = w->sy - t->sy;
X			
X					d = (relx*relx+rely*rely);
X			
X					if(!cansee(w,t))
X					{
X						goto argh;
X					}
X
X					j = 0;
X					while((w->comp->close[j] < d) && (j < i))
X						j++;
X					for(k=i;k>j;k--)
X					{
X						w->comp->close[k] = w->comp->close[k-1];
X						w->comp->closest[k] = w->comp->closest[k-1];
X						w->comp->cptr[k] = w->comp->cptr[k-1];
X					}
X					w->comp->closest[j] = l;
X					w->comp->close[j] = d;
X					w->comp->cptr[j] = t;
X					i++;
X				}
Xargh:
X				l++;
X				t = t->next;
X			}
X#ifdef TRACE
X	for(j=0;j<MAXHOST;j++)
X	{
X		printf("%d ",w->comp->closest[j]);
X	}
X	printf("\n");
X#endif
X			w->comp->no_seen = i;
X			v = i;
X			break;
X		}
X		case ENEMYAVAILPORT:
X		{
X			if(w->comp->curr_enemy == -1 || !w->comp->ce) v = 0;
X			else
X				v = cansee(w,w->comp->ce);
X			break;
X		}
X		case ENEMYDISTPORT:
X		{
X			int relx,rely;
X
X			if(w->comp->curr_enemy == -1 || !w->comp->ce || !cansee(w,w->comp->ce)) 
X			{
X				v = 0;
X			}
X			else
X			{
X				if(jamming(w,w->comp->ce))
X				{
X					relx = w->sx - (rand()%(WORLDW*2)-WORLDW);
X					rely = w->sy - (rand()%(WORLDH*2)-WORLDH);
X				}
X				else
X				{
X					relx = w->sx - w->comp->ce->sx;
X					rely = w->sy - w->comp->ce->sy;
X				}
X				v = (int)sqrt((double)(relx*relx+rely*rely));
X			}
X			break;
X		}
X		case ENEMYANGLEPORT:
X			
X			if(w->comp->curr_enemy == -1 ||!w->comp->ce ||  !cansee(w,w->comp->ce)) 
X			{
X				v = -1;
X			}
X			else
X			if(w->comp->ce->sx == w->sx && w->comp->ce->sy == w->sy) 
X				v = 0;
X			else
X			{
X				int x,y;
X				if(jamming(w,w->comp->ce))
X				{
X					x = (rand()%(WORLDW*2)-WORLDW);
X					y = (rand()%(WORLDH*2)-WORLDH);
X				}	
X				else
X				{
X					x = w->comp->ce->sx;
X					y = w->comp->ce->sy;
X				}
X				v = (int)(180.0+180.0*atan2(-(double)(x-w->sx),-(double)(y-w->sy))/M_PI);
X			}
X			break;
X		case DIRECTIONPORT:
X			if(w->xv/32768 == 0)
X			{
X				if(w->yv > 0)
X					v = 0;
X				else
X					v = 180;
X			}
X			else if(w->yv/32768 == 0)
X			{
X				if(w->xv > 0)
X					v = 90;
X				else
X					v = 270;
X			}
X			else
X			v = (int)(180+180.0*atan2(-(double)(w->xv/32768),-(double)(w->yv/32768))/M_PI);
X			break;
X		case ANGLETOPORT:
X		{
X			int *x,*y;
X	
X			x = &(w->comp->stack[w->comp->sp-2]);
X			y = &(w->comp->stack[w->comp->sp-1]);
X
X			v = (int)(180+180.0*atan2((double)(w->sx- *x),(double)(w->sy- *y))/M_PI);
X			w->comp->sp-=2;
X			break;
X		}
X		case DISTTOPORT:
X		{
X			int relx,rely;
X			int *x,*y;
X	
X			x = &(w->comp->stack[w->comp->sp-2]);
X			y = &(w->comp->stack[w->comp->sp-1]);
X
X			relx = w->sx - *x;
X			rely = w->sy - *y;
X
X			v = (int)sqrt((double)(relx*relx+rely*rely));
X
X			w->comp->sp-=2;
X			break;
X		}
X		case ENEMYDIRECTIONPORT: 
X			if(!w->comp->ce) break;
X			if(w->comp->ce->xv/32768 == 0)
X            {
X                if(w->comp->ce->yv > 0)
X                    v = 0;
X                else
X                    v = 180;
X            }
X            else if(w->comp->ce->yv/32768 == 0)
X            {
X                if(w->comp->ce->xv > 0)
X                    v = 90;
X                else
X                    v = 270;
X            }
X            else
X            v = (int)(180+180.0*atan2(-(double)(w->comp->ce->xv/32768),-(double)(w->comp->ce->yv/32768))/M_PI)
X;
X			break;
X		case ENEMYXVELPORT:
X			if(w->comp->curr_enemy == -1 ||!w->comp->ce ||  !cansee(w,w->comp->ce)) 
X			{
X				v = -1;
X			}
X			else
X				v = w->comp->ce->xv/32768;
X			break;
X		case ENEMYYVELPORT:
X			if(w->comp->curr_enemy == -1 ||!w->comp->ce ||  !cansee(w,w->comp->ce)) 
X			{
X				v = -1;
X			}
X			else
X				v = w->comp->ce->yv/32768;
X			break;
X		case ENEMYXPOSPORT:
X			if(w->comp->curr_enemy == -1 ||!w->comp->ce ||  !cansee(w,w->comp->ce)) 
X			{
X				v = -1;
X			}
X			else
X				v = w->comp->ce->sx;
X			break;
X		case ENEMYYPOSPORT:
X			if(w->comp->curr_enemy == -1 ||!w->comp->ce ||  !cansee(w,w->comp->ce)) 
X			{
X				v = -1;
X			}
X			else
X				v = w->comp->ce->sy;
X			break;
X		case REPAIRITEMPORT:
X				v = w->rep_which;
X			break;
X		case VELATANGPORT:
X		{
X			int dir, speed, *ang;
X				
X			if(w->xv/32768 == 0)
X            {
X                if(w->yv > 0)
X                    dir = 0;
X                else
X                    dir = 180;
X            }
X            else if(w->yv/32768 == 0)
X            {
X                if(w->xv > 0)
X                    dir = 90;
X                else
X                    dir = 270;
X            }
X            else
X            dir = (int)(180+180.0*atan2(-(double)(w->xv/32768),-(double)(w->yv/32768))/M_PI)
X;
X			speed = (int)(sqrt((double)(w->xv/32768*w->xv/32768)+(double)(w->yv/32768*w->yv/32768)));
X			ang= &(w->comp->stack[w->comp->sp-1]);
X			if(dir >= *ang)
X				v = speed * (mycostab[(dir - *ang)%360])/32768;
X			else 
X				v = speed * (mycostab[(*ang - dir)%360])/32768;
X		}
X			w->comp->sp-=1;
X			break;
X		case CURRWEAPSTATEPORT:
X			if(w->load_status[w->curr_weap]==-1)
X				v = 0;
X			else
X				v = 1;
X			break;
X		default:
X			fprintf(stderr,"%s ----\n",w->Name);
X			xmpb_error("Illegal Input port");
X			break;
X	}
X#ifdef TRACE
Xprintf("inport %d %d\n",i,v);
X#endif
X	return v;
X}	
X
Xoutput_port(w,o,v)
Xwinptr w;
Xint o,v;
X{
X#ifdef TRACE
Xprintf("ouport %d -> %d\n",v,o);
X#endif
X	switch(o)
X	{
X		case BUTTON1PORT:
X			w->b1 = v;
X			w->cloaking = 0;
X			break;
X		case BUTTON2PORT:
X			w->b2 = v;
X			break;
X		case BUTTON3PORT:
X			w->b3 = v;
X			break;
X		case RADARPORT:
X			w->short_range_radar = 1 - w->short_range_radar;
X			break;
X		case BALANCEPORT:
X			balance_shields(w);
X			break;
X		case TURNLEFTPORT:
X			if(v)
X				start_turn_left(w);
X			else
X				stop_turn_left(w);
X			break;
X		case TURNRIGHTPORT:
X			if(v)
X				start_turn_right(w);
X			else
X				stop_turn_right(w);
X			break;
X		case TURNTOPORT:
X/*
Xprintf("Set turn port\n");
X*/
X			w->comp->turnto = v - w->angle;
X			if(w->comp->turnto > 180)
X			{
X				w->comp->turnto -= 360;
X			}
X			if(w->comp->turnto < -180)
X			{
X				w->comp->turnto += 360;
X			}
X/*
X			w->comp->turnabs = w->angle;
X*/
X			w->comp->turnabs = v;
X			break;
X		case REPAIRTOGGLEPORT:
X			change_repair(w);
X			break;
X		case REPAIRSELITEMPORT:
X			if(w->state[v] < 100)
X				w->rep_which=v;
X			break;
X		case TARGETPORT:
X			if(w->state[TC]==-1 ||  !w->comp->ce) break;
X  			if(((w->comp->ce->cloaking) && (w->comp->ce->state[CLOAK]>=rand()%100+1))
X                || (w->comp->ce->exploding))
X			{
X				w->targeting = NULL;
X			}
X			else
X			{
X				w->targeting=w->comp->ce;
X			}
X			break;
X		case GRABPORT:
X			grab_energy(w);
X			break;
X		case SHIELDREGENPORT:
X			w->shield_regen=!w->shield_regen;
X			break;
X		case CLOAKPORT:
X			w->cloaking = v;
X			break;
X		case SELECTEPORT:
X			if(v > (w->comp->no_seen -1))
X			{
X				break;
X			}
X			w->comp->curr_enemy = w->comp->closest[v];
X			w->comp->ce = w->comp->cptr[v];
X			break;
X		case QUITPORT:
X		{
X			int add;
X			winptr r;
X
X			num_alive--;
X			num_npcs_alive--;
X			add=w->earned/3;
X			if(num_npcs_alive)
X			{
X				add /= num_npcs_alive;
X				r = first_win;
X				while(r)
X				{
X					if(!r->exploding && r->npc && r!=w)
X						r->earned += add;
X					r=r->next;
X				}
X			}
X			w->earned = w->earned*2/3;
X			
X			if(w->npcwin)
X			{
X				close_host(w);
X				num_npcs_windows--;
X				w->npcwin=0;
X			}
X			w->exploding=1;
X			untarget(w);
X		}
X			break;
X		default:
X			xmpb_error("Unknown Output port");
X			break;
X	}
X}
X
Xload_npc(w,name)
Xwinptr w;
Xchar *name;
X{
X	int i,start,no_vars,no_ins;
X	FILE *fp;
X	char fn[100];
X	struct header h;
X
X	parse_shop_contents();
X	strcpy(fn, NPCDIR);
X    strcat(fn,name);
X    strcat(fn,".no");
X
Xseteuid(euid);
X	fp = fopen(fn,"rb");
Xseteuid(getuid());
X	if(!fp) return 0;
X
X	fread(&h, sizeof(struct header), 1, fp);
X
X	strcpy(w->Name, h.Name);	
X	strcpy(w->Ship, h.Ship);	
X	w->energy_max=h.energy_max;
X	w->ls_max=h.ls_max;
X	w->rs_max=h.rs_max;
X	w->bs_max=h.bs_max;
X	w->kills=h.kills;
X	w->last_kills = h.kills;
X		
X	for(i=0;i<NUM_ITEMS;i++)
X	{
X		if(h.qual[i] == -1)
X		{
X			w->state[i] = -1;
X			w->quality[i] = 2;
X		}
X		else
X		{
X			w->quality[i] = h.qual[i];
X			w->state[i] = 100;
X		}
X	}
X
X	for(i=0;i<NO_WEAPONS;i++)
X	{
X		w->does_have_weap[i]=h.does_have_weap[i];
X		w->weap_on_status[i] = 1;
X	}
X	w->comp = create_comp(h.no_vars,h.no_ins,h.start);
X	fread(w->comp->text,sizeof(struct ins),h.no_ins,fp);
X	fread(&(w->comp->no_states),sizeof(int),1,fp);
X	for(i=0;i<w->comp->no_states;i++)
X	{
X		fread(w->comp->states[i],1,MAX_SYMB_LEN,fp);
X		fread(&(w->comp->stp[i]),sizeof(int),1,fp);
X	}
X	fclose(fp);
X	w->energy_curr = w->energy_max;;
X	w->ls_curr = w->ls_max;
X	w->rs_curr = w->rs_max;
X	w->bs_curr = w->bs_max;
X	w->shield_cnt = 3;
X	w->curr_weap = 0;	
X	w->comp->curr_enemy = -1;
X	w->comp->no_seen = 0;
X	w->comp->ce = NULL;
X	strcpy(w->comp->fname,name);
X	
X	{
X        int first;
X        int cw = 0;
X
X        w->curr_weap=WEAP_PULSE;
X        first=1;
X        while(!w->does_have_weap[w->curr_weap])
X        {
X            w->curr_weap++;
X            w->curr_weap %= NO_WEAPONS;
X            if(cw == w->curr_weap && !first)
X            {
X            w->curr_weap++;
X                cw = -1;
X                break;
X            }
X            first=0;
X        }
X        if(cw == -1) w->curr_weap = -1;
X    }
X
X	w->credits=h.cash_earned;
X	if(h.cash_earned>0)
X		w->ship_value=h.cash_earned/(1+h.num_played)+350000;
X	else
X		w->ship_value=350000;
X
X	return 1;
X}
X
X
Xcansee(w,t)
Xwinptr w,t;
X{
X	/*
X	** can w see t?
X	*/
X
X
X	if(t->exploding) return 0;
X	if(t->quitting) return 0;
X	if(t->sx < w->sx+PLAYW/2 && t->sx > w->sx-PLAYW/2 && t->sy < w->sy+PLAYH/2 && t->sy > w->sy-PLAYH/2)
X		return 1;
X	if(w->short_range_radar)
X	{
X		if(w->state[SHORTRR] < (rand()%100))
X			return 0;
X		if(!(t->sx < w->sx+WORLDW/4 && t->sx > w->sx-WORLDW/4 && t->sy < w->sy+WORLDH/4 && t->sy > w->sy-WORLDH/4))
X			return 0;
X		return 1;
X	}
X	else
X	{
X		if(w->state[LONGRR] < (rand()%100))
X			return 0;
X		return 1;
X	}
X}
X	
X
X	
Xjamming(w,t)
Xwinptr w,t;
X{
X	int c,r,chance;
X
X	if(t->cloaking)
X	{
X		c = (t->quality[CLOAK]-1)*t->state[CLOAK];
X		r = w->quality[SHORTRR]*w->state[SHORTRR];	
X		if(c+r!=0)
X			chance=(r-c)*100/(c+r) + 50;
X		if(chance < (rand()%100+1))
X			return 1;
X	}
X	return 0;
X}
X
END_OF_FILE
if test 16260 -ne `wc -c <'pcomp.c'`; then
    echo shar: \"'pcomp.c'\" unpacked with wrong size!
fi
# end of 'pcomp.c'
fi
echo shar: End of archive 1 \(of 8\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
