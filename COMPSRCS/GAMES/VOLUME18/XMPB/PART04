Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i004:  xmpb - multiplayer space combat for X, Part04/08
Date: 26 Jun 1993 00:32:45 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2259
Approved: billr@saab.CNA.TEK.COM
Message-ID: <20g5fd$6sn@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1794

Submitted-by: ddp@deakin.edu.au (Damien De Paoli)
Posting-number: Volume 18, Issue 4
Archive-name: xmpb/Part04
Environment: X11, Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 8)."
# Contents:  bitmaps/title.bmp.Z.uu handle_ev.c radar.c shop.contents
#   test.c
# Wrapped by billr@saab on Fri Jun 25 16:30:15 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'bitmaps/title.bmp.Z.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/title.bmp.Z.uu'\"
else
echo shar: Extracting \"'bitmaps/title.bmp.Z.uu'\" \(8704 characters\)
sed "s/^X//" >'bitmaps/title.bmp.Z.uu' <<'END_OF_FILE'
Xbegin 400 title.bmp.Z
XM'YV0(\B4,9/&31D0=-+085/FRYTT9.B@ 3$CAPT% 0<6/)AP84,T9=*<04,'
XMA(P;,!3,H1,FX1@08]"$D8-0(<,O8A3.V=(%1 \0>Q2 & H#CQDS+$ 4/9IT
XM*5*E1I\Z;1J5*E.H5Z=BE5IU*PNA1+MJ'2NV;%:S7,^J38L4K->W9-=:93NW
XM+ERT7X?>E;N7;E^[<>FZ#0P8[]_#A+T.-IRX,>/'<A?S=3P9LE_"DB];+ERY
XMLV"]E#5[YBSZ<]C1B#>GC@Q:=6C2L/]FCOUZ=>FZLVW3=KTY=^W?O%F?OJV[
XM^&O?P8D#%VX\^>[1R%$O5XXW.G7ISA6WQL[]^FWKS[V'Q[U=?//NY(>//V]^
XM*GCVZX^7CY]]>E[U\//+QV]??^_Y_J&GVWO]%5@=@ 8*N%^ [3E'8'T0,I=@
XM@^@]J&"$IC%(7X4(8KCA=QU>*"*(_'FHH78ECO@A;!92Z&)Z)T[(8H@OQEA5
XMBRMJB*.-'*98HXPH\OCC@3[F"*1[-!II(I)%"KGBCD<ZF*23\$&YI)1-1JFB
XME2I6.:66+W(Y9(]4@GE?F5<R)::29)KIY)IH2ICFF!FZ:2:<=A(9)YUGYMDE
XMDWNRV=:7<SY)Z)\>XEFH;(?RZ666B]JG**+0-2JHH9!2&J:E@3*:J:.2<NHG
XMB9W*."FH>HYZZ:F7>EIJHJ)&^M^GK89*ZZMR:EKKC;'J.F"OJ%9ZJZJN$FLJ
XML+L*B^NFP\JJK+&P-NOK@M!NB>RR?3K+)ZN!<JNJM]IF.VVAX(ZKYK75#BIM
XML*2FBRFVC\)KJ[Q8TMMFN#JBBR^@[L;;[[S_UAOPO>9NJV_!, XL7KGLBMMP
XMONLFV^Z^T=J[\,$/\TNQM1%CR[#$#H,,L<7C??PFQB)KC/#("N\V@[I0P0 #
XM53.4014.,]\%0PR[X;S;#6G9'-T,A<7 E<Q6X4!5#@9W[*[)=Q** \]WE9$S
XM63#<8)7-4 %-E=4SAI7UUH6503597L=\-1Y@0S5UR2AW&_>W^N) ]%Y*ZQPT
XM56DO-?.#1I-=]=F0K3T&X3AH'63+OSJ],<QY)L[9&(7!D!;EB[ULU=J5:8X5
XMUTN18=7=E*TM^6(X9%PQX]0^?C-7?1M%^>)X6&[5[$5Y[K?+>V,E>N-8K3VV
XMVZH_Z[J_QSMF.U2:2P9Z6<LOE7=1@0?/N^!+X<YKIL)SE7K*V[\* ^FU"V\^
XM54@OAK3:Z'->?)UX5$_]\Y71D-;T>#"]^?6?BZL]=]U[W:KF!J&=M>^ ZCL?
XM^Q98E/4590SN&R"D=(<''-!/,_;;'U3T9[UBX8&"-Z#?_ZX30.+!S7$K:R#/
XM$GA !I:OA0U48 QO=T+_Q&X,(RS,&-)B.!YFZW W(Q\%:_:UM95!<:5#G_?@
XM!T'T(1$/-\"?&0Q'N+/$( <2U!GA'/A"%W+QBS+L8E':IC)4Q8Z,C]GA_A:C
XMQ@X^\(G?8QY78O \&Q@Q@GLQG=90!SOOE7 I],.B"^57.RE>,&&\B9X8%PE&
XM&#+R?*C#8[4D&;X'<L5L7WOB%*DR!CAR!80B_%H5X;=)MWF29D=['B'-\+PH
XM4H6.?'N>##@G- +&KI%>#&/Z6H/+&=(+DP]JXQ@)=T0-OE& <HPE#:%2!J)9
XMB(K(I-X</]F[W&F/@JS,%DJP)RL#YK*((=.9+CF70Y:5I8FI$28>@,A,\I7R
XMF"9,9M=J>1KM-7,W7$1C'*7Y2FHJDWF8:TWLS/ _*:IN? CD)24K0\A>&L6@
XM-00..AVCSC&XTYV&.V7F8!?*=N*3<_C;9_RFR3?(05%[L.S:Y9(&OG.)[8E<
XMG&@!P_C.5$$H=CB0P6[4:3>K5/%OK>ED-#_(T66.D7P(Q8H4*2G2YO'RB;&[
XM 4J?QT6"LM2<E1F>+\>X4.IH=9%@@QI1G;A3[^UQ.X+<'52$&L_<%14K]D2J
XM.Y>*2)&>A8NQFP'^4KI5V5VU=1?Z:E6[BD^3YI.P_FGHQ-3Y53.DU2@9'2HH
XMC<HV=Y*2J?Z$2@P@RCS\<9 R$!6K8$$:T;(TU'"(-9!(;><\'1YMI6Y<YRGE
XM69004O:>SRR,2 G)U[+,8&V?M:D9.)NGT?ZUDKRA8$Q3*S#9]I.R9V$L;-4*
XMSZ(TM:B2B>MS,#O457(E!X337W2J2-QNPA2H]532+4W'W%QIYIZT?:AKG]N_
XMV++5NB:=+%R_9EG.<+>M(ZTKX;"9EL<.MZ6&/2]TA\1%GWGP0O!UZW&C2]+Z
XM[HZ-LY7P/&_;WSSJ=HG9\FX04<E-JRHUB\I3\'YMU&#TQHEP Z6D.@/7VMA*
XM+F9/U&]1R*#=U420CTH,,E;$P$GR1?5_!2UM8%6</137;HOMI=#:SOCCUMQ8
XMP[6]Y!\+^<I6VA.:=_':8M!XUR?REIR<U.31IDR_*J-0,\:U\*Q2X\V^(HJ"
XM,F6ME2E9YP^BU(_T?2!5-3EE2':(D [&VH"O^;_G%?,N;].L2<E\4"8;Y9"*
XMZG-5FT8RX+&N+(\N(X+QJ> :1TG3449D"E>7O.9&N-7&BS,@=X7JL'4:L.][
XM%V4Z_#1"R?K2M(9R.#_MWE$C3T2C!%FFD4I+)]?ZULA=-<=L9%<#,PM-2;7S
XMQ2#U[%Z_>=1BO>O]E)SKF#';U@;J-KD(B+!P>W6ZT2ZW\LXM6L2EFG;2OC:Q
XM-4/C[1P2VBXUMR/'U>=$"U?>S<VWKF&];3H+&]OV'C;#T3UQ3U<<U_0I^+U;
XMUV)C8QS@I$0XP5"E\85G%;4>CW?*[S78E4],X3&+^(.ILUY.\MG2RU4UR7]J
XM\J/AG)*8U-FYO\D^%KKPP.*+.+AJSLR;.W*789'IJOM<TV+3>9S'#3K6ACY#
XMH_?5H4BGF]C8NROE<L[I7E^DU ]Z=HECQ^Q/OR,XM9@MA]J=IN4=>>7(;J/3
XMKK%#<#]Z.:,V=F,6<,V45:3!P]HA==\][A-^>8-RSF+#DO;J ^<TVA#?="5]
XM=>TEK;O<Q9GY@0O/TF%7.8M1?FR?#WSPT),YP'C#=*YZGN</ZC.E';G[H^,/
XM[I+).\E9CYE897N1V:0S^4"/[R$%WO;(JZKPR;I6/J.9]/M%CO13GG-PJ1L[
XMQV?\MU/S?+81%CFU!S:=N2+3]"=?8U6%_?&K;D;+VUR]G+=NJM5'OM[GR>^=
XM9R7EAQV$U'Z EGO7AS6$YF1GD7[,!QP "'VB)G2&-W6&A3\/^!@#2!UXYF)8
XMMD[,%7^5XT,6AQWIYW^)1&_;,7T4&%NZHGU'HST9R%" 9G$WM#84A()WE8"F
XM18(3:" GN'%CE78BV!SS)X0!!QR")8-"J$B@]R W&&B0]5$EYD^2@80TEW_F
XM1W$[Z$@&%U@8Q84,!E//,X-P9E)FV#-KLTKEY7[T=!?8A(7\\W4>^$B0YT(Z
XMZ%5SY78DAU1E>'Z-]T1IF!J1UD#PUH#V)V>(6(&HXE2%1W1T>(=-%GWDQ7WD
XM@VAU"'Y/E(<]LT5[@WY:^'Z%PX"9%8F0:(=')WF54XE)%V(UJ(2;*(=NXTR\
XME(4#]V]DP8G--X>H:(J^B'R9.'FL2'B0MH:OF$BQ2&XC9DH_$XJX"&K)!B[E
XM]WC?E'9?*(R1IXSI9(PWTX3)N(N$*(AJ5A@;2'%:)RO3B'5$B'4KIH3#>'#T
XM$862UHT9=U91)XL-)(B\YENA:%*5\6KC$H%3:"6_MGU&B&9B164DEHHZ1WT/
XMA(^UTR".R)#0UF^/2%T%]' 2.&=V!GMWIF4+V77&!T<0:3QG48X><VBAR(+*
XMHX5/Z&L\."YQF"THF6*EUWJ\N&G*%BL"F7H74G.1E'$QJ7D!%ELU^1B_)HI6
XM9R!'J7>)M9(])XF)-)3:2!9L&)+(YU6H%XS@@XE5V4U0.7/XI)'JISS-)I9&
XM.&XJ=8ND)GKW]RI>"8X!HTC;YWU<YU=AYHQ\Z'F:I#UNV) QHX55]8R(8I%N
XM4Y(DEXC20VNH!WMBIE!5R)B4!93^5EA227]1.8^'Z7* :8BO)YF^)W%_B6WN
XM](99QI:I(9!@IXJI>8SM9GRAZ)&3IYCRE9>H28P-5)JA=W2$68J]B'Q*XWWL
XMAYA[F9:?B9.!.7!MJ)?(J6A4V(Z/D7Y0YT+7Z'G#^94$UYAB:)E'1TE-&7+T
XM48A(294>Y'@T)9O<^9"=V6I)&5#CYYG=28[]6)RJ%8)4F7L_QWL0J6?WR)ET
XM9H^\26NAZ)VT.2[R:);^0Q^J&4;5B9;PJ9XDHWVHUYL9-Z 2]YWX]Y8_B'SH
XMB7FG.)CT"3W7*3?-DI04:IQIAYGQI9,V,I$;F57ON&20EZ(L"3W?>"SO63MW
XMJ90-AS46"H>NJ6_\.'?*$Z,229M@YXU$RI$4<WP@ZJ!(^:-6&:3;V9J,N(K9
XM"*5W=9>'58]+FH07IZ.E)YRF5S14"BZK%()&&J*=(YC$AXS9HHMS28L7"99E
XM>A>&J7_@HT@^"6<KM()[2I9I**%?*G+^>#0[FIAEBAQQ65QNZI;QB6U:Z#,$
XM>:/A0I")*J"0BI%61*4L!J"_F*3@\YAUVJ#S=J7-F9$W.7OB=J<^JJ&LMJ52
XM*:I8Y:?T:(1A6(('198FJ97*.8*PVJOXQ*7LR*FLJ83D8ZI(F:L;"G,J=*O-
XM.GFH5UY.Z&8LEFS*=Z6H,X[^\57*FE5TZH*&BJ5!B6W3"JQL1)R0AJVG.F9,
XMQ:WIYJD;>H3^.:^RUTT[ZIYZ$ZRH,JB-UW].5WGT2)!K>C(ERG?%%:X=":S5
XMQR;P"H)LZGJ=IS,/RW+RBI0%RZH,AK"Q>C2\^HQ?):=II+!0!))&:*EE%IER
XM*:+0FD@9"X_8]J;"ZG"W::.%6J7#M)LOZJL3JX!DDVD7"Z/9Z&[/":'1*I2K
XM:K,]JWJ.@48S>;+\6G?5='@M"WY_>AHUZJPOE*Z[(ITA"*I;V!P*J9G&VI9<
XMNZ_0&5@C6GPE0G59VS"+X8#J>IK4::T^N[1OYX-%N9A06JT,.XGQ>G\$29ZX
XM&9TN.;=C571[-JRHZAAI*F1-1I!KR[(G%GV3"WZ$FW -(K=.)I"#F)N-&Z4L
XMI3Z'^&Y1FYSBNIXIB[=>E;E+>26<JZN58VDB2Z\6UUCXTU@G^JJ;B;87IB\A
XMVX3WR6X<>+BJJX>NNJS:ZFONI#WSM[N4JZ>THT@B"ZZA>W()"FW %U2(2ZOM
XMNAW"FWBZV1QY6D%\=KG86+ELNY:"5Z_(Y;D0Z;5#VW@\EQJC^:R*")YD:[Y_
XMR[_=2EI0R)QB9Z5U:YTS6IDTJ[Z/T9-49;>\T9.OE;250:KM:[\"W+$5>IF3
XM1[*K.999RKM]1<':IJ#SB;H+N[(#"+WWRZ39>9GHN5%2^:UPUG;9FG;NUR 0
XM#+E;"ZCK)\&:D<+'NZ?$*K@P*975*Z5,NT@&!\3&&:"+(9"U*XA"N+WI!6V-
XMM(ZS6JQ3:,$)%18H*) &Q\ 9G*)_ACXA99\WZT$]V:'_AZ1:3(V_:&+KRT\%
XM3'=UG(_'.<?0LZ-[-4>Y>WET;&<.G%7G2J)V'*IOK,75B9]9+)5Y1I;BQ\6G
XMB$:$)%6-K+A5[([Z28I%^YMP[,F9R%SR^Z&)O*E9:::7',AX&8E8#+6DO&!!
XM?)"I#,JFS**.,<J(W,6O3)$@3,O[FTW\Y\A*NLN12[Q[-\O3F<LV]*C5")G$
XMK,0AR,PB&1:KI$K27)NP>,!U*L=A"J9:ZY3[%LN:W+LX"G(XV\WZ&\XK^\W'
XMBL[B[,Y$6ZON.[/J?+3F',_E7,\PJ\_>/*ZR:\[K[,]ZS,[8*=#[[,X!/<_I
XMC-#V',[XC,$ W=#P;,P&&]$'3=!::M"OB]$#K='MS-$7[='O#-+]K-#G3-(+
XMC=(C+=(//6W\G-(BG=#W3-&%J](9;=(R[= TO6XY^IH]#;<[_8)!390VW=$X
XM;=067=))?:A''=)-K=0O';$FW=)"6M1./=,_O9-97=%1G=,3O=4U'=-('=54
XMG9ED/=2<O-12':%H+<]J7=:IJK4 "=-/S=1OW=;YS-"@!K96O=%BG<1];==G
XM72*A]M5J[=4J#=<:^QS[Z-.'+=&)C=<0G2"-7=5_[==UO=8MT]*5?=*7+=AZ
XM#=6A#=I:6Q$W8P-IIMD3I]B:F]F(;=!7E"TY((.?K=H$S=K@/-H25P:/-=N<
XM-*ZXW:.Z_=I3W2O 94\5:]FN#=DL+=DNG2:,9A7)[=F9'=P%7=V2;<G,0S^=
XM;=W_/-B/#=@(9UO;;15$YMT?!]Y=S=PIEU>FF;A+86W%#=8\'=ZB'=C:]%VM
XM5+K@YMS*?=?T+=20<D.HS;ZSQM7#S=YL'>!$O;EZ.U#0B]E8;=^D7=NL36#4
XM/>'K+=[8S>#T(09TK>$)SN$BCM^T$USXC=XL7-O$O>"I00:=;<@;?M\6[M]F
XMS1MSK=44;MO ;>-Q7>,>[M;J/>(TWN$[KN+TK-M(_M% ?N0^OM@ [N1!GM<F
XMKN!,>4E2-'U64LGX4[UOR^.<N>09#BW!!9!8M'13ZUC/(=]B?M,ESN*6%*>:
XM)-_+7&)TKC)W;M@S7N%&3A;J9 9]679I'IR'\N4(7N4DKM/-\N>!WJ*DS<:K
XM?*E/WMI1'B5VQ=_?#=]F >G<_-R(7N1OWI5]M#3/. :$'A9ZQ1E]K+,51 .I
XM#6#:#;A7K>A27I%OU4"H#<-K5> -]%A$A!4ZM4&COD%ER!4V<(F!!.8I.>63
XMK=<N>E(T$P9+<TE0%5[<+85<E /%SC=G'E3)'NJ53N2@G5?1O5;4SC<8^.U%
XM$5RQH^URSC?VQ.N1KG!M/M9*KB^I#A5BX&B:9&2T35G?H^NYTTI054>:%.'"
XM_>E\#NY1DN_KSN]\(T3.R]?LYYL@)$3/TU-"?N_,[NG%0V3,T]MI860D^^MC
XM]+#J-$2?!/(?: 8Q;N6K/>FY_<TL'S\B+RY&]GL0/V2OKLI#]%A\ZDZB4^^S
XMKN=$WNUAD0./I4XW($0WSTQSGDG3SNHSH#TYP-?-V^?BKNS>MA?AI3T9-(M4
XM(0-/_T#RSLV%S>[Y]3PY@#\V$.P'WO5[SO6N0Y U0.I#=5\?1#B*Q4UOHSX%
XM_T_4,_']W?'_/>0*K]H8+N-;3_023NM1 N(Z/O>.'^*03S$HGO!PGNA&G_@J
XM#N-CWOF;#^J7C^BX)?.:O]R<']F&?^,ICOK7S? <7^N4#_N9_OJM_^-:[_FV
XMG]ZS7_NY#^6(CRHYKONRC_NTWVICD.>/+_JJ3_K.#VTXM-+SG?R\'_S--?WA
XM?OW6/_H+/T:N[N+ W_W/__VCR/C</_[J[RR&;N_(O_[I3S$#Q>GFS_KDO_T&
XMK5R-1O?TWOLK7O[\3W4$O-90]0!@Y:-^XJ_Q=0B]I_2J'_SS?@&P\#6'5[/\
XM). #-(#^+\F)B/[#KBC=\,. V&_F!8N+$OM*'P0\@"W.3_2?_H("8=YMRX!,
XMKJD5$S921>B?!52 (3#UX3\=!@/H!\)+:Q]P!PK!($@$?Q\.O']%\/T=P0LX
XM!(U@_'N")Q &AC[[QP238).K@DXP"N; $AC]K.#NTX)(, N"P#"H!*'@&,2"
XM97#SB3#D\P,_%3@!'.AKITPW-V<"SV!T,C#MSRR\/.027*Z,X>HR].'/L4 I
XM2 >[8' P,!V0.PQ"2!%<1(QM*F_-08U(ACWX K?@[1L34H026K['<%UXD<DK
XM2TFLL%'!)0AK>HS[&Q(I+\U9/'\$O41AKFF!JT_D:!?6E@HCD\#3=-C!%0)!
XM,6C1UB#:2U9S!+GYE*PC1,J+WGMVY$W6\1;?9 ;@WCHA@0I, UY!4KB(%!'Y
XM.'8T ^P1$\ZQ]'*7@7EOA8V"K)*R5T$RC%$(+YG0*K Y0G@*OV S*C%&QM=E
XMO)U76Y;>>[L!580>:KH_]U@("1HI;#? U_T/DJ7FFF :S%"*",9,E=\F]3*'
XM,.P:AD3J[2]1:/5$@].C2?2C!CI :J@ZL$DKD8=3;\RDA1PS$.%=V2 ?P<4&
XM'+RAXLT$(E8JB++.L:%!A+/X:LNI@X3X12+6EDODE\I=7 "&RTAC_+D"\TK*
XM6-<P,#:P$(Y"1/?L3M(UJ7@Z$8J@Q/U&,PC3\O%'^V@H4A;?)NRXG<IJA\=O
XM&G8JJJ<]1(HZ 8A3D2K8@$^":;8#X=![+L\J_([JXENL7L:#'1$Q!<8\2^C[
XM*D-P47E+8Q/U.YI!#D^";!,-!@8:RCI="!5J@%UDB%!!!NBK=0<&9R)]Z(.^
XMJ>U]C;-'/LA>B*EY,P EICD\J!;'U\DK#'8DVL4I(1+^UEW-JX1DD.18JM@1
XM X3A).0;BX9FK#H#QP8=4ED03V *'YI$!180ET92%'Z\T N&17=H$,5B9>2(
XM=M ,-D?FJ!SKX'1<CMC1.E9'0W@0KZ-V3([@L3MNQZ7X'*7C>&QN?/'_>4?N
XMZ!RC8WE\C^XQ/JY'\B@?S^-&-(_AL3W.1_08&ZEC?O2/XO$_9D?V""#UHWU,
XJ@/@Q0"I( RD@O^."+) 0<D#2Q_UX'^$CA420%O) ;C9V6/106A_8 0H 
X 
Xend
END_OF_FILE
if test 8704 -ne `wc -c <'bitmaps/title.bmp.Z.uu'`; then
    echo shar: \"'bitmaps/title.bmp.Z.uu'\" unpacked with wrong size!
fi
# end of 'bitmaps/title.bmp.Z.uu'
fi
if test -f 'handle_ev.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'handle_ev.c'\"
else
echo shar: Extracting \"'handle_ev.c'\" \(11684 characters\)
sed "s/^X//" >'handle_ev.c' <<'END_OF_FILE'
X/* handle_ev.c - *** Handle X events */
X
Xstatic char sccs_id[] = "@(#)handle_ev.c 1.27 92/11/24 XMPB";
X
X#include "player.h"
X#include "save.h"
X#include <X11/keysym.h>
X#include "save.c"
X
Xextern int euid;
Xextern int no_hosts;
Xextern int num_alive;
Xextern witemptr first_weap_item;
Xextern winptr first_win;
Xextern int num_npcs_windows;
Xextern int num_npcs_alive;
X
X
X
XXEvent xe;		/* the X event received */
XKeySym keysym; 	/* the keysym decoded from the event */
X
Xint num_quit=0;
Xchar buf[20];  	/* dummy buffer for XLookupString */
X
X/*
X* handle all the events for player w
X*/
Xint handle_events(w)
Xwinptr w;
X{
X
X	/*
X	*	Only get the events for this window that match the eventmask
X	*/
X   	while(XCheckWindowEvent(w->theDisplay,w->theWindow,EVENTMASK,&xe)) 
X   	{
X    	switch(xe.type)
X    	{
X			/*
X			*	A mouse button was pressed.  Once we know which, we
X			*	the appropriate variable in the player structure
X			*/
X        	case ButtonPress:
X            	switch(xe.xbutton.button)
X            	{
X                	case Button1:
X                    	w->b1 = 1;
X						w->cloaking = 0;
X                    	break;
X                	case Button2:
X                    	w->b2 = 1;
X                    	break;
X                	case Button3:
X                    	w->b3 = 1;
X                    	break;
X                	default:
X                    	break;
X            	}
X            	break;
X
X			/*
X			*	Same as for ButtonPress
X			*/
X        	case ButtonRelease:
X            	switch(xe.xbutton.button)
X            	{
X                	case Button1:
X                    	w->b1 = 0;
X                    	break;
X                	case Button2:
X                    	w->b2 = 0;
X                    	break;
X                	case Button3:
X                    	w->b3 = 0;
X                    	break;
X                	default:
X                    	break;
X            	}
X            	break;
X
X			/* 
X			*	OK, a key was pressed, which one eh?
X			*/
X			case KeyPress:
X				XLookupString(&(xe.xkey),buf,10,&keysym,NULL);
X				/*
X				* 	Turn Anti-clockwise
X				*/
X				if(keysym==w->prefs.turnLeft) 
X					start_turn_left(w);
X
X				/* 
X				*	Turn Clockwise
X				*/
X				if(keysym==w->prefs.turnRight)
X					start_turn_right(w);
X
X				/*
X				**  Change view of deaders
X				*/
X				if(keysym==w->prefs.changeView)
X					change_view(w);
X
X				/*
X				*	Quit Now
X				*/
X				if(keysym==w->prefs.quit)
X					quit(w);
X
X				/*
X				* 	Change radar resolution
X				*/
X				if(keysym==w->prefs.toggleRadar)
X				{
X						w->short_range_radar = 1 - w->short_range_radar;
X				}
X
X				/*
X				* 	Change which item is being repaired
X				*	only damaged items can be repaired, destroyed
X				*	or non-existent are skipped
X				*   idle means nothing is being repaired
X				*/
X					
X				if(keysym==w->prefs.changeRepair)	
X				{
X					change_repair(w);
X				}
X	
X				/*
X				*	Toggle shield regenerating
X				*/
X				if(keysym==w->prefs.toggleShieldsRegen)
X				{
X					w->shield_regen=1-w->shield_regen;
X				}
X
X				/*
X				** transfer the energy from shields to energy bank
X				*/
X				if(keysym==w->prefs.grabEnergy)
X					grab_energy(w);
X
X				/*
X				** okay, lets toggle cloaking
X				*/
X				if(keysym==w->prefs.invisibility)
X					invis(w);
X
X				/*
X				**  Balance the shield energy
X				*/
X				if(keysym==w->prefs.balanceShields)
X					balance_shields(w);
X
X				/*
X				*	Toggle who we are targeting
X				*/
X				if(keysym==w->prefs.changeTarget)
X					change_target(w);
X
X				/*
X				*	Toggle current weapon on/off
X				*/
X				if(keysym==w->prefs.toggleWeaponStatus)
X				{
X					w->weap_on_status[w->curr_weap] = 1 - w->weap_on_status[w->curr_weap];
X				}
X
X				/*
X				** Simulate buttons down
X				*/
X				if(keysym==w->prefs.fire)
X					w->b1=1;
X				if(keysym==w->prefs.changeWeapon)
X					w->b2=1;
X				if(keysym==w->prefs.thrust)
X					w->b3=1;
X				break;
X
X			/*
X			* 	A key was released
X			*/
X			case KeyRelease:
X				XLookupString(&(xe.xkey),buf,10,&keysym,NULL);
X
X				/*
X				* 	We only care about the rotate keys so we know
X				*	when to stop rotating
X				*/
X				if(keysym==w->prefs.turnLeft)
X					stop_turn_left(w);
X
X				if(keysym==w->prefs.turnRight)
X					stop_turn_right(w);
X
X				/*
X				** Simulate buttons down
X				*/
X				if(keysym==w->prefs.fire)
X					w->b1=0;
X				if(keysym==w->prefs.changeWeapon)
X					w->b2=0;
X				if(keysym==w->prefs.thrust)
X					w->b3=0;
X				break;
X			
X			/*
X			* 	Blargh, an expose event, clear the screen the next
X			*	frame will fix the exposed region
X			*/
X
X			case EnterNotify:
X				XAutoRepeatOff(w->theDisplay);
X				break;
X			case LeaveNotify:
X				XAutoRepeatOn(w->theDisplay);
X				break;
X       		case Expose:
X				xfe_clear(w);
X            	break;
X			case DestroyNotify:
X				bad();
X				break;
X
X			/*
X			*	Obviously an event we don't care about
X			*/
X        	default:
X            	break;
X    	}
X    }
X	return 0;
X}
X
Xsave *load_dude(name)
Xchar *name;
X{
X	int i;
X	FILE *fp;
X	save *temp;
X	char fn[100];
X
X	strcpy(fn,SAVEDIR);
X	strcat(fn, name);
X	strcat(fn, ".xms");	
X
Xseteuid(euid);	
X	fp=fopen(fn, "rb");
Xseteuid(getuid());
X
X	if(!fp) {
X		return &(default_save);
X	}
X	temp=(save *) malloc (sizeof(save));
X    if(!temp)
X        xmpb_error("Not enough memory");
X	fread(temp, sizeof(save), 1, fp);
X	fclose(fp);
X	return temp;	
X}
X
Xsave_dude(w)
Xwinptr w;
X{
Xsave *temp;
XFILE *fp;
Xint i;
Xchar fn[100];
Xchar buf[200];
X
X	strcpy(fn,SAVEDIR);
X	strcat(fn, w->Name);
X	strcat(fn, ".xms");	
X
Xseteuid(euid);	
X	fp=fopen(fn,"wb");
Xseteuid(getuid());
X
X	if(!fp) {
X		perror("Can't open save file");
X		xmpb_error("Fatal xmpb error");
X	}
X	temp=(save *) malloc (sizeof(save));
X	if(!temp)
X		xmpb_error("Not enough memory");
X	strcpy(temp->Name, w->Name);
X	strcpy(temp->Ship, w->Ship);
X	temp->energy_max=w->energy_max;
X	temp->ls_max=w->ls_max;
X	temp->bs_max=w->bs_max;
X	temp->rs_max=w->rs_max;
X	temp->credits=w->credits+w->earned;
X	temp->kills = w->kills;
X	strncpy(temp->password,w->password,9);
X	temp->password[9] = 0;
X	temp->ship_value=w->ship_value;
X	for(i=0; i<NUM_ITEMS; i++)
X	{
X		temp->quality[i]=w->quality[i];
X		if(w->state[i] > 0)
X			temp->state[i]=w->state[i];
X		else
X			temp->state[i] = -1;
X	}
X	for(i=0; i<NO_WEAPONS; i++)
X	{
X		if(w->load_status[i] != -1)
X			temp->does_have_weap[i]=w->does_have_weap[i];	
X		else
X			temp->does_have_weap[i] = 0;
X		temp->weap_on_status[i]=w->weap_on_status[i];
X	}	
X	fwrite(temp, sizeof(save), 1, fp);
X	fclose(fp);
X	sprintf(buf,"chmod 600 %s",fn);
X	free(temp);
X}
X
Xclose_host(w)
Xwinptr w;
X{
X	char buf[80];
X
X	XAutoRepeatOn(w->theDisplay);
X    XCloseDisplay(w->theDisplay);
X    XCloseDisplay(w->radar->theDisplay);
X    XCloseDisplay(w->stats->theDisplay);
X	if(!w->npc)
X	{
X		strcpy(buf, SAVEDIR);
X		strcat(buf, w->Name);
X		strcat(buf, ".lock");
Xseteuid(euid);
X		unlink(buf);
Xseteuid(getuid());
X	}	
X}
X
Xhandle_quitting(w)
Xwinptr w;
X{
X	char buf[10];
X	int add;
X
X    XDrawImageString(w->theDisplay, w->theWindow, w->aGC, 20, 20, "Are you sure you wish to quit (y/n)? ", strlen("Are you sure you wish to quit (y/n)? "));
X	while(XCheckWindowEvent(w->theDisplay,w->theWindow,KeyPressMask,&xe))	
X	{
X		if(xe.type==KeyPress)
X		{
X			XLookupString(&(xe.xkey),buf,10,&keysym,NULL);
X			if(keysym==XK_y)	{
X    			winptr t, l;
X				witemptr tw;
X
X				tw=first_weap_item;
X				while(tw)
X				{
X					if(tw->who==w)
X						tw->who=NULL;
X					tw=tw->next;
X				}
X				add=0;
X				no_hosts--;
X				if(w->quitting==2) {
X
X
X					num_alive--;
X					num_quit++;
X					untarget(w);
X					add=w->earned/3;
X
X					if(num_alive && num_alive!=num_npcs_alive)
X						add=add/(num_alive-num_npcs_alive);
X					w->earned=w->earned*2/3;
X				}
X                t = first_win;
X                if (t==w) {
X                    first_win=w->next;
X					if(!w->npc || w->npcwin) close_host(w);
X					t=first_win;
X					while(t)
X					{
X						if(!t->exploding && !t->npc) t->earned+=add;
X						t=t->next;
X					}
X					return 1;
X                }
X				else 
X                while(t) {
X                    l=t;
X                    t=t->next;
X                    if(w==t) {
X                        l->next=t->next;
X						if(!w->npc || w->npcwin) close_host(w);
X						t=first_win;
X						while(t)
X						{
X							if(!t->exploding && !t->npc) t->earned+=add;
X							t=t->next;
X						}
X						return 1;
X                    }
X                }
X			}
X			else  { /* not a y so not quitting */
X				w->quitting=0;
X			}
X				
X		}
X	}
X	return 0;
X}
X
X/*
X*	This obscurely named routine handles events for all of the windows
X*/
Xupdate_win_strs()
X{
X	winptr temp,t,old;
X
X
X	if(num_alive==num_npcs_alive && num_npcs_windows==0)
X	{
X/*
X		winptr w;
X
X		w = first_win;
X		while(w)
X		{
X			if(w->npc)
X				save_npc(w);
X			else
X				save_dude(w);
X			w=w->next;
X		}
X		exit(0);
X*/
X		winners();
X	}
X	temp = first_win;
X    while(temp != NULL)
X    {
X		t=temp;
X		if(temp->quitting>0 && !temp->npc) 
X		{
X			if(handle_quitting(temp)) 
X			{
X        		t = temp->next;
X				if(!temp->npc)
X				{
X					parse_shop_contents();
X					temp->ship_value=value_of_craft(temp);
X					save_dude(temp);
X				}
X				free(temp);
X				temp =t;
X			}
X			else
X				temp = temp->next;
X		}
X		else {
X			if(!temp->npc)
X        		handle_events(temp);
X			else if (!temp->exploding)
X			{
X			int i;
X				for(i=0; i < 20 && execute_ins(temp,temp->comp); i++);
X			}
X			old=temp;
X        	temp = temp->next;
X		}
X    }
X}
X
Xstart_turn_left(w)
Xwinptr w;
X{
X	w->angle_changed = 1;
X	if(w->angle_v > 0)
X		w->angle_v = 0;
X	w->tl = 1;
X	w->tr = 0;
X}
X
Xstart_turn_right(w)
Xwinptr w;
X{
X	w->angle_changed = 1;
X	w->tr = 1;
X	if(w->angle_v < 0)
X		w->angle_v = 0;
X	w->tl = 0;
X}
X
Xchange_view(w)
Xwinptr w;
X{
X	int flag=0;
X	winptr t;
X
X	if(!w->exploding)
X		return;
X	if(!w->watching)
X		w->watching = first_win;
X	else
X	{
X		w->watching = w->watching->next;
X	}
X	t = w->watching;
XBLURGH:
X	while(w->watching)
X	{
X		if(!w->watching->exploding)
X		{
X			flag = 1;
X			return;
X		}
X		if(t == w->watching->next && w->watching->next)
X			return;
X		else if(t == first_win && !w->watching->next)
X			return;
X		w->watching = w->watching->next;
X	}
X	if(!w->watching)
X	{
X		w->watching = first_win;
X		goto BLURGH;
X	}
X	if(!flag)
X		w->watching = NULL;
X}
X	
Xquit(w)
Xwinptr w;
X{
X	if(w->npc) 
X		return;
X	xfe_clear(w);
X    XDrawImageString(w->theDisplay, w->theWindow, w->aGC, 20, 20, "Are you sure you wish to quit (y/n)? ", strlen("Are you sure you wish to quit (y/n)? "));
X		
X	if(w->exploding) /* 1 = dead & quit, 2= !dead & quit */
X		w->quitting=1;
X	else
X		w->quitting=2;
X}
X
Xchange_repair(w)
Xwinptr w;
X{
X	/*
X	*	Got to the next one
X	*/
X	w->rep_which=(w->rep_which+1)%(NUM_ITEMS+1);
X
X	/*
X	*	Skip the ones that can't be repaired
X	*/	
X	while(w->rep_which!=IDLE && 
X		(w->state[w->rep_which]<=0 || w->state[w->rep_which]==100))
X	{
X		w->rep_which=(w->rep_which+1)%(NUM_ITEMS+1);
X	}
X}
X
Xgrab_energy(w)
Xwinptr w;
X{
X	int tot,max;
X
X	tot=w->ls_curr+w->rs_curr+w->bs_curr;
X	if((w->energy_max-w->energy_curr) > tot/2)
X	{
X		w->energy_curr+=tot/2;
X		w->ls_curr /= 2;
X		w->rs_curr /= 2;
X		w->bs_curr /= 2;
X	}
X}	
X
Xinvis(w)
Xwinptr w;
X{
X	w->cloaking=1-w->cloaking;
X	if(w->state[CLOAK]<=0) 
X		w->cloaking=0;
X}
X
Xbalance_shields(w)
Xwinptr w;
X{
X	int tot,max;
X	
X	tot=w->ls_curr+w->rs_curr+w->bs_curr;
X	max=w->ls_max+w->rs_max+w->bs_max;
X	w->ls_curr=((w->ls_max*tot)/max);
X	w->rs_curr=((w->rs_max*tot)/max);
X	w->bs_curr=((w->bs_max*tot)/max);
X}
X
Xchange_target(w)
Xwinptr w;
X{
X	winptr temp;
X
X	if(w->exploding!=0 || w->state[TC] == -1) 
X		return;	
X	if(!w->targeting)	/* not targeting anyone yet */	
X	{
X		temp=first_win; /* so set to first */
X	}
X	else
X		temp=w->targeting->next; /* else next */
X
X	while(temp && (((temp->cloaking) &&
X		(temp->state[CLOAK]>=rand()%100+1)) || (w==temp)
X		|| (temp->exploding))) 
X	{						/* watch we don't target 
X							* cloak'ns, ourself or deaders */
X		temp=temp->next;
X	}
X	w->targeting=temp;
X}
X
Xstop_turn_left(w)
Xwinptr w;
X{
X	w->tl = 0;
X	w->tr = 0;
X	w->angle_v = 0;
X}
X
Xstop_turn_right(w)
Xwinptr w;
X{
X		w->tr = 0;
X		w->tl = 0;
X		w->angle_v = 0;
X}
END_OF_FILE
if test 11684 -ne `wc -c <'handle_ev.c'`; then
    echo shar: \"'handle_ev.c'\" unpacked with wrong size!
fi
# end of 'handle_ev.c'
fi
if test -f 'radar.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'radar.c'\"
else
echo shar: Extracting \"'radar.c'\" \(10038 characters\)
sed "s/^X//" >'radar.c' <<'END_OF_FILE'
X/* radar.c - *** routines for the radar window */
X
Xstatic char sccs_id[] = "@(#)radar.c 1.17 92/11/24 XMPB";
X
X#include "player.h"
X#include "bitmaps/ship.0"
X#define BORDER_WIDTH 2
X#define RES_NAME "da" 
X#define RES_CLASS "da"
X#define RADARW 200
X#define RADARH 200
X
X
Xint worldw,worldh;
Xextern junkptr first_junk;
Xextern witemptr first_weap_item;
Xextern winptr first_win;
X
Xsubwinptr xfe_open_sub_window(dn,win_name,w,h,x,y)
Xchar *dn, *win_name;
Xint w,h,x,y;
X{
X    XGCValues       theGCValues;
X    XSetWindowAttributes    theWindowAttributes;
X    XSizeHints      theSizeHints;
X    unsigned long       theWindowMask;
X    Pixmap          theIconPixmap;
X    XWMHints        theWMHints;
X	subwinptr		temp;
X    XClassHint      theClassHint;
X
X    temp=(subwinptr)malloc(sizeof(struct subwin));
X    if(temp == NULL)
X    {
X        return NULL;
X    }
X
X    if(!strcmp(dn,"")) temp->theDisplay = XOpenDisplay(NULL);
X    temp->theDisplay = XOpenDisplay(dn);
X
X    if(!(temp->theDisplay))
X    {
X        free(temp);
X        return NULL;
X    }
X
X    temp->theScreen = DefaultScreen(temp->theDisplay);
X    temp->thedepth = DefaultDepth(temp->theDisplay,temp->theScreen);
X    temp->theBlackPixel = BlackPixel(temp->theDisplay,temp->theScreen);
X    temp->theWhitePixel = WhitePixel(temp->theDisplay,temp->theScreen);
X    temp->theCursor = XCreateFontCursor(temp->theDisplay,XC_crosshair);
X
X    theWindowAttributes.border_pixel = temp->theBlackPixel;
X  	theWindowAttributes.background_pixel = temp->theBlackPixel;
X    theWindowAttributes.cursor = temp->theCursor;
X    theWindowAttributes.override_redirect = False;
X
X    theWindowMask = CWBackPixel | CWBorderPixel | CWOverrideRedirect | CWCursor;
X
X    temp->theWindow = XCreateWindow(temp->theDisplay,
X            RootWindow(temp->theDisplay,temp->theScreen),
X            x,y,w,h,BORDER_WIDTH,CopyFromParent,CopyFromParent,
X            CopyFromParent,theWindowMask,&theWindowAttributes);
X
X    theIconPixmap = XCreateBitmapFromData(temp->theDisplay,temp->theWindow,ship0_bits,ship0_width,ship0_height);
X    theWMHints.initial_state = NormalState;
X
X    theWMHints.icon_pixmap = theIconPixmap;
X
X    theWMHints.flags = IconPixmapHint | StateHint;
X
X    XSetWMHints(temp->theDisplay,temp->theWindow,&theWMHints);
X
X    XStoreName(temp->theDisplay,temp->theWindow,win_name);
X    XSetIconName(temp->theDisplay,temp->theWindow,win_name);
X
X    theClassHint.res_name = RES_NAME;
X    theClassHint.res_class = RES_CLASS;
X
X    XSetClassHint(temp->theDisplay,temp->theWindow,&theClassHint);
X
X    theSizeHints.flags = USPosition | USSize | PMinSize | PMaxSize;
X    theSizeHints.x     = x;
X    theSizeHints.y     = y;
X    theSizeHints.width = w;
X    theSizeHints.height = h;
X    theSizeHints.min_width = w;
X    theSizeHints.max_width = w;
X    theSizeHints.min_height = h;
X    theSizeHints.max_height = h;
X
X    XSetNormalHints(temp->theDisplay,temp->theWindow,&theSizeHints);
X    theGCValues.function = GXcopy;
X    theGCValues.foreground = temp->theWhitePixel;
X    theGCValues.background = temp->theBlackPixel;
X    temp->theGC = XCreateGC(temp->theDisplay,temp->theWindow,(unsigned long
X)(GCFunction|GCForeground|GCBackground),&theGCValues);
X
X    if(temp->theGC == 0)
X 	{
X        XDestroyWindow(temp->theDisplay,temp->theWindow);
X        free(temp);
X        return NULL;
X    }
X    XSetForeground(temp->theDisplay,temp->theGC,temp->theWhitePixel);
X    XSetBackground(temp->theDisplay,temp->theGC,temp->theBlackPixel);
X	XSelectInput(temp->theDisplay,temp->theWindow,ExposureMask);
X    XMapWindow(temp->theDisplay,temp->theWindow);
X    XFlush(temp->theDisplay);
X
X    return temp;
X
X}
X
Xdraw_bigrocks(w)
Xwinptr w;
X{
X
X	junkptr j;
X	witemptr b;
X	int x,y;
X
X	j = first_junk;
X	while(j)
X	{
X		if(j->type==BIGROCK && w->quality[SHORTRR] > 1) {
X		   x=RADARW/2+(j->sx-w->sx)*RADARW/(worldw*2);
X           y=RADARH/2+(w->sy-j->sy)*RADARH/(worldh*2);
X           XDrawPoint(w->radar->theDisplay,w->radar->theWindow, w->radar->theGC,
X				x,y);
X		}
X		if(j->type==MEDROCK && w->quality[SHORTRR] > 2) {
X		   x=RADARW/2+(j->sx-w->sx)*RADARW/(worldw*2);
X           y=RADARH/2+(w->sy-j->sy)*RADARH/(worldh*2);
X           XDrawPoint(w->radar->theDisplay,w->radar->theWindow, w->radar->theGC,
X				x,y);
X		}
X		if(j->type==SMALLROCK && w->quality[SHORTRR] > 3) {
X		   x=RADARW/2+(j->sx-w->sx)*RADARW/(worldw*2);
X           y=RADARH/2+(w->sy-j->sy)*RADARH/(worldh*2);
X           XDrawPoint(w->radar->theDisplay,w->radar->theWindow, w->radar->theGC,
X				x,y);
X		}
X		if(j->type > CLOUD6 && w->quality[SHORTRR] > 5) {
X		   x=RADARW/2+(j->sx-w->sx)*RADARW/(worldw*2);
X           y=RADARH/2+(w->sy-j->sy)*RADARH/(worldh*2);
X           XDrawPoint(w->radar->theDisplay,w->radar->theWindow, w->radar->theGC,
X				x,y);
X		}
X		if(j->type > CLOUD1 && j->type < DEBRIS1 && w->quality[SHORTRR] > 6) {
X		   x=RADARW/2+(j->sx-w->sx)*RADARW/(worldw*2);
X           y=RADARH/2+(w->sy-j->sy)*RADARH/(worldh*2);
X           XDrawPoint(w->radar->theDisplay,w->radar->theWindow, w->radar->theGC,
X				x,y);
X		}
X		j=j->next;
X	}
X	if(w->quality[SHORTRR] < 8) return;
X	b = first_weap_item;
X	while(b)
X	{
X        x=RADARW/2+(b->sx-w->sx)*RADARW/(worldw*2);
X        y=RADARH/2+(w->sy-b->sy)*RADARH/(worldh*2);
X        XDrawPoint(w->radar->theDisplay,w->radar->theWindow, w->radar->theGC,
X            x,y);
X		b = b->next;
X	}
X}
X
Xdraw_walls(w)
Xwinptr w;
X{
X	int x,y, yl, xl, xt, yt, xwall, ywall;
X
X	xwall=ywall=0;
X	if(w->sx>0) 
X	{
X    	x=RADARW/2+(WORLDW-w->sx)*RADARW/(worldw*2);
X		if((RADARW)>x)
X			xwall=1;
X	}
X	else 
X	{
X		x=RADARW/2+(-WORLDW-w->sx)*RADARW/(worldw*2);
X		if((RADARW/2)>x && x>0)
X			xwall=1;
X	}
X	if(w->sy>0)
X	{
X        y=RADARH/2+(w->sy-WORLDH)*RADARH/(worldh*2);
X		if((RADARH/2)>y && y>0)
X			ywall=1;
X	}
X	else
X	{
X        y=RADARH/2+(w->sy+WORLDH)*RADARH/(worldh*2);
X		if((RADARH)>y)
X			ywall=1;
X	}
X	if(xwall && ywall)  /* we have two walls */
X	{
X		if(w->sx>0)
X		{
X			xl=0;
X			xt=x;
X		}
X		else
X		{
X			xl=x;
X			xt=RADARW;
X		}
X		if(w->sy>0)
X		{
X			yl=y;
X			yt=RADARH;
X		}
X		else
X		{
X			yl=0;
X			yt=y;
X		}
X		XDrawLine(w->radar->theDisplay,w->radar->theWindow, w->radar->theGC,
X			x, yl, x, yt);
X		XDrawLine(w->radar->theDisplay,w->radar->theWindow, w->radar->theGC,
X			xl, y, xt, y);
X	}
X	else  /* only one so ... */
X	{
X		if(xwall)
X			XDrawLine(w->radar->theDisplay,w->radar->theWindow, w->radar->theGC,
X				x, 0, x, RADARH);
X		if(ywall)
X			XDrawLine(w->radar->theDisplay,w->radar->theWindow, w->radar->theGC,
X				0, y, RADARW, y);
X	}
X}
X
Xdo_radar(w)
Xwinptr w;
X{
X	char buf[20];
X	winptr temp;
X	int sx,sy,x,y;
X
X	if(w->short_range_radar)
X	{
X        worldh = WORLDH / 4;
X        worldw = WORLDW / 4;
X        if(w->state[SHORTRR] < rand()%100+1) 
X            return;
X		draw_bigrocks(w);
X		if(w->quality[SHORTRR]>4) draw_walls(w);
X	}
X	else
X	{
X		worldh = WORLDH;
X		worldw = WORLDW;
X		if(w->state[LONGRR]<rand()%100+1)
X			return;
X	}
X	sprintf(buf,"%2dx",WORLDW/worldw);
X	XDrawString(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,0,198,buf,strlen(buf));
X	
X	temp=first_win;
X	while(temp!=NULL) {
X		x=RADARW/2 + (temp->sx)/(2*WORLDW/RADARW);
X		y=RADARH/2 - (temp->sy)/(2*WORLDH/RADARH);
X		if(temp==w) 
X		{
X			if(w->short_range_radar)
X			{
X				XDrawPoint(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,
X					RADARW/2-1, RADARH/2-1);
X           		XDrawPoint(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,
X					RADARW/2+1,RADARH/2-1);
X            	XDrawPoint(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,
X					RADARW/2+1,RADARH/2+1);
X            	XDrawPoint(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,
X					RADARW/2-1,RADARH/2+1);
X            	XDrawPoint(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,
X					RADARW/2,RADARH/2);
X			}
X			else
X			{
X				XDrawPoint(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,
X					x-1,y-1);
X				XDrawPoint(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,
X					x+1,y-1);
X				XDrawPoint(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,
X					x+1,y+1);
X				XDrawPoint(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,
X					x-1,y+1);
X				XDrawPoint(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,x,y);
X			} 
X		}
X		else if(!temp->exploding) 
X		{
X		int chance=0;
X
X			if(w->short_range_radar) 
X			{
X			int c,r;
X	
X				
X				if(temp->cloaking)
X				{
X					c=(temp->quality[CLOAK]-1)*temp->state[CLOAK];
X					r=w->quality[SHORTRR]*w->state[SHORTRR];
X					if(c+r!=0)
X						chance=(r-c)*100/(c+r) + 50;
X				}
X				if(!temp->cloaking || (temp->cloaking && chance >= (rand()%100+1)))
X				{
X					x=RADARW/2+(temp->sx-w->sx)*RADARW/(worldw*2);
X					y=RADARH/2+(w->sy-temp->sy)*RADARH/(worldh*2);
X					if(w->targeting==temp) 
X					{
X						XDrawLine(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,
X							x-4,y,x+4,y);
X						XDrawLine(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,
X							x,y-4,x,y+4);
X					}
X					else 
X					{
X						XDrawRectangle(w->radar->theDisplay,w->radar->theWindow,
X									w->radar->theGC,x-1,y-1,3,3);
X					}
X				}
X				else
X				{
X				int xx, yy;
X
X					xx=rand()%RADARW;
X					yy=rand()%RADARH;
X					XDrawRectangle(w->radar->theDisplay,w->radar->theWindow,
X						w->radar->theGC,xx-1, yy-1, 3, 3);
X				}
X			}
X			else 
X			{
X			int c,r;
X
X				if(temp->cloaking)
X				{
X					c=(temp->quality[CLOAK]-1)*temp->state[CLOAK];
X					r=w->quality[LONGRR]*w->state[LONGRR];
X					if(c+r!=0)
X						chance=(r-c)*100/(c+r) + 50;
X				}	
X				if(!temp->cloaking || (temp->cloaking && chance >= (rand()%100+1)))
X				{
X					XDrawPoint(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,
X						x,y);
X					if(w->targeting==temp) 
X					{
X						XDrawLine(w->radar->theDisplay,w->radar->theWindow,
X							w->radar->theGC,x-2,y,x+2,y);
X						XDrawLine(w->radar->theDisplay,w->radar->theWindow,
X							w->radar->theGC,x,y-2,x,y+2);
X					}
X				}
X				else
X				{
X					XDrawPoint(w->radar->theDisplay,w->radar->theWindow,w->radar->theGC,
X						rand()%PLAYW,rand()%PLAYH);
X				}
X			}
X		}
X		temp=temp->next;
X	}
X	XFlush(w->radar->theDisplay);
X}
X
Xredo_radar(w)
Xwinptr w;
X{
X	XClearWindow(w->radar->theDisplay,w->radar->theWindow);
X	XFlush(w->radar->theDisplay);
X}
END_OF_FILE
if test 10038 -ne `wc -c <'radar.c'`; then
    echo shar: \"'radar.c'\" unpacked with wrong size!
fi
# end of 'radar.c'
fi
if test -f 'shop.contents' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'shop.contents'\"
else
echo shar: Extracting \"'shop.contents'\" \(8155 characters\)
sed "s/^X//" >'shop.contents' <<'END_OF_FILE'
XEngines
XEngine(1)
XThis is the most basic engine available
XDon' expect to last too long with this engine.
X
XEnergy Use:   7 units per turn.
XAcceleration: 1/2 units/turn/turn
X$500
XEngine(2)
XEnergy Use:   7 units per turn.
XAcceleration: 1 units/turn/turn
X$1000
XEngine(3)
XEnergy Use:   7 units per turn.
XAcceleration: 3/2 units/turn/turn
X$2000
XEngine(4)
XEnergy Use:   7 units per turn.
XAcceleration: 2 units/turn/turn
X$5000
XEngine(5)
XEnergy Use:   7 units per turn.
XAcceleration: 2 1/2 units/turn/turn
X$10000
XEngine(6)
XEnergy Use:   7 units per turn.
XAcceleration: 3 units/turn/turn
X$20000
XEngine(7)
XEnergy Use:   7 units per turn.
XAcceleration: 3 1/2 units/turn/turn
X$40000
XEngine(8)
XEnergy Use:   7 units per turn.
XAcceleration: 4 units/turn/turn
X$80000
XEngine(9)
XEnergy Use:   7 units per turn.
XAcceleration: 4 1/2 units/turn/turn
X$160000
X###
XSolar Panels
XSolar(1)
XEnergy gain: 3/2 units per turn
X$500
XSolar(2)
XEnergy gain: 3 units per turn
X$1000
XSolar(3)
XEnergy gain: 4 1/2 units per turn
X$5000
XSolar(4)
XEnergy gain: 6 units per turn
X$10000
XSolar(5)
XEnergy gain: 7 1/2 units per turn
X$30000
XSolar(6)
XEnergy gain: 9 units per turn
X$70000
XSolar(7)
XEnergy gain: 10 1/2 units per turn
X$150000
XSolar(8)
XEnergy gain: 12 units per turn
X$300000
XSolar(9)
XEnergy gain: 13 1/2 units per turn
X$600000
X###
XRadar
XLong Range Radar(1)
XThis device shows the whole playing field
Xand the positions of all the combatants.
XThe outer edge of the radar is where the
Xwalls of the playing field are.
XThe dots represent the other combatants,
Xwhilst the cross represents yourself.
X$100
XLong Range Radar(2)
X	This device will detect Jammers of 
Xquality 2 
X$1000
XLong Range Radar(3)
X	This device will detect Jammers of 
Xquality 3 or less
X$4000
XLong Range Radar(4)
X	This device will detect Jammers of 
Xquality 4 or less
X$7500
XLong Range Radar(5)
X	This device will detect Jammers of 
Xquality 5 or less
X$10000
XLong Range Radar(6)
X	This device will detect Jammers of 
Xquality 6 or less
X$12000
XLong Range Radar(7)
X	This device will detect Jammers of 
Xquality 7 or less
X$15000
XLong Range Radar(8)
X	This device will detect Jammers of 
Xquality 8 or less
X$18000
XLong Range Radar(9)
X	This device will detect Jammers of 
Xquality 9 or less
X$20000
XShort Range Radar(1)
XThis device shows a view of what is currently
Xaround your ship.  The center cross is your ship
Xand the squares are opponents.
X$100
XShort Range Radar(2)
XLike a short range radar(1), this radar shows the
Xcombatants who are close to you, and it shows large
Xrocks as well. These appear as a dot on the radar.
X$500
XShort Range Radar(3)
XThis radar shows both large and medium sized rocks
Xas well as combatants.
X$1000
XShort Range Radar(4)
XThis radar shows all combatants and rock
X(large, medium and small)
X$2000
XShort Range Radar(5)
XThis radar shows you all combatants, 
Xall rocks and the walls as they come into view
X$8000
XShort Range Radar(6)
XThis radar shows you all combatants,
Xall the rocks, the walls as they come into view
Xand any debris that is floating in space.
X$12000
XShort Range Radar(7)
XThis Radar shows you all combatants,
Xall the rocks, the walls as they come into view
Xany debris that is floating in space and the
Xclouds that appear when you score a hit.
X$15000
XShort Range Radar(8)
XThis radar shows the combatants, all rocks and the
Xclouds, debris, walls and all the weapons.
X$30000
X###
XWeapons
XPulse Rifle
XEnergy Use:       10 units
XFiring Rate:      1 turn
XDamage:           10
XRange:            1000 units
XVelocity:         50 units/turn
X$500
XEnergy Bomb
XEnergy Use:       50 units
XFiring Rate:      3 turn
XDamage:           45
XRange:            450 units
XVelocity:         30 units/turn
X$4500
XSeeker (T)
XSeeker Bomb
XEnergy Use:       100 units
XFiring Rate:      10 turn
XDamage:           80
XRange:            1600 units
XVelocity:         20 units/turn
XNote: To fire Seeker bombs requires a targeting
XComputer.
X$5000
XLight Laser
XEnergy Use:       50 units
XFiring Rate:      4 turn
XDamage:           40
XRange:            N/A
XVelocity:         N/A
X$10000
XRail Gun	
XEnergy Use:       70 units
XFiring Rate:      3 turn
XDamage:           50
XRange:            4000 units
XVelocity:         50 units/turn
X$50000
XMass Driver
XEnergy Use:       30 units
XFiring Rate:      2 turn
XDamage:           25
XRange:            800 
XVelocity:         20 units/turn
X$2500
XMine
XEnergy Use:       180 units
XFiring Rate:      8 turn
XDamage:           180
XDuration:         5000 units 
XVelocity:         -5 units/turn
X$8000
XHeavy Laser  
XEnergy Use:       80 units
XFiring Rate:      6 turn
XDamage:           60
XRange:            N/A
XVelocity:         N/A
X$70000
XAtomic Spray  
XEnergy Use:       5 units
XFiring Rate:      1 turn
XDamage:           2 
XRange:            1200 
XVelocity:         40  units/turn
X$17500
XMagneto Disk(T) 
XEnergy Use:       130 units
XFiring Rate:      8 turn
XDamage:           120
XRange:            4000 
XVelocity:         40 units/turn
X$120000
XHvy Pulse Rifle
XEnergy Use:       20 units
XFiring Rate:      2 turn
XDamage:           20
XRange:            1650 
XVelocity:         55 units/turn
X$8000
XBlack Death
XEnergy Use:       400 units
XFiring Rate:      40 turn
XDamage:           400
XRange:            400 
XVelocity:         40 units/turn
X$75000
XClover Launch
XEnergy Use:       30 units 
XFiring Rate:      3 turn
XDamage:           30
XRange:            2100
XVelocity:         60 units/turn
X$20000
XVortex Gun
XEnergy Use:       50 units 
XFiring Rate:      4 turn
XDamage:           45
XRange:            3000
XVelocity:         50 units/turn
X$25000
XMissile
XEnergy Use:       70 units 
XFiring Rate:      3 turn
XDamage:           55
XRange:            8000
XVelocity:         80 units/turn
Xunits/turn
X$27500
X###
XRepair Systems
XRepair(1)
XEnergy Cost: 50 units
XRepair Rate: 1 units/10 turns
X$100
XRepair(2)
XEnergy Cost: 25 units
XRepair Rate: 1 units/9 turns
X$250
XRepair(3)
XEnergy Cost: 16 units
XRepair Rate: 1 units/8 turns
X$500
XRepair(4)
XEnergy Cost: 12 units
XRepair Rate: 1 units/7 turns
X$1000
XRepair(5)
XEnergy Cost: 10 units
XRepair Rate: 1 units/6 turns
X$5000
XRepair(6)
XEnergy Cost: 5 units
XRepair Rate: 1 units/5 turns
X$10000
XRepair(7)
XEnergy Cost: 7 units
XRepair Rate: 1 units/4 turns
X$20000
XRepair(8)
XEnergy Cost: 6 units
XRepair Rate: 1 units/3 turns
X$30000
XRepair(9)
XEnergy Cost: 5 units
XRepair Rate: 1 units/2 turns
X$40000
X###
XMiscellaneous
XTargeting Computer
X	The targeting computer is needed if you wish to 
Xuse the Seeker weapon. These seeker weapons will 
Xseek out and explode upon their target. The target
Xis chosen by using the targeting computer.
X$4000
XJammer(2)
X	This device allows the ship to be cloaked. This
Xcloaking means that other ships will not see you on
Xtheir radar.  This can be a good stealth attack 
Xweapon.  It uses a small amount of energy to cloak,
Xbut if you thrust, fire and cloak. Watch Out! 
X	If you fire, then you once again appear on others
Xradars.
X    A Jammer(2) can be detected by a radar(2)
X$2000
XJammer(3)
X	A Jammer(3) will hide you from other
Xcombatants radars of quality less than 3
X$5000
XJammer(4)
X	A Jammer(4) will hide you from other
Xcombatants radars of quality less than 4
X$10000
XJammer(5)
X	A Jammer(5) will hide you from other
Xcombatants radars of quality less than 5
XThis Jammer only shows about 3/4 of your
Xship when you are in plain view of an
Xopponent
X$20000
XJammer(6)
X	A Jammer(6) will hide you from other
Xcombatants radars of quality less than 6
XThis jammer only shows about a 1/2 of
Xyour ship when in plain view
X$30000
XJammer(7)
X	A Jammer(7) will hide you from other
Xcombatants radars of quality less than 7
XThis Jammer only shows about a 1/4 of
Xyour ship in plain view
X$40000
XJammer(8)
X	A Jammer(8) will hide you from other
Xcombatants radars of quality less than 8
XThis Jammer camouflage you as stars
Xwhen in plain view
X$50000
XJammer(9)
X	A Jammer(9) will hide you from other
Xcombatants radars of quality less than 9
XThis Jammer completely covers you from 
Xplain view
X$60000
X###
XShields
XLeft Shield
XIncrease your Left Shield capacity by 100 units.
X$12000
XRight Shield
XIncrease your Right Shield capacity by 100 units.
X$12000
XBottom Shield
XIncrease your Bottom Shield capacity by 100 units.
X$10000
X###
XEnergy
XBattery
XIncrease your Maximum Energy capacity by 100 units.
X$15000
END_OF_FILE
if test 8155 -ne `wc -c <'shop.contents'`; then
    echo shar: \"'shop.contents'\" unpacked with wrong size!
fi
# end of 'shop.contents'
fi
if test -f 'test.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test.c'\"
else
echo shar: Extracting \"'test.c'\" \(12372 characters\)
sed "s/^X//" >'test.c' <<'END_OF_FILE'
X/* test.c - *** Main loop of xmpb */
X
Xstatic char sccs_id[] = "@(#)test.c 1.23 92/11/24 XMPB";
X
Xint installed=1;
X
X#include "player.h"
X#include <math.h>
X#include <X11/keysym.h>
X#include "save.h"
X#include <signal.h>
X#include "bits.h"
X#include "bits.c"
X#include <sys/types.h>
X#include <sys/time.h>
X#include <sys/stat.h>
X#include <fcntl.h>
X#include <errno.h>
X
X#define MAXSHIPWIDTH 91
X#define MAXSHIPHEIGHT 91
X#define maj 1
X#define min 1
X
Xextern winptr first_win;
Xextern int no_lasers;
Xextern int no_hosts, numnpcs; 
Xextern int num_quit;
Xextern int errno;
Xextern int num_alive;
X
Xint counter=5;
Xlong time_started, time_limit=900;
Xint mins_left, mins_gone, secs_left;
Xint all_combs;
Xint euid;
X
X/*
X** set default keys
X*/
Xinit_prefs(w, name)
Xwinptr w;
Xchar *name;
X{
X
X    char *t;
X
X    w->prefs.turnLeft=XK_z;
X    w->prefs.turnRight=XK_x;
X    w->prefs.toggleRadar=XK_c;
X    w->prefs.toggleShieldsRegen=XK_s;
X    w->prefs.toggleWeaponStatus=XK_w;
X    w->prefs.changeRepair=XK_r;
X    w->prefs.changeTarget=XK_t;
X    w->prefs.invisibility=XK_i;
X    w->prefs.quit=XK_q;
X    w->prefs.grabEnergy=XK_g;
X    w->prefs.balanceShields=XK_b;
X    w->prefs.changeView=XK_plus;
X	w->prefs.fire=XK_space;
X	w->prefs.changeWeapon=XK_p;
X	w->prefs.thrust=XK_l;
X    t="";
X    t=XGetDefault(w->theDisplay, name, "turnLeft");
X    if(t!=NULL)
X    {
X        w->prefs.turnLeft=XStringToKeysym(t);
X        t="";
X    }
X    t=XGetDefault(w->theDisplay, name, "turnRight");
X    if(t!=NULL)
X    {
X        w->prefs.turnRight=XStringToKeysym(t);
X        t="";
X    }
X	t=XGetDefault(w->theDisplay, name, "toggleRadar");
X	if(t!=NULL)
X    {
X        w->prefs.toggleRadar=XStringToKeysym(t);
X        t="";
X    }
X	t=XGetDefault(w->theDisplay, name, "toggleShieldsRegen");
X	if(t!=NULL)
X    {
X        w->prefs.toggleShieldsRegen=XStringToKeysym(t);
X        t="";
X    }
X	t=XGetDefault(w->theDisplay, name, "toggleWeaponStatus");
X	if(t!=NULL)
X    {
X        w->prefs.toggleWeaponStatus=XStringToKeysym(t);
X        t="";
X    }
X	t=XGetDefault(w->theDisplay, name, "changeRepair");
X	if(t!=NULL)
X    {
X        w->prefs.changeRepair=XStringToKeysym(t);
X        t="";
X    }
X	t=XGetDefault(w->theDisplay, name, "changeTarget");
X	if(t!=NULL)
X    {
X        w->prefs.changeTarget=XStringToKeysym(t);
X        t="";
X    }
X	t=XGetDefault(w->theDisplay, name, "changeView");
X	if(t!=NULL)
X    {
X        w->prefs.changeView=XStringToKeysym(t);
X        t="";
X    }
X	t=XGetDefault(w->theDisplay, name, "invisibility");
X	if(t!=NULL)
X    {
X        w->prefs.invisibility=XStringToKeysym(t);
X        t="";
X    }
X	t=XGetDefault(w->theDisplay, name, "quit");
X	if(t!=NULL)
X    {
X        w->prefs.quit=XStringToKeysym(t);
X        t="";
X    }
X	t=XGetDefault(w->theDisplay, name, "grabEnergy");
X	if(t!=NULL)
X    {
X        w->prefs.grabEnergy=XStringToKeysym(t);
X        t="";
X    }
X	t=XGetDefault(w->theDisplay, name, "balanceShields");
X	if(t!=NULL)
X    {
X        w->prefs.balanceShields=XStringToKeysym(t);
X        t="";
X    }
X	t=XGetDefault(w->theDisplay, name, "fire");
X	if(t!=NULL)
X    {
X        w->prefs.fire=XStringToKeysym(t);
X        t="";
X    }
X	t=XGetDefault(w->theDisplay, name, "changeWeapon");
X	if(t!=NULL)
X    {
X        w->prefs.changeWeapon=XStringToKeysym(t);
X        t="";
X    }
X	t=XGetDefault(w->theDisplay, name, "thrust");
X	if(t!=NULL)
X    {
X        w->prefs.thrust=XStringToKeysym(t);
X        t="";
X    }
X}
X
Xwinners()
X{
Xwinptr w;
XFont xf;
Xchar buf[MAX_NAME_SIZE];
Xint num_winner=0;
Xint retn;
Xchar **fonts;
X
X
X    w=first_win;
X    while(w) {
X        if(!w->exploding)
X            num_winner++;
X        w=w->next;
X    }
X    if(num_winner==1) winner(0);
X	else winner(1);
X}
X
Xsave_npc(w)
Xwinptr w;
X{
X    int i,start,no_vars,no_ins;
X    FILE *fp, *out_fp;
X    char fn[100], fn2[100];
X    struct header h;
X
Xprintf("Saving an npc:  %s\n", w->Name);
X    strcpy(fn, NPCDIR);
X    strcat(fn,w->comp->fname);
X    strcat(fn,".no");
X
Xseteuid(euid);
X    fp = fopen(fn,"rb");
Xseteuid(getuid());
X
X    if(!fp) 
X	{
X		fprintf(stderr, "Cannot find NPC! - Cancelling save\n");
X		return 0;
X	}
X	strcpy(fn2, fn);
X	strcat(fn2, ".tmp");
X
Xseteuid(euid);
X    out_fp = fopen(fn2,"wb");
Xseteuid(getuid());
X
X    if(!out_fp) 
X	{
X		fprintf(stderr, "Cannot save NPC!\n");
X	}
X    fread(&h, sizeof(struct header), 1, fp);
X	h.kills += w->kills-w->last_kills;
X	h.cash_earned += w->earned;
X
Xprintf("%s (%d) got %d %s", w->Name, w->ship_value, w->earned,(!w->exploding?"     -  Alive\n":"\n"));
X
X	if(w->exploding || secs_left<=0) h.num_played++;
X	fwrite(&h, sizeof(struct header), 1, out_fp);
X
Xseteuid(euid);
X   	fread(w->comp->text,sizeof(struct ins),h.no_ins,fp);
X	fwrite(w->comp->text,sizeof(struct ins),h.no_ins,out_fp);
X    fread(&(w->comp->no_states),sizeof(int),1,fp);
X    fwrite(&(w->comp->no_states),sizeof(int),1,out_fp);
X    for(i=0;i<w->comp->no_states;i++)
X    {
X        fread(w->comp->states[i],1,MAX_SYMB_LEN,fp);
X        fwrite(w->comp->states[i],1,MAX_SYMB_LEN,out_fp);
X        fread(&(w->comp->stp[i]),sizeof(int),1,fp);
X        fwrite(&(w->comp->stp[i]),sizeof(int),1,out_fp);
X    }
X
X    fclose(fp);
X	fclose(out_fp);	
X	unlink(fn);
X	rename(fn2, fn);
Xseteuid(getuid());
X}
X
Xwinner(no_winner)
Xint no_winner;
X{
Xwinptr w;
XFont xf;
Xchar buf[MAX_NAME_SIZE];
Xint retn;
Xchar **fonts;
X
X	w=first_win;
X	if(!no_winner)
X	{
X		while(w) 
X		{	
X			sprintf(buf, "Today's Winner is: %s", w->Name); 
X			if(!w->exploding && all_combs>1) 
X				w->credits+=5000;
X			w=w->next;
X		}
X	}
X	else
X        sprintf(buf, "There is no winner");
X
X	if(no_winner==2)
X	{
X		sprintf(buf, "Time has run out");
X	}
X	w=first_win;
X	parse_shop_contents();
X    while(w) {
X		if(!w->npc || w->npcwin)
X		{
X			xfe_clear(w);
X			fonts=XListFonts(w->theDisplay, "-*-helvetica-medium-*-normal-*-*-240-*-100-*-*-*-*", 10, &retn);
X			if(fonts!=NULL)
X			{ 
X				xf=XLoadFont(w->theDisplay, fonts[0]);
X				XSetFont(w->theDisplay, w->aGC, xf);
X			}
X			XDrawString(w->theDisplay, w->theWindow, w->aGC ,120, 300, buf, strlen(buf));
X			if(!w->npc) 
X			{
X				w->ship_value=value_of_craft(w);
X				save_dude(w);
X			}
X			XFlush(w->theDisplay);
X		}
X		w=w->next;
X	}
X	sleep(2);
X	w=first_win;
X    while(w) {
X		if(!w->npc || w->npcwin) close_host(w);
X		if(w->npc)
X		{
X			save_npc(w);
X		}
X		w=w->next;
X	}
X	exit(0);
X}
X
Xdec_earned()
X{
X	winptr w;
X	
X	w=first_win;
X	
X	counter--;
X	if(counter)
X		return;
X	while(w)
X	{
X		if(!w->exploding && w->earned > 0)
X			w->earned--;
X		w=w->next;
X	}
X	counter=5;
X}
X
Xdie()
X{
X	winptr w;
X
X    w=first_win;
X    while(w) {
X		if(w->npc)
X			save_npc(w);
X        if(!w->npc || w->npcwin) close_host(w);
X        w=w->next;
X    }
X    exit(0);
X}
X
Xbad()
X{
X	fprintf(stderr, "Major Bummer...  We got a bus/seg fault error\n");
X	exit(0);
X}
X
Xchar *index();
X
Xsecs_of(s)
Xchar *s;
X{
X	char *s2;
X
X	s2=0;
X	s2=index(s, ':');
X	if(s2!=NULL)
X	{
X		s[strlen(s) - strlen(s2)]=0;
X	    s2=s2+1;
X		return (atoi(s)*60 + atoi(s2));
X	}
X	else
X		return (atoi(s)*60);
X}
X
X	
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
Xint valid_disp=0;
Xint i,j,k,l,counter=30;
Xwinptr temp;
XXGCValues gc;
XXImage *xi;
Xint h,w,xh,yh;
Xchar fn[40];
Xlong tmp;
Xint fp;
X
X	euid = geteuid();
X	seteuid(getuid());
X	srand(getpid());
X
X	if(argc==1) {
X		printf("Usage: xmpb [-s] [-t] [-npc NPC_Name] [-npcwin display1] [display2] [display3] ...\n");
X		exit();
X	}
X
X	if(!strcmp(argv[1], "-s"))
X	{
X	FILE *fp;
X	char buf[160];
X	save temp;
X	struct header head;
X
X		printf("\nPlayer's Hall of Fame\n");
X	 	buf[0]=0;
X    	strcpy(buf, SAVEDIR);
X    	strcat(buf, "hall.of.fame");
X
Xseteuid(euid);
X		fp=fopen(buf, "rb");
Xseteuid(getuid());
X
X		if(!fp) {
X			fprintf(stderr, "Cannot find hall of fame\n");
X		}
X		else
X		while(fread(&temp, sizeof(save), 1, fp))
X		{
X			printf("%-25s in %-25s with %-3d kills and $%d\n", temp.Name, temp.Ship, temp.kills, temp.credits);
X		}
X		fclose(fp);
X
X		printf("\n\nNPC hall of fame:\n");
X		strcat(buf, ".npc");
X
Xseteuid(euid);
X		fp=fopen(buf, "rb");
Xseteuid(getuid());
X
X        if(!fp) {
X            fprintf(stderr, "Cannot find npc hall of fame\n");
X        }
X		else
X		while(fread(&head, sizeof(struct header), 1, fp))
X		{
X			printf("%-25s in %-25s with %-3d kills and $%d\n", head.Name, head.Ship, head.kills, head.cash_earned);
X		}
X		fclose(fp);
X		exit(0);
X	}
X
X	installed=1;
Xseteuid(euid);
X	fp=open(BITMAPDIR, O_WRONLY);  /* check to see if bitmapdir is set */
Xseteuid(getuid());
X	if(fp == -1)
X	{
X		if(errno==2)
X		{
X			installed=0;
X			fprintf(stderr, "Warning: Cannot find BITMAPDIR.  Checking for bitmaps in current directory!\n");
X		}
X		else
X		if (errno!=EISDIR)  /* if errno is EISDIR, then bitmaps have been installed */
X			perror("Trying to find bitmaps in BITMAPDIR");
X	}
X
X	i=1;
X	while (argv[i])
X	{
X		if(!strcmp(argv[i], "-npc"))
X		{
X			i++;
X			if((i!=(argc-1)) && (!strcmp(argv[i+1], "-npcwin")))
X			{
X				if(add_host(argv[i], 1, 1, argv[i+2]))
X					valid_disp = 1;
X				i=i+3;
X			}
X			else
X			{
X				add_host(argv[i], 1, 0, "");
X				i++;
X			}
X		}
X		else
X			i++;
X	}
X	printf("Xmpb version %d.%d\n",maj,min);
X	printf("Copyright (C)1992 Shane Hyde & Damien De Paoli\n");
X
X/*
X	for(i=0;i<argc-1;i++)
X	{
X		int j;
X		for(j=i+1;j<argc;j++)
X		{
X			char buf[40];
X			char buf2[40];
X
X			sscanf(argv[i],"%[^ .]",buf);
X			sscanf(argv[j],"%[^ .]",buf2);
X			if(!strcmp(buf,buf2))
X			{
X				fprintf(stderr,"I'm sorry, all host's must be unique\n");
X				exit(1);
X			}
X		}
X	}
X*/
X{
X			
X	for(i=1; i<argc; i++) 
X	{
X		if(!strcmp(argv[i], "-t"))
X		{
X			i++;
X			time_limit=secs_of(argv[i]);
X		}
X		else
X		if(!(strcmp(argv[i],"-npc")) || (!strcmp(argv[i], "-npcwin")))
X		{
X			i++;
X		}
X		else
X		{
X			if(add_host(argv[i],0,0,"")) 
X				valid_disp=1;
X			else
X				printf("Cannot connect to %s, probably not authorised to connect to server\n",argv[i]);
X		}
X	}
X	if(!valid_disp) 
X	{
X		xmpb_error("Specified host(s) could not be connected to.  Exiting\n");
X	}
X	all_combs=no_hosts;
X}
X	sleep(1);
X{
Xwinptr w;
X	w=first_win;
X	while(w)
X	{
X		if(!w->npc || w->npcwin)
X			xfe_clear(w);
X		w=w->next;
X	}
X}
X/*
Xprintf("Vendor: %s  Release: %d\n", ServerVendor(first_win->theDisplay), VendorRelease(first_win->theDisplay));
X*/
X	get_strings();
X
X	{
X		winptr w,t;
X		char buf[180];
X
X		w = first_win;
X		while(w)
X		{
X			i =0;
X			if(!w->npc || w->npcwin)
X			{
X				init_prefs(w,argv[0]);
X				XClearWindow(w->theDisplay,w->theWindow);
X				XDrawString(w->theDisplay,w->theWindow,w->aGC,20,20,"Todays Combat!",14);
X				t = first_win;
X				while(t)
X				{
X					sprintf(buf,"%s in %s %5s%d",t->Name,t->Ship,"$", t->ship_value);
X					XDrawString(w->theDisplay,w->theWindow,w->aGC,30,40+15*i,buf,strlen(buf));
X					i++;
X					t =t->next;
X				}
X				XSync(w->theDisplay,False);
X			}
X			w = w->next;
X		}
X		for(i=3;i>0;i--)
X		{
X			t = first_win;
X            while(t)
X            {
X				if(!t->npc || t->npcwin)
X				{
X                	sprintf(buf,"%d",i);
X                	XDrawImageString(t->theDisplay,t->theWindow,t->aGC,PLAYW/2,3*PLAYH/4,buf,strlen(buf));
X					XSync(t->theDisplay,False);
X				}
X                t =t->next;
X            }
X			sleep(1);
X		}
X	}
X#define MAX_JUNK_MOD 	40
X#define MAX_JUNK_OFFSET 20
X
X	for(i=0;i<15;i++)
X	{
X		add_junk(SMALLROCK,rand()%(WORLDW*2)-WORLDW,rand()%(WORLDH*2)-WORLDH,((rand()%(MAX_JUNK_MOD)-MAX_JUNK_OFFSET)*32768),((rand()%(MAX_JUNK_MOD)-MAX_JUNK_OFFSET)*32768),0);
X		add_junk(MEDROCK,rand()%(WORLDW*2)-WORLDW,rand()%(WORLDH*2)-WORLDH,((rand()%(MAX_JUNK_MOD)-MAX_JUNK_OFFSET)*32768),((rand()%(MAX_JUNK_MOD)-MAX_JUNK_OFFSET)*32768),0);
X	}
X	for(i=0;i<10;i++)
X	{
X		add_junk(BIGROCK,rand()%(WORLDW*2)-WORLDW,rand()%(WORLDH*2)-WORLDH,((rand()%(MAX_JUNK_MOD)-MAX_JUNK_OFFSET)*32768),((rand()%(MAX_JUNK_MOD)-MAX_JUNK_OFFSET)*32768),0);
X	}
X
X	signal(SIGINT, die);
X	signal(SIGHUP, die);
X	signal(SIGQUIT, die);
X	signal(SIGPIPE, die);
X	signal(SIGHUP, die);
X	signal(SIGSEGV, bad);
X	signal(SIGBUS, bad);
X
X{
X	winptr r;
X
X	r = first_win;
X	while(r)
X	{
X		if(!r->npc)
X			XAutoRepeatOff(r->theDisplay);
X		r=r->next;
X	}
X}
X
X	time_started=time(NULL);
X	mins_left=(int) time_limit/60;
X	secs_left=time_limit;
X	mins_gone=0;
X	while(1)
X	{
X		update_win_strs();
X		update_ships();
X		update_weapons();
X		update_win_input();
X		do_laser_hits();
X		synch_all();
X		dec_earned();
X		if(num_alive<=1) {
X			counter--;
X			if(num_alive==1 && counter==1) winner(0);
X			else { /* unlikely but both may die or quit in the same handle_events loop */
X				if(counter==1) winners();
X			}
X		}
X		update_win_pics();
X		update_junk();
X		no_lasers = 0;
X		tmp=time(NULL);
X		if(mins_left<=1)
X			secs_left=time_limit+time_started-tmp;
X		if(secs_left<=0)
X			winner(2);
X		if(tmp-time_started>59+60*mins_gone)
X		{
X			mins_left--;
X			mins_gone++;
X		}
X	}
X}
END_OF_FILE
if test 12372 -ne `wc -c <'test.c'`; then
    echo shar: \"'test.c'\" unpacked with wrong size!
fi
# end of 'test.c'
fi
echo shar: End of archive 4 \(of 8\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
