Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i003:  xmpb - multiplayer space combat for X, Part03/08
Date: 26 Jun 1993 00:32:40 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2281
Approved: billr@saab.CNA.TEK.COM
Message-ID: <20g5f8$6sm@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1793

Submitted-by: ddp@deakin.edu.au (Damien De Paoli)
Posting-number: Volume 18, Issue 3
Archive-name: xmpb/Part03
Environment: X11, Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 8)."
# Contents:  add_host.c bitmaps/bomb update_ships.c update_win.c
#   weapon.c
# Wrapped by billr@saab on Fri Jun 25 16:30:14 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'add_host.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'add_host.c'\"
else
echo shar: Extracting \"'add_host.c'\" \(13587 characters\)
sed "s/^X//" >'add_host.c' <<'END_OF_FILE'
X/* add_host.c - *** Add a new host (i.e. player) to the game */
X
Xstatic char sccs_id[] = "@(#)add_host.c 1.41 93/03/29 XMPB";
X
X#include "player.h"
X#include "save.h"
X#include "bitmaps/title.bmp"
X#include "bitmaps/stipple"
X#include "bitmaps/jam25"
X#include "bitmaps/jam50"
X#include "bitmaps/jam75"
X#include "bitmaps/jam100"
X
Xwinptr host[20]; 	/* 20 is hard coded, but I don't think it'll change */
Xint no_hosts=0;		/* the number of players so far */
Xint num_alive;		/* the number of alive players */
Xint numnpcs = 0;
Xint num_npcs_alive=0;
Xint num_npcs_windows=0;
Xextern winptr first_win;
Xextern int euid;
X
X/*
X** 
X/*
X*	Give the name of the host display and create the game on that display
X*/
Xadd_host(host_name,npc,npcwin, npcwinname)
Xchar *host_name;
Xint npc, npcwin;
Xchar *npcwinname;
X{
X	char fn[100];
X	FILE *fp;
X
X	XGCValues gcv;
X    int i;
X	XID	fid;
X	Pixmap title;
X	save *w;
X	winptr temp;
X
X	/*
X	*	Open the main window
X	*/
X
X    if(npc)
X	{
X		strcpy(fn, NPCDIR);
X		fp = NULL;
X    	if(host_name)
X		{
X			strcat(fn,host_name);
X    		strcat(fn,".no");
X
Xseteuid(euid);
X    		fp = fopen(fn,"r");
Xseteuid(getuid());
X
X		}
X    	if(!fp) 
X		{
X			fprintf(stderr, "Cannot find NPC: %s\n", host_name);
X			return 0;
X		}
X		fclose(fp);
X	}
X
X	if(!npc)
X	{
X    	host[no_hosts] = xfe_open_window(host_name,0,0,PLAYW,PLAYH,
X                            PLAYW,PLAYW,PLAYH,PLAYH,"xmpb");
X		if(host[no_hosts]==NULL)
X			return 0;
X		host[no_hosts]->npc=0;
X		host[no_hosts]->npcwin=0;
X	}
X	else
X	{
X		if(npcwin)
X		{
X			if(!npcwinname)
X			{
X				fprintf(stderr, "Cannot open a NULL hostname\n");
X				return 0;
X			}
X    		host[no_hosts] = xfe_open_window(npcwinname,0,0,PLAYW,PLAYH,
X                            PLAYW,PLAYW,PLAYH,PLAYH,"xmpb");
X			if(host[no_hosts]==NULL)
X				return 0;
X			host[no_hosts]->npcwin=1;
X		}
X		else
X		{
X			host[no_hosts] = (struct player *)malloc(sizeof(struct player));
X			host[no_hosts]->next = first_win;
X			host[no_hosts]->npcwin=0;
X			first_win = host[no_hosts];
X		}
X		host[no_hosts]->npc=1;
X	}
X	if(host[no_hosts] == NULL)
X		return 0;
X
X	if(!npc || npcwin)	
X	{
X
X		/*
X		* 	Create the hidden buffer
X		*/
X    	host[no_hosts]->back_buffer = XCreatePixmap(host[no_hosts]->theDisplay,
X                                  host[no_hosts]->theWindow,PLAYW+2*OFFSET,PLAYH+2*OFFSET,
X                                  host[no_hosts]->thedepth);
X	}
X	/*
X	*	Initialise the ship motion values
X	*/
X	host[no_hosts]->xv = 0.0;
X	host[no_hosts]->yv = 0.0;
X	host[no_hosts]->angle = 0;
X	host[no_hosts]->angle_v = 0;
X	host[no_hosts]->max_angle_v = 125;
X
X/*  No longer used (I think)
X	host[no_hosts]->max_accel = 3;
X*/
X
X	/*
X	*	turn mouse buttons off
X	*/
X	host[no_hosts]->b1 = 0;
X	host[no_hosts]->b2 = 0;
X	host[no_hosts]->b3 = 0;
X	host[no_hosts]->watching = NULL;
X
X	/*
X	* 	turn thruster off
X	*/
X	host[no_hosts]->t2 = 0;
X
X/*  No longer used (I think)
X	host[no_hosts]->px = PLAYW/2;
X	host[no_hosts]->py = PLAYH/2;
X	host[no_hosts]->last_pic = -1;
X*/
X	/*
X	*	Set random starting point (90 is utterly rand, need 50 tho')
X	*/
X
XSETPOS:
X	host[no_hosts]->sx = (rand()%(WORLDW-90)*2-WORLDW);
X	host[no_hosts]->sy = (rand()%(WORLDH-90)*2-WORLDH);
X	/* Check that we aint on each others posy */
X
X{
X	winptr w;
X	int xnear, ynear;
X
X	w=first_win;
X
X	while (w)
X	{
X		xnear=ynear=0;
X		if(w->sx < host[no_hosts]->sx+50 && w->sx > host[no_hosts]->sx-50)
X			xnear=1;	
X		if(w->sy < host[no_hosts]->sy+50 && w->sx > host[no_hosts]->sy-50)
X			ynear=1;
X		if(xnear && ynear)
X			goto SETPOS;
X		w=w->next;
X	}
X}
X
X	/*
X	* 	Set turn thrusters off
X	*/
X	host[no_hosts]->tl = 0;
X	host[no_hosts]->tr = 0;
X
X	/*
X	*	Not dead yet 
X	*/
X	host[no_hosts]->exploding=0;
X	host[no_hosts]->quitting=6; /* DONT EVEN ASK! */
X	host[no_hosts]->damaged=0;
X
X	/*
X	* Default is long range radar
X	*/
X	host[no_hosts]->short_range_radar = 0;
X
X/* Not used
X	host[no_hosts]->hp_curr=host[no_hosts]->hp_max=100;
X*/
X
X	/*
X	* 	Default is regen on shields and no cloaking
X	*/
X	host[no_hosts]->shield_regen=1;
X	host[no_hosts]->cloaking=0;
X
X	/*
X	* 	Define the repair countdown which sets how fast repairs are done
X	*/
X	host[no_hosts]->rep_count=REPAIR_RATE;
X
X	/*
X	* 	Set person and ship name
X	* currently displayname
X	*/
X	host[no_hosts]->Name[0]=0;
X	host[no_hosts]->Ship[0]=0;
X	host[no_hosts]->password[0]=0;
X	host[no_hosts]->pass2[0]=0;
X	/*host[no_hosts]->title[0]=0; /* used in input.c for passwd check! */
X
X	/*
X	* 	Starting credits
X	*
X	host[no_hosts]->credits = 10000; */
X	host[no_hosts]->earned = 0;
X
X	/*
X	*	Names for items
X	*	these should be global
X	*/
X	strcpy(host[no_hosts]->name[ENGINE],"Engine           ");
X	strcpy(host[no_hosts]->name[CLOAK],"Jammer           ");
X	strcpy(host[no_hosts]->name[SHORTRR],"Short Range Radar");
X	strcpy(host[no_hosts]->name[LONGRR],"Long Range Radar ");
X	strcpy(host[no_hosts]->name[TC],"TC               ");
X	strcpy(host[no_hosts]->name[REPAIR],"Repair           ");
X	strcpy(host[no_hosts]->name[SOLAR],"Solar            ");
X	strcpy(host[no_hosts]->name[IDLE],"Idle                 "); 
X
X
X	/*
X	*	Set default item states
X	*	
X	host[no_hosts]->state[ENGINE]=100;
X	host[no_hosts]->state[CLOAK]=100;
X	host[no_hosts]->state[SHORTRR]=100;
X	host[no_hosts]->state[LONGRR]=100;
X	host[no_hosts]->state[TC]=100;
X	host[no_hosts]->state[REPAIR]=100;
X	host[no_hosts]->state[SOLAR]=100;
X
X	/* 
X	*	Set default quality
X	*	the radars have no associated qualities
X	
X	host[no_hosts]->quality[ENGINE]=3;
X	host[no_hosts]->quality[REPAIR]=2;
X	host[no_hosts]->quality[LONGRR]=0;
X	host[no_hosts]->quality[SHORTRR]=0;
X	host[no_hosts]->quality[TC]=0;
X	host[no_hosts]->quality[CLOAK]=3;
X	host[no_hosts]->quality[SOLAR]=2;
X
X	/*
X	*	Set the probability of an item being hit
X	*	Why is this here?
X	*/
X	host[no_hosts]->prob[TC] = 300;
X	host[no_hosts]->prob[ENGINE] = 600;
X	host[no_hosts]->prob[CLOAK] = 1600;
X	host[no_hosts]->prob[SOLAR] = 600;
X	host[no_hosts]->prob[SHORTRR] = 1800;
X	host[no_hosts]->prob[LONGRR] = 1400;
X	host[no_hosts]->prob[REPAIR] = 400;
X
X	/*
X	* 	Not repairing anything or targeting anything yet
X	*/
X	host[no_hosts]->rep_which = IDLE;
X	host[no_hosts]->targeting = NULL;
X	host[no_hosts]->star=0;
X
X	/*
X	* 	Did we change weapons last frame (NO)
X	*/
X	host[no_hosts]->changed_last_frame = 0;
X
X
X	/*
X	*	Load all weapons
X	*/
X    for(i=0;i<NO_WEAPONS;i++)
X	{
X        host[no_hosts]->load_status[i] = 0;
X		host[no_hosts]->weap_on_status[i] = 1;
X	}
X
X	/*
X	*	Open the radar and stats windows
X	*/
X	if(!npc || npcwin)
X	{
X		if(npcwin)
X		{
X			host[no_hosts]->radar=xfe_open_sub_window(npcwinname,"radar",200,200,665,0);
X			host[no_hosts]->stats=xfe_open_sub_window(npcwinname,"stats",480,415,665,235);
X		}
X		else	
X		{
X			host[no_hosts]->radar=xfe_open_sub_window(host_name,"radar",200,200,665,0);
X			host[no_hosts]->stats=xfe_open_sub_window(host_name,"stats",480,415,665,235);
X		}
X	}
X	/*
X	*	Set the initial pic (i.e facing up)
X	*	this is required else SEGV
X	*/
X	host[no_hosts]->pic = 0;
X
X	/*
X	*	Remove all weapons from ship
X	*
X	for(i=0;i<NO_WEAPONS;i++)
X		host[no_hosts]->does_have_weap[i] = 1;
X
X	/*
X	*	Give only a pulse rifle by default
X	*
X	host[no_hosts]->does_have_weap[WEAP_PULSE] = 1;
X
X	/*
X	*	Set that the shield graphs were not displayed last frame
X	*/
X	host[no_hosts]->lls = host[no_hosts]->lrs = host[no_hosts]->lbs = host[no_hosts]->le = -1;
X
X	/*
X	*	Read all the weapon bitmaps
X	*/
X	if(!npc || npcwin)
X		read_all_weaps(host[no_hosts]);
X
X	/*
X	*	Clear the screen
X	*/
X	if(!npc || npcwin)
X		xfe_clear(host[no_hosts]);
X	
X	if(!npc || npcwin)
X	{
X		/*
X		*	Initialise the hidden buffer GC
X		*/	
X#ifdef NCD
X		gcv.function = GXand;
X#else
X		gcv.function = GXxor;
X#endif /* NCD */
X		gcv.background = host[no_hosts]->theWhitePixel;
X		gcv.foreground = host[no_hosts]->theBlackPixel;
X		gcv.graphics_exposures = False;
X		host[no_hosts]->bbgc = 
X			XCreateGC(host[no_hosts]->theDisplay,host[no_hosts]->back_buffer,
X					(unsigned long)(GCFunction|GCForeground|GCBackground),&gcv);
X	
X		gcv.function = GXnor;
X		gcv.background = host[no_hosts]->theWhitePixel;
X		gcv.foreground = host[no_hosts]->theBlackPixel;
X		gcv.fill_style = FillStippled;
X		gcv.stipple = XCreateBitmapFromData(host[no_hosts]->theDisplay,host[no_hosts]->theWindow,stipple_bits,stipple_width,stipple_height);
X		gcv.graphics_exposures = False;
X		host[no_hosts]->fillgc = 
X			XCreateGC(host[no_hosts]->theDisplay,host[no_hosts]->back_buffer,
X					(unsigned long)(GCFunction|GCForeground|GCBackground|GCFillStyle|GCStipple),&gcv);
X
X		gcv.function = GXnor;
X		gcv.background = host[no_hosts]->theWhitePixel;
X		gcv.foreground = host[no_hosts]->theBlackPixel;
X		gcv.fill_style = FillStippled;
X		gcv.stipple = XCreateBitmapFromData(host[no_hosts]->theDisplay,host[no_hosts]->theWindow,jam25_bits,jam25_width,jam25_height);
X		gcv.graphics_exposures = False;
X		host[no_hosts]->jam25= 
X			XCreateGC(host[no_hosts]->theDisplay,host[no_hosts]->back_buffer,
X					(unsigned long)(GCFunction|GCForeground|GCBackground|GCFillStyle|GCStipple),&gcv);
X	
X		gcv.function = GXnor;
X		gcv.background = host[no_hosts]->theWhitePixel;
X		gcv.foreground = host[no_hosts]->theBlackPixel;
X		gcv.fill_style = FillStippled;
X		gcv.stipple = XCreateBitmapFromData(host[no_hosts]->theDisplay,host[no_hosts]->theWindow,jam50_bits,jam50_width,jam50_height);
X		gcv.graphics_exposures = False;
X		host[no_hosts]->jam50= 
X			XCreateGC(host[no_hosts]->theDisplay,host[no_hosts]->back_buffer,
X					(unsigned long)(GCFunction|GCForeground|GCBackground|GCFillStyle|GCStipple),&gcv);
X	
X		gcv.function = GXnor;
X		gcv.background = host[no_hosts]->theWhitePixel;
X		gcv.foreground = host[no_hosts]->theBlackPixel;
X		gcv.fill_style = FillStippled;
X		gcv.stipple = XCreateBitmapFromData(host[no_hosts]->theDisplay,host[no_hosts]->theWindow,jam75_bits,jam75_width,jam75_height);
X		gcv.graphics_exposures = False;
X		host[no_hosts]->jam75= 
X			XCreateGC(host[no_hosts]->theDisplay,host[no_hosts]->back_buffer,
X					(unsigned long)(GCFunction|GCForeground|GCBackground|GCFillStyle|GCStipple),&gcv);
X	
X		gcv.function = GXnor;
X		gcv.background = host[no_hosts]->theWhitePixel;
X		gcv.foreground = host[no_hosts]->theBlackPixel;
X		gcv.fill_style = FillStippled;
X		gcv.stipple = XCreateBitmapFromData(host[no_hosts]->theDisplay,host[no_hosts]->theWindow,jam100_bits,jam100_width,jam100_height);
X		gcv.graphics_exposures = False;
X		host[no_hosts]->jam100= 
X			XCreateGC(host[no_hosts]->theDisplay,host[no_hosts]->back_buffer,
X					(unsigned long)(GCFunction|GCForeground|GCBackground|GCFillStyle|GCStipple),&gcv);
X
X		gcv.function = GXnor;
X		gcv.background = host[no_hosts]->theWhitePixel;
X		gcv.foreground = host[no_hosts]->theBlackPixel;
X		gcv.graphics_exposures = False;
X		host[no_hosts]->bmgc = 
X			XCreateGC(host[no_hosts]->theDisplay,host[no_hosts]->back_buffer,
X					(unsigned long)(GCFunction|GCForeground|GCBackground),&gcv);
X	
X		gcv.function = GXset;
X		gcv.background = host[no_hosts]->theWhitePixel;
X		gcv.foreground = host[no_hosts]->theBlackPixel;
X		gcv.graphics_exposures = False;
X	
X		host[no_hosts]->bbcleargc = 
X			XCreateGC(host[no_hosts]->theDisplay,host[no_hosts]->back_buffer,
X					(unsigned long)(GCFunction|GCForeground|GCBackground),&gcv);
X		/*
X		*	Create the title bitmap from the included file
X		*/
X		title = XCreateBitmapFromData(host[no_hosts]->theDisplay,host[no_hosts]->theWindow,title_bits,title_width,title_height);
X	
X		/*
X		*	Create the GC for blitting the hidden buffer to the window
X		*/
X		gcv.function = GXcopy;
X		gcv.background = host[no_hosts]->theWhitePixel;
X		gcv.foreground = host[no_hosts]->theBlackPixel;
X		gcv.graphics_exposures = False;
X		host[no_hosts]->blgc = 
X			XCreateGC(host[no_hosts]->theDisplay,host[no_hosts]->back_buffer,
X					(unsigned long)(GCFunction|GCForeground|GCBackground),&gcv);
X
X		gcv.function = GXcopy;     /* need diff GC, to draw black back, and white fore */
X    	gcv.foreground = host[no_hosts]->theWhitePixel;
X    	gcv.background = host[no_hosts]->theBlackPixel;
X    	gcv.graphics_exposures = False;
X    	host[no_hosts]->aGC = 
X			XCreateGC(host[no_hosts]->theDisplay,host[no_hosts]->theWindow, 
X				(unsigned long)(GCFunction|GCForeground |GCBackground),&gcv);
X	
X		/* Wait for the window to be mapped (kludgy I know) */
X		sleep(1);
X	
X		/*
X		*	Show the screen title
X		*/
X		XCopyPlane(host[no_hosts]->theDisplay,title,host[no_hosts]->theWindow,
X			host[no_hosts]->blgc,0,0,title_width,title_height,(PLAYW-title_width)/2,
X			(PLAYH-title_height)/2,1);	
X	
X		/*
X		*	Throw away the bitmap
X		*/
X		XFreePixmap(host[no_hosts]->theDisplay,title);
X		XSync(host[no_hosts]->theDisplay,False);
X		/*
X		*	Tell the server what events we would like
X		*/
X		XSelectInput(host[no_hosts]->theDisplay,
X			host[no_hosts]->theWindow,EVENTMASK);
X	
X		/*
X		*	Read the ship, thrust and star bitmaps
X		*/
X/*
X	read_ship(host[no_hosts]);
X	read_thrusts(host[no_hosts]);
X*/
X		read_stars(host[no_hosts]);
X
X		/*
X		*	Set up random 2 planes of stars
X		*/
X		init_stars(host[no_hosts]);
X	
X		/*
X		*	Don't want graphics exposures when copying pixmaps, thank you
X		*/
X		XSetGraphicsExposures(host[no_hosts]->theDisplay,host[no_hosts]->theGC,False);
X		XSetGraphicsExposures(host[no_hosts]->theDisplay,host[no_hosts]->bbgc,False);
X		XSetGraphicsExposures(host[no_hosts]->theDisplay,host[no_hosts]->blgc,False);
X		XSetGraphicsExposures(host[no_hosts]->theDisplay,host[no_hosts]->aGC,False);
X		/*
X		*	get the font id of the default font
X		*/
X    	fid=(XID) XGContextFromGC(host[no_hosts]->bbgc);
X    	host[no_hosts]->xf=XQueryFont(host[no_hosts]->theDisplay,fid);
X
X		/*
X		** load the junk bitmaps
X		*/
X		load_junkmaps(host[no_hosts]);
X	}
X	if(npc)
X	{	
X		if(load_npc(host[no_hosts],host_name))
X		{
X			numnpcs++;
X			num_npcs_alive++;
X		}
X		host[no_hosts]->quitting = 0;
X		if(host[no_hosts]->npcwin)
X			num_npcs_windows++;
X	}
X	no_hosts++;
X	num_alive=no_hosts;
X	return 1;
X}
END_OF_FILE
if test 13587 -ne `wc -c <'add_host.c'`; then
    echo shar: \"'add_host.c'\" unpacked with wrong size!
fi
# end of 'add_host.c'
fi
if test -f 'bitmaps/bomb' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/bomb'\"
else
echo shar: Extracting \"'bitmaps/bomb'\" \(186 characters\)
sed "s/^X//" >'bitmaps/bomb' <<'END_OF_FILE'
X#define bomb_width 9
X#define bomb_height 9
Xstatic char bomb_bits[] = {
X   0x38, 0x00, 0xee, 0x00, 0xf2, 0x00, 0xf1, 0x01, 0xf1, 0x01, 0xf1, 0x01,
X   0xf2, 0x00, 0xee, 0x00, 0x38, 0x00};
END_OF_FILE
if test 186 -ne `wc -c <'bitmaps/bomb'`; then
    echo shar: \"'bitmaps/bomb'\" unpacked with wrong size!
fi
# end of 'bitmaps/bomb'
fi
if test -f 'update_ships.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'update_ships.c'\"
else
echo shar: Extracting \"'update_ships.c'\" \(15776 characters\)
sed "s/^X//" >'update_ships.c' <<'END_OF_FILE'
X/* update_ships.c - *** Routines that update ships data each frame */
X
Xstatic char sccs_id[] = "@(#)update_ships.c 1.26 92/11/24 XMPB";
X
X#include <math.h>
X#include "player.h"
X
X/*
X*	How fast shields re-energize
X*	Should be in plaer.h
X*/
X#define SHIELD_CHARGE 1
X
Xextern int mysintab[],mycostab[];
Xextern junkptr first_junk;
Xextern winptr first_win;
X
Xdouble line_2_linef();
X
X/*
X*	Move all ships and check for collisions between ships and walls
X*/
Xupdate_ships()
X{
X	winptr t,w;
X	junkptr j;
X	int xa,ya;
X	double q;
X
X	int rsh=0,bsh=0,lsh=0;
X	int relx,rely,mom;
X
X	t = first_win;
X	while(t)
X	{
X		/*
X		** set damaged so that we know to update stats window
X		*/
X		t->damaged=1;
X	
X		/* 
X		*	re-energize shields 
X		*/
X		if(t->shield_regen && !t->exploding)
X		{
X			if(t->shield_cnt == 0)
X			{
X			if((t->ls_curr < t->ls_max) && (t->energy_curr >= SHIELD_CHARGE))
X			{
X				if(t->ls_max - t->ls_curr > SHIELD_CHARGE)
X				{
X					t->ls_curr += SHIELD_CHARGE;
X					t->energy_curr -= SHIELD_CHARGE;
X				}
X				else
X				{
X					t->energy_curr -= (t->ls_max - t->ls_curr);
X					t->ls_curr = t->ls_max;
X				}
X			}
X			if((t->rs_curr < t->rs_max) && (t->energy_curr >= SHIELD_CHARGE))
X			{
X				if(t->rs_max - t->rs_curr > SHIELD_CHARGE)
X				{
X					t->rs_curr += SHIELD_CHARGE;
X					t->energy_curr -= SHIELD_CHARGE;
X				}
X				else
X				{
X					t->energy_curr -= (t->rs_max - t->rs_curr);
X					t->rs_curr = t->rs_max;
X				}
X			}
X			if((t->bs_curr < t->bs_max) && (t->energy_curr >= SHIELD_CHARGE))
X			{
X				if((t->bs_max - t->bs_curr) > SHIELD_CHARGE)
X				{
X					t->bs_curr += SHIELD_CHARGE;
X					t->energy_curr -= SHIELD_CHARGE;
X				}
X				else
X				{
X					t->energy_curr -= (t->bs_max - t->bs_curr);
X					t->bs_curr = t->bs_max;
X				}
X			}
X			t->shield_cnt = 3;
X			}
X			else
X			{
X				t->shield_cnt--;
X			}
X		}	
X
X		if(t->tl)
X		{
X			if(t->angle_v > -t->max_angle_v)
X                t->angle_v--;
X		}
X		if(t->tr)
X		{
X			if(t->angle_v < t->max_angle_v)
X                t->angle_v++;
X		}
X	
X		/*
X		*	If the ship can thrust & they button is pressed & the boxhead 
X		*	has a working engine
X		*/		
X		if(t->t2 && enough_e_to_thr(t) && t->state[ENGINE]>0)
X		{
X			/*
X			*	Lose energy
X			*/
X			t->energy_curr -= THRUST_E_USE;
X
X			/*
X			*	Calc the acceleraation
X			*/
X        	xa = (t->quality[ENGINE]*t->state[ENGINE]/100*mysintab[(int)t->angle])/4;
X        	ya = (t->quality[ENGINE]*t->state[ENGINE]/100*mycostab[(int)t->angle])/4;
X
X			
X			/*
X			**  if decelelerating, make it 2 *
X			*/
X#define diffsign(x,y)	(((x)> 0) ? ((y) < 0) ? 1 : 0 : ((y) < 0) ? 0 : 1)
X#define IABS(x)			(((x)>0)?x:-x)
X
X			if(diffsign(xa,t->xv) && IABS(t->xv) > 5000) 
X				xa=2*xa;
X			if(diffsign(ya,t->yv) && IABS(t->yv) > 5000) 
X				ya=2*ya;
X
X			/*
X			*	Add to the velocity of the ship
X			*/
X        	t->xv += xa;
X        	t->yv += ya;
X		}
X		else  /* not enough energy to thrust, so turn off pic */
X		{	
X			t->t2 = 0;
X		}
X
X		/*
X		*	Move ship with current velocity
X		*/	
X		t->sx += t->xv/32768;
X		t->sy += t->yv/32768;
X		if(t->exploding > 0 && t->exploding < 450)
X		{	
X			if(t->watching)
X			{
X				t->sx = t->watching->sx;
X				t->sy = t->watching->sy;
X			}
X/*
X			int x=0,y=0;
X			int n=0;
X
X			winptr temp = first_win;
X
X			while(temp)
X			{
X				if(temp != t)
X				{
X					x += temp->sx;
X					y += temp->sy;
X					n++;
X				}
X				temp = temp->next;
X			}
X			t->sx = x/n;
X			t->sy = y/n;
X*/
X		}
X		else if(t->exploding)
X		{
X			t->exploding--;
X		}
X			
X	
X		/*
X		*	Re-energize from solar panels
X		*/	
X		t->energy_curr+=(5*t->quality[SOLAR]*t->state[SOLAR]/200);
X		if(t->energy_curr > t->energy_max)
X             t->energy_curr = t->energy_max;
X
X		/*
X		*	If enough energy left, repairs are made on selected item
X		*/
X		if(t->rep_which != IDLE 
X			&& t->energy_curr >= 10 
X			&& t->state[t->rep_which] < 100 
X			&& t->state[t->rep_which] > 0)
X		{
X			/*
X			*	Only repair if the countdown has reached below this level
X			*/
X			if(t->rep_count < 0.1)
X			{
X				/*
X				*	Fix the item a bit
X				*/
X				t->state[t->rep_which] += 1;
X
X				/*
X				*	Suck energy
X				*/
X				t->energy_curr -= 50/t->quality[REPAIR];
X
X				/*
X				*	If the item is fixed, turn off repair
X				*/
X				if(t->state[t->rep_which] == 100)
X				{
X					t->rep_which = IDLE;
X				}
X
X				/*
X				*	Start counter back at start
X				*/
X				t->rep_count = 11.0 - (double)t->quality[REPAIR];
X			}
X			else  /* counter not counted down enough */
X			{
X				/*
X				*	Dec counter by amount depending on repair state
X				*/
X				t->rep_count -= ((float)t->state[REPAIR]/100.0);
X			}	
X		}
X		/*
X		*	If item destroyed while repairing, set repair to idle
X		*/
X		if(t->state[t->rep_which] == 0)
X		{
X			t->rep_which = IDLE;
X		}
X
X		t->angle += t->angle_v;
X		if(t->angle > 359)
X			t->angle -= 360;
X		if(t->angle < 0)
X			t->angle += 360;
X        t->pic = ((int)(((double)t->angle+7.5)/15.0)%24);
X
X		/*	
X		** If cloaking then suck the energy
X		*/
X		if(t->state[CLOAK]!=0 && t->cloaking && (t->energy_curr >= 25/t->quality[CLOAK])) 
X		{
X			t->energy_curr -= 25/t->quality[CLOAK];
X			if(t->state[CLOAK] >= rand()%100+1)
X				untarget(t);
X		}
X		else t->cloaking=0;
X
X		/*
X		*	Move to 2 planes of stars
X		*/
X		do_stars(t);
X
X		/*
X		*	Do pics for thrusting
X		*/
X		update_thrust(t);
X
X		/*
X		*	Okay, do the next ship
X		*/	
X		t = t->next;
X	}
X
X	/*
X	* 	Pre calculate all the shield positions
X	*/
X	precalc();
X
X	/*
X	*	Now lets do collision detection
X	*/
X	t = first_win;
X	while(t)
X	{
X		/*
X		*	If we're dead don't check for collisions
X		*/
X		if(t->exploding) 
X			goto KLUDGE;	
X
X		/*
X		*	Check for collisions with the four walls
X		*/
X		if(t->sx < (-WORLDW + 50) || t->sx > (WORLDW -50)) {
X		int dam;
X
X			/*
X			*	damage is dependent on velocity
X			*/
X			t->xv=-t->xv;
X			if(t->sx < 0)
X			{
X				t->sx = (-WORLDW + 55);
X			}
X			else
X			{
X				t->sx = (WORLDW - 55);
X			}
X			dam = t->xv/32768;
X			dam = dam < 0 ? -3*dam : 3*dam;
X			damage_ship(t,RSH,dam);
X			damage_ship(t,LSH,dam);
X			damage_ship(t,BSH,dam);
X		}
X		if(t->sy < (-WORLDH + 50) || t->sy > (WORLDH -50)) 
X		{
X		int dam;
X
X			t->yv=-t->yv;
X			if(t->sy < 0)
X			{
X				t->sy = (-WORLDH + 55);
X			}
X			else
X			{
X				t->sy = (WORLDH - 55);
X			}
X			dam = t->xv/32768;
X			dam = t->yv/32768;
X			dam = dam < 0 ? -3*dam : 3*dam;
X			damage_ship(t,RSH,dam);
X			damage_ship(t,LSH,dam);
X			damage_ship(t,BSH,dam);
X		}
X
X		/*
X		*	Start at the ship after this one to check for collision with
X		*/
X		w = t->next;
X		while(w)
X		{
X			/*
X			*	Don't allow collisions with non-existent ships
X			*/
X			if(w->exploding)
X				goto kludge3; 	/* twas the easiest way :-) */
X
X			/* 
X			*	bounding rectangle check
X			*/
X			if((w->sx < (t->sx+100)) && (w->sx > (t->sx-100)) && (w->sy < (t->sy+100)) && (w->sy > (t->sy-100)))
X			{
X				int p1x,p1y;
X                int p2x,p2y;
X                int p3x,p3y;
X
X				int w1x,w1y;
X                int w2x,w2y;
X                int w3x,w3y;
X
X				double trwb,trwl,trwr,tlwl,tlwr,tlwb,tbwr,tbwl,tbwb;
X				double trhits,tlhits,tbhits,wbhits,wlhits,wrhits;
X
X				/*
X				*	Calculate the points of the three shield lines
X				*	for this ship
X				*/
X				p1x = t->p1x;
X				p1y = t->p1y;
X				p2x = t->p2x;
X				p2y = t->p2y;
X				p3x = t->p3x;
X				p3y = t->p3y;
X
X				/*
X				*	And the other	
X				*/
X				w1x = w->p1x;
X				w1y = w->p1y;
X				w2x = w->p2x;
X				w2y = w->p2y;
X				w3x = w->p3x;
X				w3y = w->p3y;
X
X				/*
X				*	test for intersection of the 9 lines
X				*/	
X				trwr = line_2_linef(p1x,p1y,p2x,p2y,w1x,w1y,w2x,w2y);
X				trwl = line_2_linef(p1x,p1y,p2x,p2y,w1x,w1y,w3x,w3y);
X				trwb = line_2_linef(p1x,p1y,p2x,p2y,w3x,w3y,w2x,w2y);
X
X				tlwr = line_2_linef(p1x,p1y,p3x,p3y,w1x,w1y,w2x,w2y);
X				tlwl = line_2_linef(p1x,p1y,p3x,p3y,w1x,w1y,w3x,w3y);
X				tlwb = line_2_linef(p1x,p1y,p3x,p3y,w3x,w3y,w2x,w2y);
X
X				tbwr = line_2_linef(p3x,p3y,p2x,p2y,w1x,w1y,w2x,w2y);
X				tbwl = line_2_linef(p3x,p3y,p2x,p2y,w1x,w1y,w3x,w3y);
X				tbwb = line_2_linef(p3x,p3y,p2x,p2y,w3x,w3y,w2x,w2y);
X				
X				/*
X				*	How many hits to w
X				*/	
X				wrhits = trwr+tlwr+tbwr;
X				wlhits = trwl+tlwl+tbwl;
X				wbhits = trwb+tlwb+tbwb;
X
X				/*
X				* 	And hown may on t's shields
X				*/
X				trhits = trwr+trwl+trwb;
X				tlhits = tlwr+tlwl+tlwb;
X				tbhits = tbwr+tbwl+tbwb;
X
X				/*	
X				*	A value of -9.0 on a shield means that there were no
X				*	hits to it, so if there are no hits to any of w's
X				*	shields, then there was no collision
X				*/
X				if(wrhits > -9.0 || wlhits > -9.0 || wbhits > -9.0)
X				{
X					int wtx,wty,twx,twy;
X					double scale;
X
X					/* 
X					*	Ok the ships have hit 
X					*/
X
X					int dam;
X					long int temp;
X					int relxv,relyv;
X					int tdam,wdam,tcount,wcount;
X
X					/*
X					*	Find out the relative velocity, use to calc damage
X					*/
X					relxv = (w->xv - t->xv)/32768;
X					relyv = (w->yv - t->yv)/32768;
X
X					dam = relxv*relxv+relyv*relyv;
X					dam = 10*(int)(sqrt((double)(dam)));
X			
X					/*
X					*	Find out how many of each ships shields was hit
X					*	to spread damage about
X					*/	
X					wcount = 0;
X					tcount = 0;
X					if(wrhits > -9.0)
X						wcount++;
X					if(wlhits > -9.0)
X						wcount++;
X					if(wbhits > -9.0)
X						wcount++;
X
X					if(trhits > -9.0)
X						tcount++;
X					if(tlhits > -9.0)
X						tcount++;
X					if(tbhits > -9.0)
X						tcount++;
X
X					if(tcount)
X						tdam = dam/tcount;
X					else
X						tdam = 0;
X					if(wcount)
X						wdam = dam/wcount;
X					else 
X						wdam = 0;
X
X					/*
X					*	Earned credits goes up with damage
X					*/
X					scale=(double)(t->ship_value+t->earned)/(double)(w->ship_value+w->earned);
X
X					if(scale > 10)
X						scale=10;
X					if(scale < 0.1)
X						scale=0.1;
X					t->earned += (int) (5.0*(double)dam*(1.0/scale));
X					w->earned += (int) (5.0*(double)dam*scale);
X
X					/*
X					*	Now put the damage on the ship
X					*/
X					if(wrhits > -9.0)
X					{
X						if(damage_ship(w,RSH,wdam))
X						{
X							t->kills++;
X						}
X					}
X					if(wlhits > -9.0)
X					{
X						if(damage_ship(w,LSH,wdam))
X						{
X							t->kills++;
X						}
X					}
X					if(wbhits > -9.0)
X					{
X						if(damage_ship(w,BSH,wdam))
X						{
X							t->kills++;
X						}
X					}
X
X					if(trhits > -9.0)
X					{
X						if(damage_ship(t,RSH,tdam))
X						{
X							w->kills++;
X						}
X					}
X					if(tlhits > -9.0)
X					{
X						if(damage_ship(t,LSH,tdam))
X						{
X							w->kills++;
X						}
X					}
X					if(tbhits > -9.0)
X					{
X						if(damage_ship(t,BSH,tdam))
X						{
X							w->kills++;
X						}
X					}
X
X					/*
X					*	Swap velocities for quick and easy momentum
X					*/
X
X					w->sx += t->xv/32768;
X					w->sy += t->yv/32768;
X					t->sx += w->xv/32768;
X					t->sy += w->yv/32768;
X
X/* Old turn nose on bug ... */
X
X					wtx = mycostab[(w->angle)%360]*w->angle_v/2;
X					wty = mysintab[(w->angle)%360]*w->angle_v/2;
X					twx = mycostab[(t->angle)%360]*t->angle_v/2;
X					twy = mysintab[(t->angle)%360]*t->angle_v/2;
X
X					temp = w->xv+wtx;
X					w->xv = t->xv+twx;
X					t->xv = temp;
X
X					temp = w->yv+wty;
X					w->yv = t->yv+twy;
X					t->yv = temp;
X
X
X
X#define SGN(x)	((x)>0?1:-1)
X
X
X/* YATNF */
X					temp=t->angle_v;
X					t->angle_v=-w->angle_v;
X					w->angle_v=-temp;
X
X				
X/* New turn nose bug fix ... 
X
X					w->yv = -SGN(w->yv)*327680+w->yv; 
X					w->xv = -SGN(w->xv)*327680+w->xv; 
X
X					t->xv = -SGN(t->xv)*327680+t->xv; 
X					t->yv = -SGN(t->yv)*327680+t->yv; 
X
X					temp = w->xv;
X					w->xv = t->xv;
X					t->xv = temp;
X
X					temp = w->yv;
X					w->yv = t->yv;
X					t->yv = temp;
X
X					w->sx +=w->xv/32768;
X					w->sy +=w->yv/32768;
X
X					t->sx +=t->xv/32768;
X					t->sy +=t->yv/32768;
X*/
X				}
X			}
Xkludge3:
X			w = w->next;
X		}
X		/*
X		*	Check for collision with junk items
X		*/
X
X		j = first_junk;
X		while(j)
X		{
X			if((j->type <= BIGROCK)&&(j->sx < (t->sx+75)) && (j->sx > (t->sx-75)) && (j->sy < (t->sy+75)) && (j->sy > (t->sy-75)))
X			{
X				int m2,c2,r2;
X				int z;
X
X				rsh=0;bsh=0;lsh=0;
X			
X				if(j->type == BIGROCK)
X				{
X					r2 = 25;
X					mom = 2;
X				}
X				else if(j->type == MEDROCK)
X				{
X					r2 = 11;
X					mom = 9;
X				}
X				else if(j->type == SMALLROCK)
X				{
X					r2 = 5;
X					mom = 125;
X				}
X				rsh = line_2_circle(t->p1x,t->p1y,t->p2x,t->p2y,j->sx,j->sy,r2);
X				lsh = line_2_circle(t->p1x,t->p1y,t->p3x,t->p3y,j->sx,j->sy,r2);
X				bsh = line_2_circle(t->p3x,t->p3y,t->p2x,t->p2y,j->sx,j->sy,r2);
XAARGH:
X				relx = t->xv - j->xv;
X				rely = t->yv - j->yv;
X				if(rsh)
X				{
X					damage_ship(t,RSH,2*(int)sqrt((double)(relx/32768*relx/32768+rely/32768*rely/32768)/mom));
X					if(mom < 5)
X					{
X						z = t->xv;
X						t->xv = j->xv;
X						j->xv = z;
X						z = t->yv;
X						t->yv = j->yv;
X						j->yv = z;
X					}
X					else
X					{
X					t->xv = t->xv+(int)((double)-relx*(((double)2.0)/((double)mom+1.0)))/mom;
X					t->yv = t->yv+(int)((double)-rely*(((double)2.0)/((double)mom+1.0)))/mom;
X					j->xv = t->xv+(int)((double)-relx*((1.0-(double)mom)/((double)mom+1.0)));
X					j->yv = t->yv+(int)((double)-rely*((1.0-(double)mom)/((double)mom+1.0)));
X					}
X
X					j->sx+=j->xv/32768;
X					j->sy+=j->yv/32768;
X					t->sx+=t->xv/32768;
X					t->sy+=t->yv/32768;
X				}
X				else
X				if(lsh)
X				{
X					damage_ship(t,LSH,2*(int)sqrt((double)(relx/32768*relx/32768+rely/32768*rely/32768)/mom));
X					if(mom < 5)
X					{
X						z = t->xv;
X						t->xv = j->xv;
X						j->xv = z;
X						z = t->yv;
X						t->yv = j->yv;
X						j->yv = z;
X					}
X					else
X					{
X					t->xv = t->xv+(int)((double)-relx*(((double)2.0)/((double)mom+1.0)))/mom;
X					t->yv = t->yv+(int)((double)-rely*(((double)2.0)/((double)mom+1.0)))/mom;
X					j->xv = t->xv+(int)((double)-relx*((1.0-(double)mom)/((double)mom+1.0)));
X					j->yv = t->yv+(int)((double)-rely*((1.0-(double)mom)/((double)mom+1.0)));
X					}
X					/*t->xv -= relx/mom;
X					t->yv -= rely/mom;
X					j->xv += relx*2;
X					j->yv += rely*2;
X*/
X
X					j->sx+=j->xv/32768;
X					j->sy+=j->yv/32768;
X					t->sx+=t->xv/32768;
X					t->sy+=t->yv/32768;
X				}
X				else
X				if(bsh)
X				{
X					damage_ship(t,BSH,2*(int)sqrt((double)(relx/32768*relx/32768+rely/32768*rely/32768)/mom));
X					if(mom < 5)
X					{
X						z = t->xv;
X						t->xv = j->xv;
X						j->xv = z;
X						z = t->yv;
X						t->yv = j->yv;
X						j->yv = z;
X					}
X					else
X					{
X					t->xv = t->xv+(int)((double)-relx*(((double)2.0)/((double)mom+1.0)))/mom;
X					t->yv = t->yv+(int)((double)-rely*(((double)2.0)/((double)mom+1.0)))/mom;
X					j->xv = t->xv+(int)((double)-relx*((1.0-(double)mom)/((double)mom+1.0)));
X					j->yv = t->yv+(int)((double)-rely*((1.0-(double)mom)/((double)mom+1.0)));
X					}
X/*					t->xv -= relx/mom;
X					t->yv -= rely/mom;
X					j->xv += relx*2;
X					j->yv += rely*2;
X*/
X
X					j->sx+=j->xv/32768;
X					j->sy+=j->yv/32768;
X					t->sx+=t->xv/32768;
X					t->sy+=t->yv/32768;
X				}
X				else
X				{
X					int nx,ny;
X					double r,l,b;
X					nx = j->sx+j->xv/32768;
X					ny = j->sy+j->yv/32768;
X					r = line_2_linef(j->sx,j->sy,nx,ny,t->p1x,t->p1y,t->p2x,t->p2y);
X					b = line_2_linef(j->sx,j->sy,nx,ny,t->p3x,t->p3y,t->p2x,t->p2y);
X					l = line_2_linef(j->sx,j->sy,nx,ny,t->p3x,t->p3y,t->p1x,t->p1y);
X
X
X					if(r > b)
X					{
X						if(r > l)
X							q = r;
X						else
X							q = l;
X					}
X					else
X					{	
X						if(b > l)
X							q = b;
X						else
X							q = l;
X					}
X	
X					if(r == q && r > -3.0)
X					{
X						rsh = 1;
X						goto AARGH;
X					}
X					else
X					if(l == q && l > -3.0)
X					{
X						lsh = 1;
X						goto AARGH;
X					}
X					else
X					if(b == q && b > -3.0)
X					{
X						bsh = 1;
X						goto AARGH;
X					}
X				}
X			}
X/*
X			if(lsh || rsh || bsh)
X			{
X				int speed_coll;
X				junkptr jj;
X				speed_coll = (int)sqrt((double)(relx/32768*relx/32768+rely/32768*rely/32768));
X				if(j->type == BIGROCK && speed_coll > 10)
X				{
X					int i;
X
X					jj = j->next;
X					add_junk(MEDROCK,j->sx,j->sy,j->xv,j->yv+40*32768);	
X					add_junk(MEDROCK,j->sx,j->sy,j->xv+(33)*32768,j->yv+(-33)*32768);	
X					add_junk(MEDROCK,j->sx,j->sy,j->xv+(-33)*32768,j->yv+(-33)*32768);	
X					free_junk(j);
X					j = jj;
X				}
X				else
X				if(j->type == MEDROCK && speed_coll > 100)
X				{
X				}	
X				else
X					j = j->next;
X			}	
X			else
X*/
X				j = j->next;
X		}
XKLUDGE:
X		t = t->next;
X	}
X}
END_OF_FILE
if test 15776 -ne `wc -c <'update_ships.c'`; then
    echo shar: \"'update_ships.c'\" unpacked with wrong size!
fi
# end of 'update_ships.c'
fi
if test -f 'update_win.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'update_win.c'\"
else
echo shar: Extracting \"'update_win.c'\" \(5068 characters\)
sed "s/^X//" >'update_win.c' <<'END_OF_FILE'
X/* update_win.c - ***  */
X
Xstatic char sccs_id[] = "@(#)update_win.c 1.18 92/11/11 XMPB";
X#include "player.h"
X
Xextern int mysintab[],mycostab[];
Xextern struct laser lasers[];
Xextern int no_lasers;
Xextern junkptr first_junk;
Xextern winptr first_win;
X
Xupdate_win_pics()
X{
X	int i,j,k;
X	int tx,ty;
X	junkptr junk;
X	winptr temp,t;
X	int otherx[MAXHOST],othery[MAXHOST];
X	char othername[MAXHOST][MAX_NAME_SIZE];
X	int other_vis,t1,t2,t3,op,opic[MAXHOST],ot1[MAXHOST],ot2[MAXHOST];
X	winptr otherptr[MAXHOST];
X	int ot3[MAXHOST];
X
X    temp = first_win;
X    while(temp != NULL)
X    {
X
X		if(temp->quitting || (temp->npc && !temp->npcwin) )
X			goto Kludge;
X		other_vis = 0;
X		i =0;
X		t = first_win;
X		while(t)
X		{
X			if(t != temp)
X			{
X				otherx[i] = (PLAYW/2 - temp->sx+t->sx);
X				othery[i] = (PLAYH/2 - t->sy+temp->sy);
X				if(!t->cloaking)
X					strcpy(othername[i],t->Name); 
X				else
X					strcpy(othername[i]," ");
X				ot1[i] = t->t1;
X				ot2[i] = t->t2;
X				ot3[i] = t->t3;
X				opic[i] = t->angle;
X				otherptr[i]=t;
X				if((otherx[i] < (PLAYW +OFFSET))&&(otherx[i] > -OFFSET) && (othery[i] < (PLAYH +OFFSET)) && (othery[i] > -OFFSET) && !t->exploding)
X				{
X					other_vis = 1;
X					i++;
X				}
X			}
X			t = t->next;
X		}
X		XFillRectangle(temp->theDisplay,temp->back_buffer,temp->bbcleargc,0,0,PLAYW+2*OFFSET,PLAYH+2*OFFSET);
X
X		if(temp->exploding==499)
X		{
X			temp->exploding--;
X			XFillRectangle(temp->theDisplay,temp->back_buffer,temp->bbgc,0,0,PLAYW+2*OFFSET,PLAYH+2*OFFSET);
X		}
X		if(!temp->exploding)	
X		{
X       		disp_ship(temp,temp->angle,PLAYW/2,PLAYH/2,temp->t1,temp->t2,temp->t3, temp);
X/*
X			if((temp->rs_curr) > temp->rs_max/3 || (!(rand()%((temp->rs_max/3-temp->rs_curr)/40+1))))
X			XDrawLine(temp->theDisplay,temp->back_buffer,temp->bbgc,OFFSET+PLAYW/2+50*mysintab[temp->angle]/32768,OFFSET+PLAYH/2-50*mycostab[temp->angle]/32768,OFFSET+PLAYW/2+40*mysintab[(temp->angle+135)%360]/32768,OFFSET+PLAYH/2-40*mycostab[(temp->angle+135)%360]/32768);
X			if((temp->ls_curr) > temp->ls_max/3 || (!(rand()%((temp->ls_max/3-temp->ls_curr)/40+1))))
X			XDrawLine(temp->theDisplay,temp->back_buffer,temp->bbgc,OFFSET+PLAYW/2+50*mysintab[temp->angle]/32768,OFFSET+PLAYH/2-50*mycostab[temp->angle]/32768,OFFSET+PLAYW/2+40*mysintab[(temp->angle+225)%360]/32768,OFFSET+PLAYH/2-40*mycostab[(temp->angle+225)%360]/32768);
X			if((temp->bs_curr) > temp->bs_max/3 || (!(rand()%((temp->bs_max/3-temp->bs_curr)/40+1))))
X			XDrawLine(temp->theDisplay,temp->back_buffer,temp->bbgc,OFFSET+PLAYW/2+40*mysintab[(temp->angle+225)%360]/32768,OFFSET+PLAYH/2-40*mycostab[(temp->angle+225)%360]/32768,OFFSET+PLAYW/2+40*mysintab[(temp->angle+135)%360]/32768,OFFSET+PLAYH/2-40*mycostab[(temp->angle+135)%360]/32768);
X*/
X		}
X		disp_all_items(temp);
X
X		/*
X		*	Draw all of the junk items
X		*/
X		junk = first_junk;
X		while(junk)
X		{
X			int x,y;
X
X			x = (PLAYW/2 - temp->sx+junk->sx);
X			x -= temp->j_w[junk->type]/2;
X			y = (PLAYH/2 - junk->sy+temp->sy);
X			y -= temp->j_h[junk->type]/2;
X			if(x < PLAYW+OFFSET && x > 0-OFFSET && y < PLAYH+OFFSET && y > -OFFSET)
X			{
X				/*
X				*	Ok its visible
X				*/
X	
X				switch(junk->type)
X				{
X					case DEBRIS1:
X					case DEBRIS2:
X					case DEBRIS3:
X					case CLOUD1:
X					case CLOUD2:
X					case CLOUD3:
X					case CLOUD4:
X					case CLOUD5:
X					case CLOUD6:
X					case DEADDUDE:
X					case SMALLROCK:
X					case MEDROCK:
X					case BIGROCK:
X					{
X						XCopyPlane(temp->theDisplay,temp->junk_pm[junk->type],
X							temp->back_buffer,temp->bbgc,0,0,
X							temp->j_w[junk->type],temp->j_h[junk->type],
X							x+OFFSET,y+OFFSET,1);
X					}
X					break;
X					default:
X						xmpb_error("The programmers are gits!\n");
X						break;
X				}
X			}
X			junk = junk->next;
X		}
X		for(j=0;j<i;j++)
X		{		
X			int dr, far, fdr;
X			XCharStruct or;
X			int tw; /* textwidth */
X
X			tx = otherx[j];
X			ty = othery[j];
X			t1 = ot1[j];
X			t2 = ot2[j];
X			t3 = ot3[j];
X			op = opic[j];
X
X			XTextExtents(temp->xf, othername[j], strlen(othername[j]),&dr,&far,&fdr,&or); 
X			tw=or.width / 2 - 1;
X			XDrawString(temp->theDisplay, temp->back_buffer, temp->bbgc, tx + OFFSET - tw, ty + OFFSET + 40, othername[j], strlen(othername[j]));
X			disp_ship(temp,op,tx,ty,t1,t2,t3,otherptr[j]);
X		}
X		if(!temp->exploding) {
X			draw_stars(temp);
X		}
X		do_stats(temp);
X
X		/*
X		*	Draw all the current laser beams on the screen
X		*/
X		for(i=0;i<no_lasers;i++)
X		{
X			XDrawLine(temp->theDisplay, temp->back_buffer, temp->bbgc,
X				lasers[i].x1-temp->sx+PLAYW/2+OFFSET,temp->sy-lasers[i].y1+PLAYH/2+OFFSET,lasers[i].x2-temp->sx+PLAYW/2+OFFSET,temp->sy-lasers[i].y2+PLAYH/2+OFFSET);
X		}
X
X		XDrawRectangle(temp->theDisplay, temp->back_buffer, temp->bbgc, 
X			-1*WORLDW-temp->sx+PLAYW/2+OFFSET, -1*WORLDH+temp->sy+PLAYH/2+OFFSET, 
X			2*WORLDW, 2*WORLDH);
X		XCopyPlane(temp->theDisplay,temp->back_buffer,temp->theWindow,temp->theGC,OFFSET,
X				  OFFSET,PLAYW,PLAYH,0,0,1);
X		if(!temp->exploding) {
X			redo_radar(temp);
X			do_radar(temp);	
X		}
XKludge:
X		temp = temp->next;
X	}
X}
X
X
Xvoid synch_all()
X{
X	winptr t;
X
X	t = first_win;
X	while(t)
X	{
X		if(!t->npc || t->npcwin)	
X			XSync(t->theDisplay,False);
X		t = t->next;
X	}
X}
END_OF_FILE
if test 5068 -ne `wc -c <'update_win.c'`; then
    echo shar: \"'update_win.c'\" unpacked with wrong size!
fi
# end of 'update_win.c'
fi
if test -f 'weapon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'weapon.c'\"
else
echo shar: Extracting \"'weapon.c'\" \(16072 characters\)
sed "s/^X//" >'weapon.c' <<'END_OF_FILE'
X/* weapon.c - *** All the weapon routines */
X 
Xstatic char sccs_id[] = "@(#)weapon.c 1.31 93/03/26 XMPB";
X
X#include "player.h"
X#include "weapon.h"
X
Xstruct laser lasers[MAXHOST];
Xint no_lasers;
X
Xextern int euid;
Xextern int mysintab[360],mycostab[360];
Xextern winptr first_win;
Xextern junkptr first_junk;
Xextern int installed;
X
Xwitemptr first_weap_item = NULL;
Xdouble line_2_linef();
X
Xadd_weapon_item(who,type,xv,yv,angle,targ,sx,sy)
Xwinptr who;
Xint type,xv,yv,angle;
Xwinptr targ;
Xint sx,sy;
X{
X	witemptr temp;
X
X	temp = (witemptr)malloc(sizeof(struct weapon_item));
X
X	temp->next = first_weap_item;
X	first_weap_item = temp;
X	temp->xv = xv;
X	temp->yv = yv;
X	temp->angle = angle;
X	temp->life = weap_maxlife[type];
X	temp->sx = sx;
X	temp->sy = sy;
X	temp->who = who;
X	temp->type = type;
X	temp->target = targ;
X}
X
Xfree_weap_item(w)
Xwitemptr w;
X{
X	witemptr t;
X
X	t = first_weap_item;
X
X	if(t == w)
X	{
X		first_weap_item = t->next;
X		free(t);
X		return;
X	}
X	if(t == NULL)
X	{
X		xmpb_error("Free from an empty weapon item list\n");
X	}
X	while(t->next != NULL && t->next != w)
X		t = t->next;
X	if(t->next == NULL)
X	{
X		xmpb_error("Free a non existing weapon item\n");
X	}
X	t->next = w->next;
X	free(w);
X}
X	
Xread_weap_pixmap(w,fn,pm)
Xwinptr w;
Xchar *fn;
XWeapon_Pixmap *pm;
X{
X    int xh,yh;
X    char *bitmapfile;
X    if(installed)
X	{
X    	bitmapfile = (char *)malloc(strlen(BITMAPDIR)+strlen(fn)+1);
X		strcpy(bitmapfile,BITMAPDIR);
X	}
X	else
X	{
X    	bitmapfile = (char *)malloc(10+strlen(fn)+1);
X		strcpy(bitmapfile, "./bitmaps/");
X	}
X    strcat(bitmapfile,fn);
X   
Xseteuid(euid); 
X    if(strcmp(fn,""))
X	XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile,&(pm->w),&(pm->h),&(pm->thepm),&xh,&yh);
X   
Xseteuid(getuid()); 
X    free(bitmapfile);
X}
X
Xread_all_weaps(w)
Xwinptr w;
X{
X	int i;
X
X	for(i=0;i<NO_WEAPONS;i++)
X	{
X		read_weap_pixmap(w,weap_file_names[i],&(w->weappms[i]));
X	}
X}
X
X#define CLOSEIN		60
X
Xfire_weapon(w)
Xwinptr w;
X{
X	int i;
X	winptr t = NULL;
X
X#define OFFSET_TO_FG  55
X
X	switch(w->curr_weap)
X	{
X		case WEAP_HEAVY_LASER:
X			w->energy_curr -= weap_energy[w->curr_weap];
X			w->load_status[w->curr_weap] = load_rate[w->curr_weap];
X			
X			lasers[no_lasers].x1 =w->sx+(CLOSEIN*mysintab[(int)w->angle])/32768;
X			lasers[no_lasers].y1 =w->sy+(CLOSEIN*mycostab[(int)w->angle])/32768;
X			lasers[no_lasers].x2 = w->sx+(14000*mysintab[(int)w->angle])/32768;
X			lasers[no_lasers].y2 = w->sy+(14000*mycostab[(int)w->angle])/32768;
X			lasers[no_lasers].dam = weap_damage[w->curr_weap];
X			lasers[no_lasers].who = w;
X			lasers[no_lasers].hit_dist = -5.0;
X			no_lasers++;
X
X			lasers[no_lasers].x1 =5*mycostab[w->angle]/32768+ w->sx+(CLOSEIN*mysintab[(int)w->angle])/32768;
X			lasers[no_lasers].y1 =5*mysintab[w->angle]/32768+ w->sy+(CLOSEIN*mycostab[(int)w->angle])/32768;
X			lasers[no_lasers].x2 = 400*mycostab[w->angle]/32768+w->sx+(14000*mysintab[(int)w->angle])/32768;
X			lasers[no_lasers].y2 = 400*mysintab[w->angle]/32768+w->sy+(14000*mycostab[(int)w->angle])/32768;
X			lasers[no_lasers].dam = weap_damage[w->curr_weap];
X			lasers[no_lasers].who = w;
X			lasers[no_lasers].hit_dist = -5.0;
X			no_lasers++;
X
X			lasers[no_lasers].x1 =-5*mycostab[w->angle]/32768+ w->sx+(CLOSEIN*mysintab[(int)w->angle])/32768;
X			lasers[no_lasers].y1 =-5*mysintab[w->angle]/32768+ w->sy+(CLOSEIN*mycostab[(int)w->angle])/32768;
X			lasers[no_lasers].x2 = -400*mycostab[w->angle]/32768+w->sx+(14000*mysintab[(int)w->angle])/32768;
X			lasers[no_lasers].y2 = -400*mysintab[w->angle]/32768+w->sy+(14000*mycostab[(int)w->angle])/32768;
X
X			lasers[no_lasers].dam = weap_damage[w->curr_weap];
X			lasers[no_lasers].who = w;
X			lasers[no_lasers].hit_dist = -5.0;
X			no_lasers++;
X
X			break;
X		case WEAP_LIGHT_LASER:
X			w->energy_curr -= weap_energy[w->curr_weap];
X			w->load_status[w->curr_weap] = load_rate[w->curr_weap];
X			lasers[no_lasers].x1 = w->sx+(CLOSEIN*mysintab[(int)w->angle])/32768;
X			lasers[no_lasers].y1 = w->sy+(CLOSEIN*mycostab[(int)w->angle])/32768;
X			lasers[no_lasers].x2 = w->sx+(14000*mysintab[(int)w->angle])/32768;
X			lasers[no_lasers].y2 = w->sy+(14000*mycostab[(int)w->angle])/32768;
X			lasers[no_lasers].dam = weap_damage[w->curr_weap];
X			lasers[no_lasers].who = w;
X			lasers[no_lasers].hit_dist = -5.0;
X			no_lasers++;
X			break;
X		case WEAP_SPRAY:
X			w->energy_curr -= weap_energy[w->curr_weap];
X			w->load_status[w->curr_weap] = load_rate[w->curr_weap];
X		for(i=0;i<5;i++)
X			add_weapon_item(w,w->curr_weap,
X                mysintab[(w->angle+(rand()%20-10)+360)%360]*weap_velocit[w->curr_weap]+w->xv,
X                mycostab[(w->angle+(rand()%20-10)+360)%360]*weap_velocit[w->curr_weap]+w->yv,
X                (int)w->angle,t,
X                w->sx+(OFFSET_TO_FG*mysintab[(int)w->angle])/32768,
X                w->sy+(OFFSET_TO_FG*mycostab[(int)w->angle])/32768);
X			break;
X		case WEAP_MAGNET:
X		case WEAP_SEEK:
X			t=w->targeting;
X			if(t == NULL)
X				break;
X		case WEAP_BLACK:
X		case WEAP_HVYPULSE:
X		case WEAP_MASS:
X		case WEAP_RAIL:
X		case WEAP_PULSE:
X		case WEAP_DUNNO:
X		case WEAP_DUNNO2:
X		case WEAP_BOMB:
X		case WEAP_MISSILE:
X			w->energy_curr -= weap_energy[w->curr_weap];
X			w->load_status[w->curr_weap] = load_rate[w->curr_weap];
X			add_weapon_item(w,w->curr_weap,
X                mysintab[(int)w->angle]*weap_velocit[w->curr_weap]+w->xv,
X                mycostab[(int)w->angle]*weap_velocit[w->curr_weap]+w->yv,
X                (int)w->angle,t,
X                w->sx+(OFFSET_TO_FG*mysintab[(int)w->angle])/32768,
X                w->sy+(OFFSET_TO_FG*mycostab[(int)w->angle])/32768);
X			break;
X		case WEAP_MINE:
X			w->energy_curr -= weap_energy[w->curr_weap];
X            w->load_status[w->curr_weap] = load_rate[w->curr_weap];
X            add_weapon_item(w,w->curr_weap,
X                mysintab[(int)w->angle]*weap_velocit[w->curr_weap]+w->xv,
X                mycostab[(int)w->angle]*weap_velocit[w->curr_weap]+w->yv,
X                (int)w->angle,t,
X                w->sx+(-OFFSET_TO_FG*mysintab[(int)w->angle])/32768,
X                w->sy+(-OFFSET_TO_FG*mycostab[(int)w->angle])/32768);
X            break;
X		default:
X			break;
X	}
X}
X
X#define abs(x) ((x) >=0?(x):-(x))
X/*
Xint check_if_bullet_hit(int x1,int y1,int x2,int y2,int *a,int *b,int *c,int *d,winptr *r)
X{
X	winptr t;
X	int sx,sy;
X	int f,g,h,j,k;
X
X	t = first_win;
X
X	while(t)
X	{
X		
X		h = x2 - x1;
X		j = y2 - y1;
X		if(abs(h) > abs(j))
X		{
X			f = 40*j / h;
X			g = 40;
X		}
X		else
X		{
X			f = 40;
X			g = 40 * h / j;
X		}
X		
X		if(line_2_line(x1,y1,x2,y2,t->sx-f,t->sy+g,t->sx+t->xv/32768+f,t->sy+t->yv/32768-g,a,b,c,d))
X		{
X			*r = t;
X			return 1;
X		}
X		t = t->next;
X	}
X	return 0;
X}
X*/
Xdo_laser_hits()
X{
X	int i;
X	witemptr w;
X	witemptr x;
X	winptr t;
X	junkptr j;
X	int a,b,c,d;
X	int cx,cy;
X	double curr_hit;
X	int hit_shield;
X
X	{
X		t = first_win;
X		while(t)
X		{
X			if(!t->exploding)
X			{
X				for(i=0;i<no_lasers;i++)
X				{
X					if(t != lasers[i].who)
X					{
X					cx = t->sx + t->xv/32768;
X					cy = t->sy + t->yv/32768;
X					{
X						double bsh,lsh,rsh;
X			
X					
X						curr_hit = -2.0;
X						hit_shield = 0;
X						rsh = line_2_linef(lasers[i].x1,lasers[i].y1,lasers[i].x2,lasers[i].y2,t->p1x,t->p1y,t->p2x,t->p2y);	
X						if(rsh > curr_hit )
X						{
X							hit_shield = RSH;
X							curr_hit = rsh;
X						}
X						lsh = line_2_linef(lasers[i].x1,lasers[i].y1,lasers[i].x2,lasers[i].y2,t->p3x,t->p3y,t->p1x,t->p1y);	
X						if(lsh > curr_hit)
X						{
X							hit_shield = LSH;
X							curr_hit = lsh;
X						}
X						bsh = line_2_linef(lasers[i].x1,lasers[i].y1,lasers[i].x2,lasers[i].y2,t->p2x,t->p2y,t->p3x,t->p3y);	
X						if(bsh > curr_hit)
X						{
X							hit_shield = BSH;
X							curr_hit = bsh;
X						}
X						if(hit_shield)
X						{
X							if(curr_hit > lasers[i].hit_dist)
X							{
X								lasers[i].hit_dist = curr_hit;	
X								lasers[i].hit_ship = t;
X								lasers[i].hit_shield = hit_shield;
X							}
X						}
X					}
X					}
X				}
X			}
X			t=t->next;
X		}
X	}
X
X	for(i=0;i<no_lasers;i++)
X	{
X		j=first_junk;
X		while(j)
X		{
X			if(j->type >= SMALLROCK && j->type <=BIGROCK)
X			{
X				int h;
X				double length_along;
X
X				h = line_2_circle(lasers[i].x1,lasers[i].y1,lasers[i].x2,lasers[i].y2,j->sx,j->sy,(j->type == SMALLROCK?5:j->type==MEDROCK?11:25));
X				length_along = -(double)(h-lasers[i].x1)/(double)(lasers[i].x2-lasers[i].x1);
X				if(h && length_along > lasers[i].hit_dist)
X				{
X					lasers[i].hit_dist = length_along;
X					lasers[i].hit_ship = NULL;
X				}
X			}	
X			j = j->next;
X		}
X	}
X				
X	for(i=0;i<no_lasers;i++)
X	{
X		if(lasers[i].hit_dist > -5.0 )
X		{
X			if(lasers[i].hit_ship)
X			{
X			double scale;
X
X				if(damage_ship(lasers[i].hit_ship,lasers[i].hit_shield,lasers[i].dam))
X				{
X					lasers[i].who->kills++;
X				}
X				/* scale earned */
X				scale = (double)(lasers[i].hit_ship->ship_value+lasers[i].hit_ship->earned)/(double)(lasers[i].who->ship_value+lasers[i].who->earned);
X				if(scale > 10)
X         	       	scale=10;
X                if(scale < 0.1)
X                    scale=0.1;
X				lasers[i].who->earned += (int)(5.0*(double)lasers[i].dam*scale);
X			}
X
X			lasers[i].x2 = (lasers[i].x2 - lasers[i].x1) * -lasers[i].hit_dist + lasers[i].x1;	
X			lasers[i].y2 = (lasers[i].y2 - lasers[i].y1) * -lasers[i].hit_dist + lasers[i].y1;	
X
X			if(lasers[i].hit_ship)
X			add_junk(CLOUD1,lasers[i].x2,lasers[i].y2,8*lasers[i].hit_ship->xv/10,8*lasers[i].hit_ship->yv/10,2);
X			else
X			add_junk(CLOUD1,lasers[i].x2,lasers[i].y2,0,0,2);
X
X		}
X	}
X}
Xupdate_weapons()
X{
X	int i;
X	witemptr w;
X	witemptr x;
X	winptr t;
X	junkptr j;
X	int a,b,c,d;
X	int cx,cy;
X	double curr_hit;
X	int hit_shield;
X
X	w = first_weap_item;
X
X	while(w)
X	{
X		t = first_win;
X		while(t)
X		{
X			if(!t->exploding)
X			{
X				int nx,ny;
X				nx = w->sx+w->xv/32768;
X				ny = w->sy+w->yv/32768;
X
X
X				if((nx < t->sx + 50) && (nx > t->sx - 50) && (ny < t->sy + 50) && (ny > t->sy - 50))
X				{
X					/* Ok the bullet approximately hit, lets check further */
X					cx = t->sx /* + t->xv/32768*/;
X					cy = t->sy /* + t->yv/32768*/;
X					{
X						int hx,hy;
X						double bsh,lsh,rsh;
X			
X						curr_hit = -2.0;
X						hit_shield = 0;
X						rsh = line_2_linef(w->sx,w->sy,nx,ny,t->p1x,t->p1y,t->p2x,t->p2y);	
X						if(rsh > curr_hit )
X						{
X							hit_shield = RSH;
X							curr_hit = rsh;
X						}
X						lsh = line_2_linef(w->sx,w->sy,nx,ny,t->p3x,t->p3y,t->p1x,t->p1y);	
X						if(lsh > curr_hit)
X						{
X							hit_shield = LSH;
X							curr_hit = lsh;
X						}
X						bsh = line_2_linef(w->sx,w->sy,nx,ny,t->p2x,t->p2y,t->p3x,t->p3y);	
X						if(bsh > curr_hit)
X						{
X							hit_shield = BSH;
X							curr_hit = bsh;
X						}
X						if(hit_shield)
X						{
X						double scale;
X
X							hx = w->sx + (int)((double)(nx - w->sx)*-curr_hit) ;
X							hy = w->sy + (int)((double)(ny - w->sy)*-curr_hit) ;
X							add_junk(CLOUD1,hx,hy,8*t->xv/10,8*t->yv/10,2);
X
X							if(damage_ship(t,hit_shield,weap_damage[w->type]))
X							{
X								if(w->who)
X								w->who->kills++;
X							}
X							if(w->who)
X							{
X								scale=(double)(t->ship_value+t->earned)/(w->who->ship_value+w->who->earned);
X								if(scale > 10)
X           				            scale=10;
X                   				if(scale < 0.1)
X                        			scale=0.1;
X								w->who->earned += (int) 5*scale*weap_damage[w->type];
X							}
X							w->life = 1;
X						}
X						else
X						{
X							double scale;
X							int width;
X							switch(w->type)
X							{
X								case WEAP_PULSE:
X									width = 5;
X									break;
X								case WEAP_BOMB:
X									width = 9;
X									break;
X								case WEAP_SEEK:
X									width = 9;
X									break;
X								case WEAP_MINE:
X									width = 8;
X									break;
X								case WEAP_MASS:
X									width = 6;
X									break;
X								case WEAP_BLACK:
X									width = 15;
X									break;
X								case WEAP_MAGNET:
X									width = 13;
X									break;
X								case WEAP_HVYPULSE:
X									width = 7;
X									break;
X								case WEAP_MISSILE:
X									width = 30;
X									break;
X								case WEAP_DUNNO:
X									width = 8;
X									break;
X								case WEAP_DUNNO2:
X									width = 6;
X									break;
X								default:
X									width = 0;
X									break;
X							}
X							if(width)
X							{
X								if(line_2_rect(t->p1x,t->p1y,t->p2x,t->p2y,w->sx,w->sy,width,width))
X								{
X									hit_shield = RSH;
X								}
X								else
X								if(line_2_rect(t->p1x,t->p1y,t->p3x,t->p3y,w->sx,w->sy,width,width))
X								{
X									hit_shield = LSH;
X								}
X								else
X								if(line_2_rect(t->p2x,t->p2y,t->p3x,t->p3y,w->sx,w->sy,width,width))
X								{
X									hit_shield = BSH;
X								}
X								if(hit_shield)
X								{
X									add_junk(CLOUD1,w->sx,w->sy,8*t->xv/10,8*t->yv/10,2);
X
X									if(damage_ship(t,hit_shield,weap_damage[w->type]))
X									{
X										if(w->who)
X										w->who->kills++;
X									}
X									if(w->who)
X									{
X										scale=(double)(t->ship_value+t->earned)/(w->who->ship_value+w->who->earned);
X										if(scale > 10)
X           				            		scale=10;
X                   						if(scale < 0.1)
X                        					scale=0.1;
X										w->who->earned += (int) 5*scale*weap_damage[w->type];
X									}
X									w->life = 1;
X								}
X							}
X						}
X					}
X				}
X			}
X			t = t->next;
X		}
X
X#define SGN(x) ((x)>0?1:-1)
X
X		if(w->type == WEAP_SEEK)
X		{
X			long sp;
X			long nx,ny;
X
X			nx = (w->sx - w->target->sx);
X			ny = (w->sy - w->target->sy);
X
X			if(nx*nx > ny*ny)
X			{
X				ny = SGN(ny)*abs(ny)*8/abs(nx);
X				nx = 8*SGN(nx);
X			}
X			else
X			{
X				nx = SGN(nx)*abs(nx)*8/abs(ny);
X				ny = 8*SGN(ny);
X			}
X			sp = (w->xv/32768-nx)*(w->xv/32768-nx) + (w->yv/32768-ny)*(w->yv/32768-ny);
X			
X			if(sp < 4500)
X			{
X				w->xv -= nx*32768;
X				w->yv -= ny*32768; 
X			}
X		}
X
X		if(w->type == WEAP_MAGNET)
X		{
X			long x,y;
X			long nx,ny;
X
X			nx = (long) (w->sx - w->target->sx);
X			ny = (long) (w->sy - w->target->sy);
X			
X			if(nx*nx > ny*ny)
X			{
X				x = -SGN(nx)*weap_velocit[WEAP_MAGNET];
X				if(nx>0) y = ny*x/nx;
X				else y=(long)0;
X			}
X			else
X			{
X				y = -SGN(ny)*weap_velocit[WEAP_MAGNET];
X				if(ny>0) x = nx*y/ny;
X				else x=(long)0;
X			}
X			w->xv = w->xv/20+(int) x*32768;
X			w->yv = w->yv/20+(int) y*32768;
X		}
X			
X	
X		j = first_junk;
X		while(j)
X		{
X			if((w->sx < j->sx + 50) && (w->sx > j->sx - 50) && (w->sy < j->sy + 50) && (w->sy > j->sy - 50))
X			{
X			if(j->type >= SMALLROCK && j->type <= BIGROCK)
X			{
X				int r,h;
X				
X				switch(j->type)
X				{
X					case SMALLROCK:
X						r = 5;
X						break; 	
X					case MEDROCK:
X						r = 11;
X						break; 	
X					case BIGROCK:
X						r = 25;
X						break; 	
X				}
X				if(h=line_2_circle(w->sx,w->sy,w->sx+w->xv/32768,w->sy+w->yv/32768,j->sx,j->sy,r))
X				{
X					w->life = 1;
X					if(w->sx == w->sx+w->xv/32768)
X						add_junk(CLOUD1,h,j->sy,8*j->xv/10,8*j->yv/10,2);
X					else
X						add_junk(CLOUD1,h,w->sy+(h-w->sx)*(w->sy+w->yv/32768-w->sy)/(w->sx+w->xv/32768-w->sx),8*j->xv/10,8*j->yv/10,2);
X					
X				}
X			}
X			}
X			j = j->next;
X		}
X		w->sx += w->xv/32768;
X       	w->sy += w->yv/32768;
X		w->life--;
X		w = w->next;
X	}
X	w = first_weap_item;
X	while(w)
X	{
X		if(w->life <= 0) 
X		{
X			x = w->next;
X			free_weap_item(w);
X			w = x;
X		}
X		else
X			w = w->next;
X	}
X}
X
Xint missile_lines[9][2][2] =
X{
X	{{-3,13},{-3,-17}},
X	{{3,13},{3,-17}},
X	{{-3,13},{0,16}},
X	{{0,16},{3,13}},
X	{{-3,-6},{-7,-15}},
X	{{-7,-15},{7,-15}},
X	{{7,-15},{3,-6}},
X	{{-3,-17},{0,-22}},
X	{{0,-22},{3,-17}}
X};
Xdisp_all_items(w)
Xwinptr w;
X{
X	int i,x1,x2,y1,y2;
X	witemptr t;
X
X	t = first_weap_item;
X
X	while(t)
X	{
X		switch(t->type)
X		{
X			case WEAP_BLACK:
X				break;
X			case WEAP_MISSILE:
X				for(i=0;i<9;i++)
X				{
X					rotate_pt(missile_lines[i][0][0],missile_lines[i][0][1],(t->angle+180)%360,&x1,&y1);
X					rotate_pt(missile_lines[i][1][0],missile_lines[i][1][1],(t->angle+180)%360,&x2,&y2);
X					x1 = x1/2;
X					x2 = x2/2;
X					y1 = y1/2;
X					y2 = y2/2;
X					XDrawLine(w->theDisplay,w->back_buffer,w->bmgc,
X						PLAYW/2 - w->sx+t->sx+OFFSET + x1,
X						PLAYH/2 - t->sy + w->sy+OFFSET+y1,
X						PLAYW/2 - w->sx+t->sx+OFFSET+x2,
X						PLAYH/2 - t->sy + w->sy+OFFSET+y2);
X				}
X				break;	
X			default:
X				XCopyPlane(w->theDisplay,w->weappms[t->type].thepm,
X					w->back_buffer,w->bbgc,0,0,w->weappms[t->type].w,
X					w->weappms[t->type].h,PLAYW/2 - w->sx+t->sx+OFFSET,
X					PLAYH/2 - t->sy + w->sy+OFFSET,1);
X				break;
X		}
X		t = t->next;
X	}
X}
END_OF_FILE
if test 16072 -ne `wc -c <'weapon.c'`; then
    echo shar: \"'weapon.c'\" unpacked with wrong size!
fi
# end of 'weapon.c'
fi
echo shar: End of archive 3 \(of 8\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
