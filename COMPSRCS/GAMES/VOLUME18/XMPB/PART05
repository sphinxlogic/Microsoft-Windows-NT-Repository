Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i005:  xmpb - multiplayer space combat for X, Part05/08
Date: 26 Jun 1993 00:32:50 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2152
Approved: billr@saab.CNA.TEK.COM
Message-ID: <20g5fi$6so@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1795

Submitted-by: ddp@deakin.edu.au (Damien De Paoli)
Posting-number: Volume 18, Issue 5
Archive-name: xmpb/Part05
Environment: X11, Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 8)."
# Contents:  Makefile.std junk.c npcc.man player.h shop_ui.c stats.c
#   util.c xoutput.c
# Wrapped by billr@saab on Fri Jun 25 16:30:15 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile.std' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.std'\"
else
echo shar: Extracting \"'Makefile.std'\" \(8156 characters\)
sed "s/^X//" >'Makefile.std' <<'END_OF_FILE'
X.c.o:
X	$(CC) -c $(CFLAGS) $*.c
X
X          INSTALL = install
X               RM = rm -f
X     INSTPGMFLAGS = -s -m 0755 -o bin -g bin
X
X     INSTBINFLAGS = -s -m 0755 -o bin -g bin
X     INSTUIDFLAGS = -m 4755 -o root -g bin
X     INSTLIBFLAGS = -m 0644 -o lib -g lib
X     INSTINCFLAGS = -m 0644 -o inc -g inc
X     INSTMANFLAGS = -m 0644 -o man -g man
X     INSTDATFLAGS = -m 0644 -o lib -g lib
X    INSTKMEMFLAGS = -m 2755 -o bin -g kmem
X
X      PROJECTROOT = /usr/X11R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X        USRLIBDIR = /usr/X11R5/lib
X          INCROOT = /usr/X11R5/include
X           INCDIR = $(INCROOT)/X11
X           LIBDIR = $(USRLIBDIR)/X11
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X#
X# Change these to change the installation targets
X#
X
XBLASTDIR = /home/ddp/blast
X
XNPCDIR = $(BLASTDIR)/npc
XBINDIR = $(BLASTDIR)/bin
XSAVEDIR = $(BLASTDIR)/save
XBITMAPDIR = $(BLASTDIR)/bitmaps
X
XMANSUFFIX = 6
XMANDIR = $(BLASTDIR)/man/man$(MANSUFFIX)
X
XEXTRA_LOAD_FLAGS =
XINSTALLMODS = 4755
XYACC = yacc
XLEX = lex
X
XINSTPGMFLAGS = -m $(INSTALLMODS) -o bin -g bin
X
X# If you have a NCD or HP, then remove the # on the next line
X# NCDFLAG = -DNCD
X
X# Adjust if default is unsuitable
XCC = cc
X# Adjust for debugging or optimization relative to the default
XCDEBUGFLAGS = -DBITMAPDIR="\"$(BITMAPDIR)/\"" -DSAVEDIR="\"$(SAVEDIR)/\"" -DNPCDIR="\"$(NPCDIR)/\"" $(NCDFLAG) -O2
X
X# Adjust if necessary
XMATHLIB = -lm
XMKDIRHIER = /usr/X11/bin/mkdirhier
X
X###############################
X# Nothing to change below here
X
XSRCS = xoutput.c read_ship.c test.c disp_ship.c handle_ev.c add_host.c \
X	update_win.c thrust.c ud_win.c do_stars.c radar.c stats.c weapon.c \
X	error.c polygon.c damage_ship.c update_ships.c junk.c input.c \
X	sintab.c costab.c calc_shields.c pcomp.c collide.c
XOBJS = xoutput.o read_ship.o test.o disp_ship.o handle_ev.o add_host.o \
X	update_win.o thrust.o ud_win.o do_stars.o radar.o stats.o weapon.o \
X	error.o polygon.o damage_ship.o update_ships.o junk.o input.o \
X	sintab.o costab.o calc_shields.o pcomp.o collide.o
X
XBMAPS = bitmaps/bigrock bitmaps/bomb bitmaps/cloud.1 bitmaps/cloud.2 \
X	bitmaps/cloud.3 bitmaps/cloud.4 bitmaps/cloud.5 bitmaps/cloud.6 \
X	bitmaps/debris.1 bitmaps/debris.2 bitmaps/debris.3 bitmaps/massdrive \
X	bitmaps/medrock bitmaps/mine bitmaps/pulse bitmaps/rail \
X	bitmaps/saturn1 bitmaps/seeker bitmaps/shortdeaddude bitmaps/smallrock \
X	bitmaps/star1 bitmaps/star2 bitmaps/stipple bitmaps/atom bitmaps/hvypulse \
X	bitmaps/magneto bitmaps/dunno bitmaps/dunno2
X
XNPCS = ml ml2  beam harry basic average nasty john rad1 rad2 rad3
X
XLOCAL_LIBRARIES = $(XLIB) $(MATHLIB)
X
Xall:: xmpb shop npcc retire describe clear_lock
X
X PROGRAM = xmpb
X
Xall:: xmpb
X
Xxmpb: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xsaber_xmpb:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xosaber_xmpb:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xinstall:: xmpb
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  xmpb $(DESTDIR)$(BINDIR)
X
Xinstall.man:: xmpb.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) xmpb.man $(DESTDIR)$(MANDIR)/xmpb.$(MANSUFFIX)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
Xretire: retire.o save_load.o
X	$(RM) $@
X	$(CC) -o $@ retire.o save_load.o $(LDOPTIONS)  $(LDLIBS)  $(EXTRA_LOAD_FLAGS)
X
Xclean::
X	$(RM) retire
X
Xdescribe: describe.o save_load.o
X	$(RM) $@
X	$(CC) -o $@ describe.o save_load.o $(LDOPTIONS)  $(LDLIBS)  $(EXTRA_LOAD_FLAGS)
X
Xclean::
X	$(RM) describe
X
Xnpcc: lex.yy.o y.tab.o
X	$(RM) $@
X	$(CC) -o $@ lex.yy.o y.tab.o $(LDOPTIONS)  $(LDLIBS) -ll $(EXTRA_LOAD_FLAGS)
X
Xclean::
X	$(RM) npcc
X
Xclear_lock: clear_lock.c save_load.o
X	$(RM) $@
X	$(CC) -o $@ clear_lock.c save_load.o $(LDOPTIONS)  $(LDLIBS)  $(EXTRA_LOAD_FLAGS)
X
Xclean::
X	$(RM) clear_lock
X
Xshop: shop_ui.o shop_stubs.o save_load.o
X	$(RM) $@
X	$(CC) -o $@ shop_ui.o shop_stubs.o save_load.o $(LDOPTIONS) -L$(OPENWINHOME)/lib $(LDLIBS) -lxview -lolgx -lX11 $(EXTRA_LOAD_FLAGS)
X
Xclean::
X	$(RM) shop
X
Xinstall:: shop
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  shop $(DESTDIR)$(BINDIR)
X
Xinstall:: retire
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  retire $(DESTDIR)$(BINDIR)
X
Xinstall:: describe
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  describe $(DESTDIR)$(BINDIR)
X
Xinstall:: npcc
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  npcc $(DESTDIR)$(BINDIR)
X
Xinstall.man:: retire.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) retire.man $(DESTDIR)$(MANDIR)/retire.$(MANSUFFIX)
X
Xinstall.man:: describe.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) describe.man $(DESTDIR)$(MANDIR)/describe.$(MANSUFFIX)
X
Xinstall.man:: shop.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) shop.man $(DESTDIR)$(MANDIR)/shop.$(MANSUFFIX)
X
Xinstall.man:: npcc.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) npcc.man $(DESTDIR)$(MANDIR)/npcc.$(MANSUFFIX)
X
Xinstall::
X	@case '${MFLAGS}' in *[i]*) set +e;; esac;
X	@for i in $(SAVEDIR) $(NPCDIR); do if [ -d $(DESTDIR)$$i ]; then \
X	set +x; else (set -x; $(MKDIRHIER) $(DESTDIR)$$i); fi \
X	done
X
Xinstall:: $(BMAPS)
X	@if [ -d $(DESTDIR)$(BITMAPDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BITMAPDIR)); fi
X	@case '${MFLAGS}' in *[i]*) set +e;; esac; \
X	for i in $(BMAPS); do \
X	(set -x; $(INSTALL) -c -m 0644 $$i $(DESTDIR)$(BITMAPDIR)); \
X	done
X#
X#
X#	Rules for stuff imake doesn't know
X#
X
Xlex.yy.o: lex.yy.c y.tab.c
Xlex.yy.c: lex.l
X	$(LEX) lex.l
Xy.tab.c: parse.y
X	$(YACC) -d parse.y
Xclean::
X	$(RM) lex.yy.c y.tab.c y.tab.h
X
Xnpcs::
X	npcc $(NPCS)
X
Xinstall:: install.man
X	cp shop.contents $(BITMAPDIR)
X	chmod 644 $(BITMAPDIR)/shop.contents
X	chmod 755 $(BLASTDIR)
X	chmod 755 $(BINDIR)
X	chmod 755 $(MANDIR)
X	chmod 755 $(MANDIR)/..
X	chmod 755 $(SAVEDIR)
X	chmod 755 $(NPCDIR)
X	chmod 700 $(BITMAPDIR)
X
Xinstall::
X	npcc $(NPCS)
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	# load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	# load $(ALLDEFINES) $(OBJS)
X
X# -------------------------------------------------------------------------
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
if test 8156 -ne `wc -c <'Makefile.std'`; then
    echo shar: \"'Makefile.std'\" unpacked with wrong size!
fi
# end of 'Makefile.std'
fi
if test -f 'junk.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'junk.c'\"
else
echo shar: Extracting \"'junk.c'\" \(4829 characters\)
sed "s/^X//" >'junk.c' <<'END_OF_FILE'
X/* junk.c - *** handle junk items */
X
Xstatic char sccs_id[] = "@(#)junk.c 1.10 93/03/26 ";
X
X#include "player.h"
X
Xextern int euid;
Xextern winptr first_win;
Xextern int installed;
Xjunkptr first_junk = NULL;
X
X#define ABS(x)	((x)<0?-(x):(x))
X
Xadd_junk(type,x,y,xv,yv,pic)
Xint type,x,y,xv,yv,pic;
X{
X	junkptr j;
X
X	j = (junkptr) malloc(sizeof(struct junk_item));
X
X	if(!j)
X		xmpb_error("Unable to alloc room for junk item\n");
X
X	j->type = type;
X	j->sx = x;
X	j->sy = y;
X	j->xv = xv;
X	j->yv = yv;
X	j->pic = pic;
X
X	j->next = first_junk;
X	first_junk = j;
X}
X
Xfree_junk(j)
Xjunkptr j;
X{
X	junkptr i;
X
X	i = first_junk;
X	if(i==j)
X	{
X		first_junk = j->next;
X		free(j);
X	}
X	else	
X	{
X		while(i->next)
X		{
X			if(j==i->next)
X			{
X				i->next = j->next;
X				free(j);
X				return;
X			}
X			i = i->next;
X		}
X		xmpb_error("Tried to free no-existent junk item\n");
X	}
X}
X
Xload_junkmaps(w)
Xwinptr w;
X{
X	int xh,yh;
X	int r;
X	char *bitmapfile;
X	char *bitmapfilestartptr;
X
X	/* Allocate a string to hold the bitmapfile's directory
X	   and the filename. "shortdeaddude" is the longest. */
X	if(installed)
X	{
X		bitmapfile = (char *) malloc(strlen(BITMAPDIR)+strlen("shortdeaddude")+1);
X		strcpy(bitmapfile,BITMAPDIR);
X	}
X	else
X	{
X		bitmapfile = (char *) malloc(10+strlen("shortdeaddude")+1);
X		strcpy(bitmapfile,"./bitmaps/");
X	}
X
X	/* Set a pointer to point into the start of the string where
X	   the filename will be added. Each time the filename will
X	   be overwritten with a new one. */
X	if(installed)
X		bitmapfilestartptr = bitmapfile + strlen(BITMAPDIR);
X	else
X		bitmapfilestartptr = bitmapfile + 10;
X
Xseteuid(euid);
X	strcpy(bitmapfilestartptr,"shortdeaddude");
X	r = XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile, &(w->j_w[DEADDUDE]), &(w->j_h[DEADDUDE]),&(w->junk_pm[DEADDUDE]),&xh,&yh);
X	
X	strcpy(bitmapfilestartptr,"bigrock");
X	r = XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile, &(w->j_w[BIGROCK]), &(w->j_h[BIGROCK]),&(w->junk_pm[BIGROCK]),&xh,&yh);
X
X	strcpy(bitmapfilestartptr,"medrock");
X	r = XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile, &(w->j_w[MEDROCK]), &(w->j_h[MEDROCK]),&(w->junk_pm[MEDROCK]),&xh,&yh);
X
X	strcpy(bitmapfilestartptr,"smallrock");
X	r = XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile, &(w->j_w[SMALLROCK]), &(w->j_h[SMALLROCK]),&(w->junk_pm[SMALLROCK]),&xh,&yh);
X
X	strcpy(bitmapfilestartptr,"cloud.1");
X	r = XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile, &(w->j_w[CLOUD1]), &(w->j_h[CLOUD1]),&(w->junk_pm[CLOUD1]),&xh,&yh);
X
X	strcpy(bitmapfilestartptr,"cloud.2");
X	r = XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile, &(w->j_w[CLOUD2]), &(w->j_h[CLOUD2]),&(w->junk_pm[CLOUD2]),&xh,&yh);
X
X	strcpy(bitmapfilestartptr,"cloud.3");
X	r = XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile, &(w->j_w[CLOUD3]), &(w->j_h[CLOUD3]),&(w->junk_pm[CLOUD3]),&xh,&yh);
X
X	strcpy(bitmapfilestartptr,"cloud.4");
X	r = XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile, &(w->j_w[CLOUD4]), &(w->j_h[CLOUD4]),&(w->junk_pm[CLOUD4]),&xh,&yh);
X
X	strcpy(bitmapfilestartptr,"cloud.5");
X	r = XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile, &(w->j_w[CLOUD5]), &(w->j_h[CLOUD5]),&(w->junk_pm[CLOUD5]),&xh,&yh);
X
X	strcpy(bitmapfilestartptr,"cloud.6");
X	r = XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile, &(w->j_w[CLOUD6]), &(w->j_h[CLOUD6]),&(w->junk_pm[CLOUD6]),&xh,&yh);
X
X	strcpy(bitmapfilestartptr,"debris.1");
X	r = XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile, &(w->j_w[DEBRIS1]), &(w->j_h[DEBRIS1]),&(w->junk_pm[DEBRIS1]),&xh,&yh);
X
X	strcpy(bitmapfilestartptr,"debris.2");
X	r = XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile, &(w->j_w[DEBRIS2]), &(w->j_h[DEBRIS2]),&(w->junk_pm[DEBRIS2]),&xh,&yh);
X
X	strcpy(bitmapfilestartptr,"debris.3");
X	r = XReadBitmapFile(w->theDisplay,w->theWindow,bitmapfile, &(w->j_w[DEBRIS3]), &(w->j_h[DEBRIS3]),&(w->junk_pm[DEBRIS3]),&xh,&yh);
X
X	free(bitmapfile);
Xseteuid(getuid());
X}
X
Xupdate_junk()
X{
X	junkptr j,k;
X
X	j = first_junk;
X	while(j)
X	{
X		if(j->sx + j->xv/32000 < -WORLDW+50 || j->sx + j->xv/32000 > WORLDW-50)
X		{
X			j->xv = - j->xv;
X		}
X		if(j->sy + j->yv/32000 < -WORLDH+50 || j->sy + j->yv/32000 > WORLDH-50)
X		{
X			j->yv = - j->yv;
X		}
X		k = j->next;
X
X/*
X	if(j->type < CLOUD1 || j->type > DEBRIS3)
X		while(k)
X		{	
X			int q;
X			if(ABS(j->sx - k->sx) < (first_win->j_w[j->type]+first_win->j_w[k->type])/2
X				&& (ABS(j->sy - k->sy) < (first_win->j_h[j->type]+first_win->j_h[k->type] )/2))
X			{
X				q = j->xv;
X				j->xv = k->xv;
X				k->xv = q;
X				q = j->yv;
X				j->yv = k->yv;
X				k->yv = q;
X			}	
X			k=k->next;
X		}
X*/
X		j->sx += j->xv/32000;
X		j->sy += j->yv/32000;
X		if(j->type >= CLOUD1 && j->type <= CLOUD6)
X		{
X			j->pic--;
X			if(!j->pic)
X			{
X				j->type++;
X				j->pic = 2;
X			}
X			if(j->type == CLOUD6+1)
X			{
X				junkptr z;
X				z = j->next;
X				free_junk(j);
X				j = z;
X			}
X			else
X				j = j->next;
X		}
X		else
X			j = j->next;
X	}
X}
END_OF_FILE
if test 4829 -ne `wc -c <'junk.c'`; then
    echo shar: \"'junk.c'\" unpacked with wrong size!
fi
# end of 'junk.c'
fi
if test -f 'npcc.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'npcc.man'\"
else
echo shar: Extracting \"'npcc.man'\" \(7457 characters\)
sed "s/^X//" >'npcc.man' <<'END_OF_FILE'
X.TH Xmpb
X.SH NAME
Xnpcc - NPC Compiler for Xmpb
X.SH SYPNOSIS
X.ta 4n
X\fInpcc\fR Name
X
X.SH DESCRIPTION
X
XWriting your own NPC's with npcc.
X
X
X	At the moment this is the only man page that is not even close to complete.  :^(  If you look in the section titled "The language", you need all the stuff from NPC to Jammer, Weapons and then any weapons you want.  Following this you need var (and end) with any global vars you need.  Then you can you used procedures and states.
X	States are defined like this:
X
X.nf
X    State blah
X    {
X        var 
X           local
X           vars
X           are 
X           optional
X        end
X    Entry  /* also optional, will be execute only once
X    {      ** when the state is entered */
X        /* Entry code */
X    }
X
X         /* code that will continually be executed in this state */    
X    }
X
X
X    Procedures are defined as follows:
X
X    Procedure whatever
X    {
X        var
X            locals /* again optional */
X        end
X	
X    /* procedure code */
X    return 1;  /* you must have a return.  It may or may not 
X               ** return any value you wish */
X    }
X
X    To call a procedure is just like in 'C' e.g.  whatever();
X    To jump to a state use:   (condition==1) -> blah;
X.fi
X
X	All other code is very 'C' like.  A good rule is if it gives you a syntax error (and it is 'C' like, then we didn't implement it.) 
X
X	My only other help for this is to look at the NPCs supplied.  Hopefully these will help you work out how to code an NPC.
X
X	Good luck :^)
X
X.SH 
XThe language.
X
X.SH 
XKeywords:
X
X.nf
XNPC          Specify that this is an NPC file.  Must be the first line.
XName         The Name of your NPC (e.g. Name = Idiot)
XShip         The name of your ship (e.g. Ship = Boxhead)
XEnergyMax    The maximum amount of energy your NPC's ship has
XLShieldMax   The max Left Shield  (e.g. LShield = 600)
XRShieldMax   The max Right Shield
XBShieldMax   The max Bottom Shield
XSolar        The quality of your Solar Panels  (e.g. Solar = 3)
XShortRange   The quality of your Short Range Radar
XEngine       The quality of your Engine
XLongRange    The quality of your Long Range Radar
XRepair       The quality of your Repair System
XTC           The quality of your Targeting Computer
XJammer       The quality of your Jamming Device
Xnone         If you don't want your NPC to have an item, then use none.
X             e.g. TC = none
X
XWeapons      Tells the compiler that that the weapon section follows
XPulse        Pulse Rifle
XBomb         Energy Bomb
XSeek         Seeker (T)
XLLaser       Light Laser
XRail         Rail Gun
XMass         Mass Driver
XMine         Mine
XAtom         Atomic Spray
XHLaser       Heavy Laser
XHPulse       Heavy Pulse
XMagneto      Magneto Disc
XBDeath       Black Death
X
Xvar          Tells the compiler that variables follow. Variables are all 
X             integers.  There are global variables (after weapons) and 
X             local vars (after State/Proc - described below)
XState        Tells the compiler that a State declaration follows
XEntry        Entry code that is executed once only when a state is entered
XStart        Says which state the NPC should start at
XProc         Used to define a procedure. 
XIdle         Idle is used when checking what item is being repaired.  If 
X             your repair system is idle, then it will return Idle
Xreturn       used to return from a procedure, can be used to return values 
X             like in C.  e.g. return 0;
X.fi
X
X
X.SH 
XInput Ports.
X
XInput ports allow you to determine things about the state of your npc and 
Xits environment. Input ports are use by simply calling the port and storing,
Xor comparing the value:
X
X.nf
X	e.g. num = NumEnemies;
X     	if (XPos > 0)  ...
X.fi
X
XThe full list of the input ports and what they do:
X
X.nf
XLShield    	    The current status of your Left Shield
XRShield    	    The current status of your Right Shield
XBShield    	    The current status of your Bottom Shield
XRadarMode  	 	The current mode of your radar (long or short)
XXPos            The X Position of your ship
XYPos           	The Y Position of your ship
XXVel            The X Velocity of your ship	
XYVel            The Y Velocity of your ship
XNumEnemies      The number of enemies left in the game
XAngle           The Angle you are facing
XSpeed           Your current Speed
XEnemySpeed      The Speed of the current selected Enemy
XEnemyDirection  The Bearing of the current selected Enemy
XEnemyAngle      The Angle to the current selected Enemy
XTargetState     The current state of your Targeting Computer
XSolarState      The current state of your Solar Panels
XJamState        The current state of your Jamming Device
XShortState      The current state of your Short Range Radar
XLongState       The current state of your Long Range Radar
XEngineState     The current state of your Engine State
XRepairState     The current state of your Repair System
XCurrWeap        The current weapon that is selcted
XEnemyDist       The distance to the currently selected enemy
XEnergy          The current status of your Energy banks
XEnemyAvail      If your current Enemy is available (ie. is still alive)
XDirection       The current Direction of your travel
XDistTo(x,y)     The Distance to a point (x,y)
XAngleTo(x,y)    The Angle to a point (x,y)
XEnemyXPos       The X Position of your Enemy
XEnemyYPos       The Y Position of your Enemy
XEnemyXVel       The X Velocity of your Enemy
XEnemyYVel       The X Velocity of your Enemy
XRepairItem      The current Item being Repaired
XVelAtAngle      The velocity of your ship in the current direction you 
X                are pointing
XCurrWeapState   The state of the curr weap.  0 destroyed, 1 Okay.
X.fi
X
X
X.SH 
XOutput Ports.
X
XOutput ports allow you to set things on your npc. They are used by
Xsetting the appropriate port to the correct integer.
X
X.nf	
X	e.g. set TurnTo = 90; /* turn to 90 degrees */ 
X         set B1 =1;       /* turn on button 1 (or fire weapon) */
X	     set B1 =0;       /* turn off button 1 (or stop firing weapon) */
X.fi
X
XThe full list of the output ports and what they do:
X
X.nf
XB1                  Turn button 1 on (off) - fire weapon
XB2                  Turn button 2 on (off) - change current weapon
XB3                  Turn button 3 on (off) - turn thruseters on
XBalance             Balances your shields
XRadarChange         Change radar to short (or long) range
XSelectEnemy         Select the current enemy to watch. There are up to 
X                    (NumEnemies-1) enemies. 0 is the closest, 
X                    (NumEnemies-1) is the farthest away
XJamming             Turn on/off Jamming
XGrab                Grab energy from your shields and put it into
XShieldRegen         Turn on/off your shield regenerating
XTurnLeft            Turn to the left     / Probably better to use
XTurnRight           Turn to the right	 \ TurnTo.
XTurnTo              Set the angle to turn to (0-360 absolute angle)
XTarget              Targeting computer to the selected enemy
XRepairToggle        Toggle which item to repair
XRepairSelectedItem  Repair a selected item, 
X                    e.g. set RepairSelectedItem = Solar;
XQuit                Quits (handy when you have a dead weapon, or no radars)
X                    But of course 1/3 of your cash will go to the other npcs.
X.fi
X
X.SH
XBUGS AND LIMITATIONS
X
XOnly able to have 100 states/procs
XOnly able to have 100 variables
XOnly able to have 5000 lines of assembly
X
XBut all of these are configurable in the source code
X
X.SH SEE ALSO
Xxmpb(6),npcc(6),shop(6),describe(6)
END_OF_FILE
if test 7457 -ne `wc -c <'npcc.man'`; then
    echo shar: \"'npcc.man'\" unpacked with wrong size!
fi
# end of 'npcc.man'
fi
if test -f 'player.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'player.h'\"
else
echo shar: Extracting \"'player.h'\" \(5160 characters\)
sed "s/^X//" >'player.h' <<'END_OF_FILE'
X/* player.h - *** Main structure for the game */
X
X/*   @(#)player.h 1.33 92/11/24 XMPB  */
X
X#ifndef PLAYER_H
X#define PLAYER_H
X
X#include <stdio.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/cursorfont.h>
X
X#define PLAYW 650
X#define PLAYH 650
X#define WORLDH 5000
X#define WORLDW 5000
X#define STARSPERPLANE 10
X#define MAXHOST 30
X#define OFFSET 20
X#define REPAIR_RATE 5.0
X#define THRUST_E_USE 7
X
X#define EVENTMASK ButtonPressMask|ButtonReleaseMask|ExposureMask|KeyPressMask|KeyReleaseMask|EnterWindowMask|LeaveWindowMask|DestroyNotify
X
X#define RSH	1
X#define LSH 2
X#define BSH 3
X
X#define NUM_ITEMS 7
X
X#define SOLAR   0
X#define SHORTRR 1
X#define ENGINE  2
X#define REPAIR  3
X#define LONGRR  4
X#define CLOAK   5
X#define TC      6
X#define IDLE    7
X
X#define SMALLROCK	0
X#define MEDROCK		1
X#define BIGROCK		2
X#define DEADDUDE	3
X#define CLOUD1		4
X#define	CLOUD2		5
X#define CLOUD3		6
X#define CLOUD4		7
X#define CLOUD5		8
X#define CLOUD6		9
X#define DEBRIS1		10
X#define DEBRIS2		11
X#define DEBRIS3		12
X#define NO_JUNK_ITEMS 13
X
X#define RADSIZE 200
X
X#define MAX_NAME_SIZE 25
Xstruct subwin
X{
X
X        Display         *theDisplay;
X        Window          theWindow;
X        int             theScreen;
X        int             thedepth;
X        Cursor          theCursor;
X        GC              theGC;
X        unsigned long   theBlackPixel;
X        unsigned long   theWhitePixel;
X
X};
X
Xtypedef struct subwin *subwinptr;
X
Xstruct ship_pic {
X    int w,h;
X    Pixmap pm;
X    int xo,yo;
X};
Xstruct sPm
X{
X	Pixmap spm;
X	int h,w;
X};
Xstruct stars 
X{
X	struct sPm *pm;
X	int x,y;
X	int lx,ly;
X};
X
Xstruct keys {
X        KeySym turnLeft, turnRight;
X        KeySym toggleRadar, toggleShieldsRegen, toggleWeaponStatus;
X        KeySym changeRepair, changeTarget, changeView;
X        KeySym invisibility, quit, grabEnergy, balanceShields;
X		KeySym fire, changeWeapon, thrust;
X};
X
X#define WEAP_PULSE 0
X#define WEAP_BOMB  1
X#define WEAP_SEEK  2
X#define WEAP_LIGHT_LASER 3
X#define WEAP_RAIL 4
X#define WEAP_MASS 5
X#define WEAP_MINE 6
X#define WEAP_HEAVY_LASER 7
X#define WEAP_SPRAY 8
X#define WEAP_MAGNET 9
X#define WEAP_HVYPULSE 10
X#define WEAP_BLACK 11
X#define WEAP_DUNNO 12
X#define WEAP_DUNNO2 13
X#define WEAP_MISSILE 14
X#define NO_WEAPONS 15
X
X
Xstruct Weapon_Pixmap
X{
X	Pixmap thepm;
X	int w,h;
X};
X
Xtypedef struct Weapon_Pixmap Weapon_Pixmap;
X
X
X
Xstruct player
X{
X		int npc;
X		int npcwin;
X        Display         *theDisplay;
X        Window          theWindow;
X        int             theScreen;
X        int             thedepth;
X        Cursor          theCursor;
X        GC              theGC;
X        unsigned long   theBlackPixel;
X        unsigned long   theWhitePixel;
X		
X		Pixmap back_buffer;
X		GC bbgc,bbcleargc,bmgc,fillgc;
X		GC jam25, jam50, jam75, jam100;
X		GC blgc,aGC;
X	   	XFontStruct	*xf; 
X
X		struct comp *comp;
X
X        struct player *next;
X        struct player *prev;
X		struct player *targeting;
X		struct keys prefs;
X        int x,y,w,h;
X        int minw,maxw,minh,maxh;
X		int b1,b2,b3,px,py;
X		int tl,tr;
X		int exploding, quitting;
X		struct player * watching;
X		int kills;
X		int last_kills;
X
X		subwinptr radar;
X		subwinptr stats;
X		int short_range_radar;
X		int angle_changed;
X		long int xv,yv;
X		int sx,sy,lx,ly;
X		int thrust_power;
X		/*float angle,max_angle_v;	*/
X		int angle, angle_v,max_angle_v;
X		int max_accel;
X		int dela;
X		int pic,last_pic;
X		char Name[MAX_NAME_SIZE],Ship[MAX_NAME_SIZE];
X        char *title;
X        char pass2[MAX_NAME_SIZE];
X		char password[10];
X		int hp_max, hp_curr;
X		int ls_curr, ls_max, rs_curr, rs_max, bs_curr, bs_max;
X		int shield_cnt;
X		int lls,lrs,lbs,le;
X		int energy_curr, energy_max;
X		int credits, earned;   /* cash on hand and what earned */
X		int rep_which;
X		float rep_count;
X		int shield_regen;
X		int star;  /* state of the star when time is less than 1 min */
X		int damaged;
X
X		char name[NUM_ITEMS+1][20];
X		int quality[NUM_ITEMS+1];
X		int state[NUM_ITEMS+1];
X		int prob[NUM_ITEMS+1];
X	
X		struct ship_pic sp[24];
X		struct ship_pic lt[24];
X		struct ship_pic mt[24];
X		struct ship_pic rt[24];
X		struct sPm spm[5];
X		struct stars stars1[STARSPERPLANE],stars2[STARSPERPLANE];
X		char t1,t2,t3;  /* are the thrusters on */
X		char lt1,lt2,lt3; /* were the thrusters on last frame */
X
X		int curr_weap;
X		int does_have_weap[NO_WEAPONS];
X		int load_status[NO_WEAPONS];
X		int weap_on_status[NO_WEAPONS];
X		int ship_value;
X		int changed_last_frame;
X		char cloaking;
X
X		Weapon_Pixmap weappms[NO_WEAPONS];
X
X		Pixmap junk_pm[NO_JUNK_ITEMS];		
X		int j_w[NO_JUNK_ITEMS];
X		int j_h[NO_JUNK_ITEMS];
X
X		/*
X		*	The points for pre-calcing shield positions
X		*/
X		int p1x,p1y;
X		int p2x,p2y;
X		int p3x,p3y;
X};
X
Xtypedef struct player *winptr;
X
Xstruct laser
X{
X    int x1,y1,x2,y2,dam;
X	winptr who;
X	winptr hit_ship;
X	double hit_dist;
X	int hit_shield;
X};
X
Xstruct weapon_item
X{
X	winptr who;
X	winptr target;
X	int type;
X	int xv,yv;
X	int life,maxlife;
X	int angle;
X	int sx,sy;
X	struct weapon_item *next;
X};
X
Xstruct junk_item
X{
X	int type;
X	int pic;
X	int sx,sy;
X	int xv,yv;
X	struct junk_item *next;
X};
X
X
Xtypedef struct weapon_item *witemptr;
Xtypedef struct junk_item *junkptr;
X
Xwinptr xfe_open_window();
Xsubwinptr xfe_open_sub_window();
X
X#include "pcomp.h"
X
X#endif
END_OF_FILE
if test 5160 -ne `wc -c <'player.h'`; then
    echo shar: \"'player.h'\" unpacked with wrong size!
fi
# end of 'player.h'
fi
if test -f 'shop_ui.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'shop_ui.c'\"
else
echo shar: Extracting \"'shop_ui.c'\" \(8228 characters\)
sed "s/^X//" >'shop_ui.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <sys/param.h>
X#include <sys/types.h>
X#include <xview/xview.h>
X#include <xview/canvas.h>
X#include <xview/icon_load.h>
X#include <xview/panel.h>
X#include <xview/scrollbar.h>
X#include <xview/svrimage.h>
X#include <xview/termsw.h>
X#include <xview/text.h>
X#include <xview/tty.h>
X#include <xview/xv_xrect.h>
X#include "shop_ui.h"
X
Xshort shop_bits[] = {
X#include "shop.icon"
X};
X
XXv_opaque
XMenu_create(ip, owner)
X	caddr_t		*ip;
X	Xv_opaque	owner;
X{
X	Xv_opaque	obj;
X	
X	obj = xv_create(XV_NULL, MENU_CHOICE_MENU,
X		XV_KEY_DATA, INSTANCE, ip,
X		MENU_GEN_PIN_WINDOW, (Xv_opaque) ip[0], curr->menu_name,
X		NULL);
X	curr->MenuPointer=obj;
X	return obj;
X}
X
XMainWinObjs *
XMainWinObjsInit(ip, owner)
X	MainWinObjs	*ip;
X	Xv_opaque	owner;
X{
X	if (!ip && !(ip = (MainWinObjs *) calloc(1, sizeof (MainWinObjs))))
X		return (MainWinObjs *) NULL;
X   if (!ip->Shop)
X        ip->Shop = MainWin_create(ip, owner);
X	if (!ip->controls1)
X		ip->controls1 = Controls1_create(ip, ip->Shop);
X	if (!ip->controls2)
X		ip->controls2 = Controls2_create(ip, ip->Shop);
X	if (!ip->canvas)
X		ip->canvas = Canvas_create(ip, ip->Shop);
X	if (!ip->BuyButton)
X		ip->BuyButton = BuyButton_create(ip, ip->controls2);
X	if (!ip->SellButton)
X		ip->SellButton = SellButton_create(ip, ip->controls2);
X	if (!ip->RepairButton)
X		ip->RepairButton = RepairButton_create(ip, ip->controls2);
X	if (!ip->ShowButton)
X		ip->ShowButton = ShowButton_create(ip, ip->controls2);
X    if (!ip->InShipLabel)
X        ip->InShipLabel = InShipLabel_create(ip, ip->controls1);
X	  if (!ip->InShopLabel)
X        ip->InShopLabel = InShopLabel_create(ip, ip->controls1);
X	return ip;
X}
X
XXv_opaque
XMainWin_create(ip, owner)
X	caddr_t		ip;
X	Xv_opaque	owner;
X{
X	Xv_opaque	obj;
X	Server_image shop_image;
X	Icon	icon;
X	
X	obj = xv_create(owner, FRAME,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_WIDTH, 676,
X		XV_HEIGHT, 599,
X		XV_LABEL, "Shop",
X		FRAME_CLOSED, FALSE,
X		FRAME_SHOW_FOOTER, TRUE,
X		FRAME_SHOW_RESIZE_CORNER, TRUE,
X		NULL);
X	disp=(Display *)xv_get(obj, XV_DISPLAY);
X	gc=DefaultGC(disp, DefaultScreen(disp));
X	shop_image=(Server_image)xv_create(NULL, SERVER_IMAGE, XV_WIDTH, 64, XV_HEIGHT, 64, SERVER_IMAGE_BITS, shop_bits, NULL);
X	icon=(Icon)xv_create(obj, ICON, ICON_IMAGE, shop_image, XV_X, 100, XV_Y, 100, NULL);
X	xv_set(obj, FRAME_ICON, icon, NULL);
X	base=(Frame)obj;
X	return obj;
X}
X
XXv_opaque
XControls1_create(ip, owner)
X	caddr_t		ip;
X	Xv_opaque	owner;
X{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 0,
X		XV_Y, 0,
X		XV_WIDTH, WIN_EXTEND_TO_EDGE,
X		XV_HEIGHT, 107,
X		WIN_BORDER, FALSE,
X		NULL);
X	return obj;
X}
X
XXv_opaque
XButton_create(ip, owner)
X	caddr_t		ip;
X	Xv_opaque	owner;
X{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_BUTTON,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, lastButtonPos,
X		XV_Y, ypos,
X		XV_WIDTH, 98,
X		XV_HEIGHT, 20,
X		PANEL_LABEL_STRING, curr->menu_name,
X		PANEL_ITEM_MENU, Menu_create((caddr_t *) ip, NULL),
X		NULL);
X	lastButtonPos += (int) xv_get(obj, XV_WIDTH, NULL) + 10;
X	if(lastButtonPos>600) {
X		lastButtonPos=10;
X		ypos=ypos+25;
X	}
X	
X	return obj;
X}
X
XXv_opaque
XCanvas_create(ip, owner)
X    caddr_t     ip;
X    Xv_opaque   owner;
X{
X    extern Notify_value Choose();
X    extern void DrawBits();
X    Xv_opaque   obj;
X
X    obj = xv_create(owner, CANVAS,
X        XV_KEY_DATA, INSTANCE, ip,
X        XV_X, 0,
X        XV_Y, 109,
X        XV_WIDTH, WIN_EXTEND_TO_EDGE,
X        XV_HEIGHT, 443,
X        CANVAS_REPAINT_PROC, DrawBits,
X        CANVAS_X_PAINT_WINDOW, TRUE,
X        NULL);
X    xv_set(canvas_paint_window(obj), WIN_CONSUME_EVENTS,
X        WIN_MOUSE_BUTTONS,
X        NULL, NULL);
X    notify_interpose_event_func(canvas_paint_window(obj),
X        (Notify_func) Choose, NOTIFY_SAFE);
X    xv_set(canvas_paint_window(obj), XV_KEY_DATA, INSTANCE, ip, NULL);
X    return obj;
X}
X
XXv_opaque
XControls2_create(ip, owner)
X	caddr_t		ip;
X	Xv_opaque	owner;
X{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 0,
X		XV_Y, 552,
X		XV_WIDTH, WIN_EXTEND_TO_EDGE,
X		XV_HEIGHT, WIN_EXTEND_TO_EDGE,
X		WIN_BORDER, FALSE,
X		NULL);
X	return obj;
X}
X
XXv_opaque
XQuitButton_create(ip, owner, x, y)
X    caddr_t     ip;
X    Xv_opaque   owner;
X	int x,y;
X{
X    extern void     QuitPressed();
X    Xv_opaque   obj;
X
X    obj = xv_create(owner, PANEL_BUTTON,
X        XV_KEY_DATA, INSTANCE, ip,
X        XV_X, x,
X        XV_Y, y,
X        XV_WIDTH, 57,
X        XV_HEIGHT, 20,
X        PANEL_LABEL_STRING, "Quit",
X        PANEL_NOTIFY_PROC, QuitPressed,
X        NULL);
X    return obj;
X}
X
XXv_opaque
XBuyButton_create(ip, owner)
X	caddr_t		ip;
X	Xv_opaque	owner;
X{
X	extern void		BuyPressed();
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_BUTTON,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 125,
X		XV_Y, 25,
X		XV_WIDTH, 40,
X		XV_HEIGHT, 20,
X		PANEL_LABEL_STRING, "Buy",
X		PANEL_NOTIFY_PROC, BuyPressed,
X		NULL);
X	return obj;
X}
X
XXv_opaque
XSellButton_create(ip, owner)
X	caddr_t		ip;
X	Xv_opaque	owner;
X{
X	extern void		SellPressed();
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_BUTTON,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 470,
X		XV_Y, 25,
X		XV_WIDTH, 40,
X		XV_HEIGHT, 20,
X		PANEL_LABEL_STRING, "Sell",
X		PANEL_NOTIFY_PROC, SellPressed,
X		NULL);
X	return obj;
X}
X
XXv_opaque
XRepairButton_create(ip, owner)
X	caddr_t		ip;
X	Xv_opaque	owner;
X{
X	extern void		RepairPressed();
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_BUTTON,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 365,
X		XV_Y, 25,
X		XV_WIDTH, 57,
X		XV_HEIGHT, 20,
X		PANEL_LABEL_STRING, "Repair",
X		PANEL_NOTIFY_PROC, RepairPressed,
X		NULL);
X	return obj;
X}
X
X
XXv_opaque
XShowButton_create(ip, owner)
X	caddr_t		ip;
X	Xv_opaque	owner;
X{
X	extern void		TogglePressed();
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_BUTTON,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 550,
X		XV_Y, 25,
X		XV_WIDTH, 40,
X		XV_HEIGHT, 20,
X		PANEL_LABEL_STRING, "Show Weapons",
X		PANEL_NOTIFY_PROC, TogglePressed,
X		NULL);
X	return obj;
X}
X
XpwdWinObjs *
XpwdWinObjsInit(ip, owner)
X	pwdWinObjs	*ip;
X	Xv_opaque	owner;
X{
X	if (!ip && !(ip = (pwdWinObjs *) calloc(1, sizeof (pwdWinObjs))))
X		return (pwdWinObjs *) NULL;
X	if (!ip->pwdWin)
X		ip->pwdWin = pwdWin_create(ip, owner);
X	if (!ip->controls4)
X		ip->controls4 = Controls4_create(ip, ip->pwdWin);
X	if (!ip->pwdText)
X		ip->pwdText = pwdWinPwdText_create(ip, ip->controls4);
X	return ip;
X}
X
XXv_opaque
XpwdWin_create(ip, owner)
X	caddr_t		ip;
X	Xv_opaque	owner;
X{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, FRAME_CMD,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_WIDTH, 400,
X		XV_HEIGHT, 150,
X		XV_LABEL, "Security Check!!!",
X		XV_SHOW, TRUE,
X		FRAME_SHOW_FOOTER, TRUE,
X		FRAME_SHOW_RESIZE_CORNER, FALSE,
X		FRAME_CMD_PUSHPIN_IN, FALSE,
X		NULL);
X	xv_set(xv_get(obj, FRAME_CMD_PANEL), WIN_SHOW, FALSE, NULL);
X	pwd=(Frame)obj;
X	return obj;
X}
X
XXv_opaque
XControls4_create(ip, owner)
X	caddr_t		ip;
X	Xv_opaque	owner;
X{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 9,
X		XV_Y, 33,
X		XV_WIDTH, 383,
X		XV_HEIGHT, 111,
X		WIN_BORDER, FALSE,
X		NULL);
X	return obj;
X}
X
XXv_opaque
XpwdWinPwdText_create(ip, owner)
X	caddr_t		ip;
X	Xv_opaque	owner;
X{
X	extern Panel_setting	pwdnotify();
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_TEXT,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 40,
X		XV_Y, 40,
X		XV_WIDTH, 144,
X		XV_HEIGHT, 15,
X		PANEL_LABEL_STRING, "Password: ",
X		PANEL_VALUE_X, 120,
X		PANEL_VALUE_Y, 40,
X		PANEL_LAYOUT, PANEL_HORIZONTAL,
X		PANEL_VALUE_DISPLAY_LENGTH, 9,
X		PANEL_VALUE_STORED_LENGTH, 9,
X		PANEL_MASK_CHAR, TRUE,
X		PANEL_READ_ONLY, FALSE,
X		PANEL_NOTIFY_PROC, pwdnotify,
X		NULL);
X	return obj;
X}
X
X
XXv_opaque
XInShipLabel_create(ip, owner)
X    caddr_t     ip;
X    Xv_opaque   owner;
X{
X    Xv_opaque   obj;
X
X    obj = xv_create(owner, PANEL_MESSAGE,
X        XV_KEY_DATA, INSTANCE, ip,
X        XV_X, 360,
X        XV_Y, 90,
X        XV_WIDTH, 111,
X        XV_HEIGHT, 13,
X        PANEL_LABEL_STRING, "Items in your ship:",
X        PANEL_LABEL_BOLD, FALSE,
X        NULL);
X    return obj;
X}
X
XXv_opaque
XInShopLabel_create(ip, owner)
X    caddr_t     ip;
X    Xv_opaque   owner;
X{
X    Xv_opaque   obj;
X
X    obj = xv_create(owner, PANEL_MESSAGE,
X        XV_KEY_DATA, INSTANCE, ip,
X        XV_X, 10,
X        XV_Y, 90,
X        XV_WIDTH, 108,
X        XV_HEIGHT, 13,
X        PANEL_LABEL_STRING, "Items in the Shop:",
X        PANEL_LABEL_BOLD, FALSE,
X        NULL);
X    return obj;
X}
X
END_OF_FILE
if test 8228 -ne `wc -c <'shop_ui.c'`; then
    echo shar: \"'shop_ui.c'\" unpacked with wrong size!
fi
# end of 'shop_ui.c'
fi
if test -f 'stats.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stats.c'\"
else
echo shar: Extracting \"'stats.c'\" \(8423 characters\)
sed "s/^X//" >'stats.c' <<'END_OF_FILE'
X/* stats.c - ***  */
X
X#if !defined(lint)
Xstatic char sccs_id[] = "@(#)stats.c 1.25 93/06/03 XMPB";
X#endif
X#include "player.h"
X#define W			200
X#define H	 		25
X#define BAR1X 		10
X#define BAR2X 		230
X#define COL2		250
X#define STATUSOFFSET 160
X#define SHIELDL		20 
X#define SHIELDR		70 
X#define SHIELDB		120 
X#define HP 			20
X#define ENERGY 	 170
X
Xextern weap_energy[NO_WEAPONS];
Xextern char weap_names[NO_WEAPONS][20];
Xextern int secs_left, mins_left;
X 
Xbar_graph(w,max,curr,last,x,y,width,h)
Xwinptr w; 
Xint max,curr,*last,x,y,width,h;
X{
X	int scale;
X
X	scale = max/(width);
X
X	if(*last == -1)
X	{	
X		XDrawRectangle(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X			x-1,y-1,width+1,h+1);
X		XFillRectangle(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X			x,y,(width)*curr/max,h);
X		*last = curr;
X	}
X	else 
X	{
X		XClearArea(w->stats->theDisplay,w->stats->theWindow,x,y,width,h,False);
X		XFillRectangle(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X			x,y,(width)*curr/max,h);
X		*last = curr;
X	}
X}
X
Xstatus(w,val,y)
Xwinptr w;
Xint val,y;
X{
X	char buf[MAX_NAME_SIZE];
X
X	if(val==-1)
X	{
X		 XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X            COL2+STATUSOFFSET,y,"N/A",strlen("N/A"));
X	}
X	else if(val==0) 
X	{
X		XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X			COL2+STATUSOFFSET,y,"Destroyed",strlen("Destroyed"));
X	} 
X	else if(val<100)
X	{
X		sprintf(buf,"%d %% ",val);
X		XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X			COL2+STATUSOFFSET,y,buf,strlen(buf));
X	}
X	else 
X	{
X		XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X			COL2+STATUSOFFSET,y,"Okay",strlen("Okay"));
X	}
X}	
X
X	
Xdo_stats(w)
Xwinptr w;
X{
X
X	char buf[MAX_NAME_SIZE];
X	XEvent xe;
X	int i;
X
X	while(XCheckWindowEvent(w->stats->theDisplay,w->stats->theWindow,ExposureMask,&xe))
X	{
X		switch(xe.type)
X		{
X			case Expose:
X				w->lls = -1;	
X				w->lrs = -1;
X				w->lbs = -1;
X				w->le = -1;
X				sprintf(buf,"Name: %s",w->Name);
X				XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					COL2,20,buf,strlen(buf));
X				sprintf(buf,"Ship: %s",w->Ship);
X				XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					COL2,40,buf,strlen(buf));
X				sprintf(buf,"Credits: %d   ",w->credits);
X				XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					COL2,60,buf,strlen(buf));
X				XDrawLine(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					COL2,250,470,250); 	
X				XDrawLine(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					COL2,253,470,253); 	
X				XDrawLine(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					COL2+140,230,COL2+140,405); 	
X				XDrawLine(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					COL2+143,230,COL2+143,405); 	
X				sprintf(buf,"Hardware: ");
X				XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					COL2+10,245,buf,strlen(buf));
X				sprintf(buf,"Status: ");
X				XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					COL2+STATUSOFFSET,245,buf,strlen(buf));
X				XDrawLine(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					0,207,480,207); 	
X				XDrawLine(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					240,0,240,415); 	
X		{
X		char buf[40];
X		
X				sprintf(buf, "Left Shield (%d)", w->ls_max);
X				XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					BAR1X, SHIELDL-6,buf,strlen(buf));
X				sprintf(buf, "Right Shield (%d)", w->rs_max);
X				XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					BAR1X, SHIELDR-6,buf,strlen(buf));
X				sprintf(buf, "Bottom Shield (%d)", w->bs_max);
X				XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					BAR1X, SHIELDB-6,buf,strlen(buf));
X				sprintf(buf, "Energy (%d)", w->energy_max);
X				XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X					BAR1X, ENERGY-6,buf,strlen(buf));
X		}
X				for(i=0; i < NUM_ITEMS; i++) {
X        			sprintf(buf,"%s (%d)",w->name[i],w->quality[i]);
X        			XDrawImageString(w->stats->theDisplay,w->stats->theWindow,
X					  w->stats->theGC, COL2+10,270+20*i,buf,strlen(buf));
X        			status(w,w->state[i],270+20*i);
X				}
X				break;
X			default:
X				break;
X		}
X	}
X
X	/* top left */
X	/* KLUDGE ALERTT!!!! */
X	if(w->energy_curr<0) w->energy_curr=0;
X	if(w->lls!=w->ls_curr) 
X		bar_graph(w,w->ls_max, w->ls_curr, &w->lls,BAR1X, SHIELDL, W, H);
X	if(w->lrs!=w->rs_curr) 
X		bar_graph(w,w->rs_max, w->rs_curr, &w->lrs,BAR1X, SHIELDR, W, H);
X	if(w->lbs!=w->bs_curr) 
X		bar_graph(w,w->bs_max, w->bs_curr, &w->lbs,BAR1X, SHIELDB, W, H);
X	if(w->le!=w->energy_curr) 
X		bar_graph(w,w->energy_max, w->energy_curr, &w->le,BAR1X, ENERGY, W, H);
X
X	/* top right */
X
X	sprintf(buf,"Earned: %d Credits",w->earned);
X	XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X		COL2,80,buf,strlen(buf));
X
X	sprintf(buf,"Kills: %d",w->kills);
X	XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X		COL2,100,buf,strlen(buf));
X
X	sprintf(buf,"Value: %d",w->ship_value);
X	XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X		COL2,120,buf,strlen(buf));
X
X	if(secs_left>=59)
X		sprintf(buf,"Time Left: %d mins  ", mins_left);
X	else
X	{
X		if(w->star)
X		{
X			sprintf(buf,"* Time Left: %d secs  ", secs_left);
X			w->star=0;
X		}
X		else
X		{
X			sprintf(buf,"  Time Left: %d secs", secs_left);
X			w->star=1;
X		}
X	}
X	if(!w->npcwin)
X		XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X		COL2,140,buf,strlen(buf));
X	else
X		XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X		COL2,180,buf,strlen(buf));
X
Xif(w->npc)
X{
X	for(i=1;i<w->comp->no_states;i++)
X	{
X		if(w->comp->pc < w->comp->stp[i])
X			break;
X	}
X	sprintf(buf,"State: %20s",w->comp->states[i-1]);
X	XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X		COL2,140,buf,strlen(buf));
X
X	if(w->comp->ce)
X		sprintf(buf,"Enemy: %20s",w->comp->ce->Name);
X	else
X		sprintf(buf,"Enemy: %20s","None");
X	XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X		COL2,160,buf,strlen(buf));
X}
X	/* bottom left */
X
X/* show the weapon name */	
X	if(w->curr_weap != -1)
X	{
X		sprintf(buf,"Weapon: %s      ",weap_names[w->curr_weap]);
X	}
X	else
X		sprintf(buf,"Weapon: None               ");
X	
X	XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X		BAR1X,230,buf,strlen(buf));
X
X/* update the display of the current weapon  */
Xif(w->curr_weap != -1)
X{
X	sprintf(buf,"Status: ");
X	if(w->weap_on_status[w->curr_weap] == 0)
X		strcat(buf,"Off      ");
X	else if(w->load_status[w->curr_weap] > 0)
X		strcat(buf,"Loading  ");
X	else if(w->load_status[w->curr_weap] == 0)
X		strcat(buf,"Ready    ");
X	else 
X		strcat(buf,"Destroyed");
X	XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X		BAR1X,250,buf,strlen(buf));
X
X	sprintf(buf,"Weapon Energy Usage: %d ",weap_energy[w->curr_weap]);
X	XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X		BAR1X,270,buf,strlen(buf));
X}
X
Xif(w->state[REPAIR]>0) {
X	sprintf(buf,"Repair: %s",w->name[w->rep_which]);
X	XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X		BAR1X,290,buf,strlen(buf));
X}
X
X	/* KLUDGE ALERT!!! spacing here is not on */
Xif(w->state[TC]>0) {
X	if (w->targeting)
X		sprintf(buf,"Targeting: %-20s",w->targeting->Name);
X	else
X		sprintf(buf,"Targeting: %-20s", "Off");
X	XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X		BAR1X,310,buf,strlen(buf));
X}
X
X	sprintf(buf,"Shields Regenerating: ");
X	if(w->shield_regen)
X		strcat(buf,"True ");
X	else
X		strcat(buf,"False");
X	XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X		BAR1X,330,buf,strlen(buf));
Xif(w->state[CLOAK]>0) {
X	sprintf(buf,"Jamming: ");
X	if(w->cloaking)
X		strcat(buf,"On ");
X	else
X		strcat(buf,"Off");
X	 XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X        BAR1X,350,buf,strlen(buf));
X}
X
X	/* bottom right */
Xif(w->damaged || w->rep_which!=IDLE) {
X	for(i=0; i < NUM_ITEMS; i++) { 
X		sprintf(buf,"%s (%d)",w->name[i],w->quality[i]);
X		XDrawImageString(w->stats->theDisplay,w->stats->theWindow,w->stats->theGC,
X			COL2+10,270+20*i,buf,strlen(buf));
X		status(w,w->state[i],270+20*i);
X	}
X	w->damaged=0;
X}
X
X	XFlush(w->stats->theDisplay);
X
X}
END_OF_FILE
if test 8423 -ne `wc -c <'stats.c'`; then
    echo shar: \"'stats.c'\" unpacked with wrong size!
fi
# end of 'stats.c'
fi
if test -f 'util.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util.c'\"
else
echo shar: Extracting \"'util.c'\" \(2759 characters\)
sed "s/^X//" >'util.c' <<'END_OF_FILE'
X#include "player.h"
X#include "save.h"
X#include "weapon.h"
X
Xint val(i)
Xint i;
X{
X	if(i==-1)
X		return 1;
X	if(i >=1 && i <=9)
X		return 1;
X	return 0;
X}
X
Xint euid;
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	save *dude;
X	extern save default_save;
X	char s[100];
X	int i;
X
X	if(argc!=2) 
X	{
X		printf("Usage: %s Name\n", argv[0]);
X		exit(1);
X	}
X	euid=geteuid();
X	dude=load_dude(argv[1]);
X	printf("Change Name to (%s): ", dude->Name);
X	gets(s);
X	if(strlen(s))
X		strcpy(dude->Name,s);
X	printf("Change Ship to (%s): ", dude->Ship);
X	gets(s);
X	if(strlen(s))
X		strcpy(dude->Ship,s);
X	printf("Change Password to (%s): ", dude->password);
X	gets(s);
X	if(strlen(s))
X		strcpy(dude->password,s);
X	printf("Engine Quality (-1 == none, curr =%d): ", dude->quality[ENGINE]);
X	gets(s);
X	i=atoi(s);
X	if(val(i) && strlen(s))
X	{
X		dude->quality[ENGINE]=i;
X		dude->state[ENGINE]=100;
X	}
X	printf("Solar Quality (-1 == none, curr =%d): ", dude->quality[SOLAR]);
X	gets(s);
X	i=atoi(s);
X	if(val(i) && strlen(s))
X	{
X		dude->quality[SOLAR]=i;
X		dude->state[SOLAR]=100;
X	}
X	printf("Long Range Radar Quality (-1 == none, curr =%d): ", dude->quality[LONGRR]);
X	gets(s);
X	i=atoi(s);
X	if(val(i) && strlen(s))
X	{
X		dude->quality[LONGRR]=i;
X		dude->state[LONGRR]=100;
X	}
X	printf("Short Range Radar Quality (-1 == none, curr =%d): ", dude->quality[SHORTRR]);
X	gets(s);
X	i=atoi(s);
X	if(val(i) && strlen(s))
X	{
X		dude->quality[SHORTRR]=i;
X		dude->state[SHORTRR]=100;
X	}
X	printf("Repair Quality (-1 == none, curr =%d): ", dude->quality[REPAIR]);
X	gets(s);
X	i=atoi(s);
X	if(val(i) && strlen(s))
X	{
X		dude->quality[REPAIR]=i;
X		dude->state[REPAIR]=100;
X	}
X	printf("Targeting Quality (-1 == none, curr =%d): ", dude->quality[TC]);
X	gets(s);
X	i=atoi(s);
X	if(val(i) && strlen(s))
X	{
X		dude->quality[TC]=i;
X		dude->state[TC]=100;
X	}
X	printf("Jamming Quality (-1 == none, curr =%d): ", dude->quality[CLOAK]);
X	gets(s);
X	i=atoi(s);
X	if(val(i) && strlen(s))
X	{
X		dude->quality[CLOAK]=i;
X		dude->state[CLOAK]=100;
X	}
X	for(i=0; i<NO_WEAPONS; i++)
X	{
X		printf("Do you want a ");
X		if(dude->does_have_weap[i])
X			printf("%s (y): ", weap_names[i]);
X		else
X			printf("%s (n): ", weap_names[i]);
X		gets(s);
X		if(!strcmp(s,"y"))
X			dude->does_have_weap[i]=1;
X		else
X			dude->does_have_weap[i]=0;
X	}
X	printf("Left Shield at (%d): ", dude->ls_max);
X	gets(s);
X	i=atoi(s);
X	if(strlen(s)) dude->ls_max=i;
X	printf("Right Shield at (%d): ", dude->rs_max);
X	gets(s);
X	i=atoi(s);
X	if(strlen(s)) dude->rs_max=i;
X	printf("Bottom Shield at (%d): ", dude->bs_max);
X	gets(s);
X	i=atoi(s);
X	if(strlen(s)) dude->bs_max=i;
X	printf("Energy at (%d): ", dude->energy_max);
X	gets(s);
X	i=atoi(s);
X	if(strlen(s)) dude->energy_max=i;
X	printf("Credits (%d): ", dude->credits);
X	gets(s);
X	i=atoi(s);
X	if(strlen(s)) dude->credits=i;
X	save_dude(dude);
X}
END_OF_FILE
if test 2759 -ne `wc -c <'util.c'`; then
    echo shar: \"'util.c'\" unpacked with wrong size!
fi
# end of 'util.c'
fi
if test -f 'xoutput.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xoutput.c'\"
else
echo shar: Extracting \"'xoutput.c'\" \(5647 characters\)
sed "s/^X//" >'xoutput.c' <<'END_OF_FILE'
X/* xoutput.c - ***  */
X
Xstatic char sccs_id[] = "@(#)xoutput.c 1.8 92/12/04 XMPB";
X#include <stdlib.h>
X#include <stdio.h>
X
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/cursorfont.h>
X#include "bitmaps/ship.0"
X#include "player.h"
X
X#define FULL_CIRCLE	(360*64)
X#define START_CIRCLE 0
X#define BORDER_WIDTH	2
X#define RES_NAME	"xfe"
X#define RES_CLASS	"XFE"
X
X#define CIRCLE	1
X#define POINT	2
X#define LINE	3
X#define TEXT	4
X
Xstruct player *first_win = NULL;
X
Xwinptr xfe_open_window(dn,x,y,w,h,minw,maxw,minh,maxh,title)
Xchar *dn;
Xint x,y,w,h;
Xint minw,maxw,minh,maxh;
Xchar *title;
X{
X	XGCValues		theGCValues;
X	int flag;
X	int *depths;
X	int num_depths;
X	int i;
X
X	XSetWindowAttributes	theWindowAttributes;
X	XSizeHints		theSizeHints;
X	unsigned long		theWindowMask;
X	Pixmap			theIconPixmap;
X	XWMHints		theWMHints;
X	XClassHint		theClassHint;
X	XVisualInfo		*VI,visualinfo;
X
X	winptr xfewinptr;
X
X	xfewinptr = (winptr)malloc(sizeof(struct player));
X	if(xfewinptr == NULL)
X	{
X		return NULL;
X	}
X
X	xfewinptr->x = x;
X	xfewinptr->y = y;
X	xfewinptr->w = w;
X	xfewinptr->h = h;
X	xfewinptr->minw = minw;
X	xfewinptr->maxw = maxw;
X	xfewinptr->minh = minh;
X	xfewinptr->maxw = maxw;
X	xfewinptr->title = title;
X	
X	if(!strcmp(dn,"")) xfewinptr->theDisplay = XOpenDisplay(NULL);
X	else
X		xfewinptr->theDisplay = XOpenDisplay(dn);
X
X	if(!(xfewinptr->theDisplay))
X	{
X		free(xfewinptr);
X		return NULL;
X	}
X
X	
X	xfewinptr->theScreen = DefaultScreen(xfewinptr->theDisplay);
X
X	xfewinptr->thedepth = DefaultDepth(xfewinptr->theDisplay,xfewinptr->theScreen);
X	xfewinptr->theBlackPixel = BlackPixel(xfewinptr->theDisplay,xfewinptr->theScreen);
X	xfewinptr->theWhitePixel = WhitePixel(xfewinptr->theDisplay,xfewinptr->theScreen);
X	xfewinptr->theCursor = XCreateFontCursor(xfewinptr->theDisplay,XC_crosshair);
X
X	theWindowAttributes.border_pixel = xfewinptr->theBlackPixel;
X	theWindowAttributes.background_pixel = xfewinptr->theBlackPixel;
X	theWindowAttributes.cursor = xfewinptr->theCursor;
X	theWindowAttributes.override_redirect = False;
X
X	theWindowMask = CWBackPixel | CWBorderPixel | CWOverrideRedirect | CWCursor;
X
X	xfewinptr->theWindow = XCreateWindow(xfewinptr->theDisplay,
X			RootWindow(xfewinptr->theDisplay,xfewinptr->theScreen),
X			x,y,w,h,BORDER_WIDTH,CopyFromParent,CopyFromParent,
X			CopyFromParent,theWindowMask,&theWindowAttributes);
X
X	theIconPixmap = XCreateBitmapFromData(xfewinptr->theDisplay,xfewinptr->theWindow,ship0_bits,
X						ship0_width,ship0_height);
X	theWMHints.initial_state = NormalState;
X
X	theWMHints.icon_pixmap = theIconPixmap;
X	
X	theWMHints.flags = IconPixmapHint | StateHint;
X
X	XSetWMHints(xfewinptr->theDisplay,xfewinptr->theWindow,&theWMHints);
X
X	XStoreName(xfewinptr->theDisplay,xfewinptr->theWindow,xfewinptr->title);
X	XSetIconName(xfewinptr->theDisplay,xfewinptr->theWindow,xfewinptr->title);
X
X	theClassHint.res_name = RES_NAME;
X	theClassHint.res_class = RES_CLASS;
X
X	XSetClassHint(xfewinptr->theDisplay,xfewinptr->theWindow,&theClassHint);
X
X	theSizeHints.flags = USPosition | USSize | PMinSize | PMaxSize;
X	theSizeHints.x     = x;
X	theSizeHints.y	   = y;
X	theSizeHints.width = w;
X	theSizeHints.height = h;
X	theSizeHints.min_width = minw;
X	theSizeHints.max_width = maxw;
X	theSizeHints.min_height = minh;
X	theSizeHints.max_height = maxh;
X
X	XSetNormalHints(xfewinptr->theDisplay,xfewinptr->theWindow,&theSizeHints);
X	theGCValues.function = GXcopy;
X	theGCValues.foreground = xfewinptr->theWhitePixel;
X	theGCValues.background = xfewinptr->theBlackPixel;
X	theGCValues.graphics_exposures = False;
X	xfewinptr->theGC = XCreateGC(xfewinptr->theDisplay,xfewinptr->theWindow,(unsigned long)(GCFunction|GCForeground|GCBackground),&theGCValues);
X
X	if(xfewinptr->theGC == 0)
X	{
X		XDestroyWindow(xfewinptr->theDisplay,xfewinptr->theWindow);
X		free(xfewinptr);
X		return NULL;
X	}
X	XSetForeground(xfewinptr->theDisplay,xfewinptr->theGC,xfewinptr->theBlackPixel);
X	XSetBackground(xfewinptr->theDisplay,xfewinptr->theGC,xfewinptr->theWhitePixel);
X/*
X	XSelectInput(xfewinptr->theDisplay,xfewinptr->theWindow,ExposureMask);
X*/
X	XMapWindow(xfewinptr->theDisplay,xfewinptr->theWindow);
X	XFlush(xfewinptr->theDisplay);
X
X	if(xfewinptr->next = first_win)
X		xfewinptr->next->prev = xfewinptr;
X	xfewinptr->prev = NULL;
X	first_win = xfewinptr;
X
X	return xfewinptr;
X
X}
X
Xvoid xfe_clear(win)
Xwinptr win;
X{
X	XClearWindow(win->theDisplay,win->theWindow);
X	XFlush(win->theDisplay);
X}
X
Xvoid xfe_circle(win,x,y,rad)
Xwinptr win;
Xint x,y,rad;
X{
X
X	XDrawArc(win->theDisplay,win->theWindow,win->theGC,x-rad,y-rad,2*rad,2*rad,START_CIRCLE,FULL_CIRCLE);
X	XFlush(win->theDisplay);
X}
X
Xvoid xfe_point(win,x,y)
Xwinptr win;
Xint x,y;
X{
X
X	XDrawPoint(win->theDisplay,win->theWindow,win->theGC,x,y);
X	XFlush(win->theDisplay);
X}
X
Xvoid xfe_line(win,x,y,x1,y1)
Xwinptr win;
Xint x,y,x1,y1;
X{
X	XDrawLine(win->theDisplay,win->theWindow,win->theGC,x,y,x1,y1);
X	XFlush(win->theDisplay);
X}
X
Xvoid xfe_text(win,x,y,s)
Xwinptr win;
Xint x,y;
Xchar *s;
X{
X	XDrawString(win->theDisplay,win->theWindow,win->theGC,x,y,s,strlen(s));
X	XFlush(win->theDisplay);
X}
X
Xvoid xfe_fgcolor(col)
Xint col;
X{
X}
X
Xvoid xfe_bkcolor(col)
Xint col;
X{
X}
X
Xvoid xfe_rectangle(win,x,y,x1,y1)
Xwinptr win;
Xint x,y,x1,y1;
X{
X	XDrawRectangle(win->theDisplay,win->theScreen,win->theGC,x,y,x1-x,y1-y);
X	XFlush(win->theDisplay);
X}
X
Xvoid xfe_box(win,x,y,x1,y1)
Xwinptr win;
Xint x,y,x1,y1;
X{
X	XFillRectangle(win->theDisplay,win->theWindow,win->theGC,x,y,x1-x,y1-y);
X	XFlush(win->theDisplay);
X}
X
Xvoid xfe_fill(x,y)
Xint x,y;
X{
X}
X
Xvoid xfe_solidcircle(win,x,y,rad)
Xwinptr win;
Xint x,y,rad;
X{
X	XFillArc(win->theDisplay,win->theWindow,win->theGC,x-rad,y-rad,2*rad,2*rad,START_CIRCLE,FULL_CIRCLE);
X	XFlush(win->theDisplay);
X}
X
Xvoid xfe_linestyle(ls)
Xint ls;
X{
X}
X
X
END_OF_FILE
if test 5647 -ne `wc -c <'xoutput.c'`; then
    echo shar: \"'xoutput.c'\" unpacked with wrong size!
fi
# end of 'xoutput.c'
fi
echo shar: End of archive 5 \(of 8\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
