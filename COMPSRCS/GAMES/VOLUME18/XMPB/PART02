Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i002:  xmpb - multiplayer space combat for X, Part02/08
Date: 26 Jun 1993 00:32:16 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 1845
Approved: billr@saab.CNA.TEK.COM
Message-ID: <20g5eg$6sl@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1792

Submitted-by: ddp@deakin.edu.au (Damien De Paoli)
Posting-number: Volume 18, Issue 2
Archive-name: xmpb/Part02
Environment: X11, Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 8)."
# Contents:  input.c shop_stubs.c xmpb.man
# Wrapped by billr@saab on Fri Jun 25 16:30:14 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'input.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'input.c'\"
else
echo shar: Extracting \"'input.c'\" \(7677 characters\)
sed "s/^X//" >'input.c' <<'END_OF_FILE'
X/* input.c - *** Get strings from X-window */
X
Xstatic char sccs_id[] = "@(#)input.c 1.9 93/01/13 XMPB";
X#include "player.h"
X#include "bitmaps/ship.0"
X#include <X11/keysym.h>
X#include <ctype.h>
X#define BORDER_WIDTH 2
X#define RES_NAME "da" 
X#define RES_CLASS "da"
X#include "save.h"
X
Xextern int euid;
Xextern save default_save;
Xextern winptr first_win;
Xextern int no_hosts;
Xextern int numnpcs;
X
Xsave *load_dude();
X
Xint get_string(w, aGC, x, y, out, answer, show)
Xwinptr w;
XGC aGC;
Xint x,y;
Xchar *out, *answer;
Xint show;
X{
X
X			char buf[10];   /* dummy buffer for XLookupString */
X	char *buf2; 	/* stores full string */
X	char nl[MAX_NAME_SIZE*2]; /* just blanks for a newline */
X	XEvent xe;      /* the X event received */
X	KeySym keysym;  /* the keysym decoded from the event */
X	int fin=0,i;		/* i = loop counter, y is where to draw text */
X	int dr, far, fdr; /* need these for text bits */
X	XCharStruct or; /* overall return */
X	int tw; /* textwidth */
X
X    XTextExtents(w->xf, out, strlen(out),&dr,&far,&fdr,&or);
X	
X	buf2=answer; 					/* where to put string */ 
X	for(i=0; i< MAX_NAME_SIZE; i++)  /* blank new line */
X	{
X		buf2[i]=0;
X		nl[i]=' ';
X	}
X	for(i=MAX_NAME_SIZE-1; i<2*MAX_NAME_SIZE; i++)
X		nl[i]=' ';
X	nl[i-1]=0;
X	for(i=0; i< 10; i++)
X		buf[i]=0;
X	XDrawImageString(w->theDisplay, w->theWindow, aGC, x, y, out, strlen(out));
X	XSync(w->theDisplay,False);
X    while(XCheckWindowEvent(w->theDisplay,w->theWindow,EVENTMASK,&xe))
X    {
X        switch(xe.type)
X        {
X			case KeyPress:
X		 		XLookupString(&(xe.xkey),buf,10,&keysym,NULL);	/* what key pressed */
X				switch(keysym) {
X					case XK_BackSpace:
X					case XK_Delete:					/* del a char, so move \0 back one and draw nl */
X						XDrawImageString(w->theDisplay, w->theWindow, aGC, x+29, y, nl, strlen(nl));
X						return 2;
X						break;
X			
X					case XK_Linefeed:			/* end of string so return */
X					case XK_Return:
X							return 1;
X						break;
X					case XK_Shift_L:
X					case XK_Shift_R:
X						break;
X
X					default:
X						/* if haven't typed too much, put char on */
X						if(strlen(buf2)!=MAX_NAME_SIZE-1)
X							strcat(buf2, buf);
X						break;
X				}
X				if(show)
X				XDrawImageString(w->theDisplay, w->theWindow, aGC, or.width + x, y, buf2, strlen(buf2));
X				XSync(w->theDisplay,False);
X				break;
X		
X			case Expose:
X				if(show)
X				XDrawImageString(w->theDisplay, w->theWindow, aGC, x, y, out, strlen(out));
X				XSync(w->theDisplay,False);
X				break;
X			default:
X				break;
X		}
X	}
X	return 0;
X}
X
Xget_name(w)
Xwinptr w;
X{
Xchar answer[MAX_NAME_SIZE];
Xchar buf[80];
Xint res;
X
X	sprintf(buf, "Enter your name: %s", w->Name);
X	res=get_string(w, w->aGC, 20, 20, buf, answer,1); /* we got name */
X	if(res==1)
X	{
X		return 1;
X	}
X	if(res==2)
X		w->Name[strlen(w->Name)-1]=0;
X	else
X		if(strlen(w->Name) < MAX_NAME_SIZE -1)
X			strcat(w->Name, answer);
X	return 0;
X}
X
Xget_ship(w)
Xwinptr w;
X{
Xchar answer[MAX_NAME_SIZE];
Xchar buf[80];
Xint res;
X
X	sprintf(buf, "Enter the name of your Ship: %s", w->Ship);
X	res=get_string(w, w->aGC, 20, 50, buf, answer,1);
X	if(res==1)
X		return 1;
X	if(res==2)
X		w->Ship[strlen(w->Ship)-1]=0;
X	else
X		if(strlen(w->Ship) < MAX_NAME_SIZE -1)
X			strcat(w->Ship, answer);
X	return 0;
X}
X
Xget_password(w, which)
Xwinptr w;
Xint which;
X{
Xchar answer[MAX_NAME_SIZE];
Xchar buf[80];
Xint res;
X
X	if(!which)
X		sprintf(buf, "Enter your new password:");
X	else
X	if(which==1)
X		sprintf(buf, "Password:");
X	else
X		sprintf(buf, "Retype your new password:");
X	if(which==2)
X		res=get_string(w, w->aGC, 20, 100, buf,answer,0);
X	else
X		res=get_string(w, w->aGC, 20, 80, buf,answer,0);
X	if(res==1)
X	{
X		if(which==2)
X		{
X			if(strlen(w->pass2) < MAX_NAME_SIZE -1)
X			{
X                strcat(w->pass2, answer);
X			}
X		}
X		else
X			if(strlen(w->password) < MAX_NAME_SIZE -1)
X				strcat(w->password, answer);
X		return 1;
X	}
X	if(res==2)
X	{
X		if(which==2)
X			w->pass2[strlen(w->pass2)-1]=0;
X		else
X			w->password[strlen(w->password)-1]=0;
X	}
X	else
X	{
X		if(which==2)        
X		{
X			if(strlen(w->pass2) < MAX_NAME_SIZE -1)
X			{
X				strcat(w->pass2, answer);
X			}
X		}
X		else
X		{
X			if(strlen(w->password) < MAX_NAME_SIZE -1)
X				strcat(w->password, answer);
X		}
X	}
X	return 0;
X}
X
Xset_vars(w)
Xwinptr w;
X{
Xsave *x;
Xint i;
Xchar buf[160];
XFILE *tmp;
X
X
X	x=load_dude(w->Name);
X	if(x!=&default_save)
X		strcpy(w->Ship, x->Ship);
X	if(!w->npc)
X	{
X		strcpy(buf, SAVEDIR);
X		strcat(buf, w->Name);
X		strcat(buf, ".lock");
X
Xseteuid(euid);
X		tmp=fopen(buf, "w");
Xseteuid(getuid());
X		if(!tmp)
X		{
X			printf("Cannot open lock file\n");
X		}
X		fclose(tmp);
X    	w->energy_max=x->energy_max;
X    	w->ls_max=x->ls_max;
X    	w->bs_max=x->bs_max;
X    	w->rs_max=x->rs_max;
X    	w->credits=x->credits;
X		w->kills = x->kills;
X    	for(i=0; i<NUM_ITEMS; i++)
X    	{
X        	w->quality[i]=x->quality[i];
X        	w->state[i]=x->state[i];
X    	}
X    	for(i=0; i<NO_WEAPONS; i++)
X    	{
X        	w->does_have_weap[i]=x->does_have_weap[i];
X        	w->weap_on_status[i]=x->weap_on_status[i];
X    	}
X		w->ship_value=x->ship_value;
X	}
X	/*
X	* 	Set initial shield strengths and energy
X	*/
X	w->shield_cnt = 3;
X	w->ls_curr=w->ls_max;
X	w->rs_curr=w->rs_max;
X	w->bs_curr=w->bs_max;
X	w->energy_curr=w->energy_max;
X
X	/*
X	*	Set current weapon
X	*/
X	{
X		int first;
X		int cw = 0;
X
X		w->curr_weap=WEAP_PULSE;
X		first=1;
X		while(!w->does_have_weap[w->curr_weap])
X		{
X			w->curr_weap++;
X			w->curr_weap %= NO_WEAPONS;
X			if(cw == w->curr_weap && !first)
X			{
X			w->curr_weap++;
X				cw = -1;
X				break;
X			}
X			first=0;
X		}
X		if(cw == -1) w->curr_weap = -1;
X	}
X}
X
Xget_strings()
X{
X	winptr w;
X	int done=0;
X	save *x;
X
X	while(done < no_hosts - numnpcs) 
X	{
X		w=first_win;
X		while(w)
X		{
X			if(w->npc)
X				goto KLUDGE;
X			if(w->quitting>10)
X			{
X				w->quitting--;
X				goto KLUDGE;
X			}
X			if(w->quitting==10)
X			{
X				w->quitting=6;
X				w->Name[0]=0;
X				xfe_clear(w);
X			}
X			if(w->quitting==6) 
X			{
X				if(get_name(w) && strlen(w->Name))
X				{
X					winptr r;
X
X					r=first_win;
X					while(r)
X					{
X						if(w!=r && !strcmp(r->Name, w->Name))
X						{
X							char buf[30];
X
X							xfe_clear(w);
X							sprintf(buf, "Sorry, that name has already been used by a player in this game");
X    						XDrawString(w->theDisplay, w->theWindow, w->aGC, 20, 20, buf, strlen(buf));
X							XFlush(w->theDisplay);
X							w->quitting=300;
X						}
X						r=r->next;
X					}
X					if(w->quitting==6)
X					{
X						x=load_dude(w->Name);
X						if(x == &default_save)
X							w->quitting=2;
X						else
X							w->quitting=5;
X					}
X				}
X			}
X			else 
X			{	
X				if(w->quitting==2) 
X					if(get_ship(w) && strlen(w->Ship))
X						w->quitting=3;
X				if(w->quitting==3) 
X					if(get_password(w, 0) && strlen(w->password))
X						w->quitting=4;
X				if(w->quitting==4) 
X					if(get_password(w, 2) && strlen(w->pass2))
X					{
X						if(!strcmp(w->password, w->pass2))
X						{
X							set_vars(w);
X							done++;
X							XDrawString(w->theDisplay, w->theWindow, w->aGC, 
X								20, 120, "Welcome!", 8);
X							XFlush(w->theDisplay);
X							w->quitting=0;
X						}
X						else
X						{
X							w->quitting=3;
X							w->password[0]=0;
X							w->pass2[0]=0;
X							usleep(500);
X							XClearArea(w->theDisplay, w->theWindow, 0, 70, 600, 400, False);
X						}
X					}
X				if(w->quitting==5) 
X				{
X					if(get_password(w, 1) && strlen(w->password))
X					{
X						x=load_dude(w->Name);
X						if(!strcmp(w->password, x->password))
X						{
X						char buf[80];
X							set_vars(w);
X							done++;
X							XDrawString(w->theDisplay, w->theWindow, w->aGC, 
X								20, 100, "Welcome Back!", 13);
X							XFlush(w->theDisplay);
X							w->quitting=0;
X						}
X						else
X						{
X							usleep(500);
X							xfe_clear(w);
X							w->Name[0]=0;
X							w->quitting=6;
X							w->password[0]=0;
X						}
X					}
X				}
X			}
XKLUDGE:
X			w=w->next;
X		}
X	}
X}
END_OF_FILE
if test 7677 -ne `wc -c <'input.c'`; then
    echo shar: \"'input.c'\" unpacked with wrong size!
fi
# end of 'input.c'
fi
if test -f 'shop_stubs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'shop_stubs.c'\"
else
echo shar: Extracting \"'shop_stubs.c'\" \(19508 characters\)
sed "s/^X//" >'shop_stubs.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <sys/param.h>
X#include <sys/types.h>
X#include <xview/xview.h>
X#include <xview/panel.h>
X#include <xview/textsw.h>
X#include <xview/xv_xrect.h>
X#include <xview/notice.h>
X#include <string.h>
X#include "shop_ui.h"
X#include "player.h"
X#include "save.h"
X#include "weapon.h"
X
X#define ITEMS 0
X#define WEAPONS 1
X#define LS 7
X#define RS 8
X#define BS 9
X#define ENERGY 10
X
X#define NUMLRADS 9
X
XAttr_attribute	INSTANCE;
Xint initd=0, chosen=0, passd=0;
Xsave *dude;
Xint what=-1;
XXFontStruct *xf;
Xint showing=0;
Xstruct menu_p *old_curr;
Xint	old_pos, old_what;
Xextern save default_save;
XpwdWinObjs *pwdWin;
XXFontStruct *xf;
Xint sc;
Xunsigned long white, black;
Xint euid;
X
X
Xint cost_of_item(what,pos)
Xint what,pos;
X{
Xstruct menu_p *curr;
X
X	curr=head;
X	if(what==ENGINE) {
X		return (curr->cost[dude->quality[ENGINE]-1]);
X	}
X	curr=curr->next;
X	if(what==SOLAR) {
X		return (curr->cost[dude->quality[SOLAR]-1]);
X    }
X    curr=curr->next;
X    if(what==SHORTRR || what==LONGRR) {
X		if(what==SHORTRR)
X		{
X			return (curr->cost[dude->quality[SHORTRR]+NUMLRADS-1]);	
X		}
X		else
X		{
X			return (curr->cost[dude->quality[LONGRR]-1]);
X		}
X    }
X    curr=curr->next->next;
X    if(what==REPAIR) {
X		return (curr->cost[dude->quality[REPAIR]-1]);
X    }
X    curr=curr->next;
X	if(what==TC) {
X		return (curr->cost[0]);
X	}
X	if(what==CLOAK) {
X		return (curr->cost[dude->quality[CLOAK]-1]);
X	}
X	curr=curr->next;
X	if((what==RS) || (what==BS) || (what==LS)) {
X			return(curr->cost[what-NUM_ITEMS]);
X	}
X	curr=curr->next;
X	if(what==ENERGY) {
X		return(curr->cost[0]);
X	}
X	else
X	{
X		fprintf(stderr, "No such item!  Panic time.  I'm Bailing\n Problem could be shop.contents does not match shop_stubs.c expectations\n");
X		exit(1);
X	}
X}
X
Xcost_of_weap(what)
Xint what;
X{
Xstruct menu_p *curr;
X
X    curr=head;
X	curr=curr->next->next->next;
X	return(curr->cost[what]);
X}
X
Xrevgc(which)
Xint which;
X{
X	XGCValues gcval;
X
X	if (!which)
X	{
X		gcval.background=black;
X		gcval.foreground=white;
X	}
X	else
X	{
X		gcval.background=white;
X		gcval.foreground=black;
X	}
X	XChangeGC(disp, gc, (unsigned long)GCForeground|GCBackground, &gcval);
X}
X
Xvoid
XDrawBits(canvas, paint_window, display, xid, rects)
X	Canvas		canvas;
X	Xv_window	paint_window;
X	Display		*display;
X	Window		xid;
X	Xv_xrectlist	*rects;
X{
X	char *p, buf[80];
X	int i;
X
X	win=paint_window;
X	XClearWindow(display, xid);
X	if(!passd) {
X		return;
X	}
X
X	/* all our stuff */
X	sprintf(buf, "Credits: $%d", dude->credits);
X	XDrawImageString(display, xid, gc, 360, 20, buf, strlen(buf));
X
Xif(showing==ITEMS) {
X	if(dude->state[SOLAR]!=-1)
X	{
X		sprintf(buf, "Solar Panels of quality:  %d at  (%d)%%", dude->quality[SOLAR], dude->state[SOLAR]);
X		if(what==SOLAR) {
X			revgc(0);
X			XDrawImageString(disp, xid, gc, 360, 60, buf, strlen(buf));
X			revgc(1);
X		}
X		else
X			XDrawImageString(disp, xid, gc, 360, 60, buf, strlen(buf));
X	}
X
X	if(dude->state[SHORTRR]!=-1)
X	{
X		sprintf(buf, "Short Range Radar of quality: %d at  (%d)%%", dude->quality[SHORTRR], dude->state[SHORTRR]);
X		if(what==SHORTRR)
X		{
X			revgc(0);
X			XDrawImageString(disp, xid, gc, 360, 85, buf, strlen(buf));
X		    revgc(1);
X		}
X		else
X			XDrawImageString(disp, xid, gc, 360, 85, buf, strlen(buf));
X	}
X
X	if(dude->state[ENGINE]!=-1)
X	{
X		sprintf(buf, "Engine of quality:  %d at  (%d)%%", dude->quality[ENGINE], dude->state[ENGINE]);
X		if(what==ENGINE)
X		{
X			revgc(0);
X			XDrawImageString(disp, xid, gc, 360, 110, buf, strlen(buf));
X		    revgc(1);
X		}
X		else
X			XDrawImageString(disp, xid, gc, 360, 110, buf, strlen(buf));
X	}
X
X	if(dude->state[REPAIR]!=-1)
X	{
X		sprintf(buf, "Repair System of quality: %d at  (%d)%%", dude->quality[REPAIR],  dude->state[REPAIR]);
X		if(what==REPAIR)
X		{
X			revgc(0);
X			XDrawImageString(disp, xid, gc, 360, 135, buf, strlen(buf));
X		    revgc(1);
X		}
X		else
X			XDrawImageString(disp, xid, gc, 360, 135, buf, strlen(buf));
X	}
X
X	if(dude->state[LONGRR]!=-1)
X	{
X		sprintf(buf, "Long Range Radar of quality: %d at  (%d)%%", dude->quality[LONGRR], dude->state[LONGRR]);
X		if(what==LONGRR)	
X		{
X			revgc(0);
X			XDrawImageString(disp, xid, gc, 360, 160, buf, strlen(buf));
X		    revgc(1);
X		}
X		else
X			XDrawImageString(disp, xid, gc, 360, 160, buf, strlen(buf));
X	}
X
X	if(dude->state[CLOAK]!=-1)
X	{
X		sprintf(buf, "Jammer of quality: %d at  (%d)%%", dude->quality[CLOAK], dude->state[CLOAK]);
X		if(what==CLOAK)
X		{
X			revgc(0);
X			XDrawImageString(disp, xid, gc, 360, 185, buf, strlen(buf));
X		    revgc(1);
X		}
X		else
X			XDrawImageString(disp, xid, gc, 360, 185, buf, strlen(buf));
X	}
X
X	if(dude->state[TC]!=-1)
X	{
X		sprintf(buf, "Targeting Computer of quality:  %d at  (%d)%%", dude->quality[TC], dude->state[TC]);
X		if(what==TC)
X		{
X			revgc(0);
X			XDrawImageString(disp, xid, gc, 360, 210, buf, strlen(buf));
X		    revgc(1);
X		}
X		else
X			XDrawImageString(disp, xid, gc, 360, 210, buf, strlen(buf));
X	}
X
X	sprintf(buf, "Left Shield (%d)", dude->ls_max);
X	if(what==LS) {
X		revgc(0);
X		XDrawImageString(disp, xid, gc, 360, 235, buf, strlen(buf));
X		revgc(1);
X	}
X	else
X		XDrawImageString(disp, xid, gc, 360, 235, buf, strlen(buf));
X
X	sprintf(buf, "Right Shield (%d)", dude->rs_max);
X	if(what==RS) {
X		revgc(0);
X		XDrawImageString(disp, xid, gc, 360, 260, buf, strlen(buf));
X		revgc(1);
X	}
X	else
X		XDrawImageString(disp, xid, gc, 360, 260, buf, strlen(buf));
X
X	sprintf(buf, "Bottom Shield (%d)", dude->bs_max);
X	if(what==BS) {
X		revgc(0);
X		XDrawImageString(disp, xid, gc, 360, 285, buf, strlen(buf));
X		revgc(1);
X	}
X	else
X		XDrawImageString(disp, xid, gc, 360, 285, buf, strlen(buf));
X
X	sprintf(buf, "Energy (%d)", dude->energy_max);
X	if(what==ENERGY) {
X		revgc(0);
X		XDrawImageString(disp, xid, gc, 360, 310, buf, strlen(buf));
X		revgc(1);
X	}
X	else
X		XDrawImageString(disp, xid, gc, 360, 310, buf, strlen(buf));
X}
X
X	XDrawLine(disp, xid, gc, 349, 0, 349, 600);
X	XDrawLine(disp, xid, gc, 351, 0, 351, 600);
X    if(what>=0 && ((showing==WEAPONS && what < NO_WEAPONS && dude->does_have_weap[what]>0)
X 	|| (showing==ITEMS && what < NUM_ITEMS && dude->state[what]>0) || (showing==ITEMS && what >= NUM_ITEMS && what < NUM_ITEMS+4)))
X    {
X        if(showing==ITEMS)
X		{
X            if(what < NUM_ITEMS) 
X				sprintf(buf, "Retail Value: $%d", cost_of_item(what,pos)*dude->state[what]/200);
X			else
X				sprintf(buf, "Retail Value: $%d for 100 units", cost_of_item(what,pos)/2);
X		}
X        else
X            sprintf(buf, "Retail Value: $%d", cost_of_weap(what)/2);
X        if(showing==WEAPONS) XDrawImageString(disp, xid, gc, 500, 410, buf, strlen(buf));
X        if(showing==ITEMS) XDrawImageString(disp, xid, gc, 360, 350, buf, strlen(buf));
X        if(showing==ITEMS && dude->state[what]<100 && what < NUM_ITEMS)
X        {
X            sprintf(buf, "Cost to repair: $%d", ((((100-dude->state[what])+5)*cost_of_item(what,pos))/100));
X            XDrawImageString(disp, xid, gc, 360, 410, buf, strlen(buf));
X        }
X    }
X
X	if(showing==WEAPONS)
X	{
X		int y=0;
X
X		for(y=0; y < NO_WEAPONS; y++)
X			if(dude->does_have_weap[y]) 
X			{
X				if(what==y) 
X				{
X					revgc(0);
X					XDrawImageString(disp, xid, gc, 360, 60+y*25, weap_names[y], strlen(weap_names[y]));
X					revgc(1);
X				}
X				else
X					XDrawImageString(disp, xid, gc, 360, 60+y*25, weap_names[y], strlen(weap_names[y]));
X			}
X	}
X	if(!initd && !chosen)
X	{
X		xv_set(MainWin->BuyButton, PANEL_INACTIVE, TRUE, NULL);
X    	xv_set(MainWin->SellButton, PANEL_INACTIVE, TRUE, NULL);
X    	xv_set(MainWin->RepairButton, PANEL_INACTIVE, TRUE, NULL);
X		return;
X	}	
X	if((initd && dude->credits >= curr->cost[pos]) && !(!strcmp("Weapons", curr->menu_name) && dude->does_have_weap[pos])) 
X		xv_set(MainWin->BuyButton, PANEL_INACTIVE, FALSE, NULL);
X	else
X		xv_set(MainWin->BuyButton, PANEL_INACTIVE, TRUE, NULL);
X	
X    if((what>=0) && ((showing==WEAPONS && what < NO_WEAPONS && dude->does_have_weap[what]>0) || (showing==ITEMS && what < NUM_ITEMS && dude->state[what]>0) || (showing==ITEMS && (what==LS && dude->ls_max>100) || (what==RS && dude->rs_max>100) || (what==BS && dude->bs_max>100) || (what==ENERGY && dude->energy_max>100))))
X		xv_set(MainWin->SellButton, PANEL_INACTIVE, FALSE, NULL);
X	else
X		xv_set(MainWin->SellButton, PANEL_INACTIVE, TRUE, NULL);
X	
X    if((what>=0 && what<=NUM_ITEMS-1) && showing==ITEMS && (dude->state[what]<100) && (dude->state[what]>0) && (((((100-dude->state[what])+5)*cost_of_item(what,pos))/100)<=dude->credits)) 
X	{
X		xv_set(MainWin->RepairButton, PANEL_INACTIVE, FALSE, NULL);
X	}
X	else
X		xv_set(MainWin->RepairButton, PANEL_INACTIVE, TRUE, NULL);
X
X	if(!initd) return;	
X	XDrawImageString(disp, xid, gc, 10, 20, curr->menu_item[pos], strlen(curr->menu_item[pos]));
X	XDrawImageString(disp, xid, gc, 10, 40, "Details:", strlen("Details:"));
X	
X	sprintf(buf, "Cost: $%d", curr->cost[pos]);
X	XDrawImageString(disp, xid, gc, 10, 380, buf, strlen(buf));
X	p=curr->descr[pos];
X	i=0;
X	while(*p) {
X		sscanf(p, "%[^\n]", buf);
X		p+=strlen(buf);
X		XDrawImageString(disp, xid, gc, 10, 60+i*15, buf, strlen(buf));
X		while((*p)=='\n') {
X			p++;
X			i++;
X		}
X	}
X}
X
X
XMenuNotify(menu, item)
XMenu        menu;
XMenu_item   item;
X{
X
X    /*
X    ** set curr to correct menu_item
X    */
X	initd=1;
X    curr=head;
X    while(curr)
X    {
X        for(pos=0; pos<40; pos++) {
X            if(!strcmp(curr->menu_item[pos], (char *)xv_get(item, MENU_STRING, NULL)))
X                goto KLUDGE;
X        }
X        curr=curr->next;
X    }
X
XKLUDGE:
X	old_curr=curr;
X	old_pos=pos;
X	DrawBits((Canvas)NULL,win,disp,xv_get(win,XV_XID),(Xv_xrectlist *)NULL);
X}
X
X
Xvoid
Xmain(argc, argv)
X	int		argc;
X	char		**argv;
X{
X
X	FILE *fp, *fc;
X	int i, menu_done, retn;
X	char fname[160];
X
X	euid = geteuid();
X	seteuid(getuid());
X	if(argc!=2) {
X		fprintf(stderr,"Usage: %s Name\n", argv[0]);
X		exit(1);
X	}
X	dude=load_dude(argv[1]);	
X	if(dude==&default_save) {
X		perror("No such player");
X		fprintf(stderr, "Exiting...\n");
X		exit(1);
X	}
X	fname[0]=0;
X    strcpy(fname, SAVEDIR);
X    strcat(fname, argv[1]);
X    strcat(fname, ".lock");
Xseteuid(euid);
X    fc=fopen(fname, "r");
Xseteuid(getuid());
X    if(fc)
X    {
X        fprintf(stderr,"You cannot execute the shop when you have an active xmpb window.\n");
X        fprintf(stderr,"Quit your xmpb window and then run the shop\n");
X        exit(1);
X    }
X    fclose(fc);
X
X	xv_init(XV_INIT_ARGC_PTR_ARGV, &argc, argv, 0);
X	INSTANCE = xv_unique_key();
X	
X	MainWin = MainWinObjsInit(NULL, NULL); 
X	pwdWin = pwdWinObjsInit(NULL, NULL);
X
X	lastButtonPos=10;
X	ypos=5;
X	parse_shop_contents();
X	QuitButton_create(MainWin, MainWin->controls1,lastButtonPos, ypos);
X	xv_set(base, FRAME_BUSY, TRUE, NULL);
X	xv_set(base, FRAME_CLOSED, TRUE, NULL);
X
X	xv_main_loop(MainWin->Shop);
X	exit(0);
X}
X
X
Xvoid
XQuitPressed(item, event)
X    Panel_item  item;
X    Event       *event;
X{
X	dude->ship_value=value_of_craft(dude);
X	save_dude(dude);
X	exit(0);
X}
X
Xvoid
XRepairPressed(item, event)
X	Panel_item	item;
X	Event		*event;
X{
X	int rep;
X	
X	rep=cost_of_item(what,pos);
X	rep=((((100-dude->state[what])+5)*rep)/100);
X	dude->state[what]=100;
X	dude->credits-=rep;
X	DrawBits((Canvas)NULL,win,disp,xv_get(win,XV_XID),(Xv_xrectlist *)NULL);
X	dude->ship_value=value_of_craft(dude);
X	save_dude(dude);
X	what=-1;
X}
X
Xint do_notice(panel, x, y)
XPanel panel;
X{
X	int result;
X
X	result= notice_prompt(panel, NULL,
X		NOTICE_FOCUS_XY, x, y, 
X		NOTICE_MESSAGE_STRINGS, "You already have one of these items", "Click OK to sell the existing item", "or CANCEL to cancel the buy operation", NULL,
X		NOTICE_BUTTON, "OK", 1,
X		NOTICE_BUTTON, "CANCEL", 0,
X		NULL);
X	return result;
X}
X
Xvoid
XBuyPressed(item, event)
X	Panel_item	item;
X	Event		*event;
X{
X	MainWinObjs	*ip = (MainWinObjs *) xv_get(item, XV_KEY_DATA, INSTANCE);
X
X	if(!strcmp(curr->menu_name,"Engines")) 
X	{
X		if(dude->state[ENGINE]>0) { 
X			if(!do_notice(ip->controls2, event_x(event), event_y(event))) return;
X			old_what=what; what=ENGINE; 
X			dude->credits+=cost_of_item(what,pos)*dude->state[what]/200;
X		}
X		dude->quality[ENGINE]=pos+1;
X		dude->state[ENGINE]=100;
X	}
X	else 
X	if(!strcmp(curr->menu_name,"Solar Panels")) 
X	{
X		if(dude->state[SOLAR]>0) {
X 			if(!do_notice(ip->controls2, event_x(event), event_y(event))) return;
X            old_what=what; what=SOLAR;
X            dude->credits+=cost_of_item(what,pos)*dude->state[what]/200;
X        }
X		dude->quality[SOLAR]=pos+1;
X		dude->state[SOLAR]=100;
X	}
X	else
X	if(!strcmp(curr->menu_name,"Radar")) 
X	{
X		if(pos>=NUMLRADS) 	
X		{	
X			if(dude->state[SHORTRR]>0) {
X 				if(!do_notice(ip->controls2, event_x(event), event_y(event))) return;
X				old_what=what; what=SHORTRR;
X            	dude->credits+=cost_of_item(what,pos)*dude->state[what]/200;
X        	}
X			dude->quality[SHORTRR]=pos-NUMLRADS+1;
X			dude->state[SHORTRR]=100;
X		}
X		else
X		{
X			if(dude->state[LONGRR]>0) {
X			if(!do_notice(ip->controls2, event_x(event), event_y(event))) return;
X            	old_what=what; what=LONGRR;
X            	dude->credits+=cost_of_item(what,pos)*dude->state[what]/200;
X	        }
X			dude->quality[LONGRR]=pos+1;
X            dude->state[LONGRR]=100;
X        }
X	}
X	else
X	if(!strcmp(curr->menu_name,"Weapons")) 
X	{
X		dude->does_have_weap[pos]=1;
X	}
X	else
X	if(!strcmp(curr->menu_name,"Repair Systems")) 
X	{
X		if(dude->state[REPAIR]>0) {
X		if(!do_notice(ip->controls2, event_x(event), event_y(event))) return;
X            old_what=what; what=REPAIR;
X            dude->credits+=cost_of_item(what,pos)*dude->state[what]/200;
X        }
X		dude->quality[REPAIR]=pos+1;
X		dude->state[REPAIR]=100;
X	}
X	else
X	if(!strcmp(curr->menu_name,"Miscellaneous")) 
X	{
X		if(pos==0)
X		{
X			if(dude->state[TC]>0) {
X				if(!do_notice(ip->controls2, event_x(event), event_y(event))) return;
X            		old_what=what; what=TC;
X            		dude->credits+=cost_of_item(what,pos)*dude->state[what]/200;
X        		}
X			dude->quality[TC]=0;
X			dude->state[TC]=100;
X		}
X		if(pos>0)
X		{
X			if(dude->state[CLOAK]>0) {
X	 			if(!do_notice(ip->controls2, event_x(event), event_y(event))) return;
X            		old_what=what; what=CLOAK;
X            		dude->credits+=cost_of_item(what,pos)*dude->state[what]/200;
X        	}
X			dude->quality[CLOAK]=pos+1;
X			dude->state[CLOAK]=100;
X		}
X	}
X	else
X	if(!strcmp(curr->menu_name,"Shields"))
X	{
X		switch(pos) {
X			case 0: dude->ls_max+=100;
X			break;
X			case 1: dude->rs_max+=100;
X			break;
X			case 2: dude->bs_max+=100;
X			break;
X		}
X	}
X	else
X	if(!strcmp(curr->menu_name,"Energy"))
X	{
X		dude->energy_max+=100;
X	}
X	
X	dude->credits-=curr->cost[pos];
X	DrawBits((Canvas)NULL,win,disp,xv_get(win,XV_XID),(Xv_xrectlist *)NULL);
X	dude->ship_value=value_of_craft(dude);
X	save_dude(dude);
X}
X
Xvoid
XTogglePressed(item, event)
X	Panel_item	item;
X	Event		*event;
X{
X	MainWinObjs	*ip = (MainWinObjs *) xv_get(item, XV_KEY_DATA, INSTANCE);
X	
X	showing=!showing;
X	what=-1;
X	if(showing==WEAPONS)
X		xv_set(ip->ShowButton, PANEL_LABEL_STRING, "Show Items", NULL);
X	else
X		xv_set(ip->ShowButton, PANEL_LABEL_STRING, "Show Weapons", NULL);
X	DrawBits((Canvas)NULL,win,disp,xv_get(win,XV_XID),(Xv_xrectlist *)NULL);
X}
X
Xvoid
XSellPressed(item, event)
X	Panel_item	item;
X	Event		*event;
X{
X
X	if(showing==WEAPONS)
X	{
X		dude->credits+=cost_of_weap(what)/2;
X		dude->does_have_weap[what]=0;	
X	}
X	else
X	{
X		if(what< NUM_ITEMS) {
X			dude->credits+=cost_of_item(what,pos)*dude->state[what]/200;
X			dude->state[what]=-1;
X		}
X		else {
X			dude->credits+=cost_of_item(what,pos)/2;
X			switch(what) {
X			case LS: dude->ls_max-=100;
X				break;
X			case RS: dude->rs_max-=100;
X				break;
X			case BS: dude->bs_max-=100;
X				break;
X			case ENERGY: dude->energy_max-=100;
X				break;
X			}
X		}
X	}
X	if (what < NUM_ITEMS) what=-1;
X    DrawBits((Canvas)NULL,win,disp,xv_get(win,XV_XID),(Xv_xrectlist *)NULL);
X	dude->ship_value=value_of_craft(dude);
X	save_dude(dude);
X}
X
XNotify_value
XChoose(win, event, arg, type)
X    Xv_window   win;
X    Event       *event;
X    Notify_arg  arg;
X    Notify_event_type type;
X{
X	int i, oldwhat;
X
X
X	oldwhat=what;	
X    if (event_action(event) == ACTION_SELECT && event_is_down(event)) {
X		if(event->ie_locx < 350)
X			return notify_next_event_func(win, (Notify_event) event, arg, type);
X
X	/* 20 is a KLUDGE, but it should take us out the window anyway...*/
X		for(i=0; i<20; i++) 
X			if((event->ie_locy >= 60+i*25-xf->ascent) && (event->ie_locy <= 60+i*25+xf->descent)) 
X		{
X				if(((i >= NO_WEAPONS) && (showing==WEAPONS)) || 
X					((i >= NUM_ITEMS+4) && (showing==ITEMS)))
X				{
X					what=oldwhat;
X				}
X				else 
X				{
X					what=i;
X					chosen=1;
X				}
X				break;
X		}
X		else 
X		{
X			what=oldwhat;
X		}
X		if(what!=oldwhat)
X			DrawBits((Canvas)NULL,win,disp,xv_get(win,XV_XID),(Xv_xrectlist *)NULL);
X    }
X    return notify_next_event_func(win, (Notify_event) event, arg, type);
X}
X
X	
XPanel_setting
Xpwdnotify(item, event)
X	Panel_item	item;
X	Event		*event;
X{
X	char *	value = (char *) xv_get(item, PANEL_VALUE);
X	
X	if(strcmp(value, dude->password)) {
X		xv_set(base, FRAME_BUSY, TRUE, NULL);
X	}
X	else { 
X		xv_set(base, FRAME_BUSY, FALSE, NULL);
X		xv_set(base, FRAME_CLOSED, FALSE, NULL);
X		xv_destroy_safe(pwd);
X		passd=1;
X		DrawBits((Canvas)NULL,win,disp,xv_get(win,XV_XID),(Xv_xrectlist *)NULL);
X	}
X	value[0]=0;
X	return panel_text_notify(item, event);
X}
X
X#define SHOP
X
Xparse_shop_contents()
X{
X	FILE *fp;
X	char fname[160];
X	Menu_item tempMenuItem;
X    XID fid;
X	int retn, i, menu_done;
X	
X	fname[0]=0;
X	strcpy(fname, BITMAPDIR);
X	strcat(fname, "shop.contents");
Xseteuid(euid);
X	fp=fopen(fname,"r");	
Xseteuid(getuid());
X	if(fp==NULL) {
X		fprintf(stderr, "Warning: Cannot find shop.contents in BITMAPDIR, looking in '.' instead\n");
X		strcpy(fname, "./shop.contents");
Xseteuid(euid);
X		fp=fopen(fname,"r");
Xseteuid(getuid());
X		if(fp==NULL)
X		{
X			fprintf(stderr,"No data file: %s\n", fname);
X			exit(0);
X		}
X	}
X
X	curr= (struct menu_p *) malloc(sizeof(struct menu_p));
X	head=curr;
X
X	retn=1;
X	while(retn) {
X		fgets(curr->menu_name, 40, fp);
X		curr->menu_name[strlen(curr->menu_name)-1]=0;
X
X#ifdef SHOP
X       MainWin->MenuButton = Button_create(MainWin, MainWin->controls1);
X#endif
X		menu_done=0;
X		i=0;
X		while(!menu_done && retn) {
X			retn=(int)fgets(curr->menu_item[i], 40, fp);
X			if(retn) {
X				curr->menu_item[i][strlen(curr->menu_item[i])-1]=0;
X				if(!strncmp("###",curr->menu_item[i],3)) {
X					menu_done=1;
X				}
X				else {
X					fscanf(fp, "%[^$]%*c%d%*c", curr->descr[i], &(curr->cost[i]));
X#ifdef SHOP
X					tempMenuItem=(Menu_item)xv_create(NULL,MENUITEM,MENU_STRING,
X						curr->menu_item[i],
X                    	MENU_NOTIFY_PROC, MenuNotify,
X                    	MENU_RELEASE,
X                    	NULL);
X					xv_set(curr->MenuPointer, MENU_APPEND_ITEM, tempMenuItem, NULL);
X#endif
X				}
X				i++;
X			}
X		}
X    	curr->next=(struct menu_p *)malloc(sizeof(struct menu_p));
X		curr=curr->next;
X	}	
X	curr->next=NULL;
X#ifdef SHOP
X	fid=(XID) XGContextFromGC(gc);
X	xf=XQueryFont(disp, fid);
X	sc=DefaultScreen(disp);
X	white=WhitePixel(disp, sc);
X	black=BlackPixel(disp, sc);	
X#endif
X	curr=head;
X
X}
X
Xlong value_of_craft(dude)
Xsave *dude;
X{
X    int i;
X	int what, pos;
X
X    dude->ship_value=1;
X    for (i=0; i < NUM_ITEMS; i++)
X    {
X        if(dude->state[i]>0)
X        {
X            what=i;
X            pos=dude->quality[i];
X            dude->ship_value += cost_of_item(what,pos);
X        }
X    }
X    for (i=0; i < NO_WEAPONS; i++)
X    {
X        if(dude->does_have_weap[i])
X        {
X            what=i;
X            dude->ship_value += cost_of_weap(what);
X        }
X    }
X    what=LS;
X    dude->ship_value += (dude->ls_max-100)/100*cost_of_item(what,pos);
X    what=RS;
X    dude->ship_value += (dude->rs_max-100)/100*cost_of_item(what,pos);
X    what=BS;
X    dude->ship_value += (dude->bs_max-100)/100*cost_of_item(what,pos);
X    what=ENERGY;
X    dude->ship_value += (dude->energy_max-100)/100*cost_of_item(what,pos);
X	return dude->ship_value;
X}
END_OF_FILE
if test 19508 -ne `wc -c <'shop_stubs.c'`; then
    echo shar: \"'shop_stubs.c'\" unpacked with wrong size!
fi
# end of 'shop_stubs.c'
fi
if test -f 'xmpb.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xmpb.man'\"
else
echo shar: Extracting \"'xmpb.man'\" \(24649 characters\)
sed "s/^X//" >'xmpb.man' <<'END_OF_FILE'
X.TH Xmpb 6
X.SH NAME
Xxmpb \- X Multi Player Blast
X.SH SYPNOSIS
X.in +.5i
X\fIxmpb\fR [-s] [displayname | \-npc name [ \-npcwin displayname]] ...
X.in -.5i
X
X.SH COPYRIGHT NOTICE
X.sp
XXMPB is Copyright (C) 1992-3 by Shane Hyde & Damien De Paoli.  
X.sp
XPermission is given to
Xfreely distribute in a non-modified form.  Any modifications to the source
Xcode may not be distributed without the written consent of the authors.
XOr else we'll get you with the Rail Gun!
X
X
X.SH What is XMPB?
X
XXMPB (X-Multi Player Blast) is a multi-player space combat arcade style
Xgame for X-terms and workstations.  It was written for Sparcstations
Xrunning SunOS 4.1 and using X11R5.  But it has been ported to other
Xsystems including-
X
X    - SCO SYS5 UNIX on Intel based machines
X    - VAX/VMS using DECWindows.
X
X
X.SH About the Authors.
X
XWe are two Computer Science students at Deakin University, Geelong, Australia.
XWe started XMPB while completing our Honours Degree in Computer Science.
X
XBeing bored with all the games already for X-terms, we decided to write our
Xown.  Everyone else out there, do it too!
X
X
X.SH Version 1.0 Changes.
X
X    - Save files.
X	- Hall of fame
X    - Shop.
X    - NPC's and compiler.
X    - better Imakefile.
X    - more weapons.
X    - more consistent qualities of items.
X    - Speed increase.
X    - Clean quitting.
X    - CTRL-C trapping.
X    - Fixed collision routines.
X    - Keys may be configured by resources.
X    - Keys may be used instead of the mouse buttons.
X
X
X.SH Installing XMPB.
X
XThe Imakefile that comes with the source distibution allows for much
Xlocal system dependant setup.
X
XCC should be set to your favourite C-compiler.  Any compiler should work
Xexcept maybe some versions of acc which seems to not like compiling
Xbitmaps.
X
XCFLAGS should be set to whatever flags you like.  We strongly recommend
Xthe best optimisation flags to be set for the compiler, to make the game
Xgo faster.
X
XBINDIR describe the path where the executables will be stored.
X
XMANDIR describes the path where the man page will be installed.
X
XMANSUFFIX sets which part of the manual the man page should be put in
X(6 for games).
X
XBITMAPSDIR contains the directory where the bitmaps are to be installed
Xand loaded by the game.
X
XSAVEDIR contains the directory where all the players' save files are
Xstored.
X
XINSTALLMODS is set to the permissions for the installed executables.  If
Xyou are a system administrator, it is probably best to set these to
Xsetuid.  I know this sounds like a brute force method, but it will allow
Xplayers to be able to load their saved games, regardless of who invoked
Xthe game.  Running without setuid, means that files are owned by the
Xperson running the game, and the default permissions on the save game is
Xread and write for owner only.  This is to prevent peeking at others
Xpasswords.  If you are a user who will be installing the game into your
Xhome directory, and letting your friends have access to it, then you
Xshould also probably leave the permissions the way they are and the
Xfiles will be saved as if you ran the game every time.
X
XOnce you have set all of the variables to the correct settings for your
Xsystem, it is now easy to install Xmpb.
X
X    xmkmf
X    make depend
X    make install
X
X
X.SH The Scenario.
X
XIn the far future, the most popular televised sport is "Blast" a game
Xwhere contestants battle each other in space craft inside an arena in
Xdeep space.
X
XOf course, there are heroes and there are losers.  Your job is to become
Xone of the heroes.
X
X
X.SH The Arena.
X
XThe battles are fought inside an arena, whose walls are provided by strong
Xelectro-magnetic fields.  Touching the "walls" with your ship can cause
Xdamage.  The walls also act as solid objects, "bouncing" yor ship off them.
X
XAlso, the faster you are travelling when you hit a wall, the more damage
Xis incurred.
X
XAlso provided, for added fun, are many rocks of different sizes just
Xright for crashing into.
X
X
X.SH Starting XMPB.
X
XIf you are using X-terms rather than workstations, then you may suffer a
Xlarge performance loss.  This is because this program is very server oriented,
Xmuch of execution time is spent in the server.  Unfortunatley it also seems to
Xrun slower on colour machines :^(
X
XTo get the best performance from the game, the following setup is recommended-
X- The people who want to play all login to seperate workstations.
X- Another machine is chosen to run the game. (e.g. pleb1)
X- Everyone types "xhost pleb1" (some setups may not require this)
X- The person running the game (from pleb1) starts it up by
X
X.nf
X     xmpb gleeb:0.0 nurk:0.0 frob:0.0 foo:0.0 bar:0.0 ...
X.fi
X
XN.B. You might have to use different values instead of 0.0  It all
Xdepends on your setup.
X
XN.Really.B. You should definitely use different names for the displays
Xthan the example ones (unless, of course, you have a machine called
X"gleeb"?)
X
X- It's probably best, if you used xhost before running the game to remove the host from the list of trusted hosts by typing "xhost -pleb1", or else you are subject to roaches, antfarms etc.  :-)
X
X
XAfter starting the game up on different X-terms, each is presented by a
Xprompt in turn-
X
XWhat is your name?
X
XIf you are a new player, type the name of your new character.  You will 
Xthen be asked to give a name to your ship.  After this, you will be asked
Xfor a password, and then asked to retype the password.
X
XIf you already have a character, just type your character's name and your
Xpassword, and you will be welcomed back.
X
XYou will then be presented with 3 windows as described below.
X
X.SH The Main Window.
X
X	The Main Window shows the playfield just around your ship.  You are permenantly in the middle, and will see the world slip by behind you.  There are two planes of stars to give you a good feel of how fast and in what direction you are moving.  The walls appear as lines, these bound your ship into the playing arena.  Oppostion ships, bullets, explosions, debris and clouds of smoke all show up on this window
X
X.SH The Radar Window.
X
X	The Radar Window has two modes.  It'd default is Long Range (which displays a 1x in the bottom left corner).  The Long Range Radar mode requires that you have a working Long Range Radar.  If you do, then you will see your ship as a cross.  The opposition ships, are dots.  The edge of your radar window is where the walls are.  If your Long Range Radar is not 100%, then it will flicker.  The more damaged, then the less you will see the radar.  If you have a targeting computer, and target an opponent, then the targeted ship will be a large cross in the radar window.
X	The second mode of the window is Short Range (which displays a 1x in the bottom left corner).  The Short Range Radar shows the world just around your ship, this shows you always in the middle of the screen.  It makes it easier to target the opposition.   Watch out though as the cheaper radars never show the walls.  Again flickering occurs if you have a dmaged Short Range Radar, and nothing will appear if it is destroyed or you don;t own one.  A targeted ship shows up as a large cross.  The opposition show up as little hollow squares, you show up as a cross (same as in Long Range Radar).  With more expensive Short Range Radars: rocks, clouds, debris, bullets all show up as dots, and walls as lines.  Lasers never show up. 
X
X.SH The Stats Window.
X
X	The Stats Window shows how your ship is going, and is split into four parts.  The top left section shows your shields and energy banks.  These are a simple bar graph, full white is full shields/Energy.  Remember if your shields get to 0, then you take internal damage.  And if your energy is 0, then you can't thrust, shoot, repair e.t.c.
X	The top right gives some stats about your character, its Name, Ship, Credits, how many credits you have earned this game and finally the value of your ship at the start of the game.  (This is used to even out the credits earned, so that if a cheap ship hits an expensive ship, then the cheap ship gets more credits and vice versa). 
X	The Bottom Left shows some details about the items that can be be toggled.  Firstly the current weapon is displayed (by default a Pulse Rifle if you have one), below this is the Status of your weapon.  The status can have three values, Ready - you can shoot your weapon, Loading - you will have to wait until the weapon is ready to fire, and Destroyed, which means that the weapon is destroyed and you had better use another weapon.  If You have no weapons, then the Weapon will be None, and no status will be displayed.
X	Below this is Repair, which shows which item you are repairing currently, including Idle, which means no item is currently being repaired.  If you don't have a repair system, then this line will not appear (BTW - It is foolish to go out without a Repair system).  Below this is targeting  (if you have a TC), this shows the Name of who you are targeting, or Off if no-one is currently being targeted.  Next is Shields Regenerating, this shows whether your shields are regenerating or not (when you need some energy and have high shields, it can be handy to turn shield regenerating off).  Below this (if you have a Jammer), is Jamming: with Off/On beside it, indicating your whether or not you are Jamming.
X	Finally the bottom right shows all your items, that your ship has, and beside it whether they are Okay (at 100%), between 99% and 1% or Destroyed.
X
X.SH Playing the game.
X
XAfter all the players have identified themselves, the game begins.
X
X
X.SH Your ship.
X
XYour ship is a triangular design.  It has 3 electro-magnetic shields, one on the right side, one on the left, and one on the back.  These shields take a long time to charge, but once charged, energy may be move freely between shields or quickly removed from the shields.  Fitted into the nose of your craft are weapons (useful for killing the other players).
X
XYour ship may or may not be fitted with additional items-
X
X- Solar Panels, to recharge energy banks.
X- Long Range radar, to find the enemies that are hiding.
X- Short range radar, a more detailed view.
X- Repair System, obviously only useful if you get hit
X- Engine, for moving the ship around.
X- Targeting computer, to lock seeking weapons onto enemies.
X- Jamming device, to confuse other's radars.
X
XEnergy is the basis for the ships functioning.  If you have no energy, none of the systems will function.
X
X
X.SH Controlling your craft.
X
XAll of the keys used for controlling the ship are configurable using
Xresources. See Configuring Keys below.
X
XThe default keys are as follows-
X
X.nf
Xz - rotate ship anti-clockwise.
Xx - rotate ship clockwise.
Xc - change radar scale (i.e. short range/long range)
Xb - balance the shields. (i.e. balance the shield energy 
X    evenly over the three shields)
Xs - Toggle shield regeneration on/off.  This is useful if 
X    you have poor solar capability and you wish to fire 
X    more quickly.
Xw - toggle the current weapon on/off.  This is useful when 
X    using both firing and change weapon at the same time, 
X    only "on" weapons are used.
Xr - Change item being repaired.  Of course, you must have 
X    a working repair
X    system.
Xt - Change current target.  You must have a functioning 
X    targeting computer.
Xi - Toggle Jamming Device on/off.  The jamming device 
X    prevents other ships from seeing you on their radar.
Xq - Quit.  This effectively acts as a "yield" function.  
X    Note, that there is a penalty for "yielding" in the face 
X    of danger (of 1/3 of your credits that you have EARNED 
X    this game.  You will be removed from the current game 
X    and all of the windows will be closed.  When the last 
X    person leaves the game, the program will exit.
X.fi
X
X.SH Configuring Keys.
X
X	To configure any of the keys used by the program, you need to place the appropriate line in either your .xrdb or .Xdefaults file.  If you don't have one of these files, then make a new one in your home directory.
X
X	e.g. If for instanve you wish to change the key that turns your ship to the left (or anti-clockwise) from an 'x' to an 'l', then put the following line in:
X
X.nf
X	xmpb.turnLeft:	l
X.fi
X
XEach of the resources follows, with a brief description of what the key does.
X
X.nf
X  xmpb.turnRight:	       Turn ship right (or Clock-wise)
X  xmpb.toggleRadar:        Toggles radar between short and 
X                           long range modes
X  xmpb.toggleShieldsRegen: Toggles whether shields 
X                           regenerate or not
X  xmpb.toggleWeaponStatus: Allows a weapon to be turned 
X                           off (or on again)
X  xmpb.changeRepair:       The key to use the repair 
X                           system
X  xmpb.changeTarget:       The key to target another 
X                           combatant
X  xmpb.invisibility:       The key to turn on jamming 
X                           (makes you invisible)	
X  xmpb.quit:               The key quit the game
X  xmpb.grabEnergy:         The key to grab energy from 
X                           your shields and place it 
X                           into your energy banks 
X  xmpb.balanceShields:     The key to balnce shield 
X                           strength
X  xmpb.changeView:         When one dies, this key lets
X                           you see the other combatants.	
X  xmpb.fire:               The key to fire a weapon
X  xmpb.changeWeapon:       The key to change to a new weapon
X  xmpb.thrust:             The key to engage the engines
X.fi
X
XIMPORTANT!!!  If you wish these changes to occur, then you must make your xrdb realise you have made changes.  Type "xrdb .xrdb" or "xrdb .Xdefaults" Whichever is appropriate to your system.  This needs only to be done if you change the .xrdb (or .Xdefaults) file after you have logged in.  So once you have your keys set up, each time you log in and run xmpb, the keys will be configured the way that makes you happy.
X
XN.B.  Special keys such as shift, control e.t.c. are not supported :^(
X
X
XIf you run xmpb with a -s option:
X
X		xmpb -s
X
X	Then a list of all those characters who have been retired is given, in order of most kills, and then most expensive ship.  Followed by a list of the best NPC's in a similar order
X
X
X.SH The Shop.
X
XOk, so you destroyed all of the other players and earned lots of credits.  What do you do with them?  Spend them at the shop and make your ship indestructible.  Or maybe you lost and want to buy a new ship?
X
XEach item has an associated quality rating which describes how good the item generally is.  By spending money, it is possible to improve the quality rating of your ships accesories and to buy new and better weapons.
X
X	Once an item is chosen from the menus, it will be displayed in the left side of the window.  The right hand side shows what items you have.  Pressing the "Show Weapons" button, shows your weapons.  Press again and your items will be redisplayed.
X	The buy button purchases (if you have enough $'s) what is shown in the left window.  
X	To sell or repair one of your items/weapons, select it by clicking on it with the left mouse button.  This will highlight it and give you some details about it.  Then press the sell or repair button. 
X
X
XEngines.
X
XEngine qualities range from 1-9 with the default ship having an engine of quality 3.  The quality of engine describes the acceleration provided by the rockets.  All engines use the same amount of energy.
X
X
XSolar Panels.
X
XSolar panels' qualities range from 1-9.  The default is 2.  The quality describe how quickly solar energy in space is converted and stored in your ships energy banks.
X
X
XRadars.
X
XLong range radars range from 1-9. The quality effects how easily your radar will show up ships that are jamming.
X
XShort range radars range from 1-7.  With 1 showing only ships up to 8 which shows everything down to puffs of dust clouds, even bullets.
X
XAll radars take no energy to run.
X
X
XRepair Systems.
X
XRepair systems range in quality from 1-9.  The quality describe the amount of energy used as well as how quickly repairs are provided by the system.
X
X
XTargeting Computer.
X
XThis accessory allows any targetted weapons to be used.  There is no associated quality.  It takes no energy to run.
X
X
XJamming Device.
X
XThis accesory allows your ship to jam enemies' radars and targeting computers.  If your ship is having seeking weapons fired upon it, using the jamming device will hide you from an enemy's seekers.  The quality of these items range from 2-9. The higher the quality, the 
Xmore confused the opppositions radar will be.  And in close (in your Main Window view) you will see less and less of the ship, throught to camouflage and finally being completely invisible. 
X
X.SH
XWeapons.
X
XThe weapons currently available are -
X
X\fIPulse rifle\fR Default weapon.  Fast firing, small damage, but still
Xnot a weapon to be sneezed at, due to its small energy use.
X
X\fIEnergy Bomb\fR Short Range. Fires fairly quickly. Causes large damage. 
X
X\fISeeker Bomb\fR Long Range. These weapons (with the aid of a targeting 
Xcomputer) will actually seek out and chase an enemy down. High Damage,
Xbut slow firing rate.
X
X\fILight Laser\fR Infinite Range. This weapon will shoot out a beam of light
Xthe whole way across the playing field, instantaneously. The firing rate
Xis reasonably quick, and damage is slightly less than that of an energy 
Xbomb.
X
X\fIRail Gun\fR A fast firing weapon that shoots a very small (and hard to see)
Xprojectile. This weapon has a long range and causes large damage. 
X
X\fIMass Driver\fR A fast firing weapon. This weapon can cause a lot of damage
Xat close range, but at long range is useless. Hence its cheap price.
X
X\fIMine\fR A slow firing rate. This weapon drops a mine from the back of your
Xship. These mines last for a long time and detonate on any who run over
Xthem.  Damage is very, very large.
X
X\fIHeavy Laser\fR Similar to light laser, only more damage, and three beams 
Xinstead on one.
X
X\fIAtomic Spray\fR Short Range. Very fast fire rate. Good in close.
X
X\fIHeavy Pulse Rifle\fR Just like a pulse rifle only nastier.
X
X\fIMagneto Disk(T)\fR A long range seeking weapon. This one has a superior
Xtracking algorithm. And won't miss unless you run away really fast.
XLots of damage.
X
X\fIBlack Death\fR A very short lived, short range weapon. But it does heaps
Xof damage. 
X
X	
X.SH NPC's (Non Playing Characters)
X
XIf you don't have any friends, or they're all home studying, then play
Xagainst one or more of the NPC's provided.
X
X	To set up the game with npcs in it:
X
X        xmpb gleeb:0.0 nurk:0.0 -npc basic  
X
X	This will let two windows appear and one npc (called basic) which
X	will happily attempt to kill you.
X
X		xmpb -npc basic -npcwin gleeb:0.0 -npc nasty -npc killer -npc nurk:0.0
X
X	This configuration will allow the npc basic to be seen on gleeb's display.  The full set of main, radar and stats windows show exactly what basic is doing.  (This is useful when programming npc's just to see what they are doing.  And of course if you just want to write a better npc than your mates.) Along with basic, will be nasty and killer.  And again, killer will be shown of nurk's display.
X
X	Any mix of these parameters is possible.
X
X	xmpb -npc basic gleeb:0.0 -npc nasty -npcwin frob:0.0 nurk:0.0 -npc killer
X
X	Would allow to people to play with their ships (on displays gleeb and nurk).  Along with three npcs: basic, nasty and killer.  Also nasty will be seen on frob's display.
X
X.nf
X    The current NPCs are:
X
X        basic:   Has the same ship as a player just starting
X        average: A ship for those who have won 4 or 5 games. 
X        nasty:   A real nasty NPC.  A good ship and lots 
X                 of firepower.
X        ml:      A stupid mine layer
X        ml2:     An old (and bad) attempt to ram people. A 
X                 good ship tho' 
X        john:    A tough ship.  Don't take it out unless 
X                 you have a real good ship.
X        harry:   simliar to basic.
X        beam:    see john.
X        rad1:    similar to basic
X        rad2:    Better ship, but still only a pulse rifle
X        rad3:    In the league of nasty
X        
X
X.SH Playing Tips (From the masters :-)
X
X- Don't spend all of your money as soon as you get it.  Or else, when you get nailed, you'll be out.  It's better to have some money as backup in case you get beaten, and have to buy a new ship.
X
X
X.SH SEE ALSO
Xshop(6),describe(6),retire(6),npcc(6)
X.SH BUGS
X
XBugs, what's a bug? :-)
X
XSome versions of X-servers don't like the way we put bitmaps on the
Xhidden buffer.  This results in the stars, rocks etc. being shown as
Xinverted (black pic inside a white sqaure).  if this happens to you,
Xthen change GXxor in line ??? in add_host.c to GXand and recompile.
XThis will fix this problem.  We can't code it like this, though, because
Xusing this reverses them on our displays.  Oh well, some incompatibilty
Xmaybe?  It seems to be on HP machines.
X
XSome servers do not clip lines outside the window, instead showing no
Xpart of the line at all.  This means that lasers and and walls of the
Xarena will not be displayed.  Again this is a deficiency of the servers,
Xwhich we haven't figured out which vendor yet.
X
X
X.SH Acknowledgements.
X
XThanks to everyone who responded to the posting of version 0.85.  The
Xresponse was fantastic.  There was obviously enough positive response
Xto warrant finishing this game off.
X
XSpecial thanks to the following people who provided code fragments and
Xfixes -
X
X.nf
XG Ferguson  Imakefile, original man page
X            Patches for bitmap directory.
X            Patches for color displays.
Xmuzzle      Finding out the inverted bm fix.
X.fi
X
XAnd lastly, to all the people who playtested the game and gave us their
Xsuggestions and some extra NPC's
X
X.nf
XEspecially:
X	Robert Dew
X	Michael Hobbs
X	Stephen Larcombe
X	Greg Whickham
X.fi
X
X.SH AUTHORS
XShane Hyde
XDamien De Paoli
X.SH SEE ALSO
Xshop(6),describe(6),retire(6),npcc(6)
X.SH BUGS
X
XBugs, what's a bug? :-)
X
XSome versions of X-servers don't like the way we put bitmaps on the
Xhidden buffer.  This results in the stars, rocks etc. being shown as
Xinverted (black pic inside a white sqaure).  if this happens to you,
Xthen change GXxor in line ??? in add_host.c to GXand and recompile.
XThis will fix this problem.  We can't code it like this, though, because
Xusing this reverses them on our displays.  Oh well, some incompatibilty
Xmaybe?  It seems to be on HP machines.
X
XSome servers do not clip lines outside the window, instead showing no
Xpart of the line at all.  This means that lasers and and walls of the
Xarena will not be displayed.  Again this is a deficiency of the servers,
Xwhich we haven't figured out which vendor yet.
X
X
X.SH Acknowledgements.
X
XThanks to everyone who responded to the posting of version 0.85.  The
Xresponse was fantastic.  There was obviously enough positive response
Xto warrant finishing this game off.
X
XSpecial thanks to the following people who provided code fragments and
Xfixes -
X
X.nf
XG Ferguson  Imakefile, original man page
X            Patches for bitmap directory.
X            Patches for color displays.
Xmuzzle      Finding out the inverted bm fix.
X.fi
X
XAnd lastly, to all the people who playtested the game and gave us their
Xsuggestions and some extra NPC's
X
X.nf
XEspecially:
X	Robert Dew
X	Michael Hobbs
X	Stephen Larcombe
X	Greg Whickham
X.fi
X
X.SH AUTHORS
XShane Hyde
XDamien De Paoli
X.SH SEE ALSO
Xshop(6),describe(6),retire(6),npcc(6)
X.SH BUGS
X
XBugs, what's a bug? :-)
X
XSome versions of X-servers don't like the way we put bitmaps on the
Xhidden buffer.  This results in the stars, rocks etc. being shown as
Xinverted (black pic inside a white sqaure).  if this happens to you,
Xthen change GXxor in line ??? in add_host.c to GXand and recompile.
XThis will fix this problem.  We can't code it like this, though, because
Xusing this reverses them on our displays.  Oh well, some incompatibilty
Xmaybe?  It seems to be on HP machines.
X
XSome servers do not clip lines outside the window, instead showing no
Xpart of the line at all.  This means that lasers and and walls of the
Xarena will not be displayed.  Again this is a deficiency of the servers,
Xwhich we haven't figured out which vendor yet.
X
X
X.SH Acknowledgements.
X
XThanks to everyone who responded to the posting of version 0.85.  The
Xresponse was fantastic.  There was obviously enough positive response
Xto warrant finishing this game off.
X
XSpecial thanks to the following people who provided code fragments and
Xfixes -
X
X.nf
XG Ferguson  Imakefile, original man page
X            Patches for bitmap directory.
X            Patches for color displays.
Xmuzzle      Finding out the inverted bm fix.
X.fi
X
XAnd lastly, to all the people who playtested the game and gave us their
Xsuggestions and some extra NPC's
X
X.nf
XEspecially:
X	Robert Dew
X	Michael Hobbs
X	Stephen Larcombe
X	Greg Whickham
X.fi
X
X.SH AUTHORS
XShane Hyde
XDamien De Paoli
END_OF_FILE
if test 24649 -ne `wc -c <'xmpb.man'`; then
    echo shar: \"'xmpb.man'\" unpacked with wrong size!
fi
# end of 'xmpb.man'
fi
echo shar: End of archive 2 \(of 8\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
