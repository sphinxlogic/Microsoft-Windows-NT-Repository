Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i006:  xmpb - multiplayer space combat for X, Part06/08
Date: 26 Jun 1993 00:32:56 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2826
Approved: billr@saab.CNA.TEK.COM
Message-ID: <20g5fo$6sp@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1796

Submitted-by: ddp@deakin.edu.au (Damien De Paoli)
Posting-number: Volume 18, Issue 6
Archive-name: xmpb/Part06
Environment: X11, Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 8)."
# Contents:  Imakefile average.npc basic.npc bitmaps/ship.0 bits.c
#   damage_ship.c disp_ship.c lex.l ml.npc nasty.npc polygon.c
#   rad1.npc shop.man
# Wrapped by billr@saab on Fri Jun 25 16:30:15 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(3251 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X#   @(#)Imakefile 1.29 93/06/03 XMPB  
X#
X
X# Change these to change the installation targets
X
XBLASTDIR = /home/ddp/blast 
X
XNPCDIR = $(BLASTDIR)/npc
XBINDIR = $(BLASTDIR)/bin
XSAVEDIR = $(BLASTDIR)/save
XBITMAPDIR = $(BLASTDIR)/bitmaps
X
XMANSUFFIX = 6
XMANDIR = $(BLASTDIR)/man/man$(MANSUFFIX)
X
XEXTRA_LOAD_FLAGS =
XINSTALLMODS = 4755
XYACC = yacc
XLEX = lex
X
XINSTPGMFLAGS = -m $(INSTALLMODS) -o bin -g bin
X
X# If you have a NCD or HP, then remove the # on the next line 
X# NCDFLAG = -DNCD 
X
X# Adjust if default is unsuitable
XCC = cc 
X# Adjust for debugging or optimization relative to the default
XCDEBUGFLAGS = -DBITMAPDIR="\"$(BITMAPDIR)/\"" -DSAVEDIR="\"$(SAVEDIR)/\"" -DNPCDIR="\"$(NPCDIR)/\"" $(NCDFLAG) -O2 
X
X# Adjust if necessary
XMATHLIB = -lm
XMKDIRHIER = /usr/X11/bin/mkdirhier
X
X
X###############################
X# Nothing to change below here
X
XSRCS = xoutput.c read_ship.c test.c disp_ship.c handle_ev.c add_host.c \
X	update_win.c thrust.c ud_win.c do_stars.c radar.c stats.c weapon.c \
X	error.c polygon.c damage_ship.c update_ships.c junk.c input.c \
X	sintab.c costab.c calc_shields.c pcomp.c collide.c 
XOBJS = xoutput.o read_ship.o test.o disp_ship.o handle_ev.o add_host.o \
X	update_win.o thrust.o ud_win.o do_stars.o radar.o stats.o weapon.o \
X	error.o polygon.o damage_ship.o update_ships.o junk.o input.o \
X	sintab.o costab.o calc_shields.o pcomp.o collide.o 
X
XBMAPS = bitmaps/bigrock bitmaps/bomb bitmaps/cloud.1 bitmaps/cloud.2 \
X	bitmaps/cloud.3 bitmaps/cloud.4 bitmaps/cloud.5 bitmaps/cloud.6 \
X	bitmaps/debris.1 bitmaps/debris.2 bitmaps/debris.3 bitmaps/massdrive \
X	bitmaps/medrock bitmaps/mine bitmaps/pulse bitmaps/rail \
X	bitmaps/saturn1 bitmaps/seeker bitmaps/shortdeaddude bitmaps/smallrock \
X	bitmaps/star1 bitmaps/star2 bitmaps/stipple bitmaps/atom bitmaps/hvypulse \
X	bitmaps/magneto bitmaps/dunno bitmaps/dunno2
X
XNPCS = ml ml2  beam harry basic average nasty john rad1 rad2 rad3
X
XLOCAL_LIBRARIES = $(XLIB) $(MATHLIB)
X
X/* AllTarget(install install.man) */
XAllTarget(xmpb shop npcc retire describe clear_lock)
XComplexProgramTarget(xmpb) 
XSingleProgramTarget(retire,retire.o save_load.o,,)
XSingleProgramTarget(describe,describe.o save_load.o,,)
XSingleProgramTarget(npcc,lex.yy.o y.tab.o,,-ll)
XSingleProgramTarget(clear_lock,clear_lock.c save_load.o,,)
XSingleProgramTarget(shop,shop_ui.o shop_stubs.o save_load.o,-L$(OPENWINHOME)/lib,-lxview -lolgx -lX11)
XInstallProgram(shop,$(BINDIR))
XInstallProgram(retire,$(BINDIR))
XInstallProgram(describe,$(BINDIR))
XInstallProgram(npcc,$(BINDIR))
XInstallManPage(retire,$(MANDIR))
XInstallManPage(describe,$(MANDIR))
XInstallManPage(shop,$(MANDIR))
X/* InstallManPage(xmpb,$(MANDIR)) */
XInstallManPage(npcc,$(MANDIR))
XMakeDirectories(install,$(SAVEDIR) $(NPCDIR))
XInstallMultipleDestFlags(install,$(BMAPS),$(BITMAPDIR),-m 0644)
X#
X#
X#	Rules for stuff imake doesn't know
X#
X
Xlex.yy.o: lex.yy.c y.tab.c
Xlex.yy.c: lex.l
X	$(LEX) lex.l
Xy.tab.c: parse.y
X	$(YACC) -d parse.y
Xclean::
X	$(RM) lex.yy.c y.tab.c y.tab.h
X
Xnpcs::
X	npcc $(NPCS)
X
Xinstall:: install.man
X	cp shop.contents $(BITMAPDIR)
X	chmod 644 $(BITMAPDIR)/shop.contents
X	chmod 755 $(BLASTDIR)
X	chmod 755 $(BINDIR) 
X	chmod 755 $(MANDIR)
X	chmod 755 $(MANDIR)/..
X	chmod 755 $(SAVEDIR)
X	chmod 755 $(NPCDIR)
X	chmod 700 $(BITMAPDIR)
X
Xinstall:: 
X	npcc $(NPCS)
END_OF_FILE
if test 3251 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'average.npc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'average.npc'\"
else
echo shar: Extracting \"'average.npc'\" \(4765 characters\)
sed "s/^X//" >'average.npc' <<'END_OF_FILE'
XNPC
XName = Average
XShip = Dull
XEnergyMax = 1100
XLShieldMax = 700
XRShieldMax = 700
XBShieldMax = 600
XSolar = 4
XShortRange = 2
XEngine = 4
XRepair = 6
XLongRange = 2
XJammer = 2
XTC = 3
X
XWeapons
XPulse
XHPulse
XSeek
X
Xvar
Xend
X
XState avoid
X{
Xvar
X	count
X	tmp
X	lastDist
Xend
X
X	lastDist=EnemyDist;
X	set B1 =0;
X	if(SolarState < 100)
X		set RepairSelectedItem=Solar;
X	else
X	if(EngineState < 100)
X		set RepairSelectedItem=Engine;
X	else
X		set RepairToggle = 1;
X	count = 15;
X	while(count)
X	{
X		tmp = EnemyDist;
X		if(tmp && tmp >= lastDist) -> loop;
X		if(!tmp)
X		{
X			slow();
X			-> loop;
X		}
X		set B3 =1;
X		if(EnemyAngle > 0 && EnemyAngle < 180)
X			set TurnTo=(EnemyAngle+ 90)%360;
X		else
X			set TurnTo=(EnemyAngle- 90)%360;
X		wall_check();
X		count = count - 1;
X	}
X	slow();
X	-> loop;
X}
X
XProc wall_check
X{
Xvar
X	r
X	l
X	u
X	d
Xend
X
X	r = 0;
X	l = 0;
X	u = 0;
X	d = 0;
X
X	if (XPos*XVel > 45000 && XVel > 0) r = 1;
X	if (XPos*XVel > 45000 && XVel < 0) l = 1;
X	if (YPos*YVel > 45000 && YVel > 0) u = 1;
X	if (YPos*YVel > 45000 && YVel < 0) d = 1;
X
X	if (r || l || u || d) slow();
X	return;
X}
X
XProc att_check
X{
Xvar
X    num
Xend
X
X	num=NumEnemies;
X	set Target = 1;
X	set SelectEnemy = 0;
X	set Target= 1;
X	set RepairToggle = 1;
X	set Balance = 1;
X	wall_check();
X
X	if(! EnemyAvail)
X	{
X		set B1 = 0;
X		set B3 = 0;
X		return;
X	}
X
X	if(Energy < 200 && LShield > 400 && EnemyDist < 600)
X	{
X		set Grab =1;
X		set RepairToggle =1;
X	}
X
X	if(Speed > 40) slow();
X	
X	return;
X}
X
XProc attack
X{
Xvar
X	a1
X	a2
X	m
X	a
X	p
X	cnt
X	count
Xend
X
X	
X	a2 = EnemyAngle;
X	set B2 =1;
X	count = 10;
X	while(EnemyDist < 1000)
X	{
X
X		a1 = a2;
X		a2 = EnemyAngle;
X	
X		m = EnemyDist/50 - 1;	
X		if(EnemyDist > 500)
X		{
X 			a = AngleTo(EnemyXPos+m*EnemyXVel - m*XVel,EnemyYPos+m*EnemyYVel - m*YVel);
X        	p = (Angle - a + 360)%360;
X        	if(p < 170 || p > 190)
X                set TurnTo = a;
X		}
X		else
X			set TurnTo = (EnemyAngle + (a2 - a1)*(EnemyDist/175)) % 360;
X
X
X		m = 93 - (EnemyDist)/12;
X		if((EnemyDist < 900) && Angle <= (EnemyAngle+ m) && Angle >= (EnemyAngle - m))
X			set B1 = 1; 
X		else
X			set B1 = 0;
X
X		set Balance = 1;
X		if(RepairItem != LongRange)
X			set RepairToggle = 1;
X		if(Direction - Angle > 90 || Direction - Angle < 90 && Energy > 200)
X		{
X			set B3 = 1;
X			cnt = 3;
X			while(cnt>0)
X				cnt=cnt- 1;
X			set B3 = 0;
X		}
X		count = count - 1;
X		if (!count)
X		{
X			att_check();
X			if(LongState < 50) return;
X			count = 10;
X		}		
X	}
X	set B1 = 0;
X	set B3 = 0;
X	return;
X}
X
XState repair
X{
Xvar
X	tmp
Xend
X
X	set Jamming =1;
X	if(LongState < 100 && LongState > 0)
X		set RepairSelectedItem = LongRange;
X	else
X	if(EngineState < 100 && EngineState > 0 )
X		set RepairSelectedItem = Engine;
X	else
X	if(SolarState < 100 && SolarState > 0)
X		set RepairSelectedItem = Solar;
X	else
X	if(RepairState < 100 && RepairState > 0)
X		set RepairSelectedItem = Repair;
X	else
X	if(ShortState < 100 && ShortState >0)
X		set RepairSelectedItem = ShortRange;
X	else
X		set RepairToggle = 1;
X	tmp = EnemyDist;
X	if(tmp && tmp < 1000) 
X		-> avoid;
X	if(EngineState > 30 && Speed > 10) slow();
X	if(LongState > 80 && EngineState > 60) -> loop;
X	if(!LongState)
X		set Quit =1;
X	set Balance = 1;
X	aim();
X}
X
XProc aim
X{
Xvar
X	aa1
X	aa2
X	num
Xend
X	num = NumEnemies;
X	set Target = 1;
X	set SelectEnemy = 0;
X	set Target= 1;
X
X	aa1 = aa2;
X	aa2 = EnemyAngle;
X	if(aa2 == -1)
X		aa2 = aa1;
X	else
X		set TurnTo = (EnemyAngle + (aa2 - aa1) * 4) % 360;
X
X	if(EnemyDist < 1000 && EnemyDist > 0) attack();
X	return;
X}
X
XProc slow
X{
Xvar
X	oldbs
Xend
X
X	set B1 = 0;
X	set TurnTo = (Direction + 180) % 360;
X	set B3 =1;
X	oldbs= BShield;
X	while(Speed > 5 && BShield >= oldbs)
X	{
X		set TurnTo = (Direction + 180) % 360;
X		if(EnemyDist < 500 && EnemyDist)
X		{
X			attack();
X			return;
X		}
X	}
X	set B3 =0;
X	return;
X}
X
XProc wait
X{
Xvar w
Xend
X
X	set B3 =0;
X	w = 5;
X	while (w)
X	{
X		aim();
X		if ((Direction < (Angle + 10)) && (Direction > (Angle - 10)))
X			return;
X		w = w - 1;
X	}
X	set B3 =1;
X
X	return;
X}
X
XProc seek
X{
Xvar 
X	tmp
Xend
X
X	if(!NumEnemies) 
X		return 0;	
X	set SelectEnemy = 0;
X	set Target= 1;
X
X	aim();
X	if(EnemyDist < 2000)
X	{
X		while(CurrWeap != Seek)
X			set B2 =1;
X		set B2 =0;
X		set B1=1;
X		set Target = 1;
X	}
X	else
X		set B1 =0;
X	tmp = EnemyDist;
X	if(EnemySpeed > 30 && tmp > 800 && tmp && tmp) return 1;
X
X	if(EnemyDist < 1000 && EnemyDist) attack();
X	if(Energy < 200 || LongState < 70) 
X	{
X		set B3 =0;
X		return 0;
X	} 
X	else set B3 =1;
X	if (Speed > 20 && (Direction < (Angle + 10)) && (Direction > (Angle - 10))) wait();
X	if (Speed > 30)
X		set B3 =0;
X	return 0;
X}
X
XState loop
X{
X	if(seek())
X		1 -> avoid;
X	if(RepairItem == Idle)
X		set RepairToggle = 1;
X	set Balance= 1;
X
X	if(LongState == -1)
X		set RadarChange = 1;
X
X	if (Speed > 30 && EnemyDist < 2000)  slow();
X	if(!LongState)
X		set Quit =1;
X	if (LongState < 50) 
X	{
X		slow();
X		1 -> repair;
X	}
X}
X
XState main
X{
X	set B2 = 1;
X	set B3 = 1; 
X	-> loop;
X}
X
XStart main
END_OF_FILE
if test 4765 -ne `wc -c <'average.npc'`; then
    echo shar: \"'average.npc'\" unpacked with wrong size!
fi
# end of 'average.npc'
fi
if test -f 'basic.npc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'basic.npc'\"
else
echo shar: Extracting \"'basic.npc'\" \(4611 characters\)
sed "s/^X//" >'basic.npc' <<'END_OF_FILE'
XNPC
XName = Basic
XShip = Standard
XEnergyMax = 1000
XLShieldMax = 600
XRShieldMax = 600
XBShieldMax = 400
XSolar = 2
XShortRange = 1
XEngine = 3
XRepair = 2
XLongRange = 1
XJammer = none
XTC = none
X
XWeapons
XPulse
X
Xvar
Xend
X
XState avoid
X{
Xvar
X	count
X	tmp
X	lastDist
Xend
X
XEntry
X{
X	lastDist=EnemyDist;
X	set B1 =0;
X	if(SolarState < 100 && SolarState >0)
X		set RepairSelectedItem=Solar;
X	else
X	if(EngineState < 100 && EngineState >0)
X		set RepairSelectedItem=Engine;
X	else
X		set RepairToggle = 1;
X	count = 15;
X	WaitFrame;
X}
X	if(count)
X	{
X		tmp = EnemyDist;
X		if(tmp && tmp >= lastDist) -> loop;
X		if(!tmp)
X		{
X			slow();
X			-> loop;
X		}
X		set B3 =1;
X		if(EnemyAngle > 0 && EnemyAngle < 180)
X			set TurnTo=(EnemyAngle+ 90)%360;
X		else
X			set TurnTo=(EnemyAngle- 90)%360;
X		wall_check();
X		count = count - 1;
X	}
X	else
X	{
X		slow();
X		-> loop;
X	}
X}
X
XProc wall_check
X{
X	if (XPos*XVel > 45000) return 1;
X	if (YPos*YVel > 45000) return 1;
X	return 0;
X}
X
XProc att_check
X{
X
X	NumEnemies;
X	set SelectEnemy = 0;
X	set RepairToggle = 1;
X	set Balance = 1;
X	wall_check();
X
X	if(! EnemyAvail)
X	{
X		set B1 = 0;
X		set B3 = 0;
X		return;
X	}
X
X	if(Energy < 200 && LShield > 400 && EnemyDist < 600)
X	{
X		set Grab =1;
X		set RepairToggle =1;
X	}
X
X	if(Speed > 40) slow();
X	
X	return;
X}
X
XProc attack
X{
Xvar
X	a1
X	a2
X	m
X	a
X	p
X	cnt
X	count
Xend
X
X	
X	a2 = EnemyAngle;
X	count = 10;
X	while(EnemyDist < 1000)
X	{
X
X		a1 = a2;
X		a2 = EnemyAngle;
X	
X		m = EnemyDist/(50+VelAtAngle(Angle)) - 1;	
X		if(EnemyDist > 500)
X		{
X 			a = AngleTo(EnemyXPos+m*EnemyXVel - m*XVel,EnemyYPos+m*EnemyYVel - m*YVel);
X        	p = (Angle - a + 360)%360;
X        	if(p < 170 || p > 190)
X                set TurnTo = a;
X		}
X		else
X			if(EnemyAngle > 300)
X				set TurnTo = (EnemyAngle + (a2 - a1)*(EnemyDist/150)) % 360;
X			else
X				set TurnTo = (EnemyAngle + (a2 - a1)*(EnemyDist/120)) % 360;
X
X
X		m = 40 - (EnemyDist)/30;
X		if((EnemyDist < 900) && Angle <= (EnemyAngle+ m) && Angle >= (EnemyAngle - m))
X			set B1 = 1; 
X		else
X			set B1 = 0;
X
X		set Balance = 1;
X		if(RepairItem != LongRange)
X			set RepairToggle = 1;
X		if((Direction - Angle > 90 || Direction - Angle < 90) && Energy > 200)
X		{
X			set B3 = 1;
X			cnt = 3;
X			while(cnt>0)
X				cnt=cnt- 1;
X			set B3 = 0;
X		}
X		count = count - 1;
X		if (!count)
X		{
X			att_check();
X			if(LongState < 50) return;
X			count = 10;
X		}		
X	}
X	set B1 = 0;
X	set B3 = 0;
X	return;
X}
X
XProc repair_which
X{
X	if(LongState < 100 && LongState > 0)
X		set RepairSelectedItem = LongRange;
X	else
X	if(EngineState < 100 && EngineState > 0 )
X		set RepairSelectedItem = Engine;
X	else
X	if(SolarState < 100 && SolarState > 0)
X		set RepairSelectedItem = Solar;
X	else
X	if(RepairState < 100 && RepairState > 0)
X		set RepairSelectedItem = Repair;
X	else
X	if(ShortState < 100 && ShortState >0)
X		set RepairSelectedItem = ShortRange;
X	else
X		set RepairToggle = 1;
X	return;
X}
X
XState repair
X{
Xvar
X	tmp
Xend
X
X	if(!LongState && !ShortState && !CurrWeapState)
X		set Quit = 1;
X	repair_which();
X	tmp = EnemyDist;
X	if(tmp && tmp < 1000) -> avoid;
X	if(EngineState > 30 && Speed > 10) slow();
X	if(LongState > 80 && EngineState > 60) -> loop;
X	set Balance = 1;
X	aim();
X}
X
XProc aim
X{
Xvar
X	aa1
X	aa2
X	num
Xend
X	num = NumEnemies;
X	set SelectEnemy = 0;
X
X	aa1 = aa2;
X	aa2 = EnemyAngle;
X	if(aa2 == -1)
X		aa2 = aa1;
X	else
X		set TurnTo = (EnemyAngle + (aa2 - aa1) * 4) % 360;
X
X	if(EnemyDist < 1000 && EnemyDist > 0) attack();
X	return;
X}
X
XProc slow
X{
Xvar
X	oldbs
Xend
X
X	set B1 = 0;
X	set TurnTo = (Direction + 180) % 360;
X	set B3 =1;
X	oldbs= BShield;
X	while(Speed > 5 && BShield >= oldbs)
X	{
X		if(!LongState && !ShortState && !CurrWeapState)
X			set Quit = 1;
X		set TurnTo = (Direction + 180) % 360;
X		if(EnemyDist < 500 && EnemyDist)
X		{
X			attack();
X			return;
X		}
X	}
X	set B3 =0;
X	return;
X}
X
XProc wait
X{
Xvar w
Xend
X
X	set B3 =0;
X	w = 5;
X	while (w)
X	{
X		aim();
X		if ((Direction < (Angle + 10)) && (Direction > (Angle - 10)))
X			return;
X		w = w - 1;
X	}
X	set B3 =1;
X	return;
X}
X
XProc seek
X{
Xvar 
X	tmp
Xend
X
X	if(!LongState && !ShortState && !CurrWeapState)
X		set Quit = 1;
X	if(!NumEnemies) 
X		return 0;	
X	set SelectEnemy = 0;
X
X	aim();
X
X	tmp = EnemyDist;
X	if(EnemySpeed > 30 && tmp > 800 && tmp && tmp) return 1;
X
X	if(EnemyDist < 1000 && EnemyDist) attack();
X	if(Energy < 200 || LongState < 70) 
X	{
X		set B3 =0;
X		return 0;
X	} 
X	else set B3 =1;
X	if (Speed > 6 && (Direction < (Angle + 10)) && (Direction > (Angle - 10))) wait();
X	if (Speed > 15)
X		set B3 =0;
X	return 0;
X}
X
XState loop
X{
X	if(seek())
X		-> avoid;
X	if(RepairItem == Idle)
X		repair_which();
X	set Balance= 1;
X
X	if (Speed > 30 && EnemyDist < 2000)  slow();
X	if (LongState < 50) 
X	{
X		slow();
X		-> repair;
X	}
X}
X
XState main
X{
X	set B2 = 1;
X	-> loop;
X}
X
XStart main
END_OF_FILE
if test 4611 -ne `wc -c <'basic.npc'`; then
    echo shar: \"'basic.npc'\" unpacked with wrong size!
fi
# end of 'basic.npc'
fi
if test -f 'bitmaps/ship.0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/ship.0'\"
else
echo shar: Extracting \"'bitmaps/ship.0'\" \(4127 characters\)
sed "s/^X//" >'bitmaps/ship.0' <<'END_OF_FILE'
X#define ship0_width 61
X#define ship0_height 81
Xstatic char ship0_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
X   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04,
X   0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x08, 0x04, 0x00, 0x00,
X   0x00, 0x00, 0x04, 0x02, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x42,
X   0x08, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x11, 0x41, 0x10, 0x11, 0x00, 0x00,
X   0x00, 0x00, 0x11, 0xa1, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x11, 0xa1,
X   0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x91, 0xa0, 0x20, 0x11, 0x00, 0x00,
X   0x00, 0x00, 0x91, 0x10, 0x21, 0x11, 0x00, 0x00, 0x00, 0x00, 0x91, 0x10,
X   0x21, 0x11, 0x00, 0x00, 0x00, 0x00, 0x51, 0x10, 0x41, 0x11, 0x00, 0x00,
X   0x00, 0x00, 0x51, 0x08, 0x42, 0x11, 0x00, 0x00, 0x00, 0x00, 0x51, 0x08,
X   0x42, 0x11, 0x00, 0x00, 0x00, 0x00, 0x31, 0x08, 0x82, 0x11, 0x00, 0x00,
X   0x00, 0x00, 0x31, 0x04, 0x84, 0x11, 0x00, 0x00, 0x00, 0x00, 0x31, 0xfc,
X   0x87, 0x11, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x11, 0x00, 0x00,
X   0x00, 0x00, 0x11, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00,
X   0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x12, 0x00, 0x00,
X   0x00, 0x00, 0x09, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00,
X   0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x14, 0x00, 0x00,
X   0x00, 0x00, 0x05, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
X   0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x18, 0x00, 0x00,
X   0x00, 0x00, 0x03, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
X   0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00,
X   0x00, 0x00, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
X   0x00, 0x10, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x20, 0x04, 0x00,
X   0x00, 0x8c, 0x00, 0x00, 0x00, 0x20, 0x06, 0x00, 0x00, 0x94, 0x00, 0x00,
X   0x00, 0x20, 0x05, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0xc0, 0x04, 0x00,
X   0x00, 0x44, 0x00, 0x00, 0x00, 0x40, 0x04, 0x00, 0x00, 0x84, 0x00, 0x00,
X   0x00, 0x20, 0x04, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x20, 0x04, 0x00,
X   0x00, 0x04, 0x01, 0x00, 0x00, 0x10, 0x04, 0x00, 0x00, 0x04, 0x02, 0x00,
X   0x00, 0x08, 0x04, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x08, 0x04, 0x00,
X   0x00, 0xc4, 0xff, 0xff, 0xff, 0x7f, 0x04, 0x00, 0x00, 0x24, 0x00, 0x00,
X   0x00, 0x80, 0x04, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x80, 0x04, 0x00,
X   0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x0c, 0x00, 0x00,
X   0x00, 0x00, 0x06, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
X   0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 4127 -ne `wc -c <'bitmaps/ship.0'`; then
    echo shar: \"'bitmaps/ship.0'\" unpacked with wrong size!
fi
# end of 'bitmaps/ship.0'
fi
if test -f 'bits.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bits.c'\"
else
echo shar: Extracting \"'bits.c'\" \(3067 characters\)
sed "s/^X//" >'bits.c' <<'END_OF_FILE'
Xextern int euid;
X
Xparse_shop_contents()
X{
X	FILE *fp;
X	char fname[160];
X	int retn, i, menu_done;
X	
X	fname[0]=0;
X	if(installed)
X		strcpy(fname, BITMAPDIR);
X	else
X		strcpy(fname, "./");
X	strcat(fname, "shop.contents");
Xseteuid(euid);
X	fp=fopen(fname,"r");	
Xseteuid(getuid());
X	if(fp==NULL) {
X		fprintf(stderr,"No data file: %s\n", fname);
X		exit(0);
X	}
X
X	curr= (struct menu_p *) malloc(sizeof(struct menu_p));
X	head=curr;
X
X	retn=1;
X	while(retn) {
X		fgets(curr->menu_name, 40, fp);
X		curr->menu_name[strlen(curr->menu_name)-1]=0;
X
X		menu_done=0;
X		i=0;
X		while(!menu_done && retn) {
X			retn=(int)fgets(curr->menu_item[i], 40, fp);
X			if(retn) {
X				curr->menu_item[i][strlen(curr->menu_item[i])-1]=0;
X				if(!strncmp("###",curr->menu_item[i],3)) {
X					menu_done=1;
X				}
X				else {
X					fscanf(fp, "%[^$]%*c%d%*c", curr->descr[i], &(curr->cost[i]));
X				}
X				i++;
X			}
X		}
X    	curr->next=(struct menu_p *)malloc(sizeof(struct menu_p));
X		curr=curr->next;
X	}	
X	curr->next=NULL;
X	curr=head;
X}
X
Xvalue_of_craft(dude)
Xwinptr dude;
X{
X    int i;
X	int what,pos;
X
X    dude->ship_value=1;
X    for (i=0; i < NUM_ITEMS; i++)
X    {
X        if(dude->state[i]>0)
X        {
X            what=i;
X            pos=dude->quality[i];
X            dude->ship_value += cost_of_item(dude, what, pos);
X        }
X    }
X    for (i=0; i < NO_WEAPONS; i++)
X    {
X        if(dude->does_have_weap[i])
X        {
X            what=i;
X            dude->ship_value += cost_of_weap(dude, what);
X        }
X    }
X    what=LS;
X    dude->ship_value += (dude->ls_max-100)/100*cost_of_item(dude, what, pos);
X    what=RS;
X    dude->ship_value += (dude->rs_max-100)/100*cost_of_item(dude, what, pos);
X    what=BS;
X    dude->ship_value += (dude->bs_max-100)/100*cost_of_item(dude, what, pos);
X    what=ENERGY;
X    dude->ship_value += (dude->energy_max-100)/100*cost_of_item(dude, what, pos);
X	return dude->ship_value;
X}
X
Xint cost_of_item(dude,what,pos)
Xwinptr dude;
Xint what,pos;
X{
Xstruct menu_p *curr;
X
X	curr=head;
X	if(what==ENGINE) {
X		return (curr->cost[dude->quality[ENGINE]-1]);
X	}
X	curr=curr->next;
X	if(what==SOLAR) {
X		return (curr->cost[dude->quality[SOLAR]-1]);
X    }
X    curr=curr->next;
X    if(what==SHORTRR || what==LONGRR) {
X		if(what==SHORTRR)
X		{
X			return (curr->cost[dude->quality[SHORTRR]+NUMLRADS-1]);	
X		}
X		else
X		{
X			return (curr->cost[dude->quality[LONGRR]-1]);
X		}
X    }
X    curr=curr->next->next;
X    if(what==REPAIR) {
X		return (curr->cost[dude->quality[REPAIR]-1]);
X    }
X    curr=curr->next;
X	if(what==TC) {
X		return (curr->cost[0]);
X	}
X	if(what==CLOAK) {
X		return (curr->cost[dude->quality[CLOAK]-1]);
X	}
X	curr=curr->next;
X	if((what==RS) || (what==BS) || (what==LS)) {
X			return(curr->cost[what-NUM_ITEMS]);
X	}
X	curr=curr->next;
X	if(what==ENERGY) {
X		return(curr->cost[0]);
X	}
X	else
X	{
X		fprintf(stderr, "No such item!  Panic time.  I'm Bailing\n Problem could be shop.contents does not match shop_stubs.c expectations\n");
X		exit(1);
X	}
X}
X
Xcost_of_weap(dude,what)
Xwinptr dude;
Xint what;
X{
Xstruct menu_p *curr;
X
X    curr=head;
X	curr=curr->next->next->next;
X	return(curr->cost[what]);
X}
END_OF_FILE
if test 3067 -ne `wc -c <'bits.c'`; then
    echo shar: \"'bits.c'\" unpacked with wrong size!
fi
# end of 'bits.c'
fi
if test -f 'damage_ship.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'damage_ship.c'\"
else
echo shar: Extracting \"'damage_ship.c'\" \(3674 characters\)
sed "s/^X//" >'damage_ship.c' <<'END_OF_FILE'
X/* damage_ship.c - ***  */
X
X#if !defined(lint)
Xstatic char sccs_id[] = "@(#)damage_ship.c 1.20 93/03/26 XMPB";
X#endif
X#include "player.h"
X
Xvoid blow_up();
X
Xextern int weap_damage_prob[NO_WEAPONS];
Xextern winptr first_win;
Xextern int num_alive; 
Xextern int num_npcs_alive;
Xextern num_npcs_windows;
X
X#define WEAP_DAMAGE
Xdamage_ship(w,shield,dam)
Xwinptr w;
Xint shield,dam;
X{
X	int r=0;
X
X	switch(shield)
X	{
X		case RSH:
X			w->rs_curr -= dam;
X			if(w->rs_curr < 0)
X			{
X				r=random_hit(w,-w->rs_curr/2);
X				w->rs_curr = 0;
X			}
X			break;
X		case LSH:
X            w->ls_curr -= dam;
X			if(w->ls_curr < 0)
X			{
X				r=random_hit(w,-w->ls_curr/2);
X				w->ls_curr = 0;
X			}
X            break;
X        case BSH:
X            w->bs_curr -= dam;
X			if(w->bs_curr < 0)
X			{
X				r=random_hit(w,-w->bs_curr/2);
X				w->bs_curr = 0;
X			}
X            break;
X		default:
X			xmpb_error("Haven't heard of that shield\n");
X			break;
X	}
X	return r;
X}
X
Xint random_hit(w,dam)
Xwinptr w;
Xint dam;
X{
X	int r;
X	int l;
X	int total;
X
X	int i;
X
X	total = 0;
X	w->damaged=2;
X
X	l = dam;
X	while(dam > 0)
X	{
X		if(dam < 5)
X	 	{
X			l = dam;
X			dam = 0;
X		}
X		else
X		{
X			l = 5;
X			dam -=5;
X		}
X	while(l > 0)
X	{
X		total = 0;
X		for(i=0;i<NUM_ITEMS;i++)
X		{
X			if(w->state[i] > 0)
X			{
X				total += w->prob[i];
X			}
X		}
X#ifdef WEAP_DAMAGE
X		for(i=0;i<NO_WEAPONS;i++)
X		{	
X			if(w->does_have_weap[i] && w->load_status[i] >= 0)
X				total += weap_damage_prob[i];
X		}
X#endif
X		if(total == 0 && !w->exploding)
X		{
X			blow_up(w);   
X			return 1;
X		}
X
X		if (w->exploding)
X			return 0;
X
X		r = rand()%total;
X		i =0;
X		while(r > 0)
X		{
X			if(i < NUM_ITEMS)
X			{
X				if(w->state[i] > 0)
X					r -= w->prob[i];
X			}
X#ifdef WEAP_DAMAGE
X			else
X			{
X				if(w->does_have_weap[i-NUM_ITEMS] && w->load_status[i-NUM_ITEMS] >= 0)
X					r -= weap_damage_prob[i-NUM_ITEMS];
X			}
X			i = (i+1)%(NUM_ITEMS+NO_WEAPONS);
X#else
X			i = (i+1)%(NUM_ITEMS);
X#endif
X		}
X		i--;
X#ifdef WEAP_DAMAGE
X		i = (i + (NUM_ITEMS+NO_WEAPONS))%(NUM_ITEMS+NO_WEAPONS);
X#else
X		i = (i + NUM_ITEMS)%NUM_ITEMS;
X#endif
X
X		if(i < NUM_ITEMS)
X		{
X			w->state[i] -= l;
X			l = 0;
X			if(w->state[i] < 0)
X			{
X				l = - w->state[i];
X				w->state[i] = 0;
X			}
X		}
X#ifdef WEAP_DAMAGE
X		else
X		{
X			if(!(rand()%10))
X			w->load_status[i-NUM_ITEMS] = -1;
X			l = 0;
X		}
X#endif
X	}
X	}
X	if(!(rand()%3))
X		add_junk(DEBRIS1+rand()%3,w->sx,w->sy,(rand()%20-10)*32768+w->xv,(rand()%20-10)*32768+w->yv,0);
X	return 0;
X}
X
Xvoid untarget(w)
Xwinptr w;
X{
X	winptr t;
X
X    t = first_win;
X    while(t)
X    {
X        if (t->targeting == w)
X        {
X            t->targeting=NULL;
X        }
X        t=t->next;
X    }
X}
X
Xvoid blow_up(w)
Xwinptr w;
X{
X	int i;
X	winptr t;
X
X	w->exploding = 500;
X	num_alive--;
X	if(w->npc)
X	{
X
X		num_npcs_alive--;
X		if(w->npcwin)
X		{
X			close_host(w);
X			w->npcwin = 0;
X/*
X			winptr t,l;
X			extern winptr first_win;
X
X 			t = first_win;
X            if (t==w) {
X                first_win=w->next;
X                if(!w->npc || w->npcwin) close_host(w);
X                return;
X            }
X            else
X			{
X            	while(t) 
X				{
X					l=t;
X                	t=t->next;
X                	if(w==t) 
X					{
X                    	l->next=t->next;
X                    	if(!w->npc || w->npcwin) close_host(w);
X                    	return;
X					}
X                }
X            }
X*/
X			num_npcs_windows--;
X		}
X	}
X
X	for(i=0;i<50;i++)
X	{
X		add_weapon_item(w,WEAP_PULSE,((random()%100 -50)*32768)+w->xv,((random()%100 -50)*32768)+w->yv,0,NULL,w->sx,w->sy);
X		if(i%2)
X			add_weapon_item(w,WEAP_BOMB,((random()%100 -50)*32768)+w->xv,((random()%100 -50)*32768)+w->yv,0,NULL,w->sx,w->sy);
X
X		add_junk(CLOUD1,w->sx+rand()%60-30,w->sy+rand()%60-30,w->xv,w->yv,rand()%4+1);
X	}
X	untarget(w);
X}
X	
END_OF_FILE
if test 3674 -ne `wc -c <'damage_ship.c'`; then
    echo shar: \"'damage_ship.c'\" unpacked with wrong size!
fi
# end of 'damage_ship.c'
fi
if test -f 'disp_ship.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'disp_ship.c'\"
else
echo shar: Extracting \"'disp_ship.c'\" \(4617 characters\)
sed "s/^X//" >'disp_ship.c' <<'END_OF_FILE'
X/* disp_ship.c - *** Display a ship on a display  */
X
Xstatic char sccs_id[] = "@(#)disp_ship.c 1.11 93/03/26 XMPB";
X
X#include "player.h"
X
Xextern int xo[24],yo[24];    /* get the ship offsets */
Xextern winptr first_win;
Xextern int mysintab[],mycostab[];
X
Xrotate_pt(x,y,angle,x1,y1)
Xint x, y, angle, *x1, *y1;
X{
X	*x1 = (mycostab[angle]*x-mysintab[angle]*y)*3/65536;	
X	*y1 = (mycostab[angle]*y+mysintab[angle]*x)*3/65536;	
X}
X
X#define NUMSHIPLINES 14
Xint ship_lines[][2][2] =
X{
X	{{0,-24},{12,12}},
X	{{0,-24},{-12,12}},
X	{{-12,16},{12,16}},
X	{{-12,12},{-10,16}},
X	{{12,12},{10,16}},
X	{{-2,-4},{0,-12}},
X	{{2,-4},{0,-12}},
X	{{-2,-4},{2,-4}},
X	{{-12,12},{-14,11}},
X	{{12,12},{14,11}},
X	{{-14,11},{-14,20}},
X	{{14,11},{14,20}},
X	{{-14,20},{-12,16}},
X	{{14,20},{12,16}}
X};
X
X/*
X* display a ship on window m
X* x,y are the position on the screen
X* t* are whether the thrusters of the ship are on
X* and n is the picture (derived from the angle 
X*/
Xdisp_ship(m,a,x,y,t1,t2,t3,who)
Xwinptr m;
Xint a,x,y,t1,t2,t3;
Xwinptr who;
X{
X	int i;
X	int x1,x2,y1,y2;
X	int n= (int)(((float)(a)+7.5)/15.0)%24;
X	int done_jam8=0;
X
X/* 
X   the pictures are written to a hidden buffer which is OFFSET larger in
X   all directions.  This is why the x's and y's are changed by the
X   OFFSET.
X*/
X/*
X    XCopyPlane(m->theDisplay,m->sp[n].pm,m->back_buffer,m->bbgc,0,0,m->sp[n].w,
X		m->sp[n].h,x+m->sp[n].xo-40+OFFSET,y+m->sp[n].yo-40+OFFSET,1);
X*/
X
X	for(i=0;i<NUMSHIPLINES;i++)
X	{
X		rotate_pt(ship_lines[i][0][0],ship_lines[i][0][1],a,&x1,&y1);
X		rotate_pt(ship_lines[i][1][0],ship_lines[i][1][1],a,&x2,&y2);
X		if(who==m || !who->cloaking)
X			XDrawLine(m->theDisplay,m->back_buffer,m->bmgc,x+x1+OFFSET,y+y1+OFFSET,x+x2+OFFSET,y+y2+OFFSET);
X		else
X		{
X			if(rand()%100+1 > who->state[CLOAK]+10)
X				XDrawLine(m->theDisplay,m->back_buffer,m->bmgc,x+x1+OFFSET,y+y1+OFFSET,x+x2+OFFSET,y+y2+OFFSET);
X			else
X			switch(who->quality[CLOAK])
X			{
X				case 2: 
X				case 3:
X				case 4:
X				XDrawLine(m->theDisplay,m->back_buffer,m->bmgc,x+x1+OFFSET,y+y1+OFFSET,x+x2+OFFSET,y+y2+OFFSET);
X				break;
X				case 5:
X				XDrawLine(m->theDisplay,m->back_buffer,m->jam75,x+x1+OFFSET,y+y1+OFFSET,x+x2+OFFSET,y+y2+OFFSET);
X				break;
X				case 6:
X				XDrawLine(m->theDisplay,m->back_buffer,m->jam50,x+x1+OFFSET,y+y1+OFFSET,x+x2+OFFSET,y+y2+OFFSET);
X				break;
X				case 7:
X				XDrawLine(m->theDisplay,m->back_buffer,m->jam25,x+x1+OFFSET,y+y1+OFFSET,x+x2+OFFSET,y+y2+OFFSET);
X				break;
X				case 8:
X					if(done_jam8) break;
X					XCopyPlane(m->theDisplay,(m->spm[0].spm),m->back_buffer,m->bbgc,0,0,m->spm[0].w,m->spm[0].h,x+OFFSET,y+OFFSET,1);
X					XCopyPlane(m->theDisplay,(m->spm[1].spm),m->back_buffer,m->bbgc,0,0,m->spm[1].w,m->spm[1].h,x+OFFSET-40,y+OFFSET+40,1);
X					XCopyPlane(m->theDisplay,(m->spm[2].spm),m->back_buffer,m->bbgc,0,0,m->spm[2].w,m->spm[2].h,x+OFFSET+40,y+OFFSET+40,1);
X					done_jam8=1;
X				break;
X				case 9:
X				break;
X			}
X		}
X	}
X	if(t1)
X	{
X		int xx,yy;
X		XPoint xps[3];
X
X		rotate_pt(-14,20,a,&xx,&yy);
X		xps[0].x = (short)xx+x+OFFSET;
X		xps[0].y = (short)yy+y+OFFSET;
X		rotate_pt(-8,22,a,&xx,&yy);
X		xps[1].x = (short)xx+x+OFFSET;
X		xps[1].y = (short)yy+y+OFFSET;
X		rotate_pt(-12,16,a,&xx,&yy);
X		xps[2].x = (short)xx+x+OFFSET;
X		xps[2].y = (short)yy+y+OFFSET;
X		XFillPolygon(m->theDisplay,m->back_buffer,m->fillgc,xps,3,Convex,CoordModeOrigin);
X
X/*
X    	XCopyPlane(m->theDisplay,m->lt[n].pm,m->back_buffer,m->bbgc,0,0,
X			m->lt[n].w,m->lt[n].h,x+m->lt[n].xo+OFFSET,y+m->lt[n].yo+OFFSET,1);
X*/
X	}
X	if(t2)
X	{
X		int xx,yy;
X		XPoint xps[3];
X
X		rotate_pt(-6,16,a,&xx,&yy);
X		xps[0].x = (short)xx+x+OFFSET;
X		xps[0].y = (short)yy+y+OFFSET;
X		rotate_pt(0,30,a,&xx,&yy);
X		xps[1].x = (short)xx+x+OFFSET;
X		xps[1].y = (short)yy+y+OFFSET;
X		rotate_pt(6,16,a,&xx,&yy);
X		xps[2].x = (short)xx+x+OFFSET;
X		xps[2].y = (short)yy+y+OFFSET;
X		XFillPolygon(m->theDisplay,m->back_buffer,m->fillgc,xps,3,Convex,CoordModeOrigin);
X/*
X    	XCopyPlane(m->theDisplay,m->mt[n].pm,m->back_buffer,m->bbgc,0,0,
X			m->mt[n].w,m->mt[n].h,x+m->mt[n].xo+OFFSET,y+m->mt[n].yo+OFFSET,1);
X*/
X	}
X	if(t3)
X	{
X		int xx,yy;
X		XPoint xps[3];
X
X		rotate_pt(14,20,a,&xx,&yy);
X		xps[0].x = (short)xx+x+OFFSET;
X		xps[0].y = (short)yy+y+OFFSET;
X		rotate_pt(8,22,a,&xx,&yy);
X		xps[1].x = (short)xx+x+OFFSET;
X		xps[1].y = (short)yy+y+OFFSET;
X		rotate_pt(12,16,a,&xx,&yy);
X		xps[2].x = (short)xx+x+OFFSET;
X		xps[2].y = (short)yy+y+OFFSET;
X		XFillPolygon(m->theDisplay,m->back_buffer,m->fillgc,xps,3,Convex,CoordModeOrigin);
X/*
X    	XCopyPlane(m->theDisplay,m->rt[n].pm,m->back_buffer,m->bbgc,0,0,
X			m->rt[n].w,m->rt[n].h,x+m->rt[n].xo+OFFSET,y+m->rt[n].yo+OFFSET,1);
X*/
X	}
X    XFlush(m->theDisplay);
X}
X
END_OF_FILE
if test 4617 -ne `wc -c <'disp_ship.c'`; then
    echo shar: \"'disp_ship.c'\" unpacked with wrong size!
fi
# end of 'disp_ship.c'
fi
if test -f 'lex.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lex.l'\"
else
echo shar: Extracting \"'lex.l'\" \(3518 characters\)
sed "s/^X//" >'lex.l' <<'END_OF_FILE'
X%{
X#include <stdio.h>
X#include "y.tab.h"
X
X#define MAX_SYMB_LEN 30
Xint i;
X
Xchar id[MAX_SYMB_LEN+1];
X%}
X
X%p 4000
X%e 1500
XDIGIT   [0-9]
XWS	("\t"|" ")
XNL  ("\n")
X
X%%
X    extern int yylval;
X	extern int errline;
X
X{WS}   {};/* eat up white space */
X"\n"  errline++;
X\-      return MINUS;
X[-]?{DIGIT}+       {yylval = atoi(yytext); return INTEGER;}
X\!		return NOT;
X\*      return TIMES;
X\/\*	comment();
X\+      return PLUS;
X\,		return COMMA;
X\/      return DIV;
X\-\>    return ARROW;
X\<\-\>   return DARROW;
X\{      return LBRACE;
X\}      return RBRACE;
X=       return EQUALS;
X;       return SEMICOLON;
X==      return EQIV;
X!=      return NOTEQ;
X\<       return LT;
X\>       return GT;
X\<=      return LTE;
X\%		return MOD;
X\>=      return GTE;
X\&\&      return AND;
X\|\|      return OR;
X\)       return RP;
X\(       return LP;
X
Xend		return END;
Xif 		return IF;
Xwhile	return WHILE;
Xelse	return ELSE;
Xnone    return NONE;
Xset     return SET;
Xreturn  return RETURN;
Xvar     return VAR;
XState   return STATE;
XStart       return START;
XEntry	return ENTRY;
XProc 	return PROC;
X
XPulse   return PULSE;
XBomb    return BOMB;
XSeek	return SEEK;
XLLaser  return LLASER;
XRail    return RAIL;
XMass	return MASS;
XMine	return MINE;
XAtom	return ATOM;
XHLaser	return HLASER;
XHPulse	return HPULSE;
XMagneto	return MAGNETO;
XBDeath	return BDEATH;
X
XNPC     return HEADER;
XWeapons     return WEAPONS;
XEnergyMax   return ENERGYMAX;
XLShieldMax  return LSHIELDMAX;
XRShieldMax  return RSHIELDMAX;
XBShieldMax  return BSHIELDMAX;
X
XName    return NAME;
XShip    return SHIPNAME;
X
XEngine  return ENGINEL;
XShortRange  return SHORT;
XLongRange   return LONG;
XRepair      return REPAIRL;
XTC          return TCL;
XJammer       return CLOAKL;
XSolar       return SOLARL;
XIdle		return IDLEL;
X
XBalance     return BALANCE;
XSelectEnemy return SELECTE;
XJamming		return CLOAKT;
XRadarChange return RADARCHANGE;
XTurnTo		return TURNTO;
XB1      return B1;
XB2      return B2;
XB3      return B3;
XTurnLeft   return TURNLEFT;
XTurnRight  return TURNRIGHT;
XTarget		return TARGET;
XRepairToggle return REPAIRTOGGLE;
XRepairSelectedItem	return REPAIRSELITEM;
XGrab		return GRAB;
XQuit		return QUIT;
X
XEnergy		return ENERGY;
XAngle		return ANGLE;
XLShield     return LSHIELD;
XRShield     return RSHIELD;
XBShield     return BSHIELD;
XRadarMode   return RADARMODE;
XXPos		return XPOS;
XYPos		return YPOS;
XXVel		return XVEL;
XYVel		return YVEL;
XNumEnemies	return NUMENEMIES;
XEnemyDist	return ENEMYDIST;
XCurrWeap	return CURRWEAP;
XRepairState return REPAIRSTATE;
XEngineState return ENGINESTATE;
XLongState	return LONGSTATE;
XShortState	return SHORTSTATE;
XJamState	return JAMSTATE;
XSolarState	return SOLARSTATE;
XTargetState	return TARGETSTATE;
XEnemyAngle	return ENEMYANGLE;
XEnemyDirection	return ENEMYDIRECTION;
XEnemySpeed	return ENEMYSPEED;
XEnemyXPos	return ENEMYXPOS;
XEnemyYPos	return ENEMYYPOS;
XEnemyXVel	return ENEMYXVEL;
XEnemyYVel	return ENEMYYVEL;
XSpeed		return SPEED;
XEnemyAvail  return ENEMYAVAIL;
XDirection   return DIRECTION;
XAngleTo		return ANGLETO;
XDistTo		return DISTTO;
XRepairItem  return REPAIRITEM;
XVelAtAngle	return VELATANG;
XCurrWeapState	return CURRWEAPSTATE;
XWaitFrame	return WAITFRAME;
X
X[_a-zA-Z][_A-Za-z0-9]* 	{strncpy(id,yytext,MAX_SYMB_LEN); return ID;}
X.       yyerror("Unexpected character:");
X%%
X
Xcomment()
X{
X	char c;
X	int done = 0;
X
X	while(!done)
X	{
X		c = yyinput();
X		if(c == '*')
X		{
X			if((c = yyinput()) == '/')
X				done = 1;
X			else
X				if(c == '\n')
X					errline++;
X			else if(c == 0)
X					done = 1;
X		}
X		else
X		if(c == '\n')
X			errline++;
X		else if(c== 0)
X			done = 1;
X	}
X}
END_OF_FILE
if test 3518 -ne `wc -c <'lex.l'`; then
    echo shar: \"'lex.l'\" unpacked with wrong size!
fi
# end of 'lex.l'
fi
if test -f 'ml.npc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ml.npc'\"
else
echo shar: Extracting \"'ml.npc'\" \(2596 characters\)
sed "s/^X//" >'ml.npc' <<'END_OF_FILE'
XNPC
XName = Dumbo
XShip = layer
XEnergyMax = 10000
XLShieldMax = 1200
XRShieldMax = 1200
XBShieldMax = 800
XSolar = 9
XShortRange = 1
XEngine = 2
XRepair = 9
XLongRange = 1
XJammer = 2
XTC = none
X
XWeapons
XRail
XMine
X
Xvar
X	a
X	num
Xend
X
XState Laymine
X{
X	set B3 =0;
X	while (CurrWeap!= 6)
X		set B2 =1;
X	set B2 =0;
X	set B1 =1;
X	if(XPos > 4200 && Angle==90)
X		1 -> stopright;
X	if (XPos < -4200 && Angle==270)
X		1 -> stopleft;	
X	num = NumEnemies;
X    set SelectEnemy = 0;
X    if(EnemyDist < 1000)
X        1 -> attack;
X}
X
XState stopup
X{
X	set B3 =0;
X	set TurnTo = 180;
X	while (Angle !=180);
X	set B3 =1;
X	while (YVel > 0);
X	set B3 =0;
X	1 -> main;
X}
X
XState goup
X{
X	set B3=0;
X	set TurnTo = 0;
X	while (Angle!=0);
X	set B3=1;
X	if (YVel > 20)
X		1 -> stopup;
X}
X
X
XState stopright 
X{
X	set B1 =0;
X	set TurnTo = 270;
X	while (Angle != 270);
X	set B3 = 1;
X	while (XVel>0);
X	{
X		if (XVel > 10 || YVel > 10)
X		{
X			1 -> stopright;
X		}
X		else
X		{
X			if (XVel < -10 || YVel < -10)
X			{
X				1 -> stopleft;
X			}
X		}
X	}
X	set B3 =0;
X	if(YPos < -4500)
X		1 -> goup;
X	set TurnTo = 180;
X	while (Angle != 180);
X	set B3 = 1;
X	while(YVel > -8);
X	set B3 =0;
X	set TurnTo=0;
X	while(Angle!=0);
X	set B3 =1;
X	while(YVel<-2);
X	{
X		if (XVel > 10 || YVel > 10)
X		{
X			1 -> stopright;
X		}
X		else
X		{
X			if (XVel < -10 || YVel < -10)
X			{
X				1 -> stopleft;
X			}
X		}
X	}
X	set B3 =0;
X	1 -> goleft;
X}
X
XState stopleft 
X{
X	set B1 =0;
X    set TurnTo = 90;
X    while (Angle != 90);
X    set B3 = 1;
X    while (XVel<0)
X	{
X		if (XVel > 10 || YVel > 10)
X		{
X			1 -> stopright;
X		}
X		else
X		{
X			if (XVel < -10 || YVel < -10)
X			{
X				1 -> stopleft;
X			}
X		}
X	}
X    set B3 =0;
X    set TurnTo = 180;
X    while (Angle != 180);
X    set B3 = 1;
X    while(YVel > -8);
X	set B3 =0;
X    set TurnTo=0;
X    while(Angle!=0)
X        set B3=0;
X    set B3 =1;
X    while(YVel< -2 )
X	{
X		if (XVel > 10 || YVel > 10)
X		{
X			1 -> stopright;
X		}
X		else
X		{
X			if (XVel < -10 || YVel < -10)
X			{
X				1 -> stopleft;
X			}
X		}
X	}
X	set B3 =0;
X    1 -> goright;
X}
X
XState goright
X{
X	set TurnTo = 90;
X	while (Angle!=90);
X	set B3 = 1;
X	if (XVel >= 5)
X		1 -> Laymine;
X}
X
XState goleft
X{
X	set TurnTo = 270;
X	while (Angle!=270);
X	set B3 = 1;
X	if (XVel <= -5)
X		1 -> Laymine;
X}
X
XState attack
X{
X	if(Angle > EnemyAngle)
X		set TurnTo = EnemyAngle-EnemyDist/150*1;
X	else
X		set TurnTo = EnemyAngle+EnemyDist/150*1;
X	set Balance = 1;
X	set RepairToggle = 1;
X
X	while(CurrWeap!=4)
X	{
X		set B2 =1;
X	}
X	set B2=0;
X	set B1=1;
X	if (EnemyDist> 1000)
X		1 -> main;
X}
X
XState main
X{
X	num = NumEnemies;
X	set SelectEnemy = 0;
X	if(EnemyDist < 1000)
X		1 -> attack;
X	if(XPos> 0)
X		1 -> goright;
X	else
X		1 -> goleft;
X}
X
XStart main
END_OF_FILE
if test 2596 -ne `wc -c <'ml.npc'`; then
    echo shar: \"'ml.npc'\" unpacked with wrong size!
fi
# end of 'ml.npc'
fi
if test -f 'nasty.npc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nasty.npc'\"
else
echo shar: Extracting \"'nasty.npc'\" \(4690 characters\)
sed "s/^X//" >'nasty.npc' <<'END_OF_FILE'
XNPC
XName = Nasty
XShip = Bastard
XEnergyMax = 1400
XLShieldMax = 900
XRShieldMax = 900
XBShieldMax = 700
XSolar = 5
XShortRange = 5
XEngine = 5
XRepair = 7
XLongRange = 5
XJammer = 5
XTC = 3
X
XWeapons
XPulse
XHPulse
XRail
XAtom
X
Xvar
Xend
X
XState avoid
X{
Xvar
X	count
X	tmp
X	lastDist
Xend
X
X	lastDist=EnemyDist;
X	set B1 =0;
X	if(SolarState < 100)
X		set RepairSelectedItem=Solar;
X	else
X	if(EngineState < 100)
X		set RepairSelectedItem=Engine;
X	else
X		set RepairToggle = 1;
X	count = 15;
X	while(count)
X	{
X		tmp = EnemyDist;
X		if(tmp && tmp >= lastDist) -> loop;
X		if(!tmp)
X		{
X			slow();
X			-> loop;
X		}
X		set B3 =1;
X		if(EnemyAngle > 0 && EnemyAngle < 180)
X			set TurnTo=(EnemyAngle+ 90)%360;
X		else
X			set TurnTo=(EnemyAngle- 90)%360;
X		wall_check();
X		count = count - 1;
X	}
X	slow();
X	-> loop;
X}
X
XProc wall_check
X{
Xvar
X	r
X	l
X	u
X	d
Xend
X
X	r = 0;
X	l = 0;
X	u = 0;
X	d = 0;
X
X	if (XPos*XVel > 45000 && XVel > 0) r = 1;
X	if (XPos*XVel > 45000 && XVel < 0) l = 1;
X	if (YPos*YVel > 45000 && YVel > 0) u = 1;
X	if (YPos*YVel > 45000 && YVel < 0) d = 1;
X
X	if (r || l || u || d) slow();
X	return;
X}
X
XProc att_check
X{
X
X	NumEnemies;
X	set SelectEnemy = 0;
X	set RepairToggle = 1;
X	set Balance = 1;
X	wall_check();
X
X	if(! EnemyAvail)
X	{
X		set B1 = 0;
X		set B3 = 0;
X		return;
X	}
X
X	if(Energy < 200 && LShield > 400 && EnemyDist < 600)
X	{
X		set Grab =1;
X		set RepairToggle =1;
X	}
X
X	if(Speed > 40) slow();
X	
X	return;
X}
X
XProc attack
X{
Xvar
X	a1
X	a2
X	m
X	a
X	p
X	cnt
X	count
Xend
X
X	
X	a2 = EnemyAngle;
X	count = 10;
X	while(EnemyDist < 1000)
X	{
X
X		a1 = a2;
X		a2 = EnemyAngle;
X	
X		m = EnemyDist/(50+VelAtAngle(Angle)) - 1;	
X		if(EnemyDist > 500)
X		{
X 			a = AngleTo(EnemyXPos+m*EnemyXVel - m*XVel,EnemyYPos+m*EnemyYVel - m*YVel);
X        	p = (Angle - a + 360)%360;
X        	if(p < 170 || p > 190)
X                set TurnTo = a;
X		}
X		else
X			if(EnemyAngle > 300)
X				set TurnTo = (EnemyAngle + (a2 - a1)*(EnemyDist/150)) % 360;
X			else
X				set TurnTo = (EnemyAngle + (a2 - a1)*(EnemyDist/120)) % 360;
X
X
X		m = 40 - (EnemyDist)/30;
X		if((EnemyDist < 900) && Angle <= (EnemyAngle+ m) && Angle >= (EnemyAngle - m))
X			set B1 = 1; 
X		else
X			set B1 = 0;
X
X		set Balance = 1;
X		if(RepairItem != LongRange)
X			set RepairToggle = 1;
X		if(Direction - Angle > 90 || Direction - Angle < 90 && Energy > 200)
X		{
X			set B3 = 1;
X			cnt = 2;
X			while(cnt>0)
X				cnt=cnt- 1;
X			set B3 = 0;
X		}
X		count = count - 1;
X		if (!count)
X		{
X			att_check();
X			count = 10;
X		}		
X	}
X	set B1 = 0;
X	set B3 = 0;
X	return;
X}
X
XProc repair_which
X{
X	if(LongState < 100 && LongState > 0)
X		set RepairSelectedItem = LongRange;
X	else
X	if(EngineState < 100 && EngineState > 0 )
X		set RepairSelectedItem = Engine;
X	else
X	if(SolarState < 100 && SolarState > 0)
X		set RepairSelectedItem = Solar;
X	else
X	if(RepairState < 100 && RepairState > 0)
X		set RepairSelectedItem = Repair;
X	else
X	if(ShortState < 100 && ShortState >0)
X		set RepairSelectedItem = ShortRange;
X	else
X		set RepairToggle = 1;
X	return;
X}
X
XState repair
X{
Xvar
X	tmp
Xend
X
X/*
X	if(LongState == -1)
X		set Quit = 1;
X*/
X	repair_which();
X	tmp = EnemyDist;
X	if(tmp && tmp < 1000) -> avoid;
X	if(EngineState > 30 && Speed > 10) slow();
X	if(LongState > 80 && EngineState > 60) -> loop;
X	set Balance = 1;
X	aim();
X}
X
XProc aim
X{
Xvar
X	aa1
X	aa2
X	num
Xend
X	num = NumEnemies;
X	set SelectEnemy = 0;
X
X	aa1 = aa2;
X	aa2 = EnemyAngle;
X	if(aa2 == -1)
X		aa2 = aa1;
X	else
X		set TurnTo = (EnemyAngle + (aa2 - aa1) * 4) % 360;
X
X	if(EnemyDist < 1000 && EnemyDist > 0) attack();
X	return;
X}
X
XProc slow
X{
Xvar
X	oldbs
Xend
X
X	set B1 = 0;
X	set TurnTo = (Direction + 180) % 360;
X	set B3 =1;
X	oldbs= BShield;
X	while(Speed > 5 && BShield >= oldbs)
X	{
X/*
X		if(LongState == -1)
X			set Quit = 1;
X*/
X		set TurnTo = (Direction + 180) % 360;
X		if(EnemyDist < 500 && EnemyDist)
X		{
X			attack();
X			return;
X		}
X	}
X	set B3 =0;
X	return;
X}
X
XProc wait
X{
Xvar w
Xend
X
X	set B3 =0;
X	w = 5;
X	while (w)
X	{
X		aim();
X		if ((Direction < (Angle + 10)) && (Direction > (Angle - 10)))
X			return;
X		w = w - 1;
X	}
X	set B3 =1;
X
X	return;
X}
X
XProc seek
X{
Xvar 
X	tmp
Xend
X
X/*
X	if(LongState == -1)
X		set Quit = 1;
X*/
X	if(!NumEnemies) 
X		return 0;	
X	set SelectEnemy = 0;
X
X	aim();
X
X	tmp = EnemyDist;
X	if(EnemySpeed > 30 && tmp > 800 && tmp && tmp) return 1; 
X
X	if(EnemyDist < 1000 && EnemyDist) attack();
X	if(Energy < 200 || LongState < 70) 
X	{
X		set B3 =0;
X		return 0;
X	} 
X	else set B3 =1;
X	if (Speed > 6 && (Direction < (Angle + 10)) && (Direction > (Angle - 10))) wait();
X	if (Speed > 15)
X		set B3 =0;
X	return 0;
X}
X
XState loop
X{
X	if(seek())
X		1 -> avoid;
X	if(RepairItem == Idle)
X		repair_which();
X	set Balance= 1;
X
X	if(LongState == -1)
X		set RadarChange = 1;
X
X	if (Speed > 30 && EnemyDist < 2000)  slow();
X	if (LongState < 50) {
X		slow();
X		-> repair;
X	}
X}
X
XState main
X{
X	set B2 = 1;
X	-> loop;
X}
X
XStart main
END_OF_FILE
if test 4690 -ne `wc -c <'nasty.npc'`; then
    echo shar: \"'nasty.npc'\" unpacked with wrong size!
fi
# end of 'nasty.npc'
fi
if test -f 'polygon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'polygon.c'\"
else
echo shar: Extracting \"'polygon.c'\" \(2558 characters\)
sed "s/^X//" >'polygon.c' <<'END_OF_FILE'
X/* polygon.c - *** Routines for geometric intersections */
X
Xstatic char sccs_id[] = "@(#)polygon.c 1.7 92/11/24 XMPB";
X#include <stdio.h>
X#include <math.h>
X/*
Xint line_2_point(x1,y1,x2,y2,x3,y3)
Xint x1,y1,x2,y2,x3,y3;
X{
X
X	int x2d,y2d,x3d,y3d;
X	int xbar;
X
X	x2d = x2 - x1;
X	y2d = y2 - y1;
X
X	x3d = x3 - x1;
X	y3d = y3 - y1;
X	if(y2d == 0)
X	{
X		y2d = 1;
X		y3d += 1;
X	}
X
X	xbar = y3d * x2d / y2d;
X	return(x3d - xbar);
X}
X*/
Xdouble line_2_pointf(x1,y1,x2,y2,x3,y3)
Xint x1,y1,x2,y2,x3,y3;
X{
X	double x2d,y2d,x3d,y3d;
X    double xbar;
X
X	x2d = (double)x2 - (double)x1;	
X	y2d = (double)y2 - (double)y1;	
X
X	x3d = (double)x3 - (double)x1;	
X	y3d = (double)y3 - (double)y1;	
X	y2d += 1.0;
X	y3d += 1.0;
X
X	xbar = y3d * x2d / y2d;
X	return(x3d - xbar);
X}
X/*
Xline_2_line(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,int *a,int *b,int *c,int *d)
X{
X	int t;
X	*c = line_2_point(x1,y1,x2,y2,x3,y3);
X	*d = line_2_point(x1,y1,x2,y2,x4,y4);
X	t = (*c)^(*d);
X	if(t >= 0) return 0;
X	*a = line_2_point(x3,y3,x4,y4,x1,y1);
X	*b = line_2_point(x3,y3,x4,y4,x2,y2);
X	t = (*a)^(*b);
X	if(t >= 0) return 0;
X	return 1;
X}
X*/
X
Xdouble line_2_linef(x1,y1,x2,y2,x3,y3,x4,y4)
Xint x1,y1,x2,y2,x3,y3,x4,y4;
X{
X	double a,b,c,d;
X
X	c = line_2_pointf(x1,y1,x2,y2,x3,y3);		
X	d = line_2_pointf(x1,y1,x2,y2,x4,y4);		
X	if(c*d > 0.0)
X		return -3.0;
X
X	a = line_2_pointf(x3,y3,x4,y4,x1,y1);		
X	b = line_2_pointf(x3,y3,x4,y4,x2,y2);		
X	if(a*b > 0.0)
X		return -3.0;
X
X	return ((a)/(b-a));
X}
X
X
Xint line_2_circle(x1,y1,x2,y2,x3,y3,r)
Xint x1,y1,x2,y2,x3,y3,r;
X{
X	double c2,m2;
X	double m,c;
X	double r2;
X	double ret;
X	double ret2;
X
X	if(x1 == x2)
X	{
X		if((x1 > x3+r) || (x1 < x3-r))
X			return 0;
X		if((y2 < y3-r) && (y1 < y3-r))
X			return 0;
X		if((y2 > y3+r) && (y1 > y3+r))
X			return 0;
X		return 1;
X	}
X	else
X	{
X		r2 = (double)r*(double)r;
X		m = (double)(y2-y1)/(double)(x2-x1);
X		
X		m2 = m*m;
X
X		c = (double)y1 - m*(double)x1;
X
X		ret = (2*x3*m)*(y3-c)+m2*(r2-x3*x3)-(c-y3)*(c-y3)+r2;
X		if(ret < 0.0)
X			return 0;
X		ret2 = ret;
X		ret = (-(2*m*c-2*m*y3-2*x3) + sqrt(ret))/2.0/(m2+1) ;
X		ret2 = (-(2*m*c-2*m*y3-2*x3) - sqrt(ret2))/2.0/(m2+1) ;
X
X		if(x1 < x2)
X		{
X			if(((int)ret <= x2 && (int)ret >= x1)||
X            ((int)ret2 <= x2 && (int)ret2 >= x1))
X            {
X                if(ret < ret2) return ret;
X                return ret2;
X            }
X            return 0;
X		}
X		else
X		{
X			if(((int)ret <= x1 && (int)ret >= x2)||
X            ((int)ret2 <= x1 && (int)ret2 >= x2))
X            {
X                if(ret > ret2) return ret;
X                return ret2;
X            }
X            return 0;
X		}
X			
X	}
X}
X		
END_OF_FILE
if test 2558 -ne `wc -c <'polygon.c'`; then
    echo shar: \"'polygon.c'\" unpacked with wrong size!
fi
# end of 'polygon.c'
fi
if test -f 'rad1.npc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rad1.npc'\"
else
echo shar: Extracting \"'rad1.npc'\" \(3358 characters\)
sed "s/^X//" >'rad1.npc' <<'END_OF_FILE'
XNPC
XName = rad1npc
XShip = Oldsmobile
XEnergyMax  = 1000
XLShieldMax =  600
XRShieldMax =  600
XBShieldMax =  400
XSolar = 2
XShortRange = 1
XEngine = 3
XRepair = 2
XLongRange = 1
XJammer = none
XTC = none
X
XWeapons
XPulse
X
Xvar
Xend
X
XProc evadeWall
X{
Xvar 
X	u
X	d
X	l
X	r
X	angto
Xend
X	l = 0;
X	u = 0;
X	d = 0;
X	r = 0;
X
X	if (XPos*XVel > 50000 && XVel > 0) r = 1;
X	if (XPos*XVel > 50000 && XVel < 0) l = 1;
X	if (YPos*YVel > 50000 && YVel > 0) u = 1;
X	if (YPos*YVel > 50000 && YVel < 0) d = 1;
X
X	if (r && u) 
X	{
X		angto=225;
X		set TurnTo = 225;
X		set B3 = 1;
X		return;
X	}
X	if (r && d) 
X	{
X		angto=315;
X		set TurnTo = 315;
X		set B3 = 1;
X		return;
X	}
X	if (l && u) 
X	{
X		angto=135;
X		set TurnTo = 135;
X		set B3 = 1;
X		return;
X	}
X	if (l && d) 
X	{
X		angto=45;
X		set TurnTo = 45;
X		set B3 = 1;
X		return;
X	}
X	if (r)
X	{
X		angto=270;
X		set TurnTo = 270;
X		set B3 = 1;
X		return;
X	}
X	if (l)
X	{
X		angto=90;
X		set TurnTo = 90;
X		set B3 = 1;
X		return;
X	}
X	if (d)
X	{
X		angto=0;
X		set TurnTo = 0;
X		set B3 = 1;
X		return;
X	}
X	if (u)
X	{
X		angto=180;
X		set TurnTo = 180;
X		set B3 = 1;
X		return;
X	}
X
X	return;
X}
X
X
XProc attack
X{
Xvar
X        num
X	a1
X	a2
X	a3
Xend
X	set B3 = 0;
X	a2 = EnemyAngle;
X	a3 = EnemyAngle;
X	while(EnemyDist < 1000)
X	{
X		num=NumEnemies;
X		set SelectEnemy = 0;
X		set RepairToggle = 1;
X		set Balance = 1;
X
X		if((EnemySpeed < 20) && (Speed < 10))
X			set B3 = 1;
X		else
X			set B3 = 0;
X
X		if(Energy < 250)
X		{
X			set B1 = 0;
X			set B3 = 0;
X			return; 
X		}
X
X		a1 = a2;
X		a2 = a3;
X		a3 = EnemyAngle;
X
X		set TurnTo = (EnemyAngle + 
X			((a3 - a2) + (a3 - a2 - a2 + a1)) * (Speed / 8 + 1)) % 360;
X		if(((Angle - EnemyAngle) % 360 > - 30) && ((Angle - EnemyAngle) % 360 < 30))  
X		{
X			set B1 = 1;
X			set B3 = 1;
X		}
X		else
X		{
X			set B1 = 0; 
X			set B3 = 0;
X		}
X	}
X	set B1 = 0;
X	set B3 = 0;
X	return;
X}
X
XProc slowDown
X{
X	set TurnTo = (Direction + 180) % 360;
X	set B3 = 1;
X	while(Speed > 15)
X	{
X		if(Angle != (Direction + 180) % 360)
X			set TurnTo = Direction + 180;
X	}
X	set B3 = 0;
X	return;
X}
X
XProc repair
X{
Xvar
X	num
Xend
X	slowDown();
X	while((Energy < 250) && ((RShield < 300) || (LShield < 300)))
X	{
X		num = NumEnemies;
X		set SelectEnemy = 0;
X		if(EnemyDist < 1000)
X			return;
X	}
X	return;
X}
X
XProc aim
X{
Xvar
X	num
Xend
X}
X
X
XProc thrust
X{
Xvar
X	num
X	i
X	aa1
X	aa2
X	aa3
Xend
X	num = NumEnemies;
X	set SelectEnemy = 0;
X	aa2 = EnemyAngle;
X	aa3 = EnemyAngle;
X
X	i = 0;
X	while (i < 3)
X	{
X		num = NumEnemies;
X		set SelectEnemy = 0;
X
X		aa1 = aa2;
X		aa2 = aa3;
X		aa3 = EnemyAngle;
X		if((Energy < 250) && ((RShield < 300) || (LShield < 300)))
X		{
X			if(EnemyDist < 1000)
X			{
X				set TurnTo = (EnemyAngle + 180 +
X					((aa3 - aa2) + (aa3 - aa2 - aa2 + aa1)) *
X					(Speed / 8 + 1)) % 360;
X				set B3 = 1;
X			}
X			else
X				repair();
X		}
X		else
X		{
X			set TurnTo = (EnemyAngle +
X				((aa3 - aa2) + (aa3 - aa2 - aa2 + aa1)) *
X				(Speed / 8 + 1)) % 360;
X				attack();
X        }
X
X        if(Energy > 600)
X			set B3 = 1;
X		else
X			set B3 = 0;
X		i = i + 1;
X	}
X	return;
X}
X
X
XProc drift
X{
Xvar
X	i
Xend
X	set B3 = 0;
X	i = 0;
X	while (i < 5)
X		i = i + 1;
X	return;
X}
X
X
XProc seek
X{
X	if(NumEnemies > 0)
X		thrust();
X	drift();
X	return;
X}
X
X
XState loop
X{
X	set RepairToggle = 1;
X	set Balance= 1;
X
X	if ((XPos*XVel > 50000 && XVel > 0) ||
X	    (XPos*XVel > 50000 && XVel < 0) ||
X	    (YPos*YVel > 50000 && YVel > 0) ||
X	    (YPos*YVel > 50000 && YVel < 0))
X		evadeWall();
X	else
X		seek();
X}
X
XState main
X{
X	set B2 = 1;
X	1 -> loop;
X}
X
XStart main
END_OF_FILE
if test 3358 -ne `wc -c <'rad1.npc'`; then
    echo shar: \"'rad1.npc'\" unpacked with wrong size!
fi
# end of 'rad1.npc'
fi
if test -f 'shop.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'shop.man'\"
else
echo shar: Extracting \"'shop.man'\" \(4738 characters\)
sed "s/^X//" >'shop.man' <<'END_OF_FILE'
X.TH Xmpb 6
X.SH NAME
Xshop - xmpb shop program
X.SH SYPNOSIS
X.ta 4n
X\fIshop\fR Name
X
X.SH DESCRIPTION
X
X	The shop program is part of the xmpb package.
X
X	The shop allows you to buy, sell or repair your current ship.
XTo run the shop, type:
X
X		shop Name  	(where Name is the name of your character)
X
XThen you will be presented with a small window, which is a security check.
XWhen you have correctly typed in your password, then the shop will open up.
X
XWhen you get into the shop, you will see a series of buttons on the top, 
Xtwo areas underneath this, labelled: "Items in the shop:" and 
X"Items in your ship:" The Items in your ship area will be filled with a list 
Xof all the items that your ship has left, and what state they are in.  If you
Xdidn't lose any items, then you should have the top five lines filled with
XSolar Panels, Short Range Radar, Engine, Repair System, and Long Range Radar.
X
XIf one of these items is missing, then it is probably a good idea to get
Xanother, as each of these items are REALLY useful when playing the game.
XBelow this you might have a Jammer and/or a Targeting Computer.  And below that
Xyou will have the values of your left, right and bottom shields and your Energy.
X
XAt any stage you can click on one of the items and see how much it is worth,
Xand how much it would cost to repair (if it is damaged).  To repair the item, 
Xclick on the button labelled "Repair", situated below the Items in your ship
Xlist.  This will deduct the cost and repair the item for you.
X
XIf you want to get rid of the item, then you can sell it.  (Click on the
XButton marked "Sell" beside the Repair button).
X
XBeside the Sell Button is the Button marked Show Weapons.  When you click 
Xon this button, then the Items in your ship area will show which weapons
Xyou own.  And the button will then change to a "Show Items" button.  Clicking
Xon this will allow you to go back to viewing the items.
X
XWhen looking at weapons in your ship, you can click on one and see how 
Xmuch it is worth and/or sell it.
X
XNow to the interesting bit.  Buying bigger and better items and weapons :^)
X
XEach of the top buttons: Engines, Solar Panels, Radar, Weapons, Repair 
XSystems, Miscellaneous, Shields and Energy is a menu.  Click on any of them 
Xand a series of options will be displayed.  Choose one, and in the items in 
Xthe shop area, The details of the item chosen will appear.  The cost will be 
Xdisplayed down the bottom.  If you have enough money, the Buy button, will
Xlet you buy the item.
X
XIf you already have one of these items:  (E.g.  I have an Engine(3) and
Xdecide to Buy and Engine(4), then the Buy button will put up a notice telling
Xyou that you already have one.  If you still wish to buy the item (as I would
Xin this case), then I click OK and the shop will sell off the exisiting item,
Xthe Engine(3), and buy the new item: the Engine(4).  Clicking CANCEL will 
Xstop the purchase.
X
XFinally of course there is the Quit button, which amazingly enough will quit
Xthe shop.  Avoid using the Quit given by your window manager, as the quit button
Xdoes some cleaning up before finishing.
X
X
XFor those interested (Programmers):
X
XThe	shop has a text file called: shop.contents that lists all the items, 
Xtheir descriptions and the cost of them.  This means that if you feel one of
Xthe items is too dear, too cheap etc.  You can change this file and balance
Xthe game out.  (This of course can only be done by the person installing the
Xgame, so choose someone vaguely trustworthy).
X
XOther programming tips:  Don't even look at the code, it is real ugly.  I
Xwhipped it up real fast and with several design changes whilst coding.  BUT the
Xthing works :^)
X
X.SH TROUBLESHOOTING
X
X	If the shop doesn't run:
X
X
X	Usage: Shop Name  -  this means that you haven't given the shop 1 parameter
X					     which should be the Name of the character.
X
X
X	No such player: No such file or directory
X	Exiting...
X
X- This is because the name given is not the same as the one you typed
Xin when you play xmpb.  Watch out for extra spaces.  Or of course,
Xthe character might not exist (? Maybe you retired it ?)
X
XYou cannot execute the shop when you have an active xmpb window.
XQuit your xmpb window and then run the shop
X
X- This means that you cannot run a game of xmpb and the shop at the
Xsame time.  If you want to go to the shop, then you should quit
Xthe current game.  If this message occurs even when you have 
Xfinished xmpb, then I have stuffed up, and you need to 
Xuse the program: clear_lock
X
X.SH BUGS
X
XHmmm,  probably heaps.  But at the moment I have ironed out all the ones
XI know about, so fingers crossed.  
X
XThe shop icon is atrocious.   Still that is what you get for one too many
Xbeers and no better design.
X
X.SH AUTHORS
X.br
X	Shane Hyde
X.br
X	Damien De Paoli
END_OF_FILE
if test 4738 -ne `wc -c <'shop.man'`; then
    echo shar: \"'shop.man'\" unpacked with wrong size!
fi
# end of 'shop.man'
fi
echo shar: End of archive 6 \(of 8\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
