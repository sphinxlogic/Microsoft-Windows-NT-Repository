Path: uunet!news.tek.com!news.cna.tek.com!not-for-mail
From: billr@saab.cna.tek.com (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i053:  gtetris4 - Generic Tetris for X11, V3.0.1, Part01/03 (REPOST)
Date: 30 Aug 1993 07:53:19 -0700
Organization: Tektronix, Inc., Redmond, OR
Lines: 1772
Approved: billr@saab.CNA.TEK.COM
Message-ID: <25t48v$f6f@saab.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1853

Submitted-by: "Q. Alex Zhao" <azhao@cc.gatech.edu>
Posting-number: Volume 18, Issue 53
Archive-name: gtetris4/part01
Supersedes: tetris3: Volume 15, Issue 44-45
Environment: X11R4/5, Xlib

	[Another major update to the popular generic tetris game.  -br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  README MANIFEST X11 X11/Xfuncs.h bm-3d bm-plain tetris.c
#   tetris.h utils.c
# Wrapped by billr@saab on Fri Aug 27 12:06:39 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(2654 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X	GENERIC TETRIS
X	==============	Yet Another Tetris Game on X, V3.0.1
X
X
XWHY ANOTHER?
X
X    Because this one is simple, easy to build, and portable -- actually
X    the blocks are round-cornered and bigger, more comfortable for your
X    eyes. It only uses Xlib -- no "toolkit" kind of thing. People have
X    tested it on the following platforms:
X
X	Bull DPX/2		System V	?
X	DEC 5000		Ultrix 4.3	X11R4
X	DEC Alpha AXP		DEC OSF/1 V1.2	?
X	HP 700			HP-UX 8.0x	X11R5
X				Mt. Xinu 4.3	X11R5
X	IBM RS6000		AIX V3.2	X11R3
X	Intel 486		Esix 4.0.4	?
X				Linux		?
X				SCO-ODT 2.0	X11R4/Motif
X	KSR KSR1		KSR OSF/1	X11R5
X	SGI Iris		IRIX 4.0.1	Motif
X	Sun SPARC		SunOS 4.1.x	X11R4, X11R5
X				Solaris 2.1 (*)
X	Sequent S81		DYNIX 3.2.0	X11R5
X				Dynix/ptx	?
X
X	[Note *] add to link: -L/usr/ucblib -lucb -lelf -R/usr/ucblib
X
X    If your's is not in this list, please let me know -- thanks. The
X    most updated source could be found on ftp.x.org under /contrib.
X
X    A System V port (Sequent Dynix/ptx) has been added by
X    "Hans-Wolfgang Loidl" <hwloidl@risc.uni-linz.ac.at>. The source can
X    be retrieved by anonymous FTP to:
X
X	Host:	melmac.risc.uni-linz.ac.at
X	File:	/pub/linux/upload/misc/gtetris3.taz
X
X
XHOW TO BUILD?
X
X    Edit the Imakefile for appropriate settings of variable SCOREFILE
X    and RANDOM, then do:
X	xmkmf
X	make
X
X    Note: if you don't have 'xmkmf' or the "Makefile" it generates
X    doesn't work well, try:
X	make -f Makefile.std
X
X    "Tetris" is the game. It only lists the top 15 players at the end,
X    each player may has at most three scores. With the option "-s",
X    "tetris" will list all the scores.
X
X
XANYTHING SPECIAL IN PLAYING?
X
X    Use 'j' to move left; 'l' to move right; 'k' to rotate. Left-handed
X    people may want to use 's', 'd', 'f' respectively. Use the space
X    bar to drop a block quickly. Do you want to try the arrow keys?
X
X    Use CTRL-L key combination to redraw -- in case the program messes
X    somthing up.
X
X    As usual, '+' and '-' will speed up or lower down the speed. Note
X    that you don't need to press the SHIFT key -- '=' and '_' also
X    work. The 'b' key can be used to toggle "beep" and 'n' toggles
X    "show next".
X
X    If you press 'p', the game will be paused, and the window will be
X    iconified -- just in case your boss suddenly appears at your door.
X    ;o) When the tetris window loses its focus, it also goes to
X    "paused" mode except it doesn't iconify itself.
X
X    Refer to the man page for detailed command line options.
X
X
XFOUND A BUG?
X
X    Send bug reports (or fixes) to the author:
X
X	Q. Alex Zhao,	azhao@cc.gatech.edu
X	College of Computing
X	Georgia Institute of Technology
X	Atlanta, GA 30332-0280
X
END_OF_FILE
if test 2654 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1695 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X COPYRIGHT                  3	
X Imakefile                  2	
X MANIFEST                   1	This shipping list
X Makefile.std               2	
X README                     1	
X Revisions                  2	
X X11                        1	
X X11/Xfuncproto.h           2	
X X11/Xfuncs.h               1	
X X11/Xos.h                  2	
X X11/Xosdefs.h              2	
X bm-3d                      1	
X bm-3d/rot00.xbm            3	
X bm-3d/rot01.xbm            3	
X bm-3d/rot02.xbm            3	
X bm-3d/rot03.xbm            3	
X bm-3d/rot04.xbm            3	
X bm-3d/rot05.xbm            3	
X bm-3d/rot06.xbm            3	
X bm-3d/rot07.xbm            3	
X bm-3d/rot08.xbm            3	
X bm-3d/rot09.xbm            3	
X bm-3d/rot10.xbm            3	
X bm-3d/rot11.xbm            3	
X bm-3d/rot12.xbm            3	
X bm-3d/rot13.xbm            3	
X bm-3d/rot14.xbm            3	
X bm-3d/rot15.xbm            3	
X bm-plain                   1	
X bm-plain/rop00.xbm         2	
X bm-plain/rop01.xbm         2	
X bm-plain/rop02.xbm         2	
X bm-plain/rop03.xbm         2	
X bm-plain/rop04.xbm         2	
X bm-plain/rop05.xbm         2	
X bm-plain/rop06.xbm         2	
X bm-plain/rop07.xbm         2	
X bm-plain/rop08.xbm         2	
X bm-plain/rop09.xbm         2	
X bm-plain/rop10.xbm         2	
X bm-plain/rop11.xbm         2	
X bm-plain/rop12.xbm         2	
X bm-plain/rop13.xbm         2	
X bm-plain/rop14.xbm         2	
X bm-plain/rop15.xbm         3	
X playing.c                  2	
X tetris.c                   1	
X tetris.h                   1	
X tetris.man                 2	
X ticon.xbm                  2	
X utils.c                    1	
END_OF_FILE
if test 1695 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test ! -d 'X11' ; then
    echo shar: Creating directory \"'X11'\"
    mkdir 'X11'
fi
if test -f 'X11/Xfuncs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'X11/Xfuncs.h'\"
else
echo shar: Extracting \"'X11/Xfuncs.h'\" \(1665 characters\)
sed "s/^X//" >'X11/Xfuncs.h' <<'END_OF_FILE'
X/*
X * $XConsortium: Xfuncs.h,v 1.8 91/04/17 09:27:52 rws Exp $
X * 
X * Copyright 1990 by the Massachusetts Institute of Technology
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided 
X * that the above copyright notice appear in all copies and that both that 
X * copyright notice and this permission notice appear in supporting 
X * documentation, and that the name of M.I.T. not be used in advertising
X * or publicity pertaining to distribution of the software without specific, 
X * written prior permission. M.I.T. makes no representations about the 
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X *
X */
X
X#ifndef _XFUNCS_H_
X#define _XFUNCS_H_
X
X#include <X11/Xosdefs.h>
X
X#ifdef X_USEBFUNCS
Xvoid bcopy();
Xvoid bzero();
Xint bcmp();
X#else
X#if (__STDC__ && !defined(X_NOT_STDC_ENV) && !defined(sun) && !defined(macII)) || defined(SVR4) || defined(hpux) || defined(_IBMR2)
X#include <string.h>
X#define bcopy(b1,b2,len) memmove(b2, b1, (size_t)(len))
X#define bzero(b,len) memset(b, 0, (size_t)(len))
X#define bcmp(b1,b2,len) memcmp(b1, b2, (size_t)(len))
X#else
X#ifdef sgi
X#include <bstring.h>
X#else
X#ifdef SYSV
X#include <memory.h>
X#if defined(_XBCOPYFUNC) && !defined(macII)
X#define bcopy _XBCOPYFUNC
X#define _XNEEDBCOPYFUNC
X#endif
Xvoid bcopy();
X#define bzero(b,len) memset(b, 0, len)
X#define bcmp(b1,b2,len) memcmp(b1, b2, len)
X#else /* bsd */
Xvoid bcopy();
Xvoid bzero();
Xint bcmp();
X#endif /* SYSV */
X#endif /* sgi */
X#endif /* __STDC__ and relatives */
X#endif /* X_USEBFUNCS */
X
X#endif /* _XFUNCS_H_ */
END_OF_FILE
if test 1665 -ne `wc -c <'X11/Xfuncs.h'`; then
    echo shar: \"'X11/Xfuncs.h'\" unpacked with wrong size!
fi
# end of 'X11/Xfuncs.h'
fi
if test ! -d 'bm-3d' ; then
    echo shar: Creating directory \"'bm-3d'\"
    mkdir 'bm-3d'
fi
if test ! -d 'bm-plain' ; then
    echo shar: Creating directory \"'bm-plain'\"
    mkdir 'bm-plain'
fi
if test -f 'tetris.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tetris.c'\"
else
echo shar: Extracting \"'tetris.c'\" \(12131 characters\)
sed "s/^X//" >'tetris.c' <<'END_OF_FILE'
X/*
X# GENERIC X-WINDOW-BASED TETRIS
X#
X#	tetris.c
X#
X###
X#
X#  Copyright (C) 1992 - 93              Q. Alex Zhao, azhao@cc.gatech.edu
X#
X#			All Rights Reserved
X#
X#  Permission to use, copy, modify, and distribute this software and
X#  its documentation for any purpose and without fee is hereby granted,
X#  provided that the above copyright notice appear in all copies and
X#  that both that copyright notice and this permission notice appear in
X#  supporting documentation, and that the name of the author not be
X#  used in advertising or publicity pertaining to distribution of the
X#  software without specific, written prior permission.
X#
X#  This program is distributed in the hope that it will be "playable",
X#  but WITHOUT ANY WARRANTY; without even the implied warranty of
X#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
X#
X*/
X
X#include "tetris.h"
X
X/*** variables ***/
X
Xchar            myDisplayName[256];
XDisplay        *display;
Xint             screen_num;
XVisual         *visual;
XBool            useColor = True;
XColormap        colormap;
XWindow          mainWin, blockWin;
XCursor          theCursor;
XXFontStruct    *bigFont, *tinyFont;
Xunsigned long   fg, bg;
X
XXSizeHints      sizehints, iconsizehints;
XXWMHints        wmhints = {
X    InputHint | StateHint | IconPixmapHint,
X    True,			/* input mode */
X    NormalState,		/* normal */
X    0,				/* icon pixmap */
X    0,				/* icon window */
X    0, 0,			/* icon position */
X    0				/* icon mask pixmap - not used */
X};
X
Xint             range = NUM_THINGS;
XBool            bonusMode = False;
X
Xchar            myHome[FILENAMELEN];
Xint             level = 3, prefilled = 0, score = 0, rows = 0;
XBool            showNext = False, beep = False, use3D = True;
Xscore_t         myscore;
X
Xstatic int      opTableEntries = 17;
Xstatic XrmOptionDescRec opTable[] = {
X    {"-s", "*scoresOnly", XrmoptionNoArg, (caddr_t) "yes"},
X    {"-l", "*startLevel", XrmoptionSepArg, (caddr_t) NULL},
X    {"-p", "*preFilledLines", XrmoptionSepArg, (caddr_t) NULL},
X    {"-showNext", "*showNext", XrmoptionNoArg, (caddr_t) "yes"},
X    {"-beep", "*beep", XrmoptionNoArg, (caddr_t) "yes"},
X    {"-plain", "*plain", XrmoptionNoArg, (caddr_t) "yes"},
X    {"-display", ".display", XrmoptionSepArg, (caddr_t) NULL},
X    {"-geometry", "*geometry", XrmoptionSepArg, (caddr_t) NULL},
X    {"-iconGeometry", "*iconGeometry", XrmoptionSepArg, (caddr_t) NULL},
X    {"-background", "*background", XrmoptionSepArg, (caddr_t) NULL},
X    {"-bg", "*background", XrmoptionSepArg, (caddr_t) NULL},
X    {"-foreground", "*foreground", XrmoptionSepArg, (caddr_t) NULL},
X    {"-fg", "*foreground", XrmoptionSepArg, (caddr_t) NULL},
X    {"-bigFont", "*bigFont", XrmoptionSepArg, (caddr_t) NULL},
X    {"-tinyFont", "*tinyFont", XrmoptionSepArg, (caddr_t) NULL},
X    {"-u", "*playerName", XrmoptionSepArg, (caddr_t) NULL},
X    {"-xrm", NULL, XrmoptionResArg, (caddr_t) NULL}
X};
Xstatic XrmDatabase cmmDB = (XrmDatabase) NULL, rDB = (XrmDatabase) NULL;
X
Xstatic void parseOpenDisp();
Xstatic void Usage();
Xstatic void getDefaults();
X
X/* ------------------------------------------------------------------ */
X
Xvoid
Xmain(argc, argv)
X    int             argc;
X    char           *argv[];
X{
X    (void) fprintf(stderr,
X		   "                 GENERIC TETRIS V3.0.0\n");
X    (void) fprintf(stderr,
X	 "Copyright (C) 1992-93      Q. Alex Zhao, azhao@cc.gatech.edu\n");
X    (void) fprintf(stderr,
X	 "     GENERIC TETRIS comes with ABSOLUTELY NO WARRANTY.\n\n");
X
X    sizehints.flags = PMinSize | PMaxSize | PPosition | PSize | USSize;
X    iconsizehints.flags = PPosition | PSize;
X    iconsizehints.width = iconsizehints.height = 48;
X
X    parseOpenDisp(&argc, argv);
X    getDefaults();
X    inits(argc, argv);
X    playing();
X    /* never come to here */
X}
X
X/* ------------------------------------------------------------------ */
X
Xstatic void
XparseOpenDisp(argc, argv)
X    int            *argc;
X    char           *argv[];
X{
X    struct passwd  *pw;
X    XrmValue        value;
X    char           *str_type[20];
X    XVisualInfo     vtmp, *vinfo;
X    int             n = 1;
X
X    XrmInitialize();
X
X    myDisplayName[0] = '\0';
X
X    XrmParseCommand(&cmmDB, opTable, opTableEntries, "tetris", argc, argv);
X
X    /* check for any arguments left */
X    if (*argc != 1) {
X	Usage(argv[0]);
X    }
X    /* only print out the scores? */
X    if (XrmGetResource(cmmDB, "tetris.scoresOnly", "Tetris.ScoresOnly",
X		       str_type, &value) == True) {
X	showScores(0);
X	exit(0);
X    }
X    /* get display now */
X    if (XrmGetResource(cmmDB, "tetris.display", "Tetris.Display",
X		       str_type, &value) == True)
X	(void) strncpy(myDisplayName, value.addr, ZLIM(value.size, 255));
X    myDisplayName[255] = '\0';
X
X    if (!(display = XOpenDisplay(myDisplayName))) {
X	(void) fprintf(stderr, "%s: Can't open display '%s'\n",
X		       argv[0], XDisplayName(myDisplayName));
X	exit(1);
X    }
X
X    screen_num = DefaultScreen(display);
X    visual = DefaultVisual(display, screen_num);
X    colormap = DefaultColormap(display, screen_num);
X    vtmp.visualid = XVisualIDFromVisual(visual);
X
X    if ((vinfo = XGetVisualInfo(display, VisualIDMask, &vtmp, &n)) != NULL) {
X	if ((vinfo->class == GrayScale) || (vinfo->class == StaticGray)) {
X	    useColor = False;
X	}
X	XFree((unsigned char *) vinfo);
X    } else {
X	useColor = False;
X    }
X
X    /* setup user information */
X    (void) gethostname(myscore.myhost, NAMELEN);
X
X    setpwent();
X    pw = getpwuid(getuid());
X    if (pw == NULL) {		/* impossible? */
X	(void) sprintf(myscore.myname, "%d", getuid());
X	myHome[0] = '.';
X	myHome[1] = '/';
X	myHome[2] = '\0';
X    } else {
X	(void) strncpy(myscore.myname, pw->pw_name, NAMELEN);
X	(void) strncpy(myHome, pw->pw_dir, FILENAMELEN);
X    }
X    endpwent();
X    myscore.myname[NAMELEN - 1] = '\0';
X    myscore.myhost[NAMELEN - 1] = '\0';
X    myHome[FILENAMELEN - 1] = '\0';
X}
X
X/* ------------------------------------------------------------------ */
X
Xstatic void
XUsage(argv0)
X    char           *argv0;
X{
X    (void) fprintf(stderr,
X	"Usage: %s [-s] [-l <starting level>]\n", argv0);
X    (void) fprintf(stderr,
X	"   [-p <prefilled rows>] [-plain] [-showNext] [-beep] [-u <name>]\n");
X    (void) fprintf(stderr,
X	"   [-display <display>] [-geometry <geometry>] [-iconGeometry <icon geometry>]\n");
X    (void) fprintf(stderr,
X	"   [-fg <foreground>] [-bg <background>] [-bigFont <font>] [-tinyFont <font>]\n");
X    (void) fprintf(stderr,
X	"   [-xrm <resource specifications>]\n");
X
X    exit(1);
X}
X
X/* ------------------------------------------------------------------ */
X
Xstatic void
XgetDefaults()
X{
X    XrmDatabase     homeDB, serverDB, appDB;
X    char            filenamebuf[FILENAMELEN];
X    char           *filename = &filenamebuf[0];
X    char           *env;
X    char           *classname = "Tetris";
X    char            name[255], geoStr[20], icongeoStr[20];
X    XrmValue        value;
X    char           *str_type[20];
X    int             x, y;
X    unsigned int    w, h;
X    long            flags;
X
X    (void) strcpy(name, "/usr/lib/X11/app-defaults/");
X    (void) strcat(name, classname);
X
X    /* Get application defaults file, if any */
X    appDB = XrmGetFileDatabase(name);
X    (void) XrmMergeDatabases(appDB, &rDB);
X
X    if (XResourceManagerString(display) != NULL) {
X	serverDB = XrmGetStringDatabase(XResourceManagerString(display));
X    } else {
X	(void) strcpy(filename, myHome);
X	(void) strcat(filename, "/.Xdefaults");
X	serverDB = XrmGetFileDatabase(filename);
X    }
X    XrmMergeDatabases(serverDB, &rDB);
X
X    if ((env = getenv("XENVIRONMENT")) == NULL) {
X	int             len;
X
X	env = &filenamebuf[0];
X	(void) strcpy(env, myHome);
X	len = strlen(env);
X	env[len++] = '/';
X	(void) gethostname(env + len, FILENAMELEN - len);
X    }
X    homeDB = XrmGetFileDatabase(env);
X    XrmMergeDatabases(homeDB, &rDB);
X
X    XrmMergeDatabases(cmmDB, &rDB);
X
X    /* starting levels */
X
X    if (XrmGetResource(rDB, "tetris.startLevel", "Tetris.StartLevel",
X		       str_type, &value) == True) {
X	if ((sscanf(value.addr, "%d", &level) <= 0) ||
X		(level < 0) || (level >= NUM_LEVELS)) {
X	    (void) fprintf(stderr, "Tetris: Invalid level.\n");
X	    exit(1);
X	}
X    }
X
X    /* prefilled lines */
X
X    if (XrmGetResource(rDB, "tetris.preFilledLines", "Tetris.PreFilledLines",
X		       str_type, &value) == True) {
X	if ((sscanf(value.addr, "%d", &prefilled) <= 0) ||
X		(prefilled < 0) || (prefilled >= ROWS - THINGSIZE)) {
X	    (void) fprintf(stderr, "Tetris: Invalid prefilled lines.\n");
X	    exit(1);
X	}
X    }
X
X    /* show next */
X
X    if (XrmGetResource(rDB, "tetris.showNext", "Tetris.ShowNext",
X			str_type, &value) == True) {
X	showNext = True;
X    }
X
X    /* bitmaps */
X
X    if (XrmGetResource(rDB, "tetris.plain", "Tetris.Plain",
X			str_type, &value) == True) {
X	use3D = False;
X    }
X
X    /* beep */
X
X    if (XrmGetResource(rDB, "tetris.beep", "Tetris.Beep",
X			str_type, &value) == True) {
X	beep = True;
X    }
X
X    /*** get foreground/background colors ***/
X
X    if (XrmGetResource(rDB, "tetris.foreground", "Tetris.Foreground",
X		       str_type, &value) == True) {
X	(void) strncpy(name, value.addr, ZLIM(value.size, 255));
X	name[254] = '\0';
X	fg = getColor(name);
X    } else
X	fg = BlackPixel(display, screen_num);
X
X    if (XrmGetResource(rDB, "tetris.background", "Tetris.Background",
X		       str_type, &value) == True) {
X	(void) strncpy(name, value.addr, ZLIM(value.size, 255));
X	name[254] = '\0';
X	bg = getColor(name);
X    } else
X	bg = WhitePixel(display, screen_num);
X
X    if (bg == fg) {
X	bg = WhitePixel(display, screen_num);
X	fg = BlackPixel(display, screen_num);
X    }
X
X    /*** get geometry info ***/
X
X    if (XrmGetResource(rDB, "tetris.geometry", "Tetris.Geometry",
X		       str_type, &value) == True) {
X	(void) strncpy(geoStr, value.addr, ZLIM(value.size, 20));
X	geoStr[19] = '\0';
X    } else {
X	geoStr[0] = '\0';
X    }
X
X    flags = XParseGeometry(geoStr, &x, &y, &w, &h);
X    if ((WidthValue | HeightValue) & flags)
X	Usage("tetris");
X
X    if (XValue & flags) {
X	if (XNegative & flags)
X	    x = DisplayWidth(display, screen_num) + x - sizehints.width;
X	sizehints.x = x;
X    }
X    if (YValue & flags) {
X	if (YNegative & flags)
X	    y = DisplayHeight(display, screen_num) + y - sizehints.height;
X	sizehints.y = y;
X    }
X
X    /*** get icon geometry info ***/
X
X    if (XrmGetResource(rDB, "tetris.iconGeometry", "Tetris.IconGeometry",
X		       str_type, &value) == True) {
X	(void) strncpy(icongeoStr, value.addr, ZLIM(value.size, 20));
X	icongeoStr[19] = '\0';
X    } else {
X	icongeoStr[0] = '\0';
X    }
X
X    flags = XParseGeometry(icongeoStr, &x, &y, &w, &h);
X    if ((WidthValue | HeightValue) & flags)
X	Usage("tetris");
X
X    if (XValue & flags) {
X	if (XNegative & flags)
X	    x = DisplayWidth(display, screen_num) + x - iconsizehints.width;
X	wmhints.flags |= IconPositionHint;
X	wmhints.icon_x = x;
X	iconsizehints.x = x;
X    }
X    if (YValue & flags) {
X	if (YNegative & flags)
X	    y = DisplayHeight(display, screen_num) + y - iconsizehints.height;
X	wmhints.flags |= IconPositionHint;
X	wmhints.icon_y = y;
X	iconsizehints.y = y;
X    }
X
X    /*** get fonts ***/
X
X    if (XrmGetResource(rDB, "tetris.bigFont", "Tetris.BigFont",
X		       str_type, &value) == True) {
X	(void) strncpy(name, value.addr, ZLIM(value.size, 255));
X	name[254] = '\0';
X    } else {
X	(void) strcpy(name, BIGFONT);
X    }
X    if ((bigFont = XLoadQueryFont(display, name)) == NULL) {
X	(void) fprintf(stderr, "Tetris: can't open font '%s'.\n", name);
X	exit(1);
X    }
X    if (XrmGetResource(rDB, "tetris.tinyFont", "Tetris.TinyFont",
X		       str_type, &value) == True) {
X	(void) strncpy(name, value.addr, ZLIM(value.size, 255));
X	name[254] = '\0';
X    } else {
X	(void) strcpy(name, TINYFONT);
X    }
X    if ((tinyFont = XLoadQueryFont(display, name)) == NULL) {
X	(void) fprintf(stderr, "Tetris: can't open font '%s'.\n", name);
X	exit(1);
X    }
X
X    /* player name */
X
X    if (XrmGetResource(rDB, "tetris.playerName", "Tetris.PlayerName",
X		       str_type, &value) == True) {
X	(void) strncpy(myscore.myname, value.addr, ZLIM(value.size, 20));
X	myscore.myname[19] = '\0';
X    }
X
X    /*
X     * clean up
X     */
X    XrmDestroyDatabase(rDB);
X}
X
X/* ------------------------------------------------------------------ */
END_OF_FILE
if test 12131 -ne `wc -c <'tetris.c'`; then
    echo shar: \"'tetris.c'\" unpacked with wrong size!
fi
# end of 'tetris.c'
fi
if test -f 'tetris.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tetris.h'\"
else
echo shar: Extracting \"'tetris.h'\" \(4808 characters\)
sed "s/^X//" >'tetris.h' <<'END_OF_FILE'
X/*
X# GENERIC X-WINDOW-BASED TETRIS
X#
X#	tetris.h
X#
X###
X#
X#  Copyright (C) 1992 - 93              Q. Alex Zhao, azhao@cc.gatech.edu
X#
X#			All Rights Reserved
X#
X#  Permission to use, copy, modify, and distribute this software and
X#  its documentation for any purpose and without fee is hereby granted,
X#  provided that the above copyright notice appear in all copies and
X#  that both that copyright notice and this permission notice appear in
X#  supporting documentation, and that the name of the author not be
X#  used in advertising or publicity pertaining to distribution of the
X#  software without specific, written prior permission.
X#
X#  This program is distributed in the hope that it will be "playable",
X#  but WITHOUT ANY WARRANTY; without even the implied warranty of
X#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
X#
X*/
X
X/*** Common headers ***/
X
X#include	<stdio.h>
X#include	<math.h>
X#include	<pwd.h>
X#include	<errno.h>
X
X#include	<X11/Xlib.h>
X#include	<X11/Xutil.h>
X#include	<X11/Xresource.h>
X#include	<X11/cursorfont.h>
X#include	<X11/keysym.h>
X#include	<X11/Xos.h>
X#include	<X11/Xfuncs.h>
X#include	<X11/Xfuncproto.h>
X
X#ifndef	X_NOT_STDC_ENV
X#include	<stdlib.h>
X#else
Xextern char    *getenv(
X#if	NeedFunctionPrototypes
X    char *
X#endif
X);
X#endif
X
X#ifdef	X_NOT_POSIX
Xextern int      getuid(
X#if	NeedFunctionPrototypes
X    void
X#endif
X);
Xextern struct passwd *getpwuid(
X#if	NeedFunctionPrototypes
X    int
X#endif
X);
X#endif
X
X#ifdef	_AIX
X#include	<sys/select.h>
X#endif
X
X/*** for lseek ***/
X
X#ifndef	SEEK_SET
X#define	SEEK_SET	L_SET
X#endif
X
X#ifndef	SEEK_CUR
X#define	SEEK_CUR	L_INCR
X#endif
X
X#ifndef	SEEK_END
X#define	SEEK_END	L_XTND
X#endif
X
X/*** random generator ***/
X
X#if	defined(HAS_48)		/* Use lrand48() and srand48() */
X#define	LRAND()		lrand48()
X#define	SRAND(X)	srand48((long) (X))
Xextern long     lrand48(
X#if	NeedFunctionPrototypes
X    void
X#endif
X);
X
X#else
X#if	defined(HAS_RANDOM)	/* Use random() and srandom() */
X
X#define	LRAND()		random()
X#define	SRAND(X)	srandom((unsigned int) (X))
Xextern long     random(
X#if	NeedFunctionPrototypes
X    void
X#endif
X);
X
X#else				/* Use rand() and srand() */
X
X#define	LRAND()		((long) rand())
X#define	SRAND(X)	srand(X)
X
X#endif
X#endif
X
X/*** macros ***/
X
X#define	ZLIM(X, Y)	(((int) X) < (Y) ? ((int) X) : (Y))
X
X/*** constants ***/
X
X#ifndef	SCOREFILE
X#define	SCOREFILE	"/usr/games/lib/tetris.scores"
X#endif
X
X#define	BIGFONT		"12x24"
X#define	TINYFONT	"6x12"
X#define	BVOLUME		-90
X#define NUM_FLASHES	16
X
X#define BONUSIN     2500
X#define BONUSOUT    1000
X#define SAMPLERATE  5000000
X
X#define	MILLION		1000000
X#define	MAXSCORES	3
X#define	SHOWSCORES	15
X#define	NAMELEN		12
X#define	FILENAMELEN	1024
X
X#define	MSG_PAUSED	"PAUSED"
X#define	MSG_END		"GAME OVER"
X#define	MSG_TITLE	"TETRIS"
X#define	MSG_AUTHOR	"by Q. Alex Zhao"
X
X#define	NUM_LEVELS	18
X#define	ROWS		20
X#define	COLS		10
X
X#define	BOXSIZE		30
X#define	OFFSET		20
X#define	THINGSIZE	4
X#define	NUM_THINGS	7
X#define	NUM_BTHINGS	12
X#define NUM_BITMAPS	16
X
X/*** types ***/
X
Xtypedef enum {FALL, DROP, ROTATE, LEFT, RIGHT, REFLECT} move_t;
X
Xtypedef struct {
X    char            myname[NAMELEN], myhost[NAMELEN], mydate[27];
X    char            score[10];
X    char            level[4];
X    char            rows[5];
X}               score_t;
X#define	SCORESIZE	sizeof(score_t)
X
Xtypedef struct {
X    int             map[THINGSIZE][THINGSIZE];
X    int             xpos, ypos;
X    int             size, px, py, cid, gx, gy;
X}               thing_t;
X
X/*** variables defined in "tetris.c" ***/
X
Xextern Display *display;
Xextern int      screen_num;
Xextern Visual  *visual;
Xextern Bool     useColor;
Xextern Bool     use3D;
Xextern Colormap colormap;
Xextern Window   mainWin, blockWin;
Xextern Cursor   theCursor;
Xextern XFontStruct *bigFont, *tinyFont;
Xextern unsigned long fg, bg;
X
Xextern XSizeHints sizehints, iconsizehints;
Xextern XWMHints wmhints;
X
Xextern char     myHome[FILENAMELEN];
Xextern int      level, prefilled, score, rows, range;
Xextern Bool     showNext, beep, bonusMode;
Xextern score_t  myscore;
X
X/*** variables defined in "utils.c" ***/
X
Xextern Atom     delw;
X
X/*** variables defined in "playing.c" ***/
X
X/*** functions ***/
X
Xextern unsigned long getColor();
Xextern void     showScores();
Xextern void     inits();
Xextern void     playing();
Xextern void     realTime();
Xextern void     newThing();
Xextern Bool     evGotNewThing();
Xextern void     redrawAll();
Xextern void     drawTitle();
Xextern void     drawStatus();
Xextern void     drawField();
Xextern void     drawThing();
Xextern void     drawThingDiff();
Xextern void     drawNext();
Xextern void     gameOver();
Xextern void     banner();
Xextern void     clearNext();
Xextern void     putBox();
Xextern void     tryMove();
Xextern Bool     atBottom();
Xextern Bool     overlapping();
Xextern int      checkLines();
Xextern void     drawBox();
Xextern int      nrand();
X
END_OF_FILE
if test 4808 -ne `wc -c <'tetris.h'`; then
    echo shar: \"'tetris.h'\" unpacked with wrong size!
fi
# end of 'tetris.h'
fi
if test -f 'utils.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils.c'\"
else
echo shar: Extracting \"'utils.c'\" \(25559 characters\)
sed "s/^X//" >'utils.c' <<'END_OF_FILE'
X/*
X# GENERIC X-WINDOW-BASED TETRIS
X#
X#	utils.c
X#
X###
X#
X#  Copyright (C) 1992 - 93              Q. Alex Zhao, azhao@cc.gatech.edu
X#
X#			All Rights Reserved
X#
X#  Permission to use, copy, modify, and distribute this software and
X#  its documentation for any purpose and without fee is hereby granted,
X#  provided that the above copyright notice appear in all copies and
X#  that both that copyright notice and this permission notice appear in
X#  supporting documentation, and that the name of the author not be
X#  used in advertising or publicity pertaining to distribution of the
X#  software without specific, written prior permission.
X#
X#  This program is distributed in the hope that it will be "playable",
X#  but WITHOUT ANY WARRANTY; without even the implied warranty of
X#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
X#
X*/
X
X#include	"tetris.h"
X
X#include	"ticon.xbm"
X
X#include	"bm-3d/rot00.xbm"
X#include	"bm-3d/rot01.xbm"
X#include	"bm-3d/rot02.xbm"
X#include	"bm-3d/rot03.xbm"
X#include	"bm-3d/rot04.xbm"
X#include	"bm-3d/rot05.xbm"
X#include	"bm-3d/rot06.xbm"
X#include	"bm-3d/rot07.xbm"
X#include	"bm-3d/rot08.xbm"
X#include	"bm-3d/rot09.xbm"
X#include	"bm-3d/rot10.xbm"
X#include	"bm-3d/rot11.xbm"
X#include	"bm-3d/rot12.xbm"
X#include	"bm-3d/rot13.xbm"
X#include	"bm-3d/rot14.xbm"
X#include	"bm-3d/rot15.xbm"
X
X#include	"bm-plain/rop00.xbm"
X#include	"bm-plain/rop01.xbm"
X#include	"bm-plain/rop02.xbm"
X#include	"bm-plain/rop03.xbm"
X#include	"bm-plain/rop04.xbm"
X#include	"bm-plain/rop05.xbm"
X#include	"bm-plain/rop06.xbm"
X#include	"bm-plain/rop07.xbm"
X#include	"bm-plain/rop08.xbm"
X#include	"bm-plain/rop09.xbm"
X#include	"bm-plain/rop10.xbm"
X#include	"bm-plain/rop11.xbm"
X#include	"bm-plain/rop12.xbm"
X#include	"bm-plain/rop13.xbm"
X#include	"bm-plain/rop14.xbm"
X#include	"bm-plain/rop15.xbm"
X
XAtom            delw;
X
Xstatic GC       revGC, bigGC, tinyGC, xorGC;
Xstatic GC       thingGCs[NUM_THINGS];
X
Xstatic char    *winName = "GENERIC TETRIS";
Xstatic char    *iconName = "TETRIS";
X
Xstatic int      titleLen, titleWidth, authorLen, authorWidth;
Xstatic int      titleX, titleY, authorX, authorY;
Xstatic int      sX;
Xstatic int      sLevelY, sRowsY, sScoreY;
X
Xstatic int      topRWidth, topWidth, topHeight, topMidX, topMidY;
Xstatic int      frameX, frameY, frameW, frameH;
X
Xstatic char    *bitmap_data_3d[NUM_BITMAPS] = {
X    rot00_bits, rot01_bits, rot02_bits, rot03_bits, rot04_bits, rot05_bits,
X    rot06_bits, rot07_bits, rot08_bits, rot09_bits, rot10_bits, rot11_bits,
X    rot12_bits, rot13_bits, rot14_bits, rot15_bits
X};
X
Xstatic char    *bitmap_data_plain[NUM_BITMAPS] = {
X    rop00_bits, rop01_bits, rop02_bits, rop03_bits, rop04_bits, rop05_bits,
X    rop06_bits, rop07_bits, rop08_bits, rop09_bits, rop10_bits, rop11_bits,
X    rop12_bits, rop13_bits, rop14_bits, rop15_bits
X};
X
Xstatic thing_t  possible[NUM_THINGS + NUM_BTHINGS][4] = {
X    {
X    {{{0, 0, 0, 0}, {4, 5, 5, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 4, 0, 0, 0, 1, 1},
X    {{{0, 2, 0, 0}, {0, 10, 0, 0}, {0, 10, 0, 0}, {0, 8, 0, 0}}, 0, 0, 4, 0, 1, 0, 1, 1},
X    {{{0, 0, 0, 0}, {4, 5, 5, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 4, 0, 2, 0, 1, 1},
X    {{{0, 2, 0, 0}, {0, 10, 0, 0}, {0, 10, 0, 0}, {0, 8, 0, 0}}, 0, 0, 4, 0, 3, 0, 1, 1}
X    },
X
X    {
X    {{{0, 2, 0, 0}, {0, 10, 0, 0}, {4, 9, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 1, 0, 0, 2, 1},
X    {{{2, 0, 0, 0}, {12, 5, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 1, 1, 0, 1, 0},
X    {{{6, 1, 0, 0}, {10, 0, 0, 0}, {8, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 1, 2, 0, 0, 0},
X    {{{4, 5, 3, 0}, {0, 0, 8, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 1, 3, 0, 0, 2}
X    },
X
X    {
X    {{{2, 0, 0, 0}, {10, 0, 0, 0}, {12, 1, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 2, 0, 0, 2, 0},
X    {{{6, 5, 1, 0}, {8, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 2, 1, 0, 0, 0},
X    {{{4, 3, 0, 0}, {0, 10, 0, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 2, 2, 0, 0, 1},
X    {{{0, 0, 2, 0}, {4, 5, 9, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 2, 3, 0, 1, 2}
X    },
X
X    {
X    {{{0, 2, 0, 0}, {4, 11, 0, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 3, 0, 0, 1, 1},
X    {{{0, 2, 0, 0}, {4, 13, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 3, 1, 0, 1, 1},
X    {{{2, 0, 0, 0}, {14, 1, 0, 0}, {8, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 3, 2, 0, 1, 0},
X    {{{4, 7, 1, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 3, 3, 0, 0, 1}
X    },
X
X    {
X    {{{2, 0, 0, 0}, {12, 3, 0, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 4, 0, 0, 1, 0},
X    {{{0, 6, 1, 0}, {4, 9, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 4, 1, 0, 0, 1},
X    {{{2, 0, 0, 0}, {12, 3, 0, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 4, 2, 0, 1, 1},
X    {{{0, 6, 1, 0}, {4, 9, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 4, 3, 0, 1, 1}
X    },
X
X    {
X    {{{0, 2, 0, 0}, {6, 9, 0, 0}, {8, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 5, 0, 0, 1, 0},
X    {{{4, 3, 0, 0}, {0, 12, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 5, 1, 0, 0, 1},
X    {{{0, 2, 0, 0}, {6, 9, 0, 0}, {8, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 5, 2, 0, 1, 1},
X    {{{4, 3, 0, 0}, {0, 12, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 5, 3, 0, 1, 1}
X    },
X
X    {
X    {{{6, 3, 0, 0}, {12, 9, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 2, 6, 0, 0, 0, 0},
X    {{{6, 3, 0, 0}, {12, 9, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 2, 6, 1, 0, 0, 0},
X    {{{6, 3, 0, 0}, {12, 9, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 2, 6, 2, 0, 0, 0},
X    {{{6, 3, 0, 0}, {12, 9, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 2, 6, 3, 0, 0, 0}
X    },
X
X    /* bonus mode blocks */
X
X    {
X    {{{0, 0, 0, 2}, {4, 5, 5, 9}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 4, 7, 0, 0, 1, 2},
X    {{{4, 3, 0, 0}, {0, 10, 0, 0}, {0, 10, 0, 0}, {0, 8, 0, 0}}, 0, 0, 4, 7, 1, 0, 1, 1},
X    {{{6, 5, 5, 1}, {8, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 4, 7, 2, 0, 0, 1},
X    {{{2, 0, 0, 0}, {10, 0, 0, 0}, {10, 0, 0, 0}, {12, 1, 0, 0}}, 0, 0, 4, 7, 3, 0, 2, 0}
X    },
X
X    {
X    {{{2, 0, 0, 0}, {12, 5, 5, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 4, 8, 0, 0, 1, 1},
X    {{{0, 2, 0, 0}, {0, 10, 0, 0}, {0, 10, 0, 0}, {4, 9, 0, 0}}, 0, 0, 4, 8, 1, 0, 2, 1},
X    {{{4, 5, 5, 3}, {0, 0, 0, 8}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 4, 8, 2, 0, 0, 2},
X    {{{6, 1, 0, 0}, {10, 0, 0, 0}, {10, 0, 0, 0}, {8, 0, 0, 0}}, 0, 0, 4, 8, 3, 0, 1, 0}
X    },
X
X    {
X    {{{0, 2, 0, 0}, {4, 13, 5, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 4, 9, 0, 0, 1, 1},
X    {{{0, 2, 0, 0}, {0, 10, 0, 0}, {4, 11, 0, 0}, {0, 8, 0, 0}}, 0, 0, 4, 9, 1, 0, 2, 1},
X    {{{4, 5, 7, 1}, {0, 0, 8, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 4, 9, 2, 0, 0, 2},
X    {{{2, 0, 0, 0}, {14, 1, 0, 0}, {10, 0, 0, 0}, {8, 0, 0, 0}}, 0, 0, 4, 9, 3, 0, 1, 0}
X    },
X
X    {
X    {{{0, 0, 2, 0}, {4, 5, 13, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 4, 10, 0, 0, 1, 2},
X    {{{0, 2, 0, 0}, {4, 11, 0, 0}, {0, 10, 0, 0}, {0, 8, 0, 0}}, 0, 0, 4, 10, 1, 0, 1, 1},
X    {{{4, 7, 5, 1}, {0, 8, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 4, 10, 2, 0, 0, 1},
X    {{{2, 0, 0, 0}, {10, 0, 0, 0}, {14, 1, 0, 0}, {8, 0, 0, 0}}, 0, 0, 4, 10, 3, 0, 2, 0}
X    },
X
X    {
X    {{{4, 7, 1, 0}, {0, 10, 0, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 11, 0, 0, 0, 1},
X    {{{2, 0, 0, 0}, {14, 5, 1, 0}, {8, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 11, 1, 0, 1, 0},
X    {{{0, 2, 0, 0}, {0, 10, 0, 0}, {4, 13, 1, 0}, {0, 0, 0, 0}}, 0, 0, 3, 11, 2, 0, 2, 1},
X    {{{0, 0, 2, 0}, {4, 5, 11, 0}, {0, 0, 8, 0}, {0, 0, 0, 0}}, 0, 0, 3, 11, 3, 0, 1, 2}
X    },
X
X    {
X    {{{2, 0, 0, 0}, {12, 3, 0, 0}, {0, 10, 0, 0}, {0, 8, 0, 0}}, 0, 0, 4, 12, 0, 0, 1, 1},
X    {{{0, 6, 5, 1}, {4, 9, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 4, 12, 1, 0, 0, 1},
X    {{{2, 0, 0, 0}, {10, 0, 0, 0}, {12, 3, 0, 0}, {0, 8, 0, 0}}, 0, 0, 4, 12, 2, 0, 2, 0},
X    {{{0, 0, 6, 1}, {4, 5, 9, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 4, 12, 3, 0, 1, 2}
X    },
X
X    {
X    {{{4, 3, 0, 0}, {0, 12, 5, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 4, 13, 0, 0, 1, 1},
X    {{{0, 2, 0, 0}, {0, 10, 0, 0}, {6, 9, 0, 0}, {8, 0, 0, 0}}, 0, 0, 4, 13, 1, 0, 2, 1},
X    {{{4, 5, 3, 0}, {0, 0, 12, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 4, 13, 2, 0, 0, 2},
X    {{{0, 2, 0, 0}, {6, 9, 0, 0}, {10, 0, 0, 0}, {8, 0, 0, 0}}, 0, 0, 4, 13, 3, 0, 1, 0}
X    },
X
X    {
X    {{{2, 0, 0, 0}, {12, 7, 1, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 14, 0, 0, 1, 1},
X    {{{0, 2, 0, 0}, {0, 14, 1, 0}, {4, 9, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 14, 1, 0, 1, 1},
X    {{{0, 2, 0, 0}, {4, 13, 3, 0}, {0, 0, 8, 0}, {0, 0, 0, 0}}, 0, 0, 3, 14, 2, 0, 1, 1},
X    {{{0, 6, 1, 0}, {4, 11, 0, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 14, 3, 0, 1, 1}
X    },
X
X    {
X    {{{4, 3, 0, 0}, {0, 14, 1, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 15, 0, 0, 1, 1},
X    {{{0, 2, 0, 0}, {6, 13, 1, 0}, {8, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 15, 1, 0, 1, 1},
X    {{{0, 2, 0, 0}, {4, 11, 0, 0}, {0, 12, 1, 0}, {0, 0, 0, 0}}, 0, 0, 3, 15, 2, 0, 1, 1},
X    {{{0, 0, 2, 0}, {4, 7, 9, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 15, 3, 0, 1, 1}
X    },
X
X    {
X    {{{6, 7, 1, 0}, {12, 9, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 16, 0, 0, 0, 1},
X    {{{2, 0, 0, 0}, {14, 3, 0, 0}, {12, 9, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 16, 1, 0, 1, 0},
X    {{{0, 6, 3, 0}, {4, 13, 9, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 16, 2, 0, 1, 1},
X    {{{6, 3, 0, 0}, {12, 11, 0, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 16, 3, 0, 1, 1}
X    },
X
X    {
X    {{{6, 3, 0, 0}, {12, 13, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 17, 0, 0, 1, 1},
X    {{{0, 2, 0, 0}, {6, 11, 0, 0}, {12, 9, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 17, 1, 0, 1, 1},
X    {{{4, 7, 3, 0}, {0, 12, 9, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 17, 2, 0, 0, 1},
X    {{{6, 3, 0, 0}, {14, 9, 0, 0}, {8, 0, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 17, 3, 0, 1, 0}
X    },
X
X    {
X    {{{0, 2, 0, 0}, {4, 15, 1, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 18, 0, 0, 1, 1},
X    {{{0, 2, 0, 0}, {4, 15, 1, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 18, 1, 0, 1, 1},
X    {{{0, 2, 0, 0}, {4, 15, 1, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 18, 2, 0, 1, 1},
X    {{{0, 2, 0, 0}, {4, 15, 1, 0}, {0, 8, 0, 0}, {0, 0, 0, 0}}, 0, 0, 3, 18, 3, 0, 1, 1}
X    }
X};
X
Xstatic int      checkUp[NUM_BITMAPS] = {
X    0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7
X};
Xstatic int      checkDown[NUM_BITMAPS] = {
X    0, 1, 0, 1, 4, 5, 4, 5, 8, 9, 8, 9, 12, 13, 12, 13
X};
X
Xstatic char    *thingFGs[NUM_THINGS] = {
X    "Red", "ForestGreen", "Blue", "Magenta", "DarkTurquoise", "Brown", "Black"
X};
X
Xstatic Pixmap   pms[NUM_BITMAPS];
X
Xstatic thing_t  curThing, nextThing;
Xstatic struct {
X    int             pm_num, cid;
X}               field[ROWS][COLS];
X
X/* ------------------------------------------------------------------ */
X
Xint
Xnrand(n)
X    int             n;
X{
X    return (int) (LRAND() % n);
X}
X
X/* ------------------------------------------------------------------ */
X
Xunsigned long
XgetColor(name)
X    char            name[];
X{
X    XColor          tmp;
X
X    if (!useColor) {
X	return BlackPixel(display, screen_num);
X    }
X    if (XParseColor(display, colormap, name, &tmp) == 0) {
X	(void) fprintf(stderr, "Tetris: invalid color '%s'.\n", name);
X	return BlackPixel(display, screen_num);
X    }
X    if (XAllocColor(display, colormap, &tmp) == 0) {
X	(void) fprintf(stderr, "Tetris: can't allocate color '%s'.\n", name);
X	return BlackPixel(display, screen_num);
X    }
X    return tmp.pixel;
X}
X
X/* ------------------------------------------------------------------ */
X
Xvoid
Xinits(argc, argv)
X    int             argc;
X    char           *argv[];
X{
X    XSetWindowAttributes att;
X    unsigned int    attvm;
X    XTextProperty   wName, iName;
X    XClassHint      classhints;
X    XEvent          ev;
X    XGCValues       gcv;
X    unsigned long   gcvm;
X    int             i, j;
X
X    SRAND(time(NULL));
X
X    for (i = 0; i < COLS; i++)
X	for (j = 0; j < ROWS; j++)
X	    if ((j >= ROWS - prefilled) && (nrand(2) == 0)) {
X		field[j][i].pm_num = 0;
X		field[j][i].cid = nrand(NUM_THINGS);
X	    } else {
X		field[j][i].pm_num = -1;
X		field[j][i].cid = 0;
X	    }
X
X    titleLen = strlen(MSG_TITLE);
X    titleWidth = XTextWidth(bigFont, MSG_TITLE, titleLen);
X    authorLen = strlen(MSG_AUTHOR);
X    authorWidth = XTextWidth(tinyFont, MSG_AUTHOR, authorLen);
X
X    frameW = BOXSIZE * COLS;
X    frameH = BOXSIZE * ROWS;
X    topRWidth = BOXSIZE * THINGSIZE + OFFSET * 2;
X    topHeight = frameH + OFFSET * 2 + 4;
X    if (titleWidth > topRWidth)
X	topRWidth = titleWidth;
X    if (authorWidth > topRWidth)
X	topRWidth = authorWidth;
X    topMidX = frameW + OFFSET * 2 + 4;
X    topMidY = topHeight / 2 + bigFont->ascent;
X    topWidth = topMidX + topRWidth;
X    frameX = frameY = OFFSET + 2;
X
X    titleX = (topRWidth - titleWidth) / 2 + topMidX;
X    titleY = OFFSET + 2 + bigFont->ascent;
X    authorX = (topRWidth - authorWidth) / 2 + topMidX;
X    authorY = OFFSET + 2 + bigFont->ascent + bigFont->descent + tinyFont->ascent;
X
X    sX = topMidX + OFFSET;
X    sScoreY = topHeight - OFFSET - 2 - tinyFont->descent;
X    sRowsY = sScoreY - tinyFont->descent - tinyFont->ascent - 2;
X    sLevelY = sRowsY - tinyFont->descent - tinyFont->ascent - 2;
X
X    sizehints.width = (sizehints.min_width =
X	(sizehints.max_width = topWidth));
X    sizehints.height = (sizehints.min_height =
X	(sizehints.max_height = topHeight));
X
X    theCursor = XCreateFontCursor(display, XC_exchange);
X
X    /* arrow keys */
X    XRebindKeysym(display, XK_R10, NULL, 0,
X	(unsigned char *) "j", sizeof(unsigned char));
X    XRebindKeysym(display, XK_Left, NULL, 0,
X	(unsigned char *) "j", sizeof(unsigned char));
X    XRebindKeysym(display, XK_R8, NULL, 0,
X	(unsigned char *) "k", sizeof(unsigned char));
X    XRebindKeysym(display, XK_Up, NULL, 0,
X	(unsigned char *) "k", sizeof(unsigned char));
X    XRebindKeysym(display, XK_R11, NULL, 0,
X	(unsigned char *) "k", sizeof(unsigned char));
X    XRebindKeysym(display, XK_R12, NULL, 0,
X	(unsigned char *) "l", sizeof(unsigned char));
X    XRebindKeysym(display, XK_Right, NULL, 0,
X	(unsigned char *) "l", sizeof(unsigned char));
X    XRebindKeysym(display, XK_Down, NULL, 0,
X	(unsigned char *) " ", sizeof(unsigned char));
X    XRebindKeysym(display, XK_R14, NULL, 0,
X	(unsigned char *) " ", sizeof(unsigned char));
X
X    /* create windows */
X    attvm = CWBackPixel | CWEventMask | CWDontPropagate | CWCursor;
X    att.background_pixel = bg;
X    att.event_mask = ExposureMask | KeyPressMask |
X	StructureNotifyMask | FocusChangeMask;
X    att.do_not_propagate_mask = KeyReleaseMask |
X	ButtonPressMask | ButtonReleaseMask | PointerMotionMask |
X	ButtonMotionMask | Button1MotionMask | Button2MotionMask |
X	Button3MotionMask | Button4MotionMask | Button5MotionMask;
X    att.cursor = theCursor;
X
X    mainWin = XCreateWindow(display, DefaultRootWindow(display),
X	sizehints.x, sizehints.y, topWidth, topHeight, 0,
X	CopyFromParent, InputOutput, CopyFromParent, attvm, &att);
X
X    attvm = CWBackPixel | CWBorderPixel | CWEventMask;
X    att.border_pixel = fg;
X    att.event_mask = ExposureMask;
X
X    blockWin = XCreateWindow(display, mainWin,
X	frameX-2, frameY-2, frameW, frameH, 2,
X	CopyFromParent, InputOutput, CopyFromParent, attvm, &att);
X
X    /* WM hints */
X    XStringListToTextProperty(&winName, 1, &wName);
X    XStringListToTextProperty(&iconName, 1, &iName);
X
X    wmhints.icon_pixmap = XCreateBitmapFromData(display,
X	mainWin, ticon_bits, ticon_width, ticon_height);
X    classhints.res_name = "tetris";
X    classhints.res_class = "Tetris";
X
X    XSetWMProperties(display, mainWin, &wName, &iName,
X	argv, argc, &sizehints, &wmhints, &classhints);
X
X    delw = XInternAtom(display, "WM_DELETE_WINDOW", False);
X    XSetWMProtocols(display, mainWin, &delw, 1);
X
X    /* GC's */
X
X    gcvm = GCForeground | GCBackground | GCFunction |
X	GCFont | GCGraphicsExposures;
X
X    gcv.function = GXcopy;
X    gcv.foreground = fg;
X    gcv.background = bg;
X    gcv.font = bigFont->fid;
X    gcv.graphics_exposures = False;
X    bigGC = XCreateGC(display, mainWin, gcvm, &gcv);
X
X    gcv.font = tinyFont->fid;
X    tinyGC = XCreateGC(display, mainWin, gcvm, &gcv);
X
X    gcv.foreground = bg;
X    gcv.background = fg;
X    revGC = XCreateGC(display, mainWin, gcvm, &gcv);
X
X    gcv.background = bg;
X    for (i = 0; i < NUM_THINGS; i++) {
X	gcv.foreground = getColor(thingFGs[i]);
X	if (gcv.foreground == bg)
X	    gcv.foreground = fg;
X	thingGCs[i] = XCreateGC(display, blockWin, gcvm, &gcv);
X    }
X
X    gcv.foreground = fg;
X    gcv.function = GXxor;
X    xorGC = XCreateGC(display, blockWin, gcvm, &gcv);
X
X    /* pixmaps */
X
X    if (use3D)
X	for (i = 0; i < NUM_BITMAPS; i++) {
X	    pms[i] = (Pixmap) XCreateBitmapFromData(display, blockWin,
X		bitmap_data_3d[i], BOXSIZE, BOXSIZE);
X	}
X    else for (i = 0; i < NUM_BITMAPS; i++) {
X	    pms[i] = (Pixmap) XCreateBitmapFromData(display, blockWin,
X		bitmap_data_plain[i], BOXSIZE, BOXSIZE);
X	}
X
X    /* new things */
X    newThing();
X    newThing();
X
X    /* the last thing is to wait for mapped */
X    XMapWindow(display, blockWin);
X    XMapRaised(display, mainWin);
X    XNextEvent(display, &ev);
X}
X
X/* ------------------------------------------------------------------ */
X
Xvoid
XnewThing()
X{
X    curThing = nextThing;
X    nextThing = possible[nrand(range)][nrand(4)];
X    nextThing.xpos = nrand(COLS - nextThing.size + 1);
X    nextThing.ypos = 2 - nextThing.size;
X    nextThing.cid = (bonusMode) ? nrand(NUM_THINGS) : nextThing.px;
X}
X
X/* ------------------------------------------------------------------ */
X
Xvoid
XdrawTitle()
X{
X    XDrawString(display, mainWin, bigGC,
X	titleX, titleY, MSG_TITLE, titleLen);
X    XDrawString(display, mainWin, tinyGC,
X	authorX, authorY, MSG_AUTHOR, authorLen);
X}
X
X/* ------------------------------------------------------------------ */
X
Xvoid
XdrawStatus()
X{
X    char            buf[30];
X
X    (void) sprintf(buf, "Score: %d", score);
X    XDrawImageString(display, mainWin, tinyGC, sX, sScoreY, buf, strlen(buf));
X
X    (void) sprintf(buf, "Level: %d    ", level);
X    XDrawImageString(display, mainWin, tinyGC, sX, sLevelY, buf, strlen(buf));
X
X    (void) sprintf(buf, "Rows: %d", rows);
X    XDrawImageString(display, mainWin, tinyGC, sX, sRowsY, buf, strlen(buf));
X}
X
X/* ------------------------------------------------------------------ */
X
Xvoid
XdrawBox(win, pmid, cid, x, y)
X    Window          win;
X    int             pmid, cid, x, y;
X{
X    XCopyPlane(display, pms[pmid], win, thingGCs[cid], 0, 0,
X	BOXSIZE, BOXSIZE, x, y, (unsigned long) 1);
X}
X
X/* ------------------------------------------------------------------ */
X
Xstatic void
XclearBox(x, y)
X    int             x, y;
X{
X    XFillRectangle(display, blockWin, revGC, x, y, BOXSIZE, BOXSIZE);
X}
X
X/* ------------------------------------------------------------------ */
X
Xvoid
XdrawField()
X{
X    int             i, j;
X
X    for (i = 0; i < COLS; i++)
X	for (j = 0; j < ROWS; j++)
X	    if (field[j][i].pm_num >= 0)
X		drawBox(blockWin, field[j][i].pm_num, field[j][i].cid,
X			i * BOXSIZE, j * BOXSIZE);
X}
X
X/* ------------------------------------------------------------------ */
X
Xvoid
XdrawThing()
X{
X    int             i, j;
X
X    for (i = 0; i < curThing.size; i++)
X	for (j = 0; j < curThing.size; j++)
X	    if ((curThing.ypos + j >= 0) && curThing.map[j][i])
X		drawBox(blockWin, curThing.map[j][i], curThing.cid,
X			(curThing.xpos + i) * BOXSIZE,
X			(curThing.ypos + j) * BOXSIZE);
X}
X
X/* ------------------------------------------------------------------ */
X
Xvoid
XdrawThingDiff(old)
X    thing_t        *old;
X{
X    int             i, j, ox, oy;
X
X    for (i = 0; i < curThing.size; i++)
X	for (j = 0; j < curThing.size; j++)
X	    if ((curThing.ypos + j >= 0) && curThing.map[j][i])
X		drawBox(blockWin, curThing.map[j][i], curThing.cid,
X			(curThing.xpos + i) * BOXSIZE,
X			(curThing.ypos + j) * BOXSIZE);
X
X    for (i = 0; i < curThing.size; i++)
X	for (j = 0; j < curThing.size; j++) {
X	    ox = old->xpos + i - curThing.xpos;
X	    oy = old->ypos + j - curThing.ypos;
X	    if ((old->ypos + j >= 0) && old->map[j][i] && 
X			((ox < 0) || (ox >= curThing.size) ||
X			(oy < 0) || (oy >= curThing.size) ||
X			!curThing.map[oy][ox]))
X		clearBox((old->xpos + i) * BOXSIZE, (old->ypos + j) * BOXSIZE);
X	}
X}
X
X/* ------------------------------------------------------------------ */
X
Xvoid
XdrawNext()
X{
X    int             x, y;
X    int             i, j;
X
X    x = topMidX + (topRWidth - nextThing.size * BOXSIZE) / 2;
X    y = topMidY - nextThing.size * BOXSIZE / 2;
X    for (i = 0; i < nextThing.size; i++)
X	for (j = 0; j < nextThing.size; j++)
X	    if (nextThing.map[j][i])
X		drawBox(mainWin, nextThing.map[j][i], nextThing.cid,
X		x + i * BOXSIZE, y + j * BOXSIZE);
X}
X
X/* ------------------------------------------------------------------ */
X
Xvoid
XclearNext()
X{
X    XFillRectangle(display, mainWin, revGC,
X	topMidX, topMidY - BOXSIZE * 2, topRWidth, BOXSIZE * 4);
X}
X
X/* ------------------------------------------------------------------ */
X
Xvoid
Xbanner(msg)
X    char            msg[];
X{
X    int             mlen = strlen(msg);
X    int             w = XTextWidth(bigFont, msg, mlen);
X    int             x = (topRWidth - w)/2 + topMidX;
X
X    clearNext();
X    XFillRectangle(display, mainWin, revGC,
X	x - 60, topMidY - bigFont->ascent - 5,
X	w + 120, bigFont->ascent + bigFont->descent + 10);
X    XDrawString(display, mainWin, bigGC, x, topMidY, msg, mlen);
X}
X
X/* ------------------------------------------------------------------ */
X
Xvoid
XputBox()
X{
X    int             i, j;
X    int             x = curThing.xpos, y = curThing.ypos;
X
X    for (i = 0; i < curThing.size; i++)
X	for (j = 0; j < curThing.size; j++)
X	    if ((y + j >= 0) && curThing.map[j][i]) {
X		field[y + j][x + i].pm_num = curThing.map[j][i];
X		field[y + j][x + i].cid = curThing.cid;
X	    }
X}
X
X/* ------------------------------------------------------------------ */
X
XBool
Xoverlapping()
X{
X    int             i, j;
X    int             x = curThing.xpos, y = curThing.ypos;
X
X    for (i = 0; i < curThing.size; i++)
X	for (j = 0; j < curThing.size; j++)
X	    if (curThing.map[j][i]) {
X		if ((y + j >= ROWS) || (x + i < 0) || (x + i >= COLS))
X		    return True;
X		if ((y + j >= 0) && (field[y + j][x + i].pm_num >= 0))
X		    return True;
X	    }
X
X    return False;
X}
X
X/* ------------------------------------------------------------------ */
X
XBool
XatBottom()
X{
X    int             i, j;
X    int             x = curThing.xpos, y = curThing.ypos;
X
X    for (i = 0; i < curThing.size; i++)
X	for (j = 0; j < curThing.size; j++)
X	    if ((y + j >= 0) && curThing.map[j][i]) {
X		if ((y + j >= ROWS - 1) || (x + i < 0) || (x + i >= COLS))
X		    return True;
X		if (field[y + j + 1][x + i].pm_num >= 0)
X		    return True;
X	    }
X
X    return False;
X}
X
X/* ------------------------------------------------------------------ */
X
Xvoid
XtryMove(move)
X    move_t          move;
X{
X    thing_t         old;
X    Bool            canMove = False;
X
X    old = curThing;
X
X    switch (move) {
X    case FALL:
X	curThing.ypos ++;
X	break;
X
X    case DROP:
X	do {
X	    curThing.ypos ++;
X	    score += level + prefilled;
X	} while (!overlapping());
X	curThing.ypos --;
X	score += (bonusMode ? 3 : 1) * level;
X	break;
X
X    case ROTATE:
X	curThing = possible[old.px][(old.py + 1) % 4];
X	/* xpos, ypos, cid got overwritten */
X	curThing.xpos = old.xpos + old.gy - curThing.gy;
X	curThing.ypos = old.ypos + old.gx - curThing.gx;
X	curThing.cid = old.cid;
X	break;
X
X    case LEFT:
X	curThing.xpos --;
X	break;
X
X    case RIGHT:
X	curThing.xpos ++;
X	break;
X
X    case REFLECT:
X	break;
X    }
X
X    if (overlapping()) {
X	if (move == ROTATE) {
X	    while (!canMove && (curThing.xpos + curThing.size >= COLS)) {
X		curThing.xpos --;
X		canMove = !overlapping();
X    	    }
X	    while (!canMove && (curThing.xpos < 0)) {
X		curThing.xpos ++;
X		canMove = !overlapping();
X    	    }
X	}
X    } else
X    	canMove = True;
X
X    if (canMove)
X	drawThingDiff(&old);
X    else
X	curThing = old;
X}
X
X/* ------------------------------------------------------------------ */
X
Xint
XcheckLines()
X{
X    int             lSet[ROWS], nset = 0;
X    int             i, j, y;
X
X    for (j = 0; j < ROWS; j++) {
X	lSet[j] = 0;
X	for (i = 0; i < COLS; i++)
X	    if (field[j][i].pm_num >= 0)
X		lSet[j] ++;
X	if (lSet[j] == COLS)
X	    nset ++;
X    }
X
X    if (nset) {
X	for (i = 0; i < ((NUM_FLASHES / nset) % 2) * 2; i ++) {
X	    for (j = 0; j < ROWS; j++) {
X		if (lSet[j] == COLS)
X		    XFillRectangle(display, blockWin, xorGC,
X			0, j * BOXSIZE, frameW, BOXSIZE);
X	    }
X	    XFlush(display);
X	}
X
X	for (j = ROWS-1; j >= 0; j--) {
X	    if (lSet[j] == COLS) {
X		for (y = j; y > 0; y--)
X		    for (i = 0; i < COLS; i++)
X			field[y][i] = field[y-1][i];
X		for (i = 0; i < COLS; i++)
X		    field[0][i].pm_num = -1;
X
X		XCopyArea(display, blockWin, blockWin, tinyGC,
X			0, 0, frameW, j * BOXSIZE, 0, BOXSIZE);
X		
X		XFillRectangle(display, blockWin, revGC,
X			0, 0, frameW, BOXSIZE);
X
X		for (i = j; i > 0; i--)
X		    lSet[i] = lSet[i-1];
X		lSet[0] = 0;
X
X		if (j > 0)
X		    for (i = 0; i < COLS; i++) {
X			int             tmp = field[j][i].pm_num;
X			if ((tmp >= 0) && (tmp != checkDown[tmp])) {
X			    field[j][i].pm_num = checkDown[tmp];
X			    drawBox(blockWin, field[j][i].pm_num,
X				field[j][i].cid, i * BOXSIZE, j * BOXSIZE);
X			}
X		    }
X
X		j++;
X
X		if (j < ROWS)
X		    for (i = 0; i < COLS; i++) {
X			int             tmp = field[j][i].pm_num;
X			if ((tmp >= 0) && (tmp != checkUp[tmp])) {
X			    field[j][i].pm_num = checkUp[tmp];
X			    drawBox(blockWin, field[j][i].pm_num,
X				field[j][i].cid, i * BOXSIZE, j * BOXSIZE);
X			}
X		    }
X
X		XFlush(display);
X	    }
X	}
X
X	if (beep) XBell(display, BVOLUME);
X	XSync(display, False);
X    }
X
X    return nset;
X}
X
X/* ------------------------------------------------------------------ */
X
Xvoid
XrealTime(tv)
X    struct timeval *tv;
X{
X    while (tv->tv_usec < 0) {
X	tv->tv_sec --;
X	tv->tv_usec += MILLION;
X    }
X    while (tv->tv_usec >= MILLION) {
X	tv->tv_sec ++;
X	tv->tv_usec -= MILLION;
X    }
X}
X
X/* ------------------------------------------------------------------ */
END_OF_FILE
if test 25559 -ne `wc -c <'utils.c'`; then
    echo shar: \"'utils.c'\" unpacked with wrong size!
fi
# end of 'utils.c'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
