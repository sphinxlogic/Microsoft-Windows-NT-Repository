Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i016:  ccr - colossal cave (adventure) implemented in TADS, Part01/11
Date: 12 Jul 1993 19:27:59 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2137
Approved: billr@saab.CNA.TEK.COM
Message-ID: <21sdvv$1bk@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1816

Submitted-by: David Baggett <dmb@xbar.ai.mit.edu>
Posting-number: Volume 18, Issue 16
Archive-name: ccr/part01
Environment: TADS

	[This is a rewrite of the original Colossal Cave Adventure in the
	 TADS adventure writing language. A machine independant compiled
	 game file is provided for those systems that may already have
	 the TADS runtime program, but not the compiler. Note that the
	 game file is uuencoded and split. The built.sh shell script puts
	 it back together. Runtime executables can be obtain via ftp from
	 the archive sites listed in the README.1ST file.  -br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 11)."
# Contents:  MANIFEST README.1ST src src/ccr-adv.t2 src/thingext.t
# Wrapped by billr@saab on Mon Jul 12 12:02:42 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1044 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X README.1ST                 1	
X buildit.sh                 4	
X catalog                   11	
X ccr.gam.uu1                6	
X ccr.gam.uu2                4	
X ccr.gam.uu3                5	
X ccr.gam.uu4                7	
X contact.us                 6	
X copying.doc               10	
X general.doc               11	
X readme                    11	
X readme.unix                3	
X src                        1	
X src/ccr-adv.t1             8	
X src/ccr-adv.t2             1	
X src/ccr-item.t             9	
X src/ccr-npc.t              9	
X src/ccr-room.t1            3	
X src/ccr-room.t2            2	
X src/ccr-std.t             10	
X src/ccr-verb.t            10	
X src/ccr.t                  9	
X src/close.t               11	
X src/format.t               5	
X src/help.t                11	
X src/history.t              8	
X src/makefile               9	
X src/preparse.t             7	
X src/thingext.t             1	
END_OF_FILE
if test 1044 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README.1ST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.1ST'\"
else
echo shar: Extracting \"'README.1ST'\" \(2683 characters\)
sed "s/^X//" >'README.1ST' <<'END_OF_FILE'
X
X
XDISTRIBUTION POLICY
X-------------------
X
XThis source code is copylefted under the terms of the GNU Public
XLicense.  Essentially, this means that you are allowed to do whatever
Xyou wish with this source code, provided you do not charge any money
Xfor it or for any derivative works.
X
XADVENTIONS distributes this game, but you are free to do what you will
Xwith it, provided you adhere to the terms in the GNU Public License,
Xwhich is in the file copying.doc.  Send correspondence regarding this
Xgame or original works distributed by ADVENTIONS to
X
X	ADVENTIONS
X	PO Box 851
X	Columbia, MD 21044
X
XIf you would like a catalog of releases, please enclose a SASE.  Thanks!
X
X
XIMPORTANT NOTE
X--------------
X
XThis archive contains the machine-independent versions of the game.
XThat means that the .GAM file enclosed here will run on any machine
Xthat has a TADS 2.1.0 (or later) run-time program.  It also means,
Xhowever, that the version of the run-time for *your* system is not
Xincluded in this archive, and you will have to get it separately
X(probably from the same place you got this archive).
X
XIf you're now extremely annoyed that you can't play the game you just
Xdownloaded, we apologize!  But there are simply too many machines
Xrunning TADS now for us to make an archive that will support all of
Xthem "out of the box."  Also, packaging the games this way saves space,
Xsince we don't have to include the run-time program in each archive.
X
XOnce you have the run-time program for your system (usually called "tr"
Xor "tadsr"), you can run the game by typing
X
X	tadsr <game>
X
Xwhere <game> is the filename of the TADS .GAM file.
X
XIf you have access to the Internet, you can download the latest version
Xof TADS for your system from ftp.gmd.de:
X
X	if-archive/programming/tads/*.tads2exe.*
X
XThis site is mirrored on wuarchive.wustl.edu in pub/mirrors/if-archive.
X
X
XHelp!
X-----
X
XIf you can't find the TADS system for your machine anywhere, contact
XHigh Energy Software:
X
X
X    High Energy BBS:
X       The fastest way to reach us is through the High Energy BBS.  Set
X       your modem to 14,400 bps (or any lower speed), N-8-1, and dial
X       415-493-2420.  The BBS is open to the public -- you don't need to
X       be a registered user of any our products to access the system.
X       Feel free to browse the message conferences and libraries on the
X       BBS; you may be able to find the answer to your question without
X       having to wait for a reply.  Address specific questions to SYSOP.
X
X    Internet:
X       support@hinrg.starconn.com
X
X    CompuServe:
X       73737,417
X
X    GEnie:
X       M.ROBERTS10
X
X    USPS:
X       High Energy Software
X       P.O. Box 50422
X       Palo Alto, CA  94303
X
X
END_OF_FILE
if test 2683 -ne `wc -c <'README.1ST'`; then
    echo shar: \"'README.1ST'\" unpacked with wrong size!
fi
# end of 'README.1ST'
fi
if test ! -d 'src' ; then
    echo shar: Creating directory \"'src'\"
    mkdir 'src'
fi
if test -f 'src/ccr-adv.t2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ccr-adv.t2'\"
else
echo shar: Extracting \"'src/ccr-adv.t2'\" \(47810 characters\)
sed "s/^X//" >'src/ccr-adv.t2' <<'END_OF_FILE'
X        actor.moveInto( self );
X    }
X    doLieon( actor ) =
X    {
X	// DMB changed so it says "lying."
X        "Okay, %you're% now lying on "; self.thedesc; ". ";
X        self.sitloc := actor.location;
X        actor.moveInto( self );
X    }
X    ioPutOn( actor, dobj ) =
X    {
X        dobj.doDrop( actor );
X    }
X    ioPutIn( actor, dobj ) =
X    {
X        dobj.doDrop( actor );
X    }
X;
X
X/*
X@Actor: fixeditem, movableActor
XA character in the game.  The \tt maxweight\ property specifies
Xthe maximum weight that the character can carry, and the \tt maxbulk\
Xproperty specifies the maximum bulk the character can carry.  The
X\tt actorAction( \it verb, directObject, preposition, indirectObject\ )\
Xmethod specifies what happens when the actor is given a command by
Xthe player; by default, the actor ignores the command and displays
Xa message to this effect.  The \tt isCarrying( \it object\ )\
Xmethod returns \tt true\ if the \it object\ is being carried by
Xthe actor.  The \tt actorDesc\ method displays a message when the
Xactor is in the current room; this message is displayed along with
Xa room's description when the room is entered or examined.  The
X\tt verGrab( \it object\ )\ method is called when someone tries to
Xtake an object the actor is carrying; by default, an actor won't
Xlet other characters take its possessions.
X
XIf you want the player to be able to follow the actor when it
Xleaves the room, you should define a \tt follower\ object to shadow
Xthe character, and set the actor's \tt myfollower\ property to
Xthe \tt follower\ object.  The \tt follower\ is then automatically
Xmoved around just behind the actor by the actor's \tt moveInto\
Xmethod.
X
XThe \tt isHim\ property should return \tt true\ if the actor can
Xbe referred to by the player as ``him,'' and likewise \tt isHer\
Xshould be set to \tt true\ if the actor can be referred to as ``her.''
XNote that both or neither can be set; if neither is set, the actor
Xcan only be referred to as ``it,'' and if both are set, any of ``him,''
X``her,'' or ``it'' will be accepted.
X*/
Xclass Actor: fixeditem, movableActor
X;
X
X/*
X@movableActor: qcontainer
XJust like an \tt Actor\ object, except that the player can
Xmanipulate the actor like an ordinary item.  Useful for certain
Xtypes of actors, such as small animals.
X*/
Xclass movableActor: qcontainer // A character in the game
X    isListed = nil          // described separately from room's contents
X    weight = 10             // actors are pretty heavy
X    bulk = 10               // and pretty bulky
X    maxweight = 50          // Weight that can be carried at once
X    maxbulk = 20            // Number of objects that can be carried at once
X    isactor = true          // flag that this is an actor
X    actorAction( v, d, p, i ) =
X    {
X        caps(); self.thedesc; " doesn't appear interested. ";
X        exit;
X    }
X    isCarrying( obj ) = { return( obj.isIn( self )); }
X    actorDesc =
X    {
X        caps(); self.adesc; " is here. ";
X    }
X    verGrab( item ) =
X    {
X        caps(); self.thedesc; " is carrying "; item.thedesc;
X        " and won't let %youm% have it. ";
X    }
X    verDoFollow( actor ) =
X    {
X        "But "; self.thedesc; " is right here! ";
X    }
X    moveInto( obj ) =
X    {
X        if ( self.myfollower ) self.myfollower.moveInto( self.location );
X	pass moveInto;
X    }
X    // these properties are for the format strings
X    fmtYou = "he"
X    fmtYour = "his"
X    fmtYoure = "he's"
X    fmtYoum = "him"
X    fmtYouve = "he's"
X    fmtS = "s"
X    fmtEs = "es"
X    fmtHave = "has"
X    fmtDo = "does"
X    fmtAre = "is"
X;
X
X/*
X@follower: Actor
XThis is a special object that can ``shadow'' the movements of a
Xcharacter as it moves from room to room.  The purpose of a \tt follower\
Xis to allow the player to follow an actor as it leaves a room by
Xtyping a ``follow'' command.  Each actor that is to be followed must
Xhave its own \tt follower\ object.  The \tt follower\ object should
Xdefine all of the same vocabulary words (nouns and adjectives) as the
Xactual actor to which it refers.  The \tt follower\ must also
Xdefine the \tt myactor\ property to be the \tt Actor\ object that
Xthe \tt follower\ follows.  The \tt follower\ will always stay
Xone room behind the character it follows; no commands are effective
Xwith a \tt follower\ except for ``follow.''
X*/
Xclass follower: Actor
X    sdesc = { self.myactor.sdesc; }
X    isfollower = true
X    ldesc = { caps(); self.thedesc; " is no longer here. "; }
X    actorAction( v, d, p, i ) = { self.ldesc; }
X    actorDesc = {}
X    myactor = nil   // set to the Actor to be followed
X    verDoFollow( actor ) = {}
X    doFollow( actor ) =
X    {
X        actor.travelTo( self.myactor.location );
X    }
X;
X
X/*
X@basicMe: Actor
XA default implementation of the \tt Me\ object, which is the
Xplayer character.  \tt adv.t\ defines \tt basicMe\ instead of
X\tt Me\ to allow your game to override parts of the default
Ximplementation while still using the rest, and without changing
X\tt adv.t\ itself.  To use \tt basicMe\ unchanged as your player
Xcharacter, include this in your game:  ``\tt Me: basicMe;\''.
X
XThe \tt basicMe\ object defines all of the methods and properties
Xrequired for an actor, with appropriate values for the player
Xcharacter.  The nouns ``me'' and ``myself'' are defined (``I''
Xis not defined, because it conflicts with the ``inventory''
Xcommand's minimal abbreviation of ``i'' in certain circumstances,
Xand is generally not compatible with the syntax of most player
Xcommands anyway).  The \tt sdesc\ is ``you''; the \tt thedesc\
Xand \tt adesc\ are ``yourself,'' which is appropriate for most
Xcontexts.  The \tt maxbulk\ and \tt maxweight\ properties are
Xset to 10 each; a more sophisticated \tt Me\ might include the
Xplayer's state of health in determining the \tt maxweight\ and
X\tt maxbulk\ properties.
X*/
Xclass basicMe: Actor
X    roomCheck( v ) = { return( self.location.roomCheck( v )); }
X    noun = 'me' 'myself'
X    sdesc = "you"
X    thedesc = "yourself"
X    adesc = "yourself"
X    ldesc = "You look about the same as always. "
X    maxweight = 10
X    maxbulk = 10
X    verDoFollow( actor ) =
X    {
X        if ( actor = self ) "You can't follow yourself! ";
X    }
X    actorAction( verb, dobj, prep, iobj ) = 
X    {
X    }
X    travelTo( room ) =
X    {
X        if ( room )
X        {
X	    if ( room.isobstacle )
X	    {
X	        self.travelTo( room.destination );
X	    }
X	    else if ( not ( self.location.islit or room.islit ))
X	    {
X	        darkTravel();
X	    }
X	    else
X	    {
X                if ( self.location ) self.location.leaveRoom( self );
X                self.location := room;
X                room.enterRoom( self );
X	    }
X        }
X    }
X    moveInto( room ) =
X    {
X        self.location := room;
X    }
X    // these properties are for the format strings
X    fmtYou = "you"
X    fmtYour = "your"
X    fmtYoure = "you're"
X    fmtYoum = "you"
X    fmtYouve = "you've"
X    fmtS = ""
X    fmtEs = ""
X    fmtHave = "have"
X    fmtDo = "do"
X    fmtAre = "are"
X;
X
X/*
X@decoration: fixeditem
XAn item that doesn't have any function in the game, apart from
Xhaving been mentioned in the room description.  These items
Xare immovable and can't be manipulated in any way, but can be
Xreferred to and inspected.  Liberal use of \tt decoration\ items
Xcan improve a game's playability by helping the parser recognize
Xall the words the game uses in its descriptions of rooms.
X*/
Xclass decoration: fixeditem
X;
X
X/*
X@buttonitem: fixeditem
XA button (the type you push).  The individual button's method
X\tt doPush( \it actor\ )\, which must be specified in
Xthe button, carries out the function of the button.  Note that
Xall buttons have the noun ``button'' defined.
X*/
Xclass buttonitem: fixeditem
X    noun = 'button'
X    plural = 'buttons'
X    verDoPush( actor ) = {}
X;
X
X/*
X@clothingItem: item
XSomething that can be worn.  By default, the only thing that
Xhappens when the item is worn is that its \tt isworn\ property
Xis set to \tt true\.  If you want more to happen, override the
X\tt doWear( \it actor\ )\ property.  Note that, when a \tt clothingItem\
Xis being worn, certain operations will cause it to be removed (for
Xexample, dropping it causes it to be removed).  If you want
Xsomething else to happen, override the \tt checkDrop\ method;
Xif you want to disallow such actions while the object is worn,
Xuse an \tt exit\ statement in the \tt checkDrop\ method.
X*/
Xclass clothingItem: item
X    checkDrop =
X    {
X        if ( self.isworn )
X	{
X	    "(Taking off "; self.thedesc; " first)\n";
X	}
X    }
X    doDrop( actor ) =
X    {
X        self.checkDrop;
X	pass doDrop;
X    }
X    doPutIn( actor, io ) =
X    {
X        self.checkDrop;
X	pass doPutIn;
X    }
X    doPutOn( actor, io ) =
X    {
X        self.checkDrop;
X	pass doPutOn;
X    }
X    doGiveTo( actor, io ) =
X    {
X        self.checkDrop;
X	pass doGiveTo;
X    }
X    doThrowAt( actor, io ) =
X    {
X        self.checkDrop;
X	pass doThrowAt;
X    }
X    doThrowTo( actor, io ) =
X    {
X        self.checkDrop;
X	pass doThrowTo;
X    }
X    doThrow( actor ) =
X    {
X        self.checkDrop;
X	pass doThrow;
X    }
X    moveInto( obj ) =
X    {
X        /*
X	 *   Catch any other movements with moveInto; this won't stop the
X	 *   movement from happening, but it will prevent any anamolous
X	 *   consequences caused by the object moving but still being worn.
X	 */
X        self.isworn := nil;
X	pass moveInto;
X    }
X    verDoWear( actor ) =
X    {
X        if ( self.isworn )
X        {
X            "%You're% already wearing "; self.thedesc; "! ";
X        }
X        else if ( not actor.isCarrying( self ))
X        {
X            "%You% %do%n't have "; self.thedesc; ". ";
X        }
X    }
X    doWear( actor ) =
X    {
X        "Okay, %you're% now wearing "; self.thedesc; ". ";
X        self.isworn := true;
X    }
X    verDoUnwear( actor ) =
X    {
X        if ( not self.isworn )
X        {
X            "%You're% not wearing "; self.thedesc; ". ";
X        }
X    }
X    doUnwear( actor ) =
X    {
X        "Okay, %you're% no longer wearing "; self.thedesc; ". ";
X        self.isworn := nil;
X    }
X;
X
X/*
X@obstacle: object
XAn \tt obstacle\ is used in place of a room for a direction
Xproperty.  The \tt destination\ property specifies the room that
Xis reached if the obstacle is successfully negotiated; when the
Xobstacle is not successfully negotiated, \tt destination\ should
Xdisplay an appropriate message and return \tt nil\.
X*/
Xclass obstacle: object
X    isobstacle = true
X;
X
X/*
X@doorway: fixeditem, obstacle
XA \tt doorway\ is an obstacle that impedes progress when it is closed.
XWhen the door is open (\tt isopen\ is \tt true\), the user ends up in
Xthe room specified in the \tt doordest\ property upon going through
Xthe door.  Since a doorway is an obstacle, use the door object for
Xa direction property of the room containing the door.
X
XIf \tt noAutoOpen\ is not set to \tt true\, the door will automatically
Xbe opened when the player tries to walk through the door, unless the
Xdoor is locked (\tt islocked\ = \tt true\).  If the door is locked,
Xit can be unlocked simply by typing ``unlock door'', unless the
X\tt mykey\ property is set, in which case the object specified in
X\tt mykey\ must be used to unlock the door.  Note that the door can
Xonly be relocked by the player under the circumstances that allow
Xunlocking, plus the property \tt islockable\ must be set true.
XBy default, the door is closed; set \tt isopen\ to true if the door
Xis to start out open (and be sure to open the other side as well).
X
X\tt otherside\ specifies the corresponding doorway object in the
Xdestination room (\tt doordest\), if any.  If \tt otherside\ is
Xspecified, its \tt isopen\ and \tt islocked\ properties will be
Xkept in sync automatically.
X*/
Xclass doorway: fixeditem, obstacle
X    isdoor = true           // Item can be opened and closed
X    destination =
X    {
X        if ( self.isopen ) return( self.doordest );
X	else if ( not self.islocked and not self.noAutoOpen )
X	{
X	    self.isopen := true;
X	    if ( self.otherside ) self.otherside.isopen := true;
X	    "(Opening << self.thedesc >>)\n";
X	    return( self.doordest );
X	}
X	else
X	{
X	    "%You%'ll have to open << self.thedesc >> first. ";
X	    setit( self );
X	    return( nil );
X	}
X    }
X    verDoOpen( actor ) =
X    {
X        if ( self.isopen ) "It's already open. ";
X	else if ( self.islocked ) "It's locked. ";
X    }
X    doOpen( actor ) =
X    {
X        "Opened. ";
X	self.isopen := true;
X	if ( self.otherside ) self.otherside.isopen := true;
X    }
X    verDoClose( actor ) =
X    {
X        if ( not self.isopen ) "It's already closed. ";
X    }
X    doClose( actor ) =
X    {
X        "Closed. ";
X	self.isopen := nil;
X	if ( self.otherside ) self.otherside.isopen := nil;
X    }
X    verDoLock( actor ) =
X    {
X        if ( self.islocked ) "It's already locked! ";
X	else if ( not self.islockable ) "It can't be locked. ";
X	else if ( self.isopen ) "%You%'ll have to close it first. ";
X    }
X    doLock( actor ) =
X    {
X        if ( self.mykey = nil )
X	{
X	    "Locked. ";
X	    self.islocked := true;
X	    if ( self.otherside ) self.otherside.islocked := true;
X	}
X	else
X            askio( withPrep );
X    }
X    verDoUnlock( actor ) =
X    {
X        if ( not self.islocked ) "It's not locked! ";
X    }
X    doUnlock( actor ) =
X    {
X        if ( self.mykey = nil )
X	{
X	    "Unlocked. ";
X	    self.islocked := nil;
X	    if ( self.otherside ) self.otherside.islocked := nil;
X	}
X	else
X	    askio( withPrep );
X    }
X    verDoLockWith( actor, io ) =
X    {
X        if ( self.islocked ) "It's already locked. ";
X	else if ( not self.islockable ) "It can't be locked. ";
X	else if ( self.mykey = nil )
X	    "%You% %do%n't need anything to lock it. ";
X	else if ( self.isopen ) "%You%'ll have to close it first. ";
X    }
X    doLockWith( actor, io ) =
X    {
X        if ( io = self.mykey )
X	{
X	    "Locked. ";
X	    self.islocked := true;
X	    if ( self.otherside ) self.otherside.islocked := true;
X	}
X	else "It doesn't fit the lock. ";
X    }
X    verDoUnlockWith( actor, io ) =
X    {
X        if ( not self.islocked ) "It's not locked! ";
X	else if ( self.mykey = nil )
X	    "%You% %do%n't need anything to unlock it. ";
X    }
X    doUnlockWith( actor, io ) =
X    {
X        if ( io = self.mykey )
X	{
X	    "Unlocked. ";
X	    self.islocked := nil;
X	    if ( self.otherside ) self.otherside.islocked := nil;
X	}
X	else "It doesn't fit the lock. ";
X    }
X    ldesc =
X    {
X	if ( self.isopen ) "It's open. ";
X	else
X	{
X	    if ( self.islocked ) "It's closed and locked. ";
X	    else "It's closed. ";
X	}
X    }
X;
X
X/*
X@lockableDoorway: doorway
XThis is just a normal doorway with the \tt islockable\ and
X\tt islocked\ properties set to \tt true\.  Fill in the other
Xproperties (\tt otherside\ and \tt doordest\) as usual.  If
Xthe door has a key, set property \tt mykey\ to the key object.
X*/
Xclass lockableDoorway: doorway
X    islockable = true
X    islocked = true
X;
X
X/*
X@vehicle: item, nestedroom
XThis is an object that an actor can board.  An actor cannot go
Xanywhere while on board a vehicle; the actor must get out first.
X*/
Xclass vehicle: item, nestedroom
X    reachable = ([] + self)
X    isvehicle = true
X    verDoEnter( actor ) = { self.verDoBoard( actor ); }
X    doEnter( actor ) = { self.doBoard( actor ); }
X    verDoBoard( actor ) =
X    {
X        if ( actor.location = self )
X        {
X            "%You're% already in "; self.thedesc; "! ";
X        }
X    }
X    doBoard( actor ) =
X    {
X        "Okay, %you're% now in "; self.thedesc; ". ";
X        actor.moveInto( self );
X    }
X    noexit =
X    {
X        "%You're% not going anywhere until %you% get%s% out of ";
X	  self.thedesc; ". ";
X        return( nil );
X    }
X    out = ( self.location )
X;
X
X/*
X@surface: item
XObjects can be placed on a surface.  Apart from using the
Xpreposition ``on'' rather than ``in'' to refer to objects
Xcontained by the object, a \tt surface\ is identical to a
X\tt container\.  Note: that an object cannot be both a
X\tt surface\ and a \tt container\, because there is no
Xdistinction between the two internally.
X*/
Xclass surface: item
X    issurface = true        // Item can hold objects on its surface
X    ldesc =
X    {
X        if (itemcnt( self.contents ))
X        {
X            "On "; self.thedesc; " %you% see%s% "; listcont( self ); ". ";
X        }
X        else
X        {
X            "There's nothing on "; self.thedesc; ". ";
X        }
X    }
X    verIoPutOn( actor ) = {}
X    ioPutOn( actor, dobj ) =
X    {
X        dobj.doPutOn( actor, self );
X    }
X;
X
X/*
X@container: item
XThis object can contain other objects.  The \tt iscontainer\ property
Xis set to \tt true\.  The default \tt ldesc\ displays a list of the
Xobjects inside the container, if any.  The \tt maxbulk\ property
Xspecifies the maximum amount of bulk the container can contain.
X*/
Xclass container: item
X    maxbulk = 10            // maximum bulk the container can contain
X    isopen = true           // in fact, it can't be closed at all
X    iscontainer = true      // Item can contain other items
X    ldesc =
X    {
X        if ( self.contentsVisible and itemcnt( self.contents ) <> 0 )
X        {
X            "In "; self.thedesc; " %you% see%s% "; listcont( self ); ". ";
X        }
X        else
X        {
X            "There's nothing in "; self.thedesc; ". ";
X        }
X    }
X    verIoPutIn( actor ) =
X    {
X    }
X    ioPutIn( actor, dobj ) =
X    {
X        if (addbulk( self.contents ) + dobj.bulk > self.maxbulk )
X        {
X            "%You% can't fit that in "; self.thedesc; ". ";
X        }
X        else
X        {
X	    dobj.doPutIn( actor, self );
X        }
X    }
X    verDoLookin( actor ) = {}
X    doLookin( actor ) =
X    {
X        self.ldesc;
X    }
X;
X
X/*
X@openable: container
XA container that can be opened and closed.  The \tt isopenable\
Xproperty is set to \tt true\.  The default \tt ldesc\ displays
Xthe contents of the container if the container is open, otherwise
Xa message saying that the object is closed.
X*/
Xclass openable: container
X    contentsReachable = { return( self.isopen ); }
X    contentsVisible = { return( self.isopen ); }
X    isopenable = true
X    ldesc =
X    {
X    	caps(); self.thedesc;
X    	if ( self.isopen )
X	{
X	    " is open. ";
X	    pass ldesc;
X	}
X    	else " is closed. ";
X    }
X    isopen = true
X    verDoOpen( actor ) =
X    {
X        if ( self.isopen )
X	{
X	    caps(); self.thedesc; " is already open! ";
X	}
X    }
X    doOpen( actor ) =
X    {
X        if (itemcnt( self.contents ))
X	{
X	    "Opening "; self.thedesc; " reveals "; listcont( self ); ". ";
X	}
X	else "Opened. ";
X	self.isopen := true;
X    }
X    verDoClose( actor ) =
X    {
X        if ( not self.isopen )
X	{
X	    caps(); self.thedesc; " is already closed! ";
X	}
X    }
X    doClose( actor ) =
X    {
X        "Closed. ";
X	self.isopen := nil;
X    }
X    verIoPutIn( actor ) =
X    {
X        if ( not self.isopen )
X	{
X	    caps(); self.thedesc; " is closed. ";
X	}
X    }
X    verDoLookin( actor ) =
X    {
X        if ( not self.isopen ) "It's closed. ";
X    }
X;
X
X/*
X@qcontainer: container
XA ``quiet'' container:  its contents are not listed when it shows
Xup in a room description or inventory list.  The \tt isqcontainer\
Xproperty is set to \tt true\.
X*/
Xclass qcontainer: container
X    isqcontainer = true
X;
X
X/*
X@lockable: openable
XA container that can be locked and unlocked.  The \tt islocked\
Xproperty specifies whether the object can be opened or not.  The
Xobject can be locked and unlocked without the need for any other
Xobject; if you want a key to be involved, use a \tt keyedLockable\.
X*/
Xclass lockable: openable
X    doOpen( actor ) =
X    {
X        if ( self.islocked )
X        {
X            "It's locked. ";
X        }
X        else pass doOpen;
X    }
X    verDoLock( actor ) =
X    {
X        if ( self.islocked )
X        {
X            "It's already locked! ";
X        }
X    }
X    doLock( actor ) =
X    {
X        if ( self.isopen )
X        {
X            "%You%'ll have to close "; self.thedesc; " first. ";
X        }
X        else
X        {
X            "Locked. ";
X            self.islocked := true;
X        }
X    }
X    verDoUnlock( actor ) =
X    {
X        if ( not self.islocked ) "It's not locked! ";
X    }
X    doUnlock( actor ) =
X    {
X        "Unlocked. ";
X        self.islocked := nil;
X    }
X    verDoLockWith( actor, io ) =
X    {
X        if ( self.islocked ) "It's already locked. ";
X    }
X    verDoUnlockWith( actor, io ) =
X    {
X        if ( not self.islocked ) "It's not locked! ";
X    }
X;
X
X/*
X@keyedLockable: lockable
XThis subclass of \tt lockable\ allows you to create an object
Xthat can only be locked and unlocked with a corresponding key.
XSet the property \tt mykey\ to the \tt keyItem\ object that can
Xlock and unlock the object.
X*/
Xclass keyedLockable: lockable
X    mykey = nil     // set 'mykey' to the key which locks/unlocks me
X    doLock( actor ) =
X    {
X        askio( withPrep );
X    }
X    doUnlock( actor ) =
X    {
X        askio( withPrep );
X    }
X    doLockWith( actor, io ) =
X    {
X        if ( self.isopen )
X        {
X            "%You% can't lock << self.thedesc >> when it's open. ";
X        }
X        else if ( io = self.mykey )
X        {
X            "Locked. ";
X            self.islocked := true;
X        }
X        else "It doesn't fit the lock. ";
X    }
X    doUnlockWith( actor, io ) =
X    {
X        if ( io = self.mykey )
X        {
X            "Unlocked. ";
X            self.islocked := nil;
X        }
X        else "It doesn't fit the lock. ";
X    }
X;
X
X/*
X@keyItem: item
XThis is an object that can be used as a key for a \tt keyedLockable\
Xor \tt lockableDoorway\ object.  It otherwise behaves as an ordinary item.
X*/
Xclass keyItem: item
X    verIoUnlockWith( actor ) = {}
X    ioUnlockWith( actor, dobj ) =
X    {
X        dobj.doUnlockWith( actor, self );
X    }
X    verIoLockWith( actor ) = {}
X    ioLockWith( actor, dobj ) =
X    {
X        dobj.doLockWith( actor, self );
X    }
X;
X
X/*
X@transparentItem: item
XAn object whose contents are visible, even when the object is
Xclosed.  Whether the contents are reachable is decided in the
Xnormal fashion.  This class is useful for items such as glass
Xbottles, whose contents can be seen when the bottle is closed
Xbut cannot be reached.
X*/
Xclass transparentItem: item
X    contentsVisible = { return( true ); }
X    verGrab( obj ) =
X    {
X        if ( self.isopenable and not self.isopen )
X            "%You% will have to open << self.thedesc >> first. ";
X    }
X    doOpen( actor ) =
X    {
X        self.isopen := true;
X        "Opened. ";
X    }
X;
X
X/*
X@basicNumObj: object
XThis object provides a default implementation for \tt numObj\.
XTo use this default unchanged in your game, include in your
Xgame this line:  ``\tt numObj: basicNumObj\''.
X*/
Xclass basicNumObj: object   // when a number is used in a player command,
X    value = 0               //  this is set to its value
X    sdesc = "that"
X    adesc = "that"
X    thedesc = "that"
X    verDoTypeOn( actor, io ) = {}
X    doTypeOn( actor, io ) = { "\"Tap, tap, tap, tap...\" "; }
X    verIoTurnTo( actor ) = {}
X    ioTurnTo( actor, dobj ) = { dobj.doTurnTo( actor, self ); }
X;
X
X/*
X@basicStrObj: object
XThis object provides a default implementation for \tt strObj\.
XTo use this default unchanged in your game, include in your
Xgame this line:  ``\tt strObj: basicStrObj\''.
X*/
Xclass basicStrObj: object   // when a string is used in a player command,
X    value = ''              //  this is set to its value
X    sdesc = "that"
X    adesc = "that"
X    thedesc = "that"
X    verDoTypeOn( actor, io ) = {}
X    doTypeOn( actor, io ) = { "\"Tap, tap, tap, tap...\" "; }
X    verDoSave( actor ) = {}
X    doSave( actor ) =
X    {
X        if (save( self.value ))
X            "Save failed. ";
X        else
X            "Saved. ";
X	abort;
X    }
X    verDoRestore( actor ) = {}
X    doRestore( actor ) =
X    {
X        if (restore( self.value ))
X            "Restore failed. ";
X        else
X	{
X            "Restored. ";
X	    setscore( global.score, global.turnsofar );
X	}
X        abort;
X    }
X    verDoScript( actor ) = {}
X    doScript( actor ) =
X    {
X        logging( self.value );
X        "Writing script file. ";
X        abort;
X    }
X    verDoSay( actor ) = {}
X    doSay( actor ) =
X    {
X	    // DMB added ZOT code, etc.
X	    if (upper(strObj.value) = 'XYZZY') {
X		    xyzzyVerb.action(actor);
X	    }
X    	    else if (upper(strObj.value) = 'PLUGH') {
X		    plughVerb.action(actor);
X	    }
X	    else if (upper(strObj.value) = 'PLOVER') {
X		    ploverVerb.action(actor);
X	    }
X   	    else if (upper(strObj.value) = 'Y2') {
X		    y2Verb.action(actor);
X	    }
X   	    else if (upper(strObj.value) = 'FEE') {
X		    feeVerb.action(actor);
X	    }
X   	    else if (upper(strObj.value) = 'FIE') {
X		    fieVerb.action(actor);
X	    }
X   	    else if (upper(strObj.value) = 'FOE') {
X		    foeVerb.action(actor);
X	    }
X   	    else if (upper(strObj.value) = 'FOO') {
X		    fooVerb.action(actor);
X	    }
X   	    else if (upper(strObj.value) = 'FUM') {
X		    fumVerb.action(actor);
X	    }
X	    else if (upper(strObj.value) = 'FEE FIE FOE FOO') {
X		    "Try saying the words one at a time.";
X	    }
X	    else if (upper(strObj.value) = 'FEE FIE FOE FUM') {
X		    "Try saying the words one at a time.";
X	    }
X	    else {
X		    "That doesn't seem very productive.";
X	    }
X    }
X;
X
X/*
X@deepverb: object
XA ``verb object'' that is referenced by the parser when the player
Xuses an associated vocabulary word.  A \tt deepverb\ contains both
Xthe vocabulary of the verb and a description of available syntax.
XThe \tt verb\ property lists the vocabulary words known as verbs;
Xone word (such as \tt 'take'\) or a pair (such as \tt 'pick up'\)
Xcan be used.  In the latter case, the second word must be a
Xpreposition, and may move to the end of the sentence in a player's
Xcommand, as in ``pick it up.''  The \tt action( \it actor\ )\
Xmethod specifies what happens when the verb is used without any
Xobjects; its absence specifies that the verb cannot be used without
Xan object.  The \tt doAction\ specifies the root of the message
Xnames (in single quotes) sent to the direct object when the verb
Xis used with a direct object; its absence means that a single object
Xis not allowed.  Likewise, the \tt ioAction( \it preposition\ )\
Xspecifies the root of the message name sent to the direct and
Xindirect objects when the verb is used with both a direct and
Xindirect object; its absence means that this syntax is illegal.
XSeveral \tt ioAction\ properties may be present:  one for each
Xpreposition that can be used with an indirect object with the verb.
X
XThe \tt validDo( \it actor, object, seqno\ )\ method returns \tt true\
Xif the indicated object is valid as a direct object for this actor.
XThe \tt validIo( \it actor, object, seqno\ )\ method does likewise
Xfor indirect objects.  The \it seqno\ parameter is a ``sequence
Xnumber,'' starting with 1 for the first object tried for a given
Xverb, 2 for the second, and so forth; this parameter is normally
Xignored, but can be used for some special purposes.  For example,
X\tt askVerb\ does not distinguish between objects matching vocabulary
Xwords, and therefore accepts only the first from a set of ambiguous
Xobjects.  These methods do not normally need to be changed; by
Xdefault, they return \tt true\ if the object is accessible to the
Xactor.
X
XThe \tt doDefault( \it actor, prep, indirectObject\ )\ and
X\tt ioDefault( \it actor, prep\ )\ methods return a list of the
Xdefault direct and indirect objects, respectively.  These lists
Xare used for determining which objects are meant by ``all'' and which
Xshould be used when the player command is missing an object.  These
Xnormally return a list of all objects that are applicable to the
Xcurrent command.
X*/
Xclass deepverb: object                // A deep-structure verb.
X    validDo( actor, obj, seqno ) =
X    {
X    	return( obj.isReachable( actor ));
X    }
X    invalidObj( actor, obj, name ) =
X    {
X        if ( not obj.isVisible( actor ))
X            "I don't see any << name >> here. ";
X        else
X            "%You% can't do that with << obj.thedesc >>. ";
X    }
X    validIo( actor, obj, seqno ) =
X    {
X    	return( obj.isReachable( actor ));
X    }
X    doDefault( actor, prep, io ) =
X    {
X	/* DMB */
X	//return( actor.contents + actor.location.contents );
X	return nil;
X    }
X    ioDefault( actor, prep ) =
X    {
X    	/* DMB */
X	//return( actor.contents + actor.location.contents );
X	return nil;
X    }
X;
X
X/*
X *   Various verbs.
X */
XinspectVerb: deepverb
X    verb = 'inspect' 'examine' 'look at' 'x' /* DMB: */ 'search' 'ex'
X    sdesc = "inspect"
X    doAction = 'Inspect'
X    validDo( actor, obj, seqno ) =
X    {
X        return( obj.isVisible( actor ));
X    }
X;
XaskVerb: deepverb
X    verb = 'ask'
X    sdesc = "ask"
X    prepDefault = aboutPrep
X    ioAction( aboutPrep ) = 'AskAbout'
X    validIo( actor, obj, seqno ) = { return( seqno = 1 ); }
X;
XtellVerb: deepverb
X    verb = 'tell'
X    sdesc = "tell"
X    prepDefault = aboutPrep
X    ioAction( aboutPrep ) = 'TellAbout'
X    validIo( actor, obj, seqno ) = { return( seqno = 1 ); }
X;
XfollowVerb: deepverb
X    sdesc = "follow"
X    verb = 'follow'
X    doAction = 'Follow'
X;
X/*
X * DMB -- now defined in ccr-verbs.t
XdigVerb: deepverb
X    verb = 'dig' 'dig in'
X    sdesc = "dig in"
X    prepDefault = withPrep
X    ioAction( withPrep ) = 'DigWith'
X;
X */
X/*
X * DMB -- now defined in ccr-verbs.t
X *
XjumpVerb: deepverb
X    verb = 'jump' 'jump over' 'jump off'
X    doAction = 'Jump'
X    action(actor) = { "Wheeee!"; }
X;
X*/
XpushVerb: deepverb
X    verb = 'push' 'press'
X    sdesc = "push"
X    doAction = 'Push'
X;
XattachVerb: deepverb
X    verb = 'attach' 'connect'
X    sdesc = "attach"
X    prepDefault = toPrep
X    ioAction( toPrep ) = 'AttachTo'
X;
XwearVerb: deepverb
X    verb = 'wear' 'put on'
X    sdesc = "wear"
X    doAction = 'Wear'
X;
XdropVerb: deepverb
X    verb = 'drop' 'put down' 'free' 'release'	// DMB: added last two
X    sdesc = "drop"
X    ioAction( onPrep ) = 'PutOn'
X    doAction = 'Drop'
X    doDefault( actor, prep, io ) =
X    {
X        return( actor.contents );
X    }
X;
XremoveVerb: deepverb
X    verb = 'take off'
X    sdesc = "take off"
X    doAction = 'Unwear'
X    ioAction( fromPrep ) = 'RemoveFrom'
X;
XopenVerb: deepverb
X    verb = 'open' 'pry'		// DMB added pry for "pry clam with trident"
X    sdesc = "open"
X    doAction = 'Open'
X    ioAction(withPrep) = 'OpenWith'
X;
XcloseVerb: deepverb
X    verb = 'close'
X    sdesc = "close"
X    doAction = 'Close'
X;
XputVerb: deepverb
X    verb = 'put' 'place' 'insert'	// DMB: added 'insert'
X    sdesc = "put"
X    prepDefault = inPrep
X    ioAction( inPrep ) = 'PutIn'
X    ioAction( onPrep ) = 'PutOn'
X    doDefault( actor, prep, io ) =
X    {
X        return( takeVerb.doDefault( actor, prep, io ) + actor.contents );
X    }
X;
XtakeVerb: deepverb                   // This object defines how to take things
X    verb = 'take' 'pick up' 'get' 'remove'
X    sdesc = "take"
X    ioAction( offPrep ) = 'TakeOff'
X    ioAction( outPrep ) = 'TakeOut'
X    ioAction( fromPrep ) = 'TakeOut'
X    ioAction( inPrep ) = 'TakeOut'
X    ioAction( onPrep ) = 'TakeOff'
X    doAction = 'Take'
X    doDefault( actor, prep, io ) =
X    {
X        local ret, rem, cur, rem2, cur2, tot, i, tot2, j;
X	
X	ret := [];
X        
X	/*
X	 *   For "take all out/off of <iobj>", return the (non-fixed)
X	 *   contents of the indirect object.  Same goes for "take all in
X	 *   <iobj>", "take all on <iobj>", and "take all from <iobj>".
X	 */
X	if (( prep=outPrep or prep=offPrep or prep=inPrep or prep=onPrep
X	 or prep=fromPrep ) and io<>nil )
X	{
X	    rem := io.contents;
X	    i := 1;
X	    tot := length( rem );
X	    while ( i <= tot )
X	    {
X	        cur := rem[i];
X	        if ( not cur.isfixed ) ret := ret + cur;
X		i := i + 1;
X	    }
X            return( ret );
X	}
X
X        /*
X	 *   In the general case, return everything that's not fixed
X	 *   in the actor's location, or everything inside fixed containers
X	 *   that isn't itself fixed.
X	 */
X        rem := actor.location.contents;
X	tot := length( rem );
X	i := 1;
X        while ( i <= tot )
X        {
X	    cur := rem[i];
X            if ( cur.isfixed )
X            {
X                if ((( cur.isopenable and cur.isopen ) or
X                  ( not cur.isopenable )) and ( not cur.isactor ))
X                {
X                    rem2 := cur.contents;
X		    tot2 := length( rem2 );
X		    j := 1;
X                    while ( j <= tot2 )
X                    {
X		        cur2 := rem2[j];
X                        if ( not cur2.isfixed and not cur2.notakeall )
X			{
X			    ret := ret + cur2;
X			}
X                        j := j + 1;
X                    }
X                }
X            }
X            else if ( not cur.notakeall )
X	    {
X	        ret := ret + cur;
X	    }
X
X	    i := i + 1;            
X        }
X        return( ret );
X    }
X;
XplugVerb: deepverb
X    verb = 'plug'
X    sdesc = "plug"
X    prepDefault = inPrep
X    ioAction( inPrep ) = 'PlugIn'
X;
XlookInVerb: deepverb
X    verb = 'look in' 'look on'
X    sdesc = "look in"
X    doAction = 'Lookin'
X;
XscrewVerb: deepverb
X    verb = 'screw'
X    sdesc = "screw"
X    ioAction( withPrep ) = 'ScrewWith'
X    doAction = 'Screw'
X;
XunscrewVerb: deepverb
X    verb = 'unscrew'
X    sdesc = "unscrew"
X    ioAction( withPrep ) = 'UnscrewWith'
X    doAction = 'Unscrew'
X;
XturnVerb: deepverb
X    verb = 'turn' 'rotate' 'twist'
X    sdesc = "turn"
X    ioAction( toPrep ) = 'TurnTo'
X    ioAction( withPrep ) = 'TurnWith'
X    doAction = 'Turn'
X;
XswitchVerb: deepverb
X    verb = 'switch'
X    sdesc = "switch"
X    doAction = 'Switch'
X;
XflipVerb: deepverb
X    verb = 'flip'
X    sdesc = "flip"
X    doAction = 'Flip'
X;
XturnOnVerb: deepverb
X    verb = 'activate' 'turn on' 'switch on'
X    sdesc = "turn on"
X    doAction = 'Turnon'
X;
XturnOffVerb: deepverb
X    verb = 'turn off' 'deactivate' 'switch off'	// DMB: deavtiv + ate
X    sdesc = "turn off"
X    doAction = 'Turnoff'
X;
XlookVerb: deepverb
X    verb = 'look' 'l' 'look around'
X    action( actor ) =
X    {
X        actor.location.lookAround( true );
X    }
X;
XsitVerb: deepverb
X    verb = 'sit on' 'sit in' 'sit' 'sit down' 'sit downin' 'sit downon'
X    sdesc = "sit on"
X    doAction = 'Siton'
X;
XlieVerb: deepverb
X    verb = 'lie' 'lie on' 'lie in' 'lie down' 'lie downon' 'lie downin'
X    sdesc = "lie on"
X    doAction = 'Lieon'
X;
XgetOutVerb: deepverb
X    verb = 'get out' 'get outof' 'get off' 'get offof'
X    sdesc = "get out of"
X    doAction = 'Unboard'
X    doDefault( actor, prep, io ) =
X    {
X        if ( actor.location and actor.location.location )
X            return( [] + actor.location );
X        else return( [] );
X    }
X;
XboardVerb: deepverb
X    verb = 'get in' 'get into' 'board' 'get on'
X    sdesc = "get on"
X    doAction = 'Board'
X;
XagainVerb: deepverb         // Required verb:  repeats last command.  No
X                            // action routines are necessary; this one's
X                            // handled internally by the parser.
X    verb = 'again' 'g'
X;
XwaitVerb: deepverb
X    verb = 'wait' 'z'
X    action( actor ) =
X    {
X        "Time passes...\n";
X    }
X;
XiVerb: deepverb
X    verb = 'inventory' 'i'
X    action( actor ) =
X    {
X        if (length( actor.contents ))
X        {
X            "%You% %have% "; listcont( actor ); ". ";
X	    // DMB added the check for any contents
X	    if (listcontcont(actor, nil)) {
X		    P();
X		    listcontcont(actor, true);	// DMB added second param
X	    }
X        }
X	else
X            "%You% %are% empty-handed.\n";
X    }
X;
XlookThruVerb: deepverb
X    verb = 'look through' 'look thru'
X    sdesc = "look through"
X    doAction = 'Lookthru'
X;
XattackVerb: deepverb
X    verb = 'attack' 'kill' 'hit'
X    sdesc = "attack"
X    doAction = 'Attack'	// DMB
X    prepDefault = withPrep
X    ioAction( withPrep ) = 'AttackWith'
X;
XeatVerb: deepverb
X    verb = 'eat' 'consume'
X    sdesc = "eat"
X    doAction = 'Eat'
X;
XdrinkVerb: deepverb
X    verb = 'drink' 'drink from'	// DMB: added 'drink from'
X    sdesc = "drink"
X    doAction = 'Drink'
X;
XgiveVerb: deepverb
X    verb = 'give' 'offer'
X    sdesc = "give"
X    prepDefault = toPrep
X    ioAction( toPrep ) = 'GiveTo'
X;
XpullVerb: deepverb
X    verb = 'pull'
X    sdesc = "pull"
X    doAction = 'Pull'
X;
XreadVerb: deepverb
X    verb = 'read'
X    sdesc = "read"
X    doAction = 'Read'
X;
XthrowVerb: deepverb
X    verb = 'throw' 'toss'
X    sdesc = "throw"
X    prepDefault = atPrep
X    ioAction( atPrep ) = 'ThrowAt'
X    ioAction( toPrep ) = 'ThrowTo'
X;
XstandOnVerb: deepverb
X    verb = 'stand on'
X    sdesc = "stand on"
X    doAction = 'Standon'
X;
XstandVerb: deepverb
X    verb = 'stand' 'stand up' 'get up'
X    sdesc = "stand"
X    action( actor ) =
X    {
X        if ( actor.location=nil or actor.location.location = nil )
X            "%You're% already standing! ";
X        else
X        {
X	    actor.location.doUnboard( actor );
X        }
X    }
X;
XhelloVerb: deepverb
X    verb = 'hello' 'hi' 'greetings'
X    action( actor ) =
X    {
X        "Nice weather we've been having.\n";
X    }
X;
XshowVerb: deepverb
X    verb = 'show'
X    sdesc = "show"
X    prepDefault = toPrep
X    ioAction( toPrep ) = 'ShowTo'
X;
XcleanVerb: deepverb
X    verb = 'clean'
X    sdesc = "clean"
X    ioAction( withPrep ) = 'CleanWith'
X    doAction = 'Clean'
X;
XsayVerb: deepverb
X    verb = 'say'
X    sdesc = "say"
X    doAction = 'Say'
X;
XyellVerb: deepverb
X    verb = 'yell' 'shout' 'yell at' 'shout at'
X    action( actor ) =
X    {
X        "%Your% throat is a bit sore now. ";
X    }
X;
XmoveVerb: deepverb
X    verb = 'move'
X    sdesc = "move"
X    ioAction( withPrep ) = 'MoveWith'
X    ioAction( toPrep ) = 'MoveTo'
X    doAction = 'Move'
X;
XfastenVerb: deepverb
X    verb = 'fasten' 'buckle' 'buckle up'
X    sdesc = "fasten"
X    doAction = 'Fasten'
X;
XunfastenVerb: deepverb
X    verb = 'unfasten' 'unbuckle'
X    sdesc = "unfasten"
X    doAction = 'Unfasten'
X;
XunplugVerb: deepverb
X    verb = 'unplug'
X    sdesc = "unplug"
X    ioAction( fromPrep ) = 'UnplugFrom'
X    doAction = 'Unplug'
X;
XlookUnderVerb: deepverb
X    verb = 'look under' 'look beneath'
X    sdesc = "look under"
X    doAction = 'Lookunder'
X;
XlookBehindVerb: deepverb
X    verb = 'look behind'
X    sdesc = "look behind"
X    doAction = 'Lookbehind'
X;
XtypeVerb: deepverb
X    verb = 'type'
X    sdesc = "type"
X    prepDefault = onPrep
X    ioAction( onPrep ) = 'TypeOn'
X;
XlockVerb: deepverb
X    verb = 'lock'
X    sdesc = "lock"
X    ioAction( withPrep ) = 'LockWith'
X    doAction = 'Lock'
X    prepDefault = withPrep
X;
XunlockVerb: deepverb
X    verb = 'unlock'
X    sdesc = "unlock"
X    ioAction( withPrep ) = 'UnlockWith'
X    doAction = 'Unlock'
X    prepDefault = withPrep
X;
XdetachVerb: deepverb
X    verb = 'detach' 'disconnect'
X    prepDefault = fromPrep
X    ioAction( fromPrep ) = 'DetachFrom'
X    doAction = 'Detach'
X    sdesc = "detach"
X;
X/*
X * DMB
X */
XsleepVerb: deepverb
X	action(actor) = {
X    		"This is no time for loafing!";
X	}
X	
X	verb = 'sleep' 'rest' 'loaf' 'nap' 'relax'
X;
XpokeVerb: deepverb
X    verb = 'poke' 'jab'
X    sdesc = "poke"
X    doAction = 'Poke'
X;
XtouchVerb: deepverb
X    verb = 'touch'
X    sdesc = "touch"
X    doAction = 'Touch'
X;
XmoveNVerb: deepverb
X    verb = 'move north' 'move n' 'push north' 'push n'
X    sdesc = "move north"
X    doAction = 'MoveN'
X;
XmoveSVerb: deepverb
X    verb = 'move south' 'move s' 'push south' 'push s'
X    sdesc = "move south"
X    doAction = 'MoveS'
X;
XmoveEVerb: deepverb
X    verb = 'move east' 'move e' 'push east' 'push e'
X    sdesc = "move east"
X    doAction = 'MoveE'
X;
XmoveWVerb: deepverb
X    verb = 'move west' 'move w' 'push west' 'push w'
X    sdesc = "move west"
X    doAction = 'MoveW'
X;
XmoveNEVerb: deepverb
X    verb = 'move northeast' 'move ne' 'push northeast' 'push ne'
X    sdesc = "move northeast"
X    doAction = 'MoveNE'
X;
XmoveNWVerb: deepverb
X    verb = 'move northwest' 'move nw' 'push northwest' 'push nw'
X    sdesc = "move northwest"
X    doAction = 'MoveNW'
X;
XmoveSEVerb: deepverb
X    verb = 'move southeast' 'move se' 'push southeast' 'push se'
X    sdesc = "move southeast"
X    doAction = 'MoveSE'
X;
XmoveSWVerb: deepverb
X    verb = 'move southwest' 'move sw' 'push southwest' 'push sw'
X    sdesc = "move southwest"
X    doAction = 'MoveSW'
X;
XcenterVerb: deepverb
X    verb = 'center'
X    sdesc = "center"
X    doAction = 'Center'
X;
X/*
X * DMB search is synonymous with inspect.
X */
X/*
XsearchVerb: deepverb
X    verb = 'search'
X    sdesc = "search"
X    doAction = 'Search'
X;
X*/
X/*
X *   Travel verbs  - these verbs allow the player to move about.
X *   All travel verbs have the property isTravelVerb set true.
X */
Xclass travelVerb: deepverb
X    isTravelVerb = true
X;
XclimbVerb: deepverb, travelVerb	// DMB: made this into a travelVerb
X    verb = 'climb'
X    travelDir( actor ) = { return(actor.location.climb); }
X
X    sdesc = "climb"
X    action( actor ) = { actor.travelTo(self.travelDir(actor)); }
X    doAction = 'Climb'
X;
XeVerb: travelVerb
X    action( actor ) = { actor.travelTo( self.travelDir( actor )); }
X    verb = 'e' 'east' 'go east'
X    travelDir( actor ) = { return( actor.location.east ); }
X;
XsVerb: travelVerb
X    action( actor ) = { actor.travelTo( self.travelDir( actor )); }
X    verb = 's' 'south' 'go south'
X    travelDir( actor ) = { return( actor.location.south ); }
X;
XnVerb: travelVerb
X    action( actor ) = { actor.travelTo( self.travelDir( actor )); }
X    verb = 'n' 'north' 'go north'
X    travelDir( actor ) = { return( actor.location.north ); }
X;
XwVerb: travelVerb
X    action( actor ) = { actor.travelTo( self.travelDir( actor )); }
X    verb = 'w' 'west' 'go west'
X    travelDir( actor ) = { return( actor.location.west ); }
X;
XneVerb: travelVerb
X    action( actor ) = { actor.travelTo( self.travelDir( actor )); }
X    verb = 'ne' 'northeast' 'go ne' 'go northeast'
X    travelDir( actor ) = { return( actor.location.ne ); }
X;
XnwVerb: travelVerb
X    action( actor ) = { actor.travelTo( self.travelDir( actor )); }
X    verb = 'nw' 'northwest' 'go nw' 'go northwest'
X    travelDir( actor ) = { return( actor.location.nw ); }
X;
XseVerb: travelVerb
X    action( actor ) = { actor.travelTo( self.travelDir( actor )); }
X    verb = 'se' 'southeast' 'go se' 'go southeast'
X    travelDir( actor ) = { return( actor.location.se ); }
X;
XswVerb: travelVerb
X    action( actor ) = { actor.travelTo( self.travelDir( actor )); }
X    verb = 'sw' 'southwest' 'go sw' 'go southwest'
X    travelDir( actor ) = { return( actor.location.sw ); }
X;
XinVerb: travelVerb
X    action( actor ) = { actor.travelTo( self.travelDir( actor )); }
X    verb = 'in' 'go in' 'enter'
X    sdesc = "enter"
X    doAction = 'Enter'
X    travelDir( actor ) = { return( actor.location.in ); }
X;
XoutVerb: travelVerb
X    action( actor ) = { actor.travelTo( self.travelDir( actor )); }
X    verb = 'out' 'go out' 'exit' 'leave'
X    travelDir( actor ) = { return( actor.location.out ); }
X;
XdVerb: travelVerb
X    action( actor ) = { actor.travelTo( self.travelDir( actor )); }
X    verb = 'd' 'down' 'go down'
X    travelDir( actor ) = { return( actor.location.down ); }
X;
XuVerb: travelVerb
X    action( actor ) = { actor.travelTo( self.travelDir( actor )); }
X    verb = 'u' 'up' 'go up'
X    travelDir( actor ) = { return( actor.location.up ); }
X;
X
X/*
X *   sysverb:  A system verb.  Verbs of this class are special verbs that
X *   can be executed without certain normal validations.  For example,
X *   a system verb can be executed in a dark room.  System verbs are
X *   for operations such as saving, restoring, and quitting, which are
X *   not really part of the game.
X */
Xclass sysverb: deepverb
X    issysverb = true
X;
XquitVerb: sysverb
X    verb = 'quit'
X    action( actor ) =
X    {
X        local yesno;
X
X	/* XXX */
X        "\bDo you really want to quit? (YES or NO) > ";
X        yesno := yorn();
X        "\b";
X        if ( yesno = 1 )
X        {
X	    silent_incscore(global.quitpoints); // points for quitting (neg.)
X	    scoreRank();	// DMB: moved here from XXX
X            terminate();    // allow user good-bye message
X	    quit();
X        }
X        else
X        {
X            "Okay. ";
X        }
X	abort;
X    }
X;
XverboseVerb: sysverb
X    verb = 'verbose'
X    action( actor ) =
X    {
X        "Okay, now in VERBOSE mode.\n";
X        global.verbose := true;
X	Me.location.lookAround( true );
X	abort;
X    }
X;
XterseVerb: sysverb
X    verb = 'brief' 'terse'
X    action( actor ) =
X    {
X        "Okay, now in TERSE mode.\n";
X        global.verbose := nil;
X	abort;
X    }
X;
XscoreVerb: sysverb
X    verb = 'score' 'status'
X    action( actor ) =
X    {
X        scoreRank();
X	abort;
X    }
X;
XsaveVerb: sysverb
X    verb = 'save'
X    sdesc = "save"
X    doAction = 'Save'
X    action( actor ) =
X    {
X        local savefile;
X	
X	savefile := askfile( 'File to save game in' );
X	if ( savefile = nil or savefile = '' )
X	    "Failed. ";
X	else if (save( savefile ))
X	    "Saved failed. ";
X	else
X	    "Saved. ";
X	abort;
X    }
X;
XrestoreVerb: sysverb
X    verb = 'restore'
X    sdesc = "restore"
X    doAction = 'Restore'
X    action( actor ) =
X    {
X        local savefile;
X	
X	savefile := askfile( 'File to restore game from' );
X	if ( savefile = nil or savefile = '' )
X	    "Failed. ";
X	else if (restore( savefile ))
X	    "Restore failed. ";
X	else
X	{
X	    setscore( global.score, global.turnsofar );
X	    "Restored. ";
X	}
X	abort;
X    }
X;
XscriptVerb: sysverb
X    verb = 'script'
X    doAction = 'Script'
X    action( actor ) =
X    {
X        local scriptfile;
X	
X	scriptfile := askfile( 'File to write transcript to' );
X	if ( scriptfile = nil or scriptfile = '' )
X	    "Failed. ";
X	else
X	{
X	    logging( scriptfile );
X	    "Writing script file. ";
X	}
X	abort;
X    }
X;
XunscriptVerb: sysverb
X    verb = 'unscript'
X    action( actor ) =
X    {
X        logging( nil );
X        "Script closed.\n";
X        abort;
X    }
X;
XrestartVerb: sysverb
X    verb = 'restart'
X    action( actor ) =
X    {
X        local yesno;
X        while ( true )
X        {
X            "Are you sure you want to start over? (YES or NO) > ";
X            yesno := yorn();
X            if ( yesno = 1 )
X            {
X                "\n";
X		setscore( 0, 0 );
X                restart();
X                abort;
X            }
X            else if ( yesno = 0 )
X            {
X                "\nOkay.\n";
X                abort;
X            }
X        }
X    }
X;
XversionVerb: sysverb
X    verb = 'version'
X    action( actor ) =
X    {
X        version.sdesc;
X        abort;
X    }
X;
XdebugVerb: sysverb
X    verb = 'debug'
X    action( actor ) =
X    {
X	if (debugTrace())
X	    "You can't think this game has any bugs left in it... ";
X	abort;
X    }
X;
X
XundoVerb: sysverb
X    verb = 'undo'
X    action(actor) =
X    {
X	/* do TWO undo's - one for this 'undo', one for previous command */
X	if (undo() and undo())
X	{
X	    "(Undoing one command)\b";
X	    Me.location.lookAround(true);
X	    setscore(global.score, global.turnsofar);
X	}
X	else
X	    "No more undo information is available. ";
X
X	abort;
X    }
X;
X
X/*
X@Prep: object
XA preposition.  The \tt preposition\ property specifies the
Xvocabulary word.
X*/
Xclass Prep: object
X;
X
X/*
X *   Various prepositions
X */
XaboutPrep: Prep
X    preposition = 'about'
X    sdesc = "about"
X;
XwithPrep: Prep
X    preposition = 'with'
X    sdesc = "with"
X;
XtoPrep: Prep
X    preposition = 'to'
X    sdesc = "to"
X;
XonPrep: Prep
X    preposition = 'on' 'onto' 'downon' 'upon'
X    sdesc = "on"
X;
XinPrep: Prep
X    preposition = 'in' 'into' 'downin'
X    sdesc = "in"
X;
XoffPrep: Prep
X    preposition = 'off' 'offof'
X    sdesc = "off"
X;
XoutPrep: Prep
X    preposition = 'out' 'outof'
X    sdesc = "out"
X;
XfromPrep: Prep
X    preposition = 'from'
X    sdesc = "from"
X;
XbetweenPrep: Prep
X    preposition = 'between' 'inbetween'
X    sdesc = "between"
X;
XoverPrep: Prep
X    preposition = 'over'
X    sdesc = "over"
X;
XatPrep: Prep
X    preposition = 'at'
X    sdesc = "at"
X;
XaroundPrep: Prep
X    preposition = 'around'
X    sdesc = "around"
X;
XthruPrep: Prep
X    preposition = 'through' 'thru'
X    sdesc = "through"
X;
XdirPrep: Prep
X    preposition = 'north' 'south' 'east' 'west' 'up' 'down' 'northeast' 'ne'
X                  'northwest' 'nw' 'southeast' 'se' 'southwest' 'sw'
X    sdesc = "north"         // Shouldn't ever need this, but just in case
X;
XunderPrep: Prep
X    preposition = 'under' 'beneath'
X    sdesc = "under"
X;
XbehindPrep: Prep
X    preposition = 'behind'
X    sdesc = "behind"
X;
X
X/*
X *   articles:  the "built-in" articles.  "The," "a," and "an" are
X *   defined.
X */
Xarticles: object
X    article = 'the' 'a' 'an'
X;
END_OF_FILE
if test 47810 -ne `wc -c <'src/ccr-adv.t2'`; then
    echo shar: \"'src/ccr-adv.t2'\" unpacked with wrong size!
fi
# end of 'src/ccr-adv.t2'
fi
if test -f 'src/thingext.t' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/thingext.t'\"
else
echo shar: Extracting \"'src/thingext.t'\" \(2886 characters\)
sed "s/^X//" >'src/thingext.t' <<'END_OF_FILE'
X/*
X * Colossal Cave Revisited
X *
X * A remake of Willie Crowther and Don Woods' classic Adventure.
X * Converted from Donald Ekman's PC port of the original FORTRAN source.
X * TADS version by David M. Baggett for ADVENTIONS.
X *
X * Please document all changes in the history so we know who did what.
X *
X * This source code is copylefted under the terms of the GNU Public
X * License.  Essentially, this means that you are free to do whatever
X * you wish with this source code, provided you do not charge any
X * money for it or for any derivative works.
X *
X * ADVENTIONS distributes this game, but you are free to do what you will
X * with it, provided you adhere to the terms in the GNU Public License.
X * Send correspondence regarding this game or original works distributed
X * by ADVENTIONS to 
X *
X *	ADVENTIONS
X *	PO Box 851
X *	Columbia, MD 21044
X *
X * If you would like a catalog of releases, please enclose a SASE.  Thanks!
X *
X * Contributors
X *
X *	dmb	In real life:	David M. Baggett
X *		Internet:	<dmb@ai.mit.edu>
X *		Compu$erve:	76440,2671 (ADVENTIONS account)
X *		GEnie:		ADVENTIONS
X *
X * Modification History
X *
X * 1-Jan-93	dmb	rec.arts.int-fiction BETA release (source only)
X *                      For beta testing only -- not for general
X *			distribution.
X *
X */
X
X/*
X * This file is #included in adv.t and defines extensions to the thing
X * class.
X */
X
X// Default actions for new verbs.
X// These are #included into the thing class definition.
X
X	verDoKick(actor) = { "Feeling violent?"; }
X	verDoSmell(actor) = { "It smells like an ordinary "; self.sdesc; "."; }
X	verDoWave(actor) = {
X		"Waving "; self.thedesc; " doesn't seem to do much.";
X	}
X	verDoBreak(actor) = { "I see no obvious way to do that."; }
X	verDoRub(actor) = { "Ok, you just rubbed "; self.thedesc; "."; }
X	verDoCount(actor) = { "I see one (1) "; self.sdesc; "."; }
X	verDoUse(actor) = {
X		"You'll have to be a bit more explicit than that.";
X	}
X	verDoLight(actor) = {
X		"I don't know how to light "; self.thesdesc; ".";
X	}
X	verDoPick(actor) = { "You're babbling, man!  Snap out of it!"; }
X	verDoWake(actor) = { caps(); self.thedesc; " is not asleep."; }
X	verDoBlastWith(actor) = { "Been eating those funny brownies again?"; }
X	verDoOil(actor) = { "Yuck."; }
X	verDoWater(actor) = { "I don't see any point to that."; }
X	verIoOpenWith(actor) = {
X		"You can't use that to open anything.";
X	}
X
X	/*
X	 * Map douse x with y to pour y on x
X	 */
X	verDoDouseWith(actor) = { self.verIoPourOn(actor); }
X	doDouseWith(actor, io) = { io.doPourOn(actor, self); }
X	verIoDouseWith(actor) = { self.verDoPourOn(actor); }
X	ioDouseWith(actor, dobj) = { dobj.ioPourOn(actor, self); }
X
X	verDoPourOn(actor, io) = {
X		caps(); self.thedesc; " is going to have to undergo
X		a major state change first.";
X	}
X	doPourOn(actor, io) = {
X		"This shouldn't happen.";
X	}
X	verIoPourOn(actor) = {}
X	ioPourOn(actor, dobj) = { dobj.doPourOn(actor, self); }
END_OF_FILE
if test 2886 -ne `wc -c <'src/thingext.t'`; then
    echo shar: \"'src/thingext.t'\" unpacked with wrong size!
fi
# end of 'src/thingext.t'
fi
echo shar: End of archive 1 \(of 11\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    echo "Now run buildit.sh to make gam file"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
