Path: uunet!news.tek.com!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i018:  ccr - colossal cave (adventure) implemented in TADS, Part03/11
Date: 12 Jul 1993 19:28:38 GMT
Organization: Tektronix, Inc, Redmond, OR, USA
Lines: 2438
Approved: billr@saab.CNA.TEK.COM
Message-ID: <21se16$1cr@ying.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1818

Submitted-by: David Baggett <dmb@xbar.ai.mit.edu>
Posting-number: Volume 18, Issue 18
Archive-name: ccr/part03
Environment: TADS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 11)."
# Contents:  readme.unix src/ccr-room.t1
# Wrapped by billr@saab on Mon Jul 12 12:02:43 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'readme.unix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'readme.unix'\"
else
echo shar: Extracting \"'readme.unix'\" \(286 characters\)
sed "s/^X//" >'readme.unix' <<'END_OF_FILE'
X
XNote to Unix users:
X
XAlthough the order.frm doesn't mention Unix versions, we do plan to
Xmake Unix packages of our commercial games as well.  Since there are
Xmany machines and many media types to consider, we're still working out
Xthe details.
X
XStay tuned!
X
XDave Baggett
Xdmb@ai.mit.edu
END_OF_FILE
if test 286 -ne `wc -c <'readme.unix'`; then
    echo shar: \"'readme.unix'\" unpacked with wrong size!
fi
# end of 'readme.unix'
fi
if test -f 'src/ccr-room.t1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ccr-room.t1'\"
else
echo shar: Extracting \"'src/ccr-room.t1'\" \(57085 characters\)
sed "s/^X//" >'src/ccr-room.t1' <<'END_OF_FILE'
X/*
X * Colossal Cave Revisited
X *
X * A remake of Willie Crowther and Don Woods' classic Adventure.
X * Converted from Donald Ekman's PC port of the original FORTRAN source.
X * TADS version by David M. Baggett for ADVENTIONS.
X *
X * Please document all changes in the history so we know who did what.
X *
X * This source code is copylefted under the terms of the GNU Public
X * License.  Essentially, this means that you are free to do whatever
X * you wish with this source code, provided you do not charge any
X * money for it or for any derivative works.
X *
X * ADVENTIONS distributes this game, but you are free to do what you will
X * with it, provided you adhere to the terms in the GNU Public License.
X * Send correspondence regarding this game or original works distributed
X * by ADVENTIONS to 
X *
X *	ADVENTIONS
X *	PO Box 851
X *	Columbia, MD 21044
X *
X * If you would like a catalog of releases, please enclose a SASE.  Thanks!
X *
X * Contributors
X *
X *	dmb	In real life:	David M. Baggett
X *		Internet:	<dmb@ai.mit.edu>
X *		Compu$erve:	76440,2671 (ADVENTIONS account)
X *		GEnie:		ADVENTIONS
X *
X * Modification History
X *
X *  1-Jan-93	dmb	rec.arts.int-fiction BETA release (source only)
X *                      For beta testing only -- not for general
X *			distribution.
X * 20-Apr-93	dmb	Added the stream decoration to Inside_Building
X *			you can get water there.
X *
X */
X
X/*
X * This file defines all the locations.
X */
X
X/*
X * First we need to define a new class for our rooms.
X * In the original fortran version of the game, you could move around
X * by naming adjacent places.  Since we want to retain this capability,
X * we need to augment the existing set of room movement methods.
X *
X * We also make rooms dark by default.
X *
X * We also need a few things to help our NPC's move about the cave
X * without getting stuck or wandering where they're not supposed to.
X *
X * IMPORTANT NOTE: If you add exit properties (i.e., things like
X * out, east, down, etc.), be sure to update the exitlist in ccr-npc.t
X * or NPC's won't know to look at them, and might get stuck!
X */
Xclass CCR_room: darkroom
X	//
X	// By default, exits don't go anywhere.
X	//
X	// The directional ones call noexit, the standard TADS
X	// "You can't go that way" method.
X	//
X	// The magic words print "Nothing happens."
X	//
X	// For the other words, the game tells the player it
X	// doesn't know how to apply the word in the given
X	// location.
X	//
X	jump = { "I don't see how that will help here."; return nil; }
X
X	//
X	// Directions
X	//
X	upstream = { return self.noexit; }
X	downstream = { return self.noexit; }
X	forwards = { return self.noexit; }
X	outdoors = { return self.noexit; }
X	left = { return self.noexit; }
X	right = { return self.noexit; }
X	cross = { return self.noexit; }
X	over = { return self.noexit; }
X	across = { return self.noexit; }
X
X	//
X	// Magic words
X	//
X	// Note that it's important to have these implemented as travel
X	// verbs because once the cave closes, these stop working just
X	// like the usual travel verbs.
X	//
X	// Non-travel magic words are defined in ccr-verbs.t
X	//
X	xyzzy = { return self.nothinghappens; }
X	y2 = { return self.nothinghappens; }
X	plugh = { return self.nothinghappens; }
X	plover = { return self.nothinghappens; }
X
X	//
X	// Feature names
X	//
X	// These allow limited teleporting to prominent locations.
X	//
X	road = { return self.doesnotapplyhere; }
X	forest = { return self.doesnotapplyhere; }
X	valley = { return self.doesnotapplyhere; }
X	stairs = { return self.doesnotapplyhere; }
X	building = { return self.doesnotapplyhere; }
X	gully = { return self.doesnotapplyhere; }
X	stream = { return self.doesnotapplyhere; }
X	rock = { return self.doesnotapplyhere; }
X	bed = { return self.doesnotapplyhere; }
X	crawl = { return self.doesnotapplyhere; }
X	cobble = { return self.doesnotapplyhere; }
X	tosurface = { return self.doesnotapplyhere; }
X	dark = { return self.doesnotapplyhere; }
X	passage = { return self.doesnotapplyhere; }
X	low = { return self.doesnotapplyhere; }
X	canyon = { return self.doesnotapplyhere; }
X	awkward = { return self.doesnotapplyhere; }
X	giant = { return self.doesnotapplyhere; }
X	view = { return self.doesnotapplyhere; }
X	pit = { return self.doesnotapplyhere; }
X	crack = { return self.doesnotapplyhere; }
X	steps = { return self.doesnotapplyhere; }
X	dome = { return self.doesnotapplyhere; }
X	hall = { return self.doesnotapplyhere; }
X	barren = { return self.doesnotapplyhere; }
X	debris = { return self.doesnotapplyhere; }
X	hole = { return self.doesnotapplyhere; }
X	wall = { return self.doesnotapplyhere; }
X	broken = { return self.doesnotapplyhere; }
X	floor = { return self.doesnotapplyhere; }
X	toroom = { return self.doesnotapplyhere; }
X	slit = { return self.doesnotapplyhere; }
X	slab = { return self.doesnotapplyhere; }
X	depression = { return self.doesnotapplyhere; }
X	entrance = { return self.doesnotapplyhere; }
X	secret = { return self.doesnotapplyhere; }
X	cave = { return self.doesnotapplyhere; }
X	bedquilt = { return self.doesnotapplyhere; }
X	oriental = { return self.doesnotapplyhere; }
X	cavern = { return self.doesnotapplyhere; }
X	shell = { return self.doesnotapplyhere; }
X	reservoir = { return self.doesnotapplyhere; }
X	main = { return self.doesnotapplyhere; }
X	office = { return self.doesnotapplyhere; }
X	fork = { return self.doesnotapplyhere; }
X
X	nothinghappens = {
X		"Nothing happens.";
X		return nil;
X	}
X	doesnotapplyhere = {
X		"I don't know how to apply that word here.";
X		return nil;
X	}
X
X	//
X	// Exits for NPC's.  Since NPC's won't take regular exits
X	// that are methods (instead of simple object names), we
X	// have to add "hints" in some rooms to allow complete access
X	// to all rooms.  By default, these are all nil.  (Note that
X	// it is important for them to be nil ojects, and not methods
X	// that return nil.  If they are methods, NPC's will try them.)
X	//
X	NPCexit1 = nil
X	NPCexit2 = nil
X	NPCexit3 = nil
X	NPCexit4 = nil
X	NPCexit5 = nil
X	NPCexit6 = nil
X	NPCexit7 = nil
X	NPCexit8 = nil
X
X	//
X	// Each room has a list of exit properties that can be considered by
X	// NPC's.  The lists is determined at preinit time by looking
X	// at all the exit methods and discarding those that are methods.
X	// (The NPCexits are always considered, whether they are methods
X	// or not, since they're guranteed not to print anything or
X	// change game state when they're run.)
X	//
X	// Note: the list doesn't contain locations; it contains properties;
X	// i.e., it contains [ &west &up ... ], not [ At_Y2 ... ].
X	//
X	NPCexits = []
X;
X
X/*
X * A class for the rooms in the "alike" maze.
X */
Xclass CCR_alike_maze_room: CCR_room
X	sdesc = "Maze of Twisty Little Passages, All Alike"
X	ldesc = {
X		I(); "You are in a maze of twisty little passages, 
X		all alike.";
X	}
X;
X
X/*
X * A class for rooms that are forbidden to non-player characters.
X * (This means dwarves and pirate, not bear.)
X *
X * All pits inherit this class because the original source claims
X * that dwarves won't follow the player into a pit, even though
X * they do.  It makes more sense for them to give up the chase
X * when the player scrambles down into a pit, and for that matter
X * it may sound a bit funny for a combat to occur in a little pit,
X  * so I've add NoNPC too all the pit rooms.
X */
Xclass NoNPC: CCR_room
X	noNPCs = true
X;
X
X/*
X * A class for the dead ends.
X */
Xclass CCR_dead_end_room: CCR_room
X	sdesc = "At a Dead End"
X	ldesc = {
X		I(); "You have reached a dead end.";
X	}
X;
X
X/*
X * A class for areas that are naturally lit.
X */
Xclass lightroom: CCR_room
X	islit = true
X;
X
X/*
X * A class for rooms that are outside.
X * These rooms are off limits once the cave is closed.
X */
Xclass Outside: CCR_room
X	isoutside = true
X;
X
X/*
X * A class for rooms that aren't far enough in to earn the player
X * the bonus for getting "well in."
X *
X * See the definition of Me in ccr-std.t for info on how this is used.
X */
Xclass NotFarIn: CCR_room, NoNPC
X	notfarin = true
X;
X
Xclass CCR_decoration: decoration;
X
X/*
X * This class lets us easily define a decoration that's in multiple
X * places at once.  You just list the locations it appears in in
X * a list called loclist.
X *
X * This is particularly nice for things like water, which can be
X * manipulated -- we only have one object name to consider (Stream)
X * for all the water in the game that can be taken.  (See ioPutIn
X * for the bottle in ccr-item.t)
X */
Xclass floatingdecoration: CCR_decoration
X	locationOK = true	// OK for location to be method
X	location = {
X		if (find(self.loclist, Me.location))
X			return Me.location;
X		else
X			return nil;
X	}
X;
X
X/*
X * The locations
X */
XAt_End_Of_Road: CCR_room, lightroom, NotFarIn, Outside
X	sdesc = "At End Of Road"
X	ldesc = {
X		I(); "You are standing at the end of a road before a 
X		small brick building. Around you is a forest.  A 
X		small stream flows out of the building and down a 
X		gully.";
X	}
X	road = At_Hill_In_Road
X	west = At_Hill_In_Road
X	up = At_Hill_In_Road
X	building = Inside_Building
X	in = Inside_Building
X	east = Inside_Building
X	downstream = In_A_Valley
X	gully = In_A_Valley
X	stream = In_A_Valley
X	south = In_A_Valley
X	down = In_A_Valley
X	forest = In_Forest_1
X	north = In_Forest_1
X	depression = Outside_Grate
X
X	// This was in the original fortran code, but conflicts
X	// with the fact that the building is to the east:
X	// east = In_Forest
X;
XBuilding: floatingdecoration
X	sdesc = "building"
X	ldesc = {
X		if (Me.isIn(Inside_Building))
X			"You're in it.";
X		else
X			"It's a small brick building.  It seems to be 
X			a well house.";
X	}
X	noun = 'building' 'house' 'wellhouse'
X	adjective = 'well' 'small' 'brick'
X	loclist = [ At_End_Of_Road  At_Hill_In_Road  Inside_Building ]
X
X	verDoEnter(actor) = {}
X	doEnter(actor) = {
X		actor.travelTo(At_End_Of_Road.in);
X	}
X;
XRoad: floatingdecoration
X	sdesc = "road"
X	noun = 'road' 'street' 'path'
X	adjective = 'dirt'
X	loclist = [ At_End_Of_Road  At_Hill_In_Road  In_Forest_2 ]
X;
XForest: floatingdecoration
X	sdesc = "forest"
X	adesc = "forest"
X	ldesc = {
X		"The trees of the forest are large hardwood oak and 
X		maple, with an occasional grove of pine or spruce.  
X		There is quite a bit of undergrowth, largely birch 
X		and ash saplings plus nondescript bushes of various 
X		sorts.  This time of year visibility is quite 
X		restricted by all the leaves, but travel is quite 
X		easy if you detour around the spruce and berry 
X		bushes.";
X	}
X
X	noun = 'forest' 'tree' 'trees' 'oak' 'maple' 'grove' 'pine'
X		'spruce' 'birch' 'ash' 'saplings' 'bushes' 'leaves'
X		'berry' 'berries'
X	adjective = 'surrounding' 'open' 'hardwood' 'oak' 'maple' 'pine'
X		'spruce' 'birch' 'ash' 'berry'
X	loclist = [
X		At_End_Of_Road  At_Hill_In_Road  In_A_Valley
X		In_Forest_1  In_Forest_2
X	]
X;
XStream: floatingdecoration
X	sdesc = "stream"
X	ldesc = {
X		if (Me.isIn(Inside_Building))
X			"The stream flows out through a pair of 1 
X			foot diameter sewer pipes.";
X		else
X			pass ldesc;
X	}
X	noun = 'stream' 'water' 'brook' 'river' 'lake'
X	adjective = 'small' 'tumbling' 'splashing' 'babbling' 'rushing'
X		'reservoir'
X	loclist = [
X		At_End_Of_Road  In_A_Valley  At_Slit_In_Streambed
X		In_Pit  In_Cavern_With_Waterfall  At_Reservoir
X		Inside_Building
X	]
X
X	verDoDrink(actor) = {}
X	doDrink(actor) = {
X		"You have taken a drink from the stream.  The water 
X		tastes strongly of minerals, but is not unpleasant.  
X		It is extremely cold.";
X	}
X
X	verDoTake(actor) = {
X		if (not bottle.isIn(Me))
X			"You have nothing in which to carry the water.";
X	}
X	doTake(actor) = {
X		bottle.ioPutIn(actor, self);
X	}
X	verDoPutIn(actor, io) = {}
X	doPutIn(actor, io) = {
X		if (io <> bottle)
X			"You have nothing in which to carry the water.";
X		else
X			bottle.ioPutIn(actor, self);
X	}
X;
XGully: floatingdecoration
X	sdesc = "gully"
X	noun = 'gully'
X	loclist = [ At_End_Of_Road  At_Slit_In_Streambed  Outside_Grate ]
X;
X
XAt_Hill_In_Road: CCR_room, lightroom, NotFarIn, Outside
X	sdesc = "At Hill In Road"
X	ldesc = {
X		I(); "You have walked up a hill, still in the forest. 
X		The road slopes back down the other side of the 
X		hill.  There is a building in the distance.";
X	}
X	road = At_End_Of_Road
X	building = At_End_Of_Road
X	forwards = At_End_Of_Road
X	east = At_End_Of_Road
X	north = At_End_Of_Road
X	down = At_End_Of_Road
X	forest = In_Forest_1
X	south = In_Forest_1
X
X	// Another bug in the original code:
X	// north = In_Forest
X;
XHill: CCR_decoration
X	sdesc = "hill"
X	ldesc = "It's just a typical hill."
X	noun = 'hill' 'bump' 'incline'
X	location = At_Hill_In_Road
X;
XOtherSideOfHill: CCR_decoration
X	sdesc = "other side of hill"
X	thedesc = "the other side of the hill"
X	adesc = { self.thedesc; }
X	ldesc = "Why not explore it yourself?"
X	noun = 'side'
X	adjective = 'other'
X	location = At_Hill_In_Road
X;
X
XInside_Building: CCR_room, lightroom, NotFarIn, Outside
X	sdesc = "Inside Building"
X	ldesc = {
X		I(); "You are inside a building, a well house for a 
X		large spring.";
X	}
X	out = At_End_Of_Road
X	outdoors = At_End_Of_Road
X	west = At_End_Of_Road
X	xyzzy = In_Debris_Room
X	plugh = At_Y2
X	downstream = { return self.stream; }
X	stream = {
X		"The stream flows out through a pair of 1 foot 
X		diameter sewer pipes. It would be advisable to use 
X		the exit.";
X
X		return nil;
X	}
X;
XSpring: CCR_decoration
X	sdesc = "spring"
X	location = Inside_Building
X	noun = 'spring'
X	adjective = 'large'
X;
XSewerPipes: CCR_decoration
X	sdesc = "pair of 1 foot diameter sewer pipes"
X	location = Inside_Building
X	noun = 'pipes' 'pipe'
X	adjective = 'one' 'foot' '1-foot' 'diameter' 'sewer'
X;
X
XIn_A_Valley: CCR_room, lightroom, NotFarIn, Outside
X	sdesc = "In A Valley"
X	ldesc = {
X		I(); "You are in a valley in the forest beside a 
X		stream tumbling along a rocky bed.";
X	}
X	upstream = At_End_Of_Road
X	building = At_End_Of_Road
X	north = At_End_Of_Road
X	forest = In_Forest_1
X	east = In_Forest_1
X	west = In_Forest_1
X	up = In_Forest_1
X	downstream = At_Slit_In_Streambed
X	south = At_Slit_In_Streambed
X	down = At_Slit_In_Streambed
X	depression = Outside_Grate
X;
XStreambed: floatingdecoration
X	sdesc = "streambed"
X	noun = 'bed' 'streambed' 'rock'
X	adjective = 'stream' 'water' 'river' 'small' 'tumbling' 'splashing'
X			'babbling' 'rushing' 'rocky' 'bare' 'dry'
X	loclist = [ In_A_Valley  At_Slit_In_Streambed  Outside_Grate ]
X;
XValley: floatingdecoration
X	sdesc = "valley"
X	ldesc = {
X		if (Me.isIn(In_A_Valley))
X			"You're in it.";
X		else
X			pass ldesc;
X	}
X	noun = 'valley'
X	adjective = 'deep'
X	loclist = [ In_A_Valley  In_Forest_1  In_Forest_2 ]
X;
X
XIn_Forest_1: CCR_room, lightroom, NotFarIn, Outside
X	sdesc = "In Forest"
X	ldesc = {
X		I(); "You are in open forest, with a deep valley to 
X		one side.";
X	}
X	valley = In_A_Valley
X	east = In_A_Valley
X	down = In_A_Valley
X
X	// An approximation of the original code:
X	forest = {
X		if (rand(100) <= 50)
X			return In_Forest_1;
X		else
X			return In_Forest_2;
X	}
X
X	forwards = In_Forest_1
X	north = In_Forest_1
X	west = In_Forest_1
X	south = In_Forest_1
X;
X
XIn_Forest_2: CCR_room, lightroom, NotFarIn, Outside
X	sdesc = "In Forest"
X	ldesc = {
X		I(); "You are in open forest near both a valley and a 
X		road.";
X	}
X	road = At_End_Of_Road
X	north = At_End_Of_Road
X	valley = In_A_Valley
X	east = In_A_Valley
X	west = In_A_Valley
X	down = In_A_Valley
X	forest = In_Forest_1
X	south = In_Forest_1
X;
X
XAt_Slit_In_Streambed: CCR_room, lightroom, NotFarIn, Outside
X	sdesc = "At Slit In Streambed"
X	ldesc = {
X		I(); "At your feet all the water of the stream 
X		splashes into a 2-inch slit in the rock.  Downstream 
X		the streambed is bare rock.";
X	}
X	building = At_End_Of_Road
X	upstream = In_A_Valley
X	north = In_A_Valley
X	forest = In_Forest_1
X	east = In_Forest_1
X	west = In_Forest_1
X	downstream = Outside_Grate
X	rock = Outside_Grate
X	bed = Outside_Grate
X	south = Outside_Grate
X
X	slit = { return self.down; }
X	stream = { return self.down; }
X	down = {
X		"You don't fit through a two-inch slit!";
X		return nil;
X	}
X;
XSlit: CCR_decoration
X	sdesc = "2-inch slit"
X	ldesc = "It's just a 2-inch slit in the rock, through which the
X		stream is flowing."
X	location = At_Slit_In_Streambed
X	noun = 'slit'
X	adjective = 'two' 'inch' '2-inch' 'two-inch'
X;
X
XOutside_Grate: CCR_room, lightroom, NotFarIn, Outside
X	sdesc = "Outside Grate"
X	ldesc = {
X		I(); "You are in a 20-foot depression floored with 
X		bare dirt.  Set into the dirt is a strong steel grate 
X		mounted in concrete.  A dry streambed leads into the 
X		depression.";
X	}
X	forest = In_Forest_1
X	east = In_Forest_1
X	west = In_Forest_1
X	south = In_Forest_1
X	building = At_End_Of_Road
X	upstream = At_Slit_In_Streambed
X	gully = At_Slit_In_Streambed
X	north = At_Slit_In_Streambed
X	
X	in = { return self.down; }
X	down = {
X		Grate.doEnter(Me);
X		return nil;
X	}
X;
XDepression: CCR_decoration
X	sdesc = "20-foot depression"
X	ldesc = "You're standing in it."
X	location = Outside_Grate
X	noun = 'depression' 'dirt'
X	adjective = '20-foot' 'twenty' 'foot' 'twenty-foot' 'bare'
X;
XGrate: fixeditem, keyedLockable
X	isopen = nil
X	islocked = true
X	sdesc = "steel grate"
X	ldesc = {
X		if (self.isIn(Outside_Grate)) {
X			"It just looks like an ordinary grate
X			mounted in concrete.";
X		}
X		else {
X			"It's just a 3x3 steel grate mounted
X			in the ceiling.";
X		}
X
X		" It is ";
X		if (self.isopen)
X			"open.";
X		else if (self.islocked) 
X			"closed and locked.";
X		else 
X			"closed.";
X	}
X	noun = 'grate' 'lock' 'gate' 'grille'
X	adjective = 'metal' 'strong' 'steel' 'open' 'closed' 'locked'
X		'unlocked'
X
X	locationOK = true // Tell compiler OK for location to be method
X	location = {
X		if (Me.isIn(Outside_Grate))
X			return Outside_Grate;
X		else	    
X			return Below_The_Grate;
X	}
X	mykey = set_of_keys
X
X	verDoEnter(actor) = {}
X	doEnter(actor) = {
X		if (not Grate.islocked) {
X			if (not Grate.isopen) {
X				"(Opening the grate first.)\b";
X				Grate.isopen := true;
X						
X			}
X			if (actor.isIn(Outside_Grate))
X				actor.travelTo(Below_The_Grate);
X			else
X				actor.travelTo(Outside_Grate);
X		}
X		else {
X			"You can't go through a locked steel grate!";
X		}
X	}
X	
X	verIoPutIn(actor) = { "You can't put anything in that! "; }
X	verDoPick = { "You have no tools to pick the lock with."; }
X;
X
XBelow_The_Grate: CCR_room, lightroom, NotFarIn
X	sdesc = "Below the Grate"
X	ldesc = {
X		I(); "You are in a small chamber beneath a 3x3 steel 
X		grate to the surface. A low crawl over cobbles leads 
X		inward to the west.";
X	}
X	crawl = In_Cobble_Crawl
X	cobble = In_Cobble_Crawl
X	in = In_Cobble_Crawl
X	west = In_Cobble_Crawl
X	pit = At_Top_Of_Small_Pit
X	debris = In_Debris_Room
X
X	outdoors = { return self.up; }	// DMB: added
X	out = { return self.up; }
X	up = {
X		Grate.doEnter(Me);
X		return nil;
X	}
X;
XCobbles: floatingdecoration
X	sdesc = "cobbles"
X	adesc = "cobbles"
X	ldesc = "They're just ordinary cobbles."
X	noun = 'cobble' 'cobbles' 'cobblestones' 'cobblestone' 'stones'
X		'stone'
X	adjective = 'cobble'
X	loclist = [ Below_The_Grate  In_Cobble_Crawl  In_Debris_Room ]
X;
X
XIn_Cobble_Crawl: CCR_room, lightroom, NotFarIn
X	sdesc = "In Cobble Crawl"
X	ldesc = {
X		I(); "You are crawling over cobbles in a low passage. 
X		There is a dim light at the east end of the 
X		passage.";
X	}
X	out = Below_The_Grate
X	tosurface = Below_The_Grate
X	east = Below_The_Grate
X	in = In_Debris_Room
X	dark = In_Debris_Room
X	west = In_Debris_Room
X	debris = In_Debris_Room
X	pit = At_Top_Of_Small_Pit
X
X	// DMB: added the following, in accordance with its presence
X	// in In_Debris_Room and rooms beyond.
X	depression = {
X		Grate.doEnter(Me);
X
X		// If the player didn't move, the grate must be
X		// locked.  Move the player underneath the grate.
X		if (Me.isIn(self)) {
X			"\b";
X			Me.travelTo(Below_The_Grate);
X		}
X		// We've already moved the player, but we have to
X		// return a value, so just return nil (which results
X		// in no more movement).
X		return nil;
X	}
X;
X
XIn_Debris_Room: CCR_room, NotFarIn
X	sdesc = "In Debris Room"
X	ldesc = {
X		I(); "You are in a debris room filled with stuff 
X		washed in from the surface. A low wide passage with 
X		cobbles becomes plugged with mud and debris here, but 
X		an awkward canyon leads upward and west."; P();
X
X		I(); "A note on the wall says, \"Magic word XYZZY.\"";
X	}
X	entrance = Below_The_Grate
X	crawl = In_Cobble_Crawl
X	cobble = In_Cobble_Crawl
X	passage = In_Cobble_Crawl
X	low = In_Cobble_Crawl
X	east = In_Cobble_Crawl
X	canyon = In_Awkward_Sloping_E_W_Canyon
X	in = In_Awkward_Sloping_E_W_Canyon
X	up = In_Awkward_Sloping_E_W_Canyon
X	west = In_Awkward_Sloping_E_W_Canyon
X	xyzzy = Inside_Building
X	pit = At_Top_Of_Small_Pit
X
X	// The original occasionally allowed the player to teleport
X	// large distances in one turn.  This is just one example.
X	depression = {
X		Grate.doEnter(Me);
X
X		// If the player didn't move, the grate must be
X		// locked.  Move the player underneath the grate.
X		if (Me.isIn(self)) {
X			"\b";
X			Me.travelTo(Below_The_Grate);
X		}
X
X		// We've already moved the player, but we have to
X		// return a value, so just return nil (which results
X		// in no more movement).
X		return nil;
X	}
X;
XDebris: floatingdecoration
X	sdesc = "debris"
X	ldesc = "Yuck."
X	noun = 'debris' 'stuff' 'mud'
X	loclist = [ In_Debris_Room  In_Arched_Hall ]
X;
XXyzzyNote: CCR_decoration, readable
X	sdesc = "note"
X	ldesc = { self.readdesc; }
X	readdesc = "The note says \"Magic word XYZZY\"."
X	noun = 'note'
X	location = In_Debris_Room
X;
X
XIn_Awkward_Sloping_E_W_Canyon: CCR_room, NotFarIn
X	sdesc = "In Awkward Sloping E/W Canyon"
X	ldesc = {
X		I(); "You are in an awkward sloping east/west 
X		canyon.";
X	}
X
X	entrance = Below_The_Grate
X	down = In_Debris_Room
X	east = In_Debris_Room
X	debris = In_Debris_Room
X	in = In_Bird_Chamber
X	up = In_Bird_Chamber
X	west = In_Bird_Chamber
X	pit = At_Top_Of_Small_Pit
X
X	depression = {
X		Grate.doEnter(Me);
X
X		// If the player didn't move, the grate must be
X		// locked.  Move the player underneath the grate.
X		if (Me.isIn(self)) {
X			"\b";
X			Me.travelTo(Below_The_Grate);
X		}
X		
X		// We've already moved the player, but we have to
X		// return a value, so just return nil (which results
X		// in no more movement).
X		return nil;
X	}
X;
X
XIn_Bird_Chamber: CCR_room, NotFarIn
X	sdesc = "In Bird Chamber"
X	ldesc = {
X		I(); "You are in a splendid chamber thirty feet high. 
X		The walls are frozen rivers of orange stone.  An 
X		awkward canyon and a good passage exit from east and 
X		west sides of the chamber.";
X	}
X
X	entrance = Below_The_Grate
X	debris = In_Debris_Room
X	canyon = In_Awkward_Sloping_E_W_Canyon
X	east = In_Awkward_Sloping_E_W_Canyon
X	passage = At_Top_Of_Small_Pit
X	pit = At_Top_Of_Small_Pit
X	west = At_Top_Of_Small_Pit
X
X	depression = {
X		Grate.doEnter(Me);
X
X		// If the player didn't move, the grate must be
X		// locked.  Move the player underneath the grate.
X		if (Me.isIn(self)) {
X			"\b";
X			Me.travelTo(Below_The_Grate);
X		}
X
X		// We've already moved the player, but we have to
X		// return a value, so just return nil (which results
X		// in no more movement).
X		return nil;
X	}
X;
X
XAt_Top_Of_Small_Pit: CCR_room, NotFarIn
X	sdesc = "At Top of Small Pit"
X	ldesc = {
X		// Note: this used to say "An east passage ends here..."
X		// but that's obviously a mistake.
X
X		I(); "At your feet is a small pit breathing traces of 
X		white mist.  A west passage ends here except for a 
X		small crack leading on."; P();
X
X		I(); "Rough stone steps lead down the pit.";
X	}
X	entrance = Below_The_Grate
X	debris = In_Debris_Room
X	passage = In_Bird_Chamber
X	east = In_Bird_Chamber
X	crack = { return self.west; }
X	west = {
X		"The crack is far too small for you to follow.";
X		return nil;
X	}
X
X	down = {
X		if (large_gold_nugget.isIn(Me))
X			return broken_neck.death;
X		else
X			return In_Hall_Of_Mists;
X	}
X
X	depression = {
X		Grate.doEnter(Me);
X
X		// If the player didn't move, the grate must be
X		// locked.  Move the player underneath the grate.
X		if (Me.isIn(self)) {
X			"\b";
X			Me.travelTo(Below_The_Grate);
X		}
X		
X		// We've already moved the player, but we have to
X		// return a value, so just return nil (which results
X		// in no more movement).
X		return nil;
X	}
X; 
XSmallPit: CCR_decoration
X	sdesc = "small pit"
X	ldesc = "The pit is breathing traces of white mist."
X	location = At_Top_Of_Small_Pit
X	noun = 'pit'
X;
XPitCrack: CCR_decoration
X	sdesc = "crack"
X	ldesc = "The crack is very small -- far too small for you to follow."
X	location = At_Top_Of_Small_Pit
X	noun = 'crack'
X	adjective = 'small'
X;
XMist: floatingdecoration
X	sdesc = "mist"
X	ldesc = {
X		"Mist is a white vapor, usually water, seen from time 
X		to time in caverns.  It can be found anywhere but is 
X		frequently a sign of a deep pit leading down to 
X		water.";
X	}
X	noun = 'mist' 'vapor' 'wisps'
X	adjective = 'white' 'water'
X	loclist = [
X		At_Top_Of_Small_Pit In_Hall_Of_Mists
X		On_East_Bank_Of_Fissure  At_Window_On_Pit_1
X		At_West_End_Of_Hall_Of_Mists In_Misty_Cavern
X		In_Mirror_Canyon  At_Reservoir At_Window_On_Pit_2
X		On_Sw_Side_Of_Chasm
X	]
X;
X
XIn_Hall_Of_Mists: CCR_room
X	sdesc = "In Hall of Mists"
X	ldesc = {
X		I(); "You are at one end of a vast hall stretching 
X		forward out of sight to the west.  There are openings 
X		to either side.  Nearby, a wide stone staircase leads 
X		downward.  The hall is filled with wisps of white 
X		mist swaying to and fro almost as if alive.  A cold 
X		wind blows up the staircase.  There is a passage at 
X		the top of a dome behind you."; P();
X
X		I(); "Rough stone steps lead up the dome.";
X	}
X	left = In_Nugget_Of_Gold_Room
X	south = In_Nugget_Of_Gold_Room
X	forwards = On_East_Bank_Of_Fissure
X	hall = On_East_Bank_Of_Fissure
X	west = On_East_Bank_Of_Fissure
X	stairs = In_Hall_Of_Mt_King
X	down = In_Hall_Of_Mt_King
X	north = In_Hall_Of_Mt_King
X	y2 = Jumble_Of_Rock
X
X	up = {
X		if (large_gold_nugget.isIn(Me)) {
X			"The dome is unclimbable.";
X			return nil;
X		}
X		else {
X			return At_Top_Of_Small_Pit;
X		}
X	}
X;
XStaircase: CCR_decoration
X	sdesc = "wide stone staircase"
X	ldesc = "The staircase leads down."
X	location = In_Hall_Of_Mists
X	noun = 'stair' 'stairs' 'staircase'
X	adjective = 'wide' 'stone'
X;
XDomeSteps: CCR_decoration
X	sdesc = "rough stone steps"
X	ldesc = "The rough stone steps lead up the dome."
X	location = In_Hall_Of_Mists
X	noun = 'stair' 'stairs' 'staircase'
X	adjective = 'rough' 'stone'
X;
XDome: CCR_decoration
X	sdesc = "dome"
X	ldesc = {
X		if (large_gold_nugget.isIn(Me))
X			"I'm not sure you'll be able to get up it
X			with what you're carrying.";
X		else
X			"It looks like you might be able to climb up it.";
X	}
X	location = In_Hall_Of_Mists
X	noun = 'dome'
X
X	verDoClimb(actor) = {}
X	doClimb(actor) = {
X		actor.travelTo(In_Hall_Of_Mists.up);
X	}
X;
X
XOn_East_Bank_Of_Fissure: CCR_room
X	sdesc = "On East Bank of Fissure"
X	ldesc = {
X		I(); "You are on the east bank of a fissure slicing 
X		clear across the hall. The mist is quite thick here, 
X		and the fissure is too wide to jump.";
X
X 		if (CrystalBridge.exists) {
X			P(); I();
X			"A crystal bridge now spans the fissure.";
X		}
X	}
X	hall = In_Hall_Of_Mists
X	east = In_Hall_Of_Mists
X
X	forwards = { return self.jump; }
X	jump = {
X		if (CrystalBridge.exists) {
X			"I respectfully suggest you go across the 
X			bridge instead of jumping.";
X
X			return nil;
X		}
X		else
X			return didnt_make_it.death;
X	}
X
X	over = { return self.across; }
X	west = { return self.across; }
X	cross = { return self.across; }
X	across = {
X		CrystalBridge.doCross(Me);
X		return nil;
X	}
X
X	//
X	// NPC's can go across too, but only if the bridge exists.
X	//
X	NPCexit1 = {
X		if (CrystalBridge.exists)
X			return West_Side_Of_Fissure;
X		else
X			return nil;
X	}
X;
XBridgeFissure: floatingdecoration
X	sdesc = "fissure"
X	ldesc = {
X		if (CrystalBridge.exists)
X			"A crystal bridge now spans the fissure.";
X		else
X			"The fissure looks far too wide to jump.";
X	}
X	noun = 'fissure'
X	adjective = 'wide'
X	loclist = [ West_Side_Of_Fissure  On_East_Bank_Of_Fissure ]
X;
XCrystalBridge: CCR_decoration
X	exists = nil
X	sdesc = "Crystal bridge"
X	ldesc = "It spans the fissure, thereby providing you a way across."
X	locationOK = true	// tell compiler OK for location to be method
X	location = {
X		if (self.exists) {
X			if (Me.isIn(West_Side_Of_Fissure))
X				return West_Side_Of_Fissure;
X			else
X				return On_East_Bank_Of_Fissure;
X		}
X		else
X			return nil;
X	}
X	noun = 'bridge'
X	adjective = 'crystal' 'magic' 'rod'
X
X	verDoCross(actor) = {}
X	doCross(actor) = {
X		if (self.exists) {
X			if (actor.isIn(On_East_Bank_Of_Fissure))
X				actor.travelTo(West_Side_Of_Fissure);
X			else
X				actor.travelTo(On_East_Bank_Of_Fissure);
X		}
X		else
X			"There is no way across the fissure.";
X	}
X;
X
XIn_Nugget_Of_Gold_Room: CCR_room
X	sdesc = "In Nugget of Gold Room"
X	ldesc = {
X		I(); "This is a low room with a crude note on the 
X		wall. "; NuggetNote.readdesc;
X	}
X	hall = In_Hall_Of_Mists
X	out = In_Hall_Of_Mists
X	north = In_Hall_Of_Mists
X;
XNuggetNote: CCR_decoration, readable
X	sdesc = "note"
X	ldesc = { self.readdesc; }
X	readdesc = {
X		"The note says, \"You won't get it up the steps\".";
X	}
X	location = In_Nugget_Of_Gold_Room
X	noun = 'note'
X	adjective = 'crude'
X;
X
XIn_Hall_Of_Mt_King: CCR_room
X	sdesc = "In Hall of Mt King"
X	ldesc = {
X		I(); "You are in the hall of the mountain king, with 
X		passages off in all directions.";
X
X		if (Snake.isIn(self)) {
X			P();
X			I(); "A huge green fierce snake bars the way!";
X		}
X	}
X	stairs = In_Hall_Of_Mists
X	up = In_Hall_Of_Mists
X	east = In_Hall_Of_Mists
X
X	left = { return self.north; }
X	north = {
X		if (self.snakecheck)
X			return Low_N_S_Passage;
X		else
X			return nil;
X	}
X	
X	right = { return self.south; }
X	south = {
X		if (self.snakecheck)
X			return In_South_Side_Chamber;
X		else
X			return nil;
X	}
X
X	forwards = { return self.west; }
X	west = {
X		if (self.snakecheck)
X			return In_West_Side_Chamber;
X		else
X			return nil;
X	}
X
X	/*
X	 * An interesting little bit of trivia here:
X	 * 35% of the time you can slip past the snake and into
X	 * the secret canyon.  (This is in the original fortran
X	 * code.)  But if you say "secret" you will *always* sneak
X	 * by it.
X	 */
X	sw = {
X		if (rand(100) <= 35) {
X			return In_Secret_E_W_Canyon;
X		}
X		else {
X			if (self.snakecheck)
X				return In_Secret_E_W_Canyon;
X			else
X				return nil;
X		}
X	}
X	secret = In_Secret_E_W_Canyon
X
X	snakecheck = {
X		if (Snake.isIn(Me.location)) {
X			"You can't get by the snake.";
X			return nil;
X		}
X		else
X			return true;
X	}
X;
XSnake: CCR_decoration
X	sdesc = "snake"
X	ldesc = "I wouldn't mess with it if I were you."
X	location = In_Hall_Of_Mt_King
X	noun = 'snake' 'cobra' 'asp'
X	adjective = 'huge' 'fierce' 'green' 'ferocious' 'venemous'
X		'venomous' 'large' 'big' 'killer'
X
X	verDoFeed(actor) = {}
X	doFeed(actor) = {
X		if (little_bird.isIn(Me)) {
X			"The snake has now devoured your bird.";
X			little_bird.moveInto(nil);
X		}
X		else if (little_bird.isIn(self.location))
X			"You have nothing to feed it.";
X		else
X			"There's nothing here it wants to eat (except 
X			perhaps you).";
X	}
X	verIoGiveTo(actor) = {}
X	doGiveTo(actor, dobj) = {
X		if (dobj = little_bird)
X			self.doFeed(actor);
X		else {
X			"The snake does not seem interested in ";
X			dobj.thedesc; ".";
X		}
X	}
X	
X	verDoAttack(actor) = {}
X	doAttack(actor) = {
X		"Attacking the snake both doesn't work and is very 
X		dangerous.";
X	}
X	verDoAttackWith(actor, io) = { self.verDoAttack(actor); }
X	doAttackWith(actor, io) = { self.doAttack(actor); }
X
X	verIoThrowAt(actor) = { self.verIoGiveTo(actor); }
X	ioThrowAt(actor, dobj) = {
X		if (dobj = axe)
X			self.doAttackWith(actor, dobj);
X		else
X			self.ioGiveTo(actor, dobj);
X	}
X	verIoThrowTo(actor) = { self.verIoGiveTo(actor); }
X	ioThrowTo(actor, dobj) = {
X		if (dobj = axe)
X			self.doAttackWith(actor, dobj);
X		else
X			self.ioGiveTo(actor, dobj);
X	}
X	
X	verDoKick(actor) = {}
X	doKick(actor) = { "That would be satisfying, but totally insane."; }
X
X	verifyRemove(actor) = { "Surely you're joking."; }
X;
X
XAt_West_End_Of_Twopit_Room: CCR_room
X	sdesc = "At West End of Twopit Room"
X	ldesc = {
X		I(); "You are at the west end of the twopit room.  
X 		There is a large hole in the wall above the pit at 
X		this end of the room.";
X
X		if (PlantStickingUp.isIn(self)) {
X			P(); I(); PlantStickingUp.ldesc;
X		}
X	}
X	east = At_East_End_Of_Twopit_Room
X	across = At_East_End_Of_Twopit_Room
X	west = In_Slab_Room
X	slab = In_Slab_Room
X	down = In_West_Pit
X	pit = In_West_Pit
X
X	up = { return self.hole; }	// DMB: added
X	hole = {
X		"It is too far up for you to reach.";
X		return nil;
X	}
X;
XHoleAbovePit_1: CCR_decoration
X	sdesc = "hole above pit"
X	ldesc = {
X		"The hole is in the wall above the pit at 
X		this end of the room.";
X	}
X	noun = 'hole'
X	adjective = 'large'
X	location = At_West_End_Of_Twopit_Room
X
X	verDoEnter(actor) = { "It is too far up for you to reach."; }
X;
XPlantStickingUp: CCR_decoration
X	sdesc = {
X		if (Plant.size = 1)
X			"top of 12-foot-tall beanstalk";
X		else
X			"huge beanstalk";
X	}
X	ldesc = {
X		if (Plant.size = 1)
X			"The top of a 12-foot-tall beanstalk is 
X			poking out of the west pit.";
X		else
X			"There is a huge beanstalk growing out of the 
X			west pit up to the hole.";
X	}
X	noun = 'plant' 'beanstalk' 'stalk'
X	adjective = 'bean' 'giant' 'tiny' 'little' 'murmuring'
X		'12-foot-tall' 'twelve' 'foot' 'tall' 'bellowing'
X
X	location = {
X		if (Plant.size = 0)
X			return nil;
X		else if (Me.isIn(At_West_End_Of_Twopit_Room))
X			return At_West_End_Of_Twopit_Room;
X		else
X			return At_East_End_Of_Twopit_Room;		
X	}
X;
X
XIn_East_Pit: CCR_room, NoNPC
X	sdesc = "In East Pit"
X	ldesc = {
X		I(); "You are at the bottom of the eastern pit in the 
X		twopit room.  There is a small pool of oil in one 
X		corner of the pit.";
X	}
X	up = At_East_End_Of_Twopit_Room
X	out = At_East_End_Of_Twopit_Room
X;
XEastPit: CCR_decoration
X	sdesc = "eastern pit"
X	ldesc = "You're in it."
X	noun = 'pit' 'corner'
X	adjective = 'east' 'eastern'
X	location = In_East_Pit
X;
XOil: CCR_decoration
X	sdesc = "pool of oil"
X	noun = 'pool' 'oil'
X	adjective = 'small'
X	location = In_East_Pit
X
X	verDoTake(actor) = {
X		if (not bottle.isIn(Me))
X			"You have nothing in which to carry the oil.";
X	}
X	doTake(actor) = {
X		bottle.ioPutIn(actor, self);
X	}
X	verDoPutIn(actor, io) = {}
X	doPutIn(actor, io) = {
X		if (io <> bottle)
X			"You have nothing in which to carry the oil.";
X		else
X			bottle.ioPutIn(actor, self);
X	}
X;
X
XIn_West_Pit: CCR_room, NoNPC
X	sdesc = "In West Pit"
X	ldesc = {
X		I(); "You are at the bottom of the western pit in the 
X		twopit room.  There is a large hole in the wall about 
X		25 feet above you."; P();
X
X		I(); Plant.ldesc;
X	}
X	up = At_West_End_Of_Twopit_Room
X	out = At_West_End_Of_Twopit_Room
X	climb = {
X		if (Plant.size < 1 or Plant.size > 2) {
X			"There is nothing here to climb.  Use \"up\" 
X			or \"out\" to leave the pit.";
X
X			return nil;
X		}
X		else {
X			Plant.doClimb(Me);
X			return nil;
X		}
X	}
X;
XPlant: CCR_decoration
X	size = 0
X
X	sdesc = {
X		if (self.size = 0)
X			"plant";
X		else if (self.size = 1)
X			"beanstalk";
X		else if (self.size = 2)
X			"giant beanstalk";
X	}
X	ldesc = {
X		if (self.size = 0)
X			"There is a tiny little plant in the pit, 
X			murmuring \"Water, water, ...\"";
X		else if (self.size = 1)
X			"There is a 12-foot-tall beanstalk stretching 
X			up out of the pit, bellowing \"Water!! 
X			Water!!\"";
X		else if (self.size = 2)
X			"There is a gigantic beanstalk stretching all 
X			the way up to the hole.";
X	}
X	location = In_West_Pit
X	noun = 'plant' 'beanstalk' 'stalk'
X	adjective = 'bean' 'giant' 'tiny' 'little' 'murmuring'
X		'12-foot-tall' 'twelve' 'foot' 'tall' 'bellowing'
X
X	verDoClimb(actor) = {
X		if (self.size = 0)
X			"It's just a little plant!";
X	}
X	doClimb(actor) = {
X		if (self.size = 1) {
X			"You have climbed up the plant and out of the 
X			pit.\b";
X
X			Me.travelTo(At_West_End_Of_Twopit_Room);
X		}
X		else {
X			"You clamber up the plant and scurry through 
X			the hole at the top.\b";
X
X			Me.travelTo(In_Narrow_Corridor);
X		}
X	}
X
X	verDoWater(actor) = {}
X	doWater(actor) = {
X		if (bottle.isIn(Me))
X			bottle.doPourOn(actor, self);
X		else
X			"You have nothing to water the plant with.";
X	}
X	verDoOil(actor) = {}
X	doOil(actor) = { self.doWater(actor); }
X
X	// The plant's not going anywhere.
X	verifyRemove(actor) = {
X		"The plant has exceptionally deep roots and cannot be 
X		pulled free.";
X	}
X
X	water = {
X		self.size := self.size + 1;
X
X		if (self.size = 1)
X			"The plant spurts into furious growth for a 
X			few seconds.";
X		else if (self.size = 2)
X			"The plant grows explosively, almost filling 
X			the bottom of the pit.";
X		else {
X			"You've over-watered the plant!  It's 
X			shriveling up!  It's, it's...";
X
X			self.size := 0;
X		}
X
X		P(); I(); Plant.ldesc;
X	}
X;
XWestPit: CCR_decoration
X	sdesc = "western pit"
X	ldesc = "You're in it."
X	noun = 'pit' 'corner'
X	adjective = 'west' 'western'
X	location = In_West_Pit
X;
XHoleAbovePit_2: CCR_decoration
X	sdesc = "hole above pit"
X	ldesc = "The hole is in the wall above you."
X	noun = 'hole'
X	adjective = 'large'
X	location = At_West_End_Of_Twopit_Room
X
X	verDoEnter(actor) = {
X		"You're not anywhere near the pit -- it's far overhead.";
X	}
X;
X
XWest_Side_Of_Fissure: CCR_room
X	sdesc = "West Side of Fissure"
X	ldesc = {
X		I(); "You are on the west side of the fissure in the 
X		hall of mists.";
X
X		if (CrystalBridge.exists) {
X			P(); I();
X			"A crystal bridge now spans the fissure.";
X		}
X	}
X
X	west = At_West_End_Of_Hall_Of_Mists
X
X	forwards = { return self.jump; }
X	jump = {
X		if (CrystalBridge.exists) {
X			"I respectfully suggest you go across the 
X			bridge instead of jumping.";
X
X			return nil;
X		}
X		else
X			return didnt_make_it.death;
X	}
X
X	over = { return self.across; }
X	east = { return self.across; }
X	cross = { return self.across; }
X	across = {
X		CrystalBridge.doCross(Me);
X		return nil;
X	}
X
X	north = {
X		"You have crawled through a very low wide passage 
X		parallel to and north of the hall of mists.\b";
X
X		return At_West_End_Of_Hall_Of_Mists;
X	}
X
X	//
X	// NPC's can go across too, but only if the bridge exists.
X	//
X	NPCexit1 = {
X		if (CrystalBridge.exists)
X			return On_East_Bank_Of_Fissure;
X		else
X			return nil;
X	}
X;
X
XLow_N_S_Passage: CCR_room
X	sdesc = "Low N/S Passage"
X	ldesc = {
X		I(); "You are in a low N/S passage at a hole in the 
X		floor.  The hole goes down to an E/W passage.";
X	}
X	hall = In_Hall_Of_Mt_King
X	out = In_Hall_Of_Mt_King
X	south = In_Hall_Of_Mt_King
X	north = At_Y2
X	y2 = At_Y2
X	down = In_Dirty_Passage
X	hole = In_Dirty_Passage
X;
X
XIn_South_Side_Chamber: CCR_room
X	sdesc = "In South Side Chamber"
X	ldesc = {
X		I(); "You are in the south side chamber.";
X	}
X	hall = In_Hall_Of_Mt_King
X	out = In_Hall_Of_Mt_King
X	north = In_Hall_Of_Mt_King
X;
X
XIn_West_Side_Chamber: CCR_room
X	sdesc = "In West Side Chamber"
X	ldesc = {
X		I(); "You are in the west side chamber of the hall of 
X		the mountain king. A passage continues west and up 
X		here.";
X	}
X	hall = In_Hall_Of_Mt_King
X	out = In_Hall_Of_Mt_King
X	east = In_Hall_Of_Mt_King
X	west = Crossover
X	up = Crossover
X;
X
XAt_Y2: CCR_room
X	sdesc = "At \"Y2\""
X	ldesc = {
X		I(); "You are in a large room, with a passage to the 
X		south, a passage to the west, and a wall of broken 
X		rock to the east. There is a large \"Y2\" on ";
X
X		if (Me.isIn(Y2Rock))
X			"the rock you are sitting on.";
X		else
X			"a rock in the room's center.";
X
X		self.hollowvoice;
X	}
X	plugh = Inside_Building
X	south = Low_N_S_Passage
X	east = Jumble_Of_Rock
X	wall = Jumble_Of_Rock
X	broken = Jumble_Of_Rock
X	west = At_Window_On_Pit_1
X 	plover = {
X		if (egg_sized_emerald.isIn(Me))
X			egg_sized_emerald.moveInto(In_Plover_Room);
X			
X		return In_Plover_Room;
X	}
X
X	hollowvoice = {
X		if (rand(100) <= 25) {
X			P(); I(); "A hollow voice says, \"Plugh.\"";
X		}
X	}
X;
XY2Rock: CCR_decoration, chairitem, readable
X	sdesc = "\"Y2\" rock"
X	ldesc = { self.readdesc; }
X	readdesc = "There is a large \"Y2\" painted on the rock."
X	noun = 'rock'
X	adjective = 'y2'
X
X	location = At_Y2
X
X	plugh = { return self.location.plugh; }
X
X	onroom = true	// We set ON the rock, not IN it.
X
X	//
X	// We want the player to be able to pick things in the
X	// room up while sitting on the rock.
X	//
X	reachable = {
X		return [Y2Rock] + At_Y2.contents;
X	}
X;
X
XJumble_Of_Rock: CCR_room
X	sdesc = "Jumble of Rock"
X	ldesc = {
X		I(); "You are in a jumble of rock, with cracks 
X		everywhere.";
X	}
X	down = At_Y2
X	y2 = At_Y2
X	up = In_Hall_Of_Mists
X;
X
XAt_Window_On_Pit_1: CCR_room
X	sdesc = "At Window on Pit"
X	ldesc = {
X		I(); "You're at a low window overlooking a huge pit, 
X		which extends up out of sight.  A floor is 
X		indistinctly visible over 50 feet below.  Traces of 
X		white mist cover the floor of the pit, becoming 
X		thicker to the right. Marks in the dust around the 
X		window would seem to indicate that someone has been 
X		here recently.  Directly across the pit from you and 
X		25 feet away there is a similar window looking into a 
X		lighted room.  A shadowy figure can be seen there 
X		peering back at you.";
X	}
X	east = At_Y2
X	y2 = At_Y2
X	jump = { return broken_neck.death; }
X;
XWindow: floatingdecoration
X	sdesc = "window"
X	ldesc = "It looks like a regular window."
X	noun = 'window'
X	adjective = 'low'
X	loclist = [ At_Window_On_Pit_1  At_Window_On_Pit_2 ]
X
X	verDoOpen(actor) = {}
X	doOpen(actor) = { "OK, the window is now open."; }
X	verDoClose(actor) = {}
X	doClose(actor) = { "OK, the window is now closed."; }
X;
XWindowPit: floatingdecoration
X	sdesc = "huge pit"
X	ldesc = {
X		"It's so deep you can barely make out the floor below,
X		and the top isn't visible at all.";
X	}
X	noun = 'pit'
X	adjective = 'deep' 'large'
X	loclist = [ At_Window_On_Pit_1  At_Window_On_Pit_2 ]
X;
XMarksInTheDust: floatingdecoration
X	sdesc = "marks in the dust"
X	adesc = { self.sdesc; }
X	ldesc = "Evidently you're not alone here."
X	loclist = [ At_Window_On_Pit_1  At_Window_On_Pit_2 ]
X;
XShadowyFigure: floatingdecoration
X	sdesc = "shadowy figure"
X	ldesc = {
X		"The shadowy figure seems to be trying to attract 
X		your attention.";
X	}
X	noun = 'figure' 'shadow' 'person' 'individual'
X	adjective = 'shadowy' 'mysterious'
X	loclist = [ At_Window_On_Pit_1  At_Window_On_Pit_2 ]
X;
XIn_Dirty_Passage: CCR_room
X	sdesc = "In Dirty Passage"
X	ldesc = {
X		I(); "You are in a dirty broken passage.  To the east 
X		is a crawl.  To the west is a large passage.  Above 
X		you is a hole to another passage.";
X	}
X	east = On_Brink_Of_Pit
X	crawl = On_Brink_Of_Pit
X	up = Low_N_S_Passage
X	hole = Low_N_S_Passage
X	west = In_Dusty_Rock_Room
X	bedquilt = In_Bedquilt
X	slab = In_Slab_Room	// DMB: this is only in some versions
X;
X
XOn_Brink_Of_Pit: CCR_room
X	sdesc = "On Brink of Pit"
X	ldesc = {
X		I(); "You are on the brink of a small clean climbable 
X		pit.  A crawl leads west.";
X	}
X	west = In_Dirty_Passage
X	crawl = In_Dirty_Passage
X	down = In_Pit
X	pit = In_Pit
X	climb = In_Pit
X	in = In_Pit	// DMB: added
X;
XCleanPit: CCR_decoration
X	sdesc = "small pit"
X	ldesc = "It looks like you might be able to climb down into it."
X	noun = 'pit'
X	adjective = 'small' 'clean' 'climable'
X	location = On_Brink_Of_Pit
X
X	verDoClimb(actor) = {}
X	doClimb(actor) = { Me.travelTo(self.location.climb); }
X	verDoEnter(actor) = {}
X	doEnter(actor) = { self.doClimb(actor); }
X;
XIn_Pit: CCR_room, NoNPC
X	sdesc = "In Pit"
X	ldesc = {
X		I(); "You are in the bottom of a small pit with a 
X		little stream, which enters and exits through tiny 
X		slits.";
X	}
X	climb = On_Brink_Of_Pit
X	up = On_Brink_Of_Pit
X	out = On_Brink_Of_Pit
X
X	slit = { return self.down; }
X	stream = { return self.down; }
X	upstream = { return self.down; }
X	downstream = { return self.down; }
X	down = {
X		// In the original, the same message given
X		// in At_Slit_In_Streambed was used here.
X		// Since it's not quite right (and was probably only
X		// reused to save space), I've changed it slightly.
X
X		"You don't fit through the tiny slits!";
X		return nil;
X	}
X;
XPitSlits: decoration
X	sdesc = "tiny slits"
X	adesc = { self.sdesc; }
X	ldesc = {
X		"The slits form a complex pattern in the rock.";
X	}
X	location = In_Pit
X	noun = 'slit' 'slits'
X	adjective = 'tiny'
X;
X
XIn_Dusty_Rock_Room: CCR_room
X	sdesc = "In Dusty Rock Room"
X	ldesc = {
X		I(); "You are in a large room full of dusty rocks.  
X		There is a big hole in the floor.  There are cracks 
X		everywhere, and a passage leading east.";
X	}
X	east = In_Dirty_Passage
X	passage = In_Dirty_Passage
X	down = At_Complex_Junction
X	hole = At_Complex_Junction
X	floor = At_Complex_Junction
X	bedquilt = In_Bedquilt
X;
XDustyRocks: CCR_decoration
X	sdesc = "dusty rocks"
X	ldesc = "They're just rocks.  (Dusty ones, that is.)"
X	location = In_Dusty_Rock_Room
X	noun = 'rocks' 'boulders' 'stones' 'rock' 'boulder' 'stone'
X	adjective = 'dusty' 'dirty'
X;
X
XAt_West_End_Of_Hall_Of_Mists: CCR_room
X	sdesc = "At West End of Hall of Mists"
X	ldesc = {
X		I(); "You are at the west end of the hall of mists.  
X		A low wide crawl continues west and another goes 
X		north.  To the south is a little passage 6 feet off 
X		the floor.";
X	}
X	south = Alike_Maze_1
X	up = Alike_Maze_1
X	passage = Alike_Maze_1
X	climb = Alike_Maze_1
X	east = West_Side_Of_Fissure
X	west = At_East_End_Of_Long_Hall
X	crawl = At_East_End_Of_Long_Hall
X
X	north = {
X		"You have crawled through a very low wide passage 
X		parallel to and north of the hall of mists.\b";
X
X		return West_Side_Of_Fissure;
X	}	
X;
X
XAlike_Maze_1: CCR_alike_maze_room
X	up = At_West_End_Of_Hall_Of_Mists
X	north = Alike_Maze_1
X	east = Alike_Maze_2
X	south = Alike_Maze_4
X	west = Alike_Maze_11
X;
X
XAlike_Maze_2: CCR_alike_maze_room
X	west = Alike_Maze_1
X	south = Alike_Maze_3
X	east = Alike_Maze_4
X;
X
XAlike_Maze_3: CCR_alike_maze_room
X	east = Alike_Maze_2
X	down = Dead_End_3
X	south = Alike_Maze_6
X	north = Dead_End_13
X;
X
XAlike_Maze_4: CCR_alike_maze_room
X	west = Alike_Maze_1
X	north = Alike_Maze_2
X	east = Dead_End_1
X	south = Dead_End_2
X	up = Alike_Maze_14
X	down = Alike_Maze_14
X;
X
XDead_End_1: CCR_dead_end_room
X	west = Alike_Maze_4
X	out = Alike_Maze_4
X;
X
XDead_End_2: CCR_dead_end_room
X	east = Alike_Maze_4
X	out = Alike_Maze_4
X;
X
XDead_End_3: CCR_dead_end_room
X	up = Alike_Maze_3
X	out = Alike_Maze_3
X;
X
XAlike_Maze_5: CCR_alike_maze_room
X	east = Alike_Maze_6
X	west = Alike_Maze_7
X;
X
XAlike_Maze_6: CCR_alike_maze_room
X	east = Alike_Maze_3
X	west = Alike_Maze_5
X	down = Alike_Maze_7
X	south = Alike_Maze_8
X;
X
XAlike_Maze_7: CCR_alike_maze_room
X	west = Alike_Maze_5
X	up = Alike_Maze_6
X	east = Alike_Maze_8
X	south = Alike_Maze_9
X;
X
XAlike_Maze_8: CCR_alike_maze_room
X	west = Alike_Maze_6
X	east = Alike_Maze_7
X	south = Alike_Maze_8
X	up = Alike_Maze_9
X	north = Alike_Maze_10
X	down = Dead_End_12
X;
X
XAlike_Maze_9: CCR_alike_maze_room
X	west = Alike_Maze_7
X	north = Alike_Maze_8
X	south = Dead_End_4
X;
X
XDead_End_4: CCR_dead_end_room
X	west = Alike_Maze_9
X	out = Alike_Maze_9
X;
X
XAlike_Maze_10: CCR_alike_maze_room
X	west = Alike_Maze_8
X	north = Alike_Maze_10
X	down = Dead_End_5
X	east = At_Brink_Of_Pit
X;
X
XDead_End_5: CCR_dead_end_room
X	up = Alike_Maze_10
X	out = Alike_Maze_10
X;
X
XAt_Brink_Of_Pit: CCR_room
X	sdesc = "At Brink of Pit"
X	ldesc = {
X		I(); "You are on the brink of a thirty foot pit with 
X		a massive orange column down one wall.  You could 
X		climb down here but you could not get back up.  The 
X		maze continues at this level.";
X	}
X	down = In_Bird_Chamber
X	climb = In_Bird_Chamber
X	west = Alike_Maze_10
X	south = Dead_End_6
X	north = Alike_Maze_12
X	east = Alike_Maze_13
X;
XOrangeColumn: CCR_decoration
X	sdesc = "massive orange column"
X	ldesc = "It looks like you could climb down it."
X	noun = 'column'
X	adjective = 'massive' 'orange' 'big' 'huge'
X	location = At_Brink_Of_Pit
X	
X	verDoClimb(actor) = {}
X	doClimb(actor) = { Me.travelTo(self.location.down); }
X;
XThirtyFootPit: CCR_decoration
X	sdesc = "pit"
X	ldesc = "You'll have to climb down to find out anything more..."
X	noun = 'pit'
X	adjective = 'thirty' 'foot' 'thirty-foot' '30-foot'
X	location = At_Brink_Of_Pit
X
X	verDoClimb(actor) = {}
X	doClimb(actor) = { Me.travelTo(self.location.down); }
X	verDoEnter(actor) = {}
X	doEnter(actor) = { self.doClimb(actor); }
X;
X
XDead_End_6: CCR_dead_end_room
X	east = At_Brink_Of_Pit
X	out = At_Brink_Of_Pit
X;
X
XAt_East_End_Of_Long_Hall: CCR_room
X	sdesc = "At East End of Long Hall"
X	ldesc = {
X		I(); "You are at the east end of a very long hall 
X		apparently without side chambers.  To the east a low 
X		wide crawl slants up.  To the north a round two foot 
X		hole slants down.";
X	}
X	east = At_West_End_Of_Hall_Of_Mists
X	up = At_West_End_Of_Hall_Of_Mists
X	crawl = At_West_End_Of_Hall_Of_Mists
X	west = At_West_End_Of_Long_Hall
X	north = Crossover
X	down = Crossover
X	hole = Crossover
X;
X
XAt_West_End_Of_Long_Hall: CCR_room
X	sdesc = "At West End of Long Hall"
X	ldesc = {
X		I(); "You are at the west end of a very long 
X		featureless hall.  The hall joins up with a narrow 
X		north/south passage.";
X	}
X	east = At_East_End_Of_Long_Hall
X	north = Crossover
X	south = Different_Maze_1
X;
X
XCrossover: CCR_room
X	sdesc = "N/S and E/W Crossover"
X	ldesc = {
X		I(); "You are at a crossover of a high N/S passage 
X		and a low E/W one.";
X	}
X	west = At_East_End_Of_Long_Hall
X	north = Dead_End_7
X	east = In_West_Side_Chamber
X	south = At_West_End_Of_Long_Hall
X;
XTheCrossover: CCR_decoration
X	sdesc = "crossover"
X	ldesc = "You know as much as I do at this point."
X	noun = 'crossover' 'over'
X	adjective = 'cross'
X	location = Crossover
X;
X
XDead_End_7: CCR_dead_end_room
X	south = Crossover
X	out = Crossover
X;
X
XAt_Complex_Junction: CCR_room
X	sdesc = "At Complex Junction"
X	ldesc = {
X		I(); "You are at a complex junction.  A low hands and 
X		knees passage from the north joins a higher crawl 
X		from the east to make a walking passage going west.  
X		There is also a large room above.  The air is damp 
X		here.";
X	}
X	up = In_Dusty_Rock_Room
X	climb = In_Dusty_Rock_Room
X	toroom = In_Dusty_Rock_Room
X	west = In_Bedquilt
X	bedquilt = In_Bedquilt
X	north = In_Shell_Room
X	shell = In_Shell_Room
X	east = In_Anteroom
X;
X
XIn_Bedquilt: CCR_room
X	sdesc = "In Bedquilt"
X	ldesc = {
X		I(); "You are in bedquilt, a long east/west passage 
X		with holes everywhere. To explore at random select 
X		north, south, up, or down.";
X	}
X	east = At_Complex_Junction
X	west = In_Swiss_Cheese_Room
X	south = {
X		if (rand(100) <= 80)
X			return crawled_around.message;
X		else
X			return self.slab;
X	}
X	slab = In_Slab_Room
X
X	up = {
X		if (rand(100) <= 80)
X			return crawled_around.message;
X		else if (rand(100) <= 50)
X			return In_Secret_N_S_Canyon_1;
X		else
X			return In_Dusty_Rock_Room;
X	}
X
X	north = {
X		if (rand(100) <= 60)
X			return crawled_around.message;
X		else if (rand(100) <= 75)
X			return In_Large_Low_Room;
X		else
X			return At_Junction_Of_Three_Secret_Canyons;
X	}
X
X	down = {
X		if (rand(100) <= 80)
X			return crawled_around.message;
X		else
X			return In_Anteroom;
X	}
X
X	//
X	// Let the NPC's go everywhere out of here too.
X	//
X	NPCexit1 = In_Secret_N_S_Canyon_1
X	NPCexit2 = In_Dusty_Rock_Room
X	NPCexit3 = In_Large_Low_Room
X	NPCexit4 = At_Junction_Of_Three_Secret_Canyons
X	NPCexit5 = In_Anteroom
X;
X
XIn_Swiss_Cheese_Room: CCR_room
X	sdesc = "In Swiss Cheese Room"
X	ldesc = {
X		I(); "You are in a room whose walls resemble swiss 
X		cheese.  Obvious passages go west, east, ne, and nw.  
X		Part of the room is occupied by a large bedrock 
X		block.";
X	}
X	ne = In_Bedquilt
X	west = At_East_End_Of_Twopit_Room
X	south = {
X		if (rand(100) <= 80)
X			return crawled_around.message;
X		else
X			return self.canyon;
X	}
X	canyon = In_Tall_E_W_Canyon
X
X	east = In_Soft_Room
X	nw = {
X		if (rand(100) <= 50)
X			return crawled_around.message;
X		else
X			return self.oriental;
X	}
X	oriental = In_Oriental_Room
X;
XBedrockBlock: CCR_decoration
X	sdesc = "bedrock block"
X	ldesc = "It's just a huge block."
X	noun = 'block'
X	adjective = 'bedrock' 'large'
X	location = In_Swiss_Cheese_Room
X
X	verDoLookunder(actor) = { "Surely you're joking."; }
X	verDoMove(actor) = { self.verDoLookunder(actor); }
X	verifyRemove(actor) = { self.verDoLookunder(actor); }
X;
X
XAt_East_End_Of_Twopit_Room: CCR_room
X	sdesc = "At East End of Twopit Room"
X	ldesc = {
X		I(); "You are at the east end of the twopit room.  
X		The floor here is littered with thin rock slabs, 
X		which make it easy to descend the pits. There is a 
X		path here bypassing the pits to connect passages from 
X		east and west.  There are holes all over, but the 
X		only big one is on the wall directly over the west 
X		pit where you can't get to it.";
X
X		if (PlantStickingUp.isIn(self)) {
X			P(); I(); PlantStickingUp.ldesc;
X		}
X	}
X	east = In_Swiss_Cheese_Room
X	west = At_West_End_Of_Twopit_Room
X	across = At_West_End_Of_Twopit_Room
X	down = In_East_Pit
X	pit = In_East_Pit
X;
XSlabs: CCR_decoration
X	sdesc = "thin rock slabs"
X	adesc = { self.sdesc; }
X	ldesc = "They almost form natural stairs down into the pit."
X	noun = 'slabs' 'slab' 'rocks' 'stairs'
X	adjective = 'thin' 'rock'
X	location = At_East_End_Of_Twopit_Room
X
X	verDoLookunder(actor) = { "Surely you're joking."; }
X	verDoMove(actor) = { self.verDoLookunder(actor); }
X	verifyRemove(actor) = { self.verDoLookunder(actor); }
X;
X
XIn_Slab_Room: CCR_room
X	sdesc = "In Slab Room"
X	ldesc = {
X		I(); "You are in a large low circular chamber whose 
X		floor is an immense slab fallen from the ceiling 
X		(slab room).  East and west there once were large 
X		passages, but they are now filled with boulders.  Low 
X		small passages go north and south, and the south one 
X		quickly bends west around the boulders.";
X	}
X	south = At_West_End_Of_Twopit_Room
X	up = In_Secret_N_S_Canyon_0
X	climb = In_Secret_N_S_Canyon_0
X	north = In_Bedquilt
X;
XSlab: CCR_decoration
X	sdesc = "slab"
X	ldesc = "It is now the floor here."
X	noun = 'slab'
X	adjective = 'immense'
X	location = In_Slab_Room
X;
XSlabBoulders: CCR_decoration
X	sdesc = "boulders"
X	ldesc = "They're just ordinary boulders."
X	noun = 'boulder' 'boulders' 'rocks' 'stones'
X	location = In_Slab_Room
X;
X
XIn_Secret_N_S_Canyon_0: CCR_room
X	sdesc = "In Secret N/S Canyon"
X	ldesc = {
X		I(); "You are in a secret N/S canyon above a large 
X		room.";
X	}
X	down = In_Slab_Room
X	slab = In_Slab_Room
X
X	south = {
X		In_Secret_Canyon.enteredfrom := self;
X		return In_Secret_Canyon;
X	}
X
X	north = In_Mirror_Canyon
X	reservoir = At_Reservoir
X
X	//
X	// Let NPC's go into the secret canyon too, without regard to
X	// whether the dragon's there.
X	//
X	NPCexit1 = In_Secret_Canyon
X;
X
XIn_Secret_N_S_Canyon_1: CCR_room
X	sdesc = "In Secret N/S Canyon"
X	ldesc = {
X		I(); "You are in a secret N/S canyon above a sizable 
X		passage.";
X	}
X	north = At_Junction_Of_Three_Secret_Canyons
X	down = In_Bedquilt
X	passage = In_Bedquilt
X	south = Atop_Stalactite
X;
X
XAt_Junction_Of_Three_Secret_Canyons: CCR_room
X	sdesc = "At Junction of Three Secret Canyons"
X	ldesc = {
X		I(); "You are in a secret canyon at a junction of 
X		three canyons, bearing north, south, and se.  The 
X		north one is as tall as the other two combined.";
X	}
X	se = In_Bedquilt
X	south = In_Secret_N_S_Canyon_1
X	north = At_Window_On_Pit_2
X;
X
XIn_Large_Low_Room: CCR_room
X	sdesc = "In Large Low Room"
X	ldesc = {
X		I(); "You are in a large low room.  Crawls lead 
X		north, se, and sw.";
X	}
X	bedquilt = In_Bedquilt
X	sw = In_Sloping_Corridor
X	north = Dead_End_Crawl
X	se = In_Oriental_Room
X	oriental = In_Oriental_Room
X;
X
XDead_End_Crawl: CCR_dead_end_room
X	sdesc = "Dead End Crawl"
X	ldesc = {
X		I(); "This is a dead end crawl.";
X	}
X	south = In_Large_Low_Room
X	crawl = In_Large_Low_Room
X	out = In_Large_Low_Room
X;
X
XIn_Secret_E_W_Canyon: CCR_room
X	sdesc = "In Secret E/W Canyon Above Tight Canyon"
X	ldesc = {
X		I(); "You are in a secret canyon which here runs E/W. 
X		It crosses over a very tight canyon 15 feet below.  
X		If you go down you may not be able to get back up.";
X	}
X	east = In_Hall_Of_Mt_King
X	west = {
X		In_Secret_Canyon.enteredfrom := self;
X		return In_Secret_Canyon;
X	}
X	down = In_N_S_Canyon
X
X	//
X	// Let NPC's go into the secret canyon too, without regard to
X	// whether the dragon's there.
X	//
X	NPCexit1 = In_Secret_Canyon
X;
X
XIn_N_S_Canyon: CCR_room
X	sdesc = "In N/S Canyon"
X	ldesc = {
X		I(); "You are at a wide place in a very tight N/S 
X		canyon.";
X	}
X	south = Canyon_Dead_End
X	north = In_Tall_E_W_Canyon
X;
X
XCanyon_Dead_End: CCR_dead_end_room
X	sdesc = "Canyon Dead End"
X	ldesc = {
X		I(); "The canyon here becomes too tight to go further 
X		south.";
X	}
X	north = In_N_S_Canyon
X;
X
XIn_Tall_E_W_Canyon: CCR_room
X	sdesc = "In Tall E/W Canyon"
X	ldesc = {
X		I(); "You are in a tall E/W canyon.  A low tight 
X		crawl goes 3 feet north and seems to open up.";
X	}
X	east = In_N_S_Canyon
X	west = Dead_End_8
X	north = In_Swiss_Cheese_Room
X	crawl = In_Swiss_Cheese_Room
X;
X
XDead_End_8: CCR_dead_end_room
X	ldesc = {
X		I(); "The canyon runs into a mass of boulders -- dead 
X		end.";
X	}
X	south = In_Tall_E_W_Canyon
X	out = In_Tall_E_W_Canyon	// DMB: added
X;
XMassOfBoulders: CCR_decoration
X	sdesc = "mass of boulders"
X	ldesc = "They just like ordinary boulders."
X	noun = 'boulders' 'mass'
X	location = Dead_End_8
X;
X
XAlike_Maze_11: CCR_alike_maze_room
X	north = Alike_Maze_1
X	west = Alike_Maze_11
X	south = Alike_Maze_11
X	east = Dead_End_9
X;
X
XDead_End_9: CCR_dead_end_room
X	west = Alike_Maze_11
X	out = Alike_Maze_11
X;
X
XDead_End_10: CCR_dead_end_room
X	south = Alike_Maze_3
X	out = Alike_Maze_3
X;
X
XAlike_Maze_12: CCR_alike_maze_room
X	south = At_Brink_Of_Pit
X	east = Alike_Maze_13
X	west = Dead_End_11
X;
X
XAlike_Maze_13: CCR_alike_maze_room
X	north = At_Brink_Of_Pit
X	west = Alike_Maze_12
X	nw = Dead_End_13
X;
X
XDead_End_11: CCR_dead_end_room
X	east = Alike_Maze_12
X	out = Alike_Maze_12
X;
X
XDead_End_12: CCR_dead_end_room
X	up = Alike_Maze_8
X	out = Alike_Maze_8
X;
X
XAlike_Maze_14: CCR_alike_maze_room
X	up = Alike_Maze_4
X	down = Alike_Maze_4
X;
X
XIn_Narrow_Corridor: CCR_room
X	sdesc = "In Narrow Corridor"
X	ldesc = {
X		I(); "You are in a long, narrow corridor stretching 
X		out of sight to the west.  At the eastern end is a 
X		hole through which you can see a profusion of 
X		leaves.";
X	}
X	down = In_West_Pit
X	climb = In_West_Pit
X	east = In_West_Pit
X	jump = { return broken_neck.death; }
X	west = In_Giant_Room
X	giant = In_Giant_Room
X;
XLeaves: CCR_decoration
X	sdesc = "leaves"
X	ldesc = {
X		"The leaves appear to be attached to the beanstalk 
X		you climbed to get here.";
X	}
X	location = In_Narrow_Corridor
X	noun = 'leaf' 'leaves' 'plant' 'tree' 'stalk' 'beanstalk' 'profusion'
X;
END_OF_FILE
if test 57085 -ne `wc -c <'src/ccr-room.t1'`; then
    echo shar: \"'src/ccr-room.t1'\" unpacked with wrong size!
fi
# end of 'src/ccr-room.t1'
fi
echo shar: End of archive 3 \(of 11\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    echo "Now run buildit.sh to make gam file"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
