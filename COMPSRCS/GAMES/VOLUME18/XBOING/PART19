Path: uunet!news.tek.com!news.cna.tek.com!not-for-mail
From: billr@saab.cna.tek.com (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i078:  xboing - blockout variant with color and sound for X, Part19/30
Date: 30 Aug 1993 10:28:48 -0700
Organization: Tektronix, Inc., Redmond, OR
Lines: 1983
Approved: billr@saab.CNA.TEK.COM
Message-ID: <25tdcg$i1b@saab.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1878

Submitted-by: jck@kimba.catt.citri.edu.au (Justin Kibell)
Posting-number: Volume 18, Issue 78
Archive-name: xboing/part19
Environment: X11, Xlib, XPM



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 19 (of 30)."
# Contents:  bitmaps/highscores.xpm.uu bonus.c gun.c include/audio.h
# Wrapped by billr@saab on Mon Aug 30 09:14:28 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'bitmaps/highscores.xpm.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/highscores.xpm.uu'\"
else
echo shar: Extracting \"'bitmaps/highscores.xpm.uu'\" \(19805 characters\)
sed "s/^X//" >'bitmaps/highscores.xpm.uu' <<'END_OF_FILE'
Xbegin 644 highscores.xpm
XM+RH@6%!-("HO"G-T871I8R!C:&%R("H@:&EG:'-C;W)E<U]X<&U;72`]('L*
XM+RH@=VED=&@@:&5I9VAT(&YC;VQO<G,@8VAA<G-?<&5R7W!I>&5L("HO"B(S
XM-S<@,S<@."`Q(BP*+RH@8V]L;W)S("HO"B(@"7,@3F]N90EC($YO;F4B+`HB
XM+@EC("-%.$4X13@B+`HB6`EC("-"1D)&1#(B+`HB;PEC("-!-$$T.3`B+`HB
XM3PEC("-!-#=".3`B+`HB*PEC(",U135%-44B+`HB0`EC(",W0CDP030B+`HB
XM(PEC(",T1#1$-$0B+`HO*B!P:7AE;',@*B\*(B`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`N+E@N+BX@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@+BY8+BXN6"XN6"`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@+BY8+BXN("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("XN6"XN+E@@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`N+E@N+BY8+BY8("`@("`@("`@("`@
XM(BP*(BY8+BXN6"XN6"Y86"`@("`@("`@("XN6"XN+E@N+E@N6"`@("`N+E@N
XM+BY8+BY8+E@@("`@("`@("`@("`@("`N6"Y8;T\K;V\N+E@N("`@("`@("`@
XM("`@("`@+E@N+BY8+BY8+EA8("`@("`@("`@+BY8+BXN6"XN6"Y8("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("!8+E@N0$]/;T\K;V]8
XM+BXN("`@("`@("`@("`@("`@("`@("`@("`@+E@N6&]/*V]O+BY8+B`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("Y8+EAO3RMO;RXN6"X@("`@("`@("`@
XM("`@("`@+E@N+BY8+BY8+BXN+E@N+BY8+BY8+E@@("`@("`@("`@("`@("Y8
XM+BXN6"XN6"Y8+BXN+BXN+E@N+BY8+BY8+BXN6"`@("`@("`@("`@(%@N6"Y`
XM3T]O3RMO;U@N+BX@("`@("`@("`@(BP*(EAO3V]/;RMO0$]O3R`@("`@("`@
XM(%AO6$]O6$]/*V]/3R`@("!86%AO6"LK3RM/3T\@("`@("`@("`@("!8+BYO
XM;UA/*UA/*T!O6&]/+BY8("`@("`@("`@("`@6&]/;T]O*V]`3V]/("`@("`@
XM("`@6&]83V]83T\K;T]/("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@6"Y/;V]O;UA/*UA/*T!O6&]/6"X@("`@("`@("`@("`@("`@("`@
XM6"XN;V]83RM83RM`;UAO3RXN6"`@("`@("`@("`@("`@("`@("`@(%@N+F]O
XM6$\K6$\K0&]8;T\N+E@@("`@("`@("`@("`@6&]O6%@K;U@C0&]`;U@K;T!/
XM3T!/3T\N+B`@("`@("`@("`@(%AO6"LK3RM/3V]/6%@K;T]O0%A/;UAO;UAO
XM3T]O3R`@("`@("`@("!8+D]O;V]O6$\K6$\K0&]8;T]8+B`@("`@("`@(BP*
XM(EA8;T`K;T\K3V]83R`@("`@("`@(%A`;UAO;UA8;T]O3R`@("!8;V\K3V]O
XM3V]83T\@("`@("`@("`@("Y8;V]/6"MO6$]O;V]83T!80$\K6"`@("`@("`@
XM("`@6%AO0"MO3RM/;UA/("`@("`@("`@6$!O6&]O6%AO3V]/("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@(%@N3T]/;V]/6"MO6$]O;V]83T!8
XM0$]8;R`@("`@("`@("`@("`@("`N6&]O3U@K;UA/;V]O6$]`6$!/*U@@("`@
XM("`@("`@("`@("`@("`@+EAO;T]8*V]83V]O;UA/0%A`3RM86"`@("`@("`@
XM("`@6%AO;T]86&]O3V]O;T\K3T!83V]O;UAO6"Y8("`@("`@("`@(%@K3V]O
XM3V]83V]83V]`(T]`6$]/3UA8;RM8;UA83R`@("`@("`@6"Y/3T]O;T]8*V]8
XM3V]O;UA/0%A`3UAO("`@("`@(BP*(EA83T]83V]8;V]`3R`@("`@("`@(&]O
XM(T]/;UA/*V]`3R`@("!83V]O6"MO3T]8;T\@("`@("`@("!8+E@C0&]`;U@K
XM;T!/3T!/3T]O3T]/3RX@("`@("`@("`@6%A/3UA/;UAO;T!/("`@("`@("`@
XM;V\C3T]O6$\K;T!/("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM6%@K;U@C0&]`;U@K;T!/3T!/3T]O3T]/3U@@("`@("`@("`@("`@6"Y8(T!O
XM0&]8*V]`3T]`3T]/;T]/3T\N("`@("`@("`@("`@("`@(%@N6"-`;T!O6"MO
XM0$]/0$]/3V]/3T]/6%@@("`@("`@("`@6&]/3V]/6&]86&]8;T]`;UA/6&]8
XM;V]`;UA/6%@@("`@("`@(%AO6"MO3T]8;UA`6%A/6$]O(UA83T]O0$]/3T]8
XM*R`@("`@("!86"MO6"-`;T!O6"MO0$]/0$]/3V]/3T]/6"`@("`@(BP*(EAO
XM6&]O3V]/;RMO3R`@("`@("`@(%A/3T]`6$]/;UAO3R`@("!8;T]/;T]`;T!8
XM0$\@("`@("`@(%A86&]O3V]O;T\K3T!83V]O;UAO6$]8;T!/("`@("`@("`@
XM6&]8;V]/;T]O*V]/("`@("`@("`@6$]/3T!83T]O6&]/("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("!O;T]86&]O3V]O;T\K3T!83V]O;UAO6$]8
XM;T!O("`@("`@("`@("!86%AO;T]O;V]/*T]`6$]O;V]8;UA/6&]`3R`@("`@
XM("`@("`@("`@6%A8;V]/;V]O3RM/0%A/;V]O6&]83UAO0&]8("`@("`@("`@
XM6&]/;U@K3T]83T]/6$]/6%A/*UAO6$]/3V]O;V]8("`@("`@(%A/;T]`;T!8
XM0$]83V]O3T]86%AO6$]86%A8;T!83R`@("`@(&]O3UA8;V]/;V]O3RM/0%A/
XM;V]O6&]83UAO0&\@("`@(BP*(EA`;T\K6&]`;T\K3R`@("`@("`@(%AO3V]`
XM;RMO6&]/3R`@("!8;UA/3UA86%AO6$\@("`@("`@6&]/6&]86&]8;T]`;UA/
XM6&]8;V]`;UA/3T!80"`@("`@("`@6$!O3RM8;T!O3RM/("`@("`@("`@6&]/
XM;T!O*V]8;T]/("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@($]/3V]/
XM6&]86&]8;T]`;UA/6&]8;V]`;UA/3T!80"`@("`@("`@(%AO3UAO6%AO6&]/
XM0&]83UAO6&]O0&]83T]`6$`@("`@("`@("`@("!8;T]8;UA8;UAO3T!O6$]8
XM;UAO;T!O6$]/0%A`6"`@("`@("`@6&]86"-8*V\K6$]/*UAO0%@K;T\K3T]O
XM6$]/;RMO6"`@("`@(%A/3UA86%AO6%AO6&]83UA86$]/3UA/6%AO;T]O3R`@
XM("`@3T]/;T]8;UA8;UAO3T!O6$]8;UAO;T!O6$]/0%A`("`@(BP*(EA/3UA/
XM6$]86%A8*R`@("`@("`@(&]/6$!O3V]83T]/*R`@("!83V]86&]86%A`;RL@
XM("`@("!8;U@K3T]83T]/6$]/6%A/*UAO6$]/3V]O;T]`3V\@("`@("`@6$]/
XM6$]83UA86%@K("`@("`@("`@;T]80&]/;UA/3T\K("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@(&]/;U@K3T]83T]/6$]/6%A/*UAO6$]/3V]O;T]`
XM3T\@("`@("`@6&]8*T]/6$]/3UA/3UA83T!8;UA/3T]O;V]/0$]O("`@("`@
XM("`@(%AO6"M/3UA/3T]83T]86&]`6&]83T]/;V]O3T!/;V\@("`@("`@6$\K
XM6"-/6&]8*UA/6&]86$]83RM8;UA83V]O3UA8;R`@("`@(%A86&]86%A`;T]8
XM6$!86%A8;T]O3V]`6&]8*T]8*R`@("`@;T]O6"M/3UA/3T]83T]86$\K6&]8
XM3T]/;V]O3T!/3R`@(BP*(F]/*UA83T]O6%A83R`@("`@("`@(%A/3V\K6&]8
XM6&]/3R`@("!O3T]O*T]8;UAO6$\@("`@(&]86"-8*V\K6$]/*UAO6",C(T\K
XM3T]O6$]/;RM`3T]`("`@("`@;T\K6%A/3V]86%A/("`@("`@("`@6$]/;RM8
XM;UA8;T]/("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@3V]86"-8*V\K
XM6$]/*UAO6%@K;T\K3T]O6$]/;RM`3T\@("`@("!O6%@C6"MO*UA/3RM8;U@C
XM(R-/0$]/;UA/3V\K0$]/0"`@("`@("`@;UA8(U@K;RM83T\K6&]`(R,C0$!/
XM3V]83T]O*T!/3T!O("`@("`@;V]O3T!83V]86$]O3UA8*T!/3V]86$]O0&]8
XM;UA`6$\@("`@(&]O*T]8;UAO6%AO3UAO6%A8*UA/;V\K3T]`3T]/3R`@("!/
XM;UA8(U@K;RM83T\K6&]86"MO3RM/3V]83T]O*T!/3R`@(BP*(EA/6$]8;V]/
XM6&]/3R`@("`@("`@(&]O6&]/;RM8*V]/3R`@("!83UA/6%A83UA8;T\@("`@
XM(%@K6"-/6&]8*UA/6&\C*R`@("LC;UA83V]O3UA86"M80"`@("`@6$]83UAO
XM;T]8;T]/("`@("`@("`@;V]8;T]O*U@K;T]/("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@3T\K6"-/6&]8*UA/6$\K(RLC(R,K*UA83V]O3UA86$`K
XM("`@("!8*U@C3UAO6"M83UAO(RL@("`K(V]86$]O;T]86%@K6$`@("`@("`@
XM6"M8(T]8;U@K6$]8;R,K("`@*R-O6%A/;V]/6%A8*UAO("`@("`@6&]/6$]/
XM6&]O3U@K(R,K(R,K(T]O0"MO6&]/;T]O6&\@("`@(%A/6%A83UA8;UA8*R,C
XM(R,C(R,C*R,C(R,C(RLC(R`@("!/3RM8(T]8;U@K6$]83RLC*R,C(RLK6%A/
XM;V]/6%A80"L@(BP*(EAO3V]/6$]O3T`K3R`@("`@("`@(&]86%AO6$!/6$]O
XM3R`@("!86&]O6&]83V]8*T\@("`@;UAO3T!83V]86$]O3RL@("`@("`@*T]O
XM0&]8;UA`6"M80"`@("`@6&]/;T]83V]/0"M/("`@("`@("`@;UA86&]80$]8
XM3V]/("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@;V]O3T!83V]86"M/
XM*R`@("`@("`@($]O0&]8;UA`6"M/("`@(&]8;T]`6$]O6%A/;T\K("`@("`@
XM("M/;T!O6&]80%@K6$`@("`@("!O6&]/0%A/;UA83V]/*R`@("`@("!/3V]`
XM;UAO6$!8*UA`;R`@("`@6$]8;UA/6&]/3V\K("`@("`@("!O3T]/;U@K6$]/
XM0&\@("`@(%AO6&]83V]8*UAO*R`@("`@("`@("`@("`@("`@("`@("!O;V]/
XM0%A/;UA8*T\K("`@("`@("`@3V]`;UAO6$!8*T\@(BP*(F]O*UA8*UAO6%@K
XM3R`@("`@("`@(%A83T]/6$]/;U@K3R`@("!O3T!/6%A80&]80$\@("`@;V]/
XM6$]/6&]O3UA8*R`@("`@("`@($]O6&]/;T]O6&\C3T`@("`@;V\K6%@K6&]8
XM6"M/("`@("`@("`@6%A/3T]83T]O6"M/("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@*V]/6$]/6&]O3UA/("`@("`@("`@("LC(RLC(RLC(R,K("`@
XM(&]O3UA/3UAO;T]86"L@("`@("`@("!/;UAO3V]/;UAO(T]`("`@("!O;T]8
XM3T]8;V]/6%@K("`@("`@("`@3V]8;T]O3V]8;R-/0"`@("`@;T]/6$]86$]8
XM6%@K("`@("`@("`C3UA/6$\K6$]`6$\@("`@(&]/6%A80&]80%A8*R`@("`@
XM("`@("`@("`@("`@("`@("`K;T]83T]8;V]/6$\@("`@("`@("`@*R,C*R,C
XM*R,C(RL@(BP*(EA86%A86%AO3UA/+BXN+BXN+E@N+EA`3T]/6&]83T]O3R`@
XM("!8*T]/;V]86%A83T\@("`@;T]8;UA/6&]/3V\K("`@("`@("`@("!/;U@K
XM6$]/0%A/;T`@("`@6%A86%A86&]/6$\N+BXN+BXN6"XN6$!/3T]8;UA/3V]/
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@3T]8;UA/6&]/3V]/;R`@
XM("`@("`@("`@("`@("`@("`@("`@(&]/6&]83UAO3T]O*R`@("`@("`@("`@
XM3V]8*UA/3T!83V]`("`@("!O3UAO6$]8;T]/;RL@("`@("`@("`@($]O6"M8
XM3T]`6$]O0&\@("`@6%AO6$]8;T]/;T]/("`@("`@("`@;V]O;V]/6%A83RL@
XM("`@(%A/;V]86%A83UA8*R`@("`@("`@("`@("`@("`@("`@("!/3UAO6$]8
XM;T]/;T]O("`@("`@("`@("`@("`@("`@("`@(BP*(F]86%A86%A8;UA/6%AO
XM6$]/6$]/3UA`6&]O6%A/3T]O*R`@("!O;UA8;V]86&]86"L@("!O6$]/6$]8
XM6$]86%@K("`@("`@("`@("`K(R,C(RLC(R,K(R,@("`@;UA86%A86%AO6$]8
XM6&]83T]83T]/6$!8;V]86$]/3V\K("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@*T]/6$]86$]86%A8;V]8+BXN6"XN+E@@("`@("`@("`@("`@;UA/
XM3UA/6%A/6%A8*R`@("`@("`@("`@3R,C*R,C(R,C(RLC("`@(&]83T]83UA8
XM3UA86$\@("`@("`@("`@($!/3UA`3T!/3T]8;T\@("`@;T]/3UA8;UA86$\K
XM("`@("`@("`@6%AO3T]O6&]/3T\@("`@(&]8;V]86&]86%A/3U@N6"XN6"XN
XM+E@N+BY8+B`@("`@("`K3T]83UA83UA86%AO;U@N+BY8+BXN6"`@("`@("`@
XM("`@(BP*(EA8;UAO6%@K3UA86%A8;T]8(T]O6&]8;V]O3T\K3V]83R`@("!8
XM6%A86$!O6$]/6$\@("!`6%AO6$]8;T]/;T\K("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@6%AO6&]86"M/6%A86%AO3U@C3V]8;UAO;V]/3RM/;UA/("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@($]O6$]8;T]/;T]/;T]/;UA/
XM6$\C6&\N+EA8("`@("`@("`@0%A8;UA/6&]/3V]/*R`@("`@("`@("`@("`@
XM("`@("`@("`@("`@($!86&]83UAO3T]O3RL@("`@("`@("`@($]83T]/6$!8
XM;V]86$!O("`@6%A/3T]/;UAO3U@K("`@("`@("!O6%A/3UA8;T]`;RL@("`@
XM(%A86$!O6$]/6%AO3T]83UA/3T]8;T]/*T]/*R`@("`@("`@3V]83UAO3T]O
XM3T]O3T]O6$]83R-8;RXN6%@@("`@("`@(BP*(F]/3V\K3RM/;V]86&]86"MO
XM;T]O6%A8;V]O;UA/3T]83R`@("!O6&]86%A/3UA/6$\@("!O;T]/3UA8;UA8
XM6$\@("`@("`@("`@("`@("`@("`@("`@("`@("`@;T]/;RM/*T]O;UA8;UA8
XM*V]O3V]86%AO;V]O6$]/3UA/("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("M/3UA8;UA86$]O3RM/3UAO6%AO;UAO3T]O6%@@("`@("`@;V]/3T]8
XM6&]86%A/("`@("`@("`@("`@("`@("`@("`@("`@("`@(&]O3T]/6%AO6%A8
XM3R`@("`@("`@("`@("!`3V]8;UAO;V]/3RM/("`@;RM86&]8*UAO3UA/+BXN
XM6"XN6%AO3V]O3UA/3UA/*R`@("`@(&]86%A/3UA/6%A/;RM86&]/;UA/3V]8
XM*UA/3R`@("`@("`@*T]/6%AO6%A83V]/*T]/6&]86&]O6&]/3V]86"`@("`@
XM(BP*(F]O6$]86&]/6$]83UAO6$]/6&]/6&]/;V]/6$]/0"MO*R`@("!O*UA/
XM6&]83T]/6"L@("!`3UA/3T]/;UAO3RL@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@;V]83UA8;T]83UA/6&]83T]8;T]8;T]O;T]83T]`*V\K("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`K3T]/;UAO3UA/6&]8;T!86"M8
XM6%A/3UA8;T]`("`@("`@0$]83T]/3V]8;T\K("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@($!/6$]/3T]O6&]/*R`@("`@("`@("`@("!O3V]86%AO;V]O
XM6$]/("`@;UAO6%A/6%A/6$]O3V]83T]8*RM86&]/;T`K6$]8*R`@("`@(&]/
XM6&]83T]/6$]83UA/;UAO*T]O6%A/6%A/*R`@("`@("`@("M/3T]O6&]/6$]8
XM;UAO0%A8*UA86$]/6%AO3T`@("`@(BP*(EA86%A83V]`6%AO0$!83UA83T]8
XM6%A80&]/6$\K;V]/3R`@("!86&]O6%A/6$]/;T\@("!`*RM86&]8*UAO3T\@
XM("`@("`@("`N6"XN6"Y8+BXN+BXN+E@@("`@6%A86%A/;T!86&]`0%A/6%A/
XM3UA86%A`;T]83RMO;T]/("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@*V]8*UAO3UA86%A/3V]86"MO3V]O3UA/3UA/;R`@("`@0"LK6%AO6"M8
XM;T]/("`@("`@("`@("`@("`@("`@("`@("`@("`@($`K*UA8;U@K6&]/3R`@
XM("`@("`@("`@("!`;T]8;T]O;T]83T\K("`@6%A/;V]O6$]/3UA86%A80%A/
XM6&]O;UA8;UAO6&\C("`@("`@(%AO6%A/6$]/;UA/6$]83UA/6%@K*T]O6&]O
XM*R`@("`@("`@("`K;U@K6&]/6%A86$]/;UA8*V]/;V]/6$]/6$]O("`@(BP*
XM(F]83UAO6$]O3V]O3V]/6$]83T]O;V]/6&]83T]/3V]`*R`@("!O;T]/6$!O
XM6%A86"L@("!O*UAO6%A/6%A/6$\@("`@("`@("!86"LK3V]8;V]/6$]O6$\@
XM("`@;UA/6&]83V]/;V]/;T]83UA/3V]O;T]8;UA/3T]/;T`K("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("M/6%A/6$]O3V]83T]8*RM86&]/
XM;T`K6$]86&\@("`@;RM8;UA83UA83UA/("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@(&\K6&]86$]86$]83R`@("`@("`@("`@("!/3UA86%A`;T]83RM/
XM("`@;T]86$]83UA/3UA83V\K3T]8;UA/;V]/0&]/6",@("`@("`@(&]/6$!O
XM6%A86%A86$]86%A8;T]/6"M8;V\K3R`@("`@("`@("`@*T]86$]83V]/;UA/
XM3U@K*UA8;T]O0"M83UA8;R`@(BP*(F]86$]/6%AO6$]86%@C6$]`3T!83T]/
XM6$]O;T]86&]`*R`@("!O6&]86$]O3V]O3RL@("!`3UA/;V]O6$]/3T`@("`@
XM("`@("!O3T]8*UAO;RM/3UAO6"L@("`@;UA83T]86&]83UA86"-83T!/0%A/
XM3T]83V]O3UA8;T`K("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@*T]/3UAO6%A80%A/6&]O;UA8;UAO6&]/3T]`("`@0$]83V]O;UA/3T]`
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@($!/6$]O;V]83T]/0"`@("`@
XM("`@("`@("!O3V]O;T]8;UA/3T]/("`@;V]O6%A/6%A86$\K*T]O6$!O6%@K
XM6%A86$\C(R`@("`@("`@(&]86$]O3V]O3UAO3UA86$]80$]/*UAO3T!8*R`@
XM("`@("`@("`@("`K3T]/6&]86%A`6$]8;V]O6%AO6&]8;T]/3T`@(BP*(E@K
XM;UAO*T]8;UAO*R,C*R,C(R,K(RM/6&]`6%A83V]/3R`@("!86%A86%@C3UA8
XM6$\@("!`;T]86$]83UA/3T\@("`@("`@("!`3T\K6&]/0%A/;RM83T\@("`@
XM6"MO6&\K3UAO6&\K(R,K(R,C(RLC*T]8;T!86%A/;T]/("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@(",K*V]83V\K3T]8;UA/;V]/0&]/
XM6%A86$]O("`@0&]/6%A/6$]83T]/("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@($!O3UA83UA/6$]/3R`@("`@("`@("`@("!/0%A/3T]83V]O3U@K("`@
XM6%A83UA/;UA86$]/6%A`6%AO3V]8;UAO3T]/(R`@("`@("`@(%A86%@C3UA8
XM6$]8;T]86&]/6$]`0$!/;RM/*R`@("`@("`@("`@("`@(RLK;UA/;RM/3UAO
XM6$]O;T]`;T]86%A83V\@(BP*(D!8*V]86%AO6&]O*R`@("`@("`@(&]O;T]8
XM3UA/3UA/*R`@("!`*UA86&]8;R-8;RL@("!O*V]O6%A/6%A86$`@("`@("`@
XM("!83T!`0$]O*T]O;RM/6$\@("`@0%@K;UA86&]8;V\K("`@("`@("`@;V]O
XM3UA/6$]/6$\K("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("LK(R,C(R,C*R,K6%A86$]/*V]O6%A/;R`@;RMO;UA83UA86%A`("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@(&\K;V]86$]86%A80"`@("`@("`@
XM("`@("!O6%A/6$]8;T!86%A/("`@0%A86"MO6%AO6%A83T]/6$]/3T]86%A8
XM6&]/;R`@("`@("`@($!86&]8;R-8;UA8*R,K(R,C*R,C(R,C(R,C*R`@("`@
XM("`@("`@("`@("`@*RLC(R,C(R,K(RM86%A83T\K;V]86$]O(BP*(F]/;T]/
XM6$]/;T]/3R`@("`@("`@(&]8;UA/*UA8;T\K*R`@("!O6&]/6&]/3U@C6"L@
XM("`@0%A83UA/;UA86$]`("`@("`@("!`3V]/*V]/*T]`3T]/3RL@("`@;T]O
XM3T]83T]O3T]/("`@("`@("`@;UAO6$\K6%AO3RLK("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("-O3T]/6$]/
XM6%A/3R`@($!86$]83V]86%A/0"`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("!`6%A/6$]O6%A83T`@("`@("`@("`@(&\K6&]O6&]O3UA/6"L@("`@;V]8
XM;UA`;T]/6&]83T]O3UAO6&]/3V]86&]83T\@("`@("`@(&]/6&]/3U@C6$]8
XM*R`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM(V]/3T]83T]86$]/(BP*(D!/6"M83RM86%A8*R`@("`@("`@($!8*UA/3T]`
XM;UA/*R`@("!`*V]86&]/6&]83RL@("`@3UA86"MO6%AO6%AO("`@("`@("`K
XM(R,C;V]8;V]86$]`3T\@("`@0$]8*UA/*UA86%@K("`@("`@("`@0%@K6$]/
XM3T!O6$\K("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("!/6&]/3UAO3UA8;R`@($]86%@K;UA8;UA8;R`@("`@
XM("`@("`@+BXN+E@N+BXN+BXN3R`@("!/6%A8*V]86&]86&\@("`@("`@("`@
XM(%A/3T]/;UAO6$\K6$\@("`@0"M/*T!O6%A/6"LK(R,K(R,K6&]O6&]/*UA`
XM3T]O("`@("`@($!86&]/6&]83UA8*R`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@($]8;T]/6&]/6%AO(BP*(EA86"M8;T]O
XM6%A/3R`@("`@("`@(%A83UA/6&]`6&]O3R`@("!83UA/6%A8;UA/3T\@("`@
XM0&]8;UA`;T]/6&]8("`@("`@("`@("!86&]83T]/(UA83RL@("`@6%A8*UAO
XM3V]86$]/("`@("`@("`@6%A/6$]8;T!8;V]/("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("!8+BY8+E@N+BY8+BXN6"`@("`@("`@("`@6&]83T]/(UA8
XM3R`@($!O6&]80&]/3UAO6"`@("`@("`@("`@6%AO6$]/3R-86$]8*R`@("!`
XM;UAO6$!O3T]8;U@@("`@("`@("`@(%A8;UA/3T\C6%A/6"L@("`@6&]/;UAO
XM*V]O6%@K("`@("`C(V\K6$]/3V]O3UA/("`@("`@(%A/6%A8;UA/3T]O*R`@
XM("`@("`@("`@("`@("`@("`@(%@N+E@N6"XN+E@N+BY8("`@("`@("`@("!8
XM;UA/3T\C6%A/(BP*(F]83UAO3V]/0%A8*R`@("`@("`@(&]8;V]8;T]80$]O
XM*R`@("!O3UA/6$]86&]/3RL@("`@($]/*T!O6%A/6"LK;R`@("`@("`@(%A/
XM*UA`3T\K3T]O3RL@("`@;UA/6&]/;T]`6%@K("`@("`@("`@;UAO;UAO3UA`
XM3V\K("`@("`@("`@("`@("`@("`@("`@("`@("`@("!O6"M/*T!O6%A/6"LK
XM;R`@("`@("`@("!8*UA`3T\K3T]O3R`@("!/3RM`;UA83U@K*V\@("`@("`@
XM("!83RM80$]/*T]/;T]O*R`@("`@3T\K0&]86$]8*RMO("`@("`@("`@6$\K
XM6$!/3RM/3V]/;RL@("`@;V]/;T]86%AO;V\K("`@("`@*T]/3RLK*V]/*T!`
XM;R`@("`@(&]/6$]86&]/3V]/*R`@("`@("`@("`@("`@("`@("`@(&]8*T\K
XM0&]86$]8*RMO("`@("`@("`@(%@K6$!/3RM/3V]/(BP*(D!/;T]86&]86&]8
XM*R`@("`@("`@($!83V]/3V]/3V]/*R`@("!`;UAO6%AO*V]/6"L@("`@($!/
XM;UAO*V]O6%A86%@@("`@("`@6$]/3V]O3V]8;T!`*T\@("`@0$]O3UA8;UA8
XM;U@K("`@("`@("`@0%A/;T]/;T]/;T\K("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("!83V]/;UAO*V]O6%A86%@@("`@("`@(%A/3V]O3UA/*UA83R`@
XM("!`3V]8;RMO;UA86%A8("`@("`@(%A/3T]O;T]83RM86%@K("`@("`@0$]O
XM6&\K;V]86%A86"`@("`@("!83T]/;V]/6$\K6%A8*R`@("`@0&]83V]O6%A8
XM*T]/("`@("`@("M`3T]8;V\K;UA`;R`@("`@($!O6%AO*V]/6%A/*R`@("`@
XM("`@("`@("`@("`@("`@(%A/;T]O6&\K;V]86%A86"`@("`@("`@6$]/;V]/
XM6$\K6%A/(BP*(D!/3UA86$]86$]/*R`@("`@("`@($!`3T]8;V]O6$]O*R`@
XM("!`;T]86%A`6&]/3RL@("`@("!/;T]86%AO;V]/6%@N+B`@(%@N3RLK*V]/
XM6%A8*T]83RL@("`@0$]/6%A83UA83T\K("`@("`@("`@0$!/3UAO;V]83V\K
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("!O6&]/;T]86%AO;V]/6%@N
XM6"Y8+BY8+BLK*V]/*T!`;UAO*R`@("`@3V]/6%A8;V]O3UA8+BX@("!8+D\K
XM*RMO3RM`0&]8;T\K("`@("`@($]O3UA86&]O;T]86"XN("`@6"Y/*RLK;T\K
XM0$!O6&]/*R`@("`@0"M80%A83UA86$\K("`@("`@("M/6&]/3T]8(T]/;R`@
XM("`@($!86%A`6&]/3UA/3RY8+BXN+E@N6"XN6"XN+E@N3R`@(&]8;T]O3UA8
XM6&]O;T]86"Y8+E@N+E@N*RLK;T\K0$!O6&\K(BP*(D!86%@K3V]86$!/3R`@
XM("`@("`@($!/;V]`3V]/3V]O*R`@("!`;UAO3T]O6%A/;RL@("`@("!/3V]O
XM6%A8*T]/3V]86"XN+EA`3T]8;V\K3V]/3RM/3RL@("`@0%A86"M/;UA80$]/
XM("`@("`@("`@0$]O;T!/;T]/;V\K("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@3V]83V]O6%A8*T]/3V]86%AO6%A`3T]8;V\K;UA`3T]/("`@("`@
XM3T]O;UA86"M/3T]O6%@N+BY80$]/6&]O*V]80$]/3RL@("`@("`@($]/;V]8
XM6%@K3T]/;UA8+BXN6$!/3UAO;RMO6$!/3T\K("`@("`@0$]8;V]O6$]86%@K
XM("`@("`@("!/;T!/6$]/;T]/6&\@("`@($!O3T]O6%A/;V]/3T]O;U@K6$]O
XM(UA86$]/6"-O*R`@("!/;UA/;V]86%@K3T]/;UA86&]86$!/3UAO;RMO6$!/
XM3T\@(BP*(F]86%A/3T]/6&]8*R`@("`@("`@(&]O;T\K6&]8;T]83R`@("!O
XM;UA/3UA/;UA/3T\@("`@("`@3UA83UA86$]83UAO6$]83V]/6&]/3T]83V]8
XM;T!`*RL@("`@;UA86$]/3T]8;U@K("`@("`@("`@;V]O3RM8;UAO3UA/("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@;RM80%A83UA86$]83UAO6$]8
XM3V]/6&]/3T]8(T]/;T\K("`@("`@($]86$]86%A/6$]8;UA/6$]O3UAO3T]/
XM6"-/3V]/(R`@("`@("`@("!/6%A/6%A83UA/6&]83UA/;T]8;T]/3U@C3T]O
XM3R,@("`@("`@;UA86%A/3UAO;V]/("`@("`@("!/(T]83UAO;RMO3U@@("`@
XM(&]/3UA/;UA/3V\K;T]O3T]/*T]/;V]83V]83T]O3R`@("!O*UA`6%A/6%A8
XM3UA/6&]83UA/;T]8;T]/3U@C3T]O3RL@(BP*(D!/3V]/;UA83T]/*R`@("`@
XM("`@($!O3RM/0%@K;R-8*R`@("!`*T]/3T]83V\K6"L@("`@("`@($]O6$]8
XM6%A/*UAO*RM/6"M/;T!/6$]/6%A8*T]83RL@("`@0$]/;T]O6%A/3T\K("`@
XM("`@("`@0&]/*T]`6"MO(U@K("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@($]8;V]O6$]86%A/*UAO*RM/6"M/;T!/6$]/;T]/6$\@("`@("`@("!/
XM;UA/6%A83RM8;RLK3U@K3V]`3UA/3V]/3U@K("`@("`@("`@("`@3V]83UA8
XM6$\K6&\K*T]8*T]O0$]83T]O3T]8*R`@("`@("`@0$]/3T]/6&]/;V\K("`@
XM("`@("!`3UA`6&]86&]/6&\@("`@($!/3T]83V\K6$]83V]/;UAO*V]`0&\K
XM3V]O*T]/*R`@("`@3UAO;V]83UA86$\K6&\K*T]8*T]O0$]83T]O3T]83R`@
XM(BP*(D!/;RM86%A/6&]O*R`@("`@("`@($!O3V]/;V]O;T]8*R`@("!`3T]8
XM*UA86%A83RL@("`@("`@("`K3UAO;V]O;UA/3V]O3V]8(T]83UAO3V]/3RM/
XM3T\@("`@0$]O*UA86$]8;V\K("`@("`@("`@0&]/;T]O;V]O3U@K("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("!/6%A/3UAO;V]O;UA/3V]O3V]8
XM(T]83UAO;RMO*R`@("`@("`@("`@*T]8;V]O;V]83T]O;T]O6"-/6$]8;V\K
XM;RL@("`@("`@("`@("`@("M/6&]O;V]O6$]/;V]/;U@C3UA/6&]O*V\K("`@
XM("`@("`@0&]8*RMO3UAO3U@K("`@("`@("!/6&]`3RM/3V]O3V]8("`@($!8
XM*UA86%A83T!80$]O3T\C*V]83UA/0$`K;T\K*R`@("`@($]86$]/6&]O;V]O
XM6$]/;V]/;U@C3UA/6&]O*V\K("`@(BP*(D!/6%A/3UA/6$]O3R`@("`@("`@
XM($!O*V]O;UAO;V]8*R`@("!`6&]86"MO3V]/3RL@("`@("`@("`@*V]/;V]8
XM;V]8;T]8;T]/3UA`6&]83UA8(T]/3RL@("`@0$]86$]/6$]83V]/("`@("`@
XM("`@0&\K;V]O6&]O;U@K("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@3T]/6&]/;V]8;V]8;T]8;T]/3UA`6&]86&]/("`@("`@("`@("`@("MO
XM3V]O6&]O6&]/6&]/3T]80%AO6%@C*R`@("`@("`@("`@("`@("`K;T]O;UAO
XM;UAO3UAO3T]/6$!8;UA8(RL@("`@("`@("`@0&]O3T]8;V\K0"LK("`@("`@
XM("`@0&]O3UAO;T]86%A8("`@($!86"MO3V]/3V]/3V]`3V]O;T]O;V]/*V]/
XM;RMO*R`@("`@("!/3T]8;T]O;UAO;UAO3UAO3T]/6$!8;UA8;T\@("`@(BP*
XM(D!/6"M8;UA/3V]O*R`@("`@("`@($!/3T]O3V]`3UA/*R`@("!`3V]86&]/
XM6%AO3RL@("`@("`@("`@("LK3UAO6%A86%A/;T`K6&]`3RLK*T!/6%AO;RL@
XM("`@0$]8*UAO6$]/;V\K("`@("`@("`@0$]/3V]/;T!/6$\K("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("LK3UAO3UAO6%A86%A/;T`K6&]`
XM3RM/3RL@("`@("`@("`@("`@("`K*T]8;UA86%A83V]`*UAO0$\K3RL@("`@
XM("`@("`@("`@("`@("`@*RM/6&]86%A86$]O0"M8;T!/*T\K("`@("`@("`@
XM("`@0&]O6$]/;T]O6&\C("`@("`@("`@0$]/;V]/;T]83UAO("`@($!86&]/
XM6%AO3UA83T]83V]/;V]/3V]O3V]/3RLK3R`@("`@("`@*RM/6&]/6&]86%A8
XM6$]O0"M8;T!/*T]/*R`@("`@(BP*(D!O3UA/;T]O3T]8*R`@("`@("`@($`K
XM;V]/3UA/3T]/*R`@("!`3T]86$]/6$]O6"L@("`@("`@("`@("`@*RMO3V]/
XM6$]O;T]/;V]O*RL@*T]/*RM/3RL@("`@0&]/6$]O3V]/3U@K("`@("`@("`@
XM0"MO;T]/6$]/3T\K("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@*RLK0"MO3V]/6$]O;T]/;V]O3U@K(R`@("`@("`@("`@("`@("`@("LK
XM;T]O3UA/;V]/3V]O;RLK(R`@("`@("`@("`@("`@("`@("`@("`K*V]/;T]8
XM3V]O3T]O;V\K*R,@("`@("`@("`@("`@0$!/3UAO3RMO3T\K("`@("`@("`@
XM($!8;T]O;V]O3V]O6"`@($!86$]/6$]O6$]`*T]83T]/;V]O3T]/0$]8;T`K
XM*R`@("`@("`@("`K*RM`*V]/;T]83V]O3T]O;V]/6"LC("`@("`@(BP*(BLC
XM(R,K(R,C*R,C*R`@("`@("`@("LC(R,K(R,C*R,C*R`@("`K(R,C*R,C(RLC
XM(RL@("`@("`@("`@("`@("`C(RLC6%@C3T`C(R,C("`@*R,C(RLC(RL@("`@
XM*R,C(RLC(R,K(R,K("`@("`@("`@*R,C(RLC(R,K(R,K("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@*R-/3T]`6%@C3T!O*RLC*R,@
XM("`@("`@("`@("`@("`@("`@("`@(R,K(UA8(T]`(R,C(R`@("`@("`@("`@
XM("`@("`@("`@("`@("`@(",C*R-86&]/0",C(R,@("`@("`@("`@("`@("`@
XM*R,C*R,K(R,C(R,K("`@("`@("`@("LC(RLC(R,K(R,C*R`@("LC(R,C*R,C
XM(R,C(R,C*R,C(R,C(RLC(R,C(R,C*R`@("`@("`@("`@("`K(T]/3T!86"-/
XM0&\K*R,K(R`@("`@("`@(BP*(B`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`K(R,C
XM(R,K("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`C(RLC(R,K(R,C("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM(",C(R,C*R`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("LC(R,C
XM(RL@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XH("`@("`@("`@("`@(",C*R,C(RLC(R,@("`@("`@("`@("`@(GT["B`@
X`
Xend
END_OF_FILE
if test 19805 -ne `wc -c <'bitmaps/highscores.xpm.uu'`; then
    echo shar: \"'bitmaps/highscores.xpm.uu'\" unpacked with wrong size!
fi
# end of 'bitmaps/highscores.xpm.uu'
fi
if test -f 'bonus.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bonus.c'\"
else
echo shar: Extracting \"'bonus.c'\" \(19041 characters\)
sed "s/^X//" >'bonus.c' <<'END_OF_FILE'
X#include "include/copyright.h"
X
X/*
X *  Include file dependencies:
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <stddef.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#include <xpm.h>
X
X#include "include/error.h"
X#include "include/audio.h"
X#include "include/highscore.h"
X#include "include/misc.h"
X#include "include/main.h"
X#include "include/gun.h"
X#include "include/init.h"
X#include "include/stage.h"
X#include "include/blocks.h"
X#include "include/sfx.h"
X#include "include/ball.h"
X#include "include/score.h"
X#include "include/paddle.h"
X#include "include/level.h"
X#include "include/mess.h"
X#include "include/intro.h"
X
X#include "bitmaps/titleSmall.xpm"
X
X#include "include/bonus.h"
X
X/*
X *  Internal macro definitions:
X */
X
X#define GAP					30
X#define KEY_TYPE_VOL		50
X#define LINE_DELAY			15
X
X#define BONUS_SCORE			3000
X#define SUPER_BONUS_SCORE	50000
X#define BULLET_SCORE		500
X#define LEVEL_SCORE			1000
X#define TIME_BONUS			100
X
X#define BORDER_LEFT			55
X#define BORDER_RIGHT		((PLAY_WIDTH + MAIN_WIDTH) - 50)
X#define BORDER_TOP			73
X#define BORDER_BOTTOM		((PLAY_HEIGHT + MAIN_HEIGHT) - 85)
X
X/*
X *  Internal type declarations:
X */
X
X#if NeedFunctionPrototypes
Xstatic void DoBullets(Display *display, Window window);
Xstatic void DoTimeBonus(Display *display, Window window);
X#else
Xstatic void DoTimeBonus();
Xstatic void DoBullets();
X#endif
X
X/*
X *  Internal variable declarations:
X */
X
Xstatic int 		nextFrame = 0;
Xstatic int 		count, numBonus;
Xenum BonusStates BonusState;
Xstatic Pixmap 	titlePixmap, titlePixmapM;
Xstatic int 		ypos;
Xstatic int 		waitingFrame, waitMode;
Xstatic char 	string[80];
Xstatic Pixmap 	backingStoreTitle = (Pixmap) NULL;
Xstatic u_long 	bonusScore;
Xstatic int 		firstTime = True;
X
X
X#if NeedFunctionPrototypes
Xvoid SetUpBonus(Display *display, Window window, Colormap colormap)
X#else
Xvoid SetUpBonus(display, window, colormap)
X	Display *display;
X	Window window;
X	Colormap colormap;
X#endif
X{
X	XpmAttributes   attributes;
X	int             XpmErrorStatus;
X
X	attributes.valuemask = XpmColormap;
X	attributes.colormap = colormap;
X
X	/* Create the small title pixmap */
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, titleSmall_xpm,
X		&titlePixmap, &titlePixmapM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBonus()");
X
X    /* Free the xpm pixmap attributes */
X	XpmFreeAttributes(&attributes);
X}
X
X#if NeedFunctionPrototypes
Xvoid DecNumberBonus(void)
X#else
Xvoid DecNumberBonus()
X#endif
X{
X	/* bump down the number of bonuses. sic */
X	numBonus--;
X}
X
X#if NeedFunctionPrototypes
Xvoid IncNumberBonus(void)
X#else
Xvoid IncNumberBonus()
X#endif
X{
X	/* bump up the number of bonuses. sic */
X	numBonus++;
X}
X
X#if NeedFunctionPrototypes
Xint GetNumberBonus(void)
X#else
Xint GetNumberBonus()
X#endif
X{
X	/* Umm - return the number of bonuses */
X	return numBonus;
X}
X
X#if NeedFunctionPrototypes
Xvoid ResetNumberBonus(void)
X#else
Xvoid ResetNumberBonus()
X#endif
X{
X	/* No more bonuses thanks */
X	numBonus = 0;
X}
X
X#if NeedFunctionPrototypes
Xvoid DrawBallBorder(Display *display, Window window)
X#else
Xvoid DrawBallBorder(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int x, y;
X	static int slide = 0;
X
X	/* Draw a row of balls along the top and bottom of screen */
X	for (x = BORDER_LEFT; x < BORDER_RIGHT; x += 22)
X	{
X		DrawTheBall(display, window, x, BORDER_TOP, slide);
X		DrawTheBall(display, window, x, BORDER_BOTTOM, slide);
X
X		/* Next frame of ball animation */
X		slide++;
X
X		/* Wrap around animation */
X		if (slide == BALL_SLIDES) slide = 0;
X	}
X
X	/* Draw a row of balls along both sides of the screen */
X	for (y = BORDER_TOP; y < BORDER_BOTTOM; y += 22)
X	{
X		DrawTheBall(display, window, BORDER_LEFT, y, slide);
X		DrawTheBall(display, window, BORDER_RIGHT, y, slide);
X
X		/* Next frame of ball animation */
X		slide++;
X
X		/* Wrap around animation */
X		if (slide == BALL_SLIDES) slide = 0;
X	}
X
X}
X
X#if NeedFunctionPrototypes
Xvoid DrawSmallIntroTitle(Display *display, Window window, int x, int y)
X#else
Xvoid DrawSmallIntroTitle(display, window, x, y)
X	Display *display;
X	Window window;
X	int x;
X	int y;
X#endif
X{
X	/* Draw the small title pixmap */
X	RenderShape(display, window, titlePixmap, titlePixmapM,
X		x - SMALL_TITLE_WC, y - SMALL_TITLE_HC, 
X		SMALL_TITLE_WIDTH, SMALL_TITLE_HEIGHT, False);
X}
X
X#if NeedFunctionPrototypes
Xvoid MoveSmallIntroTitle(Display *display, Window window, int x, int y)
X#else
Xvoid MoveSmallIntroTitle(display, window, x, y)
X	Display *display;
X	Window window;
X	int x;
X	int y;
X#endif
X{
X	static int oldx, oldy;
X
X    /* Make a copy of the new titles position */
X    if (backingStoreTitle != (Pixmap) NULL)
X        XCopyArea(display, backingStoreTitle, window, gc,
X            0, 0, SMALL_TITLE_WIDTH, SMALL_TITLE_HEIGHT, oldx, oldy);
X    else
X    {
X        /* Create a pixmap for the backing store title */
X        backingStoreTitle = XCreatePixmap(display, window,
X            SMALL_TITLE_WIDTH, SMALL_TITLE_HEIGHT,
X            DefaultDepth(display, XDefaultScreen(display)));
X    }
X
X    /* Update the variables for the title position */
X    oldx = x - SMALL_TITLE_WC; oldy = y - SMALL_TITLE_HC;
X
X    /* Copy back the old position picture */
X    if (backingStoreTitle)
X        XCopyArea(display, window, backingStoreTitle, gc,
X            x - SMALL_TITLE_WC, y - SMALL_TITLE_HC, 
X			SMALL_TITLE_WIDTH, SMALL_TITLE_HEIGHT, 0, 0);
X
X    DrawSmallIntroTitle(display, window, x, y);
X}
X
X
X#if NeedFunctionPrototypes
Xvoid SetupBonusScreen(Display *display, Window window)
X#else
Xvoid SetupBonusScreen(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	/* Clear the background again */
X	ClearMainWindow(display, window);
X
X	/* Draw the rectangular border of balls */
X	DrawBallBorder(display, window);
X
X	/* Draw the main title pixmap */
X	DrawSmallIntroTitle(display, window, TOTAL_WIDTH / 2, 120);
X
X	/* The new state will be the text */
X	ResetBonus();
X
X	/* Remove the window to show bonus stuff */
X	while (WindowFadeEffect(display, playWindow));
X	XUnmapWindow(display, playWindow);
X}
X
X#if NeedFunctionPrototypes
Xvoid DrawTitleText(Display *display, Window window)
X#else
Xvoid DrawTitleText(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	SetCurrentMessage(display, messWindow, "- Bonus Tally -", True);
X	
X	/* Indicate which level the bonus is for */
X	sprintf(string, "- Level %d -", level);
X	DrawShadowCentredText(display, window, titleFont, 
X		string, ypos, red, TOTAL_WIDTH);
X	ypos += (titleFont->ascent + GAP);
X
X	strcpy(string, "Press space for next level");
X	DrawShadowCentredText(display, window, textFont, 
X		string, PLAY_HEIGHT - 12, tann, TOTAL_WIDTH);
X
X	BonusState = BONUS_SCORE;
X
X	/* Just in case it has changed */
X	SetGameSpeed(FAST_SPEED);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoScore(Display *display, Window window)
X#else
Xstatic void DoScore(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	SetGameSpeed(MEDIUM_SPEED);
X
X	/* Nice message rewarding you for your efforts */
X	strcpy(string, "Congratulations on finishing this level.");
X	DrawShadowCentredText(display, window, textFont, 
X		string, ypos, white, TOTAL_WIDTH);
X	XFlush(display);
X
X	count = 0;
X	ypos += (35 + GAP);
X	SetBonusWait(BONUS_BONUS, frame + LINE_DELAY);
X	SetGameSpeed(SLOW_SPEED);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoBonuses(Display *display, Window window)
X#else
Xstatic void DoBonuses(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int x, plen;
X	static int maxLen;
X
X	if (firstTime)
X	{
X		/* Set up the bonus coin sequence */
X		firstTime = False;
X
X		if (numBonus == 0)
X		{
X			/* No bonus coins - so tell user */
X			strcpy(string, "Sorry, no bonus coins collected.");
X			DrawShadowCentredText(display, window, textFont, 
X				string, ypos, blue, TOTAL_WIDTH);
X
X			SetGameSpeed(MEDIUM_SPEED);
X
X			/* Now skip to the next sequence */
X			SetBonusWait(BONUS_LEVEL, frame + LINE_DELAY);
X			count = 0;
X			firstTime = True;
X			ypos += (textFont->ascent + GAP * 2);
X			return;
X		}
X
X		if (numBonus > MAX_BONUS)
X		{
X			/* Play the sound for the super bonus */
X			if (noSound == False) 
X				playSoundFile("superbonus", 80);
X
X			/* More than 10 coins collected - super bonus reward */
X			sprintf(string, "Super Bonus - %d", SUPER_BONUS_SCORE);
X				DrawShadowCentredText(display, window, titleFont, 
X					string, ypos, blue, TOTAL_WIDTH);
X
X			/* Update the score with more points */
X			bonusScore += SUPER_BONUS_SCORE;
X			DisplayScore(display, scoreWindow, bonusScore);
X	
X			SetGameSpeed(MEDIUM_SPEED);
X
X			/* Now skip to the next sequence */
X			SetBonusWait(BONUS_LEVEL, frame + LINE_DELAY);
X			count = 0;
X			firstTime = True;
X			ypos += (textFont->ascent + GAP * 2);
X			return;
X		}
X
X		/* Calculate where to draw these coins centred */
X		maxLen = ((numBonus * 27) + (10 * numBonus) + 5);
X	}
X
X	/* Find out where the next bonus coin will go next */
X	plen = ((numBonus * 27) + (10 * numBonus));
X	x = (((PLAY_WIDTH + MAIN_WIDTH) / 2) + (maxLen / 2)) - plen;
X
X	/* Draw the bonus coin shape */
X	DrawTheBlock(display, window, x, ypos, BONUS_BLK, 0);
X
X	/* Play the sound for the bonus */
X	if (noSound == False) 
X		playSoundFile("bonus", 50);
X
X	/* Increment the score by the value of the bonus */
X	bonusScore += BONUS_SCORE;
X	DisplayScore(display, scoreWindow, bonusScore);
X
X	/* Reduce number of bonuses */
X	DecNumberBonus();
X
X	if (numBonus <= 0)
X	{
X		/* Set up bonus state for next sequence */
X		SetBonusWait(BONUS_LEVEL, frame + LINE_DELAY);
X		count = 0;
X
X		/* Make sure bonus is reset */
X		ResetNumberBonus();
X
X		ypos += (textFont->ascent + GAP * 1.5);
X		firstTime = True;
X
X		SetGameSpeed(MEDIUM_SPEED);
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoLevel(Display *display, Window window)
X#else
Xstatic void DoLevel(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int secs, theLevel;
X
X	SetGameSpeed(MEDIUM_SPEED);
X
X	/* Get the number of seconds left on the clock */
X	secs = GetLevelTimeBonus();
X
X	if (secs > 0)
X	{
X    	/* Adjust the level so that the starting level is taken into account */
X    	theLevel = (int) level - GetStartingLevel() + 1;
X
X		/* Draw level bonus text */
X		sprintf(string, "Level bonus - level %d x %d = %d points", 
X			theLevel, LEVEL_SCORE, theLevel * LEVEL_SCORE);
X		DrawShadowCentredText(display, window, textFont, 
X			string, ypos, yellow, TOTAL_WIDTH);
X
X		/* Increment the score by the value of the level bonus */
X		bonusScore += (LEVEL_SCORE * theLevel);
X		DisplayScore(display, scoreWindow, bonusScore);
X	}
X	else
X	{
X		strcpy(string, "No level bonus - Timer ran out.");
X		DrawShadowCentredText(display, window, textFont, 
X			string, ypos, yellow, TOTAL_WIDTH);
X	}
X
X	count = 0;
X
X	/* Next section setup */
X	ypos += (textFont->ascent + GAP * 1.5);
X	SetBonusWait(BONUS_BULLET, frame + LINE_DELAY);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoBullets(Display *display, Window window)
X#else
Xstatic void DoBullets(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int x, plen;
X	static int maxLen;
X
X	if (firstTime)
X	{
X		/* For the first time setup the bullet bonus seq. */
X		firstTime = False;
X
X		if (GetNumberBullets() == 0)
X		{
X			/* No bullets - say so */
X			strcpy(string, "You have used all your bullets. No bonus!");
X			DrawShadowCentredText(display, window, textFont, 
X				string, ypos, blue, TOTAL_WIDTH);
X			
X			SetGameSpeed(MEDIUM_SPEED);
X
X			/* Get ready for the next sequence */
X			SetBonusWait(BONUS_TIME, frame + LINE_DELAY);
X			count = 0;
X			firstTime = True;
X			ypos += (textFont->ascent + GAP/2);
X			return;
X		}
X
X		/* Position where the first bullet will be drawn */
X		maxLen = ((GetNumberBullets() * 7) + (3 * GetNumberBullets()));
X	}
X
X	/* Find out where the next bonus bullet will go next */
X	plen = ((GetNumberBullets() * 7) + (3 * GetNumberBullets()));
X	x = (((PLAY_WIDTH + MAIN_WIDTH) / 2) + (maxLen / 2)) - plen;
X
X	DrawTheBullet(display, window, x, ypos);
X
X	/* Play the sound for the bullets */
X	if (noSound == False) 
X		playSoundFile("key", 50);
X
X	/* Increment the score by the value of the bullet bonus */
X	bonusScore += BULLET_SCORE;
X	DisplayScore(display, scoreWindow, bonusScore);
X
X	/* Ummm. Draw a bullet */
X	DeleteABullet(display);	
X
X	if (GetNumberBullets() == 0)
X	{
X		/* Reset bullets and get ready for next sequence */
X		SetBonusWait(BONUS_TIME, frame + LINE_DELAY);
X		count = 0;
X		ypos += (textFont->ascent + GAP/2);
X		firstTime = True;
X		SetGameSpeed(MEDIUM_SPEED);
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoTimeBonus(Display *display, Window window)
X#else
Xstatic void DoTimeBonus(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int secs = 0;
X
X	SetGameSpeed(MEDIUM_SPEED);
X
X	/* Get the number of seconds left on the clock */
X	secs = GetLevelTimeBonus();
X
X	if (secs > 0)
X	{
X		/* Draw time bonus text */
X		sprintf(string, "Time bonus - %d seconds x %d = %d points", 
X			secs, TIME_BONUS, secs * TIME_BONUS);
X		DrawShadowCentredText(display, window, textFont, 
X			string, ypos, yellow, TOTAL_WIDTH);
X
X		/* Increment the score by the value of the time bonus */
X		bonusScore += (TIME_BONUS * secs);
X		DisplayScore(display, scoreWindow, bonusScore);
X	}
X	else
X	{
X		/* Draw no time bonus text */
X		strcpy(string, "No time bonus - not quick enough!");
X		DrawShadowCentredText(display, window, textFont, 
X			string, ypos, yellow, TOTAL_WIDTH);
X	}
X
X	/* Next section setup */
X	ypos += (textFont->ascent + GAP/2);
X	SetBonusWait(BONUS_HSCORE, frame + LINE_DELAY);
X	count = 0;
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoHighScore(Display *display, Window window)
X#else
Xstatic void DoHighScore(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int myrank = 0;
X	char str[5];
X
X	SetGameSpeed(MEDIUM_SPEED);
X
X	/* Obtain current ranking for this score */
X	myrank = GetHighScoreRanking(score);
X
X	if (myrank > 0)
X	{
X		/* Special case for first place */
X		if (myrank == 1)
X			sprintf(string, "You are ranked 1st. Well done!");
X		else
X		{
X			/* Add the correct grammer for the sentence */
X			switch (myrank)
X			{
X				case 1:
X					strcpy(str, "st");
X					break;
X				
X				case 2:
X					strcpy(str, "nd");
X					break;
X				
X				case 3:
X					strcpy(str, "rd");
X					break;
X				
X				case 4:
X				case 5:
X				case 6:
X				case 7:
X				case 8:
X				case 9:
X				case 10:
X					strcpy(str, "th");
X					break;
X				
X				default:
X					strcpy(str, "");
X					break;
X			}
X
X			/* Construct beautiful sentence */
X			sprintf(string, "You are currently ranked %d%s.", 
X				myrank, str);
X		}
X	}
X	else
X		/* What a loser ;-) */
X		strcpy(string, "You haven't even qualified for a highscore!");
X
X	/* Draw the text for the game ranking */
X	DrawShadowCentredText(display, window, textFont, 
X		string, ypos, red, TOTAL_WIDTH);
X	ypos += (textFont->ascent + GAP/2);
X
X	count = 0;
X	SetBonusWait(BONUS_END_TEXT, frame + LINE_DELAY);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoEndText(Display *display, Window window)
X#else
Xstatic void DoEndText(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	SetGameSpeed(MEDIUM_SPEED);
X
X	/* Finishing sentence - so you know what level to do */
X	sprintf(string, "Prepare for level %d", level+1);
X	DrawShadowCentredText(display, window, textFont, 
X		string, ypos, yellow, TOTAL_WIDTH);
X	XFlush(display);
X
X	count = 0;
X	SetBonusWait(BONUS_FINISH, frame + 60);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoFinish(Display *display, Window window)
X#else
Xstatic void DoFinish(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	/* Setup game window for the next level */
X	level++;
X	SetupStage(display, playWindow);
X
X	BonusState = BONUS_TEXT;
X	SetGameSpeed(FAST_SPEED);
X
X	mode = MODE_GAME;
X
X	XSetWindowBorder(display, playWindow, red);
X	XMapWindow(display, playWindow);
X
X	/* Only redraw if the server hasn't backing store on */
X	if (DoesBackingStore(XDefaultScreenOfDisplay(display)) != Always)
X		SelectiveRedraw(display);
X}
X
X#if NeedFunctionPrototypes
Xvoid SetBonusWait(int newMode, int waitFrame)
X#else
Xvoid SetBonusWait(newMode, waitFrame)
X	int newMode;
X	int waitFrame;
X#endif
X{
X	waitingFrame = waitFrame;
X	waitMode = newMode;
X	BonusState = BONUS_WAIT;
X}
X
X#if NeedFunctionPrototypes
Xvoid DoBonusWait(void)
X#else
Xvoid DoBonusWait()
X#endif
X{
X	/* Wait for the frame we want to come along - then change modes */
X	if (frame == waitingFrame)
X		BonusState = waitMode;
X}
X
X#if NeedFunctionPrototypes
Xvoid DoBonus(Display *display, Window window)
X#else
Xvoid DoBonus(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	/* The states within the bonus mode */
X	switch (BonusState)
X	{
X		case BONUS_TEXT:
X			DrawTitleText(display, window);
X			break;
X
X		case BONUS_SCORE:
X			DoScore(display, window);
X			break;
X
X		case BONUS_BONUS:
X			DoBonuses(display, window);
X			break;
X
X		case BONUS_LEVEL:
X			DoLevel(display, window);
X			break;
X
X		case BONUS_BULLET:
X			DoBullets(display, window);
X			break;
X
X		case BONUS_TIME:
X			DoTimeBonus(display, window);
X			break;
X
X		case BONUS_HSCORE:
X			DoHighScore(display, window);
X			break;
X
X		case BONUS_END_TEXT:
X			DoEndText(display, window);
X			break;
X
X		case BONUS_FINISH:
X			DoFinish(display, window);
X			break;
X
X		case BONUS_WAIT:
X			DoBonusWait();
X			break;
X
X		default:
X			break;
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid RedrawBonus(Display *display, Window window)
X#else
Xvoid RedrawBonus(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	/* This will redraw the entire screen */
X	SetupBonusScreen(display, mainWindow);
X}
X
X#if NeedFunctionPrototypes
Xvoid FreeBonus(Display *display)
X#else
Xvoid FreeBonus(display)
X	Display *display;
X#endif
X{
X	/* Free all the hungry memory leaks */
X	if (titlePixmap)	XFreePixmap(display, titlePixmap);
X	if (titlePixmapM)	XFreePixmap(display, titlePixmapM);
X}
X
X#if NeedFunctionPrototypes
Xvoid ComputeAndAddBonusScore(void)
X#else
Xvoid ComputeAndAddBonusScore()
X#endif
X{
X	/* This function will pre compute the bonus score and add it to the
X	 * score. The bonus screen will only change the score by updating the
X	 * score display and not the score value. This means the user can hit
X	 * space and go to the next screen without delay. Cool.
X	 */
X	int secs = 0;
X	int theLevel = 0;
X
X	/* Compute bonus coin bonus */
X	if (numBonus > MAX_BONUS)
X	{
X		/* More than MAX_BONUS bonus so give super bonus */
X		AddToScore((u_long) SUPER_BONUS_SCORE);
X	}
X	else
X	{
X		/* Less than MAX_BONUS so work out bonus score */
X		AddToScore((u_long) (numBonus * BONUS_SCORE));
X	}
X
X   	/* Adjust the level so that the starting level is taken into account */
X   	theLevel = (int) level - GetStartingLevel() + 1;
X
X	/* Increment the score by the value of the level bonus */
X	AddToScore((u_long) (LEVEL_SCORE * theLevel));
X
X	/* Increment the score by the value of the bullet bonus */
X	if (GetNumberBullets() != 0)
X		AddToScore((u_long) (GetNumberBullets() * BULLET_SCORE));
X
X    /* Get the number of seconds left on the clock */
X    secs = GetLevelTimeBonus();
X    if (secs > 0)
X    {
X        /* Increment the score by the value of the time bonus */
X        AddToScore((u_long) (TIME_BONUS * secs));
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid ResetBonus(void)
X#else
Xvoid ResetBonus()
X#endif
X{
X	/* Setup for bonus screen from start */
X	BonusState = BONUS_TEXT;
X	nextFrame = frame + 500;
X	count = 0;
X	firstTime = True;
X	bonusScore = score;
X	ComputeAndAddBonusScore();
X	ypos = 180;
X	SetGameSpeed(FAST_SPEED);
X}
END_OF_FILE
if test 19041 -ne `wc -c <'bonus.c'`; then
    echo shar: \"'bonus.c'\" unpacked with wrong size!
fi
# end of 'bonus.c'
fi
if test -f 'gun.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gun.c'\"
else
echo shar: Extracting \"'gun.c'\" \(16237 characters\)
sed "s/^X//" >'gun.c' <<'END_OF_FILE'
X#include "include/copyright.h"
X
X/*
X *  Include file dependencies:
X */
X
X#include <xpm.h>
X#include <stdio.h>
X#include <math.h>
X#include <assert.h>
X
X#include "bitmaps/bullet.xpm"
X#include "bitmaps/tink.xpm"
X
X#include "include/error.h"
X#include "include/audio.h"
X#include "include/score.h"
X#include "include/init.h"
X#include "include/main.h"
X#include "include/stage.h"
X#include "include/blocks.h"
X#include "include/paddle.h"
X#include "include/misc.h"
X#include "include/level.h"
X#include "include/ball.h"
X#include "include/special.h"
X
X#include "include/gun.h"
X
X/*
X *  Internal macro definitions:
X */
X
X#define BULLET_DY			-10
X
X#define BULLET_WIDTH		7
X#define BULLET_HEIGHT		16
X
X#define BULLET_START_Y		(PLAY_HEIGHT - 40)
X
X#define BULLET_WC			(BULLET_WIDTH / 2)
X#define BULLET_HC			(BULLET_HEIGHT / 2)
X
X#define TINK_WIDTH			10
X#define TINK_HEIGHT			5
X
X#define TINK_WC				(TINK_WIDTH / 2)
X#define TINK_HC				(TINK_HEIGHT / 2)
X
X#define X2COL(col, x) 		(col = x / colWidth)
X#define Y2ROW(row, y) 		(row = y / rowHeight)
X
X#define BULLET_FRAME_RATE	5
X
X#define MAX_BULLETS			20	
X
X/* Should be the same */
X#define MAX_MOVING_BULLETS	10	
X#define MAX_TINKS			10	
X
X#define TINK_DELAY			100	
X
X/*
X *  Internal type declarations:
X */
X
X#if NeedFunctionPrototypes
Xstatic int 	ResetBulletStart(Display *display, Window window);
Xstatic void CheckTinks(Display *display, Window window);
Xstatic void AddTink(Display *display, Window window, int xpos);
Xstatic void ClearTinks(void);
Xstatic void UpdateBullet(Display *display, Window window);
Xstatic int	StartABullet(Display *display, Window window, int xpos);
Xstatic void ClearBullet(int i);
Xstatic void DrawTheTink(Display *display, Window window, int x, int y);
Xstatic void EraseTheTink(Display *display, Window window, int x, int y);
Xstatic void DrawBullet(Display *display, Window window, int i);
Xstatic int CheckForBulletCollision(Display *display, Window window, 
X	int x, int y);
Xstatic int CheckBallBulletCollision(Display *display, Window window, 
X	int bx, int by, int j);
X#else
Xstatic int 	ResetBulletStart();
Xstatic void CheckTinks();
Xstatic void AddTink();
Xstatic void ClearTinks();
Xstatic void UpdateBullet();
Xstatic int 	StartABullet();
Xstatic void ClearBullet();
Xstatic void DrawTheTink();
Xstatic void EraseTheTink();
Xstatic void DrawBullet();
Xstatic int CheckForBulletCollision();
Xstatic int CheckBallBulletCollision();
X#endif
X
Xstatic struct 
X{
X	int xpos;			/* x position of tink centre */
X	int	clearFrame;		/* Last frame to clear it */
X} tinks[MAX_TINKS];
X
Xstatic struct 
X{
X	int xpos;			/* x position of bullet */
X	int ypos;			/* y position of bullet */
X	int oldypos;		/* previous y position */
X	int dy;				/* Change in y positoon */
X} bullets[MAX_MOVING_BULLETS];
X
X/*
X *  Internal variable declarations:
X */
X
Xstatic Pixmap bulletPixmap, bulletMask;
Xstatic Pixmap tinkPixmap, tinkMask;
Xstatic int numBullets;
X
X#if NeedFunctionPrototypes
Xvoid InitialiseBullet(Display *display, Window window, Colormap colormap)
X#else
Xvoid InitialiseBullet(display, window, colormap)
X	Display *display;
X	Window window;
X	Colormap colormap;
X#endif
X{
X    XpmAttributes   attributes;
X	int		    XpmErrorStatus;
X
X    attributes.valuemask = XpmColormap;
X	attributes.colormap = colormap;
X
X	/* Create the xpm pixmap bullet */
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, bullet_xpm,
X		&bulletPixmap, &bulletMask, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBullet(bullet)");
X
X	/* Create the xpm pixmap tink for bullet */
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, tink_xpm,
X		&tinkPixmap, &tinkMask, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBullet(tink)");
X
X    /* Free the xpm pixmap attributes */
X	XpmFreeAttributes(&attributes);
X
X	SetNumberBullets(4);
X	ClearTinks();
X	ClearBullets();
X}
X
X#if NeedFunctionPrototypes
Xstatic void CheckTinks(Display *display, Window window)
X#else
Xstatic void CheckTinks(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int i;
X
X	/* Clear and tinks that need to be cleared */
X	for (i = 0; i < MAX_TINKS; i++)
X	{
X		/* Is this tink active */
X		if (tinks[i].xpos != -1)
X		{
X			/* Time to clear tink? */
X			if (frame >= tinks[i].clearFrame)
X			{
X				/* Clear the tink! */
X				EraseTheTink(display, window, tinks[i].xpos, 2);
X					
X				/* Free the tink up for another */
X				tinks[i].xpos = -1;
X				tinks[i].clearFrame = 0;
X			}
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void AddTink(Display *display, Window window, int xpos)
X#else
Xstatic void AddTink(display, window, xpos)
X	Display *display;
X	Window window;
X	int xpos;
X#endif
X{
X	int i;
X
X	/* Cycle through tinks and try to add one */
X	for (i = 0; i < MAX_TINKS; i++)
X	{
X		/* Is this tink free? */
X		if (tinks[i].xpos == -1)
X		{
X			/* Set the tink array position */
X			tinks[i].xpos = xpos;
X			tinks[i].clearFrame = frame + TINK_DELAY;
X
X			/* Draw the new found tink! */
X			DrawTheTink(display, window, xpos, 2);
X
X			return;
X		}
X	}
X
X	/* Full tink array - lots of shooting? */
X	WarningMessage("Cannot draw tink - tink array full.");
X}
X
X#if NeedFunctionPrototypes
Xstatic void ClearTinks(void)
X#else
Xstatic void ClearTinks()
X#endif
X{
X	int i;
X
X	/* Initialise tinks array to empty */
X	for (i = 0; i < MAX_TINKS; i++)
X	{
X		tinks[i].xpos = -1;
X		tinks[i].clearFrame = 0;
X	}
X}
X
X
X#if NeedFunctionPrototypes
Xstatic void UpdateBullet(Display *display, Window window)
X#else
Xstatic void UpdateBullet(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int i, j;
X	int row, col;
X	int ballX, ballY;
X	struct aBlock *blockP;
X
X	/* Obtain the position of the ball */
X	GetBallPosition(&ballX, &ballY, 0);
X
X	/* Draw all bullets that need updating */
X	for (i = 0; i < MAX_MOVING_BULLETS; i++)
X	{
X		/* Is this bullet active */
X		if (bullets[i].xpos != -1)
X		{
X			/* Update bullet position using dy value */	
X			bullets[i].ypos = bullets[i].oldypos + bullets[i].dy;
X
X			/* Has the bullet gone off the top edge */
X			if (bullets[i].ypos < -BULLET_HC)
X			{
X				/* Clear the bullet from the screen */
X				EraseTheBullet(display, window, 
X					bullets[i].xpos, bullets[i].oldypos);
X
X				/* Draw a tink on the top edge */
X				AddTink(display, window, bullets[i].xpos);
X
X				/* Free the bullet up for another */
X				ClearBullet(i);
X
X				continue;
X			}
X
X			if (mode == MODE_GAME)
X			{
X				for (j = 0; j < MAX_BALLS; j++)
X				{
X					if (balls[j].active == True)
X					{
X						/* Has the bullet killed the ball */
X						if (CheckBallBulletCollision(display, window, 
X							bullets[i].xpos, bullets[i].ypos, j))
X						{
X							/* Clear the bullet from the screen */
X							EraseTheBullet(display, window, 
X								bullets[i].xpos, bullets[i].oldypos);
X							ClearBullet(i);
X
X							/* Kill the ball off */
X							ClearBallNow(display, window, j);
X
X							/* Play the lovel ahhh pop sound for ball shot */
X							if (noSound == False) playSoundFile("ballshot", 50);
X							break;
X						}
X					}
X				}
X			}
X
X			/* Convert the new bullet pos to rows and cols for collision */
X			X2COL(col, bullets[i].xpos);
X			Y2ROW(row, bullets[i].ypos);
X
X			/* Pointer to the correct block we need - speed things up */
X			blockP = &blocks[row][col];
X
X			/* Check if the bullet has hit a brick or something */
X			if (CheckForBulletCollision(display, window, 
X				bullets[i].xpos, bullets[i].ypos) == True)
X			{
X				/* Clear the bullet from the screen */
X				EraseTheBullet(display, window, 
X					bullets[i].xpos, bullets[i].oldypos);
X
X				/* Switch on the type of block hit */
X				switch (blockP->blockType)
X				{
X					case COUNTER_BLK:
X						if (blockP->counterSlide == 0)
X						{
X							/* Counter has counted down to 0 so kill off */
X							DrawBlock(display, window, row, col, KILL_BLK);
X						}
X						else
X						{
X							/* Decrement counter block and draw new one */
X							blockP->counterSlide--;
X							DrawBlock(display, window, row, col, 
X								COUNTER_BLK);
X						}
X						break;
X
X					case HYPERSPACE_BLK:
X						DrawBlock(display, window, row, col, HYPERSPACE_BLK);
X						break;
X
X					case BLACK_BLK:
X						DrawBlock(display, window, row, col, BLACK_BLK);
X						break;
X
X					case REVERSE_BLK:		
X					case MGUN_BLK:		
X					case STICKY_BLK:		
X					case WALLOFF_BLK:		
X					case MULTIBALL_BLK:		
X					case DEATH_BLK:		
X					case PAD_EXPAND_BLK:		
X					case PAD_SHRINK_BLK:		
X						/* Shoot the block times to kill it */
X						blockP->counterSlide--;
X
X						if (blockP->counterSlide == 0)
X						{
X							/* Ok then a hit, explode that block */
X							DrawBlock(display, window, row, col, KILL_BLK);
X						}
X						else if (noSound == False)
X							playSoundFile("shootdeath", 70);
X						break;
X
X					default:
X						/* Ok then a hit, explode that block */
X						DrawBlock(display, window, row, col, KILL_BLK);
X						break;
X				}
X
X				/* Free the bullet up for another */
X				ClearBullet(i);
X			}
X			else
X				DrawBullet(display, window, i);
X
X			/* Keep track of old position */
X			bullets[i].oldypos = bullets[i].ypos;
X
X		}	/* Bullet active? */
X	}	/* For loop */
X}
X
X
X#if NeedFunctionPrototypes
Xstatic int StartABullet(Display *display, Window window, int xpos)
X#else
Xstatic int StartABullet(display, window, xpos)
X	Display *display;
X	Window window;
X	int xpos;
X#endif
X{
X	int i;
X
X	/* Cycle through bullets and try to add one */
X	for (i = 0; i < MAX_MOVING_BULLETS; i++)
X	{
X		/* Is this bullet free? */
X		if (bullets[i].xpos == -1)
X		{
X			/* Set the bullet array position */
X			bullets[i].xpos = xpos;
X
X			/* Get out of here */
X			return True;
X		}
X		
X		/* Break out as the machine gun is not active */
X		if (fastGun == False) return False;
X	}
X
X	/* Full moving bullet array - lots of shooting? */
X	WarningMessage("Cannot draw bullet - bullet array full.");
X
X	return False;
X}
X
X#if NeedFunctionPrototypes
Xstatic void ClearBullet(int i)
X#else
Xstatic void ClearBullet(i)
X	int i;
X#endif
X{
X	/* Setup the bullet entry */
X	bullets[i].xpos 			= -1;
X	bullets[i].ypos 			= BULLET_START_Y;
X	bullets[i].oldypos 			= BULLET_START_Y;
X	bullets[i].dy 				= BULLET_DY;
X}
X
X#if NeedFunctionPrototypes
Xvoid ClearBullets(void)
X#else
Xvoid ClearBullets()
X#endif
X{
X	int i;
X
X	/* Initialise bullets array to empty */
X	for (i = 0; i < MAX_MOVING_BULLETS; i++)
X		ClearBullet(i);
X}
X
X#if NeedFunctionPrototypes
Xvoid FreeBullet(Display *display)
X#else
Xvoid FreeBullet(display)
X	Display *display;
X#endif
X{
X	if (bulletPixmap)	XFreePixmap(display, bulletPixmap);
X 	if (bulletMask) 	XFreePixmap(display, bulletMask);
X
X	if (tinkPixmap)	XFreePixmap(display, tinkPixmap);
X 	if (tinkMask) 	XFreePixmap(display, tinkMask);
X}
X
X#if NeedFunctionPrototypes
Xvoid SetNumberBullets(int num)
X#else
Xvoid SetNumberBullets(num)
X	int num;
X#endif
X{
X	/* Set the number of bullets available */
X	numBullets = num;
X}
X
X#if NeedFunctionPrototypes
Xvoid IncNumberBullets(void)
X#else
Xvoid IncNumberBullets()
X#endif
X{
X	/* Increment the number of bullets */
X	numBullets++;
X
X	/* But don't give to many */
X	if (numBullets > MAX_BULLETS) 
X		numBullets = MAX_BULLETS;
X}
X
X#if NeedFunctionPrototypes
Xvoid DecNumberBullets(void)
X#else
Xvoid DecNumberBullets()
X#endif
X{
X	/* Decrement the number of bullets */
X	numBullets--;
X
X	/* But not to far */
X	if (numBullets < 0) 
X		numBullets = 0;
X}
X
X#if NeedFunctionPrototypes
Xint GetNumberBullets(void)
X#else
Xint GetNumberBullets()
X#endif
X{
X	assert(numBullets >= 0);
X
X	/* How many bullets do I have */
X	return numBullets;
X}
X
X#if NeedFunctionPrototypes
Xvoid shootBullet(Display *display, Window window)
X#else
Xvoid shootBullet(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	/* Only shoot if no bullet is active and bullets and ball active */
X	if ((GetNumberBullets() > 0) && (IsBallWaiting() == False))
X	{
X		/* Reset the bullet to the starting possy to go forward */
X		if (ResetBulletStart(display, window) == True)
X		{
X			/* Remove a bullet from the ammunition */
X			DeleteABullet(display);
X
X			/* Play a shooting sound */
X			if (noSound == False) playSoundFile("shoot", 50);
X		}
X	}
X	else if (GetNumberBullets() == 0)
X	{
X		/* Play an trigger clicking sound */
X		if (noSound == False) playSoundFile("click", 100);
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid EraseTheBullet(Display *display, Window window, int x, int y)
X#else
Xvoid EraseTheBullet(display, window, x, y)
X	Display *display;
X	Window window;
X	int x;
X	int y;
X#endif
X{
X	/* Erase the bullet pixmap from the window */
X    XClearArea(display, window, x - BULLET_WC, y - BULLET_HC, 
X		BULLET_WIDTH, BULLET_HEIGHT, False);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DrawTheTink(Display *display, Window window, int x, int y)
X#else
Xstatic void DrawTheTink(display, window, x, y)
X	Display *display;
X	Window window;
X	int x;
X	int y;
X#endif
X{
X	/* Draw the tink pixmap into the window */
X    RenderShape(display, window, tinkPixmap, tinkMask,
X		x - TINK_WC, y - TINK_HC, TINK_WIDTH, TINK_HEIGHT, False);
X}
X
X#if NeedFunctionPrototypes
Xstatic void EraseTheTink(Display *display, Window window, int x, int y)
X#else
Xstatic void EraseTheTink(display, window, x, y)
X	Display *display;
X	Window window;
X	int x;
X	int y;
X#endif
X{
X	/* Erase the tink pixmap from the window */
X    XClearArea(display, window, x - TINK_WC, y - TINK_HC, 
X		TINK_WIDTH, TINK_HEIGHT, False);
X}
X
X#if NeedFunctionPrototypes
Xvoid DrawTheBullet(Display *display, Window window, int x, int y)
X#else
Xvoid DrawTheBullet(display, window, x, y)
X	Display *display;
X	Window window;
X	int x;
X	int y;
X#endif
X{
X	/* Draw the bullet pixmap into the window */
X    RenderShape(display, window, bulletPixmap, bulletMask,
X		x - BULLET_WC, y - BULLET_HC, BULLET_WIDTH, BULLET_HEIGHT, False);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DrawBullet(Display *display, Window window, int i)
X#else
Xstatic void DrawBullet(display, window, i)
X	Display *display;
X	Window window;
X	int i;
X#endif
X{
X	/* Clear the window of the bullet in the old position */
X	XClearArea(display, window, bullets[i].xpos - BULLET_WC, 
X		bullets[i].oldypos - BULLET_HC, BULLET_WIDTH, BULLET_HEIGHT, False);
X
X	/* Now draw the new bullet in the new position */
X	DrawTheBullet(display, window, bullets[i].xpos, bullets[i].ypos);
X}
X
X#if NeedFunctionPrototypes
Xstatic int CheckBallBulletCollision(Display *display, Window window, 
X	int bx, int by, int j)
X#else
Xstatic int CheckBallBulletCollision(display, window, bx, by, j)
X	Display *display;
X	Window window;
X	int bx;
X	int by;
X	int j;
X#endif
X{
X	int ballX, ballY;
X
X	GetBallPosition(&ballX, &ballY, j);
X
X    /* Check if any part of the bullets coords is inside the balls box */
X    if (((bx + BULLET_WC) >= (ballX - BALL_WC)) &&
X   	    ((bx - BULLET_WC) <= (ballX + BALL_WC)) &&
X        ((by + BULLET_HC) >= (ballY - BALL_HC)) &&
X        ((by - BULLET_HC) <= (ballY + BALL_HC)))
X		return True;
X	else
X		return False;
X}
X
X#if NeedFunctionPrototypes
Xstatic int CheckForBulletCollision(Display *display, Window window, 
X	int x, int y)
X#else
Xstatic int CheckForBulletCollision(display, window, x, y)
X	Display *display;
X	Window window;
X	int x;
X	int y;
X#endif
X{
X    /* Check for bullet to block collision */
X    int row, col;
X    struct aBlock *blockP;
X
X    /* Get the row and col for block where bullet is */
X    X2COL(col, x);
X    Y2ROW(row, y);
X
X    blockP = &blocks[row][col];
X
X    /* If blocks is occupied then check for collision */
X    if (blockP->occupied == 1 && blockP->exploding == False)
X    {
X        /* Check if x adjusted for bullet width is in block region */
X        if (((x + BULLET_WC) > blockP->x) &&
X          ((x - BULLET_WC) < (blockP->x + blockP->width)))
X        {
X            if (((y + BULLET_HC) > blockP->y) &&
X              ((y - BULLET_HC) < (blockP->y + blockP->height)))
X            {
X                /* Collision */
X                return True;
X            }
X        }
X    }
X
X    /* No collision if reached here */
X    return False;
X}
X
X#if NeedFunctionPrototypes
Xstatic int ResetBulletStart(Display *display, Window window)
X#else
Xstatic int ResetBulletStart(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	/* Start a bullet on the way if possible */
X	return StartABullet(display, window, paddlePos);
X}
X
X#if NeedFunctionPrototypes
Xvoid HandleBulletMode(Display *display, Window window)
X#else
Xvoid HandleBulletMode(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	/* Update all the bullets that may be moving */
X	if ((frame % BULLET_FRAME_RATE) == 0)
X		UpdateBullet(display, window);
X
X	/* Clear any tinks that are due to be cleared */
X	CheckTinks(display, window);
X}
X
END_OF_FILE
if test 16237 -ne `wc -c <'gun.c'`; then
    echo shar: \"'gun.c'\" unpacked with wrong size!
fi
# end of 'gun.c'
fi
if test -f 'include/audio.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/audio.h'\"
else
echo shar: Extracting \"'include/audio.h'\" \(605 characters\)
sed "s/^X//" >'include/audio.h' <<'END_OF_FILE'
X#ifndef _AUDIO_H_
X#define _AUDIO_H_
X
X#include "copyright.h"
X
X/*
X *  Dependencies on other include files:
X */
X
X#include <X11/Xlib.h>
X
X/*
X *  Constants and macros:
X */
X
X#define SBUF_SIZE	32
X
X/*
X *  Type declarations:
X */
X
X/*
X *  Function prototypes:
X */
X
X#if NeedFunctionPrototypes
Xint	 SetUpAudioSystem(Display *display);
Xvoid FreeAudioSystem(void);
Xvoid playSoundFile(char *filename, int volume);
Xvoid audioDeviceEvents(void);
Xvoid SetMaximumVolume(int Volume);
X#else
Xvoid SetMaximumVolume();
Xvoid audioDeviceEvents();
Xint  SetUpAudioSystem();
Xvoid FreeAudioSystem();
Xvoid playSoundFile();
X#endif
X
X#endif
END_OF_FILE
if test 605 -ne `wc -c <'include/audio.h'`; then
    echo shar: \"'include/audio.h'\" unpacked with wrong size!
fi
# end of 'include/audio.h'
fi
echo shar: End of archive 19 \(of 30\).
cp /dev/null ark19isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    echo "Now execute sdecode.sh to build files."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
