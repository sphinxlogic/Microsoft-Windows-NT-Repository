Path: uunet!news.tek.com!news.cna.tek.com!not-for-mail
From: billr@saab.cna.tek.com (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i061:  xboing - blockout variant with color and sound for X, Part02/30
Date: 30 Aug 1993 10:26:58 -0700
Organization: Tektronix, Inc., Redmond, OR
Lines: 1995
Approved: billr@saab.CNA.TEK.COM
Message-ID: <25td92$hst@saab.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1861

Submitted-by: jck@kimba.catt.citri.edu.au (Justin Kibell)
Posting-number: Volume 18, Issue 61
Archive-name: xboing/part02
Environment: X11, Xlib, XPM



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 30)."
# Contents:  blocks.c
# Wrapped by billr@saab on Mon Aug 30 09:14:22 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'blocks.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'blocks.c'\"
else
echo shar: Extracting \"'blocks.c'\" \(55711 characters\)
sed "s/^X//" >'blocks.c' <<'END_OF_FILE'
X#include "include/copyright.h"
X
X/*
X *  Include file dependencies:
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <stddef.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#include <xpm.h>
X
X#include "bitmaps/blueblock.xpm"
X#include "bitmaps/exblueblock1.xpm"
X#include "bitmaps/exblueblock2.xpm"
X#include "bitmaps/exblueblock3.xpm"
X
X#include "bitmaps/redblock.xpm"
X#include "bitmaps/exredblock1.xpm"
X#include "bitmaps/exredblock2.xpm"
X#include "bitmaps/exredblock3.xpm"
X
X#include "bitmaps/yellowblock.xpm"
X#include "bitmaps/exyellowblock1.xpm"
X#include "bitmaps/exyellowblock2.xpm"
X#include "bitmaps/exyellowblock3.xpm"
X
X#include "bitmaps/greenblock.xpm"
X#include "bitmaps/exgreenblock1.xpm"
X#include "bitmaps/exgreenblock2.xpm"
X#include "bitmaps/exgreenblock3.xpm"
X
X#include "bitmaps/tanblock.xpm"
X#include "bitmaps/extanblock1.xpm"
X#include "bitmaps/extanblock2.xpm"
X#include "bitmaps/extanblock3.xpm"
X
X#include "bitmaps/purpleblock.xpm"
X#include "bitmaps/expurpleblock1.xpm"
X#include "bitmaps/expurpleblock2.xpm"
X#include "bitmaps/expurpleblock3.xpm"
X
X#include "bitmaps/bombblock.xpm"
X#include "bitmaps/exbombblock1.xpm"
X#include "bitmaps/exbombblock2.xpm"
X#include "bitmaps/exbombblock3.xpm"
X
X#include "bitmaps/counterblock1.xpm"
X#include "bitmaps/counterblock2.xpm"
X#include "bitmaps/counterblock3.xpm"
X#include "bitmaps/counterblock4.xpm"
X#include "bitmaps/counterblock5.xpm"
X#include "bitmaps/counterblock.xpm"
X#include "bitmaps/excounterblock1.xpm"
X#include "bitmaps/excounterblock2.xpm"
X#include "bitmaps/excounterblock3.xpm"
X
X#include "bitmaps/blackblock.xpm"
X#include "bitmaps/reverse.xpm"
X#include "bitmaps/hyperspace.xpm"
X#include "bitmaps/machinegun.xpm"
X#include "bitmaps/walloff.xpm"
X#include "bitmaps/multiballblock.xpm"
X#include "bitmaps/stickyblock.xpm"
X#include "bitmaps/paddleshrink.xpm"
X#include "bitmaps/paddleexpand.xpm"
X
X#include "bitmaps/xtraball.xpm"
X#include "bitmaps/xtraball2.xpm"
X
X#include "bitmaps/x2bonus1.xpm"
X#include "bitmaps/x2bonus2.xpm"
X#include "bitmaps/x2bonus3.xpm"
X#include "bitmaps/x2bonus4.xpm"
X
X#include "bitmaps/x4bonus1.xpm"
X#include "bitmaps/x4bonus2.xpm"
X#include "bitmaps/x4bonus3.xpm"
X#include "bitmaps/x4bonus4.xpm"
X
X#include "bitmaps/bonus1.xpm"
X#include "bitmaps/bonus2.xpm"
X#include "bitmaps/bonus3.xpm"
X#include "bitmaps/bonus4.xpm"
X
X#include "bitmaps/exx2bonus1.xpm"
X#include "bitmaps/exx2bonus2.xpm"
X#include "bitmaps/exx2bonus3.xpm"
X
X#include "bitmaps/death1.xpm"
X#include "bitmaps/death2.xpm"
X#include "bitmaps/death3.xpm"
X#include "bitmaps/death4.xpm"
X#include "bitmaps/death5.xpm"
X
X#include "bitmaps/exdeath1.xpm"
X#include "bitmaps/exdeath2.xpm"
X#include "bitmaps/exdeath3.xpm"
X#include "bitmaps/exdeath4.xpm"
X
X#include "include/audio.h"
X#include "include/misc.h"
X#include "include/mess.h"
X#include "include/gun.h"
X#include "include/error.h"
X#include "include/bonus.h"
X#include "include/special.h"
X#include "include/main.h"
X#include "include/init.h"
X#include "include/stage.h"
X#include "include/ball.h"
X#include "include/score.h"
X#include "include/paddle.h"
X#include "include/level.h"
X#include "include/sfx.h"
X
X#include "include/blocks.h"
X
X/*
X *  Internal macro definitions:
X */
X
X#define EXPLODE_DELAY				10	
X#define BONUS_DELAY					150	
X#define BONUS_LENGTH				2000
X#define NUMBER_OF_BULLETS_NEW_LEVEL 4
X#define DEATH_DELAY1				100
X#define DEATH_DELAY2				700
X#define EXTRABALL_DELAY				300
X#define RANDOM_DELAY				500
X
X/*
X *  Internal type declarations:
X */
X
X#if NeedFunctionPrototypes
Xstatic void ClearBlock(int row, int col);
Xstatic void CalculateBlockGeometry(int row, int col);
Xstatic void SetBlockUpForExplosion(int row, int col, int frame);
X#else
Xstatic void SetBlockUpForExplosion();
Xstatic void ClearBlock();
Xstatic void CalculateBlockGeometry();
X#endif
X
X/*
X *  Internal variable declarations:
X */
X
Xstatic Pixmap	exredblock[3],		exredblockM[3];
Xstatic Pixmap	extanblock[3],		extanblockM[3];
Xstatic Pixmap	exyellowblock[3],	exyellowblockM[3];
Xstatic Pixmap	exgreenblock[3],	exgreenblockM[3];
Xstatic Pixmap	exblueblock[3],		exblueblockM[3];
Xstatic Pixmap	expurpleblock[3],	expurpleblockM[3];
Xstatic Pixmap	exbombblock[3],		exbombblockM[3];
Xstatic Pixmap	excounterblock[3],	excounterblockM[3];
Xstatic Pixmap	exx2bonus[3],		exx2bonusM[3];
Xstatic Pixmap	x2bonus[4],			x2bonusM[4];
Xstatic Pixmap	x4bonus[4],			x4bonusM[4];
Xstatic Pixmap	Bonus[4],			BonusM[4];
Xstatic Pixmap	death[5],			deathM[5];
Xstatic Pixmap	exdeath[5],			exdeathM[5];
Xstatic Pixmap	counterblock[6],	counterblockM[6];
Xstatic Pixmap	extraball[3],		extraballM[3];
X
Xstatic Pixmap	redblock, greenblock, blueblock, yellowblock, purpleblock;	
Xstatic Pixmap	tanblock, blackblock, bombblock, revblock, 	hyperblock;
Xstatic Pixmap	mgunblock, walloffblock, multiball, sticky, paddleshrink;
Xstatic Pixmap	paddleexpand;
X
Xstatic Pixmap	redblockM, greenblockM, blueblockM, yellowblockM, purpleblockM;	
Xstatic Pixmap	tanblockM, blackblockM, bombblockM, revblockM, 	hyperblockM;
Xstatic Pixmap	mgunblockM, walloffblockM, multiballM, stickyM, paddleshrinkM;
Xstatic Pixmap	paddleexpandM;
X
Xstruct aBlock 	blocks[MAX_ROW][MAX_COL];
Xint			blocksExploding = 0;
Xint			rowHeight;
Xint			colWidth;
X
X#if NeedFunctionPrototypes
Xvoid InitialiseBlocks(Display *display, Window window, Colormap colormap)
X#else
Xvoid InitialiseBlocks(display, window, colormap)
X	Display *display;
X	Window window;
X	Colormap colormap;
X#endif
X{
X	XpmAttributes   attributes;
X	int 			XpmErrorStatus;
X
X	attributes.valuemask = XpmColormap;
X	attributes.colormap = colormap;
X
X	/* Create all xpm pixmap blocks from the files */
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, redblock_xpm, 
X		&redblock, &redblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(red)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, blueblock_xpm, 
X		&blueblock, &blueblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(blue)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, greenblock_xpm, 
X		&greenblock, &greenblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(green)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, yellowblock_xpm, 
X		&yellowblock, &yellowblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(yellow)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, tanblock_xpm, 
X		&tanblock, &tanblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(tan)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, purpleblock_xpm, 
X		&purpleblock, &purpleblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(purple)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, blackblock_xpm, 
X		&blackblock, &blackblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(wall)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, bombblock_xpm, 
X		&bombblock, &bombblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(bomb)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, reverse_xpm, 
X		&revblock, &revblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(reverse)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, hyperspace_xpm, 
X		&hyperblock, &hyperblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(hyperspace)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, machinegun_xpm, 
X		&mgunblock, &mgunblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(machinegun)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, walloff_xpm, 
X		&walloffblock, &walloffblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(walloff)");
X
X	/* Explosion for yellow block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exyellowblock1_xpm, &exyellowblock[0], &exyellowblockM[0], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exyellow)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exyellowblock2_xpm, &exyellowblock[1], &exyellowblockM[1], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exyellow)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exyellowblock3_xpm, &exyellowblock[2], &exyellowblockM[2], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exyellow)");
X
X	/* Explosion for red block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, exredblock1_xpm, 
X		&exredblock[0], &exredblockM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exred)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, exredblock2_xpm, 
X		&exredblock[1], &exredblockM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exred)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, exredblock3_xpm, 
X		&exredblock[2], &exredblockM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exred)");
X
X	/* Explosion for green block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exgreenblock1_xpm, &exgreenblock[0], &exgreenblockM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exgreen)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exgreenblock2_xpm, &exgreenblock[1], &exgreenblockM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exgreen)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exgreenblock3_xpm, &exgreenblock[2], &exgreenblockM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exgreen)");
X
X	/* Explosion for blue block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exblueblock1_xpm, &exblueblock[0], &exblueblockM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exblue)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exblueblock2_xpm, &exblueblock[1], &exblueblockM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exblue)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exblueblock3_xpm, &exblueblock[2], &exblueblockM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exblue)");
X
X	/* Explosion for tan block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		extanblock1_xpm, &extanblock[0], &extanblockM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(extan)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		extanblock2_xpm, &extanblock[1], &extanblockM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(extan)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		extanblock3_xpm, &extanblock[2], &extanblockM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(extan)");
X
X	/* Explosion for purple block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		expurpleblock1_xpm, &expurpleblock[0], &expurpleblockM[0], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(expurple)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		expurpleblock2_xpm, &expurpleblock[1], &expurpleblockM[1], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(expurple)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		expurpleblock3_xpm, &expurpleblock[2], &expurpleblockM[2], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(expurple)");
X
X	/* Explosion for bomb block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exbombblock1_xpm, &exbombblock[0], &exbombblockM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exbomb)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exbombblock2_xpm, &exbombblock[1], &exbombblockM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exbomb)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exbombblock3_xpm, &exbombblock[2], &exbombblockM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exbomb)");
X
X	/* Explosion for counter block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		excounterblock1_xpm, &excounterblock[0], &excounterblockM[0], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(excounter)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		excounterblock2_xpm, &excounterblock[1], &excounterblockM[1], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(excounter)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		excounterblock3_xpm, &excounterblock[2], &excounterblockM[2], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(excounter)");
X
X	/* countdown for counter block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		counterblock_xpm, &counterblock[0], &counterblockM[0], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(counter0)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		counterblock1_xpm, &counterblock[1], &counterblockM[1], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(counter1)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		counterblock2_xpm, &counterblock[2], &counterblockM[2], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(counter2)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		counterblock3_xpm, &counterblock[3], &counterblockM[3], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(counter3)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		counterblock4_xpm, &counterblock[4], &counterblockM[4], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(counter4)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		counterblock5_xpm, &counterblock[5], &counterblockM[5], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(counter5)");
X
X	/* Bonus block stuff */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x2bonus1_xpm, &x2bonus[0], &x2bonusM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x2bonus1)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x2bonus2_xpm, &x2bonus[1], &x2bonusM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x2bonus2)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x2bonus3_xpm, &x2bonus[2], &x2bonusM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x2bonus3)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x2bonus4_xpm, &x2bonus[3], &x2bonusM[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x2bonus4)");
X
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x4bonus1_xpm, &x4bonus[0], &x4bonusM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x4bonus1)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x4bonus2_xpm, &x4bonus[1], &x4bonusM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x4bonus2)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x4bonus3_xpm, &x4bonus[2], &x4bonusM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x4bonus3)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x4bonus4_xpm, &x4bonus[3], &x4bonusM[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x4bonus4)");
X
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		bonus1_xpm, &Bonus[0], &BonusM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(bonus1)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		bonus2_xpm, &Bonus[1], &BonusM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(bonus2)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		bonus3_xpm, &Bonus[2], &BonusM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(bonus3)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		bonus4_xpm, &Bonus[3], &BonusM[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(bonus4)");
X
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exx2bonus1_xpm, &exx2bonus[0], &exx2bonusM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exbonus)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exx2bonus2_xpm, &exx2bonus[1], &exx2bonusM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exbonus)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exx2bonus3_xpm, &exx2bonus[2], &exx2bonusM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exbonus)");
X
X	/* Death block initialisation */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		death1_xpm, &death[0], &deathM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(death)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		death2_xpm, &death[1], &deathM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(death)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		death3_xpm, &death[2], &deathM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(death)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		death4_xpm, &death[3], &deathM[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(death)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		death5_xpm, &death[4], &deathM[4], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(death)");
X
X	/* Death block explosion init */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exdeath1_xpm, &exdeath[0], &exdeathM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exdeath)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exdeath2_xpm, &exdeath[1], &exdeathM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exdeath)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exdeath3_xpm, &exdeath[2], &exdeathM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exdeath)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exdeath4_xpm, &exdeath[3], &exdeathM[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exdeath)");
X
X	/* Extra balll pixmaps */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		xtraball_xpm, &extraball[0], &extraballM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(extraball)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		xtraball2_xpm, &extraball[1], &extraballM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(extraball)");
X
X	/* Multiple ball pixmap */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		multiballblock_xpm, &multiball, &multiballM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(multiball)");
X
X	/* Sticky block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		stickyblock_xpm, &sticky, &stickyM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(sticky)");
X
X	/* paddle shrink and expand block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		paddleshrink_xpm, &paddleshrink, &paddleshrinkM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(paddleshrink)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		paddleexpand_xpm, &paddleexpand, &paddleexpandM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(paddleexpand)");
X
X	/* Free the xpm pixmap attributes */
X	XpmFreeAttributes(&attributes);
X}
X
X#if NeedFunctionPrototypes
Xvoid PlaySoundForBlock(int type)
X#else
Xvoid PlaySoundForBlock(type)
X	int type;
X#endif
X{
X	/* If no sound the no sound */
X	if (noSound == True) return;
X
X	/* Play the sound effect for the block being hit */
X	switch (type)
X	{
X		case BOMB_BLK:		
X			playSoundFile("bomb", 50);
X			break;
X
X		case BULLET_BLK:
X			playSoundFile("ammo", 50);
X			break;
X
X		case RED_BLK:
X		case GREEN_BLK:		
X		case BLUE_BLK:	
X		case TAN_BLK:
X		case PURPLE_BLK:	
X		case YELLOW_BLK:
X		case COUNTER_BLK:
X		case RANDOM_BLK:
X			playSoundFile("touch", 100);
X			break;
X
X		case BONUSX2_BLK:	
X		case BONUSX4_BLK:	
X		case BONUS_BLK:	
X		case MGUN_BLK:	
X		case EXTRABALL_BLK:	
X		case WALLOFF_BLK:	
X		case REVERSE_BLK:	
X		case MULTIBALL_BLK:
X		case STICKY_BLK:
X		case PAD_SHRINK_BLK:
X		case PAD_EXPAND_BLK:
X			playSoundFile("bonus", 50);
X			break;
X
X		case DEATH_BLK:	
X			playSoundFile("evillaugh", 100);
X			break;
X
X		case BLACK_BLK:		
X			playSoundFile("touch", 50);
X			break;
X
X		case HYPERSPACE_BLK:
X			playSoundFile("hyperspace", 70);
X			break;
X
X		case KILL_BLK:
X			ErrorMessage("Error: kill block type in PlaySoundForBlock()");
X			break;
X
X		default:
X			ErrorMessage("Error: Unknown block type in PlaySoundForBlock()");
X			break;
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid ExplodeBlockType(Display *display, Window window, int x, int y, 
X	int type, int slide)
X#else
Xvoid ExplodeBlockType(display, window, x, y, type, slide)
X	Display *display;
X	Window window;
X	int x;
X	int y; 
X	int type;
X	int slide;
X#endif
X{
X	/* Draw a frame from the blocks explode animation */
X	switch (type)
X	{
X		case BOMB_BLK:		/* Draw the bomb block explosion slide */
X			RenderShape(display, window, exbombblock[slide], 
X				exbombblockM[slide], x, y, 30, 30, True);
X			break;
X
X		case MULTIBALL_BLK:
X		case RED_BLK:		/* Draw a red block explosion slide */
X			RenderShape(display, window, exredblock[slide], 
X				exredblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case GREEN_BLK:		/* Draw a green block explosion slide */
X			RenderShape(display, window, exgreenblock[slide], 
X				exgreenblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case BLUE_BLK:		/* Draw a blue block explosion slide */
X			RenderShape(display, window, exblueblock[slide], 
X				exblueblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case TAN_BLK:		/* Draw a tan block explosion slide */
X			RenderShape(display, window, extanblock[slide], 
X				extanblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case PURPLE_BLK:	/* Draw a purple block explosion slide */
X			RenderShape(display, window, expurpleblock[slide], 
X				expurpleblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case BULLET_BLK:	/* Draw a bullet block explosion slide */
X		case YELLOW_BLK:	/* Draw a yellow block explosion slide */
X			RenderShape(display, window, exyellowblock[slide], 
X				exyellowblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case COUNTER_BLK:	/* Draw a counter block explosion slide */
X			RenderShape(display, window, excounterblock[slide], 
X				excounterblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case BONUS_BLK:		/* Draw a bonus coin block explosion slide */
X		case BONUSX4_BLK:	/* Draw a bonus x2 oin block explosion slide */
X		case BONUSX2_BLK:	/* Draw a bonus x4 coin block explosion slide */
X			RenderShape(display, window, exx2bonus[slide], 
X				exx2bonusM[slide], x, y, 27, 27, True);
X			break;
X
X		case DEATH_BLK:		/* Draw a pirate death block explosion slide */
X			RenderShape(display, window, exdeath[slide], 
X				exdeathM[slide], x, y, 30, 30, True);
X			break;
X
X		case BLACK_BLK:		/* The wall doesn't have any animation */
X		case REVERSE_BLK:	/* The reverse doesn't have any animation */
X		case HYPERSPACE_BLK:/* The hyperspace doesn't have any animation */
X		case EXTRABALL_BLK:	/* The extra ball doesn't have any animation */
X		case MGUN_BLK:		/* The machine gun doesn't have any animation */
X		case WALLOFF_BLK:	/* The wall off doesn't have any animation */
X		case STICKY_BLK:	/* No animation for sticky block either */
X		case PAD_SHRINK_BLK:
X		case PAD_EXPAND_BLK:
X			break;
X
X			break;
X
X		default:
X			ErrorMessage("Error: Unknown block type in ExplodeBlockType()");
X			break;
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid AddBonusBlock(Display *display, Window window, int *row, int *col, 
X	int type)
X#else
Xvoid AddBonusBlock(display, window, row, col, type)
X	Display *display;
X	Window window;
X	int *row;
X	int *col;
X	int type;
X#endif
X{
X	int r, c;
X	struct aBlock *blockP;
X
X	/* Give me a new random block position */
X	r = rand() % (MAX_ROW - 4);
X	c = rand() % MAX_COL;
X
X	/* Pointer to the correct block we need - speed things up */
X	blockP = &blocks[r][c];
X
X	/* Add a bonus coin in this block only if it isn't occupied and 
X	 * it isn't exploding.
X	 */
X	if ((blockP->occupied == False) && (blockP->explodeStartFrame == 0))
X	{
X		AddNewBlock(display, window, r, c, type, 0);
X		bonusBlock = True;
X
X		/* Setup the block structure for new block */
X		blockP->nextFrame 		= frame + BONUS_DELAY;
X		blockP->lastFrame 		= frame + BONUS_LENGTH;
X		blockP->bonusSlide 		= 3;
X
X		/* Return the new bonus row & coloumn position */
X		*row = r; *col = c;
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic int GetRandomType(void)
X#else
Xstatic int GetRandomType()
X#endif
X{
X	/* This function will return a random new block block type */
X	switch (rand() % 7)
X	{
X		case 0:
X			return RED_BLK;
X
X		case 1:
X			return BLUE_BLK;
X
X		case 2:
X			return GREEN_BLK;
X
X		case 3:
X			return TAN_BLK;
X
X		case 4:
X			return YELLOW_BLK;
X
X		case 5:
X			return PURPLE_BLK;
X
X		case 6:
X			return BULLET_BLK;
X	}
X
X	/* Shouldn't get here but it stops warnings on compiler */
X	return YELLOW_BLK;
X}
X
X#if NeedFunctionPrototypes
Xvoid HandlePendingBonuses(Display *display, Window window, int type, 
X	int r, int c)
X#else
Xvoid HandlePendingBonuses(display, window, type, r, c)
X	Display *display;
X	Window window;
X	int type;
X	int r, c;
X#endif
X{
X	struct aBlock *blockP;
X
X	blockP = &blocks[r][c];
X
X	if (blockP->nextFrame == frame) 
X	{
X		if (frame <= blockP->lastFrame)
X		{
X			/* Advance to the next frame of animation */
X			DrawTheBlock(display, window, 
X				blockP->x, blockP->y, 
X				type, blockP->bonusSlide);
X
X				blockP->nextFrame = frame + BONUS_DELAY;
X				blockP->bonusSlide--;
X
X				if (blockP->bonusSlide < 0)
X				blockP->bonusSlide = 3;
X		}
X		else
X		{
X			/* Kill off bonus block */
X			bonusBlock = False;
X			blockP->occupied = False;
X			XClearArea(display, window, 
X				blockP->x, blockP->y,
X				blockP->width, blockP->height, 
X				False);
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid HandlePendingAnimations(Display *display, Window window)
X#else
Xvoid HandlePendingAnimations(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int r, c;
X	struct aBlock *blockP;
X
X	/* Cycle through all rows and columns and update any animations that
X	 * need to be done every frame. ie: bonus etc
X	 */
X	for (r = 0; r < MAX_ROW; r++)
X	{
X		for (c = 0; c < MAX_COL; c++)
X		{
X			blockP = &blocks[r][c];
X
X			/* Only bother if the block is occupied! */
X			if (blockP->occupied == True) 
X			{
X				switch (blockP->blockType)
X				{
X					case BONUS_BLK:	/* Bonus coin symbol */
X						HandlePendingBonuses(display, window, BONUS_BLK, r, c);
X						break;
X
X					case BONUSX2_BLK:	/* Bonus x2 coin symbol */
X						HandlePendingBonuses(display, window, BONUSX2_BLK, r,c);
X						break;
X
X					case BONUSX4_BLK:	/* Bonus x4 coin symbol */
X						HandlePendingBonuses(display, window, BONUSX4_BLK, r,c);
X						break;
X
X					case DEATH_BLK:	/* Death block animation */
X						if (blockP->nextFrame == frame) 
X						{
X							/* Advance to the next frame of animation */
X							DrawTheBlock(display, window, 
X								blockP->x, blockP->y, 
X								DEATH_BLK, blockP->bonusSlide);
X
X							blockP->nextFrame = frame + DEATH_DELAY1;
X							blockP->bonusSlide++;
X
X							/* Have the delay bit between winks */
X							if (blockP->bonusSlide > 4)
X							{
X								blockP->bonusSlide = 0;
X								blockP->nextFrame = frame + DEATH_DELAY2;
X								DrawTheBlock(display, window, 
X									blockP->x, blockP->y, 
X									DEATH_BLK, blockP->bonusSlide);
X							}
X						}
X						break;
X
X					case EXTRABALL_BLK:	/* extra ball block animation */
X						if (blockP->nextFrame == frame) 
X						{
X							/* Advance to the next frame of animation */
X							DrawTheBlock(display, window, 
X								blockP->x, blockP->y, 
X								EXTRABALL_BLK, blockP->bonusSlide);
X
X							blockP->nextFrame = frame + EXTRABALL_DELAY;
X							blockP->bonusSlide++;
X
X							/* Have the delay bit between flashes */
X							if (blockP->bonusSlide > 1)
X								blockP->bonusSlide = 0;
X						}
X						break;
X				}
X
X				/* If it is a random block then change? */
X				if (blockP->random == True)
X				{
X					if (blockP->nextFrame == frame) 
X					{
X						/* Change the block to a new block block. We should
X						 * be allright in just changing the blocktype etc.
X						 * as the blocks are all the same .
X						 */
X						blockP->blockType = GetRandomType();
X						blockP->bonusSlide = 0;
X
X						DrawTheBlock(display, window, 
X							blockP->x, blockP->y, 
X							blockP->blockType, blockP->bonusSlide);
X
X						blockP->nextFrame = 
X							frame + (rand() % RANDOM_DELAY) + 300;
X					}	
X				}
X			}
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid ExplodeBlocksPending(Display *display, Window window)
X#else
Xvoid ExplodeBlocksPending(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int r, c, x, y, type, i;
X	struct aBlock *blockP;
X	char str[50];
X
X	/* If none are exploding then bug out */
X	if (blocksExploding == 0) return;
X
X	/* Cycle through all blocks exploding pending animation blocks */
X	for (r = 0; r < MAX_ROW; r++)
X	{
X		for (c = 0; c < MAX_COL; c++)
X		{
X			/* Get the pointer to the block we need */
X			blockP = &blocks[r][c];
X
X			/* Will be non-zero if animation is required */
X			if (blockP->explodeStartFrame)
X			{
X				/* Is it time to explode this frame */
X				if (blockP->explodeNextFrame == frame) 
X				{
X					x = blockP->x;
X					y = blockP->y;
X					type = blockP->blockType;
X
X					/* Switch on slide of animation */
X					switch (blockP->explodeSlide)
X					{
X						case 1:	/* First frame of animation */
X							ExplodeBlockType(display, window, x, y, type, 0);
X							blockP->explodeNextFrame =
X								blockP->explodeStartFrame;
X							break;
X	
X						case 2:	/* Second frame of animation */
X							ExplodeBlockType(display, window, x, y, type, 1);
X							break;
X	
X						case 3:	/* Third frame of animation */
X							ExplodeBlockType(display, window, x, y, type, 2);
X							break;
X	
X						case 4:	/* Last frame of animation  - clear */
X							XClearArea(display, window, x, y, 
X								blockP->width, 
X								blockP->height, False);
X							break;
X					}
X	
X					/* procede to next frame in animation */
X					blockP->explodeSlide++;
X					blockP->explodeNextFrame += EXPLODE_DELAY;
X	
X					/* last frame so clean up animation and block */
X					if (blockP->explodeSlide > 4)
X					{
X						blocksExploding--;
X						blockP->occupied = 0;
X						blockP->exploding = False;
X
X						AddToScore((u_long) blockP->hitPoints);
X						DisplayScore(display, scoreWindow, score);
X
X						switch (blockP->blockType)
X						{
X							case BLACK_BLK:
X							case PAD_SHRINK_BLK:
X							case PAD_EXPAND_BLK:
X								break;
X
X							case BOMB_BLK:
X								/* Explode all the ones around it */
X								SetBlockUpForExplosion(r+1, c, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r, c+1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r-1, c, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r, c-1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r-1, c-1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r-1, c+1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r+1, c-1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r+1, c+1, 
X									frame + EXPLODE_DELAY);
X
X								/* Special effect where screen shakes 
X								 * during explosion 
X								 */
X								SetSfxEndFrame(frame + 70);
X								changeSfxMode(SFX_SHAKE);
X								break;
X
X							case BULLET_BLK:
X								SetCurrentMessage(display, messWindow, 
X									"More ammunition, cool!", True);
X								for (i=0; i < NUMBER_OF_BULLETS_NEW_LEVEL; i++)
X									AddABullet(display);
X								break;
X
X							case BONUS_BLK:
X								IncNumberBonus();
X
X								if (GetNumberBonus() <= MAX_BONUS)
X									sprintf(str, 
X										"- Bonus #%d -", GetNumberBonus());
X								else
X									sprintf(str, "- Super Bonus -");
X
X								SetCurrentMessage(display, messWindow, str, 
X									True);
X								bonusBlock = False;
X
X								/* Turn on killer mode after 10 bonuses */
X								if (GetNumberBonus() == 10)
X								{
X									/* Turn on killer mode */
X									ToggleKiller(display, True);
X									DrawSpecials(display);
X
X									SetCurrentMessage(display, messWindow, 
X										"- Killer Mode -", True);
X								}
X								break;
X
X							case BONUSX2_BLK:
X								Togglex2Bonus(display, True);
X								Togglex4Bonus(display, False);
X								DrawSpecials(display);
X
X								bonusBlock = False;
X								SetCurrentMessage(display, messWindow, 
X									"- x2 Bonus -", True);
X								break;
X
X							case BONUSX4_BLK:
X								Togglex2Bonus(display, False);
X								Togglex4Bonus(display, True);
X								DrawSpecials(display);
X
X								bonusBlock = False;
X								SetCurrentMessage(display, messWindow, 
X									"- x4 Bonus -", True);
X								break;
X
X							default :
X								break;
X						}
X
X						/* Reset to a non exploding block */
X						ClearBlock(r, c);
X					}
X				}
X			}
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid DrawTheBlock(Display *display, Window window, int x, int y, 
X	int blockType, int slide)
X#else
Xvoid DrawTheBlock(display, window, x, y, blockType, slide)
X	Display *display;
X	Window window;
X	int x;
X	int y; 
X	int blockType;
X	int slide;
X#endif
X{
X	switch(blockType)
X	{
X		case PAD_SHRINK_BLK:	/* Paddle shrink block */
X			RenderShape(display, window, paddleshrink,
X				paddleshrinkM, x, y, 40, 15, False);
X			break;
X
X		case PAD_EXPAND_BLK:	/* Paddle expand block */
X			RenderShape(display, window, paddleexpand,
X				paddleexpandM, x, y, 40, 15, False);
X			break;
X
X		case BULLET_BLK:	/* Draw a bullet shape */
X			RenderShape(display, window, yellowblock, yellowblockM, 
X				x, y, 40, 20, False);
X			DrawTheBullet(display, window, x+6, y+10);
X			DrawTheBullet(display, window, x+15, y+10);
X			DrawTheBullet(display, window, x+24, y+10);
X			DrawTheBullet(display, window, x+33, y+10);
X			break;
X
X		case MULTIBALL_BLK:	/* Draw multiple ball block */
X			RenderShape(display, window, multiball, multiballM, 
X				x, y, 40, 20, False);
X			break;
X
X		case STICKY_BLK:	/* Draw sticky block */
X			RenderShape(display, window, sticky, stickyM, 
X				x, y, 32, 32, False);
X			break;
X
X		case RED_BLK:	/* Draw a red block shape */
X			RenderShape(display, window, redblock, redblockM, 
X				x, y, 40, 20, False);
X			break;
X
X		case BLACK_BLK:		/* Draw a solid wall block */	
X			RenderShape(display, window, blackblock, blackblockM, 
X				x, y, 50, 30, False);
X			break;
X
X		case GREEN_BLK:		/* Draw a green block */
X			RenderShape(display, window, greenblock, greenblockM, 
X				x, y, 40, 20, False);
X			break;
X
X		case BLUE_BLK:		/* Draw a blue block */
X			RenderShape(display, window, blueblock, blueblockM, 
X				x, y, 40, 20, False);
X			break;
X
X		case YELLOW_BLK:	/* Draw a yellow block */
X			RenderShape(display, window, yellowblock, yellowblockM, 
X				x, y, 40, 20, False);
X			break;
X
X		case TAN_BLK:		/* Draw a tan block */
X			RenderShape(display, window, tanblock, tanblockM, 
X				x, y, 40, 20, False);
X			break;
X
X		case PURPLE_BLK:	/* Draw a purple block */
X			RenderShape(display, window, purpleblock, purpleblockM, 
X				x, y, 40, 20, False);
X			break;
X
X		case COUNTER_BLK:	/* Draw a frame of counter block */
X			RenderShape(display, window, counterblock[slide], 
X				counterblockM[slide], x, y, 40, 20, False);
X			break;
X
X		case BONUSX2_BLK:	/* Draw a bonus x2 coin block */
X			RenderShape(display, window, x2bonus[slide], 
X				x2bonusM[slide], x, y, 27, 27, False);
X			break;
X
X		case BONUSX4_BLK:	/* Draw a bonus x4 coin block */
X			RenderShape(display, window, x4bonus[slide], 
X				x4bonusM[slide], x, y, 27, 27, False);
X			break;
X
X		case BONUS_BLK:	/* Draw a bonus coin block */
X			RenderShape(display, window, Bonus[slide], 
X				BonusM[slide], x, y, 27, 27, False);
X			break;
X
X		case BOMB_BLK:		/* Draw a bomb block */
X			RenderShape(display, window, bombblock, bombblockM, 
X				x, y, 30, 30, False);
X			break;
X
X		case DEATH_BLK:		/* Draw the pirate death block */
X			RenderShape(display, window, death[slide], deathM[slide], 
X				x, y, 30, 30, False);
X			break;
X
X		case REVERSE_BLK:	/* Draw the reverse block */
X			RenderShape(display, window, revblock, revblockM, 
X				x, y, 33, 16, False);
X			break;
X
X		case EXTRABALL_BLK:	/* Draw the extra ball block */
X			RenderShape(display, window, extraball[slide], extraballM[slide], 
X				x, y, 30, 19, False);
X			break;
X
X		case HYPERSPACE_BLK:	/* Draw the hyperspace block */
X			RenderShape(display, window, hyperblock, hyperblockM, 
X				x, y, 31, 31, False);
X			break;
X
X		case MGUN_BLK:	/* Draw the machine gun block */
X			RenderShape(display, window, mgunblock, mgunblockM, 
X				x, y, 35, 15, False);
X			break;
X
X		case WALLOFF_BLK:	/* Draw the wall off block */
X			RenderShape(display, window, walloffblock, walloffblockM, 
X				x, y, 27, 23, False);
X			break;
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void SetBlockUpForExplosion(int row, int col, int frame)
X#else
Xstatic void SetBlockUpForExplosion(row, col, frame)
X	int row;
X	int col;
X	int frame;
X#endif
X{
X    struct aBlock *blockP;
X
X	if (row < 0 || row >= MAX_ROW) return;
X	if (col < 0 || col >= MAX_COL) return;
X
X	/* Obtain a pointer to the affected block */
X	blockP = &blocks[row][col];
X
X	/* Do not have any effect on a specials block */
X	if (blockP->blockType == HYPERSPACE_BLK) return;
X
X	/* If it isn't occupied then why blow it up */
X	if (blockP->occupied == 1 && blockP->exploding == False)
X	{
X		/* Keep track of how many blocks are exploding */
X		blocksExploding++;
X
X		/* Some special variables used for timing */
X		blockP->explodeStartFrame 	= frame;
X		blockP->explodeNextFrame 	= frame;
X		blockP->explodeSlide 		= 1;
X		blockP->exploding 			= True;
X	}
X}
X
X
X#if NeedFunctionPrototypes
Xvoid DrawBlock(Display *display, Window window, int row, int col, int blockType)
X#else
Xvoid DrawBlock(display, window, row, col, blockType)
X	Display *display;
X	Window window;
X	int row;
X	int col;
X	int blockType;
X#endif
X{
X	struct aBlock *blockP;
X
X	if (row < 0 || row > MAX_ROW) 
X	{
X		ErrorMessage("Block out of bounds row.");
X		return;
X	}
X
X	if (col < 0 || col > MAX_COL) 
X	{
X		ErrorMessage("Block out of bounds column.");
X		return;
X	}
X
X	/* Pointer to the block in question */
X	blockP = &blocks[row][col];
X
X	switch(blockType)
X	{
X		case KILL_BLK:		/* Special block - blow it up */
X			PlaySoundForBlock(blockP->blockType);
X
X			if (blockP->blockType != BLACK_BLK)
X				SetBlockUpForExplosion(row, col, frame);
X			break;
X
X		default:			/* Your average block - draw it */
X			DrawTheBlock(display, window, blockP->x, blockP->y, 
X				blockType, blockP->counterSlide);
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid FreeBlockPixmaps(Display *display)
X#else
Xvoid FreeBlockPixmaps(display)
X	Display *display;
X#endif
X{
X	int i;
X
X	/* Free the memory associated with the block pixmaps */
X	if (redblock)		XFreePixmap(display, redblock);			
X	if (redblockM)		XFreePixmap(display, redblockM);
X	if (blueblock)		XFreePixmap(display, blueblock);		
X	if (blueblockM)		XFreePixmap(display, blueblockM);
X	if (greenblock)		XFreePixmap(display, greenblock);		
X	if (greenblockM)	XFreePixmap(display, greenblockM);
X	if (tanblock)		XFreePixmap(display, tanblock);			
X	if (tanblockM)		XFreePixmap(display, tanblockM);
X	if (yellowblock)	XFreePixmap(display, yellowblock);		
X	if (yellowblockM)	XFreePixmap(display, yellowblockM);
X	if (purpleblock)	XFreePixmap(display, purpleblock);		
X	if (purpleblockM)	XFreePixmap(display, purpleblockM);
X	if (blackblock)		XFreePixmap(display, blackblock);		
X	if (blackblockM)	XFreePixmap(display, blackblockM);
X	if (bombblock)		XFreePixmap(display, bombblock);		
X	if (bombblockM)		XFreePixmap(display, bombblockM);
X	if (revblock)		XFreePixmap(display, revblock);		
X	if (revblockM)		XFreePixmap(display, revblockM);
X	if (hyperblock)		XFreePixmap(display, hyperblock);		
X	if (hyperblockM)	XFreePixmap(display, hyperblockM);
X	if (mgunblock)		XFreePixmap(display, mgunblock);		
X	if (mgunblockM)		XFreePixmap(display, mgunblockM);
X	if (walloffblock)	XFreePixmap(display, walloffblock);		
X	if (walloffblockM)	XFreePixmap(display, walloffblockM);
X	if (multiball)		XFreePixmap(display, multiball);		
X	if (multiballM)		XFreePixmap(display, multiballM);
X	if (sticky)			XFreePixmap(display, sticky);		
X	if (stickyM)		XFreePixmap(display, stickyM);
X	if (paddleexpand)	XFreePixmap(display, paddleexpand);		
X	if (paddleexpandM)	XFreePixmap(display, paddleexpandM);
X	if (paddleshrink)	XFreePixmap(display, paddleshrink);		
X	if (paddleshrinkM)	XFreePixmap(display, paddleshrinkM);
X
X	for (i = 0; i < 5; i++)
X	{
X		/* Free the frames for the death block */
X		if (death[i])	XFreePixmap(display, death[i]); 	
X		if (deathM[i])	XFreePixmap(display, deathM[i]);
X	}
X
X	for (i = 0; i < 6; i++)
X	{
X		if (counterblock[i])	XFreePixmap(display, counterblock[i]); 	
X		if (counterblockM[i])	XFreePixmap(display, counterblockM[i]);
X	}
X
X	for (i = 0; i < 4; i++)
X	{
X		if (x2bonus[i])			XFreePixmap(display, x2bonus[i]); 	
X		if (x2bonusM[i])		XFreePixmap(display, x2bonusM[i]);
X
X		if (x4bonus[i])			XFreePixmap(display, x4bonus[i]); 	
X		if (x4bonusM[i])		XFreePixmap(display, x4bonusM[i]);
X
X		if (Bonus[i])			XFreePixmap(display, Bonus[i]); 	
X		if (BonusM[i])			XFreePixmap(display, BonusM[i]);
X	}
X
X	for (i = 0; i < 2; i++)
X	{
X		if (extraball[i])		XFreePixmap(display, extraball[i]); 	
X		if (extraballM[i])		XFreePixmap(display, extraballM[i]);
X	}
X
X	for (i = 0; i < 3; i++)
X	{
X		if (exgreenblock[i])   	XFreePixmap(display, exgreenblock[i]); 	
X		if (exgreenblockM[i])   XFreePixmap(display, exgreenblockM[i]);
X
X		if (exyellowblock[i])   XFreePixmap(display, exyellowblock[i]);
X		if (exyellowblockM[i])  XFreePixmap(display, exyellowblockM[i]);
X
X		if (exredblock[i])     	XFreePixmap(display, exredblock[i]);
X		if (exredblockM[i])     XFreePixmap(display, exredblockM[i]);
X
X		if (exblueblock[i])     XFreePixmap(display, exblueblock[i]);
X		if (exblueblockM[i])    XFreePixmap(display, exblueblockM[i]);
X
X		if (extanblock[i])     	XFreePixmap(display, extanblock[i]);
X		if (extanblockM[i])     XFreePixmap(display, extanblockM[i]);
X
X		if (excounterblock[i])  XFreePixmap(display, excounterblock[i]);
X		if (excounterblockM[i]) XFreePixmap(display, excounterblockM[i]);
X
X		if (exbombblock[i])     XFreePixmap(display, exbombblock[i]);
X		if (exbombblockM[i])    XFreePixmap(display, exbombblockM[i]);
X		
X		if (expurpleblock[i])   XFreePixmap(display, expurpleblock[i]);
X		if (expurpleblockM[i])  XFreePixmap(display, expurpleblockM[i]);
X		
X		if (exx2bonus[i])     	XFreePixmap(display, exx2bonus[i]);
X		if (exx2bonusM[i])     	XFreePixmap(display, exx2bonusM[i]);
X
X		if (exdeath[i])			XFreePixmap(display, exdeath[i]); 	
X		if (exdeathM[i])		XFreePixmap(display, exdeathM[i]);
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void CalculateBlockGeometry(int row, int col)
X#else
Xstatic void CalculateBlockGeometry(row, col)
X	int row, col;
X#endif
X{
X	struct aBlock *blockP;
X	XPoint points[4];
X	int halfWidth, halfHeight;
X
X	/* Pointer to the correct block we need - speed things up */
X	blockP = &blocks[row][col];
X
X	switch (blockP->blockType)
X	{
X		case COUNTER_BLK:
X			blockP->width 			= BLOCK_WIDTH;
X			blockP->height			= BLOCK_HEIGHT;
X			blockP->blockOffsetX	= (colWidth - BLOCK_WIDTH) / 2;
X			blockP->blockOffsetY 	= (rowHeight - BLOCK_HEIGHT) / 2;
X			break;
X
X		case MGUN_BLK:
X			blockP->width 			= 35;
X			blockP->height			= 15;
X			blockP->blockOffsetX	= (colWidth - 35) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 15) / 2;
X			break;
X
X		case WALLOFF_BLK:
X			blockP->width 			= 27;
X			blockP->height			= 23;
X			blockP->blockOffsetX	= (colWidth - 27) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 23) / 2;
X			break;
X
X		case REVERSE_BLK:
X			blockP->width 			= 33;
X			blockP->height			= 16;
X			blockP->blockOffsetX	= (colWidth - 33) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 16) / 2;
X			break;
X
X		case EXTRABALL_BLK:
X			blockP->width 			= 30;
X			blockP->height			= 19;
X			blockP->blockOffsetX	= (colWidth - 30) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 19) / 2;
X			break;
X
X		case HYPERSPACE_BLK:
X			blockP->width 			= 31;
X			blockP->height			= 31;
X			blockP->blockOffsetX	= (colWidth - 31) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 31) / 2;
X			break;
X
X		case BOMB_BLK:
X		case DEATH_BLK:
X			blockP->width 			= 30;
X			blockP->height			= 30;
X			blockP->blockOffsetX	= (colWidth - 30) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 30) / 2;
X			break;
X
X		case STICKY_BLK:
X			blockP->width 			= 32;
X			blockP->height			= 32;
X			blockP->blockOffsetX	= (colWidth - 32) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 32) / 2;
X			break;
X
X		case BLACK_BLK:
X			blockP->width 			= 50;
X			blockP->height			= 30;
X			blockP->blockOffsetX	= (colWidth - 50) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 30) / 2;
X			break;
X
X        case PAD_SHRINK_BLK:
X		case PAD_EXPAND_BLK:
X			blockP->width 			= 40;
X			blockP->height			= 15;
X			blockP->blockOffsetX	= (colWidth - 40) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 15) / 2;
X			break;
X
X		case BONUS_BLK:
X		case BONUSX4_BLK:
X		case BONUSX2_BLK:
X			blockP->width 			= 27;
X			blockP->height			= 27;
X			blockP->blockOffsetX	= (colWidth - 27) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 27) / 2;
X			break;
X
X		default:		/* All other blocks */
X			blockP->width 			= BLOCK_WIDTH;
X			blockP->height			= BLOCK_HEIGHT;
X			blockP->blockOffsetX	= (colWidth - BLOCK_WIDTH) / 2;
X			blockP->blockOffsetY 	= (rowHeight - BLOCK_HEIGHT) / 2;
X			break;
X
X	}	
X
X	/* Calculate the offset within the block grid */
X	blockP->x = (col * colWidth) + blockP->blockOffsetX;
X	blockP->y = (row * rowHeight) + blockP->blockOffsetY;
X
X	/* Used below */
X	halfWidth = blockP->x + (blockP->width / 2);
X	halfHeight = blockP->y + (blockP->height / 2);
X
X	/* Create the XPoint array for the top region */
X	points[0].x = blockP->x;
X	points[0].y = blockP->y;
X	points[1].x = halfWidth;
X	points[1].y = halfHeight;
X	points[2].x = blockP->x + blockP->width;
X	points[2].y = blockP->y;
X	points[3].x = points[0].x;
X	points[3].y = points[0].y;
X
X	/* Create the top region for the block */
X    blockP->regionTop = XPolygonRegion(points, 4, EvenOddRule);
X
X	/* Create the XPoint array for the bottom region */
X	points[0].x = blockP->x;
X	points[0].y = blockP->y + blockP->height;
X	points[1].x = halfWidth;
X	points[1].y = halfHeight;
X	points[2].x = blockP->x + blockP->width;
X	points[2].y = points[0].y;
X	points[3].x = points[0].x;
X	points[3].y = points[0].y;
X
X	/* Create the bottom region for the block */
X    blockP->regionBottom = XPolygonRegion(points, 4, EvenOddRule);
X
X	/* Create the XPoint array for the left region */
X	points[0].x = blockP->x;
X	points[0].y = blockP->y;
X	points[1].x = halfWidth;
X	points[1].y = halfHeight;
X	points[2].x = blockP->x;
X	points[2].y = blockP->y + blockP->height;
X	points[3].x = points[0].x;
X	points[3].y = points[0].y;
X
X	/* Create the left region for the block */
X    blockP->regionLeft = XPolygonRegion(points, 4, EvenOddRule);
X
X	/* Create the XPoint array for the right region */
X	points[0].x = blockP->x + blockP->width;
X	points[0].y = blockP->y;
X	points[1].x = halfWidth;
X	points[1].y = halfHeight;
X	points[2].x = points[0].x;
X	points[2].y = blockP->y + blockP->height;
X	points[3].x = points[0].x;
X	points[3].y = points[0].y;
X
X	/* Create the right region for the block */
X    blockP->regionRight = XPolygonRegion(points, 4, EvenOddRule);
X}
X
X#if NeedFunctionPrototypes
Xvoid AddNewBlock(Display *display, Window window, int row, int col,
X	int blockType, int counterSlide)
X#else
Xvoid AddNewBlock(display, window, row, col, blockType, counterSlide)
X	Display *display;
X	Window window;
X	int row;
X	int col;
X	int blockType;
X	int counterSlide;
X#endif
X{
X	struct aBlock *blockP;
X
X	if (row > MAX_ROW || row < 0) return;
X	if (col > MAX_COL || col < 0) return;
X
X	/* Pointer to the block we want */
X	blockP = &blocks[row][col];
X
X	/* Now set the block structure with new values */
X	blockP->blockType 		= blockType;
X	blockP->occupied 		= 1;
X	blockP->counterSlide 	= counterSlide;
X
X	/* Handle the special case for a random block */
X	if (blockType == RANDOM_BLK)
X	{
X		/* Setup the random block so it has a next frame and new type */
X		blockP->random 	  = True;
X		blockP->blockType = RED_BLK;
X		blockP->nextFrame = frame + 1;
X	}
X
X	/* Work out all the block geometry stuff */
X	CalculateBlockGeometry(row, col);
X	
X	/* Add the number of points that will be awarded for each block */
X	switch(blockType)
X	{
X		case BULLET_BLK:
X			blockP->hitPoints = 50;
X			break;
X
X		case RED_BLK:
X			blockP->hitPoints = 100;
X			break;
X
X		case GREEN_BLK:
X			blockP->hitPoints = 120;
X			break;
X
X		case BLUE_BLK:
X			blockP->hitPoints = 110;
X			break;
X
X		case TAN_BLK:
X			blockP->hitPoints = 130;
X			break;
X
X		case YELLOW_BLK:
X			blockP->hitPoints = 140;
X			break;
X
X		case PURPLE_BLK:
X			blockP->hitPoints = 150;
X			break;
X
X		case BOMB_BLK:
X			blockP->hitPoints = 50;
X			break;
X
X		case COUNTER_BLK:
X			blockP->hitPoints = 200;
X			break;
X
X		case EXTRABALL_BLK:
X			blockP->nextFrame = frame + EXTRABALL_DELAY;
X			blockP->hitPoints = 100;
X			break;
X
X		case HYPERSPACE_BLK:
X		case MGUN_BLK:
X		case WALLOFF_BLK:
X		case REVERSE_BLK:
X		case MULTIBALL_BLK:
X		case STICKY_BLK:
X        case PAD_SHRINK_BLK:
X		case PAD_EXPAND_BLK:
X			blockP->hitPoints = 100;
X			break;
X
X		case DEATH_BLK:
X			blockP->hitPoints = -1000;
X			blockP->nextFrame = frame + DEATH_DELAY2;
X			break;
X
X		default:
X			break;
X	}
X
X	/* Draw the blocks please */
X	DrawBlock(display, window, row, col, blockType);
X}
X
X#if NeedFunctionPrototypes
Xvoid SkipToNextLevel(Display *display, Window window)
X#else
Xvoid SkipToNextLevel(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X    struct aBlock *blockP;
X	int r, c;
X
X	/* This will kill all blocks that need to go before next level can
X	 * be reached. Used in debug mode and maybe in special bonus mode.
X	 */
X
X	for (r = 0; r < MAX_ROW; r++)
X		for (c = 0; c < MAX_COL; c++)
X		{
X			/* Pointer to the block we want */
X			blockP = &blocks[r][c];
X
X			if (blockP->occupied == True) 
X			{
X				switch (blockP->blockType)
X				{
X					case BONUSX2_BLK:
X					case BONUSX4_BLK:
X					case BONUS_BLK:
X					case BLACK_BLK:
X					case BULLET_BLK:
X					case BOMB_BLK:
X					case DEATH_BLK:
X					case REVERSE_BLK:
X					case HYPERSPACE_BLK:
X					case EXTRABALL_BLK:
X					case MGUN_BLK:
X					case WALLOFF_BLK:
X					case MULTIBALL_BLK:
X					case STICKY_BLK:
X        			case PAD_SHRINK_BLK:
X					case PAD_EXPAND_BLK:
X						break;
X
X					default:
X						DrawBlock(display, window, r, c, KILL_BLK);
X						break;
X				}
X			}
X		}
X}
X
X#if NeedFunctionPrototypes
Xvoid RedrawAllBlocks(Display *display, Window window)
X#else
Xvoid RedrawAllBlocks(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X    struct aBlock *blockP;
X	int r, c;
X
X	for (r = 0; r < MAX_ROW; r++)
X		for (c = 0; c < MAX_COL; c++)
X		{
X			/* Pointer to the block we want */
X			blockP = &blocks[r][c];
X
X			if (blockP->occupied == True)
X				DrawBlock(display, window, r, c, blockP->blockType);
X		}
X}
X
X#if NeedFunctionPrototypes
Xint StillActiveBlocks(void)
X#else
Xint StillActiveBlocks()
X#endif
X{
X    struct aBlock *blockP;
X	int r, c;
X
X	/* Check all blocks to see if they still are active */
X	for (r = 0; r < MAX_ROW; r++)
X		for (c = 0; c < MAX_COL; c++)
X		{
X			/* Pointer to the block we want */
X			blockP = &blocks[r][c];
X
X			if (blockP->occupied == True) 
X			{
X				switch (blockP->blockType)
X				{
X					/* These blocks don't count */
X					case BONUSX2_BLK:
X					case BONUSX4_BLK:
X					case BONUS_BLK:
X					case BLACK_BLK:
X					case BULLET_BLK:
X					case BOMB_BLK:
X					case DEATH_BLK:
X					case REVERSE_BLK:
X					case HYPERSPACE_BLK:
X					case EXTRABALL_BLK:
X					case MGUN_BLK:
X					case WALLOFF_BLK:
X					case MULTIBALL_BLK:
X					case STICKY_BLK:
X        			case PAD_SHRINK_BLK:
X					case PAD_EXPAND_BLK:
X						break;
X
X					default:
X						return True;
X				}
X			}
X		}
X	
X	/* Only all done when explosions are finished */
X	if (blocksExploding > 0)
X		return True;
X	else
X		return False;
X}
X
X#if NeedFunctionPrototypes
Xstatic void ClearBlock(int row, int col)
X#else
Xstatic void ClearBlock(row, col)
X	int row;
X	int col;
X#endif
X{
X    struct aBlock *blockP;
X
X	/* Pointer to the block we want */
X	blockP = &blocks[row][col];
X
X	/* Initialise everything in block */
X	blockP->occupied 			= False;
X	blockP->exploding 			= False;
X	blockP->x 					= 0;
X	blockP->y 					= 0;
X	blockP->width 				= 0;
X	blockP->height 				= 0;
X	blockP->hitPoints 			= 0;
X	blockP->blockType 			= NONE_BLK;
X	blockP->explodeStartFrame 	= 0;
X	blockP->explodeNextFrame 	= 0;
X	blockP->explodeSlide 		= 0;
X	blockP->counterSlide 		= 0;
X	blockP->bonusSlide 			= 0;
X	blockP->blockOffsetY 		= 0;
X	blockP->blockOffsetX 		= 0;
X	blockP->lastFrame 			= 0;
X	blockP->nextFrame 			= 0;
X	blockP->currentFrame 		= 0;
X	blockP->random 				= False;
X	blockP->ballHitIndex 		= 0;
X	blockP->balldx 				= 0;
X	blockP->balldy 				= 0;
X
X	/* Destroy the top region of the block */
X	if (blockP->regionTop != (Region) NULL)
X	{
X		XDestroyRegion(blockP->regionTop);
X		blockP->regionTop = (Region) NULL;
X	}
X
X	/* Destroy the bottom region of the block */
X	if (blockP->regionBottom != (Region) NULL)
X	{
X		XDestroyRegion(blockP->regionBottom);
X		blockP->regionBottom = (Region) NULL;
X	}
X
X	/* Destroy the left region of the block */
X	if (blockP->regionLeft != (Region) NULL)
X	{
X		XDestroyRegion(blockP->regionLeft);
X		blockP->regionLeft = (Region) NULL;
X	}
X
X	/* Destroy the right region of the block */
X	if (blockP->regionRight != (Region) NULL)
X	{
X		XDestroyRegion(blockP->regionRight);
X		blockP->regionRight = (Region) NULL;
X	}
X}
X
X
X#if NeedFunctionPrototypes
Xvoid ClearBlockArray(void)
X#else
Xvoid ClearBlockArray()
X#endif
X{
X	int r, c;
X
X	/* Scan through all block entries and erase their contents */
X	for (r = 0; r < MAX_ROW; r++)
X	{
X		for (c = 0; c < MAX_COL; c++)
X		{
X			/* Clear the block thanks */
X			ClearBlock(r, c);
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid SetupStage(Display *display, Window window)
X#else
Xvoid SetupStage(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	char levelPath[1024];
X	char *str;
X	char str2[1024];
X	static int bgrnd = 1;
X	u_long newLevel;
X
X	bgrnd++;
X	if (bgrnd == 12) bgrnd = 2;
X	DrawStageBackground(display, window, bgrnd);
X
X	ClearAllBalls();
X	currentPaddleSize   = PADDLE_HUGE;
X	ResetPaddleStart(display, window);
X	ResetBallStart(display, playWindow);
X
X	ClearBullets();
X	SetNumberBullets(NUMBER_OF_BULLETS_NEW_LEVEL);
X	ResetNumberBonus();
X
X	TurnSpecialsOff(display);		
X	SetReverseOff();
X	DisplayScore(display, scoreWindow, score);
X	DisplayLevelInfo(display, levelWindow, level);
X	DrawSpecials(display);
X
X    /* map the level number for the filename so that after the maximum
X	 * level is reached it will wrap around to 1 again but will not
X  	 * affect the level number
X   	 */
X   	newLevel = level % (MAX_NUM_LEVELS + 1);
X  	if (newLevel == 0) newLevel = 1;
X
X	/* Construct the level filename */
X	if ((str = getenv("XBOING_LEVELS_DIR")) != NULL)
X		sprintf(levelPath, "%s/level%ld.data", str, newLevel);
X	else
X		sprintf(levelPath, "%s/level%ld.data", LEVEL_INSTALL_DIR, newLevel);
X
X	if (ReadNextLevel(display, window, levelPath) == False)
X		ShutDown(display, 1, "Sorry, email: jck@citri.edu.au with bug.");
X	
X	/* Display level name for all to see */
X	sprintf(str2, "- %s -", GetLevelName());
X	SetCurrentMessage(display, messWindow, str2, True);
X
X	XFlush(display);
X}
END_OF_FILE
if test 55711 -ne `wc -c <'blocks.c'`; then
    echo shar: \"'blocks.c'\" unpacked with wrong size!
fi
# end of 'blocks.c'
fi
echo shar: End of archive 2 \(of 30\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    echo "Now execute sdecode.sh to build files."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
