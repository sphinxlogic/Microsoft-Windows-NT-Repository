Path: uunet!news.tek.com!news.cna.tek.com!not-for-mail
From: billr@saab.cna.tek.com (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i068:  xboing - blockout variant with color and sound for X, Part09/30
Date: 30 Aug 1993 10:27:38 -0700
Organization: Tektronix, Inc., Redmond, OR
Lines: 1979
Approved: billr@saab.CNA.TEK.COM
Message-ID: <25tdaa$hun@saab.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1868

Submitted-by: jck@kimba.catt.citri.edu.au (Justin Kibell)
Posting-number: Volume 18, Issue 68
Archive-name: xboing/part09
Environment: X11, Xlib, XPM



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 30)."
# Contents:  ball.c bitmaps/exblueblock1.xpm.uu sounds/whoosh.au.uu
# Wrapped by billr@saab on Mon Aug 30 09:14:24 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ball.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ball.c'\"
else
echo shar: Extracting \"'ball.c'\" \(43559 characters\)
sed "s/^X//" >'ball.c' <<'END_OF_FILE'
X#include "include/copyright.h"
X
X/*
X *  Include file dependencies:
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <math.h>
X#include <xpm.h>
X
X#include "bitmaps/ball1.xpm"
X#include "bitmaps/ball2.xpm"
X#include "bitmaps/ball3.xpm"
X#include "bitmaps/ball4.xpm"
X#include "bitmaps/killer.xpm"
X
X#include "bitmaps/ballbirth1.xpm"
X#include "bitmaps/ballbirth2.xpm"
X#include "bitmaps/ballbirth3.xpm"
X#include "bitmaps/ballbirth4.xpm"
X#include "bitmaps/ballbirth5.xpm"
X#include "bitmaps/ballbirth6.xpm"
X#include "bitmaps/ballbirth7.xpm"
X#include "bitmaps/ballbirth8.xpm"
X
X#include "include/audio.h"
X#include "include/error.h"
X#include "include/score.h"
X#include "include/sfx.h"
X#include "include/init.h"
X#include "include/main.h"
X#include "include/stage.h"
X#include "include/blocks.h"
X#include "include/paddle.h"
X#include "include/misc.h"
X#include "include/level.h"
X#include "include/mess.h"
X#include "include/special.h"
X
X#include "include/ball.h"
X
X/*
X *  Internal macro definitions:
X */
X
X#define X2COL(col, x) (col = x / colWidth)
X#define Y2ROW(row, y) (row = y / rowHeight)
X
X#define COL2X(x, col) (x = col * colWidth)
X#define ROW2Y(y, row) (y = row * rowHeight)
X
X/*
X *  Internal type declarations:
X */
X
X#if NeedFunctionPrototypes
Xstatic void MoveBall(Display *display, Window window, int x, int y, int replace,
X	int i);
Xstatic void MoveBallBirth(Display *display, Window window, int x, int y, 
X	int slide, int replace, int i);
Xstatic void DoBoardTilt(Display *display, int i);
Xstatic void TeleportBall(Display *display, Window window, int i);
Xstatic int BallHitPaddle(Display *display, Window window, int *hit, int i,
X	int *x, int *y);
Xstatic void UpdateABall(Display *display, Window window, int i);
Xstatic int CheckRegions(Display *display, Window window, int row, int col,
X	int x, int y, int i);
Xstatic int CheckForCollision(Display *display, Window window, int x, int y, 
X	int *r, int *c, int i);
Xstatic void updateBallVariables(int i);
Xstatic void SetBallWait(int newMode, int waitFrame, int i);
Xstatic void DoBallWait(int i);
Xstatic void EraseTheBall(Display *display, Window window, int x, int y);
X#else
Xstatic void MoveBall();
Xstatic void MoveBallBirth();
Xstatic void DoBoardTilt();
Xstatic void TeleportBall();
Xstatic int BallHitPaddle();
Xstatic void UpdateABall();
Xstatic int CheckRegions();
Xstatic int CheckForCollision();
Xstatic void updateBallVariables();
Xstatic void SetBallWait();
Xstatic void DoBallWait();
Xstatic void EraseTheBall();
X#endif
X
X/*
X *  Internal variable declarations:
X */
X
Xstatic Pixmap ballsPixmap[BALL_SLIDES];
Xstatic Pixmap ballsMask[BALL_SLIDES];
Xstatic Pixmap ballBirthPixmap[BIRTH_SLIDES];
Xstatic Pixmap ballBirthMask[BIRTH_SLIDES];
XBALL balls[MAX_BALLS];
X
X#if NeedFunctionPrototypes
Xvoid InitialiseBall(Display *display, Window window, Colormap colormap)
X#else
Xvoid InitialiseBall(display, window, colormap)
X	Display 	*display;
X	Window 		window;
X	Colormap 	colormap;
X#endif
X{
X    XpmAttributes   attributes;
X	int		    	XpmErrorStatus;
X
X    attributes.valuemask = XpmColormap;
X	attributes.colormap = colormap;
X
X	/* Create the xpm pixmap ball frames */
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, ball1_xpm,
X		&ballsPixmap[0], &ballsMask[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBall()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, ball2_xpm,
X		&ballsPixmap[1], &ballsMask[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBall()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, ball3_xpm,
X		&ballsPixmap[2], &ballsMask[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBall()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, ball4_xpm,
X		&ballsPixmap[3], &ballsMask[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBall()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, killer_xpm,
X		&ballsPixmap[4], &ballsMask[4], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBall()");
X
X	/* Ball birth sequence */
X
X	/* Create the xpm pixmap ball birth frames */
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, ballbirth1_xpm,
X		&ballBirthPixmap[0], &ballBirthMask[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBall()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, ballbirth2_xpm,
X		&ballBirthPixmap[1], &ballBirthMask[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBall()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, ballbirth3_xpm,
X		&ballBirthPixmap[2], &ballBirthMask[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBall()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, ballbirth4_xpm,
X		&ballBirthPixmap[3], &ballBirthMask[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBall()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, ballbirth5_xpm,
X		&ballBirthPixmap[4], &ballBirthMask[4], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBall()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, ballbirth6_xpm,
X		&ballBirthPixmap[5], &ballBirthMask[5], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBall()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, ballbirth7_xpm,
X		&ballBirthPixmap[6], &ballBirthMask[6], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBall()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, ballbirth8_xpm,
X		&ballBirthPixmap[7], &ballBirthMask[7], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBall()");
X
X	/* Free the xpm pixmap attributes */
X	XpmFreeAttributes(&attributes);
X
X	/* Make sure that all the balls are initialised */
X	ClearAllBalls();
X}
X
X#if NeedFunctionPrototypes
Xvoid FreeBall(Display *display)
X#else
Xvoid FreeBall(display)
X	Display *display;
X#endif
X{
X	int i;
X
X	/* Free all animation frames for the ball */
X	for (i = 0; i < BALL_SLIDES; i++)
X	{
X		if (ballsPixmap[i]) 	XFreePixmap(display, ballsPixmap[i]);
X	 	if (ballsMask[i]) 		XFreePixmap(display, ballsMask[i]);
X	}
X
X	/* Free all animation frames for the ball birth */
X	for (i = 0; i < BIRTH_SLIDES; i++)
X	{
X		/* Free the ball birth animation pixmaps */
X		if (ballBirthPixmap[i]) 	XFreePixmap(display, ballBirthPixmap[i]);
X	 	if (ballBirthMask[i]) 		XFreePixmap(display, ballBirthMask[i]);
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid RedrawBall(Display *display, Window window)
X#else
Xvoid RedrawBall(display, window)
X	Display *display; 
X	Window window;
X#endif
X{
X	/* STILL TO BE IMPLEMENTED */
X}
X
X#if NeedFunctionPrototypes
Xstatic void EraseTheBall(Display *display, Window window, int x, int y)
X#else
Xstatic void EraseTheBall(display, window, x, y)
X	Display *display;
X	Window window;
X	int x;
X	int y;
X#endif
X{
X	/* Clear the ball area! The x, y coordinates are the centre of ball */
X    XClearArea(display, window, x - BALL_WC, y - BALL_HC, 
X		BALL_WIDTH, BALL_HEIGHT, False);
X}
X
X#if NeedFunctionPrototypes
Xvoid DrawTheBall(Display *display, Window window, int x, int y, int slide)
X#else
Xvoid DrawTheBall(display, window, x, y, slide)
X	Display *display;
X	Window window;
X	int x;
X	int y; 
X	int slide;
X#endif
X{
X	/* Draw the ball using the slide variable as the index into the frames
X	 * of the ball animation. The x,y are the centre of the ball.
X	 */
X    RenderShape(display, window, ballsPixmap[slide], ballsMask[slide],
X		x - BALL_WC, y - BALL_HC, BALL_WIDTH, BALL_HEIGHT, False);
X}
X
X#if NeedFunctionPrototypes
Xvoid DrawTheBallBirth(Display *display, Window window, int x, int y, int slide)
X#else
Xvoid DrawTheBallBirth(display, window, x, y, slide)
X	Display *display;
X	Window window;
X	int x;
X	int y;
X	int slide;
X#endif
X{
X	/* Draw the ball using the slide variable as the index into the frames
X	 * of the ball animation. The x,y are the centre of the ball birth anim.
X	 */
X    RenderShape(display, window, ballBirthPixmap[slide], ballBirthMask[slide],
X		x - BALL_WC, y - BALL_HC, BALL_WIDTH, BALL_HEIGHT, False);
X}
X
X#if NeedFunctionPrototypes
Xstatic void MoveBallBirth(Display *display, Window window, int x, int y, 
X	int slide, int replace, int i)
X#else
Xstatic void MoveBallBirth(display, window, x, y, slide, replace, i)
X	Display *display;
X	Window window;
X	int x;
X	int y; 
X	int slide;
X	int replace;
X	int i;
X#endif
X{
X	/* Remove any debris under ball first by clearing it */
X	if (replace)
X	{
X		XClearArea(display, window, 
X			balls[i].oldx - BALL_WC, balls[i].oldy - BALL_HC, 
X			BALL_WIDTH, BALL_HEIGHT, False);
X	}	
X
X	balls[i].oldx = x;
X	balls[i].oldy = y;
X
X	/* If slide is -1 then clear the ball area */
X	if (slide == -1)
X		XClearArea(display, window, 
X			x - BALL_WC, y - BALL_HC, BALL_WIDTH, BALL_HEIGHT, False);
X	else
X		DrawTheBallBirth(display, window, x, y, slide);
X}
X
X#if NeedFunctionPrototypes
Xstatic void MoveBall(Display *display, Window window, int x, int y, int replace,
X	int i)
X#else
Xstatic void MoveBall(display, window, x, y, replace, i)
X	Display *display; 
X	Window window;
X	int x;
X	int y;
X	int replace;
X	int i;
X#endif
X{
X	if (replace)
X	{
X		EraseTheBall(display, window, balls[i].oldx, balls[i].oldy);
X	}
X
X	balls[i].oldx = x;
X	balls[i].oldy = y;
X
X	if (Killer == True)
X	{
X		/* Render the killer ball now ie: red ball */
X		DrawTheBall(display, window, x, y, BALL_SLIDES-1);
X	}
X	else
X	{
X		/* Render the ball now */
X		DrawTheBall(display, window, x, y, balls[i].slide);
X	}	
X
X	/* Change slide for ball every n frames of animation */
X	if ((frame % BALL_ANIM_RATE) == 0)
X		balls[i].slide++;
X	
X	/* wrap around slides */
X	if (balls[i].slide == BALL_SLIDES-1) balls[i].slide = 0;
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoBoardTilt(Display *display, int i)
X#else
Xstatic void DoBoardTilt(display, i)
X	Display *display;
X	int i;
X#endif
X{
X	if (balls[i].ballState == BALL_ACTIVE)
X	{
X		/* Tilt the board to remove any endless loops */
X		SetCurrentMessage(display, messWindow, 
X			"Auto Tilt Activated", True);
X	
X		balls[i].dx = balls[i].dy = 0;
X	
X		/* Randomise the ball */
X		while (balls[i].dx == 0)
X		{
X   		 	balls[i].dx = (2 - (rand() % 4)) * 2;
X   		 	balls[i].dy = (abs(balls[i].dx)) * 2;
X			balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void TeleportBall(Display *display, Window window, int i)
X#else
Xstatic void TeleportBall(display, window, i)
X	Display *display;
X 	Window window;
X	int i;
X#endif
X{
X	/* This function will teleport the ball to some other space not occupied
X	 * and start off there.
X	 */
X	int r1, c1, s1, r2, c2, s2, r3, c3, s3, r4, c4, s4;
X    int r, c, x, y;
X    struct aBlock *blockP, *bP;
X	int done = False;
X
X	/* Loop until we find a block to move to */
X	while (done == False)
X	{
X		/* Give me a new random block position */
X		r = (rand() % (MAX_ROW - 5)) + 1;
X		c = (rand() % MAX_COL) + 1;
X
X    	if (r < 0 || r >= MAX_ROW) continue;
X    	if (c < 0 || c >= MAX_COL) continue;
X
X		/* Pointer to the correct block we need - speed things up */
X		blockP = &blocks[r][c];
X
X		/* Check that the block is not occupied and not exploding */
X		if ((blockP->occupied == False) && (blockP->exploding == False))
X		{
X        	/* Check that the block is not a closed position */
X
X            r1 = r;     c1 = c - 1;  s1 = 0;
X            if (r1 < 0 || r1 >= MAX_ROW) s1 = 1;
X            if (c1 < 0 || c1 >= MAX_COL) s1 = 1;
X            if (s1 == 0) 
X			{
X            	bP = &blocks[r1][c1];
X                if (bP->blockType == BLACK_BLK)
X                s1 = 1;
X            }
X
X            r2 = r - 1; c2 = c;      s2 = 0;
X            if (r2 < 0 || r2 >= MAX_ROW) s2 = 1;
X            if (c2 < 0 || c2 >= MAX_COL) s2 = 1;
X            if (s2 == 0) 
X			{
X                bP = &blocks[r2][c2];
X                if (bP->blockType == BLACK_BLK)
X                    s2 = 1;
X            }
X
X            r3 = r;     c3 = c + 1;  s3 = 0;
X            if (r3 < 0 || r3 >= MAX_ROW) s3 = 1;
X            if (c3 < 0 || c3 >= MAX_COL) s3 = 1;
X            if (s3 == 0) 
X			{
X                bP = &blocks[r3][c3];
X                if (bP->blockType == BLACK_BLK)
X                    s3 = 1;
X            }
X
X            r4 = r + 1; c4 = c;      s4 = 0;
X            if (r4 < 0 || r4 >= MAX_ROW) s4 = 1;
X            if (c4 < 0 || c4 >= MAX_COL) s4 = 1;
X            if (s4 == 0) 
X			{
X                bP = &blocks[r4][c4];
X                if (bP->blockType == BLACK_BLK)
X                    s4 = 1;
X            }
X
X			/* If it isn't ok to go here then keep searching */
X            if ((s1 == 1) && (s2 == 1) && (s3 == 1) && (s4 == 1))
X                continue;
X
X			/* Calculate the new ball coordinates */
X			COL2X(x, c);
X			ROW2Y(y, r);
X
X			balls[i].ballx = x;
X			balls[i].bally = y;
X
X			/* Move the ball to the new position */
X			MoveBall(display, window, x, y, True, i);
X
X			balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X
X			/* Ok jump out now thanks. */
X			done = True;
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid SplitBallInTwo(Display *display, Window window)
X#else
Xvoid SplitBallInTwo(display, window)
X	Display *display;
X 	Window window;
X#endif
X{
X	int j;
X
X	if (livesLeft > 0)
X	{
X		j = AddANewBall(PLAY_WIDTH / 2, -BALL_HC, 3, 3);
X		if (j > 0)
X		{
X			/* Make this new ball move straight away */
X			ChangeBallMode(BALL_ACTIVE, j);
X
X			/* Take the life from player as the new ball is in play */
X			DecExtraLife(display);
X
X			SetCurrentMessage(display, messWindow,
X				"More balls!", True);
X		}
X	}
X	else
X		SetCurrentMessage(display, messWindow,
X			"Cannot add ball!", True);
X}
X
X#if NeedFunctionPrototypes
Xvoid ClearBallNow(Display *display, Window window, int i)
X#else
Xvoid ClearBallNow(display, window, i)
X	Display *display;
X 	Window window;
X	int i;
X#endif
X{
X	/* Kill the ball now, boy! */
X	EraseTheBall(display, window, balls[i].ballx, balls[i].bally);
X	ClearBall(i);
X	DeadBall(display, window);
X}
X
X#if NeedFunctionPrototypes
Xvoid KillBallNow(Display *display, Window window, int i)
X#else
Xvoid KillBallNow(display, window, i)
X	Display *display;
X 	Window window;
X	int i;
X#endif
X{
X	/* Kill the ball now, boy! */
X	ChangeBallMode(BALL_POP, i);
X}
X
X#if NeedFunctionPrototypes
Xvoid GetBallPosition(int *ballX, int *ballY, int i)
X#else
Xvoid GetBallPosition(ballX, ballY, i)
X	int *ballX;
X	int *ballY;
X	int i;
X#endif
X{
X	/* Return ball i's position */
X	*ballX = balls[i].ballx;
X	*ballY = balls[i].bally;
X}
X
X#if NeedFunctionPrototypes
Xstatic int BallHitPaddle(Display *display, Window window, int *hit, int i,
X	int *x, int *y)
X#else
Xstatic int BallHitPaddle(display, window, hit, i, x, y)
X	Display *display;
X	Window window;
X	int *hit;
X	int i;
X	int *x, *y;
X#endif
X{
X	float x1, x2, y1, y2, alpha, beta, xP1, xP2, xH, yH;
X    int paddleLine;
X
X	/***********************************************************************
X
X                        A1 (x1,y1)
X                        *
X                       .
X                      .
X         P1 =========.=========== P2   <----   paddle (x, y pos is known )
X        (xP1,yP1)   . H (xH, yH)    (xP2,yP2)
X                   .
X                  .
X                 .
X                .
X               .
X              *
X             A2 (x2,y2)
X
X   		Given the line A1A2, is the intersecting point H (xH, yH) in the paddle 
X		segment ? (i.e xH in [xP1,xP2])
X
X   		A1A2 is :  y = alpha * x + beta
X
X   		A1 and A2 are in A1A2 than beta = [(y1 + y2) - alpha*(x1+x2)] / 2
X
X   		yH = yP1 = yP2
X
X   		so xH = (yP1 - beta) / alpha
X
X	**********************************************************************/
X
X    paddleLine = (PLAY_HEIGHT - DIST_BASE - 2);
X
X    if (balls[i].bally + BALL_HC > paddleLine)
X   	{
X   		xP1 = (float)(paddlePos - (GetPaddleSize() / 2) - BALL_WC/2);
X   		xP2 = (float)(paddlePos + (GetPaddleSize() / 2) + BALL_WC/2);
X
X   		if (balls[i].dx == 0)
X      	{
X			/* process the vertical moving balls */
X      		if (((float)balls[i].ballx > xP1) && ((float)balls[i].ballx < xP2))
X         	{
X         		/* the ball hit the paddle */
X         		*hit = balls[i].ballx - paddlePos;
X         		*x 	 = balls[i].ballx;
X         		*y 	 = paddleLine - BALL_HC;
X
X         		return True;
X         	}
X      		else
X        		return False;
X      	}
X   		else
X      	{
X 			/* compute the line coefficients of the ball */
X
X			alpha 	= (float) balls[i].dy;
X    		x1 		= (float) (balls[i].ballx - balls[i].dx);
X    		y1 		= (float) (balls[i].bally - balls[i].dy);
X    		x2 		= (float) (balls[i].ballx);
X    		y2 		= (float) (balls[i].bally);
X    		beta 	= ((y1 + y2) - alpha * (x1 + x2)) / 2.0;
X
X    		yH = (float) paddleLine;
X    		xH = (yH - beta) / alpha;
X
X			if ((xH > xP1) && (xH < xP2))
X    		{
X    			/* the ball hit the paddle */
X        		*hit 	= (int) (xH + 0.5) - paddlePos;
X        		*x 		= (int) (xH + 0.5);
X        		*y 		= paddleLine - BALL_HC;
X
X        		return True;
X    		}
X    		else
X    			return False;
X		}
X	}
X
X   	/* We didn't hit the paddle */
X   	return False;
X}
X
X#if NeedFunctionPrototypes
Xstatic int HandleTheBlocks(Display *display, Window window, int row, int col,
X	int i)
X#else
Xstatic int HandleTheBlocks(display, window, row, col, i)
X	int row;
X	int col;
X	int i;
X#endif
X{
X	struct aBlock *blockP;
X
X	/* Pointer to the block the ball is in */
X	blockP = &blocks[row][col];
X
X	/* There has been a collision so handle it */
X	if (blockP->exploding == False)
X	{
X		if (blockP->blockType == COUNTER_BLK)
X		{
X			balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X
X			/* If in killer mode then don't bounce off block */
X			if (Killer == True)
X			{
X				DrawBlock(display, window, row, col, KILL_BLK);
X				return True;
X			}
X
X			/* Special case for counter - reduce count on block */
X			if (blockP->counterSlide == 0)
X				DrawBlock(display, window, row, col, KILL_BLK);
X			else
X			{
X				/* Draw the counter block minus one number */
X				blockP->counterSlide--;
X				DrawBlock(display, window, row, col, COUNTER_BLK);
X			}
X		}
X		else
X		{
X			if (blockP->blockType == MGUN_BLK)
X			{
X				/* Turn the machine gun on */
X				ToggleFastGun(display, True);
X				DrawSpecials(display);
X				SetCurrentMessage(display, messWindow,
X					"Machine Gun", True);
X
X				/* Not a wall so explode the block */
X				DrawBlock(display, window, row, col, KILL_BLK);
X				balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X
X				/* If in killer mode then don't bounce off block */
X				if (Killer == True)
X					return True;
X
X			} else if (blockP->blockType == DEATH_BLK)
X			{
X				/* Ha ha - hit death block so die */
X
X				/* Kill the ball now */
X				ClearBallNow(display, window, i);
X
X				/* Not a wall so explode the block */
X				DrawBlock(display, window, row, col, KILL_BLK);
X				balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X
X				/* If in killer mode then don't bounce off block */
X				if (Killer == True)
X					return True;
X
X			} else if (blockP->blockType == HYPERSPACE_BLK)
X			{
X				/* Teleport to somewhere else */
X				TeleportBall(display, window, i);
X
X				/* Redraw it just in case */
X				DrawBlock(display, window, row, col, HYPERSPACE_BLK);
X				balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X
X				PlaySoundForBlock(HYPERSPACE_BLK);
X
X				return True;
X
X			} else if (blockP->blockType == WALLOFF_BLK)
X			{
X				/* Walls are now turned off */
X				ToggleWallsOn(display, True);
X				DrawSpecials(display);
X				SetCurrentMessage(display, messWindow,
X					"Walls off", True);
X
X				/* Not a wall so explode the block */
X				DrawBlock(display, window, row, col, KILL_BLK);
X				balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X
X				/* If in killer mode then don't bounce off block */
X				if (Killer == True)
X					return True;
X
X			} else if (blockP->blockType == REVERSE_BLK)
X			{
X				/* Paddle control now reverse */
X				ToggleReverse(display);
X				SetCurrentMessage(display, messWindow,
X					"Reverse Control", True);
X				DrawSpecials(display);
X
X				/* Move the paddle to reflect reversed paddle */
X				handlePaddleMoving(display);
X
X				/* Not a wall so explode the block */
X				DrawBlock(display, window, row, col, KILL_BLK);
X				balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X
X				/* If in killer mode then don't bounce off block */
X				if (Killer == True)
X					return True;
X
X			} else if (blockP->blockType == PAD_SHRINK_BLK)
X			{
X				/* Paddle shrinking block */
X				ChangePaddleSize(display, window, PAD_SHRINK_BLK);
X				SetCurrentMessage(display, messWindow,
X					"Shrink Paddle", True);
X
X				/* Not a wall so explode the block */
X				DrawBlock(display, window, row, col, KILL_BLK);
X				balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X
X				/* If in killer mode then don't bounce off block */
X				if (Killer == True)
X					return True;
X
X			} else if (blockP->blockType == PAD_EXPAND_BLK)
X			{
X				/* Paddle expanding block */
X				ChangePaddleSize(display, window, PAD_EXPAND_BLK);
X				SetCurrentMessage(display, messWindow,
X					"Expand Paddle", True);
X
X				/* Not a wall so explode the block */
X				DrawBlock(display, window, row, col, KILL_BLK);
X				balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X
X				/* If in killer mode then don't bounce off block */
X				if (Killer == True)
X					return True;
X
X			} else if (blockP->blockType == EXTRABALL_BLK)
X			{
X				/* Extra ball */
X				AddExtraLife(display);
X				SetCurrentMessage(display, messWindow,
X					"Extra ball", True);
X
X				/* Not a wall so explode the block */
X				DrawBlock(display, window, row, col, KILL_BLK);
X				balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X
X				/* If in killer mode then don't bounce off block */
X				if (Killer == True)
X					return True;
X
X			} else if (blockP->blockType == STICKY_BLK)
X			{
X				ToggleStickyBat(display, True);
X				DrawSpecials(display);
X				SetCurrentMessage(display, messWindow,
X					"Sticky Bat", True);
X
X				/* Not a wall so explode the block */
X				DrawBlock(display, window, row, col, KILL_BLK);
X				balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X
X				/* If in killer mode then don't bounce off block */
X				if (Killer == True)
X					return True;
X
X			} else if (blockP->blockType == MULTIBALL_BLK)
X			{
X				ToggleMultiBall(display, True);
X				DrawSpecials(display);
X				SplitBallInTwo(display, window);
X
X				/* Not a wall so explode the block */
X				DrawBlock(display, window, row, col, KILL_BLK);
X				balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X
X				/* If in killer mode then don't bounce off block */
X				if (Killer == True)
X					return True;
X
X			} else if (blockP->blockType != BLACK_BLK)
X			{
X				/* Not a wall so explode the block */
X				DrawBlock(display, window, row, col, KILL_BLK);
X				balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X
X				/* If in killer mode then don't bounce off block */
X				if (Killer == True) return True;
X			}
X			else if (blockP->blockType == BLACK_BLK)
X			{
X				/* Redraw the solid wall block to make sure */
X				DrawBlock(display, window, row, col, BLACK_BLK);
X			}
X		}
X	}
X
X	/* Don't return after returning */
X	return False;
X}
X
X#if NeedFunctionPrototypes
Xstatic void UpdateABall(Display *display, Window window, int i)
X#else
Xstatic void UpdateABall(display, window, i)
X	Display *display;
X	Window window;
X	int i;
X#endif
X{
X	int row, col, hitPos, ret;
X	int cx, cy, step, j, r, ddx, ddy, Hx, Hy;
X	float incx, incy, x, y;
X	float Vs, Vx, Vy, alpha, beta, gamma, padSize;
X
X	/* Update ball position using dx and dy values */	
X	balls[i].ballx = balls[i].oldx + balls[i].dx;
X	balls[i].bally = balls[i].oldy + balls[i].dy;
X
X	/* Mark the ball to die as it is past the paddle */
X	if (balls[i].bally > (PLAY_HEIGHT - DIST_BASE))
X		ChangeBallMode(BALL_DIE, i);
X
X	/* Check if ball has hit left wall and bounce off */		
X	if (balls[i].ballx < BALL_WC && noWalls == False)
X	{
X		balls[i].dx = abs(balls[i].dx);
X		if (noSound == False) playSoundFile("boing", 20);
X
X	} else if (noWalls == True && balls[i].ballx < BALL_WC)
X	{
X		/* If the no walls mode is on then wrap around onto right wall */
X		balls[i].ballx = (PLAY_WIDTH - BALL_WC);
X
X		/* Move the ball to the new position */
X		MoveBall(display, window, balls[i].ballx, balls[i].bally, True, i);
X
X		return;
X	}
X
X	/* Check if ball has hit right wall and bounce off */		
X	if (balls[i].ballx > (PLAY_WIDTH - BALL_WC) && noWalls == False)
X	{
X		balls[i].dx = -(abs(balls[i].dx));
X		if (noSound == False) playSoundFile("boing", 20);
X
X	} else if (noWalls == True && balls[i].ballx > (PLAY_WIDTH - BALL_WC))
X	{
X		/* If the no walls mode is on then wrap around onto left wall */
X		balls[i].ballx = BALL_WC;
X
X		/* Move the ball to the new position */
X		MoveBall(display, window, balls[i].ballx, balls[i].bally, True, i);
X
X		return;
X	}
X
X	/* Check if ball has hit top wall and bounce off */		
X	if (balls[i].bally < BALL_HC) 
X	{
X		balls[i].dy = abs(balls[i].dy);
X		if (noSound == False) playSoundFile("boing", 20);
X	}
X
X	if (balls[i].ballState != BALL_DIE)
X	{
X		/* Check if the ball has hit the paddle */
X		if (BallHitPaddle(display, window, &hitPos, i, &Hx, &Hy) == True)
X		{
X			/* Keep track of how long it was since the last paddle hit */
X			balls[i].lastPaddleHitFrame = frame + PADDLE_BALL_FRAME_TILT;
X			if (noSound == False) playSoundFile("boing", 20);
X
X			/* Add a paddle hit bonus score, I'm nice ;-) */
X			AddToScore((u_long) PADDLE_HIT_SCORE);
X			DisplayScore(display, scoreWindow, score);
X
X			/* speed vector of the ball */
X           	Vx = (float) balls[i].dx;    
X           	Vy = (float) balls[i].dy;
X
X			/* speed intensity of the ball */
X           	Vs = sqrt( Vx*Vx + Vy*Vy );
X
X           	alpha = atan(Vx/-Vy);
X
X           	padSize = (float)(GetPaddleSize() + BALL_WC);
X           	Vx = (float) hitPos;
X           	Vy = (float) padSize/1.0;
X
X           	beta = atan(Vx/Vy);
X           	gamma = 2.0*beta - alpha;
X
X           	Vx = Vs * sin(gamma);
X           	Vy = -Vs * cos(gamma);
X
X			/* take in account the horizontal speed of the paddle: 
X			 * vectorial summ 
X			 */
X           	Vx += (float) (paddleDx / 10.0);
X
X           	if (Vx > 0.0)
X            	balls[i].dx = (int) (Vx + 0.5);
X           	else
X             	balls[i].dx = (int) (Vx - 0.5);
X
X           	if (Vy < 0.0)
X             	balls[i].dy = (int) (Vy - 0.5);
X           	else
X             	balls[i].dy = -MIN_DY_BALL;
X
X           	if (balls[i].dy > -MIN_DY_BALL) 
X				balls[i].dy = -MIN_DY_BALL;
X
X           	balls[i].ballx = Hx;
X           	balls[i].bally = Hy;
X
X			/* handle the sticky paddle special by changing the ball mode
X			 * to BALL_READY so it will need user to press space to start
X			 * the ball moving again.
X			 */
X			if (stickyBat == True)	
X			{
X				ChangeBallMode(BALL_READY, i);
X
X				/* Move the ball to the new position */
X				MoveBall(display, window, 
X					balls[i].ballx, balls[i].bally, True, i);
X
X				/* So that it will auto shoot off if you wait too long */
X				balls[i].nextFrame = frame + BALL_AUTO_ACTIVE_DELAY;
X
X				return;
X			}
X		}
X		else
X		{
X			/* Ball didn't hit the paddle so check if it time to autotilt the
X			 * board as it is in an infinite loop most likely.
X			 */
X			if (balls[i].lastPaddleHitFrame == frame)
X				DoBoardTilt(display, i);
X		}
X
X       	Vx = (float) balls[i].dx;
X       	Vy = (float) balls[i].dy;
X       	Vs = sqrt(Vx * Vx + Vy * Vy);
X
X       	alpha = sqrt((float)MAX_X_VEL*(float)MAX_X_VEL + (float)MAX_Y_VEL*
X			(float)MAX_Y_VEL );
X       	alpha /= 9.0; /* number of speed level */
X       	alpha *= (float) speedLevel;
X       	beta = alpha / Vs;
X       	Vx *= beta;
X       	Vy *= beta;
X
X       	if (Vx > 0.0)
X         	balls[i].dx = (int) (Vx + 0.5);
X       	else
X         	balls[i].dx = (int) (Vx - 0.5);
X
X       	if (Vy > 0.0)
X         	balls[i].dy = (int) (Vy + 0.5);
X       	else
X         	balls[i].dy = (int) (Vy - 0.5);
X
X       	if (balls[i].dy == 0) 
X			balls[i].dy = MIN_DY_BALL;
X
X       	if (balls[i].dx == 0) 
X			balls[i].dx = MIN_DX_BALL;
X	}
X
X	/* Has the player lost the ball of the bottom of the screen */
X	if (balls[i].bally > (PLAY_HEIGHT + BALL_HEIGHT))
X	{
X		/* Make ball start to die */
X		ClearBallNow(display, window, i);
X		return;
X	}
X
X	/* Convert the new ball positions to rows and cols for collision */
X	X2COL(col, balls[i].ballx);
X	Y2ROW(row, balls[i].bally);
X
X	x = balls[i].oldx;
X	y = balls[i].oldy;
X
X	cx = balls[i].dx > 0 ? 1 : -1;
X	cy = balls[i].dy > 0 ? 1 : -1;
X
X	if (abs(balls[i].dx) == abs(balls[i].dy))
X	{
X		incx = (float) cx;
X		incy = (float) cy;
X		step = abs(balls[i].dx);
X	} else if (abs(balls[i].dx) > abs(balls[i].dy))
X	{
X		incx = (float) cx;
X		incy = ((float) abs(balls[i].dy) / (float) abs(balls[i].dx)) * cy;
X		step = abs(balls[i].dx);
X	} 
X	else 
X	{
X		incy = (float) cy;
X		incx = ((float) abs(balls[i].dx) / (float) abs(balls[i].dy)) * cx;
X		step = abs(balls[i].dy);
X	}
X
X	for (j = 0; j < step; j++)
X	{
X		/* Check if the ball has hit a brick or something */
X		if ((ret = CheckForCollision(display, window, 
X			(int) x, (int) y, &row, &col, i)) != REGION_NONE)
X		{
X			if (HandleTheBlocks(display, window, row, col, i) == True)
X				return;
X
X			ddx = ddy = 0;
X			r = (rand() >> 16) % 4;
X
X			/* Find out which side the ball hit the brick */
X			switch (ret)
X			{
X				case REGION_LEFT:
X					ddx = -r/4;
X					balls[i].dx = -(abs(balls[i].dx));
X					break;
X
X				case REGION_RIGHT:
X					ddx = r/4;
X					balls[i].dx = abs(balls[i].dx);
X					break;
X
X				case REGION_TOP:
X					ddy = -r/4;
X					balls[i].dy = -(abs(balls[i].dy));
X					break;
X
X				case REGION_BOTTOM:
X					ddy = r/4;
X					balls[i].dy = abs(balls[i].dy);
X					break;
X
X				case (REGION_BOTTOM | REGION_RIGHT):
X					ddy = r;
X					ddx = r;
X					balls[i].dy = abs(balls[i].dy);
X					balls[i].dx = abs(balls[i].dx);
X					break;
X
X				case (REGION_TOP | REGION_RIGHT):
X					ddy = -r;
X					ddx = r;
X					balls[i].dy = -(abs(balls[i].dy));
X					balls[i].dx = abs(balls[i].dx);
X					break;
X
X				case (REGION_BOTTOM | REGION_LEFT):
X					ddy = r;
X					ddx = -r;
X					balls[i].dx = -(abs(balls[i].dx));
X					balls[i].dy = abs(balls[i].dy);
X					break;
X
X				case (REGION_TOP | REGION_LEFT):
X					ddy = -r;
X					ddx = -r;
X					balls[i].dx = -(abs(balls[i].dx));
X					balls[i].dy = -(abs(balls[i].dy));
X					break;
X			}
X
X			/* Update ball position using dx and dy values */	
X			balls[i].ballx = (int) x + balls[i].dx + ddx;
X			balls[i].bally = (int) y + balls[i].dy + ddy;
X
X			break;
X		}
X
X		x += incx;
X		y += incy;
X
X	}	/* for */
X
X	/* Move the ball to the new position */
X	MoveBall(display, window, balls[i].ballx, balls[i].bally, True, i);
X}
X
X#if NeedFunctionPrototypes
Xstatic int CheckRegions(Display *display, Window window, int row, int col,
X	int x, int y, int i)
X#else
Xstatic int CheckRegions(display, window, row, col, x, y, i)
X	Display *display;
X	Window window;
X	int row;
X	int col;
X	int x, y;
X	int i;
X#endif
X{
X    struct aBlock *blockP;
X	int region = REGION_NONE;
X
X    if (row < 0 || row >= MAX_ROW) return REGION_NONE;
X    if (col < 0 || col >= MAX_COL) return REGION_NONE;
X
X    blockP = &blocks[row][col];
X
X    /* If blocks is occupied then check for collision */
X    if (blockP->occupied == 1 && blockP->exploding == False)
X    {
X        /* Suss out if ball is moving more vertically than horizontally */
X        if (abs(balls[i].dx) > abs(balls[i].dy))
X        {
X            /* Check left and right first as ball is moving more horizontal */
X
X            /* See if the ball intersects with the block's left region */
X            if (XRectInRegion(blockP->regionLeft, x - BALL_WC, y - BALL_HC,
X                BALL_WIDTH, BALL_HEIGHT) != RectangleOut)
X                region |= REGION_LEFT;
X
X            /* See if the ball intersects with the block's right region */
X            if (XRectInRegion(blockP->regionRight, x - BALL_WC, y - BALL_HC,
X                BALL_WIDTH, BALL_HEIGHT) != RectangleOut)
X                region |= REGION_RIGHT;
X
X            /* See if the ball intersects with the block's bottom region */
X            if (XRectInRegion(blockP->regionBottom, x - BALL_WC, y - BALL_HC,
X                BALL_WIDTH, BALL_HEIGHT) != RectangleOut)
X                region |= REGION_BOTTOM;
X
X            /* See if the ball intersects with the block's top region */
X            if (XRectInRegion(blockP->regionTop, x - BALL_WC, y - BALL_HC,
X                BALL_WIDTH, BALL_HEIGHT) != RectangleOut)
X                region |= REGION_TOP;
X        }
X        else
X        {
X            /* Check top and bottom first as ball is moving more vertical */
X
X            /* See if the ball intersects with the block's bottom region */
X            if (XRectInRegion(blockP->regionBottom, x - BALL_WC, y - BALL_HC,
X                BALL_WIDTH, BALL_HEIGHT) != RectangleOut)
X                region |= REGION_BOTTOM;
X
X            /* See if the ball intersects with the block's top region */
X            if (XRectInRegion(blockP->regionTop, x - BALL_WC, y - BALL_HC,
X                BALL_WIDTH, BALL_HEIGHT) != RectangleOut)
X                region |= REGION_TOP;
X
X            /* See if the ball intersects with the block's left region */
X            if (XRectInRegion(blockP->regionLeft, x - BALL_WC, y - BALL_HC,
X                BALL_WIDTH, BALL_HEIGHT) != RectangleOut)
X                region |= REGION_LEFT;
X
X            /* See if the ball intersects with the block's right region */
X            if (XRectInRegion(blockP->regionRight, x - BALL_WC, y - BALL_HC,
X                BALL_WIDTH, BALL_HEIGHT) != RectangleOut)
X                region |= REGION_RIGHT;
X        }
X    }
X
X	/* Return the region combination */
X	return region;
X}
X
X#if NeedFunctionPrototypes
Xstatic int CheckForCollision(Display *display, Window window, int x, int y, 
X	int *r, int *c, int i)
X#else
Xstatic int CheckForCollision(display, window, x, y, r, c, i)
X	Display *display;
X	Window window;
X	int x, y;
X	int *r, *c;
X	int i;
X#endif
X{
X	/* Check for ball to block collision */
X	int ret, row, col;
X
X	row = *r;
X	col = *c;
X
X	if ((ret = CheckRegions(display, window, row, col, x, y, i)) 
X		!= REGION_NONE)	/*nothin*/;
X	else if ((ret = CheckRegions(display, window, row+1, col, x, y, i)) 
X		!= REGION_NONE)	row++;
X	else if ((ret = CheckRegions(display, window, row-1, col, x, y, i)) 
X		!= REGION_NONE)	row--;
X	else if ((ret = CheckRegions(display, window, row, col+1, x, y, i)) 
X		!= REGION_NONE)	col++;
X	else if ((ret = CheckRegions(display, window, row, col-1, x, y, i)) 
X		!= REGION_NONE)	col--;
X	else if ((ret = CheckRegions(display, window, row+1, col+1, x, y, i)) 
X		!= REGION_NONE)	{ row++; col++; }
X	else if ((ret = CheckRegions(display, window, row-1, col-1, x, y, i)) 
X		!= REGION_NONE)	{ row--; col--; }
X	else if ((ret = CheckRegions(display, window, row+1, col-1, x, y, i)) 
X		!= REGION_NONE) { row++; col--; }
X	else if ((ret = CheckRegions(display, window, row-1, col+1, x, y, i)) 
X		!= REGION_NONE)	
X	{
X		*r = row-1;
X		*c = col+1;
X		return REGION_NONE;
X	}
X
X	/* Return the row and column where the ball hit */
X	*r = row;
X	*c = col;
X
X	return ret;
X}
X
X#if NeedFunctionPrototypes
Xstatic void updateBallVariables(int i)
X#else
Xstatic void updateBallVariables(i)
X	int i;
X#endif
X{
X	balls[i].ballx 	= paddlePos;
X	balls[i].bally 	= PLAY_HEIGHT - DIST_BALL_OF_PADDLE;
X	balls[i].oldx 	= balls[i].ballx;
X	balls[i].oldy 	= balls[i].bally;
X}
X
X#if NeedFunctionPrototypes
Xint StartAnotherBall(Display *display, Window window)
X#else
Xint StartAnotherBall(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int i;
X
X	i = AddANewBall(0, 0, 3, -3);
X	if (i >= 0)
X	{
X		/* Make sure that all variables are updated */
X		updateBallVariables(i);
X
X		/* Set up animation for ball creation */
X		SetBallWait(BALL_ACTIVE, frame + 1, i);
X		
X		return i;
X	}
X
X	return -1;
X}
X
X#if NeedFunctionPrototypes
Xint GetNumberOfActiveBalls(void)
X#else
Xint GetNumberOfActiveBalls()
X#endif
X{
X	int i;
X	int t;
X
X	/* Zap through the list of balls */
X	for (i = 0, t = 0; i < MAX_BALLS; i++)
X	{
X		/* Found an active abll - add to total */
X		if (balls[i].ballState == BALL_ACTIVE)
X			t++;
X	}
X
X	/* Return the number of active balls */
X	return t;
X}
X
X#if NeedFunctionPrototypes
Xint GetAnActiveBall(void)
X#else
Xint GetAnActiveBall()
X#endif
X{
X	int i;
X
X	/* Zap through the list of balls */
X	for (i = 0; i < MAX_BALLS; i++)
X	{
X		/* Return this ball */
X		if (balls[i].ballState == BALL_ACTIVE)
X			return i;
X	}
X
X	return -1;
X}
X
X#if NeedFunctionPrototypes
Xint IsBallWaiting(void)
X#else
Xint IsBallWaiting()
X#endif
X{
X	int i;
X
X	/* Zap through the list of balls */
X	for (i = 0; i < MAX_BALLS; i++)
X	{
X		/* Ok it must be on the paddle so shoot it off */
X		if (balls[i].ballState == BALL_READY)
X			return True;
X	}
X
X	return False;
X}
X
X#if NeedFunctionPrototypes
Xint ActivateWaitingBall(void)
X#else
Xint ActivateWaitingBall()
X#endif
X{
X	int i;
X
X	/* Zap through the list of balls */
X	for (i = 0; i < MAX_BALLS; i++)
X	{
X		/* Ok it must be on the paddle so shoot it off */
X		if (balls[i].ballState == BALL_READY)
X		{
X			/* Change the balls mode so that it shoots off */
X			ChangeBallMode(BALL_ACTIVE, i);
X			return True;
X		}
X	}
X
X	return False;
X}
X
X#if NeedFunctionPrototypes
Xvoid ResetBallStart(Display *display, Window window)
X#else
Xvoid ResetBallStart(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int i;
X
X	i = AddANewBall(0, 0, 3, -3);
X	if (i >= 0)
X	{
X		/* Make sure that all variables are updated */
X		updateBallVariables(i);
X
X		/* Add 2 bullets every ball death or creation as it happens */
X		AddABullet(display);
X		AddABullet(display);
X
X		/* Set up animation for ball creation */
X		SetBallWait(BALL_CREATE, frame + 1, i);
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void AnimateBallPop(Display *display, Window window, int i)
X#else
Xstatic void AnimateBallPop(display, window, i)
X	Display *display;
X	Window window;
X	int i;
X#endif
X{
X	static int slide = BIRTH_SLIDES + 1;
X
X	if (frame == balls[i].nextFrame)
X	{
X		/* We are imploding so go backwards through slides */
X		slide--;
X
X		/* Wait for the next frame */
X		balls[i].nextFrame += BIRTH_FRAME_RATE;
X
X		/* First frame is to clear the ball away */
X		if (slide == BIRTH_SLIDES)
X		{
X			/* Clear the ball area */
X    		EraseTheBall(display, window, balls[i].oldx, balls[i].oldy);
X			slide--;
X		}
X
X		if (slide < 0)
X		{
X			/* Erase the ball birth image */
X			MoveBallBirth(display, window, 
X				balls[i].oldx, balls[i].oldy, -1, True, i);
X
X			slide = BIRTH_SLIDES + 1;
X
X			/* Stop the ball by killing it! */
X			ClearBall(i);
X			ResetBallStart(display, window);
X			DeadBall(display, window);
X		}
X		else
X			/* Draw ball birth - handles ball moving as well */
X			MoveBallBirth(display, window, 
X				balls[i].oldx, balls[i].oldy, slide, True, i);
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void AnimateBallCreate(Display *display, Window window, int i)
X#else
Xstatic void AnimateBallCreate(display, window, i)
X	Display *display;
X	Window window;
X	int i;
X#endif
X{
X	static int slide = 0;
X
X	/* Draw the ball birth at the new position */
X	MoveBallBirth(display, window, paddlePos, 
X		PLAY_HEIGHT - DIST_BALL_OF_PADDLE, slide, True, i);
X
X	if (frame == balls[i].nextFrame)
X	{
X		/* Next slide thanks */
X		slide++;
X
X		/* Frame that will trigger the new slide */
X		balls[i].nextFrame += BIRTH_FRAME_RATE;
X
X		if (slide == BIRTH_SLIDES)
X		{
X			/* Erase the ball birth image */
X			MoveBallBirth(display, window, 
X				paddlePos, PLAY_HEIGHT - DIST_BALL_OF_PADDLE, -1, 
X				True, i);
X
X			slide = 0;
X
X			updateBallVariables(i);
X
X			MoveBall(display, window, paddlePos, 
X				PLAY_HEIGHT - DIST_BALL_OF_PADDLE, True, i);
X
X			ChangeBallMode(BALL_READY, i);
X
X			/* This frame will trigger the auto shoot off the ball if you
X			 * don't press space within a specified time 
X			 */
X			balls[i].nextFrame = frame + BALL_AUTO_ACTIVE_DELAY;
X		}
X		else
X			MoveBallBirth(display, window, 
X				paddlePos, PLAY_HEIGHT - DIST_BALL_OF_PADDLE, 
X				slide, True, i);
X
X		if (paddleIsMoving())
X			updateBallVariables(i);
X	}
X}
X
X#if NeedFunctionPrototypes
Xint GetBallMode(int i)
X#else
Xint GetBallMode(i)
X	int i;
X#endif
X{
X	/* Return the current state of the ball */
X	return balls[i].ballState;
X}
X
X#if NeedFunctionPrototypes
Xvoid ChangeBallMode(int newMode, int i)
X#else
Xvoid ChangeBallMode(newMode, i)
X	int newMode;
X	int i;
X#endif
X{
X	/* Change the ball mode */
X	balls[i].ballState = newMode;
X}
X
X#if NeedFunctionPrototypes
Xstatic void SetBallWait(int newMode, int waitFrame, int i)
X#else
Xstatic void SetBallWait(newMode, waitFrame, i)
X	int newMode;
X	int waitFrame;
X	int i;
X#endif
X{
X	/* Set up the ball waiting loop */
X	balls[i].waitingFrame	= waitFrame;
X	balls[i].waitMode 		= newMode;
X	balls[i].ballState 		= BALL_WAIT;
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoBallWait(int i)
X#else
Xstatic void DoBallWait(i)
X	int i;
X#endif
X{
X	/* Once the waiting frame is reached then activate new state */
X	if (frame == balls[i].waitingFrame)
X	{
X		balls[i].nextFrame = frame + 10;
X		balls[i].ballState = balls[i].waitMode;
X	}
X}
X
X#if NeedFunctionPrototypes
Xint AddANewBall(int x, int y, int dx, int dy)
X#else
Xint AddANewBall(x, y, dx, dy)
X	int x;
X	int y;
X	int dx;
X	int dy;
X#endif
X{
X	int i;
X
X	/* Add a new ball to the balls array */
X	for (i = 0; i < MAX_BALLS; i++)
X	{
X		/* Is the ball free for us to use? */
X		if (balls[i].active == False)
X		{
X			/* Make sure that it is clear */
X			ClearBall(i);
X
X			/* We have found a new ball spot so setup the ball */
X			balls[i].active = True;
X			balls[i].ballx 	= x;
X			balls[i].bally 	= y;
X			balls[i].oldx 	= balls[i].ballx;
X			balls[i].oldy 	= balls[i].bally;
X			balls[i].dx 	= dx;
X			balls[i].dy 	= dy;
X			balls[i].ballState = BALL_CREATE;
X			balls[i].slide 	= 0;
X			balls[i].nextFrame = frame + BIRTH_FRAME_RATE;
X
X			return i;
X		}
X	}
X
X	/* No more free balls available */
X	WarningMessage("Cannot create a new ball - all active.");
X
X	return -1;
X}
X
X#if NeedFunctionPrototypes
Xvoid ClearBall(int i)
X#else
Xvoid ClearBall(i)
X	int i;
X#endif
X{
X	/* Clear out the ball structure */
X	balls[i].waitMode 			= BALL_NONE;
X	balls[i].waitingFrame 		= 0;
X	balls[i].lastPaddleHitFrame = 0;
X	balls[i].nextFrame 			= 0;
X	balls[i].newMode 			= BALL_NONE;
X	balls[i].active 			= False;
X	balls[i].oldx 				= 0;
X	balls[i].oldy 				= 0;
X	balls[i].ballx 				= 0;
X	balls[i].bally 				= 0;
X	balls[i].dx 				= 0;
X	balls[i].dy 				= 0;
X	balls[i].slide 				= 0;
X	balls[i].ballState 			= BALL_CREATE;
X}
X
X#if NeedFunctionPrototypes
Xvoid ClearAllBalls(void)
X#else
Xvoid ClearAllBalls()
X#endif
X{
X	int i;
X
X	/* Clear all the balls in the balls array */
X	for (i = 0; i < MAX_BALLS; i++)
X	{
X		/* "Clear the ball" - in an American accent */
X		ClearBall(i);
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid HandleBallMode(Display *display, Window window)
X#else
Xvoid HandleBallMode(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int i;
X
X	/* Loop through all the balls */
X	for (i = 0; i < MAX_BALLS; i++)
X	{
X		/* Only handle active balls - sounds disgusting! :-) */
X		if (balls[i].active == True)
X		{
X			/* Switch on the state of the ball */
X			switch (balls[i].ballState)
X			{
X				case BALL_POP:		/* Ball pop animation */
X					AnimateBallPop(display, window, i);
X					break;
X
X				case BALL_ACTIVE:	/* Animate the ball normally */
X					if ((frame % BALL_FRAME_RATE) == 0)
X						UpdateABall(display, window, i);
X					break;
X
X				case BALL_READY:	/* ball created and waiting to move */
X					if (paddleIsMoving())
X					{
X						balls[i].ballx = paddlePos;
X						balls[i].bally = PLAY_HEIGHT - DIST_BALL_OF_PADDLE;
X
X						MoveBall(display, window, balls[i].ballx, 
X							balls[i].bally, True, i);
X					}
X
X					/* After a certain number of seconds fire off anyway */
X					if (frame == balls[i].nextFrame)
X						ChangeBallMode(BALL_ACTIVE, i);
X					break;
X
X				case BALL_STOP:		/* Ball dead and stopped */
X					break;
X
X				case BALL_CREATE:	/* Create ball animation */
X					AnimateBallCreate(display, window, i);
X					break;
X
X				case BALL_WAIT:		/* In wait mode waiting to change state */
X					DoBallWait(i);
X					break;
X
X				case BALL_DIE:		/* Ball is going to die */
X					if ((frame % BALL_FRAME_RATE) == 0)
X						UpdateABall(display, window, i);
X					break;
X
X				case BALL_NONE:		/* Really cool mode ;-) */
X				default:
X					break;
X
X			}	/* Ball modes */
X		}	/* If active */	
X	}	/* For loop */
X}
END_OF_FILE
if test 43559 -ne `wc -c <'ball.c'`; then
    echo shar: \"'ball.c'\" unpacked with wrong size!
fi
# end of 'ball.c'
fi
if test -f 'bitmaps/exblueblock1.xpm.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/exblueblock1.xpm.uu'\"
else
echo shar: Extracting \"'bitmaps/exblueblock1.xpm.uu'\" \(1419 characters\)
sed "s/^X//" >'bitmaps/exblueblock1.xpm.uu' <<'END_OF_FILE'
Xbegin 644 exblueblock1.xpm
XM+RH@6%!-("HO"G-T871I8R!C:&%R("H@97AB;'5E8FQO8VLQ7WAP;5M=(#T@
XM>PHB-#`@,C`@-"`Q(BP*(B`)8R!.;VYE(BP*(BX)8R`C-#DT.3DX.3A&1D9&
XM(BP*(E@)8R!B;'5E(BP*(F\)8R!M961I=6T@8FQU92(L"B(@("`@+BXN+BXN
XM("`N+BXN("`N+BXN("`N+BX@("XN+BX@("XN+B`@(BP*(B`@+BXN+BX@("`N
XM+BXN("`N+BXN("`N+BX@("XN+BX@("XN+B`@+B`B+`HB+BXN6%@@(%A86%@@
XM("!86%A8("!86%@@(%A86%@@(%A86"`@6"YO("(L"B(N+B`@(%A86%@@(%A8
XM6%@@("!86%@@(%A86%@@(%A86"`@6%A8("!O(BP*(B`@6%A86%@@(%A86%@@
XM(%A86%@@(%A86%@@(%A86"`@6%A8("!8;V\B+`HB+BY86"`@(%A86%@@(%A8
XM6%@@(%A86%@@(%A86"`@6%A8("!86%@@("(L"B(N+B`@6%A86%@@(%A86%@@
XM(%A86%@@(%A86"`@6%A8("!86%@@(&]O(BP*(B`@6%A86"`@(%A86"`@(%A8
XM6%@@(%A86"`@6%A8("!86%@@(%A8;V\B+`HB+BY86"`@6%A86"`@6%A86"`@
XM(%A86"`@6%A8("!86%@@(%A86%@@("(L"B(N+B`@6%A86"`@6%A86"`@6%A8
XM6"`@6%A8("!86%@@(%A86%@@(&]O(BP*(B`@6%A86"`@6%A86"`@6%A86"`@
XM6%A8("!86%@@(%A86%@@(%A8;V\B+`HB+BY86"`@6%A86"`@6%A86"`@6%A8
XM("!86%@@(%A86%@@(%A86%@@("(L"B(N+B`@6%A86"`@6%A86"`@6%A8("!8
XM6%@@(%A86%@@(%A86%@@(&]O(BP*(B`@6%A86"`@6%A86"`@6%A8("!86%@@
XM(%A86%@@(%A86%@@(%A8;V\B+`HB+BY86"`@6%A86"`@6%A8("!86%@@(%A8
XM6%@@(%A86%@@(%A86%@@("(L"B(N+B`@6%A86"`@6%A8("!86%@@(%A86%@@
XM(%A86"`@(%A86%@@(&]O(BP*(B`@6%A86"`@6%A8("!86%@@(%A86%@@(%A8
XM6"`@6%A86%@@(%A8;V\B+`HB+BYO6"`@6%A8("!86%@@(%A86%@@(%A86"`@
XM6%A86"`@(%A86&\@("(L"B(@;R`@;V]O("!O;V\@(&]O;V\@(&]O;R`@;V]O
XM;R`@;V]O;R`@(&\@(BP*(B`@;V]O;R!O;V\@(&]O;V\@(&]O;R`@;V]O;R`@
X/;V]O;R`@;V]O("`B?3L*
X`
Xend
END_OF_FILE
if test 1419 -ne `wc -c <'bitmaps/exblueblock1.xpm.uu'`; then
    echo shar: \"'bitmaps/exblueblock1.xpm.uu'\" unpacked with wrong size!
fi
# end of 'bitmaps/exblueblock1.xpm.uu'
fi
if test -f 'sounds/whoosh.au.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sounds/whoosh.au.uu'\"
else
echo shar: Extracting \"'sounds/whoosh.au.uu'\" \(10674 characters\)
sed "s/^X//" >'sounds/whoosh.au.uu' <<'END_OF_FILE'
Xbegin 644 whoosh.au
XM+G-N9````"```!X/`````0``'T`````!``````````!G7U5555==9W?GX]O7
XMU=/1S]'/T=/=W^/O__]W=___=W=O9V=?7UU?7V-G;W=W=W=W=W=O;V]W_^??
XMU]73T]7=X_=W9UU;5U5555=75U=755-134Q+3$Q/45-;75]?7V-C8V=G;W?O
XMY^/7U=/3V]_G_V]C7U]?7V-C8V=W__?OW]W7U]75U]_G_V]C75M;75]C9V]O
XM;W=W]^?CW=O;V]W=W]_CX^/CY^____?W]_]W9U]=5U555UUO=^/=U\_/S]/7
XMY_]C75U?9_?GW]O;W^/GY^?=V]77V^/W8UU75UMG__?CX]_=W>/G_W=?75M;
XM5UU;6U]=6U=776/_[^/7T]/7W>__9V-?7U]?75M755-355M=9V______]^_O
XMX^/?W=O7U]73T]75U]O;W=W=W=_C[_=O9V=O]^_CU=/1T=7C]V-=6U=;;_??
XMT<S*R\W?]UM33$M*2TQ/45-76UM=75]?7UU=55-/45%145534U-56U]O__?=
XMV]'1U=_W5U%,1T9&25%;9^/=U=/3U=?C[W=;4TI&14-$2D]OY]O+R<;&RM?O
XM54Q&0$!&2U?=S<"]O;_#S]MO755/3T]355]G[]W3RL?'R<O;[U5+13X^0493
XM7W?;T\S*R\W3[V]=34I'24M;=]7/S,_3[V=134M+35UOY]?3U=OG75-+2TM/
XM6^?7R\G*T]];3TQ,3U__X\W*P\'#RLW=X_]O9UM74U==;__CW]O5U=?;W^]W
XM7UM75U=;5U5555M?_^/=T<W*RLK,S]OC=U-*0#X]/T5CW\"[M[2UN\#-548[
XM.3D\/TI16_??U=/3U=OW;U5/2T='2TU5_^/+Q\7&RM/;XW=C5U-14U5C=^?C
XMW^/G9U]734I)2DU;9^/?U]73U=OG[_?W[_?____WW]O5T=/7W>-O74U+2DU3
XM=^/1S<S/UV=32C\_1$M5Y]7*R<K3XUU/24E*35%;7V]W;UU544Q/6V?WT\W%
XMP<#$R>]=1D`]/#U'47?$N[&PL+>]XU=&.3<X.TI=W\&\N+BZOL'/U^=?54U,
XM3U=?;__GW]_CY^_OY^/?U]?7W^-O75-+2DM+3$Q-55=?7V-C9^_=T\W/[V=7
XM14`\/3Y)4]7&O;>WO,'G6TH_/T!%2F_=P;RZNKS&S]];34`].SU`56_3S,G$
XMQ,S7]TM#/3U`3%7_Y]W3U=W?W]W7Q\"[O+[=5SDR+RTO/4_GO+:SM<#38SXZ
XM.#H]36/3S,O1V_]W=_?GU<_,T==O5TI)25OOQ+^\O;_1[UM%0#T^05W?O[NY
XMO,1G1S0P+R\S/TWWP;RXN;W3;S\[.3Q$[\^]O+N]OLG;8STV+S`V3]^ZM*^M
XMK;"VOU$]+2LM,3KGQK.OK:ZSR?]*-"\N,#=/Y[ZYM+2VOL=O448]/4E;W[ZY
XMM+6WO\;G8U-)1TQ3]]W5S,S+RL?%Q<;)S-OC7U=34UOCT\K`O\3)XV]=45%C
XM]]O*R=/O6T`\.#<X/45?Y\W,T>=G24,_/S]%2U%C8U-+1#T]2U_CR\K5YT]$
XM/3<W.3Q`6_?-S='=W^?O=UM334Q)24E-4V_GT\"]N;S!=TLW,S(Z1-/`NK:Y
XMS/\_.SH^1]O&O;>VO<K=4TM+45_3R</$R=OG7U-)2U?1Q+>TL[>\WUM)/S]*
XM6^>_N:^MK[.\=TL\/#]CU;FTLK>\S^==0SY$5=VYM+.VRN=3/#<W.CU;V[FQ
XMK[2^2SLT,SA,_[ZZN<;723\[-C=!4^._O<#&S?]703T\/#Y,7\S$P<SG13T[
XM/$!;[]7,S_=C540^.CP_4V/W]W=C5TQ)2DQ1;^_7U=7?;TM&1TM*1D9*35OC
XMT\2_O\SG1D%&8^?5T]7G8T5!16_;RLK,RL2]OLW?_U]51T5&7^/,S,_?W]?3
XMV]W;S\S3XV]?9_?_;UU=[]W;8T]`/T1=Y\?%RLW3YW=323\R,#0[2[ROIZ>K
XMP?\W,2XT.E'WQ;^_Q<K'O[R\O]UG4T4^.SY+R\"^Q-WW=]O-S]OO5U%,3U_)
XMO[BZOV]*0TQCS\S-S='7W^/5P;_`U5\^/43?S,G/WUM58_?/S]-?1S8W/>_1
XMRM/W3$I7_]?#P,?58T`_5?_/T=UC4TM-6\_$O;_+5TI$1DI355M755533$_?
XMS\K3[T4].T!+U\O%R]=-1417=]_C]_?CU]7/T=U+0#T_1M?'Q<S=W]7-T]WO
XM]U%%/T55R\#!RMU14^?7U=W?9U%)1$S;S<S1W5]7=]W5W>]/1#PT-4S7O;&S
XMRE]`-SQ7[]'1W4H]-SD_[\2QL+?W2CY#3-W*OL'-0S@Q--VWJJ.GQE=`15^\
XMMK7'72XI)S5;JJ.CJKI%/$WGR[^_YTDW+2Y$W[ZMK;?#WTI&35W*P\5=138T
XM.5?;O[Z_TU\^/T?+O+F^7TI!04O;S,O;[V?_X]/1T]77W]W)R=%C445'X\:Z
XMM[]'.3,V/=_$O,#-2STY5\FOL+I).30W/413U<S)Q\GO5T5%3-W+Q\O52CPV
XM.$EGU;^_W5,_-SS_R\//8SDS,CQ1O;>VS%$[/F_1Q<GG03T]3_^\M;.]RD`V
XM,T!;O;B_T7='2^/+O[[)=V-C=^?1U=OO_]?/TU]/3$U-8\^\O=MO8]W-Q]'G
XM341`3]VYM[K!VSXW/$K&O+K35SP[/7?%KZ^U]T4Z0_>ZOU$].CU&W\JXL[+-
XM1"LL,>^\K[?&/S4M,#S&MZRN;S,G*C:_KZJTT3`K*C[7K["Z7T4U-4S;OK2W
XMXTH^3/_!O;N_RLO%P\KG0#U`_\JUL[O+;TE-Y\_#MK*SO><T,4S'LJZ\.C`Q
XM7[ZJJKWC3#P\2EWCO[W30RXG+&.ZJZ:K8S,E)BI7OZZRO$LZ-CQ%_]_C[]O)
XMRUT_-#[?KZ_W/"\P0;:MKLQ/-#E+MZ^WQ.]$/SY#8\^\L;E&-"TQ/KROK<=!
XM*2LTX[RNL;I?/3$T2_?*O<'W3#]%6UM)0TI3]^=O6_]O7V/=YTU+X\K`Q_\^
XM.30\5[V\NN]!/$==Y^]?=[BMK<%G+BTVO:^MM]TX-#I$;\#`P+NZXU-*8[RW
XMN?=*.SH\6^?!NKG+UU]+04!)RL#?5TQ==V=52S]*O;2RP6,Q+2LW5;FXO-M/
XM,RX[4]&MI['10"\S/CLS,3?1L*BT72XU2KBMK+D^.46_OSTN*3;5GY^F/2T_
XMQ:ZIL3HM0\RWON<]/#_,NK?#=V/'MK[O,2[GM*N_/R0HW[>NL\HT-#W=S4T]
XM/6/1MK?#-S%/P*RQQS$O9\S+_U?=P[R\O^]53$I%9\J^O\_=S^=OW[S#23P[
XM=\O!YSTH++NIIL8^*"Q`KJK3.2DP4[2W1#`M5[RLMF\F)#[!K:ZW6T?OQ+FY
XMS38V0+RROV<\+CJLH9^MT2\P/+^V_SPU1=&NLC\O+=.LH:O&*RA)S+W;1"TO
XMW[:LL<TO+SN\L;?%_TM155OCO,$Z-#S`MKK1/4E?9W??W\W%9RTO3:BL2S$L
XM-E.WO]M=54E,2U=?/"XM0[^KM3HK*LVKHZS-)B-%OZRPOU55R]'_S+:NN<Q#
XM/\>VN3<L.$S5KZNSP#@L+;FGK<9+.C_1QM\W-TM3]]MW5V^\O,/-VSDS-]O$
XM7SDN1L;#_TH^/__#M[7#/T!*0#Q&X]-72KRRQD4O-TG-XTQ+6]&WK<1%,4:O
XMK;D\-^/75T!%R\=G-CVZKZ]?/%>]J*W,+3/!ON,V1J^MQR4GO*NL8SI'S;W!
XMS-W%MLE'.%NUM]<F)[:FJ4<VQ[2]+2S%K:WG+2]/T=/C/#^PKL$I)ZZ?GRT?
XM+<:GLDHO3;.WR2XEYZZM/"DQRJS-+R0SQJN_+2T]L*Y`)2(_LI^K)B`INK-7
XM-S2_L>-&/].XM]TJ)S"KH]\S*DO`P6]&T;:IKLHY/KJKIV<J+5NLLV\V0;BQ
XMO#@TOJVJVT_-LZJS=RLTN;3#047G]U=&0T%,W;J\Q,G*S\I*/T6UKLU,X[R_
XM03DV/$R^O$H\/#Y?KKM!*T>?H;DM-[FR[T0]1TI$4<W'2D^XKCDI3*Z@QR\E
XM-ZNLQ2DK2]6_]T=`_[R_53$[8\#5-RLJT[7).B(E.:2H+2(EQ:NGO3PG,+6K
XMKD$O-U_,33QWM[/,1C$]MZNM0S5)V\3,WT1`254\U:ZFK;])2;RNL3@MOZ6A
XM020WOZ:O6RU$L*6].E^NN5])=T='S*FV)28]H9\X'Q^NGZXU*D6_NMU;6SPY
XM4^-!.[^VYU,V)S2OL<E#/SI=LKY=,S>_LKL]XZ^]13=!2TM,15WG04"]J,DZ
XM/\JMK-<U2LJ_6SI1]]_59SHM,5^@H4PS/:RGO$H\44]1RL1/1;W$9R$?2Z>?
XM6R$FO9^N+B%'K-<L0[BWUTTN-\Q*,TF_O%$T;[31,B0RR<!+SZRDN4\N1+FZ
XM0R<TO*6V+S+5QW=`]\3+T;*LK<TYW:_&/"H]S]<^.LFPU4I`7;ZGM$-)Q:W7
XM/=_3.S-'U<4X,,.HQ3,G6[.GK\7=S+7*/4?G/S0S6\'`W4-#Q,MG47?CQKNM
XMN5W#I[%**2I&M+??+BY5UUW!N2LDOZ*A-2+GHY\K'[&?J"T]L[]CV\U;031-
XMN:_7*R]3M,LM,%6ONB\\O**P-3^HK,HX9[9?,#+?L,P[3\#!,"7WO.=&0$S,
XML<4^1D8\T<TS(3-W/3EGKDDL=[A3+C;5L[I3/<NW73O=P&<R'S"VJE\I4:]-
XM-3ZONCCGHZ;`/N===\N]/1]3HE$FX[M3)T:JNN=&0[.N-"S_J<PK/U=+M[L]
XM-*BK'Q\[J?\\T?=O[T0WO::B/D"YO<M'W;"V]S<_NKY)-TNZP3,L,TMCM+&Q
XMK;(Y,4VDJBTL]Y^L)"5`GZHG*;VIJ"\DQJJCS3DS=[:Z.RE*MO\D*Z[=(B6?
XMH%<^3%$VN;',U;A?/STV34`[1%'-YRU;I)]G3+NZQN_71=6NNG=&+BZUP#,S
XMN:>J)BJRNLQWT[EW-K2A/"`II:TM+#6IL1\GHJA!)>^^74?*OS,[P+/_*$^P
XM1$7,Q+T]/,WC-3_7J[7&M+I5S]<[0Z7W+=W+/TRDKRPV9T4ES*JM7=M'6\17
XM-\2IIRDCK[1+(D6GQ"@ZVRHOK<,K15\L+3V[J,1)1;RO0"WON<<ZS+\V'V.P
XM.RT^J;4?'_^?JBI1L[G=+#Z?L#FXGR0?'Z>K*2O*H+P?*;RG5R5!K[!O/$2Z
XMO$^^KRXO-[2@6R,FGY\B(KV?P"9)JN<N+CJCI.<WP-LT+*>?+A\EGY\?'[V?
XMPR]1L+T_*-V?JCK-O"PJ3Z2E-S!7YSTK0:W3+*^E24M7,L6?ORK;LCHR0[[)
XM+C3_USHVR4PH+J&^*<:G/"ROQA_CGS(A5:DW)\:DLUTJ.3`QQM$YNJRV1"Y`
XM,A^TG\!*_[YW/$.\RDHO+LJ_7RT]JJW*0U'$0",VKI_'*K>K.5W`1CM1/;>]
XM/24\K*U;,SJJMS8G2:3/O*2^(-&K3$J\S,G,Q3`LQ*_#3-=#S:=W*K.TQ;-=
XM+=6NOK^\][R^2C?WKETJK*H?++#7*::G/<"Z-.>I4RNMLR0UPS$IH:TFQJ$P
XM,4UG8[.O,\RG(B*?M!_-GR<?.:-O*M^D*A_7I2,JOS\_N5$Z+C.WQT7ON2LJ
XM1,0X-MVBLRLK8U4X;_<PI*I'-/_C06.WL\IWYV]/3+:J_SFHJ"O;K\$]4:^?
XM/"GG]]U?0*6?M4M?1<6HW2^UW2XYVV>^YW=&G\8?(N?#)4R?MR@WND/#K;7&
XMMB,@.;Q?M+3O,32\S!^VGQ\?GZ`_YZMGO\$[J#H?-+QGT;_%.&\W-JU,.I^C
XM'T>D+2.]/3&S0SW`R4?+*C2EQC&DJSFOL<JZ4RHEO4\XRZDV):W?']^NS#HB
XMIJ$?9Z,O)ZTQN*`])K&IVTNEMB?GLR@DIJ<F*3HX+4W*NE?'5S=7KRX]GY\C
XMP%,?)I__)W>D0R&S3"]GQ3H[J4`EQ=%'1T2I13VHOS-7K<,V5;]W5[=;.6//
XMP,6\,RRZ/B2VK6<SQJNGS[!+,UW&Q?^TGRTFI*TLJY\H1*4K'Z*G*"JKS".H
XMG]TTGTTJXZ*Y4:R\2BJIL3J?GR,FM#A3.2V^VTH^3[JJS,>I-S3?03:\+V=&
XM++:M/#-/+V,J'T5O.B9/IRHSG[\ZS+\?(I^_)$:I+#&O)T]-'RNW2_=3ST$L
XM1%?!M7>]J"0PM[!-/Z&G+;LM.:LA*Y\T*[?-KSTMJ*W*GR@\JU$_T==WN3F[
XML^]#M#-+I#<G-;V\1BK;KK6D_R=+N,#7132T*A^?Y^>G/&.VPSHK9ZU;.RS'
XMK-O=*T6M8ZLI.;/?*9]7R;2^Q^.NIU5#GUU*43*K=\3/0_^SJB(?M3TLI[0O
XMQ\]`1D2CL?^TO;#_.+"VOZ['2V?'Q$=!9S,HXR_%M*XM)Y^_'[JK+;TA.K#$
XMQ]5O1U\T57=*O3E?_\PS0+4L)I]O'^_3,V>V16>LRL-1Y\-W,\7!R]6W+)^Q
XM/K;W-,0Z'Q^_XT2WNRFP+/^J-L0ZM[6XJW=)+^^WP#@],\0OP20HS3`JL*^J
XM*S6[W:`C=[`MISHHK42KNB^X.:RF,+2Q,\J],JRK*:VC,)^G*[2]-[DQJJHW
XMJR-CP#O**4;W,2ZL-E6OOMNJ*"3!-C!`(#RQ/:$O'Z(YI[9+73P^M#\M3[0?
XMHZDZH=LZI:E?SSR?HRJI+2*BL+E,NC/_[[[%)=VB.;@Q2JT@UZFG/#Q1P#]5
XM1[DOO<1/2ZPJL.\LQ3"]0:TI'Y\S,I^N_\RYS%5G[[Q!,:RA+%?#44?_KJXA
XMGQ\ORQ\S.A^?3Q^?M+B?42^D(#2LJV^\OS^IPZSO+;FS+:HL/Y\F,$L?/<<M
XMGTDEMJ$?KLO3/*<?GSE7/Q^KO+4NO4==KR!1."KO+K@]2;?#-MTMG[DZ]T&_
XMO;IGO#JCJ"FD'U-)'V?/MR1)P3&?'[>?'[RJ0S<VST\NY[0TU:0NJL/)GQ\W
XMH2FL'R*R1KE#N\0M,;G&-,R?(O='+UW32Z:?+)^A'SBW.$\O)]U,,=_WVSHH
XMO\.HG_];1,4UK"/5NJ\US*PSXU<SLSA?LZ8@HY\HNZ\K1Y^H-KI;K[V](<=/
XM54VJ4:^Y/2VZ/#R?RA^A6]?;Y[8GGT,?M"^]I3FNQZ^L+Z-7O"RB.2YG/M_7
XM[[8?I-6Q]S>C.+-7([VD5U-GJJ0K3;<G,V<[RC!#/#>A11^?=Y]='Y_?KJY5
XM8ZM;RS_WJ3.VNA_,5Q^HL3&LM"K`OCBO1=<N.J8S3:;1RRHT6Q_$-B_)'TFJ
XM(\O#.:N?'S^GQJ[_H2BSRZX?J,#,33BBRBB?;U'`))]!O.<UM<0J(J\I7V^U
XM2B[+N?\NM&=-*CT[HBX\(2NVWZ=,VRVXGR3&);>P4Y_/WR^Y-\DH/S3_*LGW
XMHSJQ/*Q#S]V]+3FH(">N'[PC3+O/S4R?,+5-1"2],[$W-"?+-JJN/#.C3Q^A
XM.K#)-[TGL[GOO4^?NF>V+4^V+D2K+9\LI\>L6TG_L"0PS:\W.JTCJ=^^.N<E
XMIA^I'RXH+:93LJ=?I:V^4:=*I#S5I4FOLT<M3#]OOZ0PGT^J=S&G/)\ZK:;/
XMLR>?'Y\J1Q\M/;\YM,S#H25)*:<BITM%+<I%G]VM'ZT[K!_`*">H/[#!-$/G
XM7\VP.;4ZP]&X*R-/+T:KW<2S,SPZ)[0?-RNUGRJ?,JJ_MO_$MBBI'Z$?S1]?
XM(2<H;[6\GQ_*IB6?'[J@MZ0UJF^\+J$F/&,X-3E5K+1)MB!);SDXGZ@MK[Y1
XMIN-!HS&?'Y^M-,:O-3:G+;G_'Y_$L\6X*+DV2LO#.>/%+-&MJK=3GU6@7_^M
XM[[35IB\N1B1/W\?ON"RJ._]3O[8TJ[8LM[:?)==/IV,RRL5CQ#\L(ZVU,RFC
XM]Z@?HZF_I"ZHL%=*+\H[K[%+NJNV.3<_T2;3+S`NIK*WN+:IU3>T+\^L)+TS
XM[RE,T5?5T;XC7S"Q*[`A3S`PMDV?49\LVRJ_12M=++P?J3B?+TPO(*OWV^_?
XMHK\JMR:?,BDAQCA)JS5-Q]M*K\G**B<V.[Q7P!_?1+?/=S"?4ZTR+\=,)BNB
XMO:NI*\8R(T35,[@CH2NR)JDZ+K<XUQ^S,:\WN#"TP<U&*<9CIJNSK[\^'T\A
XM41^PJ$"^KRY?)ZTK'Y\QI""?T;=!-DT]JZS!1\0K1[8?GS6[+2NV'[U7OK$U
XMJ^-ON;2D0:X?H3.LJ]&L*B=G*D77JBR?/3XQ+:9?N$^@,R\YI3PU*3Q&43BE
XMO2VI=[;5()_;MB_&+D5$,2!;19_GP:EO-MVX+SDSGT/1(6_'RZO-5SHL,Y^S
XMII]GK4Q5+3/3KJD]2C8?PS\]2\:I-;HC,#XAI\>N[Z(ZK3NL*I\?H3F?QZ4M
XML2&?,9\OGR7-;Y^E6[_$9SD^NC`W+D0X0#,AN\6MNO?-U2JHJD6H=[(BMCJ?
XM1"*LP,V[.M]/U1_/0[G$)[(DH3VK/>>],#9O(39*)+^VP;^ZMB/$;T^?)Z8P
XML1^PO*?%'T`?L4O![[2\V],L+"Q?,U&H3Y\L+"51,5-=.<=C*$`PK5NL+ZLM
XMJT:JO$4VR3TZ3"VD2K`LX\$?1ZU=I<<Y3='1+#0?J*^D-JH?OSJ?,,4EKS`T
XM5R[ONE\SN;.]=Y_+P*=7'[4GLJT\I$`J9UTV0UNBUS'?N":Q,;&]/=\@KZ>@
XM.J#*GS>C+T\@W4NF(3$R+K9+0+1,NQ\Q,#E=7;,IIS0?KJN?K".M-Y\DGQ^V
XM(*)&.TE)J%&G]T>_14^F+R<OJ3J?*J$C+LRTI+PX1[^^9ZXERC2D*5&BL[<S
XMWSU*.K0?MBI=*G=OJ$>F1L8Z+\`O=TPTW7=*25TJ1"?$*9\KP2=$--6G*</)
XM+KH?JRV\M+9!52G?3TK/*[/+L##O-*0T-RFLU[`V-/\NJ<>LP3TC6]?!OC*?
XM.6\QQ3O_1C9)TT2Y)CK5GRXT0<VV8TJLPT.M'ZLSJ;$Z4:U'NR31-T4[*ZAO
XM-ZRV,+/=*ZJUT1]`GRR?N"C)N*LD-JW+JT6YMN<PWR<WYV]5U2\_J3DIMRTT
XM*,LYLD;'P;^K']W'*KLJP%,H6ZM#M+I'.$FOH<HJ*RBK0RZ\1K8Z33HMKZ>M
XM)*NOJK,W/"=CT<TRJE^?I"M7+[8@31^^,\,S2JS`MC@J1C&TI=??JK0U3">C
XM34TH*36EYRK**UO)QB!;7;N_Q]]CQSJB)"TOOK8VMC^]HTF?RCPZN3K'(;K7
XM/)_3M2M5,TE/8^?CNM>[/"=CQ%NO,V.NRV<S+#*X.TMG+^-;3*8?GU_+.L=7
XM.E.S*L3`.=&VXU]+U48OT<1%,R[7-#_+N+ICO<$_4;PY.F.WJS;)_\VO,EW-
XM*\K,O[I?+$$WL,`Y-[RL*%]-N<RQN+V_.#ZH7['W7:S?N2KCRE=,O4#&O["W
XM*F?![R=`(;?3+4]CR\_#W=U)]S.N-DS'1*DZ-C'CW4`_K2[+QF/*0S:K-S;O
XM)]U#.4F^_^=-8]%,Q,EG/3L\.=/11N/)S&=,7SG?S4T^3$UC7\/GW<#_;U7)
XM/W=?6U.\X]VV2^]?;TO&5>=&RDG=/TOGQ5V]RE5=3$]=;^?376/3XT_?8TTZ
XMV]&_U4O/W4S?__=59^_325?;SV/5S=-56U]C;W?W]^_O[^_O[^_O[^_O[^_O
XM[^_O[^_O[^_O[^_O[^_O[^_O[^_O[^_O[^_O[^_O[^_O]_?W]^_W]_?W]_?W
XM]_?W]_?W]_?W]_?W]_?W]_?W]_?W]_?W]_?W]_?W]_?W]_?W]_?W]_?W]_?W
XM]_?W]_?W]_?W]_?W__?_]_?W]_?W]_?W]_?W]_?W]_?W]_?W]_?W]_?W]_?W
XM]_?W]_?W]_?W]_?_]__W]_?W]_?_]_?_]_?W____]_?_________________
XM______?_]__W__?W]_?_]_?W]__W__?W]_?____W___W________]______W
XM______________________________________?_]______W____________
XM______________?_]___________________________________________
XM___________W]_?W______?___?___________________________?_____
XM____________________________________________________________
XM___________________________________________________________W
XM_______W______?W______?___?_________________________________
XM____________________________________________________________
X@____________________________________________
X`
Xend
END_OF_FILE
if test 10674 -ne `wc -c <'sounds/whoosh.au.uu'`; then
    echo shar: \"'sounds/whoosh.au.uu'\" unpacked with wrong size!
fi
# end of 'sounds/whoosh.au.uu'
fi
echo shar: End of archive 9 \(of 30\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    echo "Now execute sdecode.sh to build files."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
