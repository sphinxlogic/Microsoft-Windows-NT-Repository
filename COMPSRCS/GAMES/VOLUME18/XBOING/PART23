Path: uunet!news.tek.com!news.cna.tek.com!not-for-mail
From: billr@saab.cna.tek.com (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i082:  xboing - blockout variant with color and sound for X, Part23/30
Date: 30 Aug 1993 10:29:17 -0700
Organization: Tektronix, Inc., Redmond, OR
Lines: 2006
Approved: billr@saab.CNA.TEK.COM
Message-ID: <25tddd$i29@saab.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1882

Submitted-by: jck@kimba.catt.citri.edu.au (Justin Kibell)
Posting-number: Volume 18, Issue 82
Archive-name: xboing/part23
Environment: X11, Xlib, XPM



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 23 (of 30)."
# Contents:  Makefile.std audio/AFaudio.c intro.c presents.c
#   sounds/stamp.au.uu
# Wrapped by billr@saab on Mon Aug 30 09:14:29 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile.std' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.std'\"
else
echo shar: Extracting \"'Makefile.std'\" \(13207 characters\)
sed "s/^X//" >'Makefile.std' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and </tmp/IIf.a07223>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.72.1.1 92/03/18 13:13:37 rws Exp $
X
X# operating system:  SunOS 4.1.2
X
X# $XConsortium: sunLib.rules,v 1.7 91/12/20 11:19:47 rws Exp $
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -g kmem -m 2755
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138.1.1 92/11/11 09:49:19 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/lib
X           BINDIR = /usr/bin/X11
X          INCROOT = /usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X        PEXLIBSRC = $(EXTENSIONSRC)/lib/PEXlib
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X# $XConsortium: sunLib.tmpl,v 1.14.1.2 92/11/11 09:55:02 rws Exp $
X
XSHLIBLDFLAGS = -assert pure-text
XPICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X       XMULIBONLY = -lXmu
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        DEPPEXLIB =
X           PEXLIB = -lPEX5
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X         SOPEXREV = 1.0
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X          LINTPEX = $(LINTLIBDIR)/llib-lPEX5.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
X# Imakefile for xboing version 1.7 - 27th August 1993
X
X# This is the directory where the highscore and level data will be placed.
XXBOING_DIR			= .
X
XCC					= cc
XCCOPTIONS			=
X
X#CC					= gcc
X#CCOPTIONS			= -static -DFUNCPROTO -Wall
X
X# These are some defines that must be set. Some may be overwritten in the
X# machine arch section.
X
XXPMLIB				= -L/usr/lib -lXpm
XXPMINCLUDE			= -I/usr/include/X11
XLEVEL_INSTALL_DIR 	= $(XBOING_DIR)/levels
XSOUNDS_DIR 			= $(XBOING_DIR)/sounds
XHIGH_SCORE_FILE 	= $(XBOING_DIR)/xboing.scores
XAUDIO_AVAILABLE		= False
XAUDIO_SRC			= audio/NOaudio.c
XAUDIO_INCLUDE 		=
XAUDIO_LIB     		=
X
X# Below are the special defines for different machine archs.
X
XAUDIO_AVAILABLE	= True
XAUDIO_SRC			= audio/SUNaudio.c
X
XAUDIO_INCLUDE = -I/usr/demo/SOUND/multimedia
XAUDIO_LIB     = -L/usr/demo/SOUND -laudio
X
XEXTRA_INCLS = $(XPMINCLUDE) $(AUDIO_INCLUDE)
X
X# Please take the comment out from the USE_FLOCK bit if you want to use the
X# flock() system call for locking instead of the lockf() system call.
X
XDEFINES	= $(EXTRA_INCLS) \
X	-DHIGH_SCORE_FILE=\"$(HIGH_SCORE_FILE)\" \
X	-DLEVEL_INSTALL_DIR=\"$(LEVEL_INSTALL_DIR)\" \
X	-DAUDIO_AVAILABLE=\"$(AUDIO_AVAILABLE)\" \
X	-DSOUNDS_DIR=\"$(SOUNDS_DIR)\" \
X# 	-DUSE_FLOCK=\"True\"
X
XLOCAL_LIBRARIES = $(AUDIO_LIB) $(XPMLIB) $(XLIB) -lm
X
X# Please don't change anything below this point - no need really - I hope.
X
XDEPLIBS = $(DEPXLIB)
X
XSRCS1=	version.c main.c score.c error.c ball.c blocks.c init.c \
X		stage.c level.c paddle.c mess.c intro.c bonus.c sfx.c \
X		highscore.c misc.c inst.c gun.c keys.c audio.c special.c \
X		presents.c
X
XOBJS1=	version.o main.o score.o error.o ball.o blocks.o init.o \
X		stage.o level.o paddle.o mess.o intro.o bonus.o sfx.o  \
X		highscore.o misc.o inst.o gun.o keys.o audio.o special.o \
X		presents.o
X
XPROGRAMS = xboing
X
Xall::	$(PROGRAMS)
X		@$(RM) version.c
X		@echo "xboing built successfully."
X
Xversion.c:
X		@sh ./version.sh $(PROGRAMS)
X
Xaudio.c::  $(AUDIO_SRC)
X	$(RM) $@
X	$(LN) $? $@
X
X OBJS = $(OBJS1) $(OBJS2) $(OBJS3)
X SRCS = $(SRCS1) $(SRCS2) $(SRCS3)
X
Xall:: $(PROGRAMS)
X
X$(PROGRAMS): $(OBJS1) $(DEPLIBS1)
X	$(RM) $@
X	$(CC) -o $@ $(LDOPTIONS) $(OBJS1)  $(LOCAL_LIBRARIES) $(LDLIBS)   $(EXTRA_LOAD_FLAGS)
X
Xinstall:: $(PROGRAMS)
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  $(PROGRAMS) $(DESTDIR)$(BINDIR)
X
Xinstall.man:: $(PROGRAMS).man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) $(PROGRAMS).man $(DESTDIR)$(MANDIR)/$(PROGRAMS).$(MANSUFFIX)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAMS)
X
Xinstall:: $(PROGRAMS)
X	@echo "XBoing directory is " $(XBOING_DIR)
X
X	@echo "Creating directory " $(XBOING_DIR)
X	@if [ ! -d $(XBOING_DIR) ]; then mkdir $(XBOING_DIR); fi
X
X	@echo "Creating directory " $(LEVEL_INSTALL_DIR)
X	@if [ ! -d $(LEVEL_INSTALL_DIR) ]; then mkdir $(LEVEL_INSTALL_DIR); fi
X
X	@echo "Copying level data into directory " $(LEVEL_INSTALL_DIR)
X	@cd ./levels; set -x; for file in *.data; do					\
X		$(INSTALL) -c $(INSTDATFLAGS) $$file $(LEVEL_INSTALL_DIR);	\
X	done
X
X	@if [ "$(AUDIO_AVAILABLE)" = "True" ]; 								\
X	then																\
X		echo "Creating directory " $(SOUNDS_DIR); 						\
X		if [ ! -d $(SOUNDS_DIR) ]; then mkdir $(SOUNDS_DIR); fi;		\
X		echo "Copying sound files into directory " $(SOUNDS_DIR);		\
X		cd ./sounds; set -x; for file in *.au; do						\
X			$(INSTALL) -c $(INSTDATFLAGS) $$file $(SOUNDS_DIR);			\
X		done;															\
X	fi
X
X	@echo "Creating a highscore file " $(HIGH_SCORE_FILE)
X	@touch $(HIGH_SCORE_FILE);
X	@chmod a+rw $(HIGH_SCORE_FILE);
X
Xbackup:
X	make clean;
X	tar cvf `date '+xboing%d-%h-%y.tar'` *
X	gzip *.tar
X	mv *.gz ../backup;
X
X# End of the XBoing Imakefile :-)
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
X# -------------------------------------------------------------------------
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
if test 13207 -ne `wc -c <'Makefile.std'`; then
    echo shar: \"'Makefile.std'\" unpacked with wrong size!
fi
# end of 'Makefile.std'
fi
if test -f 'audio/AFaudio.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'audio/AFaudio.c'\"
else
echo shar: Extracting \"'audio/AFaudio.c'\" \(4207 characters\)
sed "s/^X//" >'audio/AFaudio.c' <<'END_OF_FILE'
X#include "include/copyright.h"
X
X/*
X * Audiofile format - original code from Andrew Leahy 
X *                    <A.Leahy@st.nepean.uws.edu.au> 
X */
X
X/*
X *  Include file dependencies:
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include "AFlib.h"
X
X/* 
X * Internal macro definitions: 
X */
X
X#define BUFFER_SIZE				(1024 * SBUF_SIZE)	
X#define False 0
X#define True 1
X#define SPEAKER 0 /* 0 external handset, 1 for internal speaker */
X
X/*
X *  Internal type declarations:
X */
X
X#if NeedFunctionPrototypes
Xstatic void flushAudioDevice(void);
X#else
Xstatic void flushAudioDevice();
X#endif
X
X/* 
X * Internal variable declarations: 
X */
X
Xint sample_sizes[] = 
X{
X    1,  /* MU255 */
X    1,  /* ALAW */
X    2,  /* Linear PCM, 16 bits, -1.0 <= x < 1.0 */
X    2,  /* Linear PCM, 32 bits, -1.0 <= x < 1.0 */
X    1,  /* G.721, 64Kbps to/from 32Kbps. */
X    1,  /* G.723, 64Kbps to/from 32Kbps. */
X    0
X};
X
Xstatic char		*buf;
Xint 			err;
Xstruct stat     st;
Xstatic int      nbytes;
Xchar			errorString[255];
Xint				ssize;
Xstatic ATime			t, act, nact;
Xstatic AC				ac;
Xstatic AFAudioConn		*aud;
X
X#if NeedFunctionPrototypes
Xint SetUpAudioSystem(Display *display)
X#else
Xint SetUpAudioSystem(display)
X	Display *display;
X#endif
X{
X    AFSetACAttributes 	attributes;
X    int 				srate, device;
X    unsigned int 		channels;
X    AEncodeType 		type;
X    char 				*server;
X
X    device 						= SPEAKER;
X    attributes.preempt 			= Mix;
X    attributes.start_timeout 	= 0;
X    attributes.end_silence 		= 0;
X    attributes.play_gain 		= 0;
X    attributes.rec_gain 		= 0;
X
X    if ((server = (char *) getenv("AUDIOFILE")) == NULL)
X    {
X        sprintf(errorString, 
X			"The environment variable AUDIOFILE is not set.\n");
X		ErrorMessage(errorString);
X		return False;
X    }
X    else
X    {
X        if ((aud = AFOpenAudioConn(server)) == NULL) 
X		{
X            sprintf(errorString, "Cannot open a connection to audio server.\n");
X			ErrorMessage(errorString);
X            return False;
X        }
X
X        ac = AFCreateAC(aud, device, ACPlayGain, &attributes);
X        srate 		= ac->device->playSampleFreq;
X        type 		= ac->device->playBufType;
X        channels 	= ac->device->playNchannels;
X        ssize 		= sample_sizes[type] * channels;
X
X        if ((buf = (char *) malloc(BUFFER_SIZE)) == NULL) 
X		{
X            sprintf(errorString, "Couldn't allocate a play buffer.\n");
X			ErrorMessage(errorString);
X            return False;
X        }
X    }
X 
X	/* Success in opening audio device */
X	return True;
X}
X
X#if NeedFunctionPrototypes
Xstatic void flushAudioDevice(void)
X#else
Xstatic void flushAudioDevice()
X#endif
X{
X	/* How is this done in audiofile? */
X}
X
X#if NeedFunctionPrototypes
Xvoid FreeAudioSystem(void)
X#else
Xvoid FreeAudioSystem()
X#endif
X{
X	/* Close connection to the audiofile sound server */
X	AFFreeAC(ac);
X	AFCloseAudioConn(aud);
X
X	/* Free memory buffer */
X	if (buf != (char *) NULL) free(buf);
X}
X
X#if NeedFunctionPrototypes
Xvoid SetMaximumVolume(int Volume)
X#else
Xvoid SetMaximumVolume(Volume)
X	int Volume;
X#endif
X{
X	/* Not needed */
X}
X
X#if NeedFunctionPrototypes
Xvoid playSoundFile(char *filename, int volume)
X#else
Xvoid playSoundFile(filename, volume)
X	char *filename;
X	int volume;
X#endif
X{
X	int fd;
X	char soundfile[1024];
X	char *str;
X
X	/* Construct the sounds file path and use env var if exists */
X    if ((str = (char *)getenv("XBOING_SOUND_DIR")) != NULL)
X    	sprintf(soundfile, "%s/%s.au", str, filename);
X    else            
X        sprintf(soundfile, "%s/%s.au", SOUNDS_DIR, filename);
X
X	/* Open the sound file for reading */
X	if ((fd = open(soundfile, O_RDONLY, 0)) < 0) 
X	{
X		/* Issue an error about not opening sound file */
X		sprintf(errorString, "Unable to open sound file %s.", soundfile);
X		WarningMessage(errorString);
X		return;
X	}
X
X	/* At this point, we're all ready to copy the data. */
X	if ((nbytes = read(fd, (char *) buf, BUFFER_SIZE)) <= 0) 
X		return;
X
X	t = AFGetTime(ac); 
X	
X	do
X	{
X		nact = AFPlaySamples(ac, t, nbytes, buf);
X		act = nact;
X		t += nbytes;
X	} while ((nbytes = read(fd, buf, BUFFER_SIZE)) != 0);
X
X	/* Close the sound file */
X	(void) close(fd);
X}
X
X#if NeedFunctionPrototypes
Xvoid audioDeviceEvents(void)
X#else
Xvoid audioDeviceEvents()
X#endif
X{
X    /* None to do */
X}
X
END_OF_FILE
if test 4207 -ne `wc -c <'audio/AFaudio.c'`; then
    echo shar: \"'audio/AFaudio.c'\" unpacked with wrong size!
fi
# end of 'audio/AFaudio.c'
fi
if test -f 'intro.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'intro.c'\"
else
echo shar: Extracting \"'intro.c'\" \(12847 characters\)
sed "s/^X//" >'intro.c' <<'END_OF_FILE'
X#include "include/copyright.h"
X
X/*
X *  Include file dependencies:
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <stddef.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#include <xpm.h>
X
X#include "include/error.h"
X#include "include/misc.h"
X#include "include/gun.h"
X#include "include/main.h"
X#include "include/init.h"
X#include "include/inst.h"
X#include "include/stage.h"
X#include "include/blocks.h"
X#include "include/sfx.h"
X#include "include/special.h"
X#include "include/ball.h"
X#include "include/score.h"
X#include "include/paddle.h"
X#include "include/level.h"
X#include "include/mess.h"
X#include "include/audio.h"
X#include "include/version.h"
X
X#include "bitmaps/titleBig.xpm"
X
X#include "bitmaps/star1.xpm"
X#include "bitmaps/star2.xpm"
X#include "bitmaps/star3.xpm"
X#include "bitmaps/star4.xpm"
X#include "bitmaps/star5.xpm"
X#include "bitmaps/star6.xpm"
X#include "bitmaps/star7.xpm"
X#include "bitmaps/star8.xpm"
X#include "bitmaps/star9.xpm"
X#include "bitmaps/star10.xpm"
X#include "bitmaps/star11.xpm"
X
X#include "include/intro.h"
X
X/*
X *  Internal macro definitions:
X */
X
X#define GAP 10
X
X/*
X *  Internal type declarations:
X */
X
X#if NeedFunctionPrototypes
Xvoid SetIntroWait(int newMode, int waitFrame);
Xvoid DoIntroWait(void);
X#else
Xvoid SetIntroWait();
Xvoid DoIntroWait();
X#endif
X
X/*
X *  Internal variable declarations:
X */
X
Xstatic int nextFrame = 0;
Xstatic int nextFrame2 = 0;
Xstatic int endFrame = 0;
Xstatic int startFrame = 0;
Xstatic int explodeIndex = 0;
Xstatic int explodeBlock = 0;
Xenum IntroStates IntroState;
XPixmap bigtitlePixmap, bigtitlePixmapM;
XPixmap stars[12], starsM[12];
Xstatic int waitingFrame, waitMode;
X
X#if NeedFunctionPrototypes
Xvoid SetUpIntroduction(Display *display, Window window, Colormap colormap)
X#else
Xvoid SetUpIntroduction(display, window, colormap)
X	Display *display;
X	Window window;
X	Colormap colormap;
X#endif
X{
X	XpmAttributes   attributes;
X	int             XpmErrorStatus;
X
X    attributes.valuemask = XpmColormap;
X	attributes.colormap = colormap;
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, titleBig_xpm,
X		&bigtitlePixmap, &bigtitlePixmapM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseIntro()");
X
X    /* Create the stars for the letter shine */
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, star1_xpm,
X		&stars[0], &starsM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseIntro(star1)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, star2_xpm,
X		&stars[1], &starsM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseIntro(star2)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, star3_xpm,
X		&stars[2], &starsM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseIntro(star3)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, star4_xpm,
X		&stars[3], &starsM[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseIntro(star4)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, star5_xpm,
X		&stars[4], &starsM[4], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseIntro(star5)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, star6_xpm,
X		&stars[5], &starsM[5], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseIntro(star6)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, star7_xpm,
X		&stars[6], &starsM[6], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseIntro(star7)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, star8_xpm,
X		&stars[7], &starsM[7], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseIntro(star8)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, star9_xpm,
X		&stars[8], &starsM[8], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseIntro(star9)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, star10_xpm,
X		&stars[9], &starsM[9], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseIntro(star10)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, star11_xpm,
X		&stars[10], &starsM[10], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseIntro(star11)");
X
X    /* Free the xpm pixmap attributes */
X	XpmFreeAttributes(&attributes);
X
X	ResetIntroduction();
X}
X
X#if NeedFunctionPrototypes
Xvoid DrawIntroTitle(Display *display, Window window, int x, int y)
X#else
Xvoid DrawIntroTitle(display, window, x, y)
X	Display *display;
X	Window window;
X	int x;
X	int y;
X#endif
X{
X	RenderShape(display, window, bigtitlePixmap, bigtitlePixmapM,
X		x, y, 474, 74, True);
X}
X
X#if NeedFunctionPrototypes
Xvoid DoIntroTitle(Display *display, Window window)
X#else
Xvoid DoIntroTitle(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	char string[80];
X
X	/* Clear and draw background pattern */
X    DrawStageBackground(display, window, BACKGROUND_0);
X
X	/* Draw the intro title bitmap XBOING */
X	DrawIntroTitle(display, window, 10, 10);
X
X	/* Construct a copyright message leaving space for the copyright circle */
X	strcpy(string, "  Copyright 1993 Justin C. Kibell, All Rights Reserved");
X	string[0] = 0xa9;  /* Copyright circle */
X	DrawShadowCentredText(display, window, copyFont, string, 90, white, 
X		PLAY_WIDTH);
X
X	/* Be very friendly */
X	SetCurrentMessage(display, messWindow, "Welcome to XBoing", False);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoBlocks(Display *display, Window window)
X#else
Xstatic void DoBlocks(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int y = 120;
X	int x = 40;
X
X	/* Now draw the blocks on the screen */
X	DrawTheBlock(display, window, x, y, RED_BLK, 0);
X	DrawShadowText(display, window, textFont, 
X		"- 100 points", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x, y, BLUE_BLK, 0);	
X	DrawShadowText(display, window, textFont, 
X		"- 110 points", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x, y, GREEN_BLK, 0);
X	DrawShadowText(display, window, textFont, 
X		"- 120 points", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x, y, TAN_BLK, 0);	
X	DrawShadowText(display, window, textFont, 
X		"- 130 points", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x, y, YELLOW_BLK, 0);
X	DrawShadowText(display, window, textFont, 
X		"- 140 points", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x, y, PURPLE_BLK, 0);	
X	DrawShadowText(display, window, textFont, 
X		"- 150 points", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x, y, BULLET_BLK, 0);	
X	DrawShadowText(display, window, textFont, 
X		"- Ammunition", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x+5, y-5, HYPERSPACE_BLK, 0);	
X	DrawShadowText(display, window, textFont, 
X		"- Teleport", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x+5, y+5, REVERSE_BLK, 0);	
X	DrawShadowText(display, window, textFont, 
X		"- Reverse Control", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x+5, y+5, MGUN_BLK, 0);	
X	DrawShadowText(display, window, textFont, 
X		"- Machine Gun", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x, y, MULTIBALL_BLK, 0);
X	DrawShadowText(display, window, textFont, 
X		"- Multi Balls", x + 60, y, green);
X	y += 40;
X
X	/* New line from top again on right */
X	y = 120;
X	x = 260;
X
X	DrawTheBlock(display, window, x+5, y, BONUS_BLK, 0);
X	DrawShadowText(display, window, textFont, 
X		"- 3000 points", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x, y, COUNTER_BLK, 5);
X	DrawShadowText(display, window, textFont, 
X		"- 200 points", x + 60, y, green);
X	y += 40;
X
X	DrawTheBall(display, window, x + 20, y+10, 0); 
X	DrawShadowText(display, window, textFont, 
X		"- The Ball!", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x, y, BLACK_BLK, 0);
X	DrawShadowText(display, window, textFont, 
X		"- Solid wall", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x+9, y, BOMB_BLK, 0);
X	DrawShadowText(display, window, textFont, 
X		"- Bomb!", x + 60, y, green);
X	y += 40;
X
X	DrawPaddle(display, window, x+20, y, PADDLE_SMALL);
X	DrawShadowText(display, window, textFont, 
X		"- The Paddle", x + 60, y, green);
X	y += 40;
X
X	DrawTheBullet(display, window, x+20, y+5);
X	DrawShadowText(display, window, textFont, 
X		"- Bullet", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x+8, y, DEATH_BLK, 0);
X	DrawShadowText(display, window, textFont, 
X		"- Instant Death!", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x+10, y, EXTRABALL_BLK, 1);
X	DrawShadowText(display, window, textFont, 
X		"- Extra Ball", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x+10, y, WALLOFF_BLK, 0);
X	DrawShadowText(display, window, textFont, 
X		"- Walls Off", x + 60, y, green);
X	y += 40;
X
X	DrawTheBlock(display, window, x+10, y - 5, STICKY_BLK, 0);
X	DrawShadowText(display, window, textFont, 
X		"- Sticky Ball", x + 60, y, green);
X	y += 40;
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoText(Display *display, Window window)
X#else
Xstatic void DoText(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	char string[80];
X	int y;
X
X	y = PLAY_HEIGHT - 27;
X
X	strcpy(string, "Press <Space> to start the game.");
X	DrawShadowCentredText(display, window, textFont, 
X		string, y, tann, PLAY_WIDTH);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoSparkle(Display *display, Window window)
X#else
Xstatic void DoSparkle(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	static Pixmap store;
X	static int x = 100;
X	static int y = 20;
X	static int in = 0;
X
X	if (!store)
X	{
X		store = XCreatePixmap(display, window, 20, 20,
X			DefaultDepth(display, XDefaultScreen(display)));
X	}
X
X	if (in == 0) 
X		XCopyArea(display, window, store, gc, x, y, 20, 20, 0, 0);
X
X	if (frame == endFrame)
X		IntroState = INTRO_FINISH;
X
X	if (frame == startFrame)
X	{
X		RenderShape(display, window, stars[in], starsM[in],
X			x, y, 20, 20, False);
X
X	 	in++;
X		startFrame = frame + 15;
X
X		if (in == 11) 
X		{
X			XCopyArea(display, store, window, gc, 0, 0, 20, 20, x, y);
X			in = 0;
X			startFrame = frame + 500;
X			x = (rand() % 474) + 5;
X			y = (rand() % 74) + 5;
X		}	
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoFinish(Display *display, Window window)
X#else
Xstatic void DoFinish(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	ResetInstructions();
X	mode = MODE_INSTRUCT;
X
X	if (noSound == False)
X		playSoundFile("weeek", 100);
X}
X
X#if NeedFunctionPrototypes
Xvoid Introduction(Display *display, Window window)
X#else
Xvoid Introduction(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	static int firstTime = True;
X
X	switch (IntroState)
X	{
X		case INTRO_TITLE:
X			if (getSpecialEffects(display) == True && !firstTime)
X				DoIntroTitle(display, bufferWindow);
X			else
X				DoIntroTitle(display, window);
X			IntroState = INTRO_BLOCKS;
X			break;
X
X		case INTRO_BLOCKS:
X			if (getSpecialEffects(display) == True && !firstTime)
X				DoBlocks(display, bufferWindow);
X			else
X				DoBlocks(display, window);
X			IntroState = INTRO_TEXT;
X			break;
X
X		case INTRO_TEXT:
X			if (getSpecialEffects(display) == True && !firstTime)
X			{
X				DoText(display, bufferWindow);
X				while (WindowShatterEffect(display, window));
X			}
X			else
X				DoText(display, window);
X			if (firstTime) firstTime = False;
X			IntroState = INTRO_EXPLODE;
X			break;
X
X		case INTRO_EXPLODE:
X			DoSparkle(display, window);
X			if ((frame % FLASH) == 0)
X				RandomDrawSpecials(display);
X			BorderGlow(display, window);
X			break;
X
X		case INTRO_FINISH:
X			DoFinish(display, window);
X			break;
X
X		case INTRO_WAIT:
X			DoIntroWait();
X			break;
X
X		default:
X			break;
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid RedrawIntroduction(Display *display, Window window)
X#else
Xvoid RedrawIntroduction(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	DoIntroTitle(display, window);
X	DoBlocks(display, window);
X	DoText(display, window);
X}
X
X#if NeedFunctionPrototypes
Xvoid FreeIntroduction(Display *display)
X#else
Xvoid FreeIntroduction(display)
X	Display *display;
X#endif
X{
X	int i;
X
X	for (i = 0; i < 10; i++)
X	{
X    	if (stars[i])	XFreePixmap(display, stars[i]);         
X    	if (starsM[i])	XFreePixmap(display, starsM[i]);         
X	}
X
X    if (bigtitlePixmap)		XFreePixmap(display, bigtitlePixmap);         
X	if (bigtitlePixmapM)	XFreePixmap(display, bigtitlePixmapM);
X}
X
X#if NeedFunctionPrototypes
Xvoid ResetIntroduction(void)
X#else
Xvoid ResetIntroduction()
X#endif
X{
X	IntroState = INTRO_TITLE;
X	explodeIndex = 0;
X	explodeBlock = 0;
X	nextFrame = frame + 10;
X	nextFrame2 = frame + 10;
X	startFrame = frame + 10;
X	endFrame = frame + 3000;
X}
X
X#if NeedFunctionPrototypes
Xvoid SetIntroWait(int newMode, int waitFrame)
X#else
Xvoid SetIntroWait(newMode, waitFrame)
X	int newMode;
X	int waitFrame;
X#endif
X{
X	waitingFrame = waitFrame;
X	waitMode = newMode;
X	IntroState = INTRO_WAIT;
X}
X
X#if NeedFunctionPrototypes
Xvoid DoIntroWait(void)
X#else
Xvoid DoIntroWait()
X#endif
X{
X	if (frame == waitingFrame)
X		IntroState = waitMode;
X}
END_OF_FILE
if test 12847 -ne `wc -c <'intro.c'`; then
    echo shar: \"'intro.c'\" unpacked with wrong size!
fi
# end of 'intro.c'
fi
if test -f 'presents.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'presents.c'\"
else
echo shar: Extracting \"'presents.c'\" \(12494 characters\)
sed "s/^X//" >'presents.c' <<'END_OF_FILE'
X#include "include/copyright.h"
X
X/*
X *  Include file dependencies:
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <stddef.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#include <xpm.h>
X
X#include "include/error.h"
X#include "include/misc.h"
X#include "include/main.h"
X#include "include/init.h"
X#include "include/intro.h"
X#include "include/audio.h"
X#include "include/stage.h"
X#include "include/mess.h"
X#include "include/version.h"
X
X#include "bitmaps/flag.xpm"
X#include "bitmaps/earth.xpm"
X#include "bitmaps/titleX.xpm"
X#include "bitmaps/titleB.xpm"
X#include "bitmaps/titleO.xpm"
X#include "bitmaps/titleI.xpm"
X#include "bitmaps/titleN.xpm"
X#include "bitmaps/titleG.xpm"
X#include "bitmaps/justin.xpm"
X#include "bitmaps/kibell.xpm"
X#include "bitmaps/presents.xpm"
X
X#include "include/presents.h"
X
X/*
X *  Internal macro definitions:
X */
X
X#define GAP 10
X
X/*
X *  Internal type declarations:
X */
X
X#if NeedFunctionPrototypes
Xvoid SetPresentWait(int newMode, int waitFrame);
Xvoid DoPresentWait(void);
X#else
Xvoid SetPresentWait();
Xvoid DoPresentWait();
X#endif
X
X/*
X *  Internal variable declarations:
X */
X
Xstatic int nextFrame = 0;
Xstatic int endFrame = 0;
Xstatic int startFrame = 0;
Xenum PresentStates PresentState;
Xstatic Pixmap flagPixmap, flagPixmapM, earthPixmap, earthPixmapM;
Xstatic Pixmap titlePixmap[6], titlePixmapM[6];
Xstatic Pixmap justin, justinM, kibell, kibellM, presents, presentsM;
Xstatic int waitingFrame, waitMode;
X
X#if NeedFunctionPrototypes
Xvoid SetUpPresents(Display *display, Window window, Colormap colormap)
X#else
Xvoid SetUpPresents(display, window, colormap)
X	Display *display;
X	Window window;
X	Colormap colormap;
X#endif
X{
X	XpmAttributes   attributes;
X	int             XpmErrorStatus;
X
X    attributes.valuemask = XpmColormap;
X	attributes.colormap = colormap;
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, flag_xpm,
X		&flagPixmap, &flagPixmapM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialisePresent(flag)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, titleX_xpm,
X		&titlePixmap[0], &titlePixmapM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialisePresent(titleX)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, titleB_xpm,
X		&titlePixmap[1], &titlePixmapM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialisePresent(titleB)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, titleO_xpm,
X		&titlePixmap[2], &titlePixmapM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialisePresent(titleO)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, titleI_xpm,
X		&titlePixmap[3], &titlePixmapM[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialisePresent(titleI)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, titleN_xpm,
X		&titlePixmap[4], &titlePixmapM[4], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialisePresent(titleN)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, titleG_xpm,
X		&titlePixmap[5], &titlePixmapM[5], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialisePresent(titleG)");
X
X	/* Justin kibell presents */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, justin_xpm,
X		&justin, &justinM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialisePresent(justin)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, kibell_xpm,
X		&kibell, &kibellM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialisePresent(kibell)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, presents_xpm,
X		&presents, &presentsM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialisePresent(presents)");
X
X	/* Create the earth pixmap */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, earth_xpm,
X		&earthPixmap, &earthPixmapM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialisePresent(earth)");
X
X    /* Free the xpm pixmap attributes */
X	XpmFreeAttributes(&attributes);
X
X	/* Setup intro to initial state */
X	ResetPresents();
X}
X
X#if NeedFunctionPrototypes
Xstatic void DrawLetter(Display *display, Window window, int letter, 
X	int x, int y)
X#else
Xstatic void DrawLetter(display, window, letter, x, y)
X	Display *display;
X	Window window;
X	int letter;
X	int x, y;
X#endif
X{
X	switch(letter)
X	{
X		case 0:
X			RenderShape(display, window, titlePixmap[0], titlePixmapM[0],
X				x, y, 71, 74, False);
X			break;
X
X		case 1:
X			RenderShape(display, window, titlePixmap[1], titlePixmapM[1],
X				x, y, 73, 74, False);
X			break;
X
X		case 2:
X			RenderShape(display, window, titlePixmap[2], titlePixmapM[2],
X				x, y, 83, 74, False);
X			break;
X
X		case 3:
X			RenderShape(display, window, titlePixmap[3], titlePixmapM[3],
X				x, y, 41, 74, False);
X			break;
X
X		case 4:
X			RenderShape(display, window, titlePixmap[4], titlePixmapM[4],
X				x, y, 85, 74, False);
X			break;
X
X		case 5:
X			RenderShape(display, window, titlePixmap[5], titlePixmapM[5],
X				x, y, 88, 74, False);
X			break;
X
X		default:
X			ErrorMessage("Error: In default for DrawLetter()");
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid DoPresentFlag(Display *display, Window window)
X#else
Xvoid DoPresentFlag(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	char string[80];
X	int y, x;
X
X	x = ((MAIN_WIDTH + PLAY_WIDTH) / 2) - 35;
X
X	/* Draw the flag bitmap */
X	RenderShape(display, window, flagPixmap, flagPixmapM,
X		x, 15, 71, 40, True);
X	DrawShadowCentredText(display, window, textFont, 
X		"Proudly Australian Made", 
X		65, white, PLAY_WIDTH + MAIN_WIDTH);
X
X	x = ((MAIN_WIDTH + PLAY_WIDTH) / 2) - 207;
X	RenderShape(display, window, earthPixmap, earthPixmapM,
X		x, 100, 415, 415, False);
X
X	y = MAIN_HEIGHT + PLAY_HEIGHT - 50;
X
X	/* Construct a copyright message leaving space for the copyright circle */
X	strcpy(string, "  Copyright 1993 Justin C. Kibell, All Rights Reserved");
X	string[0] = 0xa9;  /* Copyright circle */
X	DrawShadowCentredText(display, window, copyFont, string, y, white, 
X		PLAY_WIDTH + MAIN_WIDTH);
X
X	/* My email address for contact and fame :-) */
X	DrawShadowCentredText(display, window, copyFont,
X		"email: jck@citri.edu.au", y + 15, white, PLAY_WIDTH + MAIN_WIDTH);
X	sprintf(string, "Version %d.%d", VERSION, REVNUM / 1000);
X	DrawShadowCentredText(display, window, copyFont,
X		string, y + 30, white, PLAY_WIDTH + MAIN_WIDTH);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoText1(Display *display, Window window)
X#else
Xstatic void DoText1(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int x, y;
X
X	if (noSound == False) playSoundFile("intro", 50);
X
X	x = ((MAIN_WIDTH + PLAY_WIDTH) / 2) - 142;
X	y = 200;
X
X	/* Render the Justin bitmap */
X	RenderShape(display, window, justin, justinM,
X		x, y, 285, 44, False);
X
X	SetPresentWait(PRESENT_TEXT2, frame + 500);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoText2(Display *display, Window window)
X#else
Xstatic void DoText2(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int x, y;
X
X	x = ((MAIN_WIDTH + PLAY_WIDTH) / 2) - 130;
X	y = 300;
X
X	/* Render the Justin bitmap */
X	RenderShape(display, window, kibell, kibellM,
X		x, y, 260, 40, False);
X
X	SetPresentWait(PRESENT_TEXT3, frame + 500);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoText3(Display *display, Window window)
X#else
Xstatic void DoText3(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int x, y;
X
X	x = ((MAIN_WIDTH + PLAY_WIDTH) / 2) - 205;
X	y = 400;
X
X	/* Render the Justin bitmap */
X	RenderShape(display, window, presents, presentsM,
X		x, y, 410, 44, False);
X
X	SetPresentWait(PRESENT_LETTERS, frame + 750);
X}
X
Xint dists[] =
X{
X	71, 73, 83, 41, 85, 88
X};
X
X#if NeedFunctionPrototypes
Xstatic void DoLetters(Display *display, Window window)
X#else
Xstatic void DoLetters(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	static int i = 0;
X	static int x = 40;
X
X	if (i < 6)
X	{
X		if (noSound == False)
X			playSoundFile("stamp", 100);
X
X		DrawLetter(display, window, i, x, 550);
X		x += 10 + dists[i];
X
X		DrawLine(display, window, 30, 530, 
X			(MAIN_WIDTH + PLAY_WIDTH) - 30, 530, red, 2);
X
X		DrawLine(display, window, 30, 644, 
X			(MAIN_WIDTH + PLAY_WIDTH) - 30, 644, red, 2);
X
X		SetPresentWait(PRESENT_LETTERS, frame + 500);
X	}
X	else
X	{
X		SetPresentWait(PRESENT_CLEAR, frame + 2000);
X	}
X
X	i++;
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoClear(Display *display, Window window)
X#else
Xstatic void DoClear(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	static int yt, yb;
X	static int first = True;
X
X	if (first == True)
X	{
X		yt = 0;
X		yb = PLAY_HEIGHT + MAIN_HEIGHT - 5;
X		first = False;
X		nextFrame = frame;
X
X    	if (noSound == False)
X			playSoundFile("whoosh", 70);
X
X	}
X
X	if (frame >= nextFrame)
X	{
X		/* Clear and draw lines */
X		XClearArea(display, window, 0, yt, PLAY_WIDTH + MAIN_WIDTH, 10, False);
X		yt += 10;
X		DrawLine(display, window, 2, yt, PLAY_WIDTH + MAIN_WIDTH-2, yt, red, 1);
X
X		XClearArea(display, window, 0, yb, PLAY_WIDTH + MAIN_WIDTH, 10, False);
X		yb -= 10;
X		DrawLine(display, window, 2, yb, PLAY_WIDTH + MAIN_WIDTH-2, yb, red, 1);
X
X		if (yt > ((PLAY_HEIGHT + MAIN_HEIGHT) / 2))
X			SetPresentWait(PRESENT_FINISH, frame + 20);
X
X		nextFrame = frame + 20;
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid QuickFinish(Display *display, Window window)
X#else
Xvoid QuickFinish(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	/* User has pressed space so finish early */
X	SetPresentWait(PRESENT_FINISH, frame);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoFinish(Display *display, Window window)
X#else
Xstatic void DoFinish(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	/* Free all the pixmaps used in this intro */
X	FreePresents(display);
X
X	/* Erase all stuff in window */
X	XClearWindow(display, mainWindow);
X
X	/* Map all the windows */
X	MapAllWindows(display);
X
X	/* Now jump into the intro mode */
X	ResetIntroduction();
X	mode = MODE_INTRO;
X}
X
X#if NeedFunctionPrototypes
Xvoid Presents(Display *display, Window window)
X#else
Xvoid Presents(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	switch (PresentState)
X	{
X		case PRESENT_FLAG:
X			DoPresentFlag(display, window);
X			PresentState = PRESENT_TEXT1;
X			break;
X
X		case PRESENT_TEXT1:
X			if ((frame % 10) == 0)
X				DoText1(display, window);
X			break;
X
X		case PRESENT_TEXT2:
X			if ((frame % 10) == 0)
X				DoText2(display, window);
X			break;
X
X		case PRESENT_TEXT3:
X			if ((frame % 10) == 0)
X				DoText3(display, window);
X			break;
X
X		case PRESENT_LETTERS:
X			DoLetters(display, window);
X			break;
X
X		case PRESENT_CLEAR:
X			DoClear(display, window);
X			break;
X
X		case PRESENT_FINISH:
X			DoFinish(display, window);
X			break;
X
X		case PRESENT_WAIT:
X			DoPresentWait();
X			break;
X
X		default:
X			break;
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid RedrawPresents(Display *display, Window window)
X#else
Xvoid RedrawPresents(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X}
X
X#if NeedFunctionPrototypes
Xvoid FreePresents(Display *display)
X#else
Xvoid FreePresents(display)
X	Display *display;
X#endif
X{
X	int i;
X
X	/* Free the flag pixmaps */
X    if (flagPixmap)		XFreePixmap(display, flagPixmap);         
X	if (flagPixmapM)	XFreePixmap(display, flagPixmapM);
X
X	/* Free the large earth pixmap and it's mask */
X    if (earthPixmap)	XFreePixmap(display, earthPixmap);         
X	if (earthPixmapM)	XFreePixmap(display, earthPixmapM);
X
X	/* Free the text pixmaps for justin, kibell and presents */
X    if (justin)		XFreePixmap(display, justin);         
X	if (justinM)	XFreePixmap(display, justinM);
X
X    if (kibell)		XFreePixmap(display, kibell);         
X	if (kibellM)	XFreePixmap(display, kibellM);
X
X    if (presents)	XFreePixmap(display, presents);         
X	if (presentsM)	XFreePixmap(display, presentsM);
X
X	/* Free the pixmaps for the letters of the work xboing */
X	for (i = 0; i < 6; i++)
X	{
X		/* Free each of the letters in XBOING */
X    	if (titlePixmap[i])		XFreePixmap(display, titlePixmap[i]);         
X		if (titlePixmapM[i])	XFreePixmap(display, titlePixmapM[i]);
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid ResetPresents(void)
X#else
Xvoid ResetPresents()
X#endif
X{
X	PresentState = PRESENT_FLAG;
X	nextFrame = frame + 100;
X	startFrame = frame + 10;
X	endFrame = frame + 3000;
X}
X
X#if NeedFunctionPrototypes
Xvoid SetPresentWait(int newMode, int waitFrame)
X#else
Xvoid SetPresentWait(newMode, waitFrame)
X	int newMode;
X	int waitFrame;
X#endif
X{
X	waitingFrame = waitFrame;
X	waitMode = newMode;
X	PresentState = PRESENT_WAIT;
X}
X
X#if NeedFunctionPrototypes
Xvoid DoPresentWait(void)
X#else
Xvoid DoPresentWait()
X#endif
X{
X	if (frame == waitingFrame)
X		PresentState = waitMode;
X}
END_OF_FILE
if test 12494 -ne `wc -c <'presents.c'`; then
    echo shar: \"'presents.c'\" unpacked with wrong size!
fi
# end of 'presents.c'
fi
if test -f 'sounds/stamp.au.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sounds/stamp.au.uu'\"
else
echo shar: Extracting \"'sounds/stamp.au.uu'\" \(12793 characters\)
sed "s/^X//" >'sounds/stamp.au.uu' <<'END_OF_FILE'
Xbegin 644 stamp.au
XM+G-N9````"#_____`````0``'T`````!``````````#;-S__14XWQ<Y;,#/.
XM6\4P_[?%OS<_V___,\[;Q3,[Q=O_+-N[__\SO[?_,#>_Q;\M,["S6S_;Q;].
XM++^___]%N[N[,$6_SK=%3MNS,S=;6[=;3L[;3C?__[?%,/^S_SLW-]N_3EN_
XM3C\S6[^S-RVWO[]%-[_;K5M;VSN_3KNPLS?;K=M;14ZFL_].OT[;O\6HMS!;
XMVZW.1?^LH,6[/\6S_UM;M\Z[/\[.SMLMQ3,W,SLP144[3D[_)BT_VTY.-S>P
XM/S,?1<6[Q2RW/RT_O]O;/T[%K3<S_T5.O[^WJ-LW+#._JL6PK<4H,$6WLT7%
XM_UO_+"HSVS`L/T5%.T4_NR@D-S`D'S,PSC<B)"TS+"8F*C\?'RT[13`[_[O_
XM-TX_/S`WO_\H'S,[/S\W-S,S-Q\F+3LL.S\D*"0D'Q\?'Q\?'R`?'Q\@'Q\?
XM'Q\?*"8L+"`M(A\@+4X_SKM;Q?].N["MIK"JG[>?IK"@GY^XMJNPL*VPKJ2E
XMKJJJN+VMM:^MKK^\M;_"PK;)R5W/5]W,PDPV0LP\,T6_24DZ3#U,,4)714))
XM3&M=0NNZ3\7"R47%PLS)O;6XO,RZK[:ON+&JL[&VK+JUL*VHO*ZPML*LR;#_
XM_UV_3SC_W<(\/44Q.BQ",2@H-2@E'Q\E)2DA'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\B("8B*2(E+3HX-C`X/3IK5VM73[JQPKJPM:F_
XMLY^?KJZHH)^DJ)^?I)^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?
XMHY^?GY^?H)^BI:"CI*6JJ:VLJJ:\KJ^SO;#=7;S%_]=%0E<L+S@X+BTJ*BLB
XM(",?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'R8B'RL?'R$D(C8P(RLP,#8P24]%
XM0EW_PO_=S,RS7=VQK;6XLY^QLZ6GJ*NJK*2EJZ6DJ*NIH9^JJJ2EJJ*KKK"S
XMI:JOLZVMKZZLKZO7O[^]N,+%MKC/R=W7R>M/UUU/R4],3$Q7W2\S,SHK*S4N
XM)RHI)Q\?(B,A)B(B(A\?'R,@'Q\?'Q\?'Q\?'Q\C)1\?'RLB'R(G'Q\@)R@D
XM+2PZ*B4K0C8Q/=<\23U7PCW_NL7KL,+KO*^OJ;VPJJBPL*BHI;.JK:"XKZVH
XMJ*^OI:>OI:.LIZZLJ+.QHJB?IZNPJ+.JG["UJJJHNK^LIZRIK;&LO<S,JJZX
XMN+:]O6O/O<*_N%?/3#]7SVO=W4D\.CA"SU=%:S9%,#`\0BTX/#8I*BXQ*C,U
XM,"LM*BDG*B8G+"LH+B4E*#$I*"<H(1\J*"0C*"PJ)"DI)2@G*BDI)2HI*B0E
XM*C,G'RHN-2PE+"\V)2<P13HX0D(S,T(_-C@]5T])/]W,NMV_O;&ZL:ZNKJNJ
XMJ*JMKJFAHY^DHJ"?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?
XMGY^?GY^?GY^CI9^?GZ2BGY^CJ:JQL*J?HK&ZM;.N74S%S,EKUSHN/4__.#4M
XM,2DK+"XD*"HD'R,A'R$?(BH?'Q\?'Q\?("$?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?(",?'Q\?'Q\?)20?'R`@(!\K)A\D+1\B*"TS-3`L*"PU+R\S.C\V
XM/38N+TPZZU<V0EU,->MKZSH]S]T\5[W/NDE/Z[U/O;JQW46]NL]=Z[VZMK/%
XML+'/1:NSO^O%NKRXS[JSMK:ZK;BLJ;.OJZRLJK"QJJJGI:&?JI^CI:"DGZ6?
XMGY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?I9^?GZ.AGY^?I*>?
XMHZ>GGY^HJ*^BI;6SL:JQK:^QMMW)MKU724E/13\_14]K,3$Q,R0F.B\K*BD?
XM'Q\E)1\?)B4?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\A(2@E)R@J+"@N73HU/4+/W?]KPK:]N*W/L*JSL:RGI*6KH9^?H)^?
XMGY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?
XMGY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?
XMGY^?GY^?GZ&?H*BDHZ"LJZJIMLFUJ6M73.N]/3Q,3T(F*C8S)2DI(R,?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'R(G)2$B)24D
XM*BXQ*RTJ*C$S-C$U0EU7_SC,Q;S/W<*ZM;"SK:^\LZBJI+"JIZ6JI*6EHJ*F
XMJZ&AHZ:GHZ*BIJ2BH*6EHZ.DGY^@H**JHY^?GZ&?GZ.?GZ&EI*B?H:.EHZ&?
XMHJ2KI:6@H:NBI*JJJJ*KL:VEJ;&PLZNUS+VPL<+%L;#=R;^]O,]7:[_=PM?_
XMZ_]/UT(]2=WK_^OKZ\]K_]T_7>O7U\S=O;S"NKV\U[J]L;J_O;JNMK:]N+"Q
XMO[:ZO;^_O;/"R47/N+K_.KJX3SQ%:U=%0C]%3#$Z134J/T\X*C$S*C`P-3$K
XM)R,H)RLE)2HP,28E'R4I-BPD)2$J+24K*RHQ*2DE(B<L*RTN*BHG+"HJ*"TQ
XM*RXK*C8P+"LL-2XQ,S`P-4],/S@V/#T\/45"14]):S8X25="5_\\3&M7:T]/
XM73\\3U=)5_\_.#P]."\P-CI"-B\N-3$N*C,P*C$M,2\P+2TU+RPF*S`Q-3\Z
XM+C$],34N-D5)23,\13TX26M//#_KZTE=S]?_:T_7U\G"L<*_Q<F]O+RZN+RM
XML:^SM:RJJK&OKJZNK*JIJZVNJK&ULZRKI:NVL+^VK[6SL+RXL[JVL;"ZK[6Z
XMO<*]K*ZQMK.OM;"QKKRUK:VOO;VPL[6VL*VNJZRLK;"IHZ.PK*6?GZ2AI*6A
XMGY^?GY^?GY^?GY^?GY^AHI^?GY^?GY^?GZ*FHJ>GJ*:GK+RXJK_)R;V_W5=7
XM.#,V/"TS*RLP*B@I)R4?(!\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\@'R`@(2,A'R(@'Q\?(R$I*"DH*B0D)RXN*RTF
XM*B\K+#`O,#TV,S,O/#A".CHX+S!%.C8]_UU".#U).$)/5T(P/$G_/$E%0CU=
XMW<]/7<7"_VO_Z\]KO<*SL+"PKJNML:ZEJ;6KI:&?I)^?H)^?GY^?GY^?GY^?
XMGY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^AGY^?HI^GI*JMK:^SL[B\K[6\
XMN+_/U]=K3%U/W?]%/S@U,U<_/2XP+B\N*R4D(R8E)1\?(B0D(Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\C*2HG)2<J
XM+RDJ+RLQ*BPM+2\U3U<].EW/_TGKW==K_[_/S\^PMKB\N+6NI:JGJJFII:*@
XMIZ.?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?
XMGY^?GY^DJJFFK[.UNKJ_MK.OS\QK75T_1<S=13U%.C@V/$(_-BXV3#$P,38Z
XM-3,V.CQ%0CI)/SHP,S`N,3,X,3$N*S$Q-2PJ+2PC)"@A'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM(!\?(2(M+3`M+SP_.#A"Z__7NK"SNJ^FJ:&AI)^?H9^?GY^?GY^?GY^?GY^?
XMGY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GZ"D
XMI:JLKK6\L[JZ5UT\0C8V/#HS,34M*RHH*BLE(!\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'R`D)20E*BLM+R\V/#Q,/44\/5W_R<6_
XMO\*VK;"ZN*ZLMK6NJ:RJI:>OK:FFI:6?I*>IIZ2IJ:JIJJRLJZJLK*^NL+BZ
XMO+W"S\G"W5U=74])/U=,/3@V.C4P+#`X-3,Q,3`N,S`O+2TK*B@J)R0G*"<F
XM*"HJ)28D)R@C(R`C'Q\A(R4D)2(C(RHJ+2HJ*"HJ,"PH*CH\.CPS0DE,24)K
XM_\_=U[^_Q;6PJ[:]JZ:OL:JIJ:ZJJ*2BIJ&AH:.?GY^?I*&BI:.CI:&FIZ.D
XMI:>HIZBHK:N\N+&UN,R_O;B_R<SK_]UK74DZ26M73^OK74E,3$QK3T),5S\V
XM.CH]+S$\.CHZ-3,N,#H],24J+BXG(2XK)R4J)B4@)2HD)"`?(B,D(B4E)24G
XM*"DA)BHL)B8E)BHK+C`P+SPX-CH].CHZ/SP_3ST]26O=75?=R=W"Q;^\PLF\
XMM;VUKJ^SMK"JK;.MJJRJJZJKJZRJI::EHY^AH:&DGY^?GY^@GY^?GY^?GY^?
XMGY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GZ6?HJ"BHZ.DHZBGJ:JJK*JSMKVV
XMO\6]O,G,:TQ,:T]/23Q)/2DJ+"XS+"HC)24D(R`?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'R,A)BTJ+BPO,#`Z3TD]14]=7?__S\_)O+^_O;6VL[JUKK"SJZNFI*6E
XMI:*IIY^?I:"?GY^BGY^?GZ"?GY^CGY^?GY^?GY^?GY^?GY^?H:&BH:BJJJ"A
XMI:6EHZ.DIJ6HJ*:FI:FJK*JNK*FJJ:JJIJJSI:.JJZRKJZNHIZJLK:JJI::G
XMI:6EJ*>JJJ.CGZ6EI:6EH9^HI:FGJ:JMJJ:HJJJOKZ^SK[&SPKBUPLS_Z\_=
XM_TE,24Q75T4]-CP\.C$U,S8Z,#$K)RPS+"LJ)20F*"4E(",K)R(?(B@D'Q\B
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?(Q\D)24J)BDO,"PN,#@V
XM-3Q"76M=W=W,PL*\N+&NK:RJL*^EIJ.CGY^?GY^?GY^?GY^?GY^?GY^?GY^?
XMGY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?
XMGY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?H*&CH:*BHZ6EIZFMJZFMM;VU
XMM<+,S]U,24P\-CPU,#$Q+BHF)R<D)"`?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'R$B(B4G)24G*2HM+BPN.#HQ*S-"/SPX3$D\/6MK_UW_
XMS\G7R<*]O+V\O[R]N+R\L[6VM;.PL;&OKJVKJ*>FJ:JHJ:>EIZ6AGZ6DH:.?
XMGY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?I*B@H*6E
XMIJ2GI:6EI["II*6ML*JMK["PK["UMK6ZO[S%O+R_S\S"U\_,R<_,Q<G7U]W7
XMS]?_Z]UKS-W,W?_7Q<7,S\R]O<+/_\G%PL7)R<S/O\G%R;^]O<7/R<S,R<_7
XMW=?K_\]KW5==24E,14(_/3\]-C,V,34O+2LI*2@D(R0E)2,B'R`?'Q\?(1\?
XM'Q\?'Q\?("4@'Q\C(R,C)24E)RHJ*2@J+"HJ*BHK+BLO,#`U-3,V/#@U.#\_
XM0C]%3$D_14)"0C\]3$P]0DE/3%="3#\\23\\.#TX.CPV-C8X.#HZ.#4V/3\V
XM.CH]/#,S.#@X/T)"/SI"13\]/T])14Q/3U=KZUU=76O/_U=7S__KU\G/S]?%
XMO,+"R<*XO;V]O;_)PKB\Q<*ZL+6ZO;RUL;6VN+JZMKBZPLRXNL+%R<S,S-W7
XMS\_=Q<G/Z^O/S,__Z^O)SUW_W=?__]WK:__7PLSK:]W%R=?/S\_,O;S%Q<FZ
XMNK.QL[BNL+6OK*VKJ:FFIJ>DHI^?H**?GY^?GY^?GY^?GY^?GY^?GY^?GY^?
XMGY^?GY^?GY^AHZ2DI*2DIZBIK*VPL:ZSNKBZO\G/Z\]=:UT]/#8U,S,O+2PK
XM*"4C(B,B'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'R(A'Q\A(R(A)BDH)R@K+"PJ*2\S+BXQ,#`P,#HX,S@Z
XM.CHZ-C@V.CPX/#P]/#P\0D4Z/3U"24E)145,3$Q)3T_KZ^O7Z^O/O[_"R<+)
XMO;RXM;&QL[.QN+:NIJ>MJZ>FIZFDHZ*DH)^?HJ.?GY^?GY^?GY^?GY^?GY^?
XMGY^?GY^?GY^?GY^?GY^?GY^?HY^?HZ6JJJJKJJ^PL[6\PL7=Z^MK:UU%/3H\
XM.#$O+BTJ*R<E(B(C'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\A'Q\?(B4E)B<H*BHJ+"XO,#\_
XM0D57:__=W<S,Q<*XM;BVKZRMJJFGI:6@H:"?GY^?GY^?GY^?GY^?GY^?GY^?
XMGY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?
XMH:6EIJBKL*^PNL7=Z]=K5T4_/#HU+BPG)B8E(R`?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\@(!\?'R`A'R`A
XM(R,B(2$A(!\?(2$?'R,D(R0B(R4E)24E(R,E)R4B)28F)RHJ*2@J+RTJ+"TN
XM+B\M*R\M.#8Q,2\S.C8V.#H].#@\24E):_],3UWKU]W=Q<7%PL*VL[:PKJVM
XMJJBJI:6EI:2AHZ"@GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?
XMGY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^@GY^EI:.EJ*BGIZ^SL;&QNKR]O+W=
XMU]W=:U=/3TD\/STV,S`O,"XK*BHJ*2@H)R4E(R0D)20C)24C)2<C)"4F)24E
XM*BHI*BHL*RLI+"TJ*R\Q+2LO,"\K*B\Q,"HL,3`N,#$O+BLJ+BTK+"PL*BHJ
XM+"HG*"HJ*2HH)R8F*2<D)28G)B4G*2@G*"DI*"@L+2HJ+2LL*RPK+2\S,S,S
XM-34U-C8X.#P_/SU"0D5,3#T\24Q)24E)0DE,3$5%3$]K3T]=5T]/3TQ,25?_
XM3UU=5T]K7=W7Z]W/S]W=U]WKS\S)U\S,S,G%R<G%Q<F_Q<G"O;^_O;JZO+^Z
XMNKJ\NKJZNKV\O+^_O+J]PKV\O,G)PKW"S\S)S,G,S,7"S\G"R<7,R<G)S,_K
XM:\G,S]?_S\_/S\_7U\G/W=?=U\S,S\_7S\_)Q;_"O[_"O\*]O;RXMKJ\L[6Q
XML*^PKJVMKZRKJZJGJ*BHI*2EHJ*@H*&CHZ.DH:*@H*&DHJ*AH*2EI:2HJJJF
XMIZNKJJRPL[.OL;:XNKS%S.O75TE,3T(]/3HV,RPM,"HI)R<G)"0F)!\?("$?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\@("4E)",G*RHK+C`P,34Z.#@\14))3TG=S\_7
XMS\F]O\*_N+BQKK"OL*ZLJJ:FJ::CHJ&CI*.?GY^@GY^?GY^?GY^?GY^?GY^?
XMGY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?HJ&CH**FI:6FJJJHJJJM
XMK:NOL+&PK[6SNKJZO+BVNKB]O;R_S,7%PK_"O\G7U\_)R=W_W<S/Z^M=_VM7
XM5U=,3UU/14)%/ST_.C8X-C8S-3,O+"XL*RHI)RDH)",D(Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?'Q\?
XM'Q\?'Q\?(B(D*BLJ*BTZ/#I"3/__S\6_NK:LJZJJJ*.@H:"?GY^?GY^?GY^?
XMGY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GY^?GZ&D
XMIZBFJJNLK:^PM;BXQ<G)R=?=:_]K5TQ)/3P_.C@Q,3$P+BXM+"PN*RHJ*RHK
XM*B8H*"4G*"HJ)28J)R8J*BLK+"HL*RPQ,2\Q,#8Z.#4Z/T)"14)"0D5,5UU,
XM3UUK:UUK___KZVM75___76M=3$E,14)"/T)"13HZ-34U-C4P+3`N+2TJ*BPK
XM*BDE)R<G)B4C(R4E)2(B)"4B(B(B(B,E)24C*"@G*"@J*B@I+BPK+2XP,"XP
XM,S8S,SH_/#P]0C\\0DQ774]/___KW=W/S\_%PLG)PK:VO;V\MK6QKZVLK:JK
XMK*RKJJFGI:6IJ*6FIJ:EI*2GI:2DHJ.CHZ6EI::EI*6CI:6GJ*FIJ*JJJJRK
XMK:ZNKJZOKK&VMKBVMKJ_O[V_O\G"O\G)Q<+7Z__7U]?7W=W____K_UWKW>M/
XM5_]K_UUK75=K76M75^O__U=75___5___:VO_:VM77?__:U=/5U=75UU)0DE,
XM3TQ,3$Q)14)"/T)"244_/ST]/3T_/SP]/S8U-C8V-C4U-C4S-34S,S,S,2\N
XM,#$O,2\O+S`P,3$S,34U-C`S-C@V-C8V-C@Z/#H_/4(_/SP\0DE%145%24E%
XM24],3$Q,24Q)3%=,3$E,5U=7:VMK__]K_UU=5^O_75U=__]K________:VMK
XM:___:UU/7?]K75UK_VM=75U=76O_:UU=_VM=75U=75=774Q)3$Q73TE/3T],
XM3$]=74]73U=/3$],3$]/5UU=7?__7?]K____Z^O__^OKW>O=U\S,S\_)S-?7
XMS+_"R<7"R<F_NK^_O;V_O[R\N+JZNK.SM;6UL[&QKZZPL["SL+&QL;"PKZ^O
XMKZZNKJ^QL;"PM;6UM;6UMKJXN+BXNKR\O;_"Q<G)R<G7S^O=W>OK:UU=5TQ,
XM3$E%14)"/#P\/#P\.#4S,#`Q,#`P+S`N+RXP+RXN+RTL+2XP+BLK+2\N+2\Q
XM+B\O+R\N+2TN+B\N+3$P+R\Q,#$Q,3,S,3$S,S,U-C@V-C@Z.#H]/3\]/3U"
XM/3]%14E%24]/3$]775UK:VMK5___Z]W7U]?7R<7)Q;_"PL*_O[^\O;VZMKBX
XMMKBXMKBXN+BXN+RSM;BXMKBXN+:VN+BZO+JZO;V_O;V_PK_"Q<G,R<S,S,_,
XMU]W7S]?KW=W/U_]K____:VMK75=/5U=/3UUK3TE,3TQ)24E)3$5)24(_24E)
XM245"14E)13]"14)"0D)%245"0D)"14)"0D)"0D)%0C]%24)%24)"0C\_0C\_
XM0C]"/3T]0CT]/#P_/3HZ.CPZ.#H]/#PZ/#P_/S\_/#P_/SP_/T)"0C]%14))
XM3$E,3$]73U==75=7:VO_:VO________K___=____Z___Z^OK___K_VMK____
XM:____VO__VMK:_]K75UK:U=75VMK5U=775=/5U=775=75UU75U=K:VMK75UK
XM:VM=________Z____]WK_^OKZ___Z]W__^OKW>O=U]W=U]W7U\_7U]?7S\S,
XMS,S/S\S/S,S,R<S,S,_/S,S)Q<S,R<7,R<G)R<G,R<S)R<+)S,S,R<G)R<G)
XMR<7)R<S,Q<7"R<G"Q<7)Q<+%Q<7"Q<7%O\+%PL7%Q<7%R<S/R<7/S\_/S-?7
XMU^OKU^O___]K76M=74]/3$Q)24E%0C\_/#HZ.C8V-C4U-34U,S`S,2\P,#`O
XM+R\O+R\N+B\P+BXO,#$N+BXQ,3`O+S$P,3$S,3,S,S,S,34U-C8V-38X.#8X
XM-CP\/3P]/3T]/3\]/T5)24Q)3$]/5U==:VMK_____]W=W=W=U\_,S\7)R<7"
XMQ<7%PK^_O[^\O+R\O+R\O[V\NKJZNKJZO+V\O;JXNKJ\O;RZO+^]O+R]O;R\
XMO+V]O;^_O;V]O;V]O;V_O[V_O[^_O\+"PK^_Q<7%Q<G)R<7)S,G)S,_7S\_/
XMU]?7U]?7U]W=W=WKZ^OKW>O___________]K____:VO___]K__]K:___:UU7
XM75=75U=75U=/3TQ/5T]/24E)3$Q%14E"0C]"/ST_14(]/3H]/ST]/ST\/#H\
XM/#H\/3P\/#HZ/#T]/#P\/3\_/3\_/S\_/3]"14)"0D5"145%24E,24E,3$Q,
XM3T],3$Q,3T]/3T]75U=73U=775U775==:UU=75UK:VMK:VMK:VMK_UUK____
XM:VO_:____VMK_________________^O____KZ^OKZ]WKZ]W=Z^O=U]?K_^O7
XMZ^O=U]WKW=W7W=W=U]?=W=?=W=?7U]W=U]?7U]?7U]?7U\_7U]W7U\_7S]?7
XMU\_/U]?/S,_/S\S/U\S,S\_,R<G,S\S,S,S,S,G,R<G%R<G)R<G)R<S,R<S,
XMS,S,S,S/S,S/S\_/U]?7W=WKZ^OKZ^O_______]K75U=75=73T]/3$Q)24E%
XM145%0C\_/S\_/3\]/S\]/#P\/3P\/#P\/3T\/3T]/ST]/3]"0C]"0D(_0D)"
XM0D)%24E)24E)24Q/3TQ,5T]/3U=75U==75==76M=:VMK_UUK:VMK:_____]K
XM____:VO_____________________________________________:VO_____
XM__]K:VMK:VMK:VM=76MK:UU=:UU=5U==75UK75U75UU=:VMK:VO_:VMK____
XM_______________KZ^OKZ]WKZ]W=W=W=U]?7U]?7U]?,S,S/S\G,S\_,R<S,
XMR<G,S,S,S,G)R<S,R<G)S,S)Q<G)S,G)R<G,S,S,S,S,S,_/S\_/S\_7S]?7
XMW=W=W=WKZ^OK____________:___:UU=75U=5U=75U=/5U=/3$Q,3$Q,3$Q,
XM3$Q,24E)24E)14E%145%0D)%145"145%0D5%14)"0D5%14)%145%145%245)
XM24E%14E)24E)24Q)24E,3$Q,3$Q,3$Q/5U=75U=75U==5U=775U=75U=76MK
XM:VMK:VMK:VMK:____________________________^OK___KZ^OKZ^OKZ^OK
XMZ^OKZ^O=W=W=W=W=W=W7W=W=U]W=W=?7W=W7U]?=W=?7U]?7U]?7U]?7S]?/
XMS]?7U]?7S\_/U]?7U]?/U]?7U]?7U]?7W=?=W=W=W>OKW=WKZ^OKZ_______
XM____________:UUK:UU=75U=75U75U=75U=75U=/3T]/3T]/3$Q,3$Q,3$Q,
XM3$Q,3$],3$Q,3$Q,3$Q,3T],3$Q,3$]/3TQ,3T]/3T]75U=/5U=75U=75U==
XM76MK76MK:VMK:VO_____________________________________________
XM____________________________________________________________
XM____________________________________________________________
XM____________________________________________________________
XM________________:___:VO__________VMK:___:VMK:VMK:VMK:VMK:VMK
XM:VMK:VMK:VMK:VMK:VMK76MK:VM=:VMK:VMK:VMK:VMK:VMK:VMK:VMK:VMK
XM:VMK_VO_:VO___]K____________________________________________
XM____________________________________________________________
XM_____________VMK__]K:VMK:VMK:VMK:VMK:VMK:VMK:VMK:VMK:VMK:VMK
XM:VMK:VMK:VO_________________________________________________
XM____________________________________________________________
XM____________________________________________________________
XM____________________________________________________________
XM____________________________________________________________
XH________________________________________________________
X`
Xend
END_OF_FILE
if test 12793 -ne `wc -c <'sounds/stamp.au.uu'`; then
    echo shar: \"'sounds/stamp.au.uu'\" unpacked with wrong size!
fi
# end of 'sounds/stamp.au.uu'
fi
echo shar: End of archive 23 \(of 30\).
cp /dev/null ark23isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    echo "Now execute sdecode.sh to build files."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
