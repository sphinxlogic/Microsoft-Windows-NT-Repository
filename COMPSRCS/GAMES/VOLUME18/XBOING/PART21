Path: uunet!news.tek.com!news.cna.tek.com!not-for-mail
From: billr@saab.cna.tek.com (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i080:  xboing - blockout variant with color and sound for X, Part21/30
Date: 30 Aug 1993 10:29:01 -0700
Organization: Tektronix, Inc., Redmond, OR
Lines: 1697
Approved: billr@saab.CNA.TEK.COM
Message-ID: <25tdct$i1r@saab.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1880

Submitted-by: jck@kimba.catt.citri.edu.au (Justin Kibell)
Posting-number: Volume 18, Issue 80
Archive-name: xboing/part21
Environment: X11, Xlib, XPM



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 21 (of 30)."
# Contents:  audio/RPLAYaudio.c bitmaps/kibell.xpm.uu level.c score.c
#   xboing.man
# Wrapped by billr@saab on Mon Aug 30 09:14:28 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'audio/RPLAYaudio.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'audio/RPLAYaudio.c'\"
else
echo shar: Extracting \"'audio/RPLAYaudio.c'\" \(3549 characters\)
sed "s/^X//" >'audio/RPLAYaudio.c' <<'END_OF_FILE'
X#include "include/copyright.h"
X
X/* RPLAYaudio.c - Use rplay to play sounds over network. Original source by
X *                Joel J. Fleck II - <joel@cc.bellcore.com> 
X * 				- I haven't the time to test this code. Should work though.
X */
X
X/*
X *  Include file dependencies:
X */
X
X#include <stdio.h>
X#include <fcntl.h>
X#include <stdlib.h>
X#include <stddef.h>
X#include <ctype.h>
X#include <errno.h>
X#include <sys/stat.h>
X#include <sys/fcntl.h>
X
X#include <rplay.h>
X
X#include "include/error.h"
X#include "include/main.h"
X#include "include/audio.h"
X
X/*
X *  Internal macro definitions:
X */
X
X/*
X *  Internal type declarations:
X */
X
X/*
X *  Internal variable declarations:
X */
X
Xstatic RPLAY   	*rp;
Xstatic int 		rplay_fd;
Xstatic char 	errorString[255];
X
X#if NeedFunctionPrototypes
Xint SetUpAudioSystem(Display *display)
X#else
Xint SetUpAudioSystem(display)
X	Display *display;
X#endif
X{
X	char hostname[256];
X   	char display_machine[256];
X    char *displayname = XDisplayString(display);
X
X	/* Obtain the systems hostname */
X    gethostname(hostname, 256);
X
X    if (strncmp(hostname, displayname, strlen(hostname)) != 0) 
X	{
X		/* Obtain the server name etc for rplay */
X    	strncpy(display_machine, displayname, strcspn(displayname,":"));
X
X		/* Connect to the rplay sound server */
X        rplay_fd = rplay_open(display_machine);
X    } 
X	else 
X	{
X		/* Connect to the rplay sound server */
X        rplay_fd = rplay_open("localhost");
X    }
X
X    if ( rplay_fd == -1 ) 
X	{
X		/* Error while trying to connect to rplay sound server */
X    	rplay_perror("SetUpAudioSystem()");
X		ErrorMessage("Error: Cannot connect to rplay sound server.");
X        return False;
X    } 
X	else 
X        return True;
X}
X
X#if NeedFunctionPrototypes
Xvoid FreeAudioSystem(void)
X#else
Xvoid FreeAudioSystem()
X#endif
X{
X	/* Close the rplay sound server */
X    rplay_close(rplay_fd);
X    rplay_destroy(rp);
X}
X
X#if NeedFunctionPrototypes
Xstatic void flushAudioDevice(void)
X#else
Xstatic void flushAudioDevice()
X#endif
X{
X	/* This is done when the sound is sent by setting the priority to highest
X	 * for every sound - I hope this works. JCK
X	 */
X}
X
X#if NeedFunctionPrototypes
Xvoid setNewVolume(unsigned int Volume)
X#else
Xvoid setNewVolume(Volume)
X	unsigned int Volume;
X#endif
X{
X	/* How do you do thism with rplay? */
X}
X
X#if NeedFunctionPrototypes
Xvoid audioDeviceEvents(void)
X#else
Xvoid audioDeviceEvents()
X#endif
X{
X    /* None to do */
X}
X
X#if NeedFunctionPrototypes
Xvoid playSoundFile(char *filename, int volume)
X#else
Xvoid playSoundFile(filename, volume)
X	char *filename;
X	int volume;
X#endif
X{
X    char soundfile[1024];
X    char *str;
X
X    /* Clear any active audio for the new sound */
X    flushAudioDevice();
X
X    /* Construct the sounds file path and use env var if exists */
X    if ((str = getenv("XBOING_SOUND_DIR")) != NULL)
X        sprintf(soundfile, "%s/%s.au", str, filename);
X    else
X        sprintf(soundfile, "%s/%s.au", SOUNDS_DIR, filename);
X
X	/* Create a connection to rplay server */
X	if ((rp = rplay_create(RPLAY_PLAY)) == NULL) 
X	{
X		/* Cannot play sound for some reason */
X    	rplay_perror("playSoundFile()");
X		ErrorMessage(errorString);
X    } 
X	else 
X	{
X		/* Volume for rplay is 1 to 255 instead of 1 to 100 */
X        volume += 50;
X
X		/* Setup the sound for rplay */
X        rplay_set(rp, RPLAY_APPEND, RPLAY_SOUND, soundfile, RPLAY_VOLUME, 
X			volume, RPLAY_PRIORITY, 255, NULL);
X
X		/* Send the rplay packet */
X        rplay(rplay_fd, rp);
X    }
X}
X
X#if NeedFunctionPrototypes
Xvoid SetMaximumVolume(int Volume)
X#else
Xvoid SetMaximumVolume(Volume)
X    int Volume;
X#endif
X{
X}
END_OF_FILE
if test 3549 -ne `wc -c <'audio/RPLAYaudio.c'`; then
    echo shar: \"'audio/RPLAYaudio.c'\" unpacked with wrong size!
fi
# end of 'audio/RPLAYaudio.c'
fi
if test -f 'bitmaps/kibell.xpm.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/kibell.xpm.uu'\"
else
echo shar: Extracting \"'bitmaps/kibell.xpm.uu'\" \(15119 characters\)
sed "s/^X//" >'bitmaps/kibell.xpm.uu' <<'END_OF_FILE'
Xbegin 644 kibell.xpm
XM+RH@6%!-("HO"G-T871I8R!C:&%R("H@:VEB96QL7WAP;5M=(#T@>PHB,C8P
XM(#0P(#$V(#$B+`HB(`ES($YO;F4)8R!.;VYE(BP*(BX)8R`C1C!&,$8P1C!&
XM,$8P(BP*(E@)8R`C13!%,$4P13!&,$8P(BP*(F\)8R`C1#!$,$0P1#!&,$8P
XM(BP*(D\)8R`C0S!#,$,P0S!&,$8P(BP*(BL)8R`C0C!",$(P0C!&,$8P(BP*
XM(D`)8R`C03!!,$$P03!&,$8P(BP*(B,)8R`C.3`Y,#DP.3!&,$8P(BP*(B0)
XM8R`C.#`X,#@P.#!&,$8P(BP*(B4)8R`C-C`V,#<P-S!&,$8P(BP*(B8)8R`C
XM-3`U,#8P-C!&,$8P(BP*(BH)8R`C-#`T,#4P-3!&,$8P(BP*(CT)8R`C,S`S
XM,#0P-#!&,$8P(BP*(BT)8R`C,C`R,#(P,C!&,$8P(BP*(CL)8R`C,3`Q,#$P
XM,3!&,$8P(BP*(CH)8R`C,#`P,#`P,#!&,$8P(BP*(B`@("`@("`@("`@("`@
XM("`@("`@("`@+BXN("`@("`@("`@("`@("`@("`@("`@("XN("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@+BXN("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`N+BXN+BXN+BXN+BX@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@+BXN+BXN+BXN+BXN("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`N+BX@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`N+BX@("`@("`@("`@(BP*(B`@("`@("`@("`@("`@("`@("`@
XM("!86%A86%A8("`@("`@("`@("`@("`@("!86%A86"`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("!86%A86%@@("`@("`@("`@("`@("`@("`@("`@("`@
XM(%A86%A86%A86%A86%A86%A86%A86%A8("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@(%A86%A86%A86%A86%A86%A86%A86%A8("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@(%A86%A86"`@("`@("`@("`@("`@("`@("`@("`@("`@
XM(%A86%A86"`@("`@("`@(BP*(B`@("`@("`@("`@("`@("`@("`@(%A86%A8
XM6%A86"`@("`@("`@("`@("`@(%A86%A86%@@("`@("`@("`@("`@("`@("`@
XM("`@("`@(%A86%A86%A8("`@("`@("`@("`@("`@("`@("!86%A86%A86%A8
XM6%A86%A86%A86%A86%A86%A86%@@("`@("`@("`@("`@("`@("`@("`@(%A8
XM6%A86%A86%A86%A86%A86%A86%A86%A86"`@("`@("`@("`@("`@("`@("`@
XM("`@("`@6%A86%A86%@@("`@("`@("`@("`@("`@("`@("`@("`@6%A86%A8
XM6%@@("`@("`@(BP*(B`@("`@("`@("`@("`@("`@("`@6%A86%A86%A86"`@
XM("`@("`@("`@("`@6%A86%A86%@@("`@("`@("`@("`@("`@("`@("`@("`@
XM6%AO6%A8;UA86"`@("`@("`@("`@("`@("`@(%A8;UA86&]86%AO6%A8;UA8
XM6&]86%AO6%A8;UA86&]8("`@("`@("`@("`@("`@("`@("`@6&]86%AO6%A8
XM;UA86&]86%AO6%A8;UA86&]86%@@("`@("`@("`@("`@("`@("`@("`@("!O
XM6%A8;UA86&\@("`@("`@("`@("`@("`@("`@("`@("!86%AO6%A8;U@@("`@
XM("`@(BP*(B`@("`@("`@("`@("`@("`@("`@;V]O;V]O;V]O("`@("`@("`@
XM("`@(&]O;V]O;V]O;V\@("`@("`@("`@("`@("`@("`@("`@("`@;V]O;V]O
XM;V]O("`@("`@("`@("`@("`@("`@(&]O;V]O;V]O;V]O;V]O;V]O;V]O;V]O
XM;V]O;V]O;V]O;R`@("`@("`@("`@("`@("`@("`@;V]O;V]O;V]O;V]O;V]O
XM;V]O;V]O;V]O;V]O;V\@("`@("`@("`@("`@("`@("`@("`@(&]O;V]O;V]O
XM;V\@("`@("`@("`@("`@("`@("`@("`@(&]O;V]O;V]O;V\@("`@("`@(BP*
XM(B`@("`@("`@("`@("`@("`@("!O;V]O;V]O;V]O("`@("`@("`@("`@;V]O
XM;V]O;V]O;R`@("`@("`@("`@("`@("`@("`@("`@("!O;V]O;V]O;V]O("`@
XM("`@("`@("`@("`@("`@(&]O;V]O;V]O;V]O;V]O;V]O;V]O;V]O;V]O;V]O
XM;V]O;V\@("`@("`@("`@("`@("`@("`@(&]O;V]O;V]O;V]O;V]O("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@(&]O;V]O;V]O;V\@("`@
XM("`@("`@("`@("`@("`@("`@(&]O;V]O;V]O;V\@("`@("`@(BP*(B`@("`@
XM("`@("`@("`@("`@($]O3V]/;T]O3V\@("`@("`@("`@("!/;T]O3V]/;T]O
XM("`@("`@("`@("`@("`@("`@("`@("`@(&]/;T]O3V]/;T\@("`@("`@("`@
XM("`@("`@("`@("`@("`@("!/;T]O3V]/;T]O("`@("`@("!/;T]O3V]/;T\@
XM("`@("`@("`@("`@("`@("`@("`@;T]O3V]/;T]O3V\@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@;T]O3V]/;T]O3R`@("`@("`@("`@
XM("`@("`@("`@("`@3V]/;T]O3V]/;R`@("`@("`@(BP*(B`@("`@("`@("`@
XM("`@("`@($]/3T]/3T]/3T\@("`@("`@("`@3T]/3T]/3T]/3T\@("`@("`@
XM("`@("`@("`@("`@("`@("`@($]/3T]/3T]/3R`@("`@("`@("`@("`@("`@
XM("`@("`@("`@($]/3T]/3T]/3R`@("`@("`@("`@3T]/3T]/3T\@("`@("`@
XM("`@("`@("`@("`@("`@3T]/3T]/3T]/3R`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("!/3T]/3T]/3T]/("`@("`@("`@("`@("`@("`@
XM("`@("!/3T]/3T]/3T]/("`@("`@("`@(BP*(B`@("`@("`@("`@("`@("`@
XM3RM/*T\K3RM/*R`@("`@("`@("!/*T\K3RM/*T\K3R`@("`@("`@("`@("`@
XM("`@("`@("`@("`@*T\K3RM/*T\K3R`@("`@("`@("`@("`@("`@("`@("`@
XM("`@($\K3RM/*T\K("`@("`@("`@("`@3RM/*T\K3RL@("`@("`@("`@("`@
XM("`@("`@("`K3RM/*T\K3RM/("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`K3RM/*T\K3RM/("`@("`@("`@("`@("`@("`@("`@("!/
XM*T\K3RM/*T\K("`@("`@("`@(BP*(B`@("`@("`@("`@("`@("`@*RLK*RLK
XM*RLK*R`@("`@("`@("LK*RLK*RLK*RLK("`@("`@("`@("`@("`@("`@("`@
XM("`@("`K*RLK*RLK*RLK("`@("`@("`@("`@("`@("`@("`@("`@("`@*RLK
XM*RLK*RLK("`@("`@("`@("`K*RLK*RLK*RL@("`@("`@("`@("`@("`@("`@
XM("`K*RLK*RLK*RL@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("LK*RLK*RLK*RL@("`@("`@("`@("`@("`@("`@("`@("LK*RLK*RLK
XM*RL@("`@("`@("`@(BP*(B`@("`@("`@("`@("`@("`K*RLK*RLK*RLK("`@
XM("`@("`K*RLK*RLK*RLK*RL@("`@("`@("`@("`@("`@("`@("`@("`@("`K
XM*RLK*RLK*RL@("`@("`@("`@("`@("`@("`@("`@("`@("`K*RLK*RLK*RL@
XM("`@("`@("`@("LK*RLK*RLK*RL@("`@("`@("`@("`@("`@("`@("LK*RLK
XM*RLK*R`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@*RLK
XM*RLK*RLK*R`@("`@("`@("`@("`@("`@("`@("`@*RLK*RLK*RLK*R`@("`@
XM("`@("`@(BP*(B`@("`@("`@("`@("`@($`K0"M`*T`K0"M`("`@("`@($`K
XM0"M`*T`K0"M`("`@("`@("`@("`@("`@("`@("`@("`@("`@($!`0$!`0$!`
XM0$`@("`@("`@("`@("`@("`@("`@("`@("`@("!`0$!`0$!`0$`@("`@("`@
XM("`@0$!`0$!`0$!`0"`@("`@("`@("`@("`@("`@("`@0$!`0$!`0$!`("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("!`0$!`0$!`0$!`
XM0"`@("`@("`@("`@("`@("`@("`@("!`0$!`0$!`0$!`0"`@("`@("`@("`@
XM(BP*(B`@("`@("`@("`@("`@($!`0$!`0$!`0$`@("`@("!`0$!`0$!`0$!`
XM0$`@("`@("`@("`@("`@("`@("`@("`@("`@("`@($!`0$!`0$!`0"`@("`@
XM("`@("`@("`@("`@("`@("`@("`@($!`0$!`0$!`0"`@("`@("`@("!`0$!`
XM0$!`0$!`0"`@("`@("`@("`@("`@("`@("!`0$!`0$!`0$!`("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("!`0$!`0$!`0$!`("`@("`@
XM("`@("`@("`@("`@("`@("!`0$!`0$!`0$!`("`@("`@("`@("`@(BP*(B`@
XM("`@("`@("`@("`@0$!`0$!`0$!`0$`@("`@0$!`0$!`0$!`0$!`0"`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@0$`C0$!`(T!`("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@0$`C0$!`(T!`0"`@("`@("`@(T!`0"-`0$`C0$!`
XM("`@("`@("`@("`@("`@("`@($`C0$!`(T!`0",@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@($`C0$!`(T!`0",@("`@("`@("`@("`@
XM("`@("`@("`@("-`0$`C0$!`(T`@("`@("`@("`@("`@(BP*(B`@("`@("`@
XM("`@("`C(T`C(R-`(R,C0",@($`C(R-`(R,C0",C(T`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`C(R,C(R,C(R,C("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@(R,C(R,C(R,C("`@("`@(",C(R,C(R,C(R,C(R,@("`@("`@
XM("`@("`@("`@("`@(R,C(R,C(R,C(R,@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@(R,C(R,C(R,C(R`@("`@("`@("`@("`@("`@("`@
XM("`@(R,C(R,C(R,C(R`@("`@("`@("`@("`@(BP*(B`@("`@("`@("`@("`C
XM(R,C(R,C(R,C(R,C(R,C(R,C(R,C(R,C(R`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`C(R,C(R,C(R,@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`C(R,C(R,C(R,C("`@("`C(R,C(R,C(R,C(R,C("`@("`@("`@("`@("`@
XM("`@("`C(R,C(R,C(R,C(R,@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@(R,C(R,C(R,C(R`@("`@("`@("`@("`@("`@("`@("`@(R,C
XM(R,C(R,C(R`@("`@("`@("`@("`@(BP*(B`@("`@("`@("`@("0C)",D(R0C
XM)",D(R0C)",D(R0C)",D(R0@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@(",D(R0C)",D(R`@("`@("`@("`@("`@("`@("`@("`@("`@("`D(R0C
XM)",D(R0C)",D(R0C)",D(R0C)",D(R0@("`@("`@("`@("`@("`@("`@("`D
XM(R0C)",D(R0C)",D(R0C)",D(R0C("`@("`@("`@("`@("`@("`@("`@("`@
XM("`D(R0C)",D(R0C("`@("`@("`@("`@("`@("`@("`@("`C)",D(R0C)",D
XM("`@("`@("`@("`@("`@(BP*(B`@("`@("`@("`@("0D)"0D)"0D)"0D)"0D
XM)"0D)"0D)"0D("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@)"0D
XM)"0D)"0D)"`@("`@("`@("`@("`@("`@("`@("`@("`@("0D)"0D)"0D)"0D
XM)"0D)"0D)"0D)"0D)"0D("`@("`@("`@("`@("`@("`@("`@("0D)"0D)"0D
XM)"0D)"0D)"0D)"0D)"0D)"`@("`@("`@("`@("`@("`@("`@("`@("0D)"0D
XM)"0D)"0@("`@("`@("`@("`@("`@("`@("`@("0D)"0D)"0D)"0@("`@("`@
XM("`@("`@("`@(BP*(B`@("`@("`@("`@)"0D)"0D)"0D)"0D)"0D)"0D)"0D
XM)"`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`D)20E)"4D)20E
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@)20E)"4D)20E)"4D)20E)"4D
XM)20E)"4D)20@("`@("`@("`@("`@("`@("`@("`@)20E)"4D)20E)"4D)20E
XM)"4D)20E)"4D)2`@("`@("`@("`@("`@("`@("`@("`@)20E)"4D)20E)"4@
XM("`@("`@("`@("`@("`@("`@("`@)"4D)20E)"4D)20@("`@("`@("`@("`@
XM("`@(BP*(B`@("`@("`@("`E)24E)24E)24E)24E)24E)24E)24@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`E)24E)24E)24@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@)24E)24E)24E)24E)24E)24E)24E)24@
XM("`@("`@("`@("`@("`@("`@("`@("`@)24E)24E)24E)24E)24E)24E)24E
XM)24E)2`@("`@("`@("`@("`@("`@("`@("`@)24E)24E)24E)2`@("`@("`@
XM("`@("`@("`@("`@("`@)24E)24E)24E)2`@("`@("`@("`@("`@("`@(BP*
XM(B`@("`@("`@("4E)24E)24E)24E)24E)24E)24E)2`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("4E)24E)24E)24@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`E)24E)24E)24E)24E)24E)24E)24E)24E)2`@("`@
XM("`@("`@("`@("`@("`@("`E)24E)24E)24E)24E)24E)24E)24E)24@("`@
XM("`@("`@("`@("`@("`@("`@("`E)24E)24E)24E("`@("`@("`@("`@("`@
XM("`@("`@("`E)24E)24E)24E("`@("`@("`@("`@("`@("`@(BP*(B`@("`@
XM("`@("4E)24E)24E)24E)24E)24E)24E)2`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("4E)24E)24E)2`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("4E)24E)24E)24E)24E)24E)24E)24E)24E)24@("`@("`@("`@
XM("`@("`@("`@("4E)24E)24E)24E)24@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`E)24E)24E)24E("`@("`@("`@("`@("`@("`@("`@
XM("`E)24E)24E)24E("`@("`@("`@("`@("`@("`@(BP*(B`@("`@("`@)24F
XM)24E)24E)2`@("`E)24E)B4E)2`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@)28E)B4F)28E)B`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("8E)B4F)28E)B4F)2`@("`@("`E)B4F)28E)B4F("`@("`@("`@("`@("`@
XM("`@("8E)B4F)28E)B4F("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("8E)B4F)28E)B4@("`@("`@("`@("`@("`@("`@("`@("4F)28E
XM)B4F)28@("`@("`@("`@("`@("`@("`@(BP*(B`@("`@("`F)B8F)B8F)B8F
XM)B`@("`F)B8F)B8F)B8@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`F)B8F)B8F)B8F("`@("`@("`@("`@("`@("`@("`@("`@("`@)B8F)B8F
XM)B8F)B8F("`@("`@("`@)B8F)B8F)B8F("`@("`@("`@("`@("`@("`@)B8F
XM)B8F)B8F)B8@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM)B8F)B8F)B8F)B`@("`@("`@("`@("`@("`@("`@("`@)B8F)B8F)B8F)B`@
XM("`@("`@("`@("`@("`@("`@(BP*(B`@("`@("`F)B8F)B8F)B8F("`@("`F
XM)B8F)B8F)B8@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`F)B8F
XM)B8F)B8F("`@("`@("`@("`@("`@("`@("`@("`@("`F)B8F)B8F)B8F)B8@
XM("`@("`@("`@)B8F)B8F)B8F("`@("`@("`@("`@("`@("`@)B8F)B8F)B8F
XM)B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@)B8F)B8F
XM)B8F)B`@("`@("`@("`@("`@("`@("`@("`@)B8F)B8F)B8F)B`@("`@("`@
XM("`@("`@("`@("`@(BP*(B`@("`@("8F)BHF)B8J)B8F("`@("`@)B8J)B8F
XM*B8F("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("HJ*BHJ*BHJ*BH@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`J*BHJ*BHJ*BHJ*B`@("`@("`@
XM("`@*BHJ*BHJ*BHJ("`@("`@("`@("`@("`@("`J*BHJ*BHJ*BHJ*B`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`J*BHJ*BHJ*BHJ("`@
XM("`@("`@("`@("`@("`@("`@("`J*BHJ*BHJ*BHJ("`@("`@("`@("`@("`@
XM("`@("`@(BP*(B`@("`@*BHJ*BHJ*BHJ*BH@("`@("`@*BHJ*BHJ*BHJ("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("HJ*BHJ*BHJ*BH@("`@("`@
XM("`@("`@("`@("`@("`@("`@("HJ*BHJ*BHJ*BHJ("`@("`@("`@("`J*BHJ
XM*BHJ*BHJ("`@("`@("`@("`@("`@("`J*BHJ*BHJ*BHJ("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`J*BHJ*BHJ*BHJ("`@("`@("`@
XM("`@("`@("`@("`@("`J*BHJ*BHJ*BHJ("`@("`@("`@("`@("`@("`@("`@
XM(BP*(B`@("`@*BHJ*BHJ*BHJ*B`@("`@("`@*BHJ*BHJ*BHJ("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@*CTJ/2H]*CTJ/2`@("`@("`@("`@("`@
XM("`@("`@("`@("`@*CTJ/2H]*CTJ/2H@("`@("`@("`@("H]*CTJ/2H]*CT@
XM("`@("`@("`@("`@("`@(#TJ/2H]*CTJ/2H]("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@(#TJ/2H]*CTJ/2H@("`@("`@("`@("`@("`@
XM("`@("`@("H]*CTJ/2H]*CT@("`@("`@("`@("`@("`@("`@("`@(BP*(B`@
XM("`]*CTJ/2H]*CTJ/2`@("`@("`@(#TJ/2H]*CTJ/2`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`]/3T]/3T]/3T]/2`@("`@("`@("`@("`@("`@("`@
XM("`@("`]/3T]/3T]/3T]/2`@("`@("`@("`@/3T]/3T]/3T]/3T@("`@("`@
XM("`@("`@("`@/3T]/3T]/3T]/3T@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@(#T]/3T]/3T]/3T@("`@("`@("`@("`@("`@("`@("`@
XM(#T]/3T]/3T]/3T@("`@("`@("`@("`@("`@("`@("`@(BP*(B`@(#T]/3T]
XM/3T]/3T]("`@("`@("`@(#T]/3T]/3T]/2`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`]/3T]/3T]/3T]("`@("`@("`@("`@("`@("`@("`@("`@("`]
XM/3T]/3T]/3T]("`@("`@("`@("`]/3T]/3T]/3T]/2`@("`@("`@("`@("`@
XM("`@/3T]/3T]/3T]/3T@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@/3T]/3T]/3T]/2`@("`@("`@("`@("`@("`@("`@("`@/3T]/3T]
XM/3T]/2`@("`@("`@("`@("`@("`@("`@("`@(BP*(B`@(#T]/3T]/3T]/3T]
XM("`@("`@("`@(#T]/3T]/3T]/3T@("`@("`@("`@("`@("`@("`@("`@("`@
XM(#T]/3T]/3T]/3T@("`@("`@("`@("`@("`@("`@("`@("`@(#T]/3T]/3T]
XM/3T@("`@("`@("`@(#T]/3T]/3T]/3T]("`@("`@("`@("`@("`@("`@/3T]
XM/3T]/3T]/2`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM/3T]/3T]/3T]("`@("`@("`@("`@("`@("`@("`@("`@/3T]/3T]/3T]("`@
XM("`@("`@("`@("`@("`@("`@("`@(BP*(B`@/3T]/3T]/3T]/3T@("`@("`@
XM("`@("`]/3T]/3T]/3T@("`@("`@("`@("`@("`@("`@("`@("`@(#T]/3T]
XM/3T]/3T@("`@("`@("`@("`@("`@("`@("`@("`@/3T]/3T]/3T]/3T@("`@
XM("`@("`]/3T]/3T]/3T]/3T@("`@("`@("`@("`@("`@("`]/3T]/3T]/3T]
XM/2`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`]/3T]/3T]
XM/3T]("`@("`@("`@("`@(#T]/2`@("`@("`]/3T]/3T]/3T]("`@("`@("`@
XM("`@(#T]/2`@("`@("`@(BP*(B`]/3T]/3T]/3T]/2`@("`@("`@("`@("`]
XM/3T]/3T]/3T]("`@("`@("`@("`@("`@("`@("`@("`@/2T]+3TM/2T]+2`@
XM("`@("`@("`@("`@("`@("`@("`@("`M/2T]+3TM/2T]+3T@("`@("`@/2T]
XM+3TM/2T]+3TM("`@("`@("`@("`@("`@("`@("`]+3TM/2T]+3TM/2`@("`@
XM("`@("`M/2T]+3TM/2`@("`@("`@("`@("`@("`@("`]+3TM/2T]+3TM("`@
XM("`@("T]+3TM/2T]+3T@("`@("`M/2T]+3TM/2T]("`@("`@(#TM/2T]+3TM
XM/2T@("`@("`@(BP*(B`M+2T]+2TM/2TM+2`@("`@("`@("`@("`@+2T]+2TM
XM/2TM("`@("`@("`@("`@("`@("`@("`@("`@+2TM+2TM+2TM+2`@("`@("`@
XM("`@("`@("`@("`@("`@("`M+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM
XM+2T@("`@("`@("`@("`@("`@("`@("`M+2TM+2TM+2TM+2TM+2TM+2TM+2TM
XM+2TM+2TM+2`@("`@("`@("`@("`@("`@("`M+2TM+2TM+2TM+2TM+2TM+2TM
XM+2TM+2TM+2T@("`@("`M+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2T@("`@
XM("`@(BP*(BTM+2TM+2TM+2TM("`@("`@("`@("`@("`@+2TM+2TM+2TM+2`@
XM("`@("`@("`@("`@("`@("`@("`M+2TM.RTM+2TM("`@("`@("`@("`@("`@
XM("`@("`@("`@("T[+2TM+2TM+3LM+2TM+2TM.RTM+2TM+2T[+2TM+2`@("`@
XM("`@("`@("`@("`@("`@("`M+2TM+3LM+2TM+2TM.RTM+2TM+2T[+2TM+2TM
XM+2`@("`@("`@("`@("`@("`@("`@+2TM+3LM+2TM+2TM.RTM+2TM+2T[+2TM
XM+2`@("`@("`@+2TM.RTM+2TM+2T[+2TM+2TM+3LM+2TM+2`@("`@("`@(BP*
XM(BTM+2TM+2TM+2T@("`@("`@("`@("`@("`@("TM+2TM+2TM+2T@("`@("`@
XM("`@("`@("`@("`@("`[.SL[.SL[.SL[("`@("`@("`@("`@("`@("`@("`@
XM("`@(#L[.SL[.SL[.SL[.SL[.SL[.SL[.SL[.SL[.SL@("`@("`@("`@("`@
XM("`@("`@("`@("`@.SL[.SL[.SL[.SL[.SL[.SL[.SL[.SL[.SL[("`@("`@
XM("`@("`@("`@("`@("`@.SL[.SL[.SL[.SL[.SL[.SL[.SL[.SL[("`@("`@
XM("`@.SL[.SL[.SL[.SL[.SL[.SL[.SL[.SL[("`@("`@("`@(BP*(CLM.SL[
XM.SL[.R`@("`@("`@("`@("`@("`@(#L[.SL[.RT[.SL[("`@("`@("`@("`@
XM("`@("`@("`[.SL[.SL[.SL@("`@("`@("`@("`@("`@("`@("`@("`@(#L[
XM.SL[.SL[.SL[.SL[.SL[.SL[.SL[.SL[("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@.SL[.SL[.SL[.SL[.SL[.SL[.SL[.SL[.R`@("`@("`@("`@("`@
XM("`@("`@("`@(#L[.SL[.SL[.SL[.SL[.SL[.SL[.R`@("`@("`@("`@(#L[
XM.SL[.SL[.SL[.SL[.SL[.SL[.R`@("`@("`@("`@(BP*(B`[.SL[.SL[.R`@
XM("`@("`@("`@("`@("`@("`[.SL[.SL[.SL[.R`@("`@("`@("`@("`@("`@
XM("`@(#LZ.SL[.CL@("`@("`@("`@("`@("`@("`@("`@("`@("`[.SLZ.SL@
XM("`@(#H[.SLZ.SL[.CL[.R`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM(#L[.CL[.SH[.SLZ.SL[.CL[.SH@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@.CL[.SH[.SLZ.SL[.CL[("`@("`@("`@("`@("`@("`@.SL[.CL[
XM.SH[.SLZ.SL[("`@("`@("`@("`@("`@(BP*(B`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@.SH[.CLZ.SH[.B`@("`@("`@("`@("`@("`@("`@("`Z
XM.CHZ.B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@(#HZ.B`@("`@("`@
XM.CHZ.CHZ.B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@(#HZ
XM.CHZ.CHZ.B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@.CHZ.CHZ.CHZ("`@("`@("`@("`@("`@("`@("`@("`@.CHZ.CHZ.CHZ
XM("`@("`@("`@("`@("`@("`@(BP*(B`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@(#HZ.CHZ.CHZ.B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
X0("`@("`@("`@("`@(GT["B`@
X`
Xend
END_OF_FILE
if test 15119 -ne `wc -c <'bitmaps/kibell.xpm.uu'`; then
    echo shar: \"'bitmaps/kibell.xpm.uu'\" unpacked with wrong size!
fi
# end of 'bitmaps/kibell.xpm.uu'
fi
if test -f 'level.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'level.c'\"
else
echo shar: Extracting \"'level.c'\" \(15856 characters\)
sed "s/^X//" >'level.c' <<'END_OF_FILE'
X#include "include/copyright.h"
X
X/*
X *  Include file dependencies:
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <stddef.h>
X#include <assert.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#include <xpm.h>
X
X#include "bitmaps/life.xpm"
X
X#include "include/error.h"
X#include "include/audio.h"
X#include "include/special.h"
X#include "include/intro.h"
X#include "include/gun.h"
X#include "include/init.h"
X#include "include/stage.h"
X#include "include/sfx.h"
X#include "include/score.h"
X#include "include/blocks.h"
X#include "include/bonus.h"
X#include "include/highscore.h"
X#include "include/ball.h"
X#include "include/main.h"
X#include "include/mess.h"
X#include "include/misc.h"
X
X#include "include/level.h"
X
X/*
X *  Internal macro definitions:
X */
X
X#define MAX_LIVES			6
X#define START_LIVES			3
X#define NEW_LIVE_SCORE_INC	100000L
X
X#define SHOTS_TO_KILL_SPECIAL	3
X
X#define BUF_SIZE			1024
X
X/*
X *  Internal type declarations:
X */
X
X#if NeedFunctionPrototypes
Xstatic void DrawLevelTimeBonus(Display *display, Window window, int timebonus);
X#else
Xstatic void DrawLevelTimeBonus();
X#endif
X
X/*
X *  Internal variable declarations:
X */
X
XPixmap		lifePixmap, lifeMask;	
Xint 		livesLeft = 3;
Xu_long		level;
Xu_long		startlevel;
Xtime_t		gameTime;
Xint			bonus = 1;
Xchar 		levelTitle[BUF_SIZE];
Xint 		bonusBlock = False;
Xstatic int 	bulletPos;
Xstatic int 	timeBonus;
X
X#if NeedFunctionPrototypes
Xvoid InitialiseLevelInfo(Display *display, Window window, Colormap colormap)
X#else
Xvoid InitialiseLevelInfo(display, window, colormap)
X	Display *display;
X	Window window;
X	Colormap colormap;
X#endif
X{
X	XpmAttributes   attributes;
X	int 			XpmErrorStatus;
X
X	attributes.valuemask = XpmColormap;
X	attributes.colormap = colormap;
X
X	/* Create xpm pixmap for the life */
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, life_xpm, 
X		&lifePixmap, &lifeMask, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseLevelInfo()");
X
X	/* Free the xpm pixmap attributes */
X	XpmFreeAttributes(&attributes);
X}
X
X#if NeedFunctionPrototypes
Xvoid DecLevelTimeBonus(Display *display, Window window)
X#else
Xvoid DecLevelTimeBonus(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	/* Decrement the time bonus */
X	timeBonus--;	
X
X	/* Cannot step back in time */
X	if (timeBonus < 0) 
X		timeBonus = 0;
X	else
X	{
X		/* Draw the time bonus */
X		DrawLevelTimeBonus(display, window, timeBonus);
X	}
X}
X
X#if NeedFunctionPrototypes
Xint GetLevelTimeBonus(void)
X#else
Xint GetLevelTimeBonus()
X#endif
X{
X	/* return the time bonus */
X	return timeBonus;	
X}
X
X#if NeedFunctionPrototypes
Xvoid SetLevelTimeBonus(Display *display, Window window, int seconds)
X#else
Xvoid SetLevelTimeBonus(display, window, seconds)
X	Display *display;
X	Window window;
X	int seconds;
X#endif
X{
X	assert(timeBonus >= 0);
X
X	/* Reset the time bonus to desired time */
X	timeBonus = seconds;	
X
X	/* Draw the time bonus */
X	DrawLevelTimeBonus(display, window, timeBonus);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DrawLevelTimeBonus(Display *display, Window window, int timebonus)
X#else
Xstatic void DrawLevelTimeBonus(display, window, timebonus)
X	Display *display;
X	Window window;
X	int timebonus;
X#endif
X{
X	int len, minutes, seconds;
X	char str[10];
X
X	/* Work out the minutes and seconds using time bonus */
X	minutes = timebonus / 60;
X	seconds = timebonus % 60;
X
X	/* Construct a string with the time bonus and draw it */
X	sprintf(str, "%02d:%02d", minutes, seconds);
X	len = strlen(str);
X
X	/* Draw the text now thanks  - using title font for big numbers */
X	XClearWindow(display, window);
X	DrawText(display, window, 2, 7, titleFont, black, str, len);
X
X	/* The less time you have the more drastic the colour comes */
X	if (timebonus <= 10)
X		DrawText(display, window, 0, 5, titleFont, red, str, len);
X	else if (timebonus <= 60)
X		DrawText(display, window, 0, 5, titleFont, yellow, str, len);
X	else 
X		DrawText(display, window, 0, 5, titleFont, green, str, len);
X}
X
X#if NeedFunctionPrototypes
Xvoid DrawLife(Display *display, Window window, int x, int y)
X#else
Xvoid DrawLife(display, window, x, y)
X	Display *display;
X	Window window;
X	int x;
X	int y;
X#endif
X{
X	/* Draw the life pixmap */
X	RenderShape(display, window, lifePixmap, lifeMask, 
X		x-12, y-12, 25, 24, True);
X}
X
X#if NeedFunctionPrototypes
Xvoid DisplayLevelInfo(Display *display, Window window, u_long level)
X#else
Xvoid DisplayLevelInfo(display, window, level)
X	Display *display;
X	Window window;
X	u_long level;
X#endif
X{
X	int i;
X
X	/* Clear the window for level information */
X	XClearWindow(display, levelWindow);
X
X	/* Put the level number up */
X	DrawOutNumber(display, levelWindow, level, 260, 0);
X
X	/* Draw out the lives left pixmaps */
X	for (i = 0; i < livesLeft; i++)
X		DrawLife(display, window, 175 - (i * 30), 21);
X
X	/* Draw the score in the score window */
X	DisplayScore(display, scoreWindow, score);
X
X	/* Draw all the bullets in the ammo pouch ;-) */
X	ReDrawBulletsLeft(display);
X
X	XFlush(display);
X}
X
X#if NeedFunctionPrototypes
Xvoid SetLevelNumber(int levelNum)
X#else
Xvoid SetLevelNumber(levelNum)
X	int levelNum;
X#endif
X{
X	level = (u_long) levelNum;
X}
X
X#if NeedFunctionPrototypes
Xvoid SetStartingLevel(int levelNum)
X#else
Xvoid SetStartingLevel(levelNum)
X	int levelNum;
X#endif
X{
X	startlevel = (u_long) levelNum;
X}
X
X#if NeedFunctionPrototypes
Xint GetStartingLevel(void)
X#else
Xint GetStartingLevel()
X#endif
X{
X	return ((int) startlevel);
X}
X
X#if NeedFunctionPrototypes
Xvoid RedrawLevelInfo(Display *display, Window window)
X#else
Xvoid RedrawLevelInfo(display, window)
X	Display *display;
X	Window	window;
X#endif
X{
X	DisplayLevelInfo(display, window, level);
X}
X
X#if NeedFunctionPrototypes
Xvoid FreeLevelInfo(Display *display)
X#else
Xvoid FreeLevelInfo(display)
X	Display *display;
X#endif
X{
X	/* Free the life pixmap  */
X	if (lifePixmap)		XFreePixmap(display, lifePixmap);
X	if (lifeMask)		XFreePixmap(display, lifeMask);
X}
X
X#if NeedFunctionPrototypes
Xvoid DeleteABullet(Display *display)
X#else
Xvoid DeleteABullet(display)
X	Display *display;
X#endif
X{
X	bulletPos = 192 - (GetNumberBullets() * 9);
X
X	/* Take a bullet away from ammo belt */
X	EraseTheBullet(display, levelWindow, bulletPos, 43);
X
X	DecNumberBullets();
X}
X
X#if NeedFunctionPrototypes
Xvoid AddABullet(Display *display)
X#else
Xvoid AddABullet(display)
X	Display *display;
X#endif
X{
X	IncNumberBullets();
X
X	bulletPos = 192 - (GetNumberBullets() * 9);
X
X	/* Add a bullet to the ammo belt */
X	DrawTheBullet(display, levelWindow, bulletPos, 43);
X}
X
X#if NeedFunctionPrototypes
Xvoid ReDrawBulletsLeft(Display *display)
X#else
Xvoid ReDrawBulletsLeft(display)
X	Display *display;
X#endif
X{
X	int x, i;
X
X	/* Draw the bullets in the ammo belt */
X	for (i = 0; i < GetNumberBullets(); i++)
X	{
X		x = 192 - ((i+1) * 9);
X		DrawTheBullet(display, levelWindow, x, 43);
X	} 
X}
X
X#if NeedFunctionPrototypes
Xvoid DecExtraLife(Display *display)
X#else
Xvoid DecExtraLife(display)
X	Display *display;
X#endif
X{
X	/* Take a life */
X	livesLeft--;
X
X	if (livesLeft < 0) 
X		livesLeft = 0;
X
X	/* redraw the level info */
X	DisplayLevelInfo(display, levelWindow, level);
X}
X
X#if NeedFunctionPrototypes
Xvoid AddExtraLife(Display *display)
X#else
Xvoid AddExtraLife(display)
X	Display *display;
X#endif
X{
X	/* Add a new life */
X	livesLeft++;
X
X	/* Dont issue too many extra balls! */
X	if (livesLeft >= MAX_LIVES) 
X		livesLeft = MAX_LIVES;
X	else
X		SetCurrentMessage(display, messWindow, "Extra ball", True);
X
X	/* redraw the level info */
X	DisplayLevelInfo(display, levelWindow, level);
X}
X
X#if NeedFunctionPrototypes
Xvoid CheckAndAddExtraLife(Display *display, long score)
X#else
Xvoid CheckAndAddExtraLife(display, score)
X	Display *display;
X	long score;
X#endif
X{
X	static int ballInc = 0;
X
X	/* Add a new life? */
X	if ((score) && ((score / NEW_LIVE_SCORE_INC) != ballInc)) 
X	{
X		/* Add a new life */
X		AddExtraLife(display);
X	}
X
X	/* Next inc before adding a new life */
X	ballInc = score / NEW_LIVE_SCORE_INC;
X}
X
X#if NeedFunctionPrototypes
Xvoid HandleGameTimer(Display *display, Window window)
X#else
Xvoid HandleGameTimer(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	static time_t oldTime = 0;
X
X	/* Time to decrement the timer */
X	if (time(NULL) > oldTime)
X	{
X		/* Decrement the timer bonus */
X		DecLevelTimeBonus(display, timeWindow);
X		oldTime = time(NULL);
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid CheckGameRules(Display *display, Window window)
X#else
Xvoid CheckGameRules(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int b = 0;
X
X	CheckAndAddExtraLife(display, score);
X
X	HandleGameTimer(display, window);
X
X	if (StillActiveBlocks() == False)
X	{
X		/* Turn off the x2 x4 bonuses */
X		Togglex2Bonus(display, False);
X		Togglex4Bonus(display, False);
X		DrawSpecials(display);
X
X		/* How many balls still left after level */
X		b = GetNumberOfActiveBalls();
X		if (b > 1)
X		{
X			/* Put back on the status area the number of balls left */
X			while (--b)
X				AddExtraLife(display);
X		}
X
X		/* Give the play a big head */
X		if (noSound == False) playSoundFile("applause", 70);
X
X		/* Finished level now so set up bonus screen */
X        mode = MODE_BONUS;
X		SetupBonusScreen(display, mainWindow);
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid UpdateHighScores(void)
X#else
Xvoid UpdateHighScores()
X#endif
X{
X	time_t endTime;
X	u_long theLevel;
X
X	/* Obtain the game duration in seconds - taking account for pauses */
X	endTime = time(NULL) - gameTime - pausedTime;
X
X	/* Adjust the level so that the starting level is taken into account */
X	theLevel = level - (u_long) GetStartingLevel() + 1L;
X
X	/* Update the high score table */
X	(void) CheckAndAddScoreToHighScore(score, theLevel, endTime, PERSONAL);
X	if (CheckAndAddScoreToHighScore(score, theLevel, endTime, GLOBAL) == False)
X		ResetHighScore(PERSONAL);
X	else
X		ResetHighScore(GLOBAL);
X}
X
X
X#if NeedFunctionPrototypes
Xvoid EndTheGame(Display *display, Window window)
X#else
Xvoid EndTheGame(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	/* Game over man! */
X	SetCurrentMessage(display, messWindow, "- Game Over - ", True);
X
X	if (noSound == False)
X		playSoundFile("game_over", 100);
X
X	UpdateHighScores();
X
X	/* Reset game and setup for high score table */
X	gameActive = False;
X	SetLevelNumber(GetStartingLevel());
X	ResetIntroduction();
X	mode = MODE_HIGHSCORE;
X
X	TurnSpecialsOff(display);
X}
X
X#if NeedFunctionPrototypes
Xvoid DeadBall(Display *display, Window window)
X#else
Xvoid DeadBall(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X
X	/* Decrement the number of lives left and display so */
X	livesLeft--;
X	DisplayLevelInfo(display, levelWindow, level);
X
X	/* Disable some of the specials */
X	Togglex2Bonus(display, False);
X	Togglex4Bonus(display, False);
X	ToggleKiller(display, False);
X	DrawSpecials(display);
X
X	SetCurrentMessage(display, messWindow, "Ball vapourised!", True);
X
X	if (livesLeft < 0 && GetAnActiveBall() == -1)
X		EndTheGame(display, window);
X	else 
X	{
X		if (noSound == False) playSoundFile("balllost", 100);
X		ResetBallStart(display, window);
X	}
X}
X
X#if NeedFunctionPrototypes
Xchar *GetLevelName(void)
X#else
Xchar *GetLevelName()
X#endif
X{
X	/* Return the name of the current level */
X	return (levelTitle);
X}
X
X#if NeedFunctionPrototypes
Xint ReadNextLevel(Display *display, Window window, char *levelName)
X#else
Xint ReadNextLevel(display, window, levelName)
X	Display *display;
X	Window window;
X	char *levelName;
X#endif
X{
X	FILE *levelFile;
X	int row, col, type;
X	char str[BUF_SIZE];
X	int	timeLimit = 180;
X
X	/* Clear all existing mess in structures */
X	ClearBlockArray();
X
X	/* Setup the new level data */
X    blocksExploding = 0;
X	colWidth 	= PLAY_WIDTH / MAX_COL;
X	rowHeight 	= PLAY_HEIGHT / MAX_ROW;
X	bonusBlock 	= False;
X	ResetNumberBonus();
X
X	/* Open the new level data file for reading */
X	if ((levelFile = fopen(levelName, "r")) == NULL)
X	{
X		ErrorMessage("Cannot load level data - check level directory.");
X		return False;
X	}
X
X	/* Obtain the title string */
X	fgets(levelTitle, BUF_SIZE, levelFile);
X
X	/* Now get the time bonus from the level file */
X	fgets(str, BUF_SIZE, levelFile);
X	if (sscanf(str, "%d", &timeLimit) != 1)
X	{
X		ErrorMessage("Cannot parse level data - time bonus error.");
X		return False;
X	}
X
X	/* Set and draw the time limit for the level */
X	SetLevelTimeBonus(display, timeWindow, timeLimit);
X
X	for (row = 0; row < (MAX_ROW - 3); row++)
X	{
X		for (col = 0; col < MAX_COL; col++)
X		{
X			/* Get the next character from the level data file */
X			type = fgetc(levelFile);
X
X			switch (type)
X			{
X				case 'H' :	/* hyperspace block - walls are now gone */
X					AddNewBlock(display, window, row, col, HYPERSPACE_BLK, 0);
X					break;
X					
X				case 'B' :	/* bullet block - ammo */
X					AddNewBlock(display, window, row, col, BULLET_BLK, 0);
X					break;
X					
X				case 'r' :	/* A red block */
X					AddNewBlock(display, window, row, col, RED_BLK, 0);
X					break;
X					
X				case 'g' :	/* A green block */
X					AddNewBlock(display, window, row, col, GREEN_BLK, 0);
X					break;
X					
X				case 'b' :	/* A blue block */
X					AddNewBlock(display, window, row, col, BLUE_BLK, 0);
X					break;
X					
X				case 't' :	/* A tan block */
X					AddNewBlock(display, window, row, col, TAN_BLK, 0);
X					break;
X					
X				case 'p' :	/* A purple block */
X					AddNewBlock(display, window, row, col, PURPLE_BLK, 0);
X					break;
X					
X				case 'y' :	/* A yellow block */
X					AddNewBlock(display, window, row, col, YELLOW_BLK, 0);
X					break;
X					
X				case 'w' :	/* A solid wall block */
X					AddNewBlock(display, window, row, col, BLACK_BLK, 0);
X					break;
X					
X				case '0' :	/* A counter block - no number */
X					AddNewBlock(display, window, row, col, COUNTER_BLK, 0);
X					break;
X					
X				case '1' :	/* A counter block level 1 */
X					AddNewBlock(display, window, row, col, COUNTER_BLK, 1);
X					break;
X					
X				case '2' : /* A counter block level 2 */
X					AddNewBlock(display, window, row, col, COUNTER_BLK, 2);
X					break;
X					
X				case '3' : /* A counter block level 3 */
X					AddNewBlock(display, window, row, col, COUNTER_BLK, 3);
X					break;
X					
X				case '4' : /* A counter block level 4 */
X					AddNewBlock(display, window, row, col, COUNTER_BLK, 4);
X					break;
X					
X				case '5' : /* A counter block level 5  - highest */
X					AddNewBlock(display, window, row, col, COUNTER_BLK, 5);
X					break;
X					
X				case 'X' : /* A bomb block - arggh! */
X					AddNewBlock(display, window, row, col, BOMB_BLK, 0);
X					break;
X
X				case 'D' : /* A death block */
X					AddNewBlock(display, window, row, col, DEATH_BLK, 
X						SHOTS_TO_KILL_SPECIAL);
X					break;
X
X				case 'L' : /* An extra ball block */
X					AddNewBlock(display, window, row, col, EXTRABALL_BLK, 0);
X					break;
X
X				case 'M' : /* A machine gun block */
X					AddNewBlock(display, window, row, col, MGUN_BLK, 
X						SHOTS_TO_KILL_SPECIAL);
X					break;
X
X				case 'W' : /* A wall off block */
X					AddNewBlock(display, window, row, col, WALLOFF_BLK, 
X						SHOTS_TO_KILL_SPECIAL);
X					break;
X
X				case '?' : /* A random changing block */
X					AddNewBlock(display, window, row, col, RANDOM_BLK, 0);
X					break;
X
X				case 'm' : /* A multiple ball block */
X					AddNewBlock(display, window, row, col, MULTIBALL_BLK, 
X						SHOTS_TO_KILL_SPECIAL);
X					break;
X
X				case 's' : /* A sticky block */
X					AddNewBlock(display, window, row, col, STICKY_BLK, 
X						SHOTS_TO_KILL_SPECIAL);
X					break;
X
X				case 'R' :	/* reverse block - switch paddle control */
X					AddNewBlock(display, window, row, col, REVERSE_BLK, 
X						SHOTS_TO_KILL_SPECIAL);
X					break;
X					
X				case '<' :	/* shrink paddle block - make paddle smaller */
X					AddNewBlock(display, window, row, col, PAD_SHRINK_BLK, 
X						SHOTS_TO_KILL_SPECIAL);
X					break;
X					
X				case '>' :	/* expand paddle block - make paddle bigger */
X					AddNewBlock(display, window, row, col, PAD_EXPAND_BLK, 
X						SHOTS_TO_KILL_SPECIAL);
X					break;
X					
X				default:
X					break;
X			}
X		}
X
X		/* Get the newline */
X		type = fgetc(levelFile);
X	}
X
X	/* Close our level data file */
X	if (fclose(levelFile) < 0)
X		WarningMessage("Cannot close level data file.");
X
X	return True;
X}
END_OF_FILE
if test 15856 -ne `wc -c <'level.c'`; then
    echo shar: \"'level.c'\" unpacked with wrong size!
fi
# end of 'level.c'
fi
if test -f 'score.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'score.c'\"
else
echo shar: Extracting \"'score.c'\" \(5369 characters\)
sed "s/^X//" >'score.c' <<'END_OF_FILE'
X#include "include/copyright.h"
X
X/*
X *  Include file dependencies:
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <stddef.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#include <xpm.h>
X
X#include "bitmaps/digit0.xpm"
X#include "bitmaps/digit1.xpm"
X#include "bitmaps/digit2.xpm"
X#include "bitmaps/digit3.xpm"
X#include "bitmaps/digit4.xpm"
X#include "bitmaps/digit5.xpm"
X#include "bitmaps/digit6.xpm"
X#include "bitmaps/digit7.xpm"
X#include "bitmaps/digit8.xpm"
X#include "bitmaps/digit9.xpm"
X
X#include "include/error.h"
X#include "include/init.h"
X#include "include/special.h"
X#include "include/misc.h"
X
X#include "include/score.h"
X
X/*
X *  Internal macro definitions:
X */
X
X#define NUM_DIGITS	10
X
X/*
X *  Internal type declarations:
X */
X
X/*
X *  Internal variable declarations:
X */
X
XPixmap	digitPixmaps[NUM_DIGITS];
XPixmap	digitPixmapsM[NUM_DIGITS];
X
Xu_long score = 0L;
X
X
X#if NeedFunctionPrototypes
Xvoid InitialiseScoreDigits(Display *display, Window window, Colormap colormap)
X#else
Xvoid InitialiseScoreDigits(display, window, colormap)
X	Display *display;
X	Window window;
X	Colormap colormap;
X#endif
X{
X	XpmAttributes   attributes;
X	int 			XpmErrorStatus;
X
X	attributes.valuemask = XpmColormap;
X	attributes.colormap = colormap;
X
X	/* Create all xpm pixmap digits from the files */
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, digit0_xpm, 
X		&digitPixmaps[0], &digitPixmapsM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseScoreDigits()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, digit1_xpm, 
X		&digitPixmaps[1], &digitPixmapsM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseScoreDigits()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, digit2_xpm, 
X		&digitPixmaps[2], &digitPixmapsM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseScoreDigits()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, digit3_xpm, 
X		&digitPixmaps[3], &digitPixmapsM[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseScoreDigits()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, digit4_xpm, 
X		&digitPixmaps[4], &digitPixmapsM[4], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseScoreDigits()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, digit5_xpm, 
X		&digitPixmaps[5], &digitPixmapsM[5], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseScoreDigits()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, digit6_xpm, 
X		&digitPixmaps[6], &digitPixmapsM[6], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseScoreDigits()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, digit7_xpm, 
X		&digitPixmaps[7], &digitPixmapsM[7], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseScoreDigits()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, digit8_xpm, 
X		&digitPixmaps[8], &digitPixmapsM[8], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseScoreDigits()");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, digit9_xpm, 
X		&digitPixmaps[9], &digitPixmapsM[9], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseScoreDigits()");
X
X	/* Free the xpm pixmap attributes */
X	XpmFreeAttributes(&attributes);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DrawDigit(Display *display, Window window, int digit, int x, int y)
X#else
Xstatic void DrawDigit(display, window, digit, x, y)
X	Display *display;
X	Window window;
X	int digit;
X	int x;
X	int y;
X#endif
X{
X	/* Draw the digit in the window */
X	RenderShape(display, window, 
X		digitPixmaps[digit], digitPixmapsM[digit], x, y, 30, 40, True);
X}
X
X#if NeedFunctionPrototypes
Xvoid DrawOutNumber(Display *display, Window window, u_long score, int x, int y)
X#else
Xvoid DrawOutNumber(display, window, score, x, y)
X	Display *display;
X	Window window;
X	u_long score;
X	int x;
X	int y;
X#endif
X{
X	int digit;
X
X	/* Get the digit that we want from the score */
X	if (score / 10)
X		DrawOutNumber(display, window, (score / 10), x - 32, y);
X
X	/* Work out the digit needed to draw */
X	digit = (score % 10);
X
X	DrawDigit(display, window, digit, x - 32, y);
X}
X
X#if NeedFunctionPrototypes
Xvoid AddToScore(u_long inc)
X#else
Xvoid AddToScore(inc)
X	u_long inc;
X#endif
X{
X	/* Take into account any score bonuses */
X	if (x2Bonus == True)
X		inc *= 2;
X	else if (x4Bonus == True)
X		inc *= 4;
X
X	/* Increment the score */
X	score += inc;
X}
X
X#if NeedFunctionPrototypes
Xvoid DisplayScore(Display *display, Window window, u_long score)
X#else
Xvoid DisplayScore(display, window, score)
X	Display *display;
X	Window window;
X	u_long score;
X#endif
X{
X	/* Erase the old score in the window */
X	XClearWindow(display, window);
X
X	/* Draw a zero if no score */
X	if (score == 0L)
X		RenderShape(display, window, 
X			digitPixmaps[0], digitPixmapsM[0], 192, 0, 30, 40, True);
X	else
X		/* Draw the score digits rescursively */
X		DrawOutNumber(display, window, score, 224, 0);
X}
X
X#if NeedFunctionPrototypes
Xvoid FreeScoreDigits(Display *display)
X#else
Xvoid FreeScoreDigits(display)
X	Display *display;
X#endif
X{
X	int i;
X
X	/* Free the memory associated with the digit pixmaps */
X	for (i = 0; i < NUM_DIGITS; i++)
X	{
X		/* Free the digits pixmap and mask */
X		if (digitPixmaps[i])	XFreePixmap(display, digitPixmaps[i]);
X		if (digitPixmapsM[i])	XFreePixmap(display, digitPixmapsM[i]);
X	}
X}
X
END_OF_FILE
if test 5369 -ne `wc -c <'score.c'`; then
    echo shar: \"'score.c'\" unpacked with wrong size!
fi
# end of 'score.c'
fi
if test -f 'xboing.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xboing.man'\"
else
echo shar: Extracting \"'xboing.man'\" \(15702 characters\)
sed "s/^X//" >'xboing.man' <<'END_OF_FILE'
X.TH XBOING 6 "August 1993" "X Version 11"
X.SH NAME
X
X\fIxboing\fP \- An X Window System based blockout clone. V1.7
X
X.SH SYNOPSIS
X
X\fIxboing\fP [-version] [-usage] [-help] [-sync] [-display <displayName>] [-speed <1-10>] [-scores] [-keys] [-sound] [-setup] [-nosfx] [-nograb] [-maxvol <1-100>] [-startlevel <1-MAXLEVELS>] [-usedefcmap]
X
X    -speed <n>         - The game speed, 1 - 9. 9=Fast
X    -maxvol <n>        - The maximum volume as percentage
X    -startlevel <n>    - The starting level for game.
X    -help              - Produce this help message.
X    -sync              - Turn on X synchronisation.
X    -usage             - Print a brief help message.
X    -version           - Print out the current version.
X    -scores            - Print out current highscores.
X    -keys              - Use keys instead of mouse control.
X    -sound             - Turn audio ON for game.
X    -setup             - Print setup information.
X    -nosfx             - Turn off special effects.
X    -nograb            - Turn pointer grabbing off.
X    -usedefcmap        - Use the default colourmap.
X    -display <display> - Set the display for the game.
X
X.SH DESCRIPTION
X
X\fIXBoing\fP is a simple blockout type game where you have a paddle which you control to bounce a ball around the game area destroying blocks with the proton ball. 
X
XEach block carries a different point value. The more blocks you destroy, the better your score. The person with the highest score wins.
X
XThe play area is filled with blocks and other objects. You have a paddle that
Xcan move from left to right at the bottom of the arena. You move the paddle
Xso that the proton ball bounces around blowing up blocks does not go past the
Xpaddle and out the bottom, much like a pinball game.
X
XThe blocks exhibit different behaviour. The bomb block when hit will explode all
Xblocks around it. If another bomb is beside it then it will go off also. The
Xsolid wall brick will not explode unless next a bomb. The ammunition block will
Xgive you four bullets and so on. Special blocks such as reverse and machine gun will only last for one level.
X
XThere are random blocks that change their colour and therefore their points every now and then. They add a bit of change to the levels.
X
XThere is a pirate symbol that will kill your ball if touched. You can shoot this block 3 times to kill it but you will lose 1000 points. Keep away from the Death block, it kills your ball!
X 
XThe walls off block will turn the wall bounce off on both the left and right side of the playing area. This will mean the ball will not bounce off but continue through the wall and wrap around to the other side respectively.
X
XThe reverse block will when hit reverse the controls to the paddle. This block should be avoided as it makes the game really hard. Hitting another reverse while already in reverse mode will turn it off.
X
XThe teleport block will teleport the ball somewhere else on that level. It will not place you too close to the bottom of the screen or on another block.
X
XThe sticky paddle block will stick the ball to your paddle each time it is hit and wait until you press space to shoot it off again. This can be a #$%$#@! and also useful for lining up shots for hard bricks.
X
XThere is a machine gun block that allows you to shoot much faster. Note that you will also go through your bullets at a great rate. Can be fun to let off a burst every now and then. Erases counter blocks very fast.
X
XAn extra ball symbol may appear and when shot or hit with another ball it will give you an extra ball!
X
XThere is a shrink paddle block that will shrink you paddle to a smaller size for the level. If you currently have the smallest paddle then it has no effect.
X
XThere is an expand paddle block that will grow you paddle to a larger size for the level. If you currently have the largest paddle then it has no effect.
X
XYou can use the bullets to shoot the last pesky blocks or to collet lots of
XYou can use the bullets to shoot the last pesky blocks or to collet lots of
Xbonus coins. You will be given 4 bullets when a new level starts. If you lose
Xa ball you will be given a token 2 bullets. Use bullets wisely as you will
Xhate yourself when there is one brick left and the ball is missing it for ever.
X
XThroughout the game the bonus coins will appear. Collect these for bonus points when the level is finished. Sometimes the coin may appear as a x2 or x4 symbol which will indicate that the scoring from now onwards will be multiplied by 2 or 4 respectively. Note: if you get a x2 then x4 then x2 you will go back to x2 mode. Also note that this x2 or x4 mode will be disabled after each ball death.
X
XIf you collect more than 10 bonuses during a level the killer mode is activated which will turn the ball red and the ball will plough through all blocks except the solid ones and finish off the level very quickly. You will also receive the SUPER BONUS on the bonus screen.
X
XThe bonus screen will tell you how you went in the last level. Your bonuses
Xwill be added and the bullet and level bonus will be added. You get 500 points
Xfor each bullet not used. You get 3000 points for each bonus and if you get
Xmore than 10 bonuses you get a SUPER BONUS of 50000 points. You also get a new
Xball every 100,000 points. Pressing space will skip the bonus animations when
Xthe bonus screen appears. Your bonus score will still be added.
X
XThere is a level timer that counts down while playing the level. If you don't
Xcomplete the level in time you will not get the time bonus which is 100 points
Xper second remaining. You will also miss out on the level bonus if your time runs out.
X
XThe ball will be automatically shot off the paddle after about 5 seconds unless you press the space bar. You can always press P to pause the game.
X
XIf the ball gets stuck in an infinite loop it will automatically tilt the board if the ball hasn't hit the paddle after a certain time span. The time span is about 8 seconds I think.
X
XXBoing was started like many other projects to learn Xlib better. I had the
XXPM library and was already using it in a Motif application. I thought that it
Xwould be cool to have nice colour pictures/animations in an Xlib game. So I
Xdid. Without the XPM library I would be still playing with the colours I think.
X
X.SH OPTIONS
X
XThe \fIspeed\fP option will adjust the speed of the overall game. It will except integer numbers between 1 and 9. This option is a little dodgy. The speed of the game can be changed from within the game as well. See Game Control. The default value is 1.
X
XThe \fImaxvol\fP option allows you to adjust the maximum volume to be used for the sound effects if sound is supported. It doesn't mean all sounds will be this volume but they will use that volume as the top volume to scale against.
X
XThe \fIstartlevel\fP option allows you to set the starting level for your games. Note that when your score is placed in the highscore table the level number is the number of levels completed and not the level number attained. Also, in the bonus screen your level bonus will be the number of levels completed multiplied by the level bonus value and not the current level number!
X
XThe \fIhelp\fP option will display a brief one line description of all the command line options used with xboing.
X
XThe \fIsync\fP option will turn on the X Window System synchronisation of all Xlib calls which means that all calls are flushed by the X server before continuing. This will cause the game to become slower but enable some debugging. The default is OFF.
X
XThe \fIusage\fP option will print a very brief synopsis of all the command line options and there value ranges.
X
XThe \fIversion\fP option prints the version of xboing that you are running.
X
XThe \fIscores\fP option will print both the roll of honour and your personal best scores to standard out. This can be useful if you are not running the program on an X window display and still want to see what the scores are.
X
XThe \fIkeys\fP option will enable the use of the keyboard for game control. Within the game you may press <g> to toggle between mouse and key control. The default is MOUSE control.
X
XThe \fIsound\fP option will enable sound to be turned on if possible. The default is OFF.
X
XThe \fIsetup\fP option is useful when you have just compiled the program. It will display the paths of the level & sound directories and also give you some information on other things.
X
XThe \fInosfx\fP option will turn OFF special effects. The special effect in question at this stage is the explosion shake. Turning it off will speed the game up a little bit. The default is ON. Servers without backing store will have it turn off automatically as the shaking is shocking.
X
XThe \fInograb\fP option will make xboing not grab the pointer when the game is visible. Pointer grabbing has the effect of stopping you move the pointer outside the game window. This is useful as it constrains the mouse and you don't get colourmap flashes. The default is ON.
X
XThe \fIusedefcmap\fP option will make xboing try to use the default colourmap. This will be fine if the default colourmap is reasonabily empty. If you have a complex picture on your background then this option will not work and xboing will be unable to allocate enough colours.
X
XThe \fIdisplay\fP option will allow you to force the game to be viewed on another display. The format of the display name is <xserver:0.0> like most other programs where xserver is the name of the display. The default is your display of course.
X
XYou may also set three environment variables used by xboing. They specify the location of the level files, sounds and the highscore file. They are listed below.
X
XXBOING_SCORE_FILE = the highscore file to be used.
XXBOING_LEVELS_DIR = the directory containing the levels.
XXBOING_SOUND_DIR  = the directory containing the sounds.
X
XThey will override the settings that are compiled into the program.
X
X.SH GAME CONTROL
X.PP
XYou must have specified "-keys" on the command line to use the keys for
Xthe paddle control. The default is to use the mouse control method.
X.nf
X
XJ = Paddle Left
XLeftArrow = Paddle Left
XK = Shoot bullet
XL = Paddle Right
XRightArrow = Paddle Right
X
XAll Mouse Buttons = Shoot Bullet/Start ball
X
XUse the mouse to move the paddle left and right by moving the mouse 
Xleft and right. The paddle will follow the mouse pointer. This is
Xthe best method and easiest to use by far.
X
XSpace   = Start game
XEscape  = End game and return to introduction.
Xi       = iconify the game and pause.
XH       = View roll of honour.
Xh       = View personal highscores.
Xp       = Pause game.
Xd       = Kill the ball.
Xa       = Toggle audio on/off
Xs       = Toggle special effects on/off
Xc       = Cycle through the intro screens.
X1-9    = Game speed where 9 is fastest.
Xq       = Quit XBoing
X
XNote: Highscores are saved at the end of each game.
X.fi
X.PP
X.SH SCORING
X
XEach blocks has a certain point score. Some blocks such as the counter block will have more than one score associated with it.
X
X.nf
Xred = 100
Xblue = 110
Xgreen = 120
Xyellow = 140
Xtan = 130
Xpurple = 150
Xbomb = 50 plus the surrounding blocks points
Xwall = 0
Xpirate = 100
Xreverse = 100
Xammo = 50 plus bullets
Xcounter = 200 (each number). 
X.fi
X
XEach time the paddle is hit with the ball your earn 10 points. I'm nice.
X
XThere are death symbols (a pirate) that when hit by a ball will kill the ball. You can shoot them but you will lose 1000 points.
X
XThe bonus coins are 3000 points - but only added to score if you reach the end of the level and go through the bonus screen.
X
XIf you collect more than 10 bonus coins you get a Super Bonus of 50,000 points. Each remaining bullet after a level is worth 500 points.
X
XAt the end of each level you are awarded a level bouns which is level <n> x 1000 points. So for level 20 you get 20,000 points! If you fail to complete the level in the time allotted you will not receive a level bonus.
X
XThere are now two highscore files. One displays the global scores which will be your best score to date. The other is a personal high score table with all your attempts.
X
X.SH SOUND SUPPORT
X
XXboing has limited support for sound. It has sound code for the following machines :-
X
XHP, SUN, NCD Xterminals, LINUX PC Soundblaster, RPLAY sound system.
X
XMost support and use the SUN .au format sound files. The linux version just sends the data down to the audio device which may cause slight clicking sounds due to the audio file header. Future versions of xboing will support other machines if patches are sent to me or if I learn the sound format. SGI will be next but they have their own format, argghh. I am not going to have heaps of converted files all over the place in different formats as the archive would be HUGE.
X
X.SH LEVELS
X
XThe levels are not increasingly harder to play - some are but some are easy. This is because it takes ages to create and design levels. The paddle does get smaller as the game goes on. This makes it REALLY hard. I may also add a ball speedup feature.
X
XThe level data is a simple ASCII file format that can be edited. The levels
Xare loaded when required from the directory specified when the game was made.
X
XYou can create more levels if you like making sure that they are in the correct
Xformat and that they have a correct filename format.
X
XCopy level0.data to level??.data and use that for the editing of new levels.
X
Xlevel format:	(case sensitive)
X
X    w = wall block
X    r = red block
X    g = green block
X    b = blue block
X    t = tan block
X    p = purple block
X    y = yellow block
X    X = Bomb
X    B = Ammo
X    . = blank
X    D = Death
X    R = Reverse
X    H = Teleport
X    L = Extra ball
X    M = Machine Gun
X    W = Walls off
X    ? = Random block
X    m = Multiple balls
X    s = sticky block
X    < = Shrink paddle block
X    > = Grow paddle block
X
XThe format of the level is shown in the newlevel.data file in the source distribution in the levels directory.
X
XMake sure you have a level title and a time bonus in seconds.
X
X.SH NOTES
X
XObatin all new versions from ftp.x.org or a mirror site.
X
X.SH REDISTRIBUTION 
X
X(c) Copyright 1993, Justin C. Kibell, All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its documentation without written agreement is hereby granted. You cannot sell this software without written permission from the author. This entire copyright notice must appear in all copies of this software.
X
XIN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
X
XTHE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE AUTHOR HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
X
X.SH AUTHOR
X
XJustin C. Kibell - Systems Programmer - CATT Centre CITRI Melbourne - Victoria - Australia.  email: jck@citri.edu.au
XSnailMail: 1/17 Albert Road, North Warrandyte, Victoria, Australia, 3113
X
XComputer Science Graduate - Royal Melbourne Institute of Technology (RMIT) - Australia
X
X.SH BUGS
X
XSee README documents in source distribution for list of bugs and bug fixes. 
X
XMail all bug reports/suggestions to jck@citri.edu.au specifying the version and machine type you are using. Use 'uname -a' to explain the machine type. Please note the version of X11 that you have installed as well, ie: X11R5, X11R4, etc.
X
XPlease note that xboing will run like a pig on the xnews X server distributed with Sun machines. Please try to use the MIT X Server that comes with the X Window System.
END_OF_FILE
if test 15702 -ne `wc -c <'xboing.man'`; then
    echo shar: \"'xboing.man'\" unpacked with wrong size!
fi
# end of 'xboing.man'
fi
echo shar: End of archive 21 \(of 30\).
cp /dev/null ark21isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    echo "Now execute sdecode.sh to build files."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
