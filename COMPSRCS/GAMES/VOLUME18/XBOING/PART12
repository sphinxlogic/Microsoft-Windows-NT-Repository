Path: uunet!news.tek.com!news.cna.tek.com!not-for-mail
From: billr@saab.cna.tek.com (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i071:  xboing - blockout variant with color and sound for X, Part12/30
Date: 30 Aug 1993 10:27:59 -0700
Organization: Tektronix, Inc., Redmond, OR
Lines: 2239
Approved: billr@saab.CNA.TEK.COM
Message-ID: <25tdav$hvg@saab.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1871

Submitted-by: jck@kimba.catt.citri.edu.au (Justin Kibell)
Posting-number: Volume 18, Issue 71
Archive-name: xboing/part12
Environment: X11, Xlib, XPM



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 30)."
# Contents:  bitmaps/titleI.xpm.uu init.c main.c
# Wrapped by billr@saab on Mon Aug 30 09:14:25 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'bitmaps/titleI.xpm.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/titleI.xpm.uu'\"
else
echo shar: Extracting \"'bitmaps/titleI.xpm.uu'\" \(4959 characters\)
sed "s/^X//" >'bitmaps/titleI.xpm.uu' <<'END_OF_FILE'
Xbegin 644 titleI.xpm
XM+RH@6%!-("HO"G-T871I8R!C:&%R("H@=&ET;&5)7WAP;5M=(#T@>PHO*B!W
XM:61T:"!H96EG:'0@;F-O;&]R<R!C:&%R<U]P97)?<&EX96P@*B\*(C0Q(#<T
XM(#@@,2(L"B\J(&-O;&]R<R`J+PHB(`ES($YO;F4)8R!.;VYE(BP*(BX)8R`C
XM.#`R1C`P(BP*(E@)8R`C03`V,#`P(BP*(F\)8R`C.3`S1C$P(BP*(D\)8R`C
XM1C!$,#0P(BP*(BL)8R`C1#`Y13(P(BP*(D`)8R`C1C!#,#,P(BP*(B,)8R`C
XM0S`W1C$P(BP*+RH@<&EX96QS("HO"B(@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("(L"B(@("`@("`@("`@("`@("`@("`@("`@
XM("`@("`@("`@("`@("`@("`@("(L"B(N6&]O;V]O;V]O;V]O;V]O;V]O;V]O
XM;V]O;V]O;V]O;V]O;V]O;V]O("(L"B)83T\K*RLK*RLK*RLK*RLK*RLK*RLK
XM*RLK*RLK*RLK*RLK*RLK*RLK6"(L"B)83T]`*RLK*RLK*RLK*RLK*RLK*RLK
XM*RLK*RLK*RLK*RLK*RLK*RLC("(L"B)83T]/0"LK*RLK*RLK*RLK*RLK*RLK
XM*RLK*RLK*RLK*RLK*RLK*R-8+B(L"B)83T]/3RLK*RLK*RLK*RLK*RLK*RLK
XM*RLK*RLK*RLK*RLK*RLK(UA8("(L"B)83T]/3T]`*RLK*RLK*RLK*RLK*RLK
XM*RLK*RLK*RLK*RLK*RLC6%A8+B(L"B)83T]/3T\K6%A86%A86%A86%@K*T!`
XM*R-86%A86%A86%A8(R-86%A8("(L"B)83T]/3T\C+BXN+BXN+BXN+BXC3T]/
XM*UAO+F\N+BXN+BXN;UA86%A86"(L"B)83T]/*R-O;RXN+BYO(R,C(R,K3T]/
XM(V]8;V\N;RXN+BXN+BY86%A8("(L"B)83T]/(RXN+BXN+BXC3T]/3T]/0$]/
XM(V]O6%A8+F\N+BXN;RXN6%A8+B(L"B)83RLC;V\N+F\C(R,K3T]/3T]`0$]/
XM(V]O6"Y8+BXN+BYO+BYO+EA8+B(L"B)83R,N;RXN+B-/3T]/3T]`0$!`0$]/
XM(V]O;V]O6%A86%@N+BXN+BY8("(L"B(@(R`@("`@+B`C*T]/3T!`0$!`0$]/
XM(V]O;V]O;UA86&\@("X@+B`N("(L"B(@("`@("`@("`@;T]`0$!`0$!`0$]/
XM(V]O;V]O;V]O6"X@("`@("`@("(L"B(@("`@("`@("`@6$]`0$!/0$!`0$]/
XM(V]O;V]O;V]O6"X@("`@("`@("(L"B(@("`@("`@("`@6$!`0$!`0$!/*T]/
XM(V]O;V]86&]O;R`@("`@("`@("(L"B(@("`@("`@("`@6$!/3T!`0$!/0$]/
XM(V]O;V]8;V]O6"X@("`@("`@("(L"B(@("`@("`@("`@6$!`3T]`0"M/3T]/
XM(V]O;V]86&]86"X@("`@("`@("(L"B(@("`@("`@("`@6$]`3T!/*T]`0$]/
XM*V]O;V]8;UAO6"X@("`@("`@("(L"B(@("`@("`@("`@6$]/0$!`0$!`0$!/
XM*UAO;V]O6%A86"X@("`@("`@("(L"B(@("`@("`@("`@6$]`3T]/0$!/0$]/
XM*UA8;V]O;UA86"X@("`@("`@("(L"B(@("`@("`@("`@6$!`3T]/3T]/3T]/
XM*UA86%AO6%A86"X@("`@("`@("(L"B(@("`@("`@("`@6$]/3T]/3T]/3T]/
XM*UA86%AO6%A86"X@("`@("`@("(L"B(@("`@("`@("`@6$]/3T]/3T]/3T]/
XM*UA86%A86%A86"X@("`@("`@("(L"B(@("`@("`@("`@6$]/3T]/3T]/3T]/
XM*UA86%A86%A86"X@("`@("`@("(L"B(@("`@("`@("`@6$]/3T]/3T]/3T]/
XM*UA86%A86%A86"X@("`@("`@("(L"B(@("`@("`@("`@6$]`*T!/3T]`*T!/
XM*UA8(UA86"-86"X@("`@("`@("(L"B(@("`@("`@("`@6$\K(RM/3T\K(RM/
XM*UA8(UA8(R-86"X@("`@("`@("(L"B(@("`@("`@("`@6$]`*T]/0"LK*T]/
XM*U@C(R-86%@C6"X@("`@("`@("(L"B(@("`@("`@("`@6$]/3T]/*R,K3T]/
XM*UA8(UA86%A8(RX@("`@("`@("(L"B(@("`@("`@("`@;RLK*RLK*RM/3T]/
XM*U@C6"-8(U@C(RX@("`@("`@("(L"B(@("`@("`@("`@;R,C(R,C*T]/3T]/
XM*R,C6%@C(R,C(RX@("`@("`@("(L"B(@("`@("`@("`@;R,C(R,C*RM/3T]/
XM*R,C6"-8(U@C(RX@("`@("`@("(L"B(@("`@("`@("`@+B,C(R,C(R,K3T]/
XM*R,C(UA86%A8(RX@("`@("`@("(L"B(@("`@("`@("`@;RLK(R,C(R,K*T!/
XM*R,C(R-8(U@C(RX@("`@("`@("(L"B(@("`@("`@("`@6$\K(R,C(R,C(RM/
XM*R,C(R,C(R,C(RX@("`@("`@("(L"B(@("`@("`@("`@;T`K(R,C(R,C(RM/
XM*R,C(R,C*RLK(RX@("`@("`@("(L"B(@("`@("`@("`@+B,C(R,C(R,C(RM/
XM0",C(R,C*T\K(RX@("`@("`@("(L"B(@("`@("`@("`@+B,C6",C6%@C(RM/
XM*R,C(R,C*RLK*U@@("`@("`@("(L"B(@("`@("`@("`@+B-86%@C(UA8(RM/
XM*R,C(R,C(R,K3U@@("`@("`@("(L"B(@("`@("`@("`@+BLC6",C6%A8(RM/
XM3RLK(R,K*R,K3U@@("`@("`@("(L"B(@("`@("`@("`@+B,C(R,C6%A86"M/
XM3T\K(RM/*R,K3U@@("`@("`@("(L"B(@("`@("`@("`@+B,C6%@C6%A8(RM/
XM3T]`*T]/0"M/3U@@("`@("`@("(L"B(@("`@("`@("`@+B-86%A86%@C(RM/
XM3T]/3T]/3T]/3U@@("`@("`@("(L"B(@("`@("`@("`@+B-86%A86%A8(RM/
XM3T]/3T`K0$]/3U@@("`@("`@("(L"B(@("`@("`@("`@+EA86%A86%A86"M/
XM3T]/3RLC*T]/3U@@("`@("`@("(L"B(@("`@("`@("`@+EA86%A86%A86"M/
XM3T]/3T`K3T]/3U@@("`@("`@("(L"B(@("`@("`@("`@+EA86%A86%A86"M/
XM3T]/3T]/3T]/3U@@("`@("`@("(L"B(@("`@("`@("`@(&]8+EA86%A86"M/
XM3T]/3T]/3T!`3U@@("`@("`@("(L"B(@("`@("`@("`@+F]O;RY86%A86"M/
XM3T]/3T]/0$!`0%@@("`@("`@("(L"B(@("`@("`@("`@+F]8+EA86%A8;RM/
XM3T]/0$]/3T!`3U@@("`@("`@("(L"B(@("`@("`@("`@+EA86%A86%AO;R-/
XM3T]/0$]/0$!`3U@@("`@("`@("(L"B(@("`@("`@("`@+F]8+EAO6%AO6"-/
XM3T]`0$!/0$]`3U@@("`@("`@("(L"B(@("`@("`@("`@(&]O;V]O;V]O6"M/
XM3T]/0$!`3T]`0%@@("`@("`@("(L"B(@("`@("`@("`@+F]O;V]O;V]O6"-/
XM3T!/0$!`0$]`0%@@("`@("`@("(L"B(@("`@("`@("`@(&]O;V]O;V]O;R-/
XM3T!`3T]`0$!`0%@@("`@("`@("(L"B(@("`@("`@("`@+F]O;V]O;V]O;R-/
XM3T!`3T!`0$!`3U@@("`@("`@("(L"B(@("`@("`@("`@+F]O;V]O;V]O;R-/
XM0$!`0$!`0$!`3U@@("`@("`@("(L"B(N6&]O;V]O;V]O6",C(UAO;V]O;R-/
XM3T!`0$!`0$]`3RMO;V]O;V]O("(L"B)83T\K*RLK*RLK3T]/3R-O;V]O;R-/
XM3T!`0$!`3T]/3RLK*RLK*RLK6"(L"B)83T]`*RLK*RLK*T`K3RLC(R-8;R-/
XM0$!`3T!/0$`K0"LK*RLK*RLC("(L"B)83T]/0"LK*RLK*RLK*RM/3T\C;R-/
XM3T!/3T]`0"LK*RLK*RLK*R-8+B(L"B)83T]/3RLK*RLK*RLK*RM/*T\K(T!/
XM0"M`0"M`*RLK*RLK*RLC(R-8("(L"B)83T]/3T]`*RLK*RLK*RLK*RM`3T]/
XM0"LK*RLK*RLK*RLK*RLC6%A8+B(L"B)83T]/3T\K6%A86%A86%A86%@C(R,C
XM6%A86"-86%A86%A86",C6%A8("(L"B)83T]/3T\C+BXN+BXN+BXN+BXN+BXN
XM+BYO+BXN+BXN+BXN;UA86%A8+B(L"B)83T]/*R-O;RXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN;V\N6%A8+B(L"B)83T]/(RXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BYO6%A8("(L"B)83RLC;V\N+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BYO;V]8+B(L"B)83R,N;RXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+F]8+B(L"B(@(R`@("`@("X@("X@+B`N("X@+B`N
XM("X@+B`N("X@+B`N("X@+B`N("(L"B(@("`@("`@("`@("`@("`@("`@("`@
X7("`@("`@("`@("`@("`@("`@(")].PH@
X`
Xend
END_OF_FILE
if test 4959 -ne `wc -c <'bitmaps/titleI.xpm.uu'`; then
    echo shar: \"'bitmaps/titleI.xpm.uu'\" unpacked with wrong size!
fi
# end of 'bitmaps/titleI.xpm.uu'
fi
if test -f 'init.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'init.c'\"
else
echo shar: Extracting \"'init.c'\" \(25223 characters\)
sed "s/^X//" >'init.c' <<'END_OF_FILE'
X#include "include/copyright.h"
X
X/*
X *  Include file dependencies:
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <stddef.h>
X#include <sys/time.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X
X#include "include/score.h"
X#include "include/presents.h"
X#include "include/special.h"
X#include "include/main.h"
X#include "include/version.h"
X#include "include/error.h"
X#include "include/mess.h"
X#include "include/ball.h"
X#include "include/gun.h"
X#include "include/sfx.h"
X#include "include/blocks.h"
X#include "include/level.h"
X#include "include/bonus.h"
X#include "include/stage.h"
X#include "include/paddle.h"
X#include "include/intro.h"
X#include "include/inst.h"
X#include "include/highscore.h"
X#include "include/keys.h"
X#include "include/audio.h"
X#include "include/misc.h"
X
X#include "include/init.h"
X
X/*
X *  Internal macro definitions:
X */
X
X#define TITLE_FONT 	"-adobe-helvetica-bold-r-*-*-24-*-*-*-*-*-*-*"
X#define COPY_FONT   "-adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-*-*"
X#define TEXT_FONT  	"-adobe-helvetica-medium-r-*-*-18-*-*-*-*-*-*-*"
X
X/*
X *  Internal type declarations:
X */
X
X#if NeedFunctionPrototypes
Xstatic void ParseCommandLine(char **argv, int argc);
Xstatic void InitialiseSettings(void);
Xstatic int compareArgument(char *arg1, char *arg2, int minMatch);
Xstatic void HandleDisplayErrors(char *displayName);
Xstatic void PrintVersion(void);
Xstatic void PrintUsage(void);
Xstatic void PrintHelp(void);
Xstatic void InitialiseGraphics(Display *display, Window window);
Xstatic void InitialiseColourNames(Display *display, Colormap colormap);
Xstatic void InitialiseFonts(Display *display);
Xstatic void ReleaseGraphics(Display *display);
Xstatic void ReleaseFonts(Display *display);
Xstatic void ExitProgramNow(int value);
Xstatic void TurnOnSynchronise(Display *display);
X#else
Xstatic void ExitProgramNow();
Xstatic void ParseCommandLine();
Xstatic void InitialiseSettings();
Xstatic int compareArgument();
Xstatic void HandleDisplayErrors();
Xstatic void PrintVersion();
Xstatic void PrintUsage();
Xstatic void PrintHelp();
Xstatic void InitialiseGraphics();
Xstatic void InitialiseColourNames();
Xstatic void InitialiseFonts();
Xstatic void ReleaseGraphics();
Xstatic void ReleaseFonts();
Xstatic void TurnOnSynchronise();
X#endif
X
X/*
X *  Internal variable declarations:
X */
X
Xint red, tann, yellow, green, white, black, blue, purple, reds[14], greens[14];
XGC gc, gcxor, gcand, gcor, gcsfx;
XXFontStruct *titleFont, *copyFont, *textFont;
XColormap 	colormap;
Xstatic XVisualInfo	visual_info;
Xstatic unsigned long event_mask;
Xstatic char *displayName = (char *) NULL;
Xstatic int	syncOn;
Xstatic int	grabPointer;
Xstatic int	useDefaultColourmap;
Xint	noSound, debug;
X
X#if NeedFunctionPrototypes
Xstatic void InitialiseGraphics(Display *display, Window window)
X#else
Xstatic void InitialiseGraphics(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X    XGCValues	gcv;
X
X	/* Create a graphics context using copy mode */
X	gcv.function   			= GXcopy;
X	gcv.fill_style			= FillTiled;
X	gcv.graphics_exposures	= False;
X	if (!(gc = XCreateGC(display, window, 
X		GCFunction | GCFillStyle | GCGraphicsExposures, &gcv)))
X		ShutDown(display, 1, "Cannot create GXcopy graphics context.");
X
X	/* Create a graphics context using xor mode */
X	gcv.function   			= GXxor;
X	gcv.graphics_exposures	= False;
X	if (!(gcxor = XCreateGC(display, window, 
X		GCFunction | GCGraphicsExposures, &gcv)))
X		ShutDown(display, 1, "Cannot create GXxor graphics context.");
X
X	/* Create a graphics context using and mode */
X	gcv.function   			= GXand;
X	gcv.graphics_exposures	= False;
X	if (!(gcand = XCreateGC(display, window, 
X		GCFunction | GCGraphicsExposures, &gcv)))
X		ShutDown(display, 1, "Cannot create GXand graphics context.");
X    XSetForeground(display, gcand, 0);
X	XSetBackground(display, gcand, ~0);
X
X	/* Create a graphics context using or mode */
X	gcv.function   			= GXor;
X	gcv.graphics_exposures	= False;
X	if (!(gcor = XCreateGC(display, window, 
X		GCFunction | GCGraphicsExposures, &gcv)))
X		ShutDown(display, 1, "Cannot create GXor graphics context.");
X
X	/* Create a graphics context for use by sfx */
X	gcv.function   			= GXcopy;
X	gcv.graphics_exposures	= False;
X	if (!(gcsfx = XCreateGC(display, window, 
X		GCFunction | GCGraphicsExposures, &gcv)))
X		ShutDown(display, 1, "Cannot create GXsfx graphics context.");
X}
X
X#if NeedFunctionPrototypes
Xstatic void InitialiseColourNames(Display *display, Colormap colormap)
X#else
Xstatic void InitialiseColourNames(display, colormap)
X	Display *display;
X	Colormap colormap;
X#endif
X{
X    /* Obtain the colour index of several colours from colourmap */
X	red     = ColourNameToPixel(display, colormap, "red");
X	tann    = ColourNameToPixel(display, colormap, "tan");
X	yellow  = ColourNameToPixel(display, colormap, "yellow");
X	green   = ColourNameToPixel(display, colormap, "green");
X	white   = ColourNameToPixel(display, colormap, "white");
X	black   = ColourNameToPixel(display, colormap, "black");
X	purple  = ColourNameToPixel(display, colormap, "purple");
X	blue    = ColourNameToPixel(display, colormap, "blue");
X}
X
X#if NeedFunctionPrototypes
Xstatic void InitialiseCycleColourNames(Display *display, Colormap colormap)
X#else
Xstatic void InitialiseCycleColourNames(display, colormap)
X	Display *display;
X	Colormap colormap;
X#endif
X{
X	reds[0] = ColourNameToPixel(display, colormap, "#f00");
X	reds[1] = ColourNameToPixel(display, colormap, "#e00");
X	reds[2] = ColourNameToPixel(display, colormap, "#d00");
X	reds[3] = ColourNameToPixel(display, colormap, "#c00");
X	reds[4] = ColourNameToPixel(display, colormap, "#b00");
X	reds[5] = ColourNameToPixel(display, colormap, "#a00");
X	reds[6] = ColourNameToPixel(display, colormap, "#900");
X	reds[7] = ColourNameToPixel(display, colormap, "#800");
X	reds[8] = ColourNameToPixel(display, colormap, "#700");
X	reds[9] = ColourNameToPixel(display, colormap, "#600");
X	reds[10] = ColourNameToPixel(display, colormap, "#500");
X	reds[11] = ColourNameToPixel(display, colormap, "#400");
X	reds[12] = ColourNameToPixel(display, colormap, "#300");
X	reds[13] = ColourNameToPixel(display, colormap, "#200");
X
X	greens[0] = ColourNameToPixel(display, colormap, "#0f0");
X	greens[1] = ColourNameToPixel(display, colormap, "#0e0");
X	greens[2] = ColourNameToPixel(display, colormap, "#0d0");
X	greens[3] = ColourNameToPixel(display, colormap, "#0c0");
X	greens[4] = ColourNameToPixel(display, colormap, "#0b0");
X	greens[5] = ColourNameToPixel(display, colormap, "#0a0");
X	greens[6] = ColourNameToPixel(display, colormap, "#090");
X	greens[7] = ColourNameToPixel(display, colormap, "#080");
X	greens[8] = ColourNameToPixel(display, colormap, "#070");
X	greens[9] = ColourNameToPixel(display, colormap, "#060");
X	greens[10] = ColourNameToPixel(display, colormap, "#050");
X	greens[11] = ColourNameToPixel(display, colormap, "#040");
X	greens[12] = ColourNameToPixel(display, colormap, "#030");
X	greens[13] = ColourNameToPixel(display, colormap, "#020");
X}
X
X#if NeedFunctionPrototypes
Xstatic void InitialiseFonts(Display *display)
X#else
Xstatic void InitialiseFonts(display)
X	Display *display;
X#endif
X{
X	/* Create all required font structures */
X
X	/* Font used for titles */
X    if (!(titleFont = XLoadQueryFont(display, TITLE_FONT)))
X	{
X		WarningMessage("Cannot open the title font. Using fixed.");
X		titleFont = XLoadQueryFont(display, "fixed");
X	}
X
X	/* Very small font used for copyright message etc. */
X	if (!(copyFont = XLoadQueryFont(display, COPY_FONT)))
X	{
X		WarningMessage("Cannot open the copyright font. Using fixed.");
X		copyFont = XLoadQueryFont(display, "fixed");
X	}
X
X	/* Font used for general text everywhere */
X	if (!(textFont = XLoadQueryFont(display, TEXT_FONT)))
X	{
X		WarningMessage("Cannot open the text font. Using fixed.");
X		textFont = XLoadQueryFont(display, "fixed");
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void ReleaseFonts(Display *display)
X#else
Xstatic void ReleaseFonts(display)
X	Display *display;
X#endif
X{
X	/* Free all the fonts used */
X	if (titleFont)	XFreeFont(display, titleFont);
X	if (copyFont)	XFreeFont(display, copyFont);
X	if (textFont)	XFreeFont(display, textFont);
X}
X
X#if NeedFunctionPrototypes
Xstatic void ExitProgramNow(int value)
X#else
Xstatic void ExitProgramNow(value)
X	int value;
X#endif
X{
X	/* Return to the shell with error code */
X	exit(value);
X}
X
X#if NeedFunctionPrototypes
Xstatic void ReleaseGraphics(Display *display)
X#else
Xstatic void ReleaseGraphics(display)
X	Display *display;
X#endif
X{
X	/* Free the graphics contexts */
X	if (gc) 	XFreeGC(display, gc);
X	if (gcxor) 	XFreeGC(display, gcxor);
X	if (gcand) 	XFreeGC(display, gcand);
X	if (gcor) 	XFreeGC(display, gcor);
X	if (gcsfx) 	XFreeGC(display, gcsfx);
X}
X
X#if NeedFunctionPrototypes
Xvoid ShutDown(Display *display, int exit_code, char *message)
X#else
Xvoid ShutDown(display, exit_code, message)
X	Display *display;
X	int exit_code;
X	char *message;
X#endif
X{
X	/* This is the last function called when exiting */
X
X	/* Remove the colour map */
X	if (colormap) XUninstallColormap(display, colormap);
X
X	/* Close the audio device if available and wanted */
X	if (noSound == False)
X		FreeAudioSystem();
X
X	FreeMisc(display);				/* Free backing store pixmap*/
X	FreeKeyControl(display);		/* Free key control         */
X	FreeHighScore(display);			/* Free high score memory 	*/
X	FreeInstructions(display);		/* Free instructions        */
X	FreeBonus(display);				/* Free bonus memory 		*/
X	FreeIntroduction(display);		/* Free introduction memory */
X	FreeMessageSystem(display);		/* Free message system 		*/
X	FreePaddle(display);			/* Free paddle pixmaps 		*/
X	FreeLevelInfo(display);			/* Free level pixmaps 		*/
X	FreeScoreDigits(display);		/* Free digit pixmaps 		*/
X	FreeBlockPixmaps(display);		/* Free all block pixmaps 	*/
X	FreeBall(display);				/* Free the ball animation 	*/
X	FreeBullet(display);			/* Free the bullet          */
X	ReleaseGraphics(display);		/* Free graphics contexts 	*/
X	ReleaseFonts(display);			/* Unload fonts used		*/
X
X	/* Output an error message if required */
X	if (message[0] != '\0')
X	{
X		/* If we had an error then use error message */
X		if (exit_code == 1)
X			ErrorMessage(message);
X		else
X			NormalMessage(message);
X	}
X
X	/* Exit with the error code */
X	ExitProgramNow(exit_code);
X}
X
X#if NeedFunctionPrototypes
Xstatic int ErrorHandler(Display *display, XErrorEvent *err)
X#else
Xstatic int ErrorHandler(display, err)
X	Display *display;
X	XErrorEvent *err;
X#endif
X{
X 	char msg[80];
X 	char string[256];
X
X	/* Obtain the error message from the server */
X	XGetErrorText(display, err->error_code, msg, 80);
X	sprintf(string, "Xlib Error: %s", msg);
X
X	/* Close down the system */
X	ShutDown(display, 1, string);
X
X	/* Not reached but makes the compiler happy */
X	return True;
X}
X
X#if NeedFunctionPrototypes
Xstatic void HandleDisplayErrors(char *displayName)
X#else
Xstatic void HandleDisplayErrors(displayName)
X	char *displayName;
X#endif
X{
X 	char string[256];
X
X	/* Check if the DISPLAY variable is set and write correct message */
X	if (getenv("DISPLAY") == NULL)
X		WarningMessage("Your X-Window system display variable is not set.");
X	else
X	{
X		sprintf(string, "Cannot connect to display called <%s>.", displayName);
X		WarningMessage(string);
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void PrintVersion(void)
X#else
Xstatic void PrintVersion()
X#endif
X{
X    /* Print version for program to user for command line help */
X    fprintf(stdout, 
X		"XBoing by Justin Kibell (jck@citri.edu.au)\n"); 
X    fprintf(stdout, 
X	  "Version %d.%d %s\n", VERSION, REVNUM + buildNum, dateString);
X    fprintf(stdout, "(c) Copyright 1993, All Rights Reserved\n");
X
X	/* Exit now */
X	ExitProgramNow(0);
X}
X
X#if NeedFunctionPrototypes
Xstatic void PrintUsage(void)
X#else
Xstatic void PrintUsage()
X#endif
X{
X    /* Print usage to user for command line help */
X
X    fprintf(stdout, "%s%s",
X		"Usage: XBoing [-version] [-usage] [-help] [-sync] ",
X		"[-display <displayName>]\n"); 
X    fprintf(stdout, "%s%s\n%s%s\n",
X		"              [-speed <1-9>] [-scores] [-keys] [-sound] [-setup]",
X		" [-nosfx]",
X		"              [-nograb] [-maxvol <1-100>] [-startlevel <1-MAX>]",
X		" [-usedefcmap]");
X
X	/* Exit now */
X	ExitProgramNow(0);
X}
X
X#if NeedFunctionPrototypes
Xstatic void PrintSetup(void)
X#else
Xstatic void PrintSetup()
X#endif
X{
X    /* Print setup information about xboing */
X	char *str;
X
X    fprintf(stdout, "xboing: Setup Information\n");
X    fprintf(stdout, "           Audio: %s\n", 
X		AUDIO_AVAILABLE ? "Available" : "Not available");
X    fprintf(stdout, "         Version: %d.%d\n", VERSION, REVNUM + buildNum);
X    fprintf(stdout, "        Compiled: %s\n", dateString);
X
X	/* If the environment variable exists - use it */
X	if ((str = getenv("XBOING_SCORE_FILE")) != NULL)
X    	fprintf(stdout, "      Score File: %s\n", str);
X	else
X    	fprintf(stdout, "      Score File: %s\n", HIGH_SCORE_FILE);
X
X	/* If the environment variable exists - use it */
X	if ((str = getenv("XBOING_LEVELS_DIR")) != NULL)
X    	fprintf(stdout, " Level directory: %s\n", str);
X	else
X    	fprintf(stdout, " Level directory: %s\n", LEVEL_INSTALL_DIR);
X
X    fprintf(stdout, "Number of levels: %d\n", MAX_NUM_LEVELS);
X
X	/* If the environment variable exists - use it */
X	if ((str = getenv("XBOING_SOUND_DIR")) != NULL)
X    	fprintf(stdout, "Sounds directory: %s\n", str);
X	else
X    	fprintf(stdout, "Sounds directory: %s\n", SOUNDS_DIR);
X
X	/* Exit now */
X	ExitProgramNow(0);
X}
X
X
X#if NeedFunctionPrototypes
Xstatic void PrintHelp(void)
X#else
Xstatic void PrintHelp()
X#endif
X{
X    /* Print help for program to user for command line help */
X    fprintf(stdout, 
X		"XBoing by Justin Kibell (jck@citri.edu.au)\n"); 
X    fprintf(stdout, "Version %d.%d %s\n", VERSION, REVNUM + buildNum,
X    	"(c) Copyright 1993, All Rights Reserved\n");
X
X    fprintf(stdout, "Help: \n");
X    fprintf(stdout, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
X        "    -speed <n>              - The game speed, 1 - 9. 9 = fast\n",
X        "    -maxvol <n>             - The maximum volume as percentage.\n",
X        "    -startlevel <n>         - The starting level for game.\n",
X        "    -help                   - Produce this help message.\n",
X        "    -sync                   - Turn on X synchronisation.\n",
X        "    -usage                  - Print a brief help message.\n",
X        "    -version                - Print out the current version.\n",
X        "    -scores                 - Print out the current highscores.\n",
X        "    -keys                   - Use keys instead of mouse control.\n",
X        "    -sound                  - Turn audio ON for game.\n",
X        "    -setup                  - Print setup information.\n",
X        "    -nosfx                  - Do not use special effects.\n",
X        "    -nograb                 - Turn off pointer grab.\n",
X        "    -usedefcmap             - Use the default colourmap.\n",
X        "    -display <display>      - Set the display for the game.\n");
X
X	/* Exit now */
X	ExitProgramNow(0);
X}
X
X#if NeedFunctionPrototypes
Xstatic int compareArgument(char *arg1, char *arg2, int minMatch)
X#else
Xstatic int compareArgument(arg1, arg2, minMatch)
X	char *arg1;
X	char *arg2;
X	int minMatch;
X#endif
X{
X    if ((strlen(arg1) < minMatch) || (strlen(arg2) < minMatch)) 
X        return 1;
X    if (strlen(arg1) > strlen(arg2)) 
X        return 1;
X
X	/* Return true or false basically */
X    return (strncmp(arg1, arg2, strlen(arg1)));
X}
X
X#if NeedFunctionPrototypes
Xstatic void TurnOnSynchronise(Display *display)
X#else
Xstatic void TurnOnSynchronise(display)
X	Display *display;
X#endif
X{
X	/* Turn the X synchronisation on to flush all calls each frame */
X	XSynchronize(display, True);
X}
X
X#if NeedFunctionPrototypes
Xstatic void InitialiseSettings(void)
X#else
Xstatic void InitialiseSettings()
X#endif
X{
X	/* Initialise some variables */
X	syncOn = False;
X	debug = False;
X	grabPointer = True;
X	useDefaultColourmap = False;
X
X	/* The audio is off by default */
X	noSound = True;
X
X	/* So the audio code will use system default */
X	SetMaximumVolume(0);	
X
X	/* Always start on level one */
X	SetStartingLevel(1);
X	SetLevelNumber(1);
X
X	/* Not so fast */
X	SetUserSpeed(7);
X
X	useSpecialEffects(True);
X	score = 0L;
X}
X
X#if NeedFunctionPrototypes
Xstatic void ParseCommandLine(char **argv, int argc)
X#else
Xstatic void ParseCommandLine(argv, argc)
X	char **argv;
X	int argc;
X#endif
X{
X	/* Parse the command line options */
X	int i, l;
X	char str[80];
X
X	/* Initialise variables */
X	InitialiseSettings();
X
X	for (i = 1; i < argc; i++)
X	{
X		if (argv[i][0] != '-')
X		{
X			PrintUsage();
X			break;
X		}
X
X		if (!compareArgument(argv[i], "-display", 7))
X		{
X			/* Set the display name for later connection */
X			i++;
X			if (i < argc)
X				displayName = argv[i];
X			else PrintUsage();
X
X		} else if (!compareArgument(argv[i], "-help", 4))
X		{
X			/* Print out the help information and quit */
X			PrintHelp();
X
X		} else if (!compareArgument(argv[i], "-debug", 5))
X		{
X			/* Turn on debugging */
X			NormalMessage("Debugging mode activated.");
X			debug = True;
X
X		} else if (!compareArgument(argv[i], "-setup", 5))
X		{
X			/* Print out information on setup */
X			PrintSetup();
X
X		} else if (!compareArgument(argv[i], "-sync", 4))
X		{
X			/* Turn on X protocol synchronisation */
X			syncOn = True;
X
X		} else if (!compareArgument(argv[i], "-version", 7))
X		{
X			/* Print out the version information and quit */
X			PrintVersion();
X
X		} else if (!compareArgument(argv[i], "-sound", 5))
X		{
X			/* Enable the sound in the game */
X			noSound = False;
X
X		} else if (!compareArgument(argv[i], "-keys", 4))
X		{
X			/* Set the paddle control mode to use keys */
X			SetPaddleControlMode(CONTROL_KEYS);
X
X		} else if (!compareArgument(argv[i], "-scores", 6))
X		{
X			/* List all the highscores */
X			CommandlineHighscorePrint();
X			ExitProgramNow(0);
X
X		} else if (!compareArgument(argv[i], "-usage", 5))
X		{
X			/* Print out the usage and quit */
X			PrintUsage();
X
X		} else if (!compareArgument(argv[i], "-nosfx", 5))
X		{
X			/* Turn off special effects then */
X			useSpecialEffects(False);
X			
X		} else if (!compareArgument(argv[i], "-nograb", 6))
X		{
X			/* Turn off pointer grabbing */
X			grabPointer = False;
X
X		} else if (!compareArgument(argv[i], "-usedefcmap", 10))
X		{
X			/* Try to use the default colourmap */
X			useDefaultColourmap = True;
X
X		} else if (!compareArgument(argv[i], "-speed", 5))
X		{
X			/* Set the speed for the game */
X			i++;
X			if (i < argc)
X			{
X				/* Obtain the speed setting */
X				l = atoi(argv[i]);
X				if ((l > 0) && (l <= 9))
X					SetUserSpeed(10 - l);
X				else 
X				{
X					WarningMessage("The speed setting range is [1-9]");
X					PrintUsage();
X				}
X			} else PrintUsage();
X
X		} else if (!compareArgument(argv[i], "-startlevel", 10))
X		{
X			/* Set the starting level */
X			i++;
X			if (i < argc)
X			{
X				/* Obtain the start level setting */
X				l = atoi(argv[i]);
X				if ((l > 0) && (l <= MAX_NUM_LEVELS))
X					SetStartingLevel(l);
X				else 
X				{
X					sprintf(str, "The starting level range is [1-%d]", 
X						MAX_NUM_LEVELS);
X					WarningMessage(str);
X					PrintUsage();
X				}
X			} else PrintUsage();
X
X		} else if (!compareArgument(argv[i], "-maxvol", 6))
X		{
X			/* Set the maximum volume to use for the game */
X			i++;
X			if (i < argc)
X			{
X				/* Obtain the maximum volume setting */
X				l = atoi(argv[i]);
X				if ((l >= 1) && (l <= 100))
X					SetMaximumVolume(l);
X				else 
X				{
X					WarningMessage("Maximum volume range is [1-100]");
X					PrintUsage();
X				}
X			} else PrintUsage();
X
X		} else PrintUsage();
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid UnGrabPointer(Display *display)
X#else
Xvoid UnGrabPointer(display)
X	Display *display;
X#endif
X{
X	/* Ungrab the pointer */
X	if (grabPointer == True)
X		XUngrabPointer(display, CurrentTime);
X}
X
X#if NeedFunctionPrototypes
Xvoid GrabPointer(Display *display, Window window)
X#else
Xvoid GrabPointer(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	Cursor cursor;
X	XColor colour;
X	Pixmap cursorPixmap;
X
X	/* Create a cursor with nothing inside it */
X	colour.pixel = WhitePixel(display, DefaultScreen(display));
X	XQueryColor(display, 
X		DefaultColormap(display, DefaultScreen(display)), &colour);
X	cursorPixmap = XCreatePixmap(display, window, 1, 1, 1);
X
X	cursor = XCreatePixmapCursor(display, 
X		cursorPixmap, cursorPixmap, &colour, &colour, 0, 0);
X	if (cursorPixmap) XFreePixmap(display, cursorPixmap);
X
X	if (grabPointer == True)
X	{
X		/* Grab the pointer so you cannot move the  mouse out of the main
X	 	 * window. Also set the cursor to a new cursor with no shape.
X	 	 */
X    	if (XGrabPointer(display, window, True,
X			ButtonReleaseMask | ButtonPressMask,
X			GrabModeAsync, GrabModeAsync, window,
X			cursor, CurrentTime) != GrabSuccess)
X		{
X			/* Error while grab - not too bad but let user know. */	
X			WarningMessage("Pointer grab unsuccessful.");
X		}
X	}
X	else
X		XDefineCursor(display, window, cursor);
X}
X
X#if NeedFunctionPrototypes
XDisplay *InitialiseGame(char **argv, int argc)
X#else
XDisplay *InitialiseGame(argv, argc)
X	char **argv;
X	int argc;
X#endif
X{
X	int screen_num;
X	static Display *display;
X
X	/* Setup the default speed for game */
X	SetUserSpeed(5);
X
X	/* Set the paddle control mode to mouse */
X	SetPaddleControlMode(CONTROL_MOUSE);
X
X	/* Parse all command line arguments - may exit here */
X	ParseCommandLine(argv, argc);
X
X	DEBUG("Command line parsed.")
X
X	/* Open a display connection */
X	if (!(display = XOpenDisplay(displayName)))
X	{
X		/* Handle display connection errors */
X		HandleDisplayErrors(displayName);
X		ExitProgramNow(1);
X	}
X
X	/* User wants synchronisation turned on so do it */
X	if (syncOn == True) TurnOnSynchronise(display);
X
X	/* Set the error handlers to point to mine */
X    XSetErrorHandler(ErrorHandler);
X
X	/* Seed the random number generator */
X	srand(time(NULL));
X
X	/* Obtain the screen number for this display */
X	screen_num = XDefaultScreen(display);
X
X	/* Make sure that we are using a colour visual */
X	if (!XMatchVisualInfo(display, screen_num, 
X		DefaultDepth(display, screen_num), PseudoColor, &visual_info))
X	{
X		if (!XMatchVisualInfo(display, screen_num, 
X			DefaultDepth(display, screen_num), DirectColor, &visual_info))
X		{
X			if (!XMatchVisualInfo(display, screen_num, 
X				DefaultDepth(display, screen_num), TrueColor, &visual_info))
X			{
X				ErrorMessage("Sorry, you must have a colour display. :-(");
X				ExitProgramNow(1);
X			}
X		}
X	}
X
X	DEBUG("Display system checked.")
X
X	/* Create our own colour map or use the default one */
X	if (useDefaultColourmap == True)
X		colormap = XDefaultColormap(display, screen_num);
X	else
X		colormap = XCreateColormap(display, RootWindow(display, screen_num), 
X			visual_info.visual, AllocNone);
X
X	DEBUG("Colourmap created.")
X
X	/* Be polite */
X	NormalMessage("Please wait, initialising xboing ...");
X
X	/* Initialise the audio system if possible */
X	if (noSound == False)
X	{
X		/* Try to turn audio on */
X		if (SetUpAudioSystem(display) == False)
X		{
X			/* Audio failed - let user know */
X			noSound = True;
X			WarningMessage("Audio unavailable or not supported.");
X		}
X	}
X
X	DEBUG("Sound system checked.")
X
X	/* Find out some colours */
X	InitialiseColourNames(display, colormap);
X
X	DEBUG("Initialised colour names.")
X
X	/* Create all windows */
X	CreateAllWindows(display, colormap, argv, argc);
X
X	DEBUG("Created all windows.")
X
X	InitialiseGraphics(display, playWindow);
X	InitialiseFonts(display);
X
X	DEBUG("Created GC and fonts.")
X
X	SetBackgrounds(display, colormap);
X
X	DEBUG("Created background pixmaps.")
X
X	/* Initialise all pixmaps and objects and setup special screens etc. */
X	InitialiseMessageSystem(display, 	messWindow, 	colormap);
X	DEBUG("InitialiseMessageSystem done.")
X	InitialiseBlocks(display, 			playWindow, 	colormap);
X	DEBUG("InitialiseBlocks done.")
X	InitialiseBall(display, 			playWindow, 	colormap);
X	DEBUG("InitialiseBall done.")
X	InitialiseBullet(display, 			playWindow, 	colormap);
X	DEBUG("InitialiseBullet done.")
X	InitialiseScoreDigits(display, 		scoreWindow, 	colormap);
X	DEBUG("InitialiseScoreDigits done.")
X	InitialiseLevelInfo(display, 		levelWindow, 	colormap);
X	DEBUG("InitialiseLevelInfo done.")
X	InitialisePaddle(display, 			playWindow, 	colormap);
X	DEBUG("InitialisePaddle done.")
X
X	SetUpPresents(display, 				mainWindow, 	colormap);
X	DEBUG("SetUpPresents done.")
X	SetUpKeys(display, 					playWindow, 	colormap);
X	DEBUG("SetUpKeys done.")
X	SetUpInstructions(display, 			playWindow, 	colormap);
X	DEBUG("SetUpInstructions done.")
X	SetUpIntroduction(display, 			playWindow, 	colormap);
X	DEBUG("SetUpIntroduction done.")
X	SetUpBonus(display, 				mainWindow, 	colormap);
X	DEBUG("SetUpBonus done.")
X	SetUpHighScore(display, 			playWindow, 	colormap);
X	DEBUG("SetUpHighScore done.")
X
X	/* Do this after pixmaps all the colourmap */
X	InitialiseCycleColourNames(display, colormap);
X
X	DEBUG("Colour cycle indexes created.")
X
X	DisplayLevelInfo(display, levelWindow, level);
X	SetLevelTimeBonus(display, timeWindow, 180);
X	DrawSpecials(display);
X
X	event_mask = KeyPressMask | KeyReleaseMask | ButtonPressMask |
X	   ButtonReleaseMask | ExposureMask | StructureNotifyMask;
X	XSelectInput(display, mainWindow, event_mask);
X
X	event_mask = KeyPressMask | KeyReleaseMask | ButtonPressMask |
X	   ButtonReleaseMask;
X	XSelectInput(display, playWindow, event_mask);
X
X    /* Actually map the main window */
X    XMapWindow(display, mainWindow);
X
X	/* Install our new colormap into the server list */
X	XInstallColormap(display, colormap);
X
X	DEBUG("Entering main loop.")
X
X	/* Return the new display */
X	return display;
X}
END_OF_FILE
if test 25223 -ne `wc -c <'init.c'`; then
    echo shar: \"'init.c'\" unpacked with wrong size!
fi
# end of 'init.c'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(25219 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X#include "include/copyright.h"
X
X/*
X *  Include file dependencies:
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <stddef.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#include <X11/keysym.h>
X
X#include "include/score.h"
X#include "include/presents.h"
X#include "include/special.h"
X#include "include/audio.h"
X#include "include/mess.h"
X#include "include/ball.h"
X#include "include/gun.h"
X#include "include/sfx.h"
X#include "include/init.h"
X#include "include/blocks.h"
X#include "include/misc.h"
X#include "include/level.h"
X#include "include/bonus.h"
X#include "include/stage.h"
X#include "include/paddle.h"
X#include "include/intro.h"
X#include "include/inst.h"
X#include "include/highscore.h"
X#include "include/keys.h"
X
X#include "include/main.h"
X
X/*
X *  Internal macro definitions:
X */
X
X#define PADDLE_ANIMATE_DELAY	5
X#define BONUS_SEED				2000	
X
X/*
X *  Internal type declarations:
X */
X
X#if NeedFunctionPrototypes
Xstatic KeySym 	GetKeySym(XEvent event);
Xstatic void 	handleGameMode(Display *display);
Xstatic void 	handleEventLoop(Display *display);
Xstatic void 	ToggleGamePaused(Display *display, Window window);
Xstatic void 	SetGamePaused(Display *display);
Xstatic void 	handleGameStates(Display *display);
Xstatic void 	sleepSync(Display *display, unsigned long ms);
Xstatic void 	handleMiscKeys(Display *display, KeySym keysym);
X#else
Xstatic void 	handleMiscKeys();
Xstatic void 	sleepSync();
Xstatic void 	handleGameStates();
Xstatic KeySym 	GetKeySym();
Xstatic void 	handleGameMode();
Xstatic void 	handleEventLoop();
Xstatic void 	ToggleGamePaused();
Xstatic void 	SetGamePaused();
X#endif
X
X/*
X *  Internal variable declarations:
X */
X
Xstatic char copyright[] = "(c) Copyright 1993, Justin Kibell, All Rights Reserved. email: jck@citri.edu.au";
X
Xint paddleMotion = 0;
Xint paddleDx = 0;
Xint speedLevel = 5;
Xint frame, gameActive;
Xint mode, oldmode;
Xstatic int iconified = False;
Xlong speed;
Xstatic int userDelay = 1;
Xstatic int paddleControl;
Xstatic time_t pauseStartTime;
Xtime_t pausedTime;
X
X#if NeedFunctionPrototypes
Xvoid SetUserSpeed(int delay)
X#else
Xvoid SetUserSpeed(delay)
X	int delay;
X#endif
X{
X	int temp;
X
X	/* Set an entire game speedup or slowdown speed */
X	temp = (long) (speed / userDelay);
X	userDelay = delay;
X	speed = (long) (temp * userDelay);
X	speedLevel = 10 - delay;
X}
X
X#if NeedFunctionPrototypes
Xint GetPaddleControlMode(void)
X#else
Xint GetPaddleControlMode()
X#endif
X{
X	/* Get the paddle control mode */
X	return paddleControl;
X}
X
X#if NeedFunctionPrototypes
Xvoid SetPaddleControlMode(int type)
X#else
Xvoid SetPaddleControlMode(type)
X	int type;
X#endif
X{
X	/* Set the paddle control mode to the new mode */
X	paddleControl = type;
X}
X
X#if NeedFunctionPrototypes
Xvoid SetGameSpeed(int delay)
X#else
Xvoid SetGameSpeed(delay)
X	int delay;
X#endif
X{
X	/* This is the speed used in the sleeping routine */
X	if (delay >= 0)
X		speed = (long) (delay * userDelay);
X}
X
X#if NeedFunctionPrototypes
Xstatic void sleepSync(Display *display, unsigned long ms)
X#else
Xstatic void sleepSync(display, ms)
X	Display *display;
X	unsigned long ms;
X#endif
X{
X    struct timeval st, et;
X    long SyncTime;
X
X    gettimeofday(&st, NULL);
X    XSync(display, False);
X    gettimeofday(&et, NULL);
X
X    SyncTime = (((et.tv_sec - st.tv_sec) * 1000) +
X               ((et.tv_usec - st.tv_usec) / 1000) );
X
X    if ((ms) > ((1000 / 60) + SyncTime))
X        ms_sleep(ms - SyncTime);
X}
X
X#if NeedFunctionPrototypes
Xstatic KeySym GetKeySym(XEvent event)
X#else
Xstatic KeySym GetKeySym(event)
X	XEvent event;
X#endif
X{
X	int count;
X	char key;
X	KeySym keysym;
X	XComposeStatus compose;
X
X	/* Lookup a keysym using the event key */
X	count = XLookupString(&event.xkey, &key, 1, &keysym, &compose);
X
X	return keysym;
X}
X
X#if NeedFunctionPrototypes
Xint paddleIsMoving(void)
X#else
Xint paddleIsMoving()
X#endif
X{
X	/* Returns direction of paddle 1 right -1 left 0 stopped */
X	return paddleMotion;
X}
X
X#if NeedFunctionPrototypes
Xvoid handlePaddleMoving(Display *display)
X#else
Xvoid handlePaddleMoving(display)
X	Display *display;
X#endif
X{
X	static oldx = 0;
X	int rx, ry, x, y;
X	unsigned int mask;
X	Window root, child;
X
X	if (paddleControl == CONTROL_KEYS)
X	{
X		switch (paddleMotion)
X		{
X			case 1:		/* Move the paddle to the right 1 increment */
X				MovePaddle(display, playWindow, 
X					PADDLE_RIGHT, currentPaddleSize, 0);
X				break;
X
X			case -1:		/* Move the paddle to the left 1 increment */
X				MovePaddle(display, playWindow, 
X					PADDLE_LEFT, currentPaddleSize, 0);
X				break;
X
X			default:
X				break;
X		}
X	} else if (paddleControl == CONTROL_MOUSE)
X	{
X		/* Obtain the position of the pointer in the play window */
X		if (XQueryPointer(display, playWindow, &root, &child, 
X			&rx, &ry, &x, &y, &mask) == True)
X		{
X			/* Has the pointer moved since our last poll */
X			if (x != oldx)
X			{
X				paddleDx = x - oldx;
X
X				/* Move the paddle to the position of the mouse pointer */
X				MovePaddle(display, playWindow, 
X					PADDLE_NONE, currentPaddleSize, x);
X				oldx = x;
X
X				/* Adjust the paddle motion variable so the ball moves when in
X				 * the BALL_READY state and BALL_CREATE state.
X				 */
X				if (x > oldx)
X					paddleMotion = 1;
X				else
X					paddleMotion = -1;
X			}
X			else
X			{
X				/* Reset to no motion */
X				paddleMotion = 0;
X				paddleDx = 0;
X			}
X		}
X	}
X}
X
X
X#if NeedFunctionPrototypes
Xstatic void ToggleGamePaused(Display *display, Window window)
X#else
Xstatic void ToggleGamePaused(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	if (mode == MODE_PAUSE)
X	{
X		/* Finished pause resume game */
X		mode = MODE_GAME;
X		SetCurrentMessage(display, messWindow, "- Play ball -", False);
X		
X		/* How many seconds were we paused for? */
X		pausedTime += (time(NULL) - pauseStartTime);
X
X 		XSelectInput(display, mainWindow, 
X			KeyPressMask | KeyReleaseMask | ButtonPressMask |
X   			ButtonReleaseMask | ExposureMask | StructureNotifyMask);
X
X 		GrabPointer(display, window);
X	}
X	else 
X		SetGamePaused(display);
X}
X
X#if NeedFunctionPrototypes
Xstatic void SetGamePaused(Display *display)
X#else
Xstatic void SetGamePaused(display)
X	Display *display;
X#endif
X{
X	if (mode == MODE_GAME)
X	{
X		/* Set game to paused mode */
X		mode = MODE_PAUSE;
X		SetCurrentMessage(display, messWindow, 
X			"- Game paused -", False);
X		
X		/* we need to keep track of how long we were paused so that later
X		 * in the highscore thing I can take that off the time.
X		 */
X		pauseStartTime = time(NULL);
X
X		XSelectInput(display, mainWindow, 
X			KeyPressMask | ExposureMask | StructureNotifyMask);
X
X		UnGrabPointer(display);
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid handleIconify(Display *display, XUnmapEvent *event)
X#else
Xvoid handleIconify(display, event)
X	Display *display;
X	XUnmapEvent *event;
X#endif
X{
X	ToggleGamePaused(display, mainWindow);
X}
X
X#if NeedFunctionPrototypes
Xvoid SelectiveRedraw(Display *display)
X#else
Xvoid SelectiveRedraw(display)
X	Display *display;
X#endif
X{
X	switch (mode)
X	{
X		case MODE_GAME:
X		case MODE_PAUSE:
X			RedrawPlayWindow(display, playWindow);
X			break;
X
X		case MODE_INTRO:
X			RedrawIntroduction(display, playWindow);
X			break;
X
X		case MODE_INSTRUCT:
X			RedrawInstructions(display, playWindow);
X			break;
X
X		case MODE_KEYS:
X			RedrawKeys(display, playWindow);
X			break;
X
X		case MODE_BONUS:
X			RedrawBonus(display, mainWindow);
X			break;
X
X		case MODE_HIGHSCORE:
X			RedrawHighScore(display, playWindow);
X			break;
X
X		default:
X			break;
X	}
X
X	/* Redisplay the message and the level/score info */
X	RedrawLevelInfo(display, levelWindow);
X	DisplayCurrentMessage(display, messWindow);
X
X	/* To be sure - to be sure */
X	XFlush(display);
X}
X
X#if NeedFunctionPrototypes
Xvoid handleExposure(Display *display, XEvent event)
X#else
Xvoid handleExposure(display, event)
X	Display *display;
X	XEvent event;
X#endif
X{
X	/* Only redraw window once so wait until all expose events have sent
X	 * and then redraw all that we need to redraw based on current game
X	 * mode.
X	 */
X	if (event.xexpose.count == 0)
X		SelectiveRedraw(display);
X}
X
X#if NeedFunctionPrototypes
Xvoid handleMouseButtons(Display *display, XEvent event, int Down)
X#else
Xvoid handleMouseButtons(display, event, Down)
X	Display *display;
X	XEvent event;
X	int Down;
X#endif
X{
X	if (Down == True)
X	{
X		/* Button pressed down */
X		switch(event.xbutton.button)
X		{
X			/* Shoot a bullet */
X			case Button1:
X			case Button2: 
X			case Button3:
X				/* If we are playing the game and a ball needs to be started
X				 * then start it otherwise shoot a bullet.
X				 */
X				if (mode == MODE_GAME)
X					if (ActivateWaitingBall() == False)
X						shootBullet(display, playWindow);
X				break;
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void handleControlKeys(Display *display)
X#else
Xstatic void handleControlKeys(display)
X	Display *display;
X#endif
X{
X	/* Toggle game mode */
X	if (GetPaddleControlMode() == CONTROL_KEYS)
X	{
X		SetCurrentMessage(display, messWindow, 
X			"Control: Mouse", True);
X		SetPaddleControlMode(CONTROL_MOUSE);
X	}
X	else
X	{
X		SetCurrentMessage(display, messWindow, 
X			"Control: Keys", True);
X		SetPaddleControlMode(CONTROL_KEYS);
X	}
X
X	/* Play a bit of sound */
X	if (noSound == False)
X		playSoundFile("toggle", 50);
X}
X
X#if NeedFunctionPrototypes
Xstatic void handleSoundKey(Display *display)
X#else
Xstatic void handleSoundKey(display)
X	Display *display;
X#endif
X{
X	if (noSound == False)
X	{
X		/* Try and turn audio off */
X		FreeAudioSystem();
X
X		noSound = True;
X		SetCurrentMessage(display, messWindow, 
X			"- Audio OFF -", True);
X	}
X	else
X	{
X		/* Try and turn audio on */
X		if (SetUpAudioSystem(display) == False)
X		{
X			/* Unable to turn audio on */
X			noSound = True;
X			SetCurrentMessage(display, messWindow, 
X				"- Audio unavailable -", True);
X		}
X		else
X		{
X			/* Audio is now active */
X			noSound = False;
X			SetCurrentMessage(display, messWindow, 
X				"- Audio ON -", True);
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void handleGameKeys(Display *display, KeySym keysym)
X#else
Xstatic void handleGameKeys(display, keysym)
X	Display *display;
X	KeySym keysym;
X#endif
X{
X	int temp;
X
X	/* Switch on the keysym */
X	switch (keysym)
X	{
X		case XK_d:	
X		case XK_D:	
X			/* Obtain an active ball - ie: not on paddle */
X			if ((temp = GetAnActiveBall()) >= 0)
X			{
X				/* Erase and reset ball to new one */
X				ClearBallNow(display, playWindow, temp);
X			}
X			break;
X
X		case XK_Left:
X		case XK_j:
X		case XK_J:
X			/* Set paddle to move left */
X			paddleMotion = -1;
X			break;
X
X		case XK_k:
X		case XK_K:
X			/* Shoot a bullet if available */
X			if (ActivateWaitingBall() == False)
X				shootBullet(display, playWindow);
X			break;
X
X		case XK_Right:
X		case XK_l:
X		case XK_L:
X			/* Set paddle to move right */
X			paddleMotion = 1;
X			break;
X
X		case XK_Escape:
X			/* Abort game and return to intros */
X			SetGameSpeed(FAST_SPEED);
X			ResetIntroduction();
X			mode = MODE_INTRO;
X
X			SetCurrentMessage(display, messWindow, 
X				"Game aborted.", True);
X			break;
X
X      	case XK_minus:
X			if (debug == True)
X			{
X            	SkipToNextLevel(display, playWindow);
X            	SetCurrentMessage(display, messWindow,
X            		"Skipping to next level ...", True);
X			}
X            break;
X
X		case XK_p:
X		case XK_P:
X			ToggleGamePaused(display, mainWindow);
X			break;
X
X		default: 	/* All other keys */
X			handleMiscKeys(display, keysym);
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void handleIntroKeys(Display *display, KeySym keysym)
X#else
Xstatic void handleIntroKeys(display, keysym)
X	Display *display;
X	KeySym keysym;
X#endif
X{
X	/* Switch on the keysym */
X	switch (keysym)
X	{
X
X		case XK_space:
X			if (mode == MODE_INTRO || mode == MODE_HIGHSCORE 
X			  || mode == MODE_INSTRUCT || mode == MODE_KEYS)
X			{
X				ResetBorderGlow(display, playWindow);
X				SetGameSpeed(FAST_SPEED);
X				gameActive = False;
X				mode = MODE_GAME;
X			}
X
X			if (mode == MODE_BONUS)
X				SetBonusWait(BONUS_FINISH, frame);
X			break;
X
X		case XK_c:
X		case XK_C:
X			/* Cycle through the introduction screens if note in a game */
X			if (mode == MODE_INTRO)
X			{
X				/* Ok - Goto the instructions mode */
X				SetGameSpeed(FAST_SPEED);
X				ResetInstructions();
X				mode = MODE_INSTRUCT;
X			} else if (mode == MODE_INSTRUCT)
X			{
X				/* Ok - Goto the keys mode */
X				SetGameSpeed(FAST_SPEED);
X				ResetKeys();
X				mode = MODE_KEYS;
X			} else if (mode == MODE_KEYS)
X			{
X				/* Ok - Goto the highscore mode */
X				SetGameSpeed(FAST_SPEED);
X				ResetHighScore(GLOBAL);
X				mode = MODE_HIGHSCORE;
X			} else if (mode == MODE_HIGHSCORE)
X			{
X				/* Ok - Goto back to the intro mode */
X				SetGameSpeed(FAST_SPEED);
X				ResetIntroduction();
X				mode = MODE_INTRO;
X			} 
X			break;
X
X		case XK_H:	/* Personal highscores */
X			if (mode == MODE_INTRO || mode == MODE_INSTRUCT 
X				|| mode == MODE_KEYS || mode == MODE_HIGHSCORE)
X			{
X				/* Display the high scores thanks */
X				SetGameSpeed(FAST_SPEED);
X				ResetHighScore(PERSONAL);
X				mode = MODE_HIGHSCORE;
X
X				/* Play a bit of sound */
X				if (noSound == False)
X					playSoundFile("toggle", 50);
X				
X			}
X			break;
X
X		case XK_h:	/* Global highscores */
X			if (mode == MODE_INTRO || mode == MODE_INSTRUCT 
X				|| mode == MODE_KEYS || mode == MODE_HIGHSCORE)
X			{
X				SetGameSpeed(FAST_SPEED);
X				ResetHighScore(GLOBAL);
X				mode = MODE_HIGHSCORE;
X
X				/* Play a bit of sound */
X				if (noSound == False)
X					playSoundFile("toggle", 50);
X			}
X			break;
X
X		case XK_s:
X		case XK_S:
X			if (mode == MODE_INTRO || mode == MODE_INSTRUCT 
X				|| mode == MODE_KEYS || mode == MODE_HIGHSCORE)
X			{
X				/* toggle the special effects system */
X				if (getSpecialEffects(display) == True)
X				{
X					/* Turn off special effects */
X					useSpecialEffects(False);
X
X					SetCurrentMessage(display, messWindow, 
X						"- SFX OFF -", True);
X				}
X				else
X				{
X					/* Cannot use sfx on this display */
X					if (getSpecialEffects(display) == -1)
X					{
X						SetCurrentMessage(display, messWindow, 
X							"- SFX Unavailable -", True);
X					}
X					else
X					{
X						/* Try and turn on special effects */
X						useSpecialEffects(True);
X
X						SetCurrentMessage(display, messWindow, 
X							"- SFX ON -", True);
X					}
X				}
X			}
X			break;
X
X		default: 	/* All other keys */
X			handleMiscKeys(display, keysym);
X	}
X}
X#if NeedFunctionPrototypes
Xstatic void handleQuitKeys(Display *display, KeySym keysym)
X#else
Xstatic void handleQuitKeys(display, keysym)
X	Display *display;
X	KeySym keysym;
X#endif
X{
X	/* Switch on the keysym */
X	switch (keysym)
X	{
X		case XK_y:
X		case XK_Y:
X			/* Save out the scores if you were playing */
X			if (oldmode == MODE_GAME || oldmode == MODE_BONUS)
X			{
X				/* Save out scores when quitting */
X				UpdateHighScores();
X			}
X
X			/* Shut down and exit game */
X			ShutDown(display, 0, "Thank you for playing XBoing.");
X			break;
X
X		case XK_n:
X		case XK_N:
X			/* Change back to the previous mode */
X			SetCurrentMessage(display, messWindow, "Quit aborted!", True);
X			mode = oldmode;
X			break;
X
X		default:
X			/* Yes or No keys thanks */
X			XBell(display, 0);
X			break;
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void handlePresentsKeys(Display *display, KeySym keysym)
X#else
Xstatic void handlePresentsKeys(display, keysym)
X	Display *display;
X	KeySym keysym;
X#endif
X{
X	/* Switch on the keysym */
X	switch (keysym)
X	{
X		case XK_space:
X			QuickFinish(display, mainWindow);
X			break;
X
X		case XK_Q:
X		case XK_q:
X			/* Shut down and exit game */
X			ShutDown(display, 0, "Thank you for playing XBoing.");
X			break;
X
X		default:
X			break;
X	}
X}
X
X
X#if NeedFunctionPrototypes
Xstatic void handleMiscKeys(Display *display, KeySym keysym)
X#else
Xstatic void handleMiscKeys(display, keysym)
X	Display *display;
X	KeySym keysym;
X#endif
X{
X	/* Switch on the keysym */
X	switch (keysym)
X	{
X		case XK_a:
X		case XK_A:
X			handleSoundKey(display);
X			break;
X
X		case XK_i:
X		case XK_I:
X			/* Iconify the window quickly - main loop handles events */
X			XIconifyWindow(display, mainWindow, 0);
X			break;
X
X		case XK_g:
X		case XK_G:
X			handleControlKeys(display);
X			break;
X
X		case XK_Q:
X		case XK_q:
X			/* Issue message and change to quit mode */
X			SetCurrentMessage(display, messWindow, 
X				"Really Quit? [Y/N]", False);
X			oldmode = mode;
X			mode = MODE_QUIT;
X			break;
X
X		case XK_1:	/* Set speed to speed 1 */
X			SetUserSpeed(9);
X			SetCurrentMessage(display, messWindow, "Warp 1", True);
X			if (noSound == False) playSoundFile("tone", 50);
X			break;
X
X		case XK_2:	/* Set speed to speed 2 */
X			SetUserSpeed(8);
X			SetCurrentMessage(display, messWindow, "Warp 2", True);
X			if (noSound == False) playSoundFile("tone", 50);
X			break;
X
X		case XK_3:	/* Set speed to speed 3 */
X			SetUserSpeed(7);
X			SetCurrentMessage(display, messWindow, "Warp 3", True);
X			if (noSound == False) playSoundFile("tone", 50);
X			break;
X
X		case XK_4:	/* Set speed to speed 4 */
X			SetUserSpeed(6);
X			SetCurrentMessage(display, messWindow, "Warp 4", True);
X			if (noSound == False) playSoundFile("tone", 50);
X			break;
X
X		case XK_5:	/* Set speed to speed 5 */
X			SetUserSpeed(5);
X			SetCurrentMessage(display, messWindow, "Warp 5", True);
X			if (noSound == False) playSoundFile("tone", 50);
X			break;
X
X		case XK_6:	/* Set speed to speed 6 */
X			SetUserSpeed(4);
X			SetCurrentMessage(display, messWindow, "Warp 6", True);
X			if (noSound == False) playSoundFile("tone", 50);
X			break;
X
X		case XK_7:	/* Set speed to speed 7 */
X			SetUserSpeed(3);
X			SetCurrentMessage(display, messWindow, "Warp 7", True);
X			if (noSound == False) playSoundFile("tone", 50);
X			break;
X
X		case XK_8:	/* Set speed to speed 8 */
X			SetUserSpeed(2);
X			SetCurrentMessage(display, messWindow, "Warp 8", True);
X			if (noSound == False) playSoundFile("tone", 50);
X			break;
X
X		case XK_9:	/* Set speed to speed 9 */
X			SetUserSpeed(1);
X			SetCurrentMessage(display, messWindow, "Warp 9", True);
X			if (noSound == False) playSoundFile("tone", 50);
X			break;
X
X		default: 	/* All other keys */
X			break;
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid handleKeyPress(Display *display, KeySym keysym, int Pressed)
X#else
Xvoid handleKeyPress(display, keysym, Pressed)
X	Display *display;
X	KeySym keysym;
X	int Pressed;
X#endif
X{
X
X	if (Pressed == False)
X	{
X		/* key was released */
X		paddleMotion = 0;
X	}
X	else
X	{
X		/* Switch on the game mode */
X		switch (mode)
X		{
X			case MODE_QUIT:
X				handleQuitKeys(display, keysym);
X				break;
X
X			case MODE_WAIT:
X			case MODE_BALL_WAIT:
X			case MODE_PAUSE:
X			case MODE_GAME:
X				handleGameKeys(display, keysym);
X				break;
X
X			case MODE_HIGHSCORE:
X			case MODE_BONUS:
X			case MODE_INTRO:
X			case MODE_INSTRUCT:
X			case MODE_KEYS:
X				handleIntroKeys(display, keysym);
X				break;
X
X			case MODE_PRESENTS:
X				handlePresentsKeys(display, keysym);
X				break;
X
X			case MODE_NONE:
X				break;
X		}
X	}
X}
X
X
X
X#if NeedFunctionPrototypes
Xstatic void handleGameMode(Display *display)
X#else
Xstatic void handleGameMode(display)
X	Display *display;
X#endif
X{
X	static int bonusRow = 0;
X	static int bonusCol = 0;
X	static int nextBonusFrame = 0;
X
X	/* If we are going to play then setup first level */
X	if (gameActive == False)
X	{
X		/* Choose a random velocity for the ball */
X
X		/* Always start at level 1 or level specified */
X		SetLevelNumber(GetStartingLevel());
X
X		/* Set some important variables */
X		livesLeft 			= 3;
X		score 				= 0;
X		nextBonusFrame 		= 0;
X		currentPaddleSize 	= PADDLE_HUGE;
X		pausedTime			= 0;
X		bonusBlock 			= False;
X
X		/* Setup the stage and load 1st level */
X		SetupStage(display, playWindow);
X
X		/* Start game play */
X		gameActive = True;
X
X		/* Keep track of the game duration - shown in highscores */
X		gameTime = time(NULL);
X	}
X
X	/* If we need to move the paddle then do so */
X	if ((frame % PADDLE_ANIMATE_DELAY) == 0)
X		handlePaddleMoving(display);
X
X	if (mode == MODE_GAME)
X	{
X		HandleBallMode(display, playWindow);
X
X		/* Add bonus coin block at random intervals */
X		if (nextBonusFrame == 0 && bonusBlock == False)
X			nextBonusFrame = frame + (rand() % BONUS_SEED);
X
X		/* Do we need to add a bonus coin? */
X		if (nextBonusFrame <= frame && bonusBlock == False)
X		{
X			/* Add the bonus block now - different types */
X			switch (rand() % 10)
X			{
X				case 0: case 1: 
X				case 2: case 3: 
X				case 4: case 5: 
X				case 6: case 7:
X					/* Add a normal bonus block */
X					AddBonusBlock(display, playWindow, &bonusRow, &bonusCol, 
X						BONUS_BLK);
X					break;
X
X				case 8:
X					/* Add the x2 bonus block */
X					AddBonusBlock(display, playWindow, &bonusRow, &bonusCol, 
X						BONUSX2_BLK);
X					break;
X
X				case 9:
X					/* Add the x4 bonus block */
X					AddBonusBlock(display, playWindow, &bonusRow, &bonusCol, 
X						BONUSX4_BLK);
X					break;
X
X			}
X
X			nextBonusFrame = 0;
X		}
X	}
X
X	HandleBulletMode(display, playWindow);
X
X	/* If any blocks need exploding then do so */
X	ExplodeBlocksPending(display, playWindow);
X
X	/* So blocks need animation all the time so do it */
X	HandlePendingAnimations(display, playWindow);
X
X	/* See if the level is finished and update level info if needed */
X	if (mode == MODE_GAME)
X		CheckGameRules(display, playWindow);
X}
X
X#if NeedFunctionPrototypes
Xstatic void handleGameStates(Display *display)
X#else
Xstatic void handleGameStates(display)
X	Display *display;
X#endif
X{
X	/* Update the message window if any new messages come along */
X	DisplayCurrentMessage(display, messWindow);
X
X	/* In game effects */
X	switch (currentSfxMode())
X	{
X		case SFX_SHAKE:
X			/* Something exploded or bumped the screen */
X			WindowShakeEffect(display, playWindow);
X			break;
X
X		case SFX_FADE:
X			/* fade when play arena is taken off screen */
X			WindowFadeEffect(display, playWindow);
X			break;
X			
X		case SFX_BLIND:
X			/* bring the backing buffer pixmap into view via a blind effect */
X			WindowBlindEffect(display, playWindow);
X			break;
X			
X		case SFX_SHATTER:
X			/* bring the backing buffer pixmap into view via a blind effect */
X			WindowShatterEffect(display, playWindow);
X			break;
X			
X		case SFX_NONE:
X		default:
X			break;
X	}
X
X	/* Switch on the current game mode */
X	switch (mode)
X	{
X		case MODE_GAME:
X			handleGameMode(display);
X			break;
X
X		case MODE_PRESENTS:
X			Presents(display, mainWindow);
X			break;
X
X		case MODE_BONUS:
X			DoBonus(display, mainWindow);
X			break;
X
X		case MODE_INTRO:
X			Introduction(display, playWindow);
X			break;
X
X		case MODE_INSTRUCT:
X			Instructions(display, playWindow);
X			break;
X
X		case MODE_KEYS:
X			Keys(display, playWindow);
X			break;
X
X		case MODE_HIGHSCORE:
X			HighScore(display, playWindow);
X			break;
X
X		case MODE_PAUSE:
X		case MODE_QUIT:
X			break;
X	}
X
X	/* Flush the display */
X	XFlush(display);
X}
X
X#if NeedFunctionPrototypes
Xstatic void handleEventLoop(Display *display)
X#else
Xstatic void handleEventLoop(display)
X	Display *display;
X#endif
X{
X	XEvent event;
X	int pending;
X	KeySym keysym;
X
X	pending = frame = 0;
X
X	/* Initial mode for game is Introduction */
X	mode = MODE_PRESENTS;
X
X	/* No special effects yet */
X	changeSfxMode(SFX_NONE);
X
X	/* Flush all events until app is fully mapped */
X    do
X	{
X		/* handle audio device events if they exist */
X		audioDeviceEvents();
X
X		/* Get the next event */
X		XNextEvent(display, &event);
X	}
X	while (event.type != MapNotify);
X
X	/* Grab the pointer to the main window */
X	GrabPointer(display, mainWindow);
X
X	/* Loop forever and ever */
X	while (True)
X	{
X		/* handle and audio device events if supported */
X		audioDeviceEvents();
X
X		/* Sleep a bit if not iconified */
X		if (iconified == False)
X			sleepSync(display, speed);
X
X		/* See if any events are waiting for me to handle */
X		if (iconified == False && mode != MODE_PAUSE)
X		{
X			/* Get an event but don't wait if none arrives */
X			pending = XPending(display);
X			frame++;
X		}
X		else
X		{
X			/* Wait here for an event and then get the number waiting */
X			XPeekEvent(display, &event);
X			pending = XPending(display);
X		}
X		
X		/* Handle any events pending */
X		while (pending > 0)
X		{
X			/* Get the next X event thanks */
X			XNextEvent(display, &event);
X
X			switch(event.type)
X			{
X				case UnmapNotify:
X					/* Turn off just all events except the mapping ones */
X    				XSelectInput(display, mainWindow, StructureNotifyMask);
X					handleIconify(display, (XUnmapEvent *) &event);
X					iconified = True;
X					break;
X
X				case MapNotify:
X					/* Turn back on all the events that are needed */
X    				XSelectInput(display, mainWindow, 
X						KeyPressMask | KeyReleaseMask | ButtonPressMask |
X       					ButtonReleaseMask | ExposureMask | StructureNotifyMask);
X
X					SelectiveRedraw(display);
X 					GrabPointer(display, mainWindow);
X					iconified = False;
X
X					break;
X
X				case ButtonRelease:
X					handleMouseButtons(display, event, False);
X					break;
X
X				case ButtonPress:
X					handleMouseButtons(display, event, True);
X					break;
X
X				case KeyRelease:
X					keysym = GetKeySym(event);
X					handleKeyPress(display, keysym, False);
X					break;
X
X				case KeyPress:
X					keysym = GetKeySym(event);
X					handleKeyPress(display, keysym, True);
X					break;
X
X				case Expose:
X					handleExposure(display, event);
X					break;
X
X				default:
X					break;
X			}
X
X			/* Decrement the number of pending events */
X			pending--;
X		}
X
X		/* handle all game states and animations */
X		if (iconified == False) 
X			handleGameStates(display);
X	}
X
X	/* NOT REACHED */
X}
X
X#if NeedFunctionPrototypes
Xvoid main(int argc, char **argv)
X#else
Xvoid main(argc, argv)
X	int argc;
X	char **argv;
X#endif
X{
X	static Display *display;
X
X	/* Initialise everything and return display */
X	display = InitialiseGame(argv, argc);
X
X	SetGameSpeed(FAST_SPEED);
X	gameActive = False;
X	iconified = False;
X
X	/* main event loop */
X	handleEventLoop(display);
X
X	/* NOTREACHED */
X}
END_OF_FILE
if test 25219 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
echo shar: End of archive 12 \(of 30\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    echo "Now execute sdecode.sh to build files."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
