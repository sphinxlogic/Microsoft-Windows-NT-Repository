Path: uunet!news.tek.com!news.cna.tek.com!not-for-mail
From: billr@saab.cna.tek.com (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i056:  threedee - two 3d tetris games for X, Part01/04
Date: 30 Aug 1993 08:34:42 -0700
Organization: Tektronix, Inc., Redmond, OR
Lines: 1955
Approved: billr@saab.CNA.TEK.COM
Message-ID: <25t6mi$fm0@saab.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1856

Submitted-by: "Andrew C. Plotkin" <ap1i+@andrew.cmu.edu>
Posting-number: Volume 18, Issue 56
Archive-name: threedee/part01
Environment: X11, Xlib

[This is two games; tetris on a sane, cubical 3-d lattice, and tetris on
a close-packed 3-d lattice of spheres. -br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 4)."
# Contents:  README MANIFEST spatial spatial/disp.c spatial/rots.c
#   spheral spheral/Makefile spheral/intro.c spheral/rots.c
# Wrapped by billr@saab on Mon Aug 30 08:05:07 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(554 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XThis is two games; tetris on a sane, cubical 3-d lattice, and tetris on
Xa close-packed 3-d lattice of spheres.
X
XThe code of the two games is similar enough that any porting changes you
Xmake to one will probably be applicable to the other.
X
XIf you grabbed the beta version of these games from my account, note the
Xfollowing changes: the "sqrt domain error" has been fixed, and spatial
Xis now in color. (Unfortunately, due to X's peculiar ideas, spheral
Xcannot be displayed correctly in color. If you manage to hack this to
Xwork, please let me know.)
X
X--Z
END_OF_FILE
if test 554 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2129 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X README                     1	
X spatial                    1	
X spatial/Makefile           3	
X spatial/README             3	
X spatial/deco.c             3	
X spatial/disp.c             1	
X spatial/game.c             2	
X spatial/grey01.bm          3	
X spatial/grey02.bm          3	
X spatial/grey03.bm          3	
X spatial/grey04.bm          3	
X spatial/grey05.bm          3	
X spatial/grey06.bm          3	
X spatial/grey07.bm          3	
X spatial/grey08.bm          3	
X spatial/grey09.bm          3	
X spatial/grey10.bm          3	
X spatial/grey11.bm          3	
X spatial/grey12.bm          3	
X spatial/grey13.bm          3	
X spatial/grey14.bm          3	
X spatial/grey15.bm          3	
X spatial/grey16.bm          3	
X spatial/intro.c            2	
X spatial/patchlevel.h       4	
X spatial/rots.c             1	
X spatial/score.c            3	
X spatial/spatial.6          3	
X spatial/spatial.c          3	
X spatial/spatial.h          3	
X spatial/spatial.shp        2	
X spheral                    1	
X spheral/Makefile           1	
X spheral/README             3	
X spheral/deco.c             3	
X spheral/disp.c             2	
X spheral/errdi.c            3	
X spheral/game.c             2	
X spheral/gcgrey.c           3	
X spheral/grey01.bm          3	
X spheral/grey02.bm          3	
X spheral/grey03.bm          3	
X spheral/grey04.bm          3	
X spheral/grey05.bm          3	
X spheral/grey06.bm          3	
X spheral/grey07.bm          3	
X spheral/grey08.bm          3	
X spheral/grey09.bm          3	
X spheral/grey10.bm          3	
X spheral/grey11.bm          3	
X spheral/grey12.bm          3	
X spheral/grey13.bm          3	
X spheral/grey14.bm          3	
X spheral/grey15.bm          3	
X spheral/grey16.bm          3	
X spheral/intro.c            1	
X spheral/patchlevel.h       2	
X spheral/rots.c             1	
X spheral/score.c            2	
X spheral/spheral.6          2	
X spheral/spheral.c          3	
X spheral/spheral.h          3	
X spheral/spheral.shp        3	
X spheral/test.c             3	
END_OF_FILE
if test 2129 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test ! -d 'spatial' ; then
    echo shar: Creating directory \"'spatial'\"
    mkdir 'spatial'
fi
if test -f 'spatial/disp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/disp.c'\"
else
echo shar: Extracting \"'spatial/disp.c'\" \(13176 characters\)
sed "s/^X//" >'spatial/disp.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include "spatial.h"
X#include "grey01.bm"
X#include "grey02.bm"
X#include "grey03.bm"
X#include "grey04.bm"
X#include "grey05.bm"
X#include "grey06.bm"
X#include "grey07.bm"
X#include "grey08.bm"
X#include "grey09.bm"
X#include "grey10.bm"
X#include "grey11.bm"
X#include "grey12.bm"
X#include "grey13.bm"
X#include "grey14.bm"
X#include "grey15.bm"
X#include "grey16.bm"
X
XDisplay *dpy;
XWindow win;
XPixmap backpm, fieldpm;
XGC gcblack, gcwhite, gcinv, gccopy, gcline,
Xgcfield, gccubes[16]; /* graphics contexts */
Xint scn;
Xint scndepth;
Xint forcemono = 0;
X
Xpiecelist pieces[MAXPIECES];
X
Xshort numpieces;
Xshort curpiece;
X
Xint dispx, dispy; /* size of window */
Xint shapex1, shapex2, shapey1, shapey2;
X/* coords of rectangle of backpm that is different from fieldpm */
Xint ddispx1, ddispx2, ddispy1, ddispy2;
X/* coords of rectangle of display that is different from fieldpm */
X
Xextern void dumppiece(), setup_fieldpm(),
Xsetup_one_fieldpm(), draw_curpiece();
X
Xvoid xinit() /* using dispx, dispy */
X{
X    register int ix;
X    XSetWindowAttributes attr;
X    XGCValues gcvalues;
X    static char dashes[2] = {1, 1};
X    Pixmap greypm[16];
X    XSizeHints hints;
X    Status res;
X    XColor col, sccol;
X    static unsigned short colvalues[16][3] = {
X	{0x0000, 0x0000, 0x0000},
X	{0x6000, 0xA000, 0x6000}, /* green grey */
X	{0x0000, 0x0000, 0x0000},
X	{0x6000, 0x6000, 0xA000}, /* blue grey */
X	{0xC000, 0x0000, 0x0000}, /* red */
X	{0x0000, 0x0000, 0x0000},
X	{0x0000, 0x0000, 0x0000},
X	{0xAA00, 0x8000, 0x0000}, /* orange */
X	{0x0000, 0x0000, 0x0000},
X	{0xC000, 0xC000, 0x0000}, /* yellow */
X	{0x0000, 0xC000, 0x0000}, /* green */
X	{0x0000, 0x0000, 0xFF00}, /* blue */
X	{0x8000, 0x0000, 0xC000}, /* purple */
X	{0xFF00, 0x6000, 0x6000}, /* light red */
X	{0x8000, 0x8000, 0xFF00}, /* light blue */
X	{0xC000, 0xC000, 0xC000}  /* light grey */
X    };
X
X    dpy = XOpenDisplay((char *) NULL);
X    if ((Display *) NULL == dpy) {
X	fprintf(stderr, "spatial: could not open display.\n");
X	exit(-1);
X    }
X
X    scn = DefaultScreen(dpy);
X    scndepth = DefaultDepth(dpy, scn);
X
X    win = XCreateSimpleWindow(dpy, DefaultRootWindow(dpy),
X	100, 100, dispx, dispy, 1, BlackPixel(dpy, scn),
X	WhitePixel(dpy, scn));
X
X    hints.min_width = 100;
X    hints.min_height = 100;
X    hints.width = dispx;
X    hints.height = dispy;
X    hints.flags = PMinSize | PSize;
X    XSetWMNormalHints(dpy, win, &hints);
X
X    XStoreName(dpy, win, "Spatial");
X
X    attr.event_mask = (KeyPressMask | ExposureMask | StructureNotifyMask);
X    XChangeWindowAttributes(dpy, win, CWEventMask, &attr);
X
X    XSetWindowBackground(dpy, win, BlackPixel(dpy, scn));
X
X    XMapWindow(dpy, win);
X
X    gcvalues.foreground = WhitePixel(dpy, scn);
X    gcvalues.background = BlackPixel(dpy, scn);
X    gcwhite = XCreateGC(dpy, win, GCForeground|GCBackground,
X	&gcvalues);
X
X    if (forcemono || DefaultDepth(dpy, scn)==1) {
X
X	greypm[0] = XCreatePixmapFromBitmapData(dpy, win,
X	grey01_bits, grey01_width, grey01_height, 0, 1, 1);
X	greypm[1] = XCreatePixmapFromBitmapData(dpy, win,
X	grey02_bits, grey02_width, grey02_height, 0, 1, 1);
X	greypm[2] = XCreatePixmapFromBitmapData(dpy, win,
X	grey03_bits, grey03_width, grey03_height, 0, 1, 1);
X	greypm[3] = XCreatePixmapFromBitmapData(dpy, win,
X	grey04_bits, grey04_width, grey04_height, 0, 1, 1);
X	greypm[4] = XCreatePixmapFromBitmapData(dpy, win,
X	grey05_bits, grey05_width, grey05_height, 0, 1, 1);
X	greypm[5] = XCreatePixmapFromBitmapData(dpy, win,
X	grey06_bits, grey06_width, grey06_height, 0, 1, 1);
X	greypm[6] = XCreatePixmapFromBitmapData(dpy, win,
X	grey07_bits, grey07_width, grey07_height, 0, 1, 1);
X	greypm[7] = XCreatePixmapFromBitmapData(dpy, win,
X	grey08_bits, grey08_width, grey08_height, 0, 1, 1);
X	greypm[8] = XCreatePixmapFromBitmapData(dpy, win,
X	grey09_bits, grey09_width, grey09_height, 0, 1, 1);
X	greypm[9] = XCreatePixmapFromBitmapData(dpy, win,
X	grey10_bits, grey10_width, grey10_height, 0, 1, 1);
X	greypm[10] = XCreatePixmapFromBitmapData(dpy, win,
X	 grey11_bits, grey11_width, grey11_height, 0, 1, 1);
X	greypm[11] = XCreatePixmapFromBitmapData(dpy, win,
X	 grey12_bits, grey12_width, grey12_height, 0, 1, 1);
X	greypm[12] = XCreatePixmapFromBitmapData(dpy, win,
X	 grey13_bits, grey13_width, grey13_height, 0, 1, 1);
X	greypm[13] = XCreatePixmapFromBitmapData(dpy, win,
X	 grey14_bits, grey14_width, grey14_height, 0, 1, 1);
X	greypm[14] = XCreatePixmapFromBitmapData(dpy, win,
X	 grey15_bits, grey15_width, grey15_height, 0, 1, 1);
X	greypm[15] = XCreatePixmapFromBitmapData(dpy, win,
X	 grey16_bits, grey16_width, grey16_height, 0, 1, 1);
X
X	gcvalues.fill_style = FillOpaqueStippled;
X	for (ix=0; ix<16; ix++) {
X	    gcvalues.stipple = greypm[ix];
X	    gccubes[ix] = XCreateGC(dpy, win,
X		GCForeground|GCBackground|GCFillStyle|GCStipple,
X		&gcvalues);
X	};
X    }
X    else {
X	for (ix=0; ix<16; ix++) {
X	    col.red = colvalues[ix][0];
X	    col.green = colvalues[ix][1];
X	    col.blue = colvalues[ix][2];
X	    res = XAllocColor(dpy, DefaultColormap(dpy, scn),
X		&col);
X	    if (!res) {
X		fprintf(stderr, "spatial: unable to allocate colors\n");
X		exit(-1);
X	    }
X	    gcvalues.foreground = col.pixel;
X	    gccubes[ix] = XCreateGC(dpy, win, GCForeground,
X		&gcvalues);
X	}
X
X    }
X
X    gcvalues.foreground = WhitePixel(dpy, scn);
X    gcvalues.background = BlackPixel(dpy, scn);
X
X    gcvalues.line_style = LineOnOffDash;
X    gcfield = XCreateGC(dpy, win, GCForeground|GCLineStyle,
X	&gcvalues);
X
X    XSetDashes(dpy, gcfield, 0, dashes, 2);
X    gcvalues.line_width = 2;
X    gcline = XCreateGC(dpy, win, GCForeground|GCLineWidth,
X	&gcvalues);
X
X    gcvalues.foreground = BlackPixel(dpy, scn);
X    gcblack = XCreateGC(dpy, win, GCForeground, &gcvalues);
X
X    gcvalues.function = GXinvert;
X    gcinv = XCreateGC(dpy, win, GCForeground|GCFunction, &gcvalues);
X
X    gcvalues.background = WhitePixel(dpy, scn);
X    gccopy = XCreateGC(dpy, win, GCForeground|GCBackground, &gcvalues);
X    XSetGraphicsExposures(dpy, gccopy, 0);
X
X    backpm = XCreatePixmap(dpy, win, dispx, dispy, scndepth);   
X    fieldpm = XCreatePixmap(dpy, win, dispx, dispy, scndepth);   
X}
X
Xvoid setup_fieldpm() /* clear, draw field box and side
X text. Also set shape{x,y}{1,2} to window size */
X{
X    XFillRectangle(dpy, fieldpm, gcblack, 0, 0, dispx, dispy);
X    XDrawImageString(dpy, fieldpm, gcwhite, 50,
X	(int)boardscale+20, "Score: ", 7); 
X
X    setup_one_fieldpm(fieldpts);
X    if (stereo)
X	setup_one_fieldpm(fieldpts2);
X
X    shapex1 = 0;
X    shapex2 = dispx-1;
X    shapey1 = 0;
X    shapey2 = dispy-1;
X    ddispx1 = 0;
X    ddispx2 = dispx-1;
X    ddispy1 = 0;
X    ddispy2 = dispy-1;
X    meteroldlev = 0;
X}
X
Xvoid setup_one_fieldpm(fips)
Xfieldplist fips;
X{
X    register int ix, iy, iz;
X
X    for (iz=0; iz<=fieldz; iz++) {
X	XDrawLine(dpy, fieldpm, gcfield, fips[0][0][iz].x,
X		  fips[0][0][iz].y, fips[fieldx][0][iz].x,
X		  fips[fieldx][0][iz].y);
X	XDrawLine(dpy, fieldpm, gcfield,
X		  fips[fieldx][fieldy][iz].x, fips[fieldx][fieldy][iz].y,
X		  fips[fieldx][0][iz].x, fips[fieldx][0][iz].y);
X	XDrawLine(dpy, fieldpm, gcfield, fips[0][0][iz].x,
X		  fips[0][0][iz].y, fips[0][fieldy][iz].x, fips[0][fieldy][iz].y);
X	XDrawLine(dpy, fieldpm, gcfield,
X		  fips[fieldx][fieldy][iz].x, fips[fieldx][fieldy][iz].y,
X		  fips[0][fieldy][iz].x, fips[0][fieldy][iz].y);
X    };
X    for (ix=0; ix<=fieldx; ix++) {
X	XDrawLine(dpy, fieldpm, gcfield, fips[ix][0][0].x,
X		  fips[ix][0][0].y, fips[ix][0][fieldz].x,
X		  fips[ix][0][fieldz].y);
X	XDrawLine(dpy, fieldpm, gcfield, fips[ix][0][0].x,
X		  fips[ix][0][0].y, fips[ix][fieldy][0].x, fips[ix][fieldy][0].y);
X	XDrawLine(dpy, fieldpm, gcfield,
X		  fips[ix][fieldy][fieldz].x, fips[ix][fieldy][fieldz].y,
X		  fips[ix][fieldy][0].x, fips[ix][fieldy][0].y);
X    }
X    for (iy=1; iy<fieldy; iy++) {
X	XDrawLine(dpy, fieldpm, gcfield, fips[0][iy][0].x,
X		  fips[0][iy][0].y, fips[0][iy][fieldz].x,
X		  fips[0][iy][fieldz].y);
X	XDrawLine(dpy, fieldpm, gcfield, fips[fieldx][iy][0].x,
X		  fips[fieldx][iy][0].y, fips[0][iy][0].x,
X		  fips[0][iy][0].y);
X	XDrawLine(dpy, fieldpm, gcfield, fips[fieldx][iy][0].x,
X		  fips[fieldx][iy][0].y, fips[fieldx][iy][fieldz].x,
X		  fips[fieldx][iy][fieldz].y);
X    };
X}
X
Xvoid draw_score(drw)
XDrawable drw;
X{
X    static char buf[32];
X    register int ix;
X    long sc;
X
X    if (score==0) {
X	XDrawImageString(dpy, drw, gcwhite, 106,
X			 (int)boardscale+20, "0         ", 10);
X    }
X    else {
X	sc = score;
X	ix = 32;
X	buf[--ix] = '\0';
X	while (sc) {
X	    buf[--ix] = (sc%10) + '0';
X	    sc /= 10;
X	};
X	XDrawImageString(dpy, drw, gcwhite, 106,
X			 (int)boardscale+20, buf+ix, 31-ix);
X    }
X}
X
Xvoid update_meter() /* on fieldpm */
X{
X    register int ix;
X    int x1, y1, width, heigh;
X    GC *gcc;
X
X    if (meterlev > meteroldlev) {
X	for (ix=meteroldlev; ix<meterlev; ix++) {
X	    gcc = &(gccubes[colors[ix]]);
X	    x1 = meterx + metersize*ix;
X	    y1 = metery;
X	    width = metersize-1;
X	    heigh = 20;
X	    XFillRectangle(dpy, fieldpm, *gcc, x1, y1, width, heigh);
X	    XDrawRectangle(dpy, fieldpm, gcwhite, x1, y1,
X			   width, heigh);
X	    if (stereo) {
X		x1 = meterx2 + metersize*ix;
X		XFillRectangle(dpy, fieldpm, *gcc, x1, y1,
X			       width, heigh);
X		XDrawRectangle(dpy, fieldpm, gcwhite, x1, y1,
X			       width, heigh);
X	    }
X	}
X    }
X    else {
X	x1 = meterx + metersize*meterlev + 1;
X	y1 = metery;
X	width = (meteroldlev - meterlev) * metersize;
X	heigh = 20;
X	XFillRectangle(dpy, fieldpm, gcblack, x1, y1, width, heigh);
X	if (stereo) {
X	    x1 = meterx2 + metersize*meterlev + 1;
X	    XFillRectangle(dpy, fieldpm, gcblack, x1, y1,
X			   width, heigh);
X	}
X    }
X    meteroldlev = meterlev;
X    meter_f_b = 1;
X}
X
Xvoid setup_backpm() 
X{
X    XCopyArea(dpy, fieldpm, backpm, gccopy, shapex1, shapey1,
X	      shapex2-shapex1+1, shapey2-shapey1+1, shapex1, shapey1);
X    
X    if (shapey2 > (int)boardscale && shapex1 < 300) {
X	draw_score(backpm);
X    }
X
X    if (meter_f_b) {
X	XCopyArea(dpy, fieldpm, backpm, gccopy, meterx,
X		  metery, metersize*fieldz+1, 21, meterx, metery);
X	if (stereo) {
X	    XCopyArea(dpy, fieldpm, backpm, gccopy, meterx2,
X		      metery, metersize*fieldz+1, 21, meterx2, metery);
X	}
X	meter_f_b = 0;
X	meter_b_d = 1;
X    }
X
X    if (curpiece != (-1)) {
X	/* draw current piece on backpm, storing
X	 shape{x,y}{1,2} limits */
X	draw_curpiece(backpm);
X    }
X}
X
Xvoid back_to_disp(all)
Xint all; 
X{
X    if (all) {
X	XCopyArea(dpy, backpm, win, gccopy, 0, 0,
X		  dispx, dispy, 0, 0);
X    }
X    else {
X	/* copy from backpm to display; area is
X	 max{shape, ddisp}; */
X	if (ddispx1 > shapex1) ddispx1 = shapex1;
X	if (ddispy1 > shapey1) ddispy1 = shapey1;
X	if (ddispx2 < shapex2) ddispx2 = shapex2;
X	if (ddispy2 < shapey2) ddispy2 = shapey2;
X	XCopyArea(dpy, backpm, win, gccopy, ddispx1, ddispy1,
X		  ddispx2-ddispx1+1, ddispy2-ddispy1+1, ddispx1, ddispy1);
X
X	if (meter_b_d) {
X	    XCopyArea(dpy, backpm, win, gccopy, meterx, metery,
X		      metersize*fieldz+1, 21, meterx, metery);
X	    if (stereo) {
X		XCopyArea(dpy, backpm, win, gccopy, meterx2,
X			  metery, metersize*fieldz+1, 21, meterx2, metery);
X	    }
X	    meter_b_d = 0;
X	}
X
X	/* set ddisp limits to shape limits; */
X	ddispx1 = shapex1;
X	ddispy1 = shapey1;
X	ddispx2 = shapex2;
X	ddispy2 = shapey2;
X    }
X}
X
Xvoid loadpieces(flname)
Xchar *flname;
X{
X    register int jx, ix;
X    FILE *fl;
X    int res;
X
X    fl = fopen(flname, "r");
X    if (fl==NULL) {
X	fprintf(stderr, "spatial: could not open shape file.\n");
X	exit(-1);
X    };
X
X    res=fscanf(fl, "%hd\n", &numpieces);
X    if (res!=1) {
X	fprintf(stderr, "spatial: error 0 in shape file.\n");
X	exit(-1);
X    };
X
X    for (ix=0; ix<numpieces; ix++) {
X	int in1, in2, in3;
X	res=fscanf(fl, "%d, %d, %d\n", &in1, &in2, &in3);
X	if (res!=3) {
X	    fprintf(stderr, "spatial: error 1 in shape file.\n");
X	    exit(-1);
X	};
X	pieces[ix].numcubes=in1;
X	pieces[ix].numverts=in2;
X	pieces[ix].numedges=in3;
X	pieces[ix].numpoints=in1+in2;
X	if (pieces[ix].numpoints>MAXPOINTS || pieces[ix].numedges>MAXEDGES) {
X	    fprintf(stderr, "spatial: shape %d is too complex.\n", ix);
X	    exit(-1);
X	};
X	for (jx=0; jx<pieces[ix].numpoints; jx++) {
X	    point *p = &(pieces[ix].points[jx]);
X	    res=fscanf(fl, "%lf, %lf, %lf\n",
X		       &(p->x), &(p->y), &(p->z));
X	    if (res!=3) {
X		fprintf(stderr, "spatial: error 2 in shape file.\n");
X		exit(-1);
X	    };
X	    p->w = 1.0;
X	};
X	pieces[ix].verts =
X	  &(pieces[ix].points[pieces[ix].numcubes]);
X	for (jx=0; jx<pieces[ix].numedges; jx++) {
X	    res=fscanf(fl, "%d,%d\n", &in1, &in2);
X	    if (res!=2) {
X		fprintf(stderr, "spatial: error 3 in shape file.\n");
X		exit(-1);
X	    };
X	    pieces[ix].edges[jx].head = in1;
X	    pieces[ix].edges[jx].tail = in2;
X	}
X    }
X}
X
Xvoid dumppiece(pnum)
Xshort pnum;
X{
X    piecelist *p = &(pieces[pnum]);
X    register int ix;
X
X    printf("%d cubes, %d verts, %d edges\n",
X	   p->numcubes, p->numverts, p->numedges);
X    for (ix=0; ix<p->numpoints; ix++) {
X	printf("%5.1f, %5.1f, %5.1f, %5.1f\n",
X	       p->points[ix].x, p->points[ix].y,
X	       p->points[ix].z, p->points[ix].w);
X    }
X    for (ix=0; ix<p->numedges; ix++) {
X	printf("%d,%d\n", p->edges[ix].head,
X	       p->edges[ix].tail);
X    };
X    printf("\n");
X}
END_OF_FILE
if test 13176 -ne `wc -c <'spatial/disp.c'`; then
    echo shar: \"'spatial/disp.c'\" unpacked with wrong size!
fi
# end of 'spatial/disp.c'
fi
if test -f 'spatial/rots.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/rots.c'\"
else
echo shar: Extracting \"'spatial/rots.c'\" \(12975 characters\)
sed "s/^X//" >'spatial/rots.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <math.h>    
X#include <X11/Xlib.h>
X#include "spatial.h"
X
Xtypedef struct _cubep {
X    int x, y, z;
X} cubep;
X
Xpoint plist[MAXPOINTS];	    /* shape, arbitrarily rotated */
Xpoint traplist[MAXPOINTS];  /* plist + offsets */
Xpoint templist[MAXCUBES];   /* temporary version */
Xdouble offx, offy, offz;
Xdouble focallen, boardscale;
Xint halfboard, halfboard2;
Xfieldplist fieldpts;
Xfieldplist fieldpts2;
X
Xint colors[11] = {1, 3, 4, 7, 9, 10, 11, 12, 13, 14, 15};
X
Xextern GC gcblack, gcwhite, gcinv, gccopy, gcline, gccubes[]; 
X
Xextern void updatepiece(), setup_fieldpm();
Xextern void add_one_cubie(), update_meter();
X
Xvoid startpiece()
X{
X    piecelist *p;
X    register int ix;
X    int res;
X    double flix, fliy, fliz;
X
X    curpiece = random() % numpieces;
X    flix = (random()%2)*2-1;
X    fliy = (random()%2)*2-1;
X    fliz = (random()%2)*2-1;
X
X    p = &(pieces[curpiece]);
X    for (ix=0; ix<p->numpoints; ix++) {
X	plist[ix].x = flix*p->points[ix].x;
X	plist[ix].y = fliy*p->points[ix].y;
X	plist[ix].z = fliz*p->points[ix].z;
X	plist[ix].w = p->points[ix].w;
X	traplist[ix].w = plist[ix].w;
X    };
X    offx=0.0;
X    offy=0.0;
X    offz=(double)fieldz+5.0;
X    updatepiece();
X    res = collision(0);
X    while (res>=1 && res<=6) {
X	switch (res) {
X	    case 1:
X		offz = floor(offz - 1.0 + 0.5);
X		break;
X	    case 2:
X		fprintf(stderr,
X			"spatial: piece too long for board\n");
X		exit(-1);
X		break;
X	    case 3:
X		offy = floor(offy + 1.0 + 0.5);
X		break;
X	    case 4:
X		offy = floor(offy - 1.0 + 0.5);
X		break;
X	    case 5:
X		offx = floor(offx - 1.0 + 0.5);
X		break;
X	    case 6:
X		offx = floor(offx + 1.0 + 0.5);
X		break;
X	}
X	updatepiece();
X	res = collision(0);
X    };
X    if (res==(-1)) curpiece = (-2);
X}
X
Xvoid rotate_piece(axis, theta) /* works on plist */
Xint axis;
Xdouble theta;
X{
X    register int ix;
X    double t1, t2;
X    double sinth = sin(theta);
X    double costh = cos(theta);
X
X    switch (axis) {
X	case 1:
X	    for (ix=0; ix<pieces[curpiece].numpoints; ix++) {
X		t1 = plist[ix].y;
X		t2 = plist[ix].z;
X		plist[ix].y = costh*t1 - sinth*t2;
X		plist[ix].z = sinth*t1 + costh*t2;
X	    }
X	    break;
X	case 2:
X	    for (ix=0; ix<pieces[curpiece].numpoints; ix++) {
X		t1 = plist[ix].x;
X		t2 = plist[ix].z;
X		plist[ix].x = costh*t1 - sinth*t2;
X		plist[ix].z = sinth*t1 + costh*t2;
X	    }
X	    break;
X	case 3:
X	    for (ix=0; ix<pieces[curpiece].numpoints; ix++) {
X		t1 = plist[ix].x;
X		t2 = plist[ix].y;
X		plist[ix].x = costh*t1 - sinth*t2;
X		plist[ix].y = sinth*t1 + costh*t2;
X	    }
X	    break;
X    }
X}
X
Xvoid updatepiece() /* create traplist from plist+offsets */
X{
X    register int ix;
X
X    for (ix=0; ix<pieces[curpiece].numpoints; ix++) {
X	traplist[ix].x = plist[ix].x + offx;
X	traplist[ix].y = plist[ix].y + offy;
X	traplist[ix].z = plist[ix].z + offz;
X    };
X}
X
Xvoid updatetemp_tra(xa, ya, za, taxi, tdir)
Xshort xa, ya, za, taxi, tdir;
X{
X    register int ix;
X
X    switch (taxi) {
X	case 0:
X	    for (ix=0; ix<pieces[curpiece].numcubes; ix++) {
X		templist[ix].x = traplist[ix].x;
X		templist[ix].y = traplist[ix].y;
X		templist[ix].z = traplist[ix].z;
X	    };
X	    break;
X	case 1:
X	    for (ix=0; ix<pieces[curpiece].numcubes; ix++) {
X		templist[ix].x = plist[ix].x + offx;
X		templist[ix].y = -tdir*plist[ix].z + offy;
X		templist[ix].z = tdir*plist[ix].y + offz;
X	    };
X	    break;
X	case 2:
X	    for (ix=0; ix<pieces[curpiece].numcubes; ix++) {
X		templist[ix].x = -tdir*plist[ix].z + offx;
X		templist[ix].y = plist[ix].y + offy;
X		templist[ix].z = tdir*plist[ix].x + offz;
X	    };
X	    break;
X	case 3:
X	    for (ix=0; ix<pieces[curpiece].numcubes; ix++) {
X		templist[ix].x = -tdir*plist[ix].y + offx;
X		templist[ix].y = tdir*plist[ix].x + offy;
X		templist[ix].z = plist[ix].z + offz;
X	    };
X	    break;
X    }
X
X    for (ix=0; ix<pieces[curpiece].numcubes; ix++) {
X	templist[ix].x += (double)xa;
X	templist[ix].y += (double)ya;
X	templist[ix].z += (double)za;
X    };
X}
X
Xvoid round_piece() /* round off piece to int
X offsets, halfint coords */
X{
X    register int ix;
X
X    offx = floor(offx+0.5);
X    offy = floor(offy+0.5);
X    offz = floor(offz+0.5);
X
X    for (ix=0; ix<pieces[curpiece].numpoints; ix++) {
X	plist[ix].x = floor(2.0*plist[ix].x + 0.5)/2.0;
X	plist[ix].y = floor(2.0*plist[ix].y + 0.5)/2.0;
X	plist[ix].z = floor(2.0*plist[ix].z + 0.5)/2.0;
X    };
X}
X
Xint collision(listflag)
X/* returns (in this priority)
X 1: out-of-field up;
X 2: ...down;
X 3: ...north;
X 4: ...south;
X 5: ...east;
X 6: ...west;
X -1 for cube overlap; 
X 0 for ok; 
X */
Xint listflag;
X{
X    register int ix;
X    cubep cubes[MAXCUBES];
X    point *pls;
X
X    if (listflag==0) pls = traplist;
X    else pls = templist;
X
X    for (ix=0; ix<pieces[curpiece].numcubes; ix++) {
X	cubes[ix].x = (int)(pls[ix].x+100.0) - 100;
X	cubes[ix].y = (int)(pls[ix].y+100.0) - 100;
X	cubes[ix].z = (int)(pls[ix].z+100.0) - 100;
X
X	if (cubes[ix].z < 0) return 2;
X	if (cubes[ix].z >= fieldz) return 1;
X	if (cubes[ix].y < 0) return 3;
X	if (cubes[ix].y >= fieldy) return 4;
X	if (cubes[ix].x >= fieldx) return 5;
X	if (cubes[ix].x < 0) return 6;
X    };
X    for (ix=0; ix<pieces[curpiece].numcubes; ix++) {
X	if (field[cubes[ix].x][cubes[ix].y][cubes[ix].z] & F_ON)
X	    return (-1);
X    };
X    return 0;
X}
X
Xvoid setup_cubies()
X{
X    register int ix, iy, iz;
X    double wcoord;
X
X    for (ix=0; ix<=fieldx; ix++)
X	for (iy=0; iy<=fieldy; iy++)
X	    for (iz=0; iz<=fieldz; iz++) {
X		wcoord = -((double)iz+fieldoffz)/focallen + 1.0;
X		fieldpts[ix][iy][iz].x = halfboard +
X		  (int)(boardscale*((double)ix+fieldoffx)/wcoord);
X		fieldpts[ix][iy][iz].y = halfboard +
X		  (int)(boardscale*((double)iy+fieldoffy)/wcoord);
X	    }
X
X    if (stereo) {
X	for (ix=0; ix<=fieldx; ix++)
X	    for (iy=0; iy<=fieldy; iy++)
X		for (iz=0; iz<=fieldz; iz++) {
X		    wcoord = -((double)iz+fieldoffz)/focallen + 1.0;
X		    fieldpts2[ix][iy][iz].x = halfboard2 +
X		      (int)(boardscale*((double)ix+fieldoffx2) / wcoord);
X		    fieldpts2[ix][iy][iz].y = halfboard +
X		      (int)(boardscale*((double)iy+fieldoffy) / wcoord);
X		}
X    }
X}
X
Xvoid add_cubie(cx, cy, cz)
Xint cx, cy, cz;
X{
X    add_one_cubie(fieldpts, cx, cy, cz);
X    if (stereo)
X	add_one_cubie(fieldpts2, cx, cy, cz);
X}
X
Xvoid add_one_cubie(fips, cx, cy, cz)
Xfieldplist fips;
Xint cx, cy, cz;
X{
X    int x1, y1, width, heigh;
X    XPoint face[5];
X    GC *gcc;
X
X    gcc = &(gccubes[colors[cz]]);
X    x1 = fips[cx][cy][cz+1].x;
X    y1 = fips[cx][cy][cz+1].y;
X    width = fips[cx+1][cy+1][cz+1].x - x1 + 1;
X    heigh = fips[cx+1][cy+1][cz+1].y - y1 + 1;
X    XFillRectangle(dpy, fieldpm, *gcc, x1, y1, width, heigh);
X    XDrawRectangle(dpy, fieldpm, gcwhite, x1, y1, width, heigh);
X
X    x1 = cx - fieldx/2;
X    if (x1<0) {
X	face[0].x = fips[cx+1][cy][cz+1].x;
X	face[0].y = fips[cx+1][cy][cz+1].y;
X	face[1].x = fips[cx+1][cy][cz].x;
X	face[1].y = fips[cx+1][cy][cz].y;
X	face[2].x = fips[cx+1][cy+1][cz].x;
X	face[2].y = fips[cx+1][cy+1][cz].y;
X	face[3].x = fips[cx+1][cy+1][cz+1].x;
X	face[3].y = fips[cx+1][cy+1][cz+1].y;
X	face[4].x = face[0].x;
X	face[4].y = face[0].y;
X	XFillPolygon(dpy, fieldpm, *gcc, face, 4,
X		     Convex, CoordModeOrigin);
X	XDrawLines(dpy, fieldpm, gcwhite, face, 5,
X		   CoordModeOrigin);
X    }
X    else if (x1>0) {
X	face[0].x = fips[cx][cy][cz+1].x;
X	face[0].y = fips[cx][cy][cz+1].y;
X	face[1].x = fips[cx][cy][cz].x;
X	face[1].y = fips[cx][cy][cz].y;
X	face[2].x = fips[cx][cy+1][cz].x;
X	face[2].y = fips[cx][cy+1][cz].y;
X	face[3].x = fips[cx][cy+1][cz+1].x;
X	face[3].y = fips[cx][cy+1][cz+1].y;
X	face[4].x = face[0].x;
X	face[4].y = face[0].y;
X	XFillPolygon(dpy, fieldpm, *gcc, face, 4,
X		     Convex, CoordModeOrigin);
X	XDrawLines(dpy, fieldpm, gcwhite, face, 5,
X		   CoordModeOrigin);
X    };
X
X    y1 = cy - fieldy/2;
X    if (y1>0) {
X	face[0].x = fips[cx][cy][cz+1].x;
X	face[0].y = fips[cx][cy][cz+1].y;
X	face[1].x = fips[cx][cy][cz].x;
X	face[1].y = fips[cx][cy][cz].y;
X	face[2].x = fips[cx+1][cy][cz].x;
X	face[2].y = fips[cx+1][cy][cz].y;
X	face[3].x = fips[cx+1][cy][cz+1].x;
X	face[3].y = fips[cx+1][cy][cz+1].y;
X	face[4].x = face[0].x;
X	face[4].y = face[0].y;
X	XFillPolygon(dpy, fieldpm, *gcc, face, 4,
X		     Convex, CoordModeOrigin);
X	XDrawLines(dpy, fieldpm, gcwhite, face, 5,
X		   CoordModeOrigin);
X    }
X    else if (y1<0) {
X	face[0].x = fips[cx][cy+1][cz+1].x;
X	face[0].y = fips[cx][cy+1][cz+1].y;
X	face[1].x = fips[cx][cy+1][cz].x;
X	face[1].y = fips[cx][cy+1][cz].y;
X	face[2].x = fips[cx+1][cy+1][cz].x;
X	face[2].y = fips[cx+1][cy+1][cz].y;
X	face[3].x = fips[cx+1][cy+1][cz+1].x;
X	face[3].y = fips[cx+1][cy+1][cz+1].y;
X	face[4].x = face[0].x;
X	face[4].y = face[0].y;
X	XFillPolygon(dpy, fieldpm, *gcc, face, 4,
X		     Convex, CoordModeOrigin);
X	XDrawLines(dpy, fieldpm, gcwhite, face, 5,
X		   CoordModeOrigin);
X    };
X}
X
Xvoid add_cubies(lev)
Xint lev;
X{
X    register int ix, iy, iz;
X
X    for (iz=lev; iz<fieldz; iz++) {
X	for (ix=0; ix<fieldx/2; ix++) {
X	    for (iy=0; iy<fieldy/2; iy++) {
X		if (field[ix][iy][iz] & F_ON) {
X		    add_cubie(ix, iy, iz);
X		}
X	    }
X	    for (iy=fieldy-1; iy>=fieldy/2; iy--) {		
X		if (field[ix][iy][iz] & F_ON) {
X		    add_cubie(ix, iy, iz);
X		}
X	    }
X	}
X	for (ix=fieldx-1; ix>=fieldx/2; ix--) {
X	    for (iy=0; iy<fieldy/2; iy++) {
X		if (field[ix][iy][iz] & F_ON) {
X		    add_cubie(ix, iy, iz);
X		}
X	    }
X	    for (iy=fieldy-1; iy>=fieldy/2; iy--) {
X		if (field[ix][iy][iz] & F_ON) {
X		    add_cubie(ix, iy, iz);
X		}
X	    }
X	}
X    };
X    if (meterlev != meteroldlev) {
X	update_meter();
X    }
X}
X
Xvoid redraw_cubies()
X{
X    register int ix, iy, iz;
X
X    for (iz=0; iz<fieldz; iz++) {
X	for (ix=0; ix<fieldx/2; ix++) {
X	    for (iy=0; iy<fieldy/2; iy++) {
X		if (field[ix][iy][iz] & F_ON) {
X		    add_cubie(ix, iy, iz);
X		}
X	    }
X	    for (iy=fieldy-1; iy>=fieldy/2; iy--) {		
X		if (field[ix][iy][iz] & F_ON) {
X		    add_cubie(ix, iy, iz);
X		}
X	    }
X	}
X	for (ix=fieldx-1; ix>=fieldx/2; ix--) {
X	    for (iy=0; iy<fieldy/2; iy++) {
X		if (field[ix][iy][iz] & F_ON) {
X		    add_cubie(ix, iy, iz);
X		}
X	    }
X	    for (iy=fieldy-1; iy>=fieldy/2; iy--) {
X		if (field[ix][iy][iz] & F_ON) {
X		    add_cubie(ix, iy, iz);
X		}
X	    }
X	}
X    }
X    if (meterlev != meteroldlev) {
X	update_meter();
X    }
X}
X
Xvoid plop_piece()
X{
X    register int ix, iy, iz;
X    int cubx, cuby, cubz;
X    int dirx, diry;
X    int lev = fieldz+1;
X
X    for (ix=0; ix<pieces[curpiece].numcubes; ix++) {
X	cubx = (int)(traplist[ix].x+100.0) - 100;
X	cuby = (int)(traplist[ix].y+100.0) - 100;
X	cubz = (int)(traplist[ix].z+100.0) - 100;
X	if (cubz < lev) lev = cubz;
X	if (cubz+1 > meterlev) meterlev = cubz+1;
X	field[cubx][cuby][cubz] |= F_ON;
X    };
X    add_cubies(lev);
X
X    /* settle */
X    while (1) {
X	int full;
X	for (iz=fieldz-1; iz>=0; iz--) {
X	    full=1;
X	    for (ix=0; full && (ix<fieldx); ix++) {
X		for (iy=0; full && (iy<fieldy); iy++) {
X		    if (!(field[ix][iy][iz] & F_ON)) full = 0;
X		}
X	    }
X	    if (full) break;
X	}
X	if (iz<0) break;
X	for (; iz<fieldz-1; iz++) 
X	    for (ix=0; ix<fieldx; ix++)
X		for (iy=0; iy<fieldy; iy++)
X		    field[ix][iy][iz] = field[ix][iy][iz+1];
X	for (ix=0; ix<fieldx; ix++)
X	    for (iy=0; iy<fieldy; iy++)
X		field[ix][iy][fieldz-1] = 0;
X	score += 20*fieldx*fieldy;
X	if (dropticks > 10) dropticks -= 6;
X	meterlev--;
X	setup_fieldpm();
X	redraw_cubies();
X    }
X}
X
Xvoid draw_curpiece(drw)
XDrawable drw;
X{
X    register int ix;
X    static point scoor[MAXVERTS];
X    static point scoor2[MAXVERTS];
X    static XSegment xpl[MAXEDGES*2];
X    double wcoord;
X    int poff = pieces[curpiece].numcubes;
X    int nume = pieces[curpiece].numedges;
X    edge *e = pieces[curpiece].edges;
X
X    shapex1 = dispx;
X    shapex2 = 0;
X    shapey1 = dispy;
X    shapey2 = 0;
X    for (ix=0; ix<pieces[curpiece].numverts; ix++) {
X	wcoord = -(traplist[ix+poff].z+fieldoffz)/focallen + 1.0;
X	scoor[ix].x = halfboard +
X	  (int)(boardscale*(traplist[ix+poff].x+fieldoffx)/wcoord);
X	scoor[ix].y = halfboard +
X	  (int)(boardscale*(traplist[ix+poff].y+fieldoffy)/wcoord);
X	if (shapex1>scoor[ix].x-1) shapex1=scoor[ix].x-1;
X	if (shapey1>scoor[ix].y-1) shapey1=scoor[ix].y-1;
X	if (shapex2<scoor[ix].x+1) shapex2=scoor[ix].x+1;
X	if (shapey2<scoor[ix].y+1) shapey2=scoor[ix].y+1;
X	if (stereo) {
X	    scoor2[ix].x = halfboard2 +
X	      (int)(boardscale*(traplist[ix+poff].x+fieldoffx2)
X		    / wcoord);
X	    if (shapex2<scoor2[ix].x+1) shapex2=scoor2[ix].x+1;
X	}
X    }
X
X    if (!stereo) {
X	for (ix=0; ix<nume; ix++) {
X	    xpl[ix].x1 = scoor[e[ix].head].x;
X	    xpl[ix].y1 = scoor[e[ix].head].y;
X	    xpl[ix].x2 = scoor[e[ix].tail].x;
X	    xpl[ix].y2 = scoor[e[ix].tail].y;
X	}
X	XDrawSegments(dpy, drw, gcline, xpl, nume);
X    }
X    else {
X	for (ix=0; ix<nume; ix++) {
X	    xpl[ix].x1 = scoor[e[ix].head].x;
X	    xpl[ix].y1 = scoor[e[ix].head].y;
X	    xpl[ix].x2 = scoor[e[ix].tail].x;
X	    xpl[ix].y2 = scoor[e[ix].tail].y;
X	    xpl[nume+ix].x1 = scoor2[e[ix].head].x;
X	    xpl[nume+ix].y1 = xpl[ix].y1;
X	    xpl[nume+ix].x2 = scoor2[e[ix].tail].x;
X	    xpl[nume+ix].y2 = xpl[ix].y2;
X	}
X	XDrawSegments(dpy, drw, gcline, xpl, 2*nume);
X    }
X}
END_OF_FILE
if test 12975 -ne `wc -c <'spatial/rots.c'`; then
    echo shar: \"'spatial/rots.c'\" unpacked with wrong size!
fi
# end of 'spatial/rots.c'
fi
if test ! -d 'spheral' ; then
    echo shar: Creating directory \"'spheral'\"
    mkdir 'spheral'
fi
if test -f 'spheral/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/Makefile'\"
else
echo shar: Extracting \"'spheral/Makefile'\" \(1471 characters\)
sed "s/^X//" >'spheral/Makefile' <<'END_OF_FILE'
X# The next lines define the directories where the executable, piece file,
X# and score file are installed. Change them to whatever is appropriate.
XDESTDIR = /tmp/dest
XDESTLIBDIR = $(DESTDIR)/lib
XDESTBINDIR = $(DESTDIR)/bin
XDESTMANDIR = $(DESTDIR)/man
X
XSCOREFILE = $(DESTLIBDIR)/spheral.sco
XPIECEFILE = $(DESTLIBDIR)/spheral.shp
X
XDEFINES =
X
X# uncomment the next line if your system doesn't have
X# random() and srandom()
X#DEFINES = -Drandom=lrand48 -Dsrandom=srand48
X
X# uncomment the next line for Solaris, which has neither
X# flock() nor random().
X#DEFINES = -DUSELOCKF -Drandom=lrand48 -Dsrandom=srand48
X
XINCLUDES = -I/usr/local/include
XXLIBS = -L/usr/local/lib -lX11
X
XOBJS = spheral.o disp.o game.o rots.o intro.o   \
X   deco.o score.o gcgrey.o errdi.o
X
XCFLAGS= -O $(DEFINES) $(INCLUDES)  \
X   -DSCOREFILENAME=\"$(SCOREFILE)\"  \
X   -DPIECEFILENAME=\"$(PIECEFILE)\"
X
Xall: spheral
X
Xspheral: $(OBJS)
X	$(CC) $(CFLAGS) $(OBJS) -o spheral $(XLIBS) -lm 
X
Xspheral.o: spheral.c spheral.h
Xdisp.o: disp.c spheral.h
Xgame.o: game.c spheral.h
Xrots.o: rots.c spheral.h
Xintro.o: intro.c spheral.h
Xdeco.o: deco.c spheral.h
Xgcgrey.o: gcgrey.c spheral.h
Xerrdi.o: errdi.c spheral.h
Xscore.o: score.c spheral.h
X
Xtargetdirs:
X	-mkdir $(DESTLIBDIR)
X	-mkdir $(DESTBINDIR)
X	-mkdir $(DESTMANDIR)
X	-mkdir $(DESTMANDIR)/man6
X
Xinstall: spheral  targetdirs
X	install -c -s spheral $(DESTBINDIR)
X	install -c spheral.shp  $(PIECEFILE)
X	install -c spheral.6 $(DESTMANDIR)/man6
X
Xclean: 
X	rm -f *.o spheral
X
END_OF_FILE
if test 1471 -ne `wc -c <'spheral/Makefile'`; then
    echo shar: \"'spheral/Makefile'\" unpacked with wrong size!
fi
# end of 'spheral/Makefile'
fi
if test -f 'spheral/intro.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/intro.c'\"
else
echo shar: Extracting \"'spheral/intro.c'\" \(5768 characters\)
sed "s/^X//" >'spheral/intro.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <sys/time.h>
X#include <X11/Xlib.h>
X#include <X11/keysym.h>
X#include "spheral.h"
X
X#define TICKLENGTH (50000)
X#define xputs(x, y, str)  \
XXDrawImageString(dpy, win, gcwhite, x, y, str, strlen(str))
X#define xline(x1, y1, x2, y2)  \
XXDrawLine(dpy, win, gcwhite, x1, y1, x2, y2) 
X#define xlineo(x1, y1, x2, y2)  \
XXDrawLine(dpy, win, gcocto, x1, y1, x2, y2) 
X
Xextern gamer hscores[NUMGAMERS];
Xextern GC gcblack, gcwhite, gccopy, gcline, gcfield, gcocto; 
Xextern int errdiflag;
X
Xextern void intro_redraw(), redo_board_globals();
X
Xvoid initintro()
X{
X    intro_redraw();
X}
X
Xvoid introloop()
X{
X    short status, res;
X    Bool eventp;
X    XEvent event, nextevent;
X    long evmasks;
X    char key;
X    KeySym ksym;
X    long lasttime;
X    struct timeval tv;
X    fd_set readbits;
X
X    while (1) {
X	tv.tv_sec = 0;
X	tv.tv_usec = TICKLENGTH;
X	FD_ZERO(&readbits);
X	FD_SET(ConnectionNumber(dpy), &readbits);
X	(void)select(1+ConnectionNumber(dpy), &readbits, 0, 0, &tv);
X
X	evmasks = (KeyPressMask | ExposureMask
X		   | StructureNotifyMask);
X	eventp = XCheckWindowEvent(dpy, win, evmasks, &event);
X	if (eventp) switch (event.type) {
X	    case Expose:
X		eventp = XCheckWindowEvent(dpy, win,
X			evmasks, &nextevent);
X		while (eventp && nextevent.type == Expose) {
X		    eventp = XCheckWindowEvent(dpy, win,
X			evmasks, &nextevent);
X		};
X		if (eventp) {
X		    XPutBackEvent(dpy, &nextevent);
X		};
X		intro_redraw();
X		break;
X	    case KeyPress:
X		XLookupString(&event, &key, 1, &ksym, NULL);
X		/*printf("got '%s'\n", XKeysymToString(ksym));*/
X		switch (ksym) {
X		    case XK_q:
X		    case XK_Q:
X			exit(0);
X			break;
X		    case XK_c:
X		    case XK_C:
X			errdiflag = !errdiflag;
X			intro_redraw();
X			break;
X		    case XK_s:
X		    case XK_S:
X			return;
X		};
X		break;
X	    case ConfigureNotify:
X		if (event.xconfigure.width != dispx
X		    || event.xconfigure.height != dispy) {
X		    dispx = event.xconfigure.width;
X		    dispy = event.xconfigure.height;
X		    redo_board_globals();
X		    XFreePixmap(dpy, backpm);
X		    XFreePixmap(dpy, fieldpm);
X		    backpm = XCreatePixmap(dpy, win, dispx,
X			dispy, scndepth);   
X		    fieldpm = XCreatePixmap(dpy, win, dispx,
X			dispy, scndepth);   
X		}
X		break;
X	}
X    }
X}
X
Xvoid intro_redraw()
X{
X    register int ix;
X    char buf[255];
X
X    XFillRectangle(dpy, win, gcblack, 0, 0, dispx, dispy);
X    xputs(50, 50, "Spheral");
X    xputs(50, 100, "A Sadistic Software Production");
X    xputs(50, 120, "(C) Copyright 1991-3 Andrew Plotkin");
X    xputs(50, 140, " (ap1i@andrew.cmu.edu)");
X    if (score!=(-1)) {
X	sprintf(buf, "Your score: %d", score);
X	xputs(50, 160, buf);
X    }
X
X    xputs(50, 180, "Commands:");
X    xputs(70, 200, "s: start game");
X    xputs(70, 220, "Escape: pause");
X    if (!errdiflag)
X	xputs(70, 240, "c: change display mode (now boring)");
X    else
X	xputs(70, 240, "c: change display mode (now neato)");
X    xputs(70, 260, "Q: quit program");
X
X    xputs(350, 150, "High Scores:");
X    for (ix=0; ix<NUMGAMERS; ix++) {
X	xputs(390, 170+20*ix, hscores[ix].name);
X	xputs(490, 170+20*ix, hscores[ix].userid);
X	xputs(590, 170+20*ix, hscores[ix].scoret);
X    };
X
X    xline(50, 320, 190, 320);
X    xline(90, 290, 165, 360);
X    xline(75, 360, 150, 290);
X    xputs(64, 325, "4j");
X    xputs(163, 325, "6l");
X    xputs(96, 304, "7u");
X    xputs(135, 304, "9o");
X    xputs(84, 346, "1m");
X    xputs(145, 346, "3.");
X
X    xline(70, 385, 170, 385);
X    xline(75, 385, 70, 390);
X    xline(75, 385, 70, 380);
X    xline(165, 385, 170, 390);
X    xline(165, 385, 170, 380);
X    xputs(111, 390, " v ");
X
X    XDrawArc(dpy, win, gcfield, 50, 410, 140, 140, 0, 23040);
X
X    XDrawArc(dpy, win, gcfield, 50, 470, 140, 20, 0, 23040);
X    XDrawArc(dpy, win, gcfield, 50, 469, 140, 22, 11520, 11520);
X
X    XDrawArc(dpy, win, gcwhite, 50, 480, 140, 20, 18000, 2880);
X    XDrawArc(dpy, win, gcwhite, 50, 480, 140, 20, 13680, 2880);
X    XDrawArc(dpy, win, gcwhite, 50, 482, 140, 20, 18000, 2880);
X    XDrawArc(dpy, win, gcwhite, 50, 482, 140, 20, 13680, 2880);
X    xline(59, 496, 65, 502);
X    xline(59, 496, 65, 492);
X    xline(181, 496, 175, 502);
X    xline(181, 496, 175, 492);
X
X    XDrawArc(dpy, win, gcfield, 70, 410, 100, 140, 0, 23040);
X    XDrawArc(dpy, win, gcfield, 69, 410, 102, 140, 5760, 11520);
X    XDrawArc(dpy, win, gcfield, 69, 410, 102, 140, 17280, 11520);
X
X    XDrawArc(dpy, win, gcwhite, 110, 410, 100, 140, 18720, 2880);
X    XDrawArc(dpy, win, gcwhite, 110, 410, 100, 140, 1440, 2880);
X    XDrawArc(dpy, win, gcwhite, 114, 410, 92, 140, 18720, 2880);
X    XDrawArc(dpy, win, gcwhite, 114, 410, 92, 140, 1440, 2880);
X    xline(177, 415, 190, 420);
X    xline(177, 415, 180, 420);
X    xline(177, 545, 190, 540);
X    xline(177, 545, 180, 540);
X
X    XDrawArc(dpy, win, gcwhite, 30, 410, 100, 140, 12960, 2880);
X    XDrawArc(dpy, win, gcwhite, 30, 410, 100, 140, 7200, 2880);
X    XDrawArc(dpy, win, gcwhite, 34, 410, 92, 140, 12960, 2880);
X    XDrawArc(dpy, win, gcwhite, 34, 410, 92, 140, 7200, 2880);
X    xline(63, 415, 50, 420);
X    xline(63, 415, 60, 420);
X    xline(63, 545, 50, 540);
X    xline(63, 545, 60, 540);
X
X    XDrawArc(dpy, win, gcfield, 90, 410, 60, 140, 0, 23040);
X
X    xlineo(70, 486, 90, 472);
X    xlineo(72, 486, 168, 486);
X    xlineo(90, 472, 150, 472);
X    xlineo(168, 486, 150, 472);
X
X    xputs(112, 504, "s g");
X    xputs(32, 500, "d");
X    xputs(32, 468, "r");
X    xputs(204, 500, "f");
X    xputs(204, 468, "e");
X
X    /*xlineo(120, 410, 70, 486);
X    xlineo(120, 410, 90, 472);
X    xlineo(120, 410, 150, 472);
X    xlineo(120, 410, 168, 486);
X    xlineo(120, 550, 70, 486);
X    xlineo(120, 550, 90, 472);
X    xlineo(120, 550, 150, 472);
X    xlineo(120, 550, 168, 486);*/
X}
END_OF_FILE
if test 5768 -ne `wc -c <'spheral/intro.c'`; then
    echo shar: \"'spheral/intro.c'\" unpacked with wrong size!
fi
# end of 'spheral/intro.c'
fi
if test -f 'spheral/rots.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/rots.c'\"
else
echo shar: Extracting \"'spheral/rots.c'\" \(11934 characters\)
sed "s/^X//" >'spheral/rots.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <math.h>    
X#include <X11/Xlib.h>
X#include "spheral.h"
X
Xtypedef struct _ballp {
X    int x, y, z;
X} ballp;
X
Xpoint plist[MAXBALLS];	    
Xpoint traplist[MAXBALLS];   
Xpoint templist[MAXBALLS];   
Xint aspectflag = 0;
Xdouble aspect;
Xdouble offx, offy, offz;
Xdouble focallen, boardscale;
Xint halfboardx, halfboardy;
Xfieldplist fieldpts;
Xfieldrlist fieldrads;
X
Xint colors[12] = {1, 3, 7, 15, 1, 3, 7, 15, 1, 3, 7, 15};
X
Xextern GC gcwhite, gcblack, gcfield, gcadd,
Xgccopy, gcballs[];
Xextern Pixmap ballpm[NUMBALLSIZES][NUMSHADES];
Xextern short ballpmflag[NUMBALLSIZES][NUMSHADES];
Xextern int errdiflag; 
X
Xextern void updatepiece(), round_piece(), measure_curpiece(),
Xrotate_axis();
Xextern void create_ballpm();
X
Xvoid startpiece()
X{
X    register int ix;
X    int res;
X    piecelist *p;
X    int flix = (random() % 2)*2-1;
X    int fliy = (random() % 2)*2-1;
X    int fliz = (random() % 2)*2-1;
X
X    curpiece = random() % numpieces;
X
X    p = &(pieces[curpiece]);
X    for (ix=0; ix<p->numballs; ix++) {
X	plist[ix].x = flix*p->points[ix].x;
X	plist[ix].y = fliy*p->points[ix].y;
X	plist[ix].z = fliz*p->points[ix].z;
X	plist[ix].w = p->points[ix].w;
X	traplist[ix].w = plist[ix].w;
X    };
X    {
X	int initx = fieldx/4;
X	int inity = initx;
X	int initz = fieldz+4;
X	offz = ((double)initz) - 0.5*inity - 0.5;
X	offy = ROOTHALF*((double)inity);
X	offx = ((double)initx) + 0.5*inity + 0.5;
X    }
X    updatepiece();
X
X    res = collision(0);
X    while (res!=OUT_NOT && res!=OUT_COLLIDE) {
X	switch (res) {
X	    case OUT_UP:
X		offz = offz - 1.0 ;
X		break;
X	    case OUT_DOWN:
X		fprintf(stderr,
X			"spheral: piece too long for board\n");
X		exit(-1);
X		break;
X	    case OUT_NORTHEAST:
X		offx = offx - 0.5;
X		offy = offy - ROOTHALF;
X		offz = offz + 0.5;
X		break;
X	    case OUT_SOUTH:
X		offx = offx + 0.5;
X		offy = offy + ROOTHALF;
X		offz = offz - 0.5;
X		break;
X	    case OUT_NORTHWEST:
X		offx = offx + 1.0;
X		break;
X	}
X	updatepiece();
X	res = collision(0);
X    };
X    if (res==(OUT_COLLIDE)) curpiece = (-2);
X}
X
Xvoid rotate_piece(pls, axis, theta)
X/* works on plist */
Xpoint pls[];
Xint axis;   /* 4-axis system */
Xdouble theta;
X{
X#define PHI (0.7853981634)
X    switch (axis) {
X	case 1:
X	    rotate_axis(pls, 2, theta);
X	    break;
X	case 2:
X	    rotate_axis(pls, 2, PHI);
X	    rotate_axis(pls, 1, theta);
X	    rotate_axis(pls, 2, -PHI);
X	    break;
X	case 3:
X	case 4:
X	    rotate_axis(pls, 2, -PHI);
X	    rotate_axis(pls, 1, -theta);
X	    rotate_axis(pls, 2, PHI);
X	    break;
X    }
X}
X
Xvoid reverse_piece(pls, axis)
Xpoint pls[];
Xint axis;
X{
X    register int ix;
X
X    switch (axis) {
X	case -1:
X	    for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X		pls[ix].x = (-pls[ix].x);
X	    }
X	    break;
X    }
X}
X
Xvoid rotate_axis(pls, axis, theta)
Xpoint pls[];
Xint axis;   /* 3-axis system */
Xdouble theta;
X{
X    register int ix;
X    double t1, t2;
X    double sinth = sin(theta);
X    double costh = cos(theta);
X
X    switch (axis) {
X	case 1:
X	    for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X		t1 = pls[ix].y;
X		t2 = pls[ix].z;
X		pls[ix].y = costh*t1 - sinth*t2;
X		pls[ix].z = sinth*t1 + costh*t2;
X	    }
X	    break;
X	case 2:
X	    for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X		t1 = pls[ix].x;
X		t2 = pls[ix].z;
X		pls[ix].x = costh*t1 - sinth*t2;
X		pls[ix].z = sinth*t1 + costh*t2;
X	    }
X	    break;
X	case 3:
X	    for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X		t1 = pls[ix].x;
X		t2 = pls[ix].y;
X		pls[ix].x = costh*t1 - sinth*t2;
X		pls[ix].y = sinth*t1 + costh*t2;
X	    }
X	    break;
X    }
X}
X
Xvoid updatepiece()
X/* create traplist from plist+offsets */
X{
X    register int ix;
X
X    if (!aspectflag) {
X	for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X	    traplist[ix].x = plist[ix].x + offx;
X	    traplist[ix].y = plist[ix].y + offy;
X	    traplist[ix].z = plist[ix].z + offz;
X	};
X    }
X    else {
X	for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X	    traplist[ix].x = aspect*plist[ix].x + offx;
X	    traplist[ix].y = plist[ix].y + offy;
X	    traplist[ix].z = plist[ix].z + offz;
X	};
X    }
X}
X
Xvoid updatetemp_tra(xa, ya, za, taxi, tdir)
X/* create templist from traplist, adding (whole)
X moves and turns */
Xdouble xa, ya, za;
Xint taxi; /* positive for rotation;
X negative for reflection */
Xint tdir;
X{
X    register int ix;
X
X    if (taxi==0) {
X	for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X	    templist[ix].x = traplist[ix].x + xa;
X	    templist[ix].y = traplist[ix].y + ya;
X	    templist[ix].z = traplist[ix].z + za;
X	};
X    }
X    else if (taxi<0) {
X	switch (taxi) {
X	    case -1:
X		for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X		    templist[ix].x = -plist[ix].x;
X		    templist[ix].y = plist[ix].y;
X		    templist[ix].z = plist[ix].z;
X		};
X		for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X		    templist[ix].x += offx + xa;
X		    templist[ix].y += offy + ya;
X		    templist[ix].z += offz + za;
X		};		
X		break;
X	}
X    }
X    else {
X	for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X	    templist[ix].x = plist[ix].x;
X	    templist[ix].y = plist[ix].y;
X	    templist[ix].z = plist[ix].z;
X	};
X	rotate_piece(templist, taxi, ((double)(tdir))*PI/2.0);
X	for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X	    templist[ix].x += offx + xa;
X	    templist[ix].y += offy + ya;
X	    templist[ix].z += offz + za;
X	};
X    }
X}
X
Xvoid round_piece() /* round off piece (plist) to grid */
X{
X    register int ix;
X
X    offx = floor(offx*2.0 + 0.5) / 2.0;
X    offy = floor(offy/(0.5*ROOTHALF) + 0.5) * (0.5*ROOTHALF);
X    offz = floor(offz*2.0 + 0.5) / 2.0;
X
X    for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X	plist[ix].x = floor(2.0*plist[ix].x + 0.5)/2.0;
X	plist[ix].y = floor(plist[ix].y/(0.5*ROOTHALF) + 0.5) * (0.5*ROOTHALF);
X	plist[ix].z = floor(2.0*plist[ix].z + 0.5)/2.0;
X    };
X}
X
Xint collision(listflag)
X/* Check a list for collision. Check traplist if
X listflag=0, templist if listflag=1.
X Returns (in this priority)
X 1: out-of-field up;
X 2: ...down;
X 3: ...northeast;
X 4: ...south;
X 6: ...northwest;
X -1 for ball overlap; 
X 0 for ok; 
X */
Xint listflag;
X{
X    register int ix;
X    static ballp balls[MAXBALLS];
X    point *pls;
X
X    if (listflag==0) pls = traplist;
X    else pls = templist;
X
X    for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X	balls[ix].y = (int)(pls[ix].y/ROOTHALF+100.5) - 100;
X	balls[ix].z = (int)(pls[ix].z+0.5*balls[ix].y+100.5) - 100;
X	balls[ix].x = (int)(pls[ix].x-0.5*balls[ix].y+100.5) - 100;
X	/*printf("%.3f, %.3f, %.3f == %d, %d, %d\n", pls[ix].x,
X	 pls[ix].y, pls[ix].z, balls[ix].x, balls[ix].y, balls[ix].z);*/
X
X	if (balls[ix].z < 0) return OUT_DOWN;
X	if (balls[ix].z >= fieldz) return OUT_UP;
X	if (balls[ix].y < 0) return OUT_SOUTH;
X	if (balls[ix].y >= fieldx-balls[ix].x) return OUT_NORTHEAST;
X	if (balls[ix].x < 0) return OUT_NORTHWEST;
X    };
X    for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X	if (field[balls[ix].x][balls[ix].y][balls[ix].z] & F_ON)
X	    return (OUT_COLLIDE);
X    };
X
X    return OUT_NOT;
X}
X
Xvoid setup_fieldpts() /* just that */
X{
X    register int ix, iy, iz;
X    double xc, yc, zc, wcoord;
X
X    if (errdiflag) {
X	XClearWindow(dpy, win);
X	XDrawImageString(dpy, win, gcwhite, 50, 50,
X	"Please wait about 15 seconds; computing pixmaps",
X	strlen("Please wait about 15 seconds; computing pixmaps"));
X    }
X
X    for (iz=0; iz<fieldz; iz++)
X	for (ix=0; ix<fieldx; ix++)
X	    for (iy=0; iy<fieldx-ix; iy++) {
X		zc = (double)iz - 0.5*iy;
X		yc = ROOTHALF*iy;
X		xc = (double)ix + 0.5*iy;
X
X		wcoord = -(zc+fieldoffz)/focallen + 1.0;
X		fieldpts[ix][iy][iz].x = halfboardx +
X		  (int)(boardscale*(xc+fieldoffx)/wcoord);
X		fieldpts[ix][iy][iz].y = halfboardy -
X		  (int)(boardscale*(yc+fieldoffy)/wcoord);
X		fieldrads[ix][iy][iz] = (int)(0.5*boardscale/wcoord);
X
X		if (errdiflag &&
X		    !ballpmflag[fieldrads[ix][iy][iz]][iz%NUMSHADES]) {
X		    create_ballpm(fieldrads[ix][iy][iz], iz%NUMSHADES);
X		}
X	    }
X    
X}
X
Xvoid add_ball(cx, cy, cz) /* draw a ball on fieldpm */
Xint cx, cy, cz;
X{
X    int rad = fieldrads[cx][cy][cz];
X    int x1 = fieldpts[cx][cy][cz].x;
X    int y1 = fieldpts[cx][cy][cz].y;
X
X    if (!errdiflag) {
X	GC gcball, gcrim;
X
X	if (monomode) {
X	    gcball = (gcballs[colors[cz]]);
X	    gcrim = (colors[cz]<8) ? (gcfield) : (gcwhite);
X	}
X	else {
X	    gcball = (gcballs[cz]);
X	    gcrim = (gcwhite);
X	}
X
X	XFillArc(dpy, fieldpm, gcball, x1-rad, y1-rad,
X		 rad*2, rad*2, 0, 23040); 
X	/*XFillArc(dpy, fieldpm, gcspot, fieldpts[cx][cy][cz].x,
X	 fieldpts[cx][cy][cz].y, rad*2/3, rad*2/3, 0, 23040); */
X	XDrawArc(dpy, fieldpm, gcrim, x1-rad, y1-rad,
X		 rad*2, rad*2, 0, 23040); 
X    }
X    else {
X	if (!ballpmflag[rad][cz%NUMSHADES]) {
X	    fprintf(stderr,
X		    "spheral: missing ball pixmap (%d, %d)\n",
X		    rad, cz%NUMSHADES);
X	    exit(-1);
X	}
X	XFillArc(dpy, fieldpm, gcblack, x1-rad, y1-rad,
X		rad*2, rad*2, 0, 23040); 
X	XCopyArea(dpy, ballpm[rad][cz%NUMSHADES], fieldpm,
X		gcadd, 0, 0, rad*2, rad*2, x1-rad, y1-rad);
X    }
X}
X
Xvoid add_balls(lev)
X/* add balls to fieldpm. lev is the smallest z-coord affected */
Xint lev;
X{
X    register int ix, iy, iz;
X    int div;
X
X    for (iz=lev; iz<fieldz; iz++) 
X	for (iy=fieldx-1; iy>=0; iy--) {
X	    div = (fieldx-iy)/2;
X	    for (ix=0; ix<div; ix++) {
X		if (field[ix][iy][iz] & F_ON) {
X		    add_ball(ix, iy, iz);
X		}
X	    }
X	    for (ix=(fieldx-iy-1); ix>=div; ix--) {		
X		if (field[ix][iy][iz] & F_ON) {
X		    add_ball(ix, iy, iz);
X		}
X	    }
X
X	}
X}
X
Xvoid plop_piece() /* plop traplist onto fieldpm. */
X{
X    register int ix, iy, iz;
X    int cubx, cuby, cubz;
X    int dirx, diry;
X    int lev = fieldz+1;
X    int full;
X
X    for (ix=0; ix<pieces[curpiece].numballs; ix++) {
X	cuby = (int)(traplist[ix].y/ROOTHALF+100.5) - 100;
X	cubz = (int)(traplist[ix].z+0.5*cuby+100.5) - 100;
X	cubx = (int)(traplist[ix].x-0.5*cuby+100.5) - 100;
X	if (cubz < lev) lev = cubz;
X	/*if (cubz+1 > meterlev) meterlev = cubz+1;*/
X	field[cubx][cuby][cubz] |= F_ON;
X    };
X    add_balls(lev);
X
X    /* check settling */
X    while (1) {
X	for (iz=fieldz-1; iz>=0; iz--) {
X	    full=1;
X	    for (ix=0; full && (ix<fieldx); ix++) {
X		for (iy=0; full && (iy<fieldx-ix); iy++) {
X		    if (!(field[ix][iy][iz] & F_ON)) full = 0;
X		}
X	    }
X	    if (full) break;
X	}
X	if (iz<0) break;
X	for (; iz<fieldz-1; iz++) 
X	    for (ix=0; ix<fieldx; ix++)
X		for (iy=0; iy<fieldx-ix; iy++)
X		    field[ix][iy][iz] = field[ix][iy][iz+1];
X	for (ix=0; ix<fieldx; ix++)
X	    for (iy=0; iy<fieldx-ix; iy++)
X		field[ix][iy][fieldz-1] = 0;
X	score += 15*fieldx*fieldx;
X	if (dropticks > 10) dropticks -= 6;
X	/*meterlev--;*/
X	setup_fieldpm();
X	add_balls(0);
X    }
X}
X
Xvoid measure_curpiece(psum)
X/* locate balls (from traplist) in screen coords */
Xpiecesum *psum;
X{
X    register int ix, jx;
X    int numballs;
X    double wcoord;
X    double dist[MAXBALLS], lowdist;
X    short arr[MAXBALLS], lowval, temp;
X
X    numballs = pieces[curpiece].numballs;
X    psum->numballs = numballs;
X
X    if (!aspectflag) {
X	psum->scalex = 1.0;
X	psum->scaley = 1.0;
X    }
X    else {
X	psum->scalex = aspect;
X	psum->scaley = 1.0;
X    }
X
X    for (ix=0; ix<numballs; ix++) {
X	arr[ix] = ix;
X	dist[ix] = (traplist[ix].z+fieldoffz)*(traplist[ix].z+fieldoffz) +
X	  (traplist[ix].x+fieldoffx)*(traplist[ix].x+fieldoffx) +
X	  (traplist[ix].y+fieldoffy)*(traplist[ix].y+fieldoffy);
X	/*printf("%.3f, %.3f, %.3f = %.3f\n",
X	 (traplist[ix].z+fieldoffz), */
X    };
X    
X    for (ix=0; ix<numballs-1; ix++) {
X	lowdist = dist[arr[ix]];
X	lowval = ix;
X	for (jx=ix+1; jx<numballs; jx++) {
X	    if (dist[arr[jx]] > lowdist) {
X		lowdist = dist[arr[jx]];
X		lowval = jx;
X	    };
X	};
X	if (ix!=lowval) {
X	    temp = arr[ix];
X	    arr[ix] = arr[lowval];
X	    arr[lowval] = temp;
X	}
X    }
X
X    for (ix=0; ix<numballs; ix++) {
X	jx = arr[ix];
X	wcoord = -(traplist[jx].z+fieldoffz)/focallen + 1.0;
X	psum->p[ix].x = halfboardx +
X	  (int)(boardscale*(traplist[jx].x+fieldoffx)/wcoord);
X	psum->p[ix].y = halfboardy -
X	  (int)(boardscale*(traplist[jx].y+fieldoffy)/wcoord);	
X	psum->rad[ix] = (int)(0.5*boardscale/wcoord);
X    };
X}
X
END_OF_FILE
if test 11934 -ne `wc -c <'spheral/rots.c'`; then
    echo shar: \"'spheral/rots.c'\" unpacked with wrong size!
fi
# end of 'spheral/rots.c'
fi
echo shar: End of archive 1 \(of 4\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
