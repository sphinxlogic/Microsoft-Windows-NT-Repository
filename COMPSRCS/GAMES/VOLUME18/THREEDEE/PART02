Path: uunet!news.tek.com!news.cna.tek.com!not-for-mail
From: billr@saab.cna.tek.com (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i057:  threedee - two 3d tetris games for X, Part02/04
Date: 30 Aug 1993 08:34:59 -0700
Organization: Tektronix, Inc., Redmond, OR
Lines: 2982
Approved: billr@saab.CNA.TEK.COM
Message-ID: <25t6n3$fm4@saab.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1857

Submitted-by: "Andrew C. Plotkin" <ap1i+@andrew.cmu.edu>
Posting-number: Volume 18, Issue 57
Archive-name: threedee/part02
Environment: X11, Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 4)."
# Contents:  spatial/game.c spatial/intro.c spatial/spatial.shp
#   spheral/disp.c spheral/game.c spheral/patchlevel.h spheral/score.c
#   spheral/spheral.6
# Wrapped by billr@saab on Mon Aug 30 08:05:07 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'spatial/game.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/game.c'\"
else
echo shar: Extracting \"'spatial/game.c'\" \(8859 characters\)
sed "s/^X//" >'spatial/game.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <sys/time.h>
X#include <X11/Xlib.h>
X#include <X11/keysym.h>
X#include "spatial.h"
X
X#define TICKLENGTH (25000)
X#define GLIDELENGTH (8)
X#define TURNLENGTH (8)
X#define PLUMLENGTH (3)
X#define FALLLENGTH (8)
X#define PI (3.141593)
X
Xint stereo;
X
Xint meterx, meterx2, metery, metersize, meterlev, meteroldlev,
Xmeter_f_b, meter_b_d; /* oldlev is level on fieldpm */
X
Xunsigned char field[MAXFIELDXY][MAXFIELDXY][MAXFIELDZ];
Xshort fieldx, fieldy, fieldz;
Xdouble fieldoffx, fieldoffx2, fieldoffy, fieldoffz;
Xextern double offx, offy, offz;
Xlong score=(-1), dropticks;
X
Xextern void plop_piece(), setup_cubies(), redo_board_globals();
Xextern void setup_fieldpm(), clearfield(),
Xback_to_disp(), setup_backpm();
Xextern void startpiece(), rotate_piece(),
Xupdatetemp_tra(), updatepiece(), round_piece();
Xextern void pauseloop();
Xextern int collision();
X
Xvoid clearfield()
X{
X    int ix, iy, iz;
X    for (ix=0; ix<fieldx; ix++)
X	for (iy=0; iy<fieldy; iy++)
X	    for (iz=0; iz<fieldz; iz++) 
X		field[ix][iy][iz] = 0;
X}
X
Xvoid initgame()
X{
X    curpiece = -1;
X    score = 0;
X    dropticks = 80;
X    meterlev = 0;
X    clearfield();
X    setup_cubies();
X    setup_fieldpm();
X}
X
Xvoid gameloop()
X{
X#define ST_STILL (0)
X#define ST_FALL (1)
X#define ST_TURN (2)
X#define ST_GLIDE (3)
X#define ST_PLUMMET (4)
X#define ST_SPACEHIT (5)
X#define ST_PAUSE (6)
X
X    short status, res, aighhmode=0;
X    short droptimer=0, stattick;
X    Bool eventp;
X    XEvent event, nextevent;
X    long evmasks;
X    char key;
X    KeySym ksym;
X    long lasttime;
X    int toffx, toffy, toffz;
X    int taxis; /* 1=x, 2=y, 3=z */
X    int tdir;
X    struct timeval tv;
X    fd_set readbits;
X    int gotit;
X
X    status = ST_PAUSE;
X    /*lasttime = current_usec();*/
X
X    while (1) {
X	if (curpiece==(-1)) {
X	    startpiece();
X	    if (curpiece==(-2)) break;
X	    setup_backpm();
X	    draw_score(backpm);
X	    draw_score(win);
X	    back_to_disp(0);
X	    droptimer = 0;
X
X	    do {
X		eventp = XCheckWindowEvent(dpy,
X			win, KeyPressMask, &event);
X	    }
X	    while (eventp);
X	};
X
X	XFlush(dpy);
X
X	tv.tv_sec = 0;
X	tv.tv_usec = TICKLENGTH;
X	FD_ZERO(&readbits);
X	FD_SET(ConnectionNumber(dpy), &readbits);
X	(void)select(1+ConnectionNumber(dpy), &readbits, 0, 0, &tv);
X
X	if (status == ST_STILL)
X	    evmasks = (KeyPressMask | ExposureMask |
X		       StructureNotifyMask);
X	else
X	    evmasks = (ExposureMask | StructureNotifyMask);
X
X	if (eventp = XCheckWindowEvent(dpy, win, evmasks, &event))
X	  switch (event.type) {
X	    case Expose:
X		do {
X		    gotit = XCheckWindowEvent(dpy, win,
X			ExposureMask, &nextevent);
X		} while (gotit);
X		back_to_disp(1);
X		break;
X	    case KeyPress:
X		XLookupString(&event, &key, 1, &ksym, NULL);
X		switch (ksym) {
X		    case XK_Q:
X		    case XK_q:
X			return;
X			break;
X		    case XK_Escape:
X			pauseloop();
X			setup_fieldpm();
X			redraw_cubies();   
X			setup_backpm();
X			draw_score(backpm);
X			draw_score(win);
X			back_to_disp(1);		    
X			break;
X		    case XK_asciitilde:
X			aighhmode = (!aighhmode);
X			break;
X		    case XK_h:
X		    case XK_j:
X		    case XK_k:
X		    case XK_l:
X		    case XK_i:
X		    case XK_m:
X			if (status != ST_STILL) break;
X			if (ksym==XK_i || ksym==XK_m) taxis=1;
X			if (ksym==XK_h || ksym==XK_l) taxis=2;
X			if (ksym==XK_j || ksym==XK_k) taxis=3;
X			if (ksym==XK_i || ksym==XK_h || ksym==XK_k)
X			    tdir=1;
X			else tdir=(-1);
X			toffx = 0;
X			toffy = 0;
X			toffz = 0;
X			updatetemp_tra(toffx, toffy, toffz, taxis,
X				       tdir);
X			res = collision(1);
X			while (res==1 || (res>=3 && res <=6)) {
X			    switch (res) {
X				case 1:
X				    toffz--;
X				    break;
X				case 3:
X				    toffy++;
X				    break;
X				case 4:
X				    toffy--;
X				    break;
X				case 5:
X				    toffx--;
X				    break;
X				case 6:
X				    toffx++;
X				    break;
X			    }
X			    updatetemp_tra(toffx, toffy, toffz,
X					   taxis, tdir);
X			    res = collision(1);
X			};
X			if (res==0) {
X			    status = ST_TURN;
X			    stattick = 0;
X			};
X			break;
X		    case XK_p:
X			if (status != ST_STILL) break;
X			droptimer = dropticks+100;
X			break;
X		    case XK_space:
X			if (status != ST_STILL) break;
X			status = ST_SPACEHIT;
X			break;
X		    case XK_Left:
X		    case XK_Right:
X		    case XK_Up:
X		    case XK_Down:
X			if (status != ST_STILL) break;
X			toffx = 0;
X			toffy = 0;
X			if (ksym==XK_Left) toffx = -1;
X			if (ksym==XK_Right) toffx = 1;
X			if (ksym==XK_Up) toffy = -1;
X			if (ksym==XK_Down) toffy = 1;
X			updatetemp_tra(toffx, toffy, 0, 0, 0);
X			if (collision(1)==0) {
X			    status = ST_GLIDE;
X			    stattick = 0;
X			};
X			break;
X		};
X		break;
X	    case ConfigureNotify:
X		if (event.xconfigure.width != dispx || event.xconfigure.height != dispy) {
X		    dispx = event.xconfigure.width;
X		    dispy = event.xconfigure.height;
X		    XFreePixmap(dpy, backpm);
X		    XFreePixmap(dpy, fieldpm);
X		    backpm = XCreatePixmap(dpy, win,
X			dispx, dispy, scndepth);   
X		    fieldpm = XCreatePixmap(dpy, win,
X			dispx, dispy, scndepth);   
X		    redo_board_globals();
X		    setup_cubies();
X		    setup_fieldpm();
X		    redraw_cubies();   
X		    setup_backpm();
X		    draw_score(backpm);
X		    draw_score(win);
X		    back_to_disp(1);		    
X		}
X		break;
X	    default:
X		break;
X	}
X
X	{
X	    if (status==ST_PAUSE) status=ST_STILL;
X	    switch (status) {
X		case ST_STILL:
X		    droptimer++;
X		    if (droptimer>dropticks) {
X			droptimer=0;
X			updatetemp_tra(0, 0, -1, 0, 0);
X			if (collision(1)==0) {  
X			    stattick=0;
X			    status = ST_FALL;
X			}
X			else {
X			    plop_piece();
X			    curpiece = -1;
X			}
X		    }
X		    break;
X		case ST_SPACEHIT:
X		    updatetemp_tra(0, 0, -1, 0, 0);
X		    if (aighhmode || collision(1)==0) {  
X			score++;
X			stattick=1;
X			status = ST_PLUMMET;
X			offz -= 1.0/PLUMLENGTH;
X			if (offz < -(fieldz+300.0)) {
X			    fprintf(stderr,
X				"Vanishing point error\nSegmentation fault\n");
X			    exit(-1);
X			}
X			updatepiece();
X			setup_backpm();
X			back_to_disp(0);
X		    }
X		    else {
X			plop_piece();
X			curpiece = -1;
X			status = ST_PAUSE;
X		    }
X		    break;
X		case ST_GLIDE:
X		    stattick++;
X		    offx += (double)toffx/GLIDELENGTH;
X		    offy += (double)toffy/GLIDELENGTH;
X		    if (stattick==GLIDELENGTH) {
X			round_piece(); 
X		    };
X		    updatepiece();
X		    setup_backpm();
X		    back_to_disp(0);
X		    if (stattick==GLIDELENGTH) {
X			status = ST_PAUSE;
X		    };
X		    break;
X		case ST_FALL:
X		    stattick++;
X		    offz -= 1.0/FALLLENGTH;
X		    if (stattick==FALLLENGTH) {
X			round_piece(); 
X		    };
X		    updatepiece();
X		    setup_backpm();
X		    back_to_disp(0);
X		    if (stattick==FALLLENGTH) {
X			status = ST_PAUSE;
X		    };
X		    break;
X		case ST_PLUMMET:
X		    stattick++;
X		    offz -= 1.0/PLUMLENGTH;
X		    if (stattick==PLUMLENGTH) {
X			round_piece(); 
X		    };
X		    updatepiece();
X		    setup_backpm();
X		    back_to_disp(0);
X		    if (stattick==PLUMLENGTH) {
X			status = ST_SPACEHIT;
X		    };
X		    break;
X		case ST_TURN:
X		    stattick++;
X		    rotate_piece(taxis, tdir*0.5*PI/TURNLENGTH);
X		    offx += (double)toffx/TURNLENGTH;
X		    offy += (double)toffy/TURNLENGTH;
X		    offz += (double)toffz/TURNLENGTH;
X		    if (stattick==TURNLENGTH) {
X			round_piece(); 
X		    };
X		    updatepiece();
X		    setup_backpm();
X		    back_to_disp(0);
X		    if (stattick==TURNLENGTH) {
X			status = ST_PAUSE;
X		    };
X		    break;
X	    }
X	    /*lasttime = current_usec();*/	    
X	}
X    }
X}
X
Xvoid redo_board_globals()  /* using dispx, dispy */
X{
X    if (!stereo) {
X	if (dispy-40<dispx-20) 
X	    boardscale = (double)(dispy - 40);
X	else
X	    boardscale = (double)(dispx - 20);
X	halfboard = (int)boardscale/2;
X    }
X    else {
X	if (dispy-40<(dispx-20)/2)
X	    boardscale = (double)(dispy - 40);
X	else
X	    boardscale = (double)((dispx - 20)/2);
X	halfboard = (int)boardscale/2;
X	halfboard2 = (3.0+(fieldoffx+2.5)/1.5)*halfboard;
X    }
X    if (dispy-(int)boardscale > 60) {
X	meterx = 32;
X	metery = boardscale+30;
X    }
X    else {
X	meterx = 176;
X	metery = boardscale+10;
X    }
X    metersize = (((int)boardscale) - meterx) / fieldz;
X    if (metersize<1) metersize = 1;
X    if (stereo) {
X	meterx2 = meterx + (halfboard2 - halfboard);
X	/*meterx2 = meterx2 & (~7);*/
X    }
X}
X
Xlong current_usec() /* returns the current
X time in microseconds */ 
X{
X    struct timeval tv;
X
X    gettimeofday(&tv, (struct timezone *)NULL);
X    return tv.tv_usec + 1000000*(tv.tv_sec%100);
X}
X
Xint elapsed(start, length) /* returns whether
X length microseconds have elapsed since start.
X Not reliable when length is more than 10^8 usec
X (100 seconds) */
Xlong start, length;
X{
X    long now;
X
X    now = current_usec();
X    if (start <= now) {
X	if (now-start > length) return 1;
X	else return 0;
X    }
X    else {  /* the current time has rolled
X     over; add 10^8 to it */
X	if (now+100000000-start > length) return 1;
X	else return 0;
X    }
X}
END_OF_FILE
if test 8859 -ne `wc -c <'spatial/game.c'`; then
    echo shar: \"'spatial/game.c'\" unpacked with wrong size!
fi
# end of 'spatial/game.c'
fi
if test -f 'spatial/intro.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/intro.c'\"
else
echo shar: Extracting \"'spatial/intro.c'\" \(4908 characters\)
sed "s/^X//" >'spatial/intro.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <sys/time.h>
X#include <X11/Xlib.h>
X#include <X11/keysym.h>
X#include "spatial.h"
X
X#define TICKLENGTH (50000)
X#define xputs(x, y, str)  \
XXDrawImageString(dpy, win, gcwhite, x, y, str, strlen(str))
X
X#define xline(x1, y1, x2, y2)  \
XXDrawLine(dpy, win, gcwhite, x1, y1, x2, y2) 
X
Xextern GC gcblack, gcwhite, gcinv, gccopy, gcline,
Xgcfield, gccubes[];
X
Xextern void intro_redraw(), redo_board_globals();
X
Xvoid initintro()
X{
X    intro_redraw();
X}
X
Xvoid introloop()
X{
X    short status, res;
X    Bool eventp;
X    XEvent event, nextevent;
X    long evmasks;
X    char key;
X    KeySym ksym;
X    long lasttime;
X    struct timeval tv;
X    fd_set readbits;
X
X    while (1) {
X	tv.tv_sec = 0;
X	tv.tv_usec = TICKLENGTH;
X	FD_ZERO(&readbits);
X	FD_SET(ConnectionNumber(dpy), &readbits);
X	(void)select(1+ConnectionNumber(dpy), &readbits, 0, 0, &tv);
X
X	evmasks = (KeyPressMask | ExposureMask | StructureNotifyMask);
X	eventp = XCheckWindowEvent(dpy, win, evmasks, &event);
X	if (eventp) switch (event.type) {
X	    case Expose:
X		eventp = XCheckWindowEvent(dpy, win, evmasks,
X			&nextevent);
X		while (eventp && nextevent.type == Expose) {
X		    eventp = XCheckWindowEvent(dpy, win, evmasks,
X			&nextevent);
X		};
X		if (eventp) {
X		    XPutBackEvent(dpy, &nextevent);
X		};
X		intro_redraw();
X		break;
X	    case KeyPress:
X		XLookupString(&event, &key, 1, &ksym, NULL);
X		/*printf("got '%s'\n", XKeysymToString(ksym));*/
X		switch (ksym) {
X		    case XK_q:
X		    case XK_Q:
X			exit(0);
X			break;
X		    case XK_c:
X		    case XK_C:
X			if (!stereo) {
X			    stereo = 1;
X			    fieldoffx = -2.65;
X			    fieldoffx2 = -2.35;
X			}
X			else if (fieldoffx < -2.5) {
X			    fieldoffx = -2.35;
X			    fieldoffx2 = -2.65;
X			}
X			else {
X			    stereo = 0;
X			    fieldoffx = -2.5;
X			};
X			redo_board_globals();
X			intro_redraw();
X			break;
X		    case XK_s:
X		    case XK_S:
X			return;
X		};
X		break;
X	    case ConfigureNotify:
X		if (event.xconfigure.width != dispx || event.xconfigure.height != dispy) {
X		    dispx = event.xconfigure.width;
X		    dispy = event.xconfigure.height;
X		    redo_board_globals();
X		    XFreePixmap(dpy, backpm);
X		    XFreePixmap(dpy, fieldpm);
X		    backpm = XCreatePixmap(dpy, win, dispx,
X					   dispy, scndepth);   
X		    fieldpm = XCreatePixmap(dpy, win, dispx,
X					    dispy, scndepth);   
X		}
X		break;
X	}
X    }
X}
X
Xvoid intro_redraw()
X{
X    register int ix;
X    char buf[255];
X
X    XFillRectangle(dpy, win, gcblack, 0, 0, dispx, dispy);
X    xputs(50, 180, "Spatial");
X    xputs(50, 200, "A Sadistic Software Production");
X    xputs(50, 220, "(C) Copyright 1991-3 Andrew Plotkin");
X    xputs(50, 240, " (ap1i@andrew.cmu.edu)");
X    if (score!=(-1)) {
X	sprintf(buf, "Your score: %d", score);
X	xputs(50, 260, buf);
X    }
X
X    xputs(50, 280, "Commands:");
X    xputs(70, 300, "s: start game");
X    if (!stereo) xputs(70, 320, "c: change display (normal)");
X    else if (fieldoffx < -2.5)
X	xputs(70, 320, "c: change display (reversed stereoscopic)");
X    else
X	xputs(70, 320, "c: change display (normal stereoscopic)");
X    xputs(70, 340, "Escape: pause");
X    xputs(70, 360, "q: quit program");
X
X    xputs(50, 400, "Game controls:");
X
X    XDrawArc(dpy, win, gcfield, 50, 410, 140, 140, 0, 23040);
X    XDrawArc(dpy, win, gcfield, 100, 410, 40, 140, 0, 23040);
X    XDrawArc(dpy, win, gcfield, 50, 460, 140, 40, 0, 23040);
X    XDrawArc(dpy, win, gcfield, 102, 410, 40, 140, 5760, 11520);
X    XDrawArc(dpy, win, gcfield, 50, 462, 140, 40, 11520, 11520);
X    XDrawArc(dpy, win, gcwhite, 101, 410, 40, 140, 8000, 3000);
X    XDrawArc(dpy, win, gcwhite, 101, 410, 40, 140, 14000, 2000);
X    XDrawArc(dpy, win, gcwhite, 50, 461, 140, 40, 13000, 2000);
X    XDrawArc(dpy, win, gcwhite, 50, 461, 140, 40, 17800, 3000);
X    XDrawArc(dpy, win, gcwhite, 51, 411, 138, 138, 1920, 1920);
X    XDrawArc(dpy, win, gcwhite, 51, 411, 138, 138, 7680, 1920);
X    xline(110, 421, 114, 430);
X    xline(110, 421, 100, 427);
X    xline(179, 492, 170, 488);
X    xline(179, 492, 173, 502);
X    xline(57, 489, 60, 498);
X    xline(57, 489, 60, 484);
X    xline(114, 546, 105, 543);
X    xline(114, 546, 119, 543);
X    xline(182, 448, 172, 445);
X    xline(58, 448, 68, 445);
X
X    xputs(83, 501, "h");
X    xputs(120, 503, "l");
X    xputs(99, 483, "i");
X    xputs(102, 518, "m");
X    xputs(91, 418, "k");
X    xputs(144, 416, "j");
X
X    xputs(70, 570, "rotation keys as shown above");
X    xputs(70, 590, "arrow keys: move piece sideways");
X    xputs(70, 610, "p: drop piece by 1");
X    xputs(70, 630, "space: drop piece to bottom");
X    xputs(70, 650, "q: quit game and return to this menu");
X
X    xputs(350, 250, "High Scores:");
X    for (ix=0; ix<NUMGAMERS; ix++) {
X	xputs(390, 270+20*ix, hscores[ix].name);
X	xputs(490, 270+20*ix, hscores[ix].userid);
X	xputs(590, 270+20*ix, hscores[ix].scoret);
X    }
X}
END_OF_FILE
if test 4908 -ne `wc -c <'spatial/intro.c'`; then
    echo shar: \"'spatial/intro.c'\" unpacked with wrong size!
fi
# end of 'spatial/intro.c'
fi
if test -f 'spatial/spatial.shp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/spatial.shp'\"
else
echo shar: Extracting \"'spatial/spatial.shp'\" \(8168 characters\)
sed "s/^X//" >'spatial/spatial.shp' <<'END_OF_FILE'
X25
X
X3, 8, 12
X.5, -.5, -.5
X.5, .5, -.5
X.5, 1.5, -.5
X0, -1, 0
X1, -1, 0
X1, 2, 0
X0, 2, 0
X0, -1, -1
X1, -1, -1
X1, 2, -1
X0, 2, -1
X0,1
X1,2
X2,3
X3,0
X4,5
X5,6
X6,7
X7,4
X0,4
X1,5
X2,6
X3,7
X
X3, 12, 18
X-.5, -.5, -.5
X-.5, .5, -.5
X.5, .5, -.5
X0, 0, 0
X1, 0, 0
X1, 1, 0
X-1, 1, 0
X-1, -1, 0
X0, -1, 0
X0, 0, -1
X1, 0, -1
X1, 1, -1
X-1, 1, -1
X-1, -1, -1
X0, -1, -1
X0,1
X1,2
X2,3
X3,4
X4,5
X5,0
X6,7
X7,8
X8,9
X9,10
X10,11
X11,6
X0,6
X1,7
X2,8
X3,9
X4,10
X5,11
X
X5, 14, 21
X-.5, -.5, .5
X-.5, -.5, -.5
X-.5, .5, -.5
X.5, .5, -.5
X1.5, .5, -.5
X-1, -1, 1
X0, -1, 1
X-1, 0, 1
X0, 0, 1
X-1, -1, -1
X0, -1, -1
X-1, 0, 0
X2, 0, 0
X2, 0, -1
X2, 1, 0
X2, 1, -1
X-1, 1, 0
X-1, 1, -1
X0, 0, -1
X0,1
X1,3
X3,2
X2,0
X6,7
X7,9
X9,11
X11,6
X4,5
X5,13
X13,8
X8,10
X10,12
X12,4
X0,4
X1,5
X3,13
X7,8
X9,10
X11,12
X2,6
X
X5, 17, 24
X-.5, .5, .5
X-.5, -.5, -.5
X-.5, .5, -.5
X.5, .5, -.5
X1.5, .5, -.5
X-1, 0, 1
X0, 0, 1
X-1, 1, 1
X0, 1, 1
X-1, -1, 0
X0, -1, 0
X0, 0, 0
X2, 0, 0
X2, 1, 0
X0, 1, 0
X-1, 0, 0
X-1, -1, -1
X0, -1, -1
X0, 0, -1
X2, 0, -1
X2, 1, -1
X-1, 1, -1
X0,10
X1,13
X7,14
X8,15
X3,9
X2,16
X4,11
X5,12
X0,1
X1,3
X3,2
X2,0
X10,4
X4,5
X5,9
X10,7
X7,8
X8,9
X11,12
X12,13
X13,14
X14,15
X15,16
X16,11
X
X5, 18, 27
X.5, .5, .5
X-.5, -.5, -.5
X-.5, .5, -.5
X.5, .5, -.5
X1.5, .5, -.5
X0, 0, 1
X1, 0, 1
X1, 1, 1
X0, 1, 1
X-1, -1, 0
X0, -1, 0
X2, 0, 0
X2, 1, 0
X1, 0, 0
X1, 1, 0
X0, 1, 0
X-1, 1, 0
X-1, -1, -1
X0, -1, -1
X0, 0, -1
X2, 0, -1
X2, 1, -1
X-1, 1, -1
X0,1
X1,2
X2,3
X3,0
X4,5
X5,10
X8,6
X6,7
X7,9
X10,11
X11,4
X12,13
X13,14
X14,15
X15,16
X16,17
X17,12
X4,12
X5,13
X0,14
X1,8
X6,15
X7,16
X2,9
X3,10
X11,17
X8,9
X
X5, 16, 24
X1.5, .5, .5
X-.5, -.5, -.5
X-.5, .5, -.5
X.5, .5, -.5
X1.5, .5, -.5
X1, 0, 1
X2, 0, 1
X1, 1, 1
X2, 1, 1
X-1, -1, 0
X0, -1, 0
X0, 0, 0
X1, 0, 0
X1, 1, 0
X-1, 1, 0
X-1, -1, -1
X0, -1, -1
X0, 0, -1
X2, 0, -1
X2, 1, -1
X-1, 1, -1
X0,1
X1,3
X3,2
X2,0
X4,5
X5,6
X6,7
X7,8
X8,9
X9,4
X10,11
X11,12
X12,13
X13,14
X14,15
X15,10
X4,10
X5,11
X6,12
X0,7
X1,13
X3,14
X2,8
X9,15
X
X5, 16, 24
X.5, -.5, .5
X.5, -.5, -.5
X-.5, .5, -.5
X.5, .5, -.5
X1.5, .5, -.5
X0, -1, 1
X1, -1, 1
X1, 0, 1
X0, 0, 1
X-1, 0, 0
X2, 0, 0
X2, 1, 0
X-1, 1, 0
X-1, 0, -1
X0, 0, -1
X0, -1, -1
X1, -1, -1
X1, 0, -1
X2, 0, -1
X2, 1, -1
X-1, 1, -1
X0,1
X1,2
X2,3
X3,0
X4,5
X5,6
X6,7
X7,4
X8,9
X9,10
X10,11
X11,12
X12,13
X13,14
X14,15
X15,8
X0,10
X1,11
X2,12
X3,9
X5,13
X6,14
X7,15
X4,8
X
X5, 20, 30
X.5, -.5, .5
X-.5, -.5, -.5
X.5, -.5, -.5
X1.5, -.5, -.5
X.5, .5, -.5
X0, -1, 1
X1, -1, 1
X1, 0, 1
X0, 0, 1
X-1, -1, 0
X0, -1, 0
X1, -1, 0
X2, -1, 0
X2, 0, 0
X-1, 0, 0
X-1, -1, -1
X2, -1, -1
X2, 0, -1
X1, 0, -1
X1, 1, -1
X0, 1, -1
X0, 0, -1
X-1, 0, -1
X0, 1, 0
X1, 1, 0
X0,1
X1,2
X2,3
X3,0
X6,7
X7,8
X8,9
X9,4
X4,5
X10,11
X11,12
X12,13
X13,14
X14,15
X15,16
X16,17
X17,10
X0,5
X1,6
X7,11
X8,12
X2,13
X3,16
X19,14
X18,15
X9,17
X4,10
X5,18
X6,19
X18,19
X
X5, 14, 21
X-.5, .5, .5
X-.5, .5, -.5
X-.5, -.5, -.5
X.5, -.5, -.5
X.5, .5, -.5
X-1, 0, 1
X0, 0, 1
X0, 1, 1
X-1, 1, 1
X-1, 0, 0
X0, 0, 0
X0, 1, 0
X1, 1, 0
X1, -1, 0
X-1, -1, 0
X-1, 1, -1
X1, 1, -1
X1, -1, -1
X-1, -1, -1
X0,1
X1,2
X2,3
X3,0
X4,5
X5,6
X6,7
X7,8
X8,9
X9,4
X10,11
X11,12
X12,13
X13,10
X0,4
X1,5
X2,6
X3,10
X9,13
X8,12
X7,11
X
X5, 17, 24
X-.5, -.5, .5
X.5, .5, .5
X-.5, -.5, -.5
X-.5, .5, -.5
X.5, .5, -.5
X0, 0, 1
X1, 0, 1
X1, 1, 1
X0, 1, 1
X0, -1, 1
X-1, -1, 1
X-1, 0, 1
X0, 0, 0
X0, 1, 0
X-1, 1, 0
X-1, 0, 0
X0, 0, -1
X1, 0, -1
X1, 1, -1
X-1, 1, -1
X-1, -1, -1
X0, -1, -1
X1,2
X2,3
X3,4
X4,5
X5,6
X6,1
X7,8
X8,9
X9,10
X10,7
X11,12
X12,13
X13,14
X14,15
X15,16
X16,11
X0,11
X1,12
X2,13
X3,8
X9,14
X6,10
X5,15
X4,16
X
X5, 18, 27
X-.5, -.5, .5
X-.5, -.5, -.5
X-.5, .5, -.5
X.5, .5, -.5
X.5, 1.5, -.5
X0, 0, 1
X-1, 0, 1
X-1, -1, 1
X0, -1, 1
X-1, 0, 0
X1, 0, 0
X1, 2, 0
X0, 2, 0
X0, 1, 0
X-1, 1, 0
X-1, -1, -1
X0, -1, -1
X0, 0, -1
X1, 0, -1
X1, 2, -1
X0, 2, -1
X0, 1, -1
X-1, 1, -1
X0,1
X1,2
X2,3
X3,0
X4,5
X5,6
X6,7
X7,8
X8,9
X9,4
X10,11
X11,12
X12,13
X13,14
X14,15
X15,16
X16,17
X17,10
X0,12
X1,4
X2,10
X3,11
X5,13
X6,14
X7,15
X8,16
X9,17
X
X5, 18, 27
X.5, .5, .5
X-.5, -.5, -.5
X-.5, .5, -.5
X.5, .5, -.5
X.5, 1.5, -.5
X0, 0, 1
X1, 0, 1
X1, 1, 1
X0, 1, 1
X-1, -1, 0
X0, -1, 0
X1, 1, 0
X1, 2, 0
X0, 2, 0
X-1, 1, 0
X-1, -1, -1
X0, -1, -1
X0, 0, -1
X1, 0, -1
X1, 2, -1
X0, 2, -1
X0, 1, -1
X-1, 1, -1
X0,1
X1,2
X2,3
X3,0
X4,5
X5,8
X8,7
X7,6
X6,9
X9,4
X10,11
X11,12
X12,13
X13,14
X14,15
X15,16
X16,17
X17,10
X0,12
X1,13
X2,6
X7,14
X8,15
X3,16
X9,17
X4,10
X5,11
X
X5, 16, 24
X-.5, .5, -.5
X.5, .5, -.5
X.5, -.5, -.5
X.5, -.5, .5
X1.5, -.5, .5
X0, -1, 1
X2, -1, 1
X2, 0, 1
X0, 0, 1
X1, -1, 0
X2, -1, 0
X2, 0, 0
X-1, 0, 0
X-1, 1, 0
X1, 1, 0
X0, -1, -1
X1, -1, -1
X1, 1, -1
X-1, 1, -1
X-1, 0, -1
X0, 0, -1
X0,1
X1,2
X2,3
X3,0
X4,5
X5,6
X6,7
X7,8
X8,9
X9,4
X10,11
X11,12
X12,13
X13,14
X14,15
X15,10
X0,10
X4,11
X1,5
X2,6
X3,15
X9,12
X8,13
X7,14
X
X5, 24, 36
X.5, .5, -.5
X-.5, .5, -.5
X.5, -.5, -.5
X1.5, .5, -.5
X.5, 1.5, -.5
X0, 0, 0
X0, -1, 0
X1, -1, 0
X1, 0, 0
X2, 0, 0
X2, 1, 0
X1, 1, 0
X1, 2, 0
X0, 2, 0
X0, 1, 0
X-1, 1, 0
X-1, 0, 0
X0, 0, -1
X0, -1, -1
X1, -1, -1
X1, 0, -1
X2, 0, -1
X2, 1, -1
X1, 1, -1
X1, 2, -1
X0, 2, -1
X0, 1, -1
X-1, 1, -1
X-1, 0, -1
X0,1
X1,2
X2,3
X3,4
X4,5
X5,6
X6,7
X7,8
X8,9
X9,10
X10,11
X11,0
X12,13
X13,14
X14,15
X15,16
X16,17
X17,18
X18,19
X19,20
X20,21
X21,22
X22,23
X23,12
X0,12
X1,13
X2,14
X3,15
X4,16
X5,17
X6,18
X7,19
X8,20
X9,21
X10,22
X11,23
X
X5, 12, 18
X-.5, -.5, -.5
X-.5, .5, -.5
X.5, .5, -.5
X1.5, .5, -.5
X2.5, .5, -.5
X0, 0, 0
X3, 0, 0
X3, 1, 0
X-1, 1, 0
X-1, -1, 0
X0, -1, 0
X0, 0, -1
X3, 0, -1
X3, 1, -1
X-1, 1, -1
X-1, -1, -1
X0, -1, -1
X0,1
X1,2
X2,3
X3,4
X4,5
X5,0
X6,7
X7,8
X8,9
X9,10
X10,11
X11,6
X0,6
X1,7
X2,8
X3,9
X4,10
X5,11
X
X5, 8, 12
X.5, -1.5, -.5
X.5, -.5, -.5
X.5, .5, -.5
X.5, 1.5, -.5
X.5, 2.5, -.5
X0, -2, 0
X1, -2, 0
X1, 3, 0
X0, 3, 0
X0, -2, -1
X1, -2, -1
X1, 3, -1
X0, 3, -1
X0,1
X1,2
X2,3
X3,0
X4,5
X5,6
X6,7
X7,4
X0,4
X1,5
X2,6
X3,7
X
X5, 16, 24
X-.5, -.5, -.5
X-.5, .5, -.5
X.5, .5, -.5
X1.5, .5, -.5
X1.5, 1.5, -.5
X0, 0, 0
X2, 0, 0
X2, 2, 0
X1, 2, 0
X1, 1, 0
X-1, 1, 0
X-1, -1, 0
X0, -1, 0
X0, 0, -1
X2, 0, -1
X2, 2, -1
X1, 2, -1
X1, 1, -1
X-1, 1, -1
X-1, -1, -1
X0, -1, -1
X0,1
X1,2
X2,3
X3,4
X4,5
X5,6
X6,7
X7,0
X8,9
X9,10
X10,11
X11,12
X12,13
X13,14
X14,15
X15,8
X0,8
X1,9
X2,10
X3,11
X4,12
X5,13
X6,14
X7,15
X
X5, 16, 24
X-.5, -1.5, -.5
X-.5, -.5, -.5
X.5, -.5, -.5
X.5, .5, -.5
X.5, 1.5, -.5
X0, 0, 0
X-1, 0, 0
X-1, -2, 0
X0, -2, 0
X0, -1, 0
X1, -1, 0
X1, 2, 0
X0, 2, 0
X0, 0, -1
X-1, 0, -1
X-1, -2, -1
X0, -2, -1
X0, -1, -1
X1, -1, -1
X1, 2, -1
X0, 2, -1
X0,1
X1,2
X2,3
X3,4
X4,5
X5,6
X6,7
X7,0
X8,9
X9,10
X10,11
X11,12
X12,13
X13,14
X14,15
X15,8
X0,8
X1,9
X2,10
X3,11
X4,12
X5,13
X6,14
X7,15
X
X5, 16, 24
X-.5, -1.5, -.5
X-.5, -.5, -.5
X-.5, .5, -.5
X-.5, 1.5, -.5
X.5, -.5, -.5
X0, 0, 0
X0, 2, 0
X-1, 2, 0
X-1, -2, 0
X0, -2, 0
X0, -1, 0
X1, -1, 0
X1, 0, 0
X0, 0, -1
X0, 2, -1
X-1, 2, -1
X-1, -2, -1
X0, -2, -1
X0, -1, -1
X1, -1, -1
X1, 0, -1
X0,1
X1,2
X2,3
X3,4
X4,5
X5,6
X6,7
X7,0
X8,9
X9,10
X10,11
X11,12
X12,13
X13,14
X14,15
X15,8
X0,8
X1,9
X2,10
X3,11
X4,12
X5,13
X6,14
X7,15
X
X5, 20, 30
X.5, .5, -.5
X-.5, .5, -.5
X.5, -.5, -.5
X1.5, -.5, -.5
X.5, 1.5, -.5
X0, 0, 0
X0, -1, 0
X2, -1, 0
X2, 0, 0
X1, 0, 0
X1, 2, 0
X0, 2, 0
X0, 1, 0
X-1, 1, 0
X-1, 0, 0
X0, 0, -1
X0, -1, -1
X2, -1, -1
X2, 0, -1
X1, 0, -1
X1, 2, -1
X0, 2, -1
X0, 1, -1
X-1, 1, -1
X-1, 0, -1
X0,1
X1,2
X2,3
X3,4
X4,5
X5,6
X6,7
X7,8
X8,9
X9,0
X10,11
X11,12
X12,13
X13,14
X14,15
X15,16
X16,17
X17,18
X18,19
X19,10
X0,10
X1,11
X2,12
X3,13
X4,14
X5,15
X6,16
X7,17
X8,18
X9,19
X
X5, 16, 24
X-.5, -.5, -.5
X.5, -.5, -.5
X1.5, -.5, -.5
X.5, .5, -.5
X.5, 1.5, -.5
X0, 0, 0
X-1, 0, 0
X-1, -1, 0
X2, -1, 0
X2, 0, 0
X1, 0, 0
X1, 2, 0
X0, 2, 0
X0, 0, -1
X-1, 0, -1
X-1, -1, -1
X2, -1, -1
X2, 0, -1
X1, 0, -1
X1, 2, -1
X0, 2, -1
X0,1
X1,2
X2,3
X3,4
X4,5
X5,6
X6,7
X7,0
X8,9
X9,10
X10,11
X11,12
X12,13
X13,14
X14,15
X15,8
X0,8
X1,9
X2,10
X3,11
X4,12
X5,13
X6,14
X7,15
X
X5, 12, 18
X.5, .5, -.5
X-.5, -.5, -.5
X.5, -.5, -.5
X-.5, .5, -.5
X1.5, -.5, -.5
X-1, -1, 0
X2, -1, 0
X2, 0, 0
X1, 0, 0
X1, 1, 0
X-1, 1, 0
X-1, -1, -1
X2, -1, -1
X2, 0, -1
X1, 0, -1
X1, 1, -1
X-1, 1, -1
X0,1
X1,2
X2,3
X3,4
X4,5
X5,0
X6,7
X7,8
X8,9
X9,10
X10,11
X11,6
X0,6
X1,7
X2,8
X3,9
X4,10
X5,11
X
X5, 20, 30
X-1.5, -.5, -.5
X-1.5, .5, -.5
X-.5, .5, -.5
X-.5, 1.5, -.5
X.5, 1.5, -.5
X0, 0, 0
X0, 1, 0
X1, 1, 0
X1, 2, 0
X-1, 2, 0
X-1, 1, 0
X-2, 1, 0
X-2, -1, 0
X-1, -1, 0
X-1, 0, 0
X0, 0, -1
X0, 1, -1
X1, 1, -1
X1, 2, -1
X-1, 2, -1
X-1, 1, -1
X-2, 1, -1
X-2, -1, -1
X-1, -1, -1
X-1, 0, -1
X0,1
X1,2
X2,3
X3,4
X4,5
X5,6
X6,7
X7,8
X8,9
X9,0
X10,11
X11,12
X12,13
X13,14
X14,15
X15,16
X16,17
X17,18
X18,19
X19,10
X0,10
X1,11
X2,12
X3,13
X4,14
X5,15
X6,16
X7,17
X8,18
X9,19
X
X5, 12, 18
X-.5, -1.5, -.5
X-.5, -.5, -.5
X-.5, .5, -.5
X.5, .5, -.5
X1.5, .5, -.5
X0, 0, 0
X2, 0, 0
X2, 1, 0
X-1, 1, 0
X-1, -2, 0
X0, -2, 0
X0, 0, -1
X2, 0, -1
X2, 1, -1
X-1, 1, -1
X-1, -2, -1
X0, -2, -1
X0,1
X1,2
X2,3
X3,4
X4,5
X5,0
X6,7
X7,8
X8,9
X9,10
X10,11
X11,6
X0,6
X1,7
X2,8
X3,9
X4,10
X5,11
X
X5, 16, 24
X-.5, -.5, -.5
X-.5, .5, -.5
X.5, .5, -.5
X1.5, .5, -.5
X1.5, -.5, -.5
X0, 0, 0
X1, 0, 0
X1, -1, 0
X2, -1, 0
X2, 1, 0
X-1, 1, 0
X-1, -1, 0
X0, -1, 0
X0, 0, -1
X1, 0, -1
X1, -1, -1
X2, -1, -1
X2, 1, -1
X-1, 1, -1
X-1, -1, -1
X0, -1, -1
X0,1
X1,2
X2,3
X3,4
X4,5
X5,6
X6,7
X7,0
X8,9
X9,10
X10,11
X11,12
X12,13
X13,14
X14,15
X15,8
X0,8
X1,9
X2,10
X3,11
X4,12
X5,13
X6,14
X7,15
END_OF_FILE
if test 8168 -ne `wc -c <'spatial/spatial.shp'`; then
    echo shar: \"'spatial/spatial.shp'\" unpacked with wrong size!
fi
# end of 'spatial/spatial.shp'
fi
if test -f 'spheral/disp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/disp.c'\"
else
echo shar: Extracting \"'spheral/disp.c'\" \(11465 characters\)
sed "s/^X//" >'spheral/disp.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include "spheral.h"
X
XDisplay *dpy;
XWindow win;
XPixmap backpm, fieldpm, piecepm;
XGC gcblack, gcwhite, gcinv, gccopy, gcline,
X  gcfield, gcocto, gcadd, gcballs[16],
X  gcpiece1, gcpiece0, gcpieceadd;
Xint scn;
Xint scndepth;
X
Xpiecelist pieces[MAXPIECES];
X
Xshort numpieces;
Xshort curpiece;
X
Xint dispx, dispy; /* size of window */
Xint sshapx1, sshapx2, sshapy1, sshapy2;
X/* size of rectangle that contains current shape */
Xint bbackx1, bbackx2, bbacky1, bbacky2;
X/* coords of rectangle of backpm that is usable */
Xint ddispx1, ddispx2, ddispy1, ddispy2;
X/* coords of rectangle of display that is
X different from fieldpm */
X
Xextern void draw_curpiece(), measure_curpiece(), setup_grey();
X
Xvoid xinit() /* using dispx, dispy */
X{
X    register int ix;
X    XSetWindowAttributes attr;
X    XGCValues gcvalues;
X    static char dashes[2] = {1, 1};
X    static char widedashes[2] = {1, 3};
X    XSizeHints hints;
X
X    dpy = XOpenDisplay((char *) NULL);
X    if ((Display *) NULL == dpy) {
X	fprintf(stderr, "spheral: could not open display.\n");
X	exit(-1);
X    }
X
X    scn = DefaultScreen(dpy);
X    scndepth = DefaultDepth(dpy, scn);
X    if (scndepth==1) monomode = 1;
X
X    win = XCreateSimpleWindow(dpy, DefaultRootWindow(dpy),
X	100, 100, dispx, dispy, 1,
X	BlackPixel(dpy, scn), WhitePixel(dpy, scn));
X
X    hints.min_width = 100;
X    hints.min_height = 100;
X    hints.width = dispx;
X    hints.height = dispy;
X    hints.flags = PMinSize | PSize;
X    XSetWMNormalHints(dpy, win, &hints);
X    {
X	XWMHints wmhints;
X	wmhints.flags = InputHint;
X	wmhints.input = True;
X	XSetWMHints(dpy, win, &wmhints);
X    }
X
X    XStoreName(dpy, win, "Spheral");
X
X    attr.event_mask = (KeyPressMask | ExposureMask
X		       | StructureNotifyMask);
X    XChangeWindowAttributes(dpy, win, CWEventMask, &attr);
X
X    XSetWindowBackground(dpy, win, BlackPixel(dpy, scn));
X
X    XMapWindow(dpy, win);
X
X    gcvalues.foreground = WhitePixel(dpy, scn);
X    gcvalues.background = BlackPixel(dpy, scn);
X    gcwhite = XCreateGC(dpy, win, GCForeground|GCBackground,
X			&gcvalues);
X
X    gcvalues.line_style = LineOnOffDash;
X    gcfield = XCreateGC(dpy, win, GCForeground|GCLineStyle,
X			&gcvalues);
X    XSetDashes(dpy, gcfield, 0, dashes, 2);
X    gcocto = XCreateGC(dpy, win, GCForeground|GCLineStyle,
X		       &gcvalues);
X    XSetDashes(dpy, gcocto, 0, widedashes, 2);
X
X    gcvalues.line_width = 2;
X    gcline = XCreateGC(dpy, win, GCForeground|GCLineWidth,
X		       &gcvalues);
X
X    if (WhitePixel(dpy, scn))
X	gcvalues.function = GXor;
X    else
X	gcvalues.function = GXand;
X    gcadd = XCreateGC(dpy, win, GCForeground|GCBackground|GCFunction,
X		      &gcvalues);
X    XSetGraphicsExposures(dpy, gcadd, 0);
X
X    gcvalues.function = GXinvert;
X    gcinv = XCreateGC(dpy, win, GCForeground|GCFunction,
X		      &gcvalues);
X
X    gcvalues.foreground = BlackPixel(dpy, scn);
X    gcblack = XCreateGC(dpy, win, GCForeground, &gcvalues);
X
X    gcvalues.background = WhitePixel(dpy, scn);
X    gccopy = XCreateGC(dpy, win, GCForeground|GCBackground,
X		       &gcvalues);
X    XSetGraphicsExposures(dpy, gccopy, 0);
X
X    setup_grey();
X
X    backpm = XCreatePixmap(dpy, win, dispx, dispy, scndepth);   
X    fieldpm = XCreatePixmap(dpy, win, dispx, dispy, scndepth);
X    if (monomode) {
X	piecepm = NULL;
X	gcpiece0 = NULL;
X	gcpiece1 = NULL;
X	gcpieceadd = NULL;
X    }
X    else {
X	piecepm = XCreatePixmap(dpy, win, dispx, dispy, 1);
X	gcvalues.foreground = 0;
X	gcpiece0 = XCreateGC(dpy, piecepm, GCForeground,
X		&gcvalues);
X	gcvalues.foreground = 1;
X	gcpiece1 = XCreateGC(dpy, piecepm, GCForeground,
X		&gcvalues);
X	gcvalues.foreground = WhitePixel(dpy, scn);
X	gcvalues.background = BlackPixel(dpy, scn);
X	gcvalues.function = GXand;
X	gcpieceadd = XCreateGC(dpy, win,
X		GCForeground|GCBackground|GCFunction,
X		&gcvalues);
X	XSetGraphicsExposures(dpy, gcpieceadd, 0);
X    }
X}
X
Xvoid setup_fieldpm() /* clear, draw field box and side text.
X Also set bback{x,y}{1,2} to window size */
X{
X    register int ix, iz;
X
X    XFillRectangle(dpy, fieldpm, gcblack, 0, 0, dispx, dispy);
X    XDrawImageString(dpy, fieldpm, gcwhite, 20, 20, "Score: ", 7); 
X
X    /* draw triangles (sort of) parallel to screen */
X    for (iz=fieldz-1; iz<fieldz; iz++) {
X	XDrawLine(dpy, fieldpm, gcfield, fieldpts[0][0][iz].x,
X		  fieldpts[0][0][iz].y, fieldpts[fieldx-1][0][iz].x,
X		  fieldpts[fieldx-1][0][iz].y);
X	XDrawLine(dpy, fieldpm, gcfield, fieldpts[0][0][iz].x,
X		  fieldpts[0][0][iz].y, fieldpts[0][fieldx-1][iz].x,
X		  fieldpts[0][fieldx-1][iz].y);
X	XDrawLine(dpy, fieldpm, gcfield, fieldpts[fieldx-1][0][iz].x,
X		  fieldpts[fieldx-1][0][iz].y, fieldpts[0][fieldx-1][iz].x,
X		  fieldpts[0][fieldx-1][iz].y);
X    };
X
X    /* draw perpendiculars to screen */
X    for (ix=0; ix<fieldx; ix++) {
X	XDrawLine(dpy, fieldpm, gcfield, fieldpts[ix][0][0].x,
X		  fieldpts[ix][0][0].y, fieldpts[ix][0][fieldz-1].x,
X		  fieldpts[ix][0][fieldz-1].y);
X	XDrawLine(dpy, fieldpm, gcfield, fieldpts[0][ix][0].x,
X		  fieldpts[0][ix][0].y, fieldpts[0][ix][fieldz-1].x,
X		  fieldpts[0][ix][fieldz-1].y);
X	XDrawLine(dpy, fieldpm, gcfield, fieldpts[ix][fieldx-1-ix][0].x,
X		  fieldpts[ix][fieldx-1-ix][0].y,
X		  fieldpts[ix][fieldx-1-ix][fieldz-1].x,
X		  fieldpts[ix][fieldx-1-ix][fieldz-1].y);
X    }
X
X    for (ix=0; ix<fieldx-1; ix++) {
X	XDrawLine(dpy, fieldpm, gcfield, fieldpts[ix+1][0][0].x,
X		  fieldpts[ix+1][0][0].y, fieldpts[0][ix+1][0].x,
X		  fieldpts[0][ix+1][0].y);
X	XDrawLine(dpy, fieldpm, gcfield, fieldpts[ix][0][0].x,
X		  fieldpts[ix][0][0].y, fieldpts[ix][fieldx-ix-1][0].x,
X		  fieldpts[ix][fieldx-ix-1][0].y);
X	XDrawLine(dpy, fieldpm, gcfield, fieldpts[0][ix][0].x,
X		  fieldpts[0][ix][0].y, fieldpts[fieldx-ix-1][ix][0].x,
X		  fieldpts[fieldx-ix-1][ix][0].y);
X    }
X
X    bbackx1 = dispx-1;
X    bbackx2 = 0;
X
X    ddispx1 = 0;
X    ddispx2 = dispx-1;
X    ddispy1 = 0;
X    ddispy2 = dispy-1;
X    /*meteroldlev = 0;*/
X}
X
Xvoid setup_backpm()
X/* put stuff on the backpm, so that bback is the smallest
X area different from fieldpm (but larger than ddisp), and
X those together are an accurate picture of the board */
X{
X    piecesum psum;
X    register int ix;
X    int rad;
X
X    /* measure piece, store max{sshap, ddisp} in bback limits */
X    measure_curpiece(&psum);
X    sshapx1 = dispx;
X    sshapx2 = 0;
X    sshapy1 = dispy;
X    sshapy2 = 0;
X    for (ix=0; ix<psum.numballs; ix++) {
X	rad = psum.rad[ix];
X	if (psum.p[ix].x-rad < sshapx1) sshapx1 = psum.p[ix].x-rad;
X	if (psum.p[ix].x+rad > sshapx2) sshapx2 = psum.p[ix].x+rad;
X	if (psum.p[ix].y-rad < sshapy1) sshapy1 = psum.p[ix].y-rad;
X	if (psum.p[ix].y+rad > sshapy2) sshapy2 = psum.p[ix].y+rad;
X    }
X    sshapx1 -= 2;
X    sshapy1 -= 2;
X    sshapx2 += 2;
X    sshapy2 += 2;
X
X    bbackx1 = (sshapx1 < ddispx1) ? sshapx1 : ddispx1;
X    bbacky1 = (sshapy1 < ddispy1) ? sshapy1 : ddispy1;
X    bbackx2 = (sshapx2 > ddispx2) ? sshapx2 : ddispx2;
X    bbacky2 = (sshapy2 > ddispy2) ? sshapy2 : ddispy2;
X
X    if (monomode) {
X	/* clear backpm, using bback limits */
X	XFillRectangle(dpy, backpm, gcblack, bbackx1, bbacky1,
X		bbackx2-bbackx1+1, bbacky2-bbacky1+1);
X	/* draw piece on backpm */
X	draw_curpiece(backpm, &psum, gcwhite, gcblack);
X
X	/* overlay fieldpm on backpm, using bback limits */
X	XCopyArea(dpy, fieldpm, backpm, gcadd, bbackx1, bbacky1,
X		bbackx2-bbackx1+1, bbacky2-bbacky1+1, bbackx1, bbacky1);
X    }
X    else {
X	/* clear piecepm, using bback limits */
X	XFillRectangle(dpy, piecepm, gcpiece0, bbackx1, bbacky1,
X		bbackx2-bbackx1+1, bbacky2-bbacky1+1);
X	/* draw piece on piecepm */
X	draw_curpiece(piecepm, &psum, gcpiece1, gcpiece0);
X
X	/* copy fieldpm to backpm, using bback limits */
X	XCopyArea(dpy, fieldpm, backpm, gccopy, bbackx1, bbacky1,
X		bbackx2-bbackx1+1, bbacky2-bbacky1+1, bbackx1, bbacky1);
X	XCopyPlane(dpy, piecepm, backpm, gcpieceadd, bbackx1, bbacky1,
X		bbackx2-bbackx1+1, bbacky2-bbacky1+1,
X		bbackx1, bbacky1, 1);
X    }
X}
X
Xvoid back_to_disp(all)
Xint all; 
X{
X    if (all || (bbackx2==0)) {
X	/* copy fieldpm to display, then backpm
X	 to display (using sshap), then set ddisp to sshap */
X	XCopyArea(dpy, fieldpm, win, gccopy, 0, 0, dispx, dispy, 0, 0);
X	XCopyArea(dpy, backpm, win, gccopy, sshapx1, sshapy1,
X		  sshapx2-sshapx1+1, sshapy2-sshapy1+1, sshapx1, sshapy1);
X	ddispx1 = sshapx1;
X	ddispy1 = sshapy1;
X	ddispx2 = sshapx2;
X	ddispy2 = sshapy2;
X    }
X    else {
X	/* copy from backpm to display (using bback) */
X	XCopyArea(dpy, backpm, win, gccopy, bbackx1, bbacky1,
X		  bbackx2-bbackx1+1, bbacky2-bbacky1+1, bbackx1, bbacky1);
X
X	/* set ddisp limits to ddisp limits; */
X	ddispx1 = sshapx1;
X	ddispy1 = sshapy1;
X	ddispx2 = sshapx2;
X	ddispy2 = sshapy2;
X
X	/*if (meter_b_d) {
X	    XCopyArea(dpy, backpm, win, gccopy, meterx, metery,
X		      metersize*fieldz+1, 21, meterx, metery);
X	    if (stereo) {
X		XCopyArea(dpy, backpm, win, gccopy, meterx2, metery,
X			  metersize*fieldz+1, 21, meterx2, metery);
X	    }
X	    meter_b_d = 0;
X	}*/
X
X    }
X}
X
Xvoid draw_curpiece(drw, psum, gcon, gcoff) /* just that */
XDrawable drw;
Xpiecesum *psum;
XGC gcon, gcoff;
X{
X    register int ix;
X    int rad, radx, rady, lradx, lrady;
X
X    for (ix=0; ix<psum->numballs; ix++) {
X	rad = psum->rad[ix];
X	radx = (int)(rad*psum->scalex);
X	if (radx < 3) radx=3;
X	rady = (int)(rad*psum->scaley);
X	if (rady < 3) rady=3;
X
X	XFillArc(dpy, drw, gcon, psum->p[ix].x-radx,
X		 psum->p[ix].y-rady, radx*2, rady*2, 0, 23040); 
X	XFillArc(dpy, drw, gcoff, psum->p[ix].x-radx+2,
X		 psum->p[ix].y-rady+2, radx*2-4, rady*2-4, 0, 23040); 
X
X	/*XFillArc(dpy, drw, gcoff, psum->p[ix].x-rad,
X	 psum->p[ix].y-rad, rad*2, rad*2, 0, 23040); 
X	 XDrawArc(dpy, drw, gcon, psum->p[ix].x-rad,
X	 psum->p[ix].y-rad, rad*2, rad*2, 0, 23040); */
X
X	/*XDrawArc(dpy, drw, gcon, psum->p[ix].x-rad/2,
X	 psum->p[ix].y-rad, rad, rad*2, 0, 23040); 
X	 XDrawArc(dpy, drw, gcon, psum->p[ix].x-rad,
X	 psum->p[ix].y-rad/2, rad*2, rad, 0, 23040); */
X
X	lradx = radx/16;
X	if (lradx < 2) lradx = 2;
X	lrady = rady/16;
X	if (lrady < 2) lrady = 2;
X	XFillArc(dpy, drw, gcon, psum->p[ix].x-lradx,
X		 psum->p[ix].y-lrady, 2*lradx, 2*lrady, 0, 23040); 
X    }
X}
X
Xvoid draw_score(drw)
XDrawable drw;
X{
X    static char buf[32];
X    register int ix;
X    long sc;
X
X    if (score==0) {
X	XDrawImageString(dpy, drw, gcwhite, 76, 20,
X			 "0         ", 10);
X    }
X    else {
X	sc = score;
X	ix = 32;
X	buf[--ix] = '\0';
X	while (sc) {
X	    buf[--ix] = (sc%10) + '0';
X	    sc /= 10;
X	};
X	XDrawImageString(dpy, drw, gcwhite, 76, 20,
X			 buf+ix, 31-ix);
X    }
X}
X
Xvoid loadpieces(flname)
Xchar *flname;
X{
X    register int jx, ix;
X    FILE *fl;
X    int res;
X
X    fl = fopen(flname, "r");
X    if (fl==NULL) {
X	fprintf(stderr, "spheral: could not open shape file.\n");
X	exit(-1);
X    };
X
X    res=fscanf(fl, "%hd\n", &numpieces);
X    if (res!=1) {
X	fprintf(stderr, "spheral: error 0 in shape file.\n");
X	exit(-1);
X    };
X
X    for (ix=0; ix<numpieces; ix++) {
X	int in1, in2, in3;
X	res=fscanf(fl, "%d\n", &in1);
X	if (res!=1) {
X	    fprintf(stderr, "spheral: error 1 in shape file.\n");
X	    exit(-1);
X	};
X	pieces[ix].numballs=in1;
X	if (pieces[ix].numballs>MAXBALLS) {
X	    fprintf(stderr, "spheral: shape %d is too complex.\n", ix);
X	    exit(-1);
X	};
X	for (jx=0; jx<pieces[ix].numballs; jx++) {
X	    point *p = &(pieces[ix].points[jx]);
X	    res=fscanf(fl, "%lf, %lf, %lf\n", &(p->x),
X		       &(p->y), &(p->z));
X	    if (res!=3) {
X		fprintf(stderr, "spheral: error 2 in shape file.\n");
X		exit(-1);
X	    };
X	    p->w = 1.0;
X	};
X    }
X}
X
END_OF_FILE
if test 11465 -ne `wc -c <'spheral/disp.c'`; then
    echo shar: \"'spheral/disp.c'\" unpacked with wrong size!
fi
# end of 'spheral/disp.c'
fi
if test -f 'spheral/game.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/game.c'\"
else
echo shar: Extracting \"'spheral/game.c'\" \(10019 characters\)
sed "s/^X//" >'spheral/game.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <math.h>
X#include <sys/time.h>
X#include <X11/Xlib.h>
X#include <X11/keysym.h>
X#include "spheral.h"
X
X#define TICKLENGTH (25000)
X#define GLIDELENGTH (8)
X#define TURNLENGTH (8)
X#define PLUMLENGTH (3)
X#define FALLLENGTH (8)
X#define MIRRORLENGTH (12)
X
X/* int meterx, meterx2, metery, metersize, meterlev,
X meteroldlev, meter_f_b, meter_b_d;
X oldlev is level on fieldpm */
X
Xunsigned char field[MAXFIELDX][MAXFIELDX][MAXFIELDZ];
Xshort fieldx, fieldz;
Xdouble fieldoffx, fieldoffy, fieldoffz;
Xextern double offx, offy, offz;
Xlong score=(-1), dropticks;
X
Xextern int aspectflag;
Xextern double aspect;
X
Xextern point plist[], traplist[], templist[];
X
Xextern void setup_backpm(), setup_fieldpm(), setup_fieldpts(),
Xplop_piece(), add_balls(), round_piece(), draw_score();
Xextern void rotate_piece(), reverse_piece(), pauseloop();
X
Xvoid clearfield()
X{
X    int ix, iy, iz;
X    for (ix=0; ix<fieldx; ix++)
X	for (iy=0; iy<fieldx; iy++)
X	    for (iz=0; iz<fieldz; iz++) 
X		field[ix][iy][iz] = 0;
X}
X
Xvoid initgame()
X{
X    curpiece = -1;
X    score = 0;
X    dropticks = 800;
X    /*meterlev = 0;*/
X    clearfield();
X    setup_fieldpts();
X    setup_fieldpm();
X}
X
Xvoid redo_board_globals()  /* using dispx, dispy */
X{
X    if (dispy*ROOTHALF < dispx/2) 
X	boardscale = 2.5 * (double)(dispy*ROOTHALF);
X    else
X	boardscale = 2.5 * (double)(dispx/2);
X    halfboardx = dispx/2;
X    halfboardy = dispy/2;
X/*
X    if (dispy-(int)boardscale > 60) {
X	meterx = 32;
X	metery = boardscale+30;
X    }
X    else {
X	meterx = 176;
X	metery = boardscale+10;
X    }
X    metersize = (((int)boardscale) - meterx) / fieldz;
X    if (metersize<1) metersize = 1;*/
X}
X
Xvoid gameloop()
X{
X#define ST_STILL (0)
X#define ST_FALL (1)
X#define ST_TURN (2)
X#define ST_GLIDE (3)
X#define ST_PLUMMET (4)
X#define ST_SPACEHIT (5)
X#define ST_PAUSE (6)
X#define ST_MIRROR (7)
X
X    short status, res;
X    short droptimer=0, stattick;
X    Bool eventp;
X    XEvent event, nextevent;
X    long evmasks;
X    char key;
X    KeySym ksym;
X    long lasttime;
X    double toffx, toffy, toffz;
X    int taxis; /* 1=x, 2=y, 3=z */
X    int tdir;
X    struct timeval tv;
X    fd_set readbits;
X    int gotit;
X
X    status = ST_PAUSE;
X    /*lasttime = current_usec();*/
X
X    while (1) {
X	if (curpiece==(-1)) {
X	    startpiece();
X	    if (curpiece==(-2)) break; /* game over, man */
X	    setup_backpm();
X	    back_to_disp(0);
X	    draw_score(win);
X	    droptimer = 0;
X
X	    do {
X		eventp = XCheckWindowEvent(dpy, win,
X		KeyPressMask, &event);
X	    }
X	    while (eventp);
X	};
X
X	XFlush(dpy);
X
X	tv.tv_sec = 0;
X	tv.tv_usec = TICKLENGTH;
X	FD_ZERO(&readbits);
X	FD_SET(ConnectionNumber(dpy), &readbits);
X	(void)select(1+ConnectionNumber(dpy), &readbits, 0, 0, &tv);
X
X	if (status == ST_STILL)
X	    evmasks = (KeyPressMask | ExposureMask
X		       | StructureNotifyMask);
X	else
X	    evmasks = (ExposureMask | StructureNotifyMask);
X	eventp = XCheckWindowEvent(dpy, win, evmasks, &event);
X	if (eventp) switch (event.type) {
X	    case Expose:
X		do {
X		    gotit = XCheckWindowEvent(dpy, win,
X			ExposureMask, &nextevent);
X		} while (gotit);
X		back_to_disp(1);
X		break;
X	    case KeyPress:
X		XLookupString(&event, &key, 1, &ksym, NULL);
X		/*printf("got '%s'\n", XKeysymToString(ksym));*/
X		switch (ksym) {
X		    case XK_Q:
X			return;
X			break;
X/*		    case XK_equal:
X			curpiece = (-1);
X			break;*/
X		    case XK_Escape:
X			pauseloop();
X			setup_fieldpm();
X			add_balls(0);   
X			setup_backpm();
X			back_to_disp(1);		    
X			draw_score(win);
X			break;
X		    case XK_s:
X		    case XK_g:
X		    case XK_e:
X		    case XK_f:
X		    case XK_r:
X		    case XK_d:
X			if (status != ST_STILL) break;
X			if (ksym==XK_s || ksym==XK_g) taxis=1;
X			if (ksym==XK_e || ksym==XK_f) taxis=2;
X			if (ksym==XK_r || ksym==XK_d) taxis=3;
X			if (ksym==XK_s || ksym==XK_f || ksym==XK_r)
X			    tdir=1;
X			else tdir=(-1);
X			toffx = 0.0;
X			toffy = 0.0;
X			toffz = 0.0;
X			updatetemp_tra(toffx, toffy, toffz, taxis, tdir);
X			res = collision(1);
X			while (res!=OUT_NOT && res!=OUT_COLLIDE
X			       && res!=OUT_DOWN) {
X			    switch (res) { /* as collision, ignore 2 */
X				case OUT_UP:
X				    toffz = toffz - 1.0 ;
X				    break;
X				case OUT_NORTHEAST:
X				    toffx = toffx - 0.5;
X				    toffy = toffy - ROOTHALF;
X				    toffz = toffz + 0.5;
X				    break;
X				case OUT_SOUTH:
X				    toffx = toffx - 0.5;
X				    toffy = toffy + ROOTHALF;
X				    toffz = toffz - 0.5;
X				    break;
X				case OUT_NORTHWEST:
X				    toffx = toffx + 1.0;
X				    break;
X			    }
X			    updatetemp_tra(toffx, toffy, toffz,
X					   taxis, tdir);
X			    res = collision(1);
X			};
X			if (res==OUT_NOT) {
X			    status = ST_TURN;
X			    stattick = 0;
X			};
X			break;
X		    case XK_v:
X			if (status != ST_STILL) break;
X			toffx = 0.0;
X			toffy = 0.0;
X			toffz = 0.0;
X			updatetemp_tra(toffx, toffy, toffz, -1, 0);
X			res = collision(1);
X			while (res!=OUT_NOT && res!=OUT_COLLIDE && res!=OUT_DOWN) {
X			    switch (res) { /* as collision, ignore 2 */
X				case OUT_UP:
X				    toffz = toffz - 1.0 ;
X				    break;
X				case OUT_NORTHEAST:
X				    toffx = toffx - 0.5;
X				    toffy = toffy - ROOTHALF;
X				    toffz = toffz + 0.5;
X				    break;
X				case OUT_SOUTH:
X				    toffx = toffx - 0.5;
X				    toffy = toffy + ROOTHALF;
X				    toffz = toffz - 0.5;
X				    break;
X				case OUT_NORTHWEST:
X				    toffx = toffx + 1.0;
X				    break;
X			    }
X			    updatetemp_tra(toffx, toffy, toffz, -1, 0);
X			    res = collision(1);
X			};
X			if (res==OUT_NOT) {
X			    status = ST_MIRROR;
X			    aspectflag = 1;
X			    aspect = 1.0;
X			    stattick = 0;
X			};
X			break;
X		    case XK_p:
X			if (status != ST_STILL) break;
X			droptimer = dropticks+100;
X			break;
X		    case XK_space:
X			if (status != ST_STILL) break;
X			status = ST_SPACEHIT;
X			break;
X		    case XK_KP_1:
X		    case XK_KP_3:
X		    case XK_KP_4:
X		    case XK_KP_6:
X		    case XK_KP_7:
X		    case XK_KP_9:
X		    case XK_u:
X		    case XK_o:
X		    case XK_l:
X		    case XK_period:
X		    case XK_m:
X		    case XK_j:
X			if (status != ST_STILL) break;
X			toffx = 0.0;
X			toffy = 0.0;
X			toffz = 0.0;
X			if (ksym==XK_KP_4 || ksym==XK_j) toffx = -1.0;
X			if (ksym==XK_KP_6 || ksym==XK_l) toffx = 1.0;
X			if (ksym==XK_KP_9 || ksym==XK_o) {
X			    toffx = 0.5;
X			    toffy = ROOTHALF;
X			    toffz = -0.5;
X			}
X			if (ksym==XK_KP_1 || ksym==XK_m) {
X			    toffx = -0.5;
X			    toffy = -ROOTHALF;
X			    toffz = 0.5;
X			}
X			if (ksym==XK_KP_3 || ksym==XK_period) {
X			    toffx = 0.5;
X			    toffy = -ROOTHALF;
X			    toffz = 0.5;
X			}
X			if (ksym==XK_KP_7 || ksym==XK_u) {
X			    toffx = -0.5;
X			    toffy = ROOTHALF;
X			    toffz = -0.5;
X			}
X			updatetemp_tra(toffx, toffy, toffz, 0, 0);
X			if (collision(1)==OUT_NOT) {
X			    status = ST_GLIDE;
X			    stattick = 0;
X			};
X			break;
X		};
X		break;
X	    case ConfigureNotify:
X		if (event.xconfigure.width != dispx ||
X		    event.xconfigure.height != dispy) {
X		    dispx = event.xconfigure.width;
X		    dispy = event.xconfigure.height;
X		    XFreePixmap(dpy, backpm);
X		    XFreePixmap(dpy, fieldpm);
X		    backpm = XCreatePixmap(dpy, win, dispx,
X			dispy, scndepth);   
X		    fieldpm = XCreatePixmap(dpy, win, dispx,
X			dispy, scndepth);   
X		    redo_board_globals();
X		    setup_fieldpts();
X		    setup_fieldpm();
X		    add_balls(0);   
X		    setup_backpm();
X		    back_to_disp(1);		    
X		    draw_score(win);
X		}
X		break;
X	} /* done event switch */
X
X	if (status==ST_PAUSE) status=ST_STILL;
X	switch (status) {
X	    case ST_STILL:
X		droptimer++;
X		if (droptimer>dropticks) {
X		    droptimer=0;
X		    updatetemp_tra(0.0, 0.0, -1.0, 0, 0);
X		    if (collision(1)==OUT_NOT) {   
X			stattick=0;
X			status = ST_FALL;
X		    }
X		    else {
X			plop_piece();
X			curpiece = -1;
X		    }
X		}
X		break;
X	    case ST_SPACEHIT:
X		updatetemp_tra(0.0, 0.0, -1.0, 0, 0);
X		if (collision(1)==OUT_NOT) {  
X		    score++;
X		    stattick=1;
X		    status = ST_PLUMMET;
X		    offz -= 1.0/PLUMLENGTH;
X		    updatepiece();
X		    setup_backpm();
X		    back_to_disp(0);
X		}
X		else {
X		    plop_piece();
X		    curpiece = -1;
X		    status = ST_PAUSE;
X		}
X		break;
X	    case ST_GLIDE:
X		stattick++;
X		offx += (double)toffx/GLIDELENGTH;
X		offy += (double)toffy/GLIDELENGTH;
X		offz += (double)toffz/GLIDELENGTH;
X		if (stattick==GLIDELENGTH) {
X		    round_piece(); 
X		};
X		updatepiece();
X		setup_backpm();
X		back_to_disp(0);
X		if (stattick==GLIDELENGTH) {
X		    status = ST_PAUSE;
X		};
X		break;
X	    case ST_FALL:
X		stattick++;
X		offz -= 1.0/FALLLENGTH;
X		if (stattick==FALLLENGTH) {
X		    round_piece(); 
X		};
X		updatepiece();
X		setup_backpm();
X		back_to_disp(0);
X		if (stattick==FALLLENGTH) {
X		    status = ST_PAUSE;
X		};
X		break;
X	    case ST_PLUMMET:
X		stattick++;
X		offz -= 1.0/PLUMLENGTH;
X		if (stattick==PLUMLENGTH) {
X		    round_piece(); 
X		};
X		updatepiece();
X		setup_backpm();
X		back_to_disp(0);
X		if (stattick==PLUMLENGTH) {
X		    status = ST_SPACEHIT;
X		};
X		break;
X	    case ST_TURN:
X		stattick++;
X		rotate_piece(plist, taxis, ((double)(tdir))*PI/2.0/TURNLENGTH);
X		offx += (double)toffx/TURNLENGTH;
X		offy += (double)toffy/TURNLENGTH;
X		offz += (double)toffz/TURNLENGTH;
X		if (stattick==TURNLENGTH) {
X		    round_piece(); 
X		};
X		updatepiece();
X		setup_backpm();
X		back_to_disp(0);
X		if (stattick==TURNLENGTH) {
X		    status = ST_PAUSE;
X		};
X		break;
X	    case ST_MIRROR:
X		stattick++;
X		if (stattick == MIRRORLENGTH/2) {
X		    reverse_piece(plist, -1);
X		};
X		if (stattick < MIRRORLENGTH/2) {
X		    aspect = (double)(MIRRORLENGTH/2-stattick)
X		      / (double)(MIRRORLENGTH/2);
X		}
X		else {
X		    aspect = (double)(stattick-MIRRORLENGTH/2)
X		      / (double)(MIRRORLENGTH/2);
X		};
X		offx += (double)toffx/MIRRORLENGTH;
X		offy += (double)toffy/MIRRORLENGTH;
X		offz += (double)toffz/MIRRORLENGTH;
X		if (stattick==MIRRORLENGTH) {
X		    round_piece(); 
X		    aspectflag = 0;
X		};
X		updatepiece();
X		setup_backpm();
X		back_to_disp(0);
X		if (stattick==MIRRORLENGTH) {
X		    status = ST_PAUSE;
X		};
X		break;
X	} /* done switch status */
X    }
X}
X
END_OF_FILE
if test 10019 -ne `wc -c <'spheral/game.c'`; then
    echo shar: \"'spheral/game.c'\" unpacked with wrong size!
fi
# end of 'spheral/game.c'
fi
if test -f 'spheral/patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/patchlevel.h'\"
else
echo shar: Extracting \"'spheral/patchlevel.h'\" \(58 characters\)
sed "s/^X//" >'spheral/patchlevel.h' <<'END_OF_FILE'
Xstatic char *patchlevel = "Spheral version 1.0, patch 1";
END_OF_FILE
if test 58 -ne `wc -c <'spheral/patchlevel.h'`; then
    echo shar: \"'spheral/patchlevel.h'\" unpacked with wrong size!
fi
# end of 'spheral/patchlevel.h'
fi
if test -f 'spheral/score.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/score.c'\"
else
echo shar: Extracting \"'spheral/score.c'\" \(3980 characters\)
sed "s/^X//" >'spheral/score.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <errno.h>
X#include <ctype.h> 
X#include <pwd.h>
X#ifdef USELOCKF 
X#include <unistd.h> /* this is for SOLARIS;
X other systems may need a different include
X file to get lockf() to work right */
X#endif
X#include <sys/file.h>
X#include <X11/Xlib.h>
X#include "spheral.h"
X
Xextern char *getenv();
Xchar ProgramName[] = "spheral";
X
Xgamer hscores[NUMGAMERS];
Xchar hscorefl[512];
Xchar userid[16], gamename[16];
X
Xextern int errno;
X
Xvoid load_hscores(save)
Xint save;
X{
X    FILE *fl;
X    register int ix, jx;
X    int fd, res;
X    char buf[255];
X
X    fl = fopen(hscorefl, "r+");
X    if (!fl) {
X	fprintf(stderr,
X	    "spheral: unable to open high score file\n");
X	fprintf(stderr,
X	    "spheral: generating empty score file\n");
X
X	fl = fopen(hscorefl, "w");
X	if (!fl) {
X	    fprintf(stderr,
X		    "spheral: unable to create high score file\n");
X	    exit(-1);
X	}
X
X	for (ix=0; ix<NUMGAMERS; ix++) {
X	    fprintf(fl, "----\nSpheral\n0\n");
X	}
X	fclose(fl);
X	fl = fopen(hscorefl, "r+");
X	if (!fl) {
X	    fprintf(stderr,
X		    "spheral: unable to reopen high score file\n");
X	    exit(-1);
X	}
X    }
X
X    fd = fileno(fl);
X#ifdef USELOCKF
X    res = lockf(fd, F_LOCK, 0);
X#else
X    res = flock(fd, LOCK_NB | LOCK_EX);
X#endif
X    while (res) {
X	if (errno != EWOULDBLOCK) {
X	    fprintf(stderr,
X		    "spheral: unable to lock high score file\n");
X	    exit(-1);
X	};
X	sleep(1);
X#ifdef USELOCKF
X	res = lockf(fd, F_LOCK, 0);
X#else
X	res = flock(fd, LOCK_NB | LOCK_EX);
X#endif
X    };
X
X    for (ix=0; ix<NUMGAMERS; ix++) {
X	long val;
X
X	fgets(buf, 255, fl);
X	for (jx=0; jx<15 && buf[jx]!='\n'; jx++) 
X	    hscores[ix].userid[jx] = buf[jx];
X	hscores[ix].userid[jx] = '\0';
X	
X	fgets(buf, 255, fl);
X	for (jx=0; jx<15 && buf[jx]!='\n'; jx++) 
X	    hscores[ix].name[jx] = buf[jx];
X	hscores[ix].name[jx] = '\0';
X	
X	fgets(buf, 255, fl);
X	val=0;
X	for (jx=0; buf[jx]!='\n'; jx++) 
X	    val = val*10 + buf[jx] - '0';
X	hscores[ix].score = val;
X	sprintf(hscores[ix].scoret, "%d", val);
X    };
X
X    if (save) {
X	if (checkmod_scores()) {
X	    rewind(fl);
X	    for (ix=0; ix<NUMGAMERS; ix++) {
X		fprintf(fl, "%s\n%s\n%d\n", hscores[ix].userid,
X		    hscores[ix].name, hscores[ix].score);
X	    }
X	}
X    }
X
X#ifdef USELOCKF
X    lockf(fd, F_ULOCK, 0);
X#else
X    flock(fd, LOCK_UN);
X#endif
X
X    fclose(fl);
X}
X
Xint checkmod_scores()
X{
X    register int ix;
X    int new, bottom;
X    
X    if (score <= hscores[NUMGAMERS-1].score) return 0;
X    
X    for (ix=0; strcmp(hscores[ix].userid, userid)
X      && ix<NUMGAMERS; ix++);
X    
X    if (ix<NUMGAMERS) { /* was in list */
X	if (score <= hscores[ix].score) return 0;
X	bottom = ix;
X    }
X    else { /* wasn't in list */
X	bottom = NUMGAMERS-1;
X    };
X
X    for (new=0; score<=hscores[new].score; new++);
X    for (ix=bottom; ix>new; ix--) {
X	strcpy(hscores[ix].name, hscores[ix-1].name);
X	strcpy(hscores[ix].userid, hscores[ix-1].userid);
X	strcpy(hscores[ix].scoret, hscores[ix-1].scoret);
X	hscores[ix].score = hscores[ix-1].score;
X    };
X    strcpy(hscores[new].name, gamename);
X    strcpy(hscores[new].userid, userid);
X    hscores[new].score = score;
X    sprintf(hscores[new].scoret, "%d", score);
X
X    return 1;
X}
X
Xvoid get_names()
X{
X    register int ix;
X    struct passwd *tp;
X    char *tcp;
X
X    strcpy(hscorefl, SCOREFILENAME);
X
X    tp = getpwuid(getuid());
X    if (!tp) {
X	printf("unable to get userid!\n");
X	strcpy(userid, "????");
X    }
X    else {
X	strncpy(userid, tp->pw_name, 16);
X	userid[15] = '\0';
X    }
X
X    tcp = getenv("NAME");
X    if (tcp) {
X	strncpy(gamename, tcp, 16);
X	gamename[15] = '\0';
X    }
X    else if (tcp=XGetDefault(dpy, "spheral", "name")) {
X	strncpy(gamename, tcp, 16);
X	gamename[15] = '\0';
X    }
X    else if (tcp=XGetDefault(dpy, "spatial", "name")) {
X	strncpy(gamename, tcp, 16);
X	gamename[15] = '\0';
X    }
X    else {
X	strcpy(gamename, userid);
X    };
X
X    printf("Welcome, %s (%s)\n", gamename, userid);
X}
END_OF_FILE
if test 3980 -ne `wc -c <'spheral/score.c'`; then
    echo shar: \"'spheral/score.c'\" unpacked with wrong size!
fi
# end of 'spheral/score.c'
fi
if test -f 'spheral/spheral.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/spheral.6'\"
else
echo shar: Extracting \"'spheral/spheral.6'\" \(2537 characters\)
sed "s/^X//" >'spheral/spheral.6' <<'END_OF_FILE'
X.PU
X.TH SPHERAL 6 contributed
X.SH NAME
Xspheral  \-  three-dimensional Tetris on a close-packed
Xlattice of spheres
X.SH SYNOPSIS
X.B spheral
X[ 
X.I -m
X]
X.PP
X.B -m
X: Force monochrome mode, even on color displays.
X.SH DESCRIPTION
XIf you don't know the rules of Tetris by now, you're beyond hope.
X.PP
XYou are looking down; pieces appear directly in front of you
Xand fall away from you. The current piece is transparent;
Xwhen it lands, it becomes opaque. You must complete an entire
Xlayer (a triangle of 21 balls) to make it disappear.
X.PP
XThe bottom of the board (and therefore, the layers that you
Xare trying to complete) are
X.I not
Xparallel to the screen. They lean backwards (away from you) 
Xon the top (north) edge. When a piece lands on the bottom
Xof the board, the balls fall on the intersections of the grey
Xlines, not in the triangles between the lines.
X.PP
XThe top corner of the game display shows your score.
X.PP
XYou can resize the window, and the board will be scaled
Xappropriately. (The high-score list doesn't behave so
Xcleverly.)
X.PP
XBy hitting
X.B c
Xat the title screen, you can change the display of the balls
Xfrom solid grey disks to nifty shaded balls. However, in
Xthis mode, the game will have to generate the shaded
Ximages the first time you start a game, and again each time
Xyou resize the window. Generating the images takes about
X15 seconds, more or less, depending on how much
Xtestosterone your computer has to crunch numbers with.
X.SH CONTROLS
X.B s, g, r, d, e, f
X: rotate the current piece. The control of rotation around three
Xspatial axes is nigh impossible to describe, especially since
Xtwo of the axes are slantwise to the screen. See the title
Xscreen for a picture that may help.
X.br
X.B 4, 6, 7, 3, 1, 9
X.I or
X.br
X.B j, l, u, ., m, o
X: slide the current piece horizontally. (Again, this motion
Xis parallel with the bottom of the board, not with your
Xscreen.)
X.br
X.B p
X: drop the current piece one space down.
X.br
X.B v
X: mirror-image the current piece, left-to-right.
X.br
X.I SPACE
X: drop the current piece all the way to the bottom of the
Xboard.
X.br
X.I ESCAPE
X: pause the game, and draw pretty random cubes until
Xyou hit
X.I ESCAPE
Xagain.
X.br
X.B Q
X: quit the current game with your current score. Hitting
X.B Q
Xagain, from the title screen, will exit the program. Note
Xthat this is a capital letter (shift-Q).
X.SH AUTHOR
XAndrew Plotkin <ap1i+@andrew.cmu.edu>
X.br
XThis program is (C) Copyright 1991-3 Andrew Plotkin.
X.br
XPermission is given to copy and distribute freely, as long
Xas this copyright notice is retained.
END_OF_FILE
if test 2537 -ne `wc -c <'spheral/spheral.6'`; then
    echo shar: \"'spheral/spheral.6'\" unpacked with wrong size!
fi
# end of 'spheral/spheral.6'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
