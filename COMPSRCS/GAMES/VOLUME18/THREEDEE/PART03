Path: uunet!news.tek.com!news.cna.tek.com!not-for-mail
From: billr@saab.cna.tek.com (Bill Randle)
Newsgroups: comp.sources.games
Subject: v18i058:  threedee - two 3d tetris games for X, Part03/04
Date: 30 Aug 1993 08:36:09 -0700
Organization: Tektronix, Inc., Redmond, OR
Lines: 2196
Approved: billr@saab.CNA.TEK.COM
Message-ID: <25t6p9$fmf@saab.cna.tek.com>
NNTP-Posting-Host: saab.cna.tek.com
Xref: uunet comp.sources.games:1858

Submitted-by: "Andrew C. Plotkin" <ap1i+@andrew.cmu.edu>
Posting-number: Volume 18, Issue 58
Archive-name: threedee/part03
Environment: X11, Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 4)."
# Contents:  spatial/Makefile spatial/README spatial/deco.c
#   spatial/grey01.bm spatial/grey02.bm spatial/grey03.bm
#   spatial/grey04.bm spatial/grey05.bm spatial/grey06.bm
#   spatial/grey07.bm spatial/grey08.bm spatial/grey09.bm
#   spatial/grey10.bm spatial/grey11.bm spatial/grey12.bm
#   spatial/grey13.bm spatial/grey14.bm spatial/grey15.bm
#   spatial/grey16.bm spatial/score.c spatial/spatial.6
#   spatial/spatial.c spatial/spatial.h spheral/README spheral/deco.c
#   spheral/errdi.c spheral/gcgrey.c spheral/grey01.bm
#   spheral/grey02.bm spheral/grey03.bm spheral/grey04.bm
#   spheral/grey05.bm spheral/grey06.bm spheral/grey07.bm
#   spheral/grey08.bm spheral/grey09.bm spheral/grey10.bm
#   spheral/grey11.bm spheral/grey12.bm spheral/grey13.bm
#   spheral/grey14.bm spheral/grey15.bm spheral/grey16.bm
#   spheral/spheral.c spheral/spheral.h spheral/spheral.shp
#   spheral/test.c
# Wrapped by billr@saab on Mon Aug 30 08:05:07 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'spatial/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/Makefile'\"
else
echo shar: Extracting \"'spatial/Makefile'\" \(1391 characters\)
sed "s/^X//" >'spatial/Makefile' <<'END_OF_FILE'
X# The next lines define the directories where the executable, piece file,
X# and score file are installed. Change them to whatever is appropriate.
XDESTDIR = /tmp/dest
XDESTLIBDIR = $(DESTDIR)/lib
XDESTBINDIR = $(DESTDIR)/bin
XDESTMANDIR = $(DESTDIR)/man
X
XSCOREFILE = $(DESTLIBDIR)/spatial.sco
XPIECEFILE = $(DESTLIBDIR)/spatial.shp
X
XDEFINES =
X
X# uncomment the next line if your system doesn't have
X# random() and srandom()
X#DEFINES = -Drandom=lrand48 -Dsrandom=srand48
X
X# uncomment the next line for Solaris, which has neither
X# flock() nor random().
X#DEFINES = -DUSELOCKF -Drandom=lrand48 -Dsrandom=srand48
X
XINCLUDES = -I/usr/local/include
XXLIBS = -L/usr/local/lib -lX11
X
XOBJS = spatial.o disp.o game.o rots.o intro.o deco.o score.o
X
XCFLAGS= -O $(DEFINES) $(INCLUDES)  \
X   -DSCOREFILENAME=\"$(SCOREFILE)\"  \
X   -DPIECEFILENAME=\"$(PIECEFILE)\"
X
Xall: spatial
X
Xspatial: $(OBJS)
X	$(CC) $(CFLAGS) $(OBJS) -o spatial $(XLIBS) -lm 
X
Xspatial.o: spatial.c spatial.h
Xdisp.o: disp.c spatial.h
Xgame.o: game.c spatial.h
Xrots.o: rots.c spatial.h
Xintro.o: intro.c spatial.h
Xdeco.o: deco.c spatial.h
Xscore.o: score.c spatial.h
X
Xtargetdirs:
X	-mkdir $(DESTLIBDIR)
X	-mkdir $(DESTBINDIR)
X	-mkdir $(DESTMANDIR)
X	-mkdir $(DESTMANDIR)/man6
X
Xinstall: spatial  targetdirs
X	install -c -s spatial $(DESTBINDIR)
X	install -c spatial.shp  $(PIECEFILE)
X	install -c spatial.6 $(DESTMANDIR)/man6
X
Xclean: 
X	rm -f *.o spatial
X
END_OF_FILE
if test 1391 -ne `wc -c <'spatial/Makefile'`; then
    echo shar: \"'spatial/Makefile'\" unpacked with wrong size!
fi
# end of 'spatial/Makefile'
fi
if test -f 'spatial/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/README'\"
else
echo shar: Extracting \"'spatial/README'\" \(1083 characters\)
sed "s/^X//" >'spatial/README' <<'END_OF_FILE'
XSpatial: three-dimensional tetris.
X
X(C) Copyright 1991-3 Andrew Plotkin. (ap1i+@andrew.cmu.edu) 
XPermission is given to copy and use, as long as this copyright notice 
Xis retained.
X
XTo compile: change the first few lines of the Makefile to reflect
Xwhere you want the game installed.
X
XThe piece shape file *must* be
Xinstalled in the DESTLIBDIR you define in the Makefile.
XType "make install" to do this.
X(The score file, which in earlier versions had to be installed,
Xis now generated automatically if it does not exist.)
X
X------------------
X
XSome comments about porting to various systems: 
X(these are gathered from play-testing comments, and
Xhave not been tested)
X
XIf your system does not have random(), uncomment the line
X#DEFINES = -Drandom=lrand48 -Dsrandom=srand48
X
XIf your system does not have flock(), add -DUSELOCKF
Xto the DEFINES line.
X
XSolaris: Uncomment the line
X#DEFINES = -DUSELOCKF -Drandom=lrand48 -Dsrandom=srand48
Xin the Makefile.
X
XAIX on RS/6000: Add the line
X#include <sys/select.h> 
Xin game.c and intro.c.
X
XYou may have to add
X#include <sys/types.h>
Xon score.c.
X
END_OF_FILE
if test 1083 -ne `wc -c <'spatial/README'`; then
    echo shar: \"'spatial/README'\" unpacked with wrong size!
fi
# end of 'spatial/README'
fi
if test -f 'spatial/deco.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/deco.c'\"
else
echo shar: Extracting \"'spatial/deco.c'\" \(2259 characters\)
sed "s/^X//" >'spatial/deco.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <sys/time.h>
X#include <X11/Xlib.h>
X#include <X11/keysym.h>
X#include "spatial.h"
X
Xextern GC gcblack, gcwhite, gcinv, gccopy, gcline, gcfield, gccubes[]; 
X
Xextern void pause_redraw(), add_cubie();
X
Xvoid pauseloop()
X{
X    short status, res, lev;
X    short droptimer, stattick;
X    Bool eventp;
X    XEvent event, nextevent;
X    long evmasks;
X    char key;
X    KeySym ksym;
X    struct timeval timeout;
X
X    setup_fieldpm();
X    pause_redraw();
X    lev = 0;
X    droptimer=0;
X
X    while (1) {
X	evmasks = (KeyPressMask | ExposureMask | StructureNotifyMask);
X	eventp = XCheckWindowEvent(dpy, win, evmasks, &event);
X	if (eventp) switch (event.type) {
X	    case Expose:
X		eventp = XCheckWindowEvent(dpy, win, evmasks, &nextevent);
X		while (eventp && nextevent.type == Expose) {
X		    eventp = XCheckWindowEvent(dpy, win, evmasks, &nextevent);
X		};
X		if (eventp) {
X		    XPutBackEvent(dpy, &nextevent);
X		};
X		pause_redraw();
X		break;
X	    case KeyPress:
X		XLookupString(&event, &key, 1, &ksym, NULL);
X		/*printf("got '%s'\n", XKeysymToString(ksym));*/
X		switch (ksym) {
X		    case XK_Escape:
X		    case XK_Q:
X		    case XK_q:
X		    case XK_S:
X		    case XK_s:
X			return;
X			break;
X		}
X		break;
X	    case ConfigureNotify:
X		if (event.xconfigure.width != dispx || event.xconfigure.height != dispy) {
X		    dispx = event.xconfigure.width;
X		    dispy = event.xconfigure.height;
X		    XFreePixmap(dpy, backpm);
X		    XFreePixmap(dpy, fieldpm);
X		    backpm = XCreatePixmap(dpy, win, dispx, dispy,
X					   scndepth);   
X		    fieldpm = XCreatePixmap(dpy, win, dispx, dispy,
X					    scndepth);   
X		    redo_board_globals();
X		    setup_cubies();
X		    setup_fieldpm();
X		    pause_redraw();
X		}
X		break;
X	};
X	timeout.tv_sec = 0;
X	timeout.tv_usec = 50000;
X	select(0, 0, 0, 0, &timeout);	
X	droptimer++;
X	if (droptimer>=5) {
X	    droptimer=0;
X	    if (lev==fieldz) {
X		lev=0;
X		setup_fieldpm();
X		pause_redraw();
X	    }
X	    else {
X		add_cubie(random()%fieldx, random()%fieldy, lev);
X		pause_redraw();
X		lev++;
X	    }
X	}
X    }
X}
X
Xvoid pause_redraw()
X{
X    XCopyArea(dpy, fieldpm, win, gccopy, 0, 0, dispx, dispy, 0, 0);
X}
END_OF_FILE
if test 2259 -ne `wc -c <'spatial/deco.c'`; then
    echo shar: \"'spatial/deco.c'\" unpacked with wrong size!
fi
# end of 'spatial/deco.c'
fi
if test -f 'spatial/grey01.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey01.bm'\"
else
echo shar: Extracting \"'spatial/grey01.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey01.bm' <<'END_OF_FILE'
X#define grey01_width 16
X#define grey01_height 16
Xstatic char grey01_bits[] = {
X0xff,0xff,0xfd,0xfd,0xff,0xff,0xff,0xff,0xff,0xff,0xdf,0xdf,
X0xff,0xff,0xff,0xff,0xff,0xff,0xfd,0xfd,0xff,0xff,0xff,0xff,
X0xff,0xff,0xdf,0xdf,0xff,0xff,0xff,0xff};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey01.bm'`; then
    echo shar: \"'spatial/grey01.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey01.bm'
fi
if test -f 'spatial/grey02.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey02.bm'\"
else
echo shar: Extracting \"'spatial/grey02.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey02.bm' <<'END_OF_FILE'
X#define grey02_width 16
X#define grey02_height 16
Xstatic char grey02_bits[] = {
X0xff,0xff,0xdf,0xdf,0xff,0xff,0xfd,0xfd,0xff,0xff,0xdf,0xdf,
X0xff,0xff,0xfd,0xfd,0xff,0xff,0xdf,0xdf,0xff,0xff,0xfd,0xfd,
X0xff,0xff,0xdf,0xdf,0xff,0xff,0xfd,0xfd};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey02.bm'`; then
    echo shar: \"'spatial/grey02.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey02.bm'
fi
if test -f 'spatial/grey03.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey03.bm'\"
else
echo shar: Extracting \"'spatial/grey03.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey03.bm' <<'END_OF_FILE'
X#define grey03_width 16
X#define grey03_height 16
Xstatic char grey03_bits[] = {
X0xff,0xff,0xdd,0xdd,0xff,0xff,0xff,0xff,0xff,0xff,0xdd,0xdd,
X0xff,0xff,0xff,0xff,0xff,0xff,0xdd,0xdd,0xff,0xff,0xff,0xff,
X0xff,0xff,0xdd,0xdd,0xff,0xff,0xff,0xff};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey03.bm'`; then
    echo shar: \"'spatial/grey03.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey03.bm'
fi
if test -f 'spatial/grey04.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey04.bm'\"
else
echo shar: Extracting \"'spatial/grey04.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey04.bm' <<'END_OF_FILE'
X#define grey04_width 16
X#define grey04_height 16
Xstatic char grey04_bits[] = {
X0xee,0xee,0xff,0xff,0xbb,0xbb,0xff,0xff,0xee,0xee,0xff,0xff,
X0xbb,0xbb,0xff,0xff,0xee,0xee,0xff,0xff,0xbb,0xbb,0xff,0xff,
X0xee,0xee,0xff,0xff,0xbb,0xbb,0xff,0xff};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey04.bm'`; then
    echo shar: \"'spatial/grey04.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey04.bm'
fi
if test -f 'spatial/grey05.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey05.bm'\"
else
echo shar: Extracting \"'spatial/grey05.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey05.bm' <<'END_OF_FILE'
X#define grey05_width 16
X#define grey05_height 16
Xstatic char grey05_bits[] = {
X0xff,0xff,0x55,0x55,0xff,0xff,0xdd,0xdd,0xff,0xff,0x55,0x55,
X0xff,0xff,0xdd,0xdd,0xff,0xff,0x55,0x55,0xff,0xff,0xdd,0xdd,
X0xff,0xff,0x55,0x55,0xff,0xff,0xdd,0xdd};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey05.bm'`; then
    echo shar: \"'spatial/grey05.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey05.bm'
fi
if test -f 'spatial/grey06.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey06.bm'\"
else
echo shar: Extracting \"'spatial/grey06.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey06.bm' <<'END_OF_FILE'
X#define grey06_width 16
X#define grey06_height 16
Xstatic char grey06_bits[] = {
X0xff,0xff,0x55,0x55,0xff,0xff,0xbb,0xbb,0xff,0xff,0x55,0x55,
X0xff,0xff,0xee,0xee,0xff,0xff,0x55,0x55,0xff,0xff,0xbb,0xbb,
X0xff,0xff,0x55,0x55,0xff,0xff,0xee,0xee};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey06.bm'`; then
    echo shar: \"'spatial/grey06.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey06.bm'
fi
if test -f 'spatial/grey07.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey07.bm'\"
else
echo shar: Extracting \"'spatial/grey07.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey07.bm' <<'END_OF_FILE'
X#define grey07_width 16
X#define grey07_height 16
Xstatic char grey07_bits[] = {
X0xff,0xff,0x55,0x55,0xff,0xff,0x55,0x55,0xff,0xff,0x55,0x55,
X0xff,0xff,0x55,0x55,0xff,0xff,0x55,0x55,0xff,0xff,0x55,0x55,
X0xff,0xff,0x55,0x55,0xff,0xff,0x55,0x55};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey07.bm'`; then
    echo shar: \"'spatial/grey07.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey07.bm'
fi
if test -f 'spatial/grey08.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey08.bm'\"
else
echo shar: Extracting \"'spatial/grey08.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey08.bm' <<'END_OF_FILE'
X#define grey08_width 16
X#define grey08_height 16
Xstatic char grey08_bits[] = {
X0xdd,0xdd,0x77,0x77,0xdd,0xdd,0x77,0x77,0xdd,0xdd,0x77,0x77,
X0xdd,0xdd,0x77,0x77,0xdd,0xdd,0x77,0x77,0xdd,0xdd,0x77,0x77,
X0xdd,0xdd,0x77,0x77,0xdd,0xdd,0x77,0x77};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey08.bm'`; then
    echo shar: \"'spatial/grey08.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey08.bm'
fi
if test -f 'spatial/grey09.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey09.bm'\"
else
echo shar: Extracting \"'spatial/grey09.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey09.bm' <<'END_OF_FILE'
X#define grey09_width 16
X#define grey09_height 16
Xstatic char grey09_bits[] = {
X0xff,0xff,0x55,0x55,0xfb,0xfb,0x55,0x55,0xff,0xff,0x55,0x55,
X0xbf,0xbf,0x55,0x55,0xff,0xff,0x55,0x55,0xfb,0xfb,0x55,0x55,
X0xff,0xff,0x55,0x55,0xbf,0xbf,0x55,0x55};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey09.bm'`; then
    echo shar: \"'spatial/grey09.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey09.bm'
fi
if test -f 'spatial/grey10.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey10.bm'\"
else
echo shar: Extracting \"'spatial/grey10.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey10.bm' <<'END_OF_FILE'
X#define grey10_width 16
X#define grey10_height 16
Xstatic char grey10_bits[] = {
X0xee,0xee,0x55,0x55,0xff,0xff,0x55,0x55,0xee,0xee,0x55,0x55,
X0xff,0xff,0x55,0x55,0xee,0xee,0x55,0x55,0xff,0xff,0x55,0x55,
X0xee,0xee,0x55,0x55,0xff,0xff,0x55,0x55};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey10.bm'`; then
    echo shar: \"'spatial/grey10.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey10.bm'
fi
if test -f 'spatial/grey11.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey11.bm'\"
else
echo shar: Extracting \"'spatial/grey11.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey11.bm' <<'END_OF_FILE'
X#define grey11_width 16
X#define grey11_height 16
Xstatic char grey11_bits[] = {
X0xee,0xee,0x55,0x55,0xfb,0xfb,0x55,0x55,0xee,0xee,0x55,0x55,
X0xbf,0xbf,0x55,0x55,0xee,0xee,0x55,0x55,0xfb,0xfb,0x55,0x55,
X0xee,0xee,0x55,0x55,0xbf,0xbf,0x55,0x55};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey11.bm'`; then
    echo shar: \"'spatial/grey11.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey11.bm'
fi
if test -f 'spatial/grey12.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey12.bm'\"
else
echo shar: Extracting \"'spatial/grey12.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey12.bm' <<'END_OF_FILE'
X#define grey12_width 16
X#define grey12_height 16
Xstatic char grey12_bits[] = {
X0x55,0x55,0xee,0xee,0x55,0x55,0xbb,0xbb,0x55,0x55,0xee,0xee,
X0x55,0x55,0xbb,0xbb,0x55,0x55,0xee,0xee,0x55,0x55,0xbb,0xbb,
X0x55,0x55,0xee,0xee,0x55,0x55,0xbb,0xbb};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey12.bm'`; then
    echo shar: \"'spatial/grey12.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey12.bm'
fi
if test -f 'spatial/grey13.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey13.bm'\"
else
echo shar: Extracting \"'spatial/grey13.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey13.bm' <<'END_OF_FILE'
X#define grey13_width 16
X#define grey13_height 16
Xstatic char grey13_bits[] = {
X0x55,0x55,0xee,0xee,0x55,0x55,0xba,0xba,0x55,0x55,0xee,0xee,
X0x55,0x55,0xab,0xab,0x55,0x55,0xee,0xee,0x55,0x55,0xba,0xba,
X0x55,0x55,0xee,0xee,0x55,0x55,0xab,0xab};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey13.bm'`; then
    echo shar: \"'spatial/grey13.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey13.bm'
fi
if test -f 'spatial/grey14.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey14.bm'\"
else
echo shar: Extracting \"'spatial/grey14.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey14.bm' <<'END_OF_FILE'
X#define grey14_width 16
X#define grey14_height 16
Xstatic char grey14_bits[] = {
X0x57,0x57,0xaa,0xaa,0x75,0x75,0xaa,0xaa,0x57,0x57,0xaa,0xaa,
X0x75,0x75,0xaa,0xaa,0x57,0x57,0xaa,0xaa,0x75,0x75,0xaa,0xaa,
X0x57,0x57,0xaa,0xaa,0x75,0x75,0xaa,0xaa};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey14.bm'`; then
    echo shar: \"'spatial/grey14.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey14.bm'
fi
if test -f 'spatial/grey15.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey15.bm'\"
else
echo shar: Extracting \"'spatial/grey15.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey15.bm' <<'END_OF_FILE'
X#define grey15_width 16
X#define grey15_height 16
Xstatic char grey15_bits[] = {
X0x55,0x55,0xae,0xae,0x55,0x55,0xaa,0xaa,0x55,0x55,0xea,0xea,
X0x55,0x55,0xaa,0xaa,0x55,0x55,0xae,0xae,0x55,0x55,0xaa,0xaa,
X0x55,0x55,0xea,0xea,0x55,0x55,0xaa,0xaa};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey15.bm'`; then
    echo shar: \"'spatial/grey15.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey15.bm'
fi
if test -f 'spatial/grey16.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/grey16.bm'\"
else
echo shar: Extracting \"'spatial/grey16.bm'\" \(243 characters\)
sed "s/^X//" >'spatial/grey16.bm' <<'END_OF_FILE'
X#define grey16_width 16
X#define grey16_height 16
Xstatic char grey16_bits[] = {
X0x55,0x55,0xaa,0xaa,0x55,0x55,0xaa,0xaa,0x55,0x55,0xaa,0xaa,
X0x55,0x55,0xaa,0xaa,0x55,0x55,0xaa,0xaa,0x55,0x55,0xaa,0xaa,
X0x55,0x55,0xaa,0xaa,0x55,0x55,0xaa,0xaa};
END_OF_FILE
if test 243 -ne `wc -c <'spatial/grey16.bm'`; then
    echo shar: \"'spatial/grey16.bm'\" unpacked with wrong size!
fi
# end of 'spatial/grey16.bm'
fi
if test -f 'spatial/score.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/score.c'\"
else
echo shar: Extracting \"'spatial/score.c'\" \(3766 characters\)
sed "s/^X//" >'spatial/score.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <errno.h>
X#include <ctype.h> 
X#include <pwd.h>    
X#include <sys/file.h>
X#include <X11/Xlib.h>
X#ifdef AFS
X#include <niftyprofile.h>    
X#endif
X#include "spatial.h"
X
Xextern char *getenv();
Xchar ProgramName[] = "spatial";
X
Xgamer hscores[NUMGAMERS];
Xchar hscorefl[512];
Xchar userid[16], gamename[16];
X
Xextern int errno;
X
Xvoid load_hscores(save)
Xint save;
X{
X    FILE *fl;
X    register int ix, jx;
X    int fd, res;
X    char buf[255];
X
X    fl = fopen(hscorefl, "r+");
X    if (!fl) {
X	fprintf(stderr,
X	    "spatial: unable to open high score file\n");
X	fprintf(stderr,
X	    "spatial: generating empty score file\n");
X
X	fl = fopen(hscorefl, "w");
X	if (!fl) {
X	    fprintf(stderr,
X		    "spatial: unable to create high score file\n");
X	    exit(-1);
X	}
X
X	for (ix=0; ix<NUMGAMERS; ix++) {
X	    fprintf(fl, "----\nSpatial\n0\n");
X	}
X	fclose(fl);
X	fl = fopen(hscorefl, "r+");
X	if (!fl) {
X	    fprintf(stderr,
X		    "spatial: unable to reopen high score file\n");
X	    exit(-1);
X	}
X    }
X
X    fd = fileno(fl);
X#ifdef USELOCKF
X    res = lockf(fd, F_LOCK, 0);
X#else
X    res = flock(fd, LOCK_NB | LOCK_EX);
X#endif
X    while (res) {
X	if (errno != EWOULDBLOCK) {
X	    fprintf(stderr,
X		    "spatial: unable to lock high score file\n");
X	    exit(-1);
X	};
X	sleep(1);
X#ifdef USELOCKF
X	res = lockf(fd, F_LOCK, 0);
X#else
X	res = flock(fd, LOCK_NB | LOCK_EX);
X#endif
X    };
X
X    for (ix=0; ix<NUMGAMERS; ix++) {
X	long val;
X
X	fgets(buf, 255, fl);
X	for (jx=0; jx<15 && buf[jx]!='\n'; jx++) 
X	    hscores[ix].userid[jx] = buf[jx];
X	hscores[ix].userid[jx] = '\0';
X	
X	fgets(buf, 255, fl);
X	for (jx=0; jx<15 && buf[jx]!='\n'; jx++) 
X	    hscores[ix].name[jx] = buf[jx];
X	hscores[ix].name[jx] = '\0';
X	
X	fgets(buf, 255, fl);
X	val=0;
X	for (jx=0; buf[jx]!='\n'; jx++) 
X	    val = val*10 + buf[jx] - '0';
X	hscores[ix].score = val;
X	sprintf(hscores[ix].scoret, "%d", val);
X    };
X
X    if (save) {
X	if (checkmod_scores()) {
X	    rewind(fl);
X	    for (ix=0; ix<NUMGAMERS; ix++) {
X		fprintf(fl, "%s\n%s\n%d\n", hscores[ix].userid,
X			hscores[ix].name, hscores[ix].score);
X	    }
X	}
X    }
X
X#ifdef USELOCKF
X    lockf(fd, F_ULOCK, 0);
X#else
X    flock(fd, LOCK_UN);
X#endif
X
X    fclose(fl);
X}
X
Xint checkmod_scores()
X{
X    register int ix;
X    int new, bottom;
X    
X    if (score <= hscores[NUMGAMERS-1].score) return 0;
X    
X    for (ix=0; strcmp(hscores[ix].userid, userid)
X      && ix<NUMGAMERS; ix++);
X    
X    if (ix<NUMGAMERS) { /* was in list */
X	if (score <= hscores[ix].score) return 0;
X	bottom = ix;
X    }
X    else { /* wasn't in list */
X	bottom = NUMGAMERS-1;
X    };
X
X    for (new=0; score<=hscores[new].score; new++);
X    for (ix=bottom; ix>new; ix--) {
X	strcpy(hscores[ix].name, hscores[ix-1].name);
X	strcpy(hscores[ix].userid, hscores[ix-1].userid);
X	strcpy(hscores[ix].scoret, hscores[ix-1].scoret);
X	hscores[ix].score = hscores[ix-1].score;
X    };
X    strcpy(hscores[new].name, gamename);
X    strcpy(hscores[new].userid, userid);
X    hscores[new].score = score;
X    sprintf(hscores[new].scoret, "%d", score);
X
X    return 1;
X}
X
Xvoid get_names()
X{
X    register int ix;
X    struct passwd *tp;
X    char *tcp;
X
X    strcpy(hscorefl, SCOREFILENAME);
X
X    tp = getpwuid(getuid());
X    if (!tp) {
X	printf("unable to get userid!\n");
X	strcpy(userid, "????");
X    }
X    else {
X	strncpy(userid, tp->pw_name, 16);
X	userid[15] = '\0';
X    }
X
X    tcp = getenv("NAME");
X    if (tcp) {
X	strncpy(gamename, tcp, 16);
X	gamename[15] = '\0';
X    }
X    else if (tcp=XGetDefault(dpy, "spatial", "name")) {
X	strncpy(gamename, tcp, 16);
X	gamename[15] = '\0';
X    }
X    else {
X	strcpy(gamename, userid);
X    };
X
X    printf("Welcome, %s (%s)\n", gamename, userid);
X}
END_OF_FILE
if test 3766 -ne `wc -c <'spatial/score.c'`; then
    echo shar: \"'spatial/score.c'\" unpacked with wrong size!
fi
# end of 'spatial/score.c'
fi
if test -f 'spatial/spatial.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/spatial.6'\"
else
echo shar: Extracting \"'spatial/spatial.6'\" \(1953 characters\)
sed "s/^X//" >'spatial/spatial.6' <<'END_OF_FILE'
X.PU
X.TH SPATIAL 6 contributed
X.SH NAME
Xspatial  \-  three-dimensional Tetris on a cubic lattice
X.SH SYNOPSIS
X.B spatial
X[ 
X.I -m
X]
X.PP
X.B -m
X: Force monochrome mode, even on color displays.
X.SH DESCRIPTION
XIf you don't know the rules of Tetris by now, you're beyond hope.
X.PP
XYou are looking down; pieces appear directly in front of you
Xand fall away from you. The current piece is transparent;
Xwhen it lands, it becomes opaque. You must complete an entire
Xlayer (25 cubes) to make it disappear.
X.PP
XThe bottom of the game display shows your score, and also
Xa meter which indicates how high the pieces are stacked on
Xthe board.
X.PP
XYou can resize the window, and the board will be scaled
Xappropriately. (The high-score list doesn't behave so
Xcleverly.)
X.PP
XBy hitting
X.B c
Xat the title screen, you can play the game with a stereoscopic
Xdisplay. Both "normal" stereoscopic mode (where you stare
Xoff into infinity) and "reversed" mode (where you cross your
Xeyes and stare two inches ahead of your nose) are available.
XReducing the window size may make this easier to use.
X.SH CONTROLS
X.B h, l, i, m, j, k
X: rotate the current piece. The control of rotation around three
Xspatial axes is nigh impossible to describe. See the title
Xscreen for a picture that may help.
X.br
X.I ARROW KEYS
X: slide the current piece north, south, east, or west.
X.br
X.B p
X: drop the current piece one space down.
X.br
X.I SPACE
X: drop the current piece all the way to the bottom of the
Xboard.
X.br
X.I ESCAPE
X: pause the game, and draw pretty random cubes until
Xyou hit
X.I ESCAPE
Xagain.
X.br
X.B q
X: quit the current game with your current score. Hitting
X.B q
Xagain, from the title screen, will exit the program.
X.SH BUGS
XThe stereoscopic mode may cause your brain to dump
Xcore.
X.SH AUTHOR
XAndrew Plotkin <ap1i+@andrew.cmu.edu>
X.br
XThis program is (C) Copyright 1991-3 Andrew Plotkin.
X.br
XPermission is given to copy and distribute freely, as long
Xas this copyright notice is retained.
END_OF_FILE
if test 1953 -ne `wc -c <'spatial/spatial.6'`; then
    echo shar: \"'spatial/spatial.6'\" unpacked with wrong size!
fi
# end of 'spatial/spatial.6'
fi
if test -f 'spatial/spatial.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/spatial.c'\"
else
echo shar: Extracting \"'spatial/spatial.c'\" \(1192 characters\)
sed "s/^X//" >'spatial/spatial.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
Xgiven to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <X11/Xlib.h>
X#include "spatial.h"
X#include "patchlevel.h"
X
X#define INITWINSIZEX (720)
X#define INITWINSIZEY (740)
X
Xextern void srandom();
X
Xextern double focallen;
Xextern int forcemono;
X
Xextern void xinit(), loadpieces(), gameloop(),
Xinitintro(), introloop(), get_names(), load_hscores(),
Xredo_board_globals();
Xextern int checkmod_scores();
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X    int ix;
X
X    srandom(getpid());
X
X    for (ix=1; ix<argc; ix++) {
X	if (strcmp(argv[ix], "-m")) {
X	    fprintf(stderr, "usage: spatial [ -m ]\n");
X	    exit(-1);
X	}
X	else
X	    forcemono = 1;
X    }
X
X    loadpieces(PIECEFILENAME);
X    fieldx = 5;
X    fieldy = 5;
X    fieldz = 11;
X    fieldoffx = -2.5;
X    fieldoffy = -2.5;
X    fieldoffz = -4.0-(double)fieldz;
X    focallen = 1.0;
X    stereo = 0;
X    dispx = INITWINSIZEX;
X    dispy = INITWINSIZEY;
X    redo_board_globals();
X    xinit();
X    get_names();
X    load_hscores(0);
X    while (1) {
X	initintro();
X	introloop();
X	initgame();
X	gameloop();
X	if (checkmod_scores()) {
X	    load_hscores(1);
X	}
X    }
X}
END_OF_FILE
if test 1192 -ne `wc -c <'spatial/spatial.c'`; then
    echo shar: \"'spatial/spatial.c'\" unpacked with wrong size!
fi
# end of 'spatial/spatial.c'
fi
if test -f 'spatial/spatial.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spatial/spatial.h'\"
else
echo shar: Extracting \"'spatial/spatial.h'\" \(2394 characters\)
sed "s/^X//" >'spatial/spatial.h' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#define MAXFIELDWIDTH (10)
X#define MAXFIELDDEPTH (10)
X
X#define MAXFIELDXY (10)
X#define MAXFIELDZ (15)
X
X#define MAXCUBES (8)
X#define MAXVERTS (30)
X#define MAXPOINTS (MAXCUBES+MAXVERTS)
X#define MAXEDGES (40)
X#define MAXPIECES (30)
X
X#define NUMGAMERS (20)
X
X#define F_OFF (0)
X#define F_ON (1)
X#define F_TEMP (2)
X
X#define CUF_SIDEX (1)
X#define CUF_SIDEY (2)
X
Xtypedef struct _point {
X    double x, y, z, w;
X} point;
X
Xtypedef struct _edge {
X    short head, tail;
X} edge;
X
Xtypedef double matrix[4][4];
X
Xtypedef XPoint fieldplist[MAXFIELDXY+1][MAXFIELDXY+1][MAXFIELDZ+1];
X
Xtypedef struct _piecelist {
X    short numcubes;
X    short numverts;
X    short numpoints;  /* sum of cubes and verts */
X    short numedges;
X    point *verts;     /* set to &(points[numcubes]) */
X    point points[MAXPOINTS];
X    edge edges[MAXEDGES];
X} piecelist;
X
Xtypedef struct _gamer {
X    char userid[16];
X    char name[16];
X    long score;
X    char scoret[16];
X} gamer;
X
Xextern gamer hscores[NUMGAMERS];
X
Xextern piecelist pieces[MAXPIECES];
X
Xextern unsigned char field[MAXFIELDXY][MAXFIELDXY][MAXFIELDZ];
Xextern fieldplist fieldpts;
Xextern fieldplist fieldpts2;
X
Xextern short fieldx, fieldy, fieldz;
Xextern double fieldoffx, fieldoffx2, fieldoffy, fieldoffz;
Xextern int meterx, meterx2, metery, metersize,
Xmeterlev, meteroldlev, meter_f_b, meter_b_d;
X/* oldlev is level on fieldpm */
X
Xextern short numpieces;
Xextern short curpiece;
X
Xextern int colors[];
X
Xextern Display *dpy;
Xextern Window win;
Xextern int scndepth;
X
Xextern int stereo;
Xextern int dispx, dispy; /* size of window */
Xextern Pixmap backpm; /* size of window */
Xextern int shapex1, shapex2, shapey1, shapey2;
X/* coords of rectangle of backpm that is different from fieldpm */
Xextern int ddispx1, ddispx2, ddispy1, ddispy2;
X/* coords of rectangle of display that is different from fieldpm */
Xextern Pixmap fieldpm; /* size of window */
Xextern long score, dropticks;
Xextern double boardscale;
Xextern int halfboard, halfboard2;
X
Xextern void clearfield();
X/* zero out field[][][] */
Xextern void setup_fieldpm();
X/* clear, draw field box and side text. Also set
X shape{x,y}{1,2} to window size */
Xextern void startpiece();
X/* pick a piece and put it in the pipeline */
Xextern long current_usec();
Xextern int elapsed();
X
Xextern long random();
END_OF_FILE
if test 2394 -ne `wc -c <'spatial/spatial.h'`; then
    echo shar: \"'spatial/spatial.h'\" unpacked with wrong size!
fi
# end of 'spatial/spatial.h'
fi
if test -f 'spheral/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/README'\"
else
echo shar: Extracting \"'spheral/README'\" \(1113 characters\)
sed "s/^X//" >'spheral/README' <<'END_OF_FILE'
XSpheral: three-dimensional tetris based on close-packed spheres.
X
X(C) Copyright 1991-3 Andrew Plotkin. (ap1i+@andrew.cmu.edu) 
XPermission is given to copy and use, as long as this copyright notice 
Xis retained.
X
XTo compile: change the first few lines of the Makefile to reflect
Xwhere you want the game installed.
X
XThe piece shape file *must* be
Xinstalled in the DESTLIBDIR you define in the Makefile.
XType "make install" to do this.
X(The score file, which in earlier versions had to be installed,
Xis now generated automatically if it does not exist.)
X
X------------------
X
XSome comments about porting to various systems: 
X(these are gathered from play-testing comments, and
Xhave not been tested)
X
XIf your system does not have random(), uncomment the line
X#DEFINES = -Drandom=lrand48 -Dsrandom=srand48
X
XIf your system does not have flock(), add -DUSELOCKF
Xto the DEFINES line.
X
XSolaris: Uncomment the line
X#DEFINES = -DUSELOCKF -Drandom=lrand48 -Dsrandom=srand48
Xin the Makefile.
X
XAIX on RS/6000: Add the line
X#include <sys/select.h> 
Xin game.c and intro.c.
X
XYou may have to add
X#include <sys/types.h>
Xon score.c.
X
END_OF_FILE
if test 1113 -ne `wc -c <'spheral/README'`; then
    echo shar: \"'spheral/README'\" unpacked with wrong size!
fi
# end of 'spheral/README'
fi
if test -f 'spheral/deco.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/deco.c'\"
else
echo shar: Extracting \"'spheral/deco.c'\" \(2338 characters\)
sed "s/^X//" >'spheral/deco.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <sys/time.h>
X#include <X11/Xlib.h>
X#include <X11/keysym.h>
X#include "spheral.h"
X
Xextern GC gccopy; 
X
Xextern void pause_redraw(), add_ball(), setup_fieldpts(),
Xsetup_fieldpm();
X
Xvoid pauseloop()
X{
X    short status, res, lev;
X    short droptimer, stattick;
X    Bool eventp;
X    XEvent event, nextevent;
X    long evmasks;
X    char key;
X    KeySym ksym;
X    struct timeval timeout;
X
X    setup_fieldpm();
X    pause_redraw();
X    lev = 0;
X    droptimer=0;
X
X    while (1) {
X	evmasks = (KeyPressMask | ExposureMask | StructureNotifyMask);
X	eventp = XCheckWindowEvent(dpy, win, evmasks, &event);
X	if (eventp) switch (event.type) {
X	    case Expose:
X		eventp = XCheckWindowEvent(dpy, win, evmasks, &nextevent);
X		while (eventp && nextevent.type == Expose) {
X		    eventp = XCheckWindowEvent(dpy, win, evmasks, &nextevent);
X		};
X		if (eventp) {
X		    XPutBackEvent(dpy, &nextevent);
X		};
X		pause_redraw();
X		break;
X	    case KeyPress:
X		XLookupString(&event, &key, 1, &ksym, NULL);
X		/*printf("got '%s'\n", XKeysymToString(ksym));*/
X		switch (ksym) {
X		    case XK_Escape:
X		    case XK_Q:
X		    case XK_S:
X		    case XK_s:
X			return;
X			break;
X		}
X		break;
X	    case ConfigureNotify:
X		if (event.xconfigure.width != dispx
X		    || event.xconfigure.height != dispy) {
X		    dispx = event.xconfigure.width;
X		    dispy = event.xconfigure.height;
X		    XFreePixmap(dpy, backpm);
X		    XFreePixmap(dpy, fieldpm);
X		    backpm = XCreatePixmap(dpy, win, dispx,
X					   dispy, scndepth);   
X		    fieldpm = XCreatePixmap(dpy, win, dispx,
X					    dispy, scndepth);   
X		    redo_board_globals();
X		    setup_fieldpts();
X		    setup_fieldpm();
X		    pause_redraw();
X		}
X		break;
X	};
X	timeout.tv_sec = 0;
X	timeout.tv_usec = 100000;
X	select(0, 0, 0, 0, &timeout);	
X	droptimer++;
X	if (droptimer>=3) {
X	    droptimer=0;
X	    if (lev==fieldz) {
X		lev=0;
X		setup_fieldpm();
X		pause_redraw();
X	    }
X	    else {
X		int val;
X		val = random()%fieldx;
X		add_ball(val, random()%(fieldx-val), lev);
X		val = random()%fieldx;
X		add_ball(val, random()%(fieldx-val), lev);
X		pause_redraw();
X		lev++;
X	    }
X	}
X    }
X}
X
Xvoid pause_redraw()
X{
X    XCopyArea(dpy, fieldpm, win, gccopy, 0, 0,
X	      dispx, dispy, 0, 0);
X}
END_OF_FILE
if test 2338 -ne `wc -c <'spheral/deco.c'`; then
    echo shar: \"'spheral/deco.c'\" unpacked with wrong size!
fi
# end of 'spheral/deco.c'
fi
if test -f 'spheral/errdi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/errdi.c'\"
else
echo shar: Extracting \"'spheral/errdi.c'\" \(2269 characters\)
sed "s/^X//" >'spheral/errdi.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <math.h>    
X#include <X11/Xlib.h>
X#include "spheral.h"
X
X#define GRIDSIZE (NUMBALLSIZES)
X#define GREYS (64)
X
XPixmap ballpm[NUMBALLSIZES][NUMSHADES];
Xshort ballpmflag[NUMBALLSIZES][NUMSHADES];
X
Xint errdiflag = 0;
X
Xextern GC gcblack, gcwhite;
X
Xvoid init_ballpmflags()
X{
X    register int ix, jx;
X
X    for (ix=0; ix<NUMBALLSIZES; ix++) 
X	for (jx=0; jx<NUMSHADES; jx++) {
X	    ballpmflag[ix][jx] = 0;
X	}
X}
X
Xvoid create_ballpm(rad, shad)
Xint rad, shad;
X{
X    static short grid[GRIDSIZE*2][GRIDSIZE*2];
X    static int shades[NUMSHADES] = {9, 20, 31, 44};
X    static double xl=0.5, yl=0.3, zl=0.81240384;
X
X    static XPoint *pts = NULL;
X    int numpts = 0;
X
X    register int ix, iy;
X    double r;
X    int ir;
X    double xd, yd, zd;
X    int lowshad = shades[shad];
X    Pixmap pm;
X
X    if (ballpmflag[rad][shad]) return;
X
X    if (!pts) {
X	pts = (XPoint *)malloc(sizeof(XPoint) * 52000);
X    };
X
X    pm = XCreatePixmap(dpy, win, rad*2, rad*2, scndepth);
X
X    for (ix=GRIDSIZE-rad; ix<GRIDSIZE+rad; ix++) 
X	for (iy=GRIDSIZE-rad; iy<GRIDSIZE+rad; iy++) {
X	    r = ((double)((ix-GRIDSIZE)*(ix-GRIDSIZE) +
X		(iy-GRIDSIZE)*(iy-GRIDSIZE))) / (double)(rad*rad);
X	    if (r>1.0) grid[ix][iy] = 0;
X	    else {
X		xd = (double)(GRIDSIZE-ix)/(double)rad;
X		yd = (double)(GRIDSIZE-iy)/(double)rad;
X		zd = sqrt(1.0001-xd*xd-yd*yd);
X
X		ir = (int)(15.0 * (xl*xd+yl*yd+zl*zd));
X		if (ir<0) ir=0;
X		else if (ir+lowshad >= GREYS) ir=GREYS-lowshad;
X		grid[ix][iy] = lowshad + ir;
X		/*grid[ix][iy] = (ir%2)*GREYS;*/
X	    }
X	    grid[ix][iy] += (7*grid[ix-1][iy] + 1*grid[ix-1][iy-1] +
X		5*grid[ix][iy-1] + 3*grid[ix+1][iy-1]) / 16;
X	    if (grid[ix][iy]>=(GREYS/2)) {
X		/*XDrawPoint(dpy, pm, gcwhite, rad+ix-GRIDSIZE,
X		 rad+iy-GRIDSIZE);*/
X		pts[numpts].x = rad+ix-GRIDSIZE;
X		pts[numpts].y = rad+iy-GRIDSIZE;
X		numpts++;
X		grid[ix][iy] -= GREYS;
X	    }
X	    /*else {
X		XDrawPoint(dpy, pm, gcblack,
X	        rad+ix-GRIDSIZE, rad+iy-GRIDSIZE);
X	    };*/
X
X	}
X
X    XFillRectangle(dpy, pm, gcblack, 0, 0, rad*2, rad*2);
X    XDrawPoints(dpy, pm, gcwhite, pts, numpts,
X		CoordModeOrigin);
X
X    ballpm[rad][shad] = pm;
X    ballpmflag[rad][shad] = 1;
X}
END_OF_FILE
if test 2269 -ne `wc -c <'spheral/errdi.c'`; then
    echo shar: \"'spheral/errdi.c'\" unpacked with wrong size!
fi
# end of 'spheral/errdi.c'
fi
if test -f 'spheral/gcgrey.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/gcgrey.c'\"
else
echo shar: Extracting \"'spheral/gcgrey.c'\" \(3773 characters\)
sed "s/^X//" >'spheral/gcgrey.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <X11/Xlib.h>
X#include "spheral.h"
X#include "grey01.bm"
X#include "grey02.bm"
X#include "grey03.bm"
X#include "grey04.bm"
X#include "grey05.bm"
X#include "grey06.bm"
X#include "grey07.bm"
X#include "grey08.bm"
X#include "grey09.bm"
X#include "grey10.bm"
X#include "grey11.bm"
X#include "grey12.bm"
X#include "grey13.bm"
X#include "grey14.bm"
X#include "grey15.bm"
X#include "grey16.bm"
X
Xextern GC gcballs[16];
X
Xvoid setup_grey()
X{
X    Pixmap greypm[16];
X    register int ix;
X    XGCValues gcvalues;
X    Status res;
X    XColor col, sccol;
X    static unsigned short colvalues[16][3] = {
X	{0x6000, 0xA000, 0x6000}, /* green grey */
X	{0x6000, 0x6000, 0xA000}, /* blue grey */
X	{0xC000, 0x0000, 0x0000}, /* red */
X	{0xAA00, 0x8000, 0x0000}, /* orange */
X	{0xC000, 0xC000, 0x0000}, /* yellow */
X	{0x0000, 0xC000, 0x0000}, /* green */
X	{0x0000, 0x0000, 0xFF00}, /* blue */
X	{0x8000, 0x0000, 0xC000}, /* purple */
X	{0xFF00, 0x6000, 0x6000}, /* light red */
X	{0x8000, 0x8000, 0xFF00}, /* light blue */
X	{0xC000, 0xC000, 0xC000},  /* light grey */
X	{0x6000, 0xA000, 0x6000}, /* green grey */
X	{0x6000, 0x6000, 0xA000}, /* blue grey */
X	{0xC000, 0x0000, 0x0000}, /* red */
X	{0xAA00, 0x8000, 0x0000}  /* orange */
X    };
X
X    if (monomode) {
X	greypm[0] = XCreatePixmapFromBitmapData(dpy, win, grey01_bits,
X	grey01_width, grey01_height, 0, 1, 1);
X	greypm[1] = XCreatePixmapFromBitmapData(dpy, win, grey02_bits,
X	grey02_width, grey02_height, 0, 1, 1);
X	greypm[2] = XCreatePixmapFromBitmapData(dpy, win, grey03_bits,
X	grey03_width, grey03_height, 0, 1, 1);
X	greypm[3] = XCreatePixmapFromBitmapData(dpy, win, grey04_bits,
X	grey04_width, grey04_height, 0, 1, 1);
X	greypm[4] = XCreatePixmapFromBitmapData(dpy, win, grey05_bits,
X	grey05_width, grey05_height, 0, 1, 1);
X	greypm[5] = XCreatePixmapFromBitmapData(dpy, win, grey06_bits,
X	grey06_width, grey06_height, 0, 1, 1);
X	greypm[6] = XCreatePixmapFromBitmapData(dpy, win, grey07_bits,
X	grey07_width, grey07_height, 0, 1, 1);
X	greypm[7] = XCreatePixmapFromBitmapData(dpy, win, grey08_bits,
X	grey08_width, grey08_height, 0, 1, 1);
X	greypm[8] = XCreatePixmapFromBitmapData(dpy, win, grey09_bits,
X	grey09_width, grey09_height, 0, 1, 1);
X	greypm[9] = XCreatePixmapFromBitmapData(dpy, win, grey10_bits,
X	grey10_width, grey10_height, 0, 1, 1);
X	greypm[10] = XCreatePixmapFromBitmapData(dpy, win, grey11_bits,
X	 grey11_width, grey11_height, 0, 1, 1);
X	greypm[11] = XCreatePixmapFromBitmapData(dpy, win, grey12_bits,
X	 grey12_width, grey12_height, 0, 1, 1);
X	greypm[12] = XCreatePixmapFromBitmapData(dpy, win, grey13_bits,
X	 grey13_width, grey13_height, 0, 1, 1);
X	greypm[13] = XCreatePixmapFromBitmapData(dpy, win, grey14_bits,
X	 grey14_width, grey14_height, 0, 1, 1);
X	greypm[14] = XCreatePixmapFromBitmapData(dpy, win, grey15_bits,
X	 grey15_width, grey15_height, 0, 1, 1);
X	greypm[15] = XCreatePixmapFromBitmapData(dpy, win, grey16_bits,
X	 grey16_width, grey16_height, 0, 1, 1);
X
X	gcvalues.foreground = WhitePixel(dpy, scn);
X	gcvalues.background = BlackPixel(dpy, scn);
X
X	gcvalues.fill_style = FillOpaqueStippled;
X	for (ix=0; ix<16; ix++) {
X	    gcvalues.stipple = greypm[ix];
X	    gcballs[ix] = XCreateGC(dpy, win,
X		GCForeground|GCBackground|GCFillStyle|GCStipple,
X		 &gcvalues);
X	};
X    }
X    else {
X	for (ix=0; ix<16; ix++) {
X	    col.red = colvalues[ix][0];
X	    col.green = colvalues[ix][1];
X	    col.blue = colvalues[ix][2];
X	    res = XAllocColor(dpy, DefaultColormap(dpy, scn),
X		&col);
X	    if (!res) {
X		fprintf(stderr, "spatial: unable to allocate colors\n");
X		exit(-1);
X	    }
X	    gcvalues.foreground = col.pixel;
X	    gcballs[ix] = XCreateGC(dpy, win, GCForeground,
X		&gcvalues);
X	}
X    }
X}
END_OF_FILE
if test 3773 -ne `wc -c <'spheral/gcgrey.c'`; then
    echo shar: \"'spheral/gcgrey.c'\" unpacked with wrong size!
fi
# end of 'spheral/gcgrey.c'
fi
if test -f 'spheral/grey01.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey01.bm'\"
else
echo shar: Extracting \"'spheral/grey01.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey01.bm' <<'END_OF_FILE'
X#define grey01_width 16
X#define grey01_height 16
Xstatic char grey01_bits[] = {
X0xff,0xff,0xfd,0xfd,0xff,0xff,0xff,0xff,0xff,0xff,0xdf,0xdf,
X0xff,0xff,0xff,0xff,0xff,0xff,0xfd,0xfd,0xff,0xff,0xff,0xff,
X0xff,0xff,0xdf,0xdf,0xff,0xff,0xff,0xff};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey01.bm'`; then
    echo shar: \"'spheral/grey01.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey01.bm'
fi
if test -f 'spheral/grey02.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey02.bm'\"
else
echo shar: Extracting \"'spheral/grey02.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey02.bm' <<'END_OF_FILE'
X#define grey02_width 16
X#define grey02_height 16
Xstatic char grey02_bits[] = {
X0xff,0xff,0xdf,0xdf,0xff,0xff,0xfd,0xfd,0xff,0xff,0xdf,0xdf,
X0xff,0xff,0xfd,0xfd,0xff,0xff,0xdf,0xdf,0xff,0xff,0xfd,0xfd,
X0xff,0xff,0xdf,0xdf,0xff,0xff,0xfd,0xfd};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey02.bm'`; then
    echo shar: \"'spheral/grey02.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey02.bm'
fi
if test -f 'spheral/grey03.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey03.bm'\"
else
echo shar: Extracting \"'spheral/grey03.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey03.bm' <<'END_OF_FILE'
X#define grey03_width 16
X#define grey03_height 16
Xstatic char grey03_bits[] = {
X0xff,0xff,0xdd,0xdd,0xff,0xff,0xff,0xff,0xff,0xff,0xdd,0xdd,
X0xff,0xff,0xff,0xff,0xff,0xff,0xdd,0xdd,0xff,0xff,0xff,0xff,
X0xff,0xff,0xdd,0xdd,0xff,0xff,0xff,0xff};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey03.bm'`; then
    echo shar: \"'spheral/grey03.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey03.bm'
fi
if test -f 'spheral/grey04.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey04.bm'\"
else
echo shar: Extracting \"'spheral/grey04.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey04.bm' <<'END_OF_FILE'
X#define grey04_width 16
X#define grey04_height 16
Xstatic char grey04_bits[] = {
X0xee,0xee,0xff,0xff,0xbb,0xbb,0xff,0xff,0xee,0xee,0xff,0xff,
X0xbb,0xbb,0xff,0xff,0xee,0xee,0xff,0xff,0xbb,0xbb,0xff,0xff,
X0xee,0xee,0xff,0xff,0xbb,0xbb,0xff,0xff};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey04.bm'`; then
    echo shar: \"'spheral/grey04.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey04.bm'
fi
if test -f 'spheral/grey05.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey05.bm'\"
else
echo shar: Extracting \"'spheral/grey05.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey05.bm' <<'END_OF_FILE'
X#define grey05_width 16
X#define grey05_height 16
Xstatic char grey05_bits[] = {
X0xff,0xff,0x55,0x55,0xff,0xff,0xdd,0xdd,0xff,0xff,0x55,0x55,
X0xff,0xff,0xdd,0xdd,0xff,0xff,0x55,0x55,0xff,0xff,0xdd,0xdd,
X0xff,0xff,0x55,0x55,0xff,0xff,0xdd,0xdd};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey05.bm'`; then
    echo shar: \"'spheral/grey05.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey05.bm'
fi
if test -f 'spheral/grey06.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey06.bm'\"
else
echo shar: Extracting \"'spheral/grey06.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey06.bm' <<'END_OF_FILE'
X#define grey06_width 16
X#define grey06_height 16
Xstatic char grey06_bits[] = {
X0xff,0xff,0x55,0x55,0xff,0xff,0xbb,0xbb,0xff,0xff,0x55,0x55,
X0xff,0xff,0xee,0xee,0xff,0xff,0x55,0x55,0xff,0xff,0xbb,0xbb,
X0xff,0xff,0x55,0x55,0xff,0xff,0xee,0xee};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey06.bm'`; then
    echo shar: \"'spheral/grey06.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey06.bm'
fi
if test -f 'spheral/grey07.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey07.bm'\"
else
echo shar: Extracting \"'spheral/grey07.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey07.bm' <<'END_OF_FILE'
X#define grey07_width 16
X#define grey07_height 16
Xstatic char grey07_bits[] = {
X0xff,0xff,0x55,0x55,0xff,0xff,0x55,0x55,0xff,0xff,0x55,0x55,
X0xff,0xff,0x55,0x55,0xff,0xff,0x55,0x55,0xff,0xff,0x55,0x55,
X0xff,0xff,0x55,0x55,0xff,0xff,0x55,0x55};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey07.bm'`; then
    echo shar: \"'spheral/grey07.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey07.bm'
fi
if test -f 'spheral/grey08.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey08.bm'\"
else
echo shar: Extracting \"'spheral/grey08.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey08.bm' <<'END_OF_FILE'
X#define grey08_width 16
X#define grey08_height 16
Xstatic char grey08_bits[] = {
X0xdd,0xdd,0x77,0x77,0xdd,0xdd,0x77,0x77,0xdd,0xdd,0x77,0x77,
X0xdd,0xdd,0x77,0x77,0xdd,0xdd,0x77,0x77,0xdd,0xdd,0x77,0x77,
X0xdd,0xdd,0x77,0x77,0xdd,0xdd,0x77,0x77};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey08.bm'`; then
    echo shar: \"'spheral/grey08.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey08.bm'
fi
if test -f 'spheral/grey09.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey09.bm'\"
else
echo shar: Extracting \"'spheral/grey09.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey09.bm' <<'END_OF_FILE'
X#define grey09_width 16
X#define grey09_height 16
Xstatic char grey09_bits[] = {
X0xff,0xff,0x55,0x55,0xfb,0xfb,0x55,0x55,0xff,0xff,0x55,0x55,
X0xbf,0xbf,0x55,0x55,0xff,0xff,0x55,0x55,0xfb,0xfb,0x55,0x55,
X0xff,0xff,0x55,0x55,0xbf,0xbf,0x55,0x55};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey09.bm'`; then
    echo shar: \"'spheral/grey09.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey09.bm'
fi
if test -f 'spheral/grey10.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey10.bm'\"
else
echo shar: Extracting \"'spheral/grey10.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey10.bm' <<'END_OF_FILE'
X#define grey10_width 16
X#define grey10_height 16
Xstatic char grey10_bits[] = {
X0xee,0xee,0x55,0x55,0xff,0xff,0x55,0x55,0xee,0xee,0x55,0x55,
X0xff,0xff,0x55,0x55,0xee,0xee,0x55,0x55,0xff,0xff,0x55,0x55,
X0xee,0xee,0x55,0x55,0xff,0xff,0x55,0x55};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey10.bm'`; then
    echo shar: \"'spheral/grey10.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey10.bm'
fi
if test -f 'spheral/grey11.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey11.bm'\"
else
echo shar: Extracting \"'spheral/grey11.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey11.bm' <<'END_OF_FILE'
X#define grey11_width 16
X#define grey11_height 16
Xstatic char grey11_bits[] = {
X0xee,0xee,0x55,0x55,0xfb,0xfb,0x55,0x55,0xee,0xee,0x55,0x55,
X0xbf,0xbf,0x55,0x55,0xee,0xee,0x55,0x55,0xfb,0xfb,0x55,0x55,
X0xee,0xee,0x55,0x55,0xbf,0xbf,0x55,0x55};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey11.bm'`; then
    echo shar: \"'spheral/grey11.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey11.bm'
fi
if test -f 'spheral/grey12.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey12.bm'\"
else
echo shar: Extracting \"'spheral/grey12.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey12.bm' <<'END_OF_FILE'
X#define grey12_width 16
X#define grey12_height 16
Xstatic char grey12_bits[] = {
X0x55,0x55,0xee,0xee,0x55,0x55,0xbb,0xbb,0x55,0x55,0xee,0xee,
X0x55,0x55,0xbb,0xbb,0x55,0x55,0xee,0xee,0x55,0x55,0xbb,0xbb,
X0x55,0x55,0xee,0xee,0x55,0x55,0xbb,0xbb};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey12.bm'`; then
    echo shar: \"'spheral/grey12.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey12.bm'
fi
if test -f 'spheral/grey13.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey13.bm'\"
else
echo shar: Extracting \"'spheral/grey13.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey13.bm' <<'END_OF_FILE'
X#define grey13_width 16
X#define grey13_height 16
Xstatic char grey13_bits[] = {
X0x55,0x55,0xee,0xee,0x55,0x55,0xba,0xba,0x55,0x55,0xee,0xee,
X0x55,0x55,0xab,0xab,0x55,0x55,0xee,0xee,0x55,0x55,0xba,0xba,
X0x55,0x55,0xee,0xee,0x55,0x55,0xab,0xab};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey13.bm'`; then
    echo shar: \"'spheral/grey13.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey13.bm'
fi
if test -f 'spheral/grey14.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey14.bm'\"
else
echo shar: Extracting \"'spheral/grey14.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey14.bm' <<'END_OF_FILE'
X#define grey14_width 16
X#define grey14_height 16
Xstatic char grey14_bits[] = {
X0x57,0x57,0xaa,0xaa,0x75,0x75,0xaa,0xaa,0x57,0x57,0xaa,0xaa,
X0x75,0x75,0xaa,0xaa,0x57,0x57,0xaa,0xaa,0x75,0x75,0xaa,0xaa,
X0x57,0x57,0xaa,0xaa,0x75,0x75,0xaa,0xaa};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey14.bm'`; then
    echo shar: \"'spheral/grey14.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey14.bm'
fi
if test -f 'spheral/grey15.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey15.bm'\"
else
echo shar: Extracting \"'spheral/grey15.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey15.bm' <<'END_OF_FILE'
X#define grey15_width 16
X#define grey15_height 16
Xstatic char grey15_bits[] = {
X0x55,0x55,0xae,0xae,0x55,0x55,0xaa,0xaa,0x55,0x55,0xea,0xea,
X0x55,0x55,0xaa,0xaa,0x55,0x55,0xae,0xae,0x55,0x55,0xaa,0xaa,
X0x55,0x55,0xea,0xea,0x55,0x55,0xaa,0xaa};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey15.bm'`; then
    echo shar: \"'spheral/grey15.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey15.bm'
fi
if test -f 'spheral/grey16.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/grey16.bm'\"
else
echo shar: Extracting \"'spheral/grey16.bm'\" \(243 characters\)
sed "s/^X//" >'spheral/grey16.bm' <<'END_OF_FILE'
X#define grey16_width 16
X#define grey16_height 16
Xstatic char grey16_bits[] = {
X0x55,0x55,0xaa,0xaa,0x55,0x55,0xaa,0xaa,0x55,0x55,0xaa,0xaa,
X0x55,0x55,0xaa,0xaa,0x55,0x55,0xaa,0xaa,0x55,0x55,0xaa,0xaa,
X0x55,0x55,0xaa,0xaa,0x55,0x55,0xaa,0xaa};
END_OF_FILE
if test 243 -ne `wc -c <'spheral/grey16.bm'`; then
    echo shar: \"'spheral/grey16.bm'\" unpacked with wrong size!
fi
# end of 'spheral/grey16.bm'
fi
if test -f 'spheral/spheral.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/spheral.c'\"
else
echo shar: Extracting \"'spheral/spheral.c'\" \(1311 characters\)
sed "s/^X//" >'spheral/spheral.c' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X#include <stdio.h>
X#include <X11/Xlib.h>
X#include "spheral.h"
X#include "patchlevel.h"
X
X#define INITWINSIZEX (800)
X#define INITWINSIZEY ((int)(800*ROOTHALF))
X
Xint monomode = 0;
X
Xextern double focallen;
Xextern void srandom();
X
Xextern void xinit(), loadpieces(), gameloop(),
Xredo_board_globals();
Xextern void initintro(), initloop();
Xextern void init_ballpmflags();
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X    int ix;
X
X    srandom(getpid());
X
X/*    for (ix=1; ix<argc; ix++) {
X	if (strcmp(argv[ix], "-m")) {
X	    fprintf(stderr, "usage: spheral [ -m ]\n");
X	    exit(-1);
X	}
X	else
X	    monomode = 1;
X    }*/
X
X    monomode = 1; /* I'm terribly sorry; color just does not
X     work for this game. */
X
X    loadpieces(PIECEFILENAME);
X    fieldx = 6;
X    fieldz = 12;
X    fieldoffx = -0.5 * (fieldx-1);
X    fieldoffy = -0.5 * ROOTHALF * (fieldx-2);
X    fieldoffz = -4.0-(double)fieldz;
X    focallen = 1.0;
X    dispx = INITWINSIZEX;
X    dispy = INITWINSIZEY;
X    redo_board_globals();
X    xinit();
X    init_ballpmflags();
X    get_names();
X    load_hscores(0);
X    while (1) {
X	initintro();
X	introloop();
X	initgame();
X	gameloop();
X	if (checkmod_scores()) {
X	    load_hscores(1);
X	}
X    }
X}
END_OF_FILE
if test 1311 -ne `wc -c <'spheral/spheral.c'`; then
    echo shar: \"'spheral/spheral.c'\" unpacked with wrong size!
fi
# end of 'spheral/spheral.c'
fi
if test -f 'spheral/spheral.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/spheral.h'\"
else
echo shar: Extracting \"'spheral/spheral.h'\" \(2178 characters\)
sed "s/^X//" >'spheral/spheral.h' <<'END_OF_FILE'
X/* (C) Copyright 1991 Andrew Plotkin. Permission is
X given to copy and use, as long as this copyright
X notice is retained. */
X
X
X#define	PI	    (3.14159265)
X#define	ROOTHALF    (0.70710678)
X
X#define MAXFIELDX (10)
X#define MAXFIELDZ (15)
X
X#define MAXBALLS (6)
X#define MAXPIECES (30)
X
X#define NUMGAMERS (20)
X
X#define NUMSHADES (4)
X#define NUMBALLSIZES (128)
X
X#define	OUT_COLLIDE	(-1)
X#define	OUT_NOT		(0)
X#define	OUT_UP		(1)
X#define	OUT_DOWN	(2)
X#define	OUT_SOUTH	(4)
X#define	OUT_NORTHWEST	(8)
X#define	OUT_NORTHEAST	(16)
X
X#define F_OFF (0)
X#define F_ON (1)
X#define F_TEMP (2)
X
Xtypedef struct _point {
X    double x, y, z, w;
X} point;
X
Xtypedef double matrix[4][4];
X
Xtypedef XPoint fieldplist[MAXFIELDX][MAXFIELDX][MAXFIELDZ];
Xtypedef int fieldrlist[MAXFIELDX][MAXFIELDX][MAXFIELDZ];
X
Xtypedef struct _piecelist {
X    short numballs;
X    point points[MAXBALLS];
X} piecelist;
X
Xtypedef struct _piecesum {
X    short numballs;
X    XPoint p[MAXBALLS];
X    int rad[MAXBALLS];
X    double scalex, scaley;
X} piecesum;
X
Xtypedef struct _gamer {
X    char userid[16];
X    char name[16];
X    long score;
X    char scoret[16];
X} gamer;
X
Xextern gamer hscores[NUMGAMERS];
X
Xextern piecelist pieces[MAXPIECES];
X
Xextern unsigned char field[MAXFIELDX][MAXFIELDX][MAXFIELDZ];
Xextern fieldplist fieldpts;
Xextern fieldrlist fieldrads;
X
Xextern short fieldx, fieldz;
Xextern double fieldoffx, fieldoffy, fieldoffz;
X/*extern int meterx, meterx2, metery, metersize,
X meterlev, meteroldlev, meter_f_b, meter_b_d; */
X
Xextern short numpieces;
Xextern short curpiece;
X
Xextern Display *dpy;
Xextern Window win;
Xextern int scn;
Xextern int scndepth;
Xextern int monomode;
X
Xextern int dispx, dispy; /* size of window */
Xextern Pixmap backpm; /* size of window */
Xextern Pixmap fieldpm; /* size of window */
Xextern int sshapx1, sshapx2, sshapy1, sshapy2;
X/* size of rectangle that contains shape */
Xextern int bbackx1, bbackx2, bbacky1, bbacky2;
X/* coords of rectangle of backpm that is usable */
Xextern int ddispx1, ddispx2, ddispy1, ddispy2;
X/* coords of rectangle of display that is different
X from fieldpm */
Xextern long score, dropticks;
Xextern double boardscale;
Xextern int halfboardx, halfboardy;
X
Xextern long random();
END_OF_FILE
if test 2178 -ne `wc -c <'spheral/spheral.h'`; then
    echo shar: \"'spheral/spheral.h'\" unpacked with wrong size!
fi
# end of 'spheral/spheral.h'
fi
if test -f 'spheral/spheral.shp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/spheral.shp'\"
else
echo shar: Extracting \"'spheral/spheral.shp'\" \(973 characters\)
sed "s/^X//" >'spheral/spheral.shp' <<'END_OF_FILE'
X22
X
X4
X-.5, 0, .5
X.5, 0, .5
X0, .7071, 0
X0, .7071, 1
X
X4
X-.5, 0, .5
X.5, 0, .5
X0, .7071, 0
X-1, .7071, 0
X
X4
X-.5, 0, .5
X.5, 0, .5
X0, .7071, 0
X-1.5, 0, .5
X
X4
X-.5, 0, .5
X.5, 0, .5
X-1.5, 0, .5
X1, .7071, 0
X
X4
X-.5, 0, .5
X.5, 0, .5
X-1.5, 0, .5
X1.5, 0, .5
X
X4
X-.5, 0, .5
X.5, 0, .5
X-1, .7071, 0
X1, .7071, 0
X
X4
X-.5, 0, .5
X.5, 0, .5
X0, .7071, 0
X0, -.7071, 0
X
X4
X-.5, 0, .5
X.5, 0, .5
X-1, .7071, 0
X0, .7071, 1
X
X4
X-.5, 0, .5
X.5, 0, .5
X-1.5, 0, .5
X1, .7071, 0
X
X4
X-.5, 0, .5
X.5, 0, .5
X-1.5, 0, .5
X.5, 0, -.5
X
X4
X-.5, 0, .5
X.5, 0, .5
X-1.5, 0, .5
X-.5, 0, -.5
X
X4
X-.5, 0, .5
X.5, 0, .5
X1, .7071, 0
X1, -.7071, 0
X
X4
X-.5, 0, .5
X.5, 0, .5
X1, .7071, 0
X-1, -.7071, 1
X
X4
X-.5, 0, .5
X.5, 0, .5
X1, .7071, 0
X-1, .7071, 1
X
X4
X-.5, 0, .5
X.5, 0, .5
X-1, .7071, 0
X1, -.7071, 0
X
X4
X-.5, 0, .5
X-.5, 0, -.5
X.5, 0, -.5
X.5, 0, .5
X
X4
X-.5, 0, .5
X-.5, 0, -.5
X.5, 0, -.5
X1, .7071, 0
X
X
X1
X.5, 0, .5
X
X3
X-.5, 0, .5
X.5, 0, .5
X.5, 0, -.5
X
X3
X-.5, 0, .5
X.5, 0, .5
X0, .7071, 0
X
X3
X-.5, 0, .5
X.5, 0, .5
X1, .7071, 0
X
X2
X-.5, 0, .5
X.5, 0, .5
X
END_OF_FILE
if test 973 -ne `wc -c <'spheral/spheral.shp'`; then
    echo shar: \"'spheral/spheral.shp'\" unpacked with wrong size!
fi
# end of 'spheral/spheral.shp'
fi
if test -f 'spheral/test.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spheral/test.c'\"
else
echo shar: Extracting \"'spheral/test.c'\" \(3814 characters\)
sed "s/^X//" >'spheral/test.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <math.h>
X#include <X11/Xlib.h>
X
X#define GRIDSIZE (128)
X#define GREYS (64)
X
XDisplay *dpy;
XWindow   win;
XGC       gcwhite, gcblack; 
XGC gcballs[16];
Xstatic short grid[GRIDSIZE*2][GRIDSIZE*2];
X
Xvoid init()
X{
X    int      scn;
X    XSetWindowAttributes attr;
X    XGCValues gcvalues;
X
X    dpy = XOpenDisplay((char *) NULL);
X    if ((Display *) NULL == dpy) {
X	fprintf(stderr, "xbox:  could not open display.\n");
X	exit(-1);
X    }
X
X    
X    scn = DefaultScreen(dpy);
X    win = XCreateSimpleWindow(dpy, DefaultRootWindow(dpy),
X			       200, 200, 500, 500, 1,
X			       BlackPixel(dpy, scn),
X			       WhitePixel(dpy, scn));
X   
X    attr.event_mask = ButtonPressMask | KeyPressMask | ExposureMask;
X    XChangeWindowAttributes(dpy, win, CWEventMask, &attr);
X
X    XSetWindowBackground(dpy, win, BlackPixel(dpy, scn));
X
X    XMapWindow(dpy, win);
X    
X    gcvalues.foreground = WhitePixel(dpy, scn);
X    gcvalues.background = BlackPixel(dpy, scn);
X    gcwhite = XCreateGC(dpy, win, GCForeground|GCBackground,
X			&gcvalues);
X
X    gcvalues.foreground = BlackPixel(dpy, scn);
X    gcvalues.background = WhitePixel(dpy, scn);
X    gcblack = XCreateGC(dpy, win, GCForeground|GCBackground,
X			&gcvalues);
X}
X
Xvoid disc(x,y,n,rad)
Xint x,y,n,rad;
X{
X    register int ix, iy;
X    int ir;
X    double r, theta;
X    double xn, yn;
X    double xd, yd, zd;
X    double xl=0.5, yl=0.3, zl=sqrt(1.0-xl*xl-yl*yl);
X
X    printf("shade = %d\n", n);
X
X    XFillArc(dpy, win, gcblack, x-rad, y-rad,
X	     rad*2, rad*2, 0, 23040);
X
X    bzero(grid, sizeof(short)*GRIDSIZE*2*GRIDSIZE*2);
X
X    for (ix=GRIDSIZE-rad; ix<GRIDSIZE+rad; ix++) 
X	for (iy=GRIDSIZE-rad; iy<GRIDSIZE+rad; iy++) {
X	    r = ((double)((ix-GRIDSIZE)*(ix-GRIDSIZE) +
X		(iy-GRIDSIZE)*(iy-GRIDSIZE))) / (double)(rad*rad);
X	    if (r>1.0) grid[ix][iy] = 0;
X	    else {
X		xd = (double)(GRIDSIZE-ix)/(double)rad;
X		yd = (double)(GRIDSIZE-iy)/(double)rad;
X		zd = sqrt(1.0-xd*xd-yd*yd);
X
X		ir = (int)(11.0 * (xl*xd+yl*yd+zl*zd));
X		if (ir<0) ir=0;
X		else if (ir+n >= GREYS) ir=GREYS-n;
X		grid[ix][iy] = n + ir;
X		/*grid[ix][iy] = (ir%2)*GREYS;*/
X	    }
X	    grid[ix][iy] += (7*grid[ix-1][iy] + 1*grid[ix-1][iy-1] +
X		5*grid[ix][iy-1] + 3*grid[ix+1][iy-1]) / 16;
X	    if (grid[ix][iy]>=(GREYS/2)) {
X		XDrawPoint(dpy, win, gcwhite,
X		    x+ix-GRIDSIZE, y+iy-GRIDSIZE);
X		grid[ix][iy] -= GREYS;
X	    }
X	    /*else {
X		XDrawPoint(dpy, win, gcblack,
X	     x+ix-GRIDSIZE, y+iy-GRIDSIZE);
X	    };*/
X
X	}
X}
X
Xvoid redraw()
X{
X    XClearWindow(dpy, win);
X}
X
Xvoid bye()
X{
X    XCloseDisplay(dpy);
X}
X
Xmain()
X{
X    Bool   done = False;
X    XEvent event;
X    char   c;
X    int dens = 1;
X
X
X    init();
X
X    while (!done) {
X	XNextEvent(dpy, &event);
X	switch (event.type) {
X	    case ButtonPress:
X		printf("button %d at %d %d\n",
X		       event.xbutton.button,
X		       event.xbutton.x, event.xbutton.y);
X		switch (event.xbutton.button) {
X		    case 1:
X			disc(event.xbutton.x, event.xbutton.y,
X			     dens, 30);
X			break;
X		    case 2:
X			disc(event.xbutton.x, event.xbutton.y,
X			     dens, 50);
X			break;
X		    case 3:
X			disc(event.xbutton.x, event.xbutton.y,
X			     dens, 100);
X			break;
X		    default:
X			break;
X		}
X		break;
X	    case KeyPress:
X		if (1 == XLookupString(&event, &c, 1, NULL, NULL)) {
X		    printf("key %c\n", c);
X		    switch (c) {
X			case 'q':
X			    done = True;
X			    break;
X			case '1':
X			    dens = 9;
X			    break;
X			case '2':
X			    dens = 20;
X			    break;
X			case '3':
X			    dens = 31;
X			    break;
X			case '4':
X			    dens = 44;
X			    break;
X			case '-':
X			    dens--;
X			    break;
X			case '+':
X			case '=':
X			    dens++;
X			    break;			    
X			case 'r':
X			case 'c':
X			    redraw();
X			    break;
X			default:
X			    break;
X		    }
X		}
X		break;
X	    case Expose:
X		printf("expose\n");
X		redraw();
X	    default:
X		break;
X	}
X    }
X
X    bye();
X}
END_OF_FILE
if test 3814 -ne `wc -c <'spheral/test.c'`; then
    echo shar: \"'spheral/test.c'\" unpacked with wrong size!
fi
# end of 'spheral/test.c'
fi
echo shar: End of archive 3 \(of 4\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
