Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i104:  gnuchess4 - GNU Chess 4.0, Patch1b
Message-ID: <3080@master.CNA.TEK.COM>
Date: 22 Jun 92 16:20:00 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2142
Approved: billr@saab.CNA.TEK.COM

Submitted-by: cracraft@rice-chex.ai.mit.edu (Stuart Cracraft)
Posting-number: Volume 13, Issue 104
Archive-name: gnuchess4/Patch1b
Patch-To: gnuchess4: Volume 13, Issue 89-100
Environment: 



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 2)."
# Contents:  patch01.02
# Wrapped by billr@saab on Mon Jun 22 09:09:36 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'patch01.02' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch01.02'\"
else
echo shar: Extracting \"'patch01.02'\" \(55335 characters\)
sed "s/^X//" >'patch01.02' <<'END_OF_FILE'
Xdiff -c ../../../../gnuchess4/src/Makefile src/Makefile
X*** ../../../../gnuchess4/src/Makefile	Sun May 31 09:14:22 1992
X--- src/Makefile	Thu Jun 18 15:18:30 1992
X***************
X*** 28,35 ****
X  # gnuchessx is the xchess based chess.
X  #
X  
X! # The version number of this release
X  VERS=	4.0
X  
X  # Relevant file areas.
X  DIST=	../README ../README.lang ../doc ../misc ../src ../test
X--- 28,36 ----
X  # gnuchessx is the xchess based chess.
X  #
X  
X! # The version number of this GNU and Xboard release
X  VERS=	4.0
X+ XVERS = 2.0
X  
X  # Relevant file areas.
X  DIST=	../README ../README.lang ../doc ../misc ../src ../test
X***************
X*** 37,47 ****
X  # Distribution directory
X  DISTDIR=/tmp_mnt/home/fsf/cracraft/Ch
X  
X  # Change these to something less transitory, like /usr/games, and then
X  # compile. Ask your system admin / unix guru to put gnuchess.{hash,lang,book}
X  # in $(LIBDIR).
X  # Where the binaries live.
X! BINDIR= /tmp
X  
X  # Where language description, our book, and the persistent hash live.
X  LIBDIR= /tmp
X--- 38,52 ----
X  # Distribution directory
X  DISTDIR=/tmp_mnt/home/fsf/cracraft/Ch
X  
X+ # Programs being distributed
X+ PROGS=gnuchess-$(VERS) xboard-$(XVERS)
X+ #PROGS=gnuchess-$(VERS)
X+ 
X  # Change these to something less transitory, like /usr/games, and then
X  # compile. Ask your system admin / unix guru to put gnuchess.{hash,lang,book}
X  # in $(LIBDIR).
X  # Where the binaries live.
X! BINDIR= /tmp_mnt/home/fsf/cracraft/Ch
X  
X  # Where language description, our book, and the persistent hash live.
X  LIBDIR= /tmp
X***************
X*** 55,61 ****
X  # -DNOMEMSET if your machine does not support memset
X  # -DNOMATERIAL don't call it a draw when no pawns and both sides < rook
X  # -DNODYNALPHA don't dynamically adjust alpha
X! # -DNOHISTORY don't use history killer hueristic 
X  # -DNOSCORESPACE don't use Scorespace hueristic
X  # -DOLDXBOARD don't generate underpromote moves
X  # -DGNU3 don't generate underpromote moves
X--- 60,67 ----
X  # -DNOMEMSET if your machine does not support memset
X  # -DNOMATERIAL don't call it a draw when no pawns and both sides < rook
X  # -DNODYNALPHA don't dynamically adjust alpha
X! # -DHISTORY use history killer hueristic 
X! # -DKILLT use killt killer hueristic 
X  # -DNOSCORESPACE don't use Scorespace hueristic
X  # -DOLDXBOARD don't generate underpromote moves
X  # -DGNU3 don't generate underpromote moves
X***************
X*** 78,86 ****
X  #              16 print move list after each ply of search
X  #              32 print adds to transposition table
X  #              64 print returns from transposition table lookups
X  
X  
X! OPT= -DAG4 -DQUIETBACKGROUND -DNOHISTORY
X  
X  # The hashfile is a record of positions seen. It is used by
X  # GNU Chess to avoid making the same mistakes, a form of learning.
X--- 84,93 ----
X  #              16 print move list after each ply of search
X  #              32 print adds to transposition table
X  #              64 print returns from transposition table lookups
X+ #	      256 print search tree as it is generated
X  
X  
X! OPT= -DAG4 -DQUIETBACKGROUND -DHISTORY 
X  
X  # The hashfile is a record of positions seen. It is used by
X  # GNU Chess to avoid making the same mistakes, a form of learning.
X***************
X*** 90,95 ****
X--- 97,103 ----
X  # moves easily and quickly, saving time, and irritating the human
X  # opponent.
X  BOOK=	-DBOOK=\"$(LIBDIR)/gnuchess.book\"
X+ #BINBOOK = -DBINBOOK=\"$(LIBDIR)/gnuchess.book.data\"
X  
X  # The language file describes capabilities of the program. Perhaps
X  # it is useful for non-English speaking countries and customizing
X***************
X*** 101,106 ****
X--- 109,115 ----
X  #CC= cc $(OPT)
X  # Use this if you are lucky enough to have GNU CC.
X  CC=	gcc -W $(OPT)
X+ #CC= c89 $(OPT)
X  
X  # Miscellaneous CFLAGS. Uncomment the one you need and comment 
X  # the other.
X***************
X*** 113,118 ****
X--- 122,128 ----
X  #CFLAGS= -O2   -funroll-loops  # gnu cc  2.00 on others
X  #CFLAGS= -O -Aa -DSIGQUIT=_SIGQUIT -DSYSV # HPUX cc 
X  #CFLAGS= -O2  -funroll-loops -traditional-cpp  # gnu cc  2.00 on SunOS
X+ #CFLAGS= -O2
X  
X  all : gnuchess gnuchessr gnuchessn gnuchessx gnuchessc postprint gnuan game checkbook checkgame
X  
X***************
X*** 173,184 ****
X  		-c genmoves.c -o genmovesX.o
X  
X  book.o: book.c gnuchess.h version.h
X! 	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c book.c 
X  bookC.o: book.c gnuchess.h version.h
X  	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DNONDSP -DCHESSTOOL \
X  		-c book.c -o bookC.o
X  bookX.o: book.c gnuchess.h version.h
X! 	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DXBOARD  -c book.c -o bookX.o
X  
X  ataks.o: ataks.h ataks.c gnuchess.h version.h
X  	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c ataks.c
X--- 183,196 ----
X  		-c genmoves.c -o genmovesX.o
X  
X  book.o: book.c gnuchess.h version.h
X! 	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) $(BINBOOK) -c book.c 
X  bookC.o: book.c gnuchess.h version.h
X  	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DNONDSP -DCHESSTOOL \
X+ 	      $(BINBOOK) \
X  		-c book.c -o bookC.o
X  bookX.o: book.c gnuchess.h version.h
X! 	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DXBOARD  $(BINBOOK) \
X! 		-c book.c -o bookX.o
X  
X  ataks.o: ataks.h ataks.c gnuchess.h version.h
X  	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c ataks.c
X***************
X*** 254,266 ****
X  
X  distribution:
X  	-patchlevel=`cat $(DISTDIR)/gnuchess-$(VERS)/src/version.h|grep patchlevel|sed -e 's/[^0-9]//g'` ;\
X! 	echo "patchlevel is $$patchlevel" ;\
X  	cd $(DISTDIR) ;\
X  	rm -f gnuchess.tar.$(VERS).Z* gnuchess.tar.$(VERS).Z.uu* ;\
X! 	tar cf - gnuchess-$(VERS) | compress > $(DISTDIR)/gnuchess-$(VERS).pl$$patchlevel.tar.Z ;\
X  	uuencode gnuchess-$(VERS).pl$$patchlevel.tar.Z gnuchess-$(VERS).pl$$patchlevel.tar.Z > gnuchess-$(VERS).pl$$patchlevel.tar.Z.uu ;\
X  	rm -f x?? ;\
X! 	split -1500 gnuchess-$(VERS).pl$$patchlevel.tar.Z.uu ;\
X  	for i in x??; do \
X  	  mv $$i $(DISTDIR)/GNU_Chess_$$i; \
X  	done
X--- 266,279 ----
X  
X  distribution:
X  	-patchlevel=`cat $(DISTDIR)/gnuchess-$(VERS)/src/version.h|grep patchlevel|sed -e 's/[^0-9]//g'` ;\
X! 	echo "GNU patchlevel is $$patchlevel" ;\
X! 	xpatchlevel=`cat $(DISTDIR)/xboard-$(XVERS)/patchlevel.h|sed -e "s/#define PATCHLEVEL //"` ;\
X  	cd $(DISTDIR) ;\
X  	rm -f gnuchess.tar.$(VERS).Z* gnuchess.tar.$(VERS).Z.uu* ;\
X! 	tar cf - $(PROGS) | compress > $(DISTDIR)/gnuchess-$(VERS).pl$$patchlevel.tar.Z ;\
X  	uuencode gnuchess-$(VERS).pl$$patchlevel.tar.Z gnuchess-$(VERS).pl$$patchlevel.tar.Z > gnuchess-$(VERS).pl$$patchlevel.tar.Z.uu ;\
X  	rm -f x?? ;\
X! 	split -2500 gnuchess-$(VERS).pl$$patchlevel.tar.Z.uu ;\
X  	for i in x??; do \
X  	  mv $$i $(DISTDIR)/GNU_Chess_$$i; \
X  	done
X***************
X*** 279,282 ****
X  	-cp ../misc/gnuchess.lang $(LIBDIR)/gnuchess.lang
X  
X  clean:
X! 	-rm -f gnuchessx gnuchessc gnuchess gnuchessr gnuchessn gnuchessd postprint gnuan *.o *~ #*# %*%
X--- 292,298 ----
X  	-cp ../misc/gnuchess.lang $(LIBDIR)/gnuchess.lang
X  
X  clean:
X! 	-rm -f gnuchessx gnuchessc gnuchess gnuchessr gnuchessn gnuchessd postprint gnuan
X! 	-echo $(DISTDIR)
X! 	-rm -f $(DISTDIR)/gnuchess-4.0/misc/gnuchess.book.data
X! 	-find $(DISTDIR) \( -name '*.o' -o -name '*~' -o -name 'CL*' -o -name 'PATCH*' -o -name '#*#' -o -name '%*%' \) -exec rm -f {} \;
Xdiff -c ../../../../gnuchess4/src/book.c src/book.c
X*** ../../../../gnuchess4/src/book.c	Sun May 31 08:29:30 1992
X--- src/book.c	Wed Jun 17 07:23:49 1992
X***************
X*** 23,29 ****
X  
X  #include "gnuchess.h"
X  extern char mvstr[4][6];
X! short bookcount = 0;
X  static struct bookentry
X  {
X    unsigned long bookkey;
X--- 23,29 ----
X  
X  #include "gnuchess.h"
X  extern char mvstr[4][6];
X! int bookcount = 0;
X  static struct bookentry
X  {
X    unsigned long bookkey;
X***************
X*** 32,38 ****
X    unsigned short hint;
X    unsigned char count;
X    unsigned char flags;
X! } OpenBook[BOOKSIZE];
X  static struct bookentry *BookTable[BKTBLSIZE];
X  void
X  GetOpenings (void)
X--- 32,38 ----
X    unsigned short hint;
X    unsigned char count;
X    unsigned char flags;
X! } *OpenBook;
X  static struct bookentry *BookTable[BKTBLSIZE];
X  void
X  GetOpenings (void)
X***************
X*** 44,49 ****
X--- 44,52 ----
X   * next line and entry->move pointing to a chunk of memory containing the
X   * moves. More Opening lines of up to 100 half moves may be added to
X   * gnuchess.book.
X+  * But now its a hashed table by position which yields a move or moves for 
X+  * each position. It no longer knows about openings per say only positions
X+  * and recommended moves in those positions.
X   */
X  #ifndef BOOK
X  #define BOOK "/usr/games/lib/gnuchess.book"
X***************
X*** 57,70 ****
X    short int xside, doit, c, side;
X    short int rf, rt;
X    unsigned short mv;
X  
X- 
X-   for (OB = OpenBook; OB < &OpenBook[BOOKSIZE]; OB++)
X-     OB->count = 0;
X    for (i = 0; i < BKTBLSIZE; i++)
X      {
X        BookTable[i] = &OpenBook[BOOKSIZE / BKTBLSIZE * i];
X      }
X    if ((fd = fopen (BOOK, "r")) == NULL)
X      fd = fopen ("gnuchess.book", "r");
X    if (fd != NULL)
X--- 60,101 ----
X    short int xside, doit, c, side;
X    short int rf, rt;
X    unsigned short mv;
X+   int bs;
X+   unsigned long ltmp;
X+   /* allocate space for the book */
X+   OpenBook = malloc(BOOKSIZE*sizeof(struct bookentry));
X  
X    for (i = 0; i < BKTBLSIZE; i++)
X      {
X        BookTable[i] = &OpenBook[BOOKSIZE / BKTBLSIZE * i];
X      }
X+ #ifdef BINBOOK
X+   fd = fopen (BINBOOK, "r");
X+   if (fd != NULL)
X+     {
X+       fscanf(fd, "%d\n", &bs);
X+       fscanf(fd, "%d\n", &bookcount);
X+       if (bs == BOOKSIZE)
X+ 	{
X+ 	  if(0>fread(OpenBook, sizeof(struct bookentry), BOOKSIZE, fd))
X+ 	    perror("fread");
X+ 	  /* set every thing back to start game */
X+ 	  Book = BOOKFAIL;
X+ 	  for (i = 0; i < 64; i++)
X+ 	    {
X+ 	      board[i] = Stboard[i];
X+ 	      color[i] = Stcolor[i];
X+ 	    }
X+ 	  fclose(fd);
X+ 	  return;
X+       
X+ 	}
X+       fclose(fd);
X+     }
X+ #endif
X+ 
X+   for (OB = OpenBook; OB < &OpenBook[BOOKSIZE]; OB++)
X+     OB->count = 0;
X    if ((fd = fopen (BOOK, "r")) == NULL)
X      fd = fopen ("gnuchess.book", "r");
X    if (fd != NULL)
X***************
X*** 106,112 ****
X  		    && (OB->flags & SIDEMASK) == side
X  		    && OB->bmove == mv)
X  		  {
X! 
X  		    /*
X  		     * yes so just bump count - count is used to choose
X  		     * opening move in proportion to its presence in the
X--- 137,143 ----
X  		    && (OB->flags & SIDEMASK) == side
X  		    && OB->bmove == mv)
X  		  {
X! 		    
X  		    /*
X  		     * yes so just bump count - count is used to choose
X  		     * opening move in proportion to its presence in the
X***************
X*** 114,119 ****
X--- 145,152 ----
X  		     */
X  		    doit = false;
X  		    OB->count++;
X+ 		    if (OB->count < 1)
X+ 		      OB->count--;
X  		    break;
X  		  }
X  		/* Book is hashed into BKTBLSIZE chunks based on hashkey */
X***************
X*** 198,203 ****
X--- 231,243 ----
X  
X  	  }
X        fclose (fd);
X+ #ifdef BINBOOK
X+       fd = fopen (BINBOOK, "w");
X+       fprintf(fd, "%d\n%d\n", BOOKSIZE, bookcount);
X+       if(0>fwrite(OpenBook, sizeof(struct bookentry), BOOKSIZE, fd))
X+ 	perror("fwrite");
X+       fclose (fd);
X+ #endif
X  #if !defined CHESSTOOL && !defined XBOARD
X        sprintf (msg, CP[213], bookcount, BOOKSIZE);
X        ShowMessage (msg);
X***************
X*** 222,228 ****
X  
X  int
X  OpeningBook (unsigned short *hint, short int side)
X! 
X  /*
X   * Go thru each of the opening lines of play and check for a match with the
X   * current game listing. If a match occurs, generate a random number. If this
X--- 262,268 ----
X  
X  int
X  OpeningBook (unsigned short *hint, short int side)
X!      
X  /*
X   * Go thru each of the opening lines of play and check for a match with the
X   * current game listing. If a match occurs, generate a random number. If this
X***************
X*** 245,251 ****
X    tcnt = 0;
X    ccnt = 0;
X    OC = NULL;
X! 
X  
X    /*
X     * find all the moves for this position  - count them and get their total
X--- 285,291 ----
X    tcnt = 0;
X    ccnt = 0;
X    OC = NULL;
X!   
X  
X    /*
X     * find all the moves for this position  - count them and get their total
Xdiff -c ../../../../gnuchess4/src/checkgame.c src/checkgame.c
X*** ../../../../gnuchess4/src/checkgame.c	Sat May 30 07:34:01 1992
X--- src/checkgame.c	Fri Jun  5 23:52:12 1992
X***************
X*** 465,471 ****
X  	}
X        return (locn (r1, c1) << 8) | locn (r2, c2);
X      }
X!   return (0);
X  }
X  
X  void
X--- 465,471 ----
X  	}
X        return (locn (r1, c1) << 8) | locn (r2, c2);
X      }
X!   /* return (0); */
X  }
X  
X  void
X***************
X*** 690,696 ****
X    if (argc > 4 || argc < 2)
X      {
X        printf ("Usage: game file [start [end] ] \n");
X!       exit ();
X      }
X    start = end = 0;
X  
X--- 690,696 ----
X    if (argc > 4 || argc < 2)
X      {
X        printf ("Usage: game file [start [end] ] \n");
X!       exit (1);
X      }
X    start = end = 0;
X  
X***************
X*** 760,766 ****
X  	      printf (" %s\n", mvstr);
X  	    }
X  	  DISP ();
X! 	  exit ();
X  	}
X        getboard (i);
X        if (board[to] == pawn)
X--- 760,766 ----
X  	      printf (" %s\n", mvstr);
X  	    }
X  	  DISP ();
X! 	  exit (1);
X  	}
X        getboard (i);
X        if (board[to] == pawn)
X***************
X*** 783,789 ****
X  	{
X  	  printf ("Badnews: you have no king\n");
X  	  DISP ();
X! 	  exit ();
X  	}
X        for (ii = 0; ii < 64; ii++)
X  	{
X--- 783,789 ----
X  	{
X  	  printf ("Badnews: you have no king\n");
X  	  DISP ();
X! 	  exit (1);
X  	}
X        for (ii = 0; ii < 64; ii++)
X  	{
X***************
X*** 801,807 ****
X  		      algbr (Tree[jj].f, Tree[jj].t, 0);
X  		      printf ("move is %s\n", mvstr);
X  		      DISP ();
X! 		      exit ();
X  		    }
X  		}
X  	    }
X--- 801,807 ----
X  		      algbr (Tree[jj].f, Tree[jj].t, 0);
X  		      printf ("move is %s\n", mvstr);
X  		      DISP ();
X! 		      exit (1);
X  		    }
X  		}
X  	    }
X***************
X*** 812,816 ****
X    printf ("\n\n");
X    printf ("Final board:\n\n");
X    DISP ();
X!   exit ();
X  }
X--- 812,816 ----
X    printf ("\n\n");
X    printf ("Final board:\n\n");
X    DISP ();
X!   exit (0);
X  }
Xdiff -c ../../../../gnuchess4/src/dspcom.c src/dspcom.c
X*** ../../../../gnuchess4/src/dspcom.c	Sun May 31 08:31:19 1992
X--- src/dspcom.c	Thu Jun 18 07:20:15 1992
X***************
X*** 22,27 ****
X--- 22,28 ----
X   */
X  #include "gnuchess.h"
X  #include "ataks.h"
X+ extern short Mwpawn[64], Mbpawn[64], Mknight[2][64], Mbishop[2][64];
X  extern char *version, *patchlevel;
X  char mvstr[4][6];
X  char *InPtr;
X***************
X*** 676,686 ****
X      }
X    else if (GameList[GameCnt].score == -9999)
X      {
X!       fprintf (fd, "%s\n", ColorStr[player ^ 1]);
X      }
X    else if (GameList[GameCnt].score == 9998)
X      {
X!       fprintf (fd, "%s\n", ColorStr[player]);
X      }
X    fclose (fd);
X  }
X--- 677,687 ----
X      }
X    else if (GameList[GameCnt].score == -9999)
X      {
X!       fprintf (fd, "%s\n", ColorStr[player ]);
X      }
X    else if (GameList[GameCnt].score == 9998)
X      {
X!       fprintf (fd, "%s\n", ColorStr[player ^ 1]);
X      }
X    fclose (fd);
X  }
X***************
X*** 759,765 ****
X      {
X        struct leaf *node = &Tree[j];
X        algbr (node->f, node->t, node->flags);
X!       printf ("%s %s %s %s\n", mvstr[0], mvstr[1], mvstr[2], mvstr[3]);
X      }
X  #endif
X  #else
X--- 760,766 ----
X      {
X        struct leaf *node = &Tree[j];
X        algbr (node->f, node->t, node->flags);
X!       printf ("%s %s %s %s %d %x\n", mvstr[0], mvstr[1], mvstr[2], mvstr[3],node->score,node->flags);
X      }
X  #endif
X  #else
X***************
X*** 768,774 ****
X  }
X  
X  void
X!  TestPSpeed (void (*f) (short int side), unsigned j)
X  {
X    short i;
X    long cnt, rate, t1, t2;
X--- 769,775 ----
X  }
X  
X  void
X!  TestPSpeed (short int (*f) (short int side), unsigned j)
X  {
X    short i;
X    long cnt, rate, t1, t2;
X***************
X*** 777,783 ****
X    t1 = time (0);
X    for (i = 0; i < j; i++)
X      {
X!       f (opponent);
X      }
X    t2 = time (0);
X    cnt = j;
X--- 778,784 ----
X    t1 = time (0);
X    for (i = 0; i < j; i++)
X      {
X!       (void) f (opponent);
X      }
X    t2 = time (0);
X    cnt = j;
X***************
X*** 882,888 ****
X  	    fclose (D);
X  	  }
X  #endif
X! #if !defined XBOARD && !defined CHESSTOOL
X  	if (flag.post)
X  	  GiveHint ();
X  #endif
X--- 883,889 ----
X  	    fclose (D);
X  	  }
X  #endif
X! #if !defined CHESSTOOL
X  	if (flag.post)
X  	  GiveHint ();
X  #endif
X***************
X*** 1120,1126 ****
X  	  ShowMessage (CP[107]);/*test capturelist*/
X  	  TestSpeed (CaptureList, 30000);
X  	  ShowMessage (CP[107]);/*test capturelist*/
X! 	  TestPSpeed ((void *) ScorePosition, 15000);
X  	}
X        else
X  #if !defined NONDSP
X--- 1121,1127 ----
X  	  ShowMessage (CP[107]);/*test capturelist*/
X  	  TestSpeed (CaptureList, 30000);
X  	  ShowMessage (CP[107]);/*test capturelist*/
X! 	  TestPSpeed (ScorePosition, 15000);
X  	}
X        else
X  #if !defined NONDSP
X***************
X*** 1128,1133 ****
X--- 1129,1146 ----
X  	ShowPostnValues ();
X        else if (strcmp (s, CP[148]) == 0)	/*debug*/
X  	DoDebug ();
X+ 	else if (strcmp (s, "Mwpawn") == 0)        /*debug*/
X+         DoTable (Mwpawn);
X+ 	else if (strcmp (s, "Mbpawn") == 0)        /*debug*/
X+         DoTable (Mbpawn);
X+ 	else if (strcmp (s, "Mwknight") == 0)        /*debug*/
X+         DoTable (Mknight[white]);
X+ 	else if (strcmp (s, "Mbknight") == 0)        /*debug*/
X+         DoTable (Mknight[black]);
X+ 	else if (strcmp (s, "Mwbishop") == 0)        /*debug*/
X+         DoTable (Mbishop[white]);
X+ 	else if (strcmp (s, "Mbbishop") == 0)        /*debug*/
X+         DoTable (Mbishop[black]);
X        else
X  #endif
X  	{
X***************
X*** 1204,1210 ****
X      {
X        printf ("ioctl failure is this gcc 2.00? See README %d %d\n", i, errno);
X        perror ("FIONREAD");
X!       exit ();
X      }
X  
X    if (nchar)
X--- 1217,1223 ----
X      {
X        printf ("ioctl failure is this gcc 2.00? See README %d %d\n", i, errno);
X        perror ("FIONREAD");
X!       exit (1);
X      }
X  
X    if (nchar)
Xdiff -c ../../../../gnuchess4/src/eval.c src/eval.c
X*** ../../../../gnuchess4/src/eval.c	Sat May 30 07:35:02 1992
X--- src/eval.c	Wed Jun 17 21:25:56 1992
X***************
X*** 247,253 ****
X  #endif
X  #endif
X  
X! static short Mwpawn[64], Mbpawn[64], Mknight[2][64], Mbishop[2][64];
X  static short Mking[2][64], Kfield[2][64];
X  static short c1, c2, *atk1, *atk2, *PC1, *PC2, atak[2][64];
X  short emtl[2];
X--- 247,253 ----
X  #endif
X  #endif
X  
X! short Mwpawn[64], Mbpawn[64], Mknight[2][64], Mbishop[2][64];
X  static short Mking[2][64], Kfield[2][64];
X  static short c1, c2, *atk1, *atk2, *PC1, *PC2, atak[2][64];
X  short emtl[2];
Xdiff -c ../../../../gnuchess4/src/game.c src/game.c
X*** ../../../../gnuchess4/src/game.c	Sat May 30 19:16:06 1992
X--- src/game.c	Fri Jun  5 23:57:39 1992
X***************
X*** 342,348 ****
X    if (argc > 4 || argc < 2)
X      {
X        printf ("Usage: game file [start [end] ] \n");
X!       exit ();
X      }
X    start = end = 0;
X    if (argc > 2)
X--- 342,348 ----
X    if (argc > 4 || argc < 2)
X      {
X        printf ("Usage: game file [start [end] ] \n");
X!       exit (1);
X      }
X    start = end = 0;
X    if (argc > 2)
X***************
X*** 420,424 ****
X  
X    if (nr)
X      printf ("showpage\n");
X!   exit ();
X  }
X--- 420,424 ----
X  
X    if (nr)
X      printf ("showpage\n");
X!   exit (0);
X  }
Xdiff -c ../../../../gnuchess4/src/genmoves.c src/genmoves.c
X*** ../../../../gnuchess4/src/genmoves.c	Sat May 30 19:16:42 1992
X--- src/genmoves.c	Mon Jun 15 23:10:20 1992
X***************
X*** 55,66 ****
X  
X    node = &Tree[*TrP];
X    mv = (f << 8) | t;
X! #if defined NOHISTORY
X    s = killt[mv | sidebit];
X! #else
X!   z = (f << 6) | t;
X!   if (xside == white)
X!     z |= 0x1000;
X    s = history[z];
X  #endif
X    if (color[t] != neutral)
X--- 55,66 ----
X  
X    node = &Tree[*TrP];
X    mv = (f << 8) | t;
X! #ifdef KILLT
X    s = killt[mv | sidebit];
X! #endif
X! #ifdef HISTORY
X!   z = mv;
X!   if (xside == white) z |= 0x4000;
X    s = history[z];
X  #endif
X    if (color[t] != neutral)
X***************
X*** 172,182 ****
X    *TrP = TrPnt[ply];
X    if (!PV)
X      Swag0 = killr0[ply];
X    Swag1 = killr1[ply];
X    Swag2 = killr2[ply];
X    Swag3 = killr3[ply];
X    if (ply > 2)
X!     Swag4 = killr1[ply - 2];
X    sidebit = ((side == white) ? 0 : 0x80);
X    killt[SwagHt | sidebit] += 5000;
X    killt[Swag0 | sidebit] += 2000;
X--- 172,184 ----
X    *TrP = TrPnt[ply];
X    if (!PV)
X      Swag0 = killr0[ply];
X+    else Swag0 = PV;
X    Swag1 = killr1[ply];
X    Swag2 = killr2[ply];
X    Swag3 = killr3[ply];
X    if (ply > 2)
X!     Swag4 = killr1[ply - 2]; else Swag4 = 0;
X! #ifdef KILLT
X    sidebit = ((side == white) ? 0 : 0x80);
X    killt[SwagHt | sidebit] += 5000;
X    killt[Swag0 | sidebit] += 2000;
X***************
X*** 184,189 ****
X--- 186,201 ----
X    killt[Swag2 | sidebit] += 50;
X    killt[Swag3 | sidebit] += 40;
X    killt[Swag4 | sidebit] += 30;
X+ #endif
X+ #ifdef HISTORY
X+   i = (side == black)?0x4000:0;
X+   history[SwagHt | i] += 5000;
X+   if(SwagHt != Swag0)history[Swag0 | i] += 2000;
X+   if(SwagHt != Swag1 && Swag1 != Swag0)history[Swag1 | i] += 60;
X+   if(SwagHt != Swag2 && Swag0 != Swag2 && Swag1 != Swag2)history[Swag2 | i] += 50;
X+   if(SwagHt != Swag3 && Swag0 != Swag3 && Swag1 != Swag3 && Swag2 != Swag3)history[Swag3 | i] += 40;
X+   if(SwagHt != Swag4 && Swag0 != Swag4 && Swag1 != Swag4 && Swag2 != Swag4 && Swag3 != Swag4)history[Swag4 | i] += 30;
X+ #endif
X    for (i = PieceCnt[side]; i >= 0; i--)
X      GenMoves (ply, PieceList[side][i], side, xside);
X    if (!castld[side])
X***************
X*** 207,212 ****
X--- 219,225 ----
X        if (color[f] == side && board[f] == pawn)
X  	LinkMove (ply, f, epsquare, capture | epmask, xside);
X      }
X+ #ifdef KILLT
X    killt[SwagHt | sidebit] -= 5000;
X    killt[Swag0 | sidebit] -= 2000;
X    killt[Swag1 | sidebit] -= 60;
X***************
X*** 213,218 ****
X--- 226,241 ----
X    killt[Swag2 | sidebit] -= 50;
X    killt[Swag3 | sidebit] -= 40;
X    killt[Swag4 | sidebit] -= 30;
X+ #endif
X+ #ifdef HISTORY
X+  i = (side == black)?0x4000:0;
X+   history[SwagHt | i] -= 5000;
X+   if(SwagHt != Swag0)history[Swag0 | i] -= 2000;
X+   if(SwagHt != Swag1 && Swag1 != Swag0)history[Swag1 | i] -= 60;
X+   if(SwagHt != Swag2 && Swag0 != Swag2 && Swag1 != Swag2)history[Swag2 | i] -= 50;
X+   if(SwagHt != Swag3 && Swag0 != Swag3 && Swag1 != Swag3 && Swag2 != Swag3)history[Swag3 | i] -= 40;
X+   if(SwagHt != Swag4 && Swag0 != Swag4 && Swag1 != Swag4 && Swag2 != Swag4 && Swag3 != Swag4)history[Swag4 | i] -= 30;
X+ #endif
X    SwagHt = 0;			/* SwagHt is only used once */
X  }
X  
X***************
X*** 237,242 ****
X--- 260,266 ----
X    node = &Tree[*TrP];
X    r7 = rank7[side];
X    PL = PieceList[side];
X+ #ifdef KILLT
X    sidebit = ((side == white) ? 0 : 0x80);
X    killt[SwagHt | sidebit] += 5000;
X    killt[Swag0 | sidebit] += 2000;
X***************
X*** 244,249 ****
X--- 268,275 ----
X    killt[Swag2 | sidebit] += 50;
X    killt[Swag3 | sidebit] += 40;
X    killt[Swag4 | sidebit] += 30;
X+ #endif
X+ 
X    for (i = 0; i <= PieceCnt[side]; i++)
X      {
X        sq = PL[i];
X***************
X*** 307,312 ****
X--- 333,339 ----
X  	    }
X  	}
X      }
X+ #ifdef KILLT
X    killt[SwagHt | sidebit] -= 5000;
X    killt[Swag0 | sidebit] -= 2000;
X    killt[Swag1 | sidebit] -= 60;
X***************
X*** 313,317 ****
X--- 340,345 ----
X    killt[Swag2 | sidebit] -= 50;
X    killt[Swag3 | sidebit] -= 40;
X    killt[Swag4 | sidebit] -= 30;
X+ #endif
X    SwagHt = 0;			/* SwagHt is only used once */
X  }
Xdiff -c ../../../../gnuchess4/src/gnuan.c src/gnuan.c
X*** ../../../../gnuchess4/src/gnuan.c	Sat May 30 19:17:57 1992
X--- src/gnuan.c	Sun Jun  7 10:58:45 1992
X***************
X*** 93,100 ****
X  #define printz printf
X  
X  char mvstr[4][6];
X! char *ColorStr[2] =
X! {"White", "Black"};
X  int mycnt1, mycnt2;
X  
X  static FILE *fpin;
X--- 93,99 ----
X  #define printz printf
X  
X  char mvstr[4][6];
X! extern char *ColorStr[2];
X  int mycnt1, mycnt2;
X  
X  static FILE *fpin;
X***************
X*** 737,742 ****
X--- 736,742 ----
X  
X    fpout = stderr;
X    fprintf (fpout, "Input the file with the algebraic moves of the game.\n");
X+   fflush(fpout);
X    gets (infilename);
X    fprintf (fpout, "\n");
X    do
X***************
X*** 754,760 ****
X        gets (inbuf);
X        max_minutes = atoi (inbuf);
X    } while (max_minutes < 1);
X!   printf ("%d %d \n", search_depth, max_minutes);
X    TCminutes = max_minutes;
X  
X    fprintf (fpout, "\n\n");
X--- 754,761 ----
X        gets (inbuf);
X        max_minutes = atoi (inbuf);
X    } while (max_minutes < 1);
X!   printf ("\nYou will search to %d half moves\n", search_depth);
X!   printf ("\nWith no search taking more than %d minutes\n",max_minutes);
X    TCminutes = max_minutes;
X  
X    fprintf (fpout, "\n\n");
Xdiff -c ../../../../gnuchess4/src/gnuchess.h src/gnuchess.h
X*** ../../../../gnuchess4/src/gnuchess.h	Sat May 30 19:21:45 1992
X--- src/gnuchess.h	Thu Jun 18 20:56:47 1992
X***************
X*** 21,32 ****
X   * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X   */
X  
X  #include <stdio.h>
X- /* <stdio.h */
X- extern int fclose (FILE *);
X- extern int fscanf (FILE *, const char *,...);
X- extern int fprintf (FILE *, const char *,...);
X- extern int fflush (FILE *);
X  
X  #define SEEK_SET 0
X  #define SEEK_END 2
X--- 21,35 ----
X   * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X   */
X  
X+ #if !defined(__STDC__) || !defined(MSDOS)
X+ #define const
X+ #endif
X+ 
X+ #ifndef __GNUC__
X+ #define inline
X+ #endif
X+ 
X  #include <stdio.h>
X  
X  #define SEEK_SET 0
X  #define SEEK_END 2
X***************
X*** 40,53 ****
X  
X  #endif /* DEBUG */
X  
X- #if !defined(__STDC__) || !defined(MSDOS)
X- #define const
X- #endif
X- 
X- #ifndef __GNUC__
X- #define inline
X- #endif
X- 
X  #include <ctype.h>
X  
X  #ifdef MSDOS
X--- 43,48 ----
X***************
X*** 72,77 ****
X--- 67,81 ----
X  #define printz printw
X  #endif
X  
X+ #if defined(__STDC__) || defined(MSDOS)
X+ /* <stdio.h> */
X+      extern int fclose (FILE *);
X+ #ifndef __ultrix /* work around bug in c89 compiler --t.mann */
X+      extern int fscanf (FILE *, const char *, ...);
X+      extern int fprintf (FILE *, const char *, ...);
X+ #endif /*__ultrix*/
X+      extern int fflush (FILE *);
X+ 
X  /* <stdlib.h> */
X       extern int abs (int);
X       extern int atoi (const char *);
X***************
X*** 81,86 ****
X--- 85,91 ----
X  
X  /* <string.h> */
X       extern void *memset (void *, int, size_t);
X+ #endif
X  
X  
X  /* Piece values */
X***************
X*** 174,182 ****
X  #define ttblsz vttblsz
X  #define TREE 1500		/* max number of tree entries */
X  #define MAXDEPTH 35		/* max depth a search can be carried */
X! #define MINDEPTH 2		/* min search depth =1 (no hint), >1 hint */
X  #define MAXMOVES 400		/* max number of half moves in a game */
X! #define BOOKSIZE 7500		/* Number of unique position/move combinations allowed */
X  #define CPSIZE 225		/* size of lang file max */
X  /***************** tuning paramaters **********************************************/
X  #define CHKDEPTH 1		/* always look forward CHKDEPTH half-moves if in check */
X--- 179,187 ----
X  #define ttblsz vttblsz
X  #define TREE 1500		/* max number of tree entries */
X  #define MAXDEPTH 35		/* max depth a search can be carried */
X! #define MINDEPTH 3		/* min search depth =1 (no hint), >1 hint */
X  #define MAXMOVES 400		/* max number of half moves in a game */
X! #define BOOKSIZE 30000		/* Number of unique position/move combinations allowed */
X  #define CPSIZE 225		/* size of lang file max */
X  /***************** tuning paramaters **********************************************/
X  #define CHKDEPTH 1		/* always look forward CHKDEPTH half-moves if in check */
X***************
X*** 187,193 ****
X  #define ZDEPTH 3		/* depth beyond which to check ZDELTA for extra time */
X  #define ZDELTA 10		/* score delta per ply to cause extra time to be given */
X  #define ZNODES 1000		/* check the time every ZNODES positions */
X! #define MAXTCCOUNT 4		/* max number of time clicks per search */
X  #define MINSEARCHPCT 10		/* must have looked at MINSEARCHPCT moves on a ply on a timeout */
X  #define SCORETIME -50		/* score below which to add search time */
X  #define SCORESPLIM 8		/* Score space doesn't apply after this stage */
X--- 192,198 ----
X  #define ZDEPTH 3		/* depth beyond which to check ZDELTA for extra time */
X  #define ZDELTA 10		/* score delta per ply to cause extra time to be given */
X  #define ZNODES 1000		/* check the time every ZNODES positions */
X! #define MAXTCCOUNT 5		/* max number of time clicks per search */
X  #define MINSEARCHPCT 10		/* must have looked at MINSEARCHPCT moves on a ply on a timeout */
X  #define SCORETIME -50		/* score below which to add search time */
X  #define SCORESPLIM 8		/* Score space doesn't apply after this stage */
X***************
X*** 203,209 ****
X  #define RBONUS 6		/* points per stage value of R increases */
X  #define KINGPOSLIMIT ( -1)	/* King positional scoring limit */
X  #define KINGSAFETY  16
X! #define MINTIME 200		/* MIN time to start a ply */
X  
X  #if defined AG0
X  #define WHITEAG0
X--- 208,214 ----
X  #define RBONUS 6		/* points per stage value of R increases */
X  #define KINGPOSLIMIT ( -1)	/* King positional scoring limit */
X  #define KINGSAFETY  16
X! #define MAXrehash (6)
X  
X  #if defined AG0
X  #define WHITEAG0
X***************
X*** 230,236 ****
X  #define BLACKAG4
X  #endif
X  /************************* parameters for Opening Book *********************************/
X! #define BOOKBITS 6		/* # bits for hashtable to book moves */
X  #define BOOKFAIL 2		/* if no book move found for BOOKFAIL turns stop using book */
X  #define BOOKRAND 1000		/* used to select an opening move from a list */
X  #define BOOKENDPCT 500		/* 50 % chance a BOOKEND will stop the book */
X--- 235,241 ----
X  #define BLACKAG4
X  #endif
X  /************************* parameters for Opening Book *********************************/
X! #define BOOKBITS 8		/* # bits for hashtable to book moves */
X  #define BOOKFAIL 2		/* if no book move found for BOOKFAIL turns stop using book */
X  #define BOOKRAND 1000		/* used to select an opening move from a list */
X  #define BOOKENDPCT 500		/* 50 % chance a BOOKEND will stop the book */
X***************
X*** 338,345 ****
X       extern FILE *debugfile;
X  
X  #endif /* DEBUG */
X! #if !defined NOHISTORY
X!      extern unsigned char history[8192];
X  #endif
X       extern char *ColorStr[2];
X       extern unsigned short int MV[MAXDEPTH];
X--- 343,350 ----
X       extern FILE *debugfile;
X  
X  #endif /* DEBUG */
X! #ifdef HISTORY
X!      extern unsigned char history[32768];
X  #endif
X       extern char *ColorStr[2];
X       extern unsigned short int MV[MAXDEPTH];
X***************
X*** 380,386 ****
X       extern short ChkFlag[], CptrFlag[], PawnThreat[];
X       extern short Pscore[], Tscore[];
X       extern short rehash;
X- #define MAXrehash (42)
X       extern unsigned int ttblsize;
X       extern short mtl[], pmtl[], hung[], emtl[];
X       extern short Pindex[];
X--- 385,390 ----
X***************
X*** 407,413 ****
X       extern FILE *hashfile;
X       extern unsigned int starttime;
X       extern short distdata[64][64], taxidata[64][64];
X!      extern short bookcount;
X       extern unsigned long hashkey, hashbd;
X       extern struct hashval hashcode[2][7][64];
X       extern char *CP[];
X--- 411,417 ----
X       extern FILE *hashfile;
X       extern unsigned int starttime;
X       extern short distdata[64][64], taxidata[64][64];
X!      extern int bookcount;
X       extern unsigned long hashkey, hashbd;
X       extern struct hashval hashcode[2][7][64];
X       extern char *CP[];
Xdiff -c ../../../../gnuchess4/src/init.c src/init.c
X*** ../../../../gnuchess4/src/init.c	Sat May 30 19:18:35 1992
X--- src/init.c	Mon Jun 15 23:02:53 1992
X***************
X*** 27,32 ****
X--- 27,33 ----
X  
X  short distdata[64][64], taxidata[64][64];
X  
X+ #ifdef KILLT
X  /* put moves to the center first */
X  void
X  Initialize_killt (void)
X***************
X*** 56,62 ****
X  	killt[(f << 8) | t | 0x80] = s;
X        }
X  }
X! 
X  void
X  Initialize_dist (void)
X  {
X--- 57,63 ----
X  	killt[(f << 8) | t | 0x80] = s;
X        }
X  }
X! #endif
X  void
X  Initialize_dist (void)
X  {
X***************
X*** 70,76 ****
X--- 71,79 ----
X  	taxidata[a][b] = d + di;
X  	distdata[a][b] = (d > di ? d : di);
X        }
X+ #ifdef KILLT
X    Initialize_killt ();
X+ #endif
X  }
X  
X  const short Stboard[64] =
X***************
X*** 381,387 ****
X    if (!constfile)
X      {
X        printf ("NO LANGFILE\n");
X!       exit ();
X      }
X    while (fgets (s, sizeof (s), constfile))
X      {
X--- 384,390 ----
X    if (!constfile)
X      {
X        printf ("NO LANGFILE\n");
X!       exit (1);
X      }
X    while (fgets (s, sizeof (s), constfile))
X      {
X***************
X*** 394,406 ****
X        if (q == &s[8])
X  	{
X  	  printf ("{ error in cinstfile\n");
X! 	  exit ();
X  	}
X        *q = '\0';
X        if (s[3] != ':' || s[7] != ':' || s[8] != '{')
X  	{
X  	  printf ("Langfile format error %s\n", s);
X! 	  exit ();
X  	}
X        s[3] = s[7] = '\0';
X        if (lang == NULL)
X--- 397,409 ----
X        if (q == &s[8])
X  	{
X  	  printf ("{ error in cinstfile\n");
X! 	  exit (1);
X  	}
X        *q = '\0';
X        if (s[3] != ':' || s[7] != ':' || s[8] != '{')
X  	{
X  	  printf ("Langfile format error %s\n", s);
X! 	  exit (1);
X  	}
X        s[3] = s[7] = '\0';
X        if (lang == NULL)
X***************
X*** 414,420 ****
X        if (entry < 0 || entry >= CPSIZE)
X  	{
X  	  printf ("Langfile number error\n");
X! 	  exit ();
X  	}
X        for (q = p = &s[9]; *p; p++)
X  	{
X--- 417,423 ----
X        if (entry < 0 || entry >= CPSIZE)
X  	{
X  	  printf ("Langfile number error\n");
X! 	  exit (1);
X  	}
X        for (q = p = &s[9]; *p; p++)
X  	{
Xdiff -c ../../../../gnuchess4/src/main.c src/main.c
X*** ../../../../gnuchess4/src/main.c	Sat May 30 19:06:35 1992
X--- src/main.c	Mon Jun 15 23:35:20 1992
X***************
X*** 58,65 ****
X  
X  char savefile[128] = "";
X  char listfile[128] = "";
X! #if !defined NOHISTORY
X! unsigned char history[8192];
X  #endif
X  short rpthash[2][256];
X  struct leaf Tree[TREE], *root;
X--- 58,65 ----
X  
X  char savefile[128] = "";
X  char listfile[128] = "";
X! #ifdef HISTORY
X! unsigned char history[32768];
X  #endif
X  short rpthash[2][256];
X  struct leaf Tree[TREE], *root;
X***************
X*** 107,113 ****
X--- 107,115 ----
X  unsigned short killr0[MAXDEPTH], killr1[MAXDEPTH];
X  unsigned short killr2[MAXDEPTH], killr3[MAXDEPTH];
X  unsigned short PV, SwagHt, Swag0, Swag1, Swag2, Swag3, Swag4, sidebit;
X+ #ifdef KILLT
X  short killt[0x4000];
X+ #endif
X  const short value[7] =
X  {0, valueP, valueN, valueB, valueR, valueQ, valueK};
X  const short control[7] =
X***************
X*** 117,122 ****
X--- 119,132 ----
X  unsigned int starttime;
X  short int ahead = true, hash = true;
X  
X+ #if defined CHESSTOOL || defined XBOARD
X+ void
X+ TerminateChess (int sig)
X+ {
X+   ExitChess();
X+ }
X+ #endif
X+ 
X  /* hmm.... shouldn`t main be moved to the interface routines */
X  int
X  main (int argc, char **argv)
X***************
X*** 256,265 ****
X  	  break;
X  	case 'v':
X  	  fprintf (stderr, CP[102], version, patchlevel);
X! 	  exit ();
X  	default:
X! 	  fprintf (stderr, CP[103]);
X! 	  exit ();
X  	}
X        argv++;
X        argc--;
X--- 266,275 ----
X  	  break;
X  	case 'v':
X  	  fprintf (stderr, CP[102], version, patchlevel);
X! 	  exit (1);
X  	default:
X! 	  fprintf (stderr, CP[113]);
X! 	  exit (1);
X  	}
X        argv++;
X        argc--;
X***************
X*** 267,273 ****
X    XC = 0;
X    Level = 0;
X  #if defined CHESSTOOL || defined XBOARD
X!   signal (SIGTERM, ExitChess);
X    TCflag = true;
X    TCmoves = 40;
X    TCminutes = 120;
X--- 277,283 ----
X    XC = 0;
X    Level = 0;
X  #if defined CHESSTOOL || defined XBOARD
X!   signal (SIGTERM, TerminateChess);
X    TCflag = true;
X    TCmoves = 40;
X    TCminutes = 120;
X***************
X*** 302,308 ****
X        if (argc > 9)
X  	{
X  	  printf ("%s\n", CP[220]);
X! 	  exit ();
X  	}
X        TCmoves = atoi (argv[1]);
X        TCminutes = strtol (argv[2], &p, 10);
X--- 312,318 ----
X        if (argc > 9)
X  	{
X  	  printf ("%s\n", CP[220]);
X! 	  exit (1);
X  	}
X        TCmoves = atoi (argv[1]);
X        TCminutes = strtol (argv[2], &p, 10);
X***************
X*** 326,332 ****
X  	  else
X  	    {
X  	      printf (CP[220]);
X! 	      exit ();
X  	    }
X  	  argc -= 2;
X  	  argv += 2;
X--- 336,342 ----
X  	  else
X  	    {
X  	      printf (CP[220]);
X! 	      exit (1);
X  	    }
X  	  argc -= 2;
X  	  argv += 2;
X***************
X*** 334,340 ****
X        if (argc)
X  	{
X  	  printf ("%s\n", CP[220]);
X! 	  exit ();
X  	}
X      }
X    Initialize ();
X--- 344,350 ----
X        if (argc)
X  	{
X  	  printf ("%s\n", CP[220]);
X! 	  exit (1);
X  	}
X      }
X    Initialize ();
Xdiff -c ../../../../gnuchess4/src/nondsp.c src/nondsp.c
X*** ../../../../gnuchess4/src/nondsp.c	Sat May 30 19:39:19 1992
X--- src/nondsp.c	Thu Jun 18 20:56:46 1992
X***************
X*** 301,321 ****
X    for (i = 1; bstline[i] > 0; i++)
X      {
X        if ((i > 1) && (i % 8 == 1))
X! 	fprintf (stderr, "\n                          ");
X        algbr ((short) (bstline[i] >> 8), (short) (bstline[i] & 0xFF), false);
X!       fprintf (stderr, "%5s ", mvstr[0]);
X      }
X!   fprintf (stderr, "\n");
X  }
X  
X  void
X  ShowResults (short int score, short unsigned int *bstline, char ch)
X  {
X! #if !defined CHESSTOOL && !defined XBOARD
X    if (flag.post)
X      {
X        ElapsedTime (2);
X!       fprintf (stderr, "%2d%c %6d %4ld %8ld  ", Sdepth, ch, score, et / 100, NodeCnt);
X        ShowLine (bstline);
X      }
X  #else
X--- 301,321 ----
X    for (i = 1; bstline[i] > 0; i++)
X      {
X        if ((i > 1) && (i % 8 == 1))
X! 	printf ("\n                          ");
X        algbr ((short) (bstline[i] >> 8), (short) (bstline[i] & 0xFF), false);
X!       printf ("%5s ", mvstr[0]);
X      }
X!   printf ("\n");
X  }
X  
X  void
X  ShowResults (short int score, short unsigned int *bstline, char ch)
X  {
X! #if !defined CHESSTOOL
X    if (flag.post)
X      {
X        ElapsedTime (2);
X!       printf ("%2d%c %6d %4ld %8ld  ", Sdepth, ch, score, et / 100, NodeCnt);
X        ShowLine (bstline);
X      }
X  #else
X***************
X*** 337,346 ****
X  #ifndef MSDOS
X    signal (SIGQUIT, TerminateSearch);
X  #endif /* MSDOS */
X! #if !defined CHESSTOOL && !defined XBOARD
X    if (flag.post)
X      {
X!       fprintf (stderr, CP[123],
X  	       TCmoves - TimeControl.moves[side] + 1,
X  	       ResponseTime, TimeControl.clock[side]);
X      }
X--- 337,346 ----
X  #ifndef MSDOS
X    signal (SIGQUIT, TerminateSearch);
X  #endif /* MSDOS */
X! #if !defined CHESSTOOL
X    if (flag.post)
X      {
X!       printf (CP[123],
X  	       TCmoves - TimeControl.moves[side] + 1,
X  	       ResponseTime, TimeControl.clock[side]);
X      }
X***************
X*** 417,423 ****
X  nomove:
X    if ((rootnode.flags & draw)||(rootnode.score == -9999)||
X        (rootnode.score == 9998)) goto summary;
X! #if !defined CHESSTOOL && !defined XBOARD
X    if (flag.post)
X      {
X        short h, l, t;
X--- 417,423 ----
X  nomove:
X    if ((rootnode.flags & draw)||(rootnode.score == -9999)||
X        (rootnode.score == 9998)) goto summary;
X! #if !defined CHESSTOOL
X    if (flag.post)
X      {
X        short h, l, t;
X***************
X*** 433,466 ****
X  	    h = t;
X  	  t = (l + h) >> 1;
X  	}
X!       /*fprintf (stderr, "Nodes %ld Tree %d Eval %ld Rate %ld RS high %ld low %ld\n",*/
X!       fprintf (stderr, CP[89],
X  	       NodeCnt, t, EvalNodes, (et) ? (NodeCnt / (et / 100)) : 0, reminus, replus);
X!       /*fprintf (stderr, "Hin/Hout/Coll/Fin/Fout = %ld/%ld/%ld/%ld/%ld\n",*/
X!       fprintf (stderr, CP[71],
X  	       HashAdd, HashCnt, THashCol, HashCol, FHashAdd, FHashCnt);
X      }
X    UpdateDisplay (rootnode.f, rootnode.t, 0, rootnode.flags);
X!   /*fprintf (stderr, "My move is: %s\n", mvstr[0]);*/
X!   fprintf (stderr, CP[83], mvstr[0]);
X    if (flag.beep)
X      printz ("%c", 7);
X  #endif /* CHESSTOOL */
X   summary:
X    if (rootnode.flags & draw)
X!     /*	fprintf (stderr, "Drawn game!\n");*/
X!     fprintf (stderr, CP[57]);
X    else if (rootnode.score == -9999)
X!     fprintf(stderr,"%s mates!\n",ColorStr[opponent]);
X    else if (rootnode.score == 9998)
X!     fprintf(stderr,"%s mates!\n",ColorStr[computer]);
X  #if !defined CHESSTOOL && !defined XBOARD
X  #ifdef VERYBUGGY
X    else if (rootnode.score < -9000)
X!     fprintf(stderr,"%s has a forced mate!\n",ColorStr[opponent]);
X    else if (rootnode.score > 9000)
X!     fprintf(stderr,"%s has a forced mate!\n",ColorStr[computer]);
X! #endif VERYBUGGY
X  #endif /* CHESSTOOL */
X  }
X  
X--- 433,466 ----
X  	    h = t;
X  	  t = (l + h) >> 1;
X  	}
X!       /*printf ("Nodes %ld Tree %d Eval %ld Rate %ld RS high %ld low %ld\n",*/
X!       printf (CP[89],
X  	       NodeCnt, t, EvalNodes, (et) ? (NodeCnt / (et / 100)) : 0, reminus, replus);
X!       /*printf ("Hin/Hout/Coll/Fin/Fout = %ld/%ld/%ld/%ld/%ld\n",*/
X!       printf (CP[71],
X  	       HashAdd, HashCnt, THashCol, HashCol, FHashAdd, FHashCnt);
X      }
X    UpdateDisplay (rootnode.f, rootnode.t, 0, rootnode.flags);
X!   /*printf ("My move is: %s\n", mvstr[0]);*/
X!   printf (CP[83], mvstr[0]);
X    if (flag.beep)
X      printz ("%c", 7);
X  #endif /* CHESSTOOL */
X   summary:
X    if (rootnode.flags & draw)
X!     /*	printf ("Drawn game!\n");*/
X!     printf (CP[57]);
X    else if (rootnode.score == -9999)
X!     printf("%s mates!\n",ColorStr[opponent]);
X    else if (rootnode.score == 9998)
X!     printf("%s mates!\n",ColorStr[computer]);
X  #if !defined CHESSTOOL && !defined XBOARD
X  #ifdef VERYBUGGY
X    else if (rootnode.score < -9000)
X!     printf("%s has a forced mate!\n",ColorStr[opponent]);
X    else if (rootnode.score > 9000)
X!     printf("%s has a forced mate!\n",ColorStr[computer]);
X! #endif /*VERYBUGGY*/
X  #endif /* CHESSTOOL */
X  }
X  
X***************
X*** 524,530 ****
X  void
X  ShowMessage (char *s)
X  {
X!   fprintf (stderr, "%s\n", s);
X  }
X  
X  void
X--- 524,530 ----
X  void
X  ShowMessage (char *s)
X  {
X!   printf("%s\n", s);
X  }
X  
X  void
X***************
X*** 576,582 ****
X    if (hint)
X      {
X        algbr ((short) (hint >> 8), (short) (hint & 0xFF), false);
X!       fprintf (stderr, CP[72], mvstr[0]);	/*hint*/
X      }
X    else
X      printz (CP[223]);
X--- 576,582 ----
X    if (hint)
X      {
X        algbr ((short) (hint >> 8), (short) (hint & 0xFF), false);
X!       printf(CP[72], mvstr[0]);	/*hint*/
X      }
X    else
X      printz (CP[223]);
Xdiff -c ../../../../gnuchess4/src/nuxdsp.c src/nuxdsp.c
X*** ../../../../gnuchess4/src/nuxdsp.c	Sat May 30 19:37:25 1992
X--- src/nuxdsp.c	Tue Jun 16 01:42:06 1992
X***************
X*** 40,58 ****
X  #include <sys/types.h>
X  #include <sys/file.h>
X  #include <curses.h>
X  
X  /* <stdlib.h> */
X! extern void *malloc (size_t);
X! extern void exit (int);
X! extern short int sscore[];
X  
X  /* <string.h> */
X! extern char *strcat (char *, const char *);
X! extern int strcmp (const char *, const char *);
X! extern char *strcpy (char *, const char *);
X  
X  /* <time.h> */
X! extern long int time (long int *);
X  
X  #endif /* MSDOS */
X  
X--- 40,60 ----
X  #include <sys/types.h>
X  #include <sys/file.h>
X  #include <curses.h>
X+      extern short int sscore[];
X  
X+ #if defined(__STDC__)
X  /* <stdlib.h> */
X!      extern void *malloc (size_t);
X!      extern void exit (int);
X  
X  /* <string.h> */
X!      extern char *strcat (char *, const char *);
X!      extern int strcmp (const char *, const char *);
X!      extern char *strcpy (char *, const char *);
X  
X  /* <time.h> */
X!      extern long int time (long int *);
X! #endif
X  
X  #endif /* MSDOS */
X  
X***************
X*** 82,88 ****
X  unsigned short int MV[MAXDEPTH];
X  int MSCORE;
X  char *DRAW;
X! char mvstr[4][6];
X  short PositionFlag = 0;
X  
X  #if defined(MSDOS) && !defined(SEVENBIT)
X--- 84,91 ----
X  unsigned short int MV[MAXDEPTH];
X  int MSCORE;
X  char *DRAW;
X! extern char mvstr[4][6];
X! extern short Mwpawn[64], Mbpawn[64], Mknight[2][64], Mbishop[2][64];
X  short PositionFlag = 0;
X  
X  #if defined(MSDOS) && !defined(SEVENBIT)
X***************
X*** 113,118 ****
X--- 116,122 ----
X    ListGame ();
X    gotoXY (1, 24);
X  #ifndef MSDOS
X+   refresh();
X    nocrmode ();
X    endwin ();
X  #endif /* MSDOS */
X***************
X*** 319,325 ****
X  ShowScore (short score)
X  {
X    gotoXY (TAB, 5);
X!   printz (CP[104], score);
X    ClrEoln ();
X  }
X  
X--- 323,329 ----
X  ShowScore (short score)
X  {
X    gotoXY (TAB, 5);
X!  printz (CP[104], score);
X    ClrEoln ();
X  }
X  
X***************
X*** 452,458 ****
X      printz (CP[96]);
X    else if (rootnode.score > 9000)
X      printz (CP[45]);
X! #endif VERYBUGGY
X    ClrEoln ();
X  
X    if (flag.post)
X--- 456,462 ----
X      printz (CP[96]);
X    else if (rootnode.score > 9000)
X      printz (CP[45]);
X! #endif /*VERYBUGGY*/
X    ClrEoln ();
X  
X    if (flag.post)
X***************
X*** 778,785 ****
X      ShowPostnValue (sq);
X    score = ScorePosition (opponent);
X    gotoXY (TAB, 5);
X!   printz (CP[103], score, mtl[computer], pmtl[computer], pscore[computer], sscore[computer],
X! 	  mtl[opponent], pmtl[opponent], pscore[opponent], sscore[opponent]);
X    ClrEoln ();
X  }
X  
X--- 782,788 ----
X      ShowPostnValue (sq);
X    score = ScorePosition (opponent);
X    gotoXY (TAB, 5);
X!  printz (CP[103], score, mtl[computer], pscore[computer], mtl[opponent],pscore[opponent]);
X    ClrEoln ();
X  }
X  
X***************
X*** 826,832 ****
X    refresh ();
X  }
X  
X! char *InPtr;
X  void
X  skip ()
X  {
X--- 829,835 ----
X    refresh ();
X  }
X  
X! extern char *InPtr;
X  void
X  skip ()
X  {
X***************
X*** 1009,1021 ****
X    ShowMessage (CP[65]);
X    scanz ("%s", s);
X    c = neutral;
X!   if (s[0] == CP[9][0] || s[0] == CP[9][1])	/* w W*/
X!     c = white;
X!   if (s[0] == CP[9][2] || s[0] == CP[9][3])	/*b B*/
X!     c = black;
X    for (p = king; p > no_piece; p--)
X!     if ((s[1] == pxx[p]) || (s[1] == qxx[p]))
X!       break;
X    for (sq = 0; sq < 64; sq++)
X      {
X        tp = board[sq];
X--- 1012,1022 ----
X    ShowMessage (CP[65]);
X    scanz ("%s", s);
X    c = neutral;
X!   if (s[0] == CP[9][0] || s[0] == CP[9][1])	/* w W*/ c = white;
X!   if (s[0] == CP[9][2] || s[0] == CP[9][3])	/*b B*/ c = black;
X    for (p = king; p > no_piece; p--)
X!     if ((s[1] == pxx[p]) || (s[1] == qxx[p])) break;
X!   if(p > no_piece)
X    for (sq = 0; sq < 64; sq++)
X      {
X        tp = board[sq];
X***************
X*** 1031,1037 ****
X      }
X    score = ScorePosition (opponent);
X    gotoXY (TAB, 5);
X!   printz (CP[103], score, mtl[computer], pmtl[computer], pscore[computer], sscore[computer],
X! 	  mtl[opponent], pmtl[opponent], pscore[opponent], sscore[opponent]);
X    ClrEoln ();
X  }
X--- 1032,1055 ----
X      }
X    score = ScorePosition (opponent);
X    gotoXY (TAB, 5);
X!   printz (CP[103], score, mtl[computer], pscore[computer], mtl[opponent],pscore[opponent]);
X    ClrEoln ();
X  }
X+ void
X+ DoTable (short table[64])
X+ {
X+   short  sq;
X+   ExaminePosition ();
X+   for (sq=0;sq<64;sq++){
X+ 
X+   gotoXY (VcoordR (sq, 2, 1));
X+ #if !defined(MSDOS) || defined(SEVENBIT)
X+   if (Vblack (sq) && !flag.shade)
X+     OReverse ();
X+ #endif /* !MSDOS || SEVENBIT */
X+ 
X+     printz ("%3d", table[sq]);
X+   ONormal ();
X+ }
X+ }
X+ 
Xdiff -c ../../../../gnuchess4/src/search.c src/search.c
X*** ../../../../gnuchess4/src/search.c	Sat May 30 19:11:56 1992
X--- src/search.c	Thu Jun 18 07:20:18 1992
X***************
X*** 31,36 ****
X--- 31,39 ----
X  unsigned short DBLINE[MAXDEPTH];
X  struct leaf *dbptr;
X  #endif
X+ #ifdef DEBUG40
X+ int d1h;
X+ #endif
X  struct leaf rootnode;
X  short int restype;
X  #include "ataks.h"
X***************
X*** 139,144 ****
X--- 142,148 ----
X    int Jscore;
X    unsigned short tmp[MAXDEPTH];
X    flag.timeout = false;
X+   flag.musttimeout = false;
X    xside = side ^ 1;
X    /* if background mode set to infinite */
X    if (iop == 2)
X***************
X*** 202,210 ****
X    if (!background)
X  #endif /* QUIETBACKGROUND */
X      SearchStartStuff (side);
X! #if !defined NOHISTORY
X  #ifdef NOMEMSET
X!   for (i = 0; i < 8192; i++)
X      history[i] = 0;
X  #else
X    memset ((char *) history, 0, sizeof (history));
X--- 206,214 ----
X    if (!background)
X  #endif /* QUIETBACKGROUND */
X      SearchStartStuff (side);
X! #ifdef HISTORY
X  #ifdef NOMEMSET
X!   for (i = 0; i < 32768; i++)
X      history[i] = 0;
X  #else
X    memset ((char *) history, 0, sizeof (history));
X***************
X*** 257,263 ****
X        Sdepth++;
X        DepthBeyond = Sdepth + ((Sdepth == 1) ? (DEPTHBEYOND >> 1) : DEPTHBEYOND);
X  
X! #if !defined CHESSTOOL && !defined XBOARD
X  #ifdef QUIETBACKGROUND
X        if (!background)
X  #endif /* QUIETBACKGROUND */
X--- 261,267 ----
X        Sdepth++;
X        DepthBeyond = Sdepth + ((Sdepth == 1) ? (DEPTHBEYOND >> 1) : DEPTHBEYOND);
X  
X! #if !defined CHESSTOOL
X  #ifdef QUIETBACKGROUND
X        if (!background)
X  #endif /* QUIETBACKGROUND */
X***************
X*** 301,306 ****
X--- 305,313 ----
X  	  score = search (side, 1, Sdepth, score, 9999, PrVar, &rpt);
X  	}
X  /**************** out of search ********************************************/
X+ #ifdef DEBUG40
X+       d1h = flag.timeout;
X+ #endif
X        if (Sdepth == MaxSearchDepth)
X  	flag.timeout = true;
X  
X***************
X*** 318,323 ****
X--- 325,331 ----
X  	      ExtraTime += TCleft;
X  	    }
X  	}
X+       if(TCflag) if ((4 * et) > (2 * ResponseTime + ExtraTime)) flag.timeout = true;
X  /************************ time control ***********************************/
X  
X        /* save PV as killer */
X***************
X*** 380,386 ****
X  	  /* recompute search window */
X  	  beta = score + ((computer == black) ? BBwindow : WBwindow);
X  #if !defined NODYNALPHA
X! 	  alpha = ((Jscore < score) ? Jscore : score) - ((computer == black) ? BAwindow : WAwindow) + abs (Jscore / 12);
X  #else
X  	  alpha = score - ((computer == black) ? BAwindow : WAwindow);
X  #endif
X--- 388,394 ----
X  	  /* recompute search window */
X  	  beta = score + ((computer == black) ? BBwindow : WBwindow);
X  #if !defined NODYNALPHA
X! 	  alpha = ((Jscore < score) ? Jscore : score) - ((computer == black) ? BAwindow : WAwindow) - abs (Jscore / 12) - 20;
X  #else
X  	  alpha = score - ((computer == black) ? BAwindow : WAwindow);
X  #endif
X***************
X*** 503,510 ****
X    g->flags = root->flags;
X  #ifdef DEBUG40
X    g->d1 = TCcount;
X!   g->d2 = ResponseTime ;
X!   g->d4 = TCleft;
X    g->d3 = ExtraTime;
X  #endif
X    /* update time comtrol info */
X--- 511,518 ----
X    g->flags = root->flags;
X  #ifdef DEBUG40
X    g->d1 = TCcount;
X!   g->d2 = ResponseTime + ExtraTime;
X!   g->d4 = d1h;
X    g->d3 = ExtraTime;
X  #endif
X    /* update time comtrol info */
X***************
X*** 584,590 ****
X  	      flag.musttimeout = false;
X  	    }
X  	  else if ((et >= (ResponseTime + ExtraTime)) && Sdepth > MINDEPTH)
X! 	    flag.timeout = true;
X  	}
X  
X      }
X--- 592,602 ----
X  	      flag.musttimeout = false;
X  	    }
X  	  else if ((et >= (ResponseTime + ExtraTime)) && Sdepth > MINDEPTH)
X!                {/* try to extend to finish ply */
X!                 if (TCflag && TCcount < MAXTCCOUNT)
X!                          { TCcount += 1; ExtraTime += (100); }
X!                 else flag.timeout = true;
X!                }
X  	}
X  
X      }
X***************
X*** 795,801 ****
X        nxtline[ply + 1] = 0;
X        if (cf && score + node->score < alpha)
X  	break;
X! #if !defined CHESSTOOL && !defined XBOARD
X        /* if at top level */
X        if (ply == 1)
X  	{			/* at the top update search status */
X--- 807,813 ----
X        nxtline[ply + 1] = 0;
X        if (cf && score + node->score < alpha)
X  	break;
X! #if !defined CHESSTOOL
X        /* if at top level */
X        if (ply == 1)
X  	{			/* at the top update search status */
X***************
X*** 872,878 ****
X  		  Tree[0] = tmp;
X  		  pbst = 0;
X  		}
X! #if !defined CHESSTOOL && !defined XBOARD
X  #ifdef QUIETBACKGROUND
X  	      if (!background)
X  #endif /* QUIETBACKGROUND */
X--- 884,890 ----
X  		  Tree[0] = tmp;
X  		  pbst = 0;
X  		}
X! #if !defined CHESSTOOL
X  #ifdef QUIETBACKGROUND
X  	      if (!background)
X  #endif /* QUIETBACKGROUND */
X***************
X*** 925,934 ****
X  #endif /* ttblsz */
X    if (depth > 0)
X      {
X! #if !defined NOHISTORY
X        j = (node->f << 6) | node->t;
X        if (side == black)
X! 	j |= 0x1000;
X        if (history[j] < 150)
X  	history[j] += (unsigned char) depth << 1;
X  #endif
X--- 937,946 ----
X  #endif /* ttblsz */
X    if (depth > 0)
X      {
X! #ifdef HISTORY
X        j = (node->f << 6) | node->t;
X        if (side == black)
X! 	j |= 0x4000;
X        if (history[j] < 150)
X  	history[j] += (unsigned char) depth << 1;
X  #endif
Xdiff -c ../../../../gnuchess4/src/uxdsp.c src/uxdsp.c
X*** ../../../../gnuchess4/src/uxdsp.c	Sun May 31 08:31:10 1992
X--- src/uxdsp.c	Tue Jun 16 01:42:55 1992
X***************
X*** 41,58 ****
X  #include <sys/file.h>
X  #include <curses.h>
X  
X! 
X  /* <stdlib.h> */
X! extern void *malloc (size_t);
X! extern void exit (int);
X  
X  /* <string.h> */
X! extern char *strcat (char *, const char *);
X! extern int strcmp (const char *, const char *);
X! extern char *strcpy (char *, const char *);
X  
X  /* <time.h> */
X! extern long int time (long int *);
X  
X  #endif /* MSDOS */
X  
X--- 41,59 ----
X  #include <sys/file.h>
X  #include <curses.h>
X  
X! #if defined(__STDC__)
X  /* <stdlib.h> */
X!      extern void *malloc (size_t);
X!      extern void exit (int);
X  
X  /* <string.h> */
X!      extern char *strcat (char *, const char *);
X!      extern int strcmp (const char *, const char *);
X!      extern char *strcpy (char *, const char *);
X  
X  /* <time.h> */
X!      extern long int time (long int *);
X! #endif
X  
X  #endif /* MSDOS */
X  
X***************
X*** 67,73 ****
X  unsigned short int MV[MAXDEPTH];
X  int MSCORE;
X  char *DRAW;
X! char mvstr[4][6];
X  
X  extern char *getenv (const char *);
X  void TerminateSearch (int), Die (int);
X--- 68,74 ----
X  unsigned short int MV[MAXDEPTH];
X  int MSCORE;
X  char *DRAW;
X! extern char mvstr[4][6];
X  
X  extern char *getenv (const char *);
X  void TerminateSearch (int), Die (int);
X***************
X*** 91,96 ****
X--- 92,98 ----
X    ListGame ();
X    gotoXY (1, 24);
X  #ifndef MSDOS
X+   refresh();
X    nocrmode ();
X    endwin ();
X  #endif /* MSDOS */
X***************
X*** 424,430 ****
X      printz (CP[96]);
X    else if (rootnode.score > 9000)
X      printz (CP[45]);
X! #endif VERYBUGGY
X    ClrEoln ();
X    if (flag.post)
X      {
X--- 426,432 ----
X      printz (CP[96]);
X    else if (rootnode.score > 9000)
X      printz (CP[45]);
X! #endif /*VERYBUGGY*/
X    ClrEoln ();
X    if (flag.post)
X      {
X***************
X*** 586,592 ****
X      ShowPostnValue (sq);
X    score = ScorePosition (opponent);
X    gotoXY (TAB, 5);
X!   printz (CP[103], score, mtl[computer], pmtl[computer], pscore[computer], mtl[opponent], pmtl[opponent], pscore[opponent]);
X    ClrEoln ();
X  }
X  
X--- 588,595 ----
X      ShowPostnValue (sq);
X    score = ScorePosition (opponent);
X    gotoXY (TAB, 5);
X!   printz (CP[103], score, mtl[computer], pscore[computer], mtl[opponent],pscore[opponent]);
X! 
X    ClrEoln ();
X  }
X  
X***************
X*** 672,678 ****
X    refresh ();
X  }
X  
X! char *InPtr;
X  void
X  skip ()
X  {
X--- 675,681 ----
X    refresh ();
X  }
X  
X! extern char *InPtr;
X  void
X  skip ()
X  {
X***************
X*** 870,875 ****
X      }
X    score = ScorePosition (opponent);
X    gotoXY (TAB, 5);
X!   printz (CP[103], score, mtl[computer], pmtl[computer], pscore[computer], mtl[opponent], pmtl[opponent], pscore[opponent]);
X    ClrEoln ();
X  }
X--- 873,891 ----
X      }
X    score = ScorePosition (opponent);
X    gotoXY (TAB, 5);
X!   printz (CP[103], score, mtl[computer], pscore[computer], mtl[opponent],pscore[opponent]);
X! 
X    ClrEoln ();
X  }
X+ void
X+ DoTable (short table[64])
X+ {
X+   short  sq;
X+   ExaminePosition ();
X+   for (sq=0;sq<64;sq++){
X+   gotoXY (4 + 5 * VIR_C (sq), 5 + 2 * (7 - VIR_R (sq)));
X+   printz ("%3d ", table[sq]);
X+ 
X+ }
X+ }
X+ 
Xdiff -c ../../../../gnuchess4/src/version.h src/version.h
X*** ../../../../gnuchess4/src/version.h	Sun May 31 08:38:24 1992
X--- src/version.h	Thu Jun 18 07:21:11 1992
X***************
X*** 4,7 ****
X   *
X   */
X  char *version = "4.00";
X! char *patchlevel = "44";
X--- 4,7 ----
X   *
X   */
X  char *version = "4.00";
X! char *patchlevel = "50";
END_OF_FILE
if test 55335 -ne `wc -c <'patch01.02'`; then
    echo shar: \"'patch01.02'\" unpacked with wrong size!
fi
# end of 'patch01.02'
fi
echo shar: End of archive 2 \(of 2\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
	cat patch01.01 patch01.02 >patches01
	rm patch01.01 patch01.02
	echo Now type \"'patch -p < patches01'\" to apply the patches
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
