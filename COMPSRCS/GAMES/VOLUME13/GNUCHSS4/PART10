Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i098:  gnuchess4 - GNU Chess 4.0, Part10/12
Message-ID: <3065@master.CNA.TEK.COM>
Date: 19 Jun 92 15:55:17 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1800
Approved: billr@saab.CNA.TEK.COM

Submitted-by: cracraft@rice-chex.ai.mit.edu (Stuart Cracraft)
Posting-number: Volume 13, Issue 98
Archive-name: gnuchess4/Part10
Supersedes: gnuchess2: Volume 4, Issue 37-40
Environment: 



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 10 (of 12)."
# Contents:  doc/CHESSTOOL doc/README.font doc/README.output
#   doc/gnuchess.1 src/Makefile src/nondsp.c
# Wrapped by billr@saab on Fri Jun 19 08:36:02 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/CHESSTOOL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/CHESSTOOL'\"
else
echo shar: Extracting \"'doc/CHESSTOOL'\" \(1720 characters\)
sed "s/^X//" >'doc/CHESSTOOL' <<'END_OF_FILE'
XChesstool interface
X
Xsave - save game to file
Xtest - no - op
Xremove - take back 2 half-moves
Xexit
Xresign
Xfirst - machine first
Xrestore - opposite of save
Xclock - print white and black clock
Xwhite
Xblack
Xhshort - give hint
Xscore - list moves
Xsetup - setup board. never quit figured setup out. should be like xboard but ???
Xrepeat - show last move
Xa2a4 - move in algebraic format
Xo-o
Xo-o-o
Xe7e8 - pawn promotion always to queen
X
Xxboard
X
XSee gnuchess manual page for all options that might be set in startup string.
X
Xeasy - don't compute while opponent moves. must be set for xboard
Xsave - save game to file
Xget - read position from gnuchess savefile
Xundo - undo 1 half move
Xremove - undo 2 half moves
Xxget - read position from xboard save file
Xsetup - setup board with subcommands:
X					# - clear board
X					c - change sides
X					. - end setup
X					pa4 - put pawn at a4
Xblack - machine black
Xwhite - machine white
Xgo - tells machine to move first	gnuchess3.1+ or gnuchess only
Xhint - give hint
Xtime - tell chess program the clock values	gnuchess only
X	otherwise its hard to keep the clocks in sync.
Xpost - include PV with each move as in:
X	3. h2h4     -7  d7d5  e4d5  d8d5  b1c3
Xa2a4 - move in algebraic format
Xo-o
Xo-o-o
Xe7e8 - pawn promotion always to queen
X
X
Xso game looks like this:
X
XChess 				Always first response from xboard or chess
Xe2e4				human move
X1. e2e4				move is echoed back by machine
X1. ... e7e5			machine move
Xa2a4				human move
X2. a2a4				echo
X2. ... g8f6			machine move
Xpost				if post is set
Xb2b3				human move
X3. b2b3    -16  g8f6  g1f3	echo back with computer predicted best line and score
X3. ... f6e4			machine move
Xb1c3
X4. b1c3   -102  f6e4  g1f3
X4. ... e4c3
Xquit
X5. quit   -141  e4c3  d2c3  d7d5
X
END_OF_FILE
if test 1720 -ne `wc -c <'doc/CHESSTOOL'`; then
    echo shar: \"'doc/CHESSTOOL'\" unpacked with wrong size!
fi
# end of 'doc/CHESSTOOL'
fi
if test -f 'doc/README.font' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/README.font'\"
else
echo shar: Extracting \"'doc/README.font'\" \(9917 characters\)
sed "s/^X//" >'doc/README.font' <<'END_OF_FILE'
XPostScript Chess Font -- "README" file.
X========== ===== ==== == ======== =====
X
X	Copyright (c) 1991 A. N. Walker.  All rights reserved.
X
XRestrictions on Use:
X------------ -- ----
X	You must keep the copyright notice on this file and on the
Xaccompanying "Font" file.  If you change anything, you must clearly
Xmark your changes.  Otherwise, you may use these files as you please
Xfor private, educational or research purposes.  You may also use them
Xfreely for commercial purposes as long as you do not make any changes
Xto the shapes of the pieces without my approval.
X
X	I do not, and am in no position to, make any claim as to
Xsuitability of these files for any specific purpose.  They work for
Xme, and if they work for you too I shall be pleased.  If they do not
Xwork for you, well, you have what you paid for.
X
X	If you are pleased with the results, please let me [and your
Xreaders, if any!] know.  If you manage to make money out of them,
Xplease let me know how!  I'd quite like to see [real or PostScript]
Xcopies of what you manage to do, if you have the necessary time,
Xinclination and resources.
X
X	If you don't like the results, please let me know why.  Indeed,
Xif you have any comments, please e- or snail- mail them to me.
X
XWhat you have to do:
X---- --- ---- -- ---
X	You should have three files, called "Font", "Demo" and "Table".
XIf you have a way of viewing PostScript, shovel "Font" and "Demo" or
X"Font" and "Table" at it;  for example, I use the commands
X
X		lpr -Plwriter Font Demo
X		lpr -Plwriter Font Table
X
Xto see the results on "my" LaserWriter.  If you have no way of viewing
XPostScript, then I'm sorry, but I can't help you.  What you should see
Xis an assorted collection of boards and figurines in various sizes and
Xrotations ("Demo") or a neat table showing all the symbols in the font
X("Table").  If anything else happens, you will have to consult someone
Xwho knows what they're doing -- *not* me!  I can promise you that the
Xfiles as shipped print nicely on a bog-standard Apple LW+.  They take
Xseveral minutes each to print on our LW+;  this is largely because they
Xmake almost pessimal use of the font caching mechanism -- lots of big
Xcharacters are printed once each in different sizes and orientations.
XConventional pages with lots of figurines or ordinary text and only a
Xfew diagrams print acceptably quickly (especially, of course, if you
Xhave a faster or more recent LW).
X
X	If you are happy with the demos, you can then install the "Font"
Xfile as a font in your system.
X
X	****************************************
X	* I cannot help you with this process! *
X	****************************************
X
XI can't even do it for our own computer, which has a much-hacked (from
Xits PDP-11 days) version of Troff;  I leave it to our guru.  Neither
Xhe nor I know what magic you have to utter for an unhacked Troff, or
Xfor TEX, or for Macs or PCs or whatever weird and wonderful software
Xor hardware you possess.  When you install the font, you may also find
Xit useful to grab some of the PostScript code from "Demo", especially
Xif you want to draw (for example) labelled diagrams.
X
XWhat there is in the Font:
X---- ----- -- -- --- -----
X	There are really two fonts wrapped up into one.  The more
Xconventional sub-font is the so-called "text mode", and is what you
Xget when you first select the font.  This mode itself has two major
Xcomponents.  The upper case letters are the figurines, for use in
Xtext.  For example, "Q" draws a queen figurine.  Lower case letters
Xand other symbols are (most of) the Informant symbols (omitting only
Xsymbols like "?" and "ch" that you can reasonably expect to find in
Xboring old Times Roman, but including "+" and "-").  I've been as
Xmnemonic as I could, but there are just too many symbols.
X
X	The other sub-font is "diagram mode".  In this, upper case
Xletters draw white pieces, and lower case letters draw black pieces.
XFor example, "Knk" draws a white king adjacent to a black knight
Xand a black king.  The pieces include a selection of fairy pieces
Xand other related symbols -- everything I've seen or had reported
Xto me on chess diagrams in the last few years.  The other symbols
Xin this sub-font consist of board-drawing components and motions
Xto facilitate the construction of diagrams.  You switch between
Xtext and diagram modes using the prime symbol, "'".  For example,
Xthe famous Reti study can be diagrammed by the PostScript:
X
X		('#[7K;8;k1P;7p;8;8;8;8]') show
X
Xwhere "#" draws the board, and the stuff between "[...]" is the
Xconventional Forsythe notation for the position.  Obviously, for
Xpractical use, you will need a chess pre-processor (which I have
X*not* written!).
X
X	Most of the capabilities of the font are illustrated on
Xthe demo page, which also includes some possibly-useful PostScript
Xprocedures for various of the effects.
X
X	Warning:  the dual-mode font treads on very thin ice in
Xsome places!  In particular, the caching mechanisms of PostScript
Xare very easy to fool with a dynamic font of this type.  For example,
Xfinding the width of a string is fraught with danger;  do it only
Xwith strings that include matched pairs of primes.
X
XThe font design:
X--- ---- -------
X	There are surprisingly many different chess fonts in use in
Xprinted books.  I have tried to copy the simplest -- for example,
Xthe rooks have no brickwork, and the kings are quite plain.  Note
Xthat the pieces do not scale well.  Large pieces (inches high) for
Xposters, etc., will have to be specially designed (and are usually
Xbased on "real" Staunton pieces).  Tiny pieces suffer from the lack
Xof resolution on 300 dpi (or coarser) printers.  On a 300 dpi printer,
X7-point is really too small, anything less is hopeless (see the demo).
XI usually use 15-point, which is comparable with most books.
X
X	The hardest piece to get right is the knight.  The book designs
Xare hopeless at 300 dpi resolution, as there are too many fine lines
Xaround the mouth and chin.  Any attempts to copy them just look like a
Xcaricature.  So I've made it a bit chunkier.  Most readers don't notice.
X
X	Note that most of the pieces (as opposed to the figurines)
Xcannot be cached.  This is because they include both write-white and
Xwrite-black components (partly, but not entirely, because they have
Xto work on black squares);  this makes drawing a whole page of black
Xkings (or whatever) rather slooow.  Fortunately, you don't often need
Xsuch a thing.  The figurines *are* cached, so are the Informant symbols,
Xand so are the commonest pieces (the black squares, and the pawns of
Xboth colours).
X
XForeign usage:
X------- ------
X	Foreign users may want to re-assign the letters used for the
Xvarious pieces.  This can easily be done in the Font file.  Lines
Xsuch as
X
X	dup 8#113 /WK put		% 'K'
X
X(not too far down the file) signify that ASCII character 113 (octal), or
X"K", is to draw the White King.  If you want some other character to draw
Xthe WK, alter the 113 to match.  You will have to change the BK and Kfig
Xby the same amount, and you will also have to reassign whatever symbol
Xyour chosen character already draws, if any.  Another minor problem is
Xthat some of the fairy pieces are defined explicitly in terms of the
Xexisting pieces -- eg, if you decide to use "F" to draw White queens,
Xthen the procedure for Grasshoppers (look for "WG" in Font) must be
Xchanged to draw upside-down "F" instead of upside-down "Q".  I hope the
Xnecessary edits are obvious even to non-PostScript users.  I suggest that
Xafter any change you try the Table and Demo files again.
X
XUnusual chess pieces:
X------- ----- -------
X	I've included a fair number of pieces that may not be familiar to
Xall chess players.  These include:
X	F for fou, French version of bishop.  There are several designs
X	    of fou in print, I have selected the easiest to implement.  If
X	    you want one of the others, you'll have to write it yourself.
X	D,X for draughts pieces.  Note that these are not cached (except
X	    as figurines);  if you are writing a book on draughts with
X	    lots of diagrams, you might find it worthwhile to re-write
X	    them in a cachable way.  This is easier if you want to use
X	    them on the white squares (you don't need the "halo" effect),
X	    but the books I have seen are about equally split on this.
X	C,I,T for chameleon, imitator, rose.  Various fairy pieces.
X	E,G,L,M,O,S,U,V,Z for various rotated standard pieces, used in
X	    fairy chess.  Note that the "Demo" file includes a more
X	    general way to rotate a piece.  I have used S for nightrider,
X	    oppositely to the problemists convention which uses S for
X	    knight and N for nightrider;  there is no way that the average
X	    player is going to change his habits!  If you are a problemist,
X	    feel free to interchange S and N (and then M and Z).
X	.,@,|,_ for various other marks useful in annotating diagrams.
X	    See the "Demo" file for examples of their use.
X	A,H,J,W,Y are unused.  Feel free to use them to add new pieces.
X
XGo pieces:
X-- -------
X	Sorry, despite several requests, I haven't put these in.  I
Xcan't save the whole world in one easy lesson.  The pieces themselves
Xand the board are easy in PostScript;  the annotations and the necessary
Xpre-processor are another kettle of fish.  The Go stones could also be
Xused for Reversi (Othello).
X
XBridge symbols:
X------ --------
X	No-one has actually asked for these, but just to forestall you,
Xnote that they are already provided in many places -- symbol fonts,
Xdingbats fonts, Hershey fonts, ....
X
XFinal comments:
X----- ---------
X	Suggestions for improvements, especially in the PostScript,
Xwill be welcomed.  Especially if they improve portability (which I
Xcan't check locally!).  Especially if you've tried them yourself,
Xand can vouch that they work.  Suggestions for extra symbols (other
Xthan Go or Bridge) also welcomed, especially if accompanied by
XPostScript or other descriptions of their shape.
X
X-- 
XAndy Walker, Maths Dept., Nott'm Univ., UK.
Xanw@maths.nott.ac.uk
END_OF_FILE
if test 9917 -ne `wc -c <'doc/README.font'`; then
    echo shar: \"'doc/README.font'\" unpacked with wrong size!
fi
# end of 'doc/README.font'
fi
if test -f 'doc/README.output' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/README.output'\"
else
echo shar: Extracting \"'doc/README.output'\" \(3639 characters\)
sed "s/^X//" >'doc/README.output' <<'END_OF_FILE'
XEnter #moves #minutes: 0 0
XOperator time(hundredths)= 0
X
XWhite 0:00  Black 0:00
X
X R N B Q K B N R
X P P P P P P P P
X - - - - - - - -
X - - - - - - - -
X - - - - - - - -
X - - - - - - - -
X p p p p p p p p
X r n b q k b n r
X
XBook used 4649 of 5500 entries
XPlaying without hashfile
X
X		There are 4649 unique position/move pairs in the book
X		There is room for a maximum of 5499 entries but it
X		should not be brought above 5400 because of the way they
X		are stored.
X
X		The hashfile gnuchess.hash was not found or was not writable.
X
XYour move is? get
XEnter file name: 
XTEST/test1
X
X
XWhite 0:00  Black 0:00
X
X - - - - - - - -
X - - - - - - - -
X - - P P - - - K
X - - - - - - - -
X - p - p - - - k
X - - - - - - - -
X - - - - - - - -
X - - - - - - - -
X
X
XYour move is? white
X
XYour move is? post
X
XYour move is? level
XEnter #moves #minutes: 40 5
XOperator time(hundredths)= 0
X
XYour move is? go
X
XMove# 1    Target= 359    Clock: 30000
X		
X		Target is the time it would like to use for this move
X		3.59 seconds Clock is the available time 300 seconds.
X
XSearch      Time  Positions
XDepth Score (secs) searched Principle Variation
X 1.    -56    0       10   h4g4 
X 2.    -14    0       38   d4d5  c6d5 
X 3&     50    0       58   d4d5  c6d5  b4b5 
X 3.     50    0       96   d4d5  c6d5  b4b5 
X 4&     43    0      154   d4d5  c6d5  b4b5  d5d4 
X 4.     43    0      211   d4d5  c6d5  b4b5  d5d4 
X 5&     37    0      329   d4d5  c6d5  b4b5  d5d4  b5b6 
X 5.     37    0      515   d4d5  c6d5  b4b5  d5d4  b5b6 
X 6&     -4    0      905   d4d5  c6d5  b4b5  d5d4  h4g4  d4d3 
X 6.     -4    1     1153   d4d5  c6d5  b4b5  d5d4  h4g4  d4d3 
X 7+    122    1     1728   d4d5  c6d5  b4b5  d5d4  b5b6  d4d3  b6b7 
X 7-     10    1     1891   d4d5  c6d5  h4g3  d5d4  b4b5  d4d3 
X 7.     10    1     2577   d4d5  c6d5  h4g3  d5d4  b4b5  d4d3 
X 8&    -19    2     4195   d4d5  c6d5  h4g3  d5d4  g3f3  d6d5  b4b5  d4d3 
X 8+    123    2     6833   h4g3  h6g6  d4d5  c6c5  b4c5  d6c5  d5d6  g6f6 
X                           d6d7 
X 8&    123    3     7205   h4g3  d6d5  g3f4  h6h7  f4e5  h7h8  e5d6  h8g8 
X                           d6c6 
X 8.    123    3     8933   h4g3  d6d5  g3f4  h6h7  f4e5  h7h8  e5d6  h8g8 
X                           d6c6 
X 9&    141    5    16265   h4g3  h6g6  d4d5  c6d5  b4b5  d5d4  b5b6  d4d3 
X                           g3f3 
X 9.    141    5    17767   h4g3  h6g6  d4d5  c6d5  b4b5  d5d4  b5b6  d4d3 
X                           g3f3 
X10.    141    8    26004   h4g3  h6g6  d4d5  c6d5  b4b5  d5d4  b5b6  d4d3 
X                           g3f3 
Xwhere:
X	. = Final result of this level
X	& = Intermediate best move inside <alpha beta> window
X	+ = best move greater than beta in <alpha beta> window
X	- = best move less than alpha in <alpha beta> window
X	   If best move is outside window it will cause a re-search high or low
X	   if it persists at end of level, + always causes a re-search.
X	   These are only printed above level 2.
X
X1. ... h4g3
XNodes 26004 Tree 142 Eval 8358 Rate 0 RS low 1 high 2
XHin/Hout/TColl/Coll/Fin/Fout = 3764/4360/0/0/0/0
X
X	Nodes = Number of positions examined
X	Tree  = Maximum entries in the search tree
X	Eval  = Number of position evaluations done
X	Rate  = Search rate in positions/sec
X	RS    = Re-searches high and low forced by the window
X	Hin   = Number of entries created in in-core transposition table
X	Hout  = Number of entries found in in-core transposition table
X	Tcoll = Number of overwrites in transposition table
X	Coll  = Number of collisions in in-core transposition table
X	Fin   = Number of entries created in external transposition table
X	Fout  = Number of entries found in external transposition table
X
XMy move is: h4g3
END_OF_FILE
if test 3639 -ne `wc -c <'doc/README.output'`; then
    echo shar: \"'doc/README.output'\" unpacked with wrong size!
fi
# end of 'doc/README.output'
fi
if test -f 'doc/gnuchess.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/gnuchess.1'\"
else
echo shar: Extracting \"'doc/gnuchess.1'\" \(9940 characters\)
sed "s/^X//" >'doc/gnuchess.1' <<'END_OF_FILE'
X.TH Chess GNUCHESS
X.SH NAME
Xgnuchess \- Chess
X.SH SYNOPSIS
X.B gnuchess
X[
X.B [-L lang] 
X.B [-t] [-c size] 
X.B [-s pathname] [-l pathname] 
X.B [-v]
X.B [-T size]
X.B [-r length]
X.B arg1 arg2
X]
X.SH DESCRIPTION
X.I Gnuchess
Xplays a game of chess against the user or it plays against itself.
X.PP
X.I Gnuchess
Xis an updated version of the gnuchess program.
XIt has a simple alpha-numeric board display, an IBM PC compatible interface,
Xor it can be compiled for use with the 
X.B chesstool 
Xprogram on a SUN workstation or with the 
X.B xboard 
Xprogram under X-windows.
XThe program gets its opening moves from the file 
X.B gnuchess2.book 
Xwhich is  located in a directory specified in the makefile.
XTo invoke the program type:
X.TP
X.B gnuchess
X- curses based version
X.TP
X.B gnuchessn 
X- IBM PC character set based version
X.TP
X.B gnuchessr 
X- ASCII based version
X.TP
X.B gnuchessc 
X- chesstools compatible version
X.TP
X.B gnuchessx 
X- xboard compatible version
X.SH TIME CONTROLS
X.PP
XIf one argument is given and it begins with a
X.B :
Xthen it is the search time per move in seconds. 
XIf it has no 
X.B :
Xit is the search depth in plys.
XSo 
X.B gnuchess :30
Xwill generate 1 move every 30 seconds, while
X.B gnuchess 5
Xwill search each move to depth 5.
X
XIf two or more arguments are given, they will be used to set tournament
Xtime controls with the first argument of each pair being the number of moves and the second
Xbeing the total clock time in minutes[
X.B :
Xseconds].  Thus, entering 
X.B gnuchess 60 5
Xwill set
Xthe clocks for 5 minutes (300 seconds) for the first 60 moves,
Xand 
X.B gnuchess 30 3:30
Xwill allow 3 minutes and 30 seconds for 30 moves.
X
X.B gnuchess 30 5 1 :30
Xwill allow 5 minutes for the first 30 moves and 30 seconds for each move after that.
XUp to 4 pairs of controls may be specified.
X
XIf no argument is given the program will prompt the user for level of play.
X
XFor use with 
X.B chesstool
Xor
X.B xboard
X, see the documentation on those programs.
X.SH BOOK
X.PP
XThe book
X.I gnuchess.book
Xconsists of a sequence of openings.
XAn opening begins with a card starting with a 
X.B !
X, the rest of the card is comments.
XFollowing this is a series of moves in algebraic notation alternating white
Xand black separated by white space. A move may have a 
X.B ?
Xafter it indicating this move should never be made in this position.
XMoves are stored as position:move so transpositions between openings
Xcan take place. 
X.SH HASHFILE
X.PP
XThe hashfile if created should be on the order of 4 megabytes or
X.B gnuchess -c 22.
XThis file contains positions and moves learned from previous games. 
XIf a hashfile is used the computer makes use of the experience it
Xgained in past games. Tests run so far show that it plays no worse
Xwith the hashfile than without, but it is not clear yet whether
Xit provides a real advantage. 
X.SH LEGAL MOVES
X.PP
X.B Note:
XPiece letters and legal castling notation is determined by the language file.
XWhat is specified here is the default english.
X.PP
XOnce
X.I gnuchess
Xis invoked, the program will display the board and prompt the user
Xfor a move. To enter a move, use the notation 
X.B e2e4
Xwhere the first letter-number pair indicates the origination square
Xand the second letter-number pair indicates the destination square.
XAn alternative is to use the notation 
X.B nf3
Xwhere the first letter indicates the piece type (p,n,b,r,q,k).
XTo castle, type the origin and destination squares
Xof the king just as you would do for a regular move, or type
X.B o-o
Xor
X.B 0-0
Xfor kingside castling and 
X.B o-o-o
Xor
X.B 0-0-0
Xfor queenside.  To promote a pawn append the type of the new piece to the move, as in 
X.B e7e8q 
Xor 
X.B c7c8r.
X.SH "FUNCTION LETTERS"
X.TP
X.B -L lang
XUse language 
X.I lang from the file 
X.B gnuchess.lang.
XIf -L is not specified it uses the first language in the file.
X.TP
X.B -v
XShow version and patchlevel.
X.TP
X.B -t
XShow statistics for HASHFILE
X.TP
X.B -c size
XCreate a new HASHFILE. File size is 2^size bytes.
X.TP
X.B -s pathname
XPathname of the save file to use with the
X.BR save
Xcommand.
X.TP
X.B -T size
XSet the transposition table size to 2^size entries.
X.TP
X.B -r length
XSearch length entries for position in transposition table.
X.TP
X.B -l pathname
XPathname of the loadfile use with the
X.BR get
Xor
X.BR xget.
X.SH COMMANDS
X.PP
XIn addition to legal moves, the following commands are available as responses.
X.BNote:
X command names are determined by the 
X.Ilanguage
Xfile and may vary with the implementation. This is default english.
X.PP
X.B alg
X-- allow algrbraic input (not implemented)
X.PP
X.B Awindow
X-- change Alpha window (default score + 90)
X.PP
X.B Bwindow
X-- change Beta window (default score - 90)
X.PP
X.B beep
X-- causes the program to beep after each move.
X.PP
X.B bd
X-- updates the current board position on the display.
X.PP
X.B book
X-- turns off use of the opening library.
X.PP
X.B both
X-- causes the computer to play both sides of a chess game.
X.PP
X.B black
X-- causes the computer to take the white pieces, if the computer is to move first the 
X.B go
Xcommand must be given.
X.PP
X.B coords
X-- show coordinates on the display (visual only)
X.PP
X.B contempt
X-- allows the value of 
X.I contempt
Xto be modified.
X.PP
X.B debug
X--  asks for a piece as color piece, as wb or bn, and shows its calculated value on
Xeach square.(allowed only on visual versions)
X.PP
X.B debuglevel
X--  sets level of debugging output if compiled with debug options.
X.PP
X.B depth
X-- allows the user to change the
Xsearch depth of the program.  The maximum depth is 29 ply.
XNormally the depth is set to 29 and the computer terminates
Xits search based on elapsed time rather than depth.
XUsing the depth command allows setting depth to say
X4 ply and setting response time to a large number such as
X9999 seconds. The program will then search until all moves
Xhave been examined to a depth of 4 ply (with extensions up
Xto 11 additional ply for sequences of checks and captures). 
X.PP
X.B easy
X-- toggles easy mode (thinking on opponents time)
Xon and off. The default is easy mode ON.  If easy mode is disabled,
Xthe keyboard is polled for input every so often and when input is
Xseen the search is terminated. It may also be terminated with a 
X.Isigint.
X.PP
X.B edit
X-- allows the user to set up a board position.
X
X.B 	#
X- command will clear the board.
X
X.B 	c 
X- toggle piece color. 
X
X.B 	.
X- command will exit setup mode.
X
X.B	pb3
X- place a pawn on b3
X
XPieces are entered by typing a letter (p,n,b,r,q,k) for
Xthe piece followed by the coordinate.
X
XThe usual warning about the
X.I language file
Xapplys.
X.PP
X.B exit
X-- exits gnuchess.
X.PP
X.B first
X-- tells the computer to move first. Computer begins searching for a move.
X(same as "go").
X.PP
X.B force
X-- allows the user to enter moves for both
Xsides. To get the program to play after a sequence of moves
Xhas been entered use the 'white' or 'black' commands.
X.PP
X.B get
X-- retrieves a game from disk.  The program will
Xprompt the user for a file name.
X.PP
X.B hash
X-- use/don't use hashfile.
X.PP
X.B hashdepth
X-- allows the user to change the minimum depth for using the hashfile and the number of moves from the
Xbegining of the game to use it.
X.PP
X.B help
X-- displays a short description of the commands and the current status of options.
X.PP
X.B go
X-- tells the computer to move first. Computer begins searching for a move.
X(same as "first").
X.PP
X.B hint
X-- causes the program to supply the user with its predicted move.
X.PP
X.B level
X-- allows the user to set time controls such as
X60 moves in 5 minutes etc.  In tournament mode, the program will
Xvary the time it takes for each
Xmove depending on the situation.  If easy mode is disabled (using
Xthe 'easy' command), the program
Xwill often respond with its move immediately, saving time on
Xits clock for use later on.
X.PP
X.B list
X-- writes the game moves and some statistics
Xon search depth, nodes, and time to the file 'chess.lst'.
X.PP
X.B material
X-- toggle material flag - draws on no pawns and both sides < rook
X.PP
X.B new
X-- starts a new game.
X.PP
X.B p
X-- evaluates the board and shows the point score for each piece. The total score for
Xa position is the sum of these individual piece scores.(allowed only on visual versions)
X.PP
X.B post
X-- causes the program to display the principle
Xvariation and the score during the search.  A score of
X100 is equivalent to a 1 pawn advantage for the computer.
X.PP
X.B quit
X-- exits the game.
X.PP
X.B random
X-- causes the program to randomize its move
Xselection slightly.
X.PP
X.B rcptr
X-- set recapture mode.
X.PP
X.B remove
X-- backout the last level for both sides. Equal to 2 
X.I undo's.
X.PP
X.B reverse
X-- causes the board display to be reversed.  That
Xis, the white pieces will now appear at the top of the board.
X.PP
X.B rv
X-- reverse board display.
X.PP
X.B setup
X-- Compatibility with Unix chess and the nchesstool. Set up a board position.
XEight lines of eight characters are used to setup the board. a8-h8 is the
Xfirst line. Black pieces are  represented  by  uppercase characters.
X.PP
X.B stars
X-- (gnuchessn only) add stars (*) to black pieces.
X.PP
X.B save
X-- saves a game to disk.  The program will prompt
Xthe user for a file name.
X.PP
X.B switch
X-- causes the program to switch places with
Xthe opponent and begin searching.
X.PP
X.B test
X-- performs some speed tests for MoveList and CaptureList generation, and ScorePosition position scoring
Xfor the current board. 
X.PP
X.B time
X-- set computers time remaining, intended for synchronizing clocks among multiple players.
X.PP
X.B undo
X-- undoes the last move whether it was the computer's
Xor the human's. You may also type "remove". This is equivalent
Xto two "undo's" (e.g. retract one move for each side).
X.PP
X.B white
X-- causes the computer to take the black pieces, if the computer is to move first the 
XiB go
Xcommand must be given.
X.PP
X.B xget
X-- read an 
X.Ixboard
Xposition file.
X.PP
X.B xwndw
X-- change X window. The window around alpha/beta used to determine whether the position
Xshould be scored or just estimated.
X.SH BUGS
X.PP
X.fi
X.SH SEE ALSO
X.nf
Xchesstool(6)
Xxboard(6)
X.fi
X
END_OF_FILE
if test 9940 -ne `wc -c <'doc/gnuchess.1'`; then
    echo shar: \"'doc/gnuchess.1'\" unpacked with wrong size!
fi
# end of 'doc/gnuchess.1'
fi
if test -f 'src/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/Makefile'\"
else
echo shar: Extracting \"'src/Makefile'\" \(11448 characters\)
sed "s/^X//" >'src/Makefile' <<'END_OF_FILE'
X#
X# Makefile for GNU Chess
X#
X# Copyright (c) 1992 Free Software Foundation
X#
X# This file is part of GNU CHESS.
X#
X# GNU Chess is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X#
X# GNU Chess is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X#
X# You should have received a copy of the GNU General Public License
X# along with GNU Chess; see the file COPYING.  If not, write to
X# the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X
X#
X# gnuchess  is a curses-based chess.
X# gnuchessn is a fancy-display-curses-based chess.
X# gnuchessr is a plain dumb-terminal chess (but with full variation output)
X# gnuchessc is suitable for chesstool use (mimics /usr/games/chess output)
X# gnuchessx is the xchess based chess.
X#
X
X# The version number of this release
XVERS=	4.0
X
X# Relevant file areas.
XDIST=	../README ../README.lang ../doc ../misc ../src ../test
X
X# Distribution directory
XDISTDIR=/tmp_mnt/home/fsf/cracraft/Ch
X
X# Change these to something less transitory, like /usr/games, and then
X# compile. Ask your system admin / unix guru to put gnuchess.{hash,lang,book}
X# in $(LIBDIR).
X# Where the binaries live.
XBINDIR= /tmp
X
X# Where language description, our book, and the persistent hash live.
XLIBDIR= /tmp
X
X# Display routines.
XLCURSES=-lcurses -ltermcap
X
X#compile options for gnuchess
X# -DAG[0-4]  selects a set of values for SpaceBonus tables
X# -DQUIETBACKGROUND don't print post information in background ( easy OFF)
X# -DNOMEMSET if your machine does not support memset
X# -DNOMATERIAL don't call it a draw when no pawns and both sides < rook
X# -DNODYNALPHA don't dynamically adjust alpha
X# -DNOHISTORY don't use history killer hueristic 
X# -DNOSCORESPACE don't use Scorespace hueristic
X# -DOLDXBOARD don't generate underpromote moves
X# -DGNU3 don't generate underpromote moves
X# -DLONG64 if you have 64bit longs
X# -DSYSV   if you are using SYSV
X# some debug options
X# -DDEBUG8 dump board,movelist,input move to /tmp/DEBUG if illegal move
X# -DDEBUG9 dump move list from test command
X# -DDEBUG10 dump board and move after search before !easy begins
X# -DDEBUG11 dump board when the move is output
X# -DDEBUG12 dump boards between moves
X# -DDEBUG13 dump search control information for each move to /tmp/DEBUG
X# -DDEBUG40 include extra values of variables for debugging  in game list
X# the rest of the debug options are tied to the debuglevel command
X# -DDEBUG -DDEBUG4 set up code for debuglevel command
X#          debuglevel
X#               1 always force evaluation in evaluate
X#               4 print move list after search
X#               8 print move list after book before search
X#              16 print move list after each ply of search
X#              32 print adds to transposition table
X#              64 print returns from transposition table lookups
X
X
XOPT= -DAG4 -DQUIETBACKGROUND -DNOHISTORY
X
X# The hashfile is a record of positions seen. It is used by
X# GNU Chess to avoid making the same mistakes, a form of learning.
XHASH=	-DHASHFILE=\"$(LIBDIR)/gnuchess.hash\"
X
X# The "book" is a record of the first few moves, for playing good
X# moves easily and quickly, saving time, and irritating the human
X# opponent.
XBOOK=	-DBOOK=\"$(LIBDIR)/gnuchess.book\"
X
X# The language file describes capabilities of the program. Perhaps
X# it is useful for non-English speaking countries and customizing
X# for their convenience and chess happiness.
XLANG= -DLANGFILE=\"$(LIBDIR)/gnuchess.lang\"
X
X# The compiler used for compiling this software.
X# Use this for a plain C compiler 
X#CC= cc $(OPT)
X# Use this if you are lucky enough to have GNU CC.
XCC=	gcc -W $(OPT)
X
X# Miscellaneous CFLAGS. Uncomment the one you need and comment 
X# the other.
X#CFLAGS= -p -Dinline=""	 -traditional-cpp
X#CFLAGS=	-O4 -Qpath .  # SunOS cc using unprotoize
X#CFLAGS= -O4 # Sun acc
X#CFLAGS= -g # debug
XCFLAGS= -O   -finline-functions -fstrength-reduce  # gnu cc 1.40
X#CFLAGS= -O   -finline-functions -fstrength-reduce -D__mips -D__LANGUAGE_C # gnu cc on DS5000
X#CFLAGS= -O2   -funroll-loops  # gnu cc  2.00 on others
X#CFLAGS= -O -Aa -DSIGQUIT=_SIGQUIT -DSYSV # HPUX cc 
X#CFLAGS= -O2  -funroll-loops -traditional-cpp  # gnu cc  2.00 on SunOS
X
Xall : gnuchess gnuchessr gnuchessn gnuchessx gnuchessc postprint gnuan game checkbook checkgame
X
Xgnuchess: main.o book.o genmoves.o ataks.o util.o eval.o init.o search.o dspcom.o uxdsp.o
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -o gnuchess main.o book.o genmoves.o ataks.o util.o eval.o init.o search.o dspcom.o uxdsp.o $(LCURSES)
X
Xgnuan: main.o book.o genmoves.o ataks.o util.o eval.o init.o search.o gnuan.o
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -o gnuan main.o book.o genmoves.o ataks.o util.o eval.o init.o search.o gnuan.o
X
Xgnuchessc: mainC.o bookC.o genmovesC.o ataks.o util.o eval.o init.o searchC.o dspcomC.o nondspC.o
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -o gnuchessc mainC.o bookC.o genmovesC.o ataks.o util.o eval.o init.o searchC.o dspcomC.o nondspC.o
X
XDgnuchessr: mainDR.o book.o genmoves.o ataks.o utilDR.o evalDR.o init.o searchDR.o dspcomDR.o nondspDR.o
X	$(CC)  -DDEBUG  -DDEBUG4 $(CFLAGS) $(HASH) $(LANG) $(BOOK) -o gnuchessr mainDR.o book.o genmoves.o ataks.o utilDR.o evalDR.o init.o searchDR.o dspcomDR.o nondspDR.o
X
Xgnuchessx: mainX.o bookX.o genmovesX.o ataks.o util.o eval.o init.o searchX.o dspcomX.o nondspX.o
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -o gnuchessx mainX.o bookX.o genmovesX.o ataks.o util.o eval.o init.o searchX.o dspcomX.o nondspX.o
X
Xgnuchessr: main.o book.o genmoves.o ataks.o util.o eval.o init.o search.o dspcomR.o nondspR.o
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -o gnuchessr main.o book.o genmoves.o ataks.o util.o eval.o init.o search.o dspcomR.o nondspR.o
X
Xgnuchessn: main.o book.o genmoves.o ataks.o util.o eval.o init.o search.o dspcom.o nuxdsp.o
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -o gnuchessn main.o book.o genmoves.o ataks.o util.o eval.o init.o search.o dspcom.o nuxdsp.o $(LCURSES)
X	
Xgame: game.c gnuchess.h
X	$(CC) $(CFLAGS) -o game game.c
X	
Xpostprint: postprint.o
X	$(CC) $(CFLAGS) -o postprint postprint.o
X	
Xcheckbook: checkbook.o
X	$(CC) $(CFLAGS) -o checkbook checkbook.o
X	
Xcheckgame: checkgame.o
X	$(CC) $(CFLAGS) -o checkgame checkgame.o
X
Xgnuan.o: gnuan.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c gnuan.c
X
Xmain.o: main.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c main.c
XmainC.o: main.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DNONDSP -DCHESSTOOL \
X		-c main.c -o mainC.o
XmainX.o: main.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DXBOARD  -c main.c -o mainX.o
XmainDR.o: main.c gnuchess.h version.h
X	$(CC)  -DDEBUG -DDEBUG4 $(CFLAGS) $(HASH) $(LANG) $(BOOK) \
X		-c main.c -o mainDR.o
X
Xgenmoves.o: genmoves.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c genmoves.c
XgenmovesC.o: genmoves.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DNONDSP -DCHESSTOOL \
X		-c genmoves.c -o genmovesC.o
XgenmovesX.o: genmoves.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DXBOARD \
X		-c genmoves.c -o genmovesX.o
X
Xbook.o: book.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c book.c 
XbookC.o: book.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DNONDSP -DCHESSTOOL \
X		-c book.c -o bookC.o
XbookX.o: book.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DXBOARD  -c book.c -o bookX.o
X
Xataks.o: ataks.h ataks.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c ataks.c
X
Xutil.o: util.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c util.c
X
Xeval.o: eval.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c eval.c
XevalDR.o: eval.c gnuchess.h version.h
X	$(CC)  -DDEBUG4 -DDEBUG $(CFLAGS) $(HASH) $(LANG) $(BOOK) \
X		-c eval.c -o evalDR.o
XutilDR.o: util.c gnuchess.h version.h
X	$(CC)  -DDEBUG4 -DDEBUG $(CFLAGS) $(HASH) $(LANG) $(BOOK) \
X		-c util.c -o utilDR.o
X
Xinit.o: init.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c init.c
X
Xsearch.o: search.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c search.c
XsearchC.o: search.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DNONDSP -DCHESSTOOL \
X		-c search.c -o searchC.o
XsearchX.o: search.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DXBOARD \
X		-c search.c -o searchX.o
XsearchDR.o: search.c gnuchess.h version.h
X	$(CC)  -DDEBUG4 -DDEBUG $(CFLAGS) $(HASH) $(LANG) $(BOOK) \
X		-c search.c -o searchDR.o
X
Xuxdsp.o: uxdsp.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c uxdsp.c
X
Xnuxdsp.o: nuxdsp.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c nuxdsp.c
X
Xnondsp.o: nondsp.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c nondsp.c
XnondspC.o: nondsp.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DNONDSP -DCHESSTOOL \
X		-c nondsp.c -o nondspC.o
XnondspX.o: nondsp.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DNONDSP -DXBOARD \
X		-c nondsp.c -o nondspX.o
XnondspR.o: nondsp.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DNONDSP \
X		-c nondsp.c -o nondspR.o
XnondspDR.o: nondsp.c gnuchess.h version.h
X	$(CC)  -DDEBUG4 -DDEBUG $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DNONDSP \
X		 -c nondsp.c -o nondspDR.o
X
Xdspcom.o: dspcom.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -c dspcom.c
XdspcomC.o: dspcom.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DNONDSP -DCHESSTOOL \
X		-c dspcom.c -o dspcomC.o
XdspcomX.o: dspcom.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DNONDSP -DXBOARD \
X		-c dspcom.c -o dspcomX.o
XdspcomR.o: dspcom.c gnuchess.h version.h
X	$(CC) $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DNONDSP \
X		-c dspcom.c -o dspcomR.o
XdspcomDR.o: dspcom.c gnuchess.h version.h
X	$(CC)  -DDEBUG -DDEBUG4 $(CFLAGS) $(HASH) $(LANG) $(BOOK) -DNONDSP \
X		-c dspcom.c -o dspcomDR.o
X
Xpostprint.o: postprint.c gnuchess.h version.h
X	$(CC) $(CFLAGS) -c postprint.c
X
Xlint:
X	lint gnuchess.c uxdsp.c nondsp.c nuxdsp.c
X
Xdistribution:
X	-patchlevel=`cat $(DISTDIR)/gnuchess-$(VERS)/src/version.h|grep patchlevel|sed -e 's/[^0-9]//g'` ;\
X	echo "patchlevel is $$patchlevel" ;\
X	cd $(DISTDIR) ;\
X	rm -f gnuchess.tar.$(VERS).Z* gnuchess.tar.$(VERS).Z.uu* ;\
X	tar cf - gnuchess-$(VERS) | compress > $(DISTDIR)/gnuchess-$(VERS).pl$$patchlevel.tar.Z ;\
X	uuencode gnuchess-$(VERS).pl$$patchlevel.tar.Z gnuchess-$(VERS).pl$$patchlevel.tar.Z > gnuchess-$(VERS).pl$$patchlevel.tar.Z.uu ;\
X	rm -f x?? ;\
X	split -1500 gnuchess-$(VERS).pl$$patchlevel.tar.Z.uu ;\
X	for i in x??; do \
X	  mv $$i $(DISTDIR)/GNU_Chess_$$i; \
X	done
X
Xinstall:
X	-cp gnuchessx $(BINDIR)/gnuchessx
X	-cp gnuchessc $(BINDIR)/gnuchessc
X	-cp gnuchessr $(BINDIR)/gnuchessr
X	-cp gnuchessn $(BINDIR)/gnuchessn
X	-cp postprint $(BINDIR)/postprint
X	-cp gnuan $(BINDIR)/gnuan
X	-cp gnuchess $(BINDIR)/gnuchess
X	-cp checkbook $(BINDIR)/checkbook
X	-cp checkgame $(BINDIR)/checkgame
X	-cp ../misc/gnuchess.book $(LIBDIR)/gnuchess.book
X	-cp ../misc/gnuchess.lang $(LIBDIR)/gnuchess.lang
X
Xclean:
X	-rm -f gnuchessx gnuchessc gnuchess gnuchessr gnuchessn gnuchessd postprint gnuan *.o *~ #*# %*%
END_OF_FILE
if test 11448 -ne `wc -c <'src/Makefile'`; then
    echo shar: \"'src/Makefile'\" unpacked with wrong size!
fi
# end of 'src/Makefile'
fi
if test -f 'src/nondsp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/nondsp.c'\"
else
echo shar: Extracting \"'src/nondsp.c'\" \(14679 characters\)
sed "s/^X//" >'src/nondsp.c' <<'END_OF_FILE'
X/*
X * nondsp.c - UNIX & MSDOS NON-DISPLAY, AND CHESSTOOL interface for Chess
X *
X * Copyright (c) 1988,1989,1990 John Stanback
X * Copyright (c) 1992 Free Software Foundation
X *
X * This file is part of GNU CHESS.
X *
X * GNU Chess is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * GNU Chess is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with GNU Chess; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include <ctype.h>
X#include <signal.h>
X#ifdef MSDOS
X#include <dos.h>
X#include <conio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <time.h>
X#else
X#include <sys/param.h>
X#include <sys/types.h>
X#include <sys/file.h>
X#include <sys/ioctl.h>
Xvoid TerminateSearch (int), Die (int);
X
X#endif /* MSDOS */
X
X#include "gnuchess.h"
X
X#ifdef DEBUG
Xshort int debuglevel = 0;
X
X#endif /* DEBUG */
Xunsigned short int MV[MAXDEPTH];
Xint MSCORE;
X
X#if defined CHESSTOOL || defined XBOARD
Xshort int chesstool = 1;
X
X#else
Xshort int chesstool = 0;
X
X#endif /* CHESSTOOL */
Xextern char mvstr[4][6];
Xint mycnt1, mycnt2;
Xchar *DRAW;
Xextern char *InPtr;
X
Xvoid
XInitialize (void)
X{
X  mycnt1 = mycnt2 = 0;
X#if defined CHESSTOOL || defined XBOARD
X#ifndef SYSV
X  setlinebuf (stdout);
X#else
X  setvbuf (stdout, NULL, _IOLBF, BUFSIZ);
X#endif
X  printf (CP[43]);		/*Chess*/
X  if (Level == 0 && !TCflag)
X    Level = 15;
X#endif /* CHESSTOOL */
X}
X
Xvoid
XExitChess (void)
X{
X  signal (SIGTERM, SIG_IGN);
X  ListGame ();
X  exit (0);
X}
X
X#ifndef MSDOS			/* never called!!! */
Xvoid
XDie (int sig)
X{
X  char s[80];
X
X  ShowMessage (CP[31]);		/*Abort?*/
X  scanz ("%s", s);
X  if (strcmp (s, CP[210]) == 0)	/*yes*/
X    ExitChess ();
X}
X
X#endif /* MSDOS */
X
Xvoid
XTerminateSearch (int sig)
X{
X#ifdef MSDOS
X  sig++;			/* shut up the compiler */
X#endif /* MSDOS */
X  if (!flag.timeout)
X    flag.musttimeout = true;
X  flag.bothsides = false;
X}
X
X
Xvoid
Xhelp (void)
X{
X  ClrScreen ();
X  /*printz ("CHESS command summary\n");*/
X  printz (CP[40]);
X  printz ("----------------------------------------------------------------\n");
X  /*printz ("g1f3      move from g1 to f3      quit      Exit Chess\n");*/
X  printz (CP[158]);
X  /*printz ("Nf3       move knight to f3       beep      turn %s\n", (flag.beep) ? "off" : "on");*/
X  printz (CP[86], (flag.beep) ? CP[92] : CP[93]);
X  /*printz ("a7a8q     promote pawn to queen\n");*/
X  printz (CP[128], (flag.material) ? CP[92] : CP[93]);
X  /*printz ("o-o       castle king side        easy      turn %s\n", (flag.easy) ? "off" : "on");*/
X  printz (CP[173], (flag.easy) ? CP[92] : CP[93]);
X  /*printz ("o-o-o     castle queen side       hash      turn %s\n", (flag.hash) ? "off" : "on");*/
X  printz (CP[174], (flag.hash) ? CP[92] : CP[93]);
X  /*printz ("bd        redraw board            reverse   board display\n");*/
X  printz (CP[130]);
X  /*printz ("list      game to chess.lst       book      turn %s used %d of %d\n", (Book) ? "off" : "on", bookcount, BOOKSIZE);*/
X  printz (CP[170], (Book) ? CP[92] : CP[93], bookcount, BOOKSIZE);
X  /*printz ("undo      undo last ply           remove    take back a move\n");*/
X  printz (CP[200]);
X  /*printz ("edit      edit board              force     enter game moves\n");*/
X  printz (CP[153]);
X  /*printz ("switch    sides with computer     both      computer match\n");*/
X  printz (CP[194]);
X  /*printz ("white     computer plays white    black     computer plays black\n");*/
X  printz (CP[202]);
X  /*printz ("depth     set search depth        clock     set time control\n");*/
X  printz (CP[149]);
X  /*printz ("post      principle variation     hint      suggest a move\n");*/
X  printz (CP[177]);
X  /*printz ("save      game to file            get       game from file\n");*/
X  printz (CP[188]);
X  /*printz ("random    randomize play          new       start new game\n");*/
X  printz (CP[181]);
X  printz ("----------------------------------------------------------------\n");
X  /*printz ("Computer: %-12s Opponent:            %s\n",*/
X  printz (CP[46],
X	  ColorStr[computer], ColorStr[opponent]);
X  /*printz ("Depth:    %-12d Response time:       %d sec\n",*/
X  printz (CP[51],
X	  MaxSearchDepth, Level);
X  /*printz ("Random:   %-12s Easy mode:           %s\n",*/
X  printz (CP[99],
X	  (dither) ? CP[93] : CP[92], (flag.easy) ? CP[93] : CP[92]);
X  /*printz ("Beep:     %-12s Transposition file: %s\n",*/
X  printz (CP[36],
X	  (flag.beep) ? CP[93] : CP[92], (flag.hash) ? CP[93] : CP[92]);
X  /*printz ("Time Control %s %d moves %d seconds %d opr %d depth\n", (TCflag) ? "ON" : "OFF",*/
X  printz (CP[110], (TCflag) ? CP[93] : CP[92],
X	  TimeControl.moves[white], TimeControl.clock[white] / 100, OperatorTime, MaxSearchDepth);
X  signal (SIGINT, TerminateSearch);
X#ifndef MSDOS
X  signal (SIGQUIT, TerminateSearch);
X#endif /* MSDOS */
X}
X
Xvoid
XEditBoard (void)
X
X/*
X * Set up a board position. Pieces are entered by typing the piece followed
X * by the location. For example, Nf3 will place a knight on square f3.
X */
X
X{
X  short a, r, c, sq, i, found;
X  char s[80];
X
X  flag.regularstart = false;
X  Book = 0;
X  ClrScreen ();
X  UpdateDisplay (0, 0, 1, 0);
X  /*printz (".   exit to main\n");*/
X  printz (CP[29]);
X  /*printz ("#   clear board\n");*/
X  printz (CP[28]);
X  /*printz ("c   change sides\n");*/
X  printz (CP[136]);
X  /*printz ("enter piece & location: \n");*/
X  printz (CP[155]);
X
X  a = white;
X  do
X    {
X      scanz ("%s", s);
X      found=0;
X      if (s[0] == CP[28][0])	/*#*/
X	for (sq = 0; sq < 64; sq++)
X	  {
X	    board[sq] = no_piece;
X	    color[sq] = neutral;
X	  }
X      if (s[0] == CP[136][0])	/*c*/
X	a = otherside[a];
X      c = s[1] - 'a';
X      r = s[2] - '1';
X      if ((c >= 0) && (c < 8) && (r >= 0) && (r < 8))
X	{
X	  sq = locn (r, c);
X	  color[sq] = a;
X	  board[sq] = no_piece;
X	  for (i = no_piece; i <= king; i++)
X	    if ((s[0] == pxx[i]) || (s[0] == qxx[i]))
X	      {
X		board[sq] = i;
X		found=1;
X		break;
X	      }
X	  if (found==0) color[sq] = neutral;	
X	}
X  } while (s[0] != CP[29][0]);
X  for (sq = 0; sq < 64; sq++)
X    Mvboard[sq] = ((board[sq] != Stboard[sq]) ? 10 : 0);
X  GameCnt = 0;
X  Game50 = 1;
X  ZeroRPT ();
X  Sdepth = 0;
X  InitializeStats ();
X  ClrScreen ();
X  UpdateDisplay (0, 0, 1, 0);
X}
X
Xvoid
XSetupBoard (void)
X
X/*
X * Compatibility with Unix chess and the nchesstool. Set up a board position.
X * Eight lines of eight characters are used to setup the board. a8-h8 is the
X * first line. Black pieces are  represented  by  uppercase characters.
X */
X
X{
X  short r, c, sq, i;
X  char ch;
X  char s[80];
X
X  NewGame ();
X
X  gets (s);			/* skip "setup" command */
X  for (r = 7; r >= 0; r--)
X    {
X      gets (s);
X      for (c = 0; c <= 7; c++)
X	{
X	  ch = s[c];
X	  sq = locn (r, c);
X	  color[sq] = neutral;
X	  board[sq] = no_piece;
X	  for (i = no_piece; i <= king; i++)
X	    if (ch == pxx[i])
X	      {
X		color[sq] = black;
X		board[sq] = i;
X		break;
X	      }
X	    else if (ch == qxx[i])
X	      {
X		color[sq] = white;
X		board[sq] = i;
X		break;
X	      }
X	}
X    }
X  for (sq = 0; sq < 64; sq++)
X    Mvboard[sq] = ((board[sq] != Stboard[sq]) ? 10 : 0);
X  InitializeStats ();
X  ClrScreen ();
X  UpdateDisplay (0, 0, 1, 0);
X  /*printz ("Setup successful\n");*/
X  printz (CP[106]);
X}
X
Xvoid
XShowDepth (char ch)
X{
X#ifdef MSDOS
X  ch++;				/* shut up the compiler */
X#endif /* MSDOS */
X}
X
X
Xvoid
XShowLine (short unsigned int *bstline)
X{
X  register int i;
X
X  for (i = 1; bstline[i] > 0; i++)
X    {
X      if ((i > 1) && (i % 8 == 1))
X	fprintf (stderr, "\n                          ");
X      algbr ((short) (bstline[i] >> 8), (short) (bstline[i] & 0xFF), false);
X      fprintf (stderr, "%5s ", mvstr[0]);
X    }
X  fprintf (stderr, "\n");
X}
X
Xvoid
XShowResults (short int score, short unsigned int *bstline, char ch)
X{
X#if !defined CHESSTOOL && !defined XBOARD
X  if (flag.post)
X    {
X      ElapsedTime (2);
X      fprintf (stderr, "%2d%c %6d %4ld %8ld  ", Sdepth, ch, score, et / 100, NodeCnt);
X      ShowLine (bstline);
X    }
X#else
X  register int i;
X
X  MSCORE = score;
X  MV[30] = ch;
X  for (i = 1; bstline[i] > 0; i++)
X    {
X      MV[i] = bstline[i];
X    } MV[i] = 0;
X#endif /* CHESSTOOL */
X}
X
Xvoid
XSearchStartStuff (short int side)
X{
X  signal (SIGINT, TerminateSearch);
X#ifndef MSDOS
X  signal (SIGQUIT, TerminateSearch);
X#endif /* MSDOS */
X#if !defined CHESSTOOL && !defined XBOARD
X  if (flag.post)
X    {
X      fprintf (stderr, CP[123],
X	       TCmoves - TimeControl.moves[side] + 1,
X	       ResponseTime, TimeControl.clock[side]);
X    }
X#endif /* CHESSTOOL */
X}
Xvoid
XOutputMove (void)
X{
X#ifdef DEBUG11
X  if (1)
X    {
X      FILE *D;
X      extern unsigned short int PrVar[];
X      char d[80];
X      int r, c, l, i;
X      D = fopen ("/tmp/DEBUGA", "a+");
X      fprintf (D, "inout move is %s\n", mvstr[0]);
X      strcpy (d, mvstr[0]);
X      for (i = 1; PrVar[i] > 0; i++)
X	{
X	  algbr ((short) (PrVar[i] >> 8), (short) (PrVar[i] & 0xFF), false);
X	  fprintf (D, "%5s ", mvstr[0]);
X	}
X      fprintf (D, "\n");
X
X      fprintf (D, "\n current board is\n");
X      for (r = 7; r >= 0; r--)
X	{
X	  for (c = 0; c <= 7; c++)
X	    {
X	      l = locn (r, c);
X	      if (color[l] == neutral)
X		fprintf (D, " -");
X	      else if (color[l] == white)
X		fprintf (D, " %c", qxx[board[l]]);
X	      else
X		fprintf (D, " %c", pxx[board[l]]);
X	    }
X	  fprintf (D, "\n");
X	}
X      fprintf (D, "\n");
X      fclose (D);
X      strcpy (mvstr[0], d);
X    }
X#endif
X
Xif (mvstr[0][0] == NULL) goto nomove;
X#if defined CHESSTOOL
X  if (computer == black)
X    printz ("%d. ... %s\n", ++mycnt1, mvstr[0]);
X  else
X    printz ("%d. %s\n", ++mycnt1, mvstr[0]);
X#else
X#ifdef XBOARD
X  printz ("%d. ... %s\n", ++mycnt1, mvstr[0]);
X#else
X  printz ("%d. ... %s\n", ++mycnt1, mvstr[0]);
X#endif
X#endif /* CHESSTOOL */
X#ifdef notdef
X  if (flag.post)
X    {
X      register int i;
X
X      printz (" %6d%c ", MSCORE, MV[30]);
X      for (i = 1; MV[i] > 0; i++)
X	{
X	  algbr ((short) (MV[i] >> 8), (short) (MV[i] & 0xFF), false);
X	  printz ("%5s ", mvstr[0]);
X	}
X    }
X  printz ("\n");
X#endif
Xnomove:
X  if ((rootnode.flags & draw)||(rootnode.score == -9999)||
X      (rootnode.score == 9998)) goto summary;
X#if !defined CHESSTOOL && !defined XBOARD
X  if (flag.post)
X    {
X      short h, l, t;
X
X      h = TREE;
X      l = 0;
X      t = TREE >> 1;
X      while (l != t)
X	{
X	  if (Tree[t].f || Tree[t].t)
X	    l = t;
X	  else
X	    h = t;
X	  t = (l + h) >> 1;
X	}
X      /*fprintf (stderr, "Nodes %ld Tree %d Eval %ld Rate %ld RS high %ld low %ld\n",*/
X      fprintf (stderr, CP[89],
X	       NodeCnt, t, EvalNodes, (et) ? (NodeCnt / (et / 100)) : 0, reminus, replus);
X      /*fprintf (stderr, "Hin/Hout/Coll/Fin/Fout = %ld/%ld/%ld/%ld/%ld\n",*/
X      fprintf (stderr, CP[71],
X	       HashAdd, HashCnt, THashCol, HashCol, FHashAdd, FHashCnt);
X    }
X  UpdateDisplay (rootnode.f, rootnode.t, 0, rootnode.flags);
X  /*fprintf (stderr, "My move is: %s\n", mvstr[0]);*/
X  fprintf (stderr, CP[83], mvstr[0]);
X  if (flag.beep)
X    printz ("%c", 7);
X#endif /* CHESSTOOL */
X summary:
X  if (rootnode.flags & draw)
X    /*	fprintf (stderr, "Drawn game!\n");*/
X    fprintf (stderr, CP[57]);
X  else if (rootnode.score == -9999)
X    fprintf(stderr,"%s mates!\n",ColorStr[opponent]);
X  else if (rootnode.score == 9998)
X    fprintf(stderr,"%s mates!\n",ColorStr[computer]);
X#if !defined CHESSTOOL && !defined XBOARD
X#ifdef VERYBUGGY
X  else if (rootnode.score < -9000)
X    fprintf(stderr,"%s has a forced mate!\n",ColorStr[opponent]);
X  else if (rootnode.score > 9000)
X    fprintf(stderr,"%s has a forced mate!\n",ColorStr[computer]);
X#endif VERYBUGGY
X#endif /* CHESSTOOL */
X}
X
Xvoid
XClrScreen (void)
X{
X#if !defined CHESSTOOL && !defined XBOARD
X  printz ("\n");
X#endif
X}
X
Xvoid
XUpdateDisplay (short int f, short int t, short int redraw, short int isspec)
X{
X
X  short r, c, l, m;
X
X  if (redraw && !chesstool)
X    {
X      printz ("\n");
X      r = TimeControl.clock[white] / 6000;
X      c = (TimeControl.clock[white] % 6000) / 100;
X      l = TimeControl.clock[black] / 6000;
X      m = (TimeControl.clock[black] % 6000) / 100;
X      /*printz ("White %d:%02d  Black %d:%02d\n", r, c, l, m);*/
X      printz (CP[116], r, c, l, m);
X      printz ("\n");
X      for (r = 7; r >= 0; r--)
X	{
X	  for (c = 0; c <= 7; c++)
X	    {
X	      l = ((flag.reverse) ? locn (7 - r, 7 - c) : locn (r, c));
X	      if (color[l] == neutral)
X		printz (" -");
X	      else if (color[l] == white)
X		printz (" %c", qxx[board[l]]);
X	      else
X		printz (" %c", pxx[board[l]]);
X	    }
X	  printz ("\n");
X	}
X      printz ("\n");
X    }
X}
X
Xvoid
Xskip ()
X{
X  while (*InPtr != ' ')
X    InPtr++;
X  while (*InPtr == ' ')
X    InPtr++;
X}
Xvoid
Xskipb ()
X{
X  while (*InPtr == ' ')
X    InPtr++;
X}
X
Xvoid
XShowMessage (char *s)
X{
X  fprintf (stderr, "%s\n", s);
X}
X
Xvoid
XShowSidetoMove (void)
X{
X}
X
Xvoid
XPromptForMove (void)
X{
X#if !defined CHESSTOOL && !defined XBOARD
X  /*printz ("\nYour move is? ");*/
X  printz (CP[124]);
X#endif /* CHESSTOOL */
X}
X
X
Xvoid
XShowCurrentMove (short int pnt, short int f, short int t)
X{
X#ifdef MSDOS
X  f++;
X  t++;
X  pnt++;			/* shut up the compiler */
X#endif /* MSDOS */
X}
X
Xvoid
XChangeAlphaWindow (void)
X{
X  printz ("WAwindow: ");
X  scanz ("%hd", &WAwindow);
X  printz ("BAwindow: ");
X  scanz ("%hd", &BAwindow);
X}
X
Xvoid
XChangeBetaWindow (void)
X{
X  printz ("WBwindow: ");
X  scanz ("%hd", &WBwindow);
X  printz ("BBwindow: ");
X  scanz ("%hd", &BBwindow);
X}
X
Xvoid
XGiveHint (void)
X{
X  if (hint)
X    {
X      algbr ((short) (hint >> 8), (short) (hint & 0xFF), false);
X      fprintf (stderr, CP[72], mvstr[0]);	/*hint*/
X    }
X  else
X    printz (CP[223]);
X}
X
Xvoid
XSelectLevel (void)
X{
X  char T[64], *p, *q;
X  printz (CP[61]);
X  scanz ("%hd %s", &TCmoves, T);
X  for (p = T; *p == ' '; p++) ;
X  TCminutes = strtol (p, &q, 10);
X  if (*q == ':')
X    TCseconds = strtol (q + 1, (char **) NULL, 10);
X  else
X    TCseconds = 0;
X#ifdef OPERATORTIME
X  printz (CP[94]);
X  scanz ("%hd", &OperatorTime);
X#endif
X  TCflag = (TCmoves > 0);
X  SetTimeControl ();
X}
X
X#ifdef DEBUG
Xvoid
XChangeDbLev (void)
X{
X  printz (CP[146]);
X  scanz ("%hd", &debuglevel);
X}
X
X#endif /* DEBUG */
X
Xvoid
XChangeSearchDepth (void)
X{
X  printz ("depth= ");
X  scanz ("%hd", &MaxSearchDepth);
X  TCflag = !(MaxSearchDepth > 0);
X}
X
XChangeHashDepth (void)
X{
X  printz ("hashdepth= ");
X  scanz ("%hd", &HashDepth);
X  printz ("MoveLimit= ");
X  scanz ("%hd", &HashMoveLimit);
X}
X
Xvoid
XSetContempt (void)
X{
X  printz ("contempt= ");
X  scanz ("%hd", &contempt);
X}
X
Xvoid
XChangeXwindow (void)
X{
X  printz ("xwndw= ");
X  scanz ("%hd", &xwndw);
X}
END_OF_FILE
if test 14679 -ne `wc -c <'src/nondsp.c'`; then
    echo shar: \"'src/nondsp.c'\" unpacked with wrong size!
fi
# end of 'src/nondsp.c'
fi
echo shar: End of archive 10 \(of 12\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
	echo Building book file.
	cat misc/book.xaa misc/book.xab > misc/gnuchess.nunn.book
	rm misc/book.xaa misc/book.xab
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
