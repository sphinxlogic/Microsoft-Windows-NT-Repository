Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i095:  gnuchess4 - GNU Chess 4.0, Part07/12
Message-ID: <3062@master.CNA.TEK.COM>
Date: 19 Jun 92 15:54:34 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2008
Approved: billr@saab.CNA.TEK.COM

Submitted-by: cracraft@rice-chex.ai.mit.edu (Stuart Cracraft)
Posting-number: Volume 13, Issue 95
Archive-name: gnuchess4/Part07
Supersedes: gnuchess2: Volume 4, Issue 37-40
Environment: 



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 12)."
# Contents:  misc/ChessFont src/ataks.h src/nuxdsp.c test/test12
# Wrapped by billr@saab on Fri Jun 19 08:36:01 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'misc/ChessFont' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/ChessFont'\"
else
echo shar: Extracting \"'misc/ChessFont'\" \(28062 characters\)
sed "s/^X//" >'misc/ChessFont' <<'END_OF_FILE'
X%!PS-Adobe-1.0
X%% This is my font for chess and similar pieces.  It is supplied "as is".
X%% It works for me, I have no idea whether it will work for you;  you gets
X%% what you pays for.  Before using it, you should read the Copyright
X%% notice below and the "README" file which should accompany this file.
X%%    -- ANW, March 1991.
X
X/Cfont 9 dict dup begin
X
X/FontMatrix [ 0.001 0 0 0.001 0 0 ] readonly def
X/FontType 3 def
X/FontBBox [ 0 0 0 0 ] readonly def
X/Encoding 256 array def
X/FontInfo 3 dict dup begin
X  /Notice (
X
X	Copyright (c) 1991 A. N. Walker.  All rights reserved.
X
X	This notice must be preserved in all versions of this file, and
X	any alterations which you make must be clearly marked as such.
X	For further information, see the "README" file which should
X	accompany this, or contact me at Dept of Mathematics, Nottingham
X	Univ., UK, anw@maths.nott.ac.uk.
X
X     ) readonly def
X  /FullName (ChessFont) readonly def
X  /version (2.0) readonly def
Xend def
X/UniqueID 472474 def
X
XEncoding
X0 1 255 { 2 copy /.notdef put pop } for
Xdup 8#040 /Wsquare put		% ' '
Xdup 8#042 /flap put		% '"'
Xdup 8#043 /board put		% '#'
Xdup 8#047 /flip put		% ''''
Xdup 8#052 /Bsquare put		% '*'
Xdup 8#055 /edge put		% '-'
Xdup 8#056 /blobfig put		% '.'
Xdup 8#057 /corner put		% '/'
Xdup 8#060 /m0 put		% '0'
Xdup 8#061 /Wsquare put		% '1'
Xdup 8#062 /m2 put		% '2'
Xdup 8#063 /m3 put		% '3'
Xdup 8#064 /m4 put		% '4'
Xdup 8#065 /m5 put		% '5'
Xdup 8#066 /m6 put		% '6'
Xdup 8#067 /m7 put		% '7'
Xdup 8#070 /m8 put		% '8'
Xdup 8#071 /m9 put		% '9'
Xdup 8#073 /nextline put		% ';'
Xdup 8#074 /m-1 put		% '<'
Xdup 8#076 /Wsquare put		% '>'
Xdup 8#100 /wblock put		% '@'
Xdup 8#102 /WB put		% 'B'
Xdup 8#103 /WC put		% 'C'
Xdup 8#104 /WD put		% 'D'
Xdup 8#105 /WE put		% 'E'
Xdup 8#106 /WF put		% 'F'
Xdup 8#107 /WG put		% 'G'
Xdup 8#111 /blob put		% 'I'
Xdup 8#113 /WK put		% 'K'
Xdup 8#114 /WL put		% 'L'
Xdup 8#115 /WM put		% 'M'
Xdup 8#116 /WN put		% 'N'
Xdup 8#117 /BO put		% 'O'
Xdup 8#120 /WP put		% 'P'
Xdup 8#121 /WQ put		% 'Q'
Xdup 8#122 /WR put		% 'R'
Xdup 8#123 /WS put		% 'S'
Xdup 8#124 /WT put		% 'T'
Xdup 8#125 /WU put		% 'U'
Xdup 8#126 /WV put		% 'V'
Xdup 8#130 /WX put		% 'X'
Xdup 8#132 /WZ put		% 'Z'
Xdup 8#133 /posstart put		% '['
Xdup 8#135 /posfinish put	% ']'
Xdup 8#137 /underbar put		% '_'
Xdup 8#142 /BB put		% 'b'
Xdup 8#143 /BC put		% 'c'
Xdup 8#144 /BD put		% 'd'
Xdup 8#145 /BE put		% 'e'
Xdup 8#146 /BF put		% 'f'
Xdup 8#147 /BG put		% 'g'
Xdup 8#151 /blob put		% 'i'
Xdup 8#153 /BK put		% 'k'
Xdup 8#154 /BL put		% 'l'
Xdup 8#155 /BM put		% 'm'
Xdup 8#156 /BN put		% 'n'
Xdup 8#157 /BO put		% 'o'
Xdup 8#160 /BP put		% 'p'
Xdup 8#161 /BQ put		% 'q'
Xdup 8#162 /BR put		% 'r'
Xdup 8#163 /BS put		% 's'
Xdup 8#164 /BT put		% 't'
Xdup 8#165 /BU put		% 'u'
Xdup 8#166 /BV put		% 'v'
Xdup 8#170 /BX put		% 'x'
Xdup 8#172 /BZ put		% 'z'
Xdup 8#174 /sidebar put		% '|'
Xdup 8#240 /Wsquare put		% ' '+
Xdup 8#241 /without put		% '!'+
Xdup 8#242 /flap put		% '"'+
Xdup 8#243 /board put		% '#'+
Xdup 8#245 /infinityequals put	% '%'+
Xdup 8#247 /flip put		% ''''+
Xdup 8#252 /circledot put	% '*'+
Xdup 8#253 /plus put		% '+'+
Xdup 8#255 /minus put		% '-'+
Xdup 8#272 /doubled put		% ':'+
Xdup 8#273 /nextline put		% ';'+
Xdup 8#274 /equalsplus put	% '<'+
Xdup 8#275 /equal put		% '='+
Xdup 8#276 /plusequals put	% '>'+
Xdup 8#277 /infinity put		% '?'+
Xdup 8#300 /circarrow put	% '@'+
Xdup 8#302 /Bfig put		% 'B'+
Xdup 8#303 /Cfig put		% 'C'+
Xdup 8#304 /Dfig put		% 'D'+
Xdup 8#305 /Efig put		% 'E'+
Xdup 8#306 /Ffig put		% 'F'+
Xdup 8#307 /Gfig put		% 'G'+
Xdup 8#311 /blobfig put		% 'I'+
Xdup 8#313 /Kfig put		% 'K'+
Xdup 8#314 /Lfig put		% 'L'+
Xdup 8#315 /Mfig put		% 'M'+
Xdup 8#316 /Nfig put		% 'N'+
Xdup 8#317 /Ofig put		% 'O'+
Xdup 8#320 /Pfig put		% 'P'+
Xdup 8#321 /Qfig put		% 'Q'+
Xdup 8#322 /Rfig put		% 'R'+
Xdup 8#323 /Sfig put		% 'S'+
Xdup 8#324 /Tfig put		% 'T'+
Xdup 8#325 /Ufig put		% 'U'+
Xdup 8#326 /Vfig put		% 'V'+
Xdup 8#330 /Xfig put		% 'X'+
Xdup 8#332 /Zfig put		% 'Z'+
Xdup 8#333 /minusorplus put	% '['+
Xdup 8#335 /plusorminus put	% ']'+
Xdup 8#336 /uparrow put		% '^'+
Xdup 8#341 /rightarrow put	% 'a'+
Xdup 8#342 /semicircle put	% 'b'+
Xdup 8#343 /centre put		% 'c'+
Xdup 8#344 /diags put		% 'd'+
Xdup 8#345 /etc put		% 'e'+
Xdup 8#346 /Phalo put		% 'f'+
Xdup 8#347 /samebs put		% 'g'+
Xdup 8#350 /edgefig put		% 'h'+
Xdup 8#351 /triangle put		% 'i'+
Xdup 8#352 /Bsquarefig put	% 'j'+
Xdup 8#353 /kside put		% 'k'+
Xdup 8#354 /line put		% 'l'+
Xdup 8#355 /hash put		% 'm'+
Xdup 8#356 /cornerfig put	% 'n'+
Xdup 8#357 /square put		% 'o'+
Xdup 8#360 /ending put		% 'p'+
Xdup 8#361 /qside put		% 'q'+
Xdup 8#362 /Pfill put		% 'r'+
Xdup 8#363 /separated put	% 's'+
Xdup 8#364 /tempo put		% 't'+
Xdup 8#365 /united put		% 'u'+
Xdup 8#366 /oppbs put		% 'v'+
Xdup 8#367 /with put		% 'w'+
Xdup 8#370 /weakpt put		% 'x'+
Xdup 8#371 /bpair put		% 'y'+
Xdup 8#372 /circlebolddot put	% 'z'+
X    8#374 /botharrow put	% '|'+
X
X/CharProcs 200 dict dup begin
X
X% Miscellaneous:
X	/.notdef { } bind def
X	/Arcto  { arcto 4 { pop } repeat } bind def
X	/Ddn3c  { dup dup neg 3 copy } bind def
X	/Round  { dtransform round exch round exch idtransform } bind def
X	/Rlineto { Round rlineto } bind def
X	/Rmoveto { Round rmoveto } bind def
X	/diamond { moveto dup neg 0 rmoveto dup dup neg rlineto
X		dup dup rlineto dup neg exch rlineto closepath } bind def
X	/dohalo { gsave 100 setlinewidth setW stroke grestore } bind def
X	/dofill { gsave fill grestore } bind def
X	/motion { 1000 mul exch 1000 mul exch setcharwidth } bind def
X	/setW	{ 1 setgray } bind def
X	/setB	{ 0 setgray } bind def
X	/drawingB { 0 currentgray eq } bind def
X	/setfig { 1000 0 0 -200 1000 800 setcachedevice 500 300 translate
X		} bind def
X	/setpce { 1000 0 setcharwidth 500 dup translate 0.95 dup scale
X		} bind def
X	/MiscStr (a) def
X	/tofig  { 0 get 8#200 add MiscStr exch 0 exch put MiscStr } bind def
X	/Tofig  { 1 0.95 div dup scale tofig } bind def
X	/intext true def
X	/flip	{ 0 0 setcharwidth /intext intext not def } bind def
X	/flap	{ 0 0 setcharwidth /intext true def } bind def
X	/Setfont { /ChessFont findfont 1000 scalefont setfont } bind def
X	/Show	{ rotate -500 dup moveto Setfont show } bind def
X	/Showfig { rotate -500 -300 moveto Setfont show } bind def
X	/LocStr (a) def
X	/SetChar {
X		dup 8#047 eq { pop flip stop } if
X		dup 8#200 lt { intext {
X			8#200 add LocStr exch 0 exch put
X			Setfont LocStr dup stringwidth setcharwidth
X			0 0 moveto show stop } if } if } bind def
X	/DoChar { Encoding exch get cvx exec } bind def
X
X% Kings
X	/WK {	setpce Kout dohalo setW dofill setB stroke Kin } bind def
X	/BK {	setpce Kout dohalo dofill stroke setW Kin } bind def
X	/Kfig { setfig Kout stroke Kin } bind def
X
X	/Kout {	2 setmiterlimit
X		325 -100 moveto 600 100 350 400 125 250 curveto
X		0 250 rlineto -250 0 rlineto 0 -250 rlineto
X		-350 400 -600 100 -325 -100 curveto 0 -250 rlineto
X		-100 -500 100 -500 325 -350 curveto closepath
X		30 setlinewidth } bind def
X	/Kin {	drawingB { 325 } { 275 } ifelse
X		Ddn3c -350 moveto 0 -300 3 -1 roll -350 800 Arcto
X		-350 lineto -100 moveto 0 -50 3 -1 roll
X		-100 800 Arcto -100 lineto
X		15 0 -185 diamond 15 -250 -210 diamond 15 250 -210 diamond
X		drawingB { 125 } { 75 } ifelse
X		Ddn3c dup dup 4 { 0 375 moveto rlineto } repeat
X		drawingB { 0 -45 moveto 125 250 lineto -250 0 rlineto
X			closepath } { 15 0 180 diamond 265 -95 moveto
X			480 150 280 380 50 -50 curveto -265 -95 moveto
X			-480 150 -280 380 -50 -50 curveto } ifelse
X		stroke } bind def
X
X% Queens
X	/WQ {	setpce Qout dohalo setW dofill setB stroke Qin } bind def
X	/BQ {	setpce Qout dohalo dofill stroke setW Qin } bind def
X	/Qfig { setfig Qout stroke Qin } bind def
X
X	/Qout {	2 setmiterlimit
X		0 75 moveto -150 440 50 -80 280 arc -250 25 lineto
X		-440 200 50 -60 300 arc -325 -100 lineto 0 -250 rlineto
X		-100 -500 100 -500 325 -350 curveto 0 250 rlineto
X		440 200 50 -120 240 arc 250 25 lineto 150 440 50 -100 260 arc
X		closepath 30 setlinewidth } bind def
X	/Qin {	drawingB { 325 } { 275 } ifelse
X		Ddn3c -350 moveto 0 -300 3 -1 roll -350 800 Arcto -350 lineto
X		-100 moveto 0 -50 3 -1 roll -100 800 Arcto -100 lineto
X		15 0 -185 diamond 15 -250 -210 diamond 15 250 -210 diamond
X		stroke } bind def
X
X% Rooks
X	/WR {	setpce Rout dohalo setW dofill setB stroke Rin } bind def
X	/BR {	setpce Rout dohalo dofill stroke setW Rin } bind def
X	/Rfig { setfig Rout stroke Rin } bind def
X
X	/Rout { -325 -450 moveto 650 0 rlineto 0 50 rlineto -100 175 rlineto
X		0 400 rlineto 50 75 rlineto 0 150 rlineto -86 0 rlineto
X		-30 -100 rlineto -86 0 rlineto -30 100 rlineto -86 0 rlineto
X		-30 -100 rlineto -86 0 rlineto -30 100 rlineto -86 0 rlineto
X		0 -150 rlineto 50 -75 rlineto 0 -400 rlineto -100 -175 rlineto
X		closepath 30 setlinewidth } bind def
X	/Rin {	drawingB { -225 } { -195 } ifelse
X		dup -225 moveto dup -2 mul 0 rlineto
X		dup 175 moveto -2 mul 0 rlineto stroke } bind def
X
X% Bishops
X	/WB {	Bsetpce Bout setW dofill setB stroke Bin } bind def
X	/BB {	Bsetpce Bout dofill stroke setW Bin } bind def
X	/Bfig { Bsetfig Bout stroke Bin } bind def
X
X	/Bsetpce { /Binpce true def setpce } bind def
X	/Bsetfig { /Binpce false def setfig } bind def
X	/Bout {	2 setmiterlimit
X		-400 -500 moveto 100 100 300 0 400 100 rcurveto
X		100 -100 300 0 400 -100 rcurveto 0 100 rlineto
X		-100 100 -300 0 -400 100 rcurveto
X		-100 -100 -300 0 -400 -100 rcurveto closepath
X		200 -350 moveto 0 200 rlineto
X		200 0 150 215 0 325 curveto -75 420 40 -90 270 arc
X		-340 100 -340 100 -200 -150 curveto 0 -200 rlineto
X		200 50 rlineto closepath 30 setlinewidth
X		gsave	0 325 moveto 150 215 200 0 200 -150 curveto
X			340 100 340 100 75 380 curveto 75 420 40 -90 270 arc
X			closepath Binpce { dohalo setW dofill setB } if stroke
X		grestore } bind def
X	/Bin {  15 0 -225 diamond
X		drawingB { 200 } { 150 } ifelse Ddn3c
X		-350 moveto 20 rlineto -20 rlineto -150 moveto
X		30 rlineto -30 rlineto stroke } bind def
X
X% Knights
X	/WN {	setpce Nout dohalo setW dofill setB stroke Nin } bind def
X	/BN {	setpce Nout dohalo dofill stroke setW Nin } bind def
X	/Nfig { setfig Nout stroke Nin } bind def
X
X	/Nout {	2 setmiterlimit
X		450 -450 moveto 450 200 150 350 -50 400 curveto
X		-25 100 rlineto -75 -200 rlineto -75 150 rlineto
X		0 -150 rlineto -125 -125 -325 -400 -275 -450 rcurveto
X		75 -75 rlineto 100 130 rlineto 0 -200 rlineto
X		50 -25 150 100 100 150 rcurveto 50 -50 150 75 125 150 rcurveto
X		125 -300 -250 -250 -250 -450 curveto
X		closepath 30 setlinewidth } bind def
X	/Nin {  15 -200 150 diamond stroke
X		drawingB {
X			[ 100 100 ] 0 setdash 410 -450 moveto
X			410 200 130 330 -60 380 curveto 50 setlinewidth
X			stroke } {
X			430 -430 moveto 430 200 150 350 -30 370 curveto
X			150 250 390 200 390 -430 curveto fill }
X		ifelse } bind def
X
X% Pawns
X	% Pawns are the only symbols which occur "frequently" in a chess
X	% diagram, so we make a special effort to optimise their caching
X	% behaviour.  Also, they are the only symbols for which this is
X	% easy!
X
X	/WP { setpce Setfont setW 0 0 moveto (f) tofig show setB (P) tofig
X		-500 -300 rmoveto show } bind def
X	/BP { setpce Setfont setW 0 0 moveto (f) tofig show setB (r) tofig
X		show } bind def
X	/Pfig { setfig Pout stroke Pin } bind def
X
X	/Pout { 300 -450 moveto 200 -300  200 -300 75 -250 curveto
X		125 -50 125 -50 75 150 curveto 125 150 100 0 90 arc
X		0 300 100 -30 210 arc -125 150 100 90 180 arc
X		150 0 rlineto -125 -50 -125 -50 -75 -250 curveto
X		-200 -300 -200 -300 -300 -450 curveto
X		closepath 50 setlinewidth } bind def
X	/Pin { -75 150 moveto 150 0 rlineto stroke } bind def
X
X	/Phalo { 0 0 -350 -500 350 450 setcachedevice
X		Pout gsave 100 setlinewidth stroke grestore fill } bind def
X	/Pfill { 0 0 -325 -475 375 425 setcachedevice
X		Pout gsave stroke grestore fill } bind def
X
X% Fous
X	% There seem to be several styles of Fou (French Bishop) -- I have
X	% selected the easiest to implement.  Anyone who *really* wants
X	% this piece can do some work for themselves!
X
X	/WF {	setpce Fout dohalo setW dofill setB stroke Fin } bind def
X	/BF {	setpce Fout dohalo dofill stroke setW Fin } bind def
X	/Ffig { setfig Fout stroke Fin } bind def
X
X	/Fout { 2 setlinejoin
X		-300 -400 moveto 150 300 rlineto -250 500 rlineto
X		250 -125 rlineto 150 175 rlineto 150 -175 rlineto
X		250 125 rlineto -250 -500 rlineto 150 -300 rlineto
X		closepath 30 setlinewidth } bind def
X
X	/Fin {  0 -400 150 dup mul 675 dup mul add sqrt
X		drawingB { 600 300 } { 30 sub 600 270 } ifelse
X		atan dup 180 sub neg arc
X		400 drawingB not { 15 5 sqrt mul add } if
X		dup neg 400 moveto dup dup -2 mul rlineto dup 2 mul rlineto
X		30 -100 150 diamond 30 100 150 diamond
X		0 175 moveto 0 -200 rlineto currentpoint stroke
X		75 210 330 arc stroke } bind def
X
X% Miscellaneous Fairy pieces
X
X    % Grasshopper
X	/WG {	setpce (Q) 180 Show } bind def
X	/BG {	setpce (q) 180 Show } bind def
X	/Gfig { setfig (Q) tofig 180 Showfig } bind def
X
X    % Nightrider.  Real problemists use S for Knight and N for Nightrider;
X    %	    the weight of tradition forces N for Knight, hence S here.
X	/WS {	setpce (N) 180 Show } bind def
X	/BS {	setpce (n) 180 Show } bind def
X	/Sfig { setfig (N) tofig 180 Showfig } bind def
X
X    % Zebra
X	/WZ {	setpce (N) -90 Show } bind def
X	/BZ {	setpce (n) -90 Show } bind def
X	/Zfig { setfig (N) tofig -90 Showfig } bind def
X
X    % Mao.  Also Camel, but C is for Chameleon.
X	/WM {	setpce (N) 90 Show } bind def
X	/BM {	setpce (n) 90 Show } bind def
X	/Mfig { setfig (N) tofig 90 Showfig } bind def
X
X    % Vao
X	/WV {	setpce (B) 90 Show } bind def
X	/BV {	setpce (b) 90 Show } bind def
X	/Vfig { setfig (B) tofig 90 Showfig } bind def
X
X    % Equihopper
X	/WE {	setpce (Q) -90 Show } bind def
X	/BE {	setpce (q) -90 Show } bind def
X	/Efig { setfig (Q) tofig -90 Showfig } bind def
X
X    % Leo.  Also Locust, Lion, Edgehog
X	/WL {	setpce (Q) 90 Show } bind def
X	/BL {	setpce (q) 90 Show } bind def
X	/Lfig { setfig (Q) tofig 90 Showfig } bind def
X
X    % Pao.  Also Empress.  Sorry, all Uther mnemonics seemed to be used Up.
X	/WU {	setpce (R) 90 Show } bind def
X	/BU {	setpce (r) 90 Show } bind def
X	/Ufig { setfig (R) tofig 90 Showfig } bind def
X
X    % Orphan -- NB, all Orphans are black!
X	/BO {	setpce (p) 90 Show } bind def
X	/Ofig { setfig 90 rotate Pout dofill stroke } bind def
X
X    % Rose.  Gardeners will know why T is mnemonic for this.
X	/WT {	setpce Tout dohalo setW dofill setB stroke Tin } bind def
X	/BT {	setpce Tout dohalo dofill stroke setW Tin } bind def
X	/Tfig { setfig Tout stroke Tin } bind def
X
X	/Tout { 300 2 sqrt 1 sub mul
X		8 { dup 300 exch dup -90 135 arc 45 rotate } repeat
X		pop 50 setlinewidth } bind def
X	/Tin {  drawingB { 270 } { 300 } ifelse
X		8 { dup 0 0 moveto 0 lineto 45 rotate } repeat
X		pop stroke } bind def
X
X    % Chameleon
X	/WC {	setpce Cout dohalo setW dofill setB stroke } bind def
X	/BC {	setpce Cout dohalo dofill stroke } bind def
X	/Cfig { setfig Cout stroke } bind def
X
X	/Cout { 2 setmiterlimit 50 setlinewidth
X		-250 -350 moveto 500 0 rlineto -500 700 rlineto
X		500 0 rlineto closepath } bind def
X
X    % Blob [for marking squares], also for Imitator
X	/blob { setpce 0 0 250 0 360 arc dohalo dofill } bind def
X	/blobfig { setfig 0 200 250 0 360 arc dofill } bind def
X
X% Draughts/Dame/Checkers pieces
X
X    % Man
X	/WD {	setpce Dout dohalo setW dofill setB stroke Din } bind def
X	/BD {	setpce Dout dohalo dofill stroke setW Din } bind def
X	/Dfig { setfig Dout stroke Din } bind def
X
X	/Dout { 1 0.5 scale 0 0 350 0 180 arc 0 -400 350 180 0 arc
X		closepath 50 setlinewidth } bind def
X	/Din {  0 0 350 drawingB { 180 0 } { 210 -30 20 setlinewidth }
X		ifelse arc stroke 20 setlinewidth 0 0 220 0 360 arc stroke
X		0 0 80 0 360 arc stroke } bind def
X
X    % King.  The mnemonic for this is unknown.
X	/WX {	setpce Xout dohalo setW dofill setB stroke Xin } bind def
X	/BX {	setpce Xout dohalo dofill stroke setW Xin } bind def
X	/Xfig { setfig Xout stroke Xin } bind def
X
X	/Xout { 1 0.5 scale 0 400 350 0 180 arc 0 -400 350 180 0 arc
X		closepath 50 setlinewidth } bind def
X	/Xin {  0 400 350 drawingB { 180 0 } { 210 -30 20 setlinewidth }
X		ifelse arc stroke 0 0 350 drawingB { 180 0 } { 210 -30 }
X		ifelse arc stroke 20 setlinewidth 0 400 220 0 360 arc stroke
X		0 400 80 0 360 arc stroke } bind def
X
X% Board symbols
X
X	/Wsquare { 1 0 motion } bind def
X	/Bsquare { setpce (j) Tofig 90 Show } bind def
X	/Bsquarefig { 1000 0 0 0 1000 1000 setcachedevice
X		/xpix 62.5 dup dtransform /ypix exch def def
X		/xpabs xpix abs def /ypabs ypix abs def
X		xpabs ypabs lt {
X			ypabs ceiling dup 4 lt { pop 4 } if
X			dup ypix div xpix mul exch } {
X			xpabs ceiling dup 4 lt { pop 4 } if
X			dup xpix div ypix mul } ifelse
X		idtransform pop abs dup 3 div setlinewidth dup 2 mul 2000
X		{ dup 1000 lt { dup 0 moveto 0 exch lineto }
X			{ 1000 sub dup 1000 moveto 1000 exch lineto }
X			ifelse } for stroke } bind def
X	/board { 10000 0 800 0 9200 8400 setcachedevice
X%		Setfont intext /intext dup true def 1000 8200 moveto
X%		4 { (hhhhhhhhn) show currentpoint translate -90 rotate } repeat
X%		-90 rotate 0 7000 moveto
X%	The above was the intention, but the borders sometimes fail to match
X%	up by a pixel or two.  Hence the following!  However, the borders
X%	work perfectly well for special purposes.
X		Setfont intext /intext dup true def
X		20 setlinewidth 940 140 moveto 8120 0 Rlineto 0 8120 Rlineto
X		-8120 0 Rlineto closepath stroke
X		80 setlinewidth 840 40 moveto 8320 0 Rlineto 0 8320 Rlineto
X		-8320 0 Rlineto closepath stroke
X		2000 200 moveto 90 rotate
X		4 { (j j j j ; j j j j;) show } repeat exch def } bind def
X	/nextline { -8 -1 motion } bind def
X	/edge { setpce (h) Tofig 0 Show } bind def
X	/edgefig { 1000 0 0 0 1000 200 setcachedevice
X		20 setlinewidth 0 60 moveto 1000 0 rlineto stroke
X		80 setlinewidth 0 160 moveto 1000 0 rlineto stroke } bind def
X	/corner { setpce (n) Tofig 0 Show } bind def
X	/cornerfig { 0 0 0 0 200 200 setcachedevice
X		20 setlinewidth 0 60 moveto 60 0 rlineto 0 -60 rlineto stroke
X		80 setlinewidth 0 160 moveto 160 0 rlineto 0 -160 rlineto
X		stroke } bind def
X	/posstart { -9 7.2 motion } bind def
X	/posfinish { 1 -0.2 motion } bind def
X	/m0 { 0.5 dup motion } bind def
X	/m2 { 2 0 motion } bind def
X	/m3 { 3 0 motion } bind def
X	/m4 { 4 0 motion } bind def
X	/m5 { 5 0 motion } bind def
X	/m6 { 6 0 motion } bind def
X	/m7 { 7 0 motion } bind def
X	/m8 { 8 0 motion } bind def
X	/m9 { 0 1 motion } bind def
X	/m-1 { -1 0 motion } bind def
X	/underbar { 1000 0 -40 -40 1040 40 setcachedevice 80 setlinewidth
X		1 setlinecap 0 0 moveto 1000 0 lineto stroke } bind def
X	/sidebar { 0 0 setcharwidth 80 setlinewidth
X		1 setlinecap 0 0 moveto 0 1000 lineto stroke } bind def
X	/wblock { 0 0 setcharwidth setW
X		200 200 moveto 600 0 rlineto 0 600 rlineto -600 0 rlineto
X		fill } bind def
X
X% Informant symbols
X
X	/plusequals { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
X		100 10 moveto 800 0 rlineto 0 140 Rmoveto -800 0 rlineto
X		0 300 Rmoveto 800 0 rlineto 500 150 moveto 0 650 rlineto
X		stroke } bind def
X
X	/equalsplus { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
X		100 790 moveto 800 0 rlineto 0 -140 Rmoveto -800 0 rlineto
X		0 -300 Rmoveto 800 0 rlineto 500 0 moveto 0 650 rlineto
X		stroke } bind def
X
X	/plusorminus { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		100 15 moveto 800 0 rlineto 0 385 Rmoveto -800 0 rlineto
X		500 0 moveto 0 800 rlineto stroke } bind def
X
X	/minusorplus { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		100 785 moveto 800 0 rlineto 0 -385 Rmoveto -800 0 rlineto
X		500 0 moveto 0 800 rlineto stroke } bind def
X
X	/plus { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		100 400 moveto 800 0 rlineto 500 0 moveto 0 800 rlineto
X		stroke } bind def
X
X	/minus { 1000 0 100 385 900 415 setcachedevice 30 setlinewidth
X		100 400 moveto 800 0 rlineto stroke } bind def
X
X	/equal { 1000 0 100 300 800 180 Round
X		320 add exch 100 add exch setcachedevice 20 setlinewidth
X		100 310 moveto 800 0 rlineto 0 180 Rmoveto -800 0 rlineto
X		stroke } bind def
X
X	/infinity { 1000 0 95 60 905 540 setcachedevice 40 setlinewidth
X		275 300 160 0 360 arc 660 300 225 -180 180 arc stroke
X		} bind def
X
X	/infinityequals { 1000 0 95 10 905 750 setcachedevice 30 setlinewidth
X		275 250 160 0 360 arc 660 250 225 -180 180 arc
X		100 565 moveto 800 0 rlineto 0 180 Rmoveto -800 0 rlineto
X		stroke } bind def
X
X	/circarrow {1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		500 400 385 0 30 arcn -200 0 rmoveto 200 0 rlineto
X		0 200 rlineto stroke } bind def
X
X	/circledot { 900 0 100 0 800 700 setcachedevice 20 setlinewidth
X		450 350 20 0 360 arc fill 450 350 340 0 360 arc stroke
X		} bind def
X
X	/rightarrow { 1200 0 100 185 1115 615 setcachedevice 30 setlinewidth
X		100 400 moveto 1000 0 rlineto -200 -200 rmoveto 200 200 rlineto
X		-200 200 rlineto stroke } bind def
X
X	/uparrow { 500 0 35 0 465 915 setcachedevice 30 setlinewidth
X		250 0 moveto 0 900 rlineto -200 -200 rmoveto 200 200 rlineto
X		200 -200 rlineto stroke } bind def
X
X	/botharrow { 1200 0 100 70 1100 730 setcachedevice 20 setlinewidth
X		100 280 moveto 990 0 rlineto -200 -200 rmoveto 200 200 rlineto
X		-200 200 rlineto 1100 520 moveto -990 0 rlineto
X		200 -200 rmoveto -200 200 rlineto 200 200 rlineto
X		stroke } bind def
X
X	/circlebolddot { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
X		500 400 50 0 360 arc fill 500 400 390 0 360 arc stroke
X		} bind def
X
X	/hash { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		100 280 moveto 800 0 rlineto 0 240 Rmoveto -800 0 rlineto
X		380 0 moveto 0 800 rlineto 240 0 Rmoveto 0 -800 rlineto
X		stroke } bind def
X
X	/triangle { 900 0 100 0 800 750 setcachedevice 30 setlinewidth
X		100 15 moveto 350 735 rlineto 350 -735 rlineto
X		closepath stroke } bind def
X
X	/square { 900 0 100 0 680 680 Round
X		20 add exch 120 add exch setcachedevice 20 setlinewidth
X		110 10 moveto 680 0 Rlineto 0 680 Rlineto
X		-680 0 Rlineto closepath stroke } bind def
X
X	/semicircle { 1000 0 50 0 950 465 setcachedevice 30 setlinewidth
X		500 15 435 0 180 arc closepath stroke } bind def
X
X	/line { 1000 0 100 190 900 610 setcachedevice 20 setlinewidth
X		220 300 moveto 560 0 rlineto 0 200 Rmoveto -560 0 rlineto
X		310 200 moveto -200 200 rlineto 200 200 rlineto
X		690 200 moveto 200 200 rlineto -200 200 rlineto
X		stroke } bind def
X
X	/diags { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
X		110 120 moveto 670 dup rlineto 110 -110 Rmoveto
X		-670 dup rlineto 640 790 moveto 250 0 rlineto
X		0 -250 rlineto stroke } bind def
X
X	/centre { 1000 0 100 0 780 780 Round
X		20 add exch 120 add exch setcachedevice 20 setlinewidth
X		110 10 moveto 780 0 Rlineto 0 780 Rlineto -780 0 Rlineto
X		closepath 110 400 moveto 780 0 rlineto 500 10 moveto
X		0 780 Rlineto stroke } bind def
X
X	/kside { 700 0 100 0 600 800 setcachedevice 20 setlinewidth
X		110 10 moveto 300 390 rlineto -300 390 rlineto
X		180 0 Rmoveto 300 -390 rlineto -300 -390 rlineto
X		stroke } bind def
X
X	/qside { 700 0 100 0 600 800 setcachedevice 20 setlinewidth
X		590 10 moveto -300 390 rlineto 300 390 rlineto
X		-180 0 Rmoveto -300 -390 rlineto 300 -390 rlineto
X		stroke } bind def
X
X	/weakpt { 700 0 100 0 600 500 setcachedevice 30 setlinewidth
X		110 10 moveto 480 480 rlineto 590 10 moveto -480 480 rlineto
X		stroke } bind def
X
X	/ending { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		100 15 moveto 800 0 rlineto 500 0 moveto 0 800 rlineto
X		stroke } bind def
X
X	/bpair { 1200 0 100 0 980 580 Round
X		20 add exch 120 add exch setcachedevice 20 setlinewidth
X		110 10 moveto 570 0 Rlineto 0 370 Rlineto -570 0 Rlineto
X		closepath 110 10 moveto 980 580 Rmoveto -570 0 Rlineto
X		0 -370 Rlineto 570 0 Rlineto closepath stroke } bind def
X
X	/oppbs { 1200 0 100 0 1100 600 setcachedevice 20 setlinewidth
X		110 10 moveto 570 0 Rlineto 0 370 Rlineto -570 0 Rlineto
X		closepath stroke 1100 600 moveto -590 0 rlineto
X		0 -390 rlineto 590 0 rlineto fill } bind def
X
X	/samebs { 1200 0 100 0 1100 600 setcachedevice
X		100 0 moveto 590 0 rlineto 0 390 rlineto -590 0 rlineto
X		closepath 1100 600 moveto -590 0 rlineto 0 -390 rlineto
X		590 0 rlineto fill } bind def
X
X	/united { 1210 0 50 0 1160 530 setcachedevice 30 setlinewidth
X		315 265 250 0 360 arc stroke 895 265 250 0 360 arc
X		stroke } bind def
X
X	/separated { 1550 0 50 0 1500 530 setcachedevice 30 setlinewidth
X		315 265 250 0 360 arc stroke 1235 265 250 0 360 arc stroke
X		665 30 60 0 360 arc fill 885 30 60 0 360 arc fill } bind def
X
X	/doubled { 730 0 100 0 630 1160 setcachedevice 30 setlinewidth
X		365 265 250 0 360 arc stroke 365 895 250 0 360 arc
X		stroke } bind def
X
X	/tempo { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
X		110 400 moveto 500 400 390 0 360 arc 500 10 moveto
X		0 790 rlineto stroke } bind def
X
X	/with { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		100 800 moveto 0 -785 rlineto 785 0 rlineto stroke } bind def
X
X	/without { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
X		100 15 moveto 785 0 rlineto 0 785 rlineto stroke } bind def
X
X	/etc { 500 0 100 0 270 800 Round
X		exch 130 add exch setcachedevice 30 setlinewidth
X		115 0 moveto 0 800 rlineto 270 0 Rmoveto 0 -800 rlineto
X		stroke } bind def
Xend def
X
X/BuildChar { exch begin CharProcs begin
X	{ SetChar } stopped not { DoChar } if
X	end end } bind def
Xend def
X
X/ChessFont Cfont definefont pop
X% Demo file to be appended to the Chess Font file & sent to your LaserWriter
X%	(or whatever else you do with PostScript!).
X
X% Miscellaneous useful procedures:
X
X	% show string centred on the current point
X/cshow { dup stringwidth -2 div exch -2 div exch rmoveto show } bind def
X
X	% Draw rank and file labels round a standard diagram
X	%   On entry, the ChessFont must be currently selected,
X	%   and the (properly scaled) font desired for the labels
X	%   must be top of stack.  Uses "cshow", defined above
X/dolabels {
X	('[<0) show			% position of top-left label
X	(0) stringwidth -1.5 div	% 1/3-square offset
X	0 exch rmoveto exch		% restore labelfont to top of stack
X	[(8)(7)(6)(5)(4)(3)(2)(1)]	% rank labels
X	{ gsave exch			% stack == offset, label, labelfont
X		dup setfont exch cshow
X	  grestore
X	  (8;) show			% move down a rank
X	} forall
X	[(a)(b)(c)(d)(e)(f)(g)(h)]	% file labels
X	{ (>) show			% move along a file
X	  gsave exch			% as before
X		dup setfont exch cshow
X	  grestore
X	} forall pop			% zap the labelfont
X	(0]') show			% move to RHS of board
X	1.5 div 0 exch rmoveto		% undo previous offset
X} bind def
X
X	% Rotate a piece.  The piece [eg "(Q)"] and the desired rotation
X	%   (in degrees, anticlockwise) should be on the stack
X/twirl {
X	gsave			% keep graphics state
X		(0) show	% go to centre of square
X		rotate		% no of degrees was on stack
X		(07;) show	% back to bottom left of rotated square --
X				% "0" takes us from centre to top right, "7"
X				% advances 7 squares, ";" goes down one and
X				% back 8
X		show		% string was on stack
X	grestore		% restore graphics state
X	( ) show		% advance to next square
X} bind def
X
X	% Draw a neutral piece (for Fairy chess).  Expects two strings
X	%   [eg. "(R) (r)"] on the stack;  the first will be drawn in
X	%   the left half of the square, the second in the right half.
X/neutral {
X	2 dict begin			% small dictionary for xinc, yinc
X	gsave				% keep graphics state
X		(0) stringwidth		% distance to centre of square
X		/yinc exch 2 mul def
X		/xinc exch def
X		currentpoint
X		xinc 0 rlineto		% draw clipping rectangle round
X		0 yinc rlineto		% left half of square
X		xinc neg 0 rlineto clip
X		moveto show		% show left half-piece
X	grestore gsave			% cancel clip
X		currentpoint
X		xinc 0 rmoveto
X		xinc 0 rlineto		% clip right half of square
X		0 yinc rlineto
X		xinc neg 0 rlineto clip
X		moveto show		% show right half-piece
X	grestore			% restore graphics state
X	( ) show			% advance to next square
X	end				% close small dictionary
X} bind def
X
X% End of generally useful procedures.
X
X% Quick hack definitions for this file:
X
X% Miscellaneous definitions:
X
X/ps 10.5 def		% point size
X/vs 12.5 def		% vertical spacing
X/V 11 72 mul def	% top margin
X/L 40 def		% left margin
X
X/N { L V vs sub dup /V exch def moveto } bind def	% newline
X/T { currentpoint exch L sub 6 add 36 div ceiling 36 mul L add exch moveto }
X	bind def	% tab
X
X	% Switch into Chess/Times/Courier/Bold
X/C { /ChessFont findfont ps scalefont setfont } bind def
X/R { /Times-Roman findfont ps scalefont setfont } bind def
X/H { /Courier findfont ps scalefont setfont } bind def
X/B { /Times-Bold findfont ps 1.25 mul scalefont setfont } bind def
X
X	12345		% pseudo-random item on stack, as check
END_OF_FILE
if test 28062 -ne `wc -c <'misc/ChessFont'`; then
    echo shar: \"'misc/ChessFont'\" unpacked with wrong size!
fi
# end of 'misc/ChessFont'
fi
if test -f 'src/ataks.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ataks.h'\"
else
echo shar: Extracting \"'src/ataks.h'\" \(2354 characters\)
sed "s/^X//" >'src/ataks.h' <<'END_OF_FILE'
X/*
X * ataks.h - Header source for GNU CHESS
X *
X * Copyright (c) 1988,1989,1990 John Stanback
X * Copyright (c) 1992 Free Software Foundation
X *
X * This file is part of GNU CHESS.
X *
X * GNU Chess is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * GNU Chess is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with GNU Chess; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
Xinline
Xstatic
Xint
XSqAtakd (register short int sq, short int side)
X
X/*
X * See if any piece with color 'side' ataks sq.  First check pawns then
X * Queen, Bishop, Rook and King and last Knight.
X */
X
X{
X  register short u;
X  register unsigned char *ppos, *pdir;
X  short xside;
X
X  xside = side ^ 1;
X  pdir = nextdir[ptype[xside][pawn]][sq];
X  u = pdir[sq];			/* follow captures thread */
X  if (u != sq)
X    {
X      if (board[u] == pawn && color[u] == side)
X	return (true);
X      u = pdir[u];
X      if (u != sq && board[u] == pawn && color[u] == side)
X	return (true);
X    }
X  /* king capture */
X  if (distance (sq, PieceList[side][0]) == 1)
X    return (true);
X  /* try a queen bishop capture */
X  ppos = nextpos[bishop][sq];
X  pdir = nextdir[bishop][sq];
X  u = ppos[sq];
X  do
X    {
X      if (color[u] == neutral)
X	u = ppos[u];
X      else
X	{
X	  if (color[u] == side && (board[u] == queen || board[u] == bishop))
X	    return (true);
X	  u = pdir[u];
X	}
X  } while (u != sq);
X  /* try a queen rook capture */
X  ppos = nextpos[rook][sq];
X  pdir = nextdir[rook][sq];
X  u = ppos[sq];
X  do
X    {
X      if (color[u] == neutral)
X	u = ppos[u];
X      else
X	{
X	  if (color[u] == side && (board[u] == queen || board[u] == rook))
X	    return (true);
X	  u = pdir[u];
X	}
X  } while (u != sq);
X  /* try a knight capture */
X  pdir = nextdir[knight][sq];
X  u = pdir[sq];
X  do
X    {
X      if (color[u] == side && board[u] == knight)
X	return (true);
X      u = pdir[u];
X  } while (u != sq);
X  return (false);
X}
END_OF_FILE
if test 2354 -ne `wc -c <'src/ataks.h'`; then
    echo shar: \"'src/ataks.h'\" unpacked with wrong size!
fi
# end of 'src/ataks.h'
fi
if test -f 'src/nuxdsp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/nuxdsp.c'\"
else
echo shar: Extracting \"'src/nuxdsp.c'\" \(20989 characters\)
sed "s/^X//" >'src/nuxdsp.c' <<'END_OF_FILE'
X/*
X * nuxdsp.c - (new)  ALPHA interface for CHESS
X *
X * Copyright (c) 1988,1989,1990 John Stanback
X * Copyright (c) 1992 Free Software Foundation
X *
X * This file is part of GNU CHESS.
X *
X * GNU Chess is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * GNU Chess is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with GNU Chess; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X#include <ctype.h>
X#include <signal.h>
X#ifdef MSDOS
X#include <dos.h>
X#include <conio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <time.h>
X
X#define ESC 0x1B
X#define refresh() fflush(stdout)
X
Xint mycntl1, mycntl2;
Xstatic void param (short n);
X
X#else
X#include <sys/param.h>
X#include <sys/types.h>
X#include <sys/file.h>
X#include <curses.h>
X
X/* <stdlib.h> */
Xextern void *malloc (size_t);
Xextern void exit (int);
Xextern short int sscore[];
X
X/* <string.h> */
Xextern char *strcat (char *, const char *);
Xextern int strcmp (const char *, const char *);
Xextern char *strcpy (char *, const char *);
X
X/* <time.h> */
Xextern long int time (long int *);
X
X#endif /* MSDOS */
X
X#include "gnuchess.h"
X
Xextern short int pscore[2];
X
X#define TAB (43)
X/* coordinates within a square for the following are ([1,5],[1,3]) */
X#define SQW (5)
X#define SQH (3)
X#define VIR_C(s)  ((flag.reverse) ? 7-column(s) : column(s))
X#define VIR_R(s)  ((flag.reverse) ? 7-row(s) : row(s))
X#define VSQ_X(x)  ((flag.reverse) ? SQW + 1 - (x) : (x))
X#define VSQ_Y(y)  ((flag.reverse) ? SQH + 1 - (y) : (y))
X#define Vblack(s) (!((VIR_C(s) + VIR_R(s)) % 2))
X/* Squares swapped */
X#define Vcoord(s,x,y) \
X	((SQW)*(VIR_C(s)))+(x),((SQH)*(7-VIR_R(s))+(y))
X/* Squares and internal locations swapped */
X#define VcoordI(s,x,y) \
X	((SQW)*(VIR_C(s)))+(VSQ_X(x)),((SQH)*(7-VIR_R(s))+(VSQ_Y(y)))
X/* Squares and internal rows swapped */
X#define VcoordR(s,x,y) \
X	((SQW)*(VIR_C(s)))+(x),((SQH)*(7-VIR_R(s))+(VSQ_Y(y)))
Xchar Analysis[128] = "";
Xunsigned short int MV[MAXDEPTH];
Xint MSCORE;
Xchar *DRAW;
Xchar mvstr[4][6];
Xshort PositionFlag = 0;
X
X#if defined(MSDOS) && !defined(SEVENBIT)
Xstatic void ONormal (void);
Xstatic void OReverse (void);
X
X#endif /* MSDOS && !SEVENBIT */
X
Xextern char *getenv (const char *);
Xvoid TerminateSearch (int), Die (int);
X
Xvoid
XInitialize (void)
X{
X  signal (SIGINT, Die);
X#ifndef MSDOS
X  signal (SIGQUIT, Die);
X  initscr ();
X  crmode ();
X#else
X  mycntl1 = mycntl2 = 0;
X#endif /* MSDOS */
X}
X
Xvoid
XExitChess (void)
X{
X  ListGame ();
X  gotoXY (1, 24);
X#ifndef MSDOS
X  nocrmode ();
X  endwin ();
X#endif /* MSDOS */
X  exit (0);
X}
X
Xvoid
XDie (int Sig)
X{
X  char s[80];
X
X  signal (SIGINT, SIG_IGN);
X#ifdef MSDOS
X  Sig++;			/* shut up the compiler */
X#else
X  signal (SIGQUIT, SIG_IGN);
X#endif /* MSDOS */
X  ShowMessage (CP[31]);		/*Abort?*/
X  scanz ("%s", s);
X  if (strcmp (s, CP[210]) == 0)	/*yes*/
X    ExitChess ();
X  signal (SIGINT, Die);
X#ifndef MSDOS
X  signal (SIGQUIT, Die);
X#endif /* MSDOS */
X}
X
Xvoid
XTerminateSearch (int Sig)
X{
X  signal (SIGINT, SIG_IGN);
X#ifdef MSDOS
X  Sig++;			/* shut up the compiler */
X#else
X  signal (SIGQUIT, SIG_IGN);
X#endif /* MSDOS */
X  if (!flag.timeout)
X    flag.musttimeout = true;
X  flag.bothsides = false;
X  signal (SIGINT, Die);
X#ifndef MSDOS
X  signal (SIGQUIT, Die);
X#endif /* MSDOS */
X}
Xvoid
XShowLine (short unsigned int *bstline)
X{
X}
X
Xvoid
Xhelp (void)
X{
X  ClrScreen ();
X  /*printz ("CHESS command summary\n");*/
X  printz (CP[40]);
X  printz ("----------------------------------------------------------------\n");
X  /*printz ("g1f3      move from g1 to f3      quit      Exit Chess\n");*/
X  printz (CP[158]);
X  /*printz ("Nf3       move knight to f3       beep      turn %s\n", (flag.beep) ? "off" : "on");*/
X  printz (CP[86]);
X  /*printz ("a7a8q     promote pawn to queen\n");*/
X  printz (CP[128], (flag.material) ? CP[92] : CP[93]);
X  /*printz ("o-o       castle king side        easy      turn %s\n", (flag.easy) ? "off" : "on");*/
X  printz (CP[173], (flag.easy) ? CP[92] : CP[93]);
X  /*printz ("o-o-o     castle queen side       hash      turn %s\n", (flag.hash) ? "off" : "on");*/
X  printz (CP[174], (flag.hash) ? CP[92] : CP[93]);
X  /*printz ("bd        redraw board            reverse   board display\n");*/
X  printz (CP[130]);
X  /*printz ("list      game to chess.lst       book      turn %s used %d of %d\n", (Book) ? "off" : "on", bookcount, BOOKSIZE);*/
X  printz (CP[170], (Book) ? CP[92] : CP[93], bookcount, BOOKSIZE);
X  /*printz ("undo      undo last ply           remove    take back a move\n");*/
X  printz (CP[200]);
X  /*printz ("edit      edit board              force     enter game moves\n");*/
X  printz (CP[153]);
X  /*printz ("switch    sides with computer     both      computer match\n");*/
X  printz (CP[194]);
X  /*printz ("white     computer plays white    black     computer plays black\n");*/
X  printz (CP[202]);
X  /*printz ("depth     set search depth        clock     set time control\n");*/
X  printz (CP[149]);
X  /*printz ("hint      suggest a move         post      turn %s principle variation\n", (flag.post) ? "off" : "on");*/
X  printz (CP[177], (flag.post) ? CP[92] : CP[93]);
X  /*printz ("save      game to file            get       game from file\n");*/
X  printz (CP[188]);
X  /*printz ("random    randomize play          new       start new game\n");*/
X  printz (CP[181]);
X  /*printz ("coords    show coords            rv        reverse video\n");*/
X  printz (CP[144]);
X#if !defined(MSDOS) || defined(SEVENBIT)
X  printz (CP[192]);
X#endif /* !MSDOS || SEVENBIT */
X  gotoXY (10, 20);
X  printz (CP[47], ColorStr[computer]);
X  gotoXY (10, 21);
X  printz (CP[97], ColorStr[opponent]);
X  gotoXY (10, 22);
X  printz (CP[79], Level);
X  gotoXY (10, 23);
X  printz (CP[59], (flag.easy) ? CP[93] : CP[92]);
X  gotoXY (40, 20);
X  printz (CP[52], MaxSearchDepth);
X  gotoXY (40, 21);
X  printz (CP[100], (dither) ? CP[93] : CP[92]);
X  gotoXY (40, 22);
X  printz (CP[112], (flag.hash) ? CP[93] : CP[92]);
X  gotoXY (40, 23);
X  printz (CP[73]);
X  gotoXY (10, 24);
X  printz (CP[110], (TCflag) ? CP[93] : CP[92],
X	  TimeControl.moves[white], TimeControl.clock[white] / 100, OperatorTime, MaxSearchDepth);
X  refresh ();
X  fflush (stdin);
X  getchar ();
X  ClrScreen ();
X  UpdateDisplay (0, 0, 1, 0);
X}
X
Xvoid
XEditBoard (void)
X
X/*
X * Set up a board position. Pieces are entered by typing the piece followed
X * by the location. For example, Nf3 will place a knight on square f3.
X */
X
X{
X  short a, r, c, sq, i;
X  char s[80];
X
X  flag.regularstart = false;
X  Book = false;
X  ClrScreen ();
X  UpdateDisplay (0, 0, 1, 0);
X  gotoXY (TAB, 3);
X  printz (CP[29]);
X  gotoXY (TAB, 4);
X  printz (CP[28]);
X  gotoXY (TAB, 5);
X  printz (CP[136]);
X  gotoXY (TAB, 7);
X  printz (CP[64]);
X  a = white;
X  do
X    {
X      gotoXY (TAB, 6);
X      printz (CP[60], ColorStr[a]);	/*Editing %s*/
X      gotoXY (TAB + 24, 7);
X      ClrEoln ();
X      scanz ("%s", s);
X      if (s[0] == CP[28][0])	/*#*/
X	{
X	  for (sq = 0; sq < 64; sq++)
X	    {
X	      board[sq] = no_piece;
X	      color[sq] = neutral;
X	      DrawPiece (sq);
X	    }
X	}
X      if (s[0] == CP[136][0])	/*c*/
X	a = otherside[a];
X      c = s[1] - 'a';
X      r = s[2] - '1';
X      if ((c >= 0) && (c < 8) && (r >= 0) && (r < 8))
X	{
X	  sq = locn (r, c);
X	  for (i = king; i > no_piece; i--)
X	    if ((s[0] == pxx[i]) || (s[0] == qxx[i]))
X	      break;
X	  board[sq] = i;
X	  color[sq] = ((board[sq] == no_piece) ? neutral : a);
X	  DrawPiece (sq);
X	}
X  } while (s[0] != CP[29][0]);
X
X  for (sq = 0; sq < 64; sq++)
X    Mvboard[sq] = ((board[sq] != Stboard[sq]) ? 10 : 0);
X  GameCnt = 0;
X  Game50 = 1;
X  ZeroRPT ();
X  Sdepth = 0;
X  InitializeStats ();
X  ClrScreen ();
X  UpdateDisplay (0, 0, 1, 0);
X}
X
Xvoid
XShowPlayers (void)
X{
X  gotoXY (TAB, ((flag.reverse) ? 23 : 2));
X  printz ("%s", (computer == black) ? CP[218] : CP[74]);
X  gotoXY (TAB, ((flag.reverse) ? 2 : 23));
X  printz ("%s", (computer == white) ? CP[218] : CP[74]);
X}
X
Xvoid
XShowDepth (char ch)
X{
X  gotoXY (TAB, 4);
X  printz (CP[53], Sdepth, ch);	/*Depth= %d%c*/
X  ClrEoln ();
X}
X
Xvoid
XShowScore (short score)
X{
X  gotoXY (TAB, 5);
X  printz (CP[104], score);
X  ClrEoln ();
X}
X
Xvoid
XShowMessage (char *s)
X{
X  gotoXY (TAB, 6);
X  printz ("%s", s);
X  ClrEoln ();
X}
X
Xvoid
XClearMessage (void)
X{
X  gotoXY (TAB, 6);
X  ClrEoln ();
X}
X
Xvoid
XShowCurrentMove (short int pnt, short int f, short int t)
X{
X  algbr (f, t, false);
X  gotoXY (TAB, 7);
X  printz ("(%2d) %4s", pnt, mvstr[0]);
X}
X
Xvoid
XShowHeader (void)
X{
X  gotoXY (TAB, 10);
X#ifdef MSDOS
X  printz (CP[67]);
X#else
X  printz (CP[68]);
X#endif /* MSDOS */
X}
X
Xvoid
XShowSidetoMove (void)
X{
X  gotoXY (TAB, 14);
X  printz ("%2d:   %s", 1 + GameCnt / 2, ColorStr[player]);
X  ClrEoln ();
X}
X
Xvoid
XShowPrompt (void)
X{
X  gotoXY (TAB, 19);
X  printz (CP[121]);		/*Your movwe is?*/
X  ClrEoln ();
X}
X
Xvoid
XShowNodeCnt (long int NodeCnt)
X{
X  gotoXY (TAB, 21);
X  printz (CP[90], NodeCnt, (et > 100) ? NodeCnt / (et / 100) : 0);
X  ClrEoln ();
X}
X
Xvoid
XShowResults (short int score, short unsigned int *bstline, char ch)
X{
X  unsigned char d, ply;
X
X  if (flag.post)
X    {
X      ShowDepth (ch);
X      ShowScore (score);
X      d = 7;
X      for (ply = 1; bstline[ply] > 0; ply++)
X	{
X	  if (ply % 4 == 1)
X	    {
X	      gotoXY (TAB, ++d);
X	      ClrEoln ();
X	    }
X	  algbr ((short) bstline[ply] >> 8, (short) bstline[ply] & 0xFF, false);
X	  printz ("%5s ", mvstr[0]);
X	}
X      ClrEoln ();
X      while (d < 13)
X	{
X	  gotoXY (TAB, ++d);
X	  ClrEoln ();
X	}
X    }
X}
X
Xvoid
XSearchStartStuff (short int side)
X{
X  short i;
X
X  signal (SIGINT, TerminateSearch);
X#ifdef MSDOS
X  side++;			/* shut up the compiler */
X#else
X  signal (SIGQUIT, TerminateSearch);
X#endif /* MSDOS */
X  for (i = 4; i < 14; i++)
X    {
X      gotoXY (TAB, i);
X      ClrEoln ();
X    }
X}
X
Xvoid
XOutputMove (void)
X{
X  register int i;
X
X  UpdateDisplay (rootnode.f, rootnode.t, 0, (short) rootnode.flags);
X  gotoXY (TAB, 17);
X  printz (CP[84], mvstr[0]);	/*My move is %s*/
X  if (flag.beep)
X    putchar (7);
X  ClrEoln ();
X
X  gotoXY (TAB, 24);
X  if (rootnode.flags & draw)
X    printz (CP[56], DRAW);
X  else if (rootnode.score == -9999)
X    printz (CP[95]);
X  else if (rootnode.score == 9998)
X    printz (CP[44]);
X#ifdef VERYBUGGY
X  else if (rootnode.score < -9000)
X    printz (CP[96]);
X  else if (rootnode.score > 9000)
X    printz (CP[45]);
X#endif VERYBUGGY
X  ClrEoln ();
X
X  if (flag.post)
X    {
X      register short h, l, t;
X
X      h = TREE;
X      l = 0;
X      t = TREE >> 1;
X      while (l != t)
X	{
X	  if (Tree[t].f || Tree[t].t)
X	    l = t;
X	  else
X	    h = t;
X	  t = (l + h) >> 1;
X	}
X
X
X      ShowNodeCnt (NodeCnt);
X      gotoXY (TAB, 22);
X
X      printz (CP[81], t);	/*Max Tree= %d*/
X      ClrEoln ();
X    }
X}
X
Xvoid
XUpdateClocks (void)
X{
X  short m, s;
X
X  m = (short) (et / 6000);
X  s = (short) (et - 6000 * (long) m) / 100;
X  if (TCflag)
X    {
X      m = (short) ((TimeControl.clock[player] - et) / 6000);
X      s = (short) ((TimeControl.clock[player] - et - 6000 * (long) m) / 100);
X    }
X  if (m < 0)
X    m = 0;
X  if (s < 0)
X    s = 0;
X  if (player == white)
X    gotoXY (60, (flag.reverse) ? 2 : 23);
X  else
X    gotoXY (60, (flag.reverse) ? 23 : 2);
X  printz ("%d:%02d   ", m, s);
X  if (flag.post)
X    ShowNodeCnt (NodeCnt);
X  refresh ();
X}
X
Xvoid
XgotoXY (short int x, short int y)
X{
X#ifdef MSDOS
X  putchar (ESC);
X  putchar ('[');
X  param (y);
X  putchar (';');
X  param (x);
X  putchar ('H');
X#else
X  move (y - 1, x - 1);
X#endif /* MSDOS */
X}
X
Xvoid
XClrScreen (void)
X{
X#ifdef MSDOS
X  putchar (ESC);
X  putchar ('[');
X  putchar ('2');
X  putchar ('J');
X#else
X  clear ();
X#endif /* MSDOS */
X  refresh ();
X}
X
Xvoid
XClrEoln (void)
X{
X#ifdef MSDOS
X  putchar (ESC);
X  putchar ('[');
X  putchar ('K');
X#else
X  clrtoeol ();
X#endif /* MSDOS */
X  refresh ();
X}
X
X#ifdef MSDOS
Xvoid
Xparam (short n)
X{
X  if (n >= 10)
X    {
X      register short d, q;
X
X      q = n / 10;
X      d = n % 10;
X      putchar (q + '0');
X      putchar (d + '0');
X    }
X  else
X    putchar (n + '0');
X}
X
X#endif /* MSDOS */
X
Xvoid
XOReverse ()
X{
X#ifdef MSDOS
X  putchar (ESC);
X  putchar ('[');
X  param (7);
X  putchar ('m');
X#else
X  standout ();
X  /* attron (A_REVERSE); */
X#endif /* MSDOS */
X}
X
Xvoid
XONormal ()
X{
X#ifdef MSDOS
X  putchar (ESC);
X  putchar ('[');
X  param (0);
X  putchar ('m');
X#else
X  standend ();
X  /* attroff (A_REVERSE); */
X#endif /* MSDOS */
X}
X
Xvoid
XDrawPiece (short int sq)
X{
X  gotoXY (VcoordR (sq, 2, 2));
X
X  switch (color[sq])
X    {
X    case black:
X      if (flag.rv)
X	OReverse ();
X#if defined(MSDOS) && !defined(SEVENBIT)
X      printz (" %c ", pxx[board[sq]]);
X#else
X      printz ((flag.stars ? "*%c*" : " %c "), pxx[board[sq]]);
X#endif /* MSDOS && !SEVENBIT */
X      ONormal ();
X      break;
X    case neutral:
X#if defined(MSDOS) && !defined(SEVENBIT)
X      if (flag.rv)
X	printz (Vblack (sq) ? "\262\262\262" : "\260\260\260");
X      else
X	printz (Vblack (sq) ? "\260\260\260" : "\262\262\262");
X#else
X      if (flag.shade)
X	printz (Vblack (sq) ? "///" : "   ");
X      else
X	{
X	  if (Vblack (sq))
X	    OReverse ();
X	  printz ("   ");
X	  ONormal ();
X	}
X#endif /* MSDOS && !SEVENBIT */
X      break;
X    case white:
X#if defined(MSDOS) && !defined(SEVENBIT)
X      if (!flag.rv)
X	OReverse ();
X      printz (" %c ", pxx[board[sq]]);
X      ONormal ();
X#else
X      printz (" %c ", pxx[board[sq]]);
X#endif /* MSDOS && !SEVENBIT */
X      break;
X    default:
X      ShowMessage (CP[55]);	/*Draw piece color[sq] err*/
X      break;
X    }
X}
X
Xvoid
XDrawSquare (short int sq)
X{
X#if defined(MSDOS) && !defined(SEVENBIT)
X  if (flag.rv)
X    {
X      gotoXY (Vcoord (sq, 1, 1));
X      printz (Vblack (sq) ? "\262\262\262\262\262" : "\260\260\260\260\260");
X      gotoXY (Vcoord (sq, 1, 2));
X      printz (Vblack (sq) ? "\262\262\262\262\262" : "\260\260\260\260\260");
X      gotoXY (Vcoord (sq, 1, 3));
X      printz (Vblack (sq) ? "\262\262\262\262\262" : "\260\260\260\260\260");
X    }
X  else
X    {
X      gotoXY (Vcoord (sq, 1, 1));
X      printz (Vblack (sq) ? "\260\260\260\260\260" : "\262\262\262\262\262");
X      gotoXY (Vcoord (sq, 1, 2));
X      printz (Vblack (sq) ? "\260\260\260\260\260" : "\262\262\262\262\262");
X      gotoXY (Vcoord (sq, 1, 3));
X      printz (Vblack (sq) ? "\260\260\260\260\260" : "\262\262\262\262\262");
X    }
X#else
X  if (flag.shade)
X    {
X      gotoXY (Vcoord (sq, 1, 1));
X      printz (Vblack (sq) ? "/////" : "     ");
X      gotoXY (Vcoord (sq, 1, 2));
X      printz (Vblack (sq) ? "/////" : "     ");
X      gotoXY (Vcoord (sq, 1, 3));
X      printz (Vblack (sq) ? "/////" : "     ");
X    }
X  else
X    {
X      if (Vblack (sq))
X	OReverse ();
X      gotoXY (Vcoord (sq, 1, 1));
X      printz ("     ");
X      gotoXY (Vcoord (sq, 1, 2));
X      printz ("     ");
X      gotoXY (Vcoord (sq, 1, 3));
X      printz ("     ");
X      ONormal ();
X    }
X#endif /* MSDOS && !SEVENBIT */
X}
X
Xvoid
XDrawCoords (void)
X{
X  short z;
X
X  for (z = 0; z <= 7; z++)
X    {
X      short sq;
X
X      sq = z << 3;
X      gotoXY (VcoordI (sq, 1, 1));
X#if !defined(MSDOS) || defined(SEVENBIT)
X      if ((Vblack (sq) || flag.shade) && flag.rv)
X#endif /* !MSDOS || SEVENBIT */
X	OReverse ();
X      printz ("%d", 1 + z);
X      ONormal ();
X    }
X
X  for (z = 0; z <= 7; z++)
X    {
X      short sq;
X
X      sq = z;
X      gotoXY (VcoordI (sq, SQW, SQH));
X#if !defined(MSDOS) || defined(SEVENBIT)
X      if ((Vblack (sq) || flag.shade) && flag.rv)
X#endif /* !MSDOS || SEVENBIT */
X	OReverse ();
X      printz ("%c", cxx[z]);
X      ONormal ();
X    }
X
X#if !defined(MSDOS) || defined(SEVENBIT)
X  for (z = 1; z <= (8 * SQH); z++)
X    {
X      gotoXY ((8 * SQW) + 1, z);
X      printz ("|");
X    }
X#endif /* MSDOS && !SEVENBIT */
X}
X
Xvoid
XShowPostnValue (short int sq)
X
X/*
X * must have called ExaminePosition() first
X */
X
X{
X  short score;
X
X  gotoXY (VcoordR (sq, 2, 1));
X  score = ScorePosition (color[sq]);
X#if !defined(MSDOS) || defined(SEVENBIT)
X  if (Vblack (sq) && !flag.shade)
X    OReverse ();
X#endif /* !MSDOS || SEVENBIT */
X
X  if (color[sq] != neutral)
X    printz ("%3d", svalue[sq]);
X  else
X#if defined(MSDOS) && !defined(SEVENBIT)
X    {
X      if (flag.rv)
X	printz (Vblack (sq) ? "\262\262\262" : "\260\260\260");
X      else
X	printz (Vblack (sq) ? "\260\260\260" : "\262\262\262");
X    }
X#else
X    printz (flag.shade && Vblack (sq) ? "///" : "   ");
X#endif /* MSDOS && !SEVENBIT */
X  ONormal ();
X}
X
Xvoid
XShowPostnValues (void)
X{
X  short sq, score;
X
X  ExaminePosition ();
X  for (sq = 0; sq < 64; sq++)
X    ShowPostnValue (sq);
X  score = ScorePosition (opponent);
X  gotoXY (TAB, 5);
X  printz (CP[103], score, mtl[computer], pmtl[computer], pscore[computer], sscore[computer],
X	  mtl[opponent], pmtl[opponent], pscore[opponent], sscore[opponent]);
X  ClrEoln ();
X}
X
Xvoid
XUpdateDisplay (short int f, short int t, short int redraw, short int isspec)
X{
X  short sq;
X
X  if (redraw)
X    {
X      ShowHeader ();
X      ShowPlayers ();
X      for (sq = 0; sq < 64; sq++)
X	{
X	  DrawSquare (sq);
X	  DrawPiece (sq);
X	}
X      if (flag.coords)
X	DrawCoords ();
X    }
X  else
X    {
X      DrawPiece (f);
X      DrawPiece (t);
X      if (isspec & cstlmask)
X	if (t > f)
X	  {
X	    DrawPiece (f + 3);
X	    DrawPiece (t - 1);
X	  }
X	else
X	  {
X	    DrawPiece (f - 4);
X	    DrawPiece (t + 1);
X	  }
X      else if (isspec & epmask)
X	{
X	  DrawPiece (t - 8);
X	  DrawPiece (t + 8);
X	}
X    }
X  if (PositionFlag)
X    ShowPostnValues ();
X  refresh ();
X}
X
Xchar *InPtr;
Xvoid
Xskip ()
X{
X  while (*InPtr != ' ')
X    InPtr++;
X  while (*InPtr == ' ')
X    InPtr++;
X}
Xvoid
Xskipb ()
X{
X  while (*InPtr == ' ')
X    InPtr++;
X}
X
Xvoid
XChangeAlphaWindow (void)
X{
X  ShowMessage (CP[114]);
X  scanz ("%hd", &WAwindow);
X  ShowMessage (CP[34]);
X  scanz ("%hd", &BAwindow);
X}
X
Xvoid
XChangeBetaWindow (void)
X{
X  ShowMessage (CP[115]);
X  scanz ("%hd", &WBwindow);
X  ShowMessage (CP[35]);
X  scanz ("%hd", &BBwindow);
X}
X
Xvoid
XGiveHint (void)
X{
X  char s[40];
X  if (hint)
X    {
X      algbr ((short) (hint >> 8), (short) (hint & 0xFF), false);
X      strcpy (s, CP[198]);	/*try*/
X      strcat (s, mvstr[0]);
X      ShowMessage (s);
X    }
X  else
X    ShowMessage (CP[223]);
X}
X
Xvoid
XChangeHashDepth (void)
X{
X  ShowMessage (CP[163]);
X  scanz ("%hd", &HashDepth);
X  ShowMessage (CP[82]);
X  scanz ("%hd", &HashMoveLimit);
X}
X
Xvoid
XChangeSearchDepth (void)
X{
X  ShowMessage (CP[150]);
X  scanz ("%hd", &MaxSearchDepth);
X  TCflag = !(MaxSearchDepth > 0);
X}
X
Xvoid
XSetContempt (void)
X{
X  ShowMessage (CP[142]);
X  scanz ("%hd", &contempt);
X}
X
X
Xvoid
XSetAnalysis (void)
X{
X  ShowMessage (CP[159]);
X  scanz ("%s", Analysis);
X}
X
Xvoid
XChangeXwindow (void)
X{
X  ShowMessage (CP[208]);
X  scanz ("%hd", &xwndw);
X}
X
Xvoid
XSelectLevel (void)
X{
X  ClrScreen ();
X  gotoXY (32, 2);
X  printz (CP[41]);
X  gotoXY (20, 4);
X  printz (CP[18]);
X  gotoXY (20, 5);
X  printz (CP[19]);
X  gotoXY (20, 6);
X  printz (CP[20]);
X  gotoXY (20, 7);
X  printz (CP[21]);
X  gotoXY (20, 8);
X  printz (CP[22]);
X  gotoXY (20, 9);
X  printz (CP[23]);
X  gotoXY (20, 10);
X  printz (CP[24]);
X  gotoXY (20, 11);
X  printz (CP[25]);
X  gotoXY (20, 12);
X  printz (CP[26]);
X  gotoXY (20, 13);
X  printz (CP[27]);
X
X  OperatorTime = 0;
X  TCmoves = 60;
X  TCminutes = 5;
X  TCseconds = 0;
X  gotoXY (20, 17);
X  printz (CP[62]);
X  refresh ();
X  scanz ("%ld", &Level);
X  switch ((int) Level)
X    {
X    case 1:
X      TCmoves = 60;
X      TCminutes = 5;
X      break;
X    case 2:
X      TCmoves = 60;
X      TCminutes = 15;
X      break;
X    case 3:
X      TCmoves = 60;
X      TCminutes = 30;
X      break;
X    case 4:
X      TCmoves = 40;
X      TCminutes = 30;
X      break;
X    case 5:
X      TCmoves = 40;
X      TCminutes = 60;
X      break;
X    case 6:
X      TCmoves = 40;
X      TCminutes = 120;
X      break;
X    case 7:
X      TCmoves = 40;
X      TCminutes = 240;
X      break;
X    case 8:
X      TCmoves = 1;
X      TCminutes = 15;
X      break;
X    case 9:
X      TCmoves = 1;
X      TCminutes = 60;
X      break;
X    case 10:
X      TCmoves = 1;
X      TCminutes = 600;
X      break;
X    }
X
X  TCflag = (TCmoves > 0);
X  SetTimeControl ();
X  ClrScreen ();
X  UpdateDisplay (0, 0, 1, 0);
X}
X
Xvoid
XDoDebug (void)
X{
X  short c, p, sq, tp, tc, tsq, score;
X  char s[40];
X
X  ExaminePosition ();
X  ShowMessage (CP[65]);
X  scanz ("%s", s);
X  c = neutral;
X  if (s[0] == CP[9][0] || s[0] == CP[9][1])	/* w W*/
X    c = white;
X  if (s[0] == CP[9][2] || s[0] == CP[9][3])	/*b B*/
X    c = black;
X  for (p = king; p > no_piece; p--)
X    if ((s[1] == pxx[p]) || (s[1] == qxx[p]))
X      break;
X  for (sq = 0; sq < 64; sq++)
X    {
X      tp = board[sq];
X      tc = color[sq];
X      board[sq] = p;
X      color[sq] = c;
X      tsq = PieceList[c][1];
X      PieceList[c][1] = sq;
X      ShowPostnValue (sq);
X      PieceList[c][1] = tsq;
X      board[sq] = tp;
X      color[sq] = tc;
X    }
X  score = ScorePosition (opponent);
X  gotoXY (TAB, 5);
X  printz (CP[103], score, mtl[computer], pmtl[computer], pscore[computer], sscore[computer],
X	  mtl[opponent], pmtl[opponent], pscore[opponent], sscore[opponent]);
X  ClrEoln ();
X}
END_OF_FILE
if test 20989 -ne `wc -c <'src/nuxdsp.c'`; then
    echo shar: \"'src/nuxdsp.c'\" unpacked with wrong size!
fi
# end of 'src/nuxdsp.c'
fi
if test -f 'test/test12' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/test12'\"
else
echo shar: Extracting \"'test/test12'\" \(491 characters\)
sed "s/^X//" >'test/test12' <<'END_OF_FILE'
XBlack computer White Human 1 # correct e5e4 Cray Blitz at 23 plys
XCastled White false Black false # 
XTimeControl 0 Operator Time 0
XWhite Clock 0 Moves 0
XBlack Clock 0 Moves 0
X
X8 ........ 10 10 10 10 10 10 10 10
X7 .....P.. 10 10 10 10 10 10 10 10
X6 ........ 0 0 0 10 10 10 0 0
X5 ....k.p. 0 0 0 0 0 0 0 0
X4 .....pK. 0 0 0 0 0 0 0 0
X3 ........ 0 0 0 10 10 0 0 0
X2 ........ 10 10 10 10 10 0 10 10
X1 ........ 10 10 10 10 10 10 10 10
X  abcdefgh
X
Xmove  score depth  nodes  time flags capture color
END_OF_FILE
if test 491 -ne `wc -c <'test/test12'`; then
    echo shar: \"'test/test12'\" unpacked with wrong size!
fi
# end of 'test/test12'
fi
echo shar: End of archive 7 \(of 12\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
	echo Building book file.
	cat misc/book.xaa misc/book.xab > misc/gnuchess.nunn.book
	rm misc/book.xaa misc/book.xab
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
