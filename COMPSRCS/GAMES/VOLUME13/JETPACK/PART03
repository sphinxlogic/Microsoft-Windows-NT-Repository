Path: uunet!spool.mu.edu!uwm.edu!ogicse!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i075:  jetpack - an arcade action game for X, Part03/04
Message-ID: <2647@master.CNA.TEK.COM>
Date: 23 Mar 92 22:32:04 GMT
Article-I.D.: master.2647
Sender: news@master.CNA.TEK.COM
Lines: 2104
Approved: billr@saab.CNA.TEK.COM

Submitted-by: meb2@cec2.wustl.edu (Mark Edward Bradley)
Posting-number: Volume 13, Issue 75
Archive-name: jetpack/Part03
Environment: X11, Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 4)."
# Contents:  Makefile.simple defs.h demo.c erase.c initx.c maze.c
#   normal.c setup.c update.c
# Wrapped by billr@saab on Mon Mar 23 14:29:27 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile.simple' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.simple'\"
else
echo shar: Extracting \"'Makefile.simple'\" \(1239 characters\)
sed "s/^X//" >'Makefile.simple' <<'END_OF_FILE'
X# Program name
XEXEC = jetpack
X
X# Master destination directory
XDESTDIR = /usrd/s/m/meb2
X
X# Various subdirectories
XLIBDIR = $(DESTDIR)/lib/jetpack
XBINDIR = $(DESTDIR)/bin
XMANPATH = $(DESTDIR)/man
X
X# Files for high scores and predifined levels
XSCOREFILE = $(LIBDIR)/jetpack.scores
XLEVELFILE = $(LIBDIR)/jetpack.lev
X
X# -O4 for optimization, -DBLIT for blitting
XCFLAGS = -O4 -DBLIT -DSCOREPATH=\"$(SCOREFILE)\" -DLEVELPATH=\"$(LEVELFILE)\"
X
X# Your favorite X library
XLIBS = -lX11
X
XOBJS =	bitmap.o bonus.o collision.o demo.o draw.o erase.o events.o\
X		gameover.o initx.o main.o maze.o message.o normal.o quitx.o\
X		scores.o setinmaze.o setup.o special.o time.o update.o windowx.o
X
Xjetpack: $(OBJS)
X	cc -o $(EXEC) $(OBJS) $(LIBS) $(CFLAGS)
X
X# do whatever you like for installation here. I have it set all the data
X# files to be readable and writable only by the user, (except the man
X# page) and the program itself to be setuid
Xinstall: $(EXEC)
X	strip $(EXEC)
X	cp $(EXEC) $(BINDIR)
X	chmod 4755 $(BINDIR)/$(EXEC)
X	cp levels/000 $(LEVELFILE)000
X	chmod 0600 $(LEVELFILE)000
X	cp jetpack.man $(MANDIR)/jetpack.n
X	chmod 0644 $(MANDIR)/jetpack.n
X
X# dependencies (leave these alone)
X$(OBJS) : defs.h copyright.h
Xbitmap.o : bitmap.h
Xmessage.c : message.h
END_OF_FILE
if test 1239 -ne `wc -c <'Makefile.simple'`; then
    echo shar: \"'Makefile.simple'\" unpacked with wrong size!
fi
# end of 'Makefile.simple'
fi
if test -f 'defs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'defs.h'\"
else
echo shar: Extracting \"'defs.h'\" \(6636 characters\)
sed "s/^X//" >'defs.h' <<'END_OF_FILE'
X/*	defs.h : externally defined things for jetpack
X*/
X
X#include "copyright.h"
X
X/*	here are all the include files used by the different source files.
X	Since every source file includes this one, it makes dependencies a lot
X	more efficient.
X*/
X
X#include	<stdio.h>
X#include	<string.h>
X#include	<fcntl.h>
X#include	<sys/param.h>
X#include	<sys/file.h>
X#include	<sys/types.h>
X#include	<sys/time.h>
X#include	<X11/Xlib.h>
X#include	<X11/Xutil.h>
X#include	<X11/keysym.h>
X#include	<X11/keysymdef.h>
X
X/*	Windowing stuff
X*/
X
X/*	Dimensions of the window and the information window
X*/
X#define WINDOWWIDTH		500
X#define WINDOWHEIGHT	500
X#define INFOHEIGHT		50
X
X/*	Error factor used in non-blitting version for overlap testing.
X*/
X#ifdef	BLIT
X#define	EDGE	0
X#else
X#define	EDGE	10
X#endif
X
X/*	Definitions for erase zone types.
X*/
X#define	ZLINE		0
X#define	ZPLAYER		1
X#define	ZBURN		2
X#define	ZEXPLODE	3
X#define	ZFIRE		4
X#define	ZGUARD		5
X#define	ZSWEEP		6
X#define	ZFUEL		7
X#define	ZKEY		8
X#define	ZDOOR		9
X#define	ZSMESS		10
X#define	ZBMESS		11
X
X/*	Dimensions and position of high score table pixmap within window
X*/
X#define SCOREWIDTH	400
X#define SCOREHEIGHT	300
X#define SCOREX		50
X#define SCOREY		180
X
Xextern Display			*display;
Xextern Colormap			colormap;
Xextern Window			rootwindow, gamewindow, infowindow, dialogwindow,
X						dialogstringwindow, dialogbuttonwindow;
Xextern int				screen, depth;
Xextern unsigned long	blackpixel, whitepixel;
Xextern XFontStruct		*fontinfo, *bigfontinfo;
Xextern Pixmap			drawpixmap, scorepixmap;
Xextern int				dialogwidth, dialogheight;
X
X/*	colors
X*/
X
X#define	NCOLORS	8
X
X#define	CBLACK	0
X#define	CRED	1
X#define	CORANGE	2
X#define	CYELLOW	3
X#define	CBLUE	4
X#define	CGREY	5
X#define	CGREEN	6
X#define	CWHITE	7
X
X/*	two GC's in each colormap entry are needed -- one for the small
X	fixed font, and one for the large Courier font.
X*/
Xstruct colors {
X	char	*name;
X	GC		smallgc;
X	GC		biggc;
X	int		pixelvalue;
X};
X
Xextern struct colors	ctable[8];
X
X/*	maze stuff
X*/
X
X#define	MAXMAZEWIDTH	100
X#define	MAXMAZEHEIGHT	100
X#define	MAXLINES MAXMAZEWIDTH*MAXMAZEHEIGHT*2+MAXMAZEWIDTH+MAXMAZEHEIGHT
X
X#define	WALLUP		0x0001
X#define	WALLRIGHT	0x0002
X#define	WALLDOWN	0x0004
X#define	WALLLEFT	0x0008
X
Xstruct line {
X	int x1, y1, x2, y2;
X};
X
Xextern int			maze[MAXMAZEWIDTH][MAXMAZEHEIGHT];
Xextern struct line	mazelines[MAXLINES];
Xextern int			mazescale, mazewidth, mazeheight, mazelcount;
Xextern char			walldir[4], oppdir[4];
Xextern int			xdir[4], ydir[4];
X
X/*	message stuff
X*/
X
X#define	MAXMESSAGELENGTH	100
X#define	MAXBIGMESSAGELENGTH	30
X#define	MAXLEVELMESSAGES	20
X
X/*	These constants are used to call the dumb_message function when
X	something worth commenting on happens
X*/
X#define	MFUEL		0
X#define	MKILL		1
X#define	MKEY		2
X#define	MCLOSE		3
X#define	MSUICIDE	4
X#define	MEXIT		5
X#define MQUIT		6
X
X/*	Structure used to store the messages triggered in certain areas of a
X	level
X*/
Xstruct levelmessage {
X	char	text[MAXMESSAGELENGTH];
X	char	bigtext[MAXBIGMESSAGELENGTH];
X	int		x1, y1, x2, y2;
X	int		color, bigcolor, time, bigtime;
X	int		active, bigactive, unused;
X};
X
Xextern int					numlmessage;
Xextern struct levelmessage	lmessage[MAXLEVELMESSAGES];
Xextern char					messagestring[MAXMESSAGELENGTH],
X							bigmessagestring[MAXBIGMESSAGELENGTH];
Xextern int					messagex, messagey, bigmessagex, bigmessagey,
X							messagecolor, bigmessagecolor,
X							messagelength, bigmessagelength,
X							messagewidth, bigmessagewidth,
X							messagetime, bigmessagetime;
X
X/*	player stuff
X*/
X
X#define	PLAYERWIDTH		20
X#define	PLAYERHEIGHT	20
X#define	PLAYERPARTS		2
X#define	BURNWIDTH		20
X#define	BURNHEIGHT		20
X#define	BURNPARTS		2
X#define	BURNDIRECTIONS	3
X
X#define	FACELEFT	0
X#define	FACEFRONT	7
X#define	FACERIGHT	14
X
X#define PLAYERPHASES	FACERIGHT+1
X
X#define	GOLEFT	-1
X#define	STOP	0
X#define	GORIGHT	1
X
Xextern Pixmap	playerpix[PLAYERPHASES], burnpix[BURNDIRECTIONS];
Xextern int		plx, ply, burn, playerphase, playerdir, playervert,
X				playerfuel, walk, waiting, dead, deadtimer;
X
X/*	pixmaps for exploding player
X*/
X
X#define	EXPLODEWIDTH	30
X#define	EXPLODEHEIGHT	30
X#define	EXPLODEFRAMES	10
X#define	EXPLODETIME		2
X
Xextern Pixmap	explodepix[EXPLODEFRAMES];
Xextern int		exploded, explodetimer;
X
X/*	wall sweepers
X*/
X
X#define	SWEEPERWIDTH	20
X#define	SWEEPERHEIGHT	20
X#define	MAXSWEEPERS		40
X#define	SWEEPERPARTS	3
X#define	SWEEPERPHASES	4
X#define	MAXSWEEPSPEED	10
X
Xextern Pixmap	sweeperpix[SWEEPERPHASES];
Xextern int		numsweep;
Xextern int		sweepx[MAXSWEEPERS], sweepy[MAXSWEEPERS],
X				sweepdir[MAXSWEEPERS], sweepfloor[MAXSWEEPERS],
X				sweepphase[MAXSWEEPERS], sweepspeed[MAXSWEEPERS],
X				sweeprot[MAXSWEEPERS];
X
X/*	fireballs
X*/
X
X#define	FIREWIDTH		20
X#define	FIREHEIGHT		20
X#define	MAXFIREBALLS	40
X#define	FIREPARTS		2
X#define	FIREPHASES		5
X
Xextern Pixmap	firepix[FIREPHASES];
Xextern int		numfire;
Xextern int		firex[MAXFIREBALLS], firey[MAXFIREBALLS],
X				firedx[MAXFIREBALLS], firedy[MAXFIREBALLS],
X				firephase[MAXFIREBALLS];
X
X/*	guards
X*/
X
X#define	GUARDWIDTH		21
X#define	GUARDHEIGHT		21
X#define	MAXGUARDS		40
X#define	GUARDPARTS		2
X#define	GUARDLIGHTS		3
X#define GUARDFLAMEPARTS	2
X#define GUARDDIRECTIONS	4
X#define	GUARDPHASES		8
X#define MAXGUARDSPEED	9
X
Xextern Pixmap	guardpix[GUARDDIRECTIONS][GUARDPHASES];
Xextern int		numguard;
Xextern int		guardx[MAXGUARDS], guardy[MAXGUARDS], guarddir[MAXGUARDS],
X				guardspeed[MAXGUARDS], guardphase[MAXGUARDS],
X				guardtime[MAXGUARDS];
X
X/*	fuel pods
X*/
X
X#define	FUELWIDTH		20
X#define	FUELHEIGHT		20
X#define	MAXFUELPODS		50
X#define	FUELPARTS		4
X#define	FUELINCREMENT	100
X
Xextern Pixmap	fuelpix;
Xextern int		numfuel;
Xextern int		fuelx[MAXFUELPODS], fuely[MAXFUELPODS],
X				fuelalive[MAXFUELPODS], fueltimer[MAXFUELPODS];
X
X/*	key
X*/
X
X#define	KEYWIDTH	10
X#define	KEYHEIGHT	10
X#define	KEYPARTS	1
X
Xextern Pixmap	keypix;
Xextern int		keyx, keyy, keyalive, keytimer;
X
X/*	door
X*/
X
X#define	DOORWIDTH	30
X#define	DOORHEIGHT	30
X#define	DOORPARTS	1
X#define	DOORFRAMES	2
X
Xextern Pixmap	doorpix[DOORFRAMES];
Xextern int		doorx, doory;
Xextern int		indoor;
X
X/*	pixmap of extra man for info window
X*/
X
X#define	EXTRAMANWIDTH	12
X#define	EXTRAMANHEIGHT	20
X
Xextern Pixmap	extramanpix;
X
X/*	dummy coordinates for checking collisions with the maze
X*/
X
Xextern int	nx, ny;
X
X/*	world data
X*/
X
X#define	UPSPEED			-10
X#define	DOWNSPEED		10
X#define THRUST			-2
X#define GRAVITY			1
X#define FUELCAPACITY	1000
X#define BURNCOST		1
X#define PLAYERSPEED		5
X
X/*	game data
X*/
X
X#define	MAXHIGHSCORES	25
X#define	BONUSINCREMENT	10
X#define	BONUSTIME		20
X#define EXTRAMANSCORE	10000
X#define USECDELAY		45000
X
Xextern int	men, score, bonus, bonustimer, initbonus, level;
X			oldscore, oldlevel, extramaninc;
X
X/*	game state
X*/
X
Xextern int	paused, leveldone, gameover, lastscore;
END_OF_FILE
if test 6636 -ne `wc -c <'defs.h'`; then
    echo shar: \"'defs.h'\" unpacked with wrong size!
fi
# end of 'defs.h'
fi
if test -f 'demo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo.c'\"
else
echo shar: Extracting \"'demo.c'\" \(4394 characters\)
sed "s/^X//" >'demo.c' <<'END_OF_FILE'
X/*	demo.c : routines that implement the title screen and demonstration.
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
X#define	DEMODELAY	50
X
Xint	demostage, demodelay;
X
X/*	demo is the pseudo-event loop that runs the demo. It is identical to
X	the main loop, except demo_event_filter only checks for input to leave
X	the demo, and demo_player does the actual player action. The level
X	itself is special level 0.
X*/
Xdemo()
X{
X	register unsigned long	timer;
X
X	reset_game();
X	reset_level();
X	level = 0;
X	demostage = 0;
X	if(special_setup() == 0) return;
X	XClearWindow(display, gamewindow);
X	XClearWindow(display, infowindow);
X	draw();
X	refresh_info();
X	while(!leveldone) {
X            begin_timer();
X            while(XPending(display) && !demo_event_filter());
X			demo_player();
X			update();
X            collision_check();
X            message_check();
X			bonus_check();
X            draw();
X            timer = get_timer();
X            if(timer < USECDELAY) usleep(USECDELAY - timer);
X	}
X	XClearWindow(display, gamewindow);
X	XClearWindow(display, infowindow);
X}
X
X/*	title_screen is the animated title screen. There is a "maze" that
X	surrounds the high score list that contain moving enemies. There is
X	also a player suspended in the center going through random motions.
X*/
Xtitle_screen()
X{
X	register unsigned long	timer, btimer;
X	register int			shifttimer, shiftwhich;
X
X	setup_title_maze();
X
X#ifdef	BLIT
X	XFillRectangle(display, drawpixmap, ctable[CBLACK].smallgc, 0, 0,
X					WINDOWWIDTH, WINDOWHEIGHT);
X#else
X	init_zones();
X#endif
X
X	XClearWindow(display, gamewindow);
X	XClearWindow(display, infowindow);
X	title_refresh();
X	/*	read in the scorefile in case it has changed
X		and draw all the scores for the first time
X	*/
X	read_new_scores();
X	shifttimer = 5; shiftwhich = 0;
X	begin_timer();
X	while(gameover) {
X		btimer = get_timer();
X		while(XPending(display)) title_event_filter();
X
X#ifdef	BLIT
X		XCopyArea(display, drawpixmap, gamewindow,
X			ctable[CBLACK].smallgc, 0, 0, WINDOWWIDTH, WINDOWHEIGHT,
X			0, 0);
X#endif
X
X		/* 	Only draw 5 scores at a time so there won't be lag
X		*/
X		shifttimer--;
X		if(shifttimer == 0) {
X			shifttimer = 5;
X			draw_scores(shiftwhich);
X			shiftwhich++;
X			if(shiftwhich == MAXHIGHSCORES / 5) shiftwhich = 0;
X		}
X		title_draw();
X		timer = get_timer();
X		/*	after 15 seconds, switch to demo
X		*/
X		if(timer > 15000000) break;
X		if(timer-btimer < USECDELAY) usleep(USECDELAY-(timer-btimer));
X	}
X	stop_timer();
X	XClearWindow(display, gamewindow);
X	XClearWindow(display, infowindow);
X}
X
X/*	demo_walk is a procedure that makes the demo player walk to a
X	position.
X*/
Xdemo_walk(x)
Xint	x;
X{
X	if(plx > x + 5) playerdir = GOLEFT;
X	else if(plx < x - 5) playerdir = GORIGHT;
X	else {
X		playerdir = STOP;
X		demostage++;
X	}
X}
X
X/*	demo_fly is a procedure that makes the demo player fly to a position.
X*/
Xdemo_fly(x, y)
Xint	x, y;
X{
X	int	maybe = 0;
X
X	if(plx > x + 5) playerdir = GOLEFT;
X	else if(plx < x - 5) playerdir = GORIGHT;
X	else {
X		playerdir = STOP;
X		maybe = 1;
X	}
X	if(ply > y + 5) burn = 1;
X	else if(ply < y - 5) burn = 0;
X	else {
X		burn = 0;
X		if(maybe) demostage++;
X	}
X}
X
X/*	demo_delay makes the demo player wait for a while.
X*/
Xdemo_delay()
X{
X	demodelay--;
X	if(!demodelay) demostage++;
X}
X
X/*	demo_player uses the above macro procedures in a crude switch
X	statement to make the demo player run through the whole routine.
X	A much better implementation would be to have all the data in a static
X	array, but since it's so simple, I'll stick to this for now.
X*/
Xdemo_player()
X{
X	switch(demostage) {
X		case 0:
X			demo_walk(300);
X			demodelay = DEMODELAY;
X			break;
X		case 1:
X			demo_delay();
X			break;
X		case 2:
X			demo_fly(240, 260);
X			break;
X		case 3:
X			demo_fly(400, 350);
X			demodelay = DEMODELAY;
X			break;
X		case 4:
X			demo_delay();
X			break;
X		case 5:
X			demo_walk(660);
X			demodelay = DEMODELAY;
X			break;
X		case 6:
X			demo_delay();
X			break;
X		case 7:
X			demo_walk(1040);
X			demodelay = DEMODELAY;
X			break;
X		case 8:
X			demo_delay();
X			break;
X		case 9:
X			demo_fly(1380, 300);
X			break;
X		case 10:
X			demo_fly(1380, 660);
X			break;
X		case 11:
X			demo_walk(1140);
X			demodelay = DEMODELAY;
X			break;
X		case 12:
X			demo_delay();
X			break;
X		case 13:
X			demo_walk(900);
X			demodelay = DEMODELAY;
X			break;
X		case 14:
X			demo_delay();
X			break;
X		case 15:
X			demo_fly(keyx, keyy);
X			break;
X		case 16:
X			demo_walk(900);
X			break;
X		default:
X			leveldone = 1;
X			break;
X	}
X}
END_OF_FILE
if test 4394 -ne `wc -c <'demo.c'`; then
    echo shar: \"'demo.c'\" unpacked with wrong size!
fi
# end of 'demo.c'
fi
if test -f 'erase.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'erase.c'\"
else
echo shar: Extracting \"'erase.c'\" \(7917 characters\)
sed "s/^X//" >'erase.c' <<'END_OF_FILE'
X/*	erase.c : routines used in non-blitting version that erase-and-draw
X	objects and reduce flicker.
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
X/*	Note: the functions and variables in this file are not used in the
X	blitting version.
X*/
X
X#ifndef BLIT
X
X#define MAXOBJECTS 6+MAXLINES+MAXFIREBALLS+MAXSWEEPERS+MAXFUELPODS+MAXGUARDS+MAXHIGHSCORES/5
X
X/*	Structure for eraseable zones that minimize flicker
X*/
Xstruct zone {
X	int	type, num;
X	int	x, y, w, h;
X	int	numtouch;
X	int	touch[MAXOBJECTS];
X	int	erased, drawn;
X};
X
Xint			numzones;
Xstruct zone	zones[MAXOBJECTS];
X
X/*	init_zones initializes the eraseable zones
X*/
Xinit_zones()
X{
X	numzones = 0;
X}
X
X/*	set_zone creates an eraseable zone. x and y are the upper left hand
X	corner, w and h are the width and height of the rectangle, type is the
X	kind of object it is (player, fireball, etc,) and num is the index to
X	the object's information arrays. If type == ZLINE, w and h are used as
X	the second endpoint of a line.
X*/
Xset_zone(x, y, w, h, type, num)
Xint	x, y, w, h, type, num;
X{
X	register int	j;
X
X	zones[numzones].x = x;
X	zones[numzones].y = y;
X	zones[numzones].w = w;
X	zones[numzones].h = h;
X	zones[numzones].type = type;
X	zones[numzones].num = num;
X	zones[numzones].erased = 0;
X	zones[numzones].drawn = 0;
X	zones[numzones].numtouch = 0;
X	for(j=0; j<numzones; j++) {
X		if(zone_intersect(numzones,j)) {
X			zones[j].touch[zones[j].numtouch] = numzones;
X			zones[j].numtouch++;
X			break;
X		}
X	}
X	numzones++;
X}
X
X/*	zone_intersect checks if two zones with indexes i and j touch. There
X	is also a built-in error EDGE, since the player moving around can add
X	some uncertainty to what is covering what.
X*/
Xint	zone_intersect(i, j)
Xint	i, j;
X{
X	if(zones[i].type == ZLINE) {
X		if(zones[j].type == ZLINE) {
X			return((zones[i].w >= zones[j].x - EDGE) && (zones[i].x <=
X					zones[j].w + EDGE) && (zones[i].h >= zones[j].y -
X					EDGE) && (zones[i].y <= zones[j].h + EDGE));
X		} else {
X			return((zones[i].w >= zones[j].x - EDGE) && (zones[i].x <=
X					zones[j].x + zones[j].w + EDGE) && (zones[i].h >=
X					zones[j].y - EDGE) && (zones[i].y <= zones[j].y +
X					zones[j].h + EDGE));
X		}
X	} else {
X		if(zones[j].type == ZLINE) {
X			return((zones[j].w >= zones[i].x - EDGE) && (zones[j].x <=
X					zones[i].x + zones[i].w + EDGE) && (zones[j].h >=
X					zones[i].y - EDGE) && (zones[j].y <= zones[i].y +
X					zones[i].h + EDGE));
X		} else {
X			return((zones[i].x > zones[j].x - zones[i].w - EDGE) &&
X					(zones[i].x < zones[j].x + zones[j].w + EDGE) &&
X					(zones[i].y > zones[j].y - zones[i].h - EDGE) &&
X					(zones[i].y < zones[j].y + zones[j].h + EDGE));
X		}
X	}
X}
X
X/*	erase_draw_zones erases all the zones and draws the associated objects
X	in their new positions in such a way as to minimize flicker. The way
X	this works is to erase all zones that touch each other in a group,
X	draw their asscociated objects, then go to the next group. This way
X	the time between erase and draw is minimized for each object while
X	preventing nasty overwriting.
X*/
Xerase_draw_zones()
X{
X	register int	i;
X
X	for(i=0; i<numzones; i++) {
X		erase_recur(i);
X		draw_recur(i);
X	}
X}
X
X/*	erase_recur erases zone i and all the zones that touch it.
X*/
Xerase_recur(i)
Xint	i;
X{
X	register int	j;
X
X	if(zones[i].erased) return;
X	for(j=0; j<zones[i].numtouch; j++) {
X		erase_recur(zones[i].touch[j]);
X	}
X	if(zones[i].type == ZLINE) {
X		XDrawLine(display, gamewindow, ctable[CBLACK].smallgc, zones[i].x,
X					zones[i].y, zones[i].w, zones[i].h);
X	} else {
X		XFillRectangle(display, gamewindow, ctable[CBLACK].smallgc,
X						zones[i].x, zones[i].y, zones[i].w, zones[i].h);
X	}
X	zones[i].erased = 1;
X}
X
X/*	draw_recur draws the object associated with zone i and the objects
X	associated with all the zones that touch it.
X*/
Xdraw_recur(i)
Xint	i;
X{
X	register int	j, tmp;
X
X	if(zones[i].drawn) return;
X	for(j=0; j<zones[i].numtouch; j++) {
X		draw_recur(zones[i].touch[j]);
X	}
X	switch(zones[i].type) {
X		case ZLINE:
X			XDrawLine(display, gamewindow, ctable[CWHITE].smallgc,
X						mazelines[zones[i].num].x1 - plx + WINDOWWIDTH / 2,
X						mazelines[zones[i].num].y1 - ply + WINDOWHEIGHT / 2,
X						mazelines[zones[i].num].x2 - plx + WINDOWWIDTH / 2,
X						mazelines[zones[i].num].y2 - ply + WINDOWHEIGHT / 2);
X			break;
X		case ZPLAYER:
X			if(!dead && (exploded == -1)) {
X				XCopyArea(display, playerpix[playerphase], gamewindow,
X							ctable[CWHITE].smallgc, 0, 0, PLAYERWIDTH,
X							PLAYERHEIGHT, WINDOWWIDTH / 2 - PLAYERWIDTH / 2,
X							WINDOWHEIGHT / 2 - PLAYERHEIGHT / 2);
X			}
X			break;
X		case ZBURN:
X			if(!dead && (exploded == -1) && burn) {
X				XCopyArea(display, burnpix[playerphase / FACEFRONT],
X							gamewindow, ctable[CWHITE].smallgc, 0, 0,
X							PLAYERWIDTH, PLAYERHEIGHT, WINDOWWIDTH / 2 -
X							PLAYERWIDTH / 2, WINDOWHEIGHT / 2 - PLAYERHEIGHT
X							/ 2);
X			}
X			break;
X		case ZEXPLODE:
X			if(!dead && (exploded > -1)) {
X				XCopyArea(display, explodepix[exploded], gamewindow,
X							ctable[CWHITE].smallgc, 0, 0, EXPLODEWIDTH,
X							EXPLODEHEIGHT, WINDOWWIDTH / 2 - EXPLODEWIDTH / 2,
X							WINDOWHEIGHT / 2 - EXPLODEHEIGHT / 2);
X			}
X			break;
X		case ZFIRE:
X			XCopyArea(display, firepix[firephase[zones[i].num]],
X						gamewindow, ctable[CWHITE].smallgc, 0, 0,
X						FIREWIDTH, FIREHEIGHT, transx(firex[zones[i].num],
X						FIREWIDTH), transy(firey[zones[i].num],
X						FIREHEIGHT));
X			break;
X		case ZGUARD:
X			XCopyArea(display,
X				guardpix[guarddir[zones[i].num]][guardphase[zones[i].num]],
X						gamewindow, ctable[CWHITE].smallgc, 0, 0,
X						GUARDWIDTH, GUARDHEIGHT, transx(guardx[zones[i].num],
X						GUARDWIDTH), transy(guardy[zones[i].num],
X						GUARDHEIGHT));
X			break;
X		case ZSWEEP:
X			XCopyArea(display, sweeperpix[sweepphase[zones[i].num]],
X						gamewindow, ctable[CWHITE].smallgc, 0, 0,
X						SWEEPERWIDTH, SWEEPERHEIGHT,
X						transx(sweepx[zones[i].num], SWEEPERWIDTH),
X						transy(sweepy[zones[i].num], SWEEPERHEIGHT));
X			break;
X		case ZFUEL:
X			if(fuelalive[zones[i].num]) {
X				XCopyArea(display, fuelpix, gamewindow,
X							ctable[CWHITE].smallgc, 0, 0, FUELWIDTH,
X							FUELHEIGHT, transx(fuelx[zones[i].num],
X							FUELWIDTH), transy(fuely[zones[i].num],
X							FUELHEIGHT));
X			} else if(fueltimer[zones[i].num]) {
X				tmp = XTextWidth(fontinfo, "100", 3) / 2;
X				XDrawString(display, gamewindow, ctable[CGREEN].smallgc,
X							fuelx[zones[i].num] - plx + WINDOWWIDTH / 2 -
X							tmp, fuely[zones[i].num] - ply +
X							WINDOWHEIGHT / 2, "100", 3);
X			}
X			break;
X		case ZKEY:
X			if(keyalive) {
X				XCopyArea(display, keypix, gamewindow,
X							ctable[CWHITE].smallgc, 0, 0, KEYWIDTH,
X							KEYHEIGHT, transx(keyx, KEYWIDTH),
X							transy(keyy, KEYHEIGHT));
X			} else if(keytimer) {
X				tmp = XTextWidth(fontinfo, "500", 3) / 2;
X				XDrawString(display, gamewindow, ctable[CGREEN].smallgc,
X							keyx - plx + WINDOWWIDTH / 2 - tmp, keyy -
X							ply + WINDOWHEIGHT / 2, "500", 3);
X			}
X			break;
X		case ZDOOR:
X			tmp = indoor;
X			if(indoor && (exploded > -1))  tmp = 0;
X			XCopyArea(display, doorpix[tmp], gamewindow,
X						ctable[CWHITE].smallgc, 0, 0, DOORWIDTH,
X						DOORHEIGHT, transx(doorx, DOORWIDTH),
X						transy(doory, DOORHEIGHT) - (DOORHEIGHT -
X						PLAYERHEIGHT) / 2);
X			break;
X		case ZSMESS:
X			if(messagetime != 0) {
X				if(messagecolor == CBLACK) tmp = random() % (NCOLORS-1) + 1;
X				else tmp = messagecolor;
X				XDrawString(display, gamewindow, ctable[tmp].smallgc,
X							messagex, messagey, messagestring, messagelength);
X			}
X			break;
X		case ZBMESS:
X			if(bigmessagetime != 0) {
X				if(bigmessagecolor == CBLACK) tmp = random() % (NCOLORS-1) + 1;
X				else tmp = bigmessagecolor;
X				XDrawString(display, gamewindow, ctable[tmp].biggc,
X							bigmessagex, bigmessagey, bigmessagestring, 
X							bigmessagelength);
X			}
X			break;
X	}
X	zones[i].drawn = 1;
X}
X
X/*	refresh draws all the objects
X*/
Xrefresh()
X{
X	register int	i;
X
X	for(i=0; i<numzones; i++) {
X		draw_recur(i);
X	}
X	for(i=0; i<numzones; i++) {
X		zones[i].drawn = 0;
X	}
X}
X
X#endif
END_OF_FILE
if test 7917 -ne `wc -c <'erase.c'`; then
    echo shar: \"'erase.c'\" unpacked with wrong size!
fi
# end of 'erase.c'
fi
if test -f 'initx.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'initx.c'\"
else
echo shar: Extracting \"'initx.c'\" \(4961 characters\)
sed "s/^X//" >'initx.c' <<'END_OF_FILE'
X/*	initx.c : routines that set up the X resources and colors.
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
XDisplay			*display;
XColormap		colormap;
XWindow			rootwindow;
Xint				screen, depth;
Xunsigned long	blackpixel, whitepixel;
XXFontStruct		*fontinfo, *bigfontinfo;
X
X/*	initialize the colortable with the names of the colors (from rgb.txt)
X*/
Xstruct colors	ctable[] = {
X	{ "black"		},
X	{ "red"			},
X	{ "orange"		},
X	{ "yellow"		},
X	{ "RoyalBlue2"	},
X	{ "grey50"		},
X	{ "green"		},
X	{ "white"		}
X};
X
X/*	Depending on your system, the fontnames listed here may not be
X	complete enough to pick the right font. The system I developed on
X	has 475 fonts, so these should be specific enough. But just in
X	case, here are the full fontnames:
X
X	small font:
X	-misc-fixed-medium-r-normal--10-70-100-100-c-60-iso8859-1
X
X	big font:
X	-adobe-courier-bold-r-normal--25-180-100-100-m-150-iso8859-1
X
X	It also might be that you won't have these fonts. If not, pick two
X	fonts that look good. The program adjusts things on the screen for
X	whatever fonts the program uses, so almost anything should do.
X	Just pick a pretty small font for the small font, and a reasonably
X	large font for the big font. Use xfontsel to make this easier
X	since it makes it really easy to pick fonts, and you can paste the
X	resulting fontname right into the code.
X*/
X
Xstatic char	*fontname = "-*-fixed-medium-r-normal--*-70-*-*-c-*-*-*";
Xstatic char	*bigfontname = "-*-courier-bold-r-normal--*-180-*-*-m-150-*-*";
X
X/*	init_X opens the display and sets up all the color stuff
X*/
Xinit_X()
X{
X    display = XOpenDisplay(NULL);
X    if (display == NULL) {
X       fprintf(stderr, "Jetpack : Cannot connect to X Server %s\n",
X               XDisplayName(NULL));
X       exit(1);
X    }
X	rootwindow = DefaultRootWindow(display);
X    screen = DefaultScreen(display);
X	colormap = DefaultColormap(display, screen);
X    depth = DefaultDepth(display, screen);
X   	blackpixel = BlackPixel(display, screen);
X   	whitepixel = WhitePixel(display, screen);
X	set_up_colors();
X	set_up_contexts();
X}
X
X/*	set_up_contexts creates the graphics smallgcs used in the game, and
X	stores them in the ctable array. The fonts are created here too.
X*/
Xset_up_contexts()
X{
X	int			i;
X	XGCValues	values;
X	Font		small, big;
X
X	fontinfo = XLoadQueryFont(display, fontname);
X	if(fontinfo == NULL) {
X		fprintf(stderr, "Jetpack : Couldn't load %s font.\n",fontname);
X		exit(1);
X	}
X	bigfontinfo = XLoadQueryFont(display, bigfontname);
X	if(bigfontinfo == NULL) {
X		fprintf(stderr, "Jetpack : Couldn't load %s font.\n",bigfontname);
X		exit(1);
X	}
X	big = bigfontinfo->fid;
X	small = fontinfo->fid;
X	values.font = small;
X	values.function = GXcopy;
X	ctable[CBLACK].smallgc = XCreateGC(display, rootwindow,
X										GCFunction|GCFont, &values);
X	values.font = big;
X	ctable[CBLACK].biggc = XCreateGC(display, rootwindow,
X										GCFunction|GCFont, &values);
X	values.function = GXor;
X	for(i=1; i<NCOLORS; i++) {
X		values.font = small;
X		ctable[i].smallgc = XCreateGC(display, rootwindow,
X										GCFunction|GCFont, &values);
X		values.font = big;
X		ctable[i].biggc = XCreateGC(display, rootwindow,
X									GCFunction|GCFont, &values);
X	}
X	for(i=0; i<NCOLORS; i++) {
X		XSetForeground(display, ctable[i].smallgc,
X						ctable[i].pixelvalue);
X		XSetBackground(display, ctable[i].smallgc,
X						ctable[CBLACK].pixelvalue);
X		XSetForeground(display, ctable[i].biggc,
X						ctable[i].pixelvalue);
X		XSetBackground(display, ctable[i].biggc,
X						ctable[CBLACK].pixelvalue);
X	}
X}
X
X/*	set_up_colors creates the colors and stores them in the graphics
X	smallgcs. If the system is mono, all colors are white except CBLACK.
X	This isn't very elegant, but I use the colors for so many different
X	items that it would be impossible to set some of them to black and not
X	lose some important images. It's still playable.
X*/
Xset_up_colors()
X{
X	int				i;
X	XColor			tmpcolor;
X	unsigned long	pixel, planes[3];
X
X	if(DisplayCells(display, screen) <= 2) {
X		for(i=0; i<NCOLORS; i++) {
X			if(i == CBLACK) ctable[i].pixelvalue = blackpixel;
X			else ctable[i].pixelvalue = whitepixel;
X		}
X	} else {
X		XAllocColorCells(display, colormap, False, planes, 3, &pixel, 1);
X		for(i=0; i<NCOLORS; i++) {
X			XParseColor(display, colormap, ctable[i].name, &tmpcolor);
X			switch(i) {
X				case CBLACK:
X					tmpcolor.pixel = pixel;
X					break;
X				case CRED:
X					tmpcolor.pixel = pixel | planes[0];
X					break;
X				case CORANGE:
X					tmpcolor.pixel = pixel | planes[1];
X					break;
X				case CYELLOW:
X					tmpcolor.pixel = pixel | planes[1] | planes[0];
X					break;
X				case CBLUE:
X					tmpcolor.pixel = pixel | planes[2];
X					break;
X				case CGREY:
X					tmpcolor.pixel = pixel | planes[2] | planes[0];
X					break;
X				case CGREEN:
X					tmpcolor.pixel = pixel | planes[2] | planes[1];
X					break;
X				case CWHITE:
X					tmpcolor.pixel = pixel | planes[2] | planes[1] | planes[0];
X					break;
X			}
X			XStoreColor(display, colormap, &tmpcolor);
X			ctable[i].pixelvalue = tmpcolor.pixel;
X		}
X	}
X}
END_OF_FILE
if test 4961 -ne `wc -c <'initx.c'`; then
    echo shar: \"'initx.c'\" unpacked with wrong size!
fi
# end of 'initx.c'
fi
if test -f 'maze.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'maze.c'\"
else
echo shar: Extracting \"'maze.c'\" \(4831 characters\)
sed "s/^X//" >'maze.c' <<'END_OF_FILE'
X/*	maze.c : routines that generate the mazes
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
X/*	These arrays are used to implement direction.
X*/
Xchar	walldir[4] = { WALLUP, WALLRIGHT, WALLDOWN, WALLLEFT };
Xchar	oppdir[4] = { WALLDOWN, WALLLEFT, WALLUP, WALLRIGHT };
Xint		xdir[4] = { 0, 1, 0, -1 };
Xint		ydir[4] = { -1, 0, 1, 0 };
X
Xint			maze[MAXMAZEWIDTH][MAXMAZEHEIGHT];
Xstruct line	mazelines[MAXLINES];
Xint			mazescale, mazelcount, mazewidth, mazeheight;
X
X/*	generate maze uses a digging algorithm to generate the maze.
X*/
Xgenerate_maze(width, height, ratio, twistratio)
Xint	width, height;
Xfloat ratio, twistratio;
X{
X	register int	x, y, d, cells, lines, twist, dug;
X	char			celldone[MAXMAZEWIDTH][MAXMAZEHEIGHT];
X
X	mazelcount = 0;
X	if(width > MAXMAZEWIDTH - 1) width = MAXMAZEWIDTH - 1;
X	if(height > MAXMAZEHEIGHT - 1) height = MAXMAZEHEIGHT - 1;
X	mazewidth = width;
X	mazeheight = height;
X	lines = (int) ((mazewidth-1)*(mazeheight-1) * ratio);
X	twist = (int) (twistratio * width * height);
X
X	/*	Make the maze full of walls.
X	*/
X	for(x=0; x < MAXMAZEWIDTH; x++)
X		for(y=0; y < MAXMAZEHEIGHT; y++) {
X			maze[x][y] = (WALLUP | WALLDOWN | WALLLEFT | WALLRIGHT);
X			celldone[x][y] = 0;
X		}
X
X	/*	Alter the edges of the maze so the algorithm uses them as
X		boundaries.
X	*/
X	for(x=0; x < width + 1; x++) {
X		celldone[x][0] = 1;
X		celldone[x][height+1] = 1;
X		maze[x][0] = 0;
X		maze[x][height+1] = WALLUP;
X	}
X	for(y=0; y < height + 1; y++) {
X		celldone[0][y] = 1;
X		celldone[width+1][y] = 1;
X		maze[0][y] = 0;
X		maze[width+1][y] = WALLLEFT;
X	}
X	maze[width+1][height+1] = 0;
X
X	/*	Pick a random cell to start and clear it.
X	*/
X	x = random() % width + 1;
X	y = random() % height + 1;
X	cells = width * height - 1;
X	celldone[x][y] = 1;
X	dug = 0;
X	while(cells > 0) {
X
X		/*	If we aren't in a dug cell or the cell we are in is completely
X			surrounded by dug cells or we've dug the maximum length of a
X			passage, go to a new cell.
X		*/
X		while((!celldone[x][y]) ||
X			(celldone[x][y-1] && celldone[x-1][y] && celldone[x][y+1] &&
X			celldone[x+1][y]) || (dug > twist)) {
X			x = random() % width + 1;
X			y = random() % height + 1;
X			dug = 0;
X		}
X
X		/*	Pick a direction that has a wall
X		*/
X		do {
X			d = random() % 4;
X		} while(celldone[x+xdir[d]][y+ydir[d]]);
X
X		/* Dig!
X		*/
X		cells--;
X		maze[x][y] &= ~(walldir[d]);
X		x += xdir[d];
X		y += ydir[d];
X		celldone[x][y] = 1;
X		maze[x][y] &= ~(oppdir[d]);
X		dug++;
X	}
X
X	/*	Remove random lines according to the ratio passed.
X	*/
X	while(lines > 0) {
X		do {
X			do {
X				x = random() % width + 1;
X				y = random() % height + 1;
X			} while(!maze[x][y]);
X			do {
X				d = random() % 4;
X			} while(!(maze[x][y] & walldir[d]));
X		} while((x+xdir[d] <= 0) || (x+xdir[d] >= mazewidth + 1) ||
X				(y+ydir[d] <= 0) || (y+ydir[d] >= mazeheight + 1));
X		maze[x][y] &= ~(walldir[d]);
X		maze[x+xdir[d]][y+ydir[d]] &= ~(oppdir[d]);
X		lines--;
X	}
X
X	/*	Create the lines used for drawing the maze.
X	*/
X	convert_maze(width, height);
X}
X
X/*	add_line adds a world-coordinates line to the maze drawing
X*/
Xadd_line( x1, y1, x2, y2)
Xint	x1, y1, x2, y2;
X{
X	mazelines[mazelcount].x1 = x1;
X	mazelines[mazelcount].y1 = y1;
X	mazelines[mazelcount].x2 = x2;
X	mazelines[mazelcount].y2 = y2;
X	mazelcount++;
X}
X
X/*	convert_maze creates a world drawing of the maze from its array
X	structure.
X*/
Xconvert_maze(width, height)
Xint	width, height;
X{
X	int x, y;
X
X	for(x=1; x<width+2; x++)
X		for(y=1; y <height+2; y++) {
X			if(maze[x][y] & WALLUP) add_line(x*mazescale, y*mazescale,
X												(x+1)*mazescale, y*mazescale);
X			if(maze[x][y] & WALLLEFT) add_line(x*mazescale, y*mazescale,
X												x*mazescale, (y+1)*mazescale);
X		}
X}
X
X/*  setup_title_maze creates the trivial maze that the title screen uses,
X    and creates the monsters that cavort in it.
X*/
Xsetup_title_maze()
X
X{
X    mazewidth = 4;
X    mazeheight = 3;
X    mazescale = 100;
X    mazelcount = 0;
X    maze[0][0] = 0; maze[1][0] = 4; maze[2][0] = 4; maze[3][0] = 4;
X    maze[4][0] = 4; maze[5][0] = 0; maze[0][1] = 2; maze[1][1] = 9;
X    maze[2][1] = 1; maze[3][1] = 1; maze[4][1] = 3; maze[5][1] = 8;
X    maze[0][2] = 2; maze[1][2] = 8; maze[2][2] = 0; maze[3][2] = 0;
X    maze[4][2] = 2; maze[5][2] = 8; maze[0][3] = 2; maze[1][3] = 12;
X    maze[2][3] = 4; maze[3][3] = 4; maze[4][3] = 6; maze[5][3] = 8;
X    maze[0][4] = 0; maze[1][4] = 1; maze[2][4] = 1; maze[3][4] = 1;
X    maze[4][4] = 1; maze[5][4] = 0;
X    convert_maze(4, 3);
X    plx = 300; ply = 170;
X    playerphase = FACEFRONT; playerdir = STOP; burn = 0;
X    random_fireballs(random() % 3 + 2, 3, 7);
X    random_guards(random() % 3 + 1, 3, 7);
X    numsweep = 0;
X    place_sweeper(random() % 4 + 1, 0, 2, 1, random() % 5 + 1);
X    place_sweeper(random() % 4 + 1, 4, 0, 1, random() % 5 + 1);
X    place_sweeper(0,random() % 3 + 1, 1, 1, random() % 5 + 1);
X    place_sweeper(5,random() % 3 + 1, 3, 1, random() % 5 + 1);
X}
END_OF_FILE
if test 4831 -ne `wc -c <'maze.c'`; then
    echo shar: \"'maze.c'\" unpacked with wrong size!
fi
# end of 'maze.c'
fi
if test -f 'normal.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'normal.c'\"
else
echo shar: Extracting \"'normal.c'\" \(4732 characters\)
sed "s/^X//" >'normal.c' <<'END_OF_FILE'
X/*	normal.c : routine that sets up the levels that aren't predefined
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
X/* normal_level is a very ugly switch statement that sets up the various
X	types of "normal" levels
X*/
Xnormal_level()
X{
X	register int	mx, my, f, p, s, n, md, mt, msc, fmin, fmax, smin, smax,
X					g, gmin, gmax, kind, obj;
X
X	/*	there are 5 kinds of "normal" levels: Open levels, Big levels,
X		Twisty levels, and Death levels
X	*/
X	kind = level % 8;
X	switch(kind) {
X		/*	Twisty level: medium large maze, all walls, normal fuel and
X			enemies, many intersections.
X		*/
X		case 0:
X			message("Twisty Level", CGREEN, 75);
X			msc = random() % 50 + 100;
X			mx = random() % 15 + 5;
X			my = random() % 15 + 5;
X			md = 0;
X			mt = 0;
X			obj = (mx * my * msc) / 500;
X			if(obj > 30) obj = 30;
X			do {
X				f = random() % 30;
X				s = random() % 30;
X				g = random() % 30;
X			} while((f + s + g > obj) || (f + s + g < obj / 2));
X			p = random() % (obj / 4) + obj / 4;
X			smin = level / 3 + 1;
X			smax = level / 3 + 3;
X			if(smin > 5) smin = 5;
X			fmin = level / 3 - 1;
X			fmax = level / 3 + 3;
X			if(fmin > 5) fmin = 5;
X			gmin = level / 3 + 1;
X			gmax = level / 3 + 3;
X			if(gmin > 5) gmin = 5;
X			make_random_level(mx, my, msc, md, mt, f, fmin, fmax, s, smin, smax,
X								g, gmin, gmax, p);
X			break;
X
X		/*	Open level: medium size maze, very few walls, normal level of
X			fuel and enemies
X		*/
X		case 2:
X			message("Open Level", CORANGE, 75);
X			msc = random() % 75 + 75;
X			mx = random() % 20 + 5;
X			my = random() % 20 + 5;
X			md = random() % 30 + 71;
X			mt = 100;
X			obj = (mx * my * msc) / 500;
X			if(obj > 30) obj = 30;
X			do {
X				f = random() % 30;
X				s = random() % 30;
X				g = random() % 30;
X			} while((f + s + g > obj) || (f + s + g < obj / 2));
X			p = random() % (obj / 4) + obj / 4;
X			smin = level / 3 + 1;
X			smax = level / 3 + 3;
X			if(smin > 5) smin = 5;
X			fmin = level / 3 - 1;
X			fmax = level / 3 + 3;
X			if(fmin > 5) fmin = 5;
X			gmin = level / 3 + 1;
X			gmax = level / 3 + 3;
X			if(gmin > 5) gmin = 5;
X			make_random_level(mx, my, msc, md, mt, f, fmin, fmax, s, smin, smax,
X								g, gmin, gmax, p);
X			break;
X		/*	Big level: large maze, very few walls missing if any, normal
X			level of fuel and enemies
X		*/
X		case 6:
X			message("Big Level", CYELLOW, 75);
X			msc = random() % 25 + 125;
X			mx = random() % 10 + 15;
X			my = random() % 10 + 15;
X			if(random() % 3 == 0) md = random() % 5;
X			else md = 0;
X			mt = random() % 101;
X			obj = (mx * my * msc) / 500;
X			p = obj / 2;
X			if(obj > 30) obj = 30;
X			do {
X				f = random() % 30;
X				s = random() % 30;
X				g = random() % 30;
X			} while((f + s + g > obj) || (f + s + g < obj / 2));
X			smin = level / 3 + 1;
X			smax = level / 3 + 3;
X			if(smin > 5) smin = 5;
X			fmin = level / 3 - 1;
X			fmax = level / 3 + 3;
X			if(fmin > 5) fmin = 5;
X			gmin = level / 3 + 1;
X			gmax = level / 3 + 3;
X			if(gmin > 5) gmin = 5;
X			make_random_level(mx, my, msc, md, mt, f, fmin, fmax, s, smin, smax,
X								g, gmin, gmax, p);
X			break;
X		/*	Death level: small maze, few walls missing, little fuel, two
X			to three times normal level of enemies
X		*/
X		case 4:
X			message("Death Level", CRED, 75);
X			msc = random() % 20 + 100;
X			mx = random() % 5 + 5;
X			my = random() % 5 + 5;
X			md = random() % 10;
X			mt = random() % 101;
X			obj = (mx * my * msc) / 500;
X			do {
X				f = random() % 30;
X				s = random() % 30;
X				g = random() % 30;
X			} while((f + s + g > obj * 3) || (f + s + g < obj * 2));
X			p = random() % (obj / 4) + obj / 3;
X			smin = level / 3 + 1;
X			smax = level / 3 + 3;
X			if(smin > 5) smin = 5;
X			fmin = level / 3 - 1;
X			fmax = level / 3 + 3;
X			if(fmin > 5) fmin = 5;
X			gmin = level / 3 + 1;
X			gmax = level / 3 + 3;
X			if(gmin > 5) gmin = 5;
X			make_random_level(mx, my, msc, md, mt, f, fmin, fmax, s, smin, smax,
X								g, gmin, gmax, p);
X			break;
X		/*	Ordinary level: normal level of fuel and enemies, maze
X			varies.
X		*/
X		default:
X			msc = random() % 75 + 75;
X			mx = random() % 15 + 5;
X			my = random() % 15 + 5;
X			n = random() % 10;
X			if(n == 0) {
X				md = random() % 90 + 11;
X			} else if(n < 4) {
X				md = random() % 10 + 1;
X			} else md = 0;
X			mt = random() % 101;
X			obj = (mx * my * msc) / 500;
X			if(obj > 30) obj = 30;
X			do {
X				f = random() % 30;
X				s = random() % 30;
X				g = random() % 30;
X			} while((f + s + g > obj) || (f + s + g < obj / 2));
X			p = random() % (obj / 4) + obj / 3;
X			smin = level / 3 + 1;
X			smax = level / 3 + 3;
X			if(smin > 5) smin = 5;
X			fmin = level / 3 - 1;
X			fmax = level / 3 + 3;
X			if(fmin > 5) fmin = 5;
X			gmin = level / 3 + 1;
X			gmax = level / 3 + 3;
X			if(gmin > 5) gmin = 5;
X			make_random_level(mx, my, msc, md, mt, f, fmin, fmax, s, smin, smax,
X								g, gmin, gmax, p);
X			break;
X	}
X}
END_OF_FILE
if test 4732 -ne `wc -c <'normal.c'`; then
    echo shar: \"'normal.c'\" unpacked with wrong size!
fi
# end of 'normal.c'
fi
if test -f 'setup.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'setup.c'\"
else
echo shar: Extracting \"'setup.c'\" \(8638 characters\)
sed "s/^X//" >'setup.c' <<'END_OF_FILE'
X/*	setup.c : routines used to setup level stuff.
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
X/*	make_random_level takes its huge list of arguments and creates a
X	level.
X*/
Xmake_random_level(mx, my, msc, md, mt, f, fmin, fmax, s, smin, smax, g, gmin,
X					gmax, p)
Xint mx, my, msc, md, mt, f, fmin, fmax, s, smin, smax, g, gmin, gmax, p;
X{
X	float	r, t;
X
X	mazescale = msc;
X	r = ((float) md) / 100.0;
X	t = ((float) mt) / 100.0;
X	generate_maze(mx, my, r, t);
X	random_player();
X	random_fireballs(f, fmin, fmax);
X	random_fuel(p);
X	random_sweepers(s, smin, smax);
X	random_guards(g, gmin, gmax);
X	random_key();
X	if(r > 0.75) r = 0.75;
X	bonus = (((int) (mazewidth * mazeheight * mazescale * (1 - r)) -
X				p * 100 + s * 50 + g * 50 + f * 100) / 100) * 10;
X	if(bonus < 500) bonus = 500;
X	initbonus = bonus;
X}
X
X/*	reset_level just gives values to certain global variables that need to
X	be initialized for each level.
X*/
Xreset_level()
X{
X	leveldone = 0;
X	waiting = 0;
X	messagetime = 0;
X	bigmessagetime = 0;
X	numlmessage = 0;
X	numfire = 0;
X	numfuel = 0;
X	numsweep = 0;
X	numguard = 0;
X	bonustimer = 20;
X	if(playerfuel < FUELCAPACITY / 2) playerfuel = FUELCAPACITY / 2;
X
X#ifndef	BLIT
X	init_zones();
X#endif
X
X}
X
X/*	reset_game just gives values to certain global variables that need to
X	be initialized for each game.
X*/
Xreset_game()
X{
X	dead = 0;
X    paused = 0;
X    score = 0;
X    men = 3;
X    playerfuel = FUELCAPACITY;
X    exploded = -1;
X    level = 1;
X	keyalive = 1;
X	extramaninc = 1;
X}
X
X/*	place_player puts the player and the door at maze location (x,y).
X*/
Xplace_player(x, y)
Xint	x, y;
X{
X	ply = (y + 1) * mazescale - 11;
X	plx = x * mazescale + mazescale / 2;
X	doorx = plx;
X	doory = ply;
X	exploded = -1;
X	walk = 1;
X	playervert = 0;
X	indoor = 1;
X	burn = 0;
X	playerdir = STOP;
X	playerphase = FACEFRONT;
X}
X
X/*	random_player puts the player and the door in a random maze location
X	with a floor.
X*/
Xrandom_player()
X{
X	register int	x, y;
X
X	do {
X		x = random() % mazewidth + 1;
X		y = random() % mazeheight + 1;
X	} while(!(maze[x][y] & WALLDOWN));
X	ply = (y + 1) * mazescale - 11;
X	plx = x * mazescale + mazescale / 2;
X	doorx = plx;
X	doory = ply;
X	exploded = -1;
X	walk = 1;
X	playervert = 0;
X	indoor = 1;
X	burn = 0;
X	playerdir = STOP;
X	playerphase = FACEFRONT;
X}
X
X/*	place_fireball puts a fireball at world position (x,y) with speed
X	[dx,dy]. The coordinates are modified to so the fireball won't sit on
X	a wall.
X*/
Xplace_fireball(x, y, dx, dy)
Xint	x, y, dx, dy;
X{
X	if(numfire == MAXFIREBALLS) return;
X	nx = x;
X	ny = y;
X	set_in_maze(FIREWIDTH / 2);
X	firex[numfire] = nx;
X	firey[numfire] = ny;
X	firedx[numfire] = dx;
X	firedy[numfire] = dy;
X	numfire++;
X}
X
X/*	random_fireballs puts num fireballs in the maze with speeds ranging
X	from min to max. The coordinates of each are generated so they won't
X	sit on a wall or are too close to the player.
X*/
Xrandom_fireballs(num, min, max)
Xint	num, min, max;
X{
X	register int	i;
X
X	if(num > MAXFIREBALLS) numfire = MAXFIREBALLS;
X	else numfire = num;
X	for(i=0; i<numfire; i++) {
X		do {
X			nx = random() % (mazewidth * mazescale) + mazescale;
X			ny = random() % (mazeheight * mazescale) + mazescale;
X			set_in_maze(FIREWIDTH / 2);
X		} while((plx - nx) * (plx - nx) + (ply - ny) * (ply - ny) < 40000);
X		firex[i] = nx;
X		firey[i] = ny;
X		do {
X			firedx[i] = random() % 21 - 10;
X			firedy[i] = random() % 21 - 10;
X		} while(((firedx[i] ==  0) && (firedy[i] == 0)) || (abs(firedx[i]) +
X				abs(firedy[i]) < min) || (abs(firedx[i]) + abs(firedy[i])
X				> max));
X		firephase[i] = random() % FIREPHASES;
X	}
X}
X
X/*	place_guard puts a guard at maze location (x,y) with direction dir and
X	speed speed
X*/
Xplace_guard(x, y, dir, speed)
Xint	x, y, dir, speed;
X{
X	if(numguard == MAXGUARDS) return;
X	guardx[numguard] = x * mazescale + mazescale / 2;
X	guardy[numguard] = y * mazescale + mazescale / 2;
X	guarddir[numguard] = dir;
X	guardspeed[numguard] = speed;
X	guardphase[numguard] = random() % GUARDPHASES;
X	guardtime[numguard] = 0;
X	numguard++;
X}
X
X/*	random_guards puts num guards in the maze with speeds ranging from min
X	to max. Guards are nor placed on the same square as the player.
X*/
Xrandom_guards(num, min, max)
Xint	num, min, max;
X{
X	register int	i, x, y, m;
X
X	if(num > MAXGUARDS) numguard = MAXGUARDS;
X	else numguard = num;
X	for(i=0; i<numguard; i++) {
X		do {
X			x = random() % mazewidth + 1;
X			y = random() % mazeheight + 1;
X		} while((x == plx / mazescale) && (y == ply / mazescale));
X		guardx[i] = x * mazescale + mazescale / 2;
X		guardy[i] = y * mazescale + mazescale / 2;
X		if(max > 9) m = 9;
X		else m = max;
X		guardspeed[i] = random() % (m - min + 1) + min;
X		guardphase[i] = random() % GUARDPHASES;
X		guardtime[i] = 0;
X		do {
X			guarddir[i] = random() % 4;
X		} while(maze[x][y] & walldir[guarddir[i]]);
X	}
X}
X
X/*	place_sweeper puts a sweeper at maze location (x,y) with a floor
X	direction of floor, rotation of rot, and speed speed
X*/
Xplace_sweeper(x, y, floor, rot, speed)
Xint	x, y, floor, rot, speed;
X{
X	if(numsweep == MAXSWEEPERS) return;
X	sweepx[numsweep] = x * mazescale + mazescale / 2 + xdir[floor] *
X						(mazescale / 2 - 11);
X	sweepy[numsweep] = y * mazescale + mazescale / 2 + ydir[floor] *
X						(mazescale / 2 - 11);
X	sweepfloor[numsweep] = floor;
X	if(rot == 1) {
X		if(floor == 0) sweepdir[numsweep] = 3;
X		else sweepdir[numsweep] = floor - 1;
X	} else {
X		if(floor == 3) sweepdir[numsweep] = 0;
X		else sweepdir[numsweep] = floor + 1;
X	}
X	sweeprot[numsweep] = rot;
X	sweepphase[numsweep] = random() % SWEEPERPHASES;
X	sweepspeed[numsweep] = speed;
X	numsweep++;
X}
X
X/*	random sweepers puts num sweepers in the maze with speeds from min to
X	max. Sweepers will not be placed in the same square as the player.
X*/
Xrandom_sweepers(num, min, max)
Xint	num, min, max;
X{
X	register int	i, x, y, dir, m;
X
X	if(num > MAXSWEEPERS) numsweep = MAXSWEEPERS;
X	else numsweep = num;
X	for(i=0; i<numsweep; i++) {
X		do {
X			do {
X				x = random() % mazewidth + 1;
X				y = random() % mazeheight + 1;
X			} while(!maze[x][y]);
X			do {
X				dir = random() % 4;
X			} while(!(maze[x][y] & walldir[dir]));
X			sweepx[i] = x * mazescale + mazescale / 2 + xdir[dir] *
X						(mazescale / 2 - 11);
X			sweepy[i] = y * mazescale + mazescale / 2 + ydir[dir] *
X						(mazescale / 2 - 11);
X			sweepfloor[i] = dir;
X			if(random() & 01) {
X				if(dir == 0) sweepdir[i] = 3;
X				else sweepdir[i] = dir - 1;
X				sweeprot[i] = 1;
X			} else {
X				if(dir == 3) sweepdir[i] = 0;
X				else sweepdir[i] = dir + 1;
X				sweeprot[i] = -1;
X			}
X		} while((plx / mazescale == sweepx[i]) &&
X					(ply / mazescale == sweepy[i]));
X		sweepphase[i] = random() % SWEEPERPHASES;
X		if(max > 9) m = 9;
X		else m = max;
X		sweepspeed[i] = random() % (m - min + 1) + min;
X	}
X}
X
X/*	place_fuel puts a fuel pod at world location (x,y). The coordinates
X	are modified so the pod won't sit on a wall.
X*/
Xplace_fuel(x, y)
Xint x, y;
X{
X	if(numfuel == MAXFUELPODS) return;
X	nx = x;
X	ny = y;
X	set_in_maze(FUELWIDTH / 2);
X	fuelx[numfuel] = nx;
X	fuely[numfuel] = ny;
X	fuelalive[numfuel] = 1;
X	numfuel++;
X}
X
X/*	random_fuel places num fuel pods in the maze. The coordinates are
X	generated so they don't sit on walls or too close together.
X*/
Xrandom_fuel(num)
Xint	num;
X{
X	register int	i, j, ok, radius;
X
X	if(num > MAXFUELPODS) numfuel = MAXFUELPODS;
X	else numfuel = num;
X	if(numfuel == 0) return;
X	radius = (mazewidth * mazeheight * mazescale * mazescale) / (6 * numfuel);
X	for(i=0; i<numfuel; i++) {
X		do {
X			nx = random() % (mazewidth * mazescale) + mazescale;
X			ny = random() % (mazeheight * mazescale) + mazescale;
X		set_in_maze(FUELWIDTH / 2);
X		ok = 1;
X		for(j=0; j<i; j++) {
X			if((fuelx[j] - nx) * (fuelx[j] - nx) +
X				(fuely[j] - ny) * (fuely[j] - ny) < radius) ok = 0;
X		}
X		} while(!ok);
X		fuelx[i] = nx;
X		fuely[i] = ny;
X		fuelalive[i] = 1;
X	}
X}
X
X/*	place_key puts the key at world coordinates (x,y). The coordinates are
X	modified so the key will not sit on a wall.
X*/
Xplace_key(x, y)
Xint	x, y;
X{
X	nx = x;
X	ny = y;
X	set_in_maze(KEYWIDTH / 2);
X	keyx = nx;
X	keyy = ny;
X	keyalive = 1;
X}
X
X/*	random_key puts the key in a random location. The coordinates are
X	generated so the key won't be on a wall or close to the player.
X*/
Xrandom_key()
X{
X	register int	radius,dist;
X
X	if(mazewidth > mazeheight) {
X		if(plx > (mazewidth * mazescale) / 2) dist = plx;
X		else dist = mazewidth * mazescale - plx;
X	} else {
X		if(ply > (mazeheight * mazescale) / 2) dist = ply;
X		else dist = mazeheight * mazescale - ply;
X	}
X	radius = (dist * dist * 9) / 16;
X	do {
X		nx = random() % (mazewidth * mazescale) + mazescale;
X		ny = random() % (mazeheight * mazescale) + mazescale;
X	} while((plx - nx) * (plx - nx) + (ply - ny) * (ply - ny) < radius);
X	set_in_maze(KEYWIDTH / 2);
X	keyx = nx;
X	keyy = ny;
X	keyalive = 1;
X}
END_OF_FILE
if test 8638 -ne `wc -c <'setup.c'`; then
    echo shar: \"'setup.c'\" unpacked with wrong size!
fi
# end of 'setup.c'
fi
if test -f 'update.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'update.c'\"
else
echo shar: Extracting \"'update.c'\" \(5977 characters\)
sed "s/^X//" >'update.c' <<'END_OF_FILE'
X/*	update.c : routines that update all the objects for each frame
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
Xint	plx, ply, burn, playerphase, playerdir, playervert, playerfuel,
X	walk, waiting, exploded, explodetimer;
X
Xint	numfire;
Xint	firex[MAXFIREBALLS], firey[MAXFIREBALLS], firedx[MAXFIREBALLS],
X	firedy[MAXFIREBALLS], firephase[MAXFIREBALLS];
X
Xint	numfuel;
Xint	fuelx[MAXFUELPODS], fuely[MAXFUELPODS], fuelalive[MAXFUELPODS],
X	fueltimer[MAXFUELPODS];
X
Xint	numsweep;
Xint	sweepx[MAXSWEEPERS], sweepy[MAXSWEEPERS], sweepphase[MAXSWEEPERS],
X	sweepdir[MAXSWEEPERS], sweepfloor[MAXSWEEPERS], sweepspeed[MAXSWEEPERS],
X	sweeprot[MAXSWEEPERS];
X
Xint	numguard;
Xint	guardx[MAXGUARDS], guardy[MAXGUARDS], guarddir[MAXGUARDS],
X	guardspeed[MAXGUARDS], guardphase[MAXGUARDS], guardtime[MAXGUARDS];
X
Xint	keyx, keyy, keyalive, keytimer;
Xint	doorx, doory, indoor;
X
X/*	update does all the object updating
X*/
Xupdate()
X{
X	update_player();
X	update_fireballs();
X	update_sweepers();
X	update_guards();
X}
X
X/*	update_player updates the player
X*/
Xupdate_player()
X{
X	register int	flags;
X
X	if(dead) {
X		deadtimer--;
X		if(!deadtimer) game_over();
X		return;
X	}
X	if(waiting) {
X		waiting--;
X		score_bonus();
X		if(waiting == 0) {
X			leveldone = 1;
X			level++;
X			oldscore = -1;
X			oldlevel = -1;
X		}
X		return;
X	}
X	if(exploded > -1) {
X		explodetimer--;
X		if(explodetimer == 0) {
X			explodetimer = EXPLODETIME;
X			exploded++;
X			if(exploded >= EXPLODEFRAMES) {
X				death();
X			}
X		}
X		return;
X	}
X	nx = plx + PLAYERSPEED * playerdir;
X	ny = ply + playervert;
X	if(playerfuel <= 0) burn = 0;
X	playervert += GRAVITY + THRUST * burn;
X	playerfuel = playerfuel - BURNCOST * burn;
X	if(playervert > DOWNSPEED) playervert = DOWNSPEED;
X	if(playervert < UPSPEED) playervert = UPSPEED;
X	flags = set_in_maze(PLAYERWIDTH / 2);
X	if(flags & WALLDOWN) {
X		walk = 1;
X		if(playervert > 0) playervert = 0;
X	} else {
X		walk = 0;
X	}
X	if(flags & WALLUP) {
X		if(playervert < 0) playervert = 0;
X	}
X	plx = nx;
X	ply = ny;
X	if(!burn && walk && (playerdir != 0)) {
X		playerphase += playerdir;
X		if(playerphase > FACERIGHT - 1) playerphase = FACEFRONT + 1;
X		if(playerphase < FACELEFT + 1) playerphase = FACEFRONT - 1;
X		if((playerdir == 1) && (playerphase < FACEFRONT))
X			playerphase = FACEFRONT;
X		if((playerdir == -1) && (playerphase > FACEFRONT))
X			playerphase = FACEFRONT;
X	} else playerphase = (playerdir + 1) * FACEFRONT;
X	if((plx > doorx - 5) && (plx < doorx + 5) && (ply < doory + 5) &&
X		(ply > doory - 5) && walk) indoor = 1;
X	else indoor = 0;
X}
X
X/*	update_fireballs updates all the fireballs
X*/
Xupdate_fireballs()
X{
X	register int	i, flags;
X
X	for(i=0; i<numfire; i++) {
X		nx = firex[i] + firedx[i];
X		ny = firey[i] + firedy[i];
X		flags = set_in_maze(FIREWIDTH / 2);
X		if(flags & WALLRIGHT) if(firedx[i] > 0) firedx[i] = -firedx[i];
X		if(flags & WALLLEFT) if(firedx[i] < 0) firedx[i] = -firedx[i];
X		if(flags & WALLDOWN) if(firedy[i] > 0) firedy[i] = -firedy[i];
X		if(flags & WALLUP) if(firedy[i] < 0) firedy[i] = -firedy[i];
X		firex[i] = nx;
X		firey[i] = ny;
X		firephase[i] = random() % FIREPHASES;
X	}
X}
X
X/*	update_guards updates all the guards
X*/
Xupdate_guards()
X{
X	register int	i, dir, x, y, dx, dy, sp;
X
X	for(i=0; i<numguard; i++) {
X		guardtime[i]++;
X		if(guardtime[i] == 10) {
X			guardtime[i] = 0;
X			guardphase[i] = random() % GUARDPHASES;
X		}
X		dx = guardx[i] % mazescale;
X		dy = guardy[i] % mazescale;
X		sp = guardspeed[i] / 2 + 1;
X		if((dx > mazescale / 2 - sp) && (dx < mazescale / 2 + sp) &&
X			(dy > mazescale / 2 - sp) && (dy < mazescale / 2 + sp)) {
X				x = guardx[i] / mazescale;
X				y = guardy[i] / mazescale;
X				guardx[i] = x * mazescale + mazescale / 2;
X				guardy[i] = y * mazescale + mazescale / 2;
X				do {
X					dir = random() % 4;
X				} while((walldir[dir] & maze[x][y]) ||
X						((walldir[dir] == oppdir[guarddir[i]]) &&
X						!(maze[x][y] == ((WALLUP|WALLDOWN|WALLLEFT|WALLRIGHT)
X						& ~(walldir[dir])))));
X				guarddir[i] = dir;
X		}
X		guardx[i] += guardspeed[i] * xdir[guarddir[i]];
X		guardy[i] += guardspeed[i] * ydir[guarddir[i]];
X	}
X}
X
X/*	update_sweepers updates all the sweepers
X*/
Xupdate_sweepers()
X{
X	register int	i, flags;
X
X	for(i=0; i<numsweep; i++) {
X		sweepphase[i] += sweeprot[i];
X		if(sweepphase[i] == SWEEPERPHASES) sweepphase[i] = 0;
X		if(sweepphase[i] < 0) sweepphase[i] = SWEEPERPHASES - 1;
X		nx = sweepx[i];
X		ny = sweepy[i];
X		if(!(maze[nx / mazescale][ny / mazescale] & walldir[sweepfloor[i]])) {
X			if(xdir[sweepfloor[i]] != 0) {
X				nx = (nx / mazescale + xdir[sweepfloor[i]]) * mazescale +
X						mazescale / 2 - xdir[sweepfloor[i]] * mazescale / 2;
X			}
X			if(ydir[sweepfloor[i]] != 0) {
X			ny = (ny / mazescale + ydir[sweepfloor[i]]) * mazescale +
X					mazescale / 2 - ydir[sweepfloor[i]] * mazescale / 2;
X			}
X			if(sweeprot[i] == 1) increment_sweepdir(i);
X			else decrement_sweepdir(i);
X		}
X		nx += xdir[sweepdir[i]] * sweepspeed[i];
X		ny += ydir[sweepdir[i]] * sweepspeed[i];
X		flags = set_in_maze(SWEEPERWIDTH / 2);
X		if(flags & WALLRIGHT) {
X			if(sweepdir[i] == 1) {
X				if(sweepfloor[i] == 2) decrement_sweepdir(i);
X				else increment_sweepdir(i);
X			}
X		}
X		if(flags & WALLLEFT) {
X			if(sweepdir[i] == 3) {
X				if(sweepfloor[i] == 0) decrement_sweepdir(i);
X				else increment_sweepdir(i);
X			}
X		}
X		if(flags & WALLUP) {
X			if(sweepdir[i] == 0) {
X				if(sweepfloor[i] == 1) decrement_sweepdir(i);
X				else increment_sweepdir(i);
X			}
X		}
X		if(flags & WALLDOWN) {
X			if(sweepdir[i] == 2) {
X				if(sweepfloor[i] == 3) decrement_sweepdir(i);
X				else increment_sweepdir(i);
X			}
X		}
X		sweepx[i] = nx;
X		sweepy[i] = ny;
X	}
X}
X
X/*	decrement_sweepdir does a circular decrement on sweeper i's direction
X*/
Xdecrement_sweepdir(i)
Xint i;
X{	
X	sweepdir[i]--;
X	if(sweepdir[i] < 0) sweepdir[i] = 3;
X	sweepfloor[i]--;
X	if(sweepfloor[i] < 0) sweepfloor[i] = 3;
X}
X
X/*	increment_sweepdir does a circular increment on sweeper i's direction
X*/
Xincrement_sweepdir(i)
Xint i;
X{	
X	sweepdir[i]++;
X	if(sweepdir[i] > 3) sweepdir[i] = 0;
X	sweepfloor[i]++;
X	if(sweepfloor[i] > 3) sweepfloor[i] = 0;
X}
END_OF_FILE
if test 5977 -ne `wc -c <'update.c'`; then
    echo shar: \"'update.c'\" unpacked with wrong size!
fi
# end of 'update.c'
fi
echo shar: End of archive 3 \(of 4\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
