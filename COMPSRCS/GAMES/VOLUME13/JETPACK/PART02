Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i074:  jetpack - an arcade action game for X, Part02/04
Message-ID: <2646@master.CNA.TEK.COM>
Date: 23 Mar 92 22:31:55 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1868
Approved: billr@saab.CNA.TEK.COM

Submitted-by: meb2@cec2.wustl.edu (Mark Edward Bradley)
Posting-number: Volume 13, Issue 74
Archive-name: jetpack/Part02
Environment: X11, Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 4)."
# Contents:  Makefile.sample bitmap.c copyright.h draw.c message.c
#   scores.c
# Wrapped by billr@saab on Mon Mar 23 14:29:26 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile.sample' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.sample'\"
else
echo shar: Extracting \"'Makefile.sample'\" \(10733 characters\)
sed "s/^X//" >'Makefile.sample' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.51 89/12/12 12:37:30 jim Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X###########################################################################
X# Makefile generated from "Imake.tmpl" and </tmp/IIf.a05645>
X# $XConsortium: Imake.tmpl,v 1.77 89/12/18 17:01:37 jim Exp $
X#
X# Platform-specific parameters may be set in the appropriate .cf
X# configuration files.  Site-wide parameters may be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor doesn't define any unique symbols, you'll need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make Makefile", "make Makefiles", or "make World").
X#
X# If you absolutely can't get imake to work, you'll need to set the
X# variables at the top of each Makefile as well as the dependencies at the
X# bottom (makedepend will do this automatically).
X#
X
X###########################################################################
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.38 89/12/23 16:10:10 jim Exp $
X# operating system:  SunOS 4.1.1
X
X###########################################################################
X# site-specific configuration parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.21 89/12/06 11:46:50 jim Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar cq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X               RM = rm -f
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0664
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X          DESTDIR =
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS =
X      COMPATFLAGS =
X
X      ALLINCLUDES = $(STD_INCLUDES) $(TOP_INCLUDES) $(INCLUDES) $(EXTRA_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(PROTO_DEFINES) $(DEFINES) $(COMPATFLAGS)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)
X   LDCOMBINEFLAGS = -X -r
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X###########################################################################
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X###########################################################################
X# X Window System make variables; this need to be coordinated with rules
X# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X          PATHSEP = /
X        USRLIBDIR = $(DESTDIR)/usr/lib
X           BINDIR = $(DESTDIR)/usr/bin/X11
X          INCROOT = $(DESTDIR)/usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = $(DESTDIR)/usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           AWMDIR = $(LIBDIR)/awm
X           TWMDIR = $(LIBDIR)/twm
X           GWMDIR = $(LIBDIR)/gwm
X          MANPATH = $(DESTDIR)/usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X           MANDIR = $(MANSOURCEPATH)n
X        LIBMANDIR = $(MANSOURCEPATH)3
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X
X        SOXLIBREV = 4.2
X          SOXTREV = 4.0
X         SOXAWREV = 4.0
X        SOOLDXREV = 4.0
X         SOXMUREV = 4.0
X        SOXEXTREV = 4.0
X
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X            FONTC = bdftosnf
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier.sh
X
X        CONFIGSRC = $(TOP)/config
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X     MKFONTDIRSRC = $(FONTSRC)/mkfontdir
X     EXTENSIONSRC = $(TOP)/extensions
X
X  DEPEXTENSIONLIB = $(USRLIBDIR)/libXext.a
X     EXTENSIONLIB =  -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X
X        DEPXMULIB =
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB =
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB =
X           XAWLIB = -lXaw
X
X LINTEXTENSIONLIB = $(USRLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(USRLIBDIR)/llib-lX11.ln
X          LINTXMU = $(USRLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(USRLIBDIR)/llib-lXt.ln
X          LINTXAW = $(USRLIBDIR)/llib-lXaw.ln
X
X        XWLIBSRC = $(CONTRIBSRC)/toolkits/Xw
X        DEPXWLIB = $(USRLIBDIR)/libXw.a
X        XWLIB =  -lXw
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X###########################################################################
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.67 89/12/18 17:14:15 jim Exp $
X
X###########################################################################
X# start of Imakefile
X
X	SRCS = bitmap.c bonus.c collision.c demo.c draw.c erase.c events.c\
X	 gameover.c initx.c main.c maze.c message.c normal.c quitx.c scores.c\
X	 setinmaze.c setup.c special.c time.c update.c windowx.c
X	OBJS = bitmap.o bonus.o collision.o demo.o draw.o erase.o events.o\
X	 gameover.o initx.o main.o maze.o message.o normal.o quitx.o scores.o\
X	 setinmaze.o setup.o special.o time.o update.o windowx.o
X
X	PROGRAMS = jetpack
X
X	DESTDIR = /usrd/s/m/meb2
X
X# These defines override the template defaults. Trash em if you want to
X# use the template locations
X	USRLIBDIR = $(DESTDIR)/lib/jetpack
X	BINDIR = $(DESTDIR)/bin
X	MANPATH = $(DESTDIR)/man
X	MANDIR = $(MANSOURCEPATH)1
X	TOP_INCLUDES =
X	DEPXLIB =
X	EXTRA_LIBRARIES = $(XLIB)
X
X# I like my programs optimized, stripped, and setuid. Do what you like.
X	INSTPGMFLAGS = $(INSTUIDFLAGS) -s
X	CDEBUGFLAGS = -O4
X
X# Since my programs are setuid, I make the data files readable only by me.
X	INSTDATFLAGS = -m 0600
X
X# These defines are needed by jetpack. Delete the -DBLIT if you don't want
X# the game to do all the drawing to an offscreen pixmap. (This is good for
X# machines that don't have hardware blitting -- if you have an xterm or a
X# graphics workhorse, leave it in, there will be no flicker)
X	DEFINES = -DBLIT -DSCOREPATH=\"$(SCOREFILE)\" -DLEVELPATH=\"$(LEVELFILE)\"
X
X# The score file can be any name you like, just make sure the directory
X# it's supposed to reside in exists, or jetpack will start creating score
X# files in the directories it is run from. Same for the level files, only
X# the filename you give here is only a prefix -- the complete filename has
X# the level number appended to it.
X	SCOREFILE = $(USRLIBDIR)/jetpack.scores
X	LEVELFILE = $(USRLIBDIR)/jetpack.lev
X
X PROGRAM = jetpack
X
Xall:: jetpack
X
Xjetpack: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xinstall:: jetpack
X	$(INSTALL) -c $(INSTPGMFLAGS)   jetpack $(BINDIR)
X
Xinstall.man:: jetpack.man
X	$(INSTALL) -c $(INSTMANFLAGS) jetpack.man $(MANDIR)/jetpack.n
X
Xdepend::
X	$(DEPEND) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
Xdepend::
X	$(DEPEND) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xinstall:: levels/000
X	$(INSTALL) -c $(INSTDATFLAGS) levels/000 $(LEVELFILE)000
X
X# oops, I can't figure how to override the template default to install the
X# man page as jetpack.1, so I install both and remove the bad one.
Xinstall.man:: jetpack.man
X	$(INSTALL) -c $(INSTMANFLAGS) jetpack.man $(MANDIR)/jetpack.1
X	@rm -f $(MANDIR)/jetpack.n
X
X###########################################################################
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) \#*
X
XMakefile::
X	-@if [ -f Makefile ]; then \
X	echo "	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak"; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
X###########################################################################
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X###########################################################################
X# dependencies generated by makedepend
X
END_OF_FILE
if test 10733 -ne `wc -c <'Makefile.sample'`; then
    echo shar: \"'Makefile.sample'\" unpacked with wrong size!
fi
# end of 'Makefile.sample'
fi
if test -f 'bitmap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmap.c'\"
else
echo shar: Extracting \"'bitmap.c'\" \(10333 characters\)
sed "s/^X//" >'bitmap.c' <<'END_OF_FILE'
X/*	bitmap.c : function to create bitmaps used in jetpack
X*/
X
X#include "copyright.h"
X#include "defs.h"
X#include "bitmap.h"
X
X/*	all the pixmaps of various objects.
X*/
XPixmap	playerpix[PLAYERPHASES], burnpix[BURNDIRECTIONS];
XPixmap	firepix[FIREPHASES], sweeperpix[SWEEPERPHASES],
X		guardpix[GUARDDIRECTIONS][GUARDPHASES];
XPixmap	explodepix[EXPLODEFRAMES];
XPixmap	doorpix[DOORFRAMES];
XPixmap	fuelpix, keypix;
XPixmap	extramanpix;
X
X/*	These arrays hold the color names for each part of each bitmap.
X	They make the pixmap creation code more modifiable.
X*/
Xint	playercolor[PLAYERPARTS] = { CBLUE, CGREY };
Xint	burncolor[BURNPARTS] = { CRED, CYELLOW };
Xint	firecolor[FIREPARTS] = { CRED, CYELLOW };
Xint	sweepcolor[SWEEPERPARTS] = { CGREEN, CGREY, CWHITE };
Xint	guardcolor[GUARDPARTS] = { CGREY, CYELLOW };
Xint	guardflamecolor[GUARDFLAMEPARTS] = { CRED, CYELLOW };
Xint	guardlightcolor = CRED;
Xint	explodecolor = CRED;
Xint	skelcolor = CWHITE;
Xint	fuelcolor[FUELPARTS] = { CORANGE, CRED, CGREY, CWHITE };
Xint	keycolor[KEYPARTS] = { CYELLOW };
Xint	doorcolor[DOORFRAMES][DOORPARTS] = {{ CWHITE }, { CGREY }};
Xint extramancolor = CBLUE;
X
Xset_up_bitmaps()
X{
X	/*	first-stage pixmaps -- each different colored part must be created
X		from a mono bitmap, and then laid atop each other to make the
X		final multi-color pixmap.
X	*/
X	Pixmap playerbit[PLAYERPHASES][PLAYERPARTS];
X	Pixmap burnbit[BURNDIRECTIONS][BURNPARTS];
X	Pixmap firebit[FIREPHASES][FIREPARTS];
X	Pixmap sweeperbit[SWEEPERPHASES][SWEEPERPARTS];
X	Pixmap guardbit[GUARDPARTS];
X	Pixmap guardlightbit[GUARDLIGHTS];
X	Pixmap guardflamebit[GUARDDIRECTIONS][GUARDFLAMEPARTS];
X	Pixmap explodebit[EXPLODEFRAMES];
X	Pixmap skelbit[EXPLODEFRAMES];
X	Pixmap doorbit[DOORFRAMES][DOORPARTS];
X	Pixmap fuelbit[FUELPARTS];
X	Pixmap keybit[KEYPARTS];
X	Pixmap extramanbit;
X
X	int	i, j, k, g[GUARDLIGHTS];
X
X	/*	Each of the following sections essentially does this:
X			create and erase the main pixmap
X			create all the secondary pixmaps from bitmap data
X			copy the secondary pixmaps onto the main pixmap with the
X				proper color
X	*/
X
X	/*	Player pixmaps
X	*/
X	for(i=0; i<PLAYERPHASES; i++) {
X		playerpix[i] = XCreatePixmap(display, gamewindow, PLAYERWIDTH,
X										PLAYERHEIGHT, depth);
X		XFillRectangle(display, playerpix[i], ctable[CBLACK].smallgc,
X						0, 0, PLAYERWIDTH, PLAYERHEIGHT);
X		for(j=0; j<PLAYERPARTS; j++) {
X			playerbit[i][j] = XCreateBitmapFromData(display, gamewindow,
X													player_bits[i][j],
X													PLAYERWIDTH,
X													PLAYERHEIGHT);
X			XCopyPlane(display, playerbit[i][j], playerpix[i],
X						ctable[playercolor[j]].smallgc, 0, 0,
X						PLAYERWIDTH, PLAYERHEIGHT, 0, 0, 1);
X		}
X	}
X
X	/*	Pixmaps for the jetpack flame
X	*/
X	for(i=0; i<BURNDIRECTIONS; i++) {
X		burnpix[i] = XCreatePixmap(display, gamewindow, BURNWIDTH,
X									BURNHEIGHT, depth);
X		XFillRectangle(display, burnpix[i], ctable[CBLACK].smallgc,
X						0, 0, BURNWIDTH, BURNHEIGHT);
X		for(j=0; j<BURNPARTS; j++) {
X			burnbit[i][j] = XCreateBitmapFromData(display, gamewindow,
X													burn_bits[i][j],
X													BURNWIDTH,
X													BURNHEIGHT);
X			XCopyPlane(display, burnbit[i][j], burnpix[i],
X						ctable[burncolor[j]].smallgc, 0, 0,
X						BURNWIDTH, BURNHEIGHT, 0, 0, 1);
X		}
X	}
X
X	/* Wall sweeper pixmaps (very pretty)
X	*/
X	for(i=0; i<SWEEPERPHASES; i++) {
X		sweeperpix[i] = XCreatePixmap(display, gamewindow, SWEEPERWIDTH,
X										SWEEPERHEIGHT, depth);
X		XFillRectangle(display, sweeperpix[i], ctable[CBLACK].smallgc,
X						0, 0, SWEEPERWIDTH, SWEEPERHEIGHT);
X		for(j=0; j<SWEEPERPARTS; j++) {
X			sweeperbit[i][j] = XCreateBitmapFromData(display, gamewindow,
X														sweeper_bits[i][j],
X														SWEEPERWIDTH, 
X														SWEEPERHEIGHT);
X			XCopyPlane(display, sweeperbit[i][j], sweeperpix[i],
X						ctable[sweepcolor[j]].smallgc, 0, 0,
X						SWEEPERWIDTH, SWEEPERHEIGHT, 0, 0, 1);
X		}
X	}
X
X	/*	Fireball pixmaps
X	*/
X	for(i=0; i<FIREPHASES; i++) {
X		firepix[i] = XCreatePixmap(display, gamewindow, FIREWIDTH,
X									FIREHEIGHT, depth);
X		XFillRectangle(display, firepix[i], ctable[CBLACK].smallgc,
X						0, 0, FIREWIDTH, FIREHEIGHT);
X		for(j=0; j<FIREPARTS; j++) {
X			firebit[i][j] = XCreateBitmapFromData(display, gamewindow,
X													fire_bits[i][j],
X													FIREWIDTH,
X													FIREHEIGHT);
X			XCopyPlane(display, firebit[i][j], firepix[i],
X						ctable[firecolor[j]].smallgc, 0, 0,
X						FIREWIDTH, FIREHEIGHT, 0, 0, 1);
X		}
X	}
X
X	/*	Guard pixmaps. These are a little odd because of the random
X		blinking light sequences. There are three sets of lights on the
X		guard, and each can be on or off. This makes 8 different frames,
X		but to cut down on bitmap data, I only made the three light
X		bitmaps rather than 8.
X	*/
X	for(i=0; i<GUARDPARTS; i++) {
X		guardbit[i] = XCreateBitmapFromData(display, gamewindow,
X											guard_bits[i], GUARDWIDTH,
X											GUARDHEIGHT);
X		for(j=0; j<GUARDDIRECTIONS; j++) {
X			guardflamebit[j][i] = XCreateBitmapFromData(display, gamewindow,
X													guard_flame_bits[j][i],
X													GUARDWIDTH,
X													GUARDHEIGHT);
X		}
X	}
X	for(i=0; i<GUARDLIGHTS; i++) {
X		guardlightbit[i] = XCreateBitmapFromData(display, gamewindow,
X											guard_light_bits[i],
X											GUARDWIDTH, GUARDHEIGHT);
X	}
X	for(i=0; i<GUARDDIRECTIONS; i++) {
X		for(j=0; j<GUARDPHASES; j++) {
X			guardpix[i][j] = XCreatePixmap(display, gamewindow, GUARDWIDTH,
X											GUARDHEIGHT, depth);
X			XFillRectangle(display, guardpix[i][j],
X							ctable[CBLACK].smallgc, 0, 0,
X							GUARDWIDTH, GUARDHEIGHT);
X			for(k=0; k<GUARDPARTS; k++) {
X				XCopyPlane(display, guardbit[k], guardpix[i][j],
X							ctable[guardcolor[k]].smallgc,
X							0, 0, GUARDWIDTH, GUARDHEIGHT, 0, 0, 1);
X			}
X			for(k=0; k<GUARDFLAMEPARTS; k++) {
X				XCopyPlane(display, guardflamebit[i][k], guardpix[i][j],
X							ctable[guardflamecolor[k]].smallgc,
X							0, 0, GUARDWIDTH, GUARDHEIGHT, 0, 0, 1);
X			}
X			/*	This initialization will need to be expanded if I add more
X				lights.
X			*/
X			g[2] = j / 4;
X			g[1] = (j % 4) / 2;
X			g[0] = (j % 4) % 2;
X			for(k=0; k<GUARDLIGHTS; k++) {
X				if(g[k]) XCopyPlane(display, guardlightbit[k], guardpix[i][j],
X									ctable[guardlightcolor].smallgc,
X									0, 0, GUARDWIDTH, GUARDHEIGHT, 0, 0, 1);
X			}
X		}
X	}
X
X	/*	Player explosion pixmaps
X	*/
X	for(i=0; i<EXPLODEFRAMES; i++) {
X		explodepix[i] = XCreatePixmap(display, gamewindow, EXPLODEWIDTH,
X										EXPLODEHEIGHT, depth);
X		XFillRectangle(display, explodepix[i], ctable[CBLACK].smallgc,
X						0, 0, EXPLODEWIDTH, EXPLODEHEIGHT);
X		explodebit[i] = XCreateBitmapFromData(display, gamewindow,
X												explode_bits[i],
X												EXPLODEWIDTH,
X												EXPLODEHEIGHT);
X		skelbit[i] = XCreateBitmapFromData(display, gamewindow,
X												skel_bits[i], SKELWIDTH,
X												SKELHEIGHT);
X		XCopyPlane(display, explodebit[i], explodepix[i],
X					ctable[explodecolor].smallgc, 0, 0, EXPLODEWIDTH,
X					EXPLODEHEIGHT, 0, 0, 1);
X		XCopyPlane(display, skelbit[i], explodepix[i],
X					ctable[skelcolor].smallgc, 0, 0, SKELWIDTH,
X					SKELHEIGHT, (EXPLODEWIDTH - SKELWIDTH) / 2,
X					(EXPLODEWIDTH - SKELWIDTH) / 2, 1);
X	}
X
X	/*	Fuel pod pixmap
X	*/
X	fuelpix = XCreatePixmap(display, gamewindow, FUELWIDTH, FUELHEIGHT,
X							depth);
X	XFillRectangle(display, fuelpix, ctable[CBLACK].smallgc, 0, 0,
X					FUELWIDTH, FUELHEIGHT);
X	for(i=0; i<FUELPARTS; i++) {
X			fuelbit[i] = XCreateBitmapFromData(display, gamewindow,
X												fuel_bits[i],
X												FUELWIDTH, FUELHEIGHT);
X			XCopyPlane(display, fuelbit[i], fuelpix,
X						ctable[fuelcolor[i]].smallgc, 0, 0,
X						FUELWIDTH, FUELHEIGHT, 0, 0, 1);
X	}
X
X	/*	Key pixmap
X	*/
X	keypix = XCreatePixmap(display, gamewindow, KEYWIDTH, KEYHEIGHT,
X							depth);
X	XFillRectangle(display, keypix, ctable[CBLACK].smallgc, 0, 0,
X					KEYWIDTH, KEYHEIGHT);
X	for(i=0; i<KEYPARTS; i++) {
X			keybit[i] = XCreateBitmapFromData(display, gamewindow,
X												key_bits[i], KEYWIDTH,
X												KEYHEIGHT);
X			XCopyPlane(display, keybit[i], keypix,
X						ctable[keycolor[i]].smallgc, 0, 0,
X						KEYWIDTH, KEYHEIGHT, 0, 0, 1);
X	}
X
X	/*	Door pixmaps. The only difference in frames is the color, but I
X		wanted it this way in case I want to animate the door in the
X		future.
X	*/
X	for(i=0; i<DOORFRAMES; i++) {
X		doorpix[i] = XCreatePixmap(display, gamewindow, DOORWIDTH,
X									DOORHEIGHT, depth);
X		XFillRectangle(display, doorpix[i], ctable[CBLACK].smallgc,
X						0, 0, DOORWIDTH, DOORHEIGHT);
X		for(j=0; j<DOORPARTS; j++) {
X			doorbit[i][j] = XCreateBitmapFromData(display, gamewindow,
X													door_bits[i][j], 
X													DOORWIDTH, DOORHEIGHT);
X			XCopyPlane(display, doorbit[i][j], doorpix[i],
X						ctable[doorcolor[i][j]].smallgc, 0, 0, 
X						DOORWIDTH, DOORHEIGHT, 0, 0, 1);
X		}
X	}
X
X	/*	Extra player pixmap
X	*/
X	extramanpix = XCreatePixmap(display, gamewindow, EXTRAMANWIDTH,
X								EXTRAMANHEIGHT, depth);
X	XFillRectangle(display, extramanpix, ctable[CBLACK].smallgc,
X					0, 0, EXTRAMANWIDTH, EXTRAMANHEIGHT);
X	extramanbit = XCreateBitmapFromData(display, gamewindow, extraman_bits,
X										EXTRAMANWIDTH, EXTRAMANHEIGHT);
X	XCopyPlane(display, extramanbit, extramanpix,
X				ctable[extramancolor].smallgc,
X				0, 0, EXTRAMANWIDTH, EXTRAMANHEIGHT, 0, 0, 1);
X
X	/*	free all the temporary pixmaps
X	*/
X	for(i=0; i<PLAYERPHASES; i++) {
X		for(j=0; j<PLAYERPARTS; j++) {
X			XFreePixmap(display, playerbit[i][j]);
X		}
X	}
X	for(i=0; i<BURNDIRECTIONS; i++) {
X		for(j=0; j<BURNPARTS; j++) {
X			XFreePixmap(display, burnbit[i][j]);
X		}
X	}
X	for(i=0; i<FIREPHASES; i++) {
X		for(j=0; j<FIREPARTS; j++) {
X			XFreePixmap(display, firebit[i][j]);
X		}
X	}
X	for(i=0; i<SWEEPERPHASES; i++) {
X		for(j=0; j<SWEEPERPARTS; j++) {
X			XFreePixmap(display, sweeperbit[i][j]);
X		}
X	}
X	for(i=0; i<GUARDPARTS; i++) {
X		XFreePixmap(display, guardbit[i]);
X	}
X	for(i=0; i<GUARDLIGHTS; i++) {
X		XFreePixmap(display, guardlightbit[i]);
X	}
X	for(i=0; i<GUARDDIRECTIONS; i++) {
X		for(j=0; j<GUARDFLAMEPARTS; j++) {
X			XFreePixmap(display, guardflamebit[i][j]);
X		}
X	}
X	for(i=0; i<EXPLODEFRAMES; i++) {
X		XFreePixmap(display, explodebit[i]);
X		XFreePixmap(display, skelbit[i]);
X	}
X	for(i=0; i<DOORFRAMES; i++) {
X		for(j=0; j<DOORPARTS; j++) {
X			XFreePixmap(display, doorbit[i][j]);
X		}
X	}
X	for(i=0; i<FUELPARTS; i++) {
X		XFreePixmap(display, fuelbit[i]);
X	}
X	for(i=0; i<KEYPARTS; i++) {
X		XFreePixmap(display, keybit[i]);
X	}
X	XFreePixmap(display, extramanbit);
X}
END_OF_FILE
if test 10333 -ne `wc -c <'bitmap.c'`; then
    echo shar: \"'bitmap.c'\" unpacked with wrong size!
fi
# end of 'bitmap.c'
fi
if test -f 'copyright.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'copyright.h'\"
else
echo shar: Extracting \"'copyright.h'\" \(548 characters\)
sed "s/^X//" >'copyright.h' <<'END_OF_FILE'
X/*
X
X	Copyright (c) 1992 Mark Bradley
X
XThis software may be freely distributed, copied, and used provided that:
X	1)	no modified versions of the software are distributed without
X		express written consent of the author,
X	2)	no fee is charged for distributing, copying, or using the
X		software,
X	3)	this copyright and notice appears in all copies of the software.
X
XNo guarantees are made about the software, and the author disclaims all
Xliability against use of the software.  This software is provided "as is"
Xwithout express or implied warranty.
X
X*/
END_OF_FILE
if test 548 -ne `wc -c <'copyright.h'`; then
    echo shar: \"'copyright.h'\" unpacked with wrong size!
fi
# end of 'copyright.h'
fi
if test -f 'draw.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'draw.c'\"
else
echo shar: Extracting \"'draw.c'\" \(16987 characters\)
sed "s/^X//" >'draw.c' <<'END_OF_FILE'
X/*	draw.c : routines that draw objects in the window
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
XPixmap	drawpixmap;
X
Xchar	fuelstring[20] = "Fuel: ";
Xchar	scorestring[30] = "Score: ";
Xchar	levelstring[40] = "Mazes Completed: ";
Xchar	bonusstring[30] = "Bonus: ";
X
Xint	oldscore = -1, oldlevel = -1;
X
Xint	titley = 130;
X
X/*	draw draws all the objects in the window.
X*/
Xdraw()
X{
X#ifdef	BLIT
X	XCopyArea(display, drawpixmap, gamewindow, ctable[CBLACK].smallgc,
X				0, 0, WINDOWWIDTH, WINDOWHEIGHT, 0, 0);
X    XFillRectangle(display, drawpixmap, ctable[CBLACK].smallgc, 0, 0,
X					WINDOWWIDTH, WINDOWHEIGHT);
X#else
X	erase_draw_zones();
X	init_zones();
X#endif
X
X	draw_info();
X
X	draw_player();
X	draw_maze();
X	draw_door();
X	draw_sweepers();
X	draw_treasures();
X	draw_fireballs();
X	draw_guards();
X	draw_messages();
X}
X
X/*	draw_maze draws the lines of the maze that appear in the window
X*/
Xdraw_maze()
X{
X	register int	i, x1, y1, x2, y2;
X
X	for(i=0; i<mazelcount; i++) {
X		x1 = mazelines[i].x1 - plx + WINDOWWIDTH / 2;
X		y1 = mazelines[i].y1 - ply + WINDOWHEIGHT / 2;
X		x2 = mazelines[i].x2 - plx + WINDOWWIDTH / 2;
X		y2 = mazelines[i].y2 - ply + WINDOWHEIGHT / 2;
X		if(((x1 >= -EDGE) && (y1 >= -EDGE) && (x1 <= WINDOWWIDTH + EDGE) &&
X			(y1 <= WINDOWHEIGHT + EDGE)) || ((x2 >= -EDGE) && (y2 >= -EDGE)
X			&& (x2 <= WINDOWWIDTH + EDGE) && (y2 <= WINDOWHEIGHT + EDGE))) {
X
X#ifdef	BLIT
X				XDrawLine(display, drawpixmap, ctable[CWHITE].smallgc,
X							x1, y1, x2, y2);
X#else
X				set_zone(x1, y1, x2, y2, ZLINE, i);
X#endif
X		}
X	}
X}
X
X/*	draw_player draws the player in the center of the window
X*/
Xdraw_player()
X{
X	if(dead) return;
X	if(exploded > -1) {
X
X#ifdef	BLIT
X		XCopyArea(display, explodepix[exploded], drawpixmap,
X					ctable[CWHITE].smallgc, 0, 0, EXPLODEWIDTH,
X					EXPLODEHEIGHT, WINDOWWIDTH / 2 - EXPLODEWIDTH / 2,
X					WINDOWHEIGHT / 2 - EXPLODEHEIGHT / 2);
X#else
X		set_zone(WINDOWWIDTH / 2 - EXPLODEWIDTH / 2, WINDOWHEIGHT / 2 -
X					EXPLODEHEIGHT / 2, EXPLODEWIDTH, EXPLODEHEIGHT,
X					ZEXPLODE, 0);
X#endif
X
X	} else {
X
X#ifdef	BLIT
X		XCopyArea(display, playerpix[playerphase], drawpixmap,
X					ctable[CWHITE].smallgc, 0, 0, PLAYERWIDTH,
X					PLAYERHEIGHT, WINDOWWIDTH / 2 - PLAYERWIDTH / 2,
X					WINDOWHEIGHT / 2 - PLAYERHEIGHT / 2);
X#else
X		set_zone(WINDOWWIDTH / 2 - PLAYERWIDTH / 2, WINDOWHEIGHT / 2 -
X					PLAYERHEIGHT / 2, PLAYERWIDTH, PLAYERHEIGHT,
X					ZPLAYER, 0);
X#endif
X
X		if(burn)
X
X#ifdef	BLIT
X			XCopyArea(display, burnpix[playerphase / FACEFRONT],
X							drawpixmap, ctable[CWHITE].smallgc, 0, 0,
X							PLAYERWIDTH, PLAYERHEIGHT, WINDOWWIDTH / 2 -
X							PLAYERWIDTH / 2, WINDOWHEIGHT / 2 -
X							PLAYERHEIGHT / 2);
X#else
X		set_zone(WINDOWWIDTH / 2 - PLAYERWIDTH / 2, WINDOWHEIGHT / 2 -
X					PLAYERHEIGHT / 2, PLAYERWIDTH, PLAYERHEIGHT,
X					ZBURN, 0);
X#endif
X
X	}
X}
X
X/*	draw_fireballs draws all the fireballs in the window
X*/
Xdraw_fireballs()
X{
X	register int	i, fx, fy;
X
X	for(i=0; i<numfire; i++) {
X		fx = transx(firex[i], FIREWIDTH);
X		fy = transy(firey[i], FIREHEIGHT);
X		if((fx >= -FIREWIDTH - EDGE) && (fy >= -FIREHEIGHT - EDGE) &&
X			(fx <= WINDOWWIDTH + EDGE) && (fy <= WINDOWHEIGHT + EDGE)) {
X
X#ifdef	BLIT
X			XCopyArea(display, firepix[firephase[i]], drawpixmap,
X						ctable[CWHITE].smallgc, 0, 0, FIREWIDTH,
X						FIREHEIGHT, fx, fy);
X#else
X			set_zone(fx, fy, FIREWIDTH, FIREHEIGHT, ZFIRE, i);
X#endif
X
X		}
X	}
X}
X
X/*	draw_guards draws all the guards in the window
X*/
Xdraw_guards()
X{
X	register int	i, gx, gy;
X
X	for(i=0; i<numguard; i++) {
X		gx = transx(guardx[i], GUARDWIDTH);
X		gy = transy(guardy[i], GUARDHEIGHT);
X		if((gx >= -GUARDWIDTH - EDGE) && (gy >= -GUARDHEIGHT - EDGE) &&
X			(gx <= WINDOWWIDTH + EDGE) && (gy <= WINDOWHEIGHT + EDGE)) {
X
X#ifdef	BLIT
X			XCopyArea(display, guardpix[guarddir[i]][guardphase[i]],
X						drawpixmap, ctable[CWHITE].smallgc, 0, 0,
X						GUARDWIDTH, GUARDHEIGHT, gx, gy);
X#else
X			set_zone(gx, gy, GUARDWIDTH, GUARDHEIGHT, ZGUARD, i);
X#endif
X
X		}
X	}
X}
X
X/*	draw_sweepers draws all the sweepers in the window
X*/
Xdraw_sweepers()
X{
X	register int	i, sx, sy;
X
X	for(i=0; i<numsweep; i++) {
X		sx = transx(sweepx[i], SWEEPERWIDTH);
X		sy = transy(sweepy[i], SWEEPERHEIGHT);
X		if((sx >= -SWEEPERWIDTH - EDGE) && (sy >= -SWEEPERHEIGHT - EDGE) &&
X			(sx <= WINDOWWIDTH + EDGE) && (sy <= WINDOWHEIGHT + EDGE)) {
X
X#ifdef	BLIT
X			XCopyArea(display, sweeperpix[sweepphase[i]], drawpixmap,
X						ctable[CWHITE].smallgc, 0, 0, SWEEPERWIDTH,
X						SWEEPERHEIGHT, sx, sy);
X#else
X			set_zone(sx, sy, SWEEPERWIDTH, SWEEPERHEIGHT, ZSWEEP, i);
X#endif
X
X		}
X	}
X}
X
X/*	draw_treasures draws the key and fuel pods in the window
X*/
Xdraw_treasures()
X{
X	register int	i, tx, ty, width;
X
X	for(i=0; i<numfuel; i++) {
X		if(fuelalive[i]) {
X			tx = transx(fuelx[i], FUELWIDTH);
X			ty = transy(fuely[i], FUELHEIGHT);
X			if((tx >= -FUELWIDTH - EDGE) && (ty >= -FUELHEIGHT - EDGE) &&
X				(tx <= WINDOWWIDTH + EDGE) && (ty <= WINDOWHEIGHT + EDGE)) {
X
X#ifdef	BLIT
X				XCopyArea(display, fuelpix, drawpixmap,
X							ctable[CWHITE].smallgc, 0, 0, FUELWIDTH,
X							FUELHEIGHT, tx, ty);
X#else
X				set_zone(tx, ty, FUELWIDTH, FUELHEIGHT, ZFUEL, i);
X#endif
X
X			}
X		} else if(fueltimer[i]) {
X			tx = transx(fuelx[i], FUELWIDTH);
X			ty = transy(fuely[i], FUELHEIGHT);
X			width = XTextWidth(fontinfo,"100",3) / 2;
X
X#ifdef	BLIT
X			XDrawString(display, drawpixmap,
X						ctable[CGREEN].smallgc, tx + FUELWIDTH / 2
X						- width, ty + FUELHEIGHT / 2,
X						"100", 3);
X#else
X			set_zone(tx + FUELWIDTH / 2 - width, ty + FUELHEIGHT / 2 -
X						fontinfo->ascent, width * 2, fontinfo->ascent +
X						fontinfo->descent, ZFUEL, i);
X#endif
X
X			fueltimer[i]--;
X		}
X	}
X	if(keyalive) {
X		tx = transx(keyx, KEYWIDTH);
X		ty = transy(keyy, KEYHEIGHT);
X		if((tx >= -KEYWIDTH - EDGE) && (ty >= -KEYHEIGHT - EDGE) &&
X			(tx <= WINDOWWIDTH + EDGE) && (ty <= WINDOWHEIGHT + EDGE)) {
X
X#ifdef	BLIT
X			XCopyArea(display, keypix, drawpixmap,
X						ctable[CWHITE].smallgc, 0, 0, KEYWIDTH,
X						KEYHEIGHT, tx, ty);
X#else
X			set_zone(tx, ty, KEYWIDTH, KEYHEIGHT, ZKEY, 0);
X#endif
X
X		}
X	} else if(keytimer) {
X		tx = transx(keyx, KEYWIDTH);
X		ty = transy(keyy, KEYHEIGHT);
X		width = XTextWidth(fontinfo,"500",3) / 2;
X
X#ifdef	BLIT
X		XDrawString(display, drawpixmap, ctable[CGREEN].smallgc,
X					tx + KEYWIDTH / 2 - width, ty + KEYHEIGHT / 2,
X					"500", 3);
X#else
X		set_zone(tx + KEYWIDTH / 2 - width, ty + KEYHEIGHT / 2 -
X					fontinfo->ascent, width * 2, fontinfo->ascent +
X					fontinfo->descent, ZKEY, 0);
X#endif
X
X		keytimer--;
X	}
X}
X
X/*	draw_door draws the door in the window
X*/
Xdraw_door()
X{
X	register int	dx, dy, phase;
X
X	dx = transx(doorx, DOORWIDTH);
X	dy = transy(doory, DOORHEIGHT);
X	if((dx >= -DOORWIDTH - EDGE) && (dy >= -DOORHEIGHT - EDGE) &&
X		(dx <= WINDOWWIDTH + EDGE) && (dy <= WINDOWHEIGHT + EDGE)) {
X		phase = indoor;
X		if(indoor && (exploded > -1)) phase = 0;
X
X#ifdef	BLIT
X		XCopyArea(display, doorpix[phase], drawpixmap,
X					ctable[CWHITE].smallgc, 0, 0, DOORWIDTH,
X					DOORHEIGHT, dx, dy - (DOORHEIGHT - PLAYERHEIGHT) / 2);
X#else
X		set_zone(dx, dy - (DOORHEIGHT - PLAYERHEIGHT) / 2, DOORWIDTH,
X					DOORHEIGHT, ZDOOR, 0);
X#endif
X
X	}
X}
X
X/*	transx translates an x coordinate against the player's x coordinate to
X	fit it properly in the window.
X*/
Xint	transx(x, off)
Xint	x, off;
X{
X	return(x - plx + WINDOWWIDTH / 2 - off / 2);
X}
X
X/*	transy translates an y coordinate against the player's y coordinate to
X	fit it properly in the window.
X*/
Xint	transy(y, off)
Xint	y, off;
X{
X	return(y - ply + WINDOWHEIGHT / 2 - off / 2);
X}
X
X/*	refresh_info redraws the info window
X*/
Xrefresh_info()
X{
X	register int	i;
X
X	XClearWindow(display, infowindow);
X	if(!keyalive) XCopyArea(display, keypix, infowindow,
X							ctable[CWHITE].smallgc, 0, 0, KEYWIDTH,
X							KEYHEIGHT, WINDOWWIDTH / 2 - 10 - KEYWIDTH, 5);
X	for(i=0; i<men; i++) {
X		XCopyArea(display, extramanpix, infowindow, ctable[CWHITE].smallgc,
X					0, 0, EXTRAMANWIDTH, EXTRAMANHEIGHT, WINDOWWIDTH - (i +
X					1) * (EXTRAMANWIDTH + 3), 5);
X	}
X	if(gameover) XDrawString(display,infowindow, ctable[CRED].biggc,
X								100,30,"DEMO",strlen("DEMO"));
X	oldlevel = -1;
X	oldscore = -1;
X	draw_info();
X}
X
X/*	draw_messages draws any active messages in the window
X*/
Xdraw_messages()
X{
X	register int	tmpcolor;
X
X	if(messagetime != 0) {
X
X#ifdef	BLIT
X		if(messagecolor == CBLACK)
X			tmpcolor = random() % (NCOLORS-1) + 1;
X		else tmpcolor = messagecolor;
X		XDrawString(display, drawpixmap,
X					ctable[tmpcolor].smallgc, messagex, messagey,
X					messagestring, messagelength);
X#else
X		set_zone(messagex, messagey - fontinfo->ascent, messagewidth,
X					fontinfo->ascent + fontinfo->descent, ZSMESS, 0);
X#endif
X
X		messagetime--;
X	}
X	if(bigmessagetime != 0) {
X
X#ifdef	BLIT
X		if(bigmessagecolor == CBLACK)
X			tmpcolor = random() % (NCOLORS-1) + 1;
X		else tmpcolor = bigmessagecolor;
X		XDrawString(display, drawpixmap,
X					ctable[tmpcolor].biggc,
X					bigmessagex, bigmessagey,
X					bigmessagestring, bigmessagelength);
X#else
X		set_zone(bigmessagex, bigmessagey - bigfontinfo->ascent,
X					bigmessagewidth, bigfontinfo->ascent +
X					bigfontinfo->descent, ZBMESS, 0);
X#endif
X
X		bigmessagetime--;
X	}
X}
X
X/*	draw_info draws the stuff in the info window that needs to be updated
X	frequently
X*/
Xdraw_info()
X{
X	int	tmp;
X
X	sprintf(fuelstring, "Fuel: %04d", playerfuel);
X	if(playerfuel < 100) tmp = CRED;
X	else if(playerfuel < 500) tmp = CYELLOW;
X	else tmp = CGREEN;
X	XDrawImageString(display, infowindow, ctable[tmp].smallgc,
X						10, 10, fuelstring, strlen(fuelstring));
X	if(level != oldlevel) {
X		sprintf(levelstring, "Level: %03d", level);
X		XDrawImageString(display, infowindow, ctable[CWHITE].smallgc,
X							10, 20 + fontinfo->ascent + fontinfo->descent,
X							levelstring, strlen(levelstring));
X		oldlevel = level;
X	}
X	sprintf(bonusstring, "Bonus: %06d", bonus);
X	XDrawImageString(display, infowindow, ctable[CWHITE].smallgc,
X						WINDOWWIDTH / 2, 10, bonusstring,
X						strlen(bonusstring));
X	if(score != oldscore) {
X		sprintf(scorestring, "Score: %09d", score);
X		XDrawImageString(display, infowindow, ctable[CWHITE].smallgc,
X							WINDOWWIDTH / 2, 20 + fontinfo->ascent +
X							fontinfo->descent, scorestring,
X							strlen(scorestring));
X		oldscore = score;
X	}
X}
X
X/*  place_string draws a centered string on the title screen
X*/
Xplace_string(s, y, color, info)
Xchar        *s;
Xint         y, color;
XXFontStruct *info;
X{
X    register int    length, width;
X
X    length = strlen(s);
X    width = XTextWidth(info, s, length);
X
X#ifdef  BLIT
X    if(info == bigfontinfo) {
X        XDrawString(display, drawpixmap, ctable[color].biggc,
X                    WINDOWWIDTH / 2 - width / 2, y, s, length);
X    } else {
X        XDrawString(display, drawpixmap, ctable[color].smallgc,
X                    WINDOWWIDTH / 2 - width / 2, y, s, length);
X    }
X#else
X    if(info == bigfontinfo) {
X        XDrawString(display, gamewindow, ctable[color].biggc,
X                    WINDOWWIDTH / 2 - width / 2, y, s, length);
X    } else {
X        XDrawString(display, gamewindow, ctable[color].smallgc,
X                    WINDOWWIDTH / 2 - width / 2, y, s, length);
X    }
X#endif
X
X}
X
X/*  title_draw updates and draws the title screen
X*/
Xtitle_draw()
X{
X    register int    i, j;
X
X    update_fireballs();
X    update_sweepers();
X    update_guards();
X
X#ifdef  BLIT
X    XFillRectangle(display, drawpixmap, ctable[CBLACK].smallgc, 0,
X                    titley, WINDOWWIDTH, WINDOWHEIGHT - titley);
X    XCopyArea(display, scorepixmap, drawpixmap, ctable[CWHITE].smallgc,
X                0, 0, SCOREWIDTH, SCOREHEIGHT, SCOREX, SCOREY);
X#else
X    XCopyArea(display, scorepixmap, gamewindow, ctable[CBLACK].smallgc,
X                0, 0, SCOREWIDTH, SCOREHEIGHT, SCOREX, SCOREY);
X    erase_draw_zones();
X    init_zones();
X#endif
X
X    draw_maze();
X    draw_guards();
X    draw_sweepers();
X    draw_fireballs();
X    /*  make the player image do random things
X    */
X    if(random() % 30 == 0) burn = 1 - burn;
X    if(random() % 30 == 0) playerdir = random() % 3 - 1;
X    if(!burn && (playerdir != STOP)) {
X        playerphase += playerdir;
X        if(playerphase > FACERIGHT - 1) playerphase = FACEFRONT + 1;
X        if(playerphase < FACELEFT + 1) playerphase = FACEFRONT - 1;
X        if((playerdir == GOLEFT) && (playerphase < FACEFRONT))
X			playerphase = FACEFRONT;
X        if((playerdir == GORIGHT) && (playerphase > FACEFRONT))
X			playerphase = FACEFRONT;
X    } else playerphase = (playerdir+1) * FACEFRONT;
X
X#ifdef  BLIT
X    XCopyArea(display, playerpix[playerphase], drawpixmap,
X                ctable[CWHITE].smallgc, 0, 0, PLAYERWIDTH,
X                PLAYERHEIGHT, WINDOWWIDTH / 2 - PLAYERWIDTH / 2, titley);
X    if(burn) XCopyArea(display, burnpix[playerphase / FACEFRONT],
X                        drawpixmap, ctable[CWHITE].smallgc, 0, 0,
X                        PLAYERWIDTH, PLAYERHEIGHT, WINDOWWIDTH / 2 -
X                        PLAYERWIDTH / 2, titley);
X#else
X    XFillRectangle(display, gamewindow, ctable[CBLACK].smallgc,
X                    WINDOWWIDTH / 2 - PLAYERWIDTH / 2, titley, PLAYERWIDTH,
X                    PLAYERHEIGHT);
X    XCopyArea(display, playerpix[playerphase], gamewindow,
X                ctable[CWHITE].smallgc, 0, 0, PLAYERWIDTH,
X                PLAYERHEIGHT, WINDOWWIDTH / 2 - PLAYERWIDTH / 2, titley);
X    if(burn) XCopyArea(display, burnpix[playerphase / FACEFRONT],
X                        gamewindow, ctable[CWHITE].smallgc, 0, 0,
X                        PLAYERWIDTH, PLAYERHEIGHT, WINDOWWIDTH / 2 -
X                        PLAYERWIDTH / 2, titley);
X#endif
X}
X
X/*  title_refresh draws the title screen stuff that doesn't have to be
X    continuously updated
X*/
Xtitle_refresh()
X{
X    char            scstring[30];
X    register int    y, width;
X
X    y = 5 + bigfontinfo->ascent;
X    place_string("Jetpack", y, CYELLOW, bigfontinfo);
X    y += bigfontinfo->descent + 5 + fontinfo->ascent;
X    place_string("By Mark Bradley", y, CBLUE, fontinfo);
X    y += fontinfo->descent + 5 + fontinfo->ascent;
X    place_string("Controls:", y, CWHITE, fontinfo);
X    y += fontinfo->descent + fontinfo->ascent;
X    place_string(
X        "  keypad 4, a, left button : move left                       ",
X        y, CGREEN, fontinfo);
X    place_string(
X        "                                           K : commit suicide",
X        y, CRED, fontinfo);
X    y += fontinfo->descent + fontinfo->ascent;
X    place_string(
X        " keypad 6, d, right button : move right                      ",
X        y, CGREEN, fontinfo);
X    place_string(
X        "                                           p : pause game    ",
X        y, CBLUE, fontinfo);
X    y += fontinfo->descent + fontinfo->ascent;
X    place_string(
X        "               keypad 5, s : stop                            ",
X        y, CRED, fontinfo);
X    place_string(
X        "                                           Q : quit game     ",
X        y, CGREY, fontinfo);
X    y += fontinfo->descent + fontinfo->ascent;
X    place_string(
X        "             center button : fire jetpack                    ",
X        y, CYELLOW, fontinfo);
X    y += fontinfo->descent + 10 + fontinfo->ascent;
X    place_string("Extra Player awarded every 10000 points", y, CGREY,
X                    fontinfo);
X
X#ifdef  BLIT
X    XCopyArea(display, fuelpix, drawpixmap, ctable[CWHITE].smallgc,
X                0, 0, FUELWIDTH, FUELHEIGHT, WINDOWWIDTH / 4 - FUELWIDTH /
X               2, 20 - FUELHEIGHT / 2);
X    XCopyArea(display, keypix, drawpixmap, ctable[CWHITE].smallgc,
X                0, 0, KEYWIDTH, KEYHEIGHT, 3 * (WINDOWWIDTH / 4) -
X                KEYWIDTH / 2, 20 - KEYHEIGHT / 2);
X    width = XTextWidth(fontinfo, "100", 3);
X    XDrawString(display, drawpixmap, ctable[CGREEN].smallgc,
X                WINDOWWIDTH / 4 - width / 2, 20 + FUELHEIGHT / 2 + 5 +
X                fontinfo->ascent, "100", 3);
X    width = XTextWidth(fontinfo, "500", 3);
X    XDrawString(display, drawpixmap, ctable[CGREEN].smallgc,
X                3 * (WINDOWWIDTH / 4) - width / 2, 20 + KEYHEIGHT / 2 +
X                10 + fontinfo->ascent, "500", 3);
X#else
X    XCopyArea(display, fuelpix, gamewindow, ctable[CWHITE].smallgc,
X                0, 0, FUELWIDTH, FUELHEIGHT, WINDOWWIDTH / 4 - FUELWIDTH /
X               2, 20 - FUELHEIGHT / 2);
X    XCopyArea(display, keypix, gamewindow, ctable[CWHITE].smallgc,
X                0, 0, KEYWIDTH, KEYHEIGHT, 3 * (WINDOWWIDTH / 4) -
X                KEYWIDTH / 2, 20 - KEYHEIGHT / 2);
X    width = XTextWidth(fontinfo, "100", 3);
X    XDrawString(display, gamewindow, ctable[CGREEN].smallgc,
X                WINDOWWIDTH / 4 - width / 2, 20 + FUELHEIGHT / 2 + 5 +
X                fontinfo->ascent, "100", 3);
X    width = XTextWidth(fontinfo, "500", 3);
X    XDrawString(display, gamewindow, ctable[CGREEN].smallgc,
X                3 * (WINDOWWIDTH / 4) - width / 2, 20 + KEYHEIGHT / 2 +
X                10 + fontinfo->ascent, "500", 3);
X#endif
X
X    sprintf(scstring, "Last Score: %09d", lastscore);
X    XDrawString(display, infowindow, ctable[CGREY].biggc,
X                WINDOWWIDTH / 2 -
X                XTextWidth(bigfontinfo, scstring, strlen(scstring)) / 2,
X                INFOHEIGHT / 2, scstring, strlen(scstring));
X}
END_OF_FILE
if test 16987 -ne `wc -c <'draw.c'`; then
    echo shar: \"'draw.c'\" unpacked with wrong size!
fi
# end of 'draw.c'
fi
if test -f 'message.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'message.c'\"
else
echo shar: Extracting \"'message.c'\" \(2687 characters\)
sed "s/^X//" >'message.c' <<'END_OF_FILE'
X/*	message.c : routines that implement a message display system
X*/
X
X#include "copyright.h"
X#include "defs.h"
X#include "message.h"
X
Xstruct levelmessage	lmessage[MAXLEVELMESSAGES];
Xint					numlmessage;
X
Xchar	messagestring[MAXMESSAGELENGTH],
X		bigmessagestring[MAXBIGMESSAGELENGTH];
Xint		messagex, messagey, bigmessagex, bigmessagey,
X		messagetime = 0, bigmessagetime = 0,
X		messagecolor, bigmessagecolor,
X		messagelength = 0, bigmessagelength = 0,
X		messagewidth, bigmessagewidth;
X
X/*	message puts a message s on the screen in color for time
X*/
Xmessage(s, color, time)
Xchar	*s;
Xint		color, time;
X{
X	messagecolor = color;
X	messagetime = time;
X	strncpy(messagestring, s, MAXMESSAGELENGTH);
X	messagelength = strlen(messagestring);
X	messagewidth = XTextWidth(fontinfo, messagestring, messagelength);
X	messagey = WINDOWHEIGHT / 5 + 50;
X	messagex = WINDOWWIDTH / 2 - messagewidth / 2;
X}
X
X/*	message puts a big message s on the screen in color for time
X*/
Xbigmessage(s, color, time)
Xchar	*s;
Xint		color, time;
X{
X	bigmessagecolor = color;
X	bigmessagetime = time;
X	strncpy(bigmessagestring, s, MAXBIGMESSAGELENGTH);
X	bigmessagelength = strlen(bigmessagestring);
X	bigmessagewidth = XTextWidth(bigfontinfo, bigmessagestring,
X									bigmessagelength);
X	bigmessagey = WINDOWHEIGHT / 5;
X	bigmessagex = WINDOWWIDTH / 2 - bigmessagewidth / 2;
X}
X
X/*	dumb_message puts up a message to the player when something happens.
X	Called dumb because the procedure is ugly and the messages are mostly
X	snide remarks.
X*/
Xdumb_message(kind)
Xint	kind;
X{
X	register int	opinion, num;
X
X	if(gameover) return;
X	if((messagetime != 0) && (kind != MKILL) && (kind != MSUICIDE) &&
X		(kind != MEXIT)) return;
X	if(exploded > -1) return;
X	if((dumbmessagechance[kind] > 1) &&
X		(random() % (dumbmessagechance[kind]) == 0)) return;
X	opinion = -1;
X	switch(kind) {
X		case MKILL:
X		case MCLOSE:
X		case MSUICIDE:
X		case MQUIT:
X			opinion = 0;
X			break;
X		case MFUEL:
X			if(playerfuel > FUELCAPACITY - FUELINCREMENT) opinion = 0;
X			if(playerfuel < 300) opinion = 1;
X			break;
X		case MKEY:
X			if(playerfuel < 400) {
X				opinion = 2;
X				break;
X			}
X			if(bonus < initbonus / 3) {
X				opinion = 0;
X				break;
X			}
X			if(bonus > (initbonus * 3) / 4) {
X				opinion = 1;
X				break;
X			}
X			opinion = 3;
X			break;
X		case MEXIT:
X			if(bonus == 0) {
X				opinion = 0;
X				break;
X			}
X			if(bonus >  (2 * initbonus) / 3) {
X				opinion = 1;
X				break;
X			}
X			if(bonus < initbonus / 3) {
X				opinion = 2;
X				break;
X			}
X			opinion = 3;
X			break;
X		default:
X			break;
X	}
X	if(opinion == -1) return;
X	num = random() % numdumbmessages[kind][opinion];
X	message(dumbmessage[kind][opinion][num], random() % (NCOLORS - 1) + 1,
X	dumbmessagetime[kind]);
X}
END_OF_FILE
if test 2687 -ne `wc -c <'message.c'`; then
    echo shar: \"'message.c'\" unpacked with wrong size!
fi
# end of 'message.c'
fi
if test -f 'scores.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scores.c'\"
else
echo shar: Extracting \"'scores.c'\" \(9523 characters\)
sed "s/^X//" >'scores.c' <<'END_OF_FILE'
X/*	scores.c : routines that implement and maintain the high scores.
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
X/*	If the scorefile is not externally defined at compile time, the
X	default scorefile is jetpack.scores . However, this means scorefiles
X	will be created in the user's cwd whenever he/she runs the game.
X*/
X#ifndef SCOREPATH
X#define SCOREPATH "jetpack.scores"
X#endif
X
XPixmap	scorepixmap;
X
X#define	MAXHIGHLENGTH	46
X#define MAXNAMELENGTH	21
X
Xint		numhighs;
Xint		highscore[MAXHIGHSCORES];
Xint		highlevel[MAXHIGHSCORES];
Xchar	highstring[MAXHIGHSCORES][MAXHIGHLENGTH];
Xchar	dtext[MAXNAMELENGTH], dialogtime[10];
Xint		scorefd;
XFILE	*scorefile;
XWindow	dialogwindow,dialogstringwindow,dialogbuttonwindow;
Xint		dialogwidth, dialogheight;
X
X/*	open_scores tries to open the score file, and if it can't it tries to
X	create one.
X*/
Xopen_scores()
X{
X	numhighs = 0;
X	scorefd = open(SCOREPATH, O_RDWR);
X	if(scorefd == -1) {
X		scorefd = open(SCOREPATH, O_RDWR | O_CREAT, 0444);
X		if(scorefd == -1) {
X			scorefd = open("jetpack.scores", O_RDWR);
X			if(scorefd == -1) {
X				scorefd = open("jetpack.scores", O_RDWR | O_CREAT, 0444);
X				if(scorefd == -1) {
X					fprintf(stderr,"Jetpack : Couldn't open scorefile.\n");
X					exit(1);
X				} else {
X					flock(scorefd,LOCK_EX);
X					scorefile = fdopen(scorefd,"r+");
X					write_scores();
X					flock(scorefd,LOCK_UN);
X					return;
X				}
X			} else {
X				flock(scorefd,LOCK_EX);
X				scorefile = fdopen(scorefd,"r+");
X				read_scores();
X				flock(scorefd,LOCK_UN);
X				return;
X			}
X		} else {
X			flock(scorefd,LOCK_EX);
X			scorefile = fdopen(scorefd,"r+");
X			write_scores();
X			flock(scorefd,LOCK_UN);
X			return;
X		}
X	} else {
X		flock(scorefd,LOCK_EX);
X		scorefile = fdopen(scorefd,"r+");
X		read_scores();
X		flock(scorefd,LOCK_UN);
X		return;
X	}
X}
X
X/*	close_scores closes the score file.
X*/
Xclose_scores()
X{
X	fclose(scorefile);
X	close(scorefd);
X}
X
X/*	read_scores reads the high score data from the score file. 
X*/
Xread_scores()
X{
X	register int	i;
X
X	rewind(scorefile);
X	fflush(scorefile);
X	fread(&numhighs, sizeof(int), 1, scorefile);
X	for(i=0; i<numhighs; i++) {
X		fread(highstring[i], sizeof(char), MAXHIGHLENGTH - 2, scorefile);
X		fread(highlevel+i, sizeof(int), 1, scorefile);
X		fread(highscore+i, sizeof(int), 1, scorefile);
X		highstring[i][MAXHIGHLENGTH-1] = '\0';
X	}
X	fflush(scorefile);
X}
X
X/*	write_scores writes the high score data into the score file.
X*/
Xwrite_scores()
X{
X	register int	i;
X
X	rewind(scorefile);
X	fflush(scorefile);
X	fwrite(&numhighs, sizeof(int), 1, scorefile);
X	for(i=0; i<numhighs; i++) {
X		fwrite(highstring[i], sizeof(char), MAXHIGHLENGTH - 2, scorefile);
X		fwrite(highlevel+i, sizeof(int), 1, scorefile);
X		fwrite(highscore+i, sizeof(int), 1, scorefile);
X	}
X	fflush(scorefile);
X}
X
X/*	read_new_scores re-reads in the score file info just in case it has
X	been changed.
X*/
Xread_new_scores()
X{
X	flock(scorefd,LOCK_EX);
X	read_scores();
X	flock(scorefd,LOCK_UN);
X	XFillRectangle(display, scorepixmap, ctable[CBLACK].smallgc,
X					0, 0, SCOREWIDTH, SCOREHEIGHT);
X	draw_scores(-1);
X}
X
X/*	check_score checks the score global variable against the high score
X	table, and if it makes it, gets the player's name and saves the new
X	high scores in the file.
X*/
Xcheck_score()
X{
X	register int	i, spot;
X	char			buf[MAXNAMELENGTH];
X
X	spot = 0;
X	flock(scorefd,LOCK_EX);
X	read_scores();
X	flock(scorefd,LOCK_UN);
X	for(i=0; i<numhighs; i++) {
X		if(score > highscore[i]) {
X			get_high_name(buf);
X			spot = 1;
X			break;
X		}
X	}
X	if(spot == 0) {
X		if(numhighs < MAXHIGHSCORES) get_high_name(buf);
X		else return;
X	}
X	flock(scorefd,LOCK_EX);
X	read_scores();
X	for(i=0; i<numhighs; i++) {
X		if(score > highscore[i]) {
X			shift_highs(i);
X			highscore[i] = score;
X			highlevel[i] = level;
X			sprintf(highstring[i], "%-20s     %-3d       %-9d", buf,
X					level, score);
X			write_scores();
X			flock(scorefd,LOCK_UN);
X			return;
X		}
X	}
X	/*	Didn't beat anyone else, but if the scoreboard isn't full, let it
X		in.
X	*/
X	if(numhighs < MAXHIGHSCORES) {
X		highscore[numhighs] = score;
X		highlevel[numhighs] = level;
X		sprintf(highstring[numhighs], "%-20s     %-3d       %-9d", buf,
X				level, score);
X		numhighs++;
X		write_scores();
X		flock(scorefd,LOCK_UN);
X		return;
X	}
X	/* Sorry, you got bumped off while you entered your name */
X}
X
X#define	HIGHTITLE	"Mad Mark's Top Fliers:"
X#define	HIGHTOP		"Name:                    Level:    Score:   "
X
X/*	draw_scores draws the high score table on the scorepixmap. which
X	allows only 5 of the names to be drawn at a time, which keeps things
X	from lagging.
X*/
Xdraw_scores(which)
Xint	which;
X{
X	register int	i, j, length, width, y, first, last;
X
X	length = strlen(HIGHTITLE);
X	width = XTextWidth(bigfontinfo,HIGHTITLE,length);
X	XDrawImageString(display, scorepixmap,
X						ctable[random()%(NCOLORS-1)+1].biggc,
X						SCOREWIDTH / 2 - width / 2, 3 + bigfontinfo->ascent,
X						HIGHTITLE, length);
X	y = bigfontinfo->ascent + bigfontinfo->descent + 3;
X	length = strlen(HIGHTOP);
X	width = XTextWidth(fontinfo,HIGHTOP,length);
X	XDrawString(display, scorepixmap, ctable[CWHITE].smallgc,
X				SCOREWIDTH / 2 - width / 2, y + 3 + fontinfo->ascent,
X				HIGHTOP, length);
X	y += fontinfo->ascent * 2 + fontinfo->descent + 4;
X	if(which == -1) {
X		first = 0;
X		last = MAXHIGHSCORES;
X	} else {
X		first = which * 5;
X		last = which * 5 + 5;
X	}
X	i = y + first * (fontinfo->ascent + fontinfo->descent);
X	for(j=first; ((j<numhighs) && (j<last)); j++) {
X		length = strlen(highstring[j]);
X		width = XTextWidth(fontinfo,highstring[j],length);
X		XDrawImageString(display, scorepixmap,
X							ctable[random()%(NCOLORS-1)+1].smallgc,
X							SCOREWIDTH / 2 - width / 2, i, highstring[j],
X							length);
X		i += fontinfo->ascent + fontinfo->descent;
X	}
X}
X
X/*	shift_highs pushes all the scores from place i down one spot.
X*/
Xshift_highs(i)
Xint	i;
X{
X	int	j;
X
X	for(j=MAXHIGHSCORES-1; j>i; j--) {
X		highscore[j] = highscore[j-1];
X		highlevel[j] = highlevel[j-1];
X		strncpy(highstring[j],highstring[j-1],44);
X	}
X	if(numhighs < MAXHIGHSCORES) numhighs++;
X}
X
X/*	get_high_name brings up a dialog that prompts the player to enter
X	his/her name. The name is stored in buf.
X*/
Xget_high_name(buf)
Xchar	*buf;
X{
X	XEvent					event;
X	register int			j, finished, timer;
X	/*
X	register unsigned long	utimer, usecond;
X	*/
X
X	XMapRaised(display, dialogwindow);
X	XMapRaised(display, dialogstringwindow);
X	XMapRaised(display, dialogbuttonwindow);
X	XFlush(display);
X
X	dtext[0] = '\0';
X	finished = 0;
X	while(!finished) {
X			XNextEvent(display, &event);
X			switch(event.type) {
X				case ConfigureNotify:
X				case Expose:
X				case MapNotify:
X					display_dialog(event.xany.window);
X					break;
X				case ButtonPress:
X					if(event.xbutton.window == dialogbuttonwindow) {
X						XFillRectangle(display, dialogbuttonwindow,
X										ctable[CBLUE].smallgc, 0, 0,
X										50, 30);
X						display_dialog(dialogbuttonwindow);
X						finished = 1;
X					}
X					break;
X				case KeyPress:
X					finished = dialog_key(&event);
X					break;
X			}
X	}
X
X	/*	check to see if there are non-blank characters in the name. If
X		there aren't any, the user is shy, so return "Anonymous"
X	*/
X	for(j=0, finished=0; dtext[j] != '\0'; j++) {
X		if(dtext[j] != ' ') finished = 1;
X	}
X	if(!finished) strncpy(dtext,"Anonymous",20);
X
X	strncpy(buf, dtext, 20);
X
X	/*	unmap the dialog
X	*/
X	XUnmapWindow(display, dialogstringwindow);
X	XUnmapWindow(display, dialogbuttonwindow);
X	XUnmapWindow(display, dialogwindow);
X	XFlush(display);
X}
X
X/*	dialog_key processes keypresses from the dialog
X*/
Xint	dialog_key(event)
XXKeyEvent	*event;
X{
X	int				length, l;
X	char			buf[MAXNAMELENGTH];
X	KeySym			keysym;
X	XComposeStatus	composestatus;
X
X	length = XLookupString(event, buf, MAXNAMELENGTH, &keysym,
X							&composestatus);
X	buf[1] = '\0';
X	l = strlen(dtext);
X	/*	check for printable character
X	*/
X	if((keysym >= ' ') && (keysym <= '~') && (length > 0)) {
X		if((l + strlen(buf)) < MAXNAMELENGTH) {
X			strcat(dtext, buf);
X			display_dialog(dialogstringwindow);
X		}
X	} else {
X		switch(keysym) {
X			/*	delete key
X			*/
X			case XK_BackSpace:
X			case XK_Delete:
X				if(l >= 1) {
X					XClearWindow(display, dialogstringwindow);
X					l--;
X					dtext[l] = '\0';
X					display_dialog(dialogstringwindow);
X					XFlush(display);
X				}
X				break;
X
X			/* return is as good as hitting ok
X			*/
X			case '\n':
X			case XK_Return:
X			case XK_KP_Enter:
X				XFillRectangle(display, dialogbuttonwindow,
X								ctable[CBLUE].smallgc, 0, 0, 50, 30);
X				display_dialog(dialogbuttonwindow);
X				return(1);
X			default:
X				break;
X		}
X	}
X	return(0);
X}
X
X/*	display_dialog draws the part of the dialog specified by w. Also
X	refreshes anything that needs to be.
X*/
Xdisplay_dialog(w)
XWindow	w;
X{
X	if(w == dialogwindow) {
X		XDrawString(display, dialogwindow, ctable[CGREEN].biggc,
X					10, 5 + bigfontinfo->ascent, "You made a high score!",
X					strlen("You made a high score!"));
X		XDrawString(display, dialogwindow, ctable[CBLUE].biggc,
X					10, 10 + bigfontinfo->descent + 2 *
X					bigfontinfo->ascent, "Enter your name:",
X					strlen("Enter your name:"));
X	}
X	if(w == dialogstringwindow)
X		XDrawString(display, dialogstringwindow,
X					ctable[CRED].biggc, 10,
X					5 + bigfontinfo->ascent, dtext, strlen(dtext));
X	if(w == dialogbuttonwindow)
X		XDrawString(display, dialogbuttonwindow,
X					ctable[CWHITE].biggc, 10,
X					5 + bigfontinfo->ascent, "OK", strlen("OK"));
X	if(w == gamewindow) 
X
X#ifdef	BLIT
X		XCopyArea(display, drawpixmap, gamewindow, ctable[CBLACK].smallgc,
X					0, 0, WINDOWWIDTH, WINDOWHEIGHT, 0, 0);
X#else
X		refresh();
X#endif
X
X	if(w == infowindow) refresh_info();
X	XFlush(display);
X}
END_OF_FILE
if test 9523 -ne `wc -c <'scores.c'`; then
    echo shar: \"'scores.c'\" unpacked with wrong size!
fi
# end of 'scores.c'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
