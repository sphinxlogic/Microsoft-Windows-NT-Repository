Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i076:  jetpack - an arcade action game for X, Part04/04
Message-ID: <2648@master.CNA.TEK.COM>
Date: 23 Mar 92 22:32:12 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1609
Approved: billr@saab.CNA.TEK.COM

Submitted-by: meb2@cec2.wustl.edu (Mark Edward Bradley)
Posting-number: Volume 13, Issue 76
Archive-name: jetpack/Part04
Environment: X11, Xlib



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 4)."
# Contents:  ADVERTISEMENT Imakefile bonus.c collision.c events.c
#   gameover.c jetpack.man levels/000 main.c message.h p2.hdr quitx.c
#   setinmaze.c special.c time.c
# Wrapped by billr@saab on Mon Mar 23 14:29:27 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ADVERTISEMENT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ADVERTISEMENT'\"
else
echo shar: Extracting \"'ADVERTISEMENT'\" \(874 characters\)
sed "s/^X//" >'ADVERTISEMENT' <<'END_OF_FILE'
XJetpack was written by Mark Bradley
X
XI am a Computer Science major at Washington University.  I will be
Xgraduating with a Bachelor's degree in May '92.  I am currently seeking
Xpermanent employment in a computing field.  The languages I am proficient
Xin are C, X, Bourne Shell, 68000 and 6502 assembly, Pascal, LISP, and PROLOG.
XI am experienced with UNIX, X-Windows, Macintosh OS, MS-DOS and Microsoft
XWindows.  If you like this game, and are looking for a good C / UNIX / X
Xprogrammer, please consider me.
X
XMy e-mail address (through May '92):
X
Xmeb2@cec2.wustl.edu
X
XMy school address (through May '92):
X
X6926 Millbrook Blvd.
XUnit 3-102
XSt. Louis, Mo. 63130
X(314) 935-1568
X
XMy permanent home address:
X
X3735 S. Winston
XTulsa Ok, 74135
X(918) 745-6025
X
XI would be happy to send you my resume, code examples, or set up an
Xinterview.
X
XThank you, and enjoy the game!
XMark Bradley
END_OF_FILE
if test 874 -ne `wc -c <'ADVERTISEMENT'`; then
    echo shar: \"'ADVERTISEMENT'\" unpacked with wrong size!
fi
# end of 'ADVERTISEMENT'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(2086 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X	SRCS = bitmap.c bonus.c collision.c demo.c draw.c erase.c events.c\
X	 gameover.c initx.c main.c maze.c message.c normal.c quitx.c scores.c\
X	 setinmaze.c setup.c special.c time.c update.c windowx.c
X	OBJS = bitmap.o bonus.o collision.o demo.o draw.o erase.o events.o\
X	 gameover.o initx.o main.o maze.o message.o normal.o quitx.o scores.o\
X	 setinmaze.o setup.o special.o time.o update.o windowx.o
X
X	PROGRAMS = jetpack
X
X	DESTDIR = /usrd/s/m/meb2
X
X# These defines override the template defaults. Trash em if you want to
X# use the template locations
X	USRLIBDIR = $(DESTDIR)/lib/jetpack
X	BINDIR = $(DESTDIR)/bin
X	MANPATH = $(DESTDIR)/man
X	MANDIR = $(MANSOURCEPATH)1
X	TOP_INCLUDES =
X	DEPXLIB =
X	EXTRA_LIBRARIES = $(XLIB)
X
X# I like my programs optimized, stripped, and setuid. Do what you like.
X	INSTPGMFLAGS = $(INSTUIDFLAGS) -s
X	CDEBUGFLAGS = -O4
X
X# Since my programs are setuid, I make the data files readable only by me.
X	INSTDATFLAGS = -m 0600
X
X# These defines are needed by jetpack. Delete the -DBLIT if you don't want
X# the game to do all the drawing to an offscreen pixmap. (This is good for
X# machines that don't have hardware blitting -- if you have an xterm or a
X# graphics workhorse, leave it in, there will be no flicker)
X	DEFINES = -DBLIT -DSCOREPATH=\"$(SCOREFILE)\" -DLEVELPATH=\"$(LEVELFILE)\"
X
X# The score file can be any name you like, just make sure the directory
X# it's supposed to reside in exists, or jetpack will start creating score
X# files in the directories it is run from. Same for the level files, only
X# the filename you give here is only a prefix -- the complete filename has
X# the level number appended to it.
X	SCOREFILE = $(USRLIBDIR)/jetpack.scores
X	LEVELFILE = $(USRLIBDIR)/jetpack.lev
X
XComplexProgramTarget(jetpack)
X
XDependTarget()
XDependDependency()
X
XInstallNonExec(levels/000,$(LEVELFILE)000)
X
X# oops, I can't figure how to override the template default to install the
X# man page as jetpack.1, so I install both and remove the bad one.
Xinstall.man:: jetpack.man
X	$(INSTALL) -c $(INSTMANFLAGS) jetpack.man $(MANDIR)/jetpack.1
X	@rm -f $(MANDIR)/jetpack.n
END_OF_FILE
if test 2086 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'bonus.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bonus.c'\"
else
echo shar: Extracting \"'bonus.c'\" \(1014 characters\)
sed "s/^X//" >'bonus.c' <<'END_OF_FILE'
X/*	bonus.c : bonus calculating routines for jetpack
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
Xint	bonus, bonustimer, initbonus, extramaninc;
X
X/*	bonus_check decrements the bonus and checks to see if the player has
X	earned an extra player
X*/
Xbonus_check()
X{
X	decrement_bonus();
X	extra_man_check();
X}
X
X/*	decrement_bonus decrements the bonus
X*/
Xdecrement_bonus()
X{
X	bonustimer--;
X	if(!bonustimer) {
X		bonus -= BONUSINCREMENT;
X		if(bonus < 0) bonus = 0;
X		bonustimer = BONUSTIME;
X	}
X}
X
X/*	extra_man_check awards an extra player if he/she has earned it
X*/
Xextra_man_check()
X{
X	if(score >= EXTRAMANSCORE * extramaninc) {
X		men++;
X		extramaninc++;
X		if(!waiting) bigmessage("BONUS!", CBLACK, 50);
X		message("Extra player awarded!", CBLACK, 100);
X		refresh_info();
X	}
X}
X
X/*	score_bonus counts down the bonus at the end of a level
X*/
Xscore_bonus()
X{
X	char buf[14];
X
X	sprintf(buf, "Bonus: %06d", bonus);
X	bigmessage(buf, CYELLOW, 1);
X	bonus -= BONUSINCREMENT;
X	if(bonus < 0) bonus = 0;
X	else score += BONUSINCREMENT;
X}
END_OF_FILE
if test 1014 -ne `wc -c <'bonus.c'`; then
    echo shar: \"'bonus.c'\" unpacked with wrong size!
fi
# end of 'bonus.c'
fi
if test -f 'collision.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'collision.c'\"
else
echo shar: Extracting \"'collision.c'\" \(3952 characters\)
sed "s/^X//" >'collision.c' <<'END_OF_FILE'
X/*	collision.c : routines that check player collisions
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
X/*	collision_check checks for all collisions
X*/
Xcollision_check()
X{
X	register int	i;
X	register long	dx, dy;
X
X	/*	if in the door, player can't be hurt
X	*/
X	if(!indoor) {
X		for(i=0; i<numfire; i++) {
X			dx = (plx - firex[i]) * (plx - firex[i]);
X			dy = (ply - firey[i]) * (ply - firey[i]);
X			if(dx + dy <= (PLAYERWIDTH / 2 + FIREWIDTH / 2) * (PLAYERWIDTH
X				/ 2 + FIREWIDTH / 2)) {
X				if(exploded == -1) {
X					dumb_message(MKILL);
X					exploded = 0;
X					explodetimer = EXPLODETIME;
X					indoor = 1;
X					if(!keyalive) {
X						keyalive = 1;
X						keyx = plx;
X						keyy = ply;
X						refresh_info();
X					}
X				}
X			} else if(dx + dy <= (PLAYERWIDTH / 2 + FIREWIDTH / 2) *
X						(PLAYERWIDTH / 2 + FIREWIDTH / 2) * 2) {
X				if((plx / mazescale == firex[i] / mazescale) &&
X					(ply / mazescale == firey[i] / mazescale))
X						dumb_message(MCLOSE);
X			}
X		}
X		for(i=0; i<numsweep; i++) {
X			dx = (plx - sweepx[i]) * (plx - sweepx[i]);
X			dy = (ply - sweepy[i]) * (ply - sweepy[i]);
X			if(dx + dy <= (PLAYERWIDTH / 2 + SWEEPERWIDTH / 2) * (PLAYERWIDTH
X				/ 2 + SWEEPERWIDTH / 2)) {
X				if(exploded == -1) {
X					dumb_message(MKILL);
X					exploded = 0;
X					explodetimer = EXPLODETIME;
X					indoor = 1;
X					if(!keyalive) {
X						keyalive = 1;
X						keyx = plx;
X						keyy = ply;
X						refresh_info();
X					}
X				}
X			} else if(dx + dy <= (PLAYERWIDTH / 2 + SWEEPERWIDTH / 2) *
X						(PLAYERWIDTH / 2 + SWEEPERWIDTH / 2) * 2) {
X				if((plx / mazescale == sweepx[i] / mazescale) &&
X					(ply / mazescale == sweepy[i] / mazescale))
X						dumb_message(MCLOSE);
X			}
X		}
X		for(i=0; i<numguard; i++) {
X			dx = (plx - guardx[i]) * (plx - guardx[i]);
X			dy = (ply - guardy[i]) * (ply - guardy[i]);
X			if(dx + dy <= (PLAYERWIDTH / 2 + GUARDWIDTH / 2) *
X				(PLAYERWIDTH / 2 + GUARDWIDTH / 2)) {
X				if(exploded == -1) {
X					dumb_message(MKILL);
X					exploded = 0;
X					explodetimer = EXPLODETIME;
X					indoor = 1;
X					if(!keyalive) {
X						keyalive = 1;
X						keyx = plx;
X						keyy = ply;
X						refresh_info();
X					}
X				}
X			} else if(dx + dy <= (PLAYERWIDTH / 2 + GUARDWIDTH / 2) *
X						(PLAYERWIDTH / 2 + GUARDWIDTH / 2) * 2) {
X				if((plx / mazescale == guardx[i] / mazescale) &&
X					(ply / mazescale == guardy[i] / mazescale))
X						dumb_message(MCLOSE);
X			}
X		}
X	}
X	for(i=0; i<numfuel; i++) {
X		if(fuelalive[i]) {
X			dx = (plx - fuelx[i]) * (plx - fuelx[i]);
X			dy = (ply - fuely[i]) * (ply - fuely[i]);
X			if(dx + dy <= (PLAYERWIDTH / 2 + FUELWIDTH / 2) * (PLAYERWIDTH
X				/ 2 + FUELWIDTH / 2)) {
X				dumb_message(MFUEL);
X				playerfuel += FUELINCREMENT;
X				if(playerfuel > FUELCAPACITY) playerfuel = FUELCAPACITY;
X				fuelalive[i] = 0;
X				fueltimer[i] = 25;
X				score += 100;
X			}
X		}
X	}
X
X	/*	Grab the key
X	*/
X	if(keyalive && (exploded == -1)) {
X		dx = (plx - keyx) * (plx - keyx);
X		dy = (ply - keyy) * (ply - keyy);
X		if(dx + dy <= (PLAYERWIDTH / 2 + KEYWIDTH / 2) * (PLAYERWIDTH / 2
X			+ KEYWIDTH / 2)) {
X			dumb_message(MKEY);
X			score += 500;
X			keyalive = 0;
X			keytimer = 25;
X			refresh_info();
X		}
X	}
X
X	/*	Exit?
X	*/
X	if(!keyalive && indoor && !waiting && !leveldone) {
X		plx = doorx;
X		ply = doory;
X		indoor = 1;
X		dumb_message(MEXIT);
X		waiting = bonus / BONUSINCREMENT + 50;
X		playerphase = FACEFRONT;
X		playerdir = STOP;
X	}
X}
X
X/*	message_checks if the player has hit a message zone and if so, puts up
X	the appropriate message
X*/
Xmessage_check()
X{
X	register int	i;
X
X	for(i=0; i<numlmessage; i++) {
X		if(lmessage[i].unused) {
X			if((plx >= lmessage[i].x1) && (ply >= lmessage[i].y1) &&
X				(plx <= lmessage[i].x2) && (ply <= lmessage[i].y2)) {
X					lmessage[i].unused = 0;
X					if(lmessage[i].bigactive) {
X						bigmessage(lmessage[i].bigtext, lmessage[i].bigcolor,
X									lmessage[i].bigtime);
X					}
X					if(lmessage[i].active) {
X						message(lmessage[i].text, lmessage[i].color,
X									lmessage[i].time);
X					}
X			}
X		}
X	}
X}
END_OF_FILE
if test 3952 -ne `wc -c <'collision.c'`; then
    echo shar: \"'collision.c'\" unpacked with wrong size!
fi
# end of 'collision.c'
fi
if test -f 'events.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'events.c'\"
else
echo shar: Extracting \"'events.c'\" \(3753 characters\)
sed "s/^X//" >'events.c' <<'END_OF_FILE'
X/*	events.c : routines that do event handling
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
X/*	event_filter handles game events
X*/
Xint	event_filter()
X{
X	XEvent	event;
X
X	XNextEvent(display, &event);
X	switch(event.type) {
X		case ConfigureNotify:
X		case Expose:
X		case MapNotify:
X			refresh_info();
X
X#ifdef	BLIT
X			XCopyArea(display, drawpixmap, gamewindow,
X						ctable[CBLACK].smallgc, 0, 0,
X						WINDOWWIDTH, WINDOWHEIGHT, 0, 0);
X#else
X			refresh();
X#endif
X
X			return(1);
X			break;
X		case ButtonPress:
X			if(!waiting) {
X				if(event.xbutton.button == Button2) burn = 1;
X				if(event.xbutton.button == Button1) {
X					if(event.xbutton.state & Button3Mask) {
X						playerdir = STOP;
X					} else {
X						playerdir = GOLEFT;
X					}
X				}
X				if(event.xbutton.button == Button3) {
X					if(event.xbutton.state & Button1Mask) {
X						playerdir = STOP;
X					} else {
X						playerdir = GORIGHT;
X					}
X				}
X			}
X			return(1);
X			break;
X		case ButtonRelease:
X			if((event.xbutton.state & Button2Mask) && 
X				(event.xbutton.button == Button2))
X				burn = 0;
X			if(event.xbutton.button == Button3) {
X				if(event.xbutton.state & Button1Mask) {
X					playerdir = GOLEFT;
X				} else {
X					playerdir = STOP;
X				}
X			}
X			if(event.xbutton.button == Button1) {
X				if(event.xbutton.state & Button3Mask) {
X					playerdir = GORIGHT;
X				} else {
X					playerdir = STOP;
X				}
X			}
X			return(1);
X			break;
X		case KeyPress:
X			key_hit(&event);
X			return(1);
X			break;
X	}
X	return(0);
X}
X
X/*	key_hit handles game key events
X*/
Xkey_hit(event)
XXKeyEvent	*event;
X{
X	char			buf;
X	KeySym			key;
X	XComposeStatus	i;
X	
X	XLookupString(event, &buf, 1, &key, &i);
X	switch(key) {
X		case XK_KP_4:
X		case 'a':
X		case 'A':
X			playerdir = GOLEFT;
X			break;
X		case XK_KP_6:
X		case 'd':
X		case 'D':
X			playerdir = GORIGHT;
X			break;
X		case XK_KP_5:
X		case ' ':
X		case 's':
X		case 'S':
X			playerdir = STOP;
X			break;
X		case 'K':
X			if(exploded != -1) break;
X			dumb_message(MSUICIDE);
X			exploded = 0;
X			explodetimer = EXPLODETIME;
X			indoor = 1;
X			if(!keyalive) {
X				keyalive = 1;
X				keyx = plx;
X				keyy = ply;
X			}
X			break;
X		case 'Q':
X			if(dead) break;
X			dead = 1;
X			deadtimer = 50;
X			messagetime = 0;
X			bigmessagetime = 0;
X			bigmessage("Game Over", CBLACK, 100);
X			dumb_message(MQUIT);
X			break;
X		case 'p':
X			if(paused) {
X				paused = 0;
X				bigmessagetime = 0;
X				begin_timer();
X			} else {
X				bigmessage("PAUSED", CBLUE, 50);
X				draw();
X
X#ifdef	BLIT
X				XCopyArea(display, drawpixmap, gamewindow,
X							ctable[CBLACK].smallgc, 0, 0,
X							WINDOWWIDTH, WINDOWHEIGHT, 0, 0);
X#else
X				refresh();
X#endif
X
X				paused = 1;
X				stop_timer();
X			}
X			break;
X	}
X}
X
X/*	demo_event_filter handles events for the demo
X*/
Xint	demo_event_filter()
X{
X	XEvent	event;
X
X	XNextEvent(display, &event);
X	switch(event.type) {
X		case ConfigureNotify:
X		case Expose:
X		case MapNotify:
X			refresh_info();
X			return(1);
X			break;
X		case ButtonPress:
X			leveldone = 1;
X			gameover = 0;
X			break;
X		case KeyPress:
X			title_key_hit(&event);
X			return(1);
X			break;
X	}
X	return(0);
X}
X
X/*	title_event_filter handles events for the title screen
X*/
Xtitle_event_filter()
X{
X	XEvent	event;
X
X	XNextEvent(display, &event);
X	switch(event.type) {
X		case ConfigureNotify:
X		case Expose:
X		case MapNotify:
X			title_refresh();
X			break;
X		case ButtonPress:
X			gameover = 0;
X			break;
X		case KeyPress:
X			title_key_hit(&event);
X			break;
X	}
X}
X
X/*	title_key_hit handles key events for the demo and title screen
X*/
Xtitle_key_hit(event)
XXKeyEvent	*event;
X{
X	char			buf;
X	KeySym			key;
X	XComposeStatus	i;
X	int				length;
X	
X	length = XLookupString(event, &buf, 1, &key, &i);
X	switch(key) {
X		case 'Q':
X		case 'q':
X			quit_game();
X			break;
X		default:
X			if(length > 0) {
X				gameover = 0;
X				leveldone = 1;
X			}
X	}
X}
END_OF_FILE
if test 3753 -ne `wc -c <'events.c'`; then
    echo shar: \"'events.c'\" unpacked with wrong size!
fi
# end of 'events.c'
fi
if test -f 'gameover.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gameover.c'\"
else
echo shar: Extracting \"'gameover.c'\" \(950 characters\)
sed "s/^X//" >'gameover.c' <<'END_OF_FILE'
X/*	gameover.c : routines used when player dies or game is over
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
Xint	dead, deadtimer;
X
X/*	death is called when a player is killed.
X*/
Xdeath()
X{
X    men--;
X    if(men < 0) {
X		dead = 1;
X		deadtimer = 50;
X		bigmessage("Game Over", CBLACK, 100);
X		return;
X	}
X    if(!keyalive) {
X        keyx = plx;
X        keyy = ply;
X        keyalive = 1;
X    }
X    plx = doorx;
X    ply = doory;
X    playerfuel = 1000;
X    burn = 0;
X    walk = 1;
X    playerdir = STOP;
X    playervert = 0;
X    playerphase = FACEFRONT;
X    exploded = -1;
X    XClearWindow(display, gamewindow);
X    XClearWindow(display, infowindow);
X    refresh_info();
X}
X
X/*	game_over is called when a player loses his/her last life. The high
X	score table is checked, and some cleanup is done.
X*/
Xgame_over()
X{
X	lastscore = score;
X	check_score();
X    XClearWindow(display, gamewindow);
X    XClearWindow(display, infowindow);
X	gameover = 1;
X	leveldone = 1;
X}
END_OF_FILE
if test 950 -ne `wc -c <'gameover.c'`; then
    echo shar: \"'gameover.c'\" unpacked with wrong size!
fi
# end of 'gameover.c'
fi
if test -f 'jetpack.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jetpack.man'\"
else
echo shar: Extracting \"'jetpack.man'\" \(4244 characters\)
sed "s/^X//" >'jetpack.man' <<'END_OF_FILE'
X.\" Copyright (c) 1992 Mark Bradley
X.\"
X.\" @(#)jetpack.1 1.00 90/02/15 SMI;
X.TH JETPACK 1  "23 February 1992"
X.SH NAME
Xjetpack \- Arcade action game for X Windows
X.SH SYNOPSIS
X.B jetpack
X.SH DESCRIPTION
X.IX games jetpack "" "\fLjetpack\fR \(em Arcade action game"
X.IX jetpack "" "\fLjetpack\fR \(em Arcade action game"
X.LP
X.B jetpack
Xis an arcade action game.
XThe user controls a
X.B player
Xwearing a jetpack.
XThe game takes place within a series of
X.B levels
Xthat each consist of a
X.B maze ,
X.B fuel pods ,
Xa
X.B door ,
Xand a
X.B key .
XThe player must travel through the maze to find the key
Xand bring it back to the door to exit to the next level.
XThere is a
X.B bonus
Xfor each level that is decremented as time goes on.
XIt is awarded when the player sucessfully exits the level.
X.SS Movement
X.LP
XThe player can move left and right through space or walk along a
Xhorizontal maze wall.
XThe player can also fire the jetpack, thrusting him upward.
XIf the player is not standing on a wall and not firing the jetpack, he will
Xaccelerate downward.
XThe player cannot be damaged by falling.
X.LP
XFiring the jetpack uses fuel.
XThe player has a tank of fuel that can contain up to 1000 units of fuel.
XPicking up a fuel pod gives the player 100 units of fuel.
X.SS Enemies
X.LP
XThere are three kinds of enemies in jetpack:
X.B guards ,
X.B fireballs ,
Xand
X.B wall sweepers .
XTouching any enemy is fatal, and enemies do not harm each other.
X.LP
XGuards patrol the maze.
XThey fly in the middle of the corridors and follow random paths through
Xthe maze.
X.LP
XFireballs fly through space and bounce off walls.
X.LP
XWall Sweepers cling to walls and continuously move along the surface of
Xthe walls.
XThey can hang on to any side, and when they reach the end of a wall, flip
Xto hug the other side and continue in the opposite direction.
X.SS Scoring
X.LP
XThe bonus for each level is proportional to the size of the level, how
Xdense the maze is, and how many enemies and fuel pods are in it.
XIn addition to the bonus, picking up a fuel pod is worth 100 points, and
Xpicking up the key is worth 500 points.
X.SS Commands
X.PD 0
X.LP
XQ	:	Quit the current game.
X.LP
XK	:	Commit suicide. (player loses a life and returns to the door)
X.LP
Xa, A, keypad 4
X.LP
X.RS
X:	Move left. Player will continue to move left until direction is
Xchanged.
X.RE
X.LP
Xd, D, keypad 6
X.LP
X.RS
X:	Move right. Player will continue to move right until direction is
Xchanged.
X.RE
X.LP
Xs, S, keypad 5
X.LP
X.RS
X:	Stop horizontal movement.
X.RE
X.LP
Xleft mouse button
X.LP
X.RS
X:	Move left. Player will continue to move left until the button is
Xreleased.
X.RE
X.LP
Xright mouse button
X.LP
X.RS
X:	Move right. Player will continue to move right until the button is
Xreleased.
X.RE
X.LP
Xcenter mouse button
X.LP
X.RS
X:	Fire jetpack. Jetpack will continue to fire until the button is
Xreleased.
X.RE
X.PD
X.SS Miscellaneous
X.LP
XThe player starts each level from the door.
XWhen the player is standing within the door, he cannot be killed.
XThe door is grey when the player is in it, otherwise it is white.
XThe player is returned to the door each time he dies.
X.LP
XIf the player has the key when he dies, the key stays where the player was
Xkilled.
X.LP
XExtra players are awarded every 10000 points.
X.SH FILES
X.PD 0
X.LP
Xlib/jetpack.scores - jetpack high scores
X.LP
Xlib/jetpack.lev000 - predefined demo level
X.PD
X.SH DIAGNOSTICS
X.LP
X"Jetpack : Cannot connect to X Server <servername>"
X.PD 0
X.LP
X.PD
XJetpack can't open the display you wanted.
XCheck the environment variable DISPLAY and make sure the host is
Xauthorized.
X.LP
X"Jetpack : Couldn't load <fontname> font."
X.PD 0
X.LP
X.PD
XJetpack was unable to load a needed font.
XCheck to make sure your X server has the font loaded, or if necessary,
Xrecompile jetpack with a font that exists on your server.
X.LP
X"Jetpack : Couldn't open scorefile."
X.PD 0
X.LP
X.PD
XJetpack couldn't open or create a high score file.
XCheck to see if the jetpack lib directory is readable and writable, and if
Xthe score file already exists, that it is readable and writable.
X.SH BUGS
X.LP
XJetpack does not use .Xauthority databases.
X.LP
XJetpack does not have any command line options.
X.LP
XJetpack has the ability to read in predefined levels, but only the demo
Xlevel is provided.
X.SH AUTHOR
X.LP
XCopyright (c) 1992 Mark Bradley
END_OF_FILE
if test 4244 -ne `wc -c <'jetpack.man'`; then
    echo shar: \"'jetpack.man'\" unpacked with wrong size!
fi
# end of 'jetpack.man'
fi
if test -f 'levels/000' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'levels/000'\"
else
echo shar: Extracting \"'levels/000'\" \(1191 characters\)
sed "s/^X//" >'levels/000' <<'END_OF_FILE'
X11  7  120   
X 
X0  4  4  4  4  4  4  4  4  4  4  4  0    
X2  9  1  1  3 13  7  9  1  1  1  3  8    
X2  8  0  4  4  5  5  4  4  0  4  2  8    
X2  8  2  9  1  1  1  1  3 14 11 10  8    
X2  8  2  8  0  0  0  4  4  5  2 10  8    
X2 12  6  8  0  0  6  9  5  3 14 10  8    
X0  1  1  0  0  0 13  2 15  8  5  6  8    
X0  0  0  0  0  0  3 12  5  6  9  1  0    
X0  0  0  0  0  0  0  1  1  1  0  0  0    
X  
X1  5   
X
X500 
X
X1 
X 
X5  1  1  3   
X  
X1 
X 
X1140  420   4  0   
X  
X2 
X 
X8  5  2  1  1   
X8  5  2  -1  5   
X  
X1 
X
X540  359   
X  
X780  780   
X
X6 
X
X240  600  360  720  3  7  75  75   
X5
XDOOR:
X64
XYou start each level from the door. You can't be hurt inside it.
X
X360  120  480  360  3  2  75  75   
X9
XFUEL POD:
X56
XYour jetpack uses fuel. Pick up fuel pods to fly longer.
X
X600  120  720  360  3  5  75  75   
X6
XGUARD:
X42
XGuards patrol the maze. Guards are deadly.
X
X960  120  1080  360  3  1  75  75   
X9
XFIREBALL:
X62
XFireballs bounce off walls. Touching a fireball will kill you.
X
X1080  600  1200  960  3  6  75  75   
X13
XWALL SWEEPER:
X59
XSweepers move along the walls. Touching a sweeper is fatal.
X
X840  600  960  960  3  3  75  75   
X4
XKEY:
X54
XPick up the key and bring it back to the door to exit.
END_OF_FILE
if test 1191 -ne `wc -c <'levels/000'`; then
    echo shar: \"'levels/000'\" unpacked with wrong size!
fi
# end of 'levels/000'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(2487 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/*	main.c : main loop of jetpack
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
XWindow	gamewindow, infowindow;
X
Xint	men, score, level;
X
Xint	leveldone, paused, gameover, lastscore;
X
X/*	main is the main loop of the progam. (surprise!) Because of the
X	functional abstraction, it should be pretty readable.
X*/
Xmain()
X{
X	int						seed;
X	char					lev[20];
X	register unsigned long	timer;
X
X	/*	randomize the random number generator by seeding it with the time
X		in seconds
X	*/
X	seed = (int) time(NULL);
X	srandom(seed);
X
X	
X	/*	set things up
X	*/
X	open_scores();
X	init_X();
X	set_up_windows();
X	set_up_bitmaps();
X	lastscore = 0;
X	gameover = 1;
X
X#ifndef	BLIT
X	init_zones();
X#endif
X
X	/*	This outer loop is executed forever. The program is exited by a
X		call to quit_game.
X	*/
X	while(1) {
X
X		/*	This loop cycles between the title screen and the
X			demonstration. When the user hits a key or button, gameover
X			is set to 1.
X		*/
X		while(gameover) {
X			title_screen();
X			if(gameover) demo();
X		}
X
X		reset_game();
X
X		/*	This loop is the outer "game" loop. Each level is started here.
X		*/
X		while(!gameover) {
X			reset_level();
X
X			/*	Some levels are special preset levels
X			*/
X			if(!special_setup()) normal_level();
X
X			/* Display the level number
X			*/
X			sprintf(lev, "Level: %d", level);
X			bigmessage(lev, CGREEN, 75);
X
X			/* initial draw
X			*/
X			XClearWindow(display, gamewindow);
X			draw();
X			XClearWindow(display, infowindow);
X			refresh_info();
X
X			/*	central event loop. When the level is over, or the player
X				loses his/her last life, leveldone is set to 1.
X			*/
X			while(!leveldone) {
X				begin_timer();
X				while(paused) {
X					while(XPending(display) && !event_filter());
X					usleep(USECDELAY);
X				}
X				while(XPending(display) && !event_filter());
X				update();
X				collision_check();
X				message_check();
X				bonus_check();
X				draw();
X
X				/*	When nothing was in the maze except me, I set
X					USECDELAY to a nice-looking speed. Jetpack doesn't
X					use a lot of cpu, but there would be slowdown with
X					more objects. So to keep the delay constant, I used
X					begin_timer and get_timer to time the calculations
X					and drawing, subtracted that from USECDELAY, and
X					voila! I had a constant delay. The only times that
X					it runs over are usually unnoticeable, and if it
X					runs over a lot, it means the machine is really
X					busy, and you shouldn't be playing anyway.
X				*/
X				timer = get_timer();
X				if(timer < USECDELAY) usleep(USECDELAY - timer);
X			}
X		}
X	}
X}
END_OF_FILE
if test 2487 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'message.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'message.h'\"
else
echo shar: Extracting \"'message.h'\" \(4113 characters\)
sed "s/^X//" >'message.h' <<'END_OF_FILE'
X/*	message.h : silly messages used in jetpack.
X*/
X
X#include "copyright.h"
X
X#define	MAXDUMBMESSAGES		10
X#define	DUMBMESSAGETYPES	7
X#define	DUMBMESSAGEOPINIONS	4
X
Xstatic int	numdumbmessages[DUMBMESSAGETYPES][DUMBMESSAGEOPINIONS] = {
X	{ 8, 9 },
X	{ 9 },
X	{ 10, 9, 8, 7 },
X	{ 10 },
X	{ 8 },
X	{ 10, 9, 9, 10 },
X	{ 10 },
X};
X
Xstatic int	dumbmessagetime[DUMBMESSAGETYPES] = {
X	50, 20, 50, 20, 50, 100, 100,
X};
X
Xstatic int	dumbmessagechance[DUMBMESSAGETYPES] = {
X	3, 2, 1, 2, 1, 1, 1,
X};
X
Xstatic char dumbmessage[DUMBMESSAGETYPES][DUMBMESSAGEOPINIONS][MAXDUMBMESSAGES][MAXMESSAGELENGTH] = {
X
X/*	MFUEL
X*/
X{
X	{
X		"Wasteful.",
X		"It'd people like you who caused the oil crisis!",
X		"Did you really need that?",
X		"I think you have plenty.",
X		"Your tank only holds 1000.",
X		"When you're running out of fuel later, don't come crying to me.",
X		"Greedy, aren't you?",
X		"If you use all the fuel up now, you'll run out later.",
X	},
X	{
X		"Lucky break.",
X		"You should be more careful!",
X		"Do you like living on the edge?",
X		"Whew!",
X		"Don't let yourself run out!",
X		"What a relief!",
X		"I hope there's more around here.",
X		"Try to pick up fuel more often.",
X		"Running on empty is a good way to lose.",
X	},
X},
X
X/*	MKILL
X*/
X{
X	{
X		"Ouch!",
X		"Aaarrrgghhh!",
X		"BOOM!",
X		"Noooooo!",
X		"Another one bites the dust.",
X		"OH NOOOOOO!!!",
X		"Dead meat.",
X		"End of the line.",
X		"KA-BOOOMMM!!",
X	},
X},
X
X/*	MKEY
X*/
X{
X	{
X		"Took you long enough.",
X		"Finally!",
X		"I hope you don't take this long to get back.",
X		"It's about time!",
X		"Hurry up and get back!",
X		"The clock's ticking...",
X		"C'mon, slowpoke!",
X		"tick...tick...tick...",
X		"Your bonus is running out!",
X		"Get the lead out!",
X	},
X	{
X		"That was quick!",
X		"Piece of cake!",
X		"What a stroke of luck!",
X		"How did you find it so quickly?",
X		"Wow, that was fast!",
X		"You didn't peek when I placed the key, did you?",
X		"That was easy!",
X		"No problem!",
X		"Perfect!",
X	},
X	{
X		"Your chances don't look good.",
X		"Did you pass any fuel on the way?",
X		"Can you make it?",
X		"You really need some fuel.",
X		"Getting back is going to be tough.",
X		"I hope you didn't use all the fuel pods getting here.",
X		"Don't waste so much fuel!",
X		"You have to find some fuel pods!",
X	},
X	{
X		"Now head back to the door!",
X		"Got it!",
X		"Alright!",
X		"Yes!",
X		"Go! Go! Go!",
X		"Good job!",
X		"Yeah!",
X	},
X},
X
X/*	MCLOSE
X*/
X{
X	{
X		"Yow! Careful!",
X		"Not so close!",
X		"Watch out!",
X		"Are you trying to get yourself killed?",
X		"Are you crazy!",
X		"I can't look!",
X		"You're out of your mind!",
X		"Look out!",
X		"Yikes!",
X		"Whoa!",
X	},
X},
X
X/*	MSUICIDE
X*/
X{
X	{
X		"Don't you know suicide is illegal?",
X		"Such a senseless waste of human life.",
X		"AAAARRRRGGGHHHH.....",
X		"Way to confront your problems!",
X		"Remember kids, suicide isn't cool.",
X		"That's no way to win.",
X		"BOOOOMMMM!!!",
X		"Surely there's an alternative?",
X	},
X},
X
X/*	MEXIT
X*/
X{
X	{
X		"Pathetic.",
X		"You need diapers.",
X		"Slow and steady loses the bonus.",
X		"Speedy Gonzalez you're not.",
X		"Zero bonus. Is that you Qarl?",
X		"Wake me after the next level.",
X		"Stop it, you're boring me to death.",
X		"What are you doing, drawing maps?",
X		"Zzzzzzzzz....",
X		"Wretched.",
X	},
X	{
X		"What speed!",
X		"I'm really impressed!",
X		"Terrific!",
X		"That was amazing!",
X		"Incredible!",
X		"Wow! I'll have to make the next maze harder!",
X		"You've got this down pat!",
X		"Fabulous!",
X		"Excellent!",
X	},
X	{
X		"You can do better than that!",
X		"That's not too good.",
X		"You need to go a little faster.",
X		"I've seen better times.",
X		"Pick up the pace, Ace.",
X		"If you want a big bonus, you have to go faster.",
X		"You're taking too long.",
X		"Too slow.",
X		"Hurry it up!",
X	},
X	{
X		"Good job!",
X		"Congratulations!",
X		"Way to go!",
X		"Good level!",
X		"Good job!",
X		"Alright!",
X		"Great!",
X		"Keep it up!",
X		"Lookin' good!",
X		"Yeah!",
X	},
X},
X
X/*	MQUIT
X*/
X{
X	{
X		"Quitter!",
X		"Don't stop now!",
X		"Well, play again soon!",
X		"Just one more game, please?",
X		"Play again, I dare ya!",
X		"Don't give up!",
X		"It's been real.",
X		"Oh, come on!",
X		"Don't you want to finish the game?",
X		"Goodbye!",
X	},
X},
X};
END_OF_FILE
if test 4113 -ne `wc -c <'message.h'`; then
    echo shar: \"'message.h'\" unpacked with wrong size!
fi
# end of 'message.h'
fi
if test -f 'p2.hdr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'p2.hdr'\"
else
echo shar: Extracting \"'p2.hdr'\" \(716 characters\)
sed "s/^X//" >'p2.hdr' <<'END_OF_FILE'
XFrom meb2@cec2.wustl.edu Sun Feb 23 11:50:11 1992
XReceived: from master.CNA.TEK.COM by saab.CNA.TEK.COM (4.1/6.24)
X	id AA03370; Sun, 23 Feb 92 11:50:06 PST
XReceived: from tektronix.TEK.COM by master.CNA.TEK.COM (4.1/7.1)
X	id AA15620; Sun, 23 Feb 92 11:49:16 PST
XReceived: from cec2.wustl.edu by tektronix.TEK.COM (4.1/8.0)
X	id AA14507; Sun, 23 Feb 92 11:50:11 PST
XReturn-Path: <meb2@cec2.wustl.edu>
XReceived: by cec2.wustl.edu
X	(5.65a/1.35); id AA10358; Sun, 23 Feb 92 13:48:29 -0600
XDate: Sun, 23 Feb 92 13:48:29 -0600
XFrom: meb2@cec2.wustl.edu (Mark Edward Bradley)
XMessage-Id: <9202231948.AA10358@cec2.wustl.edu>
XTo: billr@saab.CNA.TEK.COM
XSubject: jetpack.shar.2 Jetpack - an arcade action game for X
XStatus: O
X
END_OF_FILE
if test 716 -ne `wc -c <'p2.hdr'`; then
    echo shar: \"'p2.hdr'\" unpacked with wrong size!
fi
# end of 'p2.hdr'
fi
if test -f 'quitx.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'quitx.c'\"
else
echo shar: Extracting \"'quitx.c'\" \(1097 characters\)
sed "s/^X//" >'quitx.c' <<'END_OF_FILE'
X/*	quitx.c : routine that destroys resources and quits.
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
X/*	quit_game destroys all resources, closes the score file, and quits.
X*/
X
Xquit_game()
X{
X	register int	i, j;
X
X	for(i=0; i<PLAYERPHASES; i++) {
X		XFreePixmap(display, playerpix[i]);
X	}
X	for(i=0; i<BURNDIRECTIONS; i++) {
X		XFreePixmap(display, burnpix[i]);
X	}
X	for(i=0; i<FIREPHASES; i++) {
X		XFreePixmap(display, firepix[i]);
X	}
X	for(i=0; i<SWEEPERPHASES; i++) {
X		XFreePixmap(display, sweeperpix[i]);
X	}
X	for(i=0; i<EXPLODEFRAMES; i++) {
X		XFreePixmap(display, explodepix[i]);
X	}
X	for(i=0; i<GUARDDIRECTIONS; i++) {
X		for(j=0; j<GUARDPHASES; j++) {
X			XFreePixmap(display, guardpix[i][j]);
X		}
X	}
X	for(i=0; i<DOORFRAMES; i++) {
X		XFreePixmap(display, doorpix[i]);
X	}
X	XFreePixmap(display, fuelpix);
X	XFreePixmap(display, keypix);
X	XFreePixmap(display, extramanpix);
X	XFreePixmap(display, scorepixmap);
X
X#ifdef	BLIT
X	XFreePixmap(display, drawpixmap);
X#endif
X
X	XDestroySubwindows(display, gamewindow);
X	XDestroyWindow(display, gamewindow);
X    XCloseDisplay(display);
X	close_scores();
X	exit(0);
X}
END_OF_FILE
if test 1097 -ne `wc -c <'quitx.c'`; then
    echo shar: \"'quitx.c'\" unpacked with wrong size!
fi
# end of 'quitx.c'
fi
if test -f 'setinmaze.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'setinmaze.c'\"
else
echo shar: Extracting \"'setinmaze.c'\" \(2355 characters\)
sed "s/^X//" >'setinmaze.c' <<'END_OF_FILE'
X/*	setinmaze.c : routine used to keep objects off the maze walls
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
Xint	nx, ny;
X
X/*	set_in_maze : This ugly procedure checks the global variables nx and
X	ny against the maze and adjusts them if they sit on a wall. The reason
X	there are double checks for WALLUP and WALLDOWN is to avoid side
X	effects like being stopped by a vertical wall on the other side of the
X	ceiling you're touching with your head.
X*/
Xint	set_in_maze(off)
Xint	off;
X{
X	int flags = 0;
X
X	if(((ny % mazescale) >= mazescale - (off + 1)) &&
X		(maze[nx/mazescale][ny/mazescale] & WALLDOWN)) {
X
X			ny = mazescale - (off + 1) + ((ny/mazescale) * mazescale);
X			flags |= WALLDOWN;
X		
X	} else if(((ny % mazescale) <= (off + 1)) &&
X		(maze[nx/mazescale][ny/mazescale] & WALLUP)) {
X		
X			ny = (off + 1) + ((ny/mazescale) * mazescale);
X			flags |= WALLUP;
X		
X	}
X	if(((nx % mazescale) >= mazescale - (off + 1)) &&
X		((maze[nx/mazescale][ny/mazescale] & WALLRIGHT) ||
X		(((ny % mazescale) > mazescale - off) &&
X		(maze[nx/mazescale][ny/mazescale+1] & WALLRIGHT)) ||
X		(((ny % mazescale) < off) &&
X		(maze[nx/mazescale][ny/mazescale-1] & WALLRIGHT)))) {
X			
X			nx = mazescale - (off + 1) + ((nx/mazescale) * mazescale);
X			flags |= WALLRIGHT;
X		
X	} else if(((nx % mazescale) <= (off + 1)) &&
X		((maze[nx/mazescale][ny/mazescale] & WALLLEFT) ||
X		(((ny % mazescale) > mazescale - off) &&
X		(maze[nx/mazescale][ny/mazescale+1] & WALLLEFT)) ||
X		(((ny % mazescale) < off) &&
X		(maze[nx/mazescale][ny/mazescale-1] & WALLLEFT)))) {
X			
X			nx = (off + 1) + ((nx/mazescale) * mazescale);
X			flags |= WALLLEFT;
X		
X	}
X	if(((ny % mazescale) >= mazescale - (off + 1)) &&
X		((maze[nx/mazescale][ny/mazescale] & WALLDOWN) ||
X		(((nx % mazescale) > mazescale - off) &&
X		(maze[nx/mazescale+1][ny/mazescale] & WALLDOWN)) ||
X		(((nx % mazescale) < off) &&
X		(maze[nx/mazescale-1][ny/mazescale] & WALLDOWN)))) {
X		
X			ny = mazescale - (off + 1) + ((ny/mazescale) * mazescale);
X			flags |= WALLDOWN;
X		
X	} else if(((ny % mazescale) <= (off + 1)) &&
X		((maze[nx/mazescale][ny/mazescale] & WALLUP) ||
X		(((nx % mazescale) > mazescale - off) &&
X		(maze[nx/mazescale+1][ny/mazescale] & WALLUP)) ||
X		(((nx % mazescale) < off) &&
X		(maze[nx/mazescale-1][ny/mazescale] & WALLUP)))) {
X		
X			ny = (off + 1) + ((ny/mazescale) * mazescale);
X			flags |= WALLUP;
X		
X	}
X	return(flags);
X}
END_OF_FILE
if test 2355 -ne `wc -c <'setinmaze.c'`; then
    echo shar: \"'setinmaze.c'\" unpacked with wrong size!
fi
# end of 'setinmaze.c'
fi
if test -f 'special.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'special.c'\"
else
echo shar: Extracting \"'special.c'\" \(2264 characters\)
sed "s/^X//" >'special.c' <<'END_OF_FILE'
X/*	special.c : routines that read in the predefined levels from files.
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
X#ifndef	LEVELPATH
X#define	LEVELPATH	"jetpack.lev"
X#endif
X
X/*	special_setup checks to see if the current level has a level file, and
X	if so, to read in the level from the level file
X*/
Xint	special_setup()
X{
X	register int	i, j;
X	char			filename[MAXPATHLEN];
X	FILE			*fp;
X	int				gx, gy, gd, gs, fx, fy, fdx, fdy, sx, sy, sf, sd, ss,
X					px, py, kx, ky, length, ng, nf, ns, np, playerx,
X					playery;
X
X	sprintf(filename, "%s%03d", LEVELPATH, level);
X	fp = fopen(filename, "r");
X	if(fp == NULL) return(0);
X	rewind(fp);
X	fflush(fp);
X	mazelcount = 0;
X	fscanf(fp, " %d %d %d ", &mazewidth, &mazeheight, &mazescale);
X	for(i=0; i<mazeheight+2; i++) {
X		for(j=0; j<mazewidth+2; j++) {
X			fscanf(fp, "%d", &(maze[j][i]));
X		}
X	}
X	convert_maze(mazewidth, mazeheight);
X	fscanf(fp, " %d %d %d ", &playerx, &playery, &bonus);
X	place_player(playerx, playery);
X	fscanf(fp, " %d ", &ng);
X	for(i=0; i<ng; i++) {
X		fscanf(fp, " %d %d %d %d ", &gx, &gy, &gd, &gs);
X		place_guard(gx, gy, gd, gs);
X	}
X	fscanf(fp, " %d ", &nf);
X	for(i=0; i<nf; i++) {
X		fscanf(fp, " %d %d %d %d ", &fx, &fy, &fdx, &fdy);
X		place_fireball(fx, fy, fdx, fdy);
X	}
X	fscanf(fp, " %d ", &ns);
X	for(i=0; i<ns; i++) {
X		fscanf(fp, " %d %d %d %d %d ", &sx, &sy, &sf, &sd, &ss);
X		place_sweeper(sx, sy, sf, sd, ss);
X	}
X	fscanf(fp, " %d ", &np);
X	for(i=0; i<np; i++) {
X		fscanf(fp, " %d %d ", &px, &py);
X		place_fuel(px, py);
X	}
X	fscanf(fp, " %d %d ", &kx, &ky);
X	place_key(kx, ky);
X	fscanf(fp, " %d ", &numlmessage);
X	for(i=0; i<numlmessage; i++) {
X		fscanf(fp, " %d %d %d %d %d %d %d %d ", &(lmessage[i].x1),
X				&(lmessage[i].y1), &(lmessage[i].x2), &(lmessage[i].y2),
X				&(lmessage[i].color), &(lmessage[i].bigcolor),
X				&(lmessage[i].time), &(lmessage[i].bigtime));
X		fscanf(fp, " %d ", &length);
X		for(j=0; j<length; j++) {
X			fscanf(fp, "%c", lmessage[i].bigtext+j);
X		}
X		lmessage[i].bigtext[length] = '\0';
X		lmessage[i].bigactive = (length != 0);
X		fscanf(fp, " %d ", &length);
X		for(j=0; j<length; j++) {
X			fscanf(fp, "%c", lmessage[i].text+j);
X		}
X		lmessage[i].text[length] = '\0';
X		lmessage[i].active = (length != 0);
X		lmessage[i].unused = 1;
X	}
X	initbonus = bonus;
X	return(1);
X}
END_OF_FILE
if test 2264 -ne `wc -c <'special.c'`; then
    echo shar: \"'special.c'\" unpacked with wrong size!
fi
# end of 'special.c'
fi
if test -f 'time.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'time.c'\"
else
echo shar: Extracting \"'time.c'\" \(872 characters\)
sed "s/^X//" >'time.c' <<'END_OF_FILE'
X/*	time.c : routines that use the realtime process timer to synchronize
X	the game.
X*/
X
X#include "copyright.h"
X#include "defs.h"
X
Xstruct itimerval	val;
X
X/*	begin_timer starts the realtime process timer
X*/
Xbegin_timer()
X{
X	val.it_value.tv_sec = 30000;
X	val.it_value.tv_usec = 0;
X	val.it_interval.tv_sec = 30000;
X	val.it_interval.tv_usec = 0;
X	setitimer(ITIMER_REAL, &val, NULL);
X}
X
X/*	stop_timer stops the realtime process timer
X*/
Xstop_timer()
X{
X	val.it_value.tv_sec = 0;
X	val.it_value.tv_usec = 0;
X	val.it_interval.tv_sec = 0;
X	val.it_interval.tv_usec = 0;
X	setitimer(ITIMER_REAL, &val, NULL);
X}
X
X/*	get_timer returns the elapsed real timer time in microseconds
X*/
Xunsigned long	get_timer()
X{
X	register long	ds, dus, dt;
X
X	getitimer(ITIMER_REAL, &val);
X	ds = 30000 - val.it_value.tv_sec - 1;
X	dus = 1000000 - val.it_value.tv_usec;
X	dt = dus + 1000000 * ds;
X	return(dt);
X}
END_OF_FILE
if test 872 -ne `wc -c <'time.c'`; then
    echo shar: \"'time.c'\" unpacked with wrong size!
fi
# end of 'time.c'
fi
echo shar: End of archive 4 \(of 4\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
