Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i060:  dominion - a multi-player world simulation game, Part24/28
Message-ID: <2463@masterCNA.TEK.COM>
Date: 11 Feb 92 18:27:31 GMT
Sender: news@masterCNA.TEK.COM
Lines: 2191
Approved: billr@saab.CNA.TEK.COM

Submitted-by: rosalia@dirac.physics.sunysb.edu (Mark Galassi)
Posting-number: Volume 13, Issue 60
Archive-name: dominion/Part24
Environment: Unix, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 24 (of 28)."
# Contents:  dominion.h int_mail.c printmap.c races spelllib.c
# Wrapped by billr@saab on Tue Feb 11 10:14:58 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dominion.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dominion.h'\"
else
echo shar: Extracting \"'dominion.h'\" \(13830 characters\)
sed "s/^X//" >'dominion.h' <<'END_OF_FILE'
X  /* dominion.h -- general include file for dominion */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include <curses.h>
X
X  /* user-definable params */
X#define WORLD_FILE "world"
X#define REF_CARD_FILE "doc/refcard" /* basic reference card */
X#define INFO_FILE "doc/dominion.info" /* complete documentation */
X#define RACES_FILE "misc/races"
X#define DIPLO_FILE "dom_diplo"	/* diplomacy matrix stored here */
X#define INIT_DIPLO_FILE "init_diplo" /* remember initial diplomacy matrix */
X#define CARGO_FILE "misc/cargo" /* stores cargo exchanges */
X#define HANGING_SPELLS_FILE "hanging_spells" /* currently active spells */
X  /* any file that starts with the MAG_PREFIX is a description
X     of a magical order.  the name of the order follows the prefix.
X     a list of possible magic orders is in mag_orders.
X   */
X#define MAG_ORDERS "magic/mag_orders"
X#define MAG_PREFIX "magic/mag_"
X#define TECHNO_FILE "misc/techno_levels"
X
X#define MAIL_DIR   "mail"	/* Which dir (in lib) to place mail */
X#define NEWS_DIR   "news"       /* Which dir (in lib) to keep news */
X#define NGDB_FILE  "groups"     /* What file in NEWS_DIR to hold the news
X				   groups database */
X#define OPT_DIR    "options"    /* Which dir (in lib) to keep options */
X#define TRADES_FILE "trades"	/* file where trade info is kept */
X#define BIDS_FILE  "bids"	/* file where bids on trades are kept */
X#define ARMY_TYPES_FILE "misc/army_types" /* army type descriptions are here */
X /* spirit type descriptions are here */
X#define SPIRIT_TYPES_FILE "misc/spirit_types"
X#define NPC_FILE   "misc/npcs"	/* file where npc info is kept */
X#define MAXTRADES  100          /* maximum amount of trades on board */
X#define NATIONS 50		/* max # of nations; to be removed some day */
X
X  /* now some defines for how the NPCs move */
X#define NPC_FIGHT TRUE		/* if this is TRUE, NPCs fight each other */
X#define NPC_VIEW 4		/* how far NPC armies look to move */
X#define NPC_SIDE (NPC_VIEW*2+3)	/* length of the side of the "looking" array */
X#define MAX_TYPES 100		/* maximum number of armies NPC considers */
X#define DIP_CHANGE 75		/* Percent chance for npc diplomacy change */
X
X  /* tunable parameters */
X#define OCCUPYING_SOLDIERS 100	/* min. soldiers to occupy a sector */
X/*#define POP_REFINERY 100	/* min. population for a refinery to work */
X#define REFINERY_FACT (12.0/100.0) /* percent added by an active refinery */
X#define FOOD_PROD 4		/* production of food/farmer : tons */
X#define EAT 1.3			/* how much a person eats in 1 thon : tons */
X#define SOLD_EAT_FACTOR 1.2	/* multiplies the eat rate */
X
X#define CARAVAN_CAPACITY 250	/* how many civilians on 1 caravan unit */
X
X#define JEWEL_WEIGHT 0.01	/* the next four are in relation to one */
X#define MONEY_WEIGHT 0.01	/* person's weight (i.e. jewels weigh */
X#define METAL_WEIGHT 0.1	/* 1/100th of a person) */
X#define FOOD_WEIGHT  0.05
X
X#define DISBAND_RETURN (0.5)    /* what fraction metal is returned w/disband */
X
X/* how much do money/metal/jewels affect R&D */
X#define TECH_MONEY_FACTOR 1.0/10.0
X#define TECH_METAL_FACTOR 1.0/40.0
X#define MAG_MONEY_FACTOR 1.0/5.0
X#define MAG_JEWEL_FACTOR 1.0/200.0
X#define SPY_MONEY_FACTOR 1.0/200.0
X#define SPY_SECRECY_FACTOR 1.0/2000.0
X
X  /* these parameters determine how far you can see */
X#define LAND_SIGHT 3		/* how far you see from an owned sector */
X#define WATER_SIGHT 2		/* ...             across water */
X#define ARMY_SIGHT 2		/* ...                  an army */
X
X  /* end of user-defined parameters */
X
X#define NOT_NPC 0		/* values of the Snation.npc_flag */
X#define NPC_NOMAIL 1		/* NPC that does not get mail */
X#define NPC_MAIL 2		/* NPC that gets mail */
X  /* now a macro that allows us to quickly see if an NPC should get mail */
X#define gets_mail(np) ((np)->npc_flag == NOT_NPC || (np)->npc_flag == NPC_MAIL)
X
X#define NAMELEN 20		/* length of most names */
X#define PASSLEN 15
X#define PATHLEN 200		/* length of directory paths */
X
X#ifdef CURSES
X  typedef char Symbol;		/* just a char for curses */
X#endif
X	/* should typedef mark for X and other windows... */
X
Xstruct pt {
X  int x, y;
X};
Xtypedef struct pt Pt;
X
X  /* this structure identifies an army by its owner and id.
X     it is used in the list of armies present in each sector.
X   */
Xstruct armyid {
X  int owner, id;
X  struct armyid *next;
X};
X
X  /* defines a cargo carried by some moving object (caravan or navy) */
Xstruct scargo {
X  int money, metal, jewels, food, people, army;
X  Pt title;
X};
X
Xtypedef struct scargo Scargo;
X
Xstruct sarmy {
X  char type[NAMELEN],		/* string (i.e. "Infantry","ent")   */
X       name[NAMELEN];		/* the army's name */
X  int  n_soldiers,		/* number of soldiers in the army   */
X       status,			/* ATACK|DEFEND|OCCUPY|...          */
X       id,			/* army number                      */
X       owner,			/* nation number of army owner      */
X       mvpts,			/* move points                      */
X       mvratio;			/* fraction of movement used        */
X       long flags;		/* bitmap, fields defined in army.h */
X  Pt   pos;			/* where the army is                */
X  int  sp_bonus;          /* extra bonus, on top of basic nation bonus */
X    /* the maintainance costs are all per-soldier, except the
X       spell points, which apply to the entire army.
X     */
X  int  money_maint, metal_maint, jewel_maint, spell_pts_maint;
X  Scargo cargo;
X  struct sarmy *next;		/* pointer to next army             */
X};
Xtypedef struct sarmy Sarmy;
X
Xstruct pt_list {
X  Pt pt;			/* list of owned sectors */
X  struct pt_list *next;
X};
X
X  /* this contains the basic properties of a race, which are read in
X     from the "races" file.  this does NOT include other attributes
X     gained later by a nation.
X   */
Xstruct srace {
X  char name[NAMELEN];
X  char mark;			/* to represent them on map */
X  int strength, repro, mortality, intel, speed, stealth;
X  int pref_alt, pref_terrain, pref_climate;
X  int mag_apt, farming, mining;
X};
Xtypedef struct srace Srace;
X
Xstruct race_list {
X  Srace race;
X  struct race_list *next;
X};
X
X/* This structures stores a nations options */
Xstruct soptions {
X  int expert_mode;
X  int civ_movemode;
X  char *mail_forward;
X  char *mail_reader;
X};
Xtypedef struct soptions Soptions;
X
Xstruct snation {
X  int id;			/* for quick search */
X  char name[NAMELEN];
X  char leader[NAMELEN];
X  char passwd[PASSLEN];		/* encrypted, of course */
X  Pt capital;			/* coordinates of main city */
X  Srace race;
X  Symbol mark;			/* nation mark */
X    /* parameters that influence the economy */
X  int taxes, taxtype, charity, money, jewels, metal, food, n_sects,
X      tech_r_d, tech_r_d_metal, mag_r_d, mag_r_d_jewels, spy_r_d,
X      npc_flag, npc_agg, npc_exp, npc_iso; /* NPC performance values */
X  
X  char mag_order[NAMELEN];	/* which magical order they belong to */
X  int tech_skill, mag_skill, farm_skill, mine_skill; /* skills */
X  int spell_pts;		/* available spell points */
X    /* military stuff */
X  int attack, defense, spy, secrecy;
X  int n_armies;
X  Sarmy *armies;		/* linked list of armies */
X  struct pt_list *ptlist;	/* list of owned points */
X  int cur_mag_r_d, cur_mag_r_d_jewels;
X  int cur_tech_r_d, cur_tech_r_d_metal;
X  int cur_spy_r_d;
X  Soptions *opts;
X};
Xtypedef struct snation Snation;
X
X#define NORMAL_MAP  0		/* map_style: non-compact map display */
X#define COMPACT_MAP 1		/* map_style: compact map display */
X#define DESIGNATION 0		/* display: show sector designation */
X#define NATION_MARK 1		/* display: show nation mark */
X#define SOIL        2		/* display: show vegetation */
X#define METAL	    3		/* etc... */
X#define JEWELS      4
X#define ALTITUDE    5
X#define CLIMATE     6
X#define POPULATION  7
X#define MOVECOST    8
X#define TERRAIN     9
X#define ARMY_MOVECOST 10
X
X#define H_NONE        0		/*            don't highlight */
X#define H_OWNED       1		/* highlight: if you own sector */
X#define H_ARMIES      2		/*            if there are armies */
X#define H_YOUR_ARMIES 3		/*            if they are your armies */
X#define H_OTHER_ARMIES 4	/*            if they are not yours */
X#define H_MOVE_LEFT   5		/*            if armies can move */
X#define H_UNEMP       6		/*            if there are civ's unemployed */
X#define H_HOSTILE     7		/*            if the sector is hostile */
X
X  /* the following prepare the ground for the exec list array */
X#define N_EXEC_ARGS 12		/* for now, exec has 8 args */
X#define N_EXECS     2		/* # of exec commands before we save to file */
X#define EXECLEN     100		/* max length of exec string */
X
X  /* spell structure, used for describing a spell, and also
X     for giving each user a list of available spells
X   */
Xstruct sspell {
X  char name[NAMELEN];		/* name of spell */
X  int cost, duration;
X/*  int (*spell_func)();          /* pointer to function that does the work */
X  struct sspell *next;		/* for a linked list */
X};
Xtypedef struct sspell Sspell;
X
Xstruct sh_spell {
X  int nat_id;
X  char name[NAMELEN];
X  int thons_left;
X  int n_lines;
X  char **lines;
X  struct sh_spell *next;
X};
Xtypedef struct sh_spell Sh_spell;
X
X  /* avail army structure, used for describing available armies */
Xstruct savail_army {
X  char type[NAMELEN];		/* type of army */
X  struct savail_army *next;	/* for a linked list */
X};
Xtypedef struct savail_army Savail_army;
X
X  /* spirit structure, used for describing available spirits */
Xstruct sspirit {
X  char type[NAMELEN];		/* type of spirit */
X    /* cost can be different for different
X       mag orders, even if it is the same
X       spirit
X     */
X  int cost;
X  struct sspirit *next;		/* for a linked list */
X};
Xtypedef struct sspirit Sspirit;
X
X/* the following structure is the matrix used for diplomacy */
X/* for more info, see diplomacy.c */
Xstruct sdiplo {
X  int self_id, neighbor_id;  /* player, and his neighbor */
X  int status;                /* status from player to neighbor */
X};
Xtypedef struct sdiplo Sdiplo;
X
X  /* this structure describes run-time information for the user
X     currently playing.  It is contains their nation struct.
X   */
Xstruct suser {
X  int id;			/* nation id */
X  Snation *np;			/* describe her/his nation */
X  Pt cursor, center;		/* current sector and middle of screen */
X  char help_char;		/* char used to get help */
X    /* display styles */
X  int map_style, display, highlight, underwater;
X  int **visible_sectors;	/* which sectors can the user see? */
X  Sdiplo **diplo_matrix;	/* fast-access diplo matrix */
X  int n_execs;			/* how many exec lines already there */
X  char exec_lines[N_EXECS][EXECLEN];
X  int current_army;		/* army that has been picked */
X  int just_moved;		/* has the user just moved? */
X    /* how much did we have at the start of the turn */
X  int init_money, init_metal, init_jewels, init_food;
X/*should have other run-time info, taken from world parameters, like date*/
X    /* available types armies to that user */
X  Savail_army *avail_armies;
X    /* this is read in at the beginning of a session, and has a
X       list of spells available to this user.  same thing for spirits.
X     */
X  Sspell *spell_list;
X  Sh_spell *h_spells;
X  Sspirit *spirit_list;
X    /* this is a funny global variable, needed for
X       consistency in drawing the army list
X     */
X  int last_n_armies;
X    /* number of army/spirit types there are */
X  int n_army_types, n_spirit_types;
X    /* now some user-configurable options */
X  int xmode, show_sect_win;
X};
Xtypedef struct suser Suser;
X
Xstruct ssector {
X  Pt loc;		/* x, y coords */
X	/* if terrain is water, some of these don't apply */
X        /* a lot must be re-considered here */
X  int terrain, altitude, climate, designation, soil, metal, jewels;
X  int defense;			/* defense bonus in sector */
X  int roads;			/* how easy to travel */
X  int owner;			/* index of sector's owner */
X  int n_people;			/* civilians in that sector */
X  long flags;			/* sector flags */
X  char name[NAMELEN];		/* you can name a sector!!! */
X    /* the sector has a list of army id's, where the owner and army
X       id are stored, so the army can be obtained from the nation's
X       army list.
X     */
X  struct armyid *alist;
X};
Xtypedef struct ssector Ssector;
X
X  /* world topology type */
X#define TORUS 0
X
X/* extern Pt wrap();		/* this func. determines topology */
X
Xstruct sworld {
X  int turn;
X  int xmax, ymax;
X  Ssector **map;
X  struct {
X    int topology;		/* topology type */
X    int pwater;			/* % water in world */
X    double metal_avg, jewel_avg, soil_avg; /* averages for the world */
X  } geo;			/* geography */
X  int n_nations;		/* how many nations are actually there? */
X  Snation nations[NATIONS];
X};
Xtypedef struct sworld Sworld;
X
Xstruct argument {
X  int type;
X  union {
X    int num;
X    char str[20];
X  } data;
X};
X
X#define NUM 0    /* values for -type- field of above structure */
X#define TXT 1
X
X#define NUMCMDS 200
X
X  /* declare malloc() as returning a void *.  Don't even
X     try including malloc.h, since it is not there on very
X     many systems.  If you don't have type "void", then
X     you can make it be "char *malloc()".
X   */
Xvoid *malloc();
X
X#ifndef max
X#define max(a,b) ((a)<(b) ? (b) : (a))
X#endif
X#ifndef min
X#define min(a,b) ((a)>(b) ? (b) : (a))
X#endif
X
X#ifdef PMAX
X#define mvwprintw mymvwprintw
X#endif
END_OF_FILE
if test 13830 -ne `wc -c <'dominion.h'`; then
    echo shar: \"'dominion.h'\" unpacked with wrong size!
fi
# end of 'dominion.h'
fi
if test -f 'int_mail.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'int_mail.c'\"
else
echo shar: Extracting \"'int_mail.c'\" \(15808 characters\)
sed "s/^X//" >'int_mail.c' <<'END_OF_FILE'
X  /* mailer.c -- dominion mail reading system by Stephen Underwood */
X  /*                                          and Doug Novellano :) */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include <stdio.h>
X#ifdef AMIGA
X# include <exec/types.h>
X# include <string.h>
X#else
X# include <sys/types.h>
X#endif
X
X#include <time.h>
X#ifdef SYSV
X# include <string.h>
X#else
X# include <strings.h>
X#endif
X#include <ctype.h>
X
Xextern Suser user;
Xextern Sworld world;
Xextern char *libdir;
Xextern int ruid, euid;
X
Xstruct message {
X  struct message_body *body;
X  char status;
X  struct message *next;
X};
X  
Xstruct message_body {
X  char *line;
X  struct message_body *next;
X};
X
X/* Read the persons mail. Reader is the name
X   of the nations whose mail is to be read.
X */
Xint mail_read(reader)
X     int reader;
X{
X  FILE *lock_fp;
X  char mail_command[100],mail_file[PATHLEN];
X  char lock_fn[100], *mail_prog, *getenv();
X#ifdef UID_SECURITY
X      int pid;
X#endif
X
X/*
X  if ((mail_prog=getenv("DOMINION_MAIL"))==NULL) {
X    mail_prog=(char *)malloc(sizeof(DEFAULT_MAIL));
X    strcpy(mail_prog, DEFAULT_MAIL);
X  }
X*/
X  mail_prog = world.nations[reader].opts->mail_reader;
X
X/* This is going to be essentially what's in int_mail.c */
X  if (mail_prog == NULL) 
X  {
X    sprintf(mail_file,"%s/mail.%d",MAIL_DIR, reader);
X    printf("\n\n");
X    fflush(stdin);
X    fflush(stdout);
X    mail_reader(mail_file);
X  }
X  else /* We want to use our own mail program */
X  {
X    char tmp_fname[PATHLEN];
X    cleanup(); /* Get ready to leave the system */
X    /* we must make the file read/modify-able.  is this a security prob? */
X/* Yes it was */
X/*      sprintf(mail_command, "chmod 666 \"%s/mail.%d\"", MAIL_DIR, reader);
X      system(mail_command);
X*/
X    strcpy(tmp_fname,"/usr/tmp/dom_XXXXXX");
X    mktemp(tmp_fname);
X    sprintf(mail_command, "cp %s/mail.%d %s", MAIL_DIR, reader,tmp_fname);
X    system(mail_command);
X    sprintf(mail_command, "chmod 666 %s", tmp_fname);
X    system(mail_command);
X
X#ifdef UID_SECURITY
X      /* we must fork, so that in the child we set the
X	 real user id, whereas the parent continues with
X	 the effective user id.
X	 */
X
X      if ((pid=fork()) == 0) {		/* child has fork() == 0 */
X	  setuid(getuid());		/* so this user cannot poke around */
X#endif
X    sprintf(mail_command, "%s -f %s", mail_prog, tmp_fname);
X    system(mail_command);
X#ifdef UID_SECURITY
X	  exit(0);
X      }
X      else if (pid < 0)
X	  perror("Could not fork mailer");
X      else
X	  while (wait(0) != pid);
X#endif UID_SEQURITY
X    sprintf(mail_command,"cp %s %s/mail.%d",tmp_fname,MAIL_DIR,reader);
X    system(mail_command);
X    unlink(tmp_fname);
X
X    init_screen(); /* Resetup the screen after coming back */
X  }
X}
X
Xchar *get_line(fp)
X/* Gets a single line from the file fp and returns it, or returns NULL */
XFILE *fp;
X{
X  char *temp;
X
X  if ((temp = (char *)malloc((COLS+1) * sizeof(char))) == NULL) mem_error();
X  if ( (fgets(temp,COLS-1,fp) == NULL))
X  {
X    free(temp);
X    return NULL;
X  } 
X  temp[COLS-1] = '\0';
X  if (temp[strlen(temp) -1] != '\n') strcat(temp,"\n");
X  return temp;
X}    
X
Xis_fromline(s)
X/* Determines if the string passed it is the start of a new message */
Xchar *s;
X{
X  if (s == NULL) return 0;
X  if (strncmp(s,"From ",5) == 0) return 1;
X  return 0;
X}
X
Xadd_line(mbody, text)
X/* Adds a new line onto the end of the message passed to it. */
Xstruct message_body **mbody;
Xchar *text;
X{
X  struct message_body *last_mbody = *mbody, *temp;
X
X  if (*mbody == NULL)
X  {
X    if ((*mbody = (struct message_body *) malloc(sizeof(struct message_body)))
X             == NULL) { 
X      mem_error();
X    }
X    (*mbody)->next = NULL;
X    (*mbody)->line = text;
X  } else
X  {
X    while (last_mbody->next != NULL) last_mbody = last_mbody->next;
X    if ((temp = (struct message_body *) malloc(sizeof(struct message_body)))
X             == NULL) {
X      mem_error();
X    }
X    last_mbody->next = temp;
X    temp->next = NULL;
X    temp->line = text;
X  }
X}
X
Xmail_reader(fname)
X/* 
X  This routine acts like a very simple mail program, in that it allows
X  the user to read their mail, and to delete messages, and even to write
X  the messages to a file.  However you are still required with this program
X  to proceede linearly one message at a time through all your mail.
X*/
Xchar *fname;
X{
X  FILE *fp, *fpout, *fopen(); /* fp is the mailfile fpout is a temp file */
X  char outfname[PATHLEN], cmd[2*PATHLEN];
X  int wrote_to_outfile = 0, num_mess;
X  struct message *first_mesg = NULL;
X
X  if ((fp = fopen(fname,"r")) == NULL) /* Open the mail file */
X  {
X    fprintf(stderr,"No Mail\n");
X    return 0;
X  }
X  sprintf(outfname, "%s.out", fname);
X  if ((fpout = fopen(outfname,"w")) == NULL) /* Open our temp file */
X  {
X    fprintf(stderr,"Error: Can't open Temporary Mailfile\n");
X    return 0;
X  }
X  if ((num_mess = load_messages(fp,&first_mesg)) < 1 )
X  {
X    fprintf(stderr,"No Mail\n");
X    return 0;
X  }
X/*  initscr(); */
X  display_messages(first_mesg,num_mess);
X  if (write_messages(fpout, first_mesg) != 0)
X  {
X    fclose(fpout); /* Close the temporary file */
X    sprintf(cmd,"mv %s %s",outfname,fname);  /* then replace the mailfile */
X  } else
X  {
X    fclose(fpout); /* Close the temporary file */
X    sprintf(cmd,"rm %s",fname); /* Otherwise remove the mailfile */
X    unlink(outfname);
X  }
X#ifdef UID_SECURITY
X  if (fork() == 0) {		/* child has fork() == 0 */
X    setuid(getuid());
X    system(cmd);
X    exit(0);
X  }
X#else
X  system(cmd);
X#endif
X  
X  clear_messages(first_mesg);
X}
X
Xput_mesg_to_file(mbody)
X/*
X   This function is to write the given message out to a file the
X   user specifies
X*/
Xstruct message_body *mbody;
X{
X  FILE *fp, *fopen();
X  char fname[PATHLEN];
X  extern int ruid, euid;
X#ifdef BSD
X extern char current_dir[];
X#else /* BSD */
X extern char *current_dir;
X#endif
X
X  printw("Name of File? ");
X  refresh();
X  wget_string(stdscr,fname,PATHLEN-1);
X  if (fname[strlen(fname)-1] == '\n') fname[strlen(fname)-1] = '\0';
X
X#ifdef UID_SECURITY
X  if (fork() == 0) {		/* child has fork() == 0 */
X      /* first change back to the user's current directory */
X    setuid(ruid);
X    chdir(current_dir);
X    if ((fp = fopen(fname, "w")) == NULL) {
X      fprintf(stderr,"Error: could not write to file %d",fname);
X      exit(0);
X    }
X    put_mesg(fp,mbody);
X    fclose(fp);
X    exit(0);
X  }
X  wait(0);
X#else /* UID_SECURITY */
X  chdir(current_dir);
X  if ((fp = fopen(fname, "w")) == NULL) {
X    fprintf(stderr,"Error: could not write to file %d",fname);
X    return -1;
X  }
X  put_mesg(fp,mbody);
X  fclose(fp);
X  chdir(libdir);
X#endif /* UID_SECURITY */
X
X  return 0;
X}
X
Xput_mesg(fp,mbody)
X/* This function puts the given message into the file passed to it */
XFILE *fp;
Xstruct message_body *mbody;
X{
X  struct message_body *curr = mbody;
X
X  while (curr != NULL)
X  {
X    fprintf(fp,"%s",curr->line);
X    curr = curr->next;
X  }
X}
X
Xclear_mesg(mbody)
X/* Clean up the memory for a given message */
Xstruct message_body **mbody;
X{
X  struct message_body *curr = *mbody, *temp;
X
X  while (curr != NULL)
X  {
X    temp = curr;
X    curr = curr->next;
X    if (temp->line != NULL) free(temp->line);
X    if (temp != NULL) free(temp);
X  }
X  *mbody = NULL;  /* And clean up the beginning */
X}
X
Xadd_rest(fpout, fpin)
X/* Add the rest of the mailfile to the temporary output file */
XFILE *fpout, *fpin;
X{
X  int c;
X
X  while ((c = fgetc(fpin)) != EOF)
X  {
X     fputc(c,fpout);
X  }
X}
X
Xget_message(fp, mbody, first_flag)
Xint first_flag;
Xstruct message_body **mbody;
XFILE *fp;
X{
X  static char *from_line = NULL;
X  char *curr_text;
X  int first_line = first_flag;
X
X  while ((curr_text = get_line(fp)) != NULL) {
X    if ((is_fromline(curr_text)) && (!first_line))
X    { /* If it's the begining of any message but the first */
X      from_line = curr_text; /* save the beginning line of the next message*/
X      return 0;
X    }
X    if (from_line != NULL) /* If we have a leftover first line */
X    {
X      add_line(mbody, from_line);  /* Add it to the message */
X      from_line = NULL;
X    }
X    add_line(mbody, curr_text); /* Add the current line to the mesg */
X    first_line = 0;
X  }
X
X /* If it's the end of the file return 1 */
X  return 1;
X}
X
Xprint_message(mbody)
Xstruct message_body *mbody;
X{
X  int curr_line = 0, i;
X  struct message_body *curr = mbody;
X  char temp[100];
X
X  clear(); refresh();
X  if (curr != NULL) { curr = curr->next; } /* Don't print from line */
X  while (curr != NULL)
X  {
X    printw("%s",curr->line); /* Print out the next line */
X    if ( ++curr_line >= (LINES - 1))
X    { /* break for the end of the scren */
X      printw("---More--- Press return to cont. j to jump to next message : ");
X      refresh();
X      wget_string(stdscr,temp,39);
X      clear();
X      curr_line = 0;
X      if ((temp[0] == 'j') || (temp[0] == 'J')) 
X      {
X        return 0;
X      }
X    }
X    curr = curr->next;
X  }
X  printw("Press return to continue");
X  refresh();
X  wget_string(stdscr,temp,39);
X  curr_line = 0;
X}
X
Xload_messages(fp,first_mesg)
XFILE *fp;
Xstruct message **first_mesg;
X{
X  int file_over = 0, num_mess = 0, first_flag = 1;
X  struct message *curr_mesg = NULL;
X  struct message_body *curr_mbody = NULL;
X
X  do {
X    file_over = get_message(fp, &curr_mbody, first_flag);
X    if ( curr_mbody == NULL ) { break; }
X    num_mess++;
X    if (curr_mesg == NULL)
X    {
X      if ((curr_mesg = (struct message *)malloc(sizeof (struct message)))
X          == NULL) { mem_error(); }
X      *first_mesg = curr_mesg;
X    } else
X    {
X      if ((curr_mesg->next = (struct message *)malloc(sizeof (struct message)))
X          == NULL) { mem_error(); }
X      curr_mesg = curr_mesg->next;
X    }
X    curr_mesg->body = curr_mbody;
X    curr_mbody = NULL;
X    curr_mesg->next = NULL;
X    curr_mesg->status = ' ';
X    first_flag = 0; /* Stop special handling for first message */
X  } while (file_over != 1);
X
X  return num_mess;
X}
X
Xwrite_messages(fp, first_mesg)
XFILE *fp;
Xstruct message *first_mesg;
X{
X  struct message *curr_mesg = first_mesg;
X  int rtvl = 0;
X
X  while ( curr_mesg != NULL )
X  {
X    switch (curr_mesg->status)
X    {
X      case 'd': break;
X      default: {
X	rtvl = 1;
X        put_mesg(fp,curr_mesg->body);
X        break;
X      }
X    }
X    curr_mesg = curr_mesg->next;
X  }
X  return rtvl;
X}
X
Xstruct message *get_mesg_by_number(first, num)
Xstruct message *first;
Xint num;
X{
X  struct message *curr_mesg = first;
X  int i = 0;
X
X  if (num < 0) { return NULL; }
X  while (i < num) {
X    if (curr_mesg == NULL) { return NULL; }
X    curr_mesg = curr_mesg->next;
X    i++;
X  }
X
X  return curr_mesg;
X}
X
Xchar *get_from(mesg)
Xstruct message *mesg;
X{
X  struct message_body *curr_line = mesg->body;
X
X  while (curr_line != NULL) {
X    if (curr_line->line == NULL) { continue; }
X    if (strncmp(curr_line->line, "From: ", strlen("From: ")) == 0) {
X      return &(curr_line->line[6]);
X    }
X    curr_line = curr_line->next;
X  }
X  return NULL;
X}
X
Xchar *get_subject(mesg)
Xstruct message *mesg;
X{
X  struct message_body *curr_line = mesg->body;
X
X  while (curr_line != NULL) {
X    if (curr_line->line == NULL) { continue; }
X    if (strncmp(curr_line->line, "Subject: ", strlen("Subject: ")) == 0) {
X      return &(curr_line->line[9]);
X    }
X    curr_line = curr_line->next;
X  }
X  return NULL;
X}
X
Xdisplay_messages(first_mesg,num_mess)
Xint num_mess;
Xstruct message *first_mesg;
X{
X  struct message *curr_mesg = first_mesg, *temp_mesg;
X  struct message_body *curr_mbody;
X  int user_quit = 0, num_top = 0, num_bottom, num_curr = 0, i, j;
X  int chose_option, do_refresh = 1, x, y, oldx, oldy;
X  char temp[40], *from, *subject;
X#define USED_LINES 8
X
X  while ( user_quit == 0 )
X  {
X    if (do_refresh == 1) {
X      clear(); refresh();
X      num_bottom = num_top + (LINES - USED_LINES);
X      move(1, 0);
X      for (i = num_top;i <= num_bottom; i++)
X      {
X        if ((temp_mesg = get_mesg_by_number(first_mesg, i)) == NULL) {
X          break;
X        }
X        from = get_from(temp_mesg);
X        subject = get_subject(temp_mesg);
X        printw("          %c%.2d %c ",(i == num_curr)?'*' : ' ',i,
X               temp_mesg->status);
X        for(j = 0; (j < 30) && (from[j] != '\0') && (from[j] !='\n') ; j++)
X        {
X          addch(from[j]);
X        }
X        for ( j = j - 1; j < 30  ; j++) { addch(' '); }
X        addch(' ');
X        for(j = 0; (j < 30)&&(subject[j] != '\0')&& (subject[j] !='\n') ; j++)
X        {
X          addch(subject[j]);
X        }
X        for ( j = j - 1; j < 30  ; j++) { addch(' '); }
X        addch('\n');
X      }
X      do_refresh = 0;
X      addch('\n');
X      move(LINES - 4, 0);
X      printw("[R]ead curr [W]rite to file, [D]elete, [U]ndelete, [Q]uit\n");
X      printw("> for next page < for prev page Enter number to change curr\n");
X    } 
X    move(LINES - 2, 0);
X    printw("[RWDQ><#]:                ");
X    move(LINES - 2, 11);
X    refresh();
X    wget_string(stdscr,temp,39);
X    chose_option = 1;
X    if (isupper(temp[0])) { temp[0] = (char)tolower(temp[0]); }
X    switch (temp[0])
X    {
X      case 'w': do_refresh = 1; put_mesg_to_file(curr_mesg->body); break;
X      case 'd': {
X        curr_mesg->status = 'd'; 
X        getyx(stdscr,oldy,oldx);
X        move(num_curr - num_top + 1, 14);
X        addch('d');
X        getyx(stdscr, y, x);
X        mvcur(y, x, oldy, oldx);
X        move(oldy, oldx);
X        refresh();
X        break;
X      }
X      case 'u': {
X        curr_mesg->status = ' '; 
X        getyx(stdscr,oldy,oldx);
X        move(num_curr - num_top + 1, 14);
X        addch(' ');
X        getyx(stdscr, y, x);
X        mvcur(y, x, oldy, oldx);
X        move(oldy, oldx);
X        refresh();
X        break;
X      }
X      case 'r': do_refresh = 1; print_message(curr_mesg->body); break;
X      case '>': {
X         if ((num_top += (LINES - USED_LINES)) >= num_mess) { 
X           num_top -= (LINES - USED_LINES);
X         }
X         num_curr = num_top;
X         curr_mesg = get_mesg_by_number(first_mesg, num_curr);
X         do_refresh = 1;
X         break;
X      }
X      case '<': {
X         if ((num_top -= (LINES - USED_LINES)) < 0) { 
X           num_top = 0;
X         }
X         num_curr = num_top;
X         curr_mesg = get_mesg_by_number(first_mesg, num_curr);
X         do_refresh = 1;
X         break;
X      }
X      case 'q': user_quit = 1; break;
X      default: {
X        getyx(stdscr,oldy,oldx);
X        move(num_curr - num_top + 1, 10);
X        addch(' ');
X        if (isdigit(temp[0])) {
X          i = atoi(temp);
X          if ((temp_mesg = get_mesg_by_number(first_mesg, i)) != NULL) {
X            curr_mesg = temp_mesg;
X            num_curr = i;
X            if ((i < num_top) || (i > num_bottom)) {
X              num_top = i;
X              do_refresh = 1;
X	    }
X	  }
X	}
X        move(num_curr - num_top + 1, 10);
X        addch('*');
X        getyx(stdscr, y, x);
X        mvcur(y, x, oldy, oldx);
X        move(oldy, oldx);
X        refresh();
X      }
X    }
X  }
X}
X
Xclear_messages(first_mesg)
Xstruct message *first_mesg;
X{
X  struct message *curr_mesg = first_mesg, *next_mesg;
X
X  while (curr_mesg != NULL)
X  {
X    next_mesg = curr_mesg->next;
X    clear_mesg(&(curr_mesg->body));
X    free(curr_mesg);
X    curr_mesg = next_mesg;
X  }
X}
X
X/*#endif*/
END_OF_FILE
if test 15808 -ne `wc -c <'int_mail.c'`; then
    echo shar: \"'int_mail.c'\" unpacked with wrong size!
fi
# end of 'int_mail.c'
fi
if test -f 'printmap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'printmap.c'\"
else
echo shar: Extracting \"'printmap.c'\" \(13099 characters\)
sed "s/^X//" >'printmap.c' <<'END_OF_FILE'
X /* printmap.c -- print the nation */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X#include <stdio.h>
X#include <signal.h>
X#include <math.h>
X
Xextern Sworld world;
Xextern Suser user;
Xextern int debug;
Xextern int viewall;
Xextern char libdir[];
Xextern int (*wrapx)(), (*wrapy)();
X#ifdef BSD
Xextern char current_dir[];
X#else /* BSD */
Xextern char *current_dir, *getcwd();
X#endif
Xextern int euid, ruid;
X
Xint reverse_water=0;
Xint ascii_map=0;
Xint dash_sectors=0;
X#ifdef ANDREW
Xint beroot = 1;
X#endif
X
XSdiplo **allocate_diplo();
Xchar *des();
X
Xmain(argc, argv)
X     int argc;
X     char *argv[];
X{
X  char nation[NAMELEN], passwd[NAMELEN];
X  Snation *np;
X  Ssector *sp;
X  int i, j, iw, jw, ii, jj;		/* for loops */
X  int rel_xcenter, rel_ycenter, abs_xcenter, abs_ycenter;
X  int map_size, visibility, c, ascii=0;
X  int type1, type2, mark1, mark2;
X  extern char *optarg;
X  extern int optind;
X
X  /* rel_center vars are map center coords relative to your capital */
X  /* abs_center is the map center in absolute coordinates.  Secret! */
X  /* map_size is the number of sectors to display across the map    */
X  /* type1 is map shading type, type2 is desig || nation_mark text  */
X
X  strcpy(libdir, DEF_LIBDIR);
X#ifdef ANDREW
X  while ((c = getopt(argc, argv, "d:uxaWb")) != EOF) {
X#else
X  while ((c = getopt(argc, argv, "d:xaWs")) != EOF) {
X#endif
X    switch (c) {
X#ifdef ANDREW
X     case 'u':
X       beroot = 0;
X       break;
X#endif
X    case 'a':			/* ascii instead of postscript */
X      ascii = 1;
X      break;
X    case 'x':			/* debug mode */
X      debug = 1;
X      break;
X    case 'd':			/* lib directory */
X      strcpy(libdir, optarg);
X      break;
X    case 'W':			/* reverse above/below water */
X      reverse_water = 1;
X      break;
X    case 's':			/* show invisible sectors dashed */
X      dash_sectors = 1;
X      break;
X    }
X  }
X
X  /* now get some unix system information */
X#ifdef ANDREW
X  if (beroot == 1) {
X    Authenticate();
X    beGames();
X  }
X#else
X  ruid = getuid();
X  euid = geteuid();
X#endif
X
X  if (chdir(libdir) == -1) {
X    fprintf(stderr,"Error: cannot cd to directory %s\n",libdir);
X    clean_exit();
X    exit();
X  }
X  dom_print_intro();
X  load_army_types();
X  load_spirit_types();
X  get_user();			/* select & load nation */
X
X  get_display_type(&type1, &type2); /* display type (nation, desig... */
X  get_map_info(&rel_xcenter, &rel_ycenter, &map_size);
X
X  abs_xcenter = user.np->capital.x + rel_xcenter;
X  abs_ycenter = user.np->capital.y + rel_ycenter;
X
X#ifdef UID_SECURITY
X  setuid(ruid);
X#endif
X#ifdef ANDREW
X  if (beroot == 1) {
X    bePlayer();
X    unAuth();
X    beroot = 0;
X  }
X#endif
X  
X  ps_prolog(map_size, type1, type2);
X
X  ii = 0;
X  jj = map_size-1;
X
X  for (j = abs_ycenter - map_size/2; j < abs_ycenter + map_size/2; j++) {
X    for (i = abs_xcenter - map_size/2; i < abs_xcenter + map_size/2; i++) {
X      iw = (*wrapx)(i,j);
X      jw = (*wrapy)(i,j);
X      visibility = user.visible_sectors[iw][jw];
X      if (type1 != 99) {	/* do some kind of shading */
X	user.display = type1;
X	mark1 = which_mark(iw, jw, &user);
X      }
X      if (type2 != 99) {	/* do some text in sectors */
X	user.display = type2;
X	mark2 = which_mark(iw, jw, &user);
X      }
X
X      if (ascii_map) asc_mark(mark1, mark2, type1, type2, visibility);
X      else ps_mark(ii, jj, mark1, mark2, type1, type2, visibility);
X      ii++;
X    }
X
X    jj--; ii = 0;
X    if (ascii_map) printf("\n");
X  }
X  if (!ascii_map) {
X    draw_axes(map_size, rel_xcenter, rel_ycenter);
X    if (type1 != 99)
X      draw_key();
X    printf("\nshowpage\n\n");
X  }
X}
X
Xasc_mark(m, v)
X     int m, v;
X{
X}
X
X
Xdraw_key()
X{
X  printf("\ngrestore\n");
X  printf("/Times-Roman findfont 15 scalefont setfont\n");
X  printf("0 .1 1.01 { /i exch def\n");
X  printf("  /x 2.1 inch i 300 mul add def\n  /y 2 inch def\n");
X  printf("  x y moveto 18 0 rlineto 0 18 rlineto 18 neg 0 rlineto\n");
X  printf("  closepath gsave 1 i sub setgray fill grestore stroke\n");
X  printf("  x 4 add y .2 inch sub moveto i 10 mul round cvi str cvs show\n");
X  printf("  } for\n");
X}
X
X
Xdraw_axes(size, xc, yc)
X     int size, xc, yc;
X{
X  int x, y, step=1;
X
X  if (size > 50) step = 5;
X  else printf("\nsmallfont\n");
X
X  printf("\n/str 15 string def   /size %d def\n", size);
X  printf("/minx %d def  /miny %d def\n", xc-size/2, yc-size/2);
X  printf("0 %d size 1 sub { /i exch def /i2 i def\n", step);
X  printf("   i   -0.8    i minx add str cvs 1 letter  /i i2 def\n");
X  printf("   i   size    i minx add str cvs 1 letter  /i i2 def\n");
X  printf("  -1   size i sub 1 sub i miny add str cvs 1 letter  /i i2 def\n");
X  printf("  size size i sub 1 sub i miny add str cvs 1 letter\n");
X  printf("} for\n");
X}
X
Xps_prolog(size, type1, type2)
X     int size, type1, type2;
X{
X  printf("%%!\n");
X  printf("/inch { 72 mul } def\n");
X  printf("/center {dup stringwidth pop 2 div neg 0 rmoveto} bind def\n");
X  printf("/smallfont { /Courier findfont 25 scalefont setfont } def\n\n");
X
X  printf("/xaxis { /t exch def /x exch def gsave smallfont\n");
X  printf("   x .8 neg t 1 letter   x %d t 1 letter\n", size);
X  printf("   grestore } def\n");
X
X  printf("/yaxis { /t exch def /y exch def gsave smallfont\n");
X  printf("   1 neg y t 1 letter   %d y t 1 letter\n", size);
X  printf("   grestore } def\n\n");
X
X  printf("/box { newpath 0 0 moveto 0 64 lineto 64 64 lineto 64 0 lineto\n");
X  printf("     closepath } def\n\n");
X
X  printf("/graybox { /g exch def /y exch def /x exch def gsave\n");
X  printf("     x inch y inch translate box g setgray fill grestore } def\n\n");
X
X  printf("/emptybox { /y exch def /x exch def gsave\n");
X  printf("   x inch y inch translate box 0 setgray stroke grestore } def\n\n");
X
X  printf("/dashbox { /y exch def /x exch def gsave\n");
X  printf("     x inch y inch translate [3 9] 1 setdash box\n");
X  printf("     0 setgray stroke grestore } def\n");
X
X  printf("/waterbox { /y exch def /x exch def gsave\n");
X  printf("     x inch y inch translate  0 12 64 { /i exch def\n");
X  printf("       0 i moveto  64 i lineto stroke \n");
X  printf("     } for  grestore } def\n\n");
X
X  printf("/letter { /g exch def /t exch def /y exch def /x exch def\n");
X  printf("     gsave  x inch 20 add y inch 15 add translate 0 0 moveto\n");
X  printf("     g 0.5 lt { 1 setgray } { 0 setgray } ifelse\n");
X  printf("     t show grestore } def\n\n");
X
X  printf("/Times-Roman findfont 20 scalefont setfont\n");
X  printf("4.25 inch 10.5 inch moveto (%s) center show\n", user.np->name);
X  printf("/Times-Roman findfont 15 scalefont setfont\n");
X  printf("4.25 inch 10 inch moveto (%s/%s) center show\n", des(type1), des(type2));
X  printf("/Courier findfont 50 scalefont setfont\n\n");
X  printf("0.01 setlinewidth  gsave\n");
X  printf("1 inch 3 inch translate\n");
X  printf("%f %f scale\n\n", 6.5/size, 6.5/size);
X}
X
Xps_mark(x, y, m1, m2, t1, t2, vis)
X     int x, y, m1, m2, t1, t2, vis;
X{
X  float gray;
X  int other_char = '~';		/* which char represents 'other' world */
X
X  if (debug)
X    fprintf(stderr, "x=%d y=%d m1=%c m2=%c t1=%d t2=%d vis=%d\n",
X	    x, y, m1, m2, t1, t2, vis);
X
X  if (user.underwater)
X    other_char = '.';
X
X  if (vis > SEE_NOTHING) {
X    if (m1 == other_char || m2 == other_char) {
X      printf("%d %d waterbox\n", x, y);
X    } else {
X      if (t1 != 99) {		/* if we are doing shading */
X	if (m1 == 'I' || m1 == '+') gray = 0.0;
X	else gray = 1 - (float)(m1 - '0') / 10.0;
X	if (gray == 1.0)	/* make blank white box visible */
X	  printf("%d %d emptybox\n", x, y);
X	else			/* print a box of proper gray shade */
X	  printf("%d %d %3.2f graybox\n", x, y, gray);
X      }
X      if (t2 != 99) {		/* do some text */
X	if (t1 == 99) {		/* haven't done anything yet, make box */
X	  printf("%d %d emptybox\n", x, y);
X	  gray = 1.0;
X	}
X	printf("%d %d (%c) %3.2f letter\n", x, y, m2, gray);
X      }
X    }
X  } else {			/* invisible sectors are dashed */
X    if (dash_sectors)
X      printf("%d %d dashbox\n", x, y);
X  }
X}
X
Xcritical()
X{
X}
Xnoncritical()
X{
X}
Xcleanup()
X{
X}
Xclean_exit()
X{
X#ifdef ANDREW
X  if (beroot == 1) {
X    bePlayer();
X    unAuth();
X    beroot = 0;
X  }
X#endif
X}
X
X/* GET_MAP_INFO asks the user where to center the map, and what size
X   it should be */
Xget_map_info(x, y, size, type1, type2)
X     int *x, *y, *size, *type1, *type2;
X{
X  char buff[NAMELEN];
X  int temp;
X
X  *x = *y = 0;
X  *size = 30;
X  fprintf(stderr, "\nCenter the map around what sector?\n");
X  fprintf(stderr, "       x coordinate [0]: ");
X  gets(buff);
X  if (strlen(buff)) {
X    sscanf(buff, "%d", &temp);
X    *x = temp;
X  }
X  fprintf(stderr, "       y coordinate [0]: ");
X  gets(buff);
X  if (strlen(buff)) {
X    sscanf(buff, "%d", &temp);
X    *y = temp;
X  }
X  fprintf(stderr, "\nHow many sectors across the map [30]: ");
X  gets(buff);
X  if (strlen(buff)) {
X    sscanf(buff, "%d", &temp);
X    if ( (float)(temp) / 2.0 != (float)(temp / 2) ) /* even number */
X      temp++;
X    *size = temp;
X  }
X  if (*size < 10) *size = 10;
X}
X
X/* GET_DISPLAY_TYPE get's the user's choice of the display parameter */
Xget_display_type(t1, t2)
X     int *t1, *t2;
X{
X  char buff[NAMELEN], a;
X
X  fprintf(stderr, "\np: population\t A: Altitude\t w: Climate\n");
X  fprintf(stderr, "t: Terrain\t s: Soil\t m: Metal\n");
X  fprintf(stderr, "j: Jewels\t M: Movecost\t N: None\n");
X  fprintf(stderr, "\nSelect sector shading from above list [None]: ");
X
X  gets(buff);
X  a = buff[0];
X
X  switch (a) {
X  case 'p':
X    *t1 = POPULATION;
X    break;
X  case 'A':
X    *t1 = ALTITUDE;
X    break;
X  case 'w':
X    *t1 = CLIMATE;
X    break;
X  case 't':
X    *t1 = TERRAIN;
X    break;
X  case 's':
X    *t1 = SOIL;
X    break;
X  case 'm':
X    *t1 = METAL;
X    break;
X  case 'j':
X    *t1 = JEWELS;
X    break;
X  case 'M':
X    *t1 = MOVECOST;
X    break;
X  default:
X    *t1 = 99;
X    break;
X  }
X
X  fprintf(stderr, "\nn: Nation Mark\t d: Designation\t N: None\n");
X  fprintf(stderr, "\nSelect sector text from above list [designation]: ");
X
X  gets(buff);
X  a = buff[0];
X
X  switch (a) {
X  case 'N':
X    *t2 = 99;
X    break;
X  case 'n':
X    *t2 = NATION_MARK;
X    break;
X  case 'd':
X  default:
X    *t2 = DESIGNATION;
X    break;
X  }
X}
X
X/* GET_USER actually takes care of reading in the world, selecting and
X   loading a nation, and setting up data (such as visibility) */
Xget_user()
X{
X  char nation[NAMELEN], passwd[NAMELEN];
X  int i;
X
X  read_world(&world, WORLD_FILE);
X  fprintf(stderr, "Enter nation name: ");
X  getline(nation, NAMELEN);
X  user.id = get_nation_id(nation);
X  get_crypt_pass("Your password: ", passwd, NULL, NULL);
X  if (strcmp(world.nations[user.id].passwd, passwd)) {
X    fprintf(stderr, "\nInvalid password.  AND, *I* only give you one try!\n");
X    exit(1);
X  }
X  user.np = &world.nations[user.id];
X
X  user.avail_armies = NULL;
X  get_avail_armies(&user, user.np->tech_skill);
X
X  user.spell_list = NULL;
X  user.spirit_list = NULL;
X  get_spells(&user, user.np->mag_skill);
X  get_spirits(&user, user.np->mag_skill);
X
X  if (user.id != 0)		/* Gamemaster is already loaded   */
X    load_nation(user.id, user.np); /* load their exec file etc    */
X
X  user.underwater = 0;
X  if (user.np->race.pref_alt < 0) /* set underwater preference   */
X    user.underwater = 1;
X  if (user.id == 0)		/* give Gamemaster clairvoyance */
X    viewall = 1;
X
X  user.diplo_matrix = allocate_diplo(world.n_nations);
X  read_in_diplo(user.diplo_matrix, world.n_nations);
X
X  user.visible_sectors = (int **) malloc(world.xmax*sizeof(int *));
X  for (i = 0; i < world.xmax; ++i)
X    user.visible_sectors[i] = (int *) malloc(world.ymax*sizeof(int));
X  find_visible_sectors(user.visible_sectors);
X
X  chdir("..");
X}
X
X
Xdom_print_intro()
X{
X  fprintf(stderr, "\ndom_print - postscript map printer\n\n");
X  fprintf(stderr, "Redirect output to file or pipe to printer.\n\n");
X  fprintf(stderr, " -d dir = set lib directory\n");
X  fprintf(stderr, " -W = invert above/below water\n");
X  fprintf(stderr, " -s = show invisible sectors dashed\n\n");
X}
X
X
Xchar *des(x)
X     int x;
X{
X  switch (x) {
X  case POPULATION:
X    return "Population";
X  case ALTITUDE:
X    return "Altitude";
X  case CLIMATE:
X    return "Climate";
X  case TERRAIN:
X    return "Terrain";
X  case SOIL:
X    return "Soil";
X  case METAL:
X    return "Metal";
X  case JEWELS:
X    return "Jewels";
X  case MOVECOST:
X    return "Movecost";
X  case DESIGNATION:
X    return "Designation";
X  case NATION_MARK:
X    return "Nation Mark";
X  default:
X    return " ";
X  }
X}
X
X
END_OF_FILE
if test 13099 -ne `wc -c <'printmap.c'`; then
    echo shar: \"'printmap.c'\" unpacked with wrong size!
fi
# end of 'printmap.c'
fi
if test -f 'races' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'races'\"
else
echo shar: Extracting \"'races'\" \(1640 characters\)
sed "s/^X//" >'races' <<'END_OF_FILE'
X# this is the races file.  the format is:
X#   - comments at the start (like this one)
X#   - a line with the number of races defined in here
X#   - comments about the next race described
X#   - strings, chars and numbers describing the race, following
X#     the fields of the structure Srace, defined in dominion.h
X#   - repeat these last 2 steps, for as many races as prescribed
X#     at the beginning of this file
X#   - a section at the end with a list of army types that are
X#     specific to that race.  these require no technology to
X#     acquire
X#
X# for now I have defined Humans, Elves, Orcs, Dwarves, Hobbits, Merfolk,
X# Icefolk, Gnomes, Harpies, Ogres, Walruses, Algae, Squid
X#
X# DO NOT REMOVE THIS NUMBER!!! IT STATES HOW MANY RACES ARE DEFINED!!!
X13
X# Here is a list of the fields in the structure:
X#name:mark:str.:repro.:mortality:intel.:speed:stealth:pref_alt:pref_terrain:pref_climate:mag_apt:farming:mining
X#
XHuman	:H:80:11: 8:50:65:4: 2: 3: 7:30: 0:0
X#
XElf	:E:70: 8: 5:70:80:8: 2: 5: 7:55:10:-15
X#
XOrc	:O:50:15:10:20:40:3: 4: 4: 4:35: 0:5
X#
XDwarf	:D:95: 9: 6:60:40:2: 5: 3: 6:30:-5:20
X#
XHobbit	:h:15:10: 7:45:50:9: 3: 4: 7:20: 5:5
X#
XMerfolk	:M:30: 7: 4:75:80:7:-2:-1: 4:55:50:-10
X#
XIcefolk	:I:90: 9: 7:50:70:4: 3: 0:10:30:50:0
X#
XGnome   :G:75:10: 8:95:40:9: 4: 3: 5:10: 0:10
X#
XHarpy   :y:40:12:10:25:60:5: 5: 4: 6:30: 0:-5
X#
XOgre    :o:95: 5: 3:75:60:5: 4: 3: 6:50: 5:5
X#
XWalrus  :W:95: 9: 7:30:80:3:-1:-1: 7:55:50:5
X#
XAlgae   :A:15:11: 6:50:60:7:-2:-1: 3:45:80:0
X#
XSquid   :S:40: 9: 8:25:110:8:-2:-1:5:40:50:15
X#
X# now the race-specific army types
XOrc_armies:Orcs
XHarpy_armies:Harpies
XHobbit_armies:Hobbits
XOgre_armies:Ogres
END_OF_FILE
if test 1640 -ne `wc -c <'races'`; then
    echo shar: \"'races'\" unpacked with wrong size!
fi
# end of 'races'
fi
if test -f 'spelllib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spelllib.c'\"
else
echo shar: Extracting \"'spelllib.c'\" \(12959 characters\)
sed "s/^X//" >'spelllib.c' <<'END_OF_FILE'
X  /* spelllib.c -- handls loading spells for a nation, and keeping
X                   them "hanging" for a certain number of turns.
X   */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X
X#include <stdio.h>
X
X  /* army and spirit types */
Xextern struct army_type *army_types;
Xextern struct spirit_type *spirit_types;
X
Xextern Sworld world;
Xextern int debug;
Xextern Sh_spell *hanging_spells;
X
Xextern Sh_spell *dead_spells;
Xextern Suser user;
X
X
X  /* this writes out the hanging spells after the update, decreasing
X     the thons_left parameter by one, and removing the spell
X     once the thons_left reaches zero.
X   */
Xwrite_h_spells()
X{
X  FILE *hang_fp, *fopen();
X  char line[EXECLEN];
X  int i;
X  Sh_spell *h_spells;
X
X  if ((hang_fp = fopen(HANGING_SPELLS_FILE, "w")) == NULL) {
X    printf("cannot write file %s\n", HANGING_SPELLS_FILE);
X    return -1;
X  }
X  for (h_spells=hanging_spells; h_spells != NULL; h_spells = h_spells->next) {
X      /* only write them out if they have not expired */
X    if (h_spells->thons_left != -1) {
X      fprintf(hang_fp, "%s\n", h_spells->name);
X      fprintf(hang_fp, "%d\n", h_spells->nat_id);
X      fprintf(hang_fp, "%d\n", h_spells->thons_left);
X      fprintf(hang_fp, "%d\n", h_spells->n_lines);
X      for (i = 0; i < h_spells->n_lines; ++i) { /* write out the exec lines */
X	fprintf(hang_fp, "%s", h_spells->lines[i]);
X	  /* we might need to tack on a newline */
X	if (h_spells->lines[i][strlen(h_spells->lines[i])-1] != '\n') {
X	  fprintf(hang_fp, "\n");
X	}
X      }
X    }
X  }
X  fclose(hang_fp);
X}
X
X  /* we need list as a pointer to pointer, so as to add at
X     the start of the list (which is easy and fast)
X   */
Xadd_h_spell(listp, h_spellp)
X     Sh_spell **listp, *h_spellp;
X{
X  Sh_spell *tmp;
X
X  if (listp) {			/* list should not be null in this func. */
X    tmp = (Sh_spell *)malloc(sizeof(Sh_spell));
X    *tmp = *h_spellp;
X    tmp->next = *listp;
X    *listp = tmp;
X  }
X}
X
X  /* removes a hanging spell from the list */
Xdelete_h_spell(listp, h_spellp)
X     Sh_spell **listp, *h_spellp;
X{
X}
X
X  /* prepares a new hanging spell structure, to be
X     filled in with its exec lines
X   */
Xprepare_h_spell(h_spellp, name, nat_id, thons_left, n_lines)
X     Sh_spell *h_spellp;
X     char name[];
X     int nat_id, thons_left, n_lines;
X{
X  int i;
X
X  strcpy(h_spellp->name, name);
X  h_spellp->next = NULL;
X  h_spellp->nat_id = nat_id;
X  h_spellp->thons_left = thons_left;
X  h_spellp->n_lines = n_lines;
X  h_spellp->lines = (char **)malloc(h_spellp->n_lines*sizeof(char*));
X  for (i = 0; i < h_spellp->n_lines; ++i) {
X    h_spellp->lines[i] = (char *)malloc(EXECLEN*sizeof(char));
X    strcpy(h_spellp->lines[i], "");
X  }
X}
X
X/* compares 2 hanging spells and returns 0 if same 1 if not */
Xh_spell_compare(sp1, sp2)
XSh_spell *sp1, *sp2;
X{
X  int i;
X
X  if (sp1->nat_id != sp2->nat_id) return 1;
X  if (sp1->thons_left != sp2->thons_left) return 1;
X  if (sp1->n_lines != sp2->n_lines) return 1;
X  if (strncmp(sp1->name, sp2->name,NAMELEN) != 0) return 1;
X  for (i = 0 ; i < sp1->n_lines; i++)
X  {  
X    if (strcmp(sp1->lines[i], sp2->lines[i]) != 0) return 1;
X  }
X  return 0;
X};
X
Xis_dead_spell(sp,flag)
Xint flag;
XSh_spell *sp;
X{
X  Sh_spell *tmp;
X
X  tmp = dead_spells;
X  while (tmp != NULL)
X  {
X    if (h_spell_compare(tmp,sp) == 0)
X    { 
X      got_dead_h_spell(tmp);
X      return 1;
X    }
X    tmp = tmp->next;
X  }
X  return 0;
X}
X
Xload_dead_hspells(up,flag)
Xint flag;
X     Suser *up;			/* up can also be NULL */
X{
X  FILE *dead_fp, *fopen();
X  int done = 0, i;
X  char line[EXECLEN], filename[PATHLEN];
X  Sh_spell h_spell;
X
X  sprintf(filename,"exec/%s.%d","dead_spells",up->id);
X  if ((dead_fp = fopen(filename, "r")) == NULL) {
X    if (debug) printf("no file %s\n", filename);
X    return -1;
X  }
X  while (!done) {
X    h_spell.next = NULL;
X    if (fscanf(dead_fp, "%s", h_spell.name) < 0) {
X      done = 1;			/* useless? */
X      break;
X    }
X    fscanf(dead_fp, "%d", &h_spell.nat_id);
X    fscanf(dead_fp, "%d", &h_spell.thons_left);
X    fscanf(dead_fp, "%d", &h_spell.n_lines);
X    if (debug) {
X      printf("nation id %d, spell <%s>, time_left = %d, n_lines = %d\n",
X	   h_spell.nat_id, h_spell.name, h_spell.thons_left, h_spell.n_lines);
X    }
X    h_spell.lines = (char **)malloc(h_spell.n_lines * sizeof(char *));
X
X    for (i = 0; i < h_spell.n_lines; ++i) { /* read in the exec lines */
X      h_spell.lines[i] = (char *)malloc(EXECLEN*sizeof(char));
X      fscanf(dead_fp, "%s", h_spell.lines[i]);
X    }
X    add_h_spell(&dead_spells, &h_spell);
X  }
X  fclose(dead_fp);
X  if (flag == 1) { unlink(filename); }
X}
X
X  /* this is fundamental:  it loads all spells from the global
X     "hanging_spells" file and runs the exec lines it finds.
X     Note:  it must load all the spells, not just those for the
X     current user, because spells by other users affect the current
X     user too.  One effect is that spells, like diplomacy, take
X     immediate effect, rather than waiting for the update.  Hmm,
X     is that good or bad?
X
X     At the same time, the spells of the current user (if we are in
X     the game rather than the update) are stored into a list for that
X     user to examine, apart from the global list.
X   */
X
Xload_h_spells(up)
X     Suser *up;			/* up can also be NULL */
X{
X  FILE *hang_fp, *fopen();
X  int done = 0, i;
X  char line[EXECLEN];
X  Sh_spell h_spell;
X  struct argument exec_args[N_EXEC_ARGS];
X  Snation *np;
X
X    /* start with the global list being NULL */
X  hanging_spells = NULL;
X  if (up) {
X    up->h_spells = NULL;
X  }
X  if ((hang_fp = fopen(HANGING_SPELLS_FILE, "r")) == NULL) {
X    if (debug) printf("no file %s\n", HANGING_SPELLS_FILE);
X    return -1;
X  }
X  while (!done) {
X    h_spell.next = NULL;
X    if (fscanf(hang_fp, "%s", h_spell.name) < 0) {
X      done = 1;			/* useless? */
X      break;
X    }
X    fscanf(hang_fp, "%d", &h_spell.nat_id);
X    fscanf(hang_fp, "%d", &h_spell.thons_left);
X    fscanf(hang_fp, "%d", &h_spell.n_lines);
X    if (debug) {
X      printf("nation id %d, spell <%s>, time_left = %d, n_lines = %d\n",
X	   h_spell.nat_id, h_spell.name, h_spell.thons_left, h_spell.n_lines);
X    }
X    h_spell.lines = (char **)malloc(h_spell.n_lines * sizeof(char *));
X
X    for (i = 0; i < h_spell.n_lines; ++i) { /* read in the exec lines */
X      h_spell.lines[i] = (char *)malloc(EXECLEN*sizeof(char));
X      fscanf(hang_fp, "%s", h_spell.lines[i]);
X    }
X    if (!is_dead_spell(&h_spell,1))
X    {
X      for (i = 0 ; i < h_spell.n_lines; ++i)
X      {
X        if (i % 2 == 0) {
X	  parse_exec_line(h_spell.lines[i], exec_args);
X          np = &world.nations[h_spell.nat_id];
X          run_exec_line(np, exec_args);
X        }
X      }
X      add_h_spell(&hanging_spells, &h_spell);
X      if (up && (up->id == h_spell.nat_id || up->id == 0)) {
X	add_h_spell(&up->h_spells, &h_spell);
X      }
X    }
X  }
X  fclose(hang_fp);
X}
X
Xdelete_hanging_spell(sp1)
XSh_spell *sp1;
X{
X  Sh_spell *prev, *next, *tmp, *tmp2;
X  struct argument exec_args[N_EXEC_ARGS];
X  int i;
X
X  tmp = user.h_spells; tmp2 = NULL; prev = NULL;
X  while ((tmp != NULL) && (tmp2 == NULL))
X  {
X    if (h_spell_compare(sp1, tmp) == 0)
X    {
X      tmp2 = tmp;
X    } else
X    {
X      prev = tmp;
X      tmp = tmp->next;
X    }
X  }
X  if (prev == NULL)
X  { 
X    user.h_spells = tmp2->next;
X  } else
X  {
X    prev->next = tmp2->next;
X  }
X  for (i = 0 ; i < tmp2->n_lines; i++)
X  {
X    if (i % 2 == 1)
X    {
X      parse_exec_line(tmp2->lines[i], exec_args);
X      run_exec_line(user.np, exec_args);
X    }
X  }
X  write_dead_spell(tmp2);
X  if (is_army_spell(tmp2)) reset_spelled_flags();
X  free_h_spell(tmp2);
X}
X
Xgot_dead_h_spell(sp1)
XSh_spell *sp1;
X{
X  Sh_spell *prev, *tmp, *tmp2;
X
X  tmp = dead_spells; tmp2 = NULL; prev = NULL;
X  while ((tmp != NULL) && (tmp2 == NULL))
X  {
X    if (sp1 == tmp)
X    {
X      tmp2 = tmp;
X    } else
X    {
X      prev = tmp;
X      tmp = tmp->next;
X    }
X  }
X  if (tmp2 != NULL)
X  {
X    if (prev == NULL)
X    { 
X      dead_spells = tmp2->next;
X    } else
X    {
X      prev->next = tmp2->next;
X    }
X    free_h_spell(tmp2);
X  }
X}
X
Xfree_h_spell(sp1)
XSh_spell *sp1;
X{
X  int i;  
X
X  for (i = 0 ; i < sp1->n_lines ; i++)
X  {
X    free(sp1->lines[i]);
X  }
X  free(sp1);
X}
X
Xreset_spelled_flags()
X{
X  Sh_spell *tmp;
X  
X  tmp = user.h_spells;
X
X  while (tmp != NULL)
X  {
X    reset_one_spell(tmp);
X    tmp = tmp -> next;
X  }
X}
X
Xreset_one_spell(sp1)
XSh_spell *sp1;
X{
X  struct argument exec_args[N_EXEC_ARGS];
X 
X  if (strcmp(sp1->name, "hide_army") == 0)
X  {
X    if (sp1->n_lines < 4) return;
X    parse_exec_line(sp1->lines[2], exec_args);
X    run_exec_line(user.np, exec_args);
X  }
X  else if (strcmp(sp1->name, "fly_army") == 0)
X  {
X    if (sp1->n_lines < 4) return;
X    parse_exec_line(sp1->lines[2], exec_args);
X    run_exec_line(user.np, exec_args);
X  }
X  else if (strcmp(sp1->name, "vampire_army")== 0 )
X  {
X    if (sp1->n_lines < 4) return;
X    parse_exec_line(sp1->lines[2], exec_args);
X    run_exec_line(user.np, exec_args);
X  }
X  else if (strcmp(sp1->name, "burrow_army")== 0 )
X  {
X    if (sp1->n_lines < 4) return;
X    parse_exec_line(sp1->lines[2], exec_args);
X    run_exec_line(user.np, exec_args);
X  }
X  else if (strcmp(sp1->name, "water_walk") == 0)
X  {
X    if (sp1->n_lines < 4) return;
X    parse_exec_line(sp1->lines[2], exec_args);
X    run_exec_line(user.np, exec_args);
X  }
X  else if (strcmp(sp1->name, "mag_bonus") == 0)
X  {
X    if (sp1->n_lines < 4) return;
X    parse_exec_line(sp1->lines[2], exec_args);
X    run_exec_line(user.np, exec_args);
X  }
X}
X
Xis_army_spell(sp1)
XSh_spell *sp1;
X{
X  struct argument exec_args[N_EXEC_ARGS];
X 
X  if (strcmp(sp1->name, "hide_army") == 0)
X  {
X    return 1;
X  }
X  else if (strcmp(sp1->name, "fly_army") == 0)
X  {
X    return 1;
X  }
X  else if (strcmp(sp1->name, "vampire_army")== 0 )
X  {
X    return 1;
X  }
X  else if (strcmp(sp1->name, "burrow_army")== 0 )
X  {
X    return 1;
X  } 
X  else if (strcmp(sp1->name, "water_walk") == 0)
X  {
X    return 1;
X  }
X  else if (strcmp(sp1->name, "mag_bonus") == 0)
X  {
X    return 1;
X  }
X  return 0;
X}
X
Xwrite_dead_spell(sp1)
XSh_spell *sp1;
X{
X  FILE *dead_fp, *fopen();
X  char line[EXECLEN], filename[PATHLEN];
X  int i;
X
X  sprintf(filename,"exec/%s.%d","dead_spells",user.id);
X  if ((dead_fp = fopen(filename, "a")) == NULL) {
X    if (debug) printf("no file %s\n", filename);
X    return -1;
X  }
X  fprintf(dead_fp, "%s\n", sp1->name);
X  fprintf(dead_fp, "%d\n", sp1->nat_id);
X  fprintf(dead_fp, "%d\n", sp1->thons_left);
X  fprintf(dead_fp, "%d\n", sp1->n_lines);
X  for (i = 0; i < sp1->n_lines; ++i) { /* write out the exec lines */
X    fprintf(dead_fp, "%s", sp1->lines[i]);
X     /* we might need to tack on a newline */
X    if (sp1->lines[i][strlen(sp1->lines[i])-1] != '\n') {
X    fprintf(dead_fp, "\n");
X    }
X  }
X  fclose(dead_fp);
X}
X
Xclear_dead_hspells()
X{
X  Sh_spell *h_spells;
X  int i,end;
X  struct argument exec_args[N_EXEC_ARGS];
X
X  for (h_spells=hanging_spells; h_spells != NULL; h_spells = h_spells->next)
X  {
X    for (i = 0; i < h_spells->n_lines; ++i) { /* check the exec lines */
X/* Remove that goddman newline */
X      end = strlen(h_spells->lines[i]);
X      if (h_spells->lines[i][end-1] == '\n') {
X        h_spells->lines[i][end - 1] = '\0';
X      }
X    }
X    if (is_dead_spell(h_spells,1))
X    {
X      h_spells->thons_left = 0;
X    }
X  }
X}
X
X/* This routine checks to see if this army has a spell cast on it by  */
X/* checking to see if the flags are different from the default.       */
X/* If new spells are developed that change things besides flags, then */
X/* other mechanism's will need to be used.                            */
Xis_spelled(ap)
XSarmy *ap;
X{
X  int i;
X  int def_flags;
X  Snation *np = user.np;
X
X  i = army_type_index(ap->type);
X  if (i != -1 ) {
X    def_flags = army_types[i].flags;
X    if (def_flags & AF_INVERSE_ALT) {
X      if (np->race.pref_alt >= SEA_LEVEL) {
X        def_flags |= AF_WATER;
X      } else {
X        def_flags |= AF_LAND;
X      }
X    }
X    if (def_flags != ap->flags) {
X      return 1;
X    } else {
X      return 0;
X    }
X  } else {
X    if ((i = spirit_type_index(ap->type)) < 0) {
X      return 0;  /* We can't figure out what it is, so it's not spelled */
X    }
X    if (spirit_types[i].flags != ap->flags) {
X      return 1;
X    } else {
X      return 0;
X    }
X  }
X}
END_OF_FILE
if test 12959 -ne `wc -c <'spelllib.c'`; then
    echo shar: \"'spelllib.c'\" unpacked with wrong size!
fi
# end of 'spelllib.c'
fi
echo shar: End of archive 24 \(of 28\).
cp /dev/null ark24isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Now execute ./do_cat.sh to build doc files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
