Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i051:  dominion - a multi-player world simulation game, Part15/28
Message-ID: <2454@masterCNA.TEK.COM>
Date: 11 Feb 92 18:25:00 GMT
Sender: news@masterCNA.TEK.COM
Lines: 1985
Approved: billr@saab.CNA.TEK.COM

Submitted-by: rosalia@dirac.physics.sunysb.edu (Mark Galassi)
Posting-number: Volume 13, Issue 51
Archive-name: dominion/Part15
Environment: Unix, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 15 (of 28)."
# Contents:  Makefile makeworld.c
# Wrapped by billr@saab on Tue Feb 11 10:14:55 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(13980 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X######################################################################
X#
X# Copyright (C) 1990 Free Software Foundation, Inc.
X# Written by the dominion project.
X#
X# This file is part of dominion.
X#
X# dominion is free software; you can redistribute it and/or modify it
X# under the terms of the GNU General Public License as published by the Free
X# Software Foundation; either version 1, or (at your option) any later version.
X# 
X# dominion is distributed in the hope that it will be useful, but WITHOUT
X# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
X# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
X# details.
X# 
X# You should have received a copy of the GNU General Public License along with
X# dominion; see the file COPYING.  If not, write to the Free Software
X# Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  
X#
X#######################################################################
X
XSHELL=/bin/sh
X
X# Here is my own terminal rule for RCS, so that it DOES check
X# out the file if the RCS version is newer.  Comment this out
X# and suffer, if you don't have GNU make.  Or you can use the
X# "user" Makefile.
X
X% :: RCS/%,v
X	co $<
X
X# version number
XVERSION=1.06
X# directories for binaries and lib files
XBINDIR = /usr/games
X#BINDIR = .
X#LIBDIR = /usr/games/lib/dominion
XLIBDIR = lib
XTHIS_GAME_LIBDIR = $(LIBDIR)
X# MAILDIR is a subdir of THIS_GAME_LIBDIR
XMAILDIR = mail
XNEWSDIR = news
XNGDB_FILE = groups
X# NEWS_GROUP is the name of the news group with general update information
XNEWS_GROUP = News
X#This is the newsgroup database. Where news info is stored.
XEXECDIR = exec
XDOCDIR = doc
XMISCDIR = misc
XMAGDIR = magic
XOPTDIR = options
X
X# DEFAULT_MAIL is a basic mail program, to be used if the user has
X# no environment variable or option for DOMINION_MAIL.  This should be
X# "Mail" or "mailx", or any mail program that allows you to choose
X# whic message to read.  The old "binmail" is out.
XDEFAULT_MAIL = elm
X
X#MAILER is the mail program that will be sending forwarded mail.
X#It should be set up in such a way that you can just put addresses
X#after it and then type the message to send mail.  
X#MAILER = "/usr/ucb/mail -s Dominion_Mail"
XMAILER = /bin/mail
X
X# DEFAULT_EDITOR is a basic visual editor, to be used if the user has
X# no environment variable or option for VISUAL.  This could be
X# micro-gnu-emacs (mg), or emacs, or vi, or anything your users use.
XDEFAULT_EDITOR = mg
X
X# location of the info_intro file, used for the online manual,
X# with respect to the lib directory
XINFO_INTRO=info_intro
X
X# choose a graphics interface.  choice is only cur_stuff.o for now
XGRAPHICS_STUFF = cur_stuff.o
XGRAPHICS = -DCURSES
X
XCC = cc
X# put -g if you want to debug, or -O if you want to optimize
XDEBUGFLAGS = -g
XLDFLAGS = $(DEBUGFLAGS)
XLIBS = -lcurses -ltermcap -lm
X
X# put -DBSD instead of -DSYSV if you are on Berkeley UNIX
X
X# put -DUID_SECURITY if you are running unix and you don't
X#  want users to poke around game files with shell escapes.
X#  This requires the UNIX system setuid() calls and such, and
X#  is quite necessary on UNIX.  Massive cheating can go on
X#  otherwise.  Without UNIX, the super user will have to trust
X#  the players to not look at the game files.
X
X# put -DHAVE_STRSTR if your system has strstr().  We provide
X#  a replacement which is just a quick hack.  SGI and HP-UX
X#  are both known to have strstr().
X
X# put -DINTERNAL_MAIL if you want to use the internal mail program
X# (in case external mail programs don't interface well to dominion
X# on your system).  If you want to use the DEFAULT_MAIL defined
X# above, remove -DINTERNAL_MAIL
X
X# put -DPMAX if you are using ultrix. This will fix the mvwprintw
X# curses bug that occurs under ultrix.
X
X# put -DANDREW if you are using andrew games authentication
X
XCFLAGS = $(DEBUGFLAGS) $(GRAPHICS) -DDEF_LIBDIR=\"$(LIBDIR)\" -DDEFAULT_MAIL=\"$(DEFAULT_MAIL)\"  -DMAILER=\"$(MAILER)\" -DDEFAULT_EDITOR=\"$(DEFAULT_EDITOR)\" -DNEWS_GROUP=\"$(NEWS_GROUP)\" -DINFO_INTRO=\"$(INFO_INTRO)\" -DVERSION=\"$(VERSION)\" -DSYSV -DUID_SECURITY -DINTERNAL_MAIL
X
X# files relating to documentation, history of the game...
XDOC_FILES = README ChangeLog TASKS THE_STORY dominion.tex gm.tex dominion.6 \
X	dominion.info refcard info_intro
X
X# all files that go in MAGDIR
XMAG_FILES = mag_orders mag_Master mag_Diana mag_Necromancy mag_Yavanna \
X	mag_Demonology mag_Monsters mag_Neptune mag_Chess mag_Aule \
X	mag_Inferno mag_Avian mag_Unity mag_Time mag_Insects
X
X# all files that go in MISCDIR
XMISC_FILES = races npcs army_types spirit_types techno_levels
X
XLIB_FILES = $(DOC_FILES) $(MAG_FILES) $(MISC_FILES)
X
X# all files that are part of the distribution
XDIST_FILES = Makefile $(DOC_FILES) \
X		$(MAG_FILES) $(MISC_FILES) dominion.h misc.h army.h news.h \
X		costs.h cur_stuff.h dominion.c world.c nation.c user.c ext.c \
X		file.c misc.c init.c commands.c help.c menus.c cur_stuff.c \
X		diplomacy.c army.c reports.c spy.c makeworld.c addnation.c \
X		update.c armylib.c mail.c techno.c diplolib.c battle.c \
X		maglib.c trade.c trademenu.c news.c c_news.c npc.c npclib.c \
X		economy.c transport.c spells.c spelllib.c root.c cinfo.c \
X		budget.c construct.c int_mail.c movement.c printmap.c \
X		addnews.sh COPYING
X
Xall: dominion dom_make dom_add dom_update dom_print $(MAG_FILES) $(MISC_FILES) \
X		refcard info_intro
X
Xlib-files: all $(MAG_FILES) $(MISC_FILES) refcard info_intro \
X		dominion.info addnews.sh
X	-find $(THIS_GAME_LIBDIR) -exec chmod u+w {} \;
X	-mkdir $(THIS_GAME_LIBDIR)
X	-mkdir $(THIS_GAME_LIBDIR)/$(MAILDIR)
X	-mkdir $(THIS_GAME_LIBDIR)/$(NEWSDIR)
X	-mkdir $(THIS_GAME_LIBDIR)/$(EXECDIR)
X	-mkdir $(THIS_GAME_LIBDIR)/$(DOCDIR)
X	-mkdir $(THIS_GAME_LIBDIR)/$(MISCDIR)
X	-mkdir $(THIS_GAME_LIBDIR)/$(MAGDIR)
X	-mkdir $(THIS_GAME_LIBDIR)/$(OPTDIR)
X#	-cp $(DOC_FILES) $(THIS_GAME_LIBDIR)/$(DOCDIR)
X	-cp refcard dominion.info $(THIS_GAME_LIBDIR)/$(DOCDIR)
X	-cp info_intro $(THIS_GAME_LIBDIR)
X	-cp $(MAG_FILES) $(THIS_GAME_LIBDIR)/$(MAGDIR)
X	-cp $(MISC_FILES) $(THIS_GAME_LIBDIR)/$(MISCDIR)
X	find $(THIS_GAME_LIBDIR) -exec chmod g-rw {} \; -exec chmod o-rw {} \;
X
Xinstall: all
X	-csh -c "cp dominion dom_make dom_add dom_update $(BINDIR)"
X	cp dominion.6 /usr/man/man6
X	echo "remember to make the program *dominion* setuid to you"
X	echo "you can do this with"
X	echo "	chmod u+s dominion"
X
X# the name of GNU emacs on your system
X# (not necessary unless you build dominion.info; see rule below)
XEMACS = emacs
X# startup file for the latexinfo package on your system
X# (not necessary unless you build dominion.info; see rule below)
XLTI_START = /umax/rosalia/el/ltistart.el
X# where the emacs info files go
X# (not really important unless you run cinfo() as standalone)
XINFO_DIR = /usr/local/lib/emacs/info
X
Xinstall-info: dominion.info
X	cp dominion.info $(INFO_DIR)
X
Xclean-lib:
X	-rm -rf $(THIS_GAME_LIBDIR)
X
Xnew-world: all clean-lib lib-files
X	@echo
X	@echo 'all data cleared, and lib files installed'
X	@echo
X	./dom_make -d $(THIS_GAME_LIBDIR)
X	@echo 'newsgroup ' $(NEWS_GROUP) ' created automatically'
X	-mkdir $(THIS_GAME_LIBDIR)/$(NEWSDIR)/$(NEWS_GROUP)
X	@echo $(NEWS_GROUP) ' 1 0 0' > $(THIS_GAME_LIBDIR)/$(NEWSDIR)/$(NGDB_FILE)
X	/bin/sh ./addnews.sh $(THIS_GAME_LIBDIR)/$(NEWSDIR) $(NGDB_FILE)
X
X# use dominiontmp so you can load the program while it is being used
X#dominion: dominiontmp
X#	cp dominiontmp dominion
X
Xdominion: dominion.o world.o nation.o user.o ext.o file.o misc.o init.o \
X		trademenu.o budget.o \
X		commands.o help.o menus.o diplomacy.o reports.o spy.o trade.o \
X		army.o armylib.o mail.o diplolib.o maglib.o $(GRAPHICS_STUFF) \
X		news.o c_news.o economy.o transport.o spells.o spelllib.o \
X		root.o cinfo.o construct.o int_mail.o movement.o
X	$(CC) $(LDFLAGS) -o dominion dominion.o world.o nation.o user.o ext.o \
X		file.o budget.o \
X		misc.o init.o trademenu.o commands.o help.o menus.o \
X		diplomacy.o reports.o spy.o trade.o army.o armylib.o mail.o \
X		diplolib.o maglib.o $(GRAPHICS_STUFF) news.o c_news.o \
X		economy.o transport.o spells.o spelllib.o root.o cinfo.o \
X		construct.o int_mail.o movement.o $(LIBS)
X
Xlint:
X	lint $(CFLAGS) *.c
X
Xdom_make: makeworld.o file.o misc.o ext.o armylib.o diplolib.o world.o \
X		economy.o movement.o
X	$(CC) $(LDFLAGS) -o dom_make makeworld.o file.o misc.o ext.o \
X		armylib.o diplolib.o world.o economy.o movement.o $(LIBS)
X
Xdom_add: addnation.o file.o misc.o ext.o armylib.o diplolib.o world.o \
X		economy.o movement.o
X	$(CC) $(LDFLAGS) -o dom_add addnation.o file.o misc.o ext.o armylib.o \
X		diplolib.o world.o economy.o movement.o \
X		$(LIBS)
X
Xdom_update: update.o file.o misc.o nation.o armylib.o ext.o mail.o \
X		techno.o battle.o diplolib.o world.o maglib.o trade.o npc.o \
X		economy.o spelllib.o news.o movement.o npclib.o
X	$(CC) $(LDFLAGS) -o dom_update update.o file.o misc.o nation.o ext.o \
X		armylib.o mail.o techno.o battle.o diplolib.o world.o \
X		maglib.o trade.o npc.o economy.o spelllib.o news.o movement.o \
X		npclib.o $(LIBS)
X
X
Xdom_print: printmap.o file.o misc.o nation.o armylib.o ext.o maglib.o\
X		diplolib.o world.o economy.o movement.o
X	$(CC) $(LDFLAGS) -o dom_print printmap.o file.o misc.o nation.o \
X		ext.o armylib.o diplolib.o world.o economy.o movement.o \
X		maglib.o $(LIBS)
X
X#dom_trans: trans.o file.o misc.o nation.o armylib.o ext.o mail.o \
X#		techno.o battle.o diplolib.o world.o maglib.o trade.o npc.o \
X#		economy.o spelllib.o news.o movement.o
X#	$(CC) $(LDFLAGS) -o dom_trans trans.o file.o misc.o nation.o ext.o \
X#		armylib.o mail.o techno.o battle.o diplolib.o world.o \
X#		maglib.o trade.o npc.o economy.o spelllib.o news.o \
X#		movement.o $(LIBS)
X
X# you might want to comment this out if you don't have LaTeXinfo.
X# the second part will unpack dominion.info from a mail/news distribution.
Xdominion.info: dominion.tex
X	-/bin/rm -f info.bak
X	-mv dominion.info info.bak
X	-cp dominion.tex junk.tex
X	-chmod 644 junk.tex
X	-$(EMACS) junk.tex -l $(LTI_START) -f nodify-file -f latexinfo-format-buffer -f save-buffer -kill
X	-rm junk.tex
X	-touch dominion.info
X
X# Now that I use "shar2" I don't need all this stuff with uuencode
X# and split.  it will be done automatically while unpacking.
X
X# DO NOT DELETE THIS LINE -- make depend uses it
Xaddnation.o: addnation.c army.h dominion.h misc.h
Xarmy.o: army.c army.h cur_stuff.h dominion.h misc.h
Xarmylib.o: army.h armylib.c dominion.h misc.h
Xbattle.o: army.h battle.c dominion.h misc.h
Xc_news.o: c_news.c dominion.h news.h
Xcinfo.o: cinfo.c
Xcommands.o: army.h commands.c dominion.h misc.h
Xcur_stuff.o: cur_stuff.c cur_stuff.h dominion.h misc.h
Xdiplolib.o: diplolib.c dominion.h misc.h
Xdiplomacy.o: diplomacy.c dominion.h misc.h
Xdominion.o: dominion.c dominion.h misc.h
Xeconomy.o: army.h costs.h dominion.h economy.c misc.h
Xext.o: dominion.h ext.c misc.h
Xfile.o: dominion.h file.c misc.h
Xhelp.o: cur_stuff.h dominion.h help.c
Xinit.o: dominion.h init.c
Xint_mail.o: dominion.h int_mail.c
Xmaglib.o: dominion.h maglib.c misc.h
Xmail.o: dominion.h mail.c
Xmakeworld.o: dominion.h makeworld.c misc.h
Xmenus.o: army.h dominion.h menus.c misc.h
Xmisc.o: army.h cur_stuff.h dominion.h misc.c misc.h
Xmovement.o: army.h dominion.h movement.c misc.h
Xnation.o: army.h dominion.h misc.h nation.c
Xnews.o: dominion.h news.c news.h
Xnpc.o: army.h dominion.h misc.h npc.c
Xnpclib.o: army.h dominion.h misc.h npclib.c
Xreports.o: dominion.h misc.h reports.c
Xbudget.o: dominion.h misc.h budget.c
Xroot.o: dominion.h root.c
Xspelllib.o: army.h dominion.h misc.h spelllib.c
Xspells.o: army.h dominion.h misc.h spells.c
Xspy.o: dominion.h misc.h spy.c
Xtechno.o: dominion.h misc.h techno.c
Xtrade.o: dominion.h misc.h trade.c
Xtrademenu.o: trademenu.c
Xtransport.o: army.h costs.h dominion.h misc.h transport.c
Xconstruct.o: army.h costs.h dominion.h misc.h construct.c
Xupdate.o: army.h dominion.h misc.h update.c
Xuser.o: dominion.h misc.h user.c
Xworld.o: army.h dominion.h misc.h world.c
X# DO NOT DELETE THIS 2nd LINE -- make depend uses it
X
X# rules for RCS
X
X# check everything in
Xci_all:
X	ci $(DIST_FILES)
X
Xco_all:
X	co $(DIST_FILES)
X
Xclean:
X	/bin/rm -f *.o dom_add dom_make dominion dominiontmp dom_update \
X		a.out core TAGS info.bak *.dvi *.log *.aux *.err *.toc \
X		*.jep *.cp *.fn *.pg *.ky *.vr *.tp *~
X
X#.DEFAULT:
X#	co $@
X
X#menus.c: RCS/menus.c,v
X#	co menus.c
X
X# everything after this is used to make the ftp distribution,
X# or other such stuff.
X
X#dominion.info.Z: dominion.info
X#	compress -c dominion.info > dominion.info.Z
X
X#info.Z.uue: dominion.info.Z
X#	uuencode dominion.info.Z dominion.info.Z > info.Z.uue
X
Xdominion.shr.Z: dominion.shr
X	-/bin/rm -f dominion.shr.Z
X	compress dominion.shr
X
Xdominion.shr: $(DIST_FILES)
X	shar $(DIST_FILES) > dominion.shr
X
Xdominion.tar.Z: $(DIST_FILES) dominion.info
X	tar cvf dominion.tar $(DIST_FILES)
X	compress dominion.tar
X
Xdominion.dvi.Z: dominion.dvi
X	compress dominion.dvi
X
Xdominion.dvi: dominion.tex
X	latex dominion
X
Xdominion.PS.Z: dominion.PS
X	compress dominion.PS
X
Xdominion.PS: dominion.dvi
X	dvips dominion > dominion.PS
X
X# for mail (and news) distribution
Xmail-dist: $(DIST_FILES)
X#	split -1000 dominion.tex dominion.tex
X#	makekit -s60k -nDOM-$(VERSION)- $(DIST_FILES) info.Z.uue
X# now use the "shar2" program which can split large files if
X# necessary (> 60K).  call with verbose and mixed-ascii-binary
X# options.
X	shar2 -v -M -oDOM-$(VERSION)- -l60 $(DIST_FILES)
X	touch mail-dist
X
X# this is to make it available by anonymous ftp
XFTP_DIR=/usr/ftp/pub/dominion-$(VERSION)
X
Xftp-update: dominion.tar.Z dominion.dvi dominion.PS mail-dist dominion.info
X	mv dominion.tar.Z $(FTP_DIR)/dominion-$(VERSION).tar.Z
X	compress DOM-$(VERSION)-*
X	mv DOM-$(VERSION)-*.Z $(FTP_DIR)
X	compress dominion.PS
X	mv dominion.PS.Z $(FTP_DIR)
X	compress dominion.dvi
X	mv dominion.dvi.Z $(FTP_DIR)
X	compress -c dominion.info > $(FTP_DIR)/dominion.info.Z
X	compress -c /usr/local/lib/tex/macros/latexinfo.sty > \
X		$(FTP_DIR)/latexinfo.sty.Z
X	compress -c /usr/local/lib/tex/macros/tabular.sty > \
X		$(FTP_DIR)/tabular.sty.Z
X
XUUCPP=/usr/spool/uucppublic
X
Xto-mozart: dominion.shr
X	compress dominion.shr
X	mv dominion.shr.Z $(UUCPP)
X	uucp $(UUCPP)/dominion.shr.Z mozart!$(UUCPP)
END_OF_FILE
if test 13980 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'makeworld.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makeworld.c'\"
else
echo shar: Extracting \"'makeworld.c'\" \(43814 characters\)
sed "s/^X//" >'makeworld.c' <<'END_OF_FILE'
X/* makeworld.c   A world generation program by Stephen H. Underwood */
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X#include "dominion.h"
X#include "misc.h"
X#include <stdio.h>
X#include <math.h>
X#include <signal.h>
X#ifndef ridge			/* ridges don't have limits.h */
X# include <limits.h>
X#else /* ridge */
X# define	INT_MAX		2147483647 /* max decimal value of an "int" */
X#endif /* ridge */
X
X#define HASH_SIZE 500   /* Size of hash table for sea_level determination */
X#define STATFILE "world.stats"
X
Xextern Sworld world;   
Xextern Suser user;
Xextern struct race_list *races;	
Xextern char libdir[];
Xextern int (*wrapx)(), (*wrapy)(), compressed_world;
Xextern struct s_altitude_map altitude_map[];
Xextern struct item_map climates[];
Xdouble **d_map;
X
X/* Base terrains for each given climate type */
Xint cli_terr[] = { 1, 4, 5, 3, 6, 4, 5, 3, 5, 3, 0 };
X
Xcleanup()
X{
X}
X
Xcritical()
X{
X  signal(SIGINT, SIG_IGN);
X  signal(SIGQUIT, SIG_IGN);
X}
Xnoncritical()
X{
X  signal(SIGINT, SIG_DFL);
X  signal(SIGQUIT, SIG_DFL);
X}
X
Xdouble Gauss()
X/* 
X   This function returns a gaussian random variable with mean 0
X   and a variance of 1.
X*/
X{
X  static int first_time_flag = 0, Nrand = 4;
X  static double GaussAdd, GaussFac;
X  double sum = 0;
X  int i;
X  unsigned seed;
X
X  if (first_time_flag == 0)
X  {
X    /* This initializes things for the gaussing stuff.
X       this is done only once. */
X    GaussAdd = sqrt((double)(3 * Nrand));
X    GaussFac = 2.0 * GaussAdd/ ( (double)Nrand * (double)INT_MAX );
X    seed = (unsigned) time(NULL);
X    SRND(seed);
X    first_time_flag = 1;
X  }
X  for ( i = 0 ; i < Nrand ; i++) sum += RND();
X  return (GaussFac * sum - GaussAdd);
X
X}
X
Xgen_arr(X,H,r,xmax,ymax,max_height, min_height)
Xdouble *X[],H,r,*max_height,*min_height;
Xint xmax,ymax;
X/*
X   This routine generates a fractal arrray with fratal dimension of 3-H
X   and a lacunarity of r.  It is passed the number of sampling points in
X   the final array xmax * ymax, and a place to store the value of said
X   points. Modified version of a similar code in The Science of Fractal
X   Images by Peitgen and Saupe
X*/
X{
X  double delta, xt, yt, xT, yT, h, sigma = 0.5, t, T;
X  int  xmT, ymT, xmt, ymt, i, j, indx , xN, yN, x, y;
X
X  xN = xmax + 1;
X  yN = ymax + 1;
X
X  if ( xmax < ymax )
X  {
X    xmT = 2;
X    ymT = (int)((double)ymax / ((double)xmax/2.0));
X  } else
X  {
X    ymT = 2; 
X    xmT = (int)((double)xmax / ((double)ymax/2.0));
X  }
X  for (x = 0 ; x < xmT ; x++)
X  {
X    for (y = 0 ; y < ymT ; y++)
X    {
X      X[x][y] = 0.0;
X    }
X  }
X  xT = 1.0  / ((double)xmT - 1.0);
X  yT = 1.0  / ((double)ymT - 1.0);
X
X  while ((xmT < xN) || (ymT < yN))
X  {
X    xmt = (int)((double)xmT/r);
X    if (xmt == xmT) xmt = xmT + 1;
X    if (xmt > xN) xmt = xN;
X    xt = 1.0/((double)xmt-1.0);
X    
X    ymt = (int)((double)ymT/r);
X    if (ymt == ymT) ymt = ymT + 1;
X    if (ymt > yN) ymt = yN;
X    yt = 1.0/((double)ymt-1.0);
X
X    if ( xt > yt)
X    {
X      t = xt;
X      T = xT;
X    } else
X    {
X      t = yt;
X      T = yT;
X    }
X    
X    interpolate(X, xmT, ymT, xmt, ymt); 
X    delta = pow(t/T, 2.0 - 2.0 * H);
X    delta = sqrt(1.0 - delta);
X    delta *= sqrt(0.5);
X    delta *= pow(t,H);
X    delta *= sigma;
X    for ( i = 0 ; i < (xmt - 1); i++)
X    {
X      for ( j = 0 ; j < (ymt - 1); j++)
X      {
X        X[i][j] += delta * Gauss();
X/*
X   The following mess is for machinees with NaN implemented rather
X   than dumping core on division by zero like it should.  If it
X   doesn't apply to your machine, you are lucky and should be grateful.
X*/
X/*        if (X[i][j] != X[i][j]) /* Yes, I really mean this */
X/*        { 
X          printf("Error: value %lf at %d %d\n",X[i][j],i,j);
X        }
X*/
X      }
X    }
X    for (i = 0 ; i <= (xmt - 1) ; i++)
X    {
X      X[i][ymt-1] = X[i][0];
X    }
X    for (j = 0 ; j <= (ymt - 1) ; j++)
X    {
X      X[xmt-1][j] = X[0][j];
X    }
X    xmT = xmt;
X    ymT = ymt;
X    xT = 1.0  / ((double)xmT - 1.0);
X    yT = 1.0  / ((double)ymT - 1.0);
X  }
X/* We've computed the fractal, now find the min and max */
X  *max_height = -5000;
X  *min_height = 5000;
X  for (x = 0 ; x < xmax ; x++)
X  {
X    for (y = 0 ; y < ymax ; y++)
X    {
X      if (*max_height < X[x][y]) *max_height = X[x][y];
X      if (*min_height > X[x][y]) *min_height = X[x][y];
X    }
X  }
X  return delta;
X}
X
Xinterpolate(X, oldx, oldy, newx, newy)
X/*
X   Similar to the Interpolate routine mentionedin The Science of
X   fractal images this routine interpolates the values of the verticies
X   of a larger rectangular grid that covers the same region as the
X   smaller rectangular grid stored in X.
X   At the beginning X is oldx by oldy and at the end it's newx by newy
X*/
Xdouble *X[];
Xint oldx, oldy, newx, newy;
X{
X  int i,j,x,y,k;
X  double *Y, high_per, low_per, right_per, left_per;
X
X/* Get a temporary array to work with. */
X   if ((Y = (double *)malloc((oldy+1)* sizeof(double))) == NULL) { mem_error();}
X
X/*
X   We work backwards through the array so we don't overwrite rows that
X   we still need to work with.  We could make the code simpler by using
X   a second array, but that would cost both time (to copy the values back)
X   and memory to stor the second array.  Since this routine is called
X   frequently, we optimize
X*/    
X
X  i = oldx - 1;
X  for (x = newx - 1; x > 0 ; x--)
X  {
X    if ( i * newx >= x * oldx)
X    {
X/*
X   A point always lies between two columns.  We store the right hand
X   column in the temporary array Y
X*/
X      for (k = 0 ; k < oldy; k ++) { Y[k] = X[i][k]; }
X      i--;
X    }
X/* Determine left and right portions for this colmun in the new matrix */ 
X    right_per = (double) ( x * oldx - i * newx)/(double)newx;
X    left_per = 1.0 - right_per;
X/* Loop backwards over y just for consistancy */
X    j = oldy - 1;
X    for ( y = newy - 1 ; y >= 0 ; y--)
X    {
X/* Jump down a level, special casing the botom(top) row. */
X      if ( j * newy >= y * oldy) { 
X       if (--j < 0) { j = 0;}
X      }
X/* Determine high and low portions for this row in the new matrix */ 
X      high_per = (double)(y * oldy - j * newy) / (double)newy;
X      low_per = 1.0 - high_per;
X/* Now sum up the portions of the 4 corners surrounding this point */
X      X[x][y] = ( low_per * left_per * X[i][j] + low_per * right_per * Y[j]
X         + high_per * left_per * X[i][j+1] + high_per * right_per * Y[j+1]);
X/*
X   The following mess is for machinees with NaN implemented rather
X   than dumping core on division by zero like it should.  If it
X   doesn't apply to your machine, you are lucky and should be grateful.
X*/
X/*        if (X[x][y] != X[x][y]) /* Yes, I really mean this */
X/*        { 
X          printf("Error: value %lf at %d %d\n",X[x][y],x,y);
X        }
X*/
X    }
X  }
X/*
X   We special case the last column since we are garunteed an overwrite at 
X   that point
X*/
X
X  j = oldy;
X/* If the 0th column isn't in Y, we put it there now */
X  if (i != 0)
X  {
X    i = 0;
X    for (k = 0 ; k < oldy; k ++) { Y[k] = X[i][k]; }
X  }
X/*
X   Compute the 0th columns values.  Note that since it falls on the
X   same column as 0th column of the previous matrix, we need only
X   concern ourselves with 2-d interpolation
X */
X  for ( y = newy - 1 ; y > 0 ; y--)
X  {
X    if ( j * newy >= y * oldy) { j--; }
X    high_per = (double)(y * oldy - j * newy) / (double)newy;
X    low_per = 1.0 - high_per;
X    X[x][y] = ( low_per * Y[j] + high_per * Y[j+1])/2.0;
X  }
X/* Clean up after ourselves */
X  if ( Y != NULL) free(Y);
X}
X
X
Xint init_sector(map,i,j)
X/* This function sets a sector to it's base values (mostly zeros) */
XSsector **map;
Xint i,j;
X{
X  map[i][j].loc.x = i;
X  map[i][j].loc.y = j;
X  map[i][j].terrain = 0;
X  map[i][j].altitude = 0;
X  map[i][j].climate = 0;
X  map[i][j].designation = 0;
X  map[i][j].soil = 0;
X  map[i][j].metal = 0;
X  map[i][j].jewels = 0;
X  map[i][j].defense = 0;
X  map[i][j].roads = 0;
X  map[i][j].owner = 0;
X  map[i][j].n_people = 0;
X  map[i][j].flags = 0;
X  map[i][j].name[0] = '\0';
X  map[i][j].alist = (struct armyid *)NULL;
X};
X
Xinit_gamemaster(np)
X/* 
X   This function sets up the gamemaster nation (the only nation the game
X   starts with).
X*/
XSnation *np;
X{
X  char temppass[PASSLEN], temp2pass[PASSLEN];
X
X  np->id = 0;
X  strcpy(np->name,"Gamemaster");
X  sprintf(np->leader,"%s","Exalted One");
X/* We need to get the password from the user */
X  get_crypt_pass("\nGive World/Gamemaster password: ", temppass, NULL, NULL);
X  get_crypt_pass("\nType it once more: ", temp2pass, NULL, NULL);
X  while  (strcmp(temppass, temp2pass) != 0){
X    fprintf(stderr,"\nThose two didn't match.  Please try again.\n");
X    get_crypt_pass("\nGive World/Gamemaster password: ", temppass, NULL, NULL);
X    get_crypt_pass("\nType it once more: ", temp2pass, NULL, NULL);
X  }
X  strcpy(np->passwd, temppass);
X  np->capital.x = 0;
X  np->capital.y = 0;
X  np->race = races->race;  /* Set's it to the first race, Master */
X  np->mark = '-';          /* Useful for display nation displays */
X/* 
X  Everything starts at 0, since if the gamemaster wants something,
X  he/she can use the edit nation feature to add it.
X*/
X  np->taxes = 0;
X  np->taxtype = 0;
X  np->charity = 0;
X  np->money = 0;
X  np->jewels = 0;
X  np->metal = 0;
X  np->food = 0;
X  np->n_sects = 0;
X  np->tech_r_d = 0;
X  np->tech_r_d_metal = 0;
X  np->mag_r_d = 0;
X  np->mag_r_d_jewels = 0;
X  np->spy_r_d = 0;
X  np->npc_flag = 0;
X  np->npc_agg = 0;
X  np->npc_exp = 0;
X  np->npc_iso = 0;
X  strcpy(np->mag_order,"Master");
X  np->tech_skill = 0;
X  np->mag_skill = 0;
X  np->farm_skill = 0;
X  np->mine_skill = 0;
X  np->spell_pts = 1;
X  np->attack = 0;
X  np->defense = 0;
X  np->spy = 0;
X  np->secrecy = 0;
X  np->n_armies = 0;
X  np->armies = (Sarmy *) NULL;
X  np->ptlist = (struct pt_list *) NULL;
X
X  return 0;
X}
X
Xinit_d_map(xmax,ymax)
X/*
X   Allocate the memory for the temporary array the size of the world
X   (with one extra for wrap around) for manipulation before scaling 
X*/
Xint xmax,ymax;
X{
X  int i;
X  
X  if ((d_map = (double **) malloc((xmax + 1) * (sizeof(double *)))) == NULL)
X  {
X    mem_error();
X  }
X  for (i=0; i <=xmax ; i++)
X  {
X    if ((d_map[i] = (double *) malloc((ymax + 1) * (sizeof(double)))) == NULL)
X    {
X      mem_error();
X    }
X  }
X}
X
Xdouble find_level(wp,d_map,perc, max_height, min_height)
X/*
X   This function finds the level beneath which are roughly "perc" 
X   percentage of the sectors available.  Good for setting sea
X   level if you want 30% sea for example.
X*/
XSworld *wp;
Xdouble *d_map[],perc,max_height,min_height;
X{
X  static int hashes[HASH_SIZE + 1];
X  int num_sect,i,k,x,y, ltemp;
X  double level, scale_factor;
X
X
X  if (perc == 1.0) /* If it's all of them, but the level above everything */
X  {
X    level = max_height;
X    return level;
X  }
X  if (perc == 0.0) /* If it's none of them, put the level below everything */
X  {
X    level = min_height;
X    return level;
X  }
X/* Empty the hash table */
X  for (i=0;i<=HASH_SIZE;i++) hashes[i] = 0;
X/* Loop over the array, filing the hash table to the number of sectors
X   in the region each hash slot is associated with.
X*/ 
X  scale_factor = (double)HASH_SIZE/
X            ((max_height - min_height)*(1.0 + 1.1/HASH_SIZE));
X
X  for (x = 0 ; x < wp->xmax ; x++)
X  {
X    for (y = 0 ; y < wp->ymax ; y++)
X    {
X      ltemp = (d_map[x][y] - min_height) * scale_factor;
X/*      if ((ltemp < 0 ) || (ltemp >= HASH_SIZE))
X      {
X        printf("Error: ltemp %d max %lf min %lf val %lf\n",ltemp,
X                   max_height, min_height, d_map[x][y]);
X      } else 
X*/
X      {
X        hashes[ltemp]++;
X      }
X    }
X  }
X/* Determine the number of sectors below the level */
X  num_sect = (int)((double)(wp->xmax * wp->ymax) * perc);
X  k = 0; i = -1;
X/* Find how far down the hash table we have to go to get that many sectors */
X  while ( ( k < num_sect) && ( i <= HASH_SIZE))
X  {  
X    i++;
X    k += hashes[i]; 
X  }
X  if (i >= HASH_SIZE) /* If it's all of them, then use all of them */
X  {
X    level = max_height;
X  }
X  /* if it's none of them, use none of them. */
X  else if ((i == 0) || (num_sect == 0))
X  {
X    level = min_height;
X  }
X  else 
X/* 
X   Estimate the level as half way between a bit too few
X   (at the i-1 level) and a few too many (at the ith level)
X*/
X  {
X   level = ((max_height - min_height) * (((double)i - 0.5) / 
X                        (double)HASH_SIZE) ) + min_height;
X  }
X
X  return level;
X}
X
Xpower_scale(wp,d_map,level, k, minimum, maximum)
X/* 
X  This function takes the entire map and rescales it by taking
X  each item to the kth power, after rescaling the value to be
X  between 1 and 2.  This means that all the points get lower,
X  but specifically that high points loose more height than
X  the lower points.  This brings most of the mountain peaks
X  down to within rougly the same range.
X*/
XSworld *wp;
Xdouble *d_map[],level,k,*maximum, *minimum;
X{
X  int x,y;
X  double old_min = *minimum , old_max = *maximum, htemp;
X
X  *maximum = -50; *minimum = 50; 
X  for (x = 0 ;x < wp->xmax ; x++)
X  {
X    for (y = 0 ; y < wp->ymax ; y++)
X    {/* scale us relative to 0 */
X      if ((htemp = (d_map[x][y] -= level)) < 0)
X      {
X/*
X   scale below water between -1 and 0, then between 1 and 2, take power
X   and then scale back below 0.  Remember roots of a negative number may
X   be meaninless, so it has to be shifted (as we have done) into the positive
X*/
X        if (old_min != level)
X        { 
X          htemp /= (old_max - level);
X	} else
X        {
X          htemp = 0;
X	}
X        htemp = 1 - pow(1 - htemp,k);
X      } else
X      { 
X/*
X   scale above water between 0 and 1, and then between 1 and 2 and then
X   after the power back between 0 and 1 
X*/
X        if (old_max != level)
X        { 
X          htemp /= (old_max - level);
X	} else
X        {
X          htemp = 0;
X	}
X        htemp = pow(1 + htemp,k) -1;
X      }
X      if (htemp > *maximum) *maximum = htemp;
X      if (htemp < *minimum) *minimum = htemp;
X      d_map[x][y] = htemp;
X    }
X  }
X}
X
Xgen_alt(wp,water_per,dim,lac,info_flag,fp)
X/* 
X   Here we generate the altitudes for the world.  First step is to create
X   a fractal array of doubles to scale.  We find where sea level should be,
X   and then scale up and down from sea level.
X*/
Xdouble dim,lac,water_per;
Xint info_flag;
XSworld *wp;
XFILE *fp;
X{
X  double max_height, min_height,sea_level,dry_factor,wet_factor,old_min;
X  double loc_min,loc_max;
X  int i,j,x,y,k,sea_perc,htemp,alt_hash[14];
X  int loc_x, loc_y;
X
X  printf("Generating Altitudes\n");
X  wp->geo.pwater = (int)(water_per * 100.0);
X  gen_arr(d_map,dim,lac,wp->xmax,wp->ymax,&max_height,&min_height);
X  old_min = min_height;
X
X/* Clear out the hash table, and then fill it again by level of map */
X  sea_level = find_level(wp,d_map,water_per, max_height, min_height);
X
X/*
X   Rescale by taking everything to the 0.5 power.  flattens out
X   the higher peaks
X*/
X  power_scale(wp,d_map,sea_level, 0.5 ,&min_height, &max_height);
X  sea_level = 0.0; /* Do power scales things to sea level for us */
X
X/* Scaling factors are determined for below and above sea_level */
X  dry_factor = (int)(13.0 / (max_height - sea_level));
X  wet_factor = (int)(7.0 / (sea_level - min_height));
X  sea_perc = 0;  /* redetermine the exact sea_percentage */
X  for (i=0; i < 13 ; i++) alt_hash[i] = 0; /* set the hash table to zero */
X/* Make one last loop over the world */
X  for (x = 0 ; x < wp->xmax ; x++)
X  {
X    for (y = 0 ; y < wp->ymax ; y++)
X    {
X      d_map[x][y] = d_map[x][y] - sea_level;
X      if ((d_map[x][y] >= 0.0) && (water_per < 1.0))/* Dry land */
X      {
X        htemp = (int) (d_map[x][y] * dry_factor);
X        htemp++; /* We want 50% less lowlands */
X        if (htemp > 8) htemp--; /* We want 50% more mountains */
X        if (htemp > 10) htemp--; /* We want 50% more peaks */
X        htemp /= 2;
X        if (htemp > 5)
X        {/* If somehow the scaling is fucked */
X          printf("htemp error %d at %d %d\n",htemp,x,y);
X          fprintf(fp,"htemp error %d at %d %d\n",htemp,x,y);
X          htemp = 6;
X        }
X        else htemp++;  /* needs to be between 1 and 6, not 0 and 5 */
X        wp->map[x][y].altitude = htemp;
X        alt_hash[htemp + 5]++;  /* one more sector of htemp altitude */
X      } else if (d_map[x][y] < 0.0) /* Dry land */
X      {
X        sea_perc++;           /* One more sea sector */
X        htemp = (int)(d_map[x][y] * wet_factor);
X        htemp--;  /* number need to be -1 to -6 not 0 to -5 */
X        if (htemp < OCEAN_PLAINS ) htemp++;  /* Makes more ocean_plains */
X        if (htemp < TRENCH ) htemp++;  /* Makes more trench */
X        if (htemp < -5)
X        { /* If somehow the scaling if fucked. */
X          printf("htemp error %d at %d %d\n",htemp,x,y);
X          fprintf(fp,"htemp error %d at %d %d\n",htemp,x,y);
X          htemp = -5;
X        } 
X        wp->map[x][y].altitude = htemp; 
X        alt_hash[htemp + 5]++;  /* one more sector of htemp altitude */
X      }
X    }
X  }
X/* Now determine the sea percentage more exactly, rounding correctly */
X  sea_perc = (int)((((double)sea_perc * 100.0) /
X                (double)(wp->xmax * wp->ymax)) + 0.49);
X  if (info_flag == 3)
X  {
X    printf("Percentage of water : %d%%\n",sea_perc);
X    for (i= 0 ; i <= 11 ; i++) {
X      if ( i != 5) {
X        printf("%d sectors are %s\n",alt_hash[i],altitude_map[i].name);
X      } 
X    }
X  }
X  if (fp != NULL) {
X    fprintf(fp,"Altitude Fractal Dimension : %lf\n",3.0 - dim);
X    fprintf(fp,"Percentage of water : %d%%\n",sea_perc);
X    for (i= 0 ; i <= 11 ; i++) {
X     if (i != 5) {
X      fprintf(fp,"%d sectors are %s\n",alt_hash[i],altitude_map[i].name);
X     }
X    }
X  }
X}
X
Xgen_climate(dim,lac,wp,info_flag,fp)
X/* 
X   Here we generate the climates for the world.  First step is to create
X   a fractal array of doubles to scale.  Then we modify everything by
X   multiplying it by a sin function, thereby producing the lowest values
X   (0) at the beginning and the end.  Then we add a linear factor
X   into the polar regions, and a constant factor to everywhere else
X   to raise things up a bit.  Lastly we scale things over 11 climates
X   for land, and 9 climates for water (water has no deserts)
X   When we determine the climate, a certain base terrain type goes
X   with it.  That gets adjusted later.
X*/
Xdouble dim,lac;
Xint info_flag;
XSworld *wp;
XFILE *fp;
X{
X  double max_height, min_height,dtemp,old_min,old_max;
X  int i,x,y,htemp,artic_region,hashes[12];
X
X  printf("Generating Climates\n");
X/* Generate the original array */
X  gen_arr(d_map,dim,lac,wp->xmax,wp->ymax,&max_height,&min_height);
X  old_min = min_height; max_height = -50; min_height = 50;
X/* Do the sin function filter */
X  for (x = 0 ; x < wp->xmax ; x++)
X  {
X    for (y = 0 ; y < wp->ymax ; y++)
X    {
X      d_map[x][y] = d_map[x][y] - old_min;
X      d_map[x][y] = sin((double)y * M_PI/(double)(wp->ymax)) * d_map[x][y];
X      if (d_map[x][y] < min_height ) min_height = d_map[x][y];
X      if (d_map[x][y] > max_height ) max_height = d_map[x][y];
X    }
X  }
X  old_max = max_height; old_min = min_height;
X  max_height = -50; min_height = 50;
X/* Scale things linearly up over the artic and polar regions */
X  artic_region = wp->ymax / 5;
X  for (x = 0 ; x < wp->xmax ; x++)
X  {
X    for (y = 0 ; y < wp->ymax ; y++)
X    {
X      dtemp = (old_max - old_min)/9.0;
X      if (y < artic_region)
X      { 
X        d_map[x][y] += dtemp * (double)y / (((double)artic_region)/2.0);
X      }
X      else if ((wp->ymax - y) < artic_region)
X      { 
X        d_map[x][y] += dtemp*(double)(wp->ymax-y)/((double)artic_region/2.0);
X      }
X      else
X      {
X        d_map[x][y] += 2.0 * dtemp;
X      }
X      if (d_map[x][y] > max_height) max_height = d_map[x][y];
X      if (d_map[x][y] < min_height) min_height = d_map[x][y];
X    }
X  }
X
X/* Standard scaling */
X  for (i=0;i<11;i++) hashes[i] = 0;
X  for (x = 0 ; x < wp->xmax ; x++)
X  {
X    for (y = 0 ; y < wp->ymax ; y++)
X    {
X      if (wp->map[x][y].altitude < 0)
X      {
X        htemp = (int)(((d_map[x][y]-min_height)*9.0)/(max_height-min_height));
X      } else
X      {
X        htemp = (int)(((d_map[x][y]-min_height)*12.0)/(max_height-min_height));
X        if (htemp > 10) htemp--; /* We want more desert */
X      }
X      if (htemp >= 11)
X      {
X       htemp = 10;
X      }
X      htemp = 11 - (htemp + 1);
X      wp->map[x][y].climate = htemp;
X      if (wp->map[x][y].altitude < 0)
X      {
X/* If it's an ocean be terrain type ocean. */
X         wp->map[x][y].terrain = -5;
X      } else
X      {
X        wp->map[x][y].terrain = cli_terr[htemp];
X      }
X      hashes[htemp]++;
X    }
X  }
X  if (info_flag == 3)
X  {
X    for (i= 0 ; i < 11 ; i++)
X    {
X      printf("%d sectors have %s climate \n",hashes[i],climates[i].name);
X    }
X  }
X  if (fp != NULL)
X  {
X    fprintf(fp,"\nClimate Fractal Dimension: %lf\n",3.0 - dim);
X    for (i = 0 ; i < 11 ; i++)
X    {
X      fprintf(fp,"%d sectors have %s climate \n",hashes[i],climates[i].name);
X    }
X  }
X}
X
Xadjust_terrain(wp)
X/*
X   This function adjusts the terrain starting at the base level
X   given by the climate, and adjusting for altitude.
X*/
XSworld *wp;
X{
X  int x,y;
X
X  for (x = 0 ; x < wp->xmax; x++)
X  {
X    for (y = 0 ; y < wp->ymax ; y++)
X    {
X      if (wp->map[x][y].altitude > HILLS)
X      {
X        wp->map[x][y].terrain--;
X        if (wp->map[x][y].altitude > MOUNTAINS)
X        {
X          wp->map[x][y].terrain--;
X        }
X        if (wp->map[x][y].terrain < ICE) wp->map[x][y].terrain = ICE;
X        else if (wp->map[x][y].terrain == SWAMP) wp->map[x][y].terrain= BARREN;
X      } 
X      else if (wp->map[x][y].altitude == LOWLANDS)
X      {
X        if ((wp->map[x][y].climate > 1 ) && (wp->map[x][y].climate < 9))
X        {
X          if ((wp->map[x][y].terrain != FOREST) && (RND() % 4 == 0))
X          {
X            wp->map[x][y].terrain = SWAMP;
X          }
X        }
X      }
X    }
X  }
X}
X
Xgen_metal(wp,metal_per,metal_avg,info_flag,fp)
X/*
X  This function distributes the metal over the world.  The location of
X  the metal deposits is determined fractally, and the value of the
X  deposits is determined randomly, with a gaussian distribution.  The
X  average metal in a sector is metal_avg and the percentage of sectors
X  with any metal at all is metal_per
X*/
Xdouble metal_per,metal_avg;
Xint info_flag;
XSworld *wp;
XFILE *fp;
X{
X  double maximum, minimum,dtemp,old_min,old_max,zero_level;
X  int i,x,y,htemp,hashes[41],k, tot_sect = 0, tot_met = 0, max_met = 0;
X
X  printf("Generating Metal\n");
X  wp->geo.metal_avg = metal_avg;
X  minimum = 10000.0; maximum = -13000.0;
X  for (x = 0 ; x < wp->xmax ; x++)
X  {
X    for (y = 0 ; y < wp->ymax ; y++)
X    {
X      d_map[x][y] = (double)(RND() % 10000) + 1000.0;
X      switch(wp->map[x][y].altitude) 
X      {
X/* Hill, and the like are more probable to have metal */
X        case HILLS:
X        case MOUNTAIN_PEAK:
X        case TRENCH:
X        case CONT_SHELF: d_map[x][y] += 1000; break;
X/* mountains are even more probable to have metal */
X        case SEA_MOUNT:
X        case MOUNTAINS: d_map[x][y] += 2000; break;
X/* Plains lowlands and shallows are less probable */
X        case PLAINS:
X        case LOWLANDS:
X        case SHALLOWS: d_map[x][y] -= 1000; break;
X      }
X      if (minimum > d_map[x][y]) minimum = d_map[x][y];
X      if (maximum < d_map[x][y]) maximum = d_map[x][y];
X    }
X  }
X/* Find the cutoff level for metal */
X  zero_level = find_level(wp,d_map,metal_per, maximum, minimum);
X
X  for (i=0;i<40;i++) hashes[i] = 0;
X/* Then fill all the sectors that have metal with some amount of metal */
X  for (x = 0 ; x < wp->xmax ; x++)
X  {
X    for (y = 0 ; y < wp->ymax ; y++)
X    {
X      if (d_map[x][y] > zero_level)
X      {
X        dtemp = fabs((Gauss() + Gauss()))/2.0;
X        dtemp *= metal_avg;
X        dtemp /= 0.651;
X        htemp = (int)(dtemp) + 1;
X        wp->map[x][y].metal = htemp;
X        tot_sect++;
X        tot_met += htemp;
X        if (max_met < htemp) { max_met = htemp; }
X        if (htemp > 20) { hashes[20]++; }
X        else { hashes[htemp]++; }
X      } else hashes[0]++;
X    }
X  }
X  if (info_flag == 3)
X  {
X    printf("There are %d sectors with metal\n",tot_sect);
X    max_met = min(max_met, 20);
X    for (i= 0 ; i < max_met  ; i++)
X    {
X      printf("There are %d sectors with %d metal\n",hashes[i],i);
X    }
X    if (max_met < 20)
X    {
X      printf("There are %d sectors with %d metal\n",hashes[max_met],max_met);
X    } else
X    {
X      printf("There are %d sectors over %d metal\n",hashes[max_met],max_met-1);
X    }
X  }
X  if (fp != NULL)
X  { 
X    fprintf(fp,"\nMetal Chance %d%% with %lf average\n",
X              (int)((1.0 - metal_per) * 100.0),metal_avg);
X    fprintf(fp,"Total Metal %d over %d sectors with %d maximum\n",
X            tot_met,tot_sect ,max_met);
X    max_met = min(max_met, 20);
X    for (i= 0 ; i < max_met  ; i++)
X    {
X      fprintf(fp,"There are %d sectors with %d metal\n",hashes[i],i);
X    }
X    if (max_met < 20)
X    {
X      fprintf(fp,"There are %d sectors with %d metal\n",hashes[max_met],
X             max_met);
X    } else
X    {
X      fprintf(fp,"There are %d sectors over %d metal\n",hashes[max_met],
X               max_met-1);
X    }
X  }
X
X}
X
Xgen_jewel(wp,jewel_per,jewel_avg,info_flag,fp)
X/* 
X   This adds jewels to the world the same way metal is added.
X   If you understood gen_metal, you understand this.  They are
X   basically the same.
X*/
Xdouble jewel_per, jewel_avg;
Xint info_flag;
XSworld *wp;
XFILE *fp;
X{
X  double maximum, minimum,dtemp,old_min,old_max,zero_level;
X  int i,x,y,htemp,hashes[41],k,tot_sect = 0, tot_jewels = 0, max_jewel = 0; 
X
X  printf("Generating Jewels\n");
X  wp->geo.jewel_avg = jewel_avg;
X  minimum = 10000.0; maximum = -13000.0;
X  for (x = 0 ; x < wp->xmax ; x++)
X  {
X    for (y = 0 ; y < wp->ymax ; y++)
X    {
X      d_map[x][y] = (double)(RND() % 10000) + 1000.0;
X      switch(wp->map[x][y].altitude) 
X      {
X        case HILLS:
X        case MOUNTAIN_PEAK:
X        case TRENCH:
X        case CONT_SHELF: d_map[x][y] += 1000; break;
X        case SEA_MOUNT:
X        case MOUNTAINS: d_map[x][y] += 2000; break;
X        case PLAINS:
X        case LOWLANDS:
X        case SHALLOWS: d_map[x][y] -= 1000; break;
X      }
X      if (minimum > d_map[x][y]) minimum = d_map[x][y];
X      if (maximum < d_map[x][y]) maximum = d_map[x][y];
X    }
X  }
X  zero_level = find_level(wp,d_map,jewel_per, maximum, minimum);
X  for (i=0;i<40;i++) hashes[i] = 0;
X  for (x = 0 ; x < wp->xmax ; x++)
X  {
X    for (y = 0 ; y < wp->ymax ; y++)
X    {
X      if (d_map[x][y] > zero_level)
X      {
X        dtemp = fabs((Gauss() + Gauss()))/2.0;
X        dtemp *= jewel_avg;
X        dtemp /= 0.651;
X        htemp = (int)(dtemp) + 1;
X        wp->map[x][y].jewels = htemp;
X        tot_sect++;
X        tot_jewels += htemp;
X        if (max_jewel < htemp) { max_jewel = htemp; }
X        if (htemp > 20) { hashes[20]++; }
X        else { hashes[htemp]++; }
X      } else hashes[0]++;
X    }
X  }
X  if (info_flag == 3)
X  {
X    printf("There are %d sectors with jewels\n\n",tot_sect);
X    max_jewel = min(max_jewel, 20);
X    for (i= 0 ; i < max_jewel  ; i++)
X    {
X      printf("There are %d sectors with %d jewels\n",hashes[i],i);
X    }
X    if (max_jewel < 20)
X    {
X      printf("There are %d sectors with %d jewels\n",hashes[max_jewel],
X               max_jewel);
X    } else
X    {
X      printf("There are %d sectors over %d jewels\n",hashes[max_jewel],
X             max_jewel-1);
X    }
X  }
X  if (fp != NULL)
X  {
X    fprintf(fp,"\nJewels Percentage %d%% at %lf average\n",
X                  (int)((1.0 - jewel_per) * 100.0),jewel_avg);
X    fprintf(fp,"Total %d Jewels over %d sectors with %d max\n",
X               tot_jewels, tot_sect, max_jewel);
X    max_jewel = min(max_jewel, 20);
X    for (i= 0 ; i < max_jewel  ; i++)
X    {
X      fprintf(fp,"There are %d sectors with %d jewels\n",hashes[i],i);
X    }
X    if (max_jewel < 20)
X    {
X      fprintf(fp,"There are %d sectors with %d jewels\n",hashes[max_jewel],
X                max_jewel);
X    } else
X    {
X       fprintf(fp,"There are %d sectors over %d jewels\n",hashes[max_jewel],
X              max_jewel-1);
X    }
X  }
X}
X
Xgen_soil(wp,dim,lac,average,info_flag,fp)
X/* 
X   This routine sets the soil value for each sector.  To some degree
X   this is done fractally, and to some degree it is determined by
X   the terrain type and altitude of the sector in question.  As well
X   lots of metal and jewels in the region will limit the ammount of
X   food obtainable
X*/
Xdouble dim,lac,average;
Xint info_flag;
XSworld *wp;
XFILE *fp;
X{
X  double max_soil, min_soil,dtemp,old_min,old_max, total = 0.0, avg ;
X  int i,x,y,htemp,hashes[41], max_s = 0;
X
X  printf("Generating Soil\n");
X  wp->geo.soil_avg = average;
X  gen_arr(d_map,dim,lac,wp->xmax,wp->ymax,&max_soil,&min_soil);
X  old_min = min_soil; max_soil = -50; min_soil = 50;
X/* Generate the basic soil fertility by fractal methods */
X  for (x = 0 ; x < wp->xmax ; x++)
X  {
X    for (y = 0 ; y < wp->ymax ; y++)
X    {
X      d_map[x][y] = d_map[x][y] - old_min;
X      d_map[x][y] = (d_map[x][y]/ (old_max- old_min)) * 8.0;
X/* 
X      d_map[x][y] = sin(((double)(y* M_PI)/(double)(wp->ymax*1.5))+ (M_PI/6.0))
X                    * d_map[x][y];
X*/
X      if (d_map[x][y] < min_soil ) min_soil = d_map[x][y];
X      if (d_map[x][y] > max_soil ) max_soil = d_map[x][y];
X    }
X  }
X  for (i=0;i<40;i++) hashes[i] = 0;
X  for (x = 0 ; x < wp->xmax ; x++)
X  {
X    for (y = 0 ; y < wp->ymax ; y++)
X    {
X/* Modify food production by altitude */
X      switch(wp->map[x][y].altitude) 
X      {
X        case TRENCH:         d_map[x][y] -= 2.0;  break;
X        case SEA_MOUNT:      d_map[x][y] -= 1.0;  break;
X        case OCEAN_PLAINS:   d_map[x][y] += 0.0;  break;
X        case CONT_SHELF:     d_map[x][y] += 1.0;  break;
X        case SHALLOWS:       d_map[x][y] += 2.0;  break;
X        case LOWLANDS:       d_map[x][y] += 2.0;  break;
X        case PLAINS:         d_map[x][y] += 1.0;  break;
X        case HILLS:          d_map[x][y] -= 0.5;  break;
X        case PLATEAU:        d_map[x][y] -= 0.2;  break;
X        case MOUNTAINS:      d_map[x][y] -= 1.0;  break;
X        case MOUNTAIN_PEAK:  d_map[x][y] -= 2.0;  break;
X      }
X/* Modify food production by climate type */
X      switch(wp->map[x][y].altitude) 
X      {
X        case 0:         d_map[x][y] -= 1.5;  break;
X        case 1:         d_map[x][y] -= 0.7;  break;
X        case 2:         d_map[x][y] += 0.0;  break;
X        case 3:         d_map[x][y] += 0.0;  break;
X        case 4:         d_map[x][y] += 0.0;  break;
X        case 5:         d_map[x][y] += 0.0;  break;
X        case 6:         d_map[x][y] += 0.6;  break;
X        case 7:         d_map[x][y] += 0.2;  break;
X        case 8:         d_map[x][y] += 0.0;  break;
X        case 9:         d_map[x][y] -= 0.5;  break;
X        case 10:        d_map[x][y] -= 1.1;  break;
X      }
X   
X/* Modify food production by terrain type */
X      switch(wp->map[x][y].terrain)
X      {
X        case -5:  d_map[x][y] += 0.0;  break;
X        case -4:  d_map[x][y] += 0.0;  break;
X        case -3:  d_map[x][y] += 0.0;  break;
X        case -2:  d_map[x][y] += 1.0;  break;
X        case -1:  d_map[x][y] += 1.0;  break;
X        case 0 :  d_map[x][y] -= 2.0;  break;
X        case 1:   d_map[x][y] -= 1.0;  break;
X        case 2:   d_map[x][y] += 0.0;  break;
X        case 3:   d_map[x][y] += 1.0;  break;
X        case 4:   d_map[x][y] += 1.5;  break;
X        case 5:   d_map[x][y] += 2.0;  break;
X        case 6:   d_map[x][y] += 2.5;  break;
X      }
X/* Remove food for excess metals and jewels, rounding down */
X      d_map[x][y] -= (int)(wp->map[x][y].metal / 8);
X      d_map[x][y] -= (int)(wp->map[x][y].jewels / 8);
X/* Give the people beneath the see food for fishing */
X      if (wp->map[x][y].altitude < 0)
X      {
X         d_map[x][y] += 1;  /* Fish */
X      }
X/* Minimum soil is 0 */
X      if (d_map[x][y] < 0 )
X      {
X        d_map[x][y] = 0;
X      }
X      total += d_map[x][y];
X    }
X  }
X  avg = total / (double)(wp->xmax * wp->ymax);
X  for (x = 0 ; x < wp->xmax ; x++)
X  {
X    for (y = 0 ; y < wp->ymax ; y++)
X    {
X      htemp = (int)(((d_map[x][y]/avg)*average) + 0.49);
X      if (max_s < htemp) { max_s = htemp;}
X      if (htemp > 20) { hashes[20]++; }
X      else { hashes[htemp]++; }
X      wp->map[x][y].soil = htemp;
X    }
X  }
X  if (info_flag == 3)
X  {
X    max_s = min(max_s, 20);
X    for (i= 0 ; i < max_s  ; i++)
X    {
X      printf("There are %d sectors with %d soil\n",hashes[i],i);
X    }
X    if (max_s < 20)
X    {
X      printf("There are %d sectors with %d soil\n",hashes[max_s],max_s);
X    } else
X    {
X      printf("There are %d sectors over %d soil\n",hashes[max_s],max_s-1);
X    }
X  }
X  if (fp != NULL)
X  {
X    fprintf(fp,"\nSoil Adjustment Factor %lf Maximum is %d\n",average,max_s);
X    max_s = min(max_s, 20);
X    for (i= 0 ; i < max_s  ; i++)
X    {
X      fprintf(fp,"There are %d sectors with %d soil\n",hashes[i],i);
X    }
X    if (max_s < 20)
X    {
X      fprintf(fp,"There are %d sectors with %d soil\n",hashes[max_s],max_s);
X    } else
X    {
X      fprintf(fp,"There are %d sectors over %d soil\n",hashes[max_s],max_s-1);
X    }
X  }
X}
X
Xexplain(help_num)
Xint help_num;
X{
X  switch(help_num)
X  {
X    case 0:
X    {
X      printf("The fractal dimenstion of a given region determines it's\n");
X      printf("relative smoothness. A number close to 2 will be very smooth\n");
X      printf("as the surface is trying to get closer to a plane (a two \n");
X      printf("dimensional object) and as it gets closer to 3 it will\n");
X      printf("become more and more jagged, trying to approximate a space\n");
X      printf("filling surface.  The value must be between 2 and 3\n");
X      printf("but not equal to either 2 or 3\n");
X      break;
X    }
X    case 1:
X    {
X      printf("Percentages are integers between 0 and 100 inclusive\n");
X      break;
X    }
X    case 2:
X    {
X      printf("A default world is one in which the default settings are\n");
X      printf("used with respect to world design.   The user is left with\n");
X      printf("the options concerning width, height, and water percentage\n\n");
X      printf("A customized world allows the user to choose the options at\n");
X      printf("each step in the process (such as metal level etc.)\n\n");
X      printf("A customized world with confirmation will use the values\n");
X      printf("given to create a world, and then will show some statistics\n");
X      printf("at each step, asking the user to confirm that that is indeed\n");
X      printf("what they had in mind.  This is the most verbose option.\n");
X      break;
X    }
X    case 4:
X    {
X      printf("Both the height and width of the world must be integers\n");
X      printf("which are at least 8 and at most whatever you machine can\n");
X      printf("handle.  Be aware that there is a lot of memory usage per\n");
X      printf("sector, so you may run out of swap space and have to restart\n");
X      printf("if you are overly optimistic.\n");
X      break;
X    }
X    default:
X    {
X      printf("No help is available for this topic at this time \n");
X      break;
X    }
X  }
X}
X
Xget_int(prompt, help_num, value)
Xchar *prompt;
Xint help_num, *value;
X{
X  int rtvl;
X  char tmp[100];
X  
X  rtvl = -100;
X  while (rtvl == -100)
X  {
X    printf("%s",prompt);
X    fgets(tmp, 99,stdin);
X    if (sscanf(tmp,"%d",value) == 1)
X    {
X      rtvl = 0;
X    } else if (tmp[0] == '?')
X    {
X      explain(help_num);
X    }
X  }
X  return rtvl;
X}
X
Xget_double(prompt, help_num, value)
Xchar *prompt;
Xint help_num;
Xdouble *value;
X{
X  int rtvl;
X  char tmp[100];
X  
X  rtvl = -100;
X  while (rtvl == -100)
X  {
X    printf("%s",prompt);
X    fgets(tmp, 99,stdin);
X    if (sscanf(tmp,"%lf",value) == 1)
X    {
X      rtvl = 0;
X    } else if (tmp[0] == '?')
X    {
X      explain(help_num);
X    }
X  }
X  return rtvl;
X}
X
Xset_compressed()
X{
X  char s[100];
X
X  printf("\nDo you wish the world file to be compressed? ");
X  fgets(s,99,stdin);
X  if ((s[0] == 'y') || (s[0] == 'Y'))
X  {
X    compressed_world = 1;
X  }
X  printf("\nYou can change your mind at any time by manually compressing or\n");
X  printf("uncompressing the file %s/%s\n\n\n",libdir,WORLD_FILE);
X}
X
X
Xmain (argc, argv)
X     int argc;
X     char *argv[];
X{
X  extern char *optarg;
X  extern int optind;
X  int i,j, percent, info_flag = 0, conf_flag;
X  int c;
X  double fracdim = -1.0,lacun = (2.0/3.0), perc_d, average;
X  FILE *fp;
X
X  strcpy(libdir, DEF_LIBDIR);
X
X  while ((c = getopt(argc, argv, "d:--")) != EOF)
X  {
X    switch (c)
X    {
X      case 'd':
X        strcpy(libdir, optarg);
X        break;
X    }
X  }
X
X  if (chdir(libdir) == -1) {
X    fprintf(stderr,"Error: cannot cd to directory %s\n",libdir);
X    clean_exit();
X    exit();
X  }
X  SRND(time(0L));		/* initialize random number generator */
X  read_races();			/* get races from races file */
X  world.turn = 0;
X  if ((fp = fopen(STATFILE,"w")) == NULL)
X  {
X    fprintf(stderr,"Error: Could not write to specified directory\n");
X    fprintf(stderr,"Please check permissions and try again\n");
X    clean_exit();
X    exit(1);
X  }
X
X  printf("At any prompt hit ? and return to get more information\n");
X  printf("(if there is anything more available)\n\n");
X
X  printf("Do you wish 1) A default settings world 2) A customized world\n");
X  printf("         or 3) A customized world with confirmed completions \n");
X  
X  info_flag = -1;
X  while ((info_flag < 0) || (info_flag > 3))
X  {
X    get_int("Choice (1,2,3) : ",2,&info_flag);
X  }
X
X  printf("\nThe world will be shaped like a torus, as that is the only\n");
X  printf("shape implemented as of yet.\n");
X  world.geo.topology = TORUS;
X  init_wrap();
X
X  world.xmax = -1;
X  while (world.xmax < 8 )
X  {
X    get_int("Please enter the width of the world (min 8): ",4,&(world.xmax));
X  }
X  world.ymax = -1;
X  while (world.ymax < 8 )
X  {
X    get_int("Please enter the height of the world (min 8): ",4,&(world.ymax));
X  }
X  
X  init_d_map(world.xmax,world.ymax);
X  if ((world.map = (Ssector **)malloc(sizeof(Ssector *) * world.xmax)) == NULL)
X  {
X    mem_error();
X  }
X  for (i=0;i<world.xmax;i++)
X  {
X    if ((world.map[i] = (Ssector *)malloc(sizeof(Ssector)*world.ymax)) == NULL)
X    {
X      mem_error();
X    }
X  }
X  for (i=0;i<world.xmax;i++)
X  {
X    for (j=0;j<world.ymax;j++)
X    {
X      init_sector(world.map,i,j);
X    }
X  }
X
X  conf_flag = 0;
X  while (conf_flag != 1)
X  {
X   if (info_flag == 1)
X   {
X     fracdim = 2.75;
X   } else
X   {
X    if (conf_flag != 2)
X    {
X     printf("\nThe altitude will be determined using fractal methods. You\n");
X     printf("should enter the value for the fractal dimension of the\n");
X     printf("world. The number should be between 2 and 3, not inclusive.\n");
X     printf("The suggested value is 2.75\n");
X     fracdim = 0;
X     while ((fracdim <= 2) || (fracdim >=3))
X     {
X       get_double("Dimension is : ",0,&fracdim);
X     }
X    } else { fracdim += 3.0; }
X   }
X   fracdim = 3.0 - fracdim;
X   if (conf_flag != 2)
X   {
X    printf("\nPlease enter the percentage of water you wish in your\n");
X    printf("world.  The value must be between 0 and 100.\n");
X    percent = -1;
X    while ((percent < 0 ) || (percent > 100))
X    {
X      get_int("Percentage of water: ",1,&percent);
X    }
X    perc_d = (double)percent/100.0;
X   }
X   gen_alt(&world,perc_d,fracdim,lacun,info_flag,fp);
X   if (info_flag == 3)
X   {
X     conf_flag = -1;
X     while ((conf_flag < 1) || (conf_flag > 3))
X     {
X       get_int("1) Ok Proceed 2) Redo w/same 3) Reenter stats : ",
X                 3,&conf_flag);
X     }
X   } else { conf_flag = 1; }
X  }
X
X  conf_flag = 0;
X  if (info_flag == 1)
X  {
X    fracdim = 0.7;
X    gen_climate(fracdim,lacun,&world,info_flag,fp);
X  } else
X  {
X   while (conf_flag != 1)
X   {
X    if (conf_flag != 2)
X    {
X      printf("\nThe climate will be fractally distributed.  The entered\n");
X      printf("dimension is a value between 2 and 3 not inclusive.  A \n");
X      printf("suggested value would be 2.3 \n");
X      fracdim = 0;
X      while ((fracdim <= 2) || (fracdim >=3))
X      {
X        get_double("Dimension is : ",0,&fracdim);
X      }
X      fracdim = 3.0 - fracdim;
X    }
X    gen_climate(fracdim,lacun,&world,info_flag,fp);
X    if (info_flag == 3)
X    {
X      conf_flag = -1;
X      while ((conf_flag < 1) || (conf_flag > 3))
X      {
X        get_int("1) Ok Proceed 2) Redo w/same 3) Reenter stats : ",
X                  3,&conf_flag);
X      }
X    } else { conf_flag = 1; }
X   }
X  }
X  adjust_terrain(&world);
X
X  conf_flag = 0;
X  if (info_flag == 1)
X  {
X    perc_d = 1.0 - 0.15;
X    average = 4.5;
X    gen_metal(&world,perc_d,average,info_flag,fp);
X  } else 
X  {
X   while (conf_flag != 1)
X   {
X    if (conf_flag != 2)
X    {
X      printf("\nPlease enter the percentage of sectors with metal, and the\n");
X      printf("average value for those sectors. The suggested values are\n");
X      printf("15 percent and an avererage of 4.5\n");
X      percent = -1;
X      while ((percent < 0 ) || (percent > 100))
X      {
X        get_int("Perctage of sectors with metal: ",1,&percent);
X      }
X      perc_d = 1.0 - ((double)percent/100.0);
X      average = -1.0;
X      while (average < 0.0 )
X      {
X        get_double("Average value of metal sector: ",-1,&average);
X      }
X    }
X    gen_metal(&world,perc_d,average,info_flag,fp);
X    if (info_flag == 3)
X    {
X      conf_flag = -1;
X      while ((conf_flag < 1) || (conf_flag > 3))
X      {
X        get_int("1) Ok Proceed 2) Redo w/same 3) Reenter stats : ",
X                  3,&conf_flag);
X      }
X    } else { conf_flag = 1; }
X   }
X  }
X
X  conf_flag = 0;
X  if (info_flag == 1)
X  {
X    perc_d = 1.0 - 0.12;
X    average = 4.0;
X    gen_jewel(&world,perc_d, average,info_flag,fp);
X  } else
X  {
X   while (conf_flag != 1)
X   {
X    if (conf_flag != 2)
X    {
X      printf("\nPlease enter the percentage of sectors with jewels, and\n");
X      printf("the average value for those sectors. The suggested values\n");
X      printf("are 12 percent and an avererage of 4.0\n");
X      percent = -1;
X      while ((percent < 0 ) || (percent > 100))
X      {
X        get_int("Perctage of sectors with jewels: ",1,&percent);
X      }
X      perc_d = 1.0 - ((double)percent/100.0);
X      average = -1.0;
X      while (average < 0.0 )
X      {
X        get_double("Average value of jewel sector: ",-1,&average);
X      }
X    }
X    gen_jewel(&world,perc_d, average,info_flag,fp);
X    if (info_flag == 3)
X    {
X      conf_flag = -1;
X      while ((conf_flag < 1) || (conf_flag > 3))
X      {
X        get_int("1) Ok Proceed 2) Redo w/same 3) Reenter stats : ",
X                  3,&conf_flag);
X      }
X    } else { conf_flag = 1; }
X   }
X  }
X
X  conf_flag = 0;
X  if (info_flag == 1)
X  {
X    average = 5.0;
X    gen_soil(&world,fracdim,lacun,average,info_flag,fp);
X  } else
X  {
X   while (conf_flag != 1)
X   {
X    if (conf_flag != 2)
X    {
X      printf("\nPlease enter the value for the average soil value\n");
X      printf("5.0 is the suggested average.  Be careful with soil\n");
X      average = -1.0;
X      while (average < 0.0 )
X      {
X        get_double("Richness of soil: ",-1,&average);
X      }
X    }
X    gen_soil(&world,fracdim,lacun,average,info_flag,fp);
X    if (info_flag == 3)
X    {
X      conf_flag = -1;
X      while ((conf_flag < 1) || (conf_flag > 3))
X      {
X        get_int("1) Ok Proceed 2) Redo w/same 3) Reenter stats : ",
X                  3,&conf_flag);
X      }
X    } else { conf_flag = 1; }
X   }
X  }
X  init_gamemaster(world.nations);
X  world.n_nations = 1;
X/*  world.geo.depth = 2;
X  world.geo.sides = 1;
X*/
X  fclose (fp);
X  set_compressed();
X  write_world(&world, WORLD_FILE);
X  set_update_time();
X  exit(0);
X}
X
Xclean_exit(){};
X
END_OF_FILE
if test 43814 -ne `wc -c <'makeworld.c'`; then
    echo shar: \"'makeworld.c'\" unpacked with wrong size!
fi
# end of 'makeworld.c'
fi
echo shar: End of archive 15 \(of 28\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Now execute ./do_cat.sh to build doc files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
