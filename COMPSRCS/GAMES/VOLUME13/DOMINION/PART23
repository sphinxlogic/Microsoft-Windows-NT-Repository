Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i059:  dominion - a multi-player world simulation game, Part23/28
Message-ID: <2462@masterCNA.TEK.COM>
Date: 11 Feb 92 18:27:19 GMT
Sender: news@masterCNA.TEK.COM
Lines: 2202
Approved: billr@saab.CNA.TEK.COM

Submitted-by: rosalia@dirac.physics.sunysb.edu (Mark Galassi)
Posting-number: Volume 13, Issue 59
Archive-name: dominion/Part23
Environment: Unix, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 23 (of 28)."
# Contents:  THE_STORY budget.c commands.c reports.c
# Wrapped by billr@saab on Tue Feb 11 10:14:57 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'THE_STORY' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'THE_STORY'\"
else
echo shar: Extracting \"'THE_STORY'\" \(5116 characters\)
sed "s/^X//" >'THE_STORY' <<'END_OF_FILE'
XSo you want to know how this all got started?
X
XWell, Keith Messing and Mark Galassi each decided to attend
XSUNY at Stony Brook in the fall of 1987.  Keith was a first semester
Xundergraduate of electrical engineering, and Mark was a first semester
Xgraduate student of the Institute for Theoretical Physics (ITP).
X
XIt must have been fate (kismet, etc) that brought them together in
XPhysics 101, section 13 (a lucky number, no doubt).  This was the
XIntroduction to Classical Physics (a requirement for e.e. majors)
Xthat had its disgustingly boring lab section on Thursday nights.
X
XMark, was the instructor of that Thursday night lab section.  He
Xwas interesting/weird, yet very friendly all at the same time...
XJust the kind a guy you would want to get to know.
XWell one week, Keith was way behind in his work (truly uncharacteristic
Xbehavior) and he was not going to be able to submit his lab report
Xon time.  He timidly approached Mark, and asked for an extension.
XMark obliged, and yet expressed a concern for what seemed like
Xa terrible lack of motivation on Keith's part.
X
XOn that day, and after an extensive conversation, their friendship was
Xborn.  In no time, Mark showed Keith around the ITP and introduced
Xhim to all these great computers that they had.
X
XThen there was this game.
X
XIt was called Conquer.
X
XMark had put "his nation" on the screen for him to see, but all Keith could
Xsee were a bunch of characters... letters and dashes and squiggles all over
Xthe place, and none of it really made any sense.... but
Xby the way Mark talked about it, it fascinated him!
X
XKeith was interested, although he didn't know why.  Mark offered to add him
Xto the game, and therefore also give him an account on the machine.
XAs a freshman, he had never dreamed of having access to these machines,
Xor knowing the super-user of them personally.
X
XHe watched as Mark became the superuser and added his account.
XHE ACTUALLY GOT TO CHOOSE my login name.  Wow!!!!
XFor lack of any other creative name, he asked for 'keith'.
XSoon after, Mark created Keith's nation to be added to the conquer
Xworld.
X
XHe played nation "The_Bronx", and his leader was Randolph.....
X
XLittle did he realize that he was playing Conquer version 2.
XLittle did he realize that this incident would come back to haunt
Xhim two years later.
X
X==================
X
XTwo years later....
X
XIt was late in the fall of 1989.  Mark and Keith are still friends,
Xalthough they don't often find much time to spend together.
XAt some point late in the fall, Keith approached Mark with the idea
Xof porting the latest version of Conquer and playing it campus wide
Xon the new HP system.
X
XMark enthusiastically supported his idea, and said they would do it.
X
XThus began the adventure and trauma.  There was FIRST_EARTH,
Xthe first attempt at playing the game.  This featured nations like
XRochelle, Belegost, Theorland, Nightmare, Avalon, and many more....
XAvalon had two consecutive peasant revolts!!!  And then the world
Xcrashed, because some evil High School student wanted to be added to the
Xgame.  UGH!
XMeanwhile, Avalon, had gone wimpering off to start his own game....
XThis became known as SECOND_EARTH.  But Dave Buksbaum learned little
Xfrom the tragedy of FIRST_EARTH.  He did not back up his world, and it
Xtoo crashed!
X
XTHEN THERE WAS THIRD EARTH!
X
XWe all know it well. The personalities that were there in that dimension
Xwill long be remembered.  Ender of Skighton, Lapu-Lapu of Pilipinas,
XMattingly of Rochelle, Jubel of Uruz, Durin of Belegost, Geiserich of
XPthor, and Antryg Windrose of Nimiria were all dominating forces.
XWhat a glorious world it was........
X
XBut meanwhile, back in reality, Mark and Keith, now joined by a host
Xof other awesome dudes, were getting really fed up with the crippling
Xnature of all the bugs in Conquer.
X
X- There was Alan and Mike that had a "groo" and a "brok" for no apparent
X  reason.
X- There was Mark and Jon that lost 200000 talons for breaking treaties
X  that the computer forced them to break.
X- There was the turn that the trade board exploded and everyone
X  got everybody elses commodities....
X- Oh, and don't forget the NOMADS that appeared in Tim's nation out
X  of  nowhere...
X- Not to mention that the conquer world was flat and was a quadragon.
X- Selling sectors, and getting all the people on them even of a different
X  race.
X- Jungles, next to deserts, next to tundra.
X- Some nations had many leaders born, some had none.
X- Relocating people that don't exist.
X- And what did terror, popularity, and poverty really do?
X- Who would want to spend hundreds of thousands of jewels just to
X  suddenly be able to draft Cavalry from your population?
X- Who wanted Mercs that always ran away?
X
XAnd hundreds of other inconsistencies, annoyances and flat out BUGS,
Xthat drove all who played crazy!
X
XMark was most fed up of all!  He knew that we could do something about
Xthis.  He knew that we did not have to stand by and watch as poor
Xinnocent hackers and gamers got ulcers as they had to deal with someone's
X"first C program!"
X
XIt was Mark who inspired us, united us under a common goal:
XHow can we rewrite Conquer?
X
XSBW WAS BORN!
X
END_OF_FILE
if test 5116 -ne `wc -c <'THE_STORY'`; then
    echo shar: \"'THE_STORY'\" unpacked with wrong size!
fi
# end of 'THE_STORY'
fi
if test -f 'budget.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'budget.c'\"
else
echo shar: Extracting \"'budget.c'\" \(16603 characters\)
sed "s/^X//" >'budget.c' <<'END_OF_FILE'
X/* budget.c -- modify budget, etc. */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include <stdio.h>
X#include <ctype.h>
X
Xextern Sworld world;
Xextern Suser user;
Xextern WINDOW *sectw;
Xextern char *libdir;
Xextern char help_tag[];
X#ifdef BSD
X extern char current_dir[];
X#else /* BSD */
X extern char *current_dir;
X#endif
X
X#define ALL_CUR_PER (np->cur_tech_r_d + np->cur_mag_r_d + np->cur_spy_r_d)
X#define ALL_NEXT_PER (np->mag_r_d + np->spy_r_d + np->charity + np->tech_r_d)
X
X/* char budget_report (Snation *); */
X
X/* Internal functions, should NOT be called outside of this file */
X
X/* do_tech_budget (WINDOW *, Snation *); */
X/* do_magic_budget (WINDOW *, Snation *); */
X/* void storage_budget (Snation *); */
X
X/* a nation's budget report */
X
Xchar budget_report(np)
X     Snation *np;
X{
X  WINDOW *w;
X  char s[EXECLEN];
X  char c, spych;
X  int new_value, done = 0, percent_expend, ret, got=0, bad_number;
X  int semidone = 0, tmp;
X  FILE *diplock;
X
X  strcpy(help_tag, "Budget Report");
X  strcpy(s, "");
X
X  w = newwin(LINES-2, COLS, 0, 0); /* full screen */
X
X  touchwin(w);
X  while (!done) {
X    semidone = 0;
X    bad_number = 0;
X    statline("type space when done, or F to dump to a file", "budget_report");
X    statline2("","");
X
X    draw_budget_screen (w, np);
X
X    got = 0;
X    do {
X      c = getch();
X    } while (strchr(" stTMSFipndL?", c) == NULL && c != CTL('L'));
X    switch (c) {
X    case ' ':
X    case 'i':
X    case 'p':
X    case 'n':
X    case 'd':
X      done = 1;
X      break;
X    case 's':
X      storage_budget (np);
X      draw_budget_screen (w, np);
X      semidone = 1;
X      break;
X    case 'T':
X      do_tech_budget (w, np);
X      draw_budget_screen (w, np);
X      semidone = 1;
X      break;
X    case 'M':
X      do_magic_budget (w, np);
X      draw_budget_screen (w, np);
X      semidone = 1;
X      break;
X    case CTL('L'):
X      wclear (w);
X      draw_budget_screen (w, np);
X      semidone = 1;
X      break;
X    case 'F':
X      /* should also give thon in default file name */
X      dump_current_screen(w, "budget_report");
X      break;
X    case '?':
X      online_info();
X      break;
X    default:
X      break;
X    }
X    
X    if (!done && !semidone) {
X      /* here prepare for getting the new value */
X      wmove(w, LINES-3, 0);
X      wclrtoeol(w);
X      mvwprintw(w, LINES-3, 0, "      give new value: ");
X
X      ret = wget_number(w, &new_value);
X      if (ret > 0) {	/* only do this if the user actually gave a number */
X	if (new_value < 0 || new_value > 100) {
X	  statline2_err ("Bad value for a percentage (hit space)", "");
X	} else {
X	  strcpy(s, "");
X
X	  switch (c) {
X	  case 't':
X	    np->taxes = new_value;
X	    sprintf(s, "TAXRATE:%d\n", np->taxes);
X	    break;
X/* Charity doesn't work right now... */
X/*	  case 'c':
X	    np->charity = n;
X	    sprintf(s, "CHARITY:%d\n", n);
X	    break;
X*/
X	  case 'S':
X	    if (next_thon_money (np) >= 0) {
X	      np->spy_r_d = new_value;
X	      sprintf (s, "SPYR&Dmoney:%d\n", new_value);
X	    }
X	    else bad_number = 1;
X	    break;
X	  default:
X	    bad_number = 1;
X	    break;
X	  }
X	  if (bad_number) {
X	    statline2_err ("hit space", "bad number");
X	  }	    
X	  else gen_exec(s);
X	}
X      }
X    }
X  }
X  delwin(w);
X
X  return c;
X}
X
X/* Does the sub-budget for magic */
X
Xdo_magic_budget (w, np)
X
XWINDOW * w;
XSnation * np;
X{
X  char ch;
X  int new_value;
X  char exec [EXECLEN];
X  int bad_number = 0;
X  int old_value_tmp;
X
X  wmove (w, LINES-3, 0);
X  wclrtoeol (w);
X  mvwprintw (w, LINES-3, 0, "Change %% of [M]oney or [j]ewels invested?");
X  wrefresh (w);
X  ch = getch ();
X
X  if (strchr ("Mj", ch) == NULL) { ; }
X  else {
X    mvwprintw (w, LINES-3, 0, " enter new value (as %%): ");
X    wclrtoeol (w);
X    wrefresh (w);
X    
X    if (wget_number (w, &new_value) <= 0) {
X      bad_number = 1;
X    }
X     
X    if (new_value > 100 || new_value < 0) {
X      bad_number = 1;
X    }
X
X    /* What I do next is simple - calc_expend uses np->mag_r_d(_jewels)
X       to calculate jewels, so I save the old value of np->mag_r_d
X       and then copy the new value in, and if the new value is too
X       large, then copy the old value back in. This way, you can change
X       calc_expend however you want to, and it will work */    
X
X    switch (ch) {
X    case 'j':
X      old_value_tmp = np->mag_r_d_jewels; /* Do the old swaperoo */
X      np->mag_r_d_jewels = new_value;
X
X      if (next_thon_jewels(np) >= 0 && !bad_number) {
X	sprintf (exec, "MAGR&Djewels:%d\n", np->mag_r_d_jewels);
X	gen_exec (exec);
X      }
X      else { bad_number = 1; np->mag_r_d_jewels = old_value_tmp; }
X      break;
X    case 'M':
X      old_value_tmp = np->mag_r_d; /* Do the old swaperoo! */
X      np->mag_r_d = new_value;
X
X      if (next_thon_money(np) >= 0 && !bad_number &&
X	  ALL_NEXT_PER <= 100) {	  
X	sprintf (exec, "MAGR&Dmoney:%d\n", np->mag_r_d);
X	gen_exec (exec);
X	break;
X      }
X      else { bad_number = 1; np->mag_r_d = old_value_tmp; }
X      break;
X    default:
X      break;
X    }
X    if (bad_number) {  /* Print an error message if it was a bad number */
X      statline2_err ("hit space", "bad number");
X    }
X  }
X}
X
Xdo_tech_budget (w, np)
X
XWINDOW * w;
XSnation * np;
X{
X  char ch;
X  int new_value;
X  char exec [EXECLEN];
X  int bad_number = 0;
X  int old_value_tmp;
X
X  wmove (w, LINES-3, 0);
X  wclrtoeol (w);
X  mvwprintw (w, LINES-3, 0, "Change %% of [M]oney or [m]etal invested?");
X  wrefresh (w);
X  ch = getch ();
X
X  if (strchr ("Mm", ch) == NULL) { ; }
X  else {
X    mvwprintw (w, LINES-3, 0, " enter new value (as %%): ");
X    wclrtoeol (w);
X    wrefresh (w);
X
X    if (wget_number (w, &new_value) <= 0) {
X      bad_number = 1;
X    }
X    
X    if (new_value > 100 || new_value < 0) {
X      bad_number = 1;
X    }
X
X    /* What I do next is simple - calc_expend uses np->mag_r_d(_jewels)
X       to calculate jewels, so I save the old value of np->mag_r_d
X       and then copy the new value in, and if the new value is too
X       large, then copy the old value back in. This way, you can change
X       calc_expend however you want to, and it will work */    
X
X    switch (ch) {
X    case 'm':
X      old_value_tmp = np->tech_r_d_metal; /* Do the old swaperoo */
X      np->tech_r_d_metal = new_value;
X
X      if (next_thon_metal(np) >= 0 && !bad_number) {
X	sprintf (exec, "TECHR&Dmetal:%d\n", np->tech_r_d_metal);
X	gen_exec (exec);
X      }
X      else { bad_number = 1; np->tech_r_d_metal = old_value_tmp; }
X      break;
X    case 'M':
X      old_value_tmp = np->tech_r_d; /* Do the old swaperoo! */
X      np->tech_r_d = new_value;
X
X      if (next_thon_money(np) >= 0 && !bad_number &&
X	  ALL_NEXT_PER <= 100) {
X	sprintf (exec, "TECHR&Dmoney:%d\n", np->tech_r_d);
X	gen_exec (exec);
X	break;
X      }
X      else { bad_number = 1; np->tech_r_d = old_value_tmp; }
X      break;
X    default:
X      break;
X    }
X    if (bad_number) {  /* Print an error message if it was a bad number */
X      statline2_err ("hit space", "bad number");
X    }
X  }
X}
X
X/* */
X
Xdraw_budget_screen (w, np)
X
XWINDOW * w;
XSnation * np;
X{
X  char s [EXECLEN];
X
X  sprintf(s, "Budget Report for Nation %s", np->name);
X
X  wmove(w, 0, (COLS-strlen(s))/2); /* make the string centered */
X  wstandout(w);
X  waddstr (w, s);
X  wclrtoeol(w);
X  wstandend(w);
X
X      /* now a tedious list of stuff */
X  wclrtobot(w);
X  mvwprintw(w, 2, 0, "  Item");
X  mvwprintw(w, 3, 0, "--------");
X  mvwprintw(w, 2, COLS/5-2, "This Thon (%d)", world.turn);
X  mvwprintw(w, 3, COLS/5-2, "---------", world.turn);
X  mvwprintw(w, 2, (2*COLS)/5-3, "Revenue");
X  mvwprintw(w, 3, (2*COLS)/5-3, "-------");
X  mvwprintw(w, 2, (3*COLS)/5, "Expenditure");
X  mvwprintw(w, 3, (3*COLS)/5, "-----------");
X  mvwprintw(w, 2, (4*COLS)/5, "Next Thon (%d)", world.turn + 1);
X  mvwprintw(w, 3, (4*COLS)/5, "---------", world.turn + 1);
X  mvwprintw(w, 4, 0, "Treasury");
X  mvwprintw(w, 5, 0, "Metal");
X  mvwprintw(w, 6, 0, "Jewels");
X  mvwprintw(w, 7, 0, "Food");
X  /* this turn */
X  mvwprintw(w, 4, COLS/5-2, "%d", user.init_money);
X  mvwprintw(w, 5, COLS/5-2, "%d", user.init_metal);
X  mvwprintw(w, 6, COLS/5-2, "%d", user.init_jewels);
X  mvwprintw(w, 7, COLS/5-2, "%d", user.init_food);
X
X  /* revenue */
X  mvwprintw(w, 4, (2*COLS)/5-3, "%d (%d%% tax)        ",
X	    calc_revenue(np), np->taxes);
X  mvwprintw(w, 5, (2*COLS)/5-3, "%d   ", calc_metal(np));
X  mvwprintw(w, 6, (2*COLS)/5-3, "%d   ", calc_jewels(np));
X  mvwprintw(w, 7, (2*COLS)/5-3, "%d   ", calc_food(np));
X
X  /* expenses */
X  mvwprintw(w, 4, (3*COLS)/5, "%d    ",
X	    calc_expend(np) + user.init_money - np->money +
X	    (cur_expend(np)));
X  mvwprintw(w, 5, (3*COLS)/5, "%d    ",
X	    calc_expend_metal(np) + user.init_metal - np->metal
X	    + cur_expend_metal(np));
X  mvwprintw(w, 6, (3*COLS)/5, "%d    ",
X	    calc_expend_jewels(np) + user.init_jewels - np->jewels
X	    + cur_expend_jewels(np));
X  mvwprintw(w, 7, (3*COLS)/5, "%d    ",
X	    calc_expend_food(np) + user.init_food - np->food);
X
X  /* next turn */
X  mvwprintw(w, 4, (4*COLS)/5, "%d    ",
X	    next_thon_money(np));
X  mvwprintw(w, 5, (4*COLS)/5, "%d    ",
X	    next_thon_metal(np));
X  mvwprintw(w, 6, (4*COLS)/5, "%d    ",
X	    next_thon_jewels(np));
X  mvwprintw(w, 7, (4*COLS)/5, "%d    ",
X	    np->food + calc_food(np) - calc_expend_food(np));
X
X
X  /* now for the modifiable stuff */
X  strcpy(s, "**Breakdown of Expenditures**");
X  mvwaddstr(w, 9, (COLS-strlen(s))/2, s);
X  
X  mvwprintw(w, 11, 0, "MONEY:");
X  mvwprintw(w, 11, 8, "Charity:     %3d%% -> %d      ",
X	    np->charity, (np->charity*calc_revenue(np))/100);
X  mvwprintw(w, 12, 8, "Tech R&D:    %3d%% -> %d      ",
X	    np->tech_r_d, ((np->tech_r_d*calc_revenue(np)) / 100));
X  mvwprintw(w, 13, 8, "Magic R&D:   %3d%% -> %d      ",
X	    np->mag_r_d, np->mag_r_d*calc_revenue(np)/100);
X  mvwprintw(w, 14, 8, "Spy R&D:     %3d%% -> %d      ",
X	    np->spy_r_d, (np->spy_r_d * calc_revenue (np)) / 100);
X  mvwprintw(w, 15, 8, "Storage use: %3d%% -> %d",
X	    (np->cur_tech_r_d + np->cur_mag_r_d + np->cur_spy_r_d),
X	    (np->cur_tech_r_d + np->cur_mag_r_d + np->cur_spy_r_d) *
X	    np->money / 100);
X  mvwprintw(w, 16, 8, "Military maint.:     %d      ", military_maint(np));
X  mvwprintw(w, 17, 8, "Other:               %d      ",
X	    user.init_money + non_profit_maint(np) - np->money);
X
X  mvwprintw(w, 11, COLS/2, "METAL:");
X  mvwprintw(w, 11, COLS/2+8, "Tech R&D:    %3d%% -> %d    ",
X	    np->tech_r_d_metal, ((np->tech_r_d_metal*calc_metal(np))/100));
X  mvwprintw(w, 12, COLS/2+8, "Storage use: %3d%% -> %d",
X	    np->cur_tech_r_d_metal,
X	    (np->cur_tech_r_d_metal * np->metal) / 100);	    
X  mvwprintw(w, 13, COLS/2+8, "Other:               %d    ",
X	    user.init_metal - np->metal + military_maint_metal(np));
X  
X  mvwprintw(w, 15, COLS/2, "JEWELS:");
X  mvwprintw(w, 15, COLS/2+8, "Magic R&D:   %3d%% -> %d    ",
X	    np->mag_r_d_jewels, ((np->mag_r_d_jewels*calc_jewels(np))/100));
X  mvwprintw(w, 16, COLS/2+8, "Storage use: %3d%% -> %d",
X	    np->cur_mag_r_d_jewels,
X	    (np->cur_mag_r_d_jewels * np->jewels) / 100);
X  mvwprintw(w, 17, COLS/2+8, "Other:               %d    ",
X	    user.init_jewels - np->jewels + military_maint_jewels(np));
X  
X  /* now the part where the user gets to decide HOW TO SPEND the money! */
X  mvwaddstr(w, LINES-5, 0, "Choose which parameter to modify:");
X  mvwaddstr(w, LINES-4, 8,
X	    "[t]ax rate, [T]ech R&D, [M]agic R&D, [S]py R&D, [s]torage");
X  mvwaddstr(w, LINES-3, 0,
X	    "See report: [i]nfo, [p]roduction, [n]ations, [d]iplomacy");
X  wclrtobot(w);
X  wrefresh(w);
X
X}
X
X/* Storage report, budget */
X
Xstorage_budget (np)
X
XSnation * np;
X{
X  WINDOW * w;
X  char s [EXECLEN];
X  char ch;
X  int bad_number, new_value;
X
X  w = newwin (11, 70, 8, 5);
X
X  while (1) {
X    bad_number = 0;
X    draw_storage_budget (w, np);
X
X    do { ch = getch (); } while (strchr (" TMS", ch) == NULL);
X
X    if (ch == ' ') return;
X
X    switch (ch) {
X    case 'S':
X      wmove (w, 9, 1);
X      wclrtoeol (w);
X      box (w, '|', '-');
X      mvwprintw (w, 9, 2, "enter new value (percent): ");
X      wrefresh (w);
X      if (wget_number (w, &new_value) <= 0) {
X	bad_number = 1;
X      }
X
X      if (new_value < 0 || new_value > 100) bad_number = 1;
X
X      if (!bad_number && next_thon_money(np) >= 0 &&
X       ((np->cur_tech_r_d + np->cur_mag_r_d + new_value) <= 100)) {
X         
X	sprintf (s, "CUR_SPYR&Dmoney:%d\n", new_value);
X	np->cur_spy_r_d = new_value;
X	gen_exec (s);
X      }
X      else bad_number = 1;
X      break;
X    case 'T':
X      wmove (w, 9, 1);
X      wclrtoeol (w);
X      box (w, '|', '-');
X      mvwprintw (w, 9, 3, "Change [M]oney or [m]etal? ");
X      wrefresh (w);
X
X      do { ch = getch (); } while (strchr (" Mm", ch) == NULL);
X
X      if (ch != 'M' && ch != 'm') { break; }
X      wmove (w, 9, 1);
X      wclrtoeol (w);
X      box (w, '|', '-');
X      mvwprintw (w, 9, 3, "enter new value (percentage): ");
X      wrefresh (w);
X      if (wget_number (w, &new_value) <= 0) {
X	bad_number = 1;
X      }
X      wmove (w);
X      wclrtoeol (w);
X      box (w, '|', '-');
X
X      if (new_value < 0 || new_value > 100) bad_number = 1;
X
X      switch (ch) {
X      case 'M':
X	if (next_thon_money(np) >= 0 && !bad_number &&
X          ((new_value + np->cur_mag_r_d + np->cur_spy_r_d) <= 100)) {
X
X	  np->cur_tech_r_d = new_value;
X	  sprintf (s, "CUR_TECHR&Dmoney:%d\n", new_value);
X	  gen_exec (s);
X	}
X	else bad_number = 1;
X	break;
X      case 'm':
X	if (!bad_number && next_thon_metal(np) >= 0) {
X	  np->cur_tech_r_d_metal = new_value;
X	  sprintf (s, "CUR_TECHR&Dmetal:%d\n", new_value);
X	  gen_exec (s);
X	  break;
X	}
X	else bad_number = 1;
X	break;
X      default:
X	break;
X      }
X      break;
X    case 'M':
X      wmove (w, 9, 1);
X      wclrtoeol (w);
X      box (w, '|', '-');
X      mvwprintw (w, 9, 3, "Change [M]oney or [j]ewels? ");
X      wrefresh (w);
X
X      do { ch = getch (); } while (strchr (" Mj", ch) == NULL);
X
X      if (ch != 'M' && ch != 'j') { break; }
X      wmove (w, 9, 1);
X      wclrtoeol (w);
X      box (w, '|', '-');
X      mvwprintw (w, 9, 3, "enter new value (percentage): ");
X      wrefresh (w);
X      if (wget_number (w, &new_value) <= 0) {
X	bad_number = 1;
X      }
X      wmove (w);
X      wclrtoeol (w);
X      box (w, '|', '-');
X
X      if (new_value < 0 || new_value > 100) bad_number = 1;
X
X      switch (ch) {
X      case 'M':
X	if (next_thon_money(np) && !bad_number &&
X    ((np->cur_tech_r_d + new_value + np->cur_spy_r_d) <= 100)) { 
X
X	  np->cur_mag_r_d = new_value;
X	  sprintf (s, "CUR_MAGR&Dmoney:%d\n", new_value);
X	  gen_exec (s);
X	}
X	else bad_number = 1;
X	break;
X      case 'j':
X	if (!bad_number && next_thon_jewels(np) >= 0) {
X	  np->cur_mag_r_d_jewels = new_value;
X	  sprintf (s, "CUR_MAGR&Djewels:%d\n", new_value);
X	  gen_exec (s);
X	  break;
X	}
X	else bad_number = 1;
X	break;
X      default:
X	break;
X      }
X      break;
X    default:
X      break;
X    }
X    if (bad_number) {
X      statline2_err ("hit space", "bad number");
X    }
X    werase (w);
X  }
X}
X
Xdraw_storage_budget (w, np)
X
XWINDOW * w;
XSnation * np;
X{
X  char s [EXECLEN];
X
X  box (w, '|', '-');
X
X  sprintf (s, "Storage Usage Report");
X  mvwprintw (w, 1, 35 - (strlen (s)) / 2, "%s", s);
X  mvwprintw (w, 2, 35 - (strlen (s)) / 2, "--------------------");
X
X  mvwprintw (w, 4, 2, "MONEY:");
X  mvwprintw (w, 5, 7, "Tech R&D:   %3d%% -> %d",
X	     np->cur_tech_r_d, (np->cur_tech_r_d * np->money / 100));
X  mvwprintw (w, 6, 7, "Magic R&D:  %3d%% -> %d",
X	     np->cur_mag_r_d, (np->cur_mag_r_d * np->money / 100));
X  mvwprintw (w, 7, 7, "Spy R&D:    %3d%% -> %d",
X	     np->cur_spy_r_d, (np->cur_spy_r_d * np->money / 100));
X
X  mvwprintw (w, 4, 36, "METAL:");
X  mvwprintw (w, 5, 41, "Tech R&D:   %3d%% -> %d",
X	     np->cur_tech_r_d_metal, (np->cur_tech_r_d_metal * np->metal
X				       / 100));
X  mvwprintw (w, 6, 36, "JEWELS:");
X  mvwprintw (w, 7, 41, "Magic R&D:  %3d%% -> %d",
X	     np->cur_mag_r_d_jewels, (np->cur_mag_r_d_jewels * np->jewels
X				       / 100));
X
X  mvwprintw (w, 9, 12, "Modify: [M]agic R&D, [T]ech R&D, [S]py R&D");
X
X  wrefresh (w);
X}
END_OF_FILE
if test 16603 -ne `wc -c <'budget.c'`; then
    echo shar: \"'budget.c'\" unpacked with wrong size!
fi
# end of 'budget.c'
fi
if test -f 'commands.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'commands.c'\"
else
echo shar: Extracting \"'commands.c'\" \(17606 characters\)
sed "s/^X//" >'commands.c' <<'END_OF_FILE'
X  /* commands.c -- various commands in dominion */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X#include <stdio.h>
X	/* many commands are kept in this file, except for those
X	   that depend on the graphics being used.
X	 */
X
Xextern Suser user;
Xextern Sworld world;
Xextern struct s_desig_map desig_map[];
Xextern struct s_altitude_map altitude_map[];
Xextern struct item_map climates[];
Xextern struct item_map terrains[];
Xextern WINDOW *sectw;
Xextern char help_tag[];
Xextern int (*wrapx)(), (*wrapy)();
Xextern char *getenv();
Xextern char libdir[], *current_dir;
X
Xquit()				/* cleanup and quit */
X{
X  clear();
X  cleanup();
X  clean_exit();
X  exit(0);
X}
X
Xhelp()
X{
X  start_help_win();
X  show_help();
X  end_help_win();
X}
X
X  /* this routine sets certain parameters that must be
X     set when the cursor has been moved
X   */
Xjust_moved()
X{
X  user.just_moved = 1;
X}
X
Xup()				/* move the cursor; should look at topology */
X{
X  --user.cursor.y;
X  just_moved();
X}
Xjup()
X{
X  user.cursor.y -= 8;
X  just_moved();
X}
Xdown()
X{
X  ++user.cursor.y;
X  just_moved();
X}
Xjdown()
X{
X  user.cursor.y += 8;
X  just_moved();
X}
Xright()
X{
X  ++user.cursor.x;
X  just_moved();
X}
Xjright()
X{
X  user.cursor.x += 8;
X  just_moved();
X}
Xleft()
X{
X  --user.cursor.x;
X  just_moved();
X}
Xjleft()
X{
X  user.cursor.x -= 8;
X  just_moved();
X}
Xupright()
X{
X  up(); right();
X  just_moved();
X}
Xupleft()
X{
X  up(); left();
X  just_moved();
X}
Xdownright()
X{
X  down(); right();
X  just_moved();
X}
Xdownleft()
X{
X  down(); left();
X  just_moved();
X}
Xjhome()
X{
X  user.cursor.x = user.np->capital.x;
X  user.cursor.y = user.np->capital.y;
X  user.center = user.cursor;
X  just_moved();
X}
X
Xjpos()
X{
X  char s[100];
X  int x,y;
X
X  statline2("  x postion to jump to ? : " , "position");
X  move (LINES-2, strlen("  x position to jump to ? : "));
X  if ( wget_number(stdscr, &x) < 1) {
X    statline2("", "");
X    return;
X  }
X  statline2("  y postion to jump to ? : " , "position");
X  move (LINES-2, strlen("  y position to jump to ? : "));
X  if ( wget_number(stdscr, &y) < 1) {
X    statline2("", "");
X    return;
X  }
X  user.cursor.x = (*wrapx)(user.np->capital.x + x,user.np->capital.y + y);
X  user.cursor.y = (*wrapy)(user.np->capital.x + x,user.np->capital.y + y);
X  user.center = user.cursor;
X  just_moved();
X  statline2("", "");
X}
X
X#define ZX 70
X#define ZY 18
X
X  /* zoom-in on a sector */
Xzoom_sector()
X{
X  WINDOW *zoomw = NULL;
X  char s[EXECLEN];
X  char c;
X  int x = user.cursor.x, y = user.cursor.y;
X  Ssector *sp = &world.map[x][y];
X  Snation *np;
X  int done = 0, old_desig = sp->designation;
X  int new_desig = sp->designation, quantity, fraction, total;
X  int visibility = user.visible_sectors[x][y];
X
X  strcpy(help_tag, "Designations");
X  if (user.id != 0) {
X    np = user.np;
X  } else {
X    np = &world.nations[sp->owner]; /* for super user */
X  }
X  if (!user.xmode) {
X    zoomw = newwin(ZY, ZX, 4, 5);
X  }
X  while (!done) {
X    if (zoomw) {
X      statline("type space when done", "zoom_sector");
X
X      if (strlen(sp->name) > 0 && (visibility & SEE_POPULATION)) {
X	sprintf(s, "Detailed Evaluation of %s", sp->name);
X      } else {
X	sprintf(s, "Detailed Evaluation of Sector (%d,%d)",
X		xrel(x, y, np->capital), yrel(x, y, np->capital));
X      }
X      wmove(zoomw, 1, 1);
X      wclrtoeol(zoomw);
X      wmove(zoomw, 1, (70-strlen(s))/2); /* make the string centered */
X      wstandout(zoomw);
X      waddstr(zoomw, s);
X      wclrtoeol(zoomw);
X      wstandend(zoomw);
X
X      if (sp->owner != 0 && (visibility & SEE_OWNER)) {
X	mvwprintw(zoomw, 2, 2, "     Owner: %s",world.nations[sp->owner].name);
X      } else {
X	mvwprintw(zoomw, 2, 2, "     Owner: None");
X      }
X      if (strlen(sp->name) > 0 || !(visibility & SEE_POPULATION)) {
X	mvwprintw(zoomw, 2, 1+ZX/2, "Location: (%d,%d)",xrel(x,y,np->capital),
X		  yrel(x,y,np->capital));
X      }
X      wclrtoeol(zoomw);
X
X      mvwprintw(zoomw, 3, 2, " Geography: ");
X      if (visibility & SEE_LAND_WATER) {
X	wprintw(zoomw, "%s ", terrains[sp->terrain - MIN_TERRAIN].name);
X	if (sp->altitude > SEA_LEVEL) {
X	  wprintw(zoomw, "%s", altitude_map[map_alt(sp->altitude)].name);
X	}
X      } else {
X	wprintw(zoomw, "Unknown");
X      }
X      wclrtoeol(zoomw);
X
X      mvwprintw(zoomw, 4, 2, "   Climate: ");
X      if (visibility & SEE_LAND_WATER) {
X	wprintw(zoomw, "%s", climates[sp->climate].name);
X      } else {
X	wprintw(zoomw, "Unknown");
X      }
X      wclrtoeol(zoomw);
X
X      mvwprintw(zoomw, 5, 2, " Resources: ");
X      if (visibility & SEE_RESOURCES) {
X	wprintw(zoomw, "soil %d, metal %d, jewels %d", sp->soil, sp->metal,
X		sp->jewels);
X      } else {
X	wprintw(zoomw, "Unknown");
X      }
X      wclrtoeol(zoomw);
X
X      mvwprintw(zoomw, 6, 2, "Population: ");
X      if (sp->owner != 0) {
X	if (visibility & SEE_POPULATION) {
X	  wprintw(zoomw, "%d people (%c); %d employed; %d%% unemp.",
X		  sp->n_people, world.nations[sp->owner].race.mark,
X		  n_workers(sp), sp->n_people ?
X		  (100*(sp->n_people - n_workers(sp)))/sp->n_people : 0);
X	} else {
X	  wprintw(zoomw, "Unknown people");
X	}
X	if ((visibility & SEE_ARMIES) && sp->alist != NULL) {
X	  wprintw(zoomw, "; %d armies", sect_n_armies(sp));
X	}
X      } else {
X	wprintw(zoomw, "None");
X      }
X      wclrtoeol(zoomw);
X
X      mvwprintw(zoomw, 7, 2, "  Movecost: ");
X      if (visibility & SEE_LAND_WATER) {
X	wprintw(zoomw, "%d", get_generic_move_cost(np,sp));
X/*	wprintw(zoomw, "%d", get_move_cost(np,sp)); */
X      } else {
X	wprintw(zoomw, "Unknown");
X      }
X      wclrtoeol(zoomw);
X      mvwprintw(zoomw, 7, 1+ZX/4, "Roads: %d", sp->roads);
X      mvwprintw(zoomw, 7, 1+2*ZX/4, "Defense: %d", sp->defense);
X      mvwprintw(zoomw, 7, 1+3*ZX/4, " %s", has_bubble(sp) ? "Bubble" : "");
X
X      if (sp->owner == np->id || user.id == 0) {
X	mvwprintw(zoomw, 9, 2, "Sector Economy:");
X	wclrtoeol(zoomw);
X
X	mvwprintw(zoomw, 10, 2, "       Designation: %s (%c)",
X		  desig_map[old_desig].name,
X		  desig_map[old_desig].mark);
X	wclrtoeol(zoomw);
X
X	mvwprintw(zoomw, 11, 2, " Trial Designation: %s (%c)",
X		  desig_map[new_desig].name,
X		  desig_map[new_desig].mark);
X	wclrtoeol(zoomw);
X
X	  /* now tell the user how much revenue this sector generates */
X	quantity=(desig_map[new_desig].revenue*np->taxes*n_workers(sp))/100;
X	if (calc_revenue(np) > 0) {
X	  fraction = (100*quantity)/calc_revenue(np);
X	} else {
X	  fraction = 100;
X	}
X
X	mvwprintw(zoomw, 12, 2, "Per capita revenue: %d    ",
X		  desig_map[new_desig].revenue);
X	mvwprintw(zoomw, 13, 2,
X		  "   Taxes collected: %d, %d%% of total income (%d)    ",
X		  quantity, fraction, calc_revenue(np));
X	wclrtoeol(zoomw);
X
X	switch (desig_map[new_desig].mark) {
X	case 'm':
X	  strcpy(s, "metal");
X	  total = calc_metal(np);
X	  quantity = sector_metal(sp);
X	  break;
X	case 'j':
X	  strcpy(s, "jewels");
X	  total = calc_jewels(np);
X	  quantity = sector_jewels(sp);
X	  break;
X	case 'f':
X	  strcpy(s, "food");
X	  total = calc_food(np);
X	  quantity = sector_food(sp);
X	  break;
X	default:
X	  strcpy(s, "");
X	  quantity = -1;
X	  fraction = 0;
X	  break;
X	}
X	fraction = (total == 0) ? 100 : ((quantity * 100) / total);
X
X	wmove(zoomw, 14, 2);
X	if (quantity != -1) {
X	  /* watch out for division by zero if there are zero workers */
X	  wprintw(zoomw,
X               "Production of %s: %d; %d%% of total (%d); %5.2f per capita   ",
X	  s, quantity, fraction, total,
X	  ((double) quantity)/((double) (n_workers(sp) ? n_workers(sp) : 1)));
X	}
X	wclrtoeol(zoomw);
X      }
X
X      mvwaddstr(zoomw, 16, 1,
X		"Options: [N]ame sector, [t]rial redesignate, [r]edesignate");
X      box(zoomw, '|', '-');
X      wrefresh(zoomw);
X    } else {			/* else we must be in e[x]pert mode */
X      if (visibility & SEE_POPULATION) {
X	sprintf(s, "[N],[r],pop=%d,emp=%d,roads=%d,defense=%d", sp->n_people,
X		n_workers(sp), sp->roads, sp->defense);
X      } else {
X	sprintf(s, "[N],[r],pop=?,emp=?,roads%d,defense%d",
X		sp->roads, sp->defense);
X      }
X      statline_prompt(s, "sector zoom");
X    }
X    switch(c = mygetch()) {
X    case ' ':
X      done = 1;
X      break;
X    case 'N':
X      name_sector(zoomw);
X      break;
X    case 't':			/* redesignate without paying and saving */
X      if (zoomw) {			/* not in expert mode */
X	new_desig = redesignate(np, zoomw, 0);
X	sp->designation = new_desig;
X      }
X      break;
X    case 'r':			/* make a redesignation for sure, and pay */
X      new_desig = redesignate(np, zoomw, 2);
X      old_desig = new_desig;	/* permanent change!! */
X      sp->designation = new_desig;
X      break;
X    default:
X      break;
X    }
X  }
X  if (zoomw) {
X    delwin(zoomw);
X    touch_all_wins();
X    refresh();
X  }
X  sp->designation = old_desig;	/* make sure "trial" changes are temporary */
X}
X
X  /* change the name of a sector */
Xname_sector(w)
X     WINDOW *w;
X{
X  char name[NAMELEN];
X  int x = user.cursor.x, y = user.cursor.y;
X  Ssector *sp = &world.map[x][y];
X  char s[EXECLEN];
X  int ret;			/* for return values */
X
X  if (w) {
X    statline("name this sector", "name_sector");
X  }
X  if (sp->owner != user.id && user.id != 0) {
X    statline2_err("hit space", "sector not yours");
X  } else {
X    if (w) {
X      mvwaddstr(w, ZY-3, 2, "Enter name for the sector: ");
X      wclrtoeol(w);
X      wrefresh(w);
X    } else {
X      statline_prompt("Name this sector: ", "");
X    }
X    ret = wget_name(w, name);
X    if (ret > 0) {
X      strcpy(sp->name, name);
X        /* now generate the exec instruction */
X      sprintf(s, "SNAME:%d:%d:%s\n", x, y, name);
X      gen_exec(s);
X    }
X  }
X  if (w) {
X    wmove(w, ZY-3, 2);
X    wclrtoeol(w);
X  }
X  user.just_moved = 1;
X}
X
X  /* menu that allows you to redesignate a sector */
Xredesignate(np, w, confirm)
X     Snation * np;
X     WINDOW *w;
X     int confirm;
X{
X  char name[NAMELEN];
X  int x = user.cursor.x, y = user.cursor.y;
X  Ssector *sp = &world.map[x][y];
X  char s[EXECLEN];
X  char c;
X  int i, new_desig = sp->designation;
X
X  if (w) {
X    statline("choose a designation", "redesignate");
X  }
X  if (sp->owner != user.id && user.id != 0) {
X    statline2_err("type space to continue", "sector not yours");
X      /* a user cannot remove their capital, but Gamemaster can */
X  } else if (user.id != 0 && sp->designation == D_CAPITAL) {
X    statline2_err("type space to continue", "you cannot be without a capital");
X  } else {
X    if (w) {
X      wmove(w, ZY-5, 1);
X      wclrtoeol(w);
X      wmove(w, ZY-5, 1);
X      for (i = 0; i < D_MAX_DESIG; ++i) {
X	if (i % 4 == 0) {
X	  wmove(w, ZY-5 + i/4, 1);
X	  wclrtoeol(w);
X	  wmove(w, ZY-5 + i/4, 1);
X	}
X	wprintw(w, "[%c]-%s  ", desig_map[i].mark, desig_map[i].name);
X      }
X      box(w,'|','-');
X      wrefresh(w);
X    } else {			/* expert mode */
X      statline_prompt("Give new designation: ", "");
X    }
X    c = getch();		/* get the new designation */
X
X    for (i = 0; i < D_MAX_DESIG; ++i) {
X      if (desig_map[i].mark == c) {
X	new_desig = i;
X	break;
X      }
X    }
X    /* make sure that user's capital is moved (if it is confirmed) */
X    if ((new_desig == D_CAPITAL) && confirm) {
X      move_capital(&world.nations[sp->owner], sp);
X    }
X  }
X  if (w) {
X    wmove(w, ZY-5, 0);
X    wclrtobot(w);
X    statline2("", "");
X  }
X  if (new_desig==D_CITY && sp->n_people < desig_map[new_desig].min_employed) {
X    sprintf(s, "need %d people for a city", desig_map[new_desig].min_employed);
X    statline2_err("type space to continue", s);
X    new_desig = sp->designation;
X    confirm = 0;
X  }
X
X  if (np->money < desig_map [new_desig].price && confirm && !(user.id == 0)) {
X    confirm = 0;
X    new_desig = sp->designation;
X    statline2_err ("space to continue", "not enough money");
X  }
X
X  /* only make the actual change if the confirm flag is set */
X  if ((new_desig != sp->designation) && confirm) {
X    sp->designation = new_desig;
X      /* now generate the exec instructions */
X    sprintf(s, "DESIG_SECTOR:%d:%d:%d\n", x, y, new_desig);
X    gen_exec(s);
X    user.np->money -= desig_map[i].price;
X    cmoney(user.np, -desig_map[new_desig].price);
X  }
X  user.just_moved = 1;
X  return new_desig;
X}
X
X  /* a couple of little routines that generate simple
X     exec lines, and are used all the time
X   */
Xcpeople_sector(sp, p)
X     Ssector *sp;
X     int p;
X{
X  char s[EXECLEN];
X
X  sprintf(s, "CPEOPLE_SECTOR:%d:%d:%d\n", sp->loc.x, sp->loc.y, p);
X  gen_exec(s);
X}
X
Xcmoney(np, m)
X     Snation *np;
X     int m;
X{
X  char s[EXECLEN];
X  sprintf(s, "CMONEY:%d:%d\n", np->id, m);
X  gen_exec(s);
X}
X
Xcmetal(np, m)
X     Snation *np;
X     int m;
X{
X  char s[EXECLEN];
X  sprintf(s, "CMETAL:%d:%d\n", np->id, m);
X  gen_exec(s);
X}
X
Xcjewels(np, j)
X     Snation *np;
X     int j;
X{
X  char s[EXECLEN];
X  sprintf(s, "CJEWELS:%d:%d\n", np->id, j);
X  gen_exec(s);
X}
X
Xcspell_pts(np, pts)
X     Snation *np;
X     int pts;
X{
X  char s[EXECLEN];
X
X  sprintf(s, "CSPELL_PTS:%d:%d\n", np->id, pts);
X  gen_exec(s);
X}
X
Xcfood(np, f)
X     Snation *np;
X     int f;
X{
X  char s[EXECLEN];
X  sprintf(s, "CFOOD:%d:%d\n", np->id, f);
X  gen_exec(s);
X}
X
Xctech_skill(np, change)
X     Snation *np;
X     int change;
X{
X  char s[EXECLEN];
X  sprintf(s, "CTECH_SKILL:%d:%d\n", np->id, change);
X  gen_exec(s);
X}
X
Xcmag_skill(np, change)
X     Snation *np;
X     int change;
X{
X  char s[EXECLEN];
X  sprintf(s, "CMAG_SKILL:%d:%d\n", np->id, change);
X  gen_exec(s);
X}
X
X  /* this ensures that the user has only one capital,
X     when he moves his over.
X   */
Xmove_capital(np, sp)
X     Snation *np;
X     Ssector *sp;
X{
X  char s[EXECLEN];
X    /* first make the old capital be a simple city */
X  if (user.id != 0) {
X    world.map[np->capital.x][np->capital.y].designation = D_CITY;
X    sprintf(s,"DESIG_SECTOR:%d:%d:%d\n", np->capital.x, np->capital.y, D_CITY);
X    gen_exec(s);
X      /* now make this sector be the new capital */
X  }
X  np->capital = sp->loc;
X}
X
X  /* dumps the map visible on the screen to a file */
Xdump_map()
X{
X  char s[80], filename[NAMELEN];
X  sprintf(s, "give a file name (default = \"%s\")", "map");
X  statline(s, "dump_map");
X  move(LINES-2, COLS/3);
X  addstr("> ");
X  echo();
X  if (wget_string(NULL,filename,18) <= 0) {
X    strcpy(filename, "map");
X  }
X  noecho();
X  move(LINES-2, COLS/3);
X  clrtoeol();
X  my_scr_dump(stdscr, filename);
X}
X
X  /* mail menu */
Xmail()
X{
X  char *mail_prog;
X
X  statline("do you want to (r)ead mail or (w)rite mail", "mail");
X  switch (getch()) {
X  case 'r':
X    refresh();
X    mail_read(user.id);
X    clear(); refresh();
X    user.just_moved = 1;
X    break;
X  case 'w':
X    mail_write();
X    user.just_moved = 1;
X    break;
X  default:
X    break;
X  }
X}
X
X/* This function takes care of players' sending mail to other nations.
X It does all the curses printing and scaning here (That's why it's a bit
X messy) and calls functions from mail for editing and sending and lock foo. */
X
Xmail_write()
X{
X  char s[EXECLEN];
X  int ret, id, done = 0;
X  char r_name[NAMELEN];
X  int c;
X  char tmp_fname[PATHLEN];
X  char subject[100];
X  char sender[NAMELEN*2+4],receiver[NAMELEN*2+4];
X  
X  clear();
X  statline("Sending mail","mail_write");
X  mvaddstr(1,0,"Enter name of recipient (Nation name) ");
X  ret = wget_name(stdscr,r_name);
X  if (ret > 0) {
X    id=get_nation_id(r_name);
X    if (id>=0) {
X      if (has_mail_lock(id)) {
X	mvaddstr(4,0,"The recipient's mailbox is active right now.");
X	mvaddstr(5,0,"Try sending you mail in a moment.");
X	refresh();
X	statline2_err("Press space to return","write_mail");
X	clear();
X      } else {
X	strcpy(tmp_fname, "/usr/tmp/domedXXXXXX");
X	if (mktemp(tmp_fname) == NULL) {
X	  fprintf(stderr,"Error getting temp file name\n");
X	  fflush(stderr);
X	  return;
X	}
X	mvaddstr(4,0,"Subject: ");
X	refresh();
X	wget_name(stdscr, subject);
X	cleanup();
X	chdir("/usr/tmp");
X	edit(tmp_fname);
X	chdir(current_dir);
X	chdir(libdir);
X	{
X	  initscr();
X	  savetty();
X	  nonl();
X	  cbreak();
X	  noecho();
X	  clear();
X	}
X	mvaddstr(2, 0, "Choices: S)end mail or A)bort sending ");
X	refresh();
X	done = 0;
X	while(!done) {
X	  switch(getch()){
X	  case 'S':
X	  case 's':
X/*	    lock_mail(id); */
X	    mvaddstr(3, 9, "Sending Mail...");
X	      /* Check if mail is being used by/for this user right now */
X	    if (has_mail_lock(id)) {
X	      printf("Found a lock file for receiver %d\n", id);
X	      fflush(stdout);
X	      refresh();
X	      sleep(2);
X	      if(has_mail_lock(id)) {
X		printf("Found a lock file for receiver %d\n", id);
X		fflush(stdout);
X		refresh();
X		return(1);
X	      }
X	    }
X	    lock_mail(id);
X	    refresh();
X	    mail_send(tmp_fname, user.id, id, subject);
X	    unlock_mail(id);
X	    mvaddstr(3, LINES, "done.");
X	    refresh();
X	    done = 1;
X	    break;
X	  case 'A':
X	    mvaddstr(3, LINES-1, "OK. Aborting...");
X	    refresh();
X	    done = 1;
X	    unlock_mail(id);
X	    break;
X	  }
X	  unlink(tmp_fname);
X	}
X	cleanup();
X	init_screen();
X      } /* else */
X    } /* id >= 0 */
X    else {			/* else we got a bad nation name */
X      mvaddstr(7,0,"Invalid Nation Name");
X      statline2_err("Press <SPACE> to return", "Bad Nation Name");
X      clear();
X      refresh();
X    } /* else */
X  } /* ret > 0 */
X  clear(); refresh();
X} /* mail_write */
END_OF_FILE
if test 17606 -ne `wc -c <'commands.c'`; then
    echo shar: \"'commands.c'\" unpacked with wrong size!
fi
# end of 'commands.c'
fi
if test -f 'reports.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'reports.c'\"
else
echo shar: Extracting \"'reports.c'\" \(17594 characters\)
sed "s/^X//" >'reports.c' <<'END_OF_FILE'
X /* reports.c -- all things from the 'r' menu */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include <stdio.h>
X#include <ctype.h>
X
Xextern Sworld world;
Xextern Suser user;
Xextern WINDOW *sectw;
Xextern char *libdir;
Xextern char help_tag[];
X#ifdef BSD
X extern char current_dir[];
X#else /* BSD */
X extern char *current_dir;
X#endif
Xextern int ruid, euid;
X
X  /* each report returns a char */
Xchar info_report(), production_report(), nations_report();
X
X
Xextern char diplo_report (), budget_report ();
X
Xreport_menu()		/* this gives a menu of possible report forms */
X{
X  WINDOW *repw;
X  char c, exit_c = ' ';
X  FILE *fp, *fopen(), *diplock;
X  int done = 0;
X  char filename[80];
X
X  strcpy(help_tag, "Reports");
X
X  if (user.xmode) {
X    repw = NULL;
X  } else {
X    repw = newwin(5, 60, LINES-7, 10);
X  }
X  while (!done) {
X    if (exit_c == ' ') {
X      touch_all_wins();
X
X      if (user.xmode) {
X	statline_prompt("Report: (i,b,p,n,d,v)", "report_menu");
X      } else {
X	statline("choose the form you want (space to exit)", "report_menu");
X	wmove(repw, 1, 1);
X	waddstr(repw, "your nation:       [i]nfo [b]udget [p]roduction");
X	wmove(repw, 2, 1);
X	waddstr(repw, "the whole world:   ");
X	waddstr(repw, "[n]ations [d]iplomacy");
X	wmove(repw, 3, 1);
X	waddstr(repw,
X		"  or type [v] to view a report that was saved to a file");
X	wclrtobot(repw);
X	box(repw, '|', '-');
X	wrefresh(repw);
X      }
X 
X    }
X
X    if (exit_c != ' ') 
X      c = exit_c;
X    else
X      do { c = getch (); } while (strchr (" ibpndv", c) == NULL);
X
X    switch (c) {
X    case ' ':
X      done = 1;
X      break;
X    case 'v':
X#ifdef NO_FILE_ACCESS
X      statline2_err("Hit space", "File access is disabled");
X#else
X      if (user.xmode) {
X	statline_prompt("file you want to view: ", "reports_menu");
X      } else {
X	wmove (repw, 3, 4);
X	wclrtoeol (repw);
X	mvwaddstr(repw, 3, 4, "give file name you want to view: ");
X	box (repw, '|', '-');
X	wrefresh(repw);
X      }
X      if (wget_name(repw, filename) > 0) {
X	/*   erase();	  /* now erase the screen so we can view the report */
X	werase(sectw);
X	if (!user.xmode) {
X	  werase(repw);
X	}
X	/*      wrefresh(repw); */
X	/*      scr_restore(filename); */
X
X	if (my_scr_restore(filename) != -1) {
X	/*      doupdate(); */
X	}
X	if (!user.xmode) {
X	  wclrtobot(repw);
X	}
X      }
X#endif NO_FILE_ACCESS
X      break;
X    case 'i':
X      exit_c = info_report(user.np);
X      break;
X    case 'b':
X      exit_c = budget_report(user.np);
X      break;
X    case 'p':
X      exit_c = production_report(user.np);
X      break;
X    case 'n':
X      exit_c = nations_report();
X      break;
X    case 'd':
X      exit_c = diplo_report(user.np);
X      break;
X    case '?':
X      online_info();
X      break;
X    }
X    if (!user.xmode) {
X      statline("choose the form you want (space to exit)", "report_menu");
X      touchwin(repw);
X    }
X  }
X  if (!user.xmode) {
X    delwin(repw);
X  }
X  touchwin(stdscr);
X  user.just_moved = 1;
X}
X
X  /* info about a specific nation */
Xchar info_report(np)
X     Snation *np;
X{
X  WINDOW *w;
X  FILE *diplock;
X  char s[80];
X  char c;
X  int done = 0;
X
X  strcpy(help_tag, "Information Report");
X  w = newwin(LINES-2, COLS, 0, 0); /* full screen */
X
X  touchwin(w);
X    /* now a tedious list of stuff */
X  while (!done) {
X    draw_info_screen(w, np);
X
X    statline("type space when done, or F to dump to a file", "info_report");
X
X    switch (c = getch()) {
X    case CTL('L'):
X      wclear (w);
X      draw_info_screen (w, np);
X      break;
X    case 'P':
X      change_passwd(np, w);
X      break;
X    case 'l':
X      change_leader(np, w);
X      break;
X    case 't':			/* rotate values for the npc flag */
X      np->npc_flag = (np->npc_flag + 1) % 3;
X      if (np->npc_flag) {
X	sprintf(s, "SET_NPC:%d\n", np->id);
X      } else {
X	sprintf(s, "CLEAR_NPC:%d\n", np->id);
X      }
X      gen_exec(s);
X      break;
X    case 'a':			/* set the aggressiveness paramter */
X      if (np->npc_flag) {
X	set_aggressiveness(np, w);
X      }
X      break;
X    case 'F':
X      dump_current_screen(w, "info_report");
X      break;
X    case ' ':
X    case 'b':			/* go to other reports */
X    case 'p':
X    case 'n':
X    case 'd':
X      done = 1;
X      break;
X    case '?':
X      online_info();
X      break;
X    default:
X      break;
X    }
X    wrefresh(w);
X    statline2("", "");
X  }
X  delwin(w);
X/*  touch_all_wins(); */
X/*  refresh(); */
X  return c;
X}
X
X/* */
Xdraw_info_screen (w, np)
X
XWINDOW * w;
XSnation * np;
X{
X  char s [EXECLEN];
X
X  sprintf(s, "Info Report for Nation %s", np->name);
X  wmove(w, 0, (COLS-strlen(s))/2 - 4); /* make the string centered */
X  wstandout(w);
X  waddstr(w, s);
X  wstandend(w);
X  mvwprintw(w, 1, COLS/3+7, "Thon %d", world.turn);
X  mvwprintw(w, 3, 0, "Nation:  %s", np->name);
X  switch(np->npc_flag) {
X  case NPC_NOMAIL:
X    mvwaddstr(w, 2, 8, " [npc]     ");
X    break;
X  case NPC_MAIL:
X    mvwaddstr(w, 2, 8, " [npc+mail]");
X    break;
X  case NOT_NPC:
X  default:
X    mvwaddstr(w, 2, 8, "           ");
X    break;
X  }
X/*
X  if (!np->npc_flag) {
X    waddstr(w, "           ");
X  } else if (np->npc_flag == 1) {
X/*    waddstr(w, " [npc: aggress. %d]", np->npc_agg); */
X/*    waddstr(w, " [npc]");
X  } else {			/* for npc_flag == 2 */
X/*    waddstr(w, " [npc+mail]");
X  }
X*/
X  mvwprintw(w, 4, 0, "Id:      %d", np->id);
X  mvwprintw(w, 5, 0, "Leader:  %s    ", np->leader);
X  mvwprintw(w, 6, 0, "Capital: (%d,%d)",
X	    xrel(np->capital.x,np->capital.y,user.np->capital),
X	    yrel(np->capital.x,np->capital.y,user.np->capital));
X  mvwprintw(w, 7, 0, "Race:    %s", np->race.name);
X  mvwprintw(w, 8, 0, "Mark:    %c", np->mark);
X  mvwprintw(w, 3, COLS/3, "Sectors:  %d", np->n_sects);
X  mvwprintw(w, 4, COLS/3, "Treasury: %d", np->money);
X  mvwprintw(w, 5, COLS/3, "Jewels:   %d", np->jewels);
X  mvwprintw(w, 6, COLS/3, "Metal:    %d", np->metal);
X  mvwprintw(w, 7, COLS/3, "Food:     %d", np->food);
X  mvwprintw(w,  3, (2*COLS)/3, "Birth rate:  %d%%", np->race.repro);
X  mvwprintw(w,  4, (2*COLS)/3, "Mortality:   %d%%", np->race.mortality);
X  mvwprintw(w,  5, (2*COLS)/3, "Strength:    %d", np->race.strength);
X  mvwprintw(w,  6, (2*COLS)/3, "Intel: %d + %d = %d", np->race.intel,
X	    univ_intel(np), np->race.intel + univ_intel(np));
X  mvwprintw(w,  7, (2*COLS)/3, "Magic Apt: %d + %d = %d", np->race.mag_apt,
X	    priestliness(np), np->race.mag_apt + priestliness(np));
X  mvwprintw(w,  8, (2*COLS)/3, "Speed:       %d", np->race.speed);
X  mvwprintw(w,  9, (2*COLS)/3, "Stealth:     %d", np->race.stealth);
X
X  mvwprintw(w, 11, (2*COLS)/3, "Civilians:     %d", get_n_civil(np));
X  mvwprintw(w, 12, (2*COLS)/3, "Soldiers:      %d", get_n_soldiers(np));
X  mvwprintw(w, 13, (2*COLS)/3, "Armies:        %d", np->n_armies);
X  mvwprintw(w, 14, (2*COLS)/3, "Attack bonus:  %d%%", np->attack);
X  mvwprintw(w, 15, (2*COLS)/3, "Defense bonus: %d%%", np->defense);
X  mvwprintw(w, 16, (2*COLS)/3, "Move points:   %d", basic_move_rate(np));
X
X  mvwprintw(w, 10, 0, "Initiated to the magical order %s", np->mag_order);
X  mvwprintw(w, 11, 0, "Magic skill:       %d", np->mag_skill);
X  mvwprintw(w, 12, 0, "Spell points:      %d (%d in maint)", np->spell_pts,
X	    military_maint_spell_pts(np));
X  mvwprintw(w, 13, 0, "Technology skill:  %d", np->tech_skill);
X  mvwprintw(w, 14, 0, "Farming skill:     %d", np->farm_skill);
X  mvwprintw(w, 15, 0, "Mining skill:      %d", np->mine_skill);
X  mvwprintw(w, 16, 0, "Spy skill:         %d", np->spy);
X  mvwprintw(w, 17, 0, "Secrecy:           %d", np->secrecy);
X
X  mvwprintw(w, LINES-5, 4,
X	    "Options: [P]assd change, [l]eader change, [t]oggle npc");
X  if (np->npc_flag) {
X    waddstr(w, ", [a]ggr.");
X  } else {
X    wclrtoeol(w);
X  }
X  mvwprintw(w, LINES-4, 4,
X	    "Reports: [b]udget, [p]roduction, [n]ations, [d]iplomacy");
X  wclrtobot(w);
X  wrefresh(w);
X}
X
X  /* a nation's production report:  this gives detail on where
X     all the income comes from (mines, cities...) and so on
X   */
Xchar production_report(np)
X     Snation *np;
X{
X  WINDOW *w;
X  FILE *diplock;
X  char s[EXECLEN];
X  char c;
X  int n, done = 0, percent_expend, ret;
X
X  strcpy(help_tag, "Production Report");
X
X  w = newwin(LINES-2, COLS, 0, 0); /* full screen */
X  statline2 ("", "");
X  touchwin(w);
X
X  while (!done) {
X    draw_production_screen (w, np);
X
X    statline("type space when done, or F to dump to a file",
X	     "production_report");
X
X    switch (c = getch()) {
X    case CTL('L'):
X      wclear (w);
X      draw_production_screen (w, np);
X      break;
X    case ' ':
X      done = 1;
X      break;
X    case 'F':
X      dump_current_screen(w, "production_report");
X      break;
X    case 'b':
X    case 'i':
X    case 'n':
X    case 'd':
X      done = 1;
X      break;
X    case '?':
X      online_info();
X      break;
X    default:
X      break;
X    }
X  }
X
X  delwin(w);
X/*  touch_all_wins(); */
X/*  refresh(); */
X  return c;
X}
X
Xdraw_production_screen (w, np)
X
XWINDOW * w;
XSnation * np;
X{
X  char s [EXECLEN];
X
X  int emp, emp_met, emp_jwl, emp_farm, emp_serv, n_civil;
X
X  emp = get_employed(np);
X  emp_met = get_emp_met(np);
X  emp_jwl = get_emp_jwl(np);
X  emp_farm = get_emp_farm(np);
X  emp_serv = get_emp_serv(np);
X  n_civil = get_n_civil(np);
X  
X  sprintf(s, "Production Report for Nation %s", np->name);
X  wmove(w, 0, (COLS-strlen(s))/2 - 4); /* make the string centered */
X  wstandout(w);
X  waddstr(w, s);
X  wstandend(w);
X  wclrtoeol(w);
X  /* now a tedious list of stuff */
X  mvwprintw(w, 2, 0, "  Job");
X  mvwprintw(w, 3, 0, "--------");
X  mvwprintw(w, 2, COLS/4-5, "# employed (unemp.)");
X  mvwprintw(w, 3, COLS/4-5, "-------------------", world.turn);
X  mvwprintw(w, 2, (2*COLS)/4-3, "Revenue");
X  mvwprintw(w, 3, (2*COLS)/4-3, "-------");
X  mvwprintw(w, 2, (3*COLS)/4-5, "prod/person");
X  mvwprintw(w, 3, (3*COLS)/4-5, "-----------");
X  mvwprintw(w, 4, 0, "General");
X  mvwprintw(w, 5, 0, "Metal miners");
X  mvwprintw(w, 6, 0, "Jewel miners");
X  mvwprintw(w, 7, 0, "Farmers");
X  mvwprintw(w, 8, 0, "Services");
X  /* number of people */
X  mvwprintw(w, 4, COLS/4-2, "%6d (%d)", emp, get_unemployed(np));
X  mvwprintw(w, 5, COLS/4-2, "%6d (%d)", emp_met, get_unemp_met(np));
X  mvwprintw(w, 6, COLS/4-2, "%6d (%d)", emp_jwl, get_unemp_jwl(np));
X  mvwprintw(w, 7, COLS/4-2, "%6d (%d)", emp_farm, get_unemp_farm(np));
X  mvwprintw(w, 8, COLS/4-2, "%6d (%d)", emp_serv, get_unemp_serv(np));
X  
X  /* revenue */
X  mvwprintw(w, 4, (2*COLS)/4-3, "%7d (%d%% tax)        ",
X	    calc_revenue(np), np->taxes);
X  mvwprintw(w, 5, (2*COLS)/4-3, "%7d   ", calc_metal(np));
X  mvwprintw(w, 6, (2*COLS)/4-3, "%7d   ", calc_jewels(np));
X  mvwprintw(w, 7, (2*COLS)/4-3, "%7d   ", calc_food(np));
X  mvwprintw(w, 8, (2*COLS)/4-3, "%7d   ", calc_serv_revenue(np));
X  
X  /* revenue/person */
X  mvwprintw(w, 4, (3*COLS)/4-3, "%5.2f   sk.",
X	    emp ? calc_revenue(np)/(1.0*emp) : 0, np->taxes);
X  mvwprintw(w, 5, (3*COLS)/4-3,"%5.2f   met.",
X	    emp_met ? calc_metal(np)/(1.0*emp_met) : 0.0);
X  mvwprintw(w, 6, (3*COLS)/4-3,"%5.2f   jwl.",
X	    emp_jwl ? calc_jewels(np)/(1.0*emp_jwl) : 0.0);
X  mvwprintw(w, 7, (3*COLS)/4-3,"%5.2f   food",
X	    emp_farm ? calc_food(np)/(1.0*emp_farm) : 0.0);
X  mvwprintw(w, 8, (3*COLS)/4-3,"%5.2f   sk.",
X	    emp_serv ? calc_serv_revenue(np)/(1.0*emp_serv) : 0.0);
X  
X  /* other statistics */
X  mvwprintw(w, 10, COLS/5, "Total people: %d  ",
X	      n_civil + get_n_soldiers(np));
X    mvwprintw(w, 11, COLS/5, "Civilians:    %d  ", n_civil);
X    mvwprintw(w, 12, COLS/5, "Employed:     %d  ", get_employed(np));
X    mvwprintw(w, 13, COLS/5, "Unemployed:   %d  ", get_unemployed(np));
X    mvwprintw(w, 14, COLS/5, "Soldiers:     %d  ", get_n_soldiers(np));
X    mvwprintw(w, 15, COLS/5, "Unemp. rate:  %d%%  ", n_civil == 0 ? 0 :
X	      (100*get_unemployed(np))/n_civil);
X
X    mvwprintw(w, 20, 4, "Reports: [b]udget, [i]info, [n]ations, [d]iplomacy");
X    wclrtobot(w);
X    wrefresh(w);
X}
X
X
X  /* this prompts for a file name and then dumps
X     the current screen to that file
X   */
Xdump_current_screen(w, def_filename)
X     WINDOW *w;
X     char def_filename[];
X{
X  char filename[80], s[80];
X
X#ifdef NO_FILE_ACCESS
X  statline2_err("Hit space", "File access disabled");
X#else  
X  sprintf(s, "give file name (default = \"%s%d\")", def_filename, world.turn);
X  statline2(s, "dump_current_screen");
X  move(LINES-3, 0);
X  clrtoeol();
X  move(LINES-3, COLS/3);
X  addstr("> ");
X  echo();
X  if (scanw("%18s", filename) < 1) {
X    strcpy(filename, def_filename);
X    sprintf(filename, "%s%d",  def_filename, world.turn);
X  }
X  noecho();
X  move(LINES-3, COLS/3);
X  clrtoeol();
X  statline2("", "");
X  my_scr_dump(w, filename);
X/*  scr_dump(filename); /* the curses scr_dump() isn't good enough */
X#endif
X}
X
X  /* the curses routine is not very nice, since it
X     can only be read-in by curses.  hence this.
X   */
Xmy_scr_dump(w, fname)
X     WINDOW *w;
X     char fname[];
X{
X  int x, y;
X  char c;
X  FILE *fp, *fopen();
X
X#ifdef UID_SECURITY
X  if (fork() == 0) {		/* child has fork() == 0 */
X      /* first change back to the user's current directory */
X    setuid(ruid);
X    chdir(current_dir);
X/*    printf("\r\nnow I am %d, changed to %s\n\r", ruid, current_dir); */
X      /* dilemma:  should we overwrite or append? */
X    if ((fp = fopen(fname, "w")) == NULL) {
X      exit(1);
X    }
X/*    printf("\r\n writing out the file %s in %s\n\r", fname, current_dir); */
X    for (y = 0; y < LINES; ++y) {
X      for (x = 0; x < COLS; ++x) {
X	wmove(w, y, x);
X	c=winch(w);
X	fputc(c, fp);
X      }
X      fputc('\n', fp);
X    }
X    fclose(fp);
X    exit(0);
X  }
X  wait(0);
X#else /* UID_SECURITY */
X    /* dilemma:  should we overwrite or append? */
X  if ((fp = fopen(fname, "w")) == NULL) {
X    return -1;
X  }
X  for (y = 0; y < LINES; ++y) {
X    for (x = 0; x < COLS; ++x) {
X      wmove(w, y, x);
X      c=winch(w);
X      fputc(c, fp);
X    }
X    fputc('\n', fp);
X  }
X  fclose(fp);
X#endif /* UID_SECURITY */
X  return 1;
X}
X
X  /* this restores a dump made with our custom screen dump routine */
Xmy_scr_restore(fname)
X     char fname[];
X{
X  int x, y;
X  char c;
X  FILE *fp, *fopen();
X  WINDOW *restw;
X
X
X#ifdef UID_SECURITY
X  if (fork() == 0) {
X    setuid(ruid);
X    chdir(current_dir);
X    if ((fp = fopen(fname, "r")) == NULL) {
X      exit(1);
X    }
X    restw = newwin(LINES, COLS, 0, 0);
X    werase(restw);
X    touchwin(restw);
X    for (y = 0; y < LINES; ++y) {
X      for (x = 0; x < COLS; ++x) {
X	c = fgetc(fp);
X	if ((c == '\n') || (c == '\r')) {
X	  --x;
X	  continue;		/* wow!!! a use for continue!!! */
X	}
X	mvwaddch(restw, y, x, c);
X      }
X      wclrtoeol(restw);
X    }
X    wclrtobot(restw);
X    wrefresh(restw);
X    fclose(fp);
X    statline2_err("type space to go on", "view_saved_report");
X    delwin(restw);
X    exit(0);
X  }				/* we close the "if (fork() == 0) {" */
X  wait(0);
X#else /* UID_SECURITY */
X  if ((fp = fopen(fname, "r")) == NULL) {
X    return -1;
X  }
X  restw = newwin(COLS, LINES, 0, 0);
X
X  for (y = 0; y < LINES; ++y) {
X    for (x = 0; x < COLS; ++x) {
X      c = fgetc(fp);
X      if ((c == '\n') || (c == '\r')) {
X	--x;
X	continue;		/* wow!!! a use for continue!!! */
X      }
X      mvwaddch(restw, y, x, c);
X    }
X    wclrtoeol(restw);
X  }
X  wclrtobot(restw);
X  fclose(fp);
X  delwin(restw);
X  statline2_err("type space to go on", "view_saved_report");
X#endif /* UID_SECURITY */
X  touch_all_wins();
X  refresh();
X  user.just_moved = 1;
X  return 1;
X}
X
X  /* let a nation change its password */
Xchange_passwd(np, w)
X     Snation *np;
X     WINDOW *w;
X{
X  char old_p[NAMELEN], try1[NAMELEN], try2[NAMELEN];
X
X  wmove(w, w->_maxy-3, 0);
X  wclrtobot(w);
X  wmove(w, w->_maxy-3, 6);
X  wrefresh(w);
X  /* if it is NOT the Gamemaster, then we have to make sure
X     this user knows the old password.  Gamemaster, instead,
X     can change passwds without knowing the old ones.
X   */
X  if (user.id != 0) {
X    get_crypt_pass("Old password: ", old_p, w, NULL);
X    wmove(w, w->_maxy-3, 6);
X    wrefresh(w);
X    if (strcmp(old_p, np->passwd) != 0) {
X      statline2_err("Hit space", "sorry");
X      wmove(w, w->_maxy-4, 0);
X      wclrtobot(w);
X      wrefresh(w);
X      return -1;
X    }
X  }
X  get_crypt_pass("New password:  ", try1, w, NULL);
X  wmove(w, w->_maxy-3, 6);
X  wrefresh(w);
X  get_crypt_pass("Type it again: ", try2, w, NULL);
X  while (strcmp(try1, try2) != 0) {
X    mvwprintw(w, 20, 6, "They don't match, try again");
X    wmove(w, w->_maxy-3, 6);
X    wrefresh(w);
X    get_crypt_pass("New password:  ", try1, w, NULL);
X    wmove(w, w->_maxy-3, 6);
X    wrefresh(w);
X    get_crypt_pass("Type it again: ", try2, w, NULL);
X  }
X  strcpy(np->passwd, try1);
X  cpass(np, try1);		/* generate the exec line */
X  wmove(w, w->_maxy-4, 0);
X  wclrtobot(w);
X}
X
X  /* allow a user to change their leader */
Xchange_leader(np, w)
X     Snation *np;
X     WINDOW *w;
X{
X  char name[NAMELEN], s[EXECLEN];
X
X  mvwprintw(w, 21, 6, "What is the new name of your leader? ");
X  if (wget_name(w, name) > 0) {
X    strcpy(np->leader, name);
X    sprintf(s, "NATION_LEADER:%d:%s\n", np->id, name);
X    gen_exec(s);
X  }
X}
END_OF_FILE
if test 17594 -ne `wc -c <'reports.c'`; then
    echo shar: \"'reports.c'\" unpacked with wrong size!
fi
# end of 'reports.c'
fi
echo shar: End of archive 23 \(of 28\).
cp /dev/null ark23isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Now execute ./do_cat.sh to build doc files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
