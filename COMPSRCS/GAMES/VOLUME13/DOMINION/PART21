Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i057:  dominion - a multi-player world simulation game, Part21/28
Message-ID: <2460@masterCNA.TEK.COM>
Date: 11 Feb 92 18:26:57 GMT
Sender: news@masterCNA.TEK.COM
Lines: 2214
Approved: billr@saab.CNA.TEK.COM

Submitted-by: rosalia@dirac.physics.sunysb.edu (Mark Galassi)
Posting-number: Volume 13, Issue 57
Archive-name: dominion/Part21
Environment: Unix, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 21 (of 28)."
# Contents:  c_news.c economy.c npc.c
# Wrapped by billr@saab on Tue Feb 11 10:14:57 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'c_news.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'c_news.c'\"
else
echo shar: Extracting \"'c_news.c'\" \(19406 characters\)
sed "s/^X//" >'c_news.c' <<'END_OF_FILE'
X/* c_news.c : Curses routines for the news subsystem of Dominion */
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "news.h"
X#include <stdio.h>
X#ifdef SYSV
X#include <string.h>
X#else
X#include <strings.h>
X#endif
X#include <ctype.h>
X
Xextern Suser user;		/* The current user. Used for names. */
Xextern Sworld world;		/* The current world. Used for the thon. num.*/
X
Xextern s_group *group_find();	/* In news.c. Searches a database for a 
X				 specified group. */
X
Xint first_unread(art_arr,g_choice)
Xs_article **art_arr;
Xs_group *g_choice;
X{
X  int loop,ret;
X
X  ret=g_choice->last;
X  if (g_choice->first <= g_choice->last)
X    for(loop=g_choice->first;((loop<=g_choice->last)&&(ret==g_choice->last))
X	;loop++)
X      if (!(art_arr[loop-g_choice->first]->read))
X	ret=loop;
X  return(ret);
X} /* first_unread */
X
X
Xwrite_newsrc(art_arr, g_choice)
Xs_article **art_arr;
Xs_group *g_choice;
X{
X  FILE *nr_fp,*tmp_fp;
X  char nr_fn[100],tmp_fn[100];
X  char input[300],output[300],cmd[100],group_name[100];
X  int art_pnt;
X
X  if ((g_choice->first)>(g_choice->last))
X    return;
X  sprintf(nr_fn,"%s/.newsrc.%d",NEWS_DIR,user.id);
X  sprintf(tmp_fn,"%s/.tmprc.%d",NEWS_DIR,user.id);
X  nr_fp=fopen(nr_fn,"r");
X  tmp_fp=fopen(tmp_fn,"w");
X  if (tmp_fp==NULL)
X    {
X      fprintf(stderr,"Could not open temp. file to save read article list\n");
X      fflush(stderr);
X      fclose(nr_fp);
X      fclose(tmp_fp);
X    }
X  else
X    {
X      if (nr_fp!=NULL)
X/*	while((fscanf(nr_fp,"%[^\n]",input))!=EOF)*/
X	while ((fgets(input,300,nr_fp))!=NULL)
X	  {
X	    sscanf(input,"%s",group_name);
X	    if (strcmp(group_name,g_choice->name))
X	      fprintf(tmp_fp,"%s",input);
X	  }
X      fprintf(tmp_fp,"%s ",g_choice->name);
X      art_pnt=g_choice->first;
X      while(art_pnt<=g_choice->last)
X	{
X	  if (!(art_arr[art_pnt-g_choice->first]->read))
X	    art_pnt++;
X	  else
X	    if ((art_pnt<g_choice->last)&&
X		(art_arr[art_pnt+1-g_choice->first]->read))
X	      {
X		fprintf(tmp_fp,"%d-",art_pnt);
X		while((art_pnt<g_choice->last)&&
X		      (art_arr[art_pnt+1-g_choice->first]->read))
X		  art_pnt++;
X		fprintf(tmp_fp,"%d ",art_pnt);
X		art_pnt++;
X	      }
X	    else
X	      {
X		fprintf(tmp_fp,"%d ",art_pnt);
X		art_pnt++;
X	      }
X	} /* while art_pnt <= gchoice->last */
X      fprintf(tmp_fp,"\n");
X      fclose(tmp_fp);
X      fclose(nr_fp);
X      sprintf(cmd,"rm -f %s",nr_fn);
X      system(cmd);
X      sprintf(cmd,"cp %s %s",tmp_fn,nr_fn);
X      system(cmd);
X      sprintf(cmd,"rm -f %s",tmp_fn);
X      system(cmd);
X    } /* else */
X} /* write_newsrc */
X
Xread_newsrc(art_arr,g_choice)
Xs_article **art_arr;
Xs_group *g_choice;
X{
X  FILE *nr_fp;
X  char nr_fn[100],input[300],group_name[100],*in_ptr;
X  int art_num,art_pnt,first_art,last_art;
X
X  sprintf(nr_fn,"%s/.newsrc.%d",NEWS_DIR,user.id);
X  nr_fp=fopen(nr_fn,"r");
X  if (nr_fp!=NULL)
X    {
X      while ((fgets(input,300,nr_fp))!=NULL)
X	{
X	  sscanf(input,"%s",group_name);
X	  if (!strcmp(group_name,g_choice->name))
X	    {
X	      in_ptr=strchr(input,(int)' ');
X	      if (in_ptr!=NULL)
X		in_ptr++;
X	      while (*in_ptr!='\0')
X		{
X		  sscanf(in_ptr,"%d",&first_art);
X		  while (isdigit(*in_ptr))
X		    in_ptr++;
X		  if (*in_ptr=='-')
X		    {
X		      sscanf(in_ptr+1,"%d",&last_art);
X		      in_ptr=strchr(in_ptr,(int)(' '));
X		    }
X		  else
X		    {
X		      last_art=first_art;
X		      in_ptr++;
X		    }
X		  for (art_num=first_art;art_num<=last_art;art_num++)
X		    if ((art_num<=g_choice->last)&&(art_num>=g_choice->first))
X		      (art_arr[art_num-g_choice->first]->read)=1;
X		} /* while *in_ptr */
X	    } /* if !strcmp */
X	} /* while */
X    } /* if nr_fp */
X  fclose(nr_fp);
X} /* read_newsrc */
X
Xart_menu_bottom(menu_lines)
Xint menu_lines;
X{
X  mvaddstr(menu_lines+2,5,"Position arrow with [j]/[2] (down) and [k]/[8] (up)");
X  mvaddstr((menu_lines+3),5,"RETURN to Read, Q to Quit    (Use SHIFT to jump by page)");
X  mvaddstr(menu_lines+4,1,"(*'s indicate previously read - [r]/[u] to mark as read/unread)");
X}
X
X
X/* This function displays a portion (or the whole) of the menu of articles
X   that can be read. The menu is displayed according to where the cursor is
X   and where it's pointing to. (and of course the size of the screen) */
X
Xshow_art_menu(art_arr,menu_lines,cur_point,cur_pos,first_art,last_art)
X     s_article **art_arr;
X     /* This is an array of pointers to "article structures". See news.h */
X     int menu_lines,cur_point,cur_pos,first_art,last_art;
X     /* menu_lines: how many lines can be displayed on the screen
X	cur_point: which article the cursor is pointing to
X	cur_pos: where on the screen the cursor is
X	first_art: the first article of all the articles that can be read
X	last_art: the last article....
X	*/
X{
X  int line,art_no; /* line: what line on the display we're showing.
X		      art_no: What article this is we're showing. */
X  char fmt[50],out[200]; /* fmt: How to format the output strings (sprintf).
X			    out: The output string for the menu. */
X
X  sprintf(fmt,"%%4d> %%-9.9s  %%-%d.%ds %%-%d.%ds",NAMELEN,
X	  NAMELEN,(COLS-23-NAMELEN),(COLS-23-NAMELEN)); 
X  /* fmt is how the menu lines look. It's used to handle variable width screens
X     4 characters for the article number, a >, 16 characters for the thon,
X     NAMELEN characters for the sender, and the rest for the subject. */
X  for(line=1;line <= menu_lines;line++)
X    {
X      art_no=(cur_point-cur_pos)+line; /* Took a while to figure out. I 
X					think it's right though. */
X      if (art_no <= last_art)	/* Don't display articles past the end.  */
X	{
X	  sprintf(out,fmt,art_no,art_arr[art_no-first_art]->date,
X		  art_arr[art_no-first_art]->sender,
X		  art_arr[art_no-first_art]->subject); /* Print to the string*/
X	  mvaddstr(line,4,out);	/* Show the string. */
X	  if ((art_arr[art_no-first_art]->read)==1)
X	    mvaddstr(line,5,"*");
X	} /* if (art_no <= last_art */
X    } /* for line=1... */
X} /* show_art_menu */
X
X
X/* This function is used for reading news articles. The user has selected a
X   group to read (pointed to by g_choice). This displays a menu of the articles
X   and allows the user to display articles from the menu. */
X
Xnews_arts_menu(g_choice,turn)
Xs_group *g_choice;		/* This is the group to read from */
Xint turn;			/* What thon is this? For positioning the
X				 cursor. */
X{
X  char news_dir[100], g_dir[100], a_fn[100], cmd[100];
X    /* news_dir: the main news directory. g_dir: this group's directory.
X       a_fn: The file name of an article. cmd: the 'system' command
X       to view arts. */
X  char text[100],type[10];
X    /* , date, from: The header of the articles. 
X     type what type line of the header? */
X  char this_thon[20]; /* What thon it is in string format. */
X  FILE *a_fp; /* The file pointer to an article file. */
X  int loop;   /* To loop through the articles. */
X  char c;     /* The key the user presses. */
X  s_article **art_arr,*a_temp;	/* art_arr: An array of pointers to
X				            'article' structures.
X				   a_temp: A work pointer. */
X  int menu_lines,menu_center,cur_pos,cur_point,done;
X  int show_next = 0;	/* should we see the next article immediately? */
X    /* menu_lines: How many lines can be shown.
X       menu_center: What line is the center line.
X       cur_pos: Where on the screen is the cursor.
X       cur_point: What article is it pointing to.
X       done: Can we leave news? */
X  if((g_choice->first)<=(g_choice->last))
X    art_arr=(s_article **)malloc(sizeof(s_article *)*(g_choice->last-
X						      g_choice->first+1));
X       /* Allocate space for the array. */
X  else
X    art_arr=NULL;
X  sprintf(this_thon,"Thon %d",turn);  
X  sprintf(news_dir,"%s",NEWS_DIR);
X  sprintf(g_dir,"%s/%s",news_dir,g_choice->name);
X  clear();
X  for(loop=g_choice->first;loop<=g_choice->last;loop++)
X    {
X      a_temp=(s_article *)malloc(sizeof(s_article));
X      a_temp->read=0;
X      sprintf(a_fn,"%s/%d",g_dir,loop);
X      a_fp=fopen(a_fn,"r");
X      if (a_fp!=NULL)
X	{
X	  strcpy(a_temp->subject,"");
X	  while (!strcmp(a_temp->subject,""))
X	    {
X	      fscanf(a_fp,"%s",type);
X	      if (!strcmp(type,"Date:"))
X		{
X		  fscanf(a_fp,"%[^\n]",text);
X		  strcpy(a_temp->date,text);
X		}
X	      if (!strcmp(type,"From:"))
X		{
X		  fscanf(a_fp,"%[^\n]",text);
X		  strcpy(a_temp->sender,text);
X		}
X	      if (!strcmp(type,"Author:"))
X		{
X		  fscanf(a_fp,"%[^\n]",text);
X		}
X	      if (!strcmp(type,"Subj:"))
X		{
X		  fscanf(a_fp,"%[^\n]",text);
X		  strcpy(a_temp->subject,text);
X		}
X	    }
X	  a_temp->art_num=loop;
X	}
X      else
X	{
X	  sprintf(a_temp->date,"");
X	  sprintf(a_temp->sender,"  --Article Missing--");
X	  sprintf(a_temp->subject,"");
X	  a_temp->art_num=loop;
X	} /* else */
X      art_arr[loop-(g_choice->first)]=a_temp;
X      if (a_fp != NULL) { fclose(a_fp); } 
X    }
X
X  read_newsrc(art_arr,g_choice);
X  
X  menu_lines=(LINES-6);
X  menu_lines=(int)((menu_lines-1)/2);
X  menu_lines*=2;
X  menu_lines+=1;
X  menu_center=(int)((menu_lines+1)/2);
X  cur_point=first_unread(art_arr,g_choice);
X  cur_pos=cur_point-(g_choice->first-1);
X  while (cur_pos>menu_lines)
X    cur_pos-=(menu_center);
X    
X  
X  show_art_menu(art_arr,menu_lines,cur_point,cur_pos,g_choice->first,
X		g_choice->last);
X  art_menu_bottom(menu_lines);
X  mvaddstr(cur_pos,1,"===>");
X  refresh();
X  done=0;
X  while (!done)
X    {
X      switch(c=getch()) {
X      case 'k':
X      case '8':
X	if (cur_point > g_choice->first)
X	  {
X	    mvaddstr(cur_pos,1,"    ");
X	    cur_point--;
X	    if (cur_pos==1)
X	      {
X		cur_pos=menu_center;
X		clear();
X		show_art_menu(art_arr,menu_lines,cur_point,cur_pos,
X			      g_choice->first,g_choice->last);
X		art_menu_bottom(menu_lines);
X	      }
X	    else
X	      cur_pos--;
X	    mvaddstr(cur_pos,1,"===>");
X	    refresh();
X	  } /* if cur_point > ... */
X	break; 
X      case 'K':
X      case '*':
X	if (cur_point > g_choice->first)
X	  {
X	    mvaddstr(cur_pos,1,"    ");
X	    if (cur_pos > menu_center)
X	      {
X		cur_point-=(cur_pos-menu_center);
X		cur_pos=menu_center;
X	      }
X	    else
X	      {
X		cur_point-=cur_pos;
X		if (cur_point<g_choice->first)
X		  {
X		    cur_pos=1;
X		    cur_point=g_choice->first;
X		  }
X		else
X		  {
X		    cur_pos=menu_center;
X		    clear();
X		    show_art_menu(art_arr,menu_lines,cur_point,cur_pos,
X				  g_choice->first, g_choice->last);
X		    art_menu_bottom(menu_lines);
X		  } /* else */
X	      } /* else */
X	    mvaddstr(cur_pos,1,"===>");
X	    refresh();
X	  } /* if cur_point ... */
X	break;
X      case 'j':
X      case '2':
X      if (cur_point < g_choice->last)
X	{
X	  mvaddstr(cur_pos,1,"    ");
X	  cur_point++;
X	  if (cur_pos==menu_lines)
X	    {
X	      cur_pos=menu_center;
X	      clear();
X	      show_art_menu(art_arr,menu_lines,cur_point,cur_pos,
X			    g_choice->first, g_choice->last);
X	      art_menu_bottom(menu_lines);
X	    }
X	  else
X	    cur_pos++;
X	  mvaddstr(cur_pos,1,"===>");
X	  refresh();
X	} /*  if cur_point... */
X      break;
X      case 'J':
X      case '@':
X	if (cur_point < g_choice->last)
X	  {
X	    mvaddstr(cur_pos,1,"    ");
X	    if (cur_pos<menu_center)
X	      {
X		cur_point+=(menu_center-cur_pos);
X		cur_pos=menu_center;
X	      }
X	    else
X	      {
X		cur_point+=((menu_lines-cur_pos)+1);
X		if(cur_point>g_choice->last)
X		  {
X		    cur_point=g_choice->last;
X		    cur_pos=cur_point-(g_choice->first-1);
X		    while(cur_pos>menu_lines)
X		      cur_pos-=menu_center;
X		  }
X		else
X		  {
X		    cur_pos=menu_center;
X		    clear();
X		    show_art_menu(art_arr,menu_lines,cur_point,cur_pos,
X				  g_choice->first, g_choice->last);
X		    art_menu_bottom(menu_lines);
X		  } /* else*/
X	      } /* else */
X	    mvaddstr(cur_pos,1,"===>");
X	    refresh();
X	  } /* if cur_point... */
X	break;
X      case 'r':
X	if (art_arr!=NULL)
X	  {
X	    art_arr[cur_point-g_choice->first]->read=1;
X	    mvaddstr(cur_pos,5,"*");
X	    mvaddstr(cur_pos,5,"");
X	  }
X	break;
X      case 'u':
X	if (art_arr!=NULL)
X	  {
X	    art_arr[cur_point-g_choice->first]->read=0;
X	    mvaddstr(cur_pos,5," ");
X	    mvaddstr(cur_pos,5,"");
X	  }
X      	break;
X      case '\n':
X      case '\r':
X      case ' ':
X	show_next = 0;
X	start_help_win();
X	do {
X	    /* show the article with more */
X/*	  sprintf(cmd,"more %s/%d",g_dir,cur_point);
X	  sprintf(cmd,"%s/%d",g_dir,cur_point);
X*/
X	  sprintf(a_fn, "%s/%d", g_dir, cur_point);
X/*	  cleanup(); */
X/*	  system(cmd); */
X/*	  show_file(a_fn); */
X/*	  init_screen(); */
X/*	  printf("\nPress RETURN to continue or [n] for the next article\n");
X	  fflush(stdout);
X*/
X	    /* run the pager on the file.  pager() returns 'n'
X	       if the user types n at the end of an article
X	     */
X	  if ((c = pager(a_fn)) != 'n'){ /* run the pager on this file */
X	    statline("RETURN or [q] for article menu; [n] for next article"
X		     , "");
X	    c = getch();
X	  }
X
X	  if (art_arr!=NULL)
X	    art_arr[cur_point-g_choice->first]->read=1;
X
X	  if (c == 'n') {
X	    show_next = 1;
X	  } else {
X	    show_next = 0;
X	  }
X	  if(cur_point<g_choice->last) {
X	    cur_point++;
X	    cur_pos++;
X	    if (cur_pos>=menu_lines)
X 	      cur_pos-=menu_center;
X	  } /* if cur_point < */
X	} while (show_next);
X	end_help_win();
X	clear();
X	show_art_menu(art_arr,menu_lines,cur_point,cur_pos,
X		      g_choice->first,g_choice->last);
X	art_menu_bottom(menu_lines);
X	mvaddstr(cur_pos,1,"===>");
X	refresh();
X	break;
X      case 'Q':
X      case 'q':
X	done=1;
X	break;
X      } /* switch */
X    }   /* while */
X  /* Write out "newsrc" data for this group */
X  write_newsrc(art_arr,g_choice);
X  /* Clean up memory */
X  for (loop=g_choice->first;loop<=g_choice->last;loop++)
X    free(art_arr[loop-(g_choice->first)]);
X  free(art_arr);
X
X  clear();
X} /* news_arts_menu */
X
X
Xs_group *news_groups_menu(human,reading)
X     int human;			/* a flag to say if a human is posting. */
X     int reading;               /* a flag to say if we're only reading. */
X{
X  int ret;
X  char news_dir[100],g_fn[100],a_fn[100];
X  FILE *g_fp,*a_fp;
X  char g_name_in[100],post_in;
X  int first_in,last_in,g_index,total_groups,cur_pos,done,loop;
X  char s_in[100],c;
X  s_group *g_first,*g_temp,*g_ret;
X
X  g_first=NULL;
X  g_temp=NULL;
X  total_groups=0;
X
X  sprintf(news_dir,"%s",NEWS_DIR);
X  sprintf(g_fn,"%s/%s",news_dir,NGDB_FILE);
X  g_fp=fopen(g_fn,"r");
X  if (g_fp!=NULL)
X/*    while ((fscanf(g_fp,"%[^:]: %d %d %c",g_name_in,&first_in,&last_in,
X		   &post_in))>0) */
X    while ((fgets(s_in,100,g_fp))!=NULL)
X      {
X	s_in[strlen(s_in)-1] = '\0';
X	sscanf(s_in,"%s %d %d %c",g_name_in,&first_in,&last_in,&post_in);
X	g_temp=(s_group *)malloc(sizeof(s_group));
X	sprintf((g_temp)->name,"%s",g_name_in);
X	(g_temp)->first=first_in;
X	(g_temp)->last=last_in;
X	(g_temp)->postable=post_in;
X	(g_temp)->next=NULL;
X	if ((human==0)||(g_temp->postable=='1'))
X	  if (!reading||((g_temp->first)<=(g_temp->last)))
X	  {
X	    group_insert(&g_first,g_temp);
X	    total_groups++;
X	  }
X	else
X	  free(g_temp);
X      }
X  if (g_fp != NULL) { fclose(g_fp); } 
X  clear();
X  if (g_first==NULL)
X    {
X      fprintf(stderr,"Problem getting group database\n");
X      return(NULL);
X    }
X  statline("choose the group you want (RETURN to exit)","news_group_choices");
X  statline2("*'s indicate articles exist","");
X  g_index=0;
X  for ((g_temp)=(g_first);(g_temp)!=NULL;(g_temp)=(g_temp)->next)
X    {
X      if ((g_temp)->last >= (g_temp)->first)
X	mvaddstr((g_index)+2,6,"*");
X      mvaddstr((g_index++)+2,7,(g_temp)->name);
X    }
X  mvaddstr(LINES-4,5,"Position arrow with [j]/[2] (down) and [k]/[8] (up)");
X  mvaddstr(LINES-3,5,"RETURN to Read, Q to Quit");
X  cur_pos=1;
X  mvaddstr(cur_pos+1,1,"===>");
X  refresh();
X  done=0;
X  g_temp=NULL;
X/*  if (total_groups==1)
X    {
X      done=1;
X      g_temp=g_first;
X    } */
X  while (!done)
X    {
X      switch(c=getch()) {
X      case 'k':
X      case '8':
X	if (cur_pos>1)
X	  {
X	    mvaddstr(cur_pos+1,1,"    ");
X	    cur_pos--;
X	    mvaddstr(cur_pos+1,1,"===>");
X	    refresh();
X	  }
X	break;
X      case 'j':
X      case '2':
X	if (cur_pos<total_groups)
X	  {
X	    mvaddstr(cur_pos+1,1,"    ");
X	    cur_pos++;
X	    mvaddstr(cur_pos+1,1,"===>");
X	    refresh();
X	  }
X	break;
X      case '\n':
X      case '\r':
X      case ' ':
X	g_temp=g_first;
X	if (cur_pos>1)
X	  for(loop=2;loop<=cur_pos;loop++)
X	    g_temp=g_temp->next;
X	done=1;
X	break;
X      case 'q':
X      case 'Q':
X	done = 1;
X	break;
X      } /* switch */
X    } /* while */
X  
X/*  ret = wget_name(stdscr, g_name_in);
X  if (ret > 0)
X    {
X      g_temp=group_find(g_first,g_name_in);
X      if (g_temp==NULL)
X	{
X	  statline("Bad Group Name - Space to Return","Bad Group Name");
X	  get_space();
X	}
X    }
X  clear();*/
X/* Clean up allocated space */
X  g_ret=g_temp;
X  for(g_temp=g_first;g_temp!=NULL;g_temp=g_first)
X    {
X      if (g_temp!=g_ret)
X	{
X	  g_first=g_temp->next;
X	  free(g_temp);
X	}
X      else
X	{
X	  g_first=g_temp->next;
X	  g_ret->next=NULL;
X	}
X    }
X  return(g_ret);
X} /* news_groups_menu */
X
Xnews()
X{
X  int not_done;
X  char tmp_fname[PATHLEN];
X  char date[80];
X  char from[80];
X  char subj[80],out[100];
X  FILE *tmp_fp;
X  int ret;
X  s_group *g_first,*g_temp;
X  char group[80];
X  statline("do you want to (r)ead news or (p)ost news","news");
X  switch (getch()) {
X  case 'r':
X    g_temp=news_groups_menu(0,1); /* 0 = not human(n/a), 1 = reading */
X/*    if (g_temp!=NULL)
X      news_arts_menu(g_temp,world.turn);*/
X    while(g_temp!=NULL)
X      {
X	news_arts_menu(g_temp,world.turn);
X	g_temp=news_groups_menu(0,1); /* 0 = not human(n/a), 1=reading */
X      }
X    clear(); refresh();
X    break;
X  case 'p':
X    sprintf(date,"Thon %d",world.turn);
X    sprintf(from,"%s of %s",user.np->leader,user.np->name);
X    clear();
X    g_temp=news_groups_menu(1,0); /* 1=human, 0=posting(!reading) */
X    clear();
X    if(g_temp!=NULL)
X      {
X	strcpy(tmp_fname, "/usr/tmp/domXXXXXX");
X	if (mktemp(tmp_fname) == NULL) {
X	  fprintf(stderr,"Error getting temp file name\n");
X	  fflush(stderr);
X	  return;
X	}
X	statline("Enter Subject","Posting News");
X	mvaddstr(2,1,"Subject: ");
X	wget_name(stdscr, subj);
X/*	echo();
X	nocbreak();
X	refresh();
X	scanw("%[^\n]",subj);
X	noecho();
X	cbreak();
X	refresh();
X*/
X	cleanup();
X	edit(tmp_fname);
X	{
X	  init_screen();
X/*	  initscr();
X	  savetty();
X	  nonl();
X	  cbreak();
X	  noecho();
X	  clear();
X*/
X	}
X	mvaddstr(2,0,"Choices: S)end news or A)bort posting ");
X	refresh();
X	not_done=1;
X	while(not_done)
X	  {
X	    switch(getch()) {
X	    case 'S':
X	    case 's':
X	      mvaddstr(3,9,"Posting News...");
X	      refresh();
X	      post_news_file(tmp_fname, g_temp->name, subj, user.id);
X	      mvaddstr(3,24,"done.");
X	      refresh();
X	      not_done=0;
X	      unlink(tmp_fname);
X	      break;
X	    case 'A':
X	      mvaddstr(3,23,"OK. Aborting...");
X	      refresh();
X	      unlink(tmp_fname);
X	      not_done=0;
X	      break;
X	    } /* switch */
X	  } /* while */
X	{
X	  cleanup();
X	  init_screen();
X	}
X      } /* if g_temp!=NULL */
X    break;
X  } /* switch */
X  user.just_moved = 1;
X} /* news */
END_OF_FILE
if test 19406 -ne `wc -c <'c_news.c'`; then
    echo shar: \"'c_news.c'\" unpacked with wrong size!
fi
# end of 'c_news.c'
fi
if test -f 'economy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'economy.c'\"
else
echo shar: Extracting \"'economy.c'\" \(18590 characters\)
sed "s/^X//" >'economy.c' <<'END_OF_FILE'
X/* economy.c -- routines which deal with the economy, revenue and
X               expenses of all types.
X */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X/* calc_revenue(np) - find the amount of tax revenue for a nation  */
X/* calc_metal(np) - find the amount of metal produced by nation    */
X/* calc_jewels(np) - find the amount of jewels produced by nation  */
X/* calc_food(np) - find the amount of food produced by nation      */
X/* calc_expend(np) - calculate a nation's expenditures             */
X/* calc_expend_metal(np) - calculate metal expenditures for nation */
X/* calc_expend_jewels(np) - calculate jewel expenditures for nation*/
X/* calc_expend_food(np) - calculate food expenditures for a nation */
X/* sector_metal(sp) - calculate metal produced in a single sector  */
X/* sector_jewels(sp) - calculate jewels produced in single sector  */
X/* sector_food(sp) - calculate food produced in a single sector    */
X/* military_maint(np) - returns total amount of money spent for armies */
X/* military_maint_metal(np) - total amount of metal spent for armies   */
X/* military_maint_jewels(np) - total amount of jewels spent for armies */
X/* army_maint_money(ap) - amount of money needed to maintain given army*/
X/* construct_cost(type) - cost to construct object                 */
X/* construct_cost_metal(type) - metal cost to construct object     */
X/* get_employed(np) - how many employed in that nation             */
X/* get_emp_met(np) - how many employed metal miners                */
X/* get_emp_jws(np) - how many employed jewel miners                */
X/* get_emp_farm(np) - how many employed farmers                    */
X/* (same for unemployed)                                           */
X/* get_avg_money(wp) - average money in the world                  */
X/* emp_desire(np,x,y) - gives the employment desireability in x,y  */
X/* n_workers(sp) - number of people employed in that sect.         */
X/* prod_level(np) - Relative level of production of a nation       */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X#include "costs.h"
X#include "cur_stuff.h"
X#include <stdio.h>
X#include <ctype.h>
X#include <signal.h>
X#include <math.h>
X
Xextern Sworld world;
Xextern struct s_desig_map desig_map[];
Xextern struct s_altitude_map altitude_map[];
Xextern struct item_map terrains[];
Xextern struct item_map climates[];
Xextern Suser user;
Xextern int debug;
Xextern int (*wrapx)(), (*wrapy)();
X
X#define PROD_POWER (7.0/6.0)
X
Xdouble prod_level(np)
X     Snation *np;
X{
X  return (1.0 - pow((double)(np->taxes)/100.0,PROD_POWER));
X}
X
X  /* calculate the amount of tax revenue for a given nation */
Xcalc_revenue(np)
X     Snation *np;
X{
X  Ssector *sp;
X  struct pt_list *points;
X  int income = 0, taxes = np->taxes, pop;
X    /* first thing: run through the list of that nation's sectors
X       and see what income might come from the various sectors
X     */
X  if ((points = np->ptlist) == NULL) {
X    return 0;			/* nation has no sectors!! */
X  }
X  do {
X    sp = &(world.map[points->pt.x][points->pt.y]);
X    pop = n_workers(sp);
X    income+=(taxes*prod_level(np)*pop*desig_map[sp->designation].revenue)/100;
X  } while ((points = points->next) != NULL);
X  return income;
X}
X
X
X/* int calc_metal (Snation *) -- calculates metal owned by all sectors owned.
X   - Cycles through all sectors owned, and computes metal production for
X     that sector.
X   - Sums them up, and returns the total.
X*/ 
X
Xint calc_metal (np)
X     Snation *np;
X{
X  Ssector *sp;
X  struct pt_list *points;
X  int metal_total = 0;
X  
X  if ((points = np->ptlist) == NULL) {
X    return 0;			/* nation has no sectors!! */
X  }
X  do {
X    sp = &(world.map [points->pt.x][points->pt.y]);
X    switch (sp->designation) {
X    case D_METAL_MINE:
X      metal_total += sector_metal(sp);
X      break;
X    default:
X      break;
X    }
X  } while ((points = points->next) != NULL);
X  
X  return (metal_total);
X}
X
X
X/* int calc_jewels (Snation *) -- calculates jewels owned by all sectors owned.
X *  - Cycles through all sectors owned.
X *  - If sector is a jewel mine, computes the jewels by:
X *        jewels_per_civilian * number_of_people
X *  - returns summation.
X */
X
Xint calc_jewels (np)
XSnation *np;
X{
X  Ssector *sp;
X  struct pt_list *points;
X  int jewels_total = 0;
X
X  if ((points = np->ptlist) == NULL) {
X    return 0;			/* nation has no sectors!! */
X  }
X  do {
X    sp = &(world.map[points->pt.x][points->pt.y]);
X    
X    switch (sp->designation) {
X    case D_JEWEL_MINE:
X      jewels_total += sector_jewels(sp);
X      break;
X    default:
X      break;
X    }
X  } while ((points = points->next) != NULL);
X
X  return (jewels_total);
X}
X
X  /* how much food is produced in the nation */
Xcalc_food(np)
X     Snation *np;
X{
X  Ssector *sp;
X  struct pt_list *points;
X  int food_total = 0;
X
X  if ((points = np->ptlist) == NULL) {
X    return 0;			/* nation has no sectors!! */
X  }
X  do {
X    sp = &(world.map[points->pt.x][points->pt.y]);
X    switch (sp->designation) {
X    case D_FARM:
X      food_total += sector_food(sp);
X      break;
X    default:
X      break;
X    }
X  } while ((points = points->next) != NULL);
X  
X  return food_total;
X}
X
X  /* calculate a nation's expenditures */
Xcalc_expend(np)
X     Snation *np;
X{
X  int percent;
X
X  percent = np->charity + np->tech_r_d + np->mag_r_d + np->spy_r_d;
X
X  return (percent*calc_revenue(np)) / 100 + military_maint(np)
X    + non_profit_maint(np);;
X}
X
Xcalc_expend_metal(np)
X     Snation *np;
X{
X  int percent;
X
X  percent = np->tech_r_d_metal;
X
X  return (percent*calc_metal(np)) / 100 + military_maint_metal(np);
X}
X
Xcalc_expend_jewels(np)
X     Snation *np;
X{
X  int percent;
X
X  percent = np->mag_r_d_jewels;
X
X  return (percent*calc_jewels(np)) / 100 + military_maint_jewels(np);
X}
X
Xcalc_expend_food(np)
X     Snation *np;
X{
X  int food_eaten;
X
X  food_eaten = (int) (get_n_civil(np) * EAT
X		      + SOLD_EAT_FACTOR * get_n_soldiers(np) * EAT);
X
X  return food_eaten;
X}
X
X  /* now come a couple of routines that calculate
X     the amount of a resource (metal, jewels, food)
X     for a SINGLE sector
X   */
Xsector_metal(sp)
X     Ssector *sp;
X{
X  int i, j, n_refineries = 0;
X  float metal;
X  Snation *np = &world.nations[sp->owner];
X
X    /* see how many active refineries are close by.
X       a refinery is active if there are the minimum number
X       of people emplyed in it.
X     */
X  for (i = sp->loc.x-1; i <= sp->loc.x+1; ++i) {
X    for (j = sp->loc.y-1; j <= sp->loc.y+1; ++j) {
X      if ((world.map[(*wrapx)(i,j)][(*wrapy)(i,j)].designation == D_REFINERY)
X	  &&
X	  (world.map[(*wrapx)(i,j)][(*wrapy)(i,j)].n_people
X	   >= desig_map[D_REFINERY].min_employed)) {
X	++n_refineries;
X      }
X    }
X  }
X    /* add to metal production depending on the
X       number of refineries and the mining skill
X     */
X  metal = n_workers(sp) * (1.0 + np->mine_skill/100.0) * sp->metal;
X  metal *= (1.0 + REFINERY_FACT*n_refineries);
X  
X  return (int)(metal * prod_level(np));
X}
X
Xsector_jewels(sp)
X     Ssector *sp;
X{
X  Snation *np = &world.nations[sp->owner];
X  float jewels;
X  
X  jewels = n_workers(sp) * (1.0 + np->mine_skill/100.0) * sp->jewels;
X
X  return (int) (jewels * prod_level(np));
X}
X
Xsector_food(sp)
X     Ssector *sp;
X{
X  Snation *np = &world.nations[sp->owner];
X  float food;
X
X  food = (1.0 + np->farm_skill/100.0) * ((sp->soil+1)/6.0)
X    * n_workers(sp) * FOOD_PROD;
X
X  return (int) (food * prod_level(np));
X}
X
X  /* this returns the TOTAL amount of money spent
X     to maintain the nation's military forces
X   */
Xmilitary_maint(np)
X     Snation *np;
X{
X  Sarmy *ap;
X  int total = 0;
X
X  for (ap = np->armies; ap != NULL; ap = ap->next) {
X    total += army_maint_money(ap);
X  }
X
X  return total;
X}
X  /* this returns the TOTAL amount of metal spent
X     to maintain the nation's military forces
X   */
Xmilitary_maint_metal(np)
X     Snation *np;
X{
X  Sarmy *ap;
X  int total = 0;
X
X  for (ap = np->armies; ap != NULL; ap = ap->next) {
X    total += ap->n_soldiers * ap->metal_maint;
X  }
X
X  return total;
X}
X  /* this returns the TOTAL amount of jewels spent
X     to maintain the nation's military forces
X   */
Xmilitary_maint_jewels(np)
X     Snation *np;
X{
X  Sarmy *ap;
X  int total = 0;
X
X  for (ap = np->armies; ap != NULL; ap = ap->next) {
X    total += ap->n_soldiers * ap->jewel_maint;
X  }
X  return total;
X}
X  /* this returns the TOTAL amount of jewels spent
X     to maintain the nation's military forces
X   */
Xmilitary_maint_spell_pts(np)
X     Snation *np;
X{
X  Sarmy *ap;
X  int total = 0;
X  struct spirit_type *stype, *get_spirit_type();
X
X  for (ap = np->armies; ap != NULL; ap = ap->next) {
X/*    if (is_spirit(ap)) {
X      if ((stype = get_spirit_type(&user, ap->type)) == NULL) {
X	printf(
X    "\r\nBAD BUG: is_spirit(), but can't get which spirit from type %s\r\n",
X	       ap->type);
X      } else {
X	total += (ap->n_soldiers * ap->spell_pts_maint) / stype->size;
X      }
X    }
X*/
X    if (ap->spell_pts_maint != 0)  {
X      total += get_spell_pts_maint(ap);
X    }
X  }
X  return total;
X}
X
X  /* this gives the money needed to maintain a given army */
Xarmy_maint_money(ap)
X     Sarmy *ap;
X{
X  int money_maint = 0, index;
X  extern struct army_type *army_types;
X
X  if (is_army(ap)) {
X    index = army_type_index(ap);
X    money_maint = army_types[index].money_maint * ap->n_soldiers;
X  }
X    /* in other cases, money maint is zero */
X
X  return  money_maint + ARMY_OVERHEAD;
X}
X
X  /* this returns the TOTAL amount of money spent to
X     maintain the nation's non-profit centers (hospitals  ...)
X   */
Xnon_profit_maint(np)
X     Snation *np;
X{
X  struct pt_list *ptlist = np->ptlist; /* nation's list of owned sectors */
X  Ssector *sp;
X  int total = 0;
X
X  for ( ; ptlist != NULL; ptlist = ptlist->next) {
X    sp = &world.map[ptlist->pt.x][ptlist->pt.y];
X    switch (sp->designation) {
X    case D_UNIVERSITY:
X      total += UNIV_MAINT_COST;
X      break;
X    case D_HOSPITAL:
X      total += HOSPITAL_MAINT_COST;
X      break;
X    default:
X      break;
X    }
X  }
X  return total;
X}
X
Xget_n_students(np)
X     Snation *np;
X{
X  Ssector *sp;
X  struct pt_list *ptlist = np->ptlist;
X  int n = 0;
X
X  while (ptlist != NULL) {
X    sp = &world.map[ptlist->pt.x][ptlist->pt.y];
X    if (sp->designation == D_UNIVERSITY) {
X      n += n_workers(sp);
X    }
X    ptlist = ptlist->next;
X  }
X  return n;
X}
X
Xget_n_priests (np)
X     Snation *np;
X{
X  Ssector *sp;
X  struct pt_list *ptlist = np->ptlist;
X  int n = 0;
X
X  while (ptlist != NULL) {
X    sp = &world.map[ptlist->pt.x][ptlist->pt.y];
X    if (sp->designation == D_TEMPLE) {
X      n += n_workers(sp);
X    }
X    ptlist = ptlist->next;
X  }
X  return n;
X}
X
Xget_employed(np)
X     Snation *np;
X{
X  Ssector *sp;
X  struct pt_list *ptlist = np->ptlist;
X  int n = 0;
X
X  while (ptlist != NULL) {
X    sp = &world.map[ptlist->pt.x][ptlist->pt.y];
X        /* only people who are employed */
X    n += n_workers(sp);
X    ptlist = ptlist->next;
X  }
X  return n;
X}
X
Xget_unemployed(np)
X     Snation *np;
X{
X  Ssector *sp;
X  struct pt_list *ptlist = np->ptlist;
X  int n = 0;
X
X  while (ptlist != NULL) {
X    sp = &world.map[ptlist->pt.x][ptlist->pt.y];
X        /* only people who are un-employed */
X    n += max(0, sp->n_people - n_workers(sp));
X    ptlist = ptlist->next;
X  }
X  return n;
X}
X
Xget_emp_met(np)
X     Snation *np;
X{
X  Ssector *sp;
X  struct pt_list *ptlist = np->ptlist;
X  int n = 0;
X
X  while (ptlist != NULL) {
X    sp = &world.map[ptlist->pt.x][ptlist->pt.y];
X        /* only people who are employed */
X    if (sp->designation == D_METAL_MINE) {
X      n += n_workers(sp);
X    }
X    ptlist = ptlist->next;
X  }
X  return n;
X}
X
Xget_unemp_met(np)
X     Snation *np;
X{
X  Ssector *sp;
X  struct pt_list *ptlist = np->ptlist;
X  int n = 0;
X
X  while (ptlist != NULL) {
X    sp = &world.map[ptlist->pt.x][ptlist->pt.y];
X    if (sp->designation == D_METAL_MINE) {
X        /* only people who are un-employed */
X      n += max(0, sp->n_people - n_workers(sp));
X    }
X    ptlist = ptlist->next;
X  }
X  return n;
X}
X
Xget_emp_jwl(np)
X     Snation *np;
X{
X  Ssector *sp;
X  struct pt_list *ptlist = np->ptlist;
X  int n = 0;
X
X  while (ptlist != NULL) {
X    sp = &world.map[ptlist->pt.x][ptlist->pt.y];
X        /* only people who are employed */
X    if (sp->designation == D_JEWEL_MINE) {
X      n += n_workers(sp);
X    }
X    ptlist = ptlist->next;
X  }
X  return n;
X}
X
Xget_unemp_jwl(np)
X     Snation *np;
X{
X  Ssector *sp;
X  struct pt_list *ptlist = np->ptlist;
X  int n = 0;
X
X  while (ptlist != NULL) {
X    sp = &world.map[ptlist->pt.x][ptlist->pt.y];
X    if (sp->designation == D_JEWEL_MINE) {
X        /* only people who are un-employed */
X      n += max(0, sp->n_people - n_workers(sp));
X    }
X    ptlist = ptlist->next;
X  }
X  return n;
X}
X
Xget_emp_farm(np)
X     Snation *np;
X{
X  Ssector *sp;
X  struct pt_list *ptlist = np->ptlist;
X  int n = 0;
X
X  while (ptlist != NULL) {
X    sp = &world.map[ptlist->pt.x][ptlist->pt.y];
X        /* only people who are employed */
X    if (sp->designation == D_FARM) {
X      n += n_workers(sp);
X    }
X    ptlist = ptlist->next;
X  }
X  return n;
X}
X
Xget_unemp_farm(np)
X     Snation *np;
X{
X  Ssector *sp;
X  struct pt_list *ptlist = np->ptlist;
X  int n = 0;
X
X  while (ptlist != NULL) {
X    sp = &world.map[ptlist->pt.x][ptlist->pt.y];
X    if (sp->designation == D_FARM) {
X        /* only people who are un-employed */
X      n += max(0, sp->n_people - n_workers(sp));
X    }
X    ptlist = ptlist->next;
X  }
X  return n;
X}
X
X  /* the service sector!! */
Xget_emp_serv(np)
X     Snation *np;
X{
X  return get_employed(np)-get_emp_met(np)-get_emp_jwl(np)-get_emp_farm(np);
X}
X
Xget_unemp_serv(np)
X     Snation *np;
X{
X  return get_unemployed(np)
X    - get_unemp_met(np) - get_unemp_jwl(np) - get_unemp_farm(np);
X}
X
X  /* tax revenue from the service sector */
Xcalc_serv_revenue(np)
X     Snation *np;
X{
X  Ssector *sp;
X  struct pt_list *points;
X  int income = 0;
X  int taxes = np->taxes;
X    /* first thing: run through the list of that nation's sectors
X       and see what income might come from the various sectors
X     */
X  if ((points = np->ptlist) == NULL) {
X    return 0;			/* nation has no sectors!! */
X  }
X  do {
X    sp = &(world.map[points->pt.x][points->pt.y]);
X    switch (sp->designation) {
X    case D_METAL_MINE:
X    case D_JEWEL_MINE:
X    case D_FARM:
X      break;
X    default:			/* other things (service sector) */
X      income += (taxes * prod_level(np)*n_workers(sp)*
X                            desig_map[sp->designation].revenue)/100;
X      break;
X    }
X  } while ((points = points->next) != NULL);
X  return income;
X}
X
X  /* average quantities of all nations in the world */
Xget_avg_money(wp)
X      Sworld *wp;
X{
X  Snation *np;
X  int i, n_nations = 0, total = 0;
X
X  for (i = 1; i < wp->n_nations; ++i) {
X    np = &wp->nations[i];
X    if (is_active_ntn(np)) {
X      ++n_nations;
X      total += np->money;
X    }
X  }
X  return n_nations ? total/n_nations : 0;
X}
X
Xget_avg_metal(wp)
X      Sworld *wp;
X{
X  Snation *np;
X  int i, n_nations = 0, total = 0;
X
X  for (i = 1; i < wp->n_nations; ++i) {
X    np = &wp->nations[i];
X    if (is_active_ntn(np)) {
X      ++n_nations;
X      total += np->metal;
X    }
X  }
X  return n_nations ? total/n_nations : 0;
X}
X
Xget_avg_jewels(wp)
X      Sworld *wp;
X{
X  Snation *np;
X  int i, n_nations = 0, total = 0;
X
X  for (i = 1; i < wp->n_nations; ++i) {
X    np = &wp->nations[i];
X    if (is_active_ntn(np)) {
X      ++n_nations;
X      total += np->jewels;
X    }
X  }
X  return n_nations ? total/n_nations : 0;
X}
X
Xget_avg_food(wp)
X      Sworld *wp;
X{
X  Snation *np;
X  int i, n_nations = 0, total = 0;
X
X  for (i = 1; i < wp->n_nations; ++i) {
X    np = &wp->nations[i];
X    if (is_active_ntn(np)) {
X      ++n_nations;
X      total += np->food;
X    }
X  }
X  return n_nations ? total/n_nations : 0;
X}
X
Xget_avg_civil(wp)
X      Sworld *wp;
X{
X  Snation *np;
X  int i, n_nations = 0, total = 0;
X
X  for (i = 1; i < wp->n_nations; ++i) {
X    np = &wp->nations[i];
X    if (is_active_ntn(np)) {
X      ++n_nations;
X      total += get_n_civil(np);
X    }
X  }
X  return n_nations ? total/n_nations : 0;
X}
X
Xget_avg_soldiers(wp)
X      Sworld *wp;
X{
X  Snation *np;
X  int i, n_nations = 0, total = 0;
X
X  for (i = 1; i < wp->n_nations; ++i) {
X    np = &wp->nations[i];
X    if (is_active_ntn(np)) {
X      ++n_nations;
X      total += get_n_soldiers(np);
X    }
X  }
X  return n_nations ? total/n_nations : 0;
X}
X
X
Xget_avg_sectors(wp)
X     Sworld *wp;
X{
X  Snation *np;
X  int i, n_nations = 0, total = 0;
X
X  for (i=1; i < wp->n_nations; i++) {
X    np = &wp->nations[i];
X    if (is_active_ntn(np)) {
X      ++n_nations;
X      total += np->n_sects;
X    }
X  }
X  return n_nations ? total/n_nations : 0;
X}
X
X
Xget_per_occu_land(wp)
X     Sworld *wp;
X{
X  int x, y, land = 0, n_occu = 0;
X
X  for (y = 0; y < wp->ymax; y++)
X    for (x = 0; x < wp->xmax; x++)
X      if (wp->map[x][y].altitude >= SEA_LEVEL) {
X	land++;
X	if (wp->map[x][y].owner != 0)
X	  n_occu++;
X      }
X  return (n_occu*100)/land;
X}
X
Xget_per_occu_water(wp)
X     Sworld *wp;
X{
X  int x, y, water = 0, n_occu = 0;
X
X  for (y = 0; y < wp->ymax; y++)
X    for (x = 0; x < wp->xmax; x++)
X      if (wp->map[x][y].altitude < SEA_LEVEL) {
X	water++;
X	if (wp->map[x][y].owner != 0)
X	  n_occu++;
X      }
X  if (water != 0) {
X    return (n_occu*100)/water;
X  } else {
X    return 0;
X  }
X}
X
X
X  /* return the number of active nations (including game master) */
Xget_n_act_ntn(wp)
X     Sworld *wp;
X{
X  int i, total = 0;
X
X  for (i = 0; i < wp->n_nations; ++i) {
X    if (is_active_ntn(&wp->nations[i])) {
X      ++total;
X    }
X  }
X  return total;
X}
X
Xn_workers(sp)
X     Ssector *sp;
X{
X  double race_factor;
X
X  race_factor = sqrt(world.nations[sp->owner].race.repro/10.0);
X return min(sp->n_people,
X	    (int) (desig_map[sp->designation].max_employed*race_factor));
X}
X
Xint emp_desire(np, x, y)	/* desireability for employment */
X     Snation *np;
X     int x, y;
X{
X  int unemployed;
X  Ssector *sp = &world.map[x][y];
X
X/*  unemployed = min(0, n_workers(sp) - sp->n_people); */
X    /* what we return is the percentage of people employed */
X  return sp->n_people ? (100*n_workers(sp))/sp->n_people : 100;
X}
END_OF_FILE
if test 18590 -ne `wc -c <'economy.c'`; then
    echo shar: \"'economy.c'\" unpacked with wrong size!
fi
# end of 'economy.c'
fi
if test -f 'npc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'npc.c'\"
else
echo shar: Extracting \"'npc.c'\" \(19296 characters\)
sed "s/^X//" >'npc.c' <<'END_OF_FILE'
X   /* npc.c -- modules involved in NPC movemaking */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X#ifdef SYSV
X# include <string.h>
X#else
X# include <strings.h>
X#endif /* SYSV */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X#include <math.h>
X#include <curses.h>
X#include <stdio.h>
X#include <ctype.h>
X#include <signal.h>
X
Xextern Sworld world;
Xextern Suser user;
Xextern struct s_desig_map desig_map[];
Xextern int (*wrapx)(), (*wrapy)();
Xextern Sdiplo **allocate_diplo();
Xextern int debug;
Xextern struct army_type *army_types;
Xextern struct spirit_type *spirit_types;
X
Xstruct desire {
X  int base,final;
X};
X
Xfloat npc_food_need,npc_metal_need,npc_jewel_need,npc_money_need;
Xint opt_army_size,atwar,npc_specific;
X
X/*-----------------------------npc_moves()------------------------------------
X	This function makes the moves for an npc
X----------------------------------------------------------------------------*/
Xnpc_moves(np)
X     Snation *np;
X{
X  int i;
X  struct desire **des_array;
X
X  des_array = (struct desire **) malloc(world.xmax*sizeof(struct desire*));
X  for (i = 0; i < world.xmax; ++i)
X    des_array[i] = (struct desire *) malloc(world.ymax*sizeof(struct desire));
X  if (debug)
X    printf("doing init\n");
X  init_npc(np);
X/*  npc_needs(np); */
X  do_npc_draft(np);
X  if (debug)
X    printf("doing merge\n");
X  do_npc_merge(np);
X  if (debug)
X    printf("doing split\n");
X  do_npc_split(np);
X  if (debug)
X    printf("doing summon\n");
X  do_npc_summon(np);
X  if (debug)
X    printf("doing armies\n");
X  do_npc_armies(np,des_array);
X  if (debug)
X    printf("doing redesig\n");
X  do_npc_redesig(np);
X
X  for (i = 0; i < world.xmax; i++)	/* free desire array */
X    free(des_array[i]);
X  free(des_array);
X
X  for (i = 0; i < world.xmax; ++i) {	/* free visible sectors array */
X    free(user.visible_sectors[i]);
X  }
X  free(user.visible_sectors);
X
X  free_diplo(user.diplo_matrix, world.n_nations);
X}
X
X/*-------------------------------init_npc()----------------------------------
X	This is basically the function init_user, copied from user.c.  There
Xare some things that init_user does that this does not do.
X	Also, this function sets global varibles like needs and race-specific
Xarmy types.
X---------------------------------------------------------------------------*/
Xinit_npc(np)
X     Snation *np;
X{
X  int c,i,d;
X  FILE *fp, *fopen();
X  char line[EXECLEN];
X
X    /* find out which army types are available to the user */
X  user.avail_armies = NULL;
X  get_avail_armies(&user, np->tech_skill);
X
X	/*------ set npc_specific to be 1 + the index of the race 
X		 specific army type, if any.  ---------------*/
X  npc_specific = 0;
X  if ((fp = fopen(RACES_FILE, "r")) != NULL) {
X    while (1) {
X      if (fgets(line, EXECLEN, fp) == NULL)
X        break;
X      if (strncmp(line, np->race.name, strlen(np->race.name)) == 0
X	  && strncmp(line+strlen(np->race.name), "_armies:",
X		     strlen("_armies:")) == 0) {
X        if (line[strlen(line)-1] == '\n') {
X          line[strlen(line)-1] = '\0';
X	}
X	npc_specific = army_type_index(strchr(line, ':')+1) + 1;
X      }
X    }
X    fclose(fp);
X  }
X
X  user.spirit_list = NULL;
X  get_spirits(&user, np->mag_skill);
X    /* now set fields for the ustruct */
X  user.underwater = 0;		/* user is not underwater at start */
X  if (np->race.pref_alt < 0) {
X    user.underwater = 1;	/* merfolk or whatever */
X  }
X    /* load user's diplomacy statuses, for fast access later;
X       also remember the initial values, so users cannot change
X       their status by more than one step at a time.
X     */
X  user.diplo_matrix = allocate_diplo(world.n_nations);
X/*  user.init_diplo = allocate_diplo(world.n_nations); */
X  read_in_diplo(user.diplo_matrix, world.n_nations);
X/*  read_initial_diplo(user.init_diplo, world.n_nations); */
X
X/* now do diplomacy and set the atwar variable to 1 if npc is at war */
X  do_npc_diplo(np);
X
X    /* load hanging spells, and put them in this user's list */
X  load_h_spells(&user);
X    /* calculate visibility matrix for this user.
X       this might depend on spells, so do it after
X       loading spells.
X     */
X  user.visible_sectors = (int **) malloc(world.xmax*sizeof(int *));
X  for (i = 0; i < world.xmax; ++i) {
X    user.visible_sectors[i] = (int *) malloc(world.ymax*sizeof(int));
X  }
X  find_visible_sectors(user.visible_sectors);
X
X
X/*  npc_money_need =(float)calc_expend(np)/((float)calc_revenue(np)+1.0);
X  npc_metal_need =(float)calc_expend_metal(np)/((float)calc_metal(np)+1.0)+.3;
Xnpc_jewel_need =(float)calc_expend_jewels(np)/((float)calc_jewels(np)+1.0)+.3;*/
X
X  npc_metal_need = atwar ? 1.3:1.0; /* for now */
X  npc_jewel_need = atwar ? 1.3:1.0; /* for now */
X  npc_food_need = (float)calc_expend_food(np)/((float)calc_food(np)+1.0);
X  if(atwar){
X    opt_army_size = get_n_soldiers(np)*2/np->n_sects;
X    opt_army_size=max(OCCUPYING_SOLDIERS*3/2,opt_army_size);
X  }
X  else{
X    opt_army_size = OCCUPYING_SOLDIERS;
X  }
X
X  if(debug)
X    printf("opt size = %d.\n",opt_army_size);
X
X  if(atwar){
X    np->taxes = 20;
X    np->tech_r_d_metal = 0;
X    if (next_thon_jewels(np) < MAGE_JEWELS_MAINT) {
X      np->mag_r_d_jewels = 0;
X    } else {
X      if (calc_jewels(np) * 2 > np->jewels) {
X	np->mag_r_d_jewels = np->jewels * 50 / calc_jewels(np);
X      } else {
X	np->mag_r_d_jewels = 100;
X      }
X    }
X    np->mag_r_d = 15;
X    np->tech_r_d = 15;
X  } else {
X    np->taxes = 10;
X    np->tech_r_d_metal = 30;
X    np->mag_r_d_jewels = 0;
X    np->mag_r_d = 30;
X    np->tech_r_d = 30;
X  }
X}
X
X/*---------------------------do_npc_draft()-----------------------------------
X	Draft armies.  This routine has been altered to take technology
Xlevel into account.
X----------------------------------------------------------------------------*/
Xdo_npc_draft(np)
X     Snation *np;
X{
X  Sarmy ap, make_army();
X  Ssector *sp;
X  Savail_army *can_draft;
X  struct army_type this_atype;
X  int max_sold,cur_sold,ngood,good_armies[MAX_TYPES],i,drafted;
X  int cut1,cut2,start,stop,step;
X  char type[NAMELEN];
X
X	/*-------- Initialize variables for npc drafting -------*/
X  if(atwar) max_sold = get_n_civil(np)*np->npc_agg/200;
X  else max_sold = get_n_civil(np)*np->npc_agg/300;
X
X  cut1 = max_sold*(np->npc_agg/2)/100;		/* -30 bonus cutoff */
X  cut2 = max_sold*(np->npc_agg/2 + 25)/100;	/* -1 to -29 bonus cutoff */
X  cur_sold = get_n_soldiers(np);
X  ngood = get_good_types(good_armies,cur_sold,cut1,cut2);
X
X	/*--- now draft from the cheap armies if we are desperate ------*/
X  if(cur_sold < cut2 || (cur_sold - cut2 < max_sold - cur_sold)){
X    start = 0;
X    stop = ngood;
X    step = 1;
X  } else{
X    start = ngood-1;
X    stop = -1;
X    step = -1;
X  }
X	/*--- get cut 2 out of the way if we have already passed it ---*/
X  if(cur_sold > cut2) cut2 = 2*max_sold;
X
X  if(ngood == 0)	/* no armies we want to draft */
X    return;
X
X		/*------ Now draft armies ---------*/
X  while(cur_sold < max_sold){
X    drafted = 0;
X    for(i = start;(i != stop) && (cur_sold < max_sold);i += step){
X      this_atype = army_types[good_armies[i]];
X      strcpy(type,this_atype.type);
X      sp = &world.map[np->capital.x][np->capital.y];
X      ap = make_army(type,type, opt_army_size, A_DEFEND, np->id, sp->loc);
X      ap.id = free_army_id(np);
X      ap.next = NULL;
X      if (ap.n_soldiers > sp->n_people || army_cost(&ap) > np->money ||
X            army_cost_metal(&ap) > np->metal) {
X        break;
X      }
X      ++np->n_armies;
X      cur_sold += opt_army_size;
X      drafted = 1;
X      if (debug)
X        printf("npc drafted %s\n",type);
X
X      if (np->armies == NULL) {
X        np->armies = (Sarmy *) malloc(sizeof(Sarmy));
X        *(np->armies) = ap;
X        np->armies->next = NULL;
X      } else {
X        insert_army_nation(np, &ap, -1);
X      }
X      insert_army_sector(sp, &ap);
X      sp->n_people -= ap.n_soldiers;
X      np->money -= army_cost(&ap);
X      np->metal -= army_cost_metal(&ap);
X    }
X  if(cur_sold > cut2){			/* need to recalc good types */
X    cut1 = max_sold*(np->npc_agg/2)/100;	/* -30 bonus cutoff */
X    cut2 = max_sold*(np->npc_agg/2 + 25)/100;	/* -1 to -29 bonus cutoff */
X    ngood = get_good_types(good_armies,cur_sold,cut1,cut2);
X    if(cur_sold > cut1) cut1 = 2*max_sold;
X    if(cur_sold > cut2) cut2 = 2*max_sold;
X  }
X  if(!drafted || !ngood)	/* No armies can be drafted anymore */
X    return;
X  }
X}
X
X/*----------------------------do_npc_summon()--------------------------------
X	Have the npc draft a mage, if necessary, and summon spirits.
XBasically, find the net spell points and draft the biggest spirit you can.
XDon't draft caravan spirits.
X---------------------------------------------------------------------------*/
Xdo_npc_summon(np)
XSnation *np;
X{
X  int have_mage = 0,sindex,net_points,badflags;
X  Sarmy army,make_army();
X  struct spirit_type this_stype;
X  Ssector *sp;
X  Sspirit *sptr,*tmp_sptr;
X
X  if(!atwar || np->spell_pts < 2)
X    return;
X
X  badflags = AF_INVERSE_ALT & AF_CARGO;
X  if (user.underwater)
X    badflags |= AF_LAND;
X  else
X    badflags |= AF_WATER;
X
X  sp = &world.map[np->capital.x][np->capital.y];
X
X  have_mage = get_first_mage(np);
X  if (!have_mage) {
X    if (np->jewels >= INITIATION_JEWELS && next_thon_jewels(np) > 6000)
X      init_npc_mage(np,sp);
X    else
X      return;			/* no mage, can't summon */
X  }
X  
X  net_points = new_spell_pts(np) - military_maint_spell_pts(np);
X  while(net_points){		/* while we can still summon */
X    tmp_sptr = 0;
X    for(sptr = user.spirit_list ; sptr ; sptr = sptr->next){
X      if (np->spell_pts < sptr->cost) 
X	break;
X      tmp_sptr = sptr;
X    }
X    if (!tmp_sptr)
X      break;
X
X    sindex = spirit_type_index(tmp_sptr->type);
X    this_stype = spirit_types[sindex];
X    while ((this_stype.flags & badflags) && sptr != user.spirit_list){
X      for (sptr = user.spirit_list ;sptr->next != tmp_sptr ;sptr = sptr->next);
X      sindex = spirit_type_index(sptr->type);
X      this_stype = spirit_types[sindex];
X      tmp_sptr = sptr;
X      }
X
X    if (this_stype.flags & badflags)
X      break;
X
X    if (debug)
X      printf("npc summons %s\n",tmp_sptr->type);
X
X    army = make_army(this_stype.type, this_stype.type, this_stype.size,
X		     A_DEFEND, np->id, sp->loc);
X    army.id = free_army_id(np);
X    army.next = NULL;
X    army.flags = this_stype.flags;
X
X  /*============ now insert it into the list ============*/
X
X    ++np->n_armies;
X    if (np->armies == NULL) { 		/* special case:  empty list */
X      np->armies = (Sarmy *) malloc(sizeof(Sarmy));
X      *(np->armies) = army;
X      np->armies->next = NULL;
X    } else {
X      insert_army_nation(np, &army, -1);
X    }
X    insert_army_sector(sp, &army);
X    np->spell_pts -= spirit_types[sindex].spell_pts_draft;
X    net_points = new_spell_pts(np) - military_maint_spell_pts(np);
X  }
X}
X
X/*-----------------------------do_npc_merge()--------------------------------
X	merge npc armies together.  If an army has less than an optimal
Xnumber of units, check for other armies of the npc that are reachable and
Xwithin NPC_VIEW sectors.  Move to the one that will give the greatest
Xmovement left and merge.  Prefer to merge with other armies that have
Xless than the optimal number.
X---------------------------------------------------------------------------*/
Xdo_npc_merge(np)
X  Snation *np;
X{
X  int i,tx,ty,x,y,finalmv;
X  Pt finalpos;
X  Sarmy *bestarmy,*ap,*tmpap,*get_army();
X  struct armyid *alist;
X  struct argument args[N_EXEC_ARGS];
X  struct tmp_map {
X    int mvcost,mvleft;
X  } legal_moves[NPC_SIDE][NPC_SIDE];
X
X  for(i = 0;i < NPC_SIDE; i++){			/* fill in border of legal mv */
X    legal_moves[0][i].mvleft = -2;
X    legal_moves[NPC_SIDE-1][i].mvleft = -2;
X    legal_moves[i][0].mvleft = -2;
X    legal_moves[i][NPC_SIDE-1].mvleft = -2;
X  }
X
X  for(ap = np->armies ;ap ;ap = ap->next){	/* for all npcs armies */
X    if(ap->n_soldiers >= max(opt_army_size*2/3,OCCUPYING_SOLDIERS))
X      continue;					/* skip loop if army ok. */
X    if(is_mage(ap))
X      continue;
X    bestarmy = 0;
X    check_moves(np,ap,legal_moves);		/* new function */
X
X    /* now check for armies belonging to this player that can be moved to */
X
X /*   printf("%d needs to merge.\n",ap->id); */
X    for (x = ap->pos.x-NPC_VIEW; x <= ap->pos.x+NPC_VIEW; x++) {
X      for (y = ap->pos.y-NPC_VIEW; y <= ap->pos.y+NPC_VIEW; y++) {
X	alist = world.map[(*wrapx)(x,y)][(*wrapy)(x,y)].alist;
X	while(alist){
X	  if(alist->owner == np->id){		/* if same owner */
X	    tx = x - ap->pos.x + NPC_VIEW + 1;
X	    ty = y - ap->pos.y + NPC_VIEW + 1;	/* coords in legal_move */
X	    if(legal_moves[tx][ty].mvleft >= 0){
X	      tmpap = get_army(np, alist->id);
X	    /* printf("looking at army %d\n",tmpap->id); */
X	      if(tmp_army_better(ap,tmpap,bestarmy) && tmpap != ap){
X	    /* printf("best is %d\n",tmpap->id); */
X	        bestarmy = tmpap;
X		finalpos.x = x;
X		finalpos.y = y;
X		finalmv = legal_moves[tx][ty].mvleft;
X              }
X	    }
X	  }
X	  alist = alist->next;
X	}	/* while alist */
X      }		/* for y */
X    }		/* for x */
X
X  /* now move the army to the correct location and merge.  */
X    if(bestarmy){
X      if (debug)
X        printf("npc army %d merges with %d.\n",ap->id,bestarmy->id);
X      args[1].data.num = ap->id;
X      alist = world.map[(*wrapx)(x,y)][(*wrapy)(x,y)].alist;
X      args[2].data.num = (*wrapx)(finalpos.x,finalpos.y);
X      args[3].data.num = (*wrapy)(finalpos.x,finalpos.y);
X      args[4].data.num = finalmv;
X      cmd_amove(np,args);		/* move army to new location */
X      args[1].data.num = ap->id;
X      args[2].data.num = bestarmy->id;
X      cmd_amerge(np,args);
X    }
X  }		/* for ap */
X}
X
X/*--------------------------------do_npc_split()------------------------------
X	Split armies that have grown too large into manageable armies
X----------------------------------------------------------------------------*/
Xdo_npc_split(np)
XSnation *np;
X{
X  Sarmy *ap;
X  struct argument args[N_EXEC_ARGS];
X
X  for(ap = np->armies ;ap ;ap = ap->next){	/* for all npcs armies */
X    if(ap->n_soldiers < opt_army_size*2 || is_spirit(ap))
X      continue;					/* skip loop if army ok. */
X    while(ap->n_soldiers >= opt_army_size*2){
X      if (debug)
X	printf ("npc splits %d troops from army %d\n",opt_army_size,ap->id);
X      args[1].data.num = ap->id;
X      args[2].data.num = opt_army_size;
X      cmd_asplit(np,args);
X    }
X  }
X}
X
X/*-------------------------------do_npc_armies()------------------------------
X	This routine moves npc armies to desirable sectors.  Des_array is
Xan array containing the desirability of each sector on the map.  legal_moves
Xis an array containing the sectors that the army can see, with the sectors
Xthat the army can move to marked with the number of movepoints the army will
Xhave left at that point.  The function looks for the most desirable sectors
Xthat the army can move to and puts them in the highlist array.  It then
Xrandomly picks a point from this array and moves the army to it.
X----------------------------------------------------------------------------*/
Xdo_npc_armies(np,des_array)
X  Snation *np;
X  struct desire **des_array;
X{
X  int i,x,y,tx,ty,des_here,high_des,nhigh;
X  struct pt highlist[NPC_SIDE*NPC_SIDE];
X  Sarmy *ap;
X  struct argument args[N_EXEC_ARGS];
X  struct tmp_map {
X    int mvcost,mvleft;
X  } legal_moves[NPC_SIDE][NPC_SIDE],final;
X
X  find_desire(np,des_array);			/* fill desireability array */
X  for(i = 0;i < NPC_SIDE; i++){			/* fill in border of legal mv */
X    legal_moves[0][i].mvleft = -2;
X    legal_moves[NPC_SIDE-1][i].mvleft = -2;
X    legal_moves[i][0].mvleft = -2;
X    legal_moves[i][NPC_SIDE-1].mvleft = -2;
X  }
X
X  /* Have NPC nation take sectors */
X  
X  if (np->n_armies == 0) {	/* If there are no armies, forget it */
X    return;
X  }
X  for (ap = np->armies; ap; ap = ap->next) {
X    if (debug)
X      printf("%d\n", ap->id);
X    if(is_mage(ap) && ap->n_soldiers == 1)
X      continue;
X    check_moves(np,ap,legal_moves);		/* new function */
X    high_des = -1;
X    for (x = ap->pos.x-NPC_VIEW; x <= ap->pos.x+NPC_VIEW; x++) {
X      for (y = ap->pos.y-NPC_VIEW; y <= ap->pos.y+NPC_VIEW; y++) {
X
X/* Now check if it's the most desireable sector so far */
X/* and if it can be moved to. */
X
X        if (good_altitude(&world.map[(*wrapx)(x,y)][(*wrapy)(x,y)],np)) {
X	  des_here = des_array[(*wrapx)(x,y)][(*wrapy)(x,y)].final;
X	  tx = x - ap->pos.x + NPC_VIEW + 1;
X	  ty = y - ap->pos.y + NPC_VIEW + 1;
X	  if (legal_moves[tx][ty].mvleft >= 0){
X	    if(des_here > high_des) {
X	      nhigh = 1;
X	      highlist[0].x = x;
X	      highlist[0].y = y;
X	      high_des = des_here;
X	    }
X	    if(des_here == high_des) {
X	      highlist[nhigh].x = x;
X	      highlist[nhigh++].y = y;
X	    }
X          }
X	}
X      }		/* end y loop */
X    }		/* enc x loop */
X
X    /* Move army to one of the desireable sectors and change status to OCCUPY */
X    /* Change the desireability of the sector so not all the armies go there */
X
X    i = RND() % nhigh;
X    tx = highlist[i].x - ap->pos.x + NPC_VIEW + 1;
X    ty = highlist[i].y - ap->pos.y + NPC_VIEW + 1;
X    x = (*wrapx)(highlist[i].x,highlist[i].y);
X    y = (*wrapy)(highlist[i].x,highlist[i].y);
X    args[1].data.num = ap->id;
X    args[2].data.num = x;
X    args[3].data.num = y;
X    args[4].data.num = legal_moves[tx][ty].mvleft;
X    cmd_amove(np,args);		/* move army to new location */
X    if(good_altitude(&world.map[x][y],np) || is_water(ap)){
X      args[2].data.num = A_OCCUPY;
X      cmd_astat(np,args);
X    }
X    des_array[x][y].final = des_array[x][y].final * opt_army_size /
X			(opt_army_size+ap->n_soldiers);
X  }
X}
X
X/*------------------------------do_npc_redesig()-------------------------------
X	Redesignate sectors that the npc owns.
X-----------------------------------------------------------------------------*/
Xdo_npc_redesig(np)
X     Snation *np;
X{
X  struct pt_list *Pointer;
X  int Loop,x,y;
X 
X  /* Have NPC nation redesignate sectors */
X  
X  Pointer = np->ptlist;
X  for (Loop = 0; Loop < np->n_sects; Loop++) {
X    x = Pointer->pt.x;
X    y = Pointer->pt.y;
X    if (world.map[x][y].n_people > 0 &&
X	world.map[x][y].designation == D_NODESIG) {
X      if ((world.map[x][y].metal + world.map[x][y].jewels > 0)
X	  && ((world.map[x][y].metal > world.map[x][y].soil - 6)
X	  || (world.map[x][y].jewels > world.map[x][y].soil - 6))) {
X	if (world.map[x][y].metal > world.map[x][y].jewels) {
X	  world.map[x][y].designation = D_METAL_MINE;
X	  np->money -= desig_map[D_METAL_MINE].price;
X	} else {
X	  world.map[x][y].designation = D_JEWEL_MINE;
X	  np->money -= desig_map[D_JEWEL_MINE].price;
X	}
X      } else {
X	if (world.map[x][y].soil >= 0) {
X	  world.map[x][y].designation = D_FARM;
X	  np->money -= desig_map[D_FARM].price;
X	}
X      }
X    }
X  Pointer = Pointer->next;
X  }
X}
END_OF_FILE
if test 19296 -ne `wc -c <'npc.c'`; then
    echo shar: \"'npc.c'\" unpacked with wrong size!
fi
# end of 'npc.c'
fi
echo shar: End of archive 21 \(of 28\).
cp /dev/null ark21isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Now execute ./do_cat.sh to build doc files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
