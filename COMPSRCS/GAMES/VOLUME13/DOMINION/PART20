Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i056:  dominion - a multi-player world simulation game, Part20/28
Message-ID: <2459@masterCNA.TEK.COM>
Date: 11 Feb 92 18:26:47 GMT
Sender: news@masterCNA.TEK.COM
Lines: 2228
Approved: billr@saab.CNA.TEK.COM

Submitted-by: rosalia@dirac.physics.sunysb.edu (Mark Galassi)
Posting-number: Volume 13, Issue 56
Archive-name: dominion/Part20
Environment: Unix, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 20 (of 28)."
# Contents:  addnation.c mag_Diana movement.c spells.c
# Wrapped by billr@saab on Tue Feb 11 10:14:56 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'addnation.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'addnation.c'\"
else
echo shar: Extracting \"'addnation.c'\" \(24914 characters\)
sed "s/^X//" >'addnation.c' <<'END_OF_FILE'
X  /* addnation.c -- primitive program to add a nation to the world */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include <signal.h>
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X
X#define INIT_CIV 10000
X#define RADIUS 8		/* minimum distance from other nations */
X#define MAX_TRIES 10000		/* max tries to find a good capital */
X
Xextern Sworld world;
Xextern Suser user;
Xextern struct race_list *races;	/* list of races */
Xextern struct army_type *army_types; /* array of available armies */
Xextern char libdir[];
Xextern int debug;
Xextern int (*wrapx)(), (*wrapy)();
X
Xchar get_nation_mark ();
Xint sigquit();
X
XSdiplo **allocate_diplo();
X
Xmain(argc, argv)
X     int argc;
X     char *argv[];
X{
X  int npcs_get_mail = 0;
X  extern int interrupt();
X  int n;
X  int c;
X  extern char *optarg;
X  extern int optind;
X  char add_fn[255];		/* get NPCs from this file name */
X
X  stdscr = NULL;		/* to know if curses is initialized */
X  add_fn[0] = '\0';
X  strcpy(libdir, DEF_LIBDIR);
X  while ((c = getopt(argc, argv, "md:f:x")) != EOF) {
X    switch (c) {
X    case 'm':			/* make these NPCs get mail */
X      npcs_get_mail = 1;
X      break;
X    case 'x':			/* set debugging mode */
X      debug = 1;
X      break;
X    case 'd':			/* set the LIBDIR path */
X      strcpy(libdir, optarg);
X      break;
X    case 'f':			/* the name of the file with NPCs */
X      strcpy(add_fn, optarg);
X      break;
X    default:
X      break;
X    }
X  }
X  if (chdir(libdir) == -1) {
X    fprintf(stderr,"Error: cannot cd to directory %s\n",libdir);
X    clean_exit();
X    exit();
X  }
X
X  SRND(time((long *) 0L));	/* initialize random number generator */
X
X  read_world(&world, WORLD_FILE);
X  read_races();
X
X  if (!verify_gamemaster()) {
X    printf("Hey, you can't add a nation!\n");
X    clean_exit();
X    exit(1);
X  }
X
X  if (is_master_lock()) {
X    printf("\nThere is a master lock\n");
X    clean_exit();
X    exit(1);
X  }
X  set_master_lock();
X  if (is_any_lock()) {
X    printf("There is a lock;you should make sure the nation is not playing\n");
X    del_master_lock();
X    clean_exit();
X    exit(1);
X  }
X  /* initialize curses if we are adding a
X     nation interactively (i.e. not NPCs)
X   */
X  if (strlen(add_fn) == 0) {
X    initscr();			/* Initialize curses */
X    cbreak();			/* set cbreak mode */
X    noecho();			/* unset echo mode */
X  }
X  noncritical();
X
X  if ((n = find_free_nation(&world)) == -1) {
X    printf("No free nations, sorry.\n");
X    clean_exit();
X    exit(1);
X  }
X
X  if (debug) {
X    printf("First free nation id is %d.\n", n);
X  }
X
X  fflush(stdin);
X
X  if (stdscr) {
X    refresh();
X  }
X
X  /* check if we are adding NPCs from file add_fn[] */
X  if (strlen(add_fn) != 0) {
X      /* MCG Kludge Time */
X    char full_path_fn[255];
X    strcpy(full_path_fn, "misc/");
X    strcat(full_path_fn, add_fn);
X    printf("\nAdding NPC nations\n\n");
X    add_npcs(full_path_fn, npcs_get_mail);
X  } else {			/* else we add a single player */
X    add_player(n);
X  }
X
X  clean_exit();
X  return 0;
X}
X
X  /* inserts a player into the world with id = n */
Xadd_player(n)
X     int n;
X{
X  Snation tmp_nation;			/* as we form the nation */
X  char racemark;
X  char mag_ord[NAMELEN], pass_try1[NAMELEN], pass_try2[NAMELEN];
X
X  clear();
X
X  tmp_nation.id = n;
X
X  echo();
X  mvaddstr(0, 0, "Nation's name: ");
X  refresh();
X/*  getstr(tmp_nation.name); */
X  wget_string(stdscr,tmp_nation.name,NAMELEN);
X
X  while (!unique_name(tmp_nation.name)) {  
X    clear();
X    mvprintw(0, 0, "Sorry, \"%s\" is already taken.", tmp_nation.name);
X    mvaddstr(2, 0, "Enter nation's name: ");
X    refresh();
X/*    getstr(tmp_nation.name); */
X    wget_string(stdscr,tmp_nation.name,NAMELEN);
X  }
X  noecho();
X
X  get_crypt_pass("\nEnter the password for your nation: ", pass_try1, stdscr,
X		 NULL);
X  get_crypt_pass("\nType it once more: ", pass_try2, stdscr, NULL);
X
X
X  /* make sure user knows their pass. */
X  while  (strcmp(pass_try1, pass_try2) != 0){
X    clear();
X    printw("They don't match, try again\n\r");
X    get_crypt_pass("Give nation's password: ", pass_try1, stdscr, NULL);
X    get_crypt_pass("\nPlease type it once more: ", pass_try2, stdscr, NULL);
X  }
X  strcpy(tmp_nation.passwd, pass_try1);
X  echo();
X
X  printw("\n\rGive your leader's name: ");
X  refresh();
X/*   getstr(tmp_nation.leader); */
X  wget_string(stdscr,tmp_nation.leader,NAMELEN);
X  racemark = get_race_mark();
X
X  tmp_nation.mark = get_nation_mark();
X
X  choose_mag_order(mag_ord);
X    /* each magic order brings some advantages.  insert them now */
X  add_special_mag(&tmp_nation, mag_ord);
X
X  clear();
X  refresh();
X
X    /* Set up a new, non-NPC nation */
X  if (setup_new_nation(tmp_nation.name, tmp_nation.passwd, tmp_nation.leader,
X	racemark, tmp_nation.mark, mag_ord, NOT_NPC, 50, 5, 5) < 0) {
X    printw("\n\r  Could not add nation %s\n\r", tmp_nation.name);
X    refresh();
X    noecho();
X  } else {
X    move(0, LINES-1);
X    refresh();
X    endwin();
X    stdscr = NULL;
X    write_world(&world, WORLD_FILE);
X  }
X}
X
X  /* make sure that the guy knows the game master password */
Xverify_gamemaster()
X{
X  char s[NAMELEN], *getpass(), *crypt();
X  
X  get_crypt_pass("Enter game master's password: ", s, NULL, NULL);
X  return !strcmp(s, world.nations[0].passwd);
X}
X
X
Xfind_free_nation(wp)		/* return first free slot, -1 if none */
X     Sworld *wp;
X{
X  int i;
X  for (i = 0; i < NATIONS; ++i) {
X    if (strlen(wp->nations[i].name) == 0) {
X      return i;			/* found a free one! */
X    }
X  }
X  return -1;
X}
X
Xcleanup()
X{
X/*  clear(); */
X  refresh();
X}
X
X  /* cleanup and prepare to exit */
Xclean_exit()
X{
X  del_master_lock();
X  if (stdscr) {
X    refresh();
X    endwin(); /* end curses */
X  }
X}
X
X  /* initial military setup */
X#define INITIAL_SOLDIERS 10*OCCUPYING_SOLDIERS
Xsetup_armies(np)
X     Snation *np;
X{
X  Sarmy army, make_army();
X  int i;
X  char name [NAMELEN];
X
X  load_army_types();
X    /* we make 10 armies of equal size. the first one has special handling. */
X  army = make_army(army_types[0].type, "Cavemen 0", INITIAL_SOLDIERS/10,
X		   A_DEFEND, np->id, np->capital);
X  army.mvpts = basic_move_rate(np);
X  army.mvratio = 100;		/* ration of initial to final move points */
X  army.id = 0;			/* make sure, this is FIRST army! */
X  if (debug) {
X    printf("made a new army: owner=%d,x=%d,y=%d,num=%d", army.owner,
X	   army.pos.x,army.pos.y,army.n_soldiers);
X  }
X  army.next = NULL;
X  np->armies = (Sarmy *) malloc(sizeof(Sarmy));	/* create army list */
X  *(np->armies) = army;
X  /* the sector must also have a list of armies */
X  world.map[army.pos.x][army.pos.y].alist
X    = (struct armyid *) malloc(sizeof(struct armyid));
X  world.map[army.pos.x][army.pos.y].alist->owner = army.owner;
X  world.map[army.pos.x][army.pos.y].alist->id = army.id;
X  world.map[army.pos.x][army.pos.y].alist->next = NULL;
X  for (i = 1; i < 10; ++i) {
X    sprintf(name, "%s", army_types[0].type);
X    army = make_army(army_types[0].type, name, INITIAL_SOLDIERS/10,
X		     A_DEFEND, np->id, np->capital);
X      /* first time around, they move at full rate */
X    army.mvpts = basic_move_rate(np);
X    army.mvratio = 100;
X    army.id = i;
X    army.next = NULL;
X    insert_army_nation(np, &army, i);
X    insert_army_sector(&world.map[army.pos.x][army.pos.y], &army);
X  }
X  np->n_armies = 10;
X    /* figure out bonuses; crude formula for now */
X  np->attack = np->race.strength/4 + np->race.intel/12;
X  np->defense = np->race.strength/4 + np->race.intel/12;
X  np->spy = 0;
X  np->secrecy = 0;
X}
X
X  /* initialize fields in this nation's data structure
X     that are relevant to the economy.
X   */
Xsetup_economy(np)
X     Snation *np;
X{
X  np->taxes = 10;		/* tax rate, % of income */
X  np->charity = 0;		/* money given to the poor */
X  np->money = 100000;		/* initial wealth */
X  np->jewels = 20000;
X  np->metal = 20000;
X  np->food = 100000;
X    /* default values, until user learns how to use her/his budget screen */
X  np->tech_r_d = 30;
X  np->tech_r_d_metal = 40;
X  np->mag_r_d = 30;
X  np->mag_r_d_jewels = 40;
X  np->spy_r_d = 0;
X  np->cur_mag_r_d = 0;
X  np->cur_mag_r_d_jewels = 0;
X  np->cur_tech_r_d = 0;
X  np->cur_tech_r_d_metal = 0;
X  np->cur_spy_r_d = 0;
X}
X
Xget_race_mark()
X{
X  char racemark;
X  int done = 0;
X  int race_counter=0;
X  struct race_list *rlp;	/* to manipulate the list */
X  char tmp_sprintf [70];
X
X  clear ();
X
X  mvaddstr (2, 0, "Races: ");
X  rlp = races;
X  while (rlp != NULL) {
X    sprintf (tmp_sprintf, "(%c) : %s\n", rlp->race.mark, rlp->race.name);
X    mvaddstr (4+race_counter++, 4, tmp_sprintf);
X    rlp = rlp->next;
X  }
X  do {
X    mvaddstr (0, 0, "Pick a race and enter its mark: ");
X    refresh ();
X    racemark = getch();
X    done = 0;
X    rlp = races;
X    while (rlp != NULL) {
X      if (rlp->race.mark == racemark) {
X	done = 1;
X	break;
X      }
X      rlp = rlp->next;
X    }
X  } while (!done);
X  return racemark;
X}
X
Xsetup_race(np,racemark)
X     Snation *np;
X     char racemark;
X{
X  struct race_list *rlp;	/* So we can work with the races list */
X  
X  rlp = races;
X  while(rlp != NULL) {
X    if (rlp->race.mark == racemark) { /* Did we find that race? */
X      np->race = rlp->race;
X      return 1;			/* If we found it, return a 1 */
X    }
X    rlp = rlp->next;
X  }
X  return -1;			/* We didn't find it */
X}
X
Xsetup_skills(np)
X     Snation *np;
X{
X  np->tech_skill = 0;
X  np->mag_skill = 0;
X  
X  /* Nations begin with a certain production and it increases from there */
X  
X  np->farm_skill = np->race.farming;
X  np->mine_skill = np->race.mining;
X
X  np->spell_pts = 0;
X}
X
Xchoose_mag_order(s)
X     char s[];
X{
X  strcpy(s, "");
X  clear ();
X  list_mag_orders();
X
X  do {
X    mvaddstr (0, 0, "Choose one of the listed magical orders: ");
X    clrtoeol ();
X    refresh ();
X    wget_string (stdscr,s,NAMELEN);
X  } while (!is_good_order(s));
X}
X
X  /* sets up the capital and a few outlying sectors; if after
X     MAX_TRIES it does not find a good place, it exits.
X   */
Xsetup_capital(np)
X     Snation *np;
X{
X  int pref, i, j, x, y, distance, tries,
X    remaining_pop = INIT_CIV + RND() % 100, beginning_pop;
X  Ssector *sp;
X  int radius, n_sects;		/* dist. from capital for other sects */
X
X  beginning_pop = remaining_pop;
X  tries = 0;
X  pref = 0;
X  /* a negative capital x-coordinate means we have not found
X     a good location for the capital yet.
X   */
X  x = -1;
X  distance = 7;
X
X  while (x < 0) {
X    distance = max(1, --distance);
X    for (i = 0; i < 10; i++) {
X      do {
X	  /* keep trying random sectors as long
X	     as things aren't good.
X	   */
X	x = RND() % world.xmax;
X	y = RND() % world.ymax;
X	++tries;
X	if (tries >= MAX_TRIES) {
X	  printf("  Cannot find space for capital of nation %s\n", np->name);
X	  return -1;
X	}
X      } while ((world.map[x][y].owner != 0) || !isolated(x, y) ||
X	       (!good_altitude(&world.map[x][y], np)) ||
X	       (world.map[x][y].metal > 0) ||
X	       (world.map[x][y].jewels > 0));  /*see if it's taken!*/
X      if (sect_desire(np, x, y) > pref) {
X	pref = sect_desire(np, x, y);
X	np->capital.x = x;
X	np->capital.y = y;
X      }
X    }
X    for (i = np->capital.x - distance; i <= np->capital.x + distance; i++) {
X      for (j = np->capital.y - distance; j <= np->capital.y + distance; j++) {
X	if (np->race.pref_alt < SEA_LEVEL) { /* under water race */
X	  if (world.map[(*wrapx)(i,j)][(*wrapy)(i,j)].owner != 0 &&
X	      world.map[(*wrapx)(i,j)][(*wrapy)(i,j)].altitude >= SEA_LEVEL) {
X	    x = -1;		/* water race cannot be on land */
X	  }
X	} else {		/* above race */
X	  if (world.map[(*wrapx)(i,j)][(*wrapy)(i,j)].owner != 0 &&
X	      world.map[(*wrapx)(i,j)][(*wrapy)(i,j)].altitude < SEA_LEVEL) {
X	    x = -1;		/* land race canot be underwater */
X	  }
X	}
X      }
X    }
X  }
X  x = np->capital.x;
X  y = np->capital.y;
X  putchar('\n');
X  np->ptlist = NULL;
X  addsector(np, x, y);
X  world.map[x][y].n_people = beginning_pop/2; /* half people in capital */
X  remaining_pop -= beginning_pop/2;
X  world.map[x][y].designation = D_CAPITAL;
X  np->n_sects = 1;
X
X  radius = 1;
X  n_sects = 1;
X  while (n_sects < 9) {		/* must give user 9 sectors */
X    for (i=x-radius; i<=x+radius; i++) {
X      for (j=y-radius; j<=y+radius; j++) {
X	if (i != 0 || j != 0) {	/* skip the capital */
X	  sp = &world.map[wrapx(i,j)][wrapy(i,j)];
X	  if (sp->owner != 0
X	      || (np->race.pref_alt >= SEA_LEVEL && sp->altitude < SEA_LEVEL)
X	      || (np->race.pref_alt < SEA_LEVEL && sp->altitude >= SEA_LEVEL)
X	      || n_sects >= 9) {
X	  } else {
X	    addsector(np, (*wrapx)(i,j), (*wrapy)(i,j));
X	    sp->n_people = beginning_pop/16;
X	    remaining_pop -= beginning_pop/16;
X	    sp->designation = default_desig(sp);
X/*	    printf("rad %d; %d,%d: %d people, remaining_pop=%d (of %d)\n",
X		   radius, i, j, sp->n_people, remaining_pop, beginning_pop);
X*/
X	    ++n_sects;
X	  }
X	}
X      }
X    }
X    ++radius;			/* try bigger and bigger circles */
X  }
X    /* now if any people are left, put them in the capital */
X  world.map[x][y].n_people += remaining_pop;
X/*   printf("Done with nation %s\n", sp->name);*/
X/*  printf("capital has %d people\n", world.map[x][y].n_people); */
X  return 1;
X}
X
X  /* this gives a sector a default designation of
X     D_FARM unless some other resource is present
X   */
Xdefault_desig(sp)
X     Ssector *sp;
X{
X  if (sp->jewels > 0) {
X    if (sp->metal > sp->jewels) {
X      return D_METAL_MINE;
X    } else {
X      return D_JEWEL_MINE;
X    }
X  }
X  if (sp->metal > 0) {
X    return D_METAL_MINE;
X  } else {
X    return D_FARM;
X  }
X}
X
X  /* the workhorse behind addnation */
Xsetup_new_nation(nation_name, nation_pass, leader_name, nation_race,
X		 nation_mark, mag_ord, npc_flag, npcagg, npcexp, npciso)
X     char nation_name[NAMELEN],nation_pass[PASSLEN],leader_name[NAMELEN],
X       mag_ord[NAMELEN], nation_race;
X     Symbol nation_mark;
X     int npc_flag, npcagg, npcexp, npciso;
X{
X  Sdiplo **dm_old, **dm_new;
X  Snation tmp;
X  int n;			/* Free nation ID number */
X  char cmd_str[PATHLEN];
X
X  if ((n = find_free_nation(&world)) == -1) {
X    printf("No free nations, sorry.\n");
X    return -1;
X  }
X
X  tmp.id = n;
X  if (!unique_name(nation_name)) { /* Should reject identical names */
X    printf("Already have a nation called %s.\n", nation_name);
X    return -1;
X  }
X  strcpy(tmp.name, nation_name);
X  strcpy(tmp.passwd, nation_pass);
X  strcpy(tmp.leader, leader_name);
X  strcpy(tmp.mag_order, mag_ord);
X
X  setup_race(&tmp, nation_race);
X
X  printf("Doing nation %s\n", nation_name);
X
X  if (!free_nation_mark(&world, nation_mark)) {
X    printf("  Already have a nation using %c as their nation mark.\n",
X	   nation_mark);	/* Should reject identical nation marks */
X    return(-1);
X  }
X  tmp.mark = nation_mark;
X
X  setup_economy(&tmp);
X  setup_skills(&tmp);
X
X  tmp.npc_flag = npc_flag;
X  tmp.npc_agg = npcagg;
X  tmp.npc_iso = npciso;
X  tmp.npc_exp = npcexp;
X
X  if (setup_capital(&tmp) < 0) { /* Adds a capital and land */
X    /* if there is no good place for the nation */
X    return -1;
X  }
X  setup_armies(&tmp);		/* must be done after capital */
X
X  world.nations[n] = tmp;	/* OK, now add this nation */
X  ++world.n_nations;
X
X    /* now update the diplo file, so it is bigger */
X  dm_old = allocate_diplo(world.n_nations-1);
X  dm_new = allocate_diplo(world.n_nations);
X  read_in_diplo(dm_old, world.n_nations-1);
X  increase_diplo(dm_old, dm_new, world.n_nations-1, &tmp);
X  dump_diplo(NULL, dm_new, world.n_nations);
X    /* also make a copy of the initial diplomacy file */
X  sprintf(cmd_str, "cp %s %s\n", DIPLO_FILE, INIT_DIPLO_FILE);
X  system(cmd_str);
X  free_diplo(dm_old, world.n_nations-1);
X  free_diplo(dm_new, world.n_nations);
X
X  return 1;
X}
X
Xadd_npcs(npc_fn, npcs_get_mail)
X     char * npc_fn;
X     int npcs_get_mail;
X{
X  FILE *fp;
X  char s[110], racemark, nationmark;
X  char nation_name[NAMELEN], leader_name[NAMELEN], mag_order[NAMELEN];
X  int n_npcs, npc_agg, npc_exp, npc_iso;
X  int i;
X
X  if ((fp = fopen(npc_fn, "r")) == NULL) {
X    printf("Cannot open npc file.\n");
X    return;
X  }
X
X  fgets(s, 100, fp);
X  while (s[0] == '#') {		/* Ignoring the comments */
X    fgets(s, 100, fp);
X  }
X  sscanf(s, "%d", &n_npcs);
X
X  for (i = 0; i < n_npcs; i++) {
X    fgets(s, 100, fp);
X    s[strlen(s)-1] = '\0';
X    if (s[0] != '#') {
X      sscanf(s, "%s : %s : %c : %c : %s : %d : %d : %d", nation_name,
X	     leader_name, &racemark, &nationmark, mag_order,
X	     &npc_agg, &npc_exp, &npc_iso);
X      if (debug) {
X	printf("  Nation: %s\n  Leader: %s\nRacemark: %c\n Ntnmark: %c\n",
X	       nation_name, leader_name, racemark, nationmark);
X	printf("Mag_Ordr: %s\nAgressiv: %d\n  Expand: %d\n Isolate: %d\n\n",
X	       mag_order, npc_agg, npc_exp, npc_iso);
X      }
X      if (setup_new_nation(nation_name, world.nations[0].passwd, leader_name,
X		       racemark, nationmark, mag_order,
X		       npcs_get_mail ? NPC_MAIL : NPC_NOMAIL,
X		       npc_agg, npc_exp, npc_iso) < 0) {
X	/* if we cannot set up this NPC for whatever reason */
X	printf("    Did NOT set up nation %s\n\n", nation_name);
X	continue;		/* go on to the next NPC */
X      }
X    }
X  }
X  fclose(fp);
X  printf("\n");
X  write_world(&world, WORLD_FILE);
X}
X
X  /* critical() for the update/make/add is different from the game */
Xcritical()
X{
X  signal(SIGINT, SIG_IGN);
X  signal(SIGQUIT, SIG_IGN);
X}
Xnoncritical()
X{
X  signal(SIGINT, sigquit);
X  signal(SIGQUIT, sigquit);
X}
X
X
Xint sigquit ()
X{
X  if (stdscr) {
X    standout();
X    mvprintw(0, 65, "Quitting...");
X    standend();
X    refresh();
X  } else {
X    printf("\nQuitting...\n");
X  }
X  clean_exit();
X  exit(1);
X}
X
X/* Lifted from misc.c and maglib.c */
Xshow_race_w(rp)
X     Srace *rp;
X{
X}
X
Xlist_mag_orders()
X{
X  int n_orders, i;
X  FILE *fp;
X  char line[200];
X  char **order_list;
X  char mag_counter=0;
X
X  if ((fp = fopen(MAG_ORDERS, "r")) == NULL) {
X    printw("\ncannot find file %s.  this is bad.\n\r", MAG_ORDERS);
X    clean_exit();
X    exit(1);
X  }
X  while (fgets(line, 200, fp) != NULL) {
X    if (line[0] != '#') {
X      sscanf(line, "%d", &n_orders);
X      break;			/* we got the number of orders */
X    }
X  }
X  order_list = (char **) malloc(n_orders*sizeof(char *));
X
X  mvaddstr (2, 0, "Magical orders: ");
X
X  for (i = 0; i < n_orders; ) {
X    fgets(line, NAMELEN, fp);
X    if (line[0] != '#') {
X      mvprintw(3 + mag_counter++, 4, "%s", line);
X      order_list[i] = (char *) malloc(NAMELEN*sizeof(char));
X      strcpy(order_list[i], line);
X      ++i;
X    }
X  }
X
X  fclose(fp);
X}
X
X  /* prompt a user for a nation mark */
X#define valid_nation_mark(c) (strchr(valid_mark_str, c))
Xchar get_nation_mark()
X{
X  int attempt_counter=0;
X  char mark;
X  char valid_mark_str[128];
X
X  form_valid_mark_str(valid_mark_str);
X
X  clear();
X
X  mvaddstr(0, 0, "Which nation mark do you want? ");
X  refresh();
X
X  mark = getch();
X  while (!free_nation_mark(&world, mark) || !valid_nation_mark(mark)) {
X    if (attempt_counter > 15) {
X      attempt_counter = 15;
X    }
X    if (!free_nation_mark(&world, mark)) {
X      mvprintw(2 + attempt_counter++, 0,
X		"Sorry, the nation mark %c is taken already.", mark);
X    } else if (!valid_nation_mark(mark)) {
X      mvprintw(2 + attempt_counter++, 0,
X		"Sorry, the nation mark %c is not valid.", mark);
X      clrtoeol();
X      mvprintw(2 + attempt_counter++, 0, "Valid nation marks are: ");
X      mvprintw(2 + attempt_counter++, 0, "%s", valid_mark_str);
X      ++attempt_counter;
X    }
X    mvaddstr(0, 0, "Which nation mark do you want? ");
X    refresh();
X    mark = getch();
X  }
X  return mark;
X
X#ifdef OLD
X  if (!free_nation_mark(&world, mark))  { /* see if it's already used */
X    do {
X      if (attempt_counter > 20) attempt_counter=20;
X      mvprintw (2 + attempt_counter++, 0,
X                "Sorry, the nation mark %c is taken already.", mark);
X      mvprintw (0, 0, "Which nation mark do you want: ");
X      refresh ();
X      mark = getch ();
X    } while (!free_nation_mark(&world, mark));
X  }
X
X  /* now check if it is a nation mark that is not valid
X     (like a space, or a dash or a dot or twiddle)
X   */
X  if (!valid_nation_mark(mark))  {
X    do {
X      if (attempt_counter > 20) {
X	attempt_counter=20;
X      }
X      mvprintw(2 + attempt_counter++, 0,
X	       "Sorry, the nation mark %c is not valid.", mark);
X      mvprintw(2 + attempt_counter++, 0, "Valid nation marks are: ");
X      addstr(valid_mark_str);
X      mvprintw(0, 0, "Which nation mark do you want: ");
X      refresh();
X      mark = getch();
X    } while (!free_nation_mark(&world, mark));
X  }
X  return mark;
X#endif /* OLD */
X}
X
X  /* returns true if there is no owned sector too near this one */
Xisolated(x, y)
X{
X  int i, j;
X
X  for (i = x-RADIUS; i <= x+RADIUS; ++i) {
X    for (j = y-RADIUS; j <= y+RADIUS; ++j) {
X        /* see if one of these nearby sectors is owned */
X      if (world.map[(*wrapx)(i, j)][(*wrapy)(i, j)].owner != 0) {
X	return 0;		/* oops, we are *not* isolated */
X      }
X    }
X  }
X  return 1;
X}
X
X  /* put some stuff into a nation's exec file to get them started with
X     the privilege of their magic order.
X   */
Xadd_special_mag(np, mag_ord)
X     Snation *np;
X     char mag_ord[];
X{
X  char fname[255], line[2*EXECLEN];
X  FILE *magfp, *execfp;
X  int done = 0;
X
X  strcpy(fname, MAG_PREFIX);
X  strcat(fname, mag_ord);
X  if ((magfp = fopen(fname, "r")) == NULL) {
X    clean_exit();
X    exit(1);
X  }
X  sprintf(fname, "exec/exec%d", np->id);
X  if ((execfp = fopen(fname, "a")) == NULL) {
X    clean_exit();
X    exit(1);
X  }
X  while (!done) {
X    if (fgets(line, EXECLEN, magfp) == NULL) {
X      fclose(magfp);
X      fclose(execfp);
X      return;
X    }
X    if (line[0] != '#') {	/* avoid comments */
X      if (strncmp(line, "EXEC:", strlen("EXEC:")) == 0) {
X/*	printf("found an exec line %s\n", line);
X	refresh();
X	getch();
X	getch();
X*/
X	fprintf(execfp, "%s", line+strlen("EXEC:"));
X      }
X    }
X  }
X}
X
X/* Please note that this is the same routine as in cur_stuff.c but linking
X   that into this code would require a plethora of other object files to 
X   successfully compile.
X*/
X  /* gets a string str of max length len */
Xwget_string (w, rets, len)
X     WINDOW * w;
X     char * rets;
X     int len;
X{
X  char s [80];
X  int pos, done;
X  int x, y, i;
X  int oldpos;		/* Used for ^W */
X  noecho ();
X
X  if (w == NULL) {
X    w = stdscr;
X  }
X
X  pos = 0;
X  done = 0;
X
X  getyx (w, y, x);
X  wrefresh (w);
X
X  while (!done) {
X    s [pos] = wgetch (stdscr);
X    switch (s[pos]) {
X    case '\n':
X    case '\r':
X      s [pos] = '\0';
X      done = 1;
X      break;
X    case '\b':
X    case DEL:
X      if (pos > 0) {
X	pos--;
X	s[pos] = '\0';
X	wmove (w, y, x + pos);
X	waddch (w, ' ');
X	wmove (w, y, x + pos);
X      }
X      break;
X    case CTL('U'):
X      wmove (w, y, x);
X      for (i=0; i < pos; i++) {
X	waddch (w, ' ');
X      }
X      wmove (w, y, x);
X      pos = 0;
X      s [pos] = '\0';
X      break;
X    case CTL('W'):
X      oldpos = pos;
X      while (pos != 0 && s[pos] == ' ') {
X	pos --;
X      }
X      if (pos) {
X	pos --;
X      }
X      while (pos != 0 && s[pos] != ' ') {
X	pos --;
X      }
X      wmove (w, y, x + pos);
X      while (oldpos != pos) {
X	oldpos--;
X	waddch (w, ' ');
X      }      
X      wmove (w, y, x + pos);
X      break;
X    default:
X      waddch (w, s [pos]);
X      pos++;
X      break;
X    }
X    wrefresh (w);
X  }
X
X  if (pos == 0) {
X    return 0;
X  }
X  s [len-1] = '\0';
X  strcpy (rets, s); 
X  return 1;
X}
X
X  /* return true if sector (x, y) has at least n connected sectors
X     on land (or in water if (x, y) is in water) surrounding it.
X   */
Xhas_connected_mass(x, y, n)
X     int x, y, n;
X{
X  Ssector *sp = &world.map[x][y];
X  int n_found = 1, prev_n_found = 1; /* count (x, y) */
X  int i, j;
X
X  /* go about (x, y) one circle at a time.  after each circle,
X     see if any new connected sectors were found.  if none were,
X     and n_found < n, then NAH... doesn't work!!  put it off for now.
X   */
X}
X
X  /* makes a list of valid nation marks in the given string;
X     a mark is valid if it doesn't make a [d] [n] (nation mark
X     display) confusing.  For example, <space>, '.' and so on
X     would confuse.
X   */
Xform_valid_mark_str(mark_str)
X     char mark_str[];
X{
X  char tmp_str[128];
X
X  strcpy(tmp_str, "");
X  /* run through the ascii table (only those chars that are printable) */
X  strcat(tmp_str, "!\"#$%&'()*+,");
X  /* skip '-' and '.' */
X  strcat(tmp_str, "/0123456789:;<=>"); /* now skip '?' */
X  strcat(tmp_str, "@ABCDEFGHIJKLMNOPQRSTUVWXYZ");
X  strcat(tmp_str, "[\]^_`abcdefghijklmnopqrstuvwxyz{|}");
X  strcpy(mark_str, tmp_str);
X}
END_OF_FILE
if test 24914 -ne `wc -c <'addnation.c'`; then
    echo shar: \"'addnation.c'\" unpacked with wrong size!
fi
# end of 'addnation.c'
fi
if test -f 'mag_Diana' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mag_Diana'\"
else
echo shar: Extracting \"'mag_Diana'\" \(686 characters\)
sed "s/^X//" >'mag_Diana' <<'END_OF_FILE'
X# this file describes magic powers available to magical order of Diana,
X# which is mostly concerned with animals and hunting.
X#
X# the format is:
X# name level cost
X# begin
X#   series of exec lines
X# end
X#
X# where `level' is the magical skill level at which you get the power,
X# and `cost' is the cost in spell points to use the power.
X#
XEXEC:NEW_ARMY_TYPE:Hunters
X# terraform 100 20
Xsummon_wolf 90 1
Xsummon_swarm 200 3
Xsummon_mole 200 3
Xsummon_snake 200 3
Xsummon_shark 300 3
Xsummon_hawk 500 5
Xsummon_bear 800 5
Xsummon_lion 900 6
Xsummon_terrasque 2000 13
X#
Xhide_army 200 1 2
Xhide_sector 250 2 8
Xmag_bonus 300 1 2
Xfly_army 400 2 2
Xwater_walk 400 2 2
Xcaltitude 800 8 6
X#
Xfertility 1000 4 6
END_OF_FILE
if test 686 -ne `wc -c <'mag_Diana'`; then
    echo shar: \"'mag_Diana'\" unpacked with wrong size!
fi
# end of 'mag_Diana'
fi
if test -f 'movement.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'movement.c'\"
else
echo shar: Extracting \"'movement.c'\" \(6808 characters\)
sed "s/^X//" >'movement.c' <<'END_OF_FILE'
X  /* movement.c - routines that affect movement and move costs */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X/* get_move_cost(np,sp) - calculates a sector's move cost for a nation    */
X/* get_army_move_cost(np,ap,sp) - calculates a sector's move cost
X   for a given army                                                       */
X/* good_altitude(sp,np) - TRUE if nation is compatible with sect. alt.    */
X/* good_army_altitude(np,sp,ap) - TRUE if army is compatible with sect. alt. */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X#include <stdio.h>
X
X#define TOO_MUCH_MOVE_COST 1000	/* basically impenetrable */
X
X  /* returns the move cost for a given army over a given sector
X     if ap is NULL we should consider giving a "generic" move
X     cost for that sector.
X   */
Xget_army_move_cost(np, sp, ap)
X     Snation *np;
X     Ssector *sp;
X     Sarmy *ap;
X{
X  int cost = 1;
X
X  if (has_impenetrable(sp)) {
X    return TOO_MUCH_MOVE_COST;
X  }
X  cost += alt_mc(np, sp, ap);
X  cost += climate_mc(np, sp, ap);
X  cost += terrain_mc(np, sp, ap);
X  cost += patrol_mc(np, sp, ap);
X  cost += roads_mc(np, sp, ap);
X  cost += diplo_mc(np, sp, ap);
X  return max(1, cost);		/* can't be negative */
X}
X
X  /* generic move cost for a given nation on a given
X     sector.  this is displayed in the sector window,
X     but can be quite different from the move
X     cost for an army with special flags. this value
X     is the move cost for a basic army type, such
X     as "Infantry".
X   */
Xget_generic_move_cost(np, sp)
X     Snation *np;
X     Ssector *sp;
X{
X  int cost = 1;
X
X  if (has_impenetrable(sp)) {
X    return 100;
X  }
X  cost += alt_mc(np, sp, NULL);
X  cost += climate_mc(np, sp, NULL);
X  cost += terrain_mc(np, sp, NULL);
X  cost += patrol_mc(np, sp, NULL);
X  cost += roads_mc(np, sp, NULL);
X  cost += diplo_mc(np, sp, NULL);
X  return max(1, cost);		/* can't be negative */
X}
X
X  /* here follow a bunch of routines that give the
X     partial move cost for a given army on a given
X     sector, due to altitude, climate, diplomacy,
X     patrols, and so on...  if the army pointer
X     is NULL, then a "generic" value is returned
X     which does not account for special army flags
X   */
X  /* this macro does the real work */
X#define alt_cost(pref_alt, sp) (abs(pref_alt - sp->altitude)/2)
X
Xalt_mc(np, sp, ap)
X     Snation *np;
X     Ssector *sp;
X     Sarmy *ap;
X{
X  int virt_pref_alt = np->race.pref_alt; /* virtual preferred altitude */
X
X  if (ap == NULL) {		/* generic value */
X    return alt_cost(virt_pref_alt, sp);
X  }
X    /* if ap is not null, we examine special army properties */
X  if (is_flight(ap)) {		/* flying armies ignore altitude */
X    return 0;
X  }
X
X    /* see if army can make it into that sector */
X  if (!good_army_altitude(np, sp, ap)) {
X    return TOO_MUCH_MOVE_COST;
X  }
X  if (np->race.pref_alt >= SEA_LEVEL && sp->altitude < SEA_LEVEL
X      && is_water(ap)) {	/* water armies are adapted to shallows */
X    virt_pref_alt = SHALLOWS;
X  }
X  if (np->race.pref_alt < SEA_LEVEL && sp->altitude >= SEA_LEVEL
X      && is_land(ap)) {		/* land armies are adapted to lowlands */
X    virt_pref_alt = LOWLANDS;
X  }
X
X  return alt_cost(virt_pref_alt, sp);
X}
X
Xclimate_mc(np, sp, ap)
X     Snation *np;
X     Ssector *sp;
X     Sarmy *ap;
X{
X  int cost = 0;
X
X  cost += abs(np->race.pref_climate - sp->climate)/3;
X  return cost;
X}
X
Xterrain_mc(np, sp, ap)
X     Snation *np;
X     Ssector *sp;
X     Sarmy *ap;
X{
X  int cost = 0;
X
X  cost += abs(np->race.pref_terrain - sp->terrain)/2;
X  return cost;
X}
X
Xpatrol_mc(np, sp, ap)
X     Snation *np;
X     Ssector *sp;
X     Sarmy *ap;
X{
X  int cost = 0;
X
X  if (are_patrols(np, ap, sp)) {
X    cost += 5;
X  }
X  return cost;
X}
X
Xroads_mc(np, sp, ap)
X     Snation *np;
X     Ssector *sp;
X     Sarmy *ap;
X{
X  int cost = 0;
X
X  cost -= sp->roads;
X  return cost;
X}
X
Xdiplo_mc(np, sp, ap)
X     Snation *np;
X     Ssector *sp;
X     Sarmy *ap;
X{
X  int cost = 0;
X
X  if (ap && is_flight(ap)) {	/* flying armies ignore diplomacy */
X    return cost;
X  }
X    /* here the move cost goes up if we are not buddy-buddy with the owner */
X  if (sp->owner != np->id) {
X    if (sp->owner == 0) {
X      cost += 2;
X    } else if (are_allied(np->id, sp->owner)) {
X      cost += 1;
X    } else {
X      cost += 5;		/* non-allied land: mucho move cost */
X    }
X  }
X  return cost;
X}
X
X
X  /* this takes care of whether a given race can
X     move to a given sector from the altitude point of view
X   */
Xgood_altitude(sp, np)
X     Ssector *sp;
X     Snation *np;
X{
X  if (sp->altitude >= SEA_LEVEL) { /* if above water */
X    return (np->race.pref_alt >= SEA_LEVEL || has_bubble(sp));
X  }
X  return (np->race.pref_alt < SEA_LEVEL || has_bubble(sp)); /* underwater */
X}
X  /* this takes care of whether a given army of a given race can
X     move to a given sector from the altitude point of view
X   */
Xgood_army_altitude(np, sp, ap)
X     Snation *np;
X     Ssector *sp;
X     Sarmy *ap;
X{
X  if (has_bubble(sp)) {
X    return 1;
X  }
X  if (is_water(ap) && is_land(ap)) {
X    return 1;
X  }
X  if (is_in_transport(ap)) {
X    return 1;			/* carried by someone else */
X  }
X    /* first look at the case where we are above water */
X  if (sp->altitude >= SEA_LEVEL) {
X    if (np->race.pref_alt >= SEA_LEVEL) {
X        /* water armies can only be in water (for land race) */
X      if (is_water(ap) && !is_coastal_sect(np, sp, ap)) {
X	return 0;
X      }
X      return 1;			/* it's OK: land army on land. */
X    }
X      /* otherwise we are a water race on land */
X    if (is_land(ap)) {
X      return 1;
X    }
X    if (is_water(ap) && is_coastal_sect(np, sp, ap)) {
X      return 1;			/* water army can stay on coast */
X    }
X    return 0;
X  }
X    /* now the case where we are an underwater sector */
X  if (np->race.pref_alt >= SEA_LEVEL) { /* land race under water */
X    if (is_water(ap)) {
X      return 1;
X    }
X    return 0;
X  }
X    /* now the case of a water race under water */
X  if (is_land(ap) && !is_coastal_sect(np, sp, ap)) {
X    return 0;
X  }
X  return 1;
X
X
X/*  return (np->race.pref_alt < SEA_LEVEL || has_bubble(sp)); /* underwater */
X}
END_OF_FILE
if test 6808 -ne `wc -c <'movement.c'`; then
    echo shar: \"'movement.c'\" unpacked with wrong size!
fi
# end of 'movement.c'
fi
if test -f 'spells.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spells.c'\"
else
echo shar: Extracting \"'spells.c'\" \(24702 characters\)
sed "s/^X//" >'spells.c' <<'END_OF_FILE'
X  /* spells.c -- the spells are coded here */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X
X#include <stdio.h>
X
X  /* how many new move points the haste spall gives you */
X#define HASTE_POINTS 8
X
Xextern Sworld world;
Xextern Sh_spell *hanging_spells;
Xextern Suser user;
X
X  /* the spell_structures[] array stores the spell names
X     together with the function pointers that execute them.
X   */
Xint spell_caltitude(), spell_fertility(), spell_hide_army(),
X  spell_fly_army(), spell_vampire_army(), spell_burrow_army(),
X  spell_haste_army(), spell_water_walk(),
X  spell_mag_bonus(), spell_merge(), spell_cmetal(), spell_cjewels(),
X  spell_fireburst(), spell_inferno(), spell_hide_sector(), spell_castle(),
X  spell_sacrifice();
X
Xstruct spell_struct {  char name[NAMELEN];  int (*func)(); };
X
Xstatic struct spell_struct spell_structures[] = {
X  {"caltitude", spell_caltitude}, {"fertility", spell_fertility},
X  {"hide_army", spell_hide_army}, {"fly_army", spell_fly_army},
X  {"vampire_army", spell_vampire_army}, {"burrow_army", spell_burrow_army},
X  {"water_walk", spell_water_walk}, {"haste_army", spell_haste_army},
X  {"mag_bonus", spell_mag_bonus}, {"merge", spell_merge},
X  {"cmetal", spell_cmetal},
X  {"cjewels", spell_cjewels}, {"fireburst", spell_fireburst},
X  {"inferno", spell_inferno}, {"hide_sector", spell_hide_sector},
X  {"castle", spell_castle,}, {"sacrifice", spell_sacrifice}
X};
X
X  /* this actually executes a spell */
Xexec_spell(spellp, w)
X     Sspell *spellp;
X     WINDOW *w;
X{
X  int cost = 0, i;
X  Sh_spell h_spell;
X  struct argument exec_args[N_EXEC_ARGS];
X
X  for (i = 0; i < sizeof(spell_structures)/sizeof(struct spell_struct); ++i) {
X    if (strcmp(spellp->name, spell_structures[i].name) == 0) {
X        /* each spell function returns the cost of casting */
X      cost = spell_structures[i].func(&user, w, spellp, &h_spell);
X      if (cost > 0) {		/* only if there is a real cost */
X	user.np->spell_pts -= cost;
X	cspell_pts(user.np, -cost);
X	  /* add the spell to the list of hanging spells */
X	add_h_spell(&user.h_spells, &h_spell);
X	add_h_spell(&hanging_spells, &h_spell);
X	  /* execute the spell */
X	for (i = 0; i < h_spell.n_lines; ++i) {
X	  if (i % 2 == 0) {
X	    parse_exec_line(h_spell.lines[i], exec_args);
X	    run_exec_line(user.np, exec_args);
X	  }
X	}
X	  /* should put this in a more efficient place */
X	write_h_spells();
X      }
X      return cost;		/* we found our spell, now return */
X    }
X  }
X  return cost;
X}
X
X  /* terraforming spells */
Xint spell_caltitude(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  Ssector *sp = &world.map[up->cursor.x][up->cursor.y];
X  int cost, change = 0;
X  char s[EXECLEN];
X
X  if (w) {
X    mvwprintw(w, 4, 1,
X	 "Cost %d spell points.  Do you wish to [+]raise or [-]lower sector? ",
X	 spellp->cost);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Costs %d; [+] or [-]? ", spellp->cost);
X    statline(s, "cast_spell");
X    move(LINES-1, strlen(s));
X  }
X  cost =  spellp->cost;
X  switch (getch()) {
X  case '+':
X    change = 1;
X    break;
X  case '-':
X    change = -1;
X    break;
X  default:
X    break;
X  }
X    /* only apply the spell if the new altitude is good */
X  if (sp->altitude+change > MOUNTAIN_PEAK ||  sp->altitude+change < TRENCH) {
X    return 0;
X  }
X    /* prepare the h_spell struct, and then insert the exec lines */
X  prepare_h_spell(h_spellp, spellp->name, up->id, spellp->duration, 2);
X  sprintf(h_spellp->lines[0], "CALTITUDE_SECTOR:%d:%d:%d\n",
X	  sp->loc.x, sp->loc.y, change);
X  sprintf(h_spellp->lines[1], "CALTITUDE_SECTOR:%d:%d:%d\n",
X	  sp->loc.x, sp->loc.y, -change);
X  return cost;
X}
X
Xint spell_fertility(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  Ssector *sp = &world.map[up->cursor.x][up->cursor.y];
X  int cost, change = 0;
X  char s[EXECLEN];
X
X  if (w) {
X    mvwprintw(w, 4, 1,
X     "Cost %d spell points.  Do you wish to [+]increase or [-]decrease soil? ",
X     spellp->cost);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Costs %d; [+] or [-]? ", spellp->cost);
X    statline(s, "cast_spell");
X    move(LINES-1, strlen(s));
X  }
X  cost =  spellp->cost;
X  switch (getch()) {
X  case '+':
X    change = 1;
X    break;
X  case '-':
X    change = -1;
X    break;
X  default:
X    break;
X  }
X
X    /* prepare the h_spell struct, and then insert the exec lines */
X  prepare_h_spell(h_spellp, spellp->name, up->id, spellp->duration, 2);
X  sprintf(h_spellp->lines[0], "CSOIL_SECTOR:%d:%d:%d\n",
X	  sp->loc.x, sp->loc.y, change);
X  sprintf(h_spellp->lines[1], "CSOIL_SECTOR:%d:%d:%d\n",
X	  sp->loc.x, sp->loc.y, -change);
X  return cost;
X}
X
Xint spell_cmetal(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  Ssector *sp = &world.map[up->cursor.x][up->cursor.y];
X  int cost, change = 0;
X  char s[EXECLEN];
X
X  if (w) {
X    mvwprintw(w, 4, 1,
X    "Cost %d spell points.  Do you wish to [+]increase or [-]decrease metal? ",
X    spellp->cost);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Costs %d; [+] or [-]? ", spellp->cost);
X    statline(s, "cast_spell");
X    move(LINES-1, strlen(s));
X  }
X  cost =  spellp->cost;
X  switch (getch()) {
X  case '+':
X    change = 1;
X    break;
X  case '-':
X    change = -1;
X    break;
X  default:
X    break;
X  }
X
X    /* prepare the h_spell struct, and then insert the exec lines */
X  prepare_h_spell(h_spellp, spellp->name, up->id, spellp->duration, 2);
X  sprintf(h_spellp->lines[0], "CMETAL_SECTOR:%d:%d:%d\n",
X	  sp->loc.x, sp->loc.y, change);
X  sprintf(h_spellp->lines[1], "CMETAL_SECTOR:%d:%d:%d\n",
X	  sp->loc.x, sp->loc.y, -change);
X  return cost;
X}
X
Xint spell_cjewels(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  Ssector *sp = &world.map[up->cursor.x][up->cursor.y];
X  int cost, change = 0;
X  char s[EXECLEN];
X
X
X  if (w) {
X    mvwprintw(w, 4, 1,
X   "Cost %d spell points.  Do you wish to [+]increase or [-]decrease jewels? ",
X   spellp->cost);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Costs %d; [+] or [-]? ", spellp->cost);
X    statline(s, "cast_spell");
X    move(LINES-1, strlen(s));
X  }
X  cost =  spellp->cost;
X  switch (getch()) {
X  case '+':
X    change = 1;
X    break;
X  case '-':
X    change = -1;
X    break;
X  default:
X    break;
X  }
X
X    /* prepare the h_spell struct, and then insert the exec lines */
X  prepare_h_spell(h_spellp, spellp->name, up->id, spellp->duration, 2);
X  sprintf(h_spellp->lines[0], "CJEWELS_SECTOR:%d:%d:%d\n",
X	  sp->loc.x, sp->loc.y, change);
X  sprintf(h_spellp->lines[1], "CJEWELS_SECTOR:%d:%d:%d\n",
X	  sp->loc.x, sp->loc.y, -change);
X  return cost;
X}
X
X  /* this really messes up a sector */
Xint spell_fireburst(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  Ssector *sp = &world.map[up->cursor.x][up->cursor.y];
X  int cost = 0, change = 0;
X  char c;
X  char s[EXECLEN];
X
X  if (w) {
X    mvwprintw(w, 4, 1, "Cost %d spell points.  Go ahead? ", spellp->cost);
X    wclrtoeol(w);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Costs %d; go ahead? ", spellp->cost);
X    statline_prompt(s, spellp->name);
X  }
X  if ((c = getch()) == 'y' || c == 'Y') {
X      /* prepare the h_spell struct, and then insert the exec lines */
X    cost =  spellp->cost;
X    prepare_h_spell(h_spellp, spellp->name, up->id, spellp->duration, 6);
X    sprintf(h_spellp->lines[0], "CSOIL_SECTOR:%d:%d:%d\n",
X	    sp->loc.x, sp->loc.y, -sp->soil);
X    sprintf(h_spellp->lines[1], "CSOIL_SECTOR:%d:%d:%d\n",
X	    sp->loc.x, sp->loc.y, sp->soil);
X    sprintf(h_spellp->lines[2], "DESIG_SECTOR:%d:%d:%d\n", sp->loc.x,
X	    sp->loc.y, sp->designation == D_CAPITAL ? D_CAPITAL : D_NODESIG);
X    sprintf(h_spellp->lines[3], "DESIG_SECTOR:%d:%d:%d\n",
X	    sp->loc.x, sp->loc.y, sp->designation);
X    sprintf(h_spellp->lines[4], "CPEOPLE_SECTOR:%d:%d:%d\n",
X	    sp->loc.x, sp->loc.y, -sp->n_people/3);
X    sprintf(h_spellp->lines[5], "CPEOPLE_SECTOR:%d:%d:%d\n",
X	    sp->loc.x, sp->loc.y, sp->n_people/3);
X    user.just_moved = 1;
X  }
X  return cost;
X}
X  /* makes a sector completely inaccessible */
Xint spell_inferno(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  Ssector *sp = &world.map[up->cursor.x][up->cursor.y];
X  int cost = 0, change = 0;
X  char c;
X  char s[EXECLEN];
X
X    /* you can only cast inferno on your own sectors */
X  if (sp->owner != up->id) {
X    return -1;
X  }
X  if (w) {
X    mvwprintw(w, 4, 1, "Cost %d spell points.  Go ahead? ", spellp->cost);
X    wclrtoeol(w);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Costs %d; go ahead? ", spellp->cost);
X    statline_prompt(s, spellp->name);
X  }
X  if ((c = getch()) == 'y' || c == 'Y') {
X      /* prepare the h_spell struct, and then insert the exec lines */
X    cost =  spellp->cost;
X    prepare_h_spell(h_spellp, spellp->name, up->id, spellp->duration, 4);
X    sprintf(h_spellp->lines[2], "DESIG_SECTOR:%d:%d:%d\n", sp->loc.x,
X	    sp->loc.y, sp->designation == D_CAPITAL ? D_CAPITAL : D_NODESIG);
X    sprintf(h_spellp->lines[3], "DESIG_SECTOR:%d:%d:%d\n", sp->loc.x,
X	    sp->loc.y, sp->designation == D_CAPITAL ? D_CAPITAL : D_NODESIG);
X    sprintf(h_spellp->lines[0], "FLAG_SET_SECTOR:%d:%d:%d\n",
X	    sp->loc.x, sp->loc.y, SF_IMPENETRABLE);
X    sprintf(h_spellp->lines[1], "FLAG_CLEAR_SECTOR:%d:%d:%d\n",
X	  sp->loc.x, sp->loc.y, SF_IMPENETRABLE);
X      /* also:  kill all the people, once and permanently */
X    cpeople_sector(sp, -sp->n_people);
X    sp->n_people = 0;
X    user.just_moved = 1;
X  }
X  return cost;
X}
X
X  /* these spells set various army flags */
Xint spell_hide_army(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  int id, cost;			/* army id and cost of casting */
X  Sarmy *ap, *get_army();
X  char s[EXECLEN];
X
X  if (w) {
X    mvwprintw(w, 4, 1,
X      "Cost: %d spell pts./100 sold.  Which army do you want to hide? ",
X      spellp->cost);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Cost %d pts/100 men; which army? ", spellp->cost);
X    statline_prompt(s, "fly_army");
X  }
X  if ( (wget_number(w, &id) <= 0) ||
X       ((ap = get_army(up->np, id)) == NULL) ||
X       (ap->pos.x != up->cursor.x) || (ap->pos.y != up->cursor.y) ) {
X    return -1;
X  }
X  cost = (spellp->cost * ap->n_soldiers + 99)/100;
X  if (cost > up->np->spell_pts) {
X    return -1;
X  }
X  if (w) {
X    wmove(w, 4, 1);
X    wclrtoeol(w);
X  }
X    /* prepare the h_spell struct, and then insert the exec lines */
X  prepare_h_spell(h_spellp, spellp->name, up->id, spellp->duration, 2);
X  sprintf(h_spellp->lines[0], "AFLAG_SET:%d:%d\n",
X	  ap->id, AF_HIDDEN);
X  sprintf(h_spellp->lines[1], "AFLAG_CLEAR:%d:%d\n",
X	  ap->id, AF_HIDDEN);
X  return cost;
X}
X
Xint spell_fly_army(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  int id, cost;			/* army id and cost of casting */
X  Sarmy *ap, *get_army();
X  char s[EXECLEN];
X
X  if (w) {
X    mvwprintw(w, 4, 1,
X	    "Cost: %d spell pts./100 sold.  Which army do you want to fly? ",
X	    spellp->cost);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Cost %d pts/100 men; which army? ", spellp->cost);
X    statline_prompt(s, "hide_army");
X  }
X  if ( (wget_number(w, &id) <= 0) ||
X       ((ap = get_army(up->np, id)) == NULL) ||
X       (ap->pos.x != up->cursor.x) || (ap->pos.y != up->cursor.y) ) {
X    return -1;
X  }
X  cost = (spellp->cost * ap->n_soldiers + 99)/100;
X  if (cost > up->np->spell_pts) {
X    return -1;
X  }
X  if (w) {
X    wmove(w, 4, 1);
X    wclrtoeol(w);
X  }
X    /* prepare the h_spell struct, and then insert the exec lines */
X  prepare_h_spell(h_spellp, spellp->name, up->id, spellp->duration, 2);
X  sprintf(h_spellp->lines[0], "AFLAG_SET:%d:%d\n",
X	  ap->id, AF_FLIGHT);
X  sprintf(h_spellp->lines[1], "AFLAG_CLEAR:%d:%d\n",
X	  ap->id, AF_FLIGHT);
X  return cost;
X}
X
Xint spell_vampire_army(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  int id, cost;			/* army id and cost of casting */
X  Sarmy *ap, *get_army();
X  char s[EXECLEN];
X
X  if (w) {
X    mvwprintw(w, 4, 1,
X      "Cost: %d spell pts./100 sold.  Which army do you want to vampirize? ",
X       spellp->cost);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Cost %d pts/100 men; which army? ", spellp->cost);
X    statline_prompt(s, "vampire_army");
X  }
X  if ( (wget_number(w, &id) <= 0) ||
X       ((ap = get_army(up->np, id)) == NULL) ) {
X    return -1;
X  }
X  cost = (spellp->cost * ap->n_soldiers + 99)/100;
X  if (w) {
X    wmove(w, 4, 1);
X    wclrtoeol(w);
X  }
X    /* prepare the h_spell struct, and then insert the exec lines */
X  prepare_h_spell(h_spellp, spellp->name, up->id, spellp->duration, 2);
X  sprintf(h_spellp->lines[0], "AFLAG_SET:%d:%d\n",
X	  ap->id, AF_VAMPIRE);
X  sprintf(h_spellp->lines[1], "AFLAG_CLEAR:%d:%d\n",
X	  ap->id, AF_VAMPIRE);
X  return cost;
X}
Xint spell_burrow_army(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  int id, cost;			/* army id and cost of casting */
X  Sarmy *ap, *get_army();
X  char s[EXECLEN];
X
X  if (w) {
X    mvwprintw(w, 4, 1,
X      "Cost: %d spell pts./100 sold.  Which army do you want to send underground? ",
X       spellp->cost);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Cost %d pts/100 men; which army? ", spellp->cost);
X    statline_prompt(s, "burrow_army");
X  }
X  if ( (wget_number(w, &id) <= 0) ||
X       ((ap = get_army(up->np, id)) == NULL) ) {
X    return -1;
X  }
X  cost = (spellp->cost * ap->n_soldiers + 99)/100;
X  if (w) {
X    wmove(w, 4, 1);
X    wclrtoeol(w);
X  }
X    /* prepare the h_spell struct, and then insert the exec lines */
X  prepare_h_spell(h_spellp, spellp->name, up->id, spellp->duration, 2);
X  sprintf(h_spellp->lines[0], "AFLAG_SET:%d:%d\n",
X	  ap->id, AF_UNDERGROUND);
X  sprintf(h_spellp->lines[1], "AFLAG_CLEAR:%d:%d\n",
X	  ap->id, AF_UNDERGROUND);
X  return cost;
X}
X
Xint spell_water_walk(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  int id, cost;			/* army id and cost of casting */
X  Sarmy *ap, *get_army();
X  char s[EXECLEN];
X
X  if (w) {
X    mvwprintw(w, 4, 1,
X    "Cost: %d spell pts./100 sold.  Which army do you want to walk on water? ",
X       spellp->cost);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Cost %d pts/100 men; which army? ", spellp->cost);
X    statline_prompt(s, "walk_water");
X  }
X  if ( (wget_number(w, &id) <= 0) ||
X       ((ap = get_army(up->np, id)) == NULL) ||
X       (ap->pos.x != up->cursor.x) || (ap->pos.y != up->cursor.y) ) {
X    return -1;
X  }
X  cost = (spellp->cost * ap->n_soldiers + 99)/100;
X  if (cost > up->np->spell_pts) {
X    return -1;
X  }
X  if (w) {
X    wmove(w, 4, 1);
X    wclrtoeol(w);
X  }
X    /* prepare the h_spell struct, and then insert the exec lines */
X  prepare_h_spell(h_spellp, spellp->name, up->id, spellp->duration, 2);
X  sprintf(h_spellp->lines[0], "AFLAG_SET:%d:%d\n",
X	  ap->id, AF_WATER);
X  sprintf(h_spellp->lines[1], "AFLAG_CLEAR:%d:%d\n",
X	  ap->id, AF_WATER);
X  return cost;
X}
X
Xint spell_haste_army(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  int id, cost;			/* army id and cost of casting */
X  Sarmy *ap, *get_army();
X  char s[EXECLEN];
X
X  if (w) {
X    mvwprintw(w, 4, 1,
X      "Cost: %d spell pts./100 sold.  Which army do you want to hasten? ",
X       spellp->cost);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Cost %d pts/100 men; which army? ", spellp->cost);
X    statline_prompt(s, "haste_army");
X  }
X  if ( (wget_number(w, &id) <= 0) ||
X       ((ap = get_army(up->np, id)) == NULL) ) {
X    return -1;
X  }
X  cost = (spellp->cost * ap->n_soldiers + 99)/100;
X  if (w) {
X    wmove(w, 4, 1);
X    wclrtoeol(w);
X  }
X    /* prepare the h_spell struct, and then insert the exec lines */
X  prepare_h_spell(h_spellp, spellp->name, up->id, spellp->duration, 0);
X/*  sprintf(h_spellp->lines[0], "AFLAG_SET:%d:%d\n",
X	  ap->id, AF_VAMPIRE);
X  sprintf(h_spellp->lines[1], "AFLAG_CLEAR:%d:%d\n",
X	  ap->id, AF_VAMPIRE);
X*/
X  ap->mvpts += HASTE_POINTS;	/* increase movement */
X    /* make the exec line for this move point change; we
X       implement it as a trivial movement with change in move points.
X     */
X  sprintf(s, "AMOVE:%d:%d:%d:%d\n",
X	  ap->id, ap->pos.x, ap->pos.y, ap->mvpts);
X  gen_exec(s);
X  return cost;
X}
X
Xint spell_mag_bonus(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  int id, cost;			/* army id and cost of casting */
X  Sarmy *ap, *get_army();
X  char s[EXECLEN];
X
X  if (w) {
X    mvwprintw(w, 4, 1,
X       "Cost: %d spell pts./100 sold.  Which army do you want to enhance? ",
X       spellp->cost);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Cost %d pts/100 men; which army? ", spellp->cost);
X    statline_prompt(s, "mag_bonus");
X  }
X  if ( (wget_number(w, &id) <= 0) ||
X       ((ap = get_army(up->np, id)) == NULL) ||
X       (ap->pos.x != up->cursor.x) || (ap->pos.y != up->cursor.y) ) {
X    return -1;
X  }
X  cost = (spellp->cost * ap->n_soldiers + 99)/100;
X  if (cost > up->np->spell_pts) {
X    return -1;
X  }
X  if (w) {
X    wmove(w, 4, 1);
X    wclrtoeol(w);
X  }
X    /* prepare the h_spell struct, and then insert the exec lines */
X  prepare_h_spell(h_spellp, spellp->name, up->id, spellp->duration, 2);
X  sprintf(h_spellp->lines[0], "CABONUS:%d:%d\n", ap->id, 30);
X  sprintf(h_spellp->lines[1], "CABONUS:%d:%d\n", ap->id, -30);
X  return cost;
X}
X
X  /* this is a Unity spell which merges people into
X     an existing spirit.  you can only make the spirit
X     as big as twice its basic size.  the people
X     are taken from the current sector.  this is permanent,
X     it is not a hanging spell.  In fact, it is more of
X     an ability than a spell.
X   */
Xint spell_merge(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  int id, cost, ind;		/* army id, cost of casting and spirit index */
X  extern struct spirit_type *spirit_types;
X  Sarmy *ap, *get_army();
X  char s[EXECLEN];
X  int n_merged = 0;		/* number of people merged */
X  Ssector *sp = &world.map[up->cursor.x][up->cursor.y];
X
X  if (w) {
X    mvwprintw(w, 4, 1,
X       "Cost: %d spell pts./100 sold.  Which spirit do you want to enhance? ",
X       spellp->cost);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Cost %d pts/100 men; which spirit? ", spellp->cost);
X    statline_prompt(s, "merge");
X  }
X  if ( (wget_number(w, &id) <= 0)
X      || ((ap = get_army(up->np, id)) == NULL)
X      || (ap->pos.x != up->cursor.x) || (ap->pos.y != up->cursor.y)
X      || !is_spirit(ap) ) {
X    return -1;
X  }
X  if (has_hostile(sp) || sp->owner != user.id) {
X    statline2_err ("hit space", "cannot merge on a hostile sector");
X    return -1;
X  }
X  if (is_spelled(ap)) {
X    statline2_err ("hit space", "cannot merge on a spelled army");
X    return -1;
X  }
X  ind = spirit_type_index(ap->type);
X  if (w) {
X    mvwprintw(w, 4, 1,
X	      "How many men do you want to merge (or subtract) (max %d)? ",
X	      2*spirit_types[ind].size - ap->n_soldiers);
X    wclrtoeol(w);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Merge how many (max %d)? ",
X	    2*spirit_types[ind].size - ap->n_soldiers);
X    statline_prompt(s, "merge");
X  }
X    /* make sure that the spirit will not become too big or too small */
X  if ( (wget_number(w, &n_merged) <= 0)
X      || (n_merged > 0 && n_merged > 2*spirit_types[ind].size - ap->n_soldiers)
X      || n_merged < -ap->n_soldiers+1 || n_merged > sp->n_people) {
X    return -1;
X  }
X  cost = (spellp->cost * ap->n_soldiers + 99)/100; /* rounding up */
X  if (cost > 0 && cost > up->np->spell_pts) {
X    return -1;
X  }
X  if (w) {
X    wmove(w, 4, 1);
X    wclrtoeol(w);
X  }
X    /* this is not a hanging spell.  we just do the work once. */
X  ap->n_soldiers += n_merged;
X  ap->mvpts = 0;
X  ap->mvratio = 0;
X  sprintf(s, "AINCREASE:%d:%d\n", ap->id, n_merged);
X  gen_exec(s);
X  sp->n_people -= n_merged;
X  cpeople_sector(sp, -n_merged);
X  user.just_moved = 1;
X  return -1;
X}
X
X  /* hide a sector from view */
Xint spell_hide_sector(up, w, spellp, h_spellp)
X     Suser *up;
X     WINDOW *w;
X     Sspell *spellp;
X     Sh_spell *h_spellp;
X{
X  Ssector *sp = &world.map[up->cursor.x][up->cursor.y];
X  int cost;
X  char s[EXECLEN];
X
X  if (w) {
X    mvwprintw(w, 4, 1,
X    "Cost %d spell points.  Go ahead (y/n)? ",
X    spellp->cost);
X    wrefresh(w);
X  } else {
X    sprintf(s, "Costs %d; go ahead (y/n)? ", spellp->cost);
X    statline_prompt(s, "hide_sector");
X  }
X  cost =  spellp->cost;
X  switch (getch()) {
X  case 'y':
X  case 'Y':
X    break;
X  default:
X    return -1;
X  }
X
X  /* prepare the h_spell struct, and then insert the exec lines */
X  prepare_h_spell(h_spellp, spellp->name, up->id, spellp->duration, 2);
X  sprintf(h_spellp->lines[0], "FLAG_SET_SECTOR:%d:%d:%d\n",
X	  sp->loc.x, sp->loc.y, SF_HIDDEN);
X  sprintf(h_spellp->lines[1], "FLAG_CLEAR_SECTOR:%d:%d:%d\n",
X	  sp->loc.x, sp->loc.y, SF_HIDDEN);
X  user.just_moved = 1;
X  return cost;
X}
X
X  /* these are used to set and clear army flags (in the exec file) */
Xaflag_set(ap, flag)
X     Sarmy *ap;
X     int flag;
X{
X  char s[EXECLEN];
X
X  sprintf(s, "AFLAG_SET:%d:%d\n", ap->id, flag);
X  gen_exec(s);
X}
X
Xaflag_clear(ap, flag)
X     Sarmy *ap;
X     int flag;
X{
X  char s[EXECLEN];
X
X  sprintf(s, "AFLAG_CLEAR:%d:%d\n", ap->id, flag);
X  gen_exec(s);
X}
X
X/* For chess; transfers the spirit to the nations capital  */
Xspell_castle (up, w, spellp, h_spellp)
X     Suser * up;
X     WINDOW * w;
X     Sspell * spellp;
X     Sh_spell * h_spellp;
X{
X  Ssector * sp; 
X  Ssector * capital = &world.map [up->np->capital.x][up->np->capital.y];
X  Ssector * cur = &world.map [up->cursor.x][up->cursor.y];
X  Sarmy * ap;
X  char s [EXECLEN];
X  int army_num;
X
X  if (w) {
X    mvwprintw (w, 4, 1,
X	       "Costs %d spell points.  Go ahead (y/n)? ", spellp->cost);
X    wrefresh (w);
X  } else {
X    sprintf (s, "Costs %d; go ahead (y/n)? ", spellp->cost);
X    statline (s, "castle");
X  }
X    
X  switch (getch ()) {
X  case 'y':
X  case 'Y':
X    break;
X  default:
X    return -1;
X  }
X
X  sprintf (s, "Castle army #");
X  if (w) {
X    wmove (w, 4,1);
X    wclrtoeol (w);
X    box (w, '|', '-');
X    mvwprintw (w, 4, 1, s);
X  }
X  else {
X    statline (s, "castle");
X    move (LINES-1, strlen (s));
X    refresh ();
X  }
X  if (wget_number (w, &army_num) <= 0) {
X    return -1;
X  }
X  if ((ap = get_army (up->np, army_num)) == NULL) {
X    return -1;
X  }
X      
X  if (ap->pos.x != up->cursor.x || ap->pos.y != up->cursor.y) {
X    statline2_err ("Hit space", "Must be on the same sector as army");
X    return 0;
X  }
X
X  sp = &world.map[ap->pos.x][ap->pos.y];
X
X  delete_army_sector (sp, ap);
X
X  ap->pos.x = capital->loc.x;
X  ap->pos.y = capital->loc.y;
X  
X  insert_army_sector (capital, ap);
X
X  sprintf (s, "ACASTLE:%d\n", ap->id);
X  gen_exec (s);
X
X  cspell_pts (up->np, spellp->cost);
X  up->np->spell_pts -= spellp->cost;
X  return -1;
X}
X
Xint spell_sacrifice(up, w, spellp, h_spellp)
X     Suser * up;
X     WINDOW * w;
X     Sspell * spellp;
X     Sh_spell * h_spellp;
X{
X  char s [EXECLEN];
X  Ssector * sp = &world.map [up->cursor.x][up->cursor.y];
X  int num;
X
X  sprintf (s, "Sacrifice how many people (%d people per sp. point)? ",
X	   SACRIFICED_FRACT);
X
X  statline_prompt(s, "sacrifice");
X  if (wget_number(stdscr, &num) <= 0) {
X    return 0;
X  }
X  if (sp->owner != up->np->id) {
X    statline2_err ("hit space", "sorry, must sacrifice your own people");
X    return 0;
X  } else if (has_hostile (sp)) {
X    statline2_err ("hit space", "sorry, must sacrifice friendly people");
X    return 0;
X  } else if (sp->n_people < num) {
X    statline2_err ("hit space", "too many!");
X    return 0;
X  } else if (num < 0) {
X    statline2_err ("hit space", "nice try");
X    return 0;
X  }
X
X  cpeople_sector (sp, -num);
X  cspell_pts (up->np, (int)(num / SACRIFICED_FRACT));
X  sp->n_people -= num;
X  up->np->spell_pts += (int) (num / SACRIFICED_FRACT);
X  up->just_moved = 1;
X
X  return 0;
X}
END_OF_FILE
if test 24702 -ne `wc -c <'spells.c'`; then
    echo shar: \"'spells.c'\" unpacked with wrong size!
fi
# end of 'spells.c'
fi
echo shar: End of archive 20 \(of 28\).
cp /dev/null ark20isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Now execute ./do_cat.sh to build doc files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
