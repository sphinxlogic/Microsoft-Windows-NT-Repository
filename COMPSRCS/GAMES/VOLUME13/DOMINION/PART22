Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i058:  dominion - a multi-player world simulation game, Part22/28
Message-ID: <2461@masterCNA.TEK.COM>
Date: 11 Feb 92 18:27:08 GMT
Sender: news@masterCNA.TEK.COM
Lines: 2238
Approved: billr@saab.CNA.TEK.COM

Submitted-by: rosalia@dirac.physics.sunysb.edu (Mark Galassi)
Posting-number: Volume 13, Issue 58
Archive-name: dominion/Part22
Environment: Unix, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 22 (of 28)."
# Contents:  cur_stuff.c mag_Monsters mag_Unity menus.c npclib.c
# Wrapped by billr@saab on Tue Feb 11 10:14:57 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'cur_stuff.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cur_stuff.c'\"
else
echo shar: Extracting \"'cur_stuff.c'\" \(18715 characters\)
sed "s/^X//" >'cur_stuff.c' <<'END_OF_FILE'
X  /* cur_stuff.c -- stuff that uses curses a lot */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X/* pager(fname) - pages through a file                             */
X/* mygetch() - runs getch(), and gives help if user types '?'      */
X/* wget_name(w, name) - gets a name in a curses window             */
X/* wget_string(w, str, len) - gets a string in a curses window     */
X/* wget_number(w, p) - gets a number in a curses window            */
X
X#include "dominion.h"
X#include "misc.h"
X#include "cur_stuff.h"
X#include <stdio.h>
X
Xextern Suser user;
Xextern Sworld world;
Xextern int (*keymap[128])(), (*wrapx)(), (*wrapy)();
Xextern struct s_desig_map desig_map[];
Xextern struct s_altitude_map altitude_map[];
Xextern struct item_map terrains[];
X
XWINDOW *sectw;
X/* WINDOW *sectw, *armyw; */
X
X/* statline and statline2 moved to misc.c */
X
X  /* simple standalone pager, used for news and other stuff */
Xpager(fname)
X     char fname[];
X{
X  FILE *fp, *fopen();
X  WINDOW *pagew;
X  long page_lines = LINES-2, lines = 0;
X  char line[200];
X  char c;
X  int i;
X
X  if ((fp = fopen(fname, "r")) == NULL) {
X    statline2_err("cannot open file", fname);
X    return '\0';
X  }
X  pagew = newwin(LINES-2, COLS, 0, 0);
X  touchwin(pagew);
X  lines = 0;
X  while (fgets(line, 180, fp) != NULL) {
X    line[COLS-2] = '\0';	/* make sure it fits on screen */
X    mvwaddstr(pagew, lines, 0, line);
X    wclrtoeol(pagew);
X    wrefresh(pagew);
X    ++lines;
X    if (lines % page_lines == 0) { /* next page? */
X      wclrtobot(pagew);
X      wrefresh(pagew);
X      lines = 0;
X      statline("SPACE to continue, [q] or [n] to leave this file", fname);
X      switch(c = getch()) {
X      case 'q':
X      case 'n':
X	fclose(fp);
X	return c;
X	break;
X      case 'f':			/* skip 23 lines */
X	for (i = 0; i < 23 && fgets(line, 180, fp); ++i) {
X	}
X	break;
X      case ' ':
X	break;
X      default:
X	break;
X      }
X      wmove(pagew, 0, 0);
X    }
X  }
X  fclose(fp);
X  wclrtobot(pagew);
X  wrefresh(pagew);
X  delwin(pagew);
X  return ' ';
X}
X
X  /* draw the world map */
Xdraw_map()
X{
X  if (user.map_style == NORMAL_MAP) {
X    draw_map_regular();
X  } else {
X    draw_map_compact();
X  }
X}
X
X  /* draw the map with a space between adjacent sectors */
Xdraw_map_regular()
X{
X  char s[80];
X  int x = user.cursor.x, y = user.cursor.y /*,
X         xoff = user.center.x-(COLS-2)/4, yoff = user.center.y - (LINES-2)/2*/;
X  int i, j, iw, jw, n;
X  int mark;	/* what to draw in that sector, negative if highlight */
X  Ssector *sp = &world.map[x][y];
X  int visibility;
X
X    /* clean up the space from the previous armies */
X  for (i = 0; i <= 2*user.last_n_armies; ++i) {
X    move(i, ARMYW_X);
X    clrtoeol();
X  }
X  user.last_n_armies = sect_n_armies(sp);
X
X  for (i = xoff(); (i < xoff()+(COLS-2)/2) && (i < xoff()+world.xmax); ++i) {
X    for (j = yoff(); (j < yoff()+LINES-2) && (j < yoff()+world.ymax); ++j) {
X      if (!is_under_sectw(2*(i-xoff()), j-yoff())) {
X          /* now wrap the coordinates, so we handle the topology */
X	move(j-yoff(), 2*(i-xoff()));	/* move does not want wrapping */
X	iw = (*wrapx)(i,j);
X	jw = (*wrapy)(i,j);
X	visibility = user.visible_sectors[iw][jw];
X	if (visibility > SEE_NOTHING && visibility != SEE_ARMIES) {
X	  if ((mark = which_mark(iw, jw, &user)) < 0) {
X	    standout();
X	    addch(-mark);
X	    standend();
X	  } else {
X	    addch(mark);
X	  }
X	} else {		/* if not visible, put a space */
X	  addch(' ');
X	}
X      }
X    }
X  }
X  show_armies(&world.map[x][y]);
X  sprintf(s, "Nation %s; money %d; Thon %d;   type %c for help",
X	  user.np->name, user.np->money, world.turn, user.help_char);
X  statline(s, "draw_map_regular");
X  show_sector(x, y);
X  move((*wrapy)(x-xoff(),y-yoff()), 2*(*wrapx)(x-xoff(),y-yoff()));
X  refresh();
X}
X
Xdraw_map_compact()		/* compact drawing of map */
X{
X  char s[80];
X  int x = user.cursor.x, y = user.cursor.y;
X  int i, j, n;
X  int mark;	/* what to draw in that sector, negative if highlight */
X  Ssector *sp = &world.map[x][y];
X  int visibility;
X
X    /* clean up the space from the previous armie */
X  for (i = 0; i <= 2*user.last_n_armies; ++i) {
X    move(i, ARMYW_X);
X    clrtoeol();
X  }
X  user.last_n_armies = sect_n_armies(sp);
X
X  for (i = xoff_compact();
X       (i < xoff_compact() + COLS-2) && (i < xoff_compact() + world.xmax); ++i) {
X    for (j = yoff(); (j < yoff() + LINES-2) && (j < yoff() + world.ymax); ++j) {
X      move(j-yoff(), i-xoff_compact());
X      visibility = user.visible_sectors[(*wrapx)(i,j)][(*wrapy)(i,j)];
X      if (visibility > SEE_NOTHING && visibility != SEE_ARMIES) {
X	if ((mark = which_mark((*wrapx)(i,j), (*wrapy)(i,j), &user)) < 0) {
X	  standout();
X	  addch(-mark);
X	  standend();
X	} else {
X	  addch(mark);
X	}
X      } else {			/* if not visible, put a space */
X	addch(' ');
X      }
X    }
X  }
X  show_armies(&world.map[x][y]);
X  sprintf(s, "Nation %s; money %d; Thon %d;   type %c for help",
X	  user.np->name, user.np->money, world.turn, user.help_char);
X  statline(s, "draw_map_compact");
X  show_sector(user.cursor.x, user.cursor.y);
X  move((*wrapy)(x-xoff_compact(),y-yoff()), (*wrapx)(x-xoff_compact(),y-yoff()));
X  refresh();
X}
X
Xshow_sector(x, y)		/* give info on the sector */
X     int x, y;
X{
X  Ssector *sp = &world.map[x][y];
X  char s[2*NAMELEN];
X  int visibility = user.visible_sectors[x][y];
X
X  if (user.show_sect_win && user.just_moved) {
X    /* put the stuff in the special sector window */
X  mvwprintw(sectw, 1, 1, "(%d,%d)", xrel(x,y,user.np->capital),
X	    yrel(x,y,user.np->capital));
X
X  wclrtobot(sectw);
X
X    /* Show sector name if they can see the population of the sector! */
X  if (visibility & SEE_POPULATION) {
X    wprintw(sectw," %s", sp->name);
X  }
X  
X    /* Shows owner if can see owner */
X  wmove(sectw, 2, 1);
X  if ((visibility & SEE_OWNER) && (sp->owner!=0)) {
X    wprintw(sectw,"%s-", world.nations[sp->owner].name);
X  }
X  
X    /* Shows designation if can see designation */
X  if (visibility & SEE_DESIG) {
X    if (sp->owner != 0 || sp->designation != D_NODESIG) {
X      wprintw(sectw, "%s", desig_map[sp->designation].name);
X      if (has_bubble(sp)) {
X	waddstr(sectw, "/B");
X      }
X      if (has_hidden(sp)) {
X	waddstr(sectw, "/H");
X      }
X      if (has_traded(sp)) {
X	waddstr(sectw, "/T");
X      }
X      if (has_impenetrable(sp)) {
X	waddstr(sectw, "/I");
X      }
X      if (has_hostile(sp)) {
X	waddstr(sectw, "/h");
X      }
X    }
X  }
X  
X  if (visibility & SEE_LAND_WATER) {
X    mvwprintw(sectw, 3, 1, "%s ", terrains[sp->terrain - MIN_TERRAIN].name);
X    wprintw(sectw, "%s", altitude_map[map_alt(sp->altitude)].name);
X  }
X
X    wmove(sectw, 4, 1);    
X    if (visibility & SEE_POPULATION) {
X      wprintw(sectw, "%d people", sp->n_people);
X      if (sp->owner != 0) {	/* print race of owner, if owner is not 0 */
X	wprintw(sectw, " (%c)",	world.nations[sp->owner].race.mark);
X      }
X    }
X  
X  if (visibility & SEE_RESOURCES) {
X    mvwprintw(sectw, 5, 1, "metal %d", sp->metal);
X    mvwprintw(sectw, 5, 13, "jewels %d", sp->jewels);
X  }
X  
X  if (visibility & SEE_RESOURCES) {
X    mvwprintw(sectw, 6, 2, "soil %d", sp->soil);
X  }
X  if (visibility & SEE_LAND_WATER) {
X    mvwprintw(sectw, 6, 11, "movecost %d",
X	      get_generic_move_cost(&world.nations[user.id],sp));
X/*	      get_move_cost(&world.nations[user.id],sp)); */
X  }
X
X  box(sectw, '|', '-');
X  } /* (for future optimization) */
X  wrefresh(sectw);
X}
X
Xbad_key()			/* user typed an undefined key */
X{
X  statline("type space to go on", "bad_key");
X  while (getch() != ' ') {
X  }
X}
X
Xredraw()
X{
X/*  user.center = user.cursor; */
X  clear();
X  refresh();
X  user.just_moved = 1;
X}
X
Xwindows()			/* user gets to manage windows */
X{
X  WINDOW *winw;			/* for this screen only */
X  Pt new_loc;			/* new location of the window */
X
X  statline("", "windows");
X  winw = newwin(6, 26, 2, 2);
X  wstandout(winw);
X  mvwprintw(winw, 1, 4, "you can choose: ");
X  wstandend(winw);
X  mvwprintw(winw, 2, 0, "m - [m]ove sector window");
X  mvwprintw(winw, 3, 0, "h - [h]ide sector window");
X  mvwprintw(winw, 4, 0, "s - [s]how sector window");
X  move(4,0);
X  box(winw, '|', '-');
X  wrefresh(winw);
X  move(4,0);
X  switch(getch()) {
X  case 'm':
X    new_loc.x = sectw->_begx;
X    new_loc.y = sectw->_begy;
X    mvprintw(LINES-2, 0, "starting at (%d,%d)", new_loc.x, new_loc.y);
X    refresh();
X      /* absolute dragging */
X    new_loc = drag_cursor(new_loc, DRAG_ABS, NULL, NULL);
X    mvwin(sectw, new_loc.y, new_loc.x);
X    break;
X  case 'h':
X    user.show_sect_win = 0;
X    werase(sectw);
X    wrefresh(sectw);
X    touchwin(stdscr);
X    break;
X  case 's':
X    if (!user.show_sect_win) {
X      show_sector(user.cursor.x, user.cursor.y);
X    }
X    user.show_sect_win = 1;
X    break;
X  default:
X    break;
X  }
X  delwin(winw);			/* done with it */
X  touch_all_wins();
X/*  fflush(stdin); */
X}
X
Xtouch_all_wins()	/* make sure all permanent windows get touched */
X{
X  touchwin(stdscr);
X/*  if (user.show_sect_win) {
X    touchwin(sectw);
X  }
X*/
X  user.just_moved = 1;
X}
X
X  /* this is used in general to track the user's movements */
XPt drag_cursor(pt, flags, comment, legal)
X     Pt pt;
X     int flags;
X     char (*comment)();
X     int (*legal)();
X{
X  char c;
X  char s[100], comment_str[100];
X  Pt old_pt;
X  int done = 0;
X
X  old_pt = pt;
X
X  statline("move the cursor; type space when done", "drag_cursor");
X
X  if ((flags == DRAG_REL) && (user.map_style == NORMAL_MAP)) {
X    wrap(&pt);			/* regural map, relative drag */
X    move(pt.y-yoff(), 2*(pt.x-xoff()));
X  } else if (flags == DRAG_REL) { /* compact map, but still relative */
X    wrap(&pt);
X    move((*wrapy)(pt.x-xoff_compact(), pt.y-yoff()),
X	 (*wrapx)(pt.x-xoff_compact(),pt.y-yoff()));
X  } else {			/* absolute positions */
X    move(pt.y, pt.x);
X  }
X  refresh();
X  while (((c = getch()) != ' ') && !done) {
X    old_pt = pt;
X    switch (c) {
X    case '?':
X      online_info();
X      break;
X    case 'h':
X    case '4':
X      --pt.x;
X      break;
X    case 'j':
X    case '2':
X      ++pt.y;
X      break;
X    case 'k':
X    case '8':  
X      --pt.y;
X      break;
X    case 'l':
X    case '6':  
X      ++pt.x;
X      break;
X    case 'y':
X    case '7':
X      --pt.x;
X      --pt.y;
X      break;
X    case 'u':
X    case '9':
X      ++pt.x;
X      --pt.y;
X      break;
X    case 'b':
X    case '1':
X      --pt.x;
X      ++pt.y;
X      break;
X    case 'n':
X    case '3':
X      ++pt.x;
X      ++pt.y;
X      break;
X    default:
X      continue;
X    }
X    if (legal != NULL) {	/* if there *is* a legal() func... */
X      wrap(&pt);
X      if (!((*legal)(pt, user.np, user.current_army))) {
X	beep();			/* illegal */
X	pt = old_pt;
X	statline2("hit space", "invalid point");
X	get_space();
X      }
X    }
X    if (flags == DRAG_REL) {	/* cludge, and ugly, since we wrap later */
X      wrap(&pt);
X      sprintf(s, "(%d,%d)", xrel(pt.x,pt.y,user.np->capital),
X	      yrel(pt.x,pt.y,user.np->capital));
X    } else {
X      sprintf(s, "(%d,%d)", pt.x, pt.y);
X    }
X    if (comment != NULL) {
X      done = comment(comment_str);
X      statline2(comment_str, s);
X    } else {
X      statline2("", s);
X    }
X    switch (flags) {
X    case DRAG_REL:
X      wrap(&pt);
X      re_center(pt.x, pt.y);
X      user.just_moved = 1;
X      draw_map();
X/*      show_sector(pt.x, pt.y); */
X      if (user.map_style == NORMAL_MAP) {
X	move((*wrapy)(pt.x-xoff(),pt.y-yoff()), 2*(*wrapx)(pt.x-xoff(),pt.y-yoff()));
X      } else {
X	move((*wrapy)(pt.x-xoff_compact(),pt.y-yoff()), (*wrapx)(pt.x-xoff_compact(),pt.y-yoff())); /* compact map */
X      }
X      break;
X    case DRAG_ABS:
X      move(pt.y, pt.x);
X      break;
X    default:
X      break;
X    }
X    refresh();
X  }
X  if (flags == DRAG_REL) {
X    sprintf(s, "the new point is (%d, %d)", xrel(pt.x,pt.y,user.np->capital),
X	    yrel(pt.x,pt.y,user.np->capital));
X  } else {
X    sprintf(s, "the new point is (%d, %d)", pt.x, pt.y);
X  }
X  statline2(s, "");
X  move(LINES-2, 0);
X  clrtoeol();
X  refresh();
X  return pt;
X}
X
X  /* this routine sees if the screen needs re-centering, and
X     re-centers it if necessary.  return 1 if re-centering was done.
X     return 0 if there was no need to re-center.
X   */
Xre_center(x, y)
X     int x, y;
X{
X  int change = 0;
X  int width, height;
X
X  height = LINES-3;
X  width = (COLS-2)-2;
X
X  if (user.map_style == NORMAL_MAP) {
X    if ((*wrapx)(x - xoff(),0) >= width/2) { /* No Y coord to add! -KM */
X      user.center.x = x;	/* too much to the right */
X      change = 1;
X    }
X    if ((*wrapx)(x - xoff(),0) <= 0) { /* No Y coord to add! -KM */
X      user.center.x = x;	/* too much to the left */
X      change = 1;
X    }
X  } else {
X    if ((*wrapx)(x - xoff_compact(),0) >= width) {
X      user.center.x = x;	/* too much to the right */
X      change = 1;
X    }
X    if ((*wrapx)(x - xoff_compact(),0) <= 0) {
X      user.center.x = x;	/* too much to the left */
X      change = 1;
X    }
X  }
X  if ((*wrapy)(0,y - yoff()) >= height) {
X    user.center.y = y;		/* too far down */
X    change = 1;
X  }
X  if ((*wrapy)(0,y - yoff()) <= 0) {
X    user.center.y = y;		/* too far up */
X    change = 1;
X  }
X#ifdef hpux
X  if (change) {
X    redraw();
X  }
X#endif /* hpux */
X  return change;
X}
X
X  /* see if these coordinates would appear under the sector window */
Xis_under_sectw(x, y)
X     int x, y;
X{
X  int xfirst, yfirst, xlast, ylast;
X
X  if (!user.show_sect_win) {
X    return 0;
X  }
X  xfirst = sectw->_begx;
X  yfirst = sectw->_begy;
X  xlast = xfirst + SECTW_SIZE_X;
X  ylast = yfirst + SECTW_SIZE_Y;
X  if (x < xfirst ||  x > xlast || y < yfirst || y > ylast) {
X    return 0;
X  }
X  return 1;
X}
X
X  /* this puts the cursor in the right place */
Xset_cursor()
X{
X  int x = user.cursor.x, y = user.cursor.y;
X
X  if (user.map_style == NORMAL_MAP) {
X    move((*wrapy)(x-xoff(),y-yoff()), 2*(*wrapx)(x-xoff(),y-yoff()));
X  } else {
X    move((*wrapy)(x-xoff_compact(),y-yoff()), (*wrapx)(x-xoff_compact(),y-yoff()));
X  }
X  refresh();
X}
X
X  /* replacement for getch():  first checks if it is a question
X     mark, and if it is it calls online_info().
X   */
Xmygetch()
X{
X  int c;
X  if ((c = getch()) == '?') {
X    online_info();
X  }
X  return c;
X}
X
X  /* gets a string str of max length len; returns 0 on failure; 1 otherwise */
Xwget_string (w, rets, len)
X     WINDOW * w;
X     char * rets;
X     int len;
X{
X  char s [80];
X  int pos, done;
X  int x, y, i;
X  int oldpos;		/* Used for ^W */
X  noecho ();
X
X  if (w == NULL) {
X    w = stdscr;
X  }
X
X  pos = 0;
X  done = 0;
X
X  getyx (w, y, x);
X  wrefresh (w);
X
X  while (!done) {
X    s [pos] = wgetch (stdscr);
X    switch (s[pos]) {
X    case '\n':
X    case '\r':
X      s [pos] = '\0';
X      done = 1;
X      break;
X    case '\b':
X    case DEL:
X      if (pos > 0) {
X	pos--;
X	s[pos] = '\0';
X	wmove (w, y, x + pos);
X	waddch (w, ' ');
X	wmove (w, y, x + pos);
X      }
X      break;
X    case CTL('U'):
X      wmove (w, y, x);
X      for (i=0; i < pos; i++) {
X	waddch (w, ' ');
X      }
X      wmove (w, y, x);
X      pos = 0;
X      s [pos] = '\0';
X      break;
X    case CTL('W'):
X      oldpos = pos;
X      while (pos != 0 && s[pos] == ' ') {
X	pos --;
X      }
X      if (pos) {
X	pos --;
X      }
X      while (pos != 0 && s[pos] != ' ') {
X	pos --;
X      }
X      wmove (w, y, x + pos);
X      while (oldpos != pos) {
X	oldpos--;
X	waddch (w, ' ');
X      }      
X      wmove (w, y, x + pos);
X      break;
X    default:
X      waddch (w, s [pos]);
X      pos++;
X      break;
X    }
X    wrefresh (w);
X  }
X
X  if (pos == 0) {
X    return 0;
X  }
X  s [len-1] = '\0';
X  strcpy (rets, s); 
X  return 1;
X}
X
X/* gets a number from window w; returns 1 if all OK; -1 otherwise */
Xwget_number (w, num)
X     WINDOW * w;
X     int * num;
X{
X  char s [80];
X  int pos, done;
X  int x, y, i;
X  noecho ();
X
X  if (w == NULL) {
X    w = stdscr;
X  }
X
X  pos = 0;
X  done = 0;
X
X  getyx (w, y, x);
X  wrefresh (w);
X
X  while (!done) {
X    s [pos] = wgetch (stdscr);
X    switch (s[pos]) {
X    case '\n':
X    case '\r':
X      done = 1;
X      break;
X    case '\b':
X    case DEL:
X      if (pos > 0) {
X	pos--;
X	s[pos] = '\0';
X	wmove (w, y, x + pos);
X	waddch (w, ' ');
X	wmove (w, y, x + pos);
X      }
X      break;
X    case CTL('U'):
X      wmove (w, y, x);
X      for (i=0; i < pos; i++) {
X	waddch (w, ' ');
X      }
X      wmove (w, y, x);
X      pos = 0;
X      s [pos] = '\0';
X      break;
X    default:
X      waddch (w, s [pos]);
X      pos++;
X      break;
X    }
X    wrefresh (w);
X  }
X  if (pos == 0) {
X    return -1;
X  }
X  if ((sscanf(s, "%d", num)) < 1) {
X    return -1;
X  }
X  return 1;
X}
X
Xwget_name (w, name)
X     WINDOW * w;
X     char * name;
X{
X  char s[80];
X  int pos, done;
X  int x, y, i;
X  int oldpos;		/* Used for ^W */
X  noecho();
X
X  if (w == NULL) {
X    w = stdscr;
X  }
X
X  pos = 0;
X  done = 0;
X
X  getyx (w, y, x);
X  wrefresh (w);
X
X  while (!done) {
X    s [pos] = wgetch (stdscr);
X    switch (s[pos]) {
X    case '\n':
X    case '\r':
X      s [pos] = '\0';
X      done = 1;
X      break;
X    case '\b':
X    case DEL:
X      if (pos > 0) {
X	pos--;
X	s[pos] = '\0';
X	wmove (w, y, x + pos);
X	waddch (w, ' ');
X	wmove (w, y, x + pos);
X      }
X      break;
X    case CTL('U'):
X      wmove (w, y, x);
X      for (i=0; i < pos; i++) {
X	waddch (w, ' ');
X      }
X      wmove (w, y, x);
X      pos = 0;
X      s [pos] = '\0';
X      break;
X    case CTL('W'):
X      oldpos = pos;
X      while (pos != 0 && s[pos] == ' ') {
X	pos --;
X      }
X      if (pos) {
X	pos --;
X      }
X      while (pos != 0 && s[pos] != ' ') {
X	pos --;
X      }
X      wmove (w, y, x + pos);
X      while (oldpos != pos) {
X	oldpos--;
X	waddch (w, ' ');
X      }      
X      wmove (w, y, x + pos);
X      break;
X    default:
X      waddch (w, s [pos]);
X      pos++;
X      break;
X    }
X    wrefresh (w);
X  }
X
X  if (pos == 0) {
X    return -1;
X  }
X  strcpy (name, s); 
X  return 1;
X}
X
X#ifdef PMAX  /* Fix for the mvwprintw bug in pmax curses */
X#undef mvwprintw
X#include <varargs.h>
X
Xmymvwprintw(va_alist)
X     va_dcl
X{
X    va_list ap;
X    reg WINDOW	*win;
X    reg int		y, x;
X    char		*fmt;
X    char	buf[512];
X
X    va_start(ap);
X    win = va_arg(ap, WINDOW *);
X    y = va_arg(ap, int);
X    x = va_arg(ap, int);
X    fmt = va_arg(ap, char *);
X    
X    if (wmove(win,y, x) != OK)
X      return ERR;
X    (void) vsprintf(buf, fmt, ap);
X    va_end(ap);
X    return waddstr(win, buf);
X}
X#endif /* PMAX */
END_OF_FILE
if test 18715 -ne `wc -c <'cur_stuff.c'`; then
    echo shar: \"'cur_stuff.c'\" unpacked with wrong size!
fi
# end of 'cur_stuff.c'
fi
if test -f 'mag_Monsters' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mag_Monsters'\"
else
echo shar: Extracting \"'mag_Monsters'\" \(689 characters\)
sed "s/^X//" >'mag_Monsters' <<'END_OF_FILE'
X# this file describes magic powers available to magical
X# order of Monstrosity.
X#
X# the format is:
X# name level cost
X# begin
X#   series of exec lines
X# end
X#
X# where `level' is the magical skill level at which you get the power,
X# and `cost' is the cost in spell points to use the power.
X#
Xsummon_spider 50 1
Xsummon_yeti 90 2
Xsummon_ettin 170 3
Xsummon_cyclops 200 3
Xsummon_hydra 500 4
Xsummon_crimson_death 800 8
Xsummon_sea_dragon 1300 9
Xsummon_green_dragon 1700 11
Xsummon_red_dragon 2300 17
Xsummon_gold_dragon 3000 24
X#
Xhide_army 200 1 2
Xhide_sector 250 2 8
Xmag_bonus 300 1 2
Xfly_army 400 2 2
Xwater_walk 500 2 2
Xhaste_army 600 3 2
Xcaltitude 800 8 6
Xvampire_army 900 3 8
Xfireburst 1000 4 4
END_OF_FILE
if test 689 -ne `wc -c <'mag_Monsters'`; then
    echo shar: \"'mag_Monsters'\" unpacked with wrong size!
fi
# end of 'mag_Monsters'
fi
if test -f 'mag_Unity' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mag_Unity'\"
else
echo shar: Extracting \"'mag_Unity'\" \(608 characters\)
sed "s/^X//" >'mag_Unity' <<'END_OF_FILE'
X# this file describes magic powers available to magical order of Unity,
X# which is concerned mostly with mixed animals.
X#
X# the format is:
X# name level cost
X# begin
X#   series of exec lines
X# end
X#
X# where `level' is the magical skill level at which you get the power,
X# and `cost' is the cost in spell points to use the power.
X#
Xsummon_naga 50 1
Xsummon_centaur 90 3
Xsummon_werewolf 140 4
Xsummon_minotaur 150 3
Xsummon_owl_bear 400 4
Xsummon_gryphon 500 7
Xsummon_sea_lion 700 7
Xsummon_chimera 1100 10
Xsummon_sphynx 2200 17
X#
Xhide_army 400 1 2
Xmerge 0 0 0
Xhide_sector 500 2 8
Xmag_bonus 600 1 2
Xfly_army 800 2 2
END_OF_FILE
if test 608 -ne `wc -c <'mag_Unity'`; then
    echo shar: \"'mag_Unity'\" unpacked with wrong size!
fi
# end of 'mag_Unity'
fi
if test -f 'menus.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'menus.c'\"
else
echo shar: Extracting \"'menus.c'\" \(19167 characters\)
sed "s/^X//" >'menus.c' <<'END_OF_FILE'
X  /* menus.c -- various menus for dominion */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#ifdef SYSV
X# include <string.h>
X#else
X# include <strings.h>
X#endif /* SYSV */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X
Xextern Sworld world;
Xextern Suser user;
X  /* info about all spirits */
Xextern struct spirit_type *spirit_types;
Xextern char help_tag[];
X
X  /* asks the user what the display should look like */
Xdisplay_menu()
X{
X  WINDOW *dispw;
X  char c;
X
X  strcpy(help_tag, "Display options");
X  if (user.xmode) {
X    statline("[r,c,n,d,p,A,w,M,t,T,s,m,j,h,o,a,y,O,l,u,-,C,W]", "display_menu");
X  } else {
X    statline("choose an option (space to exit)", "display menu");
X    dispw = newwin(9, COLS-4, LINES-11, 2);
X    wmove(dispw, 1, 1);
X    waddstr(dispw, "Map Style:         [r]egular, [c]ompact");
X    wmove(dispw, 2, 1);
X    waddstr(dispw, "Display Options:   ");
X    waddstr(dispw, "[n]ation mark, [d]esignation, [p]opulation,");
X    wmove(dispw, 3, 1);
X    waddstr(dispw, "                   ");
X    waddstr(dispw, "[A]ltitude, [w] Climate, army [M]ovecost, [t]errain,");
X    wmove(dispw, 4, 1);
X    waddstr(dispw, "                   ");
X    waddstr(dispw, "[s]oil, [m]etal, [j]ewels, [T]errain move cost");
X    wmove(dispw, 5, 1);
X    waddstr(dispw, "Highlight Options: ");
X    waddstr(dispw, "[o]wnership, [a]rmies, [y]our armies, [O]ther armies,");
X    wmove(dispw, 6, 1);
X    waddstr(dispw, "                   ");
X    waddstr(dispw, "[l] move left, [h]ostile, [u]nemployment, [-]none");
X    wmove(dispw, 7, 1);
X    waddstr(dispw, "Other Things:      ");
X    waddstr(dispw, "[C]enter screen at cursor, [W]ater/underwater toggle");
X    box(dispw, '|', '-');
X    wrefresh(dispw);
X  }
X  switch (c = mygetch()) {
X  case ' ':
X    break;
X  case 'h':
X    user.highlight = H_HOSTILE;
X    break;
X  case 'M':
X    user.display = ARMY_MOVECOST;
X    break;
X  case 'r':
X    user.map_style = NORMAL_MAP; /* map style */
X    wclear(stdscr);
X    break;
X  case 'c':
X    user.map_style = COMPACT_MAP;
X    wclear(stdscr);
X    break;
X  case 'd':
X    user.display = DESIGNATION; /* display */
X    break;
X  case 'n':
X    user.display = NATION_MARK;
X    break;
X  case 's':
X    user.display = SOIL;
X    break;
X  case 'm':
X    user.display = METAL;
X    break;
X  case 'j':
X    user.display = JEWELS;
X    break;
X  case 'A':
X    user.display = ALTITUDE;
X    break;
X  case 'w':
X    user.display = CLIMATE;
X    break;
X  case 'p':
X    user.display = POPULATION;
X    break;
X  case 'T':
X    user.display = MOVECOST;
X    break;
X  case 't':
X    user.display = TERRAIN;
X    break;
X  case 'o':
X    user.highlight = H_OWNED;	/* highlighting */
X    break;
X  case 'a':
X    user.highlight = H_ARMIES;
X    break;
X  case 'y':
X    user.highlight = H_YOUR_ARMIES;
X    break;
X  case 'O':
X    user.highlight = H_OTHER_ARMIES;
X    break;
X  case 'l':
X    user.highlight = H_MOVE_LEFT;
X    break;
X  case 'u':
X    user.highlight = H_UNEMP;
X    break;
X  case '-':			/* no highlighting */
X    user.highlight = H_NONE;
X    break;
X  case 'C':			/* center screen around current cursor */
X    user.center = user.cursor;
X#ifdef hpux			/* HP curses is baaad */
X    redraw();
X#endif /* hpux */
X    break;
X  case 'W':			/* above/below water toggle */
X    user.underwater = !user.underwater;
X    break;
X  default:
X    bad_key();
X    break;
X  }
X  if (!user.xmode) {
X    delwin(dispw);
X  }
X  touchwin(stdscr);
X  user.just_moved = 1;
X}
X
X  /* wizardry commands */
Xwizardry_menu()
X{
X  WINDOW *wizw;
X  char c;
X  int done = 0;
X  char s[PATHLEN];
X  Snation *np = user.np;
X  Ssector *sp = &world.map[user.cursor.x][user.cursor.y];
X
X  if (user.xmode) {
X    wizw = (WINDOW *) NULL;
X  } else {
X    wizw = newwin(6, COLS-4, LINES-8, 2);
X  }
X    /* now see if we can automatically select the first mage
X       on this sector.
X     */
X  if (first_sect_mage_id(user.np, sp) != -1) {
X    user.current_army = first_sect_mage_id(user.np, sp);
X    show_armies(sp);
X  }
X  while (!done) {
X    strcpy(help_tag, "Wizardry");
X    if (user.xmode) {
X      sprintf(s, "%d spell pts. [l,c,s,h,i]", np->spell_pts);
X      statline(s, "wizardry_menu");
X    } else {
X      statline("Choose a wizardry command (space to leave)","wizardry_menu");
X      mvwaddstr(wizw, 1, 1,
X	"  [l]ist spells and spirits, [c]ast a spell, [s]ummon a spirit");
X      mvwaddstr(wizw, 2, 1, "  list [h]anging spells, [i]nitiate a mage");
X      mvwprintw(wizw, 3, 1, "    You have %d spell points", np->spell_pts);
X      box(wizw, '|', '-');
X      wrefresh(wizw);
X    }
X    switch (c = getch()) {
X    case ' ':
X      done = 1;
X      break;
X    case 'l':
X      if (!user.xmode) {
X	wmove(wizw, 2, 1);
X	wprintw(wizw,
X		"  listing spells and spirits for nation %s (order of %s)",
X		user.np->name, user.np->mag_order);
X      }
X      list_spells(&user);
X      list_spirits(&user);
X      statline2_err("Type space to get back", "spells and spirits list");
X      touchwin(stdscr);
X      refresh();
X      fflush(stdin);
X      user.just_moved = 1;
X      break;
X    case 's':
X      if (!user.xmode) {
X	list_spirits(&user);
X      }
X      summon(&user, wizw);
X      break;
X    case 'c':
X      if (!user.xmode) {
X	list_spells(&user);
X      }
X      cast_spell(&user, wizw);
X      break;
X    case 'i':
X      initiate_mage(&user, wizw);
X      break;
X    case 'h':
X      show_hanging_spells(&user);
X      break;
X    case '?':
X      online_info();
X      break;
X    default:
X      break;
X    }
X    statline2("", "");
X    if (!user.xmode) {
X      wmove(wizw, 2, 1);
X      wclrtobot(wizw);
X    }
X  }
X  if (!user.xmode) {
X    touchwin(stdscr);
X    delwin(wizw);
X    user.just_moved = 1;
X  }
X}
X
X  /* conjures a spirit */
Xsummon(up, w)
X     Suser *up;
X     WINDOW *w;
X{
X  char type[NAMELEN], name[NAMELEN];
X  int type_index;
X  Sspirit *spiritp = user.spirit_list;
X  Sarmy *ap, *get_army();
X  Ssector *sp = &world.map[up->cursor.x][up->cursor.y];
X
X  strcpy(help_tag, "Spirit types");
X
X  if ((ap = get_army(up->np, up->current_army)) == NULL  ||  !is_mage(ap) ) {
X    statline2_err("only mages can summon. hit space.", "summon");
X    return;
X  }
X  if (sp->owner != up->np->id) {
X    statline2_err("must summon in your own land", "summon");
X    return;
X  }
X  if (w) {
X    mvwprintw(w, 2, 1, "Which type of spirit do you wish to summon? ");
X  } else {
X    statline_prompt("Which type? ", "summon");
X  }
X  wget_name(w, type);
X  if ((type_index = spirit_type_index(type)) < 0) {
X    statline2_err("couldn't find a spirit of that type. hit space.", "summon");
X    return;
X  }
X    /* get the spirit pointer from the list of available spirits */
X  while (spiritp && (strcmp(type, spiritp->type) != 0)) {
X    spiritp = spiritp->next;
X  }
X  if (spiritp == NULL) {
X    statline2_err("That is not available to you. hit space.", "summon");
X    return;
X  }
X    /* now see if they can afford it */
X  if (spiritp->cost > up->np->spell_pts) {
X    statline2_err("you do not have enough spell points. hit space.", "summon");
X    return;
X  }
X  if (w) {
X    mvwprintw(w, 3, 1, "Give a name to your spirit (default %s: ", type);
X  } else {
X    statline("Give name: ", "summon");
X    move(LINES-1, strlen("Give name: "));
X  }
X  if (wget_name(w, name) <= 0) {
X    sprintf(name, "%s", type);
X  }
X  exec_summon(type_index, name);
X  statline2_err("spirit has been summoned, hit space to get back", "summon");
X}
X
X  /* initiates a mage */
Xinitiate_mage(up, w)
X     Suser *up;
X     WINDOW *w;
X{
X  char c;
X  char name[NAMELEN], s[NAMELEN];
X  Ssector *sp;
X  char def_name [NAMELEN];
X
X  strcpy(help_tag, "Mages");
X  sp = &world.map[user.cursor.x][user.cursor.y];
X  if ((sp->designation != D_CITY && sp->designation != D_UNIVERSITY
X      && sp->designation != D_TEMPLE && sp->designation != D_CAPITAL)
X      || (sp->owner != user.id)) {
X    statline2_err("must initiate in *your* city/univ/temple. hit space.",
X	      "initiate_mage");
X    return;
X  }
X  name[0] = '\0';
X  if (w) {
X    mvwprintw(w, 3, 1,
X	      "initiation costs %d jewels.  go ahead (y/n)? ",
X	      INITIATION_JEWELS);
X    wrefresh(w);
X  } else {
X    sprintf(s, "costs %d jewels.  go ahead (y/n)? ", INITIATION_JEWELS);
X    statline(s, "initiate");
X    move(LINES-1, strlen(s));
X  }
X  c = getchar();
X  if (c == '?') {
X    online_info();
X  }
X  if (c != 'y' && c != 'y') {
X    return;
X  }
X  if (up->np->jewels < INITIATION_JEWELS) {
X    statline2_err("You do not have enough jewels. hit space.","initiate_mage");
X    return;
X  }
X  if (next_thon_jewels (up->np) - MAGE_JEWELS_MAINT < 0) {
X    statline2_err ("You would have negative jewels next thon.  hit space.",
X		   "initiate_mage");
X    return;
X  }
X
X  sprintf (def_name, "Mage");
X  sprintf (s, "Name (default \"%s\"): ", def_name);
X
X  if (w) {
X    mvwprintw(w, 4, 1,"Give a name to your new mage (default \"%s\"): ",
X	      def_name);
X  } else {
X    statline(s, "initiate");
X    move(LINES-1,strlen (s));
X  }
X  if ((wget_name(w, name)) == NULL) {
X    strcpy (name, def_name);
X  }
X    /* if we got this far, it means that the initiation is valid */
X  exec_initiate(name);
X  statline2_err("mage has been initiated, hit space to get back",
X		"initiate_mage");
X}
X
X  /* list a user's spells */
Xlist_spells(up)
X     Suser *up;
X{
X  Sspell *spells = up->spell_list;
X  WINDOW *listw;
X  int i, n_spells = 0;
X
X  while (spells != NULL) {
X    spells = spells->next;
X    ++n_spells;
X  }
X  listw = newwin(n_spells+3, NAMELEN, 2, 37);
X  box(listw, '|', '-');
X  wstandout(listw);
X  mvwaddstr(listw, 0, 2, "Spell");
X  wstandend(listw);
X  waddstr(listw, "(cost,time)");
X  spells = up->spell_list;
X  for (i = 0; i < n_spells; ++i) {
X    mvwprintw(listw, i+2, 1, "%s(%d,%d)",
X	      spells->name, spells->cost, spells->duration);
X    spells = spells->next;
X  }
X  wrefresh(listw);
X  delwin(listw);
X}
X
X  /* list a user's spirits */
Xlist_spirits(up)
X     Suser *up;
X{
X  Sspirit *spirits = up->spirit_list;
X  int n_spirits = 0, i;
X  WINDOW *listw;
X
X  while (spirits != NULL) {
X    spirits = spirits->next;
X    ++n_spirits;
X  }
X  listw = newwin(n_spirits+3, NAMELEN, 2, 7);
X  box(listw, '|', '-');
X  wstandout(listw);
X  mvwaddstr(listw, 0, 4, "Spirit");
X  wstandend(listw);
X  waddstr(listw, "(cost)");
X  spirits = up->spirit_list;
X    /* run through the list and print them out */
X  for (i = 0; i < n_spirits; ++i) {
X    if (spirit_type_index(spirits->type) >= 0) {
X      mvwprintw(listw, i+2, 1, "%s(%d)", spirits->type, spirits->cost);
X    }
X    spirits = spirits->next;
X  }
X  wrefresh(listw);
X  delwin(listw);
X}
X
Xcast_spell(up, w)
X     Suser *up;
X     WINDOW *w;
X{
X  Sspell *slist = up->spell_list;
X  char name[NAMELEN], s[NAMELEN];
X  Sarmy *ap, *get_army();
X  int cost;
X
X  if ((ap = get_army(up->np, up->current_army)) == NULL  ||  !is_mage(ap) ) {
X    statline2_err("only mages can cast spells. hit space.", "cast_spell");
X    return;
X  }
X  if (w) {
X    mvwprintw(w, 4, 1, "which spell do you want to cast? ");
X  } else {
X    statline_prompt("Which spell? ", "cast_spell");
X  }
X  wget_name(w, name);
X  while (slist != NULL) {
X    if (strcmp(slist->name, name) == 0) {
X      break;			/* found it */
X    }
X    slist = slist->next;
X  }
X  if (slist == NULL) {
X    statline2_err("no spell by that name. hit space.", "cast_spell");
X    return;
X  }
X  if (slist->cost > 0 && slist->cost > up->np->spell_pts) {
X    statline2_err("you do not have enough spell points. hit space.",
X		  "cast_spell");
X    return;
X  }
X    /* if we got this far, it means that the spell is valid */
X  cost = exec_spell(slist, w);
X  show_armies(&world.map[up->cursor.x][up->cursor.y]);
X  if (cost > 0) {
X    statline2_err("spell has been cast, hit space to get back", "cast_spell");
X  }
X}
X
X  /* this sets up the spirit as a new army */
Xexec_summon(type_index, name)
X     int type_index;
X     char name[];
X{
X  Sarmy army, make_army();
X  Ssector *sp = &world.map[user.cursor.x][user.cursor.y];
X  char s[EXECLEN];
X
X  army = make_army(spirit_types[type_index].type, name,
X		   spirit_types[type_index].size, A_DEFEND,
X		   user.np->id, sp->loc);
X  army.id = free_army_id(user.np);
X   /* spirits cost spell points to draft *and* maintain (set in make_army) */
X  army.next = NULL;
X  army.flags = spirit_types[type_index].flags;
X    /* now insert it into the list */
X  ++user.np->n_armies;
X  if (user.np->armies == NULL) { /* special case:  empty list */
X    user.np->armies = (Sarmy *) malloc(sizeof(Sarmy));
X    *(user.np->armies) = army;
X    user.np->armies->next = NULL;
X  } else {
X    insert_army_nation(user.np, &army, -1);
X  }
X  insert_army_sector(sp, &army);
X  user.np->spell_pts -= spirit_types[type_index].spell_pts_draft;
X  cspell_pts(user.np, -spirit_types[type_index].spell_pts_draft);
X    /* now prepare the exec string for making the army and costs */
X  sprintf(s, "AMAKE:%d:%d:%d:%d:%s:%s\n", army.id, army.n_soldiers,
X	  army.pos.x, army.pos.y, army.type, army.name);
X  gen_exec(s);
X    /* now a last detail:  the "current_army" variable
X       must be set (like in draft_army())
X     */
X  if (user.current_army == -1) {
X    user.current_army = first_sect_army(sp);
X  }
X  show_armies(sp);
X}
X
X  /* this sets up the mage as a new army */
Xexec_initiate(name)
X     char name[];
X{
X  Sarmy army, make_army();
X  Ssector *sp = &world.map[user.cursor.x][user.cursor.y];
X  char s[EXECLEN];
X
X  army = make_army("Mage", name, 1, A_DEFEND,
X		   user.np->id, sp->loc);
X    /* now give the mage maintainance costs */
X  army.jewel_maint = 1000;
X/*  army.spell_pts_maint = 1; */
X  army.id = free_army_id(user.np);
X  army.flags |= AF_WIZARD;
X  army.next = NULL;
X    /* now insert it into the list */
X  ++user.np->n_armies;
X  if (user.np->armies == NULL) { /* special case:  empty list */
X    user.np->armies = (Sarmy *) malloc(sizeof(Sarmy));
X    *(user.np->armies) = army;
X    user.np->armies->next = NULL;
X  } else {
X    insert_army_nation(user.np, &army, -1);
X  }
X  insert_army_sector(sp, &army);
X  user.np->jewels -= INITIATION_JEWELS;
X  cjewels(user.np, -INITIATION_JEWELS);
X    /* now prepare the exec string for making the army and costs */
X  sprintf(s, "AMAKE:%d:%d:%d:%d:%s:%s\n", army.id, army.n_soldiers,
X	  army.pos.x, army.pos.y, army.type, army.name);
X  gen_exec(s);
X  aflag_set(&army, AF_WIZARD);
X/*  sprintf(s, "%d:%d", army.id, AF_WIZARD); */
X/*  aflag_set(&army, AF_NOFIGHT); */
X    /* now a last detail:  the "current_army" var must be set
X       (like in draft_army())
X     */
X  if (user.current_army == -1) {
X    user.current_army = first_sect_army(sp);
X  }
X  show_armies(sp);
X}
X
X  /* make a window to show user her/his hanging spells */
Xshow_hanging_spells(up)
X     Suser *up;
X{
X  WINDOW *sw;
X  int done = 0, i;
X  Sh_spell *h_list;		/* list of hanging spells for this user */
X
X  strcpy(help_tag, "Spells");
X  statline("Hit space to get back", "show_hanging_spells");
X  sw = newwin(20, 30, 2, 2);
X  while (!done) {
X    mvwprintw(sw, 1, 1, "     Spell       thons");
X    wclrtobot(sw);
X    if (up->id == 0) { waddstr(sw, " (nat)"); }
X    mvwprintw(sw, 2, 1, "   --------       --- ");
X    if (up->id == 0) { waddstr(sw, "  --- "); }
X    for (i = 0, h_list = up->h_spells; h_list != NULL;
X	 ++i,h_list = h_list->next) {
X      mvwprintw(sw, 3+i, 1, " %2d %-12.12s  %2d", i, h_list->name,
X		h_list->thons_left);
X      if (up->id == 0) { wprintw(sw, "    %3d", h_list->nat_id); }
X      wclrtoeol(sw);
X    }
X    mvwaddstr(sw, 18, 1, " [z]oom, [d]elete ");
X    wclrtoeol(sw);
X    box(sw, '|', '-');
X    wrefresh(sw);
X    switch(getch()) {
X    case 'z':
X      zoom_on_h_spell(up->h_spells, sw);
X      break;
X    case 'd':
X      zoom_del_h_spell(up->h_spells, sw);
X      break;
X
X    case ' ':
X      done = 1;
X      break;
X    case '?':
X      online_info();
X      break;
X    default:
X      break;
X    }
X  }
X  delwin(sw);
X  touch_all_wins();
X}
X
X  /* allows the user to focus on a specific spell */
Xzoom_on_h_spell(h_list, sw)
X     Sh_spell *h_list;
X     WINDOW *sw;
X{
X  WINDOW *zoomw;
X  int n, i;
X  char s[EXECLEN];
X
X    /* first ask the user which spell s/he wants to see */
X  mvwaddstr(sw, 18, 1, " On which spell? ");
X  wclrtoeol(sw);
X  box(sw, '|', '-');
X  wrefresh(sw);
X  if (wget_number(sw, &n) < 0 || n < 0) {
X    return -1;
X  }
X  for (i = 0; h_list && i < n; ++i) {
X    h_list = h_list->next;
X  }
X  if (h_list == NULL) {
X    return -1;
X  }
X    /* then zoom in on it */
X  zoomw = newwin(h_list->n_lines/2+3, 30, 4, 25);
X  mvwprintw(zoomw, 1, 3, " Spell <%s>  ", h_list->name);
X  for (i = 0; i < h_list->n_lines; i += 2) {
X      /* now insert the hiding of coordinates */
X    strcpy(s, h_list->lines[i]);
X    fix_sector_line(h_list->lines[i], s);
X    mvwprintw(zoomw, i/2+2, 1, " %s", s);
X  }
X  box(zoomw, '|', '-');
X  wrefresh(zoomw);
X  statline2_err("Hit space to return", "zoom_on_h_spell");
X  delwin(zoomw);
X  return 1;
X}
X
X  /* fix the exec line if it has references to a sector by
X     absolute coordinates.  put the "censored" line into s.
X     this is quite a hack, what?
X   */
Xfix_sector_line(line, s)
X     char line[], s[];
X{
X  int xabs, yabs, x_rel, y_rel, arg;
X  char *s2, s3[EXECLEN];	/* for temporary work */
X
X    /* if there is no '_', then just return */
X  if ((s2 = strrchr(line, '_')) == NULL) {
X    strcpy(s, line);
X    return;
X  }
X    /* the convention is, if the exec line ends with "_SECTOR"
X       then the first 2 numbers are the x and y coordinates.
X     */
X  if (strncmp(s2+1, "SECTOR", strlen("SECTOR")) != 0) {
X    strcpy(s, line);
X    return;
X  }
X    /* for now make the gross assumption that
X       the only arguments are x, y and a third "arg"
X     */
X  s2 = line;
X  s2 = strchr(s2, ':')+1;
X  sscanf(s2, "%d", &xabs);
X  s2 = strchr(s2, ':')+1;
X  sscanf(s2, "%d", &yabs);
X  s2 = strchr(s2, ':')+1;
X  sscanf(s2, "%d", &arg);
X  if (user.id == 0) {
X    x_rel = xabs;
X    y_rel = yabs;
X  } else {
X    x_rel = xrel(xabs, yabs, user.np->capital);
X    y_rel = yrel(xabs, yabs, user.np->capital);
X  }
X  /*    sprintf(s3, "%d:%d:%d\n", xabs, yabs, arg); (debug) */
X  sprintf(s3, ":%d:%d:%d\n", x_rel, y_rel, arg);
X  strcpy(strchr(s, ':'), s3);
X  /*    statline(s, "final s, hit space"); */
X}
X
Xzoom_del_h_spell(h_list, sw)
X     Sh_spell *h_list;
X     WINDOW *sw;
X{
X  WINDOW *zoomw;
X  int n, i;
X  char s[EXECLEN];
X
X    /* first ask the user which spell s/he wants to see */
X  mvwaddstr(sw, 18, 1, " Remove which spell? ");
X  wclrtoeol(sw);
X  box(sw, '|', '-');
X  wrefresh(sw);
X  if (wget_number(sw, &n) < 0 || n < 0) {
X    return -1;
X  }
X  for (i = 0; h_list && i < n; ++i) {
X    h_list = h_list->next;
X  }
X  if (h_list == NULL) {
X    return -1;
X  }
X
X  delete_hanging_spell(h_list);
X  return 1;
X}
X
END_OF_FILE
if test 19167 -ne `wc -c <'menus.c'`; then
    echo shar: \"'menus.c'\" unpacked with wrong size!
fi
# end of 'menus.c'
fi
if test -f 'npclib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'npclib.c'\"
else
echo shar: Extracting \"'npclib.c'\" \(17716 characters\)
sed "s/^X//" >'npclib.c' <<'END_OF_FILE'
X   /* nplib.c -- modules involved in NPC movemaking */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X#ifdef SYSV
X# include <string.h>
X#else
X# include <strings.h>
X#endif /* SYSV */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X#include <math.h>
X#include <curses.h>
X#include <stdio.h>
X#include <ctype.h>
X#include <signal.h>
X
X#define CUTOFF1 -30		/* army bonus for draft cutoff 1 (npc_draft) */
X#define CUTOFF2 0		/* army bonus for draft cutoff 2 (npc_draft) */
X
Xextern Sworld world;
Xextern Suser user;
Xextern struct s_desig_map desig_map[];
Xextern int (*wrapx)(), (*wrapy)();
Xextern int debug;
Xextern struct army_type *army_types;
Xextern struct spirit_type *spirit_types;
X
Xextern float npc_food_need,npc_metal_need,npc_jewel_need,npc_money_need;
Xextern int opt_army_size,atwar,npc_specific;
X
X/*--------------------find_visible_sectors()-------------------------------
X   NOTE: the following routine copied from user.c to avoid fiddling with
X   the Makefile and increasing the size of dom_update.  One difference,
X   viewall is not used. 
X
X   this routine goes through the entire map and figures out
X   which sectors are visible by the user.
X---------------------------------------------------------------------------*/
X/*
Xfind_visible_sectors(visible_sectors)
X     int **visible_sectors;
X{
X  int x, y, i, j;
X  struct pt_list *plist;
X  Sarmy *ap;
X  Ssector *sp;
X
X  for (i = 0; i < world.xmax; ++i) {
X    for (j = 0; j < world.ymax; ++j) {
X      visible_sectors[i][j] = SEE_NOTHING;
X    }
X  }
X  for (plist = user.np->ptlist; plist != NULL; plist = plist->next) {
X    x = plist->pt.x;
X    y = plist->pt.y;
X    visible_sectors[x][y] = SEE_ALL;
X    for (i = x-LAND_SIGHT; i <= x+LAND_SIGHT; ++i) {
X      for (j = y-LAND_SIGHT; j <= y+LAND_SIGHT; ++j) {
X	sp = &world.map[(*wrapx)(i,j)][(*wrapy)(i,j)];
X	if (has_hidden(sp) && sp->owner != user.id) {
X	  visible_sectors[x][y] |= SEE_ARMIES;
X	} else {
X	  visible_sectors[(*wrapx)(i,j)][(*wrapy)(i,j)] |=
X	    (SEE_LAND_WATER | SEE_OWNER | SEE_DESIG | SEE_POPULATION);
X	}
X	if (world.map[(*wrapx)(i,j)][(*wrapy)(i,j)].owner == 0) {
X	  visible_sectors[(*wrapx)(i,j)][(*wrapy)(i,j)] |= SEE_RESOURCES;
X	}
X      }
X    }
X  }
X  for (ap = user.np->armies; ap != NULL; ap = ap->next) {
X    x = ap->pos.x;
X    y = ap->pos.y;
X    sp = &world.map[x][y];
X    if (has_hidden(sp) && sp->owner != user.id) {
X      visible_sectors[x][y] = SEE_ARMIES;
X    } else {
X      visible_sectors[x][y] = SEE_ALL;
X    }
X    for (i = x-ARMY_SIGHT; i <= x+ARMY_SIGHT; ++i) {
X      for (j = y-ARMY_SIGHT; j <= y+ARMY_SIGHT; ++j) {
X	sp = &world.map[(*wrapx)(i,j)][(*wrapy)(i,j)];
X	if (!has_hidden(sp)) {
X	  visible_sectors[(*wrapx)(i,j)][(*wrapy)(i,j)] |=
X	    (SEE_LAND_WATER | SEE_OWNER | SEE_DESIG |
X	     SEE_POPULATION | SEE_ARMIES);
X	}
X	if (world.map[(*wrapx)(i,j)][(*wrapy)(i,j)].owner == 0) {
X	  visible_sectors[(*wrapx)(i,j)][(*wrapy)(i,j)] |= SEE_RESOURCES;
X	}
X      }
X    }
X  }
X}
X*/
X/*------------------------------get_good_types()-----------------------------
X	This function fills an array with the indexed to army_types that will
Xbe good for this npc.
X	Basically, the npc will only draft armies like spearmen and cavemen
Xwhen it is in desperate straits.  For now, npc's will not draft transports,
Xwater-walk armies, kamikaze armies, front-line armies, or machines, because
Xhandling these well is beyond me at this point.
X	The npc decides whether or not to draft armies with low bonuses based
Xon the proportion of current#of troops to desired #of troops.  The desired
Xis  civilians * npc_agg/200 when at war, and civil. * npc_agg/300 otherwise.
XThe cutoffs are 25+npc/2 % and npc/2 %, for armies with -1 to -30 bonuses and
Xarmies with <-30 bonuses, respectively.
X	For example, a nation with an aggressiveness of 50 and a civilian
Xpopulation of 10,000 will not draft cavemen when it has more than 625 soldiers,
Xand will not draft spearmen when it has more than 1250 soldiers, and will not
Xdraft at all when it has more than 2500 soldiers. (when at war)
X---------------------------------------------------------------------------*/
Xget_good_types(good_armies,current,cut1,cut2)
Xint good_armies[MAX_TYPES];
Xint current,cut1,cut2;	/* current # of troops and cutoffs */
X{
X  Savail_army *tmp_avail;
X  struct army_type this_atype;
X  int type_index,ngood = 0,badflags;
X
X  badflags = AF_WATER |  AF_LAND | AF_INVERSE_ALT | AF_KAMIKAZE | AF_FRONT_LINE
X	   | AF_MACHINE | AF_CARGO | AF_WIZARD;
X
X  for(tmp_avail = user.avail_armies;tmp_avail ; tmp_avail = tmp_avail->next){
X    type_index = army_type_index(tmp_avail->type);
X    this_atype = army_types[type_index];
X    if (this_atype.flags & badflags)
X	 continue;
X    if(this_atype.bonus < CUTOFF1 && current > cut1)
X      continue;
X    else if(this_atype.bonus < CUTOFF2 && current > cut2)
X      continue;
X		/* replace army type with race-specific type if appropriate */
X    if(npc_specific &&
X	army_types[npc_specific-1].bonus >= this_atype.bonus &&
X	this_atype.bonus >= 0)
X      good_armies[ngood++] = npc_specific - 1;
X    else
X      good_armies[ngood++] = type_index;
X    }
X  if (debug)
X    printf("ngood = %d\n",ngood);
X  return(ngood);
X}
X
X/*---------------------------tmp_army_better()-------------------------------
X	This function checks tmpap and oldap to see if tmpap would be better
Xfor ap to merge with.  Better is defined as big enough after the merge
Xto take sectors, but smaller after the merge than the other army.
XThis is a crude way of preventing one army from growing too large.
XEdit to your heart's content, if you think it will make the npc's better.
X	(This function is called by npc_merge)
X------------------------------------------------------------------------*/
Xtmp_army_better(ap,tmpap,oldap)
XSarmy *ap,*tmpap,*oldap;
X{
X  if(strcmp(tmpap->type,ap->type)){	/* different types */
X    return(0);
X  }
X  
X  if(!oldap)				/* anything is better than nothing */
X    return(1);
X
X  if(tmpap->n_soldiers + ap->n_soldiers < opt_army_size)
X    return(0);				/* already have oldap */
X
X  if(tmpap->n_soldiers < oldap->n_soldiers)
X    return(1);				/* enough soldiers but not too big */
X  else
X    return(0);				/* too big */
X}
X
X/*---------------------------find_desire()------------------------------------
X	Fill the desire array with the desireability for each sector on the
Xmap.  The base desire goes from zero to half the length of the shortest side.
XTo find the final desire, the base desire is squared.  The desire for the
Xsurrounding sectors is modified.  If the base desire is N, then all the
Xadjacent sectors have their desireability increased by N-1, the next sectors
Xout are increased by N-2, etc.  This will hopefully keep npc's moving in the
Xright general direction. (the base desire of owned sectors is 0, unless at war)
X---------------------------------------------------------------------------*/
Xfind_desire(np,des_array)
XSnation *np;
Xstruct desire{
X	int base,final;
X	} **des_array;
X{
X  int x,y,i,d;
X
X  for(x = 0; x < world.xmax;x++)
X    for(y = 0; y < world.ymax; y++){
X      des_array[x][y].base = npc_des(np,x,y);
X      des_array[x][y].final = 0;
X    }
X
X  for(x = 0; x < world.xmax;x++)
X    for(y = 0; y < world.ymax; y++){
X      d = des_array[x][y].base;
X      des_array[x][y].final += d*d;
X      if(atwar && d > 0){		/* sector owned by us or enemy */
X        des_array[x][y].final += world.map[x][y].n_people/25;
X        if (world.map[x][y].designation == D_CAPITAL) 
X          des_array[x][y].final *= 2;
X        }
X      if(user.visible_sectors[x][y])
X        for(i = 1;i < d && add_square(x,y,i,d-i,des_array,np);i++);
X      }
X/* This makes a big mess--------
X    if(debug){
X    for(y = 0; y < world.ymax; y++){
X      for(x = 0; x < world.xmax;x++)
X        printf("%2d,",des_array[x][y].base);
X      printf("\n");
X    }
X    for(y = 0; y < world.ymax; y++){
X      for(x = 0; x < world.xmax;x++)
X        printf("%3d,",des_array[x][y].final);
X      printf("\n");
X    }
X  } */
X}
X
X/*-------------------------------npc_des()-------------------------------------
X	This function calculates the desireability of a sector to an npc.
XThis desireability will be calculated differently when the npc is at war
Xthan when it is at peace.  For now, just try to expand.
X-----------------------------------------------------------------------------*/
Xnpc_des(np,x,y)
XSnation *np;
Xint x,y;
X{
X  int num,i,j,dstat;
X  Sdiplo **dm;
X
X  if(!good_altitude(&world.map[x][y],np))
X    return(0);
X
X  if(atwar && world.map[x][y].owner){
X    dm = user.diplo_matrix;
X    dstat = get_diplo_status(dm, np->id, world.map[x][y].owner);
X    if(world.map[x][y].owner != np->id && (dstat != WAR && dstat != JIHAD))
X  	return(0);
X  } else if (world.map[x][y].owner == np->id)
X    return (0);
X
X  if(atwar && world.map[x][y].owner){
X    if(world.map[x][y].owner == np->id){
X      switch(world.map[x][y].designation){
X        case D_FARM:
X          num = 3 + world.map[x][y].soil * npc_food_need;
X	  break;
X        case D_METAL_MINE:
X          num = 3 + world.map[x][y].metal * npc_metal_need;
X	  break;
X        case D_JEWEL_MINE:
X          num = 3 + world.map[x][y].jewels * npc_jewel_need;
X	  break;
X        case D_CITY: case D_UNIVERSITY:
X          num = 11;
X	  break;
X	case D_CAPITAL:
X	  num = 8 + np->npc_agg / 10;
X	  break;
X        default:
X	  break;
X        }
X      }
X    else{
X      num = 12;
X  /*    switch(world.map[x][y].designation){
X        case D_FARM:
X          num = 8 * npc_food_need;
X	  break;
X        case D_METAL_MINE:
X          num = 8 * npc_metal_need;
X	  break;
X        case D_JEWEL_MINE:
X          num = 8 * npc_jewel_need;
X	  break;
X        case D_CITY: case D_UNIVERSITY: case D_CAPITAL:
X	  num = 12;
X	  break;
X        default:
X	  num = 7;
X	  break;
X        } */
X  
X      for(i = -1;i < 2;i++)
X        for(j = -1;j < 2;j++)
X          if(world.map[(*wrapx)(x+j,y+i)][(*wrapy)(x+j,y+i)].owner == np->id)
X            num++;
X      /* if(world.map[x][y].n_people >= 0)
X        num += sqrt((double)world.map[x][y].n_people)/5.0; */
X      }
X    }
X  
X  else{
X    num = world.map[x][y].soil * npc_food_need;
X    num += world.map[x][y].metal * npc_metal_need;
X    num += world.map[x][y].jewels * npc_jewel_need;
X    for(i = -1;i < 2;i++)
X      for(j = -1;j < 2;j++)
X        if(world.map[(*wrapx)(x+j,y+i)][(*wrapy)(x+j,y+i)].owner == np->id)
X          num++;
X  }
X
X/*  if(atwar && !world.map[x][y].owner)
X    return(num/4);
X  else */
X  num = min ( num, min (world.xmax, world.ymax) );
X    return(num/2);
X}
X
X/*----------------------------add_square()---------------------------------
X	This function adds a number, add to the desireability of the sectors
Xradius away from x,y.  Radius is defined rather loosely here, since the sectors
Xform a square.
X---------------------------------------------------------------------------*/
Xadd_square(x,y,radius,add,des_array,np)
Xint x,y,radius,add;
Xstruct desire{
X	int base,final;
X	} **des_array;
XSnation *np;
X{
Xint i,tx,ty,id,flag = 0;
XSsector *sp;
X
X  id = np->id;
X  tx = x-radius;			/* bottom side from lower left corner */
X  ty = y-radius;
X  for(i = 0; i < radius*2;i++){
X    sp = &world.map[(*wrapx)(tx+i,ty)][(*wrapy)(tx+i,y)];
X    if(!good_altitude(sp,np))
X      flag++;
X    des_array[(*wrapx)(tx+i,ty)][(*wrapy)(tx+i,ty)].final += add;
X  }
X
X  ty = y+radius;			/* left side from upper left corner */
X  for(i = 0; i < radius*2;i++){
X    sp = &world.map[(*wrapx)(tx,ty-i)][(*wrapy)(tx-i,y-i)];
X    if(!good_altitude(sp,np))
X      flag++;
X    des_array[(*wrapx)(tx,ty-i)][(*wrapy)(tx,ty-i)].final += add;
X  }
X
X  tx = x+radius;			/* top side from upper right corner */
X  for(i = 0; i < radius*2;i++){
X    sp = &world.map[(*wrapx)(tx-i,ty)][(*wrapy)(tx-i,y)];
X    if(!good_altitude(sp,np))
X      flag++;
X    des_array[(*wrapx)(tx-i,ty)][(*wrapy)(tx-i,ty)].final += add;
X  }
X
X  ty = y-radius;			/* right side from lower right corner */
X  for(i = 0; i < radius*2;i++){
X    sp = &world.map[(*wrapx)(tx,ty+i)][(*wrapy)(tx,y+i)];
X    if(!good_altitude(sp,np))
X      flag++;
X    des_array[(*wrapx)(tx,ty+i)][(*wrapy)(tx,ty+i)].final += add;
X  }
X
X  return((flag > 4*radius) ? 0:1);	/* equal to zero if lots of water */
X}
X
X/*----------------------------check_moves()-----------------------------------
X	Ary represents the area of the map centered at the army ap.  This
Xfunction fills ary with the maximum movepoints the army can have left when
Xit arrives at the sector.  Of course, routes that are outside of the section
Xof the map in ary are not considered, so a larger value for NPC_SIDE will
Xsometimes result in better movement.  However, since the algorithm includes
Xan insertion, it's best to keep the value small in the interest of time.
X--------------------------------------------------------------------------*/
Xcheck_moves(np,ap,ary)
XSnation *np;
XSarmy *ap;
Xstruct tmp_map{
X  int mvcost,mvleft;
X  } ary[NPC_SIDE][NPC_SIDE];
X{
X  int i,j,k;
X  int x,y,tx,ty,mapx,mapy;
X  int mv,mvleft;
X  int head=0,tail=0;
X  struct mvlist{
X    int mv;
X    Pt pos;
X  } list[NPC_SIDE * NPC_SIDE];	/* doesn't really need to be this big */
X  Ssector *sect;
X
X  for(x = 1; x < NPC_SIDE-1; x++)
X  for(y = 1; y < NPC_SIDE-1; y++){
X    tx = x - (NPC_VIEW+1) + ap->pos.x;	/* translate ary */
X    ty = y - (NPC_VIEW+1) + ap->pos.y;	/* coords to map */
X    sect = &world.map[(*wrapx)(tx,ty)][(*wrapy)(tx,ty)];
X    ary[x][y].mvleft = -1;
X    ary[x][y].mvcost = get_army_move_cost(np,sect,ap);
X  }
X 
X  for(i = 0;i < NPC_SIDE * NPC_SIDE;i++)	/* initialize list of points */
X  list[i].mv = 0;
X 
X  /* start army in center of ary with whatever movement it has */
X  ary[NPC_VIEW+1][NPC_VIEW+1].mvleft = ap->mvpts;
X  list[0].mv = ap->mvpts;
X  list[0].pos.x = NPC_VIEW+1;
X  list[0].pos.y = NPC_VIEW+1;
X
X  for(head = 0; list[head].mv; head++){		/* until list is empty */
X    mv = list[head].mv;
X    for(x = list[head].pos.x-1;x <= list[head].pos.x + 1;x++)
X      for(y = list[head].pos.y-1;y <= list[head].pos.y + 1;y++)
X        if(ary[x][y].mvleft == -1 && ary[x][y].mvcost <= mv){
X          mvleft = mv - ary[x][y].mvcost;
X          ary[x][y].mvleft = mvleft;
X          if(mvleft){
X            for(j = tail;list[j].mv < mvleft;j--);
X            for(k = tail;k > j;k--)
X              list[k+1] = list[k];
X            list[j+1].mv = mvleft;
X            list[j+1].pos.x = x;
X            list[j+1].pos.y = y;
X            tail++;
X          }
X        }
X    }
X
Xif(debug){
X  printf("ary for army %d= :\n",ap->id);
X  for(y = 0; y < NPC_SIDE; y++){
X    for(x = 0;x < NPC_SIDE;x++)
X      printf("[%d,%d],",ary[x][y].mvleft,ary[x][y].mvcost);
X    printf("\n");
X    }
X  }
X}
X
X/*--------------------------do_npc_diplo()------------------------------------
X	Update the diplomacy for npcs.  Change the diplomacy according to
Xa random number, and the npc aggressiveness.  If the number is less than
Xthe npc aggressiveness, then the diplomacy status goes down.  Otherwise
Xit goes up.
X---------------------------------------------------------------------------*/
Xdo_npc_diplo(np)
X     Snation *np;
X{
X  int i,dip_from,dip_to,num,up,down;
X  Snation *tmpnp;
X  
X  /* Take care of NPC diplomacy here */
X  
X  atwar = 0;
X  for(i = 1;i < world.n_nations;i++){
X    tmpnp = &world.nations[i];
X    if (is_active_ntn(tmpnp) && (!tmpnp->npc_flag || NPC_FIGHT)) { 
X      if (!have_met(user.diplo_matrix, np->id, i))
X        continue;
X      dip_to = get_diplo_status(user.diplo_matrix, np->id, i);
X      dip_from = get_diplo_status(user.diplo_matrix, i, np->id);
X      if (debug)
X	printf("from = %d, to = %d\n",dip_from,dip_to);
X      down = np->npc_agg * DIP_CHANGE / 100;
X      up = (100 - np->npc_agg) * DIP_CHANGE / 100;
X      num = RND()%100;
X      if (debug)
X	printf("num = %d ",num);
X      if(num < np->npc_agg){
X        if(num < down/2 || dip_from < dip_to)
X          dip_to--;
X        if(num < down)
X	  dip_to--;
X	}
X      else{
X	num = 100 - num;
X        if(num < up/2)
X	  dip_to++;
X        if(num < up)
X	  dip_to++;
X	}
X      if(dip_to > dip_from)
X        dip_to = dip_from;
X      dip_to = max(dip_to,JIHAD);
X      if (debug)
X	printf("up = %d, down = %d, newto = %d\n",up,down,dip_to);
X      if(dip_to == WAR || dip_to == JIHAD)
X        atwar = 1;
X      set_diplo_status(user.diplo_matrix,np->id,i,dip_to);
X      }
X    }
X  dump_diplo(np,user.diplo_matrix, world.n_nations);
X}
X
X/*---------------------------init_npc_mage()-----------------------------------
X	Initiate a mage for the npc.  Copied from menus.c
X-----------------------------------------------------------------------------*/
Xinit_npc_mage(np,sp)
XSnation *np;
XSsector *sp;
X{
X  Sarmy army, make_army();
X
X  army = make_army("Mage", "Mage", 1, A_DEFEND, np->id, sp->loc);
X  army.jewel_maint = 1000;
X  army.id = free_army_id(np);
X  army.flags |= AF_WIZARD;
X  army.next = NULL;
X    /* now insert it into the list */
X  np->n_armies++;
X  if (np->armies == NULL) { /* special case:  empty list */
X    np->armies = (Sarmy *) malloc(sizeof(Sarmy));
X    *(np->armies) = army;
X    np->armies->next = NULL;
X  } else {
X    insert_army_nation(np, &army, -1);
X  }
X  insert_army_sector(sp, &army);
X  np->jewels -= INITIATION_JEWELS;
X}
END_OF_FILE
if test 17716 -ne `wc -c <'npclib.c'`; then
    echo shar: \"'npclib.c'\" unpacked with wrong size!
fi
# end of 'npclib.c'
fi
echo shar: End of archive 22 \(of 28\).
cp /dev/null ark22isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Now execute ./do_cat.sh to build doc files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
