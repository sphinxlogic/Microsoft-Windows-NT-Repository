Path: uunet!ogicse!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i050:  dominion - a multi-player world simulation game, Part14/28
Message-ID: <2453@masterCNA.TEK.COM>
Date: 11 Feb 92 18:24:48 GMT
Article-I.D.: masterCN.2453
Sender: news@masterCNA.TEK.COM
Lines: 1972
Approved: billr@saab.CNA.TEK.COM

Submitted-by: rosalia@dirac.physics.sunysb.edu (Mark Galassi)
Posting-number: Volume 13, Issue 50
Archive-name: dominion/Part14
Environment: Unix, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 14 (of 28)."
# Contents:  construct.c update.c
# Wrapped by billr@saab on Tue Feb 11 10:14:54 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'construct.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'construct.c'\"
else
echo shar: Extracting \"'construct.c'\" \(7273 characters\)
sed "s/^X//" >'construct.c' <<'END_OF_FILE'
X/* construct.c -- routines dealing with construction */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X#include "costs.h"
X#include "cur_stuff.h"
X
X#include <stdio.h>
X#include <math.h>
X
Xextern Suser user;
Xextern Sworld world;
Xextern char help_tag[];
Xextern WINDOW * sectw;
X
Xextern int (*wrapx)(), (*wrapy)();
X
X  /* construct a constructible object */
Xconstruct()
X{
X  WINDOW *cw;
X  char c;
X  int done=0;
X  Snation *np = user.np;
X  Ssector *sp =  &world.map[user.cursor.x][user.cursor.y];
X
X  strcpy(help_tag, "Construction");
X
X  if (user.xmode) {
X    cw = NULL;
X  } 
X  else {
X    cw = newwin(6, COLS/2+18, LINES-11, COLS/4-16);
X  }
X
X  while (!done) {
X    if (cw != NULL) {
X      statline("", "construct");
X      mvwprintw(cw, 1, 1, "What type of object do you want to construct? ");
X      mvwprintw(cw, 2, 1, " [f]ortification, [r]oads, [b]ubble");
X      wmove(cw, 3, 1);
X      wclrtobot(cw);
X      box(cw, '|', '-');
X      wrefresh(cw);
X    }
X    else {			/* expert mode */
X      statline_prompt ("Construct: (f,r,b)", "construct");
X    }
X
X    switch (c = mygetch()) {
X    case 'f':
X      construct_fortification(np, sp, cw);
X      break;
X    case 'r':
X      construct_roads(np, sp, cw);
X      break;
X    case 'b':
X      construct_bubble(np, sp, cw);
X      break;
X    case ' ':
X      done = 1;
X      break;
X    default:
X      break;
X    }
X  }
X
X  if (cw != NULL) {
X    wrefresh(cw);
X    delwin(cw);
X  }
X
X  touch_all_wins();
X  statline2("", "");
X  show_armies(sp);
X  return 1;
X}
X
X  /* build fortification on a sector */
Xconstruct_fortification(np, sp, w)
X     Snation *np;
X     Ssector *sp;
X     WINDOW *w;
X{
X  int fort_increase, ret, cost, cost_met;
X  char s[EXECLEN];
X  char c;
X
X  if (sp->owner != user.id) {
X    statline2_err("hit space to go on", "hey dude, this sector is not yours");
X    return -1;
X  }
X  cost = (int) (pow(2.0, (double) sp->defense/10)*FORT_COST_MONEY);
X  cost_met = (int) (pow(2.0, (double) sp->defense/10)*FORT_COST_METAL);
X
X  if (w != NULL) {
X    mvwprintw(w, 3, 1, "Current fort %d; cost for 10 more: %d sk., %d met.",
X	      sp->defense, cost, cost_met);
X    mvwprintw(w, 4, 1, "Build ten more (y/n)? ");
X    box(w, '|', '-');
X    wrefresh(w);
X  }
X  else {
X    sprintf (s, "Current: %d, Cost +10 = %d sk., %d met. Build? ",
X	     sp->defense, cost, cost_met);
X    statline2 (s, "con_fort");
X  }
X
X  if ((c = getch()) != 'y' && c != 'Y') {
X    statline2 ("", "");
X    return -1;
X  }
X  if (w == NULL) {
X    statline2 ("", "");
X  }
X  fort_increase = 10;
X    /* now see if we can afford the construction */
X  if (cost > user.np->money) {
X    statline2_err("space to go on", "not enough money to construct");
X    return -1;
X  }
X  if (cost_met > user.np->metal) {
X    statline2_err("space to go on", "not enough metal to construct");
X    return -1;
X  }
X
X  /* if we have reached this point, it means we can construct! */
X
X  sp->defense += fort_increase;
X  np->money -= cost;
X  np->metal -= cost_met;
X    /* now prepare the exec string */
X  sprintf(s, "CFORT_SECTOR:%d:%d:%d\n", sp->loc.x, sp->loc.y, fort_increase);
X  gen_exec(s);
X  cmoney(np, -cost);
X  cmetal(np, -cost_met);
X
X  return 1;
X}
X  /* build roads on a sector */
Xconstruct_roads(np, sp, w)
X     Snation *np;
X     Ssector *sp;
X     WINDOW *w;
X{
X  int roads_increase, ret, cost, cost_met;
X  char s[EXECLEN];
X  char c;
X
X  if (sp->owner != user.id) {
X    statline2_err("hit space to go on", "hey dude, this sector is not yours");
X    return -1;
X  }
X  cost = (int) (pow(2.0, (double) sp->roads)*ROADS_COST_MONEY);
X  cost_met = (int) (pow(2.0, (double) sp->roads)*ROADS_COST_METAL);
X
X  if (w != NULL) {
X    mvwprintw(w, 3, 1,
X	      "Current roads %d; cost %d sk., %d met.", sp->roads, cost, cost_met);
X    mvwprintw(w, 4, 1, "Build one more (y/n)? ");
X    box(w, '|', '-');
X    wrefresh(w);
X  }
X  else {
X    sprintf (s, "Current: %d, Cost +1 = %d sk., %d met. Build? ",
X	     sp->roads, cost, cost_met);
X    statline2 (s, "con_roads");
X  }
X  if ((c = getch()) != 'y' && c != 'Y') {
X    statline2 ("", "");
X    return -1;
X  }
X
X  if (w == NULL) {
X    statline2 ("", "");
X  }
X
X  roads_increase = 1;
X    /* now see if we can afford the construction */
X  if (roads_increase*cost > user.np->money) {
X    statline2_err("space to go on", "not enough money to construct");
X    return -1;
X  }
X  if (roads_increase*cost_met > user.np->metal) {
X    statline2_err("space to go on", "not enough metal to construct");
X    return -1;
X  }
X
X  /* if we have reached this point, it means we can construct! */
X
X  sp->roads += roads_increase;
X  np->money -= roads_increase*cost;
X  np->metal -= roads_increase*cost_met;
X    /* now prepare the exec string */
X  sprintf(s, "CROADS_SECTOR:%d:%d:%d\n", sp->loc.x, sp->loc.y, roads_increase);
X  gen_exec(s);
X  cmoney(np, -roads_increase*cost);
X  cmetal(np, -roads_increase*cost_met);
X
X  return 1;
X}
X
X  /* build a bubble on a sector; allowing a
X     race to live in a sector below (or above)
X     water, when they normally could not.
X   */
Xconstruct_bubble(np, sp, w)
X     Snation *np;
X     Ssector *sp;
X     WINDOW *w;
X{
X  int ret, cost, cost_met;
X  char s[EXECLEN];
X  char c;
X
X  if (sp->owner != user.id) {
X    statline2_err("hit space to go on", "Hey dude, this sector is not yours");
X    return -1;
X  }
X  if (has_bubble(sp)) {
X    statline2_err("hit space to go on", "There already is a bubble!");
X  }
X  cost = BUBBLE_COST;
X  cost_met = BUBBLE_COST_METAL;
X
X  if (w != NULL) {
X    mvwprintw(w, 3, 1, "Cost %d sk., %d met.", cost, cost_met);
X    mvwprintw(w, 4, 1, "Go ahead (y/n)? ");
X    box(w, '|', '-');
X    wrefresh(w);
X  }
X  else {
X    sprintf (s, "Cost = %d sk., %d met. Build? ",
X	     cost, cost_met);
X    statline2 (s, "con_bubble");
X  }
X  if ((c = getch()) != 'y' && c != 'Y') {
X    statline2 ("", "");
X    return -1;
X  }
X  if (w == NULL) {
X    statline2 ("", "");
X  }
X
X    /* now see if we can afford the construction */
X  if (cost > user.np->money) {
X    beep();
X    statline2_err("space to go on", "not enough money to construct");
X    return -1;
X  }
X  if (cost_met > user.np->metal) {
X    beep();
X    statline2_err("space to go on", "not enough metal to construct");
X    return -1;
X  }
X
X  /* if we have reached this point, it means we can construct! */
X
X  sp->flags |= SF_BUBBLE;
X  np->money -= cost;
X  np->metal -= cost_met;
X    /* now prepare the exec string */
X  sprintf(s, "FLAG_SET_SECTOR:%d:%d:%d\n", sp->loc.x, sp->loc.y, SF_BUBBLE);
X  gen_exec(s);
X  cmoney(np, -cost);
X  cmetal(np, -cost_met);
X
X  return 1;
X}
X
END_OF_FILE
if test 7273 -ne `wc -c <'construct.c'`; then
    echo shar: \"'construct.c'\" unpacked with wrong size!
fi
# end of 'construct.c'
fi
if test -f 'update.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'update.c'\"
else
echo shar: Extracting \"'update.c'\" \(49821 characters\)
sed "s/^X//" >'update.c' <<'END_OF_FILE'
X /* update.c -- update the dominion world */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X#include <stdio.h>
X#include <signal.h>
X#include <math.h>
X
X#define BAKBEFORE 1
X#define BAKAFTER 2
X
Xextern Sworld world;
Xextern Suser user;
Xextern struct race_list *races;	/* list of races */
Xextern struct army_type *army_types; /* array of available armies */
Xextern Sh_spell *hanging_spells;
Xextern char libdir[];
Xextern int debug;
Xextern int (*wrapx)(), (*wrapy)();
XFILE *mailfile;
Xextern struct s_desig_map desig_map[];
Xextern double get_version(), atof();
XSuser *temp_users;
X
Xstruct move_data
X{
X  int moved, adj;
X  double des;
X} **work_data;
X
X
Xmain(argc, argv)
X     int argc;
X     char *argv[];
X{
X  int i, j, k, insector, occuflag, c, bakflag = 0;
X  Snation *np;
X  Ssector *sp;
X  Sarmy *ap, *best;
X  extern char *optarg;
X  extern int optind;
X  char mailname[NAMELEN], passwd[PASSLEN], default_pass[NAMELEN];
X  char mail_subject[80],receiver[NAMELEN];
X
X  strcpy(libdir, DEF_LIBDIR);	/* default libdir */
X  default_pass[0] = '\0';
X
X  if (debug) {
X    printf("libdir=%s,def_libdir=%s\n", libdir, DEF_LIBDIR);
X  }
X
X  while ((c = getopt(argc, argv, "baxp:d:--")) != EOF)
X    switch (c) {
X    case 'b':
X      bakflag |= BAKBEFORE;
X      break;
X    case 'a':
X      bakflag |= BAKAFTER;
X      break;
X    case 'x':
X      debug++;
X      break;
X    case 'd':
X      strcpy(libdir, optarg);
X      break;
X    case 'p':			/* allow user to give passwd on command line */
X      strcpy(default_pass, optarg);
X      break;
X    }
X  if (chdir(libdir) == -1) {
X    fprintf(stderr,"Error: cannot cd to directory %s\n",libdir);
X    clean_exit();
X    exit();
X  }
X
X  if (is_master_lock()) {
X    printf("There is a master lock\n");
X    exit(1);
X  }
X  set_master_lock();
X  if (is_any_lock()) {
X    printf("There is a lock; you should see if the nation is still playing\n");
X    clean_exit();
X    exit(1);
X  }
X  set_update_time();
X  SRND(time(0L));
X  load_army_types();		/* it is important to load these in */
X  load_spirit_types();		/* these must also be loaded */
X
X  if (bakflag & BAKBEFORE) {
X    printf("Backing up data in 'bakbefore' directory\n");
X    backuplib("bakbefore"); }
X  printf("\n\n dominion : Update Module : COMMENCING\n");
X  printf("----------------------------------\n");
X
X  read_world(&world, WORLD_FILE);
X
X  get_crypt_pass("Gamemaster password: ", passwd, NULL, default_pass);
X  if (strcmp(world.nations[0].passwd, passwd)) {
X    printf("\r\nTry again\r\n");
X    get_crypt_pass("Gamemaster password: ", passwd, NULL, default_pass);
X    if (strcmp(world.nations[0].passwd, passwd)) {
X      printf("You must be a gamemaster to update the world!\n");
X      exit(1);
X    }
X  }
X
X  printf("Updating from thon %d to thon %d.\n", world.turn, world.turn+1);
X  world.turn++; /* HAPPY NEW THON */
X
X  /* Run through each nation doing calculations for money, etc. */
X  /* this is a kludge:  we need the user struct for things like spells */
X
X/*  update_npc_diplo(); /* we don't use this any more */
X  load_master_execs();
X  init_work_data(world.xmax, world.ymax);
X    /* you must load each nation before you can load the hanging
X       spells, in case a user cast a spell on an army s/he just made
X       this turn.
X     */
X  for (i=1; i<world.n_nations; ++i) {
X    np = &world.nations[i];
X    if (is_active_ntn(np)) {
X      user.spirit_list = NULL;
X      user.np = np;
X      get_spirits(&user, np->mag_skill);
X      load_nation(i, np);
X
X      if (gets_mail(np)) {
X	sprintf(mailname, "mail%d", i);
X	mailfile = fopen(mailname, "a");
X	fprintf(mailfile,"\n---------MESSAGE FROM UPDATE PROGRAM---------\n");
X	fprintf(mailfile, "During the time between thon %d and thon %d...\n",
X		 world.turn-1, world.turn);
X	fclose(mailfile);
X      } else {
X	mailfile = NULL;
X      }
X    }
X  }
X  load_h_spells(NULL);
X  docargos();			/* picks up cargos dropped by caravans */
X  for (i = 1; i < world.n_nations; ++i) {
X    np = &world.nations[i];
X    if (is_active_ntn(np)) {
X
X      user.id = i;
X      user.np = &world.nations[i];
X
X      /* start the user off with all spells s/he deserves.
X         note that, because of spirits, this has to be done
X         before load_nation(), since the spirit list is used
X         in the exec parsing.  THIS MIGHT NOT BE TRUE ANY MORE.
X         It still is true. moreso than ever -SHU
X        */
X      user.spell_list = NULL;
X      user.spirit_list = NULL;
X        /* prepare for sending them mail */
X      if (gets_mail(np)) {
X	sprintf (mailname, "mail%d", i);
X	mailfile = fopen(mailname, "a");
X      } else {
X	mailfile = NULL;
X      }
X      printf(" - - - - - - updating nation %s (%d) %s - - - - - -\n",
X	      np->name, i, (np->npc_flag)?"[npc]":" ");
X      fflush(stdout);
X      if (np->npc_flag) {
X	npc_moves(np);
X      }
X      dotechno (np, mailfile);
X      dospy(np, mailfile);
X      domagic(np, mailfile);
X      domoney(np);
X      dometal(np);
X      dojewels(np);
X      dofood(np);
X      docivilians(np);
X      load_dead_hspells(&user,1);
X
X      if (mailfile) { fclose (mailfile); }
X    }
X  }
X  dobattles();
X  take_sectors();
X  update_diplo();
X  reset_armies();
X  send_mail();
X  post_statistics();
X    /* clears the hanging spells before writing the world */
X  clear_dead_hspells();
X
X  clear_h_spells();
X  write_h_spells();
X  
X  printf("Saving world data...\n");
X  fflush(stdout);
X  write_world(&world, WORLD_FILE);
X
X  system("rm -f exec/exec*");
X
X  if (bakflag & BAKAFTER) {
X    printf("Backing up data in 'bakafter' directory.\n");
X    backuplib("bakafter"); }
X  printf("----------------------------------\n");
X  printf(" dominion : Update module : COMPLETE\n\n");
X    /* at the end, remove the cargo file */
X    /* remove the master lock file */
X  del_master_lock();
X}
X
X  /* This will send mail to each nation that has a mail temp file. */
Xsend_mail()
X{
X  char mailname[200], receiver[200], mail_subject[200];
X  int i;
X
X  printf("Sending mail... "); fflush(stdout);
X
X  sprintf(mail_subject,"Update to thon %d", world.turn);
X  for (i = 1; i < world.n_nations; i++) {
X    sprintf(mailname, "mail%d", i);
X    mailfile = fopen(mailname, "r");
X    if (mailfile) {
X      fclose (mailfile);
X      sprintf(receiver,"%s of %s",
X	      world.nations[i].leader, world.nations[i].name);
X      if (debug) {
X	printf("Sending mail to %s using file %s.\n",world.nations[i].name,
X	       mailname);
X	printf("Receiver => %s\n",receiver);
X      }
X        /* make sure we send no mail to NPCs */
X      if (gets_mail(&world.nations[i])) {
X	if (mail_send(mailname, 0, i, mail_subject) > 0) {
X	  fprintf(stderr,"Couldn't send mail to nation %d\n",i);
X	}
X      }
X      unlink(mailname);
X    }
X  }
X  printf("done.\n");
X  fflush(stdout);
X}
X
X
X/* This will backup the lib directory either before an update, after an
X   update, or both.  */
Xbackuplib(dirname)
X     char dirname[];
X{
X  char cmdstr[200];
X
X  sprintf(cmdstr, "/bin/rm -fr %s\n", dirname);
X  if (debug) printf("%s", cmdstr);
X  system(cmdstr);
X  sprintf(cmdstr, "/bin/mkdir %s\n", dirname);
X  if (debug) printf("%s", cmdstr);
X  system(cmdstr);
X  sprintf(cmdstr,
X	   "/bin/cp -r doc magic misc exec mail news world dom_diplo %s\n",
X	   dirname);
X  if (debug) { printf("%s", cmdstr); }
X  system(cmdstr);
X}
X
X
X/* This function is called at the end of the update to change all armies
X   that are in occupy mode to defend mode.  It also restores full move
X   points to all armies.
X */
X
X/* HOLD IT:  shouldn't this be done with the nation army lists instead
X   of sector army lists?  many sectors will have no armies, so it is
X   a waste to traverse the whole map.
X */
Xreset_armies()
X{
X  Sarmy *ap, *next_ap;
X  Sspirit *spiritp = NULL, *get_spirit_from_type();
X  struct army_type this_atype;
X  extern struct army_type *army_types;
X  struct spirit_type this_spirit_type;
X  extern struct spirit_type *spirit_types;
X  Snation *np;
X  Ssector *sp;
X  int i, j;
X  FILE *mfile, *fopen();
X  char mailfname[PATHLEN];
X
X  printf("Resetting armies...\n");
X  fflush(stdout);
X  for(j = 0; j < world.n_nations; ++j) {
X    np = &world.nations[j];
X    sprintf(mailfname, "mail%d", j);
X    mfile = fopen(mailfname, "a");
X    ap = np->armies;
X    for(i=0; ap != NULL; ++i) {
X      next_ap = ap->next;
X      sp = &world.map[ap->pos.x][ap->pos.y];
X      if (ap->status == A_OCCUPY) {
X	ap->status = A_DEFEND;
X      }
X      ap->mvpts = army_move_rate(np, ap);
X        /* make sure that armies are not too small for patrol/intercept */
X      if ((ap->status == A_PATROL || ap->status == A_INTERCEPT)
X	  && !can_patrol(ap)) {
X	ap->status = A_DEFEND;
X      }
X        /* patrol and garrison move less */
X      if (ap->status == A_PATROL || ap->status == A_GARRISON) {
X	ap->mvpts /= 2;
X      }
X      if (ap->status == A_INTERCEPT) {
X	ap->mvpts = 0;
X      }
X        /* if they were in a fort, add some bonus */
X      if (is_army(ap)) {
X	if (sp->owner == np->id && sp->designation == D_FORT) {
X	  ap->sp_bonus += FORT_BONUS_INCREASE;
X	}
X      }
X        /* make sure that armies and spirits have their permanent flags */
X      if (is_army(ap)) {
X	this_atype = army_types[army_type_index(ap->type)];
X	ap->flags |= this_atype.flags;
X      }
X      if (is_spirit(ap)) {
X	this_spirit_type = spirit_types[spirit_type_index(ap->type)];
X	ap->flags |= this_spirit_type.flags;
X      }
X      if (is_mage(ap)) {
X	ap->flags |= AF_WIZARD;
X      }
X        /* special handling of the INVERSE_ALT flag:  if they
X	   are a land race, it becomes a WATER flag;  if they
X	   are a water race, it becomes a LAND flag.
X	 */
X      if (ap->flags & AF_INVERSE_ALT) {
X	if (np->race.pref_alt >= SEA_LEVEL) {
X	  ap->flags |= AF_WATER;
X	} else {
X	  ap->flags |= AF_LAND;
X	}
X      }
X        /* if they are underwater without the right flag, make them drown */
X      if (!good_army_altitude(np, sp, ap)) {
X	printf("Army %d (%s) in %s %s.  x%d,y%d\n", ap->id, ap->name, np->name,
X	       (sp->altitude < SEA_LEVEL) ? "drowned" : "suffocated",
X	       ap->pos.x, ap->pos.y);
X	if (mfile) {		/* elaborate printing statement!! */
X	  fprintf(mfile, "Your army %d (%s) %s.\n", ap->id, ap->name,
X		  (sp->altitude < SEA_LEVEL) ? "drowned" : "suffocated");
X	}
X	delete_army_sector(sp, ap);
X	delete_army_nation(np, ap);
X      }
X
X      ap = next_ap;
X    }
X    if (mailfile) { fclose(mailfile); }
X  }
X  if (mfile) { fclose(mfile); }
X  printf("done.\n");
X  fflush(stdout);
X}
X
X
X
X/* This will check which sectors have armies in them in occupy mode.  If there
X   are two armies in occupy mode, the one with the highest move ratio gets the
X   sector... */
Xtake_sectors()
X{
X  int i, j, k, occuflag, availflag;
X  Ssector *sp;
X  int old_owner;		/* old owner of the sector that was taken */
X  Sarmy *ap, *best, *get_army();
X  int n_armies;			/* how many are in sector */
X  struct armyid *alist;		/* to run through the sector's army list */
X  char mailname[200];
X  Sdiplo **dm, **allocate_diplo();
X
X  dm = allocate_diplo(world.n_nations);
X  read_in_diplo(dm,world.n_nations);
X  
X  for (i = 0; i < world.ymax; i++) /* check each sector for armies */
X    for (j = 0; j < world.xmax; j++) {
X      sp = &(world.map[j][i]);
X      sp->flags &= ~SF_HOSTILE; /* Turn off the old hostility */
X      if (sp->alist != NULL) { 	/* we have some armies in this sector */
X	occuflag = 0;		/* is anyone trying to occupy this sector?  */
X	availflag = 1;		/* is this sector available */
X	best = NULL;		/* this keeps track of army with best ratio */
X	alist = sp->alist;
X
X	/* Now we'll run though each army in the sector and try to find      */
X	/* which (if any) are attempting to occupy that sector.  An army can */
X	/* only occupy a sector if it's status is OCCUPY, it has enough      */
X	/* soldiers (OCCUPYING_SOLDIERS) and either the sector is unowned or */
X	/* the nation which owns the sector is the foe of the army and the   */
X	/* sector owner has no armies remaining in the sector.               */
X
X	n_armies = sect_n_armies(sp);
X	for (k = 0; k < n_armies; k++) {
X	  ap = get_army(&world.nations[alist->owner], alist->id);
X
X	  if (ap->status == A_OCCUPY && ap->n_soldiers >= OCCUPYING_SOLDIERS &&
X	      (sp->owner == 0 || 
X	       (sp->owner != 0 && 
X		(get_diplo_status(dm,ap->owner,sp->owner) == WAR || 
X		 get_diplo_status(dm,ap->owner,sp->owner) == JIHAD)))) {
X
X	    if (best == NULL) best = ap; /* if first army checked, best yet */
X	    occuflag = 1;	/* yes, someone's trying to get the sector */
X	    if (ap->mvratio > best->mvratio) best = ap;
X	  }
X
X	  /* If sector owner has an army remaining on it, nobody can take it */
X	  if (ap->owner == sp->owner) {
X	    availflag = 0;
X	  }
X	  alist = alist->next;	/* now get the next army */
X	}
X
X	if (occuflag && availflag) {
X	  old_owner = sp->owner;
X	  if (debug) printf("Winner is %s's army %d... ",
X			     world.nations[best->owner].name, best->id);
X	  if (best->owner != sp->owner) {
X	    if (sp->owner != 0) subtsector(&world.nations[sp->owner], j, i);
X	    addsector(&world.nations[best->owner], j, i);
X            if (sp->n_people) {
X            /* If there were any civilians in the sector */
X              sp->flags |= SF_HOSTILE; /* It's hostile for 1 update */
X	    }
X	    if (gets_mail(&world.nations[old_owner]) && old_owner != 0) {
X	      sprintf(mailname, "mail%d", old_owner);
X	      mailfile = fopen(mailname, "a");
X	    } else {mailfile = NULL; }
X	    if (sp->designation == D_CAPITAL) {
X	      take_capital(&(world.nations[old_owner]),
X			   &(world.nations[best->owner]), mailfile);
X	    } else {
X	      if (mailfile) {
X		fprintf(mailfile,
X			"Sector %d, %d has been taken from you by %s!\n",
X			xrel(j,i,world.nations[old_owner].capital),
X			yrel(j,i,world.nations[old_owner].capital),
X			world.nations[best->owner].name);
X	      }
X	    }
X	    if (mailfile) {
X	      fclose(mailfile);
X	    }
X	    if (gets_mail(&world.nations[best->owner])) {
X	      sprintf(mailname, "mail%d", best->owner);
X	      if ((mailfile = fopen(mailname, "a")) == NULL)
X              {
X                fprintf(stderr,"Error: cannot append to %s\n",mailname);
X                clean_exit();
X                exit(1);
X              }
X	      fprintf(mailfile, "You successfully captured sector %d, %d!\n",
X		      xrel(j,i,world.nations[best->owner].capital),
X		      yrel(j,i,world.nations[best->owner].capital));
X	      fclose(mailfile);
X	    }
X	  }
X	  else if (debug) printf("They already own that sector!\n");
X	}
X      }
X    }
X  free_diplo(dm,world.n_nations);
X}
X
X/* nation np2 takes capital of nation np1.  mfile is mail file of nation
X   np1.  If np1 has any cities, make the first one their new capital.
X   1/2 of np1's metal, jewels, and money are transferred to np2. */
Xtake_capital(np1, np2, mfile)
X     Snation *np1, *np2;
X     FILE *mfile;
X{
X  struct pt_list *ptlist, *bestpt;
X  int done = 0, x = np1->capital.x, y = np1->capital.y;
X  FILE *news_fp, *fopen();	/* to print this to the news */
X  FILE * sacker;
X  char tmp_name[100];
X  char * contents ();
X  char subj[100];
X
X    /* A temporary file name for this news posting */
X/*  tmp_name = tmpnam(NULL, "dominion"); */
X  strcpy(tmp_name, "dominionXXXXXX");
X  mktemp(tmp_name);
X
X  if (strlen(tmp_name) == 0) {
X    fprintf(stderr, "Error getting temp file name\n");
X    return;
X  }
X  if ((news_fp = fopen(tmp_name, "w")) == NULL) {
X    fprintf(stderr, "Error opening file %s for writing\n", tmp_name);
X    return;
X  }
X  sprintf (subj, "mail%d", np2->id);
X  if ((sacker = fopen (subj, "a")) == NULL) {
X    fprintf (stderr, "Error opening file %s for writing\n", subj);
X    return;
X  }
X  sprintf(subj, "Capital of %s sacked", np1->name);
X  fprintf(news_fp,"\n\nCapital of %s was sacked by %s\n",np1->name,np2->name);
X  fclose(news_fp);
X  post_news_file(tmp_name, NEWS_GROUP,subj,0);
X
X  if (mfile) {
X    fprintf(mfile, "Your capital was captured by %s!\n", np2->name);
X  }
X  printf("   ** %s has lost their capital to %s! **\n", np1->name, np2->name);
X  ptlist = np1->ptlist;
X    /* first we see if we can get another city for capital */
X  while (ptlist != NULL && !done) {
X    if (world.map[ptlist->pt.x][ptlist->pt.y].designation == D_CITY) {
X      done = 1;
X      world.map[ptlist->pt.x][ptlist->pt.y].designation = D_CAPITAL;
X      break;
X    }
X    ptlist = ptlist->next;
X  }
X  if (done) {			/* found a replacement city */
X    if (mfile) {
X      fprintf(mfile, "Your city at %d,%d is your new capital\n",
X	      xrel(ptlist->pt.x, ptlist->pt.y, np1->capital),
X	      yrel(ptlist->pt.x, ptlist->pt.y, np1->capital));
X    }
X    world.map[ptlist->pt.x][ptlist->pt.y].designation = D_CAPITAL;
X    np1->capital = ptlist->pt;
X  } else {			/* np1 had no more cities!! */
X    if (mfile) {
X      fprintf(mfile, "You have no cities to put your new capital!\n");
X    }
X
X    ptlist = np1->ptlist;       /* give them the most populated sector */
X    if (ptlist) {               /* if they have any left!! */
X      bestpt = ptlist;
X      while (ptlist != NULL) {
X        if (world.map[ptlist->pt.x][ptlist->pt.y].n_people >
X            world.map[bestpt->pt.x][bestpt->pt.y].n_people)
X          bestpt = ptlist;
X	ptlist = ptlist->next;
X      }
X      if (mfile) {
X	fprintf(mfile, "I am putting your new capital at (%d,%d)\n",
X		xrel(bestpt->pt.x, bestpt->pt.y, np1->capital),
X		yrel(bestpt->pt.x, bestpt->pt.y, np1->capital));
X      }
X      np1->capital.x = bestpt->pt.x;
X      np1->capital.y = bestpt->pt.y;
X      world.map[bestpt->pt.x][bestpt->pt.y].designation = D_CAPITAL;
X    } else {			/* if you have no sectors... you die */
X      if (mfile) {
X	fprintf(mfile,"You have no sectors left. Your nation is destroyed.\n");
X      }
X      destroy_nation(np1->id);
X      printf("*** nation %d is destroyed ***\n", np1->id);
X    }
X  }
X  world.map[x][y].designation = D_CITY; /* old capital -> city (for new guy) */
X
X  /* deplete nation */
X  fprintf (sacker, "\nSacked capital of %s.  Gained:\n", np1->name);
X  fprintf (sacker, "\t%s\n\n", contents(max(np1->money/2, 0),
X				      max(np1->metal/2, 0),
X				      max(np1->jewels/2, 0),
X				      max(np1->food/2, 0), 0, -1, NULL, 0));
X  fclose (sacker);
X
X  np2->money += max(np1->money/2, 0); /* don't acquire debts */
X  np1->money = np1->money/2;
X  np2->jewels += max(np1->jewels/2, 0);
X  np1->jewels = np1->jewels/2;
X  np2->metal += max(np1->metal/2, 0);
X  np1->metal = np1->metal/2;
X  np2->food += max(np1->food/2, 0);
X  np1->food =np1->food/2;				      
X}
X
X  /* runs throught the list of sectors belonging to a nation
X     and does things like reproduction and such.
X   */
Xdocivilians(np)
X     Snation *np;
X{
X  int current, born, died, tborn, tdied, rep, mort, i, j;
X  Ssector *sp;
X  struct pt_list *lp;
X
X  rep  = np->race.repro;
X  mort = np->race.mortality;
X  tborn = tdied = 0;
X  lp = np->ptlist;
X  while (lp != NULL) {
X    sp = &world.map[lp->pt.x][lp->pt.y];
X    if (debug) printf ("Doing population in %d,%d\n", lp->pt.x, lp->pt.y);
X    current = sp->n_people;
X    born = (int) (current * rep  / 100.0);
X    died = (int) (current * mort / 100.0);
X    tborn += born;
X    tdied += died;
X    sp->n_people += born - died;
X      /* they might suffocate or drown */
X    if (sp->n_people > 0 && !good_altitude(sp, np)) {
X      printf("%d people %s in sector (%d, %d)\n", sp->n_people,
X	     (sp->altitude < SEA_LEVEL) ? "drowned" : "suffocated",
X	     sp->loc.x, sp->loc.y);
X      if (mailfile) {
X	fprintf(mailfile, "%d people %s in sector (%d, %d)\n", sp->n_people,
X		(sp->altitude < SEA_LEVEL) ? "drowned" : "suffocated",
X		xrel(sp->loc.x, sp->loc.y, np->capital),
X		yrel(sp->loc.x, sp->loc.y, np->capital) );
X      }
X      sp->n_people = 0;
X    }
X/* Old civ movement code.  Has been replaced.
X    for (i=sp->loc.x-1; i<=sp->loc.x+1; i++)
X      for (j=sp->loc.y-1; j<=sp->loc.y+1; j++) { 
X	if (world.map[(*wrapx)(i,j)][(*wrapy)(i,j)].owner == np->id)
X	  movepeople(np, sp->loc.x, sp->loc.y, (*wrapx)(i,j), (*wrapy)(i,j));
X      }
X*/
X    lp = lp->next;
X  }
X  clear_work_data(); /* Setup for moving */
X  switch(np->opts->civ_movemode) {
X    case 1: { move_people_restrict(np); break; }
X    case 2: { move_people_free(np); break; }
X    default: { /* the default (0) is to not move at all */; }
X  }
X  if (mailfile) {
X    fprintf(mailfile,
X	 "There were %d births and %d deaths, for a population change of %d\n",
X	 tborn, tdied, tborn-tdied);
X    fprintf(mailfile, "Your nation now has %d civilians\n", get_n_civil(np));
X  }
X}
X
Xmovepeople(np, a, b, x, y)
X/* This routine is outdated and should be removed */
X     Snation *np;
X     int a, b, x, y;
X{
X  int p1, p2, pt2, moved, des1, des2;
X
X  if ((a != x || b != y) && world.map[x][y].owner == world.map[a][b].owner) {
X/*    des1 = max(0,sect_desire(np, a, b));
X    des2 = max(0,sect_desire(np, x, y));
X*/
X      /* desireability = % of people employed */
X    des1 = emp_desire(np, a, b);
X    des2 = emp_desire(np, x, y);
X    p1 = world.map[a][b].n_people;
X    p2 = world.map[x][y].n_people;
X/*    pt2 = (des2*(p1+p2))/(des1+des2); /* Potential change in p2 */
X
X/*    moved = (pt2 - p2)/4; /* Move 1/4 of potential change to p2 */
X/*    moved /= 4;			/* make even fewer people move */
X    moved = (p1*(100-des1))/400 - (p2*(100-des2))/400;
X    moved = min(moved, p1);
X      /* hold it!! we cannot move people underwater without bubbles */
X    if (!good_altitude(&world.map[a][b], np)
X	|| !good_altitude(&world.map[x][y], np)) {
X      moved = 0;
X    }
X    p2 += moved;
X    p1 -= moved;
X    world.map[a][b].n_people = p1;
X    world.map[x][y].n_people = p2;
X    if (debug) printf ("Moved %d people from %d,%d to %d,%d\n", moved, a, b, x, y);
X  }
X}
X
Xdomoney(np)
X     Snation *np;
X{
X  int temp;
X
X  temp = np->money;
X  np->money = next_thon_money(np);
X    temp / 100;
X
X  if (mailfile) fprintf(mailfile, "Your net MONEY change is %d, bringing your total to %d\n", np->money-temp, np->money);
X}
X
X
Xdometal(np)
X     Snation *np;
X{
X  int temp;
X
X  temp = np->metal;
X  np->metal = next_thon_metal(np);
X
X  if (mailfile) fprintf(mailfile, "Your net METAL change is %d, bringing your total to %d\n", np->metal-temp, np->metal);
X}
X
X  /* calculates the new amount of jewels a nation has,
X     and if it is negative, it kills off some mages
X   */
Xdojewels(np)
X     Snation *np;
X{
X  int temp;
X  Sarmy *ap, *get_first_mage();
X  Ssector *sp;
X
X  temp = np->jewels;
X
X  np->jewels = next_thon_jewels(np);
X
X  while (np->jewels < 0) {
X    if ((ap = get_first_mage (np)) == NULL) {
X      break;
X    }
X    sp = &world.map[ap->pos.x][ap->pos.y];
X    printf ("\ndeleting mage %d\n", ap->id);
X
X    if (mailfile) {
X      fprintf (mailfile,
X	       "\nYou lost your mage %d because you had no jewels...\n",
X	       ap->id);
X    }
X
X    delete_army_sector (sp, ap);
X    delete_army_nation (np, ap);
X    np->jewels += MAGE_JEWELS_MAINT;
X  }
X
X  /* now we have the final data on jewels: report it to mail file */
X  if (mailfile) {
X    fprintf(mailfile,
X	    "Your net JEWEL change is %d, bringing your total to %d\n",
X	    np->jewels-temp, np->jewels);
X  }
X}
X
X
X  /* calculate the new amount of food.  also takes care of starving */
Xdofood(np)
X     Snation *np;
X{
X  int n_should_starve, n_starved, n_sold_starved;
X  int oldfood, n_civil, n_sold, x;
X  double starved_fraction;
X  Ssector *sp;
X  struct pt_list *ptlist = np->ptlist;
X  Sarmy *ap, *next;		/* for army starvation */
X  struct argument args[N_EXEC_ARGS];
X  char s[EXECLEN];
X
X  n_civil = get_n_civil(np);
X  n_sold = get_n_soldiers(np);
X
X  oldfood = np->food;
X  np->food += calc_food(np) - calc_expend_food(np);
X  if (mailfile) {
X    if (oldfood == np->food)
X      fprintf(mailfile, "Your farmers produced as much food as was needed\n");
X    else if (oldfood < np->food) {
X      fprintf(mailfile,	"Your farmers produced more food than was consumed\n");
X      fprintf(mailfile, "Your food in storage increased %d tons, to %d\n",
X	      np->food-oldfood, np->food);
X    } else if (oldfood > np->food) {
X      fprintf(mailfile,
X	      "Your farmers did not produce enough to feed everyone\n");
X      if (np->food >= 0) {
X	fprintf(mailfile,
X		"%d tons of food were used from storage, leaving %d tons\n",
X		oldfood-np->food, np->food);
X      } else {
X	fprintf(mailfile, "Your remaining storage, %d tons, was used up\n",
X		   oldfood);
X      }
X    }
X  }
X  if (np->food < 0) {
X    printf("people starving in nation %s\n", np->name);
X      /* all those in cities who cannot eat starve */
X    n_should_starve = - (int) (np->food / EAT);
X    if (n_civil == 0) {
X      starved_fraction = 0;
X    } else {
X      starved_fraction = (1.0*n_should_starve)/(1.0*get_n_civil(np));
X    }
X      
X    if (starved_fraction > 1.0) {
X      starved_fraction = 1.0;
X    }
X    n_starved = 0;
X    while (ptlist != NULL) {
X      sp = &world.map[ptlist->pt.x][ptlist->pt.y];
X	n_starved += (int) (starved_fraction*sp->n_people);
X	sp->n_people -= (int) (starved_fraction*sp->n_people);
X	if (sp->n_people < 0) {
X	  sp->n_people = 0;
X	}
X      ptlist = ptlist->next;
X    }
X    if (mailfile) {
X      fprintf(mailfile,
X      "%d people starve in your %d sectors, leaving %d surviving civilians.\n",
X	       n_starved, np->n_sects, get_n_civil(np));
X    }
X      /* if there is still not enough food, starve soldiers */
X    if (n_should_starve > n_civil) {
X      n_sold_starved = (int) (n_should_starve-n_starved)/SOLD_EAT_FACTOR;
X    } else {
X      n_sold_starved = 0;
X    }
X    
X    if (get_n_soldiers(np) == 0) {
X      starved_fraction = 0;
X    } else {
X      starved_fraction = (1.0*n_sold_starved)/(1.0*get_n_soldiers(np));
X    }
X    if (starved_fraction > 1.0) {
X      starved_fraction = 1.0;
X    }
X    if (n_sold_starved > 0) {
X      if (mailfile) {
X	fprintf(mailfile,
X		"%d of your soldiers will starve too\n", n_sold_starved);
X      }
X      ap = np->armies;
X      while (ap && n_sold_starved > 0) {
X	x = starved_fraction*ap->n_soldiers;
X	ap->n_soldiers -= x;
X	n_sold_starved -= x;
X	if (x > 0 && mailfile) {
X	  fprintf(mailfile,"in army %d, %d soldiers starve\n", ap->id, x);
X	}
X	next = ap->next;
X	if (ap->n_soldiers <= 0) {
X	  sprintf(s, "ADISBAND:%d\n", ap->id);
X	  parse_exec_line(s,args);
X	  run_exec_line(np,args);
X	}
X	ap = next;
X      }
X    }
X    np->food = 0;
X  }
X}
X
Xcleanup()
X{
X  /* not much to do here */
X}
X
Xclean_exit()
X{
X  del_master_lock();
X};
X
X  /* reads in the cargo file, then it gives the recipient
X     nation all the stuff.  if there is an army, it reads
X     in that army and inserts it into the sector and nation
X   */
Xdocargos()
X{
X  Scargo cargo;			/* the cargo that is being traded */
X  int from_id, to_id;
X  Snation *from_np, *to_np;
X  char mailname[NAMELEN];
X  FILE *fp, *fopen(), *mailf, *newsf;
X  Sarmy army;			/* was an army traded? */
X  Ssector *traded_sp;		/* was a sector traded? */
X  Ssector *sp;			/* on which sector does it happen? */
X  int x, y;			/* location of the trade */
X  char * contents ();    	/* returns string of cargo_contents */
X
X  if ((fp = fopen(CARGO_FILE, "r")) == NULL) {
X    printf("No cargo file\n");
X    return;
X  }
X  critical();
X  while (fread(&x, sizeof(int), 1, fp) > 0) {
X    fread(&y, sizeof(int), 1, fp);
X    fread(&from_id, sizeof(int), 1, fp);
X    fread(&to_id, sizeof(int), 1, fp);
X    from_np = &world.nations[from_id];
X    to_np = &world.nations[to_id];
X    fread(&cargo, sizeof(Scargo), 1, fp);
X      /* send mail to the donor, if it does not go to root */
X    if (to_id != 0) {
X      if (gets_mail(&world.nations[from_id])) {
X	sprintf(mailname, "mail%d", from_id);
X	mailf = fopen(mailname, "a");
X      } else {mailf = NULL; }
X      if (mailf) {
X	fprintf(mailf,
X		"Cargo given by %s to %s:\n", from_np->name, to_np->name);
X	fprintf(mailf,"\tCargo=%s\n",
X		contents (cargo.money, cargo.metal, cargo.jewels,
X			  cargo.food, cargo.people, cargo.army,
X			  &cargo.title, 0));
X	fclose(mailf);
X      }
X        /* send mail to the recipient */
X      if (gets_mail(&world.nations[to_id])) {
X	sprintf(mailname, "mail%d", to_id);
X	mailf = fopen(mailname, "a");
X      } else {mailf = NULL; }
X      if (mailf) {
X	fprintf(mailf,
X		"Cargo given by %s to %s:\n", from_np->name, to_np->name);
X	fprintf(mailf,"\tCargo=%s\n",
X		contents (cargo.money, cargo.metal, cargo.jewels,
X			  cargo.food, cargo.people, cargo.army,
X			  &cargo.title, 0));
X	fclose(mailf);
X	printf("wrote to mail files about cargo\n");
X      }
X    }
X    if (debug) {
X      printf("Got a cargo from nation %d to nation %d\n", from_id, to_id);
X      printf("\tCargo=%s\n",
X	     contents (cargo.money, cargo.metal, cargo.jewels,
X		       cargo.food, cargo.people, cargo.army,
X		       &cargo.title, 0));
X    }
X    fflush(stdout);
X    to_np->money += cargo.money;
X    to_np->metal += cargo.metal;
X    to_np->jewels += cargo.jewels;
X    to_np->food += cargo.food;
X      /* put people in the sector */
X    sp = &world.map[x][y];
X    sp->n_people += cargo.people;
X      /* if an army is there, read it in from the file */
X    if (cargo.army != -1) {
X      fread(&army, sizeof(Sarmy), 1, fp);
X      army.owner = to_np->id;
X      army.flags &= ~AF_IN_TRANSPORT;
X      insert_army_nation(to_np, &army, -1);
X      ++to_np->n_armies;
X      insert_army_sector(sp, &army);
X    }
X      /* if there is a sector, give it to the new nation */
X    if (cargo.title.x != -1 && cargo.title.y != -1) {
X      Ssector *sp = &world.map[cargo.title.x][cargo.title.y];
X      subtsector(from_np, cargo.title.x, cargo.title.y);
X      addsector(to_np, cargo.title.x, cargo.title.y);
X      sp->flags &= ~SF_TRADED;
X    }
X  }
X  fclose(fp);
X  unlink(CARGO_FILE);
X  noncritical();
X}
X
X  /* update the nation's spy values */
Xdospy(np, mailfile)
X     Snation *np;
X     FILE *mailfile;
X{
X  int stealth = np->race.stealth;
X
X  np->spy += stealth * (sqrt(1.0 * np->spy_r_d * calc_revenue(np) / 100 +
X			     np->cur_spy_r_d * np->money / 100)) *
X			     SPY_MONEY_FACTOR;
X  np->secrecy += (stealth*stealth) * 
X    (sqrt (1.0*np->spy_r_d * calc_revenue(np) / 100 +
X	   (np->cur_spy_r_d * np->money / 100)) * SPY_SECRECY_FACTOR);
X}
X
X/* undo hanging spells, decrease the thons_left param */
Xclear_h_spells()
X{
X  Sh_spell *h_spells;
X  int i;
X  struct argument exec_args[N_EXEC_ARGS];
X
X  for (h_spells=hanging_spells; h_spells != NULL; h_spells = h_spells->next) {
X    for (i = 0; i < h_spells->n_lines; ++i) {
X      if (i % 2 == 1) {		/* odd number means undo */
X	parse_exec_line(h_spells->lines[i], exec_args);
X	run_exec_line(&world.nations[h_spells->nat_id], exec_args);
X      }
X    }
X    if (h_spells->thons_left >= 0) {
X      --h_spells->thons_left;
X    }
X  }
X}
X
X  /* critical() for the update/make/add is different from the game */
Xcritical()
X{
X  signal(SIGINT, SIG_IGN);
X  signal(SIGQUIT, SIG_IGN);
X}
Xnoncritical()
X{
X  signal(SIGINT, SIG_DFL);
X  signal(SIGQUIT, SIG_DFL);
X}
X
X  /* posts some news articles of general interest */
Xpost_statistics()
X{
X  FILE *tmp_fp, *fopen();
X  char tmp_name[PATHLEN];
X  char subj[100];
X
X  /* a temporary file name for this news posting */
X/*  tmp_name = tmpnam(NULL, "dominion"); */
X  strcpy(tmp_name, "dominionXXXXXX");
X  mktemp(tmp_name);
X
X  if (strlen(tmp_name) == 0) {
X    fprintf(stderr, "Error getting temp file name\n");
X    return;
X  }
X  if ((tmp_fp = fopen(tmp_name, "w")) == NULL) {
X    fprintf(stderr, "Error opening file %s for writing\n", tmp_name);
X    return;
X  }
X  sprintf(subj, "statistics at thon %d", world.turn);
X  fprintf(tmp_fp, "\nThere are %d active nations.\n", get_n_act_ntn(&world));
X  fprintf(tmp_fp, "Average population: %d\n", get_avg_civil(&world));
X  fprintf(tmp_fp, "Average soldiers:   %d\n", get_avg_soldiers(&world));
X  fprintf(tmp_fp, "Average treasury:   %d\n", get_avg_money(&world));
X  fprintf(tmp_fp, "Average metal:      %d\n", get_avg_metal(&world));
X  fprintf(tmp_fp, "Average jewels:     %d\n", get_avg_jewels(&world));
X  fprintf(tmp_fp, "Average food:       %d\n", get_avg_food(&world));
X  fprintf(tmp_fp, "Average sectors:    %d\n", get_avg_sectors(&world));
X  fprintf(tmp_fp, "World occupation:   %d%% of land\n",
X	  get_per_occu_land(&world));
X  fprintf(tmp_fp, "                    %d%% of water\n",
X	  get_per_occu_water(&world));
X  fclose(tmp_fp);
X  post_news_file(tmp_name, NEWS_GROUP,subj,0);
X}
X
Xinit_work_data(xmax, ymax)
X/*
X   Allocate the memory for the temporary array the size of the world
X   (with one extra for wrap around) for manipulation before scaling 
X*/
Xint xmax,ymax;
X{
X  int i;
X  
X  if ((work_data = (struct move_data **) malloc((xmax) * 
X                           (sizeof(struct move_data *)))) == NULL)
X  {
X    mem_error();
X  }
X  for (i=0; i <xmax ; i++)
X  {
X    if ((work_data[i] = (struct move_data *) malloc((ymax) * 
X                                  (sizeof(struct move_data)))) == NULL)
X    {
X      mem_error();
X    }
X  }
X}
X
Xclear_work_data()
X/* Clear the work_peop array */
X{
X  int x,y;
X
X  for (x = 0 ; x < world.xmax ; x++)
X  {
X    for (y = 0 ; y < world.ymax ; y++)
X    {
X      work_data[x][y].moved = 0;
X      work_data[x][y].adj = 0;
X      work_data[x][y].des = 0.0;
X    }
X  }
X}
X
X#define MOVE_FREE 1
X
Xmove_people_free(np)
XSnation *np;
X{
X  struct pt_list *curr_pt;
X  int tot_peop, tot_emp,x,y,moving,i,j,xx,yy;
X  double race_factor, desire,divisor;
X
X  race_factor = sqrt(world.nations[np->id].race.repro/10.0);
X  curr_pt = np->ptlist;
X/* Loop over every point the user has. */
X  while (curr_pt != NULL)
X  {
X    if (!good_altitude(&world.map[curr_pt->pt.x][curr_pt->pt.y],np))
X    {
X      curr_pt = curr_pt->next;
X      continue;
X    }
X    x = curr_pt->pt.x;
X    y = curr_pt->pt.y; 
X    work_data[x][y].des = desig_map[world.map[x][y].designation].max_employed;
X    work_data[x][y].des *= race_factor;
X    desire = (double)sect_desire(np,x,y);
X    /* Determine the desireability of the sector */
X    desire = (desire - 650.0)/1000.0;
X    /* And have that modify the % of people wanting to live there */
X    work_data[x][y].des *= (1.0 + desire);
X    for (i = 0 ; i < (MOVE_FREE * 2) + 1  ; i++)
X    {
X      for (j = 0 ; j < (MOVE_FREE * 2) + 1 ; j++)
X      {
X        x = (*wrapx)(i+(curr_pt->pt.x-MOVE_FREE),j+(curr_pt->pt.y-MOVE_FREE));
X        y = (*wrapy)(i+(curr_pt->pt.x-MOVE_FREE),j+(curr_pt->pt.y-MOVE_FREE));
X        if (world.map[x][y].owner == np->id)
X        { 
X          work_data[curr_pt->pt.x][curr_pt->pt.y].adj++;
X	}
X      }
X    }
X    curr_pt = curr_pt->next;
X  }    
X  curr_pt = np->ptlist;
X  while (curr_pt != NULL)
X  {
X    tot_peop = 0;  /* Sum up the total owned people in a 1 sector radius */
X    tot_emp = 0;  /* Sum up the total available employment in a 1 sect rad */ 
X/* If the sector cannot suport civilians, then we don't move to or from it */
X    if (!good_altitude(&world.map[curr_pt->pt.x][curr_pt->pt.y],np))
X    {
X      curr_pt = curr_pt->next;
X      continue;
X    }
X/* First loop over the neighboorhod and find totals */
X    for (i = 0 ; i < (MOVE_FREE * 2) + 1  ; i++)
X    {
X      for (j = 0 ; j < (MOVE_FREE * 2) + 1 ; j++)
X      {
X        x = (*wrapx)(i+(curr_pt->pt.x-MOVE_FREE),j+(curr_pt->pt.y-MOVE_FREE));
X        y = (*wrapy)(i+(curr_pt->pt.x-MOVE_FREE),j+(curr_pt->pt.y-MOVE_FREE));
X        if (world.map[x][y].owner == np->id)
X        { 
X          /* Start with the number of people employable */
X          tot_peop += world.map[x][y].n_people;
X          tot_emp += work_data[x][y].des;
X	}
X      }
X    }
X/* Find the max divisor for this neighboorhood */
X    divisor = 1.0;
X    for (i = 0 ; i < (MOVE_FREE * 2) + 1  ; i++)
X    {
X      for (j = 0 ; j < (MOVE_FREE * 2) + 1 ; j++)
X      {
X        x = (*wrapx)(i+(curr_pt->pt.x-MOVE_FREE),j+(curr_pt->pt.y-MOVE_FREE));
X        y = (*wrapy)(i+(curr_pt->pt.x-MOVE_FREE),j+(curr_pt->pt.y-MOVE_FREE));
X        if (work_data[x][y].adj > divisor)
X        {
X          divisor = work_data[x][y].adj;
X        }
X      }
X    }
X/* Then distribute people over the neighboorhood. */
X    for (i = 0 ; i < (MOVE_FREE * 2) + 1  ; i++)
X    {
X      for (j = 0 ; j < (MOVE_FREE * 2) + 1 ; j++)
X      {
X        x = (*wrapx)(i+(curr_pt->pt.x-MOVE_FREE),j+(curr_pt->pt.y-MOVE_FREE));
X        y = (*wrapy)(i+(curr_pt->pt.x-MOVE_FREE),j+(curr_pt->pt.y-MOVE_FREE));
X/* Again, only work with sectors owned.  No inter-national movement */
X        if ((world.map[x][y].owner == np->id) && 
X             good_altitude(&world.map[x][y],np))
X        {
X/*
X   The percentage of modified available employment times the number of
X   people available is the number of people who want to be in that sector 
X*/
X          moving = (int)( (work_data[x][y].des/tot_emp) * tot_peop);
X
X/* Then adjust for the people already in that sector */
X          moving -= world.map[x][y].n_people;
X/* 
X  If we are working with a sector with N adjacent sectors, then we
X  only move 1/N th of the people we'd like, since the other adjacent
X  sectors may decide to all do the same thing.
X*/
X          moving =(int)((double)moving/(double)divisor);
X/*
X   And lastly put the people into the array stating that they will be moving.
X   this is important since all moves are considered before they see where
X   everybody else is moving.
X*/
X          work_data[x][y].moved += moving;
X          work_data[curr_pt->pt.x][curr_pt->pt.y].moved -= moving;
X	}
X      }
X    }
X    curr_pt = curr_pt->next;
X  }
X/* Loop over all points again */
X  curr_pt = np->ptlist;
X  while (curr_pt != NULL)
X  {
X    x = curr_pt->pt.x;
X    y = curr_pt->pt.y;
X/* Now add all the movement of people to the state of the world */
X    world.map[x][y].n_people += work_data[x][y].moved;
X    work_data[x][y].moved = 0;
X/* If we less than zero people (roundoff error happens) */
X    if (world.map[x][y].n_people < 0)
X    {
X      if ((debug) || (world.map[x][y].n_people < -9))
X      {
X        fprintf(stderr,"Error: Point %d, %d has %d people\n",x,y,
X                       world.map[x][y].n_people);
X      }
X/* Look around the neighboorhood for a place to get the people from */
X      for (i=0 ; (i < (MOVE_FREE*2)+1) && (world.map[x][y].n_people < 0); i++)
X      {
X        for (j=0 ;(j < (MOVE_FREE*2)+1) && (world.map[x][y].n_people < 0); j++)
X        {
X          xx=(*wrapx)(i+(curr_pt->pt.x-MOVE_FREE),j+(curr_pt->pt.y-MOVE_FREE));
X          yy=(*wrapy)(i+(curr_pt->pt.x-MOVE_FREE),j+(curr_pt->pt.y-MOVE_FREE));
X/* If they have people to spare */
X          if (world.map[xx][yy].n_people + work_data[xx][yy].moved > 0)
X          {
X/* Then we move as many as we can, up to as many as we need */
X            moving = min(world.map[xx][yy].n_people + work_data[xx][yy].moved,
X                         -1 * world.map[x][y].n_people);
X            world.map[xx][yy].n_people -= moving;
X            world.map[x][y].n_people += moving;
X	  }
X	}
X      }
X    }
X/* If we still have not enough people, then the algorithm is buggy */
X    if (world.map[x][y].n_people < 0)
X    {
X       fprintf(stderr,"Error: Point %d, %d still has %d people\n",x,y,
X                       world.map[x][y].n_people);
X    }
X    curr_pt = curr_pt->next;
X  }
X}
X
Xfill_work_data(np)
XSnation *np;
X{
X  struct pt_list *curr_pt;
X  double desire,race_factor;
X  int x,y;
X
X  race_factor = sqrt(world.nations[np->id].race.repro/10.0);
X  curr_pt = np->ptlist;
X  while (curr_pt != NULL)
X  {
X    if (!good_altitude(&world.map[curr_pt->pt.x][curr_pt->pt.y],np)) {
X      curr_pt = curr_pt->next;
X      continue;
X    }
X    x = curr_pt->pt.x;
X    y = curr_pt->pt.y; 
X    work_data[x][y].des = desig_map[world.map[x][y].designation].max_employed;
X    work_data[x][y].des *= race_factor;
X/* the adj holds the number of jobs available in that sector */
X    work_data[x][y].adj = work_data[x][y].des - world.map[x][y].n_people;
X    desire = (double)sect_desire(np,x,y);
X    /* Determine the desireability of the sector */
X    desire = (desire - 650.0)/1000.0;
X    /* And have that modify the % of people wanting to live there */
X    work_data[x][y].des *= (1.0 + desire);
X    curr_pt = curr_pt->next;
X  }    
X}
X
X#define MOVE_RESTR 2
X
Xmove_the_people(np)
XSnation *np;
X{
X  struct pt_list *curr_pt;
X  int x,y, xx,yy,i,j, moving;
X
X  curr_pt = np->ptlist;
X  while (curr_pt != NULL)
X  {
X    x = curr_pt->pt.x;
X    y = curr_pt->pt.y;
X/* Now add all the movement of people to the state of the world */
X    world.map[x][y].n_people += work_data[x][y].moved;
X    work_data[x][y].moved = 0;
X/* If we less than zero people (roundoff error happens) */
X    if (world.map[x][y].n_people < 0)
X    {
X      if ((debug) || (world.map[x][y].n_people < -9))
X      {
X        fprintf(stderr,"Error: Point %d, %d has %d people\n",x,y,
X                       world.map[x][y].n_people);
X      }
X/* Look around the neighboorhood for a place to get the people from */
X      for (i=0;(i < (MOVE_RESTR*2)+1) && (world.map[x][y].n_people < 0); i++)
X      {
X        for (j=0;(j < (MOVE_RESTR*2)+1) && (world.map[x][y].n_people < 0); j++)
X        {
X          xx=(*wrapx)(i+(curr_pt->pt.x-MOVE_RESTR),
X                                           j+(curr_pt->pt.y-MOVE_RESTR));
X          yy=(*wrapy)(i+(curr_pt->pt.x-MOVE_RESTR),
X                                           j+(curr_pt->pt.y-MOVE_RESTR));
X/* If they have people to spare */
X          if (world.map[xx][yy].n_people + work_data[xx][yy].moved > 0)
X          {
X/* Then we move as many as we can, up to as many as we need */
X            moving = min(world.map[xx][yy].n_people + work_data[xx][yy].moved,
X                         -1 * world.map[x][y].n_people);
X            world.map[xx][yy].n_people -= moving;
X            world.map[x][y].n_people += moving;
X	  }
X	}
X      }
X    }
X/* If we still have not enough people, then the algorithm is buggy */
X    if (world.map[x][y].n_people < 0)
X    {
X       fprintf(stderr,"Error: Point %d, %d still has %d people\n",x,y,
X                       world.map[x][y].n_people);
X    }
X    curr_pt = curr_pt->next;
X  }
X}
X
Xmove_space_avail(np,curr_pt,peop,tot_emp,tot_peop)
XSnation *np;
Xstruct pt_list *curr_pt;
Xint tot_emp, *peop,tot_peop;
X{
X  struct pt_list *nhbd_list,*curr_plist;
X  int moving,i,j,x,y,peop_left = *peop;
X  double desire;
X
X  nhbd_list = NULL;
X  for (i = 0 ; i < (MOVE_RESTR * 2) + 1 ; i++) {
X    for (j = 0 ; j < (MOVE_RESTR * 2) + 1 ; j++) {
X      x = (*wrapx) (i+(curr_pt->pt.x-MOVE_RESTR),
X                                      j+(curr_pt->pt.y-MOVE_RESTR));
X      y = (*wrapy) (i+(curr_pt->pt.x-MOVE_RESTR),
X                                      j+(curr_pt->pt.y-MOVE_RESTR));
X/* Again, only work with sectors owned.  No inter-national movement */
X      if ((world.map[x][y].owner == np->id) && good_altitude(
X           &world.map[x][y],np) && ((i != j) || (i != MOVE_RESTR))) {
X         moving = (work_data[x][y].adj * tot_peop / (2 *tot_emp));
X         if (moving < 0) { moving = 0; }
X         peop_left -= moving;
X         work_data[x][y].moved += moving;
X         add_to_plist(&nhbd_list, x, y);
X      }
X    }
X  }
X  sort_ptlist(&nhbd_list);
X  curr_plist = nhbd_list;
X  while ((curr_plist != NULL) && (peop_left != 0))
X  {
X    x = curr_plist->pt.x;
X    y = curr_plist->pt.y;
X/* First figure out how many were moved here already */
X    moving = (work_data[x][y].adj * tot_peop / (2 *tot_emp));
X/* Then figure out how many more can move there. */
X    moving = work_data[x][y].adj - moving;
X    if (moving < 0 ) { moving = 0 ; }
X    if (moving > peop_left) {
X      moving = peop_left;
X      peop_left = 0;
X    } else {
X      peop_left -= moving; 
X    }
X    work_data[x][y].moved += moving;
X    curr_plist = curr_plist->next;
X  }
X  free_ptlist(&nhbd_list);
X  *peop = peop_left;
X}
X
Xmove_somespace_avail(np,curr_pt,peop)
XSnation *np;
Xstruct pt_list *curr_pt;
Xint *peop;
X{
X  int i,j,x,y,moving,peop_left = *peop;
X
X  for (i = 0 ; i < (MOVE_RESTR * 2) + 1 ; i++) {
X    for (j = 0 ; j < (MOVE_RESTR * 2) + 1 ; j++) {
X      x = (*wrapx)(i+(curr_pt->pt.x-MOVE_RESTR),j+(curr_pt->pt.y-MOVE_RESTR));
X      y = (*wrapy)(i+(curr_pt->pt.x-MOVE_RESTR),j+(curr_pt->pt.y-MOVE_RESTR));
X      if ((world.map[x][y].owner == np->id) && good_altitude(
X           &world.map[x][y],np) && ((i != j) || (i != MOVE_RESTR))) {
X         moving = work_data[x][y].adj;
X         if (moving < 0 ) { moving = 0; }
X         if (moving > peop_left ) {
X           moving = peop_left;
X           peop_left = 0; 
X         } else {
X           peop_left -= moving;
X         }
X         work_data[x][y].moved += moving;
X      }
X    }
X  }
X  *peop = peop_left;
X}
X
Xmove_people_restrict(np)
XSnation *np;
X{
X  struct pt_list *curr_pt;
X  int tot_peop, peop_left, tot_emp,x,y,moving,i,j,xx,yy;
X  double race_factor, desire,divisor;
X  struct pt_list *nhbd_list, *curr_plist;
X
X  race_factor = sqrt(world.nations[np->id].race.repro/10.0);
X  fill_work_data(np);
X/* Loop over every point the user has. */
X  curr_pt = np->ptlist;
X  while (curr_pt != NULL)
X  {
X    tot_emp = 0;  /* Sum up the total available employment in a 1 sect rad */ 
X/* If the sector cannot suport civilians, then we don't move to or from it */
X    if (!good_altitude(&world.map[curr_pt->pt.x][curr_pt->pt.y],np)) {
X      curr_pt = curr_pt->next;
X      continue;
X    }
X/* If there are no unemployed people here, then go on. */
X    if ((tot_peop = work_data[curr_pt->pt.x][curr_pt->pt.y].adj) >= 0) {
X      curr_pt = curr_pt->next;
X      continue;
X    }
X    tot_peop *= -1;
X    peop_left = tot_peop;
X    work_data[curr_pt->pt.x][curr_pt->pt.y].moved -= peop_left; 
X
X/* First loop over the neighboorhod and find totals */
X    for (i = 0 ; i < (MOVE_RESTR * 2) + 1  ; i++)
X    {
X      for (j = 0 ; j < (MOVE_RESTR * 2) + 1 ; j++)
X      {
X        x =(*wrapx)(i+(curr_pt->pt.x-MOVE_RESTR),j+(curr_pt->pt.y-MOVE_RESTR));
X        y =(*wrapy)(i+(curr_pt->pt.x-MOVE_RESTR),j+(curr_pt->pt.y-MOVE_RESTR));
X        if ((world.map[x][y].owner == np->id) && ((i!=j) || (i != MOVE_RESTR)))
X        { 
X          /* Start with the number of available jobs */
X          if (work_data[x][y].adj > 0) {
X            tot_emp += work_data[x][y].adj;
X	  }
X	}
X      }
X    }
X    if (tot_emp > 0) {
X      if (tot_emp > tot_peop) {
X        move_space_avail(np,curr_pt,&peop_left,tot_emp,tot_peop);
X      } else {
X        move_somespace_avail(np,curr_pt,&peop_left);
X      }
X    }
X    if (peop_left > 0) {
X      tot_peop = peop_left; 
X      desire = 0.0;
X      for (i = 0 ; i < (MOVE_RESTR * 2) + 1 ; i++) {
X        for (j = 0 ; j < (MOVE_RESTR * 2) + 1 ; j++) {
X          x =(*wrapx)(i+(curr_pt->pt.x-MOVE_RESTR),
X                                          j+(curr_pt->pt.y-MOVE_RESTR));
X          y =(*wrapy)(i+(curr_pt->pt.x-MOVE_RESTR),
X                                          j+(curr_pt->pt.y-MOVE_RESTR));
X          if ((world.map[x][y].owner == np->id) && good_altitude(
X               &world.map[x][y],np) && ((i != j) || (i != MOVE_RESTR))) {
X            desire += work_data[x][y].des;
X          }
X        }
X      }
X      for (i = 0 ; i < (MOVE_RESTR * 2) + 1 ; i++) {
X        for (j = 0 ; j < (MOVE_RESTR * 2) + 1 ; j++) {
X          x =(*wrapx)(i+(curr_pt->pt.x-MOVE_RESTR),
X                                          j+(curr_pt->pt.y-MOVE_RESTR));
X          y =(*wrapy)(i+(curr_pt->pt.x-MOVE_RESTR),
X                                          j+(curr_pt->pt.y-MOVE_RESTR));
X          if ((world.map[x][y].owner == np->id) && good_altitude(
X               &world.map[x][y],np) && ((i != j) || (i != MOVE_RESTR))) {
X            moving = (int)((work_data[x][y].des * tot_peop)/desire);
X            if (moving < 0 ) { moving = 0; } 
X            peop_left -= moving;
X            work_data[x][y].moved += moving;
X          }
X        }
X      }
X      work_data[curr_pt->pt.x][curr_pt->pt.y].moved += peop_left;
X    }
X    curr_pt = curr_pt->next;
X  }
X  move_the_people(np);
X/* Loop over all points again */
X}
X
Xint sort_ptlist(ptlist)
Xstruct pt_list **ptlist;
X{
X  struct pt_list *pnext, *pprev, *pcurr, *ptemp;
X  int switched;
X
X  if (*ptlist == NULL) { return; }
X  if ((*ptlist)->next == NULL) {return; }
X  do {
X    switched = 0;
X    pcurr = *ptlist;
X    pnext = pcurr->next;
X    if (work_data[pcurr->pt.x][pcurr->pt.y].des <
X                  work_data[pnext->pt.x][pnext->pt.y].des) {
X      switched++;
X      ptemp = pnext->next;
X      *ptlist = pnext;
X      (*ptlist)->next = pcurr;
X      (*ptlist)->next->next = ptemp;
X    }
X    pprev = *ptlist;
X    pcurr = (*ptlist)->next;
X    while (pcurr->next != NULL) {
X      pnext = pcurr->next;
X      if (work_data[pcurr->pt.x][pcurr->pt.y].des <
X                         work_data[pnext->pt.x][pnext->pt.y].des) {
X        ptemp = pnext->next;
X        pprev->next = pnext;
X        pprev->next->next = pcurr;
X        pprev->next->next->next = ptemp;
X        switched++;
X      }
X      pprev = pprev->next;
X      pcurr = pprev->next;
X    }
X  } while (switched > 0) ;
X  return;
X}
X
Xfree_ptlist(ptlist)
Xstruct pt_list **ptlist;
X{
X  struct pt_list *pt_list = *ptlist, *tmp_pt;
X  
X  while (pt_list != NULL) {
X    tmp_pt = pt_list->next;
X    free(pt_list);
X    pt_list = tmp_pt;
X  }
X}
X
Xadd_to_plist(ptlist, x, y)
Xstruct pt_list **ptlist;
Xint x,y;
X{
X  struct pt_list *ptemp = *ptlist; 
X
X  if (*ptlist == NULL) {
X    if ((*ptlist = (struct pt_list *)malloc(sizeof(struct pt_list)))== NULL) {
X      mem_error();
X    }
X    (*ptlist)->pt.x = x;
X    (*ptlist)->pt.y = y;
X    (*ptlist)->next = NULL;
X    return;
X  }
X  while (ptemp->next != NULL) {
X    ptemp = ptemp->next;
X  }
X  if ((ptemp->next = (struct pt_list *)malloc(sizeof(struct pt_list)))
X            == NULL) { mem_error(); }
X  ptemp = ptemp->next;
X  ptemp->pt.x = x;
X  ptemp->pt.y = y;
X  ptemp->next = NULL;
X  return;
X}
X    
Xsetup_user_arr(num)
Xint num;
X{
X  if ((temp_users = (Suser *)malloc(num * sizeof(Suser))) == NULL) {
X    mem_error();
X  }
X}
X
Xcopy_to_user_arr(val)
Xint val;
X{
X  temp_users[val] = user;
X}
X
Xcopy_from_user_arr(val)
Xint val;
X{
X  user = temp_users[val];
X}
X
END_OF_FILE
if test 49821 -ne `wc -c <'update.c'`; then
    echo shar: \"'update.c'\" unpacked with wrong size!
fi
# end of 'update.c'
fi
echo shar: End of archive 14 \(of 28\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Now execute ./do_cat.sh to build doc files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
