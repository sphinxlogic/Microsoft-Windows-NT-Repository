Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i063:  dominion - a multi-player world simulation game, Part27/28
Message-ID: <2466@masterCNA.TEK.COM>
Date: 11 Feb 92 18:28:13 GMT
Sender: news@masterCNA.TEK.COM
Lines: 2172
Approved: billr@saab.CNA.TEK.COM

Submitted-by: rosalia@dirac.physics.sunysb.edu (Mark Galassi)
Posting-number: Volume 13, Issue 63
Archive-name: dominion/Part27
Environment: Unix, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 27 (of 28)."
# Contents:  TASKS army.h dominion.c ext.c gm.tex mag_Chess news.c
#   spirit_types techno.c techno_levels trade.c trademenu.c
# Wrapped by billr@saab on Tue Feb 11 10:14:59 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'TASKS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TASKS'\"
else
echo shar: Extracting \"'TASKS'\" \(6364 characters\)
sed "s/^X//" >'TASKS' <<'END_OF_FILE'
XList of tasks to be done for dominion, with concise reflections on
Xhow they might be done.
X
X					Mark.
X
X[ My main concerns are: ]
X
X-- No features should be added for which it takes longer to play.
X
X-- A system of going into debt, possibly the system of issuing bonds
X   outlined in the manual but not implemented.
X
X-- Trimming the manual.  The manual is big and has lots of repeated
X   stuff.  In particular, the Getting Started section should be
X   replaced with a "Don't Panic" section which really takes the user
X   by the hand for the first couple of turns.  People who are not
X   experienced with war games are quite overwhelmed at first.
X
X-- Battle code must be completely redone.  Right now it only supports
X   land-land warfare properly, and other situations are pretty weird.
X   it would also be nice if it handled the capturing of cargos and so
X   on.
X   [Titus and Charles are currently working on that and have almost
X    finished.]
X
X-- More spells, and make spells useful (currently people use their
X   spell points only for spirits).
X
X-- Make "dom_add" give new nations a contiguous land (or water) mass.
X   Nations that start out split have a severe handicap.
X
X-- Make hospitals have some effect.  One idea thought of independently
X   by Chris Adami, Titus Brown and Mark Galassi is to make them
X   have an effect on deaths in battle if they are near enough
X   to a battlefield.
X
X-- Construct-types should be defined in an abstract way and determined
X   by technology, just the way army types are.  If you want to think
X   of a scheme for that, let me know what you come up with.
X
X	The next two items are for the far future:
X
X-- A built-in programming language interpreter to allow for more
X   extensions in the game.  As it is, we have a mini-interpreter
X   for the exec commands, and if someone is studying compilers and
X   wants to implement something more general, then whole new horizons
X   will open up.
X
X-- Split the game into a client and a server.  This would allow 2
X   things: (secure) remote access through a network, and the
X   possibility of high-quality graphics interfaces in the future.
X   [Titus is currently working on a simpler idea to make the game
X    playable over the network.]
X
X-- A UNIX interface with a ".dominionrc" file, and other such stuff,
X   would be quite nice.  [this has already been provided by Paolo,
X   but is not yet included]  Stephen Underwood has made the [O]ptions
X   be saved in a file, which might make the ".dominionrc" file
X   unnecessary.
X
X-- A bold idea proposed by Paolo Montrasio [montra@ghost.unimi.it]
X   which is best summarized by including part of his message and my
X   reply to it which includes my reflections on how it might be done.
X
X[--Paolo--]
X
X- Now the BIG idea. I read in the TASK file that the dev. team is planning
X  to rewrite dominion using a client-server architecture. This is intended
X  to allow remote-playing and the development of some graphical interface
X  (X11 ?). This is a good idea, but not so innovative. This is my own idea:
X
X  We have a > 200,000-hosts network, the Internet. A lot of universities
X  are linked to the Inet, and you know that the students are good players.
X  So we have a lot of potential dominion players. Why must we force them
X  I think you know what IRC is, however I cannot be sure, so here is a
X  SHORT explanation:
X
X  IRC is chat system (you can login and talk with everyone has access to
X  the Inet) with a clever architecture. There a lot of servers, linked
X  together, and distributed across the world. The clients links to
X  the nearer server and are still able to talk with someone at the
X  other end of the net. If IRC was built around central-server machine,
X  this machine would suffer of overloading.
X
X  I think that this distributed architecture can be applied to dominion
X  to reach the following goals:
X
X  - use the storing capacity of any single (interested!) Inet host
X    to store a part of the world.
X
X  - allow thousands of players to play in the same world.
X
XThe topology of this world must allow an indefinite expansion of the
Xplaying ground: I think that an unbounded flat surface must be used.
XWhen too many new players join the game a new portion of the world is
Xgenerated and stored on a server near them.
X
XI think that an "expert" in distributed databases can help a lot
Xin designing such a system. Conversely, if someone does implement this
Xsystem, he'll became a distributed DB expert!
X
XI don't think it is an easy job, but it is very fashinating, isn't it?
X
X[--Mark--]
X    As for the distributed database aspect, you are quite right.  It is
Xextremely ambitious to decentralize it that way.  If all the servers were
Xto keep complete data, then it would be quite easy, since the game
Xis not real time.  There are right now a couple of real-time elements:
Xmail and diplomacy.  The diplomacy can be made to change over the update,
X(some people already want that) and the mail could too, or alternatively
Xordinary email could be used for mail.
X
X    We are due for a meeting in which we make improvements on the battle
Xalgorithms.  Then we will implement those.  After that, I think we should
Xdedicate our attention to your idea.  Here is my simple-minded first-try
Xapproach:
X        1. each server has a planet.
X        2. each nation starts on a given planet
X        3. if a nation discovers and can colonize another
X           planet through magic or technology, then their nation
X           participates in the updates on those planets.  when they
X           select the army or sector that is on the other planet, then
X           the software would not have to do any special networking
X           stuff, since the data would be duplicated on all the servers.
X        4. over the update the networking aspects come up.  the update
X           program would have to collect exec files from all the servers,
X           then run the update on one of the servers, then ship out the
X           new  data files to all the servers.
X        5. for integrity, there would have to be a system to either force
X           a nation to play always on the same server, or at least to make
X           sure that he does not have an exec file on another server when
X           he starts up a session.
X
X    This is simpler than what you had said, and is less distributed, but
Xmight be doable with minimal changes to the software.
X[----]
END_OF_FILE
if test 6364 -ne `wc -c <'TASKS'`; then
    echo shar: \"'TASKS'\" unpacked with wrong size!
fi
# end of 'TASKS'
fi
if test -f 'army.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'army.h'\"
else
echo shar: Extracting \"'army.h'\" \(4051 characters\)
sed "s/^X//" >'army.h' <<'END_OF_FILE'
X  /* army.h -- constants for armies, caravans, ships....
X               there are also some macros declared below
X   */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X  /* army statuses */
X#define A_DEFEND 1		/* army status: defend */
X#define A_ATTACK 2		/*              attack */
X#define A_OCCUPY 3		/*              occupy current sector */
X#define A_PATROL 4		/*              patrol surrounding sectors */
X#define A_INTERCEPT 5		/*              intercept nearby armies */
X#define A_GARRISON 6		/*              man city/town/fort/sctr def. */
X#define A_AMBUSH 7		/*              perform ambushes from towns */
X#define A_TRADED 8		/*              this army will be traded */
X
X  /* fraction of the dead that vampire units raise from the dead */
X#define VAMPIRE_FRACT 0.33	/* 1/3 of the dead rise */
X#define SACRIFICED_FRACT 125	/* 1 pt. per 125 people */
X
X  /* bit definitions for Sarmy.flags */
X#define AF_FLIGHT  0x01		/* army is flying!! (1) */
X#define AF_HIDDEN  0x02		/* army is magically cloaked (2) */
X#define AF_VAMPIRE 0x04		/* army is sucking blood (4) */
X#define AF_IN_TRANSPORT 0x08	/* army is on a caravan/ship (8) */
X#define AF_MISSILES 0x10	/* army shoots arrows and such */
X#define AF_WATER 0x20		/* army is walking on water (32) */
X#define AF_FRONT_LINE 0x40	/* front line type of army (64) */
X#define AF_KAMIKAZE 0x80	/* will die after fighting (128) */
X#define AF_MACHINE 0x100	/* war carts, catapults, siege eng. (256) */
X#define AF_DISGUISED 0x200	/* army is disguised (512) */
X#define AF_WIZARD 0x400		/* can summon and cast spells (1024) */
X#define AF_SORCERER 0x800	/* can use sorcery (2048) */
X#define AF_CARGO 0x1000		/* can hold a cargo (4096) */
X#define AF_UNDERGROUND 0x2000	/* can burrow under ground (8192) */
X#define AF_LAND 0x4000		/* army walks on land (16384) */
X  /* this next one is kind of special, and requires some special
X     handling.  this flag means that (at draft/summon/reset time)
X     the army will be given the WATER flag if it is a land race,
X     and the LAND flag if it is a water race.  The special-purpose
X     code for this flag should be in make_army() and reset_armies().
X   */
X#define AF_INVERSE_ALT 0x8000	/* opposite of race pref (32768) */
X
X  /* a couple of useful macros */
X#define is_hidden(ap) (ap->flags & AF_HIDDEN)
X#define is_vampire(ap) (ap->flags & AF_VAMPIRE)
X#define is_flight(ap) (ap->flags & AF_FLIGHT)
X#define is_in_transport(ap) (ap->flags & AF_IN_TRANSPORT)
X#define is_missiles(ap) (ap->flags & AF_MISSILES)
X#define is_water(ap) (ap->flags & AF_WATER)
X#define is_front_line(ap) (ap->flags & AF_FRONT_LINE)
X#define is_kamikaze(ap) (ap->flags & AF_KAMIKAZE)
X#define is_machine(ap) (ap->flags & AF_MACHINE)
X#define is_disguised(ap) (ap->flags & AF_DISGUISED)
X#define is_wizard(ap) (ap->flags & AF_WIZARD)
X#define is_sorcerer(ap) (ap->flags & AF_SORCERER)
X#define is_cargo(ap) (ap->flags & AF_CARGO)
X#define is_underground(ap) (ap->flags & AF_UNDERGROUND)
X#define is_land(ap) (ap->flags & AF_LAND)
X
X#define INITIATION_JEWELS 5000	/* cost to initiate a mage (jewels) */
X#define MAGE_JEWELS_MAINT 1000  /* cost to maintain a mage (jewels) */
X#define MAGE_MOVE_FACTOR 2	/* mages move 2*basic_rate */
X#define SORCERER_MOVE_FACTOR 1  /* sorcerers move at basic rate */
X#define MEN_PER_MACHINE 10
END_OF_FILE
if test 4051 -ne `wc -c <'army.h'`; then
    echo shar: \"'army.h'\" unpacked with wrong size!
fi
# end of 'army.h'
fi
if test -f 'dominion.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dominion.c'\"
else
echo shar: Extracting \"'dominion.c'\" \(5979 characters\)
sed "s/^X//" >'dominion.c' <<'END_OF_FILE'
X  /* dominion.c -- main loop of dominion */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include <stdio.h>
X#include <signal.h>
X
X  /* most of these data structures are declared in ext.c */
Xextern Suser user;
Xextern Sworld world;
Xextern struct race_list *races;
Xextern char libdir[];
Xextern int euid, ruid;
Xextern char help_tag[];
Xextern int interrupt();
Xextern int (*keymap[128])();
Xextern char *get_update_time(), *update_time;
X
Xint old_umask;			/* to reset when we leave */
X#ifdef ANDREW
Xint beroot = 0;
X#endif
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X  int c;
X  int innation = 0;
X  char nation[NAMELEN];
X  extern char *optarg;
X  extern int optind;
X#ifdef BSD
X    /* BSD uses getwd(), which does not allocate static space */
X  extern char current_dir[], *getwd();
X#else /* BSD */
X  extern char *current_dir, *getcwd();
X#endif /* BSD */
X    /* starting help tag is Top */
X  strcpy(help_tag, "Top");
X
X    /* now get some unix system information */
X  ruid = getuid();
X  euid = geteuid();
X  old_umask = umask(077);
X/*  printf("ruid = %d, euid = %d\n", ruid, euid); */
X#ifdef BSD
X  getwd(current_dir);
X#else /* BSD */
X  current_dir = getcwd(NULL, PATHLEN);
X#endif /* BSD */
X/*  printf("current dir is %s\n", current_dir); */
X  strcpy(libdir, DEF_LIBDIR);
X
X  user.xmode = 0;
X#ifndef ANDREW
X  while ((c = getopt(argc, argv, "n:d:vphc--")) != EOF)
X#else
X  while ((c = getopt(argc, argv, "n:d:vuphc--")) != EOF)
X#endif
X    switch (c) {
X#ifdef ANDREW
X     case 'u':
X       beroot = 0;
X       break;
X#endif
X    case 'n':
X      innation = 1;
X      strcpy(nation, optarg);
X      break;
X    case 'v':
X      /*      viewall = 1; */
X      break;
X    case 'd':
X      strcpy(libdir, optarg);
X      break;
X    case 'h':
X      chdir(libdir);
X      init_screen();
X      online_info();
X      resetty();
X      endwin();
X      exit(1);
X    case 'p':
X      chdir(libdir);
X      read_races();
X      read_world(&world, WORLD_FILE);
X      print_nations();
X      exit(1);
X   case 'c':
X      chdir(libdir);
X      printf("Last update at %s\n",get_update_time());
X      exit(0);
X    default:
X      usageerr(argc,argv);
X      exit(1);
X   }
X#ifdef ANDREW
X  if (beroot == 1) {
X    Authenticate();
X    beGames();
X  }
X#endif
X  if (chdir(libdir) != 0) {
X    fprintf(stderr,"Error: cannot cd to directory %s\n",libdir);
X    clean_exit();
X    exit();
X  }
X  update_time = get_update_time();
X/*  printf("libdir=%s,def_libdir=%s\n", libdir, DEF_LIBDIR); */
X
X  init();			/* set up data structures */
X  init_user(innation, nation);
X    /* init keymap after user is loaded, because of master commands */
X  init_keymap();
X  init_screen();
X  intro(&world, user.np);
X  noncritical();		/* normal signal operation */
X  main_loop();
X  cleanup();
X  clean_exit();
X  exit(0);
X}
X
Xinit()
X{
X  printf("Initializing...\r\n");
X  SRND(time(0L));		/* initialize random number generator */
X  read_races();			/* get races from races file */
X    /* read in the world */
X  read_world(&world, WORLD_FILE);
X}
X
X	/* this is where all the work is done  */
Xmain_loop()
X{
X  char c;
X  char s[80];
X
X  for ( ; ; ) {
X    sprintf(s, "Nation %s; money %d; Thon %d;   type %c for help",
X	    user.np->name, user.np->money, world.turn, user.help_char);
X    statline(s, "draw_map_regular");
X    if (user.just_moved) {
X      draw_map();
X      user.just_moved = 0;
X    }
X    set_cursor();
X    switch(c = getch()) {
X    default:
X      (*keymap[c % 128])();	/* make sure no high bits get there */
X      (void) re_center(user.cursor.x, user.cursor.y); /* ignore return val */
X      if (user.just_moved) {
X	wrap(&user.cursor);
X	if (!army_is_in_sector(&world.map[user.cursor.x][user.cursor.y],
X			       user.id, user.current_army)) {
X	  user.current_army
X	    = first_sect_army(&world.map[user.cursor.x][user.cursor.y]);
X	}
X      }
X      break;
X    }
X  }
X}
X
X  /* clean up graphics, and flush out the exec file */
Xcleanup()
X{
X  int i;
X
X  statline("", "cleanup");
X/*  delay_output(200); */
X  resetty();
X  endwin();
X  putchar('\n');
X  putchar('\n');
X  gen_exec(NULL);
X}
X
Xclean_exit()
X{
X  extern int is_in_diplo;
X
X  if (is_in_diplo) {
X    unlink("DIPLOCK");
X  }
X  del_lock(user.id);
X  umask(old_umask);
X#ifdef ANDREW
X  if (beroot == 1) {
X    bePlayer();
X    unAuth();
X    beroot = 0;
X  }
X#endif
X}
X
Xcritical()			/* while writing data files, don't bug me!! */
X{
X  signal(SIGINT, SIG_IGN);
X  signal(SIGQUIT, SIG_IGN);
X#ifdef SIGTSTP
X  signal(SIGTSTP, SIG_IGN);
X#endif /* SIGTSTP */
X  signal(SIGHUP, SIG_IGN);
X}
X
Xnoncritical()			/* normal operation */
X{
X  signal(SIGINT, interrupt);
X  signal(SIGQUIT, interrupt);
X#ifdef SIGTSTP
X  signal(SIGTSTP, interrupt);
X#endif /* SIGTSTP */
X  signal(SIGHUP, interrupt);
X}
X
X  /* just prints a list of all nations to the terminal */
Xprint_nations()
X{
X  int i;
X  Snation *np;
X
X  printf("%s %-14s[%s]    %-15s %-10s\n", "Id", "Name",
X	 "mark", "Leader", "Race");
X  printf("----------------------------------------------------------------------\n");
X  for (i = 1; i < world.n_nations; ++i) {
X    np = &world.nations[i];
X    printf("%2d %-15s [%c]     %-15s %-10s %-10s %-5s\n", i, np->name,np->mark,
X	   np->leader, np->race.name, is_active_ntn(np) ? "" : "DESTROYED",
X	   np->npc_flag ? "npc" : "");
X  }
X}
X
END_OF_FILE
if test 5979 -ne `wc -c <'dominion.c'`; then
    echo shar: \"'dominion.c'\" unpacked with wrong size!
fi
# end of 'dominion.c'
fi
if test -f 'ext.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ext.c'\"
else
echo shar: Extracting \"'ext.c'\" \(4664 characters\)
sed "s/^X//" >'ext.c' <<'END_OF_FILE'
X  /* declaration of various shared variables */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X
XSuser user;
XSworld world;
Xint compressed_world=0;		/* is world file compressed? */
Xstruct race_list *races;	/* list of races available */
Xstruct army_type *army_types;	/* array of available armies */
Xstruct spirit_type *spirit_types; /* array of available spirits */
XSh_spell *hanging_spells;
Xchar libdir[200];		/* the dir. the game lives in */
X	/* users's current directory */
X#ifdef BSD			/* BSD does not return a static string */
Xchar current_dir[PATHLEN];
X#else /* BSD */
Xchar *current_dir;
X#endif /* BSD */
X
Xint ruid, euid;			/* user ids */
Xchar help_tag[EXECLEN];		/* current help topic */
Xint is_in_diplo = 0;
X
X  /* each ascii key points to a function which handles that key */
Xint (*wrapx)();
Xint (*wrapy)();
Xint (*keymap[128])();
X
Xint debug = 0;
X
Xstruct s_desig_map desig_map[]
X  = {  {'x', "none", 1000, 30, 0, 20}, {'f', "farm", 5000, 100, 10, 500},
X	 {'m', "mtl. mine", 10000, 100, 10, 800},
X	 {'j', "jwl. mine", 10000, 100, 10, 800},
X	 {'c', "city", 30000, 200, 300, 5000},
X	 {'C', "capital", 50000, 300, 300, 7000},
X	 {'u', "university", 10000, 30, 200, 1000},
X	 {'+', "temple", 5000, 0, 200, 1000},
X	 {'s', "stadium", 5000, 150, 10, 400},
X	 {'T', "trade post", 10000, 150, 10, 300},
X	 {'e', "embassy", 5000, 0, 50, 200},
X	 {'!', "fort", 10000, 50, 10, 200},
X	 {'h', "hospital", 10000, 100, 10, 300},
X	 {'r', "refinery", 8000, 130, 100, 200} };
X
X/* Lowest altitude must come first in this list and they must be in order */
X
Xstruct s_altitude_map altitude_map[]
X  = {  {'v',"Trench",TRENCH}, {'-',"Ocean Plain",OCEAN_PLAINS},
X	 {'^',"Sea Mountain",SEA_MOUNT}, {'+',"Cont. Shelf",CONT_SHELF},
X	 {'#',"Shallows",SHALLOWS}, {'~',"Sea Level",SEA_LEVEL},
X	 {'.',"Lowlands",LOWLANDS}, {'-',"Plains",PLAINS},
X	 {'%',"Hills",HILLS}, {'=',"Plateau",PLATEAU},
X	 {'^',"Mountains",MOUNTAINS}, {'+',"Mountain Peak",MOUNTAIN_PEAK} };
X
Xstruct item_map terrains[] 
X  = {  {'O',"Ocean"}, {'B',"Bay"}, {'R',"Reef"}, {'L',"Lake"}, {'R',"River"},
X	 {'#',"Ice"}, {'b',"Barren"}, {'s',"Swamped"}, {'g',"Grassy"}, 
X	 {'B',"Brush"}, {'f',"Forested"}, {'j',"Jungle"} };
X
Xstruct item_map climates[]
X  = {  {'D',"Desert"}, {'d',"Semiarid"}, {'h',"Humid Subtropical"},
X	 {'t',"Tropical Wet and Dry"}, {'T',"Rainy Tropical"},
X	 {'s',"Dry Summer Subtropical"}, {'m',"Mid-latitude Marine"},
X	 {'w',"Humid Continental Warm"}, {'c',"Humid Continental Cool"},
X	 {'a',"Subarctic"}, {'A',"Polar"} };
X
Xchar *dip_status[] = { " SELF" , " UNMET", "JIHAD", "WAR", "HOSTILE", 
X                       "UNRECOGNIZED", "NEUTRAL", "RECOGNIZED", "FRIENDLY", 
X                       "ALLIED", "TREATY" };
X
Xstruct item_map tradeitems[] 
X  = {  {'g', "GOLD"}, {'m', "METAL"}, {'j', "JEWELS"}, {'f', "FOOD"},
X	 {'e', "END"} };
X
Xstruct army_flags army_flags[] =
X{
X  {'F', "This army flies"},
X  {'H', "This army is hidden"},
X  {'V', "This army will possess the dead"},
X  {'T', "This army is in transport"},
X  {'^', "This army uses missiles"},
X  {'W', "This army travels in water"},
X  {'f', "This army is front line"},
X  {'k', "This army is kamikaze"},
X  {'m', "This army is a machine"},
X  {'d', "This army can disguise itself"},
X  {'w', "This army can cast spells"},
X  {'s', "This army is a sorcerer"},
X  {'c', "This army can carry cargo"},
X  {'U', "This army burrows underground"},
X  {'L', "This army travels on land"},
X  {'I', ""},
X  {' ', ""},{' ', ""},{' ', ""},{' ', ""},{' ', ""},{' ', ""},
X  {' ', ""},{' ', ""},{' ', ""},{' ', ""},{' ', ""},{' ', ""},{' ', ""},
X  {' ', ""},{' ', ""},{' ', ""}};
X
X
X/* char *army_flags[] =
X  { "F","H","V","T","^","W","f","k","m","d","w","s","c","U","L" ,"I" ,
X     "" ,"" ,"" ,"" ,"" ,"" ,"" ,"" ,"" ,"" ,"" ,"" ,"" ,"" ,"" ,"" };
X*/
X
Xchar *update_time;
Xchar *civ_move[] =  { "None", "Restricted", "Free" };
XSh_spell *dead_spells = NULL;
END_OF_FILE
if test 4664 -ne `wc -c <'ext.c'`; then
    echo shar: \"'ext.c'\" unpacked with wrong size!
fi
# end of 'ext.c'
fi
if test -f 'gm.tex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gm.tex'\"
else
echo shar: Extracting \"'gm.tex'\" \(3686 characters\)
sed "s/^X//" >'gm.tex' <<'END_OF_FILE'
X\documentstyle[12pt]{report}
X\pagestyle{headings}
X
X\begin{document}
X
X\pagestyle{empty}
X
X\title{Dominion Gamemaster's Manual}
X
X\author{Mark Galassi}
X
X\date{\today}
X
X\maketitle
X
X\pagestyle{headings}
X
X\tableofcontents
X
X\chapter{Overview}
XThis document gives some hint to the Game Master on how to run a game
Xof {\bf Dominion}.  It is {\em extremely} incomplete.
X
X\chapter{Making a world}
X
XLook at the README file to see how to compile dominion.
X
XOnce you have run ``make new-world'', everything should be set up.
XYou might want to make sure that the ownership of the files in LIBDIR
Xis correct, and that the prgram {\em dominion} is setuid to that
Xowner (using the {\em chmod} command).
X
XThe world is made with one nation already in it.  This nation is
Xcalled {\em Gamemaster}, of race {\em Creator} and magic order {\em
XMaster}.  The Gamemaster nation is not really to be played as a
Xnation, since it does not have any sectors, or any other desireable
Xproperties.  But it has the most totally bodacious [E] command which
Xwill be described below.
X
X\chapter{Adding a nation}
X
XYou run the program dom\_add.  You have to run this with the userid of
Xthe owner of the game.  You will be prompted interactively for all the
Xparamters of this nation.  Then the nation will be added to the world
Xand they can play.  Nations should be added when nobody is playing,
Xand while you are adding anyone in the game will be kicked out.
X
X\chapter{News and mail}
X
XYou will be prompted to set up some newsgroups for the game.  There is
Xalways a newsgroup called {\em News} in which general information is
Xposted about the update, battles, and so on.  You should create
Xanother newsgroup which can be posted to by all nations.  This gives
Xthe players a public forum which can induce some great role-playing.
X
XMail is sent from one player to the other within the game.  A player
Xcan set a {\em forwarding address} with the [O]ptions menu.  The mail
Xwill be sent to the electronic mail address they specify.
X
XNews can also be forwarded: the Gamemaster creates a file called
X``news.post'' which contains a list of electronic mail addresses.
XThis file should reside in the main dominion LIBDIR.  Any news article
Xwill be mailed to everyone in that list when it gets posted.
X
X\chapter{Special Gamemaster commands}
X
XThe Gamemaster can do special things to the game in two ways: by {\bf
Xediting the ``exec files''} and by using the {\bf Edit Sector} and {\bf
XEdit Nation} commands.
X
XEditing the ``exec files'' requires some knowledge of how the game
Xworks internally, though some people who have not seen the source code
Xhave been able to work on this.
X
XThe [E]dit command to edit a [s]ector or a [n]ation is menu-driven, so
Xyou can experiment with it.  It allows you to change their storage of
Xfood, metal, jewels, spell points and so on.  It also allows you to
Xchange the population of a sector, or to add to a nation's magic and
Xtechnological skill.
X
XYou should be careful using these Game Master commands, since some of
Xthem have not yet been tested in all possible contexts.  You should be
Xmost careful about changing the ownership of a sector.  For now it has
Xbeen tested only for changing sector ownership from {\em unowned} to
Xbeing owned by a given nation.  Changing ownership from one nation to
Xanother has not been tested.  In fact, I suspect it will not work.
X
X\chapter{Using the Master race and order}
X
XThe magic order Master can be used to create special nations run by
Xthe Game Master, since it gets all spells and spirits for free.  This
Xway you can do some active ``Gamemaster'' play, if you so wish.
X
XYou should not give the magic order Master to any ordinary player.
X
Xmore here....
X
X\end{document}
END_OF_FILE
if test 3686 -ne `wc -c <'gm.tex'`; then
    echo shar: \"'gm.tex'\" unpacked with wrong size!
fi
# end of 'gm.tex'
fi
if test -f 'mag_Chess' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mag_Chess'\"
else
echo shar: Extracting \"'mag_Chess'\" \(697 characters\)
sed "s/^X//" >'mag_Chess' <<'END_OF_FILE'
X# this file describes magic powers available to magical order of Chess,
X# which is of a highly mystical nature.
X#
X# the format for spirits is:
X#	name level cost
X# and for spells:
X#	name level cost duration
X#
X# where `level' is the magical skill level at which you get the power,
X# and `cost' is the cost in spell points to use the power.  `duration'
X# tells how long a spell will last.
X#
Xsummon_pawn 40 1
Xsummon_knight 90 4
Xsummon_bishop 120 5
Xsummon_rook 200 6
Xsummon_queen 600 9
Xsummon_king 1000 8
Xsummon_master 1500 11
Xsummon_grandmaster 2000 14
X#
Xhide_sector 125 1 8
Xhide_army 200 1 2
Xmag_bonus 300 1 2
Xfly_army 400 2 2
Xwater_walk 400 2 2
Xhaste_army 600 3 2
X#
Xcastle 150 2 0
Xstalemate 500 1 4
END_OF_FILE
if test 697 -ne `wc -c <'mag_Chess'`; then
    echo shar: \"'mag_Chess'\" unpacked with wrong size!
fi
# end of 'mag_Chess'
fi
if test -f 'news.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'news.c'\"
else
echo shar: Extracting \"'news.c'\" \(6062 characters\)
sed "s/^X//" >'news.c' <<'END_OF_FILE'
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "news.h"
X#include <stdio.h>
X#ifdef AMIGA
X#  include <exec/types.h>
X#  define sleep(x) Delay(x*50)
X#else
X#  include <sys/types.h>
X#endif
X#include <time.h>
X#ifdef SYSV
X#  include <string.h>
X#else
X#  include <strings.h>
X#endif
X
Xextern Sworld world;
Xextern Suser user;
X
Xchar *news_post()
X{
X    FILE *file;
X    static char buffer[1024];
X    char *ptr;
X
X    sprintf(buffer, "news.post");
X    if (file = fopen(buffer, "r")) {
X	fgets(buffer, sizeof(buffer), file);
X	fclose(file);
X	ptr = buffer + strlen(buffer) - 1;
X	if (*ptr == '\n')
X	    *ptr = '\0';
X	return buffer;
X    }
X    else
X	return NULL;
X}
X
Xint valid_group(name,posting)
Xchar *name;
Xint posting;
X{
X  char news_dir[100],g_fn[100],in[100];
X  char post_in;
X  FILE *g_fp;
X  int ret = 0;
X  char out[100];
X  char s_in[100];
X
X  sprintf(news_dir,"%s",NEWS_DIR);
X  sprintf(g_fn,"%s/%s",news_dir,NGDB_FILE);
X  
X  g_fp=fopen(g_fn,"r");
X  if (g_fp!=NULL)
X/*    while((fscanf(g_fp,"%s %*d %*d %*c",in))>0)*/
X    while((fgets(s_in,100,g_fp))!=NULL)
X      {
X	s_in[strlen(s_in)-1] = '\0';
X	sscanf(s_in,"%s %*d %*d %c",in,&post_in);
X	if((!posting)&&(!strcmp(in,name)))
X	  ret=1;
X	else
X	  if((posting)&&(!strcmp(in,name))&&(post_in=='1'))
X	    ret=1;
X      }
X  if (g_fp != NULL) { fclose(g_fp); }
X  return(ret);
X} /* valid_group */
X	
Xs_group *group_find(first,name)
Xs_group *first;
Xchar *name;
X{
X  s_group *loop,*ret;
X  ret=NULL;
X  for (loop=first;loop!=NULL;loop=loop->next)
X    if (!strcmp(name,loop->name))
X      ret=loop;
X  return(ret);
X} /* group_find */
X      
X/* This checks if someone else is adding an article (ie it's locked) */
X
Xint check_news_lock()
X{
X  FILE *lock_fp;
X  char lock_fn[100];
X  char news_dir[100];
X  int ret;
X
X  sprintf(news_dir,"%s",NEWS_DIR);
X  sprintf(lock_fn,"%s/%s.lock",news_dir,NGDB_FILE);
X  if ((lock_fp=fopen(lock_fn,"r"))!=NULL) {
X    ret=0;
X    fclose(lock_fp);
X  } else {
X    ret=1;
X  }
X  return(ret);
X}   /* check_news_lock */
X
Xvoid lock_news()
X{
X  FILE *lock_fp;
X  char news_dir[100],lock_fn[100];
X
X  sprintf(news_dir,"%s",NEWS_DIR);
X  sprintf(lock_fn,"%s/%s.lock",news_dir,NGDB_FILE);
X  if ((lock_fp=fopen(lock_fn,"w"))!=NULL)
X    {
X      fprintf(lock_fp,"locked\n");
X      fclose(lock_fp);
X    }
X}  /* lock_news */
X
Xvoid unlock_news()
X{
X  char news_dir[100],lock_fn[100];
X  sprintf(news_dir,"%s",NEWS_DIR);
X  sprintf(lock_fn,"%s/%s.lock",news_dir,NGDB_FILE);
X  unlink(lock_fn);
X}  /* unlock_news */
X
Xvoid group_insert(first,temp)
Xs_group **first,*temp;
X{
X  s_group *loop;
X  
X  if (*first==NULL)
X    {
X      *first=temp;
X    }
X  else
X    {
X      for (loop=(*first);loop->next!=NULL;loop=loop->next);
X      loop->next=temp;
X    }
X} /* group_insert */
X
Xpost_news_file(news_file,group_name,subject,id)
Xchar *news_file,*group_name,*subject;
Xint id;
X{
X  FILE *in,*out;
X  FILE *g_fp;
X  char news_dir[100],g_fn[100],g_dir[100],a_fn[100];
X  s_group *g_first,*g_temp;
X  char g_name_in[100],post_in;
X  int first_in,last_in;
X  int news_locked;
X  char cmd[1000];
X  char s_in[100];
X  FILE *a_fp;
X  char *forward;
X
X  g_first=NULL;
X
X  sprintf(news_dir,"%s",NEWS_DIR);
X  sprintf(g_fn,"%s/%s",news_dir,NGDB_FILE);
X  sprintf(g_dir,"%s/%s",news_dir,group_name);
X  if (!(news_locked=check_news_lock()))
X    {
X      sleep(2);
X      news_locked=check_news_lock();
X    }
X  if (news_locked==1)
X    {
X      lock_news();
X      if ((g_fp=fopen(g_fn,"r")) == NULL) {
X	printf(
X            "\nCould not open file %s for reading; you should check it out\n",
X	       g_fn);
X      } else {
X/*while((fscanf(g_fp,"%s %d %d %c",g_name_in,&first_in,&last_in,&post_in))>0)*/
X	while ((fgets(s_in,100,g_fp))!=NULL) {
X	  s_in[strlen(s_in)-1] = '\0';
X	  sscanf(s_in,"%s %d %d %c",g_name_in,&first_in,&last_in,&post_in);
X	  g_temp=(s_group *)malloc(sizeof(s_group));
X	  strcpy(g_temp->name,g_name_in);
X	  /*	  sprintf(*g_temp->name,"%s",g_name_in); */
X	  g_temp->first=first_in;
X	  g_temp->last=last_in;
X	  g_temp->postable=post_in;
X	  g_temp->next=NULL;
X	  group_insert(&g_first,g_temp);
X	}
X	fclose(g_fp);
X      }
X      g_temp=group_find(g_first,group_name);
X      if (g_temp==NULL) {
X	fprintf(stderr,"Bad group name: %s\n",group_name);
X      } else {
X	  /* sprintf(a_fn,"%s/%d",g_dir,g_temp->last+1);
X	  sprintf(cmd,"mv %s %s",news_file,a_fn);
X	  system(cmd);
X	  */
X	sprintf(a_fn,"%s/%d",g_dir,g_temp->last+1);
X	a_fp=fopen(a_fn,"w");
X	if (a_fp==NULL) {
X	  fprintf(stderr,"Error Opening New Article File Pointer\n");
X	  return(1);
X	}
X	fprintf(a_fp,"Date: Thon %d\n",world.turn);
X	if (id==0) {
X	  fprintf(a_fp,"From: Update\n");
X	} else {
X	  fprintf(a_fp,"From: %s\n",world.nations[id].name);
X	  fprintf(a_fp,"Author: %s of %s\n",world.nations[id].leader,
X		  world.nations[id].name);
X	}
X	fprintf(a_fp,"Subj: %s\n\n",subject);
X	insert(news_file,a_fp);
X	if (a_fp != NULL) { fclose(a_fp); }
X	unlink(news_file);
X	(g_temp->last)++;
X      }
X      if ( (forward = news_post()) != NULL) {
X	sprintf(cmd, "cat %s | %s '%s'", a_fn, MAILER, forward);
X	system(cmd);
X      }
X      g_fp=fopen(g_fn,"w");
X      for (g_temp=g_first;g_temp!=NULL;g_temp=g_temp->next) {
X	fprintf(g_fp,"%s %d %d %c\n",g_temp->name,g_temp->first,
X		g_temp->last,g_temp->postable);
X      }
X      if (g_fp != NULL) { fclose(g_fp); }
X      unlock_news();
X    } /* News_locked==1 */
X} /* Post_news_file */
END_OF_FILE
if test 6062 -ne `wc -c <'news.c'`; then
    echo shar: \"'news.c'\" unpacked with wrong size!
fi
# end of 'news.c'
fi
if test -f 'spirit_types' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spirit_types'\"
else
echo shar: Extracting \"'spirit_types'\" \(6149 characters\)
sed "s/^X//" >'spirit_types' <<'END_OF_FILE'
X# format of file (similar to races and army types file):
X# number of spirit types defined
X# type:char:size:move_factor:bonus:spellpt_draft:jewel_draft:jewel_maint:flags
X# where the flags are defined as bit locations in army.h (1 for fly etc...)
X#
X# See the file "army.h" for the meaning of the flags.
X#
X112
X# demonology
Ximp          : i :  30:2.0: 0:  2:  0:  30: 0
Xlesser_demon : l :  70:1.7: 0:  3:  0:  70: 0
Xhellhound    : h : 150:1.7: 0:  4:  0: 150: 0
Xdevil        : d : 250:1.0: 0:  4:  0: 250: 0
Xtormented_soul :t: 300:1.2:100: 5:  0: 300: 128
Xmajor_demon  : m : 500:2.0: 0:  8:  0: 500: 1
Xbalrog       : b :1500:1.5:50: 15:  0:1500: 0
Xdemon_lord   : d :2500:2.0: 0: 19:  0:2500: 1024
X# diana (mole is also in aule, swarm is also in insects) (shark is in neptune)
Xwolf      : w :  30:1.5: 0:  1:  0:  30: 0
Xswarm     : s :  50:1.3:300: 3:  0:  50: 129
Xmole      : m :  70:1.0: 0:  3:  0:  70:24576
Xsnake     : s : 100:0.8: 0:  3:  0: 100: 0
Xhawk      : e : 200:2.0: 0:  5:  0: 200: 1
Xbear      : b : 300:1.4: 0:  5:  0: 300: 0
Xlion      : l : 500:1.5: 0:  6:  0: 500:16384
Xterrasque : t :2000:0.5: 0: 13:  0:2000:16384
X# Monsters
Xspider        : s :   30:0.8: 0: 1: 0:  30: 0
Xyeti          : y :   70:1.0: 0: 2: 0:  70:16384
Xettin         : e :  120:1.5: 0: 3: 0: 120: 0
Xcyclops       : c :  150:0.8: 0: 3: 0: 150: 0
Xhydra         : h :  250:1.2: 0: 4: 0: 250: 0
Xcrimson_death : d :  500:2.0: 0: 8: 0: 500: 1
Xsea_dragon    : s : 1000:1.2: 0:10: 0:1000:32
Xgreen_dragon  : D : 1500:2.0: 0:11: 0:1500:16384
Xred_dragon    : r : 2500:1.5: 0:17: 0:2500: 1
Xgold_dragon   : g : 3500:2.0: 0:24: 0:3500:1025
X# Necromancy
Xghost_ship    : g :    1:2.5: 0: 1: 0:   1:36866
Xskeleton      : s :   40:0.8: 0: 1: 0:  40: 0
Xwraith        : w :   30:1.5: 0: 2: 0:  30: 2
Xzombie        : z :   70:0.8: 0: 3: 0:  70: 4
Xpoltergeist   : p :  150:0.1: 0: 3: 0: 150: 512
Xmummy         : m :   80:0.8:30: 3: 0:  80:8192
Xghost         : g :  250:0.7:20: 5: 0: 250: 1
Xlacedon       : l :  500:1.0: 0: 8: 0: 500:32
Xlich          : l : 2000:2.0:-20:14:0:2000:1024
Xvampire       : v : 1500:0.8:30:15: 0:1500: 4
X# Yavanna  (need more)
Xdryad         : d :   30:1.0: 0:  1:  0:  30: 0
Xtree_spirit   : t :   50:1.5: 0:  2:  0:  50: 1
Xwood_beast    : w :   70:1.0: 0:  2:  0:  70: 0
Xmagic_trees   : m :  150:1.0: 0:  3:  0: 150: 0
Xyellow_musk   : y :  200:0.7: 0:  4:  0: 200: 4
Xent           : e :  250:0.8: 0:  4:  0: 250: 0
Xswamp_beast   : s :  500:1.0:10:  6:  0: 500:32
Xshambling_mound :s: 1200:0.8:10: 10:  0:1200: 0
Xforest        : F : 2000:0.7: 0: 14:  0:2000: 0
X# Chess (think of AF_HOPPING flag for knight; for now make it hidden)
Xpawn         : p :  30:0.5: 0:  1:  0:  50: 0
Xknight       : N : 120:1.0:10:  4:  0: 120: 2
Xbishop       : b : 150:2.0: 0:  5:  0: 150: 1
Xrook         : r : 250:3.0:30:  6:  0: 250: 0
Xking         : K :1000:0.4: 0:  8:  0:1000: 0
Xqueen        : Q : 500:4.0:50:  9:  0: 500: 0
Xmaster       : m :2000:1.0:10: 11:  0:2000: 0
Xgrandmaster  : g :3000:1.3:20: 14:  0:3000:1024
X# Neptune
Xliving_ship     : l :    4:2.5: 0:  1:  0:   1:36864
Xpirana          : p :   30:1.2: 0:  1:  0:  30:32
Xwater_nymph     : n :   50:1.2: 0:  2:  0:  50:32
Xwhale           : w :   80:1.0: 0:  2:  0:  80:32
Xshark           : s :  100:1.5:10:  3:  0: 100:32
Xsea_serpent     : S :  150:1.2: 0:  3:  0: 500:16416
Xcraken          : k :  250:1.0: 0:  4:  0: 250:32
Xsea_giant       : g :  500:0.8: 0:  5:  0: 500:32
Xwater_elemental : W : 2000:2.0: 0: 15:  0:2000:32
Xleviathan	: l : 3000:0.9:10: 18:  0:3000:32
X# Aule (mole is in diana)
Xgargoyle        : g :   30:1.0: 0:  2:  0:  30: 1
X#mole           : m :   70:1.0: 0:  3:  0:  70:8192
Xdust_devil      : d :  150:1.0: 0:  4:  0: 150:16385
Xumber_hulk      : U :  250:1.7: 0:  6:  0: 150:24576
Xstone_giant     : S :  500:0.7: 0:  6:  0: 250: 0
Xearth_elemental : E : 2000:2.0: 0: 16:  0:2000:8192
Xmountain        : M : 3000:0.3:60: 22:  0:3000: 0
X# Inferno
Xefreet          : e :   70:1.5: 0:  2:  0:  70:16384
Xphoenix         : p :   30:2.0: 0:  3:  0:  30:16385
Xfire_giant      : g :  250:1.0: 0:  4:  0: 250:16384
Xfire_drake      : f :  500:1.5: 0:  6:  0: 500: 0
Xlava_beast      : l : 1000:1.0: 0: 10:  0:1000:8192
Xfire_elemental  : F : 2000:2.0: 0: 15:  0:2000:16384
Xconflagration   : c : 3000:1.5: 0: 18:  0:3000:16384
X# Avian
Xflying_carpet   : f :    1:1.5: 0:  1:  0:   1:4097
Xroc             : r :   30:1.5: 0:  1:  0:  30: 1
Xeagle           : e :   70:1.5: 0:  2:  0:  70: 1
Xcloud_giant     : a :  150:1.0: 0:  3:  0: 150: 1
Xwyvern          : c :  250:1.0: 0:  4:  0: 250: 1
Xareal_serpent   : s :  500:1.8: 0:  7:  0: 500: 1
Xair_elemental   : A : 2000:2.0: 0: 15:  0:2000: 1
Xtempest         : t : 3000:2.0: 0: 19:  0:3000: 1
X# Unity
Xnaga            : n :   30:1.0: 0:  1:  0:  30: 0
Xcentaur         : c :   70:2.0: 0:  3:  0:  70: 0
Xwerewolf        : w :  100:1.5: 0:  4:  0: 100:516
Xminotaur        : m :  150:1.0: 0:  3:  0: 150:16384
Xowl_bear        : o :  250:1.0: 0:  4:  0: 250: 0
Xgryphon         : g :  350:2.0: 0:  7:  0: 350: 1
Xsea_lion        : s :  600:1.5: 0:  7:  0: 600:32
Xchimera         : c : 1000:1.5: 0: 10:  0: 600: 1
Xsphynx          : s : 2000:0.8: 0: 17:  0:2000:1025
X# Time
Xdiplodocus      : d :   30:1.3: 0:  1:  0:  30: 0
Xbrontosaurus    : b :   70:0.7: 0:  3:  0:  70: 0
Xpleisiosaurus   : p :   50:1.5: 0:  3:  0:  50:32
Xpterodactyl     : p :  150:1.5: 0:  4:  0: 150: 1
Xstegosaurus     : s :  250:1.0: 0:  4:  0: 250: 0
Xtriceratops     : t :  500:0.8: 0:  6:  0: 500:16384
Xtyrannosaurus   : t : 1500:1.5: 0: 12:  0:1500: 0
Xbrachiosaurus   : b : 3000:0.5: 0: 18:  0:3000:16416
X# insects (swarms are in Diana)
Xant             : d :   30:1.0: 0:  2:  0:  30:24576
X#swarm          : b :   50:1.3:300: 3:  0:  50: 129
Xfly             : p :   70:1.0: 0:  3:  0:  70:   1
Xmoth            : p :  150:1.5: 0:  4:  0: 150:   1
Xbee             : s :  250:1.2:30:  6:  0: 250:   1
Xgrasshopper     : t :  350:1.0: 0:  6:  0: 500:16386
Xmosquito        : t :  500:0.5: 0:  6:  0: 500:   5
Xinfestation     : i :  600:0.0:50:  6:  0: 600:   0
Xroach           : t : 1000:0.8:20: 10:  0:1000:   0
Xlobster         : b : 1500:1.0: 0: 13:  0:1500:  32
Xcreeping_doom   : c : 2500:0.8:20: 17:  0:2500:   0
END_OF_FILE
if test 6149 -ne `wc -c <'spirit_types'`; then
    echo shar: \"'spirit_types'\" unpacked with wrong size!
fi
# end of 'spirit_types'
fi
if test -f 'techno.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'techno.c'\"
else
echo shar: Extracting \"'techno.c'\" \(4888 characters\)
sed "s/^X//" >'techno.c' <<'END_OF_FILE'
X  /* techno.c -- updates technology for a nation in dominion */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X
X#include <stdio.h>
X#include <math.h>
X
Xextern int debug;
Xextern Suser user;
X
X#define METAL_TECH_POWER (3.0/4.0)
X
X  /* this routine calculates the new tech_skill for a nation */
Xnew_tech_skill(np)
X     Snation *np;
X{
X  int increase;
X
X  increase =
X    (int) (((np->race.intel + univ_intel(np)) / 100.0) *
X	   (sqrt(1.0 * (calc_revenue(np)*np->tech_r_d/100.0 +
X			np->money * np->cur_tech_r_d / 100))
X	    * TECH_MONEY_FACTOR +  pow((double)(calc_metal (np) *
X             (np->tech_r_d_metal / 100.0) + np->metal * 
X              np->cur_tech_r_d_metal / 100),METAL_TECH_POWER) 
X               * TECH_METAL_FACTOR));
X  return np->tech_skill + increase;
X}
X
X  /* this routine sees if the user should get a new
X     technology level, by comparing its old and new tech skills
X   */
Xget_new_techno(np, old_skill, new_skill, mailfile)
X     Snation *np;
X     int old_skill, new_skill;
X     FILE *mailfile;
X{
X  FILE *fp, *fopen();
X  int level;
X  char name[NAMELEN], line[EXECLEN], execstr[EXECLEN];
X  int done = 0;
X
X  if ((fp = fopen(TECHNO_FILE, "r")) == NULL) {
X    printf("could not open technology file %s\n", TECHNO_FILE);
X    return -1;
X  }
X
X  while (!done) {
X    if (fgets(line, EXECLEN, fp) == NULL) {
X      done = 1;
X      break;			/* we are done */
X    }
X    if (line[0] != '#') {
X      sscanf(line, "%s%d", name, &level);
X      if (debug) {
X	printf("name = <%s>, level = %d\n", name, level);
X      }
X      if ((level > old_skill) && (level <= new_skill)) {
X	if (debug) {
X	  printf("deserves a new tech: old_skill=%d, new_skill=%d\n",
X		 old_skill, new_skill);
X	}
X	if (mailfile) fprintf(mailfile,
X		"You get technology power <%s>, level %d, which gives you:\n",
X		name, level);
X	get_tech_entry(fp, np, mailfile);
X      } else {
X	skip_tech_entry(fp);
X      }
X    }
X  }
X  fclose(fp);
X}
X
X  /* read in a specific tech entry, delimited by begin
X     and end, and add it to the nation's ability.  this routine
X     should only be called if the nation *deserves* the new tech
X     power.
X   */
Xget_tech_entry(fp, np, mailfile)
X     FILE *fp;
X     Snation *np;
X     FILE *mailfile;
X{
X  char line[EXECLEN], *line2;
X  struct argument exec_args[N_EXEC_ARGS];
X
X  do {
X    fgets(line, EXECLEN, fp);
X  } while ((strlen(line) == 0) && (line[0] == '#')); /* skip blank lines */
X  if (strncmp(line, "begin", strlen("begin")) != 0) {
X    printf("syntax error:  did not find a begin\n");
X  } else {
X    if (debug) {
X      printf("got a begin\n");
X    }
X  }
X  for (;;) {
X    fgets(line, EXECLEN, fp);
X    if (line[strlen(line)-1] == '\n') {
X      line[strlen(line)-1] = '\0';
X    }
X    line2 = line;
X    while (*line2 == ' ') {	/* skip spaces at start */
X      ++line2;
X    }				/* now line2 is ready for exec parsing */
X    if (strncmp(line2, "end", strlen("end")) == 0) {
X      if (debug) {
X	printf("got an end\n");
X      }
X      break;
X    }
X      /* if that was not the end, we can parse the exec command */
X    if (debug) {
X      printf("line = <%s>, line2 = <%s>, ABOUT TO PARSE\n", line, line2);
X    }
X    if (mailfile) fprintf(mailfile, "%s\n", line);
X    if (line2[0] != '#') {
X      parse_exec_line(line2, exec_args);
X      run_exec_line(np, exec_args);
X    }
X  }
X}
X
X  /* wait for an "end" in the techno file */
Xskip_tech_entry(fp)
X     FILE *fp;
X{
X  char line[EXECLEN];
X  do {
X    fgets(line, EXECLEN, fp);
X  } while (strncmp(line, "end", strlen("end")) != 0);
X}
X
X  /* this is the routine actually called by the update program */
Xdotechno(np, mailfile)
X     Snation *np;
X     FILE *mailfile;
X{
X  int old_skill, new_skill;
X
X  old_skill = np->tech_skill;
X  new_skill = new_tech_skill(np);
X
X  if (debug) {
X    printf("nation %s has old_skill = %d, new_skill = %d\n",
X	   np->name, old_skill, new_skill);
X  }
X  if (mailfile) fprintf(mailfile,
X	"Your skill in technology has increased from %d to %d\n",
X	old_skill, new_skill);
X  get_new_techno(np, old_skill, new_skill, mailfile);
X  np->tech_skill = new_skill;	/* save the change */
X
X/*  np->tech_skill = 0; */
X}
END_OF_FILE
if test 4888 -ne `wc -c <'techno.c'`; then
    echo shar: \"'techno.c'\" unpacked with wrong size!
fi
# end of 'techno.c'
fi
if test -f 'techno_levels' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'techno_levels'\"
else
echo shar: Extracting \"'techno_levels'\" \(3751 characters\)
sed "s/^X//" >'techno_levels' <<'END_OF_FILE'
X# this file describes all possible technologies, and the
X# technology level at which a nation gets them.
X#
X# the format is:
X# name level
X# begin
X#   series of exec lines
X# end
X#
Xbasic 0
Xbegin
X  NEW_ARMY_TYPE:Cavemen
X  NEW_ARMY_TYPE:Caravan
X  NEW_ARMY_TYPE:Mage
Xend
Xstone_tools 1
Xbegin
X  NEW_ARMY_TYPE:Spearmen
Xend
Xfire 10
Xbegin
X  CMINE:5
X  CMORTALITY:-1
X  CFARM:5
Xend
Xtorches 15
Xbegin
X  CMINE:5
X  CCOMBAT:2
Xend
Xnumbers 20
Xbegin
X  CINTEL:5
Xend
Xceramics 30
Xbegin
X  CFARM:15
Xend
Xboomerang 40
Xbegin
X  CCOMBAT:2
Xend
Xclothes 50
Xbegin
X  CMORTALITY:-1
X  CCOMBAT:2
Xend
Xtraining 70
Xbegin
X  NEW_ARMY_TYPE:Infantry
Xend
Xarchery 90
Xbegin
X  CCOMBAT:5
X  CFARM:10
X  NEW_ARMY_TYPE:Archers
Xend
Xbricks 120
Xbegin
X#  CCONSTRUCT:30
X  CMORTALITY:-1
Xend
Xcanoes 150
Xbegin
X  CFARM:10
X  NEW_ARMY_TYPE:Canoes
Xend
Xsnorkels 160
Xbegin
X  NEW_ARMY_TYPE:Swimmers
X  NEW_ARMY_TYPE:Walkers
Xend
Xcopper 190
Xbegin
X  CCOMBAT:8
Xend
Xbronze 220
Xbegin
X  CCOMBAT:1
X  NEW_ARMY_TYPE:Phalanx
Xend
Xharpoons 260
Xbegin
X  NEW_ARMY_TYPE:Sailors
X  CFARM:3
Xend
Xmap 300
Xbegin
X  CSPEED:10
X  CMAPPING:10
Xend
Xrope 340
Xbegin
X#  CCONSTRUCT:10
Xend
Xdomesticated_dogs 340
Xbegin
X  CFARM:3
Xend
Xcolumns 380
Xbegin
X#  CCONSTRUCT:5
Xend
Xstaple_crops 420
Xbegin
X  CFARM:15
Xend
Xtrade_units 460
Xbegin
X#  NEW_DESIG:trade post
X#  CECO_SPEED:5
Xend
Xplumbing 500
Xbegin
X  CMORTALITY:-1
Xend
Xplough 550
Xbegin
X  CFARM:20
Xend
Xcoins 600
Xbegin
X#  CECO_SPEED:10
Xend
Xcompass 650
Xbegin
X  CMAPPING:10
Xend
Xwheels 700
Xbegin
X  CSPEED:30
X  NEW_ARMY_TYPE:Chariots
Xend
Xcanals 750
Xbegin
X  NEW_CONSTRUCT:canal
Xend
Xiron 800
Xbegin
X  CCOMBAT:3
X#  CCONSTRUCT:5
X  CMINE:5
X  NEW_ARMY_TYPE:Legion
Xend
Xhorses 850
Xbegin
X  CSPEED:20
X  CFARM:5
X  NEW_ARMY_TYPE:Cavalry
X  NEW_ARMY_TYPE:Elite
Xend
Xsails 900
Xbegin
X  NEW_ARMY_TYPE:Sailboats
Xend
Xbridges 950
Xbegin
X  NEW_CONSTRUCT:bridges
Xend
Xconcrete 1000
Xbegin
X  NEW_CONSTRUCT:roads
Xend
Xboarding_hooks 1050
Xbegin
X  NEW_ARMY_TYPE:Marines
Xend
Xparchment 1100
Xbegin
X  CINTEL:5
X  CMAG_APT:5
X  CMAPPING:10
Xend
Xwriting 1150
Xbegin
X  CINTEL:5
X  CMAG_APT:5
Xend
Xstonehenge 1200
Xbegin
X  CMAG_APT:10
X#  NEW_DESIG:temple
Xend
Xsurgery 1250
Xbegin
X  CMORTALITY:-1
Xend
Xstandard_units 1300
Xbegin
X#  CECO_SPEED:5
Xend
Xwagons 1350
Xbegin
X  NEW_ARMY_TYPE:Wagons
Xend
Xtunneling 1400
Xbegin
X  CMINE:10
Xend
Xcontraceptives 1475
Xbegin
X  CREPRO:-1
Xend
Xsewage 1550
Xbegin
X  CMORTALITY:-1
Xend
Xbellows 1625
Xbegin
X#  NEW_DESIG:refinery
Xend
Xhealth_diet 1700
Xbegin
X  CMORTALITY:-1
Xend
Xbeer 1775
Xbegin
X  CCOMBAT:1
Xend
Xwar_carts 1850
Xbegin
X  NEW_ARMY_TYPE:War_carts
Xend
Xlarge_ships 1925
Xbegin
X  NEW_ARMY_TYPE:Galleys
Xend
Xsteel 2000
Xbegin
X  CMINE:10
X  CCOMBAT:5
Xend
Xphilosopher 2100
Xbegin
X  CINTEL:15
X  CSTRENGTH:-10
Xend
Xbrainwash 2200
Xbegin
X  NEW_ARMY_TYPE:Berzerkers
X  CINTEL:-5
Xend
Xtelegraph 2300
Xbegin
X  CSPEED:10
Xend
Xpulley 2400
Xbegin
X#  CCONSTRUCT:10
X  CSTRENGTH:10
Xend
Xmercenaries 2500
Xbegin
X  NEW_ARMY_TYPE:Merc
Xend
Xcatapults 2600
Xbegin
X  NEW_ARMY_TYPE:Catapults
Xend
Xquadriremes 2700
Xbegin
X  NEW_ARMY_TYPE:Quadriremes
X  NEW_ARMY_TYPE:Scuba_divers
Xend
Xhospitals 2800
Xbegin
X  CREPRO:1
Xend
Xfortification 2900
Xbegin
X  NEW_CONSTRUCT:fortification
Xend
Xaqueducts 3000
Xbegin
X  CMORTALITY:-1
Xend
Xlighthouse 3200
Xbegin
X#  NEW_DESIG:lighthouse
Xend
Xlever 3400
Xbegin
X  CSTRENGTH:10
Xend
Xwater_wheel 3600
Xbegin
X  CFARM:8
Xend
Xwater_mill 3800
Xbegin
X  CFARM:8
Xend
Xharbour 4000
Xbegin
X#  NEW_DESIG:harbour
Xend
Xwheelbarrow 4200
Xbegin
X  CFARM:10
Xend
Xkamikaze 4400
Xbegin
X  NEW_ARMY_TYPE:Kamikaze
Xend
Xgears 4600
Xbegin
X  CSPEED:10
Xend
Xabacus 4800
Xbegin
X  CINTEL:5
Xend
Xdeception 5000
Xbegin
X  CCOMBAT:2
X  NEW_ARMY_TYPE:Ninja
Xend
Xbooks 5300
Xbegin
X  CINTEL:5
X  CMAG_APT:5
Xend
Xice_houses 5600
Xbegin
X  CFARM:8
Xend
Xcrossbow 5900
Xbegin
X  CCOMBAT:5
X  NEW_ARMY_TYPE:Crossbowmen
Xend
Xsupport_beams 6200
Xbegin
X#  CCONSTRUCT:10
X  CMINE:20
Xend
Xcanned_food 6500
Xbegin
X  CFARM:15
X  CSPEED:10
Xend
END_OF_FILE
if test 3751 -ne `wc -c <'techno_levels'`; then
    echo shar: \"'techno_levels'\" unpacked with wrong size!
fi
# end of 'techno_levels'
fi
if test -f 'trade.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'trade.c'\"
else
echo shar: Extracting \"'trade.c'\" \(3356 characters\)
sed "s/^X//" >'trade.c' <<'END_OF_FILE'
X/* trade.c -- code to handle the trade board during an update and in the game
X */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include <stdio.h>
X
X#define T_GOLD 1
X#define T_METAL 2
X#define T_JEWELS 3
X#define T_FOOD 4
X
Xextern struct item_map tradeitems[];
Xextern int debug;
XFILE *tradef, *bidf;
X
Xstruct bid { int nation, amount; };
X
X/* Called during update to resolve trades. Bids array is first read
X   in. array index is transaction number. bids are read from the bids
X   file and placed in the array. old bids are replaced by higher new
X   bids. then the trades file is read in, and each is checked against the
X   bids array.*/
X/* Variables: t=transaction number, n=nation selling, a=amount selling,
X   i=item selling, i2=item wanted, a2=min amount wanted, p=privacy info */
Xdotrades(wp)
X     Sworld *wp;
X{
X  struct bid bids[MAXTRADES];
X  int t, n, a, i, i2, a2, p;
X  
X  tradef = fopen("trades", "r");
X  if (!tradef) {
X    printf ("Nothing traded this turn\n");
X    return(0);
X  }
X  bidf = fopen("bids", "r");
X  if (!bidf) {
X    printf ("Nothing bought this turn\n");
X    if (tradef) fclose(tradef);
X    return(0);
X  }
X  /* I am going to read in the bids file, picking best bids as we go
X     along... i.e. if a bid is read in that is lower than an existing
X     bid, it is ignored. */
X  while (!feof(bidf)) {
X    fscanf(bidf, "%d %d %d\n", &t, &n, &a);
X    if (bids[t].amount < a) {
X      bids[t].nation = n;
X      bids[t].amount = a;
X    }
X  }
X  while (!feof(tradef)) {
X    fscanf(tradef, "%d %d %d %d %d %d %d\n", &t, &n, &i, &a, &i2, &a2, &p);
X    if (bids[t].amount >= a2) {
X      printf ("nation %d sells %d %s to nation %d for %d %s\n", n, a,
X	      tradeitems[i].name, bids[t].nation, bids[t].amount, tradeitems[i2].name);
X      swapgoods (&wp->nations[n], &wp->nations[bids[t].nation], a, i); /* subtract goods from one nation */
X      swapgoods (&wp->nations[bids[t].nation], &wp->nations[n], a2, i2); /* add them to the other */
X    }
X  }
X}
X
X
X
X/* This actually adds or subtracts an item from a nation */
Xswapgoods (fromnat, tonat, amt, item)
X     Snation *fromnat, *tonat;
X     int amt, item;
X{
X  switch (tradeitems[item].mark) {
X  case 'g':
X    fromnat->money -= amt;
X    tonat->money += amt;
X    break;
X  case 'm':
X    fromnat->metal -= amt;
X    tonat->metal += amt;
X    break;
X  case 'j':
X    fromnat->jewels -= amt;
X    tonat->jewels += amt;
X    break;
X  case 'f':
X    fromnat->food -= amt;
X    tonat->food += amt;
X    break;
X  default:
X    printf ("TRADE ERROR:  Unknown commodity!\n");
X    break;
X  }
X}  
X
END_OF_FILE
if test 3356 -ne `wc -c <'trade.c'`; then
    echo shar: \"'trade.c'\" unpacked with wrong size!
fi
# end of 'trade.c'
fi
if test -f 'trademenu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'trademenu.c'\"
else
echo shar: Extracting \"'trademenu.c'\" \(6066 characters\)
sed "s/^X//" >'trademenu.c' <<'END_OF_FILE'
X/* trademenu.c - displays trade board and allows buying and selling of items */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X#ifdef TRADEMENU
X
X#include "dominion.h"
X#include "misc.h"
X#include <stdio.h>
X#include <ctype.h>
X
Xextern Sworld world;
Xextern Suser user;
Xextern struct item_map tradeitems[];
XFILE *trades, *bids;
X
Xstruct trade { int natn, item1, amt1, item2, amt2, priv; };
X
Xtrade_menu(nation)
X{
X  WINDOW *tw;
X  char c;
X  int done=0, done2=0, start, curn, i, num_trades;
X  int num, amt;
X  struct trade tlist[MAXTRADES], tr;
X  int blist[MAXTRADES];
X  
X  while (!done) {
X    num_trades = read_trades(tlist, blist);
X    statline("hit space when done", "trade board");
X    tw = newwin(LINES-2, COLS, 0, 0);
X    wmove(tw, 0, COLS/2-10);
X    wstandout(tw);
X    wprintw(tw, "Trade Board for nation %s", world.nations[user.id].name);
X    wstandend(tw);
X    
X    mvwprintw(tw, 2, 1, "T# | NATION           ITEM FOR SALE     |     MINIMUM BID       | YOUR BID");
X    mvwprintw(tw, 3, 1, "== | ============  ==================== | ===================== | ========");
X    
X    start = 0;
X    for (i = 0; i < (num_trades-start); i++) {
X      tr = tlist[i+start];
X      mvwprintw(tw, i+4, 0, "%3d | %-12s %8d %-12s | %8d %-12s | %8d",
X		i+start, world.nations[tr.natn].name, tr.amt1,
X		tradeitems[tr.item1].name, tr.amt2,
X		tradeitems[tr.item2].name, blist[i+start]);
X    }
X    mvwprintw(tw, 19, 2, "Do you wish to (s)ell an item, or (b)uy an item? ");
X    wrefresh(tw);
X    
X    done2 = 0;
X    while (!done2) {
X      c = getch();
X      c = isupper(c) ? tolower(c) : c;
X      switch(c) {
X      case ' ':
X	done = done2 = 1;
X	break;
X      case 's':
X	tr.natn = user.id;
X	tr.item1 = tr.item2 = tr.amt1 = tr.amt2 = tr.priv = 0;
X	sell_what(tw, &tr);    /* find what to sell and amount */
X	append_sale(tw, tr, num_trades);  /* write new trade to trade file */
X	done2 = 1;
X	break;
X      case 'b':
X	buy_what(tw, &num, &amt);	/* get users bid */
X	append_bid(tw, num, amt); /* write new bid to bids file */
X	done2 = 1;
X	break;
X      default:
X	bad_key();
X	break;
X      }
X    }
X  }
X  delwin(tw);
X  touch_all_wins();
X  refresh();
X}
X
X
X/* reads the list of current trades from the trades file into an array. */
Xint read_trades(list, list2)
X     struct trade list[];
X     int list2[];
X{
X  int n, i, t, a, nt;
X
X  trades = fopen(TRADES_FILE, "r");
X  i = 0;
X  if (trades) {
X    while (!feof(trades)) {
X      fscanf(trades, "%d", &n);
X      fscanf(trades, "%d %d %d %d %d %d\n", &list[n].natn, &list[n].item1,
X	     &list[n].amt1, &list[n].item2, &list[n].amt2, &list[n].priv);
X      i++;
X    }
X    fclose(trades);
X  }
X  nt = i;
X
X  for (i = 0; i < MAXTRADES; i++)
X    list2[i] = 0;
X  bids = fopen(BIDS_FILE, "r");
X  if (bids) {
X    while (!feof(bids)) {
X      fscanf(bids, "%d %d %d\n", &t, &n, &a);
X      if (n == user.id)
X	list2[t] = a;
X    }
X    fclose(bids);  
X  }
X  return(nt);
X}
X
X
Xsell_what(tw, desc)
X     WINDOW *tw;
X     struct trade *desc;
X{
X  char str[80], ic1, ic2;
X  int i, it1, am1, it2, am2, ret;
X
X  i = 0;
X  str[0] = '\0';
X
X  while (strncmp(tradeitems[i].name, "END", 3)) {
X    sprintf(&str[strlen(str)], "(%c) %s, ", tradeitems[i].mark, tradeitems[i].name);
X    i++;
X  }
X  mvwprintw(tw, 19, 2, "%s", str);
X  echo();
X  mvwprintw(tw, 21, 2, "Which item type do you wish to sell? ");
X  wrefresh(tw);
X  ic1 = getch();
X  it1 = whichitem(ic1);
X  if (ret > 0) {
X    mvwprintw(tw, 21, 2, "How much %s to sell? ", tradeitems[it1].name);
X    wclrtoeol(tw);
X    nocbreak();
X    wrefresh(tw);
X    ret = wscanw(tw, "%d", &am1);
X    if (ret > 0) {
X      mvwprintw(tw, 21, 2, "Which item do you want in return? ");
X      wclrtoeol(tw);
X      cbreak();
X      wrefresh(tw);
X      ic2 = getch();
X      it2 = whichitem(ic2);
X      if (ret > 0) {
X	mvwprintw(tw, 21, 2, "Minimum %s you will accept? ", tradeitems[it2].name);
X	wclrtoeol(tw);
X	nocbreak();
X	ret = wscanw(tw, "%d", &am2);
X	if (ret > 0) {
X	  desc->item1 = it1;
X	  desc->amt1 = am1;
X	  desc->item2 = it2;
X	  desc->amt2 = am2;
X	  desc->priv = 0;
X	}
X      }
X    }
X  }
X  noecho();
X  cbreak();
X}
X
X
Xint whichitem(ch)
X     char ch;
X{
X  int i=0;
X
X  while (tradeitems[i].mark != ch) i++;
X  return i;
X}
X
X
Xbuy_what(tw, t, a)
X     WINDOW *tw;
X     int *t, *a;
X{
X  int num, am, ret;
X
X  wmove(tw, 19, 2);
X  wclrtoeol(tw);
X  mvwprintw(tw, 19, 2, "Which trade item do you wish to bid on? ");
X  echo();
X  nocbreak();
X  wrefresh(tw);
X  ret = wscanw(tw, "%d", &num);
X  if (ret > 0) {
X    mvwprintw(tw, 19, 2, "How much do you wish to bid? ");
X    wclrtoeol(tw);
X    ret = wscanw(tw, "%d", &am);
X    if (ret > 0) {
X      *t = num;
X      *a = am;
X    }
X  }
X  noecho();
X  cbreak();
X}
X
X
Xappend_sale(tw, desc, number)
X     WINDOW *tw;
X     struct trade desc;
X     int number;
X{
X  if ((trades = fopen (TRADES_FILE, "a")) == NULL)
X  {
X    fprintf(stderr,"Error: Cannot write to file %s\n",TRADES_FILE);
X    clean_exit();
X    exit(1);
X  }
X  fprintf(trades, "%d %d %d %d %d %d %d\n", number, desc.natn,
X	  desc.item1, desc.amt1, desc.item2, desc.amt2, desc.priv);
X  fclose(trades);
X}
X
X
Xappend_bid(tw, num, amt)
X     int num, amt;
X{
X  if ( (bids = fopen(BIDS_FILE, "a") ) == NULL)
X  {
X    fprintf(stderr,"Error: Cannot write to file %s\n",BIDS_FILE);
X    clean_exit();
X    exit(1);
X  }
X  fprintf(bids, "%d %d %d\n", num, user.id, amt);
X  fclose(bids);
X}
X#endif /* TRADEMENU */
END_OF_FILE
if test 6066 -ne `wc -c <'trademenu.c'`; then
    echo shar: \"'trademenu.c'\" unpacked with wrong size!
fi
# end of 'trademenu.c'
fi
echo shar: End of archive 27 \(of 28\).
cp /dev/null ark27isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Now execute ./do_cat.sh to build doc files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
