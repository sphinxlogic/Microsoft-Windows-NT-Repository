Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i037:  dominion - a multi-player world simulation game, Part01/28
Message-ID: <2440@masterCNA.TEK.COM>
Date: 11 Feb 92 18:21:43 GMT
Sender: news@masterCNA.TEK.COM
Lines: 2029
Approved: billr@saab.CNA.TEK.COM

Submitted-by: rosalia@dirac.physics.sunysb.edu (Mark Galassi)
Posting-number: Volume 13, Issue 37
Archive-name: dominion/Part01
Environment: Unix, curses


[From the author(s)...]
[[Dominion is a multi-player world simulation game.  Each user is the
leader of a nation, and makes decisions for that nation.  The
decisions are political, military, diplomatic and economic, and all
these are extremely important for the well-being of a nation.  The
game is not real-time: a user plays her/his turn and then an update is
run periodically to incorporate changes of all players.

Dominion has features from both fantasy role-playing games, educational
games, and war games: a user needs to develop a character as leader of
a nation, keep a healty economy, and can then develop a strong
military force using magic or technology.

Dominion has been tested on several versions of UNIX: System V.2
(Ridge and UNIX PC), HPUX (HP 3000 and 9000 series), System V.3 (MIPS
and SGI), System V.4 (386 boxes), SCO Xenix system V (386 boxes), Sun
OS 4.1 (sun sparcstation), ULTRIX (vax, DEC 5000), mach (NeXT), AIX
(IBM RS6000).  A previous version was ported to the amiga, though the
port would have to be redone from scratch now.]]


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 28)."
# Contents:  README MANIFEST army.c npcs
# Wrapped by billr@saab on Tue Feb 11 10:14:48 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(11007 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XWHAT IS THIS?
X-------------
X
XThis is release of Dominion (version 1.06), a world simulation and
Xconquest game.  Dominion runs on every version of UNIX on which we
Xhave tested it.
X
XThe dominion source code is available by anonymous ftp on
Xmax.physics.sunysb.edu [129.49.21.100], in the directory
Xpub/dominion-version.  For example, to get version 1.06 you would
Xtype:
X
X	ftp -i max.physics.sunysb.edu		(or ftp -i 129.49.21.100)
X	<log in as "anonymous", with any password you want>
X	cd pub/dominion-1.06
X	ls
X	binary
X	mget DOM*
X
XThe files you will retrieve are "shell archives", so after
Xuncompressing, you un-bundle them with the Bourne shell.
X
XSend bug reports to:
X	rosalia@max.physics.sunysb.edu
X
XSend flames to /dev/tty :-).
X
XDon't forget that this is copylefted free software.  Read the file COPYING.
X
X
XHOW DO YOU COMPILE DOMINION?
X----------------------------
X
XOnce you have unpacked all the files, you might be lucky and just be
Xable to type "make all" and "make new-world".  Even better would be
X"gmake" and "gmake new-world" if you have GNU Make.  If not:
X
XYou should browse the Makefile, and modify the top part of it.  There are
Xsome customization options:
X
X0.  if you don't have GNU make, remove the 2 lines that refer to RCS.
X    otherwise, you can always type "make" with some target, such
X    as "make all" or "make install" or "make new-world".
X
X1.  if you have Berkeley UNIX, or sunOS, you should put -DBSD in the
X    CFLAGS, rather than -DSYSV.  We have noticed that on mach (NeXT)
X    and ULTRIX (VAX, DEC 5000) we need -DBSD, whereas AIX and System V
X    will compile with -DSYSV.
X
X2.  you should also set the LIBDIR (essential), THIS_GAME_LIBDIR
X    (typically equal to LIBDIR), and BINDIR (not so essential).  You
X    should also set the DEBUGFLAGS to "-O" if you want your compiler to
X    optimize.  when dominion is shipped, the "-g" flag is specified.
X
X3.  get the name of a basic mail program on your system, and set the
X    Makefile variable DEFAULT_MAIL to be that.  This can be overruled
X    with the DOMINION_MAIL environment variable, or in the dominion
X    [O]ptions menu.
X
X4.  do the same as step 3, with a basic visual editor:  the Makefile
X    variable DEFAULT_EDITOR should be the editor most people
X    use.  This can be overruled with the VISUAL environment variable,
X    or in the dominion [O]ptions menu.
X
X5.  There are some other Makefile variables that you might want to
X    change, though they are not essential.  Some of the things we
X    have in the Makefile are for software development.
X
X    If you do not have LaTeXinfo, or you just want to use the manual
X    as we shipt it, you should comment out the lines that generate
X    dominion-man.info.  If you have LaTeXinfo, then you should set
X    EMACS to be the name of GNU emacs on your system, and
X    LTI_START to the name of the file with your LaTeXinfo lisp
X    code.
X
X    There is a newsgroup in which general things are posted.  This is
X    called "News" by default, but it can be changed with the NEWS_GROUP
X    variable in Makefile.
X
X6.  Run "make all", and it will make 5 programs:
X      "dom_make", "dom_add", "dominion", "dom_update" and "dom_print".
X
X7.  Make sure that the file "dominion.info" is there.  We provide
X    a copy of it with the distribution, in case you don't have the
X    emacs lisp code needed to generate this file from "dominion.tex".
X    This emacs lisp code comes with the LaTeXinfo package.
X
X8.  Run "make new-world" to make a new world, then run "dom_add" to add
X    a nation, then run "dominion" to play that nation, and
X    "dom_update" to update the world after you run a turn etc...  It
X    is convenient to run "make new-world" instead of manually typing
X    "dom_make", since "make new-world" will copy all the relevant files
X    to the LIBDIR.
X
X9.  If you want to play with NPCs (nations run by the computer),
X    type "dom_add -f npcs", where "npcs" is the name of the file
X    with all information on these Non Player Countries.  From version
X    1.05 on, the computer playes a pretty good game for the NPCs:
X    they will definitely be a challenge!!  If you want to put in
X    your own file for NPCs, just copy it to $LIBDIR/misc.
X
X    The "npcs" file we distribute has 26 NPCs in it.  If you are
X    running a small world, you might want to comment some of them
X    out: do so by editing the file $LIBDIR/misc/npcs putting a '#'
X    at the beginning of the line for each NPC you don't want.
X
X10. If you don't like some of the hard-coded parameters, you can
X    change them by editing the "dominion.h" and "costs.h" files.
X    Other parameters are defined in "techno_levels", "army_types",
X    "spirit_types", "npcs", and any file that starts with "mag_".
X    If you change "dominion.h" or "costs.h", re-compile.  If you
X    have modified the other files, just run "make lib-files".
X
X11. To make a hardcopy of the manual dominion.tex, you must run LaTeX
X    with the LaTeXinfo document style.  If you do not have this, you
X    can get a copy of the two files "latexinfo.sty" and "tabular.sty"
X    by anonymous ftp from
X        max.physics.sunysb.edu [129.49.21.100]
X    in the directory pub/dominion.  If you don't want to bother running
X    LaTeX, you can find (in the same ftp directory) the files
X    dominion.dvi.Z and dominion.PS.Z, and if you need it we can provide
X    files ready for other laser printers.
X
X12. We also supply a Game Master manual in the file "gm.tex".  This is
X    formatted with ordinary LaTeX, and you can just use latex to format
X    it and print it out.  This manual is just an initial sketch.
X
XWHAT IS IT ALL ABOUT?
X---------------------
X
XThis is a world simulation game developed by students at SUNY at Stony
XBrook.  The intention is to write a game which offers the role playing
Xpotential and complexity of relations found in conquer (written by Ed
XBarlow, then picked up by Adam Bryant).  The plan is to extend the
Xgame by offering general descriptions of many features (such as races,
Xmagic spells, armies, spirits and technology powers).  For example,
Xthe races of the world are not limited to 4 hard-coded races, but are
Xdescribed in a file which can be modified at any point in the game by
Xthe Game Master.  The same goes for army and spirit types.
X
XDominion is *not* another version of conquer; things work quite
Xdifferently, and we have *never* looked at the conquer source.  Still,
Xwe acknowledge this most creative game which gave us our inspiration.
XIn September 1990, the author of conquer version 5 has heard of many
Xof the features of dominion, and has included them in conquer version
X5.  He has acknowledged that these ideas come from Dominion.
X
XThe Game Master is given a nation, but this nation is sort of
X"fragile", since it has no sectors, and such stuff.  We will make it
Xmore solid, but meanwhile it is to be used mostly for its [E] command,
Xwhich allows the Game Master (who logs into the game as "Gamemaster")
Xto change the properties of a sector or of a nation.
X
XDominion development started in the spring of 1990, when we were
Xrunning a game of conquer at Stony Brook.  After the data file kept
Xcrashing, and a whole lot of inconsistencies were discovered, and we
Xfound that the source was too complex to be fixed, we decided to write
Xour own replacement.  Ed Barlow did a great job with conquer, and it
Xis a great game, but it was his first C program, and people who added
Xto it kept the endless case statements, and the special cases, and
Xworked on new features rather than re-writing.  The original name of
XDominion was Stony Brook World (sbw), but it has been named Dominion
Xsince version 1.02.
X
XOne goal of dominion is that the ruler of a nation should always have
Xmany choices available on how to invest resources, each one presenting
Xstrong but distinct advantages.  Conquer contains both a good and a
Xbad example of this: you can invest metal in cities, ships or armies.
XEither way you get advantages, and you have to choose.  On the other
Xhand, jewels are really not used for much else than getting magic
Xpowers.  You can also use them to support monsters, but that is a
Xdifferent order of magnitude, and few players get the monsters.  In
Xdominion, there should be several decisions you can make to invest all
Xyour resources.
X
XKevin Hart has been working on the NPC code which allows the computer
Xto play various nations.  Starting with version 1.05, the
Xcomputer-played NPCs have begun posing a real challenge in the game.
X
X
XABOUT THE DEVELOPERS
X--------------------
X
XPeople who have written code or documentation so far are:
X
XMark Galassi (rosalia@dirac.physics.sunysb.edu)
XMike Fischer (greendog@max.physics.sunysb.edu)
XDoug Novellano (doug@max.physics.sunysb.edu)
XKeith Messing (keith@max.physics.sunysb.edu)
XAlan Saporta (gandalf@max.physics.sunysb.edu)
XJoanne Rosenshein (raven@max.physics.sunysb.edu)
XStephen Bae (sbae@max.physics.sunysb.edu)
XChris Coligado (noel@max.physics.sunysb.edu)
XStephen Underwood (su11+@andrew.cmu.edu)
XKevin Hart (hart@cs.andrews.edu)
XC. Titus Brown (brown@dirac.physics.sunysb.edu)
XCharles Ofria (charles@max.physics.sunysb.edu)
X
XWe keep in touch electronically and meeting in the Stony Brook
XInstitute for Theoretical Physics.  We also meet once a week for 1
Xhour, and some times have parties on Saturdays.  The tuesday meetings
Xare strictly for discussing code, the saturday parties are for
Xfantasizing about what we would like to do.
X
XThere is also a creative team of D&D and war-game players who are
Xgiving suggestions on how magic, technology and battle should work.
XWe also hope to use some simple econometric models to calculate
Xparameters of the economy.
X
X
XABOUT THE CODE
X--------------
X
XThere are 5 programs: dom_make, dom_add, dominion dom_update and
Xdom_print.  These all share some files, such as misc.c, nation.c and
Xfile.c.
X
XIt would be nice to get, some day, some real graphical interfaces for
Xwidely available personal computers (Amiga, Atari ST, Macintosh, IBM
XPC) and windowing systems such as X and NeWS.  But for now we only
Xhave the curses interface, and this is supported as the common
Xdenominator.  There exist, of course, curses implementations for all
Xsorts of personal computers.
X
X
XABOUT SUPPORT AND MAINTAINANCE
X------------------------------
X
XWe will definitely try to fix any bugs that are reported.  When
Xreporting a bug you should mention on which version of UNIX you found
Xit, and be precise.  A fix would be nice.
X
XAs for new ideas, we intend to move slowly in that area because
Xaccepting innovations indiscriminately can be harmful in the long run.
XAny idea which does not make the game more complicated is welcome, and
Xwill be considered.  If you make your own modifications to the game,
Xremember to do so in accordance with the GNU General Public Licence
X(see the file COPYING).
X
X
XWHAT HAS BEEN DONE SO FAR?
X--------------------------
X
XWe feel that the game is complete as it is, though lots of things
Xcould be improved.  There is a file called TASKS with a list of
Xjobs for the enterprising hacker who wants to help with Dominion.
END_OF_FILE
if test 11007 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(3059 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X COPYING                   25	
X ChangeLog                 19	
X MANIFEST                   1	This shipping list
X Makefile                  15	
X README                     1	
X TASKS                     27	
X THE_STORY                 23	
X addnation.c               20	
X addnews.sh                26	
X army.c                     1	
X army.h                    27	
X army_types                28	
X armylib.c                 17	
X battle.c                  19	
X budget.c                  23	
X c_news.c                  21	
X cinfo.c                   25	
X commands.c                23	
X construct.c               14	
X costs.h                    4	
X cur_stuff.c               22	
X cur_stuff.h               13	
X diplolib.c                25	
X diplomacy.c               26	
X do_cat.sh                  3	
X dom_info.aa                2	
X dom_info.ab                3	
X dom_ps.aa                 12	
X dom_ps.ab                 11	
X dom_ps.ac                 10	
X dom_ps.ad                  8	
X dom_ps.ae                  5	
X dom_ps.af                  4	
X dom_ps.ag                  6	
X dom_ps.ah                  9	
X dom_ps.ai                  7	
X dom_ps.aj                 13	
X dom_tex.aa                16	
X dom_tex.ab                17	
X dominion.6                28	
X dominion.c                27	
X dominion.h                24	
X economy.c                 21	
X ext.c                     27	
X file.c                    16	
X gm.tex                    27	
X help.c                    28	
X info_intro                12	
X init.c                    28	
X int_mail.c                24	
X mag_Aule                   9	
X mag_Avian                 28	
X mag_Chess                 27	
X mag_Demonology            10	
X mag_Diana                 20	
X mag_Inferno               28	
X mag_Insects               12	
X mag_Master                18	
X mag_Monsters              22	
X mag_Necromancy             7	
X mag_Neptune               11	
X mag_Time                  28	
X mag_Unity                 22	
X mag_Yavanna                8	
X mag_orders                 8	
X maglib.c                  25	
X mail.c                    26	
X makeworld.c               15	
X menus.c                   22	
X misc.c                    19	
X misc.h                    26	
X movement.c                20	
X nation.c                  18	
X news.c                    27	
X news.h                     5	
X npc.c                     21	
X npclib.c                  22	
X npcs                       1	
X printmap.c                24	
X races                     24	
X refcard                    6	
X reports.c                 23	
X root.c                    25	
X spelllib.c                24	
X spells.c                  20	
X spirit_types              27	
X spy.c                     26	
X techno.c                  27	
X techno_levels             27	
X trade.c                   27	
X trademenu.c               27	
X transport.c               18	
X update.c                  14	
X user.c                    26	
X world.c                   26	
END_OF_FILE
if test 3059 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'army.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'army.c'\"
else
echo shar: Extracting \"'army.c'\" \(40121 characters\)
sed "s/^X//" >'army.c' <<'END_OF_FILE'
X  /* army.c -- visual army stuff;  see also armylib.c */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X#include "cur_stuff.h"
X
X#include <stdio.h>
X#ifdef AMIGA
X# include <stdlib.h>
X#endif
X
Xextern Sworld world;
Xextern Suser user;
Xextern char help_tag[];
X
Xint legal_move();
XSarmy *get_army();
Xextern struct army_type *army_types;
Xextern struct army_flags army_flags [];
X
X  /* this shows the armies inside the current sector.
X     the info is put in the the main window.
X   */
Xshow_armies(sp)
X     Ssector *sp;
X{
X  Sarmy *ap;
X  Snation *np;
X  struct armyid *alist;
X    /* we need to know how many are hidden, for display purposes */
X  int i, n_hidden = 0, n_armies;
X  char s[NAMELEN];
X  char apparent_type[NAMELEN];	/* if an army is disguised */
X  int visibility = user.visible_sectors[sp->loc.x][sp->loc.y];
X  int n_shown, first_shown = 0, current_index; /* to handle scrolling */
X  Sarmy **army_array;
X
X  if (user.current_army == -1) {
X    user.current_army = first_sect_army(sp);
X  }
X
X  if (!(visibility & SEE_ARMIES)) {
X    user.last_n_armies = 0;
X    return;
X  }
X
X    /* we use this array to store all pointers, because it is useful
X       to access the armies as an array for the scrolling display
X     */
X  alist = sp->alist;
X  current_index = 0;
X  n_armies = sect_n_armies(sp);
X  army_array = (Sarmy **) malloc(n_armies * sizeof(Sarmy *));
X  for (i = 0; i < n_armies; ++i) {
X    np = &world.nations[alist->owner];
X    ap = get_army(np, alist->id);
X    army_array[i] = ap;
X      /* we want to know which the current army is,
X	 so that we can highlight it.
X       */
X    if (ap->id == user.current_army && ap->owner == user.id) {
X      current_index = i;
X    }
X    alist = alist->next;
X  }
X
X    /* cycle through armies and show them */
X  alist = sp->alist;
X  n_shown = min(7, n_armies);
X  if ((n_armies - current_index) <= n_shown/2) { /* are we near end of list */
X    first_shown = n_armies - n_shown;
X  } else {
X    first_shown = max(current_index-n_shown/2, 0);
X  }
X  for (i = 0; i < n_shown; ++i) {
X    ap = army_array[i+first_shown];
X    if ((ap->owner == user.id) && (ap->id == user.current_army)) {
X      standout();
X    }
X    if (ap->owner == user.id || user.id == 0) {	/* your armies */
X      if (ap->id == user.current_army) {
X	mvprintw(2*(i-n_hidden), ARMYW_X,
X		 ">%.10s:%d %.8s", world.nations[ap->owner].name,
X		 ap->n_soldiers, ap->type);
X      } else {
X	mvprintw(2*(i-n_hidden), ARMYW_X,
X		 " %.10s:%d %.8s", world.nations[ap->owner].name,
X		 ap->n_soldiers, ap->type);
X      }
X      clrtoeol();
X    } else if (!is_hidden(ap)) { /* other people's armies */
X      get_apparent_type(ap, apparent_type);
X      mvprintw(2*(i-n_hidden), ARMYW_X,
X	       " %.10s:%d %.8s", world.nations[ap->owner].name,
X	       ap->n_soldiers, apparent_type);
X    } else {			/* is hidden */
X      ++n_hidden;
X    }
X    clrtoeol();
X      /* we have printed the first army description
X	 line; now print the other one.
X       */
X    if (ap->owner == user.id || user.id == 0) {
X      get_army_status(ap, s);
X      mvprintw(2*(i-n_hidden)+1, ARMYW_X,
X	       " #%d; mv=%d;%s", ap->id, ap->mvpts, s);
X    } else {
X      move(2*(i-n_hidden)+1, ARMYW_X);
X    }
X      /* tricky line;  if it is there it causes this bug
X	 with hidden armies; I try only clearing if the
X	 army is not hidden.  that might solve the problem,
X	 but still cause trouble if the army is hidden and
X	 belongs to me.  I will test it.
X       */
X    if (!(is_hidden(ap) && ap->owner != user.id)) {
X      clrtoeol();		/* do it for non-enemy hidden armies */
X    }
X    if ((ap->owner == user.id) && (ap->id == user.current_army)) {
X      standend();
X    }
X    alist = alist->next;
X  }
X  if (n_shown < user.last_n_armies) {
X    for (i = n_armies-n_hidden; i < user.last_n_armies; i++) {
X      move(2*i, ARMYW_X);
X      clrtoeol();
X      move(2*i+1, ARMYW_X);
X      clrtoeol();
X    }
X  }
X  user.last_n_armies = n_shown;	/* n_armies - n_hidden; */
X  free(army_array);
X}
X
X  /* this is the general army menu, which allows
X     you to choose an army action.
X   */
Xarmy_menu()
X{
X  WINDOW *aw;
X  int x, y;
X  char c;
X  int done = 0;
X  Ssector *sp;			/* current sector */
X  Sarmy *ap;
X
X  x = user.cursor.x;
X  y = user.cursor.y;
X  sp = &world.map[x][y];
X
X  if (!user.xmode) {
X    aw = newwin(8, COLS-2, LINES-10, 1);
X  }
X  while (!done) {
X    if (user.xmode) {
X      statline("(d,D,E,n,p,N,P,m,s,t,l,z,Z,-,+)", "army_menu");
X    } else {
X      statline("Choose the army action you want (space to exit)", "army_menu");
X      mvwaddstr(aw, 1, 1,
X"  Choose Army: [n]ext, [p]revious, [N]/[P] (absolute), [j]ump to #");
X      mvwaddstr(aw, 2, 1,
X" Command Army: [m]ove, change [s]tatus, [t]ransport, [D]isband army");
X      mvwaddstr(aw, 3, 1,
X"    Army Info: [l]ist available army types,[z]oom,[Z] global zoom,[E]xamine");
X      mvwaddstr(aw, 4, 1,
X"Army Creation: [d]raft troops, [-]split army, [+]merge armies");
X      box(aw, '|', '-');
X      wrefresh(aw);
X    }
X    set_cursor();
X    strcpy(help_tag, "Diplomacy and war");
X    switch (c = mygetch()) {
X    case ' ':
X      done = 1;
X      break;
X    case 'j':
X      done = jarmy ();
X      break;
X    case 'm':
X      if (!user.xmode) {
X	werase(aw);
X	touch_all_wins();
X      }
X      critical();		/* make sure people don't exit while moving */
X      move_army(user.current_army, user.xmode ? NULL : aw);
X      noncritical();		/* now they can exit:  move is saved */
X      break;
X    case 't':			/* allow access to the transp. menu */
X      transport();
X      break;
X    case 'p':
X      previous_army();		/* pick the previous army */
X      if (user.display == ARMY_MOVECOST) {
X	draw_map ();
X      }
X      break;
X    case 'n':
X      next_army();		/* pick the next army */
X      if (user.display == ARMY_MOVECOST) {
X	draw_map ();
X      }
X      break;
X    case 'N':			/* pick the next army, no matter where */
X      if (ap=get_army(user.np,next_nation_army(user.np, user.current_army))) {
X	user.current_army = ap->id;
X	user.cursor = ap->pos;
X	just_moved();
X	re_center(ap->pos.x, ap->pos.y);
X	draw_map();
X      } else {
X	user.current_army = -1;
X      }
X      break;
X    case 'P':
X      if (ap=get_army(user.np,prev_nation_army(user.np, user.current_army))) {
X	user.current_army = ap->id;
X	user.cursor = ap->pos;
X	just_moved();
X	re_center(ap->pos.x, ap->pos.y);
X	draw_map();
X      } else {
X	user.current_army = -1;
X      }
X      break;
X    case 's':
X      change_army_status(user.xmode ? NULL : aw, user.current_army);
X      break;
X    case 'd':
X      list_available_armies(&user, user.xmode ? NULL : aw);
X      draft_army(user.np);
X      if (user.current_army == -1) {
X        user.current_army = first_sect_army(sp);
X      }
X      break;
X    case 'D':
X      if ((ap = get_army(user.np, user.current_army)) == NULL) {
X	return 0;
X      }
X      army_disband (sp, ap);
X      break;
X    case 'E':
X      if ((ap = get_army(user.np, user.current_army)) == NULL) {
X	return 0;
X      }
X      army_examine(ap);
X      break;
X    case 'l':
X        /* if we pass NULL, it means we are in xmode */
X      list_available_armies(&user, user.xmode ? NULL : aw);
X      get_space();
X      break;
X    case 'z':
X      zoom_armies(&user, sp);
X      break;
X    case 'Z':
X      zoom_armies(&user, NULL);
X                     /* with a null pointer for sector... */
X      break;
X    case '+':
X      ap = get_army (user.np, user.current_army);
X      if (ap == NULL) {
X	break;
X      }
X      army_merge (ap);
X      break;
X    case '-':
X      ap = get_army (user.np, user.current_army);
X      if (ap == NULL) {
X	break;
X      }
X      army_split (ap);
X      break;
X    default:
X      break;
X    }
X    ap = get_army(user.np,user.current_army);
X    if (ap != NULL) {
X      sp = &world.map[ap->pos.x][ap->pos.y];
X    }
X    if (!user.xmode) {
X      wmove(aw, 3, 1);
X      wclrtobot(aw);
X      touchwin(aw);
X    }
X    statline2("", "");
X    show_armies(sp);
X    refresh();
X  }
X  if (!user.xmode) {
X    delwin(aw);
X    touch_all_wins();
X  }
X}
X
X/* Merge selected army with another army */
X
Xarmy_merge (ap)
X
XSarmy * ap;
X{
X  struct argument args[N_EXEC_ARGS];
X  Sarmy * ap2;
X  Ssector * sp;
X  char stmp [EXECLEN];
X  int army_num;
X
X  sp = &world.map[user.cursor.x][user.cursor.y];
X
X  sprintf (stmp, "Merge army %d into army #? ", ap->id);
X  statline2_prompt (stmp, "army_merge");
X  if (wget_number (stdscr, &army_num) <= 0) {
X    statline2 ("", "");
X    return 0;
X  }
X  ap2 = get_army (user.np, army_num);
X  if (ap2 == NULL) {
X    statline2 ("", "");
X    return 0;
X  }
X  if (is_in_transport(ap) || is_in_transport (ap2)) {
X    statline2_err("Hit space to get back", "Army is in transport");
X    statline2 ("", "");
X    return 0;
X  }
X  if (cargo_not_empty(&ap->cargo) || cargo_not_empty (&ap2->cargo)) {
X    statline2_err("Hit space to get back", "Army has a cargo");
X    statline2 ("", "");
X    return 0;
X  }
X  if (is_spelled(ap) || is_spelled(ap2))
X  {
X    statline2_err("Hit space to get back", "Army is under a Spell");
X    statline2 ("", "");
X    return 0;
X  }     
X  if (ap2->pos.x != sp->loc.x || ap2->pos.y != sp->loc.y ||
X      strcmp(ap->type,ap2->type) != 0 || ap == ap2) {
X    statline2 ("", "");
X    return 0;
X  }
X  sprintf(stmp, "AMERGE:%d:%d\n", ap->id, ap2->id);
X  gen_exec(stmp);
X    /* have the exec routine do the work!! */
X  parse_exec_line(stmp,args);
X  run_exec_line(user.np,args);
X    /* make sure there is a current army selected */
X  user.current_army = ap2->id;
X  return 1;
X}
X
Xarmy_split (ap)
X
XSarmy * ap;
X{
X  struct argument args[N_EXEC_ARGS];
X  Ssector * sp;
X  char stmp [EXECLEN];
X  int num_troops;
X
X  sp = &world.map[user.cursor.x][user.cursor.y];
X
X  sprintf (stmp, "Split how many units from army %d? ", ap->id);
X
X  statline2_prompt (stmp, "army_split");
X  if (wget_number (stdscr, &num_troops) <= 0) {
X    statline2 ("", "");
X    return 0;
X  }
X  if (num_troops < 1 || num_troops > ap->n_soldiers - 1) {
X    statline2 ("", "");
X    return 0;
X  }    
X  if (is_in_transport(ap)) {
X    statline2_err("Hit space to get back", "Army is in transport");
X    statline2 ("", "");
X    return 0;
X  }
X  if (cargo_not_empty(&ap->cargo)) {
X    statline2_err("Hit space to get back", "Army has a cargo");
X    statline2 ("", "");
X    return 0;
X  }
X  if (is_spirit (ap)) {
X    statline2_err ("Hit space to get back", "Cannot split spirits");
X    statline2 ("", "");
X    return 0;
X  }
X  if (is_spelled(ap))
X  {
X    statline2_err("Hit space to get back", "Army is under a Spell");
X    statline2 ("", "");
X    return 0;
X  }     
X  sprintf(stmp, "ASPLIT:%d:%d\n", ap->id, num_troops);
X  gen_exec(stmp);
X    /* have the exec routine do the work!! */
X  parse_exec_line(stmp,args);
X  run_exec_line(user.np,args);
X    /* make sure there is a current army selected */
X  return 1;
X}
X
X  /* allow the user to move an army */
Xmove_army(id,aw)
X     int id;
X     WINDOW *aw;
X{
X  int army_move_comment();
X    /* army being moved (and cargo if there) */
X  Sarmy *ap, *cargo_ap, *get_army();
X  Ssector *sp_initial, *sp_final;
X  Pt pos;
X  char s[EXECLEN];
X  int /* mv_initial, */ mv_final;
X
X  strcpy(help_tag, "Moving your armies");
X
X  ap = get_army(user.np, id);
X  if ((ap == NULL) || (ap->id != id)) {
X    beep();
X    statline("Type space to continue", "No Army Selected");
X    get_space();
X    return;
X  }
X  if ((ap->owner != user.id)) {
X    beep();
X    statline2_err("Type space to continue", "Army not yours");
X    return;
X  }
X  if ((ap->mvpts <= 0)) {
X    beep();
X    statline2_err("Type space to continue", "No movement left");
X    return;
X  }
X  if (is_in_transport(ap)) {
X    beep();
X    statline2_err("Type space to continue", "This army is loaded");
X    return;
X  }
X
X    /* remove it from old sector */
X  pos = user.cursor;		/* old position */
X  sp_initial = &world.map[pos.x][pos.y];
X    /* see if there is still something in the list */
X    delete_army_sector(sp_initial, ap); /* remove from sector list of armies */
X
X    /* now for the guts of it: drag the army along,
X       and get new position at the end.
X     */
X  pos = drag_cursor(ap->pos, DRAG_REL, army_move_comment, legal_move);
X  ap->pos = pos;		/* army is in a new place!! */
X  mv_final = ap->mvpts;
X    /* adding army to new sector */
X  sp_final = &world.map[pos.x][pos.y];
X  insert_army_sector(sp_final, ap);
X    /* put the user's cursor at new position */
X  user.cursor = pos;
X    /* make the exec line for this army movement */
X  sprintf(s, "AMOVE:%d:%d:%d:%d\n",
X	  ap->id, pos.x, pos.y, mv_final);
X  gen_exec(s);
X    /* not sure if I should call this here or in insert_army_sector() */
X  find_visible_sectors(user.visible_sectors);
X  user.current_army = ap->id;
X
X    /* now see if we should also move the cargo (recursively) */
X  if (is_cargo(ap) && ap->cargo.army >= 0) {
X    cargo_ap = ap;
X    while (cargo_ap = get_army(user.np, cargo_ap->cargo.army)) {
X	delete_army_sector(sp_initial, cargo_ap);
X      cargo_ap->pos = sp_final->loc;
X      insert_army_sector(sp_final, cargo_ap);
X      /* make the exec line for this army movement */
X      sprintf(s, "AMOVE:%d:%d:%d:%d\n",
X	      cargo_ap->id, pos.x, pos.y, cargo_ap->mvpts);
X      gen_exec(s);
X    }
X  }
X    /* now some code to allow an army in TRADED mode to
X       give itself to the recipient.  this only happens
X       on other peoples' trade posts.
X     */
X  if (ap->status == A_TRADED) donate_army(ap, sp_final);
X}
X
X  /* run through the armies in a sector and pick the next */
Xnext_army()
X{
X  int old_id;
X  Sarmy *ap = get_army(user.np, user.current_army);
X  Ssector *sp = &world.map[user.cursor.x][user.cursor.y];
X
X  if ((ap == NULL) || (sp->alist == NULL)) {
X    return;
X  }
X  old_id = ap->id;
X
X  if ((user.current_army = next_sect_army(sp, ap)) == -1) {
X    user.current_army = old_id;
X  }
X}
X  /* run through the armies in a sector and pick the previous */
Xprevious_army()
X{
X  Sarmy *ap = get_army(user.np, user.current_army);
X  Ssector *sp = &world.map[user.cursor.x][user.cursor.y];
X
X  if ((ap == NULL) || (sp->alist == NULL)) {
X    return;
X  }
X
X  if ((user.current_army = prev_sect_army(sp, ap)) == -1) {
X    user.current_army = first_sect_army(sp);
X  }
X}
X  /* run through the armies in a nation and pick the next */
Xnext_nation_army(np, old_id)
X     Snation *np;
X     int old_id;
X{
X  Sarmy *ap = get_army(np, old_id);
X
X  if (np->armies == NULL) {
X    return -1;
X  }
X  if (ap == NULL) {
X    return np->armies->id;	/* go to the start */
X  }
X  if (ap->next == NULL) {	/* we are at the end of the line */
X    return old_id;
X  }
X  return ap->next->id;		/* the next army id!! */
X}
X  /* run through the armies in a nation and pick the previous */
Xprev_nation_army(np, old_id)
X     Snation *np;
X     int old_id;
X{
X  Sarmy *ap = np->armies;
X
X  while (ap) {
X    if (ap->next && ap->next->id == old_id) {
X      return ap->id;
X    }
X    ap = ap->next;
X  }
X  return old_id;
X}
X
X  /* change the status of the army as it appears in both
X     the nation's army list and the sector army list.
X   */
Xchange_army_status(aw,id)
X     WINDOW *aw;
X     int id;			/* army id */
X{
X  char c;
X  Sarmy *ap;
X  Ssector *sp = &world.map[user.cursor.x][user.cursor.y];
X  char execstr[EXECLEN];
X
X  if ((ap = get_army(user.np, id)) == NULL) {
X    beep();
X    statline("type space to continue", "army not yours");
X    get_space();
X    return;
X  }
X
X  if (aw) {
X    statline2("Enter your new status.", "change_army_status");
X    wmove(aw, 5, 2);
X    wclrtoeol(aw);
X    mvwprintw(aw, 5, 2, " [a]ttack, [d]efend, [o]ccupy,");
X    mvwprintw(aw, 6, 2, " [p]atrol, [i]ntercept, [g]arrison or [t]raded");
X    box(aw,'|','-');
X    wrefresh(aw);
X  } else {
X    statline2("[a,d,o,n,p,i,g,t]", "change_army_status");
X  }
X  switch(c = getch()) {
X  case 'a':
X    ap->status = A_ATTACK;
X    sprintf(execstr, "ASTAT:%d:%d\n", ap->id, ap->status);
X    gen_exec(execstr);
X    break;
X  case 'd':
X    ap->status = A_DEFEND;
X    sprintf(execstr, "ASTAT:%d:%d\n", ap->id, ap->status);
X    gen_exec(execstr);
X    break;
X  case 'o':
X    if (can_occupy(ap)) {
X      if (sp->owner != ap->owner) {
X	ap->status = A_OCCUPY;
X	ap->mvpts = 0;
X	sprintf(execstr, "ASTAT:%d:%d\n", ap->id, ap->status);
X	gen_exec(execstr);
X      } else {
X	statline2_err("type space to continue", "cannot occupy your sector!");
X      }
X    } else {
X      statline2("type space to continue", "this army cannot occupy");
X      get_space();
X    }
X    break;
X  case 'p':
X    if (can_patrol(ap)) {
X      ap->status = A_PATROL;
X      sprintf(execstr, "ASTAT:%d:%d\n", ap->id, ap->status);
X      gen_exec(execstr);
X    } else {
X      statline2_err("type space to continue", "this army cannot patrol");
X    }
X    break;
X  case 'i':
X    if (can_intercept(ap)) {
X      ap->status = A_INTERCEPT;
X      sprintf(execstr, "ASTAT:%d:%d\n", ap->id, ap->status);
X      gen_exec(execstr);
X    } else {
X      statline2_err("type space to continue", "this army cannot intercept");
X    }
X    break;
X  case 'g':
X    if (can_garrison(ap)) {
X      ap->status = A_GARRISON;
X      sprintf(execstr, "ASTAT:%d:%d\n", ap->id, ap->status);
X      gen_exec(execstr);
X    } else {
X      statline2_err("type space to continue", "this army cannot garrison");
X    }
X    break;
X  case 't':
X    ap->status = A_TRADED;
X      /* see if the army is ready to be traded */
X    if (sp->owner != user.id && sp->designation == D_TRADE_POST) {
X      sprintf(execstr, "ASTAT:%d:%d\n", ap->id, ap->status);
X      gen_exec(execstr);
X      donate_army(ap, sp);
X    }
X    break;
X  default:
X    break;
X  }
X  show_armies(&world.map[user.cursor.x][user.cursor.y]);
X}
X
X  /* this function is used by move_army() with drag_cursor(),
X     and returns 0 if the given point cannot be moved to
X     by the given army.
X   */
Xlegal_move(pt, np, id)
X     Pt pt;
X     Snation *np;
X     int id;			/* army id */
X{
X  Sarmy *ap;
X  Ssector *sp = &world.map[pt.x][pt.y], *old_sp;
X  int cost;
X
X  wrap(&pt);
X    /* find the army we are moving around */
X  ap = get_army(np, id);
X
X  /* this is if we want to make it that armies cannot go
X     more than 1 step from land that they own.  for now, we
X     jack up the move cost instead, so this is commented out.
X   */
X
X  cost = get_army_move_cost(np, sp, ap);
X  if (ap->mvpts < cost) {
X    return 0;
X  }
X
X  ap->pos = pt;
X  user.cursor = pt;		/* so the map is drawn right */
X  army_visibility(user.visible_sectors, ap); /* update the visibility */
X  ap->mvpts -= cost;
X  return 1;			/* if we are here, must be a legal move */
X}
X
X  /* this function returns the status of the army, so it
X     can be put in the statline while the army is moved.  it
X     will also return a 0 if move points are over, or 1 if
X     there are still move points.
X   */
Xarmy_move_comment(s)
X     char *s;
X{
X  Sarmy *ap = get_army(user.np, user.current_army);
X  int cost;
X
X  cost = get_army_move_cost(user.np, &world.map[ap->pos.x][ap->pos.y], ap);
X
X  sprintf(s, "army %d; move points left: %d; cost %d", ap->id, ap->mvpts,cost);
X  return (ap->mvpts > 0) ? 0 : 1;
X}
X
X  /* draft an army for that nation */
Xdraft_army(np)
X     Snation *np;
X{
X  WINDOW *w;
X  int size, ret, i;
X  Sarmy army, make_army();	/* the new army!! */
X  Ssector *sp = &world.map[user.cursor.x][user.cursor.y];
X    /* exec string, army's type and army's name */
X  char s[EXECLEN], type[NAMELEN], name[NAMELEN], c;
X  extern struct s_desig_map desig_map[];
X
X  strcpy(help_tag, "Army types");
X
X  if (sp->owner != user.np->id) {
X    statline2_err("hit space to continue", "Must be your sector");
X    return;
X  }
X/* Make sure the sector is not hostile */
X  if (has_hostile(sp)) {
X    statline2_err("hit space to continue", "Cannot draft from hostile sector");
X    return;
X  }
X  
X  statline("choose your army/navy/caravan type", "draft_army");
X  if (!user.xmode) {
X    w = newwin(6, 60, LINES-14, COLS/5);
X    mvwprintw(w, 1, 1, "You have %d armies;  first free one is #%d",
X	      np->n_armies, free_army_id(np));
X    mvwprintw(w, 2, 1, "What type of army/navy/caravan do you want? ");
X    box(w, '|', '-');
X    wrefresh(w);
X  }
X  noecho();
X  cbreak();
X  c = getch();
X  if (c == '?') {
X    online_info();
X    return -1;
X  } else if (c == ' ') {
X    if (!user.xmode) {
X      wrefresh(w);
X      delwin(w);
X      touch_all_wins();
X    }
X    return -1;
X  }
X  for(i = 0; i < user.n_army_types; i++) {
X    if (army_types[i].type_char == c) {
X      strcpy(type, army_types[i].type);
X      break;
X    }
X  }
X				/* While it is still the same army_types... */
X  if (!strchr (army_types [i].draft_places, desig_map[sp->designation].mark)) {
X    statline2_err ("hit space", "bad place to draft");
X    if (!user.xmode) {
X      wrefresh (w);
X      delwin (w);
X    }
X    return -1;
X  }
X  if (!is_avail_army_type(&user, type)) {
X    statline2_err("Hit space to get back", "Bad army type");
X    if (!user.xmode) {
X      wrefresh(w);
X      delwin(w);
X      touch_all_wins();
X    }
X    return -1;
X  }
X  if (!user.xmode) {
X    wprintw(w, "%s", type);
X  }
X
X  strcpy (name, type);
X
X  if (user.xmode) {
X    sprintf(s, "(default: %s): ", name);
X    statline2_prompt(s, "Name your army");
X    ret = wget_name(stdscr, name);
X  } else {
X    mvwprintw(w, 3, 1, "Name your army (default: %s):  ", name);
X    ret = wget_name(w, name);
X  }
X    /* if they just type return, use the default name */
X  if (ret <= 0) {
X    sprintf(name, "%s", type, free_army_id(np));
X  }
X
X  if (user.xmode) {
X    statline("", "How many units?");
X    move(LINES-1, 0);
X    ret = wget_number(stdscr, &size);
X  } else {
X    mvwprintw(w, 4, 1, "How many units do you want? ");
X    box(w, '|', '-');
X    ret = wget_number(w, &size);
X  }
X  if ((ret <= 0) || (size <= 0)) {
X    if (!user.xmode) {
X      wrefresh(w);
X      delwin(w);
X      touch_all_wins();
X    }
X    return -1;
X  }
X  army = make_army(type, name, size, A_DEFEND, np->id, sp->loc);
X  army.id = free_army_id(np);
X  army.next = NULL;
X    /* now see if we can afford the army */
X  if (army.n_soldiers
X      > (sp->n_people - desig_map[sp->designation].min_employed)) {
X    beep();
X    statline2("space to go on", "not enough people in sector");
X    get_space();
X    if (!user.xmode) {
X      wrefresh(w);
X      delwin(w);
X      touch_all_wins();
X    }
X    return -1;
X  }
X  if (army_cost(&army) > user.np->money) {
X    beep();
X    statline2("space to go on", "not enough money to draft");
X    get_space();
X    if (!user.xmode) {
X      wrefresh(w);
X      delwin(w);
X      touch_all_wins();
X    }
X    return -1;
X  }
X  if (army_cost_metal(&army) > user.np->metal) {
X    beep();
X    statline2("space to go on", "not enough metal to draft");
X    get_space();
X    if (!user.xmode) {
X      wrefresh(w);
X      delwin(w);
X      touch_all_wins();
X    }
X    return -1;
X  }
X
X    /* well, if we have reached this point, it means that we
X       can afford this army, so let us insert it into the lists
X     */
X  np->n_armies++;
X  if (np->armies == NULL) {	/* special case:  empty list */
X    np->armies = (Sarmy *) malloc(sizeof(Sarmy));
X    *(np->armies) = army;
X    np->armies->next = NULL;
X  } else {
X    insert_army_nation(np, &army, -1);
X  }
X  insert_army_sector(sp, &army);
X  sp->n_people -= army.n_soldiers;
X  np->money -= army_cost(&army);
X  np->metal -= army_cost_metal(&army);
X    /* now prepare the exec string for making the army and costs */
X  sprintf(s, "AMAKE:%d:%d:%d:%d:%s:%s\n", army.id, army.n_soldiers,
X	  army.pos.x, army.pos.y, army.type, army.name);
X  gen_exec(s);
X  cpeople_sector(sp, -army.n_soldiers);
X  cmoney(np, -army_cost(&army));
X  cmetal(np, -army_cost_metal(&army));
X
X  show_armies(sp);
X
X  if (!user.xmode) {
X    wrefresh(w);
X    delwin(w);
X    touch_all_wins();
X  }
X  just_moved();
X  return 1;
X}
X
X  /* get the first army in that sector that belongs to you */
Xfirst_sect_army(sp)
X     Ssector *sp;
X{
X  int id = -1;			/* default:  no army selected */
X  struct armyid *alist = sp->alist;
X  char s[100];
X
X  while (alist != NULL) {
X    if (alist->owner == user.id) {
X/* this routine sometimes messes up */
X      id = alist->id;
X      break;
X    }
X    alist = alist->next;
X  }
X
X  return id;
X}
X
X  /* takes a sector, an army (possibly in that sector), and
X     returns the id of the next army you own in that sector,
X     or -1 if you don't have any more
X   */
Xnext_sect_army(sp, ap)
X     Ssector *sp;
X     Sarmy *ap;
X{
X  struct armyid *alist = sp->alist;
X  char s[100];
X
X  if (ap == NULL) {		/* in case the army given was bogus */
X    return first_sect_army(sp);
X  }
X
X    /* first get up to the given army */
X  while ((alist != NULL) &&
X	 !((alist->id == ap->id) && (alist->owner == ap->owner))) {
X    alist = alist->next;
X  }
X/*  if (alist->next == NULL) {	/* we are at the end of the list */
X/*    return -1;
X  }
X*/
X
X  if ((alist == NULL) || (alist = alist->next) == NULL) {
X    return -1;
X  }
X    /* now look for the next army owned by the current user */
X  while ((alist != NULL) && (alist->owner != ap->owner)) {
X    alist = alist->next;
X  }
X  if (alist == NULL) {
X    return -1;
X  }
X  return alist->id;		/* in this case, we have a valid next army */
X}
X
X  /* takes a sector, an army (should be in that sector), and
X     returns the id of the previous army you own in that sector,
X     or -1 if you don't have any more.
X   */
Xprev_sect_army(sp, ap)
X     Ssector *sp;
X     Sarmy *ap;
X{
X  struct armyid *alist = sp->alist, *previous = sp->alist;
X  previous = NULL;
X
X  if ((ap == NULL) || (alist == NULL)) {
X    return first_sect_army(sp);
X  }
X    /* now get up to the given army */
X  while ((alist != NULL) &&
X	 !((alist->owner == ap->owner) && (alist->id == ap->id))) {
X    if (alist->owner == ap->owner) {
X      previous = alist;
X    }
X    alist = alist->next;
X  }
X
X  return (previous == NULL) ? -1 : previous->id;
X}
X
X  /* gives a list of army types available to this user */
Xlist_available_armies(up, aw)
X     Suser *up;
X     WINDOW *aw;		/* army window */
X{
X  int i, count = 0;
X  Savail_army *avail_armies = up->avail_armies;
X  char s[200];
X
X  strcpy(s, " ");
X  if (aw) {
X    wmove(aw, 1, 1);
X    wclrtobot(aw);
X    mvwprintw(aw, 1, 20, "AVAILABLE ARMIES");
X    wmove(aw, 2, 1);
X  }
X  while (avail_armies != NULL) {
X    if ((i = army_type_index(avail_armies->type)) >= 0) {
X      if (aw) {
X	wprintw(aw, " %s(%c) ", army_types[i].type, army_types[i].type_char);
X      } else {
X	sprintf(s, "%s%c ", s, army_types[i].type_char);
X      }
X      if (aw && avail_armies->next != NULL) {
X	waddstr(aw, ",");
X      }
X      if (aw) { wclrtoeol(aw); }
X      ++count;
X      if (aw && (count % 5) == 0) { /* new line */
X	wmove(aw, 2+count/5, 1);
X      }
X    }
X    avail_armies = avail_armies->next;
X  }
X  if (aw) {
X    box(aw, '|', '-');
X    wrefresh(aw);
X    statline2("Type space to get back", "list_available_armies");
X  } else {
X    statline2(s, "list_available_armies");
X  }
X}
X
X
Xarmy_disband(sp, ap)
X
XSsector *sp;
XSarmy * ap;
X{
X  int army_num, done, index, metal_return;
X  Snation *np = user.np;
X  char s[EXECLEN], c;
X  struct argument args[N_EXEC_ARGS];
X
X  if (sp->owner != np->id) {
X    statline2_err("Hit space to get back", "You don't own sector");
X    return 0;
X  }
X
X  if (is_in_transport(ap)) {
X    statline2_err("Hit space to get back", "Army is in transport");
X    return 0;
X  }
X  if (is_cargo(ap) && cargo_not_empty(&ap->cargo)) {
X    statline2_err("Hit space to get back", "Caravan has stuff loaded");
X    return 0;
X  }
X  if (is_spelled(ap)) {
X    statline2_err("Hit space to get back", "Army under a spell");
X    return 0;
X  }
X  sprintf (s, "Disband army %d.  Are you sure? ", ap->id);
X  statline2_prompt (s, "army_disband");
X
X  switch (c = getch()) {
X  case 'Y':
X  case 'y':
X    sprintf(s, "ADISBAND:%d\n", ap->id);
X    index = army_type_index (ap->type);
X    if (index != -1) {  /* If it's not a spirit */
X      metal_return = (army_types [index].metal_draft * ap->n_soldiers) *
X	DISBAND_RETURN;
X      np->metal +=metal_return;
X      cmetal (np, metal_return);
X    }
X
X    gen_exec(s);
X    parse_exec_line(s,args);
X    run_exec_line(np,args);
X    break;
X  case 'N': case 'n':
X  default: 
X    break;
X  }
X
X  if (get_army(user.np, user.current_army) == NULL) {
X    user.current_army = first_sect_army(sp);
X  }
X  just_moved ();
X}
X
X  /* give a name to an army */
Xarmy_name (ap)
X     Sarmy * ap;
X{
X  char name[NAMELEN], s[EXECLEN];
X  int ret;
X
X  statline2_prompt ("Give army name: ", "");
X  ret = wget_name(stdscr, name);
X  if (ret > 0) {
X    strcpy(ap->name, name);
X      /* now generate the exec instruction */
X    sprintf(s, "ANAME:%d:%s\n", ap->id, ap->name);
X    gen_exec(s);
X  }
X  noecho();
X  cbreak();
X}
X
X  /* give a detailed description of all armies in a nation,
X     or just those in the "current_sp".
X   */
Xzoom_armies(up, sp)
X     
XSuser *up;
XSsector *sp;
X{
X  WINDOW *azlw, * azmw;
X  Sarmy * armies;
X  int army_count, maxlen_win;
X  int num_shown;
X  int show_cargo = 0;
X  int done = 0;
X  int page = 1;
X  int maxpage;
X
X  armies = up->np->armies;
X  army_count = 0;
X
X  while (armies != NULL) {	/* Count the number of armies to be shown  */
X    if (sp != NULL) {
X      if (armies->pos.x == sp->loc.x
X	      && armies->pos.y == sp->loc.y) {
X	army_count ++;
X      }
X    } else {
X      army_count++;
X    }
X    armies = armies->next;
X  }
X
X  if (army_count == 0) {
X    return 0;
X  }
X
X  maxlen_win = LINES - 3;
X  if (!user.xmode) {		/* Allow for the non-expert menu */
X    maxlen_win -= 4;
X  }
X
X  if (army_count <= maxlen_win - 4) { /* Don't use the entire window len? */
X    maxlen_win = army_count + 4;
X    num_shown = army_count;
X    if (user.xmode) {
X      azlw = newwin (maxlen_win, COLS, LINES - (2 + maxlen_win), 0);
X    }
X    else {
X      azlw = newwin (maxlen_win, COLS, LINES - (2 + 4 + maxlen_win), 0);
X    }
X  }
X  else {
X    num_shown = maxlen_win - 4;
X    azlw = newwin (maxlen_win, COLS, 1, 0);
X  }
X  maxpage = army_count / (maxlen_win - 4); 
X  maxpage ++;
X  
X  box (azlw, '|', '-');
X
X  mvwprintw (azlw, 1, 1, 
X" ID Name       Size Type        Status  Bonus       ");
X  mvwprintw (azlw, 1, 47, "%s", show_cargo ? "Cargo" : "Maint");
X  mvwprintw (azlw, 2, 1, 
X"--- ---------  ---- ----------- ------- ----  ------------------------------");
X
X
X  while (!done) {
X    char c;
X    int i;
X    char s [EXECLEN];
X    Sarmy * ap;
X    Ssector * sp2;
X    
X    sp2 = &world.map[user.cursor.x][user.cursor.y];
X
X    statline2 ("", "");
X    for (i = 3; i < maxlen_win - 1; i++) {
X      wmove (azlw, i, 0);
X      wclrtoeol (azlw);
X    }
X    if (user.xmode) {
X      azmw = NULL;
X      statline ("[>,<,c,D,E,N,+,-]", "zoom_armies");
X    } else {
X      azmw = newwin (4, COLS, LINES - 6, 0);
X      box (azmw, '|', '-');
X      mvwprintw(azmw, 1, 1,
X		" [>]/[.]next pg, [<]/[,]prev pg,[N]ame army, [c] examine %s ",
X		show_cargo ? "costs" : "cargo");
X      mvwprintw(azmw, 2, 1,
X	" [D]isband army, [-]split army, [+]merge army [E]xamine army");
X      statline ("Choose zoom_army command (space to exit)", "zoom_armies");
X      wrefresh (azmw);
X    }
X
X    box (azlw, '|', '-');
X    zoom_army_page (azlw, up->np->armies, sp, page,maxlen_win-4, show_cargo);
X
X    do { c = getch (); } while (strchr (" <>.,NcD-+E", c) == NULL);
X
X    switch (c) {
X    case ' ':
X      done = 1;
X      break;
X    case 'c':
X      show_cargo = !show_cargo;
X      mvwprintw (azlw, 1, 47, "%s", show_cargo ? "Cargo" : "Maint");
X      wrefresh (azlw);
X      if (azmw) {
X	mvwprintw(azmw, 1, 1,
X	  " [>]/[.]next pg, [<]/[,]prev pg,[N]ame army, [c] examine %s ",
X		  show_cargo ? "costs" : "cargo");
X	wrefresh (azmw);
X      }
X      break;
X    case '>':
X    case '.':
X      if (page != maxpage) {
X	page ++;
X      }
X      break;
X    case '<':
X    case ',':
X      if (page != 1) {
X	page --;
X      }
X      break;
X    case 'N':
X      statline2_prompt ("Name army #", "army_name"); 
X      if (((wget_number (stdscr, &i)) <= 0) || 
X	((ap  = get_army (user.np, i)) == NULL)) {
X	break;
X      }
X      army_name (ap);
X      break;
X    case 'E':
X      statline2_prompt ("Examine army #", "army_examine"); 
X      if (((wget_number (stdscr, &i)) <= 0) || 
X	((ap  = get_army (user.np, i)) == NULL)) {
X	break;
X      }
X      army_examine(ap);
X      break;
X    case 'D':
X      statline2_prompt ("Disband army #", "army_disband"); 
X      if (((wget_number (stdscr, &i)) <= 0) || 
X	((ap  = get_army (user.np, i)) == NULL)) {
X	break;
X      }
X      army_disband (sp2, ap);
X      break;
X    case '-':
X      statline2_prompt ("Split army #", "army_split"); 
X      if (((wget_number (stdscr, &i)) <= 0) || 
X	((ap  = get_army (user.np, i)) == NULL)) {
X	break;
X      }
X      army_split (ap);
X      break;
X    case '+':
X      statline2_prompt ("Merge army #", "army_merge"); 
X      if (((wget_number (stdscr, &i)) <= 0) || 
X	((ap  = get_army (user.np, i)) == NULL)) {
X	break;
X      }
X      army_merge (ap);
X      break;
X    }
X  }
X
X  if (azmw) { delwin(azmw); }
X  delwin(azlw);
X  touch_all_wins();
X  return 0;
X}
X
X/* This function is used by zoom_armies to select the page of armies you want*/
X
Xzoom_army_page (azlw, armies, sp, page, len_page, show_cargo)
X
XWINDOW * azlw;
XSarmy * armies;
XSsector * sp;
Xint page, len_page, show_cargo;
X{
X  int army_count, i;
X  Sarmy * ap = armies;
X
X  while (ap != NULL) {
X    if (sp != NULL) {
X      if (sp->loc.x == ap->pos.x && sp->loc.y == ap->pos.y) {
X	army_count ++;
X      }
X    }
X    else {
X      army_count ++;
X    }
X    ap = ap->next;
X  }
X
X  if (army_count <= len_page) {
X    zoom_list_armies (azlw, armies, sp, 0, len_page, show_cargo);
X    return 0;
X  }
X  if ((page - 2) * len_page > army_count) {	/* Too high a page number */
X    return 1;
X  }
X  ap = armies;
X
X  for (i=0; i < (page-1) * len_page; i++) {
X    ap = ap->next;
X  }
X  if (ap != NULL) {
X    zoom_list_armies (azlw, armies, sp, ap->id, len_page, show_cargo);
X  }
X  return 0;
X}
X
X/* This function is used by zoom_armies to list armies in the azlw win */
X
Xzoom_list_armies (azlw, armies, sp, start_army, len_win, cargo)
X
XWINDOW * azlw;
XSarmy * armies;
XSsector * sp;
Xint start_army;			/* Starting army number */
Xint len_win;			/* Number of army lines allowed in window */
Xint cargo;			/* Cargo mode? */
X{
X  int army_count;
X  int row;
X  char * slash_pos;
X  Scargo * snails;		/* Sorry for the pun :-) */
X  char * contents ();		/* Returns string of stuff, nicely formatted */
X  char s [EXECLEN];
X  char zooms [EXECLEN];
X
X  while (armies != NULL) {	/* Get to the starting army number */
X    if (armies->id >= start_army) { /* In case it doesn't actually exist... */
X      break;
X    }
X    armies = armies->next;
X  }
X
X  if (sp != NULL) {		/* If not zoom ALL armies, */
X    do {			/* Check that the first army is on sector */
X      if (armies->pos.x == sp->loc.x && armies->pos.y == sp->loc.y) {
X	break;
X      }
X      armies = armies->next;
X    } while (armies != NULL);
X  }
X
X  /* Now display the armies */
X
X  row = 3;
X  while (armies != NULL && row-3 < len_win) {
X    mvwprintw(azlw, row,  1, "%3d    ", armies->id);
X    mvwprintw(azlw, row,  5, "%s                   ", armies->name);
X    mvwprintw(azlw, row, 16, "%4d  ", armies->n_soldiers);
X    mvwprintw(azlw, row, 21, "%s           ", armies->type);
X    get_army_status(armies, s);
X    slash_pos = (char *) strchr (s, (int) '/');
X    if (slash_pos != NULL) {
X      *slash_pos = '\0';
X    }
X    mvwprintw(azlw, row, 33, "%s     ", s);
X    mvwprintw(azlw, row, 42, "%3d    ", armies->sp_bonus);
X
X    strcpy (zooms, "");
X    if (cargo) {
X      if (!is_cargo (armies)) {
X	sprintf (zooms, "   not a transport");
X      }
X      else {
X	snails = &armies->cargo;
X	sprintf (zooms, "%s", 
X		 contents (snails->money, snails->metal, snails->jewels,
X			   snails->food, snails->people, snails->army,
X			   &snails->title, 0));
X      }
X    }
X    else {
X      sprintf (zooms, "%s",
X	       contents (armies->money_maint * armies->n_soldiers,
X			 armies->metal_maint * armies->n_soldiers,
X			 armies->jewel_maint * armies->n_soldiers, 0,
X			 0, -1, NULL, get_spell_pts_maint (armies))); 
X    }
X
X    mvwprintw(azlw, row, 47, zooms);
X
X    armies = armies->next;
X    if (sp != NULL && armies) {	/* Again, check if we want to discriminate...*/
X      do {
X	if (armies->pos.x == sp->loc.x && armies->pos.y == sp->loc.y) {
X	  break;
X	}
X	armies = armies->next;
X      } while (armies != NULL);
X    }
X    row ++;
X  }
X  wrefresh (azlw);
X}
X
X    /* now some code to allow an army in TRADED mode to
X       give itself to the recipient.  this only happens
X       on other peoples' trade posts.
X     */
Xdonate_army(ap, sp)
X     Sarmy *ap;
X     Ssector *sp;
X{
X  if (is_cargo (ap) && cargo_not_empty (&ap->cargo)) {
X    statline2_err ("Error: transport still has a cargo", "donate_army");
X  } 
X  else if (ap->flags & AF_IN_TRANSPORT) {
X    statline2_err ("Error: army is still in transport", "donate_army");
X  }
X  else if ((ap->status == A_TRADED) && (sp->designation == D_TRADE_POST)
X      && (sp->owner !=  user.np->id)) {
X    statline2("Do you want to trade this army right here [y/n]? ", "");
X    switch (getch()) {
X      Scargo cargo;
X    case 'y':
X    case 'Y':
X      cargo.money = cargo.metal = cargo.jewels = cargo.food = 0;
X      cargo.people = 0;
X      cargo.army = ap->id;
X      cargo.title.x = -1;
X      cargo.title.y = -1;
X      donate_cargo(sp->loc.x, sp->loc.y,
X		   user.np->id, sp->owner, &cargo);
X      break;
X    default:
X      break;
X    }
X  }
X}
X
Xextern int (*wrapx)(), (*wrapy)();
X
Xint jarmy ()
X{
X  char s[100];
X  int army_num;
X  Sarmy * ap;
X  int x, y;
X
X  ap = user.np->armies;
X
X  statline2 ("Army number to jump to? ", "jump_army");
X  move (LINES-2, 25);
X  refresh ();
X  if (wget_number(stdscr, &army_num) < 1) {
X    statline2("", "");
X    return;
X  }
X
X  while (ap != NULL) {
X    if (ap->id == army_num) {
X      break;
X    }
X    ap = ap->next;
X  }
X
X  if (ap == NULL) {
X    statline2_err ("Hit space to continue", "army does not exist");
X    return 0;
X  }
X  if (ap->id == army_num) {
X    x = ap->pos.x;
X    y = ap->pos.y;
X    user.cursor.x = (*wrapx)(x,y);
X    user.cursor.y = (*wrapy)(x,y);
X    user.center = user.cursor;
X    user.current_army = ap->id;
X    just_moved();
X  }
X  statline2("", "");
X  return 1;
X}
X
Xarmy_examine(ap)
X     Sarmy * ap;
X{
X  WINDOW * flagw, * infow;
X  char s [NAMELEN], * slash_pos;
X  int n_flags = 0;
X  int i, rowpos;
X  char * flags [20];
X  Snation * np = &world.nations [ap->owner];
X
X  infow = newwin (9, 32, 0, 0);
X  box (infow, '|', '-');
X
X  get_army_status (ap, s);
X
X  slash_pos = (char *)strchr (s, (int)'/');
X  n_flags = 0;
X  if (slash_pos != NULL) {
X    n_flags = strlen(slash_pos) - 1;
X    *slash_pos = '\0';
X  }
X
X  mvwprintw (infow, 1, 2, "Name: %8s (#%d)", ap->name, ap->id);
X  mvwprintw (infow, 2, 2, "%d Movepoints, %d left",
X	     army_move_rate (np, ap), ap->mvpts);
X  mvwprintw (infow, 3, 2, "Type: %d %s", ap->n_soldiers, ap->type);
X  mvwprintw (infow, 4, 2, "Status: %s  Bonus: %d",
X	     s, ap->sp_bonus);
X  if (is_cargo (ap)) {
X    mvwprintw (infow, 5,2, "Capacity: %d/Weight: %d",
X	       ap->n_soldiers * CARAVAN_CAPACITY, army_weight (ap));
X  }
X  else {
X    mvwprintw (infow, 5,2, "Weight: %d", army_weight (ap));
X  }
X  mvwprintw (infow, 6,2, "Maintenance per thon:");
X  mvwprintw (infow, 7,2, "  %s",
X	     contents (ap->money_maint * ap->n_soldiers,
X		       ap->metal_maint * ap->n_soldiers,
X		       ap->jewel_maint * ap->n_soldiers, 0,
X		       0, -1, NULL, get_spell_pts_maint (ap))); 
X  wrefresh (infow);
X
X  if (n_flags > 0) {
X    flagw = newwin (n_flags + 2, COLS - 40, 0, 40);
X
X    rowpos = 1;
X    for (i = 0; i < 32; i++) {
X      if (strlen (army_flags [i].description) > 0 &&
X		  ap->flags & (0x1 << i)) {
X	mvwprintw (flagw, rowpos, 1, "%s", army_flags [i].description);
X	rowpos++;
X      }
X    }
X    box (flagw, '|', '-');
X    wrefresh (flagw);
X  }
X  else {
X    flagw = NULL;
X  }
X
X  statline2_err ("hit space to continue", "army_examine");
X  werase (infow);
X  if (flagw) {
X    werase (flagw);
X  }
X  touch_all_wins ();
X}
END_OF_FILE
if test 40121 -ne `wc -c <'army.c'`; then
    echo shar: \"'army.c'\" unpacked with wrong size!
fi
# end of 'army.c'
fi
if test -f 'npcs' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'npcs'\"
else
echo shar: Extracting \"'npcs'\" \(1103 characters\)
sed "s/^X//" >'npcs' <<'END_OF_FILE'
X# Format of NPC descriptions
X# Nation :Leader :Race:Mark:Order :Aggr:Expan:Iso
X26
XAsterix	 :Sariture	:E:a:Chess	:40:8:5
XBrukhan	 :Derikus	:S:b:Unity	:60:4:5
XCerelias :Erisp_Dalidus	:A:c:Diana	:35:5:5
XDusitari :Gruite	:D:d:Unity	:55:6:5
XErigat	 :Anvlak	:o:e:Inferno	:65:8:5
XFusigade :Lurivar	:S:f:Chess	:50:6:5
XGrenzell :Tarni		:h:g:Time	:30:3:5
XHezra	 :Zerilla	:y:h:Insects	:75:5:5
XIcbrek	 :Ynavo_Pgirish	:I:i:Demonology	:70:4:5
XJezertok :Grash		:O:j:Monsters	:95:3:5
XKrell	 :Zucchini	:A:k:Yavanna	:40:6:5
XLhuvadan :Freziqua	:H:l:Avian	:25:9:5
XMurdika	 :Thrarish	:D:m:Aule	:50:4:5
XNerisent :Namdas	:I:n:Yavanna	:20:5:5
XOriesca	 :Bresk_Tinkerson :G:o:Aule	:40:3:5
XPnafari	 :Screrc	:y:p:Avian	:65:7:5
XQuavish	 :Wavariaus	:W:q:Insects	:80:6:5
XRushard	 :Herni_Vaserus	:M:r:Demonology	:70:7:5
XSyntharc :Fondin	:E:s:Inferno	:55:5:5
XTuvric	 :Walvrus	:W:t:Neptune	:65:5:5
XUtoprus	 :Savyur	:h:u:Diana	:15:1:5
XVertuhl	 :Vortalk	:H:v:Time	:55:6:5
XWendivar :Turugu	:o:w:Necromancy	:65:7:5
XXeribar	 :Xerine	:G:x:Monsters	:60:4:5
XYeperion :Hergi_Bendfin	:M:y:Neptune	:40:6:5
XZuruiten :Jezikus	:O:z:Necromancy	:65:5:5
END_OF_FILE
if test 1103 -ne `wc -c <'npcs'`; then
    echo shar: \"'npcs'\" unpacked with wrong size!
fi
# end of 'npcs'
fi
echo shar: End of archive 1 \(of 28\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Now execute ./do_cat.sh to build doc files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
