Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i062:  dominion - a multi-player world simulation game, Part26/28
Message-ID: <2465@masterCNA.TEK.COM>
Date: 11 Feb 92 18:27:54 GMT
Sender: news@masterCNA.TEK.COM
Lines: 2091
Approved: billr@saab.CNA.TEK.COM

Submitted-by: rosalia@dirac.physics.sunysb.edu (Mark Galassi)
Posting-number: Volume 13, Issue 62
Archive-name: dominion/Part26
Environment: Unix, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 26 (of 28)."
# Contents:  addnews.sh diplomacy.c mail.c misc.h spy.c user.c world.c
# Wrapped by billr@saab on Tue Feb 11 10:14:59 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'addnews.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'addnews.sh'\"
else
echo shar: Extracting \"'addnews.sh'\" \(1606 characters\)
sed "s/^X//" >'addnews.sh' <<'END_OF_FILE'
X#!/bin/sh
X#
X# Copyright (C) 1990 Free Software Foundation, Inc.
X# Written by the SBW project.
X#
X# This file is part of SBW.
X#
X# SBW is free software; you can redistribute it and/or
X# modify it under the terms of the GNU General Public License as published
X# by the Free Software Foundation; either version 1, or (at your option)
X# any later version.
X#
X# This software is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X#
X# You should have received a copy of the GNU General Public License
X# along with this software; see the file COPYING.  If not, write to
X# the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X
Xcase $# in 
X2)
X	echo 'Adding  newsgroups' ;;
X*)
X	echo 'Problem in calling addnews' 1>&2 ; exit 2;;
Xesac
X
XDIR=$1
XDB=$2
Xif  test ! -d "$DIR"
Xthen
X	echo 'Problem with news directory argument' 1>&2
X	exit 3
Xfi
Xif test ! -f  "$DIR/$DB"
Xthen
X	touch $DIR/$DB
X	echo 'Creating new database ' $DIR/$DB
Xelse
X	echo 'Adding groups to database ' $DIR/$DB
Xfi
X
Xt="y"
Xwhile test "$t" = "y"
Xdo
X	echo 'Enter the name of the news group: \c'
X	read group
X	echo 'Do you want it human (default) or just game postable (G=game) \c'
X	read postable
X	if test "$postable" = "G"
X	then
X		echo $group ' 1 0 0' >> $DIR/$DB
X	else
X		echo $group ' 1 0 1' >> $DIR/$DB
X	fi
X	if test ! -d "$DIR/$group"
X	then
X		mkdir $DIR/$group
X	fi
X	echo 'Do you want another group? (y/Y=yes) \c'
X	read t
X	if test "$t" = "Y"
X	then
X		t="y"
X	fi
Xdone
X
Xexit 0
END_OF_FILE
if test 1606 -ne `wc -c <'addnews.sh'`; then
    echo shar: \"'addnews.sh'\" unpacked with wrong size!
fi
chmod +x 'addnews.sh'
# end of 'addnews.sh'
fi
if test -f 'diplomacy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'diplomacy.c'\"
else
echo shar: Extracting \"'diplomacy.c'\" \(8211 characters\)
sed "s/^X//" >'diplomacy.c' <<'END_OF_FILE'
X/* diplomacy.c - screen-oriented diplomacy routines */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include <stdio.h>
X#include <ctype.h>
X
Xextern Sworld world;
Xextern Suser user;
Xextern char *dip_status[];
X
Xchar show_to_screen();
X
Xchar diplo_report(nation)
X     Snation *nation;
X{
X  Sdiplo **diplo_matrix, **initial_diplo; /* structure containing all info */
X  Sdiplo **allocate_diplo();
X  FILE   *dfp;           /* file containing all info */
X  int i;
X  char c;
X
X/*  statline2_err("diplo was not locked", "hit space"); */
X    /* read in the current diplomacy matrix, and also the
X       initial state (to see if the user wants to change
X       their status too much)
X     */
X  diplo_matrix = allocate_diplo(world.n_nations);
X  initial_diplo = allocate_diplo(world.n_nations);
X  read_initial_diplo(initial_diplo, world.n_nations);
X    /* if reading in the file fails, we must re-create it */
X  if (read_in_diplo(diplo_matrix, world.n_nations) == -1) {
X    statline2_err("Hit space to go on", "have to re-build diplo file");
X    init_diplo(1);
X    for (i = 2; i <= world.n_nations; ++i) {
X      Sdiplo **dm_old, **dm_new;
X      dm_old = allocate_diplo(i-1);
X      dm_new = allocate_diplo(i);
X      read_in_diplo(dm_old, i-1);
X      increase_diplo(dm_old, dm_new, i-1, &world.nations[i-1]);
X      dump_diplo(nation, dm_new, i);
X      free_diplo(dm_old, i-1);
X      free_diplo(dm_new, i);
X    }
X    update_diplo();		/* update it, since it was reset */
X    read_in_diplo(diplo_matrix, world.n_nations);
X  }
X
X  c = show_to_screen(diplo_matrix, initial_diplo, nation);
X  free_diplo(diplo_matrix, world.n_nations);
X  return c;
X}
X
Xchar show_to_screen(dm, initial_dm, nation)
X  Sdiplo **dm, **initial_dm;
X  Snation *nation;
X{
X/* this function will dynamically keep the window updated with 
X   the diplomacy information.
X */
X
X  WINDOW *dipw;          /* the diplomacy window */
X  int i, j, done=0, neigh_id=0, first_shown, n_shown;
X  char c;
X
X  statline("hit space when done", "diplomacy report");
X
X  dipw = newwin(LINES-2, COLS, 0, 0);  /* full screen window */
X  werase(dipw);
X  touchwin(dipw);
X  first_shown = 1;
X  n_shown = min(world.n_nations, LINES-9);
X  while (!done) {
X    wmove(dipw, 0, COLS/2-13);
X    wstandout(dipw);
X    wprintw(dipw, "Diplomacy for nation %s", nation->name);
X    wstandend(dipw);
X
X  mvwprintw(dipw,1,3,"                                        TO  YOU        TO YOU  ");
X  mvwprintw(dipw,2,3," NATION                   BY YOU         (now)       (at start)");
X  mvwprintw(dipw,3,3," ======                   ======         ======      ==========");
X    wclrtobot(dipw);
X
X    i=0;
X    for (j = 0; j < n_shown &&  j+first_shown < world.n_nations; ++j) {
X        /* j+first_shown is for nation ids, i is for lines printed */
X      wmove(dipw, 4+j, 3);
X      wclrtoeol(dipw);
X      ++i;
X      if (is_active_ntn(&world.nations[j+first_shown])) {
X	mvwprintw(dipw, 4+j, 3, "%2d. %-21s%c%-12s  %c%-12s  %-12s",
X		  world.nations[j+first_shown].id,
X		  world.nations[j+first_shown].name,
X		  dm[nation->id][j+first_shown].status ==
X	          initial_dm[nation->id][j+first_shown].status ? ' ' : '*',
X		  dip_status[ dm[nation->id][j+first_shown].status ],
X		  dm[j+first_shown][nation->id].status ==
X		  initial_dm[j+first_shown][nation->id].status ? ' ' : '*',
X		  dip_status[dm[j+first_shown][nation->id].status ],
X		  dip_status[ initial_dm[j+first_shown][nation->id].status ]);
X      } else {
X	mvwprintw(dipw, 4+j, 3, "%2d. %-21s   ** DESTROYED **",
X		  world.nations[j+first_shown].id,
X		  world.nations[j+first_shown].name);
X      }
X    }
X    mvwprintw(dipw, LINES-4, 4,
X      "[c]hange diplomacy status, [<]/[,] previous page, [>]/[.] next page");  
X    mvwprintw(dipw, LINES-3, 4,
X      "    Other reports: [i]nfo, [b]udget, [p]roduction, [n]ations ");
X    wrefresh(dipw);    /* update the window, always before input */
X
X    switch (c = getch()) {
X    case ' ':
X    case 'i':
X    case 'b':
X    case 'p':
X    case 'n':
X      done = 1;
X      break;
X    case '.':
X    case '>':
X      if (first_shown + n_shown < world.n_nations) {
X	first_shown += n_shown;
X      }
X      break;
X    case ',':
X    case '<':
X      if (first_shown > 1) {
X	first_shown -= n_shown;
X      }
X      break;
X    case 'c':
X        /* allow to change status */
X      mvwprintw(dipw, LINES-3, 3, "TO WHAT NATION: ");
X      wclrtoeol(dipw);
X      wget_number(dipw, &neigh_id);
X      if (!(have_met(dm, nation->id, neigh_id)) && user.id != 0) {
X	mvwprintw(dipw, LINES-4, 3, "Have not met that nation yet!!!");
X	mvwprintw(dipw, LINES-3, 3, "--- hit space to continue ---");
X	wrefresh(dipw);    /* update the window, always before input */
X	get_space();
X	wrefresh(dipw);    /* update the window, always before input */
X      } else if (diplo_is_locked()) {
X	statline2_err("Sorry, someone writing diplomacy file.", "hit space");
X      } else {
X	change_dip_status(dm, initial_dm, nation->id, neigh_id);
X	dump_diplo(nation, dm, world.n_nations);
X	touchwin(dipw);
X	wrefresh(dipw);    /* update the window, always before input */
X      }
X      break;
X    default:
X      bad_key();
X      break;
X    } /* end of switch (c) statement */
X  }   /* end of while(done ==0) loop */
X  
X  delwin(dipw);
X/*  touch_all_wins();
X  refresh();
X */
X  return c;
X}
X
Xchange_dip_status(dm, initial_dm, n1, n2)
X     Sdiplo **dm, **initial_dm;
X     int n1, n2;
X{
X  char cc;
X  int i,               /* for loops... */
X  New_St,              /* input for new status */
X  ind1=0, ind2=0;      /* indices of nations in array... */
X  WINDOW *chng_dipw;
X  
X  chng_dipw = newwin((LINES-3), (COLS/2), 3, (COLS/2));
X  touchwin(chng_dipw);
X  mvwprintw(chng_dipw, 0,3, "NEW STATUS");
X  mvwprintw(chng_dipw, 1,3, "==========");
X  for (i=JIHAD; i<= TREATY; i++) {
X    mvwprintw(chng_dipw, i,3, "[%c]. %s", dip_status[i][0], dip_status[i] );  
X  }      
X  mvwprintw(chng_dipw, i+1, 3, "Enter new status: ");
X  wrefresh(chng_dipw);    /* update the window, always before input */
X/*  wget_number(chng_dipw, &New_St); */
X
X  cc = getch();			/* we want the first char of a status */
X  if (cc > 'Z') {
X    cc -= ('a'-'A');		/* go to upper case */
X  }
X
X  for (New_St = JIHAD; New_St <= TREATY; New_St++) {
X    if (dip_status[New_St][0] == cc)
X      break;
X  }
X  
X/*  New_St++;   /* to compensate for numbers shown on screen */
X  if ((New_St < JIHAD) || (New_St > TREATY)) {
X    mvwprintw(chng_dipw, i+2, 3, "Illegal Input!");
X    mvwprintw(chng_dipw, i+3, 3,"--- hit space to continue ---");
X    wrefresh(chng_dipw);    /* update the window, always before input */
X    get_space();
X  } else if (user.id != 0 && abs(New_St - initial_dm[n1][n2].status) > 2) {
X    mvwprintw(chng_dipw, i+2, 3, "Can't change so much!!");
X    mvwprintw(chng_dipw, i+3, 3,"--- hit space to continue ---");
X    wrefresh(chng_dipw);    /* update the window, always before input */
X    get_space();
X  } else {
X    /* make the change in status!!! */
X    while(n1 != dm[ind1++][0].self_id)
X      ;
X    ind1--;
X    while(n2 != dm[ind1][ind2++].neighbor_id)
X      ;
X    ind2--;
X    dm[ind1][ind2].status = New_St;
X
X    mvwprintw(chng_dipw, i+2, 3, "The change has been made.");
X    mvwprintw(chng_dipw, i+3, 3,"--- hit space to continue ---");
X    wrefresh(chng_dipw);    /* update the window, always before input */
X    get_space();
X  }
X
X  wrefresh(chng_dipw);     /* update the window, always before input */
X  
X  delwin(chng_dipw);
X/*  touch_all_wins();
X  refresh();
X */
X}
X
END_OF_FILE
if test 8211 -ne `wc -c <'diplomacy.c'`; then
    echo shar: \"'diplomacy.c'\" unpacked with wrong size!
fi
# end of 'diplomacy.c'
fi
if test -f 'mail.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mail.c'\"
else
echo shar: Extracting \"'mail.c'\" \(8487 characters\)
sed "s/^X//" >'mail.c' <<'END_OF_FILE'
X  /* mail.c -- dominion mail system */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include <stdio.h>
X#ifdef AMIGA
X# include <exec/types.h>
X# include <string.h>
X#else
X# include <sys/types.h>
X#endif
X
X#include <time.h>
X#ifdef SYSV
X# include <string.h>
X#else
X# include <strings.h>
X#endif
X
Xextern Suser user;
Xextern Sworld world;
Xextern char *libdir;
Xextern int ruid, euid;
Xextern char *get_char_option();
X
Xchar *mail_forwarding(nation)
X     int nation;
X{
X  return get_char_option(nation,"MAIL_FORWARD");
X}
X
X  /* This function checks if mailbox for nation 'id' is locked. */
Xhas_mail_lock(id)
X     int id;
X{
X  FILE *lock_fp;
X  char lock_fn[PATHLEN];
X  int ret;
X
X/*  ruid = getuid();
X  euid = geteuid();
X*/
X  if (mail_forwarding(id))
X      return 0;
X
X  sprintf(lock_fn,"%s/%d.lock", MAIL_DIR, id);
X    /* if it's locked: close and return 1 */
X  if ((lock_fp = fopen(lock_fn, "r")) != NULL) {
X    fclose(lock_fp);
X    ret=1;
X  } else {
X    ret=0;
X  }
X  return(ret);
X} /* has_mail_lock */
X
X  /* This function locks a user's mailbox */
Xlock_mail(nation)
Xint nation;
X{
X  FILE *lock_fp;
X  char lock_fn[100];
X  
X  if (mail_forwarding(nation))
X      return;
X
X  sprintf(lock_fn, "%s/%d.lock", MAIL_DIR, nation);
X  if ((lock_fp = fopen(lock_fn, "w")) != NULL) {
X      fprintf(lock_fp, "%ld; Nation %s\n", time(0L), user.np->name);
X      fclose(lock_fp);
X    }
X}
X
X  /* This unlock's a user's mailbox */
Xunlock_mail(nation)
Xint nation;
X{
X  char lock_fn[100];
X  
X  if (mail_forwarding(nation))
X      return;
X
X  sprintf(lock_fn, "%s/%d.lock", MAIL_DIR, nation);
X  unlink(lock_fn);
X}
X
X  /* This calls the system to edit the given file with the preferred editor */
Xvoid edit(t_fn)
X     char *t_fn;
X{
X  int tmp;
X  char *edit_prog, *getenv();
X  char edit_command[200], command[200];
X
X  if ((edit_prog=getenv("DOMINION_EDITOR"))==NULL
X      && (edit_prog = getenv("VISUAL")) == NULL
X      && (edit_prog = getenv("EDITOR")) == NULL) {
X      edit_prog = DEFAULT_EDITOR;
X    }
X#ifdef UID_SECURITY
X    /* we must fork, so that in the child we set the
X       real user id, whereas the parent continues with
X       the effective user id.
X     */
X  if (fork() == 0) {		/* child has fork() == 0 */
X    setuid(ruid);		/* so this user cannot poke around */
X    close(creat(t_fn, 0600));
X    sprintf(edit_command, "%s %s", edit_prog, t_fn);
X    system(edit_command);
X    /* change owner so that it can be processed once the uid changes back */
X/*
X    sprintf(command, "chown %d %s", euid, t_fn);
X    system(command);
X*/
X    chown(t_fn, euid, getgid()); /* use the system call to chown() */
X/*
X    printf("waiting; type a few returns\n");
X    fflush(stdout);
X    getchar();
X    getchar();
X*/
X    exit(0);
X  }
X  wait(0);
X#else /* UID_SECURITY */
X  creat(t_fn, 0666);
X  sprintf(command, "chmod 666 %s", t_fn);
X  system(command);
X  sprintf(edit_command, "%s %s", edit_prog, t_fn);
X  system(edit_command);
X#endif /* UID_SECURITY */
X}
X
X/* Insert a file (with the name in_name) into the open file stream pointed
X   to by out_pntr */
Xvoid insert(in_name, out_pntr)
X     char *in_name;
X     FILE *out_pntr;
X{
X  FILE *in_pntr;
X  int c;
X
X  if ((in_pntr=fopen(in_name, "r"))!=NULL)
X    {
X      while((c=fgetc(in_pntr))!=EOF)
X	fputc(c, out_pntr);
X      fclose(in_pntr);
X    }
X} /* insert */
X
X
Xchar *fix_name(s,fixed)
X/* Elm and etc. want the name that mail is from to contain no white space */
Xchar *s,*fixed;
X{
X  char *poss = s, *posf = fixed;
X
X  if (s == NULL) { return NULL; }
X  for ( poss = s;(poss != '\0') && (posf - fixed < NAMELEN);  poss++ , posf++)
X  {
X    if ((*poss == ' ') || (*poss == '\t'))
X    {
X      *posf = '_';
X    } else
X    {
X      *posf = *poss;
X    }
X  }
X  if (posf - fixed < NAMELEN) { *posf = '\0' ; }
X  else { *(fixed + NAMELEN - 1) = '\0'; }
X  return fixed;
X}
X/* Send mail from one nation to another. mailfile is the _name_ of the
X   file containing the body of the mail. sender and receiver are the full
X   names of the appropriate nations. Guess what subject is... */
X
Xint mail_send(mailfile, sender, receiver, subject)
X     char mailfile[];
X     int sender, receiver;
X     char subject[];
X{
X  time_t now_secs;
X  char lock_fn[200], dest_fn[200], tmp_fname[PATHLEN], *now_chars;
X  FILE *lock_fp, *dest_fp, *temp_fp;
X  char s_name[NAMELEN], r_name[NAMELEN];
X  int temp;
X  char *forward, fixed_name[NAMELEN];
X
X  if ((forward = get_char_option(receiver,"MAIL_FORWARD")) != NULL) {
X      char command[2048];
X#ifdef UID_SECURITY
X      int pid;
X#endif
X
X      strcpy(tmp_fname, "/usr/tmp/domXXXXXX");
X      mktemp(tmp_fname);
X      temp_fp = fopen(tmp_fname, "w");
X      if (!temp_fp) {
X	  perror("Could not open temp file");
X	  return 1;
X      }
X      fprintf(temp_fp,"From: %s of %s\n",world.nations[sender].leader,
X	      world.nations[sender].name);
X      fprintf(temp_fp,"To: %s of %s\n",world.nations[receiver].leader,
X	      world.nations[receiver].name);
X      fprintf(temp_fp,"Subject: %s\n\n",subject);
X      fclose(temp_fp);
X
X#ifdef UID_SECURITY
X      sprintf(command, "chmod +r %s", tmp_fname);
X      system(command);
X#endif
X
X      sprintf(command, "cat %s %s | %s '%s'", tmp_fname, mailfile,
X                          MAILER, forward);
X
X/*
X      printf("\r\n ready to run the cat command; type some returns \r\n");
X      fflush(stdout);
X      getchar();
X      getchar();
X*/
X      system(command);
X#ifdef CONFUSED_UID
X#ifdef UID_SECURITY
X      /* we must fork, so that in the child we set the
X	 real user id, whereas the parent continues with
X	 the effective user id.
X       */
X
X      if ((pid=fork()) == 0) {		/* child has fork() == 0 */
X	  setuid(getuid());		/* so this user cannot poke around */
X#endif
X	  system(command);
X#ifdef UID_SECURITY
X	  exit(0);
X      }
X/*      else if (pid < 0)
X	  perror("Could not fork mailer");
X      else
X	  while (wait(0) != pid);
X*/
X      wait(0);
X#endif /* UID_SECURITY */
X#endif /* CONFUSED_UID */
X
X      unlink(tmp_fname);
X      return 0;			/* we've forwarded, so that's all */
X  }
X
X  /* Set the names of the files used in mail */
X  sprintf(dest_fn, "%s/mail.%d", MAIL_DIR, receiver);
X
X/*  sprintf(lock_fn, "%d.lock", receiver); */
X  strcpy(tmp_fname, "dommaXXXXXX");
X  mktemp(tmp_fname);
X
X    /* Get the time right now */
X  now_secs=time(0L);
X  now_chars=ctime(&now_secs);
X
X    /* If not make sure it won't be used */
X/*  lock_fp=fopen(lock_fn, "w");
X  fprintf(lock_fp, "Mail being sent by %s at %s\n", user.np->name, now_chars);
X  fclose(lock_fp);
X*/
X
X    /* Copy the mail that's there right now out */
X  if ((temp_fp = fopen(tmp_fname, "w")) == NULL) { 
X    fprintf(stderr,"Error: Cannot write to mail file %s\n",tmp_fname);
X    clean_exit();
X    exit(1);
X  }
X  insert(dest_fn, temp_fp);
X  fclose(temp_fp);
X    /* Put in the new mail */
X  if ((dest_fp=fopen(dest_fn, "w"))!=NULL) {
X       /* Some header stuff */
X      fix_name(world.nations[sender].leader, fixed_name);
X      fprintf(dest_fp, "From %s %s", fixed_name,now_chars);
X      fprintf(dest_fp, "Date: %s", now_chars);
X      fprintf(dest_fp, "From: %s of %s\n", world.nations[sender].leader,
X	      world.nations[sender].name);
X      fprintf(dest_fp, "To: %s of %s\n", world.nations[receiver].leader,
X	      world.nations[receiver].name);
X      fprintf(dest_fp, "Subject: %s\n\n", subject);
X
X        /* Now the body of the message */
X      insert(mailfile, dest_fp);
X      fprintf(dest_fp, "\n");
X        /* and now copy the old mail back in */
X      insert(tmp_fname, dest_fp);
X      fclose(dest_fp);
X    } /* if fopen dest_fp */
X  else {
X    if (sender==0) {
X      fprintf(stderr, "Couldn't open dest_fn\n");
X    }
X  }
X    /* Remove the old unnecessary files */
X  unlink(tmp_fname);
X  unlink(mailfile);
X/*  unlink(lock_fn); */
X  unlock_mail(receiver);
X  return(0);
X} /* mail_send */
X
END_OF_FILE
if test 8487 -ne `wc -c <'mail.c'`; then
    echo shar: \"'mail.c'\" unpacked with wrong size!
fi
# end of 'mail.c'
fi
if test -f 'misc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc.h'\"
else
echo shar: Extracting \"'misc.h'\" \(8037 characters\)
sed "s/^X//" >'misc.h' <<'END_OF_FILE'
X /* misc.h - various definitions used in dominion */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X  /* get the control char corresponding to the *upper case*
X     char c.  Note:  will probably only work for ascii.
X   */
X#define CTL(c) (c - 'A' + 1)
X  /* the DELETE key */
X#define DEL ((char) 0x7F)
X
X#ifdef BSD
X# define SRND(x) srandom(x)
X# define RND() random()
X# define strchr(a, b) index(a, b)
X#endif BSD
X
X#ifdef SYSV
X# define SRND(x) srand48(x)
X# define RND() lrand48()
X#endif SYSV
X
X/* Figuring in cur_ stuff. */
X#define cur_expend(np) (((np->cur_tech_r_d + np->cur_mag_r_d + np->cur_spy_r_d) * np->money) / 100)
X#define cur_expend_metal(np) ((np->cur_tech_r_d_metal * np->metal) / 100)
X#define cur_expend_jewels(np) ((np->cur_mag_r_d_jewels * np->jewels) / 100)
X
X#define next_thon_money(np) ((np->money - cur_expend(np)) + (calc_revenue(np) - calc_expend(np)))
X#define next_thon_metal(np) ((np->metal - cur_expend_metal(np)) + (calc_metal (np) - calc_expend_metal(np)))
X#define next_thon_jewels(np) ((np->jewels - cur_expend_jewels(np)) + (calc_jewels (np) - calc_expend_jewels(np)))
X
X  /* the number of good workers in a sector */
X/* #define n_workers(sp) (min(sp->n_people, (world.nations[sp->owner].race.repro*desig_map[sp->designation].max_employed)/10)) */
X
X#define SALT ".."
X
X  /* sector flags */
X#define SF_BUBBLE 0x01		/* a bubble has been built */
X#define SF_QUARANTINE 0x02	/* people cannot migrate */
X#define SF_HIDDEN 0x04		/* sector is cloaked */
X#define SF_TRADED 0x08		/* sector has been traded */
X#define SF_IMPENETRABLE 0x10	/* sector is impenetrable */
X#define SF_HOSTILE 0x20	        /* sector is hostile */
X
X  /* routines that check sector flags */
X#define has_bubble(sp) (sp->flags & SF_BUBBLE)
X#define has_quarantine(sp) (sp->flags & SF_QUARANTINE)
X#define has_hidden(sp) (sp->flags & SF_HIDDEN)
X#define has_traded(sp) (sp->flags & SF_TRADED)
X#define has_impenetrable(sp) (sp->flags & SF_IMPENETRABLE)
X#define has_hostile(sp) (sp->flags & SF_HOSTILE)
X
X  /* this is to hide the absolute coordinates from a user */
X/* #define xrel(a) (user.nation.id == 0 ? a : a - user.nation.capital.x)
X#define yrel(b) (user.nation.id == 0 ? b : b - user.nation.capital.y)
X*/
X  /* definitions for sector visibility:  this is a bit-field */
X#define SEE_NOTHING    0x00	/* not on your map at all */
X#define SEE_LAND_WATER 0x01	/* see if it is land or water */
X#define SEE_OWNER      0x02
X#define SEE_DESIG      0x04
X#define SEE_POPULATION 0x08
X#define SEE_RESOURCES  0x10	/* see what metal etc... are there */
X#define SEE_ARMIES     0x20
X#define SEE_ALL        0xff	/* see everything (all bits set) */
X
X                                /* Terrains */
X#define MIN_TERRAIN  -5
X#define JUNGLE        6
X#define FOREST        5         /* Terrain describes how the land looks to */
X#define BRUSH         4         /* the creatures on or around it. */
X#define GRASSLANDS    3
X#define SWAMP         2
X#define BARREN        1
X#define ICE           0
X#define RIVER        -1
X#define LAKE         -2
X#define REEF         -3
X#define BAY          -4
X#define OCEAN        -5
X                                /* Altitudes by */
X#define MOUNTAIN_PEAK 6         
X#define MOUNTAINS     5         /* Altitudes describe the height or depth of */
X#define PLATEAU       4         /* the land on the specified sector. */
X#define HILLS         3         
X#define PLAINS        2         
X#define LOWLANDS      1         
X#define SEA_LEVEL     0         
X#define SHALLOWS     -1
X#define CONT_SHELF   -2
X#define SEA_MOUNT    -3
X#define OCEAN_PLAINS -4
X#define TRENCH       -5
X
X  /* possible sector designations */
X#define D_NODESIG     0		/* designations */
X/*#define D_RUIN        1 */
X#define D_FARM        1
X#define D_METAL_MINE  2
X#define D_JEWEL_MINE  3
X#define D_CITY        4		/* can draft and build; heavy tax */
X#define D_CAPITAL     5		/* nation's capital; even more tax */
X#define D_UNIVERSITY  6		/* increase intelligence (costs to maintain) */
X#define D_TEMPLE      7		/* religion: + morale */
X#define D_STADIUM     8		/* entertainment: + morale */
X#define D_TRADE_POST  9		/* in foreign land: allows trade */
X#define D_EMBASSY    10		/* in foreign land: allows diplo */
X#define D_FORT       11		/* must have a garrison */
X#define D_HOSPITAL   12		/* decrease death rate (costs to maintain) */
X#define D_REFINERY   13		/* put next to a mine, > production */
X#define D_MAX_DESIG  D_REFINERY+1 /* the biggest designation number + 1 */
X/* #define D_MAX_DESIG (sizeof(desig_map)/sizeof(s_desig_map)) */
X#define FORT_BONUS_INCREASE 3	/* how much bonus for passing time in forts */
X
X  /* army_type is used for the general description of
X     armies, and is loaded at the beginning of a session
X     from the file ("army_types")
X   */
Xstruct army_type {
X  char type[NAMELEN];		/* such as "Infantry" */
X  char type_char;		/* could be 'i' for Infantry */
X  float move_factor;		/* multiplies the nation's basic move rate */
X    /* should we have separate attack and defense bonus? */
X  int bonus;			/* added to nation's basic bonus */
X    /* the following describe how much it costs to draft a
X       SINGLE soldier of this type, and maintain it, except in
X       the case of spell points, where it is the price for the
X       ENTIRE army.
X     */
X  int money_draft, metal_draft, jewel_draft;
X  int money_maint, metal_maint, jewel_maint, spell_pts_maint;
X  int flags;			/* permanent flags */
X  char draft_places [NAMELEN];
X};
X
X  /* spirit_type is used for the general description of
X     armies, and is loaded at the beginning of a session
X     from the file ("spirit_types")
X   */
Xstruct spirit_type {
X  char type[NAMELEN];		/* such as "eagle" */
X  char type_char;		/* could be 'E' for eagle */
X  int size;			/* how many "men" */
X  float move_factor;		/* multiplies the nation's basic move rate */
X    /* should we have separate attack and defense bonus? */
X  int bonus;			/* added to nation's basic bonus */
X    /* the following describe how much it costs to draft a
X       SINGLE soldier of this type, and maintain it, except in
X       the case of spell points, where it is the price for the
X       ENTIRE army.  The "flags" field is for permanenty army-type
X       flags.
X     */
X  int spell_pts_draft, jewel_draft, jewel_maint;
X  int flags;
X};
X
X  /* this describes the various types of designation, that their mark
X     is, their name, and how much it costs to redesignate to that.  in
X     future we might put a general description of designations, and
X     also a per-turn cost.
X   */
Xstruct s_desig_map {
X  char mark;
X  char *name;
X  int price;			/* how much it costs to redesignate */
X  int revenue;			/* per capita revenue in sector */
X  int min_employed;		/* how many you need to function */
X  int max_employed;		/* how many can be gainfully employed? */
X};
X
Xstruct s_altitude_map {
X  char mark;
X  char *name;
X  int value;
X};
X
Xstruct army_flags {
X  char flag;
X  char description [EXECLEN];
X};
X
X  /* diplomacy statuses */
X#define SELF          0
X#define UNMET         1
X#define JIHAD         2
X#define WAR           3
X#define HOSTILE       4
X#define UNRECOGNIZED  5
X#define NEUTRAL       6
X#define RECOGNIZED    7
X#define FRIENDLY      8
X#define ALLIED        9
X#define TREATY        10
X
Xstruct item_map { char mark; char *name; }; /* for many things */
END_OF_FILE
if test 8037 -ne `wc -c <'misc.h'`; then
    echo shar: \"'misc.h'\" unpacked with wrong size!
fi
# end of 'misc.h'
fi
if test -f 'spy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spy.c'\"
else
echo shar: Extracting \"'spy.c'\" \(8899 characters\)
sed "s/^X//" >'spy.c' <<'END_OF_FILE'
X  /* spy.c -- things having to do with "other" nations and espionage */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include <stdio.h>
X#include <ctype.h>
X#include <math.h>
X
X  /* these macros represent the difficulty in gathering
X     inteligence in various areas.
X   */
X#define SPY_POP 1
X#define SPY_ECO 3
X#define SPY_MAG 4
X#define SPY_MIL 5
X#define SPY_TECHNO 5
X#define SPY_CAP 6
X
Xextern Sworld world;
Xextern Suser user;
Xextern char help_tag[];
X
X  /* info on all nations in the world */
Xchar nations_report()
X{
X  WINDOW *w;
X  FILE *diplock;
X  char s[200];
X  Snation *np;
X  char c;
X  int i, done = 0, first_shown, n_shown, id;
X
X  w = newwin(LINES-2, COLS, 0, 0); /* full screen */
X  werase(w);
X  touchwin(w);
X  sprintf(s, "report on all nations");
X  wmove(w, 0, (COLS-strlen(s))/2); /* make the string centered */
X  wstandout(w);
X  waddstr(w, s);
X  wclrtoeol(w);
X  wstandend(w);
X
X    /* here go the guts */
X  sprintf(s,"World size is: %dx%d, there are %d nations",
X	    world.xmax, world.ymax, world.n_nations);
X  wmove(w, 1, (COLS-strlen(s))/2); /* make the string centered */
X  waddstr(w, s);
X  mvwaddstr(w, 3, 0, " id");
X  mvwaddstr(w, 4, 0, "---");
X  mvwaddstr(w, 3, 5, "nation");
X  mvwaddstr(w, 4, 5, "------");
X  mvwaddstr(w, 3, 25, "mark");
X  mvwaddstr(w, 4, 25, "----");
X  mvwaddstr(w, 3, 31, "leader");
X  mvwaddstr(w, 4, 31, "------");
X  mvwaddstr(w, 3, 47, "race");
X  mvwaddstr(w, 4, 47, "----");
X  if (user.id == 0) {
X    mvwaddstr(w, 3, 55, "money");
X    mvwaddstr(w, 4, 55, "-----");
X    mvwaddstr(w, 3, 65, "civil");
X    mvwaddstr(w, 4, 65, "-----");
X  }
X    /* figure out which nations to show */
X  first_shown = 1;
X  n_shown = min(world.n_nations, LINES-10);
X  while (!done) {
X    strcpy(help_tag, "Nations Report");
X    for (i = 0; i < n_shown && i+first_shown < world.n_nations; ++i) {
X      np = &(world.nations[i+first_shown]);
X      mvwprintw(w, i+5, 0, "%3d", np->id);
X      wclrtoeol(w);
X      mvwaddstr(w, i+5, 5, np->name);
X      mvwaddch(w, i+5, 26, np->mark);
X      sprintf(s,"%-12.12s",np->leader);
X      mvwaddstr(w, i+5, 31, s);
X
X      mvwaddstr(w, i+5, 47, np->race.name);
X
X      if (!is_active_ntn(np)) {
X	mvwaddstr(w, i+5, 60, "DESTROYED");
X      } else if (user.id == 0) {
X	mvwprintw(w, i+5, 55, "%d", np->money);
X	mvwprintw(w, i+5, 65, "%d", get_n_civil(np));
X      }
X      if (np->npc_flag) {
X	mvwaddstr(w, i+5, 75, "npc");
X      }
X    }
X    wclrtobot(w);
X    mvwaddstr(w, LINES-4, 4,
X   "Options: [s]py on a nation, [<]/[,] previous screen, [>]/[.] next screen");
X    mvwaddstr(w, LINES-3, 4,
X	      "Reports: [b]udget, [p]roduction, [i]nfo, [d]iplomacy");
X    wrefresh(w);
X    statline("type space when done, or F to dump to a file", "nations_report");
X
X    switch (c = getch()) {
X    case '>':
X    case '.':
X      if (first_shown+n_shown < world.n_nations) {
X	first_shown += n_shown;
X      }
X      break;
X    case '<':
X    case ',':
X      if (first_shown > 1) {
X	first_shown -= n_shown;
X      }
X      break;
X    case 's':
X      mvwaddstr(w, LINES-3, 4, "  Number of nation to spy on? ");
X      wclrtoeol(w);
X      if (wget_number(w, &id) > 0 && is_active_ntn(&world.nations[id])
X	  && id != user.np->id) {
X	if (user.id == 0) {	/* for the game master, give the total info */
X	  (void) info_report(&world.nations[id]);
X	} else {
X	  spy_report(id);
X	}
X	touchwin(w);
X      }
X      break;
X    case 'F':
X      dump_current_screen(w, "nations_report");
X      break;
X    case ' ':
X    case 'b':
X    case 'p':
X    case 'i':
X    case 'd':
X      done = 1;
X      break;
X    case '?':
X      online_info();
X      break;
X    default:
X      break;
X    }
X  }
X  delwin(w);
X  return c;
X}
X
X  /* allow a nation to spy on anther */
Xspy_report(id)
X     int id;
X{
X  WINDOW *spyw;
X  Snation *spied_np = &world.nations[id], *spying_np = user.np;
X  char s[EXECLEN];
X  char c;
X  int done = 0, bribe;		/* amount of jewels to get info */
X  int x, y;			/* for capital locations */
X
X  strcpy(help_tag, "Nations Report");
X  spyw = newwin(18, 60, LINES-22, (COLS-60)/2);
X  werase(spyw);
X  touchwin(spyw);
X  while (!done) {
X    sprintf(s, "Espionage Report on nation %s", spied_np->name);
X    wmove(spyw, 1, (60-strlen(s))/2);
X    wstandout(spyw);
X    waddstr(spyw, s);
X    wclrtoeol(spyw);
X    wstandend(spyw);
X    /* put the guts between here and the wrefresh() */
X    mvwaddstr(spyw, 3, 5, "Spy on: [p]opulation, [e]conomy");
X    mvwaddstr(spyw, 4, 5, "        [m]ilitary, ma[g]ic, [C]apital location");
X    mvwaddstr(spyw, 5, 5, "        [t]echology, [T]echnology theft");
X    wclrtobot(spyw);
X    box(spyw, '|', '-');
X    wrefresh(spyw);
X    statline("type space when done, or F to dump to a file", "spy_report");
X    c = getch();
X    if (strchr("pemgCt", c) != NULL) {
X      mvwaddstr(spyw, 10, 1,
X		"How many jewels do you want to pay in bribes? ");
X      if (wget_number(spyw, &bribe) < 1 || bribe <= 0) {
X	continue;
X      }
X      if (bribe > spying_np->jewels) {
X	statline2_err("Hit space", "You don't have enough jewels");
X	continue;
X      }
X    }
X    switch (c) {
X    case '?':
X      online_info();
X      break;
X    case ' ':
X      done = 1;
X      break;
X    case 'p':			/* info on their population */
X      mvwprintw(spyw, 12, 6, "Population is %d",
X		spy_figure(get_n_civil(spied_np), bribe,
X		spying_np, spied_np, SPY_POP) );
X      break;
X    case 'e':			/* info on their military */
X      mvwprintw(spyw, 12, 4, "Money: %d",
X		spy_figure(spied_np->money, bribe,
X		spying_np, spied_np, SPY_ECO) );
X      mvwprintw(spyw, 12, 20, "Jewels: %d",
X		spy_figure(spied_np->jewels, bribe,
X		spying_np, spied_np, SPY_ECO) );
X      mvwprintw(spyw, 12, 36, "Metal: %d",
X		spy_figure(spied_np->metal, bribe,
X		spying_np, spied_np, SPY_ECO) );
X      mvwprintw(spyw, 13, 4, "Food: %d",
X		spy_figure(spied_np->food, bribe,
X		spying_np, spied_np, SPY_ECO) );
X      mvwprintw(spyw, 13, 20, "Tax: %d",
X		spy_figure(spied_np->taxes, bribe,
X		spying_np, spied_np, SPY_ECO) );
X      break;
X    case 'C':
X      x = spy_figure(spied_np->capital.x, bribe, spying_np, spied_np, SPY_CAP);
X      y = spy_figure(spied_np->capital.y, bribe, spying_np, spied_np, SPY_CAP);
X      x = xrel(x, y, spying_np->capital);
X      y = yrel(x, y, spying_np->capital);
X      mvwprintw(spyw, 13, 4, "Capital is at (%d, %d) ", x, y);
X      break;
X    case 't':			/* info on their technology */
X      mvwprintw(spyw, 12, 4, "Techno skill: %d",
X		spy_figure(spied_np->tech_skill, bribe,
X		spying_np, spied_np, SPY_TECHNO) );
X      break;
X    case 'm':			/* info on their military */
X      mvwprintw(spyw, 12, 4, "Soldiers: %d",
X		spy_figure(get_n_soldiers(spied_np), bribe,
X		spying_np, spied_np, SPY_MIL) );
X      break;
X    case 'g':			/* info on their magic */
X      mvwprintw(spyw, 12, 4, "Magic skill: %d",
X		spy_figure(spied_np->mag_skill, bribe,
X		spying_np, spied_np, SPY_MAG) );
X      mvwprintw(spyw, 13, 4, "Spell pts.: %d",
X		spy_figure(spied_np->spell_pts, bribe,
X		spying_np, spied_np, SPY_MAG) );
X      break;
X    }
X        /* this section is common to all bribes */
X    if (strchr("pemgCt", c) != NULL) {
X      mvwaddstr(spyw, 14, 10, "Hit space");
X      wrefresh(spyw);
X      get_space();
X      spying_np->jewels -= bribe;
X      cjewels(spying_np, -bribe);
X    }
X  }
X  delwin(spyw);
X}
X
Xspy_figure(n, expend, spying_np, spied_np, cost_fact)
X     int n,			/* number we modify here */
X       expend;			/* jewels spent on bribes */
X     Snation *spying_np, *spied_np; /* nations involved */
X     int cost_fact;		/* cost factor for type of info */
X{
X  double accuracy, error;
X  int figure;			/* the figure we actually return */
X  char s[400];
X
X  if (spied_np->secrecy == 0) {
X    spied_np->secrecy = 1;	/* avoid divide-by-zero */
X  }
X  accuracy =
X    ((double) expend*spying_np->spy)/(cost_fact*spied_np->secrecy*100);
X  
X    /* now get the percent error */
X  error = 100*( exp(-sqrt(accuracy)) + 1.0/(5.0+accuracy) );
X  if (error > 100) {
X    error = 100;
X  }
X/*  sprintf(s, "acc=%f,%%err=%f", accuracy, error); */
X    /* now get the absolute error */
X  error = 1 + n*error/100.0;
X  figure = n + (RND() % ((int) error)) - (int) (error/2);
X
X/*  statline2(s, ""); */
X
X  return figure;
X}
END_OF_FILE
if test 8899 -ne `wc -c <'spy.c'`; then
    echo shar: \"'spy.c'\" unpacked with wrong size!
fi
# end of 'spy.c'
fi
if test -f 'user.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user.c'\"
else
echo shar: Extracting \"'user.c'\" \(10194 characters\)
sed "s/^X//" >'user.c' <<'END_OF_FILE'
X/* user.c -- stuff relating to the "current user" */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include <stdio.h>
X#ifdef SYSV
X# include <string.h>
X#else
X# include <strings.h>
X#endif /* SYSV */
X#include <time.h>
X
X#include "dominion.h"
X#include "misc.h"
X
Xextern Suser user;
Xextern Sworld world;
Xextern int debug;
Xextern int (*wrapx)(), (*wrapy)();
Xextern int viewall;
Xextern double get_version(),atof();
Xextern char *update_time, *get_update_time(), *mail_forwarding(),*civ_move[];
X
Xvoid usageerr(argc, argv)
Xint argc;
Xchar *argv[]; 
X{
X  fprintf(stderr, "usage: %s -[n nation] [-d dir] [-x] [-h] [-p] [-c]\n", argv[0]);
X}
X
X  /* initializes the user's data structure, and does
X     other tasks concerned with loading up the game
X   */
Xinit_user(innation, nation)
X     int innation;		/* do we have a nation name already? */
X     char nation[];		/* pre-entered nation name */
X{
X  char passwd[NAMELEN];
X  char *s, *getpass(), *crypt();
X  int c;
X  char syscmd[NAMELEN];
X  int i;
X  Sdiplo **allocate_diplo();
X
X  printf("initializing user...\r\n");
X  load_army_types();
X  load_spirit_types();
X    /* in case the master changed your password */
X  load_master_execs();
X  if (!innation)
X    {
X      printf("which nation would you like to play? ");
X      getline(nation, NAMELEN);
X    }
X  if ((user.id = get_nation_id(nation)) == -1) {
X    printf ("\r\nnation does not exist, sorry\r\n");
X    clean_exit ();
X    exit (1);
X  }
X  get_crypt_pass("Your nation's password: ", passwd, NULL, NULL);
X  if (strcmp(world.nations[user.id].passwd, passwd)) {
X    printf("\r\nTry again\r\n");
X    get_crypt_pass("Your nation's password: ", passwd, NULL, NULL);
X    user.id = get_nation_id(nation);
X    if (strcmp(world.nations[user.id].passwd, passwd)) {
X      printf("\r\nwrong password, sorry\r\n");
X      clean_exit();
X      exit(1);
X    }
X  }
X
X  handle_locks(user.id);
X
X  user.np = &world.nations[user.id];
X
X    /* now check to see if this nation has been destroyed */
X  if (user.np->capital.x == -1 && user.np->capital.y == -1) {
X    if (user.np->id == 0) {	/* nation 0 cannot be destroyed!!! */
X      user.np->capital.x = 0;
X      user.np->capital.y = 0;
X    } else {
X      printf("\r\nYour nation has been destroyed.\n");
X      printf("Ask your Gamemaster for your last mail.\n");
X      clean_exit();
X      exit(0);
X    }
X  }
X    /* find out which army types are available to the user */
X  user.avail_armies = NULL;
X  get_avail_armies(&user, user.np->tech_skill);
X    /* start the user off with all spells s/he deserves.
X       note that, because of spirits, this has to be done
X       before load_nation(), since the spirit list is used
X       in the exec parsing.
X     */
X  user.spell_list = NULL;
X  user.spirit_list = NULL;
X  get_spells(&user, user.np->mag_skill);
X  get_spirits(&user, user.np->mag_skill);
X    /* fundamental step:  load exec file */
X  if (user.id != 0) {		/* gamemaster is already loaded */
X    load_nation(user.id, user.np);
X  } else {
X    load_options(user.np);
X  }
X    /* now set fields for the ustruct */
X  user.cursor = user.center = user.np->capital;
X  user.help_char = '?';
X  user.map_style = NORMAL_MAP;
X  user.display = DESIGNATION;
X  if (user.id != 0) {
X    user.highlight = H_OWNED;
X  } else {			/* for gamemaster, don't highlight */
X    user.highlight = H_NONE;
X  }
X  user.underwater = 0;		/* user is not underwater at start */
X  if (user.np->race.pref_alt < 0) {
X    user.underwater = 1;	/* merfolk or whatever */
X  }
X  user.n_execs = 0;
X  user.current_army =
X    first_sect_army(&world.map[user.cursor.x][user.cursor.y]);
X  user.just_moved = 1;
X  user.last_n_armies = 0;
X    /* super user visibility */
X  if (user.id == 0) {
X    viewall = 1;
X  }
X  user.show_sect_win = 1;
X    /* load user's diplomacy statuses, for fast access later;
X       also remember the initial values, so users cannot change
X       their status by more than one step at a time.
X     */
X  user.diplo_matrix = allocate_diplo(world.n_nations);
X  read_in_diplo(user.diplo_matrix, world.n_nations);
X/* Load removed spells first */
X  load_dead_hspells(&user,0);
X
X    /* load hanging spells, and put them in this user's list */
X  load_h_spells(&user);
X    /* calculate visibility matrix for this user.
X       this might depend on spells, so do it after
X       loading spells.
X     */
X  user.visible_sectors = (int **) malloc(world.xmax*sizeof(int *));
X  for (i = 0; i < world.xmax; ++i) {
X    user.visible_sectors[i] = (int *) malloc(world.ymax*sizeof(int));
X  }
X  find_visible_sectors(user.visible_sectors);
X}
X
X  /* for a fixed army, update its visibility range */
Xarmy_visibility(visible_sectors, ap)
X     int **visible_sectors;
X     Sarmy *ap;
X{
X  int x = ap->pos.x, y = ap->pos.y, i, j;
X  Ssector *sp;
X
X  sp = &world.map[x][y];
X  if (has_hidden(sp) && sp->owner != user.id) {
X    visible_sectors[x][y] = SEE_ARMIES;
X  } else if (sp->owner != user.id) {
X    visible_sectors[x][y] = SEE_ARMIES;
X  } else {
X    visible_sectors[x][y] = SEE_ALL;
X  }
X  for (i = x-ARMY_SIGHT; i <= x+ARMY_SIGHT; ++i) {
X    for (j = y-ARMY_SIGHT; j <= y+ARMY_SIGHT; ++j) {
X      sp = &world.map[(*wrapx)(i,j)][(*wrapy)(i,j)];
X      if (has_hidden(sp) && sp->owner != user.id) {
X	/* if sect. is hidden, we don't see it */
X      } else {
X	visible_sectors[(*wrapx)(i,j)][(*wrapy)(i,j)] |=
X	  (SEE_LAND_WATER | SEE_OWNER | SEE_DESIG |
X	   SEE_POPULATION | SEE_ARMIES);
X      }
X      if (world.map[(*wrapx)(i,j)][(*wrapy)(i,j)].owner == 0) {
X	visible_sectors[(*wrapx)(i,j)][(*wrapy)(i,j)] |= SEE_RESOURCES;
X      }
X    }
X  }
X}
X
X  /* this allows a user to set her/his options */
Xoptions()
X{
X  WINDOW *optw;
X  char c;
X  int done = 0;
X  char *forwarding = mail_forwarding(user.id);
X
X  optw = newwin(8, 50, 5, 10);
X  while (!done) {
X    mvwprintw(optw, 1, 2, "[x]: toggle expert mode (%s)",
X	      user.np->opts->expert_mode ? "on" : "off");
X    wclrtoeol(optw);
X
X    if (user.np->opts->mail_forward) {
X      mvwprintw(optw, 2, 2, "[f]: Change mail forwarding (\"%s\")",
X                   user.np->opts->mail_forward);
X    } else {
X      mvwprintw(optw, 2, 2, "[f]: Change mail forwarding (none)");
X    }
X    wclrtoeol(optw);
X    mvwprintw(optw, 3, 2, "[c]: Toggle civilian movement (%s)",
X                     civ_move[user.np->opts->civ_movemode]);
X    wclrtoeol(optw);
X    if (user.np->opts->mail_reader) {
X      mvwprintw(optw, 4, 2, "[m]: Mail Program (%s)",
X                                   user.np->opts->mail_reader);
X    } else {
X      mvwprintw(optw, 4, 2, "[m]: Mail Program (internal)");
X    }
X    wclrtobot(optw);
X    box(optw, '|', '-');
X    wrefresh(optw);
X    statline("Choose an option, hit space to get back.", "options");
X    switch (c = getch()) {
X    case 'x':
X      user.np->opts->expert_mode = !user.np->opts->expert_mode;
X      user.xmode = user.np->opts->expert_mode;
X      break;
X    case 'f':
X      ask_for_forwarding(optw);
X      break;
X    case 'c':
X        /* cycle through the various migration modes */
X      user.np->opts->civ_movemode = (user.np->opts->civ_movemode + 1) % 3;
X      break;
X    case 'm':
X      ask_for_mail_reader(optw);
X      break;
X    case ' ':
X      done = 1;
X      break;
X    default:
X      break;
X    }
X  }
X  delwin(optw);
X  user.just_moved = 1;
X  save_options(user.np);
X
X  touch_all_wins();
X}
X
Xstatic ask_for_forwarding(win)
X     WINDOW *win;
X{
X  char buf[200];
X
X  mvwprintw(win, 5, 2, "New mail address? (<return> for no forwarding)");
X  mvwprintw(win, 6, 4, "-->");
X  wrefresh(win);
X
X  if (user.np->opts->mail_forward != NULL) {
X    free(user.np->opts->mail_forward);
X    user.np->opts->mail_forward = NULL;
X  }
X  if (wget_string(win, buf,200) != 0) {
X    if ((user.np->opts->mail_forward = (char *)malloc ((strlen(buf) + 1) * 
X          sizeof (char))) == NULL) { mem_error(); }
X    strcpy(user.np->opts->mail_forward, buf);
X  } 
X}
X
Xask_for_mail_reader(win)
X     WINDOW *win;
X{
X  char buf[200];
X
X  if (user.np->opts->mail_reader) { free(user.np->opts->mail_reader); }
X
X  mvwprintw(win, 5, 2, "New mail reader? (<return> for internal mail)");
X  mvwprintw(win, 6, 4, "-->");
X  wrefresh(win);
X
X  if (wget_string(win, buf, 200))  {
X    if ((user.np->opts->mail_reader = (char *)malloc ((strlen(buf) + 1) * 
X          sizeof (char))) == NULL) { mem_error(); }
X    strcpy(user.np->opts->mail_reader, buf);
X  } else {
X    user.np->opts->mail_reader = NULL;
X  }
X}
X
X  /* check if there is a lock file, and handle the situation if there is */
Xhandle_locks(id)
X     int id;
X{
X  FILE *lock_fp, *is_locked();
X  char *timestr;
X  long secs;			/* seconds marked in lock file */
X
X    /* check if there is a master lock file */
X  if (is_master_lock()) {
X    printf("There is a master lock file.  You cannot play right now.\n");
X    clean_exit();
X    exit(1);
X  }
X  if (strcmp(update_time,get_update_time()) != 0)
X  {
X    fprintf(stderr,"Error: Update has occured.  Please restart program \n");
X    clean_exit();
X    exit(0);
X  }
X
X    /* see if there is a lock file for this nation */
X  if (lock_fp = is_locked(id)) {
X    fscanf(lock_fp, "%ld", &secs);
X    fclose(lock_fp);
X    timestr = ctime(&secs);
X    printf("\r\nYour nation is already being played.\n\r");
X    printf("That session seems to have been started at %s", timestr);
X    printf("If that session is no more and you want to play now, type [y] ");
X    if (getchar() != 'y') {
X      printf("OK, then you will have to wait until that session is over\n");
X      clean_exit();
X      exit(1);
X    }
X  }
X    /* set a lock file */
X  set_lock(id);
X}
X
END_OF_FILE
if test 10194 -ne `wc -c <'user.c'`; then
    echo shar: \"'user.c'\" unpacked with wrong size!
fi
# end of 'user.c'
fi
if test -f 'world.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'world.c'\"
else
echo shar: Extracting \"'world.c'\" \(11077 characters\)
sed "s/^X//" >'world.c' <<'END_OF_FILE'
X/* world.c -- function dealing with the world; its use and implementation */
X
X/*
X* Copyright (C) 1990 Free Software Foundation, Inc.
X* Written by the dominion project.
X*
X* This file is part of dominion.
X*
X* dominion is free software; you can redistribute it and/or
X* modify it under the terms of the GNU General Public License as published
X* by the Free Software Foundation; either version 1, or (at your option)
X* any later version.
X*
X* This software is distributed in the hope that it will be useful,
X* but WITHOUT ANY WARRANTY; without even the implied warranty of
X* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X* GNU General Public License for more details.
X*
X* You should have received a copy of the GNU General Public License
X* along with this software; see the file COPYING.  If not, write to
X* the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X*/
X
X/* wrap(pp) - wraps a point to its proper location                        */
X/* latitude(x,y) - returns the latitude of a particular point             */
X/* map_alt(altitude) - maps the altitude value to the correct data entry  */
X/* xrel(x,y) - gives the relative x coordinate from nation's capital      */
X/* yrel(x,y) - gives the relative y coordinate from nation's capital      */
X/* xdist(x,y,x1,y1) - gives the x distance between (x,y) and (x1,y1)      */
X/* ydist(x,y,x1,y1) - gives the y distance between (x,y) and (x1,y1)      */
X/* sect_desire(np,x,y) - gives the desireability value of x,y for nation  */
X/* is_coastal_sect(np,sp,ap) - is this coast (for given nation and army)? */
X/* is_active_ntn(np) - returns 1 if the nation has not been destroyed     */
X/* are_patrols(np, moving_ap, sp) - returns true if moving_ap gets slowed */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X
X#include <stdio.h>
X#include <math.h>
X
Xextern Sworld world;
Xextern Suser user;
Xextern struct s_altitude_map altitude_map[];
Xextern struct s_desig_map desig_map[];
Xextern int (*wrapx)(), (*wrapy)();
X
X/* Wrapping functions are the heart and soul of the world's shape */
X/* these main functions, wrapx and wrapy, choose the proper function for */
X/* the proper shape of the world in question. */
X
X/* This function wraps the entire point */
X
Xwrap(pp)
XPt *pp;
X{
Xpp->x = (*wrapx)(pp->x,pp->y);
Xpp->y = (*wrapy)(pp->x,pp->y);
X}
X
X/* Wrap functions for a TORUS world */
X
Xtorus_wrapx(x,y)  /* produce new value of x, if x is too big or negative */
Xint x,y;
X{
Xif (x >= world.xmax) {
Xreturn x % world.xmax;
X}
Xwhile (x < 0) {
Xx += world.xmax;
X}
Xreturn x;
X}
X
Xtorus_wrapy(x,y)  /* produce new value of y, if y is too big or negative*/
Xint x,y;
X{
Xif (y >= world.ymax) {
Xreturn y % world.ymax;
X}
Xwhile (y < 0) {
Xy += world.ymax;
X}
Xreturn y;
X}
X
X/* Wrap function for a pinched cylinder world */
X
Xpinch_wrapx(x,y)
Xint x,y;
X{
Xreturn pinch_wrapxy(x,y,1);
X}
X
Xpinch_wrapy(x,y)
Xint x,y;
X{
Xreturn pinch_wrapxy(x,y,2);
X}
X
Xpinch_wrapxy(x,y,which) /* if which=1 then return x */
Xint x,y,which;
X{
Xwhile (y < 0) {
Xy = -(y + 1);
Xx = x + (world.xmax / 2);
X}
Xwhile (y >= world.ymax) {
Xy = 2 * world.ymax - (y + 1);
Xx = x + (world.xmax / 2);
X}
Xwhile (x < 0) {
Xx = x + world.xmax;
X}
Xif (x >= world.xmax) {
Xx = x % world.xmax;
X}
Xif (which == 1) {
Xreturn x;
X} else {
Xreturn y;
X}
X}
X
X/* A latitude function for the world which returns a float angle of the */
X/* latitude of the y-coordinate given.  Equator is 0 degrees and the poles */
X/* are 90 degrees (north pole) and negative 90 degrees (south pole) */
X
Xlatitude(x,y)
Xint x,y;
X{
Xfloat angle;
Xswitch(world.geo.topology) {
Xcase TORUS:
Xangle = torus_latitude(y); break;
X}
Xreturn angle;
X}
X
X/* Returns the latitude of a y-coordinate for a pinched cylinder. */
X
Xpinch_latitude(y)
Xint y;
X{
Xfloat eq_dist, angle;
Xeq_dist = y - (world.ymax / 2.0);
Xif (eq_dist < 0) {
Xeq_dist = eq_dist + 1.0;
X}
Xangle = 90.0 * (eq_dist / (world.ymax / 2.0));
Xreturn -(angle);
X}
X
X/* Returns the latitude of a y-coordinate for a torus */
X
Xtorus_latitude(y)
Xint y;
X{
Xfloat eq_dist, angle;
Xeq_dist = y - (world.ymax / 2.0);
Xangle = 90.0 * (eq_dist / (world.ymax / 2.0));
Xreturn angle;
X}
X
Xint map_alt(altitude)
Xint altitude;
X{
Xaltitude -= altitude_map[0].value;
Xreturn altitude;
X}
X
X/* These functions give the coordinates of a sector relative to the user's */
X/* capital.  They differ depending on which type of world you use! */
Xint xrel(x, y, cap)
Xint x, y;
XPt cap;
X{
Xx=xdist(x, y, cap.x, cap.y);
X/*  if (x < 0) {
Xreturn(x + world.xmax);
X} */
Xreturn(x);
X}
X
Xint yrel(x, y, cap)
Xint x,y;
XPt cap;
X{
Xy = ydist(x, y, cap.x, cap.y);
X/*  if (y < 0) {
Xreturn(y + world.ymax);
X} */
Xreturn(y);
X}
X
X/* Functions to return the how far (x,y) is from (x1,y1) */
Xint xdist(x,y,x1,y1)
Xint x,y,x1,y1;
X{
Xswitch (world.geo.topology) {
Xcase TORUS:
Xx = x - x1;
Xif (x <= (0 - world.xmax / 2)) {
Xx += world.xmax;
X}
Xif (x > world.xmax / 2) {
Xx = x - world.xmax;
X}
Xreturn x;
Xbreak;    
X}
X}
X
Xint ydist(x,y,x1,y1)
Xint x,y,x1,y1;
X{
Xswitch (world.geo.topology) {
Xcase TORUS:
Xy = y - y1;
Xif (y <= (0 - world.ymax / 2)) {
Xy += world.ymax;
X}
Xif (y > world.ymax / 2) {
Xy = y - world.ymax;
X}
Xreturn y;
Xbreak;
X}
X}
X
Xpinched_dist(x,y,x1,y1,choice)
Xint x,y,x1,y1,choice;
X{
Xint dx,dy,dx2,dy2;
Xfloat r1,r2;
Xdx = x - x1;
Xdy = y - y1;
Xif (dx > world.xmax / 2) {
Xdx = dx - world.xmax;
X}
Xif (dx <= (0 - world.xmax / 2)) {
Xdx = dx + world.xmax;
X}
X
Xdy2 = y + y1 + 1;
Xif (dy2 > world.ymax) {
Xdy2 = world.ymax * 2 - dy2;
X} else {
Xdy2 = -(dy2);
X}
Xdx2 = x - x1 + world.xmax / 2;
Xif (dx2 >= world.xmax / 2) {
Xdx2 = dx2 - world.xmax;
X}
X
Xr1 = sqrt(dx*dx + dy*dy);
Xr2 = sqrt(dx2*dx2 + dy2*dy2);
Xif (r1 <= r2) {
Xif (choice == 1) {
Xreturn dx;
X} else {
Xreturn dy;
X}
X} else {
Xif (choice == 1) {
Xreturn dx2;
X} else {
Xreturn dy2;
X}
X}
X}
X
X/* Old Sector Desire
Xint sect_desire(np, x, y)
XSnation *np;
Xint x, y;
X{
Xint terrain_d,climate_d,altitude_d,total_d;
X
Xterrain_d = abs(world.map[x][y].terrain - np->race.pref_terrain);
Xclimate_d = abs(world.map[x][y].climate - np->race.pref_climate);
Xaltitude_d = abs(world.map[x][y].altitude - np->race.pref_alt);
Xtotal_d  = max(0,300-(terrain_d*terrain_d)*10);
Xtotal_d += max(0,50-climate_d*3);
Xtotal_d += max(0,300-(altitude_d*altitude_d)*8);
Xtotal_d += world.map[x][y].metal*5;
Xtotal_d += world.map[x][y].soil*4;
Xtotal_d += world.map[x][y].jewels*6;
Xif (world.map[x][y].designation == D_CITY || world.map[x][y].designation == D_CAPITAL) {
Xtotal_d *= 3;
X}
Xreturn total_d;
X}
X*/
X
Xint sect_desire(np, x, y)
XSnation *np;
Xint x, y;
X{
X  int terrain_d,climate_d,altitude_d,total_d;
X
X  terrain_d = abs(world.map[x][y].terrain - np->race.pref_terrain);
X  climate_d = abs(world.map[x][y].climate - np->race.pref_climate);
X  altitude_d = abs(world.map[x][y].altitude - np->race.pref_alt);
X
X  total_d  = max(0,230-(terrain_d*terrain_d)*10);
X  total_d += max(0,250-(climate_d*climate_d)*10);
X  total_d += max(0,250-(altitude_d*altitude_d)*20);
X  if (user.id == world.map[x][y].owner)
X  {
X    switch (world.map[x][y].designation)
X    {
X      case D_FARM: total_d += world.map[x][y].soil * 9; break;
X      case D_METAL_MINE: total_d += world.map[x][y].metal * 11; break;
X      case D_JEWEL_MINE: total_d += world.map[x][y].jewels * 13; break;
X      default:
X      { 
X        total_d += 37;
X        total_d += world.map[x][y].soil;
X        total_d += world.map[x][y].metal;
X        total_d += world.map[x][y].jewels;
X      }
X    }
X  } else
X  {
X    total_d += world.map[x][y].soil * 7;
X    total_d += world.map[x][y].metal * 9;
X    total_d += world.map[x][y].jewels * 11;
X  }
X  return total_d;
X}
X
X/* this function returns true if there is a non-treaty army
X   in patrol/intercept mode in the neighbourhood of the given sector.
X   if none is found, it returns 0.  If the "moving_ap" is NULL,
X   then you ignore the issue of whether moving_ap is in flight.
X */
Xare_patrols(np, moving_ap, sp)
X     Snation *np;
X     Sarmy *moving_ap;
X     Ssector *sp;
X{
X  int found = 0, done = 0, x, y;
X  Sarmy *ap, *get_army();
X  struct armyid *alist;
X
X  if (moving_ap && is_underground(moving_ap)) {
X    return 0;			/* underground armies can't be intercepted */
X  }
X    /* here we check if there are patrol or intercept units around */
X  for (x = sp->loc.x - 1; ((x <= sp->loc.x + 1) && (done == 0)); x++) {
X    for (y = sp->loc.y - 1; ((y <= sp->loc.y + 1) && (done == 0)); y++) {
X      done = 0;
X      if (np->npc_flag
X          || user.visible_sectors[(*wrapx)(x,y)][(*wrapy)(x,y)] & SEE_ARMIES) {
X	alist = world.map[(*wrapx)(x,y)][(*wrapy)(x,y)].alist;
X	while (alist != NULL) {
X	  if (alist->owner == sp->owner) {
X	    ap = get_army(&world.nations[alist->owner],alist->id);
X	    if ( (ap->status == A_PATROL || ap->status == A_INTERCEPT) &&
X	        /* OK, we got an army on intercept or patrol.
X		   now check the issue of flight.
X		 */
X		(!(moving_ap && is_flight(moving_ap)) || is_missiles(ap))
X		/* make sure that we only slow down armies that are
X		   not our own.  In the future, this should
X		   also let TREATY armies pass...
X		 */
X		&& (moving_ap && (ap->owner != moving_ap->owner))
X		&& (get_diplo_status(user.diplo_matrix,
X				    ap->owner, moving_ap->owner != TREATY))) {
X	      alist = NULL;
X	      found = 1;
X	      done = 1;
X	    } else {
X	      alist = alist->next;
X	    }
X	  } else {
X	    alist = alist->next;
X	  }
X	}
X      }
X    }
X  }
X  return found;
X}
X
Xinit_wrap() 
X{
X  int torus_wrapx(), torus_wrapy();
X  switch(world.geo.topology) {
X  case TORUS:
X    wrapx = torus_wrapx;
X    wrapy = torus_wrapy;
X    break;
X  default:
X    printf("What world is this???\n");
X    wrapx = torus_wrapx;
X    wrapy = torus_wrapy;
X    break;
X  }
X}
X
X  /* returns 1 if this is a coastal sector (for that race and army),
X     0 otherwise.  Note that this only applies if the army has the
X     L or W flag, since other armies don't get any benefit from
X     coastal sectors:  they should drown anyway.
X   */
Xis_coastal_sect(np, sp, ap)
X     Snation *np;		/* nation that wants to go there */
X     Ssector *sp;
X     Sarmy *ap;
X{
X  int land, i, j, x, y;
X
X  if (is_land(ap) && is_water(ap)) {
X    return 0;			/* amphibious don't have a coastline */
X  }
X  if (is_land(ap)) {
X    land = 1;
X  } else if (is_water(ap)) {
X    land = 0;
X  } else {			/* coast only applies to L and W flags */
X    return 0;
X  }
X    /* case: we are land army in water; look for land nearby! */
X  if (land && sp->altitude < SEA_LEVEL) {
X    for (i = sp->loc.x-1; i <= sp->loc.x+1; ++i) {
X      for (j = sp->loc.y-1; j <= sp->loc.y+1; ++j) {
X	x = wrapx(i, j);
X	y = wrapy(i, j);
X	if (world.map[x][y].altitude >= SEA_LEVEL) {
X	  return 1;
X	}
X      }
X    }
X    return 0;			/* no shore nearby */
X  }
X    /* case: we are water army on land; look for water nearby! */
X  if (!land && sp->altitude >= SEA_LEVEL) {
X    for (i = sp->loc.x-1; i <= sp->loc.x+1; ++i) {
X      for (j = sp->loc.y-1; j <= sp->loc.y+1; ++j) {
X	x = wrapx(i, j);
X	y = wrapy(i, j);
X	if (world.map[x][y].altitude < SEA_LEVEL) {
X	  return 1;
X	}
X      }
X    }
X    return 0;			/* no shor nearby */
X  }
X}
X
X  /* tells you if a nation has not been destroyed */
Xis_active_ntn(np)
X     Snation *np;
X{
X  if (np->id == 0) {
X    return 1;
X  }
X  if (!(np->capital.x == -1 && np->capital.y == -1)) {
X    return 1;
X  }
X  return 0;
X}
END_OF_FILE
if test 11077 -ne `wc -c <'world.c'`; then
    echo shar: \"'world.c'\" unpacked with wrong size!
fi
# end of 'world.c'
fi
echo shar: End of archive 26 \(of 28\).
cp /dev/null ark26isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Now execute ./do_cat.sh to build doc files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
