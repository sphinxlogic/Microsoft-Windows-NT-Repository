Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i054:  dominion - a multi-player world simulation game, Part18/28
Message-ID: <2457@masterCNA.TEK.COM>
Date: 11 Feb 92 18:26:04 GMT
Sender: news@masterCNA.TEK.COM
Lines: 2341
Approved: billr@saab.CNA.TEK.COM

Submitted-by: rosalia@dirac.physics.sunysb.edu (Mark Galassi)
Posting-number: Volume 13, Issue 54
Archive-name: dominion/Part18
Environment: Unix, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 18 (of 28)."
# Contents:  mag_Master nation.c transport.c
# Wrapped by billr@saab on Tue Feb 11 10:14:56 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'mag_Master' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mag_Master'\"
else
echo shar: Extracting \"'mag_Master'\" \(715 characters\)
sed "s/^X//" >'mag_Master' <<'END_OF_FILE'
X# this file describes magic powers available to magical order of Master,
X# which has all magic available at no cost.
X#
X# the format is:
X# name level cost		(for spirits)
X# name level cost duration	(for spells)
X#
X# where `level' is the magical skill level at which you get the power,
X# and `cost' is the cost in spell points to use the power.
X#
Xsummon_gargoyle 0 0
Xsummon_giant_mole 0 0
Xsummon_umber_hulk 0 0
Xhide_army 0 0 -1
Xhide_sector 0 0 -1
Xcmetal 0 0 -1
Xcjewels 0 0 -1
Xmag_bonus 0 0 -1
Xfly_army 0 0 -1
Xcaltitude 0 0 -1
Xsummon_stone_giant 0 0
Xsummon_earth_elemental 0 0
Xsummon_mountain 0 0
Xsummon_roc 0 0
Xsummon_eagle 0 0
Xsummon_cloud_giant 0 0
Xsummon_wyvern 0 0
Xsummon_areal_serpent 0 0
Xsummon_air_elemental 0 0
END_OF_FILE
if test 715 -ne `wc -c <'mag_Master'`; then
    echo shar: \"'mag_Master'\" unpacked with wrong size!
fi
# end of 'mag_Master'
fi
if test -f 'nation.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nation.c'\"
else
echo shar: Extracting \"'nation.c'\" \(28685 characters\)
sed "s/^X//" >'nation.c' <<'END_OF_FILE'
X/* nation.c -- commands needed to remember changes to a nation;
X               basically a lot of routines to parse the exec file
X */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
Xextern Sworld world;
Xextern int debug;
X#include <stdio.h>
X#include <ctype.h>
X
Xstruct exec_cmd { char name[NAMELEN]; int (*func)(); };
X
Xint cmd_amove(), cmd_astat(), cmd_aflag_set(), cmd_aflag_clear(),
X  cmd_flag_set_sector(), cmd_flag_clear_sector(),
X  cmd_acargo(), cmd_sname(),  cmd_aname(), cmd_charity(),
X  cmd_taxrate(), cmd_desig_sector(), cmd_amake(),
X  cmd_cpeople_sector(), cmd_cowner_sector(), cmd_csoil_sector(),
X  cmd_cmetal_sector(), cmd_cjewels_sector(), cmd_caltitude_sector(),
X  cmd_cmoney(), cmd_cmetal(), cmd_cjewels(),
X  cmd_cur_tech_money (), cmd_cur_mag_money (), cmd_cur_mag_jewels (),
X  cmd_cur_tech_metal (),
X  cmd_cur_spy_money (),
X  cmd_cspell_pts(), cmd_ctech_skill(), cmd_cmag_skill(),
X  cmd_cfood(), cmd_tech_money(), cmd_tech_metal(),
X  cmd_spy_money(),
X  cmd_mag_money(), cmd_mag_jewels(), cmd_cmine(), cmd_cfarm(),
X  cmd_cspeed(), cmd_nation_name(), cmd_nation_leader(), cmd_nation_order(),
X  cmd_nation_mark(), cmd_set_npc(), cmd_clear_npc(), cmd_npc_param(),
X  cmd_ccombat(), cmd_cattack(), cmd_cdefense(), cmd_crepro(), cmd_cmortality(),
X  cmd_cintel(), cmd_cmag_apt(), cmd_cstrength(),
X  cmd_new_army_type(), cmd_aincrease(), cmd_amerge(), cmd_asplit(),
X  cmd_adisband(),
X  cmd_cabonus(), cmd_cfort_sector(), cmd_croads_sector(), cmd_cpass(),
X  cmd_destroy(), cmd_acastle ();
X
Xstatic struct exec_cmd commands[] = {
X  {"AMOVE", cmd_amove} , {"ASTAT", cmd_astat} , {"AMAKE", cmd_amake} ,
X  {"AFLAG_SET", cmd_aflag_set} , {"AFLAG_CLEAR", cmd_aflag_clear} ,
X  {"FLAG_SET_SECTOR", cmd_flag_set_sector} ,
X  {"FLAG_CLEAR_SECTOR", cmd_flag_clear_sector} ,
X  {"ACARGO", cmd_acargo} ,
X  {"SNAME", cmd_sname} , {"ANAME", cmd_aname},
X  {"DESIG_SECTOR", cmd_desig_sector} ,
X  {"CHARITY", cmd_charity} , {"TAXRATE", cmd_taxrate},
X  {"CMONEY", cmd_cmoney} , {"CJEWELS", cmd_cjewels}, {"CMETAL", cmd_cmetal},
X  {"CUR_MAGR&Dmoney", cmd_cur_mag_money},
X  {"CUR_TECHR&Dmoney", cmd_cur_tech_money},
X  {"CUR_TECHR&Dmetal", cmd_cur_tech_metal},
X  {"CUR_MAGR&Djewels", cmd_cur_mag_jewels},
X  {"CUR_SPYR&Dmoney", cmd_cur_spy_money},
X  {"CSPELL_PTS", cmd_cspell_pts}, {"CTECH_SKILL", cmd_ctech_skill} ,
X  {"CMAG_SKILL", cmd_cmag_skill} ,
X  {"CFOOD", cmd_cfood} , {"TECHR&Dmoney", cmd_tech_money} ,
X  {"TECHR&Dmetal", cmd_tech_metal} , {"SPYR&Dmoney", cmd_spy_money} ,
X  {"MAGR&Dmoney" , cmd_mag_money} , {"MAGR&Djewels" , cmd_mag_jewels} ,
X  {"CMINE" , cmd_cmine} , {"CFARM" , cmd_cfarm} , {"CSPEED", cmd_cspeed} ,
X  {"NATION_NAME", cmd_nation_name} , {"NATION_LEADER", cmd_nation_leader} ,
X  {"NATION_ORDER", cmd_nation_order} , {"NATION_MARK", cmd_nation_mark} ,
X  {"SET_NPC", cmd_set_npc} , {"CLEAR_NPC", cmd_clear_npc} ,
X  {"NPC_PARAM", cmd_npc_param} ,
X  {"CATTACK" , cmd_cattack} , {"CDEFENSE" , cmd_cdefense} , {"CCOMBAT" , cmd_ccombat} ,
X  {"CREPRO" , cmd_crepro} , {"CINTEL", cmd_cintel} ,
X  {"CMAG_APT", cmd_cmag_apt} , {"CSTRENGTH", cmd_cstrength} ,
X  {"CMORTALITY" , cmd_cmortality} , {"CPEOPLE_SECTOR" , cmd_cpeople_sector} ,
X  {"COWNER_SECTOR" , cmd_cowner_sector} , {"CSOIL_SECTOR", cmd_csoil_sector} ,
X  {"CMETAL_SECTOR", cmd_cmetal_sector} ,
X  {"CJEWELS_SECTOR", cmd_cjewels_sector} ,
X  {"CALTITUDE_SECTOR", cmd_caltitude_sector} ,
X  {"NEW_ARMY_TYPE", cmd_new_army_type} , {"AMERGE", cmd_amerge} ,
X  {"AINCREASE", cmd_aincrease},
X  {"ASPLIT", cmd_asplit} , {"ADISBAND", cmd_adisband} ,
X  {"CABONUS", cmd_cabonus} ,
X  {"CFORT_SECTOR", cmd_cfort_sector} , {"CROADS_SECTOR", cmd_croads_sector} ,
X  {"CPASS", cmd_cpass} , {"DESTROY", cmd_destroy},
X  {"ACASTLE", cmd_acastle}
X};
X
X
X/*******************************************************/
X/* gets nation data for nation 'id', put it into '*np' */
X/* takes in an integer nation id, and a pointer to a   */
X/* nation structure.                                   */
X/*******************************************************/
Xload_nation(id, np)
X     int id;
X     Snation *np;
X{
X  FILE *exec_file;
X  struct argument args[N_EXEC_ARGS];
X  char filename[NAMELEN];
X  int argc, i;
X  extern Suser user;
X
X  *np = world.nations[id];
X  user.np = np;		/* hmm.. must cleanup use of "Suser" in update */
X    /* remember what the initial values were, before reading the exec file */
X  user.init_money = user.np->money;
X  user.init_metal = user.np->metal;
X  user.init_jewels = user.np->jewels;
X  user.init_food = user.np->food;
X  user.id = np->id;
X  load_options(np);
X
X  sprintf(filename, "exec/exec%d", np->id);
X  exec_file = fopen(filename, "r");
X  if (!exec_file && np->npc_flag == 0) {
X    fprintf(stderr, "Nation %d (%s) did not move this turn.\n", np->id, np->name); }
X  else {
X    while (argc = getexec(exec_file, args) != -1) {
X      run_exec_line(np, args);
X    }
X    if (exec_file != NULL) { fclose(exec_file); }
X  }
X}
X
X/****************************************************************/
X/* this takes a pointer to the exec file and a pointer to an    */
X/* array of argument structures.  The structures are filled in  */
X/* with the arguments of the next line of the file.  The        */
X/* function returns an integer which is the number of arguments */
X/****************************************************************/
Xint getexec(fp, args)
XFILE *fp;
Xstruct argument args[];
X{
X  char buff[EXECLEN];
X  if (fp == NULL) {
X    return (-1);
X  }
X  if (fgets(buff, EXECLEN, fp) != NULL) {
X    parse_exec_line(buff, args);
X  }
X  else return(-1);
X}
X
X
X
X  /* this takes the exec line args (already parsed) and runs it */
Xrun_exec_line(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int i, found = 0;
X
X  for (i=0; i < sizeof(commands)/sizeof(struct exec_cmd); i++) {
X    if (!(strcmp(commands[i].name, args[0].data.str))) {
X      found = 1;
X      (*commands[i].func)(np, args);
X    }
X  }
X  if (!found) {
X    printf("Error: exec command <%s> not implemented\n", args[0].data.str);
X  }
X}
X
X#ifdef AMIGA
X#define sscanf sscanf2
Xsscanf2(data, terminate, result)
X     char *data, *terminate, *result;
X{
X  int i;
X  
X  terminate += 3;
X  for (;;) {
X    for (i=0; i<strlen(terminate); i++)
X      if (*data == terminate[i]) return;
X    *result = *data;
X    data++;
X    result++;
X    *result = '\0';
X  }
X}
X#endif
X
X
X  /* this parses a single exec line */
Xparse_exec_line(line, args)
X     char line[];
X     struct argument args[];
X{
X  char cmd_str[NAMELEN], arg_tmp[NAMELEN];
X  int count = 0, place;
X
X    /* make sure there is a newline at the end of this line */
X  if (line[strlen(line)-1] != '\n') {
X    line[strlen(line)+1] = '\0'; /* extend the string */
X    line[strlen(line)] = '\n'; /* put the newline in */
X  }
X  sscanf(line, "%[^:]", args[0].data.str);
X  place = strlen(args[0].data.str)+1;
X  args[0].type = TXT;
X  do {
X    sscanf(&line[place], "%[^:\n]", arg_tmp);
X    place += strlen(arg_tmp)+1;
X    count++;
X    if (isdigit(arg_tmp[0]) || (arg_tmp[0] == '-')) {
X      args[count].type = NUM;
X      args[count].data.num = atoi(arg_tmp);
X    }
X    else {
X      args[count].type = TXT;
X      strcpy(args[count].data.str, arg_tmp);
X    }
X  } while (place+1 < strlen(line));
X  return(count);
X}
X
X
X
X/******************************************************************/
X/* this takes the name of a nation (a pointer to an array of      */
X/* characters) and returns the id number of that nation.          */
X/******************************************************************/
Xint get_nation_id(name)		/* finds id, given name */
X     char name[];
X{
X  int i;
X
X  for (i = 0; i < world.n_nations; ++i) {
X    if (!strcmp(world.nations[i].name, name)) {
X      return i;		/* found it! */
X    }
X  }
X  return -1;			/* it's not there */
X}
X
X  /* rename a sector */
Xcmd_sname(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int x, y;
X  char name[NAMELEN];
X
X  x = args[1].data.num;
X  y = args[2].data.num;
X  strcpy (name, args[3].data.str);
X  
X  if (debug) printf ("Naming sector %d,%d as %s.\n", x, y, name); 
X  strcpy(world.map[x][y].name, name);
X}
X
X  /* rename an army */
Xcmd_aname(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int id;
X  char *name;
X  Sarmy *ap, *get_army();
X
X  id = args[1].data.num;
X  name = args[2].data.str;
X  
X  if (ap = get_army(np, id)) {
X    if (debug) printf ("Naming army %d as %s.\n", id, name);
X    strcpy(ap->name, name);
X  } else {
X    printf("funny:  cannot find army %d\n", id);
X  }
X}
X
X
X/* Move an army... change it's move points to the move points left, which
X   is given in the exec string. */
Xcmd_amove(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Sarmy *armypt;
X  Ssector *sp;
X  int a, x, y, fm;
X  
X  a = args[1].data.num;		/* army number */
X  x = args[2].data.num;		/* new x coordinate */
X  y = args[3].data.num;		/* new y coordinate */
X  fm = args[4].data.num;	/* final moves */
X  armypt = np->armies;
X  while (armypt->id != a && armypt->next != NULL) armypt = armypt->next;
X  if (armypt->id == a) {
X    if (debug) {
X      printf ("Moving army %d from %d,%d to %d,%d\n", a, armypt->pos.x,
X	    armypt->pos.y, x, y);
X    }
X    sp = &(world.map[armypt->pos.x][armypt->pos.y]);
X    delete_army_sector(sp, armypt);
X
X    armypt->pos.x = x;
X    armypt->pos.y = y;
X    armypt->mvpts = fm;
X    sp = &(world.map[x][y]);
X    insert_army_sector(sp, armypt);
X  }
X  else printf ("Error! Could not find army!\n"); 
X}
X
X
X/* Change status of an army... if the army is being changed to OCCUPY mode,
X   and it is _already_ in occupy mode, DO NOT change it's move ratio!
X   Otherwise set the move ratio, change the moves left to zero, and
X   change the status. */
Xcmd_astat(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int a, s;
X  Sarmy *armypt, *get_army();
X  
X  a = args[1].data.num;
X  s = args[2].data.num;
X  if (debug) printf ("Changing status of army %d to %d\n", a, s);
X  armypt = get_army(np, a);
X  if (armypt) {
X    if (s == A_OCCUPY && armypt->status != A_OCCUPY) {
X      armypt->mvratio =
X	(int)(100 * (float)(armypt->mvpts) / basic_move_rate(np) );
X      armypt->mvpts = 0;
X    }
X    armypt->status = s;
X  } else {
X    printf("Trying to change status on army %d which does not exist\n", a);
X  }
X}
X
X  /* Set/clear a flag of an army, such as AF_HIDDEN, AF_FLIGHT and so on... */
Xcmd_aflag_set(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int id, flag;
X  Sarmy *armypt, *get_army();
X  
X  id = args[1].data.num;
X  flag = args[2].data.num;
X  if (debug) printf ("Setting bit %x of army %d\n", flag, id);
X  if (armypt = get_army(np, id)) {
X    armypt->flags |= flag;
X  }
X}
X
Xcmd_aflag_clear(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int id, flag;
X  Sarmy *armypt, *get_army();
X  
X  id = args[1].data.num;
X  flag = args[2].data.num;
X  if (debug) printf ("Clearing bit %x of army %d\n", flag, id);
X  if (armypt = get_army(np, id)) {
X    armypt->flags &= ~flag;
X  }
X}
X
X  /* Set/clear a flag of a sector, such as SF_HIDDEN, SF_BUBBLE and so on... */
Xcmd_flag_set_sector(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int x, y, flag;
X  Ssector *sp;
X  
X  x = args[1].data.num;
X  y = args[2].data.num;
X  flag = args[3].data.num;
X  sp = &world.map[x][y];
X  sp->flags |= flag;
X}
X
Xcmd_flag_clear_sector(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int x, y, flag;
X  Ssector *sp;
X  
X  x = args[1].data.num;
X  y = args[2].data.num;
X  flag = args[3].data.num;
X  sp = &world.map[x][y];
X  sp->flags &= ~flag;
X}
X
X  /* Change cargo of an army */
Xcmd_acargo(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int id;
X  Sarmy *armypt, *get_army();
X  
X  id = args[1].data.num;
X
X  if (debug) printf ("Changing cargo of army %d\n", id);
X  if ((armypt = get_army(np, id)) != NULL) {
X    armypt->cargo.money = args[2].data.num;
X    armypt->cargo.metal = args[3].data.num;
X    armypt->cargo.jewels = args[4].data.num;
X    armypt->cargo.food = args[5].data.num;
X    armypt->cargo.people = args[6].data.num;
X    armypt->cargo.army = args[7].data.num;
X    armypt->cargo.title.x = args[8].data.num;
X    armypt->cargo.title.y = args[9].data.num;
X  } else {
X    printf("[%s] Could not find army %d, nation %d\n", args[0].data.str,
X	   id, np->id);
X  }
X}
X
Xcmd_taxrate(np, args)
X     struct argument args[];
X     Snation *np;
X{
X  int t;
X
X  t = args[1].data.num;  
X  if (debug) printf ("Taxes changed from %d to %d.\n", np->taxes, t);
X  np->taxes = t;
X}
X
X
X
Xcmd_charity(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int c;
X  
X  c = args[1].data.num;
X  if (debug) printf ("Charity changed from %d to %d.\n", np->charity, c);
X  np->charity = c;
X}
X
X
Xcmd_desig_sector(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int x, y, d;
X  Snation *owner_np;
X
X  x = args[1].data.num;
X  y = args[2].data.num;
X  d = args[3].data.num;		/* the new designation */
X  owner_np = &world.nations[world.map[x][y].owner];
X  if (debug) printf ("Redesignating %d,%d to %d.\n", x, y, d);
X  world.map[x][y].designation = d;
X    /* special case for capital: */
X  if (d == D_CAPITAL) {
X    owner_np->capital.x = x;	/* make sure Gamemaster does not get it */
X    owner_np->capital.y = y;
X  }
X}
X
X
Xcmd_amake(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Sarmy army, make_army();
X  Ssector *sp;
X  int a, no_sold, x, y;
X  char *type, *name;
X  
X  a = args[1].data.num;		/* army number */
X  no_sold = args[2].data.num;	/* number of soldiers drafted */
X  x = args[3].data.num;		/* x coordinate where army is drafted */
X  y = args[4].data.num;		/* y coordinate where army is drafted */
X  type = args[5].data.str;	/* army type */
X  name = args[6].data.str;	/* army name */
X
X  sp = &(world.map[x][y]);
X  army = make_army(type,name,no_sold,A_DEFEND,np->id,sp->loc);
X/*  army.id  = free_army_id(np); */
X  army.id = a;
X  army.next = NULL;
X
X  if (debug) printf("Permanently drafting army #%d\n",army.id);
X  if (np->armies == NULL) {
X    np->armies = (Sarmy *) malloc(sizeof(Sarmy));
X    *(np->armies) = army;
X  } else {
X    insert_army_nation(np, &army, a);
X  }
X  insert_army_sector(sp, &army);
X  ++np->n_armies;
X}
X
Xcmd_cmoney(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int change, nat_id;
X
X  nat_id = args[1].data.num;
X  change = args[2].data.num;	/* changed money */
X  np = &world.nations[nat_id];
X     
X  np->money = np->money + change;
X  if (debug) printf("New nation money (after difference of %d) = %d\n",
X	 change,np->money);
X}
X
Xcmd_cmetal(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int change, nat_id;
X
X  nat_id = args[1].data.num;
X  change = args[2].data.num;   /* changed money */
X  np = &world.nations[nat_id];
X  
X  np->metal = np->metal + change;
X  if (debug) printf("New nation metal (after difference %d) = %d\n",
X	 change,np->metal);
X}
X
Xcmd_cjewels(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int change, nat_id;
X
X  nat_id = args[1].data.num;
X  change = args[2].data.num;   /* changed money */
X  np = &world.nations[nat_id];
X  
X  np->jewels = np->jewels + change;
X  if (debug) printf("New nation jewel (after difference %d) = %d\n",
X	 change,np->jewels);
X}
X
Xcmd_cspell_pts(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int change, nat_id;
X
X  nat_id = args[1].data.num;
X  change = args[2].data.num;   /* changed money */
X  np = &world.nations[nat_id];
X  
X  np->spell_pts = np->spell_pts + change;
X  if (debug) printf("New nation spell pts (after difference %d) = %d\n",
X		    change, np->spell_pts);
X}
X
Xcmd_ctech_skill(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int change, nat_id;
X
X  nat_id = args[1].data.num;
X  change = args[2].data.num;   /* changed money */
X  np = &world.nations[nat_id];
X  
X  np->tech_skill = np->tech_skill + change;
X}
X
Xcmd_cmag_skill(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int change, nat_id;
X
X  nat_id = args[1].data.num;
X  change = args[2].data.num;   /* changed money */
X  np = &world.nations[nat_id];
X  
X  np->mag_skill = np->mag_skill + change;
X}
X
Xcmd_cfood(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int change, nat_id;
X
X  nat_id = args[1].data.num;
X  change = args[2].data.num;   /* changed money */
X  np = &world.nations[nat_id];
X  
X  np->food = np->food + change;
X  if (debug) printf("New nation food (after difference %d) = %d\n",
X	 change,np->food);
X}
X
Xcmd_tech_money(np,args)
X     Snation *np;
X     struct argument args[];
X{
X  np->tech_r_d = args[1].data.num;
X  if (debug) printf("Tech R&D money changed to %d\n",np->tech_r_d);
X}
X
X
Xcmd_tech_metal(np,args)
X     Snation *np;
X     struct argument args[];
X{
X  np->tech_r_d_metal = args[1].data.num;
X  if (debug) printf("Tech R&D metal changed to %d\n",np->tech_r_d_metal);
X}
X
X
Xcmd_spy_money(np,args)
X     Snation *np;
X     struct argument args[];
X{
X     np->spy_r_d = args[1].data.num;
X   }
X
X
Xcmd_mag_money(np,args)
X     Snation *np;
X     struct argument args[];
X{
X  np->mag_r_d = args[1].data.num;
X  if (debug) printf("Magic money changed to %d\n",np->mag_r_d);
X}
X
Xcmd_mag_jewels(np,args)
X     Snation *np;
X     struct argument args[];
X{
X  np->mag_r_d_jewels = args[1].data.num;
X  if (debug) printf("Magic jewels changed to %d\n",np->mag_r_d_jewels);
X}
X
Xcmd_cmine(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  np->mine_skill += args[1].data.num;
X}
Xcmd_cfarm(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  np->farm_skill += args[1].data.num;
X}
Xcmd_cspeed(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  np->race.speed += args[1].data.num;
X}
X
Xcmd_nation_name(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Snation *changed_np = &world.nations[args[1].data.num];
X  strcpy(changed_np->name, args[2].data.str);
X}
X
Xcmd_nation_leader(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Snation *changed_np = &world.nations[args[1].data.num];
X  strcpy(changed_np->leader, args[2].data.str);
X}
X
Xcmd_nation_order(np, args)	/* change magic order */
X     Snation *np;
X     struct argument args[];
X{
X  Snation *changed_np = &world.nations[args[1].data.num];
X  strcpy(changed_np->mag_order, args[2].data.str);
X}
X
Xcmd_nation_mark(np, args)	/* change a nation's mark */
X     Snation *np;
X     struct argument args[];
X{
X  Snation *changed_np = &world.nations[args[1].data.num];
X  changed_np->mark = args[2].data.str[0];
X}
X
X  /* set and clear the npc flag on a nation */
Xcmd_set_npc(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Snation *changed_nation = &world.nations[args[1].data.num];
X
X  changed_nation->npc_flag = 1;
X}
X
Xcmd_clear_npc(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Snation *changed_nation = &world.nations[args[1].data.num];
X
X  changed_nation->npc_flag = 0;
X}
X
Xcmd_npc_param(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Snation *changed_nation = &world.nations[args[1].data.num];
X
X  changed_nation->npc_agg = args[2].data.num;
X  changed_nation->npc_exp = args[3].data.num;
X  changed_nation->npc_iso = args[4].data.num;
X}
X
X  /* change in a nation's fight bonus */
Xcmd_cattack(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  np->attack += args[1].data.num;
X}
X
Xcmd_cdefense(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  np->defense += args[1].data.num;
X}
X
Xcmd_ccombat(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  np->attack += args[1].data.num;
X  np->defense += args[1].data.num;
X}
X
Xcmd_crepro(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  np->race.repro += args[1].data.num;
X}
X
Xcmd_cmortality(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  if ((np->race.mortality += args[1].data.num) < 1) {
X    np->race.mortality = 1;
X  }
X}
X
Xcmd_cintel(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  if ((np->race.intel += args[1].data.num) < 1) {
X    np->race.intel = 1;
X  }
X}
X
Xcmd_cmag_apt(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  if ((np->race.mag_apt += args[1].data.num) < 1) {
X    np->race.mag_apt = 1;
X  }
X}
X
Xcmd_cstrength(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  if ((np->race.strength += args[1].data.num) < 1) {
X    np->race.strength = 1;
X  }
X}
X
X  /* change the number of people in that sector */
Xcmd_cpeople_sector(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Ssector *sp;
X  int x, y;
X
X  x = args[1].data.num;
X  y = args[2].data.num;
X  sp = &world.map[x][y];
X  sp->n_people += args[3].data.num;
X}
X  /* change the owner in that sector */
Xcmd_cowner_sector(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Ssector *sp;
X  int x, y;
X
X  x = args[1].data.num;
X  y = args[2].data.num;
X  sp = &world.map[x][y];
X  sp->owner = args[3].data.num;
X  addsector(&world.nations[sp->owner], x, y);
X  if (debug)
X    printf("sector (%d,%d) owned by %s\n", x, y,
X	   world.nations[sp->owner].name);
X}
X
X  /* change the soil in that sector */
Xcmd_csoil_sector(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Ssector *sp;
X  int x, y;
X
X  x = args[1].data.num;
X  y = args[2].data.num;
X  sp = &world.map[x][y];
X  sp->soil += args[3].data.num;
X}
X
X  /* change the metal in that sector */
Xcmd_cmetal_sector(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Ssector *sp;
X  int x, y;
X
X  x = args[1].data.num;
X  y = args[2].data.num;
X  sp = &world.map[x][y];
X  sp->metal += args[3].data.num;
X}
X  /* change the jewels in that sector */
Xcmd_cjewels_sector(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Ssector *sp;
X  int x, y;
X
X  x = args[1].data.num;
X  y = args[2].data.num;
X  sp = &world.map[x][y];
X  sp->jewels += args[3].data.num;
X}
X
X  /* change the altitude in that sector */
Xcmd_caltitude_sector(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Ssector *sp;
X  int x, y;
X
X  x = args[1].data.num;
X  y = args[2].data.num;
X  sp = &world.map[x][y];
X  sp->altitude += args[3].data.num;
X}
X
X/* adds a new type of army to the nation's list of available army types */
Xcmd_new_army_type(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Savail_army *aa;
X  extern Suser user;
X  int falready=0;
X
X  /* Check to see that they don't already have the army type */
X  aa = user.avail_armies;
X  if (aa != NULL) {
X    do {
X      if (!strcmp (aa->type, args[1].data.str)) {
X	falready = 1;
X	break;
X      }
X    } while (aa->next && (aa=aa->next));
X  }
X  if (aa == NULL) {
X    aa = (Savail_army *) malloc (sizeof(Savail_army));
X    strcpy (aa->type, args[1].data.str);
X  } else if (!falready) {
X    do { ; } while (aa->next && (aa = aa->next));
X    aa->next = (Savail_army *) malloc (sizeof (Savail_army));
X    aa->next->next = NULL;
X    strcpy(aa->next->type, args[1].data.str);
X  }
X  user.n_army_types++;
X}
X
X/* allows nation to construct a new type of object, such
X   as increasing roads in a sector, or making land into water
X   or vice-versa, or ships, or caravans.
X*/
Xcmd_new_construct(np, args)
X     Snation *np;
X     struct argument args[];
X{
X}
X
X  /* adds the first army to the second.  Requires the two army ids. */
Xcmd_amerge(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Sarmy *ap, *ap2;
X  Ssector *sp;
X  ap = get_army(np, args[1].data.num);
X  ap2 = get_army(np, args[2].data.num);
X  sp = &world.map[ap->pos.x][ap->pos.y];
X  ap2->n_soldiers += ap->n_soldiers;
X  ap2->sp_bonus = min(ap->sp_bonus, ap2->sp_bonus);
X  ap2->mvpts = min(ap->mvpts, ap2->mvpts);
X  ap2->mvratio = min(ap->mvratio, ap2->mvratio);
X  delete_army_sector(sp, ap);
X  delete_army_nation(np, ap);
X}
X
X  /* increases the army (of given id) by the given number of people */
Xcmd_aincrease(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Sarmy *ap;
X
X  ap = get_army(np, args[1].data.num);
X  ap->n_soldiers += args[2].data.num;
X  ap->mvpts = 0;
X  ap->mvratio = 0;
X}
X
X  /* splits an army up.  requires armyid and number of men to split */
Xcmd_asplit(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Sarmy *ap, army2, make_army(), *get_army();
X
X  ap = get_army(np,args[1].data.num);
X  army2 = make_army(ap->type, "", args[2].data.num, ap->status,
X		    ap->owner, ap->pos);
X  ap->n_soldiers -= args[2].data.num;
X  army2.mvpts = ap->mvpts;
X  army2.mvratio = ap->mvratio;
X  army2.flags = ap->flags;
X  army2.sp_bonus = ap->sp_bonus;
X  army2.money_maint = ap->money_maint;
X  army2.metal_maint = ap->metal_maint;
X  army2.jewel_maint = ap->jewel_maint;
X  army2.spell_pts_maint = ap->spell_pts_maint;
X  sprintf(army2.name, "%s", army2.type, army2.id);
X  np->n_armies++;
X  insert_army_nation(np, &army2, -1);
X  insert_army_sector(&world.map[army2.pos.x][army2.pos.y], &army2);
X    /* to give them a name, we must know their id *after* they are inserted */
X  ap = get_army(np, army2.id);
X  sprintf(ap->name, "%s", army2.type, army2.id);
X}
X
Xcmd_adisband(np,args)
X     Snation *np;
X     struct argument args[];
X{
X  Sarmy *ap;
X  Ssector *sp;
X  ap = get_army(np,args[1].data.num);
X  sp = &world.map[ap->pos.x][ap->pos.y];
X    /* you don't get the population back from a spirit */
X  if (!is_spirit(ap) && !is_in_transport(ap)) {
X    sp->n_people += ap->n_soldiers;
X  }
X  delete_army_sector(sp, ap);
X  delete_army_nation(np, ap);
X}
X
Xcmd_cabonus(np,args)		/* give an army more/less special bonus */
X     Snation *np;
X     struct argument args[];
X{
X  Sarmy *ap;
X  int bonus_change;
X
X  bonus_change = args[2].data.num;
X  if (ap = get_army(np,args[1].data.num)) {
X    ap->sp_bonus += bonus_change;
X  }
X}
X
X  /* change fortification level of a sector */
Xcmd_cfort_sector(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Ssector *sp;
X  int x, y;
X
X  x = args[1].data.num;
X  y = args[2].data.num;
X  sp = &world.map[x][y];
X  sp->defense += args[3].data.num;
X}
X
X  /* change number of roads in a sector */
Xcmd_croads_sector(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Ssector *sp;
X  int x, y;
X
X  x = args[1].data.num;
X  y = args[2].data.num;
X  sp = &world.map[x][y];
X  sp->roads += args[3].data.num;
X}
X
Xcmd_cpass(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  Snation *dest_np;
X  int id;
X  char *new_pass;
X
X  id = args[1].data.num;
X  new_pass = args[2].data.str;
X  dest_np = &world.nations[id];
X  strcpy(dest_np->passwd, new_pass);
X}
X
Xcmd_cur_mag_money (np, args)
X
XSnation * np;
Xstruct argument args [];
X{
X  np->cur_mag_r_d = args[1].data.num;
X}
X
Xcmd_cur_tech_money (np, args)
X
XSnation * np;
Xstruct argument args [];
X{
X  np->cur_tech_r_d = args[1].data.num;
X}
X
Xcmd_cur_mag_jewels (np, args)
X
XSnation * np;
Xstruct argument args [];
X{
X  np->cur_mag_r_d_jewels = args[1].data.num;
X}
X
Xcmd_cur_tech_metal (np, args)
X
XSnation * np;
Xstruct argument args [];
X{
X  np->cur_tech_r_d_metal = args[1].data.num;
X}
X
Xcmd_cur_spy_money (np, args)
X
XSnation * np;
Xstruct argument args [];
X{
X  np->cur_spy_r_d = args[1].data.num;
X}
X
Xcmd_destroy(np, args)
X     Snation *np;
X     struct argument args[];
X{
X  int id;
X
X  id = args[1].data.num;
X  destroy_nation(id);
X}
X
Xcmd_acastle (np, args)
X     
XSnation * np;
Xstruct argument args [];
X{
X  int army_id;
X  Ssector * sp;
X  Ssector * capital = &world.map [np->capital.x][np->capital.y];
X  Sarmy * ap;
X
X  army_id = args[1].data.num;
X  if ((ap = get_army (np, army_id)) == NULL) {
X    printf ("funny, can't find army %d\n", army_id);
X  }
X  sp = &world.map [ap->pos.x][ap->pos.y];
X
X  delete_army_sector (sp, ap);
X
X  ap->pos.x = capital->loc.x;
X  ap->pos.y = capital->loc.y;
X  
X  insert_army_sector (capital, ap);
X}
X
X  /* read in the exec file for the master nation; this is done by all
X     users, in case the master has changed things for them.  It is not
X     done by the master nation, since that happens automaticaly.
X   */
Xload_master_execs()
X{
X  int argc;
X  Snation *np = &world.nations[0];
X  FILE *exec_file, *fopen();
X  struct argument args[N_EXEC_ARGS];
X  char filename[NAMELEN];
X
X  sprintf(filename, "exec/exec%d", np->id);
X  exec_file = fopen(filename, "r");
X  if (!exec_file && np->npc_flag == 0) {
X    /* printf("Nation %d (%s) did not move this turn.\n", np->id, np->name); */
X  } else {
X    while (argc = getexec(exec_file, args) != -1) {
X      run_exec_line(np, args);
X    }
X    if (exec_file != NULL) { fclose(exec_file); }
X  }
X}
X
END_OF_FILE
if test 28685 -ne `wc -c <'nation.c'`; then
    echo shar: \"'nation.c'\" unpacked with wrong size!
fi
# end of 'nation.c'
fi
if test -f 'transport.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'transport.c'\"
else
echo shar: Extracting \"'transport.c'\" \(27480 characters\)
sed "s/^X//" >'transport.c' <<'END_OF_FILE'
X/* transport.c -- routines dealing with transportation */
X
X/*
X * Copyright (C) 1990 Free Software Foundation, Inc.
X * Written by the dominion project.
X *
X * This file is part of dominion.
X *
X * dominion is free software; you can redistribute it and/or
X * modify it under the terms of the GNU General Public License as published
X * by the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This software is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this software; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "dominion.h"
X#include "misc.h"
X#include "army.h"
X#include "costs.h"
X#include "cur_stuff.h"
X
X#include <stdio.h>
X#include <math.h>
X
Xextern Suser user;
Xextern Sworld world;
Xextern char help_tag[];
Xextern WINDOW * sectw;
Xextern struct army_type * army_types;
X
X
X/* Main transport functions */
X/* int transport ();  /* Coordinates everything (top level) */
X/* int transport_load (Sarmy *, WINDOW *); /* Actually loads stuff */
X/* int transport_unload (Sarmy *, WINDOW *); /* Unloads stuff */
X/* int transport_transfer (Sarmy *, WINDOW *); /* Transfers stuff */
X
X/* Cargo weight functions */
X/* int army_weight (Sarmy *); /* Figures out an army's manweight */ 
X/* int caravan_weight (Sarmy *); /* Figures out a caravan's manweight */
X/* int cargo_weight (Scargo *); /* Figures out a cargo's manweight */
X/* char * make_cargo_statline (Scargo *); /* Makes a cargo statline */
X
X  /* allows you to load/unload cargo from a caravan */
Xint transport()
X{
X  WINDOW *tw;
X  char type[NAMELEN];
X  int ret, size;
X  Snation *np = user.np;
X  Ssector *sp =  &world.map[user.cursor.x][user.cursor.y];
X  Sarmy *ap, *get_army();
X  char s[EXECLEN];
X  int done = 0;
X
X    /* before I make the new window, I should check if the user
X       is transporting on a caravan or ship, or if they are transporting
X       on something else (like an army or a spirit)
X     */
X  ap = get_army(np, user.current_army);
X  if ( (ap == NULL) || !is_cargo(ap) ) {
X    statline2_err ("hit space", "must select a caravan or navy");
X    return -1;
X  }
X  if (user.xmode) {
X    tw = NULL;
X  } else {
X    statline("hit space to exit", "transportation");
X    tw = newwin(7, COLS/2+28, LINES-10, COLS/4-14);
X  }
X
X  while (!done) {
X    if (tw != NULL) {
X      mvwprintw(tw, 1, 1, "Do you wish to [l]oad, [u]nload or [t]ransfer? ");
X      wclrtobot(tw);
X      box(tw, '|', '-');
X      wrefresh(tw);
X    }
X    cargo_statline(user.xmode ? NULL : tw, &user);
X
X    strcpy(help_tag, "Transportation");
X    switch (mygetch()) {
X    case 'l':
X      if (ap->flags & AF_IN_TRANSPORT) {
X	statline2_err ("hit space", "cannot load a caravan in transit");
X      }
X      else transport_load(ap, user.xmode ? NULL : tw);
X      statline2("", "");
X      break;
X    case 'u':
X      if (!cargo_not_empty (&ap->cargo)) {
X	statline2_err ("hit space", "cannot unload an empty caravan"); 
X      }
X      else transport_unload(ap, user.xmode ? NULL : tw);
X      statline2("", "");
X      break;
X    case 't':
X      if (!cargo_not_empty (&ap->cargo)) {
X	statline2_err ("hit space", "nothing to transfer");
X      }
X      else transport_transfer(ap, user.xmode ? NULL : tw);
X      statline2("", "");
X      break;
X    case ' ':
X      done = 1;
X      break;
X    default:
X      break;
X    }
X  }
X
X  if (tw != NULL) {
X    delwin(tw);
X    wrefresh (sectw);
X    touchwin(stdscr);
X  }
X  just_moved ();
X  return 1;
X}
X
X  /* load onto a caravan or ship */
Xtransport_load (ap, tw)
X     Sarmy *ap;
X     WINDOW *tw;
X{
X  Snation *np = user.np;
X  Ssector *sp = &world.map[ap->pos.x][ap->pos.y];
X  Sarmy *loaded_army;
X  int quantity, done = 0, ret; 
X  int doit;
X  char c;
X  char s[100];
X
X  strcpy(help_tag, "Transportation");
X
X  while (!done) {
X    if (tw != NULL) {
X      wmove(tw, 4, 1);
X      wclrtobot(tw);
X    }
X    cargo_statline(tw, &user);
X    if (tw != NULL) {
X      box(tw, '|', '-');
X    }
X    if (user.xmode) {
X      statline2("  [s,m,j,f,a,p,t]", "load");
X    } else {
X      wmove (tw, 1, 0);
X      wclrtoeol (tw);
X      box (tw, '|', '-');
X      mvwprintw(tw, 2, 2, "What do you want to load? ");
X      mvwprintw(tw, 3, 2,
X		" [s]hekels, [m]etal, [j]ewels, [f]ood, [a]rmy, [p]eople, [t]itle ");
X      wrefresh(tw);
X    }
X    do { c = mygetch(); } while (strchr (" smjfapt", c) == NULL);
X
X    doit = 1;
X    
X    /* If anything besides a title or an exit, prompt */
X    if (c != ' ' && c != 't') {
X      sprintf (s, (c == 'a') ? "(%c) Which army? " : "(%c) Quantity? ", c);
X      if (user.xmode) {
X	statline2(s, "");
X	move(LINES-2, strlen(s));
X      } else {
X	mvwprintw(tw, 4, 5, s);
X      }
X      ret = wget_number(user.xmode ? stdscr : tw, &quantity);
X      if (ret <= 0) {
X	doit = 0;
X      }
X    }
X
X    strcpy (s, "");
X
X    if (!good_loading_place (np, sp, c, quantity)) {
X      statline2_err ("Can't load that here", "load");
X    } else if (load_too_big (np, ap, c, quantity)) {
X      statline2_err ("Too much (space)", "load");
X    } else if (quantity >= 0 && doit) {
X      switch (c) {
X      case ' ':
X	done = 1;
X	break;
X      case 's':
X	if (quantity <= np->money) {
X	  ap->cargo.money += quantity;
X	  np->money -= quantity;
X	  cmoney (np, -quantity);
X	}
X	else sprintf (s, "Sorry, not enough in storage (space)");
X	break;
X      case 'j':
X	if (quantity <= np->jewels) {
X	  ap->cargo.jewels += quantity;
X	  np->jewels -= quantity;
X	  cjewels (np, -quantity);
X	}
X	else sprintf (s, "Sorry, not enough in storage (space)");
X	break;
X      case 'm':
X	if (quantity <= np->metal) {
X	  ap->cargo.metal += quantity;
X	  np->metal -= quantity;
X	  cmetal (np, -quantity);
X	}
X	else sprintf (s, "Sorry, not enough in storage (space)");
X	break;
X      case 'f':
X	if (quantity <= np->food) {
X	  ap->cargo.food += quantity;
X	  np->food -= quantity;
X	  cfood (np, -quantity);
X	}
X	else sprintf (s, "Sorry, not enough in storage (space)");
X	break;
X      case 'a':
X	if (ap->cargo.army == -1) {
X	  if (army_is_in_sector(sp, ap->owner, quantity)) {
X	    if (ap->id != quantity) {
X	      ap->cargo.army = quantity;
X	      loaded_army = get_army (np, quantity);
X	      loaded_army->flags |= AF_IN_TRANSPORT;
X	      aflag_set (loaded_army, AF_IN_TRANSPORT);
X	      show_armies (sp);
X	    }
X	    else sprintf(s,"That would be an interesting topological exercise!");	  }
X	  else sprintf (s, "Sorry, can't load across sectors!");
X	}
X	else sprintf (s, "Sorry, can only transport one army at a time.");
X	break;
X      case 'p':
X	if (quantity <= sp->n_people) {
X	  ap->cargo.people += quantity;
X	  sp->n_people -= quantity;
X	  cpeople_sector (sp, -quantity);
X	  if (user.xmode) {
X	    just_moved ();
X	    show_sector (user.cursor.x, user.cursor.y);
X	  }
X	}
X	else sprintf (s, "Sorry, too large a number (space)");
X	break;
X      case 't':
X	if (!has_traded (sp)) {
X	  if (sp->designation != D_CAPITAL) {
X	    if (ap->cargo.title.x == -1) {
X	      sp->flags |= SF_TRADED;
X	      sprintf (s, "FLAG_SET_SECTOR:%d:%d:%d\n", sp->loc.x, sp->loc.y,
X		       SF_TRADED);
X	      gen_exec (s);
X	      sprintf (s, "");
X	      ap->cargo.title = sp->loc;
X	    }
X	    else sprintf (s, "Sorry, can only load one title per caravan");
X	  }
X	  else sprintf (s, "Sorry, but you can't give away your nation...");
X	}
X	else sprintf (s, "Sector is already traded");
X	break;
X      }
X      if (strlen (s) > 0) {
X	statline2_err (s, "load");
X      }
X      else { adjust_cargo (ap); }
X    }
X  }
X}
X
X/* unload from a caravan */
Xtransport_unload(ap, tw)
X     Sarmy *ap;
X     WINDOW *tw;
X{
X  Snation *np = user.np;
X  Ssector *sp = &world.map[ap->pos.x][ap->pos.y];
X  int recip_id;			/* the guy you to whom give the cargo */
X  Scargo dropped_cargo;		/* how much you drop */
X  char c;
X  char s[100];
X  int done = 0, ret, quantity, bad_load = 0;
X  Sarmy *trans_ap;
X
X  /* initialize that nothing is traded */
X  dropped_cargo.money = 0;
X  dropped_cargo.metal = 0;
X  dropped_cargo.jewels = 0;
X  dropped_cargo.food = 0;
X  dropped_cargo.people = 0;
X  dropped_cargo.army = -1;
X  dropped_cargo.title.x = -1;
X  dropped_cargo.title.y = -1;
X
X  trans_ap = get_army(np, ap->cargo.army);
X  recip_id = sp->owner;
X
X  while (!done) {
X    cargo_statline(tw, &user);
X    if (tw != NULL) {
X      box(tw, '|', '-');
X      wrefresh(tw);
X    }
X    if (tw == NULL) {
X      statline2("  [s,m,j,f,p,a,t,*]", "unload");
X    } else {
X      wmove (tw, 1, 0);
X      wclrtoeol (tw);
X      box (tw, '|', '-');
X      mvwprintw(tw, 2, 2, "What do you want to unload? ");
X      mvwprintw(tw, 3, 2,
X		"[s]hekels/[m]etal/[j]ewels/[f]ood/[p]eople/[a]rmy/[t]itle/[*]");
X      wrefresh (tw);
X    }
X    do { c = mygetch (); } while (strchr ("*smjaftp ", c) == NULL);
X    
X    if (!good_unloading_place(np, sp, c, ap->cargo.army)) {
X      statline2_err("Cannot unload that here (space)", "");
X    }
X    else {
X      if (c != ' ' && c != 'a' && c != 't' && c != '*') {
X	sprintf (s, "(%c) Quantity? ", c);
X	if (tw == NULL) {
X	  statline2 (s, "unload");
X	  move (LINES-2, strlen(s));
X	} else {
X	  mvwprintw (tw, 4, 7, s);
X	}
X	ret = wget_number(user.xmode ? stdscr : tw, &quantity);
X      }
X
X      strcpy (s, "");
X
X      /* Actually unload the stuff */
X      if (strchr (" at*", c) != NULL || (ret >= 0) ) {
X	switch (c) {
X	case 's':
X	  if (quantity <= ap->cargo.money && quantity > 0) {
X	    ap->cargo.money -= quantity;
X	    dropped_cargo.money += quantity;
X	  }
X	  else sprintf (s, "Invalid number (space)");
X	  break;
X	case 'm':
X	  if (quantity <= ap->cargo.metal && quantity > 0) {
X	    ap->cargo.metal -= quantity;
X	    dropped_cargo.metal += quantity;
X	  }
X	  else sprintf (s, "Invalid number (space)");
X	  break;
X	case 'j':
X	  if (quantity <= ap->cargo.jewels && quantity > 0) {
X	    ap->cargo.jewels -= quantity;
X	    dropped_cargo.jewels += quantity;
X	  }
X	  else sprintf (s, "Invalid number (space)");
X	  break;
X	case 'f':
X	  if (quantity <= ap->cargo.food && quantity > 0) {
X	    ap->cargo.food -= quantity;
X	    dropped_cargo.food += quantity;
X	  }
X	  else sprintf (s, "Invalid number (space)");
X	  break;
X	case 'p':
X	  if (quantity <= ap->cargo.people && quantity > 0) {
X	    ap->cargo.people -= quantity;
X	    dropped_cargo.people += quantity;
X	  }
X	  else sprintf (s, "Invalid number (space)");
X	  break;
X	case 't':		/* drop a title to land */
X	  if (ap->cargo.title.x != -1) {
X	    dropped_cargo.title = ap->cargo.title;
X	    ap->cargo.title.x = -1;
X	    ap->cargo.title.y = -1;
X	  }
X	  else sprintf (s, "No sector title loaded (space)");
X	  break;
X	case 'a':
X	  if (ap->cargo.army >= 0) {
X	    dropped_cargo.army = ap->cargo.army;
X	    ap->cargo.army = -1;
X	  }
X	  else sprintf (s, "No army loaded (space)");
X	  break;
X	case '*':
X	  if (ap->cargo.army >= 0) {
X	    dropped_cargo.army = ap->cargo.army;
X	    ap->cargo.army = -1;
X	  }
X	  dropped_cargo.people = ap->cargo.people;
X	  ap->cargo.people = 0;
X	  dropped_cargo.jewels = ap->cargo.jewels;
X	  ap->cargo.jewels = 0;
X	  dropped_cargo.metal = ap->cargo.metal;
X	  ap->cargo.metal = 0;
X	  dropped_cargo.food = ap->cargo.food;
X	  ap->cargo.food = 0;
X	  dropped_cargo.money = ap->cargo.money;
X	  ap->cargo.money = 0;
X	  if (ap->cargo.title.x != -1) {
X	    dropped_cargo.title = ap->cargo.title;
X	    ap->cargo.title.x = -1;
X	    ap->cargo.title.y = -1;
X	  }
X	  done = 1;
X	  break;
X	case ' ':
X	  done = 1;
X	  break;
X	default:
X	  break;
X	}
X	if (strlen (s) > 0) {
X	  statline2_err (s, "");
X	  bad_load = 1;
X	}
X      }
X    }
X  }
X  if (bad_load == 1) { ; }
X  else if (recip_id == user.id) { /* on your land, just put the stuff down */
X    np->money += dropped_cargo.money;
X    np->metal += dropped_cargo.metal;
X    np->jewels += dropped_cargo.jewels;
X    np->food += dropped_cargo.food;
X    sp->n_people += dropped_cargo.people;
X    if (dropped_cargo.title.x != -1) {
X      Ssector *traded_sp;
X      traded_sp = &world.map[dropped_cargo.title.x][dropped_cargo.title.y];
X      traded_sp->flags &= ~SF_TRADED;
X        /* now prepare the exec string */
X      sprintf(s, "FLAG_CLEAR_SECTOR:%d:%d:%d\n", traded_sp->loc.x,
X	      traded_sp->loc.y, SF_TRADED);
X      gen_exec(s);
X    }
X    cmoney(np, dropped_cargo.money);
X    cmetal(np, dropped_cargo.metal);
X    cjewels(np, dropped_cargo.jewels);
X    cfood(np, dropped_cargo.food);
X    cpeople_sector(sp, dropped_cargo.people);
X      /* just drop your army on your own land */
X    if (dropped_cargo.army != -1) {
X      trans_ap->flags &= ~AF_IN_TRANSPORT;
X      aflag_clear(trans_ap, AF_IN_TRANSPORT);
X      dropped_cargo.army = -1;
X    }
X  } 
X  else { /* Not in your land */
X    if (dropped_cargo.army != -1) { /* Clear army transport flags */
X      if (is_front_line (trans_ap) || !(trans_ap->status == A_TRADED)) {
X	dropped_cargo.army = -1;	/* don't donate it!! */
X      }
X      trans_ap->flags &= ~AF_IN_TRANSPORT;
X      aflag_clear(trans_ap, AF_IN_TRANSPORT);
X    }
X    if (cargo_not_empty(&dropped_cargo)) {
X      donate_cargo(sp->loc.x, sp->loc.y, user.id, recip_id, &dropped_cargo);
X    }
X  } 
X  adjust_cargo(ap);		/* tell the exec file that cargo is changed */
X  if (tw == NULL) { /* Update the sector window */
X    just_moved ();
X    show_sector (user.cursor.x, user.cursor.y);
X  }
X  show_armies(sp);
X}
X
Xtransport_transfer (ap, tw)
XSarmy * ap;
XWINDOW * tw;
X{
X  Snation *np = user.np;
X  Ssector *sp = &world.map [ap->pos.x][ap->pos.y];
X  Sarmy * recip;
X  int recip_num;
X  char c;
X  char s [EXECLEN];
X  int ret, quantity;
X
X  if (tw == NULL) {
X    statline2("  [s,m,j,f,p,a,t,*]", "transfer");
X  } else {
X    wmove (tw, 1, 0);
X    wclrtoeol (tw);
X    box (tw, '|', '-');
X    mvwprintw(tw, 2, 2, "What do you want to transfer? ");
X    mvwprintw(tw, 3, 2,
X	      "[s]hekels/[m]etal/[j]ewels/[f]ood/[p]eople/[a]rmy/[t]itle/[*]");
X    wrefresh (tw);
X  }
X
X  do { c = mygetch (); } while (strchr ("*smjaftp ", c) == NULL);
X
X  if (c == ' ') {
X    statline2 ("", "");
X    return 0; 
X  }
X
X  if (c != 'a' && c != 't' && c != '*') {
X    sprintf (s, "(%c) Quantity? ", c);
X    if (tw == NULL) {
X      statline2 (s, "transfer");
X      move (LINES-2, strlen(s));
X    } else {
X      mvwprintw (tw, 4, 7, s);
X      wrefresh (tw);
X    }
X    ret = wget_number(user.xmode ? stdscr : tw, &quantity);
X    if (ret <= 0 || c == ' ') {
X      statline2 ("", "");
X      return 0;
X    }
X  }
X
X  sprintf (s, "Transfer to army #? ");
X  if (tw == NULL) {
X    statline2 (s, "transfer");
X    move (LINES-2, strlen (s));
X  } else {
X    mvwprintw (tw, 4, 7, "Transfer to army #? ");
X    wrefresh (tw);
X   }
X  ret = wget_number(user.xmode ? stdscr : tw, &recip_num);
X
X  if (ap->id == recip_num || (recip = get_army (user.np, recip_num)) == NULL) {
X    statline2 ("", "");
X    return 0;
X  }
X
X  /* Actually transfer */
X  if (strchr ("at*", c) != NULL) {
X    if (c == '*') {
X      int capacity;
X
X      if (ap->cargo.army != -1 && recip->cargo.army != -1) {
X	statline2_err ("hit space", "only one army allowed per caravan");
X	return 0;
X      }
X      if (recip->cargo.title.x != -1 && ap->cargo.title.x != -1) {
X	statline2_err ("hit space", "only one title allowed per caravan");
X	return 0;
X      }
X      if (is_cargo (recip)) {
X	capacity = recip->n_soldiers * CARAVAN_CAPACITY;
X      } else capacity = 0;   /* Someone made a booboo */
X
X      if ((capacity - cargo_weight (&recip->cargo))
X	  >= cargo_weight (&ap->cargo)) {
X	recip->cargo.money += ap->cargo.money;
X	ap->cargo.money = 0;
X	recip->cargo.jewels += ap->cargo.jewels;
X	ap->cargo.jewels = 0;
X	recip->cargo.metal += ap->cargo.metal;
X	ap->cargo.metal = 0;
X	recip->cargo.food += ap->cargo.food;
X	ap->cargo.food = 0;
X	recip->cargo.people += ap->cargo.people;
X	ap->cargo.people = 0;
X	recip->cargo.army = ap->cargo.army;
X	ap->cargo.army = -1;
X	recip->cargo.title.x = ap->cargo.title.x;
X	recip->cargo.title.y = ap->cargo.title.y;
X	ap->cargo.title.x = -1;
X	ap->cargo.title.y = -1;
X      }
X      else {
X	statline2_err ("hit space", "cargo too big to transfer");
X	return 0;
X      }
X    }
X    else {
X      if (load_too_big (np, recip, c, quantity)) {
X	statline2_err ("hit space", "load too big");
X	return (0);
X      }
X      switch (c) {
X      case 'a':
X	if (recip->cargo.army != -1) {
X	  statline2_err ("hit space", "army already loaded");
X	  return 0;
X	}
X	recip->cargo.army = ap->cargo.army;
X	ap->cargo.army = -1;
X	break;
X      case 't':
X	if (recip->cargo.title.x != -1) {
X	  statline2_err ("hit space", "title already loaded");
X	  return 0;
X	}
X	recip->cargo.title.x = ap->cargo.title.x;
X	recip->cargo.title.y = ap->cargo.title.y;
X	ap->cargo.title.x = -1;
X	ap->cargo.title.y = -1;
X	break;
X      default:
X	break;
X      }
X    }
X  }
X  else {
X    if (load_too_big (np, recip, c, quantity)) {
X      statline2_err("hit space", "load too big");
X      return (0);
X    }
X    switch (c) {
X    case 's':
X      if (quantity <= ap->cargo.money && quantity > 0) {
X	ap->cargo.money -=quantity;
X	recip->cargo.money += quantity;
X      }
X      else statline2_err ("hit space", "Invalid quantity");
X      break;
X    case 'm':
X      if (quantity <= ap->cargo.metal && quantity > 0) {
X	ap->cargo.metal -=quantity;
X	recip->cargo.metal += quantity;
X      }
X      else statline2_err ("hit space", "Invalid quantity");
X      break;
X    case 'j':
X      if (quantity <= ap->cargo.jewels && quantity > 0) {
X	ap->cargo.jewels -=quantity;
X	recip->cargo.jewels += quantity;
X      }
X      else statline2_err ("hit space", "Invalid quantity");
X      break;
X    case 'f':
X      if (quantity <= ap->cargo.food && quantity > 0) {
X	ap->cargo.food -=quantity;
X	recip->cargo.food += quantity;
X      }
X      else statline2_err ("hit space", "Invalid quantity");
X      break;
X    case 'p':
X      if (quantity <= ap->cargo.people && quantity > 0) {
X	ap->cargo.people -=quantity;
X	recip->cargo.people += quantity;
X      }
X      else statline2_err ("hit space", "Invalid quantity");
X      break;
X    default:
X      break;
X    }
X  }
X  adjust_cargo (ap);
X  adjust_cargo (recip);
X  statline2 ("", "");
X}
X
X#define is_city(sp) (sp->designation == D_CITY || sp->designation == D_CAPITAL)
X
X/* you can only load a caravan in certain places */
Xgood_loading_place(np, sp, type, quantity)
X     Snation *np;
X     Ssector *sp;
X     char type;			/* type of cargo */
X     int quantity;		/* amount, or army id */
X{
X  Sarmy *ap, *get_army();
X
X  switch (type) {
X  case 's':
X    if (!(sp->owner == np->id) || !is_city(sp)) {
X      return 0;
X    }
X    break;
X  case 'm':
X    if (!(sp->owner == np->id) || !(is_city(sp) ||
X				 sp->designation == D_METAL_MINE)) {
X      return 0;
X    }
X    break;
X  case 'j':
X    if (!(sp->owner == np->id) || !(is_city(sp) ||
X				    sp->designation == D_JEWEL_MINE)) {
X      return 0;
X    }
X    break;
X  case 'f':
X    if (!(sp->owner == np->id) || (!(is_city(sp) ||
X				    sp->designation == D_FARM))) {
X      return 0;
X    }
X    break;
X  case 'p':
X     /* you can only load people in your own non-hostile sectors */
X    if (!(sp->owner == np->id)|| !(good_altitude(sp, np))||(has_hostile(sp))) {
X      return 0;
X    }
X    break;
X  case 't':
X      /* you can only load a title in your own land, 
X         and if the sector is not traded. */
X    if ((sp->owner != np->id) || !(good_altitude(sp, np))) {
X      return 0;
X    }
X    break;
X  case 'a':
X    if (!(ap = get_army(np, quantity))
X	|| !(army_is_in_sector(sp, np->id, quantity))
X	|| ((sp->owner != np->id) && !is_front_line (ap) &&
X	sp->designation != D_TRADE_POST)) { 
X      return 0;
X    }
X    break;
X  case ' ':			/* this means we don't really load */
X    break;
X  default:			/* bad type (someone screwed up) */
X    return 0;
X  }
X  return 1;
X}
X
X/* you can only unload a caravan in certain places */
Xgood_unloading_place(np, sp, type, quantity)
X     Snation *np;
X     Ssector *sp;
X     char type;			/* type of thing being unloaded */
X     int quantity;		/* how much, or army id */
X{
X  Sarmy *ap, *get_army();
X
X  switch (type) {
X  case 's':
X  case 'm':
X  case 'j':
X  case 'f':
X  case 't':
X    if ((np->id == sp->owner) || (is_trade_place(sp))) {
X      return 1;
X    }
X    return 0;
X  case '*':
X    return 1;
X  case 'p':
X    if ((sp->designation == D_TRADE_POST || sp->owner == np->id)
X	&& good_altitude(sp, np)) {
X      return 1;
X    }
X    return 0;
X  case 'a':
X    if (!(ap = get_army(np, quantity))) {
X      return 0;
X    }
X    if (!good_army_altitude(np, sp, ap)) {
X      return 0;
X    }
X    if (sp->owner == np->id) {
X      return 1;
X    }
X    if (is_front_line(ap)) {
X      return 1;
X    }
X    if (sp->designation == D_TRADE_POST) {
X      return 1;
X    }
X    return 0;
X  case ' ':
X    return 1;
X  default:
X    return 0;
X  }
X/*
X  if (np->id == 0) {
X    return 0;
X  }
X  if (np->id == sp->owner) {
X    return 1;
X  }
X  if ( (np->id != sp->owner) && (sp->designation == D_TRADE_POST) ) {
X    return 1;
X  }
X  return 0;
X*/
X}
X
X
X/* keeps a status line on the transportation window which
X   which shows you the cargo on the currently selected army */
Xcargo_statline(w, up)
X     WINDOW *w;
X     Suser *up;
X{
X  char * s;
X  Sarmy *ap, *get_army();
X  char * make_cargo_statline ();
X
X  if ((ap = get_army(up->np, up->current_army)) == NULL) {
X    return;
X  }
X  
X  s = make_cargo_statline (&ap->cargo);
X
X  if (w) {
X    mvwaddstr(w, 5, 2, s);
X    wclrtoeol(w);
X    box (w, '|', '-');
X    wrefresh(w);
X  } else {			/* if w is NULL, we are in xmode */
X    statline(s, "transp[l,u,t]");
X  }
X}
X
X/* gives cargo from one nation to another */
Xdonate_cargo(x, y, from_id, to_id, cargo)
X     int from_id, to_id;
X     Scargo *cargo;
X{
X  Sarmy *ap, *get_army();
X  Ssector *sp;
X  FILE *fp, *fopen();
X  struct argument args[N_EXEC_ARGS];
X  char s[NAMELEN];
X  int n_people;
X
X  while (cargo_is_locked()) {
X    sleep(1);
X  }
X  critical();
X  lock_cargo();
X  if ((fp = fopen(CARGO_FILE, "a")) == NULL) {
X    statline("hit space", "serious error:  cannot append to trade file");
X    get_space();
X    return;
X  }
X    /* coordinates of where the trade happened */
X  fwrite(&x, sizeof(int), 1, fp);
X  fwrite(&y, sizeof(int), 1, fp);
X  fwrite(&from_id, sizeof(int), 1, fp);
X  fwrite(&to_id, sizeof(int), 1, fp);
X  fwrite(cargo, sizeof(Scargo), 1, fp);
X    /* handle the donation of an army */
X  if ((ap = get_army(user.np, cargo->army)) != NULL) {
X    fwrite(ap, sizeof(Sarmy), 1, fp);
X    if (!is_spirit (ap)) {
X      n_people = ap->n_soldiers;
X    }
X    else n_people = 0;
X    sprintf(s, "ADISBAND:%d\n", ap->id);
X    gen_exec(s);
X    parse_exec_line(s,args);
X    run_exec_line(user.np,args);
X    /* Unfortunately, ADISBAND puts the people from the disbanding
X       onto the trade sector, thus furnishing some free people ... */
X    sp = &world.map[ap->pos.x][ap->pos.y];
X    cpeople_sector (sp, -n_people);
X    sp->n_people -= n_people;
X    delete_army_sector(sp, ap);
X    delete_army_nation(user.np, ap);
X  }
X    /* now handle the donation of a land title */
X  sp = &world.map[cargo->title.x][cargo->title.y];
X
X  fclose(fp);
X  unlock_cargo();
X  noncritical();
X}
X
X/* lock and unlock the cargo data file */
Xlock_cargo()
X{
X  FILE *fp, *fopen();
X  char fname[NAMELEN];
X
X  strcpy(fname, CARGO_FILE);
X  strcat(fname, ".LOCK");
X
X  if ((fp = fopen(fname, "w")) == NULL)
X  {
X    fprintf(stderr,"Error: Cannot open lockfile %s\n",CARGO_FILE);
X    clean_exit();
X    exit(1);
X  }
X}
X
Xunlock_cargo()
X{
X  char fname[NAMELEN];
X
X  strcpy(fname, CARGO_FILE);
X  strcat(fname, ".LOCK");
X
X  unlink(fname);
X}
X
X/* check if the cargo data file is locked */
Xcargo_is_locked()
X{
X  FILE *fp, *fopen();
X  char fname[NAMELEN];
X
X  strcpy(fname, CARGO_FILE);
X  strcat(fname, ".LOCK");
X
X  if ((fp = fopen(fname, "r")) == NULL) {
X    return 0;
X  }
X  fclose(fp);
X  return 1;
X}
X
X/* valid trading places are cities, capitals and trade posts */
Xis_trade_place(sp)
X     Ssector *sp;
X{
X  switch (sp->designation) {
X  case D_CAPITAL:
X  case D_CITY:
X  case D_TRADE_POST:
X    return 1;
X  default:
X    return 0;
X  }
X}
X
X/* returns true if there is a cargo */
X
Xcargo_not_empty(cargop)
X     Scargo *cargop;
X{
X  if (cargop->money > 0 || cargop->metal > 0 || cargop->jewels > 0
X      || cargop->food > 0 || cargop->people > 0 || cargop->army != -1
X      || cargop->title.x != -1 || cargop->title.y != -1) {
X    return 1;
X  }
X  return 0;
X}
X
X/* returns true if we cannot fit this additional load
X   onto the ship or caravan. */
Xload_too_big(np, ap, c, quantity)
X     Snation *np;
X     Sarmy *ap;			/* the carrier */
X     char c;			/* the type of load */
X     int quantity;		/* how much */
X{
X  Sarmy *cargo_ap;
X  float capacity, quantity_weight;
X
X  if (is_cargo (ap)) {
X    capacity = ap->n_soldiers * CARAVAN_CAPACITY;
X  } else capacity = 0;   /* Someone made a booboo */
X
X  switch (c) {
X  case 's':			/* money and other things */
X    quantity_weight = quantity * MONEY_WEIGHT;
X    break;
X  case 'm':
X    quantity_weight = quantity * METAL_WEIGHT;
X    break;
X  case 'j':
X    quantity_weight = quantity * JEWEL_WEIGHT;
X    break;
X  case 'f':
X    quantity_weight = quantity * FOOD_WEIGHT;
X    break;
X  case 'p':
X    quantity_weight = quantity;
X    break;
X  case 'a':
X    if (cargo_ap = get_army(np, quantity)) {
X      quantity_weight = army_weight (cargo_ap);
X    }
X    else { quantity_weight = 0; }  /* no army ?!? */
X    break;
X  case 't':
X    quantity_weight = 0;
X    break;
X  default: /* Someone made a booboo */
X    return 0;
X  }
X  quantity_weight += cargo_weight (&ap->cargo);
X
X  if (quantity_weight > capacity) { 
X    return 1;
X  }
X  
X  return 0;
X}
X
X/* Returns the weight of an army, whether normal or a caravan/navy */
X
Xint army_weight (ap)
X
XSarmy * ap;
X{
X  int weight, index;
X  float weight_per;
X
X  index = army_type_index (ap->type);
X
X  if (is_cargo(ap)) {
X    weight = caravan_weight (ap);
X  }
X  else if (is_spirit (ap)) {
X    weight = ap->n_soldiers;
X  }
X  else {
X    weight_per = ((float) army_types [index].metal_draft / 100.0) + 
X      ((float) army_types [index].metal_maint / 100) + 1.0;
X    weight = weight_per * ap->n_soldiers;
X  }
X  return weight;
X}
X
X/* Returns the weight of a caravan, plus any subsidiary cargo */
X
Xint caravan_weight (ap)
X
XSarmy * ap;
X{
X  int weight = 0, caravan_index;
X
X  caravan_index = army_type_index (ap->type);
X
X  /* Get the weight of the cargo */
X  weight += cargo_weight (&ap->cargo);
X  /* Caravans have 1000 weight (when empty :-) */
X  weight += army_types [caravan_index].metal_draft * ap->n_soldiers;
X
X  return weight;
X}
X
X/* Returns the weight of a cargo */
X
Xint cargo_weight (cargo)
X
XScargo * cargo;
X{
X  int weight = 0;
X
X  if (cargo->army >= 0) {
X    weight += army_weight (get_army (user.np, cargo->army));
X  }
X  weight += cargo->people;
X  weight += cargo->jewels * JEWEL_WEIGHT;
X  weight += cargo->metal * METAL_WEIGHT;
X  weight += cargo->food * FOOD_WEIGHT;
X  weight += cargo->money * MONEY_WEIGHT;
X
X  return weight;
X}
X
X/* Builds cargo statline out of the cargo struct */
X
Xchar * make_cargo_statline (cargo)
X
XScargo * cargo;
X{
X  char * rstatline;
X  char tmps [60];
X
X  if ((rstatline = (char *)malloc (sizeof (char) * 100)) == NULL) {
X    clean_exit();
X    exit (-1);
X  }
X
X  sprintf (rstatline, "(%d mw)", cargo_weight (cargo));
X
X  strcat (rstatline, contents (cargo->money, cargo->metal, cargo->jewels,
X			       cargo->food, cargo->people, cargo->army,
X			       &cargo->title, 0));
X
X  return rstatline;
X}
X
X/* puts out an exec line describing the new cargo of a caravan */
Xadjust_cargo(ap)
X     Sarmy *ap;
X{
X  char s[EXECLEN];
X
X  sprintf(s, "ACARGO:%d:%d:%d:%d:%d:%d:%d:%d:%d\n", ap->id, ap->cargo.money,
X       ap->cargo.metal, ap->cargo.jewels, ap->cargo.food,
X       ap->cargo.people, ap->cargo.army, ap->cargo.title.x, ap->cargo.title.y);
X  gen_exec(s);
X}
END_OF_FILE
if test 27480 -ne `wc -c <'transport.c'`; then
    echo shar: \"'transport.c'\" unpacked with wrong size!
fi
# end of 'transport.c'
fi
echo shar: End of archive 18 \(of 28\).
cp /dev/null ark18isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Now execute ./do_cat.sh to build doc files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
