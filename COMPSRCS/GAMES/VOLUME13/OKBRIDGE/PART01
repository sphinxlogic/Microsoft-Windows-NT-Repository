Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i016:  okbridge - computer-mediated bridge game, Part01/07
Message-ID: <2275@masterCNA.TEK.COM>
Date: 10 Jan 92 16:44:09 GMT
Sender: news@masterCNA.TEK.COM
Lines: 1609
Approved: billr@saab.CNA.TEK.COM

Submitted-by: mclegg@cs.UCSD.EDU (Matthew Clegg)
Posting-number: Volume 13, Issue 16
Archive-name: okbridge/Part01
Environment: BSD-derived Unix, curses, sockets



	[This is a multiplayer networked bridge game that uses the
	 computer to handle dealing, scoring, etc. It was inspired
	 by the 'bridge' game posted in c.s.g. (v4i019/20), but has
	 been completely rewritten.  -br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 7)."
# Contents:  README MANIFEST README.Install README.Playing network.c
#   terminal.c
# Wrapped by billr@saab on Fri Jan 10 08:31:27 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(3772 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
Xintro -- introduction to the okbridge program
XMatthew Clegg.  August 1990.
X
X
XGeneral Description
X------- -----------
X
XThe okbridge program is an interactive computer-mediated bridge game.
XIt allows four players at (not necessarily) different locations on the
Xinternet to participate in a game of rubber or Chicago (duplicate)
Xbridge.  The program handles the dealing, scoring and communication of
Xbids and plays.  It is screen oriented, although the screen display is
Xrather simplistic.
X
X
XCopyright Notice
X--------- ------
X
XCopyright (C) 1990,1991 by Matthew Clegg
X
XThis program may be copied and distributed freely.  Please do not
Xcharge money for this program or for any program derived from it.
XIf you modify this program, then include a notice stating plainly
Xthat your program is derived from the okbridge program and is not
Xthe same as the official okbridge program.
X
XI welcome any suggestions for improvement to okbridge, and 
XI would be especially happy to receive improved source code.
XIf you have comments or suggestions, or if you would like to
Xjoin the okbridge mailing list, then write to
X
X  mclegg@cs.ucsd.edu
X
X
X
XSystem Requirements
X------ ------------
X
XThe program has been compiled and tested on a few SUN and VAX systems
Xrunning derivatives of BSD UNIX.  The okbridge program uses the
X"curses" library, which is available at most sites.  It also requires
Xthat the machine on which it is running be an internet site.  If you
Xobtained this software through the use of the 'ftp' program, then your
Xmachine is probably an internet site.  The source code is written in
Xthe C programming language.
X
X
XHistory
X-------
X
XMy interest in bridge began as an undergraduate at the University of
XCalifornia, Riverside, where I learned the game.  After some time, I
Xended up in Berkeley :-), while one of my best bridge-playing friends
Xsomehow wound up stuck in Oklahoma :-(.  But then a bridge program was
Xdiscovered archived somewhere on the net, and we happily continued
Xplaying.  When I later moved to Finland (my wife is Finnish :-), it
Xbecame impossible to use this program anymore.  So, I set out to write
Xa new bridge program which would correct the deficiencies of the old one.
X
XThe old bridge program was quite inspirational, but it was also rather
Xidiosyncratic.  Perhaps the difficulties with it can best be described
Xby the authors themselves:
X
X        This program provides communication between different
X        machines so that people can play bridge even they are
X        on different machine.  It is written by Shyan-Ming
X        Yuan and Jiang-Hsing Chu at University of Maryland,
X        College Park.  It was tested on Vaxes and Sun 3/50
X        running BSD 4.2 and BSD 4.3.  Since we don't have the
X        previlege to create a 'bridge daemon' as a normal
X        user, we decided to use 'talk daemon' instead.  The
X        underlying communication program is modified from the
X        'talk' program.  You will have confusion in trying to
X        connect to the others...
X
XIn particular, we found that the talk daemons on various systems were
Xoften incompatible.  So it was only possible for us to play when all
Xfour of us logged onto a single machine via telnet.  In writing the
Xnew program, I have abandoned the use of the 'talk daemon' in favor of
Xestablishing the network connections directly through operating system
Xcalls.  This has the advantage that it is universally standardized and
Xperhaps faster and more reliable.  Also, the user interface for the
Xold program was very unforgiving.  I have tried to correct this
Xdeficiency too.
X
X
X
XFurther Documentation
X------- -------------
X
XREADME.Install 
X  Instructions about how to compile and install the program on your system.
X
XREADME.Playing
X  Instructions about how to operate the program.
END_OF_FILE
if test 3772 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1199 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X MakeDistrib                2	
X Makefile                   7	
X README                     1	
X README.Install             1	
X README.Playing             1	
X Revisions                  7	
X bridge.c                   2	
X code.c                     6	
X code.h                     7	
X display.c                  5	
X display.h                  7	
X email.c                    5	
X email.h                    6	
X globals.h                  6	
X help.c                     6	
X help.h                     7	
X helpfile.h                 2	
X input.c.aa                 3	
X input.c.ab                 4	
X input.h                    6	
X network.c                  1	
X network.h                  7	
X okbridge.help              5	
X okbridgerc                 7	
X okshuffle.c                7	
X oktally.c                  6	
X ps.c                       5	
X ps.h                       7	
X scoring.c                  6	
X scoring.h                  7	
X socket.c                   7	
X startup.c                  3	
X terminal.c                 1	
X terminal.h                 7	
END_OF_FILE
if test 1199 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README.Install' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.Install'\"
else
echo shar: Extracting \"'README.Install'\" \(1004 characters\)
sed "s/^X//" >'README.Install' <<'END_OF_FILE'
X
Xsetup -- how to compile the okbridge program
XMatthew Clegg.  August 1990.
X
X
XMaking the okbridge program
X------ --- -------- -------
X
XThe okbridge program is distributed in a compressed tar file called
Xokbridge.tar.Z.  The following two commands can be used to uncompress
Xand untar the okbridge program:
X
X     uncompress okbridge.tar.Z
X     tar -xf okbridge.tar
X
XBefore compiling the program, you may want to edit the makefile.
XYou will have to decide where you would like the okbridge executable
Xto reside and you will also have to decide where you would like the
Xokbridge help file to reside.  The location of the executable is
Xspecified with the variable OKBRIDGE_DIR.  The directory where the
Xhelp file will be stored is specified with the variable OKBRIDGE_HELPFILE.
X
XTo compile okbridge, you would then simply type 'make'.  To then
Xinstall the program, you should type 'make install'.  If you do not
Xplan to install the program in a public directory, then there is no
Xneed to type 'make install'.
X
END_OF_FILE
if test 1004 -ne `wc -c <'README.Install'`; then
    echo shar: \"'README.Install'\" unpacked with wrong size!
fi
# end of 'README.Install'
fi
if test -f 'README.Playing' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.Playing'\"
else
echo shar: Extracting \"'README.Playing'\" \(29891 characters\)
sed "s/^X//" >'README.Playing' <<'END_OF_FILE'
X
Xplaying -- how to operate the okbridge program
XMatthew Clegg.  September 1990.  Updated May 1991.
X
X
XArranging the Game
X--------- --- ----
X
XThe prerequisites for using the okbridge program are (1) there must
Xbe four people wishing to play bridge together, and (2) each of these
Xpersons must have access to a computer on the internet where the okbridge
Xprogram has been compiled.  In addition, these players must reach prior
Xagreement on the points outlined below.
X
XFirst, the players must agree on a common time to play.  The okbridge
Xprogram is interactive, in the sense that it requires simultaneous
Xparticipation by all of the players. 
X
XSecond, the players must agree about who will be `sitting' in which
X`chair' around the bridge table.  Conceptually, the players will be
Xsitting at a table where the chairs are labeled north, south, east
Xand west.  North and south will form one team, while east and west
Xwill form the other.  North will be the dealer in the first hand. 
X
XAnd third, the players must agree about who will be the `server'.
XThis is a networking issue which does not affect the play of the game.
XThe program is built so that all of the messages between the players
Xare mediated (invisibly) by a single player.  This arrangement has
Xsimplified the design of the communication protocols.  However, it
Xrequires that the players decide beforehand who will act as the
Xserver.  I suspect that the performance of the okbridge program
Xmight be slightly improved if the server is `centrally located' with
Xrespect to the other players.
X
X
XInvoking the okbridge Program
X-------- --- -------- -------
X
XThe situation we are about to describe is one where each of the four
Xplayers is sitting at his or her terminal, ready to begin a game of
Xbridge.  We describe how to begin the game from the point of view of
Xa particular (but arbitrary) player.  This particular player will be known
Xas the "local" player, while the other three players will be referred to
Xas "remote" players.  Given this point of view, the command which the
Xlocal player should type is as follows:
X
X    okbridge [-c] [-d] [-i] [-e] [-R] position name server
X	[-p portno] [-r replay-file] [-l autoload-file] [-L logfile]
X	[-z# zhang-logfile]
X
Xwhere
X
X    -c, -d, -i, -e, -R
X      are optional parameters to indicate that the playing and
X      scoring conventions respectively for Chicago, Duplicate,
X      simulated IMP, Email duplicate, or Rubber bridge should be used.
X      These parameters are only relevant for the player whose
X      position is 'n' (north). In other words, north makes the 
X      decision for everyone about the scoring convention that will be 
X      used.  If this parameter is omitted, then the playing and scoring
X      conventions will default to those of rubber bridge.  The -R
X      parameter is suppplied for the sake of overriding any default
X      which may appear in the .okbridgerc file.
X
X    position    
X      is one of the characters: 'n', 's', 'e', or 'w'.  This specifies
X      which seat the local player wishes to have in the game. 
X
X    name 
X      is the name (a single word) which will be used to identify the 
X      local player.  If this is omitted, then the local player's position  
X      will be used.
X
X    server
X      is the name (internet host name or address) of the remote machine 
X      where the `server' will be playing.  If server is omitted, then the 
X      local player will assume the role of the server.
X
X    -p portno
X      specifies the port number which will be used for establishing
X      the network connections.  It is only in unusual circumstances
X      that this parameter need be specified.
X
X    -r replay-file
X      specifies that the file "replay-file" contains a sequence of 
X      duplicate deals which should be played and then recorded back
X      to the file after play.  This is equivalent to the REPLAY command
X      in the .okbridgerc file.  See the description of email duplicate 
X      bridge below.
X
X    -l autoload-file
X      specifies that the file "autoload-file" contains a sequence of
X      duplicate deals which should be played (but will not be recorded
X      back to the same file after play).  This is equivalent to the
X      LOAD command in the .okbridgerc file.  See the description of
X      email duplicate bridge below.
X
X    -L logfile
X      specifies the name of the file to which the results of play will
X      be written.  This is equivalent to the LOG command in the
X      .okbridgerc file.
X
X    -z# [zhang-logfile]
X      specifes an alternate log file which will be recorded in the
X      format developed by Shangyou Zhang.  The character '#' should
X      be replaced by a table number.  If the name of the file is
X      omitted, then the name "okb_#_rec" will be used.
X
X
XHere is an example.  Suppose that the names of the players are Alex,
XBob, Cathy and Dot.  Alex and Cathy will be one team, while Bob and Dot
Xwill be the other.  They decide that Alex will be north, and Bob will be
Xeast.  Further, they decide that Bob will be the server.  Here is a
Xlist of the commands that each might use to invoke the okbridge program
Xon their respective (hypothetical) machines:
X
X   Name    Position  Machine         Command to invoke okbridge
X   ----    --------  -------         --------------------------
X   Alex    north     a.alaska.edu    okbridge n Alex b.berkeley.edu
X   Bob     east      b.berkeley.edu  okbridge e Bob
X   Cathy   south     c.florida.edu   okbridge s Cathy b.berkeley.edu
X   Dot     west      d.maine.edu     okbridge w Dot b.berkeley.edu
X
XWhen the okbridge program first begins, it will attempt to establish
Xthe network connections with the other players.  There will be no
Xactivity on the screen at this time -- the okbridge program is
Xsilently waiting for the other players to join the game.  The length
Xof this wait is of course determined by the time at which the last
Xperson joins the game.  When the last person has joined the game, the
Xfirst hand will be dealt automatically and your cards will be
Xdisplayed.  If the okbridge program waits for ten minutes without
Xmanaging to establish the connections, then it gives up.
X
X
XThe Modes of Operation
X--- ----- -- ---------
X
XThere are two major phases in the playing of a hand of bridge.
XIn the first phase, the players take turns bidding for the contract.
XWhen this phase ends, the contract and trump suit have been decided.
XIn the second phase, the cards are played and the tricks are taken.
XWhen this phase ends, the hand can be scored.  The operation of the
Xokbridge program is similarly divided into two phases, which reflect 
Xthese two phases of play.
X
XWe will refer to the first of these two phases as the `bidding' phase.
XFor lack of a better word, we will refer to the second of these two phases
Xas the `playing' phase.  Unfortunately, the verb `to play' is already
Xbeing used in other contexts, and I'm afraid this may lead to some
Xambiguity.
X
X
XThe Display and Entering Input
X--- ------- --- -------- -----
X
XHere we give an example of the screen display during bidding.  The numbers
Xin the left column do not actually appear on the screen -- they are given
Xfor reference purposes only.
X
X   ========================================================================
X 1 OKBRIDGE  1.3                                                 WE    THEY
X 2                                                            -----   -----
X 3 cathy's BID                                        TRICKS      0       0
X 4                                                    ABOVE       0       0
X 5    alex    bob     cathy   dot       |cathy        BELOW       0       0
X 6    ----    ---     -----   ---       |-----        VUL        NO      NO
X 7 1  1C      --                        |S KQ7642
X 8                                      |H 652
X 9                                      |D 76
X10                                      |C K9
X11 
X12 
X13 
X14
X15 
X16 BID   1s
X17 TALK
X18 
X19 ------------------------------------------------------------------------
X20 |MODERATOR: WEST HAS JOINED THE GAME                                   |
X21 |MODERATOR: WELCOME TO OKBRIDGE, BY MATTHEW CLEGG                      |
X22 |MODERATOR: TYPE /HELP FOR INSTRUCTIONS ABOUT THIS PROGRAM             |
X23 |MODERATOR: ACKNOWLEDGMENT RECEIVED FROM bob                           |
X24 |MODERATOR: ACKNOWLEDGMENT RECEIVED FROM alex                          |
X   ========================================================================
X
XIn the upper right corner of the screen (lines 1-6), the scores are
Xdisplayed.  The number of tricks taken by each side is displayed on
Xline 3.  The points above and below the line for each side are displayed
Xon lines 3 and 4, respectively.  And an indication of which sides are
Xvulnerable is displayed on line 6.  It has been pointed out to me that
Xduring ordinary bridge play, the scores are only available to the players
Xbetween hands and not during the bidding and playing.  I apologize that
Xthe okbridge program is not faithful to the real game in this respect.
X
XAt the left hand margin of line 3, we can see that it is now Cathy's turn
Xto bid.  On lines 5-9, we can see the bids that have been made up to
Xthis point.  The display shows that Alex has bid 1 Club, while Bob has
Xpassed.  Cathy's cards are displayed to the right of this table of bids.
X
XLine 16 is the place where the local player's input to the program is
Xentered.  The word `BID' at the lefthand margin is printed by the program
Xand indicates that the program is expecting Cathy to type her bid.
XThe characters `1s' were entered by Cathy, and they indicate that she
Xintends to bid 1 Spade.  At the time this screen was copied, the
Xcursor was located just to the right of the letter `s' in `1s'.
XIf Cathy now presses the return key, then the bid 1 Spade will be
Xtransmitted to the other players.
X
XLine 17 is the line where the local player may type messages which will
Xbe transmitted to the other players.  The position of the cursor is
Xcontrolled by the okbridge program, and the cursor alternates between
Xlines 16 and 17.  When it is the local player's turn to enter a bid or play,
Xthe cursor is automatically placed on line 16.  At all other times, the
Xcursor is placed on line 17.  The local player may type a message on
Xline 17, and after pressing the return key, the message will be 
Xtransmitted to each of the other players.
X
XWhen entering input, the backspace and delete keys will erase the last
Xcharacter typed.  The escape key erases the entire input line.  And
Xpressing control-R causes the entire screen to be redrawn from scratch.
XAlways press return to have your input transmitted to the other players.
X
XThere is a `default' input option embedded in the input processor.
XWhen the input line is empty, pressing return results in the display
Xof a `default' input.  When in bidding mode, the default input is
Xalways `pass'.  When in playing mode, the default input is the lowest
Xranked card, where the trumps are ranked above all others.  Pressing
Xreturn a second time (i.e., after the default input has been
Xdisplayed) causes the default input to be transmitted to the other
Xplayers.  Sometimes in playing mode there is only one legal input.
XIn this case, this input is displayed automatically -- you need only
Xpress return to transmit it to the other players.
X
XLines 20 through 24 display messages from the program and from other
Xplayers.  Each message is of the form `source: text', where `source'
Xis either MODERATOR or the name of one of the players.  Messages from
Xthe MODERATOR give information about the internal state of the program.
X
X
XBidding
X-------
X
XThe rules for bidding in the okbridge program follow the standard
Xrules in rubber bridge.  I think the only thing that needs to be
Xspecified here is the syntax of a bid.
X
XA contract bid is specified by giving the level and then the trump suit.
XThe level is given as an integer in the range 1-7, while the trump
Xsuits are of course clubs, diamonds, hearts, spades and no trump. 
XHowever, the name of the trump suit may be abbreviated to its initial
Xletter.  Thus, here are some examples of legal contract bids:
X  1c, 1 c, 1 C, 1 club, 1 CLUB
X  1d, 1h, 1s, 1n, 2c, 2d, 2h, 2s, 2n, 3c, 3d, 3h, 3s, 3n, ...
X  1 n, 1 no trump, 1 nt
X
XA passing bid is given by entering `pass' or just `p'.
XA doubling bid is given by entering `double' or `d' or `X'.
XA redoubling bid is given by entering `redouble' or `XX'.
X
X
XPlaying
X-------
X
XSimilarly to bidding, I think the only thing that needs be specified
Xin playing is the syntax of a play.  A play of course consists of a
Xselection of a card from the hand of the local player.  The name of
Xa card is specified by giving its suit and then its rank.  The ranks
Xof the honor cards are `ten', `jack', `queen', `king' and `ace', but 
Xthis can be abbreviated to the first letter.  Thus, one way to
Xspecify each of the cards in the deck is 
X
X    C2, C3, C4, C5, C6, C7, C8, C9, CT, CJ, CQ, CK, CA
X    D2, D3, D4, D5, D6, D7, D8, D9, DT, DJ, DQ, DK, DA
X    H2, H3, H4, H5, H6, H7, H8, H9, HT, HJ, HQ, HK, HA
X    S2, S3, S4, S5, S6, S7, S8, S9, ST, SJ, SQ, SK, SA
X
XNote that CT for example could also be specified as `club t',
X`c ten' or `club ten'.
X
X
XCommands
X--------
X
XThere a number of special commands that are available in the okbridge
Xprogram.  These special commands are invoked by entering at the beginning
Xof a line a slash `/', the name of the command, and perhaps some
Xparameters.  Here is a brief list of the available commands:
X
X
X     /BELL [ON|OFF]
X       By default, the okbridge program rings the terminal's bell whenever
X       it requests input from you.  However, this can be disabled by
X       typing '/BELL OFF'.
X
X     /CLAIM [n]
X       This command 'claims' n additional tricks for the declarer.
X       If n is omitted, then all remaining tricks are claimed.
X       The other players are shown the declarer's hand and are
X       asked whether or not they agree to the declarer's request.
X       If both agree, then the hand is ended early.  This command can
X       be used only by the declarer and only when it is declarer's or
X       dummy's turn to play.
X
X     /DEAL [nhands]
X       This command can only be used by north when playing Email
X       duplicate bridge.  It causes nhands hands to be dealt and
X       played.  After they have been played, the results can be
X       /SAVEd and emailed to another foursome for play.
X
X     /DEFAULT [ON | OFF]
X       This command controls whether or not defaults will be provided
X       for bids, plays and questions.
X
X     /LOAD filename
X       This command can only be used by north when playing Email
X       duplicate bridge.  It causes a series of boards to be read
X       from the file "filename".  
X
X     /HELP [topic]
X       Type '/HELP' alone to obtain general help, or type
X       '/HELP topic' to obtain help about a particular topic.
X
X     /LOG [filename]
X       Typing '/LOG filename' causes this hand and subsequent hands
X       to be written to the file with name 'filename'.  If '+filename'
X       is specified, then the log is appended to 'filename'.  Otherwise,
X       'filename' is overwritten.  Omitting 'filename' causes the current 
X       log file to be closed.
X
X     /PING
X       Sends an invisible message to each of the other players, which is
X       automatically echoed.  Reports the round-trip communication time.
X
X     /PROMPT [ON|OFF]
X       By default, the dummy is asked to press RETURN after the end
X       of each trick.  This allows the dummy to see each trick as
X       it is played.  This prompting can be disabled by typing
X       '/PROMPT OFF' (convenient if you need to run to the wc :-)
X
X     /REPLAY filename
X       This command can only be used by north when playing email bridge.
X       It first causes a sequence of boards to be read from filename, like
X       the /LOAD command.  After the boards have been played, they are
X       automatically saved along with the results of play back to the file
X       from which they were read.
X
X     /REVIEW
X       This command displays the bidding for review.  (It is intended
X       to be used during the playing mode.)
X
X     /QUIT
X       Terminates the program.
X
X     /SAVE filename
X       This command causes the set of boards which have been played
X       so far to be saved to a the file with name filename.  These
X       boards can then be emailed to another foursome for competitive
X       play.  Note that the /SAVE command can be used by any player
X       at any time.  However, the previous results of play by other
X       foursomes will only be recorded if /SAVE is used by north.
X
X     /TALK message
X       Sends a short message to the other players.  This command can be used
X       when the program is waiting for you to enter a bid or a play.  
X       Not needed if the word 'TALK' is displayed to the left of the cursor.
X
X
XControl-Character Equivalents
X----------------- -----------
X
XThe following control characters have special meaning to okbridge:
X 
X  ^B -- If in the playing mode, a review of the bidding is displayed.
X  ^C -- Same as the /QUIT command.
X  ^D -- Toggles the default input mode (see the /DEFAULT command above).
X  ^G -- Toggles the bell (see the /BELL command above).
X  ^P -- Toggles the dummy prompting (see the /PROMPT command above).
X  ^R -- Refreshes the screen.
X
X
XScoring
X-------
X
XThe following tables give a basic outline of how okbridge computes
Xthe scores.  It was derived from the documentation supplied with
Xthe bridge program written by Yuan and Chu.
X
X
XTrick Score (below the line)
X
XIf the contracting team succeeds in making their contract,
Xthen the base score for the hand is computed according to
Xthe following chart.  For rubber bridge, the score computed
Xaccording to the number of tricks bid.  For other scoring
Xmethods, the score is computed according to how many tricks
Xwere actually made.
X
XSpades of Hearts	30 per trick	|  If doubled:
XDiamonds or Clubs	20 per trick	|	multiply by 2
XNotrump		40 for first trick	|  If redoubled:
X	30 for each additional trick	|	multiply by 4
X
XIn a doubled contract in rubber bridge, overtricks are
Xscored at 100 points each if not vulnerable and 200 points
Xeach if vulnerable.  In a redoubled contract in rubber bridge,
Xovertricks are scored at 200 and 400 respectively.
X
XIn rubber bridge, a game is scored if 100 points or more are
Xaccumulated below the line.  The scoring side then becomes
Xvulnerable and wins the rubber if they win a second game.
XIn other forms of bridge, the vulnerability proceeds according
Xto a rotation.  In the first hand, neither side is vulnerable.
XFor the next two hands, the dealer's side is vulnerable.  And
Xfor the fourth hand, both sides are vulnerable.  For Duplicate,
XIMP and Email scoring, the rotation then starts over.  For Chicago
Xbridge, the rotation does not repeat itself until 16 hands have 
Xbeen played.
X
X
XBonuses
X
XFor rubber bridge, there is a bonus for winning the rubber,
Xwhich is scored as follows: 
X
XRubber bonus:	500 if you win two games out of three
X		700 if you win the only two games
X
X
XFor all forms of bridge, there is a bonus for making a slam.
X
X			Not Vulnerable		Vulnerable
XSlam Bonus:  Small Slam	     500		    750
X	     Grand Slam	    1000		   1500
X
XIn rubber and Chicago bridge, there is a bonus if the contracting
Xside has enough honor cards in the trump suit:
X
XHonors:  4 trump honors in one hand		100
X	 5 trump honors in one hand		150
X	 4 aces in one hand at notrump		150
X
XIn non-rubber bridge, there is a 300 point bonus for bidding
Xand making a game when not vulnerable.  The bonus is 500 points
Xif vulnerable.
X
XMaking Doubled (or redoubled) Contract:	 50 points
X
XPenalties (above the line)
X
X			Undoubled		Doubled
X		Not Vul.	Vul.	  Not Vul.	Vul.
XDown 1		   50		100	    100		200
XDown 2		  100		200	    300		500
XDown 3		  150		300	    500		800
XDown 4		  200		400	    700	       1100
XDown 5		  250		500	    900	       1400
XDown 6		  300		600	   1100	       1700
XDown 7		  350		700	   1300        2100
XDown 8		  400		800	   1500	       2500
X  .                .             .           .           .
X  .                .             .           .           .
X  .                .             .           .           .
X
XIf redoubled: multiply the doubled penalty by two.
X
XFor IMP bridge, the base score is computed according to the
Xabove rules for duplicate scoring.  It is then used to determine 
Xan approximate number of international match points according
Xto the following table:
X
X	Duplicate score		IMP points
X	---------------		----------
X	     <=	20		0
X		50		1
X		80		2
X		120		3
X		160		4
X		210		5
X		260		6
X		310		7
X		360		8
X		430		9
X		500		10
X		600		11
X		750		12
X		900		13
X		1100		14
X		1300		15
X		1500		16
X		1750		17
X		2000		18
X		2500		19
X		3000		20
X		3500		21
X		4000		22
X		4500		23
X		above		24
X
XTo this number of IMP points is added 20 minus the number of high
Xcard points held by the contracting team.
X
XPlaying Duplicate Bridge
X------- --------- ------
X
XVersion 1.5 of okbridge introduces an 'email duplicate' scoring
Xmode.  The idea is that a sequence of boards can be read from a
Xfile for play.  After each board has been played, a match point
Xscore is computed for all of the players who have played the board.
XAfter the last board has been played, all of the boards along with
Xthe match point scores can then be written to a file which can
Xbe emailed to another foursome.  This allows for a type of competitive
Xduplicate play.
X
XThe procedure for playing email duplicate is as follows.  To begin
Xa fresh set of boards, north starts the okbridge program with the
X-e scoring option.  He then types /DEAL n, where n is the number of
Xboards he wishes to play.
X
XAfter the boards have been played, north then types /SAVE filename
Xto save the boards along with the results of play to a file.
XThe /SAVE command then creates to files.  One is named "filename"
Xand the other is named "filename.plain".  The first file is intended
Xfor being mailed to another foursome for play.  It contains the
Xboards and the scores, but in an encoded format which is not
Xeasily readable.  The second file contains the same information
Xbut not encoded.  It can be emailed to those who have already
Xplayed these boards, so they can see how well they have competed.
X
XTo play a sequence of boards which have already been played by
Xothers, north should again start the okbridge program with the
X-e option.  He then types /LOAD filename to read the boards from
Xthe file with name filename.  At the end of each hand, the
Xmatch point scores for the playing foursome will be displayed to
Xthem.  After all of the boards have been played, north can save
Xthe boards along with the results of play to a new file by typing
X/SAVE newfilename.  This will create an encoded file named
X"newfilename" which is suitable for mailing to a new foursome
Xand an unencoded file named "newfilename.plain" which is suitable
Xfor mailing to those who have already played these boards.
X
XAlternatively, a sequence of boards can be replayed by using the
X/REPLAY command.  This first causes the boards to be read into the
Xprogram for play.  After they have been played, they are then
Xautomatically saved along with the results back to the file from
Xwhich they were read.
X
XTo create a unplayed set of shuffled boards, use the okshuffle program.
XThe format of the okshuffle command is:
X
X	okshuffle [nboards] [-m "message"] [-d] > <email-filename>
X
Xwhere  
X
X  nboards  
X     is the number of boards to shuffle.  If this is omitted,
X     then 4 is assumed.
X
X  -m "message"
X     is an optional message that will displayed to each of the
X     players as soon as the boards are /LOADed.
X
X  -d
X     specifies that the date of the shuffle should be displayed to each of
X     the players when the boards are /LOADed.
X
XAlso, to merge a number of boards that have already been played,
Xyou can use the oktally program.  The format of the oktally command is:
X
X   oktally [-c] [-sn] file_1 file_2 ... file_n > output-email-file
X
XThe oktally program reads each of file_1, file_2, ..., file_n.  If one
Xof the file names is "-", then standard input is read instead.  It
Xthen merges the boards from these files and totals the match points
Xfor each pair.  It writes the merged set of boards to standard output.
XIf the -c flag is given, then the output is written in encoded format.
XIf the -sn flag is given, then n is read as a positive integer which
Xspecifies the number of boards to skip in the input files.
X
XHere is an example copy of a plain email duplicate file:
X
XThis is an email duplicate file for Okbridge version 1.5
XbxnXwecs8mIQjz6DT7SYuEaFt0goHdqfR1vU2JByiMCrZWL5+9V4hApN-PG3OKlk
X# nboards npairs
X1 4
X
X# pair north/east south/west    match points
X     1 matt       merja         0.0
X     2 doug       ann           1.0
X     3 norm       suzanne       1.0
X     4 ernest     wilma         0.0
X
X# board 1
X# NORTH  CLUBS: Q J T 3,  DIAMONDS: Q 4 3 2,  HEARTS: J T 9 4,  SPADES: 7
X# EAST   CLUBS: A K 4,  DIAMONDS: A 9 6,  HEARTS: 6 2,  SPADES: K 9 5 4 3
X# SOUTH  CLUBS: 9 8,  DIAMONDS: 8 5,  HEARTS: A K Q 7 3,  SPADES: T 8 6 2
X# WEST   CLUBS: 7 6 5 2,  DIAMONDS: K J T 7,  HEARTS: 8 5,  SPADES: A Q J
X# Dealer Vulnerabilities
XNORTH  NONE
XWNEWWWSSNNNEENNNSEWSEWWNWEESNWESWNNNSSSSEEESNSESWWEW
X# ns  ew bid       by result    score  ns-mp  ew-mp
X   1   2 4S        E      +5     -450    0.0    1.0
X   3   4 3NT       E      -1       50    1.0    0.0
X--
X
XThe pairs who have played these boards, along with their respective
Xmatch point scores, are listed at the top of the file.  After the list
Xof pairs follows the list of boards.  For each foursome, there is a
Xscore line indicating how they performed in this board.  The score
Xwhich is printed is relative to the north-south pair.  We see for
Xexample that 4S was bid by east, making 5.  This results in a score of
X+450 for east-west, but relative to north-south it is -450.  The
Xcolumn 'ns-mp' gives the number of match points awarded to north-south
Xfor this board, and the column 'ew-mp' gives the number of match
Xpoints awarded to east-west in this board.
X
X
XThe .okbridgerc initialization file
X--- ----------- -------------- ----
X
XVersion 1.5 of okbridge introduces an initialization file which
Xis automatically read when the program starts.  This initialization
Xfile can specify a number of default settings for the program.
XWhen the program starts, the current working directory is first
Xsearched for a file named ".okbridgerc".  If no file is found, then
Xthe home directory is searched for the same file.  For an example
Xof an .okbridgerc file, see the file in this distribution named
X"okbridgerc".  (Note that it is incorrectly named -- to be read by
Xthe okbridge program, it should be named ".okbridgerc").
X
XEach line in this file is either a comment line or a (field, value) pair.  
XComment lines begin with the pound sign '#' character.  
XField, value pairs are of the format
X<Field-name>	<value>
X
XThe fields which are currently recognized are as follows:
X
XBELL		ON | OFF
X   When requesting input (a bid or a play), the terminal's
X   bell is rung by default.  However, this can be disabled
X   by specifying 'BELL OFF'.  This has the same effect as the
X   '/BELL OFF' command.
X
XHELPFILE	<directory-name>
X   This field specifies the location of the okbridge help file.
X
XLOAD            <email-duplicate-filename>
X   This field is only valid if the position is north and the
X   scoring mode is email duplicate.  In this case, okbridge will
X   automatically read a set of email duplicate boards from the
X   named file.
X
XLOG		<filename>
X   If this statement is present in the startup file, then
X   the hands will automatically be logged to the given filename.
X   If the first character of <filename> is a plus sign '+', then
X   the log is appended to <filename>.  Otherwise, <filename> is
X   overwritten.
X
XNAME		<local-player-name>
X   This field specifies the name that will be used to identify
X   the local player to the other players.  If both the NAME field
X   and the POSITION field are present in the .okbridgerc startup
X   file, then the corresponding parameters can be omitted from
X   the okbridge command line.  In this case, the SERVER field
X   should also be specified in the .okbriderc file.
X
XPOSITION	NORTH | EAST | SOUTH | WEST
X   This field specifies the local player's position.  If both the
X   NAME field and the POSITION field are present in the .okbridgerc
X   startup file, then the corresponding parameters can be omitted
X   from the okbridge command line.  In this case, the SERVER field
X   should also be specified in the .okbridgerc file.
X
XPORT		<positive-integer>
X   This field specifies the internet port number that will be
X   used for communications with the server.  It is usually not
X   necessary to specify a port number.
X
XPROMPT 	        NO | YES
X   The value of this field is only relevant in hands where the
X   local player is the dummy.  In this case, the dummy is
X   ordinarily prompted to press RETURN at the end of each trick.
X   This allows the dummy to see the cards that are played as they
X   are played.  However, if 'PROMPT NO' is specified, then the
X   dummy will not be prompted.
X
XREPLAY          <email-duplicate-filename>
X   This field is only valid if the position is north and the
X   scoring mode is email duplicate.  In this case, a set of
X   boards will automatically be read from the named file.
X   After they have been played, the results will automatically
X   be written back to the file from which the boards were read.
X
XSCORING	        RUBBER | CHICAGO | DUPLICATE | EMAIL | IMP
X   This field is only relevant if the local player is north.
X   In this case, the SCORING field determines the type of scoring
X   that will be used by default in the game.
X
XSERVER	        ME | <internet-name-or-number>
X   If the value of this field is 'ME', then the local player
X   will assume the role of server.  If the value of this field
X   is anything else, then it is interpreted as an internet name
X   or number of the machine where the server is running.
X
END_OF_FILE
if test 29891 -ne `wc -c <'README.Playing'`; then
    echo shar: \"'README.Playing'\" unpacked with wrong size!
fi
# end of 'README.Playing'
fi
if test -f 'network.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'network.c'\"
else
echo shar: Extracting \"'network.c'\" \(12892 characters\)
sed "s/^X//" >'network.c' <<'END_OF_FILE'
X/* network.c
X ! 
X ! Copyright (C) 1990,1991 by Matthew Clegg
X ! 
X ! This program may be copied and distributed freely.  Please do not
X ! charge money for this program or for any program derived from it.
X ! If you modify this program, then include a notice stating plainly
X ! that your program is derived from the okbridge program and is not
X ! the same as the official okbridge program.
X !
X ! I welcome any suggestions for improvement to okbridge, and 
X ! I would be especially happy to receive improved source code.
X ! If you have comments or suggestions, or if you would like to
X ! join the okbridge mailing list, then write to
X !
X !   mclegg@cs.ucsd.edu
X !
X*/
X
Xextern char *strdup();
X
X
X#include <ctype.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/time.h>
X#ifdef AIX
X#include <sys/select.h>
X#endif
X#include <stdio.h>
X#include <string.h>
X#include <curses.h>
X
X#include "globals.h"
X#include "display.h"
X
X#ifdef   LOOPBACK_MODE
X#define  DEFAULT_PORT	1731
X#else
X#define  DEFAULT_PORT	1729
X#endif
X
X#ifdef LOGFILE
XFILE *netlog;
X#endif
X
Xextern char socket_error [];
X
Xextern char *sys_errlist[];
Xextern int  errno;
Xextern int players_here [];
X
Xint network_port=1729; /* The port number that we will be doing our
X			  communications through. */
Xint server_mode=1;   /* True if we are acting as a server. */
Xint listen_port;     /* The socket descriptor where we check for new
X			connections. */
Xchar *server_name;   /* If we are not acting as a server, then the
X			name of the remote machine. */
Xint clients [5];     /* The file descriptors for the clients that we
X			are serving. */
Xchar client_ids[5];  /* For each client, a character identifying his
X			position.  Only valid if we are the server. */
Xint connections;     /* The number of connections that have been made. */
Xint no_dropped = 0;  /* The number of connections that have been dropped. */
Xint expected;        /* The number of connections we expect to make. */
Xint network_down;    /* After an error, we refuse to send or receive any more
X			messages. */
X
X
Xint check_for_data (f, wait)
Xint f, wait;
X/* Does a poll of the opened file f to see if there is any input
X * data available.  If f is negative, then interprets -f as the
X * real socket number and polls stdin at the same time.
X * If wait is nonzero, then blocks for up to
X * wait milliseconds waiting for data.  If data is available,
X * returns 1.  Otherwise, returns 0.  If an error, returns -1
X * and places an error message in socket_error.
X */
X{
X	struct fd_set ready;
X	struct timeval wait_time;
X	int data_avail;
X
X	wait_time.tv_sec  = wait / 1000;
X	wait_time.tv_usec = (wait % 1000) * 1000;
X
X	FD_ZERO (&ready);
X	if (f < 0) {
X		f = -f;
X		FD_SET (0, &ready);
X	};
X
X	FD_SET  (f, &ready);
X	 
X	data_avail = select (FD_SETSIZE, &ready, (fd_set *) 0, 
X			     (fd_set *) 0, &wait_time);
X	if (data_avail < 0) 
X		sprintf (socket_error, "select error: %s",
X			 sys_errlist[errno]);
X	return (data_avail);
X};
X
Xint check_for_exception (f)
Xint f;
X/* Returns true if an exceptional condition has occurred at
X * file descriptor f.
X */
X{
X	struct fd_set exception_set;
X	struct timeval wait_time;
X	int exception;
X
X	wait_time.tv_sec = 0;
X	wait_time.tv_usec = 0;
X
X	FD_ZERO (&exception_set);
X	FD_SET  (f, &exception_set);
X
X	exception = select (FD_SETSIZE, (fd_set *) 0, (fd_set *) 0, 
X			     &exception_set, &wait_time);
X	if (exception < 0) 
X		sprintf (socket_error, "select error: %s",
X			 sys_errlist[errno]);
X	return (exception);
X};
X
Xint socket_read_line (fd, buf, buflen)
Xint fd; char *buf; int buflen;
X/* Reads characters from the socket fd until a newline character \n
X * is detected.  Copies up to buflen-1 characters into buf, and
X * terminates the string with a null byte.  Returns the number of
X * bytes read.  -1 is returned if the socket is closed or if an
X * exceptional condition has occurred on the socket. 
X */
X{
X	int buflog, readlog, exception;
X	char chbuf[2];
X
X	buf[0] = '\0';
X	if (check_for_exception(fd))
X		return (-1);
X	readlog = read (fd, chbuf, 1);
X	if (readlog == 0)
X	  sprintf (socket_error, "EOF on read from socket");
X	else if (readlog < 0)
X	  sprintf (socket_error, "socket read error: %s",
X		   sys_errlist[errno]);
X	if (readlog <= 0) return (readlog);
X	buflog = 0;
X	while (chbuf[0] != '\0') {
X		if (buflog < buflen-1)
X			buf[buflog++] = chbuf[0];
X		readlog = read (fd, chbuf, 1);
X		if (readlog <= 0) {
X		  buf[0] = '\0';
X		  if (readlog < 0)
X		    sprintf (socket_error, "socket read error: %s",
X			     sys_errlist[errno]);
X		  else
X		    sprintf (socket_error, "EOF on read from socket");
X		  return (readlog);
X		};
X	};
X	buf[buflog] = '\0';
X	return (buflog);
X};
X
Xint initialize_server_mode ()
X{
X  char comment_buf [80];
X  int i;
X
X  sprintf (comment_buf, "ENTERING SERVER MODE ON PORT %d", network_port);
X  Display_Player_Comment ("NETWORK", comment_buf);
X
X  listen_port = open_port (network_port);
X  if (listen_port < 0) {
X    Display_Player_Comment ("NETWORK: ", socket_error);
X    Terminate_Program ("IS THERE ALREADY A SERVER RUNNING?");
X  };
X
X  connections = 0;
X#ifdef LOOPBACK_MODE
X  expected = 0;
X#else
X#ifdef TWOPLAYER_MODE
X  expected = 1;
X#else
X  expected = 3;
X#endif
X#endif
X
X  for (i = 0; i < 4; i++) client_ids[i] = '\0';
X  return (0);
X};
X
Xint initialize_client_mode ()
X{
X  char comment_buf [80];
X
X  sprintf (comment_buf, "CONNECTING TO SERVER AT %s ON PORT %d", 
X	   server_name, network_port);
X  Display_Player_Comment ("NETWORK", comment_buf);
X
X  restore_cursor ();
X
X  clients [0] = client_init (server_name, network_port);
X  if (clients[0] < 0) {
X    network_down = 1;
X    Terminate_Program (socket_error);
X  };
X/*
X  if (clients[0] < 0)
X    return (-1);
X*/
X
X  connections = 1;
X  expected = 1;
X
X  Display_Player_Comment ("NETWORK", "CONNECTION ESTABLISHED");
X  return (0);
X
X};
X  
Xinitialize_network ()
X{
X  int error;
X
X#ifdef LOGFILE
X  netlog = fopen (player_names[local_player], "w");
X#endif
X
X  network_down = 1;
X
X  if (server_mode) 
X    error = initialize_server_mode ();
X  else
X    error = initialize_client_mode ();
X  network_down = 0;
X
X  if (error) {
X    network_down = 1;
X    Terminate_Program (socket_error);
X  };
X};
X
Xclose_connection (connection_no)
X/* Closes the given connection in the list of connections.  If we
X   are a client, then we exit the program. */
X{
X  int i;
X
X
X  if (!server_mode)
X    Terminate_Program ("NETWORK CONNECTIONS CLOSED -- TERMINATING PROGRAM");
X
X  if (clients[connection_no] > 0) {
X    if (game_mode == STARTUP_MODE) {
X      switch (client_ids[connection_no]) {
X      case 'N':
X	players_here[PLAYER_NORTH] = 0;
X	break;
X      case 'E':
X	players_here[PLAYER_EAST] = 0;
X	break;
X      case 'W':
X	players_here[PLAYER_WEST] = 0;
X	break;
X      case 'S':
X	players_here[PLAYER_SOUTH] = 0;
X      default:
X	break;
X      };
X    };
X
X    close (clients[connection_no]);
X    for (i = connection_no; i < connections-1; i++) {
X      clients[i] = clients[i+1];
X      client_ids[i] = client_ids[i+1];
X    };
X    connections--;
X    if (game_mode != STARTUP_MODE)
X      no_dropped++;
X    client_ids[connections] = '\0';
X  };
X};
X 
Xvoid Close_Network_Connection (player_name)
X     char *player_name;
X/* Closes the connection the named player.  Allows the connection to
X   be re-established. */
X{
X  int i, c;
X
X  if (!server_mode) return;
X  c = -1;
X  for (i = 0; i < connections; i++)
X    if (client_ids[i] == *player_name) c = i;
X  if (c < 0) return;
X
X  close (clients[c]);
X  for (i = c; i < connections-1; i++) {
X    clients[i] = clients[i+1];
X    client_ids[i] = client_ids[i+1];
X  };
X  if (game_mode != STARTUP_MODE) no_dropped++;
X  connections--;
X  client_ids[connections] = '\0';
X};
X
Xcheck_for_connections ()
X{
X  struct sockaddr net_addr;
X  int addrlen;
X  char error_buf[80];
X
X  if (network_down) return;
X  addrlen = sizeof(struct sockaddr);
X  if (server_mode) {
X    if (check_for_data (listen_port, 0)) {
X      clients[connections] = accept (listen_port, &net_addr, &addrlen);
X      if (clients[connections] < 0) {
X	sprintf (socket_error, "connection error: %s", sys_errlist[errno]);
X	Display_Player_Comment ("NETWORK ERROR!", socket_error);
X      } else if ((connections + no_dropped) >= expected) {
X	sprintf (error_buf, 
X		 "NORTH SEATERR SORRY -- THERE ARE NO FREE SEATS.");
X	write (clients[connections], error_buf, strlen(error_buf)+1);
X	close (clients[connections]);
X      } else {
X	client_ids[connections++] = '\0';
X      };
X    };
X  };
X};
X
Xsend_message (message)
X	char *message;
X{
X  int i;
X  
X/*  Display_Player_Comment ("NET SENDING",message); */
X  if (network_down) return;
X  check_for_connections ();
X
X  if (server_mode && (client_ids[3] == '\0')) {
X#ifdef LOGFILE
Xfprintf (netlog, "SERVER ID IS %c\n", message[0]);
X#endif
X    client_ids[3] = message[0];
X  };
X
X  for (i = 0; i < connections; i++)
X    write (clients[i], message, strlen(message)+1);
X
X#ifdef LOGFILE
X  fprintf (netlog, "S%s\n", message);
X#endif
X};
X
Xstatic void wait_for_event ()
X/* Blocks until either a message arrives from the network or a
X   key is pressed.
X */
X{
X
X  int i, status;
X  struct fd_set wait_set;     /* A set representing the connections that
X				 have been established. */
X
X  if (network_down) return;
X
X  FD_ZERO (&wait_set);
X
X  while (1) {
X    /* We use a loop here because we think that the select call may
X       occasionally unblock with spurious (keyboard?) events. */
X
X    for (i = 0; i < connections; i++)
X      FD_SET (clients[i], &wait_set);
X
X    if (server_mode)
X      FD_SET (listen_port, &wait_set);
X
X    FD_SET (0, &wait_set);
X
X    status = select (FD_SETSIZE, &wait_set, (fd_set *) 0, (fd_set *) 0, 
X		     (struct timeval *) 0);
X
X    if (FD_ISSET (0, &wait_set))  /* check for keyboard event */
X      return;
X
X    if (server_mode) /* check for new connection */
X      if (FD_ISSET (listen_port, &wait_set))
X	return;
X
X    for (i = 0; i < connections; i++)  /* check for incoming network message */
X      if (FD_ISSET (clients[i], &wait_set))
X	return;
X  };
X};
X
Xint message_available ()
X{
X  int i, status;
X  struct fd_set wait_set;     /* A set representing the connections that
X				 have been established. */
X  struct timeval wait_time;   /* The amount of time to wait in checking our
X				 connections. */
X
X  if (network_down) return;
X  check_for_connections ();
X
X  restore_cursor ();
X
X  wait_for_event (); 
X
X  wait_time.tv_sec = 0;
X  wait_time.tv_usec = 0;
X
X  FD_ZERO (&wait_set);
X
X  /* Check for network data without blocking.  */
X  for (i = 0; i < connections; i++)
X    FD_SET (clients[i], &wait_set);
X
X  status = select (FD_SETSIZE, &wait_set, (fd_set *) 0, (fd_set *) 0, 
X		   &wait_time);
X
X  return (status != 0);
X
X};
X
Xstatic Duplicate_Seat_Error (message, error_port)
X     char *message;
X{
X  char error_buf[100];
X  int i;
X
X  for (i = 0; (message[i] != '\0') && !isspace(message[i]); i++);
X  message[i] = '\0';
X
X  sprintf (error_buf, "DUPLICATE SEAT REQUEST FOR %s", message);
X  Display_Player_Comment ("NETWORK", error_buf);
X
X  sprintf (error_buf, "NORTH SEATERR THE CURRENTLY TAKEN SEATS ARE: ");
X  client_ids[connections] = *("NESW" + local_player);
X  for (i = 0; i <= connections; i++) {
X    switch (client_ids[i]) {
X    case 'S':
X      sprintf (error_buf + strlen(error_buf)," SOUTH");
X      break;
X    case 'E':
X      sprintf (error_buf + strlen(error_buf)," EAST");
X      break;
X    case 'N':
X      sprintf (error_buf + strlen(error_buf), " NORTH");
X      break;
X    case 'W':
X      sprintf (error_buf + strlen(error_buf), " WEST");
X    default:
X      break;
X    };
X  };
X  write (clients[error_port], error_buf, strlen(error_buf)+1);
X  close (clients[error_port]);
X  connections--;
X
X};
X
Xreceive_message (message)
X	char *message;
X{
X  int i, j, log, no_message, in_port;
X
X  message[0] = '\0';
X  if (network_down) return;
X  check_for_connections ();
X  if (!message_available())
X    return;
X
X  no_message = 1;
X  for (i = 0; (i < connections) && no_message; i++)
X    no_message = !check_for_data (clients[in_port = i], 0);
X
X  log = socket_read_line (clients[in_port], message, 100);
X/*  Display_Player_Comment ("NET RECVD", message); */
X  if (server_mode && (log > 0) && (client_ids[in_port] == '\0')) {
X    for (j = 0; j < connections; j++)
X      if ((client_ids[j] == message[0]) || 
X	  (*("NESW" + local_player) == message[0])) {
X	Duplicate_Seat_Error (message, in_port);
X	message [0] ='\0';
X	return;
X      };
X    client_ids[in_port] = message[0];
X#ifdef LOGFILE
Xfprintf (netlog, "ESTABLISHED CLIENT ID OF %c\n", client_ids[in_port]);
X#endif
X  };
X
X  if (log > 0) {
X    for (j = 0; j < connections; j++)
X      if (j != in_port) write (clients[j], message, log+1);
X  } else {
X    if (log < 0)
X      Display_Player_Comment ("NETWORK ERROR!", socket_error);
X    close_connection (in_port);
X    message [0] = '\0';
X  };
X#ifdef LOGFILE
X  fprintf (netlog, "R%s\n", message);
X#endif
X};
X
X
Xreset_network ()
X/* To be called once at the end of the program.  Resets the
X   communications network. */
X{
X  int i;
X
X  for (i = 0; i < connections; i++)
X    close (clients[i]);
X  connections = 0;
X
X  network_down = 1;
X};
END_OF_FILE
if test 12892 -ne `wc -c <'network.c'`; then
    echo shar: \"'network.c'\" unpacked with wrong size!
fi
# end of 'network.c'
fi
if test -f 'terminal.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'terminal.c'\"
else
echo shar: Extracting \"'terminal.c'\" \(2072 characters\)
sed "s/^X//" >'terminal.c' <<'END_OF_FILE'
X/* terminal
X ! 
X ! Copyright (C) 1990,1991 by Matthew Clegg
X ! 
X ! This program may be copied and distributed freely.  Please do not
X ! charge money for this program or for any program derived from it.
X ! If you modify this program, then include a notice stating plainly
X ! that your program is derived from the okbridge program and is not
X ! the same as the official okbridge program.
X !
X ! I welcome any suggestions for improvement to okbridge, and 
X ! I would be especially happy to receive improved source code.
X ! If you have comments or suggestions, or if you would like to
X ! join the okbridge mailing list, then write to
X !
X !   mclegg@cs.ucsd.edu
X !
X*/
X 
X#include <curses.h>
X
Xint cursor_x, cursor_y;   /* The current position of the input cursor. */
X 
XInitialize_Terminal ()
X/* To be called once at the beginning of the program. */
X{
X	initscr ();
X#ifdef ultrix
X	crmode ();
X#else
X	cbreak ();
X#endif
X	noecho ();
X	nonl ();
X};
X 
X 
Xprint (row, col, message)
X	int row, col; char *message;
X/* (1,1) specifies the upper left corner of the screen. */
X{
X	mvaddstr (row-1, col-1, message);
X};
X 
Xint char_avail ()
X/* Returns TRUE if a character is available from the keyboard. */
X{
X	int ch;
X
X	restore_cursor ();
X        return (check_for_data(0,0));
X
X};
X 
Xint input_char ()
X/* Returns the next input character from the keyboard.
X   (The character is echo'ed if it is not a control character.) */
X{
X	int log;
X	char chbuf[2];
X 
X	restore_cursor ();
X	log = 0;
X	while (log < 1) log = read (0, chbuf, 1);
X
X	return (chbuf[0]);
X};
X 
Xset_cursor (row, col)
X	int row, col;
X/* Places the cursor at the specified (row, col). */
X{
X        cursor_x = col-1;
X	cursor_y = row-1;
X	restore_cursor ();
X};
X 
Xrestore_cursor ()
X{
X  move (cursor_y, cursor_x);
X  refresh ();
X};
X
Xclear_screen ()
X{
X	clear ();
X	refresh ();
X};
X 
Xring_bell ()
X/* void ring_bell (void); */
X/* Rings the terminal's bell */
X{
X	addstr ("\007");
X	restore_cursor ();
X};
X
XReset_Terminal ()
X/* To be called at the end of the program to reset the terminal to its
X   initial operating mode. */
X{
X	clear_screen ();
X	endwin ();
X};
X 
END_OF_FILE
if test 2072 -ne `wc -c <'terminal.c'`; then
    echo shar: \"'terminal.c'\" unpacked with wrong size!
fi
# end of 'terminal.c'
fi
echo shar: End of archive 1 \(of 7\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
    echo creating input.c from input.c.aa and input.c.ab
    cat input.c.aa input.c.ab >input.c
    rm -f input.c.aa input.c.ab
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
