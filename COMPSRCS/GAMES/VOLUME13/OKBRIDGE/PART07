Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i022:  okbridge - computer-mediated bridge game, Part07/07
Message-ID: <2281@masterCNA.TEK.COM>
Date: 10 Jan 92 16:45:26 GMT
Sender: news@masterCNA.TEK.COM
Lines: 1367
Approved: billr@saab.CNA.TEK.COM

Submitted-by: mclegg@cs.UCSD.EDU (Matthew Clegg)
Posting-number: Volume 13, Issue 22
Archive-name: okbridge/Part07
Environment: BSD-derived Unix, curses, sockets



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 7)."
# Contents:  Makefile Revisions code.h display.h help.h network.h
#   okbridgerc okshuffle.c ps.h scoring.h socket.c terminal.h
# Wrapped by billr@saab on Fri Jan 10 08:31:30 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(2756 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# makefile for Okbridge 1.5
X#
X# Matthew Clegg.
X#
X
X# In general the okbridge program can be compiled simply by
X# typing 'make'.  If you are planning to install okbridge in
X# a public directory, then you may want to first change the
X# values of the variables OKBRIDGE_DIR and OKBRIDGE_HELPFILE.
X# Then, type 'make install'.
X
XOKBRIDGE_DIR = /usr/local/games
XOKBRIDGE_HELPFILE = /usr/local/games/okbridge.help
X
X# If you are compiling this program on a machine which is
X# running IBM's AIX operating system, then uncomment the
X# next line:
X#MACHINE_FLAGS = -DAIX
X#
X# If you are running on an HP/UX system, you may need to uncomment
X# the following line:
X#MACHINE_FLAGS = -DHPUX
X#
X# If you are compiling this program on a machine which does not
X# have strcasecmp and strncasecmp, then you will need to uncomment
X# the following line (this is not necessary if you are using
X# SunOS or a recent version of Ultrix):
X#STRCASECMP = -DNO_STRCASECMP
X#
X# The following flags may be useful if you have modified the okbridge
X# program and you need assistance debugging it:
X#
X# Uncomment the following line to test the program in LOOPBACK_MODE.
X# CFLAGS = -g -DLOGFILE -DLOOPBACK_MODE -DDEBUG $(STRCASECMP) $(MACHINE_FLAGS)
X# CFLAGS = -g -DDEBUG -DLOGFILE $(STRCASECMP) $(MACHINE_FLAGS)
X# CFLAGS = -g -DDEBUG $(STRCASECMP) $(MACHINE_FLAGS)
XCFLAGS = -g $(STRCASECMP) $(MACHINE_FLAGS)
X
XOBJ = bridge.o input.o display.o terminal.o network.o help.o ps.o socket.o\
X      scoring.o email.o code.o startup.o
X
XSHUFFLEOBJ = okshuffle.o email.o code.o
X
XTALLYOBJ = oktally.o email.o code.o
X
X
X
Xall:	okbridge okshuffle oktally
X
Xokbridge:	$(OBJ)
X	$(CC) -o okbridge $(OBJ) -lcurses -ltermcap
X
Xokshuffle:	$(SHUFFLEOBJ) globals.h
X	$(CC) -o okshuffle $(SHUFFLEOBJ)
X
Xoktally:	$(TALLYOBJ) globals.h
X	$(CC) -o oktally $(TALLYOBJ)
X
Xinstall:	okbridge
X	install okbridge $(OKBRIDGE_DIR)
X	install okshuffle $(OKBRIDGE_DIR)
X	install oktally $(OKBRIDGE_DIR)
X	install -c -m 644 okbridge.help $(OKBRIDGE_HELPFILE)
X
Xclean:
X	rm -f *.o 
X	rm -f tmp*
X	rm -f okbridge okshuffle oktally core tags TAGS
X
Xdistrib:	clean
X		rm -f helpfile.h 
X		rm -f *~
X		csh -f < MakeDistrib
X
Xbridge.o:	bridge.c globals.h ps.h display.h input.h network.h\
X		terminal.h help.h scoring.h
X
Xcode.o:		code.h code.c
X
Xdisplay.o:	display.h display.c globals.h terminal.h
X
Xemail.o:	email.h email.c code.h
X
Xhelp.o:		help.h help.c globals.h ps.h input.h terminal.h helpfile.h
X
Xinput.o:	input.h input.c globals.h ps.h network.h terminal.h display.h\
X		help.h input.h
X
Xnetwork.o:	network.h network.c globals.h socket.c
X
Xps.o:		ps.h ps.c
X
Xsocket.o:	socket.c
X
Xscoring.o:	scoring.h scoring.c globals.h
X
Xstartup.o:	globals.h
X
Xterminal.o:	terminal.h terminal.c
X
Xhelpfile.h:
X		echo 'char *help_file_name="'$(OKBRIDGE_HELPFILE)'";' \
X		> helpfile.h
X
END_OF_FILE
if test 2756 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'Revisions' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Revisions'\"
else
echo shar: Extracting \"'Revisions'\" \(2853 characters\)
sed "s/^X//" >'Revisions' <<'END_OF_FILE'
XThis file notes the changes that have been made for each revision
Xof okbridge.  My apologies for not starting this list earlier.
X
X1.5Q
X  - Added some code to allow version 1.5P to compile correctly
X    under AIX.
X
X1.5Q
X  - Modified the '/claim' command so that if the number of tricks is omitted,
X    then all remaining tricks are claimed.
X  - Added '^T' control key to force the program into TALK mode when
X    it is expecting a bid or play.
X  - Added some code to allow version 1.5P to compile correctly
X    under AIX.
X  - Corrected the bug which causes the program to crash when a client
X    attempts to occupy the seat taken by the server.
X  - Corrected some array sizes in code.c, thus fixing the 
X    "north terminal problem".
X
X1.5P
X  - Writes the Zhang log file even if all players pass.
X  - Added the -R command line option for rubber bridge.
X  - Changed the names of shuffle and tally to okshuffle and oktally.
X  - Added the -d parameter to the shuffle command for printing the date
X    to the deals file.
X  - Writes the date to both types of log files.
X  - Accepts the -s parameter on the tally command for skipping deals.
X  - Accepts "-" as a filename parameter on the tally command for
X    specifying standard input.
X
X1.5N
X  - Added the -z option for generating log files in the format used
X    by S. Zhang's okbd program.
X  - Improved the error handling when an incompatible client 
X    is recognized.
X  - Screen refreshes now handled properly during review of the hand.
X
X1.5M released Dec. 8, 1991
X  - Added the -r, -l and -L parameters to the command line which emulate
X    the /REPLAY, /LOAD and /LOG commands, respectively.
X  - fixed a bug in the network code having to do with handling connection
X    requests after one of the players has disconnected.
X  - Incorporated Zhenjun Wu's code for computing IMP scores.
X  - Added the /REVIEW command for reviewing the bidding.
X  - Added the /DEFAULT command for disabling default inputs.
X  - Added control-character equivalents for the /BELL, /DEFAULTS,
X    /PROMPT and /REVIEW commands.
X  - Introduces the 'okb' shell script by Charles Wen for making
X    the startup of okbridge more user friendly.
X
X1.5L 
X  - There was no version 1.5L released.
X
X1.5K
X  - Modified the coding of the email duplicate files so that the initial
X    message supplied by the '-m' parameter to the shuffle command appears
X    in plaintext in the deal file.
X  - "Unfixed" the "bug" in IMP scoring which was "fixed" in version 1.5J
X
X1.5J released Nov 1, 1991
X  - Fixed a bug in the IMP scoring which causes the scores to be off by 1.
X  - Added the '-m' parameter to the shuffle command for recording an
X    initial message.
X  - Eliminated use of the more modern 'long random()' function in favor
X    of the older 'int rand()'.  At least one user pointed out that
X    'long random()' is not available on his system.
END_OF_FILE
if test 2853 -ne `wc -c <'Revisions'`; then
    echo shar: \"'Revisions'\" unpacked with wrong size!
fi
# end of 'Revisions'
fi
if test -f 'code.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'code.h'\"
else
echo shar: Extracting \"'code.h'\" \(3523 characters\)
sed "s/^X//" >'code.h' <<'END_OF_FILE'
X/* code.h
X ! 
X ! Copyright (C) 1990,1991 by Matthew Clegg
X ! 
X ! This program may be copied and distributed freely.  Please do not
X ! charge money for this program or for any program derived from it.
X ! If you modify this program, then include a notice stating plainly
X ! that your program is derived from the okbridge program and is not
X ! the same as the official okbridge program.
X !
X ! I welcome any suggestions for improvement to okbridge, and 
X ! I would be especially happy to receive improved source code.
X ! If you have comments or suggestions, or if you would like to
X ! join the okbridge mailing list, then write to
X !
X !   mclegg@cs.ucsd.edu
X !
X *
X * This file provides definitions for a module which implements a
X * very simple cipher that is used to encode crucial parts of the
X * email duplicate files.  The purpose of the cipher is to allow
X * email duplicate files to be manipulated easily without revealing
X * their contents.  For details about how the cipher is implemented,
X * see the file code.c.
X *
X*/
X
Xtypedef struct Encoded_File_Struct Encoded_File;
X
Xextern int codefile_line_no;
X	/* The number of lines that have been read from the current
X           coded file. */
X
Xextern int Reset_Encoded_File ();
X/*
Xextern int Reset_Encoded_File (filename, check_string, ef)
X	char *filename, check_string; Encoded_File **ef; */
X/* Opens the named file for input.  Returns a pointer to a structure
X   describing the opened file.  If an error occurs in opening the
X   file, returns -1, in which case the system error code is stored
X   in errno.  Reads lines from the file until a line is found which
X   matches check_string.  If the check_string is not found, then
X   returns 1.  Else, reads the cipher_encoding from the following line.
X   Allocates a new Encoded_File structure and stores its location in ef.
X   Returns 0 on success.
X*/
X
Xextern int Read_Encoded_Line ();
X/*
Xextern int Read_Encoded_Line (ef, buf, buflen)
X	Encoded_File *ef; char *buf; int buflen; */
X/* Reads a line of up to buflen characters from the encoded file ef
X   into buf.  If the first character of the line is '!', then strips
X   that character and applies the decoding algorithm to the remainder
X   of the line.  Otherwise, just copies the line from the input file
X   to the buffer.  Returns the number of characters read or -1 if
X   the end of file is reached.
X*/
X
Xextern int Rewrite_Encoded_File ();
X/*
Xextern int Rewrite_Encoded_File (filename, check_string, ef)
X	char *filename, *check_string; Encoded_File **ef; */
X/* Opens the named file for output.  Returns a pointer to a structure
X   describing the opened file.  If an error occurs in opening the file,
X   then returns -1, in which case the system error code is stored
X   in errno.  Invents a permutation for the new encoded file.
X   Writes the check_string as the first line of the new file,
X   and the permutation as the second line.  Returns 0 to indicate
X   success.
X*/
X
Xextern int Write_Encoded_Line ();
X/*
Xextern int Write_Encoded_Line (ef, buf)
X	Encoded_File ef; char *buf; */
X/* Writes the encoded version of the string from buf to the encoded
X   file ef.  Returns 0 on success or 1 if the system reports an error.
X*/
X
Xextern int Write_Unencoded_Line ();
X/* 
Xextern int Write_Unencoded_Line (ef, buf)
X	Encoded_File *ef; char *buf; */
X/* Writes the unencoded line in buf to the file ef. */
X
Xextern void Close_Encoded_File ();
X/*
Xvoid Close_Encoded_File (ef)
X	Encoded_File *ef; */
X/* Closes the file associated to ef and disposes of the memory
X   associated to ef. */
X
END_OF_FILE
if test 3523 -ne `wc -c <'code.h'`; then
    echo shar: \"'code.h'\" unpacked with wrong size!
fi
# end of 'code.h'
fi
if test -f 'display.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'display.h'\"
else
echo shar: Extracting \"'display.h'\" \(5944 characters\)
sed "s/^X//" >'display.h' <<'END_OF_FILE'
X/* display.h
X ! 
X ! Copyright (C) 1990,1991 by Matthew Clegg
X ! 
X ! This program may be copied and distributed freely.  Please do not
X ! charge money for this program or for any program derived from it.
X ! If you modify this program, then include a notice stating plainly
X ! that your program is derived from the okbridge program and is not
X ! the same as the official okbridge program.
X !
X ! I welcome any suggestions for improvement to okbridge, and 
X ! I would be especially happy to receive improved source code.
X ! If you have comments or suggestions, or if you would like to
X ! join the okbridge mailing list, then write to
X !
X !   mclegg@cs.ucsd.edu
X !
X *
X * The DISPLAY module for the bridge program is responsible for
X * presenting the information regarding various aspects of the
X * game to the screen.  The organization of the screen is embedded
X * within this module, and there are entry points for giving
X * updates to the screen at each step of the game.
X *
X * This module does not make any calls to the operating system
X * directly.  Instead, all of its output functions are channeled
X * through the TERMINAL module.
X *
X */
X 
Xextern Initialize_Display ();
X/* Should be called once when the program starts up. */
X 
Xextern Reset_Display ();
X/* Redraws the main features of the screen.  Used in the process
X   of doing a 'refresh'. */
X 
Xextern Refresh_Display ();
X/* Updates the entire screen. */
X 
X 
X/* The scoring display gives information about the following attributes
X * for each side:
X *
X * -- The number of tricks taken in the current hand.
X * -- The current 'above the line' score.
X * -- The current 'below the line' score.
X * -- The vulnerabilities of each side.
X *
X * Nov. 3, 1990: The scoring display routines have now been revised to
X *  present the display in the Chicago-scoring format as well as in the
X *  rubber-scoring format.  The decision is made by inspecting the
X *  variable rubber_scoring defined in globals.h.
X */
X 
Xextern Display_Tricks_Taken      ();
Xextern Display_Above_Line_Points ();
Xextern Display_Below_Line_Points ();
Xextern Display_Vulnerabilities   ();
X 
X 
X/* The bidding display is given as four columns, similar to that found
X * in many bridge books.  At the top of each column is printed the
X * corresponding input parameter string to identify the bidder.
X *
X * Before bidding can begin, the bidding display must be initialized.
X * Then, for each bid, that bid must be shown on the display.  And after
X * the bids have been made, the contract must be displayed.  Thus,
X * we have the following procedures:
X *
X * Display_Bidding_Board:  Called to initialize the bidding display.
X *   This procedure should be called once at the beginning of the bidding.
X *
X * Display_Hand_for_Bidding: Called to show what the local player is
X *   holding.  This procedure should be called once after the call to
X *   Display_Bidding_Board.
X *
X * Display_Bidder:  Called to show whose turn it is to bid now.
X *
X * Display_Bid:  Called to show a player's bid.  The current round of
X *   bidding and the player who has bid are passed as input parameters,
X *   but the actual bid is read from the global variable 'bids'.
X *
X * Clear_Bidding_Board:  Called to erase the bidding display.  This should
X *   be called once after the auction has concluded.
X *
X * Display_Contract:  To be called after the auction is over.  This
X *   procedure displays the contract which has been determined by the
X *   bidding.
X */
X 
Xextern Display_Bidding_Board ();
Xextern Display_Hand_for_Bidding ();
Xextern Display_Bidder ();
Xextern Display_Bid ();
Xextern Clear_Bidding_Board ();
Xextern Display_Contract ();
X 
X 
X/* The playing board is a separate display which runs during the play
X * of the hands.  In the center of the screen is displayed a large square
X * which is supposed to represent the tabletop, and the cards which are
X * played are shown on this table top.
X *
X * The playing proceeds also in a series of stages.  First, there is an
X * initial call to draw the playing board.  Then, in each trick there are
X * calls to show the cards which have been played.  At the end of each
X * trick, there is a final call to clear the cards from the playing board.
X * And after all of the tricks have been played, the playing board is
X * cleared.  Thus, we have the following procedures:
X *
X * Display_Playing_Board:  called initially to draw the playing board.
X *
X * Display_Hand:  called at the beginning of each trick to display the
X *   contents of the (local) player's hand.  The player whose hand is to
X *   be displayed is passed as input, mainly as an aid to debugging.
X *
X * Display_Player: called before each card is played to display whose
X *   it is to play next.
X *
X * Display_Play:  called after each card has been played to display the
X *   card on the tabletop.  The player and the card are passed as input.
X *
X * Clear_Hand:  called intermittently to erase a player's hand from
X *   the display.
X *
X * Clear_Plays:  called at the end of each trick to clear the cards from
X *   the tabletop.
X *
X * Clear_Playing_Board:  called after all of the tricks have been played
X *   to clear the 'playing board' from the screen.
X *
X */
X 
Xextern Display_Playing_Board ();
Xextern Display_Hand ();
Xextern Display_Player ();
Xextern Display_Play ();
Xextern Clear_Plays  ();
Xextern Clear_Hand ();
Xextern Clear_Playing_Board ();
X 
X 
X/* One line of the display is reserved for displaying special messages about
X * the status of the game.  The following two procedures are given for
X * manipulating this display.
X */
X 
Xextern Display_Status ();
Xextern Clear_Status_Display ();
X 
X 
X/* The bottom part of the screen is used for the exchange of comments
X * between the players.  The following procedures are used for managing
X * this part of the display.
X */
X 
Xextern Refresh_Player_Comments ();
Xextern Initialize_Player_Comments ();
Xextern Display_Player_Comment ();
X
Xextern Suspend_Comment_Display ();
Xextern Continue_Comment_Display ();
X
END_OF_FILE
if test 5944 -ne `wc -c <'display.h'`; then
    echo shar: \"'display.h'\" unpacked with wrong size!
fi
# end of 'display.h'
fi
if test -f 'help.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help.h'\"
else
echo shar: Extracting \"'help.h'\" \(2491 characters\)
sed "s/^X//" >'help.h' <<'END_OF_FILE'
X/* help.h -- help functions for the bridge program.
X ! 
X ! Copyright (C) 1990,1991 by Matthew Clegg
X ! 
X ! This program may be copied and distributed freely.  Please do not
X ! charge money for this program or for any program derived from it.
X ! If you modify this program, then include a notice stating plainly
X ! that your program is derived from the okbridge program and is not
X ! the same as the official okbridge program.
X !
X ! I welcome any suggestions for improvement to okbridge, and 
X ! I would be especially happy to receive improved source code.
X ! If you have comments or suggestions, or if you would like to
X ! join the okbridge mailing list, then write to
X !
X !   mclegg@cs.ucsd.edu
X !
X *
X * This file contains the interface for a help procedure for the
X * bridge program.  The help function is organized as a series of topics,
X * headed by a main topic.  All of the help information is stored in a
X * single file, organized as a list of topics.  The first entry in the
X * file is interpreted to be the main topic, i.e., it is the entry which
X * is displayed if no particular keyword is given.  Each topic entry
X * has a header line which contains an identifying keyword and a 
X * descriptive phrase.  This is followed by the body of the entry
X * and is terminated by an end-of-entry line.  The format of the header
X * line is simply
X *  <keyword> <phrase>
X * where <keyword> is any text string not containing white space characters.
X * The body of the entry consists simply of a series of text lines.
X * These are displayed in order on the screen.  However, a line beginning
X * with the circumflex '^' character is displayed at the beginning of a
X * new page.  A help entry is terminated by a line containing just the
X * two characters '--'.  The last entry in the file need not have this
X * terminator.  The help file may also contain comment lines.  These
X * begin with the pound sign '#' character.
X */
X 
Xextern initialize_help_system ();
X/* Called once at the beginning of the program to read the file of help
X * topics.
X */
X 
Xextern display_help ();
X/* void display_help (char *topic); */
X/* Displays help on the given topic.  This consists of looking up the
X * help file associated to this topic and displaying the contents of this
X * file on the screen.  If the topic string is empty, then displays first
X * the contents of the main topic file, and then displays a list of the
X * topics.  If there is no help on the given topic, then displays a list
X * of topics.
X */
X 
END_OF_FILE
if test 2491 -ne `wc -c <'help.h'`; then
    echo shar: \"'help.h'\" unpacked with wrong size!
fi
# end of 'help.h'
fi
if test -f 'network.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'network.h'\"
else
echo shar: Extracting \"'network.h'\" \(2299 characters\)
sed "s/^X//" >'network.h' <<'END_OF_FILE'
X/* network.h
X ! 
X ! Copyright (C) 1990,1991 by Matthew Clegg
X ! 
X ! This program may be copied and distributed freely.  Please do not
X ! charge money for this program or for any program derived from it.
X ! If you modify this program, then include a notice stating plainly
X ! that your program is derived from the okbridge program and is not
X ! the same as the official okbridge program.
X !
X ! I welcome any suggestions for improvement to okbridge, and 
X ! I would be especially happy to receive improved source code.
X ! If you have comments or suggestions, or if you would like to
X ! join the okbridge mailing list, then write to
X !
X !   mclegg@cs.ucsd.edu
X !
X *
X * This is the interface between the network and the bridge program.
X * It is expected that this part of the program may have to be
X * totally re-written for each different port.  Therefore, the
X * interface has been made as simple as possible.
X *
X * The input and output of this module consists simply of character
X * strings.  However, we assume tacitly that the calling procedures
X * attach the name of the player at the beginning of each transmission.
X *
X * We assume that the network module implements a 'broadcast' model
X * of communication, where every message is transmitted to each of
X * the three other players.  We assume also that the network
X * connections are reliable, in the sense that once a connection is
X * established between two players, it remains intact until the
X * end of the game.  However, we do not make any assumptions about
X * the order in which we may receive the messages.
X */
X 
Xextern initialize_network ();
X/* void initialize_network (char *name); */
X/* To be called once at the beginning of the program. 'name' is the
X   name used by the player. */
X 
Xextern send_message ();
X/* void send_message (char *message); */
X 
Xextern int message_available ();
X/* int message_available (void); */
X 
Xextern receive_message ();
X/* void receive_message (char *message); */
X 
Xextern reset_network ();
X/* void reset_network (void); */
X/* To be called once at the end of the program.  Resets the
X   communications network. */
X 
Xextern Close_Network_Connection ();
X/* void Close_Network_Connection (char *player_name); */
X/* Closes the connection the named player.  Allows the connection to
X   be re-established. */
X 
END_OF_FILE
if test 2299 -ne `wc -c <'network.h'`; then
    echo shar: \"'network.h'\" unpacked with wrong size!
fi
# end of 'network.h'
fi
if test -f 'okbridgerc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'okbridgerc'\"
else
echo shar: Extracting \"'okbridgerc'\" \(3042 characters\)
sed "s/^X//" >'okbridgerc' <<'END_OF_FILE'
X# .okbridgerc
X# 
X# This is an example startup file for the okbridge program.
X# When okbridge first starts up, it searches for the .okbridgerc
X# startup file.  The current working directory is first searched,
X# and if this fails, then the home directory is searched.
X#
X# Comment lines in the .okbridgerc file begin with a pound sign '#'.
X# Noncomment lines contain a keyword and a value associated to that
X# keyword.  The possible keyword, value pairs are described below.
X#
X#
X#  BELL		ON | OFF
X#	When requesting input (a bid or a play), the terminal's
X#	bell is rung by default.  However, this can be disabled
X#	by specifying 'BELL OFF'.  This has the same effect as the
X#	'/BELL OFF' command.
X# BELL OFF
X
X
X# HELPFILE	<directory-name>
X#   This field specifies the location of the okbridge help file.
X# HELPFILE /usr/local/games/okbridge.help
X 
X#   LOG		<filename>
X#	If this statement is present in the startup file, then
X#	the hands will automatically be logged to the given filename.
X#
XLOG okbridge.log
X
X#  NAME		<local-player-name>
X#	This field specifies the name that will be used to identify
X#	the local player to the other players.
X#
X# NAME matt
X
X#  POSITION	NORTH | EAST | SOUTH | WEST
X#	This field specifies the local player's position.
X#
XPOSITION north
X
X#  PORT		<positive-integer>
X#	This field specifies the internet port number that will be
X#	used for communications with the server.
X#
X# PORT 1122
X
X#  PROMPT 	NO | YES
X#	The value of this field is only relevant in hands where the
X#	local player is the dummy.  In this case, the dummy is
X#	ordinarily prompted to press RETURN at the end of each trick.
X#	This allows the dummy to see the cards that are played as they
X#	are played.  However, if 'PROMPT NO' is specified, then the
X#	dummy will not be prompted.
X# PROMPT NO
X
X#  SCORING	RUBBER | CHICAGO | DUPLICATE | EMAIL | IMP
X#	This field is only relevant if the local player is north.
X#	In this case, the SCORING field determines the type of scoring
X#	that will be used by default in the game.
XSCORING EMAIL
X
X#  SERVER	ME | <internet-name-or-number>
X#	If the value of this field is 'ME', then the local player
X#	will assume the role of server.  If the value of this field
X#	is anything else, then it is interpreted as an internet name
X#	or number of the machine where the server is running.
X# SERVER reciprocity
X
X# The following two options are only relevant if the position is
X# north and the scoring mode is email.  In this case, these commands
X# can be used to automatically load and store email duplicate boards.
X#
X#   LOAD        <filename>
X#        Causes the boards stored in the email duplicate file
X#        named <filename> to be automatically loaded at the beginning
X#        of the program.
X#
X#   REPLAY      <filename>
X#        Also causes the boards stored in the email duplicate file
X#        named <filename> to be automatically loaded at the beginning
X#        of the program.  After they have been played, the boards along
X#        with the results of play are automatically saved back to the
X#        same file.
END_OF_FILE
if test 3042 -ne `wc -c <'okbridgerc'`; then
    echo shar: \"'okbridgerc'\" unpacked with wrong size!
fi
# end of 'okbridgerc'
fi
if test -f 'okshuffle.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'okshuffle.c'\"
else
echo shar: Extracting \"'okshuffle.c'\" \(4633 characters\)
sed "s/^X//" >'okshuffle.c' <<'END_OF_FILE'
X/* shuffle.c -- generate shuffles for use in email duplicate play.
X ! 
X ! Copyright (C) 1991 by Matthew Clegg
X ! 
X ! This program may be copied and distributed freely.  Please do not
X ! charge money for this program or for any program derived from it.
X ! If you modify this program, then include a notice stating plainly
X ! that your program is derived from the okbridge program and is not
X ! the same as the official okbridge program.
X !
X ! I welcome any suggestions for improvement to okbridge, and 
X ! I would be especially happy to receive improved source code.
X ! If you have comments or suggestions, or if you would like to
X ! join the okbridge mailing list, then write to
X !
X !   mclegg@cs.ucsd.edu
X !
X *
X * Format of command:
X *   
X *   shuffle [nboards] [-d] [-m initial-message]
X *
X * where
X *   nboards 
X *     is the number of boards to generate.  If omitted, nboards
X *     defaults to 4.
X *
X *   initial-message
X *     is a message which will be displayed to each of the players
X *     as soon as the first board is loaded from the file.
X *
X *   -d
X *     is a flag indicating that the date should be written to the
X *     deals file.
X *
X * Writes the encoded boards to standard output.
X *
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/time.h>
X
X#define _BRIDGE_
X
X#include "globals.h"
X#include "email.h"
X
Xint dealer_list [16] =
X{PLAYER_NORTH, PLAYER_EAST, PLAYER_SOUTH, PLAYER_WEST,
X PLAYER_NORTH, PLAYER_EAST, PLAYER_SOUTH, PLAYER_WEST,
X PLAYER_NORTH, PLAYER_EAST, PLAYER_SOUTH, PLAYER_WEST,
X PLAYER_NORTH, PLAYER_EAST, PLAYER_SOUTH, PLAYER_WEST};
X
Xint ns_vulnerability_list [16] =
X{0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1};
X
Xint ew_vulnerability_list [16] =
X{0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0};
X
Xextern char *malloc ();
X
Xchar *strdup (s)
X     char *s;
X{
X  char *p, *q;
X
X  p = q = malloc (strlen(s) + 1);
X  while (*s)
X    *(q++) = *(s++);
X  *q = '\0';
X  return (p);
X
X};
X
Xstatic shuffle_the_deck (cards)
X	deal cards;
X/* Using the algorithm suggested by Douglas Foxvog.  Thanks, Doug! */
X{
X	int i, t, c;
X	deal shuffle;
X 
X	for (i = 0; i < 52; i++) 
X		shuffle [i] = i;
X	for (i = 0; i < 51; i++) {
X		c = (rand () / 97) % (52 - i);
X		t = shuffle[i+c]; 
X		shuffle[i+c] = shuffle[i];
X		shuffle[i] = t;
X	};
X	for (i = 0; i < 52; i++)
X		cards[shuffle[i]] = (i % 4);
X		
X};
X
Xstatic void parameter_error (msg)
X     char *msg;
X{
X  fprintf (stderr, "shuffle: error in parameters: %s\n", msg);
X  fprintf (stderr, "shuffle: usage: shuffle [nboards] [-m initial_message]\n");
X  exit (1);
X};
X
Xmain (argc, argv)
X     int argc; char *argv[];
X{
X  int i, j, nboards, know_nboards, print_date;
X  struct Email_Duplicate_struct *board_list;
X  Email_Board *current_board;
X  Email_Comment *ec;
X  char *initial_message, error_buf[80], date_buffer[80];
X  deal new_deal;
X  time_t time_value;
X
X  nboards = 4;
X  know_nboards = 0;
X  print_date = 0;
X  initial_message = NULL;
X  for (i = 1; i < argc; i++) {
X    if (!strcmp(argv[i], "-d"))
X      print_date = 1;
X    else if (!strcmp(argv[i], "-m")) {
X      i++;
X      if (i < argc)
X	initial_message = strdup (argv[i]);
X      else
X	parameter_error ("initial_message missing");
X    } else if (!know_nboards) {
X      nboards = atoi (argv[i]);
X      know_nboards = 1;
X      if (nboards <= 0) {
X	sprintf (error_buf, "expected integer nboards, but got %s", argv[i]);
X	parameter_error (error_buf);
X      };
X    } else
X      parameter_error ("too many parameters");
X  };
X
X  srand (time(NULL));
X  if (print_date) {
X    time (&time_value);
X    sprintf (date_buffer, "THIS HAND WAS SHUFFLED ON %s", ctime(&time_value));
X    if (date_buffer[strlen(date_buffer)-1] == '\n')
X      date_buffer[strlen(date_buffer)-1] = '\0';
X  };
X
X  board_list = New_Email_Duplicate_Struct ();
X  for (i = 0; i < nboards; i++) {
X    j = i % 16;
X    shuffle_the_deck (new_deal);
X    current_board = Add_Email_Board (board_list, new_deal);
X    current_board->dealer = dealer_list[j];
X    current_board->ns_vulnerable = ns_vulnerability_list[j];
X    current_board->ew_vulnerable = ew_vulnerability_list[j];
X    if (print_date) {
X      ec = (Email_Comment *) malloc(sizeof(Email_Comment));
X      current_board->pre_script = ec;
X      current_board->pre_script->comment = date_buffer;
X      current_board->pre_script->next = NULL;
X    };
X  };
X
X  current_board = board_list->board_list;
X  if ((current_board != NULL) && (initial_message != NULL)) {
X    ec = (Email_Comment *) malloc (sizeof(Email_Comment));
X    ec->next = current_board->pre_script;
X    current_board->pre_script = ec;
X    current_board->pre_script->comment = initial_message;
X  };
X
X  Write_Email_Duplicate_File ("-", 1, board_list);
X    
X
X};
END_OF_FILE
if test 4633 -ne `wc -c <'okshuffle.c'`; then
    echo shar: \"'okshuffle.c'\" unpacked with wrong size!
fi
# end of 'okshuffle.c'
fi
if test -f 'ps.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ps.h'\"
else
echo shar: Extracting \"'ps.h'\" \(3663 characters\)
sed "s/^X//" >'ps.h' <<'END_OF_FILE'
X/* ps.h -- "parse-string" data structure.
X ! 
X ! Copyright (C) 1990,1991 by Matthew Clegg
X ! 
X ! This program may be copied and distributed freely.  Please do not
X ! charge money for this program or for any program derived from it.
X ! If you modify this program, then include a notice stating plainly
X ! that your program is derived from the okbridge program and is not
X ! the same as the official okbridge program.
X !
X ! I welcome any suggestions for improvement to okbridge, and 
X ! I would be especially happy to receive improved source code.
X ! If you have comments or suggestions, or if you would like to
X ! join the okbridge mailing list, then write to
X !
X !   mclegg@cs.ucsd.edu
X !
X *
X * This file defines a data structure for handling strings which are
X * to be parsed.  The crucial aspect of a such a data structure is that
X * it permit the current character to be read without advancing the
X * input pointer.
X *
X * The lifetime of a parse string can be described crudely as follows:
X *   Create the parse string
X *   Repeat:
X *     Copy data into the parse string (from memory or from a file).
X *     Read the data out of the parse string.
X *   End.
X *
X * Thus, we provide procedures for handling each of these steps and for
X * giving some additional information about the string.
X */
X 
Xtypedef char *parse_string;
X 
X#define PS_SIZE		0
X#define PS_LENGTH	1
X#define PS_POS		2
X#define PS_OFFSET	3
X 
X 
Xextern parse_string ps_alloc ();
X/* parse_string ps_alloc (int n); */
X/* Returns a parse_string which can hold up to n bytes of text. */
X 
X/* void ps_reset(parse_string ps); */
X/* Clears a parse_string so that new data can be copied into it. */
X#define ps_reset(ps)	(ps[PS_LENGTH]=ps[PS_POS]=0;)
X 
Xextern ps_put ();
X/* void ps_put (parse_string ps, char ch); */
X/* Adds the character ch to the parse_string ps. */
X 
Xextern ps_copy ();
X/* void ps_copy (parse_string ps, char *s); */
X/* Copies the string s to the parse_string ps.
X   Resets ps before doing the copy. */
X 
Xextern ps_read ();
X/* void ps_read (parse_string ps, FILE *fp); */
X/* Copies the next text line from the file fp to the parse_string ps.
X * Resets ps before doing the copy.
X */
X 
X/* char ps_scan (parse_string ps); */
X/* Returns the current character in the parse_string ps.
X * Does not advance the pointer in ps.
X */
X#define ps_scan(ps)	((ps[PS_POS] < ps[PS_LENGTH]) ? ps [PS_OFFSET + ps[PS_POS]] : '\0')
X 
Xextern int ps_matches ();
X/* int ps_matches (parse_string ps, char *key); */
X/* Returns TRUE if the next sequence of characters in the parse string
X * matches key.  If so, then advances the pointer in the parse string
X * past key.  Otherwise, returns FALSE.
X */
X 
Xextern int ps_matches_ic ();
X/* int ps_matches_ic (parse_string ps, char *key); */
X/* Returns TRUE if the next sequence of characters in the parse string
X * matches key, after both are converted to upper case.  If so, then
X * advances the pointer in the parse string past key.
X */
X 
X/* int ps_next (parse_string ps); */
X/* Advances the pointer in the parse_string ps to the next character.
X *  Returns the character which the read head has just moved past.
X */
X/* #define ps_next(ps)	(ps[PS_POS]++) */
X#define ps_next(ps) ((ps[PS_POS] < ps[PS_LENGTH]) ? ps[PS_OFFSET+ps[PS_POS]++] : '\0')
X 
X/* int ps_size  (parse_string ps); */
X/* Returns the number of characters allocated for text in ps. */
X#define ps_size(ps)	(ps[PS_SIZE])
X 
X/* int ps_length (parse_string ps); */
X/* Returns the number of characters of text currently used in ps. */
X#define ps_length(ps)	(ps[PS_LENGTH])
X 
X/* int ps_pos (parse_string ps); */
X/* Returns the index of the current character in ps. */
X#define ps_pos(ps)	(ps[PS_POS])
X 
X 
X 
X 
X 
X 
END_OF_FILE
if test 3663 -ne `wc -c <'ps.h'`; then
    echo shar: \"'ps.h'\" unpacked with wrong size!
fi
# end of 'ps.h'
fi
if test -f 'scoring.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scoring.h'\"
else
echo shar: Extracting \"'scoring.h'\" \(3427 characters\)
sed "s/^X//" >'scoring.h' <<'END_OF_FILE'
X/* scoring.h -- scoring functions for the bridge program.
X ! 
X ! Copyright (C) 1990,1991 by Matthew Clegg
X ! 
X ! This program may be copied and distributed freely.  Please do not
X ! charge money for this program or for any program derived from it.
X ! If you modify this program, then include a notice stating plainly
X ! that your program is derived from the okbridge program and is not
X ! the same as the official okbridge program.
X !
X ! I welcome any suggestions for improvement to okbridge, and 
X ! I would be especially happy to receive improved source code.
X ! If you have comments or suggestions, or if you would like to
X ! join the okbridge mailing list, then write to
X !
X !   mclegg@cs.ucsd.edu
X !
X *
X * This file defines the functions used for computing scores.
X * We provide functions for scoring according to the rules of
X * rubber bridge as well as according to the rules of Chicago style
X * bridge.  Instead of being passed parameters, these functions
X * obtain most of their information from the global variables
X * defined in globals.h.
X *
X * I would like to thank Tom Kronmiller for supplying the code
X * for scoring according to the Chicago rules.  Thanks Tom!
X */
X 
X
Xextern int Rubber_score_above ();
X/* int Rubber_score_above (int extra); */
X/* Computes the above-the-line score for the current contract assuming
X * that 'extra' many tricks below the required number were taken.
X * Returns the score.
X */
X
Xextern int Rubber_score_below ();
X/* int Rubber_score_below (void); */
X/* Computes the below-the-line score for the current contract,
X * assuming that it was made.
X */
X
Xextern int Rubber_score_set ();
X/* int Rubber_score_set (int down); */
X/* Computes the penalty score for the current contract assuming that
X * 'down' too few tricks were taken.  Returns the score.
X */
X
Xextern int Chicago_score_made ();
X/* int Chicago_score_made (int extra, int vulnerable); */
X/* Computes the score for the current contract assuming that it was made
X * and that an additional 'extra' tricks were taken.  'vulnerable' is a
X * boolean flag which indicates whether the declaring team was
X * vulnerable.  Part_score is the 'part score' of the declaring team.
X * The scoring is the same as for rubber bridge, except that bidding and
X * making a game is worth 300 nonvulnerable or 500 vulnerable.
X * Returns the score.
X *
X * Based on code written by Tom Kronmiller
X */
X
Xextern int Chicago_score_set ();
X/* int Chicago_score_set (int down, int vulnerable); */
X/* Computes the score for the current contract assuming that it was
X * set and that 'down' too few tricks were taken.  'vulnerable' is
X * a boolean flag which indicates whether the declaring team was
X * vulnerable.  Returns the score.
X *
X * Based on code written by Tom Kronmiller
X */
X
Xextern int Duplicate_score_made ();
X/* int Duplicate_score_made (int extra, int vulnerable); */
X/* Computes the score for the current contract assuming that it was made
X * and that an additional 'extra' tricks were taken.  'vulnerable' is a
X * boolean flag which indicates whether the declaring team was
X * vulnerable.  Returns the score.
X */
X
Xextern int Duplicate_score_set ();
X/* int Duplicate_score_set (int down, int vulnerable); */
X/* Computes the score for the current contract assuming that it was
X * set and that 'down' too few tricks were taken.  'vulnerable' is
X * a boolean flag which indicates whether the declaring team was
X * vulnerable.  Returns the score.
X */
X
X
END_OF_FILE
if test 3427 -ne `wc -c <'scoring.h'`; then
    echo shar: \"'scoring.h'\" unpacked with wrong size!
fi
# end of 'scoring.h'
fi
if test -f 'socket.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'socket.c'\"
else
echo shar: Extracting \"'socket.c'\" \(3577 characters\)
sed "s/^X//" >'socket.c' <<'END_OF_FILE'
X/* socket.c -- routines for establishing socket connections
X *             over the Internet.
X ! 
X ! Copyright (C) 1990 by Jarkko Oikarinen
X ! 
X ! This program may be copied and distributed freely.  You may modify 
X ! this program if you like, but we request that you give the modified 
X ! version a different name.  Also, we would appreciate hearing about 
X ! any improvements that have been made to the program.
X ! 
X ! If you have any questions or comments, then please contact 
X ! Matthew Clegg at "clegg@tolsun.Oulu.FI".
X !
X *
X *
X */
X
X#include <ctype.h>
X#include <sys/errno.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <netdb.h>
X#include <stdio.h>
X#include <sys/time.h>
X
X
X#define RETRY_LIMIT 60
X
X
Xextern int errno;
Xextern char *sys_errlist[];
X
Xchar socket_error [80];
X
Xint client_init(host, portnum)
Xchar *host;
Xint portnum;
X/* Attempts to establish a connection with the host identified by the
X * string 'host' at port 'portnum'.  If the connection is established,
X * then returns the socket number.  Otherwise, returns -1 and places
X * an error message in socket_error.
X */
X{
X  int sock, tryagain = 1, notrys;
X  static struct hostent *hp;
X  static struct sockaddr_in server;
X  int server_avail;
X
X
X  notrys = 0;
X  while (notrys < RETRY_LIMIT) {
X  /* FIX:  jtrim@duorion.cair.du.edu -- 3/4/89 
X     and jto@tolsun.oulu.fi -- 3/7/89 */
X
X    sock = socket(AF_INET, SOCK_STREAM, 0);
X/*
X    sprintf (socket_error, "Assigned socket %d", sock);
X    Display_Player_Comment ("DEBUG", socket_error);
X    restore_cursor ();
X*/
X    if (sock < 0) {
X      sprintf (socket_error, "error opening socket: %s",
X	       sys_errlist [errno]);
X      return (-1);
X    }
X    server.sin_family = AF_INET;
X    
X    /* MY FIX -- jtrim@duorion.cair.du.edu   (2/10/89) */
X    if ( isdigit(*host))
X      {
X	server.sin_addr.s_addr = inet_addr(host);
X      }
X    else
X      { 
X	hp = gethostbyname(host);
X	if (hp == 0) {
X	  sprintf(socket_error, "%s: unknown host\n", host);
X	  return (-1);
X	}
X#ifdef HPUX
X	strncpy(&server.sin_addr, hp->h_addr, hp->h_length);
X#else
X	bcopy(hp->h_addr, &server.sin_addr, hp->h_length);
X#endif
X      }
X    server.sin_port = htons(portnum);
X    /* End Fix */
X    
X    server_avail = connect(sock, (struct sockaddr *) &server, sizeof(server));
X    if (server_avail) {
X            close (sock);
X	    sprintf (socket_error, "connection error: %s", 
X		     sys_errlist [errno]);
X/*            printf ("client_init: %s\n", socket_error); */
X	    notrys++;
X	    if (errno == EINTR) return;
X	    sleep (10);
X    } else
X      return(sock);
X  };
X};
X
X
Xint open_port(portnum)
Xint portnum;
X/* Opens a socket port for listening.  If successful, returns the
X * number of socket which has been established.  If unsuccessful,
X * returns -1 and places an error string in socket_error.
X */
X{
X  int sock, length;
X  static struct sockaddr_in server;
X  /* At first, open a new socket */
X  sock = socket(AF_INET, SOCK_STREAM, 0);
X  if (sock < 0) {
X    sprintf (socket_error, "error opening socket: %s",
X	     sys_errlist[errno]);
X    return(-1);
X  }
X
X  /* Bind a port to listen for new connections */
X  server.sin_family = AF_INET;
X  server.sin_addr.s_addr = INADDR_ANY;
X  server.sin_port = htons(portnum);
X/*  for (length = 0; length < 10; length++) { */
X    if (bind(sock, (struct sockaddr *) (&server), sizeof(server))) {
X      sprintf (socket_error, "error binding stream socket: %s",
X	       sys_errlist[errno]);
X/*      if (length >= 9) */
X	return(-1);
X/*      sleep(10); */
X    };
X/*
X    else
X      break;
X  }
X*/
X  listen(sock, 3);
X  return(sock);
X}
X
END_OF_FILE
if test 3577 -ne `wc -c <'socket.c'`; then
    echo shar: \"'socket.c'\" unpacked with wrong size!
fi
# end of 'socket.c'
fi
if test -f 'terminal.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'terminal.h'\"
else
echo shar: Extracting \"'terminal.h'\" \(2076 characters\)
sed "s/^X//" >'terminal.h' <<'END_OF_FILE'
X/* terminal
X ! 
X ! Copyright (C) 1990,1991 by Matthew Clegg
X ! 
X ! This program may be copied and distributed freely.  Please do not
X ! charge money for this program or for any program derived from it.
X ! If you modify this program, then include a notice stating plainly
X ! that your program is derived from the okbridge program and is not
X ! the same as the official okbridge program.
X !
X ! I welcome any suggestions for improvement to okbridge, and 
X ! I would be especially happy to receive improved source code.
X ! If you have comments or suggestions, or if you would like to
X ! join the okbridge mailing list, then write to
X !
X !   mclegg@cs.ucsd.edu
X !
X *
X * The TERMINAL module serves as one of the main interfaces to the
X * operating system, the other interface being the NETWORK module.
X * This module provides primitives for outputting text to the screen
X * and reading characters from the keyboard.  We assume that
X * the screen has at least 24 lines and 80 columns, that the cursor
X * is addressable, and that it is possible to check in advance whether
X * or not a character is available from the keyboard.
X */
X 
Xextern Initialize_Terminal ();
X/* To be called once at the beginning of the program. */
X 
Xextern print ();
X/* void print (int row, int col, char *message); */
X/* (1,1) specifies the upper left corner of the screen. */
X 
Xextern int char_avail ();
X/* int char_avail (void); */
X/* Returns TRUE if a character is available from the keyboard. */
X 
Xextern int input_char ();
X/* int input_char (void); */
X/* Returns the next input character from the keyboard. */
X 
Xextern set_cursor ();
X/* void set_cursor (int row, int col); */
X/* Places the cursor at the specified (row, col). */
X 
Xextern clear_screen ();
X/* void clear_screen (void); */
X/* Clears the screen and places the cursor in the upper left corner. */
X 
Xextern ring_bell ();
X/* void ring_bell (void); */
X/* Rings the terminal's bell */
X
Xextern Reset_Terminal ();
X/* void Reset_Terminal (void); */
X/* To be called at the end of the program to reset the terminal to its
X   initial operating mode. */
END_OF_FILE
if test 2076 -ne `wc -c <'terminal.h'`; then
    echo shar: \"'terminal.h'\" unpacked with wrong size!
fi
# end of 'terminal.h'
fi
echo shar: End of archive 7 \(of 7\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
    echo creating input.c from input.c.aa and input.c.ab
    cat input.c.aa input.c.ab >input.c
    rm -f input.c.aa input.c.ab
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
