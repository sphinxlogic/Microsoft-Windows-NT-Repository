Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i033:  xsokoban3 - another X11 based, get the money game (V2), Part01/03
Message-ID: <2432@masterCNA.TEK.COM>
Date: 10 Feb 92 23:54:35 GMT
Sender: news@masterCNA.TEK.COM
Lines: 1995
Approved: billr@saab.CNA.TEK.COM

Submitted-by: "Joseph L. Traub" <jt1o+@andrew.cmu.edu>
Posting-number: Volume 13, Issue 33
Archive-name: xsokoban3/Part01
Supersedes: xsokoban2: Volume 13, Issue 13-15
Environment: X11, Xlib

	[This is version 2 of Joseph's XSokoban game. -br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  README MANIFEST bitmaps bitmaps/defaults display.c
#   errors.h main.c play.c score.c screens screens
# Wrapped by billr@saab on Mon Feb 10 15:46:04 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1696 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XThis is the second release of XSokoban.
X
XThis distribution contains all the files to compile and run the game,
Xthe original 50 sokoban screen files, 35 additional screen files
Xthat were sent to me as being gleaned from various public domain
Xversions of sokoban, and a manual page that explains how the game works..
X
XInstallation -
X  - Edit the header file config.h to define the appropriate paths, and
X    things for your system. Nearly EVERY define in this file MUST be
X    changed if your game is to run correctly.
X
X  - Compile by typing 'make'.  If something goes wrong, and you can track
X    down an error, send me a bug report (including what changes you needed
X    to make, and I will see about fixing it for later distributions)
X
X  - Create the scorefile by typing 'xsokoban -c'.  (If you have a sokoban
X    game already on your system, you should be able to just use that score
X    file by setting the config.h defines correctly).
X
X  - Play the game by typing 'xsokoban'.
X
X  - Have fun.
X
XNotes -
X  - The screen files need to be publically readable.
X
X  - The score file should be readable/writeable ONLY by the 'superuser' of the
X    program (see config.h).
X
X  - The save files should be readable/writeable ONLY by the 'superuser'.
X
X  - Because of this, the game needs to be run setuid of the person who is
X    'superuser'.
X
XFixes/Bug Reports/Modifications -
X  - If you make any changes to this program, fix any bugs, add any neat
X    features, or whatever, please get ahold of me at jt1o@andrew.cmu.edu
X    so that I can add them in to the newest release.
X
XFuture -
X  - I will be setting up a sokoban level designer sometime in the near future.
X
X--Joseph L. Traub
X  (jt1o@andrew.cmu.edu)
END_OF_FILE
if test 1696 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(4232 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	
X Makefile                   2	
X README                     1	
X bitmaps                    1	
X bitmaps/defaults           1	
X bitmaps/defaults/centerwall.xbm  2	
X bitmaps/defaults/east_twall.xbm  2	
X bitmaps/defaults/eastwall.xbm  2	
X bitmaps/defaults/floor.xbm  2	
X bitmaps/defaults/goal.xbm  2	
X bitmaps/defaults/horizwall.xbm  2	
X bitmaps/defaults/llcornerwall.xbm  2	
X bitmaps/defaults/lonewall.xbm  2	
X bitmaps/defaults/lrcornerwall.xbm  2	
X bitmaps/defaults/man.xbm   2	
X bitmaps/defaults/north_twall.xbm  2	
X bitmaps/defaults/northwall.xbm  2	
X bitmaps/defaults/object.xbm  2	
X bitmaps/defaults/saveman.xbm  2	
X bitmaps/defaults/south_twall.xbm  2	
X bitmaps/defaults/southwall.xbm  2	
X bitmaps/defaults/treasure.xbm  2	
X bitmaps/defaults/ulcornerwall.xbm  2	
X bitmaps/defaults/urcornerwall.xbm  2	
X bitmaps/defaults/vertiwall.xbm  2	
X bitmaps/defaults/wall.xbm  2	
X bitmaps/defaults/west_twall.xbm  2	
X bitmaps/defaults/westwall.xbm  2	
X config.h                   2	
X defaults.h                 2	
X display.c                  1	
X errors.h                   1	
X externs.h                  2	
X globals.h                  2	
X help.h                     2	
X main.c                     1	
X options.h                  2	
X play.c                     1	
X resources.c                2	
X save.c                     2	
X score.c                    1	
X screen.c                   2	
X screens                    1	
X screens                    1	
X screens/screen.1           3	
X screens/screen.10          2	
X screens/screen.11          3	
X screens/screen.12          3	
X screens/screen.13          3	
X screens/screen.14          3	
X screens/screen.15          3	
X screens/screen.16          3	
X screens/screen.17          3	
X screens/screen.18          3	
X screens/screen.19          3	
X screens/screen.2           3	
X screens/screen.20          3	
X screens/screen.21          3	
X screens/screen.22          3	
X screens/screen.23          3	
X screens/screen.24          3	
X screens/screen.25          3	
X screens/screen.26          3	
X screens/screen.27          3	
X screens/screen.28          3	
X screens/screen.29          3	
X screens/screen.3           3	
X screens/screen.30          3	
X screens/screen.31          3	
X screens/screen.32          3	
X screens/screen.33          3	
X screens/screen.34          3	
X screens/screen.35          3	
X screens/screen.36          3	
X screens/screen.37          3	
X screens/screen.38          3	
X screens/screen.39          3	
X screens/screen.4           3	
X screens/screen.40          3	
X screens/screen.41          3	
X screens/screen.42          3	
X screens/screen.43          3	
X screens/screen.44          3	
X screens/screen.45          3	
X screens/screen.46          3	
X screens/screen.47          3	
X screens/screen.48          3	
X screens/screen.49          3	
X screens/screen.5           3	
X screens/screen.50          3	
X screens/screen.51          2	
X screens/screen.52          3	
X screens/screen.53          3	
X screens/screen.54          3	
X screens/screen.55          3	
X screens/screen.56          3	
X screens/screen.57          3	
X screens/screen.58          3	
X screens/screen.59          3	
X screens/screen.6           3	
X screens/screen.60          3	
X screens/screen.61          3	
X screens/screen.62          3	
X screens/screen.63          3	
X screens/screen.64          3	
X screens/screen.65          3	
X screens/screen.66          3	
X screens/screen.67          3	
X screens/screen.68          3	
X screens/screen.69          3	
X screens/screen.7           3	
X screens/screen.70          3	
X screens/screen.71          3	
X screens/screen.72          3	
X screens/screen.73          3	
X screens/screen.74          3	
X screens/screen.75          3	
X screens/screen.76          3	
X screens/screen.77          3	
X screens/screen.78          3	
X screens/screen.79          3	
X screens/screen.8           3	
X screens/screen.80          3	
X screens/screen.81          3	
X screens/screen.82          3	
X screens/screen.83          3	
X screens/screen.84          3	
X screens/screen.85          2	
X screens/screen.9           3	
X xsokoban.man               2	
END_OF_FILE
if test 4232 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test ! -d 'bitmaps' ; then
    echo shar: Creating directory \"'bitmaps'\"
    mkdir 'bitmaps'
fi
if test ! -d 'bitmaps/defaults' ; then
    echo shar: Creating directory \"'bitmaps/defaults'\"
    mkdir 'bitmaps/defaults'
fi
if test -f 'display.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'display.c'\"
else
echo shar: Extracting \"'display.c'\" \(16715 characters\)
sed "s/^X//" >'display.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "externs.h"
X#include "globals.h"
X#include "defaults.h"
X#include "help.h"
X
X/* mnemonic defines to help orient some of the text/line drawing, sizes */
X#define HELPLINE ((bit_height * MAXROW) + 30)
X#define STATUSLINE ((bit_height * MAXROW) + 5)
X#define HELP_H (bit_height * MAXROW)
X#define HELP_W (bit_width * MAXCOL)
X
X/* useful globals */
XDisplay *dpy;
XWindow win;
Xint scr;
XGC gc, rgc, drgc;
XXFontStruct *finfo;
Xunsigned int width, height, depth, bit_height, bit_width;
XBoolean display_alloc = False, font_alloc = False, gc_alloc = False,
X        pix_alloc = False;
XBoolean optwalls;
XColormap cmap;
XCursor this_curs;
XPixmap help[HELP_PAGES], floor;
XPixmap blank, work, man, saveman, goal, object, treasure, walls[NUM_WALLS];
Xint hlpscrn = -1;
Xchar buf[500];
X
Xextern char *progname;
Xextern char map[MAXROW+1][MAXCOL+1];
Xextern short rows, cols, level, moves, pushes, packets, savepack;
Xextern char *bitpath;
X
X/* names of the fancy wall bitmap files.  If you define a set of fancy
X * wall bitmaps, they must use these names
X */
Xchar *wallname[] = {
X "lonewall.xbm", "southwall.xbm", "westwall.xbm", "llcornerwall.xbm",
X "northwall.xbm", "vertiwall.xbm", "ulcornerwall.xbm", "west_twall.xbm",
X "eastwall.xbm", "lrcornerwall.xbm", "horizwall.xbm", "south_twall.xbm",
X "urcornerwall.xbm", "east_twall.xbm", "north_twall.xbm", "centerwall.xbm"
X};
X
X/* Do all the nasty stuff like makeing the windows, setting all the defaults
X * creating all the pixmaps, loading everything, and mapping the window.
X * this does NOT do the XOpenDisplay() so that the -display switch can be
X * handled cleanly.
X */
Xshort InitX(void)
X{
X  int i;
X  Boolean reverse = _false_, tmpwalls = _false_;
X  char *rval;
X  unsigned long fore, back, bord, curs, gc_mask;
X  XSizeHints szh;
X  XWMHints wmh;
X  XSetWindowAttributes wattr;
X  XClassHint clh;
X  XGCValues val, reval;
X  XTextProperty wname, iname;
X  XColor cfg, cbg;
X
X  /* these are always needed */
X  scr = DefaultScreen(dpy);
X  cmap = DefaultColormap(dpy, scr);
X  depth = DefaultDepth(dpy, scr);
X
X  /* here is where we figure out the resources and set the defaults.
X   * resources can be either on the command line, or in your .Xdefaults/
X   * .Xresources files.  They are read in and parsed in main.c, but used
X   * here.
X   */
X  rval = GetResource(FONT);
X  if(rval == (char *)0)
X    rval = DEF_FONT;
X  finfo = XLoadQueryFont(dpy, rval);
X  if(finfo == (XFontStruct *)0)
X    return E_NOFONT;
X  font_alloc = _true_;
X
X  rval = GetResource(REVERSE);
X  if(rval != (char *)0) {
X    reverse = StringToBoolean(rval);
X  }
X
X  if(!GetColorResource(FOREG, &fore))
X    fore = BlackPixel(dpy, scr);
X
X  if(!GetColorResource(BACKG, &back))
X    back = WhitePixel(dpy, scr);
X
X  if(reverse) {
X    unsigned long t;
X    t = fore;
X    fore = back;
X    back = t;
X  }
X
X  if(!GetColorResource(BORDER, &bord))
X    bord = fore;
X  if(!GetColorResource(CURSOR, &curs))
X    curs = fore;
X
X  bitpath = GetResource(BITDIR);
X  rval = GetResource(WALLS);
X  if(rval != (char *)0)
X    tmpwalls = StringToBoolean(rval);
X
X  /* walls are funny.  if a alternate bitpath has been defined, assume
X   * !fancywalls unless explicitly told fancy walls.  If the default 
X   * bitpath is being used, you can assume fancy walls.
X   */
X  if(bitpath && !tmpwalls)
X    optwalls = _false_;
X  else
X    optwalls = _true_;
X
X  width = MAXCOL * DEF_BITW;
X  height = MAXROW * DEF_BITH + 50;
X
X  wmh.initial_state = NormalState;
X  wmh.input = True;
X  wmh.flags = (StateHint | InputHint);
X
X  clh.res_class = clh.res_name = progname;
X
X  /* Make sure the window and icon names are set */
X  if(!XStringListToTextProperty(&progname, 1, &wname))
X    return E_NOMEM;
X  if(!XStringListToTextProperty(&progname, 1, &iname))
X    return E_NOMEM;
X
X  /* load in a cursor, and recolor it so it looks pretty */
X  this_curs = XCreateFontCursor(dpy, DEF_CURSOR);
X  cfg.pixel = curs;
X  cbg.pixel = back;
X  XQueryColor(dpy, cmap, &cfg);
X  XQueryColor(dpy, cmap, &cbg);
X  XRecolorCursor(dpy, this_curs, &cfg, &cbg);
X
X  /* set up the funky little window attributes */
X  wattr.background_pixel = back;
X  wattr.border_pixel = bord;
X  wattr.backing_store = Always;
X  wattr.event_mask = (KeyPressMask | ExposureMask | ButtonPressMask);
X  wattr.cursor = this_curs;
X
X  /* whee, create the window, we create it with NO size so that we
X   * can load in the bitmaps, we later resize it correctly
X   */
X  win = XCreateWindow(dpy, RootWindow(dpy, scr), 0, 0, width, height, 4,
X		      CopyFromParent, InputOutput, CopyFromParent,
X                      (CWBackPixel | CWBorderPixel | CWBackingStore |
X                       CWEventMask | CWCursor), &wattr);
X
X  /* this will set the bit_width and bit_height as well as loading
X   * in the pretty little bitmaps
X   */
X  if(LoadBitmaps() == E_NOBITMAP)
X    return E_NOBITMAP;
X  blank = XCreatePixmap(dpy, win, bit_width, bit_height, 1);
X  pix_alloc = _true_;
X
X  width = MAXCOL * bit_width;
X  height = MAXROW * bit_height + 50;
X  
X  /* whee, resize the window with the correct size now that we know it */
X  XResizeWindow(dpy, win, width, height);
X
X  /* set up the size hints, we don't want manual resizing allowed. */
X  szh.min_width = szh.width = szh.max_width = width;
X  szh.min_height = szh.height = szh.max_height = height;
X  szh.x = szh.y = 0;
X  szh.flags = (PSize | PPosition | PMinSize | PMaxSize);
X
X  /* now SET all those hints we create above */
X  XSetWMNormalHints(dpy, win, &szh);
X  XSetWMHints(dpy, win, &wmh);
X  XSetClassHint(dpy, win, &clh);
X  XSetWMName(dpy, win, &wname);
X  XSetWMIconName(dpy, win, &iname);
X
X  work = XCreatePixmap(dpy, win, width, height, depth);
X
X  /* set up all the relevant GC's */
X  val.foreground = reval.background = fore;
X  val.background = reval.foreground = back;
X  val.function = reval.function = GXcopy;
X  val.font = reval.font = finfo->fid;
X  gc_mask = (GCForeground | GCBackground | GCFunction | GCFont);
X  gc = XCreateGC(dpy, work, gc_mask, &val);
X  rgc = XCreateGC(dpy, blank, gc_mask, &reval);
X  drgc = XCreateGC(dpy, work, gc_mask, &reval);
X  
X  /* make the help windows and the working bitmaps */
X  /* we need to do this down here since it requires GCs to be allocated */
X  for(i = 0; i < HELP_PAGES; i++)
X    help[i] = XCreatePixmap(dpy, win, HELP_W, HELP_H, depth);
X  MakeHelpWindows();
X  XFillRectangle(dpy, blank, rgc, 0, 0, bit_width, bit_height);
X
X  gc_alloc = _true_;
X
X  /* display the friendly little clear screen */
X  ClearScreen();
X  XMapWindow(dpy, win);
X  RedisplayScreen();
X  
X  return 0;
X}
X
X/* deallocate all the memory and structures used in creating stuff */
Xvoid DestroyDisplay(void)
X{
X  int i;
X
X  /* kill the font */
X  if(font_alloc)
X    XFreeFont(dpy, finfo);
X
X  /* destroy everything allocted right around the gcs.  Help windows are
X   * freed here cause they are created about the same time.  (Yes, I know
X   * this could cause problems, it hasn't yet.
X   */
X  if(gc_alloc) {
X    XFreeGC(dpy, gc);
X    XFreeGC(dpy, rgc);
X    XFreeGC(dpy, drgc);
X    XFreePixmap(dpy, work);
X    for (i = 0; i < HELP_PAGES; i++)
X      XFreePixmap(dpy, help[i]);
X  }
X  /* free up all the allocated pix */
X  if(pix_alloc) {
X    XFreePixmap(dpy, man);
X    XFreePixmap(dpy, saveman);
X    XFreePixmap(dpy, goal);
X    XFreePixmap(dpy, treasure);
X    XFreePixmap(dpy, object);
X    XFreePixmap(dpy, floor);
X    XFreePixmap(dpy, blank);
X    for(i = 0; i < NUM_WALLS; i++)
X      if(i == 0 || optwalls)
X        XFreePixmap(dpy, walls[i]);
X  }
X  /* okay.. NOW we can destroy the main window and the display */
X  if(display_alloc) {
X    XDestroyWindow(dpy, win);
X    XCloseDisplay(dpy);
X  }
X}
X
X/* this loads in a single bitmap.  If this bitmap is the largest in the x or
X * y direction, set bit_width or bit_height appropriately.  If your pixmaps
X * are of varying sizes, a bit_width by bit_height box is gaurenteed to be
X * able to surround all of them.
X */
XBoolean LoadOneBitmap(char *fname, char *altname, Pixmap *pix)
X{
X  unsigned int dum1, dum2;
X  int dum3, dum4;
X  Boolean load_fail = _false_;
X  char buf[1024];
X
X  if(bitpath && *bitpath) {
X    /* we have something to try other than the default, let's do it */
X    sprintf(buf, "%s/%s", bitpath, fname);
X    if(XReadBitmapFile(dpy, win, buf, &dum1, &dum2, pix, &dum3, &dum4) !=
X       BitmapSuccess) {
X      if(altname && *altname) {
X        fprintf(stderr, "%s: Cannot find '%s/%s', trying alternate.\n",
X                progname, bitpath, fname);
X        sprintf(buf, "%s/%s", bitpath, altname);
X        if(XReadBitmapFile(dpy, win, buf, &dum1, &dum2, pix, &dum3, &dum4) !=
X           BitmapSuccess) {
X          load_fail = _true_;
X          fprintf(stderr, "%s: Cannot find '%s/%s', trying defaults.\n",
X                  progname, bitpath, altname);
X        } else {
X	  if(dum1 > bit_width) bit_width = dum1;
X	  if(dum2 > bit_height) bit_height = dum2;
X          return _true_;
X        }
X      } else {
X        load_fail = _true_;
X        fprintf(stderr, "%s: Cannot find '%s/%s', trying alternate.\n",
X                progname, bitpath, fname);
X      }
X    } else {
X      if(dum1 > bit_width) bit_width = dum1;
X      if(dum2 > bit_height) bit_height = dum2;
X      return _true_;
X    }
X  }
X  if(!bitpath || !*bitpath || load_fail) {
X    sprintf(buf, "%s/%s", BITPATH, fname);
X    if(XReadBitmapFile(dpy, win, buf, &dum1, &dum2, pix, &dum3, &dum4) !=
X       BitmapSuccess) {
X      if(altname && *altname) {
X        fprintf(stderr, "%s: Cannot find '%s', trying alternate.\n",
X                progname, fname);
X        sprintf(buf, "%s/%s", BITPATH, fname);
X        if(XReadBitmapFile(dpy, win, buf, &dum1, &dum2, pix, &dum3, &dum4) !=
X           BitmapSuccess) {
X          fprintf(stderr, "%s: Cannot find '%s'!\n", progname, altname);
X          return _false_;
X        } else {
X	  if(dum1 > bit_width) bit_width = dum1;
X	  if(dum2 > bit_height) bit_height = dum2;
X          return _true_;
X	}
X      } else {
X        fprintf(stderr, "%s: Cannot find '%s'!\n", progname, fname);
X        return _false_;
X      }
X    } else {
X      if(dum1 > bit_width) bit_width = dum1;
X      if(dum2 > bit_height) bit_height = dum2;
X      return _true_;
X    }
X  }
X}
X
X/* loads all the bitmaps in.. if any fail, it returns E_NOBITMAP up a level
X * so the program can report the error to the user.  It tries to load in the
X * alternates as well.
X */
Xshort LoadBitmaps(void)
X{
X  register int i;
X
X  if(!LoadOneBitmap("man.xbm", NULL, &man)) return E_NOBITMAP;
X  if(!LoadOneBitmap("saveman.xbm", "man.xbm", &saveman)) return E_NOBITMAP;
X  if(!LoadOneBitmap("object.xbm", NULL, &object)) return E_NOBITMAP;
X  if(!LoadOneBitmap("treasure.xbm", NULL, &treasure)) return E_NOBITMAP;
X  if(!LoadOneBitmap("goal.xbm", NULL, &goal)) return E_NOBITMAP;
X  if(!LoadOneBitmap("floor.xbm", NULL, &floor)) return E_NOBITMAP;
X
X  if(optwalls) {
X    for(i = 0; i < NUM_WALLS; i++) {
X      if(!LoadOneBitmap(wallname[i], "wall.xbm", &walls[i])) return E_NOBITMAP;
X    }
X  } else {
X    if(!LoadOneBitmap("wall.xbm", NULL, &walls[0])) return E_NOBITMAP;
X  }
X  return 0;
X}
X
X/* create and draw all the help windows in.  This is not wholly fullproff with
X * the variable size bitmap code yet, as the constants to place things on the
X * screen, are just that, constants.  This could most likley be reworked.
X */
Xvoid MakeHelpWindows(void)
X{
X  register int i;
X  char *title =
X    "    Sokoban  --  X version by Joseph L. Traub  --  Help page %d";
X  char *next =
X     "     Press Enter to exit  --   Any other key for next page.";
X
X  for(i = 0; i < HELP_PAGES; i++) {
X    XFillRectangle(dpy, help[i], drgc, 0, 0, HELP_W, HELP_H);
X    sprintf(buf, title, (i+1));
X    XDrawImageString(dpy, help[i], gc, 0, 11, buf, strlen(buf));
X    XDrawLine(dpy, help[i], gc, 0, 17, HELP_W, 17);
X    XDrawLine(dpy, help[i], gc, 0, HELP_H-20, HELP_W, HELP_H-20);
X    XDrawImageString(dpy, help[i], gc, 2, HELP_H-7, next, strlen(next));
X  }
X  for(i = 0; help_pages[i].textline != NULL; i++) {
X    XDrawImageString(dpy,help[help_pages[i].page], gc,
X                     help_pages[i].xpos * (finfo->max_bounds.width),
X                     help_pages[i].ypos, help_pages[i].textline,
X                     strlen(help_pages[i].textline));
X  }
X  XCopyPlane(dpy, man, help[0], gc, 0, 0, bit_width, bit_height, 180, 360, 1);
X  XCopyPlane(dpy, goal, help[0], gc, 0, 0, bit_width, bit_height, 270, 360, 1);
X  XCopyPlane(dpy, walls[0], help[0], gc, 0, 0, bit_width, bit_height,
X	     369, 360, 1);
X  XCopyPlane(dpy, object, help[0], gc, 0, 0, bit_width, bit_height,
X	     477, 360, 1);
X  XCopyPlane(dpy, treasure, help[0], gc, 0, 0, bit_width, bit_height,
X	     270, 400, 1);
X  XCopyPlane(dpy, saveman, help[0], gc, 0, 0, bit_width, bit_height,
X	     477, 400, 1);
X}
X
X/* wipe out the entire contents of the screen */
Xvoid ClearScreen(void)
X{
X  register int i,j;
X
X  XFillRectangle(dpy, work, drgc, 0, 0, width, height);
X  for(i = 0; i < MAXROW; i++)
X    for(j = 0; j < MAXCOL; j++)
X      XCopyPlane(dpy, floor, work, gc, 0, 0, bit_width, bit_height,
X                 j*bit_width, i*bit_height, 1);
X  XDrawLine(dpy, work, gc, 0, bit_height*MAXROW, bit_width*MAXCOL,
X            bit_height*MAXROW);
X}
X
X/* redisplay the current screen.. Has to handle the help screens if one
X * is currently active..  Copys the correct bitmaps onto the window.
X */
Xvoid RedisplayScreen(void)
X{
X  if(hlpscrn == -1)
X    XCopyArea(dpy, work, win, gc, 0, 0, width, height, 0, 0);
X  else
X    XCopyArea(dpy, help[hlpscrn], win, gc, 0, 0, HELP_W, HELP_H, 0, 0);
X  XFlush(dpy);
X}
X
X/* Draws all the neat little pictures and text onto the working pixmap
X * so that RedisplayScreen is happy.
X */
Xvoid ShowScreen(void)
X{
X  register int i,j;
X
X  for(i = 0; i < rows; i++)
X    for(j = 0; j < cols && map[i][j] != NULL; j++)
X      MapChar(map[i][j], i, j);
X  DisplayLevel();
X  DisplayPackets();
X  DisplaySave();
X  DisplayMoves();
X  DisplayPushes();
X  DisplayHelp();
X  RedisplayScreen();
X}
X
X/* Draws a single pixmap, translating from the character map to the pixmap
X * rendition.
X */
Xvoid MapChar(char c, int i, int j)
X{
X  Pixmap this;
X
X  this = GetObjectPixmap(i, j, c); /* i, j are passed so walls can be done */
X  XCopyPlane(dpy, this, work, gc, 0, 0, bit_width, bit_height, cX(j), cY(i), 1);
X}
X
X/* figures out the appropriate pixmap from the internal game representation.
X * Handles fancy walls.
X */
XPixmap GetObjectPixmap(int i, int j, char c)
X{
X  switch(c) {
X    case player: return man;
X    case playerstore: return saveman;
X    case store: return goal;
X    case save: return treasure;
X    case packet: return object;
X    case wall:
X       if(optwalls) return walls[PickWall(i,j)];
X       else return walls[0];
X    case ground: return floor;
X    default: return blank;
X  }
X}
X
X/* returns and index into the fancy walls array. works by assigning a value
X * to each 'position'.. the type of fancy wall is computed based on how
X * many neighboring walls there are.
X */
Xint PickWall(int i, int j)
X{
X  int ret = 0;
X
X  if(i > 0 && map[i-1][j] == wall) ret += 1;
X  if(j < cols && map[i][j+1] == wall) ret += 2;
X  if(i < rows && map[i+1][j] == wall) ret += 4;
X  if(j > 0 && map[i][j-1] == wall) ret += 8;
X  return ret;
X}
X
X/* Draws a string onto the working pixmap */
Xvoid DrawString(int x, int y, char *text)
X{
X  int x_off, y_off;
X
X  x_off = x * finfo->max_bounds.width;
X  y_off = y + finfo->ascent;
X
X  XDrawImageString(dpy, work, gc, x_off, y_off, text, strlen(text));
X}
X
X/* The following routines display various 'statusline' stuff (ie moves, pushes,
X * etc) on the screen.  they are called as they are needed to be changed to
X * avoid unneccesary drawing */
Xvoid DisplayLevel(void)
X{
X   sprintf(buf, "Level: %3d", level);
X   DrawString(0, STATUSLINE, buf);
X}
X
Xvoid DisplayPackets(void)
X{
X   sprintf(buf, "Packets: %3d", packets);
X   DrawString(12, STATUSLINE, buf);
X}
X
Xvoid DisplaySave(void)
X{
X  sprintf(buf, "Saved: %3d", savepack);
X  DrawString(26, STATUSLINE, buf);
X}
X
Xvoid DisplayMoves(void)
X{
X  sprintf(buf, "Moves: %5d", moves);
X  DrawString(38, STATUSLINE, buf);
X}
X
Xvoid DisplayPushes(void)
X{
X  sprintf(buf, "Pushes: %3d", pushes);
X  DrawString(52, STATUSLINE, buf);
X}
X
Xvoid DisplayHelp(void)
X{
X  DrawString(0, HELPLINE, "Press ? for help.");
X}
X
X/* Displays the first help page, and flips help pages (one per key press)
X * until a return is pressed.
X */
Xvoid ShowHelp(void)
X{
X  int i = 0;
X  Boolean done = _false_;
X
X  hlpscrn = 0;
X  XCopyArea(dpy, help[i], win, gc, 0, 0, HELP_W, HELP_H, 0, 0);
X  XFlush(dpy);
X  while(!done) {
X    done = WaitForEnter();
X    if(done) {
X      hlpscrn = -1;
X      return;
X    } else {
X      i = (i+1)%HELP_PAGES;
X      hlpscrn = i;
X      XCopyArea(dpy, help[i], win, gc, 0, 0, HELP_W, HELP_H, 0, 0);
X      XFlush(dpy);
X    }
X  }
X}
X
X/* since the 'press ? for help' is ALWAYS displayed, just beep when there is
X * a problem.
X */
Xvoid HelpMessage(void)
X{
X  XBell(dpy, 0);
X  RedisplayScreen();
X}
END_OF_FILE
if test 16715 -ne `wc -c <'display.c'`; then
    echo shar: \"'display.c'\" unpacked with wrong size!
fi
# end of 'display.c'
fi
if test -f 'errors.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'errors.h'\"
else
echo shar: Extracting \"'errors.h'\" \(2541 characters\)
sed "s/^X//" >'errors.h' <<'END_OF_FILE'
X/* textual errormessages corresponding to the #defines in globals.h */
Xchar *errmess[] = {
X    "illegal error number",
X    "cannot open screen file",
X    "more than one player position in screen file",
X    "illegal char in screen file",
X    "no player position in screenfile",
X    "too much rows in screen file",
X    "too much columns in screenfile",
X    "quit the game",
X    "cannot get your username",
X    "cannot open savefile",
X    "error writing to savefile",
X    "cannot stat savefile",
X    "error reading savefile",
X    "cannot restore, your savefile has been altered",
X    "game saved",
X    "too much users in score table",
X    "cannot open score file",
X    "error reading scorefile",
X    "error writing scorefile",
X    "illegal command line syntax",
X    "illegal password",
X    "level number too big in command line",
X    "only superuser is allowed to make a new score table",
X    "cannot find file to restore",
X    "cannot find bitmap file",
X    "cannot open display",
X    "cannot load font",
X    "cannot allocate string memory",
X    "could not load requested color"
X};
X
X/* usage message */
X#define USAGESTR \
X "usage: %s [-{s|c|r|<nn>} -display <disp> -{w|walls} -{f|font} \n\
X                 -{rv|reverse} -{b|bitdir} <path> -{fg|foreground} <color> \n\
X                 -{bg|background} <color> -{bd|border} <color> \n\
X                 -{pr|pointer} <color> -xrm <arg>]\n\n"
X
Xchar *usages[] = {
X  "\t-c                  : create a new score file (superuser only)\n",
X  "\t-r                  : restore a saved game.\n",
X  "\t-s                  : show high score table.\n",
X  "\t-<nn>               : play level <nn> (<nn> must be greater than 0)\n",
X  "\t-display <disp>     : run on display <disp>\n",
X  "\t-w                  :\n",
X  "\t-walls              : use fancy walls\n",
X  "\t-rv                 :\n",
X  "\t-reverse            : reverse the foreground and backgound colors\n",
X  "\t-f <fn>             :\n",
X  "\t-font <fn>          : use font <fn>\n",
X  "\t-b <path>           :\n",
X  "\t-bitdir <path>      : use bitmaps found in directory <path>\n",
X  "\t-fg <color>         :\n",
X  "\t-foregound <color>  : use <color> as foreground color\n",
X  "\t-bg <color>         :\n",
X  "\t-backgound <color>  : use <color> as background color\n",
X  "\t-bd <color>         :\n",
X  "\t-border <color>     : use <color> as border color\n",
X  "\t-pr <color>         :\n",
X  "\t-pointer <color>    : use <color> as the pointer foreground color\n",
X  "\t-xrm <arg>          : specify that <arg> is an X resource.\n",
X  NULL
X};
END_OF_FILE
if test 2541 -ne `wc -c <'errors.h'`; then
    echo shar: \"'errors.h'\" unpacked with wrong size!
fi
# end of 'errors.h'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(7722 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <pwd.h>
X#include "externs.h"
X#include "globals.h"
X#include "options.h"
X#include "errors.h"
X
X/* useful globals */
XBoolean scoring = _true_;
Xshort level, packets, savepack, moves, pushes, rows, cols;
Xshort scorelevel, scoremoves, scorepushes;
XPOS ppos;
Xchar map[MAXROW + 1][MAXCOL + 1];
Xchar *username = NULL, *progname = NULL, *bitpath = NULL;;
Xstatic Boolean optshowscore = _false_, optmakescore = _false_,
X	       optrestore = _false_, superuser = _false_;
Xstatic short optlevel = 0, userlevel;
Xstruct passwd *pwd;
XXrmDatabase rdb;
X
Xextern Display *dpy;
Xextern int scr;
Xextern Boolean display_alloc;
X
X/* do all the setup foo, and make sure command line gets parsed. */
Xvoid main(int argc, char **argv)
X{
X  short ret = 0, ret2 = 0;
X
X#ifdef VICE
X  Authenticate();
X#endif
X
X  scorelevel = 0;
X  moves = pushes = packets = savepack = 0;
X
X  /* make the program name be what it is invoked with */
X  progname = strrchr(argv[0], '/');
X  if(progname == NULL)
X    progname = argv[0];
X  else
X    progname++;
X
X  /* find out who is playing us. (pwd will be kept around in case we need to
X   * build the Xresources stuff later.
X   */
X  pwd = getpwuid(getuid());
X  if(pwd == NULL)
X    /* we MUST be being played by somebody, sorry */
X    ret = E_NOUSER;
X  else {
X    /* find out who we are. */
X    username = pwd->pw_name;
X    /* see if we are the superuser */
X    superuser = (strcmp(username, SUPERUSER) == 0) ? _true_ : _false_;
X    /* Parse the command line */
X    ret = CheckCommandLine(&argc, argv);
X    if(ret == 0) {
X      if(optshowscore)
X	ret = OutputScore();
X      else if(optmakescore) {
X	if(superuser) {
X	  /* make sure of that, shall we? */
X	  ret = GetGamePassword();
X	  if(ret == 0)
X	    ret = MakeNewScore();
X	} else
X	  /* sorry, BAD superuser */
X	  ret = E_NOSUPER;
X      } else if(optrestore) {
X	ret = RestoreGame();
X      } else {
X	ret = GetUserLevel(&userlevel);
X	if(ret == 0) {
X	  if(optlevel > 0) {
X	    if(superuser) {
X	      /* superusers can play any level (but not score) useful for
X	       * testing out new boards.
X	       */
X	      level = optlevel;
X	      scoring = _false_;
X	    } else if (userlevel < optlevel)
X	      ret = E_LEVELTOOHIGH;
X	    else
X	      level = optlevel;
X	  } else
X	    level = userlevel;
X	}
X      }
X    }
X  }
X  if(ret == 0) {
X    /* play till we drop, then nuke the good stuff */
X    ret = GameLoop();
X    DestroyDisplay();
X  }
X  /* always report here since the game returns E_ENDGAME when the user quits.
X   * Sigh.. it would be so much easier to just do it right.
X   */
X  Error(ret);
X  /* see if they score, and do it (again report an error */
X  if((scorelevel > 0) && scoring) {
X    ret2 = Score();
X    Error(ret2);
X  }
X  /* exit with whatever status we ended with */
X  exit(ret);
X}
X
X/* Oh boy, the fun stuff.. Follow along boys and girls as we parse the command
X * line up into little bitty pieces and merge in all the xdefaults that we
X * need.
X */
Xshort CheckCommandLine(int *argcP, char **argv)
X{
X  XrmDatabase command, temp;
X  char *res;
X  char buf[1024];
X  int option;
X
X  /* let's do this the sensible way, Command line first! */
X  /* we will also OPEN the display here, though we won't do anything with it */
X  XrmInitialize();
X
X  /* build an XrmDB from the command line based on the options (options.h) */
X  XrmParseCommand(&command, options, sizeof(options)/sizeof(*options),
X		  progname, argcP, argv);
X
X  /* okay, we now have the X command line options parsed, we might as well
X   * make sure we need to go further before we do.  These command line options
X   * are NOT caught by XrmParseCommand(), so we need to do them ourselves.
X   * Remember, they are all exclusive of one another.
X   */
X  for(option = 1; option < *argcP; option++) {
X    if(argv[option][0] == '-') {
X      switch(argv[option][1]) {
X	case 's':
X	  if(optshowscore || optmakescore || optrestore || (optlevel > 0))
X	    return E_USAGE;
X	  optshowscore = _true_;
X	  break;
X	case 'c':
X	  if(optshowscore || optmakescore || optrestore || (optlevel > 0))
X	    return E_USAGE;
X	  optmakescore = _true_;
X	  break;
X	case 'r':
X	  if(optshowscore || optmakescore || optrestore || (optlevel > 0))
X	    return E_USAGE;
X	  optrestore = _true_;
X	default:
X	  if(optshowscore || optrestore || optmakescore || (optlevel > 0))
X	    return E_USAGE;
X	  optlevel = atoi(argv[option]+1);
X	  if(optlevel == 0)
X	    return E_USAGE;
X	  break;
X      }
X    } else
X      /* found an option that didn't begin with a - (oops) */
X      return E_USAGE;
X  }
X
X  /* okay.. NOW, find out what display we are currently attached to. This
X   * allows us to put the display on another machine
X   */
X  res = GetDatabaseResource(command, "display");
X
X  /* open up the display */
X  dpy = XOpenDisplay(res);
X  if(dpy == (Display *)NULL)
X    return E_NODISPLAY;
X  display_alloc = _true_;
X
X  /* okay, we have a display, now we can get the std xdefaults and stuff */
X  res = XResourceManagerString(dpy);
X  if(res != NULL)
X    /* try to get it off the server first (ya gotta love R4) */
X    rdb = XrmGetStringDatabase(res);
X  else {
X    /* can't get it from the server, let's do it the slow way */
X    /* try HOME first in case you have people sharing accounts :) */
X    res = getenv("HOME");
X    if(res != NULL)
X      strcpy(buf, res);
X    else
X      /* no HOME, let's try and make one from the pwd (whee) */
X      strcpy(buf, pwd->pw_dir);
X    strcat(buf, "/.Xdefaults");
X    rdb = XrmGetFileDatabase(buf);
X  }
X
X  /* let's merge in the X environment */
X  res = getenv("XENVIRONMENT");
X  if(res != NULL) {
X    temp = XrmGetFileDatabase(res);
X    XrmMergeDatabases(temp, &rdb);
X  }
X
X  /* now merge in the rest of the X command line options! */
X  XrmMergeDatabases(command, &rdb);
X  return 0;
X}
X
X/* we just sit here and keep playing level after level after level after .. */
Xshort GameLoop(void)
X{
X  short ret = 0;
X
X  /* make sure X is all set up and ready for us */
X  ret = InitX();
X  if(ret != 0)
X    return ret;
X
X  /* get where we are starting from */
X  if(!optrestore)
X    ret = ReadScreen();
X
X  /* until we quit or get an error, just keep on going. */
X  while(ret == 0) {
X    ret = Play();
X    if(ret == 0) {
X      level++;
X      moves = pushes = packets = savepack = 0;
X      ret = ReadScreen();
X    }
X  }
X  return ret;
X}
X
X/* Does this really need a comment :) */
Xshort GetGamePassword(void)
X{
X  return ((strcmp(getpass("Password: "), PASSWORD) == 0) ? 0 : E_ILLPASSWORD);
X}
X
X/* display the correct error message based on the error number given us. 
X * There are 2 special cases, E_ENDGAME (in which case we don't WANT a 
X * silly error message cause it's not really an error, and E_USAGE, in which
X * case we want to give a really nice list of all the legal options.
X */
Xvoid Error(short err)
X{
X  switch(err) {
X    case E_FOPENSCREEN:
X    case E_PLAYPOS1:
X    case E_ILLCHAR:
X    case E_PLAYPOS2:
X    case E_TOMUCHROWS:
X    case E_TOMUCHCOLS:
X    case E_NOUSER:
X    case E_FOPENSAVE:
X    case E_WRITESAVE:
X    case E_STATSAVE:
X    case E_READSAVE:
X    case E_ALTERSAVE:
X    case E_SAVED:
X    case E_TOMUCHSE:
X    case E_FOPENSCORE:
X    case E_READSCORE:
X    case E_WRITESCORE:
X    case E_USAGE:
X    case E_ILLPASSWORD:
X    case E_LEVELTOOHIGH:
X    case E_NOSUPER:
X    case E_NOSAVEFILE:
X    case E_NOBITMAP:
X    case E_NODISPLAY:
X    case E_NOFONT:
X    case E_NOMEM:
X    case E_NOCOLOR:
X      fprintf(stderr, "%s: %s\n", progname, errmess[err]);
X      if(err == E_USAGE)
X        Usage();
X      break;
X    default:
X      if(err != E_ENDGAME)
X	fprintf(stderr, "%s: %s\n", progname, errmess[0]);
X      break;
X  }
X}
X
X/* this simply prints out the usage string nicely. */
Xvoid Usage(void)
X{
X  short i;
X
X  fprintf(stderr, USAGESTR, progname);
X  for (i = 0; usages[i] != NULL; i++)
X    fprintf(stderr, "%s", usages[i]);
X}
END_OF_FILE
if test 7722 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'play.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'play.c'\"
else
echo shar: Extracting \"'play.c'\" \(12228 characters\)
sed "s/^X//" >'play.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "externs.h"
X#include "globals.h"
X
X/* defining the types of move */
X#define MOVE            1
X#define PUSH            2
X#define SAVE            3
X#define UNSAVE          4
X#define STOREMOVE       5
X#define STOREPUSH       6
X
X/* This value merely needs to be greater than the longest possible path length
X * making it the number of squares in the array seems a good bet. 
X */
X#define BADMOVE MAXROW*MAXCOL
X
X/* some simple checking macros to make sure certain moves are legal when 
X * trying to do mouse based movement.
X */
X#define ISPLAYER(x,y) ((map[x][y] == player) || (map[x][y] == playerstore))
X#define ISCLEAR(x,y) ((map[x][y] == ground) || (map[x][y] == store))
X#define ISPACKET(x,y) ((map[x][y] == packet) || (map[x][y] == save))
X
X/* whee, yet more globals */
Xextern char map[MAXROW+1][MAXCOL+1];
Xextern short rows, cols, level, moves, pushes, savepack, packets;
Xextern short scorelevel, scoremoves, scorepushes;
Xextern POS ppos;
Xextern Display *dpy;
Xextern int bit_width, bit_height;
X
Xstatic XEvent xev;
Xstatic POS tpos1, tpos2, lastppos, lasttpos1, lasttpos2;
Xstatic char lppc, ltp1c, ltp2c;
Xstatic short action, lastaction;
X
X/** For the temporary save **/
Xstatic char  tmp_map[MAXROW+1][MAXCOL+1];
Xstatic short tmp_pushes, tmp_moves, tmp_savepack;
Xstatic POS   tmp_ppos;
Xstatic Boolean undolock = _true_;
Xstatic Boolean shift = _false_;
Xstatic Boolean cntrl = _false_;
Xstatic KeySym oldmove;
Xstatic int findmap[MAXROW+1][MAXCOL+1];
X
X/* play a particular level.
X * All we do here is wait for input, and dispatch to appropriate routines
X * to deal with it nicely.
X */
Xshort Play(void)
X{
X  short c;
X  short ret;
X  int bufs = 1;
X  char buf[1];
X  KeySym sym;
X  XComposeStatus compose;
X  
X  ClearScreen();
X  ShowScreen();
X  TempSave();
X  ret = 0;
X  while (ret == 0) {
X    XNextEvent(dpy, &xev);
X    switch(xev.type) {
X      case Expose:
X	/* Redisplaying is pretty cheap, so I don't care to much about it */
X	RedisplayScreen();
X	break;
X      case ButtonPress:
X	switch(xev.xbutton.button) {
X	  case Button1:
X	    /* move the man to where the pointer is. */
X	    MoveMan(xev.xbutton.x, xev.xbutton.y);
X	    break;
X	  case Button2:
X	    /* redo the last move */
X	    MakeMove(oldmove);
X	    break;
X	  case Button3:
X	    /* undo last move */
X	    if(!undolock) {
X	      UndoMove();
X	      undolock = _true_;
X	    }
X	    break;
X	  default:
X	    /* I'm sorry, you win the irritating beep for your efforts. */
X	    HelpMessage();
X	    break;
X	}
X	break;
X      case KeyPress:
X	buf[0] = '\0';
X	(void) XLookupString(&xev.xkey, buf, bufs, &sym, &compose);
X	cntrl = (xev.xkey.state & ControlMask) ? _true_ : _false_;
X	shift = (xev.xkey.state & ShiftMask) ? _true_ : _false_;
X	switch(sym) {
X	  case XK_q:
X	    /* q is for quit */
X	    if(!cntrl)
X	      ret = E_ENDGAME;
X	    break;
X	  case XK_s:
X	    /* save */
X	    if(!cntrl) {
X	      ret = SaveGame();
X	      if(ret == 0)
X		ret = E_SAVED;
X	    }
X	    break;
X	  case XK_question:
X	    /* help */
X	    if(!cntrl) {
X	      ShowHelp();
X	      RedisplayScreen();
X	    }
X	    break;
X	  case XK_r:
X	    /* ^R refreshes the screen */
X	    if(cntrl)
X	      RedisplayScreen();
X	    break;
X	  case XK_c:
X	    /* make a temp save */
X	    if(!cntrl)
X	      TempSave();
X	    break;
X	  case XK_U:
X	    /* Do a full screen reset */
X	    if(!cntrl) {
X	      moves = pushes = 0;
X	      ret = ReadScreen();
X	      if(ret == 0) {
X		ShowScreen();
X		undolock = _true_;
X	      }
X	    }
X	    break;
X	  case XK_u:
X	    if(cntrl) {
X	      /* Reset to last temp save */
X	      TempReset();
X	      undolock = _true_;
X	      ShowScreen();
X	    } else {
X	      /* undo last move */
X	      if (!undolock) {
X		UndoMove();
X		undolock = _true_;
X	      }
X	    }
X	    break;
X	  case XK_k:
X	  case XK_K:
X	  case XK_Up:
X	  case XK_j:
X	  case XK_J:
X	  case XK_Down:
X	  case XK_l:
X	  case XK_L:
X	  case XK_Right:
X	  case XK_h:
X	  case XK_H:
X	  case XK_Left:
X	    /* A move, A move!! we have a MOVE!! */
X	    MakeMove(sym);
X	    break;
X	  default:
X	    /* I ONLY want to beep if a key was pressed.  Contrary to what
X	     * X11 believes, SHIFT and CONTROL are NOT keys
X	     */
X            if(buf[0]) {
X	      HelpMessage();
X	    }
X	    break;
X	}
X	break;
X      default:
X	break;
X    }
X    /* if we solved a level, set it up so we get some score! */
X    if((ret == 0) && (packets == savepack)) {
X      scorelevel = level;
X      scoremoves = moves;
X      scorepushes = pushes;
X      break;
X    }
X  }
X  return ret;
X}
X
X/* Well what do you THINK this does? */
Xvoid MakeMove(KeySym sym)
X{
X  do {
X    action = TestMove(sym);
X    if(action != 0) {
X      lastaction = action;
X      lastppos.x = ppos.x;
X      lastppos.y = ppos.y;
X      lppc = map[ppos.x][ppos.y];
X      lasttpos1.x = tpos1.x;
X      lasttpos1.y = tpos1.y;
X      ltp1c = map[tpos1.x][tpos1.y];
X      lasttpos2.x = tpos2.x;
X      lasttpos2.y = tpos2.y;
X      ltp2c = map[tpos2.x][tpos2.y];
X      DoMove(lastaction);
X      undolock = _false_;
X      /* store the current keysym so we can do the repeat. */
X      oldmove = sym;
X    }
X  } while ((action != 0) && (packets != savepack) && (shift || cntrl));
X}
X
X/* make sure a move is valid and if it is, return type of move */
Xshort TestMove(KeySym action)
X{
X  short ret;
X  char tc;
X  Boolean stop_at_object;
X
X  stop_at_object = cntrl;
X
X  if((action == XK_Up) || (action == XK_k) || (action == XK_K)) {
X    tpos1.x = ppos.x-1;
X    tpos2.x = ppos.x-2;
X    tpos1.y = tpos2.y = ppos.y;
X  }
X  if((action == XK_Down) || (action == XK_j) || (action == XK_J)) {
X    tpos1.x = ppos.x+1;
X    tpos2.x = ppos.x+2;
X    tpos1.y = tpos2.y = ppos.y;
X  }
X  if((action == XK_Left) || (action == XK_h) || (action == XK_H)) {
X    tpos1.y = ppos.y-1;
X    tpos2.y = ppos.y-2;
X    tpos1.x = tpos2.x = ppos.x;
X  }
X  if((action == XK_Right) || (action == XK_l) || (action == XK_L)) {
X    tpos1.y = ppos.y+1;
X    tpos2.y = ppos.y+2;
X    tpos1.x = tpos2.x = ppos.x;
X  }
X  tc = map[tpos1.x][tpos1.y];
X  if((tc == packet) || (tc == save)) {
X    if(!stop_at_object) {
X      if(map[tpos2.x][tpos2.y] == ground)
X	ret = (tc == save) ? UNSAVE : PUSH;
X      else if(map[tpos2.x][tpos2.y] == store)
X	ret = (tc == save) ? STOREPUSH : SAVE;
X      else
X	ret = 0;
X    } else
X      ret = 0;
X  } else if(tc == ground)
X    ret = MOVE;
X  else if(tc == store)
X    ret = STOREMOVE;
X  else
X    ret = 0;
X  return ret;
X}
X
X/* actually update the internal map with the results of the move */
Xvoid DoMove(short moveaction)
X{
X  map[ppos.x][ppos.y] = (map[ppos.x][ppos.y] == player) ? ground : store;
X  switch( moveaction) {
X    case MOVE:
X      map[tpos1.x][tpos1.y] = player;
X      break;
X    case STOREMOVE:
X      map[tpos1.x][tpos1.y] = playerstore;
X      break;
X    case PUSH:
X      map[tpos2.x][tpos2.y] = map[tpos1.x][tpos1.y];
X      map[tpos1.x][tpos1.y] = player;
X      pushes++;
X      break;
X    case UNSAVE:
X      map[tpos2.x][tpos2.y] = packet;
X      map[tpos1.x][tpos1.y] = playerstore;
X      pushes++;
X      savepack--;
X      break;
X    case SAVE:
X      map[tpos2.x][tpos2.y] = save;
X      map[tpos1.x][tpos1.y] = player;
X      savepack++;
X      pushes++;
X      break;
X    case STOREPUSH:
X      map[tpos2.x][tpos2.y] = save;
X      map[tpos1.x][tpos1.y] = playerstore;
X      pushes++;
X      break;
X  }
X  moves++;
X  DisplayMoves();
X  DisplayPushes();
X  DisplaySave();
X  MapChar(map[ppos.x][ppos.y], ppos.x, ppos.y);
X  MapChar(map[tpos1.x][tpos1.y], tpos1.x, tpos1.y);
X  MapChar(map[tpos2.x][tpos2.y], tpos2.x, tpos2.y);
X  RedisplayScreen();
X  ppos.x = tpos1.x;
X  ppos.y = tpos1.y;
X}
X
X/* undo the most recently done move */
Xvoid UndoMove(void)
X{
X  map[lastppos.x][lastppos.y] = lppc;
X  map[lasttpos1.x][lasttpos1.y] = ltp1c;
X  map[lasttpos2.x][lasttpos2.y] = ltp2c;
X  ppos.x = lastppos.x;
X  ppos.y = lastppos.y;
X  switch( lastaction) {
X    case MOVE:
X      moves--;
X      break;
X    case STOREMOVE:
X      moves--;
X      break;
X    case PUSH:
X      moves--;
X      pushes--;
X      break;
X    case UNSAVE:
X      moves--;
X      pushes--;
X      savepack++;
X      break;
X    case SAVE:
X      moves--;
X      pushes--;
X      savepack--;
X      break;
X    case STOREPUSH:
X      moves--;
X      pushes--;
X      break;
X  }
X  DisplayMoves();
X  DisplayPushes();
X  DisplaySave();
X  MapChar(map[ppos.x][ppos.y], ppos.x, ppos.y);
X  MapChar(map[lasttpos1.x][lasttpos1.y], lasttpos1.x, lasttpos1.y);
X  MapChar(map[lasttpos2.x][lasttpos2.y], lasttpos2.x, lasttpos2.y);
X  RedisplayScreen();
X}
X
X/* make a temporary save so we don't screw up too much at once */
Xvoid TempSave(void)
X{
X  short i, j;
X
X  for( i = 0; i < rows; i++)
X    for( j = 0; j < cols; j++)
X       tmp_map[i][j] = map[i][j];
X  tmp_pushes = pushes;
X  tmp_moves = moves;
X  tmp_savepack = savepack;
X  tmp_ppos.x = ppos.x;
X  tmp_ppos.y = ppos.y;
X}
X
X/* restore from that little temp save */
Xvoid TempReset(void)
X{
X  short i, j;
X
X  for( i = 0; i < rows; i++)
X    for( j = 0; j < cols; j++)
X      map[i][j] = tmp_map[i][j];
X  pushes = tmp_pushes;
X  moves = tmp_moves;
X  savepack = tmp_savepack;
X  ppos.x = tmp_ppos.x;
X  ppos.y = tmp_ppos.y;
X}
X
X/* Function used by the help pager.  We ONLY want to flip pages if a key
X * key is pressed.. We want to exit the help pager if ENTER is pressed.
X * As above, <shift> and <control> and other such fun keys are NOT counted
X * as a keypress.
X */
XBoolean WaitForEnter(void)
X{
X  KeySym keyhit;
X  char buf[1];
X  int bufs = 1;
X  XComposeStatus compose;
X
X  while (1) {
X    XNextEvent(dpy, &xev);
X    switch(xev.type) {
X      case Expose:
X	RedisplayScreen();
X	break;
X      case KeyPress:
X	buf[0] = '\0';
X	XLookupString(&xev.xkey, buf, bufs, &keyhit, &compose);
X	if(buf[0]) {
X	  return (keyhit == XK_Return) ? _true_ : _false_;
X	}
X	break;
X      default:
X	break;
X    }
X  }
X}
X
X/* find the shortest path to the target via a fill search algorithm */
Xvoid FindTarget(int px, int py, int pathlen)
X{
X  if(!(ISCLEAR(px, py) || ISPLAYER(px, py)))
X    return;
X  if(findmap[px][py] <= pathlen)
X    return;
X
X  findmap[px][py] = pathlen++;
X
X  if((px == ppos.x) && (py == ppos.y))
X    return;
X
X  FindTarget(px - 1, py, pathlen);
X  FindTarget(px + 1, py, pathlen);
X  FindTarget(px, py - 1, pathlen);
X  FindTarget(px, py + 1, pathlen);
X}
X
X/* Do all the fun movement stuff with the mouse */
Xvoid MoveMan(int mx, int my)
X{
X  int i, j, cx, cy, x, y;
X
X  shift = cntrl = _false_;
X
X  /* reverse the screen coords to get the internal coords (yes, I know this 
X   * should be fixed) RSN */
X  y = wX(mx);
X  x = wY(my);
X
X  /* make sure we are within the bounds of the array */
X  if((x < 0) || (x > MAXROW) || (y < 0) || (y > MAXCOL)) {
X    HelpMessage();
X    return;
X  }
X
X  /* if we are clicking on an object, and are right next to it, we want to
X   * move the object.
X   */
X  if(ISPACKET(x, y)) {
X    if(ISPLAYER(x - 1, y))
X      MakeMove(XK_Down);
X    else if(ISPLAYER(x + 1, y))
X      MakeMove(XK_Up);
X    else if(ISPLAYER(x, y - 1))
X      MakeMove(XK_Right);
X    else if(ISPLAYER(x, y + 1))
X      MakeMove(XK_Left);
X    else {
X      /* we weren't right next to the object */
X      HelpMessage();
X      return;
X    }
X    return;
X  }
X
X  /* if we clicked on the player or a wall (or an object but that was already
X   * handled) the we don't want to move.
X   */
X  if(!ISCLEAR(x, y)) {
X    HelpMessage();
X    return;
X  }
X  /* okay.. this is a legal place to click, so set it up by filling the
X   * trace map with all impossible values
X   */
X  for(i = 0; i < MAXROW + 1; i++)
X    for (j = 0; j < MAXCOL + 1; j++)
X      findmap[i][j] = BADMOVE;
X  /* flood fill search to find any shortest path. */
X  FindTarget(x, y, 0);
X
X  /* if we didn't make it back to the players position, there is no valid path
X   * to that place.
X   */
X  if(findmap[ppos.x][ppos.y] == BADMOVE) {
X    HelpMessage();
X  } else {
X    /* we made it back, so let's walk the path we just built up */
X    cx = ppos.x;
X    cy = ppos.y;
X    while(findmap[cx][cy]) {
X      if(findmap[cx - 1][cy] == (findmap[cx][cy] - 1)) {
X	MakeMove(XK_Up);
X	cx--;
X      } else if(findmap[cx + 1][cy] == (findmap[cx][cy] - 1)) {
X	MakeMove(XK_Down);
X	cx++;
X      } else if(findmap[cx][cy - 1] == (findmap[cx][cy] - 1)) {
X	MakeMove(XK_Left);
X	cy--;
X      } else if(findmap[cx][cy + 1] == (findmap[cx][cy] - 1)) {
X	MakeMove(XK_Right);
X	cy++;
X      } else {
X	/* if we get here, something is SERIOUSLY wrong, so we should abort */
X	abort();
X      }
X    }
X  }
X}
END_OF_FILE
if test 12228 -ne `wc -c <'play.c'`; then
    echo shar: \"'play.c'\" unpacked with wrong size!
fi
# end of 'play.c'
fi
if test -f 'score.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'score.c'\"
else
echo shar: Extracting \"'score.c'\" \(6727 characters\)
sed "s/^X//" >'score.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <signal.h>
X#include <sys/types.h>
X#include <netinet/in.h>
X#include "externs.h"
X#include "globals.h"
X
Xextern FILE *fopen();
X
Xextern char *username;
Xextern short scorelevel, scoremoves, scorepushes;
X
Xstatic short scoreentries;
Xstatic struct {
X  char user[MAXUSERNAME];
X  unsigned short lv, pad1, mv, pad2, ps, pad3;
X} scoretable[MAXSCOREENTRIES];
X
Xstatic FILE *scorefile;
Xstatic long sfdbn;
X
X/* print out the score list */
Xshort OutputScore(void)
X{
X  short ret;
X
X  while (creat(LOCKFILE, 0666) < 0) ;	/* lock the score file */
X
X  if ((ret = ReadScore()) == 0)
X    ShowScore();
X  unlink(LOCKFILE);
X  return ((ret == 0) ? E_ENDGAME : ret);
X}
X
X/* create a new score file */
Xshort MakeNewScore(void)
X{
X  short ret = 0;
X
X  while (creat(LOCKFILE, 0666) < 0) ;
X  scoreentries = 0;
X
X  if ((scorefile = fopen(SCOREFILE, "w")) == NULL)
X    ret = E_FOPENSCORE;
X  else {
X    sfdbn = fileno(scorefile);
X    if (write(sfdbn, &scoreentries, 2) != 2)
X      ret = E_WRITESCORE;
X    fclose(scorefile);
X  }
X  unlink(LOCKFILE);
X  return ((ret == 0) ? E_ENDGAME : ret);
X}
X
X/* get the players current level based on the level they last scored on */
Xshort GetUserLevel(short *lv)
X{
X  short ret = 0, pos;
X
X  while (creat(LOCKFILE, 0666) < 0) ;
X
X  if ((scorefile = fopen(SCOREFILE, "r")) == NULL)
X    ret = E_FOPENSCORE;
X  else {
X    if ((ret = ReadScore()) == 0)
X      *lv = ((pos = FindUser()) > -1) ? scoretable[pos].lv + 1 : 1;
X  }
X  unlink(LOCKFILE);
X  return (ret);
X}
X
X/* Add a new score to the score file */
Xshort Score(void)
X{
X  short ret;
X
X  while (creat(LOCKFILE, 0666) < 0) ;	/* lock the score file */
X  if ((ret = ReadScore()) == 0)
X    if ((ret = MakeScore()) == 0)
X      if ((ret = WriteScore()) == 0)
X	ShowScore();
X  unlink(LOCKFILE);
X  return ((ret == 0) ? E_ENDGAME : ret);
X}
X
X/* read in an existing score file.  Uses the ntoh() and hton() functions
X * so that the score files transfer across systems.
X */
Xshort ReadScore(void)
X{
X  short ret = 0;
X  long tmp;
X
X  if ((scorefile = fopen(SCOREFILE, "r")) == NULL)
X    ret = E_FOPENSCORE;
X  else {
X    sfdbn = fileno(scorefile);
X    if (read(sfdbn, &scoreentries, 2) != 2)
X      ret = E_READSCORE;
X    else {
X      scoreentries = ntohs(scoreentries);
X      tmp = scoreentries * sizeof(scoretable[0]);
X      if (read(sfdbn, &(scoretable[0]), tmp) != tmp)
X	ret = E_READSCORE;
X
X      /* swap up for little-endian machines */
X      for (tmp = 0; tmp < scoreentries; tmp++) {
X	scoretable[tmp].lv = ntohs(scoretable[tmp].lv);
X	scoretable[tmp].mv = ntohs(scoretable[tmp].mv);
X	scoretable[tmp].ps = ntohs(scoretable[tmp].ps);
X      }
X    }
X    fclose(scorefile);
X  }
X  return ret;
X}
X
X/* makes a new user score.  uses the ntoh and hton functions to make sure
X * the score file is transferable across systems
X */
Xshort MakeScore(void)
X{
X  short ret = 0, pos, i;
X  Boolean insert, build = _true_;
X
X  if ((pos = FindUser()) > -1) {  /* user already in score file */
X    insert = ((scorelevel > scoretable[pos].lv) ||
X	      ((scorelevel == scoretable[pos].lv) &&
X	       (scoremoves < scoretable[pos].mv)) ||
X	      ((scorelevel == scoretable[pos].lv) &&
X	       (scoremoves == scoretable[pos].mv) &&
X	       (scorepushes < scoretable[pos].ps)));
X    if (insert) {		/* delete existing entry */
X      for (i = pos; i < scoreentries - 1; i++)
X	CopyEntry(i, i + 1);
X      scoreentries--;
X    } else
X      build = _false_;
X  } else if (scoreentries == MAXSCOREENTRIES)
X    ret = E_TOMUCHSE;
X  if ((ret == 0) && build) {
X    pos = FindPos();		/* find the new score position */
X    if (pos > -1) {		/* score table not empty */
X      for (i = scoreentries; i > pos; i--)
X	CopyEntry(i, i - 1);
X    } else
X      pos = scoreentries;
X
X    strcpy(scoretable[pos].user, username);
X    scoretable[pos].lv = scorelevel;
X    scoretable[pos].mv = scoremoves;
X    scoretable[pos].ps = scorepushes;
X    scoreentries++;
X  }
X  return ret;
X}
X
X/* searches the score table to find a specific player */
Xshort FindUser(void)
X{
X  short i;
X  Boolean found = _false_;
X
X  for (i = 0; (i < scoreentries) && (!found); i++)
X    found = (strcmp(scoretable[i].user, username) == 0);
X  return ((found) ? i - 1 : -1);
X}
X
X/* finds the position for a new score in the score table */ 
Xshort FindPos(void)
X{
X  short i;
X  Boolean found = _false_;
X
X  for (i = 0; (i < scoreentries) && (!found); i++)
X    found = ((scorelevel > scoretable[i].lv) ||
X	     ((scorelevel == scoretable[i].lv) &&
X	      (scoremoves < scoretable[i].mv)) ||
X	     ((scorelevel == scoretable[i].lv) &&
X	      (scoremoves == scoretable[i].mv) &&
X	      (scorepushes < scoretable[i].ps)));
X  return ((found) ? i - 1 : -1);
X}
X
X/* writes out the score table.  It uses ntoh() and hton() functions to make
X * the scorefile transfer across systems.
X */
Xshort WriteScore(void)
X{
X  short ret = 0;
X  long tmp;
X
X  if ((scorefile = fopen(SCOREFILE, "w")) == NULL)
X    ret = E_FOPENSCORE;
X  else {
X    sfdbn = fileno(scorefile);
X    scoreentries = htons(scoreentries);
X    if (write(sfdbn, &scoreentries, 2) != 2)
X      ret = E_WRITESCORE;
X    else {
X      scoreentries = ntohs(scoreentries);
X
X      /* swap around for little-endian machines */
X      for (tmp = 0; tmp < scoreentries; tmp++) {
X	scoretable[tmp].lv = htons(scoretable[tmp].lv);
X	scoretable[tmp].mv = htons(scoretable[tmp].mv);
X	scoretable[tmp].ps = htons(scoretable[tmp].ps);
X      }
X      tmp = scoreentries * sizeof(scoretable[0]);
X      if (write(sfdbn, &(scoretable[0]), tmp) != tmp)
X	ret = E_WRITESCORE;
X
X      /* and swap back for the rest of the run ... */
X      for (tmp = 0; tmp < scoreentries; tmp++) {
X	scoretable[tmp].lv = ntohs(scoretable[tmp].lv);
X	scoretable[tmp].mv = ntohs(scoretable[tmp].mv);
X	scoretable[tmp].ps = ntohs(scoretable[tmp].ps);
X      }
X    }
X    fclose(scorefile);
X  }
X  return ret;
X}
X
X/* displays the score table to the user */
Xvoid ShowScore(void)
X{
X  register short lastlv = 0, lastmv = 0, lastps = 0, i;
X
X  fprintf(stdout, "Rank        User     Level     Moves    Pushes\n");
X  fprintf(stdout, "==============================================\n");
X  for (i = 0; i < scoreentries; i++) {
X    if ((scoretable[i].lv == lastlv) &&
X	(scoretable[i].mv == lastmv) &&
X	(scoretable[i].ps == lastps))
X      fprintf(stdout, "      ");
X    else {
X      lastlv = scoretable[i].lv;
X      lastmv = scoretable[i].mv;
X      lastps = scoretable[i].ps;
X      fprintf(stdout, "%4d  ", i + 1);
X    }
X    fprintf(stdout, "%10s  %8d  %8d  %8d\n", scoretable[i].user,
X	    scoretable[i].lv, scoretable[i].mv, scoretable[i].ps);
X  }
X}
X
X/* duplicates a score entry */
Xvoid CopyEntry(short i1, short i2)
X{
X  strcpy(scoretable[i1].user, scoretable[i2].user);
X  scoretable[i1].lv = scoretable[i2].lv;
X  scoretable[i1].mv = scoretable[i2].mv;
X  scoretable[i1].ps = scoretable[i2].ps;
X}
END_OF_FILE
if test 6727 -ne `wc -c <'score.c'`; then
    echo shar: \"'score.c'\" unpacked with wrong size!
fi
# end of 'score.c'
fi
if test ! -d 'screens' ; then
    echo shar: Creating directory \"'screens'\"
    mkdir 'screens'
fi
if test ! -d 'screens' ; then
    echo shar: Creating directory \"'screens'\"
    mkdir 'screens'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
