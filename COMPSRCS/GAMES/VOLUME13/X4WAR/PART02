Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i078:  x4war - An X11 version of Chinese four-state war game, Part02/03
Message-ID: <2650@master.CNA.TEK.COM>
Date: 23 Mar 92 22:50:25 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1824
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Xiaobing Chen <xiaobing@cs.sfu.ca>
Posting-number: Volume 13, Issue 78
Archive-name: x4war/Part02
Environment: X11, Xlib, Xt



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 3)."
# Contents:  Makefile.simple bgbitmap.c bitmaps/go.xbm bitmaps/stop.xbm
#   war.c war.h x4war.man
# Wrapped by billr@saab on Mon Mar 23 14:49:05 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile.simple' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.simple'\"
else
echo shar: Extracting \"'Makefile.simple'\" \(345 characters\)
sed "s/^X//" >'Makefile.simple' <<'END_OF_FILE'
X#Makefile for x4war, under SunOS 4.1.1
X#
X# x4war
X#
X
XLDLIBS= -lXt -lX11
XCC= cc
X
X#CFLAGS= -g
XCFLAGS= -O
X
XOBJS= x4war.o war.o
X
Xx4war: $(OBJS)
X	$(CC) $(CFLAGS) -o $@ $(OBJS) $(LDLIBS)
X
Xx4war.o: x4war.c war.h
X	$(CC) $(CFLAGS) -c x4war.c
X
Xwar.o: war.c war.h
X	$(CC) $(CFLAGS) -c war.c
X
X
Xbgbitmap: bgbitmap.c war.h
X	$(CC) -o bgbitmap bgbitmap.c -lX11
X
X
END_OF_FILE
if test 345 -ne `wc -c <'Makefile.simple'`; then
    echo shar: \"'Makefile.simple'\" unpacked with wrong size!
fi
# end of 'Makefile.simple'
fi
if test -f 'bgbitmap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bgbitmap.c'\"
else
echo shar: Extracting \"'bgbitmap.c'\" \(14463 characters\)
sed "s/^X//" >'bgbitmap.c' <<'END_OF_FILE'
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#include <X11/Xatom.h>
X
X#include <stdio.h>
X
X#include "war.h"
X
XDisplay *display;
Xint screen_num;
XGC gc, undraw_gc;
XPixmap pixmap;
X
X
Xvoid main(argc, argv)
Xint argc;
Xchar **argv;
X{
X	XFontStruct *font_info;
X	XGCValues values;
X
X	if ((display = XOpenDisplay(NULL)) == NULL) {
X	    fprintf(stderr, "cannot open display\n");
X	    exit(-1);
X	}
X	screen_num = DefaultScreen(display);
X
X	pixmap = XCreatePixmap(display, RootWindow(display, screen_num),
X		DIMENSION, DIMENSION, 1);
X
X	font_info = XLoadQueryFont(display, "9x15bold");
X
X	values.arc_mode = ArcChord;
X
X	values.foreground = 0;
X	values.background = 1;
X	undraw_gc = XCreateGC(display, pixmap, GCForeground | GCBackground |
X		GCArcMode, &values);
X
X	values.foreground = 1;
X	values.background = 0;
X
X	values.font = font_info->fid;
X	gc = XCreateGC(display, pixmap, GCForeground|GCBackground|GCFont,
X		&values);
X
X	printf("'war_background.xbm' file will be created at ./bitmaps\n");
X	printf("please wait a second...\n");
X	draw();
X
X	XWriteBitmapFile(display, "war_background", pixmap,
X			DIMENSION, DIMENSION, -1, -1);
X	system("mv ./war_background ./bitmaps/war_background.xbm");
X
X	printf("completed!\n");
X
X	XUnloadFont(display, font_info->fid);
X	XFreeGC(display, gc);
X	XFreeGC(display, undraw_gc);
X	XCloseDisplay(display);
X	exit(0);
X}
X
X
X
Xdraw()
X{
X    static unsigned char dash_list[] = {10, 10};
X    int i, j;
X
X    XFillRectangle(display, pixmap, undraw_gc, 0, 0, DIMENSION, DIMENSION);
X
X    XDrawString(display, pixmap, gc, 110, 575, "DEATH ANGEL", 11);
X    XDrawString(display, pixmap, gc, 695, 628, "NEW GAME", 8);
X    XDrawString(display, pixmap, gc, 695, 668, "START WAR", 9);
X    XDrawString(display, pixmap, gc, 695, 708, "REDEPLOY", 8);
X    XDrawString(display, pixmap, gc, 695, 748, "PEACE", 5);
X    XDrawString(display, pixmap, gc, 695, 788, "SURRENDER", 9);
X    XDrawString(display, pixmap, gc, 695, 828, "QUIT", 4);
X
X    XSetLineAttributes(display, gc, 5, LineOnOffDash, CapButt, JoinMiter);
X    XSetDashes(display, gc, 0, dash_list, 2);
X
X    XDrawLine(display, pixmap, gc, P3, P1+50, P3, P6-50);
X    XDrawLine(display, pixmap, gc, P4, P1+50, P4, P6-50);
X    XDrawLine(display, pixmap, gc, P1+50, P3, P6-50, P3);
X    XDrawLine(display, pixmap, gc, P1+50, P4, P6-50, P4);
X
X    XDrawLine(display, pixmap, gc, P3, P1+50, P4, P1+50);
X    XDrawLine(display, pixmap, gc, P3, P2, P4, P2);
X    XDrawLine(display, pixmap, gc, P3, P5, P4, P5);
X    XDrawLine(display, pixmap, gc, P3, P6-50, P4, P6-50);
X
X    XDrawLine(display, pixmap, gc, P1+50, P3, P1+50, P4);
X    XDrawLine(display, pixmap, gc, P2, P3, P2, P4);
X    XDrawLine(display, pixmap, gc, P5, P3, P5, P4);
X    XDrawLine(display, pixmap, gc, P6-50, P3, P6-50, P4);
X
X    XDrawLine(display, pixmap, gc, P2, P3+100, P5, P3+100);
X    XDrawLine(display, pixmap, gc, P3+100, P2, P3+100, P5);
X
X    XSetLineAttributes(display, gc, 5, LineSolid, CapButt, JoinRound);
X    XDrawArc(display, pixmap, gc, P2-50, P2-50, 100, 100, 0, -90*64);
X    XDrawArc(display, pixmap, gc, P4, P2-50, 100, 100, 180*64, 90*64);
X    XDrawArc(display, pixmap, gc, P2-50, P4, 100, 100, 0, 90*64);
X    XDrawArc(display, pixmap, gc, P4, P4, 100, 100, 90*64, 90*64);
X
X    XSetLineAttributes(display, gc, 1, LineSolid, CapButt, JoinRound);
X
X    XDrawLine(display, pixmap, gc, P3-2, P1+50, P3-2, P6-50);
X    XDrawLine(display, pixmap, gc, P3+2, P1+50, P3+2, P6-50);
X    XDrawLine(display, pixmap, gc, P4-2, P1+50, P4-2, P6-50);
X    XDrawLine(display, pixmap, gc, P4+2, P1+50, P4+2, P6-50);
X    XDrawLine(display, pixmap, gc, P1+50, P3-2, P6-50, P3-2);
X    XDrawLine(display, pixmap, gc, P1+50, P3+2, P6-50, P3+2);
X    XDrawLine(display, pixmap, gc, P1+50, P4-2, P6-50, P4-2);
X    XDrawLine(display, pixmap, gc, P1+50, P4+2, P6-50, P4+2);
X
X    XDrawLine(display, pixmap, gc, P3, P1+48, P4, P1+48);
X    XDrawLine(display, pixmap, gc, P3, P1+52, P4, P1+52);
X    XDrawLine(display, pixmap, gc, P3, P2-2, P4, P2-2);
X    XDrawLine(display, pixmap, gc, P3, P2+2, P4, P2+2);
X    XDrawLine(display, pixmap, gc, P3, P5-2, P4, P5-2);
X    XDrawLine(display, pixmap, gc, P3, P5+2, P4, P5+2);
X    XDrawLine(display, pixmap, gc, P3, P6-52, P4, P6-52);
X    XDrawLine(display, pixmap, gc, P3, P6-48, P4, P6-48);
X
X    XDrawLine(display, pixmap, gc, P1+48, P3, P1+48, P4);
X    XDrawLine(display, pixmap, gc, P1+52, P3, P1+52, P4);
X    XDrawLine(display, pixmap, gc, P2-2, P3, P2-2, P4);
X    XDrawLine(display, pixmap, gc, P2+2, P3, P2+2, P4);
X    XDrawLine(display, pixmap, gc, P5-2, P3, P5-2, P4);
X    XDrawLine(display, pixmap, gc, P5+2, P3, P5+2, P4);
X    XDrawLine(display, pixmap, gc, P6-48, P3, P6-48, P4);
X    XDrawLine(display, pixmap, gc, P6-52, P3, P6-52, P4);
X
X    XDrawLine(display, pixmap, gc, P2, P3+98, P5, P3+98);
X    XDrawLine(display, pixmap, gc, P2, P3+102, P5, P3+102);
X    XDrawLine(display, pixmap, gc, P3+98, P2, P3+98, P5);
X    XDrawLine(display, pixmap, gc, P3+102, P2, P3+102, P5);
X
X    for (i=RIP_Y+50; i<RIP_Y+RIP_DIMENSION; i += 50)
X	XDrawLine(display, pixmap, gc, P1, i, P1+RIP_DIMENSION, i);
X    for (i=P1+50; i<P1+RIP_DIMENSION; i += 50)
X	XDrawLine(display, pixmap, gc, i, RIP_Y, i, RIP_Y+RIP_DIMENSION);
X
X    for (i=P3+50; i<P4; i += 50)
X	XDrawLine(display, pixmap, gc, i, P5, i, P6);
X    for (i=P5+50; i<P6-50; i += 50)
X	XDrawLine(display, pixmap, gc, P3, i, P4, i);
X    XDrawLine(display, pixmap, gc, P3, P5, P4, P6-50);
X    XDrawLine(display, pixmap, gc, P3, P5+100, P3+100, P6-50);
X    XDrawLine(display, pixmap, gc, P3+100, P5, P4, P5+100);
X    XDrawLine(display, pixmap, gc, P3, P6-50, P4, P5);
X    XDrawLine(display, pixmap, gc, P3, P5+100, P3+100, P5);
X    XDrawLine(display, pixmap, gc, P3+100, P6-50, P4, P5+100);
X
X    for (i=P3+50; i<P4; i += 50)
X	XDrawLine(display, pixmap, gc, i, P1, i, P2);
X    for (i=P1+100; i<P2; i += 50)
X	XDrawLine(display, pixmap, gc, P3, i, P4, i);
X    XDrawLine(display, pixmap, gc, P3, P1+50, P4, P2);
X    XDrawLine(display, pixmap, gc, P3, P2-100, P3+100, P2);
X    XDrawLine(display, pixmap, gc, P3+100, P1+50, P4, P2-100);
X    XDrawLine(display, pixmap, gc, P3, P2-100, P3+100, P1+50);
X    XDrawLine(display, pixmap, gc, P3, P2, P4, P1+50);
X    XDrawLine(display, pixmap, gc, P3+100, P2, P4, P2-100);
X
X    for (i=P3+50; i<P4; i += 50)
X	XDrawLine(display, pixmap, gc, P1, i, P2, i);
X    for (i=P1+100; i<P2; i += 50)
X	XDrawLine(display, pixmap, gc, i, P3, i, P4);
X    XDrawLine(display, pixmap, gc, P1+50, P3+100, P2-100, P4);
X    XDrawLine(display, pixmap, gc, P1+50, P3, P2, P4);
X    XDrawLine(display, pixmap, gc, P2-100, P3, P2, P3+100);
X    XDrawLine(display, pixmap, gc, P1+50, P3+100, P2-100, P3);
X    XDrawLine(display, pixmap, gc, P2, P3, P1+50, P4);
X    XDrawLine(display, pixmap, gc, P2-100, P4, P2, P3+100);
X
X    for (i=P3+50; i<P4; i += 50)
X	XDrawLine(display, pixmap, gc, P5, i, P6, i);
X    for (i=P5+50; i<P6-50; i += 50)
X	XDrawLine(display, pixmap, gc, i, P3, i, P4);
X    XDrawLine(display, pixmap, gc, P5, P3+100, P5+100, P4);
X    XDrawLine(display, pixmap, gc, P5, P3, P6-50, P4);
X    XDrawLine(display, pixmap, gc, P5+100, P3, P6-50, P3+100);
X    XDrawLine(display, pixmap, gc, P5, P3+100, P5+100, P3);
X    XDrawLine(display, pixmap, gc, P5, P4, P6-50, P3);
X    XDrawLine(display, pixmap, gc, P5+100, P4, P6-50, P3+100);
X
X    XSetLineAttributes(display, gc, 3, LineSolid, CapButt, JoinRound);
X
X    XDrawRectangle(display, pixmap, gc, TALK_L_X,TALK_Y,TALK_WIDTH,TALK_HEIGHT);
X    XDrawRectangle(display, pixmap, gc, TALK_L_X, TALK_Y+90,
X		TALK_WIDTH, TALK_HEIGHT);
X    XDrawRectangle(display, pixmap, gc, TALK_R_X,TALK_Y,TALK_WIDTH,TALK_HEIGHT);
X    XDrawRectangle(display, pixmap, gc, TALK_R_X, TALK_Y+90,
X		TALK_WIDTH, TALK_HEIGHT);
X
X    XDrawRectangle(display, pixmap, gc, P1, P1, 66, 66);
X    XDrawRectangle(display, pixmap, gc, MSG_BOX_X, MSG_BOX_Y,
X		MSG_WIDTH, MSG_HEIGHT);
X
X    XDrawLine(display, pixmap, gc, P3-1, P1-1, P3-1, P1+50);
X    XDrawLine(display, pixmap, gc, P4+1, P1-1, P4+1, P1+50);
X    XDrawLine(display, pixmap, gc, P3-1, P1-1, P4+1, P1-1);
X
X    XDrawLine(display, pixmap, gc, P3-1, P6-50, P3-1, P6+1);
X    XDrawLine(display, pixmap, gc, P4+1, P6-50, P4+1, P6+1);
X    XDrawLine(display, pixmap, gc, P3-1, P6+1, P4+1, P6+1);
X
X    XDrawLine(display, pixmap, gc, P6-50, P3-1, P6+1, P3-1);
X    XDrawLine(display, pixmap, gc, P6-50, P4+1, P6+1, P4+1);
X    XDrawLine(display, pixmap, gc, P6+1, P3-1, P6+1, P4+1);
X
X    XDrawLine(display, pixmap, gc, P1-1, P3-1, P1+50, P3-1);
X    XDrawLine(display, pixmap, gc, P1-1, P4+1, P1+50, P4+1);
X    XDrawLine(display, pixmap, gc, P1-1, P3-1, P1-1, P4+1);
X
X    XDrawRectangle(display, pixmap, gc, P1, RIP_Y, 
X	RIP_DIMENSION-1,RIP_DIMENSION-1);
X
X    for (i=NEW_Y; i<=NEW_Y+BUTTON_DIS*5; i += BUTTON_DIS)
X	XDrawRectangle(display, pixmap, gc, BUTTON_X, i,
X	    BUTTON_WIDTH, BUTTON_HEIGHT);
X
X    XSetLineAttributes(display, gc, 2, LineSolid, CapButt, JoinRound);
X
X    XFillArc(display, pixmap, undraw_gc, P3+30, P1+80, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P3+30, P1+80, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P4-70, P1+80, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P4-70, P1+80, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P3+80, P2-120, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P3+80, P2-120, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P3+30, P2-70, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P3+30, P2-70, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P4-70, P2-70, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P4-70, P2-70, 40, 40, 0, 360*64);
X
X    XFillArc(display, pixmap, undraw_gc, P5+30, P3+30, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P5+30, P3+30, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P5+30, P4-70, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P5+30, P4-70, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P5+80, P3+80, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P5+80, P3+80, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P6-120, P3+30, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P6-120, P3+30, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P6-120, P4-70, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P6-120, P4-70, 40, 40, 0, 360*64);
X
X    XFillArc(display, pixmap, undraw_gc, P1+80, P3+30, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P1+80, P3+30, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P1+80, P4-70, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P1+80, P4-70, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P1+130, P3+80, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P1+130, P3+80, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P2-70, P3+30, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P2-70, P3+30, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P2-70, P4-70, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P2-70, P4-70, 40, 40, 0, 360*64);
X
X    XFillArc(display, pixmap, undraw_gc, P3+30, P5+30, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P3+30, P5+30, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P3+30, P6-120, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P3+30, P6-120, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P3+80, P5+80, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P3+80, P5+80, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P4-70, P5+30, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P4-70, P5+30, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P4-70, P6-120, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P4-70, P6-120, 40, 40, 0, 360*64);
X
X    for (i=P3-15; i<P4; i += 100)
X      for (j=P3-15; j<P4; j += 100) {
X	XFillRectangle(display, pixmap, undraw_gc, i, j, 30, 30);
X	XDrawRectangle(display, pixmap, gc, i, j, 29, 29);
X    }
X
X    for (i=P3-20; i<P4; i += 50)
X      for (j=P5-10; j<P6; j += 50)
X	if (i==P3+30 && j==P5+40 || i==P4-70 && j==P5+40 ||
X		i==P3+80 && j==P5+90 ||
X	    i==P3+30 && j==P6-110 || i==P4-70 && j==P6-110 )
X	    ;
X	else {
X	    XFillRectangle(display, pixmap, undraw_gc, i, j, 40, 20);
X	    XDrawRectangle(display, pixmap, gc, i, j, 40, 20);
X	}
X
X    for (i=P3-20; i<P4; i += 50)
X      for (j=P1-10; j<P2; j += 50)
X	if (i==P3+30 && j==P1+90 || i==P4-70 && j==P1+90 ||
X		i==P3+80 && j==P2-110 ||
X	    i==P3+30 && j==P2-60 || i==P4-70 && j==P2-60 )
X	    ;
X	else {
X	    XFillRectangle(display, pixmap, undraw_gc, i, j, 40, 20);
X	    XDrawRectangle(display, pixmap, gc, i, j, 40, 20);
X	}
X
X    for (i=P1-10; i<P2; i += 50)
X      for (j=P3-20; j<P4; j += 50)
X	if (i==P1+90 && j==P3+30 || i==P2-60 && j==P3+30 ||
X		i==P2-110 && j==P3+80 ||
X	    i==P1+90 && j==P4-70 || i==P2-60 && j==P4-70)
X	    ;
X	else {
X	    XFillRectangle(display, pixmap, undraw_gc, i, j, 20, 40);
X	    XDrawRectangle(display, pixmap, gc, i, j, 20, 40);
X	}
X
X    for (i=P5-10; i<P6; i += 50)
X      for (j=P3-20; j<P4; j += 50)
X	if (i==P5+40 && j==P3+30 || i==P6-110 && j==P3+30 ||
X		i==P5+90 && j==P3+80 ||
X	    i==P5+40 && j==P4-70 || i==P6-110 && j==P4-70)
X	    ;
X	else {
X	    XFillRectangle(display, pixmap, undraw_gc, i, j, 20, 40);
X	    XDrawRectangle(display, pixmap, gc, i, j, 20, 40);
X	}
X
X    XFillArc(display, pixmap, undraw_gc, P3+35, P1-14, 30, 30, 210*64, 120*64);
X    XDrawArc(display, pixmap, gc, P3+35, P1-14, 30, 30, 215*64, 110*64);
X    XFillArc(display, pixmap, undraw_gc, P4-65, P1-14, 30, 30, 210*64, 120*64);
X    XDrawArc(display, pixmap, gc, P4-65, P1-14, 30, 30, 215*64, 110*64);
X
X    XFillArc(display, pixmap, undraw_gc, P3+35, P6-16, 30, 30, 30*64, 120*64);
X    XDrawArc(display, pixmap, gc, P3+35, P6-16, 30, 30, 35*64, 110*64);
X    XFillArc(display, pixmap, undraw_gc, P4-65, P6-16, 30, 30, 30*64, 120*64);
X    XDrawArc(display, pixmap, gc, P4-65, P6-16, 30, 30, 35*64, 110*64);
X
X    XFillArc(display, pixmap, undraw_gc, P1-14, P3+35, 30, 30, 60*64, -120*64);
X    XDrawArc(display, pixmap, gc, P1-14, P3+35, 30, 30, 55*64, -110*64);
X    XFillArc(display, pixmap, undraw_gc, P1-14, P4-65, 30, 30, 60*64, -120*64);
X    XDrawArc(display, pixmap, gc, P1-14, P4-65, 30, 30, 55*64, -110*64);
X
X    XFillArc(display, pixmap, undraw_gc, P6-16, P3+35, 30, 30, 120*64, 120*64);
X    XDrawArc(display, pixmap, gc, P6-16, P3+35, 30, 30, 125*64, 110*64);
X    XFillArc(display, pixmap, undraw_gc, P6-16, P4-65, 30, 30, 120*64, 120*64);
X    XDrawArc(display, pixmap, gc, P6-16, P4-65, 30, 30, 125*64, 110*64);
X}
X
X
X
END_OF_FILE
if test 14463 -ne `wc -c <'bgbitmap.c'`; then
    echo shar: \"'bgbitmap.c'\" unpacked with wrong size!
fi
# end of 'bgbitmap.c'
fi
if test -f 'bitmaps/go.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/go.xbm'\"
else
echo shar: Extracting \"'bitmaps/go.xbm'\" \(3271 characters\)
sed "s/^X//" >'bitmaps/go.xbm' <<'END_OF_FILE'
X#define go_width 64
X#define go_height 64
Xstatic char go_bits[] = {
X   0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff,
X   0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x0f, 0x00, 0x00,
X   0x00, 0x00, 0xfe, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff,
X   0xff, 0xff, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x83, 0xe0, 0xff, 0x01, 0x00,
X   0x00, 0xf0, 0x7f, 0x80, 0x00, 0xff, 0x07, 0x00, 0x00, 0xf8, 0x0f, 0xc0,
X   0x01, 0xf8, 0x0f, 0x00, 0x00, 0xfc, 0x03, 0xc0, 0x01, 0xe0, 0x1f, 0x00,
X   0x00, 0xfe, 0x00, 0xe0, 0x03, 0x80, 0x3f, 0x00, 0x00, 0x7f, 0x00, 0xf0,
X   0x07, 0x00, 0x7f, 0x00, 0x80, 0x3f, 0x00, 0xf0, 0x07, 0x00, 0xfe, 0x00,
X   0xc0, 0x1f, 0x00, 0xf0, 0x07, 0x00, 0xfc, 0x01, 0xc0, 0x0f, 0x00, 0xf8,
X   0x0f, 0x00, 0xf8, 0x01, 0xe0, 0x07, 0x00, 0xfc, 0x1f, 0x00, 0xf0, 0x03,
X   0xf0, 0x03, 0x00, 0xfc, 0x1f, 0x00, 0xe0, 0x07, 0xf0, 0x01, 0x00, 0xfe,
X   0x3f, 0x00, 0xc0, 0x07, 0xf8, 0x01, 0x00, 0xfe, 0x3f, 0x00, 0xc0, 0x0f,
X   0xf8, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x80, 0x0f, 0xfc, 0x00, 0x00, 0xff,
X   0x7f, 0x00, 0x80, 0x1f, 0x7c, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x1f,
X   0x7c, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x1f, 0x7e, 0x00, 0x00, 0xe0,
X   0x03, 0x00, 0x00, 0x3f, 0x3e, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x3e,
X   0x3e, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x3e, 0x3e, 0x00, 0x00, 0xe0,
X   0x03, 0x00, 0x00, 0x3e, 0x1f, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x7c,
X   0x1f, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x7c, 0x1f, 0x00, 0x00, 0xe0,
X   0x03, 0x00, 0x00, 0x7c, 0x1f, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x7c,
X   0x1f, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x7c, 0x1f, 0x00, 0x00, 0xe0,
X   0x03, 0x00, 0x00, 0x7c, 0x1f, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x7c,
X   0x1f, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x7c, 0x1f, 0x00, 0x00, 0xe0,
X   0x03, 0x00, 0x00, 0x7c, 0x1f, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x7c,
X   0x1f, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x7c, 0x3e, 0x00, 0x00, 0xe0,
X   0x03, 0x00, 0x00, 0x3e, 0x3e, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x3e,
X   0x3e, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x3e, 0x7e, 0x00, 0x00, 0xe0,
X   0x03, 0x00, 0x00, 0x3f, 0x7c, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x1f,
X   0x7c, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0xe0,
X   0x03, 0x00, 0x80, 0x1f, 0xf8, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x80, 0x0f,
X   0xf8, 0x01, 0x00, 0xe0, 0x03, 0x00, 0xc0, 0x0f, 0xf0, 0x01, 0x00, 0xe0,
X   0x03, 0x00, 0xc0, 0x07, 0xf0, 0x03, 0x00, 0xe0, 0x03, 0x00, 0xe0, 0x07,
X   0xe0, 0x07, 0x00, 0xe0, 0x03, 0x00, 0xf0, 0x03, 0xc0, 0x0f, 0x00, 0xe0,
X   0x03, 0x00, 0xf8, 0x01, 0xc0, 0x1f, 0x00, 0xe0, 0x03, 0x00, 0xfc, 0x01,
X   0x80, 0x3f, 0x00, 0xe0, 0x03, 0x00, 0xfe, 0x00, 0x80, 0x7f, 0x00, 0xe0,
X   0x03, 0x00, 0x7f, 0x00, 0x00, 0xfe, 0x00, 0xe0, 0x03, 0x80, 0x3f, 0x00,
X   0x00, 0xfc, 0x03, 0xe0, 0x03, 0xe0, 0x1f, 0x00, 0x00, 0xf8, 0x0f, 0xe0,
X   0x03, 0xf8, 0x0f, 0x00, 0x00, 0xf0, 0x7f, 0x00, 0x00, 0xff, 0x07, 0x00,
X   0x00, 0xc0, 0xff, 0x03, 0xe0, 0xff, 0x01, 0x00, 0x00, 0x80, 0xff, 0xff,
X   0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x3f, 0x00, 0x00,
X   0x00, 0x00, 0xf8, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff,
X   0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
X
X
END_OF_FILE
if test 3271 -ne `wc -c <'bitmaps/go.xbm'`; then
    echo shar: \"'bitmaps/go.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/go.xbm'
fi
if test -f 'bitmaps/stop.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/stop.xbm'\"
else
echo shar: Extracting \"'bitmaps/stop.xbm'\" \(3277 characters\)
sed "s/^X//" >'bitmaps/stop.xbm' <<'END_OF_FILE'
X#define stop_width 64
X#define stop_height 64
Xstatic char stop_bits[] = {
X   0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff,
X   0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x0f, 0x00, 0x00,
X   0x00, 0x00, 0xfe, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff,
X   0xff, 0xff, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x03, 0xe0, 0xff, 0x01, 0x00,
X   0x00, 0xf0, 0x7f, 0x00, 0x00, 0xff, 0x07, 0x00, 0x00, 0xf8, 0x0f, 0x00,
X   0x00, 0xf8, 0x0f, 0x00, 0x00, 0xfc, 0x03, 0x00, 0x00, 0xe0, 0x1f, 0x00,
X   0x00, 0xfe, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x7f, 0x00, 0x00,
X   0x00, 0x00, 0x7f, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00,
X   0xc0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x01, 0xc0, 0x0f, 0x00, 0x00,
X   0x00, 0x00, 0xf8, 0x01, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x03,
X   0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0xf0, 0x01, 0x00, 0x00,
X   0x00, 0x00, 0xc0, 0x07, 0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x0f,
X   0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x0f, 0xfc, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x80, 0x1f, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
X   0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x7e, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x3f, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e,
X   0x3e, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x3e, 0x3e, 0x00, 0x00, 0x60,
X   0x48, 0x00, 0x00, 0x3e, 0x1f, 0x00, 0x00, 0x20, 0xf9, 0x00, 0x00, 0x7c,
X   0x1f, 0x00, 0x00, 0x60, 0xf3, 0x81, 0x00, 0x7c, 0x1f, 0x00, 0x00, 0xe0,
X   0xff, 0xc3, 0x00, 0x7c, 0x1f, 0x00, 0x00, 0xe0, 0xff, 0xe7, 0x01, 0x7c,
X   0x1f, 0x00, 0x00, 0xe0, 0xfb, 0xff, 0x01, 0x7c, 0x1f, 0x00, 0x00, 0xe0,
X   0xf3, 0xff, 0x01, 0x7c, 0x1f, 0x00, 0x00, 0xe0, 0xe3, 0xff, 0x01, 0x7c,
X   0x1f, 0x00, 0x00, 0xe0, 0xc3, 0xff, 0x01, 0x7c, 0x1f, 0x00, 0x00, 0xe0,
X   0x83, 0xff, 0x01, 0x7c, 0x1f, 0x00, 0x00, 0xe0, 0xc3, 0xff, 0x01, 0x7c,
X   0x1f, 0x00, 0x00, 0xe0, 0xe3, 0xff, 0x03, 0x7c, 0x3e, 0x00, 0x00, 0xe0,
X   0xf3, 0xff, 0x03, 0x3e, 0x3e, 0x00, 0x00, 0xe0, 0x03, 0xff, 0x03, 0x3e,
X   0x3e, 0x00, 0x00, 0xe0, 0x03, 0xe0, 0x07, 0x3e, 0x7e, 0x00, 0x00, 0xe0,
X   0x03, 0x80, 0x07, 0x3f, 0x7c, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x04, 0x1f,
X   0x7c, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0xe0,
X   0x03, 0x00, 0x80, 0x1f, 0xf8, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x80, 0x0f,
X   0xf8, 0x01, 0x00, 0xe0, 0x03, 0x00, 0xc0, 0x0f, 0xf0, 0x01, 0x00, 0xe0,
X   0x03, 0x00, 0xc0, 0x07, 0xf0, 0x03, 0x00, 0xe0, 0x03, 0x00, 0xe0, 0x07,
X   0xe0, 0x07, 0x00, 0xe0, 0x03, 0x00, 0xf0, 0x03, 0xc0, 0x0f, 0x00, 0xe0,
X   0x03, 0x00, 0xf8, 0x01, 0xc0, 0x1f, 0x00, 0xe0, 0x03, 0x00, 0xfc, 0x01,
X   0x80, 0x3f, 0x00, 0xe0, 0x03, 0x00, 0xfe, 0x00, 0x80, 0x7f, 0x00, 0xe0,
X   0x03, 0x00, 0x7f, 0x00, 0x00, 0xfe, 0x00, 0xe0, 0x03, 0x80, 0x3f, 0x00,
X   0x00, 0xfc, 0x03, 0xe0, 0x03, 0xe0, 0x1f, 0x00, 0x00, 0xf8, 0x0f, 0xe0,
X   0x03, 0xf8, 0x0f, 0x00, 0x00, 0xf0, 0x7f, 0x00, 0x00, 0xff, 0x07, 0x00,
X   0x00, 0xc0, 0xff, 0x03, 0xe0, 0xff, 0x01, 0x00, 0x00, 0x80, 0xff, 0xff,
X   0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x3f, 0x00, 0x00,
X   0x00, 0x00, 0xf8, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff,
X   0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
X
X
END_OF_FILE
if test 3277 -ne `wc -c <'bitmaps/stop.xbm'`; then
    echo shar: \"'bitmaps/stop.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/stop.xbm'
fi
if test -f 'war.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'war.c'\"
else
echo shar: Extracting \"'war.c'\" \(21847 characters\)
sed "s/^X//" >'war.c' <<'END_OF_FILE'
X#include "war.h"
X
Xextern Arr arr[4][6][5], mid[3][3];
X
Xextern Sapper_path sap[];
X
Xextern int round;
X
X/*******************************************************************
X*
X*   Synopsis
X*	fatal_error(s)
X*	    char *s;
X*
X*   Description
X*	it prints s as an error message and exit.
X*
X*******************************************************************/
X
Xfatal_error(s)
Xchar *s;
X{
X    printf("%s\n", s);
X    exit(-1);
X}
X
X
X
X/****************************************************************
X*
X*   Synopsis
X*	syntax(s)
X*	    char *s;
X*
X*   Argument
X*	s	the program name, usually x4war;
X*
X*   Description
X*	x4war command line arguments specification
X*
X****************************************************************/
X
Xsyntax(s)
Xchar *s;
X{
X    printf("Usage: %s [options ...]\n\n", s);
X    printf("where options include:\n");
X    printf("\t-p0 string\t\tplayer0's name\n");
X    printf("\t-d0 string\t\tplayer0's display\n");
X    printf("\t-c0 string\t\tplayer0's node color\n");
X    printf("\t-p1 string\t\tplayer1's name\n");
X    printf("\t-d1 string\t\tplayer1's display\n");
X    printf("\t-c1 string\t\tplayer1's node color\n");
X    printf("\t-p2 string\t\tplayer2's name\n");
X    printf("\t-d2 string\t\tplayer2's display\n");
X    printf("\t-c2 string\t\tplayer2's node color\n");
X    printf("\t-p3 string\t\tplayer3's name\n");
X    printf("\t-d3 string\t\tplayer3's display\n");
X    printf("\t-c3 string\t\tplayer3's node color\n");
X    printf("\t-debug\t\t\ta default deploy\n");
X    printf("\t-usage\t\t\tthis usage list\n\n");
X}
X
X
X
X/***********************************************************************
X *
X *  Synopsis
X *	int fight(x, y)
X *	    int x, y;
X *
X *  Arguments
X *	x, y	representing two node values between COLOURS and BOMB.
X *		x must be a movable, i.e., not COLOURS and MINE.
X *
X *  Return values
X *	x < y: return 2;
X *	x = y: return 3;
X *	x > y: return 4;
X *
X *  Description
X *	it returns the fighting result when node x moved to meet node y.
X *
X ***********************************************************************/
X
Xint fight(x, y)
Xint x, y;
X{
X    if (x==SAPPER && y==MINE)  return(4);
X    if (x==BOMB || y==BOMB)  return(3);
X    if (x==y) return(3);
X    if (x<y)  return(2);
X    if (x>y)  return(4);
X}
X
X
X/**********************************************************************
X*
X*   Synopsis
X*	int boardtofield(x, y, i, j)
X*	    int x, y;
X*	    int *i, *j;		return values
X*
X*   Arguments
X*	x, y	coordinates of a point on board;
X*	*i, *j  contain the converted field coordinates;
X*
X*   Return values
X*	return a value from F0 to OTHERPLACE according to the position (x,y),
X*	i and j are set if returned values between F0 and RIP.
X*
X***********************************************************************/
X
Xint boardtofield(x, y, i, j)
Xint x, y, *i, *j;
X{
X    if (x>=315 && x<=555 && y>=565 && y<=855) {
X	*j = (x-310)/50;
X	*i = (y-560)/50;
X	return(F0);
X    }
X    if (x>=565 && x<=855 && y>=315 && y<=555) {
X	*i = (x-560)/50;
X	*j = 4-(y-310)/50;
X	return(F1);
X    }
X    if (x>=315 && x<=555 && y>=15 && y<=305) {
X	*i = 5-(y-10)/50;
X	*j = 4-(x-310)/50;
X	return(F2);
X    }
X    if (x>=15 && x<=305 && y>=315 && y<=555) {
X	*i = 5-(x-10)/50;
X	*j = (y-310)/50;
X	return(F3);
X    }
X    if (x>=315 && x<=555 && y>=315 && y<=555) {
X	*j = (x-310)/100;
X	*i = (y-310)/100;
X	return(MIDFIELD);
X    }
X    if (x>=35 && x<=285 && y>=585 && y<=835) {
X	*j = (x-35)/50;
X	*i = (y-585)/50;
X	return(RIP);
X    }
X
X    if (x>=BUTTON_X && x<=BUTTON_X + BUTTON_WIDTH) {
X	if (y>=610 && y<=635)  return(NEW);
X	if (y>=650 && y<=675)  return(READY);
X	if (y>=690 && y<=715)  return(REDEPLOY);
X	if (y>=730 && y<=755)  return(PEACE);
X	if (y>=770 && y<=795)  return(SURRENDER);
X	if (y>=810 && y<=835)  return(QUIT);
X    }
X    return(OTHERPLACE);
X}
X
X
X
X/********************************************************************
X*
X*   Synopsis
X*	fieldtoboard(f, i, j, x, y)
X*	    int f, i, j;
X*	    int *x, *y;		return
X*
X*   Arguments
X*	f	field id between F0 and RIP;
X*	i, j	coordinates of the field;
X*	*x, *y	contains returned values of coordinates of the board;
X*
X*********************************************************************/
X
Xfieldtoboard(f, i, j, x, y)
Xint f, i, j, *x, *y;
X{
X    switch (f) {
X      case F0:
X	*x = 335+j*50;
X	*y = 585+i*50;
X	break;
X      case F1:
X	*x = 585+i*50;
X	*y = 335+(4-j)*50;
X	break;
X      case F2:
X	*x = 335+(4-j)*50;
X	*y = 35+(5-i)*50;
X	break;
X      case F3:
X	*x = 35+(5-i)*50;
X	*y = 335+j*50;
X	break;
X      case MIDFIELD:
X	*x = 335+j*100;
X	*y = 335+i*100;
X	break;
X      case RIP:
X	*x = 60+j*50;
X	*y = 610+i*50;
X    }
X}
X
X
X
X/**********************************************************************
X*
X*   Synopsis
X*	arrtoboard(id, g, i, j, x, y)
X*	    int id, g, i, j;
X*	    int *x, *y;		return
X*
X*   Arguments
X*	id	0-3, specifies the player of the board;
X*	g	F0 - RIP, which array;
X*	i, j	coordinates of the array;
X*	*x, *y  contains the results;
X*
X**********************************************************************/
X
Xarrtoboard(id, g, i, j, x, y)
Xint id, g, i, j, *x, *y;
X{
X    int k;
X
X    if (g==MIDFIELD)
X	switch (id) {
X	  case 1:
X	    k = i;  i = j;  j = 2-k;
X	    break;
X	  case 2:
X	    i = 2-i;  j = 2-j;
X	    break;
X	  case 3:
X	    k = i;  i = 2-j; j = k;
X	}
X    else if (g != RIP) {
X	g -= id;
X	if (g<0) g += 4;
X    }
X    fieldtoboard(g,i,j,x,y);
X}
X
X
X
X
X
X/*********************************************************************
X*
X*   Synopsis
X*	int fieldtoarr(id, f, fi, fj, ai, aj)
X*	    int id, f, fi, fj;
X*	    int *ai, *aj;
X*
X*   Arguments
X*	id	0-3, the player of the board;
X*	f	F0 - RIP, field number;
X*	fi, fj	coordinates in the field;
X*	*ai, *aj	result coordinates of the array;
X*
X*   Return value
X*	returns which array is resulted
X*
X**********************************************************************/
X
Xint fieldtoarr(id, f, fi, fj, ai, aj)
Xint id, f, fi, fj, *ai, *aj;
X{
X    *ai = fi;
X    *aj = fj;
X    if ( f==MIDFIELD )
X	switch (id) {
X	  case 1:
X	    *ai = 2-fj; *aj = fi;
X	    break;
X	  case 2:
X	    *ai = 2 - fi; *aj = 2 - fj;
X	    break;
X	  case 3:
X	    *ai = fj;  *aj = 2 - fi;
X	}
X    return((f>=F0 && f<MIDFIELD) ? (f+id)%4 : f);
X}
X
X
X
X/*********************************************************************
X*
X*   Synopsis
X*	int boardtoarr(f, x, y, i, j)
X*	    int f, x, y, *i, *j;
X*
X*   Arguments
X*	f	specifies who's board;
X*	x, y	the coordinates on board;
X*	*i, *j	return the coordinates in the array;
X*
X*   Return value
X*	it returns which array the point corresponds.
X*	returns -1 if no array to match.
X*
X**********************************************************************/
X
Xint boardtoarr(f, x, y, i, j)
Xint f, x, y, *i, *j;
X{
X    int m, n, s;
X
X    s = boardtofield(x, y, &m, &n);
X    if (s > RIP) return(-1);
X    s = fieldtoarr(f, s, m, n, i, j);
X    return(s);
X}
X
X
X
X
X/************************************************************************
X*
X*   Synopsis
X*	int area_intersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2,
X*		cx1, cy1, cx2, cy2)
X*	    int ax1, ay1, ax2, ay2, bx1, by1, bx2, by2;
X*	    int *cx1, *cy1, *cx2, *cy2;		return
X*
X*   Arguments
X*	a's and b's:	coordinates of two rectangles;
X*	c's		contains the coordinates of the intersection area;
X*
X*   Return values
X*	1	if the two rectangles intersect, and c's are set;
X*	0	if the two rectangles not intersect;
X*
X**************************************************************************/
X
Xint area_intersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2,
X	    cx1, cy1, cx2, cy2)
Xint ax1, ay1, ax2, ay2, bx1, by1, bx2, by2, *cx1, *cy1, *cx2, *cy2;
X{
X    int k;
X
X    if (ax1>ax2) {
X	k = ax1; ax1 = ax2; ax2 = k;
X    }
X    if (ay1>ay2) {
X	k = ay1; ay1 = ay2; ay2 = k;
X    }
X    if (bx1>bx2) {
X	k = bx1; bx1 = bx2; bx2 = k;
X    }
X    if (by1>by2) {
X	k = by1; by1 = by2; by2 = k;
X    }
X    *cx2 = (ax2<bx2) ? ax2 : bx2;
X    *cy2 = (ay2<by2) ? ay2 : by2;
X    if (ax1<=bx1 && ay1<=by1 && bx1<ax2 && by1<ay2) {
X	*cx1 = bx1;  *cy1 = by1;
X	return(1);
X    }
X    if (ax1<=bx1 && ay1>by1 && ay1<by2 && ax2>bx1) {
X	*cx1 = bx1; *cy1 = ay1;
X	return(1);
X    }
X    if (ax1>bx1 && ay1>by1 && ax1<bx2 && ay1<by2) {
X	*cx1 = ax1; *cy1 = ay1;
X	return(1);
X    }
X    if (ax1>bx1 && ay1<by1 && ax1<bx2 && ay2>by1) {
X	*cx1 = ax1; *cy1 = by1;
X	return(1);
X    }
X    return(0);
X}
X
X
X
X
X/**********************************************************************
X*
X*   Synopsis
X*	int sapper_check(i, x, y, z)
X*	    int i, x, y, z;
X*
X*   Arguments
X*	i	start check from i of sap[];
X*	x, y, z the destination;
X*
X*   Return values
X*	0	if cannot reach destination;
X*	1	if can reach destination;
X*
X*   Side effect
X*	mark all visited nodes to round.
X*
X*   Description
X*	it recursively checks if a SAPPER can reach a destination, starting
X*	from a position in sap[i]; sap[i] must not have been visited, and
X*	the starting position must not be the destination.
X*
X***********************************************************************/
X
Xint sapper_check(i, x, y, z)
Xint i, x, y, z;
X{
X    int m, n, a, b, c, j;
X
X    sap[i].visited = round;
X    m = 0;
X    if (i<12) {
X	a = i/3;
X	c = 2*(i%3);
X	if (c==0) {
X	    n = (a-1);
X	    if (n<0)  n = 3;
X	    if (y==0 && z==4 && x==n)  return(1);
X	    if (sap[n*3+2].visited != round && arr[n][0][4].value == EMPTY)
X		m = sapper_check(n*3+2, x, y, z);
X	    if (m) return(1);
X
X	    n = sap[i].neighbor[0];
X	    b = (n-12)/3;
X	    c = (n-12)%3;
X	    if (x==MIDFIELD && y==b && z==c)  return(1);
X	    if (sap[n].visited != round && mid[b][c].value == EMPTY)
X		m = sapper_check(n, x, y, z);
X	    if (m) return(1);
X
X	    if (x==a && y==0 && z==1)  return(1);
X	    if (arr[a][0][1].value == EMPTY) {
X		if (x==a && y==0 && z==2)  return(1);
X		if (sap[a*3+1].visited != round && arr[a][0][2].value == EMPTY)
X		    m = sapper_check(a*3+1, x, y, z);
X		if (m) return(1);
X	    }
X
X	    if (a==x || sap[a*3+2].visited != round) {
X		if (a==x && z==0) {
X		    for (j=1; j<y; j++)
X			if (arr[a][j][0].value != EMPTY) return(0);
X		    return(1);
X		}
X		for (j=1; j<5; j++)
X		    if (arr[a][j][0].value != EMPTY) return(0);
X		if (a==x && y==4) {
X		    for (j=1; j<z; j++)
X			if (arr[a][4][j].value != EMPTY) return(0);
X		    return(1);
X		}
X		for (j=1; j<5; j++)
X		    if (arr[a][4][j].value != EMPTY) return(0);
X		if (a==x && z==4) {
X		    for (j=y+1; j<4; j++)
X			if (arr[a][j][4].value != EMPTY) return(0);
X		    return(1);
X		}
X		if (sap[a*3+2].visited == round) return(0);
X		for (j=0; j<4; j++)
X		    if (arr[a][j][4].value != EMPTY) return(0);
X		return(sapper_check(a*3+2, x, y, z));
X	    }
X	    return(0);
X	}
X	if (c==2) {
X	    if (a==x && y==0 && z==1)  return(1);
X	    if (arr[a][0][1].value == EMPTY) {
X		if (a==x && y==0 && z==0)  return(1);
X		if (sap[a*3].visited != round && arr[a][0][0].value == EMPTY)
X		    m = sapper_check(a*3, x, y, z);
X		if (m) return(1);
X	    }
X	    n = sap[i].neighbor[0];
X	    b = (n-12)/3;
X	    c = (n-12)%3;
X	    if (x==MIDFIELD && y==b && z==c)  return(1);
X	    if (sap[n].visited != round && mid[b][c].value == EMPTY)
X		m = sapper_check(n, x, y, z);
X	    if (m) return(1);
X
X	    if (a==x && y==0 && z==3)  return(1);
X	    if (arr[a][0][3].value == EMPTY) {
X		if (a==x && y==0 && z==4)  return(1);
X		if (sap[a*3+2].visited != round && arr[a][0][4].value == EMPTY)
X		    m = sapper_check(a*3+2, x, y, z);
X		if (m) return(1);
X	    }
X	    return(0);
X	}
X	/* now c==4 */
X	if (a==x && y==0 && z==3)  return(1);
X	if (arr[a][0][3].value == EMPTY) {
X	    if (a==x && y==0 && z==2)  return(1);
X	    if (sap[a*3+1].visited != round && arr[a][0][2].value == EMPTY)
X		m = sapper_check(a*3+1, x, y, z);
X	    if (m) return(1);
X	}
X	n = sap[i].neighbor[0];
X	b = (n-12)/3;
X	c = (n-12)%3;
X	if (x==MIDFIELD && b==y && c==z)  return(1);
X	if (sap[n].visited != round && mid[b][c].value == EMPTY)
X	    m = sapper_check(n, x, y, z);
X	if (m) return(1);
X	n = (a+1)%4;
X	if (x==n && y==0 && z==0)  return(1);
X	if (sap[n*3].visited != round && arr[n][0][0].value == EMPTY)
X	    m = sapper_check(n*3, x, y, z);
X	if (m) return(1);
X
X	if (sap[a*3].visited != round || a==x) {
X	    if (a==x && z==4) {
X		for (j=1; j<y; j++)
X		    if (arr[a][j][4].value != EMPTY) return(0);
X		return(1);
X	    }
X	    for (j=1; j<5; j++)
X		if (arr[a][j][4].value != EMPTY) return(0);
X	    if (a==x && y==4) {
X		for (j=z+1; j<4; j++)
X		    if (arr[a][4][j].value != EMPTY) return(0);
X		return(1);
X	    }
X	    for (j=0; j<4; j++)
X		if (arr[a][4][j].value != EMPTY) return(0);
X	    if (a==x && z==0) {
X		for (j=y+1; j<4; j++)
X		    if (arr[a][j][0].value != EMPTY) return(0);
X		return(1);
X	    }
X	    if (sap[a*3].visited == round) return(0);
X	    for (j=0; j<4; j++)
X		if (arr[a][j][0].value != EMPTY) return(0);
X	    return(sapper_check(a*3, x, y, z));
X	}
X	return(0);
X    }
X    else {	/* starting position in the MIDFIELD */
X	j = 0;
X	while (!m && j<4) {
X	    n = sap[i].neighbor[j];
X	    if (sap[n].visited != round)
X		if (n<12) {
X		    a = n/3;
X		    c = 2*(n%3);
X		    if (x==a && y==0 && z==c) return(1);
X		    if (arr[a][0][c].value == EMPTY)
X			m = sapper_check(n, x, y, z);
X		}
X		else {
X		    b = (n-12)/3;
X		    c = (n-12)%3;
X		    if (x==MIDFIELD && y==b && z==c)  return(1);
X		    if (mid[b][c].value == EMPTY)
X			m = sapper_check(n, x, y, z);
X		}
X	    j++;
X	}
X	return(m);
X    }
X}
X
X
X
X
X
X
X
X
X/**********************************************************************
X*
X*   Synopsis
X*	int valid_move(a, b, c, x, y, z)
X*	    int a, b, c, x, y, z;
X*
X*   Return values
X*	1	for valid move;
X*	0	for invalid move;
X*
X*   Description
X*	It checks if a move as (a,b,c)=>(x,y,z) is valid according to
X*	the positions;
X*
X***********************************************************************/
X
Xint valid_move(a, b, c, x, y, z)
Xint a, b, c, x, y, z;
X{
X    int m, n, i, l;
X
X    if ((a<MIDFIELD && x<MIDFIELD) && (b==5 || y==5 ||
X		(0<b && b<4 && 0<c && c<4) || (0<y && y<4 && 0<z && z<4))) {
X	/* can move only one step far */
X	if (a != x) return(0);
X	m = abs(b-y) + abs(c-z);
X	if (m<=2 && (((b==1 || b==3) && (c==1 || c==3)) || (b==2 && c==2) ||
X		     ((y==1 || y==3) && (z==1 || z==3)) || (y==2 && z==2)))
X	    return(1);
X	if (m == 1) return(1);
X	else return(0);
X    }
X
X/* from now on, the source and the destination are both on the railway */
X    if (a==MIDFIELD && mid[b][c].value == SAPPER ||
X	a<MIDFIELD && arr[a][b][c].value == SAPPER) {
X	round++;
X	m = 0;
X	if (a<MIDFIELD && (b!=0 || (b==0 && (c==1 || c==3)))) {
X	    if (b==0)
X		if (c==1) {
X		    if (x==a && y==0 && (z==0 || z==2)) return(1);
X		    if (arr[a][0][0].value == EMPTY)
X			m = sapper_check(a*3, x, y, z);
X		    if (m) return(1);
X		    if (sap[a*3+1].visited!=round && arr[a][0][2].value==EMPTY)
X			m = sapper_check(a*3+1, x, y, z);
X		    return(m);
X		}
X		else {
X		    if (x==a && y==0 && (z==2 || z==4)) return(1);
X		    if (arr[a][0][2].value != EMPTY)
X			m = sapper_check(a*3+1, x, y, z);
X		    if (m) return(1);
X		    if (sap[a*3+2].visited!=round && arr[a][0][4].value==EMPTY)
X			m = sapper_check(a*3+2, x, y, z);
X		    return(m);
X		}
X	    else
X		if (c==0 || c==4) {
X		    if (a==x && z==c && y<b) {
X			for (i=y+1; i<b; i++)
X			    if (arr[a][i][c].value != EMPTY) break;
X			if (i==b) return(1);
X		    }
X		    else {
X			for (i=0; i<b; i++)
X			    if (arr[a][i][c].value != EMPTY) break;
X			if (i==b)
X			    m = sapper_check(a*3+(c/2), x, y, z);
X			if (m) return(1);
X		    }
X		    if (a==x || sap[a*3].visited != round ||
X				sap[a*3+2].visited != round) {
X			if (a==x && z==c && y>b) {
X			    for (i=b+1; i<y; i++)
X				if (arr[a][i][c].value != EMPTY) return(0);
X			    return(1);
X			}
X			for (i=b+1; i<5; i++)
X			    if (arr[a][i][c].value != EMPTY) return(0);
X			if (a==x && y==4)
X			    if (c==0) {
X				for (i=1; i<z; i++)
X				    if (arr[a][4][i].value != EMPTY) return(0);
X				return(1);
X			    }
X			    else {
X				for (i=z+1; i<4; i++)
X				    if (arr[a][4][i].value != EMPTY) return(0);
X				return(1);
X			    }
X			n = (c==0) ? 1 : 0;
X			for (i=0; i<4; i++)
X			    if (arr[a][4][i+n].value != EMPTY) return(0);
X			n = (c==0) ? 4 : 0;
X			if (a==x && n==z) {
X			    for (i=y+1; i<4; i++)
X				if (arr[a][i][n].value != EMPTY) return(0);
X			    return(1);
X			}
X			if (sap[a*3+n/2].visited == round) return(0);
X			for (i=0; i<4; i++)
X			    if (arr[a][i][n].value != EMPTY) return(0);
X			return(sapper_check(a*3+n/2, x, y, z));
X		    }
X		    return(0);
X		}
X		else {	    /* starting point is at the second bottom line */
X		    if (a==x && y==4 && z<c) {
X			for (i=z+1; i<c; i++)
X			    if (arr[a][4][i].value != EMPTY) break;
X			if (i==c) return(1);
X		    }
X		    else
X			for (i=0; i<c; i++)
X			    if (arr[a][4][i].value != EMPTY) break;
X		    if (i==c) {
X			if (a==x && y<4 && z==0) {
X			    for (i=y+1; i<4; i++)
X				if (arr[a][i][0].value != EMPTY) break;
X			    if (i==4) return(1);
X			}
X			else
X			    for (i=0; i<4; i++)
X				if (arr[a][i][0].value != EMPTY) break;
X			if (i==4) {
X			    m = sapper_check(a*3, x, y, z);
X			    if (m) return(1);
X			}
X		    }
X		    if (a==x || sap[a*3].visited != round ||
X				sap[a*3+2].visited != round) {
X			if (a==x && y==4 && z>c) {
X			    for (i=c+1; i<z; i++)
X				if (arr[a][4][i].value != EMPTY) return(0);
X			    return(1);
X			}
X			for (i=c+1; i<5; i++)
X			    if (arr[a][4][i].value != EMPTY) return(0);
X			if (a==x && y<4 && z==4) {
X			    for (i=y+1; i<4; i++)
X				if (arr[a][i][4].value != EMPTY) return(0);
X			    return(1);
X			}
X			if (sap[a*3+2].visited==round) return(0);
X			for (i=0; i<4; i++)
X			    if (arr[a][i][4].value != EMPTY) return(0);
X			return(sapper_check(a*3+2, x, y, z));
X		    }
X		    return(0);
X		}
X	}
X	else
X	    if (a<4)  return(sapper_check(a*3+c/2, x, y, z));
X	    else return(sapper_check(12+b*3+c, x, y, z));
X    }
X
X
X/* now the moving node is not a SAPPER */
X
X    if (a<MIDFIELD && a==x) {
X	if (b==y && (b==0 || b==4)) {
X	    if (c < z) {
X		m = c;  n = z;
X	    }
X	    else {
X		m = z;  n = c;
X	    }
X	    for (i=m+1; i<n; i++)
X		if (arr[a][b][i].value != EMPTY)  return(0);
X	    return(1);
X	}
X	else if (c==z && (c==0 || c==4)) {
X	    if (b < y) {
X		m = b;  n = y;
X	    }
X	    else {
X		m = y;  n = b;
X	    }
X	    for (i=m+1; i<n; i++)
X		if (arr[a][i][c].value != EMPTY) return(0);
X	    return(1);
X	}
X	else return(0);
X    }
X
X/* from now on the source and the destination are on different fields */
X    if (a != MIDFIELD)
X	if (c==0 || c==4) {
X	    for (i=0; i<b; i++)
X		if (arr[a][i][c].value != EMPTY) return(0);
X	}
X	else
X	    if (b!=0 || c!=2) return(0);
X    if (x != MIDFIELD)
X	if (z==0 || z==4) {
X	    for (i=0; i<y; i++)
X		if (arr[x][i][z].value != EMPTY) return(0);
X	}
X	else
X	    if (y!=0 || z!=2) return(0);
X
X    if (a<MIDFIELD && x<MIDFIELD) {
X	if ((x+1)%4 == a)
X	    if (z==4 && c==0)  return(1);
X	    else return(0);
X	else if ((a+1)%4 == x)
X	    if (z==0 && c==4) return(1);
X	    else return(0);
X	if (!((c==0 && z==4) || (c==4 && z==0) || (c==2 && z==2)))
X	    return(0);
X    }
X
X/* now the move has to go across the MIDFIELD */
X    if ((a<MIDFIELD && a%2==0) || (x<MIDFIELD && x%2==0) ||
X	(a==MIDFIELD && x==MIDFIELD && c==z)) {
X	if (a != MIDFIELD) {
X	    if (a==F0) {
X		l = c/2;
X		n = 2;
X		m = (x==MIDFIELD) ? (y+1) : 0;
X	    }
X	    else {
X		l = (4-c)/2;
X		m = 0;
X		n = (x==MIDFIELD) ? (y-1) : 2;
X	    }
X	    if (x==MIDFIELD && l!=z) return(0);
X	}
X	else
X	    if (x != MIDFIELD) {
X		if (x==F0) {
X		    l = z/2;
X		    m = b+1;
X		    n = 2;
X		}
X		else {
X		    l = (4-z)/2;
X		    m = 0;
X		    n = b-1;
X		}
X		if (l != c)  return(0);
X	    }
X	    else {
X		l = z;
X		if (b<y) {
X		    m = b+1; n = y-1;
X		}
X		else {
X		    m = y+1; n = b-1;
X		}
X	    }
X
X	for (i=m; i<=n; i++)
X	    if (mid[i][l].value != EMPTY) return(0);
X	return(1);
X    }
X
X    if ((a<MIDFIELD && a%2!=0) || (x<MIDFIELD && x%2!=0) ||
X	(a==MIDFIELD && x==MIDFIELD && b==y)) {
X	if (a != MIDFIELD) {
X	    if (a==F1) {
X		l = (4-c)/2;
X		n = 2;
X		m = (x==MIDFIELD) ? (z+1) : 0;
X	    }
X	    else {
X		l = c/2;
X		m = 0;
X		n = (x==MIDFIELD) ? (z-1) : 2;
X	    }
X	    if (x == MIDFIELD && l != y) return(0);
X	}
X	else
X	    if (x != MIDFIELD) {
X		if (x==F1) {
X		    l = (4-z)/2;
X		    m = c+1;
X		    n = 2;
X		}
X		else {
X		    l = z/2;
X		    m = 0;
X		    n = c-1;
X		}
X		if (l != b)  return(0);
X	    }
X	    else {
X		l = b;
X		if (c<z) {
X		    m = c+1; n = z-1;
X		}
X		else {
X		    m = z+1; n = c-1;
X		}
X	    }
X
X
X	for (i=m; i<=n; i++)
X	    if (mid[l][i].value != EMPTY) return(0);
X	return(1);
X    }
X
X    return(0);
X}
X
X
X/*************************************************************************
X*
X*   Synopsis
X*	initial_sapper()
X*
X*   Description
X*	initializes the array 'sap' of the sapper move checking path.
X*
X**************************************************************************/
X
Xinitial_sapper()
X{
X    int i;
X
X    round = 0;
X
X    for (i=0; i<21; i++)
X	sap[i].visited = 0;
X
X    sap[0].neighbor[0] = 18;
X    sap[1].neighbor[0] = 19;
X    sap[2].neighbor[0] = 20;
X    sap[3].neighbor[0] = 20;
X    sap[4].neighbor[0] = 17;
X    sap[5].neighbor[0] = 14;
X    sap[6].neighbor[0] = 14;
X    sap[7].neighbor[0] = 13;
X    sap[8].neighbor[0] = 12;
X    sap[9].neighbor[0] = 12;
X    sap[10].neighbor[0] = 15;
X    sap[11].neighbor[0] = 18;
X
X    sap[12].neighbor[0] = 9;
X    sap[12].neighbor[1] = 8;
X    sap[12].neighbor[2] = 13;
X    sap[12].neighbor[3] = 15;
X    sap[13].neighbor[0] = 12;
X    sap[13].neighbor[1] = 7;
X    sap[13].neighbor[2] = 14;
X    sap[13].neighbor[3] = 16;
X    sap[14].neighbor[0] = 13;
X    sap[14].neighbor[1] = 6;
X    sap[14].neighbor[2] = 5;
X    sap[14].neighbor[3] = 17;
X
X    sap[15].neighbor[0] = 10;
X    sap[15].neighbor[1] = 12;
X    sap[15].neighbor[2] = 16;
X    sap[15].neighbor[3] = 18;
X    sap[16].neighbor[0] = 15;
X    sap[16].neighbor[1] = 13;
X    sap[16].neighbor[2] = 17;
X    sap[16].neighbor[3] = 19;
X    sap[17].neighbor[0] = 16;
X    sap[17].neighbor[1] = 14;
X    sap[17].neighbor[2] = 4;
X    sap[17].neighbor[3] = 20;
X
X    sap[18].neighbor[0] = 11;
X    sap[18].neighbor[1] = 15;
X    sap[18].neighbor[2] = 19;
X    sap[18].neighbor[3] = 0;
X    sap[19].neighbor[0] = 18;
X    sap[19].neighbor[1] = 16;
X    sap[19].neighbor[2] = 20;
X    sap[19].neighbor[3] = 1;
X    sap[20].neighbor[0] = 19;
X    sap[20].neighbor[1] = 17;
X    sap[20].neighbor[2] = 3;
X    sap[20].neighbor[3] = 2;
X}
X
X
X
END_OF_FILE
if test 21847 -ne `wc -c <'war.c'`; then
    echo shar: \"'war.c'\" unpacked with wrong size!
fi
# end of 'war.c'
fi
if test -f 'war.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'war.h'\"
else
echo shar: Extracting \"'war.h'\" \(1767 characters\)
sed "s/^X//" >'war.h' <<'END_OF_FILE'
X#define DEFAULT_BOARD_BG "gray"
X#define DEFAULT_BOARD_FG "black"
X#define PLAYER0_COLOR "red"
X#define PLAYER1_COLOR "black"
X#define PLAYER2_COLOR "blue"
X#define PLAYER3_COLOR "purple"
X
X#define DIMENSION 870
X
X#define P1	35
X#define P2	285
X#define P3	335
X#define P4	535
X#define P5	585
X#define P6	835
X
X#define TALK_WIDTH 250
X#define TALK_HEIGHT 60
X#define TALK_Y	135		/* the y-coordinate for the upper talk
X				 * boxes. the lower talk box's is
X				 * TALK_Y+TALK_HEIGHT+30.
X				 */
X#define TALK_L_X P1
X#define TALK_R_X P5
X#define TALK_X_INC 9		/* char gap in x-direction of talk
X				 * string.
X				 */
X#define TALK_Y_INC 20
X#define TALK0_X  P1+5		/* talk string's x-coordinate for
X				 * player 0
X				 */
X#define TALK0_Y  TALK_Y+15
X#define TALK1_X  P5+5
X#define TALK1_Y  TALK_Y+15
X#define TALK2_X  P1+5
X#define TALK2_Y  TALK_Y+105
X#define TALK3_X  P5+5
X#define TALK3_Y  TALK_Y+105
X
X#define RIP_Y	585
X#define RIP_DIMENSION 250
X
X#define BUTTON_WIDTH 100
X#define BUTTON_HEIGHT 25
X#define BUTTON_X  685
X#define NEW_Y	610
X#define BUTTON_DIS  40
X
X#define MSG_BOX_X P5
X#define MSG_BOX_Y P1
X#define MSG_WIDTH 250
X#define MSG_HEIGHT 50
X#define MSG_X	592
X#define MSG_Y	53
X
X#define MAX_MSG 27
X
X#define SIGN_DIMENSION 64
X
X#define EMPTY -1
X#define COLOURS 0
X#define SAPPER 1
X#define F_LIEUTENANT 2
X#define CAPTAIN 3
X#define MAJOR 4
X#define COLONEL 5
X#define BRIGADIER 6
X#define M_GENERAL 7
X#define GENERAL 8
X#define MARSHAL 9
X#define MINE 10
X#define BOMB 11
X
X#define F0 0
X#define F1 1
X#define F2 2
X#define F3 3
X#define MIDFIELD 4
X#define RIP 5
X#define NEW 6
X#define READY 7
X#define REDEPLOY 8
X#define PEACE 9
X#define SURRENDER 10
X#define QUIT 11
X#define OTHERPLACE 12
X
X
Xtypedef struct {
X	int id;
X	int value;
X} Arr;
X
X
Xtypedef struct {
X	int neighbor[4];
X	int visited;
X} Sapper_path;
X
X
X
END_OF_FILE
if test 1767 -ne `wc -c <'war.h'`; then
    echo shar: \"'war.h'\" unpacked with wrong size!
fi
# end of 'war.h'
fi
if test -f 'x4war.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'x4war.man'\"
else
echo shar: Extracting \"'x4war.man'\" \(5622 characters\)
sed "s/^X//" >'x4war.man' <<'END_OF_FILE'
X.TH X4WAR 6 "3-Mar-92"
X.SH NAME
Xx4war \- An X version of the Chinese four-state-war game.
X.SH SYNOPSIS
X.B x4war
X\ [options]
X.br
X.SH DESCRIPTION
X.I x4war
Xis a game like the Chinese board game, four-state-war. It involves four players,
Xtwo players at the opposite position of the board play an ally and are against the
Xother two. It runs under X Window environment. At First, players deploy their
Xarmy on their own fields, then a war can be started after all have deployed
Xtheir army correctly. During the war, each moves one of his/her node in turn.
XThe goal of the war is to capture the COLOURS of the opponents.
X.LP
XBy default, players are named 'PLAYER 0' through 'PLAYER 3', their positions on
Xthe board are sequenced counter-clockwise, PLAYER 0 and PLAYER 2 forms an ally
Xand are against the ally of PLAYER 1 and PLAYER 3.
X.PP
X.SH OPTIONS
X.TP
X.BI \-p "i string"
XSpecifies player
X.I i
X\'s name.
X.I i
Xis between 0 - 3, default to "PLAYER \fIi".
X.TP
X.BI \-c "i string"
XSpecifies the color of player
X.I i
X\'s node.
X.I i
Xis between 0 - 3.
X.TP
X.BI \-d "i string"
XSpecifies the display of player
X.I i.
X.TP
X.BI \-debug
XA default deploy.
X.TP
X.BI \-usage
XGives the command options.
X.PP
X.SH USAGE
XPress a button on your own node to move it, release the button at a position
Xand the node will be placed there if it constitutes a valid move. When a war
Xhas started, the players take turns to make a move. You can move your node if
Xan arrow is shown in the upper-left corner of the board. A broken arrow there
Xmeans that it's not your turn to move.
X.LP
XSome rules during a war session are set by the program:
X.RS
X.IP
XThe COLOURS and MINEs can not be moved; a node deployed in the 'base'(the two
Xnon-rectangular positions at the button line of the board) cannot be moved.
X.IP
XA node moved into the base will be killed.
X.IP
XA SAPPER can safely remove a MINE.
X.IP
XA BOMB will go with any node including a MINE.
X.IP
XAny nodes other than a SAPPER or a BOMB meet a MINE will be killed and the
XMINE is not destroyed.
X.IP
XIf a player's MARSHAL is killed, his/her COLOURS will be shown faced up at
Xother player's board.
X.IP
XA node in 'safe depot'(circled positions on the board) cannot be attacked.
X.IP
XA node cannot move over other nodes.
X.IP
XA node can go only one step if not moving on the railway, it can move several
Xsteps on the railway.
X.IP
XExcept for a SAPPER, the direction of a move cannot be changed. (the direction
Xis a straight line, or from your left line to the right line of the field on
Xyour left, or from your right line to the left line of the field on your right)
X.RE
X.LP
XOther rules can be set by players.
X.LP
XThe message box at the upper-right corner of the board shows each move and the
Xfighting result. For a coordinates
X.I (w, x, y),
Xit is defined from the view of the player 0's board as follows:
X.RS
X.TP 3
X.I w
Xspecifies which field. Player
X.I i
X\'s field is numbered
X.I i (i in 0-3),
Xthe middle field is numbered 4.
X.LP
X.I x
Xand
X.I y
Xspecify rows and columns in each field,
Xrespectively, which are in 0-6 and 0-5 for rows and columns in players fields
Xand 0-2 for both rows and columns in the middle field.
X.RE
X.LP
XThe four talk boxes can be used for talking purposes. key input is shown in the
Xcorresponding box at all players screen.
X.LP
XThe functions of buttons at the bottom-right of the board are as follows:
X.TP
X.B NEW GAME
XStarts a new game after one game of war is over, then players can deploy their
Xnodes to their field for the new war.
X.IP
XSome deploy restrictions:
X.RS
X.IP .
Xthe COLOURS can be deployed only in one of the 'base's;
X.IP .
Xa MINE can be deployed only at the bottom two lines;
X.IP .
Xno node can be deployed in the 'safe depot'.
X.RE
X.IP
XOther restrictions can be set by players. (such as: a BOMB cannot be at the
Xfirst line)
X.TP
X.B START WAR
XAfter you have deployed your army, you press this button to get ready for the
Xwar. After all four players have pressed the button, the war gets started and
Xthe one in his/her turn can move a node.
X.TP
X.B REDEPLOY
XRe-deploy your army after you pressed
X.B "START WAR"
Xbutton and before all players have pressed that button. After re-deploy, you
Xshould press
X.B "START WAR"
Xagain.
X.TP
X.B PEACE
XRequesting for peace during the war. Then a dialog box is shown on the other
Xplayer's screen, the others have to answer the request. If one answered NO,
Xthe war will continue.
X.TP
X.B SURRENDER
XIf you surrender, all your nodes are moved and all nodes on your board will be
Xshown faced up so that you can watch the rest of the war. (seems not a bad
Xchoice to enjoy other players battle tactics at the lose of your dignity)
X.TP
X.B QUIT   
XIf you have been defeated, your quit will not affect the battle, otherwise you
Xcan only use it in your turn, and it will cause every one to quit.
X.LP
XA brief example session is like:
X.RS
X.IP 1.
Xget four people and four displays.
X.IP 2.
Xrun the program, set the board to different displays.
X.IP 3.
Xeach deploys his/her army correctly and then presses START WAR.
X.IP 4.
Xafter all have pressed START WAR, the war began and the first one can move.
X.IP 5.
Xfight a decisive battle, have fun!
X.RE
X.LP
XOne way to play a two persons game.
X.RS
X.IP 1.
Xstart the program with '-debug' option, this will cause a default deploy to
Xappear on four boards.
X.IP 2.
Xre-deploy the army in your field.
X.IP 3.
Xpress START WAR on all four boards to start a war.
X.IP 4.
Xsurrender the two armies you don't play.
X.IP 5.
Xnow have a two players game.
X.RE
X.PP
X.SH SEE ALSO
XA Chinese guy or anybody who can read Chinese characters and knows the
Xconventional rules about the war game.
X.PP
X.SH AUTHOR
XXiaobing Chen, xiaobing@cs.sfu.ca  Feb. 25, 1992
X
X
END_OF_FILE
if test 5622 -ne `wc -c <'x4war.man'`; then
    echo shar: \"'x4war.man'\" unpacked with wrong size!
fi
# end of 'x4war.man'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
