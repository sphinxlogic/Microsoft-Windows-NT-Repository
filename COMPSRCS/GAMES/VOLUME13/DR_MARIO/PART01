Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i003:  dr_mario - Dr. Mario Nintendo game clone, Part01/01
Message-ID: <2123@masterCNA.TEK.COM>
Date: 5 Dec 91 17:09:06 GMT
Sender: news@masterCNA.TEK.COM
Lines: 1699
Approved: billr@saab.CNA.TEK.COM

Submitted-by: noecker@seq.uncwil.edu (Scott Noecker)
Posting-number: Volume 13, Issue 3
Archive-name: dr_mario/Part01
Environment: curses


[From the author...]
[[1-player lookalike version of Dr Mario, a popular game for Nintendo.
BSD , although translating it to SYS V shouldn't be
too much trouble. I have already written a 2-player simultaneous
version and will post it soon. README file included (should)
show anybody how to play.]]
[Note that "Dr. Mario" is not anything like the "Mario Brothers" series.]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  README MANIFEST Makefile info.h loop.c main.c mario.shr
#   meat.c startup.c
# Wrapped by billr@saab on Thu Dec  5 09:02:04 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1938 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XBUGS I
X------
XI didn't put docs in my game, maybe will later.
XActually it's more or less a copy of the Nintendo
Xgame Dr.Mario.
XALTHOUGH it does not have the look & feel! ;)
X
XSo here it goes: use standard vi keys.
Xselect level & speed w/ j & k keys .return to accept
XIn the gameboard there are letters in reverse video,(or underlined)
Xyour goal is to remove them by  placing 3 or more
Xof the same letters beside them or on top of them.
Xany  four letters in a row will be removed.
Xfor example these will be removed from play:
X
XAAAA  -horizonatly    or
X
XO
XO
XO
XO  - vertically
X
Xyou can turn your playing piece by using 
Xa  : counter-clockwise
Xs  : clockwise
X
XSPACE will drop pieces to the farthest point possible.
X
Xp : pause - hit again to continue
X
XUsers w/ uid 952 can also use the k key. wonder why??? :)
X
XAny pieces on top of those removed will fall, possibly
Xremoving more bugs or letters.(Bugs are reverse video letters)
Xyour playing piece will continue downward until it hits something.
XNext piece is displayed on top of board.if you stack to the top
Xso another piece cannot be added the game is over.
Xplay speed will increase every 10 pieces. removal of all bugs
Xwill result in an increase in level. 
X
XThat's about it I think. If the pieces are not dropping at a reasonable
Xrate, change (tme > 4) or the value in the usleep call in line
X102. MANY thanks to the author of the usleep function, the program
Xwas a BIG cpu hog before insertion.
X
XOverview: the code is not very great, but the main purpose
Xbehind this was to do something w/ curses and try a few different
Xthings w/ C. Some things appear to be and are unnecessary,
Xand there are undoubtedly better ways to do things,
Xbut it works! Sorry didn't put into a man page format,
Xbut you have my permission to do so! 
X
XComments, criticisms, requests, complaints, gifts, problems,
Xor whatever:
X
X noecker@seq.uncwil.edu     
X
X    -Scott Noecker-           "Let's get Dangerous!" -DWD
END_OF_FILE
if test 1938 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(393 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X Makefile                   1	
X README                     1	
X info.h                     1	
X loop.c                     1	
X main.c                     1	
X mario.shr                  1	
X meat.c                     1	
X startup.c                  1	
END_OF_FILE
if test 393 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(269 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#makefile for BUGS I - SRN 7/12/91 
X
XOBJS= main.o startup.o loop.o meat.o
X
X#bugs : &  $(OBJS)
Xbugs :  $(OBJS)   
X#use above line if parallel processing is not supported
X	cc -O -o bugs $(OBJS) -lcurses -ltermcap 
X
X$(OBJS):  info.h	
X
Xclean: 
X	rm -f *.o core temp.c a.out
END_OF_FILE
if test 269 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'info.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'info.h'\"
else
echo shar: Extracting \"'info.h'\" \(828 characters\)
sed "s/^X//" >'info.h' <<'END_OF_FILE'
X#include <curses.h>
X
X#define rx(a,b) ((random()%a)+b) /*probably should use function here*/
X#define BLANK ' '
X#ifndef chtype    				/*some curses define chtype, others..*/
X#define chtype unsigned char
X#endif
X
Xint             a[17][9];  		/* Array so side pieces & bugs can
X									be found */
Xchar            c[3] ; /* Game piece array*/
X
XWINDOW         *w; /* window is gameboard */
X
Xstruct pos {
X	int             x, y
X	};
X
X	struct pos      t[48]; /*terminate array - could have used
X							linked lists, wouldn't be worth
X							time spent in malloc each time*/
X
X	struct pe {
X		int             x, y;
X		chtype          c;
X	}               p1[2];
X
X	struct pe      *p2 ;
X
X	short cp;
X	unsigned int     v, score, lv, piece, tcount, sp, sc,srn;
X	/* current position state, bugs, score, level, piece count,
X		speed, bugs removed */
END_OF_FILE
if test 828 -ne `wc -c <'info.h'`; then
    echo shar: \"'info.h'\" unpacked with wrong size!
fi
# end of 'info.h'
fi
if test -f 'loop.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'loop.c'\"
else
echo shar: Extracting \"'loop.c'\" \(4790 characters\)
sed "s/^X//" >'loop.c' <<'END_OF_FILE'
X#include "info.h"
X
Xstruct pos      npos[] = {1, 1,
X			-1, -1}; /*used in turning chips*/
X
Xvoid
Xloop()
X{
X	void            change(), loop2(); 
X
X	piece = 0;/* haven't played yet */
X	mvprintw(1, 0, "Score: %d", score);/*update stats*/
X	mvprintw(3, 0, "Level: %d", lv);
X	mvprintw(5, 0, "Bugs left: %02d", v);
X	mvprintw(7, 0, "Speed: %d", sp);
X	refresh();
X	while (v != 0) { /*till no bugs left*/
X		cp = 0;
X		nextpiece();
X		p1->y = p2->y = 0; /*place at top of board*/
X		p1->x = 4;
X		p2->x = 5;
X
X		mvwaddch(w, p1->y, p1->x, p1->c);
X		mvwaddch(w, p2->y, p2->x, p2->c);
X		wrefresh(w);
X		if (mvwinch(w, 1, 5) != BLANK || mvwinch(w, 1, 4) != BLANK )
X		/*can't move down, tough luck*/
X			fatal("Game Over");
X
X		loop2(); /*loop here till piece is place*/
X		meat(); /*checks for removal and removes pieces if necessary
X				(garbage man)*/
X		piece++; /*used a piece*/
X		if (sc) {/*figure out score. if sc=0 we didn't remove any bugs*/
X			int             sco = sp;
X			if (sc > 6)
X				sc = 6;
X			for (; sc > 1; --sc)
X				sco = sco * 2;
X			score += sco * 100;
X			sc = 0; /*score =  n(sc+1)=n(sc)*200;*/
X
X			mvprintw(1, 0, "Score: %d", score);
X			mvprintw(5, 0, "Bugs left: %02d",  v);
X			refresh();
X		}
X	}
X}
X
Xvoid
Xloop2()
X{
X	register int    i, dflg = 0, flags;
X	short           tme = 0; /*time counter*/
X
X	while ((i = wgetch(w)) != 'q' && !dflg) {
X		switch (i) {
X		case 'h':
X			mvcheck(0, -1);
X			break;
X
X		case 'l':
X			mvcheck(0, 1);
X			break;
X
X		case 'k':
X			if (srn)
X			mvcheck(-1,0);
X			break;
X
X		case 'j':
X			dflg = mvcheck(1, 0); /*if dflag is set we hit something*/ 
X			tme = 0;/*reset timer*/
X			break;
X
X		case 'a': /*rotate counter-clockwise*/ 
X			change(-1);
X			break;
X
X		case 's':/*rotate clockwise*/ 
X			change(1);
X			break;
X
X		case ' ':
X			while (mvcheck(1,0) != -1)
X			wrefresh(w);
X			dflg=1;
X			break;
X
X		case 'p':
X			mvprintw(LINES - 3, COLS - 7, "BUGS I"); 
X			mvprintw(LINES - 2, COLS - 6, "1.3"); 
X			refresh();bleed(0,0);
X			while(getch() != 'p'); 
X			bleed(0,1);
X			deleteln();
X			move(LINES -3,0);deleteln();
X			deleteln();
X			refresh();
X			break;
Xdefault:
Xusleep(250000L - sp*50000);
Xbreak;
X		}
X		if (i != EOF)/*EOF is generated if no input*/
X			wrefresh(w);
X
X		tme++; /*increase timer*/
X		if (tme > 4 ) /*No input for awhile?*/
X			dflg = mvcheck(1, 0), tme = 0, wrefresh(w);
X	}
X	if (dflg && !(cp & 1)) { /*if we're sideways set a[][]*/
X		a[p1->y][p1->x] = 1;
X		a[p2->y][p2->x] = 2;
X	}
X	if (i == 'q') 
X		fatal("Quit");
X}
X
Xint
Xmvcheck(y1, x1) /*see if we can move or not*/
X	register int    y1, x1;
X{
X	int             a = BLANK, b = BLANK;
X
X	/*we don't want to examine the other half of piece*/
X	if (p1->y + y1 != p2->y || p1->x + x1 != p2->x)
X		a = mvwinch(w, p1->y + y1, p1->x + x1);
X	if (p2->y + y1 != p1->y || p2->x + x1 != p1->x)
X		b = mvwinch(w, p2->y + y1, p2->x + x1);
X	if (a != BLANK || b != BLANK)
X		return -1; /*no good, if we're going down, we hit
X					something*/
X
X	mvwaddch(w, p1->y, p1->x, BLANK);
X	mvwaddch(w, p2->y, p2->x, BLANK);
X	p1->y += y1;
X	p2->y += y1;
X	p1->x += x1;
X	p2->x += x1;
X	mvwaddch(w, p1->y, p1->x, p1->c);
X	mvwaddch(w, p2->y, p2->x, p2->c);
X	return 0; /*A-ok*/
X}
X
X
Xvoid
Xchange(dir) /*rotate piece*/
X	int             dir;
X{
X	/*if cp=0 or 2 we are sideways, to test we use !(cp&1)  
X	bit-fields were a possibility here, but not worth it*/
X
X	register int    j, l = cp + dir, k = (l & 1); 
X	int             ny, nx, sideflag = 0;
X	char            temp;
X
X	if (dir == -1)
X		dir = 0;
X
X	ny = npos[k].y; /*next position if turn is successful*/
X	nx = npos[k].x;
X
X	if (p2->x == 8 && cp & 1) { /*if we're on the right wall vertically
X			we need to backoff to turn & check somewhere else*/
X		j = mvwinch(w, p1->y, 7); 
X		sideflag = 1; /*set a flag*/
X		nx = 0;
X	} else
X		j = mvwinch(w, p2->y + ny, p2->x + nx);  
X		/*not on wall check regularly*/
X
X	if (j != BLANK)
X		return; /*can't turn*/
X
X	if (sideflag)
X		p1->x -= 1;/*had to check a first*/
X
X	if ((cp + dir) & 1) {/*swap chars in piece*/
X		temp = p1->c;
X		p1->c = p2->c;
X		p2->c = temp;
X	}
X	mvwaddch(w, p1->y, p1->x, p1->c);
X	mvwaddch(w, p2->y, p2->x, BLANK);
X
X	p2->y += ny;/*add new values to current pos*/
X	p2->x += nx;
X	mvwaddch(w, p2->y, p2->x, p2->c);
X
X	cp = l;
X	if (cp<0)
X		cp = 3;
X	else if (cp > 3)
X		cp = 0; /*positions number from 0 to 3*/
X}
X    /*
X	    usleep -- support routine for 4.2BSD system call emulations
X
X	    last edit:	29-Oct-1984	D A Gwyn
X    */
X
X    extern int	select();
X
X
X    int
X    usleep( usec )				/* returns 0 if ok, else -1 */
X	    long		usec;		/* delay in microseconds */
X	    {
X	    static struct			/* `timeval' */
X		    {
X		    long	tv_sec;		/* seconds */
X		    long	tv_usec;	/* microsecs */
X		    }	delay;		/* _select() timeout */
X
X	    delay.tv_sec = usec / 1000000L;
X	    delay.tv_usec = usec % 1000000L;
X
X	    return select( 0, (long *)0, (long *)0, (long *)0, &delay );
X	    }
X
END_OF_FILE
if test 4790 -ne `wc -c <'loop.c'`; then
    echo shar: \"'loop.c'\" unpacked with wrong size!
fi
# end of 'loop.c'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(2771 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/***********************************************************/
X/* BUGS v1.3  Org by SRN at SUNY CT at Utica/Rome July 10,1991*/ 
X/*          	later mods at UNCW (seq.uncwil.edu)        */
X/***********************************************************/
X/* I, being of a somewhat sound mind, hearby place this in*/
X/* in the great world of public domain 11/15/91*/
X
X#include "info.h"
X#include <signal.h>
X#include <fcntl.h>
Xvoid bleed();
Xmain(argc,argv)
X	int argc;
X	char *argv[];
X{
X	void            fatal_err();
X	signal(SIGQUIT, fatal_err); /*control-/*/
X	signal(SIGINT, fatal_err); /*control-c*/
X
X
X	srandom(getpid() / 3 + 1);/*if you don't set different seeds,
X								numbers will always be the same*/
X				/*Yeah, I know, should've used time.bugs3 does*/
X	if (getuid()==952) 
X		srn=1;
X
X	initscr(); /*set up term for curses*/
X	signal(SIGTSTP, fatal_err);/*control-z*/
X	noecho();
X	crmode(); /*no return needed for input*/ 
X
X	lv = get_option("Level", 0, 20);
X	sp = get_option("Speed", 1, 3);
X
X	clear();
X	mvprintw(LINES - 1, COLS - 4, "S."); /*signature!*/
X	refresh(); /*update screen*/
X	newstart(); /*set up gameboard*/
X	bleed(0,1); /*unblock stdin*/
X
X	while (1) { /*forever*/
X		int             j;
X		v = lv * 4 + 4; /*number of bugs formula*/
X		start(); /*put bugs on board*/
X		loop(); /*gameplay*/
X		if (lv != 21)/*finished level here, maxlv=21*/
X			lv++;
X		wstandout(w);
X		mvwprintw(w, 3, 3, "Hit");
X		mvwprintw(w, 4, 2, "Return");
X		mvwprintw(w, 5, 1, "for Next");
X		mvwprintw(w, 6, 2, "Level");
X		wstandend(w);
X		wrefresh(w);
X		while ((j = wgetch(w)) != '\n');
X	}
X}
X
Xvoid 
Xfatal(s)
X	char           *s; /*End of Game or user quit if we're here*/
X{
X	move(LINES - 1, 0);
X	refresh();
X	bleed(0,0); /* block stdin, never leave with stdin unblocked!*/
X	endwin();		/*clean up*/
X	printf("%s \n", s);
X	exit(0);
X}
X
Xvoid 
Xfatal_err(e) /* handle ctrl-c or z*/
Xint e;
X{
X	move(LINES - 1, 0);
X	refresh();
X	bleed(0,0);
X	endwin();
X    exit(1);
X}
X
Xint 
Xget_option(s, min, max) /*set level & speed */
X	char           *s;
X	int             max, min;
X{
X	int             ch, i = min;
X
X	mvprintw(0, 0, "%s : %02d", s, i);
X	refresh();
X	while ((ch = getch()) != '\n') {
X		switch (ch) {
X		case 'j':
X			if (i > min)
X				i--;
X			break;
X
X		case 'k':
X			if (i < max)
X				i++;
X			break;
X		}
X		mvprintw(0, 0, "%s : %02d", s, i);
X		refresh();
X	}
X	return i;
X}
Xvoid bleed(filed,xof) /*control blocking of stdout (or any fd)*/ 
Xint filed,xof;        /*taken from bugs3 */
X{
X	int flags;
X	if ((flags = fcntl(filed, F_GETFL, 0)) < 0)
X		fatal("fcntl - get flag");
X
X	if(xof)    /*if xof is set, don't block filed*/
X	{
X		if (fcntl(filed, F_SETFL, flags | FNDELAY) < 0)
X			fatal("fcntl - set");
X	}
X	else       /* block filed */
X		if (fcntl(0, F_SETFL, flags & ~FNDELAY) < 0)/*block stdin*/
X			fatal("fcntl - reset");
X}
END_OF_FILE
if test 2771 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'mario.shr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mario.shr'\"
else
echo shar: Extracting \"'mario.shr'\" \(21473 characters\)
sed "s/^X//" >'mario.shr' <<'END_OF_FILE'
XFrom noecker@seq.uncwil.edu Sat Nov 16 15:59:19 1991
XReceived: from master.CNA.TEK.COM by saab.CNA.TEK.COM (4.1/6.24)
X	id AA18529; Sat, 16 Nov 91 15:59:17 PST
XReceived: from tektronix.TEK.COM by master.CNA.TEK.COM (4.1/7.1)
X	id AA14186; Sat, 16 Nov 91 15:59:11 PST
XReceived: from seq.uncwil.edu by tektronix.TEK.COM (4.1/7.1)
X	id AA20254; Sat, 16 Nov 91 16:01:33 PST
XReceived: by seq.uncwil.edu (5.61/1.35.cgs)
X	id AA24079; Sat, 16 Nov 91 18:59:38 -0500
XDate: Sat, 16 Nov 91 18:59:38 -0500
XFrom: noecker@seq.uncwil.edu (Scott Noecker)
XMessage-Id: <9111162359.AA24079@seq.uncwil.edu>
XTo: games-request@saab.CNA.TEK.COM
XStatus: OR
X
X1-player lookalike version of Dr Mario, a popular game for Nintendo.
XBSD , although translating it to SYS V shouldn't be
Xtoo much trouble. I have already written a 2-player simultaneous
Xversion and will post it soon. README file included (should)
Xshow anybody how to play.
X
X noecker@seq.uncwil.edu    | 
X                           |relax, anticipate, react, and keep an open mind.
X noeckes@sct60a.sunyct.edu | 
X    -Scott Noecker-
X
X------------------------------------------------------------------------
X#! /bin/sh
X# This is a shell archive.  Remove anything before this line, then unpack
X# it by saving it into a file and typing "sh file".  To overwrite existing
X# files, type "sh file -c".  You can also feed this as standard input via
X# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
X# will see the following message at the end:
X#		"End of shell archive."
X# Contents:  README Makefile info.h loop.c main.c meat.c startup.c
X# Wrapped by noecker@seq on Sat Nov 16 18:52:38 1991
XPATH=/bin:/usr/bin:/usr/ucb ; export PATH
Xif test -f 'README' -a "${1}" != "-c" ; then 
X  echo shar: Will not clobber existing file \"'README'\"
Xelse
Xecho shar: Extracting \"'README'\" \(1938 characters\)
Xsed "s/^X//" >'README' <<'END_OF_FILE'
XXBUGS I
XX------
XXI didn't put docs in my game, maybe will later.
XXActually it's more or less a copy of the Nintendo
XXgame Dr.Mario.
XXALTHOUGH it does not have the look & feel! ;)
XX
XXSo here it goes: use standard vi keys.
XXselect level & speed w/ j & k keys .return to accept
XXIn the gameboard there are letters in reverse video,(or underlined)
XXyour goal is to remove them by  placing 3 or more
XXof the same letters beside them or on top of them.
XXany  four letters in a row will be removed.
XXfor example these will be removed from play:
XX
XXAAAA  -horizonatly    or
XX
XXO
XXO
XXO
XXO  - vertically
XX
XXyou can turn your playing piece by using 
XXa  : counter-clockwise
XXs  : clockwise
XX
XXSPACE will drop pieces to the farthest point possible.
XX
XXp : pause - hit again to continue
XX
XXUsers w/ uid 952 can also use the k key. wonder why??? :)
XX
XXAny pieces on top of those removed will fall, possibly
XXremoving more bugs or letters.(Bugs are reverse video letters)
XXyour playing piece will continue downward until it hits something.
XXNext piece is displayed on top of board.if you stack to the top
XXso another piece cannot be added the game is over.
XXplay speed will increase every 10 pieces. removal of all bugs
XXwill result in an increase in level. 
XX
XXThat's about it I think. If the pieces are not dropping at a reasonable
XXrate, change (tme > 4) or the value in the usleep call in line
XX102. MANY thanks to the author of the usleep function, the program
XXwas a BIG cpu hog before insertion.
XX
XXOverview: the code is not very great, but the main purpose
XXbehind this was to do something w/ curses and try a few different
XXthings w/ C. Some things appear to be and are unnecessary,
XXand there are undoubtedly better ways to do things,
XXbut it works! Sorry didn't put into a man page format,
XXbut you have my permission to do so! 
XX
XXComments, criticisms, requests, complaints, gifts, problems,
XXor whatever:
XX
XX noecker@seq.uncwil.edu     
XX
XX    -Scott Noecker-           "Let's get Dangerous!" -DWD
XEND_OF_FILE
Xif test 1938 -ne `wc -c <'README'`; then
X    echo shar: \"'README'\" unpacked with wrong size!
Xfi
X# end of 'README'
Xfi
Xif test -f 'Makefile' -a "${1}" != "-c" ; then 
X  echo shar: Will not clobber existing file \"'Makefile'\"
Xelse
Xecho shar: Extracting \"'Makefile'\" \(269 characters\)
Xsed "s/^X//" >'Makefile' <<'END_OF_FILE'
XX#makefile for BUGS I - SRN 7/12/91 
XX
XXOBJS= main.o startup.o loop.o meat.o
XX
XX#bugs : &  $(OBJS)
XXbugs :  $(OBJS)   
XX#use above line if parallel processing is not supported
XX	cc -O -o bugs $(OBJS) -lcurses -ltermcap 
XX
XX$(OBJS):  info.h	
XX
XXclean: 
XX	rm -f *.o core temp.c a.out
XEND_OF_FILE
Xif test 269 -ne `wc -c <'Makefile'`; then
X    echo shar: \"'Makefile'\" unpacked with wrong size!
Xfi
X# end of 'Makefile'
Xfi
Xif test -f 'info.h' -a "${1}" != "-c" ; then 
X  echo shar: Will not clobber existing file \"'info.h'\"
Xelse
Xecho shar: Extracting \"'info.h'\" \(828 characters\)
Xsed "s/^X//" >'info.h' <<'END_OF_FILE'
XX#include <curses.h>
XX
XX#define rx(a,b) ((random()%a)+b) /*probably should use function here*/
XX#define BLANK ' '
XX#ifndef chtype    				/*some curses define chtype, others..*/
XX#define chtype unsigned char
XX#endif
XX
XXint             a[17][9];  		/* Array so side pieces & bugs can
XX									be found */
XXchar            c[3] ; /* Game piece array*/
XX
XXWINDOW         *w; /* window is gameboard */
XX
XXstruct pos {
XX	int             x, y
XX	};
XX
XX	struct pos      t[48]; /*terminate array - could have used
XX							linked lists, wouldn't be worth
XX							time spent in malloc each time*/
XX
XX	struct pe {
XX		int             x, y;
XX		chtype          c;
XX	}               p1[2];
XX
XX	struct pe      *p2 ;
XX
XX	short cp;
XX	unsigned int     v, score, lv, piece, tcount, sp, sc,srn;
XX	/* current position state, bugs, score, level, piece count,
XX		speed, bugs removed */
XEND_OF_FILE
Xif test 828 -ne `wc -c <'info.h'`; then
X    echo shar: \"'info.h'\" unpacked with wrong size!
Xfi
X# end of 'info.h'
Xfi
Xif test -f 'loop.c' -a "${1}" != "-c" ; then 
X  echo shar: Will not clobber existing file \"'loop.c'\"
Xelse
Xecho shar: Extracting \"'loop.c'\" \(4790 characters\)
Xsed "s/^X//" >'loop.c' <<'END_OF_FILE'
XX#include "info.h"
XX
XXstruct pos      npos[] = {1, 1,
XX			-1, -1}; /*used in turning chips*/
XX
XXvoid
XXloop()
XX{
XX	void            change(), loop2(); 
XX
XX	piece = 0;/* haven't played yet */
XX	mvprintw(1, 0, "Score: %d", score);/*update stats*/
XX	mvprintw(3, 0, "Level: %d", lv);
XX	mvprintw(5, 0, "Bugs left: %02d", v);
XX	mvprintw(7, 0, "Speed: %d", sp);
XX	refresh();
XX	while (v != 0) { /*till no bugs left*/
XX		cp = 0;
XX		nextpiece();
XX		p1->y = p2->y = 0; /*place at top of board*/
XX		p1->x = 4;
XX		p2->x = 5;
XX
XX		mvwaddch(w, p1->y, p1->x, p1->c);
XX		mvwaddch(w, p2->y, p2->x, p2->c);
XX		wrefresh(w);
XX		if (mvwinch(w, 1, 5) != BLANK || mvwinch(w, 1, 4) != BLANK )
XX		/*can't move down, tough luck*/
XX			fatal("Game Over");
XX
XX		loop2(); /*loop here till piece is place*/
XX		meat(); /*checks for removal and removes pieces if necessary
XX				(garbage man)*/
XX		piece++; /*used a piece*/
XX		if (sc) {/*figure out score. if sc=0 we didn't remove any bugs*/
XX			int             sco = sp;
XX			if (sc > 6)
XX				sc = 6;
XX			for (; sc > 1; --sc)
XX				sco = sco * 2;
XX			score += sco * 100;
XX			sc = 0; /*score =  n(sc+1)=n(sc)*200;*/
XX
XX			mvprintw(1, 0, "Score: %d", score);
XX			mvprintw(5, 0, "Bugs left: %02d",  v);
XX			refresh();
XX		}
XX	}
XX}
XX
XXvoid
XXloop2()
XX{
XX	register int    i, dflg = 0, flags;
XX	short           tme = 0; /*time counter*/
XX
XX	while ((i = wgetch(w)) != 'q' && !dflg) {
XX		switch (i) {
XX		case 'h':
XX			mvcheck(0, -1);
XX			break;
XX
XX		case 'l':
XX			mvcheck(0, 1);
XX			break;
XX
XX		case 'k':
XX			if (srn)
XX			mvcheck(-1,0);
XX			break;
XX
XX		case 'j':
XX			dflg = mvcheck(1, 0); /*if dflag is set we hit something*/ 
XX			tme = 0;/*reset timer*/
XX			break;
XX
XX		case 'a': /*rotate counter-clockwise*/ 
XX			change(-1);
XX			break;
XX
XX		case 's':/*rotate clockwise*/ 
XX			change(1);
XX			break;
XX
XX		case ' ':
XX			while (mvcheck(1,0) != -1)
XX			wrefresh(w);
XX			dflg=1;
XX			break;
XX
XX		case 'p':
XX			mvprintw(LINES - 3, COLS - 7, "BUGS I"); 
XX			mvprintw(LINES - 2, COLS - 6, "1.3"); 
XX			refresh();bleed(0,0);
XX			while(getch() != 'p'); 
XX			bleed(0,1);
XX			deleteln();
XX			move(LINES -3,0);deleteln();
XX			deleteln();
XX			refresh();
XX			break;
XXdefault:
XXusleep(250000L - sp*50000);
XXbreak;
XX		}
XX		if (i != EOF)/*EOF is generated if no input*/
XX			wrefresh(w);
XX
XX		tme++; /*increase timer*/
XX		if (tme > 4 ) /*No input for awhile?*/
XX			dflg = mvcheck(1, 0), tme = 0, wrefresh(w);
XX	}
XX	if (dflg && !(cp & 1)) { /*if we're sideways set a[][]*/
XX		a[p1->y][p1->x] = 1;
XX		a[p2->y][p2->x] = 2;
XX	}
XX	if (i == 'q') 
XX		fatal("Quit");
XX}
XX
XXint
XXmvcheck(y1, x1) /*see if we can move or not*/
XX	register int    y1, x1;
XX{
XX	int             a = BLANK, b = BLANK;
XX
XX	/*we don't want to examine the other half of piece*/
XX	if (p1->y + y1 != p2->y || p1->x + x1 != p2->x)
XX		a = mvwinch(w, p1->y + y1, p1->x + x1);
XX	if (p2->y + y1 != p1->y || p2->x + x1 != p1->x)
XX		b = mvwinch(w, p2->y + y1, p2->x + x1);
XX	if (a != BLANK || b != BLANK)
XX		return -1; /*no good, if we're going down, we hit
XX					something*/
XX
XX	mvwaddch(w, p1->y, p1->x, BLANK);
XX	mvwaddch(w, p2->y, p2->x, BLANK);
XX	p1->y += y1;
XX	p2->y += y1;
XX	p1->x += x1;
XX	p2->x += x1;
XX	mvwaddch(w, p1->y, p1->x, p1->c);
XX	mvwaddch(w, p2->y, p2->x, p2->c);
XX	return 0; /*A-ok*/
XX}
XX
XX
XXvoid
XXchange(dir) /*rotate piece*/
XX	int             dir;
XX{
XX	/*if cp=0 or 2 we are sideways, to test we use !(cp&1)  
XX	bit-fields were a possibility here, but not worth it*/
XX
XX	register int    j, l = cp + dir, k = (l & 1); 
XX	int             ny, nx, sideflag = 0;
XX	char            temp;
XX
XX	if (dir == -1)
XX		dir = 0;
XX
XX	ny = npos[k].y; /*next position if turn is successful*/
XX	nx = npos[k].x;
XX
XX	if (p2->x == 8 && cp & 1) { /*if we're on the right wall vertically
XX			we need to backoff to turn & check somewhere else*/
XX		j = mvwinch(w, p1->y, 7); 
XX		sideflag = 1; /*set a flag*/
XX		nx = 0;
XX	} else
XX		j = mvwinch(w, p2->y + ny, p2->x + nx);  
XX		/*not on wall check regularly*/
XX
XX	if (j != BLANK)
XX		return; /*can't turn*/
XX
XX	if (sideflag)
XX		p1->x -= 1;/*had to check a first*/
XX
XX	if ((cp + dir) & 1) {/*swap chars in piece*/
XX		temp = p1->c;
XX		p1->c = p2->c;
XX		p2->c = temp;
XX	}
XX	mvwaddch(w, p1->y, p1->x, p1->c);
XX	mvwaddch(w, p2->y, p2->x, BLANK);
XX
XX	p2->y += ny;/*add new values to current pos*/
XX	p2->x += nx;
XX	mvwaddch(w, p2->y, p2->x, p2->c);
XX
XX	cp = l;
XX	if (cp<0)
XX		cp = 3;
XX	else if (cp > 3)
XX		cp = 0; /*positions number from 0 to 3*/
XX}
XX    /*
XX	    usleep -- support routine for 4.2BSD system call emulations
XX
XX	    last edit:	29-Oct-1984	D A Gwyn
XX    */
XX
XX    extern int	select();
XX
XX
XX    int
XX    usleep( usec )				/* returns 0 if ok, else -1 */
XX	    long		usec;		/* delay in microseconds */
XX	    {
XX	    static struct			/* `timeval' */
XX		    {
XX		    long	tv_sec;		/* seconds */
XX		    long	tv_usec;	/* microsecs */
XX		    }	delay;		/* _select() timeout */
XX
XX	    delay.tv_sec = usec / 1000000L;
XX	    delay.tv_usec = usec % 1000000L;
XX
XX	    return select( 0, (long *)0, (long *)0, (long *)0, &delay );
XX	    }
XX
XEND_OF_FILE
Xif test 4790 -ne `wc -c <'loop.c'`; then
X    echo shar: \"'loop.c'\" unpacked with wrong size!
Xfi
X# end of 'loop.c'
Xfi
Xif test -f 'main.c' -a "${1}" != "-c" ; then 
X  echo shar: Will not clobber existing file \"'main.c'\"
Xelse
Xecho shar: Extracting \"'main.c'\" \(2771 characters\)
Xsed "s/^X//" >'main.c' <<'END_OF_FILE'
XX/***********************************************************/
XX/* BUGS v1.3  Org by SRN at SUNY CT at Utica/Rome July 10,1991*/ 
XX/*          	later mods at UNCW (seq.uncwil.edu)        */
XX/***********************************************************/
XX/* I, being of a somewhat sound mind, hearby place this in*/
XX/* in the great world of public domain 11/15/91*/
XX
XX#include "info.h"
XX#include <signal.h>
XX#include <fcntl.h>
XXvoid bleed();
XXmain(argc,argv)
XX	int argc;
XX	char *argv[];
XX{
XX	void            fatal_err();
XX	signal(SIGQUIT, fatal_err); /*control-/*/
XX	signal(SIGINT, fatal_err); /*control-c*/
XX
XX
XX	srandom(getpid() / 3 + 1);/*if you don't set different seeds,
XX								numbers will always be the same*/
XX				/*Yeah, I know, should've used time.bugs3 does*/
XX	if (getuid()==952) 
XX		srn=1;
XX
XX	initscr(); /*set up term for curses*/
XX	signal(SIGTSTP, fatal_err);/*control-z*/
XX	noecho();
XX	crmode(); /*no return needed for input*/ 
XX
XX	lv = get_option("Level", 0, 20);
XX	sp = get_option("Speed", 1, 3);
XX
XX	clear();
XX	mvprintw(LINES - 1, COLS - 4, "S."); /*signature!*/
XX	refresh(); /*update screen*/
XX	newstart(); /*set up gameboard*/
XX	bleed(0,1); /*unblock stdin*/
XX
XX	while (1) { /*forever*/
XX		int             j;
XX		v = lv * 4 + 4; /*number of bugs formula*/
XX		start(); /*put bugs on board*/
XX		loop(); /*gameplay*/
XX		if (lv != 21)/*finished level here, maxlv=21*/
XX			lv++;
XX		wstandout(w);
XX		mvwprintw(w, 3, 3, "Hit");
XX		mvwprintw(w, 4, 2, "Return");
XX		mvwprintw(w, 5, 1, "for Next");
XX		mvwprintw(w, 6, 2, "Level");
XX		wstandend(w);
XX		wrefresh(w);
XX		while ((j = wgetch(w)) != '\n');
XX	}
XX}
XX
XXvoid 
XXfatal(s)
XX	char           *s; /*End of Game or user quit if we're here*/
XX{
XX	move(LINES - 1, 0);
XX	refresh();
XX	bleed(0,0); /* block stdin, never leave with stdin unblocked!*/
XX	endwin();		/*clean up*/
XX	printf("%s \n", s);
XX	exit(0);
XX}
XX
XXvoid 
XXfatal_err(e) /* handle ctrl-c or z*/
XXint e;
XX{
XX	move(LINES - 1, 0);
XX	refresh();
XX	bleed(0,0);
XX	endwin();
XX    exit(1);
XX}
XX
XXint 
XXget_option(s, min, max) /*set level & speed */
XX	char           *s;
XX	int             max, min;
XX{
XX	int             ch, i = min;
XX
XX	mvprintw(0, 0, "%s : %02d", s, i);
XX	refresh();
XX	while ((ch = getch()) != '\n') {
XX		switch (ch) {
XX		case 'j':
XX			if (i > min)
XX				i--;
XX			break;
XX
XX		case 'k':
XX			if (i < max)
XX				i++;
XX			break;
XX		}
XX		mvprintw(0, 0, "%s : %02d", s, i);
XX		refresh();
XX	}
XX	return i;
XX}
XXvoid bleed(filed,xof) /*control blocking of stdout (or any fd)*/ 
XXint filed,xof;        /*taken from bugs3 */
XX{
XX	int flags;
XX	if ((flags = fcntl(filed, F_GETFL, 0)) < 0)
XX		fatal("fcntl - get flag");
XX
XX	if(xof)    /*if xof is set, don't block filed*/
XX	{
XX		if (fcntl(filed, F_SETFL, flags | FNDELAY) < 0)
XX			fatal("fcntl - set");
XX	}
XX	else       /* block filed */
XX		if (fcntl(0, F_SETFL, flags & ~FNDELAY) < 0)/*block stdin*/
XX			fatal("fcntl - reset");
XX}
XEND_OF_FILE
Xif test 2771 -ne `wc -c <'main.c'`; then
X    echo shar: \"'main.c'\" unpacked with wrong size!
Xfi
X# end of 'main.c'
Xfi
Xif test -f 'meat.c' -a "${1}" != "-c" ; then 
X  echo shar: Will not clobber existing file \"'meat.c'\"
Xelse
Xecho shar: Extracting \"'meat.c'\" \(4543 characters\)
Xsed "s/^X//" >'meat.c' <<'END_OF_FILE'
XX#include "info.h"
XX
XXvoid 
XXmeat() /*checks and removes*/
XX{
XX	int             terminate();
XX	int             remove = 0, i ;
XX	/*remove is flag that we've erased something*/
XX
XX	tcount = 0; /*haven't killed anything yet*/
XX
XX	remove = row(p1->y) + cols(p1->x);
XX
XX	if (cp & 1)
XX		remove += row(p2->y); /*we're vertical*/
XX
XX	if (!(cp & 1))
XX		remove += cols(p2->x);/*we're sideways;horizontal if you wish*/
XX
XX	if (terminate())
XX		return;	/*zap characters and move down pieces if possible
XX				terminate returns 0 unless v==0*/
XX
XX	while (remove) { /*did something check if any fallen pieces
XX						can remove anything*/
XX
XX		remove = 0;/*reset - we might have to do this more than once*/
XX
XX		/*check everywhere*/
XX		for (i = 1; i < 17; i++)
XX			remove += row(i);
XX		for (i = 1; i < 9; i++)
XX			remove += cols(i);
XX		if (remove) /*anything happen?*/
XX			if (terminate()) /*yup.*/
XX				return;
XX	}
XX}
XX
XXint 
XXterminate() /*I'll be back!*/
XX{
XX	void            down();
XX	struct pos     *tp = t; /*tp points to t[0]*/
XX	int             i;
XX	wrefresh(w);
XX
XX	if (v == 0)
XX		return ERR; /*we've killed all the bugs!*/
XX
XX	/*walk through t[48]*/
XX	for (i = 0; tcount > i; tp++, i++)
XX		while (tp->y < 18) /*till we're at the bottom*/
XX			if (mvwinch(w, tp->y, tp->x) != BLANK)
XX				break; /*nothing there*/
XX			else
XX				down(tp->y++, tp->x);/*pull down one if we can, then
XX									see if we can do it again*/
XX
XX	tcount = 0;/*no more in t[]*/
XX	wrefresh(w);
XX	return 0; /*still got bugs left*/
XX}
XX
XXvoid 
XXdown(y, x)
XX	register int    y, x;
XX{
XX	register chtype ad;
XX	register int    b;
XX
XX	/*if current pos is blank and up is not & not  a bug & we're not at 
XX	the top,(whew!) we're ok*/
XX	while (mvwinch(w, y, x) == BLANK && (b = a[y - 1][x]) != 3 && y > 1 &&
XX	       (ad = mvwinch(w, y - 1, x)) != BLANK)
XX		if (b == 1)
XX			if (mvwinch(w, y, x + 1) == BLANK) {
XX				a[y - 1][x] = a[y - 1][x + 1] = 0;
XX				a[y][x] = 1;
XX				a[y][x + 1] = 2;
XX				down(y, x + 1);/*side piece  - can move down. 
XX				use recursion to go up next column
XX				(wow. & I thought I'd never use recursion!)*/
XX			} else
XX				return; /*forget it. side piece can't move down*/
XX		else if (b == 2)
XX			if (mvwinch(w, y, x - 1) == BLANK) {
XX				a[y - 1][x] = a[y - 1][x - 1] = 0;
XX				a[y][x] = 2;
XX				a[y][x - 1] = 1;
XX				down(y, x - 1); /*same thing*/
XX			} else
XX				return;
XX		else {
XX			mvwaddch(w, y, x, ad);/*move piece down*/
XX			mvwaddch(w, --y, x, BLANK);
XX			wrefresh(w);
XX		}
XX}
XX
XXint 
XXrow(y)
XX	register int    y; /*check rows*/
XX{
XX	void            seta();
XX	register chtype a1, b1;
XX	register int    x = 0;
XX	int             status = 0;
XX
XX	while (x < 10) {
XX		register int    counter = 0;
XX		do {
XX			a1 = mvwinch(w, y, x++);
XX			b1 = mvwinch(w, y, x);
XX			counter++;
XX		} while (a1 == b1 && a1 != BLANK);/*keep going till different*/
XX
XX		if (counter < 4) /*less than four in a row?*/    
XX			continue;
XX
XX		/*put cordinates in t[], increment tcount, check for bugs,
XX		if bugs increase sc */
XX		for (; counter > 0; counter--) {
XX			t[tcount].y = y;
XX			t[tcount++].x = x - counter;
XX			mvwaddch(w, y, x - counter, BLANK);
XX			if (a[y][x - counter] == 3)
XX				sc++, v--;
XX			seta(y, x - counter);
XX			status = 1; /*so remove knows we did something*/
XX		}
XX	}
XX	return status; 
XX}
XX
XXvoid 
XXseta(y, x)
XX	int             y, x;
XX{
XX	int             lr;
XX	lr = a[y][x];
XX	a[y][x] = 0;
XX	if (lr == 1) 
XX		a[y][x + 1] = 0; /*if it was laid sideways and was removed
XX							free the other side*/
XX	else if (lr == 2)
XX		a[y][x - 1] = 0;
XX}
XX
XXint 
XXcols(x)
XX	register int    x; /*basically same as rows*/
XX{
XX	void            setac();
XX	register chtype a1, b1;
XX	register int    y = 0;
XX	int             status = 0;
XX
XX	while (y < 18) {
XX		register int    counter = 0;
XX		do {
XX			a1 = mvwinch(w, y++, x);
XX			b1 = mvwinch(w, y, x);
XX			counter++;
XX		} while (a1 == b1 && a1 != BLANK);
XX		if (counter < 4)
XX			continue;
XX
XX		t[tcount].y = y - counter;  /*we don't have to check*/
XX		t[tcount++].x = x;			/*every piece removed*/  
XX		t[tcount].y = y;  			/*when we killed it*/
XX		t[tcount++].x = x; 			/*vertically*/
XX
XX		for (; counter > 0; counter--) {
XX			mvwaddch(w, y - counter, x, BLANK);
XX			if (a[y - counter][x] == 3)
XX				sc++, v--;
XX			setac(y - counter, x);
XX			status = 1;
XX		}
XX	}
XX	return status;
XX}
XX
XXvoid 
XXsetac(y, x)
XX	int             y, x;
XX{
XX	int             lr;
XX	lr = a[y][x];
XX	a[y][x] = 0;
XX	if (lr == 1) {
XX		a[y][x + 1] = 0;
XX		if (mvwinch(w, y + 1, x + 1) == BLANK)
XX			t[tcount].y = y + 1, t[tcount++].x = x + 1;
XX	/*set t[] here because terminate won't check the neighboring cols*/
XX	} else if (lr == 2) {
XX		a[y][x - 1] = 0;
XX		if (mvwinch(w, y + 1, x - 1) == BLANK)
XX			t[tcount].y = y + 1;
XX		t[tcount++].x = x - 1;
XX	}
XX}
XEND_OF_FILE
Xif test 4543 -ne `wc -c <'meat.c'`; then
X    echo shar: \"'meat.c'\" unpacked with wrong size!
Xfi
X# end of 'meat.c'
Xfi
Xif test -f 'startup.c' -a "${1}" != "-c" ; then 
X  echo shar: Will not clobber existing file \"'startup.c'\"
Xelse
Xecho shar: Extracting \"'startup.c'\" \(1538 characters\)
Xsed "s/^X//" >'startup.c' <<'END_OF_FILE'
XX#include "info.h"
XX
XXvoid 
XXnewstart()
XX{
XX	c[0] = 'A'; /* Game pieces */
XX	c[1] = 'L'; 
XX	c[2] = 'S'; 
XX
XX	p2 = &p1[1]; /*pointers not really necessary here
XX					for that matter neither is array*/
XX
XX	w = subwin(stdscr,18, 10, 2, 32);/*make gameboard*/
XX	if (w == (WINDOW *) NULL)
XX		fatal("memory error"); /*trouble- no memory!*/
XX
XX	box(w, 124, 34);
XX
XX	mvwprintw(w, 0, 0, "___!  !___");/*change box a little*/
XX	mvwaddch(w, 17, 0, 34);
XX	mvwaddch(w, 17, 9, 34);
XX}
XX
XXvoid 
XXstart() 					/*call this every new level*/
XX{
XX	void            nextpiece();
XX	extern char     c[];
XX	int             i, x, y, z, ch;
XX	for (y = 1; y < 17; y++) 	/*zap board and a[][]*/
XX		for (x = 1; x < 9; x++)
XX			mvwaddch(w, y, x, BLANK), a[y][x] = 0;
XX	wrefresh(w);
XX	wstandout(w); /*reverse all characters added till standend()*/
XX	for (i = 0; i < v; i++) {
XX		do {
XX			z = rx(3, 0); /*which char?*/
XX			x = rx(8, 1);
XX			y = rx(14, 4);
XX			ch = mvwinch(w, y, x);
XX			if ((mvwinch(w, y + 3, x) == c[z] || mvwinch(w, y - 3, x) == c[z])
XX			    || (mvwinch(w, y, x + 3) == c[z] || mvwinch(w, y, x - 3) == c[z])) /* can't have 4 in a row or col to start */
XX				ch = 0;
XX
XX		} while (ch != BLANK);
XX		mvwaddch(w, y, x, c[z]); /*place on board */
XX		a[y][x] = 3; /* show bug in a[][]*/
XX		wrefresh(w);
XX	}
XX	wstandend(w);
XX	nextpiece();/*show next piece*/
XX}
XXvoid 
XXnextpiece()
XX{
XX	static chtype   na, nb;/*remember every time*/
XX	p1->c = c[na];/*put old chars in play*/
XX	p2->c = c[nb];
XX	na = rx(3, 0);/* make new next piece & display it*/
XX	nb = rx(3, 0);
XX	mvprintw(1, 36, "%c%c", c[na], c[nb]);
XX	refresh();
XX}
XEND_OF_FILE
Xif test 1538 -ne `wc -c <'startup.c'`; then
X    echo shar: \"'startup.c'\" unpacked with wrong size!
Xfi
X# end of 'startup.c'
Xfi
Xecho shar: End of shell archive.
Xexit 0
X
END_OF_FILE
if test 21473 -ne `wc -c <'mario.shr'`; then
    echo shar: \"'mario.shr'\" unpacked with wrong size!
fi
# end of 'mario.shr'
fi
if test -f 'meat.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'meat.c'\"
else
echo shar: Extracting \"'meat.c'\" \(4543 characters\)
sed "s/^X//" >'meat.c' <<'END_OF_FILE'
X#include "info.h"
X
Xvoid 
Xmeat() /*checks and removes*/
X{
X	int             terminate();
X	int             remove = 0, i ;
X	/*remove is flag that we've erased something*/
X
X	tcount = 0; /*haven't killed anything yet*/
X
X	remove = row(p1->y) + cols(p1->x);
X
X	if (cp & 1)
X		remove += row(p2->y); /*we're vertical*/
X
X	if (!(cp & 1))
X		remove += cols(p2->x);/*we're sideways;horizontal if you wish*/
X
X	if (terminate())
X		return;	/*zap characters and move down pieces if possible
X				terminate returns 0 unless v==0*/
X
X	while (remove) { /*did something check if any fallen pieces
X						can remove anything*/
X
X		remove = 0;/*reset - we might have to do this more than once*/
X
X		/*check everywhere*/
X		for (i = 1; i < 17; i++)
X			remove += row(i);
X		for (i = 1; i < 9; i++)
X			remove += cols(i);
X		if (remove) /*anything happen?*/
X			if (terminate()) /*yup.*/
X				return;
X	}
X}
X
Xint 
Xterminate() /*I'll be back!*/
X{
X	void            down();
X	struct pos     *tp = t; /*tp points to t[0]*/
X	int             i;
X	wrefresh(w);
X
X	if (v == 0)
X		return ERR; /*we've killed all the bugs!*/
X
X	/*walk through t[48]*/
X	for (i = 0; tcount > i; tp++, i++)
X		while (tp->y < 18) /*till we're at the bottom*/
X			if (mvwinch(w, tp->y, tp->x) != BLANK)
X				break; /*nothing there*/
X			else
X				down(tp->y++, tp->x);/*pull down one if we can, then
X									see if we can do it again*/
X
X	tcount = 0;/*no more in t[]*/
X	wrefresh(w);
X	return 0; /*still got bugs left*/
X}
X
Xvoid 
Xdown(y, x)
X	register int    y, x;
X{
X	register chtype ad;
X	register int    b;
X
X	/*if current pos is blank and up is not & not  a bug & we're not at 
X	the top,(whew!) we're ok*/
X	while (mvwinch(w, y, x) == BLANK && (b = a[y - 1][x]) != 3 && y > 1 &&
X	       (ad = mvwinch(w, y - 1, x)) != BLANK)
X		if (b == 1)
X			if (mvwinch(w, y, x + 1) == BLANK) {
X				a[y - 1][x] = a[y - 1][x + 1] = 0;
X				a[y][x] = 1;
X				a[y][x + 1] = 2;
X				down(y, x + 1);/*side piece  - can move down. 
X				use recursion to go up next column
X				(wow. & I thought I'd never use recursion!)*/
X			} else
X				return; /*forget it. side piece can't move down*/
X		else if (b == 2)
X			if (mvwinch(w, y, x - 1) == BLANK) {
X				a[y - 1][x] = a[y - 1][x - 1] = 0;
X				a[y][x] = 2;
X				a[y][x - 1] = 1;
X				down(y, x - 1); /*same thing*/
X			} else
X				return;
X		else {
X			mvwaddch(w, y, x, ad);/*move piece down*/
X			mvwaddch(w, --y, x, BLANK);
X			wrefresh(w);
X		}
X}
X
Xint 
Xrow(y)
X	register int    y; /*check rows*/
X{
X	void            seta();
X	register chtype a1, b1;
X	register int    x = 0;
X	int             status = 0;
X
X	while (x < 10) {
X		register int    counter = 0;
X		do {
X			a1 = mvwinch(w, y, x++);
X			b1 = mvwinch(w, y, x);
X			counter++;
X		} while (a1 == b1 && a1 != BLANK);/*keep going till different*/
X
X		if (counter < 4) /*less than four in a row?*/    
X			continue;
X
X		/*put cordinates in t[], increment tcount, check for bugs,
X		if bugs increase sc */
X		for (; counter > 0; counter--) {
X			t[tcount].y = y;
X			t[tcount++].x = x - counter;
X			mvwaddch(w, y, x - counter, BLANK);
X			if (a[y][x - counter] == 3)
X				sc++, v--;
X			seta(y, x - counter);
X			status = 1; /*so remove knows we did something*/
X		}
X	}
X	return status; 
X}
X
Xvoid 
Xseta(y, x)
X	int             y, x;
X{
X	int             lr;
X	lr = a[y][x];
X	a[y][x] = 0;
X	if (lr == 1) 
X		a[y][x + 1] = 0; /*if it was laid sideways and was removed
X							free the other side*/
X	else if (lr == 2)
X		a[y][x - 1] = 0;
X}
X
Xint 
Xcols(x)
X	register int    x; /*basically same as rows*/
X{
X	void            setac();
X	register chtype a1, b1;
X	register int    y = 0;
X	int             status = 0;
X
X	while (y < 18) {
X		register int    counter = 0;
X		do {
X			a1 = mvwinch(w, y++, x);
X			b1 = mvwinch(w, y, x);
X			counter++;
X		} while (a1 == b1 && a1 != BLANK);
X		if (counter < 4)
X			continue;
X
X		t[tcount].y = y - counter;  /*we don't have to check*/
X		t[tcount++].x = x;			/*every piece removed*/  
X		t[tcount].y = y;  			/*when we killed it*/
X		t[tcount++].x = x; 			/*vertically*/
X
X		for (; counter > 0; counter--) {
X			mvwaddch(w, y - counter, x, BLANK);
X			if (a[y - counter][x] == 3)
X				sc++, v--;
X			setac(y - counter, x);
X			status = 1;
X		}
X	}
X	return status;
X}
X
Xvoid 
Xsetac(y, x)
X	int             y, x;
X{
X	int             lr;
X	lr = a[y][x];
X	a[y][x] = 0;
X	if (lr == 1) {
X		a[y][x + 1] = 0;
X		if (mvwinch(w, y + 1, x + 1) == BLANK)
X			t[tcount].y = y + 1, t[tcount++].x = x + 1;
X	/*set t[] here because terminate won't check the neighboring cols*/
X	} else if (lr == 2) {
X		a[y][x - 1] = 0;
X		if (mvwinch(w, y + 1, x - 1) == BLANK)
X			t[tcount].y = y + 1;
X		t[tcount++].x = x - 1;
X	}
X}
END_OF_FILE
if test 4543 -ne `wc -c <'meat.c'`; then
    echo shar: \"'meat.c'\" unpacked with wrong size!
fi
# end of 'meat.c'
fi
if test -f 'startup.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'startup.c'\"
else
echo shar: Extracting \"'startup.c'\" \(1538 characters\)
sed "s/^X//" >'startup.c' <<'END_OF_FILE'
X#include "info.h"
X
Xvoid 
Xnewstart()
X{
X	c[0] = 'A'; /* Game pieces */
X	c[1] = 'L'; 
X	c[2] = 'S'; 
X
X	p2 = &p1[1]; /*pointers not really necessary here
X					for that matter neither is array*/
X
X	w = subwin(stdscr,18, 10, 2, 32);/*make gameboard*/
X	if (w == (WINDOW *) NULL)
X		fatal("memory error"); /*trouble- no memory!*/
X
X	box(w, 124, 34);
X
X	mvwprintw(w, 0, 0, "___!  !___");/*change box a little*/
X	mvwaddch(w, 17, 0, 34);
X	mvwaddch(w, 17, 9, 34);
X}
X
Xvoid 
Xstart() 					/*call this every new level*/
X{
X	void            nextpiece();
X	extern char     c[];
X	int             i, x, y, z, ch;
X	for (y = 1; y < 17; y++) 	/*zap board and a[][]*/
X		for (x = 1; x < 9; x++)
X			mvwaddch(w, y, x, BLANK), a[y][x] = 0;
X	wrefresh(w);
X	wstandout(w); /*reverse all characters added till standend()*/
X	for (i = 0; i < v; i++) {
X		do {
X			z = rx(3, 0); /*which char?*/
X			x = rx(8, 1);
X			y = rx(14, 4);
X			ch = mvwinch(w, y, x);
X			if ((mvwinch(w, y + 3, x) == c[z] || mvwinch(w, y - 3, x) == c[z])
X			    || (mvwinch(w, y, x + 3) == c[z] || mvwinch(w, y, x - 3) == c[z])) /* can't have 4 in a row or col to start */
X				ch = 0;
X
X		} while (ch != BLANK);
X		mvwaddch(w, y, x, c[z]); /*place on board */
X		a[y][x] = 3; /* show bug in a[][]*/
X		wrefresh(w);
X	}
X	wstandend(w);
X	nextpiece();/*show next piece*/
X}
Xvoid 
Xnextpiece()
X{
X	static chtype   na, nb;/*remember every time*/
X	p1->c = c[na];/*put old chars in play*/
X	p2->c = c[nb];
X	na = rx(3, 0);/* make new next piece & display it*/
X	nb = rx(3, 0);
X	mvprintw(1, 36, "%c%c", c[na], c[nb]);
X	refresh();
X}
END_OF_FILE
if test 1538 -ne `wc -c <'startup.c'`; then
    echo shar: \"'startup.c'\" unpacked with wrong size!
fi
# end of 'startup.c'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
