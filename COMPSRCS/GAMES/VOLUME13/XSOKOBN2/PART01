Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i013:  xsokoban2 - another X11 based, get the money game, Part01/03
Message-ID: <2266@masterCNA.TEK.COM>
Date: 10 Jan 92 00:32:00 GMT
Sender: news@masterCNA.TEK.COM
Lines: 1847
Approved: billr@saab.CNA.TEK.COM

Submitted-by: "Joseph L. Traub" <jt1o+@andrew.cmu.edu>
Posting-number: Volume 13, Issue 13
Archive-name: xsokoban2/Part01
Environment: x11, xlib

	[This version presents a slightly different user interface than
	 the previously posted version (xsokoban, v13i001/2). It compiled
	 and executed OK on my SS-2, X11R5.  -br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  README MANIFEST README.v2 README.vX bitmaps help.h play.c
#   score.c screens screens/screen.10 sok.c xdisp.c
# Wrapped by billr@saab on Thu Jan  9 16:24:57 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1551 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XThis is SOKOBAN.
X
XI saw this game first on a PC running MSDOS. I found the idea of the game so
Xclever, that I made up my mind to make it run with an ascii terminal using
Xcurses so that we can play it on our MicroVAX/ULTRIX. 
X
XAlong with this package there are alot of screen files describing the various
Xplay levels. So what you need to do to install it on your own machine is:
X
X-   Edit the header file sokoban.h to alter the given defines
X
XYou have to note the following restrictions
X
X-   The screen files must be readable for everyone who should be able to play
X    his game
X-   The score file should have read/write permission only for the owner
X    of the executable program. Because of that sokoban must run with setuid.
X
XYou can now compile it (just type 'make').
XIf compilation is succesful you must initialize the score file (just type
X'sokoban -c')
X
XThere is no manual page. All you have to know when you first play the game is
Xthe command '?'. This gives you one screenful of information.
X
XAfter you have solved all the given screens (this will take a while) you will
Xfind the game boring (sure you will). I hope there will be a lot of players who
Xwill think out some new screens.
XTo test your own screens copy them to the screen directory (with a new level
Xnumber <nn>) and type sokoban -<nn>.
X
XPLEASE DO SO AND POST NEW SCREENS TO THE NET.
XOTHERWISE IT GETS BORING !!!!!!!!!!!!!!!!!!!!
X
XComments are welcome.
X
XFrom Canada or the US reply to ...!pyramid!tub!astbe!ber
X   (otherwise it would be expensive)
Xfrom elsewhere reply to ber@astbe
END_OF_FILE
if test 1551 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2904 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X Makefile                   2	
X README                     1	
X README.v2                  1	
X README.vX                  1	
X bitmaps                    1	
X bitmaps/centerwall.xbm     2	
X bitmaps/east_twall.xbm     2	
X bitmaps/eastwall.xbm       2	
X bitmaps/floor.xbm          2	
X bitmaps/goal.xbm           2	
X bitmaps/horizwall.xbm      2	
X bitmaps/llcornerwall.xbm   2	
X bitmaps/lonewall.xbm       2	
X bitmaps/lrcornerwall.xbm   2	
X bitmaps/man.xbm            2	
X bitmaps/north_twall.xbm    2	
X bitmaps/northwall.xbm      2	
X bitmaps/object.xbm         2	
X bitmaps/saveman.xbm        2	
X bitmaps/south_twall.xbm    2	
X bitmaps/southwall.xbm      2	
X bitmaps/treasure.xbm       2	
X bitmaps/ulcornerwall.xbm   2	
X bitmaps/urcornerwall.xbm   2	
X bitmaps/vertiwall.xbm      2	
X bitmaps/wall.xbm           2	
X bitmaps/west_twall.xbm     2	
X bitmaps/westwall.xbm       2	
X help.h                     1	
X makefile                   2	
X play.c                     1	
X readscreen.c               2	
X save.c                     2	
X score.c                    1	
X screens                    1	
X screens/screen.1           3	
X screens/screen.10          1	
X screens/screen.11          3	
X screens/screen.12          3	
X screens/screen.13          3	
X screens/screen.14          2	
X screens/screen.15          3	
X screens/screen.16          3	
X screens/screen.17          3	
X screens/screen.18          3	
X screens/screen.19          3	
X screens/screen.2           3	
X screens/screen.20          2	
X screens/screen.21          3	
X screens/screen.22          2	
X screens/screen.23          3	
X screens/screen.24          2	
X screens/screen.25          2	
X screens/screen.26          3	
X screens/screen.27          3	
X screens/screen.28          2	
X screens/screen.29          3	
X screens/screen.3           3	
X screens/screen.30          2	
X screens/screen.31          3	
X screens/screen.32          3	
X screens/screen.33          3	
X screens/screen.34          3	
X screens/screen.35          2	
X screens/screen.36          2	
X screens/screen.37          2	
X screens/screen.38          3	
X screens/screen.39          2	
X screens/screen.4           3	
X screens/screen.40          3	
X screens/screen.41          2	
X screens/screen.42          3	
X screens/screen.43          3	
X screens/screen.44          2	
X screens/screen.45          3	
X screens/screen.46          3	
X screens/screen.47          3	
X screens/screen.48          3	
X screens/screen.49          3	
X screens/screen.5           3	
X screens/screen.50          2	
X screens/screen.6           3	
X screens/screen.7           3	
X screens/screen.8           3	
X screens/screen.9           3	
X showscreen.c               2	
X sok.c                      1	
X sokoban.h                  2	
X xdisp.c                    1	
END_OF_FILE
if test 2904 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README.v2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.v2'\"
else
echo shar: Extracting \"'README.v2'\" \(1264 characters\)
sed "s/^X//" >'README.v2' <<'END_OF_FILE'
XThis is my second version of SOKOBAN.
X
XThe first thing I have to say is that I don't have the sources for SOKOBAN
Xunder MS-DOS. I believe that this program is copyrighted. I took only the
Xidea and the screens of the PC-version.
XI think that porting my version of SOKOBAN to the PC will not be very difficult
Xif you use the PC-Curses version which was on the net some months ago.
X
XI had a short mail talk with Norman Ramsey (...!allegra!princeton!nr) who wants 
Xto do the porting. He said that he will post his version if the work is done.
X
XSome people asked me whether it is possible to make a better looking screen.
XI added some extra definitions to the header file sokoban.h so that it is
Xpossible to alter the the characters that are used for the representation of
Xthe objects on the screen. You can also define wheter the object is displayed
Xin standout mode (invers) or not.
X
XThere is no helpfile anymore (sokoban.help in the first version). I
Xincluded the help file in showscreen.c and made a better help facility.
X
XThe score files from both versions are compatible so that you can go on with
Xthe game.
X
XAt last I added some new screens. I hope you enjoy them.
X
XIf you have already designed some new screens mail them to me. My netadress is
Xgiven in README.
END_OF_FILE
if test 1264 -ne `wc -c <'README.v2'`; then
    echo shar: \"'README.v2'\" unpacked with wrong size!
fi
# end of 'README.v2'
fi
if test -f 'README.vX' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.vX'\"
else
echo shar: Extracting \"'README.vX'\" \(2563 characters\)
sed "s/^X//" >'README.vX' <<'END_OF_FILE'
XThis is the X version of sokoban.
X
XThe only way this is different from the previous version is that the curses
Xdisplay routines have been removed, and replaced with an X driven display.
XHowever this implies some small differences and enhancements as detailed below.
X
XI have nothing to do with the original author of Sokoban, and did attempt
Xto contact the author of the unix version, but was unable to get a reply
Xback from him.
X
XI'm releasing this to the net as a public service.  This game is EXCLUSIVELY
Xin the public domain.
X
XCHANGES:
X   -- Requires at least X11R4 to compile.
X   -- bitmaps can be specified on the command line or via xresources.
X      On the command line, -b followed by the directory in which to find
X      the bitmaps will cause them to be loaded from there instead of the
X      default.  Anyone not found will be loaded from the default.
X   -- the fancy walls option can be specified via the command line or via
X      xresources.
X   -- the arrow keys on DEC keyboards can be used to control movement in
X      exactly the same ways as the h, j, k, l keys can (including shifted
X      or controlled).
X   -- The program recognizes the following x resources.
X      xsokoban.foreground:	The name of the color to use as the foreground.
X      xsokoban.background:	The name of the color to use as the background.
X      xsokoban.border:		The name of the color to use as the border.
X      xsokoban.cursor:		The name of the color to use as the cursor
X				foreground.
X      xsokoban.fontname:	The name of the font to display text with.
X				Using a font other than 9x15 (the default)
X				may cause some parts of the help screens to
X				not display properly.
X      xsokoban.bitmaps:		The name of the directory in which to search
X				for the bitmaps used by the program.
X      xsokoban.fancyWalls:	Specifies whether to use fancy walls or not.
X				Use 0 for false or anything else for true
X   -- It is possible that the score file format is NOT compatable with
X      versions of sokoban in existance.  I believe that the standard
X      sokoban scorefile format was modified here at CMU, and I used the CMU
X      score file version in this code.
X
XA list of the names of the bitmap files and what they expect is given in the
Xinternal help.
X
XThere is no man page for this program to this date.
X
XIf anyone wishes to write the man page, or to make other improvements to this
Xcode, please send me context diffs agains these sources, and I will take care
Xof merging all patches together and redistributing them.
X
XThank you.
X
XJoseph L. Traub
Xjt1o@andrew.cmu.edu
END_OF_FILE
if test 2563 -ne `wc -c <'README.vX'`; then
    echo shar: \"'README.vX'\" unpacked with wrong size!
fi
# end of 'README.vX'
fi
if test ! -d 'bitmaps' ; then
    echo shar: Creating directory \"'bitmaps'\"
    mkdir 'bitmaps'
fi
if test -f 'help.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help.h'\"
else
echo shar: Extracting \"'help.h'\" \(3691 characters\)
sed "s/^X//" >'help.h' <<'END_OF_FILE'
Xtypedef struct helpline {
X   int xpos, ypos, page;
X   char *textline;
X} h_line;
X
Xh_line help_pages[] = {
X  { 0, 35, 0, "Objective:  Push all the objects from their starting positions"},
X  { 12, 50, 0, "into their goal positions.  Be warned that you can"},
X  { 12, 65, 0, "push only one object at a time; watch out for corners!"},
X  { 0, 100, 0, "Movement:   Use the vi-keys hjkl or the keyboard arrow keys"},
X  { 25, 130, 0, "left right up down"},
X  { 13, 145, 0, "Move/Push     h    l    k   j"},
X  { 13, 160, 0, "Run/Push      H    L    K   J"},
X  { 13, 175, 0, "Run Only     ^H   ^L   ^K  ^J"},
X  { 0, 210, 0, "Commands:"},
X  { 12, 210, 0, "^r: refresh screen            ?: get this help screen"},
X  { 12, 225, 0, "^u: restore to temp save      c: make a temp save"}, 
X  { 12, 240, 0, " u: undo last move/push       U: restart this level"},
X  { 12, 255, 0, " s: save game and quit        q: quit game"},
X  { 0, 285, 0, "Misc:       If you set a temp save, you need not undo all"},
X  { 12, 300, 0, "when you get stuck.  Just reset to this save."},
X  { 12, 330, 0, "A temporary save is automatically made at the start."},
X  { 0, 380, 0, "Bitmaps:"},
X  { 12, 380, 0, "Player:     Goal:      Wall:     Object:"},
X  { 12, 420, 0, "Object on a goal:      Player on a goal:"},
X  { 0, 35, 1, "                  Making your own bitmaps"},
X  { 0, 65, 1, "The game expects various bitmaps to be present in the"},
X  { 0, 80, 1, "directory you specify with -b.  The following are the"},
X  { 0, 95, 1, "correspondences between files and game objects:"},
X  { 0, 110, 1, "   man.xbm      -- The player bitmap"},
X  { 0, 125, 1, "   goal.xbm     -- The bitmap for the goal"},
X  { 0, 140, 1, "   wall.xbm     -- The generic wall bitmap"},
X  { 0, 155, 1, "   object.xbm   -- Bitmap for the object you push around"},
X  { 0, 170, 1, "   treasure.xbm -- Bitmap for an object on the goal"},
X  { 0, 185, 1, "   saveman.xbm  -- Bitmap for man on a goal position"},
X  { 0, 200, 1, "If you use the -w option (for fancy walls), the following"},
X  { 0, 215, 1, "bitmaps are also needed:"},
X  { 0, 230, 1, "   southwall.xbm    -- wall with only northern connections"},
X  { 0, 245, 1, "   northwall.xbm    -- wall with only southern connections"}, 
X  { 0, 260, 1, "   eastwall.xbm     -- wall with only western connections"}, 
X  { 0, 275, 1, "   westwall.xbm     -- wall with only eastern connections"}, 
X  { 0, 290, 1, "   llcornerwall.xbm -- Lower left hand corner wall"},
X  { 0, 305, 1, "   ulcornerwall.xbm -- Upper left hand corner wall"}, 
X  { 0, 320, 1, "   lrcornerwall.xbm -- Lower right hand corner wall"},
X  { 0, 335, 1, "   urcornerwall.xbm -- Upper right hand corner wall"}, 
X  { 0, 350, 1, "   north_twall.xbm  -- connects to south, east, and west"},
X  { 0, 365, 1, "   south_twall.xbm  -- connects to north, east, and west"},
X  { 0, 380, 1, "   east_twall.xbm   -- connects to north, south, and west"},
X  { 0, 395, 1, "   west_twall.xbm   -- connects to north, south, and east"},
X  { 0, 410, 1, "   centerwall.xbm   -- connects to walls on every side"},
X  { 0, 425, 1, "   lonewall.xbm     -- connects to walls on no sides"},
X  { 0, 440, 1, "If you do not have a saveman.xbm, it will try to load man.xbm"},
X  { 0, 455, 1, "and if you use -w and a wall file is missing, it will try to"},
X  { 0, 470, 1, "load wall.xbm."},
X  { 0, 485, 1, "All loading takes place in the following order:"},
X  { 0, 500, 1, "  bitmap from -b dir (if -b specified)"},
X  { 0, 515, 1, "  alternate from -b dir (if -b specified, and there is an"},
X  { 0, 530, 1, "    alternate (see saveman.xbm and -w wall bitmaps))"},
X  { 0, 545, 1, "  default bitmap"},
X  { 0, 560, 1, "  default alternate if one exists"},
X  {0, 0, 0, NULL}
X};
END_OF_FILE
if test 3691 -ne `wc -c <'help.h'`; then
    echo shar: \"'help.h'\" unpacked with wrong size!
fi
# end of 'help.h'
fi
if test -f 'play.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'play.c'\"
else
echo shar: Extracting \"'play.c'\" \(6948 characters\)
sed "s/^X//" >'play.c' <<'END_OF_FILE'
X#include <ctype.h>
X#include "sokoban.h"
X
X/* defining the types of move */
X#define MOVE 		1
X#define PUSH 		2
X#define SAVE 		3
X#define UNSAVE 		4
X#define STOREMOVE 	5
X#define STOREPUSH 	6
X
X/* defines for control characters */
X#define CNTL_L		'\014'
X#define CNTL_K		'\013'
X#define CNTL_H		'\010'
X#define CNTL_J		'\012'
X#define CNTL_R		'\022'
X#define CNTL_U		'\025'
X
Xextern char  map[MAXROW+1][MAXCOL+1];
Xextern short rows, cols, level, moves, pushes, savepack, packets;
Xextern short scorelevel, scoremoves, scorepushes;
Xextern POS   ppos;
X
Xstatic POS   tpos1,		   /* testpos1: 1 pos. over/under/left/right */
X             tpos2,		   /* testpos2: 2 pos.  "                    */
X             lastppos,		   /* the last player position (for undo)    */
X             lasttpos1, lasttpos2; /* last test positions (for undo)         */
Xstatic char lppc, ltp1c, ltp2c;    /* the char for the above pos. (for undo) */
Xstatic short action, lastaction;
X
X/** For the temporary save **/
Xstatic char  tmp_map[MAXROW+1][MAXCOL+1];
Xstatic short tmp_pushes, tmp_moves, tmp_savepack;
Xstatic POS   tmp_ppos;
X
Xshort play() {
X
X   short c;
X   short ret;
X   short undolock = 1;		/* locked for undo */
X   
X   clearscreen();
X   showscreen();
X   tmpsave();
X   ret = 0;
X   while( ret == 0) {
X      switch( (c = event_loop())) {
X	 case 'q':    /* quit the game 					*/
X	              ret = E_ENDGAME; 
X	              break;
X	 case 's':    /* save the games					*/
X		      if( (ret = savegame()) == 0)
X			 ret = E_SAVED;
X		      break;
X	 case '?':    /* show the help file				*/
X		      showhelp();
X		      redisp_screen();
X		      break;
X	 case CNTL_R: /* refresh the screen 				*/
X		      redisp_screen();
X		      break;
X	 case 'c':    /* temporary save					*/
X		      tmpsave();
X		      break;
X	 case CNTL_U: /* reset to temporary save 			*/
X		      tmpreset();
X		      undolock = 1;
X		      showscreen();
X		      break;
X	 case 'U':    /* undo this level 				*/
X		      moves = pushes = 0;
X		      if( (ret = readscreen()) == 0) {
X		         showscreen();
X			 undolock = 1;
X		      }
X		      break;
X	 case 'u':    /* undo last move 				*/
X		      if( ! undolock) {
X		         undomove();
X		         undolock = 1;
X		      }
X		      break;
X	 case 'k':    /* up 						*/
X	 case 'K':    /* run up 					*/
X	 case CNTL_K: /* run up, stop before object 			*/
X	 case 'j':    /* down 						*/
X	 case 'J':    /* run down 					*/
X	 case CNTL_J: /* run down, stop before object 			*/
X	 case 'l':    /* right 						*/
X	 case 'L':    /* run right 					*/
X	 case CNTL_L: /* run right, stop before object 			*/
X	 case 'h':    /* left 						*/
X	 case 'H':    /* run left 					*/
X	 case CNTL_H: /* run left, stop before object 			*/
X		      do {
X		         if( (action = testmove( c)) != 0) {
X			    lastaction = action;
X		            lastppos.x = ppos.x; lastppos.y = ppos.y;
X		            lppc = map[ppos.x][ppos.y];
X		            lasttpos1.x = tpos1.x; lasttpos1.y = tpos1.y; 
X		            ltp1c = map[tpos1.x][tpos1.y];
X		            lasttpos2.x = tpos2.x; lasttpos2.y = tpos2.y; 
X		            ltp2c = map[tpos2.x][tpos2.y];
X		            domove( lastaction); 
X		            undolock = 0;
X		         }
X		      } while( (action != 0) && (! islower( c))
X			      && (packets != savepack));
X		      break;
X	 default:     helpmessage(); break;
X      }
X      if( (ret == 0) && (packets == savepack)) {
X	 scorelevel = level;
X	 scoremoves = moves;
X	 scorepushes = pushes;
X	 break;
X      }
X   }
X   return( ret);
X}
X
Xtestmove( action)
Xregister short action;
X{
X   register short ret;
X   register char  tc;
X   register short stop_at_object;
X
X   if( (stop_at_object = iscntrl( action))) action = action + 'A' - 1;
X   action = (isupper( action)) ? tolower( action) : action;
X   if( (action == 'k') || (action == 'j')) {
X      tpos1.x = (action == 'k') ? ppos.x-1 : ppos.x+1;
X      tpos2.x = (action == 'k') ? ppos.x-2 : ppos.x+2;
X      tpos1.y = tpos2.y = ppos.y;
X   }
X   else {
X      tpos1.y = (action == 'h') ? ppos.y-1 : ppos.y+1;
X      tpos2.y = (action == 'h') ? ppos.y-2 : ppos.y+2;
X      tpos1.x = tpos2.x = ppos.x;
X   }
X   tc = map[tpos1.x][tpos1.y];
X   if( (tc == packet) || (tc == save)) {
X      if( ! stop_at_object) {
X         if( map[tpos2.x][tpos2.y] == ground)
X            ret = (tc == save) ? UNSAVE : PUSH;
X         else if( map[tpos2.x][tpos2.y] == store)
X            ret = (tc == save) ? STOREPUSH : SAVE;
X         else ret = 0;
X      }
X      else ret = 0;
X   }
X   else if( tc == ground)
X      ret = MOVE;
X   else if( tc == store)
X      ret = STOREMOVE;
X   else ret = 0;
X   return( ret);
X}
X
Xdomove( moveaction) 
Xregister short moveaction;
X{
X   map[ppos.x][ppos.y] = (map[ppos.x][ppos.y] == player) 
X			       ? ground
X			       : store;
X   switch( moveaction) {
X      case MOVE:      map[tpos1.x][tpos1.y] = player; 	break;
X      case STOREMOVE: map[tpos1.x][tpos1.y] = playerstore; 	break;
X      case PUSH:      map[tpos2.x][tpos2.y] = map[tpos1.x][tpos1.y];
X		      map[tpos1.x][tpos1.y] = player;	
X		      pushes++;						break;
X      case UNSAVE:    map[tpos2.x][tpos2.y] = packet;
X		      map[tpos1.x][tpos1.y] = playerstore;		
X		      pushes++; savepack--;			 	break;
X      case SAVE:      map[tpos2.x][tpos2.y] = save;
X		      map[tpos1.x][tpos1.y] = player;			
X		      savepack++; pushes++;				break;
X      case STOREPUSH: map[tpos2.x][tpos2.y] = save;
X		      map[tpos1.x][tpos1.y] = playerstore;		
X		      pushes++;						break;
X   }
X   moves++;
X   dispmoves(); disppushes(); dispsave();
X   mapchar( map[ppos.x][ppos.y], ppos.x, ppos.y);
X   mapchar( map[tpos1.x][tpos1.y], tpos1.x, tpos1.y);
X   mapchar( map[tpos2.x][tpos2.y], tpos2.x, tpos2.y);
X   redisp_screen();
X   ppos.x = tpos1.x; ppos.y = tpos1.y;
X}
X
Xundomove() {
X
X   map[lastppos.x][lastppos.y] = lppc;
X   map[lasttpos1.x][lasttpos1.y] = ltp1c;
X   map[lasttpos2.x][lasttpos2.y] = ltp2c;
X   ppos.x = lastppos.x; ppos.y = lastppos.y;
X   switch( lastaction) {
X      case MOVE:      moves--;				break;
X      case STOREMOVE: moves--;				break;
X      case PUSH:      moves--; pushes--;		break;
X      case UNSAVE:    moves--; pushes--; savepack++;	break;
X      case SAVE:      moves--; pushes--; savepack--;	break;
X      case STOREPUSH: moves--; pushes--;		break;
X   }
X   dispmoves(); disppushes(); dispsave();
X   mapchar( map[ppos.x][ppos.y], ppos.x, ppos.y);
X   mapchar( map[lasttpos1.x][lasttpos1.y], lasttpos1.x, lasttpos1.y);
X   mapchar( map[lasttpos2.x][lasttpos2.y], lasttpos2.x, lasttpos2.y);
X   redisp_screen();
X}
X
Xtmpsave() {
X
X   register short i, j;
X
X   for( i = 0; i < rows; i++) for( j = 0; j < cols; j++)
X      tmp_map[i][j] = map[i][j];
X   tmp_pushes = pushes;
X   tmp_moves = moves;
X   tmp_savepack = savepack;
X   tmp_ppos.x = ppos.x; tmp_ppos.y = ppos.y;
X}
X
Xtmpreset() {
X
X   register short i, j;
X
X   for( i = 0; i < rows; i++) for( j = 0; j < cols; j++)
X      map[i][j] = tmp_map[i][j];
X   pushes = tmp_pushes;
X   moves = tmp_moves;
X   savepack = tmp_savepack;
X   ppos.x = tmp_ppos.x; ppos.y = tmp_ppos.y;
X}
END_OF_FILE
if test 6948 -ne `wc -c <'play.c'`; then
    echo shar: \"'play.c'\" unpacked with wrong size!
fi
# end of 'play.c'
fi
if test -f 'score.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'score.c'\"
else
echo shar: Extracting \"'score.c'\" \(7077 characters\)
sed "s/^X//" >'score.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <signal.h>
X#include <sys/types.h>
X#include <netinet/in.h>
X#include "sokoban.h"
X
Xextern FILE *fopen();
X
Xextern char  *username;
Xextern short scorelevel, scoremoves, scorepushes;
X
Xstatic short scoreentries;
Xstatic struct {
X   char user[MAXUSERNAME];
X   unsigned short lv, pad1, mv, pad2, ps, pad3;
X} scoretable[MAXSCOREENTRIES];
X
Xstatic FILE *scorefile;
Xstatic long sfdbn;
X
Xshort outputscore() {
X
X   short ret;
X
X   while( creat( LOCKFILE, 0666) < 0);	/* lock the score file */
X   if( (ret = readscore()) == 0)
X      showscore();
X   unlink( LOCKFILE);
X   return( (ret == 0) ? E_ENDGAME : ret);
X}
X
Xshort makenewscore() {
X
X   short ret = 0;
X
X   while( creat( LOCKFILE, 0666) < 0) ;
X   scoreentries = 0;
X#ifdef __MSDOS__
X   if( (scorefile = fopen( SCOREFILE, "wb")) == NULL)
X      ret = E_FOPENSCORE;
X   else {
X	if (fwrite (&scoreentries, 1, sizeof( scoreentries), scorefile) != sizeof(scoreentries))
X	    ret = E_WRITESCORE;
X#else
X   if( (scorefile = fopen( SCOREFILE, "w")) == NULL)
X      ret = E_FOPENSCORE;
X   else {
X      sfdbn = fileno( scorefile);
X      if( write( sfdbn, &scoreentries, 2) != 2) ret = E_WRITESCORE;
X#endif
X      fclose( scorefile);
X   }
X   unlink( LOCKFILE);
X   return( (ret == 0) ? E_ENDGAME : ret);
X}
X
Xshort getuserlevel( lv)
Xshort *lv;
X{
X   short ret = 0, pos;
X
X   while( creat( LOCKFILE, 0666) < 0);
X#ifdef __MSDOS__
X   if( (scorefile = fopen( SCOREFILE, "rb")) == NULL)
X#else
X   if( (scorefile = fopen( SCOREFILE, "r")) == NULL)
X#endif
X      ret = E_FOPENSCORE;
X   else {
X      if( (ret = readscore()) == 0)
X	 *lv = ( (pos = finduser()) > -1) ? scoretable[pos].lv+1 : 1;
X   }
X   unlink( LOCKFILE);
X   return( ret);
X}
X
Xshort score() {
X   
X   short ret;
X
X   while( creat( LOCKFILE, 0666) < 0);	/* lock the score file */
X   if( (ret = readscore()) == 0)
X      if( (ret = makescore()) == 0)
X	 if( (ret = writescore()) == 0)
X	    showscore();
X   unlink( LOCKFILE);
X   return( (ret == 0) ? E_ENDGAME : ret);
X}
X
Xreadscore() {
X
X   short ret = 0;
X   long tmp;
X
X#ifdef __MSDOS__
X   if( (scorefile = fopen( SCOREFILE, "rb")) == NULL)
X      ret = E_FOPENSCORE;
X   else {
X      tmp = sizeof( scoreentries);
X      if( fread( &scoreentries, 1, tmp, scorefile) != tmp) ret = E_READSCORE;
X      else {
X	 tmp = scoreentries * sizeof( scoretable[0]);
X	 if( fread( scoretable, 1, tmp, scorefile) != tmp) ret = E_READSCORE;
X      }
X#else
X   if( (scorefile = fopen( SCOREFILE, "r")) == NULL)
X      ret = E_FOPENSCORE;
X   else {
X      sfdbn = fileno( scorefile);
X      if( read( sfdbn, &scoreentries, 2) != 2) ret = E_READSCORE;
X      else {
X	 scoreentries = ntohs(scoreentries);
X	 tmp = scoreentries * sizeof( scoretable[0]);
X	 if( read( sfdbn, &(scoretable[0]), tmp) != tmp) ret = E_READSCORE;
X
X	/* swap up for little-endian machines */
X	 for(tmp = 0; tmp < scoreentries; tmp++) {
X		scoretable[tmp].lv = ntohs(scoretable[tmp].lv);
X		scoretable[tmp].mv = ntohs(scoretable[tmp].mv);
X		scoretable[tmp].ps = ntohs(scoretable[tmp].ps);
X	 }
X      }
X#endif
X      fclose( scorefile);
X   }
X   return( ret);
X}
X
Xmakescore() {
X
X   short ret = 0, pos, i, build = 1, insert;
X
X   if( (pos = finduser()) > -1) {	/* user already in score file */
X      insert =    (scorelevel > scoretable[pos].lv)
X	       || ( (scorelevel == scoretable[pos].lv) &&
X                    (scoremoves < scoretable[pos].mv)
X		  )
X	       || ( (scorelevel == scoretable[pos].lv) &&
X		    (scoremoves == scoretable[pos].mv) &&
X		    (scorepushes < scoretable[pos].ps)
X		  );
X      if( insert) { 			/* delete existing entry */
X	 for( i = pos; i < scoreentries-1; i++)
X	    cp_entry( i, i+1);
X	 scoreentries--;
X      }
X      else build = 0;
X   }
X   else if( scoreentries == MAXSCOREENTRIES)
X      ret = E_TOMUCHSE;
X   if( (ret == 0) && build) {
X      pos = findpos();			/* find the new score position */
X      if( pos > -1) {			/* score table not empty */
X	 for( i = scoreentries; i > pos; i--)
X	    cp_entry( i, i-1);
X      }
X      else pos = scoreentries;
X
X      strcpy( scoretable[pos].user, username);
X      scoretable[pos].lv = scorelevel;
X      scoretable[pos].mv = scoremoves;
X      scoretable[pos].ps = scorepushes;
X      scoreentries++;
X   }
X   return( ret);
X}
X
Xfinduser() {
X
X   short i, found = 0;
X
X   for( i = 0; (i < scoreentries) && (! found); i++)
X      found = (strcmp( scoretable[i].user, username) == 0);
X   return( (found) ? i-1 : -1);
X}
X
Xfindpos() {
X 
X   short i, found = 0;
X
X   for( i = 0; (i < scoreentries) && (! found); i++)
X      found =    (scorelevel > scoretable[i].lv)
X	      || ( (scorelevel == scoretable[i].lv) &&
X                   (scoremoves < scoretable[i].mv)
X		 )
X	      || ( (scorelevel == scoretable[i].lv) &&
X		   (scoremoves == scoretable[i].mv) &&
X		   (scorepushes < scoretable[i].ps)
X		 );
X   return( (found) ? i-1 : -1);
X}
X
Xwritescore() {
X
X   short ret = 0;
X   long tmp;
X
X#ifdef __MSDOS__
X   if( (scorefile = fopen( SCOREFILE, "wb")) == NULL)
X      ret = E_FOPENSCORE;
X   else {
X      tmp = sizeof( scoreentries);
X      if( fwrite( &scoreentries, 1, tmp, scorefile) != tmp) ret = E_WRITESCORE;
X      else {
X	 tmp = scoreentries * sizeof( scoretable[0]);
X	 if( fwrite( scoretable, 1, tmp, scorefile) != tmp) ret = E_WRITESCORE;
X      }
X#else
X   if( (scorefile = fopen( SCOREFILE, "w")) == NULL)
X      ret = E_FOPENSCORE;
X   else {
X      sfdbn = fileno( scorefile);
X      scoreentries = htons(scoreentries);
X      if( write( sfdbn, &scoreentries, 2) != 2) ret = E_WRITESCORE;
X      else {
X         scoreentries = ntohs(scoreentries);
X
X	/* swap around for little-endian machines */
X	 for(tmp = 0; tmp < scoreentries; tmp++) {
X		scoretable[tmp].lv = htons(scoretable[tmp].lv);
X		scoretable[tmp].mv = htons(scoretable[tmp].mv);
X		scoretable[tmp].ps = htons(scoretable[tmp].ps);
X	 }		
X	 tmp = scoreentries * sizeof( scoretable[0]);
X	 if( write( sfdbn, &(scoretable[0]), tmp) != tmp) ret = E_WRITESCORE;
X
X	 /* and swap back for the rest of the run ... */
X	 for(tmp = 0; tmp < scoreentries; tmp++) {
X		scoretable[tmp].lv = ntohs(scoretable[tmp].lv);
X		scoretable[tmp].mv = ntohs(scoretable[tmp].mv);
X		scoretable[tmp].ps = ntohs(scoretable[tmp].ps);
X	 }		
X
X      }
X#endif
X      fclose( scorefile);
X   }
X   return( ret);
X}
X
Xshowscore() {
X
X   register short lastlv = 0, lastmv = 0, lastps = 0, i;
X
X   fprintf( stdout, "Rank        User     Level     Moves    Pushes\n");
X   fprintf( stdout, "==============================================\n");
X   for( i = 0; i < scoreentries; i++) {
X      if( (scoretable[i].lv == lastlv)&& 
X	  (scoretable[i].mv == lastmv) && 
X	  (scoretable[i].ps == lastps))
X	 fprintf( stdout, "      ");
X      else {
X         lastlv = scoretable[i].lv;
X         lastmv = scoretable[i].mv;
X         lastps = scoretable[i].ps;
X         fprintf( stdout, "%4d  ", i+1);
X      }
X      fprintf( stdout, "%10s  %8d  %8d  %8d\n", scoretable[i].user, 
X		scoretable[i].lv, scoretable[i].mv, scoretable[i].ps);
X   }
X}
X
Xcp_entry( i1, i2)
Xregister short i1, i2;
X{
X   strcpy( scoretable[i1].user, scoretable[i2].user);
X   scoretable[i1].lv = scoretable[i2].lv;
X   scoretable[i1].mv = scoretable[i2].mv;
X   scoretable[i1].ps = scoretable[i2].ps;
X}
END_OF_FILE
if test 7077 -ne `wc -c <'score.c'`; then
    echo shar: \"'score.c'\" unpacked with wrong size!
fi
# end of 'score.c'
fi
if test ! -d 'screens' ; then
    echo shar: Creating directory \"'screens'\"
    mkdir 'screens'
fi
if test -f 'screens/screen.10' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screens/screen.10'\"
else
echo shar: Extracting \"'screens/screen.10'\" \(320 characters\)
sed "s/^X//" >'screens/screen.10' <<'END_OF_FILE'
X ###  #############
X##@####       #   #
X# $$   $$  $ $ ...#
X#  $$$#    $  #...#
X# $   # $$ $$ #...#
X###   #  $    #...#
X#     # $ $ $ #...#
X#    ###### ###...#
X## #  #  $ $  #...#
X#  ## # $$ $ $##..#
X# ..# #  $      #.#
X# ..# # $$$ $$$ #.#
X##### #       # #.#
X    # ######### #.#
X    #           #.#
X    ###############
END_OF_FILE
if test 320 -ne `wc -c <'screens/screen.10'`; then
    echo shar: \"'screens/screen.10'\" unpacked with wrong size!
fi
# end of 'screens/screen.10'
fi
if test -f 'sok.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sok.c'\"
else
echo shar: Extracting \"'sok.c'\" \(6342 characters\)
sed "s/^X//" >'sok.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <pwd.h>
X#include "sokoban.h"
X
Xextern char    *strrchr(), *getlogin(), *getpass();
Xextern short    readscreen(), play(), outputscore(), getuserlevel(),
X                makenewscore(), restoregame(), score();
X
Xshort           scoring = 1;
Xshort           level, packets, savepack, moves, pushes, rows, cols;
Xshort           scorelevel, scoremoves, scorepushes;
Xchar            map[MAXROW + 1][MAXCOL + 1];
XPOS             ppos;
Xchar           *username, *prgname;
X
Xstatic short    optshowscore = 0, optmakescore = 0, optrestore = 0, optlevel = 0;
Xstatic short    superuser = 0;
X
Xchar            bitfilepath[1024];
Xstatic short    userlevel;
Xint		optbitmap = 0, optwalls = 1;
X
Xmain(argc, argv)
X    short           argc;
X    char           *argv[];
X{
X    short           ret, ret2;
X    struct passwd  *pwd, *getpwuid();
X
X#ifdef VICE
X    Authenticate();
X#endif
X
X    scorelevel = 0;
X    moves = pushes = packets = savepack = 0;
X    if ((prgname = strrchr(argv[0], '/')) == NULL)
X	prgname = argv[0];
X    else
X	prgname++;
X    if ((pwd = getpwuid(getuid())) == NULL)
X	ret = E_NOUSER;
X    else {
X	username = pwd->pw_name;
X	superuser = (strcmp(username, SUPERUSER) == 0);
X	if ((ret = checkcmdline(argc, argv)) == 0) {
X	    if (optshowscore)
X		ret = outputscore();
X	    else if (optmakescore) {
X		if (superuser) {
X		    if ((ret = getpassword()) == 0)
X			ret = makenewscore();
X		} else
X		    ret = E_NOSUPER;
X	    } else if (optrestore) {
X		ret = restoregame();
X	    } else if ((ret = getuserlevel(&userlevel)) == 0) {
X		if (optlevel > 0) {
X		    if (superuser) {
X			level = optlevel;
X			scoring = 0;
X		    } else if (userlevel < optlevel)
X			ret = E_LEVELTOOHIGH;
X		    else
X			level = optlevel;
X		} else
X		    level = userlevel;
X	    }
X	}
X    }
X    if (ret == 0) {
X	ret = gameloop();
X	shutdown_screen();
X    }
X    errmess(ret);
X    if (scorelevel && scoring) {
X	ret2 = score();
X	errmess(ret2);
X    }
X    exit(ret);
X}
X
Xcheckcmdline(argc, argv)
X    short           argc;
X    char           *argv[];
X{
X    short           ret = 0;
X    int             option = 0;
X    int             tempwalls = 0;
X
X    for (option = 1; option < argc; option++) {
X	if (argv[option][0] == '-') {
X	    switch (argv[option][1]) {
X	    case 's':
X		if (optmakescore || optrestore || optlevel || optbitmap)
X		    ret = E_USAGE;
X		optshowscore = 1;
X		break;
X	    case 'c':
X		if (optshowscore || optrestore || optlevel || optbitmap)
X		    ret = E_USAGE;
X		optmakescore = 1;
X		break;
X	    case 'r':
X		if (optshowscore || optmakescore || optlevel || optbitmap)
X		    ret = E_USAGE;
X		optrestore = 1;
X		break;
X	    case 'b':
X		if (optshowscore || optmakescore || optrestore)
X		    ret = E_USAGE;
X		if (argv[option][2]) {
X		    strcpy(bitfilepath, argv[option] + 2);
X		} else {
X		    option++;
X		    strcpy(bitfilepath, argv[option]);
X		}
X		optbitmap = 1;
X		break;
X	    case 'w':
X		if (optshowscore || optmakescore || optrestore)
X		    ret = E_USAGE;
X		tempwalls = 1;
X		break;
X	    default:
X		if (optshowscore || optmakescore || optrestore)
X		    ret = E_USAGE;
X		if ((optlevel = atoi(argv[option] + 1)) == 0)
X		    ret = E_USAGE;
X		break;
X	    }
X	} else {
X	    ret = E_USAGE;
X	}
X    }
X    if (optbitmap && !tempwalls)
X	optwalls = 0;
X    return (ret);
X}
X
Xgameloop()
X{
X
X    short           ret = 0;
X
X    switch (init_screen()) {
X    case E_NOBITMAP:
X	return E_NOBITMAP;
X	break;
X
X    case E_NODISPLAY:
X	exit(1);
X	break;
X
X    default:
X	break;
X    }
X    if (!optrestore)
X	ret = readscreen();
X    while (ret == 0) {
X	if ((ret = play()) == 0) {
X	    level++;
X	    moves = pushes = packets = savepack = 0;
X	    ret = readscreen();
X	}
X    }
X    return (ret);
X}
X
Xgetpassword()
X{
X
X    return ((strcmp(getpass("Password: "), PASSWORD) == 0) ? 0 : E_ILLPASSWORD);
X}
X
Xchar           *message[] =
X{
X    "illegal error number",
X    "cannot open screen file",
X    "more than one player position in screen file",
X    "illegal char in screen file",
X    "no player position in screenfile",
X    "too much rows in screen file",
X    "too much columns in screenfile",
X    "quit the game",
X    NULL,			/* errmessage deleted */
X    "cannot get your username",
X    "cannot open savefile",
X    "error writing to savefile",
X    "cannot stat savefile",
X    "error reading savefile",
X    "cannot restore, your savefile has been altered",
X    "game saved",
X    "too much users in score table",
X    "cannot open score file",
X    "error reading scorefile",
X    "error writing scorefile",
X    "illegal command line syntax",
X    "illegal password",
X    "level number too big in command line",
X    "only superuser is allowed to make a new score table",
X    "cannot find file to restore",
X    "cannot find bitmap file",
X    "cannot open display",
X    "cannot load font",
X    "cannot allocate string memory",
X    "could not load requested color"
X};
X
Xerrmess(ret)
X    register short  ret;
X{
X    if (ret != E_ENDGAME) {
X	fprintf(stderr, "%s: ", prgname);
X	switch (ret) {
X	case E_FOPENSCREEN:
X	case E_PLAYPOS1:
X	case E_ILLCHAR:
X	case E_PLAYPOS2:
X	case E_TOMUCHROWS:
X	case E_TOMUCHCOLS:
X	case E_ENDGAME:
X	case E_NOUSER:
X	case E_FOPENSAVE:
X	case E_WRITESAVE:
X	case E_STATSAVE:
X	case E_READSAVE:
X	case E_ALTERSAVE:
X	case E_SAVED:
X	case E_TOMUCHSE:
X	case E_FOPENSCORE:
X	case E_READSCORE:
X	case E_WRITESCORE:
X	case E_USAGE:
X	case E_ILLPASSWORD:
X	case E_LEVELTOOHIGH:
X	case E_NOSUPER:
X	case E_NOSAVEFILE:
X	case E_NOBITMAP:
X	case E_NODISPLAY:
X	case E_NOFONT:
X	case E_NOMEM:
X	case E_NOCOLOR:
X	    fprintf(stderr, "%s\n", message[ret]);
X	    break;
X	default:
X	    fprintf(stderr, "%s\n", message[0]);
X	    break;
X	}
X	if (ret == E_USAGE)
X	    usage();
X    }
X}
X
Xstatic char    *usagestr[] =
X{
X    "     -c             :    create new score table (superuser only)\n",
X    "     -r             :    restore saved game\n",
X    "     -s             :    show score table\n",
X    "     -<nn>          :    play this level (<nn> must be greater 0)\n",
X    "     -b <bitmap_dir>:    use alternate bitmaps. See ingame help.\n",
X    "                         implies !-w\n",
X  "     -w             :    use fancy walls (default unless you use your\n",
X    "                         own set of bitmaps)\n",
X    NULL
X};
X
Xusage()
X{
X
X    register short  i;
X
X    fprintf(stderr, "Usage: %s [-{s|c|r|<nn>|b <bitmap_dir>|w|m}]\n\n", prgname);
X    for (i = 0; usagestr[i] != NULL; i++)
X	fprintf(stderr, "%s", usagestr[i]);
X}
END_OF_FILE
if test 6342 -ne `wc -c <'sok.c'`; then
    echo shar: \"'sok.c'\" unpacked with wrong size!
fi
# end of 'sok.c'
fi
if test -f 'xdisp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdisp.c'\"
else
echo shar: Extracting \"'xdisp.c'\" \(14338 characters\)
sed "s/^X//" >'xdisp.c' <<'END_OF_FILE'
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/keysym.h>
X#include <stdio.h>
X#include "sokoban.h"
X#include "help.h"
X
X#define PRG_NAME "xsokoban"
X
X#define BIT_H 30 
X#define BIT_W 30
X
X#define FONT "9x15"
X#define DEF_CURSOR 102
X
X#define HELPLINE ((BIT_H * MAXROW) + 30)
X#define STATUSLINE ((BIT_H * MAXROW) + 5)
X
X#define HELP_H (BIT_H*MAXROW)
X#define HELP_W (BIT_W*MAXCOL)
X
Xextern short rows, cols, level, moves, pushes, packets, savepack;
Xextern char  map[MAXROW+1][MAXCOL+1];
Xextern char bitfilepath[1024];
Xextern int optbitmap, optwalls;
X
Xchar *wallname[] =
X   { "lonewall.xbm",
X     "southwall.xbm",
X     "westwall.xbm",
X     "llcornerwall.xbm",
X     "northwall.xbm",
X     "vertiwall.xbm",
X     "ulcornerwall.xbm",
X     "west_twall.xbm",
X     "eastwall.xbm",
X     "lrcornerwall.xbm",
X     "horizwall.xbm",
X     "south_twall.xbm",
X     "urcornerwall.xbm",
X     "east_twall.xbm",
X     "north_twall.xbm",
X     "centerwall.xbm" };
X
XPixmap goal, man, object, treasure, swalls[16], blank, work, help[2];
XPixmap floor, saveman;
XDisplay *display;
XWindow win;
Xint screen;
XGC gc, rev, depth_rev;
XXFontStruct *font_info;
Xunsigned int width, height, depth;
Xchar buf[100];
Xint display_alloc = 0, font_alloc = 0, gc_alloc = 0, pix_alloc = 0;
XColormap cmap;
XCursor this_curs;
XXColor foreg, backg, curs, bordr;
X
Xint hlpscrn = -1;
X
Xvoid get_int(res, val, def_val)
Xchar *res;
Xint *val, def_val;
X{
X  char *string;
X
X  string = XGetDefault(display, PRG_NAME, res);
X  if(string)
X    *val = atoi(string);
X  else
X    *val = def_val;
X}
X
Xvoid get_string(res, val, def_val)
Xchar *res;
Xchar **val;
Xchar *def_val;
X{
X  char *string;
X
X  string = XGetDefault(display, PRG_NAME, res);
X  if(string) {
X    *val = string;
X  } else {
X    *val = def_val;
X  }
X}
X
Xint get_color(res, val, def_val)
Xchar *res;
XXColor *val;
Xchar *def_val;
X{
X  char *string;
X  int found = False;
X
X  string = XGetDefault(display, PRG_NAME, res);
X  if(string)
X    if(XParseColor(display, cmap, string, val))
X        found = True;
X  if(!found)
X    if(XParseColor(display, cmap, def_val, val))
X        found = True;
X  if(!found)
X    return 0;
X  if(!XAllocColor(display, cmap, val))
X    return 0;
X  return 1;
X}
X
Xint init_screen()
X{
X  int i;
X  char *win_name = "XSokoban";
X  char *icon_name = "XSokoban";
X  XSizeHints size_hints;
X  XWMHints wm_hints;
X  XSetWindowAttributes win_attr;
X  XClassHint classhint;
X  XGCValues revvals, values;
X  XTextProperty Win_Name, Icon_Name;
X  char *font_name;
X  char *string;
X  int temp, tempwalls = 1;
X
X  if((display = XOpenDisplay(NULL)) == NULL) {
X    return E_NODISPLAY;
X  }
X  display_alloc = 1;
X
X  get_string("fontname", &font_name, FONT);
X  if((font_info = XLoadQueryFont(display, font_name)) == NULL) {
X    return E_NOFONT;
X  }
X  font_alloc = 1;
X
X  screen = DefaultScreen(display);
X  cmap = DefaultColormap(display, screen);
X  depth = DefaultDepth(display, screen);
X
X  if(!get_color("foreground", &foreg, "white"))
X    return E_NOCOLOR;
X  if(!get_color("background", &backg, "black"))
X    return E_NOCOLOR;
X  if(!get_color("border", &bordr, "white"))
X    return E_NOCOLOR;
X  if(!get_color("cursor", &curs, "white"))
X    return E_NOCOLOR;
X  if(!optbitmap) {
X    get_string("bitmaps", &string, NULL);
X    if(string) {
X      strcpy(bitfilepath, string);
X      optbitmap = 1;
X      tempwalls = 0;
X    }
X  }
X
X  if(!optwalls || !tempwalls) {
X    get_int("fancyWalls", &optwalls, tempwalls);
X  }
X
X  width = MAXCOL * BIT_W;
X  height = MAXROW * BIT_H + 50;
X
X  size_hints.min_width = size_hints.width = size_hints.max_width = width;
X  size_hints.min_height = size_hints.height = size_hints.max_height = height;
X  size_hints.x = size_hints.y = 0;
X
X  size_hints.flags = (PSize | PPosition | PMinSize | PMaxSize);
X
X  wm_hints.initial_state = NormalState;
X  wm_hints.input = True;
X
X  wm_hints.flags = (StateHint | InputHint);
X
X  classhint.res_class = classhint.res_name = PRG_NAME;
X
X  this_curs = XCreateFontCursor(display, DEF_CURSOR);
X  XRecolorCursor(display, this_curs, &curs, &backg);
X
X  win_attr.background_pixel = backg.pixel;
X  win_attr.border_pixel = bordr.pixel;
X  win_attr.backing_store = Always;
X  win_attr.event_mask = (KeyPressMask | ExposureMask);
X  win_attr.cursor = this_curs;
X
X  if(XStringListToTextProperty(&win_name, 1, &Win_Name) == NULL) {
X    return E_NOMEM;
X  }
X
X  if(XStringListToTextProperty(&icon_name, 1, &Icon_Name) == NULL) {
X    return E_NOMEM;
X  }
X
X  win = XCreateWindow(display, RootWindow(display, screen), 0, 0, width,
X		      height, 4, CopyFromParent, InputOutput, CopyFromParent,
X		      (CWBackPixel | CWBorderPixel | CWBackingStore |
X		       CWEventMask | CWCursor), &win_attr);
X
X  XSetWMNormalHints(display, win, &size_hints);
X  XSetWMHints(display, win, &wm_hints);
X  XSetClassHint(display, win, &classhint);
X  XSetWMName(display, win, &Win_Name);
X  XSetWMIconName(display, win, &Icon_Name);
X
X  for(i = 0; i < 2; i++) {
X    help[i] = XCreatePixmap(display, win, HELP_W, HELP_H, depth);
X  }
X  blank = XCreatePixmap(display, win, BIT_W, BIT_H, 1);
X  work = XCreatePixmap(display, win, width, height, depth);
X
X  values.foreground = foreg.pixel;
X  revvals.foreground = backg.pixel;
X  values.background = backg.pixel;
X  revvals.background = foreg.pixel;
X  values.function  = revvals.function = GXcopy;
X  values.font = revvals.font = font_info->fid;
X
X  gc = XCreateGC(display, win, (GCFunction | GCBackground | GCForeground |
X				GCFont), &values);
X  rev = XCreateGC(display, blank, (GCFunction | GCBackground | GCForeground |
X				   GCFont), &revvals);
X  depth_rev = XCreateGC(display, win, (GCFunction | GCBackground |
X				       GCForeground | GCFont), &revvals);
X
X  gc_alloc = 1;
X
X  if(load_bitmaps() == E_NOBITMAP) return E_NOBITMAP;
X  make_help_windows();
X  pix_alloc = 1;
X
X  XFillRectangle(display, blank, rev, 0, 0, BIT_W, BIT_H);
X
X  clearscreen();
X
X  XMapWindow(display, win);
X
X  redisp_screen();
X
X  return 0;
X}
X
Xload_one_bitmap(fname, altname, this_pix)
Xchar *fname;
Xchar *altname;
XPixmap *this_pix;
X{
X  unsigned int dummy1, dummy2;
X  int dummy3, dummy4;
X  int load_fail;
X  if(optbitmap) {
X    chdir(bitfilepath);
X    if(XReadBitmapFile(display, win, fname, &dummy1, &dummy2, this_pix,
X		       &dummy3, &dummy4) != BitmapSuccess) {
X      if(altname && *altname) {
X	printf("Unable to load %s/%s, trying alternate %s/%s\n",
X	       bitfilepath, fname, bitfilepath, altname);
X	if(XReadBitmapFile(display, win, altname, &dummy1, &dummy2, this_pix,
X			   &dummy3, &dummy4) != BitmapSuccess) {
X	  load_fail = 1;
X	  printf("Unable to load alternate %s/%s, trying defaults\n",
X		 bitfilepath, altname);
X        } else {
X	  return 0;
X	}
X      } else {
X	printf("Unable to load %s/%s, trying defaults.\n", bitfilepath, fname);
X      }
X    } else
X      return 0;
X  }
X  chdir(BITPATH);
X  if(!optbitmap || load_fail) {
X    if(XReadBitmapFile(display, win, fname, &dummy1, &dummy2, this_pix,
X		       &dummy3, &dummy4) != BitmapSuccess) {
X      if(altname && *altname) {
X	printf("Unable to load default %s, trying alternate %s\n",
X	       fname, altname);
X        if(XReadBitmapFile(display, win, altname, &dummy1, &dummy2, this_pix,
X			   &dummy3, &dummy4) != BitmapSuccess) {
X	  printf("Unable to load alternate %s!\n", altname);
X	  return 1;
X        } else
X	  return 0;
X      } else {
X	printf("Unable to load default %s!\n", fname);
X	return 1;
X      }
X    } else
X      return 0;
X  }
X}
X
Xint load_bitmaps()
X{
X  register int i;
X  int ret = 0;
X
X  if(load_one_bitmap("man.xbm", NULL, &man)) ret = E_NOBITMAP;
X  if(load_one_bitmap("saveman.xbm", "man.xbm", &saveman)) ret = E_NOBITMAP;
X  if(load_one_bitmap("object.xbm", NULL, &object)) ret = E_NOBITMAP;
X  if(load_one_bitmap("treasure.xbm", NULL, &treasure)) ret = E_NOBITMAP;
X  if(load_one_bitmap("goal.xbm", NULL, &goal)) ret = E_NOBITMAP;
X  if(load_one_bitmap("floor.xbm", NULL, &floor)) ret = E_NOBITMAP;
X
X  if(optwalls) {
X    for(i = 0; i < 16; i++) {
X      if(load_one_bitmap(wallname[i], "wall.xbm", &swalls[i])) ret = E_NOBITMAP;
X    }
X  } else {
X    if(load_one_bitmap("wall.xbm", NULL, &swalls[0])) ret = E_NOBITMAP;
X  }
X  return ret;
X}
X
Xmake_help_windows()
X{
X  int i;
X  char *title =
X     "    Sokoban  --  X version by Joseph L. Traub  --  Help page %d";
X  char *next =
X     "     Press Enter to exit  --   Any other key for next page.";
X
X  for (i = 0; i < 2; i++) {
X    XFillRectangle(display, help[i], depth_rev, 0, 0, HELP_W, HELP_H);
X    sprintf(buf, title, (i+1));
X    XDrawImageString(display, help[i], gc, 0, 11, buf, strlen(buf));
X    XDrawLine(display, help[i], gc, 0, 17, HELP_W, 17);
X    XDrawLine(display, help[i], gc, 0, HELP_H-20, HELP_W, HELP_H-20);
X    XDrawImageString(display, help[i], gc, 2, HELP_H-7, next, strlen(next));
X  }
X  for(i = 0; help_pages[i].textline != NULL; i++) {
X    XDrawImageString(display,help[help_pages[i].page], gc,
X		     help_pages[i].xpos * (font_info->max_bounds.width), 
X		     help_pages[i].ypos, help_pages[i].textline,
X		     strlen(help_pages[i].textline));
X  }
X  XCopyPlane(display, man, help[0], gc, 0, 0, BIT_W, BIT_H, 180, 360, 1);
X  XCopyPlane(display, goal, help[0], gc, 0, 0, BIT_W, BIT_H, 270, 360, 1);
X  XCopyPlane(display, swalls[0], help[0], gc, 0, 0, BIT_W, BIT_H, 369, 360, 1);
X  XCopyPlane(display, object, help[0], gc, 0, 0, BIT_W, BIT_H, 477, 360, 1);
X  XCopyPlane(display, treasure, help[0], gc, 0, 0, BIT_W, BIT_H, 270, 400, 1);
X  XCopyPlane(display, saveman, help[0], gc, 0, 0, BIT_W, BIT_H, 477, 400, 1);
X}
X
Xshutdown_screen() {
X  int i;
X
X  if(font_alloc) {
X    XFreeFont(display, font_info);
X  }
X  if(gc_alloc) {
X    XFreeGC(display, gc);
X    XFreeGC(display, rev);
X    XFreeGC(display, depth_rev);
X  }
X  if(pix_alloc) {
X    XFreePixmap(display, work);
X    XFreePixmap(display, man);
X    XFreePixmap(display, saveman);
X    XFreePixmap(display, goal);
X    XFreePixmap(display, treasure);
X    XFreePixmap(display, object);
X    XFreePixmap(display, floor);
X    for(i = 0; i < 16; i++) {
X      if(i < 2)
X        XFreePixmap(display, help[i]);
X      if(i == 0 || optwalls)
X        XFreePixmap(display, swalls[i]);
X    }
X    XFreePixmap(display, blank);
X  }
X  if(display_alloc)
X    XCloseDisplay(display);
X}
X
Xclearscreen() {
X  int i,j;
X
X  XFillRectangle(display, work, depth_rev, 0, 0, width, height);
X  for(i = 0; i < MAXROW; i++)
X    for(j = 0; j < MAXCOL; j++)
X      XCopyPlane(display, floor, work, gc, 0, 0, BIT_W, BIT_H, j*BIT_W,
X	        i*BIT_H, 1);
X  XDrawLine(display, work, gc, 0, BIT_H*MAXROW, BIT_W*MAXCOL, BIT_H*MAXROW);
X}
X
Xchar event_loop()
X{
X  XEvent report;
X  char buf[1];
X  int bufsiz = 1;
X  KeySym keysym;
X  XComposeStatus compose;
X  int cntrl, shiftd;
X
X  while(1) {
X    XNextEvent(display, &report);
X    switch (report.type) {
X      case Expose:
X	redisp_screen();
X	break;
X      case KeyPress:
X	buf[0] = NULL;
X	(void) XLookupString(&report.xkey, buf, bufsiz, &keysym, &compose);
X	cntrl = report.xkey.state & ControlMask;
X	shiftd = report.xkey.state & ShiftMask;
X	if(keysym == XK_Left) {
X	  if (cntrl)
X	    buf[0] = '\010';
X	  else if (shiftd)
X	    buf[0] = 'H';
X          else
X	    buf[0] = 'h';
X	}
X	if(keysym == XK_Right) {
X	  if (cntrl)
X	    buf[0] = '\014';
X	  else if (shiftd)
X	    buf[0] = 'L';
X          else
X	    buf[0] = 'l';
X	}
X	if(keysym == XK_Up) {
X	  if (cntrl)
X	    buf[0] = '\013';
X	  else if (shiftd)
X	    buf[0] = 'K';
X          else
X	    buf[0] = 'k';
X	}
X	if(keysym == XK_Down) {
X	  if (cntrl)
X	    buf[0] = '\012';
X	  else if (shiftd)
X	    buf[0] = 'J';
X          else
X	    buf[0] = 'j';
X	}
X	if(*buf)
X	  return buf[0];
X	break;
X      default:
X	break;
X    }
X  }
X}
X
Xint redisp_screen() {
X  if(hlpscrn == -1)
X    XCopyArea(display, work, win, gc, 0, 0, width, height, 0, 0);
X  else {
X    XCopyArea(display, help[hlpscrn], win, gc, 0, 0, HELP_W, HELP_H, 0, 0);
X  }
X  XFlush(display);
X}
X
Xint showscreen() {
X  int mapchar(); 
X  register short i, j;
X
X  for(i = 0; i < rows; i++)
X    for(j = 0; j < cols && map[i][j] != '\0'; j++)
X      mapchar(map[i][j], i, j);
X
X  displevel();
X  disppackets();
X  dispsave();
X  dispmoves();
X  disppushes();
X  disphelp();
X  redisp_screen();
X}
X
Xint mapchar(c, i, j)
Xchar c;
Xregister short i, j;
X{
X  Pixmap this, get_obj_adr();
X  register short offset_row, offset_col;
X
X  offset_col = BIT_W * (((MAXCOL - cols) / 2) + j);
X  offset_row = BIT_H * (((MAXROW - rows) / 2) + i);
X
X  this = get_obj_adr(i, j, c);
X
X
X  XCopyPlane(display, this, work, gc, 0, 0, BIT_W, BIT_H, offset_col,
X	    offset_row, 1);
X}
X
XPixmap get_obj_adr(i, j, c)
Xregister short i, j;
Xchar c;
X{
X  switch (c) {
X    case player:
X      return man;
X    case playerstore:
X      return saveman;
X    case store:
X      return goal;
X    case save:
X      return treasure;
X    case packet:
X      return object;
X    case wall:
X      if(optwalls)
X	return swalls[pickwall(i,j)];
X      else
X	return swalls[0];
X    case ground:
X      return floor;
X    default:
X      return blank;
X  }
X}
X
Xpickwall(i, j)
Xint i, j;
X{
X   int ret = 0;
X
X   if(i > 0 && map[i-1][j] == wall)
X     ret += 1;
X   if(i < rows && map[i+1][j] == wall)
X     ret += 4;
X   if(j < cols && map[i][j+1] == wall)
X     ret += 2;
X   if (j > 0 && map[i][j-1] == wall)
X     ret += 8;
X   return ret;
X}
X
Xdraw_string(x, y, text)
Xint x, y;
Xchar *text;
X{
X  int x_offset, y_offset;
X
X  x_offset = x * font_info->max_bounds.width;
X  y_offset = y + font_info->ascent;
X
X  XDrawImageString(display, work, gc, x_offset, y_offset, text, strlen(text));
X}
X
Xclear_string(x, y, len)
Xint x, y, len;
X{
X  int i;
X
X  for(i = 0; i < len; i++)
X    buf[i] = ' ';
X
X  buf[len] = '\0';
X  draw_string(x, y, buf);
X}
X
Xdisplevel()
X{
X   sprintf(buf, "Level: %3d", level);
X   draw_string(0, STATUSLINE, buf);
X}
X
Xdisppackets()
X{
X   sprintf(buf, "Packets: %3d", packets);
X   draw_string(12, STATUSLINE, buf);
X}
X
Xdispsave()
X{
X  sprintf(buf, "Saved: %3d", savepack);
X  draw_string(26, STATUSLINE, buf);
X}
X
Xdispmoves()
X{
X  sprintf(buf, "Moves: %5d", moves);
X  draw_string(38, STATUSLINE, buf);
X}
X
Xdisppushes()
X{
X  sprintf(buf, "Pushes: %3d", pushes);
X  draw_string(52, STATUSLINE, buf);
X}
X
Xdisphelp()
X{
X  draw_string(0, HELPLINE, "Press ? for help.");
X}
X
Xshowhelp()
X{
X  int i = 0;
X  char c;
X  
X  hlpscrn = 0;
X  XCopyArea(display, help[i], win, gc, 0, 0, HELP_W, HELP_H, 0, 0);
X  XFlush(display);
X  while(c = event_loop()) {
X    switch(c) {
X      case '\015':
X	hlpscrn = -1;
X	return;
X      default:
X	i = (i+1)%2;
X	hlpscrn = i;
X	XCopyArea(display, help[i], win, gc, 0, 0, HELP_W, HELP_H, 0, 0);
X	XFlush(display);
X    }
X  }
X}
X
Xhelpmessage()
X{
X  XBell(display,0);
X  redisp_screen();
X}
END_OF_FILE
if test 14338 -ne `wc -c <'xdisp.c'`; then
    echo shar: \"'xdisp.c'\" unpacked with wrong size!
fi
# end of 'xdisp.c'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
