Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i010:  xmake5 - connect five-in-a-row game, Part01/03
Message-ID: <2160@masterCNA.TEK.COM>
Date: 13 Dec 91 22:20:37 GMT
Sender: news@masterCNA.TEK.COM
Lines: 1552
Approved: billr@saab.CNA.TEK.COM

Submitted-by: hsiehch@SPUNKY.CS.NYU.EDU (Chih-Hung Hsieh)
Posting-number: Volume 13, Issue 10
Archive-name: xmake5/Part01
Environment: C++, X11, curses

[This requires a C++ compiler to build and includes both an X and curses
 interface.  -br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  README MANIFEST cmake5.C initbd.C xmake5.c
# Wrapped by billr@saab on Fri Dec 13 14:14:56 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(2786 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XX11 Based Make5 / Version 1.1
X
XMake5 is an interesting and challenging game.  It is also
Xcalled 5-in-a-row or Go-Moku in other programs.  Rules of 
Xthis game and other details are available in the on-line 
XHELP, the file xmake5.doc, and the man page xmake5.6.
X
XHow to Install:
X---------------
X
XThis program has been tested on SUN4 and SUN3 with X11/R4.
XA simple Makefile is provided to create the executable 
Xfiles xmake5 and cmake5.  
X
X"xmake5" uses the Athena widgets and "cmake5" uses the
XUNIX curses library.  They both require a C++ compiler.
XYou may use GNU C and C++ compilers if it is feasible.
X
XTo make the executable files:
X
X(1) Change the directory and file names in the Makefile:
X        BINDIR:         where to put the executable files
X        SCOREDIR:       where to put the high score files
X        MANDIR:         where to put the man pages
X        SCORE_F:        the high score file
X        LOCK_F:         the locker for the high score file
X        MAILER:         used by cmake5 only
X
X(2) Type "make" to make "xmake5", "cmake5", and the initial
X    high score file.
X
X(3) Type "make install" to install "xmake5" and "cmake5"
X    in the BINDIR, and to copy "xmake5.6" and "cmake5.6"
X    to the MANDIR.
X
XIn XMake5.ad you can find the X resources used by xmake5.
XThe defaults listed in XMake5.ad could be modified for your
Xcustomized X environment.  Like all X application default files,
Xyou may put your own XMake5 in your X application default 
Xdirectory or merge it into your X resource database using the
Xfollowing command:  "xrdb -merge XMake5".
X
X                                               November 28, 1991
X
XAuthor:  Chih-Hung Hsieh  (pronounce as Chi Hong Shay)
X
XE-mail:  hsiehch@cs.nyu.edu
X
X
X        Hsieh                   Chih                    Hung    
X------------------------ ------------------------ ------------------------
X ,,,       ||'      ||'             ||'           ,,,,,,,,,|,     ||,
X  '||    ,,|,,,|    ||              ||        ,,          ||'     ||
X,,,,|,|, ||   ||    ||   '''''''''''||'''''''''''         ||      ||
X         ||'''|| ,,,||,|            ||             |,,,,,,||     ,|'
X ,,,,|,  ||,,,||    ||              ||      ,,     ||     ''     ||
X         ||   ||,,  ||     ''''''''''''''''''''    ||            ||
X ''''''  || ,,||'   ||             ,,              ||,,,,,,|,   ||
X ,     '||'' ,|| |  ||      ,  ||'  '|,    ,,      ''     ||'   |'   ',
X ||''||    ,|'||  | ||      |  ||    ''     '|,           ||   |'     '|
X ||  || ,,''  ||    ||    ,|'  ||         |  '||         ,|'  ,'      ,||
X ||  ||       ||    ||   ,||   ||         |,  ||'       ,|' ,,|,,,|''' '||
X ||''''    ''||' ''||'   ''    '|||||||||||'       '''|||'   ''''       ||
X------------------------ ------------------------ ------------------------
END_OF_FILE
if test 2786 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(796 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X COPYRIGHT                  3	
X MANIFEST                   1	This shipping list
X Makefile                   2	
X README                     1	
X bdconst.h                  2	
X board.xbm                  3	
X cmake5.6                   3	
X cmake5.C                   1	
X debug.inc                  2	
X drawing.c                  2	
X helptext.C                 2	
X initbd.C                   1	
X line_val.inc               3	
X make5.C                    2	
X make5.xbm                  2	
X printhelp.c                3	
X record.c                   2	
X select.C                   2	
X xmake5.6                   2	
X xmake5.c                   1	
X xmake5.doc                 2	
X xmake5.h                   3	
END_OF_FILE
if test 796 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'cmake5.C' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cmake5.C'\"
else
echo shar: Extracting \"'cmake5.C'\" \(16849 characters\)
sed "s/^X//" >'cmake5.C' <<'END_OF_FILE'
X// File: cmake5.C       (the Make5 game program, curses version)
X
Xextern "C" {
X#include <stdio.h>
X#include <curses.h>
Xextern char *strdup(char *);
Xextern void srand(int), exit(int);
Xextern int  time(int);
Xextern char toupper(char);
Xextern char *getlogin(void);
Xextern void mail_record(int,int,int[]);
Xextern void add_score_record(int,int,int);
X}
X// ---------------------------------------------------------------------
X
Xextern char *ScoreF;
X
X#define max(a,b) (a>b?a:b)
X#define min(a,b) (a<b?a:b)
X
Xvoid c_time(int &t)     { t = time(0); }
Xint  c_lines(void)      { return LINES; }
Xint  c_cols(void)       { return COLS; }
Xvoid c_key_raw(void)    { noecho(); cbreak(); }
Xvoid c_repaint(void)    { clearok(curscr,TRUE); wrefresh(curscr); }
Xvoid c_addint(int n)    { printw("%d",n); refresh(); }
Xvoid c_initscr(void)    { initscr(); idlok(stdscr,TRUE); 
X                          scrollok(stdscr,TRUE), nl(); }
Xvoid c_clear(void)      { clear(); }
Xvoid c_endwin(void)     { endwin(); }
Xvoid c_addch(char c)    { addch(c); refresh(); }
Xvoid c_move(int r, int c)   { move(r,c); refresh(); }
Xvoid c_addch_at(char x,int r, int c) { move(r,c); addch(x); refresh(); }
Xvoid c_clrscr(void)     { clear(); move(0,0); refresh(); }
Xvoid c_clreol(void)     { clrtoeol(); refresh(); }
Xvoid c_getkey(char &x)  { while ((x=getch()) == 12) c_repaint(); }
Xvoid c_getret(void)     { char c; do {c_getkey(c);} while (c!='\n');}
X// ---------------------------------------------------------------------
X
Xconst char
X  wall  = '#' ,  blank = '.' ,
X  black = 'X' ,  white = 'O' ,  xmark = '*' ;
X
Xconst int
X  bdx = 19 ,      bdy = 1 ,
X  msg_row = 1 ,   name_row = 2 ,  mark_row = 3 , msg_width = 16,
X  bdwidth = 21 ,  bdlength = 440,
X  start_pos = 22, end_pos = 418,  center_point = 220;
X
Xconst int msg_col[2] = {0,63};
X
Xextern char board[bdlength+1];          // in initbd.C
X
Xchar *bar_str = "----------------" ;
X
Xchar mark_str[2][msg_width+1];
X
Xchar  *(command_keys[2]) = {
X"[R]:redraw [IJKL1..9]:move [RETURN]:set [S]:sound [H]:hint [U]:undo [Q]:quit",
X"   [R]:redraw    [IJKL1..9]:move    [RETURN]:set    [S]:sound    [Q]:quit"} ;
X
Xint   time1,time2;
Xint   player_time[2];
Xchar  player_color[2];
Xint   esc,back;         // boolean
Xchar  bdmark[441];      // boolean
Xchar  bell;
X
X// ---------------------------------------------------------------------
Xstatic char     computer_name[20];
Xstatic char     *warning_msg;
Xstatic int      game_over, warning_msg_on, challenging;
Xstatic int      last_move_rec, move_rec[360];
X
X#define the_last_move move_rec[last_move_rec]
X
Xstatic char     *(player_name[2]);
X
Xint          step, player;              /* used in make5.C  */
Xint          min_depth, max_depth;      /* used in select.C */
X
X// ---------------------------------------------------------------------
Xextern "C" void init_data(void);       /* in make5.C */
Xextern "C" char *get_warning(int,int);
Xextern "C" int  is_game_over(int,int);
Xextern "C" void set_on(int,int), take_out(int);
Xextern "C" int  computer_move(int), computer_suggest(int);
X
Xstatic void show_command_keys(void);
Xstatic void show_high_score(int);
X// --------------------------------------------------------------------
X// --------------------------------------------------------------------
X//      Board coordinates computation
X
X// --------------------------------------------------------------------
Xinline int x_col(int x) {
X  return (bdx + ((x % bdwidth) * 2)) ;
X}
X// --------------------------------------------------------------------
Xinline int x_row(int x) {
X  return (bdy + (x / bdwidth)) ;
X}
X
X// --------------------------------------------------------------------
X// --------------------------------------------------------------------
X//      Simple character and string I/O
X
Xinline void moveto(int x) {
X  c_move(x_row(x),x_col(x)) ;
X}
X// --------------------------------------------------------------------
Xvoid write_blanks(int n) {
X  for (int i=0; i<n; i++) c_addch(' ');
X}
X// ---------------------------------------------------------------------
Xvoid randomize(void) {
Xint t;
X  c_time(t); srand(t);
X}
X// --------------------------------------------------------------------
Xvoid clean_screen(int r, int c, int w) {
X  c_move(r,c); write_blanks(w);
X}
X// --------------------------------------------------------------------
Xvoid clear_line(int r) {
X  c_move(r,0); c_clreol();
X}
X// --------------------------------------------------------------------
Xstatic void write_str(char *x) {
X  while (*x) {c_addch(*x); x++; }
X}
X// --------------------------------------------------------------------
Xvoid write_str_at(int r, int c, char *x) {
X  c_move(r,c); write_str(x);
X}
X// --------------------------------------------------------------------
Xvoid two_digit(int n) {
X  if (n < 10) c_addch('0');
X  c_addint(n);
X}
X// --------------------------------------------------------------------
Xvoid display_time(int p, int t) {
X  c_move(0,msg_col[p]+8);
X  player_time[p] += t;
X  c_addch('(');  two_digit(player_time[p] / 60);
X  c_addch(':');  two_digit(player_time[p] % 60);
X  c_addch(')');
X}
X
X// --------------------------------------------------------------------
X// --------------------------------------------------------------------
X//      Higher-level I/O
X
Xint yes_no(int r, char *msg) {
X  char x;
X  do {
X    clear_line(r);
X    write_str(msg); write_str(" (y/n)"); c_addch(' '); c_getkey(x) ;
X    x = toupper(x) ;
X  } while (x != 'Y' && x != 'N');
X  c_addch(x);
X  return (x == 'Y');
X}
X// --------------------------------------------------------------------
Xchar *get_name() { return (getlogin()); }
X
X// --------------------------------------------------------------------
X// --------------------------------------------------------------------
X//      Marks on the Board
X
Xinline char x_rowmark(int x) {
X  return ('A' + (x/bdwidth) - 1) ;
X}
X// --------------------------------------------------------------------
Xinline char x_colmark(int x) {
X  return ('a' + (x%bdwidth) - 1) ;
X}
X// --------------------------------------------------------------------
Xvoid markon(int x, char c) {
X  moveto(x) ;  c_addch(c);  moveto(x);
X}
X// --------------------------------------------------------------------
Xvoid resetmark(int x) {         //  reset marks on the screen
X  if (bdmark[x])  markon(x,xmark);
X  else markon(x,blank);
X}
X// --------------------------------------------------------------------
Xvoid clr_mark() {               /*  clear marks on the screen */
X  for (int i=start_pos; i<=end_pos; i++)
X    if (bdmark[i]) {
X      bdmark[i] = 0;
X      markon(i,board[i]) ;
X    }
X}
X// ---------------------------------------------------------------------
Xvoid markx(int p, int x, int i, int &sw) {
X  sw = i ;
X  if (board[x] == blank)
X       if (sw == 1) markon(x,player_color[p]);
X       else         resetmark(x);
X  else markon(x,board[x]) ;
X}
X// ---------------------------------------------------------------------
Xstatic void redraw_board()
X{   int i,j,n;
X
X  c_clrscr();
X  c_move(bdy,bdx);
X  for(i=2,n=bdwidth*2; i<=n; i++) c_addch(wall);
X  for(i=bdwidth,n=bdlength-bdwidth; i<=n; i++) {
X        j=i%bdwidth;
X        if (j==0 || j==bdwidth-1) markon(i,wall);
X        else markon(i,board[i]);
X  }
X  c_move(bdy+bdwidth-1,bdx);
X  for(i=2,n=bdwidth*2; i<=n; i++) c_addch(wall);
X
X/*
X  for(i=1,n=bdwidth-2; i<=n; i++) {
X    j = i * bdwidth;
X    c_addch_at(x_rowmark(j), x_row(j),    bdx-1);
X    c_addch_at(x_rowmark(j), x_row(j),    bdx+2*bdwidth-1);
X    c_addch_at(x_colmark(i), bdy-1,       x_col(i));
X    c_addch_at(x_colmark(i), bdy+bdwidth, x_col(i));
X  }
X*/
X
X  for (i=0; i<2; i++) {
X    write_str_at(msg_row, msg_col[i],   bar_str) ;
X    write_str_at(name_row,msg_col[i],   player_name[i]) ;
X    write_str_at(mark_row,msg_col[i],   mark_str[i]) ;
X    write_str_at(0,       msg_col[i]+8, "(00:00)");
X  }
X}
X
X// ---------------------------------------------------------------------
X// ---------------------------------------------------------------------
X//              Initialize board status
X
Xstatic int current_level;
Xstatic int min_depths[] = {0,1,2,3,3,3};
Xstatic int max_depths[] = {0,2,4,5,8,9};
X
Xvoid init_play_order(void) {
X    int i,p;
X    char x;
X    write_str_at(3,10,"[1] Challenge mode,    (Computer first)");
X    write_str_at(5,10,"[2] Computer vs Human  (Computer first)");
X    write_str_at(7,10,"[3] Human vs Computer  (Human first)");
X  do {
X    clear_line(0);  write_str("Please choose the play order: (1..3) ") ;
X    c_getkey(x);  i = x - '0';
X  } while (i<1 || i >3);
X  c_addch(x);
X  switch (i) {
X      case 1:
X         player_name[0] = computer_name;
X         player_name[1] = get_name();
X         challenging = 1;
X         break;
X      case 2: case 3:
X         player_name[i-2] = computer_name;
X         player_name[3-i] = get_name();
X         challenging = 0;
X         break;
X  }
X
X  do {
X    clear_line(10);
X    if (challenging)
X      write_str_at(10,0,"Please choose computer\'s search level: (2..5)");
X    else 
X      write_str_at(10,0,"Please choose computer\'s search level: (1..5)");
X    c_addch(' '); c_getkey(x);  current_level = x-'0' ;
X  } while (current_level < 1 ||  current_level > 5 || 
X           (current_level == 1 && challenging));
X  c_addch(x);
X  sprintf(computer_name,"Computer (L%d)",current_level);
X  min_depth = min_depths[current_level];
X  max_depth = max_depths[current_level];
X
X  player_color[0] = black ;
X  player_color[1] = white ;
X  for (p=0; p<2; p++) {
X    for (i=0; i<msg_width; i++)
X      mark_str[p][i] = player_color[p] ;
X    mark_str[p][i]=0;
X  }
X  bell = 7;
X}
X// --------------------------------------------------------------------
Xstatic int new_high_score=0;
Xvoid init_the_board()
X{
X  int i;
X    if (new_high_score) {
X        show_high_score(1);
X        new_high_score = 0;
X    }
X    step = 1; player = 0;
X    last_move_rec = 0;
X    the_last_move = center_point;
X    warning_msg = "";
X    esc = back = game_over = warning_msg_on = 0;
X    for (i=0; i<=bdlength; i++) bdmark[i] = 0;
X    player_time[0] = player_time[1] = 0;
X    c_clrscr();
X    init_play_order();
X    randomize();
X    init_data();        // in make5.C
X    redraw_board();
X}
X// ---------------------------------------------------------------------
X// ---------------------------------------------------------------------
X//      making moves
X
Xstatic void check_game_over(void)
X{
X  warning_msg = get_warning(player,the_last_move);
X  game_over = is_game_over(player,the_last_move);
X  clear_line(23);
X  if (warning_msg[0] != 0) {
X         write_str_at(23,20,warning_msg);
X         c_addch(bell);  warning_msg_on = 1;
X  } else show_command_keys();
X  if (game_over && challenging) {
X        mail_record(current_level,last_move_rec,&(move_rec[1]));
X        if (player==1) {
X                new_high_score=1;
X                add_score_record(current_level,step,player_time[1]);
X        }
X  }
X}
X// ---------------------------------------------------------------------
Xextern void take_out(int);
Xinline void back_one_move() {
X  int x = move_rec[last_move_rec--];
X    take_out(x);
X    markon(x,blank);
X}
X// ---------------------------------------------------------------------
Xstatic void undo()
X{
X    if (step > 2 || (step == 2 && player == 1)) {
X      back_one_move();
X      back_one_move();
X      step--;
X      if (player==0) step--;
X      player=1-player;
X      check_game_over();
X    }
X}
X// ---------------------------------------------------------------------
X// ---------------------------------------------------------------------
X//      get user's move
X
Xvoid adjust(int &x) {           //  adjust X if X is out of range 
X  int r,c;
X  if ((c=(x%bdwidth)) == 0) x++;
X  else if (c == bdwidth-1) x--;
X  if ((r=(x/bdwidth)) == 0) x += bdwidth;
X  else if (r == bdwidth-1) x -= bdwidth;
X}
X// --------------------------------------------------------------------
Xstatic void show_command_keys(void) {
X    write_str_at(23,0,command_keys[challenging]); warning_msg_on=0;
X}
X// --------------------------------------------------------------------
Xvoid wait_first_key(char &k) {
X  if (step == 1)  show_command_keys();
X  moveto(the_last_move);
X  c_getkey(k) ; k = toupper(k) ;
X  if (warning_msg_on) show_command_keys();
X  moveto(the_last_move);
X}
X// --------------------------------------------------------------------
Xextern int  num_of_suggestion, suggest_position[];
Xvoid draw_suggestions()
X{ int i,n,x;
X
X    for (i=0,n=num_of_suggestion; i<n; i++) {
X      x=suggest_position[i];
X      bdmark[x]=1;  markon(x,xmark);
X    }
X}
X// --------------------------------------------------------------------
Xconst int move_dir[10] = {0,20,21,22,-1,0,1,-22,-21,-20};
X
Xint player_move(int p) {
X  int  x,t;
X  char k;
X
X//  c_addch(bell);
X  x = the_last_move;  
X  wait_first_key(k) ;
X  while (1) {
X        switch (k) {
X          case 'I': k='8'; break;
X          case 'J': k='4'; break;
X          case 'K': k='2'; break;
X          case 'L': k='6'; break;
X        }
X        switch (k) {
X          case 'R':
X                 c_repaint();  break;
X          case 'S':
X                 if (bell==7)  bell=0;  else bell=7;
X                 break;
X          case '1': case '2': case '3':
X          case '4': case '5': case '6':
X          case '7': case '8': case '9':
X                 t = x + move_dir[k-'0'] ;
X                 adjust(t) ;
X                 if ( t != x) {
X                   markx(p,x,0,0) ;
X                   x = t ;  markx(p,x,1,0) ;
X                 }
X                 break;
X          case 'U':             // Undo
X                 if (challenging) break;
X                 back = back || (step > 1) ;
X          case 'Q':             //  Quit
X                 esc = esc || k == 'Q';
X                 if (esc || back) {
X                   markx(p,x,0,0) ;  return x;
X                 }
X                 break;
X          case 'H':
X                 if (challenging) break;
X                 c_addch(board[x]) ;
X                 x = computer_suggest(p) ;
X                 draw_suggestions();
X                 markx(p,x,1,0) ;
X                 break;
X          default:
X                if (k == 10 && board[x] == blank)  return x;
X        }
X        c_getkey(k); k=toupper(k);
X  } 
X}
X// --------------------------------------------------------------------
Xint move_of(int p) {            /*  get move of player p */
X  int p2,m;
X
X  clr_mark();
X
X  p2 = 1 - p ;
X  write_str_at(0,msg_col[p],"step:");
X  c_addint(step) ;  c_addch(' ');       //  display current step
X  clean_screen(0,msg_col[p2],8) ;
X  write_str_at(msg_row,msg_col[p],bar_str) ;
X  clean_screen(mark_row,msg_col[p2],msg_width) ;
X
X  c_time(time1);
X  if (player_name[player] == computer_name)  {
X         moveto(the_last_move);
X         m = computer_move(p);
X  } else m = player_move(p) ;
X  c_time(time2);
X  display_time(player,time2-time1);
X
X  write_str_at(mark_row,msg_col[p2],mark_str[p2]) ;
X  write_str_at(msg_row,msg_col[p],bar_str) ;
X  return m;
X}
X
X// ---------------------------------------------------------------------
X// ---------------------------------------------------------------------
X//      Starting and Ending the game
X
Xvoid end_of_game() {
X  char s[80];
X  clear_line(23);
X  sprintf(s,"***  GAME OVER  ***    The winner is: %s [%c]",
X        player_name[player],player_color[player]);
X  write_str(s);
X  write_str_at(23,70,"[RETURN]") ;
X  c_getret(); 
X}
X// --------------------------------------------------------------------
Xstatic void show_high_score(int pause)
X{ FILE *f;
X  int i=0;
X  char c;
X    f = fopen(ScoreF,"r");
X    c_move(0,0);
X    while ((c=fgetc(f)) != EOF) {
X        c_addch(c); 
X        if (c=='\n') i++;
X        if (i>20) break;
X    }
X    fclose(f);
X    if (pause) {
X      write_str_at(23,0,"type [RETURN] to continue...") ; c_getret();
X    } else c_move(23,0);
X}
X// --------------------------------------------------------------------
Xvoid init_window() {
X  c_initscr();
X  c_key_raw();
X  if ((c_lines() < 24) || (c_cols() < 80))  {
X    c_clear();
X    write_str_at(0,0,"This program needs a screen size at least 24 by 80!");
X    c_move(1,0);  c_endwin();
X    exit(0);
X  }
X  c_clrscr() ; 
X  show_high_score(1);
X}
X// --------------------------------------------------------------------
Xvoid main() {
X  int x;
X  init_window();
X  do {
X    init_the_board();
X    do {
X      x = move_of(player) ;
X      if (!esc) {
X        if (back) {
X            undo();  back=0;
X        } else {
X            move_rec[++last_move_rec] = x;
X            markon(x,player_color[player]);
X            set_on(the_last_move,player) ;
X        }
X        check_game_over();
X        if (!game_over) {
X          player = 1 - player ;  //  turn to the next player
X          if (player == 0)  step++;
X        }
X      } else {
X        game_over = 1;
X        player = 1 - player;
X        if (player == 1)  step--;
X      } 
X    } while (!game_over);
X    end_of_game() ;
X  } while (yes_no(22,"Would you want to play again ?"));
X  c_clrscr(); show_high_score(0);
X  c_endwin();
X}
X// -----------------------------------------------------------------------
END_OF_FILE
if test 16849 -ne `wc -c <'cmake5.C'`; then
    echo shar: \"'cmake5.C'\" unpacked with wrong size!
fi
# end of 'cmake5.C'
fi
if test -f 'initbd.C' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'initbd.C'\"
else
echo shar: Extracting \"'initbd.C'\" \(6574 characters\)
sed "s/^X//" >'initbd.C' <<'END_OF_FILE'
X// FILE:        initbd.C
X
X#define true  1
X#define false 0
X
X#include "bdconst.h"
X
Xconst int
X  weight5[5] = {0,1,3,7,15} ,                 // {  -3  -2  -1  }
X  dirx[8] = {20,21,22,-1,1,-22,-21,-20};      // {   4   X  -4  }
X      // {1,-22,-21,-20,0,20,21,22,-1}        // {   1   2   3  }
X      // -4..4 ==> 0..7                       // {   5   6   7  }
X      // 1 2 3 4 ==> 0 1 2 3                  // {   3   X   4  }
X      // -1 -2 -3 -4 ==> 7 6 5 4              // {   0   1   2  }
X
X#include "line_val.inc"
X// defines "const line_val_type line_val"
X
Xint weight31[31];
X//---------------------------------------------------------------------------
Xconst pt_lev_range
X  point_lev_tab[max_line_lev+1][max_line_lev+1]
X    = {{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
X       { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
X       { 0, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3},
X       { 0, 1, 2, 2, 2, 2, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},
X       { 0, 1, 2, 2, 2, 2, 4, 4, 4, 6, 6, 6, 8, 8, 8,10,10,10,10,10,10},
X       { 0, 1, 2, 2, 2, 2, 4, 4, 4, 6, 6, 6, 8, 8, 8,10,10,10,12,12,12},
X       { 0, 1, 2, 4, 4, 4, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7},
X       { 0, 1, 2, 4, 4, 4, 5, 5, 5, 7, 7, 7, 9, 9, 9,11,11,11,11,11,11},
X       { 0, 1, 2, 4, 4, 4, 5, 5, 5, 7, 7, 7, 9, 9, 9,11,11,11,13,13,13},
X       { 0, 1, 3, 6, 6, 6, 7, 7, 7,14,14,14,14,14,14,17,17,19,19,19,19},
X       { 0, 1, 3, 6, 6, 6, 7, 7, 7,14,14,14,15,15,15,17,17,19,19,19,19},
X       { 0, 1, 3, 6, 6, 6, 7, 7, 7,14,14,14,15,15,15,17,17,19,19,19,19},
X       { 0, 1, 3, 6, 8, 8, 7, 9, 9,14,15,15,16,16,16,18,18,18,18,18,18},
X       { 0, 1, 3, 6, 8, 8, 7, 9, 9,14,15,15,16,18,18,18,18,20,20,20,20},
X       { 0, 1, 3, 6, 8, 8, 7, 9, 9,14,15,15,16,18,18,18,18,20,20,20,20},
X       { 0, 1, 3, 6,10,10, 7,11,11,17,17,17,18,18,18,21,21,22,24,24,24},
X       { 0, 1, 3, 6,10,10, 7,11,11,17,17,17,18,18,18,21,21,22,24,24,24},
X       { 0, 1, 3, 6,10,10, 7,11,11,19,19,19,18,20,20,22,22,23,25,26,27},
X       { 0, 1, 3, 6,10,12, 7,11,13,19,19,19,18,20,20,24,24,25,25,26,27},
X       { 0, 1, 3, 6,10,12, 7,11,13,19,19,19,18,20,20,24,24,26,26,26,27},
X       { 0, 1, 3, 6,10,12, 7,11,13,19,19,19,18,20,20,24,24,27,27,27,27}};
X
X   // point_lev_tab[0][*] and point_lev_tab[*][0] are not used.
X
X//---------------------------------------------------------------------------
Xchar board[x_index_range];
X
Xbdstatus_type bdstatus;
X//---------------------------------------------------------------------------
Xvoid init_board(void) {  // { initialize chess board }
Xint i;
X  for (i=0; i<=bdlength; i++)  // { clear the chess board to blank }
X    board[i] = blank;
X  for (i=0; i<bdwidth; i++)
X  {
X    board[i] = wall;                // { set top margin }
X    board[bdlength-i] = wall;       // { set bottom margin }
X    board[i*bdwidth] = wall;        // { set left margin }
X    board[(i+1)*bdwidth-1] = wall;  // { set right margin }
X  }
X}
X//---------------------------------------------------------------------------
Xvoid init_weight31() {
Xint i;
X  weight31[0] = 0;
X  for (i=1; i<31; i++)
X    weight31[i] = weight31[i-1] + i;
X}
X//---------------------------------------------------------------------------
Xint get_side_lev(int x,int d,char c) {
Xint i,v;
X  v = 0;  d = dirx[d];
X  for (i=0; i<4; i++)
X  {
X    x += d;
X    if (board[x] == c )   v = (v << 1) + 1;
X    else if (board[x] == blank ) v <<= 1;
X    else return(v + weight5[i]);
X  }
X  x += d;
X  if (board[x] != c)  return(v + weight5[4]);
X  for (i=3; i>=0; i--) {
X          x -= d;
X          if (board[x] == c)  v >>= 1;
X          else return ((v >> 1) + weight5[i]);
X  }
X  return (max_side_lev);    // { very special condition }
X}
X//---------------------------------------------------------------------------
Xvoid set_side_lev(int x) {
X  for (int d=0; d<8; d++)
X    bdstatus.side_lev[x][0][d] = get_side_lev(x,d,white);
X}
X//---------------------------------------------------------------------------
Xvoid set_line_lev(int x,int c,int d) {
Xint c1,c2;
X      c1 = bdstatus.side_lev[x][c][d];
X      c2 = bdstatus.side_lev[x][c][7-d];
X      if ((c1 == max_side_lev) || (c2 == max_side_lev))
X             bdstatus.line_lev[x][c][d] = max_line_lev;
X      else if (c1 < c2)
X                 bdstatus.line_lev[x][c][d] = line_val[weight31[c2]+c1];
X            else bdstatus.line_lev[x][c][d] = line_val[weight31[c1]+c2];
X}
X//---------------------------------------------------------------------------
Xstatic void set_all_line_lev(int x) {
X    for (int d=0; d<4; d++) set_line_lev(x,0,d);
X}
X//---------------------------------------------------------------------------
Xvoid set_point_lev(int x, int c) {
Xint k,m,n,d;
X    m = n = max_pt_lev;
X    for (d=0; d<4; d++) {
X      k = bdstatus.line_lev[x][c][d];
X      if (m < n)
X           { if (k < n) n = k; }
X      else { if (k < m) m = k; }
X    }
X    bdstatus.point_lev[x][c] = point_lev_tab[m][n];
X}
X//---------------------------------------------------------------------------
Xvoid compute_bdstatus(void) {
Xint x,d;
X  for (x=0; x<=bdlength; x++)
X    if  (board[x] == wall) {
X           for (d=0; d<8; d++) bdstatus.side_lev[x][0][d] = max_side_lev;
X           for (d=0; d<4; d++) bdstatus.line_lev[x][0][d] = max_line_lev;
X           bdstatus.point_lev[x][0] = max_pt_lev;
X    }
X    else {
X           set_side_lev(x);
X           set_all_line_lev(x);
X           set_point_lev(x,0);
X    }
X}
X//---------------------------------------------------------------------------
Xvoid copy12(void) {
Xint x,d;
X    for (x=0; x<=bdlength; x++) {
X      for (d=0; d<8; d++)
X                bdstatus.side_lev[x][1][d] = bdstatus.side_lev[x][0][d];
X      for (d=0; d<4; d++)
X                bdstatus.line_lev[x][1][d] = bdstatus.line_lev[x][0][d];
X      bdstatus.point_lev[x][1] = bdstatus.point_lev[x][0];
X    }
X}
X//---------------------------------------------------------------------------
Xvoid count_pt_lev_rec(void) {
Xint i,j;
Xpt_lev_record &bp = bdstatus.pt_lev_rec;
X
X    for (i=0; i<2; i++)
X      for (j=1; j<=max_pt_lev; j++)
X        bp.pc[i][j] = 0;
X    for (i=1; i<=bdlength; i++)
X      if (board[i] == blank)
X        for (j=0; j<2; j++)
X          (bp.pc[j][bdstatus.point_lev[i][j]])++;
X    for (i=0; i<2; i++) {
X      bp.mp[i] = 1;
X      while (bp.pc[i][bp.mp[i]] == 0)   (bp.mp[i])++;
X    }
X}
X//---------------------------------------------------------------------------
Xvoid init_bdstatus (void) {
X  init_board();
X  init_weight31();
X  compute_bdstatus();
X  copy12();
X  count_pt_lev_rec();
X}
X//---------------------------------------------------------------------------
END_OF_FILE
if test 6574 -ne `wc -c <'initbd.C'`; then
    echo shar: \"'initbd.C'\" unpacked with wrong size!
fi
# end of 'initbd.C'
fi
if test -f 'xmake5.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xmake5.c'\"
else
echo shar: Extracting \"'xmake5.c'\" \(24060 characters\)
sed "s/^X//" >'xmake5.c' <<'END_OF_FILE'
X/* FILE: xmake5.c   (Ver. 1.1) */
X
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X#include <X11/Xaw/Cardinals.h>
X#include <X11/Xaw/AsciiText.h>
X#include <X11/Xaw/Paned.h>
X#include <X11/Xaw/Box.h>
X#include <X11/Xaw/Command.h>
X#include <X11/Xaw/Label.h>
X#include <X11/Xaw/MenuButton.h>
X#include <X11/Xaw/SimpleMenu.h>
X#include <X11/Xaw/SmeBSB.h>
X#include <X11/Xaw/SmeLine.h>
X
X#include <stdio.h>
X#include <string.h>
X
X/**********************************************************************/
X
X#include "xmake5.h"
X#include "make5.xbm"
X
Xextern Window   main_win;
X
Xstatic Pixmap   icon_map;
Xstatic char     *warning_msg;
X
X/**********************************************************************/
X/*      Moving records                  */
X
Xstatic int      current_level;
Xstatic char     move_rec_text[6000];   /* to hold 200 * 30 characters */
Xint    game_over, sound_level=1, help_win_switch=0, challenging;
Xint    last_move_rec, move_rec[360];
X
Xchar     player_name[2];
Xint      step, player;              /* used in make5.C  */
Xint      min_depth, max_depth;      /* used in select.C */
X
Xstatic int min_depths[] = {0,1,2,3,3,3};
Xstatic int max_depths[] = {0,2,4,5,8,9};
X
X/**********************************************************************/
XString fallback_resources[] = { 
X    "*XMake5.title:              Make5:  the Game Program  (Ver. 1.1)",
X    "*font:                      -adobe-courier-bold-r-*-*-12-*-*-*-*-*-*-*",
X    "*XMake5*commands.resizeToPreferred:      True",
X    "*XMake5*status.resizeToPreferred:        True",
X    "*XMake5*warning.resizeToPreferred:       True",
X    "*XMake5*board_canvas.resizeToPreferred:  True",
X    "*commands.width:            380",
X    "*status.width:              380",
X    "*warning.width:             380",
X    "*quit_B*label:              QUIT",
X    "*restart_B*label:           Restart",
X    "*setup_B*label:             Setup...",
X    "*question_B*label:          Where...",
X    "*windows_B*label:           Open Sub Window",
X    "*status*showGrip:           Off",
X    "*status*skipAdjust:         True",
X    "*warning*showGrip:          Off",
X    "*warning*skipAdjust:        True",
X    "*warning*font:              -adobe-courier-bold-r-*-*-14-*-*-*-*-*-*-*",
X    "*board_canvas*showGrip:     Off",
X    "*board_canvas.width:        506",
X    "*board_canvas.height:       506",
X    "*setup_B*menuName:                      setupMenu",
X    "XMake5*setupMenu.label:                 Set up options:",
X    "XMake5*setupMenu*sound_switch*label:    Sound OFF       (Key:S)",
X    "XMake5*setupMenu*level1*label:          Search Level 1  (Key:1)",
X    "XMake5*setupMenu*level2*label:          Search Level 2  (Key:2)",
X    "XMake5*setupMenu*level3*label:          Search Level 3  (Key:3)",
X    "XMake5*setupMenu*level4*label:          Search Level 4  (Key:4)",
X    "XMake5*setupMenu*level5*label:          Search Level 5  (Key:5)",
X    "XMake5*setupMenu*order_cc*label:        Computer  vs.  Computer",
X    "XMake5*setupMenu*order_cm*label:        Computer  vs.  Human",
X    "XMake5*setupMenu*order_mc*label:        Human     vs.  Computer",
X    "XMake5*setupMenu*order_mm*label:        Human     vs.  Human",
X    "XMake5*setupMenu*adjust*label:          Reshape board   (Key:R)",
X    "XMake5*setupMenu*undo*label:            Undo one step   (Key:U)",
X    "XMake5*setupMenu*challenge2*label:      Challenge Level 2",
X    "XMake5*setupMenu*challenge3*label:      Challenge Level 3",
X    "XMake5*setupMenu*challenge4*label:      Challenge Level 4",
X    "XMake5*setupMenu*challenge5*label:      Challenge Level 5",
X    "XMake5*setupMenu*RowHeight:             16",
X    "XMake5*setupMenu*HorizontalMargins:     10",
X    "*question_B*menuName:                   q_Menu",
X    "XMake5*q_Menu*where*label:              Last move? (Key:L)",
X    "XMake5*q_Menu*suggest*label:            Hint?      (Key:H)",
X    "*XMake5_Help.title:         Help/Info",
X    "*XMake5_Help*font:          -adobe-courier-bold-r-*-*-14-*-*-*-*-*-*-*",
X    "*Text*scrollVertical:       whenNeeded",
X    "*Text*scrollHorizontal:     whenNeeded",
X    "*help_win_label.label:      Make5 Help Window",
X    "*help_win_label*showGrip:   Off",
X    "*help_win_label*skipAdjust: True",
X    "*help_win.editType:         read",
X    "*help_win.height:           300",
X    "*help_win.width:            500",
X    "*rec_win_label.label:       Move Records",
X    "*rec_win_label*showGrip:    Off",
X    "*rec_win_label*skipAdjust:  True",
X    "*rec_win.editType:          read",
X    "*rec_win.height:            100",
X    "*score_win_label.label:       List of Winners",
X    "*score_win_label*showGrip:    Off",
X    "*score_win_label*skipAdjust:  True",
X    "*score_win.editType:          read",
X    "*score_win.height:            100",
X    NULL
X};
X
X/**********************************************************************/
Xstatic Widget play_order[4], play_level[5], challenge_level[4], 
X              undo, suggest;
Xstatic char player_order_names[][2] = {
X  {'C', 'C'},  {'C', 'M'},  {'M', 'C'},  {'M', 'M'}
X};
X
X/**********************************************************************/
Xextern void reset_timer(), start_timer(), pause_timer();
Xextern int  get_timer();
Xextern void warp_to_position(), to_last_position(), switch_color(),
X            draw_suggestions(), adjust_board(), setup_gc();
Xextern void Board_redraw(), Board_seton(), Board_config();
Xstatic void Quit_B(),Restart_B(),Where_B(),Undo_B(),Windows_B();
Xstatic void create_help_shell(), add_menu_items1(), add_menu_items2();
Xstatic void set_sound_level(), suggestion();
Xstatic void set_level_1(), set_level_2(), set_level_3(), set_level_4(),
X            set_level_5(), update_move_record(), set_challenge_level(),
X            set_challenging(), set_play_order();
X
Xvoid check_computer_move(), make_computer_move(), make_a_move();
X/**********************************************************************/
Xstatic String trans =
X        "<Expose>:     Board_redraw()    \n\
X         <BtnUp>:      Board_seton()     \n\
X         <Configure>:  Board_config()    \n\
X         <Key>S:       set_sound_level() \n\
X         <Key>1:       set_level_1()     \n\
X         <Key>2:       set_level_2()     \n\
X         <Key>3:       set_level_3()     \n\
X         <Key>4:       set_level_4()     \n\
X         <Key>5:       set_level_5()     \n\
X         <Key>R:       adjust_board()    \n\
X         <Key>U:       Undo_B()          \n\
X         <Key>L:       Where_B()         \n\
X         <Key>H:       suggestion() ";
X
Xstatic XtActionsRec window_actions[] = {
X        {"Board_redraw",        Board_redraw},
X        {"Board_seton",         Board_seton},
X        {"Board_config",        Board_config},
X        {"set_sound_level",     set_sound_level},
X        {"set_level_1",         set_level_1},
X        {"set_level_2",         set_level_2},
X        {"set_level_3",         set_level_3},
X        {"set_level_4",         set_level_4},
X        {"set_level_5",         set_level_5},
X        {"adjust_board",        adjust_board},
X        {"Undo_B",              Undo_B},
X        {"Where_B",             Where_B},
X        {"suggestion",          suggestion}
X};
X
X/**********************************************************************/
XWidget toplevel;
Xstatic Widget vpane, board_canvas, status_label, 
X              warning_label, sound_switch, help_shell, windows_B, 
X              rec_win, score_win;
Xstatic XtAppContext app_con;
X/**********************************************************************/
X/*                     Configuration                                  */
X/**********************************************************************/
Xmain(argc, argv)
X    int argc;  char *argv[];
X{
X    create_top_level(argc,argv);
X    create_buttons();
X    create_help_shell();
X
X    status_label = XtCreateManagedWidget("status",
X                        labelWidgetClass,vpane,NULL,ZERO);
X
X    warning_label = XtCreateManagedWidget("warning",
X                        labelWidgetClass,vpane,NULL,ZERO);
X
X    board_canvas = XtVaCreateManagedWidget("board_canvas", 
X                        widgetClass, vpane, 
X                        XtNtranslations, XtParseTranslationTable(trans),
X                        NULL);
X    XtAppAddActions(app_con, window_actions, XtNumber(window_actions));
X
X    XtRealizeWidget(toplevel);
X    main_win = XtWindow(board_canvas);
X    setup_gc();
X    set_play_order(2);
X    set_play_level(2);
X    init_board();
X    srand(time(NULL));       /* initialize random number generator */
X    reset_timer(0);  reset_timer(1); start_timer(0);
X    set_challenging(0);
X
X    XtAppMainLoop(app_con);
X}
X/**********************************************************************/
Xcreate_top_level(argc, argv)
X    int argc;  char **argv;
X{  
X    Arg args[2];
X
X    toplevel = XtAppInitialize(&app_con, "XMake5", NULL, ZERO,
X                               &argc, argv,
X                               fallback_resources, NULL, ZERO);
X    display = XtDisplay(toplevel);
X    screen_num = DefaultScreen(display);
X
X    icon_map = XCreateBitmapFromData(display, 
X                             RootWindow(display, screen_num),
X                             make5_bits, make5_width, make5_height);
X    XtSetArg(args[0], XtNiconPixmap, icon_map);
X    XtSetArg(args[1], XtNiconName, "X Make5");
X    XtSetValues(toplevel, args, 2);
X
X    vpane = XtCreateManagedWidget("vpane", panedWidgetClass, toplevel, 
X                                    NULL, ZERO);
X}
X/**********************************************************************/
Xcreate_buttons()
X{
X  Widget commands, quit_B, restart_B, setup_B, question_B;
X
X    commands = XtCreateManagedWidget("commands", boxWidgetClass, vpane, 
X                                  NULL, ZERO);
X
X#define create_a_button(but,name,callback) { \
X    but=XtCreateManagedWidget(name,commandWidgetClass,commands,NULL,ZERO); \
X    XtAddCallback(but,XtNcallback,callback,NULL); }
X
X    create_a_button(quit_B,    "quit_B",    Quit_B);
X    create_a_button(restart_B, "restart_B", Restart_B);
X
X    setup_B = XtCreateManagedWidget("setup_B", 
X                          menuButtonWidgetClass, commands, NULL, ZERO);
X    add_menu_items1(setup_B);
X
X    question_B = XtCreateManagedWidget("question_B", 
X                          menuButtonWidgetClass, commands, NULL, ZERO);
X    add_menu_items2(question_B);
X
X    create_a_button(windows_B, "windows_B", Windows_B);
X#undef create_a_button(but,name)
X}
X/**********************************************************************/
Xvoid refresh_high_score()
X{
X  Arg args[2];  
X  extern char *ScoreF;
X    XtSetArg(args[0], XtNstring, "");
X    XtSetArg(args[1], XtNtype, XawAsciiString);
X    XtSetValues(score_win, args, 2);
X    XtSetArg(args[0], XtNstring, ScoreF);
X    XtSetArg(args[1], XtNtype, XawAsciiFile);
X    XtSetValues(score_win, args, 2);
X}
X/**********************************************************************/
Xstatic void create_help_shell()
X{
X  Arg args[1];  
X  Widget pane, help_win;
X    
X    help_shell = XtCreatePopupShell("XMake5_Help", 
X                                    transientShellWidgetClass,
X                                    toplevel, NULL, ZERO);
X    XtSetArg(args[0], XtNiconPixmap, icon_map);
X    XtSetValues(help_shell, args, 1);
X
X    pane = XtCreateManagedWidget("vpane", panedWidgetClass, help_shell,
X                                    NULL, ZERO);
X
X    XtCreateManagedWidget("help_win_label",
X                        labelWidgetClass,pane,NULL,ZERO);
X    help_win = XtCreateManagedWidget("help_win",
X                          asciiTextWidgetClass, pane, NULL, ZERO);
X    XtSetArg(args[0], XtNstring, helptext);
X    XtSetValues(help_win, args, ONE);
X
X    XtCreateManagedWidget("rec_win_label",
X                        labelWidgetClass,pane,NULL,ZERO);
X    rec_win = XtCreateManagedWidget("rec_win",
X                          asciiTextWidgetClass, pane, NULL, ZERO);
X    update_move_record();
X
X    XtCreateManagedWidget("score_win_label",
X                        labelWidgetClass,pane,NULL,ZERO);
X    score_win = XtCreateManagedWidget("score_win",
X                          asciiTextWidgetClass, pane, NULL, ZERO);
X    refresh_high_score();
X}
X/**********************************************************************/
Xstatic void add_menu_items1(button)
X    Widget button;
X{
X    static Widget menu,adjust;
X    static void set_level_item(), set_order_item();
X
X#define add_one_menu_line \
X    XtCreateManagedWidget("line",smeLineObjectClass,menu,NULL,ZERO);
X#define add_one_menu_item(w,name,callback,parameter) \
X    w = XtCreateManagedWidget(name,smeBSBObjectClass,menu,NULL,ZERO); \
X    XtAddCallback(w, XtNcallback, callback, (XtPointer) parameter);
X
X    menu = XtCreatePopupShell("setupMenu", simpleMenuWidgetClass, 
X                          button, NULL, ZERO);
X    add_one_menu_line;
X    add_one_menu_item(sound_switch,"sound_switch",set_sound_level,NULL);
X    add_one_menu_line;
X    add_one_menu_item(play_order[0],"order_cc",set_order_item,0);
X    add_one_menu_item(play_order[1],"order_cm",set_order_item,1);
X    add_one_menu_item(play_order[2],"order_mc",set_order_item,2);
X    add_one_menu_item(play_order[3],"order_mm",set_order_item,3);
X    add_one_menu_line;
X    add_one_menu_item(play_level[0],"level1",set_level_item,1);
X    add_one_menu_item(play_level[1],"level2",set_level_item,2);
X    add_one_menu_item(play_level[2],"level3",set_level_item,3);
X    add_one_menu_item(play_level[3],"level4",set_level_item,4);
X    add_one_menu_item(play_level[4],"level5",set_level_item,5);
X    add_one_menu_line;
X    add_one_menu_item(undo,"undo",Undo_B,NULL);
X    add_one_menu_line;
X    add_one_menu_item(adjust,"adjust",adjust_board,NULL);
X    add_one_menu_line;
X    add_one_menu_item(challenge_level[0],"challenge2",set_challenge_level,2);
X    add_one_menu_item(challenge_level[1],"challenge3",set_challenge_level,3);
X    add_one_menu_item(challenge_level[2],"challenge4",set_challenge_level,4);
X    add_one_menu_item(challenge_level[3],"challenge5",set_challenge_level,5);
X}  
X/**********************************************************************/
Xstatic void add_menu_items2(button)
X    Widget button;
X{
X    static Widget menu, where;
X
X    menu = XtCreatePopupShell("q_Menu", simpleMenuWidgetClass, 
X                          button, NULL, ZERO);
X    add_one_menu_item(where,"where",Where_B,NULL);
X    add_one_menu_item(suggest,"suggest",suggestion,NULL);
X}  
X/**********************************************************************/
X#define set_one_sec_alarm \
X    XtAppAddTimeOut(app_con,1000,check_computer_move,0)
X
X/**********************************************************************/
X/*                      Setup Options                                 */
X/**********************************************************************/
Xstatic void
Xset_challenging(sw) int sw;
X{ Boolean sensitive;
X  int i;
X    if (sw) { challenging = 1;  sensitive = FALSE;  } 
X    else    { challenging = 0;  sensitive = TRUE; }
X    XtSetSensitive(undo,sensitive);
X    XtSetSensitive(suggest,sensitive);
X    for (i=0; i<4; i++) {
X      XtSetSensitive(play_order[i],sensitive);
X      XtSetSensitive(play_level[i],sensitive);
X    }
X    XtSetSensitive(play_level[4],sensitive);
X}
X/**********************************************************************/
Xstatic void
Xset_play_order(n) int n;
X{
X    player_name[0] = player_order_names[n][0];
X    player_name[1] = player_order_names[n][1];
X    set_one_sec_alarm;
X}
X/**********************************************************************/
Xstatic void
Xset_sound_level()
X{
X  Arg args[1];
X    if (sound_level)  XtSetArg(args[0], XtNlabel,"Sound ON        (Key:S)");
X    else              XtSetArg(args[0], XtNlabel,"Sound OFF       (Key:S)");
X    sound_level = !sound_level;
X    XtSetValues(sound_switch, args, 1);
X    update_status_label();
X}
X/**********************************************************************/
X#define set_level_n(n)  if (challenging) return;  \
X                        set_play_level(n); update_status_label()
Xstatic void set_level_1() { set_level_n(1); }
Xstatic void set_level_2() { set_level_n(2); }
Xstatic void set_level_3() { set_level_n(3); }
Xstatic void set_level_4() { set_level_n(4); }
Xstatic void set_level_5() { set_level_n(5); }
X/**********************************************************************/
Xset_play_level(n) int n;
X{
X    current_level = n;
X    min_depth = min_depths[current_level];
X    max_depth = max_depths[current_level];
X}
X/**********************************************************************/
Xstatic void
Xset_level_item(w, client_data, garbage)
XWidget w;
XXtPointer client_data;
XXtPointer garbage;  /* call_data */
X{
X    set_play_level((int) client_data);
X    update_status_label();
X}
X/**********************************************************************/
Xstatic void
Xset_challenge_level(w, client_data, garbage)
XWidget w;
XXtPointer client_data;
XXtPointer garbage;  /* call_data */
X{
X    set_challenging(1);
X    set_play_level((int) client_data);
X    set_play_order(1);    /* computer first */
X    update_status_label();
X    Restart_B();
X}
X/**********************************************************************/
Xstatic void
Xset_order_item(w, client_data, garbage)
XWidget w;
XXtPointer client_data;
XXtPointer garbage;  /* call_data */
X{
X    set_play_order((int) client_data);
X    update_status_label();
X}
X/**********************************************************************/
X/*                      Update Status                                 */
X/**********************************************************************/
Xstatic char *(player_color[2])={"Black","White"};
Xstatic char *(sound_status[2])={"off","on"};
Xupdate_status_label() 
X{
X  char s[250], *player_prompt;
X  Arg args[1];
X  int t1,t2;
X
X    if (player_name[player] == 'C') {
X        if (player_name[1-player] == 'C')
X              player_prompt = "Click for Demo";
X        else  player_prompt = "Computer's turn";
X    } else {
X        if (challenging)
X              player_prompt = "Challenging";
X        else  player_prompt = "Human's turn";
X    }
X    sprintf(s,"Step:%d  P%d (%s)  %s  (Level:%d) (sound %s)",
X            step, player+1, player_color[player], player_prompt,
X            current_level, sound_status[sound_level]);
X    XtSetArg(args[0], XtNlabel, s);
X    XtSetValues(status_label, args, 1);
X    if (sound_level) {
X      if (warning_msg[0] != 0)  XBell(display,sound_level);
X      if (game_over)  { 
X         XBell(display,sound_level); XBell(display,sound_level);
X      } 
X    }
X    t1=get_timer(0);
X    t2=get_timer(1);
X    sprintf(s,"P1(%d:%d)  %s  P2(%d:%d)",
X            t1/60,t1%60,warning_msg,t2/60,t2%60);
X    XtSetArg(args[0], XtNlabel, s);
X    XtSetValues(warning_label, args, 1);
X}
X/**********************************************************************/
Xupdate_status() 
X{
X    update_status_label();
X    switch_color(player);
X}
X/**********************************************************************/
X/*                        CALL BACK functions                         */
X/**********************************************************************/
Xstatic void
XQuit_B(w, text_ptr, call_data)
XWidget w;  XtPointer text_ptr, call_data;
X{
X    XtDestroyApplicationContext(XtWidgetToApplicationContext(w)); 
X    exit(0);
X}
X/**********************************************************************/
Xstatic void
XRestart_B()
X{
X    init_board();
X    redraw_board();
X    set_one_sec_alarm;
X    reset_timer(0);  reset_timer(1); start_timer(0);
X    refresh_high_score();
X}
X/**********************************************************************/
Xstatic void
XWhere_B()
X{
X    to_last_position();
X}
X/**********************************************************************/
X#define back_one_move { int x = move_rec[last_move_rec--]; \
X    take_out(x); \
X    board_stones[BoardX(x)][BoardY(x)] = empty_stone; }
X/**********************************************************************/
Xstatic void
XUndo_B()
X{
X    int x;
X    if (challenging) return;
X    num_of_suggestion = 0;
X    if (step > 2 || (step == 2 && player == 1)) {
X      back_one_move;
X      back_one_move;
X      update_move_record();
X      step--;
X      x = move_rec[last_move_rec];
X      warning_msg = get_warning(1-player,x);
X      game_over = is_game_over(1-player,x);
X      redraw_board();
X    } 
X    else Restart_B();
X}
X/**********************************************************************/
Xstatic void
XWindows_B(w, text_ptr, call_data)
XWidget w;  XtPointer text_ptr, call_data;
X{   Arg args[1];
X    char *s;
X    help_win_switch = !help_win_switch;
X    if (help_win_switch)  {
X      s="Close Sub Window";
X      XtPopup(help_shell,XtGrabNone);
X    } else {
X      s="Open Sub Window";
X      XtPopdown(help_shell);
X    }
X    XtSetArg(args[0], XtNlabel, s);
X    XtSetValues(windows_B, args, 1);
X}
X/**********************************************************************/
Xstatic void suggestion()
X{
X  int best;
X
X    if (challenging) return;
X    if (game_over) return;
X    best = computer_suggest(player);
X    draw_suggestions();
X    warp_to_position(BoardX(best),BoardY(best));
X}
X/**********************************************************************/
X/*           All about making moves                                   */
X/**********************************************************************/
Xinit_board()
X{   int i,j;
X
X    for (i=0; i < BoardLines; i++)
X      for (j=0; j < BoardLines; j++)
X        board_stones[i][j] = empty_stone;
X    step = 1; player = 0;  
X    last_move_rec = 0;
X    update_move_record();
X    warning_msg = "";
X    game_over = 0;
X    num_of_suggestion = 0;
X    init_data();
X}
X/**********************************************************************/
Xvoid make_a_move(x)
X    int x;
X{   int new_high_score=0, num_step, used_time;
X
X    pause_timer(player);
X    unmark_last_move();
X    move_rec[++last_move_rec] = x;
X    clear_mark_stone();
X    put_stone(BoardX(x), BoardY(x), player);
X    set_on(x,player);
X    warning_msg = get_warning(player,x);
X    game_over = is_game_over(player,x);
X    XFlush(display);
X    if (game_over && challenging) {
X      if (player==1) {  /* human win */
X        new_high_score = 1;
X        num_step = step;
X        used_time = get_timer(1);
X        warning_msg = "Congratulation! You win.";
X      }
X      set_challenging(0);
X    }
X    player = 1 - player;
X    if (player==0) step++;
X    mark_last_move();
X    update_status();
X    update_move_record();
X    XFlush(display);
X    if (new_high_score) {
X        add_score_record(current_level,num_step,used_time);
X        refresh_high_score();
X    }
X    start_timer(player);
X}
X/**********************************************************************/
Xvoid make_computer_move()
X{
X    if (player_name[player] != 'C') return;
X    if (!game_over)  make_a_move(computer_move(player));
X}
X/**********************************************************************/
Xvoid check_computer_move()
X{
X    char s[250];
X    Arg args[1];
X
X    if (player_name[player] != 'C') return;
X    if (!game_over) {
X      sprintf(s,"Step:%d  Computer's thinking.... (Level:%d)",
X              step,current_level);
X      XtSetArg(args[0], XtNlabel, s);
X      XtSetValues(status_label, args, 1);
X      XFlush(display);
X      XtAppAddTimeOut(app_con,100,make_computer_move,0);
X    }
X}
X/**********************************************************************/
Xstatic void update_move_record()
X{ Arg args[1];
X  char line[30];
X  int i,n,x1,x2;
X    strcpy(move_rec_text,"Step   P1      P2\n--------------------\n");
X    for (i=1,n=last_move_rec/2; i<=n; i++) {
X        x1=move_rec[i*2-1];
X        x2=move_rec[i*2];
X        sprintf(line,"%3d  (%2d,%2d) (%2d,%2d)\n",
X                      i, x1/BoardSize, x1%BoardSize, 
X                         x2/BoardSize, x2%BoardSize);
X        strcat(move_rec_text,line);
X    }
X    if (n*2 != last_move_rec) {
X        x1=move_rec[last_move_rec];
X        sprintf(line,"%3d  (%2d,%2d)\n",
X                      i, x1/BoardSize, x1%BoardSize);
X        strcat(move_rec_text,line);
X    }
X    XtSetArg(args[0], XtNstring, move_rec_text);
X    XtSetValues(rec_win, args, ONE);
X    XawTextSetInsertionPoint(rec_win,99999);
X}
X/**********************************************************************/
END_OF_FILE
if test 24060 -ne `wc -c <'xmake5.c'`; then
    echo shar: \"'xmake5.c'\" unpacked with wrong size!
fi
# end of 'xmake5.c'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
