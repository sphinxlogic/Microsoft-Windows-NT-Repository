Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i082:  x4war2 - An X11 version of Chinese four-state war game (Ver. 1.1), Part01/04
Message-ID: <2793@master.CNA.TEK.COM>
Date: 25 Apr 92 00:49:20 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1741
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Xiaobing Chen <xiaobing@cs.sfu.ca>
Posting-number: Volume 13, Issue 82
Archive-name: x4war2/Part01
Supersedes: x4war: Volume 13, Issue 77-79
Environment: X11, Xlib, Xt

	[This is an updated version of the previously posted 'x4war'. In
	 addition to feature enhancements and bugfixes, it includes a set
	 of pictoral bitmaps in addition to the original chinese character
	 bitmaps. (Comment out the -DCHINESE define in the [I]Makefile.)
			-br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 4)."
# Contents:  README MANIFEST bgbitmap.c bitmaps bitmaps/chinese_piece
#   bitmaps/image_piece bitmaps/war_logo.xbm war.c war.h
# Wrapped by billr@saab on Fri Apr 24 17:36:55 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(3469 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
Xx4war - An X11 version of Chinese four-state war game.
X
X
XWHAT IS IT?
X
XThis is a board game which implements the Chinese four-state war game in the
XX Window environment. It allows four players to play the game on four displays,
Xeach coordinating a complete army, players at the opposite position of the
Xplaying board are allied. The goal of the game is to capture the COLOURS of
Xthe enemy.
X
XI heard it's sort of like the American game 'stratego'.
X
X
XCOMPILING
X
XThe program is implemented using Xlib and Xt. It should be compilable in
Xmost of  X11/R4 environment. Presently the program is tested only under
XSunOS 4.1.1 and IRIX 4.0.1 System V.
X
XThere are two sets of bitmaps which can be used for the faces of pieces, one
Xis in Chiese characters under subdirectory ./bitmaps/chinese_piece, the other
Xis drawings under subdirectory ./bitmaps/image_piece. When you
Xcompile, you can select one of the bitmaps set.
X
X
X1) select a set of bitmaps
X
XIf you want to use the Chinese character bitmaps, nothing needs to be changed.
X
XIf you want to use the image bitmaps, edit Makefile.simple to define DEFS to
Xempty, or comment out DEFINES definition in Imakefile if you use Imakefile.
X
X
X2) compilation.
X
XIf you use Makefile.simple, the steps are as follows:
X
X	%make -f Makefile.simple bgbitmap
X		to get 'bgbitmap' for creating the background of the board.
X
X	%bgbitmap
X		wait for a second and a background bitmap file called
X		'war_background.xbm' will be created in the bitmaps
X		subdirectory.
X
X	%make -f Makefile.simple
X		this will get you the 'x4war' executable.
X
X
XIf you use Imakefile, you can type 'xmkmf' to get a Makefile, then use the above
Xcommands for Makefile.simple with '-f Makefile.simple' omitted.
X
XThe file 'x4war' is enough for the game. Other files can be removed after you
Xget the 'x4war' file.
X
X
XUSAGE
X
XType 'x4war -usage' to get command options.
X
XFor the meaning of the pieces and rules of the game, please consult one who can
Xread Chinese characters and knows the conventional rules. Also read x4war.man
Xfor detail.
X
X
XACKNOWLEDGEMENTS
X
XSpecial thanks to Zhongmin Guo, Bo Wang, Ju Wu, and Danpo Zhang, who created
Xmost of the bitmaps and had given many valuable suggestions. And many thanks
Xto my fellow students at School of Computing Science and Engineering Science,
XSimon Fraser University, who had helped to test the program and given all
Xkinds of support.
X
XI'm also grateful to those who, after the first release of the program, 
Xcommunicated with me via e-mail and gave me suggestions about the program.
XEspecially to Reece Peacock (nrp@btcase.bt.co.uk), who provided most of the
Xbitmaps in ./bitmaps/image_piece, and kindly granted me the permission to
Xdistribute them to the public.
X
X
XCOPYRIGHT
X
XCopyright 1992 by Xiaobing Chen
X
XPermission to use, copy, and distribute for non-commercial purposes,
Xis hereby granted without fee, providing that the above copyright
Xnotice appear in all copies and that both the copyright notice and this
Xpermission notice appear in supporting documentation. 
X
XThe software may be modified for your own purposes, but modified versions
Xmay not be distributed without prior consent of the the author.
X
XThis software is provided "as is" without any expressed or implied warranty.
X
XThe author may be contacted via:
X    Address:   Xiaobing Chen
X               School of Computing Science
X               Simon Fraser University  
X               Burnaby, B.C.,  V5A 1S6
X	       Canada
X
X    EMail:     xiaobing@cs.sfu.ca       
X
X
X
X
END_OF_FILE
if test 3469 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1770 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Imakefile                  4	
X MANIFEST                   1	This shipping list
X Makefile.simple            4	
X Patchlevel                 4	
X README                     1	
X bgbitmap.c                 1	
X bitmaps                    1	
X bitmaps/back0.xbm          4	
X bitmaps/back1.xbm          4	
X bitmaps/back2.xbm          4	
X bitmaps/back3.xbm          4	
X bitmaps/chinese_piece      1	
X bitmaps/chinese_piece/bomb.xbm  3	
X bitmaps/chinese_piece/brigadier.xbm  3	
X bitmaps/chinese_piece/captain.xbm  3	
X bitmaps/chinese_piece/colonel.xbm  3	
X bitmaps/chinese_piece/colours.xbm  3	
X bitmaps/chinese_piece/f_lieutenant.xbm  3	
X bitmaps/chinese_piece/general.xbm  3	
X bitmaps/chinese_piece/m_general.xbm  3	
X bitmaps/chinese_piece/major.xbm  3	
X bitmaps/chinese_piece/marshal.xbm  3	
X bitmaps/chinese_piece/mine.xbm  3	
X bitmaps/chinese_piece/sapper.xbm  3	
X bitmaps/cursor.xbm         4	
X bitmaps/cursormask.xbm     2	
X bitmaps/go.xbm             3	
X bitmaps/image_piece        1	
X bitmaps/image_piece/bomb.xbm  3	
X bitmaps/image_piece/brigadier.xbm  3	
X bitmaps/image_piece/captain.xbm  3	
X bitmaps/image_piece/colonel.xbm  3	
X bitmaps/image_piece/colours.xbm  3	
X bitmaps/image_piece/f_lieutenant.xbm  3	
X bitmaps/image_piece/general.xbm  3	
X bitmaps/image_piece/m_general.xbm  3	
X bitmaps/image_piece/major.xbm  3	
X bitmaps/image_piece/marshal.xbm  3	
X bitmaps/image_piece/mine.xbm  4	
X bitmaps/image_piece/sapper.xbm  3	
X bitmaps/nodemask.xbm       3	
X bitmaps/pillar.xbm         4	
X bitmaps/stop.xbm           2	
X bitmaps/war_logo.xbm       1	
X war.c                      1	
X war.h                      1	
X x4war.c                    2	
X x4war.man                  3	
END_OF_FILE
if test 1770 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'bgbitmap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bgbitmap.c'\"
else
echo shar: Extracting \"'bgbitmap.c'\" \(14959 characters\)
sed "s/^X//" >'bgbitmap.c' <<'END_OF_FILE'
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#include <X11/Xatom.h>
X
X#include <stdio.h>
X
X#include "war.h"
X
XDisplay *display;
Xint screen_num;
XGC gc, undraw_gc;
XPixmap pixmap;
X
X
Xvoid main(argc, argv)
Xint argc;
Xchar **argv;
X{
X	XFontStruct *font_info;
X	XGCValues values;
X
X	if ((display = XOpenDisplay(NULL)) == NULL) {
X	    fprintf(stderr, "cannot open display\n");
X	    exit(-1);
X	}
X	screen_num = DefaultScreen(display);
X
X	pixmap = XCreatePixmap(display, RootWindow(display, screen_num),
X		DIMENSION, DIMENSION, 1);
X
X	font_info = XLoadQueryFont(display, "9x15bold");
X
X	values.arc_mode = ArcChord;
X
X	values.foreground = 0;
X	values.background = 1;
X	undraw_gc = XCreateGC(display, pixmap, GCForeground | GCBackground |
X		GCArcMode, &values);
X
X	values.foreground = 1;
X	values.background = 0;
X
X	values.font = font_info->fid;
X	gc = XCreateGC(display, pixmap, GCForeground|GCBackground|GCFont,
X		&values);
X
X	printf("'war_background.xbm' file will be created at ./bitmaps\n");
X	printf("please wait a second...\n");
X	draw();
X
X	XWriteBitmapFile(display, "war_background", pixmap,
X			DIMENSION, DIMENSION, -1, -1);
X	system("mv ./war_background ./bitmaps/war_background.xbm");
X
X	printf("completed!\n");
X
X	XUnloadFont(display, font_info->fid);
X	XFreeGC(display, gc);
X	XFreeGC(display, undraw_gc);
X	XCloseDisplay(display);
X	exit(0);
X}
X
X
X
Xdraw()
X{
X    static unsigned char dash_list[] = {10, 10};
X    int i, j;
X
X    XFillRectangle(display, pixmap, undraw_gc, 0, 0, DIMENSION, DIMENSION);
X
X    XDrawString(display, pixmap, gc, 110, 575, "DEATH ANGEL", 11);
X    XDrawString(display, pixmap, gc, 695, 628, "NEW GAME", 8);
X    XDrawString(display, pixmap, gc, 695, 668, "START WAR", 9);
X    XDrawString(display, pixmap, gc, 695, 708, "REDEPLOY", 8);
X    XDrawString(display, pixmap, gc, 695, 748, "PEACE", 5);
X    XDrawString(display, pixmap, gc, 695, 788, "SURRENDER", 9);
X    XDrawString(display, pixmap, gc, 695, 828, "QUIT", 4);
X
X    XSetLineAttributes(display, gc, 5, LineOnOffDash, CapButt, JoinMiter);
X    XSetDashes(display, gc, 0, dash_list, 2);
X
X    XDrawLine(display, pixmap, gc, P3, P1+50, P3, P6-50);
X    XDrawLine(display, pixmap, gc, P4, P1+50, P4, P6-50);
X    XDrawLine(display, pixmap, gc, P1+50, P3, P6-50, P3);
X    XDrawLine(display, pixmap, gc, P1+50, P4, P6-50, P4);
X
X    XDrawLine(display, pixmap, gc, P3, P1+50, P4, P1+50);
X    XDrawLine(display, pixmap, gc, P3, P2, P4, P2);
X    XDrawLine(display, pixmap, gc, P3, P5, P4, P5);
X    XDrawLine(display, pixmap, gc, P3, P6-50, P4, P6-50);
X
X    XDrawLine(display, pixmap, gc, P1+50, P3, P1+50, P4);
X    XDrawLine(display, pixmap, gc, P2, P3, P2, P4);
X    XDrawLine(display, pixmap, gc, P5, P3, P5, P4);
X    XDrawLine(display, pixmap, gc, P6-50, P3, P6-50, P4);
X
X    XDrawLine(display, pixmap, gc, P2, P3+100, P5, P3+100);
X    XDrawLine(display, pixmap, gc, P3+100, P2, P3+100, P5);
X
X    XDrawArc(display, pixmap, gc, P2-50, P2-50, 100, 100, 0, -90*64);
X    XDrawArc(display, pixmap, gc, P4, P2-50, 100, 100, 180*64, 90*64);
X    XDrawArc(display, pixmap, gc, P2-50, P4, 100, 100, 0, 90*64);
X    XDrawArc(display, pixmap, gc, P4, P4, 100, 100, 90*64, 90*64);
X
X    XSetLineAttributes(display, gc, 1, LineSolid, CapButt, JoinRound);
X
X    XDrawArc(display, pixmap, gc, P2-52, P2-52, 104, 104, 0, -90*64);
X    XDrawArc(display, pixmap, gc, P2-48, P2-48,  96,  96, 0, -90*64);
X    XDrawArc(display, pixmap, gc, P4-2, P2-52, 104, 104, 180*64, 90*64);
X    XDrawArc(display, pixmap, gc, P4+2, P2-48,  96,  96, 180*64, 90*64);
X    XDrawArc(display, pixmap, gc, P2-52, P4-2, 104, 104, 0, 90*64);
X    XDrawArc(display, pixmap, gc, P2-48, P4+2,  96,  96, 0, 90*64);
X    XDrawArc(display, pixmap, gc, P4-2, P4-2, 104, 104, 90*64, 90*64);
X    XDrawArc(display, pixmap, gc, P4+2, P4+2,  96,  96, 90*64, 90*64);
X
X    XDrawLine(display, pixmap, gc, P3-2, P1+50, P3-2, P6-50);
X    XDrawLine(display, pixmap, gc, P3+2, P1+50, P3+2, P6-50);
X    XDrawLine(display, pixmap, gc, P4-2, P1+50, P4-2, P6-50);
X    XDrawLine(display, pixmap, gc, P4+2, P1+50, P4+2, P6-50);
X    XDrawLine(display, pixmap, gc, P1+50, P3-2, P6-50, P3-2);
X    XDrawLine(display, pixmap, gc, P1+50, P3+2, P6-50, P3+2);
X    XDrawLine(display, pixmap, gc, P1+50, P4-2, P6-50, P4-2);
X    XDrawLine(display, pixmap, gc, P1+50, P4+2, P6-50, P4+2);
X
X    XDrawLine(display, pixmap, gc, P3, P1+48, P4, P1+48);
X    XDrawLine(display, pixmap, gc, P3, P1+52, P4, P1+52);
X    XDrawLine(display, pixmap, gc, P3, P2-2, P4, P2-2);
X    XDrawLine(display, pixmap, gc, P3, P2+2, P4, P2+2);
X    XDrawLine(display, pixmap, gc, P3, P5-2, P4, P5-2);
X    XDrawLine(display, pixmap, gc, P3, P5+2, P4, P5+2);
X    XDrawLine(display, pixmap, gc, P3, P6-52, P4, P6-52);
X    XDrawLine(display, pixmap, gc, P3, P6-48, P4, P6-48);
X
X    XDrawLine(display, pixmap, gc, P1+48, P3, P1+48, P4);
X    XDrawLine(display, pixmap, gc, P1+52, P3, P1+52, P4);
X    XDrawLine(display, pixmap, gc, P2-2, P3, P2-2, P4);
X    XDrawLine(display, pixmap, gc, P2+2, P3, P2+2, P4);
X    XDrawLine(display, pixmap, gc, P5-2, P3, P5-2, P4);
X    XDrawLine(display, pixmap, gc, P5+2, P3, P5+2, P4);
X    XDrawLine(display, pixmap, gc, P6-48, P3, P6-48, P4);
X    XDrawLine(display, pixmap, gc, P6-52, P3, P6-52, P4);
X
X    XDrawLine(display, pixmap, gc, P2, P3+98, P5, P3+98);
X    XDrawLine(display, pixmap, gc, P2, P3+102, P5, P3+102);
X    XDrawLine(display, pixmap, gc, P3+98, P2, P3+98, P5);
X    XDrawLine(display, pixmap, gc, P3+102, P2, P3+102, P5);
X
X    for (i=RIP_Y+50; i<RIP_Y+RIP_DIMENSION; i += 50)
X	XDrawLine(display, pixmap, gc, P1, i, P1+RIP_DIMENSION, i);
X    for (i=P1+50; i<P1+RIP_DIMENSION; i += 50)
X	XDrawLine(display, pixmap, gc, i, RIP_Y, i, RIP_Y+RIP_DIMENSION);
X
X    for (i=P3+50; i<P4; i += 50)
X	XDrawLine(display, pixmap, gc, i, P5, i, P6);
X    for (i=P5+50; i<P6-50; i += 50)
X	XDrawLine(display, pixmap, gc, P3, i, P4, i);
X    XDrawLine(display, pixmap, gc, P3, P5, P4, P6-50);
X    XDrawLine(display, pixmap, gc, P3, P5+100, P3+100, P6-50);
X    XDrawLine(display, pixmap, gc, P3+100, P5, P4, P5+100);
X    XDrawLine(display, pixmap, gc, P3, P6-50, P4, P5);
X    XDrawLine(display, pixmap, gc, P3, P5+100, P3+100, P5);
X    XDrawLine(display, pixmap, gc, P3+100, P6-50, P4, P5+100);
X
X    for (i=P3+50; i<P4; i += 50)
X	XDrawLine(display, pixmap, gc, i, P1, i, P2);
X    for (i=P1+100; i<P2; i += 50)
X	XDrawLine(display, pixmap, gc, P3, i, P4, i);
X    XDrawLine(display, pixmap, gc, P3, P1+50, P4, P2);
X    XDrawLine(display, pixmap, gc, P3, P2-100, P3+100, P2);
X    XDrawLine(display, pixmap, gc, P3+100, P1+50, P4, P2-100);
X    XDrawLine(display, pixmap, gc, P3, P2-100, P3+100, P1+50);
X    XDrawLine(display, pixmap, gc, P3, P2, P4, P1+50);
X    XDrawLine(display, pixmap, gc, P3+100, P2, P4, P2-100);
X
X    for (i=P3+50; i<P4; i += 50)
X	XDrawLine(display, pixmap, gc, P1, i, P2, i);
X    for (i=P1+100; i<P2; i += 50)
X	XDrawLine(display, pixmap, gc, i, P3, i, P4);
X    XDrawLine(display, pixmap, gc, P1+50, P3+100, P2-100, P4);
X    XDrawLine(display, pixmap, gc, P1+50, P3, P2, P4);
X    XDrawLine(display, pixmap, gc, P2-100, P3, P2, P3+100);
X    XDrawLine(display, pixmap, gc, P1+50, P3+100, P2-100, P3);
X    XDrawLine(display, pixmap, gc, P2, P3, P1+50, P4);
X    XDrawLine(display, pixmap, gc, P2-100, P4, P2, P3+100);
X
X    for (i=P3+50; i<P4; i += 50)
X	XDrawLine(display, pixmap, gc, P5, i, P6, i);
X    for (i=P5+50; i<P6-50; i += 50)
X	XDrawLine(display, pixmap, gc, i, P3, i, P4);
X    XDrawLine(display, pixmap, gc, P5, P3+100, P5+100, P4);
X    XDrawLine(display, pixmap, gc, P5, P3, P6-50, P4);
X    XDrawLine(display, pixmap, gc, P5+100, P3, P6-50, P3+100);
X    XDrawLine(display, pixmap, gc, P5, P3+100, P5+100, P3);
X    XDrawLine(display, pixmap, gc, P5, P4, P6-50, P3);
X    XDrawLine(display, pixmap, gc, P5+100, P4, P6-50, P3+100);
X
X    XSetLineAttributes(display, gc, 3, LineSolid, CapButt, JoinRound);
X
X    XDrawRectangle(display, pixmap, gc, TALK_L_X,TALK_Y,TALK_WIDTH,TALK_HEIGHT);
X    XDrawRectangle(display, pixmap, gc, TALK_L_X, TALK_Y+90,
X		TALK_WIDTH, TALK_HEIGHT);
X    XDrawRectangle(display, pixmap, gc, TALK_R_X,TALK_Y,TALK_WIDTH,TALK_HEIGHT);
X    XDrawRectangle(display, pixmap, gc, TALK_R_X, TALK_Y+90,
X		TALK_WIDTH, TALK_HEIGHT);
X
X    XDrawRectangle(display, pixmap, gc, P1, P1, 66, 66);
X    XDrawRectangle(display, pixmap, gc, MSG_BOX_X, MSG_BOX_Y,
X		MSG_WIDTH, MSG_HEIGHT);
X
X    XDrawLine(display, pixmap, gc, P3-1, P1-1, P3-1, P1+50);
X    XDrawLine(display, pixmap, gc, P4+1, P1-1, P4+1, P1+50);
X    XDrawLine(display, pixmap, gc, P3-1, P1-1, P4+1, P1-1);
X
X    XDrawLine(display, pixmap, gc, P3-1, P6-50, P3-1, P6+1);
X    XDrawLine(display, pixmap, gc, P4+1, P6-50, P4+1, P6+1);
X    XDrawLine(display, pixmap, gc, P3-1, P6+1, P4+1, P6+1);
X
X    XDrawLine(display, pixmap, gc, P6-50, P3-1, P6+1, P3-1);
X    XDrawLine(display, pixmap, gc, P6-50, P4+1, P6+1, P4+1);
X    XDrawLine(display, pixmap, gc, P6+1, P3-1, P6+1, P4+1);
X
X    XDrawLine(display, pixmap, gc, P1-1, P3-1, P1+50, P3-1);
X    XDrawLine(display, pixmap, gc, P1-1, P4+1, P1+50, P4+1);
X    XDrawLine(display, pixmap, gc, P1-1, P3-1, P1-1, P4+1);
X
X    XDrawRectangle(display, pixmap, gc, P1, RIP_Y, 
X	RIP_DIMENSION-1,RIP_DIMENSION-1);
X
X    for (i=NEW_Y; i<=NEW_Y+BUTTON_DIS*5; i += BUTTON_DIS)
X	XDrawRectangle(display, pixmap, gc, BUTTON_X, i,
X	    BUTTON_WIDTH, BUTTON_HEIGHT);
X
X    XSetLineAttributes(display, gc, 2, LineSolid, CapButt, JoinRound);
X
X    XFillArc(display, pixmap, undraw_gc, P3+30, P1+80, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P3+30, P1+80, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P4-70, P1+80, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P4-70, P1+80, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P3+80, P2-120, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P3+80, P2-120, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P3+30, P2-70, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P3+30, P2-70, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P4-70, P2-70, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P4-70, P2-70, 40, 40, 0, 360*64);
X
X    XFillArc(display, pixmap, undraw_gc, P5+30, P3+30, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P5+30, P3+30, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P5+30, P4-70, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P5+30, P4-70, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P5+80, P3+80, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P5+80, P3+80, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P6-120, P3+30, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P6-120, P3+30, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P6-120, P4-70, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P6-120, P4-70, 40, 40, 0, 360*64);
X
X    XFillArc(display, pixmap, undraw_gc, P1+80, P3+30, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P1+80, P3+30, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P1+80, P4-70, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P1+80, P4-70, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P1+130, P3+80, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P1+130, P3+80, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P2-70, P3+30, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P2-70, P3+30, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P2-70, P4-70, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P2-70, P4-70, 40, 40, 0, 360*64);
X
X    XFillArc(display, pixmap, undraw_gc, P3+30, P5+30, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P3+30, P5+30, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P3+30, P6-120, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P3+30, P6-120, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P3+80, P5+80, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P3+80, P5+80, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P4-70, P5+30, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P4-70, P5+30, 40, 40, 0, 360*64);
X    XFillArc(display, pixmap, undraw_gc, P4-70, P6-120, 40, 40, 0, 360*64);
X    XDrawArc(display, pixmap, gc, P4-70, P6-120, 40, 40, 0, 360*64);
X
X    for (i=P3-15; i<P4; i += 100)
X      for (j=P3-15; j<P4; j += 100) {
X	XFillRectangle(display, pixmap, undraw_gc, i, j, 30, 30);
X	XDrawRectangle(display, pixmap, gc, i, j, 29, 29);
X    }
X
X    for (i=P3-20; i<P4; i += 50)
X      for (j=P5-10; j<P6; j += 50)
X	if (i==P3+30 && j==P5+40 || i==P4-70 && j==P5+40 ||
X		i==P3+80 && j==P5+90 ||
X	    i==P3+30 && j==P6-110 || i==P4-70 && j==P6-110 )
X	    ;
X	else {
X	    XFillRectangle(display, pixmap, undraw_gc, i, j, 40, 20);
X	    XDrawRectangle(display, pixmap, gc, i, j, 40, 20);
X	}
X
X    for (i=P3-20; i<P4; i += 50)
X      for (j=P1-10; j<P2; j += 50)
X	if (i==P3+30 && j==P1+90 || i==P4-70 && j==P1+90 ||
X		i==P3+80 && j==P2-110 ||
X	    i==P3+30 && j==P2-60 || i==P4-70 && j==P2-60 )
X	    ;
X	else {
X	    XFillRectangle(display, pixmap, undraw_gc, i, j, 40, 20);
X	    XDrawRectangle(display, pixmap, gc, i, j, 40, 20);
X	}
X
X    for (i=P1-10; i<P2; i += 50)
X      for (j=P3-20; j<P4; j += 50)
X	if (i==P1+90 && j==P3+30 || i==P2-60 && j==P3+30 ||
X		i==P2-110 && j==P3+80 ||
X	    i==P1+90 && j==P4-70 || i==P2-60 && j==P4-70)
X	    ;
X	else {
X	    XFillRectangle(display, pixmap, undraw_gc, i, j, 20, 40);
X	    XDrawRectangle(display, pixmap, gc, i, j, 20, 40);
X	}
X
X    for (i=P5-10; i<P6; i += 50)
X      for (j=P3-20; j<P4; j += 50)
X	if (i==P5+40 && j==P3+30 || i==P6-110 && j==P3+30 ||
X		i==P5+90 && j==P3+80 ||
X	    i==P5+40 && j==P4-70 || i==P6-110 && j==P4-70)
X	    ;
X	else {
X	    XFillRectangle(display, pixmap, undraw_gc, i, j, 20, 40);
X	    XDrawRectangle(display, pixmap, gc, i, j, 20, 40);
X	}
X
X    XFillArc(display, pixmap, undraw_gc, P3+35, P1-14, 30, 30, 210*64, 120*64);
X    XDrawArc(display, pixmap, gc, P3+35, P1-14, 30, 30, 215*64, 110*64);
X    XFillArc(display, pixmap, undraw_gc, P4-65, P1-14, 30, 30, 210*64, 120*64);
X    XDrawArc(display, pixmap, gc, P4-65, P1-14, 30, 30, 215*64, 110*64);
X
X    XFillArc(display, pixmap, undraw_gc, P3+35, P6-16, 30, 30, 30*64, 120*64);
X    XDrawArc(display, pixmap, gc, P3+35, P6-16, 30, 30, 35*64, 110*64);
X    XFillArc(display, pixmap, undraw_gc, P4-65, P6-16, 30, 30, 30*64, 120*64);
X    XDrawArc(display, pixmap, gc, P4-65, P6-16, 30, 30, 35*64, 110*64);
X
X    XFillArc(display, pixmap, undraw_gc, P1-14, P3+35, 30, 30, 60*64, -120*64);
X    XDrawArc(display, pixmap, gc, P1-14, P3+35, 30, 30, 55*64, -110*64);
X    XFillArc(display, pixmap, undraw_gc, P1-14, P4-65, 30, 30, 60*64, -120*64);
X    XDrawArc(display, pixmap, gc, P1-14, P4-65, 30, 30, 55*64, -110*64);
X
X    XFillArc(display, pixmap, undraw_gc, P6-16, P3+35, 30, 30, 120*64, 120*64);
X    XDrawArc(display, pixmap, gc, P6-16, P3+35, 30, 30, 125*64, 110*64);
X    XFillArc(display, pixmap, undraw_gc, P6-16, P4-65, 30, 30, 120*64, 120*64);
X    XDrawArc(display, pixmap, gc, P6-16, P4-65, 30, 30, 125*64, 110*64);
X}
X
X
X
X
X
END_OF_FILE
if test 14959 -ne `wc -c <'bgbitmap.c'`; then
    echo shar: \"'bgbitmap.c'\" unpacked with wrong size!
fi
# end of 'bgbitmap.c'
fi
if test ! -d 'bitmaps' ; then
    echo shar: Creating directory \"'bitmaps'\"
    mkdir 'bitmaps'
fi
if test ! -d 'bitmaps/chinese_piece' ; then
    echo shar: Creating directory \"'bitmaps/chinese_piece'\"
    mkdir 'bitmaps/chinese_piece'
fi
if test ! -d 'bitmaps/image_piece' ; then
    echo shar: Creating directory \"'bitmaps/image_piece'\"
    mkdir 'bitmaps/image_piece'
fi
if test -f 'bitmaps/war_logo.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/war_logo.xbm'\"
else
echo shar: Extracting \"'bitmaps/war_logo.xbm'\" \(3291 characters\)
sed "s/^X//" >'bitmaps/war_logo.xbm' <<'END_OF_FILE'
X#define war_logo_width 64
X#define war_logo_height 64
Xstatic char war_logo_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0x00, 0x06, 0x7f, 0x0f, 0x00, 0x00,
X   0x00, 0x06, 0x00, 0x07, 0x66, 0x04, 0x00, 0x00, 0x00, 0x06, 0x00, 0x06,
X   0x66, 0x04, 0x00, 0x00, 0x00, 0x06, 0x00, 0x06, 0x66, 0x04, 0x00, 0x00,
X   0x00, 0x06, 0x00, 0x06, 0x6e, 0x04, 0x1f, 0xce, 0x01, 0x06, 0xf0, 0x06,
X   0xee, 0x82, 0x38, 0x2c, 0x03, 0x06, 0x8c, 0x07, 0xcc, 0x42, 0x70, 0x1c,
X   0x03, 0x06, 0x04, 0x07, 0xec, 0x62, 0x60, 0x0c, 0x00, 0x06, 0x06, 0x06,
X   0xdc, 0x63, 0x60, 0x0c, 0x00, 0x06, 0x06, 0x06, 0xdc, 0x61, 0x60, 0x0c,
X   0x00, 0x06, 0x06, 0x06, 0x98, 0x61, 0x60, 0x0c, 0x00, 0x06, 0x06, 0x06,
X   0x98, 0xe1, 0x20, 0x0c, 0x00, 0x06, 0x0e, 0x07, 0x98, 0xc1, 0x11, 0x0c,
X   0x00, 0x06, 0x9c, 0x06, 0x98, 0x81, 0x0f, 0x1e, 0x80, 0x1f, 0x78, 0x0e,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x73, 0x7e, 0xf0, 0x03, 0x00, 0x00,
X   0x00, 0x80, 0x73, 0xee, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x80, 0x73, 0xe0,
X   0xe0, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7f, 0xf8, 0xe0, 0x00, 0x00, 0x00,
X   0x00, 0x80, 0x7f, 0xfc, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7f, 0xee,
X   0xe1, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7f, 0xee, 0xe1, 0x00, 0x00, 0x00,
X   0x00, 0x80, 0x73, 0xfc, 0xf1, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x1f, 0x7c, 0xf0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x38,
X   0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x38, 0xe0, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x0e, 0x38, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x38,
X   0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x38, 0xe0, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x0e, 0x38, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x38,
X   0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x38, 0xe0, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x0e, 0x38, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x7c,
X   0xf0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
X
X
X
X
END_OF_FILE
if test 3291 -ne `wc -c <'bitmaps/war_logo.xbm'`; then
    echo shar: \"'bitmaps/war_logo.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/war_logo.xbm'
fi
if test -f 'war.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'war.c'\"
else
echo shar: Extracting \"'war.c'\" \(21998 characters\)
sed "s/^X//" >'war.c' <<'END_OF_FILE'
X#include "war.h"
X
Xextern Arr arr[4][6][5], mid[3][3];
X
Xextern Sapper_path sap[];
X
Xextern int round;
X
X/*******************************************************************
X*
X*   Synopsis
X*	fatal_error(s)
X*	    char *s;
X*
X*   Description
X*	it prints s as an error message and exit.
X*
X*******************************************************************/
X
Xfatal_error(s)
Xchar *s;
X{
X    printf("%s\n", s);
X    exit(-1);
X}
X
X
X
X/****************************************************************
X*
X*   Synopsis
X*	syntax(s)
X*	    char *s;
X*
X*   Argument
X*	s	the program name, usually x4war;
X*
X*   Description
X*	x4war command line arguments specification
X*
X****************************************************************/
X
Xsyntax(s)
Xchar *s;
X{
X    printf("Usage: %s [options ...]\n\n", s);
X    printf("where options include:\n");
X    printf("\t-p0 string\t\tplayer0's name\n");
X    printf("\t-d0 string\t\tplayer0's display\n");
X    printf("\t-c0 string\t\tplayer0's node color\n");
X    printf("\t-p1 string\t\tplayer1's name\n");
X    printf("\t-d1 string\t\tplayer1's display\n");
X    printf("\t-c1 string\t\tplayer1's node color\n");
X    printf("\t-p2 string\t\tplayer2's name\n");
X    printf("\t-d2 string\t\tplayer2's display\n");
X    printf("\t-c2 string\t\tplayer2's node color\n");
X    printf("\t-p3 string\t\tplayer3's name\n");
X    printf("\t-d3 string\t\tplayer3's display\n");
X    printf("\t-c3 string\t\tplayer3's node color\n");
X    printf("\t-two \t\t\tplay a two players game\n");
X    printf("\t-debug\t\t\ta default deploy\n");
X    printf("\t-usage\t\t\tthis usage list\n");
X    printf("\t-help\t\t\tthis usage list\n\n");
X}
X
X
X
X/***********************************************************************
X *
X *  Synopsis
X *	int fight(x, y)
X *	    int x, y;
X *
X *  Arguments
X *	x, y	representing two node values between COLOURS and BOMB.
X *		x must be a movable, i.e., not COLOURS and MINE.
X *
X *  Return values
X *	x < y: return 2;
X *	x = y: return 3;
X *	x > y: return 4;
X *
X *  Description
X *	it returns the fighting result when node x moved to meet node y.
X *
X ***********************************************************************/
X
Xint fight(x, y)
Xint x, y;
X{
X    if (x==SAPPER && y==MINE)  return(4);
X    if (x==BOMB || y==BOMB)  return(3);
X    if (x==y) return(3);
X    if (x<y)  return(2);
X    if (x>y)  return(4);
X}
X
X
X/**********************************************************************
X*
X*   Synopsis
X*	int boardtofield(x, y, i, j)
X*	    int x, y;
X*	    int *i, *j;		return values
X*
X*   Arguments
X*	x, y	coordinates of a point on board;
X*	*i, *j  contain the converted field coordinates;
X*
X*   Return values
X*	return a value from F0 to OTHERPLACE according to the position (x,y),
X*	i and j are set if returned values between F0 and RIP.
X*
X***********************************************************************/
X
Xint boardtofield(x, y, i, j)
Xint x, y, *i, *j;
X{
X    if (x>=315 && x<=555 && y>=565 && y<=855) {
X	*j = (x-310)/50;
X	*i = (y-560)/50;
X	return(F0);
X    }
X    if (x>=565 && x<=855 && y>=315 && y<=555) {
X	*i = (x-560)/50;
X	*j = 4-(y-310)/50;
X	return(F1);
X    }
X    if (x>=315 && x<=555 && y>=15 && y<=305) {
X	*i = 5-(y-10)/50;
X	*j = 4-(x-310)/50;
X	return(F2);
X    }
X    if (x>=15 && x<=305 && y>=315 && y<=555) {
X	*i = 5-(x-10)/50;
X	*j = (y-310)/50;
X	return(F3);
X    }
X    if (x>=315 && x<=555 && y>=315 && y<=555) {
X	*j = (x-310)/100;
X	*i = (y-310)/100;
X	return(MIDFIELD);
X    }
X    if (x>=35 && x<=285 && y>=585 && y<=835) {
X	*j = (x-35)/50;
X	*i = (y-585)/50;
X	return(RIP);
X    }
X
X    if (x>=BUTTON_X && x<=BUTTON_X + BUTTON_WIDTH) {
X	if (y>=610 && y<=635)  return(NEW);
X	if (y>=650 && y<=675)  return(READY);
X	if (y>=690 && y<=715)  return(REDEPLOY);
X	if (y>=730 && y<=755)  return(PEACE);
X	if (y>=770 && y<=795)  return(SURRENDER);
X	if (y>=810 && y<=835)  return(QUIT);
X    }
X    return(OTHERPLACE);
X}
X
X
X
X/********************************************************************
X*
X*   Synopsis
X*	fieldtoboard(f, i, j, x, y)
X*	    int f, i, j;
X*	    int *x, *y;		return
X*
X*   Arguments
X*	f	field id between F0 and RIP;
X*	i, j	coordinates of the field;
X*	*x, *y	contains returned values of coordinates of the board;
X*
X*********************************************************************/
X
Xfieldtoboard(f, i, j, x, y)
Xint f, i, j, *x, *y;
X{
X    switch (f) {
X      case F0:
X	*x = 335+j*50;
X	*y = 585+i*50;
X	break;
X      case F1:
X	*x = 585+i*50;
X	*y = 335+(4-j)*50;
X	break;
X      case F2:
X	*x = 335+(4-j)*50;
X	*y = 35+(5-i)*50;
X	break;
X      case F3:
X	*x = 35+(5-i)*50;
X	*y = 335+j*50;
X	break;
X      case MIDFIELD:
X	*x = 335+j*100;
X	*y = 335+i*100;
X	break;
X      case RIP:
X	*x = 60+j*50;
X	*y = 610+i*50;
X    }
X}
X
X
X
X/**********************************************************************
X*
X*   Synopsis
X*	arrtoboard(id, g, i, j, x, y)
X*	    int id, g, i, j;
X*	    int *x, *y;		return
X*
X*   Arguments
X*	id	0-3, specifies the player of the board;
X*	g	F0 - RIP, which array;
X*	i, j	coordinates of the array;
X*	*x, *y  contains the results;
X*
X**********************************************************************/
X
Xarrtoboard(id, g, i, j, x, y)
Xint id, g, i, j, *x, *y;
X{
X    int k;
X
X    if (g==MIDFIELD)
X	switch (id) {
X	  case 1:
X	    k = i;  i = j;  j = 2-k;
X	    break;
X	  case 2:
X	    i = 2-i;  j = 2-j;
X	    break;
X	  case 3:
X	    k = i;  i = 2-j; j = k;
X	}
X    else if (g != RIP) {
X	g -= id;
X	if (g<0) g += 4;
X    }
X    fieldtoboard(g,i,j,x,y);
X}
X
X
X
X
X
X/*********************************************************************
X*
X*   Synopsis
X*	int fieldtoarr(id, f, fi, fj, ai, aj)
X*	    int id, f, fi, fj;
X*	    int *ai, *aj;
X*
X*   Arguments
X*	id	0-3, the player of the board;
X*	f	F0 - RIP, field number;
X*	fi, fj	coordinates in the field;
X*	*ai, *aj	result coordinates of the array;
X*
X*   Return value
X*	returns which array is resulted
X*
X**********************************************************************/
X
Xint fieldtoarr(id, f, fi, fj, ai, aj)
Xint id, f, fi, fj, *ai, *aj;
X{
X    *ai = fi;
X    *aj = fj;
X    if ( f==MIDFIELD )
X	switch (id) {
X	  case 1:
X	    *ai = 2-fj; *aj = fi;
X	    break;
X	  case 2:
X	    *ai = 2 - fi; *aj = 2 - fj;
X	    break;
X	  case 3:
X	    *ai = fj;  *aj = 2 - fi;
X	}
X    return((f>=F0 && f<MIDFIELD) ? (f+id)%4 : f);
X}
X
X
X
X/*********************************************************************
X*
X*   Synopsis
X*	int boardtoarr(f, x, y, i, j)
X*	    int f, x, y, *i, *j;
X*
X*   Arguments
X*	f	specifies who's board;
X*	x, y	the coordinates on board;
X*	*i, *j	return the coordinates in the array;
X*
X*   Return value
X*	it returns which array the point corresponds.
X*	returns -1 if no array to match.
X*
X**********************************************************************/
X
Xint boardtoarr(f, x, y, i, j)
Xint f, x, y, *i, *j;
X{
X    int m, n, s;
X
X    s = boardtofield(x, y, &m, &n);
X    if (s > RIP) return(-1);
X    s = fieldtoarr(f, s, m, n, i, j);
X    return(s);
X}
X
X
X
X
X/************************************************************************
X*
X*   Synopsis
X*	int area_intersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2,
X*		cx1, cy1, cx2, cy2)
X*	    int ax1, ay1, ax2, ay2, bx1, by1, bx2, by2;
X*	    int *cx1, *cy1, *cx2, *cy2;		return
X*
X*   Arguments
X*	a's and b's:	coordinates of two rectangles;
X*	c's		contains the coordinates of the intersection area;
X*
X*   Return values
X*	1	if the two rectangles intersect, and c's are set;
X*	0	if the two rectangles not intersect;
X*
X**************************************************************************/
X
Xint area_intersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2,
X	    cx1, cy1, cx2, cy2)
Xint ax1, ay1, ax2, ay2, bx1, by1, bx2, by2, *cx1, *cy1, *cx2, *cy2;
X{
X    int k;
X
X    if (ax1>ax2) {
X	k = ax1; ax1 = ax2; ax2 = k;
X    }
X    if (ay1>ay2) {
X	k = ay1; ay1 = ay2; ay2 = k;
X    }
X    if (bx1>bx2) {
X	k = bx1; bx1 = bx2; bx2 = k;
X    }
X    if (by1>by2) {
X	k = by1; by1 = by2; by2 = k;
X    }
X    *cx2 = (ax2<bx2) ? ax2 : bx2;
X    *cy2 = (ay2<by2) ? ay2 : by2;
X    if (ax1<=bx1 && ay1<=by1 && bx1<ax2 && by1<ay2) {
X	*cx1 = bx1;  *cy1 = by1;
X	return(1);
X    }
X    if (ax1<=bx1 && ay1>by1 && ay1<by2 && ax2>bx1) {
X	*cx1 = bx1; *cy1 = ay1;
X	return(1);
X    }
X    if (ax1>bx1 && ay1>by1 && ax1<bx2 && ay1<by2) {
X	*cx1 = ax1; *cy1 = ay1;
X	return(1);
X    }
X    if (ax1>bx1 && ay1<by1 && ax1<bx2 && ay2>by1) {
X	*cx1 = ax1; *cy1 = by1;
X	return(1);
X    }
X    return(0);
X}
X
X
X
X
X/**********************************************************************
X*
X*   Synopsis
X*	int sapper_check(i, x, y, z)
X*	    int i, x, y, z;
X*
X*   Arguments
X*	i	start check from i of sap[];
X*	x, y, z the destination;
X*
X*   Return values
X*	0	if cannot reach destination;
X*	1	if can reach destination;
X*
X*   Side effect
X*	mark all visited nodes to round.
X*
X*   Description
X*	it recursively checks if a SAPPER can reach a destination, starting
X*	from a position in sap[i]; sap[i] must not have been visited, and
X*	the starting position must not be the destination.
X*
X***********************************************************************/
X
Xint sapper_check(i, x, y, z)
Xint i, x, y, z;
X{
X    int m, n, a, b, c, j;
X
X    sap[i].visited = round;
X    m = 0;
X    if (i<12) {
X	a = i/3;
X	c = 2*(i%3);
X	if (c==0) {
X	    n = (a-1);
X	    if (n<0)  n = 3;
X	    if (y==0 && z==4 && x==n)  return(1);
X	    if (sap[n*3+2].visited != round && arr[n][0][4].value == EMPTY)
X		m = sapper_check(n*3+2, x, y, z);
X	    if (m) return(1);
X
X	    n = sap[i].neighbor[0];
X	    b = (n-12)/3;
X	    c = (n-12)%3;
X	    if (x==MIDFIELD && y==b && z==c)  return(1);
X	    if (sap[n].visited != round && mid[b][c].value == EMPTY)
X		m = sapper_check(n, x, y, z);
X	    if (m) return(1);
X
X	    if (x==a && y==0 && z==1)  return(1);
X	    if (arr[a][0][1].value == EMPTY) {
X		if (x==a && y==0 && z==2)  return(1);
X		if (sap[a*3+1].visited != round && arr[a][0][2].value == EMPTY)
X		    m = sapper_check(a*3+1, x, y, z);
X		if (m) return(1);
X	    }
X
X	    if (a==x || sap[a*3+2].visited != round) {
X		if (a==x && z==0) {
X		    for (j=1; j<y; j++)
X			if (arr[a][j][0].value != EMPTY) return(0);
X		    return(1);
X		}
X		for (j=1; j<5; j++)
X		    if (arr[a][j][0].value != EMPTY) return(0);
X		if (a==x && y==4) {
X		    for (j=1; j<z; j++)
X			if (arr[a][4][j].value != EMPTY) return(0);
X		    return(1);
X		}
X		for (j=1; j<5; j++)
X		    if (arr[a][4][j].value != EMPTY) return(0);
X		if (a==x && z==4) {
X		    for (j=y+1; j<4; j++)
X			if (arr[a][j][4].value != EMPTY) return(0);
X		    return(1);
X		}
X		if (sap[a*3+2].visited == round) return(0);
X		for (j=0; j<4; j++)
X		    if (arr[a][j][4].value != EMPTY) return(0);
X		return(sapper_check(a*3+2, x, y, z));
X	    }
X	    return(0);
X	}
X	if (c==2) {
X	    if (a==x && y==0 && z==1)  return(1);
X	    if (arr[a][0][1].value == EMPTY) {
X		if (a==x && y==0 && z==0)  return(1);
X		if (sap[a*3].visited != round && arr[a][0][0].value == EMPTY)
X		    m = sapper_check(a*3, x, y, z);
X		if (m) return(1);
X	    }
X	    n = sap[i].neighbor[0];
X	    b = (n-12)/3;
X	    c = (n-12)%3;
X	    if (x==MIDFIELD && y==b && z==c)  return(1);
X	    if (sap[n].visited != round && mid[b][c].value == EMPTY)
X		m = sapper_check(n, x, y, z);
X	    if (m) return(1);
X
X	    if (a==x && y==0 && z==3)  return(1);
X	    if (arr[a][0][3].value == EMPTY) {
X		if (a==x && y==0 && z==4)  return(1);
X		if (sap[a*3+2].visited != round && arr[a][0][4].value == EMPTY)
X		    m = sapper_check(a*3+2, x, y, z);
X		if (m) return(1);
X	    }
X	    return(0);
X	}
X	/* now c==4 */
X	if (a==x && y==0 && z==3)  return(1);
X	if (arr[a][0][3].value == EMPTY) {
X	    if (a==x && y==0 && z==2)  return(1);
X	    if (sap[a*3+1].visited != round && arr[a][0][2].value == EMPTY)
X		m = sapper_check(a*3+1, x, y, z);
X	    if (m) return(1);
X	}
X	n = sap[i].neighbor[0];
X	b = (n-12)/3;
X	c = (n-12)%3;
X	if (x==MIDFIELD && b==y && c==z)  return(1);
X	if (sap[n].visited != round && mid[b][c].value == EMPTY)
X	    m = sapper_check(n, x, y, z);
X	if (m) return(1);
X	n = (a+1)%4;
X	if (x==n && y==0 && z==0)  return(1);
X	if (sap[n*3].visited != round && arr[n][0][0].value == EMPTY)
X	    m = sapper_check(n*3, x, y, z);
X	if (m) return(1);
X
X	if (sap[a*3].visited != round || a==x) {
X	    if (a==x && z==4) {
X		for (j=1; j<y; j++)
X		    if (arr[a][j][4].value != EMPTY) return(0);
X		return(1);
X	    }
X	    for (j=1; j<5; j++)
X		if (arr[a][j][4].value != EMPTY) return(0);
X	    if (a==x && y==4) {
X		for (j=z+1; j<4; j++)
X		    if (arr[a][4][j].value != EMPTY) return(0);
X		return(1);
X	    }
X	    for (j=0; j<4; j++)
X		if (arr[a][4][j].value != EMPTY) return(0);
X	    if (a==x && z==0) {
X		for (j=y+1; j<4; j++)
X		    if (arr[a][j][0].value != EMPTY) return(0);
X		return(1);
X	    }
X	    if (sap[a*3].visited == round) return(0);
X	    for (j=0; j<4; j++)
X		if (arr[a][j][0].value != EMPTY) return(0);
X	    return(sapper_check(a*3, x, y, z));
X	}
X	return(0);
X    }
X    else {	/* starting position in the MIDFIELD */
X	j = 0;
X	while (!m && j<4) {
X	    n = sap[i].neighbor[j];
X	    if (sap[n].visited != round)
X		if (n<12) {
X		    a = n/3;
X		    c = 2*(n%3);
X		    if (x==a && y==0 && z==c) return(1);
X		    if (arr[a][0][c].value == EMPTY)
X			m = sapper_check(n, x, y, z);
X		}
X		else {
X		    b = (n-12)/3;
X		    c = (n-12)%3;
X		    if (x==MIDFIELD && y==b && z==c)  return(1);
X		    if (mid[b][c].value == EMPTY)
X			m = sapper_check(n, x, y, z);
X		}
X	    j++;
X	}
X	return(m);
X    }
X}
X
X
X
X
X
X
X
X
X/**********************************************************************
X*
X*   Synopsis
X*	int valid_move(a, b, c, x, y, z)
X*	    int a, b, c, x, y, z;
X*
X*   Return values
X*	1	for valid move;
X*	0	for invalid move;
X*
X*   Description
X*	It checks if a move as (a,b,c)=>(x,y,z) is valid according to
X*	the positions;
X*
X***********************************************************************/
X
Xint valid_move(a, b, c, x, y, z)
Xint a, b, c, x, y, z;
X{
X    int m, n, i, l;
X
X    if ((a<MIDFIELD && x<MIDFIELD) && (b==5 || y==5 ||
X		(0<b && b<4 && 0<c && c<4) || (0<y && y<4 && 0<z && z<4))) {
X	/* can move only one step far */
X	if (a != x) return(0);
X	m = abs(b-y) + abs(c-z);
X	if (m<1 || m>2)  return(0);
X	if ( (abs(b-y)<2 && abs(c-z)<2) &&
X		(((b==1 || b==3) && (c==1 || c==3)) || (b==2 && c==2) ||
X		((y==1 || y==3) && (z==1 || z==3)) || (y==2 && z==2)))
X	    return(1);
X	if (m == 1) return(1);
X	else return(0);
X    }
X
X/* from now on, the source and the destination are both on the railway */
X    if (a==MIDFIELD && mid[b][c].value == SAPPER ||
X	a<MIDFIELD && arr[a][b][c].value == SAPPER) {
X	round++;
X	m = 0;
X	if (a<MIDFIELD && (b!=0 || (b==0 && (c==1 || c==3)))) {
X	    if (b==0)
X		if (c==1) {
X		    if (x==a && y==0 && (z==0 || z==2)) return(1);
X		    if (arr[a][0][0].value == EMPTY)
X			m = sapper_check(a*3, x, y, z);
X		    if (m) return(1);
X		    if (sap[a*3+1].visited!=round && arr[a][0][2].value==EMPTY)
X			m = sapper_check(a*3+1, x, y, z);
X		    return(m);
X		}
X		else {
X		    if (x==a && y==0 && (z==2 || z==4)) return(1);
X		    if (arr[a][0][2].value != EMPTY)
X			m = sapper_check(a*3+1, x, y, z);
X		    if (m) return(1);
X		    if (sap[a*3+2].visited!=round && arr[a][0][4].value==EMPTY)
X			m = sapper_check(a*3+2, x, y, z);
X		    return(m);
X		}
X	    else
X		if (c==0 || c==4) {
X		    if (a==x && z==c && y<b) {
X			for (i=y+1; i<b; i++)
X			    if (arr[a][i][c].value != EMPTY) break;
X			if (i==b) return(1);
X		    }
X		    else {
X			for (i=0; i<b; i++)
X			    if (arr[a][i][c].value != EMPTY) break;
X			if (i==b)
X			    m = sapper_check(a*3+(c/2), x, y, z);
X			if (m) return(1);
X		    }
X		    if (a==x || sap[a*3].visited != round ||
X				sap[a*3+2].visited != round) {
X			if (a==x && z==c && y>b) {
X			    for (i=b+1; i<y; i++)
X				if (arr[a][i][c].value != EMPTY) return(0);
X			    return(1);
X			}
X			for (i=b+1; i<5; i++)
X			    if (arr[a][i][c].value != EMPTY) return(0);
X			if (a==x && y==4)
X			    if (c==0) {
X				for (i=1; i<z; i++)
X				    if (arr[a][4][i].value != EMPTY) return(0);
X				return(1);
X			    }
X			    else {
X				for (i=z+1; i<4; i++)
X				    if (arr[a][4][i].value != EMPTY) return(0);
X				return(1);
X			    }
X			n = (c==0) ? 1 : 0;
X			for (i=0; i<4; i++)
X			    if (arr[a][4][i+n].value != EMPTY) return(0);
X			n = (c==0) ? 4 : 0;
X			if (a==x && n==z) {
X			    for (i=y+1; i<4; i++)
X				if (arr[a][i][n].value != EMPTY) return(0);
X			    return(1);
X			}
X			if (sap[a*3+n/2].visited == round) return(0);
X			for (i=0; i<4; i++)
X			    if (arr[a][i][n].value != EMPTY) return(0);
X			return(sapper_check(a*3+n/2, x, y, z));
X		    }
X		    return(0);
X		}
X		else {	    /* starting point is at the second bottom line */
X		    if (a==x && y==4 && z<c) {
X			for (i=z+1; i<c; i++)
X			    if (arr[a][4][i].value != EMPTY) break;
X			if (i==c) return(1);
X		    }
X		    else
X			for (i=0; i<c; i++)
X			    if (arr[a][4][i].value != EMPTY) break;
X		    if (i==c) {
X			if (a==x && y<4 && z==0) {
X			    for (i=y+1; i<4; i++)
X				if (arr[a][i][0].value != EMPTY) break;
X			    if (i==4) return(1);
X			}
X			else
X			    for (i=0; i<4; i++)
X				if (arr[a][i][0].value != EMPTY) break;
X			if (i==4) {
X			    m = sapper_check(a*3, x, y, z);
X			    if (m) return(1);
X			}
X		    }
X		    if (a==x || sap[a*3].visited != round ||
X				sap[a*3+2].visited != round) {
X			if (a==x && y==4 && z>c) {
X			    for (i=c+1; i<z; i++)
X				if (arr[a][4][i].value != EMPTY) return(0);
X			    return(1);
X			}
X			for (i=c+1; i<5; i++)
X			    if (arr[a][4][i].value != EMPTY) return(0);
X			if (a==x && y<4 && z==4) {
X			    for (i=y+1; i<4; i++)
X				if (arr[a][i][4].value != EMPTY) return(0);
X			    return(1);
X			}
X			if (sap[a*3+2].visited==round) return(0);
X			for (i=0; i<4; i++)
X			    if (arr[a][i][4].value != EMPTY) return(0);
X			return(sapper_check(a*3+2, x, y, z));
X		    }
X		    return(0);
X		}
X	}
X	else
X	    if (a<4)  return(sapper_check(a*3+c/2, x, y, z));
X	    else return(sapper_check(12+b*3+c, x, y, z));
X    }
X
X
X/* now the moving node is not a SAPPER */
X
X    if (a<MIDFIELD && a==x) {
X	if (b==y && (b==0 || b==4)) {
X	    if (c < z) {
X		m = c;  n = z;
X	    }
X	    else {
X		m = z;  n = c;
X	    }
X	    for (i=m+1; i<n; i++)
X		if (arr[a][b][i].value != EMPTY)  return(0);
X	    return(1);
X	}
X	else if (c==z && (c==0 || c==4)) {
X	    if (b < y) {
X		m = b;  n = y;
X	    }
X	    else {
X		m = y;  n = b;
X	    }
X	    for (i=m+1; i<n; i++)
X		if (arr[a][i][c].value != EMPTY) return(0);
X	    return(1);
X	}
X	else return(0);
X    }
X
X/* from now on the source and the destination are on different fields */
X    if (a != MIDFIELD)
X	if (c==0 || c==4) {
X	    for (i=0; i<b; i++)
X		if (arr[a][i][c].value != EMPTY) return(0);
X	}
X	else
X	    if (b!=0 || c!=2) return(0);
X    if (x != MIDFIELD)
X	if (z==0 || z==4) {
X	    for (i=0; i<y; i++)
X		if (arr[x][i][z].value != EMPTY) return(0);
X	}
X	else
X	    if (y!=0 || z!=2) return(0);
X
X    if (a<MIDFIELD && x<MIDFIELD) {
X	if ((x+1)%4 == a)
X	    if (z==4 && c==0)  return(1);
X	    else return(0);
X	else if ((a+1)%4 == x)
X	    if (z==0 && c==4) return(1);
X	    else return(0);
X	if (!((c==0 && z==4) || (c==4 && z==0) || (c==2 && z==2)))
X	    return(0);
X    }
X
X/* now the move has to go across the MIDFIELD */
X    if ((a<MIDFIELD && a%2==0) || (x<MIDFIELD && x%2==0) ||
X	(a==MIDFIELD && x==MIDFIELD && c==z)) {
X	if (a != MIDFIELD) {
X	    if (a==F0) {
X		l = c/2;
X		n = 2;
X		m = (x==MIDFIELD) ? (y+1) : 0;
X	    }
X	    else {
X		l = (4-c)/2;
X		m = 0;
X		n = (x==MIDFIELD) ? (y-1) : 2;
X	    }
X	    if (x==MIDFIELD && l!=z) return(0);
X	}
X	else
X	    if (x != MIDFIELD) {
X		if (x==F0) {
X		    l = z/2;
X		    m = b+1;
X		    n = 2;
X		}
X		else {
X		    l = (4-z)/2;
X		    m = 0;
X		    n = b-1;
X		}
X		if (l != c)  return(0);
X	    }
X	    else {
X		l = z;
X		if (b<y) {
X		    m = b+1; n = y-1;
X		}
X		else {
X		    m = y+1; n = b-1;
X		}
X	    }
X
X	for (i=m; i<=n; i++)
X	    if (mid[i][l].value != EMPTY) return(0);
X	return(1);
X    }
X
X    if ((a<MIDFIELD && a%2!=0) || (x<MIDFIELD && x%2!=0) ||
X	(a==MIDFIELD && x==MIDFIELD && b==y)) {
X	if (a != MIDFIELD) {
X	    if (a==F1) {
X		l = (4-c)/2;
X		n = 2;
X		m = (x==MIDFIELD) ? (z+1) : 0;
X	    }
X	    else {
X		l = c/2;
X		m = 0;
X		n = (x==MIDFIELD) ? (z-1) : 2;
X	    }
X	    if (x == MIDFIELD && l != y) return(0);
X	}
X	else
X	    if (x != MIDFIELD) {
X		if (x==F1) {
X		    l = (4-z)/2;
X		    m = c+1;
X		    n = 2;
X		}
X		else {
X		    l = z/2;
X		    m = 0;
X		    n = c-1;
X		}
X		if (l != b)  return(0);
X	    }
X	    else {
X		l = b;
X		if (c<z) {
X		    m = c+1; n = z-1;
X		}
X		else {
X		    m = z+1; n = c-1;
X		}
X	    }
X
X
X	for (i=m; i<=n; i++)
X	    if (mid[l][i].value != EMPTY) return(0);
X	return(1);
X    }
X
X    return(0);
X}
X
X
X/*************************************************************************
X*
X*   Synopsis
X*	initial_sapper()
X*
X*   Description
X*	initializes the array 'sap' of the sapper move checking path.
X*
X**************************************************************************/
X
Xinitial_sapper()
X{
X    int i;
X
X    round = 0;
X
X    for (i=0; i<21; i++)
X	sap[i].visited = 0;
X
X    sap[0].neighbor[0] = 18;
X    sap[1].neighbor[0] = 19;
X    sap[2].neighbor[0] = 20;
X    sap[3].neighbor[0] = 20;
X    sap[4].neighbor[0] = 17;
X    sap[5].neighbor[0] = 14;
X    sap[6].neighbor[0] = 14;
X    sap[7].neighbor[0] = 13;
X    sap[8].neighbor[0] = 12;
X    sap[9].neighbor[0] = 12;
X    sap[10].neighbor[0] = 15;
X    sap[11].neighbor[0] = 18;
X
X    sap[12].neighbor[0] = 9;
X    sap[12].neighbor[1] = 8;
X    sap[12].neighbor[2] = 13;
X    sap[12].neighbor[3] = 15;
X    sap[13].neighbor[0] = 12;
X    sap[13].neighbor[1] = 7;
X    sap[13].neighbor[2] = 14;
X    sap[13].neighbor[3] = 16;
X    sap[14].neighbor[0] = 13;
X    sap[14].neighbor[1] = 6;
X    sap[14].neighbor[2] = 5;
X    sap[14].neighbor[3] = 17;
X
X    sap[15].neighbor[0] = 10;
X    sap[15].neighbor[1] = 12;
X    sap[15].neighbor[2] = 16;
X    sap[15].neighbor[3] = 18;
X    sap[16].neighbor[0] = 15;
X    sap[16].neighbor[1] = 13;
X    sap[16].neighbor[2] = 17;
X    sap[16].neighbor[3] = 19;
X    sap[17].neighbor[0] = 16;
X    sap[17].neighbor[1] = 14;
X    sap[17].neighbor[2] = 4;
X    sap[17].neighbor[3] = 20;
X
X    sap[18].neighbor[0] = 11;
X    sap[18].neighbor[1] = 15;
X    sap[18].neighbor[2] = 19;
X    sap[18].neighbor[3] = 0;
X    sap[19].neighbor[0] = 18;
X    sap[19].neighbor[1] = 16;
X    sap[19].neighbor[2] = 20;
X    sap[19].neighbor[3] = 1;
X    sap[20].neighbor[0] = 19;
X    sap[20].neighbor[1] = 17;
X    sap[20].neighbor[2] = 3;
X    sap[20].neighbor[3] = 2;
X}
X
X
X
X
X
END_OF_FILE
if test 21998 -ne `wc -c <'war.c'`; then
    echo shar: \"'war.c'\" unpacked with wrong size!
fi
# end of 'war.c'
fi
if test -f 'war.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'war.h'\"
else
echo shar: Extracting \"'war.h'\" \(1787 characters\)
sed "s/^X//" >'war.h' <<'END_OF_FILE'
X#define DEFAULT_BOARD_BG "gray"
X#define DEFAULT_BOARD_FG "black"
X#define PLAYER0_COLOR "red"
X#define PLAYER1_COLOR "black"
X#define PLAYER2_COLOR "blue"
X#define PLAYER3_COLOR "purple"
X
X#define DIMENSION 870
X
X#define P1	35
X#define P2	285
X#define P3	335
X#define P4	535
X#define P5	585
X#define P6	835
X
X#define TALK_WIDTH 250
X#define TALK_HEIGHT 60
X#define TALK_Y	135		/* the y-coordinate for the upper talk
X				 * boxes. the lower talk box's is
X				 * TALK_Y+TALK_HEIGHT+30.
X				 */
X#define TALK_L_X P1
X#define TALK_R_X P5
X#define TALK_X_INC 9		/* char gap in x-direction of talk
X				 * string.
X				 */
X#define TALK_Y_INC 20
X#define TALK0_X  P1+5		/* talk string's x-coordinate for
X				 * player 0
X				 */
X#define TALK0_Y  TALK_Y+15
X#define TALK1_X  P5+5
X#define TALK1_Y  TALK_Y+15
X#define TALK2_X  P1+5
X#define TALK2_Y  TALK_Y+105
X#define TALK3_X  P5+5
X#define TALK3_Y  TALK_Y+105
X
X#define RIP_Y	585
X#define RIP_DIMENSION 250
X
X#define BUTTON_WIDTH 100
X#define BUTTON_HEIGHT 25
X#define BUTTON_X  685
X#define NEW_Y	610
X#define BUTTON_DIS  40
X
X#define MSG_BOX_X P5
X#define MSG_BOX_Y P1
X#define MSG_WIDTH 250
X#define MSG_HEIGHT 50
X#define MSG_X	592
X#define MSG_Y	53
X
X#define MAX_MSG 27
X
X#define SIGN_DIMENSION 64
X
X#define PILLAR -2
X#define EMPTY -1
X#define COLOURS 0
X#define SAPPER 1
X#define F_LIEUTENANT 2
X#define CAPTAIN 3
X#define MAJOR 4
X#define COLONEL 5
X#define BRIGADIER 6
X#define M_GENERAL 7
X#define GENERAL 8
X#define MARSHAL 9
X#define MINE 10
X#define BOMB 11
X
X#define F0 0
X#define F1 1
X#define F2 2
X#define F3 3
X#define MIDFIELD 4
X#define RIP 5
X#define NEW 6
X#define READY 7
X#define REDEPLOY 8
X#define PEACE 9
X#define SURRENDER 10
X#define QUIT 11
X#define OTHERPLACE 12
X
X
Xtypedef struct {
X	int id;
X	int value;
X} Arr;
X
X
Xtypedef struct {
X	int neighbor[4];
X	int visited;
X} Sapper_path;
X
X
X
X
X
END_OF_FILE
if test 1787 -ne `wc -c <'war.h'`; then
    echo shar: \"'war.h'\" unpacked with wrong size!
fi
# end of 'war.h'
fi
echo shar: End of archive 1 \(of 4\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
