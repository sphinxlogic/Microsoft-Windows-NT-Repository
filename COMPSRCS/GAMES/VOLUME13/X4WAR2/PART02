Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i083:  x4war2 - An X11 version of Chinese four-state war game (Ver. 1.1), Part02/04
Message-ID: <2794@master.CNA.TEK.COM>
Date: 25 Apr 92 00:49:56 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1950
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Xiaobing Chen <xiaobing@cs.sfu.ca>
Posting-number: Volume 13, Issue 83
Archive-name: x4war2/Part02
Supersedes: x4war: Volume 13, Issue 77-79
Environment: X11, Xlib, Xt



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 4)."
# Contents:  bitmaps/cursormask.xbm bitmaps/stop.xbm x4war.c
# Wrapped by billr@saab on Fri Apr 24 17:36:56 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'bitmaps/cursormask.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/cursormask.xbm'\"
else
echo shar: Extracting \"'bitmaps/cursormask.xbm'\" \(525 characters\)
sed "s/^X//" >'bitmaps/cursormask.xbm' <<'END_OF_FILE'
X#define cursormask_width 20
X#define cursormask_height 20
X#define cursormask_x_hot 9
X#define cursormask_y_hot 9
Xstatic char cursormask_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x0f, 0x00,
X   0xe0, 0x3f, 0x00, 0xf0, 0x7f, 0x00, 0xf0, 0x7f, 0x00, 0xf8, 0xff, 0x00,
X   0xf8, 0xff, 0x00, 0xf8, 0xff, 0x00, 0xf8, 0xff, 0x00, 0xf8, 0xff, 0x00,
X   0xf0, 0x7f, 0x00, 0xf0, 0x7f, 0x00, 0xe0, 0x3f, 0x00, 0x80, 0x0f, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
X
X
X
X
END_OF_FILE
if test 525 -ne `wc -c <'bitmaps/cursormask.xbm'`; then
    echo shar: \"'bitmaps/cursormask.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/cursormask.xbm'
fi
if test -f 'bitmaps/stop.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/stop.xbm'\"
else
echo shar: Extracting \"'bitmaps/stop.xbm'\" \(3279 characters\)
sed "s/^X//" >'bitmaps/stop.xbm' <<'END_OF_FILE'
X#define stop_width 64
X#define stop_height 64
Xstatic char stop_bits[] = {
X   0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff,
X   0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x0f, 0x00, 0x00,
X   0x00, 0x00, 0xfe, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff,
X   0xff, 0xff, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x03, 0xe0, 0xff, 0x01, 0x00,
X   0x00, 0xf0, 0x7f, 0x00, 0x00, 0xff, 0x07, 0x00, 0x00, 0xf8, 0x0f, 0x00,
X   0x00, 0xf8, 0x0f, 0x00, 0x00, 0xfc, 0x03, 0x00, 0x00, 0xe0, 0x1f, 0x00,
X   0x00, 0xfe, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x7f, 0x00, 0x00,
X   0x00, 0x00, 0x7f, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00,
X   0xc0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x01, 0xc0, 0x0f, 0x00, 0x00,
X   0x00, 0x00, 0xf8, 0x01, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x03,
X   0xf0, 0x03, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0xf0, 0x01, 0x00, 0x00,
X   0x00, 0x00, 0xc0, 0x07, 0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x0f,
X   0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x0f, 0xfc, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x80, 0x1f, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
X   0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x7e, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x3f, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e,
X   0x3e, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x3e, 0x3e, 0x00, 0x00, 0x60,
X   0x48, 0x00, 0x00, 0x3e, 0x1f, 0x00, 0x00, 0x20, 0xf9, 0x00, 0x00, 0x7c,
X   0x1f, 0x00, 0x00, 0x60, 0xf3, 0x81, 0x00, 0x7c, 0x1f, 0x00, 0x00, 0xe0,
X   0xff, 0xc3, 0x00, 0x7c, 0x1f, 0x00, 0x00, 0xe0, 0xff, 0xe7, 0x01, 0x7c,
X   0x1f, 0x00, 0x00, 0xe0, 0xfb, 0xff, 0x01, 0x7c, 0x1f, 0x00, 0x00, 0xe0,
X   0xf3, 0xff, 0x01, 0x7c, 0x1f, 0x00, 0x00, 0xe0, 0xe3, 0xff, 0x01, 0x7c,
X   0x1f, 0x00, 0x00, 0xe0, 0xc3, 0xff, 0x01, 0x7c, 0x1f, 0x00, 0x00, 0xe0,
X   0x83, 0xff, 0x01, 0x7c, 0x1f, 0x00, 0x00, 0xe0, 0xc3, 0xff, 0x01, 0x7c,
X   0x1f, 0x00, 0x00, 0xe0, 0xe3, 0xff, 0x03, 0x7c, 0x3e, 0x00, 0x00, 0xe0,
X   0xf3, 0xff, 0x03, 0x3e, 0x3e, 0x00, 0x00, 0xe0, 0x03, 0xff, 0x03, 0x3e,
X   0x3e, 0x00, 0x00, 0xe0, 0x03, 0xe0, 0x07, 0x3e, 0x7e, 0x00, 0x00, 0xe0,
X   0x03, 0x80, 0x07, 0x3f, 0x7c, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x04, 0x1f,
X   0x7c, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0xe0,
X   0x03, 0x00, 0x80, 0x1f, 0xf8, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x80, 0x0f,
X   0xf8, 0x01, 0x00, 0xe0, 0x03, 0x00, 0xc0, 0x0f, 0xf0, 0x01, 0x00, 0xe0,
X   0x03, 0x00, 0xc0, 0x07, 0xf0, 0x03, 0x00, 0xe0, 0x03, 0x00, 0xe0, 0x07,
X   0xe0, 0x07, 0x00, 0xe0, 0x03, 0x00, 0xf0, 0x03, 0xc0, 0x0f, 0x00, 0xe0,
X   0x03, 0x00, 0xf8, 0x01, 0xc0, 0x1f, 0x00, 0xe0, 0x03, 0x00, 0xfc, 0x01,
X   0x80, 0x3f, 0x00, 0xe0, 0x03, 0x00, 0xfe, 0x00, 0x80, 0x7f, 0x00, 0xe0,
X   0x03, 0x00, 0x7f, 0x00, 0x00, 0xfe, 0x00, 0xe0, 0x03, 0x80, 0x3f, 0x00,
X   0x00, 0xfc, 0x03, 0xe0, 0x03, 0xe0, 0x1f, 0x00, 0x00, 0xf8, 0x0f, 0xe0,
X   0x03, 0xf8, 0x0f, 0x00, 0x00, 0xf0, 0x7f, 0x00, 0x00, 0xff, 0x07, 0x00,
X   0x00, 0xc0, 0xff, 0x03, 0xe0, 0xff, 0x01, 0x00, 0x00, 0x80, 0xff, 0xff,
X   0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x3f, 0x00, 0x00,
X   0x00, 0x00, 0xf8, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff,
X   0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
X
X
X
X
END_OF_FILE
if test 3279 -ne `wc -c <'bitmaps/stop.xbm'`; then
    echo shar: \"'bitmaps/stop.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/stop.xbm'
fi
if test -f 'x4war.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'x4war.c'\"
else
echo shar: Extracting \"'x4war.c'\" \(45444 characters\)
sed "s/^X//" >'x4war.c' <<'END_OF_FILE'
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/X.h>
X#include <X11/Xos.h>
X#include <X11/Xatom.h>
X#include <X11/Intrinsic.h>
X#include <X11/keysym.h>
X
X#include <stdio.h>
X#include "war.h"
X
X#include "bitmaps/war_background.xbm"
X#include "bitmaps/war_logo.xbm"
X
X#ifdef CHINESE
X
X#include "bitmaps/chinese_piece/colours.xbm"
X#include "bitmaps/chinese_piece/marshal.xbm"
X#include "bitmaps/chinese_piece/general.xbm"
X#include "bitmaps/chinese_piece/m_general.xbm"
X#include "bitmaps/chinese_piece/brigadier.xbm"
X#include "bitmaps/chinese_piece/colonel.xbm"
X#include "bitmaps/chinese_piece/major.xbm"
X#include "bitmaps/chinese_piece/captain.xbm"
X#include "bitmaps/chinese_piece/f_lieutenant.xbm"
X#include "bitmaps/chinese_piece/sapper.xbm"
X#include "bitmaps/chinese_piece/mine.xbm"
X#include "bitmaps/chinese_piece/bomb.xbm"
X
X#else
X
X#include "bitmaps/image_piece/colours.xbm"
X#include "bitmaps/image_piece/marshal.xbm"
X#include "bitmaps/image_piece/general.xbm"
X#include "bitmaps/image_piece/m_general.xbm"
X#include "bitmaps/image_piece/brigadier.xbm"
X#include "bitmaps/image_piece/colonel.xbm"
X#include "bitmaps/image_piece/major.xbm"
X#include "bitmaps/image_piece/captain.xbm"
X#include "bitmaps/image_piece/f_lieutenant.xbm"
X#include "bitmaps/image_piece/sapper.xbm"
X#include "bitmaps/image_piece/mine.xbm"
X#include "bitmaps/image_piece/bomb.xbm"
X
X#endif
X
X#include "bitmaps/back0.xbm"
X#include "bitmaps/back1.xbm"
X#include "bitmaps/back2.xbm"
X#include "bitmaps/back3.xbm"
X
X#include "bitmaps/cursor.xbm"
X#include "bitmaps/cursormask.xbm"
X#include "bitmaps/nodemask.xbm"
X
X#include "bitmaps/go.xbm"
X#include "bitmaps/stop.xbm"
X
X#include "bitmaps/pillar.xbm"
X
Xstruct Player {
X    Display *dis;
X    int scr;		/* screen number of display *dis */
X    Window win, confirm;
X    Pixmap node[16];	/* 0-11 for faces of nodes, 12-15 for back and cursor */
X    Pixmap cursormask_pixmap,nodemask_pixmap,icon_pixmap,stop_pixmap,go_pixmap;
X    unsigned long fg[4];   /* foreground of nodes */
X    XColor fg_color, bg_color;
X    GC gc;
X    Cursor cursor, tmp_cursor;
X
X    char *display_name;
X    char player_name[10];
X    char color_name[20];
X    int rip[5][5];
X    int rip_index;
X    int state;		/* 0--dead, 1--deploy, 2--play, 3--quit */
X    int num_movable;
X    int popup;		/* 0--no popup, 1--Peace Request, 2--Quit,
X			   3--continue message*/
X			/* if confirm window is poped up, input is grabed */
X
X/* this structure tells if a node is picked up by pressing a button, it
X   records the array and subscripts of the node.
X*/
X    struct {
X	int arr;
X	int x, y;
X	int value;
X	Boolean picked;
X    } pick;
X    Boolean marshal_dead;
X    char talk_msg[3][30];
X    int talk_col;
X    int talk_x, talk_y;
X};
X
XXtAppContext app_context;
X
XArr arr[4][6][5], mid[3][3];	/* array to remember the state of the
X				   war */
X
Xstruct Player p[4];
X
XSapper_path sap[21];
X
XPixmap pillar[2];
XBoolean two;
X
Xunsigned int  global_argc;
Xchar ** global_argv;
Xchar *progname;
X
Xchar msg1[30], msg2[30];
Xchar confirm_msg[30];
X
Xint mode;	/* game mode */
X		/* 0 -- new game and deploy phase */
X		/* 1 -- play phase	*/
X		/* 2 -- peace request phase */
X		/* 3 -- one game finished */
X		/* 4 -- during a move */
X
Xint num_player; /* when one is defeated, this var decrease by 1 */
X
Xint count;	/* to calculate the flashing when node moved */
X		/* values and meanings
X		   8--clear source;
X		   7--show source;
X		   6--clear source;
X		   5--show source;
X		   4--clear source;
X		   3--show destination;
X		   2--clear destination;
X		   1--show destination;
X		   0--clear destination;
X		*/
Xint turn;		/* 0-3, specifies who's turn to move */
X
Xint round;
X
Xint sf, si, sj, sw, sv, df, di, dj, dw, dv;	/* record one move */
X
XBoolean debug;
X
Xstatic void refresh_board();
X
X
X/*******************************************************************
X*
X*   Synopsis
X*	parse_arguments(argc, argv)
X*	    int argc;
X*	    char **argv;
X*
X*   Description
X*	parses arguments in command line and set appropriate properties,
X*	exit if illegal argument present.
X*
X********************************************************************/
X
Xstatic void
Xparse_arguments(argc, argv)
Xint argc;
Xchar **argv;
X{
X    int i;
X
X    i = 1;
X    while (i<argc) {
X	if (!strcmp(argv[i], "-p0"))
X	    strncpy(p[0].player_name, argv[++i], 9);
X	else if (!strcmp(argv[i], "-d0"))
X	    p[0].display_name = argv[++i];
X	else if (!strcmp(argv[i], "-c0"))
X	    strncpy(p[0].color_name, argv[++i], 19);
X	else if (!strcmp(argv[i], "-p1"))
X	    strncpy(p[1].player_name, argv[++i], 9);
X	else if (!strcmp(argv[i], "-d1"))
X	    p[1].display_name = argv[++i];
X	else if (!strcmp(argv[i], "-c1"))
X	    strncpy(p[1].color_name, argv[++i], 19);
X	else if (!strcmp(argv[i], "-p2"))
X	    strncpy(p[2].player_name, argv[++i], 9);
X	else if (!strcmp(argv[i], "-d2"))
X	    p[2].display_name = argv[++i];
X	else if (!strcmp(argv[i], "-c2"))
X	    strncpy(p[2].color_name, argv[++i], 19);
X	else if (!strcmp(argv[i], "-p3"))
X	    strncpy(p[3].player_name, argv[++i], 9);
X	else if (!strcmp(argv[i], "-d3"))
X	    p[3].display_name = argv[++i];
X	else if (!strcmp(argv[i], "-c3"))
X	    strncpy(p[3].color_name, argv[++i], 19);
X	else if (!strcmp(argv[i], "-usage") || !strcmp(argv[i], "-help")) {
X	    syntax(argv[0]);
X	    exit(0);
X	}
X	else if (!strcmp(argv[i], "-two"))
X	    two = True;
X	else if (!strcmp(argv[i], "-debug"))
X	    debug = True;
X
X	else {
X	    syntax(argv[0]);
X	    exit(-1);
X	}
X	i++;
X    }
X}
X
X
X
X
X/*****************************************************************************
X *
X *   Synopsis
X *	Boolean LookUpColor(display, name, col, color_index)
X *	    Display *display;
X *	    char *name;
X *	    XColor *col;
X *	    unsigned long *color_index;	return
X *
X *   Arguments
X *	display	     specifies a connection to an X server;
X *	name	     a string for color;
X *	col	     returns XColor structure of the named color;
X *	color_index  returns the pixel value representing the named color,
X *		     which is actually an index to the colormap;
X *
X *   Return values
X *	True on success
X *	False on failing to allocate the named color
X *
X ****************************************************************************/
X
XBoolean LookUpColor(display, name, col, color_index)
XDisplay *display;
Xchar *name;
XXColor *col;
Xunsigned long *color_index;
X{
X  XColor xcolor;
X
X  if(XAllocNamedColor(display, DefaultColormap(display, DefaultScreen(display)),
X		name,  col, &xcolor) == 0) {
X	printf("LookUpColor: could not allocate %s.\n", name);
X	return(False);
X  } 
X  *color_index = col->pixel;
X  return(True);
X}
X
X
X/*********************************************************************
X*
X*   Synopsis
X*	connect_display()
X*
X*   Description
X*	connect to displays and create windows.
X*
X**********************************************************************/
X
X
Xstatic void
Xconnect_display()
X{
X    Display *dpy;
X    Pixmap background;
X    int i, j;
X    char err_msg[100];
X    XSetWindowAttributes attr;
X    unsigned long fg, bg;
X    XSizeHints size_hints;
X    char *win_name, *icon_name;
X    XGCValues values;
X    XColor color;
X
X    XtToolkitInitialize();
X    app_context = XtCreateApplicationContext();
X
X    values.foreground = 0;
X    values.background = 1;
X
X    win_name = (char *)malloc(40);
X
X    for (i=0; i<4; i++) {
X	if (two && i%2 != 0) continue;	/*for two players, connect only twice*/
X
X	if (!(p[i].dis=XtOpenDisplay(app_context, p[i].display_name, "x4war",
X		"x4war", 0, 0, &global_argc, global_argv))) {
X	    sprintf(err_msg, "can not open display %s",
X			XDisplayName(p[i].display_name));
X	    fatal_error(err_msg);
X	}
X	dpy = p[i].dis;
X	p[i].scr = DefaultScreen(dpy);
X
X	attr.border_pixel = BlackPixel(dpy, p[i].scr);
X
X	p[i].win = XCreateWindow(dpy, RootWindow(dpy,p[i].scr), 
X			i*40, 0, DIMENSION, DIMENSION, 4, CopyFromParent, 
X			InputOutput, CopyFromParent, CWBorderPixel, &attr);
X
X	if (!LookUpColor(dpy, DEFAULT_BOARD_BG, &color, &bg))
X	    bg = WhitePixel(dpy, p[i].scr);
X	if (!LookUpColor(dpy, DEFAULT_BOARD_FG, &color, &fg))
X	    fg = BlackPixel(dpy, p[i].scr);
X	background = XCreatePixmapFromBitmapData(dpy, p[i].win,
X		war_background_bits, war_background_width,
X		war_background_height, fg, bg,
X		DefaultDepth(dpy, p[i].scr));
X
X	XSetWindowBackgroundPixmap(dpy, p[i].win, background);
X
X	XFreePixmap(dpy, background);
X
X	sprintf(win_name, "x4war  player %s", p[i].player_name);
X	icon_name = p[i].player_name;
X	p[i].icon_pixmap = XCreateBitmapFromData(dpy, p[i].win, war_logo_bits,
X		war_logo_width, war_logo_height);
X
X	size_hints.flags = PPosition | PSize | PMinSize;
X	size_hints.min_width = DIMENSION;
X	size_hints.min_height = DIMENSION;
X    {
X	XWMHints wm_hints;
X	XClassHint class_hints;
X
X	XTextProperty windowName, iconName;
X
X	if (XStringListToTextProperty(&win_name, 1, &windowName) == 0)
X	    fatal_error("structure allocation for windowName failed.");
X	if (XStringListToTextProperty(&icon_name, 1, &iconName) == 0)
X	    fatal_error("structure allocation for iconName failed.");		
X
X	wm_hints.initial_state = NormalState;
X	wm_hints.input = True;
X	wm_hints.icon_pixmap = p[i].icon_pixmap;
X	wm_hints.flags = StateHint | IconPixmapHint | InputHint;
X
X	class_hints.res_name = progname;
X	class_hints.res_class = "X4war";
X
X	XSetWMProperties(dpy, p[i].win, &windowName, &iconName, 
X			global_argv, global_argc, &size_hints, &wm_hints, 
X			&class_hints);
X    }
X
X	XSelectInput(dpy, p[i].win, ExposureMask | KeyPressMask | 
X			ButtonPressMask | ButtonReleaseMask);
X
X	if (!LookUpColor(dpy, p[i].color_name, &(p[i].fg_color), &(p[i].fg[i])))
X	    p[i].fg[i] = BlackPixel(dpy, p[i].scr);
X
X	for (j=0; j<4; j++) {
X	    if ((two && j%2 != 0) || j==i) continue;
X	    if (!LookUpColor(dpy, p[j].color_name, &color, &(p[i].fg[j])))
X		p[i].fg[j] = BlackPixel(dpy, p[i].scr);
X	}
X
X	p[i].gc = XCreateGC(dpy, p[i].win, 0, NULL);
X	XSetBackground(dpy, p[i].gc, WhitePixel(dpy, p[i].scr));
X	XSetFont(dpy, p[i].gc, XLoadFont(dpy, "9x15bold"));
X	XSetLineAttributes(dpy, p[i].gc, 2, LineSolid, CapButt, JoinRound);
X
X	p[i].node[0] = XCreateBitmapFromData(dpy, p[i].win, colours_bits,
X		colours_width, colours_height);
X	p[i].node[1] = XCreateBitmapFromData(dpy, p[i].win, sapper_bits,
X		sapper_width, sapper_height);
X	p[i].node[2] = XCreateBitmapFromData(dpy, p[i].win, f_lieutenant_bits,
X		f_lieutenant_width, f_lieutenant_height);
X	p[i].node[3] = XCreateBitmapFromData(dpy, p[i].win, captain_bits,
X		captain_width, captain_height);
X	p[i].node[4] = XCreateBitmapFromData(dpy, p[i].win, major_bits,
X		major_width, major_height);
X	p[i].node[5] = XCreateBitmapFromData(dpy, p[i].win, colonel_bits,
X		colonel_width, colonel_height);
X	p[i].node[6] = XCreateBitmapFromData(dpy, p[i].win, brigadier_bits,
X		brigadier_width, brigadier_height);
X	p[i].node[7] = XCreateBitmapFromData(dpy, p[i].win, m_general_bits,
X		m_general_width, m_general_height);
X	p[i].node[8] = XCreateBitmapFromData(dpy, p[i].win, general_bits,
X		general_width, general_height);
X	p[i].node[9] = XCreateBitmapFromData(dpy, p[i].win, marshal_bits,
X		marshal_width, marshal_height);
X	p[i].node[10] = XCreateBitmapFromData(dpy, p[i].win, mine_bits,
X		mine_width, mine_height);
X	p[i].node[11] = XCreateBitmapFromData(dpy, p[i].win, bomb_bits,
X		bomb_width, bomb_height);
X
X	if (i != 0)
X	    p[i].node[12] = XCreateBitmapFromData(dpy, p[i].win,
X			back0_bits, back0_width, back0_height);
X	if (i != 1)
X	    p[i].node[13] = XCreateBitmapFromData(dpy, p[i].win,
X			back1_bits, back1_width, back1_height);
X	if (i != 2)
X	    p[i].node[14] = XCreateBitmapFromData(dpy, p[i].win,
X			back2_bits, back2_width, back2_height);
X	if (i != 3)
X	    p[i].node[15] = XCreateBitmapFromData(dpy, p[i].win,
X			back3_bits, back3_width, back3_height);
X
X	p[i].node[12+i] = XCreateBitmapFromData(dpy, p[i].win,
X			cursor_bits, cursor_width, cursor_height);
X	p[i].cursormask_pixmap = XCreateBitmapFromData(dpy, p[i].win,
X			cursormask_bits, cursormask_width, cursormask_height);
X	LookUpColor(dpy, "White", &(p[i].bg_color), &bg);
X	p[i].cursor = XCreatePixmapCursor(dpy, p[i].node[i+12],
X		p[i].cursormask_pixmap, &(p[i].fg_color), &(p[i].bg_color),
X		cursor_x_hot, cursor_y_hot);
X	XDefineCursor(dpy, p[i].win, p[i].cursor);
X
X	p[i].confirm = XCreateSimpleWindow(dpy, p[i].win, 400, 400, 300, 120, 4,
X		BlackPixel(dpy, p[i].scr), WhitePixel(dpy, p[i].scr));
X	XSelectInput(dpy, p[i].confirm, ExposureMask | ButtonPressMask);
X
X	p[i].nodemask_pixmap = XCreateBitmapFromData(dpy, p[i].win,
X		nodemask_bits, nodemask_width, nodemask_height);
X	p[i].stop_pixmap = XCreateBitmapFromData(dpy, p[i].win, stop_bits,
X		stop_width, stop_height);
X	p[i].go_pixmap = XCreateBitmapFromData(dpy, p[i].win, go_bits,
X		go_width, go_height);
X    }
X
X    if (two) {
X	pillar[0] = XCreateBitmapFromData(p[0].dis, p[0].win, pillar_bits,
X		pillar_width, pillar_height);
X	pillar[1] = XCreateBitmapFromData(p[2].dis, p[2].win, pillar_bits,
X		pillar_width, pillar_height);
X    }
X}
X
X
X/************************************************************************
X*
X*   Synopsis
X*	initial_board()
X*
X*   Description
X*	set for a new game
X*
X************************************************************************/
Xstatic void
Xinitial_board()
X{
X    int i, j, k;
X
X
X    for (i=0; i<4; i++)
X     for (j=0; j<6; j++)
X      for (k=0; k<5; k++) {
X	arr[i][j][k].value = EMPTY;
X	arr[i][j][k].id = i;
X    }
X
X    for (i=0; i<3; i++)
X      for (j=0; j<3; j++)
X	mid[i][j].value = EMPTY;
X
X
X    for (i=0; i<4; i++) {
X	p[i].rip_index = 0;
X	p[i].state = 1;
X	p[i].num_movable = 21;
X	p[i].popup = 0;
X	p[i].pick.picked = False;
X	p[i].marshal_dead = False;
X	p[i].talk_msg[0][0] = p[i].talk_msg[1][0] = p[i].talk_msg[2][0] = '\0';
X	p[i].talk_col = 0;
X
X	if (debug && (!two || i%2==0)) {
X	    arr[i][0][0].value = MARSHAL;
X	    arr[i][0][1].value = GENERAL;
X	    arr[i][0][2].value = M_GENERAL;
X	    arr[i][0][3].value = M_GENERAL;
X	    arr[i][0][4].value = BRIGADIER;
X	    arr[i][1][0].value = BRIGADIER;
X	    arr[i][1][2].value = COLONEL;
X	    arr[i][1][4].value = COLONEL;
X	    arr[i][2][0].value = MAJOR;
X	    arr[i][2][1].value = MAJOR;
X	    arr[i][2][3].value = CAPTAIN;
X	    arr[i][2][4].value = CAPTAIN;
X	    arr[i][3][0].value = CAPTAIN;
X	    arr[i][3][2].value = F_LIEUTENANT;
X	    arr[i][3][4].value = F_LIEUTENANT;
X	    arr[i][4][0].value = F_LIEUTENANT;
X	    arr[i][4][1].value = SAPPER;
X	    arr[i][4][2].value = SAPPER;
X	    arr[i][4][3].value = SAPPER;
X	    arr[i][4][4].value = BOMB;
X	    arr[i][5][0].value = BOMB;
X	    arr[i][5][1].value = COLOURS;
X	    arr[i][5][2].value = MINE;
X	    arr[i][5][3].value = MINE;
X	    arr[i][5][4].value = MINE;
X
X	    for (j=0; j<5; j++)
X	      for (k=0; k<5; k++)
X		p[i].rip[j][k] = EMPTY;
X	}
X
X      else  {
X	p[i].rip[0][0] = COLOURS;
X	p[i].rip[0][1] = MARSHAL;
X	p[i].rip[0][2] = GENERAL;
X	p[i].rip[0][3] = M_GENERAL;
X	p[i].rip[0][4] = M_GENERAL;
X	p[i].rip[1][0] = BRIGADIER;
X	p[i].rip[1][1] = BRIGADIER;
X	p[i].rip[1][2] = COLONEL;
X	p[i].rip[1][3] = COLONEL;
X	p[i].rip[1][4] = MAJOR;
X	p[i].rip[2][0] = MAJOR;
X	p[i].rip[2][1] = CAPTAIN;
X	p[i].rip[2][2] = CAPTAIN;
X	p[i].rip[2][3] = CAPTAIN;
X	p[i].rip[2][4] = F_LIEUTENANT;
X	p[i].rip[3][0] = F_LIEUTENANT;
X	p[i].rip[3][1] = F_LIEUTENANT;
X	p[i].rip[3][2] = SAPPER;
X	p[i].rip[3][3] = SAPPER;
X	p[i].rip[3][4] = SAPPER;
X	p[i].rip[4][0] = MINE;
X	p[i].rip[4][1] = MINE;
X	p[i].rip[4][2] = MINE;
X	p[i].rip[4][3] = BOMB;
X	p[i].rip[4][4] = BOMB;
X      }
X
X    }
X
X    if (two) {
X	num_player = 2;
X	arr[1][0][0].value = arr[1][0][2].value = arr[1][0][4].value =
X	arr[3][0][0].value = arr[3][0][2].value = arr[3][0][4].value = PILLAR;
X	p[1].state = p[3].state = 3;
X    }
X    else  num_player = 4;
X    mode = 0;
X}
X
X
X
X
X
X
X/*********************************************************************
X*
X*   Synopsis
X*	int whichplayer(display)
X*	    Display *display;
X*
X*   Return values
X*	0 - 4    according to whom the display belongs
X*	-1	 if nobody
X*
X**********************************************************************/
X
Xint whichplayer(display)
XDisplay *display;
X{
X    int i;
X
X    for (i=0; i<4; i++) {
X	if (two && i%2 != 0)  continue;
X	if (p[i].state != 3 && display == p[i].dis)  return(i);
X    }
X    return(-1);
X}
X
X
X
X/**********************************************************************
X*
X*   Synopsis
X*	put_msg(s1, s2)
X*	    char *s1, *s2;
X*
X*   Description
X*	put the two strings into the global msg1 and msg2, and draw them
X*	on the board.
X*
X***********************************************************************/
X
Xstatic void
Xput_msg(s1, s2)
Xchar *s1, *s2;
X{
X    int i;
X
X    strncpy(msg1, s1, MAX_MSG);
X    strncpy(msg2, s2, MAX_MSG);
X
X    for (i=0; i<4; i++)
X	if (p[i].state != 3) {
X	    XClearArea(p[i].dis, p[i].win, MSG_BOX_X, MSG_BOX_Y,
X		MSG_WIDTH, MSG_HEIGHT, False);
X	    XSetForeground(p[i].dis, p[i].gc, p[i].fg[i]);
X	    XDrawString(p[i].dis, p[i].win, p[i].gc, MSG_X, MSG_Y,
X		msg1, strlen(msg1));
X	    XDrawString(p[i].dis, p[i].win, p[i].gc, MSG_X, MSG_Y+25,
X		msg2, strlen(msg2));
X	}
X}
X
X
X
X/*********************************************************************
X*
X*   Synopsis
X*	send_expose_event()
X*
X*   Description
X*	send an expose event to all active players
X*
X*********************************************************************/
X
Xstatic void
Xsend_expose_event()
X{
X    XEvent event;
X    int n;
X
X    event.xexpose.x = event.xexpose.y = 0;
X    event.xexpose.width = event.xexpose.height = DIMENSION;
X    for (n=0; n<4; n++)
X	if (p[n].state != 3)
X	    refresh_board(n, &event);
X}
X
X
X
X
X/**********************************************************************
X*
X*   Synopsis
X*	redraw_confirm(i)
X*	    int i;
X*
X*   Argument
X*	i	specifies which player;
X*
X*   Description
X*	redraws the confirmation window, with confirm_msg displayed.
X*
X***********************************************************************/
X
Xstatic void
Xredraw_confirm(i)
Xint i;
X{
X    XSetForeground(p[i].dis, p[i].gc, BlackPixel(p[i].dis, p[i].scr));
X    XDrawRectangle(p[i].dis, p[i].confirm, p[i].gc, 3, 3, 293, 113);
X    if (p[i].popup == 3)
X	XDrawRectangle(p[i].dis, p[i].confirm, p[i].gc, 100, 75, 99, 19);
X    else {
X	XDrawRectangle(p[i].dis, p[i].confirm, p[i].gc, 80, 75, 39, 19);
X	XDrawRectangle(p[i].dis, p[i].confirm, p[i].gc, 180, 75, 39, 19);
X    }
X
X    XSetForeground(p[i].dis, p[i].gc, p[i].fg[i]);
X    if (p[i].popup == 3)
X	XDrawString(p[i].dis, p[i].confirm, p[i].gc, 110, 90, "CONTINUE", 8);
X    else {
X	XDrawString(p[i].dis, p[i].confirm, p[i].gc, 90, 90, "OK", 2);
X	XDrawString(p[i].dis, p[i].confirm, p[i].gc, 190, 90, "NO", 2);
X    }
X    XDrawString(p[i].dis, p[i].confirm, p[i].gc, 30, 40, confirm_msg,
X		strlen(confirm_msg));
X}
X
X
X
X
X/**********************************************************************
X*
X*   Synopsis
X*	Boolean valid_deploy(i)
X*	    int i;
X*
X*   Description
X*	check if player i's initial deploy is valid.
X*
X***********************************************************************/
X
XBoolean valid_deploy(i)
Xint i;
X{
X    int m, n, k;
X
X    if (arr[i][5][1].value != COLOURS && arr[i][5][3].value != COLOURS)
X	return(False);
X    if (arr[i][1][1].value != EMPTY || arr[i][1][3].value != EMPTY ||
X	arr[i][2][2].value != EMPTY || arr[i][3][1].value != EMPTY ||
X	arr[i][3][3].value != EMPTY)
X	  return(False);
X
X    k = 0;
X    for (m=4; m<6; m++)
X      for (n=0; n<5; n++)
X	if (arr[i][m][n].value == MINE) k++;
X    if (k<3)  return(False);
X
X    for (m=0; m<5; m++)
X      for (n=0; n<5; n++)
X	if (p[i].rip[m][n] != EMPTY)  return(False);
X
X    if (arr[i][5][1].value != MINE && arr[i][5][3].value != MINE)
X	p[i].num_movable--; 
X    return(True);
X}
X
X
X
X
X
X/***********************************************************************
X*
X*   Synopsis
X*	peace_request(i)
X*	    int i;
X*
X*   Description
X*	player i request for peace, this can only happen in play mode 1.
X*
X************************************************************************/
X
Xstatic void
Xpeace_request(i)
Xint i;
X{
X    int n;
X
X    mode = 2;
X
X    for (n=0; n<4; n++)
X      if (n != i && p[n].state == 2) {
X	p[n].popup = 1;
X	sprintf(confirm_msg, "%s requesting peace", p[i].player_name);
X	XMapWindow(p[n].dis, p[n].confirm);
X      }
X}
X
X
X
X/********************************************************************
X*
X*   Synopsis
X*	lost_war(i)
X*	    int i;
X*
X*   Description
X*	player i lost the war, if he/she's partner has lost too, change
X*	mode to 3; else, just update the playing array and send an expose
X*	event.
X*
X**********************************************************************/
X
Xstatic void
Xlost_war(i)
Xint i;
X{
X    int n, j, k;
X
X    p[i].state = 0;
X    num_player--;
X    if (two || p[(i+2)%4].state != 2) {
X	if (!two)
X	    put_msg(p[i].player_name, "and my ally lost!");
X	if (two)
X	    sprintf(confirm_msg, "%s lost the war", p[i].player_name);
X	else
X	    sprintf(confirm_msg, "%s and %s lost!", p[i].player_name,
X		    p[(i+2)%4].player_name);
X	for (n=0; n<4; n++)
X	    if (p[n].state != 3) {
X		XBell(p[n].dis, 0);
X		p[n].popup = 3;
X		XMapWindow(p[n].dis, p[n].confirm);
X		p[n].state = 0;
X	    }
X	mode = 3;
X	send_expose_event();
X    }
X    else {
X	for (n=0; n<4; n++)
X	 for (j=0; j<6; j++)
X	  for (k=0; k<5; k++)
X	    if (arr[n][j][k].value != EMPTY  && arr[n][j][k].id == i) {
X		p[i].rip[p[i].rip_index/5][p[i].rip_index%5] =
X			arr[n][j][k].value;
X		p[i].rip_index++;
X		arr[n][j][k].value = EMPTY;
X	    }
X	for (n=0; n<3; n++)
X	  for (j=0; j<3; j++)
X	    if (mid[n][j].value != EMPTY && mid[n][j].id == i) {
X		p[i].rip[p[i].rip_index/5][p[i].rip_index%5] = mid[n][j].value;
X		p[i].rip_index++;
X		mid[n][j].value = EMPTY;
X	    }
X	send_expose_event();
X    }
X}
X
X
X
X
X
X/***********************************************************************
X*
X*   Synopsis
X*	new_game()
X*
X*   Description
X*	it clears the board and starts a new game, or quit if someone has gone.
X*
X************************************************************************/
X
Xstatic void
Xnew_game()
X{
X    int i, j, k;
X
X    if (!two)
X      for (i=0; i<4; i++)
X	if (p[i].state == 3) {	/* someone has already quit */
X	    for (k=0; k<4; k++) {
X		XFreeCursor(p[k].dis, p[k].cursor);
X		XFreeGC(p[k].dis, p[k].gc);
X		for (j=0; j<16; j++)
X		    XFreePixmap(p[k].dis, p[k].node[j]);
X		XFreePixmap(p[k].dis, p[k].cursormask_pixmap);
X		XFreePixmap(p[k].dis, p[k].icon_pixmap);
X		XFreePixmap(p[k].dis, p[k].go_pixmap);
X		XFreePixmap(p[k].dis, p[k].stop_pixmap);
X	    }
X	    exit(0);
X	}
X
X    for (i=0; i<4; i++) {
X	if (two && i%2 !=0)  continue;
X	if (p[i].popup != 0) {
X	    p[i].popup = 0;
X	    XUnmapWindow(p[i].dis, p[i].confirm);
X	}
X	XClearArea(p[i].dis, p[i].win, 0, 0, DIMENSION, DIMENSION, False);
X    }
X    initial_board();
X    put_msg("New War", "deploy first");
X    send_expose_event();
X}
X
X
X
X
X
X/************************************************************************
X*
X*   Synopsis
X*	putsign(i, flag)
X*	    int i, flag;
X*
X*   Arguments
X*	i	specifies which player's board;
X*	flag	0 or 1,  0 to put stop sign, and 1 to put go ahead sign
X*
X*   Description
X*	it puts stop or go-ahead signs in the sign box.
X*
X*************************************************************************/
X
Xstatic void
Xputsign(i, flag)
Xint i, flag;
X{
X    XSetForeground(p[i].dis, p[i].gc, p[i].fg[i]);
X    if (flag)
X	XCopyPlane(p[i].dis, p[i].go_pixmap, p[i].win, p[i].gc, 0, 0,
X		SIGN_DIMENSION, SIGN_DIMENSION, P1+2, P1+2, 1);
X    else
X	XCopyPlane(p[i].dis, p[i].stop_pixmap, p[i].win, p[i].gc, 0, 0,
X		SIGN_DIMENSION, SIGN_DIMENSION, P1+2, P1+2, 1);
X}
X
X
X
X
X/***********************************************************************
X*
X*   Synopsis
X*	putnode(i, value, x, y)
X*	    int i, value, x, y;
X*
X*   Arguments
X*	i	specifies player i's board;
X*	value	-2 -- 15, means clear or an index to the node image;
X*	x, y	coordinates of the center of the node on the board;
X*
X*   Description
X*	it draws the image indicated by value at position (x,y) on
X*	player i's board.
X*	if value is EMPTY, it clear the positioned area.
X*	the foreground of the gc should be set before hand.
X*	the image is drawn at (x-20, y-20) with width and height of
X*	both 40.
X*
X************************************************************************/
X
Xstatic void
Xputnode(i, value, x, y)
Xint i, value, x, y;
X{
X    if (value == EMPTY)
X	XClearArea(p[i].dis, p[i].win, x-20, y-20, 40, 40, False);
X    else
X	if (value != PILLAR)
X	    XCopyPlane(p[i].dis, p[i].node[value], p[i].win, p[i].gc, 0, 0,
X		    40, 40, x-20, y-20, 1);
X	else
X	    XCopyPlane(p[i].dis, pillar[i/2], p[i].win, p[i].gc, 0, 0,
X		    40, 40, x-20, y-20, 1);
X}
X
X
X
X
X/************************************************************************
X*
X*   Synopsis
X*	putarea(i, x1, y1, x2, y2)
X*	    int i, x1, y1, x2, y2)
X*
X*   Description
X*	redraw an area of (x1, y1), (x2, y2) on player i's board.
X*	the coordinates are for the board but within the area of F0-F3
X*	and MIDFIELD.
X*
X*************************************************************************/
X
Xputarea(i, x1, y1, x2, y2)
Xint i, x1, y1, x2, y2;
X{
X    int f, k, l, m, n, a1, b1, a2, b2, c, d;
X
X    boardtoarr(i, x1, y1, &a1, &b1);
X    f = boardtoarr(i, x2, y2, &a2, &b2);
X
X    if (a1 > a2) {
X	k = a1;  a1 = a2;  a2 = k;
X    }
X    if (b1 > b2) {
X	k = b1;  b1 = b2;  b2 = k;
X    }
X
X    for (m=a1; m<=a2; m++)
X      for (n=b1; n<=b2; n++) {
X	if (f == MIDFIELD) {
X	    k = mid[m][n].value;
X	    l = mid[m][n].id;
X	}
X	else {
X	    k = arr[f][m][n].value;
X	    l = arr[f][m][n].id;
X	}
X	if (k == PILLAR)
X	    XSetForeground(p[i].dis, p[i].gc, BlackPixel(p[i].dis, p[i].scr));
X	else
X	    XSetForeground(p[i].dis, p[i].gc, p[i].fg[l]);
X
X	if (k > EMPTY && l != i && p[i].state != 0 &&
X		!(k==COLOURS && p[f].marshal_dead) )  k = l + 12;
X	arrtoboard(i, f, m, n, &c, &d);
X	putnode(i, k, c, d);
X      }
X}
X
X
X
X
X/************************************************************************
X*
X*   Synopsis
X*	refresh_board(i, event)
X*	    int i;
X*	    XEvent *event;
X*
X*   Description
X*	refresh player i's board according to the expose event.
X*
X**************************************************************************/
X
Xstatic void
Xrefresh_board(i, event)
Xint i;
XXEvent *event;
X{
X    int x1, y1, x2, y2;
X    int a1, b1, a2, b2;
X    int c1, d1, c2, d2;
X    int flag, m, n;
X    char s[35];
X
X    x1 = event->xexpose.x;
X    y1 = event->xexpose.y;
X    x2 = x1 + event->xexpose.width;
X    y2 = y1 + event->xexpose.height;
X
X
X    flag = area_intersection(P1, P1, P2, P2, x1,y1, x2,y2, &a1, &b1, &a2, &b2);
X    if (flag) {
X	XSetForeground(p[i].dis, p[i].gc, p[i].fg[i]);
X	if (mode == 0 || mode == 3 || turn != i)
X	    putsign(i, 0);
X	else putsign(i, 1);
X
X	XClearArea(p[i].dis, p[i].win, TALK_L_X, TALK_Y, TALK_WIDTH, 150,False);
X
X	XSetForeground(p[i].dis, p[i].gc, p[i].fg[0]);
X	sprintf(s, "PLAYER 0  (%s)", p[0].player_name);
X	XDrawString(p[i].dis, p[i].win,p[i].gc, TALK0_X, TALK_Y-5, s,strlen(s));
X	n = TALK0_Y;
X	for (m=0; m<3; m++) {
X	    XDrawString(p[i].dis, p[i].win, p[i].gc, TALK0_X, n,
X			p[0].talk_msg[m], strlen(p[0].talk_msg[m]));
X	    n += TALK_Y_INC;
X	}
X
X	XSetForeground(p[i].dis, p[i].gc, p[i].fg[2]);
X	sprintf(s, "PLAYER 2  (%s)", p[2].player_name);
X	XDrawString(p[i].dis, p[i].win,p[i].gc, TALK2_X,TALK_Y+85, s,strlen(s));
X	n = TALK2_Y;
X	for (m=0; m<3; m++) {
X	    XDrawString(p[i].dis, p[i].win, p[i].gc, TALK2_X, n,
X			p[2].talk_msg[m], strlen(p[2].talk_msg[m]));
X	    n += TALK_Y_INC;
X	}
X    }
X
X    flag = area_intersection(P5, P1, P6, P2, x1,y1, x2,y2, &a1, &b1, &a2, &b2);
X    if (flag) {
X	XSetForeground(p[i].dis, p[i].gc, p[i].fg[i]);
X	XClearArea(p[i].dis, p[i].win, MSG_BOX_X, MSG_BOX_Y,
X			MSG_WIDTH, MSG_HEIGHT, False);
X	XDrawString(p[i].dis, p[i].win, p[i].gc, MSG_X, MSG_Y,
X		msg1, strlen(msg1));
X	XDrawString(p[i].dis, p[i].win, p[i].gc, MSG_X, MSG_Y+25,
X		msg2, strlen(msg2));
X
X	XSetForeground(p[i].dis, p[i].gc, p[i].fg[1]);
X	sprintf(s, "PLAYER 1  (%s)", p[1].player_name);
X	XDrawString(p[i].dis, p[i].win,p[i].gc, TALK1_X, TALK_Y-5, s,strlen(s));
X	n = TALK1_Y;
X	for (m=0; m<3; m++) {
X	    XDrawString(p[i].dis, p[i].win, p[i].gc, TALK1_X, n,
X			p[1].talk_msg[m], strlen(p[1].talk_msg[m]));
X	    n += TALK_Y_INC;
X	}
X
X	XSetForeground(p[i].dis, p[i].gc, p[i].fg[3]);
X	sprintf(s, "PLAYER 3  (%s)", p[3].player_name);
X	XDrawString(p[i].dis, p[i].win,p[i].gc, TALK3_X,TALK_Y+85, s,strlen(s));
X	n = TALK3_Y;
X	for (m=0; m<3; m++) {
X	    XDrawString(p[i].dis, p[i].win, p[i].gc, TALK3_X, n,
X			p[3].talk_msg[m], strlen(p[3].talk_msg[m]));
X	    n += TALK_Y_INC;
X	}
X    }
X
X    flag = area_intersection(P1+5, RIP_Y+5, P1+RIP_DIMENSION-5,
X	RIP_Y+RIP_DIMENSION-5, x1, y1, x2, y2, &a1, &b1, &a2, &b2);
X    if (flag) {
X	boardtofield(a1, b1, &c1, &d1);
X	boardtofield(a2, b2, &c2, &d2);
X	XSetForeground(p[i].dis, p[i].gc, p[i].fg[i]);
X	for (m=c1; m<=c2; m++)
X	  for (n=d1; n<=d2; n++) {
X		fieldtoboard(RIP, m, n, &a1, &b1);
X		putnode(i, p[i].rip[m][n], a1, b1);
X	  }
X    }
X
X/* refresh field 0 */
X    flag = area_intersection(P3-20, P5-20, P4+20, P6+20,
X		x1, y1, x2, y2, &a1, &b1, &a2, &b2);
X    if (flag)
X	putarea(i, a1, b1, a2, b2);
X
X    if (mode > 0) {
X/* refresh field 1 */
X	flag = area_intersection(P5-20, P3-20, P6+20, P4+20,
X		x1, y1, x2, y2, &a1, &b1, &a2, &b2);
X	if (flag)
X	    putarea(i, a1, b1, a2, b2);
X
X/* refresh field 2 */
X        flag = area_intersection(P3-20, P1-20, P4+20, P2+20,
X		x1, y1, x2, y2, &a1, &b1, &a2, &b2);
X	if (flag)
X	    putarea(i, a1, b1, a2, b2);
X
X/* refresh field 3 */
X        flag = area_intersection(P1-20, P3-20, P2+20, P4+20,
X		x1, y1, x2, y2, &a1, &b1, &a2, &b2);
X	if (flag)
X	    putarea(i, a1, b1, a2, b2);
X
X/* refresh midfield */
X        flag = area_intersection(P3-20, P3-20, P4+20, P4+20,
X		x1, y1, x2, y2, &a1, &b1, &a2, &b2);
X	if (flag)
X	    putarea(i, a1, b1, a2, b2);
X    }
X}
X
X
X
X
X/**********************************************************************
X*
X*   Synopsis
X*	talk(i, flag, k)
X*	    int i, flag;
X*	    char k;
X*
X*   Arguments
X*	i	player i pressed a key;
X*	flag	0 - a printable key; 1 - a backspace; 2 - a Return key;
X*	k	the char if printable;
X*
X*   Description
X*	player i has pressed a key 'k', this function draws the character
X*	in the corresponding talking box.
X*
X************************************************************************/
X
Xstatic void
Xtalk(i, flag, k)
Xint i, flag;
Xchar k;
X{
X    int m;
X    static char s[] = {' ', '\0'};
X
X
X    if (flag == 1) {
X	if (p[i].talk_col == 0)   return;
X	s[0] = ' ';
X	p[i].talk_msg[2][p[i].talk_col] = '\0';
X	p[i].talk_col--;
X	for (m=0; m<4; m++)
X	    if (p[m].state != 3)
X		XDrawImageString(p[m].dis, p[m].win, p[m].gc,
X			p[i].talk_x+p[i].talk_col*TALK_X_INC, p[i].talk_y,
X			s, 1);
X	return;
X    }
X
X    for (m=0; m<4; m++)
X	if (p[m].state != 3)
X	    XSetForeground(p[m].dis, p[m].gc, p[m].fg[i]);
X
X    if (flag == 2 || p[i].talk_col >= MAX_MSG) {
X	strcpy(p[i].talk_msg[0], p[i].talk_msg[1]);
X	strcpy(p[i].talk_msg[1], p[i].talk_msg[2]);
X	p[i].talk_msg[2][0] = '\0';
X	p[i].talk_col = 0;
X	for (m=0; m<4; m++)
X	    if (p[m].state != 3) {
X		XClearArea(p[m].dis, p[m].win, p[i].talk_x-5,
X			p[i].talk_y-2*TALK_Y_INC-15, TALK_WIDTH, TALK_HEIGHT,
X			False);
X
X		XDrawImageString(p[m].dis, p[m].win, p[m].gc,
X			p[i].talk_x, p[i].talk_y-2*TALK_Y_INC,
X			p[i].talk_msg[0], strlen(p[i].talk_msg[0]));
X		XDrawImageString(p[m].dis, p[m].win, p[m].gc,
X			p[i].talk_x, p[i].talk_y-TALK_Y_INC,
X			p[i].talk_msg[1], strlen(p[i].talk_msg[1]));
X	    }
X    }
X    if (flag == 0) {
X	s[0] = k;
X	for (m=0; m<4; m++)
X	    if (p[m].state != 3)
X		XDrawImageString(p[m].dis, p[m].win, p[m].gc,
X			p[i].talk_x+TALK_X_INC*p[i].talk_col,
X			p[i].talk_y, s, 1);
X	p[i].talk_msg[2][p[i].talk_col++] = k;
X	p[i].talk_msg[2][p[i].talk_col] = '\0';
X    }
X}
X
X
X
X
X
X
X
X/**********************************************************************
X*
X*   Synopsis
X*	int move(i, f, x, y)
X*	    int i, f, x, y;
X*
X*   Argument
X*	i	0-3, specifies a move from p[i].pick;
X*	f	F0 -- RIP, the destination array;
X*	x, y	subscripts in the destination array;
X*
X*   Return values
X*	0	invalid move;
X*	1	no fight, just a move;
X*	2	source loses;
X*	3	tie;
X*	4	source win;
X*
X***********************************************************************/
X
Xint move(i, f, x, y)
Xint i, f, x, y;
X{
X    int m;
X
X    if (f == RIP)  return(0);
X    if (two && (f==1 || f==3)) return(0);
X    if (f == MIDFIELD) {
X	m = mid[x][y].value;
X	if (m != EMPTY && (mid[x][y].id==i || (!two && mid[x][y].id==(i+2)%4)))
X	    return(0);
X    }
X    else {
X	m = arr[f][x][y].value;
X	if (m != EMPTY && (arr[f][x][y].id==i ||
X			   (!two && arr[f][x][y].id==(i+2)%4)))
X	    return(0);
X	if (m != EMPTY && ((x==1 && y==1) || (x==1 && y==3) || (x==2 && y==2)
X			|| (x==3 && y==1) || (x==3 && y==3)))
X	    return(0);
X    }
X
X    if (!valid_move(p[i].pick.arr, p[i].pick.x, p[i].pick.y, f, x, y))
X	return(0);
X
X    if (x==5 && (y==1 || y==3))
X	 return ((m==COLOURS) ? 3 : 2);
X    if (m == EMPTY)  return(1);
X    return(fight(p[i].pick.value, m));
X}
X
X
X
X
X/************************************************************************
X*
X*   Synopsis
X*	Boolean lose_check(i, v)
X*	    int i, v;
X*
X*   Return values
X*	True	if defeated;
X*	False	otherwise;
X*
X*   Description
X*	player i has just lost a node valued v, this function checks if:
X*	    it is the COLOURS, then declares defeated;
X*	    it is the MARSHAL, then its COLOURS is showed face up on all
X*		boards;
X*	    the player has no moving nodes avaliable, then declares defeated.
X*	the last case is not implemented.
X*
X***************************************************************************/
X
XBoolean lose_check(i, v)
Xint i, v;
X{
X    int m, k, b, c;
X
X    if (v == COLOURS)
X	return(True);
X    if (v == MARSHAL) {
X	p[i].marshal_dead = True;
X	m = (arr[i][5][1].value == COLOURS) ? 1 : 3;
X	for (k=0; k<4; k++)
X	    if (p[k].state != 3) {
X		XSetForeground(p[k].dis, p[k].gc, p[k].fg[i]);
X		arrtoboard(k, i, 5, m, &b, &c);
X		putnode(k, COLOURS, b, c);
X	    }
X    }
X    if ((--p[i].num_movable)==0)  return(True);
X    return(False);
X}
X
X
X
X
X
X/***********************************************************************
X*
X*   Synopsis
X*	return_rip(i, v)
X*	    int i, v;
X*
X*   Description
X*	returns player i's node valued v to rip.
X*
X************************************************************************/
X
Xstatic void
Xreturn_rip(i, v)
Xint i, v;
X{
X    int m, n, x, y;
X
X    m = p[i].rip_index/5;
X    n = p[i].rip_index%5;
X    p[i].rip[m][n] = v;
X    p[i].rip_index++;
X    arrtoboard(i, RIP, m, n, &x, &y);
X    XSetForeground(p[i].dis, p[i].gc, p[i].fg[i]);
X    putnode(i, v, x, y);
X}
X
X
X
X
X/************************************************************************
X*
X*   Synopsis
X*	show_move(m)
X*	    int m;
X*
X*   Argument
X*	m	the moving result from move();
X*
X*   Description
X*	it takes the values from the global arguments (sf,si,sj) and
X*	(df,di,dj) and show the move on the board.
X*	Then, it update the state to implement the move.
X*
X************************************************************************/
X
Xstatic void
Xshow_move(m)
Xint m;
X{
X    int a, b, c, v, w, x;
X    char s1[40], s2[40];
X
X    if (count >= 0) {
X	for (c=0; c<4; c++)
X	    if (p[c].state != 3) {
X		if (count>3)
X		    arrtoboard(c, sf, si, sj, &a, &b);
X		else
X		    arrtoboard(c, df, di, dj, &a, &b);
X		if (count%2 == 0)
X		    putnode(c, -1, a, b);
X		else {
X		    XSetForeground(p[c].dis, p[c].gc, p[c].fg[sw]);
X		    x = sv;
X		    if (c!=sw && p[c].state!=0)
X			x = 12 + sw;
X		    putnode(c, x, a, b);
X		}
X	    }
X	count--;
X	XtAppAddTimeOut(app_context, 300, show_move, m);
X    }
X    else {
X	sprintf(s1, "%s (%d,%d,%d)=>(%d,%d,%d)", p[sw].player_name,
X		sf, si, sj, df, di, dj);
X	if (m == 2)
X	    sprintf(s2, "%s lost to %s", p[sw].player_name, p[dw].player_name);
X	else if (m == 3)
X	    sprintf(s2, "%s and %s tied", p[sw].player_name, p[dw].player_name);
X	else
X	    sprintf(s2, "%s is marching on", p[sw].player_name);
X	put_msg(s1, s2);
X
X	if (m == 3)
X	    if (df == MIDFIELD) mid[di][dj].value = EMPTY;
X	    else arr[df][di][dj].value = EMPTY;
X	if (m == 4 || m == 1)
X	    if (df == MIDFIELD) {
X		mid[di][dj].value = sv;
X		mid[di][dj].id = sw;
X	    }
X	    else {
X		arr[df][di][dj].value = sv;
X		arr[df][di][dj].id = sw;
X	    }
X
X	if (df == MIDFIELD) {	
X	    w = mid[di][dj].id;
X	    v = mid[di][dj].value;
X	}
X	else {
X	    w = arr[df][di][dj].id;
X	    v = arr[df][di][dj].value;
X	}
X	for (c=0; c<4; c++)
X	    if (p[c].state != 3) {
X		arrtoboard(c, df, di, dj, &a, &b);
X		XSetForeground(p[c].dis, p[c].gc, p[c].fg[w]);
X		x = v;
X		if (c!=w && p[c].state!=0 && v!=EMPTY)
X		   x = 12 + w;
X		putnode(c, x, a, b);
X	    }
X
X	mode = 1;	/* because lost_war could change mode if lost */
X	if (m == 3 || m == 4) {
X	    return_rip(dw, dv);
X	    if (lose_check(dw, dv)) lost_war(dw);
X	}
X	if ((mode==1) && (m==2 || m==3)) {
X	    return_rip(sw, sv);
X	    if (lose_check(sw, sv)) lost_war(sw);
X	}
X	if (mode == 1) {
X	    if (two)  turn = (turn + 2) % 4;
X	    else
X		do {
X		    turn = (turn+1)%4;
X		} while (p[turn].state != 2);
X	    putsign(sw, 0);
X	    putsign(turn, 1);
X	    XBell(p[turn].dis, 0);
X	}
X    }
X}
X
X
Xmain(argc, argv)
Xint argc;
Xchar **argv;
X{
X    int i, j, who, x, y, f, m, n;
X    int agree_to_peace;
X    XEvent event;
X    char buffer, s[40];
X    KeySym keysym;
X    XComposeStatus compose;
X
X    progname = argv[0];
X    global_argc = argc;
X    global_argv = argv;
X
X    for (i=0; i<4; i++) {
X	p[i].display_name = NULL;
X	sprintf(p[i].player_name, "PLAYER %d", i);
X    }
X    strcpy(p[0].color_name, PLAYER0_COLOR);
X    strcpy(p[1].color_name, PLAYER1_COLOR);
X    strcpy(p[2].color_name, PLAYER2_COLOR);
X    strcpy(p[3].color_name, PLAYER3_COLOR);
X    p[0].talk_x = p[2].talk_x = TALK0_X;
X    p[1].talk_x = p[3].talk_x = TALK1_X;
X    p[0].talk_y = p[1].talk_y = TALK0_Y+2*TALK_Y_INC;
X    p[2].talk_y = p[3].talk_y = TALK2_Y+2*TALK_Y_INC;
X
X    debug = False;
X    two = False;
X
X    parse_arguments(argc, argv);
X
X    connect_display();
X    initial_sapper();
X    initial_board();
X    turn = 0;
X
X    for (i=0; i<4; i++) {
X	if (two && i%2 != 0)  continue;
X	XMapWindow(p[i].dis, p[i].win);
X    }
X
X    while (1) {
X	XtAppNextEvent(app_context, &event);
X	switch(event.type) {
X	  case Expose:
X	    who = whichplayer(event.xexpose.display);
X	    if (who == -1) break;
X
X	    if (p[who].confirm == event.xexpose.window)
X		redraw_confirm(who);
X	    else refresh_board(who, &event);
X	    break;
X
X	  case ButtonPress:
X	    who = whichplayer(event.xbutton.display);
X	    if (who == -1) break;
X
X	    if (p[who].popup) {
X		if (event.xbutton.window != p[who].confirm) {
X		    XBell(p[who].dis, 0);
X		    break;
X		}
X		x = event.xbutton.x;
X		y = event.xbutton.y;
X		if (p[who].popup != 3)
X		    if (x>80 && x<120 && y>75 && y<95)  f = 1;
X		    else if (x>180 && x<220 && y>75 && y<95)  f = 0;
X		    else {
X			XBell(p[who].dis, 0);
X			break;
X		    }
X
X		XUnmapWindow(p[who].dis, p[who].confirm);
X		if (p[who].popup == 3) {
X		    p[who].popup = 0;
X		    break;
X		}
X		if (p[who].popup == 2) {	/* QUIT popup */
X		    if (f) {		/* yes to quit */
X			XUnmapWindow(p[who].dis, p[who].win);
X			if (p[who].state || mode==3 || two) {
X			    for (i=0; i<4; i++) {
X				if (two && i%2 != 0)  continue;
X				XFreeCursor(p[i].dis, p[i].cursor);
X				XFreeGC(p[i].dis, p[i].gc);
X				for (j=0; j<16; j++)
X				    XFreePixmap(p[i].dis, p[i].node[j]);
X				XFreePixmap(p[i].dis, p[i].cursormask_pixmap);
X				XFreePixmap(p[i].dis, p[i].icon_pixmap);
X				XFreePixmap(p[i].dis, p[i].go_pixmap);
X				XFreePixmap(p[i].dis, p[i].stop_pixmap);
X				XFreePixmap(p[i].dis, p[i].nodemask_pixmap);
X			    }
X			    exit(0);
X			}
X			else p[who].state = 3;
X		    }
X		    p[who].popup = 0;
X		}
X		else	/* PEACE popup */
X		    if (f) {
X			agree_to_peace++;
X			p[who].popup = 0;
X			if (agree_to_peace >= num_player) {
X			    strcpy(confirm_msg, "peace arrived!");
X			    for (i=0; i<4; i++)
X				if (p[i].state != 3) {
X				    p[i].popup = 3;
X				    XMapWindow(p[i].dis, p[i].confirm);
X				}
X			    mode = 3;
X			}
X		    }
X		    else {
X			strcpy(confirm_msg, "Absolutely no peace!");
X			for (i=0; i<4; i++)
X			    if (p[i].state != 3) {
X				if (p[i].popup)
X				    XUnmapWindow(p[i].dis, p[i].confirm);
X				p[i].popup = 3;
X				XMapWindow(p[i].dis, p[i].confirm);
X			    }
X			mode = 1;
X		    }
X
X		break;
X	    }
X
X	    f = boardtofield(event.xbutton.x, event.xbutton.y, &x, &y);
X	    if (f == QUIT) {
X		if (mode!=1 || p[who].state!=2 || who==turn) {
X			strcpy(confirm_msg, "Confirm quit!");
X			p[who].popup = 2;
X			XMapWindow(p[who].dis, p[who].confirm);
X		}
X		else  XBell(p[who].dis, 0);
X		break;
X	    }
X
X	    if (f == SURRENDER) {
X		if (mode==1 && p[who].state==2 && turn==who) {
X		    put_msg(p[who].player_name, "I surrender, spare me!");
X		    if (two)  turn = (turn + 2) % 4;
X		    else
X			do {
X			    turn = (turn+1)%4;
X			} while (p[turn].state != 2);
X		    XBell(p[turn].dis, 0);
X		    lost_war(who);
X		}
X
X		else XBell(p[who].dis, 0);
X		break;
X	    }
X
X	    if (f == PEACE) {
X		if (mode == 1 && p[who].state == 2 && turn == who) {
X		    for (i=0; i<4; i++)
X			if (p[i].popup != 0) break;
X		    if (i == 4) {
X			agree_to_peace = 1;
X			peace_request(who);
X			break;
X		    }
X		}
X		XBell(p[who].dis, 0);
X		break;
X	    }
X
X	    if (f == REDEPLOY) {
X		if (mode == 0)  p[who].state = 1;
X		else XBell(p[who].dis, 0);
X		break;
X	    }
X
X	    if (f == READY) {
X		if (mode == 0)
X		    if (!valid_deploy(who)) {
X			strcpy(confirm_msg,"Invalid deploy");
X			p[who].popup = 3;
X			XMapWindow(p[who].dis, p[who].confirm);
X			XBell(p[who].dis, 0);
X		    }
X		    else {
X			p[who].state = 2;
X			if (two)
X			    if (p[(who+2)%4].state == 2)  i = 4;
X			    else  i = 0;
X			else
X			    for (i=0; i<4; i++)
X				if (p[i].state != 2) break;
X
X			if (i == 4) {
X			    mode = 1;
X			    sprintf(s, "%s moves first", p[turn].player_name);
X			    put_msg("WAR started", s);
X			    send_expose_event();
X			    XBell(p[turn].dis, 0);
X			}
X		    }
X		else XBell(p[who].dis, 0);
X		break;
X	    }
X
X	    if (f == NEW) {
X		if (mode == 3) new_game();
X		else XBell(p[who].dis, 0);
X		break;
X	    }
X
X/*from now on the button event happened on the board for picking up a node */
X
X	    if (p[who].state==0 || mode>1) {
X		XBell(p[who].dis, 0);
X		break;
X	    }
X
X	    f = boardtoarr(who, event.xbutton.x, event.xbutton.y, &x, &y);
X	    if (f == -1) {
X		XBell(p[who].dis, 0);
X		break;
X	    }
X	    p[who].pick.arr = f;
X	    p[who].pick.x = x;
X	    p[who].pick.y = y;
X	    if (mode == 0)
X		if (p[who].state == 1)
X		    if (f == RIP && p[who].rip[x][y] != EMPTY)
X			p[who].pick.value = p[who].rip[x][y];
X		    else if (f == who && arr[f][x][y].value != EMPTY)
X			p[who].pick.value = arr[f][x][y].value;
X		    else {
X			XBell(p[who].dis, 0);
X			break;
X		    }
X		else {
X		    XBell(p[who].dis, 0);
X		    break;
X		}
X	    else {
X		if (turn != who) {
X		    XBell(p[who].dis, 0);
X		    break;
X		}
X		if (f==MIDFIELD && mid[x][y].id==who && mid[x][y].value!=EMPTY)
X		    p[who].pick.value = mid[x][y].value;
X		else if (f>=F0 && f<=F3 && arr[f][x][y].id == who &&
X			arr[f][x][y].value!=EMPTY && arr[f][x][y].value!=MINE &&
X			(x!=5 || (y!=1 && y!=3)) )
X		    p[who].pick.value = arr[f][x][y].value;
X		else {
X		    XBell(p[who].dis, 0);
X		    break;
X		}
X	    }
X	    p[who].pick.picked = True;
X	    arrtoboard(who, f, x, y, &m, &n);
X	    putnode(who, -1, m, n);
X
X	    p[who].tmp_cursor = XCreatePixmapCursor(p[who].dis,
X		p[who].node[p[who].pick.value], p[who].nodemask_pixmap,
X		&(p[who].fg_color), &(p[who].bg_color),
X		nodemask_x_hot, nodemask_y_hot);
X	    XDefineCursor(p[who].dis, p[who].win, p[who].tmp_cursor);
X	    break;
X
X	  case ButtonRelease:
X	    who = whichplayer(event.xbutton.display);
X	    if (who == -1)  break;
X
X	    if (p[who].pick.picked) {
X		XSetForeground(p[who].dis, p[who].gc, p[who].fg[who]);
X		p[who].pick.picked = False;
X		XFreeCursor(p[who].dis, p[who].tmp_cursor);
X		XDefineCursor(p[who].dis, p[who].win, p[who].cursor);
X		f = boardtoarr(who, event.xbutton.x, event.xbutton.y, &x, &y);
X		if (f != -1)
X		    if (mode == 0) {
X			if (f == RIP && p[who].rip[x][y] == EMPTY)
X			    p[who].rip[x][y] = p[who].pick.value;
X			else if (f == who && arr[f][x][y].value == EMPTY)
X			    arr[f][x][y].value = p[who].pick.value;
X			else {
X			    arrtoboard(who, p[who].pick.arr, p[who].pick.x,
X				p[who].pick.y, &m, &n);
X			    putnode(who, p[who].pick.value, m, n);
X			    XBell(p[who].dis, 0);
X			    break;
X			}
X
X			m = p[who].pick.x;
X			n = p[who].pick.y;
X			if (p[who].pick.arr==RIP)
X			    p[who].rip[m][n] = EMPTY;
X			else  arr[who][m][n].value = EMPTY;
X			arrtoboard(who, f, x, y, &m, &n);
X			putnode(who, p[who].pick.value, m, n);
X		    }
X		    else {
X			m = move(who, f, x, y);
X			if (m == 0) {	/* invalid move */
X			    arrtoboard(who, p[who].pick.arr, p[who].pick.x,
X				p[who].pick.y, &m, &n);
X			    putnode(who, p[who].pick.value, m, n);
X			    XBell(p[who].dis, 0);
X			}
X			else {
X			    mode = 4;
X			    sf = p[who].pick.arr;
X			    si = p[who].pick.x;
X			    sj = p[who].pick.y;
X			    df = f;
X			    di = x;
X			    dj = y;
X			    if (sf == MIDFIELD) {
X				sw = mid[si][sj].id;
X				sv = mid[si][sj].value;
X				mid[si][sj].value = EMPTY;
X			    }
X			    else {
X				sw = arr[sf][si][sj].id;
X				sv = arr[sf][si][sj].value;
X				arr[sf][si][sj].value = EMPTY;
X			    }
X			    if (df == MIDFIELD) {
X				dw = mid[di][dj].id;
X				dv = mid[di][dj].value;
X			    }
X			    else {
X				dw = arr[df][di][dj].id;
X				dv = arr[df][di][dj].value;
X			    }
X			    count = 8;
X			    show_move(m);
X			}
X		    }
X		else {
X		    arrtoboard(who, p[who].pick.arr, p[who].pick.x,
X				p[who].pick.y, &m, &n);
X		    putnode(who, p[who].pick.value, m, n);
X		    XBell(p[who].dis, 0);
X		}
X	    } /* if (picked == True) */
X	    break;
X
X	  case KeyPress:
X	    who = whichplayer(event.xkey.display);
X	    if (who == -1)  break;
X
X	    f = XLookupString(&event, &buffer, 1, &keysym, &compose);
X	    if (keysym==XK_Return || keysym==XK_Linefeed) {
X		talk(who, 2, '_');
X		break;
X	    }
X	    if (keysym==XK_BackSpace || keysym==XK_Delete) {
X		talk(who, 1, '_');
X		break;
X	    }
X	    if (keysym>=XK_space && keysym<=XK_asciitilde)
X		talk(who, 0, buffer);
X	    break;
X
X	  case MappingNotify:
X	    XRefreshKeyboardMapping(&event);
X	    break;
X
X	  default:
X	    break;
X	}  /* switch */
X    } /* while(1) */
X}
X
X
X
X
X
END_OF_FILE
if test 45444 -ne `wc -c <'x4war.c'`; then
    echo shar: \"'x4war.c'\" unpacked with wrong size!
fi
# end of 'x4war.c'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
