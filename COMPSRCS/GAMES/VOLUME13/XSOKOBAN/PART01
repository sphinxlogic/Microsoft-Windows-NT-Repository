Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i001:  xsokoban - X11 based, get the money game (Version 2), Part01/02
Message-ID: <2121@masterCNA.TEK.COM>
Date: 5 Dec 91 16:33:39 GMT
Sender: news@masterCNA.TEK.COM
Lines: 1990
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Kevin Solie <kevins@ms.uky.edu>
Posting-number: Volume 13, Issue 1
Archive-name: xsokoban/Part01
Environment: x11, xlib


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 2)."
# Contents:  README MANIFEST icon.xbm initx.c initx.h makefile play.c
#   playerstore.xbm readscreen.c save.c score.c screens
#   screens/screen.10 screens/screen.14 screens/screen.20
#   screens/screen.22 screens/screen.24 screens/screen.25
#   screens/screen.35 screens/screen.36 screens/screen.37
#   screens/screen.39 screens/screen.41 screens/screen.50 showscreen.c
#   sok.c sokoban.h
# Wrapped by billr@saab on Wed Dec  4 16:49:46 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(808 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
X	Welcome to Xsokoban. This implementation is very incomplete. I stole
Xthe logic code from a person who stole the idea from a PC game. The original
Xsokoban was based on curses so I simply put an X11 frontend around it. 
XThis game is, however Shareware. A $.50 donation (thats right, 50 cents. I just
Xwant to see if anyone ever sends money) should be sent to me if you use this 
Xsrc. Also, if fancy workin on this please send me updates of your changes.
X
XNOTE:
X		The makefile is designed to be run as root and puts things in
X		a games dir. For a personal scorefile (If you dont have access to
X		root) just change the makefile.
X
X
Xkevins@ms.uky.edu
X
XSend $$$$ to
X
XKevin Solie
X273 Lexington Ave.
XLexington Ky. 40508
X
XAdditional Note: Be sure to edit the path names in sokoban.h to match your
Xsystem/environment.
END_OF_FILE
if test 808 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2377 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X README                     1	
X cursor.xbm                 2	
X ground.xbm                 2	
X icon.xbm                   1	
X initx.c                    1	
X initx.h                    1	
X makefile                   1	
X obj.h                      2	
X packet.xbm                 2	
X play.c                     1	
X player.xbm                 2	
X playerstore.xbm            1	
X readscreen.c               1	
X save.c                     1	
X save.xbm                   2	
X score.c                    1	
X screens                    1	
X screens/screen.1           2	
X screens/screen.10          1	
X screens/screen.11          2	
X screens/screen.12          2	
X screens/screen.13          2	
X screens/screen.14          1	
X screens/screen.15          2	
X screens/screen.16          2	
X screens/screen.17          2	
X screens/screen.18          2	
X screens/screen.19          2	
X screens/screen.2           2	
X screens/screen.20          1	
X screens/screen.21          2	
X screens/screen.22          1	
X screens/screen.23          2	
X screens/screen.24          1	
X screens/screen.25          1	
X screens/screen.26          2	
X screens/screen.27          2	
X screens/screen.28          2	
X screens/screen.29          2	
X screens/screen.3           2	
X screens/screen.30          2	
X screens/screen.31          2	
X screens/screen.32          2	
X screens/screen.33          2	
X screens/screen.34          2	
X screens/screen.35          1	
X screens/screen.36          1	
X screens/screen.37          1	
X screens/screen.38          2	
X screens/screen.39          1	
X screens/screen.4           2	
X screens/screen.40          2	
X screens/screen.41          1	
X screens/screen.42          2	
X screens/screen.43          2	
X screens/screen.44          2	
X screens/screen.45          2	
X screens/screen.46          2	
X screens/screen.47          2	
X screens/screen.48          2	
X screens/screen.49          2	
X screens/screen.5           2	
X screens/screen.50          1	
X screens/screen.6           2	
X screens/screen.7           2	
X screens/screen.8           2	
X screens/screen.9           2	
X showscreen.c               1	
X sok.c                      1	
X sokoban.h                  1	
X store.xbm                  2	
X wall.xbm                   2	
END_OF_FILE
if test 2377 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'icon.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icon.xbm'\"
else
echo shar: Extracting \"'icon.xbm'\" \(1676 characters\)
sed "s/^X//" >'icon.xbm' <<'END_OF_FILE'
X#define icon_width 64
X#define icon_height 32
Xstatic char icon_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x0e, 0x00, 0x38, 0x3c, 0x00, 0x0e, 0x00, 0x0c, 0x12,
X   0x80, 0x20, 0x66, 0x00, 0x19, 0x00, 0x0b, 0x31, 0x80, 0x20, 0x46, 0x00,
X   0x31, 0x80, 0x09, 0x21, 0x80, 0x21, 0x44, 0x00, 0x21, 0x80, 0x08, 0x21,
X   0x00, 0x23, 0x6c, 0x00, 0x21, 0x80, 0x0c, 0x21, 0x00, 0x3e, 0x38, 0x02,
X   0x33, 0x80, 0x1f, 0x31, 0x00, 0x00, 0x00, 0x03, 0x1e, 0x00, 0x10, 0x10,
X   0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0xc0, 0x00,
X   0x00, 0x07, 0x00, 0x10, 0x00, 0x00, 0x70, 0x00, 0x80, 0x0d, 0x00, 0x10,
X   0x00, 0x00, 0xf8, 0x07, 0xc0, 0x08, 0x00, 0x10, 0x00, 0x00, 0x6c, 0x00,
X   0xe0, 0x08, 0x00, 0x30, 0x00, 0x00, 0x43, 0x00, 0x98, 0x0d, 0x00, 0x00,
X   0x00, 0x40, 0x41, 0x00, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
X   0x0e, 0x01, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xf0, 0x01, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1676 -ne `wc -c <'icon.xbm'`; then
    echo shar: \"'icon.xbm'\" unpacked with wrong size!
fi
# end of 'icon.xbm'
fi
if test -f 'initx.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'initx.c'\"
else
echo shar: Extracting \"'initx.c'\" \(3503 characters\)
sed "s/^X//" >'initx.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include "sokoban.h"
X#include "initx.h"
X#include "obj.h"
X
X#include "icon.xbm"  
X#include "cursor.xbm"
X#include "ground.xbm"
X#include "packet.xbm"
X#include "player.xbm"
X#include "playerstore.xbm"
X#include "save.xbm"
X#include "store.xbm"
X#include "wall.xbm"
X
XDisplay				*dpy;
XWindow				win;
XGC					gc,gclear;
XPixmap				bitmap,
X					cursor_bitmap;
XCursor				cursor;
XXColor				fg,bg,dummy;
Xunsigned long 			attribmask;
XXGCValues 			gcv;
XXSizeHints			xsh;
XXSetWindowAttributes	xswa;
XXWMHints 				xwmh;
XFont					font;
Xchar					sline[80];
XXSizeHints    			hints;
XPixmap				icon;
X
Xvoid load_pieces();
X
Xvoid killx()
X{
X	XDestroyWindow(dpy,win);
X     XCloseDisplay(dpy);
X}
Xvoid initx()
X{
X
X	if ((dpy = XOpenDisplay(NULL)) == NULL) {
X		fprintf(stderr,"\tCannot open %s\n",DISPLAYNAME);
X		exit(1);
X	}
X
X	xswa.colormap = COLORMAP;
X	xswa.bit_gravity = CenterGravity;
X	xswa.border_pixel = BLACKPIXEL;
X	xswa.background_pixel = WHITEPIXEL;
X	attribmask = ( CWColormap | CWBitGravity | CWBorderPixel | CWBackPixel);
X	win = XCreateWindow(dpy,ROOT,XORIGIN,YORIGIN,PIXMAPX*MAXCOL,
X		PIXMAPY*MAXROW+20,BORDERWIDTH,DEPTH,InputOutput,CopyFromParent,attribmask,&xswa);
X	if ((win==BadMatch)||(win==BadAlloc)||(win==BadColor)||
X		(win==BadCursor)||(win==BadPixmap)||(win==BadValue)||(win==BadWindow))	{
X		fprintf(stderr,"\tHeeeeeeeyyy mon, can't create window\n");
X		exit (-1);
X	}	
X
X	cursor_bitmap = XCreateBitmapFromData(dpy,win,cursor_bits,cursor_width,cursor_height);
X	icon = XCreateBitmapFromData(dpy,ROOT,icon_bits,icon_width,icon_height);	
X
X     XLookupColor(dpy,COLORMAP,"black",&dummy,&fg);
X     XLookupColor(dpy,COLORMAP,"white",&dummy,&bg);
X     xswa.cursor = XCreatePixmapCursor(dpy,cursor_bitmap,cursor_bitmap,&fg,&bg,16,4);
X     XChangeWindowAttributes(dpy,win,CWCursor,&xswa);
X	xwmh.initial_state = NormalState;
X	xwmh.flags = StateHint; 
X	XSetWMHints(dpy,win,&xwmh); 
X
X	hints.width = hints.min_width = hints.max_width = PIXMAPX*MAXCOL;
X	hints.height = hints.min_height = hints.max_height = PIXMAPY*MAXROW+20;
X	hints.flags = PMinSize|PMaxSize|PSize;
X
X	XSetStandardProperties(dpy,win,TITLE,TITLE,icon,NULL,0,&hints);
X	load_pieces();
X
X	font = XLoadFont(dpy,"9x15");
X	      
X	gcv.function = GXcopy;
X	gcv.font = font;
X	gcv.foreground = BLACKPIXEL;
X	gcv.background = WHITEPIXEL;
X	gcv.graphics_exposures = FALSE;
X	gc = XCreateGC(dpy,win,(GCFont|GCGraphicsExposures|GCForeground|GCBackground|GCFunction),&gcv);
X
X	gcv.function = GXcopy;
X	gcv.font = font;
X	gcv.foreground = WHITEPIXEL;
X	gcv.background = BLACKPIXEL;
X	gcv.graphics_exposures = FALSE;
X	gclear = XCreateGC(dpy,win,(GCFont|GCGraphicsExposures|GCForeground|GCBackground|GCFunction),&gcv);
X
X
X	XMapRaised(dpy,win);
X	showscreen();
X	sprintf(sline," Level:       Packets:       Saved:      Moves:       Pushes:");
X
X	XSync(dpy,False);
X}
Xvoid load_pieces()
X{
X	player.obj_display = XCreateBitmapFromData(dpy,win,player_bits,player_width,player_height);
X	playerstore.obj_display = XCreateBitmapFromData(dpy,win,playerstore_bits,playerstore_width,playerstore_height);
X	wall.obj_display = XCreateBitmapFromData(dpy,win,wall_bits,wall_width,wall_height);
X	store.obj_display = XCreateBitmapFromData(dpy,win,store_bits,store_width,store_height);
X	packet.obj_display = XCreateBitmapFromData(dpy,win,packet_bits,packet_width,packet_height);
X	save.obj_display = XCreateBitmapFromData(dpy,win,save_bits,save_width,save_height);
X	ground.obj_display = XCreateBitmapFromData(dpy,win,ground_bits,ground_width,ground_height);
X}
END_OF_FILE
if test 3503 -ne `wc -c <'initx.c'`; then
    echo shar: \"'initx.c'\" unpacked with wrong size!
fi
# end of 'initx.c'
fi
if test -f 'initx.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'initx.h'\"
else
echo shar: Extracting \"'initx.h'\" \(609 characters\)
sed "s/^X//" >'initx.h' <<'END_OF_FILE'
X#define NUMQ    5 
X#define TRUE (1==1)
X#define FALSE (1==0)
X#define BORDER	1
X#define BORDERWIDTH 3
X#define TITLE "Sokoban"
X#define FONT "-adobe-times-bold-r-normal--18-180-75-75-p-99-iso8859-1"
X#define WIDTH 200
X#define HEIGHT 200
X#define XORIGIN 1
X#define YORIGIN 1
X#define SCR  DefaultScreen(dpy)
X#define DEPTH  DefaultDepth(dpy,SCR)
X#define ROOT DefaultRootWindow(dpy)
X#define COLORMAP DefaultColormap(dpy,SCR)
X#define BLACKPIXEL 	BlackPixel(dpy,SCR)
X#define WHITEPIXEL  WhitePixel(dpy,SCR)
X#define DWIDTH DisplayWidth(dpy,SCR)
X#define DHEIGHT DisplayHeight(dpy,SCR)
X#define DISPLAYNAME XDisplayName(NULL)
END_OF_FILE
if test 609 -ne `wc -c <'initx.h'`; then
    echo shar: \"'initx.h'\" unpacked with wrong size!
fi
# end of 'initx.h'
fi
if test -f 'makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile'\"
else
echo shar: Extracting \"'makefile'\" \(1177 characters\)
sed "s/^X//" >'makefile' <<'END_OF_FILE'
XPARALLEL = # &
XCCOPT= -O
XOBJECTS= sok.o readscreen.o showscreen.o play.o save.o score.o initx.o
XCC = cc
XINCLUDE = -I/usr/X11R5/include
X
Xsokoban: $(PARALLEL) $(OBJECTS)
X	$(CC) $(CCOPT) -o sokoban $(OBJECTS) -lX11 
X
Xinstall:	sokoban
X	cp sokoban /usr/games/sokoban
X	chmod 4711 /usr/games/sokoban
X	-mkdir /usr/games/lib/sokoban
X	-mkdir /usr/games/lib/sokoban/screens
X	-mkdir /usr/games/lib/sokoban/save
X	cp screen.* /usr/games/lib/sokoban/screens
X	@echo "\007"
X	@echo "Login as games, and \"sokoban -c\" to generate new score file"
Xlocal:	sokoban
X	cp sokoban /u/s7/staff/kevins/bin/xsokoban
X	chmod 4755 /u/s7/staff/kevins/bin/xsokoban
X	chown games /u/s7/staff/kevins/bin/xsokoban
X	chgrp games /u/s7/staff/kevins/bin/xsokoban
Xclean:
X	rm -f *.o sokoban
X
Xsok.o: sok.c sokoban.h
X	$(CC) $(CCOPT) -c sok.c
X
Xreadscreen.o: readscreen.c sokoban.h
X	$(CC) $(CCOPT) -c readscreen.c
X
Xshowscreen.o: showscreen.c 
X	$(CC) $(CCOPT) -c showscreen.c
X
Xplay.o: play.c sokoban.h
X	$(CC) $(CCOPT) $(INCLUDE) -c play.c
X
Xsave.o: save.c sokoban.h
X	$(CC) $(CCOPT) -c save.c
X
Xscore.o: score.c sokoban.h
X	$(CC) $(CCOPT) -c score.c
X
Xinitx.o: initx.c sokoban.h obj.h initx.h
X	$(CC) $(CCOPT) $(INCLUDE) -c initx.c
END_OF_FILE
if test 1177 -ne `wc -c <'makefile'`; then
    echo shar: \"'makefile'\" unpacked with wrong size!
fi
# end of 'makefile'
fi
if test -f 'play.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'play.c'\"
else
echo shar: Extracting \"'play.c'\" \(6649 characters\)
sed "s/^X//" >'play.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <ctype.h>
X#include <X11/keysym.h>
X#include "sokoban.h"
X#include "obj.h"
X
X/* defining the types of move */
X#define MOVE 		1
X#define PUSH 		2
X#define SAVE 		3
X#define UNSAVE 	4
X#define STOREMOVE 	5
X#define STOREPUSH 	6
X
X#define EVMASK KeyPressMask | ExposureMask | ButtonPressMask | FocusChangeMask
X
X#if 0
Xvoid doit(void);
X#else
Xvoid doit();
X#endif
Xextern dispstatus();
X
Xextern char	map[MAXROW+1][MAXCOL+1];
Xextern short	rows, cols, level, moves, pushes, savepack, packets;
Xextern short	scorelevel, scoremoves, scorepushes;
Xextern POS	ppos;
Xextern Display	*dpy;
Xextern Window	win;
Xextern GC		gc;
Xextern char	sline[80];
X
Xstatic XEvent	xev;
Xstatic POS	tpos1,			/* testpos1: 1 pos. over/under/left/right */
X			tpos2,			/* testpos2: 2 pos.  "                    */
X			lastppos,			/* the last player position (for undo)    */
X			lasttpos1,lasttpos2;/* last test positions (for undo)         */
Xstatic char 	lppc, ltp1c, ltp2c;	/* the char for the above pos. (for undo) */
Xstatic short	action, lastaction;
XKeySym		keyhit;
Xshort		undolock = 1;		/* locked for undo */
X
X/** For the temporary save **/
Xstatic char  tmp_map[MAXROW+1][MAXCOL+1];
Xstatic short tmp_pushes, tmp_moves, tmp_savepack;
Xstatic POS   tmp_ppos;
X
Xshort play() {
X
X	short 	c,
X			ret = 0;
X	int		keycount;
X	char 	buf[50];
X
X	XSelectInput(dpy,win,EVMASK);
X	tmpsave();
X	showscreen();
X	while(ret == 0) {
X		XNextEvent(dpy,&xev);
X		XDrawString(dpy,win,gc,10,MAXROW*PIXMAPY,sline,strlen(sline));
X		if (xev.type == Expose &&  xev.xexpose.count == 0)
X			showscreen();
X		else
X			if(xev.type == KeyPress)	{
X				keycount = XLookupString(&xev,buf,50,&keyhit,(XComposeStatus *) NULL);
X				if(xev.xkey.state & ControlMask)
X					switch(keyhit)  {
X					case XK_u:
X						tmpreset();
X						undolock = 1;
X						showscreen();
X						break;
X					case XK_r: 
X						clearscreen();
X						break;
X					case XK_Left:
X					case XK_Up:
X					case XK_Right:
X					case XK_Down:
X						doit();
X						break;
X					default:     
X						break;
X					}
X				else
X					switch(keyhit) {
X					case XK_q:    
X						ret = E_ENDGAME; 
X						break;
X					case XK_s:   
X						if( (ret = savegame()) == 0)
X							ret = E_SAVED;
X						break;
X					case XK_c:  
X						tmpsave();
X						break;
X					case XK_U:  
X						moves = pushes = 0;
X						if( (ret = readscreen()) == 0) {
X							showscreen();
X							undolock = 1;
X						}
X						break;
X					case XK_u: 
X						if( ! undolock) {
X							undomove();
X							undolock = 1;
X						}
X						break;
X					case XK_Left:
X					case XK_Up:
X					case XK_Right:
X					case XK_Down:
X						doit();
X						break;
X					default:     
X						break;
X					}
X				if( (ret == 0) && (packets == savepack)) {
X					scorelevel = level;
X					scoremoves = moves;
X					scorepushes = pushes;
X					clearscreen();
X					break;
X				}
X			}
X	}
X	return(ret);
X}
X
Xvoid doit()
X{
X	do {
X		if((action = testmove(keyhit)) != 0) {
X			lastaction = action;
X			lastppos.x = ppos.x; 
X			lastppos.y = ppos.y;
X			lppc = map[ppos.x][ppos.y];
X			lasttpos1.x = tpos1.x; 
X			lasttpos1.y = tpos1.y; 
X			ltp1c = map[tpos1.x][tpos1.y];
X			lasttpos2.x = tpos2.x; 
X			lasttpos2.y = tpos2.y; 
X			ltp2c = map[tpos2.x][tpos2.y];
X			domove(lastaction); 
X			undolock = 0;
X		}
X	} 	while((action != 0) && (packets != savepack) && 
X			((xev.xkey.state & ShiftMask) || (xev.xkey.state & ControlMask)));
X}
X
Xtestmove(action)
Xregister KeySym action;
X{
X	register short ret,
X				stop_at_object = 0;
X	register char  tc;
X
X	if(xev.xkey.state & ShiftMask)
X		stop_at_object = 1;
X
X	if( (action == XK_Up) || (action == XK_Down)) {
X		tpos1.x = (action == XK_Up) ? ppos.x-1 : ppos.x+1;
X		tpos2.x = (action == XK_Up) ? ppos.x-2 : ppos.x+2;
X		tpos1.y = tpos2.y = ppos.y;
X	}
X	else {
X		tpos1.y = (action == XK_Left) ? ppos.y-1 : ppos.y+1;
X		tpos2.y = (action == XK_Left) ? ppos.y-2 : ppos.y+2;
X		tpos1.x = tpos2.x = ppos.x;
X	}
X	tc = map[tpos1.x][tpos1.y];
X	if((tc == packet.obj_intern) || (tc == save.obj_intern)) {
X		if(!stop_at_object) {
X			if(map[tpos2.x][tpos2.y] == ground.obj_intern)
X				ret = (tc == save.obj_intern) ? UNSAVE : PUSH;
X			else if(map[tpos2.x][tpos2.y] == store.obj_intern)
X				ret = (tc == save.obj_intern) ? STOREPUSH : SAVE;
X			else ret = 0;
X		}
X		else ret = 0;
X	}
X	else if(tc == ground.obj_intern)
X		ret = MOVE;
X	else if(tc == store.obj_intern)
X		ret = STOREMOVE;
X	else ret = 0;
X	return(ret);
X}
X
Xdomove( moveaction) 
Xregister short moveaction;
X{
X	map[ppos.x][ppos.y] = (map[ppos.x][ppos.y] == player.obj_intern) 
X		? ground.obj_intern 
X		    : store.obj_intern;
X	switch( moveaction) {
X	case MOVE:      
X		map[tpos1.x][tpos1.y] = player.obj_intern; 	
X		break;
X	case STOREMOVE: 
X		map[tpos1.x][tpos1.y] = playerstore.obj_intern; 	
X		break;
X	case PUSH:      
X		map[tpos2.x][tpos2.y] = map[tpos1.x][tpos1.y];
X		map[tpos1.x][tpos1.y] = player.obj_intern;	
X		pushes++;						
X		break;
X	case UNSAVE:    
X		map[tpos2.x][tpos2.y] = packet.obj_intern;
X		map[tpos1.x][tpos1.y] = playerstore.obj_intern;		
X		pushes++; 
X		savepack--;			 	
X		break;
X	case SAVE:      
X		map[tpos2.x][tpos2.y] = save.obj_intern;
X		map[tpos1.x][tpos1.y] = player.obj_intern;			
X		savepack++; 
X		pushes++;				
X		break;
X	case STOREPUSH: 
X		map[tpos2.x][tpos2.y] = save.obj_intern;
X		map[tpos1.x][tpos1.y] = playerstore.obj_intern;		
X		pushes++;						
X		break;
X	}
X	moves++;
X	dispstatus();
X	mapchar(map[ppos.x][ppos.y], ppos.x, ppos.y);
X	mapchar(map[tpos1.x][tpos1.y], tpos1.x, tpos1.y);
X	mapchar(map[tpos2.x][tpos2.y], tpos2.x, tpos2.y);
X	ppos.x = tpos1.x; 
X	ppos.y = tpos1.y;
X}
X
Xundomove() {
X
X	map[lastppos.x][lastppos.y] = lppc;
X	map[lasttpos1.x][lasttpos1.y] = ltp1c;
X	map[lasttpos2.x][lasttpos2.y] = ltp2c;
X	ppos.x = lastppos.x; 
X	ppos.y = lastppos.y;
X	switch( lastaction) {
X	case MOVE:      
X		moves--;				
X		break;
X	case STOREMOVE: 
X		moves--;				
X		break;
X	case PUSH:      
X		moves--; 
X		pushes--;		
X		break;
X	case UNSAVE:    
X		moves--; 
X		pushes--; 
X		savepack++;	
X		break;
X	case SAVE:      
X		moves--; 
X		pushes--; 
X		savepack--;	
X		break;
X	case STOREPUSH: 
X		moves--; 
X		pushes--;		
X		break;
X	}
X	dispstatus();
X	mapchar( map[ppos.x][ppos.y], ppos.x, ppos.y);
X	mapchar( map[lasttpos1.x][lasttpos1.y], lasttpos1.x, lasttpos1.y);
X	mapchar( map[lasttpos2.x][lasttpos2.y], lasttpos2.x, lasttpos2.y);
X}
X
Xtmpsave() {
X
X	register short i, j;
X
X	for( i = 0; i < rows; i++) for( j = 0; j < cols; j++)
X		tmp_map[i][j] = map[i][j];
X	tmp_pushes = pushes;
X	tmp_moves = moves;
X	tmp_savepack = savepack;
X	tmp_ppos.x = ppos.x; 
X	tmp_ppos.y = ppos.y;
X}
X
Xtmpreset() {
X
X	register short i, j;
X
X	for( i = 0; i < rows; i++) for( j = 0; j < cols; j++)
X		map[i][j] = tmp_map[i][j];
X	pushes = tmp_pushes;
X	moves = tmp_moves;
X	savepack = tmp_savepack;
X	ppos.x = tmp_ppos.x; 
X	ppos.y = tmp_ppos.y;
X}
END_OF_FILE
if test 6649 -ne `wc -c <'play.c'`; then
    echo shar: \"'play.c'\" unpacked with wrong size!
fi
# end of 'play.c'
fi
if test -f 'playerstore.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'playerstore.xbm'\"
else
echo shar: Extracting \"'playerstore.xbm'\" \(296 characters\)
sed "s/^X//" >'playerstore.xbm' <<'END_OF_FILE'
X#define playerstore_width 16
X#define playerstore_height 16
Xstatic char playerstore_bits[] = {
X   0x55, 0x5f, 0xba, 0xae, 0x7d, 0x55, 0xfe, 0xae, 0xfd, 0x57, 0xfb, 0xab,
X   0xf7, 0x55, 0xff, 0xab, 0xd5, 0x57, 0xaa, 0xaf, 0xd5, 0xdd, 0xea, 0xfa,
X   0x55, 0xd5, 0xea, 0xaa, 0x55, 0x55, 0xfa, 0xab};
END_OF_FILE
if test 296 -ne `wc -c <'playerstore.xbm'`; then
    echo shar: \"'playerstore.xbm'\" unpacked with wrong size!
fi
# end of 'playerstore.xbm'
fi
if test -f 'readscreen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'readscreen.c'\"
else
echo shar: Extracting \"'readscreen.c'\" \(1509 characters\)
sed "s/^X//" >'readscreen.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "sokoban.h"
X#include "obj.h"
X
Xextern char *malloc();
Xextern FILE *fopen();
X
Xextern short level, packets, savepack, rows, cols;
Xextern char  map[MAXROW+1][MAXCOL+1];
Xextern POS   ppos;
X
Xshort readscreen() {
X
X   FILE *screen;
X   char *fnam;
X   short j, c, ret = 0;
X
X   fnam = malloc( strlen( SCREENPATH) + 11);
X   sprintf( fnam, "%s/screen.%d", SCREENPATH, level);
X   if( (screen = fopen( fnam, "r")) == NULL) 
X      ret = E_FOPENSCREEN;
X   else {
X      packets = savepack = rows = j = cols  = 0;
X      ppos.x = -1; ppos.y = -1;
X      while( (ret == 0) && ((c = getc( screen)) != EOF)) {
X         if( c == '\n') {
X	    map[rows++][j] = '\0';
X	    if( rows > MAXROW) 
X	       ret = E_TOMUCHROWS;
X	    else {
X	       if( j > cols) cols = j;
X	       j = 0;
X	    }
X	 }
X	 else if( (c == player.obj_intern) || (c == playerstore.obj_intern)) {
X	    if( ppos.x != -1) 
X	       ret = E_PLAYPOS1;
X	    else { 
X	       ppos.x = rows; ppos.y = j;
X	       map[rows][j++] = c;
X	       if( j > MAXCOL) ret = E_TOMUCHCOLS;
X	    }
X	 }
X	 else if( (c == save.obj_intern) || (c == packet.obj_intern) ||
X		  (c == wall.obj_intern) || (c == store.obj_intern) ||
X		  (c == ground.obj_intern)) {
X	    if( c == save.obj_intern)   { savepack++; packets++; }
X	    if( c == packet.obj_intern) packets++;
X	    map[rows][j++] = c;
X	    if( j > MAXCOL) ret = E_TOMUCHCOLS;
X	 }
X	 else ret = E_ILLCHAR;
X      }
X      fclose( screen);
X      if( (ret == 0) && (ppos.x == -1)) ret = E_PLAYPOS2;
X   }
X   return( ret);
X}
END_OF_FILE
if test 1509 -ne `wc -c <'readscreen.c'`; then
    echo shar: \"'readscreen.c'\" unpacked with wrong size!
fi
# end of 'readscreen.c'
fi
if test -f 'save.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'save.c'\"
else
echo shar: Extracting \"'save.c'\" \(3668 characters\)
sed "s/^X//" >'save.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <signal.h>
X#include "sokoban.h"
X
Xextern char  *malloc();
Xextern FILE  *fopen();
X
Xextern char  *username;
Xextern char  map[MAXROW+1][MAXCOL+1];
Xextern short level, moves, pushes, packets, savepack, rows, cols;
Xextern short scoring;
Xextern POS   ppos;
X
Xstatic long        savedbn;
Xstatic char        *sfname;
Xstatic FILE        *savefile;
Xstatic struct stat sfstat;
X
Xshort savegame() {
X
X   short ret = 0;
X
X   signal( SIGINT, SIG_IGN);
X   sfname = malloc( strlen( SAVEPATH) + strlen( username) + 5);
X   sprintf( sfname, "%s/%s.sav", SAVEPATH, username);
X   if( (savefile = fopen( sfname, "w")) == NULL)
X      ret = E_FOPENSAVE;
X   else {
X      savedbn = fileno( savefile);
X      if( write( savedbn, &(map[0][0]), MAXROW*MAXCOL) != MAXROW*MAXCOL)
X	 ret = E_WRITESAVE;
X      else if( write( savedbn, &ppos, sizeof( POS)) != sizeof( POS))     
X	 ret = E_WRITESAVE;
X      else if( write( savedbn, &scoring, 2) != 2)  ret = E_WRITESAVE;
X      else if( write( savedbn, &level, 2) != 2)    ret = E_WRITESAVE;
X      else if( write( savedbn, &moves, 2) != 2)    ret = E_WRITESAVE;
X      else if( write( savedbn, &pushes, 2) != 2)   ret = E_WRITESAVE;
X      else if( write( savedbn, &packets, 2) != 2)  ret = E_WRITESAVE;
X      else if( write( savedbn, &savepack, 2) != 2) ret = E_WRITESAVE;
X      else if( write( savedbn, &rows, 2) != 2)     ret = E_WRITESAVE;
X      else if( write( savedbn, &cols, 2) != 2)     ret = E_WRITESAVE;
X      else {
X	 fclose( savefile);
X	 if( stat( sfname, &sfstat) != 0) ret = E_STATSAVE;
X	 else if( (savefile = fopen( sfname, "a")) == NULL)
X            ret = E_FOPENSAVE;
X         else {
X	    if( write( savedbn, &sfstat, sizeof( sfstat)) != sizeof( sfstat))
X	       ret = E_WRITESAVE;
X	    fclose( savefile);
X	 }
X      }
X   }
X   if( (ret == E_WRITESAVE) || (ret == E_STATSAVE)) unlink( sfname);
X   signal( SIGINT, SIG_DFL);
X
X   return( ret);
X}
X
Xshort restoregame() {
X
X   short ret = 0;
X   struct stat oldsfstat;
X
X   signal( SIGINT, SIG_IGN);
X   sfname = malloc( strlen( SAVEPATH) + strlen( username) + 5);
X   sprintf( sfname, "%s/%s.sav", SAVEPATH, username);
X   if( stat( sfname, &oldsfstat) < -1) 
X      ret = E_NOSAVEFILE;
X   else {
X      if( (savefile = fopen( sfname, "r")) == NULL)
X	 ret = E_FOPENSAVE;
X      else {
X         savedbn = fileno( savefile);
X         if( read( savedbn, &(map[0][0]), MAXROW*MAXCOL) != MAXROW*MAXCOL)
X	    ret = E_READSAVE;
X         else if( read( savedbn, &ppos, sizeof( POS)) != sizeof( POS))     
X	    ret = E_READSAVE;
X         else if( read( savedbn, &scoring, 2) != 2)  ret = E_READSAVE;
X         else if( read( savedbn, &level, 2) != 2)    ret = E_READSAVE;
X         else if( read( savedbn, &moves, 2) != 2)    ret = E_READSAVE;
X         else if( read( savedbn, &pushes, 2) != 2)   ret = E_READSAVE;
X         else if( read( savedbn, &packets, 2) != 2)  ret = E_READSAVE;
X         else if( read( savedbn, &savepack, 2) != 2) ret = E_READSAVE;
X         else if( read( savedbn, &rows, 2) != 2)     ret = E_READSAVE;
X         else if( read( savedbn, &cols, 2) != 2)     ret = E_READSAVE;
X	 else if( read( savedbn, &sfstat, sizeof( sfstat)) != sizeof( sfstat))
X	    ret = E_READSAVE;
X	 else if( (sfstat.st_dev != oldsfstat.st_dev) ||
X                  (sfstat.st_ino != oldsfstat.st_ino) ||
X                  (sfstat.st_nlink != oldsfstat.st_nlink) ||
X                  (sfstat.st_uid != oldsfstat.st_uid) ||
X                  (sfstat.st_gid != oldsfstat.st_gid) ||
X                  (sfstat.st_mtime != oldsfstat.st_mtime))
X            ret = E_ALTERSAVE;
X      }
X      unlink( sfname);
X   }
X   signal( SIGINT, SIG_DFL);
X   return( ret);
X}
END_OF_FILE
if test 3668 -ne `wc -c <'save.c'`; then
    echo shar: \"'save.c'\" unpacked with wrong size!
fi
# end of 'save.c'
fi
if test -f 'score.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'score.c'\"
else
echo shar: Extracting \"'score.c'\" \(5071 characters\)
sed "s/^X//" >'score.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <signal.h>
X#include "sokoban.h"
X
Xextern FILE *fopen();
X
Xextern char  *username;
Xextern short scorelevel, scoremoves, scorepushes;
X
Xstatic short scoreentries;
Xstatic struct {
X   char user[MAXUSERNAME];
X   short lv, mv, ps;
X} scoretable[MAXSCOREENTRIES];
X
Xstatic FILE *scorefile;
Xstatic long sfdbn;
X
Xshort outputscore() {
X
X   short ret;
X
X   while( creat( LOCKFILE, 0666) < 0);	/* lock the score file */
X   if( (ret = readscore()) == 0)
X      showscore();
X   unlink( LOCKFILE);
X   return( (ret == 0) ? E_ENDGAME : ret);
X}
X
Xshort makenewscore() {
X
X   short ret = 0;
X
X   while( creat( LOCKFILE, 0666) < 0) ;
X   scoreentries = 0;
X   if( (scorefile = fopen( SCOREFILE, "w")) == NULL)
X      ret = E_FOPENSCORE;
X   else {
X      sfdbn = fileno( scorefile);
X      if( write( sfdbn, &scoreentries, 2) != 2) ret = E_WRITESCORE;
X      fclose( scorefile);
X   }
X   unlink( LOCKFILE);
X   return( (ret == 0) ? E_ENDGAME : ret);
X}
X
Xshort getuserlevel( lv)
Xshort *lv;
X{
X   short ret = 0, pos;
X
X   while( creat( LOCKFILE, 0666) < 0);
X   if( (scorefile = fopen( SCOREFILE, "r")) == NULL)
X      ret = E_FOPENSCORE;
X   else {
X      if( (ret = readscore()) == 0)
X	 *lv = ( (pos = finduser()) > -1) ? scoretable[pos].lv+1 : 1;
X   }
X   unlink( LOCKFILE);
X   return( ret);
X}
X
Xshort score() {
X   
X   short ret;
X
X   while( creat( LOCKFILE, 0666) < 0);	/* lock the score file */
X   if( (ret = readscore()) == 0)
X      if( (ret = makescore()) == 0)
X	 if( (ret = writescore()) == 0)
X	    showscore();
X   unlink( LOCKFILE);
X   return( (ret == 0) ? E_ENDGAME : ret);
X}
X
Xreadscore() {
X
X   short ret = 0;
X   long tmp;
X
X   if( (scorefile = fopen( SCOREFILE, "r")) == NULL)
X      ret = E_FOPENSCORE;
X   else {
X      sfdbn = fileno( scorefile);
X      if( read( sfdbn, &scoreentries, 2) != 2) ret = E_READSCORE;
X      else {
X	 tmp = scoreentries * sizeof( scoretable[0]);
X	 if( read( sfdbn, &(scoretable[0]), tmp) != tmp) ret = E_READSCORE;
X      }
X      fclose( scorefile);
X   }
X   return( ret);
X}
X
Xmakescore() {
X
X   short ret = 0, pos, i, build = 1, insert;
X
X   if( (pos = finduser()) > -1) {	/* user already in score file */
X      insert =    (scorelevel > scoretable[pos].lv)
X	       || ( (scorelevel == scoretable[pos].lv) &&
X                    (scoremoves < scoretable[pos].mv)
X		  )
X	       || ( (scorelevel == scoretable[pos].lv) &&
X		    (scoremoves == scoretable[pos].mv) &&
X		    (scorepushes < scoretable[pos].ps)
X		  );
X      if( insert) { 			/* delete existing entry */
X	 for( i = pos; i < scoreentries-1; i++)
X	    cp_entry( i, i+1);
X	 scoreentries--;
X      }
X      else build = 0;
X   }
X   else if( scoreentries == MAXSCOREENTRIES)
X      ret = E_TOMUCHSE;
X   if( (ret == 0) && build) {
X      pos = findpos();			/* find the new score position */
X      if( pos > -1) {			/* score table not empty */
X	 for( i = scoreentries; i > pos; i--)
X	    cp_entry( i, i-1);
X      }
X      else pos = scoreentries;
X
X      strcpy( scoretable[pos].user, username);
X      scoretable[pos].lv = scorelevel;
X      scoretable[pos].mv = scoremoves;
X      scoretable[pos].ps = scorepushes;
X      scoreentries++;
X   }
X   return( ret);
X}
X
Xfinduser() {
X
X   short i, found = 0;
X
X   for( i = 0; (i < scoreentries) && (! found); i++)
X      found = (strcmp( scoretable[i].user, username) == 0);
X   return( (found) ? i-1 : -1);
X}
X
Xfindpos() {
X 
X   short i, found = 0;
X
X   for( i = 0; (i < scoreentries) && (! found); i++)
X      found =    (scorelevel > scoretable[i].lv)
X	      || ( (scorelevel == scoretable[i].lv) &&
X                   (scoremoves < scoretable[i].mv)
X		 )
X	      || ( (scorelevel == scoretable[i].lv) &&
X		   (scoremoves == scoretable[i].mv) &&
X		   (scorepushes < scoretable[i].ps)
X		 );
X   return( (found) ? i-1 : -1);
X}
X
Xwritescore() {
X
X   short ret = 0;
X   long tmp;
X
X   if( (scorefile = fopen( SCOREFILE, "w")) == NULL)
X      ret = E_FOPENSCORE;
X   else {
X      sfdbn = fileno( scorefile);
X      if( write( sfdbn, &scoreentries, 2) != 2) ret = E_WRITESCORE;
X      else {
X	 tmp = scoreentries * sizeof( scoretable[0]);
X	 if( write( sfdbn, &(scoretable[0]), tmp) != tmp) ret = E_WRITESCORE;
X      }
X      fclose( scorefile);
X   }
X   return( ret);
X}
X
Xshowscore() {
X
X   register short lastlv = 0, lastmv = 0, lastps = 0, i;
X
X   fprintf( stdout, "Rank        User     Level     Moves    Pushes\n");
X   fprintf( stdout, "==============================================\n");
X   for( i = 0; i < scoreentries; i++) {
X      if( (scoretable[i].lv == lastlv)&& 
X	  (scoretable[i].mv == lastmv) && 
X	  (scoretable[i].ps == lastps))
X	 fprintf( stdout, "      ");
X      else {
X         lastlv = scoretable[i].lv;
X         lastmv = scoretable[i].mv;
X         lastps = scoretable[i].ps;
X         fprintf( stdout, "%4d  ", i+1);
X      }
X      fprintf( stdout, "%10s  %8d  %8d  %8d\n", scoretable[i].user, 
X		scoretable[i].lv, scoretable[i].mv, scoretable[i].ps);
X   }
X}
X
Xcp_entry( i1, i2)
Xregister short i1, i2;
X{
X   strcpy( scoretable[i1].user, scoretable[i2].user);
X   scoretable[i1].lv = scoretable[i2].lv;
X   scoretable[i1].mv = scoretable[i2].mv;
X   scoretable[i1].ps = scoretable[i2].ps;
X}
END_OF_FILE
if test 5071 -ne `wc -c <'score.c'`; then
    echo shar: \"'score.c'\" unpacked with wrong size!
fi
# end of 'score.c'
fi
if test ! -d 'screens' ; then
    echo shar: Creating directory \"'screens'\"
    mkdir 'screens'
fi
if test -f 'screens/screen.10' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screens/screen.10'\"
else
echo shar: Extracting \"'screens/screen.10'\" \(320 characters\)
sed "s/^X//" >'screens/screen.10' <<'END_OF_FILE'
X ###  #############
X##@####       #   #
X# $$   $$  $ $ ...#
X#  $$$#    $  #...#
X# $   # $$ $$ #...#
X###   #  $    #...#
X#     # $ $ $ #...#
X#    ###### ###...#
X## #  #  $ $  #...#
X#  ## # $$ $ $##..#
X# ..# #  $      #.#
X# ..# # $$$ $$$ #.#
X##### #       # #.#
X    # ######### #.#
X    #           #.#
X    ###############
END_OF_FILE
if test 320 -ne `wc -c <'screens/screen.10'`; then
    echo shar: \"'screens/screen.10'\" unpacked with wrong size!
fi
# end of 'screens/screen.10'
fi
if test -f 'screens/screen.14' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screens/screen.14'\"
else
echo shar: Extracting \"'screens/screen.14'\" \(284 characters\)
sed "s/^X//" >'screens/screen.14' <<'END_OF_FILE'
X       #######
X #######     #
X #     # $@$ #
X #$$ #   #########
X # ###......##   #
X #   $......## # #
X # ###......     #
X##   #### ### #$##
X#  #$   #  $  # #
X#  $ $$$  # $## #
X#   $ $ ###$$ # #
X#####     $   # #
X    ### ###   # #
X      #     #   #
X      ########  #
X             ####
END_OF_FILE
if test 284 -ne `wc -c <'screens/screen.14'`; then
    echo shar: \"'screens/screen.14'\" unpacked with wrong size!
fi
# end of 'screens/screen.14'
fi
if test -f 'screens/screen.20' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screens/screen.20'\"
else
echo shar: Extracting \"'screens/screen.20'\" \(303 characters\)
sed "s/^X//" >'screens/screen.20' <<'END_OF_FILE'
X    ##########
X#####        ####
X#     #   $  #@ #
X# #######$####  ###
X# #    ## #  #$ ..#
X# # $     #  #  #.#
X# # $  #     #$ ..#
X# #  ### ##     #.#
X# ###  #  #  #$ ..#
X# #    #  ####  #.#
X# #$   $  $  #$ ..#
X#    $ # $ $ #  #.#
X#### $###    #$ ..#
X   #    $$ ###....#
X   #      ## ######
X   ########
END_OF_FILE
if test 303 -ne `wc -c <'screens/screen.20'`; then
    echo shar: \"'screens/screen.20'\" unpacked with wrong size!
fi
# end of 'screens/screen.20'
fi
if test -f 'screens/screen.22' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screens/screen.22'\"
else
echo shar: Extracting \"'screens/screen.22'\" \(311 characters\)
sed "s/^X//" >'screens/screen.22' <<'END_OF_FILE'
X######     ####
X#    #######  #####
X#   $#  #  $  #   #
X#  $  $  $ # $ $  #
X##$ $   # @# $    #
X#  $ ########### ##
X# #   #.......# $#
X# ##  # ......#  #
X# #   $........$ #
X# # $ #.... ..#  #
X#  $ $####$#### $#
X# $   ### $   $  ##
X# $     $ $  $    #
X## ###### $ ##### #
X#         #       #
X###################
END_OF_FILE
if test 311 -ne `wc -c <'screens/screen.22'`; then
    echo shar: \"'screens/screen.22'\" unpacked with wrong size!
fi
# end of 'screens/screen.22'
fi
if test -f 'screens/screen.24' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screens/screen.24'\"
else
echo shar: Extracting \"'screens/screen.24'\" \(306 characters\)
sed "s/^X//" >'screens/screen.24' <<'END_OF_FILE'
X###############
X#..........  .####
X#..........$$.#  #
X###########$ #   ##
X#      $  $     $ #
X## ####   #  $ #  #
X#      #   ##  # ##
X#  $#  # ##  ### ##
X# $ #$###    ### ##
X###  $ #  #  ### ##
X###    $ ## #  # ##
X # $  #  $  $ $   #
X #  $  $#$$$  #   #
X #  #  $      #####
X # @##  #  #  #
X ##############
END_OF_FILE
if test 306 -ne `wc -c <'screens/screen.24'`; then
    echo shar: \"'screens/screen.24'\" unpacked with wrong size!
fi
# end of 'screens/screen.24'
fi
if test -f 'screens/screen.25' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screens/screen.25'\"
else
echo shar: Extracting \"'screens/screen.25'\" \(295 characters\)
sed "s/^X//" >'screens/screen.25' <<'END_OF_FILE'
X####
X#  ##############
X#  #   ..#......#
X#  # # ##### ...#
X##$#    ........#
X#   ##$######  ####
X# $ #     ######@ #
X##$ # $   ######  #
X#  $ #$$$##       #
X#      #    #$#$###
X# #### #$$$$$    #
X# #    $     #   #
X# #   ##        ###
X# ######$###### $ #
X#        #    #   #
X##########    #####
END_OF_FILE
if test 295 -ne `wc -c <'screens/screen.25'`; then
    echo shar: \"'screens/screen.25'\" unpacked with wrong size!
fi
# end of 'screens/screen.25'
fi
if test -f 'screens/screen.35' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screens/screen.35'\"
else
echo shar: Extracting \"'screens/screen.35'\" \(298 characters\)
sed "s/^X//" >'screens/screen.35' <<'END_OF_FILE'
X############ ######
X#   #    # ###....#
X#   $$#   @  .....#
X#   # ###   # ....#
X## ## ###  #  ....#
X # $ $     # # ####
X #  $ $##  #      #
X#### #  #### # ## #
X#  # #$   ## #    #
X# $  $  # ## #   ##
X# # $ $    # #   #
X#  $ ## ## # #####
X# $$     $$  #
X## ## ### $  #
X #    # #    #
X ###### ######
END_OF_FILE
if test 298 -ne `wc -c <'screens/screen.35'`; then
    echo shar: \"'screens/screen.35'\" unpacked with wrong size!
fi
# end of 'screens/screen.35'
fi
if test -f 'screens/screen.36' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screens/screen.36'\"
else
echo shar: Extracting \"'screens/screen.36'\" \(289 characters\)
sed "s/^X//" >'screens/screen.36' <<'END_OF_FILE'
X            #####
X#####  ######   #
X#   ####  $ $ $ #
X# $   ## ## ##  ##
X#   $ $     $  $ #
X### $  ## ##     ##
X  # ##### #####$$ #
X ##$##### @##     #
X # $  ###$### $  ##
X # $  #   ###  ###
X # $$ $ #   $$ #
X #     #   ##  #
X #######.. .###
X    #.........#
X    #.........#
X    ###########
END_OF_FILE
if test 289 -ne `wc -c <'screens/screen.36'`; then
    echo shar: \"'screens/screen.36'\" unpacked with wrong size!
fi
# end of 'screens/screen.36'
fi
if test -f 'screens/screen.37' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screens/screen.37'\"
else
echo shar: Extracting \"'screens/screen.37'\" \(272 characters\)
sed "s/^X//" >'screens/screen.37' <<'END_OF_FILE'
X###########
X#......   #########
X#......   #  ##   #
X#..### $    $     #
X#... $ $ #   ##   #
X#...#$#####    #  #
X###    #   #$  #$ #
X  #  $$ $ $  $##  #
X  #  $   #$#$ ##$ #
X  ### ## #    ##  #
X   #  $ $ ## ######
X   #    $  $  #
X   ##   # #   #
X    #####@#####
X        ###
END_OF_FILE
if test 272 -ne `wc -c <'screens/screen.37'`; then
    echo shar: \"'screens/screen.37'\" unpacked with wrong size!
fi
# end of 'screens/screen.37'
fi
if test -f 'screens/screen.39' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screens/screen.39'\"
else
echo shar: Extracting \"'screens/screen.39'\" \(291 characters\)
sed "s/^X//" >'screens/screen.39' <<'END_OF_FILE'
X             ######
X #############....#
X##   ##     ##....#
X#  $$##  $ @##....#
X#      $$ $#  ....#
X#  $ ## $$ # # ...#
X#  $ ## $  #  ....#
X## ##### ### ##.###
X##   $  $ ##   .  #
X# $###  # ##### ###
X#   $   #       #
X#  $ #$ $ $###  #
X# $$$# $   # ####
X#    #  $$ #
X######   ###
X     #####
END_OF_FILE
if test 291 -ne `wc -c <'screens/screen.39'`; then
    echo shar: \"'screens/screen.39'\" unpacked with wrong size!
fi
# end of 'screens/screen.39'
fi
if test -f 'screens/screen.41' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screens/screen.41'\"
else
echo shar: Extracting \"'screens/screen.41'\" \(286 characters\)
sed "s/^X//" >'screens/screen.41' <<'END_OF_FILE'
X           #####
X          ##   ##
X         ##     #
X        ##  $$  #
X       ## $$  $ #
X       # $    $ #
X####   #   $$ #####
X#  ######## ##    #
X#.            $$$@#
X#.# ####### ##   ##
X#.# #######. #$ $##
X#........... #    #
X##############  $ #
X             ##  ##
X              ####
END_OF_FILE
if test 286 -ne `wc -c <'screens/screen.41'`; then
    echo shar: \"'screens/screen.41'\" unpacked with wrong size!
fi
# end of 'screens/screen.41'
fi
if test -f 'screens/screen.50' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screens/screen.50'\"
else
echo shar: Extracting \"'screens/screen.50'\" \(307 characters\)
sed "s/^X//" >'screens/screen.50' <<'END_OF_FILE'
X      ############
X     ##..    #   #
X    ##..* $    $ #
X   ##..*.# # # $##
X   #..*.# # # $  #
X####...#  #    # #
X#  ## #          #
X# @$ $ ###  #   ##
X# $   $   # #   #
X###$$   # # # # #
X  #   $   # # #####
X  # $# #####      #
X  #$   #   #    # #
X  #  ###   ##     #
X  #  #      #    ##
X  ####      ######
END_OF_FILE
if test 307 -ne `wc -c <'screens/screen.50'`; then
    echo shar: \"'screens/screen.50'\" unpacked with wrong size!
fi
# end of 'screens/screen.50'
fi
if test -f 'showscreen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'showscreen.c'\"
else
echo shar: Extracting \"'showscreen.c'\" \(5219 characters\)
sed "s/^X//" >'showscreen.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "sokoban.h"
X#include "obj.h"
X
Xextern Display		*dpy;
Xextern Window		win;
Xextern GC			gc,gclear;
X
Xextern short rows, cols, level, moves, pushes, packets, savepack;
Xextern char  map[MAXROW+1][MAXCOL+1];
Xchar line[80];
X
Xshowscreen() {
X
X   register short i, j;
X
X   for( i = 0; i < rows; i++)	{
X      for( j = 0; map[i][j] != '\0'; j++)
X			mapchar(map[i][j], i, j);
X	}
X   dispstatus();
X}
X
Xmapchar( c, i, j) 
Xregister char c; 
Xregister short i, j;
X{
X	OBJECT *obj, *get_obj_adr();
X
X	obj = get_obj_adr(c);
X	XCopyPlane(dpy,obj->obj_display,win,gc,0,0,PIXMAPX,PIXMAPY,j*PIXMAPX+PIXMAPX*(MAXCOL/2-cols/2),i*PIXMAPY+PIXMAPY*(MAXROW/2-rows/2),1);	
X}
X
Xclearscreen() {
X
X   register short i, j;
X
X   for( i = 0; i < rows; i++)	{
X      for( j = 0; map[i][j] != '\0'; j++)
X			clearchar(map[i][j], i, j);
X	}
X   dispstatus();
X}
X
Xclearchar( c, i, j) 
Xregister char c; 
Xregister short i, j;
X{
X	XCopyPlane(dpy,ground.obj_display,win,gc,0,0,PIXMAPX,PIXMAPY,j*PIXMAPX+PIXMAPX*(MAXCOL/2-cols/2),i*PIXMAPY+PIXMAPY*(MAXROW/2-rows/2),1);	
X}
X
XOBJECT *get_obj_adr(c)
Xregister char c;
X{
X   register OBJECT *ret;
X	if (c ==  player.obj_intern)		return &player;
X	if (c ==  playerstore.obj_intern)	return &playerstore;
X	if (c ==  store.obj_intern)		return &store;
X	if (c ==  save.obj_intern)		return &save;
X	if (c ==  packet.obj_intern)		return &packet;
X	if (c ==  wall.obj_intern)		return &wall;
X	if (c ==  ground.obj_intern)		return &ground;
X	return &ground;
X}
X
X
Xdispstatus()
X{
X
X	XDrawString(dpy,win,gclear,10,MAXROW*PIXMAPY,line,strlen(line));
X	sprintf(line,"         %3d            %3d         %3d        %5d         %5d ",level,packets,savepack,moves,pushes);	
X	XDrawString(dpy,win,gc,10,MAXROW*PIXMAPY,line,strlen(line));
X}
X
Xhelpmessage() {
X   fprintf( stdout,"Press ? for help.\n");
X}
X/*
Xstatic char *helppages[] = { 
X   "The problem is to push packets to",
X   "saving positions by moving around",
X   "and  pushing only one packet at a",
X   "        time if possible.        ",
X   "                                 ",
X   "                                 ",
X   "                                 ",
X   "                                 ",
X   "                                 ",
X   NULL,				
X   "Moving: You can move by using    ",
X   "           the vi-keys hjkl.     ",
X   "                                 ",
X   "              left right up down ",
X   "  Move/Push     h    l    k   j  ",
X   "  Run/Push      H    L    K   J  ",
X   "  Run only     ^H   ^L   ^K  ^J  ",
X   "                                 ",
X   "                                 ",
X   NULL,			
X   "Other commands:                  ",
X   "   c:  temporary save            ",
X   "   q:  quit                      ",
X   "  ^R:  refresh the screen        ",
X   "   s:  save the game             ",
X   "   u:  undo last move/push       ",
X   "   U:  undo all                  ",
X   "  ^U:  reset to temp save        ",
X   "   ?:  this help scree           ",
X   NULL,		
X   "Characters on screen are:        ",
X   "                                 ",
X   "  %@  player                     ",
X   "  %+  player on saving position  ",
X   "  %.  saving position for packet ",
X   "  %$  packet                     ",
X   "  %*  saved packet               ",
X   "  %#  wall                       ",
X   "                                 ",
X   NULL,	
X   "If you set a temporary  save, you",
X   "need not  undo  all when you  get",
X   "stucked. Just reset to this save.",
X   "                                 ",
X   "A temporary save is automatically",
X   "made at the start.",
X   "                                 ",
X   "                                 ",
X   "                                 ",
X   NULL,
X   NULL
X};
X
Xstatic char *title[] = {
X   "          S O K O B A N          ",
X   "---------------------------------"
X};
X
Xstatic char *helphelp[] = {
X   "   (Press return to exit help,   ",
X   "    any other key to continue)   "
X};
X
X#define HELPROWS	16
X#define HELPCOLS	37
X
Xshowhelp() {
X
X   register short line, i;
X   short goon = 1;
X   WINDOW *win, *makehelpwin();
X
X   win = makehelpwin();
X   for( i = 0, line = 2; goon; i++, line++) {
X      if( helppages[i] != NULL) {
X	 wmove( win, line+1, 2);
X	 printhelpline( win, helppages[i]);
X      }
X      else {
X	 wmove( win, HELPROWS-1, 0);
X	 wrefresh( win);
X	 if( (goon = (wgetch( win) != '\n'))) {
X	    line = 1;
X	    if( helppages[i+1] == NULL) i = -1;
X	 }
X      }
X   }
X   werase( win);
X   wrefresh( win);
X   delwin( win);
X}
X
XWINDOW *makehelpwin() {
X
X   WINDOW *win, *newwin();
X
X   win = newwin( HELPROWS, HELPCOLS, 2, 0);
X   box( win, '|', '-');
X   wmove( win, 1, 2);
X   wprintw( win, "%s", title[0]);
X   wmove( win, 2, 2);
X   wprintw( win, "%s", title[1]);
X   wmove( win, HELPROWS-3, 2);
X   wprintw( win, "%s", helphelp[0]);
X   wmove( win, HELPROWS-2, 2);
X   wprintw( win, "%s", helphelp[1]);
X
X   return( win);
X}
X
Xprinthelpline( win, line)
XWINDOW *win;
Xchar *line;
X{
X   OBJECT *obj, *get_obj_adr();
X
X   for( ; *line != '\0'; line++) {
X      if( *line == '%') {
X	 ++line;
X	 obj = get_obj_adr( *line);
X         if( obj -> invers) wstandout( win);
X         waddch( win, obj -> obj_display); waddch( win, obj -> obj_display);
X         if( obj -> invers) wstandend( win);
X      }
X      else waddch( win, *line);
X   }
X}
X*/
END_OF_FILE
if test 5219 -ne `wc -c <'showscreen.c'`; then
    echo shar: \"'showscreen.c'\" unpacked with wrong size!
fi
# end of 'showscreen.c'
fi
if test -f 'sok.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sok.c'\"
else
echo shar: Extracting \"'sok.c'\" \(4950 characters\)
sed "s/^X//" >'sok.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "sokoban.h"
X
XOBJECT 
X   player = 	 { '@',NULL, 0 },
X   playerstore = { '+',NULL, 1 },
X   store = 	 { '.',NULL, 0 },
X   packet = 	 { '$',NULL, 0 },
X   save = 	 { '*',NULL, 1 },
X   ground = 	 { ' ',NULL, 0 },
X   wall = 	 { '#',NULL, 1 };
X
Xextern char  *rindex(), *getlogin(), *getpass();
Xextern short readscreen(), play(), outputscore(), getuserlevel(),
X	     makenewscore(), restoregame(), score();
X
Xshort scoring = 1;
Xshort level, packets, savepack, moves, pushes, rows, cols;
Xshort scorelevel, scoremoves, scorepushes;
Xchar  map[MAXROW+1][MAXCOL+1];
XPOS   ppos;
Xchar  *username, *prgname;
X
Xstatic short optshowscore = 0, 
X	     optmakescore = 0, 
X             optrestore = 0, 
X	     optlevel = 0; 
Xstatic short superuser = 0;
X
Xstatic short userlevel;
X
Xmain( argc, argv) 
Xshort argc; 
Xchar *argv[];
X{
X   short ret, ret2;
X
X   scorelevel = 0;
X   moves = pushes = packets = savepack = 0;
X   if( (prgname = rindex( argv[0], '/')) == NULL)
X      prgname = argv[0];
X   else prgname++;
X   if( (username = getlogin()) == NULL)
X      ret = E_NOUSER;
X   else {
X      superuser = (strcmp( username, SUPERUSER) == 0);
X      if( (ret = checkcmdline( argc, argv)) == 0) {
X         if( optshowscore)
X	    ret = outputscore();
X         else if( optmakescore) {
X	    if( superuser) {
X	       if( (ret = getpassword()) == 0)
X	          ret = makenewscore();
X	    }
X	    else ret = E_NOSUPER;
X	 }
X	 else if( optrestore) {
X	    ret = restoregame();
X	 }
X         else if( (ret = getuserlevel( &userlevel)) == 0) {
X            if( optlevel > 0) {
X	       if( superuser) {
X	          level = optlevel;
X		  scoring = 0;
X	       }
X	       else if( userlevel < optlevel)
X	          ret = E_LEVELTOOHIGH;
X	       else level = optlevel;
X	    }
X	    else level = userlevel;
X         }
X      }
X   }
X   if( ret == 0) {
X	initx();
X      ret = gameloop();
X	killx();
X	}
X   errmess( ret);
X   if( scorelevel && scoring) {
X      ret2 = score();
X      errmess( ret2);
X   }
X   exit( ret);
X}
X
Xcheckcmdline( argc, argv) 
Xshort argc; 
Xchar *argv[];
X{
X   short ret = 0;
X
X   if( argc > 1)
X      if( (argc == 2) && (argv[1][0] == '-')) {
X	 if( (argv[1][1] == 's') && (argv[1][2] == '\0'))
X	    optshowscore = 1;
X	 else if( (argv[1][1] == 'c') && (argv[1][2] == '\0'))
X	    optmakescore = 1;
X	 else if( (argv[1][1] == 'r') && (argv[1][2] == '\0'))
X	    optrestore = 1;
X	 else if( (optlevel = atoi( &(argv[1][1]))) == 0)
X	    ret = E_USAGE;
X      }
X      else ret = E_USAGE;
X   return( ret);
X}
X
Xgameloop() {
X
X   short ret ;
X
X	ret = readscreen();
X   while( ret == 0) {
X      if( (ret = play()) == 0) {
X         level++;
X         moves = pushes = packets = savepack = 0;
X         ret = readscreen();
X      }
X   }
X   return( ret);
X}
X
Xgetpassword() {
X
X   return( (strcmp(getpass("Password: "), PASSWORD) == 0) ? 0 : E_ILLPASSWORD);
X}
X
Xchar *message[] = {
X   "illegal error number",
X   "cannot open screen file",
X   "more than one player position in screen file",
X   "illegal char in screen file",
X   "no player position in screenfile",
X   "too much rows in screen file",
X   "too much columns in screenfile",
X   "quit the game",
X   NULL,			/* errmessage deleted */
X   "cannot get your username",
X   "cannot open savefile",
X   "error writing to savefile",
X   "cannot stat savefile",
X   "error reading savefile",
X   "cannot restore, your savefile has been altered",
X   "game saved",
X   "too much users in score table",
X   "cannot open score file",
X   "error reading scorefile",
X   "error writing scorefile",
X   "illegal command line syntax",
X   "illegal password",
X   "level number too big in command line",
X   "only superuser is allowed to make a new score table",
X   "cannot find file to restore"
X};
X
Xerrmess( ret) 
Xregister short ret;
X{
X   if( ret != E_ENDGAME) {
X      fprintf( stderr, "%s: ", prgname);
X      switch( ret) {
X         case E_FOPENSCREEN: case E_PLAYPOS1:   case E_ILLCHAR: 
X	 case E_PLAYPOS2:    case E_TOMUCHROWS: case E_TOMUCHCOLS: 
X	 case E_ENDGAME:     case E_NOUSER:      
X	 case E_FOPENSAVE:   case E_WRITESAVE:  case E_STATSAVE:    
X	 case E_READSAVE:    case E_ALTERSAVE:  case E_SAVED:       
X	 case E_TOMUCHSE:    case E_FOPENSCORE: case E_READSCORE: 
X	 case E_WRITESCORE:  case E_USAGE:	case E_ILLPASSWORD:
X	 case E_LEVELTOOHIGH: case E_NOSUPER:	case E_NOSAVEFILE:
X			     fprintf( stderr, "%s\n", message[ret]);
X                             break;
X         default:            fprintf( stderr, "%s\n", message[0]);
X                             break;
X      }
X      if( ret == E_USAGE) usage();
X   }
X}
X
Xstatic char *usagestr[] = {
X   "           -c:    create new score table (superuser only)\n",
X   "           -r:    restore saved game\n",
X   "           -s:    show score table\n",
X   "           -<nn>: play this level (<nn> must be greater 0)\n",
X   NULL
X};
X
Xusage() {
X
X   register short i;
X
X   fprintf( stderr, "Usage: %s [-{s|c|r|<nn>}]\n\n", prgname);
X   for( i = 0; usagestr[i] != NULL; i++)
X      fprintf( stderr, "%s", usagestr[i]);
X}
END_OF_FILE
if test 4950 -ne `wc -c <'sok.c'`; then
    echo shar: \"'sok.c'\" unpacked with wrong size!
fi
# end of 'sok.c'
fi
if test -f 'sokoban.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sokoban.h'\"
else
echo shar: Extracting \"'sokoban.h'\" \(2634 characters\)
sed "s/^X//" >'sokoban.h' <<'END_OF_FILE'
X/***********************************************************************
X   You may wish to alter the following directory paths
X***********************************************************************/
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X/**/
X/* SCREENPATH: the name of the directioy where the screen file are held */
X/**/
X#define SCREENPATH 	"/u/s7/staff/kevins/src/X/sokoban/screens"
X
X/**/
X/* SAVEPATH: the name of the path where save files are held */
X/*           Attention: Be sure that there are no other files with */
X/*                      the name <username>.sav                    */
X/**/
X#define SAVEPATH	"/u/s7/staff/kevins/src/X/sokoban/"
X
X/**/
X/* LOCKPATH: temporary file which is created to ensure that no users */
X/*           work with the scorefile at the same time                */
X/**/
X#define LOCKFILE	"/tmp/sok.lock"
X
X/**/
X/* SCOREFILE: the full pathname of the score file */
X/**/
X#define SCOREFILE	"/u/s3/games/lib/sokoban/sok.score"
X
X/**/
X/* MAXUSERNAME: defines the maximum length of a system's user name */
X/**/
X#define MAXUSERNAME	10
X
X/**/
X/* MAXSCOREENTRIES: defines the maximum numner of entries in the scoretable */
X/**/
X#define MAXSCOREENTRIES	50
X
X/**/
X/* SUPERUSER: defines the name of the game superuser */
X/**/
X#define SUPERUSER "kevins"
X
X/**/
X/* PASSWORD: defines the password necessary for creating a new score file */
X/**/
X#define PASSWORD "nabokos"
X
X/**/
X/* OBJECT: this typedef is used for internal and external representation */
X/*         of objects                                                    */
X/**/
Xtypedef struct {
X   char obj_intern;	/* internal representation of the object */
X   Pixmap obj_display;	/* display char for the object		 */
X   short invers;	/* if set to 1 the object will be shown invers */
X} OBJECT;
X
X
X/*************************************************************************
X********************** DO NOT CHANGE BELOW THIS LINE *********************
X*************************************************************************/
X#define MAXROW		20
X#define MAXCOL		40
X#define PIXMAPX	16
X#define PIXMAPY	16
X
Xtypedef struct {
X   short x, y;
X} POS;
X
X#define E_FOPENSCREEN	1
X#define E_PLAYPOS1	2
X#define E_ILLCHAR	3
X#define E_PLAYPOS2	4
X#define E_TOMUCHROWS	5
X#define E_TOMUCHCOLS	6
X#define E_ENDGAME	7
X#define E_NOUSER	9
X#define E_FOPENSAVE	10
X#define E_WRITESAVE	11
X#define E_STATSAVE	12
X#define E_READSAVE	13
X#define E_ALTERSAVE	14
X#define E_SAVED		15
X#define E_TOMUCHSE	16
X#define E_FOPENSCORE	17
X#define E_READSCORE	18
X#define E_WRITESCORE	19
X#define E_USAGE		20
X#define E_ILLPASSWORD	21
X#define E_LEVELTOOHIGH	22
X#define E_NOSUPER	23
X#define E_NOSAVEFILE	24
END_OF_FILE
if test 2634 -ne `wc -c <'sokoban.h'`; then
    echo shar: \"'sokoban.h'\" unpacked with wrong size!
fi
# end of 'sokoban.h'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
