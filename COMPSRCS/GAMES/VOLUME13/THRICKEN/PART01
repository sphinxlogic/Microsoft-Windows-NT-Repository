Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v13i101:  thricken - a multiscreen collect-the-objects style game, Part01/01
Message-ID: <3068@master.CNA.TEK.COM>
Date: 19 Jun 92 16:12:54 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2015
Approved: billr@saab.CNA.TEK.COM

Submitted-by: James Bonfield <rince@dcs.warwick.ac.uk>
Posting-number: Volume 13, Issue 101
Archive-name: thricken/Part01
Environment: curses


[[Thricken is the sequel to perp. It's a more sophisticated system allowing for
a far more flexible game. It is still outdated however and is a given up
project. Even so, it is definitely in a playable state.

	James 'Rince' Bonfield]]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  README MANIFEST Makefile data data/00-03col data/00-03spr
#   data/00level data/01level data/02level data/03level data/04col
#   data/04level data/04spr data/05col data/05level data/05spr
#   data/06col data/06level data/06spr data/README data/scores
#   data/screen extern.h files.c main.c scores.c screen.c thricken.6
#   thricken.h
# Wrapped by billr@saab on Fri Jun 19 09:09:47 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(632 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XThis is the game of thricken - written by James 'Rince' Bonfield.
XYou may redistribute and modify any of this source provided that my name is
Xstill mentioned in connection with the pieces of code I have written.
X
XI'd be interested in any screens you happen to write for the game - as can be
Xseen by my (and Radagast aka Stephen Landmore) exploits the screens can be
Xpretty flexible and unlike each other.
X
XEmail me at :
X	rince@dcs.warwick.ac.uk
X
X
XWhat this doesn't do :
X	No decent high score system
X	Currently it pretends to save what level you last got up to, but is
X		somewhat buggy still in this area.
X	Do project work for you.
X
END_OF_FILE
if test 632 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1013 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X Makefile                   1	
X README                     1	
X data                       1	
X data/00-03col              1	
X data/00-03spr              1	
X data/00level               1	
X data/01level               1	
X data/02level               1	
X data/03level               1	
X data/04col                 1	
X data/04level               1	
X data/04spr                 1	
X data/05col                 1	
X data/05level               1	
X data/05spr                 1	
X data/06col                 1	
X data/06level               1	
X data/06spr                 1	
X data/README                1	
X data/scores                1	
X data/screen                1	
X extern.h                   1	
X files.c                    1	
X main.c                     1	
X scores.c                   1	
X screen.c                   1	
X thricken.6                 1	
X thricken.h                 1	
END_OF_FILE
if test 1013 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(898 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# compiler flags
XCC = gcc
XCFLAGS = -O
XLDFLAGS = -s
XLIBS = -lcurses -ltermcap
X
X# directories
XBINDIR = /dcs/89/rince/open/bin.$(ARCH)
XLIBDIR = /dcs/89/rince/open/lib/thricken
XMANDIR = /dcs/89/rince/open/man
X
XOBJ = files.o main.o scores.o screen.o
X
XDEFS =	-DLIBDIR=\"$(LIBDIR)\"
X
Xthricken:	$(OBJ)
X	$(CC) $(LDFLAGS) $(OBJ) -o $@ $(LIBS)
X
X%.o:	%.c
X	$(CC) $(CFLAGS) $(DEFS) -c $<
X	
X
Xinstall:	thricken thricken.6
X	# the game
X	-mkdir -p $(BINDIR)
X	chmod a+xr $(BINDIR)
X	-cp thricken $(BINDIR)
X	chmod a+x $(BINDIR)/thricken
X
X	# the data files
X	-mkdir -p $(LIBDIR)
X	chmod a+xr $(LIBDIR)
X	-cp data/* $(LIBDIR)
X	chmod a+r $(LIBDIR)/*
X
X	# the man page
X	-mkdir -p $(MANDIR)/man6
X	chmod a+xr $(MANDIR)/man6
X	-cp thricken.6 $(MANDIR)/man6
X	chmod a+r $(MANDIR)/man6/thricken.6
X
Xclean:
X	-rm thricken *.o *~
X
Xfiles.o: thricken.h
Xmain.o: thricken.h extern.h
Xscores.o: extern.h thricken.h
Xscreen.o: extern.h thricken.h
END_OF_FILE
if test 898 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test ! -d 'data' ; then
    echo shar: Creating directory \"'data'\"
    mkdir 'data'
fi
if test -f 'data/00-03col' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/00-03col'\"
else
echo shar: Extracting \"'data/00-03col'\" \(372 characters\)
sed "s/^X//" >'data/00-03col' <<'END_OF_FILE'
X 0123
X.oO@
X..d@hjkl3
Xoo.dhjkl5
XOOo.hjkl7
X@@Oohjkl13
X0110hjkl0
X0220hjkl0
X0330hjkl0
X1001hjkl0
X1221hjkl0
X1331hjkl0
X2002hjkl0
X2112hjkl0
X2332hjkl0
X3003hjkl0
X3113hjkl0
X3223hjkl0
X00@Ohjkl0
X11@Ohjkl0
X22@Ohjkl0
X33@Ohjkl0
X.0.0hjkl0
Xo0o0hjkl0
XO0O0hjkl0
X@0@0hjkl0
X.1.1hjkl0
Xo1o1hjkl0
XO1O1hjkl0
X@1@1hjkl0
X.2.2hjkl0
Xo2o2hjkl0
XO2O2hjkl0
X@2@2hjkl0
X.3.3hjkl0
Xo3o3hjkl0
XO3O3hjkl0
X@3@3hjkl0
END_OF_FILE
if test 372 -ne `wc -c <'data/00-03col'`; then
    echo shar: \"'data/00-03col'\" unpacked with wrong size!
fi
# end of 'data/00-03col'
fi
if test -f 'data/00-03spr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/00-03spr'\"
else
echo shar: Extracting \"'data/00-03spr'\" \(462 characters\)
sed "s/^X//" >'data/00-03spr' <<'END_OF_FILE'
X 
X      
X      
X      
X>
X /O__o
X \___/
X /_\_ 
X<
Xo__O\ 
X\___/ 
X _/_\ 
X^
X ^__^ 
X/----\
X_/  \_
Xv
X O__O 
X/----\
X_/  \_
X-
X------
X======  
X------
X|
X| :: |
X| :: |
X| :: |
X/
X+-----
X| ++==
X| :: +
X\
X-----+
X==++ |
X+ :: |
X`
X| :: +
X| ++==
X+-----
X'
X+ :: |
X==++ |
X-----+
Xd
X      
X  {}  
X      
X.
X  ___ 
X /...\
X \.../
Xo
X  ___ 
X /ooo\
X \ooo/
XO
X  ___ 
X /OOO\
X \OOO/
X@
X  ___ 
X /@@@\
X \@@@/
X0
X++++++
X+....+
X++++++
X1
X......
X.OOOO.
X......
X2
XOOOOOO
XO####O
XOOOOOO
X3
X######
X#++++#
X######
END_OF_FILE
if test 462 -ne `wc -c <'data/00-03spr'`; then
    echo shar: \"'data/00-03spr'\" unpacked with wrong size!
fi
# end of 'data/00-03spr'
fi
if test -f 'data/00level' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/00level'\"
else
echo shar: Extracting \"'data/00level'\" \(148 characters\)
sed "s/^X//" >'data/00level' <<'END_OF_FILE'
X00-03spr
X00-03col
X8
X8
X0
X0
X14
X/------\
X|      |
X| 3012 |
X| 0123 |
X| 1230 |
X| 2301 |
X|      |
X`------'
Xbearings
XCyclic Madness
XJames 'Rince' Bonfield
END_OF_FILE
if test 148 -ne `wc -c <'data/00level'`; then
    echo shar: \"'data/00level'\" unpacked with wrong size!
fi
# end of 'data/00level'
fi
if test -f 'data/01level' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/01level'\"
else
echo shar: Extracting \"'data/01level'\" \(172 characters\)
sed "s/^X//" >'data/01level' <<'END_OF_FILE'
X00-03spr
X00-03col
X8
X11
X2
X2
X14
X/---------\
X|         |
X| 3003    |
X|  2332   |
X|   1221  |
X|    0110 |
X|         |
X`---------'
Xbearings
XMore insanity
XJames 'Rince' Bonfield
END_OF_FILE
if test 172 -ne `wc -c <'data/01level'`; then
    echo shar: \"'data/01level'\" unpacked with wrong size!
fi
# end of 'data/01level'
fi
if test -f 'data/02level' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/02level'\"
else
echo shar: Extracting \"'data/02level'\" \(339 characters\)
sed "s/^X//" >'data/02level' <<'END_OF_FILE'
X00-03spr
X00-03col
X9
X28
X2
X2
X70
X/--------------------------\
X|                          |
X| 123012 23 122320 03   22 |
X| 21     11 02     21   30 |
X| 301210 20 312310 3120203 |
X| 03     11     12 03   30 |
X| 13     03 020203 21   12 |
X|                          |
X`--------------------------'
Xbearings
XSwimming around
XJames 'Rince' Bonfield
END_OF_FILE
if test 339 -ne `wc -c <'data/02level'`; then
    echo shar: \"'data/02level'\" unpacked with wrong size!
fi
# end of 'data/02level'
fi
if test -f 'data/03level' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/03level'\"
else
echo shar: Extracting \"'data/03level'\" \(195 characters\)
sed "s/^X//" >'data/03level' <<'END_OF_FILE'
X00-03spr
X00-03col
X8
X14
X3
X2
X17
X/------\/----\
X|@ @   ||    |
X|   @ @`'@ @ |
X|@ @  @o   /-'
X|   @ @/\@ `-\
X|@ @   ||  @ |
X| @ @ @||    |
X`------'`.---'
Xbearings
XCarrots Bane
XJames 'Rince' Bonfield
END_OF_FILE
if test 195 -ne `wc -c <'data/03level'`; then
    echo shar: \"'data/03level'\" unpacked with wrong size!
fi
# end of 'data/03level'
fi
if test -f 'data/04col' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/04col'\"
else
echo shar: Extracting \"'data/04col'\" \(189 characters\)
sed "s/^X//" >'data/04col' <<'END_OF_FILE'
X .
XoOsPhjklE
Xssddhjkl15
Xooddhjkl10
XE.  hjkl0
XPS dhjkl5
XhH  h   15
XjJ  jk  15
XkK  kj  15
XlL  l   15
Xs..shjkl0
Xo.o.hjkl0
Xh.h.hjkl0
Xj.j.hjkl0
Xk.k.hjkl0
Xl.l.hjkl0
XP.P.hjkl0
XS.S.hjkl0
XO.O.hjkl0
END_OF_FILE
if test 189 -ne `wc -c <'data/04col'`; then
    echo shar: \"'data/04col'\" unpacked with wrong size!
fi
# end of 'data/04col'
fi
if test -f 'data/04level' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/04level'\"
else
echo shar: Extracting \"'data/04level'\" \(992 characters\)
sed "s/^X//" >'data/04level' <<'END_OF_FILE'
X04spr
X04col
X30
X30
X2
X2
X216
X##############################
X#      #    #dodod  o #. .o o#
X#    ok j   #ododoo . #o#o  .#
X#       o  ....dd.#.s.#    oo#
X#ododododo .....d.....#  o#oo#
X# # #.###  .. sss.....# o  # #
X# # #.#    ..s........#  #  o#
X###.# #    ..s .......#d######
X#s# o #   K...ssss ...#d#oooo#
X#d#o# ###.J.......o...#d#oEEo#
X#d OdOdO .o.......o..#dd#.d..#
X#o do  . .do      o #ddd#odd.#
X#########.o#oooooo.#.   #odd.#
X#                 #o.   ###d##
X#         ###d# ###o.       o#
X# ######SS  #d# #d# .   ddd  #
X# # ooo#PP  #o# #d#o.o. dEd  #
X# d oo #    #d#o#o###.  ddd  #
X# #ooo #     d..#do#.      # #
X# #########  o s od#o o oo o #
X#    odo#o#        #o######  #
X# S  dodod# ########o#dodo# d#
X# d  o#odo#    # d    oooo#dd#
X# S  dodod###d # d   #odoo# d#
X#    ododo  .P # d   ###### d#
X#    do#od  .d # #   o ## o d#
X#ooooododo  .P # d          d#
X#           .  . d          d#
X# o    #oo#o   # #ddddd     d#
X##############################
Xdiamonds
XOrange Flamingos
XBroadbane
END_OF_FILE
if test 992 -ne `wc -c <'data/04level'`; then
    echo shar: \"'data/04level'\" unpacked with wrong size!
fi
# end of 'data/04level'
fi
if test -f 'data/04spr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/04spr'\"
else
echo shar: Extracting \"'data/04spr'\" \(558 characters\)
sed "s/^X//" >'data/04spr' <<'END_OF_FILE'
X 
X      
X      
X      
X>
X /O__o
X \___/
X /_\_ 
X<
Xo__O\ 
X\___/ 
X _/_\ 
X^
X ^__^ 
X/----\
X_/  \_
Xv
X O__O 
X/----\
X_/  \_
X[
X\\\\\\
X\\\\\\
X\\\\\\
X]
X//////
X//////
X//////
X#
X/\/\/\
X\/\\/\
X\/\/\/
Xd
X  /\  
X <  > 
X  \/  
Xo
X  ___  
X /   \ 
X \___/ 
XO
X  ___  
X /@@@\ 
X \@@@/ 
Xh
X| | /\
X----||
X    \/
Xl
X/\ | |
X||----
X\/    
Xj
X /--\ 
X  \/  
X==|   
Xk
X==|   
X  /\  
X \--/ 
XH
X  <<  
X  <<  
X  <<  
XL
X  >>  
X  >>  
X  >>  
XJ
X      
Xvvvvvv
X      
XK
X      
X^^^^^^
X      
X.
X. . . 
X . . .
X. . . 
Xs
X  ___ 
X /ooo\
X \ooo/
XS
XSOCKET
XSOCKET
XSOCKET
XP
X PLUG!
X PLUG!
X PLUG!
XE
XEATEAT
XEATEAT
XEATEAT
END_OF_FILE
if test 558 -ne `wc -c <'data/04spr'`; then
    echo shar: \"'data/04spr'\" unpacked with wrong size!
fi
# end of 'data/04spr'
fi
if test -f 'data/05col' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/05col'\"
else
echo shar: Extracting \"'data/05col'\" \(64 characters\)
sed "s/^X//" >'data/05col' <<'END_OF_FILE'
X 
Xo@hjkl
Xooddhjkl10
XhH  h   15
XjJ  j   15
XkK  k   15
XlL  l   15
END_OF_FILE
if test 64 -ne `wc -c <'data/05col'`; then
    echo shar: \"'data/05col'\" unpacked with wrong size!
fi
# end of 'data/05col'
fi
if test -f 'data/05level' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/05level'\"
else
echo shar: Extracting \"'data/05level'\" \(468 characters\)
sed "s/^X//" >'data/05level' <<'END_OF_FILE'
X05spr
X05col
X14
X28
X5
X4
X39
X***************************
X*********1234567890.*******
X*D**do#       #  o o #  ***
X****oo# #K### #j # # #h ***
X**D*    #  H     hh# #od***
X****oo  H  ####k#d   # o***
X*D**######J#o #  o# ## o***
X****dd##oo #o ###ddo#   ***
X**D* @d### # o####do#  d***
X**** o H        #####o  ***
X*D** oo##  #@    @ @ @ o***
X****d  #oooo@ o#   @    ***
X**D************************
X***************************
Xdiamonds
XExpanded minitures
XJames 'Rince' Bonfield
END_OF_FILE
if test 468 -ne `wc -c <'data/05level'`; then
    echo shar: \"'data/05level'\" unpacked with wrong size!
fi
# end of 'data/05level'
fi
if test -f 'data/05spr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/05spr'\"
else
echo shar: Extracting \"'data/05spr'\" \(696 characters\)
sed "s/^X//" >'data/05spr' <<'END_OF_FILE'
X 
X      
X      
X      
X>
X /O__o
X \___/
X /_\_ 
X<
Xo__O\ 
X\___/ 
X _/_\ 
X^
X ^__^ 
X/----\
X_/  \_
Xv
X O__O 
X/----\
X_/  \_
X#
X######
X######
X######
Xd
X  /\  
X <  > 
X  \/  
Xo
X  ___  
X /   \ 
X \___/ 
X@
X  ___  
X /@@@\ 
X \@@@/ 
Xh
X| | /\
X----||
X    \/
Xl
X/\ | |
X||----
X\/    
Xj
X /--\ 
X  \/  
X==|   
Xk
X==|   
X  /\  
X \--/ 
XH
X  <<  
X  <<  
X  <<  
XL
X  >>  
X  >>  
X  >>  
XJ
X      
Xvvvvvv
X      
XK
X      
X^^^^^^
X      
X*
X@@@@@@
X@@@@@@
X@@@@@@
X1
X@ B E 
X@@@@@@
X@@@@@@
X2
XW A R 
X@@@@@@
X@@@@@@
X3
XE    O
X@@@@@@
X@@@@@@
X4
X F    
X@@@@@@
X@@@@@@
X5
XS E G 
X@@@@@@
X@@@@@@
X6
XM E N 
X@@@@@@
X@@@@@@
X7
XT A T 
X@@@@@@
X@@@@@@
X8
XI O N 
X@@@@@@
X@@@@@@
X9
X   F A
X@@@@@@
X@@@@@@
X0
X U L T
X@@@@@@
X@@@@@@
X.
X S @@@
X@@@@@@
X@@@@@@
XD
X@@/\@@
X@<<>>@
X@@\/@@
END_OF_FILE
if test 696 -ne `wc -c <'data/05spr'`; then
    echo shar: \"'data/05spr'\" unpacked with wrong size!
fi
# end of 'data/05spr'
fi
if test -f 'data/06col' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/06col'\"
else
echo shar: Extracting \"'data/06col'\" \(64 characters\)
sed "s/^X//" >'data/06col' <<'END_OF_FILE'
X 
Xo@hjkl
Xooddhjkl10
XhH  h   15
XjJ  j   15
XkK  k   15
XlL  l   15
END_OF_FILE
if test 64 -ne `wc -c <'data/06col'`; then
    echo shar: \"'data/06col'\" unpacked with wrong size!
fi
# end of 'data/06col'
fi
if test -f 'data/06level' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/06level'\"
else
echo shar: Extracting \"'data/06level'\" \(282 characters\)
sed "s/^X//" >'data/06level' <<'END_OF_FILE'
X06spr
X06col
X14
X14
X5
X5
X4
X##############
X#    # #     #
X# h  H H  h  #
X# hj # #     #
X#    # #     #
X#J####o####KJ#
X#  o  H      #
X#K#### #### ##
X#    L #ol   #
X#  #K# #   k #
X#k # # H     #
X#  #    #kh  #
X#o #    #    #
X##############
Xdiamonds
XAn easy starter
XJames 'Rince' Bonfield
END_OF_FILE
if test 282 -ne `wc -c <'data/06level'`; then
    echo shar: \"'data/06level'\" unpacked with wrong size!
fi
# end of 'data/06level'
fi
if test -f 'data/06spr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/06spr'\"
else
echo shar: Extracting \"'data/06spr'\" \(397 characters\)
sed "s/^X//" >'data/06spr' <<'END_OF_FILE'
X 
X      
X      
X      
X>
X /O__o
X \___/
X /_\_ 
X<
Xo__O\ 
X\___/ 
X _/_\ 
X^
X ^__^ 
X/----\
X_/  \_
Xv
X O__O 
X/----\
X_/  \_
X#
X######
X######
X######
Xd
X  /\  
X <  > 
X  \/  
Xo
X  ___  
X /   \ 
X \___/ 
X@
X  ___  
X /@@@\ 
X \@@@/ 
Xh
X| | /\
X----||
X    \/
Xl
X/\ | |
X||----
X\/    
Xj
X /--\ 
X  \/  
X==|   
Xk
X==|   
X  /\  
X \--/ 
XH
X  <<  
X  <<  
X  <<  
XL
X  >>  
X  >>  
X  >>  
XJ
X      
Xvvvvvv
X      
XK
X      
X^^^^^^
X      
END_OF_FILE
if test 397 -ne `wc -c <'data/06spr'`; then
    echo shar: \"'data/06spr'\" unpacked with wrong size!
fi
# end of 'data/06spr'
fi
if test -f 'data/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/README'\"
else
echo shar: Extracting \"'data/README'\" \(1887 characters\)
sed "s/^X//" >'data/README' <<'END_OF_FILE'
XDesigning screens:
XUse 'thricken -d directory' where directory is where you have your own set of
Xgame files. These consist of:
XA screen file which must be called 'screen' - copy it out of here.
XA 00level file (for level 0). (eg 01level, 02level etc)
XA sprite file. (eg 0-3spr)
XA collision file. (eg 0-3col)
XA 'scores' file. This must exist - create it with something like 'touch scores'
X
X
X
Xlevel file
X==========
X
Xline 1: sprite filename
Xline 2: sprite data filename
Xline 3: map height
Xline 4: map width
Xline 5: start x coord (top left of map is 0 0)
Xline 6: start y coord
Xline 7: no. of diamonds needed to finish the level
Xthen  : map data (`height` lines)
Xend-2 : name of diamonds
Xend-1 : name of screen
Xend   : author of level
X
XRules:
Xsprite 'd' is always a diamond, and is the only collectable sprite
Xsprite ' ' should always be a background (walkable) sprite.
Xsprites <,v,^,> are the sprites for you facing left,down,up and right.
X
X
X
Xspr file
X========
X
XConsists of a list of sprites.
X
XEach sprite is:
X1 line containing a single char - the sprite character for map
X3 lines of six characters - the sprite
X
X
XCollision file
X==============
X
Xline 1: list of sprites that can be walked over - such as ' '
Xline 2: list of sprites that can be pushed - such as 'oO'
Xthen  : list of sprite collisions with directions.
X	char 1-2 = which sprites for collision
X	char 3-4 = new sprites to replace old ones
X	char 5-8 = directions for collision (must be 4 chars)
X	char 9-  = decimal number for score change. 
X        eg's:
X	'ooddhjkl10' for boulders to diamonds
X	'hH  h   15' for key & lock (from one direction).
X
Xsprites x, X and * are reserved
Xthey are wildcards for collision.
Xx = any non walkable sprite
XX = any non pushable sprite
X* = any sprite
XHence 'GXGdh  l10' would be a sprite G which can turn any pushable sprite into
Xa diamond (scoring 10 points), but only on directions left and right.
END_OF_FILE
if test 1887 -ne `wc -c <'data/README'`; then
    echo shar: \"'data/README'\" unpacked with wrong size!
fi
# end of 'data/README'
fi
if test -f 'data/scores' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/scores'\"
else
echo shar: Extracting \"'data/scores'\" \(1 character\)
sed "s/^X//" >'data/scores' <<'END_OF_FILE'
X
END_OF_FILE
if test 1 -ne `wc -c <'data/scores'`; then
    echo shar: \"'data/scores'\" unpacked with wrong size!
fi
# end of 'data/scores'
fi
if test -f 'data/screen' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/screen'\"
else
echo shar: Extracting \"'data/screen'\" \(1936 characters\)
sed "s/^X//" >'data/screen' <<'END_OF_FILE'
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
X                                                 
XO-----------------------------O
X| ___ . . ._. . ._ .  ._ . .  |
X|  |  |_| |_| | |  |/ |_ |\|  |
X|  |  | | | \ | |_ |\ |_ | |  |
X|                             |
X| \-------------------------/ |
X|  By James 'Rince' Bonfield  |
X| /-------------------------\ |
XO-----------------------------O
XO-----------------------------O
X|    <Name of this screen>    |
X+--------------+--------------+
X| Level:000000 |    xxxxxx    |
X|              |    xxxxxx    |
X| Score:000000 |    xxxxxx    |
X|              |              |
X| Moves:000000 | Diamonds:    |
X|              |   000000     |
X+--------------+--------------+
X| This screen was designed by |
X|   <Name of designer>        |
X|                             |
XO-----------------------------O
END_OF_FILE
if test 1936 -ne `wc -c <'data/screen'`; then
    echo shar: \"'data/screen'\" unpacked with wrong size!
fi
# end of 'data/screen'
fi
if test -f 'extern.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extern.h'\"
else
echo shar: Extracting \"'extern.h'\" \(338 characters\)
sed "s/^X//" >'extern.h' <<'END_OF_FILE'
Xextern int load_level(int level);
Xextern void init_display();
Xextern int draw_map(int y,int x);
Xextern void update_wins();
Xextern void draw_stats(char level);
Xextern void draw_you(char y, char x, char c);
Xextern void write_score();
Xextern char *readline(FILE *fp);
Xextern void display_scores();
Xextern struct scored *find_level(int uid);
END_OF_FILE
if test 338 -ne `wc -c <'extern.h'`; then
    echo shar: \"'extern.h'\" unpacked with wrong size!
fi
# end of 'extern.h'
fi
if test -f 'files.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'files.c'\"
else
echo shar: Extracting \"'files.c'\" \(2365 characters\)
sed "s/^X//" >'files.c' <<'END_OF_FILE'
X#include <fcntl.h>
X#include <string.h>
X#include <stdio.h>
X#include "thricken.h"
X
Xchar *readline(FILE *fp);
Xint read_sprites();
Xchar *spr_file, *data_file;
X
Xint load_level(int level) {
X    int i,j;
X    FILE *fp;
X    char *level_file = strdup("xxlevel");
X    
X    level_file[0]='0'+((level<10)?0:(level/10));
X    level_file[1]='0'+level%10;
X    if ((fp = fopen(level_file,"r")) == NULL)
X	return -1;
X    spr_file = strdup(readline(fp));
X    data_file = strdup(readline(fp));
X    rows = atoi(readline(fp));
X    cols = atoi(readline(fp));
X    x = atoi(readline(fp));
X    y = atoi(readline(fp));
X    diamonds = atoi(readline(fp));
X    for (i=0; i<rows; i++)
X	map[i]=strdup(readline(fp));
X    if (dname)
X	free(dname);
X    dname = strdup(readline(fp));
X    if (lname)
X	free(lname);
X    lname = strdup(readline(fp));
X    if (author)
X	free(author);
X    author = strdup(readline(fp));
X    fclose(fp);
X    read_sprites();
X    read_sprdata();
X}
X
Xchar *readline(FILE *fp) {
X    /*
X     * buf is big enough for anything I'm going to use, but it's still
X     * a bit of a kludge.
X     */
X    static char buf[1024];
X    int i=0;
X    char c = '\0';
X    
X    if (fgets(buf,1000,fp) == (char *)0)
X	return (char *)-1;
X    buf[strlen(buf)-1] = '\0';
X    return buf;
X}
X
X
Xread_sprites() {
X    FILE *fp;
X    char spr;
X    char *ptr;
X    int j,i;
X    
X    if ((fp = fopen(spr_file,"r")) == NULL)
X	return -2;
X    while ((ptr = readline(fp)) != (char *)-1) {
X	spr = ptr[0];
X	for (j=0; j<SPRHEIGHT; j++) {
X	    ptr = readline(fp);
X	    for (i=0; i<SPRWIDTH; i++)
X		sprite[spr][j][i] = ptr[i];
X	}
X    }
X}
X
Xread_sprdata() {
X    FILE *fp;
X    int i;
X    char *ptr;
X    struct coll *c, *c2;
X
X    for (i=0; i<256; i++) {
X	if (c = sprdata[i]) {
X	    do {
X		c2 = c->next;
X		free(c->dirs);
X		free(c->coll);
X		free(c);
X		c = c2;
X	    } while (c);
X	}
X	sprdata[i]=0;
X    }
X    if ((fp = fopen(data_file,"r")) == NULL)
X	return -2;
X    walkable = strdup(readline(fp));
X    pushable = strdup(readline(fp));
X    while ((ptr = readline(fp)) != (char *)-1) {
X	if (sprdata[ptr[0]]) {
X	    c = (struct coll *)malloc(sizeof(struct coll));
X	    c->next = sprdata[ptr[0]];
X	    sprdata[ptr[0]] = c;
X	} else {
X	    c = sprdata[ptr[0]] = (struct coll *)malloc(sizeof(struct coll));
X	    c->next = 0;
X	}
X	sscanf(ptr+8,"%d",&(c->score));
X	*(ptr+8)=0;c->dirs = strdup(ptr+4);
X	*(ptr+4)=0;c->coll = strdup(ptr+1);
X    }
X}
END_OF_FILE
if test 2365 -ne `wc -c <'files.c'`; then
    echo shar: \"'files.c'\" unpacked with wrong size!
fi
# end of 'files.c'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(4556 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X#include <signal.h>
X#include <errno.h>
X#include <curses.h>
X#include <string.h>
X#include "thricken.h"
X#include "extern.h"
X
Xextern int draw_sprite(WINDOW *w, int y,int x,char spr);
Xextern WINDOW *gw,*sw,*lw;
X
Xvoid init();
Xchar query_map(char y, char x);
Xchar face[] = "<v^>";
Xchar keys[] = "hjkl";
X/* short cut for setting up n1 & n2 */
Xchar zdir[] = {-1,0,0,1,-1,0};
X
Xchar xs,ys;
X
Xmain(int argc, char **argv) {
X    char c,level=-1;
X
X    extern char *optarg;
X
X    chdir(LIBDIR);
X
X    /* initialise variables */
X    score = moves = 0;
X    level=-1;
X
X    while ((c = getopt(argc,argv,"d:l:-s")) != -1)
X	switch(c) {
X	case 'd':
X	    if (chdir(optarg)) {
X		perror(optarg);
X		exit(1);
X	    }
X	    break;
X	case 'l':
X	    level=atoi(optarg);
X	    break;
X	case 's':
X	    display_scores();
X	    exit(1);
X	case '?':
X	    fprintf(stderr,"Usage: %s [-d directory] [-l level number]\n",
X		    argv[0]);
X	    exit(1);
X	    break;
X	}
X    /* Remember the level we started the game on.
X     * This is used in the scoreboard routines to determine if we started
X     * on one of the levels we've done before.
X     */
X    if (level == -1) {
X	struct scored *s;
X	s = find_level(getuid());
X	level = s->level;
X	moves = s->moves;
X    }
X    startlevel = level;
X    play_game(level,moves);
X}
X
Xplay_game(char startl,int moves) {
X    char c,t1,t2,t3,t4;
X    char dir;
X
X    init_display();
X    level = startl;
X    do {
X	llevel = level;
X	lscore = score;
X	lmoves = moves;
X	if (load_level(level) == -1) {
X	    nocbreak();
X	    echo();
X	    endwin();
X	    puts("No such level");
X	    exit(1);
X	}
X	save_map();
X	dir = 1;
X	draw_stats(level);
X	do {
X	    t1 = (y/(SCRHEIGHT-2))*(SCRHEIGHT-2);
X	    t2 = (x/(SCRWIDTH-2))*(SCRWIDTH-2);
X	    t3 = SPRHEIGHT*(y%(SCRHEIGHT-2)+1);
X	    t4 = SPRWIDTH*(x%(SCRWIDTH-2)+1);
X	    draw_map(t1,t2);
X	    draw_you(t3,t4, face[dir]);
X	    update_wins();
X
X	    switch(c = getchar()) {
X	    case 'h':
X	    case 'j':
X	    case 'k':
X	    case 'l':
X		moves++;
X		dir = (char)(strchr(keys,c)-keys);
X		move_dir(dir, c);
X		break;
X	    case 's':
X		moves++;
X		save_map();
X		break;
X	    case 'r':
X		restore_map();
X		moves++;
X		break;
X	    case 'q':
X		kill(getpid(),SIGINT);
X		break;
X	    }
X	} while (diamonds);
X	update_wins();
X	level++;
X    } while (1);
X}
X
Xmove_dir(char dir,char key) {
X    char n1,n2,bang;
X    char nx,ny,mx,my;
X    struct coll *c;
X
X    n1 = query_map(y+zdir[dir+2],x+zdir[dir]);
X    n2 = query_map(y+zdir[dir+2]*2,x+zdir[dir]*2);
X    nx = (x+zdir[dir]+cols)%cols;
X    mx = (x+zdir[dir]*2+cols)%cols;
X    ny = (y+zdir[dir+2]+rows)%rows;
X    my = (y+zdir[dir+2]*2+rows)%rows;
X    
X    /* now do the checking of valid moves & their actions */
X    if (n1 == 'd') {
X	set_map(ny,nx,' ');
X	diamonds--;
X	score+=10;
X	x = nx, y = ny;
X    }
X    bang = 0;
X    if (sprdata[n1]) {
X	c = sprdata[n1];
X	do {
X	    /* if square is in our collision list
X	     * or if coll is '*' (any sprite)
X	     * or if coll is 'x' and ob is pushable
X	     * or if coll is 'X' and ob is not walkable
X	     * and we hit in the right direction
X	     * then....
X	     */
X	    if ((n2 == *(c->coll) ||
X	               *(c->coll) == '*' ||
X                       (*(c->coll) == 'x' && strchr(pushable,n2)) ||
X                       (*(c->coll) == 'X' && !strchr(walkable,n2))
X                   ) && strchr(c->dirs,key)) {
X		set_map(ny,nx,c->coll[1]);
X		set_map(my,mx,c->coll[2]);
X		score += c->score;
X		if (strchr(walkable,c->coll[1]))
X		    x = nx, y = ny;
X		bang = 1;
X	    }
X	} while (c = c->next);
X    }
X    if (strchr(pushable,n1) && bang == 0 && strchr(walkable,n2)) {
X	set_map(ny,nx,' ');
X	set_map(my,mx,n1);
X	x = nx, y = ny;
X    }
X    if (strchr(walkable,query_map(ny,nx)))
X	x = nx, y = ny;
X}
X
X/* could do this as a #define I suppose  - it'd be quicker anyway */
Xchar query_map(char y, char x) {
X    return map[(y+rows+1)%rows][(x+cols+1)%cols];
X}
X
Xset_map(char y, char x, char p) {
X    map[(y+rows+1)%rows][(x+cols+1)%cols]=p;
X}
X
Xsave_map() {
X    int i;
X
X    for (i=0; i<100; i++) {
X	if (oldpos.map[i]) {
X	    free(oldpos.map[i]);
X	    oldpos.map[i] = 0;
X	}
X	if (map[i])
X	    oldpos.map[i] = strdup(map[i]);
X    }
X    oldpos.score = score;
X    oldpos.level = level;
X    oldpos.diamonds = diamonds;
X    oldpos.moves = moves;
X    oldpos.x = x;
X    oldpos.y = y;
X}
X
Xrestore_map() {
X    int i;
X
X    for (i=0; i<100; i++) {
X	if (map[i]) {
X	    free(map[i]);
X	    map[i] = 0;
X	}
X	if (oldpos.map[i])
X	    map[i] = strdup(oldpos.map[i]);
X    }
X    score = oldpos.score;
X    level = oldpos.level;
X    diamonds = oldpos.diamonds;
X    moves = oldpos.moves;
X    x = oldpos.x;
X    y = oldpos.y;
X
X}
END_OF_FILE
if test 4556 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'scores.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'scores.c'\"
else
echo shar: Extracting \"'scores.c'\" \(3602 characters\)
sed "s/^X//" >'scores.c' <<'END_OF_FILE'
X#include <string.h>
X#include <stdlib.h>
X#include <stdio.h>
X#include <pwd.h>
X#include "extern.h"
X#include "thricken.h"
X
X#define SCWIDTH 57
X
X/*
X * not really a score file at the moment - but merely a list of how far
X * each player has got
X */
X
Xstruct score {
X    char user[8];
X    int score,moves,level;
X    char name[27];
X};
X
Xstruct score *read_entry(FILE *fp);
XFILE *open_scores(FILE *fp,char *mode);
Xvoid close_scores(FILE *fp);
X
Xvoid write_score() {
X    char *ptr1,*ptr2;
X    struct score *entry;
X    struct passwd *p;
X    int l;
X    FILE *fp;
X
X    if (llevel == 0) {
X	/* no need to bother saving anything as we didn't get anywhere */
X	return;
X    }
X
X    p=getpwuid(getuid());
X    l = find_level(getuid())->level;
X
X    /* if we cheated and started on a higher level then stop here */
X    if (l < startlevel) {
X	return;
X    }
X
X    if ((fp = open_scores(fp,"r+")) == NULL) {
X	return;
X    }
X    /* if we don't have an entry in the score file, then go to the end */
X    if (l == 0) {
X	/* offset of 0 from end-of-file (2) */
X	fseek(fp,0,2);
X    } else {
X	/* need to scan through score file looking for our entry */
X	do {
X	    entry = read_entry(fp);
X	} while (entry && strcmp(entry->user,p->pw_name));
X	/* now skip back by one entry so when we write another it'll overwrite
X	 * our existing entry. 
X	 */
X	fseek(fp,-SCWIDTH,1);
X    }
X
X    /* now we need to write data to fp */
X    if (fprintf(fp,"%-8s %06d %06d %06d %-26s\n",
X		ptr2=getpwuid(getuid())->pw_name,
X		lscore,lmoves,llevel,
X		(ptr1=getenv("NAME"))?ptr1:ptr2) == EOF) {
X	fprintf(stderr,"No data written\n");
X    }
X    close_scores(fp);
X}
X
X/* opens the score file with some locking etc builtin.
X * see also close_scores
X */
XFILE *open_scores(FILE *fp,char *mode) {
X    if ((fp = fopen(SCOREFILE,mode)) == NULL) {
X	puts("No high scores yet.");
X	return (FILE *)0;
X    }
X    return fp;
X}
X
Xvoid close_scores(FILE *fp) {
X    fclose(fp);
X}
X
Xvoid display_scores() {
X    FILE *fp;
X    struct score *entry;
X    int rank=0;
X
X    if ((fp = open_scores(fp,"r")) == NULL) {
X	return;
X    }
X    puts("+------+----------------------------+----------+--------+--------+--------+");
X    puts("| Rank | Name                       | Usercode | Level  | Score  | Moves  |");
X    puts("+------+----------------------------+----------+--------+--------+--------+");
X    while (entry = read_entry(fp))
X	/* Rank | Name | Code | Level | Score | Moves */
X	printf("| %4d | %-26s | %-8s | %06d | %06d | %06d |\n",
X	       ++rank,entry->name, entry->user, entry->level,
X	       entry->score,entry->moves);
X    puts("+------+----------------------------+----------+--------+--------+--------+");
X    close_scores(fp);
X}
X
Xstruct scored *find_level(int uid) {
X    FILE *fp;
X    struct score *entry;
X    struct passwd *p;
X    static struct scored ret;
X
X    if ((fp = open_scores(fp,"r")) == NULL) {
X	return;
X    }
X    p=getpwuid(uid);
X    do {
X	entry = read_entry(fp);
X    } while (entry && strcmp(entry->user,p->pw_name));
X    if (entry) {
X	ret.level = entry->level;
X	ret.moves = entry->moves;
X    } else {
X	ret.level = 0;
X	ret.moves = 0;
X    }
X    close_scores(fp);
X    return &ret;
X}
X
Xstruct score *read_entry(FILE *fp) {
X    char *ptr,*tmp;
X    static struct score entry;
X
X    if ((ptr = readline(fp)) == (char *)-1)
X	return (struct score *)0;
X    *(ptr+8)='\0';
X    if (tmp = strchr(ptr,' '))
X	*tmp='\0';
X    strcpy(entry.user,ptr);
X    ptr+=9;
X    *(ptr+6)='\0';
X    entry.score = atoi(ptr);
X    ptr+=7;
X    *(ptr+6)='\0';
X    entry.moves = atoi(ptr);
X    ptr+=7;
X    *(ptr+6)='\0';
X    entry.level = atoi(ptr);
X    ptr+=7;
X    strcpy(entry.name,ptr);
X    return &entry;
X}
END_OF_FILE
if test 3602 -ne `wc -c <'scores.c'`; then
    echo shar: \"'scores.c'\" unpacked with wrong size!
fi
# end of 'scores.c'
fi
if test -f 'screen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screen.c'\"
else
echo shar: Extracting \"'screen.c'\" \(2569 characters\)
sed "s/^X//" >'screen.c' <<'END_OF_FILE'
X#include <signal.h>
X#include <fcntl.h>
X#include <curses.h>
X#include "extern.h"
X#include "thricken.h"
X
XWINDOW *gw,*sw,*lw;
Xchar *init_file = "screen";
X
Xvoid myerror(char *error);
Xvoid stop();
Xvoid refresh3();
X
Xvoid cleanup() {
X    nocbreak();
X    echo();
X    endwin();
X    write_score();
X    exit(0);
X}
X
Xvoid init_display() {
X    int i,j;
X    char *ptr,s;
X    FILE *fp;
X    initscr();
X    signal(SIGTSTP,stop);
X    signal(SIGINT,cleanup);
X    clear();
X    noecho();
X    cbreak();
X    gw = newwin(HEIGHT, WIDTH, 0,0);
X    lw = newwin(9, 79-WIDTH, 0, WIDTH+1); 
X    sw = newwin(14, 79-WIDTH, 10, WIDTH+1); 
X    
X    if ((fp = fopen(init_file,"r")) == NULL) {
X	myerror(init_file);
X    }
X    for (i=0; i<24; i++) {
X	mvwaddstr(gw,i,0,readline(fp));
X    }
X    for (i=0; i<9; i++) {
X	mvwaddstr(lw,i,0,readline(fp));
X    }
X    for (i=0; i<14; i++) {
X	mvwaddstr(sw,i,0,readline(fp));
X    }
X    fclose(fp);
X}
X
Xvoid myerror(char *e) {
X    nocbreak();
X    echo();
X    endwin();
X    perror(e);
X    sleep(2);
X    exit(1);
X}
X
Xdraw_sprite(WINDOW *w, int y, int x, char spr) {
X    int i,j;
X
X    for (j=0; j<SPRHEIGHT; j++)
X	for (i=0; i<SPRWIDTH; i++)
X	    mvwaddch(w,y+j,x+i,sprite[spr][j][i]);
X}
X
Xdraw_map(int y, int x) {
X    int i,j;
X
X    for (i=0; i<SCRWIDTH; i++)
X	for (j=0; j<SCRHEIGHT; j++) {
X	    draw_sprite(gw, j*SPRHEIGHT, i*SPRWIDTH,
X			map[(y+j+rows)%rows][(x+i+cols)%cols]);
X	}
X}
X
Xvoid draw_you(char y, char x, char c) {
X    draw_sprite(gw, y, x, c);
X}
X
Xvoid draw_stats(char level) {
X    char buf[75-WIDTH];
X    char tmp;
X    
X    mvwprintw(sw,3,8,"%06d",level);
X    draw_sprite(sw,3,20,'d');
X    strncpy(buf,lname,74-WIDTH);
X    if ((tmp=strlen(lname)) < 74-WIDTH)
X	strncpy(buf+tmp,"                        \0",74-WIDTH-tmp);
X    buf[26]='\0';
X    mvwprintw(sw,1,3,"%s",buf);
X    strncpy(buf,author,74-WIDTH);
X    if ((tmp=strlen(author)) < 74-WIDTH)
X	strncpy(buf+tmp,"                        \0",74-WIDTH-tmp);
X    buf[25]='\0';
X    mvwprintw(sw,11,4,"%s",buf);
X    strncpy(buf,dname,74-WIDTH);
X    if ((tmp=strlen(dname)) < 74-WIDTH)
X	strncpy(buf+tmp,":                       \0",74-WIDTH-tmp);
X    buf[11]='\0';
X    mvwprintw(sw,7,17,"%s",buf);
X}
X
Xvoid update_wins() {
X    mvwprintw(sw,5,8,"%06d",score);
X    mvwprintw(sw,7,8,"%06d",moves);
X    mvwprintw(sw,8,19,"%06d",diamonds);
X    refresh3();
X}
X
Xvoid refresh3() {
X    wrefresh(gw);
X    wrefresh(sw);
X    wrefresh(lw);
X}
X
Xvoid refresh_all() {
X    clearok(curscr,TRUE);
X    wrefresh(curscr);
X}
X    
Xvoid stop() {
X    nocbreak();
X    echo();
X    kill(getpid(),SIGSTOP);
X    noecho();
X    cbreak();
X    refresh_all();
X}
END_OF_FILE
if test 2569 -ne `wc -c <'screen.c'`; then
    echo shar: \"'screen.c'\" unpacked with wrong size!
fi
# end of 'screen.c'
fi
if test -f 'thricken.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'thricken.6'\"
else
echo shar: Extracting \"'thricken.6'\" \(7469 characters\)
sed "s/^X//" >'thricken.6' <<'END_OF_FILE'
X.TH THRICKEN 6 "9th April 1992"
X.SH NAME
Xthricken \- a multiscreen collect-the-objects style game
X.SH SYNOPSIS
X.I thricken
X[-l level_num ] [ -d directory ]
X.SH DESCRIPTION
X.I thricken
Xis designed to be a flexible game whereby the actual game strategies may vary
Xsubstantially from level to level. Each level can have it's own set of
Xsprites, it's own map, and it's own list of interactions between the sprites.
XAlthough the basic aim of each level is always the same - to collect all the
X'collectable' items (such as diamonds or bearings). The current item to
Xcollect is displayed in the panel on the right hand side of the screen. Also
Xin this window is the current number of items needed to collect before the
Xlevel is finished, the current score, the current number of moves, and the
Xcurrent level number.
X.sp
XYou may start on any level you wish by using the
X.I -l level_num
Xoption. If you attempt to start on a non existant level you will be told it
Xdoes not exist. This also happens when you finish the last level as there is
Xcurrently no 'end game' sequence. If you do not give the level number as an
Xoption then the game should automatically place you on the highest level you
Xhave reached so far. Note that you cannot (well, shouldn't) be able to fool
Xthe game into thinking you've completed the first 5 levels by starting on
Xlevel 5. Level 0 is the first level.
X.sp
XShould you wish to give the game a different feel when using a different set
Xof sprites and rules you may specify a directory as an argument using the
X.I -d directory
Xoption. This allows for the same program to utilise a different score (more
Xreally like a 'position') file, a different logo, and to some extent a
Xdifferent panel style. This is also a very useful feature should you wish to
Xdesign and play your own set of screens.
X.sp
XTo design your own screens for the game is relatively simple. In you \fBlib\fP
Xdirectory you *must* have files called \fIscreen\fP and \fIscore\fP. Any
Xlevels you write should be saved as the level number (two digits) followed by
X'level'. For instance, \fB00level\fP and \fB99level\fP. Each level file in
Xturn will reference a sprite file and a collisions file. These filenames are
Xspecified by the user.
X.sp
XThe format of a level file is as follows:
X.ta 1i
X.nf
Xline 1	: sprite filename
Xline 2	: collisions filename
Xline 3	: map height
Xline 4	: map width
Xline 5	: start x coord (top left of map is 0 0)
Xline 6	: start y coord
Xline 7	: no. of diamonds (collectables) needed to finish the level
Xthen	: map data (`height` lines)
Xend-2	: name of diamonds (collectables)
Xend-1	: name of screen
Xend	: author of level
X.fi
X.sp
XThe map data itself is just a matrix of ASCII characters. A few characters are
Xreserved and there meaning should not be changed.
X.br
X\fId\fP is always a diamond, and is the only collectable sprite
X.br
X\fI<space>\fP is always a background (walkable) sprite.
X.br
X\fI<\fP, \fIv\fP, \fI^\fP, \fI>\fP are the sprites for you facing left, down,
Xup and right respectively.
X.sp
XThe sprite data format is simpler to understand. It consists of a list of
Xsprite characters and data. Each character used on the map (such as 'you')
Xneeds to be defined in this file. Each sprite entry consists of one line for
Xthe sprite character to be used on the map, and three lines (of six characters
Xlong each) for what the sprite will look like on the screen. Care must be
Xtaken to ensure that the sprites are six characters wide. For instance, five
Xwide sprites need to be padded with a space. A snippet from an example sprite
Xfile (defining only you) is shown here:
X.sp
X.nf
X>
X /O__o
X \e\___/
X /_\e\_ 
X<
Xo__O\e\ 
X\e\___/ 
X _/_\e\ 
X^
X ^__^ 
X/----\e\ 
X_/  \e\_
Xv
X O__O 
X/----\e\ 
X_/  \e\_
X.fi
X.sp
XThe collisions file defines what happens to a sprite when you push it into
Xanother. Upon moving the game remembers the sprite directly in front of you,
Xand the sprite behind that one (which can be considered as the sprite that you
Xare trying to push the sprite directly next to you on to). To define a
Xcollision between two sprites we specify the two sprites colliding, the two
Xresultant sprites, the direction we were moving in, and the change in score.
X.sp
XThe first line of the file contains a list of sprites which can be walked
Xover, or which other sprites may be pushed over (unless a collision is defined
Xcontrary to this). This could simply be a single space on a line. The second
Xline is a list of pushable sprites - such as boulders and keys. The third
Xonwards lines define a single collision per line in the following format.
X.sp
X.nf
Xchar 1	: sprite nearest to player before collision
Xchar 2	: sprite furthest from player before collision
Xchar 3	: sprite nearest to player after collision
Xchar 4	: sprite furthest from player after collision
Xchar 5-8	: directions for which collision is valid
Xchars 9-	: decimal number for change in score
X.fi
X.sp
XA short note about the directions field (char 5-8) : There must be four
Xcharacters here. Each of the four characters corresponds to each of the four
Xdirections the player can walk in. Treat the four characters as a string. If
Xthe direction is in the string then the collision is valid. Otherwise the
Xstring must be padded with spaces upto the four character limit. For example:
X.sp
X\fIooddhjkl10\fP will turn two 'o's into two 'd's (the collectables) upon any
Xof the four directions, scoring 10 points.
X.br
X\fIhH  h   15\fP - when pusing an 'h' (eg a left key) into an 'H' (eg a left
Xdoor) from direction 'h' (left) replace both sprites with a blank (space) and
Xscore 15 points.
X.sp
XUpon a collision, if the resulting sprite directly in front of the player is a
Xwalkable sprite (or the collectable) the player is also moved forward one
Xsquare in addition to the collision being performed.
X.sp
XA few sprite names have special meaning in collisions (and so should not be
Xused on the map). They are wildcards for any sprite obeying the following
Xrules.
X.br
Xx = any non walkable sprite.
X.br
XX = any non pushable sprite.
X.br
X* = any sprite.
X.sp
XHence '\fIGXdh  l-5\fP' would be a sprite G which can turn any pushable sprite
Xinto a diamond (scoring -5 points), but only on directions left and right.
X.SH FILES
X.ta 2i
X.br
X.I LIBDIR/xxlevel	- The level files (00level to 99level)
X.br
X.I LIBDIR/scores	- The 'score' table
X.br
X.I LIBDIR/screen	- The initial screen and panel layout
X.br
Xwhere LIBDIR is usually /usr/games/lib/thricken.
X.SH AUTHOR
X.I thricken
Xwas written by James 'Rince' Bonfield. He can be contacted via email at
X'rince@dcs.warwick.ac.uk' (currently - not sure how long this shall last).
X.SH BUGS
XNo checks for relative pathnames are done within the level files. This means
Xthat there may be potential security problems if the game is installed setuid
Xor setgid. I would not recommend it.
X.sp
XThe score table is not really a score table. It can be examined using the
X\fI-s\fP option, but this is not a wise thing to take note of. It is a classic
Xexample of something started and never finished. The current state of the
Xscore table is simply to keep a record of whom has played up to which level
X(and not 100% bug free in that bit either). The rank of a player is not
Xcomputed. 
X.sp
XThe game concepts and ideas have already been junked in preference for a
Xbetter method. This was one reason for so little time being devoted to this
Xgame. I would like to see any new screens anyone produces, but I am not likely
Xto fix any bugs as I view it as a terminated project. Feel free to fix them
Xyourselves :-)
END_OF_FILE
if test 7469 -ne `wc -c <'thricken.6'`; then
    echo shar: \"'thricken.6'\" unpacked with wrong size!
fi
# end of 'thricken.6'
fi
if test -f 'thricken.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'thricken.h'\"
else
echo shar: Extracting \"'thricken.h'\" \(1672 characters\)
sed "s/^X//" >'thricken.h' <<'END_OF_FILE'
X#define SCRWIDTH  8
X#define SCRHEIGHT 8
X#define SPRWIDTH  6
X#define SPRHEIGHT 3
X#define WIDTH (SPRWIDTH * SCRWIDTH)
X#define HEIGHT (SPRHEIGHT * SCRHEIGHT)
X#define SCOREFILE "scores"
X
Xchar *map[100];          /* The map array - Max 100 deep */
Xchar rows,cols;          /* of size rows x cols */
Xchar x,y;                /* Your start coordinates */
Xshort diamonds;          /* Number of diamonds left to collect */
Xchar sprite[256][SPRHEIGHT][SPRWIDTH];
Xint score, moves, level;
X                         /* copies of vars that are copied at the start of
X			  * each level - used for saving the game as we can
X			  * only save at the start of a new level
X			  */
Xint startlevel;          /* level we started the game on */
Xint lscore, lmoves, llevel;
X                         /* sprites that can be walked over or pushed */
Xchar *pushable, *walkable;
X
Xstruct coll {
X    char *coll;          /* change of map data for collision */
X    char *dirs;          /* list of directions for valid collision */
X    int score;           /* change in score */
X    struct coll *next;   /* next collision info */
X};
Xstruct coll *sprdata[256];      /* table of collision for sprites */
X
Xchar *dname;          /* name of item to collect (diamond) */
Xchar *lname;          /* level name */
Xchar *author;         /* author of level */
X
Xstruct saved {
X    char *map[100];          /* The map array - Max 100 deep */
X    char x,y;                /* Your start coordinates */
X    short diamonds;          /* Number of diamonds left to collect */
X    int score, moves, level;
X};
X
Xstruct saved oldpos;
X
X/* structure to read from high score file */
Xstruct scored {
X    int level;
X    int moves;
X};
X
END_OF_FILE
if test 1672 -ne `wc -c <'thricken.h'`; then
    echo shar: \"'thricken.h'\" unpacked with wrong size!
fi
# end of 'thricken.h'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
