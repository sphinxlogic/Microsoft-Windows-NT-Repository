Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i004:  xjewel - dropping jewels game for X11, Part04/05
Message-ID: <4511@master.CNA.TEK.COM>
Date: 8 Feb 93 21:38:04 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1832
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1683

Submitted-by: dcooper@datap.ca (Dave Cooper)
Posting-number: Volume 17, Issue 4
Archive-name: xjewel/Part04
Environment: X11, Xlib, Unix, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 5)."
# Contents:  Imakefile Makefile.simple bitmaps/border.xbm
#   bitmaps/border1.xbm bitmaps/button.xbm bitmaps/flash1.xbm
#   bitmaps/flash2.xbm bitmaps/flash3.xbm bitmaps/flash4.xbm
#   bitmaps/jewel.xbm bitmaps/piece1.xbm bitmaps/piece2.xbm
#   bitmaps/piece3.xbm bitmaps/piece4.xbm bitmaps/piece5.xbm
#   bitmaps/piece6.xbm bitmaps/skulemask.xbm help.c hscore.c jewel.h
#   panel.c xjewel.help xjewel.man xw.h
# Wrapped by billr@saab on Mon Feb  8 11:36:53 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(1675 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X# A little makeyfile edit up to the solid line...
X
X# EDIT THE CDEBUGFLAGS IF -O GIVES A PROBLEM
XCDEBUGFLAGS = -O  
X
X# CHANGE HSCORE_FILE TO SUIT
X#HSCORE_FILE=/usr/local/lib/xjewel.scores
XHSCORE_FILE=xjewel.scores
X
X# ADD YOUR ARCHITECTURE IF YOU USE SELECT INSTEAD OF POLL
X#if defined(HPArchitecture) || defined(ApolloArchitecture) || \
X 	defined(UltrixArchitecture)
X#define sel -DUSE_SELECT
X#else
X#define sel 
X#endif
X
X# DEFINE 'DECWM' if you use DECwindows session manager
X# DEFINE 'ICON_WINDOW if you want dynamic icons
X# DEFINE 'LEAVE_PAUSE' if you auto pause if the pointer leaves the window
X# DEFINE 'GETPWENT' if you dont have the cuserid ftn (hscore.c)
X# DEFINE 'SLOW_FONTS=n' if your server is overly fast on fonts
X# DEFINE 'SLOW_DRAW=n' if your server is overly fast on drawing
XUSERDEFS = -DICON_WINDOW
X
X# CHANGE FFILE TO REFLECT THE EXTENSION USED FOR COMPILED FONTS
XFFILE = snf
X
X##############################################################################
X# X-STUFF...
XLOCAL_LIBRARIES = $(XLIB)
XDEPLIBS =
X
XDEFINES = -DHSCORE_FILE=\"$(HSCORE_FILE)\" sel $(USERDEFS)
X# MY CODE...
XHDRS    = general.h xw.h jewel.h logic.h panel.h xhscore.h hscore.h \
X		game.h intro.h help.h
XOBJS    = xw.o jewel.o logic.o panel.o xhscore.o hscore.o game.o intro.o help.o
XSRCS    = xw.c jewel.c logic.c panel.c xhscore.c hscore.c game.c intro.c help.c
XFONT   = bitmaps/seven_seg
XCFONT   = bitmaps/seven_seg.$(FFILE)
X
X
X# LETS GET TO IT...
XComplexProgramTarget(xjewel)
X
X# IF YOUR SERVER DOES NOT LIKE THE DEFAULT FONT COMPILER, EDIT HERE...
XFontTarget($(FONT))
X	$(MKFONTDIR) bitmaps/
X
X# FORCE FONT TO BE BUILT
Xall:: $(CFONT)
X
Xinstall::
X	touch  $(HSCORE_FILE)
X	chmod a+w $(HSCORE_FILE)
END_OF_FILE
if test 1675 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'Makefile.simple' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.simple'\"
else
echo shar: Extracting \"'Makefile.simple'\" \(1890 characters\)
sed "s/^X//" >'Makefile.simple' <<'END_OF_FILE'
X# A Simple makefile which will satisfy most users
X
X# Edit the following to the solid line:
XINSTDIR = /usr/local
X#HSCORE_FILE = $(INSTDIR)/lib/xjewel.scores
XHSCORE_FILE = xjewel.scores
X
X# DEFINE 'DECWM' if you use DECwindows session manager
X# DEFINE 'ICON_WINDOW' if you want dynamic icons
X# DEFINE 'LEAVE_PAUSE' if you auto pause if the pointer leaves the window
X# DEFINE 'GETPWENT' if you dont have the cuserid ftn (hscore.c)
X# DEFINE 'SLOW_FONTS=n' if your server is overly fast on fonts
X# DEFINE 'SLOW_DRAW=n' if your server is overly fast on drawing
XUSERDEFS = -DICON_WINDOW
X
X# Declare what is necessary to build an X client
X#	POLL - define to USE_SELECT for bsdish systems
X#	LDFLAGS - the X11 libraries as reqd
X
X# the basic: (OSF, generic BSD)
XPOLL = -DUSE_SELECT
XLDFLAGS = -lX11
X
X# IF SUN ->
X#INCLUDES = -I/usr/openwin/include
X#LDFLAGS = -L/usr/openwin/lib -lX11
X
X# IF HPUX ->
X#POLL = -DUSE_SELECT
XINCLUDES = -I/usr/include/X11R4
XLDFLAGS = -L/usr/lib/X11R4 -lX11
X
X# IF ISC3.0 ->
X#POLL =
X#INCLUDES = 
X#LDFLAGS = -lX11 -lXmalloc -lnsl_s -lc_s
X
X##############################################################################
X
XCFLAGS  = -O -DHSCORE_FILE=\"$(HSCORE_FILE)\" $(USERDEFS) $(INCLUDES) $(POLL)
X
XSHELL = /bin/sh
X
XHDRS    = general.h xw.h jewel.h logic.h panel.h xhscore.h hscore.h \
X		game.h intro.h help.h
X
XOBJS    = xw.o jewel.o logic.o panel.o xhscore.o hscore.o game.o intro.o help.o
XSRCS    = xw.c jewel.c logic.c panel.c xhscore.c hscore.c game.c intro.c help.c
X
Xxjewel: $(OBJS)
X	rm -f $@
X	$(CC) -o $@ $(OBJS) $(LDFLAGS) $(MALLOC_LIB) 
X
X# IF YOUR SYSTEM USES .pcf OR .scr FILES, CHANGE THE FOLLOWING
XFFILE = snf
X
Xbitmaps/seven_seg.$(FFILE): bitmaps/seven_seg.bdf
X	bdfto$(FFILE) bitmaps/seven_seg.bdf >bitmaps/seven_seg.$(FFILE)
X	(cd bitmaps ; mkfontdir)
X
Xinstall: xjewel bitmaps/seven_seg.$(FFILE)
X	touch $(HSCORE_FILE)
X	chmod a+w $(HSCORE_FILE)
X	cp xjewel $(INSTDIR)/bin
X
END_OF_FILE
if test 1890 -ne `wc -c <'Makefile.simple'`; then
    echo shar: \"'Makefile.simple'\" unpacked with wrong size!
fi
# end of 'Makefile.simple'
fi
if test -f 'bitmaps/border.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/border.xbm'\"
else
echo shar: Extracting \"'bitmaps/border.xbm'\" \(1299 characters\)
sed "s/^X//" >'bitmaps/border.xbm' <<'END_OF_FILE'
X#define border_width 40
X#define border_height 40
X
Xstatic char border_bits[] = {
X 0xfe, 0xff, 0xff, 0xff, 0x3f, 0xfd, 0xff, 0xff, 0xff, 0x9f, 0xfb, 0xff,
X 0xff, 0xff, 0x5f, 0x07, 0x00, 0x00, 0x00, 0xa0, 0xef, 0xff, 0xff, 0xff,
X 0x57, 0x2f, 0x00, 0x20, 0x00, 0xa6, 0xaf, 0x03, 0x40, 0x3e, 0x55, 0xaf,
X 0x03, 0x80, 0xbe, 0xa4, 0xaf, 0x03, 0x00, 0x41, 0x54, 0x2f, 0x00, 0x00,
X 0x22, 0xa4, 0x2f, 0x00, 0x00, 0x14, 0x54, 0xef, 0xff, 0xff, 0x0f, 0xa4,
X 0x2f, 0x00, 0x00, 0x08, 0x54, 0xaf, 0xff, 0xff, 0x0b, 0xa4, 0x2f, 0x00,
X 0x00, 0x08, 0x54, 0xaf, 0xef, 0xef, 0x0b, 0xa4, 0x2f, 0x10, 0x10, 0x08,
X 0x54, 0xaf, 0xef, 0xef, 0x0b, 0xa4, 0x2f, 0x10, 0x10, 0x08, 0x54, 0xaf,
X 0xef, 0xef, 0x0b, 0xa4, 0x2f, 0x10, 0x10, 0x08, 0x54, 0xaf, 0xef, 0xef,
X 0x0b, 0xa4, 0x2f, 0x10, 0x10, 0x08, 0x54, 0xaf, 0xef, 0xef, 0x0b, 0xa4,
X 0x2f, 0x10, 0x10, 0x08, 0x54, 0xaf, 0xef, 0xef, 0x0b, 0xa4, 0x2f, 0x00,
X 0x00, 0x08, 0x54, 0xaf, 0xff, 0xff, 0x0b, 0xa4, 0x2f, 0x00, 0x00, 0x08,
X 0x54, 0xaf, 0xff, 0xff, 0x0b, 0xa4, 0x2f, 0x00, 0x00, 0x08, 0x54, 0xaf,
X 0xff, 0xff, 0x0b, 0xa4, 0x2f, 0x00, 0x00, 0x08, 0x54, 0x2f, 0x00, 0x00,
X 0x08, 0xa4, 0xef, 0xff, 0xff, 0xff, 0x57, 0x0f, 0x00, 0x00, 0x00, 0xa0,
X 0x57, 0x55, 0x55, 0x55, 0x55, 0xab, 0xaa, 0xaa, 0xaa, 0x8a, 0x55, 0x55,
X 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0xaa, 0x2a };
END_OF_FILE
if test 1299 -ne `wc -c <'bitmaps/border.xbm'`; then
    echo shar: \"'bitmaps/border.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/border.xbm'
fi
if test -f 'bitmaps/border1.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/border1.xbm'\"
else
echo shar: Extracting \"'bitmaps/border1.xbm'\" \(1302 characters\)
sed "s/^X//" >'bitmaps/border1.xbm' <<'END_OF_FILE'
X#define border1_width 40
X#define border1_height 40
X
Xstatic char border1_bits[] = {
X 0x00, 0xfe, 0xff, 0xff, 0x7f, 0x00, 0x01, 0x00, 0x00, 0x60, 0x80, 0x00,
X 0x00, 0x00, 0x50, 0x40, 0x00, 0x00, 0x00, 0x48, 0x20, 0x00, 0x00, 0x00,
X 0x44, 0x10, 0x00, 0x00, 0x00, 0x42, 0x08, 0x00, 0x00, 0x00, 0x41, 0x04,
X 0x00, 0x00, 0x80, 0x40, 0xfe, 0xff, 0xff, 0x7f, 0x40, 0x02, 0x00, 0x02,
X 0x60, 0x40, 0x3a, 0x00, 0xe4, 0x53, 0x40, 0x3a, 0x00, 0xe8, 0x4b, 0x40,
X 0x3a, 0x00, 0x10, 0x44, 0x40, 0x02, 0x00, 0x20, 0x42, 0x40, 0x02, 0x00,
X 0x40, 0x41, 0x40, 0xfe, 0xff, 0xff, 0x40, 0x40, 0x02, 0x00, 0x80, 0x40,
X 0x40, 0xfa, 0xff, 0xbf, 0x40, 0x40, 0x02, 0x00, 0x80, 0x40, 0x40, 0xfa,
X 0xfe, 0xbe, 0x40, 0x40, 0x02, 0x01, 0x81, 0x40, 0x40, 0xfa, 0xfe, 0xbe,
X 0x40, 0x40, 0x02, 0x01, 0x81, 0x40, 0x40, 0xfa, 0xfe, 0xbe, 0x40, 0x40,
X 0x02, 0x01, 0x81, 0x40, 0x40, 0xfa, 0xfe, 0xbe, 0x40, 0x40, 0x02, 0x01,
X 0x81, 0x40, 0x40, 0xfa, 0xfe, 0xbe, 0x40, 0x40, 0x02, 0x01, 0x81, 0x40,
X 0x40, 0xfa, 0xfe, 0xbe, 0x40, 0x40, 0x02, 0x00, 0x80, 0x40, 0x40, 0xfa,
X 0xff, 0xbf, 0x40, 0x20, 0x02, 0x00, 0x80, 0x40, 0x10, 0xfa, 0xff, 0xbf,
X 0x40, 0x08, 0x02, 0x00, 0x80, 0x40, 0x04, 0xfa, 0xff, 0xbf, 0x40, 0x02,
X 0x02, 0x00, 0x80, 0x40, 0x01, 0x02, 0x00, 0x80, 0xc0, 0x00, 0xfe, 0xff,
X 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
END_OF_FILE
if test 1302 -ne `wc -c <'bitmaps/border1.xbm'`; then
    echo shar: \"'bitmaps/border1.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/border1.xbm'
fi
if test -f 'bitmaps/button.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/button.xbm'\"
else
echo shar: Extracting \"'bitmaps/button.xbm'\" \(1299 characters\)
sed "s/^X//" >'bitmaps/button.xbm' <<'END_OF_FILE'
X#define button_width 40
X#define button_height 40
X
Xstatic char button_bits[] = {
X 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa,
X 0xaa, 0xaa, 0x6a, 0x54, 0x55, 0x55, 0x55, 0x75, 0xaa, 0xaa, 0xaa, 0xaa,
X 0x7a, 0x54, 0x55, 0x55, 0x55, 0x7d, 0x2a, 0x00, 0x00, 0x00, 0x7c, 0x14,
X 0x55, 0x55, 0x55, 0x7d, 0xaa, 0xaa, 0xaa, 0xaa, 0x7c, 0x14, 0x55, 0x55,
X 0x55, 0x7d, 0xaa, 0xaa, 0xaa, 0xaa, 0x7c, 0x14, 0x55, 0x55, 0x55, 0x7d,
X 0xaa, 0xaa, 0xaa, 0xaa, 0x7c, 0x14, 0x55, 0x55, 0x55, 0x7d, 0xaa, 0xaa,
X 0xaa, 0xaa, 0x7c, 0x14, 0x55, 0x55, 0x55, 0x7d, 0xaa, 0xaa, 0xaa, 0xaa,
X 0x7c, 0x14, 0x55, 0x55, 0x55, 0x7d, 0xaa, 0xaa, 0xaa, 0xaa, 0x7c, 0x14,
X 0x55, 0x55, 0x55, 0x7d, 0xaa, 0xaa, 0xaa, 0xaa, 0x7c, 0x14, 0x55, 0x55,
X 0x55, 0x7d, 0xaa, 0xaa, 0xaa, 0xaa, 0x7c, 0x14, 0x55, 0x55, 0x55, 0x7d,
X 0xaa, 0xaa, 0xaa, 0xaa, 0x7c, 0x14, 0x55, 0x55, 0x55, 0x7d, 0xaa, 0xaa,
X 0xaa, 0xaa, 0x7c, 0x14, 0x55, 0x55, 0x55, 0x7d, 0xaa, 0xaa, 0xaa, 0xaa,
X 0x7c, 0x14, 0x55, 0x55, 0x55, 0x7d, 0xaa, 0xaa, 0xaa, 0xaa, 0x7c, 0x14,
X 0x55, 0x55, 0x55, 0x7d, 0xaa, 0xaa, 0xaa, 0xaa, 0x7c, 0x14, 0x00, 0x00,
X 0x00, 0x7c, 0xea, 0xff, 0xff, 0xff, 0x7b, 0xf4, 0xff, 0xff, 0xff, 0x77,
X 0xfa, 0xff, 0xff, 0xff, 0x6f, 0xfc, 0xff, 0xff, 0xff, 0x5f, 0xfe, 0xff,
X 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00 };
END_OF_FILE
if test 1299 -ne `wc -c <'bitmaps/button.xbm'`; then
    echo shar: \"'bitmaps/button.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/button.xbm'
fi
if test -f 'bitmaps/flash1.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/flash1.xbm'\"
else
echo shar: Extracting \"'bitmaps/flash1.xbm'\" \(1299 characters\)
sed "s/^X//" >'bitmaps/flash1.xbm' <<'END_OF_FILE'
X#define flash1_width 40
X#define flash1_height 40
X
Xstatic char flash1_bits[] = {
X 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0x00, 0x00, 0xe0,
X 0xff, 0x0f, 0x00, 0x00, 0xf8, 0xff, 0x3f, 0x00, 0x00, 0xfc, 0xff, 0x7f,
X 0x00, 0x00, 0xff, 0xff, 0xff, 0x01, 0x80, 0xff, 0xff, 0xff, 0x03, 0xc0,
X 0xff, 0xff, 0xff, 0x07, 0xe0, 0xff, 0xff, 0xff, 0x0f, 0xe0, 0xff, 0xff,
X 0xff, 0x0f, 0xf0, 0xff, 0xff, 0xff, 0x1f, 0xf8, 0xff, 0xff, 0xff, 0x3f,
X 0xf8, 0xff, 0xff, 0xff, 0x3f, 0xfc, 0xff, 0xff, 0xff, 0x7f, 0xfc, 0xff,
X 0xff, 0xff, 0x7f, 0xfc, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff,
X 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe,
X 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff,
X 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff,
X 0xfe, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0x7f, 0xfc, 0xff,
X 0xff, 0xff, 0x7f, 0xfc, 0xff, 0xff, 0xff, 0x7f, 0xf8, 0xff, 0xff, 0xff,
X 0x3f, 0xf8, 0xff, 0xff, 0xff, 0x3f, 0xf0, 0xff, 0xff, 0xff, 0x1f, 0xe0,
X 0xff, 0xff, 0xff, 0x0f, 0xe0, 0xff, 0xff, 0xff, 0x0f, 0xc0, 0xff, 0xff,
X 0xff, 0x07, 0x80, 0xff, 0xff, 0xff, 0x03, 0x00, 0xff, 0xff, 0xff, 0x01,
X 0x00, 0xfc, 0xff, 0x7f, 0x00, 0x00, 0xf8, 0xff, 0x3f, 0x00, 0x00, 0xe0,
X 0xff, 0x0f, 0x00, 0x00, 0x00, 0xff, 0x01, 0x00 };
END_OF_FILE
if test 1299 -ne `wc -c <'bitmaps/flash1.xbm'`; then
    echo shar: \"'bitmaps/flash1.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/flash1.xbm'
fi
if test -f 'bitmaps/flash2.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/flash2.xbm'\"
else
echo shar: Extracting \"'bitmaps/flash2.xbm'\" \(1331 characters\)
sed "s/^X//" >'bitmaps/flash2.xbm' <<'END_OF_FILE'
X#define flash2_width 40
X#define flash2_height 40
Xstatic char flash2_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x01,
X   0x00, 0x00, 0xe0, 0xff, 0x0f, 0x00, 0x00, 0xf8, 0xff, 0x3f, 0x00, 0x00,
X   0xfc, 0xff, 0x7f, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
X   0xff, 0x01, 0x80, 0xff, 0xff, 0xff, 0x03, 0xc0, 0xff, 0xff, 0xff, 0x07,
X   0xc0, 0xff, 0xff, 0xff, 0x07, 0xe0, 0xff, 0xff, 0xff, 0x0f, 0xe0, 0xff,
X   0xff, 0xff, 0x0f, 0xe0, 0xff, 0xff, 0xff, 0x0f, 0xf0, 0xff, 0xff, 0xff,
X   0x1f, 0xf0, 0xff, 0xff, 0xff, 0x1f, 0xf0, 0xff, 0xff, 0xff, 0x1f, 0xf0,
X   0xff, 0xff, 0xff, 0x1f, 0xf0, 0xff, 0xff, 0xff, 0x1f, 0xf0, 0xff, 0xff,
X   0xff, 0x1f, 0xf0, 0xff, 0xff, 0xff, 0x1f, 0xf0, 0xff, 0xff, 0xff, 0x1f,
X   0xf0, 0xff, 0xff, 0xff, 0x1f, 0xe0, 0xff, 0xff, 0xff, 0x0f, 0xe0, 0xff,
X   0xff, 0xff, 0x0f, 0xe0, 0xff, 0xff, 0xff, 0x0f, 0xc0, 0xff, 0xff, 0xff,
X   0x07, 0xc0, 0xff, 0xff, 0xff, 0x07, 0x80, 0xff, 0xff, 0xff, 0x03, 0x00,
X   0xff, 0xff, 0xff, 0x01, 0x00, 0xfe, 0xff, 0xff, 0x00, 0x00, 0xfc, 0xff,
X   0x7f, 0x00, 0x00, 0xf8, 0xff, 0x3f, 0x00, 0x00, 0xe0, 0xff, 0x0f, 0x00,
X   0x00, 0x00, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1331 -ne `wc -c <'bitmaps/flash2.xbm'`; then
    echo shar: \"'bitmaps/flash2.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/flash2.xbm'
fi
if test -f 'bitmaps/flash3.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/flash3.xbm'\"
else
echo shar: Extracting \"'bitmaps/flash3.xbm'\" \(1331 characters\)
sed "s/^X//" >'bitmaps/flash3.xbm' <<'END_OF_FILE'
X#define flash3_width 40
X#define flash3_height 40
Xstatic char flash3_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0xfe, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x07, 0x00, 0x00, 0xf0, 0xff,
X   0x1f, 0x00, 0x00, 0xf8, 0xff, 0x3f, 0x00, 0x00, 0xfc, 0xff, 0x7f, 0x00,
X   0x00, 0xfe, 0xff, 0xff, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x00, 0x00, 0xff,
X   0xff, 0xff, 0x01, 0x00, 0xff, 0xff, 0xff, 0x01, 0x00, 0xff, 0xff, 0xff,
X   0x01, 0x80, 0xff, 0xff, 0xff, 0x03, 0x80, 0xff, 0xff, 0xff, 0x03, 0x80,
X   0xff, 0xff, 0xff, 0x03, 0x80, 0xff, 0xff, 0xff, 0x03, 0x80, 0xff, 0xff,
X   0xff, 0x03, 0x80, 0xff, 0xff, 0xff, 0x03, 0x80, 0xff, 0xff, 0xff, 0x03,
X   0x00, 0xff, 0xff, 0xff, 0x01, 0x00, 0xff, 0xff, 0xff, 0x01, 0x00, 0xff,
X   0xff, 0xff, 0x01, 0x00, 0xfe, 0xff, 0xff, 0x00, 0x00, 0xfe, 0xff, 0xff,
X   0x00, 0x00, 0xfc, 0xff, 0x7f, 0x00, 0x00, 0xf8, 0xff, 0x3f, 0x00, 0x00,
X   0xf0, 0xff, 0x1f, 0x00, 0x00, 0xc0, 0xff, 0x07, 0x00, 0x00, 0x00, 0xfe,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1331 -ne `wc -c <'bitmaps/flash3.xbm'`; then
    echo shar: \"'bitmaps/flash3.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/flash3.xbm'
fi
if test -f 'bitmaps/flash4.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/flash4.xbm'\"
else
echo shar: Extracting \"'bitmaps/flash4.xbm'\" \(1331 characters\)
sed "s/^X//" >'bitmaps/flash4.xbm' <<'END_OF_FILE'
X#define flash4_width 40
X#define flash4_height 40
Xstatic char flash4_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x80, 0xff, 0x03, 0x00,
X   0x00, 0xe0, 0xff, 0x0f, 0x00, 0x00, 0xf0, 0xff, 0x1f, 0x00, 0x00, 0xf0,
X   0xff, 0x1f, 0x00, 0x00, 0xf8, 0xff, 0x3f, 0x00, 0x00, 0xf8, 0xff, 0x3f,
X   0x00, 0x00, 0xfc, 0xff, 0x7f, 0x00, 0x00, 0xfc, 0xff, 0x7f, 0x00, 0x00,
X   0xfc, 0xff, 0x7f, 0x00, 0x00, 0xfc, 0xff, 0x7f, 0x00, 0x00, 0xfc, 0xff,
X   0x7f, 0x00, 0x00, 0xfc, 0xff, 0x7f, 0x00, 0x00, 0xfc, 0xff, 0x7f, 0x00,
X   0x00, 0xf8, 0xff, 0x3f, 0x00, 0x00, 0xf8, 0xff, 0x3f, 0x00, 0x00, 0xf0,
X   0xff, 0x1f, 0x00, 0x00, 0xf0, 0xff, 0x1f, 0x00, 0x00, 0xe0, 0xff, 0x0f,
X   0x00, 0x00, 0x80, 0xff, 0x03, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1331 -ne `wc -c <'bitmaps/flash4.xbm'`; then
    echo shar: \"'bitmaps/flash4.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/flash4.xbm'
fi
if test -f 'bitmaps/jewel.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/jewel.xbm'\"
else
echo shar: Extracting \"'bitmaps/jewel.xbm'\" \(1296 characters\)
sed "s/^X//" >'bitmaps/jewel.xbm' <<'END_OF_FILE'
X#define jewel_width 40
X#define jewel_height 40
X
Xstatic char jewel_bits[] = {
X 0x01, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0x7f, 0xfa, 0xff,
X 0xff, 0xff, 0x7f, 0xf6, 0xff, 0xff, 0xff, 0x5f, 0xee, 0xff, 0xff, 0xff,
X 0x4f, 0xde, 0xff, 0xff, 0xff, 0x47, 0xfe, 0xff, 0xff, 0xff, 0x43, 0x7e,
X 0x55, 0x55, 0x55, 0x43, 0xfe, 0xaa, 0xaa, 0xaa, 0x42, 0x7e, 0x55, 0x55,
X 0x55, 0x43, 0xfe, 0xaa, 0xaa, 0xaa, 0x42, 0x7e, 0x55, 0x55, 0x55, 0x43,
X 0xfe, 0xaa, 0xaa, 0xaa, 0x42, 0x7e, 0x55, 0x55, 0x55, 0x43, 0xfe, 0xa8,
X 0xaa, 0x8a, 0x42, 0x7e, 0x55, 0x55, 0x55, 0x43, 0xfe, 0x88, 0x80, 0x88,
X 0x42, 0x7e, 0x25, 0x55, 0x52, 0x43, 0xfe, 0x88, 0x94, 0x88, 0x42, 0x7e,
X 0x54, 0x41, 0x15, 0x43, 0xfe, 0xaa, 0xaa, 0xaa, 0x42, 0x7e, 0x55, 0x55,
X 0x55, 0x43, 0xfe, 0xaa, 0xaa, 0xaa, 0x42, 0x7e, 0x55, 0x55, 0x55, 0x43,
X 0xfe, 0xaa, 0xaa, 0xaa, 0x42, 0x7e, 0x55, 0x55, 0x55, 0x43, 0xfe, 0xaa,
X 0xaa, 0xaa, 0x42, 0x7e, 0x55, 0x55, 0x55, 0x43, 0xfe, 0xaa, 0xaa, 0xaa,
X 0x42, 0x7e, 0x55, 0x55, 0x55, 0x43, 0xfe, 0xaa, 0xaa, 0xaa, 0x42, 0x7e,
X 0x55, 0x55, 0x55, 0x43, 0xfe, 0xaa, 0xaa, 0xaa, 0x43, 0xfe, 0xff, 0xff,
X 0xff, 0x43, 0x3e, 0x00, 0x00, 0x00, 0x44, 0x1e, 0x00, 0x00, 0x00, 0x48,
X 0x0e, 0x00, 0x00, 0x00, 0x50, 0x06, 0x00, 0x00, 0x00, 0x60, 0xfe, 0xff,
X 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00 };
END_OF_FILE
if test 1296 -ne `wc -c <'bitmaps/jewel.xbm'`; then
    echo shar: \"'bitmaps/jewel.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/jewel.xbm'
fi
if test -f 'bitmaps/piece1.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/piece1.xbm'\"
else
echo shar: Extracting \"'bitmaps/piece1.xbm'\" \(1299 characters\)
sed "s/^X//" >'bitmaps/piece1.xbm' <<'END_OF_FILE'
X#define piece1_width 40
X#define piece1_height 40
X
Xstatic char piece1_bits[] = {
X 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x55, 0x55, 0x55, 0x05, 0xb0, 0xaa,
X 0xaa, 0xaa, 0x0a, 0xd8, 0xff, 0x55, 0x55, 0x15, 0x2c, 0xff, 0xa0, 0xaa,
X 0x2a, 0xd6, 0x37, 0xff, 0x55, 0x55, 0xea, 0x9b, 0xff, 0xa7, 0x2a, 0xec,
X 0xed, 0xff, 0x5f, 0x55, 0xfe, 0xf6, 0xff, 0xdf, 0x2a, 0x7e, 0xfb, 0xff,
X 0x3f, 0x55, 0xbe, 0xfd, 0xff, 0xff, 0x2a, 0xbe, 0xfd, 0xff, 0x7f, 0x55,
X 0xfe, 0xfe, 0xf3, 0xff, 0x2a, 0xfe, 0xfe, 0xe0, 0xff, 0x55, 0xfe, 0x3e,
X 0xfe, 0xff, 0x2a, 0xfe, 0x9e, 0xff, 0xff, 0x55, 0xfe, 0x9e, 0xff, 0xff,
X 0x2b, 0x7e, 0xcf, 0xff, 0xff, 0x55, 0x7e, 0xc7, 0xff, 0xff, 0x2b, 0x7e,
X 0xe7, 0xe7, 0xbf, 0x55, 0x7e, 0xe7, 0xc3, 0xbf, 0x2b, 0x7e, 0xe7, 0xc3,
X 0xbf, 0x55, 0x7e, 0xe7, 0x67, 0x9f, 0x2b, 0x7e, 0xc7, 0x3f, 0x9e, 0x55,
X 0x7e, 0xcf, 0x7f, 0x9b, 0x2b, 0xfe, 0x8f, 0xff, 0xd9, 0x55, 0xfe, 0x9f,
X 0xff, 0xcf, 0x2a, 0xfc, 0x3f, 0xfe, 0xe7, 0x55, 0xfe, 0xfd, 0xfc, 0xf3,
X 0x2a, 0xfc, 0xfb, 0xff, 0x78, 0x55, 0xfa, 0xfb, 0x3f, 0xbc, 0x2a, 0xfc,
X 0xe7, 0xff, 0x5f, 0x55, 0xfa, 0xcf, 0xff, 0xaf, 0x2a, 0xf4, 0x3f, 0xff,
X 0x57, 0x55, 0xea, 0x7f, 0xfe, 0xaa, 0x2a, 0x54, 0xff, 0x55, 0x55, 0x15,
X 0xa8, 0xfe, 0xaa, 0xaa, 0x0a, 0x50, 0x75, 0x55, 0x55, 0x05, 0xa0, 0xaa,
X 0xff, 0xaa, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 };
END_OF_FILE
if test 1299 -ne `wc -c <'bitmaps/piece1.xbm'`; then
    echo shar: \"'bitmaps/piece1.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/piece1.xbm'
fi
if test -f 'bitmaps/piece2.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/piece2.xbm'\"
else
echo shar: Extracting \"'bitmaps/piece2.xbm'\" \(1299 characters\)
sed "s/^X//" >'bitmaps/piece2.xbm' <<'END_OF_FILE'
X#define piece2_width 40
X#define piece2_height 40
X
Xstatic char piece2_bits[] = {
X 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x0f, 0xf8, 0xff,
X 0xfe, 0xff, 0x1f, 0xfc, 0x7f, 0xfd, 0xff, 0x3f, 0xfe, 0xff, 0xfe, 0xff,
X 0x6f, 0xfe, 0xff, 0xff, 0xff, 0x57, 0xfe, 0xff, 0xff, 0xff, 0x2b, 0xfe,
X 0xff, 0xff, 0xff, 0x55, 0xfe, 0xff, 0xff, 0xff, 0x2a, 0xfe, 0x01, 0x00,
X 0x50, 0x55, 0xfe, 0xfc, 0xaa, 0x9f, 0x2a, 0xf6, 0x7a, 0xd5, 0x2f, 0x55,
X 0xea, 0xfc, 0xaa, 0x9f, 0x2a, 0xf6, 0x7a, 0xd5, 0x2f, 0x55, 0xfe, 0xfc,
X 0xaa, 0x9f, 0x2a, 0xfe, 0x7a, 0xd5, 0x2f, 0x55, 0xfe, 0xfc, 0xaa, 0x9f,
X 0x2a, 0xfe, 0x7a, 0xd5, 0x2f, 0x55, 0xfe, 0xfc, 0xea, 0x9f, 0x2a, 0xfe,
X 0x7e, 0xf5, 0x2f, 0x55, 0xfe, 0xfe, 0xfa, 0x9f, 0x2a, 0xfe, 0x7e, 0xfd,
X 0x2f, 0x55, 0xfe, 0xfe, 0xfe, 0x9f, 0x2a, 0xfe, 0x7e, 0xff, 0x2f, 0x55,
X 0xfe, 0xfe, 0xff, 0x9f, 0x2a, 0xfe, 0xfe, 0xff, 0x2f, 0x55, 0xfe, 0xfe,
X 0xff, 0x9f, 0x2a, 0xfe, 0xfe, 0xff, 0x2f, 0x55, 0xfe, 0xfe, 0xff, 0x9f,
X 0x2a, 0xfe, 0xae, 0xaa, 0x2a, 0x55, 0xfe, 0x01, 0x00, 0x80, 0x2a, 0xfe,
X 0x55, 0x55, 0x55, 0x55, 0xfe, 0xaa, 0xaa, 0xaa, 0x2a, 0x7e, 0x55, 0x55,
X 0x55, 0x55, 0xbe, 0xaa, 0xaa, 0xaa, 0x2a, 0x5e, 0x55, 0x55, 0x55, 0x55,
X 0xac, 0xaa, 0xaa, 0xaa, 0x2a, 0x58, 0x55, 0x55, 0x55, 0x15, 0xb0, 0xaa,
X 0xaa, 0xaa, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00 };
END_OF_FILE
if test 1299 -ne `wc -c <'bitmaps/piece2.xbm'`; then
    echo shar: \"'bitmaps/piece2.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/piece2.xbm'
fi
if test -f 'bitmaps/piece3.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/piece3.xbm'\"
else
echo shar: Extracting \"'bitmaps/piece3.xbm'\" \(1299 characters\)
sed "s/^X//" >'bitmaps/piece3.xbm' <<'END_OF_FILE'
X#define piece3_width 40
X#define piece3_height 40
X
Xstatic char piece3_bits[] = {
X 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00,
X 0xff, 0x00, 0x00, 0x00, 0xc0, 0xf7, 0x03, 0x00, 0x00, 0xf0, 0xf7, 0x0f,
X 0x00, 0x00, 0xfc, 0xf7, 0x3f, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0xc0,
X 0xff, 0xf7, 0xff, 0x01, 0xf0, 0xff, 0xf7, 0xff, 0x0a, 0xfc, 0xff, 0xf7,
X 0x7f, 0x15, 0xf2, 0xff, 0xff, 0xbf, 0x2a, 0xce, 0xff, 0xf7, 0x5f, 0x55,
X 0x3e, 0xff, 0xf7, 0xaf, 0x2a, 0xfe, 0xfc, 0xff, 0x5f, 0x55, 0xfe, 0xeb,
X 0xff, 0xbf, 0x2a, 0xfe, 0x7f, 0xff, 0x56, 0x55, 0xfe, 0xff, 0x7e, 0xab,
X 0x2a, 0xfe, 0xff, 0xbd, 0x57, 0x55, 0xfe, 0xfe, 0xdb, 0xab, 0x2b, 0xfe,
X 0xff, 0xff, 0x57, 0x57, 0xbe, 0xff, 0xff, 0xab, 0x2a, 0xde, 0xff, 0xdb,
X 0x57, 0x55, 0xfe, 0xff, 0xbd, 0xab, 0x2a, 0xf6, 0xff, 0x7e, 0x57, 0x75,
X 0xfa, 0x7f, 0xff, 0xae, 0x6a, 0xfc, 0xff, 0xff, 0x55, 0x55, 0xfe, 0xff,
X 0xff, 0xbf, 0x2f, 0xfe, 0x5f, 0x5d, 0x55, 0x55, 0xfe, 0xaf, 0xaa, 0xaa,
X 0x2a, 0xfe, 0x57, 0x5d, 0x55, 0x55, 0xfc, 0xab, 0xaa, 0xaa, 0x3a, 0xf0,
X 0x55, 0x5d, 0x55, 0x0d, 0xc0, 0xaa, 0xaa, 0xaa, 0x03, 0x00, 0x57, 0x5d,
X 0xd5, 0x00, 0x00, 0xac, 0xaa, 0x3a, 0x00, 0x00, 0x70, 0x5d, 0x0d, 0x00,
X 0x00, 0xc0, 0xaa, 0x03, 0x00, 0x00, 0x00, 0xdf, 0x00, 0x00, 0x00, 0x00,
X 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
END_OF_FILE
if test 1299 -ne `wc -c <'bitmaps/piece3.xbm'`; then
    echo shar: \"'bitmaps/piece3.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/piece3.xbm'
fi
if test -f 'bitmaps/piece4.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/piece4.xbm'\"
else
echo shar: Extracting \"'bitmaps/piece4.xbm'\" \(1299 characters\)
sed "s/^X//" >'bitmaps/piece4.xbm' <<'END_OF_FILE'
X#define piece4_width 40
X#define piece4_height 40
X
Xstatic char piece4_bits[] = {
X 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x0f, 0xf8, 0xff,
X 0xff, 0xff, 0x1f, 0xfc, 0xff, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0xff, 0xff,
X 0x6f, 0xfe, 0xff, 0xff, 0xff, 0x57, 0x7e, 0x00, 0x00, 0x00, 0x2a, 0xbe,
X 0xff, 0xff, 0xff, 0x55, 0xbe, 0xff, 0xff, 0xff, 0x29, 0xbe, 0x7f, 0x55,
X 0xff, 0x55, 0xbe, 0xff, 0xaa, 0xfe, 0x29, 0xbe, 0x7f, 0x55, 0xff, 0x55,
X 0xbe, 0xff, 0xaa, 0xfe, 0x29, 0xbe, 0x7f, 0x55, 0xff, 0x55, 0xbe, 0xff,
X 0xaa, 0xfe, 0x29, 0xbe, 0x7f, 0x55, 0xff, 0x55, 0xbe, 0xff, 0xaa, 0xfe,
X 0x29, 0xbe, 0x7f, 0x55, 0xff, 0x55, 0xbe, 0xff, 0xaa, 0xfe, 0x29, 0xbe,
X 0x7f, 0x55, 0xff, 0x55, 0xbe, 0xff, 0xaa, 0xff, 0x29, 0xbe, 0x7f, 0xd5,
X 0xff, 0x55, 0xbe, 0xff, 0xea, 0xff, 0x29, 0xbe, 0x7f, 0xf5, 0xff, 0x55,
X 0xbe, 0xff, 0xfa, 0xff, 0x29, 0xbe, 0x7f, 0xfd, 0xff, 0x55, 0xbe, 0xff,
X 0xfe, 0xef, 0x29, 0xbe, 0x7f, 0xff, 0xf7, 0x55, 0xbe, 0xff, 0xff, 0xeb,
X 0x29, 0xbe, 0xff, 0xff, 0xf5, 0x55, 0xbe, 0xff, 0xff, 0xea, 0x29, 0xbe,
X 0xff, 0x7f, 0xf5, 0x55, 0xbe, 0xff, 0xff, 0xff, 0x29, 0x7e, 0x00, 0x00,
X 0x00, 0x54, 0xbe, 0xaa, 0xaa, 0xaa, 0x2a, 0x5e, 0x55, 0x55, 0x55, 0x55,
X 0xac, 0xaa, 0xaa, 0xaa, 0x2a, 0x58, 0x55, 0x55, 0x55, 0x15, 0xb0, 0xaa,
X 0xaa, 0xaa, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00 };
END_OF_FILE
if test 1299 -ne `wc -c <'bitmaps/piece4.xbm'`; then
    echo shar: \"'bitmaps/piece4.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/piece4.xbm'
fi
if test -f 'bitmaps/piece5.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/piece5.xbm'\"
else
echo shar: Extracting \"'bitmaps/piece5.xbm'\" \(1299 characters\)
sed "s/^X//" >'bitmaps/piece5.xbm' <<'END_OF_FILE'
X#define piece5_width 40
X#define piece5_height 40
X
Xstatic char piece5_bits[] = {
X 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x7f, 0x00, 0x00, 0xee,
X 0xbf, 0xbe, 0x00, 0x00, 0xd7, 0x5f, 0x5f, 0x01, 0x80, 0xed, 0xff, 0xaf,
X 0x02, 0xc0, 0x3a, 0x00, 0x50, 0x05, 0x60, 0xdd, 0xff, 0xa7, 0x0a, 0xb0,
X 0xee, 0xff, 0x4f, 0x15, 0x58, 0xf7, 0xff, 0x9f, 0x2a, 0xac, 0xfb, 0xff,
X 0x3f, 0x55, 0xde, 0xfd, 0xff, 0x7f, 0x2a, 0xee, 0xfe, 0xff, 0xff, 0x54,
X 0x7e, 0xff, 0xff, 0xff, 0x29, 0x7e, 0xff, 0xff, 0xff, 0x55, 0x7e, 0xff,
X 0xff, 0xff, 0x29, 0x7e, 0xff, 0xff, 0xff, 0x55, 0x7e, 0xff, 0xff, 0xff,
X 0x29, 0x7e, 0xff, 0xff, 0xf7, 0x55, 0x3e, 0xff, 0xff, 0xff, 0x29, 0x5e,
X 0xff, 0xfb, 0xf7, 0x55, 0x2e, 0xff, 0xe7, 0xf3, 0x29, 0x56, 0xff, 0xe7,
X 0xfb, 0x55, 0x2a, 0xff, 0x1f, 0xf7, 0x29, 0x56, 0xff, 0x1f, 0xf3, 0x55,
X 0x6a, 0xff, 0x1f, 0xfb, 0x29, 0x76, 0xff, 0xff, 0xf7, 0x55, 0x7a, 0xff,
X 0xff, 0xf3, 0x29, 0x7e, 0xff, 0xff, 0xf3, 0x54, 0xfe, 0xfe, 0x93, 0x78,
X 0x2a, 0xfe, 0x7d, 0x49, 0x3c, 0x55, 0xbc, 0xfb, 0xff, 0x9f, 0x2a, 0x58,
X 0xf7, 0xff, 0x4f, 0x15, 0xb0, 0xef, 0xff, 0xa7, 0x0a, 0xe0, 0xdf, 0xff,
X 0x53, 0x05, 0xc0, 0x3f, 0x00, 0xa8, 0x02, 0x80, 0x5f, 0x55, 0x55, 0x01,
X 0x00, 0xaf, 0xaa, 0xaa, 0x00, 0x00, 0x56, 0x55, 0x55, 0x00, 0x00, 0xac,
X 0xaa, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
END_OF_FILE
if test 1299 -ne `wc -c <'bitmaps/piece5.xbm'`; then
    echo shar: \"'bitmaps/piece5.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/piece5.xbm'
fi
if test -f 'bitmaps/piece6.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/piece6.xbm'\"
else
echo shar: Extracting \"'bitmaps/piece6.xbm'\" \(1299 characters\)
sed "s/^X//" >'bitmaps/piece6.xbm' <<'END_OF_FILE'
X#define piece6_width 40
X#define piece6_height 40
X
Xstatic char piece6_bits[] = {
X 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x07, 0x00, 0x00, 0xf8,
X 0xff, 0x1f, 0x00, 0x00, 0xfc, 0xff, 0x3f, 0x00, 0x00, 0xfe, 0xff, 0x7f,
X 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0xff, 0x01, 0xc0,
X 0xff, 0xff, 0xff, 0x03, 0xe0, 0xff, 0xff, 0xff, 0x07, 0xf0, 0x3f, 0xc0,
X 0xff, 0x0f, 0xf8, 0xff, 0xff, 0xff, 0x1f, 0xfc, 0xff, 0xff, 0xff, 0x3f,
X 0xfc, 0xff, 0xff, 0xff, 0x2f, 0xfe, 0xff, 0xff, 0xff, 0x57, 0xfe, 0xff,
X 0xff, 0xff, 0x2b, 0xfe, 0xfb, 0xff, 0xff, 0x55, 0xfe, 0xfb, 0xff, 0xbf,
X 0x2a, 0xfe, 0xf3, 0xff, 0xbf, 0x55, 0xfe, 0xf3, 0xff, 0xbf, 0x2a, 0xfe,
X 0xf3, 0xff, 0xbf, 0x55, 0xfe, 0xf3, 0xff, 0xbf, 0x2a, 0xfe, 0xf3, 0xff,
X 0xbf, 0x55, 0xfe, 0xf3, 0xff, 0xbf, 0x2a, 0xfe, 0xf3, 0xff, 0xbf, 0x55,
X 0xfe, 0xf3, 0xff, 0x9f, 0x2a, 0xfe, 0xf3, 0xff, 0x9f, 0x55, 0xfe, 0xf3,
X 0xff, 0x9f, 0x6a, 0xfc, 0xf3, 0xff, 0x9f, 0x35, 0xfc, 0x03, 0xf0, 0x87,
X 0x3a, 0xf8, 0x07, 0xfe, 0xff, 0x1d, 0xf0, 0xff, 0xff, 0xdf, 0x0e, 0xe0,
X 0xff, 0xff, 0xaf, 0x07, 0xc0, 0xff, 0x55, 0x55, 0x03, 0x80, 0xff, 0xaa,
X 0xaa, 0x01, 0x00, 0x7f, 0x55, 0xd5, 0x00, 0x00, 0xbe, 0xaa, 0x6a, 0x00,
X 0x00, 0x5c, 0x55, 0x35, 0x00, 0x00, 0xa8, 0xaa, 0x1a, 0x00, 0x00, 0x50,
X 0x55, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
END_OF_FILE
if test 1299 -ne `wc -c <'bitmaps/piece6.xbm'`; then
    echo shar: \"'bitmaps/piece6.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/piece6.xbm'
fi
if test -f 'bitmaps/skulemask.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/skulemask.xbm'\"
else
echo shar: Extracting \"'bitmaps/skulemask.xbm'\" \(839 characters\)
sed "s/^X//" >'bitmaps/skulemask.xbm' <<'END_OF_FILE'
X#define skulemask_width 30
X#define skulemask_height 30
Xstatic char skulemask_bits[] = {
X   0x00, 0xf0, 0x03, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0xfc, 0x1f, 0x00,
X   0x00, 0xfe, 0x3f, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0xff, 0x7f, 0x00,
X   0x80, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0x00,
X   0x80, 0xff, 0xff, 0x00, 0x80, 0xff, 0xff, 0x00, 0x00, 0xff, 0x7f, 0x00,
X   0x00, 0xff, 0x7f, 0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00, 0xfc, 0x1f, 0x00,
X   0x00, 0xf8, 0x0f, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x18, 0xf0, 0x07, 0x0c,
X   0xfc, 0xf0, 0x87, 0x1f, 0xfc, 0xe7, 0xf3, 0x1f, 0xf8, 0xff, 0xff, 0x0f,
X   0xe0, 0xff, 0xff, 0x03, 0x00, 0xff, 0x7f, 0x00, 0x00, 0xff, 0x7f, 0x00,
X   0xe0, 0xff, 0xff, 0x03, 0xf8, 0x3f, 0xfe, 0x0f, 0xfc, 0x07, 0xf0, 0x1f,
X   0xfc, 0x00, 0x80, 0x1f, 0x18, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 839 -ne `wc -c <'bitmaps/skulemask.xbm'`; then
    echo shar: \"'bitmaps/skulemask.xbm'\" unpacked with wrong size!
fi
# end of 'bitmaps/skulemask.xbm'
fi
if test -f 'help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help.c'\"
else
echo shar: Extracting \"'help.c'\" \(3235 characters\)
sed "s/^X//" >'help.c' <<'END_OF_FILE'
X/*
X**
X**	X11 Jewel By David Cooper and Jose Guterman 05/92
X**
X*/
X
X#ifdef VMS
X#include <decw$include/Xlib.h>
X#include <decw$include/Xutil.h>
X#include <decw$include/Xos.h>
X#else
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#endif
X 
X#include "general.h"
X#include "logic.h"
X#include "jewel.h"
X#include "xhscore.h"
X#include "xw.h"
X
X
XXFontStruct *SymbolFont;
XGC SymbolGC;
XXFontStruct *HeaderFont;
XGC HeaderGC;
X#define SYMBOL_FONT "-adobe-symbol-*-*-*-*-18-*-*-*-*-*-adobe-*"
X#define HEADER_FONT "-*-*-bold-r-*-*-24-*-*-*-p-*-iso8859-1"
X#define HEADER_LOC_Y 100
X#define HELP_LEFT_X 100
X#define HELP_RIGHT_X (SCREEN_X - HELP_LEFT_X)
Xchar *HeaderString = "\253\253\253 Keys \273\273\273";
X
X#define NUM_HELP 6
Xstatic char *HelpStrings[NUM_HELP][3]=
X	{
X		{ "\254", ", j, 4 ",     " Move Block Left", },
X		{ "\255", ", k, 5 ",     " Rotate Block", },
X		{ "\256", ", l, 6 ",     " Move Block Right", },
X		{ "\257", ", Space, 0 ", " Drop Block", },
X		{ " ", "P, p", " Pause/unPause", },
X		{ " ", "U, u", " Iconify and Pause", },
X	};
X
X
Xvoid Expose_Help()
X	{
X	int i, y;
X	XCharStruct Sizes;
X	int dir, asc, dsc;
X
X	y=HEADER_LOC_Y;
X
X	XTextExtents(HeaderFont,HeaderString,strlen(HeaderString),
X		&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, HeaderGC,
X		(SCREEN_X - (Sizes.width))/2 , y,
X		HeaderString, strlen(HeaderString));
X
X	for (i=0; i< NUM_HELP; i++)
X		{
X		int len;
X		y+=((HeaderFont->ascent+HeaderFont->descent)*2);
X		/* draw keypad */
X		len=strlen(HelpStrings[i][0]);
X		XTextExtents(SymbolFont,HelpStrings[i][0],len,
X			&dir,&asc,&dsc,&Sizes);
X		XDrawImageString(xw_display, xw_window, SymbolGC, 
X			HELP_LEFT_X, y, HelpStrings[i][0],len);
X		/* draw keyboard */
X		len=strlen(HelpStrings[i][1]);
X		XDrawImageString(xw_display, xw_window, HeaderGC,
X			(HELP_LEFT_X + Sizes.width), y, HelpStrings[i][1], len);
X		/* draw operations */
X		len=strlen(HelpStrings[i][2]);
X		XTextExtents(HeaderFont,HelpStrings[i][2],len,
X			&dir,&asc,&dsc,&Sizes);
X		XDrawImageString(xw_display, xw_window, HeaderGC,
X			(HELP_RIGHT_X - Sizes.width), y, HelpStrings[i][2], len);
X		}
X
X	XTextExtents(VerFont,StartString, strlen(StartString),
X		&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, VerGC,
X		(SCREEN_X - Sizes.width)/2,
X		START_LOC_Y+((VerFont->ascent)*3/2),
X		StartString, strlen(StartString));
X
X	XDrawImageString(xw_display, xw_window, VerGC, VER_LOC_X,
X		VER_LOC_Y+((VerFont->ascent)*3/2),
X		VerString, strlen(VerString));
X	XFlush(xw_display);
X	}
X
X
Xvoid Start_Help()
X	{
X	XClearWindow(xw_display, xw_window);
X
X	Expose_Help();
X	JewelState=HELP;
X	xw_set_timer(10000L);
X	}
X
Xvoid Init_Help()
X	{
X	XGCValues gcv;
X	unsigned long gcvm;
X
X	gcvm=(GCFont | GCGraphicsExposures | GCForeground | GCBackground);
X
X	gcv.graphics_exposures=False;
X	gcv.foreground=white;
X	gcv.background=black;
X
X	if ( (SymbolFont=XLoadQueryFont(xw_display,SYMBOL_FONT)) == NULL)
X		{ xw_fatal("Cannot load SYMBOL font.\n",__LINE__,__FILE__); }
X	gcv.font=SymbolFont->fid;
X	SymbolGC=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X
X	if ( (HeaderFont=XLoadQueryFont(xw_display,HEADER_FONT)) == NULL)
X		{ xw_fatal("Cannot load HEADER font.\n",__LINE__,__FILE__); }
X	gcv.font=HeaderFont->fid;
X	HeaderGC=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	}
END_OF_FILE
if test 3235 -ne `wc -c <'help.c'`; then
    echo shar: \"'help.c'\" unpacked with wrong size!
fi
# end of 'help.c'
fi
if test -f 'hscore.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hscore.c'\"
else
echo shar: Extracting \"'hscore.c'\" \(3528 characters\)
sed "s/^X//" >'hscore.c' <<'END_OF_FILE'
X/*
X**
X**	X11 Jewel By David Cooper and Jose Guterman 05/92
X**
X*/
X
X#include <stdio.h>
X
X#ifndef SYSV
X#   include <string.h>
X#   ifdef VMS
X#	include <file.h>
X#   else
X#	include <sys/file.h>
X#   endif
X#else
X#   include <sys/types.h>
X#   include <sys/stat.h>
X#   include <fcntl.h>
X#   include <strings.h>
X#endif
X
X#ifdef GETPWENT
X#   include <pwd.h>
X#endif
X
X#include <errno.h>
X
X#include "general.h"
X#include "hscore.h"
X#include "xhscore.h"
X
Xint hscorefd;
XFILE *hscorefile;
X
X
Xint num_high_scores;
Xstruct record high_scores[MAX_HIGH_SCORES];
X
Xstatic int Stage, Score;
X
Xvoid Write_Scores()
X	{
X	int i;
X
X	rewind(hscorefile);
X	fflush(hscorefile);
X	fprintf(hscorefile, "%d\n", num_high_scores);
X	for (i=0; i<num_high_scores; i++)
X		{
X		fprintf(hscorefile, "%s %d %d\n", high_scores[i].name,
X				high_scores[i].stage, high_scores[i].score);
X		}
X	fflush(hscorefile);
X	}
X
Xvoid Read_Scores()
X	{
X	int i;
X
X	rewind(hscorefile);
X	fscanf(hscorefile, "%d\n", &num_high_scores);
X	for (i=0; i<num_high_scores; i++)
X		{
X		fscanf(hscorefile, "%s %d %d\n", high_scores[i].name,
X				&high_scores[i].stage, &high_scores[i].score);
X		high_scores[i].name[MAX_NAME_LENGTH] = '\0';
X		}
X	}
X
Xvoid File_Lock()
X	{
X	}
X
Xvoid File_Unlock()
X	{
X	}
X
XBOOL Open_High_Score_File()
X	{
X	if ((hscorefd = open(HSCORE_FILE, O_RDWR)) <0)
X		{
X		if (errno == ENOENT) 
X			{
X			/* File  does no exist */
X			if ((hscorefd = open(HSCORE_FILE, O_RDWR|O_CREAT, 0666)) <0)
X				{
X				/* Unsuccesful creation of file */
X				perror("CANNOT OPEN HIGHSCOREFILE:");
X				return(FALSE);
X				}
X			else
X				{
X				/* Succesful creation of new file */
X				File_Lock();
X				hscorefile = fdopen(hscorefd, "r+");
X				num_high_scores = 0;
X				Write_Scores();
X				return(TRUE);
X				}
X			}
X		else
X			{
X			/* File exist and unsuccesful open */
X			return(FALSE);
X			}
X		}
X	else
X		{
X		/* File exists and succesful open */
X		File_Lock();
X		hscorefile = fdopen(hscorefd, "r+");
X		Read_Scores();
X		return(TRUE);
X		}
X	}
X
Xvoid Close_High_Score_File()
X	{
X	File_Unlock();
X	fclose(hscorefile);
X	close(hscorefd);
X	}
X
Xvoid Add_High_Score(i)
Xint i;
X	{
X	high_scores[i].stage = Stage;
X	high_scores[i].score = Score;
X#ifndef GETPWENT
X    /*printf("%s\n",cuserid(0l));*/
X    memcpy(high_scores[i].name,cuserid(0l),8);
X#else
X	memcpy(high_scores[i].name,getpwuid(getuid())->pw_name,MAX_NAME_LENGTH+1);
X#endif
X	if (num_high_scores < MAX_HIGH_SCORES)
X		{
X		num_high_scores++;
X		}
X	Write_Scores();
X	Draw_One_High_Score(i+1);
X	}
X
Xvoid Update_High_Scores(NewStage, NewScore)
Xint NewStage, NewScore;
X	{
X	int i, j;
X	BOOL updated;
X	
X	Stage=NewStage;
X	Score=NewScore;
X
X	if (!Open_High_Score_File())
X		{
X		printf("Could not open high scores file\n");
X		}
X
X	Show_High_Scores(1);
X
X	updated = FALSE;
X	for (i=0; i<num_high_scores; i++)
X		{
X		if (Score > high_scores[i].score)
X			{
X			for (j=MAX_HIGH_SCORES-2; j>=i; j--)
X				{
X				high_scores[j+1].stage = high_scores[j].stage;
X				high_scores[j+1].score = high_scores[j].score;
X				memcpy(high_scores[j+1].name, high_scores[j].name,
X						MAX_NAME_LENGTH+1);
X				}
X			if (num_high_scores == MAX_HIGH_SCORES)
X				{
X				Wipeout_Last_High_Score();
X				}
X			Move_Down_High_Scores(i+1);
X			/*ms_sleep(1000L);*/
X			Add_High_Score(i);
X			Show_High_Scores(i+1);
X			updated = TRUE;
X			break;
X			}
X		}
X
X	if ((!updated) && (num_high_scores < MAX_HIGH_SCORES))
X		{
X		Add_High_Score(num_high_scores);
X		}
X	
X	Close_High_Score_File();
X	}
X
Xvoid Refresh_High_Scores()
X	{
X	if (!Open_High_Score_File())
X		{
X		printf("Could not open high scores file\n");
X		}
X
X	Show_High_Scores(1);
X	Close_High_Score_File();
X	}
END_OF_FILE
if test 3528 -ne `wc -c <'hscore.c'`; then
    echo shar: \"'hscore.c'\" unpacked with wrong size!
fi
# end of 'hscore.c'
fi
if test -f 'jewel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jewel.h'\"
else
echo shar: Extracting \"'jewel.h'\" \(2515 characters\)
sed "s/^X//" >'jewel.h' <<'END_OF_FILE'
X/*
X**
X**	X11 Jewel By David Cooper and Jose Guterman 05/92
X**
X*/
X
X
Xenum JStates { GAME, INTRO, HELP, HIGHSCORE, ICON, NULL_STATE };
Xextern enum JStates JewelState;
X
X/* functions in game.c */
Xextern void Start_New_Game();
X
X
X/* window shape:
X
X ######## ###
X ######## ###
X ######## ###
X ######## ###
X ######## ###
X ########
X ########
X ########
X ########
X ######## SCORE     6350
X ######## LIVES        2
X ######## SPEED    1.500
X ######## STAGE        0
X ######## REST        50
X ######## SOUND       ON
X
X Jewel 
X Version 1.0 (5/22/92) By David Cooper and Jose Guterman
X
X */
X
X#define MARGINX 10
X#define MARGINY 10
X  
X#define SIZE_PIECE 40 /* should match the bitmaps */
X#define BOARD_WIDTH (NUM_COLS+2) /* including side columns */
X#define BOARD_HEIGHT (NUM_ROWS+1) /* including bottom row */
X#define PREVIEW_WIDTH 3 /* including sides */
X#define PREVIEW_HEIGHT (BLOCK_SIZE + 2) /* including top and bot */
X#define SCORE_WIDTH 14 /* in characters */
X#define SCORE_HEIGHT 6 /* in characters */
X#define VER_FONT "-*-*-bold-o-*-*-18-*-*-*-p-*-iso8859-1"
X#define HIGHSC_FONT "-*-*-bold-r-*-*-24-*-*-*-p-*-iso8859-1"
Xextern char *VerString;
X#define SCORE_FONT "seven_seg"
X#define ALT_SC_FONT "-*-*-bold-r-*-*-24-*-*-*-m-*-iso8859-1"
X
X#define BRD_LOC_X (MARGINX)
X#define BRD_LOC_Y (MARGINY)
X#define BRD_WIDTH (BOARD_WIDTH * SIZE_PIECE)
X#define BRD_HEIGHT (BOARD_HEIGHT * SIZE_PIECE)
X#define PREV_LOC_X (BRD_LOC_X+SIZE_PIECE*(BOARD_WIDTH+1))
X#define PREV_LOC_Y (BRD_LOC_Y)
X#define LOGO_LOC_X (BRD_LOC_X+SIZE_PIECE/2)
X#define LOGO_LOC_Y (BRD_LOC_Y+SIZE_PIECE*BOARD_HEIGHT+(SIZE_PIECE/2))
X#define VER_LOC_X (BRD_LOC_X+SIZE_PIECE/2)
X#define VER_LOC_Y (LOGO_LOC_Y+Jewellogo_Height)
X#define START_LOC_Y 600
Xextern char *StartString;
X#define SCORE_LOC_X (PREV_LOC_X)
X#define SCORE_LOC_Y (PREV_LOC_Y+(SIZE_PIECE*PREVIEW_HEIGHT)+SIZE_PIECE)
X
X#define SCREEN_X 650
X#define SCREEN_Y 728
X
Xextern Pixmap LogoPM;
Xextern Pixmap Logo2PM;
Xextern GC LogoGC;
Xextern GC Logo2GC;
X
Xextern Pixmap BorderPM;
Xextern GC BorderGC;
X
Xextern Pixmap PiecesPM[];
Xextern GC PiecesGC[];
X
Xextern Pixel colors[];
X
Xextern Pixel green;
Xextern Pixel yellow;
Xextern Pixel black;
Xextern Pixel white;
X
Xextern int Score_Char_MHeight;
Xextern int Score_x_right;
Xextern XFontStruct *VerFont, *ScoreFont, *HighScoreFont;
Xextern GC ScoreGC;
Xextern GC HighScoreGC;
Xextern GC VerGC;
X
X/* bitmap dimensions */
Xextern int Border_Width;
Xextern int Border_Height;
Xextern int Jewellogo2_Width;
Xextern int Jewellogo2_Height;
Xextern int Jewellogo_Width;
Xextern int Jewellogo_Height;
END_OF_FILE
if test 2515 -ne `wc -c <'jewel.h'`; then
    echo shar: \"'jewel.h'\" unpacked with wrong size!
fi
# end of 'jewel.h'
fi
if test -f 'panel.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'panel.c'\"
else
echo shar: Extracting \"'panel.c'\" \(3339 characters\)
sed "s/^X//" >'panel.c' <<'END_OF_FILE'
X/*
X**
X**	X11 Jewel By David Cooper and Jose Guterman 05/92
X**
X*/
X
X#include "general.h"
X#include "hscore.h"
X#include "panel.h"
X
Xstatic int Score;
Xstatic int Lives;
Xstatic float Speed;
Xstatic int Stage;
Xstatic int Rest;
Xstatic BOOL _Sound = DEF_SOUND;
Xstatic BOOL _Paused;
X
Xstatic float Speeds[]=
X	{
X	1.500,		/* Stage 1 */
X	1.250,		/* Stage 2 */
X	1.000,		/* Stage 3 */
X	0.750,		/* Stage 4 */
X	0.500,		/* Stage 5 */
X	0.250,		/* Stage 6 */
X	0.2375,		/* Stage 7 */
X	0.2250,		/* Stage 8 */
X	0.2125,		/* Stage 9 */
X	0.2000,		/* Stage 10 */
X	0.1875,		/* Stage 11 */
X	0.1750,		/* Stage 12 */
X	0.1625,		/* Stage 13 */
X	0.1500,		/* Stage 14 */
X	0.1375,		/* Stage 15 */
X	0.1250,		/* Stage 16 */
X	0.1125,		/* Stage 17 */
X	0.1000,		/* Stage 18 */
X	0.0875,		/* Stage 19 */
X	0.0750,		/* Stage 20 */
X	0.0625,		/* Stage 21 */
X	0.0500,		/* Stage 22 */
X	0.0375,		/* Stage 23 */
X	0.0250,		/* Stage 24 */
X	0.0125,		/* Stage 25 */
X	0.0000,		/* Stage 26 */
X	0.0000		/* Stage 27 */
X	};
X
Xvoid Reset_Score()
X	{
X	/* set to zero */
X	Score=0;
X	Redraw_Score(Score);
X	}
X
Xvoid Add_Raw_Score(pts,mult)
Xint pts, mult;
X	{
X	/* a pts is any value */
X	/*  mult is simply the number of times pts is to be added */
X	/* Redraw_Add_Score(pts,mult);*/
X	Score+=(pts*mult);
X	Redraw_Score(Score);
X	}
X
X
Xvoid Add_Score(pts,iteration)
Xint pts, iteration;
X	{
X	int Mult=1<<(iteration-1);
X	/* mult is simply the iteration of match algorithm */
X	Redraw_Add_Score(pts,Mult);
X	Score+=(pts*Mult);
X	Redraw_Score(Score);
X	}
X
Xint Get_Score()
X	{
X	return(Score);
X	}
X
Xvoid Reset_Lives()
X	{
X	/* set to default */
X	Lives=INITIAL_LIVES;
X	Redraw_Lives(Lives);
X	}
X
Xvoid Dec_Lives()
X	{
X	/* obvious */
X	Lives--;
X	Redraw_Lives(Lives);
X	if (Lives == 0)		/* Sorry my friend you are history... */
X		{
X		End_Game();
X		}
X	}
X
Xvoid Reset_Stage()
X	{
X	/* set stage and speed */
X	Stage=1;
X	Speed=Speeds[0];
X	Redraw_Speed(Speed);
X	Redraw_Stage(Stage);
X	}
X
Xvoid Inc_Stage()
X	{
X	/* set stage and speed */
X	Stage++;
X	if (Stage > MAX_STAGE)
X		{
X		Stage = 1;
X		}
X	Speed=Speeds[Stage-1];
X	Redraw_Speed(Speed);
X	Redraw_Stage(Stage);
X	}
X
Xvoid Dec_Stage()
X	{
X	/* set stage and speed */
X	if (Stage > 1)
X		{
X		Stage--;
X		Speed=Speeds[Stage-1];
X		Redraw_Speed(Speed);
X		Redraw_Stage(Stage);
X		}
X	}
X
Xint Get_Stage()
X	{
X	return(Stage);
X	}
X
Xunsigned long Get_Speed_ms()
X	{
X	return((unsigned long)(Speed*1000));
X	}
X
Xvoid Reset_Rest()
X	{
X	Rest=PIECES_PER_STAGE;
X	Redraw_Rest(Rest);
X	}
X
XBOOL Dec_Rest(val)
X	{
X	BOOL new_stage;
X
X	new_stage=FALSE;
X	Rest = Rest-val;
X    if (Rest <= 0)           /* Time for next stage */
X        {
X		Inc_Stage();
X        Rest = PIECES_PER_STAGE + Rest;
X		new_stage=TRUE;
X        }
X    Redraw_Rest(Rest);
X	return(new_stage);
X    }
X
Xvoid Reset_Pause()
X	{
X	_Paused=FALSE;
X	Redraw_Pause();
X	}
X
Xvoid Set_Pause()
X	{
X	_Paused=TRUE;
X	Redraw_Pause();
X	}
X
XBOOL Toggle_Pause()
X	{
X	_Paused=((_Paused) ? FALSE : TRUE);
X	Redraw_Pause();
X	return(_Paused);
X	}
X
XBOOL Paused()
X	{
X	return(_Paused);
X	}
X
XBOOL Toggle_Sound()
X	{
X	_Sound=((_Sound) ? FALSE : TRUE);
X	Redraw_Sound();
X	return(_Sound);
X	}
X
XBOOL Sound()
X	{
X	return(_Sound);
X	}
X
Xvoid Redraw_Text()
X	{
X	/* do all of above */
X	Redraw_Score(Score);
X	Redraw_Lives(Lives);
X	Redraw_Speed(Speed);
X	Redraw_Stage(Stage);
X	Redraw_Rest(Rest);
X	Redraw_Sound();
X	Redraw_Pause();
X	}
X
Xvoid New_Game()
X	{
X	Reset_Score();
X	Reset_Lives();
X	Reset_Stage();
X	Reset_Rest();
X	Reset_Pause();
X	}
END_OF_FILE
if test 3339 -ne `wc -c <'panel.c'`; then
    echo shar: \"'panel.c'\" unpacked with wrong size!
fi
# end of 'panel.c'
fi
if test -f 'xjewel.help' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xjewel.help'\"
else
echo shar: Extracting \"'xjewel.help'\" \(4890 characters\)
sed "s/^X//" >'xjewel.help' <<'END_OF_FILE'
X1 XJEWEL
X Format:
X	run xjewel.exe
X
X Jewel is a droping block game akin to tetris.
X
X It is played by controling the motion of blocks which continue to fall from
X the top of the screen.  One can move them left and right, as well as
X rotate the jewel segements.  The object is to get the most points before
X the grim reaper ends the fun.
X
X Death happens when the screen is no longer capable of holding any more
X blocks.  To make high scores more interesting, you are given but three
X attempts to get points -- use them wisely.
X
X As the game progresses, and more jewels are removed, the speed of the game
X will increase.  This is measured in seconds of delay between steps of
X block motion.
X
X2 KEYS
X
X There are three sets of keys that can be used:
X ( or any combination )
X
X Option 1:
X         +---+ +---+ +---+
X         | j | | k | | l |
X         +---+ +---+ +---+
X           ^     ^     ^
X           |     |     |__ move block right
X           |     |________ rotate block
X           |______________ move block left
X
X         +---------+
X         |  SPACE  | <---- drop block
X         +---------+
X
X Option 2:
X         +---+ +---+ +---+
X         | 4 | | 5 | | 6 |
X         +---+ +---+ +---+
X           ^     ^     ^
X           |     |     |__ move block right
X           |     |________ rotate block
X           |______________ move block left
X
X         +---------+
X         |    0    | <---- drop block
X         +---------+
X
X Option 3: (cursor keypad)
X
X               +---+
X               | ^ | <----  rotate block
X               +---+
X         +---+ +---+ +---+
X         | < | | V | | > |
X         +---+ +---+ +---+
X           ^     ^     ^
X           |     |     |__ move block right
X           |     |________ drop block
X           |______________ move block left
X
X2 ROTATIONS
X
X The folowing rotations are possible:
X ( there are no others )
X
X              +---+       +---+       +---+
X              | 1 |       | 3 |       | 2 |
X              +---+       +---+       +---+
X              | 2 |  ==>  | 1 | ==>   | 3 |
X              +---+       +---+       +---+
X              | 3 |       | 2 |       | 1 |
X              +---+       +---+       +---+
X
X2 SCORING
X
X The basic way to get points is to unite the jewels to form triplet (or
X higher) matches.  This can be done in any direction, and can be
X accomplished in more than one part of the board at one time.  As the
X jewels are removed, the board falls to fill the spaces -- matches may
X again occur.
X
X These teritiary matches provide an interesting part to the game due to the
X formula for calculating points:
X
X    ( 300 (for base triplet) + 150 * (each additional jewel) ) * 2^order
X
X    where order is the number of the repeition from which the match
X    occured.
X
X As a light at the end of the bleak tunnel, a WILD CARD is available.  The
X wild block will be given at infrequent intervals, and will give the user
X the points for one triplet by removing all the jewels of a particular
X shape/color.
X
X To add some interest to the game, points are awarded for dropping the
X block from a height above its resting place.  This is accumlated at 10
X points per level above the place it will rest.
X
X2 STAGES
X
X There are no changes for the higher levels, although the speed increases,
X proportionaly to the level.  Stage increases with the successful
X completion of the 50 jewels required per level.  The current status is
X shown in the REST field.
X
X2 NOTES
X
X This game was originally written by Yoshihiro Satoh of HP.  I have made a
X modest attempt to replicate Domain/JewelBox under X.
X
X I have somewhat rudely taken the bitmaps from the original game and
X created this version.  I hold the copyright for the code, as I created
X it, but I hold no claim to the bitmaps which were freely
X distributed with the Domain version.
X
X REDISTRIBUTION in source or binary from is permited as long as adequate
X notation of the originators is retained, including the developer of the
X original Domain/Jewlbox, Yoshihiro Satoh.
X NOTE: I do not claim to hold any copyright on columns games, Jewelbox, or any
X related name or icon.  I have written the source and thats all I hold claim to.
X
X USE AT YOUR OWN RISK AND PERIL, I MAKE NO CLAIM OF USEABILITY OR WARANTY.
X
XORIGINAL NOTATIONS
X >Authors
X >-------
X >
X >   Programming       Yoshihiro Satoh
X >   Font Design       Yoshiharu Minami
X >   Document Writing  Nancy Paisner
X >
X >Copyright
X >---------
X >
X >  This software is in the Yoshihiro's Arcade Collections.
X >  Domain/JewelBox is a trade mark of Yoshihiro Satoh.
X >
X >  Copyright @ 1990 by Yoshihiro Satoh
X >  All rights are reserved by Yoshihiro Satoh.
X
X xjewel - Jewel for X11 Copyright 1992 by David Cooper
X
X2 AUTHOR
X
X David Cooper
X Jose Guterman
X
X2 BUGS
X
X It does not currently accept any arguments, including the display argument
X
X The DISPLAY environment must be set for it to work:
X
X	$ set display/node=<local node name>/create
X	$ run jewel
X
END_OF_FILE
if test 4890 -ne `wc -c <'xjewel.help'`; then
    echo shar: \"'xjewel.help'\" unpacked with wrong size!
fi
# end of 'xjewel.help'
fi
if test -f 'xjewel.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xjewel.man'\"
else
echo shar: Extracting \"'xjewel.man'\" \(4917 characters\)
sed "s/^X//" >'xjewel.man' <<'END_OF_FILE'
X.TH JEWEL 6 "December 1992" "X Version 11"
X.SH NAME
X
Xxjewel \- X windows droping jewels game
X
X.SH SYNOPSIS
X
X.B xjewel
X
X.SH DESCRIPTION
X
X.I Jewel
Xis a droping block game akin to tetris. 
X
XIt is played by controling the motion of blocks which continue to fall from
Xthe top of the screen.  One can move them left and right, as well as
Xrotate the jewel segements.  The object is to get the most points before
Xthe grim reaper ends the fun.
X
XDeath happens when the screen is no longer capable of holding any more
Xblocks.  To make high scores more interesting, you are given but three
Xattempts to get points -- use them wisely.
X
XAs the game progresses, and more jewels are removed, the speed of the game
Xwill increase.  This is measured in seconds of delay between steps of
Xblock motion.
X
X.SH KEYS
X
XThere are three sets of keys that can be used:
X.br
X( or any combination )
X
XOption 1:
X.TS
Xcenter tab (%) ;
X| cw(1.25i) | cw(1.25i) | cw(1.25i) | 
X  c   c   c
X  c   c   c .
X_
XJ %  K %  L 
X_
X|  %   |   %  | 
Xmove block left % rotate block % move block right
X.TE
X.TS
Xcenter tab (%) ;
X_   l
X| cw(1.25i) | l
X_   l.
X
XSPACE  % <- drop block
X
X.TE
X
XOption 2:
X
X.TS
Xcenter tab (%) ;
X| cw(1.25i) | cw(1.25i) | cw(1.25i) |
X  c   c   c
X  c   c   c .
X_
X4 %  5 %  6
X_
X|  %   |   %  |
Xmove block left % rotate block % move block right
X.TE
X.TS
Xcenter tab (%) ;
X_   l
X| cw(1.25i) | l
X_   l.
X
X0  % <- drop block
X
X.TE
X
X.if n .ne 8
XOption 3: (cursor keypad)
X                
X.TS
Xcenter tab (%) ;
X  l        _        l 
X  cw(1.25i) | cw(1.25i) | l
X  l        _        l  
X| cw(1.25i) | cw(1.25i) | cw(1.25i) |
X  c   c   c
X  c   c   c .
X
X %  \(ua %  - rotate block
X
X_
X\(<- %  \(da  %  \(->
X_
X|  %   |   %  |
Xmove block left % rotate block % move block right
X.TE
X
X.SH ROTATIONS
X
XThe folowing rotations are possible:
X( there are no others )
X
X.TS
Xcenter tab (%);
X_ % cw(1i) % _ % cw(1i) % _
X| cw(1i) | % cw(1i) % | cw(1i) | % cw(1i) % | cw(1i) |
X_ % cw(1i) % _ % cw(1i) % _
X| cw(1i) | % cw(1i) % | cw(1i) | % cw(1i) % | cw(1i) |
X_ % cw(1i) % _ % cw(1i) % _
X| cw(1i) | % cw(1i) % | cw(1i) | % cw(1i) % | cw(1i) |
X_ % cw(1i) % _ % cw(1i) % _ .
X
X1 % % 3 % % 2
X
X2 % \(rh % 1 % \(rh % 3
X
X3 % % 2 % % 1
X
X.TE
X
X.SH SCORING
X
XThe basic way to get points is to unite the jewels to form triplet (or
Xhigher) matches.  This can be done in any direction, and can be
Xaccomplished in more than one part of the board at one time.  As the
Xjewels are removed, the board falls to fill the spaces -- matches may
Xagain occur.
X
XThese teritiary matches provide an interesting part to the game due to the
Xformula for calculating points:
X    
X    ( 300 (for base triplet) + 150 * (each additional jewel) ) * 2^order
X
X    where order is the number of the repeition from which the match
X    occured.
X
XAs a light at the end of the bleak tunnel, a WILD CARD is available.  The
Xwild block will be given at infrequent intervals, and will give the user
Xthe points for one triplet by removing all the jewels of a particular
Xshape/color.
X
XTo add some interest to the game, points are awarded for dropping the
Xblock from a height above its resting place.  This is accumlated at 10
Xpoints per level above the place it will rest.
X
X.SH STAGES
X
XThere are no changes for the higher levels, although the speed increases,
Xproportionaly to the level.  Stage increases with the successful
Xcompletion of the 50 jewels required per level.  The current status is
Xshown in the REST field.
X
X.SH NOTES
X
XThis game was originally written by Yoshihiro Satoh of HP.  I have made a
Xmodest attempt to replicate Domain/JewelBox under X.
X
XI have somewhat rudely taken the bitmaps from the original game and
Xcreated this version.  I hold the copyright for the code, as I created
Xit, but I hold no claim to the bitmaps which were freely
Xdistributed with the Domain version.
X
XNOTE: I have attempted to reach the holder of the original copyright to 
Xascertain his acceptance for the release of this game, he did not, or was
Xnot able to reply.
X
XREDISTRIBUTION in source or binary from is permited as long as adequate
Xnotation of the originators is retained, including the developer of the 
Xoriginal Domain/Jewlbox, Yoshihiro Satoh.
X
XUSE AT YOUR OWN RISK AND PERIL, I MAKE NO CLAIM OF USEABILITY OR WARANTY.
X
X.SH ORIGINAL NOTATIONS
X>Authors
X.br
X>-------
X.br
X>
X.br
X>   Programming       Yoshihiro Satoh
X.br
X>   Font Design       Yoshiharu Minami
X.br
X>   Document Writing  Nancy Paisner
X.br
X>
X.br
X>Copyright
X.br
X>---------
X.br
X>
X.br
X>  This software is in the Yoshihiro's Arcade Collections.
X.br
X>  Domain/JewelBox is a trade mark of Yoshihiro Satoh.
X.br
X>
X.br
X>  Copyright @ 1990 by Yoshihiro Satoh
X.br
X>  All rights are reserved by Yoshihiro Satoh.
X.br
X
Xxjewel - Jewel for X11 Copyright 1992 by David Cooper
X
X.SH AUTHOR
X
XDavid Cooper
X.br
XJose Guterman
X.SH "SEE ALSO"
X
X.SH BUGS
X
XIt does not currently accept any X arguments, including the -display argument.
X
XThe DISPLAY environment variable must be set for it to work.
END_OF_FILE
if test 4917 -ne `wc -c <'xjewel.man'`; then
    echo shar: \"'xjewel.man'\" unpacked with wrong size!
fi
# end of 'xjewel.man'
fi
if test -f 'xw.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xw.h'\"
else
echo shar: Extracting \"'xw.h'\" \(1623 characters\)
sed "s/^X//" >'xw.h' <<'END_OF_FILE'
X/*
X**
X**	X11 Jewel By David Cooper and Jose Guterman 05/92
X**
X*/
X
X/*
X** xw.h - Header file for xw.c (XWraper) functoins
X*/
X
X/* Some XW types */
X
X/*typedef unsigned long Pixel;*/
X
X/* Functions provided by xw */
X
Xextern void  xw_fatal();
Xextern Pixel xw_alloc_color();
Xextern void  xw_main_loop();
Xextern void  xw_exit_main();
Xextern void  xw_init();
Xextern void  xw_start();
Xextern void  xw_set_timer();
Xextern void  xw_sync_sleep();
X
X/* Functions required by xw */
Xextern void xw_but_event(/*xbev*/);
Xextern void xw_expose_event(/*xev*/);
Xextern void xw_focus_event(/*xfev*/);
Xextern void xw_leave_event(/*xlev*/);
Xextern void xw_key_event(/*xkev*/);
Xextern void xw_map_event(/*xmev*/);
Xextern void xw_timeout();
X
X
X#ifdef VMS
X    struct timeval { long tv_sec; long tv_usec; };
X#else
X#	ifdef USE_SELECT
X#		include <sys/types.h>
X#		include <sys/time.h>
X#	    ifndef FD_SET
X		typedef long fd_set;
X#		define FD_SET(n,p) (*(p) |= (1 << (n)) )
X#		define FD_CLR(n,p) (*(p) &= ~(1 << (n)) )
X#		define FD_ISSET(n,p) (*(p) & (1 << (n)) )
X#		define FD_ZERO(p) bzero( (p), sizeof(*(p)) )
X#	    endif
X#	else
X#		include <stropts.h>
X#		include <poll.h>
X#	endif
X#endif
X
X#if defined(VMS)
X#   define ms_sleep(ms) { float tm; tm=(ms)/1000.0; LIB$WAIT(&tm); }
X#else
X#if defined(USE_SELECT)
X#	define ms_sleep(ms) { struct timeval tv; tv.tv_sec=((ms)/1000); tv.tv_usec=(((ms)%1000)*1000); select(1,NULL,NULL,NULL,&tv); }
X#else
Xstatic int __JUNK[2]={0};
X#	define ms_sleep(ms) poll(__JUNK,(unsigned long)0,ms)
X#endif
X#endif
X
X/* Data externs */
X
Xextern Display *xw_display;
Xextern int     xw_screen;
Xextern Window  xw_window;
Xextern GC      xw_gc;
END_OF_FILE
if test 1623 -ne `wc -c <'xw.h'`; then
    echo shar: \"'xw.h'\" unpacked with wrong size!
fi
# end of 'xw.h'
fi
echo shar: End of archive 4 \(of 5\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
