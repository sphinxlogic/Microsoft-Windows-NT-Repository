Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i003:  xjewel - dropping jewels game for X11, Part03/05
Message-ID: <4510@master.CNA.TEK.COM>
Date: 8 Feb 93 21:37:49 GMT
Sender: news@master.CNA.TEK.COM
Lines: 3403
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1682

Submitted-by: dcooper@datap.ca (Dave Cooper)
Posting-number: Volume 17, Issue 3
Archive-name: xjewel/Part03
Environment: X11, Xlib, Unix, VMS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 5)."
# Contents:  bitmaps/seven_seg.bdf game.c jewel.c logic.c make.com
#   xhscore.c
# Wrapped by billr@saab on Mon Feb  8 11:36:53 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'bitmaps/seven_seg.bdf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/seven_seg.bdf'\"
else
echo shar: Extracting \"'bitmaps/seven_seg.bdf'\" \(11219 characters\)
sed "s/^X//" >'bitmaps/seven_seg.bdf' <<'END_OF_FILE'
XSTARTFONT 2.1
XCOMMENT space_size 12
XFONT seven_seg
XSIZE 34 72 72
XFONTBOUNDINGBOX 18 34 0 -6
XSTARTPROPERTIES 2
XFONT_DESCENT 6
XFONT_ASCENT 28
XENDPROPERTIES
XCHARS 36
XSTARTCHAR char_0x20
XENCODING 32
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x2b
XENCODING 43
XSWIDTH 0 0
XDWIDTH 15 0
XBBX 15 33 0 -6
XBITMAP
X0000
X0000
X0000
X0000
X0000
X0000
X0000
X0E00
X0F00
X0E80
X0E40
X0E20
X0E20
XFFE0
XFFF0
XFFE8
X4F14
X2E8A
X1E46
X0E3E
X0E20
X0E20
X0520
X02A0
X0160
X00E0
X0000
X0000
X0000
X0000
X0000
X0000
X0000
XENDCHAR
XSTARTCHAR char_0x2d
XENCODING 45
XSWIDTH 0 0
XDWIDTH 16 0
XBBX 16 33 0 -6
XBITMAP
X0000
X0000
X0000
X0000
X0000
X0000
X0000
X0000
X0000
X0000
X0000
X0000
X0000
XFFF0
XFFF8
XFFF4
X400A
X2005
X1003
X0FFF
X0000
X0000
X0000
X0000
X0000
X0000
X0000
X0000
X0000
X0000
X0000
X0000
X0000
XENDCHAR
XSTARTCHAR char_0x2e
XENCODING 46
XSWIDTH 0 0
XDWIDTH 8 0
XBBX 8 33 0 -6
XBITMAP
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
XF0
XF8
XF4
XF2
X49
X25
X13
X0F
X00
X00
XENDCHAR
XSTARTCHAR char_0x30
XENCODING 48
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 34 0 -6
XBITMAP
X000000
X3FF000
XFFFC00
XFFFE00
XF01D00
XE81C80
XE41C40
XE3FC40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
X520A40
XEA1D40
XF61EC0
XEE1DC0
XE41C80
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XFFFC40
XFFFC40
X7FF240
X200140
X1000C0
X0801C0
X03FF00
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x31
XENCODING 49
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 34 0 -6
XBITMAP
X000000
X001C00
X001E00
X001D00
X001C80
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X000A40
X001D40
X001EC0
X001DC0
X001C80
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X000A40
X000540
X0002C0
X0001C0
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x32
XENCODING 50
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 34 0 -6
XBITMAP
X000000
X3FF000
X3FFC00
X3FFE00
X101D00
X081C80
X041C40
X03FC40
X001C40
X001C40
X001C40
X001C40
X001C40
X7FFC40
X7FF840
XFFF840
XF00440
XE802C0
XE40180
XE3FF80
XE20000
XE20000
XE20000
XE20000
XE20000
XFFF800
XFFFC00
X7FFA00
X200500
X100280
X080180
X03FF80
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x33
XENCODING 51
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 34 0 -6
XBITMAP
X000000
X3FF000
X3FFC00
X3FFE00
X101D00
X081C80
X041C40
X03FC40
X001C40
X001C40
X001C40
X001C40
X001C40
X3FFC40
X3FFC40
X3FFE40
X101D40
X081CC0
X041C00
X03FC40
X001C40
X001C40
X001C40
X001C40
X001C40
X7FFC40
X7FFC40
X7FF240
X200140
X1000C0
X0801C0
X07FF00
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x34
XENCODING 52
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 34 0 -6
XBITMAP
X000000
X001C00
XE01E00
XF01D00
XE81C80
XE41C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XFFFC40
X7FF840
X7FFE40
X201D40
X101CC0
X081C00
X07FC40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X000A40
X000540
X0002C0
X0001C0
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x35
XENCODING 53
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 34 0 -6
XBITMAP
X000000
X3FF000
XFFF800
XFFF400
XF00A00
XE80500
XE40300
XE3FF00
XE20000
XE20000
XE20000
XE20000
XE20000
XFFF800
X7FFC00
X7FFE00
X201D00
X101C80
X081C40
X07FC40
X001C40
X001C40
X001C40
X001C40
X001C40
X7FFC40
X7FFC40
X7FF240
X200140
X1000C0
X0801C0
X07FF00
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x36
XENCODING 54
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 34 0 -6
XBITMAP
X000000
X3FF000
XFFF800
XFFF400
XF00A00
XE80500
XE40300
XE3FF00
XE20000
XE20000
XE20000
XE20000
XE20000
XFFF800
XFFFC00
XFFFE00
XF01D00
XE81C80
XE41C40
XE3FC40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XFFFC40
XFFFC40
X7FF240
X200140
X1000C0
X0801C0
X03FF00
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x37
XENCODING 55
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 34 0 -6
XBITMAP
X000000
X7FF000
X7FFC00
X7FFE00
X201D00
X101C80
X081C40
X07FC40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X000A40
X001D40
X001EC0
X001DC0
X001C80
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X000A40
X000540
X0002C0
X0001C0
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x38
XENCODING 56
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 34 0 -6
XBITMAP
X000000
X3FF000
XFFFC00
XFFFE00
XF01D00
XE81C80
XE41C40
XE3FC40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XFFFC40
X7FF840
XFFFC40
XF01E40
XE81D40
XE41C80
XE3FC40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XFFFC40
XFFFC40
X7FF240
X200140
X1000C0
X0801C0
X07FF00
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x39
XENCODING 57
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 34 0 -6
XBITMAP
X000000
X3FF000
XFFFC00
XFFFE00
XF01D00
XE81C80
XE41C40
XE3FC40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XFFFC40
X7FF840
X7FFC40
X201E40
X101D40
X081C80
X07FC40
X001C40
X001C40
X001C40
X001C40
X001C40
X7FFC40
X7FFC40
X7FF240
X200140
X1000C0
X0801C0
X07FF00
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x3a
XENCODING 58
XSWIDTH 0 0
XDWIDTH 8 0
XBBX 8 33 0 -6
XBITMAP
X00
X00
X00
X00
X00
X00
X00
X00
X00
XF0
XF8
XF4
XF2
X49
X25
XF3
XFF
XF4
XF2
X49
X25
X13
X0F
X00
X00
X00
X00
X00
X00
X00
X00
X00
X00
XENDCHAR
XSTARTCHAR char_0x41
XENCODING 65
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X3FF000
XFFFC00
XFFFE00
XF01D00
XE81C80
XE41C40
XE3FC40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XFFFC40
X7FF840
XFFFC40
XF01E40
XE81D40
XE41C80
XE3FC40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
X520A40
X2A0540
X1602C0
X0A0140
X0600C0
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x43
XENCODING 67
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X3FF000
XFFF800
XFFF400
XF00A00
XE80500
XE40300
XE3FF00
XE20000
XE20000
XE20000
XE20000
XE20000
XE20000
X520000
XEA0000
XF60000
XEA0000
XE40000
XE20000
XE20000
XE20000
XE20000
XE20000
XE20000
XFFF000
XFFF800
X7FF400
X200A00
X100500
X080300
X03FF00
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x44
XENCODING 68
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X3FF000
XFFFC00
XFFFE00
XF01D00
XE81C80
XE41C40
XE3FC40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
X520A40
XEA0540
XF61AC0
XEA3DC0
XE47AC0
XE2F500
XE3E300
XE3C100
XE78200
XEF0400
XFE0800
XFC1000
XF82000
X704000
X288000
X150000
X0A0000
X060000
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x45
XENCODING 69
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X3FF000
XFFF800
XFFF400
XF00A00
XE80500
XE40300
XE3FF00
XE20000
XE20000
XE20000
XE20000
XE20000
XFFF000
XFFF800
XFFF400
XF00A00
XE80500
XE40300
XE3FF00
XE20000
XE20000
XE20000
XE20000
XE20000
XFFF000
XFFF800
X7FF400
X200A00
X100500
X080300
X03FF00
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x46
XENCODING 70
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X3FF000
XFFF800
XFFF400
XF00A00
XE80500
XE40300
XE3FF00
XE20000
XE20000
XE20000
XE20000
XE20000
XFFF000
XFFF800
XFFF400
XF00A00
XE80500
XE40300
XE3FF00
XE20000
XE20000
XE20000
XE20000
XE20000
XE20000
XE20000
X520000
X2A0000
X160000
X0A0000
X060000
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x47
XENCODING 71
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X3FF000
XFFF800
XFFF400
XF00A00
XE80500
XE40300
XE3FF00
XE20000
XE20000
XE20000
XE20000
XE20000
XE20000
X521C00
XEA1E00
XF61D00
XEA1C80
XE41C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XFFFC40
XFFFC40
X7FF240
X200140
X1000C0
X0801C0
X03FF00
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x48
XENCODING 72
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X001C00
XE01C00
XE01E00
XF01D00
XE81C80
XE41C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XFFFC40
X7FF840
XFFFC40
XF01E40
XE81D40
XE41C80
XE3FC40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
X520A40
X2A0540
X1602C0
X0A0140
X0600C0
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x49
XENCODING 73
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X001C00
X001E00
X001D00
X001C80
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X000A40
X001D40
X001EC0
X001DC0
X001C80
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X000A40
X000540
X0002C0
X0001C0
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x4c
XENCODING 76
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X000000
XC00000
XE00000
XF00000
XE80000
XE40000
XE20000
XE20000
XE20000
XE20000
XE20000
XE20000
XE20000
X520000
XEA0000
XF60000
XEE0000
XE40000
XE20000
XE20000
XE20000
XE20000
XE20000
XE20000
XFFF800
XFFFC00
X7FFA00
X200500
X100280
X080180
X03FF00
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x4d
XENCODING 77
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X400800
XE01C00
XF03E00
XE87D00
XEEfC80
XEfdC40
XEf9C40
XE71C40
XE31C40
XE2bC40
XE25C40
XE21C40
XE21C40
X521A40
XEA1D40
XF61EC0
XEA1D40
XE41C80
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
X520A40
X2A0540
X1602C0
X0A0140
X0600C0
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x4e
XENCODING 78
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X400800
XE01C00
XF01E00
XE81D00
XEE1C80
XEF1C40
XEF9C40
XE7DC40
XE3FC40
XE3FC40
XE2FC40
XE27C40
XE21C40
X521A40
XEA1D40
XF61EC0
XEA1D40
XE41C80
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
X520A40
X2A0540
X1602C0
X0A0140
X0600C0
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x4f
XENCODING 79
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X3FF000
XFFFC00
XFFFE00
XF01D00
XE81C80
XE41C40
XE3FC40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
X520A40
XEA1D40
XF61EC0
XEE1DC0
XE41C80
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XFFFC40
XFFFC40
X7FF240
X200140
X1000C0
X0801C0
X03FF00
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x50
XENCODING 80
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X3FF000
XFFFC00
XFFFE00
XF01D00
XE81C80
XE41C40
XE3FC40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XFFFC40
X7FF840
XFFFC40
XF00A40
XE80540
XE402C0
XE3FFC0
XE20000
XE20000
XE20000
XE20000
XE20000
XE20000
XE20000
X520000
X2A0000
X160000
X0A0000
X060000
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x52
XENCODING 82
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X3FF000
XFFFC00
XFFFE00
XF01D00
XE81C80
XE41C40
XE3FC40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XFFFC40
X7FF840
XFFFC40
XF00A40
XEE0540
XEF02C0
XEFBFC0
XE7C000
XE3E000
XE1F000
XE2F800
XE27C00
XE23E00
XE21D00
X520A80
X2A0540
X1602C0
X0A0140
X0600C0
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x53
XENCODING 83
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X3FF000
XFFF800
XFFF400
XF00A00
XE80500
XE40300
XE3FF00
XE20000
XE20000
XE20000
XE20000
XE20000
XFFF800
X7FFC00
X7FFE00
X201D00
X101C80
X081C40
X07FC40
X001C40
X001C40
X001C40
X001C40
X001C40
X7FFC40
X7FFC40
X7FF240
X200140
X1000C0
X0801C0
X07FF00
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x54
XENCODING 84
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X7FF000
X7FFC00
X7FFE00
X201D00
X101C80
X081C40
X07FC40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X000A40
X001D40
X001EC0
X001DC0
X001C80
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X001C40
X000A40
X000540
X0002C0
X0001C0
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x55
XENCODING 85
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X000000
X400C00
XE01E00
XF01D00
XE81C80
XE41C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
X520A40
XEA1D40
XF61EC0
XEE1DC0
XE41C80
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XFFFC40
XFFFC40
X7FF240
X200140
X1000C0
X0801C0
X03FF00
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x56
XENCODING 86
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X000000
XE01C00
XE01E00
XF01D00
XE81C80
XE41C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
X520A40
XEA0540
XF61AC0
XEA3DC0
XE47AC0
XE2F500
XE3E300
XE3C100
XE78200
XEF0400
XFE0800
XFC1000
XF82000
X704000
X288000
X150000
X0A0000
X060000
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x58
XENCODING 88
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X001C00
XE01C00
XE01E00
XF01D00
XE81C80
XE41C40
XE21C40
XE21C40
XE21C40
XE21C40
XF23C40
X7A7C40
X3FF240
X1FE140
X3FF080
X787900
XF83E00
XE41D00
XE3FC80
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
X520A40
X2A0540
X1602C0
X0A0140
X0600C0
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x6e
XENCODING 110
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X7FF800
XFFFC00
XFFFE00
XF01D00
XE81C80
XE41C40
XE3FC40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
XE21C40
X520A40
X2A0540
X1602C0
X0E01C0
X000000
X000000
XENDCHAR
XSTARTCHAR char_0x72
XENCODING 114
XSWIDTH 0 0
XDWIDTH 18 0
XBBX 18 33 0 -6
XBITMAP
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X000000
X7FF800
XFFFC00
XFFFA00
XF00500
XE80300
XE40100
XE3FF00
XE20000
XE20000
XE20000
XE20000
XE20000
XE20000
XE20000
XE20000
X520000
X2A0000
X160000
X0E0000
X000000
X000000
XENDCHAR
XENDFONT
END_OF_FILE
if test 11219 -ne `wc -c <'bitmaps/seven_seg.bdf'`; then
    echo shar: \"'bitmaps/seven_seg.bdf'\" unpacked with wrong size!
fi
# end of 'bitmaps/seven_seg.bdf'
fi
if test -f 'game.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'game.c'\"
else
echo shar: Extracting \"'game.c'\" \(10788 characters\)
sed "s/^X//" >'game.c' <<'END_OF_FILE'
X/*
X**
X**	X11 Jewel By David Cooper and Jose Guterman 05/92
X**
X*/
X
X#ifdef VMS
X#include <decw$include/Xlib.h>
X#include <decw$include/Xutil.h>
X#include <decw$include/Xos.h>
X#else
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#endif
X
X#include "general.h"
X#include "logic.h"
X#include "hscore.h"
X#include "xhscore.h"
X#include "jewel.h"
X#include "game.h"
X#include "panel.h"
X#include "xw.h"
X
X
X/* util functions */
Xvoid Key_Bell()
X	{
X	if (Sound())
X		{ XBell(xw_display,100); }
X	}
X#define STRBUFSIZE 128
X
X
X#include <stdlib.h>
X#define RANDY(range) (random()%(range))
X
Xvoid Melt_Down()
X	{
X	int cycle;
X	int offx,offy;
X	int srcx,srcy, destx,desty;
X	unsigned int width,height;
X	unsigned int GWIDTH=NUM_COLS*SIZE_PIECE, GHEIGHT=NUM_ROWS*SIZE_PIECE;
X
X	struct timeval curtime;
X	gettimeofday(&curtime,NULL);
X	srandom((unsigned int)(curtime.tv_usec>>8));
X
X#define NUM_CYCLES 12
X	for(cycle=0;cycle<NUM_CYCLES;cycle++)
X	  for(srcy=1+cycle ;srcy<(GHEIGHT-10);srcy+=(SIZE_PIECE/2))
X		{
X		int count;
X		for (count=0;count<((NUM_COLS*SIZE_PIECE)/40);count++)
X			{
X			offx=RANDY(5)-2;
X			offy=RANDY(4)+1;
X
X			width=RANDY(GWIDTH/2);
X			height=RANDY(GHEIGHT-srcy-offy);
X
X			/* MAXwidth+MAXoffx must be << GWIDTH */
X			srcx=RANDY(GWIDTH-width-(abs(offx)));
X			if (offx<0) { srcx-=offx; }
X
X			destx=srcx+offx;
X			desty=srcy+offy;
X			if (desty>(GHEIGHT-1)) break;
X
X			XCopyArea(xw_display,xw_window,xw_window,xw_gc,
X				srcx+(BRD_LOC_X+SIZE_PIECE), srcy+BRD_LOC_Y,
X				width,height,
X				destx+(BRD_LOC_X+SIZE_PIECE),desty+BRD_LOC_Y);
X			}
X		}
X	xw_sync_sleep(150L);
X
X	/* erase area */
X#	define NUM_SCAT 10 /* SIZE_PIECE should be an integral mult of this */
X	offx=RANDY(NUM_SCAT);
X	offy=RANDY(NUM_SCAT);
X	for (srcx=0; srcx < NUM_SCAT; srcx++)
X		{
X		static int xscat[NUM_SCAT]={ 1, 9, 3, 6, 2, 4, 0, 7, 5, 8 };
X		static int yscat[NUM_SCAT]={ 2, 1, 0, 8, 6, 4, 9, 3, 7, 5 };
X		for (srcy=0; srcy < NUM_SCAT; srcy++)
X			{
X			for (destx=0;destx<NUM_COLS;destx++)
X			  for (desty=0;desty<NUM_ROWS;desty++)
X				{
X				/*XClearArea(xw_display,xw_window,*/
X				XFillRectangle(xw_display,xw_window,PiecesGC[FLASH1],
X					((destx+1)*SIZE_PIECE)+BRD_LOC_X+
X						xscat[(srcx+srcy+offx)%NUM_SCAT]*(SIZE_PIECE/NUM_SCAT),
X					((desty)*SIZE_PIECE)+BRD_LOC_Y+
X						yscat[(srcy+offy)%NUM_SCAT]*(SIZE_PIECE/NUM_SCAT),
X					(SIZE_PIECE/NUM_SCAT), (SIZE_PIECE/NUM_SCAT)/*,False*/);
X				}
X			}
X		}
X	xw_sync_sleep(150L);
X	}
X
X
Xvoid Draw_Piece(piece,x,y)
Xint piece, x, y;
X	{
X	/* draw piece at loc x,y */
X	/* locations here are not raw board, but the active board */
X	if (x<0)
X		{
X		XCopyPlane(xw_display, PiecesPM[piece], xw_window, PiecesGC[piece],
X			0, 0, SIZE_PIECE, SIZE_PIECE,
X			PREV_LOC_X+(SIZE_PIECE*1), PREV_LOC_Y+(SIZE_PIECE*(y+1)), 1L);
X		}
X	else
X		{
X		XCopyPlane(xw_display, PiecesPM[piece], xw_window, PiecesGC[piece],
X			0, 0, SIZE_PIECE, SIZE_PIECE,
X			BRD_LOC_X+(SIZE_PIECE*(x+1)), BRD_LOC_Y+(SIZE_PIECE*y), 1L);
X		}
X	}
X
X
Xvoid Flash_Pieces(p_remove, numflash, background)
Xstruct rem_piece p_remove[];
Xint numflash,background;
X	{
X#ifndef SLOW_DRAW
X#  define SLOW_DRAW 0
X#endif
X	int reps;
X	int findex;
X
X	for (reps=0;reps<NUM_FLASH;reps++)
X		{
X		for (findex=0;findex < numflash;findex++)
X			{
X			Draw_Piece(FLASH1+reps, p_remove[findex].x, p_remove[findex].y);
X			}
X		xw_sync_sleep(70L+SLOW_DRAW);
X		for (findex=0;findex < numflash;findex++)
X			{
X			Draw_Piece(p_remove[findex].piece,
X				p_remove[findex].x, p_remove[findex].y);
X			}
X		xw_sync_sleep(160L+SLOW_DRAW);
X		}
X	for (findex=0;findex < numflash;findex++)
X		{
X		Draw_Piece(background, p_remove[findex].x, p_remove[findex].y);
X		}
X	xw_sync_sleep(100L+SLOW_DRAW);
X	}
X
Xvoid Redraw_Add_Score(pts,mult)
Xint pts, mult;
X	{
X#ifndef SLOW_FONTS
X#   define SLOW_FONTS 0
X#endif
X	char buf[80];
X	int y=SCORE_LOC_Y;
X	XCharStruct Sizes;
X	int dir, asc, dsc;
X	/* write points */
X	sprintf(buf,"POINTS");
X	XDrawImageString(xw_display, xw_window, ScoreGC, SCORE_LOC_X, y,
X		buf, strlen(buf));
X	sprintf(buf,"%d",pts);
X	XTextExtents(ScoreFont,buf,strlen(buf),&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, ScoreGC,
X		(Score_x_right - Sizes.width), y, buf, strlen(buf));
X	y+=Score_Char_MHeight;
X
X	/* write multiple */
X	sprintf(buf,"X");
X	XDrawImageString(xw_display, xw_window, ScoreGC, SCORE_LOC_X, y,
X		buf, strlen(buf));
X	sprintf(buf,"%d",mult);
X	XTextExtents(ScoreFont,buf,strlen(buf),&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, ScoreGC,
X		(Score_x_right - Sizes.width), y, buf, strlen(buf));
X	y+=Score_Char_MHeight;
X
X	/* wait a while */
X	xw_sync_sleep(160L+SLOW_FONTS);
X	
X	/* put total points up */
X	y=SCORE_LOC_Y;
X	sprintf(buf,"%6d",(pts * mult));
X	XTextExtents(ScoreFont,buf,strlen(buf),&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, ScoreGC,
X		(Score_x_right - Sizes.width), y, buf, strlen(buf));
X
X	for (y=SCORE_LOC_Y+1; y<(SCORE_LOC_Y + (Score_Char_MHeight*2)) ; y++)
X			/* location of SCORE */
X		{
X		char *buf2="POINTS ";
X		XDrawImageString(xw_display, xw_window, ScoreGC, SCORE_LOC_X, y,
X			buf2, strlen(buf2));
X		XDrawImageString(xw_display, xw_window, ScoreGC,
X			(Score_x_right - Sizes.width), y, buf, strlen(buf));
X		if (SLOW_FONTS > 0)
X		    {
X		    xw_sync_sleep(10L+SLOW_FONTS);
X		    /* IF THE X-SERVER IS FAST WITH FONTS */
X		    }
X		}
X	xw_sync_sleep(110L+SLOW_FONTS);
X	}
X
X
Xvoid Redraw_Score(Score)
Xint Score;
X	{
X	char buf[80];
X	XCharStruct Sizes;
X	int dir, asc, dsc;
X	int y=SCORE_LOC_Y + (Score_Char_MHeight*2);
X	/* write Score */
X	sprintf(buf,"SCORE  ");
X	XDrawImageString(xw_display, xw_window, ScoreGC, SCORE_LOC_X, y,
X		buf, strlen(buf));
X	sprintf(buf,"%d",Score);
X	XTextExtents(ScoreFont,buf,strlen(buf),&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, ScoreGC,
X		(Score_x_right - Sizes.width), y, buf, strlen(buf));
X	y+=Score_Char_MHeight;
X	}
X
Xvoid Redraw_Lives(Lives)
Xint Lives;
X	{
X	char buf[80];
X	XCharStruct Sizes;
X	int dir, asc, dsc;
X	int y=SCORE_LOC_Y + (Score_Char_MHeight*3);
X	/* write Lives */
X	sprintf(buf,"LIVES  ");
X	XDrawImageString(xw_display, xw_window, ScoreGC, SCORE_LOC_X, y,
X		buf, strlen(buf));
X	sprintf(buf,"%d",Lives);
X	XTextExtents(ScoreFont,buf,strlen(buf),&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, ScoreGC,
X		(Score_x_right - Sizes.width), y, buf, strlen(buf));
X	y+=Score_Char_MHeight;
X	}
X
Xvoid Redraw_Speed(Speed)
Xfloat Speed;
X	{
X	char buf[80];
X	XCharStruct Sizes;
X	int dir, asc, dsc;
X	int y=SCORE_LOC_Y + (Score_Char_MHeight*4);
X	/* write Speed */
X	sprintf(buf,"SPEED  ");
X	XDrawImageString(xw_display, xw_window, ScoreGC, SCORE_LOC_X, y,
X		buf, strlen(buf));
X	sprintf(buf,"%.5f",Speed);
X	XTextExtents(ScoreFont,buf,strlen(buf),&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, ScoreGC,
X		(Score_x_right - Sizes.width), y, buf, strlen(buf));
X	y+=Score_Char_MHeight;
X	}
X
X
Xvoid Redraw_Stage(Stage)
Xint Stage;
X	{
X	char buf[80];
X	XCharStruct Sizes;
X	int dir, asc, dsc;
X	int y=SCORE_LOC_Y + (Score_Char_MHeight*5);
X	/* write Stage */
X	sprintf(buf,"STAGE  ");
X	XDrawImageString(xw_display, xw_window, ScoreGC, SCORE_LOC_X, y,
X		buf, strlen(buf));
X	sprintf(buf," %d",Stage);
X	XTextExtents(ScoreFont,buf,strlen(buf),&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, ScoreGC,
X		(Score_x_right - Sizes.width), y, buf, strlen(buf));
X	y+=Score_Char_MHeight;
X	}
X
X
Xvoid Redraw_Rest(Rest)
Xint Rest;
X	{
X	char buf[80];
X	XCharStruct Sizes;
X	int dir, asc, dsc;
X	int y=SCORE_LOC_Y + (Score_Char_MHeight*6);
X	/* write Rest */
X	sprintf(buf,"REST  ");
X	XDrawImageString(xw_display, xw_window, ScoreGC, SCORE_LOC_X, y,
X		buf, strlen(buf));
X	sprintf(buf,"  %d",Rest);
X	XTextExtents(ScoreFont,buf,strlen(buf),&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, ScoreGC,
X		(Score_x_right - Sizes.width), y, buf, strlen(buf));
X	y+=Score_Char_MHeight;
X	}
X
Xvoid Redraw_Sound()
X	{
X	char buf[80];
X	XCharStruct Sizes;
X	int dir, asc, dsc;
X	int y=SCORE_LOC_Y + (Score_Char_MHeight*7);
X	/* write Sound */
X	sprintf(buf,"SOUND ");
X	XDrawImageString(xw_display, xw_window, ScoreGC, SCORE_LOC_X, y,
X		buf, strlen(buf));
X	sprintf(buf,"%s",((Sound()) ? "  ON" : "OFF"));
X	XTextExtents(ScoreFont,buf,strlen(buf),&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, ScoreGC,
X		(Score_x_right - Sizes.width), y, buf, strlen(buf));
X	y+=Score_Char_MHeight;
X	}
X
Xvoid Redraw_Pause()
X	{
X	char buf[80];
X	XCharStruct Sizes;
X	int dir, asc, dsc;
X	int y=SCORE_LOC_Y + (Score_Char_MHeight*8);
X	/* write Pause */
X	if (Paused())
X		{ sprintf(buf,"PAUSED"); }
X	else
X		{ sprintf(buf,"            "); }
X	XTextExtents(ScoreFont,buf,strlen(buf),&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, ScoreGC,
X		(Score_x_right - Sizes.width), y, buf, strlen(buf));
X	}
X
Xvoid Redraw_Game_Board()
X	{
X	int x,y;
X	/* build border */
X	for (y=0;y<BOARD_HEIGHT;y++)
X		{
X		XCopyPlane(xw_display, BorderPM, xw_window, BorderGC, 0, 0,
X			Border_Width, Border_Height,
X			BRD_LOC_X, BRD_LOC_Y+(SIZE_PIECE*y),1L);
X		XCopyPlane(xw_display, BorderPM, xw_window, BorderGC, 0, 0,
X			Border_Width, Border_Height,
X			BRD_LOC_X+(SIZE_PIECE*(BOARD_WIDTH-1)), BRD_LOC_Y+(SIZE_PIECE*y),1L);
X		}
X	for (x=1;x<(BOARD_WIDTH-1);x++)
X		{
X		XCopyPlane(xw_display, BorderPM, xw_window, BorderGC, 0, 0,
X			Border_Width, Border_Height,
X			BRD_LOC_X+(SIZE_PIECE*x),BRD_LOC_Y+(SIZE_PIECE*(BOARD_HEIGHT-1)),1L);
X		}
X	for (x=0;x<(PREVIEW_WIDTH);x++)
X	  for (y=0;y<(PREVIEW_HEIGHT);y++)
X		{
X		XCopyPlane(xw_display, BorderPM, xw_window, BorderGC, 0, 0,
X			Border_Width, Border_Height,
X			PREV_LOC_X+(SIZE_PIECE*x),PREV_LOC_Y+(SIZE_PIECE*y),1L);
X		}
X	/* put pieces on it */
X	Redraw_Board();
X	}
X
Xvoid Start_New_Game()
X	{
X	extern void Expose_Game();
X	XClearWindow(xw_display,xw_window);
X	xw_set_timer(Get_Speed_ms());
X	JewelState=GAME;
X	New_Game();
X	Init_Logic();
X	Expose_Game();
X	}
X
Xvoid End_Game()
X	{
X	char *buf;
X	XCharStruct Sizes;
X	int dir, asc, dsc;
X	int y=SCORE_LOC_Y + (Score_Char_MHeight*8);
X
X	buf="GAME OVER";
X	XTextExtents(ScoreFont,buf,strlen(buf),&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, ScoreGC,
X		(Score_x_right - Sizes.width), y, buf, strlen(buf));
X
X	xw_sync_sleep(500L);
X	Set_State_High_Score();
X	Update_High_Scores(Get_Stage(), Get_Score());
X	}
X
X
Xvoid Expose_Game()
X	{
X	XCopyPlane(xw_display, Logo2PM, xw_window, Logo2GC, 0, 0,
X		Jewellogo2_Width, Jewellogo2_Height,
X		LOGO_LOC_X, LOGO_LOC_Y, 1L);
X
X	XSetClipOrigin(xw_display, LogoGC, LOGO_LOC_X, LOGO_LOC_Y );
X	XCopyPlane(xw_display, LogoPM, xw_window, LogoGC, 0, 0,
X		Jewellogo_Width, Jewellogo_Height,
X		LOGO_LOC_X, LOGO_LOC_Y, 1L);
X
X	XDrawImageString(xw_display, xw_window, VerGC, VER_LOC_X,
X		VER_LOC_Y+((VerFont->ascent)*3/2),
X		VerString, strlen(VerString));
X
X	Redraw_Text();
X	Redraw_Game_Board();
X	XFlush(xw_display);
X	}
X
Xvoid Game_Timeout()
X	{
X	if (!Paused())
X		{
X		Logic_Timeout();
X		XFlush(xw_display);
X		}
X	if (JewelState==GAME)
X		{ xw_set_timer(Get_Speed_ms()); }
X	}
END_OF_FILE
if test 10788 -ne `wc -c <'game.c'`; then
    echo shar: \"'game.c'\" unpacked with wrong size!
fi
# end of 'game.c'
fi
if test -f 'jewel.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jewel.c'\"
else
echo shar: Extracting \"'jewel.c'\" \(12508 characters\)
sed "s/^X//" >'jewel.c' <<'END_OF_FILE'
X/*
X**
X**	X11 Jewel By David Cooper and Jose Guterman 05/92
X**
X*/
X
X#define XK_MISCELLANY
X#define XK_LATIN1
X#ifdef VMS
X#include <decw$include/Xlib.h>
X#include <decw$include/Xutil.h>
X#include <decw$include/Xos.h>
X#include <decw$include/keysymdef.h>
X#else
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#include <X11/keysymdef.h>
X#endif
X
X#include <stdlib.h>
X
X#include "general.h"
X#include "logic.h"
X#include "jewel.h"
X#include "xw.h"
X#include "xhscore.h"
X#include "hscore.h"
X#include "intro.h"
X#include "game.h"
X#include "panel.h"
X#include "help.h"
X
X#include "version.h"
Xchar *StartString="Press \140Space\047 to begin, or \140H\047 for Help";
X
Xenum JStates JewelState;
X/* event functions */
X
Xvoid xw_focus_event(xfev)
XXFocusChangeEvent *xfev;
X	{
X	/* handle focus change */
X	if ((JewelState == GAME) && (xfev->type == FocusOut))
X		{
X		/*printf("FocusOut->PAUSED\n");*/
X		Set_Pause();
X		}
X	}
X
X
Xvoid xw_leave_event(xlev)
XXLeaveWindowEvent *xlev;
X	{
X#ifdef LEAVE_PAUSE
X	if (JewelState == GAME)
X		{
X		/*printf("LeaveOut->PAUSED\n");*/
X		Set_Pause();
X		}
X#endif
X	}
X
X
Xstatic enum JStates OldState=NULL_STATE;
X
Xstatic void StartIcon()
X    {
X    OldState=JewelState;
X    JewelState=ICON;
X    xw_set_timer(2000l);
X    }
X
Xstatic void EndIcon()
X    {
X    JewelState=OldState;
X    xw_set_timer(100L);
X    }
X
Xvoid xw_map_event(xmev)
XXMapEvent *xmev;
X	{
X	/*printf("GOT MAP EVENT. win=%ld, type=%d\n",xmev->window,
X	xmev->type);*/
X	if (xmev->window == xw_window)
X		{
X		if ((JewelState!=ICON) && (xmev->type == UnmapNotify))
X			{
X			StartIcon();
X			}
X		if ((JewelState==ICON) && (xmev->type == MapNotify))
X			{
X			EndIcon();
X			}
X		}
X	}
X
Xvoid xw_key_event(xkev)
XXKeyEvent *xkev;
X	{
X	/* deal with key event */
X	KeySym key;
X
X	key=XLookupKeysym(xkev,xkev->state);
X	switch(JewelState)
X		{
X		case GAME:
X			switch(key)
X				{
X				/* HIDDEN KEYS USED FOR DEBUGGING 
X				case XK_plus:
X				case XK_KP_Add:
X					Inc_Stage();	
X					break;
X				case XK_minus:
X				case XK_KP_Subtract:
X					Dec_Stage();	
X					break; 
X				********************************/
X				case XK_U:
X				case XK_u:
X				case XK_Menu:/* do */
X				case XK_F1:
X				case XK_F20:
X					XIconifyWindow(xw_display, xw_window, xw_screen);
X					break;
X				case XK_Cancel:
X				case XK_E:
X				case XK_e:
X					Melt_Down();
X					End_Game();
X					break;
X				case XK_P:
X				case XK_p:
X					Toggle_Pause();
X					break;
X				case XK_S:
X				case XK_s:
X					Toggle_Sound();
X					break;
X				case XK_X:
X				case XK_x:
X				case XK_Q:
X				case XK_q:
X					printf("Thankyou for playing...try again sometime!\n");
X					xw_exit_main();
X					break;
X				case XK_Left:
X				case XK_4:
X				case XK_KP_4:
X				case XK_J:
X				case XK_j:
X					if (!Paused()) Move_Left();
X					break;
X				case XK_Right:
X				case XK_6:
X				case XK_KP_6:
X				case XK_L:
X				case XK_l:
X					if (!Paused()) Move_Right();
X					break;
X				case XK_Next:
X				case XK_Up:
X				case XK_5:
X				case XK_KP_5:
X				case XK_K:
X				case XK_k:
X					if (!Paused()) Rotate();
X					break;
X				case XK_Down:
X				case XK_0:
X				case XK_KP_0:
X				case XK_space:
X				case XK_KP_Space:
X					if (!Paused()) Drop();
X					break;
X				}
X			break;
X		case INTRO:
X		case HIGHSCORE:
X		case HELP:
X			switch (key)
X				{
X				case XK_Select:
X				case XK_Execute:
X				case XK_S:
X				case XK_s:
X				case XK_space:
X				case XK_KP_Space:
X					Start_New_Game();
X					break;
X				case XK_P:
X				case XK_p:
X					Set_State_High_Score();
X					break;
X				case XK_H:
X				case XK_h:
X				case XK_F1:
X				case XK_Help:
X				case XK_Menu:
X					Start_Help();
X					break;
X				case XK_X:
X				case XK_x:
X				case XK_Q:
X				case XK_q:
X					printf("Thankyou for playing...try again sometime!\n");
X					xw_exit_main();
X					break;
X				}
X			break;
X		}
X	XFlush(xw_display);
X	
X	/*xw_ev.x = xkev->x;
X	xw_ev.y = xkev->y;*/
X	}
X
X
X
Xvoid xw_but_event(xbev)
XXButtonEvent *xbev;
X	{
X	/* deal with key event */
X	/*printf("buttonpress:%d\n",xbev->button); */
X	/*xw_ev.button = xbev->button;
X	xw_ev.x = xbev->x;
X	xw_ev.y = xbev->y;*/
X	}
X
X
X
Xvoid xw_expose_event(xev)
XXExposeEvent *xev;
X	{
X	/* do screen update */
X	/*printf("GOT EXPOS EVENT, win=%ld, jstate=%d\n", xev->window,
X	JewelState);*/
X#ifdef ICON_WINDOW
X	if (xev->window != xw_window)
X	    { /* must be icon window */
X	    if (JewelState != ICON)
X		{ StartIcon(); }
X	    return;
X	    }
X	else
X	    {
X	    if (JewelState == ICON)
X		{ EndIcon(); }
X	    }
X#endif
X	if (!(xev->count))
X		{
X		switch(JewelState)
X			{
X			case NULL_STATE:
X				Start_Intro();
X				break;
X			case GAME:
X				Expose_Game();
X				break;
X			case HELP:
X				Expose_Help();
X				break;
X			case INTRO:
X				Expose_Intro();
X				break;
X			case HIGHSCORE:
X				Refresh_High_Scores();
X				break;
X			}
X		}
X	}
X
X
Xvoid Rot_Icons()
X	{
X#ifdef ICON_WINDOW
X	extern Window iw_window;
X	extern int iw_width, iw_height;
X	static int IconPiece=PIECE1;
X
X	XCopyPlane(xw_display, PiecesPM[IconPiece], iw_window, PiecesGC[IconPiece],
X		0, 0, SIZE_PIECE, SIZE_PIECE,
X		(iw_width - SIZE_PIECE)/2, (iw_height - SIZE_PIECE)/2, 1L);
X
X	IconPiece++;
X	if (IconPiece == NUM_REAL_PIECES) { IconPiece=PIECE1; }
X#endif
X
X	xw_set_timer(2000L);
X	}
X
Xvoid xw_timeout()
X	{
X	/* handle timer */
X	switch(JewelState)
X		{
X		case GAME:
X			Game_Timeout();
X			break;
X		case HIGHSCORE:
X			Start_Help();
X			break;
X		case HELP:
X			Start_Intro();
X			break;
X		case INTRO:
X			Intro_Timeout();
X			break;
X		case ICON:
X			Rot_Icons();
X			break;
X		}
X	}
X
X
X
X/********************************************************/
X
X#include "bitmaps/jewellogo.xbm"
X#include "bitmaps/jewellogo2.xbm"
X/* border */
X#include "bitmaps/border.xbm"
X/*#include "bitmaps/border1.xbm"*/
X/* pieces */
X#include "bitmaps/piece1.xbm"
X#include "bitmaps/piece2.xbm"
X#include "bitmaps/piece3.xbm"
X#include "bitmaps/piece4.xbm"
X#include "bitmaps/piece5.xbm"
X#include "bitmaps/piece6.xbm"
X#include "bitmaps/jewel.xbm"
X#include "bitmaps/flash1.xbm"
X#include "bitmaps/flash2.xbm"
X#include "bitmaps/flash3.xbm"
X#include "bitmaps/flash4.xbm"
X/* backdrops */
X#include "bitmaps/back1.xbm"
X#include "bitmaps/back2.xbm"
X#include "bitmaps/back3.xbm"
X#include "bitmaps/back4.xbm"
X
Xint Border_Width=border_width;
Xint Border_Height=border_height;
Xint Jewellogo2_Width=jewellogo2_width;
Xint Jewellogo2_Height=jewellogo2_height;
Xint Jewellogo_Width=jewellogo_width;
Xint Jewellogo_Height=jewellogo_height;
X
XPixmap LogoPM;
XPixmap Logo2PM;
XGC LogoGC;
XGC Logo2GC;
X
XPixmap BorderPM;
XGC BorderGC;
X
XPixmap PiecesPM[NUM_PIECES];
XGC PiecesGC[NUM_PIECES];
X
XGC ScoreGC;
XGC HighScoreGC;
Xint Score_Char_MHeight;
Xint Score_x_right;
XGC VerGC;
XXFontStruct *VerFont, *ScoreFont, *HighScoreFont;
X
XPixel colors[NUM_PIECES];
X
XPixel green;
XPixel yellow;
XPixel black;
XPixel white;
X
Xvoid Init_Jewel()
X	{
X	XGCValues gcv;
X	unsigned long gcvm=(GCGraphicsExposures | GCForeground | GCBackground);
X
X	green=xw_alloc_color("green");
X	yellow=xw_alloc_color("yellow");
X	black=BlackPixel(xw_display,xw_screen);
X	white=WhitePixel(xw_display,xw_screen);
X
X	gcv.graphics_exposures=False;
X	gcv.background=black;
X
X	/* Logo */
X	gcv.foreground=green;
X	LogoGC=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	LogoPM=XCreateBitmapFromData(xw_display, xw_window,
X			jewellogo_bits, jewellogo_width, jewellogo_height);
X	XSetClipMask(xw_display,LogoGC,LogoPM);
X
X	gcv.foreground=white;
X	Logo2GC=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	Logo2PM=XCreateBitmapFromData(xw_display, xw_window,
X			jewellogo2_bits, jewellogo2_width, jewellogo2_height);
X
X	/* border */
X	gcv.foreground=white;
X	BorderGC=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	BorderPM=XCreateBitmapFromData(xw_display, xw_window, border_bits, 
X			border_width, border_height);
X
X	/* Pieces */
X	colors[WILD_PIECE]=xw_alloc_color(WILD_C);
X	gcv.foreground=colors[WILD_PIECE];
X	PiecesGC[WILD_PIECE]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[WILD_PIECE]=XCreateBitmapFromData(xw_display, xw_window,
X			jewel_bits, jewel_width, jewel_height);
X
X	colors[PIECE1]=xw_alloc_color(PIECE1_C);
X	gcv.foreground=colors[PIECE1];
X	PiecesGC[PIECE1]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[PIECE1]=XCreateBitmapFromData(xw_display, xw_window,
X			piece1_bits, piece1_width, piece1_height);
X
X	colors[PIECE2]=xw_alloc_color(PIECE2_C);
X	gcv.foreground=colors[PIECE2];
X	PiecesGC[PIECE2]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[PIECE2]=XCreateBitmapFromData(xw_display, xw_window,
X			piece2_bits, piece2_width, piece2_height);
X
X	colors[PIECE3]=xw_alloc_color(PIECE3_C);
X	gcv.foreground=colors[PIECE3];
X	PiecesGC[PIECE3]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[PIECE3]=XCreateBitmapFromData(xw_display, xw_window,
X			piece3_bits, piece3_width, piece3_height);
X
X	colors[PIECE4]=xw_alloc_color(PIECE4_C);
X	gcv.foreground=colors[PIECE4];
X	PiecesGC[PIECE4]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[PIECE4]=XCreateBitmapFromData(xw_display, xw_window,
X			piece4_bits, piece4_width, piece4_height);
X
X	colors[PIECE5]=xw_alloc_color(PIECE5_C);
X	gcv.foreground=colors[PIECE5];
X	PiecesGC[PIECE5]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[PIECE5]=XCreateBitmapFromData(xw_display, xw_window,
X			piece5_bits, piece5_width, piece5_height);
X
X	colors[PIECE6]=xw_alloc_color(PIECE6_C);
X	gcv.foreground=colors[PIECE6];
X	PiecesGC[PIECE6]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[PIECE6]=XCreateBitmapFromData(xw_display, xw_window,
X			piece6_bits, piece6_width, piece6_height);
X
X	/* Flash pieces */
X	colors[FLASH1]=xw_alloc_color(FLASH_C);
X	gcv.foreground=colors[FLASH1];
X	PiecesGC[FLASH1]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[FLASH1]=XCreateBitmapFromData(xw_display, xw_window,
X			flash1_bits, flash1_width, flash1_height);
X
X	colors[FLASH2]=colors[FLASH1];
X	PiecesGC[FLASH2]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[FLASH2]=XCreateBitmapFromData(xw_display, xw_window,
X			flash2_bits, flash2_width, flash2_height);
X
X	colors[FLASH3]=colors[FLASH1];
X	PiecesGC[FLASH3]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[FLASH3]=XCreateBitmapFromData(xw_display, xw_window,
X			flash3_bits, flash3_width, flash3_height);
X
X	colors[FLASH4]=colors[FLASH1];
X	PiecesGC[FLASH4]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[FLASH4]=XCreateBitmapFromData(xw_display, xw_window,
X			flash4_bits, flash4_width, flash4_height);
X
X	/* Backdrops */
X	colors[BACKGND1]=xw_alloc_color(BACKGND_C);
X	gcv.foreground=colors[BACKGND1];
X	PiecesGC[BACKGND1]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[BACKGND1]=XCreateBitmapFromData(xw_display, xw_window,
X			back1_bits, back1_width, back1_height);
X
X	colors[BACKGND2]=colors[BACKGND1];
X	PiecesGC[BACKGND2]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[BACKGND2]=XCreateBitmapFromData(xw_display, xw_window,
X			back2_bits, back2_width, back2_height);
X
X	colors[BACKGND3]=colors[BACKGND1];
X	PiecesGC[BACKGND3]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[BACKGND3]=XCreateBitmapFromData(xw_display, xw_window,
X			back3_bits, back3_width, back3_height);
X
X	colors[BACKGND4]=colors[BACKGND1];
X	PiecesGC[BACKGND4]=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	PiecesPM[BACKGND4]=XCreateBitmapFromData(xw_display, xw_window,
X			back4_bits, back4_width, back4_height);
X
X	/* fonts */
X	gcvm|=GCFont;
X
X	if ( (VerFont=XLoadQueryFont(xw_display,VER_FONT)) == NULL)
X		{ xw_fatal("Cannot load VERSION font.\n",__LINE__,__FILE__); }
X	gcv.font=VerFont->fid;
X	gcv.foreground=white;
X	VerGC=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X
X	if ( (HighScoreFont=XLoadQueryFont(xw_display,HIGHSC_FONT)) == NULL)
X		{ xw_fatal("Cannot load HIGHSCORE font.\n",__LINE__,__FILE__); }
X	gcv.foreground=white;
X	gcv.font=HighScoreFont->fid;
X	HighScoreGC=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X
X	if ( (ScoreFont=XLoadQueryFont(xw_display,SCORE_FONT)) == NULL)
X		{
X		if ( (ScoreFont=XLoadQueryFont(xw_display,ALT_SC_FONT)) == NULL)
X			{ xw_fatal("Cannot load SCORE font.\n",__LINE__,__FILE__); }
X		}
X	gcv.foreground=white;
X	gcv.font=ScoreFont->fid;
X	ScoreGC=XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	Score_Char_MHeight=(ScoreFont->ascent + ScoreFont->descent)*3/2;
X	Score_x_right=SCORE_LOC_X + (ScoreFont->max_bounds.width*SCORE_WIDTH);
X	}
X
X
X
Xint main(argc,argv)
Xint argc;
Xchar **argv;
X	{
X	XKeyboardControl Values;
X	struct timeval curtime;
X
X	gettimeofday(&curtime,NULL);
X	srandom((unsigned int)(curtime.tv_usec>>8));
X
X	JewelState=NULL_STATE;
X
X	xw_init(argc,argv,SCREEN_X, SCREEN_Y);
X
X	Init_Jewel();
X
X	Values.bell_duration=50;
X	XChangeKeyboardControl(xw_display,KBBellDuration, &Values);
X	xw_start();
X	Init_Draw_High_Scores();
X	Init_Intro();
X	Init_Help();
X
X	xw_main_loop();
X	XCloseDisplay(xw_display);
X	exit(0);
X	}
END_OF_FILE
if test 12508 -ne `wc -c <'jewel.c'`; then
    echo shar: \"'jewel.c'\" unpacked with wrong size!
fi
# end of 'jewel.c'
fi
if test -f 'logic.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'logic.c'\"
else
echo shar: Extracting \"'logic.c'\" \(9600 characters\)
sed "s/^X//" >'logic.c' <<'END_OF_FILE'
X/*
X**
X**	X11 Jewel By David Cooper and Jose Guterman 05/92
X**
X*/
X
X#include <stdio.h>
X#include <stdlib.h>
X
X#include "general.h"
X#include "logic.h"
X#include "panel.h"
X#include "game.h"
X
Xint board[NUM_COLS][NUM_ROWS];
Xint curr_block[BLOCK_SIZE];
Xint next_block[BLOCK_SIZE];
Xint background = BACKGND1;
Xint curr_block_x, curr_block_y;
XBOOL moving_block = FALSE;
Xstruct rem_piece p_remov[NUM_COLS*NUM_ROWS];
Xint index_rem;
X
Xvoid Redraw_Board()
X	{
X	int i, j;
X
X	for (i=0; i<NUM_COLS; i++)
X		for (j=0; j<NUM_ROWS; j++)
X			Draw_Piece(board[i][j], i, j);
X
X	for(i=0; i<BLOCK_SIZE; i++)
X		{
X		Draw_Piece(next_block[i], -1, i);
X		}
X	}
X
Xvoid Get_Random_Block(block)
Xint *block;
X	{
X	int i;
X
X	if ((random() % AVG_BLOCKS_BETWEEN_JEWELS) == 0) /* time for a jewel? */
X		{
X		for (i=0; i<BLOCK_SIZE; i++)
X			{
X			block[i] = WILD_PIECE;
X			}
X		}
X	else
X		{
X		for (i=0; i<BLOCK_SIZE; i++)
X			{
X			block[i] = (random() % NUM_REAL_PIECES);
X			}
X		}
X	}
X
Xint Get_New_Background(old_background)
Xint old_background;
X	{
X	int bgnd;
X
X	/* Random Background */
X/*
X	while ((bgnd = ((random() % NUM_BACKGND) + BACKGND1)) == old_background)
X		{}
X*/
X
X	/* Rotate Backgrounds */
X	bgnd = old_background+1;
X	if (bgnd >= BACKGND1 + NUM_BACKGND)
X		{
X		bgnd = BACKGND1;
X		}
X	
X	return(bgnd);
X	}
X
Xvoid Clear_Board()
X	{
X	int i, j;
X
X	for (i=0; i<NUM_COLS; i++)
X		for (j=0; j<NUM_ROWS; j++)
X			{
X			board[i][j]=background;
X			}
X	}
X
XUpdate_Board(piece, x, y)
Xint piece, x, y;
X	{
X	board[x][y] = piece;
X	Draw_Piece(piece, x, y);
X	}
X
Xvoid Init_Logic()
X	{
X	/* Initialize the board to be empty */
X	background = Get_New_Background(BACKGND1);
X	Clear_Board();
X
X	/* Prepare for the firs block */
X	Get_Random_Block(next_block);
X	moving_block = FALSE;
X	curr_block_x = NUM_COLS/2;
X	curr_block_y = 0;
X	}
X
Xvoid Clear_Remove_List()
X	{
X	index_rem = 0;
X	}
X
Xvoid Add_To_Remove_List(x, y, piece)
Xint piece, x, y;
X	{
X	p_remov[index_rem].x = x;
X	p_remov[index_rem].y = y;
X	p_remov[index_rem].piece = piece;
X	index_rem++;
X	}
X
Xvoid Handle_Horiz_Line(i, j, in_line)
Xint i, j, in_line;
X	{
X	int k;
X
X	for (k=0; k<in_line; k++)
X		{
X		Add_To_Remove_List(j-k-1, i, board[j-1][i]);
X		}
X	}
X
Xvoid Handle_Vert_Line(i, j, in_line)
Xint i, j, in_line;
X	{
X	int k;
X
X	for (k=0; k<in_line; k++)
X		{
X		Add_To_Remove_List(i, j-k-1, board[i][j-1]);
X		}
X	}
X
X
Xvoid Handle_DiagR_Line(i, j, in_line)
Xint i, j, in_line;
X	{
X	int k;
X
X	for (k=0; k<in_line; k++)
X		{
X		Add_To_Remove_List(j-k-1, i-k-1, board[j-k-1][i-k-1]);
X		}
X	}
X
X
Xvoid Handle_DiagL_Line(i, j, in_line)
Xint i, j, in_line;
X	{
X	int k;
X
X	for (k=0; k<in_line; k++)
X		{
X		Add_To_Remove_List(j+k+1, i-k-1, board[j+k+1][i-k-1]);
X		}
X	}
X
Xint Check_Board()
X	{
X	int add_score;
X	int i, j, k, l;
X	int in_line;
X	int piece_checked;
X
X	add_score = 0;
X	Clear_Remove_List();
X
X	/* Check Horizontal */
X	for (i=0; i<NUM_ROWS; i++)
X		{
X		in_line = 1;
X		piece_checked = background;
X		for (j=0; j<NUM_COLS; j++)
X			{
X			if (TEST_PIECE(board[j][i]) && (board[j][i] == piece_checked))
X				{
X				in_line++;
X				}
X			else
X				{
X				piece_checked = board[j][i];
X				if (in_line > 2)
X					{
X					add_score = add_score + POINTS(in_line);
X					Handle_Horiz_Line(i,j,in_line);
X					}
X				in_line = 1;
X				}
X			}
X
X		if (in_line > 2)
X			{
X			add_score = add_score + POINTS(in_line);
X			Handle_Horiz_Line(i,j,in_line);
X			}
X		}
X
X	/* Check Vertical */
X	for (i=0; i<NUM_COLS; i++)
X		{
X		in_line=1;
X		piece_checked=background;
X		for (j=0; j<NUM_ROWS; j++)
X			{
X			if (TEST_PIECE(board[i][j]) && (board[i][j] == piece_checked))
X				{
X				in_line++;
X				}
X			else
X				{
X				piece_checked = board[i][j];
X				if (in_line > 2)
X					{
X					add_score = add_score + POINTS(in_line);
X					Handle_Vert_Line(i,j,in_line);
X					}
X				in_line = 1;
X				}
X			}
X
X		if (in_line > 2)
X			{
X			add_score = add_score + POINTS(in_line);
X			Handle_Vert_Line(i,j,in_line);
X			}
X		}
X
X	/* Check Diagonal Right */
X	k=NUM_COLS-2;
X	l=0;
X	while (l<(NUM_ROWS-2))
X		{
X		i=l;
X		j=k;
X		in_line=1;
X		piece_checked=background;
X		while((i<NUM_ROWS) && (j<NUM_COLS))
X			{
X			if (TEST_PIECE(board[j][i]) && (board[j][i] == piece_checked))
X				{
X				in_line++;
X				}
X			else
X				{
X				piece_checked = board[j][i];
X				if (in_line > 2)
X					{
X					add_score = add_score + POINTS(in_line);
X					Handle_DiagR_Line(i,j,in_line);
X					}
X				in_line = 1;
X				}
X			i++;
X			j++;
X			}
X
X		if (in_line > 2)
X			{
X			add_score = add_score + POINTS(in_line);
X			Handle_DiagR_Line(i,j,in_line);
X			}
X
X		if (k>0)
X			{
X			k--;
X			}
X		else
X			{
X			l++;
X			}
X		}
X
X	/* Check Diagonal Left */
X	k=3;
X	l=0;
X	while (l<(NUM_ROWS-2))
X		{
X		i=l;
X		j=k;
X		in_line=1;
X		piece_checked=background;
X		while((i<NUM_ROWS) && (j>=0))
X			{
X			if (TEST_PIECE(board[j][i]) && (board[j][i] == piece_checked))
X				{
X				in_line++;
X				}
X			else
X				{
X				piece_checked = board[j][i];
X				if (in_line > 2)
X					{
X					add_score = add_score + POINTS(in_line);
X					Handle_DiagL_Line(i,j,in_line);
X					}
X				in_line = 1;
X				}
X			i++;
X			j--;
X			}
X
X		if (in_line > 2)
X			{
X			add_score = add_score + POINTS(in_line);
X			Handle_DiagL_Line(i,j,in_line);
X			}
X
X		if (k<(NUM_COLS-1))
X			{
X			k++;
X			}
X		else
X			{
X			l++;
X			}
X		}
X
X	return(add_score);
X	}
X
Xint Remove_Flash()
X	{
X	int index;
X
X	for (index=0; index<index_rem; index++)
X		{
X		if (board[p_remov[index].x][p_remov[index].y] == FLASH1)
X			{
X			p_remov[index].x = p_remov[index_rem-1].x;
X			p_remov[index].y = p_remov[index_rem-1].y;
X			p_remov[index].piece = p_remov[index_rem-1].piece;
X			index_rem--;
X			index--;
X			}
X		else
X			{
X			board[p_remov[index].x][p_remov[index].y] = FLASH1;
X			}
X		}
X
X	Flash_Pieces(p_remov, index_rem, background);
X	}
X
Xvoid Drop_Down_After_Flash()
X	{
X	int i, j, k;
X
X	for (i=0; i<NUM_COLS; i++)
X		for (j=0; j<NUM_ROWS; j++)
X			{
X			if (board[i][j] == FLASH1)
X				{
X				for (k=j-1; k>=0; k--)
X					{
X					Update_Board(board[i][k], i, k+1);
X					}
X				Update_Board(background, i, 0);
X				}
X			}
X	}
X
Xvoid Redraw_Background()
X	{
X	int i, j;
X
X	for (i=0; i<NUM_COLS; i++)
X		for (j=0; j<NUM_ROWS; j++)
X			if (!TEST_PIECE(board[i][j])) 
X				{
X				Update_Board(background, i, j);
X				}
X	}
X
Xvoid Update_Rest(num_pieces)
Xint num_pieces;
X	{
X	if (Dec_Rest(num_pieces))
X		{
X		background = Get_New_Background(background);
X		Redraw_Background();
X		}
X	}
X
Xvoid Process_Block(special, piece)
XBOOL special;
Xint piece;
X	{
X	int i, j;
X	int add_score;
X	
X	if (special)
X		{
X		Clear_Remove_List();
X		for (i=0; i<NUM_COLS; i++)
X			for (j=0; j<NUM_ROWS; j++)
X				if ((board[i][j] == WILD_PIECE) ||
X					((board[i][j] == piece) && TEST_PIECE(board[i][j])))
X					{
X					Add_To_Remove_List(i, j, board[i][j]);
X					}
X
X		Remove_Flash();
X		Drop_Down_After_Flash();
X		Add_Score(JEWELSCORE, 1);
X		Update_Rest(index_rem);
X		}
X
X	i = 1;
X	while ((add_score = Check_Board()) > 0)
X		{
X		Remove_Flash();
X		Drop_Down_After_Flash();
X		Add_Score(add_score, i);
X		Update_Rest(index_rem);
X		i++;
X		}
X
X	if (TEST_PIECE(board[NUM_COLS/2][BLOCK_SIZE-1]))
X		{
X		Melt_Down();
X		Clear_Board();
X		Redraw_Board();
X		Dec_Lives();
X		}
X	}
X
Xvoid Move_Right()
X	{
X	int i;
X
X	if (!moving_block) 
X		{
X		return;
X		}
X
X	if (curr_block_x < (NUM_COLS-1))
X		{
X		for (i=0; i<BLOCK_SIZE; i++)
X			{
X			if (TEST_PIECE(board[curr_block_x+1][curr_block_y+i]))
X				{
X				return;
X				}
X			}
X
X		curr_block_x++;
X		for (i=0; i<BLOCK_SIZE; i++)
X			{
X			Update_Board(curr_block[i], curr_block_x, curr_block_y+i);
X			Update_Board(background, curr_block_x-1, curr_block_y+i);
X			}
X
X		Key_Bell();
X		}
X	}
X
Xvoid Move_Left()
X	{
X	int i;
X	if (!moving_block)
X		{
X		return;
X		}
X
X	if (curr_block_x > 0)
X		{
X		for (i=0; i<BLOCK_SIZE; i++)
X			{
X			if (TEST_PIECE(board[curr_block_x-1][curr_block_y+i]))
X				{
X				return;
X				}
X			}
X
X		curr_block_x--;
X		for (i=0; i<BLOCK_SIZE; i++)
X			{
X			Update_Board(curr_block[i], curr_block_x, curr_block_y+i);
X			Update_Board(background, curr_block_x+1, curr_block_y+i);
X			}
X
X		Key_Bell();
X		}
X	}
X
Xvoid Move_Down()
X	{
X	int i;
X
X	if ((curr_block_y == (NUM_ROWS - BLOCK_SIZE)) ||
X		(TEST_PIECE(board[curr_block_x][curr_block_y+BLOCK_SIZE])))
X		{
X		moving_block = FALSE;
X		if (curr_block[0] == WILD_PIECE)
X			{
X			if (curr_block_y == NUM_ROWS-BLOCK_SIZE)
X				{
X				Process_Block(TRUE, background);
X				}
X			else
X				{
X				Process_Block(TRUE,
X					board[curr_block_x][curr_block_y+BLOCK_SIZE]);
X				}
X			}
X		else
X			{
X			Process_Block(FALSE, NULL);
X			}
X		}
X	else
X		{
X		for (i=0; i<BLOCK_SIZE; i++)
X			{
X			Update_Board(curr_block[i], curr_block_x, curr_block_y+i+1);
X			}
X		Update_Board(background, curr_block_x, curr_block_y);
X		curr_block_y++;
X		}
X	}
X
Xvoid Drop()
X	{
X	int cycles=(-1);
X	int i,j;
X	if (!moving_block)
X		{
X		return;
X		}
X
X	Key_Bell();
X	/* we have to find the number of steps it falls here
X	   so we can show the points first */
X	i=curr_block_x;
X	j=curr_block_y+BLOCK_SIZE;
X
X	while (j<NUM_ROWS)
X		{
X		if (TEST_PIECE(board[i][j]))
X			{
X			break;
X			}
X		cycles++;
X		j++;
X		}
X	if (cycles>0)
X		{
X		Add_Raw_Score(DROP_POINTS, cycles);
X		}
X
X	while(moving_block)
X		{
X		Move_Down();
X		}
X	}
X
Xvoid Rotate()
X	{
X	int i;
X	int tmp_block=curr_block[BLOCK_SIZE-1];
X	if (!moving_block) return;
X	for (i=BLOCK_SIZE-1; i>0; i--)
X		{
X		curr_block[i]=curr_block[i-1];
X		Update_Board(curr_block[i], curr_block_x, curr_block_y+i);
X		}
X	curr_block[0]=tmp_block;
X	Update_Board(curr_block[0], curr_block_x, curr_block_y);
X	Key_Bell();
X	}
X
Xvoid Logic_Timeout()
X	{
X	int i;
X
X	if (!moving_block)
X		{
X		curr_block_x = NUM_COLS/2;
X		curr_block_y = 0;
X
X		for (i=0; i<BLOCK_SIZE; i++)
X			{
X			curr_block[i] = next_block[i];
X			Update_Board(curr_block[i], curr_block_x, curr_block_y+i);
X			}
X
X		Get_Random_Block(next_block);
X		for(i=0; i<BLOCK_SIZE; i++)
X			{
X			Draw_Piece(next_block[i], -1, i);
X			}
X		moving_block = TRUE;
X		}
X	else
X		{
X		Move_Down();
X		}
X	}
END_OF_FILE
if test 9600 -ne `wc -c <'logic.c'`; then
    echo shar: \"'logic.c'\" unpacked with wrong size!
fi
# end of 'logic.c'
fi
if test -f 'make.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make.com'\"
else
echo shar: Extracting \"'make.com'\" \(1688 characters\)
sed "s/^X//" >'make.com' <<'END_OF_FILE'
X$! See imakefile. for information about options				      !
X$ HSCORE_FILE = F$TRNLNM("SYS$DISK") + F$DIRECTORY() + "xjewel.scores"
X$ defs:=DECWM,ICON_WINDOW,""""HSCORE_FILE=""""""'HSCORE_FILE'"""""" """"
X$ write sys$output "HIGH SCORE FILE IS:",HSCORE_FILE
X$ write sys$output "BUILDING JEWEL..."
X$ write sys$output " game"
X$ cc GAME.C /define=('defs')
X$ write sys$output " help"
X$ cc HELP.C /define=('defs')
X$ write sys$output " hscore"
X$ cc HSCORE.C /define=('defs')
X$ write sys$output " intro"
X$ cc INTRO.C /define=('defs')
X$ write sys$output " jewel"
X$ cc JEWEL.C /define=('defs')
X$ write sys$output " logic"
X$ cc LOGIC.C /define=('defs')
X$ write sys$output " panel"
X$ cc PANEL.C /define=('defs')
X$ write sys$output " vmsstubs"
X$ cc VMSSTUBS.C /define=('defs')
X$ write sys$output " xhscore"
X$ cc XHSCORE.C /define=('defs')
X$ write sys$output " xw"
X$ cc XW.C /define=('defs')
X$ write sys$output "LINKING..."
X$ link /EXEC=XJEWEL JEWEL.OBJ,GAME.OBJ,HELP.OBJ,HSCORE.OBJ,INTRO.OBJ, -
XLOGIC.OBJ,PANEL.OBJ,VMSSTUBS.OBJ,XHSCORE.OBJ,XW.OBJ, SYS$INPUT/opt
XSYS$LIBRARY:DECW$XLIBSHR.EXE/SHARE
XSYS$LIBRARY:VAXCRTL/LIBR
X$ xjewel := run xjewel.exe
X$ write sys$output "FONTS..."
X$ set def [.bitmaps]
X$ font seven_seg.bdf
X$ run sys$system:decw$mkfontdir
X$ set def [.-]
X$ fini:
X$ write sys$output "HELPFILE..."
X$ helpfile = F$TRNLNM("SYS$DISK") + F$DIRECTORY() + "xjewel.hlb"
X$ if (F$SEARCH(helpfile) .nes. "") then  delete /nolog/nocon 'helpfile';*
X$ lib/help/create/replace 'helpfile' xjewel.help 
X$ define/nolog HLP$LIBRARY 'helpfile'
X$ purge
X$ purge [.bitmaps]
X$ if (F$SEARCH(HSCORE_FILE) .nes "") then delete /nolog/nocon 'HSCORE_FILE';*
X$! xjewel will create a new score file with open permissions
END_OF_FILE
if test 1688 -ne `wc -c <'make.com'`; then
    echo shar: \"'make.com'\" unpacked with wrong size!
fi
# end of 'make.com'
fi
if test -f 'xhscore.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xhscore.c'\"
else
echo shar: Extracting \"'xhscore.c'\" \(5029 characters\)
sed "s/^X//" >'xhscore.c' <<'END_OF_FILE'
X/*
X**
X**	X11 Jewel By David Cooper and Jose Guterman 05/92
X**
X*/
X
X#include <stdio.h>
X
X#ifdef VMS
X#include <decw$include/Xlib.h>
X#include <decw$include/Xutil.h>
X#include <decw$include/Xos.h>
X#else
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#endif
X
X#include "general.h"
X#include "jewel.h"
X#include "xw.h"
X#include "xhscore.h"
X#include "hscore.h"
X
X#define HSCORE_X_START	75
X#define HSCORE_X_END	(SCREEN_X - HSCORE_X_START)
X#define HSCORE_X_SIZE (HSCORE_X_END - HSCORE_X_START)
X#define HSCORE_Y_START 100
X#define HSCORE_Y_SIZE	((HighScoreFont->ascent + HighScoreFont->descent)*3/2)
X#define ONE_HSCORE_START(x) (HSCORE_Y_START+(2+x)*HSCORE_Y_SIZE)
X#define ONE_HSCORE_TOP(x) (ONE_HSCORE_START(x)-HighScoreFont->ascent)
X
X#define HSCORE_AVG_WIDTH 14
X/* left */
X#define HSCORE_COL1 (HSCORE_X_START + (4 * (HSCORE_AVG_WIDTH)) )
X/* right */
X#define HSCORE_COL3 HSCORE_X_END
X/* center */
X#define HSCORE_COL2 (HSCORE_COL3 - (12 * (HSCORE_AVG_WIDTH)) )
X
X#include "bitmaps/skule.xbm"
X#include "bitmaps/skulemask.xbm"
X
XPixmap SkulePM;
XPixmap SkulemaskPM;
XGC SkuleGC;
X
XPixel red;
X
Xchar buf[50];
X
Xvoid Init_Draw_High_Scores()
X	{
X	XGCValues gcv;
X	unsigned long gcvm = (GCGraphicsExposures | GCForeground | GCBackground);
X
X	red = xw_alloc_color("red");
X
X	gcv.graphics_exposures = False;
X	gcv.background = black;
X    gcv.foreground = red;
X	SkuleGC = XCreateGC(xw_display, xw_window, gcvm, &gcv);
X	SkulePM = XCreateBitmapFromData(xw_display, xw_window,
X			skule_bits, skule_width, skule_height);
X	SkulemaskPM = XCreateBitmapFromData(xw_display, xw_window,
X			skulemask_bits, skulemask_width, skulemask_height);
X	/*
X	XSetClipMask(xw_display,SkuleGC,SkulemaskPM);
X	*/
X	}
X
Xvoid Draw_High_Score_Title()
X	{
X	XCharStruct Sizes;
X	int dir, asc, dsc;
X	int len;
X
X	sprintf(buf, "HIGH SCORES");
X	len=strlen(buf);
X	XTextExtents(HighScoreFont,buf,len,&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, HighScoreGC,
X		(SCREEN_X - Sizes.width)/2, HSCORE_Y_START, buf, len);
X	/* left */
X	sprintf(buf, "   Name");
X	len=strlen(buf);
X	XDrawImageString(xw_display, xw_window, HighScoreGC, HSCORE_COL1,
X		HSCORE_Y_START + 2*HSCORE_Y_SIZE, buf, len);
X	/* center */
X	sprintf(buf, "Stage");
X	len=strlen(buf);
X	XTextExtents(HighScoreFont,buf,len,&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, HighScoreGC,
X		HSCORE_COL2 - (Sizes.width/2),
X		HSCORE_Y_START + 2*HSCORE_Y_SIZE, buf, len);
X	/* right */
X	sprintf(buf, "Score");
X	len=strlen(buf);
X	XTextExtents(HighScoreFont,buf,len,&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, HighScoreGC,
X		HSCORE_COL3 - Sizes.width,
X		HSCORE_Y_START + 2*HSCORE_Y_SIZE, buf, len);
X	XFlush(xw_display);
X	}
X
Xvoid Draw_One_High_Score(i)
Xint i;
X	{
X	XCharStruct Sizes;
X	int dir, asc, dsc;
X	int len;
X
X	/* right */
X	sprintf(buf,"%d-",i);
X	len=strlen(buf);
X	XTextExtents(HighScoreFont,buf,len,&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, HighScoreGC,
X		HSCORE_COL1 - Sizes.width,
X		ONE_HSCORE_START(i), buf, len);
X	/* left */
X	sprintf(buf, " %.20s", high_scores[i-1].name);
X	len=strlen(buf);
X	XDrawImageString(xw_display, xw_window, HighScoreGC,
X		HSCORE_COL1,
X		ONE_HSCORE_START(i), buf, len);
X	/* center */
X	sprintf(buf, "%d", high_scores[i-1].stage);
X	len=strlen(buf);
X	XTextExtents(HighScoreFont,buf,len,&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, HighScoreGC,
X		HSCORE_COL2 - (Sizes.width/2),
X		HSCORE_Y_START + (2 + i)*HSCORE_Y_SIZE, buf, len);
X	/* right */
X	sprintf(buf, "%d", high_scores[i-1].score);
X	len=strlen(buf);
X	XTextExtents(HighScoreFont,buf,len,&dir,&asc,&dsc,&Sizes);
X	XDrawImageString(xw_display, xw_window, HighScoreGC,
X		HSCORE_COL3 - Sizes.width,
X		ONE_HSCORE_START(i), buf, len);
X	XFlush(xw_display);
X	}
X
X
Xvoid Show_High_Scores(start)
Xint start;
X	{
X	int i;
X
X	Draw_High_Score_Title();
X	for (i=start; i<=num_high_scores; i++)
X		{
X		Draw_One_High_Score(i);
X		}
X	XFlush(xw_display);
X	}
X
Xvoid Wipeout_Last_High_Score()
X	{
X	int i;
X
X	for (i=0; i<(HSCORE_X_SIZE - (HSCORE_COL1 - HSCORE_X_START)); i=i+3)
X		{
X		/*
X		XSetClipOrigin(xw_display, SkuleGC,
X			HSCORE_COL1+i, ONE_HSCORE_TOP(MAX_HIGH_SCORES));
X		*/
X		XCopyPlane(xw_display, SkulePM, xw_window, SkuleGC,
X			0, 0, skule_width, skule_height, HSCORE_COL1+i,
X			ONE_HSCORE_TOP(MAX_HIGH_SCORES), 1L);
X		xw_sync_sleep(50L);
X		}
X	}
X
Xvoid Move_Down_High_Scores(number)
Xint number;
X	{
X	int width, height;
X	int i;
X	/*
X	move area starting HSCORE_COL1, ONE_HSCORE_TOP(i)
X	ending   HSCORE_COL3, ONE_HSCORE_TOP(MAX_HIGH_SCORES)
X	down by HSCORE_Y_SIZE
X	*/
X	if (number < MAX_HIGH_SCORES)
X		{
X		width = HSCORE_COL3 - HSCORE_COL1; 
X		height = ONE_HSCORE_TOP(MAX_HIGH_SCORES) - ONE_HSCORE_TOP(number);
X		for (i=0; i<HSCORE_Y_SIZE; i++)
X			{
X			XCopyArea(xw_display, xw_window, xw_window, xw_gc, HSCORE_COL1,
X				ONE_HSCORE_TOP(number)+i, width, height,
X				HSCORE_COL1, ONE_HSCORE_TOP(number) + i + 1);
X			xw_sync_sleep(20L);
X			}
X		}
X	}
X
X
Xvoid Set_State_High_Score()
X	{
X	XClearWindow(xw_display, xw_window);
X
X	Refresh_High_Scores();
X
X	JewelState=HIGHSCORE;
X	xw_set_timer(10000L);
X	}
END_OF_FILE
if test 5029 -ne `wc -c <'xhscore.c'`; then
    echo shar: \"'xhscore.c'\" unpacked with wrong size!
fi
# end of 'xhscore.c'
fi
echo shar: End of archive 3 \(of 5\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
