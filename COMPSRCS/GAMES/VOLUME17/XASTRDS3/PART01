Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i034:  xasteroids3 - asteroids arcade game for X, Ver 5, Part01/01
Message-ID: <4575@master.CNA.TEK.COM>
Date: 16 Feb 93 23:38:34 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1316
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1713

Submitted-by: goetz@cs.Buffalo.EDU (Phil Goetz)
Posting-number: Volume 17, Issue 34
Archive-name: xasteroids3/Part01
Supersedes: xasteroids2: Volume 13, Issue 80
Environment: X11, Xlib

	[I added a simple Imakefile. Compiles and runs fine on a Sparc.  -br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  README MANIFEST Imakefile Makefile.std xast.c xast.docs
#   xast.man xasteroids
# Wrapped by billr@saab on Tue Feb 16 15:34:54 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(3060 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X     Here is the source to Xasteroids, version 5, 9 Feb 93.
X
X     This program runs under UNIX in the X-Windows or OpenWindows
Xenvironment.  It could probably be modified for other operating systems
Xwithout difficulty.  I compile it under quasi-BSD with this command:
X
X	cc -I/util/X11/include -L/util/X11/lib xast.c -lm -lX11 -o xast.exe -O
X
XThat is, include files /util/X11/include, use the library in /util/X11/lib,
Xsource file ast.c, use the math and X11 libraries, object file will be ast.out,
Xand Optimize.  The Makefile provided should do this for you if you type
X
X	make xast.exe
X
X     To run the program, type
X
X	xasteroids &
X
XThis runs the shell script which runs the game and saves high scores.
XYou should modify the first line of the shell script to move to the proper
Xdirectory.
X
X     Playing with scale of movement, object size, and window size can give you
Xvery different games.
X
X     If you like the game, please send $5 to
X
X	Phil Goetz
X	4023 Huckleberry Row
X	Ellicott City, MD 21043
X
X     Even if you don't register, please send a note to my e-mail address
Xso I know how many people use Xasteroids.
XSend any comments, suggestions, bug reports, modifications, etc., to
X
X	goetz@cs.buffalo.EDU
X
X     If you modify the game, feel free to post your version, PROVIDED that
Xyou retain my copyright notice, the credits, and note which version yours
Xwas derived from and its release date, what changes you made, and your
Xrelease date.  I do not intend to release any more versions myself.
XI wash my hands of it.
X
X     David Elliot (dce@sonyusa.sony.com) says that he had to put an
XXSync(disp) after the XDrawLines call or he would get protocol errors.
X
X     On anything slower than a SPARCstation 1, or on any color screen,
Xit will really drag.  There should be a way to set color screens to use
Xa bitmap of depth 1, but I don't know how.  Please tell me if you do.
X     The code is not optimized because the XWindows
Xcalls take the vast majority of the time.  I tried, for instance,
Xreading sines and cosines from a table instead of calculating them -
Xit made no noticeable difference in speed.  Similarly, the collision
Xdetection could be optimized only to check objects nearby - but why
Xbother.  Same goes for using registers, pointers to frequently-referenced
Xarray elements, etc.  It MIGHT make a significant difference in runtime
Xif you replace the vector drawing with bitmaps.  It runs a LOT slower on
Xcolor displays.
X     The vast majority of time seems to be used in erasing the pixmap
Xeach round, & there isn't much to do about that.  My tests have indicated
Xthat blanking individual asteroids rather than the whole screen would
Xtake comparable time, unless you had a complicated routine to optimize
Xblanking.
X
XBy
X	Phil Goetz	<goetz@cs.buffalo.edu>
XContributors:
X	Peter Phillips	<pphillip@cs.ubc.ca>
X	Pat Ryan	<pat@jaameri.gsfc.nasa.gov>
X	Craig Smith	<csmith@cscs.UUCP>
X	Doug Merritt	<doug@netcom.com>
X	James Berg	<berg@plains>		(makefile)
X	David Partain	<dlp@ida.liu.se>	(original man page)
X	Chris Moore	<moore@src.bae.co.uk>	(hi score script)
END_OF_FILE
if test 3060 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(362 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Imakefile                  1	
X MANIFEST                   1	This shipping list
X Makefile.std               1	
X README                     1	
X xast.c                     1	
X xast.docs                  1	
X xast.man                   1	
X xasteroids                 1	
END_OF_FILE
if test 362 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(253 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X# simple Imakefile for xasteroids
XSRCS = xast.c
XOBJS = xast.o
X
XEXTRA_LIBRARIES = -lX11 -lm
X
XSimpleProgramTarget(xast)
X#
X#   define dependencies
XDependTarget()
X#
X#   define installation rules
XInstallProgram(xast,$(BINDIR))
XInstallManPage(xast,$(MANDIR))
END_OF_FILE
if test 253 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'Makefile.std' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.std'\"
else
echo shar: Extracting \"'Makefile.std'\" \(488 characters\)
sed "s/^X//" >'Makefile.std' <<'END_OF_FILE'
X#CC = gcc -Wall
XCC = cc
XCFLAGS = -O
X#INCLUDES = -I/usr/local/include
XINCLUDES = -I/util/X11/include
X#LDFLAGS = -s -L/usr/local/lib
XLDFLAGS = -s -L/util/X11/lib
XLIBS = -lm -lX11
XTARGET = xast.exe
XSRCS = xast.c
XOBJS = xast.o 
XALL = README xasteroids xast.docs xast.man Makefile $(SRCS) 
X
Xall:	$(TARGET)
X
X$(TARGET):	$(OBJS)
X	$(CC) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
X
X.c.o:
X	$(CC) $(CFLAGS) $(INCLUDES) -c $*.c
X
Xclean:
X	rm -f $(OBJS) $(TARGET) core
X
Xshar:	$(ALL)
X	shar -o $(TARGET).shar $(ALL)
END_OF_FILE
if test 488 -ne `wc -c <'Makefile.std'`; then
    echo shar: \"'Makefile.std'\" unpacked with wrong size!
fi
# end of 'Makefile.std'
fi
if test -f 'xast.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xast.c'\"
else
echo shar: Extracting \"'xast.c'\" \(27746 characters\)
sed "s/^X//" >'xast.c' <<'END_OF_FILE'
X/*	Xasteroids
X	Copyright 1990 by Phil Goetz
X	goetz@cs.buffalo.EDU
X	Version 5, 9 Feb 93
X
X	Changes from version 4.3:
X
X		High score script.
X		Enemy moves towards you at higher levels.
X
X	Changes from version 3:
X
X		Better collision detection:  Actually checks for intersection
X			of line segments if non-round objects are very close.
X		Explosions!  (Thanks to Peter Phillips.)
X		Fine rotation repeating detected using KeyRelease.
X		Thrust indicator behind ship.  (Thanks to Peter Phillips.)
X		Doesn't place ship in center of screen for new levels.
X		Seeds random-number generator with time.
X			(Thanks to Craig Smith.)
X		Shields!  (Thanks to Peter Phillips.  I rewrote the bounce code
X			& added the energy bar & other refinements.)
X		Solved won't-take-input bug. (Thanks to Doug Merritt.)
X		Detects failure of XOpenDisplay. (Thanks to Pat Ryan.)
X
X	Contributors:	Peter Phillips <pphillip@cs.ubc.ca>
X			Pat Ryan <pat@jaameri.gsfc.nasa.gov>
X			Craig Smith <csmith@cscs.UUCP>
X			Doug Merritt <doug@netcom.com>
X			Makefile by James Berg <berg@plains>
X			Hi score script by Chris Moore <moore@src.bae.co.uk>
X			Man page by David Partain <dpl@ida.liu.se>
X*/
X#include <stdio.h>		/* For NULL	*/
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/cursorfont.h>	/* For erasing cursor - not important	*/
X#include <math.h>
X
X/* Indexes for 1st dimension of obj	*/
X/* The order they are in is important	*/
X#define	AST	0
X#define	ENEMY	96
X#define ENEMYBUL 97
X#define	FBUL	98
X#define	LASTBUL	102
X#define	SHIP	103
X#define LASTOBJ 103	/* Must be ship!  See makeasts().	*/
X
X/* Shapes	*/
X/* Order is important!  See collide().	*/
X#define	ASTSHAPE1	0
X#define ASTSHAPE2	1
X#define ASTSHAPE3	2
X#define ENBULSH		3
X#define	BULSHAPE	4
X#define	SHIPSHAPE	5
X#define SHIPTHRSHAPE	6
X#define	ENEMYSHAPE	7
X#define LASTSHAPE	7
X
X/* Masses	*/
X#define M_BIG	8.0
X#define M_MED	4.0
X#define M_SMALL	1.0
X#define M_SHIP	1.5
X#define M_ENEMY	1.0
X#define M_BULLET 0.1
X
X/* Keys		*/
X#define FIRE		'p'
X#define PAUSE		27	/* escape	*/
X#define SHIELD		'`'
X#define THRUST		'o'
X
X#define BMAX		300	/* Max particles in a "boom" + 1	*/
X#define letheight	20	/* height of font	*/
X#define	pi		3.1415926535897932384
X#define SHIPSIZE	28
X
Xtypedef struct _Boom *Boom;
Xstruct _Boom {Boom next; int dur, part; double bcoord[BMAX][2], bvec[BMAX][2];};
Xtypedef struct {int shape, alive, time;
X		double mass, x, y, xvel, yvel, rot, rotvel;} Objtype;
Xtypedef struct {double angle; int length;} PolarPair;
Xtypedef struct {double x, y, mag;} Vector;
X
X/* Global variables:	*/
XObjtype	obj[SHIP+1];
X/*	In shapes pairs, 1st # is radians, 2nd is length in pixels.
X	Degrees: 0 ->, pi/2 down, pi <-, 3*pi/2 up
X	IF YOU CHANGE THE SHAPES, you MUST change numpairs & shapesize
X*/
XPolarPair shapes[LASTSHAPE+1][11] =
X	{	{{0,0}, {3*pi/2,40}, {0,20}, {pi/4,28}, {pi/2,40}, /* just crossed 0-deg line */
X		 {3*pi/4,28},{pi,40},{5*pi/4,28},{3*pi/2,40},{7*pi/4,28},{0,20}},
X/*	hexagon if you prefer
X		{{0,0}, {3*pi/2, 20}, {pi/6, 20}, {pi/2, 20},
X                 {5*pi/6, 20}, {7*pi/6, 20}, {3*pi/2, 20}, {11*pi/6, 20}},
X*/
X		{{0,0}, {3*pi/2,20}, {0,10}, {pi/4,14}, {pi/2,20},
X		 {3*pi/4,14},{pi,20},{5*pi/4,14},{3*pi/2,20},{7*pi/4,14},{0,10}},
X		{{0,0}, {3*pi/2,10}, {0,5}, {pi/4,7}, {pi/2,10},
X		 {3*pi/4,7},{pi,10},{5*pi/4,7},{3*pi/2,10},{7*pi/4,7},{0,5}},
X		{{0,0}, {7*pi/4, 4}, {pi/4, 4}, {3*pi/4, 4}, {5*pi/4, 4}},
X		{{0,0}, {0,10}},
X		{{0,0}, {5*pi/4,28}, {0,20}, {pi/4,28},{3*pi/4,28},{pi,20},{7*pi/4,28}},	/* Ship */
X		{{0,0}, {5*pi/4,28}, {0,20}, {pi/4,28},{3*pi/4,28},{pi,20},
X		 {7*pi/4,28}, {3*pi/4, 7}, {9*pi/8, 13}, {15*pi/8, 13}},	/* Thrusting ship */
X		{{0,0}, {pi,20},{7*pi/4,28},{pi/4,28},{pi,20}}
X	};
XBoom	blist = NULL;
Xdouble	drawscale = 1, speedscale = 1;
Xint	width, height,
X	energy,		/* # of turns shield is good for	*/
X	highscore = 0, level,
X	nextbul = FBUL,			/* Obj# of next bullet fired	*/
X	numasts, oldscore = 99,
X	rndint = 73, ships, score,
X	numpairs[LASTSHAPE+1]	= {11, 11, 11, 5, 2, 7, 10, 5},
X	shapesize[LASTSHAPE+1]	= {44, 21, 10, 2, 1, SHIPSIZE+1, 35, 20},
X	shield_on;
X
Xinitasts()
X{	int i;
X	extern Objtype obj[SHIP+1];
X
X	for (i = 0; i < LASTOBJ+1; i++)
X	{	obj[i].rot = 0;
X		obj[i].rotvel = 0;
X	}
X	for (i = 0; i < ENEMY; i++)
X	{	obj[i].shape = ASTSHAPE1;
X	}
X	obj[SHIP].shape = SHIPSHAPE;
X	obj[SHIP].mass = M_SHIP;
X	obj[ENEMY].shape = ENEMYSHAPE;
X	obj[ENEMY].mass = M_ENEMY;
X	obj[ENEMYBUL].shape = ENBULSH;
X	obj[ENEMYBUL].mass = M_BULLET;
X	for (i = FBUL; i < LASTBUL+1; i++)
X	{	obj[i].shape = BULSHAPE;
X		obj[i].mass = M_BULLET;
X}	}
X
Xmakeasts()
X{	int i;
X	extern Objtype obj[SHIP+1];
X	extern int level, numasts, rndint;
X	extern double speedscale;
X	unsigned char a;
X
X	for (i = 0; i < SHIP; i++)
X		obj[i].alive = 0; /* Erase objs from last level except ship */
X	for (i = ENEMYBUL; i < LASTBUL+1; i++)
X		obj[i].time = 0;		/* No bullets in the air */
X	for (i = 0; i < ((level > 8) ? 8 : level+4); i++)	/* Asteroids:	*/
X	{	a = rand(rndint); a>>=1;	/* a = rand# from 0 to 127 */
X		if (a > 63)
X			obj[i].x = (double) a;
X			else obj[i].x = (double) (width - a);
X		a = rand(rndint); a>>=1;	/* Now the same for y	*/
X		if (a >  63)
X			obj[i].y = (double) a;
X			else obj[i].y = (double) height - a;
X		a = rand(rndint); a = 4 - a>>5;
X		obj[i].rot = (double) a;
X		a = rand(rndint);
X		obj[i].rotvel = ((double) a)/2048;
X		a = rand(rndint);
X		obj[i].xvel = cos((double) a);
X		obj[i].yvel = sin((double) a);
X		obj[i].shape = ASTSHAPE1;
X		obj[i].mass = M_BIG;
X		obj[i].alive = 1;
X	}
X	numasts = i;
X}
X
Xmakeenemy()	/* Start an enemy ship	*/
X{	extern Objtype obj[SHIP+1];
X	extern int height, level, rndint;
X	unsigned char c;
X
X	obj[ENEMY].alive = 1;
X	obj[ENEMY].x = 0;
X	obj[ENEMY].y = (double) height/4;
X	c = rand(rndint); obj[ENEMY].y += (double) c; /* May put enemy outside window	*/
X	obj[ENEMY].xvel = .4 + ((double) level)/3.;
X	obj[ENEMY].yvel = 0;
X	obj[ENEMY].rot = 0;
X	obj[ENEMY].rotvel = 0;
X}
X
Xint nextast()	/* Find next unused asteroid object	*/
X{	extern Objtype obj[SHIP+1];
X	int i;
X	for (i = 0; obj[i].alive; i++);	/* guaranteed to find one	*/
X	return i;
X}
X
Xint collide(i, j)	/* Returns non-zero if i collided with j	*/
X			/* Ship must be j!  (See below)			*/
X	int i, j;
X{	extern Objtype obj[SHIP+1];
X	extern int shapesize[LASTSHAPE+1];
X	extern double drawscale;
X	double	mi, mj,				/* Slopes of lines	*/
X		ix1, ix2, iy1, iy2, jx1, jx2, jy1, jy2,	/* Endpoints	*/
X		roti, rotj,
X		xcross,	ycross,		/* coord of intersection	*/
X		z;
X	int	diff, xd, yd,
X		a, b,
X		shapei, shapej;
X	xd = obj[i].x - obj[j].x;
X	yd = obj[i].y - obj[j].y;
X	diff = sqrt((double)(xd*xd + yd*yd));
X	shapei = obj[i].shape; shapej = obj[j].shape;
X	/* Note this will miss if drawscale is < 0	*/
X	if (diff < (shapesize[shapei] + shapesize[shapej])*drawscale)
X	{   /* If both are round objects, approximation is good */
X	    if (shapei < SHIPSHAPE && shapej < SHIPSHAPE) return 1;
X	    if (j == SHIP && shield_on) return 1;	/* Ship always j! */
X	    roti = obj[i].rot; rotj = obj[j].rot;
X	    ix1 = (double) obj[i].x; iy1 = (double) obj[i].y;
X	    for (a = 1; a < numpairs[shapei]; a++)
X	    {	ix2 = ix1 + (double) shapes[shapei][a].length * drawscale *
X			cos(shapes[shapei][a].angle + roti);
X		iy2 = iy1 + (double) shapes[shapei][a].length * drawscale *
X			sin(shapes[shapei][a].angle + roti);
X		if (ix1 == ix2)
X		{	printf("\nif1 = if2"); return 1;} /* Easy way out */
X		mi = (iy2-iy1)/(ix2-ix1);
X		z = mi*ix1;
X		jx1 = (double) obj[j].x; jy1 = (double) obj[j].y;
X		for (b = 1; b < numpairs[shapej]; b++)
X		{	jx2 = jx1 + (double) shapes[shapej][b].length *
X				drawscale * cos(shapes[shapej][b].angle + rotj);
X			jy2 = jy1 + (double) shapes[shapej][b].length *
X				drawscale * sin(shapes[shapej][b].angle + rotj);
X			if (jx1 == jx2)
X			{	ycross = ix1 + (jx1-ix1)*mi;
X				if ((jx1-ix1) * (ix2-jx1) >= 0 &&
X					(ycross-jy1)*(jy2-ycross) >= 0)
X					return 1;
X				else jx2 += .0001;	/* Avoid divide by 0 */
X			}
X			mj = (jy2-jy1)/(jx2-jx1);
X			if (mj == mi) goto Loopend;	/* Parallel lines */
X			xcross = (iy1 - jy1 + mj*jx1 - z) / (mj - mi);
X			if ((xcross-ix1) * (ix2-xcross) > 0
X				&& (xcross-jx1) * (jx2-xcross) > 0) return 1;
XLoopend:		jx1 = jx2; jy1 = jy2;
X		}
X		ix1 = ix2; iy1 = iy2;
X	}   }
X	return 0;
X}
X
Xblastpair(i, j)		/* Generate random velocity vector v.	*/
X	int i, j ;	/* Add v to i, -v to j.			*/
X{	extern int rndint;
X	extern Objtype obj[SHIP+1];
X	unsigned char c;	/* for rand	*/
X	double vx, vy;
X	c = rand(rndint);
X/*	c = 4 - c>>5;	if you need angles from -3 to 4		*/
X	c>>2;		/* possibly save some time on sin/cos	*/
X	vx = cos((double) c); vy = sin((double) c);
X	obj[i].xvel = obj[i].xvel + vx;
X	obj[i].yvel = obj[i].yvel + vy;
X	obj[j].xvel = obj[j].xvel - vx;
X	obj[j].yvel = obj[j].yvel - vy;
X	obj[i].rotvel = obj[i].rotvel + .05;
X	obj[j].rotvel = obj[j].rotvel - .05;
X}
X
X/* dot product of 2 vectors	*/
X#define dot(i,j)	(i.x*j.x + i.y*j.y)
X/* rotational inertia (constant eliminated) of obj. i	*/
X#define rotinert(i)	(double) (obj[i].mass*shapesize[obj[i].shape]*shapesize[obj[i].shape])
X
X/* cause two objects to collide elastically	*/
Xbounce(i, j)
Xint	i,j;
X{
Xdouble	rotrat, temp;
Xextern	Objtype obj[SHIP+1];
XVector	vi, vj,		/* velocity of objs i, j		*/
X	ij,		/* vector from center of i to center of j */
X	vi_ij, vj_ij,	/* velocity of obj along vector ij	*/
X	vipij, vjpij,	/* velocity perpendicular to ij		*/
X	vi_ijf, vj_ijf;	/* post-collision velocity along ij	*/
X
Xvi.x = obj[i].xvel; vi.y = obj[i].yvel;
Xvj.x = obj[j].xvel; vj.y = obj[j].yvel;
Xij.x = obj[j].x - obj[i].x; ij.y = obj[j].y - obj[i].y;
Xij.mag = sqrt(ij.x*ij.x + ij.y*ij.y);
X/*
XCalculate velocities projected onto ij;
X	vi_ij = vi*cos(a) = (vi dot ij) / |ij|		*/
Xvi_ij.mag = dot(vi, ij) / ij.mag;
Xvi_ij.x = (ij.x * vi_ij.mag) / ij.mag;
Xvi_ij.y = (ij.y * vi_ij.mag) / ij.mag;
Xvj_ij.mag = dot(vj, ij) / ij.mag;
Xvj_ij.x = (ij.x * vj_ij.mag) / ij.mag;
Xvj_ij.y = (ij.y * vj_ij.mag) / ij.mag;
Xif (vi_ij.mag - vj_ij.mag < 0)	/* Objs moving away from each other -
X	Since objs are round (at least when bouncing), this means
X	they are moving away from each other already.	*/
X	return;
X/*
XCalculate component of velocities perpendicular to ij:
X	|vipij| = |vi|*sin(a) = |vi x ij| / |ij|
XSame as
X	|vipij| = |vi|*cos(pi/2 - a) = (vi dot (perp. to ij)) / |ij|	*/
Xtemp = vi.y*ij.x - vi.x*ij.y;	/* - (cross product when 3rd coord is 0)*/
Xtemp /= (ij.mag*ij.mag);
Xvipij.x = -ij.y*temp; vipij.y = ij.x*temp;
Xtemp = (vj.x*ij.y - vj.y*ij.x) / (ij.mag*ij.mag);
Xvjpij.x = -ij.y*temp; vjpij.y = ij.x*temp;
X/*
XCalculate the linear elastic collision along ij:
X	mass(i)*vi_ij + mass(j)*vj_ij = mass(i)*vi_ijf + mass(j)*vj_ijf
X	vi_ij + vi_ijf = vj_ij + vj_ijf	(derived by dividing equation
X	for conservation of kinetic energy by eq. for cons. of momentum) */
Xtemp = obj[i].mass/obj[j].mass;
Xvj_ijf.x = (temp * (2*vi_ij.x - vj_ij.x) + vj_ij.x) / (1 + temp);
Xvj_ijf.y = (temp * (2*vi_ij.y - vj_ij.y) + vj_ij.y) / (1 + temp);
Xvi_ijf.x = vj_ijf.x + vj_ij.x - vi_ij.x;
Xvi_ijf.y = vj_ijf.y + vj_ij.y - vi_ij.y;
X/*
XNow, given vi_ijf and vj_ijf, add them to the perpendicular
X	components to get final velocity vectors		*/
Xobj[i].xvel = vi_ijf.x + vipij.x;
Xobj[i].yvel = vi_ijf.y + vipij.y;
Xobj[j].xvel = vj_ijf.x + vjpij.x;
Xobj[j].yvel = vj_ijf.y + vjpij.y;
X/*
XNow calculate rotational velocity exchange	*/
Xrotrat = rotinert(i)/rotinert(j);
Xtemp = rotrat * (2*obj[i].rotvel - obj[j].rotvel) / (1+rotrat);
Xobj[i].rotvel = temp + obj[j].rotvel - obj[i].rotvel;
Xobj[j].rotvel = temp;
X}
X
Xbotline(disp, window, gc)	/* Print status line text	*/
X	Display *disp;
X	Drawable window;
X	GC gc;
X{	extern int highscore, ships, score;
X	char text[70];
X	sprintf(text, "Ships:%2d   Score:%6d   Shield:        High:%6d",
X		ships, score, highscore);
X	XDrawImageString (disp, window, gc, 0, height+letheight,
X			text, strlen(text));
X}
X
Xprintss(disp, window, gc)	/* Print ships and score	*/
X	Display *disp;
X	Drawable window;
X	GC gc;
X{	extern int height, highscore, oldscore, ships, score;
X	extern Objtype obj[SHIP+1];	/* to kill ship	*/
X	char sstring[30];
X
X	if (score != oldscore)
X	{	if (score/10000 > oldscore/10000)
X		{	ships++; botline(disp, window, gc);}
X		if (score/10000 < oldscore/10000)
X		{	ships--; botline(disp, window, gc);
X			if (!ships) obj[SHIP].alive = 0;
X		}
X		if (score > highscore)	/* Separate if to avoid flashing */
X		{	highscore = score;
X			sprintf(sstring, "%6d", highscore);
X			XDrawImageString (disp, window, gc, 460,
X				height+letheight, sstring, strlen(sstring));
X		}
X		sprintf(sstring, "%6d", score);
X		XDrawImageString (disp, window, gc, 170, height+letheight,
X				sstring, strlen(sstring));
X		oldscore = score;
X	}
X
X	/* Draw shield energy bar	*/
X	XFillRectangle(disp, window, gc, 340, height+8, energy>>1, 10);
X	XClearArea(disp, window, 340+(energy>>1), height+8, 8, 10, False);
X}
X
Xupscore(killer, up)	/* Only award score for things the player shot */
X	int killer, up;
X{	extern int score;
X	if (killer != ENEMYBUL && killer != SHIP)
X		score = score + up;
X}
X
X/* boom, movebooms, drawbooms all by Peter Phillips */
Xboom(ob, particles, duration)
Xint ob;
Xint particles;
Xint duration;
X{ extern int rndint;
X  int i;
X  unsigned int r1, r2;
X  Boom b;
X  double x, y;
X  double angle, length;
X
X  b = (Boom) malloc(sizeof(struct _Boom));
X  b->dur = duration;
X  b->part = particles;
X  x = obj[ob].x;
X  y = obj[ob].y;
X  for (i = 0; i < particles; i++) {
X    r1 = (rand(rndint) >> 2) % 100;
X    r2 = (rand(rndint) >> 2) % 7;
X
X    b->bcoord[i][0] = x;
X    b->bcoord[i][1] = y;
X    angle = r1 * pi / 50.0;
X    length = 3 + r2;
X    b->bvec[i][0] = cos(angle) * length + obj[ob].xvel;
X    b->bvec[i][1] = sin(angle) * length + obj[ob].yvel;
X  }
X  b->next = blist;
X  blist = b;
X}
X
X/* move the various booms that are active */
Xmovebooms()
X{
X  int i;
X  Boom b, prevb;
X
X  prevb = NULL;
X  b = blist;
X  while (b != NULL) {
X    b->dur--;
X    if (b->dur < 0) { /* delete this boom */
X      Boom temp;
X
X      temp = b;
X      if (prevb == NULL) {
X        blist = b->next;
X      } else {
X        prevb->next = b->next;
X      }
X      b = b->next;
X      free(temp);
X    } else {  /* move boom, advance list */
X      for (i = 0; i < b->part; i++) {
X        b->bcoord[i][0] += b->bvec[i][0];
X        b->bcoord[i][1] += b->bvec[i][1];
X      }
X      prevb = b;
X      b = b->next;
X    }
X  }
X}
X
X/* Draw the various booms */
Xdrawbooms(disp, window, gc)
X     Display *disp;
X     Drawable window;
X     GC gc;
X{
X  int i;
X  Boom b;
X  XPoint figure[BMAX];
X
X  b = blist;
X  while (b != NULL) {
X    for (i = 0; i < b->part; i++) {
X      figure[i].x = (int) b->bcoord[i][0];
X      figure[i].y = (int) b->bcoord[i][1];
X    }
X    XDrawPoints(disp, window, gc, figure, b->part, CoordModeOrigin);
X    b = b->next;
X  }
X}
X
Xdeletebooms()	/* delete all booms */
X{	Boom b;
X
X	b = blist;
X	while (b != NULL)
X	{	b->dur = 0;
X		b = b->next;
X}	}
X
Xkillast(killer, i)
X	int killer, i;		/* i = Asteroid # to kill	*/
X{	extern Objtype obj[SHIP+1];
X	extern int numasts;
X	int k, na, oldna;
X
X	if (obj[i].shape == ASTSHAPE1)
X	{	na = nextast();		/* Could put 6 lines in a sub */
X		obj[na].x = obj[i].x;
X		obj[na].y = obj[i].y;
X		obj[na].xvel = obj[i].xvel;
X		obj[na].yvel = obj[i].yvel;
X		obj[na].alive++;
X		obj[na].shape = ASTSHAPE2;
X		obj[na].mass = M_MED;
X		obj[i].shape = ASTSHAPE2;
X		obj[i].mass = M_MED;
X		blastpair(i, na);
X		boom(i, 30, 12);
X		numasts++;
X		if (numasts == 2)	/* Big asteroid was last remaining */
X			upscore(killer, 25+level*2000);
X		else	upscore(killer, 25);
X	}
X	else if (obj[i].shape == ASTSHAPE2)
X	{
X		for (k = 0; k < 3; k++)
X		{	oldna = na;
X			na = nextast();
X			obj[na].x = obj[i].x;
X			obj[na].y = obj[i].y;
X			obj[na].xvel = obj[i].xvel;
X			obj[na].yvel = obj[i].yvel;
X			obj[na].alive++;
X			obj[na].shape = ASTSHAPE3;
X			obj[na].mass = M_SMALL;
X			if (k == 1) blastpair(oldna,na);
X		}
X		obj[i].shape = ASTSHAPE3;
X		obj[i].mass = M_SMALL;
X		blastpair(na, i);
X		boom(i, 20, 10);
X		if (numasts == 1) upscore(killer, 500*level);
X		numasts = numasts + 3;
X		upscore(killer, 50);
X	}
X	else if (obj[i].shape == ASTSHAPE3)
X	{	boom(i, 10, 8);
X		obj[i].alive = 0; numasts--; upscore(killer, 100);}
X	else	/* enemy {ship or bullet}	*/
X	{	boom(i, 9, 7);
X		obj[i].alive = 0; upscore(killer, 500);}
X}
Xmoveobjs(crash)
X	int *crash;
X{	extern Objtype obj[SHIP+1];
X	extern int ships;
X	extern double speedscale;
X	int i, j;	/* Indexes	*/
X	double *temp;
X
X	movebooms();
X	for (i = 0; i < LASTOBJ+1; i++)
X		if (obj[i].alive)
X		{	temp = &obj[i].x;
X			*temp = *temp + obj[i].xvel*speedscale;
X			while (*temp < 0) *temp = *temp + (double) width;
X			while (*temp > width) *temp = *temp - (double) width;
X			temp = &obj[i].y;
X			*temp = *temp + obj[i].yvel*speedscale;
X			while (*temp < 0) *temp = *temp + height;
X			while (*temp > height) *temp = *temp - height;
X			obj[i].rot = obj[i].rot + obj[i].rotvel;
X		}
X	for (i = 0; i < FBUL; i++)
X	    if (obj[i].alive)
X	    {
X		if (obj[SHIP].alive && collide(i, SHIP))
X		{	if (shield_on) bounce(SHIP, i);
X			else
X			{	*crash = 2;
X				ships--; obj[SHIP].alive = 0;
X				killast(SHIP, i);
X				continue;
X		}	}
X		for (j = ENEMYBUL; j < LASTBUL+1; j++)
X			if (obj[j].alive && collide(i, j) &&
X			   (j != ENEMYBUL || (i != ENEMYBUL && i != ENEMY)))
X			{	obj[j].alive = 0;	/* Kill the bullet */
X				/* Don't have 2 bullets kill same asteroid */
X				if (obj[i].alive) killast(j,i);
X			}
X	    }
X}
X
Xfire()
X{	extern Objtype obj[SHIP+1];
X	extern int width, nextbul;
X	extern double drawscale, speedscale;
X	double *shiprot, cosrot, sinrot;
X
X	obj[nextbul].alive++;
X	shiprot = &obj[SHIP].rot;
X	cosrot = cos(*shiprot); sinrot = sin(*shiprot);
X	obj[nextbul].x = obj[SHIP].x + 20 * cosrot * drawscale;
X	obj[nextbul].y = obj[SHIP].y + 20 * sinrot * drawscale;
X	obj[nextbul].xvel = obj[SHIP].xvel + 10 * cosrot;
X	obj[nextbul].yvel = obj[SHIP].yvel + 10 * sinrot;
X	obj[nextbul].rot = *shiprot;
X	obj[nextbul].time = width/(speedscale*11);	/* loops before bullet expires	*/
X	nextbul++; if (nextbul == LASTBUL+1) nextbul = FBUL;
X}
X
Xhyper()
X{	extern Objtype obj[SHIP+1];
X	extern int width, height, rndint;
X	unsigned char c;
X	unsigned int i;
X
X	c = rand(rndint); i = c; i<<=2;	/* 0 - 1024	*/
X	while (i > width) i -= width;
X	obj[SHIP].x = (double) i;
X	c = rand(rndint); i = c; i<<=2;	/* 0 - 1024	*/
X	while (i > height) i -= height;
X	obj[SHIP].y = (double) i;
X}
X
Xvdraw(disp, window, gc, shape, x, y, rot)
X	Display *disp;
X	Drawable window;
X	GC gc;
X	int shape;
X	double x, y, rot;
X
X{	int line;
X	extern PolarPair shapes[LASTSHAPE+1][11];
X	extern int numpairs[LASTSHAPE+1];
X	extern double drawscale;
X	XPoint figure[20];
X	figure[0].x = (int) x; figure[0].y = (int) y;
X	for (line=1; line < numpairs[shape]; line++)	/* 2 pairs = 1 line */
X	{	figure[line].x  = (int) shapes[shape][line].length *
X			cos(shapes[shape][line].angle + rot) * drawscale;
X		figure[line].y  = (int) shapes[shape][line].length *
X			sin(shapes[shape][line].angle + rot) * drawscale;
X	}
X	XDrawLines (disp, window, gc, figure, numpairs[shape], CoordModePrevious);
X}
X
Xmain(argc, argv)
X	int argc;
X	char **argv;
X{	Colormap cmap;
X	Cursor cursor;
X	Display *disp;
X	Font font;
X	GC gc, pmgc;
X	KeySym key;
X	Pixmap pixmap;
X	Window window;
X	XColor black, exact;
X	XEvent event;
X	XSizeHints hint;
X	XWMHints wmhints;
X	extern int width, height;
X	int screen, depth;
X	char text[30];
X	unsigned long fg, bg;
X
X	extern double drawscale, speedscale;
X	extern int level, numasts, rndint, ships, score, oldscore;
X	extern Objtype obj[SHIP+1];
X	unsigned char c;	/* for rand	*/
X	double *temp, dx, dy, dist;
X	int crashed, flashon, len, pause = 0, delay = 64,
X		enemycount, counter, counterstart = 1,
X		i,	/* index for drawing objs, counting bullets */
X		r;	/* radius of shield circle	*/
X
X	disp = XOpenDisplay(0);
X	if (disp == (Display *) NULL)
X	{	fprintf(stderr, "Could not open display\n");
X		exit(1);
X	}
X	screen = DefaultScreen(disp);
X	bg = BlackPixel(disp, screen);
X	fg = WhitePixel(disp, screen);
X	hint.x = 150; hint.y = 200; hint.width = 550; hint.height = 550;
X	hint.flags = PPosition | PSize;
X	width = hint.width; height = hint.height-letheight-1;
X	depth = DefaultDepth (disp, screen);
X	window = XCreateSimpleWindow (disp, DefaultRootWindow(disp),
X		hint.x, hint.y, hint.width, hint.height, 5, fg, bg);
X	pixmap = XCreatePixmap (disp, window, width, height, depth);
X	XSetStandardProperties (disp, window, "asteroids", "asteroids", None,
X		argv, argc, &hint);
X	gc = XCreateGC (disp, window, 0, 0);
X	XSetGraphicsExposures(disp, gc, 0);	/* IMPORTANT!  If you do not
X		specifically ask not to get Expose events, every XCopyArea
X		will generate one, & the event queue will fill up.	*/
X	font = XLoadFont(disp, "10x20\0");	/* If you don't have this
X		font, try replacing it with 9x15\0	*/
X	XSetFont(disp, gc, font);
X	pmgc = XCreateGC (disp, window, 0, 0);
X	XSetBackground (disp, gc, bg);
X	XSetForeground (disp, gc, fg);
X	XSetForeground (disp, pmgc, bg);  /* fg of pixmap is bg of window */
X	wmhints.flags = InputHint;
X	wmhints.input = True;
X	XSetWMHints(disp, window, &wmhints);	/* Thanks to Doug Merritt */
X	XSelectInput (disp, window,
X		KeyPressMask | KeyReleaseMask | StructureNotifyMask);
X	XMapRaised (disp, window);
X
X	/* Erase cursor. Just delete next 5 lines if any error.	*/
X	cmap = XDefaultColormap(disp, screen);
X	XAllocNamedColor(disp, cmap, "Black", &exact, &black);
X	cursor = XCreateFontCursor(disp, XC_dot);
X	XRecolorCursor(disp, cursor, &black, &black);
X	XDefineCursor(disp, window, cursor);
X
X	XFillRectangle (disp, pixmap, pmgc, 0, 0, width, height);
X/*	Can delete next line if it causes trouble	*/
X	srand((unsigned) time(0));	/* By Craig Smith	*/
X	initasts();
XNewgame:
X	deletebooms();
X	ships = 3;
X	score = 0; oldscore = -1;
X	for (level = 0; ;)
X	{   if (level < 15) level++;
X	    makeasts ();
XNewship:    botline(disp, window, gc);
X	    if (!obj[SHIP].alive)
X	    {	obj[SHIP].x = width/2;
X		obj[SHIP].y = height/2;
X		obj[SHIP].xvel = 0;
X		obj[SHIP].yvel = 0;
X		obj[SHIP].rot = 3*pi/2;
X		obj[SHIP].rotvel = 0;
X		energy = 80;
X		shield_on = 0;
X	    }
X	    obj[SHIP].alive = (ships > 0);
X	    crashed = 0; flashon = 0; enemycount = 20;
X	    counter = 0;
X	    while (numasts)
X	    {	for (i = FBUL; i < LASTBUL+1; i++)  /* Bullet timer */
X		    if (obj[i].alive)
X		    {	obj[i].time--;
X			if (!obj[i].time) obj[i].alive = 0; /* Not --! */
X		    }
X		while (XEventsQueued(disp, QueuedAfterReading))
X		{   XNextEvent(disp, &event);
X		    switch (event.type)
X		    {	case MappingNotify:
X			    XRefreshKeyboardMapping (&event);
X			    break;
X			case ConfigureNotify:
X			    width = event.xconfigure.width;
X			    height = event.xconfigure.height-letheight-1;
X			    XFreePixmap (disp, pixmap);
X			    pixmap = XCreatePixmap (disp, window, width, height, depth);
X			    XFillRectangle (disp, pixmap, pmgc, 0, 0, width, height);
X			    botline(disp, window, gc);
X			    break;
X			case KeyPress:
X			    len = XLookupString (&event, text, 10, &key, 0);
X			    if (len == 1 && !shield_on) switch (text[0])
X			    {	case 'e':
X				    obj[SHIP].rotvel = obj[SHIP].rotvel - .1; break;
X				case 'r':
X				    obj[SHIP].rotvel = obj[SHIP].rotvel + .1; break;
X				case 'w':
X				    obj[SHIP].rot -= pi/4; break;
X				case 't':
X				    obj[SHIP].rot += pi/4; break;
X				case 'd':
X				    obj[SHIP].rotvel = obj[SHIP].rotvel - .02; break;
X				case 'f':
X				    obj[SHIP].rotvel = obj[SHIP].rotvel + .02; break;
X				case THRUST:
X				    obj[SHIP].xvel += cos(obj[SHIP].rot);
X				    obj[SHIP].yvel += sin(obj[SHIP].rot);
X				    obj[SHIP].shape = SHIPTHRSHAPE;
X				    break;
X				case FIRE:
X				    if (obj[SHIP].alive) fire(); break;
X				case ' ':
X				    if (obj[SHIP].alive)
X				    {	hyper(); flashon = 1;
X/*				    NOT XSetForeground (disp, gc, bg);
X	If you set the fg black, & print the highscore, it will effectively erase it.	*/
X				        XSetForeground (disp, pmgc, fg);
X					XFillRectangle (disp, pixmap, pmgc, 0, 0, width, height);
X				    }
X				    break;
X				case SHIELD:
X				    if (energy)
X				    {	shield_on = 1;
X					obj[SHIP].shape = SHIPSHAPE;}
X					break;
X				case '.':	/* decrease delay	*/
X				    if (delay > 1) delay >>=1; break;
X				case ',':	/* increase delay	*/
X				    delay <<=1; break;
X				case 'm':	/* decrease drawscale - may go negative */
X				    drawscale -= .1; break;
X				case 'n':	/* increase drawscale	*/
X				    drawscale += .1; break;
X				case '2':	/* increase speedscale	*/
X				    speedscale += .1; break;
X				case '1':	/* decrease speedscale	*/
X				    speedscale -= .1; break;
X				case 'b':	/* increase moves/update */
X				    counterstart++; break;
X				case 'v':	/* decrease moves/update */
X				    if (counterstart > 1) counterstart--;
X				    break;
X				case PAUSE:	/* pause	*/
X				    pause = 1 - pause; break;
X				case '+':	/* cheat	*/
X				    ships++; botline(disp, window, gc); break;
X				case 'Q':	/* quit		*/
X				    goto End;
X				case 's':	/* start new ship */
X				    if (!obj[SHIP].alive)
X					if (ships < 1) goto Newgame;
X					else goto Newship;
X				    break;
X			    }
X			    break;
X			case KeyRelease:
X			    len = XLookupString(&event, text, 10, &key, 0);
X			    if (len == 1) switch (text[0])
X			    {	case 'e':
X				    obj[SHIP].rotvel = 0; break;
X				case 'r':
X				    obj[SHIP].rotvel = 0; break;
X				case THRUST:
X				    obj[SHIP].shape = SHIPSHAPE;
X				    break;
X				case SHIELD:
X				    shield_on = 0; break;
X			    }
X/*			    break;		*/
X		}   }
X		if (!pause)
X		{   moveobjs(&crashed);
X		    if (ships) score--;	/* timer effect	*/
X		    if (!counter)
X		    {	counter = counterstart;	/* Restart counter */
X			if (crashed == 2)
X			{   crashed--; flashon++;
X			    boom(SHIP, BMAX-1, 70);
X			    XSetForeground (disp, pmgc, fg);
X			    XFillRectangle (disp, pixmap, pmgc, 0, 0, width, height);
X			    botline(disp, window, gc);
X			}
X			/* Write copyright notice	*/
X			if (!ships && blist == NULL)
X			{   sprintf(text, "Xasteroids");
X			    XDrawImageString (disp, pixmap, gc,
X				width/2-50, height/2-2*letheight,
X				text, strlen(text));
X			    sprintf(text, "Copyright 1990 by Phil Goetz");
X			    XDrawImageString (disp, pixmap, gc,
X				width/2-140, height/2,
X				text, strlen(text));
X			    sprintf(text, "goetz@cs.buffalo.edu");
X			    XDrawImageString (disp, pixmap, gc,
X				width/2-100, height/2+2*letheight,
X				text, strlen(text));
X			}
X			/*	Draw objects	*/
X			for (i = 0; i <= LASTOBJ; i++)
X			    if (obj[i].alive)
X				vdraw(disp, pixmap, gc, obj[i].shape,
X					obj[i].x, obj[i].y, obj[i].rot);
X			if (shield_on && obj[SHIP].alive)
X			{   r = abs((int) (drawscale*SHIPSIZE));
X			    XDrawArc(disp, pixmap, gc,
X				((int) obj[SHIP].x) - r,
X				((int) obj[SHIP].y) - r,
X				2*r, 2*r, 0, 360*64);
X			    energy--;
X			    if (!energy) shield_on = 0;
X			}
X			drawbooms(disp, pixmap, gc);
X			/* update display:	*/
X			XCopyArea(disp, pixmap, window, gc, 0, 0, width, height, 0, 0);
X			printss(disp, window, gc);
X			/* erase objects	*/
X			XFillRectangle (disp, pixmap, pmgc, 0, 0, width, height);
X			if (flashon)
X			{   flashon--;
X			    XSetForeground (disp, pmgc, bg);
X			    XFillRectangle (disp, pixmap, pmgc, 0, 0, width, height);
X			}
X			XSync(disp, 0);
X		    }
X		    counter--;
X		    i = (rand(rndint)>>8) & 255;
X		    if (!obj[ENEMY].alive)
X			{   if (i < level)
X			    {	c = rand(rndint);
X				if (c < level * 10) makeenemy();
X			}   }
X		    else
X		    {	i += (obj[SHIP].y > obj[ENEMY].y)
X				? level>>1 : -(level>>1);
X			obj[ENEMY].yvel += (i>128+6*obj[ENEMY].yvel) ? .5 : -.5;
X		    }
X		    enemycount--; if (!enemycount)
X		    {	enemycount = 100;
X			if (obj[ENEMY].alive)
X			{   obj[ENEMYBUL].alive++;
X			    obj[ENEMYBUL].x = obj[ENEMY].x;
X			    obj[ENEMYBUL].y = obj[ENEMY].y;
X			    dx = obj[SHIP].x - obj[ENEMY].x;
X			    dy = obj[SHIP].y - obj[ENEMY].y;
X			    dist = sqrt(dx*dx + dy*dy);
X			    obj[ENEMYBUL].xvel = 3*dx/dist;
X			    obj[ENEMYBUL].yvel = 3*dy/dist;
X			}
X			else	obj[ENEMYBUL].alive = 0;
X		    }
X		    for (i = 0; i < delay; i++);
X		}
X	    }
X	}
XEnd:	printf("\nYour high score was %d\n", highscore);
X	XFreeGC (disp, gc);
X	XFreeGC (disp, pmgc);
X	XFreePixmap (disp, pixmap);
X	XDestroyWindow (disp, window);
X	XCloseDisplay (disp);
X	exit(0);
X}
END_OF_FILE
if test 27746 -ne `wc -c <'xast.c'`; then
    echo shar: \"'xast.c'\" unpacked with wrong size!
fi
# end of 'xast.c'
fi
if test -f 'xast.docs' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xast.docs'\"
else
echo shar: Extracting \"'xast.docs'\" \(1405 characters\)
sed "s/^X//" >'xast.docs' <<'END_OF_FILE'
X		X-Asteroids
X	Copyright 1990 by Phil Goetz
X	    goetz@cs.Buffalo.EDU
X
XKeypress	Command
X--------        -------
X    e		Rotate counterclockwise ("left")
X    r		Rotate clockwise ("right")
X    w		Rotate 45 degrees counterclockwise
X    t		Rotate 45 degrees clockwise
X    d		Increase counterclockwise rotational velocity
X    f		Increase clockwise rotational velocity
X    o		Thrust
X    p		Fire
X  space		Hyperspace
X    `		Shields
X    s		Start new ship in center of playing field
X		(Also used to start a new game)
X   esc		Pause
X    Q		Quit
XSpeed commands:	Key associated with faster speed is to the right of its
X		corresponding key associated with slower speed.
X    .		Decrease delay:  Speed game up
X    ,		Increase delay:  Slow the game down
X    m		Decrease size	("Minimize")
X    n		Increase size
X    b		Increase # of moves/frame
X    v		Decrease # of moves/frame
X    2		Increase scale of movement
X    1		Decrease scale of movement
X
XObject		Score
X-------		-----
XBig asteroid	 25, or 2000*level if it is the last asteroid remaining
XMedium asteroid	 50, or  500*level if it is the last asteroid remaining
XLittle asteroid	100
XEnemy spaceship	500
XEnemy bullet	500
X
XCommands can only be entered when the mouse pointer is in the
Xasteroids window.
X
XResize the window with your window manager
Xat any time for a different playing field.
X
XUse the command-line option -s on the xasteroids script
Xto see the high score list.
END_OF_FILE
if test 1405 -ne `wc -c <'xast.docs'`; then
    echo shar: \"'xast.docs'\" unpacked with wrong size!
fi
# end of 'xast.docs'
fi
if test -f 'xast.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xast.man'\"
else
echo shar: Extracting \"'xast.man'\" \(1976 characters\)
sed "s/^X//" >'xast.man' <<'END_OF_FILE'
X.TH xasteroids n
X.SH NAME
Xxasteroids - X windows based asteroids style arcade game
X.SH SYNOPSIS
X.ta 8n
X\fBxasteroids\fP
X.br
X.SH DESCRIPTION
XMake big rocks into little ones.
X.br
X.SH COMMANDS
X.I xasteroids 
X
X e           Rotate counterclockwise ("left")
X r           Rotate clockwise ("right")
X w           Rotate 45 degrees counterclockwise
X t           Rotate 45 degrees clockwise
X d           Increase counterclockwise rotational velocity
X f           Increase clockwise rotational velocity
X o           Thrust
X p           Fire
X `           Shields
X space       Hyperspace
X s           Start new ship in center of playing field
X             (Also used to start a new game)
X esc         Pause
X Q           Quit
X
XSpeed commands: Key associated with faster speed is to the right of its
X                corresponding key associated with slower speed.
X
X .           Decrease delay:  Speed game up
X ,           Increase delay:  Slow the game down
X m           Decrease size   ("Minimize")
X n           Increase size
X b           Increase # of moves/frame
X v           Decrease # of moves/frame
X 2           Increase scale of movement
X 1           Decrease scale of movement
X
XObject          Score
X
X Big asteroid    25, or 2000*level if it is the last asteroid remaining
X Medium asteroid 50, or  500*level if it is the last asteroid remaining
X Little asteroid 100
X Enemy spaceship 500
X Enemy bullet    500
X
XCommands can only be entered when the mouse pointer is in the
Xasteroids window.
X
XResize the window with your window manager
Xat any time for a different playing field.
X
X.SH OPTIONS
X.I xasteroids [-s]
X-s Display high scores without running game.
X.PP
X.SH AUTHOR
XPhil Goetz
X.br
Xgoetz@cs.Buffalo.EDU
X.SH CONTRIBUTORS
XPeter Phillips	pphillip@cs.ubc.ca
XPat Ryan	pat@jaameri.gsfc.nasa.gov
XCraig Smith	csmith@cscs.UUCP
XDoug Merritt	doug@netcom.com
XJames Berg	berg@plains		(makefile)
XChris Moore	moore@src.bae.co.uk	(hi score script)
XDavid Partain	dlp@ida.liu.se		(original man page)
END_OF_FILE
if test 1976 -ne `wc -c <'xast.man'`; then
    echo shar: \"'xast.man'\" unpacked with wrong size!
fi
# end of 'xast.man'
fi
if test -f 'xasteroids' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xasteroids'\"
else
echo shar: Extracting \"'xasteroids'\" \(497 characters\)
sed "s/^X//" >'xasteroids' <<'END_OF_FILE'
X#!/bin/sh
X#cd /u5/grads/goetz/X
Xif [ "$1" = "-s" ]
Xthen
X  /bin/cat xast.hs
Xelse
X  /bin/echo ""
X  /bin/cat xast.hs
X  /bin/echo ""
X  /bin/echo Type 'Q' to save your high score...
X  umask 77
X  score=`xast.exe | /bin/cut '-d ' -f5`
X  if [ "$score" != "" ]
X  then
X    (/bin/echo $score"	"$USER"		`/bin/date | /bin/sed 's/  / 0/g' | cut '-d ' -f1,2,3,6 | /bin/sed 's/ 0/  /g'`"; cat xast.hs) | /bin/sort +0rn -1 +5n +3M | head -10 > xast.hs2
X    /bin/mv -f xast.hs2 xast.hs
X    /bin/cat xast.hs
X  fi
Xfi
END_OF_FILE
if test 497 -ne `wc -c <'xasteroids'`; then
    echo shar: \"'xasteroids'\" unpacked with wrong size!
fi
chmod +x 'xasteroids'
# end of 'xasteroids'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
