Subject:  v17i040:  napoleon - text adventure game, Part03/04
Newsgroups: comp.sources.games
Approved: billr@saab.CNA.TEK.COM

Submitted-by: pc123@cus.cam.ac.uk (Pete Chown)
Posting-number: Volume 17, Issue 40
Archive-name: napoleon/Part03
Environment: Unix, ASNI-C


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 4)."
# Contents:  describe.c difftime.c file.c lex.c line.c napoleon.nr
#   noughts.c parse.c
# Wrapped by billr@saab on Thu Mar  4 09:46:52 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'describe.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'describe.c'\"
else
echo shar: Extracting \"'describe.c'\" \(6045 characters\)
sed "s/^X//" >'describe.c' <<'END_OF_FILE'
X/* Copyright (C) 1992 Pete Chown.
X
X   Here is my latest adventure game, Napoleon (see the documentation
X   if you don't know why it's called that).  Have fun... (don't cheat,
X   even though you've got the source :-) ).
X
X   This game is free software; you can redistribute it and/or modify
X   it under the terms of the GNU General Public License as published by
X   the Free Software Foundation; either version 1, or (at your option)
X   any later version.
X
X   The game is distributed in the hope that it will be useful, but
X   WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X   General Public License for more details.
X
X   The GNU General Public License is often shipped with GNU software, and
X   is generally kept in a file called COPYING or LICENSE.  If you do not
X   have a copy of the license, write to the Free Software Foundation,
X   675 Mass Ave, Cambridge, MA 02139, USA. */
X
X#include "adv.h"
X
Xextern void resumscore(void)
X{
X  int i,roomsvisited = 0;
X
X  for(i = 0;objects [i].examine != 0;i++)
X  {
X    if(objects [i].objtype.visited) roomsvisited++;
X  }
X
X  score = (+(roomsvisited * 100)) / i;
X}
X
X/* detachfromchain() has a rather obscure function: it deletes the object
X   from the list it is currently in, ready to be reattached somewhere else.
X   It is included as a special function on the basis that removing an object
X   from a list is very much harder than adding it.  */
X
Xextern void detachfromchain(int this)
X{
X  int parent = objects [this].parent,*whichchain = 0;
X
X  if(objects [parent].above == this) whichchain = & objects [parent].above;
X  if(objects [parent].below == this) whichchain = & objects [parent].below;
X  if(objects [parent].inside == this) whichchain = & objects [parent].inside;
X  if(objects [parent].next == this) whichchain = & objects [parent].next;
X
X  if(whichchain == 0) fail(); /* Parent pointer goes to the wrong place */
X
X  *whichchain = objects [this].next;
X  if(objects [this].next != 0) objects [objects [this].next].parent = parent;
X}
X
X/* addtochain() puts an object into a specified chain.  */
X
Xextern void addtochain(int toadd,int parent,int *chain)
X{
X  objects [toadd].parent = parent;
X  objects [toadd].next = *chain;
X  objects [*chain].parent = toadd;
X  *chain = toadd;
X}
X
Xextern int getroom(int player)
X{
X  int room = player;
X
X  while(objects [room].objtype.room == FALSE) room = objects [room].parent;
X
X  return room;
X}
X
Xextern bool ancestor(int elder,int younger)
X{
X  while(younger != 0)
X  {
X    younger = objects [younger].parent;
X    if(younger == elder) return TRUE;
X  }
X
X  return FALSE;
X}
X
Xstatic void listchain(int this,char *start,char *end)
X{
X  bool reportedone = FALSE;
X  int nextone = -1;
X  char buffer [4096] = "";
X
X  while(this != 0)
X  {
X    if(! objects [this].objtype.virtual) {
X      if(nextone != -1) {
X	if(reportedone) {
X	  strcat(buffer,", ");
X	  strcat(buffer,objects [nextone].longname);
X	} else {
X	  reportedone = TRUE;
X	  strcat(buffer,start);
X	  strcat(buffer,objects [nextone].longname);
X	}
X      }
X      nextone = this;
X    }
X    this = objects [this].next;
X  }
X  if(nextone != -1) {
X    if(reportedone) {
X      strcat(buffer," and ");
X      strcat(buffer,objects [nextone].longname);
X      strcat(buffer,end);
X    } else {
X      sprintf(buffer,"%s%s%s",start,objects [nextone].longname,end);
X    }
X  }
X  if(*buffer != 0) format("%s",buffer);
X}
X
Xstatic char *subst(char *template,char *substitution)
X{
X  static char buffer [60],*name;
X
X  name = strchr(substitution,' ') + 1;
X  if(name == (char *) 1) name = substitution;
X  sprintf(buffer,template,name);
X  return buffer;
X}
X
Xstatic void recursivelist(int);
X
Xstatic void recursivelistchain(int this)
X{
X  while(this != 0)
X  {
X    recursivelist(this);
X    this = objects [this].next;
X  }
X}
X
Xstatic void recursivelist(int this)
X{
X  char *longname = objects [this].longname;
X
X  listchain(objects [this].above,subst("On the %s, there is ",longname),".\n");
X  if(! objects [this].objtype.opaque) {
X    listchain(objects [this].below,subst("Under the %s, there is ",longname),".\n");
X    if(objects [this].objtype.alive)
X      listchain(objects [this].inside,subst("The %s is carrying ",longname),".\n");
X    else listchain(objects [this].inside,subst("Inside the %s, there is ",longname),".\n");
X  }
X  recursivelistchain(objects [this].above);
X  if(! objects [this].objtype.opaque) {
X    recursivelistchain(objects [this].below);
X    recursivelistchain(objects [this].inside);
X  }
X}
X
Xstatic bool luminous(int this)
X{
X  if(this == 0) return FALSE;
X  return objects [this].objtype.luminous || luminous(objects [this].above) || luminous(objects [this].below) || luminous(objects [this].inside) || luminous(objects [this].next);
X}
X
Xextern bool illuminated(int room)
X{
X  return objects [room].objtype.luminous || luminous(objects [room].inside);
X}
X
Xextern void describe_room(int player,bool look_called)
X{
X  int room = getroom(player),this = objects [room].inside;
X  char buffer [10] = "";
X  bool verbosedescription = flags [0] == 2
X    || (flags [0] == 0 && ! objects [getroom(player)].objtype.visited) || look_called;
X
X  if(hacker) sprintf(buffer," [%0d]",room);
X  if(illuminated(room)) {
X    if(verbosedescription)
X      format("\n%s%s\n\n%s\n",objects [room].longname,buffer,objects [room].examine);
X    else format("\n%s%s\n",objects [room].longname,buffer);
X    listchain(this,"There is "," here.\n");
X    recursivelistchain(this);
X  } else {
X    format("It's pitch dark.\n\nIn the distance, someone calls, 'Get the gia"
X"nt spider woken up!'\nCloser by, someone shouts, 'Wake up you lazy slob!  Wa"
X"ke up, wake up, I tell you!'\n");
X  }
X
X  if(! objects [getroom(player)].objtype.visited) {
X    objects [getroom(player)].objtype.visited = 1;
X    resumscore();
X  }
X
X  postdescription(player);
X}
X
Xextern void inventory(int player)
X{
X  if(objects [player].inside == 0) {
X    format("You aren't carrying anything!");
X  } else {
X    listchain(objects [player].inside,"You are carrying ",".\n");
X    recursivelistchain(objects [player].inside);
X  }
X}
END_OF_FILE
if test 6045 -ne `wc -c <'describe.c'`; then
    echo shar: \"'describe.c'\" unpacked with wrong size!
fi
# end of 'describe.c'
fi
if test -f 'difftime.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'difftime.c'\"
else
echo shar: Extracting \"'difftime.c'\" \(984 characters\)
sed "s/^X//" >'difftime.c' <<'END_OF_FILE'
X/* Copyright (C) 1991 Free Software Foundation, Inc.
XThis file is part of the GNU C Library.
X
XThe GNU C Library is free software; you can redistribute it and/or
Xmodify it under the terms of the GNU Library General Public License as
Xpublished by the Free Software Foundation; either version 2 of the
XLicense, or (at your option) any later version.
X
XThe GNU C Library is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY; without even the implied warranty of
XMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
XLibrary General Public License for more details.
X
XYou should have received a copy of the GNU Library General Public
XLicense along with the GNU C Library; see the file COPYING.LIB.  If
Xnot, write to the Free Software Foundation, Inc., 675 Mass Ave,
XCambridge, MA 02139, USA.  */
X
X#include <time.h>
X
X
X/* Return the difference between TIME1 and TIME0.  */
X
Xdouble difftime (time_t time1, time_t time0)
X{
X  return (double) (time1 - time0);
X}
END_OF_FILE
if test 984 -ne `wc -c <'difftime.c'`; then
    echo shar: \"'difftime.c'\" unpacked with wrong size!
fi
# end of 'difftime.c'
fi
if test -f 'file.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'file.c'\"
else
echo shar: Extracting \"'file.c'\" \(2518 characters\)
sed "s/^X//" >'file.c' <<'END_OF_FILE'
X/* Copyright (C) 1992 Pete Chown.
X
X   Here is my latest adventure game, Napoleon (see the documentation
X   if you don't know why it's called that).  Have fun... (don't cheat,
X   even though you've got the source :-) ).
X
X   This game is free software; you can redistribute it and/or modify
X   it under the terms of the GNU General Public License as published by
X   the Free Software Foundation; either version 1, or (at your option)
X   any later version.
X
X   The game is distributed in the hope that it will be useful, but
X   WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X   General Public License for more details.
X
X   The GNU General Public License is often shipped with GNU software, and
X   is generally kept in a file called COPYING or LICENSE.  If you do not
X   have a copy of the license, write to the Free Software Foundation,
X   675 Mass Ave, Cambridge, MA 02139, USA. */
X
X#include "adv.h"
X
Xstatic const char *filehead = "Napoleon " VERSION;
Xstatic int numobjects;
X
Xextern void loadgame(void)
X{
X  FILE *infile;
X  char *name,buffer [128];
X
X  name = getline("Filename >",LINE_NO_HISTORY);
X  infile = fopen(name,"rb");
X  if(infile == 0) {
X    format("Sorry, can't open that file.\n");
X    return;
X  }
X  fread(buffer,strlen(filehead),1,infile);
X  if(strncmp(buffer,filehead,strlen(filehead))) {
X    format("Sorry, that file is not a Napoleon saved game, or it is a Napole"
X"on saved game from a different version of the program.\n");
X  } else {
X    fread(flags,sizeof(flags),1,infile);
X    fread(objects,sizeof(object),numobjects,infile);
X  }
X  fclose(infile);
X  resumscore();
X  descr = TRUE;
X}
X
Xextern void savegame(void)
X{
X  FILE *outfile;
X  char *name;
X
X  name = getline("Filename >",LINE_NO_HISTORY);
X  outfile = fopen(name,"wb");
X  if(outfile == 0) {
X    format("Sorry, can't open that file.\n");
X    return;
X  }
X  fwrite(filehead,strlen(filehead),1,outfile);
X  fwrite(flags,sizeof(flags),1,outfile);
X  fwrite(objects,sizeof(object),numobjects,outfile);
X  fclose(outfile);
X}
X
Xextern void initialise(void)
X{
X  int i;
X
X  for(numobjects = 0;intobjects [numobjects].examine != (char *) 1;numobjects++);
X  numobjects++;
X
X  if(objects == 0) objects = xmalloc(numobjects * sizeof(object));
X
X  memcpy(objects,intobjects,numobjects * sizeof(object));
X
X  player = -1;
X  for(i = 0;;i++)
X  {
X    if(objects [i].objtype.player) {
X      player = i;
X      break;
X    }
X  }
X  if(player == -1) fail();
X
X  for(i = 0;i < 128;i++) flags [i] = 0;
X}
END_OF_FILE
if test 2518 -ne `wc -c <'file.c'`; then
    echo shar: \"'file.c'\" unpacked with wrong size!
fi
# end of 'file.c'
fi
if test -f 'lex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lex.c'\"
else
echo shar: Extracting \"'lex.c'\" \(5562 characters\)
sed "s/^X//" >'lex.c' <<'END_OF_FILE'
X/* Copyright (C) 1992 Pete Chown.
X
X   Here is my latest adventure game, Napoleon (see the documentation
X   if you don't know why it's called that).  Have fun... (don't cheat,
X   even though you've got the source :-) ).
X
X   This game is free software; you can redistribute it and/or modify
X   it under the terms of the GNU General Public License as published by
X   the Free Software Foundation; either version 1, or (at your option)
X   any later version.
X
X   The game is distributed in the hope that it will be useful, but
X   WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X   General Public License for more details.
X
X   The GNU General Public License is often shipped with GNU software, and
X   is generally kept in a file called COPYING or LICENSE.  If you do not
X   have a copy of the license, write to the Free Software Foundation,
X   675 Mass Ave, Cambridge, MA 02139, USA. */
X
X#include "adv.h"
X#include "lang.h"
X
Xstatic int identify(char *command,char *teststring)
X{
X  int i;
X
X  for(i = 1;*teststring != 0;i++)
X  {
X    if(strcmp_ci(command,teststring)) return i;
X    teststring += strlen(teststring) + 1;
X  }
X  return 0;
X}
X
X/* strcmp_ci_t is a routine to compare two strings, allowing any character
X   in the third string as a terminator.  */
X
Xstatic bool strcmp_ci_t(char *a,char *b,char *term)
X{
X  while(tolower(*a) == tolower(*b) || (strchr(term,*a) && strchr(term,*b)))
X  {
X    if(strchr(term,*a)) return TRUE;
X    a++;
X    b++;
X  }
X  return FALSE;
X}
X
X/* findword has the job of searching for a word and determining
X   whether it is a noun or an adjective.  */
X
Xstatic int findword(char *word)
X{
X  int i;
X
X  for(i = 0;objects [i].examine != (char *) 1;i++)
X  {
X    if(objects [i].shortname != 0) {
X      char *lookingat = objects [i].shortname;
X
X      do {
X	if(strcmp_ci_t(lookingat,word,"_")) {
X	  if(strchr(lookingat,'_')) return ADJECTIVE;
X	  return NOUN;
X	}
X	lookingat = strchr(lookingat,'_') + 1;
X      } while(lookingat != (char *) 1);
X    }
X  }
X  return 0;
X}
X
Xextern int yylex(void)
X{
X  char buffer [64];
X  int word,wordtype,i;
X
X  while(isspace(*yaccstring)) yaccstring++;
X  if(*yaccstring == 0) return 0; /* End of command line */
X  if(isalpha(*yaccstring)) {
X    strncpy(buffer,yaccstring,63);
X    buffer [63] = 0;
X    for(i = 0;isalpha(buffer [i]);i++);
X    buffer [i] = 0;
X    yaccstring += strlen(buffer);
X    word = identify(buffer,"north\0south\0west\0east\0northwest\0northeast\0"
X"southwest\0southeast\0up\0down\0");
X    if(word == 0) word = identify(buffer,"n\0s\0w\0e\0nw\0ne\0sw\0se\0u\0d\0"
X"inventory\0load\0look\0quit\0save\0score\0go\0examine\0all\0everything\0in\0"
X"into\0on\0off\0to\0get\0drop\0take\0put\0inv\0restore\0onto\0under\0undernea"
X"th\0at\0below\0the\0and\0read\0twirl\0turn\0say\0ask\0about\0yes\0no\0hello\0"
X"hi\0goodbye\0bye\0hack\0play\0with\0noughts\0crosses\0give\0throw\0over\0jump"
X"\0touch\0unlock\0open\0brief\0verbose\0normal\0record\0drink\0wait\0kiss\0"
X"search\0climb\0");
X    switch(word)
X    {
X    case 0:
X      wordtype = findword(buffer);
X      switch(wordtype)
X      {
X      case NOUN:
X	strcpy(yylval.string,buffer);
X	return NOUN;
X      case ADJECTIVE:
X	strcpy(yylval.string,buffer);
X	return ADJECTIVE;
X      case 0:
X	format("I don't understand '%s'.",buffer);
X	return 0;
X      default:
X	fail();
X      }
X    case 1: return NORTH;
X    case 2: return SOUTH;
X    case 3: return WEST;
X    case 4: return EAST;
X    case 5: return NORTHWEST;
X    case 6: return NORTHEAST;
X    case 7: return SOUTHWEST;
X    case 8: return SOUTHEAST;
X    case 9: return UP;
X    case 10: return DOWN;
X    case 11: return INVENTORY;
X    case 12: return LOAD;
X    case 13: return LOOK;
X    case 14: return QUIT;
X    case 15: return SAVE;
X    case 16: return SCORE;
X    case 17: return GO;
X    case 18: return EXAMINE;
X    case 19: return ALL;
X    case 20: return EVERYTHING;
X    case 21: return IN;
X    case 22: return INTO;
X    case 23: return ON;
X    case 24: return OFF;
X    case 25: return TO;
X    case 26: return GET;
X    case 27: return DROP;
X    case 28: return TAKE;
X    case 29: return PUT;
X    case 30: return INV;
X    case 31: return RESTORE;
X    case 32: return ONTO;
X    case 33: return UNDER;
X    case 34: return UNDERNEATH;
X    case 35: return AT;
X    case 36: return BELOW;
X    case 37: return THE;
X    case 38: return AND;
X    case 39: return READ;
X    case 40: return TWIRL;
X    case 41: return TURN;
X    case 42: return SAY;
X    case 43: return ASK;
X    case 44: return ABOUT;
X    case 45: return YES;
X    case 46: return NO;
X    case 47: return HELLO;
X    case 48: return HI;
X    case 49: return GOODBYE;
X    case 50: return BYE;
X    case 51: return HACK;
X    case 52: return PLAY;
X    case 53: return WITH;
X    case 54: return NOUGHTS;
X    case 55: return CROSSES;
X    case 56: return GIVE;
X    case 57: return THROW;
X    case 58: return OVER;
X    case 59: return JUMP;
X    case 60: return TOUCH;
X    case 61: return UNLOCK;
X    case 62: return OPEN;
X    case 63: return BRIEF;
X    case 64: return VERBOSE;
X    case 65: return NORMAL;
X    case 66: return RECORD;
X    case 67: return DRINK;
X    case 68: return WAIT;
X    case 69: return KISS;
X    case 70: return SEARCH;
X    case 71: return CLIMB;
X
X    default: fail();
X    }
X  } else {
X    switch(*(yaccstring++))
X    {
X    case '\"': case '\'': return QUOTE;
X    case '.': case '!': return FULLSTOP;
X    case ',': return COMMA;
X    case ';': return SEMICOLON;
X    default:
X      format("What do you mean '%c'?",*(yaccstring - 1));
X      return 0;
X    }
X  }
X  return 0;
X}
END_OF_FILE
if test 5562 -ne `wc -c <'lex.c'`; then
    echo shar: \"'lex.c'\" unpacked with wrong size!
fi
# end of 'lex.c'
fi
if test -f 'line.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'line.c'\"
else
echo shar: Extracting \"'line.c'\" \(5356 characters\)
sed "s/^X//" >'line.c' <<'END_OF_FILE'
X/* Copyright (C) 1992 Pete Chown.
X
X   Here is my latest adventure game, Napoleon (see the documentation
X   if you don't know why it's called that).  Have fun... (don't cheat,
X   even though you've got the source :-) ).
X
X   This game is free software; you can redistribute it and/or modify
X   it under the terms of the GNU General Public License as published by
X   the Free Software Foundation; either version 1, or (at your option)
X   any later version.
X
X   The game is distributed in the hope that it will be useful, but
X   WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X   General Public License for more details.
X
X   The GNU General Public License is often shipped with GNU software, and
X   is generally kept in a file called COPYING or LICENSE.  If you do not
X   have a copy of the license, write to the Free Software Foundation,
X   675 Mass Ave, Cambridge, MA 02139, USA. */
X
X#include "adv.h"
X
X#ifdef UNIX
X
X#include <termios.h>
X
X#ifdef HAS_UNISTD
X#include <unistd.h>
X#endif
X
X#endif
X
X#ifndef TIOCGWINSZ
Xstatic int screenx = 80,screeny = 24;
X#else
Xstatic int screenx = 0,screeny = 0;
X#endif
Xstatic int lineswritten = 0;
X
Xint delay;
X
X#ifdef UNIX
Xstatic void getscreenx(void)
X{
X#ifdef TIOCGWINSZ
X
X  struct winsize window_size;
X
X  ioctl(0,TIOCGWINSZ,& window_size);
X  screenx = (int) window_size.ws_col;
X  screeny = (int) window_size.ws_row;
X
X#else
X
X  fail();
X
X#endif
X}
X#endif
X
X#ifdef UNIX
Xstatic void winchhandler(int signo)
X{
X  signo = signo;
X
X  getscreenx();
X  signal(SIGWINCH,& winchhandler);
X}
X#endif
X
Xextern void more(void)
X{
X  printf("-- more; press return --");
X  while(getchar() != '\n');
X  lineswritten = 0;
X}
X
Xextern void format(char *fmt,...)
X{
X  va_list args;
X  char buf [16384],*here = buf,*linestart = buf,*lineend = buf;
X  bool hardnewline = TRUE;
X
X#ifdef UNIX
X
X  if(screenx == 0) {
X    getscreenx();
X    signal(SIGWINCH,& winchhandler);
X  }
X
X#endif
X
X  va_start(args,fmt);
X  vsprintf(buf,fmt,args);
X  va_end(args);
X
X  do {
X    if(isspace(*here) || *here == 0) {
X      lineend = here;
X      hardnewline = *here == '\n';
X    }
X    if(here - linestart == screenx || *here == '\n') {
X      *lineend = 0;
X      printf("%s\n",linestart);
X      linestart = lineend + 1;
X      if(! hardnewline) while(*linestart == ' ') linestart++;
X      lineswritten++;
X      if(lineswritten == screeny - 1) {
X	more();
X      }
X    }
X    here++;
X  } while(*here != 0);
X  printf("%s\n",linestart);
X}
X
X#ifdef PURE_ANSI
X
Xstatic char *readline(char *prompt)
X{
X  char buffer [16384],*result;
X
X  printf("%s",prompt);
X  fgets(buffer,16384,stdin);
X  buffer [strlen(buffer) - 1] = 0;
X  result = malloc(strlen(buffer) + 1);
X  strcpy(result,buffer);
X  return result;
X}
X
X#endif
X
Xextern char *getline(char *prompt,int function)
X{
X  static char *lineread;
X  time_t starttime,endtime;
X
X  if(lineread != 0) free(lineread);
X
X  starttime = time(0);
X  lineread = readline(prompt);
X  endtime = time(0);
X  delay = (int) difftime(endtime,starttime);
X
X#ifdef UNIX
X
X  switch(function)
X  {
X  case LINE_HISTORY:
X    if(*lineread != 0) add_history(lineread);
X    break;
X  case LINE_NO_HISTORY:
X    break;
X  default:
X    fail();
X  }
X
X#endif
X
X  lineswritten = 0;
X  return lineread;
X}
X
X#ifndef HAS_XMALLOC
X
X/* xmalloc.c -- safe versions of malloc and realloc */
X
X/* Copyright (C) 1991 Free Software Foundation, Inc.
X
X   This file is part of GNU Readline, a library for reading lines
X   of text with interactive input and history editing.
X
X   Readline is free software; you can redistribute it and/or modify it
X   under the terms of the GNU General Public License as published by the
X   Free Software Foundation; either version 1, or (at your option) any
X   later version.
X
X   Readline is distributed in the hope that it will be useful, but
X   WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X   General Public License for more details.
X
X   You should have received a copy of the GNU General Public License
X   along with Readline; see the file COPYING.  If not, write to the Free
X   Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
X
X#include <stdio.h>
X
Xstatic void memory_error_and_abort ();
X
X/* **************************************************************** */
X/*								    */
X/*		   Memory Allocation and Deallocation.		    */
X/*								    */
X/* **************************************************************** */
X
X/* Return a pointer to free()able block of memory large enough
X   to hold BYTES number of bytes.  If the memory cannot be allocated,
X   print an error message and abort. */
X
X/* Changed these functions to return a void *, rather than a char *.
X   In other words they are now more like ANSI malloc than K&R malloc.
X   -- PC, 24.09.92  */
X
Xvoid *
Xxmalloc (bytes)
X     int bytes;
X{
X  char *temp = (char *)malloc (bytes);
X
X  if (!temp)
X    memory_error_and_abort ("xmalloc");
X  return (temp);
X}
X
Xvoid *
Xxrealloc (pointer, bytes)
X     void *pointer;
X     int bytes;
X{
X  char *temp;
X
X  if (!pointer)
X    temp = (char *)malloc (bytes);
X  else
X    temp = (char *)realloc (pointer, bytes);
X
X  if (!temp)
X    memory_error_and_abort ("xrealloc");
X  return (temp);
X}
X
Xstatic void
Xmemory_error_and_abort (fname)
X     char *fname;
X{
X  fprintf (stderr, "%s: Out of virtual memory!\n", fname);
X  abort ();
X}
X
X#endif
END_OF_FILE
if test 5356 -ne `wc -c <'line.c'`; then
    echo shar: \"'line.c'\" unpacked with wrong size!
fi
# end of 'line.c'
fi
if test -f 'napoleon.nr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'napoleon.nr'\"
else
echo shar: Extracting \"'napoleon.nr'\" \(13157 characters\)
sed "s/^X//" >'napoleon.nr' <<'END_OF_FILE'
X.\" -*- nroff -*-
X.Dd February 28, 1993
X.Dt NAPOLEON 1
X.Os
X.Sh NAME
X.Nm napoleon
X.Nd adventure game
X.Sh SYNOPSIS
X.Nm napoleon
X.Sh DESCRIPTION
X.Nm Napoleon
Xis a traditional text adventure game.  On the other hand it is modern
Xin the sense that it has a yacc/bison parser to allow you to type more
Xcomplex commands than the traditional two words.
X.Pp
XYou already know what an adventure game is, I expect... so all that
Xremains is to set the scene for this particular one:
X.Sh INTRODUCTION
XIt was an alarmingly dark night.  In Rusgreve's office, a
Xsolitary candle burned, and spluttered fitfully in the
Xslight breeze.  The Council of War began.  Prendergast lit a
Xsmelly cigarette.
X.Pp
XRusgreve began to explain the problem.  'The difficulty is,'
Xhe said, 'someone is going to have to go in without us
Xhaving first obtained proper information.  It isn't going to
Xbe me.'
X.Pp
XMany, many weeks previously, the investigation had begun. 
XAt first, Rusgreve had claimed there was nothing to worry
Xabout.  After a time, that became a bigger worry than the
Xthings people might have worried about, and so he rewrote
Xhistory so that in fact he had been concerned all along. 
XThe delay rather hindered the efforts to gain information
Xabout the people involved prior to sending in an agent.
X.Pp
XMany, many years previously, the so-called Napoleon gang had
Xbeen normal criminals - yes, they did a bit of time here,
Xand yes, there was the odd bungled attack there.  Then
Xthings changed for the better (although it was worse for
Xeveryone else).  The first and most important change was
Xthat Rusgreve took over as director of the Criminal Re-
Xeducation Bureau, responsible for placing crooks in the nick
Xfor re-education.
X.Pp
XThe second, and less important change was that the Napoleon
Xgang were joined by a fourth member.  This member was known
Xas Professor R. P. P. Tinthywinkle-Croack.  Rusgreve pointed
Xout early on how surprising it was that one of the Napoleon
Xgang was using his real name.  Unfortunately it rapidly
Xbecame obvious that this was not so.  Information was passed
Xout to the Napoleons which was supposed to be top secret,
Xfor your eyes only, printed on red paper.  This led to the
Xuncharitable starting to believe that somewhere in the CRB,
Xa leaker was at work.  An immediate Public Enquiry was set
Xup, which served only to pass still more information into
Xthe hands of Joe Public (who Rusgreve always suspected of
Xbeing a secret Communist - others only suspected Rusgreve of
Xbeing a little simple).
X.Pp
XOne particular piece of information which got into the hands
Xof the Napoleon gang was the knowledge of how to idea-flip. 
XPrendergast was originally employed to try to research this
Xtopic, in order that it could be directed at miscreants, as
Xpart of the re-education programme.  We asked him to explain
Xit to the Council of War so that it could be quoted below:
X.Pp
XWhen you dream, you populate your dreams with other people. 
XHowever those people don't know that they were in your dream
X(unless you tell them, yes, Rusgreve).  Now if we can bring
Xsufficient energy to bear on the problem, we can arrange it
Xso that people's dreams come true; they don't know it, and
Xneither does anyone else unless some action is taken to
Xtransport people to them.  But when this happens, two people
Xcan meet in a dream, and both people will remember the same
Xdream when they wake up.
X.Pp
XNow this is not just of academic interest.  Many people saw
Xa lot of potential in this system for creating everything
Xfrom idyllic gardens to death traps (the use the Napoleon
Xgang were eventually to find).
X.Pp
XWhat was not appreciated was that people's dreams were not
Xbeing realised individually but instead everyone who placed
Xtheir dreams at the disposal of the idea-flipping machine
Xhad their dreams combined into a single very large system. 
XIn the end portions of the system became quite well ordered. 
XIn places this was because people deliberately dreamed in
Xsuch a way as to create improved order while in others it
Xwas due simply to people with efficient minds dreaming.
X.Pp
XThis caused the Napoleon gang a lot of problems.  The point
Xwas that they wanted to create death traps to which people
Xcould be whisked as soon as they fell asleep.  But the
Xmajority of the dreamland was neutral or good, since wide
Xpublication of the invention had been prevented;  apart from
Xthe Napoleon gang, everyone who knew about the invention was
Xconcerned with creating safe places for people to go.
X.Pp
XHowever there are nasty places.  These, however, have been
Xwatered down by the proximity of good areas.  They are now
Xmuch more what you make of them than unreservedly bad.  That
Xis, you have to survive by your wits.
X.Pp
XNext Rusgreve himself gave a short briefing to the meeting,
Xreading from a large pad in front of him on the table:
X.Pp
XNow it wouldn't be so bad if the Napoleon gang hadn't
Xmanaged to steer anyone to the unpleasant areas, but they
Xhave.  They created for themselves a complex of rooms with
Xexits leading to all the bad places; then they entered the
Xdreamland looking for someone important who could be
Xkidnapped and held hostage there.  And they found someone:
Xthe Princess Caroline, who was dreaming naturally and was
Xunaware that she had moved from dream to semi reality.
X.Pp
XShe has been asleep ever since, and cannot be woken.  It has
Xbeen put about that she is ill, but those people knowing
Xabout the idea-flipping secret know that she is not ill.  So
Xdo the Napoleon gang, who have asked for a large fee in
Xreturn for releasing her.  But someone's going to have to go
Xinto the dreamland to let her out.
X.Pp
X\|'Well volunteered,' said Rusgreve to you at about this
Xpoint.
X.Pp
X\|'Hmmm,' said Prendergast, 'I suppose we could easily put
Xsomeone into the Napoleon gang's rooms that lead to all the
Xnasty bits.  It's just if they get killed, they won't come
Xback, just like the Princess Caroline didn't.'
X.Pp
X\|'We won't get anywhere without taking a few risks,' said
XRusgreve, kindly.
X.Pp
X\|'We don't know what unpleasant things the Napoleon gang
Xmight have put there for unexpected visitors, though,' said
XPrendergast.
X.Pp
XThe exchanges went on for quite some time.  In the end
XRusgreve, as director of the Bureau, overruled all
Xobjections and annouced that Something Must be Done.  You
Xare on your way.
X.Pp
X\|'Alright then,' said Prendergast with a sigh.  'We'll be
Xable to keep watch over you until you leave the Napoleons'
Xplace for the various nasty bits, and make sure nothing too
Xnasty happens.  But we won't be able to help you operate
Xwhatever the Napoleons have put there, and we won't be able
Xto help you once you get past there into the rest of the
Xdreamland.'
X.Pp
X\|'And good luck,' finished Rusgreve. 'We appreciate what you
Xare doing.  We will give you the papers you need to carry
Xout this mission to the best of your ability - and remember
Xthe most important thing.  Read the scroll in the office at
Xthe centre of the Napoleons' headquarters.'
X.Sh SHEET 604
XTarget Information -- Napoleon Gang (sheet # 604)
X.Pp
XUp to date information on the Napoleons is difficult to come
Xby.  Over the last few years they have moved from being
Xreally quite ordinary criminals who we have been able to
Xhave a try at re-educating sometimes to their present form.
X.Pp
XIt is popularly believed that they 'hit the big time' as the
Xleader liked to put it, when the information on idea-
Xflipping fell into their hands, apparently leaked by someone
Xat the Bureau.  We would like to stress that this is almost
Xcertainly not the case and it is thought to be highly
Xunlikely that anyone at the Bureau could have been
Xresponsible for the sudden rise to power that the Napoleon
Xgang have experienced.
X.Pp
XThe reason we haven't got much information to place in this
Xreport is that the Napoleons have become very accustomed to
Xsecrecy.  Last year one of our operatives had to pretend to
Xbe a window-cleaner after he was seen fixing an electronic
Xdevice to their window frame.  It is believed that his cover
Xmay have been compromised by someone at the Bureau and
Xeveryone is urged to be uncommonly vigilant to prevent
Xunauthorised activities such as leaking from being carried
Xon.  The attached device subsequently only ever recorded
Xpeople berating the Bureau for inefficiency in catching
Xcriminals.
X.Pp
XThe Napoleon gang is, however, known to have three members,
Xas well as Professor R. P. P. Tinthywinkle-Croack.  Apart
Xfrom the Professor, all the members use false names, and so
Xthe accuracy of what follows cannot be guaranteed.
X.Pp
XNapoleon target # 1: Richard Entwhistle-SmytheCumbert
X.Pp
XCommonly uses the alias of Fred Smith.
X.Pp
XServed five years in jail for robbery with violence, while
Xthe Napoleons were in a less subtle phase.
X.Pp
XCommonly believed to be the leader of the outfit, RESC
Xseemed to be the first to hear of the opportunity available
Xwith the idea-flipping machine.  He approached Professor
XTinthywinkle-Croack to bring him in on the project.  The
Xmeeting was monitored, but unfortunately took place in a
Xlanguage for which a translator could not be found for
Xanother three weeks, by which time it was, of course, far
Xtoo late.
X.Pp
XIf you see RESC, take great care.  He may attack with a
Xsavagery learnt during his days as a robber.  He may try to
Xtrick you, using his undoubted verbal skill.  He may ignore
Xyou and hope you go away.  He might attempt to recruit you,
Xand we wouldn't want that, would we?
X.Pp
XRESC may be recognised in the dreamland by his tendency to
Xend up leading what ever bizarre operation someone has
X\|'dreamed' up.  One of nature's leaders, he will lead you
Xinto compromising the Bureau if you are not careful.  Be
Xwarned.  If you change sides, the whole arsenal of the
XBureau's sophisticated tools will be pointed at you.
X.Pp
XNapoleon target # 2: Charlie Zzzwocke
X.Pp
XChanged his name by Deed Poll in order that he could take
Xpart in a bank fraud.
X.Pp
XCommonly uses the alias of Uncle Z, which is not very
Xconvincing, but you believe that that is his name when he is
Xstanding over you asking whether you want to buy any
Xinsurance.
X.Pp
XA natural thug, he is available for any operation involving
Xcrimes of violence in a dark alley.  He was brought into the
Xfraud because someone realised that the person most at risk
Xwas the one with the funny name - and predictably Zzzwocke
Xgot caught.  He served three months at an open prison before
Xabsconding.
X.Pp
XWhile on the run, he took part in an attack on a bank. 
XUnfortunately the bank had folded several months previously
Xand there was now nothing in the branch except a pile of old
Xpaying-in slips.  He took these, and started to run out
Xbefore falling over the doormat and letting his gun off
Xacross the street.  RESC saw him and thought him the ideal
Xgang member - frightening to anyone not wanting insurance,
Xbut not intelligent enough to have leadership ambitions. 
XRESC removed him from under the noses of the police.
X.Pp
XOf all the gang members, Zzzwocke is the least at home in
Xdreamland.  'Namby-pamby' pursuits like dreaming are not for
Xhim, and a sudden shock will sometimes cause him to wake up.
X.Pp
XNapoleon target # 3: Brian Turner
X.Pp
X[ Note: the above name is believed to be too ordinary to be
Xcorrect.  Would anyone who would like to suggest an
Xalternative name please contact the information desk on the
Xnumber shown below. ]
X.Pp
XNot using any aliases, Brian Turner is a supremely confident
Xtalker who could sell double glazing to... well, anyone
Xreally.  He has been involved in organised crime ever since
Xhis childhood, when he 'organised' people to distract the
Xstore detective while his friends helped themselves to
Xchocolate bars.  Predictably, he got caught, and was
Xcautioned.
X.Pp
XLater he turned his attention to selling timeshare holidays. 
XThis ended when he got so good at it that he sold himself
Xone, forgetting all the bad points, like that it was still
Xjust a hole in the ground.
X.Pp
XLater he turned his attention to getting people to put
Xthousands of pounds in brown envelopes and leave them in the
Xhotel safe.  One of the people he did this to was our own
XRusgreve, and this was the reason why Rusgreve decided to go
Xinto crime prevention, in order to get his own back.  This
Xparticular misdeed therefore had repercussions for the crime
Xstatistics far beyond its own ability to increment them.
X.Pp
XFinally, he joined the Napoleons when a man who had just
Xbeen cheated turned nasty.  That man was Mr Zzzwocke.
X.Pp
XIf you have any further information to add to this dossier,
Xplease ring 4733 and ask for Peabody.
X.Pp
XIf you believe that your cover may have been compromised,
Xplease ring 8955 and ask to speak to the Editor.
X.Sh SHEET 904
XTarget Information -- Bureau Leaker (sheet # 904)
X.Pp
X(this page intentionally left blank)
X.Pp
XIf you have any further information to add to this dossier,
Xplease ring 4733 and ask for Peabody.
X.Pp
XIf you believe that your cover may have been compromised,
Xplease ring 8955 and ask to speak to the Editor.
X.Pp
X.Sh DIAGNOSTICS
XExit status is always 0.  All errors are reported interactively by the
Xprogram.
X.Sh BUGS
XSurely not?
X.Sh HISTORY
XThis is the first version.  History is just about to start... :-)
END_OF_FILE
if test 13157 -ne `wc -c <'napoleon.nr'`; then
    echo shar: \"'napoleon.nr'\" unpacked with wrong size!
fi
# end of 'napoleon.nr'
fi
if test -f 'noughts.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'noughts.c'\"
else
echo shar: Extracting \"'noughts.c'\" \(4705 characters\)
sed "s/^X//" >'noughts.c' <<'END_OF_FILE'
X/* Copyright (C) 1992 Pete Chown.
X
X   Here is my latest adventure game, Napoleon (see the documentation
X   if you don't know why it's called that).  Have fun... (don't cheat,
X   even though you've got the source :-) ).
X
X   This game is free software; you can redistribute it and/or modify
X   it under the terms of the GNU General Public License as published by
X   the Free Software Foundation; either version 1, or (at your option)
X   any later version.
X
X   The game is distributed in the hope that it will be useful, but
X   WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X   General Public License for more details.
X
X   The GNU General Public License is often shipped with GNU software, and
X   is generally kept in a file called COPYING or LICENSE.  If you do not
X   have a copy of the license, write to the Free Software Foundation,
X   675 Mass Ave, Cambridge, MA 02139, USA. */
X
X#include "adv.h"
X
Xstatic void showboard(char *board)
X{
X  printf("The board currently contains:\n\n   |   |\n %c | %c | %c\n   |   |"
X"\n---+---+---\n   |   |\n %c | %c | %c\n   |   |\n---+---+---\n   |   |\n %c"
X" | %c | %c\n   |   |\n",board [0],board [1],board [2],board [3],board [4],board [5],board [6],board [7],board [8]);
X}
X
Xstatic void playersmove(char *board,char playerch)
X{
X  char *line;
X  signed char square;
X
X  printf("\nPlease enter your move:\n");
X  for(;;)
X  {
X    line = getline(">",LINE_NO_HISTORY);
X    square = atoi(line) - 1;
X    if(square < 0 || square > 8 || ! isdigit(board [square])) format("The Gr"
X"andmaster says, 'You are not allowed to play there, my friend.'"); else break;
X  }
X  board [square] = playerch;
X}
X
X#define ROW(a,b,c) \
X  if(board [a] == 'X' && board [b] == 'X' && board [c] == 'X') return 'X';\
X  if(board [a] == 'O' && board [b] == 'O' && board [c] == 'O') return 'O'
X
Xstatic int whowon(char *board)
X{
X  ROW(0,1,2);
X  ROW(3,4,5);
X  ROW(6,7,8);
X  ROW(0,3,6);
X  ROW(1,4,7);
X  ROW(2,5,8);
X  ROW(0,4,8);
X  ROW(2,4,6);
X
X  return 0;
X}
X
Xstatic int movecomputer(char *board,char compch,int nummoves,bool undomove)
X{
X  char goodmoves [9],numgoodmoves = 0,otherch = compch == 'X' ? 'O' : 'X',winner,i;
X  signed char score = 2;
X
X  if(nummoves == 0) {
X    board [rnd(9)] = compch;
X    return 0;
X  }
X
X  winner = whowon(board);
X  if(winner == compch) return 1;
X  if(winner == otherch) return -1;
X  if(nummoves == 9) return 0;
X
X  for(i = 0;i < 9;i++)
X  {
X    if(isdigit(board [i])) {
X      signed char thisposition;
X
X      board [i] = compch;
X      thisposition = movecomputer(board,otherch,nummoves + 1,TRUE);
X      board [i] = i + '1';
X
X      if(thisposition < score) {
X        score = thisposition;
X	numgoodmoves = 0;
X      }
X      if(thisposition == score) {
X	goodmoves [(int) numgoodmoves++] = i;
X      }
X    }
X  }
X
X  if(numgoodmoves == 0 || score == 2) fail();
X  if(! undomove) board [goodmoves [rnd(numgoodmoves)]] = compch;
X
X  return -score;
X}
X
Xstatic int doagame(bool playerstarts)
X{
X  char board [] = "123456789",nummoves = 0,winner,playerch,compch;
X  bool playergo = playerstarts;
X
X  if(playerstarts) {
X    playerch = 'X';
X    compch = 'O';
X  } else {
X    playerch = 'O';
X    compch = 'X';
X  }
X
X  while(whowon(board) == 0 && nummoves < 9)
X  {
X    showboard(board);
X    if(playergo) playersmove(board,playerch); else {
X      format("The Grandmaster ponders for a while, and then makes his move:\n");
X      more();
X      movecomputer(board,compch,nummoves,FALSE);
X    }
X    playergo = ! playergo;
X    nummoves++;
X  }
X
X  winner = whowon(board);
X  if(winner == 'X' && playerstarts) return 1;
X  if(winner == 'O' && playerstarts) return 0;
X  if(winner == 'X') return 0;
X  if(winner == 'O') return 1;
X  return 2;
X}
X
X/* playnoughts() returns 0 for a drawn match (the computer should never lose, at least), 1 for a
X   match the player just lost, and 2 for a match the player lost by a big margin.  */
X
Xextern int playnoughts(void)
X{
X  int computer = 0,player = 0,drawn = 0;
X  bool playerstarts = TRUE;
X
X  while(computer + player + drawn < 3)
X  {
X    switch(doagame(playerstarts))
X    {
X    case 0:
X      format("The Grandmaster says, 'Noughts and Crosses is a fine game, do "
X"you not agree?'");
X      computer++;
X      break;
X    case 1:
X      format("The Grandmaster looks a little bit crestfallen, and wipes out "
X"the board ready for his next game.");
X      player++;
X      break;
X    case 2:
X      format("The Grandmaster says, 'Would you believe, some people think th"
X"at it is always possible to force a draw at noughts and crosses?'");
X      drawn++;
X      break;
X    }
X    playerstarts = ! playerstarts;
X  }
X
X  if(drawn == 2 && computer == 1) return 1;
X  if(computer <= player) return 0;
X  return 2;
X}
END_OF_FILE
if test 4705 -ne `wc -c <'noughts.c'`; then
    echo shar: \"'noughts.c'\" unpacked with wrong size!
fi
# end of 'noughts.c'
fi
if test -f 'parse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'parse.c'\"
else
echo shar: Extracting \"'parse.c'\" \(11926 characters\)
sed "s/^X//" >'parse.c' <<'END_OF_FILE'
X/* Copyright (C) 1992 Pete Chown.
X
X   Here is my latest adventure game, Napoleon (see the documentation
X   if you don't know why it's called that).  Have fun... (don't cheat,
X   even though you've got the source :-) ).
X
X   This game is free software; you can redistribute it and/or modify
X   it under the terms of the GNU General Public License as published by
X   the Free Software Foundation; either version 1, or (at your option)
X   any later version.
X
X   The game is distributed in the hope that it will be useful, but
X   WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X   General Public License for more details.
X
X   The GNU General Public License is often shipped with GNU software, and
X   is generally kept in a file called COPYING or LICENSE.  If you do not
X   have a copy of the license, write to the Free Software Foundation,
X   675 Mass Ave, Cambridge, MA 02139, USA. */
X
X#include "adv.h"
X#include "lang.h"
X
Xint listedobjects,objectlist [200],said,subject;
Xbool all,speechflag;
Xchar *yaccstring;
Xint direction,yaccplayer;
X
Xstatic char adjectives [4] [20];
Xstatic int numadjectives;
X
Xstatic int getnpc(int what)
X{
X  int oldwhat;
X
X  do {
X    oldwhat = what;
X    what = objects [what].parent;
X  } while((! objects [what].objtype.alive || objects [what].next == oldwhat
X	   || objects [what].objtype.player)
X	&& ! objects [what].objtype.room);
X  if(objects [what].objtype.alive) return what;
X  return 0;
X}
X
Xstatic bool heldbynpc(int what)
X{
X  return getnpc(what) != 0;
X}
X
Xextern void moveplayer(void)
X{
X  int playerroom = getroom(yaccplayer),dest;
X  bool failquietly = FALSE;
X
X  switch(direction)
X  {
X  case NORTH:
X    dest = objects [playerroom].n;
X    break;
X  case SOUTH:
X    dest = objects [playerroom].s;
X    break;
X  case WEST:
X    dest = objects [playerroom].w;
X    break;
X  case EAST:
X    dest = objects [playerroom].e;
X    break;
X  case NORTHWEST:
X    dest = objects [playerroom].nw;
X    break;
X  case NORTHEAST:
X    dest = objects [playerroom].ne;
X    break;
X  case SOUTHWEST:
X    dest = objects [playerroom].sw;
X    break;
X  case SOUTHEAST:
X    dest = objects [playerroom].se;
X    break;
X  case UP:
X    dest = objects [playerroom].u;
X    break;
X  case DOWN:
X    dest = objects [playerroom].d;
X    break;
X  default:
X    fail();
X  }
X  if(dest != 0) failquietly = TRUE;
X  dest = premove(yaccplayer,dest);
X  if(dest == 0) {
X    if(! failquietly) format("You don't seem to be able to get through that "
X"way.");
X  } else {
X    if(! illuminated(getroom(yaccplayer)) && ! illuminated(dest)) {
X      format("\nYou got eaten by the giant spider in the dark.  Sorry.\n");
X      dead = TRUE;
X    } else {
X      detachfromchain(yaccplayer);
X      objects [yaccplayer].next = objects [dest].inside;
X      objects [yaccplayer].parent = dest;
X      if(objects [dest].inside != 0) objects [objects [dest].inside].parent = yaccplayer;
X      objects [dest].inside = yaccplayer;
X      descr = TRUE;
X    }
X  }
X  postmove();
X}
X
Xextern bool strcmp_ci(char *a,char *b)
X{
X  while(tolower(*a) == tolower(*b))
X  {
X    if(*a == 0) return TRUE;
X    a++;
X    b++;
X  }
X  return FALSE;
X}
X
Xextern int rnd(int range)
X{
X  return ((rand() & 0xffff) * range) >> 16;
X}
X
Xextern void yyerror(char *s)
X{
X  switch(rnd(3))
X  {
X  case 0:
X    format("Eh?");
X    break;
X  case 1:
X    format("You're mumbling again.");
X    break;
X  case 2:
X    format("Come again?");
X    break;
X  }
X}
X
Xextern void command(int player,char *string)
X{
X  static char *oldline;
X
X  if(oldline != 0) free(oldline);
X  yaccstring = oldline = xmalloc(strlen(string) + 1);
X  strcpy(yaccstring,string);
X  yaccplayer = player;
X  listedobjects = 0;
X  numadjectives = 0;
X  speechflag = FALSE;
X  all = FALSE;
X  yyparse();
X}
X
Xextern void addadjective(char *adj)
X{
X  if(numadjectives != 4) strcpy(adjectives [numadjectives++],adj);
X}
X
Xextern void addobject(int objectno)
X{
X  if(objectno != -1) {
X    if(ispresent(objectno,yaccplayer)) objectlist [listedobjects++] = objectno;
X    else format("I can't see %s anywhere near here.",quickname("the",objectno));
X  }
X  else format("I don't know anything like that (1)!");
X  numadjectives = 0;
X}
X
Xstatic void addchain(int this)
X{
X  while(this != 0)
X  {
X    objectlist [listedobjects++] = this;
X    this = objects [this].next;
X  }
X}
X
Xextern void addfirstdescendants(int parent)
X{
X  addchain(objects [parent].above);
X  addchain(objects [parent].below);
X  addchain(objects [parent].inside);
X}
X
Xstatic bool checkadjectives(char *name)
X{
X  int i;
X  char buffer [20];
X
X  for(i = 0;i < numadjectives;i++)
X  {
X    sprintf(buffer,"_%s_",adjectives [i]);
X    if(! strstr(name,buffer) && strncmp(name,buffer + 1,strlen(buffer + 1))) return FALSE;
X  }
X
X  return TRUE;
X}
X
Xextern int getobject(char *noun)
X{
X  int i,result = -1;
X  char *objectname = noun,*a = "a",*extras = "";
X  bool goodmatch = FALSE;
X
X  while(strchr(objectname,' ')) objectname = strchr(objectname,' ') + 1;
X  for(i = 0;objectname [i] != 0;i++) objectname [i] = tolower(objectname [i]);
X
X  for(i = 0;objects [i].examine != (char *) 1;i++)
X  {
X    if(objects [i].shortname != 0) {
X      if(strlen(objects [i].shortname) >= strlen(noun)) {
X	if(strcmp_ci(objects [i].shortname + strlen(objects [i].shortname) - strlen(noun),noun)) {
X	  if(checkadjectives(objects [i].shortname)) {
X	    goodmatch = TRUE;
X	    extras = "";
X	    if(ispresent(i,yaccplayer) || speechflag) {
X	      if(heldbynpc(i) && ! speechflag) {
X		format("%s won't let you do anything with that.",quickname("The",getnpc(i)));
X		return -1;
X	      } else result = i;
X	    } else {
X	      objectname = quickname("",i);
X	    }
X	  } else {
X	    if(! goodmatch) extras = " like that";
X	  }
X	}
X      }
X    }
X  }
X  if(result == -1) {
X    if(strchr("aeiou",tolower(objectname [0]))) a = "an";
X    format("I can't see %s %s%s here.",a,objectname,extras);
X  }
X  numadjectives = 0;
X  return result;
X}
X
Xextern char *quickname(char *newword,int i)
X{
X  static char buffer [32];
X  char *a = strchr(objects [i].longname,' ');
X
X  if(a == 0) return objects [i].longname;
X  else sprintf(buffer,"%s %s",newword,a + 1);
X
X  return *newword == 0 ? buffer + 1 : buffer;
X}
X
Xextern bool ispresent(int this,int player)
X{
X  return getroom(this) == getroom(player);
X}
X
Xextern void examine(void)
X{
X  int i;
X
X  for(i = 0;i < listedobjects;i++)
X  {
X    format("%s\n",objects [objectlist [i]].examine);
X  }
X  listedobjects = 0;
X}
X
Xextern void do_read(void)
X{
X  int i;
X
X  for(i = 0;i < listedobjects;i++)
X  {
X    switch(objectlist [i])
X    {
X    case 102: /* scroll */ case 123: /* card */
X      format("%s\n",objects [objectlist [i]].examine);
X      break;
X    default:
X      format("You can't read that!");
X      break;
X    }
X  }
X  listedobjects = 0;
X}
X
Xextern void get(void)
X{
X  int i;
X  bool gotsomething = FALSE;
X
X  if(all) addfirstdescendants(getroom(yaccplayer));
X  for(i = 0;i < listedobjects;i++)
X  {
X    if(objects [objectlist [i]].objtype.virtual == FALSE) {
X      detachfromchain(objectlist [i]);
X      addtochain(objectlist [i],yaccplayer,& objects [yaccplayer].inside);
X      gotsomething = TRUE;
X      format("You take %s.",quickname("the",objectlist [i]));
X    } else {
X      if(! objects [objectlist [i]].objtype.player)
X	format("You can't take %s!",quickname("the",objectlist [i]));
X    }
X  }
X  listedobjects = 0;
X  if(all && ! gotsomething) format("There is nothing here that you can reall"
X"y take!");
X}
X
Xextern void drop(void)
X{
X  int i;
X  bool gotsomething = FALSE;
X
X  if(all) addfirstdescendants(yaccplayer);
X  for(i = 0;i < listedobjects;i++)
X  {
X    if(ancestor(yaccplayer,objectlist [i])) {
X      detachfromchain(objectlist [i]);
X      addtochain(objectlist [i],getroom(yaccplayer),& objects [getroom(yaccplayer)].inside);
X      gotsomething = TRUE;
X      format("You drop %s.",quickname("the",objectlist [i]));
X    } else {
X      if(! all) format("You are not carrying %s!",quickname("the",objectlist [i]));
X    }
X  }
X  if(all && ! gotsomething) format("You are not carrying anything!");
X  listedobjects = 0;
X}
X
Xextern void put(int destination,int *chain)
X{
X  int i;
X  bool gotsomething = FALSE;
X
X  if(!objects [destination].objtype.container && chain == & objects [destination].inside) {
X    format("You won't be able to put things in that very easily!\n");
X    return;
X  }
X
X  if(all) addfirstdescendants(yaccplayer);
X  for(i = 0;i < listedobjects;i++)
X  {
X    if(! objects [objectlist [i]].objtype.virtual) {
X      detachfromchain(objectlist [i]);
X      addtochain(objectlist [i],destination,chain);
X      gotsomething = TRUE;
X      format("You put %s in position.",quickname("the",objectlist [i]));
X      justput(objectlist [i],destination,chain);
X    } else {
X      if(! all) format("You can't move %s!",quickname("the",objectlist [i]));
X    }
X  }
X  if(all && ! gotsomething) format("You are not carrying anything!");
X  listedobjects = 0;
X}
X
Xextern void give(int destination)
X{
X  int i;
X  bool gotsomething = FALSE;
X
X  if(all) addfirstdescendants(yaccplayer);
X  for(i = 0;i < listedobjects;i++)
X  {
X    if(ispresent(yaccplayer,objectlist [i])) {
X      if(wantsit(destination,objectlist [i])) gotsomething = TRUE;
X    } else {
X      if(! all) format("You are not carrying %s!",quickname("the",objectlist [i]));
X    }
X  }
X  if(all && ! gotsomething) format("You are not carrying anything!");
X  listedobjects = 0;
X}
X
Xextern int getbeastie()
X{
X  int posn = objects [getroom(yaccplayer)].inside;
X
X  while(posn != 0 && (! objects [posn].objtype.alive || objects [posn].objtype.player))
X    posn = objects [posn].next;
X  return posn;
X}
X
Xextern void speech(int recipient,int type)
X{
X  if(! ispresent(recipient,player)) {
X    format("You can't see anything like that near here!");
X    return;
X  }
X
X  if(! objects [recipient].objtype.alive) {
X    format("Strangely enough, %s takes no notice of you!",quickname("the",recipient));
X    return;
X  }
X
X  if(type == 0 && said == 1) {
X    type = 1;
X    objectlist [0] = subject;
X    listedobjects = 1;
X  }
X
X  if(type == 0) {
X    switch(said)
X    {
X    case 0:
X      if(! dogreeting(recipient)) format("%s says, 'Hello!'",quickname("The",recipient));
X      break;
X    case 2:
X      doyes(recipient);
X      break;
X    case 3:
X      dono(recipient);
X      break;
X    case 4:
X      if(! dofarewell(recipient)) format("%s says, 'Goodbye!'",quickname("Th"
X"e",recipient));
X      break;
X    case 5:
X      if(! referred_to(recipient)) format("%s says, 'You what?!'",quickname("The",recipient));
X      break;
X    default:
X      fail();
X    }
X  } else {
X    int i;
X    bool gotsomething = FALSE;
X
X    if(all) addfirstdescendants(getroom(recipient));
X    for(i = 0;i < listedobjects;i++)
X    {
X      if(ancestor(getroom(recipient),objectlist [i])) {
X	examineobject(recipient,objectlist [i]);
X      } else {
X	if(! all) format("%s says 'What ever's that?'",quickname("The",recipient));
X      }
X    }
X    if(all && ! gotsomething) format("%s says 'I can't see anything!'",quickname("The",recipient));
X    listedobjects = 0;
X  }
X}
X
Xextern void hack(void)
X{
X  char *password = "";
X
X  format("So you want to hack the game, for debugging of course... now enter"
X" the password:\n");
X  if(! hacker) password = getline(">",LINE_NO_HISTORY);
X  if(strcmp_ci(password,"tarnisher") || hacker) {
X    int dest;
X
X    format("Which room do you want?\n");
X    dest = atoi(getline(">",LINE_NO_HISTORY));
X    detachfromchain(yaccplayer);
X    objects [yaccplayer].next = objects [dest].inside;
X    objects [yaccplayer].parent = dest;
X    if(objects [dest].inside != 0) objects [objects [dest].inside].parent = yaccplayer;
X    objects [dest].inside = yaccplayer;
X    descr = TRUE; 
X    hacker = TRUE;
X  } else format("Wrong password");
X}
X
Xextern void destroy(int what)
X{
X  detachfromchain(what);
X  /* Now make the object hang off the storage room.  It is not a good idea to make it hang off the
X     root, because then we can't go and look at anything (looking in the root object doesn't
X     work).  */
X  addtochain(what,59,& objects [59].inside);
X}
END_OF_FILE
if test 11926 -ne `wc -c <'parse.c'`; then
    echo shar: \"'parse.c'\" unpacked with wrong size!
fi
# end of 'parse.c'
fi
echo shar: End of archive 3 \(of 4\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
