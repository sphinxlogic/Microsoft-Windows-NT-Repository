Path: uunet!paladin.american.edu!howland.reston.ans.net!zaphod.mps.ohio-state.edu!uwm.edu!ogicse!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i009:  dinkum3 - australian text adventure game, V2.12, Part04/07
Message-ID: <4520@master.CNA.TEK.COM>
Date: 9 Feb 93 20:02:22 GMT
Article-I.D.: master.4520
Sender: news@master.CNA.TEK.COM
Lines: 1937
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1688

Submitted-by: Gary Allen <gary@sun.mech.uq.oz.au>
Posting-number: Volume 17, Issue 9
Archive-name: dinkum3/Part04
Supersedes: dinkum2: Volume 15, Issue 36-43
Environment: Unix, DOS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 7)."
# Contents:  opener.c pusher.c
# Wrapped by billr@saab on Mon Feb  8 13:40:51 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'opener.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'opener.c'\"
else
echo shar: Extracting \"'opener.c'\" \(31331 characters\)
sed "s/^X//" >'opener.c' <<'END_OF_FILE'
X#define OPNR
X#include "dink_sym.h"
X#include "dink_glb.h"
X
X#if (PROTOTYPE)
Xvoid dialer(int n)
X#else
Xvoid dialer(n)
Xint n ;
X#endif
X/*****************************/
X/*      "dial" command"      */
X/*     Version:  Mk 1.1      */
X/*      29 October 1989      */
X/*****************************/
X{
X
X/* deal with the question of "What is the combination?" */
Xif (tag[V_what]) {
Xprintf("I really don't know.  You might try looking around for a\n") ;
Xprintf("series of numbers. Sometimes that can be a clue to the\n") ;
Xprintf("actual combination.\n") ;
X	return ;
X}
X
X/* See if the combination was dialed in the right place */
Xif ((n == R_office_mang)&&(Picture->Status >= S_open)) {
X	if (tag[V_0] && tag[V_49] && tag[V_67] && tag[V_82]) {
X		printf ("Click!! \n");
X		Safe->Status = S_dialed ;
X		return ; 
X	}
Xprintf ("You turned the dial but nothing happened.  I think you \n");   
Xprintf ("dialed the wrong thing. \n");
X	return ; 
X}
Xprintf ("How am I supposed to dial that? \n");
X} /* --- end of the "dialer" subroutine --- */
X
X 
X#if (PROTOTYPE)
Xvoid inventer(void)
X#else
Xvoid inventer()
X#endif
X/*****************************/
X/*   "inventory" command     */
X/*     Version:  Mk 1.0      */
X/*       11 March 1989       */
X/*****************************/
X{
X#if (PROTOTYPE)
Xvoid objector(OBJECT_STRUCT*) ;
X#endif
X
Xregister int i;
Xint j_ws ;
XOBJECT_STRUCT *pnt, *point ;
X 
Xj_ws = 0 ;
Xpnt = object ;
Xfor (i = 0; i < Objcnt; i++) {
X	if ((pnt++)->Location == B_have) {
X		++j_ws ;
X		point = (pnt - 1) ;
X	}
X}
Xif ((j_ws == 0)&&(gleep_count == 0)) {
X	printf("You've got NOTHING!! \n") ;
X	return ;
X}
Xif (j_ws >= 1) {
X	if (j_ws == 1) {
X		printf("You are carrying ") ;
X		objector(point);
X		printf ("\n") ;
X	}
X	else {
X		printf ("You are carrying the following: \n");
X		pnt = object ;
X		for (i = 0; i < Objcnt; i++) {
X			if ((pnt++)->Location == B_have) {
X				printf("        ") ;
X				point = (pnt - 1) ;
X				objector(point);
X				printf("\n") ;
X			}
X		}
X	}
X}
Xif (gleep_count > 0) {
X	if (gleep_count == 1) {
X		printf("You have one gleep.\n") ;
X		return ;
X	}
X	printf("You are carrying %d gleeps. \n",gleep_count) ;
X}
X
X} /* --- end of the "inventor" subroutine --- */
X 
X#if (PROTOTYPE)
Xvoid drinker(void)
X#else
Xvoid drinker()
X#endif
X/*****************************/
X/*     "drink" command       */
X/*     Version:  Mk 1.0      */
X/*       11 March 1989       */
X/*****************************/
X{
X#if (PROTOTYPE)
Xvoid no_booze(void) ;
X#endif
X
Xif (tag[V_can]) {
X	if (Can->Location == B_have) {
X		printf("The XXXX keeps on coming on ? \n") ;
Xprintf("I think not, for there is no Fourex left for me to drink!\n") ;
X	}
X	else no_booze() ;
X	return ;
X}
X
Xif (tag[V_bottle]) {
X	if (Bottle->Location == B_have) {
Xprintf("Some greedy larrikin has drunk up all of the Black Swan! \n") ;
X	printf("Bad on Him! There is none left for me! \n") ;
X	return ;
X	}
X	no_booze() ;
X	return ;
X}
X
Xif (tag[V_water]) {
X	printf("There is no water here that I am willing to drink.\n") ;
X	return ;
X}
X	
Xprintf ("What exactly do you want me to drink? \n");
Xreturn; 
X
X} /* --- end of the "drinker" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid no_booze(void)
X#else
Xvoid no_booze()
X#endif
X/*****************************/
X/*     Version:  Mk 1.0      */
X/*     7 December 1992       */
X/*****************************/
X{
Xprintf ("You don't have it in your possession to drink!\n");
Xreturn ;
X} /* --- end of the "no_booze" subroutine --- */
X
X 
X#if (PROTOTYPE)
Xvoid reader(int n)
X#else
Xvoid reader(n)
Xint n ;
X#endif
X/*****************************/
X/*      "read" command       */
X/*     Version:  Mk 1.2      */
X/*      23 December 1992     */
X/*****************************/
X{
Xregister int i ;
Xint m, sw_no_see ;
X
XOBJECT_STRUCT *point ;
XREAD_STRUCT *pnt ;
X
X#if (PROTOTYPE)
Xvoid rdtxt(int) ;
XOBJECT_STRUCT* point_to_object(int) ;
X#else
XOBJECT_STRUCT* point_to_object() ;
X#endif
X
X/* reject an isolated "read" command */
Xif (tag[V_VERB_ONLY]) { 
X		printf ("What exactly do you want me to read? \n");
X		return;
X}
X
Xsw_no_see = FALSE ;
Xpnt = read_object ;
Xfor (i = 0; i < Read_objcnt; i++) {
X	m = pnt->ID ;
X	if (!(pnt++)->Readable) continue ;
X	if (tag[m]) {
X		point = (OBJECT_STRUCT*)point_to_object(m) ;
X		if (((point->Location == n)&&(point->Type == Z_unmovable))
X			||(point->Location == B_have)) rdtxt(m) ;
X		else {
X			if (point->Type == Z_unmovable) {
X				sw_no_see = TRUE ;
X				continue ;
X			}
X			else
Xprintf ("I can't read it because it isn't in my possession. \n");
X		}
X		return ;
X	}
X}
X
X/* Deal with unreadable objects */
Xif (sw_no_see) printf ("I don't see how I can read that.\n") ;
Xelse printf("There is no way in which I can read that. \n");
Xreturn ;
X
X} /* --- end of the subroutine "reader" --- */
X
X#if (PROTOTYPE)
Xvoid locker(int n)
X#else
Xvoid locker(n)
Xint n ;
X#endif
X/*****************************/
X/*     "lock" command        */
X/*      Version: Mk 1.0      */
X/*      27 January 1992      */
X/*****************************/
X{
Xif (tag[V_VERB_ONLY]) {
X	printf ("What do you want me to lock? \n");
X	return; 
X}
X
Xif (room[n][M_unmov_obj]) {
X	switch (n) {
X
X	/* Managers office */
X	case R_office_mang:
Xif (tag[V_safe]) {
X	if (Picture->Status == S_open) { 
X		if (tag[V_key]) {
Xprintf("You can't lock a combination safe with a key (no keyhole)!\n") ;
X			return ;
X		}
X
X		switch (Safe->Status) { 
X		case S_open:
Xprintf("You close the safe and it locks with a \"click\". \n");
X			break ;
X
X		case S_dialed:
Xprintf("You give the safe's dial a twist, locking the safe. \n");
X			break ;
X
X		default:
X			printf("The safe is already locked!\n") ;
X			return ;
X		}
X		Safe->Status = S_closed ;
X	}
X	else printf("I don't see a safe to lock.\n") ;
X}
Xelse  printf("You're wasting your time.  You can't lock that! \n");
Xreturn;
X
X	/* office entrance */
X	case R_office_entr:
X	if (tag[V_door]) {
X		if (tag[V_key]) {
X			if (Key->Location != B_have) {
Xprintf("You don't have the key to this door in your possession! \n");
X				return ;
X			}
X		}
X		else {
X			printf ("With what shall I lock the door? \n");
X			return;
X		}
X
X		switch(Door->Status) {
X		case S_open:
Xprintf("You close the door and turn the key in the lock, locking the door.\n") ;
X			break ;
X		
X		case S_kicked:
Xprintf("The door has been kicked in! It'll never be locked again.\n");
X			return;
X		
X		case S_unlocked:
X		/* The door is closed but unlocked */
Xprintf("You turn the key in the lock, locking the door.\n") ;
X			break ;
X		} /* end of the office entrance "switch" block */
X
X		room[R_office_entr][2] = R_WALL ;
X		Door->Status = S_closed ;
X		return; 
X	}
X
X	default:
Xprintf("I don't think that is the sort of thing one locks.\n") ;
X	}  /* end of "lock" room scan switch */
X} /* end of "unmovable action device" block */
Xelse printf("There is nothing here that can be locked! \n");
Xreturn ;
X}  /* --- end of the "locker" subroutine --- */
X 
X
X#if (PROTOTYPE)
Xvoid unlocker(int n)
X#else
Xvoid unlocker(n)
Xint n ;
X#endif
X/*****************************/
X/*     "unlock" command      */
X/*      Version: Mk 1.1      */
X/*      16 September 1989    */
X/*****************************/
X{
X 
Xif (tag[V_VERB_ONLY]) {
X	printf ("What do you want me to unlock? \n");
X	return; 
X}
X
Xif (room[n][M_unmov_obj]) {
X	switch (n) {
X
X	/* Managers office */
X	case R_office_mang:
X		if (tag[V_safe]) {
X			if (Picture->Status == S_open) { 
Xprintf("This is a combination type safe (no key hole).  You must\n");
Xprintf("dial a combination in order to open this safe. \n");
X			}
X			else printf("I don't see a safe to unlock.\n") ;
X		}
X		else 
Xprintf("You're wasting your time.  You can't unlock that! \n");
X		return;
X
X	/* office entrance */
X	case R_office_entr:
X	if (tag[V_door]) {
X		switch(Door->Status) {
X		case S_open:
X			printf("The door is already open! \n");
X			return;
X		
X		case S_kicked:
X			printf("The door has been kicked in! \n");
X			return;
X		
X		case S_unlocked:
Xprintf("The door is already unlocked.  However it is still closed! \n");
X			return;
X		} /* end of the office entrance "switch" block */
X
X		/* The door has to still be unlocked */
X		if (tag[V_key]) {
X		if (Key->Location != B_have) {
Xprintf("You don't have the key to this door in your possession! \n");
X		}
X		else {
X			printf("You turn the key in the lock and ") ;
X			printf("hear a satisfying \"click\".\n");
X			Door->Status = S_unlocked ;
X		}
X		}
X		else printf ("With what shall I unlock the door? \n");
X		return; 
X	}
X
X	default:
Xprintf("I don't think that is the sort of thing one unlocks.\n") ;
X	}  /* end of "unlock" room scan switch */
X} /* end of "unmovable action device" block */
Xelse printf("There is nothing here that can be unlocked! \n");
Xreturn ;
X}  /* --- end of the "unlocker" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid closer(int n)
X#else
Xvoid closer(n)
Xint n ;
X#endif
X/*****************************/
X/*     "close" command       */
X/*     Version:  Mk 1.0      */
X/*     12 November 1988      */
X/*****************************/
X{
X 
X/* scan "close" sentence */
Xif (!room[n][M_unmov_obj]) {
Xprintf("There is nothing here that can be closed! \n");
X	return; 
X}
X
Xif (tag[V_VERB_ONLY]) {
X	printf ("What exactly do you want me to close? \n");
X	return; 
X}
X
Xswitch (n) {
X	/* office door */
X	case R_office_entr:
X		if (!tag[V_door]) break ;
X
X		switch (Door->Status) {
X		case S_kicked:
Xprintf("The door has been kicked in!  It'll never be closed again.\n");
X			return;
X		
X		case S_open:
X			if (tag[V_key]) {
X				if (Key->Location != B_have) {
Xprintf("You don't have the key to this door in your possession! \n");
X				}
X				else {
Xprintf("You close the office door and lock it with the key.\n") ;
X					room[R_office_entr][2] = R_WALL ;
X					Door->Status = S_closed ;
X				}
X				return ;
X			}
X			printf("The office door closes with a slam. \n");
X			Door->Status = S_unlocked ;
X			return ;
X		
X		default:
X			printf("The office door is already closed! \n");
X			return ;
X		} /* end of the door status switch */
X
X	/* managers office */
X	case R_office_mang:
X	if ((!tag[V_picture])&&(!tag[V_safe])) break;
X	if (tag[V_safe]) {
X		if (Safe->Status != S_open) 
X		printf("The safe is already closed. \n");
X		else {
X	printf("The safe door closes and locks with a \"click\". \n");
X			Safe->Status = S_closed ;
X		}
X	}
X	if (tag[V_picture]) {
X		if (Picture->Status == S_closed) 
X		printf("The platypus picture is already closed. \n");
X		else  {
Xprintf("The picture swings flush against the wall, hiding the safe.\n");
X			Picture->Status = S_closed ;
X		}
X	}
X	return ;
X
X} /* end of the "close" switch */
X
Xprintf ("I really don't see how one would close that? \n");
Xreturn; 
X} /* --- end of the "closer" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid opener(int n)
X#else
Xvoid opener(n)
Xint n ;
X#endif
X/*****************************/
X/*      "open" command       */
X/*     Version:  Mk 2.1      */
X/*     25 April 1990         */
X/*****************************/
X{
Xregister int i, j ;
Xint sw_found ;
X
XOBJECT_STRUCT *pnt, *point ;
X
X#if (PROTOTYPE)
Xvoid boom(void), ender(int), gleeper(int) ; 
Xvoid objector(OBJECT_STRUCT*) ;
X#endif
X
X/* deal with a terse command */
Xif (tag[V_VERB_ONLY]) {
X	printf ("What exactly do you want me to open? \n");
X	return;
X}
X 
Xif (tag[V_can]) {
X	if (Can->Location == B_have) 
Xprintf("Some bugger has already drunk it up. The stubee is empty!\n");
X	else printf("You don't have a can to open! \n") ;
X	return; 
X}
X
Xif (tag[V_letter]) {
X	if (Letter->Location == B_have) {
X		boom() ; /* cause an explosion */
Xprintf("It's not polite to read other people's mail!!  As you lay\n") ;
Xprintf("bleeding on the floor with your hands and arms blown away,\n") ;
Xprintf("you realize that envelope actually contained a letter bomb!\n");
Xprintf("(A trick widely used by terrorists in the 1970s).  However\n");
Xprintf("the knowledge does you little good since your spirit soon\n");
Xprintf("departs this mortal coil.\n");
X		ender(F_died) ;
X	}
X	else printf("You don't have a letter to open!\n") ;
X	return ;
X}
X
Xif (tag[V_bottle]) {
X	if (Bottle->Location == B_have)
Xprintf("Some bugger has already drunk it up. The bottle is Empty! \n");
X	else printf("You don't have a bottle to open! \n") ;
X	return; 
X}
X
Xif (tag[V_umbrella]) {
X	if (Umbrella->Location == B_have) {
Xprintf("You open the umbrella but find it's full of holes and\n");
Xprintf("its clasp is broken.  As soon as you release it, the\n");
Xprintf("umbrella snaps shut.\n") ;
X	}
X	else printf("You don't have an umbrella to open! \n") ;
X	return; 
X}
X 
X/* Now check to see if the location is consistent with the command */
Xif (!room[n][M_unmov_obj]) {
X	printf ("I don't understand what you want me to open. \n") ;
X	return ;
X}
X
Xswitch (n) {
X	/* office entrance (door) */
X	case R_office_entr:
X		if (tag[V_door]) {
X		switch (Door->Status) {
X			case S_kicked:
Xprintf("The door has been kicked in!  You don't need to open it.\n");
X				return;
X		
X			case S_open:
X				printf("The door is already open! \n");
X				return ;
X		
X			case S_unlocked:
Xprintf("As you push open the office door, the rusty hinges creak \n");
Xprintf("from long disuse.  Darkness and stale air seem to exude \n");
Xprintf("from the vacant office.  The way is free for you to enter. \n");
X				room[R_office_entr][2] = R_office_hall ;
X				Door->Status = S_open ;
X				return ;
X		
X			case S_closed:
X				if (tag[V_key]) {
Xif (Key->Location != B_have) {
X	printf("You don't have the key to this door in your possession! \n");
X}
Xelse {
Xprintf("You turn the key in the lock and hear a satisfying \"click\".\n");
Xprintf("Then you push open the office door, the rusty hinges creak \n");
Xprintf("from long disuse.  Darkness and stale air seem to exude \n");
Xprintf("from the vacant office.  The way is free for you to enter. \n");
X	room[R_office_entr][2] = R_office_hall ;
X	Door->Status = S_open ;
X}
X				}
X				else {
Xprintf("The office door is locked tight.");
Xprintf("  You need to unlock it with a key. \n");
X				}
X				return ;
X		} /* end of room status switch */
X		} /* end of the door "if" block */
X		break ;
X
X	/* managers office */
X	case R_office_mang:
X		if ((!tag[V_picture])&&(!tag[V_safe])) {
Xprintf("I don't understand how I would open that.\n") ;
X			return ;
X		}
X
X		if (tag[V_picture]) {
X			if (Picture->Status == S_closed) {
Xprintf("You swing open the platypus picture revealing a large wall \n");
Xprintf("safe with a combination dial. \n");
X				Picture->Status = S_open ;
X			}
X			else {
X				if (Safe->Status == S_closed) {
Xprintf("The picture is already swung out.  The problem is to open \n");
Xprintf("the safe!!  Hint:  Dial in a combination. \n");
X				}
X				else {
Xprintf("The picture is already swung out.\n");
X				}
X			}
X			return ;
X		} /* end of the picture "if" block */
X
X		if (tag[V_safe]) {
X			if (Picture->Status == S_closed) {
Xprintf("I do not see a safe in this office for me to open.  Perhaps\n");
Xprintf("there is a safe hidden in this office somewhere.\n");
X				return ;
X			}
X
X		switch (Safe->Status) {
X		case S_closed:
Xprintf("The safe is locked.  You must first dial the combination\n");
Xprintf("in order to open it.  See if you can find the combination. \n");
X			return ;
X		
X		case S_dialed:
X	printf("The safe door swings open smoothly and easily. \n");
X			Safe->Status = S_open ;
X			sw_active = TRUE ;
X			sw_found = FALSE ;
X			point = object ;
X			for (j = 0; j < Objcnt; j++) {
X			if ((point++)->Location == B_in_safe) {
Xprintf("Inside the safe, you see the following: \n");
X				sw_found = TRUE ;
X				pnt = object ;
X				for (i = 0; i < Objcnt; i++) {
X					if (pnt->Location == B_in_safe) {
X						printf ("        ") ;
X						objector(pnt);
X						printf("\n") ;
X					}
X					pnt++ ;
X				}				
X				break ;
X			}
X			}
X			if (gleep_safe != 0) {
X				if (sw_found) {
X					if (gleep_safe == 1) 
Xprintf("        one gleep\n") ;
X					else
Xprintf("        %d gleeps\n", gleep_safe) ;
X				}
X				else {
X					if (gleep_safe == 1) 
Xprintf("Inside the safe is one gleep.\n") ;
X					else
Xprintf("Inside the safe are %d gleeps.\n", gleep_safe) ;
X					sw_found = TRUE ;
X				}
X			}
X			if (!sw_found) printf("---The safe is empty.--- \n");
X			return ;
X
X		case S_open:
X			printf("The safe is already open! \n");
X			return ;
X		} /* end of the "safe" status switch */
X		} /* end of the safe "if" block */
X		return ; /* this return statement must remain */
X
X	/* Lift door(s) */
X	case R_lift_entr:
X		if (tag[V_door]||tag[V_lift]) {
Xprintf("It is not exactly clear how I would open these doors.\n") ;
Xprintf("However I see a push button next to the lift doors.\n") ;
Xprintf("Perhaps if I pressed the button something would happen.\n") ;
X		}
X		else printf("I'm confused about what I should open.\n");
X		return ;
X		
X} /* end of the "open" room switch */
Xprintf ("I see nothing here that I can open. \n") ;
X} /* --- end of the "opener" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid boom(void)
X#else
Xvoid boom()
X#endif
X{
Xprintf("\n\n");
Xprintf("BBBBBB      OOOOO        OOOOO      MM        MM      !!!\n");
Xprintf("B    BB   OO     OO    OO     OO    M M      M M      !!!\n");
Xprintf("B    BB   OO     OO    OO     OO    M  M    M  M      !!!\n");
Xprintf("BBBBBB    OO     OO    OO     OO    M   M  M   M      !!!\n");
Xprintf("B    BB   OO     OO    OO     OO    M    MM    M      !!!\n");
Xprintf("B    BB   OO     OO    OO     OO    M          M\n");
Xprintf("BBBBBB      OOOOO        OOOOO      M          M      !!!\n\n");
X} /* --- end of the "boom" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid gleeper(int n)
X#else
Xvoid gleeper(n) 
Xint n ;
X#endif
X/********************************************/
X/*                                          */
X/*           Gleeper Subroutine             */
X/*                                          */
X/*     Software by Gary A. Allen, Jr.       */
X/*           Version: Mk 1.00               */
X/* (c) Copyright 1989 by Gary A. Allen, Jr. */
X/*                                          */
X/********************************************/
X{
Xregister int i ;
Xint count ;
Xstatic int sw_glp_st = FALSE, cnt_down = 0 ;
X
X/* Gleep display routine */
Xcount = room[n][M_gleep] ;
X
Xif (((Torch->Location == B_have)&&Torch->Status)
X		||(n < 186)||(n > 202)) { 
X	if (count != 0) {
X		sw_glp_st = TRUE ; /*  gleeps can now multiply */
X		if (count != 1) 
X	    	   printf("There are %d gleeps here. \n",count) ;
X		else printf("There is a gleep here. \n") ;
X		return ;
X	}
X}
X
X/* Gleep reproduction routine */
Xif (sw_glp_st == TRUE) {
X	if (++cnt_down > 5) {
X		cnt_down = 0 ;
X		for (i = 0; i <= 9; i++) {
X			if (room[gleep_spot[i]][M_gleep] == 0) continue;
X			if (room[gleep_spot[i]][M_gleep] > 10000) 
X				++room[gleep_spot[i]][M_gleep] ;
X			else room[gleep_spot[i]][M_gleep] <<= 1 ;
X		}
X	}
X}
X} /* --- end of "gleeper" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid clip_in(int ammo_flag)
X#else
Xvoid clip_in(ammo_flag)
Xint ammo_flag ;
X#endif
X/********************************************/
X/*                                          */
X/*            Clip_In Subroutine            */
X/*                                          */
X/*     Software by Gary A. Allen, Jr.       */
X/*           Version: Mk 2.00               */
X/* (c) Copyright 1990 by Gary A. Allen, Jr. */
X/*                                          */
X/********************************************/
X{
X/* ammo clip insertion routine */
Xif (Rifle->Location != B_have) {
Xprintf("Galah!!  You don't have a rifle to put an ammo clip into.\n");
X	return ;
X}
Xif (clip_flag != F_no_clip) {
Xprintf("There is already an ammo clip in the rifle. \n") ;
X	return ;
X}
Xif (((Clip->Location != B_have)&&(ammo_flag == F_normal_clip))
X	||((Org_clip->Location != B_have)&&(ammo_flag == F_org_clip))) {
Xprintf("You don't possess an ammo clip to put into the rifle.\n");
X	return ;
X}
X/* actually load the clip into the rifle */
XRifle->Type = Z_alias ;
Xcarry_count-- ;
Xcarry_weight -= Clip->Weight  ;
Xif (ammo_flag == F_normal_clip) {
X	Clip->Location = B_unmade ;
X	clip_flag = F_normal_clip ;
X	Rifle->Status  = Clip->Status ;
X}
Xelse {
X	Org_clip->Location = B_unmade ;
X	clip_flag = F_org_clip ;
X	Rifle->Status = Org_clip->Status ;
X}
Xprintf("The ammunition clip slides into the rifle with a \"click\".\n");
Xprintf("You have %d bullets in the clip \n",
X			Rifle->Status) ;
Xif (Rifle->Status > 0) 
X	printf("You cycle the M16's bolt once to chamber a round.\n");
Xreturn ;
X} /* --- end of the "clip_in" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid clip_out(int n)
X#else
Xvoid clip_out(n)
Xint n ;
X#endif
X/********************************************/
X/*                                          */
X/*           Clip_Out Subroutine            */
X/*                                          */
X/*     Software by Gary A. Allen, Jr.       */
X/*           Version: Mk 1.00               */
X/* (c) Copyright 1989 by Gary A. Allen, Jr. */
X/*                                          */
X/********************************************/
X{
Xint ammo_flag ; 
X
X/* remove clip from rifle */
Xif (Rifle->Location != B_have) {
X	printf("You Bloody Galah!  ") ;
X	printf("You don't have a rifle in your possession!\n");
X	return ;
X}
Xif (clip_flag == F_no_clip) {
X	printf("There is no clip in the rifle. \n") ;
X	return ;
X}
X/* eject the clip from the rifle */
XRifle->Type = Z_normal ;
Xif (clip_flag == F_normal_clip) {
X	Clip->Location = n ;
X	ammo_flag = F_normal_clip ;
X}
Xelse {
X	Org_clip->Location = n ;
X	ammo_flag = F_org_clip ;
X}
X++room[n][M_obj_cnt] ;
Xclip_flag = F_no_clip ;
Xprintf("You press the \"eject\" button on the rifle and the ") ;
Xprintf("magazine falls to the ground.\n") ;
X
Xif (Rifle->Status > 0) {
Xprintf("You then cycle the M16's bolt once to clear the chamber. ");
Xprintf("The unfired round\n") ;
Xprintf("is ejected from the breech and rolls out of sight. \n") ;
X	if (ammo_flag == F_normal_clip) Clip->Status = --Rifle->Status ;
X	else Org_clip->Status = --Rifle->Status ;
X}
Xelse {
X	if (ammo_flag == F_normal_clip) Clip->Status = 0 ;
X	else Org_clip->Status = 0 ;
X}
XRifle->Status = 0 ;
Xreturn ;
X} /* --- end of the "clip_out" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid igniter(int n)
X#else
Xvoid igniter(n)
Xint n ;
X#endif
X/********************************************/
X/*                                          */
X/*           Igniter Subroutine             */
X/*                                          */
X/*     Software by Gary A. Allen, Jr.       */
X/*           Version: Mk 1.00               */
X/* (c) Copyright 1989 by Gary A. Allen, Jr. */
X/*                                          */
X/********************************************/
X{
X#if (PROTOTYPE)
Xvoid switcher(int) ;
Xlong time(long*) ;
X#else
Xlong time() ;
X#endif
X
X/* reject single verb command */
Xif (tag[V_VERB_ONLY]) {
X	printf("What exactly do you want me to set alight?\n") ;
X	return ;
X}
X
X/* deal with 'light torch' command */
Xif (tag[V_torch]) {
X	switcher(n) ;
X	return ;
X}
X
X/* see if the player has or requested matches */
Xif (!tag[V_match]) {
X	printf("What am I to light it with?\n") ;
X	printf("(I am not prepared to rub two sticks together.)\n") ;
X	return ;
X}
Xif (Matches->Location != B_have) {
X	printf("I have no matches!\n") ;
X	return ;
X}
Xelse {
X/* reject spurious "ignite" command */
X	if ((!tag[V_cap])&&(!tag[V_dynamite])
X		&&(sent[2] != V_LINE_END)) {
Xprintf("It would be a fire hazard to set that alight.\n");
X		return ;
X	}
X
X/* deal with spurious "light dynamite with match" */
Xif (tag[V_dynamite]&&(Dynamite->Location != B_have)) {
X	printf("You have no dynamite to ignite.\n") ;
X	return ;
X}
X
X/* deal with spurious "light cap with match" */
Xif (tag[V_cap]&&(Dynamite->Location != B_have)
X	&&(Cap->Location != B_have)) {
Xprintf("You don't have one to ignite.\n") ;
X	return ;
X}
X
X/* light up the match(es) */
X	if (tag[V_PLURAL]) {
Xprintf("You open up the match box and strike ALL of the matches.\n");
X		Matches->Location = B_destroyed ;
X	}
X	else {
Xprintf("You take one match from the match box and ignite it.\n") ;
X	}
X}
X
X/* see if player selected burnable objects */
Xif (tag[V_cap]&&(Cap->Location == B_have)) {
Xprintf("You then ignite the fuse of the blasting cap.\n\n"); 
Xprintf("Ssssssssssssssssssssssss........\n");
X	clock_explode = time(0) + 11 ;
X	sw_clock = TRUE ;
X	flag_clock = V_cap ;
X	return ;
X}
X
Xif ((tag[V_cap]||tag[V_dynamite])&&
X	(Dynamite->Location == B_have)) {
X	if (Dynamite->Type == Z_alias) {
Xprintf("You then ignite the fuse of the dynamite's blasting cap....\n");
Xprintf("You need to very quickly get very far away from this thing!!");
Xprintf("\n\nSsssssssssssssssssssssss........\n");
X		clock_explode = time(0) + 11 ;
X		sw_clock = TRUE ;
X		flag_clock = V_dynamite ;
X	 	return ;
X	}
X	else {
Xprintf("You then ignite the dynamite. Which is an odd thing\n"); 
Xprintf("to do since it doesn't have a blasting cap in it.  The\n");
Xprintf
X  ("\"dynamite\" (which is actually a very safe mining explosive)\n");
Xprintf("burns for a few minutes, billowing out smelly black smoke\n");
Xprintf("and eventually goes out leaving a few scant ashes behind.\n") ;
X		Dynamite->Location = B_destroyed ;
X	 	return ;
X	}
X}
X
X} /* -- end of the "igniter" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid hold_it(void)
X#else
Xvoid hold_it()
X#endif
X/********************************************/
X/*                                          */
X/*            Wait Subroutine               */
X/*                                          */
X/*     Software by Gary A. Allen, Jr.       */
X/*           Version: Mk 1.00               */
X/* (c) Copyright 1989 by Gary A. Allen, Jr. */
X/*                                          */
X/********************************************/
X{
X#if (PROTOTYPE)
Xchar getch(void) ;
X#endif
X
X#ifdef __TURBOC__
X/* Stop scrolling the screen until the user is ready */
Xprintf("               [Press any key to continue]\r") ;
Xgetch() ;
Xprintf("                                          \n") ;
X#endif
X
X#ifndef __TURBOC__
Xprintf("               [Press RETURN to continue]\n") ;
Xgetchar() ;
X#endif
X
X} /* --- end of the "hold_it" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid eater(void)
X#else
Xvoid eater()
X#endif
X/********************************************/
X/*                                          */
X/*            Eater Subroutine              */
X/*                                          */
X/*     Software by Gary A. Allen, Jr.       */
X/*           Version: Mk 1.00               */
X/* (c) Copyright 1989 by Gary A. Allen, Jr. */
X/*                                          */
X/********************************************/
X{
X
X#if (PROTOTYPE)
Xvoid ender(int) ;
X#endif
X
X/* reject single verb command */
Xif (tag[V_VERB_ONLY]) {
X	printf("What exactly do you want me to swallow?\n") ;
X	return ;
X}
X
X/* deal with "eat (atropine) pill(s)" command */
Xif (tag[V_pill]) {
X	if (Pills->Location != B_have) {
Xprintf("You don't have the atropine pills in your possesion!\n") ;
X		return ;
X	}
X	if (tag[V_PLURAL]) {
Xprintf("You remove ALL of the pills from the packet and swallow\n");
Xprintf("the lot.  For a couple of minutes nothing happens, then you\n");
Xprintf("start seeing double and have nervous twitches. You then\n");
Xprintf("start shaking violently and collapse to the ground.\n") ;
Xprintf("Eventually you pass out and expire from atropine poisoning.\n");
X		ender(F_died) ;
X	}
X	if (--pill_count <= 0 ) {
X		Pills->Location = B_destroyed ;
X		carry_count-- ;
X		carry_weight -= Pills->Weight  ;
Xprintf("You swallow the last atropine pill and throw away the empty\n");
Xprintf("packet which disappears from sight.  ") ;
X	}
Xelse printf("You swallow one atropine pill.  ") ;
X		i_poison += 10 ;
X		if (i_poison >= 30) {
Xprintf("\nAfter a moment you have a violent seizure and die.\n") ;
X			ender(F_died) ;
X		}
X		if (i_poison >= 20) {
Xprintf("\nYou begin to shake violently and can barely stand.\n") ;
X			return ;
X		}
X		if (i_poison >= 15) {
Xprintf("\nYour hands become a bit jittery and your vision blurred.\n") ;
X			return ;
X		}
X		printf("The drug has no ill effect.\n") ;
X	return ;
X}
Xelse 
Xprintf("I am not inclined towards putting that into my mouth!\n") ;
X
X} /* --- end of the "eater" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid ender(int i_quit)
X#else
Xvoid ender(i_quit)
Xint i_quit ;
X#endif
X/********************************************/
X/*                                          */
X/*            Ender Subroutine              */
X/*                                          */
X/*     Software by Gary A. Allen, Jr.       */
X/*           Version: Mk 1.00               */
X/* (c) Copyright 1989 by Gary A. Allen, Jr. */
X/*                                          */
X/********************************************/
X{
X#if (PROTOTYPE)
Xvoid hold_it(void), new_score(void), exit(int) ;
X#endif
X
X/* get last score */
Xnew_score() ;
X
Xif (Tank->Status != 0) sw_active = TRUE ; 
X
Xif (i_quit == F_died) { 
X	hold_it() ;
X	score -= 100 ;
Xprintf ("\nOh Dear!  You've just turned yourself into a corpse! \n\n");
Xprintf ("For getting killed you lose 100 points. \n\n") ;
X}
X
X/* Scoring Block */
Xfor(;;) {
Xif (!sw_active) {
X	if (score == 0) { 
X		printf("You concluded the game with no points.  ") ; 
X		printf("What a pitiful performance!!\n") ;
X	}
X	else {
Xprintf("You concluded the game with a miserable negative score\n") ;
Xprintf("of %d points.  Your score was better BEFORE you \n",score);
Xprintf("started playing (need I say more on how this reflects\n");
Xprintf("upon your limited aptitude at Dinkum).\n") ;
X	}
X	break ;  /* drop out of the scoring block */
X}
X
Xif (score == 0)  {
Xprintf("You concluded the game with no points ") ;
X	if (Tank->Status == 0) { 
Xprintf("and didn't drop a single gleep\n") ;
Xprintf("into the gleep tank. The word \"embarrassing\" sums it up!\n") ;
X	}
X	else {
X		if (Tank->Status > 1) {
Xprintf("but you did put %d gleeps\n",Tank->Status) ;
Xprintf("into the gleep tank.\n") ;
X		}
X		else {
Xprintf("but you did manage to find a gleep\n") ;
Xprintf("and put it in the gleep tank, (Hah!! What an achievement!).\n");
X		}
X	}
X}
X
Xelse {
Xif (score > 0)
Xprintf ("You concluded the game with %d points",score);
Xelse {
Xprintf("You concluded the game with a miserable negative score\n") ;
Xprintf("of %d points.  Your score was better BEFORE you \n",score);
Xprintf("started playing (need I say more on how this reflects\n");
Xprintf("upon your limited aptitude at Dinkum).  You ") ;
X	if (Tank->Status == 0) { 
Xprintf("also failed to\nget any gleeps into the tank.  At least ");
Xprintf("you're consistent.\n\n") ;
X	}
X	else {
Xprintf("managed\nto get something into the gleep tank.  However ");
Xprintf("it hardly\nmatters, considering your poor score.\n\n") ;
X	}
X	break ;  /* drop out of the scoring block */
X}
X	if (Tank->Status == 0) 
Xprintf(".\nHowever you placed no gleeps in the gleep tank.\n") ;
X	else {
X		if (Tank->Status > 1) {
Xprintf (" and placed %d gleeps\n",Tank->Status) ;
Xprintf ("in the gleep tank.  Good on you, Mate!\n") ;
X		}
X		else {
Xprintf(" but you did manage to find a gleep\n") ;
Xprintf("and put it in the gleep tank.\n") ;
X		}
X	}
X}
Xbreak ;  /* drop out of the scoring block */
X} /* end of the ifinite "for" loop scoring block */
X
X/* Closing Remark */
Xprintf("\nDinkum has ended.  If you are interested in more ") ;
Xprintf("information\nabout this program type:    dinkum -h\n") ;
Xexit(0);
X
X} /* --- end of "ender" routine --- */
X 
X#if (PROTOTYPE)
XOBJECT_STRUCT* point_to_object(int find_id)
X#else
XOBJECT_STRUCT* point_to_object(find_id)
Xint find_id ;
X#endif
X/*****************************/
X/*  Object Pointer Function  */
X/*     Version:  Mk 1.0      */
X/*      9 January 1993       */
X/*****************************/
X{
X
Xregister int i;
XOBJECT_STRUCT *pnt ;
X
X#if (PROTOTYPE)
Xvoid bugs(int) ;
X#endif
X 
Xpnt = object ;
Xfor (i = 0; i < Objcnt; i++) {
X	if (pnt->ID == find_id) return(pnt) ;
X	pnt++ ;
X}
Xprintf("Run time error detected in \"point_to_object\" function.\n") ;
Xprintf("\"find_id\" value was %d.\n", find_id) ;
Xbugs(Logic_error) ;
Xreturn(pnt) ;  /* this is just a dummy return for Lint */
X
X} /* --- end of "point_to_object" function --- */
X
END_OF_FILE
if test 31331 -ne `wc -c <'opener.c'`; then
    echo shar: \"'opener.c'\" unpacked with wrong size!
fi
# end of 'opener.c'
fi
if test -f 'pusher.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pusher.c'\"
else
echo shar: Extracting \"'pusher.c'\" \(20031 characters\)
sed "s/^X//" >'pusher.c' <<'END_OF_FILE'
X#define PUSHER
X#include "dink_sym.h"
X#include "dink_glb.h"
X
X#if (PROTOTYPE)
Xvoid pusher(int *n_arg)
X#else
Xvoid pusher(n_arg) 
Xint *n_arg ;
X#endif
X/********************************************************************/
X/*                                                                  */
X/*                  --- The Pusher Subroutine ---                   */
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 14 June 1989,    Version: Mk 1.2 */
X/*           (c) Copyright 1988 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xregister int i ;
Xint n ;
Xstatic long delta_time, *time_arg = 0 ;
Xchar file_name[80] ;
X
X#if (PROTOTYPE)
Xvoid which_button(void) ; 
Xvoid lift_moves(void) ; 
Xvoid nothing_happens(void) ; 
Xvoid cubic(void) ; 
Xvoid no_gray(void) ; 
Xvoid no_switch(void) ; 
Xvoid no_cube(void) ; 
Xvoid describe(int) ;
Xint yes_no(void) ;
Xlong time(long*) ;
Xvoid ender(int) ;
X#else
Xlong time() ;
Xint yes_no() ;
X#endif
X 
X/* pass the room pointer */
Xn = *n_arg ;
X
X/* reject an isolated "push" command */
Xif (tag[V_VERB_ONLY]) {
X	printf ("What exactly do you want me to push? \n");
X	return; 
X}
X
X/* Deal with the recorder */
Xif (tag[V_red_button] || tag[V_white_button] || tag[V_green_button]
X		|| tag[V_orange_button]) {
X	if (Gong->Status == S_recorder) {
X	if (Recorder->Location == B_have) {
X		if (tag[V_red_button]) {
X			if (Recorder->Status != S_inactive) {
X				printf("--- The data recorder has stopped ") ;
X				if (Recorder->Status == S_playing)
X					printf("playing. ---\n") ;
X				else printf("recording. ---\n") ;
X				Recorder->Status = S_inactive ;
X				fclose(fp) ;
X			}
X			else printf("Nothing happened!\n") ;
X			return ;
X		}
X		if (tag[V_white_button]) {
X			printf("Type in the file name for reading from:  ") ;
X			scanf("%s",file_name) ;
X			if ((fp = fopen(file_name,"r")) == 0) {
Xprintf("I could not open the file:  %s \n",file_name);
Xprintf("This file probably doesn't exit.\n") ;
Xprintf("Try pressing the white button again and using a different name.\n") ;
X			}
X			else Recorder->Status = S_playing ;
X			return ;
X		}
X		if (tag[V_green_button]) {
X			printf("Type in the file name for writing to:  ") ;
X			scanf("%s",file_name) ;
X			if ((fp = fopen(file_name,"w")) == 0) {
Xprintf ("I could not open the file:  %s \n",file_name);
Xprintf("Try pressing the green button again and using a different name.\n") ;
X			}
X			else {
X				Recorder->Status = S_recording ;
X				printf("--- Recording ---\n") ;
X			}
X			return ;
X		}
Xif (tag[V_orange_button]) {
X	printf("Dinkum's clock has been stopped.\n\n") ;
X	delta_time = time(time_arg) - (start_time + 3300L) ;
X
X	for (;;) {
X		printf("Do you wish to resume playing Dinkum?\n") ;
X		if (yes_no()) {
X			start_time = time(time_arg) - (delta_time + 3300L) ;
Xprintf("\n+----------------------------------------------------------+\n") ;
Xprintf("| Dinkum's clock is restarted with the same time remaining |\n") ;
Xprintf("| as when it was halted.                                   |\n") ;
Xprintf("+----------------------------------------------------------+\n\n");
X			describe(n) ;
X			return ;
X		}
X		else {
X			printf("Do you wish to quit Dinkum?\n") ;
X			if (yes_no()) ender(F_quit) ;
X		}
X	}
X}
X	}
X	else printf("You don't have the recorder in your possession!\n") ;
X	}
X	else printf("I have never seen a button of that color.\n") ;
X	return ;
X}
X
Xswitch (n) {
X/* Lift entrance at the ground level */
Xcase R_lift_entr:
X	if (tag[V_gray_button]) {
X		no_gray() ;
X		return ;
X	}
X	if (!tag[V_button]) {
X		if (!tag[V_blue_button]) {
X			printf ("I don't see why I should push that! \n");
X		}
X		else nothing_happens() ;
X		return ;
X	}
X	if (Lift_door->Status == S_flashing ) {
Xprintf ("You push the call button and there is a loud \"whirr\" from ");
Xprintf ("an electric motor. \nThe massive steel doors slide open ");
Xprintf ("revealing a huge lift that could hold \ntwenty men at once. ");
Xprintf ("The way is now open for you to enter. \n");
X		Lift_door->Status = S_open ;
X		room[R_lift_entr][2] = R_lift_inside ;
X		break ;
X	}
X	else {
X		if (Lift_door->Status == S_open) {
Xprintf ("You push the call button and there is a loud \"whirr\" from ");
Xprintf ("an electric motor. \nThe massive steel doors slide shut, ");
Xprintf ("closing off access to the lift.\n");
X			Lift_door->Status = S_flashing ;
X			room[R_lift_entr][2] = R_WALL ;
X			break ;
X		}
X		else {
Xprintf("You pushed the lift call button, but nothing happened.\n");
Xprintf("I think the electrical power has been turned off at the\n") ;
Xprintf("circuit breaker.\n") ;
X		break ;
X		}
X	}
X 
X/* Lift Compartment */
Xcase R_lift_inside:
X	if (tag[V_gray_button]) {
X		no_gray() ;
X		return ;
X	}
X 
X	/* scan push sentence */
X	/* zero level */
X	if (tag[V_0]) {
X		if (Lift->Status == L0) {
Xprintf ("You pushed the flashing button, but nothing happened.\n");
X			break ;
X		}
Xprintf ("The steel doors slam shut and you feel heavy as the lift ");
Xprintf ("accelerates \nupwards.  Finally the lift jerks to a halt ");
Xprintf ("and the doors whirr open.  \nSunlight is streaming in. ");
Xprintf ("Once again you are breathing the fresh air.\n");
X		Lift->Status = L0 ;
X		room[R_lift_inside][3] = R_lift_entr;
X		room[R_lift_inside][7] = R_lift_entr;
X		return ;
X	}
X 
X	/* forty-ninth level */
X	if (tag[V_49]) {
X		if (Lift->Status == L49) {
Xprintf ("You pushed the forty-nine button, but nothing happened.\n");
X			return ;
X		}	
X		Lift->Status = L49 ;
X		room[R_lift_inside][3] = R_L49_entr;
X		room[R_lift_inside][7] = R_L49_entr;
X		lift_moves() ;
X		return ;
X	}
X 
X	/* sixty-seventh level */
X	if (tag[V_67]) {
X		if (Lift->Status == L67) {
Xprintf ("You pushed the sixty-seven button, but nothing happened.\n");
X			return ;
X		}	
X		Lift->Status = L67;
X		room[R_lift_inside][3] = R_L67_entr;
X		room[R_lift_inside][7] = R_L67_entr;
X		lift_moves() ;
X		return ;
X	}
X
X	/* eighty-second level */
X	if (tag[V_82]) {
X		if (Lift->Status == L82) {
Xprintf ("You pushed the eighty-two button, but nothing happened.\n");
X			return ;
X		}	
X		Lift->Status  = L82;
X		room[R_lift_inside][3] = R_L82_entr;
X		room[R_lift_inside][7] = R_L82_entr;
Xprintf ("The steel doors slam shut and you feel a sense of ");
Xprintf ("weightlessness as \nthe lift plummets down the mine shaft. ");
Xprintf ("Finally the lift comes to a halt \n");
Xprintf ("and the doors whirr open. \n");
X		return ;
X	}
X	if (tag[V_blue_button]) {
X		nothing_happens() ;
X		return ;
X	}
Xprintf ("This lift can go only to levels 0, 49, 67, or 82 \n");
X	return ;
X
X/* inside the closet at the Iranian Parliament */
Xcase R_closet:
X	if (tag[V_gray_button]) {
X		no_gray() ;
X		return ;
X	}
X	if (tag[V_blue_button] || tag[V_button]) {
X		/* Is the command for the black cube */
X		if (Cube->Location != B_have) {
X			no_switch() ;
X		}
Xprintf("There is a bright flash of light! Then suddenly you are\n");
Xprintf("back in the hexagon chamber of the ancient spaceship.\n\n");
X		*n_arg = R_transporter ;
X	}
X	else no_switch() ;
X	return ;
X 
X
X/* the transporter control panel room */
Xcase R_panel:
X	if (tag[V_button]) {
X		which_button() ;
X		return;
X	}
X	if (tag[V_blue_button]) {
X		if (Cube->Location==B_have) cubic() ;
X		else no_cube() ;
X		return ;
X	}
X	if (tag[V_gray_button]) {
X		if (!Transporter->Status) {
Xprintf("Lots of the \"Sanskrit\" text is flashing by on the display\n");
Xprintf("panel's CRTs.  There is a whirring noise coming out of the\n");
Xprintf("equipment around you which is increasing in both loudness\n");
Xprintf("and pitch. You've turned something on, that's for sure!\n") ;
X			Transporter->Status = TRUE ;
X		}
X		else nothing_happens() ;
X		return ;
X	}
Xdefault:
X	/* Semtex explosive detector */
X	if (tag[V_detector] || tag[V_yellow_button] ||
X		((Cube->Location != B_have) &&
X		(Detector->Location == B_have))) { 
X			if (Detector->Location == B_have) {
X				/* press Semtex detector button */
Xprintf("You press the button on the Semtex explosive detector and\n");
X				for (i = 0; i <= 9; i++) {
X					if ((n == i+207)||(n == i+228)) {
Xif (room[227-i][M_rm_type] == T_lethal) {
X	printf("hear a \"beep, beep, beep\".\n") ;
X	return ;
X}
X					}
X				}
X				printf("the yellow light flashed.\n") ;
X			}
X			else {
Xprintf("You don't have the detector in your possession.\n") ;
X			}
X			return ;
X		}
X		/* Transporter return device */
X		if (Cube->Location == B_have) {
X			if ((Detector->Location == B_have) && 
X				(!tag[V_blue_button])) {
X					which_button() ;
X					return;
X			}
X			cubic() ;
X			return ;
X		}
X		if (tag[V_blue_button]) {
X			no_cube() ;
X			return ;
X		}
X		if (tag[V_gray_button]) {
X			no_gray() ;
X			return ;
X		}
X
Xprintf ("You can push as much as you like, but nothing will happen.\n");
X} /* end of the switch block */
Xreturn; 
X
X} /* --- end of the "pusher" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid which_button(void) 
X#else
Xvoid which_button() 
X#endif
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 8 December 1992  Version: Mk 1.0 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xprintf("Which button do you want me to push? \n") ;
Xreturn; 
X} /* --- end of the "which_button" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid lift_moves(void) 
X#else
Xvoid lift_moves() 
X#endif
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 8 December 1992  Version: Mk 1.0 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xprintf ("The steel doors slam shut and you feel the vibration of ");
Xprintf ("the lift \nmoving in its shaft. Finally the lift jerks ");
Xprintf ("to a halt and the doors whirr open. \n");
Xreturn; 
X} /* --- end of the "lift_moves" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid nothing_happens(void) 
X#else
Xvoid nothing_happens() 
X#endif
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 8 December 1992  Version: Mk 1.0 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xprintf("Nothing happens!\n");
Xreturn; 
X} /* --- end of the "nothing_happens" subroutine --- */
X 
X#if (PROTOTYPE)
Xvoid cubic(void) 
X#else
Xvoid cubic() 
X#endif
X/********************************************************************/
X/*                                                                  */
X/*              Press cube button in wrong place.                   */
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 8 December 1992  Version: Mk 1.0 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xprintf("You press the button on the cube but nothing happens.\n");
Xreturn; 
X} /* --- end of the "cubic" subroutine --- */
X 
X#if (PROTOTYPE)
Xvoid no_gray(void) 
X#else
Xvoid no_gray() 
X#endif
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 8 December 1992  Version: Mk 1.0 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xprintf("I see no gray button to push!\n");
Xreturn; 
X} /* --- end of the "no_gray" subroutine --- */
X 
X#if (PROTOTYPE)
Xvoid no_switch(void) 
X#else
Xvoid no_switch() 
X#endif
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 8 December 1992  Version: Mk 1.0 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xprintf("There is nothing here with a push button switch.\n");
Xreturn; 
X} /* --- end of the "no_switch" subroutine --- */
X 
X#if (PROTOTYPE)
Xvoid no_cube(void) 
X#else
Xvoid no_cube() 
X#endif
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 8 December 1992  Version: Mk 1.0 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xprintf("You don't have the black cube with the blue button in your") ;
Xprintf(" possession!\n") ;
Xreturn; 
X} /* --- end of the "no_cube" subroutine --- */
X 
X 
X#if (PROTOTYPE)
Xvoid switcher(int n)
X#else
Xvoid switcher(n) 
Xint n ;
X#endif
X/********************************************************************/
X/*                                                                  */
X/*                --- The Switcher Subroutine ---                   */
X/*                                                                  */
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 29 October 1989  Version: Mk 1.4 */
X/*           (c) Copyright 1988 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xint flag_switch, flag_rifle_md ;
X
X#if (PROTOTYPE)
Xvoid dialer(int) ;
X#endif
X
X/* deal with single verb commands */
Xif (tag[V_VERB_ONLY]) {
X	if (tag[V_turn]) printf("Turn what?\n") ;
X	if (tag[V_set]) printf("Set what?\n") ;
X	if (tag[V_select]) printf("Select what?\n") ;
X	if (tag[V_switch]) printf("Switch what?\n") ;
X	return ;
X}
X
X/* Deal with changing the safety on the rifle */
Xif (tag[V_safety]) {
X	if (Rifle->Location == B_have) {
X		if (tag[V_off]) {
X			rifle_flag = F_single ;
Xprintf("The M16 rifle is set to single shot mode ") ;
Xprintf("with the safey off.\n") ;
X			return ;
X		}
X		if (tag[V_on]) {
X			rifle_flag = F_safety ;
Xprintf("The M16 rifle's safety has been turned on.\n") ;
X			return ;
X		}
X		printf("How do you want the safety set?\n") ;
X	}
X	else printf("You're not holding the rifle!\n") ;
X	return ;
X}
X
X/* deal with special case "turn (safe) dial 0 49 67 82" */
Xif (tag[V_turn] && tag[V_dial] && (!tag[V_rifle])) {
X	dialer(n) ;
X	return ;
X}
X
X/* deal with special case "turn safe ..." */
Xif (tag[V_turn] && (!tag[V_dial]) && tag[V_safe]) {
X	if (n != R_office_mang) {
X		printf("There is no safe here to turn!\n") ;
X		return  ;
X	}
Xprintf("Since the safe is set in a concrete wall, turning it would\n");
Xprintf("be rather difficult!  Perhaps I should turn the safe's\n") ;
Xprintf("dial instead?\n") ;
X	return ;
X}
X
X/* initialize the local switches */
Xflag_switch = F_no_argument ; 
Xif (tag[V_on]) flag_switch = TRUE ;
Xif (tag[V_off]) flag_switch = FALSE ;
Xif (verb == V_light) flag_switch = TRUE ;
X
Xflag_rifle_md = F_no_argument ;
Xif (tag[V_safe]) flag_rifle_md = F_safety ;
Xif (tag[V_triple]) flag_rifle_md = F_triple ;
Xif (tag[V_single]) flag_rifle_md = F_single ;
Xif (tag[V_auto]) flag_rifle_md = F_auto ;
X
Xif ((flag_switch == F_no_argument)&&(flag_rifle_md == F_no_argument)) {
Xprintf("You will have to be a little more specific than that. \n") ;
X	return ;
X}
X
X/* see if it is a simple "on/off" power equipment switch command */
Xif ((!tag[V_torch])&&(!tag[V_rifle])&&
X	(flag_rifle_md == F_no_argument)) {
Xif (n == R_store_room) {
X	/* The circuit breaker is switched off */
X	if (flag_switch == FALSE) {
X	if (Circuit_breaker->Status) {
Xprintf ("As you pull the switch lever, there is a bright blue \n");
Xprintf ("arc and then all of the lights go out. \n");
X		Circuit_breaker->Status = FALSE ;
X		Lift_door->Status = S_closed ;
X		room[R_lift_entr][2] = R_WALL ;
X	}
X	else printf ("The circuit breaker is already turned off! \n");
X	return;
X	}
X	/* The circuit breaker is switched on */
X	if (flag_switch == TRUE) {
X	if (Circuit_breaker->Status) {
X	printf ("The circuit breaker is already turned on! \n");
X	}
X	else {
Xprintf ("As you pull the switch lever, there is a loud \"CLUNK\" \n");
Xprintf ("and you see a POWER ON light glowing. \n");
X		Circuit_breaker->Status = TRUE ;
X		Lift_door->Status = S_flashing ;
X	}
X	return;
X	}
X}          
X
X/* Deal with a garbage command */
Xprintf("I don't understand what you want me to switch. \n") ;
Xreturn ;
X} /* end of the simple "on/off" switch group */
X
X/* the switch command is to select an M16 rifle firing mode */
Xif (tag[V_rifle]) {
X	if (Rifle->Location == B_have) {
X
X		/* turn the rifle on naively */
X		if ((flag_switch==TRUE)||
X	           ((flag_rifle_md==F_safety)&&(flag_switch==FALSE))) {
X			if (rifle_flag != F_safety) {
Xprintf("The rifle's safety is already off! \n") ; 
X				return;
X			}
X			rifle_flag = F_single ;
Xprintf("The M16 rifle has been set to single shot mode. \n") ;
X			return ;
X		} 
X/* turn on the safety */
X	if ((flag_switch==FALSE)||
X	  ((flag_rifle_md==F_safety)&&((flag_switch==TRUE)||
X	  (flag_switch==F_no_argument)))) {
X				if (rifle_flag == F_safety) {
Xprintf("The rifle's safety is already on! \n") ; 
X				return;
X				}
X			rifle_flag = F_safety ;
Xprintf("The M16 rifle's safety has now been turned on. \n") ;
X			return ;
X	} 
X		/* select single shot mode */  
X		if (flag_rifle_md == F_single) {
X			if (rifle_flag == F_single) {
Xprintf("The rifle has already been set to single shot mode.\n");
X				return;
X			}
X			rifle_flag = F_single ;
Xprintf("The M16 rifle has been set to single shot mode. \n") ;
X			return ;
X		} 
X		/* select triple fire mode */  
X		if (flag_rifle_md == F_triple) {
X			if (rifle_flag == F_triple) {
Xprintf("The rifle has already been set to triple fire mode.\n");
X				return;
X			}
X			rifle_flag = F_triple ;
Xprintf("The M16 rifle has been set to triple fire mode. \n") ;
X			return ;
X		} 
X		/* select to fully automatice mode */
X		if (flag_rifle_md == F_auto) {
X			if (rifle_flag == F_auto) {
Xprintf("The rifle has already been set to fully automatic.\n");
X				return;
X			}
X			rifle_flag = F_auto ;
Xprintf("The M16 rifle has been set to fully automatic. \n") ;
X			return ;
X		} 
X	}
X	/* This is the rifle nonpossession error handler */
X	else {
Xprintf("You don't have a rifle in your possession! \n") ;
X		return ;
X	}
X} /* end of the rifle mode switching block */
X
X/* the switch command is to turn the torch off or on. */
Xif (tag[V_torch]) {
X	if (Torch->Location == B_have) {
X		/* "switch torch on" command */
X		if (flag_switch==TRUE) {
X			if (Torch->Status) {
Xprintf("The torch is already turned on.\n") ;
X				return ;
X			}
Xprintf("An intense beam of light is projected from the torch.\n") ;
X			Torch->Status = TRUE ;
X			return ;
X		}
X		/* "switch torch off" command */
X		if (flag_switch==FALSE) {
X			if (!Torch->Status) {
Xprintf("The torch isn't switched on.\n") ;
X				return ;
X			}
Xprintf("The torch switches off with a \"click\".\n") ;
X			Torch->Status = FALSE ;
X			return ;
X		}
X	}
Xprintf("You don't have a torch in your possession to switch! \n") ;
X	return ;
X}
X
X} /* --- end of the "switcher" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid new_score(void) 
X#else
Xvoid new_score() 
X#endif
X/* This subroutine calculates the score based on treasure in the safe */
X{
Xregister int i ;
XOBJECT_STRUCT *pnt ;
X
Xscore = 0 ;
Xpnt = object ;
Xfor (i = 0; i < Objcnt; i++) if ((pnt++)->Location == B_in_safe)  {
X		score += (pnt - 1)->Value ;
X} ;
X} /* --- end of the "new_score" subroutine --- */
X
END_OF_FILE
if test 20031 -ne `wc -c <'pusher.c'`; then
    echo shar: \"'pusher.c'\" unpacked with wrong size!
fi
# end of 'pusher.c'
fi
echo shar: End of archive 4 \(of 7\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
