Path: uunet!paladin.american.edu!howland.reston.ans.net!zaphod.mps.ohio-state.edu!uwm.edu!ogicse!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i011:  dinkum3 - australian text adventure game, V2.12, Part06/07
Message-ID: <4522@master.CNA.TEK.COM>
Date: 9 Feb 93 20:02:49 GMT
Article-I.D.: master.4522
Sender: news@master.CNA.TEK.COM
Lines: 1519
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1690

Submitted-by: Gary Allen <gary@sun.mech.uq.oz.au>
Posting-number: Volume 17, Issue 11
Archive-name: dinkum3/Part06
Supersedes: dinkum2: Volume 15, Issue 36-43
Environment: Unix, DOS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 7)."
# Contents:  describe.c parse.c
# Wrapped by billr@saab on Mon Feb  8 13:40:52 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'describe.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'describe.c'\"
else
echo shar: Extracting \"'describe.c'\" \(28125 characters\)
sed "s/^X//" >'describe.c' <<'END_OF_FILE'
X#define DSCRB
X#include "dink_sym.h"
X#include "dink_glb.h"
X 
X#if (PROTOTYPE)
Xvoid describe(int n)         
X#else
Xvoid describe(n)
Xint n ;         
X#endif
X/*********************************************************/
X/*                                                       */
X/*           --- Room Description and Path ---           */
X/*                                                       */
X/*      Program by Gary A. Allen, Jr.  6 June 1989       */
X/*        (c) Copyright 1992 by Gary A. Allen, Jr.       */
X/*                                                       */
X/*********************************************************/
X{
X
Xstatic int old_n, dark_count, sw_hint = FALSE ;
Xchar chr ;
X
X/* room description */
Xstatic char *descript[] = {
X"are in a grassy meadow that stretches out in all directions",  /* 0 */
X"are on a path next to the meadow.  To the east is a road.",    /* 1 */
X"are approaching a thickly wooded forest full of gum trees.",   /* 2 */
X"have hiked a short distance and then climbed up onto a river dike.",
X"are next to a wide murky river that looks dangerous.",         /* 4 */
X"--- marker for drowing in river",                              /* 5 */
X"are next to a billabong with a stream feeding into it.",       /* 6 */
X"feel something slimey under the water wraping itself around your leg.",
X"--- marker for the bunyip",                                    /* 8 */
X"are back on top of the dike next to a great meandering river.", 
X"are waist deep in the stream, the water is cool and refreshing.",
X"are in a thickly wooded forest. There is a rich eucalyptus smell",
X"are deeper into the gum tree forest and getting disoriented.",
X"are deep in a gum tree forest and appear to be ***lost***.",   /* 13 */
X"are wading in the billabong.  The water is stagnant and smelly.",
X"approach an area with high grass. You can only see in a few metres.",
X"are deep in the grass, which is waist high.",                  /* 16 */
X"see snakes slither by in the grass.  Some are quite big.",     /* 17 */
X"--- marker for the Taipan",                                    /* 18 */
X"leave the grassy area and head towards the meadow.",           /* 19 */
X"are on a road.  Far to the east are some deserted buildings.", /* 20 */
X"are on a narrow one lane road stretching out to the horizon.", /* 21 */
X"are west from the head gear of the abandoned ACME Gold Mine.", /* 22 */
X"are in an orange desert with bulldust swirling about you.",    /* 23 */
X"are in a desert full of high sand dunes.",                     /* 24 */
X"are in between two sand dunes and can see only sand.",         /* 25 */
X"are in a sandy desert with large thorny spinifexes rolling by you.",
X"are west of the mine shaft lift.  The mine tower looms over head.",
X"are walking away from a forest of sweet smelling gum trees. ", /* 28 */
X"find yourself on a narrow potholed bitumen road with soft shoulders.",
X"are southwest of the mine lift.  To the south is desert.",     /* 30 */
X"are southeast of the mine lift.  To the south is desert.",     /* 31 */
X"are east of the mine tower between the lift and the office.",  /* 32 */
X"are east of the mine office building.  There is no door here.",
X"are at the north eastern corner of the office building.",      /* 34 */
X"are at the north western corner of the office building.",      /* 35 */
X"are west of the ACME Gold Mine office building entrance.",     /* 36 */
X"are in the entry hall.  There are doors to the north, south and west.",
X"are in the Site Manager's office.  The only exit is to the south.",
X"are in the western section of the Geologist's Office.",        /* 39 */
X"are in the store room. The only exit is to the south.",	/* 40 */
X"are in the eastern section of the Geologist's Office.",        /* 41 */
X"continue walking on the narrow road which has only one lane.", /* 42 */
X"are inside the mine lift.  The doorway is to the west.",
X"are in a dimly lit tunnel going west.  To the east is the lift.",
X"are in a poorly lit tunnel going east, west and south.",       /* 45 */
X"are in a dimly lit tunnel going north.  To the east is the lift.",
X"are in a pasture.  To the east is a road and west is a billabong.",
X"are in a T-section going north, south or east.",               /* 48 */
X"are in a T-section going north, south or west.",               /* 49 */
X"are in a T-section going north, west or east.",                /* 50 */
X"are in a T-section going east, west or south.",                /* 51 */
X"are in a T-section going northeast, northwest, or southwest.", /* 52 */
X"are in a T-section going northeast, northwest, or southeast.", /* 53 */
X"are in a T-section going northeast, southeast, or southwest.",
X"are in a tunnel going north and south.",                       /* 55 */
X"are in a tunnel going east and west.",                         /* 56 */
X"are in a tunnel going northwest and southeast.",               /* 57 */
X"are in a tunnel going northeast and southwest.",               /* 58 */
X"are in a tunnel that has a hole in the ground and goes east/west.",
X"are in an L-section going southeast or up through a hole in the roof.",
X"are in an L-section that goes south or up through a hole in the roof.",
X"are in an L-section that goes east or up through a hole in the roof.",
X"are in an L-section that goes west or up through a hole in the roof.",
X"are in a Y-section that goes north, southeast, or southwest.", /* 64 */
X"are in a Y-section that goes south, northeast, or northwest.", /* 65 */
X"are in a Y-section that goes west, northeast, or southeast.",  /* 66 */
X"are in a Y-section that goes east, northwest, or southwest.",  /* 67 */
X"are in a Y-section that goes north, south, or southwest.",     /* 68 */
X"are in a Y-section that goes south, north, or northwest.",     /* 69 */
X"are in a Y-section that goes west, east, or southeast.",       /* 70 */
X"are in a Y-section that goes east, west, or southwest.",       /* 71 */
X"are in a Y-section that goes north, south, or southeast.",     /* 72 */
X"are in a Y-section that goes south, north, or northeast.",     /* 73 */
X"are in a Y-section that goes west, east, or northeast.",       /* 74 */
X"are in a Y-section that goes east, west, or northwest.",       /* 75 */
X"are in a Y-section that goes down a manhole, northwest, or southwest.",
X"are in a Y-section that goes down a manhole, northeast, or southeast.",
X"are at a tunnel crossing.  You can go north, east, south, or west.",
X"are at a tunnel crossing going nw, ne, sw, and se.",           /* 79 */
X"are in a tunnel corner that goes south and west.",             /* 80 */
X"are in a tunnel corner that goes south and east.",             /* 81 */
X"are in a tunnel corner that goes north and west.",             /* 82 */
X"are in a tunnel corner that goes north and east.",             /* 83 */
X"are in a tunnel corner that goes southeast and southwest.",    /* 84 */
X"are in a tunnel corner that goes southeast and northeast.",    /* 85 */
X"are in a tunnel corner that goes northwest and southwest.",    /* 86 */
X"are in a tunnel corner that goes northwest and northeast.",    /* 87 */
X"are in a tunnel going southwest with a stairway going down.",  /* 88 */
X"are in a tunnel going northeast with a stairway going up.",    /* 89 */
X"are at a deadend.",                                            /* 90 */
X"are in the ventilation equipment room. The exit is to the west.",
X"are in the worker's lunch room. The exit is to the north.",
X"are at the stope face with the hydraulic jacks still in place.",
X"are in an ore storage area with exits to the south and west.",
X"are in a T-section going northwest, southeast, or southwest.",
X"are in a tunnel going northeast/southwest, with a hole in the roof.",
X"are in a corner going north and east, with a manhole going down.",
X"are in a tunnel going west with a stairway going up.",         /* 98 */
X"are in a tunnel going east with a stairway going down.",       /* 99 */
X"can go north or climb down a man hole.",                       /*100 */
X"are at a caved in section of tunnel which is now a dead end.", /*101 */
X"are in a bleak and forbidding desert of bare flat stone.",     /*102 */
X"are on a narrow one lane road with gum trees on either side.", /*103 */
X"are in a flat and boring desert.",				/*104 */
X"are in front of Ned Kelly's desert hide out.",			/*105 */
X"are in a vast desert of dry salt lakes shimmering with mirages.",
X"are inside Ned Kelly's hide out.  The only way out is to the west.",
X"are north of a grassy area and within the bend of a great river.", 
X"are south of a grassy area and on the edge of a gum tree forest.",
X"can go east or climb down a man hole.",			/*110 */
X"can go east, west or climb up through a hole in the roof.",	/*111 */
X"are at the Level #67 Shift Foreman's office. You can go west.",
X"are at the spacecraft's end.  You can go north, south and west.",
X"are near the spacecraft's fin. You can go south or north-east.",
X"are next to the ship's wing.  You can go south-west or south-east.",
X"are beside the ship's window.  You can go north-west or south.",
X"are next to the spacecraft's Mach probe.  You can north or south.",
X"are facing the access hatch.  You can go up, north, or south-west.",
X"are beside the landing gear.  You can go north-east or north-west.",
X"are beside the wing's edge.  You can go north or south-east.",
X"are in the spacecraft's airlock.  You can go down or north.",
X"are in the central access way.  You can east, west, or south.",
X"are on the flight deck of an ancient spacecraft.  You can go west.",
X"are at a mysterious control panel.  You can east or west.",	/* 124 */
X"are in the chamber with glowing hexagons. The only exit is east.",
X"are in a room with a tank full of dark blue liquid.  You can go west.",
X"are in a cavernous room with a huge silver gong in the middle.",
X"are in a room with a warning on the wall going north, south and west.",
X"are in a closet stinking of moth balls. The only exit is north.",
X"are in the guard room. The closet is south, the main doorway is east.",
X"are in the prayer room of the Iranian Parliament. The guard room is west.",
X"are in a tunnel going east and west with a message on the wall.",
X"are on a narrow country road.  There is a dead kangaroo by the road.",
X"are on a road with a low rise ahead of you.  You hear a distant rumbling.",
X"--- marker for getting hit by a road train.",                  /* 135 */
X"are on a narrow country road.  There is a dead red kangaroo by the road."
X}  ;
X
X#if (PROTOTYPE)
Xvoid ender(int) ;
Xchar getch(void) ;
X#endif
X
X/* give the short description */
Xif (((Torch->Location == B_have) && Torch->Status) || 
X	(n < 186)||(n > 202)) { 
X/* Deal with the possibility of a hint for the safe */
X	if (n == R_office_mang) {
X		if ((!sw_active)&&(Rifle->Status != 0)&&
X(Ned->Location == B_destroyed)&&(!sw_hint)) {
X			sw_hint = TRUE ;
Xprintf("For half of the bullets in your M-16 rifle I will\n") ;
Xprintf("give you a hint on how to get into the safe.\n") ;
Xprintf("             Are you interested? \n") ;
X
X			for (;;) {
X
X#ifndef __TURBOC__
X				do {
Xprintf("(Answer:  Yes or No) ") ; 
X				} while ('\n' == (chr = getchar())) ;
X
X				while ('\n' != getchar()) ;
X#endif
X
X#ifdef __TURBOC__
X				printf("\n") ;
X				do {
Xprintf("(Answer:  Yes or No) ") ; 
X				} while ('\n' == (chr = getch())) ;
X				printf("\n") ;
X#endif
X
X				if (('n' == chr)||
X('N' == chr)||('y' == chr)||('Y' == chr)) {
X					if (('y' == chr)||
X						('Y' == chr)) { 
X				Rifle->Status /= 2 ;
Xprintf("\nTake the missing word in the sentence:\n") ;
Xprintf("                      \"The chook **** an egg.\"\n");
Xprintf("and spell it backwards.  Then look very carefully at the\n") ;
Xprintf("map which you found in the manager's office.  Also, you\n") ;
Xprintf("now have %d bullets in your rifle.\n",
X				Rifle->Status) ;
X					}
X				break ;
X				}
X			}
X			printf("\n") ;
X		}
X	}
Xprintf ("You %s \n",descript[room[n][M_descp]]);
X	old_n = n;
X	dark_count = 0 ;
X
X}
X
X/* deal with dark rooms */
Xelse {
X	if (n == 186) {
Xprintf("You have entered a north/south passage which does not have\n") ;
Xprintf("electric lighting.  There is some light coming in from the\n");
Xprintf("north, but the tunnel to the south is completely dark.\n");
X		return;
X	}
X	if (n == 187) {
Xprintf("The tunnel you are in is pitch black.  There is a little\n");
Xprintf("light coming in from the north.  If you keep going you will\n");
Xprintf("probably fall down a hole.\n") ;
X		return ;
X	}
X	if ((n >= 188)&&(n <= 202)) {
X		if ((dark_count==0)||(old_n == n)) {
Xprintf("You are in a mine tunnel in total darkness, which is \n") ;
Xprintf("extremely dangerous.  I have no clue where we are going.\n") ;
Xprintf("Let's go back to where there is some light!\n") ;
X			++dark_count ;
X			old_n = n;
X		}
X		else {
Xprintf("Twit!!  You have fallen down a hole and broken your neck!\n");
X		ender(F_died) ;
X		}
X		return ;
X	}
X}
X} /* end of the "describe" subroutine */
X 
X#if (PROTOTYPE)
Xvoid rdtxt(int k)
X#else
Xvoid rdtxt(k)
Xint k;
X#endif
X/*********************************************************/
X/*                                                       */
X/*     --- Text for the "Read"/"Describe" Command ---    */
X/*                                                       */
X/*       Program by Gary A. Allen, Jr.  21 February 1989 */
X/*         (c) Copyright 1992 by Gary A. Allen, Jr.      */
X/*                                                       */
X/*********************************************************/
X{
X#if (PROTOTYPE)
Xvoid hold_it(void) ;
X#else
Xvoid hold_it() ;
X#endif
X
Xswitch(k) {
X
X/* text for the map fragment in the manager's office */
Xcase V_map_frag:
Xprintf("______________________________________________________ \n");
Xprintf("|..................................................... \n");
Xprintf("|...._______________________.......................... \n");
Xprintf("|...|  Current Operational  |........................ \n");
Xprintf("|...|  Levels are:          |......D--W--W--W--W--W- \n");
Xprintf("|...|     0, 49, 67, 82     |......|................ \n");
Xprintf("|...| Level #67 is depicted |......S................ \n");
Xprintf("|...._______________________.......|................ \n");
Xprintf("|..................................S............... \n");
Xprintf("|..................................|............... \n");
Xprintf("|......................S--W--W--D--W.............. \n");
Xprintf("|......................|........|................. \n");
Xprintf("|......................S........E--E--E--E--E--E- \n");
Xprintf("|......................|.......................... \n");
Xprintf("|.......[dead end]--W--*--E--[dead end].......... \n");
Xprintf("|......................|........................ \n");
Xprintf("|......................S......................");
Xprintf("       The rest of the map\n");
Xprintf("|......................|.....................");
Xprintf("        has turned into dust.\n");
Xprintf("|.........[false dead end (partition)]......\n");
Xprintf("|...........^..........|................. \n");
Xprintf("|.{use an explosive}...S.............. \n");
Xprintf("|......................|.... \n");
Xprintf("|.............. \n");
X	break;
X
X/* Can of Fourex Beer */
Xcase V_can:
Xprintf("You see an aluminum beer can with a hole in the bottom. The\n");
Xprintf("can is coloured yellow-orange.  Written in red letters\n");
Xprintf("across the can's front is the following:\n\n") ;
Xprintf("                  \"CASTLEMAINE\"\n") ;
Xprintf("                      XXXX\n") ;
Xprintf("                   BITTER ALE\n\n") ;
Xprintf("There's a picture of Fourex's Milton brewery in the middle.\n");
X	break ;
X
X/* Atropine pills */
Xcase V_pills:
Xprintf("You're holding a packet which once contained ") ;
Xprintf("30 pills but now\nholds only") ;
Xprintf(" %d pills.  On the back of the packet is written:\n\n",
X	pill_count) ;
Xprintf("                       ATROPINE PILLS\n");
Xprintf("The pills in this packet will protect the user against ") ;
Xprintf("poisoning\nby organo-phosphorous ") ;
Xprintf("compounds, i.e. VX nerve gas.\n") ;
Xprintf("    Dosage:  Take ONE pill when poisoning symptons occur.\n");
Xprintf("    Warning:  Atropine is itself a poison.  An overdose can\n");
Xprintf("              be lethal!\n\n") ;
X	break ;
X
X
X/* description of Qaddafi's letter bomb */
Xcase V_letter:
Xprintf("___________________________________________________________\n");
Xprintf("|                                               +-----+   |\n");
Xprintf("| Col. M. Gaddafi                               |Libya|   |\n");
Xprintf("| Azizya Barracks                Postage Due    |5 zl.|   |\n");
Xprintf("| Tripoli, Libya                   $1.50        | -o- |   |\n");
Xprintf("|                                               +-----+   |\n");
Xprintf("|                 Sam Cohen                               |\n");
Xprintf("|                 Level #67 Shift Boss                    |\n");
Xprintf("|                 ACME Mine Ltd.                          |\n");
Xprintf("|                 Birdsville, Queensland 4482             |\n");
Xprintf("|  AIR MAIL                   Australia                   |\n");
Xprintf("|                                                         |\n");
Xprintf("___________________________________________________________\n");
Xprintf("\n\nThe envelope must be opened before the ");
Xprintf("letter can be read.\n\n") ;
X	break;
X
X/* text for the paper found in the safe */
Xcase V_paper:
Xprintf("                             Congratulations!!! \n");
Xprintf("You got the safe open!  Now you can start scoring points for ");
Xprintf("treasure.\n") ;
Xprintf("Credit is awarded **only** for treasure put into the safe. ");
Xprintf("Beware of fell\nbush ") ;
Xprintf("rangers who steal treasure (and sometimes kill adventurers).") ;
Xprintf("\n\n                        ---  Concerning Gleeps ---\n");
Xprintf("Gleeps are potent adjuncts which are credited separately from");
Xprintf(" treasure.  Gleeps\n") ;
Xprintf("will reproduce if left undisturbed in special locations ") ;
Xprintf("underground. However\n") ;
Xprintf("in most locations they will remain dormant. Credit ");
Xprintf("for gleeps is awarded \n") ;
Xprintf("only for those placed in a \"gleep tank\". While anyone ");
Xprintf("can gather treasure, the\n") ;
Xprintf("ability to cultivate and collect gleeps is the mark of a ");
Xprintf("fair dinkum master.\n") ;
Xprintf("                               Have Fun !!\n");
X	break;
X
X/* description of the rifle */
Xcase V_rifle:
Xprintf("--- You are looking at a Colt M16 infantry rifle. --- \n");
Xprintf("This fully automatic weapon is supplied bullets from a \n") ;
Xprintf("detachable magazine which can hold up to 200 rounds. \n") ;
Xprintf("The rifle has a selector knob that can place the weapon \n") ;
Xprintf("into one of four possible firing modes: \n\n") ;
Xprintf("     SAFE = Rifle can't fire, even if dropped \n") ;
Xprintf("     I    = Single fire mode. Shoots one bullet at a time \n");
Xprintf("     III  = Triple fire mode. Shoots three bullets rapidly \n");
Xprintf("            every time the trigger is pulled. \n") ;
Xprintf("     AUTO = Fully automatic, firing bullets at a rate of \n") ;
Xprintf("            660 rounds/min. when trigger is pulled. \n\n") ;
Xif (rifle_flag == F_safety)
Xprintf("The rifle is currently set in the SAFE mode. \n") ;
Xif (rifle_flag == F_single)
Xprintf
X  ("The rifle is currently set in the \"I\" or single fire mode.\n");
Xif (rifle_flag == F_triple)
Xprintf("The rifle is now set in the \"III\" or triple fire mode.\n");
Xif (rifle_flag == F_auto)
Xprintf("The rifle is currently set in the AUTO mode. \n") ;
Xif (clip_flag == F_no_clip)
Xprintf("The rifle does not have an ammunition clip attached to it.\n") ;
Xif (clip_flag == F_normal_clip) {
X	printf("The rifle has a standard ammunition clip attached ") ;
X	printf("which contains %d rounds.\n",
X				Rifle->Status) ;
X}
Xif (clip_flag == F_org_clip) {
X	printf("The rifle has an orange ammunition clip attached ") ;
X	printf("which contains %d rounds.\n",
X				Rifle->Status) ;
X}
X	break ;
X 
X/* description of the safe */
Xcase V_safe:
X	if (Picture->Status >= S_open) {
Xprintf("You see a conventional combination dial type wall safe \n");
Xprintf("fixed immovably into the wall.  The dial is black with \n");
Xprintf("white numbers written onto it.  The numbers range from \n");
Xprintf("one to one hundred. Attached to the upper right hand \n");
Xprintf("corner of the safe is a manufacturer's label which reads:\n\n");
Xprintf("                     _____________________________  \n") ;
Xprintf("                    |     Kryptonite Safe Co.     | \n") ;
Xprintf("                    |  Model Number:  C-3283      | \n") ; 
Xprintf("                    |  Serial Number: 10149167182 | \n") ;
Xprintf("                    |      Made in Australia      | \n") ;
Xprintf("                     _____________________________  \n") ;
X	}
X	else printf("I don't see a safe here for me to describe.\n");
X	break ;
X 
X/* Message on wall from Indiana Jones */
Xcase V_wall:
Xcase V_message:
Xprintf("You've read this message before.  It says:\n\n") ;
Xprintf("Dear Treasure Hunter:\n") ;
Xprintf("There was lots of treasure on this level when I first\n") ;
Xprintf("discovered this mine.  However I have since carted it all\n") ;
Xprintf("away.  You might try looking on another level.") ;
Xprintf("\n\n                            Good Luck!\n") ;
Xprintf("                         Dr. I. Jones, Ph.D.\n\n") ;
X	return ;
X 
X/* description of the save script recorder */
Xcase V_recorder:
Xprintf("  --- You are holding a Fair Dinkum data recorder. ---\n") ;
Xprintf("This device is a metal box with four coloured buttons.  The\n") ;
Xprintf("buttons have the following functions:\n\n") ;
Xprintf("Green Button:\n") ;
Xprintf("When the green button is pressed the recorder will query the user\n") ;
Xprintf("for a data file name.  Once the name has been provided, every\n") ;
Xprintf("move made after will be recorded in the named file.  The recording\n") ;
Xprintf("session will end when the red button is pressed.\n\n") ;
Xprintf("White Button:\n") ;
Xprintf("When the white button is pressed the recorder will query the user\n") ;
Xprintf("for a data file name.  Once the name for an existing data file has\n") ;
Xprintf("been provided, then all the moves listed in that file will be\n") ;
Xprintf("played back with the player acting accordingly.\n\n") ;
Xprintf("Red Button:\n") ;
Xprintf("When the red button is pressed a recording or play back session\n") ;
Xprintf("is ended.  Otherwise nothing happens.\n\n") ;
X	hold_it() ;
Xprintf("Orange Button:\n") ;
Xprintf("When the orange button is pressed then play is suspended and\n") ;
Xprintf("Dinkum's clock stopped.  You are then asked if you want to\n") ;
Xprintf("start the clock running again.\n\n") ;
Xprintf("                          -------------\n\n") ;
Xprintf("Warning:  Things Change!  A recorder file which worked for one\n") ;
Xprintf("situation could become lethal for another.\n") ;
X	break ;
X 
X/* Strike warning */
Xcase V_warning:
Xprintf("+---------------------------------------------------------+\n");
Xprintf("|                                                         |\n");
Xprintf("|              ACME MINE IS UNFAIR TO WORKERS!!           |\n");
Xprintf("|                                                         |\n");
Xprintf("|                       ON STRIKE!!                       |\n");
Xprintf("|                                                         |\n");
Xprintf("| The Loyal Brotherhood of Australian Miners and Under-   |\n");
Xprintf("| ground Workers is on strike against Acme Mines Ltd. due |\n");
Xprintf("| to unfair treatment of its workers.  Our Union demands  |\n");
Xprintf("| the following:  Worker's wages be increased by 30%%, the |");
Xprintf("\n") ;
Xprintf("| week shall have only 4 working days, the working day    |\n");
Xprintf("| shall be reduced to 5 hours, triple wages for overtime  |\n");
Xprintf("| work and immunity from sacking for all Union members.   |\n");
Xprintf("| To discourage scabs and other strike breakers from      |\n");
Xprintf("| working during the strike, we have planted booby traps  |\n");
Xprintf("| through out the tunnels on this level.  We do hope you  |\n");
Xprintf("| don't mind the mine being mined so it won't be mined.   |\n");
Xprintf("+---------------------------------------------------------+\n");
X	break ;
X 
X/* description of the Semtex detector*/
Xcase V_detector:
Xprintf("You see an olive green box with a yellow button in its\n");
Xprintf("centre, a yellow light in its upper right hand corner and\n");
Xprintf("Cryllic writing all over it.  Below the Cryllic letters\n") ;
Xprintf("is a translation in English which reads:\n\n") ;
Xprintf("              Mk 5.12 Semtex Explosive Detector\n") ;
Xprintf("This device is used in detecting explosive weapons such as\n");
Xprintf("antipersonal mines which utilize the high velocity plastic\n") ;
Xprintf("explosive Semtex.  To operate this device merely press the\n") ;
Xprintf("yellow button and an air sample will be taken. If trace\n");
Xprintf("amounts of Semtex are detected then a warning beeper will\n");
Xprintf("be activated.   If there is no detectable Semtex then a\n") ;
Xprintf("yellow light will flash.\n\n") ;
Xprintf("               Made in the Czeckoslovak Socialist Republic\n") ;
X	break ;
X 
X/* description of the black cube with the blue button */
Xcase V_cube:
Xprintf("You're holding a cube made of dull black metal which is about\n") ;
Xprintf("6 cm across each face.  There is a strange alien writing much\n") ;
Xprintf("like Sanskrit stamped into the metal.  On one cube face is a\n") ;
Xprintf("large iridescent blue push button projecting out from the surface.\n") ;
Xbreak ;
X 
X/* description of the normal ammunition clip */
Xcase V_clip:
Xprintf("You see a conventional M16 ammunition clip.  It is olive "); 
Xprintf(" green\n") ;
Xprintf("in colour and about 30 centimetres long.\n"); 
X
Xif (Clip->Status == 0)
X	printf("\nThe clip is EMPTY with NO bullets.\n") ;
Xelse {
Xif (Clip->Status == 1)
X	printf("\nThe clip contains one bullet.\n") ;
Xelse
Xprintf("\nThe clip contains %d bullets.\n", Clip->Status) ;
X}
Xbreak ;
X
X/* description of the gong */
Xcase V_gong:
Xprintf("You see an enormous silver gong weighing at least a ton.  The\n") ;
Xprintf("huge gong is suspended from a finely polished red cedar frame,\n") ;
Xprintf("the top of which is about four metres above the floor.\n") ;
Xbreak ;
X 
X/* description of the orange clip */
Xcase V_org_clip:
Xprintf("You see an M16 ammunition clip which has been painted bright");
Xprintf(" orange.\n") ;
Xprintf("A strange blue glow seems to be radiating from the clip. ");
Xprintf("There is\n") ;
Xprintf("a placard attached to the side of the clip which reads:\n\n") ;
Xprintf("     ____________________________________________________ \n");
Xprintf("    |    Hypertoxic 0.223 Caliber Ammunition Magazine    |\n");
Xprintf("    |                                                    |\n");
Xprintf("    | The ammunition contained in this magazine is       |\n");
Xprintf("    | manufactured from spent nuclear fuel rods composed |\n");
Xprintf("    | of uranium and plutonium metal.  The bullets have  |\n");
Xprintf("    | been hollowed out and filled with mercury metal.   |\n");
Xprintf("    | The exterior of each bullet has been striated and  |\n");
Xprintf("    | impregnated with VX nerve gas and anthrax bacillus.|\n");
Xprintf("    | The use of this ammunition violates the Geneva     |\n");
Xprintf("    | Convention on the Rules of War, the International  |\n");
Xprintf("    | Moratorium on Biological Weapons, and the United   |\n");
Xprintf("    | Nations Charter.  Close proximity to this          |\n");
Xprintf("    | ammunition can be harmful to your health.          |\n");
Xprintf("    |                                                    |\n");
Xprintf("    |    Developed under DOE Contract: LLNL 89-5632/Z    |\n");
Xprintf("    |                  Patent Pending                    |\n");
Xprintf("     ____________________________________________________ \n");
X
Xif (Org_clip->Status == 0)
X	printf("\nThe orange clip is EMPTY with NO bullets.\n") ;
Xelse {
Xif (Org_clip->Status == 1)
X	printf("\nThe orange clip contains one bullet.\n") ;
Xelse printf("\nThe orange clip contains %d bullets.\n",
X	Org_clip->Status) ;
X}
X	break ;
X} /* end of the "switch" block */
X} /* --- end of "rdtxt" subroutine --- */
END_OF_FILE
if test 28125 -ne `wc -c <'describe.c'`; then
    echo shar: \"'describe.c'\" unpacked with wrong size!
fi
# end of 'describe.c'
fi
if test -f 'parse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'parse.c'\"
else
echo shar: Extracting \"'parse.c'\" \(18436 characters\)
sed "s/^X//" >'parse.c' <<'END_OF_FILE'
X#define PARSE
X#include "dink_sym.h"
X#include "dink_glb.h"
X#include <string.h>
X#include <stdlib.h>
X 
X#if (PROTOTYPE)
Xvoid parse(void)
X#else
Xvoid parse()
X#endif
X/*********************************************************/
X/*                                                       */
X/*      --- English Language Parsing Subroutine ---      */
X/*                                                       */
X/*  This subroutine parses a sentence of up to nineteen  */
X/*  words and decodes the words into integers and passes */
X/*  a twenty element vector back to the calling          */
X/*  program.  The digit 0, implies an unused word.  The  */
X/*  digit -1 (V_LINE_END), indicates end of sentence.    */
X/*                                                       */
X/*      Program by Gary A. Allen, Jr. 24 January 1993    */
X/*        (c) Copyright 1993 by Gary A. Allen, Jr.       */
X/*                                                       */
X/*********************************************************/
X{
X#if (PROTOTYPE)
Xchar getche(void) ;
Xint synonym(int) ;
Xvoid purge(int, int*) ;
X#else
Xchar getche() ;
Xint synonym() ;
X#endif
X
Xregister int i, j ;
X
Xint m, n, jacc, i_ws, sw_purge, j_purge, sw_loop, sw_decode ;
X
X/* a sentence can have 19 words of 15 letters */ 
Xchar words[20][15], word[15] ;
Xchar letter, buffer[300], *pnt ;
X
XADJECTIVE_STRUCT *adj ;
X
X/* flush the "sent vector" */
Xfor (i = 0; i <= 19; i++) sent[i] = 0 ;
X
X/* flush the tag vector */
Xfor (i = 0; i <= Vocab_cnt; i++) tag[i] = FALSE ;
X
X/* Outer infinite "for" loop to parse and load in the words */
Xfor(;;) {
X
X/* print prompt */
X/* This modification was suggested by Chris Herborth. */
X#ifdef PROMPT
Xprintf(">") ;
X#endif
X
X/* Keyboard input "for" loop */
Xfor (i = 0; i <= 299; i++) {
X	if (Recorder->Status == S_playing) {
X		if (feof(fp)) {
X			Recorder->Status = S_inactive ;
X			continue ;
X		}
X		letter = fgetc(fp) ;
X		putchar(letter) ;
X	}
X	else {
X#ifndef __TURBOC__
X		letter = getchar() ;	
X#endif
X#ifdef __TURBOC__
X		letter = getche() ;	
X#endif
X		if (Recorder->Status == S_recording) {
X			if ((letter == '\n') || (letter == 13)) {
X				fprintf(fp,"\n") ;
X			}
X			else fputc(letter, fp) ;
X		}
X	}
X
X	buffer[i] = letter ;
X
X	/* First pass "switch" block */
X	switch(letter) {
X
X	/* Carriage return */
X	case '\n':
X	case 13:
X		break ;
X
X	/* Backspace */
X	case 8:
X		i -= 2 ;
X		if (i < 0) {
X			i = -1 ;
X#ifdef __TURBOC__
X			putchar(0x07) ; /* ring bell */
X/* "{" --- this is to balance the parenthesis below for Vi */
X		}
X		putchar(' ') ;
X		putchar(0x08) ;
X#endif
X#ifndef __TURBOC__
X		}
X#endif
X		continue ;
X
X	default:
X		continue ;
X	} /* end of the first pass "switch" block */
X	break ;
X} /* end of keyboard input "for" loop */
X
X/* Deal with goofy long strings */
Xif (i > 299) {
X	printf("\n\nHuh? That last sentence was a long one!\n") ;
X	printf("Try making it a bit shorter.\n\n") ;
X	continue ;
X}
X
Xsw_loop = FALSE ;
Xsw_decode = FALSE ;
Xpnt = buffer ;
X
X/* Outer word counting "for" loop */
Xfor (i = 0; i <= 18; i++) {
X	/* Inner letter counting "for" loop */
X	for (j = 0; j <= 14; j++) {
X		/* Letter type "switch" block */
X		switch (letter = *(pnt++)) {
X			case '\n':
X			case 13 :
X				sw_loop = TRUE ;
X				if ((i == 0) && (j == 0)) break ;
X				words[i][j] = '\0' ;  
X				sw_decode = TRUE ; 
X				break ;
X
X			/* White spaces and punctuation for cutting out words */
X			case '\"':
X			case ' ':
X			case ',':
X			case '.':
X			case ';':
X			case ':':
X			case '?':
X			case '!':
X			case '&':
X			case '{':
X			case '}':
X			case '[':
X			case ']':
X			case ')':
X			case '(':
X			case '\'':
X			case '`':
X			case '\t':
X				words[i][j] = '\0' ;  
X				break;
X
X			default:
X				words[i][j] = letter ;
X				continue ;
X		} /* end of letter type "switch" block */
X		break ;
X	} /* end of inner letter counting "for" loop */
X	if (sw_loop) break ;
X	if (j > 14) {
Xprintf("\nYou're saying nonsense! Type the sentence again. \n");
X		break ;
X	}
X	if (j == 0) i-- ;
X} /* end of outer word counting "for" loop */
X
X/* Bad sentence handling block */
Xif (!sw_decode) {
X	if (sw_loop) continue ;
X
X	if (i > 18) 
Xprintf ("\nYour sentence is too long. Type something shorter! \n") ;
X
X#ifndef __TURBOC__
X	/* Purge the input buffer */
X	for (;;) if ('\n' == getchar()) break ;
X#endif
X
X	continue ; /* resume the infinite "for" loop */
X} /* end of bad sentence handling block */
X
X#ifdef __TURBOC__
Xprintf("\n") ;
X#endif
X
X/* Decode the words from the known vocabulary */
Xm = i ;
Xjacc = 0;
Xfor (i = 0; i <= m; i++) {
X	for (j = 0; j <= 14; j++) {
X		word[j] = words[i][j] ; 
X	}
X	for (j = 0; j < Vocab_cnt; j++) {
X		n = strcmp(word,vocab[j]);
X		if (n == 0) {
X			if ((j > 9)&&(j < 20)) j -= 10;
X			sent[jacc++] = j + 1 ;
X			break; 
X		}
X	}
X	/* Deal with a number */
X	if ((word[0] >= 48)&&(word[0] <= 57)) {
X		tag[V_NUMBER] = TRUE ;
X		for (j = 0; j <= 14; j++) {
X			if ((word[j] < 48)||(word[j] > 57)) {
X				if (word[j] != '\0') tag[V_NUMBER] = FALSE ;
X				break ;
X			}
X		}
X		if (tag[V_NUMBER]) number_word = atoi(word) ;
X	}
X} /* end of vobaulary decode block */
X
Xif (jacc == 0) {
X	printf ("Huh? Nothing you said was understandable! Try again. \n");
X	continue ;
X}
X 
X/* mark last word */
Xsent[jacc] = V_LINE_END ;
X 
X/* Check to see if this is a simple move command */
Xif (sent[0] <= 10) {
X	tag[V_MOVE] = TRUE ;
X	tag[V_DIRECTION] = TRUE ;
X	verb = sent[0] ;
X	return ; 
X} /* end of the simple move block */
X 
X/* adjective and "in/out" preposition "for" loop */
Xsw_purge = FALSE ;
Xfor (j = 0; j <= jacc-1; j++) {
X
X	/* check for adjectives */
X	adj = adjective ;
X	for (i = 0; i < Adj_max; i++) {
X		if (sent[j] == adj->Adjective) {
X
X		/* Does a noun have to be ignored ? */
X		if ((adj->Command == F_ignore)
X			&& (adj->Modified_noun != sent[j+1])) break ;
X
X		/* Does a noun have to be replaced? */
X		if ((adj->Command == F_replace)
X			&& (adj->Modified_noun == sent[j+1])) {
X				sent[j+1] = adj->Generated_noun ;
X		}
X		sw_purge = TRUE ;
X		j_purge = j ;
X		}
X		adj++ ;
X	} 
X} /* end of adjective and "in/out" preposition "for" loop */
X
X/* purge processed adjective from sentence */
Xif (sw_purge) purge(j_purge, &jacc) ;
X 
X/* Verb grammer check "for" loop */
X/* see if the sentence is of a command sentax */
Xsw_loop = FALSE ;
Xfor (i = 0; i < Verb_max; i++) {
X	if (sent[0] == verb_table[i]) {
X		if (synonym(jacc)) {
X			sw_loop = TRUE ;
X			break ;
X		}
X		return ;
X	}
X} /* end of verb grammer check "for" loop */
Xif (sw_loop) continue ;
X
X/* First word is not a verb so check to see if this is a "question" sentence */
X/*    this logic can certainly be improved  */
Xfor (i = 0; i < Quest_max; i++) {
X	if (sent[0] == quest[i]) {
X		/* shift the sentence over and load in "question" */ 
X		for (j = jacc; j >= 0; j--) sent[j+1] = sent[j] ;
X		sent[0] = V_QUESTION ;
X		tag[V_QUESTION] = TRUE ; 
X		if (++jacc == 2) {
X		/* Sentence is a one word command */
X			tag[V_VERB_ONLY] = TRUE ;
X			tag[sent[1]] = TRUE ;
X			verb = V_QUESTION ;
X			return ;
X		}
X		if (synonym(jacc)) {
X			sw_loop = TRUE ;
X			break ;
X		}
X		return ;
X	} 
X} /* end of first word not a verb so check if "question" block */
Xif (sw_loop) continue ;
X 
X/* This is not a question and the first word is --not-- a verb. */
X/*     Therefore a verb is embedded and must be swapped in. */
Xif (jacc != 1) for (j = 1; j <= jacc-1; j++) {
X	/* Check to see if the word is a move command */
X	if (sent[j] <= 10) {
X		tag[V_MOVE] = TRUE ;
X		i_ws = sent[0] ;
X		sent[0] = sent[j] ;
X		sent[j] = i_ws ;
X		if (synonym(jacc)) {
X			sw_loop = TRUE ;
X			break ;
X		}
X		return ;
X	} /* end of simple move command block */
X
X	/* if not a move command then check the verb table */
X	for (i = 0; i < Verb_max; i++) {
X		if (sent[j] == verb_table[i]) {
X			i_ws = sent[0] ;
X			sent[0] = sent[j] ;
X			sent[j] = i_ws ;
X			if (synonym(jacc)) {
X				sw_loop = TRUE ;
X				break ;
X			}
X			return ;
X		}
X	}
X	if (sw_loop) break ;
X} /* end of verb is embedded and must be swapped in block */
Xif (sw_loop) continue ;
X
X/* Verb error routine */
Xprintf ("If there was a verb in that sentence, I didn't understand ") ;
Xprintf ("it.\n") ;
X
X} /* end of outer most infinite "for" loop to parse in the words */
X
X} /* --- end of "parse" subroutine --- */
X
X
X#if (PROTOTYPE)
Xint synonym(int jacc)
X#else
Xint synonym(jacc)
Xint jacc ;
X#endif
X/**************************************/
X/*                                    */
X/*         Synonym Function           */
X/*                                    */
X/* Version: Mk 1.0    6 December 1992 */
X/*                                    */
X/**************************************/
X{
Xregister int i, j ;
Xint j_point ;
Xint sw_movement, sw_adverb, sw_adverb_fnd ;
X
XADVERB_STRUCT *adv ;
X
X#if (PROTOTYPE)
Xvoid purge(int, int*) ;
X#endif
X
X/* prescan for verb connected movement commands */
Xswitch(sent[0]) { 
Xcase V_go:
Xcase V_move:
Xcase V_walk:
Xcase V_run:
Xcase V_jump:
Xcase V_leap:
Xcase V_hop:
Xcase V_stroll:
Xcase V_saunter:
Xcase V_swagger:
X	sw_movement = TRUE ;
X	break ;
Xdefault:
X	sw_movement = FALSE ;
X}
X
X/* adverb scan, sent[0] is the verb */
Xsw_adverb = FALSE ;
Xsw_adverb_fnd = FALSE ;
Xadv = adverb ;
Xfor (i = 0; i < Adv_max; i++) {
X	for (j = 1; j <= jacc-1; j++) {
X		/* see if this is an adverb */
X		if (sent[j] == adv->Adverb) {
X			j_point = j ;
X			sw_adverb = TRUE ;
X
X			/* does the sentence have the companion verb? */
X			if (adv->Modified_verb == sent[0]) {
X				sent[0] = adv->Generated_verb ;
X				sw_adverb = FALSE ;
X				sw_adverb_fnd = TRUE ;
X
X			/* purge processed adverb from sentence */
X				purge(j, &jacc) ;
X			}
X		}
X	}
X	adv++ ;
X}
X
X/* purge unprocessed adverb from sentence */
Xif (sw_adverb && (!sw_movement)) purge(j_point, &jacc) ;
X 
X/* scan the sentence for the movement direction */
Xif ((!sw_adverb_fnd) && sw_movement) {
X	for (j = 0; j <= jacc-1; j++) {
X		if (sent[j] <= 10) {
X			tag[V_MOVE] = TRUE ;
X			tag[V_DIRECTION] = TRUE ;
X			verb = sent[j] ;
X			return(FALSE) ;
X		}
X		if (sent[j] == V_LINE_END) break ;
X	}
X	printf("Where to?  In what direction?\n") ;
X	return(TRUE) ;
X} 
X
Xtag[sent[0]] = TRUE ;  /* activate the tag for the verb */
X 
Xif (jacc == 1) {
X/* Sentence is a one word command */
X	tag[V_VERB_ONLY] = TRUE ;
X	verb = sent[0] ;
X	if (sent[0] <= 4) return(FALSE) ; /* first 5 elements are reserved */
X	return(FALSE) ;
X}
X
X/* Load the "tag" matrix for detected words and synonyms */
Xfor (j = 1; j <= 19; j++) {
X	if (sent[j] == V_LINE_END) break ;
X	if (sent[j] <= 10) tag[V_DIRECTION] = TRUE ;
X	if (sent[j] <= 4) continue ; /* first 5 elements are reserved */
X	tag[sent[j]] = TRUE ;  /* activate an element for each word */
X
X	/* Deal with synonym nouns */
X	switch(sent[j]) {
X
X	case V_automatic:
X	case V_AUTO:
X		tag[V_auto] = TRUE ;
X		continue ;
X 
X	case V_bar:
X		tag[V_gold] = TRUE ;
X		continue ;
X
X	case V_beer:
X	case V_fourex:
X	case V_Fourex:
X		tag[V_can] = TRUE ;
X		continue ;
X
X	case V_cockroaches:
X		tag[V_PLURAL] = TRUE ;
X		tag[V_cockroach] = TRUE ;
X		continue ;
X
X	case V_diamond:
X		tag[V_ring] = TRUE ;
X		continue ;
X 
X	case V_doormat:
X		tag[V_mat] = TRUE ;
X		continue ;
X
X	case V_drop:
X		tag[V_bear] = TRUE ;
X		continue ;
X
X	case V_everything:
X		tag[V_all] = TRUE ;
X		continue ;
X
X	case V_wall:
X		tag[V_warning] = TRUE ;
X		tag[V_message] = TRUE ;
X		continue ;
X
X	case V_money:
X		tag[V_bill] = TRUE ;
X		continue ;
X
X	case V_lager:
X		tag[V_bottle] = TRUE ;
X		continue ;
X
X	case V_fuze:
X	case V_fuse:
X		tag[V_cap] = TRUE ;
X		continue ;
X
X	case V_gleeps:
X		tag[V_PLURAL] = TRUE ;
X		tag[V_gleep] = TRUE ;
X		continue ;
X
X	case V_hoop:
X		tag[V_snake] = TRUE ;
X		continue ;
X
X	case V_M16:
X	case V_m16:
X	case V_gun:
X		tag[V_rifle] = TRUE ;
X		continue ;
X
X	case V_kangaroos:
X		tag[V_PLURAL] = TRUE ;
X		tag[V_kangaroo] = TRUE ;
X		continue ;
X
X	case V_magazine:
X	case V_ammo:
X		tag[V_clip] = TRUE ;
X		continue ;
X
X	case V_mail:
X	case V_envelope:
X		tag[V_letter] = TRUE ;
X		continue ;
X
X	case V_charts:
X	case V_schedule:
X	case V_schedules:
X		tag[V_chart] = TRUE ;
X		continue ;
X
X	case V_matchbox:
X		tag[V_matches] = TRUE ;
X	case V_matches:
X		tag[V_PLURAL] = TRUE ;
X		tag[V_match] = TRUE ;
X		continue ;
X
X	case V_Ned:
X	case V_kelly:
X	case V_Kelly:
X		tag[V_ned] = TRUE ;
X		continue ;
X
X	case V_off_q:
X		tag[V_off] = TRUE ;
X		continue ;
X
X	case V_on_q:
X		tag[V_on] = TRUE ;
X		continue ;
X 
X	case V_plan:
X		tag[V_map] = TRUE ;
X	case V_map:
X		tag[V_map_frag] = TRUE ;
X		continue ;
X
X	case V_painting:
X		tag[V_picture] = TRUE ;
X		continue ;
X
X	case V_picture:
X		tag[V_photo] = TRUE ;
X		continue ;
X
X	case V_doors:
X		tag[V_PLURAL] = TRUE ;
X		tag[V_door] = TRUE ;
X		continue ;
X
X	case V_pills:
X	case V_packet:
X		tag[V_PLURAL] = TRUE ;
X	case V_atropine:
X		tag[V_pill] = TRUE ;
X		continue ;
X
X	case V_safety:
X	case V_SAFE:
X		tag[V_safe] = TRUE ;
X		continue ;
X 
X	case V_silver:
X		tag[V_coin] = TRUE ;
X		continue ;
X
X	case V_spinifexes:
X		tag[V_PLURAL] = TRUE ;
X		tag[V_spinifex] = TRUE ;
X		continue ;
X
X	case V_yourself:
X	case V_myself:
X		tag[V_self] = TRUE ;
X		continue ;
X
X	case V_stick:
X	case V_explosive:
X		tag[V_dynamite] = TRUE ;
X		continue ;
X
X	case V_switch:
X		tag[V_button] = TRUE ;
X		continue ;
X
X	case V_treasure:
X		tag[V_all] = TRUE ;
X		continue ;
X
X	case V_I:
X		tag[V_single] = TRUE ;
X		continue ;
X
X	case V_III:
X		tag[V_triple] = TRUE ;
X		continue ;
X
X	case V_zero:
X		tag[V_0] = TRUE ;
X		tag[V_NUMBER] = TRUE ;
X		number_word = 0 ;
X		continue ;
X
X	case V_one:
X		tag[V_NUMBER] = TRUE ;
X		number_word = 1 ;
X		continue ;
X
X	case V_two:
X		tag[V_NUMBER] = TRUE ;
X		number_word = 2 ;
X		continue ;
X
X	case V_three:
X		tag[V_NUMBER] = TRUE ;
X		number_word = 3 ;
X		continue ;
X
X	case V_four:
X		tag[V_NUMBER] = TRUE ;
X		number_word = 4 ;
X		continue ;
X
X	case V_five:
X		tag[V_NUMBER] = TRUE ;
X		number_word = 5 ;  /* Dinkum doesn't count past 5 */
X		continue ;
X
X	case V_forty_nine:
X		tag[V_49] = TRUE ;
X		continue ;
X
X	case V_sixty_seven:
X		tag[V_67] = TRUE ;
X		continue ;
X
X	case V_eighty_two:
X		tag[V_82] = TRUE ;
X		continue ;
X
X	default:
X		continue ;
X	}
X} /* end of sentence tag word scan */
Xverb = sent[0] ;
Xreturn(FALSE) ;
X
X} /* --- end of "synonym" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid purge(int k_start, int *k_finish)
X#else
Xvoid purge(k_start, k_finish)
Xint k_start, *k_finish ;
X#endif
X/***********************************/
X/*                                 */
X/*   Sentence Purging Subroutine   */
X/*                                 */
X/* Version: Mk 1.0  3 March 1990   */
X/*                                 */
X/***********************************/
X{
Xregister int k ;
Xint k_end ;
X
Xk_end = *k_finish ;
Xfor (k = k_start; k <= k_end-1; k++) sent[k] = sent[k+1] ;
X*k_finish = --k_end ;
X} /* --- end of "purge" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid filler(void)
X#else
Xvoid filler()
X#endif
X/***********************************/
X/*                                 */
X/*        Looker Subroutine        */
X/*                                 */
X/* Version: Mk 1.0  18 August 1989 */
X/*                                 */
X/***********************************/
X{
X
Xif (tag[V_VERB_ONLY]) {
X	printf("Fill what?\n") ;
X	return ;
X}
Xif (tag[V_can]) {
X	if (Can->Location != B_have) 
Xprintf("You don't have the Fourex can in your possession!\n") ;
Xelse printf("I can't do it!  There's a hole in the can's bottom.\n") ;
X	return ;
X}
Xif (tag[V_bottle]) {
X	if (Bottle->Location != B_have) 
Xprintf("You don't have the bottle in your possession!\n") ;
Xelse printf("I can't do it!  The bottle has a crack in it's bottom.\n");
X	return ;
X}
Xprintf("I can't fill that!\n") ;
X} /* --- end of the "filler" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid looker(int n)
X#else
Xvoid looker(n)
Xint n ;
X#endif
X/***********************************/
X/*                                 */
X/*        Looker Subroutine        */
X/*                                 */
X/* Version: Mk 1.0  18 August 1989 */
X/*                                 */
X/***********************************/
X{
Xregister int i ;
Xint m, sw_no_see ;
X
XOBJECT_STRUCT *pnt ;
XREAD_STRUCT *point ;
X
X#if (PROTOTYPE)
Xvoid long_descp(int), describe(int), objlooker(int), gleeper(int) ;
Xvoid actor(int), rdtxt(int) ;
XOBJECT_STRUCT* point_to_object(int) ;
X#else
XOBJECT_STRUCT* point_to_object() ;
X#endif
X
X/* an isolated "look" means to just look at the room */
Xif (tag[V_VERB_ONLY]) { 
X	/* Check for long description */
X	if ((room[n][M_rm_type] == T_was_long)||(n == R_lift_inside))
X	   long_descp(n);
X	else describe (n) ;
X	objlooker(n) ; /* Check if there are objects in the room */
X	gleeper(n) ;   /* check for gleeps and update the gleep count */
X	/* describe unmovable action objects and status */
X	if (room[n][M_unmov_obj]) actor(n) ;
X	return ;
X}
X
X/* Gleep tank */
Xif (tag[V_tank]) {
X	if (n == R_gleep_tank) {
Xprintf("You look inside the gleep tank and see a blue fluid which\n") ;
Xprintf("smells of chlorine") ;
X		if (Tank->Status == 0) {
Xprintf(".\n") ;
X			return ;
X		}
X		if (Tank->Status == 1) {
Xprintf(" and a single gleep submerged in the fluid.\n") ;
X			return ;
X		}
Xprintf(" and %d gleeps submerged in the fluid.\n",
X		Tank->Status) ;
X		return ;
X	}
X	else {
X		printf("There is no gleep tank here!\n") ;
X		return ;
X	}
X}
X
Xsw_no_see = FALSE ;
Xpoint = read_object ;
Xfor (i = 0; i < Read_objcnt; i++) {
X	m = (point++)->ID ;
X	if (tag[m]) {
X		pnt = point_to_object(m) ;
X		if (pnt->Type == Z_unmovable) {
X			if (pnt->Location == n) {
X				rdtxt(m) ;
X				return ;
X			}
X			else sw_no_see = TRUE ;
X		}
X		else {
X			if (pnt->Location == B_have) rdtxt(m) ;
X			else 
Xprintf("I can examine an object only if it is in my possession.\n");
X			return ;
X		}
X	}
X}
Xif (sw_no_see) {
X	printf("I don't see it here.\n") ;
X	return ;
X}
X
X/* Deal with unreadable objects */
Xprintf("There is nothing more that I can describe about it.\n");
Xreturn ;
X
X} /* --- end of the "looker" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid pass(void)
X#else
Xvoid pass()
X#endif
X/***********************************/
X/*                                 */
X/*        Password Subroutine      */
X/*                                 */
X/* Version: Mk 1.0  29 July 1989   */
X/*                                 */
X/***********************************/
X{
Xregister int i ;
Xchar chr ;
Xstatic char *passwd = "2Xngootx7Ysd4Du9" ;
X
X#if (PROTOTYPE)
Xvoid exit(int);
Xchar getch(void) ;
X#else
Xchar getch() ;
X#endif
X
X/* Request password */
Xprintf("Enter password:  ") ;
X
X#ifndef __TURBOC__
Xfor (i = 2; i <= 7; i++) {
X	chr = getchar() ;
X	if (chr+i-1 != passwd[i]) exit(0) ;
X}	
Xif (getchar() != '\n') exit(0) ;
Xprintf(".\n") ;  /* indicate that the password was accepted */
X#endif
X
X#ifdef __TURBOC__
Xfor (i = 2; i <= 7; i++) {
X	chr = getch() ;
X	if (chr+i-1 != passwd[i]) { 
X		for (;;) if (getch() == 3) break ;
X		printf("\r                    \n") ;
X		exit(0) ;
X	}
X}
Xprintf("\r.                     \n") ;
X#endif
X
Xsw_wizard = TRUE ; /* toggle wizard switch */
X
X} /* --- end of the "pass" subroutine */
END_OF_FILE
if test 18436 -ne `wc -c <'parse.c'`; then
    echo shar: \"'parse.c'\" unpacked with wrong size!
fi
# end of 'parse.c'
fi
echo shar: End of archive 6 \(of 7\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
