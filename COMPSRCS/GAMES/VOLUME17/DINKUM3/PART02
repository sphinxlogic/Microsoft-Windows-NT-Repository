Path: uunet!paladin.american.edu!howland.reston.ans.net!zaphod.mps.ohio-state.edu!uwm.edu!ogicse!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i007:  dinkum3 - australian text adventure game, V2.12, Part02/07
Message-ID: <4518@master.CNA.TEK.COM>
Date: 9 Feb 93 20:02:00 GMT
Article-I.D.: master.4518
Sender: news@master.CNA.TEK.COM
Lines: 1944
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1686

Submitted-by: Gary Allen <gary@sun.mech.uq.oz.au>
Posting-number: Volume 17, Issue 7
Archive-name: dinkum3/Part02
Supersedes: dinkum2: Volume 15, Issue 36-43
Environment: Unix, DOS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 7)."
# Contents:  dink_sym.h dinkum.c make.unx makefile
# Wrapped by billr@saab on Mon Feb  8 13:40:50 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dink_sym.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dink_sym.h'\"
else
echo shar: Extracting \"'dink_sym.h'\" \(12377 characters\)
sed "s/^X//" >'dink_sym.h' <<'END_OF_FILE'
X/***********************************************************/
X/*                                                         */
X/*          --- Dinkum Symbol Definition File ---          */
X/*                                                         */
X/*            Version:  Mk 1.13,   16 January 1993         */
X/*                                                         */
X/***********************************************************/
X
X#include <stdio.h> 
X
X/* Deal with K&R C versus ANSI-C */
X#if sun
X#define void	int
X#define PROTOTYPE	0
X#else
X#define PROTOTYPE	1
X#endif
X
X#ifdef CLASSIC
X#define PROTOTYPE	0
X#endif
X
X/* Definitions for Bugs subroutine */
X#define Failed		0
X#define Request		1
X#define Logic_error	2
X 
X/* Room code numbers */
X/*  These code numbers 'n' point to the table entry in room[n][] */
X#define R_WALL		-1
X#define R_meadow	0
X#define R_dike		3
X#define R_river_edge	4
X#define R_river		5
X#define R_stream	6
X#define R_slime		7
X#define R_bunyip	8
X#define R_river_exit	9
X#define R_forest	11
X#define R_billabong	14
X#define R_taipan	18
X#define R_mine_head	22
X#define R_lift_entr	27
X#define R_bitumen	29
X#define R_office_entr	36
X#define R_office_hall	37
X#define R_office_mang	38
X#define R_geo_w		39
X#define R_store_room	40
X#define R_geo_e		41
X#define R_lift_inside	43
X#define R_L49_entr      44
X#define R_L67_entr      45
X#define R_L82_entr      46
X#define R_hideout_entr	144
X#define R_hideout	146
X#define R_bend		147
X#define R_no_treasure	159
X#define R_manhole_1	166
X#define R_manhole_2	170
X#define R_foreman	177
X#define R_blast_point	185
X#define R_ufo_w		191
X#define R_ufo_nw	192
X#define R_ufo_n		193
X#define R_ufo_ne	194
X#define R_ufo_e		195
X#define R_ufo_se	196
X#define R_ufo_s		197
X#define R_ufo_sw	198
X#define R_air_lock	199
X#define R_ship_passage	200
X#define R_flight_deck	201
X#define R_panel		202
X#define R_transporter	203
X#define R_gleep_tank	206
X#define R_warning	217
X#define R_gong		238
X#define R_closet	240 
X#define R_guard 	241
X#define R_prayer	242
X#define R_road_kill_s	245
X#define R_road_kill_n	248
X
X/* Room category indicator for room[n][i] where "i" is below */
X#define M_rm_type	10
X#define M_obj_cnt	11
X#define M_unmov_obj     12
X#define M_monster	13
X#define M_gleep		14
X#define M_descp		15
X
X/* Room type, referred to by room[n][M_rm_type] */
X#define T_lethal	-1
X#define T_short_descp	0
X#define T_long_descp	1
X#define T_was_long	3
X#define T_looping	5
X
X/* Unmovable object status, i.e.  Safe->Status  */
X#define S_closed	0
X#define S_revealed	1
X#define S_flashing	1
X#define S_dialed	2
X#define S_unlocked	2
X#define S_open		3
X#define S_kicked	8
X#define S_recorder	4
X#define S_told		5
X#define S_fair_game	6
X#define S_recording	7
X#define S_playing	9
X#define S_inactive	10
X
X#define L0		0
X#define L49		49
X#define L67		67
X#define L82		82
X
X/* Vocabulary code numbers */
X/*  numbers -1 to 10 to not correspond to actual vocabulary words */
X#define V_LINE_END	-1
X#define V_NULL		0
X#define V_MOVE		1
X#define V_PLURAL	2
X#define V_VERB_ONLY	3
X#define V_DIRECTION	4
X#define V_NUMBER	5
X
X/* --- below are real word symbols --- */
X#define V_east		3
X#define V_west		4
X#define V_up		5
X#define V_down	 	6
X#define V_u		15
X#define V_quit		21
X#define V_unlock	22
X#define V_lock		23
X#define V_take		24
X#define V_leave		25
X#define V_drop		26
X#define V_can		27
X#define V_bottle	28
X#define V_mat		29  
X#define V_key		30
X#define V_butt		31
X#define V_look		32
X#define V_door		33
X#define V_open		34
X#define V_get		35
X#define V_throw		36
X#define V_turn		37
X#define V_on		38
X#define V_off		39
X#define V_push		40
X#define V_button	41
X#define V_enter		42
X#define V_switch	43
X#define V_zero		44
X#define V_forty_nine	45
X#define V_sixty_seven	46
X#define V_eighty_two	47
X#define V_0		48
X#define V_49		49
X#define V_67		50
X#define V_82		51
X#define V_beer		52
X#define V_lager		53
X#define V_doormat	54
X#define V_lift		55
X#define V_on_q		56
X#define V_off_q		57
X#define V_svc		58
X#define V_map		59
X#define V_picture	60
X#define V_safe		61
X#define V_dial		62
X#define V_paper		63
X#define V_put		64
X#define V_close		65
X#define V_read		66
X#define V_gold		67
X#define V_bar		68
X#define V_dynamite	69
X#define V_rifle		70
X#define V_M16		71
X#define V_m16		72
X#define V_cap		73
X#define V_matches	74
X#define V_diamond	75
X#define V_ring		76
X#define V_ruby		77
X#define V_silver	78
X#define V_coin		79
X#define V_bill		80
X#define V_money		81
X#define V_teapot	82
X#define V_clip		83
X#define V_ammo		84
X#define V_box		85
X#define V_stick		86
X#define V_pills		87
X#define V_orange	88
X#define V_glowing	89
X#define V_saphire	90
X#define V_emerald	91
X#define V_score		92
X#define V_inventory	93
X#define V_examine	94
X#define V_describe	95
X#define V_drink 	96
X#define V_fill		97
X#define V_water		98
X#define V_fourex	99
X#define V_invent	100
X#define V_view		101
X#define V_press		102
X#define V_exit		103
X#define V_all		104
X#define V_Fourex	105
X#define V_everything	106
X#define V_shoot		107
X#define V_kill		108
X#define V_ned		109
X#define V_Ned		110
X#define V_kelly		111
X#define V_Kelly		112
X#define V_pick		113
X#define V_grab		114
X#define V_combination	115
X#define V_select	116
X#define V_safety	117
X#define V_SAFE		118
X#define V_triple	119
X#define V_III		120
X#define V_single	121
X#define V_I		122
X#define V_auto		123
X#define V_AUTO		124
X#define V_automatic	125
X#define V_set		126
X#define V_insert	127
X#define V_attach	128
X#define V_plan		129
X#define V_gun		130
X#define V_magazine	131
X#define V_hoop		132
X#define V_snake		133
X#define V_bear		134
X#define V_wombat	135
X#define V_remove	136
X#define V_eject		137
X#define V_org_clip	138
X#define V_shut		139
X#define V_gleep		140
X#define V_gleeps	141
X#define V_letter	142
X#define V_envelope	143
X#define V_torch		144
X#define V_mail		145
X#define V_tank		146
X#define V_carefully	147
X#define V_gently	148
X#define V_softly	149
X#define V_slow_drop	150
X#define V_light		151
X#define V_ignite	152
X#define V_fuse		153
X#define V_slowly	154
X#define V_match		155
X#define V_cube		156
X#define V_blue		157
X#define V_blue_button	158
X#define V_gray		159
X#define V_gray_button	160
X#define V_clapper	161
X#define V_sound		162
X#define V_bang		163
X#define V_hit		164
X#define V_strike	165
X#define V_gong		166
X#define V_detector	167
X#define V_give		168
X#define V_stats		169
X#define V_jsys		170
X#define V_su		171
X#define V_yellow	172
X#define V_yellow_button	173
X#define V_poster	174
X#define V_eat		175
X#define V_swallow	176
X#define V_pill		177
X#define V_atropine	178
X#define V_packet	179
X#define V_wrapper	180
X#define V_tire		181
X#define V_shell		182
X#define V_brick		183
X#define V_rope		184
X#define V_package	185
X#define V_belt		186
X#define V_filter	187
X#define V_string	188
X#define V_cabinet	189
X#define V_calendar	190
X#define V_tackle	191
X#define V_bit		192
X#define V_jack		193
X#define V_pen		194
X#define V_pencil	195
X#define V_wire		196
X#define V_pipe		197
X#define V_panel		198
X#define V_opener	199
X#define V_cord		200
X#define V_photo		201
X#define V_chair		202
X#define V_bulb		203
X#define V_rag		204
X#define V_tube		205
X#define V_carpet	206
X#define V_branch	207
X#define V_cork		208
X#define V_trap		209
X#define V_lighter	210
X#define V_lace		211
X#define V_comb		212
X#define V_umbrella	213
X#define V_meadow	214
X#define V_billabong	215
X#define V_river		216
X#define V_road		217
X#define V_forest	218
X#define V_grass		219
X#define V_stream	220
X#define V_desert	221
X#define V_building	222
X#define V_office	223
X#define V_hideout	224
X#define V_dust		225
X#define V_mine		226
X#define V_tunnel	227
X#define V_tree		228
X#define V_spinifex	229
X#define V_hexagon	230
X#define V_spacecaft	231
X#define V_airlock	232
X#define V_wing		233
X#define V_hole		234
X#define V_tray		235
X#define V_liquid	236
X#define V_cockroach	237
X#define V_go		238
X#define V_scream	239
X#define V_yell		240
X#define V_bring		241
X#define V_help		242
X#define V_dump		243
X#define V_attack	244
X#define V_check		245
X#define V_inspect	246
X#define V_place		247
X#define V_touch		248
X#define V_pull		249
X#define V_extinguish	250
X#define V_ask		251
X#define V_talk		252
X#define V_tell		253
X#define V_find		254
X#define V_move		255
X#define V_break		256
X#define V_kick		257
X#define V_smash		258
X#define V_feed		259
X#define V_taste		260
X#define V_smell		261
X#define V_slam		262
X#define V_desk		263
X#define V_in		264
X#define V_into		265
X#define V_under		266
X#define V_out		267
X#define V_from		268
X#define V_by		269
X#define V_with		270
X#define V_fling		271
X#define V_what		272
X#define V_where		273
X#define V_are		274
X#define V_am		275
X#define V_have		276
X#define V_QUESTION	277
X#define V_how		278
X#define V_why		279
X#define V_who		280
X#define V_when		281
X#define V_leap		282
X#define V_walk		283
X#define V_run		284
X#define V_jump		285
X#define V_hop		286
X#define V_stroll	287
X#define V_saunter	288
X#define V_swagger	289
X#define V_swing		290
X#define V_dig		291
X#define V_swim		292
X#define V_depart	293
X#define V_info		294
X#define V_back		295
X#define V_hold		296
X#define V_fire		297
X#define V_stand		298
X#define V_painting	299
X#define V_doors		300
X#define V_treasure	301
X#define V_trigger	302
X#define V_load		303
X#define V_unload	304
X#define V_sand		305
X#define V_cockroaches	306
X#define V_kangaroo	307
X#define V_climb		308
X#define V_bulldust	309
X#define V_kangaroos	310
X#define V_spinifexes	311
X#define V_fuze		312
X#define V_message	313
X#define V_wall		314
X#define V_recorder	315
X#define V_red		316
X#define V_white		317
X#define V_green		318
X#define V_red_button	319
X#define V_white_button	320
X#define V_green_button	321
X#define V_grey		322
X#define V_matchbox	323
X#define V_map_frag	324
X#define V_circuit	325
X#define V_lift_door	326
X#define V_transporter	327
X#define V_warning	328
X#define V_explosive	329
X#define V_self		330
X#define V_myself	331
X#define V_yourself	332
X#define V_one		333
X#define V_two		334
X#define V_three		335
X#define V_four		336
X#define V_five		337
X#define V_toss		338
X#define V_chart		339
X#define V_charts	340
X#define V_schedule	341
X#define V_schedules	342
X#define V_orange_button	343
X
X/* Miscellaneous flags */
X#define FALSE		0
X#define TRUE		1
X#define F_asleep	8
X#define F_stealing	9
X#define F_passive	10
X#define F_aggressive	11
X#define F_killing	12
X#define F_no_monster	13
X#define F_monster_active	14
X#define F_no_argument	15
X#define F_safety	16
X#define F_single	17
X#define F_triple	18
X#define F_auto		19
X#define F_no_clip	20
X#define F_normal_clip	21
X#define F_org_clip	22
X#define F_wounded	23
X#define F_replace	24
X#define F_ignore	25
X#define F_died		26
X#define F_quit		27
X
X/* enemy/monster symbols */
X#define N_ned		0
X#define N_wombat	1
X#define N_drop_bear	2
X/* 2-5 drop bear   */
X#define N_hoop_snake	6
X/* 6-13 hoop snake */
X#define N_guards	14
X#define N_mullah	15
X 
X/* Object status as referred to in object->Location */
X#define B_have  	-1
X#define B_unmade	-2
X#define B_destroyed	-3
X#define B_in_safe	-5
X
X/* Object external property as referred to in object->Type */
X#define Z_normal	0
X#define Z_transform	1
X#define Z_alias		2
X#define Z_unmovable	3
X
X/* Structure for monsters */
Xstruct monster_struct { 
X	int Type ;	/* Monster type			      */
X	int Location ;	/* Location of the monster            */
X	int Status ;	/* Status of the monster              */
X	int Hits ;	/* Number of bullet hits into monster */
X} ;
X
Xtypedef struct monster_struct MONSTER_STRUCT;
X
X/* Structure for objects */
Xstruct object_struct {
X	int Location ; 	/* Object's location or status   */
X	int Value ;	/* Treasure value                */
X	int Type ;	/* Object's external property    */
X	int ID ;	/* Object ID number              */
X	int Weight ;	/* Object weight                 */
X	int Status ; 	/* Object's internal property    */
X	char *Text ;	/* Text string describing object */
X} ;
X
Xtypedef struct object_struct OBJECT_STRUCT;
X
X/* Structure for objects which can be examined or read */
Xstruct read_struct {
X	int ID ;	/* Object ID number              */
X	int Readable ;	/* TRUE if readable              */
X} ;
X
Xtypedef struct read_struct READ_STRUCT;
X
X/* Structure for adjectives */
Xstruct adjective_struct {
X	int Adjective ;		/* Adjective word number */
X	int Modified_noun ;	/* Noun to be modified word number */
X	int Generated_noun ;	/* Resultant noun from above adjective & noun */
X	int Command ;		/* Command or action done with resultant noun */
X} ;
X
Xtypedef struct adjective_struct ADJECTIVE_STRUCT;
X
X/* Structure for adverbs */
Xstruct adverb_struct {
X	int Adverb ;		/* Adverb word number */
X	int Modified_verb ;	/* Verb to be modified word number */
X	int Generated_verb ;	/* Resultant verb from above adverb & verb */
X} ;
X
Xtypedef struct adverb_struct ADVERB_STRUCT;
X
X
X
END_OF_FILE
if test 12377 -ne `wc -c <'dink_sym.h'`; then
    echo shar: \"'dink_sym.h'\" unpacked with wrong size!
fi
# end of 'dink_sym.h'
fi
if test -f 'dinkum.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dinkum.c'\"
else
echo shar: Extracting \"'dinkum.c'\" \(35524 characters\)
sed "s/^X//" >'dinkum.c' <<'END_OF_FILE'
X#define DINKUM
X#include "dink_sym.h"
X#include "dink_glb.h"
X#include <stdlib.h>
X
X/* ---------------- Version Date --------------- */
Xchar *lb_date = "30 January 1993" ;
X/* --------------------------------------------- */
X
X/*  ---- Version Number  ---- */
Xchar *lb_version = "2.12" ;
X/*  ------------------------- */
X
X/* ---------------- Version Type --------------- */
Xchar *lb_share = "[GAMES.SOURCES Version]" ;
X/* --------------------------------------------- */
X
X/*  ---- Serial Number  ---- */
X#define S_number 	1
Xint serial = S_number ;
X/*  ------------------------ */
X 
X/* Global variables local to this file only */
Xint sw_help = FALSE, sw_null = FALSE, sw_number = FALSE, sw_standard = FALSE ;
X
X/* MAIN PROGRAM --- MAIN PROGRAM --- MAIN PROGRAM --- MAIN PROGRAM */
X#if (PROTOTYPE)
Xvoid main(int argc, char *argv[])
X#else
Xvoid main(argc,argv)
Xint argc ;
Xchar *argv[] ;
X#endif
X/*********************************************************************/
X/*                                                                   */
X/*                   --- The Dinkum Program ---                      */
X/*                                                                   */
X/* Software by Gary A. Allen, Jr. 30 January 1993  Version: Mk 2.12  */
X/*            (c) Copyright 1993 by Gary A. Allen, Jr.               */
X/*                                                                   */
X/*********************************************************************/
X{
Xregister int i, j ;
X
Xint dig_1, dig_2, sw_loop ;
Xint move_dir, i_rand1, i_rand2, i_rand3, loc[3] ;
Xlong l_pass, l_base, *time_arg = 0 ;
Xchar chr, cmd[8] ;
X
XMONSTER_STRUCT *mnstr ;
XOBJECT_STRUCT *pnt ;
X
X#if (PROTOTYPE)
X/* Function prototypes ANSI C */
Xvoid cmd_switch(char[8], int, int, char *[]) ;
Xvoid bugs(int), help(void), locker(int) ;
Xvoid kelly(int), long_descp(int), objlooker(int), killer(int) ;
Xvoid gleeper(int), actor(int), ender(int), closer(int), opener(int) ;
Xvoid dialer(int), taker(int), dropper(int), describe(int) ;
Xvoid igniter(int), switcher(int), unlocker(int), sounder(int) ;
Xvoid loader(void), eater(void), filler(void), looker(int), exit(int) ;
Xvoid monster(int[3]), new_score(void), boom(void), parse(void) ;
Xint mover(int,int[3]) ; 
Xint yes_no(void) ;
Xvoid inventer(void), drinker(void), reader(int), pusher(int*);
Xvoid cheater(void) ; 
Xvoid pass(void), unloader(int) ;
Xlong time(long*) ;
Xchar getch(void), getche(void) ;
XOBJECT_STRUCT* point_to_object(int) ;
X
X#else
X/* Function prototypes K&R-C */
Xint mover() ; 
Xint yes_no() ;
Xlong time() ;
Xchar getch(), getche() ;
XOBJECT_STRUCT* point_to_object() ;
X#endif
X
X/* Software security */
Xif (serial != S_number) exit(0) ;  /* abort if serial number changed */
X
X/* Load the object pointers */
XRifle = point_to_object(V_rifle) ;
XTeapot = point_to_object(V_teapot) ;
XCan = point_to_object(V_can) ;
XClip = point_to_object(V_clip) ;
XOrg_clip = point_to_object(V_org_clip) ;
XRecorder = point_to_object(V_recorder) ;
XCap = point_to_object(V_cap) ;
XDynamite = point_to_object(V_dynamite) ;
XLetter = point_to_object(V_letter) ;
XClapper = point_to_object(V_clapper) ;
XDetector = point_to_object(V_detector) ;
XKey = point_to_object(V_key) ;
XUmbrella = point_to_object(V_umbrella) ;
XMatches = point_to_object(V_matches) ;
XPills = point_to_object(V_pills) ;
XCube = point_to_object(V_cube) ;
XTorch = point_to_object(V_torch) ;
XMat = point_to_object(V_mat) ;
XMap = point_to_object(V_map) ;
XMap_frag = point_to_object(V_map_frag) ;
XBottle = point_to_object(V_bottle) ;
XCircuit_breaker = point_to_object(V_circuit) ;
XLift = point_to_object(V_lift) ;
XDoor = point_to_object(V_door) ;
XSafe = point_to_object(V_safe) ;
XLift_door = point_to_object(V_lift_door) ;
XPicture = point_to_object(V_picture) ;
XTank = point_to_object(V_tank) ;
XGong = point_to_object(V_gong) ;
XTransporter = point_to_object(V_transporter) ;
X
X/* Scan the after the DOS/Unix command for switches or file name */
Xif (argc > 1) {
Xfor (i = 1; i <= argc-1; i++) {
X	/* Flush command vector */
X	for (j = 0; j <= 7; j++) cmd[j] = '\0' ;
X	/* Get command vector */
X	sscanf(argv[i],"%c%c%c%c%c%c%c%c%c", &chr, &cmd[0], &cmd[1],
X		&cmd[2], &cmd[3], &cmd[4], &cmd[5], &cmd[6], &cmd[7]) ;
X	sw_null = FALSE ;
X	if (chr == '?') help() ;
X	if (chr == '-') {
X		for (j = 0; j <= 7; j++) {
X			cmd_switch(cmd, j, i, argv) ;
X			if (sw_number) {
X				i++ ;
X				sw_number = FALSE ;
X				break ;
X			}
X			if (sw_null) break ;
X		} /* end of command "for" loop */
X
X		if (j > 7) {
Xprintf("\n!!!! Too many commands on one \"-\" switch group.\n") ;
Xprintf("!!!! Break up the commands into several \"-\" switch groups.\n") ;
X			bugs(Failed) ;
X		}  
X	} /* end of the "-" marker block */
X
X	/* Deal with garbage on the command line */
X	else {
Xprintf ("\n!!!! The following on the command line was not understood:  %s \n",
X	argv[i]);
X		bugs(Failed) ;
X	} /* Nondefault scratch file opening block */
X
X} /* end of argument token "for" loop */
X
Xif (sw_help) help() ;
X} /* end of the command switch block */
X
X/* Deal with someone cheating with switch "-s" */
Xif (sw_standard && (!sw_wizard)) {
X	printf("!!!! Command line switch -s is unknown.\n") ;
X	bugs(Failed) ;
X}
X 
X/* Software security */
Xif (serial != S_number) exit(0) ;  /* abort if serial number changed */
X
X/* Initialize the program */
Xsw_warned = FALSE ;
Xl_time = time(time_arg) ;
Xl_base = l_time/10 ;
Xl_base *= 10 ;
Xl_pass = l_time - l_base ;
Xdig_1 = (int)l_pass ;
Xloc[2] = 0 ; 	/* zero out the "old" location */
X
Xprintf("                    ") ;
Xprintf("                   --- Dinkum --- \n");
Xprintf("                    ") ;
Xprintf("     (c) Copyright 1993 by Gary A. Allen, Jr.\n") ;
Xprintf("                    ") ;
Xprintf("  All Rights Reserved. Version %s, %s\n\n",
X	lb_version, lb_date);
X
Xprintf("Would like some initial help with Dinkum?\n") ;
X
Xif (yes_no()) {
Xprintf("\nG'day Mate!  Welcome to \"Dinkum\" the Australian adventure");
Xprintf("\ngame.  In Dinkum you'll search for treasure in the\n") ;
Xprintf("Australian Outback.  You give the commands and I'll do the\n");
Xprintf("dangerous work. I understand most plain English sentences.\n");
Xprintf("If you want me to go east then type \"Will you please go\n");
Xprintf("east?\" and press the RETURN or ENTER key.  If you don't\n") ;
Xprintf("enjoy typing then just type \"e\" and press RETURN.  I'll\n");
Xprintf("still go east.  After you have gathered up some things\n") ;
Xprintf("you can see what you have by typing \"inventory\".\n") ;
Xprintf("Sometimes you can learn more about an object by typing\n");
Xprintf("\"examine NAME-OF-OBJECT\".  I understand many other\n") ;
Xprintf("commands and words.  However I'll let you have the fun of\n") ;
Xprintf("finding out what I can and can not understand. Good luck!\n\n");
X}
X
X/* produce two random numbers ranging from 0-9 based on system clock*/
Xl_time = time(time_arg) ;
Xstart_time = l_time ;
Xl_base = l_time/10 ;
Xl_base *= 10 ;
Xl_pass = l_time - l_base ;
Xdig_2 = (int)l_pass ;
X
X/* generate the actual random array pointers */
Xif (sw_standard) {
X	i_rand1 = 2 ; 
X	i_rand2 = 3 ;
X	i_rand3 = 1 ;
X}
Xelse {
X	i_rand3 = (dig_1 + dig_2)/2 ;
X	i_rand2 = dig_2/3 ;
X	i_rand1 = (dig_1/3) + 1 ;
X}
X
Xprintf("\nIt's a hot summer day (in January) in ") ;
Xprintf("Queensland, Australia.\n") ;
Xloc[1] = R_meadow ;
Xloc[0] = R_meadow ;
X
X/* Software security */
Xif (serial != S_number) exit(0) ;  /* abort if serial number changed */
X
X/* load objects into the rooms */
Xif (Gong->Status == S_recorder) Recorder->Location = R_meadow ;
Xpnt = object ;
Xfor (j = 0; j < Objcnt; j++) {
X	for (i = 0; i < Obj_init_max; i++) {
X		if (pnt->ID == obj_init[i][0]) {
X			pnt->Location = obj_init[i][i_rand1] ;
X			break ;
X		}
X	}
X	i = pnt->Location ;
X
X	/* Flag the presence of unmovable objects in each room */
X        if (pnt->Type == Z_unmovable) room[i][M_unmov_obj] = TRUE ; 
X
X	/* Count up number of movable objects in each room */
X	else if (i >= 0) ++room[i][M_obj_cnt] ;
X	
X	pnt++ ;
X}
X
Xcarry_count = 0 ;
Xcarry_weight = 0 ;
X
X/* Initialize the Monsters */
Xif ((monster_start = (MONSTER_STRUCT *)calloc((unsigned)(Enemy_cnt+1),
X		sizeof(MONSTER_STRUCT))) == 0) {
X	printf("\n---- PROBLEMS ----\n") ;
X	printf("RAM memory is full!\n") ; 
X	printf(" PROGRAM ABORTED\n") ;
X	exit(0) ;
X}
X
XNed = (monster_start + N_ned) ;        /* point to the Ned Kelly structure */
XGuards = (monster_start + N_guards) ;  /* point to the Guards structure */
XWombat = (monster_start + N_wombat) ;  /* point to the Wombat structure */
XMullah = (monster_start + N_mullah) ;  /* point to the Mullah structure */
X
X/* Load up the monster data structure */
Xfor (i = 0; i <= Enemy_cnt; i++) { 
X	mnstr = (monster_start + i) ; 	/* point to the monster */
X
X 	/* locate the monster */
X	if (i == 0) mnstr->Location = B_unmade ;
X	else mnstr->Location = mon_init[i-1][i_rand2] ;
X
X	/* All monsters are initially asleep */
X	mnstr->Status = F_asleep ;
X
X	/* Load Type numbers for the different monsters */
X	switch(i) {
X	case 2:
X	case 3:
X	case 4:
X	case 5:
X		mnstr->Type = N_drop_bear ;
X		break ;
X	case 6:
X	case 7:
X	case 8:
X	case 9:
X	case 10:
X	case 11:
X	case 12:
X	case 13:
X		mnstr->Type = N_hoop_snake ;
X		break ;
X	default:
X		mnstr->Type = i ;
X	} /* end of the monster Type switch block */
X
X	/* Monsters are initially healthy */
X	mnstr->Hits = 0 ;	
X
X	j = mnstr->Location ;
X	if (j != B_unmade) ++room[j][M_monster] ;
X} /* end of the monster data structure loadup "for" loop */
X 
X/* load the gleep reproductive locations and seed gleep */
Xfor (i = 0; i <= 9; i++)  
X	gleep_spot[i] = gleep_init[i][i_rand2] ;
Xroom[gleep_spot[0]-1][M_gleep] = 1 ; /* seed a nonreproductive spot */ 
X
X/* load safe passage for end-game killing passages  */
Xroom[218 + i_rand3][M_rm_type] = T_short_descp ;
X
X/* Beginning of outer infinite "for" loop */
Xfor(;;) {
X/* special action routine */
Xnew_score() ;  /* update the score */
X
X/* See if the game has timed out */
Xl_time = time(time_arg) ;
Xif ((!sw_warned) && (l_time > start_time + 3300L)) {
X	sw_warned = TRUE ;
X	start_time = l_time ;
Xprintf("There's suddenly a puff of blue smoke which fills the room\n") ;
Xprintf("with a hazy cloud.  Slowly this cloud coalesces into a\n") ;
Xprintf("ghostly human form.  This ethereal being is wearing a grey\n") ;
Xprintf("flannel suit, a bowler hat, and glancing at a gold pocket\n") ;
Xprintf("watch which is attached to a long golden chain.  You can\n");
Xprintf("hear \"Waltzing Matilda\" being played softly in the\n") ;
Xprintf("background.  You know what?  I think this ethereal being\n") ;
Xprintf("is none other than the ghost of Banjo Patterson!  With\n") ;
Xprintf("this realization Banjo looks up in your direction and\n") ;
Xprintf("begins to speak:\n\n") ;
Xprintf("\"Sorry mate, you've been at this for too long!  You've\n") ;
Xprintf("got five more minutes to go and then you're history!\"\n\n") ;
Xprintf("Then just as suddenly Banjo Patterson dissolves back into\n") ;
Xprintf("smoke and disappears from view.\n\n") ;
X}
Xif (sw_warned && (l_time > start_time + 300L)) {
Xprintf("You hear someone clearing his throat behind you.  You turn\n") ;
Xprintf("around and see Banjo Patterson has appeared once again.  An\n");
Xprintf("old brass chain is hanging from mid air next to Banjo.  On\n") ;
Xprintf("the end of the chain is a white porcelain tear drop shaped\n");
Xprintf("nob with the word \"PULL\" written on it in black letters.\n") ;
Xprintf("Banjo reaches for the nob and says the following:\n\n\"Sorry") ;
Xprintf(" mate, your time has come!  Better luck next time!\"\n\n");
Xprintf("He gives the chain a quick jerk and everything around you\n") ;
Xprintf("slowly fades from view.\n\n") ;
X	ender(F_quit) ;
X}
X
Xkelly(loc[0]) ; /* check if Ned Kelly can do something */
X 
X/* Check if there is a long description */
Xif ((!((room[R_hideout][M_monster] > 0) && (loc[0] == R_hideout))) &&
X	(!((monster_flag == F_monster_active) && (loc[2] == loc[0])))) {
X
X	loc[2] = 0 ;
X
X/* Check if there is to be a long room description */
Xif (room[loc[0]][M_rm_type] == T_long_descp) long_descp(loc[0]) ;
Xelse {
X	describe(loc[0]) ;  /* short description */
X
X	/* describe unmovable action objects and status */
X	if (room[loc[0]][M_unmov_obj]) actor(loc[0]) ;
X}
X
Xobjlooker(loc[0]) ; /* Check if there are objects in the room */
Xgleeper(loc[0]) ;   /* check for gleeps and update the gleep count */
X
X/* see if the spaceship's transporter is active */
Xif (Transporter->Status) {
X	if (loc[0] == R_ship_passage) Transporter->Status = FALSE ;
X	else if (loc[0] == R_transporter) {
X		loc[0] = R_closet ;
X		Transporter->Status = FALSE ;
Xprintf("\nSuddenly radiant energy seems to surge from the hexagons\n");
Xprintf("around you.  Then there is a bright flash and you find\n");
Xprintf("yourself in.....\n\n") ;
Xprintf("A closet stinking of moth balls full of nondescript junk.\n") ;
Xprintf("The only exit is to the north through a curtain hanging\n");
Xprintf("over the entrance.\n\n") ; 
X	}
X} /* end of the "transporter" block */
X} /* end of long description check block */
X
Xfor(;;) {
Xsw_loop = FALSE ;
X
X/* monster check */
Xif ((room[loc[0]][M_monster] > 0)||(monster_flag != F_no_monster)) {
X	if (monster_flag == F_wounded) monster_flag = F_monster_active ;
X	else monster(loc) ;
X} /* end of the monster check block */
X
X/* parse in the command */
Xparse();
X
X/* poison check */
X/* remove atropine drug with each game cycle */
Xif (i_poison > 0) --i_poison ;
Xelse {
X	/* accumulate poison if holding the orange clip */
X	if (Org_clip->Location == B_have) {
X		--i_poison ;
X		switch (i_poison) {
X		case -20:
X	printf("You've developed a nervous tick near your eye.\n") ;
X			break ;
X		case -30:
X	printf("You're hands are starting to shake ") ;
X	printf("and you're sweating like a pig.\n") ;	
X			break ;
X		case -35:
X	printf("You're shaking so bad you can barely stand and you ");
X	printf("could lose your lunch\nat any moment.\n") ;
X			break ;
X		case -40:
Xprintf("The toxic fumes coming off of the orange ammo clip you were ") ;
Xprintf("carrying finally\ncaught up with you.  You fall over DEAD!\n") ;
X			ender(F_died) ;
X		}
X	}
X	/* remove poison after release of orange clip */
X	else if (i_poison < 0) ++i_poison ;
X} /* end of the poison check block */
X
X/* clock check */
Xif (sw_clock) {
X	switch (flag_clock) {
X	/* see if the blasting cap is to explode */
X	case V_cap:
X		if (time(time_arg) > clock_explode) {
X			if (Cap->Location == B_have) {
Xprintf("                           POP!!\n") ;
Xprintf("The blasting cap which you were stupidly holding in your\n") ;
Xprintf("hand just blew up and took two of your fingers with it!\n") ;
Xprintf("Good thing you've got another eight fingers to spare!\n\n") ;
X				carry_count-- ;
X				carry_weight -= Cap->Weight ;
X			}
X			else {
Xprintf("Far down the tunnel you hear a POP!\n") ;
Xprintf("The blasting cap has finally exploded, not that it\n");
Xprintf("achieved much except make a loud noise.\n\n") ;
X			}
X			Cap->Location = B_destroyed ;
X			sw_clock = FALSE ;
X		}
X		break ;
X	
X	/* see if the dynamite is to explode */
X	case V_dynamite:
X		if (time(time_arg) > clock_explode) {
X			/* player dies if he is holding the dynamite */
X			if (Dynamite->Location == B_have) {
X			boom() ;
X
Xprintf("The dynamite which you were holding and had earlier ignited\n");
Xprintf("the fuse has finally exploded.  That was a rather noisy\n");
Xprintf("and messy way to commit suicide!  Needless to say there is\n");
Xprintf("nothing left of you but a greasy spot.\n") ;
X			ender(F_died) ;
X			}
X			/* player dies if too close during explosion */
X			else {
X				if (((loc[0] <= 185) && (loc[0] >= 178))
X				  || ((loc[0] <= 170) && (loc[0] >= 166))) {
X					boom() ;
X
Xprintf("You weren't far enough away from the dynamite when it\n");
Xprintf("exploded!  The shock wave was still strong enough to blow\n");
Xprintf("your brains out your ears.  Next time try to get to the\n") ;
Xprintf("upper level before the dynamite goes off.\n") ;
X					ender(F_died) ;
X				}
X
X				/* dynamite explodes and player survives */
X				else {
Xprintf("Far down the tunnel you hear a low BOOM!\n") ;
Xprintf("That dynamite you set burning has finally exploded.\n\n");
X
X/* open up the passage to the UFO */
Xif (Dynamite->Location == R_blast_point) {
X	room[R_blast_point][1] = 186 ;
X	room[R_blast_point][M_descp] = 55 ;
X					}
X				}
X			}
X			Dynamite->Location = B_destroyed ;
X			sw_clock = FALSE ;
X		} /* end of the dynamite explodes block */
X		break ;
X	}
X} /* end of the clock block */
X
X/* the command is a simple move command */
Xif (tag[V_MOVE]) {
X	if (mover(verb,loc)) break ;
X	continue ;
X} /* end of the "move" block */
X
X/* complicated command decoder */
Xswitch (verb) {
X 
X/* "help" command */
Xcase V_help:
Xcase V_info:
Xprintf("There is no help available.  You're on your own!\n") ;
X	break ;
X 
X/* "quit" command */
Xcase V_quit:
X	ender(F_quit) ;
X
X/* "question" command */
Xcase V_QUESTION:
X	if (tag[V_VERB_ONLY]) {
X		if (tag[V_how]) {
Xprintf("That's for you to figure out.\n") ;
X			break ;
X		}
Xprintf("I don't have a clue!\n") ;
X		break ;
X	}
X
X	/* Question "Where am I?" */
X	if (tag[V_where] && tag[V_am]) {
X		tag[V_VERB_ONLY] = TRUE ; /* This is for "looker" */
X		looker(loc[0]) ;
X		break ;
X	}
X
X	/* Question "What have I got?" */
X	if (tag[V_what] && tag[V_have]) {
X		inventer() ;
X		break ;
X	}
X
X	/* Question which can't be processed */
Xprintf("You asked a question.  Unfortunately I have no answers.\n") ;
X	break ;
X
X/* "inventory" command */
Xcase V_inventory: 
Xcase V_invent:
X	inventer() ;
X	break;
X
X/* "close" command  */
Xcase V_close:
Xcase V_shut:
X	closer(loc[0]) ;
X	break;
X
X/* "open" command  */
Xcase V_open:
Xcase V_swing:
X	opener(loc[0]) ;
X	break;
X
X/* "dial" command  */
Xcase V_dial:
Xcase V_combination:
X	dialer(loc[0]) ;
X	break ;
X 
X/* "drink" command */
Xcase V_drink: 
X	drinker() ;
X	break ;
X
X/* "ignite" command */
Xcase V_ignite: 
Xcase V_light: 
X	igniter(loc[0]) ;
X	break ;
X
X/* "read" command  */
Xcase V_read:
X	reader(loc[0]) ;
X	break;
X 
X/* "push" command  */
Xcase V_push:
Xcase V_press:
X	pusher(&loc[0]) ; 
X	break ;
X 
X/* "turn", "switch" command */
Xcase V_switch:
Xcase V_turn:
Xcase V_select:
Xcase V_set:
X	switcher(loc[0]) ;
X	break ;
X 
X/* "shoot" command  */
Xcase V_shoot:
Xcase V_fire:
Xcase V_kill:
X	killer(loc[0]) ;
X	break;
X 
X/* "unlock" command  */
Xcase V_unlock:
X	unlocker(loc[0]) ;
X	break;
X 
X/* "lock" command  */
Xcase V_lock:
X	locker(loc[0]) ;
X	break;
X 
X/* "eat" command  */
Xcase V_eat:
Xcase V_swallow:
X	eater() ;
X	break;
X 
X/* "fill" command  */
Xcase V_fill:
X	filler() ;
X	break;
X 
X/* "sound" command  */
Xcase V_sound:
Xcase V_bang:
Xcase V_hit:
Xcase V_strike:
X	sounder(loc[0]) ;
X	break;
X
X/* "SVC" wizard move command */
X/* This command had an error in it discovered by Per-Anders Eriksson. */
X/*      Thanks, Per-Anders!                                           */
Xcase V_svc:
X	if (sw_wizard) {
X		printf ("Enter room coordinate number:  ");
X		scanf ("%d",&loc[0]);
X		monster_flag = F_no_monster ; /* turn off monsters */
X		sw_loop = TRUE ;
X		break ;
X	}
X	else cheater() ;
X
X/* "STATS" game statistics */
Xcase V_stats :
X		printf("      --- Dinkum --- \n");
X		printf("Version: %s, %s\n\n", lb_version, lb_date);
X		printf("i_rand1 = %d, i_rand2 = %d, i_rand3 = %d\n",
X			i_rand1, i_rand2, i_rand3) ;
X		printf("Room Number = %d\n", loc[0]) ;
X		printf("Room object count = %d \n",
X			room[loc[0]][M_obj_cnt]) ;
X		printf("Room monster count = %d\n",
X			room[loc[0]][M_monster]) ; 
X		printf("Gleeps on room's floor count = %d\n",
X			room[loc[0]][M_gleep]) ;
X		printf("Poison level = %d\n",i_poison) ;
X		printf("Gleep count = %d\n", gleep_count) ;
X		printf("carry_count = %d, carry_weight = %d\n",
X			carry_count, carry_weight) ;
X		break ;
X
X/* "SU" wizard initiation command */
Xcase V_su:
X	pass() ;
X	break ;
X
X/* "JSYS" wizard command which deactivates a monster */
Xcase V_jsys:
X	if (sw_wizard) monster_flag = F_no_monster ;
X	else cheater() ;
X	break ;
X
X/* "score" command */
Xcase V_score: 
X	new_score() ;
X	if ((Tank->Status == 0)&&(score == 0)) {
Xprintf("You haven't scored anything at all, Bozo! Try putting\n");
Xprintf("a valuable into the safe or find some gleeps.\n") ;
X		break ;
X	}
X	if (score == 0) { 
X		if (Tank->Status > 1) {
Xprintf("You haven't scored any points but you splashed ") ;
Xprintf ("%d gleeps into the gleep tank.\n",Tank->Status) ;
X		}
X		else {
Xprintf("You haven't scored any points at all but you did put a\n");
Xprintf ("gleep in the gleep tank (big deal!).\n") ;
X		}
X	}
X	else {
Xprintf ("You scored %d points ",score) ;
X		if (Tank->Status == 0) 
Xprintf ("but have yet to put any gleeps in the gleep tank.\n") ;
X		else {
X			if (Tank->Status > 1) 
Xprintf ("and put %d gleeps into the gleep tank.\n",Tank->Status) ;
X	
X			else 
Xprintf ("and put a gleep in the gleep tank.\n") ;
X		}
X	}
X	break ;
X 
X/* "enter" command  */
Xcase V_enter:
Xswitch (loc[0]) {
X 
X	/* Lift entrance at the ground level */
X	case R_lift_entr:
X		if (room[R_lift_entr][2] == R_WALL) {
Xprintf("I can't do it!  The lift door needs to be opened.\n") ;
X			continue ;
X		}
X		move_dir = V_east ;
X		break ;
X	/* office door */
X	case R_office_entr:
X		if (room[R_office_entr][2] == R_WALL) {
Xprintf("I can't go in!  The office door needs to be opened.\n") ;
X			continue ;
X		}
X		move_dir = V_east ;
X		break ;
X	/* Lift entrance at level #49 */
X	case R_L49_entr:
X		move_dir = V_east ;
X		break ;
X	/* Entrance to Ned Kelly's hideout */
X	case R_hideout_entr:
X		move_dir = V_east ;
X		break ;
X
X	/* Enter gleep tank (and suicide) */
X	case R_gleep_tank:
X		if (tag[V_tank]) {
Xprintf("\nYou climb up onto the edge of the gleep tank and dip your\n");
Xprintf("foot into the dark blue fluid.  Suddenly the fluid begins a\n");
Xprintf("furious boiling that instantly reduces your foot into\n") ;
Xprintf("bleached white bones.  The shock and pain disturbs your\n");
Xprintf("balance and you fall into the horrible stuff!!  There is\n");
Xprintf("once again a furious boiling.  Eventually the fluid stills\n");
Xprintf("and becomes clear again.  On the bottom of the tank can\n") ;
Xprintf("be seen a white, clean, \"medical school quality\" human\n");
Xprintf("skeleton.\n") ;
X			ender(F_died) ;
X		}
X 
X	default:
X	printf("I don't understand exactly how to enter. \n");
X		continue ;
X} /* end of the "enter" switch block */
Xif (mover(move_dir, loc)) sw_loop = TRUE ;
Xbreak ;
X
X/* "exit" command  */
Xcase V_exit:
Xcase V_leave:
Xcase V_depart:
Xswitch (loc[0]) {
X 
X	/* Lift entrance at the ground level */
X	case R_lift_inside:
X		move_dir = V_west ;
X		break ;
X	/* office door */
X	case R_office_hall:
X		move_dir = V_west ;
X		break ;
X	/* Ned Kelly's hideout */
X	case R_hideout :
X		move_dir = V_west ;
X		break ;
X	default:
Xprintf("I don't understand exactly how you want to exit.\n");
X		continue ;
X} /* end of the "depart" switch block */
Xif (mover(move_dir, loc)) sw_loop = TRUE ;
Xbreak ;
X
X/* "dig" command */
Xcase V_dig:
Xprintf("You get on your knees and scrape away at the ground for\n") ;
Xprintf("awhile. Except for getting your hands dirty you didn't\n") ;
Xprintf("achieve much.\n") ;
X	break ;
X
X/* "stand" command */
Xcase V_stand:
Xprintf("You're standing there very nicely.  However you're not\n");
Xprintf("achieving much by doing so.\n") ;
X	break ;
X
X/* "load" rifle command */
Xcase V_load:
X	loader() ;
X	break ;
X
X/* "unload" rifle command */
Xcase V_unload:
X	unloader(loc[0]) ;
X	break ;
X
X/* "pull" command */
Xcase V_pull:
X	if (tag[V_trigger]) {
X		/* alias in the "shoot" command */
X		verb = V_shoot ;
X		tag[V_VERB_ONLY] = TRUE ;
X		killer(loc[0]) ;   /* "pull trigger" */
X	}
X	else  printf("I don't see how I could pull that.\n") ;
X	break ;
X
X/* "climb" command */
Xcase V_climb:
Xprintf("I'm not climbing anything!  (I'm afraid of heights.)\n") ;
X	break ;
X
X/* "swim" command */
Xcase V_swim:
Xprintf("I'm not going for a swim!  (I'm afraid of the water.)\n") ;
X	break ;
X
X/* Go backwards to previous location */
Xcase V_back:
X	loc[0] = loc[1] ;
X	sw_loop = TRUE ;
X	break ;
X 
X/* "take", "get", "lift" command */
Xcase V_take:
Xcase V_get:
Xcase V_lift:
Xcase V_pick:
Xcase V_grab:
Xcase V_remove:
Xcase V_attach:
Xcase V_hold:
X	taker(loc[0]) ;
X	break ;
X 
X/* "drop", "throw", "put" command */
Xcase V_drop:
Xcase V_throw:
Xcase V_put:
Xcase V_fling:
Xcase V_toss:
Xcase V_insert:
Xcase V_give:
Xcase V_eject:
Xcase V_slow_drop:
X	dropper(loc[0]) ;
X	break ;
X
X/* "look" command */
Xcase V_look:
Xcase V_view:
Xcase V_examine:
Xcase V_inspect:
Xcase V_describe:
X	looker(loc[0]) ;
X	break;
X
X/* gibberish command */
Xdefault:
Xprintf("Huh?  You will have to make yourself clearer! \n");
X
X} /* end of "decoder" switch */
Xif (sw_loop) break ;
X} /* end of the inner infinite "for" loop */
X} /* end of the outer infinite "for" loop */
X
X} /* --- end of Main routine --- */
X
X#if (PROTOTYPE)
Xvoid cmd_switch(char cmd[8], int cmd_arg, int i_point, char *argv[])
X#else
Xvoid cmd_switch(cmd, cmd_arg, i_point, argv)
Xchar cmd[8], *argv[] ;
Xint cmd_arg, i_point ;
X#endif
X/*****************************************************/
X/*                                                   */
X/*         --- Command line Switch Parser ---        */
X/*                                                   */
X/*  (c) Copyright 1992,   University of Queensland   */
X/*        Program written by Gary A. Allen, Jr.      */
X/*           Version:  Mk 1.1   24 February 1992     */
X/*                                                   */
X/*****************************************************/
X{
X
X#if (PROTOTYPE)
Xvoid bugs(int), pass(void) ;
X#endif
X
Xswitch (cmd[cmd_arg]) {
Xcase '\0':
Xcase -1:
X	sw_null = TRUE ;
X	return ;
X
X/* Activate save script capability */
Xcase 's':
Xcase 'S':
X	Gong->Status = S_recorder ;
X	break ;
X
X/* Version verification command switch */
Xcase 'v':
X	if ((cmd[cmd_arg+1] == 'e')&&(cmd[cmd_arg+2] == 'r')) {
X		printf("Version: %s, Serial Number: %06d %s \n", 
X			lb_version, serial, lb_share) ;
X		bugs(Request) ;
X	}
X	else {
X		printf("!!!! Command line switch -v is unknown.\n") ;
X		bugs(Failed) ;
X	}
X
X/* Wizard mode command switch */
Xcase 'w':
Xcase 'W':
X	pass() ;
X	break ;
X
X/* Standard matrix load command switch */
Xcase 'x':
Xcase 'X':
X	sw_standard = TRUE ;
X	break ;
X
X/* Rubbish option to supress a warning */
Xcase 'y':
Xcase 'Y':
X	sw_number = TRUE ;
X	printf("y = %d\n", atoi(argv[i_point+1])) ;
X	return ;
X
X/* Help option */
Xcase '?':
Xcase 'h':
Xcase 'H':
X	sw_help = TRUE ;
X	return ;
X
Xcase ' ':
Xcase '-':
Xcase '1':
Xcase '2':
Xcase '3':
Xcase '4':
Xcase '5':
Xcase '6':
Xcase '7':
Xcase '8':
Xcase '9':
X	return ;
X
Xdefault:
Xprintf("!!!! Command line switch -%c is unknown.\n", cmd[cmd_arg]) ;
X	bugs(Failed) ;
X}
X} /* --- end of the cmd_switch subroutine --- */
X
X#if (PROTOTYPE)
Xvoid bugs(int i_type)
X#else
Xvoid bugs(i_type)
Xint i_type ;
X#endif
X/***************************************************************/
X/*                                                             */
X/*       (c) Copyright 1992,   University of Queensland        */
X/*            Program written by Gary A. Allen, Jr.            */
X/*             Version:  Mk 1.0        24 April 1992           */
X/*                                                             */
X/***************************************************************/
X{
Xswitch(i_type) {
Xcase Failed:
X	printf("!!!! If confused, type:  dinkum -h \n");
X	printf("!!!! --- Program ABORTED --- \n");
X	break ;
X
Xcase Request:
X	printf("Program terminated by user request.\n") ;
X	break ;
X
Xcase Logic_error:
X	printf("Please refer to program author's address by typing\n") ;
X	printf("\"dinkum -h\" and inform the author of this error.\n") ;
X	printf("             --- Program ABORTED ---\n") ;
X	break ;
X}
Xexit (0) ; 
X} /* --- end of the "bugs" subroutine --- */
X
X#if (PROTOTYPE)
Xvoid help(void) 
X#else
Xvoid help() 
X#endif
X/*****************************************************/
X/*                                                   */
X/*                    Help Routine                   */
X/*                                                   */
X/*  (c) Copyright 1992,   University of Queensland   */
X/*        Program written by Gary A. Allen, Jr.      */
X/*           Version:  Mk 1.0    24 April 1992       */
X/*                                                   */
X/*****************************************************/
X{
Xchar chr ;
X
Xprintf("                    --- Dinkum --- \n");
Xprintf("       (c) Copyright 1993 by Gary A. Allen, Jr.\n") ;
Xprintf("   All Rights Reserved. Version: %s, %s\n\n", 
X		lb_version, lb_date);
X
Xprintf("      Dinkum is a text style \"adventure\" game.\n\n") ;
X
Xprintf("You are free to use, copy and distribute Dinkum provided:\n") ;
Xprintf("       NO FEE IS CHARGED FOR USE, COPYING OR DISTRIBUTION.\n") ;
Xprintf("       THIS PROGRAM IS FOR PRIVATE, NONCOMMERICAL USE ONLY.\n");
Xprintf("       THE PROGRAM MAY NOT BE MODIFIED IN ANY WAY.\n\n") ;
X
Xprintf("This program is provided AS IS without any warranty,\n") ;
Xprintf("expressed or implied, including but not limited to fitness\n") ;
Xprintf("for any particular purpose.\n\n") ;
X
X/* keep the screen from scrolling */
X#ifndef __TURBOC__
Xprintf("         [Press RETURN or ENTER to continue]") ;
Xchr = getchar() ;
X#endif
X
X#ifdef __TURBOC__
Xprintf("  [Press \"q\" to quit or any other key to continue]") ;
Xchr = getche() ;
Xprintf("\r                                                        \r") ;
X#endif
X
Xif ((chr == 'q')||(chr == 'Q')) exit (0) ;
X
Xprintf("If you start the game by typing \"dinkum -s\" rather than \n");
Xprintf("simply \"dinkum\" then the game creates a \"data recorder\" \n"); 
Xprintf("which appears in the beginning  of  the game.  The data \n"); 
Xprintf("recorder acts like a tape recorder allowing the user to \n"); 
Xprintf("save moves and play them back in the current  or  later \n"); 
Xprintf("games.  The generated file is in ASCII format  and  can \n"); 
Xprintf("be  edited  after  finishing  Dinkum.    Type  \"examine \n"); 
Xprintf("recorder\" after having taken it and Dinkum will explain \n"); 
Xprintf("how to use it.  This data  recorder  has  a  couple  of \n"); 
Xprintf("important  limitations:   Unlike  most adventure games, \n"); 
Xprintf("Dinkum is  dynamic,  viz.  the  game changes every time \n"); 
Xprintf("you play it.  So if you record  a  script  for  a  game \n"); 
Xprintf("which takes you to a room where you find a  weapon  and \n"); 
Xprintf("then to another room where you find a monster, then the \n"); 
Xprintf("next time you use  that script you may find the monster \n"); 
Xprintf("where you  previously  found  the  weapon (leading to a \n"); 
Xprintf("fairly short game). The other limitation  of  the  data \n"); 
Xprintf("recorder is if you use the \"dinkum -s\" switch then  you \n"); 
Xprintf("will  not  be  admitted  into  the  end  game  with the \n"); 
Xprintf("consequence being that  \"winning\" Dinkum is impossible. \n"); 
Xprintf("To win Dinkum you must  play  it  \"on your own\" without \n"); 
Xprintf("the unfair advantage of script files and data recorders.\n\n");
X
X/* keep the screen from scrolling */
X#ifndef __TURBOC__
Xprintf("         [Press RETURN or ENTER to continue]") ;
Xchr = getchar() ;
X#endif
X
X#ifdef __TURBOC__
Xprintf("  [Press \"q\" to quit or any other key to continue]") ;
Xchr = getche() ;
Xprintf("\r                                                        \r") ;
X#endif
X
Xif ((chr == 'q')||(chr == 'Q')) exit (0) ;
X
Xprintf("When corresponding please state the current version of\n") ;
Xprintf("Dinkum which you are using.  Contributions and questions\n") ;
Xprintf("about this program should be sent to the following address:\n\n") ;
Xprintf("          E-mail address:     gary@sun.mech.uq.oz.au\n\n") ;
Xprintf("          Postal address:     Gary A. Allen, Jr. \n");
Xprintf("                              P.O. Box 13\n") ;       
Xprintf("                              St. Lucia, Queensland  4067\n");
Xprintf("		 	 	            Australia\n") ;
X
Xexit(0);
X} /* ---- end of the "help" subroutine ---- */
X
X#if (PROTOTYPE)
Xvoid cheater(void) 
X#else
Xvoid cheater() 
X#endif
X/*****************************************************/
X/*                                                   */
X/*  (c) Copyright 1992,   University of Queensland   */
X/*        Program written by Gary A. Allen, Jr.      */
X/*           Version:  Mk 1.0   9 December 1992      */
X/*                                                   */
X/*****************************************************/
X{
Xprintf("Rather than cheat at this game by using a disassembler, you\n");
Xprintf("should send the author $150 and he'll gladly send you\n") ;
Xprintf("the source code.  If you just want a clue, then send $20\n") ;
Xprintf("with your question and he'll provide the answer.  You can find\n") ;
Xprintf("the author's address by typing:  dinkum -h\n") ;
X		exit(0) ;
X} /* ---- end of the "cheater" subroutine ---- */
X
X#if (PROTOTYPE)
Xint mover(int direction, int loc[3])
X#else
Xint mover(direction,loc)
Xint direction, loc[3] ;
X#endif
X/*****************************************************/
X/*                                                   */
X/*  (c) Copyright 1992,   University of Queensland   */
X/*        Program written by Gary A. Allen, Jr.      */
X/*           Version:  Mk 1.0  17 December 1992      */
X/*                                                   */
X/*****************************************************/
X{
X
X#if (PROTOTYPE)
X/* Function prototypes */
Xvoid long_descp(int), ender(int), boom(void) ;
X#endif
X
X/* see if this movement prohibits blasting caps */
Xif (((direction == V_u)||(direction == V_up)) &&
X		((loc[0] == R_manhole_1)||(loc[0] == R_manhole_2))) {
X
X	if (Cap->Location == B_have) {
Xprintf("As you were climbing up through the hole in the ceiling,\n");
Xprintf("the blasting cap slipped from your grasp and fell to the\n") ;
Xprintf("floor below where it detonated on impact.  The explosion\n") ;
Xprintf("was deafening, but caused no damage.\n") ;
X		carry_count-- ;
X		carry_weight -= Cap->Weight ;
X		Cap->Location = B_destroyed; 
X	}
X	else {
X		if ((Dynamite->Location == B_have)&&(Dynamite->Type == Z_alias)) {
X			boom() ;
X
Xprintf("As you were climbing up through the hole in the ceiling,\n");
Xprintf("the dynamite with the blasting cap inside slipped from\n") ;
Xprintf("your grasp and fell to the floor below where it detonated\n") ;
Xprintf("on impact.  At that point you literally became a human\n");
Xprintf("cannon ball as the shock wave carried you up the vertical\n");
Xprintf("passage and splattered you into protoplasmic jelly on the\n");
Xprintf("ceiling above.\n") ; 
X			ender(F_died) ;
X		}
X	}
X} /* end of the cap/manhole block */
X
Xdirection-- ;
Xif (room[loc[0]][direction] == R_WALL) {
X	printf("You can't go that way. \n");
X	return(FALSE) ;
X}
X
X/* save previous location */
Xloc[1] = loc[0] ;
Xloc[0] = room[loc[0]][direction] ;
X
X/* See if player walked into a lethal room */
Xif (room[loc[0]][M_rm_type] == T_lethal) {
X	long_descp(loc[0]) ;
X	ender(F_died) ;
X}
Xreturn(TRUE) ;
X} /* --- end of the "mover" function --- */
X
X#if (PROTOTYPE)
Xint yes_no(void)
X#else
Xint yes_no()
X#endif
X/*****************************************************/
X/*                                                   */
X/*  (c) Copyright 1993,   University of Queensland   */
X/*        Program written by Gary A. Allen, Jr.      */
X/*           Version:  Mk 1.0  27 January 1993       */
X/*                                                   */
X/*****************************************************/
X{
X
Xchar chr ;
X
X#if (PROTOTYPE)
X/* Function prototypes ANSI C */
Xchar getch(void), getche(void) ;
X
X#else
X/* Function prototypes K&R-C */
Xchar getch(), getche() ;
X#endif
X
Xfor (;;) {
X
X#ifndef __TURBOC__
X	do {
X		printf("(Answer:  Yes or No) ") ; 
X	} while ('\n' == (chr = getchar())) ;
X
X	while ('\n' != getchar()) ;
X#endif
X
X#ifdef __TURBOC__
X	printf("\n") ;
X	do {
X		printf("(Answer:  Yes or No) ") ; 
X	} while ('\n' == (chr = getch())) ;
X	printf("\n") ;
X#endif
X
X	if (('n' == chr)||('N' == chr)||('y' == chr)||('Y' == chr)) break ;
X} /* end of the infinite "for" loop */
X
Xif (('y' == chr)||('Y' == chr)) return(TRUE) ;
Xelse return(FALSE) ;
X
X} /* --- end of the "yes_no" function --- */
END_OF_FILE
if test 35524 -ne `wc -c <'dinkum.c'`; then
    echo shar: \"'dinkum.c'\" unpacked with wrong size!
fi
# end of 'dinkum.c'
fi
if test -f 'make.unx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make.unx'\"
else
echo shar: Extracting \"'make.unx'\" \(972 characters\)
sed "s/^X//" >'make.unx' <<'END_OF_FILE'
XCFLAGS =  -c
XHEAD = dink_sym.h dink_glb.h
X
X# Don't add anymore files because the makefile with the Borland Ver. 2
X#    Tlink will choke and die.
X
XOBJECTS = dinkum.o describe.o longdsc.o objlook.o actor.o \
Xpusher.o monster.o opener.o parse.o taker.o
Xdinkum: $(OBJECTS)
X	cc $(OBJECTS) -o dinkum
Xdinkum.o: dinkum.c $(HEAD)
X	cc $(CFLAGS) dinkum.c
Xdescribe.o: describe.c $(HEAD)
X	cc $(CFLAGS) describe.c
Xlongdsc.o: longdsc.c $(HEAD)
X	cc $(CFLAGS) longdsc.c
Xobjlook.o: objlook.c $(HEAD)
X	cc $(CFLAGS) objlook.c
Xpusher.o: pusher.c $(HEAD)
X	cc $(CFLAGS) pusher.c
Xactor.o: actor.c $(HEAD)
X	cc $(CFLAGS) actor.c
Xmonster.o: monster.c $(HEAD)
X	cc $(CFLAGS) monster.c
Xopener.o: opener.c $(HEAD)
X	cc $(CFLAGS) opener.c
Xtaker.o: taker.c $(HEAD)
X	cc $(CFLAGS) taker.c
X
Xparse.o: parse.c $(HEAD)
X# Replace with PROMPT if you want a prompt with every command entry.
X# This modification was suggested by Chris Herborth.  Thanks, Chris!
X#	cc $(CFLAGS) -DPROMPT parse.c
X	cc $(CFLAGS) parse.c
X
END_OF_FILE
if test 972 -ne `wc -c <'make.unx'`; then
    echo shar: \"'make.unx'\" unpacked with wrong size!
fi
# end of 'make.unx'
fi
if test -f 'makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile'\"
else
echo shar: Extracting \"'makefile'\" \(972 characters\)
sed "s/^X//" >'makefile' <<'END_OF_FILE'
XCFLAGS =  -c
XHEAD = dink_sym.h dink_glb.h
X
X# Don't add anymore files because the makefile with the Borland Ver. 2
X#    Tlink will choke and die.
X
XOBJECTS = dinkum.o describe.o longdsc.o objlook.o actor.o \
Xpusher.o monster.o opener.o parse.o taker.o
Xdinkum: $(OBJECTS)
X	cc $(OBJECTS) -o dinkum
Xdinkum.o: dinkum.c $(HEAD)
X	cc $(CFLAGS) dinkum.c
Xdescribe.o: describe.c $(HEAD)
X	cc $(CFLAGS) describe.c
Xlongdsc.o: longdsc.c $(HEAD)
X	cc $(CFLAGS) longdsc.c
Xobjlook.o: objlook.c $(HEAD)
X	cc $(CFLAGS) objlook.c
Xpusher.o: pusher.c $(HEAD)
X	cc $(CFLAGS) pusher.c
Xactor.o: actor.c $(HEAD)
X	cc $(CFLAGS) actor.c
Xmonster.o: monster.c $(HEAD)
X	cc $(CFLAGS) monster.c
Xopener.o: opener.c $(HEAD)
X	cc $(CFLAGS) opener.c
Xtaker.o: taker.c $(HEAD)
X	cc $(CFLAGS) taker.c
X
Xparse.o: parse.c $(HEAD)
X# Replace with PROMPT if you want a prompt with every command entry.
X# This modification was suggested by Chris Herborth.  Thanks, Chris!
X#	cc $(CFLAGS) -DPROMPT parse.c
X	cc $(CFLAGS) parse.c
X
END_OF_FILE
if test 972 -ne `wc -c <'makefile'`; then
    echo shar: \"'makefile'\" unpacked with wrong size!
fi
# end of 'makefile'
fi
echo shar: End of archive 2 \(of 7\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
