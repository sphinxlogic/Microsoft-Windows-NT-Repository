Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i019:  gbp - Galactic Bloodshed+, an empire-like war game, Part07/21
Message-ID: <4547@master.CNA.TEK.COM>
Date: 12 Feb 93 17:30:45 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1643
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1698

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 19
Archive-name: gbp/Part07
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 21)."
# Contents:  hdrs/proto.h server/doplanet.c
# Wrapped by billr@saab on Fri Feb 12 09:14:25 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'hdrs/proto.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdrs/proto.h'\"
else
echo shar: Extracting \"'hdrs/proto.h'\" \(18590 characters\)
sed "s/^X//" >'hdrs/proto.h' <<'END_OF_FILE'
X#ident  "%W% %G% %Q%"
X/***********************************************
X * proto.h
X *
X * Created: Thu Jan 28 16:08:03 EST 1993
X * Author:  J. Deragon (deragon@jethro.nyu.edu)
X *
X * Version: %I% %U%
X * 
X * File with ALL the function prototypes.
X * (replaces numerous *.p)
X */
X
X/* GB_server.c function prototypes */
X
Xextern void notify_race(int, char *);
Xextern int notify(int, int, char *);
Xextern void d_think(int, int, char *);
Xextern void d_broadcast(int, int, char *, int);
Xextern void d_shout(int, int, char *);
Xextern void d_announce(int, int, int, char *);
Xextern void do_next_thing(void);
Xextern void load_race_data(void);
Xextern void load_star_data(void);
Xextern void GB_time(int, int);
Xextern void GB_schedule(int, int);
Xextern void check_for_telegrams(int, int);
Xextern void kill_ship(int, shiptype *);
Xextern void compute_power_blocks(void);
Xextern void insert_sh_univ(struct stardata *, shiptype *);
Xextern void insert_sh_star(startype *, shiptype *);
Xextern void insert_sh_plan(planettype *, shiptype *);
Xextern void insert_sh_ship(shiptype *, shiptype *);
Xextern void remove_sh_star(shiptype *);
Xextern void remove_sh_plan(shiptype *);
Xextern void remove_sh_ship(shiptype *, shiptype *);
Xextern double GetComplexity(int);
Xextern int ShipCompare(int *, int *);
Xextern void SortShips(void);
Xextern void warn_race(int, char *);
Xextern void warn(int, int, char *);
Xextern void warn_star(int, int, int, char *);
Xextern void notify_star(int, int, int, int, char *);
Xextern void post_star(char *, int, int);
Xextern void adjust_morale(racetype *, racetype *, int);
Xextern void version(int, int);
X
X/* VN.c prototypes */
Xextern void do_VN(shiptype *);
Xextern void planet_doVN(shiptype *, planettype *);
Xextern void order_berserker(shiptype *);
Xextern void order_VN(shiptype *);
X/*
X * analysis.c prototypes
X*/
X
Xextern void analysis(int, int, int);
Xextern void do_analysis(int, int, int, int, int, int, int);
X
X/* autoreport.c function prototypes */
X
Xextern void autoreport(int, int, int);
X
X/*
Xautoshoot.c function prototypes
X*/
X
Xextern int Bombard(shiptype *, planettype *, racetype *);
X
X/*
Xbuild.c function prototypes
X*/
X
Xextern void upgrade(int, int, int);
Xextern void make_mod(int, int, int, int);
Xextern void build(int, int, int);
Xextern int getcount(int, char *);
Xextern int can_build_at_planet(int, int, startype *, planettype *);
Xextern int get_build_type(char *);
Xextern int can_build_this(int, racetype *, char *);
Xextern int can_build_on_ship(int, racetype *, shiptype *, char *);
Xextern int can_build_on_sector(int, racetype *, planettype *, sectortype *, 
X	int, int, char *);
Xextern int build_at_ship(int, int, racetype *, shiptype *, int *, int *);
Xextern void autoload_at_planet(int, shiptype *, planettype *, sectortype *, int *,
X			double *);
Xextern void autoload_at_ship(int, shiptype *, shiptype *, int *, double *);
Xextern void initialize_new_ship(int, int, racetype *, shiptype *, double, int);
Xextern void create_ship_by_planet(int, int, racetype *, shiptype *, planettype *,
X			   int, int, int, int);
Xextern void create_ship_by_ship(int, int, racetype *, int, startype *, planettype *,
X			 shiptype *, shiptype *);
Xextern double getmass(shiptype *);
Xextern int ship_size(shiptype *);
Xextern double cost(shiptype *);
Xextern void system_cost(double *, double *, int, int);
Xextern double complexity(shiptype *);
Xextern void Getship(shiptype *, int, racetype *);
Xextern void Getfactship(shiptype *, shiptype *);
Xextern int Shipcost(int, racetype *);
Xextern void sell(int, int, int);
Xextern void bid(int, int, int);
Xextern int shipping_cost(int, int, double *, int);
X/* capital.c function prototypes */
X
Xextern void capital(int, int, int);
X
X/* capture.c function prototypes */
X
Xextern void capture(int, int, int);
Xextern void capture_stuff(shiptype *);
X
X/* cs.c function prototypes */
X
Xextern void center(int, int, int);
Xextern void do_prompt(int, int);
Xextern void cs(int, int, int);
X
X/* declare.c function prototypes */
X
Xextern void invite(int, int, int, int);
Xextern void declare(int, int, int);
Xextern void vote(int, int, int);
Xextern void show_votes(int, int);
Xextern void pledge(int, int, int, int);
X/* dissolve.c function prototypes */
X
Xextern void dissolve(int, int);
Xextern int revolt(planettype *, int, int);
X
X/* dock.c function prototypes */
X
Xextern void dock(int, int, int, int);
X
X/* doplanet.c function prototypes */
X
Xextern int doplanet(int, planettype *, int);
Xextern int moveship_onplanet(shiptype *, planettype *);
Xextern void terraform(shiptype *, planettype *);
Xextern void plow(shiptype *, planettype *);
Xextern void do_dome(shiptype *, planettype *);
Xextern void do_quarry(shiptype *, planettype *);
Xextern void do_recover(planettype *, int, int);
Xextern double est_production(sectortype *);
X
X/* dosector.c function prototypes */
X
Xextern void produce(startype *, planettype *, sectortype *);
Xextern void spread(planettype *, sectortype *, int, int);
Xextern void Migrate2(planettype *, int, int, sectortype *, int *);
Xextern void explore(planettype *, sectortype *, int, int, int);
Xextern void plate(sectortype *);
X
X/* doship.c function prototypes */
X
Xextern void doship(shiptype *, int);
Xextern void domass(shiptype *);
Xextern void doown(shiptype *);
Xextern void domissile(shiptype *);
Xextern void domine(int, int);
Xextern void doabm(shiptype *);
Xextern void do_repair(shiptype *);
Xextern void do_habitat(shiptype *);
Xextern void do_pod(shiptype *);
Xextern int infect_planet(int, int, int);
Xextern void do_meta_infect(int, planettype *);
Xextern void do_canister(shiptype *);
Xextern void do_greenhouse(shiptype *);
Xextern void do_mirror(shiptype *);
Xextern void do_god(shiptype *);
Xextern void do_ap(shiptype *);
Xextern double crew_factor(shiptype *);
Xextern double ap_planet_factor(planettype *);
Xextern void do_oap(shiptype *);
Xextern int do_weapon_plant(shiptype *);
X
X
X/* doturn.c function prototypes */
X
Xextern void do_turn(int);
Xextern int APadd(int, int, racetype *);
Xextern int governed(racetype *);
Xextern void fix_stability(startype *);
Xextern void do_reset(int);
Xextern void handle_victory(void);
Xextern void make_discoveries(racetype *);
X#ifdef MARKET
Xextern void maintain(racetype *, int, int);
X#endif
Xextern int attack_planet(shiptype *);
Xextern void output_ground_attacks(void);
Xextern int planet_points(planettype *);
X
X/* enslave.c function prototypes */
X
Xextern void enslave(int, int, int);
X
X/* examine.c function prototypes */
X
Xextern void examine(int, int, int);
X
X/* explore.c function prototypes */
X
Xextern void colonies_at_star(int, int, racetype *, int, int);
Xextern void colonies(int, int, int, int);
Xextern void distance(int, int, int);
Xextern void star_locations(int, int, int);
Xextern void exploration(int, int, int);
Xextern void tech_status(int, int, int);
Xextern void tech_report_star(int, int, startype *, int, int *, double *, double *);
X
X/* files_rw.c function prototypes */
X
Xextern void Fileread(int, char *, int, int);
Xextern void Filewrite(int, char *, int, int);
X
X/* files_shl.c function prototypes */
X
Xextern void close_file(int);
Xextern void open_data_files(void);
Xextern void close_data_files(void);
Xextern void openstardata(int *);
Xextern void openshdata(int *);
Xextern void opencommoddata(int *);
Xextern void openpdata(int *);
Xextern void opensectdata(int *);
Xextern void openracedata(int *);
Xextern void getsdata(struct stardata *S);
X#ifdef DEBUG
Xextern void DEBUGgetrace(racetype **, int, char *, int);
Xextern void DEBUGgetstar(startype **, int, char *, int);
Xextern void DEBUGgetplanet(planettype **, int, int, char *, int);
Xextern int DEBUGgetship(shiptype **, int, char *, int);
Xextern int DEBUGgetcommod(commodtype **, int, char *, int);
X#else
Xextern void getrace(racetype **, int);
Xextern void getstar(startype **, int);
Xextern void getplanet(planettype **, int, int);
Xextern int getship(shiptype **, int);
Xextern int getcommod(commodtype **, int);
X#endif
Xextern void getsector(sectortype **, planettype *, int, int);
Xextern void getsmap(sectortype *, planettype *);
Xextern int getdeadship(void);
Xextern int getdeadcommod(void);
Xextern void putsdata(struct stardata *);
Xextern void putrace(racetype *);
Xextern void putstar(startype *, int);
Xextern void putplanet(planettype *, int, int);
Xextern void putsector(sectortype *, planettype *, int, int);
Xextern void putsmap(sectortype *, planettype *);
Xextern void putship(shiptype *);
Xextern void putcommod(commodtype *, int);
Xextern int Numraces(void);
Xextern int Numships(void);
Xextern int Numcommods(void);
Xextern int Newslength(int);
Xextern void clr_shipfree(void);
Xextern void clr_commodfree(void);
Xextern void makeshipdead(int);
Xextern void makecommoddead(int);
Xextern void Putpower(struct power [MAXPLAYERS]);
Xextern void Getpower(struct power [MAXPLAYERS]);
Xextern void Putblock(struct block [MAXPLAYERS]);
Xextern void Getblock(struct block [MAXPLAYERS]);
X
X/* fire.c function prototypes */
X
Xextern void fire(int, int, int, int);
Xextern void bombard(int, int, int);
Xextern void defend(int, int, int);
Xextern void detonate(int, int, int);
Xextern int retal_strength(shiptype *);
Xextern int adjacent(int, int, int, int, planettype *);
Xextern int landed(shiptype *);
Xextern void check_overload(shiptype *, int, int *);
Xextern void check_retal_strength(shiptype *, int *);
Xextern int laser_on(shiptype *);
X
X/* fuel.c function prototypes */
X
Xextern void proj_fuel(int, int, int);
Xextern void fuel_output(int, int, double, double, double, double, int);
Xextern int do_trip(double, double);
X
X/* get4args function prototypes */
X
Xextern void get4args(char *, int *, int *, int *, int *);
X
X/* getplace.c function prototypes */
X
Xextern placetype Getplace(int, int, char *, int);
Xextern placetype Getplace2(int, int, char *, placetype *, int, int);
Xextern char *Dispshiploc_brief(shiptype *);
Xextern char *Dispshiploc(shiptype *);
Xextern char *Dispplace(int, int, placetype *);
Xextern int testship(int, int, shiptype *);
X
X/* land.c function prototypes */
X
Xextern void land(int, int, int);
Xextern int crash(shiptype *, double);
Xextern int docked(shiptype *);
Xextern int overloaded(shiptype *);
X
X/* launch.c function prototypes */
X
Xextern void launch(int, int, int);
X
X/* load.c function prototypes */
X
Xextern void load(int, int, int, int);
Xextern void jettison(int, int, int);
Xextern int jettison_check(int, int, int, int);
Xextern void dump(int, int, int);
Xextern void transfer(int, int, int);
Xextern void mount(int, int, int, int);
Xextern void use_fuel(shiptype *, double);
Xextern void use_destruct(shiptype *, int);
Xextern void use_resource(shiptype *, int);
Xextern void use_popn(shiptype *, int, double);
Xextern void rcv_fuel(shiptype *, double);
Xextern void rcv_resource(shiptype *, int);
Xextern void rcv_destruct(shiptype *, int);
Xextern void rcv_popn(shiptype *, int, double);
Xextern void rcv_troops(shiptype *, int, double);
Xextern void do_transporter(racetype *, int, shiptype *);
Xextern int landed_on(shiptype *, int);
Xextern void unload_onto_alien_sector(int, int, planettype *, shiptype *,
X				      sectortype *, int, int);
X
X/* map.c function prototypes */
X
Xextern void map(int, int, int);
Xextern void show_map(int, int, int, int, planettype *, int, int);
Xextern char desshow(int, int, planettype *, int, int, racetype *);
X
X/* max.c function prototypes */
X
Xextern int maxsupport(racetype *, sectortype *, double, int);
Xextern double compatibility(planettype *, racetype *);
Xextern double gravity(planettype *);
Xextern char *prin_ship_orbits(shiptype *);
X
X/* misc.c function prototypes */
X
Xextern double logscale(int);
X
X/* mobiliz.c function prototypes */
X
Xextern void mobilize(int, int, int);
Xextern void tax(int, int, int);
Xextern int control(int, int, startype *);
X
X/* move.c function prototypes */
X
Xextern void arm(int, int, int, int);
Xextern void move_popn(int, int, int);
Xextern void walk(int, int, int);
Xextern int get_move(char, int, int, int *, int *, planettype *);
Xextern void mech_defend(int, int, int *, int, planettype *, int, int, sectortype *,
X		 int, int, sectortype *);
Xextern void mech_attack_people(shiptype *, int *, int *, racetype *, racetype *,
X			sectortype *, int, int, int, char *, char *);
Xextern void people_attack_mech(shiptype *, int, int, racetype *, racetype *,
X			sectortype *, int, int, char *, char *);
Xextern void ground_attack(racetype *, racetype *, int *, int, unsigned short *,
X		   unsigned short *, unsigned int, unsigned int,
X		   double, double, double *, double *, int *, int *, int *);
X
X/* moveplanet.c function prototypes */
X
Xextern void moveplanet(int, planettype *, int);
X
X/* moveship.c function prototypes */
X
Xextern void Moveship(shiptype *, int, int, int);
Xextern void msg_OOF(shiptype *);
Xextern int followable(shiptype *, shiptype *);
Xextern int do_merchant(shiptype *, planettype *);
X
X/* name.c function prototypes */
X
Xextern void personal(int, int, char *);
Xextern void bless(int, int, int);
Xextern void insurgency(int, int, int);
Xextern void pay(int, int, int);
Xextern void give(int, int, int);
Xextern void page(int, int, int);
Xextern void send_message(int, int, int, int);
Xextern void read_messages(int, int, int);
Xextern void motto(int, int, int, char *);
Xextern void name(int, int, int);
Xextern int MostAPs(int, startype *);
Xextern void announce(int, int, char *, int, int);
X
X/* orbit.c function prototypes */
X
Xextern void orbit(int, int, int);
Xextern void DispStar(int, int, int, startype *, int, int, char *);
Xextern void DispPlanet(int, int, int, planettype *, char *, int, racetype *, char *);
Xextern void DispShip(int, int, placetype *, shiptype *, planettype *, int, char *);
X
X/* order.c function prototypes */
X
Xextern void order(int, int, int);
Xextern void give_orders(int, int, int, shiptype *);
Xextern char *prin_aimed_at(int, int, shiptype *);
Xextern char *prin_ship_dest(int, int, shiptype *);
Xextern void mk_expl_aimed_at(int, int, shiptype *);
Xextern void DispOrdersHeader(int, int);
Xextern void DispOrders(int, int, shiptype *);
Xextern void route(int, int, int);
X
X
X/* perm.c function prototypes */
X
Xextern void PermuteSects(planettype *);
Xextern int Getxysect(planettype *, int *, int *, int);
X
X/* power.c function prototypes */
X
Xextern void block(int, int, int);
Xextern void power(int, int, int);
Xextern void prepare_output_line(racetype *, racetype *, int, int);
X
X/* prof.c function prototypes */
X
Xextern void whois(int, int, int);
Xextern void profile(int, int, int);
Xextern char *Estimate_f(double, racetype *, int);
Xextern char *Estimate_i(int, racetype *, int);
Xextern int round_perc(int, racetype *, int);
Xextern void treasury(int, int);
X/* rand.c function prototypes */
X
Xextern double double_rand(void);
Xextern int int_rand(int, int);
Xextern int round_rand(double);
Xextern int rposneg(void);
X
X/* read_teleg.c function prototypes */
X
Xextern void teleg_read(int, int);
Xextern void news_read(int, int, int);
X
X/* relation.c function prototypes */
X
Xextern void relation(int, int, int);
Xextern char *allied(racetype *, int, int, int);
X
X/* rst.c function prototypes */
X
Xextern void rst(int, int, int, int);
Xextern void ship_report(int, int, int, unsigned char []);
Xextern void plan_getrships(int, int, int, int);
Xextern void star_getrships(int, int, int);
Xextern int Getrship(int, int, int);
Xextern void Free_rlist(void);
Xextern int listed(int, char *);
X
X/* scrap.c function prototypes */
X
Xextern void scrap(int, int, int);
X
X/* shlmisc.c function prototypes */
X
Xextern char *Ship(shiptype *s);
Xextern void grant(int, int, int);
Xextern void governors(int, int, int);
Xextern void do_revoke(racetype *, int, int);
Xextern int authorized(int, shiptype *);
Xextern int start_shiplist(int, int, char *);
Xextern int do_shiplist(shiptype **, int *);
Xextern int in_list(int, char *, shiptype *, int *);
Xextern void fix(int, int);
Xextern int match(char *, char *);
Xextern void DontOwnErr(int, int, int);
Xextern int enufAP(int, int, unsigned short, int);
Xextern int Getracenum(char *, char *, int *, int *);
Xextern int GetPlayer(char *);
Xextern void allocateAPs(int, int, int);
Xextern void deductAPs(int, int, int, int, int);
Xextern void list(int, int);
Xextern double morale_factor(double);
X#if DEBUG
Xextern char *DEBUGmalloc(int, char *, int);
Xextern void DEBUGfree(char *);
Xextern char *DEBUGrealloc(char *, int, char *, int);
Xextern void DEBUGcheck(int, int);
Xextern void DEBUGreset(int, int);
X#endif
X
X/* shootblast.c function prototypes */
X
Xextern int shoot_ship_to_ship(shiptype *, shiptype *, int, int, int, char *,
X			       char *);
X#ifdef DEFENSE
Xextern int shoot_planet_to_ship(racetype *, planettype *, shiptype *, int,
X				 char *, char *);
X#endif
Xextern int shoot_ship_to_planet(shiptype *, planettype *, int, int, int, int, int,
X				 int, char *, char *);
Xextern int do_radiation(shiptype *, double, int, int, char *, char *);
Xextern int do_damage(int, shiptype *, double, int, int, int, int, double, char *,
X		      char *);
Xextern void ship_disposition(shiptype *, int *, int *, int *);
Xextern int CEW_hit(double, int);
Xextern int Num_hits(double, int, int, double, int, int, int, int, int, int, int,
X		     int);
Xextern int hit_odds(double, int *, double, int, int, int, int, int, int, int, int);
Xextern int cew_hit_odds(double, int);
Xextern double gun_range(racetype *, shiptype *, int);
Xextern double tele_range(int, double);
Xextern int current_caliber(shiptype *);
Xextern void do_critical_hits(int, shiptype *, int *, int *, int, char *);
Xextern void do_collateral(shiptype *, int, int *, int *, int *, int *);
Xextern int getdefense(shiptype *);
Xextern double p_factor(double, double);
Xextern int planet_guns(int);
Xextern void mutate_sector(sectortype *);
X
X/* survey.c function prototypes */
X
Xextern void survey(int, int, int, int);
Xextern void repair(int, int, int);
X
X/* tech.c function prototypes */
X
Xextern void technology(int, int, int);
Xextern double tech_prod(int, int);
X
X/* teleg_send.c function prototypes */
X
Xextern void purge(void);
Xextern void post(char *, int);
Xextern void push_telegram_race(int, char *);
Xextern void push_telegram(int, int, char *);
X
X/* toggle.c function prototypes */
X
Xextern void toggle(int, int, int);
Xextern void highlight(int, int);
Xextern void tog(int, int, char *, char *);
X
X/* toxicity.c function prototypes */
X
Xextern void toxicity(int, int, int);
X
X/* victory.c function prototypes */
X
Xextern void victory(int, int);
Xextern void create_victory_list(struct vic [MAXPLAYERS]);
Xextern int victory_sort(struct vic *, struct vic *);
X
X/* zoom.c function prototypes */
X
Xextern void zoom(int, int);
X
X/* client.c function prototypes */
Xextern void CSP_process_command(int, int);
Xextern void CSP_client_on(int , int);
Xextern void CSP_client_off(int, int);
Xextern void CSP_client_toggle(int, int, int);
Xextern void CSP_client_version(int, int );
END_OF_FILE
if test 18590 -ne `wc -c <'hdrs/proto.h'`; then
    echo shar: \"'hdrs/proto.h'\" unpacked with wrong size!
fi
# end of 'hdrs/proto.h'
fi
if test -f 'server/doplanet.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/doplanet.c'\"
else
echo shar: Extracting \"'server/doplanet.c'\" \(33331 characters\)
sed "s/^X//" >'server/doplanet.c' <<'END_OF_FILE'
X#ident  "@(#)doplanet.c	1.7 1/31/93 "
Xint             Sectormappos;
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h. doplanet.c -- do one turn on a planet.
X */
X
X#include <math.h>
X/* #include <malloc.h> */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "doturn.h"
X#include "power.h"
X#include "buffers.h"
X
Xextern long     Shipdata[NUMSTYPES][NUMABILS];
X
X/* types of accidents that can occur on a toxic planet. */
Xchar           *Accidents_uninhab[] = {
X	/* on water sectors */
X	"Widespread waste spill",
X	"Ecological instability",
X	/* on land sectors */
X	"Massive volcanic eruptions",
X	"Ecological instability",
X	/* on mountain sectors */
X	"Massive volcanic eruptions",
X	"Ecological instability",
X	/* gas sectors */
X	"Lethal toxin concentration",
X	"Ecological instability",
X	/* ice */
X	"Leak in isolated chemical plant",
X	"Continental warming cause glacial melting",
X	/* plate */
X	"Nuclear accident",
X	"Untended nuclear plant explodes"
X};
X
Xchar           *Accidents_inhab[] = {
X	"Nuclear accident",
X	"Terrorists trigger nuclear weapon",
X	"Release of toxic waste",
X	"Weapons dump explosion",
X	"Massive starvation",
X	"Virus epidemic",
X	"famine",
X	"starvation",
X	"Widespread cultist suicide",
X	"Atomic experiment gone wrong",
X	"Great Hrung collapse"
X};
X
Xint             doplanet(int, planettype *, int);
Xint             moveship_onplanet(shiptype *, planettype *);
Xvoid            terraform(shiptype *, planettype *);
Xvoid            plow(shiptype *, planettype *);
Xvoid            do_dome(shiptype *, planettype *);
Xvoid            do_quarry(shiptype *, planettype *);
Xvoid            do_recover(planettype *, int, int);
Xdouble          est_production(sectortype *);
X
X#include "proto.h"
X
Xint 
Xdoplanet(int starnum, planettype * planet, int planetnum)
X{
X	int             shipno, x, y, nukex, nukey;
X	int             o = 0;
X	char			*nukem;
X	reg int         i;
X	sectortype     *p;
X	shiptype       *ship;
X	double          fadd;
X	int             timer = 20;
X	unsigned char   allmod = 0, allexp = 0;
X
X	Sectormappos = planet->sectormappos;
X	/*
X	 * if (!(Stars[starnum]->inhabited[0]+Stars[starnum]->inhabited[1]))
X	 * return 0;  /* no one's here now
X	 */
X
X	getsmap(Smap, planet);
X	PermuteSects(planet);
X	bzero((char *) Sectinfo, sizeof(Sectinfo));
X
X	bzero((char *) avg_mob, sizeof(avg_mob));
X	bzero((char *) sects_gained, sizeof(sects_gained));
X	bzero((char *) sects_lost, sizeof(sects_lost));
X	bzero((char *) prod_res, sizeof(prod_res));
X	bzero((char *) prod_fuel, sizeof(prod_fuel));
X	bzero((char *) prod_destruct, sizeof(prod_destruct));
X	bzero((char *) prod_crystals, sizeof(prod_crystals));
X
X	tot_resdep = prod_eff = prod_mob = tot_captured = 0;
X	Claims = 0;
X
X	planet->maxpopn = 0;
X
X	planet->popn = 0;	/* initialize population for recount */
X	planet->troops = 0;
X	planet->total_resources = 0;
X
X	/* reset global variables */
X	for (i = 1; i <= Num_races; i++) {
X		Compat[i - 1] = compatibility(planet, races[i - 1]);
X		planet->info[i - 1].numsectsowned = 0;
X		planet->info[i - 1].troops = 0;
X		planet->info[i - 1].popn = 0;
X		planet->info[i - 1].est_production = 0.0;
X		prod_crystals[i - 1] = 0;
X		prod_fuel[i - 1] = 0;
X		prod_destruct[i - 1] = 0;
X		prod_res[i - 1] = 0;
X		avg_mob[i - 1] = 0;
X	}
X
X	shipno = planet->ships;
X	while (shipno) {
X		ship = ships[shipno];
X		if (ship->alive && !ship->rad) {
X			/*
X			 * planet level functions - do these here because
X			 * they use the sector map or affect planet
X			 * production
X			 */
X			switch (ship->type) {
X			case OTYPE_TERRA:
X				if (ship->on && landed(ship) && ship->popn)
X					if (ship->fuel >= (double) FUEL_COST_TERRA)
X						terraform(ship, planet);
X					else if (!ship->notified) {
X						ship->notified = 1;
X						msg_OOF(ship);
X					}
X				break;
X			case OTYPE_PLOW:
X				if (ship->on && landed(ship)) {
X					if (ship->fuel >= (double) FUEL_COST_PLOW)
X						plow(ship, planet);
X					else if (!ship->notified) {
X						ship->notified = 1;
X						msg_OOF(ship);
X					}
X				} else if (ship->on) {
X					sprintf(buf, "K%d is not landed.", ship->number);
X					push_telegram(ship->owner, ship->governor, buf);
X				} else {
X					sprintf(buf, "K%d is not switched on.", ship->number);
X					push_telegram(ship->owner, ship->governor, buf);
X				}
X				break;
X			case OTYPE_DOME:
X				if (ship->on && landed(ship)) {
X					if (ship->resource >= RES_COST_DOME)
X						do_dome(ship, planet);
X					else {
X						sprintf(buf, "Y%d does not have enough resources.", ship->number);
X						push_telegram(ship->owner, ship->governor, buf);
X					}
X				} else if (ship->on) {
X					sprintf(buf, "Y%d is not landed.", ship->number);
X					push_telegram(ship->owner, ship->governor, buf);
X				} else {
X					sprintf(buf, "Y%d is not switched on.", ship->number);
X					push_telegram(ship->owner, ship->governor, buf);
X				}
X				break;
X			case OTYPE_WPLANT:
X				if (landed(ship))
X					if (ship->resource >= RES_COST_WPLANT
X					  && ship->fuel >= FUEL_COST_WPLANT)
X						prod_destruct[ship->owner - 1] += do_weapon_plant(ship);
X					else {
X						if (ship->resource < RES_COST_WPLANT) {
X							sprintf(buf, "W%d does not have enough resources.", ship->number);
X							push_telegram(ship->owner, ship->governor, buf);
X						} else {
X							sprintf(buf, "W%d does not have enough fuel.", ship->number);
X							push_telegram(ship->owner, ship->governor, buf);
X						}
X					}
X				else {
X					sprintf(buf, "W%d is not landed.", ship->number);
X					push_telegram(ship->owner, ship->governor, buf);
X				}
X				break;
X			case OTYPE_QUARRY:
X				if (ship->on && landed(ship) && ship->popn)
X					if (ship->fuel >= FUEL_COST_QUARRY)
X						do_quarry(ship, planet);
X					else if (!ship->notified) {
X						ship->on = 0;
X						msg_OOF(ship);
X					} else {
X						if (!ship->on) {
X							sprintf(buf, "q%d is not switched on.", ship->number);
X						}
X						if (!landed(ship)) {
X							sprintf(buf, "q%d is not landed.", ship->number);
X						}
X						if (!ship->popn) {
X							sprintf(buf, "q%d does not have workers aboard.", ship->number);
X						}
X						push_telegram(ship->owner, ship->governor, buf);
X					}
X				break;
X			}
X			/* add fuel for ships orbiting a gas giant */
X			if (!landed(ship) && planet->type == TYPE_GASGIANT) {
X				switch (ship->type) {
X				case STYPE_TANKER:
X					fadd = FUEL_GAS_ADD_TANKER;
X					break;
X				case STYPE_HABITAT:
X					fadd = FUEL_GAS_ADD_HABITAT;
X					break;
X				default:
X					fadd = FUEL_GAS_ADD;
X					break;
X				}
X				fadd = MIN((double) Max_fuel(ship) - ship->fuel, fadd);
X				rcv_fuel(ship, fadd);
X			}
X		}
X		shipno = ship->nextship;
X	}
X
X	/*
X	 * if (!Stinfo[starnum][planetnum].inhab) return 0;  /* (no one's
X	 * explored the planet)
X	 */
X
X	/* check for space mirrors (among other things) warming the planet */
X	/* if a change in any artificial warming/cooling trends */
X	planet->conditions[TEMP] = planet->conditions[RTEMP] +
X		Stinfo[starnum][planetnum].temp_add + int_rand(-5, 5);
X
X
X	(void) Getxysect(planet, &x, &y, 1);
X
X	while (Getxysect(planet, &x, &y, 0)) {
X		p = &Sector(*planet, x, y);
X
X		if (p->owner && (p->popn || p->troops)) {
X			allmod = 1;
X			if (!Stars[starnum]->nova_stage) {
X				produce(Stars[starnum], planet, p);
X				if (p->owner)
X					planet->info[p->owner - 1].est_production += est_production(p);
X				spread(planet, p, x, y);
X			} else {
X				/* damage sector from supernova */
X				p->resource++;
X				p->fert *= 0.8;
X				if (Stars[starnum]->nova_stage == 14)
X					p->popn = p->owner = p->troops = 0;
X				else
X					p->popn = round_rand((double) p->popn * .50);
X			}
X			Sectinfo[x][y].done = 1;
X		}
X		if ((!p->popn && !p->troops) || !p->owner) {
X			p->owner = 0;
X			p->popn = p->troops = 0;
X		}
X		/*
X		 * if (p->wasted) { if (x>1 && x<planet->Maxx-2) { if
X		 * (p->des==DES_SEA || p->des==DES_GAS) { if ( y>1 &&
X		 * y<planet->Maxy-2 && (!(p-1)->wasted || !(p+1)->wasted) &&
X		 * !random()%5) p->wasted = 0; } else if (p->des==DES_LAND ||
X		 * p->des==DES_MOUNT || p->des==DES_ICE) { if ( y>1 &&
X		 * y<planet->Maxy-2 && ((p-1)->popn || (p+1)->popn) &&
X		 * !random()%10) p->wasted = 0; } } }
X		 */
X		/*
X		 * if (Stars[starnum]->nova_stage) { if (p->des==DES_ICE)
X		 * if(random()&01) p->des = DES_LAND; else if
X		 * (p->des==DES_SEA) if(random()&01) if ( (x>0 &&
X		 * (p-1)->des==DES_LAND) || (x<planet->Maxx-1 &&
X		 * (p+1)->des==DES_LAND) || (y>0 &&
X		 * (p-planet->Maxx)->des==DES_LAND) || (y<planet->Maxy-1 &&
X		 * (p+planet->Maxx)->des==DES_LAND ) ) { p->des = DES_LAND;
X		 * p->popn = p->owner = p->troops = 0; p->resource +=
X		 * int_rand(1,5); p->fert = int_rand(1,4); } }
X		 */
X	}
X
X
X	(void) Getxysect(planet, &x, &y, 1);
X	while (Getxysect(planet, &x, &y, 0)) {
X		p = &Sector(*planet, x, y);
X		if (p->owner)
X			planet->info[p->owner - 1].numsectsowned++;
X	}
X
X	if (planet->expltimer >= 1)
X		planet->expltimer--;
X	if (!Stars[starnum]->nova_stage && !planet->expltimer) {
X		if (!planet->expltimer)
X			planet->expltimer = 5;
X		for (i = 1; !Claims && !allexp && i <= Num_races; i++) {
X			/* sectors have been modified for this player */
X			if (planet->info[i - 1].numsectsowned)
X				while (!Claims && !allexp && timer > 0) {
X					timer -= 1;
X					o = 1;
X					(void) Getxysect(planet, &x, &y, 1);
X					while (!Claims && Getxysect(planet, &x, &y, 0)) {
X						/*
X						 * find out if all sectors
X						 * have been explored
X						 */
X						o &= Sectinfo[x][y].explored;
X						p = &Sector(*planet, x, y);
X						if (((Sectinfo[x][y].explored == i) && !(random() & 02))
X						    && (!p->owner && p->condition != WASTED
X							&& p->condition == races[i - 1]->likesbest)) {
X							/*
X							 * explorations have
X							 * found an island
X							 */
X							Claims = i;
X							p->popn = races[i - 1]->number_sexes;
X							p->owner = i;
X							tot_captured = 1;
X						} else
X							explore(planet, p, x, y, i);
X					}
X					allexp |= o;	/* all sectors explored
X							 * for this player */
X				}
X		}
X	}
X	if (allexp)
X		planet->expltimer = 5;
X
X	/* environment nukes a random sector */
X	if (planet->conditions[TOXIC] > ENVIR_DAMAGE_TOX) {
X		nukex = int_rand(0, (int) planet->Maxx - 1);
X		nukey = int_rand(0, (int) planet->Maxy - 1);
X		p = &Sector(*planet, nukex, nukey);
X		p->condition = WASTED;
X		/* index into accident type array */
X		nukem = p->popn + p->troops ?
X			Accidents_inhab[int_rand(0, sizeof(Accidents_inhab) / sizeof(char *))]
X			: Accidents_uninhab[p->type * 2 + (random() &01)];
X		p->popn = p->owner = p->troops = 0;
X	}
X	for (i = 1; i <= Num_races; i++)
X		if (sects_gained[i - 1] || sects_lost[i - 1]) {
X			sprintf(telegram_buf, "****** Report: Planet /%s/%s ******\n",
X				Stars[starnum]->name, Stars[starnum]->pnames[planetnum]);
X			sprintf(buf, " WAR STATUS: %d sectors gained, %d sectors lost.\n",
X				sects_gained[i - 1], sects_lost[i - 1]);
X			strcat(telegram_buf, buf);
X			push_telegram(i, (int) Stars[starnum]->governor[i - 1], telegram_buf);
X		}
X	for (i = 1; i <= Num_races; i++) {
X		planet->info[i - 1].prod_crystals = prod_crystals[i - 1];
X		planet->info[i - 1].prod_res = prod_res[i - 1];
X		planet->info[i - 1].prod_fuel = prod_fuel[i - 1];
X		planet->info[i - 1].prod_dest = prod_destruct[i - 1];
X		if (planet->info[i - 1].autorep) {
X			planet->info[i - 1].autorep--;
X			sprintf(telegram_buf, "\nFrom /%s/%s\n",
X				Stars[starnum]->name, Stars[starnum]->pnames[planetnum]);
X
X			if (Stinfo[starnum][planetnum].temp_add) {
X				sprintf(buf, "Temp: %d to %d\n",
X					planet->conditions[RTEMP], planet->conditions[TEMP]);
X				strcat(telegram_buf, buf);
X			}
X			sprintf(buf, "Total      Prod: %dr %df %dd\n", prod_res[i - 1],
X				prod_fuel[i - 1], prod_destruct[i - 1]);
X			strcat(telegram_buf, buf);
X			if (prod_crystals[i - 1]) {
X				sprintf(buf, "    %d crystals found\n", prod_crystals[i - 1]);
X				strcat(telegram_buf, buf);
X			}
X			if (tot_captured) {
X				sprintf(buf, "%d sectors captured\n", tot_captured);
X				strcat(telegram_buf, buf);
X			}
X			if (Stars[starnum]->nova_stage) {
X				sprintf(buf, "This planet's primary is in a Stage %d nova.\n",
X					Stars[starnum]->nova_stage);
X				strcat(telegram_buf, buf);
X			}
X			/*
X			 * remind the player that he should clean up the
X			 * environment.
X			 */
X			if (planet->conditions[TOXIC] > ENVIR_DAMAGE_TOX) {
X				sprintf(buf, "Environmental damage on sector %d,%d\n",
X					nukex, nukey);
X				strcat(telegram_buf, buf);
X			}
X			if (planet->slaved_to) {
X				sprintf(buf, "ENSLAVED to player %d\n", planet->slaved_to);
X				strcat(telegram_buf, buf);
X			}
X			push_telegram(i, Stars[starnum]->governor[i - 1], telegram_buf);
X		}
X	}
X
X	/* find out who is on this planet, for nova notification */
X	if (Stars[starnum]->nova_stage == 1) {
X		sprintf(telegram_buf, "BULLETIN from /%s/%s\n",
X		   Stars[starnum]->name, Stars[starnum]->pnames[planetnum]);
X		sprintf(buf, "\nStar %s is undergoing nova.\n", Stars[starnum]->name);
X		strcat(telegram_buf, buf);
X		if (planet->type == TYPE_EARTH || planet->type == TYPE_WATER ||
X		    planet->type == TYPE_FOREST) {
X			strcat(buf, "Seas and rivers are boiling!\n");
X			strcat(telegram_buf, buf);
X		}
X		sprintf(buf, "This planet must be evacuated immediately!\n%c",
X			TELEG_DELIM);
X		strcat(telegram_buf, buf);
X		for (i = 1; i <= Num_races; i++)
X			if (planet->info[i - 1].numsectsowned)
X				push_telegram(i, Stars[starnum]->governor[i - 1], telegram_buf);
X	}
X	do_recover(planet, starnum, planetnum);
X
X	planet->popn = 0;
X	planet->troops = 0;
X	planet->maxpopn = 0;
X	planet->total_resources = 0;
X
X	for (i = 1; i <= Num_races; i++) {
X		planet->info[i - 1].numsectsowned = 0;
X		planet->info[i - 1].popn = 0;
X		planet->info[i - 1].troops = 0;
X	}
X
X	(void) Getxysect(planet, &x, &y, 1);
X	while (Getxysect(planet, &x, &y, 0)) {
X		p = &Sector(*planet, x, y);
X		if (p->owner) {
X			planet->info[p->owner - 1].numsectsowned++;
X			planet->info[p->owner - 1].troops += p->troops;
X			planet->info[p->owner - 1].popn += p->popn;
X			planet->popn += p->popn;
X			planet->troops += p->troops;
X			planet->maxpopn += maxsupport(races[p->owner - 1], p,
X			   Compat[p->owner - 1], planet->conditions[TOXIC]);
X			Power[p->owner - 1].troops += p->troops;
X			Power[p->owner - 1].popn += p->popn;
X			Power[p->owner - 1].sum_eff += p->eff;
X			Power[p->owner - 1].sum_mob += p->mobilization;
X			starpopns[starnum][p->owner - 1] += p->popn;
X		} else {
X			p->popn = 0;
X			p->troops = 0;
X		}
X		planet->total_resources += p->resource;
X	}
X
X	/* deal with enslaved planets */
X	if (planet->slaved_to) {
X		if (planet->info[planet->slaved_to - 1].popn > planet->popn / 1000) {
X			for (i = 1; i <= Num_races; i++)
X				/* add production to slave holder of planet */
X				if (planet->info[i - 1].numsectsowned) {
X					planet->info[planet->slaved_to - 1].resource += prod_res[i - 1];
X					prod_res[i - 1] = 0;
X					planet->info[planet->slaved_to - 1].fuel += prod_fuel[i - 1];
X					prod_fuel[i - 1] = 0;
X					planet->info[planet->slaved_to - 1].destruct += prod_destruct[i - 1];
X					prod_destruct[i - 1] = 0;
X				}
X		} else {
X			/* slave revolt! */
X			/* first nuke some random sectors from the revolt */
X			i = planet->popn / 1000 + 1;
X			while (--i) {
X				p = &Sector(*planet, int_rand(0, (int) planet->Maxx - 1),
X				       int_rand(0, (int) planet->Maxy - 1));
X				if (p->popn + p->troops) {
X					p->owner = p->popn = p->troops = 0;
X					p->condition = WASTED;
X				}
X			}
X			/* now nuke all sectors belonging to former master */
X			(void) Getxysect(planet, &x, &y, 1);
X			while (Getxysect(planet, &x, &y, 0)) {
X				if (Stinfo[starnum][planetnum].intimidated && random() & 01) {
X					p = &Sector(*planet, x, y);
X					if (p->owner == planet->slaved_to) {
X						p->owner = 0;
X						p->popn = 0;
X						p->troops = 0;
X						p->condition = WASTED;
X					}
X				}
X				/* also add up the populations while here */
X			}
X			sprintf(telegram_buf, "\nThere has been a SLAVE REVOLT on /%s/%s!\n",
X				Stars[starnum]->name, Stars[starnum]->pnames[planetnum]);
X			strcat(telegram_buf, buf);
X			sprintf(buf, "All population belonging to player #%d on the planet have been killed!\n", planet->slaved_to);
X			strcat(telegram_buf, buf);
X			strcat(buf, "Productions now go to their rightful owners.\n");
X			strcat(telegram_buf, buf);
X			for (i = 1; i <= Num_races; i++)
X				if (planet->info[i - 1].numsectsowned)
X					push_telegram(i,
X						      (int) Stars[starnum]->governor[i - 1], telegram_buf);
X			planet->slaved_to = 0;
X		}
X	}
X	/* add production to all people here */
X	for (i = 1; i <= Num_races; i++)
X		if (planet->info[i - 1].numsectsowned) {
X			planet->info[i - 1].fuel += prod_fuel[i - 1];
X			planet->info[i - 1].resource += prod_res[i - 1];
X			planet->info[i - 1].destruct += prod_destruct[i - 1];
X			planet->info[i - 1].crystals += prod_crystals[i - 1];
X
X			/* tax the population - set new tax rate when done */
X			if (races[i - 1]->Gov_ship) {
X				planet->info[i - 1].prod_money = round_rand(INCOME_FACTOR *
X									    (double) planet->info[i - 1].tax * (double) planet->info[i - 1].popn);
X				races[i - 1]->governor[Stars[starnum]->governor[i - 1]].money +=
X					planet->info[i - 1].prod_money;
X				planet->info[i - 1].tax += MIN((int) planet->info[i - 1].newtax
X					- (int) planet->info[i - 1].tax, 5);
X			} else
X				planet->info[i - 1].prod_money = 0;
X			races[i - 1]->governor[Stars[starnum]->governor[i - 1]].income +=
X				planet->info[i - 1].prod_money;
X
X			/* do tech investments */
X			if (races[i - 1]->Gov_ship) {
X				if (races[i - 1]->governor[Stars[starnum]->governor[i - 1]].money >=
X				    planet->info[i - 1].tech_invest) {
X					planet->info[i - 1].prod_tech =
X						tech_prod((int) (planet->info[i - 1].tech_invest),
X					  (int) (planet->info[i - 1].popn));
X					races[i - 1]->governor[Stars[starnum]->governor[i - 1]].money -=
X						planet->info[i - 1].tech_invest;
X					races[i - 1]->tech += planet->info[i - 1].prod_tech;
X					races[i - 1]->governor[Stars[starnum]->governor[i - 1]].cost_tech +=
X						planet->info[i - 1].tech_invest;
X				} else
X					planet->info[i - 1].prod_tech = 0;
X			} else
X				planet->info[i - 1].prod_tech = 0;
X
X			/* build wc's if it's been ordered */
X			if (planet->info[i - 1].tox_thresh > 0 &&
X			    planet->conditions[TOXIC] >= planet->info[i - 1].tox_thresh &&
X			    planet->info[i - 1].resource >= Shipcost(OTYPE_TOXWC, races[i - 1])) {
X				shiptype       *s2;
X				reg int         t;
X				++Num_ships;
X				ships = (shiptype **) realloc(ships,
X							      (unsigned) ((Num_ships + 1) * sizeof(shiptype *)));
X				s2 = ships[Num_ships] = Malloc(shiptype);
X				bzero((char *) s2, sizeof(shiptype));
X				s2->number = Num_ships;
X				s2->type = OTYPE_TOXWC;
X
X				s2->armor = Shipdata[OTYPE_TOXWC][ABIL_ARMOR];
X				s2->guns = NONE;
X				s2->primary = Shipdata[OTYPE_TOXWC][ABIL_GUNS];
X				s2->primtype = Shipdata[OTYPE_TOXWC][ABIL_PRIMARY];
X				s2->secondary = Shipdata[OTYPE_TOXWC][ABIL_GUNS];
X				s2->sectype = Shipdata[OTYPE_TOXWC][ABIL_SECONDARY];
X				s2->max_crew = Shipdata[OTYPE_TOXWC][ABIL_MAXCREW];
X				s2->max_resource = Shipdata[OTYPE_TOXWC][ABIL_CARGO];
X				s2->max_fuel = Shipdata[OTYPE_TOXWC][ABIL_FUELCAP];
X				s2->max_destruct = Shipdata[OTYPE_TOXWC][ABIL_DESTCAP];
X				s2->max_speed = Shipdata[OTYPE_TOXWC][ABIL_SPEED];
X				s2->build_cost = Shipcost(OTYPE_TOXWC, races[i - 1]);
X				s2->size = ship_size(s2);
X				s2->base_mass = 1.0;	/* a hack */
X				s2->mass = s2->base_mass;
X				s2->alive = 1;
X				s2->active = 1;
X				sprintf(s2->name, "Scum%04d", Num_ships);
X
X				insert_sh_plan(planet, s2);
X
X				s2->whatorbits = LEVEL_PLAN;
X				s2->storbits = starnum;
X				s2->pnumorbits = planetnum;
X				s2->docked = 1;
X				s2->xpos = Stars[starnum]->xpos + planet->xpos;
X				s2->ypos = Stars[starnum]->ypos + planet->ypos;
X				s2->land_x = int_rand(0, (int) planet->Maxx - 1);
X				s2->land_y = int_rand(0, (int) planet->Maxy - 1);
X				s2->whatdest = LEVEL_PLAN;
X				s2->deststar = starnum;
X				s2->destpnum = planetnum;
X				s2->owner = i;
X				s2->governor = Stars[starnum]->governor[i - 1];
X				t = MIN(TOXMAX, planet->conditions[TOXIC]);	/* amt of tox */
X				planet->conditions[TOXIC] -= t;
X				s2->special.waste.toxic = t;
X			}
X		}		/* (if numsectsowned[i]) */
X	if (planet->maxpopn > 0 && planet->conditions[TOXIC] < 100)
X		planet->conditions[TOXIC] += planet->popn / planet->maxpopn;
X
X	if (planet->conditions[TOXIC] > 100)
X		planet->conditions[TOXIC] = 100;
X	else if (planet->conditions[TOXIC] < 0)
X		planet->conditions[TOXIC] = 0;
X
X#ifdef THRESHLOADING
X  /* CWL Threshloading done here! */
X  shipno = planet->ships;
X  while (shipno) {
X    if (((ship = ships[shipno]) != NULL)
X	&& ship->alive && !ship->rad
X	&& (ship->whatdest == LEVEL_PLAN) && landed(ship)
X	&& (has_switch(ship) && ship->on || !has_switch(ship))) {
X      unsigned int             amti;
X
X      if (!ship->resource && ship->threshload[TH_RESOURCE]) {
X	if (ship->threshload[TH_RESOURCE] >
X	    planet->info[ship->owner - 1].resource)
X	  amti = planet->info[ship->owner - 1].resource;
X	else
X	  amti = ship->threshload[TH_RESOURCE];
X	planet->info[ship->owner - 1].resource -= amti;
X	ship->resource += amti;
X	/*
X	 * sprintf(buf, "%s: %c%d %s threshloaded %dr.",
X	 * prin_ship_orbits(ship), Shipltrs[ship->type], shipno, ship->name,
X	 * amti); push_message(TELEG_PLAYER_AUTO, 0, (int) ship->owner, (int)
X	 * ship->locked_to, buf, TELEGRAM);
X	 */
X      }
X      if (!ship->destruct && ship->threshload[TH_DESTRUCT]) {
X	if (ship->threshload[TH_DESTRUCT] >
X	    planet->info[ship->owner - 1].destruct)
X	  amti = planet->info[ship->owner - 1].destruct;
X	else
X	  amti = ship->threshload[TH_DESTRUCT];
X	planet->info[ship->owner - 1].destruct -= amti;
X	ship->destruct += amti;
X	/*
X	 * sprintf(buf, "%s: %c%d %s threshloaded %dd.",
X	 * prin_ship_orbits(ship), Shipltrs[ship->type], shipno, ship->name,
X	 * amti); push_message(TELEG_PLAYER_AUTO, 0, (int) ship->owner, (int)
X	 * ship->locked_to, buf, TELEGRAM);
X	 */
X      }
X      if (ship->fuel < 1.0 && ship->threshload[TH_FUEL]) {
X	ship->fuel = 0.0;
X	if (ship->threshload[TH_FUEL] >
X	    planet->info[ship->owner - 1].fuel)
X	  amti = (int) planet->info[ship->owner - 1].fuel;
X	else
X	  amti = ship->threshload[TH_FUEL];
X	planet->info[ship->owner - 1].fuel -= amti;
X	ship->fuel += (float) amti;
X	/*
X	 * sprintf(buf, "%s: %c%d %s threshloaded %df.",
X	 * prin_ship_orbits(ship), Shipltrs[ship->type], shipno, ship->name,
X	 * amti); push_message(TELEG_PLAYER_AUTO, 0, (int) ship->owner, (int)
X	 * ship->locked_to, buf, TELEGRAM);
X	 */
X      }
X      if (!ship->crystals && ship->threshload[TH_CRYSTALS]) {
X	if (ship->threshload[TH_CRYSTALS] >
X	    planet->info[ship->owner - 1].crystals)
X	  amti = planet->info[ship->owner - 1].crystals;
X	else
X	  amti = ship->threshload[TH_CRYSTALS];
X	planet->info[ship->owner - 1].crystals -= amti;
X	ship->crystals += amti;
X	/*
X	 * sprintf(buf, "%s: %c%d %s threshloaded %dx.",
X	 * prin_ship_orbits(ship), Shipltrs[ship->type], shipno, ship->name,
X	 * amti); push_message(TELEG_PLAYER_AUTO, 0, (int) ship->owner, (int)
X	 * ship->locked_to, buf, TELEGRAM);
X	 */
X      }
X    }				/* end threshloading */
X    shipno = ship->nextship;
X  }				/* end while shipno */
X  /* end threshloading */
X
X#endif
X
X	for (i = 1; i <= Num_races; i++) {
X		Power[i - 1].resource += planet->info[i - 1].resource;
X		Power[i - 1].destruct += planet->info[i - 1].destruct;
X		Power[i - 1].fuel += planet->info[i - 1].fuel;
X		Power[i - 1].sectors_owned += planet->info[i - 1].numsectsowned;
X		Power[i - 1].planets_owned += !!planet->info[i - 1].numsectsowned;
X		if (planet->info[i - 1].numsectsowned) {
X			/*
X			 * combat readiness naturally moves towards the avg
X			 * mobilization
X			 */
X			planet->info[i - 1].mob_points = avg_mob[i - 1];
X			avg_mob[i - 1] /= (int) planet->info[i - 1].numsectsowned;
X			planet->info[i - 1].comread = avg_mob[i - 1];
X		} else
X			planet->info[i - 1].comread = 0;
X		planet->info[i - 1].guns = planet_guns(planet->info[i - 1].mob_points);
X	}
X	return allmod;
X}
X
Xint 
Xmoveship_onplanet(shiptype * ship, planettype * planet)
X{
X	int             x, y, bounced = 0;
X
X	if (ship->class[ship->special.terraform.index] == 's') {
X		ship->on = 0;
X		return 0;
X	} else if (ship->class[ship->special.terraform.index] == 'c')
X		ship->special.terraform.index = 0;	/* reset the orders */
X
X	(void) get_move(ship->class[ship->special.terraform.index],
X			ship->land_x, ship->land_y, &x, &y, planet);
X	if (y >= planet->Maxy)
X		bounced = 1, y -= 2;	/* bounce off of south pole! */
X	else if (y < 0)
X		bounced = y = 1;/* bounce off of north pole! */
X	if (planet->Maxy == 1)
X		y = 0;
X	if (ship->class[ship->special.terraform.index + 1] != '\0') {
X		++ship->special.terraform.index;
X		if ((ship->class[ship->special.terraform.index + 1] == '\0') &&
X		    (!ship->notified)) {
X			char            teleg_buf[1000];
X			ship->notified = 1;
X			sprintf(teleg_buf, "%s is out of orders at %s.", Ship(ship),
X				prin_ship_orbits(ship));
X			push_telegram((int) (ship->owner),
X				      (int) ship->governor, teleg_buf);
X		}
X	} else if (bounced)
X		ship->class[ship->special.terraform.index] +=
X			((ship->class[ship->special.terraform.index] > '5') ? -6 : 6);
X	ship->land_x = x;
X	ship->land_y = y;
X	return 1;
X}
X
Xvoid 
Xterraform(shiptype * ship, planettype * planet)
X{
X	sectortype     *s;
X
X	/* move, and then terraform. */
X	if (!moveship_onplanet(ship, planet))
X		return;
X	s = &Sector(*planet, (int) ship->land_x, (int) ship->land_y);
X	if ((s->condition != races[ship->owner - 1]->likesbest) &&
X	    (s->condition != GAS) &&
X	success((100 - (int) ship->damage) * ship->popn / ship->max_crew)) {
X		/* gas sectors can't be terraformed. */
X		/* only condition can be terraformed, type doesn't change */
X		s->condition = races[ship->owner - 1]->likesbest;
X		s->eff = 0;
X		s->mobilization = 0;
X		s->popn = s->troops = 0;
X		s->owner = 0;
X		use_fuel(ship, FUEL_COST_TERRA);
X		if ((random() & 01) && (planet->conditions[TOXIC] < 100))
X			planet->conditions[TOXIC] += 1;
X		if ((ship->fuel < (double) FUEL_COST_TERRA) && (!ship->notified)) {
X			ship->notified = 1;
X			msg_OOF(ship);
X		}
X	} else if (s->condition == races[ship->owner - 1]->likesbest) {
X		sprintf(buf, " T%d is full of zealots!!!", ship->number);
X		push_telegram(ship->owner, ship->governor, buf);
X	}
X	if (s->condition == GAS) {
X		sprintf(buf, " T%d is trying to terraform gas.", ship->number);
X		push_telegram(ship->owner, ship->governor, buf);
X	}
X}
X
Xvoid 
Xplow(shiptype * ship, planettype * planet)
X{
X	sectortype     *s;
X
X	if (!moveship_onplanet(ship, planet))
X		return;
X	s = &Sector(*planet, (int) ship->land_x, (int) ship->land_y);
X	if ((races[ship->owner - 1]->likes[s->condition]) && (s->fert < 100)) {
X		int             adjust = round_rand(10 * (0.01 * (100.0 - (double) ship->damage)
X				   * (double) ship->popn) / ship->max_crew);
X		if ((ship->fuel < (double) FUEL_COST_PLOW) && (!ship->notified)) {
X			ship->notified = 1;
X			msg_OOF(ship);
X			return;
X		}
X		s->fert = MIN(100, s->fert + adjust);
X		if (s->fert >= 100) {
X			sprintf(buf, " K%d is full of zealots!!!", ship->number);
X			push_telegram(ship->owner, ship->governor, buf);
X		}
X		use_fuel(ship, FUEL_COST_PLOW);
X		if ((random() & 01) && (planet->conditions[TOXIC] < 100))
X			planet->conditions[TOXIC] += 1;
X	}
X}
X
Xvoid 
Xdo_dome(shiptype * ship, planettype * planet)
X{
X	sectortype     *s;
X	int             adjust;
X
X	s = &Sector(*planet, (int) ship->land_x, (int) ship->land_y);
X	if (s->eff >= 100) {
X		sprintf(buf, " Y%d is full of zealots!!!", ship->number);
X		push_telegram(ship->owner, ship->governor, buf);
X		return;
X	}
X	adjust = round_rand(.05 * (100. - (double) ship->damage)
X			    * (double) ship->popn / ship->max_crew);
X	s->eff += adjust;
X	if (s->eff > 100)
X		s->eff = 100;
X	use_resource(ship, RES_COST_DOME);
X#ifdef AUTOSCRAP
X	if (ship->autoscrap && s->eff == 100) {
X	/* Autoscrap this ship */
X		s->popn += ship->popn;
X		s->troops += ship->troops;
X		planet->popn += ship->popn;
X		planet->troops += ship->troops;
X		planet->info[ship->owner - 1].resource += ship->resource +
X			(int) (Cost(ship) / 2);
X		planet->info[ship->owner - 1].destruct += ship->destruct;
X		planet->info[ship->owner - 1].fuel += (int) ship->fuel;
X		planet->info[ship->owner - 1].crystals += ship->crystals;
X		sprintf(buf, "%s: Dome #%d autoscrapped.",
X			prin_ship_orbits(ship), ship->number);
X		push_telegram(ship->owner, ship->governor, buf);
X		kill_ship(ship->owner, ship);
X	}
X#endif 
X
X}
X
Xvoid 
Xdo_quarry(shiptype * ship, planettype * planet)
X{
X	sectortype     *s;
X	int             prod, tox;
X
X	s = &Sector(*planet, (int) (ship->land_x), (int) (ship->land_y));
X
X	if ((ship->fuel < (double) FUEL_COST_QUARRY)) {
X		if (!ship->notified)
X			msg_OOF(ship);
X		ship->notified = 1;
X		return;
X	}
X	/* nuke the sector */
X	s->condition = WASTED;
X	prod = round_rand(races[ship->owner - 1]->metabolism
X			  * (double) ship->popn / (double) ship->max_crew);
X	ship->fuel -= FUEL_COST_QUARRY;
X	prod_res[ship->owner - 1] += prod;
X	tox = int_rand(0, int_rand(0, prod));
X	planet->conditions[TOXIC] = MIN(100, planet->conditions[TOXIC] + tox);
X	if (s->fert >= prod)
X		s->fert -= prod;
X	else
X		s->fert = 0;
X}
X
Xvoid 
Xdo_recover(planettype * planet, int starnum, int planetnum)
X{
X	int             owners = 0, i, j;
X	int             ownerbits[2];
X	int             stolenres = 0, stolendes = 0, stolenfuel = 0, stolencrystals = 0;
X	int             all_buddies_here = 1;
X
X	ownerbits[0] = ownerbits[1] = 0;
X
X	for (i = 1; i <= Num_races && all_buddies_here; i++) {
X		if (planet->info[i - 1].numsectsowned > 0) {
X			owners++;
X			setbit(ownerbits, i);
X			for (j = 1; j < i && all_buddies_here; j++)
X				if (isset(ownerbits, j) && (!isset(races[i - 1]->allied, j) ||
X					   !isset(races[j - 1]->allied, i)))
X					all_buddies_here = 0;
X		} else {	/* Player i owns no sectors */
X			if (i != 1) {	/* Can't steal from God */
X				stolenres += planet->info[i - 1].resource;
X				stolendes += planet->info[i - 1].destruct;
X				stolenfuel += planet->info[i - 1].fuel;
X				stolencrystals += planet->info[i - 1].crystals;
X			}
X		}
X	}
X	if (all_buddies_here && owners != 0 && (stolenres > 0 ||
X		   stolendes > 0 || stolenfuel > 0 || stolencrystals > 0)) {
X		/* Okay, we've got some loot to divvy up */
X		int             shares = owners;
X		int             res, des, fuel, crystals;
X		int             givenres = 0, givendes = 0, givenfuel = 0,
X		                givencrystals = 0;
X
X		for (i = 1; i <= Num_races; i++)
X			if (isset(ownerbits, i)) {
X				sprintf(telegram_buf, "Recovery Report: Planet /%s/%s\n",
X					Stars[starnum]->name, Stars[starnum]->pnames[planetnum]);
X				push_telegram(i,
X				      (int) Stars[starnum]->governor[i - 1],
X					      telegram_buf);
X				sprintf(telegram_buf, "%-14.14s %5s %5s %5s %5s\n",
X					"", "res", "destr", "fuel", "xtal");
X				push_telegram(i,
X				      (int) Stars[starnum]->governor[i - 1],
X					      telegram_buf);
X			}
X		/* First: give the loot the the conquerers */
X		for (i = 1; i <= Num_races && owners > 1; i++)
X			if (isset(ownerbits, i)) {	/* We have a winnah! */
X				if ((res = round_rand((double) stolenres / shares))
X				    + givenres > stolenres)
X					res = stolenres - givenres;
X				if ((des = round_rand((double) stolendes / shares))
X				    + givendes > stolendes)
X					des = stolendes - givendes;
X				if ((fuel = round_rand((double) stolenfuel / shares))
X				    + givenfuel > stolenfuel)
X					fuel = stolenfuel - givenfuel;
X				if ((crystals = round_rand((double) stolencrystals / shares))
X				    + givencrystals > stolencrystals)
X					crystals = stolencrystals - givencrystals;
X				planet->info[i - 1].resource += res;
X				givenres += res;
X				planet->info[i - 1].destruct += des;
X				givendes += des;
X				planet->info[i - 1].fuel += fuel;
X				givenfuel += fuel;
X				planet->info[i - 1].crystals += crystals;
X				givencrystals += crystals;
X
X				owners--;
X				sprintf(telegram_buf, "%-14.14s %5d %5d %5d %5d",
X					races[i - 1]->name, res, des, fuel, crystals);
X				for (j = 1; j <= Num_races; j++)
X					if (isset(ownerbits, j))
X						push_telegram(j,
X							      (int) Stars[starnum]->governor[j - 1],
X							      telegram_buf);
X			}
X		/* Leftovers for last player */
X		for (; i <= Num_races; i++)
X			if (isset(ownerbits, i))
X				break;
X		if (i <= Num_races) {	/* It should be */
X			res = stolenres - givenres;
X			des = stolendes - givendes;
X			fuel = stolenfuel - givenfuel;
X			crystals = stolencrystals - givencrystals;
X
X			planet->info[i - 1].resource += res;
X			planet->info[i - 1].destruct += des;
X			planet->info[i - 1].fuel += fuel;
X			planet->info[i - 1].crystals += crystals;
X			sprintf(telegram_buf, "%-14.14s %5d %5d %5d %5d",
X			      races[i - 1]->name, res, des, fuel, crystals);
X			sprintf(buf, "%-14.14s %5d %5d %5d %5d\n", "Total:",
X			  stolenres, stolendes, stolenfuel, stolencrystals);
X			for (j = 1; j <= Num_races; j++)
X				if (isset(ownerbits, j)) {
X					push_telegram(j, (int) Stars[starnum]->governor[j - 1],
X						      telegram_buf);
X					push_telegram(j, (int) Stars[starnum]->governor[j - 1],
X						      buf);
X				}
X		} else
X			push_telegram(1, 0, "Bug in stealing resources\n");
X		/* Next: take all the loot away from the losers */
X		for (i = 2; i <= Num_races; i++)
X			if (!isset(ownerbits, i)) {
X				planet->info[i - 1].resource = 0;
X				planet->info[i - 1].destruct = 0;
X				planet->info[i - 1].fuel = 0;
X				planet->info[i - 1].crystals = 0;
X			}
X	}
X}
X
Xdouble 
Xest_production(sectortype * s)
X{
X
X	/* Mod by SKF -- added by JPD */
X
X	double est_sec_prod;
X
X	est_sec_prod = races[s->owner-1]->metabolism*(double)s->eff*
X				(double)s->eff/200.0;
X
X	if (est_sec_prod > s->resource)
X			return ((double)s->resource);
X
X	return(est_sec_prod);
X}
END_OF_FILE
if test 33331 -ne `wc -c <'server/doplanet.c'`; then
    echo shar: \"'server/doplanet.c'\" unpacked with wrong size!
fi
# end of 'server/doplanet.c'
fi
echo shar: End of archive 7 \(of 21\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
