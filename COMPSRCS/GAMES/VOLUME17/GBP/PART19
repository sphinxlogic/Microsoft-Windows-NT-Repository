Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i031:  gbp - Galactic Bloodshed+, an empire-like war game, Part19/21
Message-ID: <4559@master.CNA.TEK.COM>
Date: 12 Feb 93 17:33:29 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2304
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1710

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 31
Archive-name: gbp/Part19
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 19 (of 21)."
# Contents:  doc/CHANGES doc/README_OLD doc/races.doc hdrs/races.h
#   misc/planet.list server/Makefile.SH server/dosector.c
#   user/dissolve.c user/enslave.c user/togg.c
# Wrapped by billr@saab on Fri Feb 12 09:14:30 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/CHANGES'\"
else
echo shar: Extracting \"'doc/CHANGES'\" \(4529 characters\)
sed "s/^X//" >'doc/CHANGES' <<'END_OF_FILE'
X
X	This file denotes changes that was made between this release
Xof Galactic bloodshed and GB5.2.
X
X
X	Version 1.1.0
X	-------------
X
X	loginfo function --  All information that was written to stdout
X	before is now written to one of 2 log files.  There are currently
X	3 log files.  
X
X		user.log 
X		error.log
X		update.log
X
X	GB_server.c  -- Alot of function were removed from ths file and put
X    in other files.  
X
X	psmap.c -- is now included in the utils directory.
X
X	togg.c vict.c zoom.c sche.c toxi.c tele.c tech.c -- These files were
X	just cleaned up, and comments were added.  Eventually all the files
X	will be in this format.
X
X	prof.c -- Fixed some formatting bugs in profile.
X
X	analysis.c -- Fixed some formatting bugs in analysis.
X
X	shootblast.c -- Fixed divide by zero error in do_critical_hits().
X
X	order.c build.c doplanet.c ships.h vars.h -- Added ifdefs for 
X    treshload/autoscrap code.
X
X	shipdata.h -- added a dock field to the file, which shows if the ship
X	can be loaded into hangers.  (ie: fixes floating ground telescope bug)
X
X	land.c -- Fixed bug that allowed ground telescopes to be launched from
X	a ship at universe/star/planet level.  Any ship with max-speed of 0 cannot
X	be loaded into a ship.
X
X	Version 1.1.1
X	-------------
X
X	shipdata.h ship.h -- added minesweeper shiptype
X
X	shipdata.h tweakables.h config.h -- added ifdef for SUPER_PODS
X	
X	cs.c -- added Shawn Fox's fix to cs to planets via cs ../2 cs ../1
X	instead of using names.
X
X	doplanet.c -- added Shawn Fox's est_production fix...
X
X
X	Version 1.1.2
X	-------------
X
X	Keesh's change to survey.c and tele.c to comply with GBII ver 2.4.6
X
X	Version 1.1.3
X	-------------
X
XTues Jan 26 08:01:00 EST 1993 johnd
X
X	Added the CLIENT_PROTOCOL Support file to the release
X
X	shlmisc.c - grant now works correctly (fixed bug, that prevents subtraction
X	of money from governors)
X
XWed Jan 27 20:07:56 EST 1993 johnd
X
X	shipdata.h - changed space telescope letter from \ to E and missle from
X	^ to z
X		
XThu Jan 28 03:49:02 EST 1993 johnd
X
X	GB_server.c	- Added governor logout message.
X		
X	GB_server.c - Added server generated password prompt for client.
X
X	dock.c - Fixed bug in dock(), s->whatorbits should be s2->whatorbits
X
X	rst.c order.c - made mod to the way xtals/hyperdrives are show.
X	is ship doesnt have hyper * is shown, hyper/no xtal - is shown,
X	hyper/xtal + is shown.
X
X	name.c chan.c GB_server.c vars.h prof.c Configure - Added multiple
X	communications channel capability. Channels are numbered 1,2,3. Can
X	send on any channel by using the number of the channel you wish to
X	send on.  Set the default channel (for use with broadcast and ') via
X	'channel <channel> default', view current channels with 'channel', set
X	channels to monitor via 'channel <channel> (toggle).  You will only
X	receive messages for channels you have turned on. (By default channel
X	one is set upon login)
X
X
XThu Jan 28 21:38:28 EST 1993 johnd
X	
X	all Makefile.SH -- Added clean targets
X
X	GB_server.c sche.c -- changed long to time_t for clock defs.
X
X	many .c's -- changed sprintf to strcat whereever possible
X
X	vars.h -- removed clk, added to GB_server.c and sche.c
X
X	tele.c -- removed ctime and fopen defs (included in time.h and stdlib.h)
X
X	GB_server.c -- added #include sys/stat.h
X
X	all *.c's -- removed #include "*.p" and moved all prototypes to
X	hdrs/proto.h
X
X
XSat Jan 30 20:28:58 EST 1993 johnd
X
X	lists.c -- Changes [MAXSTARS] and [MAXPLANETS] to [MAXSTARS -1] and
X	[MAXPLANETS -1].
X
X	max.c -- compatibility() changed add from int to double.  
X
X	build.c -- get_build_type() removed line to init i to -1, chaned order
X	of comparisions to check for (i < NUMSTYPES) first.
X
X	fuel.c -- was assigning information from a struct that was free'ed,
X	
X
X	-- END OF GB+ 1.1.4
X
XMon Feb  1 00:26:07 EST 1993
X
X	-- START OF GB+ 1.2.0	
X
X	This version is the start serious development work, many changes started
X	including closer interaction between client and server.
X
X	client.c -- added client.c to handle all client specific parsing and
X	commands.
X
X	csp.h -- added csp.h.  This file should be the same in the client as
X	well as the server.
X
X	toggle.c -- added new 'toggle client' option to use client result codes.
X
X	vars.h -- added #defs for UPDATE_START, UPDATE_END, SEGMENT_START,
X	SEGMENT_END, RESET_START, RESET_END.
X
X	GB_server.c -- added CSP_process_command into process_command function.
X	** All client commands should be added to CSP_process_command.c, not in 
X	process_command.
X
X	doship.c -- fixed bug in domine() that prevented mines from shooting
X	enemy ships.
X	
X	-- END OF GB+ 1.2.0
END_OF_FILE
if test 4529 -ne `wc -c <'doc/CHANGES'`; then
    echo shar: \"'doc/CHANGES'\" unpacked with wrong size!
fi
# end of 'doc/CHANGES'
fi
if test -f 'doc/README_OLD' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/README_OLD'\"
else
echo shar: Extracting \"'doc/README_OLD'\" \(2902 characters\)
sed "s/^X//" >'doc/README_OLD' <<'END_OF_FILE'
X   The code is divided into two parts, GB_server.shar which contains
Xthis file, and GB_client.shar. Most of the user playing the game will
Xjust need the client, since the server is run at the game site and
Xmanaged by the host there. Game documentation is in the file
XGB_docs.shar.
X
X   If you wish to host a GB game, you must have GB_server.shar, GB_docs
Xand GB_client.shar. After unsharing these files (they should be done in
Xseparate directories!), you can compile and link them by doing
X'make'. The Makefile is set up for 4.3 BSD Unix, if you are running
Xon a different operating system, you may need to change the Makefile
Xto suit your system.
X
X   Assuming all goes well, you should have several programs in the
Xserver's directory, and one program in the client's directory (GB_client).
XIn the server's directory:
X	GB_enroll
X	GB_server
X	makeuniv
X
X   This version of the server has the update clock built into the server.
XWhen starting up the server, use the following syntax:
X  GB_server [port] [minutes between updates] [movement segments per update] &
XFor example:
X	GB_server 2010 720 6 &
Xwill run the server using port 2010, 720 minutes (6 hrs) between updates, and
X6 evenly spaced movement segments (note that an update is counted as a
Xmovement segment). The program also supports the update password and
Xsegment password as used in earlier version of the program. I would like
Xto thank Dan Dickey at Cray for his help in putting the framework for this
Xtogether. It is a  good idea to make your update times a factor 
Xof 24 hours and the movement segment interval a factor of the update interval.
XIf you want to force an update/segment just telnet to the server 
Xand enter the update/segment password.
X
XUpdates and segments can be forced by the deity by using the '@@update'
Xand '@@segment' commands. A 'fix' routine has also been installed for the
Xdeity player, but still needs some work (you can customize it in shlmisc.c).
X
XPlayers cannot enroll by themselves in this version. The game's host
Xmust do that by running 'GB_enroll' and following the instructions. It
Xis a good idea to bring the game down for this (log in as a God status
Xplayer and do '@@shutdown'). Always make player #1 (the first one
Xenrolled God status, as many game functions default to player 1).
X
XTime allocation cas be set using the 'reset' command.
X
XBefore starting a game you must create a universe for your users to play in.
XDo 'makeuniv' and follow the instructions.
X
XAlso, be careful about setting up your default paths correctly. Unshare the
XGB_docs.shar file into a subdirectory 'Docs'.
X
X
XThere have been ajor improvements in the game and server stability since
Xthis readme file was last updated, much too numerous to expound upon. However,
XI am always open for suggestions, and take a look at the program yourself
Xto help me find errors :)
X
XGood luck,
X
XGarrett Warren van Cleef
Xvancleef@pooh.caltech.edu
X7/19/91
END_OF_FILE
if test 2902 -ne `wc -c <'doc/README_OLD'`; then
    echo shar: \"'doc/README_OLD'\" unpacked with wrong size!
fi
# end of 'doc/README_OLD'
fi
if test -f 'doc/races.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/races.doc'\"
else
echo shar: Extracting \"'doc/races.doc'\" \(5823 characters\)
sed "s/^X//" >'doc/races.doc' <<'END_OF_FILE'
XRACES			Galactic Bloodshed		RACES
X
X
XCONCEPTS
X
X   The creation of new races is controlled by the person hosting the game.
XPlayer #1 (the first player enrolled into the game) should always be given
Xdiety status, as many of the game default operations are placed in player #1's
Xcontrol.  Other players may be designated as having diety status during the
Xenrollment procedure, but this isn't recommended (or needed in most cases).
X
X   Race generation is often done using a rather complex point based system,
Xthe idea being that you must spend a limited number points to get better
Xattributes.  The program that you do this creation process with is called
X"racegen".  There are five types of data associated with each race that the
Xplayer can choose:
X
X* Name, password, and other profile information -- While none of these have
Xany direct effect on game play, they add interest.  Name and password can be
Xset with racegen before enrolling in the game.  All of the others can be
Xchanged as needed; see also: name, personal, profile
X
X* Home planet type -- A race's home planet can drastically affect its game.
XJovian home planets are the most costly type, because jovians are huge planets
Xwith about half the sector area of the universe on them.  Jovians are the only
Xworlds with gas sectors on them; gas tends to be resource-poor but fertile.
XClass M (Earth-type) home planets are the next most useful, with a good
Xbalance of fertility and resources.  Forest and water worlds are like class
XM's and generally more fertile, but they are also smaller on average.  Desert
Xworlds have high resource content but are not very fertile.  Iceballs and
Xairless worlds are too small to make very good home planets, but they are very
Xcommon in the universe as a whole.
X
X* Racial type -- There are two main racial types in GB: normal races (think of
Xhumans, Klingons, Wookies, Pierson's Puppeteers, etc) and metamorphs (Alien,
Xthe Thing, body snatchers, etc.)  The primary difference between these two
Xrace classes is that only metamorphs may have pods and absorbtion as racial
Xattributes.  Metamorphs are also required to have one sex, which is another
Xadvantage.  A secondary difference that is rather harder to notice is that the
Xprice of various attribute combinations is slightly different for normals and
Xmorphs in racegen, especially for some of the attributes' extremes.
X
X* Compats -- The planets found in the GB universe are represented as arrays of
Xsectors of various types: ice, land, sea, etc.  Various races may have varying
Xdegrees of compatibility with these sector types, which will affect the amount
Xof population they can grow on that sector type, and other things too.
X
X* Attributes -- Attributes are quantizations of a race's abilities.  Currently
Xthere are 11 basic attributes for each race:
X
X** Absorbtion -- Only metamorphs may have this attribute, which allows them to
X	absorb enemy troops and civilians in combat if the morph wins.
X	Combined with pods, it allows metamorphs to replace alien population
X	on planets when pods burst.
X
X** Adventurism -- This described what percentage of a sector's population may
X	move and explore other sectors.  High value tend to settle planets on
X	their own far more efficiently. If you have a low value, you can order
X	movements with the 'move' option.
X
X** Birthrate -- This factor determines how rapidly the population in the
X	sector will converge to the maximum population supportable on the
X	there.  High values mean that the population multiplies faster.
X
X** Fertilize -- This attribute represents the percentage chance that a race
X	will increase by one percent the fertility of any sector it owns.  Any
X	race may take advantage of space plows for a similar effect, once it
X	gets to tech level 5.
X
X** Fighting Ability - Higher values mean that the race is more likely to kill
X	an alien than a lower value.  Races with lower values will usually need
X	to have larger forces to win in direct combat over a high fighting
X	ability.  It is important to note that this effects only land combat
X	and ship boarding strengths, and not ship to ship fighting.
X
X** IQ -- The raw growth rate of a race's technology is governed by the race's
X	intelligence.  The technology increase per update is IQ/100.  Addi-
X	tional technology gain is available by technology investments on the
X	individual planets under the race's control.
X
X** Collective IQ; IQ limit -- The intelligence of a race with collective IQ is
X	related to the race's total population, as follows:
X		IQ = IQ_limit * [ (2/PI) atan(population/50000)]^2. 
X
X** Mass -- Each race has a mass.  The heavier the individual, the more fuel it
X	will take to launch and land ships full of the race.
X
X** Metabolism -- This value controls how industrious the race is.  Higher
X	metabolism races will produce resources more rapidly than lower
X	metabolisms, and also increase the efficiency of sectors faster.
X
X** Pods -- Pods are small ships, available only to metamorphs but at tech
X	level 0, buildable instantly on the surface of planets.  Each one may
X	carry a single crew-thing; this makes them ideal for settling other 
X	planets.  Pods which enter a system after having frozen in deep
X	space will warm and eventually burst, possibly leading to spores
X	landing on worlds in the new system.  If a spore lands on a sector, a
X	ton or more of biomass will be created, resulting in a new colony for
X	the podding race.  Note that spores may never land on alien occupied
X	sectors unless the podding race has absorbtion.
X
X** Sexes -- Each race has a number of sexes. This represent the minimum
X	population that a sector must have in order to be able to reproduce.
X	Lower values are preferable to high values for colonization efforts.
X	It is not recommended to have more than 3 to 6 sexes at the outside,
X	unless you are really looking for a challenge
END_OF_FILE
if test 5823 -ne `wc -c <'doc/races.doc'`; then
    echo shar: \"'doc/races.doc'\" unpacked with wrong size!
fi
# end of 'doc/races.doc'
fi
if test -f 'hdrs/races.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdrs/races.h'\"
else
echo shar: Extracting \"'hdrs/races.h'\" \(5887 characters\)
sed "s/^X//" >'hdrs/races.h' <<'END_OF_FILE'
X#ident  "@(#)races.h	1.3 1/28/93 "
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, 
X * smq@ucscb.ucsc.edu, mods by people in GB.c, enroll.dat.
X * Restrictions in GB.c.
X */
X
Xtypedef struct {
X    char invisible;
X    char standby;
X    char color;	        /* 1 if you are using a color client */
X    char gag;
X    char double_digits;
X    char inverse;
X    char geography;
X    char autoload;
X    char highlight;	        /* which race to highlight */
X    char compat;
X} toggletype;
X
Xstruct race {
X    int Playernum;
X    char name[RNAMESIZE];       /* Racial name. */
X    char password[RNAMESIZE];
X    char info[PERSONALSIZE];	/* personal information */
X    char motto[MOTTOSIZE];	/* for a cute message */
X    unsigned char absorb;       /* Does this race absorb enemies in combat? */
X    unsigned char collective_iq;/* Does this race have collective IQ? */
X    unsigned char pods;         /* Can this race use pods? */
X    unsigned char fighters;     /* Fight rating of this race. */
X    unsigned char IQ;           
X    unsigned char IQ_limit;     /* Asymtotic IQ for collective IQ races. */
X    unsigned char number_sexes;
X    unsigned char fertilize;    /* Chance that this race will increase the
X				   fertility of its sectors by 1 each update */
X    double adventurism;          
X    double birthrate;
X    double mass;
X    double metabolism;
X    short conditions[OTHER+1];	/* Atmosphere/temperature this race likes. */
X    double likes[WASTED+1];	/* Sector condition compats. */
X    unsigned char likesbest;    /* 100% compat sector condition for this race. */
X    
X    char dissolved;          /* Player has quit. */
X    char God;                /* Player is a God race. */
X    char Guest;              /* Player is a guest race. */
X    char Metamorph;          /* Player is a morph; (for printing). */
X    char monitor;            /* God is monitering this race. */
X
X    char translate[MAXPLAYERS];  /* translation mod for each player */
X
X    unsigned long atwar[2];	/* war 64 bits*/
X    unsigned long allied[2];	/* allies 64 bits*/
X
X    unsigned short Gov_ship;    /* Shipnumber of government ship. */
X    long morale;                 /* race's morale level */
X    unsigned int points[MAXPLAYERS]; /* keep track of war status against
X				        another player - for short reports */
X    unsigned short controlled_planets;   /* Number of planets under control. */
X    unsigned short victory_turns;
X    unsigned short turn;
X
X    double tech;                 
X    unsigned char discoveries[80];    /* Tech discoveries. */
X    unsigned long victory_score;      /* Number of victory points. */
X    unsigned long votes;
X    unsigned long planet_points;      /* For the determination of global APs */
X    
X    char governors;
X    struct gov {
X	char name[RNAMESIZE];
X	char password[RNAMESIZE];
X	unsigned char active;
X	unsigned char deflevel;
X	unsigned char defsystem;
X	unsigned char defplanetnum;	/* current default */
X	unsigned char homelevel;
X	unsigned char homesystem;
X	unsigned char homeplanetnum;	/* home place */
X	unsigned long newspos[4];	/* news file pointers */
X	toggletype toggle;
X	unsigned long money;
X	unsigned long income;
X	unsigned long maintain;
X	unsigned long cost_tech;
X	unsigned long cost_market;
X	unsigned long profit_market;
X	unsigned long channel[2];  /* the channel we are communicating on */
X	long login;	 /* last login for this governor */
X	struct {
X	unsigned csp_user : 1;
X	unsigned empty : 7;
X	} CSP_client_info;
X
X    } governor[MAXGOVERNORS+1];
X};
X
X/* vote bits: */
X#define	VOTE_UPDATE_GO	0x01	/* On - Go, Off - Wait */
X
X/* special discoveries */
X#define D_HYPER_DRIVE	  0 /* hyper-space capable */
X#define D_LASER		  1 /* can construct/operate combat lasers */
X#define D_CEW		  2 /* can construct/operate cews */
X#define D_TRACTOR_BEAM    4 /* tractor/repulsor beam */
X#define D_TRANSPORTER     5 /* tractor beam (local) */
X#define D_AVPM	          6 /* AVPM transporter */
X#define D_CLOAK	          7 /* cloaking device */
X#define D_WORMHOLE        8 /* worm-hole */
X#define D_CRYSTAL	  9 /* crystal power */
X
X#define Hyper_drive(r) 	((r)->discoveries[D_HYPER_DRIVE])
X#define Laser(r)	((r)->discoveries[D_LASER])
X#define Cew(r)		((r)->discoveries[D_CEW])
X#define Tractor_beam(r)	((r)->discoveries[D_TRACTOR_BEAM])
X#define Transporter(r)	((r)->discoveries[D_TRANSPORTER])
X#define Avpm(r)		((r)->discoveries[D_AVPM])
X#define Cloak(r)	((r)->discoveries[D_CLOAK])
X#define Wormhole(r)	((r)->discoveries[D_WORMHOLE])
X#define Crystal(r)	((r)->discoveries[D_CRYSTAL])
X
X#define TECH_HYPER_DRIVE	50.0
X#define TECH_LASER	       100.0
X#define TECH_CEW	       150.0
X#define TECH_TRACTOR_BEAM      999.0
X#define TECH_TRANSPORTER       999.0
X#define TECH_AVPM	       250.0
X#define TECH_CLOAK	       999.0
X#define TECH_WORMHOLE	       999.0
X#define TECH_CRYSTAL		50.0
X
Xstruct block {
X    int Playernum;
X    char name[RNAMESIZE];
X    char motto[MOTTOSIZE];
X    unsigned long invite[2];
X    unsigned long pledge[2];
X    unsigned long atwar[2];
X    unsigned long allied[2];
X    unsigned short next;
X    unsigned short systems_owned;
X    unsigned long VPs;
X    unsigned long money;
X
X    unsigned long dummy[2];
X};
X
Xstruct power_blocks {
X	char time[128];
X	unsigned long members[MAXPLAYERS];
X	unsigned long troops[MAXPLAYERS];	/* total troops */
X	unsigned long popn[MAXPLAYERS];	/* total population */
X	unsigned long resource[MAXPLAYERS];	/* total resource in stock */
X	unsigned long fuel[MAXPLAYERS];
X	unsigned long destruct[MAXPLAYERS];	/* total dest in stock */
X	unsigned short ships_owned[MAXPLAYERS];	/* # of ships owned */
X	unsigned short systems_owned[MAXPLAYERS];
X	unsigned long sectors_owned[MAXPLAYERS];
X	unsigned long money[MAXPLAYERS];
X	unsigned short VPs[MAXPLAYERS];
X};
X
Xtypedef struct race racetype;
Xtypedef struct block blocktype;
XEXTERN struct block Blocks[MAXPLAYERS];
XEXTERN struct power_blocks Power_blocks;
X
XEXTERN racetype *races[MAXPLAYERS];
END_OF_FILE
if test 5887 -ne `wc -c <'hdrs/races.h'`; then
    echo shar: \"'hdrs/races.h'\" unpacked with wrong size!
fi
# end of 'hdrs/races.h'
fi
if test -f 'misc/planet.list' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/planet.list'\"
else
echo shar: Extracting \"'misc/planet.list'\" \(5494 characters\)
sed "s/^X//" >'misc/planet.list' <<'END_OF_FILE'
XAasarus
XAberius
XAbyssinia
XAceldama
XAchates
XAcheron
XAchilles
XAcropolis
XAcrisis
XAdam
XAdrastea
XAdreaticus
XAeetes
XAegea
XAegir
XAeneas
XAeolus
XAesir
XAesop
XAether
XAgamemnon
XAgnar
XAgni
XAiakos
XAjax
XAkroteri
XAlbion
XAlcmene
XAlexander
XAlfheim
XAmalthea
XAmaterasu
XAmericos
XAmphion
XAnacreon
XAnchises
XAngakok
XAngurboda
XAnsu
XAntaeus
XAntigone
XAnubis
XApache
XApaosha
XAphrodite
XApsyrtus
XAragorn
XArapaho
XArgos
XArgus
XAriadne
XArion
XArmageddon
XAsgard
XAshur
XAstarte
XAthens
XAtlantis
XAtlas
XAtropos
XAttica
XAudhumla
XAvalon
XAzazel
XAziDahak
XAzores
XBaal
XBabylon
XBacchus
XBaezelbub
XBagdemagus
XBalder
XBakongo
XBali
XBan
XBaugi
XBedivere
XBelial
XBellerophon
XBellona
XBenkei
XBergelmir
XBernoulli
XBerserks
XBianca
XBifrost
XBohr
XBoeotia
XBohort
XBora
XBors
XBoz
XBragi
XBrave
XBrisingamen
XBritannia
XBuri
XBushido
XCadiz
XCaeser
XCain
XCamelot
XCamlan
XCanan
XCarbonek
XCarme
XCarthage
XCelaeno
XCelephais
XCeleus
XCelt
XCerberus
XCetelus
XCeto
XCh'eng-huang
XChansky
XChaos
XCharon
XCharybdis
XCheiron
XCherubim
XChi'ih-yu
XChimera
XChiron
XChow
XChuai
XCirrus
XClaire
XCleito
XClotho
XClytemnestra
XCocytus
XColchis
XConiraya
XCordelia
XCorinth
XCoriolis
XCranus
XCrassus
XCressida
XCronus
XCyclops
XCyzicus
XDaedalus
XDagon
XDamon
XDanae
XDanaus
XDannaura
XDanube
XDardanus
XDarkalheim
XDarwin
XDawn
XDeganus
XDeimus
XDelphi
XDemeter
XDemise
XDepth
XDescartes
XDesdemona
XDesire
XDesolation
XDespoina
XDeucalion
XDevadatta
XDharma
XDiana
XDinka
XDiogenes
XDis
XDjanggawul
XDorian
XDorus
XDoula
XDove
XDragon
XDraupnir
XDrak
XDream
XDruj
XDwarka
XDyaus
XEarth
XEcho
XEctoprimax
XEctor
XEddas
XEdjo
XEegos
XEhecatl
XEinstein
XElara
XEldorado
XElectra
XEleusis
XEllindil
XElysia
XEnceladus
XEndoprimax
XEnkindu
XEnlil
XEphialtes
XEphraites
XEpigoni
XEpimetheus
XErebus
XErech
XErgos
XErishkegal
XEros
XEstanatleh
XEteocles
XEurasia
XEuripedes
XEuropa
XEurydice
XEurytion
XExcalibur
XExodus
XFalcha
XFebrus
XFeiLien
XFenrir
XFonLegba
XFourthWorld
XFreedom
XFreuchen
XFreyr
XFrigg
XFrisia
XForseti
XFu-hsi
XFujin
XFuture
XGabora
XGades
XGadir
XGaea
XGalactica
XGalahad
XGalanopoulus
XGalileo
XGandalf
XGanymede
XGarm
XGaokerena
XGathas
XGawain
XGeirrod
XGerda
XGermania
XGeryon
XGhal
XGil-galad
XGilgamesh
XGimli
XGinnungagap
XGjallarhorn
XGlispa
XGondor
XGorgias
XGorgon
XGorlois
XGosadaya
XGraeae
XGranis
XGrunbunde
XGuinevere
XHadad
XHalloway
XHalvec
XHaoma
XHarpie
XHaroeris
XHathor
XHeaven
XHebe
XHecate
XHegel
XHei-tiki
XHeidrun
XHeidegger
XHeimdall
XHeisenburg
XHel
XHelene
XHell
XHelle
XHeracles
XHermod
XHesoid
XHestia
XHimalia
XHodur
XHoeinir
XHomer
XHope
XHotei
XHringhorni
XHugi
XHuron
XHyksos
XHyperion
XIacchos
XIapetus
XIbanis
XIcarus
XIdun
XIlliam
XIllyria
XImperium
XInfinity
XIo
XIolcus
XIoue
XIrkalla
XIsmene
XIulus
XIxbalanque
XIxmirsis
XJackal
XJamsid
XJataka
XJazdarnil
XJena
XJotars
XJotunheim
XJuliet
XJung
XJurojin
XK'unLun
XKachinas
XKadath
XKalki
XKamakura
XKant
XKaraja
XKarnak
XKay
XKepa
XKeshvar
XKettoi
XKhepri
XKhwanirath
XKierkegaard
XKirin
XKishijoten
XKoffler
XKol
XKunmanggur
XKuya-Shonin
XKythamil
XLabyrinth
XLachesis
XLaindjung
XLaius
XLancelot
XLao-tze
XLapiths
XLares
XLarissa
XLarnok
XLeda
XLeibniz
XLeinster
XLemnos
XLeng
XLeodegrance
XLethe
XLeto
XLeviathan
XLhard
XLodbrok
XLodur
XLogan
XLogi
XLoki
XLot
XLotan
XLove
XLugundum
XLungshan
XLuntag
XLuyia
XLycurgus
XLysithea
XMacha
XMador
XMaenads
XMagna
XMandara
XManitou
XMarduk
XMarmora
XMars
XMashyane
XMedea
XMedusa
XMeepzorp
XMegara
XMeneleus
XMenrua
XMercury
XMerlin
XMetis
XMidas
XMidgard
XMimas
XMimir
XMinoa
XMinos
XMiranda
XMiriam
XMirkwood
XMithrandir
XMjolnir
XModred
XMoirai
XMontaigne
XMorrigan
XMulungu
XMunin
XMuspellheim
XNada
XNagilfar
XNaiad
XNanna
XNarcissus
XNardis
XNebo
XNelligan
XNeptune
XNereid
XNietszche
XNight
XNinhursag
XNinigi
XNirvana
XNjord
XNorn
XNu-ku
XNuba
XNuptadi
XNyambe
XNyarlathotep
XNymph
XOberon
XObolus
XOceana
XOd
XOdin
XOdysseus
XOedipus
XOeneus
XOhrmazd
XOjin
XOkesa
XOkokanoffee
XOkuninushi
XOlifat
XOliphant
XOlympus
XOphelia
XOrchomenus
XOrd
XOrestes
XOrpheus
XOro
XOrthoprimax
XOrunila
XOsirus
XOtus
XOvid
XOz
XP'an-Ku
XPachacutil
XPan
XPandora
XParshya
XParvati
XPasiphae
XPatala
XPatrise
XPelias
XPellas
XPellinore
XPeloponnesus
XPek
XPercivale
XPersphone
XPhegethon
XPhineas
XPhobos
XPhoebe
XPhoenix
XPhorcys
XPhrixus
XPhyrro
XPiithar
XPindar
XPinel
XPifall
XPlanck
XPlato
XPluto
XPolybus
XPolydectes
XPolyneices
XPoseiden
XPriam
XPrimax
XPrithivi
XPrometheus
XProetus
XPthura
XPtolemy
XPuck
XPymeria
XPyrgos-Dirou
XPyrrha
XPythia
XQaQwaai
XQuagKeep
XQuetzalcoatl
XQuimbaya
XQuirnok
XR'lyeh
XRadha
XRagnarok
XRashnu
XRata
XReggae
XRegia
XRegulus
XResida
XRhadamanthys
XRhea
XRhpisort
XRimahad
XRol
XRosalind
XRousseau
XRudra
XRuhe
XRukmini
XRunes
XRustam
XRyobu
XSagurak
XSakra
XSalacia
XSappedon
XSardonis
XSarnak
XSatan
XSati
XSaturn
XSauron
XScearce
XSchopenhaur
XScylla
XSecundus
XSedaria
XSedna
XSega
XSekasis
XSemele
XSeneca
XSeriphos
XSha-Lana
XShaman
XShantak
XShapash
XShax
XShen
XSiddhartha
XSif
XSig
XSigyn
XSinope
XSirens
XSkidbladnir
XSkirnir
XSkrymir
XSkuld
XSleipner
XSocrates
XSolaria
XSphinx
XSpinner
XSpinoza
XSrishok
XStyx
XSuboceana
XSuga
XSugriva
XSurt
XSurya
XSwarga
XSymplegades
XSyrinx
XT'aishan
XTacitus
XTadanobu
XTantrus
XTare
XTarnesus
XTartarus
XTaweskare
XTekeli-li
XTelesto
XTerminus
XTerra
XTethys
XThalassa
XThebes
XThemis
XThera
XTheseus
XThinis
XThjalfi
XThjazi
XThor
XThought
XThrace
XThrasymachus
XTi'i
XTigra-nog'th
XTiki
XTillich
XTimaeus
XTime
XTirawa-Atius
XTitan
XTiu
XTjinimin
XTou-Mu
XTrantor
XTrashtri
XTrisala
XTriton
XTroll
XTroy
XTsathoggua
XTsentsa
XTyphon
XTyr
XTyrns
XTyrrea
XUhura
XUkaipu
XUlka
XUnicorn
XUnok
XUpuaut
XUranus
XUrd
XUrdanis
XUrech
XUrsa
XUrsharabi
XUrth
XUtgard
XUther
XUtnapishtim
XUxmal
XVal
XValhalla
XValkyrie
XVanCleef
XVanaheim
XVanir
XVarnak
XVasuki
XVe
XVedies
XVenus
XVerdandi
XVesta
XVigari
XVili
XVirag
XVivian
XVishtaspa
XVohuManuh
XVoltaire
XVolva
XVucu-Caquix
XVulcan
XVurat
XWalla
XWampum
XWaterloo
XWaura
XWawalag
XWoden
XWu
XXantor
XXerxes
XXrka
XYaddith
XYami
XYamotodake
XYang
XYangtse
XYarnek
XYgerne
XYggdrasil
XYin
XYmir
XYog-sothoth
XYu-Nu
XYu-ti
XYucatan
XYumCaax
XZaaxon
XZahak
XZapana
XZarathrusta
XZetes
XZethus
XZocho
XZoroaster
XZrd
XZurvan
END_OF_FILE
if test 5494 -ne `wc -c <'misc/planet.list'`; then
    echo shar: \"'misc/planet.list'\" unpacked with wrong size!
fi
# end of 'misc/planet.list'
fi
if test -f 'server/Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/Makefile.SH'\"
else
echo shar: Extracting \"'server/Makefile.SH'\" \(5777 characters\)
sed "s/^X//" >'server/Makefile.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X    fi
X    . ./config.sh
X    ;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
X
Xecho "Extracting server/Makefile (with variable substitutions)"
Xcat >Makefile <<!GROK!THIS!
X#
X#  user level Makefile for the GB+ program
X#  This makefile will make the commands library routines
X#
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	John Deragon deragon@jethro.cs.nyu.edu
X#
X# Revision 1.7 23:34:38 jpd
X# 
X#
X# Variables
X#	Variables established by Configure
XCC		=	$cc
XCCFLAGS		=	$ccflags $xencf
XCHGRP		=	$chgrp
XCHMOD		=	$chmod
XCP		=	$cp
XDEST		=	$bin
XECHO		=	$echo
XLFLAGS		=	$ldflags 
XLIB		=	-L../user
XLIBS2		= 	-luser
XLIBS		=	-ltermcap -lcurses -lm
XLINT		=	$lint
XMV		=	$mv
XOPTIMIZE	=	$optimize
XRM		= 	$rm -f
XAR		= 	$ar
XRANLIB  =   $ranlib
XTOUCH		=	$touch
XPORT        =   $port
XHOST        =   $host
X
X!GROK!THIS!
X
Xcat >>Makefile <<'!NO!SUBS!'
X
X#	Variables you may want to manually edit
X#		If you want debug logging then you'll
X#		want to uncomment the following.
X#DEBUG		=	-DDEBUG
X
X#		If you're on an ACSnet system (Australia) then
X#		you'll want to uncomment the following.
X# DACSNET	=	-DACSNET
X
X#	Other general variables
XBIN		=	../bin
XCFLAGS		=	$(CCFLAGS) $(OPTIMIZE) -I$(INCLDIR) $(DEBUG) $(DACSNET) 
XINCLDIR		=	../hdrs
XLINTFLAGS	=	-I$(INCLDIR)
XSHELL		=	/bin/sh
X
X# 	Lists
XSERVER_SRC		=	GB_server.c \
X					doplanet.c \
X					dosector.c \
X					doship.c \
X					doturn.c \
X					files.c \
X					files_rw.c \
X					max.c \
X					files_shl.c \
X					get4args.c \
X					getplace.c \
X					misc.c \
X					moveplanet.c \
X					moveship.c \
X					perm.c \
X					rand.c \
X					log.c \
X					lists.c \
X					access.c \
X					client.c \
X					shlmisc.c 
X
XSERVER_OBJ		=	GB_server.o \
X					doplanet.o \
X					dosector.o \
X					doship.o \
X					doturn.o \
X					files.o \
X					files_rw.o \
X					max.o \
X					files_shl.o \
X					get4args.o \
X					getplace.o \
X					misc.o \
X					moveplanet.o \
X					moveship.o \
X					perm.o \
X					rand.o \
X					log.o \
X					lists.o \
X					access.o \
X					client.o \
X					shlmisc.o 
X
X
X
X# Standard targets
Xall:		GB
X
X#	Dependencies and rules for compiling C programs
XGB:	$& $(SERVER_OBJ)
X		$(CC) $(LFLAGS) -o $@ $(SERVER_OBJ) $(LIB) $(LIBS2) $(LIBS)
X
Xinstall:
X		install GB $(BIN)
X
Xinstallgbx:
X		install GBX $(BIN)
X
X#   Use this for making a version to debug with
Xinclude  ../user/OBJECTS
Xinclude  ../user/SOURCES
XGBX: $& $(SERVER_OBJ)
X		$(CC) $(LFLAGS) -g -o $@ $(USER_OBJ) $(SERVER_OBJ) $(LIBS)
X
Xsaber:
X	#load $(CFLAGS) $(SERVER_SRC) $(USER_SRC)
X
Xclean: 
X	$(RM) $(SERVER_OBJ)
X
X# DO NOT DELETE THIS LINE -- make depend depends on it.
XGB_server.o: ../hdrs/TinyMUD_copyright.h ../hdrs/vars.h ../hdrs/files.h
XGB_server.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
XGB_server.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/doturn.h
XGB_server.o: ../hdrs/interface.h ../hdrs/buffers.h 
Xaccess.o:  ../hdrs/interface.h ../hdrs/TinyMUD_copyright.h ../hdrs/files.h
Xdoplanet.o: ../hdrs/GB_copyright.h ../hdrs/vars.h 
Xdoplanet.o: ../hdrs/files.h ../hdrs/tweakables.h ../hdrs/config.h
Xdoplanet.o: ../hdrs/doturn.h ../hdrs/power.h ../hdrs/buffers.h
Xdosector.o: ../hdrs/GB_copyright.h ../hdrs/vars.h
Xdosector.o: ../hdrs/files.h ../hdrs/tweakables.h ../hdrs/config.h
Xdosector.o: ../hdrs/power.h ../hdrs/races.h
Xdosector.o: ../hdrs/ships.h ../hdrs/doturn.h 
Xdoship.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xdoship.o: ../hdrs/tweakables.h ../hdrs/config.h 
Xdoship.o: ../hdrs/ships.h 
Xdoship.o: ../hdrs/races.h ../hdrs/doturn.h ../hdrs/power.h ../hdrs/buffers.h
Xdoturn.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xdoturn.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xdoturn.o: ../hdrs/races.h ../hdrs/doturn.h ../hdrs/power.h ../hdrs/buffers.h
Xfiles.o: ../hdrs/GB_copyright.h ../hdrs/files.h
Xfiles_rw.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/buffers.h
Xfiles_rw.o: ../hdrs/files.h ../hdrs/tweakables.h ../hdrs/config.h
Xfiles_shl.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xfiles_shl.o: ../hdrs/tweakables.h ../hdrs/config.h 
Xfiles_shl.o: ../hdrs/ships.h 
Xfiles_shl.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h
Xget4args.o: ../hdrs/GB_copyright.h
Xgetplace.o: ../hdrs/GB_copyright.h ../hdrs/vars.h
Xgetplace.o: ../hdrs/files.h ../hdrs/tweakables.h ../hdrs/config.h
Xgetplace.o: ../hdrs/races.h ../hdrs/ships.h
Xgetplace.o: ../hdrs/power.h ../hdrs/buffers.h 
Xlists.o: ../hdrs/vars.h ../hdrs/files.h
Xlists.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xlog.o: ../hdrs/vars.h ../hdrs/files.h
Xlog.o: ../hdrs/tweakables.h ../hdrs/config.h 
Xmax.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xmax.o: ../hdrs/tweakables.h ../hdrs/config.h 
Xmax.o: ../hdrs/power.h ../hdrs/races.h ../hdrs/ships.h 
Xmisc.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xmisc.o: ../hdrs/tweakables.h ../hdrs/config.h 
Xmisc.o: ../hdrs/races.h ../hdrs/buffers.h
Xmoveplanet.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xmoveplanet.o: ../hdrs/tweakables.h ../hdrs/config.h
Xmoveplanet.o: ../hdrs/ships.h
Xmoveplanet.o: ../hdrs/races.h ../hdrs/doturn.h 
Xmoveship.o: ../hdrs/GB_copyright.h ../hdrs/vars.h
Xmoveship.o: ../hdrs/files.h ../hdrs/tweakables.h ../hdrs/config.h
Xmoveship.o: ../hdrs/power.h ../hdrs/ships.h
Xmoveship.o: ../hdrs/races.h ../hdrs/doturn.h ../hdrs/buffers.h
Xperm.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xperm.o: ../hdrs/tweakables.h ../hdrs/config.h 
Xrand.o: ../hdrs/GB_copyright.h
Xshlmisc.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xshlmisc.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/races.h
Xshlmisc.o: ../hdrs/power.h ../hdrs/ships.h ../hdrs/buffers.h
XGBX: $(USER_OBJ)
X!NO!SUBS!
END_OF_FILE
if test 5777 -ne `wc -c <'server/Makefile.SH'`; then
    echo shar: \"'server/Makefile.SH'\" unpacked with wrong size!
fi
# end of 'server/Makefile.SH'
fi
if test -f 'server/dosector.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/dosector.c'\"
else
echo shar: Extracting \"'server/dosector.c'\" \(5569 characters\)
sed "s/^X//" >'server/dosector.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h, enroll.dat.
X * Restrictions in GB_copyright.h. dosector.c produce() -- produce, stuff
X * like that, on a sector. spread()  -- spread population around. explore()
X * -- mark sector and surrounding sectors as having been explored.
X */
X#include <math.h>
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "power.h"
X#include "races.h"
X#include "ships.h"
X#include "doturn.h"
X
Xextern int      Defensedata[];
X/* produce stuff in sector */
X
Xvoid            produce(startype *, planettype *, sectortype *);
Xvoid            spread(planettype *, sectortype *, int, int);
Xvoid            Migrate2(planettype *, int, int, sectortype *, int *);
Xvoid            explore(planettype *, sectortype *, int, int, int);
Xvoid            plate(sectortype *);
X#include "proto.h"
X
Xvoid 
Xproduce(startype * star, planettype * planet, sectortype * s)
X{
X	reg int         ss;
X	reg int         maxsup;
X	reg int         pfuel = 0, pdes = 0, pres = 0;
X	reg struct plinfo *pinf;
X	reg int         prod, diff;
X	racetype       *Race;
X
X	if (!s->owner)
X		return;
X	Race = races[s->owner - 1];
X
X	if (s->resource && success(s->eff)) {
X		prod = round_rand(Race->metabolism) * int_rand(1, s->eff);
X		prod = MIN(prod, s->resource);
X		s->resource -= prod;
X		pfuel = prod * (1 + (s->condition == GAS));
X		if (success(s->mobilization))
X			pdes = prod;
X		else
X			pres = prod;
X		prod_fuel[s->owner - 1] += pfuel;
X		prod_res[s->owner - 1] += pres;
X		prod_destruct[s->owner - 1] += pdes;
X	}
X	/* try to find crystals */
X	/* chance of digging out a crystal depends on efficiency */
X	if (s->crystals && Crystal(Race) && success(s->eff)) {
X		prod_crystals[s->owner - 1]++;
X		s->crystals--;
X	}
X	pinf = &planet->info[s->owner - 1];
X
X	/* increase mobilization to planetary quota */
X	if (s->mobilization < pinf->mob_set) {
X		if (pinf->resource + prod_res[s->owner - 1] > 0) {
X			s->mobilization++;
X			prod_res[s->owner - 1] -= round_rand(MOB_COST);
X			prod_mob++;
X		}
X	} else if (s->mobilization > pinf->mob_set) {
X		s->mobilization--;
X		prod_mob--;
X	}
X	avg_mob[s->owner - 1] += s->mobilization;
X
X	/* do efficiency */
X	if (s->eff < 100) {
X		reg int         chance;
X		chance = round_rand((100.0 - (double) planet->info[s->owner - 1].tax) *
X				    Race->likes[s->condition]);
X		if (success(chance)) {
X			s->eff += round_rand(Race->metabolism);
X			if (s->eff >= 100)
X				plate(s);
X		}
X	} else
X		plate(s);
X
X
X	if ((s->condition != WASTED) && Race->fertilize && (s->fert < 100))
X		s->fert += (int_rand(0, 100) < Race->fertilize);
X	if (s->fert > 100)
X		s->fert = 100;
X
X	if (s->condition == WASTED && success(NATURAL_REPAIR))
X		s->condition = s->type;
X
X	maxsup = maxsupport(Race, s, Compat[s->owner - 1], planet->conditions[TOXIC]);
X	if ((diff = s->popn - maxsup) < 0) {
X		if (s->popn >= Race->number_sexes)
X			ss = round_rand(-(double) diff * Race->birthrate);
X		else
X			ss = 0;
X	} else
X		ss = -int_rand(0, MIN(2 * diff, s->popn));
X	s->popn += ss;
X
X	if (s->troops)
X		Race->governor[star->governor[s->owner - 1]].maintain
X			+= UPDATE_TROOP_COST * s->troops;
X	else if (!s->popn)
X		s->owner = 0;
X}
X
Xint             x_adj[] = {-1, 0, 1, -1, 1, -1, 0, 1};
Xint             y_adj[] = {1, 1, 1, 0, 0, -1, -1, -1};
X
Xvoid 
Xspread(reg planettype * pl, reg sectortype * s, reg int x, reg int y)
X{
X	int             people;
X	reg int         x2, y2, j;
X	reg int         check;
X	racetype       *Race;
X
X	if (!s->owner)
X		return;
X	if (pl->slaved_to && pl->slaved_to != s->owner)
X		return;		/* no one wants to go anywhere */
X
X	Race = races[s->owner - 1];
X
X	/* the higher the fertility, the less people like to leave */
X	people = round_rand((double) Race->adventurism * (double) s->popn
X			    * (100. - (double) s->fert) / 100.)
X		- Race->number_sexes;	/* how many people want to move - one
X					 * family stays behind */
X
X	check = round_rand(6.0 * Race->adventurism);	/* more rounds for high
X							 * advent */
X	while (people > 0 && check) {
X		j = int_rand(0, 7);
X		x2 = x_adj[j];
X		y2 = y_adj[j];
X		Migrate2(pl, x + x2, y + y2, s, &people);
X		check--;
X	}
X
X}
X
Xvoid 
XMigrate2(planettype * planet, reg int xd, reg int yd, sectortype * ps, int *people)
X{
X	reg sectortype *pd;
X	reg int         move;
X
X	/* attempt to migrate beyond screen, or too many people */
X	if (yd > planet->Maxy - 1 || yd < 0)
X		return;
X
X	if (xd < 0)
X		xd = planet->Maxx - 1;
X	else if (xd > planet->Maxx - 1)
X		xd = 0;
X
X	pd = &Sector(*planet, xd, yd);
X
X	if (!pd->owner) {
X		move = (int) ((double) (*people) * Compat[ps->owner - 1] *
X			races[ps->owner - 1]->likes[pd->condition] / 100.0);
X		if (!move)
X			return;
X		*people -= move;
X		pd->popn += move;
X		ps->popn -= move;
X		pd->owner = ps->owner;
X		tot_captured++;
X		Claims = 1;
X	}
X}
X
X/*
X * mark sectors on the planet as having been "explored." for sea exploration
X * on earthtype planets.
X */
X
Xvoid 
Xexplore(reg planettype * planet, reg sectortype * s, reg int x, reg int y, reg int p)
X{
X	reg int         d;
X
X	/* explore sectors surrounding sectors currently explored. */
X	if (Sectinfo[x][y].explored) {
X		Sectinfo[mod(x - 1, planet->Maxx, d)][y].explored = p;
X		Sectinfo[mod(x + 1, planet->Maxx, d)][y].explored = p;
X		if (y == 0) {
X			Sectinfo[x][1].explored = p;
X		} else if (y == planet->Maxy - 1) {
X			Sectinfo[x][y - 1].explored = p;
X		} else {
X			Sectinfo[x][y - 1].explored = Sectinfo[x][y + 1].explored = p;
X		}
X
X	} else if (s->owner == p)
X		Sectinfo[x][y].explored = p;
X
X}
X
Xvoid 
Xplate(sectortype * s)
X{
X	s->eff = 100;
X	if (s->condition != GAS)
X		s->condition = PLATED;
X}
END_OF_FILE
if test 5569 -ne `wc -c <'server/dosector.c'`; then
    echo shar: \"'server/dosector.c'\" unpacked with wrong size!
fi
# end of 'server/dosector.c'
fi
if test -f 'user/dissolve.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/dissolve.c'\"
else
echo shar: Extracting \"'user/dissolve.c'\" \(5186 characters\)
sed "s/^X//" >'user/dissolve.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h. dissolve.c -- commit suicide, nuke all ships and sectors;
X * July 24th, 1989, John Deragon, cruz@cadman.nyu.edu
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "doturn.h"
X#include "power.h"
X#include "buffers.h"
X#include <math.h>
X
Xvoid            dissolve(int, int);
Xint             revolt(planettype *, int, int);
X#include "proto.h"
X
Xvoid 
Xdissolve(int Playernum, int Governor)
X{
X	int             n_ships;
X	int             i, j, z, x2, y2, hix, hiy, lowx, lowy;
X	unsigned char   waste;
X	shiptype       *sp;
X	racetype       *Race;
X	planettype     *pl;
X	sectortype     *s;
X	char            nuke;
X	char            racepass[100], govpass[100];
X
X#ifndef DISSOLVE
X	notify(Playernum, Governor, "Dissolve has been disabled. Please notify diety.\n");
X	return;
X#endif
X
X	if (Governor) {
X		notify(Playernum, Governor, "Only the leader may dissolve the race. The leader has been notified of your attempt!!!\n");
X		sprintf(buf, "Governor #%d has attempted to dissolve this race.\n",
X			Governor);
X		notify(Playernum, 0, buf);
X		return;
X	}
X	n_ships = Numships();
X
X	if (argn < 3) {
X		sprintf(buf, "Self-Destruct sequence requires passwords.\n");
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Please use 'dissolve <race password> <leader password>'<option> to initiate\n");
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "self-destruct sequence.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	} else {
X		sprintf(buf, "WARNING!! WARNING!! WARNING!!\n");
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "-------------------------------\n");
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Entering self destruct sequence!\n");
X		notify(Playernum, Governor, buf);
X
X		sscanf(args[1], "%s", racepass);
X		sscanf(args[2], "%s", govpass);
X
X		waste = 0;
X		if (argn > 3) {
X			sscanf(args[3], "%c", &nuke);
X			if (nuke == 'w')
X				waste = 1;
X		}
X		Getracenum(racepass, govpass, &i, &j);
X
X		if (!i || !j) {
X			sprintf(buf, "Password mismatch, self-destruct not initiated!\n");
X			notify(Playernum, Governor, buf);
X			return;
X		}
X		for (i = 1; i <= n_ships; i++) {
X			(void) getship(&sp, i);
X			if (sp->owner == Playernum) {
X				kill_ship(Playernum, sp);
X				sprintf(buf, "Ship #%d, self-destruct enabled\n", i);
X				notify(Playernum, Governor, buf);
X				putship(sp);
X			}
X			free(sp);
X		}
X
X		getsdata(&Sdata);
X		for (z = 0; z < Sdata.numstars; z++) {
X			getstar(&(Stars[z]), z);
X			if (isset(Stars[z]->explored, Playernum)) {
X				for (i = 0; i < Stars[z]->numplanets; i++) {
X					getplanet(&pl, z, i);
X
X					if (pl->info[Playernum - 1].explored
X					    && pl->info[Playernum - 1].numsectsowned) {
X						pl->info[Playernum - 1].fuel = 0;
X						pl->info[Playernum - 1].destruct = 0;
X						pl->info[Playernum - 1].resource = 0;
X						pl->info[Playernum - 1].popn = 0;
X						pl->info[Playernum - 1].troops = 0;
X						pl->info[Playernum - 1].tax = 0;
X						pl->info[Playernum - 1].newtax = 0;
X						pl->info[Playernum - 1].crystals = 0;
X						pl->info[Playernum - 1].numsectsowned = 0;
X						pl->info[Playernum - 1].explored = 0;
X						pl->info[Playernum - 1].autorep = 0;
X					}
X					getsmap(Smap, pl);
X
X					lowx = 0;
X					lowy = 0;
X					hix = pl->Maxx - 1;
X					hiy = pl->Maxy - 1;
X					for (y2 = lowy; y2 <= hiy; y2++) {
X						for (x2 = lowx; x2 <= hix; x2++) {
X							s = &Sector(*pl, x2, y2);
X							if (s->owner == Playernum) {
X								s->owner = 0;
X								s->troops = 0;
X								s->popn = 0;
X								if (waste)
X									/*
X									 * cod
X									 * e
X									 * fol
X									 * ded
X									 * 
X									 * fro
X									 * m
X									 * her
X									 * e
X									 */
X									s->condition = WASTED;
X								/* unfolding */
X							}
X						}
X					}
X					putsmap(Smap, pl);
X					putstar(Stars[z], z);
X					putplanet(pl, z, i);
X					free(pl);
X				}
X			}
X		}
X
X		Race = races[Playernum - 1];
X		Race->dissolved = 1;
X		putrace(Race);
X
X		sprintf(buf, "%s [%d] has dissolved.\n", Race->name, Playernum);
X		post(buf, DECLARATION);
X
X	}
X}
X
X
Xint 
Xrevolt(planettype * pl, int victim, int agent)
X{
X	int             x, y, hix, hiy, lowx, lowy;
X	racetype       *Race;
X	sectortype     *s;
X	int             changed_hands = 0;
X
X	Race = races[victim - 1];
X
X	getsmap(Smap, pl);
X	/* do the revolt */
X	lowx = 0;
X	lowy = 0;
X	hix = pl->Maxx - 1;
X	hiy = pl->Maxy - 1;
X	for (y = lowy; y <= hiy; y++) {
X		for (x = lowx; x <= hix; x++) {
X			s = &Sector(*pl, x, y);
X			if (s->owner == victim && s->popn) {
X				if (success(pl->info[victim - 1].tax)) {
X					if (int_rand(1, (int) s->popn) > 10 * Race->fighters * s->troops) {
X						s->owner = agent;	/* enemy gets it */
X						s->popn = int_rand(1, (int) s->popn);	/* some people killed */
X						s->troops = 0;	/* all troops destroyed */
X						pl->info[victim - 1].numsectsowned -= 1;
X						pl->info[agent - 1].numsectsowned += 1;
X						pl->info[victim - 1].mob_points -= s->mobilization;
X						pl->info[agent - 1].mob_points += s->mobilization;
X						changed_hands++;
X					}
X				}
X			}
X		}
X	}
X	putsmap(Smap, pl);
X
X	return changed_hands;
X}
END_OF_FILE
if test 5186 -ne `wc -c <'user/dissolve.c'`; then
    echo shar: \"'user/dissolve.c'\" unpacked with wrong size!
fi
# end of 'user/dissolve.c'
fi
if test -f 'user/enslave.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/enslave.c'\"
else
echo shar: Extracting \"'user/enslave.c'\" \(4368 characters\)
sed "s/^X//" >'user/enslave.c' <<'END_OF_FILE'
X/*
X * * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, *
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. * Restrictions in
X * GB_copyright.h. *  enslave.c -- ENSLAVE the planet below.
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X#include <signal.h>
X
Xvoid            enslave(int, int, int);
X#include "proto.h"
X
Xvoid 
Xenslave(int Playernum, int Governor, int APcount)
X{
X	shiptype       *s, *s2;
X	planettype     *p;
X	int             sh, shipno, i, aliens = 0, def = 0, attack = 0;
X	racetype       *Race;
X
X	sscanf(args[1] + (args[1][0] == '#'), "%d", &shipno);
X
X	if (!getship(&s, shipno)) {
X		return;
X	}
X	if (testship(Playernum, Governor, s)) {
X		free(s);
X		return;
X	}
X	if (s->type != STYPE_OAP) {
X		sprintf(buf, "This ship is not an %s.\n", Shipnames[STYPE_OAP]);
X		notify(Playernum, Governor, buf);
X		free(s);
X		return;
X	}
X	if (s->whatorbits != LEVEL_PLAN) {
X		sprintf(buf, "%s doesn't orbit a planet.\n", Ship(s));
X		notify(Playernum, Governor, buf);
X		free(s);
X		return;
X	}
X	if (!enufAP(Playernum, Governor, Stars[s->storbits]->AP[Playernum - 1], APcount)) {
X		free(s);
X		return;
X	}
X	getplanet(&p, (int) s->storbits, (int) s->pnumorbits);
X	if (p->info[Playernum - 1].numsectsowned == 0) {
X		sprintf(buf, "You don't have a garrison on the planet.\n");
X		notify(Playernum, Governor, buf);
X		free(s);
X		free(p);
X		return;
X	}
X	/* add up forces attacking, defending */
X	for (attack = aliens = def = 0, i = 1; i < MAXPLAYERS; i++) {
X		if (p->info[i - 1].numsectsowned && i != Playernum) {
X			aliens = 1;
X			def += p->info[i - 1].destruct;
X		}
X	}
X
X	if (!aliens) {
X		sprintf(buf, "There is no one else on this planet to enslave!\n");
X		notify(Playernum, Governor, buf);
X		free(s);
X		free(p);
X		return;
X	}
X	Race = races[Playernum - 1];
X
X	sh = p->ships;
X	while (sh) {
X		(void) getship(&s2, sh);
X		if (s2->alive && s2->active) {
X			if (p->info[s2->owner].numsectsowned && s2->owner != Playernum)
X				def += s2->destruct;
X			else if (s2->owner == Playernum)
X				attack += s2->destruct;
X		}
X		sh = s2->nextship;
X		free(s2);
X	}
X
X	deductAPs(Playernum, Governor, APcount, (int) s->storbits, 0);
X
X	sprintf(buf, "\nFor successful enslavement this ship and the other ships here\n");
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "that are yours must have a weapons\n");
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "capacity greater than twice that the enemy can muster, including\n");
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "the planet and all ships orbiting it.\n");
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "\nTotal forces bearing on %s:   %d\n", prin_ship_orbits(s), attack);
X	notify(Playernum, Governor, buf);
X
X	sprintf(telegram_buf, "ALERT!!!\n\nPlanet /%s/%s ",
X		Stars[s->storbits]->name,
X		Stars[s->storbits]->pnames[s->pnumorbits]);
X
X	if (def <= 2 * attack) {
X		p->slaved_to = Playernum;
X		putplanet(p, (int) s->storbits, (int) s->pnumorbits);
X
X		/* send telegs to anyone there */
X		sprintf(buf, "ENSLAVED by %s!!\n", Ship(s));
X		strcat(telegram_buf, buf);
X		sprintf(buf, "All material produced here will be\ndiverted to %s coffers.",
X			Race->name);
X		strcat(telegram_buf, buf);
X
X		sprintf(buf, "\nEnslavement successful.  All material produced here will\n");
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "be diverted to %s.\n", Race->name);
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "You must maintain a garrison of 0.1%% the population of the\n");
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "planet (at least %.0f); otherwise there is a 50%% chance that\n", p->popn * 0.001);
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "enslaved population will revolt.\n");
X		notify(Playernum, Governor, buf);
X	} else {
X		sprintf(buf, "repulsed attempt at enslavement by %s!!\n", Ship(s));
X		strcat(telegram_buf, buf);
X		sprintf(buf, "Enslavement repulsed, defense/attack Ratio : %d to %d.\n", def, attack);
X		strcat(telegram_buf, buf);
X
X		sprintf(buf, "Enslavement repulsed.\n");
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "You needed more weapons bearing on the planet...\n");
X		notify(Playernum, Governor, buf);
X	}
X
X	for (i = 1; i < MAXPLAYERS; i++)
X		if (p->info[i - 1].numsectsowned && i != Playernum)
X			warn(i, (int) Stars[s->storbits]->governor[i - 1], telegram_buf);
X
X	free(p);
X	free(s);
X}
END_OF_FILE
if test 4368 -ne `wc -c <'user/enslave.c'`; then
    echo shar: \"'user/enslave.c'\" unpacked with wrong size!
fi
# end of 'user/enslave.c'
fi
if test -f 'user/togg.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/togg.c'\"
else
echo shar: Extracting \"'user/togg.c'\" \(4634 characters\)
sed "s/^X//" >'user/togg.c' <<'END_OF_FILE'
X#ident  "@(#)togg.c	1.5 2/1/93 "
X/***********************************************
X * togg.c
X *
X * Created: ???
X * Author:  Robert Chansky
X *
X * Version: 1.5 00:14:42
X *
X * Contains: toggle()
X *           highlight()
X *           tog()
X *
X ***********************************************/
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X#include <strings.h>
X
X/*
X * Prototypes
X */
Xvoid            toggle(int, int, int);
Xvoid            highlight(int, int);
Xvoid            tog(int, int, char *, char *);
X#include "proto.h"
X
X/*
X * toggle:
X * 
X * arguments: Playernum Governor
X * 
X * called by: process_commands
X * 
X * description:  Called from process_commands, allows you to toggle some
X * options. Currently inverse, double_digits, gag, autoload, color, and
X * monitor
X * 
X */
Xvoid
Xtoggle(int Playernum, int Governor, int APcount)
X{
X	racetype       *Race;
X
X	Race = races[Playernum - 1];
X
X	if (argn > 1) {
X		if (match(args[1], "inverse"))
X			tog(Playernum, Governor,
X			&Race->governor[Governor].toggle.inverse, "inverse");
X		else if (match(args[1], "double_digits"))
X			tog(Playernum, Governor,
X			    &Race->governor[Governor].toggle.double_digits, "double_digits");
X		else if (match(args[1], "geography"))
X			tog(Playernum, Governor,
X			    &Race->governor[Governor].toggle.geography, "geography");
X		else if (match(args[1], "gag"))
X			tog(Playernum, Governor,
X			    &Race->governor[Governor].toggle.gag, "gag");
X		else if (match(args[1], "autoload"))
X			tog(Playernum, Governor,
X			    &Race->governor[Governor].toggle.autoload, "autoload");
X		else if (match(args[1], "color"))
X			tog(Playernum, Governor,
X			    &Race->governor[Governor].toggle.color, "color");
X		else if (match(args[1], "visible"))
X			tog(Playernum, Governor,
X			    &Race->governor[Governor].toggle.invisible, "invisible");
X		else if (Race->God && match(args[1], "monitor"))
X			tog(Playernum, Governor, &Race->monitor, "monitor");
X		else if (match(args[1], "compatibility"))
X			tog(Playernum, Governor,
X			    &Race->governor[Governor].toggle.compat, "compatibility");
X		else if (match(args[1], "client")) {
X			CSP_client_toggle(Playernum, Governor, 0);	
X		} else {
X			sprintf(buf, "No such option '%s'\n", args[1]);
X			notify(Playernum, Governor, buf);
X			return;
X		}
X		putrace(Race);
X	} else {
X		sprintf(buf, "gag is %s\n",
X			Race->governor[Governor].toggle.gag ? "ON" : "OFF");
X		notify(Playernum, Governor, buf);
X
X		sprintf(buf, "inverse is %s\n",
X		    Race->governor[Governor].toggle.inverse ? "ON" : "OFF");
X		notify(Playernum, Governor, buf);
X
X		sprintf(buf, "double_digits is %s\n",
X			Race->governor[Governor].toggle.double_digits ? "ON" : "OFF");
X		notify(Playernum, Governor, buf);
X
X		sprintf(buf, "geography is %s\n",
X		  Race->governor[Governor].toggle.geography ? "ON" : "OFF");
X		notify(Playernum, Governor, buf);
X
X		sprintf(buf, "autoload is %s\n",
X		   Race->governor[Governor].toggle.autoload ? "ON" : "OFF");
X		notify(Playernum, Governor, buf);
X
X		sprintf(buf, "color is %s\n",
X		      Race->governor[Governor].toggle.color ? "ON" : "OFF");
X		notify(Playernum, Governor, buf);
X
X		sprintf(buf, "compatibility is %s\n",
X		     Race->governor[Governor].toggle.compat ? "ON" : "OFF");
X		notify(Playernum, Governor, buf);
X
X		sprintf(buf, "%s\n",
X			Race->governor[Governor].toggle.invisible ? "INVISIBLE" : "VISIBLE");
X		notify(Playernum, Governor, buf);
X
X		sprintf(buf, "highlight player %d\n",
X			Race->governor[Governor].toggle.highlight);
X		notify(Playernum, Governor, buf);
X
X		sprintf(buf, "client mode is %s\n",
X			Race->governor[Governor].CSP_client_info.csp_user ? "ON" : "OFF");
X		notify(Playernum, Governor, buf);
X
X		if (Race->God) {
X			sprintf(buf, "monitor is %s\n", Race->monitor ? "ON" : "OFF");
X			notify(Playernum, Governor, buf);
X		}
X	}
X}
X/*
X * hightlight:
X * 
X * arguments: Playernum Governor
X * 
X * description:  Called process commands.
X * 
X */
Xvoid
Xhighlight(int Playernum, int Governor)
X{
X	int             n;
X	racetype       *Race;
X
X	if (!(n = GetPlayer(args[1]))) {
X		sprintf(buf, "No such player.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	Race = races[Playernum - 1];
X	Race->governor[Governor].toggle.highlight = n;
X	putrace(Race);
X}
X
X/*
X * tog:
X * 
X * arguments: Playernum Governor op  - what we are toggling name
X * 
X * called by: toggle (local to this file)
X * 
X * description: This function does the acutal toggle of the bits
X * 
X */
Xvoid
Xtog(int Playernum, int Governor, char *op, char *name)
X{
X	*op = !(*op);
X	sprintf(buf, "%s is now %s\n", name, *op ? "on" : "off");
X	notify(Playernum, Governor, buf);
X}
END_OF_FILE
if test 4634 -ne `wc -c <'user/togg.c'`; then
    echo shar: \"'user/togg.c'\" unpacked with wrong size!
fi
# end of 'user/togg.c'
fi
echo shar: End of archive 19 \(of 21\).
cp /dev/null ark19isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
