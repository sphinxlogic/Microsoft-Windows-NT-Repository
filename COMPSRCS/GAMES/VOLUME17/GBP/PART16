Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i028:  gbp - Galactic Bloodshed+, an empire-like war game, Part16/21
Message-ID: <4556@master.CNA.TEK.COM>
Date: 12 Feb 93 17:32:38 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1598
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1707

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 28
Archive-name: gbp/Part16
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 16 (of 21)."
# Contents:  hdrs/csp.h hdrs/shipdata.h hdrs/ships.h hdrs/vars.h
#   user/cs.c user/declare.c
# Wrapped by billr@saab on Fri Feb 12 09:14:29 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'hdrs/csp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdrs/csp.h'\"
else
echo shar: Extracting \"'hdrs/csp.h'\" \(1748 characters\)
sed "s/^X//" >'hdrs/csp.h' <<'END_OF_FILE'
X/*
X * csp.h: Contains the defines for all the Client-Server Protocol (CSP)
X *        numbers.
X *
X * Version 1.2
X *
X * Please send any modifications of this file to:
X *    ekoffler@darkwing.uoregon.edu 
X *    deragon@jethro.nyu.edu
X *
X */
X
X
X/* character to be found in column 0 of a CSP output line */
X# define CSP_CLIENT			'|'
X
X/* identifier sent by client to server when sending a command/request */
X# define CSP_SERVER			"CSP"
X
X/* VERSION */
X# define CSP_VERSION_INFO               10      /* version XX */
X# define CSP_VERSION_OPTIONS            11      /* options set YY */
X
X/* LOGIN */
X# define CSP_CLIENT_ON			30	/* client mode on      */
X# define CSP_CLIENT_OFF			31	/* client mode off     */
X
X/* UPDATE/SEGMENT/RESET */
X
X/* update/segment info */			
X# define CSP_UPDATE_START		50	/* update started */
X# define CSP_UPDATE_END			51	/* update finshed */
X# define CSP_SEGMENT_START		52	/* segment started */
X# define CSP_SEGMENT_END		53	/* segment finished */
X# define CSP_RESET_START		54	/* reset started */
X# define CSP_RESET_END			55	/* reset finished */
X
X/* SURVEY */
X
X/* client_survey command */
X# define CSP_SURVEY_INTRO               101     /* planet info */
X# define CSP_SURVEY_SECTOR              102     /* sector info */
X# define CSP_SURVEY_END                 103     /* end of command(EOC) */
X
X/* COMMANDS */
X
X# define CSP_LOGIN_COMMAND		1101	/* login command   */
X# define CSP_VERSION_COMMAND		1102	/* version command */
X# define CSP_SURVEY_COMMAND		1103    /* imap command    */
X
X/* ERRORS */
X
X# define CSP_ERR			9900    /* error           */
X# define CSP_ERR_TOO_MANY_ARGS		9901	/* too many args   */
X# define CSP_ERR_TOO_FEW_ARGS		9902    /* too few args    */
X# define CSP_ERR_UNKNOWN_COMMAND	9903    /* unknown command */
X
X
END_OF_FILE
if test 1748 -ne `wc -c <'hdrs/csp.h'`; then
    echo shar: \"'hdrs/csp.h'\" unpacked with wrong size!
fi
# end of 'hdrs/csp.h'
fi
if test -f 'hdrs/shipdata.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdrs/shipdata.h'\"
else
echo shar: Extracting \"'hdrs/shipdata.h'\" \(9773 characters\)
sed "s/^X//" >'hdrs/shipdata.h' <<'END_OF_FILE'
X#ident  "@(#)shipdata.h	1.7 2/1/93 "
X
X#include "config.h"
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, 
X * smq@ucscb.ucsc.edu, mods by people in GB.c, enroll.dat.
X * Restrictions in GB.c.
X */
X
Xchar Shipltrs[]={ 'p','s','X','D','B','I','C','d','f','e','H','S','O','c',
X	't','+','M','=','E','-','a','g','h','@','l','w',':','G','F',
X	'T','[','^','P', 'q', 'K', 'Y', 'W', 'J', '&', 'R', 'b', 'L', 'm' };
X
X/* table for [ABIL_BUILD]. (bd). sum the numbers to get the correct value.
X/*      1 To allow it to be built on a planet.
X/*      2 For building by warships (d, B, C,..). Currently only for Space Probe.
X/*	  Mines used to be this way too. Built in hanger of building ship.
X/*      4 For building by Shuttles, Cargo ship, Habitats, etc.
X/*        Also forces construction on the outside of the ship. Not in hanger.
X/*      8 For building in Factories. Built on planet, or in hanger of carrying
X/*        ship (Habitat).
X/*     16 For building in Habitats. Used by Pods for instance. Also used by
X/*        Factories. Built inside Habitat. */
X
X/* table for [ABIL_CONSTRUCT]. (cn). sum the numbers to get the correct value.
X/*      1 To allow it to build like a planet.
X/*      2 For building like warships (d, B, C,..).
X/*      4 For building like Shuttles, Cargo ship, Habitats, etc.
X/*      8 For building like Factories.
X/*     16 For building like Habitats. */
X
X/* Changes here to use the new build routine using above tables.  Maarten
X/* Also changed:
X/*   - Pods, Factories, Weapons Plants, Terraforming Devices,
X/*     Orbital Mind Control Lasers and Government Centers can 
X/*     be built inside Habitats.
X/*   - Probes, and other type 2 ships (currently none), are now built inside
X/*     ships, requiring hanger space. This gives more incentive to keep some
X/*     hanger space in the big warships.
X/*   - The big space stations (Habitats, Stations, and Orbital Assault
X/*     Platforms) can now build Probes as well.
X
X /*   - Habitats and Stations had their ability to use a crystal mount removed.
X/*     Since they cannot use it in any way, it was rather useless. It only
X/*     confused the required resources to build the ship, though this has been
X/*     taken care of too.
X/*   - Orbital Mind Control Lasers having 10 guns of caliber 0 seemed strange.
X/*     Now 0 guns. Also removed the 100 destruct carrying capacity. Added 25
X/*     cargo space so it can repair itself. */
X
X
Xlong Shipdata[NUMSTYPES][NUMABILS] = {
X   /*  tech  carg  bay  dest guns prim sec fuelcap  crw arm  cst mt jp ld sw sp dm  bd   cn mod las cew clk god prg port rep pay dock*/
X#ifdef SUPER_PODS
X/*SPd*/   0,   0,    0,   0,   0,   0,  0,    20,    1,  0,   9,  0, 0, 1, 0, 3,  0,  1,  0, 0,  0,  0,  0,  0,   1,  0,  1,  0, 1,
X#else
X/*SPd*/   0,   0,    0,   0,   0,   0,  0,    20,    1,  0,   1,  0, 0, 1, 0, 2,  0,  1,  0, 0,  0,  0,  0,  0,   1,  0,  1,  0, 1,
X#endif
X/*Shu*/  10,  25,    2,   2,   1,   1,  0,    20,   10,  0,   2,  0, 0, 1, 0, 4,  0,  8,  4, 1,  0,  0,  0,  0,   1,  0,  0,  1, 1,
X/*Car*/ 250, 600,  200, 800,  30,   3,  2,  1000,   30,  5,  30,  1, 1, 0, 0, 4, 50, 20,  2, 1,  1,  1,  0,  0,   1,  0,  1,  1, 1,
X/*Drn*/ 300, 500,   10, 500,  60,   3,  2,   500,   60, 10,  40,  1, 1, 1, 0, 6, 50,  8,  2, 1,  1,  1,  0,  0,   1,  0,  0,  1, 1,
X/*BB */ 200, 235,   10, 400,  30,   3,  2,   200,   30,  7,  20,  1, 1, 1, 0, 6, 50,  8,  2, 1,  1,  1,  0,  0,   1,  0,  0,  1, 1,
X/*Int*/ 150, 110,    5, 120,  20,   2,  2,   200,   20,  3,  15,  1, 1, 1, 0, 6, 50,  8,  2, 1,  1,  1,  0,  0,   1,  0,  0,  1, 1,
X/*CA */ 150, 165,    5, 300,  20,   3,  2,   120,   20,  5,  10,  1, 1, 1, 0, 6, 50,  8,  2, 1,  1,  1,  0,  0,   1,  0,  0,  1, 1,
X/*DD */ 100, 110,    5, 120,  15,   2,  2,    80,   15,  3,   5,  1, 1, 1, 0, 6, 50,  8,  2, 1,  1,  1,  0,  0,   1,  0,  0,  1, 1,
X/*FF */ 100,   0,    0,  40,  20,   2,  1,    10,    1,  2,   1,  1, 1, 1, 0, 9,  0,  8,  2, 1,  1,  1,  0,  0,   1,  0,  1,  1, 1,
X/*Exp*/  40,  10,    0,  15,   5,   2,  0,    35,    5,  1,   2,  1, 1, 1, 0, 6,  0,  8,  0, 1,  1,  0,  0,  0,   1,  0,  0,  1, 1,
X/*Hab*/ 100,5000,   10, 500,  20,   2,  1,  2000,  2000, 3,  50,  0, 0, 0, 1, 4, 75, 20, 18, 1,  0,  0,  0,  0,   1,  1,  1,  1, 1,
X/*Stn*/ 100,5000,   10, 250,  20,   2,  0,  2000,   50,  1,  10,  0, 0, 0, 0, 4, 75, 20,  6, 1,  0,  0,  0,  0,   1,  1,  1,  1, 1,
X/*OSP*/ 200,1400,   20,1000,  50,   3,  2,  2000,  200,  5,  40,  1, 1, 0, 0, 4, 75, 20,  6, 1,  1,  1,  0,  0,   1,  0,  1,  1, 1,
X/*Crg*/ 100,1000,    5,1000,  10,   1,  0,  1000,  100,  2,  10,  1, 1, 1, 0, 4,  0,  8,  4, 1,  0,  0,  0,  0,   1,  0,  0,  1, 1,
X/*Tnk*/ 100, 200,    5, 200,  10,   1,  0,  5000,   10,  2,  10,  1, 1, 1, 0, 4,  0,  8,  2, 1,  0,  0,  0,  0,   1,  0,  0,  1, 1,
X/*SMn*/  50,   0,    0,  25,   0,   0,  0,    20,    0,  1,  30,  0, 0, 1, 1, 2,  0,  8,  0, 1,  0,  0,  0,  0,   1,  0,  0,  0, 1,
X   /*  tech  carg  bay  dest guns prim sec fuelcap  crw arm  cst mt jp ld sw sp dm  bd  cn mod las cew clk god prg port rep pay dock*/
X/*mir*/ 100, 200,    0,  10,   1,   1,  0,    20,    5,  0, 100,  0, 0, 0, 0, 2, 75, 20,  0, 0,  0,  0,  0,  0,   1,  0,  1,  1, 1,
X/*Stc*/  50,   0,    0,   0,   0,   0,  0,    20,    2,  0,  20,  1, 1, 1, 0, 4,  0,  8,  0, 1,  0,  0,  0,  0,   1,  0,  0,  1, 1,
X/*Tsc*/   5,   0,    0,   0,   0,   0,  0,     0,    2,  0,   2,  0, 0, 1, 0, 0,  0,  1,  0, 0,  0,  0,  0,  0,   1,  0,  1,  0, 0,
X/*T-R*/ 200,   0,    0,   0,   0,   0,  0,  1000,    5,  0,  20,  1, 0, 1, 1, 2,  0,  1,  0, 0,  0,  0,  0,  0,   0,  0,  1,  0, 1,
X/*APr*/  80,   0,    0,   0,   0,   0,  0,   200,   10,  1,  20,  0, 0, 1, 1, 0,  0,  1,  0, 0,  0,  0,  0,  0,   1,  0,  1,  0, 0,
X/* CD*/  40,   0,    0,   0,   0,   0,  0,     1,    0,  0,  10,  0, 0, 1, 1, 1,  0,  1,  0, 0,  0,  0,  0,  0,   1,  0,  1,  0, 1,
X/*Grn*/  40,   0,    0,   0,   0,   0,  0,     1,    0,  0,  10,  0, 0, 1, 0, 1,  0,  1,  0, 0,  0,  0,  0,  0,   1,  0,  1,  0, 1,
X/*Gov*/   0, 500,    0, 100,  10,   1,  0,  1000,   10, 20, 500,  0, 0, 1, 0, 0, 75, 17,  0, 0,  0,  0,  0,  0,   1,  1,  1,  0, 0,
X/*OMCL*/350,  25,    0,   0,   0,   0,  0,   100,    2,  1,  50,  0, 0, 1, 1, 4,  0, 17,  0, 0,  0,  0,  0,  0,   0,  0,  0,  0, 1,
X/*TWC*/   0,   0,    0,   0,   0,   0,  0,    20,    0,  0,   5,  0, 0, 1, 0, 4,  0,  1,  0, 0,  0,  0,  0,  0,   1,  0,  0,  0, 1,
X/*Prb*/ 150,   0,    0,   0,   0,   0,  0,    20,    0,  0,  10,  0, 0, 1, 0, 9,  0, 19,  0, 0,  0,  0,  0,  0,   1,  0,  0,  0, 1,
X   /*  tech  carg  bay  dest guns prim sec fuelcap  crw arm  cst mt jp ld sw sp dm  bd  cn mod las cew clk god prg port rep pay dock*/
X/*GRL */100,  50,    0, 120,  20,   1,  0,     0,   40,  3,  30,  0, 0, 1, 1, 0, 75,  1,  0, 1,  0,  1,  0,  0,   1,  0,  1,  1, 1,
X/*Fac*/   0,  50,    0,   0,   0,   0,  0,     0,   20,  0,  20,  0, 0, 1, 1, 0, 75, 17,  8, 0,  0,  0,  0,  0,   1,  0,  1,  1, 0,
X/*TFD*/  50,  40,    5,   0,   0,   0,  0,   200,   20,  1,  20,  1, 0, 1, 1, 4,  0, 17,  0, 1,  0,  0,  0,  0,   1,  0,  1,  1, 1,
X/*TD */ 200,1000,    0,1000,   0,   0,  0,  1000,   100,  0, 300, 0, 0, 1, 1, 0, 50,  1,  0, 0,  0,  0,  0,  0,   1,  0,  1,  0, 0,
X/*Mis*/  50,   0,    0,  10,   0,   0,  0,     5,     0,  0,   5, 0, 0, 0, 1, 6,  0,  8,  0, 1,  0,  0,  0,  0,   1,  0,  0,  0, 1,
X/*PDN*/ 200,  50,    0, 500,  20,   3,  0,     0,    50, 10, 100, 0, 0, 1, 1, 0, 75,  1,  0, 1,  0,  0,  0,  0,   1,  0,  1,  1, 0,
X   /*  tech  carg  bay  dest guns prim sec fuelcap  crw arm  cst mt jp ld sw sp dm  bd  cn mod las cew clk god prg port rep pay dock*/
X/*Qua*/   0,   0,    0,   0,  0,   0,  0,   200,    50,  1,  10,  0, 0, 1, 1, 0,  0,  1,  0, 1,  0,  0,  0,  0,   1,  0,  1,  1, 0,
X/*Plo*/   5,   0,    0,   0,  0,   0,  0,   200,    10,  1,  10,  0, 0, 1, 1, 0,  0,  1,  0, 1,  0,  0,  0,  0,   1,  0,  0,  0, 1,
X/*Dom*/  10, 100,    0,   0,  0,   0,  0,     0,    20,  1,  10,  0, 0, 1, 1, 0,  0,  1,  0, 1,  0,  0,  0,  0,   1,  0,  1,  0, 1,
X/*Wea*/   0, 500,    0,   0,  0,   0,  0,   500,    20,  5,  20,  0, 0, 1, 0, 0, 75, 17,  0, 0,  0,  0,  0,  0,   1,  0,  1,  0, 1,
X/*Port*/  0,   0,    0,   0,  0,   0,  0,     0,   100,  3,  50,  0, 0, 1, 0, 0, 75,  1,  0, 1,  0,  0,  0,  0,   1,  1,  1,  1, 1,
X/*ABM*/ 100,   5,    0,  50,  5,   1,  0,     0,     5,  5,  50,  0, 0, 1, 1, 0, 50,  1,  0, 1,  0,  0,  0,  0,   1,  0,  1,  1, 0,
X   /*  tech  carg  bay  dest guns prim sec fuelcap  crw arm  cst mt jp ld sw sp dm  bd  cn mod las cew clk god prg port rep pay dock*/
X/*AFV*/  50,   5,    0,  20,  2,   1,  0,    20,     1,  2,  20,  0, 0, 0, 0, 0,  0,  8,  0, 1,  0,  0,  0,  0,   1,  0,  1,  1, 1,
X/*Bun*/  10, 100,   20, 100,  0,   0,  0,   100,   100, 15, 100,  0, 0, 0, 0, 0, 50,  1,  0, 1,  0,  0,  0,  0,   1,  0,  1,  1, 0,
X/*Lnd*/ 150, 100,   10, 200, 10,   3,  0,   100,   500,  7,  50,  1, 1, 1, 0, 2, 50,  8,  0, 1,  0,  0,  0,  0,   1,  0,  1,  1, 0, 
X/*Swp*/ 100,  25,    2,  80,  8,   1,  1,    80,     8,  3,  23,  1, 1, 1, 0, 5, 50,  8,  2, 1,  1,  1,  1,  0,   1,  0,  0,  0, 1
X};
X
Xchar *Shipnames[NUMSTYPES] = {
X   "Spore pod",
X   "Shuttle",
X   "Carrier",
X   "Dreadnaught",
X   "Battleship",
X   "Interceptor",
X   "Cruiser",
X   "Destroyer",
X   "Fighter Group",
X   "Explorer",
X   "Habitat",
X   "Station",
X   "Ob Asst Pltfrm",
X   "Cargo Ship",
X   "Tanker",
X   "Space Mine",
X   "Space Mirror",
X   "Space Telescope",
X   "Ground Telescope",
X   "* T-R beam",
X   "Atmosph Processor",
X   "Dust Canister",
X   "Greenhouse Gases",
X   "Govrnmnt. Center",
X   "Mind Control Lsr",
X   "Tox Waste Canistr",
X   "Space Probe",
X   "Gamma Ray Laser",
X   "Factory",
X   "Terraform Device",
X   "AVPM Transporter",
X   "Missile",
X   "Planet Def Net",
X   "Quarry",
X   "Space Plow",
X   "Dome",
X   "Weapons Plant",
X   "Space Port",
X   "ABM Battery",
X   "Mech",
X   "Bunker",
X   "Lander",
X   "Mine Sweeper"
X   };
END_OF_FILE
if test 9773 -ne `wc -c <'hdrs/shipdata.h'`; then
    echo shar: \"'hdrs/shipdata.h'\" unpacked with wrong size!
fi
# end of 'hdrs/shipdata.h'
fi
if test -f 'hdrs/ships.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdrs/ships.h'\"
else
echo shar: Extracting \"'hdrs/ships.h'\" \(10183 characters\)
sed "s/^X//" >'hdrs/ships.h' <<'END_OF_FILE'
X#ident  "@(#)ships.h	1.4 1/19/93 "
X
X#include "config.h"
X
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, 
X * smq@ucscb.ucsc.edu, mods by people in GB.c, enroll.dat.
X * Restrictions in GB.c.
X */
X#define LIGHT		1
X#define MEDIUM		2
X#define HEAVY		3
X#define NONE		0
X#define PRIMARY		1
X#define SECONDARY	2
X
X#define STYPE_POD	0
X#define STYPE_SHUTTLE 	1
X#define STYPE_CARRIER   2
X#define STYPE_DREADNT	3
X#define STYPE_BATTLE 	4
X#define STYPE_INTCPT	5
X#define STYPE_CRUISER	6
X#define STYPE_DESTROYER 7
X#define STYPE_FIGHTER 	8
X#define STYPE_EXPLORER 	9
X#define STYPE_HABITAT 	10
X#define STYPE_STATION	11
X#define STYPE_OAP	12
X#define STYPE_CARGO 	13
X#define STYPE_TANKER 	14
X#define STYPE_MINE	15
X#define STYPE_MIRROR	16
X#define OTYPE_STELE	17
X#define OTYPE_GTELE	18
X#define OTYPE_TRACT 19	
X#define OTYPE_AP	20
X#define OTYPE_CANIST	21
X#define OTYPE_GREEN	22
X#define OTYPE_GOV	23
X#define OTYPE_OMCL	24
X#define OTYPE_TOXWC	25
X#define OTYPE_PROBE	26
X#define OTYPE_GR	27
X#define OTYPE_FACTORY	28
X#define OTYPE_TERRA	29
X#define OTYPE_TRANSDEV	30
X#define STYPE_MISSILE	31
X#define OTYPE_PLANDEF	32
X#define OTYPE_QUARRY	33
X#define OTYPE_PLOW	34
X#define OTYPE_DOME    	35
X#define OTYPE_WPLANT	36
X#define OTYPE_PORT	37
X#define OTYPE_ABM	38
X#define OTYPE_AFV	39
X#define OTYPE_BUNKER	40
X#define STYPE_LANDER	41
X#define STYPE_SWEEPER   42
X
X#define ABIL_TECH 	0
X#define ABIL_CARGO	1
X#define ABIL_HANGER	2
X#define ABIL_DESTCAP 	3
X#define ABIL_GUNS 	4
X#define ABIL_PRIMARY	5
X#define ABIL_SECONDARY	6
X#define ABIL_FUELCAP 	7
X#define ABIL_MAXCREW 	8
X#define ABIL_ARMOR 	9
X#define ABIL_COST 	10
X#define ABIL_MOUNT	11
X#define ABIL_JUMP	12
X#define ABIL_CANLAND	13
X#define ABIL_HASSWITCH	14
X#define ABIL_SPEED	15
X#define ABIL_DAMAGE	16
X#define ABIL_BUILD	17
X#define ABIL_CONSTRUCT	18
X#define ABIL_MOD	19
X#define ABIL_LASER	20
X#define ABIL_CEW	21
X#define ABIL_CLOAK	22
X#define ABIL_GOD	23	/* only diety can build these objects */
X#define ABIL_PROGRAMMED 24
X#define ABIL_PORT	25
X#define ABIL_REPAIR	26
X#define ABIL_MAINTAIN	27
X#define ABIL_CANDOCK    28  /* allows ship to be docked with another -jpd- */
X
X#define NUMSTYPES 	(STYPE_SWEEPER+1)
X#define NUMABILS 	(ABIL_CANDOCK+1)
X
X#define SHIP_NAMESIZE	18
X
X
X
Xtypedef struct ship shiptype;
Xtypedef struct place placetype;
X
X
Xstruct ship {
X    unsigned short number;	/* ship knows its own number */
X    unsigned char owner;  	/* owner of ship */
X    unsigned char governor;     /* subordinate that controls the ship */
X    char name[SHIP_NAMESIZE];	    /* name of ship (optional) */
X    char class[SHIP_NAMESIZE];	    /* class of ship - designated by players */
X
X    unsigned char race;		/* race type - used when you gain alien
X				   ships during revolts and whatnot - usually
X				   equal to owner */
X    double xpos;
X    double ypos;
X    double fuel;
X    double mass;
X    unsigned char land_x, land_y;
X
X    unsigned short destshipno;		/* destination ship # */
X    unsigned short nextship;		/* next ship in linked list */
X    unsigned short ships;		/* ships landed on it */
X
X    unsigned char armor;
X    unsigned short size;
X
X    unsigned short max_crew;
X    unsigned short max_resource;
X    unsigned short max_destruct;
X    unsigned short max_fuel;
X    unsigned short max_speed;
X    unsigned short build_type;	/* for factories - type of ship it makes */
X    unsigned short build_cost;
X
X    double base_mass;
X    double tech;		/* engineering technology rating */
X    double complexity;	/* complexity rating */
X    
X    unsigned short destruct;	 	/* stuff it's carrying */
X    unsigned short resource;
X    unsigned short popn;			/* crew */
X    unsigned short troops;			/* marines */
X    unsigned short crystals;
X
X    /* special ship functions (10 bytes) */
X    union {
X    	struct {		/* if the ship is a Space Mirror */
X	    unsigned short shipno;	/* aimed at what ship */
X	    unsigned char snum;    	/* aimed at what star */
X	    char intensity;		/* intensity of aiming */
X	    unsigned char pnum;  	/* aimed at what planet */
X	    unsigned char level;	/* aimed at what level */
X	    unsigned char dummy[4]; 	/* unused bytes */
X	} aimed_at;
X	struct {	/* spore pods */
X	    unsigned char decay;
X	    unsigned char temperature;
X	    unsigned char dummy[8];
X	} pod;
X	struct {	/* dust canisters, greenhouse gases */
X	    unsigned char count;
X	    unsigned char dummy[9];
X	} timer;
X	struct {	/* missiles */
X	    unsigned char x;
X	    unsigned char y;
X	    unsigned char scatter;
X	    unsigned char dummy[7];
X	} impact;
X	struct {	/* mines */
X	    unsigned short radius;
X	    unsigned char dummy[8];
X	} trigger;
X	struct {	/* terraformers */
X	    unsigned char index;
X	    unsigned char dummy[9];
X	} terraform;
X	struct {	/* AVPM */
X	    unsigned short target;
X	    unsigned char dummy[8];
X	} transport;
X	struct {	/* toxic waste containers */
X	    unsigned char toxic;
X	    unsigned char dummy[9];
X	} waste;
X    } special;
X    
X    short who_killed;	/* who killed the ship */
X
X    struct {
X	unsigned on : 1;    /* toggles navigate mode */
X	unsigned speed : 4; /* speed for navigate command */
X	unsigned turns : 15;/* number turns left in maneuver */
X	unsigned bearing : 9; /* course */
X	unsigned dummy : 3;
X    } navigate;
X	
X    struct {
X	double maxrng;	       /* maximum range for autoshoot */
X	unsigned on	 :  1; /* toggle on/off */
X	unsigned planet  :  1; /* planet defender */
X	unsigned self	 :  1; /* retaliate if attacked */
X	unsigned evade	 :  1; /* evasive action */
X	unsigned ship	 : 14; /* ship it is protecting */
X	unsigned dummy	 :  6;
X    } protect;
X
X
X/* special systems */
X    unsigned char mount;      /* has a crystal mount */
X    struct {
X	unsigned char charge;
X	unsigned ready : 1;
X	unsigned on : 1;
X	unsigned has : 1;
X	unsigned dummy : 5;
X    } hyper_drive;
X    unsigned char cew;	      	/* CEW strength */
X    unsigned short cew_range;	/* CEW (confined-energy-weapon) range */
X    unsigned char cloak;       	/* has cloaking device */
X    unsigned char laser;	/* has a laser */
X    unsigned char focus;	/* focused laser mode */
X    unsigned char fire_laser;	/* retaliation strength for lasers */
X    
X    unsigned char storbits;	/* what star # orbits */
X    unsigned char deststar;	/* destination star */
X    unsigned char destpnum;	/* destination planet */
X    unsigned char pnumorbits;	/* # of planet if orbiting */
X    unsigned char whatdest;	/* where going (same as Dir) */
X    unsigned char whatorbits;	/* where orbited (same as Dir) */
X
X    unsigned char damage;	/* amt of damage */
X    unsigned char rad;		/* radiation level */
X    unsigned char retaliate;
X    unsigned short target;
X    
X    unsigned char type;		/* what type ship is */
X    unsigned char speed;       	/* what speed to travel at 0-9 */
X
X    unsigned active: 1;	       	/* tells whether the ship is active */
X    unsigned alive : 1;		/* ship is alive */
X    unsigned mode : 1;
X    unsigned bombard : 1;	/* bombard planet we're orbiting */
X    unsigned mounted : 1;	/* has a crystal mounted */
X    unsigned cloaked : 1;	/* is cloaked ship */
X    unsigned sheep : 1;		/* is under influence of mind control */
X    unsigned docked : 1;	/* is landed on a planet or docked */
X    unsigned notified : 1; 	/* has been notified of something */
X    unsigned examined : 1;	/* has been examined */
X    unsigned on : 1;		/* on or off */
X    unsigned autoscrap : 1; /* Domes and quarries autoscrap when done */
X    unsigned nodock : 1;    /* can be docked/loaded on another ship */
X    unsigned dummy3 : 3;
X
X
X	unsigned int threshload[TH_CRYSTALS+1]; /* autoload r, d, f, x */
X
X    unsigned char merchant;	/* this contains the route number */
X    unsigned char guns;		/* current gun system which is active */
X    unsigned char primary;	/* describe primary gun system */
X    unsigned char primtype;
X    unsigned char secondary;	/* describe secondary guns */
X    unsigned char sectype;
X
X    unsigned short hanger;	/* amount of hanger space used */
X    unsigned short max_hanger;  /* total hanger space */
X};
X
Xstruct place {		/* used in function return for finding place */
X    unsigned char snum;
X    unsigned char pnum;
X    unsigned short shipno;
X    shiptype *shipptr;
X    unsigned char level;	/* .level: same as Dir */
X    unsigned char err;		/* if error */
X};
X
X
X /* can takeoff & land, is mobile, etc. */
X#define speed_rating(s) ((s)->max_speed)
X
X /* has an on/off switch */
X#define has_switch(s) (Shipdata[(s)->type][ABIL_HASSWITCH])
X
X /* can bombard planets */
X#define can_bombard(s) \
X	(Shipdata[(s)->type][ABIL_GUNS] && ((s)->type != STYPE_MINE))
X
X/* can navigate */
X#define can_navigate(s) (Shipdata[(s)->type][ABIL_SPEED] > 0 && (s)->type != OTYPE_TERRA)
X
X /* can aim at things. */
X#define can_aim(s) ((s)->type>=STYPE_MIRROR && (s)->type<=OTYPE_TRACT)
X
X/* macros to get ship stats */
X#define Armor(s) ( ((s)->type==OTYPE_FACTORY) ? Shipdata[(s)->type][ABIL_ARMOR] : (s)->armor*(100-(s)->damage)/100)
X#define Guns(s) ( ((s)->guns==NONE) ? 0 : ((s)->guns==PRIMARY ? (s)->primary : (s)->secondary))
X#define Max_crew(s) ( ((s)->type==OTYPE_FACTORY) ? Shipdata[(s)->type][ABIL_MAXCREW] - (s)->troops : (s)->max_crew - (s)->troops)
X#define Max_mil(s) ( ((s)->type==OTYPE_FACTORY) ? Shipdata[(s)->type][ABIL_MAXCREW] - (s)->popn : (s)->max_crew - (s)->popn)
X#define Max_resource(s) ( ((s)->type==OTYPE_FACTORY) ? Shipdata[(s)->type][ABIL_CARGO] : (s)->max_resource)
X#define Max_crystals(s) (127)
X#define Max_fuel(s) ( ((s)->type==OTYPE_FACTORY) ? Shipdata[(s)->type][ABIL_FUELCAP] : (s)->max_fuel)
X#define Max_destruct(s) ( ((s)->type==OTYPE_FACTORY) ? Shipdata[(s)->type][ABIL_DESTCAP] : (s)->max_destruct)
X#define Max_speed(s) ( ((s)->type==OTYPE_FACTORY) ? Shipdata[(s)->type][ABIL_SPEED] : (s)->max_speed)
X#define Cost(s) ( ((s)->type==OTYPE_FACTORY) ? 2*(s)->build_cost*(s)->on + Shipdata[(s)->type][ABIL_COST ] : (s)->build_cost)
X#define Mass(s) ((s)->mass)
X#define Sight(s) ( ((s)->type==OTYPE_PROBE) || (s)->popn)
X#define Retaliate(s) ( (s)->retaliate)
X#define Size(s) ((s)->size)
X#define Body(s) ((s)->size-(s)->max_hanger)
X#define Hanger(s) ((s)->max_hanger - (s)->hanger)
X#define Repair(s) ( ((s)->type==OTYPE_FACTORY) ? (s)->on : Max_crew(s))
X
Xextern long Shipdata[NUMSTYPES][NUMABILS];
Xextern char Shipltrs[];
Xextern char *Shipnames[];
X
XEXTERN shiptype **ships;
X
X
END_OF_FILE
if test 10183 -ne `wc -c <'hdrs/ships.h'`; then
    echo shar: \"'hdrs/ships.h'\" unpacked with wrong size!
fi
# end of 'hdrs/ships.h'
fi
if test -f 'hdrs/vars.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdrs/vars.h'\"
else
echo shar: Extracting \"'hdrs/vars.h'\" \(10522 characters\)
sed "s/^X//" >'hdrs/vars.h' <<'END_OF_FILE'
X#ident  "@(#)vars.h	1.4 1/6/93 "
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, 
X * smq@ucscb.ucsc.edu, mods by people in GB.c, enroll.dat.
X * Restrictions in GB.c.
X * vars.h --
X *  main bunch of variables 
X */
X
X#include "files.h"
X#include "tweakables.h"
X#include "config.h"
X#include <sys/types.h>
X#include <sys/file.h>
X#include <stdio.h>
X
Xunsigned long segments;	/* number of movement segments (global variable) */
X 
X#define MAX_ROUTES 4	/* Shipping routes - DON'T change this */
X						/* unless you know what you are doing */
X
X#define TH_RESOURCE 0   /* THRESHLOADING STUFF */
X#define TH_DESTRUCT 1
X#define TH_FUEL 2
X#define TH_CRYSTALS 3
X
X
X#define LEVEL_UNIV 0
X#define LEVEL_STAR 1
X#define LEVEL_PLAN 2
X#define LEVEL_SHIP 3
X
X#define MAXPLAYERS 64
X#define MAXSTRLEN 2047
X#define HUGESTRLEN (2*MAXSTRLEN+1)
X#define SMALLSTR 31
X
X#define ANN		0
X#define BROADCAST	1
X#define SHOUT		2
X#define THINK		3
X
X#define COMM_CHANNEL1 	1
X#define COMM_CHANNEL2 	2
X#define COMM_CHANNEL3 	3
X
X#define DEFAULT_CHANNEL_MASK 10
X#define COMM_DEF_CHANNEL1 	11
X#define COMM_DEF_CHANNEL2 	12
X#define COMM_DEF_CHANNEL3 	13
X
X/* Used for the log() function.  Determine if we look at errno
X * or just use the default errno which is "log"
X */
X#define NOERRNO		0  
X#define WANTERRNO   1
X
X#define ERRORLOG    0
X#define USERLOG     1
X#define UPDATELOG   2
X
X#define UPDATE_START 	1
X#define UPDATE_END 		2
X#define SEGMENT_START	3
X#define SEGMENT_END 	4
X#define RESET_START		5
X#define RESET_END  		6
X
X
Xtypedef char hugestr[HUGESTRLEN];
X
Xlong random();
X
Xtypedef struct sector sectortype;
Xtypedef struct planet planettype;
Xtypedef struct star startype;
Xtypedef struct commod commodtype;
X
Xstruct plinfo {				/* planetary stockpiles */
X      unsigned short fuel;		/* fuel for powering things */
X      unsigned short destruct;   	/* destructive potential */
X      unsigned short resource;		/* resources in storage */
X      unsigned long popn;
X      unsigned long troops;
X      unsigned short crystals;
X
X      unsigned short prod_res;	/* shows last update production */
X      unsigned short prod_fuel;
X      unsigned short prod_dest;
X      unsigned short prod_crystals;
X      unsigned long prod_money;
X      double prod_tech;
X
X      unsigned short tech_invest;
X      unsigned short numsectsowned;
X
X      unsigned char comread;		/* combat readiness (mobilization)*/
X      unsigned char mob_set;		/* mobilization target */
X      unsigned char tox_thresh;		/* min to build a waste can */
X
X      unsigned char explored;
X      unsigned char autorep;
X      unsigned char tax;	/* tax rate */
X      unsigned char newtax;	/* new tax rate (after update) */
X      unsigned char guns;	/* number of planet guns (mob/5) */
X
X      /* merchant shipping parameters */
X      struct {
X	  unsigned char set;	/* does the planet have orders? */
X	  unsigned char dest_star;	/* star that ship has to go to next */
X	  unsigned char dest_planet;	/* planet destination */
X	  unsigned char load;	/* bit-field commodities to be loaded there */
X	  unsigned char unload;	/* unloaded commodities */
X	  unsigned char x,y;	/* location that ship has to land on */
X      } route[MAX_ROUTES];  /* i am allowing up to four routes per planet */
X
X      unsigned long mob_points;
X      double est_production;	/* estimated production */
X      unsigned long dummy[3];
X};
X
X#define M_FUEL		0x1
X#define M_DESTRUCT 	0x2
X#define M_RESOURCES	0x4
X#define M_CRYSTALS	0x8
X#define Fuel(x)		((x) & M_FUEL)
X#define Destruct(x)	((x) & M_DESTRUCT)
X#define Resources(x)	((x) & M_RESOURCES)
X#define Crystals(x)	((x) & M_CRYSTALS)
X
Xstruct commod {
X    char owner;
X    char governor;
X    char type;
X    unsigned short amount;
X    unsigned char dummy;
X    unsigned char deliver; /* whether the lot is ready for shipping or not */
X    unsigned long bid;
X    unsigned char bidder;
X    unsigned char bidder_gov;
X    unsigned char star_from;	/* where the stuff originated from */
X    unsigned char planet_from;
X    unsigned char star_to;	/* where it goes to */
X    unsigned char planet_to;
X};
X
Xstruct sector {
X    unsigned char eff;		/* efficiency (0-100) */
X    unsigned char fert;		/* max popn is proportional to this */
X    unsigned char mobilization;	/* percent popn is mobilized for war */
X    unsigned char crystals;
X    unsigned short resource;
X    
X    unsigned short popn;
X    unsigned short troops;	/* troops (additional combat value) */
X
X    unsigned char owner;	/* owner of place */
X    unsigned char race;		/* race type occupying sector
X				   (usually==owner) - makes things more
X				   realistic when alien races revolt and
X				   you gain control of them! */
X    unsigned char type;		/* underlying sector geology */
X    unsigned char condition;	/* environmental effects */
X    unsigned long dummy2;
X};
X
X
Xstruct planet {
X    int sectormappos;		/* file posn for sector map */
X
X    double xpos, ypos;		/* x,y relative to orbit */
X    unsigned short ships;       /* first ship in orbit (to be changed) */
X    unsigned char Maxx, Maxy;		/* size of map */
X
X    struct plinfo info[MAXPLAYERS]; 	/* player info */
X    short conditions[TOXIC+1];  /* atmospheric conditions for terraforming */
X
X    unsigned long popn;
X    unsigned long troops;
X    unsigned long maxpopn;			/* maximum population */
X    unsigned long total_resources;
X	
X    unsigned char slaved_to;
X    unsigned char type;		/* what type planet is */
X    unsigned char expltimer;	/* timer for explorations */
X
X    unsigned char explored;
X
X    unsigned long dummy[2];
X};
X
Xstruct star {
X    unsigned short ships;	/* 1st ship in orbit */
X    char name[NAMESIZE];	/* name of star */
X    char governor[MAXPLAYERS];	/* which subordinate maintains the system */
X    unsigned char AP[MAXPLAYERS];	/* action pts alotted */
X    unsigned long explored[2]; 	/* who's been here 64 bits*/
X    unsigned long inhabited[2];	/* who lives here now 64 bits*/
X    double xpos,ypos;
X
X    unsigned char numplanets;		/* # of planets in star system */
X    char pnames[MAXPLANETS][NAMESIZE]; 	/* names of planets */
X    unsigned long planetpos[MAXPLANETS];/* file posns of planets */
X
X    unsigned char stability;	/* how close to nova it is */
X    unsigned char nova_stage;	/* stage of nova */
X    unsigned char temperature;  /* factor which expresses how hot the star is*/
X    double gravity;		/* attraction of star in "Standards". */
X
X    long dummy[2];		/* dummy bits for development */
X};
X
X
X
X	/* this data will all be read at once */
Xstruct stardata {
X    unsigned short numstars;		/* # of stars */
X    unsigned short ships;		/* 1st ship in orbit */
X    unsigned char  AP[MAXPLAYERS];	/* Action pts for each player */
X    unsigned long dummy[2];
X};
X
XEXTERN struct stardata Sdata;
X
Xstruct directory {
X    unsigned char level;	/* what directory level */
X    unsigned char snum;		/* what star system obj # (level=0) */
X    unsigned char pnum;		/* number of planet */
X    unsigned short shipno;	/* # of ship */
X    char prompt[3*NAMESIZE+5];	/* just to be safe */
X    double lastx[2], lasty[2], zoom[2];	/* last coords for zoom */
X};
X
Xstruct vic {
X  unsigned char racenum;
X  char   name[RNAMESIZE];
X  unsigned long no_count;
X  char	sleep;
X  double tech;
X  int Thing;
X  int IQ;
X  long rawscore;
X  long login;
X};
X
Xstruct text_block {
X    int      nchars;
X    struct text_block  *nxt;
X    char      *start;
X    char      *buf;
X};
X
Xstruct text_queue {
X    struct text_block *head;
X    struct text_block **tail;
X};
X
X
Xstruct descriptor_data {
X    int descriptor;
X    int connected;
X    int God;        /* deity status */
X    int Playernum;  /* race */
X    int Governor;       /* governor/subcommander */
X    char *output_prefix;
X    char *output_suffix;
X    int output_size;
X    struct text_queue output;
X    struct text_queue input;
X    char *raw_input;
X    char *raw_input_at;
X    long last_time;
X    int quota;
X    struct descriptor_data *next;
X    struct descriptor_data **prev;
X};
X
Xstruct descriptor_data *descriptor_list;
X
X
X
XEXTERN struct directory Dir[MAXPLAYERS][MAXGOVERNORS+1];
X
XEXTERN sectortype Smap[(MAX_X+1)*(MAX_Y+1) + 1];
X
Xextern char *malloc();
X
XEXTERN unsigned char Nuked[MAXPLAYERS];
XEXTERN unsigned long StarsInhab[NUMSTARS];
XEXTERN unsigned long StarsExpl[NUMSTARS];
XEXTERN startype *Stars[NUMSTARS];
XEXTERN unsigned short Sdatanumships[MAXPLAYERS];
XEXTERN unsigned long Sdatapopns[MAXPLAYERS];
XEXTERN unsigned short starnumships[NUMSTARS][MAXPLAYERS];
XEXTERN unsigned long starpopns[NUMSTARS][MAXPLAYERS];
X
XEXTERN unsigned long tot_resdep, prod_eff, prod_res[MAXPLAYERS];
XEXTERN unsigned long prod_fuel[MAXPLAYERS], prod_destruct[MAXPLAYERS];
XEXTERN unsigned long prod_crystals[MAXPLAYERS], prod_money[MAXPLAYERS];
XEXTERN unsigned long tot_captured, prod_mob;
XEXTERN unsigned long avg_mob[MAXPLAYERS];
XEXTERN unsigned char sects_gained[MAXPLAYERS], sects_lost[MAXPLAYERS];
XEXTERN unsigned char Claims;
XEXTERN unsigned char adr;
XEXTERN char junk[2][256];
X
XEXTERN planettype *planets[NUMSTARS][MAXPLANETS];
XEXTERN unsigned char ground_assaults[MAXPLAYERS][MAXPLAYERS][NUMSTARS];
XEXTERN unsigned long inhabited[NUMSTARS][2];
XEXTERN double Compat[MAXPLAYERS];
XEXTERN unsigned long Num_races, Num_ships, Num_commods;
XEXTERN unsigned long Planet_count;
XEXTERN unsigned long newslength[4];
XEXTERN char args[MAXARGS][COMMANDSIZE];
XEXTERN int argn;
X
XEXTERN long    next_update_time;   /* When will next update be... approximately */
XEXTERN long    next_segment_time;  /* When will next segment be... approximately */
XEXTERN long    last_update_time;
XEXTERN long    last_segment_time;
XEXTERN int     update_time;        /* Interval between updates */
X
XEXTERN int nsegments_done;     /* How many movements have we done so far? */
XEXTERN int nupdates_done;          /* number of updates so far */
X
XEXTERN long clk;
X
X
X
X/* bit routines stolen from UNIX <sys/param.h> */
X#define setbit(a, i)	((a)[(i)/32] |= ((i)<32 ? 1<<(i) : 1<<(i)-32))
X#define clrbit(a, i)	((a)[(i)/32] &= ~((i)<32 ? 1<<(i) : 1<<(i)-32))
X#define isset(a, i)	((a)[(i)/32] & ((i)<32 ? 1<<(i) : 1<<(i)-32))
X#define isclr(a, i)	(!isset((a), (i)))
X
X#ifdef DEBUG		/* for debugging option */
X#define malloc(s)	DEBUGmalloc(s, __FILE__, __LINE__)
X#define free(s)		DEBUGfree(s)
X#define realloc(p,s)	DEBUGrealloc(p, s, __FILE__, __LINE__)
X
X#define getrace(a,b,c)	DEBUGgetrace(a,b,c,__FILE__,__LINE__)
X#define getstar(a,b,c)	DEBUGgetstar(a,b,c,__FILE__,__LINE__)
X#define getplanet(a,b,c)	DEBUGgetplanet(a,b,c,__FILE__,__LINE__)
X#define getship(a,b,c)	DEBUGgetship(a,b,c,__FILE__,__LINE__)
X#define getcommod(a,b,c)	DEBUGgetcommod(a,b,c,__FILE__,__LINE__)
X#endif
X
X#define success(x) (int_rand(1,100) <= (x))
END_OF_FILE
if test 10522 -ne `wc -c <'hdrs/vars.h'`; then
    echo shar: \"'hdrs/vars.h'\" unpacked with wrong size!
fi
# end of 'hdrs/vars.h'
fi
if test -f 'user/cs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/cs.c'\"
else
echo shar: Extracting \"'user/cs.c'\" \(9593 characters\)
sed "s/^X//" >'user/cs.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h. cs.c -- change scope (directory)
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X
Xvoid            center(int, int, int);
Xvoid            do_prompt(int, int);
Xvoid            cs(int, int, int);
X#include "proto.h"
X
Xvoid 
Xcenter(int Playernum, int Governor, int APcount)
X{
X	placetype       where;
X
X	where = Getplace(Playernum, Governor, args[1], 1);
X
X	if (where.err) {
X		sprintf(buf, "cs: bad scope.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	} else if (where.level == LEVEL_SHIP) {
X		notify(Playernum, Governor, "CHEATER!!!\n");
X		return;
X	}
X	Dir[Playernum - 1][Governor].lastx[1] = Stars[where.snum]->xpos;
X	Dir[Playernum - 1][Governor].lasty[1] = Stars[where.snum]->ypos;
X}
X
Xvoid 
Xdo_prompt(int Playernum, int Governor)
X{
X	shiptype       *s, *s2;
X
X	if (Dir[Playernum - 1][Governor].level == LEVEL_UNIV) {
X		sprintf(Dir[Playernum - 1][Governor].prompt, " ( [%d] / )\n", Sdata.AP[Playernum - 1]);
X	} else if (Dir[Playernum - 1][Governor].level == LEVEL_STAR) {
X		sprintf(Dir[Playernum - 1][Governor].prompt, " ( [%d] /%s )\n",
X		Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1],
X			Stars[Dir[Playernum - 1][Governor].snum]->name);
X	} else if (Dir[Playernum - 1][Governor].level == LEVEL_PLAN) {
X		sprintf(Dir[Playernum - 1][Governor].prompt, " ( [%d] /%s/%s )\n",
X		Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1],
X			Stars[Dir[Playernum - 1][Governor].snum]->name,
X			Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum]);
X	} else if (Dir[Playernum - 1][Governor].level == LEVEL_SHIP) {
X		(void) getship(&s, Dir[Playernum - 1][Governor].shipno);
X		switch (s->whatorbits) {
X		case LEVEL_UNIV:
X			sprintf(Dir[Playernum - 1][Governor].prompt, " ( [%d] /#%d )\n",
X				Sdata.AP[Playernum - 1], Dir[Playernum - 1][Governor].shipno);
X			break;
X		case LEVEL_STAR:
X			sprintf(Dir[Playernum - 1][Governor].prompt, " ( [%d] /%s/#%d )\n",
X				Stars[s->storbits]->AP[Playernum - 1],
X				Stars[s->storbits]->name,
X				Dir[Playernum - 1][Governor].shipno);
X			break;
X		case LEVEL_PLAN:
X			sprintf(Dir[Playernum - 1][Governor].prompt, " ( [%d] /%s/%s/#%d )\n",
X				Stars[s->storbits]->AP[Playernum - 1],
X				Stars[s->storbits]->name,
X				Stars[s->storbits]->pnames[Dir[Playernum - 1][Governor].pnum],
X				Dir[Playernum - 1][Governor].shipno);
X			break;
X			/*
X			 * I put this mess in because of non-functioning
X			 * prompts when you are in a ship within a ship, or
X			 * deeper. I am certain this can be done more
X			 * elegantly (a lot more) but I don't feel like
X			 * trying that right now. right now I want it to
X			 * function. Maarten
X			 */
X		case LEVEL_SHIP:
X			(void) getship(&s2, (int) s->destshipno);
X			switch (s2->whatorbits) {
X			case LEVEL_UNIV:
X				sprintf(Dir[Playernum - 1][Governor].prompt, " ( [%d] /#%d/#%d )\n",
X					Sdata.AP[Playernum - 1], s->destshipno, Dir[Playernum - 1][Governor].shipno);
X				break;
X			case LEVEL_STAR:
X				sprintf(Dir[Playernum - 1][Governor].prompt, " ( [%d] /%s/#%d/#%d )\n",
X				      Stars[s->storbits]->AP[Playernum - 1],
X					Stars[s->storbits]->name,
X					s->destshipno,
X					Dir[Playernum - 1][Governor].shipno);
X				break;
X			case LEVEL_PLAN:
X				sprintf(Dir[Playernum - 1][Governor].prompt, " ( [%d] /%s/%s/#%d/#%d )\n",
X				      Stars[s->storbits]->AP[Playernum - 1],
X					Stars[s->storbits]->name,
X					Stars[s->storbits]->pnames[Dir[Playernum - 1][Governor].pnum],
X					s->destshipno,
X					Dir[Playernum - 1][Governor].shipno);
X				break;
X			case LEVEL_SHIP:
X				while (s2->whatorbits == LEVEL_SHIP) {
X					free(s2);
X					(void) getship(&s2, (int) s2->destshipno);
X				}
X				switch (s2->whatorbits) {
X				case LEVEL_UNIV:
X					sprintf(Dir[Playernum - 1][Governor].prompt, " ( [%d] / /../#%d/#%d )\n",
X						Sdata.AP[Playernum - 1], s->destshipno, Dir[Playernum - 1][Governor].shipno);
X					break;
X				case LEVEL_STAR:
X					sprintf(Dir[Playernum - 1][Governor].prompt, " ( [%d] /%s/ /../#%d/#%d )\n",
X						Stars[s->storbits]->AP[Playernum - 1],
X						Stars[s->storbits]->name,
X						s->destshipno,
X					Dir[Playernum - 1][Governor].shipno);
X					break;
X				case LEVEL_PLAN:
X					sprintf(Dir[Playernum - 1][Governor].prompt, " ( [%d] /%s/%s/ /../#%d/#%d )\n",
X						Stars[s->storbits]->AP[Playernum - 1],
X						Stars[s->storbits]->name,
X						Stars[s->storbits]->pnames[Dir[Playernum - 1][Governor].pnum],
X						s->destshipno,
X					Dir[Playernum - 1][Governor].shipno);
X					break;
X				default:
X					break;
X				}
X				free(s2);
X				break;
X			default:
X				break;
X			}
X		}
X		free(s);
X	}
X}
X
Xvoid 
Xcs(int Playernum, int Governor, int APcount)
X{
X	placetype       where;
X	planettype     *planet;
X	shiptype       *s;
X	racetype       *Race;
X
X	Race = races[Playernum - 1];
X
X	if (argn == 1) {
X		/* chdir to def scope */
X		Dir[Playernum - 1][Governor].level = Race->governor[Governor].deflevel;
X		if ((Dir[Playernum - 1][Governor].snum = Race->governor[Governor].defsystem)
X		    >= Sdata.numstars)
X			Dir[Playernum - 1][Governor].snum = Sdata.numstars - 1;
X		if ((Dir[Playernum - 1][Governor].pnum = Race->governor[Governor].defplanetnum) >= Stars[Dir[Playernum - 1][Governor].snum]->numplanets)
X			Dir[Playernum - 1][Governor].pnum = Stars[Dir[Playernum - 1][Governor].snum]->numplanets - 1;
X		Dir[Playernum - 1][Governor].shipno = 0;
X		Dir[Playernum - 1][Governor].lastx[0] = Dir[Playernum - 1][Governor].lasty[0] = 0.0;
X		Dir[Playernum - 1][Governor].lastx[1] = Stars[Dir[Playernum - 1][Governor].snum]->xpos;
X		Dir[Playernum - 1][Governor].lasty[1] = Stars[Dir[Playernum - 1][Governor].snum]->ypos;
X		return;
X	} else if (argn == 2) {
X		/* chdir to specified scope */
X
X		where = Getplace(Playernum, Governor, args[1], 0);
X
X		if (where.err) {
X			sprintf(buf, "cs: bad scope.\n");
X			notify(Playernum, Governor, buf);
X			Dir[Playernum - 1][Governor].lastx[0] = Dir[Playernum - 1][Governor].lasty[0] = 0.0;
X			return;
X		}
X		/* fix lastx, lasty coordinates */
X
X		switch (Dir[Playernum - 1][Governor].level) {
X		case LEVEL_UNIV:
X			Dir[Playernum - 1][Governor].lastx[0] = Dir[Playernum - 1][Governor].lasty[0] = 0.0;
X			break;
X		case LEVEL_STAR:
X			if (where.level == LEVEL_UNIV) {
X				Dir[Playernum - 1][Governor].lastx[1] = Stars[Dir[Playernum - 1][Governor].snum]->xpos;
X				Dir[Playernum - 1][Governor].lasty[1] = Stars[Dir[Playernum - 1][Governor].snum]->ypos;
X			} else
X				Dir[Playernum - 1][Governor].lastx[0] = Dir[Playernum - 1][Governor].lasty[0] = 0.0;
X			break;
X		case LEVEL_PLAN:
X			getplanet(&planet, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X			if (where.level == LEVEL_STAR && where.snum == Dir[Playernum - 1][Governor].snum) {
X				Dir[Playernum - 1][Governor].lastx[0] = planet->xpos;
X				Dir[Playernum - 1][Governor].lasty[0] = planet->ypos;
X			} else if (where.level == LEVEL_UNIV) {
X				Dir[Playernum - 1][Governor].lastx[1] = Stars[Dir[Playernum - 1][Governor].snum]->xpos + planet->xpos;
X				Dir[Playernum - 1][Governor].lasty[1] = Stars[Dir[Playernum - 1][Governor].snum]->ypos + planet->ypos;
X			} else
X				Dir[Playernum - 1][Governor].lastx[0] = Dir[Playernum - 1][Governor].lasty[0] = 0.0;
X			free(planet);
X			break;
X		case LEVEL_SHIP:
X			(void) getship(&s, Dir[Playernum - 1][Governor].shipno);
X			if (!s->docked) {
X				switch (where.level) {
X				case LEVEL_UNIV:
X					Dir[Playernum - 1][Governor].lastx[1] = s->xpos;
X					Dir[Playernum - 1][Governor].lasty[1] = s->ypos;
X					break;
X				case LEVEL_STAR:
X					if (s->whatorbits >= LEVEL_STAR && s->storbits == where.snum) {
X						/*
X						 * we are going UP from the
X						 * ship.. change last
X						 */
X						Dir[Playernum - 1][Governor].lastx[0] = s->xpos - Stars[s->storbits]->xpos;
X						Dir[Playernum - 1][Governor].lasty[0] = s->ypos - Stars[s->storbits]->ypos;
X					} else
X						Dir[Playernum - 1][Governor].lastx[0] = Dir[Playernum - 1][Governor].lasty[0] = 0.0;
X					break;
X				case LEVEL_PLAN:
X					if (s->whatorbits == LEVEL_PLAN && s->storbits == where.snum
X					    && s->pnumorbits == where.pnum) {
X						/* same */
X						getplanet(&planet, (int) s->storbits, (int) s->pnumorbits);
X						Dir[Playernum - 1][Governor].lastx[0] = s->xpos - Stars[s->storbits]->xpos - planet->xpos;
X						Dir[Playernum - 1][Governor].lasty[0] = s->ypos - Stars[s->storbits]->ypos - planet->ypos;
X						free(planet);
X					} else
X						Dir[Playernum - 1][Governor].lastx[0] = Dir[Playernum - 1][Governor].lasty[0] = 0.0;
X					break;
X				case LEVEL_SHIP:
X					Dir[Playernum - 1][Governor].lastx[0] = Dir[Playernum - 1][Governor].lasty[0] = 0.0;
X					break;
X				default:
X					break;
X				}
X			} else
X				Dir[Playernum - 1][Governor].lastx[0] = Dir[Playernum - 1][Governor].lasty[0] = 0.0;
X			free(s);
X			break;
X		default:
X			break;
X		}
X		Dir[Playernum - 1][Governor].level = where.level;
X		Dir[Playernum - 1][Governor].snum = where.snum;
X		Dir[Playernum - 1][Governor].pnum = where.pnum;
X		Dir[Playernum - 1][Governor].shipno = where.shipno;
X	} else if (argn == 3 && args[1][1] == 'd') {
X		/* make new def scope */
X		where = Getplace(Playernum, Governor, args[2], 0);
X
X		if (!where.err && where.level != LEVEL_SHIP) {
X			Race->governor[Governor].deflevel = where.level;
X			Race->governor[Governor].defsystem = where.snum;
X			Race->governor[Governor].defplanetnum = where.pnum;
X			putrace(Race);
X
X			sprintf(buf, "New home system is %s\n", Dispplace(Playernum, Governor, &where));
X		} else {
X			sprintf(buf, "cs: bad home system.\n");
X		}
X	}
X}
END_OF_FILE
if test 9593 -ne `wc -c <'user/cs.c'`; then
    echo shar: \"'user/cs.c'\" unpacked with wrong size!
fi
# end of 'user/cs.c'
fi
if test -f 'user/declare.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/declare.c'\"
else
echo shar: Extracting \"'user/declare.c'\" \(9628 characters\)
sed "s/^X//" >'user/declare.c' <<'END_OF_FILE'
X/*
X * * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, *
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. * Restrictions in
X * GB_copyright.h. * declare.c -- declare alliance, neutrality, war, the
X * basic thing.
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X#include <signal.h>
X#include <ctype.h>
X
Xvoid            invite(int, int, int, int);
Xvoid            declare(int, int, int);
Xvoid            vote(int, int, int);
Xvoid            show_votes(int, int);
Xvoid            pledge(int, int, int, int);
X
X#include "proto.h"
X
X/* invite people to join your alliance block */
Xvoid 
Xinvite(int Playernum, int Governor, int APcount, int mode)
X{
X	int             n;
X	racetype       *Race, *alien;
X
X	if (Governor) {
X		notify(Playernum, Governor, "Only leaders may invite.\n");
X		return;
X	}
X	if (!(n = GetPlayer(args[1]))) {
X		sprintf(buf, "No such player.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	if (n == Playernum) {
X		notify(Playernum, Governor, "Not needed, you are the leader.\n");
X		return;
X	}
X	Race = races[Playernum - 1];
X	alien = races[n - 1];
X	if (mode) {
X		setbit(Blocks[Playernum - 1].invite, n);
X		sprintf(buf, "%s [%d] has invited you to join %s\n", Race->name,
X			Playernum, Blocks[Playernum - 1].name);
X		warn_race(n, buf);
X		sprintf(buf, "%s [%d] has been invited to join %s [%d]\n",
X		     alien->name, n, Blocks[Playernum - 1].name, Playernum);
X		warn_race(Playernum, buf);
X	} else {
X		clrbit(Blocks[Playernum - 1].invite, n);
X		sprintf(buf, "You have been blackballed from %s [%d]\n",
X			Blocks[Playernum - 1].name, Playernum);
X		warn_race(n, buf);
X		sprintf(buf, "%s [%d] has been blackballed from %s [%d]\n",
X		     alien->name, n, Blocks[Playernum - 1].name, Playernum);
X		warn_race(Playernum, buf);
X	}
X	post(buf, DECLARATION);
X
X	Putblock(Blocks);
X}
X
X/* declare that you wish to be included in the alliance block */
Xvoid 
Xpledge(int Playernum, int Governor, int APcount, int mode)
X{
X	int             n;
X	racetype       *alien, *Race;
X
X	if (Governor) {
X		notify(Playernum, Governor, "Only leaders may pledge.\n");
X		return;
X	}
X	if (!(n = GetPlayer(args[1]))) {
X		sprintf(buf, "No such player.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	if (n == Playernum) {
X		notify(Playernum, Governor, "Not needed, you are the leader.\n");
X		return;
X	}
X	Race = races[Playernum - 1];
X	alien = races[n - 1];
X	if (mode) {
X		setbit(Blocks[n - 1].pledge, Playernum);
X		sprintf(buf, "%s [%d] has pledged %s.\n", Race->name,
X			Playernum, Blocks[n - 1].name);
X		warn_race(n, buf);
X		sprintf(buf, "You have pledged allegiance to %s.\n",
X			Blocks[n - 1].name);
X		warn_race(Playernum, buf);
X
X		switch (int_rand(1, 20)) {
X		case 1:
X			sprintf(buf, "%s [%d] joins the band wagon and pledges allegiance to %s [%d]!\n",
X			      Race->name, Playernum, Blocks[n - 1].name, n);
X			break;
X		default:
X			sprintf(buf, "%s [%d] pledges allegiance to %s [%d].\n",
X			      Race->name, Playernum, Blocks[n - 1].name, n);
X			break;
X		}
X	} else {
X		clrbit(Blocks[n - 1].pledge, Playernum);
X		sprintf(buf, "%s [%d] has quit %s [%d].\n", Race->name,
X			Playernum, Blocks[n - 1].name, n);
X		warn_race(n, buf);
X		sprintf(buf, "You have quit %s\n", Blocks[n - 1].name);
X		warn_race(Playernum, buf);
X
X		switch (int_rand(1, 20)) {
X		case 1:
X			sprintf(buf, "%s [%d] calls %s [%d] a bunch of geeks and QUITS!\n",
X			      Race->name, Playernum, Blocks[n - 1].name, n);
X		default:
X			sprintf(buf, "%s [%d] has QUIT %s [%d]!\n",
X			      Race->name, Playernum, Blocks[n - 1].name, n);
X			break;
X		}
X	}
X
X	post(buf, DECLARATION);
X
X	compute_power_blocks();
X	Putblock(Blocks);
X}
X
Xvoid 
Xdeclare(int Playernum, int Governor, int APcount)
X{
X	int             n, d_mod;
X	racetype       *Race, *alien;
X
X	if (Governor) {
X		notify(Playernum, Governor, "Only leaders may declare.\n");
X		return;
X	}
X	if (!(n = GetPlayer(args[1]))) {
X		sprintf(buf, "No such player.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	/* look in sdata for APs first */
X	/* enufAPs would print something */
X	if ((int) Sdata.AP[Playernum - 1] >= APcount) {
X		deductAPs(Playernum, Governor, APcount, 0, 1);
X		/* otherwise use current star */
X	} else if ((Dir[Playernum - 1][Governor].level == LEVEL_STAR ||
X		    Dir[Playernum - 1][Governor].level == LEVEL_PLAN) &&
X		   enufAP(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1], APcount)) {
X		deductAPs(Playernum, Governor, APcount, Dir[Playernum - 1][Governor].snum, 0);
X	} else {
X		sprintf(buf, "You don't have enough AP's (%d)\n", APcount);
X		notify(Playernum, Governor, buf);
X		return;
X	}
X
X	Race = races[Playernum - 1];
X	alien = races[n - 1];
X
X	switch (*args[2]) {
X	case 'a':
X		setbit(Race->allied, n);
X		clrbit(Race->atwar, n);
X		if (success(5)) {
X			sprintf(buf, "But would you want your sister to marry one?\n");
X			notify(Playernum, Governor, buf);
X		} else {
X			sprintf(buf, "Good for you.\n");
X			notify(Playernum, Governor, buf);
X		}
X		sprintf(buf, " Player #%d (%s) has declared an alliance with you!\n",
X			Playernum, Race->name);
X		warn_race(n, buf);
X		sprintf(buf, "%s [%d] declares ALLIANCE with %s [%d].\n",
X			Race->name, Playernum, alien->name, n);
X		d_mod = 30;
X		if (argn > 3)
X			sscanf(args[3], "%d", &d_mod);
X		d_mod = MAX(d_mod, 30);
X		break;
X	case 'n':
X		clrbit(Race->allied, n);
X		clrbit(Race->atwar, n);
X		sprintf(buf, "Done.\n");
X		notify(Playernum, Governor, buf);
X
X		sprintf(buf, " Player #%d (%s) has declared neutrality with you!\n", Playernum, Race->name);
X		warn_race(n, buf);
X		sprintf(buf, "%s [%d] declares a state of neutrality with %s [%d].\n",
X			Race->name, Playernum, alien->name, n);
X		d_mod = 30;
X		break;
X	case 'w':
X		setbit(Race->atwar, n);
X		clrbit(Race->allied, n);
X		if (success(4)) {
X			sprintf(buf, "Your enemies flaunt their secondary male reproductive glands in your\ngeneral direction.\n");
X			notify(Playernum, Governor, buf);
X		} else {
X			sprintf(buf, "Give 'em hell!\n");
X			notify(Playernum, Governor, buf);
X		}
X		sprintf(buf, " Player #%d (%s) has declared war against you!\n", Playernum, Race->name);
X		warn_race(n, buf);
X		switch (int_rand(1, 5)) {
X		case 1:
X			sprintf(buf, "%s [%d] declares WAR on %s [%d].\n",
X				Race->name, Playernum, alien->name, n);
X			break;
X		case 2:
X			sprintf(buf, "%s [%d] has had enough of %s [%d] and declares WAR!\n",
X				Race->name, Playernum, alien->name, n);
X			break;
X		case 3:
X			sprintf(buf, "%s [%d] decided that it is time to declare WAR on %s [%d]!\n",
X				Race->name, Playernum, alien->name, n);
X			break;
X		case 4:
X			sprintf(buf, "%s [%d] had no choice but to declare WAR against %s [%d]!\n",
X				Race->name, Playernum, alien->name, n);
X			break;
X		case 5:
X			sprintf(buf, "%s [%d] says 'screw it!' and declares WAR on %s [%d]!\n",
X				Race->name, Playernum, alien->name, n);
X			break;
X		default:
X			break;
X		}
X		d_mod = 30;
X		break;
X	default:
X		notify(Playernum, Governor, "I don't understand.\n");
X		return;
X	}
X
X	post(buf, DECLARATION);
X	warn_race(Playernum, buf);
X
X	/* They, of course, learn more about you */
X	alien->translate[Playernum - 1] = MIN(alien->translate[Playernum - 1] + d_mod, 100);
X
X	putrace(alien);
X	putrace(Race);
X}
X
X#ifdef VOTING
Xvoid 
Xvote(int Playernum, int Governor, int APcount)
X{
X	int             i;
X	racetype       *Race;
X	int             check, nvotes, nays, yays;
X
X	Race = races[Playernum - 1];
X
X	if (Race->God) {
X		sprintf(buf, "Your vote doesn't count, however, here is the count.\n");
X		notify(Playernum, Governor, buf);
X		show_votes(Playernum, Governor);
X		return;
X	}
X	if (Race->Guest) {
X		sprintf(buf, "You are not allowed to vote, but, here is the count.\n");
X		notify(Playernum, Governor, buf);
X		show_votes(Playernum, Governor);
X		return;
X	}
X	if (argn > 2) {
X		check = 0;
X		if (match(args[1], "update")) {
X			i = strlen(args[2]);
X			if (match(args[2], "go")) {
X				Race->votes |= VOTE_UPDATE_GO;
X				check = 1;
X			} else if (match(args[2], "wait"))
X				Race->votes &= ~VOTE_UPDATE_GO;
X			else {
X				sprintf(buf, "No such update choice '%s'\n", args[2]);
X				notify(Playernum, Governor, buf);
X				return;
X			}
X		} else {
X			sprintf(buf, "No such vote '%s'\n", args[1]);
X			notify(Playernum, Governor, buf);
X			return;
X		}
X		putrace(Race);
X
X		if (check) {
X			/*
X			 * Ok...someone voted yes.  Tally them all up and see
X			 * if
X			 */
X			/* we should do something. */
X			nays = 0;
X			yays = 0;
X			nvotes = 0;
X			for (Playernum = 1; Playernum <= Num_races; Playernum++) {
X				Race = races[Playernum - 1];
X				if (Race->God || Race->Guest)
X					continue;
X				nvotes++;
X				if (Race->votes & VOTE_UPDATE_GO)
X					yays++;
X				else
X					nays++;
X			}
X			/* Is Update/Movement vote unanimous now? */
X			if (nvotes > 0 && nvotes == yays && nays == 0) {
X				/* Do it... */
X				do_next_thing();
X			}
X		}
X	} else {
X		sprintf(buf, "Your vote on updates is %s\n",
X			(Race->votes & VOTE_UPDATE_GO) ? "go" : "wait");
X		notify(Playernum, Governor, buf);
X		show_votes(Playernum, Governor);
X	}
X}
X
Xvoid 
Xshow_votes(int Playernum, int Governor)
X{
X	int             nvotes, nays, yays, pnum;
X	racetype       *Race;
X
X	nays = yays = nvotes = 0;
X	for (pnum = 1; pnum <= Num_races; pnum++) {
X		Race = races[pnum - 1];
X		if (Race->God || Race->Guest)
X			continue;
X		nvotes++;
X		if (Race->votes & VOTE_UPDATE_GO) {
X			yays++;
X			sprintf(buf, "  %s voted go.\n", Race->name);
X		} else {
X			nays++;
X			sprintf(buf, "  %s voted wait.\n", Race->name);
X		}
X		if (races[Playernum - 1]->God)
X			notify(Playernum, Governor, buf);
X	}
X	sprintf(buf, "  Total votes = %d, Go = %d, Wait = %d.\n", nvotes, yays, nays);
X	notify(Playernum, Governor, buf);
X}
X#endif
END_OF_FILE
if test 9628 -ne `wc -c <'user/declare.c'`; then
    echo shar: \"'user/declare.c'\" unpacked with wrong size!
fi
# end of 'user/declare.c'
fi
echo shar: End of archive 16 \(of 21\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
