Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i025:  gbp - Galactic Bloodshed+, an empire-like war game, Part13/21
Message-ID: <4553@master.CNA.TEK.COM>
Date: 12 Feb 93 17:31:59 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1986
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1704

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 25
Archive-name: gbp/Part13
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 13 (of 21)."
# Contents:  server/files_shl.c user/analysis.c user/land.c
#   utils/enrol.c
# Wrapped by billr@saab on Fri Feb 12 09:14:27 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'server/files_shl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/files_shl.c'\"
else
echo shar: Extracting \"'server/files_shl.c'\" \(13655 characters\)
sed "s/^X//" >'server/files_shl.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * disk input/output routines & msc stuff all read routines lock the data they
X * just accessed (the file is not closed).  write routines close and thus
X * unlock that area.
X * 
X */
X#include <strings.h>
X#include <signal.h>
X#include <errno.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#define SHIP_CONSISTENCY
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X
Xint             commoddata, pdata, racedata, sectdata, shdata, stdata;
X
Xextern int      errno;
Xint             sys_nerr;
Xextern char    *sys_errlist[];
X
Xvoid            close_file(int);
Xvoid            open_data_files(void);
Xvoid            close_data_files(void);
Xvoid            openstardata(int *);
Xvoid            openshdata(int *);
Xvoid            opencommoddata(int *);
Xvoid            openpdata(int *);
Xvoid            opensectdata(int *);
Xvoid            openracedata(int *);
Xvoid            getsdata(struct stardata * S);
X#ifdef DEBUG
Xvoid            DEBUGgetrace(racetype **, int, char *, int);
Xvoid            DEBUGgetstar(startype **, int, char *, int);
Xvoid            DEBUGgetplanet(planettype **, int, int, char *, int);
Xint             DEBUGgetship(shiptype **, int, char *, int);
Xint             DEBUGgetcommod(commodtype **, int, char *, int);
X#else
Xvoid            getrace(racetype **, int);
Xvoid            getstar(startype **, int);
Xvoid            getplanet(planettype **, int, int);
Xint             getship(shiptype **, int);
Xint             getcommod(commodtype **, int);
X#endif
Xvoid            getsector(sectortype **, planettype *, int, int);
Xvoid            getsmap(sectortype *, planettype *);
Xint             getdeadship(void);
Xint             getdeadcommod(void);
Xvoid            putsdata(struct stardata *);
Xvoid            putrace(racetype *);
Xvoid            putstar(startype *, int);
Xvoid            putplanet(planettype *, int, int);
Xvoid            putsector(sectortype *, planettype *, int, int);
Xvoid            putsmap(sectortype *, planettype *);
Xvoid            putship(shiptype *);
Xvoid            putcommod(commodtype *, int);
Xint             Numraces(void);
Xint             Numships(void);
Xint             Numcommods(void);
Xint             Newslength(int);
Xvoid            clr_shipfree(void);
Xvoid            clr_commodfree(void);
Xvoid            makeshipdead(int);
Xvoid            makecommoddead(int);
Xvoid            Putpower(struct power[MAXPLAYERS]);
Xvoid            Getpower(struct power[MAXPLAYERS]);
Xvoid            Putblock(struct block[MAXPLAYERS]);
Xvoid            Getblock(struct block[MAXPLAYERS]);
X#include "proto.h"
X
Xvoid 
Xclose_file(int fd)
X{
X	close(fd);
X}
X
Xvoid 
Xopen_data_files(void)
X{
X	opencommoddata(&commoddata);
X	openpdata(&pdata);
X	openracedata(&racedata);
X	opensectdata(&sectdata);
X	openshdata(&shdata);
X	openstardata(&stdata);
X}
X
Xvoid 
Xclose_data_files(void)
X{
X	close_file(commoddata);
X	close_file(pdata);
X	close_file(racedata);
X	close_file(sectdata);
X	close_file(shdata);
X	close_file(stdata);
X}
X
Xvoid 
Xopenstardata(int *fd)
X{
X	/* printf(" openstardata\n"); */
X	if ((*fd = open(STARDATAFL, O_RDWR, 0777)) < 0) {
X		perror("openstardata");
X		printf("unable to open %s\n", STARDATAFL);
X		exit(-1);
X	}
X}
X
Xvoid 
Xopenshdata(int *fd)
X{
X	if ((*fd = open(SHIPDATAFL, O_RDWR, 0777)) < 0) {
X		perror("openshdata");
X		printf("unable to open %s\n", SHIPDATAFL);
X		exit(-1);
X	}
X}
X
Xvoid 
Xopencommoddata(int *fd)
X{
X	if ((*fd = open(COMMODDATAFL, O_RDWR, 0777)) < 0) {
X		perror("opencommoddata");
X		printf("unable to open %s\n", COMMODDATAFL);
X		exit(-1);
X	}
X}
X
Xvoid 
Xopenpdata(int *fd)
X{
X	if ((*fd = open(PLANETDATAFL, O_RDWR, 0777)) < 0) {
X		perror("openpdata");
X		printf("unable to open %s\n", PLANETDATAFL);
X		exit(-1);
X	}
X}
X
Xvoid 
Xopensectdata(int *fd)
X{
X	if ((*fd = open(SECTORDATAFL, O_RDWR, 0777)) < 0) {
X		perror("opensectdata");
X		printf("unable to open %s\n", SECTORDATAFL);
X		exit(-1);
X	}
X}
X
Xvoid 
Xopenracedata(int *fd)
X{
X	if ((*fd = open(RACEDATAFL, O_RDWR, 0777)) < 0) {
X		perror("openrdata");
X		printf("unable to open %s\n", RACEDATAFL);
X		exit(-1);
X	}
X}
X
Xvoid 
Xgetsdata(struct stardata * S)
X{
X	Fileread(stdata, (char *) S, sizeof(struct stardata), 0);
X}
X
X
X#ifdef DEBUG
Xvoid 
XDEBUGgetrace(racetype ** r, int rnum, char *fname, int lineno)
X#else
Xvoid 
Xgetrace(racetype ** r, int rnum)
X#endif
X{
X#ifdef DEBUG
X	*r = (racetype *) DEBUGmalloc(sizeof(racetype), fname, lineno);
X#else
X	*r = (racetype *) malloc(sizeof(racetype));
X#endif
X	Fileread(racedata, (char *) *r, sizeof(racetype), (rnum - 1) * sizeof(racetype));
X}
X
X#ifdef DEBUG
Xvoid 
XDEBUGgetstar(startype ** s, int star, char *fname, int lineno)
X#else
Xvoid 
Xgetstar(startype ** s, int star)
X#endif
X{
X	if (s >= &Stars[0] && s < &Stars[NUMSTARS - 1]);	/* Do nothing */
X	else {
X#ifdef DEBUG
X		*s = (startype *) DEBUGmalloc(sizeof(startype), fname, lineno);
X#else
X		*s = (startype *) malloc(sizeof(startype));
X#endif
X	}
X	Fileread(stdata, (char *) *s, sizeof(startype), (int) (sizeof(Sdata) + star * sizeof(startype)));
X}
X
X
X#ifdef DEBUG
Xvoid 
XDEBUGgetplanet(planettype ** p, int star, int pnum, char *fname, int lineno)
X#else
Xvoid 
Xgetplanet(planettype ** p, int star, int pnum)
X#endif
X{
X	int             filepos;
X	if (p >= &planets[0][0] && p < &planets[NUMSTARS - 1][MAXPLANETS - 1]);	/* Do nothing */
X	else {			/* Allocate space for others */
X#ifdef DEBUG
X		*p = (planettype *) DEBUGmalloc(sizeof(planettype), fname, lineno);
X#else
X		*p = (planettype *) malloc(sizeof(planettype));
X#endif
X	}
X	filepos = Stars[star]->planetpos[pnum];
X	Fileread(pdata, (char *) *p, sizeof(planettype), filepos);
X}
X
X
Xvoid 
Xgetsector(sectortype ** s, planettype * p, int x, int y)
X{
X	int             filepos;
X	filepos = p->sectormappos + (y * p->Maxx + x) * sizeof(sectortype);
X	*s = (sectortype *) malloc(sizeof(sectortype));
X	Fileread(sectdata, (char *) *s, sizeof(sectortype), filepos);
X}
X
Xvoid 
Xgetsmap(sectortype * map, planettype * p)
X{
X	Fileread(sectdata, (char *) map, p->Maxx * p->Maxy * sizeof(sectortype),
X		 p->sectormappos);
X}
X
X
X#ifdef DEBUG
Xint 
XDEBUGgetship(shiptype ** s, int shipnum, char *fname, int lineno)
X#else
Xint 
Xgetship(shiptype ** s, int shipnum)
X#endif
X{
X	struct stat     buffer;
X
X	if (shipnum <= 0)
X		return 0;
X
X	fstat(shdata, &buffer);
X	if (buffer.st_size / sizeof(shiptype) < shipnum)
X		return 0;
X	else {
X
X#ifdef DEBUG
X		if ((*s = (shiptype *) DEBUGmalloc(sizeof(shiptype), fname, lineno)) == NULL)
X#else
X		if ((*s = (shiptype *) malloc(sizeof(shiptype))) == NULL)
X#endif
X			printf("getship:Malloc() error \n"), exit(0);
X
X		Fileread(shdata, (char *) *s, sizeof(shiptype), (shipnum - 1) * sizeof(shiptype));
X		return 1;
X	}
X}
X
X#ifdef DEBUG
Xint 
XDEBUGgetcommod(commodtype ** c, int commodnum, char *fname, int lineno)
X#else
Xint 
Xgetcommod(commodtype ** c, int commodnum)
X#endif
X{
X	struct stat     buffer;
X
X	if (commodnum <= 0)
X		return 0;
X
X	fstat(commoddata, &buffer);
X	if (buffer.st_size / sizeof(commodtype) < commodnum)
X		return 0;
X	else {
X
X#ifdef DEBUG
X		if ((*c = (commodtype *) DEBUGmalloc(sizeof(commodtype), fname, lineno)) == NULL)
X#else
X		if ((*c = (commodtype *) malloc(sizeof(commodtype))) == NULL)
X#endif
X			printf("getcommod:Malloc() error \n"), exit(0);
X
X		Fileread(commoddata, (char *) *c, sizeof(commodtype), (commodnum - 1) * sizeof(commodtype));
X		return 1;
X	}
X}
X
X
X/*
X * gets the ship # listed in the top of the file SHIPFREEDATAFL. this * might
X * have no other uses besides build().
X */
Xint 
Xgetdeadship(void)
X{
X	struct stat     buffer;
X	short           shnum;
X	int             fd;
X	int             abort;
X
X	if ((fd = open(SHIPFREEDATAFL, O_RDWR, 0777)) < 0) {
X		perror("getdeadship");
X		printf("unable to open %s\n", SHIPFREEDATAFL);
X		exit(-1);
X	}
X	abort = 1;
X	fstat(fd, &buffer);
X
X	if (buffer.st_size && (abort == 1)) {
X		/* put topmost entry in fpos */
X		Fileread(fd, (char *) &shnum, sizeof(short), buffer.st_size - sizeof(short));
X		/* erase that entry, since it will now be filled */
X		ftruncate(fd, (long) (buffer.st_size - sizeof(short)));
X		close_file(fd);
X		return (int) shnum;
X	} else
X		close_file(fd);
X	return -1;
X}
X
Xint 
Xgetdeadcommod(void)
X{
X	struct stat     buffer;
X	short           commodnum;
X	int             fd;
X	int             abort;
X
X	if ((fd = open(COMMODFREEDATAFL, O_RDWR, 0777)) < 0) {
X		perror("getdeadcommod");
X		printf("unable to open %s\n", COMMODFREEDATAFL);
X		exit(-1);
X	}
X	abort = 1;
X	fstat(fd, &buffer);
X
X	if (buffer.st_size && (abort == 1)) {
X		/* put topmost entry in fpos */
X		Fileread(fd, (char *) &commodnum, sizeof(short), buffer.st_size - sizeof(short));
X		/* erase that entry, since it will now be filled */
X		ftruncate(fd, (long) (buffer.st_size - sizeof(short)));
X		close_file(fd);
X		return (int) commodnum;
X	} else
X		close_file(fd);
X	return -1;
X}
X
X
Xvoid 
Xputsdata(struct stardata * S)
X{
X	Filewrite(stdata, (char *) S, sizeof(struct stardata), 0);
X}
X
X
Xvoid 
Xputrace(racetype * r)
X{
X	Filewrite(racedata, (char *) r, sizeof(racetype), (r->Playernum - 1) * sizeof(racetype));
X}
X
Xvoid 
Xputstar(startype * s, int snum)
X{
X	Filewrite(stdata, (char *) s, sizeof(startype), (int) (sizeof(Sdata) + snum * sizeof(startype)));
X}
X
Xvoid 
Xputplanet(planettype * p, int star, int pnum)
X{
X	int             filepos;
X	filepos = Stars[star]->planetpos[pnum];
X	Filewrite(pdata, (char *) p, sizeof(planettype), filepos);
X}
X
Xvoid 
Xputsector(sectortype * s, planettype * p, int x, int y)
X{
X	int             filepos;
X	filepos = p->sectormappos + (y * p->Maxx + x) * sizeof(sectortype);
X	Filewrite(sectdata, (char *) s, sizeof(sectortype), filepos);
X}
X
Xvoid 
Xputsmap(sectortype * map, planettype * p)
X{
X	Filewrite(sectdata, (char *) map,
X		  p->Maxx * p->Maxy * sizeof(sectortype), p->sectormappos);
X}
X
Xvoid 
Xputship(shiptype * s)
X{
X	Filewrite(shdata, (char *) s, sizeof(shiptype), (s->number - 1) * sizeof(shiptype));
X}
X
Xvoid 
Xputcommod(commodtype * c, int commodnum)
X{
X	Filewrite(commoddata, (char *) c, sizeof(commodtype), (commodnum - 1) * sizeof(commodtype));
X}
X
Xint 
XNumraces(void)
X{
X	struct stat     buffer;
X
X	fstat(racedata, &buffer);
X	return ((int) (buffer.st_size / sizeof(racetype)));
X}
X
Xint 
XNumships(void)
X{				/* return number of ships */
X	struct stat     buffer;
X
X	fstat(shdata, &buffer);
X	return ((int) (buffer.st_size / sizeof(shiptype)));
X}
X
Xint 
XNumcommods(void)
X{
X	struct stat     buffer;
X
X	fstat(commoddata, &buffer);
X	return ((int) (buffer.st_size / sizeof(commodtype)));
X}
X
Xint 
XNewslength(int type)
X{
X	struct stat     buffer;
X	FILE           *fp;
X
X	switch (type) {
X	case DECLARATION:
X		if ((fp = fopen(DECLARATIONFL, "r")) == NULL)
X			fp = fopen(DECLARATIONFL, "w+");
X		break;
X
X	case TRANSFER:
X		if ((fp = fopen(TRANSFERFL, "r")) == NULL)
X			fp = fopen(TRANSFERFL, "w+");
X		break;
X	case COMBAT:
X		if ((fp = fopen(COMBATFL, "r")) == NULL)
X			fp = fopen(COMBATFL, "w+");
X		break;
X	case ANNOUNCE:
X		if ((fp = fopen(ANNOUNCEFL, "r")) == NULL)
X			fp = fopen(ANNOUNCEFL, "w+");
X		break;
X	default:
X		return 0;
X	}
X	fstat(fileno(fp), &buffer);
X	fclose(fp);
X	return ((int) buffer.st_size);
X}
X
X/* delete contents of dead ship file */
Xvoid 
Xclr_shipfree(void)
X{
X	fclose(fopen(SHIPFREEDATAFL, "w+"));
X}
X
Xvoid 
Xclr_commodfree(void)
X{
X	fclose(fopen(COMMODFREEDATAFL, "w+"));
X}
X
X/*
X * * writes the ship to the dead ship file at its end.
X */
Xvoid 
Xmakeshipdead(int shipnum)
X{
X	int             fd;
X	unsigned short  shipno;
X	struct stat     buffer;
X
X	shipno = shipnum;	/* conv to u_short */
X
X	if (shipno == 0)
X		return;
X
X	if ((fd = open(SHIPFREEDATAFL, O_WRONLY, 0777)) < 0) {
X		printf("fd = %d \n", fd);
X		printf("errno = %d \n", errno);
X		perror("openshfdata");
X		printf("unable to open %s\n", SHIPFREEDATAFL);
X		exit(-1);
X	}
X	/* write the ship # at the very end of SHIPFREEDATAFL */
X	fstat(fd, &buffer);
X
X	Filewrite(fd, (char *) &shipno, sizeof(shipno), buffer.st_size);
X	close_file(fd);
X}
X
Xvoid 
Xmakecommoddead(int commodnum)
X{
X	int             fd;
X	unsigned short  commodno;
X	struct stat     buffer;
X
X	commodno = commodnum;	/* conv to u_short */
X
X	if (commodno == 0)
X		return;
X
X	if ((fd = open(COMMODFREEDATAFL, O_WRONLY, 0777)) < 0) {
X		printf("fd = %d \n", fd);
X		printf("errno = %d \n", errno);
X		perror("opencommodfdata");
X		printf("unable to open %s\n", COMMODFREEDATAFL);
X		exit(-1);
X	}
X	/* write the commod # at the very end of COMMODFREEDATAFL */
X	fstat(fd, &buffer);
X
X	Filewrite(fd, (char *) &commodno, sizeof(commodno), buffer.st_size);
X	close_file(fd);
X}
X
Xvoid 
XPutpower(struct power p[MAXPLAYERS])
X{
X	int             power_fd;
X
X	if ((power_fd = open(POWFL, O_RDWR, 0777)) < 0) {
X		perror("open power data");
X		printf("unable to open %s\n", POWFL);
X		return;
X	}
X	write(power_fd, (char *) p, sizeof(*p) * MAXPLAYERS);
X	close_file(power_fd);
X}
X
Xvoid 
XGetpower(struct power p[MAXPLAYERS])
X{
X	int             power_fd;
X
X	if ((power_fd = open(POWFL, O_RDONLY, 0777)) < 0) {
X		perror("open power data");
X		printf("unable to open %s\n", POWFL);
X		return;
X	} else {
X		read(power_fd, (char *) p, sizeof(*p) * MAXPLAYERS);
X		close_file(power_fd);
X	}
X}
X
Xvoid 
XPutblock(struct block b[MAXPLAYERS])
X{
X	int             block_fd;
X
X	if ((block_fd = open(BLOCKDATAFL, O_RDWR, 0777)) < 0) {
X		perror("open block data");
X		printf("unable to open %s\n", BLOCKDATAFL);
X		return;
X	}
X	write(block_fd, (char *) b, sizeof(*b) * MAXPLAYERS);
X	close_file(block_fd);
X}
X
Xvoid 
XGetblock(struct block b[MAXPLAYERS])
X{
X	int             block_fd;
X
X	if ((block_fd = open(BLOCKDATAFL, O_RDONLY, 0777)) < 0) {
X		perror("open block data");
X		printf("unable to open %s\n", BLOCKDATAFL);
X		return;
X	} else {
X		read(block_fd, (char *) b, sizeof(*b) * MAXPLAYERS);
X		close_file(block_fd);
X	}
X}
END_OF_FILE
if test 13655 -ne `wc -c <'server/files_shl.c'`; then
    echo shar: \"'server/files_shl.c'\" unpacked with wrong size!
fi
# end of 'server/files_shl.c'
fi
if test -f 'user/analysis.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/analysis.c'\"
else
echo shar: Extracting \"'user/analysis.c'\" \(10337 characters\)
sed "s/^X//" >'user/analysis.c' <<'END_OF_FILE'
X /* Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h. 
X *
X * anal.c 
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X#include <string.h>
X#include <ctype.h>
X
Xextern char    *Desnames[];
Xextern char	Dessymbols[];
X
X#define CARE 5
Xstruct anal_sect {
X    int             x, y;
X    int             value;
X    int	    des;
X};
X
Xvoid analysis(int, int, int);
Xvoid do_analysis(int, int, int, int, int, int, int);
Xvoid Insert(int, struct anal_sect [], int, int, int, int);
Xvoid PrintTop(int, int, struct anal_sect [], char *);
X#include "proto.h"
X
X
Xvoid analysis(int Playernum, int Governor, int APcount)
X{
X    int pnum;
X    int sector_type = -1;       /* -1 does analysis on all types */
X    placetype       where;      /* otherwise on specific type */
X    int             i;
X    int             do_player = -1;
X    char           *p;
X    int             mode = 1;	/* does top five. 0 does low five */
X
X    i = 1;
X    do {
X	 where.level = Dir[Playernum - 1][Governor].level;
X	 where.snum = Dir[Playernum - 1][Governor].snum;
X	 where.pnum = Dir[Playernum - 1][Governor].pnum;
X	
X          p = args[1];
X            if (*p == '-')     /*  Must use 'd' to do an analysis on */
X            {                  /*  desert sectors to avoid confusion */
X               p++;            /*  with the '-' for the mode type    */
X               i++;
X               mode = 0;
X            }
X            switch (*p) {
X               case CHAR_SEA   : sector_type = SEA;   break;
X               case CHAR_LAND  : sector_type = LAND;  break; 
X               case CHAR_MOUNT : sector_type = MOUNT; break;
X               case CHAR_GAS   : sector_type = GAS;   break;
X               case CHAR_ICE   : sector_type = ICE;   break;
X               case CHAR_FOREST: sector_type = FOREST;break;
X               case 'd'        : sector_type = DESERT;break;
X               case CHAR_PLATED: sector_type = PLATED;break;
X               case CHAR_WASTED: sector_type = WASTED;break;
X            }
X            if (sector_type != -1 && mode == 1)
X            {
X               i++;
X            }
X
X            p = args[i];
X	    if (isdigit(*p)) {
X		do_player = atoi(p);
X		if (do_player > Num_races) {
X		    notify(Playernum, Governor, "No such player #.\n");
X		    return;
X		}
X		where.level = Dir[Playernum - 1][Governor].level;
X		where.snum = Dir[Playernum - 1][Governor].snum;
X		where.pnum = Dir[Playernum - 1][Governor].pnum;
X                i++;
X	    } 
X            p = args[i];
X            if (i<argn && (isalpha (*p) || *p == '/'))
X            {
X		where = Getplace(Playernum, Governor, args[i], 0);
X		if (where.err)
X		    continue;
X	    }
X
X	switch (where.level) {
X	  case LEVEL_UNIV:
X	    notify(Playernum, Governor, "You can only analyze planets.\n");
X	    break;
X	  case LEVEL_PLAN:
X	    do_analysis(Playernum, Governor, do_player, mode, sector_type,
X			(int)where.snum, (int)where.pnum);
X	    break;
X	  case LEVEL_STAR:
X	    for (pnum = 0; pnum < Stars[where.snum]->numplanets; pnum++)
X		do_analysis(Playernum, Governor, do_player, mode, sector_type,
X			    (int)where.snum, pnum);
X	    break;
X	}
X    } while (0);
X    return;
X}
X
X
Xvoid do_analysis(int Playernum, int Governor, int ThisPlayer, int mode,
X		 int sector_type, int Starnum, int Planetnum)
X{
X  planettype     *planet;
X  sectortype     *sect;
X  racetype       *Race;
X  int             x, y;
X  int             p;
X  int             i;
X  double          compat;
X  struct anal_sect Res[CARE], Eff[CARE], Frt[CARE], Mob[CARE];
X  struct anal_sect Troops[CARE], Popn[CARE], mPopn[CARE];
X  int             TotalCrys, PlayCrys[MAXPLAYERS + 1];
X  int             TotalTroops, PlayTroops[MAXPLAYERS + 1];
X  int             TotalPopn, PlayPopn[MAXPLAYERS + 1];
X  int             TotalMob, PlayMob[MAXPLAYERS + 1];
X  int             TotalEff, PlayEff[MAXPLAYERS + 1];
X  int             TotalRes, PlayRes[MAXPLAYERS + 1];
X  int             TotalSect, PlaySect[MAXPLAYERS + 1][WASTED + 1];
X  int             PlayTSect[MAXPLAYERS + 1];
X  int             TotalWasted, WastedSect[MAXPLAYERS + 1];
X  int             Sect[WASTED + 1];
X  static char     SectTypes[] = {CHAR_SEA, CHAR_LAND, CHAR_MOUNT,
X				     CHAR_GAS, CHAR_ICE, CHAR_FOREST,
X				     CHAR_DESERT, CHAR_PLATED, CHAR_WASTED};
X
X  for (i = 0; i < CARE; i++)
X      Res[i].value = Eff[i].value = Frt[i].value = Mob[i].value =
X	  Troops[i].value = Popn[i].value = mPopn[i].value = -1;
X
X  TotalWasted = TotalCrys = TotalPopn = TotalMob =
X      TotalTroops = TotalEff = TotalRes = TotalSect = 0;
X  for (p = 0; p <= Num_races; p++) {
X      PlayTroops[p] = PlayPopn[p] = PlayMob[p] = PlayEff[p] = PlayCrys[p] =
X	  PlayRes[p] = PlayTSect[p] = 0;
X      WastedSect[p] = 0;
X      for (i = 0; i <= WASTED; i++)
X	  PlaySect[p][i] = 0;
X  }
X
X  for (i = 0; i <= WASTED; i++)
X      Sect[i] = 0;
X
X  Race = races[Playernum-1];
X  getplanet(&planet, Starnum, Planetnum);
X
X  if (!planet->info[Playernum - 1].explored) {
X      free(planet);
X      return;
X  }
X  getsmap(Smap, planet);
X
X  compat = compatibility(planet, Race);
X
X  TotalSect = planet->Maxx * planet->Maxy;
X  for (x = planet->Maxx - 1; x >= 0; x--) {
X      for (y = planet->Maxy - 1; y >= 0; y--) {
X	  sect = &Sector(*planet, x, y);
X	  p = sect->owner;
X
X	  PlayEff[p] += sect->eff;
X	  PlayMob[p] += sect->mobilization;
X	  PlayRes[p] += sect->resource;
X	  PlayPopn[p] += sect->popn;
X	  PlayTroops[p] += sect->troops;
X	  PlaySect[p][sect->condition]++;
X	  PlayTSect[p]++;
X	  TotalEff += sect->eff;
X	  TotalMob += sect->mobilization;
X	  TotalRes += sect->resource;
X	  TotalPopn += sect->popn;
X	  TotalTroops += sect->troops;
X	  Sect[sect->condition]++;
X
X          if (sect->condition==WASTED) {
X             WastedSect[p]++;
X             TotalWasted++;
X          }
X	  if (sect->crystals && Race->tech >= TECH_CRYSTAL) {
X	     PlayCrys[p]++;
X	     TotalCrys++;
X	  }
X
X          if (sector_type == -1 || sector_type == sect->condition)
X          {
X	     if (ThisPlayer < 0 || ThisPlayer == p) 
X             {
X	        Insert(mode, Res, x, y, sect->condition, (int)sect->resource);
X	        Insert(mode, Eff, x, y, sect->condition, (int)sect->eff);
X	        Insert(mode, Mob, x, y, sect->condition,
X		     (int)sect->mobilization);
X	        Insert(mode, Frt, x, y, sect->condition, (int)sect->fert);
X	        Insert(mode, Popn, x, y, sect->condition, (int)sect->popn);
X	        Insert(mode, Troops, x, y, sect->condition, (int)sect->troops);
X	        Insert(mode, mPopn, x, y, sect->condition, 
X		     maxsupport(Race, sect, compat,
X				(int)planet->conditions[TOXIC]));
X             }
X	  }
X      }
X  }
X
X  sprintf(buf, "\nAnalysis of /%s/%s:\n", Stars[Starnum]->name,
X	  Stars[Starnum]->pnames[Planetnum]);
X  notify(Playernum, Governor, buf);
X  sprintf(buf, "%s %d",
X      (mode ? "Highest" : "Lowest"), CARE, ThisPlayer);
X  switch (sector_type) 
X  {
X     case -1     : sprintf (buf, "%s of all", buf); break;
X     case SEA    : sprintf (buf, "%s Ocean", buf); break;
X     case LAND   : sprintf (buf, "%s Land", buf); break;
X     case MOUNT  : sprintf (buf, "%s Mountain", buf); break;
X     case GAS    : sprintf (buf, "%s Gas", buf); break;
X     case ICE    : sprintf (buf, "%s Ice", buf); break;
X     case FOREST : sprintf (buf, "%s Forest", buf); break;
X     case DESERT : sprintf (buf, "%s Desert", buf); break;
X     case PLATED : sprintf (buf, "%s Plated", buf); break;
X     case WASTED : sprintf (buf, "%s Wasted", buf); break;
X  }
X  notify (Playernum, Governor, buf);
X  if (ThisPlayer < 0)
X     sprintf (buf, " sectors.\n");
X  else if (ThisPlayer == 0)
X     sprintf (buf, " sectors that are unoccupied.\n");
X  else
X     sprintf (buf, " sectors owned by %d.\n", ThisPlayer);
X  notify(Playernum, Governor, buf);
X
X  PrintTop(Playernum, Governor, Troops, "Troops");
X  PrintTop(Playernum, Governor, Res, "Res");
X  PrintTop(Playernum, Governor, Eff, "Eff");
X  PrintTop(Playernum, Governor, Frt, "Frt");
X  PrintTop(Playernum, Governor, Mob, "Mob");
X  PrintTop(Playernum, Governor, Popn, "Popn");
X  PrintTop(Playernum, Governor, mPopn, "^Popn");
X
X  notify(Playernum, Governor, "\n");
X  sprintf(buf, "%2s %3s %7s %6s %5s %5s %5s %2s",
X	  "Pl", "sec", "popn", "troops", "a.eff", "a.mob", "res", "x");
X  notify(Playernum, Governor, buf);
X
X  for (i = 0; i <= WASTED; i++) {
X      sprintf(buf, "%4c", SectTypes[i]);
X      notify(Playernum, Governor, buf);
X  }
X  notify(Playernum, Governor,
X	 "\n-------------------------------------------------------------------------------\n");
X  for (p = 0; p <= Num_races; p++)
X      if (PlayTSect[p] != 0) {
X	  sprintf(buf, "%2d %3d %7d %6d %5.1lf %5.1lf %5d %2d",
X		  p, PlayTSect[p], PlayPopn[p], PlayTroops[p],
X		  (double)PlayEff[p] / PlayTSect[p],
X		  (double)PlayMob[p] / PlayTSect[p], PlayRes[p], PlayCrys[p]);
X	  notify(Playernum, Governor, buf);
X	  for (i = 0; i <= WASTED; i++) {
X	      sprintf(buf, "%4d", PlaySect[p][i]);
X	      notify(Playernum, Governor, buf);
X	  }
X	  notify(Playernum, Governor, "\n");
X      }
X  notify(Playernum, Governor,
X	 "-------------------------------------------------------------------------------\n");
X  sprintf(buf, "%2s %3d %7d %6d %5.1lf %5.1lf %5d %2d",
X	  "Tl", TotalSect, TotalPopn, TotalTroops, (double)TotalEff / TotalSect,
X	  (double)TotalMob / TotalSect, TotalRes, TotalCrys);
X  notify(Playernum, Governor, buf);
X  for (i = 0; i <= WASTED; i++) {
X      sprintf(buf, "%4d", Sect[i]);
X      notify(Playernum, Governor, buf);
X  }
X  notify(Playernum, Governor, "\n");
X  free(planet);
X}
X
Xvoid Insert(int mode, struct anal_sect arr[], int x, int y, int des, int value)
X{
Xint             i, j;
X
Xfor (i = 0; i < CARE; i++)
X    if ((mode && arr[i].value < value) ||
X	(!mode && (arr[i].value > value || arr[i].value == -1))) {
X	for (j = CARE - 1; j > i; j--)
X	    arr[j] = arr[j - 1];
X	arr[i].value = value;
X	arr[i].x = x;
X	arr[i].y = y;
X	arr[i].des =des;
X	return;
X    }
X}
X
Xvoid PrintTop(int Playernum, int Governor, struct anal_sect arr[], char *name)
X{
Xint             i;
X
Xsprintf(buf, "%8s:", name);
Xnotify(Playernum, Governor, buf);
Xfor (i = 0; i < CARE && arr[i].value != -1; i++) {
X    sprintf(buf, "%5d%c(%2d,%2d)", arr[i].value, Dessymbols[arr[i].des], arr[i].x, arr[i].y);
X    notify(Playernum, Governor, buf);
X}
Xnotify(Playernum, Governor, "\n");
X}
X
X
X
END_OF_FILE
if test 10337 -ne `wc -c <'user/analysis.c'`; then
    echo shar: \"'user/analysis.c'\" unpacked with wrong size!
fi
# end of 'user/analysis.c'
fi
if test -f 'user/land.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/land.c'\"
else
echo shar: Extracting \"'user/land.c'\" \(12809 characters\)
sed "s/^X//" >'user/land.c' <<'END_OF_FILE'
X/*
X * * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, *
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. * Restrictions in
X * GB_copyright.h. *
X * 
X *  land.c -- land a ship *  also.... dock -- dock a ship w/ another ship *
X * and..... assault -- a very un-PC version of land/dock
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X#include <signal.h>
X#include <math.h>
X
Xextern long     Shipdata[NUMSTYPES][NUMABILS];
Xint             roll;
X
Xvoid            land(int, int, int);
Xint             crash(shiptype *, double);
Xint             docked(shiptype *);
Xint             overloaded(shiptype *);
X#include "proto.h"
X
Xvoid 
Xland(int Playernum, int Governor, int APcount)
X{
X	shiptype       *s, *s2;
X	planettype     *p;
X	sectortype     *sect;
X
X	int             shipno, ship2no, x = -1, y = -1, i, numdest, strength,
X	                damage;
X	double          fuel;
X	double          Dist;
X	racetype       *Race, *alien;
X	int             nextshipno;
X
X	if (argn < 2) {
X		notify(Playernum, Governor, "Land what?\n");
X		return;
X	}
X	nextshipno = start_shiplist(Playernum, Governor, args[1]);
X
X	while (shipno = do_shiplist(&s, &nextshipno))
X		if (in_list(Playernum, args[1], s, &nextshipno) &&
X		    authorized(Governor, s)) {
X			if (overloaded(s)) {
X				sprintf(buf, "%s is too overloaded to land.\n", Ship(s));
X				notify(Playernum, Governor, buf);
X				free(s);
X				continue;
X			}
X			
X			if (!Shipdata[s->type][ABIL_CANDOCK]) {
X				sprintf(buf, "This ship is not equipped to be docked.\n");
X				notify(Playernum, Governor, buf);
X				free(s);
X				continue;
X			}
X
X			if (s->type == OTYPE_QUARRY) {
X				notify(Playernum, Governor, "You can't load quarries onto ship.\n");
X				free(s);
X				continue;
X			}
X			if (docked(s)) {
X				notify(Playernum, Governor, "That ship is docked to another ship.\n");
X				free(s);
X				continue;
X			}
X			if (args[2][0] == '#') {
X				/*
X				 * attempting to land on a friendly ship (for
X				 * carriers/stations/etc)
X				 */
X				sscanf(args[2] + 1, "%d", &ship2no);
X				if (!getship(&s2, ship2no)) {
X					sprintf(buf, "Ship #%d wasn't found.\n", ship2no);
X					notify(Playernum, Governor, buf);
X					free(s);
X					continue;
X				}
X				if (testship(Playernum, Governor, s2)) {
X					notify(Playernum, Governor, "Illegal format.\n");
X					free(s);
X					free(s2);
X					continue;
X				}
X				if (s2->type == OTYPE_FACTORY) {
X					notify(Playernum, Governor, "Can't land on factories.\n");
X					free(s);
X					free(s2);
X					continue;
X				}
X				if (landed(s)) {
X					if (!landed(s2)) {
X						sprintf(buf, "%s is not landed on a planet.\n", Ship(s2));
X						notify(Playernum, Governor, buf);
X						free(s);
X						free(s2);
X						continue;
X					}
X					if (s2->storbits != s->storbits) {
X						notify(Playernum, Governor, "These ships are not in the same star system.\n");
X						free(s);
X						free(s2);
X						continue;
X					}
X					if (s2->pnumorbits != s->pnumorbits) {
X						notify(Playernum, Governor, "These ships are not landed on the same planet.\n");
X						free(s);
X						free(s2);
X						continue;
X					}
X					if ((s2->land_x != s->land_x) ||
X					    (s2->land_y != s->land_y)) {
X						notify(Playernum, Governor, "These ships are not in the same sector.\n");
X						free(s);
X						free(s2);
X						continue;
X					}
X					if (s->on) {
X						sprintf(buf, "%s must be turned off before loading.\n",
X							Ship(s));
X						notify(Playernum, Governor, buf);
X						free(s);
X						free(s2);
X						continue;
X					}
X					if (Size(s) > Hanger(s2)) {
X						sprintf(buf, "Mothership does not have %d hanger space available to load ship.\n",
X							Size(s));
X						notify(Playernum, Governor, buf);
X						free(s);
X						free(s2);
X						continue;
X					}
X					/* ok, load 'em up */
X					remove_sh_plan(s);
X					/*
X					 * get the target ship again because
X					 * it had a pointer changed (and put
X					 * to disk) in the remove routines
X					 */
X					free(s2);
X					(void) getship(&s2, ship2no);
X					insert_sh_ship(s, s2);
X					/* increase mass of mothership */
X					s2->mass += s->mass;
X					s2->hanger += Size(s);
X					fuel = 0.0;
X					sprintf(buf, "%s loaded onto %s using %.1f fuel.\n",
X						Ship(s), Ship(s2), fuel);
X					notify(Playernum, Governor, buf);
X					s->docked = 1;
X					putship(s2);
X					free(s2);
X				} else if (s->docked) {
X					sprintf(buf, "%s is already docked or landed.\n", Ship(s));
X					notify(Playernum, Governor, buf);
X					free(s);
X					free(s2);
X					continue;
X				} else {
X					/*
X					 * Check if the ships are in the same
X					 * scope level. Maarten
X					 */
X					if (s->whatorbits != s2->whatorbits) {
X						notify(Playernum, Governor, "Those ships are not in the same scope.\n");
X						free(s);
X						free(s2);
X						continue;
X					}
X					/*
X					 * check to see if close enough to
X					 * land
X					 */
X					Dist = sqrt((double) Distsq(s2->xpos, s2->ypos, s->xpos, s->ypos));
X					if (Dist > DIST_TO_DOCK) {
X						sprintf(buf, "%s must be %.2f or closer to %s.\n",
X							Ship(s), DIST_TO_DOCK, Ship(s2));
X						notify(Playernum, Governor, buf);
X						free(s);
X						free(s2);
X						continue;
X					}
X					fuel = 0.05 + Dist * 0.025 * sqrt(s->mass);
X					if (s->fuel < fuel) {
X						sprintf(buf, "Not enough fuel.\n");
X						notify(Playernum, Governor, buf);
X						free(s);
X						free(s2);
X						continue;
X					}
X					if (Size(s) > Hanger(s2)) {
X						sprintf(buf, "Mothership does not have %d hanger space available to load ship.\n",
X							Size(s));
X						notify(Playernum, Governor, buf);
X						free(s);
X						free(s2);
X						continue;
X					}
X					use_fuel(s, fuel);
X
X					/*
X					 * remove the ship from whatever
X					 * scope it is currently in
X					 */
X					if (s->whatorbits == LEVEL_PLAN)
X						remove_sh_plan(s);
X					else if (s->whatorbits == LEVEL_STAR)
X						remove_sh_star(s);
X					else {
X						notify(Playernum, Governor, "Ship is not in planet or star scope.\n");
X						free(s);
X						free(s2);
X						continue;
X					}
X					/*
X					 * get the target ship again because
X					 * it had a pointer changed (and put
X					 * to disk) in the remove routines
X					 */
X					free(s2);
X					(void) getship(&s2, ship2no);
X					insert_sh_ship(s, s2);
X					/* increase mass of mothership */
X					s2->mass += s->mass;
X					s2->hanger += Size(s);
X					sprintf(buf, "%s landed on %s using %.1f fuel.\n",
X						Ship(s), Ship(s2), fuel);
X					notify(Playernum, Governor, buf);
X					s->docked = 1;
X					putship(s2);
X					free(s2);
X				}
X			} else {/* attempting to land on a planet */
X				if (s->docked) {
X					sprintf(buf, "%s is docked.\n", Ship(s));
X					notify(Playernum, Governor, buf);
X					free(s);
X					continue;
X				}
X				sscanf(args[2], "%d,%d", &x, &y);
X				if (s->whatorbits != LEVEL_PLAN) {
X					sprintf(buf, "%s doesn't orbit a planet.\n", Ship(s));
X					notify(Playernum, Governor, buf);
X					free(s);
X					continue;
X				}
X				if (!Shipdata[s->type][ABIL_CANLAND]) {
X					sprintf(buf, "This ship is not equipped to land.\n");
X					notify(Playernum, Governor, buf);
X					free(s);
X					continue;
X				}
X				if ((s->storbits != Dir[Playernum - 1][Governor].snum) ||
X				    (s->pnumorbits != Dir[Playernum - 1][Governor].pnum)) {
X					sprintf(buf, "You have to cs to the planet it orbits.\n");
X					notify(Playernum, Governor, buf);
X					free(s);
X					continue;
X				}
X				if (!speed_rating(s)) {
X					sprintf(buf, "This ship is not rated for maneuvering.\n");
X					notify(Playernum, Governor, buf);
X					free(s);
X					continue;
X				}
X				if (!enufAP(Playernum, Governor, Stars[s->storbits]->AP[Playernum - 1], APcount)) {
X					free(s);
X					continue;
X				}
X				getplanet(&p, (int) s->storbits, (int) s->pnumorbits);
X
X				sprintf(buf, "Planet /%s/%s has gravity field of %.2f.\n",
X					Stars[s->storbits]->name,
X					Stars[s->storbits]->pnames[s->pnumorbits], gravity(p));
X				notify(Playernum, Governor, buf);
X
X				sprintf(buf, "Distance to planet: %.2f.\n",
X					Dist = sqrt((double) Distsq(Stars[s->storbits]->xpos + p->xpos,
X					 Stars[s->storbits]->ypos + p->ypos,
X							s->xpos, s->ypos)));
X				notify(Playernum, Governor, buf);
X
X				if (Dist > DIST_TO_LAND) {
X					sprintf(buf, "%s must be %.3g or closer to the planet (%.2f).\n",
X						Ship(s), DIST_TO_LAND, Dist);
X					notify(Playernum, Governor, buf);
X					free(s);
X					free(p);
X					continue;
X				}
X				fuel = s->mass * gravity(p) * LAND_GRAV_MASS_FACTOR;
X
X				if ((x < 0) || (y < 0) || (x > p->Maxx - 1) || (y > p->Maxy - 1)) {
X					sprintf(buf, "Illegal coordinates.\n");
X					notify(Playernum, Governor, buf);
X					free(s);
X					free(p);
X					continue;
X				}
X#ifdef DEFENSE
X				/*
X				 * people who have declared war on you will
X				 * fire at your landing ship
X				 */
X				for (i = 1; i <= Num_races; i++)
X					if (s->alive && i != Playernum && p->info[i - 1].popn &&
X					    p->info[i - 1].guns && p->info[i - 1].destruct) {
X						alien = races[i - 1];
X						if (isset(alien->atwar, (int) s->owner)) {
X							/*
X							 * attack the landing
X							 * ship
X							 */
X							strength = MIN((int) p->info[i - 1].guns,
X								       (int) p->info[i - 1].destruct);
X							if (strength) {
X								damage = shoot_planet_to_ship(alien, p, s, strength,
X								 buf, temp);
X								post(temp, COMBAT);
X								notify_star(0, 0, (int) s->owner,
X									    (int) s->storbits, temp);
X								warn(i, (int) Stars[s->storbits]->governor[i - 1], buf);
X								notify((int) s->owner, (int) s->governor, buf);
X								p->info[i - 1].destruct -= strength;
X							}
X						}
X					}
X				if (!s->alive) {
X					putplanet(p, (int) s->storbits, (int) s->pnumorbits);
X					putship(s);
X					free(p);
X					free(s);
X					continue;
X				}
X#endif
X				/*
X				 * check to see if the ship crashes from lack
X				 * of fuel or damage
X				 */
X				if (crash(s, fuel)) {
X					/*
X					 * damaged ships stand of chance of
X					 * crash landing
X					 */
X					numdest = shoot_ship_to_planet(s, p,
X								       round_rand((double) (s->destruct) / 3.),
X								       x, y, 1, 0, HEAVY, long_buf, short_buf);
X					sprintf(buf, "BOOM!! %s crashes on sector %d,%d with blast radius of %d.\n",
X						Ship(s), x, y, numdest);
X					for (i = 1; i <= Num_races; i++)
X						if (p->info[i - 1].numsectsowned || i == Playernum)
X							warn(i, (int) Stars[s->storbits]->governor[i - 1], buf);
X					if (roll)
X						sprintf(buf, "Ship damage %d%% (you rolled a %d)\n",
X						     (int) s->damage, roll);
X					else
X						sprintf(buf, "You had %.1ff while the landing required %.1ff\n",
X							s->fuel, fuel);
X					notify(Playernum, Governor, buf);
X					kill_ship((int) s->owner, s);
X				} else {
X					s->land_x = x;
X					s->land_y = y;
X					s->xpos = p->xpos + Stars[s->storbits]->xpos;
X					s->ypos = p->ypos + Stars[s->storbits]->ypos;
X					use_fuel(s, fuel);
X					s->docked = 1;
X					s->whatdest = LEVEL_PLAN;	/* no destination */
X					s->deststar = s->storbits;
X					s->destpnum = s->pnumorbits;
X				}
X
X				getsector(&sect, p, x, y);
X
X				if (sect->condition == WASTED) {
X					sprintf(buf, "Warning: That sector is a wasteland!\n");
X					notify(Playernum, Governor, buf);
X				} else if (sect->owner && sect->owner != Playernum) {
X					Race = races[Playernum - 1];
X					alien = races[sect->owner - 1];
X					if (!(isset(Race->allied, sect->owner) &&
X					 isset(alien->allied, Playernum))) {
X						sprintf(buf, "You have landed on an alien sector (%s).\n", alien->name);
X						notify(Playernum, Governor, buf);
X					} else {
X						sprintf(buf, "You have landed on allied sector (%s).\n", alien->name);
X						notify(Playernum, Governor, buf);
X					}
X				}
X				if (s->whatorbits == LEVEL_UNIV)
X					deductAPs(Playernum, Governor, APcount, 0, 1);
X				else
X					deductAPs(Playernum, Governor, APcount, (int) s->storbits, 0);
X
X				putplanet(p, (int) s->storbits, (int) s->pnumorbits);
X
X				if (numdest)
X					putsector(sect, p, x, y);
X
X				/* send messages to anyone there */
X				sprintf(buf, "%s observed landing on sector %d,%d,planet /%s/%s.\n",
X					Ship(s), s->land_x, s->land_y,
X					Stars[s->storbits]->name,
X				 Stars[s->storbits]->pnames[s->pnumorbits]);
X				for (i = 1; i <= Num_races; i++)
X					if (p->info[i - 1].numsectsowned && i != Playernum)
X						notify(i, (int) Stars[s->storbits]->governor[i - 1], buf);
X
X				sprintf(buf, "%s landed on planet.\n", Ship(s));
X				notify(Playernum, Governor, buf);
X
X				free(sect);
X				free(p);
X			}
X			putship(s);
X			free(s);
X		} else
X			free(s);
X}
X
Xint 
Xcrash(shiptype * s, double fuel)
X{
X	roll = 0;
X
X	if (s->fuel < fuel)
X		return 1;
X	else if ((roll = int_rand(1, 100)) <= (int) s->damage)
X		return 1;
X	else
X		return 0;
X}
X
Xint 
Xdocked(shiptype * s)
X{
X	return (s->docked && s->whatdest == LEVEL_SHIP);
X}
X
Xint 
Xoverloaded(shiptype * s)
X{
X	return ((s->resource > Max_resource(s)) || (s->fuel > Max_fuel(s)) ||
X		(s->popn + s->troops > s->max_crew) || (s->destruct > Max_destruct(s)));
X}
END_OF_FILE
if test 12809 -ne `wc -c <'user/land.c'`; then
    echo shar: \"'user/land.c'\" unpacked with wrong size!
fi
# end of 'user/land.c'
fi
if test -f 'utils/enrol.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/enrol.c'\"
else
echo shar: Extracting \"'utils/enrol.c'\" \(13967 characters\)
sed "s/^X//" >'utils/enrol.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, 
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h.
X * Restrictions in GB_copyright.h.
X * enrol.c -- initializes to owner one sector and planet. 
X */
X
X#include "GB_copyright.h"
X#include <stdio.h>
X#include <signal.h>
X#include <strings.h>
X#include <curses.h>
X#include <errno.h>
X#define EXTERN
X#include "vars.h"
X#include "ships.h"
X#include "shipdata.h"
X#include "races.h"
X#include "buffers.h"
Xextern int errno;
Xchar desshow();
Xracetype *Race;
X
Xstruct stype {
X  char here;
X  char x,y;
X  int count;
X};
X#define RACIAL_TYPES 10
X
X/* racial types (10 racial types ) */
Xint Thing[RACIAL_TYPES] = {
X  1, 1, 1, 0, 0, 0, 0, 0, 0, 0};
Xdouble db_Mass[RACIAL_TYPES] = {
X  .1,.15,.2,.125,.125,.125,.125,.125,.125,.125};
Xdouble db_Birthrate[RACIAL_TYPES] = {
X  0.9, 0.85, 0.8, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8};
Xint db_Fighters[RACIAL_TYPES] = {
X  9, 10, 11, 2, 3, 4, 5, 6, 7, 8};
Xint db_Intelligence[RACIAL_TYPES] = {
X  0, 0, 0, 190, 180, 170, 160, 150, 140, 130};
Xdouble db_Adventurism[RACIAL_TYPES] = {
X  0.89, 0.89, 0.89, .6, .65, .7, .7, .75, .75, .8};
Xint Min_Sexes[RACIAL_TYPES] = {
X  1, 1, 1, 2, 2, 2, 2, 2, 2, 2};
Xint Max_Sexes[RACIAL_TYPES] = {
X  1, 1, 1, 2, 2, 4, 4, 4, 4, 4};
Xdouble db_Metabolism[RACIAL_TYPES] = {
X  3.0, 2.7, 2.4, 1.0, 1.15, 1.30, 1.45, 1.6, 1.75, 1.9};
X
X#define RMass(x) (db_Mass[(x)] + .001*(double)int_rand(-25, 25))
X#define Birthrate(x) (db_Birthrate[(x)] + .01*(double)int_rand(-10, 10))
X#define Fighters(x) (db_Fighters[(x)] + int_rand(-1, 1))
X#define Intelligence(x) (db_Intelligence[(x)] + int_rand(-10, 10))
X#define Adventurism(x) (db_Adventurism[(x)] + 0.01*(double)int_rand(-10,10))
X#define Sexes(x) (int_rand(Min_Sexes[(x)], int_rand(Min_Sexes[(x)], Max_Sexes[(x)])))
X#define Metabolism(x) (db_Metabolism[(x)] + .01*(double)int_rand(-15, 15))
X
X/* compatibility schematic for sectors.  Note that plated sectors are
X   compatible with everything.  */
Xdouble Likes[15] = {
X  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9
X};
X
Xchar *Desnames[] = {
X  "ocean",
X  "land",
X  "mountainous",
X  "gaseous",
X  "ice",
X  "forest",
X  "desert",
X  "plated",
X  "error in des type!",  /* (illegal values) */
X  "err in des type!"
X};
X
Xmain()
X{
X  int x,y, or;
X  int pnum,star=0,found=0,check,vacant,count,i,j,Playernum;
X  int ifd, mask,ppref = -1;
X  int s, idx, k;
X  char str[100], c;
X  char racepass[MAXCOMMSTRSIZE], govpass[MAXCOMMSTRSIZE];
X  sectortype *sect;
X  struct stype secttypes[WASTED+1];
X  planettype *planet;
X  unsigned char not_found[TYPE_GASGIANT+1];
X  startype *star_arena;
X  FILE *fd;
X
X  open_data_files();	
X
X  srandom(getpid());
X
X  if ( (Playernum=Numraces()+1) >= MAXPLAYERS) {
X    printf("There are already %d players; No more allowed.\n",MAXPLAYERS-1);
X    exit(-1);
X  }
X
X
X  printf("Enter racial type to be created (1-%d):", RACIAL_TYPES);
X  scanf("%d", &idx);
X  getchr();
X
X  if(idx <= 0 || idx > RACIAL_TYPES) {
X    printf("Bad racial index.\n");
X    exit(1);
X  }
X  idx=idx-1;
X  
X  getsdata(&Sdata);
X
X  star_arena = (startype *)malloc(Sdata.numstars * sizeof(startype));
X  for (s=0; s<Sdata.numstars; s++) {
X    Stars[s] = &star_arena[s];
X    getstar(&(Stars[s]),s);
X  }
X  printf("There is still space for player %d.\n", Playernum);
X
X  bzero((char *)not_found, sizeof(not_found));
X  do {
X    printf("\nLive on what type planet:\n     (e)arth, (g)asgiant, (m)ars, (i)ce, (w)ater, (d)esert, (f)orest? ");
X    c=getchr();
X    getchr();
X
X    switch (c) {
X    case 'w': 
X      ppref = TYPE_WATER;
X      break;
X    case 'e': 
X      ppref = TYPE_EARTH;
X      break;
X    case 'm': 
X      ppref = TYPE_MARS;
X      break;
X    case 'g': 
X      ppref = TYPE_GASGIANT;
X      break;
X    case 'i': 
X      ppref = TYPE_ICEBALL;
X      break;
X    case 'd': 
X      ppref = TYPE_DESERT;
X      break;
X    case 'f': 
X      ppref = TYPE_FOREST;
X      break;
X    default: 
X      printf("Oh well.\n");
X      exit(-1);
X      break;
X    }
X
X    printf("Looking for type %d planet...\n", ppref);
X
X    /* find first planet of right type */
X    count = 0;
X    found = 0;
X
X    for (star=0; star<Sdata.numstars && !found && count < 100; ) {
X
X      check = 1;
X      /* skip over inhabited stars - or stars with just one planet! */
X      if (Stars[star]->inhabited[0]+Stars[star]->inhabited[1] ||
X	  Stars[star]->numplanets<2)
X        check = 0;
X
X      /* look for uninhabited planets */
X      if (check) {
X        pnum = 0;
X        while (!found && pnum<Stars[star]->numplanets) {
X          getplanet(&planet,star,pnum);
X
X          if (planet->type==ppref && Stars[star]->numplanets!=1) {
X            vacant = 1;
X            for (i=1; i<=Playernum; i++ )
X              if (planet->info[i-1].numsectsowned)
X                vacant = 0;
X            if (vacant && planet->conditions[RTEMP] >= -50 && planet->conditions[RTEMP]
X                <= 50)
X            {
X              found = 1;
X            }
X          }
X          if (!found) {
X            free(planet);
X            pnum++;
X          }
X        }
X      }
X
X      if (!found) {
X        count++;
X        star = int_rand(0,Sdata.numstars-1);
X      }
X
X    }
X
X    if (!found) {
X      printf("planet type not found in any free systems.\n");
X      not_found[ppref] = 1;
X      for (found=1,i=TYPE_EARTH; i<=TYPE_DESERT; i++)
X        found &= not_found[i];
X      if (found) {
X        printf("Looks like there aren't any free planets left.  bye..\n");
X        endwin();
X        exit(-1);
X      } else
X        printf("  Try a different one...\n");
X      found = 0;
X    }
X
X  } while (!found);
X
X  Race = Malloc(racetype);
X  Bzero(*Race);
X
X  printf("\n\tDeity/Guest/Normal (d/g/n) ?");
X  c=getchr();
X  getchr();
X
X  Race->God = (c=='d');
X  Race->Guest = (c=='g');
X  strcpy(Race->name, "Unknown");
X
X  for(i=0; i<=MAXGOVERNORS; i++) {
X      Race->governor[0].money = 0;
X  }
X  Race->governor[0].homelevel = Race->governor[0].deflevel = LEVEL_PLAN;
X  Race->governor[0].homesystem = Race->governor[0].defsystem = star;
X  Race->governor[0].homeplanetnum = Race->governor[0].defplanetnum = pnum;
X  /* display options */
X  Race->governor[0].toggle.highlight = Playernum;
X  Race->governor[0].toggle.inverse = 1;
X  Race->governor[0].toggle.color = 0;
X  Race->governor[0].active = 1;
X  printf("Enter the password for this race:");
X  scanf("%s", Race->password);
X  getchr();
X  printf("Enter the password for this leader:");
X  scanf("%s", Race->governor[0].password);
X  getchr();
X
X
X  /* make conditions preferred by your people set to (more or less) 
X     those of the planet : higher the concentration of gas, the higher
X     percentage difference between planet and race (commented out) */
X  for (j=0; j<=OTHER; j++)
X    Race->conditions[j] = planet->conditions[j];
X  /*+ int_rand( round_rand(-planet->conditions[j]*2.0), round_rand(planet->conditions[j]*2.0) )*/
X
X
X  for (i=0; i<MAXPLAYERS; i++) {
X    /* messages from autoreport, player #1 are decodable */
X    if ((i==Playernum || Playernum==1) || Race->God)
X      Race->translate[i-1] = 100;  /* you can talk to own race */
X    else
X      Race->translate[i-1] = 1;
X  }
X
X  /* assign racial characteristics */
X  for(i=0; i<100; i++)
X    Race->discoveries[i] = 0;
X  Race->tech = 0.0;
X  Race->morale = 0;
X  Race->turn = 0;
X  Race->allied[0] = Race->allied[1] = 0;
X  Race->atwar[0] = Race->atwar[1] = 0;
X  do {
X    Race->mass = RMass(idx);
X    Race->birthrate = Birthrate(idx);
X    Race->fighters = Fighters(idx);
X    if(Thing[idx]) {
X	Race->IQ = 0;
X	Race->Metamorph = Race->absorb = Race->collective_iq = Race->pods = 1;
X    } else {
X	Race->IQ = Intelligence(idx);
X	Race->Metamorph = Race->absorb = Race->collective_iq = Race->pods = 0;
X    }
X    Race->adventurism = Adventurism(idx);
X    Race->number_sexes = Sexes(idx);
X    Race->metabolism = Metabolism(idx);
X
X    printf("%s\n", Race->Metamorph ? "METAMORPHIC" : "");
X    printf("       Birthrate: %.3f\n",Race->birthrate);
X    printf("Fighting ability: %d\n",Race->fighters);
X    printf("              IQ: %d\n",Race->IQ);
X    printf("      Metabolism: %.2f\n",Race->metabolism);
X    printf("     Adventurism: %.2f\n",Race->adventurism);
X    printf("            Mass: %.2f\n",Race->mass);
X    printf(" Number of sexes: %d (min req'd for colonization)\n",Race->number_sexes);
X
X    printf("\n\nLook OK(y/n)\?");
X    if(gets(str)==NULL)
X      exit(1);
X  } while (str[0] != 'y');
X
X  bzero((char *)secttypes, sizeof(secttypes));
X
X  getsmap(Smap,planet);
X
X  printf("\nChoose a primary sector preference. This race will prefer to live\non this type of sector.\n");
X
X  PermuteSects(planet);
X  Getxysect(planet, 0, 0, 1);
X  while (Getxysect(planet,&x,&y,0)) {
X    secttypes[Sector(*planet,x,y).condition].count++;
X    if (!secttypes[Sector(*planet,x,y).condition].here) {
X        secttypes[Sector(*planet,x,y).condition].here = 1;
X        secttypes[Sector(*planet,x,y).condition].x = x;
X        secttypes[Sector(*planet,x,y).condition].y = y;
X    }
X}
X  planet->explored = 1;
X  for (i=SEA; i<=WASTED; i++)
X    if (secttypes[i].here) {
X      printf("(%2d): %c (%d, %d) (%s, %d sectors)\n", i,
X          desshow(planet, secttypes[i].x,secttypes[i].y),
X	     secttypes[i].x, secttypes[i].y,
X	     Desnames[i], secttypes[i].count);
X    }
X  planet->explored = 0;
X
X  found = 0;
X  do {
X    printf("\nchoice (enter the number): ");
X    scanf("%d", &i);
X    getchr();
X    if (i<SEA || i>WASTED || !secttypes[i].here) {
X      printf("There are none of that type here..\n");
X    } else
X      found = 1;
X  } while (!found);
X
X  sect = &Sector(*planet,secttypes[i].x,secttypes[i].y);
X  Race->likesbest = i;
X  Race->likes[i] = 1.0;
X  Race->likes[PLATED] = 1.0;
X  Race->likes[WASTED] = 0.0;
X  printf("\nEnter compatibilities of other sectors -\n");
X  for (j=SEA; j<PLATED; j++)
X    if(i!=j) {
X      printf("%6s (%3d sectors) :", Desnames[j], secttypes[j].count);
X      scanf("%d", &k);
X      Race->likes[j]=(double)k/100.0;
X    }
X  printf("Numraces = %d\n", Numraces());
X  Playernum = Race->Playernum = Numraces() + 1;
X  
X  mask = sigblock(SIGBLOCKS);
X  /* build a capital ship to run the government */
X  {
X    shiptype s;
X    int shipno;
X
X    Bzero(s);
X    shipno = Numships() + 1;
X    printf("Creating government ship %d...\n", shipno);
X    Race->Gov_ship = shipno;
X    planet->ships = shipno;
X    s.nextship = 0;
X
X    s.type = OTYPE_GOV;
X    s.xpos = Stars[star]->xpos + planet->xpos;
X    s.ypos = Stars[star]->ypos + planet->ypos;
X    s.land_x = (char)secttypes[i].x;
X    s.land_y = (char)secttypes[i].y;
X
X    s.speed = 0;
X    s.owner = Playernum;
X    s.race = Playernum;
X    s.governor = 0;
X
X    s.tech = 100.0;
X
X    s.build_type = OTYPE_GOV;
X    s.armor = Shipdata[OTYPE_GOV][ABIL_ARMOR];
X    s.guns = PRIMARY;
X    s.primary = Shipdata[OTYPE_GOV][ABIL_GUNS];
X    s.primtype = Shipdata[OTYPE_GOV][ABIL_PRIMARY];
X    s.secondary = Shipdata[OTYPE_GOV][ABIL_GUNS];
X    s.sectype = Shipdata[OTYPE_GOV][ABIL_SECONDARY];
X    s.max_crew = Shipdata[OTYPE_GOV][ABIL_MAXCREW];
X    s.max_destruct = Shipdata[OTYPE_GOV][ABIL_DESTCAP];
X    s.max_resource = Shipdata[OTYPE_GOV][ABIL_CARGO];
X    s.max_fuel = Shipdata[OTYPE_GOV][ABIL_FUELCAP];
X    s.max_speed = Shipdata[OTYPE_GOV][ABIL_SPEED];
X    s.build_cost = Shipdata[OTYPE_GOV][ABIL_COST];
X    s.size = 100;
X    s.base_mass = 100.0;
X    sprintf(s.class, "Standard");
X
X    s.fuel = 0.0;
X    s.popn = Shipdata[s.type][ABIL_MAXCREW];
X    s.troops = 0;
X    s.mass = s.base_mass + Shipdata[s.type][ABIL_MAXCREW]*Race->mass;
X    s.destruct = s.resource = 0;
X
X    s.alive = 1;
X    s.active = 1;
X    s.protect.self = 1;
X
X    s.docked = 1;
X    /* docked on the planet */
X    s.whatorbits = LEVEL_PLAN;
X    s.whatdest = LEVEL_PLAN;
X    s.deststar = star;
X    s.destpnum = pnum;
X    s.storbits = star;
X    s.pnumorbits = pnum;
X    s.rad = 0;
X    s.damage = 0;  /*Shipdata[s.type][ABIL_DAMAGE];*/
X    /* (first capital is 100% efficient */
X    s.retaliate = 0;
X
X    s.ships = 0;
X
X    s.on = 1;
X
X    s.name[0] = '\0';
X    s.number = shipno;
X    printf("Created on sector %d,%d on /%s/%s\n",
X	   s.land_x, s.land_y, Stars[s.storbits]->name,
X	   Stars[s.storbits]->pnames[s.pnumorbits]);
X    putship(&s);
X  }
X
X  for(j=0; j<MAXPLAYERS; j++) Race->points[j]=0;
X  
X  putrace(Race);
X
X  planet->info[Playernum-1].numsectsowned = 1;
X  planet->explored = 0;
X  planet->info[Playernum-1].explored = 1;
X  /*planet->info[Playernum-1].autorep = 1;*/
X
X  sect->owner = Playernum;
X  sect->race = Playernum;
X  sect->popn = planet->popn = Race->number_sexes;
X  sect->fert = 100;
X  sect->eff = 10;
X  sect->troops = planet->troops = 0;
X  planet->maxpopn = maxsupport(Race, sect, 100.0,0)
X      * planet->Maxx * planet->Maxy / 2;
X  /* (approximate) */
X
X  putsector(sect, planet, secttypes[i].x, secttypes[i].y);
X  putplanet(planet,star,pnum);
X
X  /* make star explored and stuff */
X  getstar(&Stars[star],star);
X  setbit(Stars[star]->explored,Playernum);
X  setbit(Stars[star]->inhabited,Playernum);
X  Stars[star]->AP[Playernum-1] = 5;
X  putstar(Stars[star],star);
X  close_data_files();
X
X  sigsetmask(mask);
X
X  printf("\nYou are player %d.\n\n",Playernum);
X  printf("Your race has been created on sector %d,%d on\n",
X      secttypes[i].x,secttypes[i].y);
X  printf("%s/%s.\n\n",Stars[star]->name, Stars[star]->pnames[pnum]);
X
X}
X
Xchar desshow(p,x,y) /* copied from map.c */
Xreg planettype *p;
Xreg int x,y;
X{
X  reg sectortype *s;
X
X  s = &Sector(*p,x,y);
X
X  switch (s->condition) {
X    case WASTED:
X      return CHAR_WASTED;
X    case SEA: 
X      return CHAR_SEA;
X    case LAND: 
X      return CHAR_LAND;
X    case MOUNT: 
X      return CHAR_MOUNT;
X    case GAS: 
X      return CHAR_GAS;
X    case PLATED: 
X      return CHAR_PLATED;
X    case DESERT: 
X      return CHAR_DESERT;
X    case FOREST:
X      return CHAR_FOREST;
X    case ICE: 
X      return CHAR_ICE;
X    default: 
X      return('!');
X  }
X}
X
Xvoid notify(who, gov, msg)
Xint who, gov;
Xchar *msg;
X{
X  /* this is a dummy routine */
X}
X
Xvoid warn(who, gov, msg)
Xint who, gov;
Xchar *msg;
X{
X  /* this is a dummy routine */
X}
X
Xvoid push_message(what, who, msg)
Xint what, who;
Xchar *msg;
X{
X  /* this is a dummy routine */
X}
END_OF_FILE
if test 13967 -ne `wc -c <'utils/enrol.c'`; then
    echo shar: \"'utils/enrol.c'\" unpacked with wrong size!
fi
# end of 'utils/enrol.c'
fi
echo shar: End of archive 13 \(of 21\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
