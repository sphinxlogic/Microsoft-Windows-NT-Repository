Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i018:  gbp - Galactic Bloodshed+, an empire-like war game, Part06/21
Message-ID: <4546@master.CNA.TEK.COM>
Date: 12 Feb 93 17:30:33 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1691
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1697

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 18
Archive-name: gbp/Part06
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 21)."
# Contents:  hdrs/interface.h user/name.c utils/makeplanet.c
# Wrapped by billr@saab on Fri Feb 12 09:14:25 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'hdrs/interface.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdrs/interface.h'\"
else
echo shar: Extracting \"'hdrs/interface.h'\" \(443 characters\)
sed "s/^X//" >'hdrs/interface.h' <<'END_OF_FILE'
X#include "TinyMUD_copyright.h"
X
X/* these symbols must be defined by the interface */
Xextern int notify();
Xextern int shutdown_flag; /* if non-zero, interface should shut down */
Xextern void emergency_shutdown();
X
X/* the following symbols are provided by game.c */
X
X/* max length of command argument to process_command */
X#define MAX_COMMAND_LEN 512
X#define BUFFER_LEN ((MAX_COMMAND_LEN)*8)
Xextern void process_command();
X
Xextern void panic();
END_OF_FILE
if test 443 -ne `wc -c <'hdrs/interface.h'`; then
    echo shar: \"'hdrs/interface.h'\" unpacked with wrong size!
fi
# end of 'hdrs/interface.h'
fi
if test -f 'user/name.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/name.c'\"
else
echo shar: Extracting \"'user/name.c'\" \(34058 characters\)
sed "s/^X//" >'user/name.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * name.c -- rename something to something else announce.c -- make announcements
X * in the system you currently in. You must be inhabiting that system for
X * your message to sent. You must also be in that system (and inhabiting) to
X * receive announcements. page.c -- send a message to a player requesting his
X * presence in a system.
X */
X#include <ctype.h>
X#include <signal.h>
X#include <strings.h>
X#include <time.h>
X#include <math.h>
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "races.h"
X#include "power.h"
X#include "ships.h"
X#include "buffers.h"
X#include "config.h"
X
Xchar            msg[1024];
Xstruct tm      *current_tm;	/* for watching for next update */
Xlong            clk;
X
Xvoid            personal(int, int, char *);
Xvoid            bless(int, int, int);
Xvoid            insurgency(int, int, int);
Xvoid            pay(int, int, int);
Xvoid            give(int, int, int);
Xvoid            page(int, int, int);
Xvoid            send_message(int, int, int, int);
Xvoid            read_messages(int, int, int);
Xvoid            motto(int, int, int, char *);
Xvoid            name(int, int, int);
Xint             MostAPs(int, startype *);
Xvoid            announce(int, int, char *, int, int);
X#include "proto.h"
X
Xvoid 
Xpersonal(int Playernum, int Governor, char *message)
X{
X	racetype       *Race;
X
X	if (Governor) {
X		notify(Playernum, Governor, "Only the leader can do this.\n");
X		return;
X	}
X	Race = races[Playernum - 1];
X	strncpy(Race->info, message, PERSONALSIZE - 1);
X	putrace(Race);
X}
X
Xvoid 
Xbless(int Playernum, int Governor, int APcount)
X{
X	planettype     *planet;
X	racetype       *Race;
X	int             who, amount, Mod;
X	char            commod;
X
X	Race = races[Playernum - 1];
X	if (!Race->God) {
X		notify(Playernum, Governor, "You are not privileged to use this command.\n");
X		return;
X	}
X	if (Dir[Playernum - 1][Governor].level != LEVEL_PLAN) {
X		notify(Playernum, Governor, "Please cs to the planet in question.\n");
X		return;
X	}
X	who = atoi(args[1]);
X	if (who < 1 || who > Num_races) {
X		notify(Playernum, Governor, "No such player number.\n");
X		return;
X	}
X	if (argn < 3) {
X		notify(Playernum, Governor, "Syntax: bless <player> <what> <+amount>\n");
X		return;
X	}
X	amount = atoi(args[3]);
X
X	Race = races[who - 1];
X	/* race characteristics? */
X	Mod = 1;
X
X	if (match(args[2], "money")) {
X		Race->governor[0].money += amount;
X		sprintf(buf, "Deity gave you %d money.\n", amount);
X	} else if (match(args[2], "password")) {
X		strcpy(Race->password, args[3]);
X		sprintf(buf, "Deity changed your race password to `%s'\n", args[3]);
X	} else if (match(args[2], "morale")) {
X		Race->morale += amount;
X		sprintf(buf, "Deity gave you %d morale.\n", amount);
X	} else if (match(args[2], "pods")) {
X		Race->pods = 1;
X		sprintf(buf, "Deity gave you pod ability.\n");
X	} else if (match(args[2], "nopods")) {
X		Race->pods = 0;
X		sprintf(buf, "Deity took away pod ability.\n");
X	} else if (match(args[2], "collectiveiq")) {
X		Race->collective_iq = 1;
X		sprintf(buf, "Deity gave you collective intelligence.\n");
X	} else if (match(args[2], "nocollectiveiq")) {
X		Race->collective_iq = 0;
X		sprintf(buf, "Deity took away collective intelligence.\n");
X	} else if (match(args[2], "maxiq")) {
X		Race->IQ_limit = atoi(args[3]);
X		sprintf(buf, "Deity gave you a maximum IQ of %d.\n", Race->IQ_limit);
X	} else if (match(args[2], "mass")) {
X		Race->mass = atof(args[3]);
X		sprintf(buf, "Deity gave you %.2f mass.\n", Race->mass);
X	} else if (match(args[2], "metabolism")) {
X		Race->metabolism = atof(args[3]);
X		sprintf(buf, "Deity gave you %.2f metabolism.\n", Race->metabolism);
X	} else if (match(args[2], "adventurism")) {
X		Race->adventurism = atof(args[3]);
X		sprintf(buf, "Deity gave you %-3.0f%% adventurism.\n", Race->adventurism * 100.0);
X	} else if (match(args[2], "birthrate")) {
X		Race->birthrate = atof(args[3]);
X		sprintf(buf, "Deity gave you %.2f birthrate.\n", Race->birthrate);
X	} else if (match(args[2], "fertility")) {
X		Race->fertilize = amount;
X		sprintf(buf, "Deity gave you a fetilization ability of %d.\n", amount);
X	} else if (match(args[2], "IQ")) {
X		Race->IQ = amount;
X		sprintf(buf, "Deity gave you %d IQ.\n", amount);
X	} else if (match(args[2], "fight")) {
X		Race->fighters = amount;
X		sprintf(buf, "Deity set your fighting ability to %d.\n", amount);
X	} else if (match(args[2], "technology")) {
X		Race->tech += (double) amount;
X		sprintf(buf, "Deity gave you %d technology.\n", amount);
X	} else if (match(args[2], "guest")) {
X		Race->Guest = 1;
X		sprintf(buf, "Deity turned you into a guest race.\n");
X	} else if (match(args[2], "god")) {
X		Race->God = 1;
X		sprintf(buf, "Deity turned you into a deity race.\n");
X	} else if (match(args[2], "mortal")) {
X		Race->God = 0;
X		Race->Guest = 0;
X		sprintf(buf, "Deity turned you into a mortal race.\n");
X		/* sector preferences */
X	} else if (match(args[2], "water")) {
X		Race->likes[SEA] = 0.01 * (double) amount;
X		sprintf(buf, "Deity set your water preference to %d%%\n", amount);
X	} else if (match(args[2], "land")) {
X		Race->likes[LAND] = 0.01 * (double) amount;
X		sprintf(buf, "Deity set your land preference to %d%%\n", amount);
X	} else if (match(args[2], "mountain")) {
X		Race->likes[MOUNT] = 0.01 * (double) amount;
X		sprintf(buf, "Deity set your mountain preference to %d%%\n", amount);
X	} else if (match(args[2], "gas")) {
X		Race->likes[GAS] = 0.01 * (double) amount;
X		sprintf(buf, "Deity set your gas preference to %d%%\n", amount);
X	} else if (match(args[2], "ice")) {
X		Race->likes[ICE] = 0.01 * (double) amount;
X		sprintf(buf, "Deity set your ice preference to %d%%\n", amount);
X	} else if (match(args[2], "forest")) {
X		Race->likes[FOREST] = 0.01 * (double) amount;
X		sprintf(buf, "Deity set your forest preference to %d%%\n", amount);
X	} else if (match(args[2], "desert")) {
X		Race->likes[DESERT] = 0.01 * (double) amount;
X		sprintf(buf, "Deity set your desert preference to %d%%\n", amount);
X	} else if (match(args[2], "plated")) {
X		Race->likes[PLATED] = 0.01 * (double) amount;
X		sprintf(buf, "Deity set your plated preference to %d%%\n", amount);
X	} else
X		Mod = 0;
X	if (Mod) {
X		putrace(Race);
X		warn(who, 0, buf);
X	}
X	if (Mod)
X		return;
X	/* ok, must be the planet then */
X	commod = args[2][0];
X	getplanet(&planet, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X	if (match(args[2], "explorebit")) {
X		planet->info[who - 1].explored = 1;
X		getstar(&Stars[Dir[Playernum - 1][Governor].snum], Dir[Playernum - 1][Governor].snum);
X		setbit(Stars[Dir[Playernum - 1][Governor].snum]->explored, who);
X		putstar(Stars[Dir[Playernum - 1][Governor].snum], Dir[Playernum - 1][Governor].snum);
X		sprintf(buf, "Deity set your explored bit at /%s/%s.\n",
X			Stars[Dir[Playernum - 1][Governor].snum]->name,
X			Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum]);
X	} else if (match(args[2], "noexplorebit")) {
X		planet->info[who - 1].explored = 0;
X		sprintf(buf, "Deity reset your explored bit at /%s/%s.\n",
X			Stars[Dir[Playernum - 1][Governor].snum]->name,
X			Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum]);
X	} else if (match(args[2], "planetpopulation")) {
X		planet->info[who - 1].popn = atoi(args[3]);
X		planet->popn++;
X		sprintf(buf, "Deity set your population variable to %d at /%s/%s.\n",
X			Stars[Dir[Playernum - 1][Governor].snum]->name,
X			Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum]);
X	} else if (match(args[2], "inhabited")) {
X		getstar(&Stars[Dir[Playernum - 1][Governor].snum], Dir[Playernum - 1][Governor].snum);
X		setbit(Stars[Dir[Playernum - 1][Governor].snum]->inhabited, Playernum);
X		putstar(Stars[Dir[Playernum - 1][Governor].snum], Dir[Playernum - 1][Governor].snum);
X		sprintf(buf, "Deity has set your inhabited bit for /%s/%s.\n",
X			Stars[Dir[Playernum - 1][Governor].snum]->name,
X			Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum]);
X	} else if (match(args[2], "numsectsowned")) {
X		planet->info[who - 1].numsectsowned = atoi(args[3]);
X		sprintf(buf, "Deity set your \"numsectsowned\" variable at /%s/%s to %d.\n",
X			Stars[Dir[Playernum - 1][Governor].snum]->name,
X			Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum],
X			planet->info[who - 1].numsectsowned);
X	} else {
X		switch (commod) {
X		case 'r':
X			planet->info[who - 1].resource += amount;
X			sprintf(buf, "Deity gave you %d resources at %s/%s.\n",
X				amount,
X			     Stars[Dir[Playernum - 1][Governor].snum]->name,
X				Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum]);
X			break;
X		case 'd':
X			planet->info[who - 1].destruct += amount;
X			sprintf(buf, "Deity gave you %d destruct at %s/%s.\n",
X				amount,
X			     Stars[Dir[Playernum - 1][Governor].snum]->name,
X				Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum]);
X			break;
X		case 'f':
X			planet->info[who - 1].fuel += amount;
X			sprintf(buf, "Deity gave you %d fuel at %s/%s.\n",
X				amount,
X			     Stars[Dir[Playernum - 1][Governor].snum]->name,
X				Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum]);
X			break;
X		case 'x':
X			planet->info[who - 1].crystals += amount;
X			sprintf(buf, "Deity gave you %d crystals at %s/%s.\n",
X				amount,
X			     Stars[Dir[Playernum - 1][Governor].snum]->name,
X				Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum]);
X			break;
X		case 'a':
X			getstar(&Stars[Dir[Playernum - 1][Governor].snum], Dir[Playernum - 1][Governor].snum);
X			Stars[Dir[Playernum - 1][Governor].snum]->AP[who - 1] += amount;
X			putstar(Stars[Dir[Playernum - 1][Governor].snum], Dir[Playernum - 1][Governor].snum);
X			sprintf(buf, "Deity gave you %d action points at %s.\n",
X				amount,
X			    Stars[Dir[Playernum - 1][Governor].snum]->name);
X			break;
X		default:
X			notify(Playernum, Governor, "No such commodity.\n");
X			free(planet);
X			return;
X		}
X	}
X	putplanet(planet, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X	warn_race(who, buf);
X	free(planet);
X}
X
Xvoid 
Xinsurgency(int Playernum, int Governor, int APcount)
X{
X	int             who, amount, eligible, them = 0;
X	racetype       *Race, *alien;
X	planettype     *p;
X	double          x;
X	int             changed_hands, chance;
X	register int    i;
X
X	if (Dir[Playernum - 1][Governor].level != LEVEL_PLAN) {
X		notify(Playernum, Governor, "You must 'cs' to the planet you wish to try it on.\n");
X		return;
X	}
X	if (!control(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum])) {
X		notify(Playernum, Governor, "You are not authorized to do that here.\n");
X		return;
X	}
X	/*
X	 * if(argn<3) { notify(Playernum, Governor, "The correct syntax is
X	 * 'insurgency <race> <money>'\n"); return; }
X	 */
X	if (!enufAP(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1], APcount))
X		return;
X	if (!(who = GetPlayer(args[1]))) {
X		sprintf(buf, "No such player.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	Race = races[Playernum - 1];
X	alien = races[who - 1];
X	if (alien->Guest) {
X		notify(Playernum, Governor, "Don't be such a dickweed.\n");
X		return;
X	}
X	if (who == Playernum) {
X		notify(Playernum, Governor, "You can't revolt against yourself!\n");
X		return;
X	}
X	eligible = 0;
X	them = 0;
X	for (i = 0; i < Stars[Dir[Playernum - 1][Governor].snum]->numplanets; i++) {
X		getplanet(&p, Dir[Playernum - 1][Governor].snum, i);
X		eligible += p->info[Playernum - 1].popn;
X		them += p->info[who - 1].popn;
X		free(p);
X	}
X	if (!eligible) {
X		notify(Playernum, Governor, "You must have population in the star system to attempt insurgency\n.");
X		return;
X	}
X	getplanet(&p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X
X	if (!p->info[who - 1].popn) {
X		notify(Playernum, Governor, "This player does not occupy this planet.\n");
X		free(p);
X		return;
X	}
X	sscanf(args[2], "%d", &amount);
X	if (amount < 0) {
X		notify(Playernum, Governor, "You have to use a positive amount of money.\n");
X		free(p);
X		return;
X	}
X	if (Race->governor[Governor].money < amount) {
X		notify(Playernum, Governor, "Nice try.\n");
X		free(p);
X		return;
X	}
X	x = INSURG_FACTOR * (double) amount *
X	                (double) p->info[who - 1].tax / (double) p->info[who - 1].popn;
X	x *= morale_factor((double) (Race->morale - alien->morale));
X	x *= morale_factor((double) (eligible - them) / 50.0);
X	x *= morale_factor(10.0 * (double) (Race->fighters * p->info[Playernum - 1].troops -
X			 alien->fighters * p->info[who - 1].troops)) / 50.0;
X	sprintf(buf, "x = %f\n", x);
X	notify(Playernum, Governor, buf);
X	chance = round_rand(200.0 * atan((double) x) / 3.14159265);
X	sprintf(long_buf, "%s/%s: %s [%d] tries insurgency vs %s [%d]\n",
X		Stars[Dir[Playernum - 1][Governor].snum]->name,
X		Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum],
X		Race->name, Playernum, alien->name, who);
X	sprintf(buf, "\t%s: %d total civs [%d]  opposing %d total civs [%d]\n",
X		Stars[Dir[Playernum - 1][Governor].snum]->name,
X		eligible, Playernum, them, who);
X	strcat(long_buf, buf);
X	sprintf(buf, "\t\t %d morale [%d] vs %d morale [%d]\n",
X		Race->morale, Playernum, alien->morale, who);
X	strcat(long_buf, buf);
X	sprintf(buf, "\t\t %d money against %d population at tax rate %d%%\n",
X		amount, p->info[who - 1].popn, p->info[who - 1].tax);
X	strcat(long_buf, buf);
X	sprintf(buf, "Success chance is %d%%\n", chance);
X	strcat(long_buf, buf);
X	if (success(chance)) {
X		changed_hands = revolt(p, who, Playernum);
X		notify(Playernum, Governor, long_buf);
X		sprintf(buf, "Success!  You liberate %d sector%s.\n", changed_hands,
X			(changed_hands == 1) ? "" : "s");
X		notify(Playernum, Governor, buf);
X		sprintf(buf,
X			"A revolt on /%s/%s instigated by %s [%d] costs you %d sector%s\n",
X			Stars[Dir[Playernum - 1][Governor].snum]->name,
X			Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum],
X			Race->name, Playernum,
X			changed_hands, (changed_hands == 1) ? "" : "s");
X		strcat(long_buf, buf);
X		warn(who, (int) Stars[Dir[Playernum - 1][Governor].snum]->governor[who - 1], long_buf);
X		p->info[Playernum - 1].tax = p->info[who - 1].tax;
X		/* you inherit their tax rate (insurgency wars he he ) */
X		sprintf(buf, "/%s/%s: Successful insurgency by %s [%d] against %s [%d]\n",
X			Stars[Dir[Playernum - 1][Governor].snum]->name,
X			Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum],
X			Race->name, Playernum, alien->name, who);
X		post(buf, DECLARATION);
X	} else {
X		notify(Playernum, Governor, long_buf);
X		notify(Playernum, Governor, "The insurgency failed!\n");
X		sprintf(buf,
X			"A revolt on /%s/%s instigated by %s [%d] fails\n",
X			Stars[Dir[Playernum - 1][Governor].snum]->name,
X			Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum],
X			Race->name, Playernum);
X		strcat(long_buf, buf);
X		warn(who, (int) Stars[Dir[Playernum - 1][Governor].snum]->governor[who - 1], long_buf);
X		sprintf(buf, "/%s/%s: Failed insurgency by %s [%d] against %s [%d]\n",
X			Stars[Dir[Playernum - 1][Governor].snum]->name,
X			Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum],
X			Race->name, Playernum, alien->name, who);
X		post(buf, DECLARATION);
X	}
X	deductAPs(Playernum, Governor, APcount, Dir[Playernum - 1][Governor].snum, 0);
X	Race->governor[Governor].money -= amount;
X	putrace(Race);
X	free(p);
X}
X
Xvoid 
Xpay(int Playernum, int Governor, int APcount)
X{
X	int             who, amount;
X	racetype       *Race, *alien;
X
X	if (!(who = GetPlayer(args[1]))) {
X		sprintf(buf, "No such player.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	if (Governor) {
X		notify(Playernum, Governor, "You are not authorized to do that.\n");
X		return;
X	}
X	Race = races[Playernum - 1];
X	alien = races[who - 1];
X
X	sscanf(args[2], "%d", &amount);
X	if (amount < 0) {
X		notify(Playernum, Governor, "You have to give a player a positive amount of money.\n");
X		return;
X	}
X	if (Race->Guest) {
X		notify(Playernum, Governor, "Nice try. Your attempt has been duly noted.\n");
X		return;
X	}
X	if (Race->governor[Governor].money < amount) {
X		notify(Playernum, Governor, "You don't have that much money to give!\n");
X		return;
X	}
X	Race->governor[Governor].money -= amount;
X	alien->governor[0].money += amount;
X	sprintf(buf, "%s [%d] payed you %d.\n", Race->name, Playernum, amount);
X	warn(who, 0, buf);
X	sprintf(buf, "%d payed to %s [%d].\n", amount, alien->name, who);
X	notify(Playernum, Governor, buf);
X
X	sprintf(buf, "%s [%d] pays %s [%d].\n", Race->name,
X		Playernum, alien->name, who);
X	post(buf, TRANSFER);
X
X	putrace(alien);
X	putrace(Race);
X}
X
Xvoid 
Xgive(int Playernum, int Governor, int APcount)
X{
X	int             who, sh;
X	shiptype       *ship;
X	planettype     *planet;
X	racetype       *Race, *alien;
X
X	if (!(who = GetPlayer(args[1]))) {
X		sprintf(buf, "No such player.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	if (Governor) {
X		notify(Playernum, Governor, "You are not authorized to do that.\n");
X		return;
X	}
X	alien = races[who - 1];
X	Race = races[Playernum - 1];
X	if (alien->Guest && !Race->God) {
X		notify(Playernum, Governor, "You can't give this player anything.\n");
X		return;
X	}
X	if (Race->Guest) {
X		notify(Playernum, Governor, "You can't give anyone anything.\n");
X		return;
X	}
X	/* check to see if both players are mutually allied */
X	if (!Race->God &&
X	    !(isset(Race->allied, who) && isset(alien->allied, Playernum))) {
X		notify(Playernum, Governor, "You two are not mutually allied.\n");
X		return;
X	}
X	sscanf(args[2] + (args[2][0] == '#'), "%d", &sh);
X
X	if (!getship(&ship, sh)) {
X		notify(Playernum, Governor, "Illegal ship number.\n");
X		return;
X	}
X	if (ship->owner != Playernum || !ship->alive) {
X		DontOwnErr(Playernum, Governor, sh);
X		free(ship);
X		return;
X	}
X	if (ship->type == STYPE_POD) {
X		notify(Playernum, Governor, "You cannot change the ownership of spore pods.\n");
X		free(ship);
X		return;
X	}
X	if ((ship->popn + ship->troops) && !Race->God) {
X		notify(Playernum, Governor, "You can't give this ship away while it has crew/mil on board.\n");
X		free(ship);
X		return;
X	}
X	if (ship->ships && !Race->God) {
X		notify(Playernum, Governor, "You can't give away this ship, it has other ships loaded on it.\n");
X		free(ship);
X		return;
X	}
X	switch (ship->whatorbits) {
X	case LEVEL_UNIV:
X		if (!enufAP(Playernum, Governor, Sdata.AP[Playernum - 1], APcount)) {
X			free(ship);
X			return;
X		}
X		break;
X	default:
X		if (!enufAP(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1], APcount)) {
X			free(ship);
X			return;
X		}
X		break;
X	}
X
X	ship->owner = who;
X	ship->governor = 0;	/* give to the leader */
X	capture_stuff(ship);
X
X	putship(ship);
X
X	/* set inhabited/explored bits */
X	switch (ship->whatorbits) {
X	case LEVEL_UNIV:
X		break;
X	case LEVEL_STAR:
X		getstar(&(Stars[ship->storbits]), (int) ship->storbits);
X		setbit(Stars[ship->storbits]->explored, who);
X		putstar(Stars[ship->storbits], (int) ship->storbits);
X		break;
X	case LEVEL_PLAN:
X		getstar(&(Stars[ship->storbits]), (int) ship->storbits);
X		setbit(Stars[ship->storbits]->explored, who);
X		putstar(Stars[ship->storbits], (int) ship->storbits);
X
X		getplanet(&planet, (int) ship->storbits, (int) ship->pnumorbits);
X		planet->info[who - 1].explored = 1;
X		putplanet(planet, (int) ship->storbits, (int) ship->pnumorbits);
X		free(planet);
X
X		break;
X	default:
X		notify(Playernum, Governor, "Something wrong with this ship's scope.\n");
X		free(ship);
X		return;
X	}
X
X	switch (ship->whatorbits) {
X	case LEVEL_UNIV:
X		deductAPs(Playernum, Governor, APcount, 0, 1);
X		free(ship);
X		return;
X	default:
X		deductAPs(Playernum, Governor, APcount, Dir[Playernum - 1][Governor].snum, 0);
X		break;
X	}
X	notify(Playernum, Governor, "Owner changed.\n");
X	sprintf(buf, "%s [%d] gave you %s at %s.\n", Race->name, Playernum,
X		Ship(ship), prin_ship_orbits(ship));
X	warn(who, 0, buf);
X
X	if (!Race->God) {
X		sprintf(buf, "%s [%d] gives %s [%d] a ship.\n", Race->name,
X			Playernum, alien->name, who);
X		post(buf, TRANSFER);
X		free(ship);
X	}
X}
X
Xvoid 
Xpage(int Playernum, int Governor, int APcount0)
X{
X	int             i, who, gov, to_block, dummy[2], APcount;
X	racetype       *Race, *alien;
X
X	APcount = APcount0;
X	if (!enufAP(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1], APcount))
X		return;
X
X	to_block = 0;
X	if (match(args[1], "block")) {
X		to_block = 1;
X		notify(Playernum, Governor, "Paging alliance block.\n");
X	} else {
X		if (!(who = GetPlayer(args[1]))) {
X			sprintf(buf, "No such player.\n");
X			notify(Playernum, Governor, buf);
X			return;
X		}
X		alien = races[who - 1];
X		APcount *= !alien->God;
X		if (argn > 1)
X			gov = atoi(args[2]);
X	}
X
X	switch (Dir[Playernum - 1][Governor].level) {
X	case LEVEL_UNIV:
X		sprintf(buf, "You can't make pages at universal scope.\n");
X		notify(Playernum, Governor, buf);
X		break;
X	default:
X		getstar(&Stars[Dir[Playernum - 1][Governor].snum], Dir[Playernum - 1][Governor].snum);
X		if (!enufAP(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1], APcount)) {
X			return;
X		}
X		Race = races[Playernum - 1];
X
X		sprintf(buf, "%s \"%s\" page(s) you from the %s star system.\n",
X			Race->name, Race->governor[Governor].name,
X			Stars[Dir[Playernum - 1][Governor].snum]->name);
X
X		if (to_block) {
X			dummy[0] = Blocks[Playernum - 1].invite[0] & Blocks[Playernum - 1].pledge[0];
X			dummy[1] = Blocks[Playernum - 1].invite[1] & Blocks[Playernum - 1].pledge[1];
X			for (i = 1; i <= Num_races; i++)
X				if (isset(dummy, i) && i != Playernum)
X					notify_race(i, buf);
X		} else {
X			if (argn > 1)
X				notify(who, gov, buf);
X			else
X				notify_race(who, buf);
X		}
X
X		notify(Playernum, Governor, "Request sent.\n");
X		break;
X	}
X	deductAPs(Playernum, Governor, APcount, Dir[Playernum - 1][Governor].snum, 0);
X}
X
Xvoid 
Xsend_message(int Playernum, int Governor, int APcount0, int postit)
X{
X	int             who, i, j, to_block, dummy[2], APcount;
X	int             to_star, star, start;
X	placetype       where;
X	racetype       *Race, *alien;
X
X	APcount = APcount0;
X
X	to_star = to_block = 0;
X
X	if (argn < 2) {
X		notify(Playernum, Governor, "Send what?\n");
X		return;
X	}
X	if (postit) {
X		Race = races[Playernum - 1];
X		sprintf(msg, "%s \"%s\" [%d,%d]: ",
X			Race->name, Race->governor[Governor].name,
X			Playernum, Governor);
X		/* put the message together */
X		for (j = 1; j < argn; j++) {
X			sprintf(buf, "%s ", args[j]);
X			strcat(msg, buf);
X		}
X		strcat(msg, "\n");
X		post(msg, ANNOUNCE);
X		return;
X	}
X	if (match(args[1], "block")) {
X		to_block = 1;
X		notify(Playernum, Governor, "Sending message to alliance block.\n");
X		if (!(who = GetPlayer(args[2]))) {
X			sprintf(buf, "No such alliance block.\n");
X			notify(Playernum, Governor, buf);
X			return;
X		}
X		alien = races[who - 1];
X		APcount *= !alien->God;
X	} else if (match(args[1], "star")) {
X		to_star = 1;
X		notify(Playernum, Governor, "Sending message to star system.\n");
X		where = Getplace(Playernum, Governor, args[2], 1);
X		if (where.err || where.level != LEVEL_STAR) {
X			sprintf(buf, "No such star.\n");
X			notify(Playernum, Governor, buf);
X			return;
X		}
X		star = where.snum;
X		getstar(&(Stars[star]), star);
X	} else {
X		if (!(who = GetPlayer(args[1]))) {
X			sprintf(buf, "No such player.\n");
X			notify(Playernum, Governor, buf);
X			return;
X		}
X		alien = races[who - 1];
X		APcount *= !alien->God;
X	}
X
X	switch (Dir[Playernum - 1][Governor].level) {
X	case LEVEL_UNIV:
X		sprintf(buf, "You can't send messages from universal scope.\n");
X		notify(Playernum, Governor, buf);
X		return;
X
X	case LEVEL_SHIP:
X		sprintf(buf, "You can't send messages from ship scope.\n");
X		notify(Playernum, Governor, buf);
X		return;
X
X	default:
X		getstar(&Stars[Dir[Playernum - 1][Governor].snum], Dir[Playernum - 1][Governor].snum);
X		if (!enufAP(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1], APcount))
X			return;
X		break;
X	}
X
X	Race = races[Playernum - 1];
X
X	/* send the message */
X	if (to_block)
X		sprintf(msg, "%s \"%s\" [%d,%d] to %s [%d]: ", Race->name,
X			Race->governor[Governor].name, Playernum, Governor,
X			Blocks[who - 1].name, who);
X	else if (to_star)
X		sprintf(msg, "%s \"%s\" [%d,%d] to inhabitants of %s: ", Race->name,
X			Race->governor[Governor].name, Playernum,
X			Governor, Stars[star]->name);
X	else
X		sprintf(msg, "%s \"%s\" [%d,%d]: ", Race->name,
X			Race->governor[Governor].name, Playernum, Governor);
X
X	if (to_star || to_block || isdigit(*args[2]))
X		start = 3;
X	else if (postit)
X		start = 1;
X	else
X		start = 2;
X	/* put the message together */
X	for (j = start; j < argn; j++) {
X		sprintf(buf, "%s ", args[j]);
X		strcat(msg, buf);
X	}
X	/* post it */
X	sprintf(buf, "%s \"%s\" [%d,%d] has sent you a telegram. Use `read' to read it.\n",
X		Race->name, Race->governor[Governor].name,
X		Playernum, Governor);
X	if (to_block) {
X		dummy[0] = (Blocks[who - 1].invite[0] & Blocks[who - 1].pledge[0]);
X		dummy[1] = (Blocks[who - 1].invite[1] & Blocks[who - 1].pledge[1]);
X		sprintf(buf, "%s \"%s\" [%d,%d] sends a message to %s [%d] alliance block.\n",
X			Race->name, Race->governor[Governor].name, Playernum, Governor,
X			Blocks[who - 1].name, who);
X		for (i = 1; i <= Num_races; i++) {
X			if (isset(dummy, i)) {
X				notify_race(i, buf);
X				push_telegram_race(i, msg);
X			}
X		}
X	} else if (to_star) {
X		sprintf(buf, "%s \"%s\" [%d,%d] sends a stargram to %s.\n", Race->name,
X			Race->governor[Governor].name, Playernum,
X			Governor, Stars[star]->name);
X		notify_star(Playernum, Governor, 0, star, buf);
X		warn_star(Playernum, 0, star, msg);
X	} else {
X		int             gov;
X		if (who == Playernum)
X			APcount = 0;
X		if (isdigit(*args[2]) && (gov = atoi(args[2])) >= 0 && gov <= MAXGOVERNORS) {
X			push_telegram(who, gov, msg);
X			notify(who, gov, buf);
X		} else {
X			push_telegram_race(who, msg);
X			notify_race(who, buf);
X		}
X
X		alien = races[who - 1];
X		/* translation modifier increases */
X		alien->translate[Playernum - 1] = MIN(alien->translate[Playernum - 1] + 2, 100);
X		putrace(alien);
X	}
X	notify(Playernum, Governor, "Message sent.\n");
X	deductAPs(Playernum, Governor, APcount, Dir[Playernum - 1][Governor].snum, 0);
X}
X
Xvoid 
Xread_messages(int Playernum, int Governor, int APcount)
X{
X	if (argn == 1 || match(args[1], "telegram"))
X		teleg_read(Playernum, Governor);
X	else if (match(args[1], "news")) {
X		notify(Playernum, Governor, CUTE_MESSAGE);
X		notify(Playernum, Governor, "\n----------        Declarations        ----------\n");
X		news_read(Playernum, Governor, DECLARATION);
X		notify(Playernum, Governor, "\n----------           Combat           ----------\n");
X		news_read(Playernum, Governor, COMBAT);
X		notify(Playernum, Governor, "\n----------          Business          ----------\n");
X		news_read(Playernum, Governor, TRANSFER);
X		notify(Playernum, Governor, "\n----------          Bulletins         ----------\n");
X		news_read(Playernum, Governor, ANNOUNCE);
X	} else
X		notify(Playernum, Governor, "Read what?\n");
X}
X
Xvoid 
Xmotto(int Playernum, int Governor, int APcount, char *message)
X{
X	if (Governor) {
X		notify(Playernum, Governor, "You are not authorized to do this.\n");
X		return;
X	}
X	strncpy(Blocks[Playernum - 1].motto, message, MOTTOSIZE - 1);
X	Putblock(Blocks);
X	notify(Playernum, Governor, "Done.\n");
X}
X
Xvoid 
Xname(int Playernum, int Governor, int APcount)
X{
X	char           *ch;
X	register int    i, spaces;
X	int             len;
X	unsigned char   check = 0;
X	shiptype       *ship;
X	char            string[1024];
X	char            temp[128];
X	racetype       *Race;
X
X	if (!isalnum(args[2][0]) || argn < 3) {
X		notify(Playernum, Governor, "Illegal name format.\n");
X		return;
X	}
X	sprintf(buf, "%s", args[2]);
X	for (i = 3; i < argn; i++) {
X		sprintf(temp, " %s", args[i]);
X		strcat(buf, temp);
X	}
X
X	sprintf(string, "%s", buf);
X
X	i = strlen(args[0]);
X
X	/*
X	 * make sure there are no ^'s or '/' in name, also make sure the name
X	 * has at least 1 character in it
X	 */
X	ch = string;
X	spaces = 0;
X	while (*ch != '\0') {
X		check |= ((!isalnum(*ch) && !(*ch == ' ') && !(*ch == '.')) || (*ch == '/'));
X		ch++;
X		if (*ch == ' ')
X			spaces++;
X	}
X
X	len = strlen(buf);
X	if (spaces == strlen(buf)) {
X		notify(Playernum, Governor, "Illegal name.\n");
X		return;
X	}
X	if (strlen(buf) < 1 || check) {
X		sprintf(buf, "Illegal name %s.\n", check ? "form" : "length");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	if (match(args[1], "ship")) {
X		if (Dir[Playernum - 1][Governor].level == LEVEL_SHIP) {
X			(void) getship(&ship, Dir[Playernum - 1][Governor].shipno);
X			strncpy(ship->name, buf, SHIP_NAMESIZE);
X			putship(ship);
X			notify(Playernum, Governor, "Name set.\n");
X			free(ship);
X			return;
X		} else {
X			notify(Playernum, Governor, "You have to 'cs' to a ship to name it.\n");
X			return;
X		}
X	} else if (match(args[1], "class")) {
X		if (Dir[Playernum - 1][Governor].level == LEVEL_SHIP) {
X			(void) getship(&ship, Dir[Playernum - 1][Governor].shipno);
X			if (ship->type != OTYPE_FACTORY) {
X				notify(Playernum, Governor, "You are not at a factory!\n");
X				free(ship);
X				return;
X			}
X			if (ship->on) {
X				notify(Playernum, Governor, "This factory is already on line.\n");
X				free(ship);
X				return;
X			}
X			strncpy(ship->class, buf, SHIP_NAMESIZE - 1);
X			putship(ship);
X			notify(Playernum, Governor, "Class set.\n");
X			free(ship);
X			return;
X		} else {
X			notify(Playernum, Governor, "You have to 'cs' to a factory to name the ship class.\n");
X			return;
X		}
X	} else if (match(args[1], "block")) {
X		/* name your alliance block */
X		if (Governor) {
X			notify(Playernum, Governor, "You are not authorized to do this.\n");
X			return;
X		}
X		strncpy(Blocks[Playernum - 1].name, buf, RNAMESIZE - 1);
X		Putblock(Blocks);
X		notify(Playernum, Governor, "Done.\n");
X	} else if (match(args[1], "star")) {
X		if (Dir[Playernum - 1][Governor].level == LEVEL_STAR) {
X			Race = races[Playernum - 1];
X			if (!Race->God) {
X				notify(Playernum, Governor, "Only dieties may name a star.\n");
X				return;
X			}
X			strncpy(Stars[Dir[Playernum - 1][Governor].snum]->name, buf, NAMESIZE - 1);
X			putstar(Stars[Dir[Playernum - 1][Governor].snum], Dir[Playernum - 1][Governor].snum);
X		} else {
X			notify(Playernum, Governor, "You have to 'cs' to a star to name it.\n");
X			return;
X		}
X	} else if (match(args[1], "planet")) {
X		if (Dir[Playernum - 1][Governor].level == LEVEL_PLAN) {
X			getstar(&Stars[Dir[Playernum - 1][Governor].snum], Dir[Playernum - 1][Governor].snum);
X			Race = races[Playernum - 1];
X			if (!Race->God) {
X				notify(Playernum, Governor, "Only deity can rename planets.\n");
X				return;
X			}
X			strncpy(Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum],
X				buf, NAMESIZE - 1);
X			putstar(Stars[Dir[Playernum - 1][Governor].snum], Dir[Playernum - 1][Governor].snum);
X			deductAPs(Playernum, Governor, APcount, Dir[Playernum - 1][Governor].snum, 0);
X		} else {
X			notify(Playernum, Governor, "You have to 'cs' to a planet to name it.\n");
X			return;
X		}
X	} else if (match(args[1], "race")) {
X		Race = races[Playernum - 1];
X		if (Governor) {
X			notify(Playernum, Governor, "You are not authorized to do this.\n");
X			return;
X		}
X		strncpy(Race->name, buf, RNAMESIZE - 1);
X		sprintf(buf, "Name changed to `%s'.\n", Race->name);
X		notify(Playernum, Governor, buf);
X		putrace(Race);
X	} else if (match(args[1], "governor")) {
X		Race = races[Playernum - 1];
X		strncpy(Race->governor[Governor].name, buf, RNAMESIZE - 1);
X		sprintf(buf, "Name changed to `%s'.\n", Race->governor[Governor].name);
X		notify(Playernum, Governor, buf);
X		putrace(Race);
X	} else {
X		notify(Playernum, Governor, "I don't know what you mean.\n");
X		return;
X	}
X}
X
Xint 
XMostAPs(int Playernum, startype * s)
X{
X	register int    i, t = 0;
X
X	for (i = 0; i < MAXPLAYERS; i++)
X		if (s->AP[i] >= t)
X			t = s->AP[i];
X
X	return (s->AP[Playernum - 1] == t);
X}
X
Xvoid 
Xannounce(int Playernum, int Governor, char *message, int mode, int override)
X{
X	racetype       *Race;
X	char            symbol;
X	int 			channel_to_send_on = COMM_CHANNEL1;
X
X	Race = races[Playernum - 1];
X
X#ifdef MULTIPLE_COMM_CHANNELS
X
X	if (!override) {
X		if (isset(races[Playernum -1]->governor[Governor].channel, 
X			COMM_DEF_CHANNEL1))
X			channel_to_send_on = COMM_CHANNEL1;
X		else if (isset(races[Playernum -1]->governor[Governor].channel, 
X			COMM_DEF_CHANNEL2))
X			channel_to_send_on = COMM_CHANNEL2;
X		else if (isset(races[Playernum -1]->governor[Governor].channel, 
X			COMM_DEF_CHANNEL3))
X			channel_to_send_on = COMM_CHANNEL3;
X		else {
X			channel_to_send_on = COMM_CHANNEL1;
X			notify(Playernum, Governor, "No default channel specifed, sending on 1\n");
X		}
X	} else 
X		channel_to_send_on = override;
X#endif
X
X	if (mode == SHOUT && !Race->God) {
X		notify(Playernum, Governor, "You are not privileged to use this command.\n");
X		return;
X	}
X	switch (Dir[Playernum - 1][Governor].level) {
X	case LEVEL_UNIV:
X		if (mode == ANN)
X			mode = BROADCAST;
X		break;
X	default:
X		if ((mode == ANN) &&
X		    !(!!isset(Stars[Dir[Playernum - 1][Governor].snum]->inhabited, Playernum)
X		      || Race->God)) {
X			sprintf(buf,
X				"You do not inhabit this system or have diety privileges.\n");
X			notify(Playernum, Governor, buf);
X			return;
X		}
X	}
X
X	switch (mode) {
X	case ANN:
X		symbol = ':';
X		break;
X	case BROADCAST:
X		symbol = '>';
X		break;
X	case SHOUT:
X		symbol = '!';
X		break;
X	case THINK:
X		symbol = '=';
X		break;
X	}
X#ifdef MULTIPLE_COMM_CHANNELS
X	sprintf(msg, "%s \"%s\" [%d,%d] %d %c%s\n", Race->name,
X		Race->governor[Governor].name, Playernum, Governor,
X		channel_to_send_on, symbol, message);
X#else
X	sprintf(msg, "%s \"%s\" [%d,%d] %c %s\n", Race->name,
X		Race->governor[Governor].name, Playernum, Governor,
X		symbol, message);
X#endif 
X
X	switch (mode) {
X	case ANN:
X		d_announce(Playernum, Governor, Dir[Playernum - 1][Governor].snum, msg);
X		break;
X	case BROADCAST:
X		d_broadcast(Playernum, Governor, msg, channel_to_send_on);
X		break;
X	case SHOUT:
X		d_shout(Playernum, Governor, msg);
X		break;
X	case THINK:
X		d_think(Playernum, Governor, msg);
X		break;
X	default:
X		break;
X	}
X}
END_OF_FILE
if test 34058 -ne `wc -c <'user/name.c'`; then
    echo shar: \"'user/name.c'\" unpacked with wrong size!
fi
# end of 'user/name.c'
fi
if test -f 'utils/makeplanet.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/makeplanet.c'\"
else
echo shar: Extracting \"'utils/makeplanet.c'\" \(16391 characters\)
sed "s/^X//" >'utils/makeplanet.c' <<'END_OF_FILE'
X/* makeplanet.c -- makes one planet.
X *
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, 
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h.
X * Restrictions in GB_copyright.h.
X */
X#include "GB_copyright.h"
X
X#define MAP_ISLANDS 3		/* # of beginning islands for makeuniv */
X#define MAP_MOUNT_PERCENT 0.22	/* percentage of mountain areas */
X#define MAP_DESERT_PERCENT 0.10	/* percent of desert areas */
X#define MAP_GASGIANT_BANDMIN 20  /* min size gasgiants that have bands */
X#define LANDPERCENTAGE int_rand(20,70)/100
X#define POLEFUDGE 10
X
X#define EXTERN extern
X#include "vars.h"
X#include <math.h>
X
Xextern double double_rand(void);
Xextern int int_rand(int, int);
Xextern int round_rand(double);
Xextern int rposneg(void);
X
X
X/*             @   o   O   #   ~   .   (   -    */
Xint xmin[] = {15,  1,  4,  4, 30,  6, 10, 10} ;
Xint xmax[] = {23,  3,  8,  8, 36, 15, 20, 25} ;
X
X/*             @   o   O   #   ~   .   (   -    */
Xint fmin[] = {20,  1,  1, 35, 32, 25, 60,  1} ;
Xint fmax[] = {45,  2,  8, 55, 52, 55, 80, 20} ;
X
X
X/*               .    *    ^    ~  */
Xint rmin[]  = {150, 120, 200,  20} ;
Xint rmax1[] = {200, 120, 600,  20} ;
Xint rmax2[] = {200, 300, 600,  60} ;
X
X/*               @      o     O    #    ~    .       (       _  */
Xint type1[] = {SEA, MOUNT, LAND, SEA, GAS, SEA,   LAND,   LAND};
Xint cond1[] = {SEA, MOUNT, LAND, ICE, GAS, SEA, FOREST, DESERT};
X
X#define RES_GAS int_rand(rmin[GAS], int_rand(rmax[GAS], rmax1[GAS]));
X#define RES_MOUNT int_rand(rmin[MOUNT], int_rand(rmax1[MOUNT], rmax1[MOUNT])) ;
X#define RES_LAND int_rand(rmin[LAND], int_rand(rmax1[LAND], rmax1[LAND])) ;
X#define RES_SEA int_rand(rmin[SEA], int_rand(rmax1[SEA], rmax1[SEA])) ;
X
X#if 0
X/* Define this for old-style GG's, which had bands of water (?) on them: */
X#define MAKE_WATERY_JOVIANS
X#endif
X
Xextern int    Temperature(double, int);
X
Xdouble DistmapSq(int, int, int, int);
Xvoid   MakeEarthAtmosphere(planettype *, int);
Xint    Numneighbors(planettype *, int, int, int);
Xint    SectorTemp(planettype *, int, int);
Xvoid   Smashup(planettype *, double, char, int, int, int);
Xint    Volcano(planettype *, int, int, int, char);
Xvoid   Makesurface(planettype *);
Xshort  SectTemp(planettype *, int);
Xplanettype Makeplanet(double, short, int);
X
Xplanettype Makeplanet(double dist, short stemp, int type)
X{
X    reg int x, y ;
X    sectortype *s ;
X    planettype planet ;
X    int i, atmos, landsects, Numlandsects, cont_type ;
X    int desert;
X    short rowtemp;
X    char c, t;
X    double f;
X    
X    Bzero(planet);
X    bzero((char *)Smap, sizeof(Smap));
X    planet.type = type;
X    planet.expltimer = 5;
X    planet.conditions[TEMP] = planet.conditions[RTEMP] = Temperature(dist, stemp);
X  
X    planet.Maxx = int_rand(xmin[type], xmax[type]) ;
X    f = (double)planet.Maxx / RATIOXY;
X    planet.Maxy = round_rand(f) + 1;
X    if(!(planet.Maxy % 2))
X	planet.Maxy++;		/* make odd number of latitude bands */
X
X    if (type == TYPE_ASTEROID)
X	planet.Maxy = int_rand(1, 3) ;   /* Asteroids have funny shapes. */
X
X    t = type1[type];
X    c = cond1[type];
X
X    if ((type == TYPE_ASTEROID) && (!int_rand(0, 4)))
X	c = DESERT ;
X
X    for (y=0; y<planet.Maxy; y++) {
X	for (x=0; x<planet.Maxx; x++) {
X	    s = &Sector(planet,x,y);
X	    s->type = t;
X	    s->condition = c;
X	    s->fert = int_rand(fmin[type], fmax[type]) ;
X	    s->resource = int_rand(rmin[t], int_rand(rmax1[t], rmax2[t])) ;
X	}
X    }
X  
X    switch (type) {
X      case TYPE_GASGIANT:		/* gas giant planet */
X	/* either lots of meth or not too much */
X	if (int_rand(0, 1)) {	/* methane planet */
X	    atmos = 100 - (planet.conditions[METHANE] = int_rand(70, 80)); 
X	    atmos -= planet.conditions[HYDROGEN] = int_rand(1, atmos/2);
X	    atmos -= planet.conditions[HELIUM] = 1;
X	    atmos -= planet.conditions[OXYGEN] = 0;
X	    atmos -= planet.conditions[CO2] = 1;
X	    atmos -= planet.conditions[NITROGEN] = int_rand(1, atmos/2);
X	    atmos -= planet.conditions[SULFUR] = 0;
X	    planet.conditions[OTHER] = atmos;
X	} else {
X	    atmos = 100 - (planet.conditions[HYDROGEN] = int_rand(30,75));
X	    atmos -= planet.conditions[HELIUM] = int_rand(20,atmos/2);
X	    atmos -= planet.conditions[METHANE] = random()&01;
X	    atmos -= planet.conditions[OXYGEN] = 0;
X	    atmos -= planet.conditions[CO2] = random()&01;
X	    atmos -= planet.conditions[NITROGEN] = int_rand(1,atmos/2);
X	    atmos -= planet.conditions[SULFUR] = 0;
X	    planet.conditions[OTHER] = atmos;
X	}
X#ifdef MAKE_WATERY_JOVIANS
X	if (planet.Maxx > MAP_GASGIANT_BANDMIN) {
X	    int nbands = round_rand(planet.Maxy/7.0);
X	    for (i=1; i<=nbands; i++) {
X		y = int_rand(1,planet.Maxy-2);
X		for (x=0; x<planet.Maxx; x++) {
X		    s = &Sector(planet,x,y);
X		    s->des = SEA;	/* make random bands of water */
X		    s->resource = RES_SEA;
X		    s->fert = int_rand(20,30);
X		}
X	    }
X	    for (i=0; i<=MAP_ISLANDS*6; i++) {
X		x=int_rand(0,planet.Maxx-1);
X		y=int_rand(0,planet.Maxy-1);
X		s = &Sector(planet,x,y);
X		s->des = SEA;	/* make random spots of water */
X		s->resource = RES_SEA;
X		s->fert = int_rand(60,90);
X	    }
X	}
X#endif
X	break;
X      case TYPE_MARS:
X	planet.conditions[HYDROGEN] = 0;
X	planet.conditions[HELIUM] = 0;
X	planet.conditions[METHANE] = 0;
X	planet.conditions[OXYGEN] = 0;
X	if (random()&01) {    /* some have an atmosphere, some don't */
X	    atmos = 100 - (planet.conditions[CO2] = int_rand(30,45));
X	    atmos -= planet.conditions[NITROGEN] = int_rand(10, atmos/2);
X	    atmos -= planet.conditions[SULFUR] = 
X		(random()&01) ? 0 : int_rand(20,atmos/2) ;
X	    atmos -= planet.conditions[OTHER] = atmos;
X	} else {
X	    planet.conditions[CO2] = 0;
X	    planet.conditions[NITROGEN] = 0;
X	    planet.conditions[SULFUR] = 0;
X	    planet.conditions[OTHER] = 0;
X	}
X	Smashup(&planet, 1.5, MOUNT,  5, 1, 0);  /* make mountain ranges */
X	break;
X      case TYPE_ASTEROID: 		/* asteroid */
X	/* no atmosphere */
X	for (y=0; y<planet.Maxy; y++)
X	    for (x=0; x<planet.Maxx; x++)
X		if (!int_rand(0,3)) {
X		    s = &Sector(planet, int_rand(1,planet.Maxx), 
X				int_rand(1,planet.Maxy));
X		    s->type = LAND ;
X		}
X	break;
X      case TYPE_ICEBALL:		/* ball of ice */
X	/* no atmosphere */
X	planet.conditions[HYDROGEN] = 0;
X	planet.conditions[HELIUM] = 0;
X	planet.conditions[METHANE] = 0;
X	planet.conditions[OXYGEN] = 0;
X	if (planet.Maxx * planet.Maxy > int_rand(0,20)) {
X	    atmos = 100 - (planet.conditions[CO2] = int_rand(30,45)) ;
X	    atmos -= planet.conditions[NITROGEN] = int_rand(10, atmos/2) ;
X	    atmos -= planet.conditions[SULFUR] = 
X		(random()&01) ? 0 : int_rand(20, atmos/2) ;
X	    atmos -= planet.conditions[OTHER] = atmos ;
X	} else {
X	    planet.conditions[CO2] = 0;
X	    planet.conditions[NITROGEN] = 0;
X	    planet.conditions[SULFUR] = 0;
X	    planet.conditions[OTHER] = 0;
X	}
X	Smashup(&planet, double_rand(), MOUNT, 20, 0, 0);       
X	/* make some random mountains */
X	for (i=0; i<MAP_ISLANDS; i++) {
X	    x = int_rand(0,planet.Maxx-1);
X	    y = int_rand(0,planet.Maxy-1);
X	    Sector(planet,x,y).type = MOUNT;
X	    Sector(planet,x,y).condition = MOUNT;
X	    Sector(planet,x,y).resource = RES_MOUNT;
X	    Sector(planet,x,y).fert *= 0.3;
X	}
X	break;
X      case TYPE_EARTH:
X	MakeEarthAtmosphere(&planet, 1) ;
X	Numlandsects = planet.Maxx*planet.Maxy*LANDPERCENTAGE;
X	/* make first isolated islands */
X	for (i=0; i<MAP_ISLANDS; i++) {
X	    s = &Sector(planet, int_rand(planet.Maxx/5,planet.Maxx-planet.Maxx/5),
X			int_rand(1,planet.Maxy-2));
X	    s->type = LAND;  
X	    s->condition = LAND;
X	    s->resource = RES_LAND;
X	    s->fert = int_rand(6,20);
X	}
X	landsects=0;
X	while (landsects<=Numlandsects)
X	    landsects += Volcano(&planet, landsects, Numlandsects, 1, MOUNT);
X	/* make more isolated islands */
X	for (i=0; i<=MAP_ISLANDS*3; i++) {
X	    x=int_rand(0,planet.Maxx-1);
X	    y=int_rand(0,planet.Maxy-1);
X	    s = &Sector(planet,x,y);
X	    s->type = (int_rand(0,1) ? LAND : MOUNT);
X	    s->condition = s->type;
X	    s->resource = RES_LAND;
X	    s->fert = int_rand(35,55) ;
X	}
X	break;
X      case TYPE_FOREST:
X	MakeEarthAtmosphere(&planet, 0) ;
X	Numlandsects = planet.Maxx*planet.Maxy*LANDPERCENTAGE;
X	/* make first isolated islands */
X	for (i=0; i<=MAP_ISLANDS; i++) {
X	    x = int_rand(0, planet.Maxx-1) ;
X	    y = int_rand(0, planet.Maxy-1) ;
X	    s = &Sector(planet, x, y) ;
X	    s->type = LAND;
X	    s->condition = s->type;
X	    s->resource = RES_LAND;
X	    s->fert = int_rand(6,20);
X	}
X	landsects=0;
X	while (landsects<=Numlandsects)
X	    landsects += Volcano(&planet, landsects, Numlandsects, 1, SEA);
X	landsects=0;
X	while (landsects<=Numlandsects)
X	    landsects += Volcano(&planet, landsects, Numlandsects, 1, MOUNT);
X	Smashup(&planet, double_rand(), SEA, 20, 40,0);
X    
X	/* make more isolated islands */
X	for (i=0; i<=MAP_ISLANDS; i++) {
X	    x=int_rand(0,planet.Maxx-1);
X	    y=int_rand(0,planet.Maxy-1);
X	    s = &Sector(planet,x,y);
X	    s->type = int_rand(0,2) ? LAND : MOUNT;
X	    s->condition = s->type;
X	    s->resource = RES_LAND;
X	    s->fert = int_rand(35,55) ;
X	}
X	break;
X      case TYPE_WATER:
X	MakeEarthAtmosphere(&planet, 2) ;
X	Smashup(&planet, double_rand()/2.0, LAND, 50, 50, 0);
X	Numlandsects = planet.Maxx*planet.Maxy*LANDPERCENTAGE;
X	cont_type = int_rand(0,3) ? LAND : MOUNT;
X	landsects=0;
X	while (landsects<=Numlandsects)
X	    landsects += Volcano(&planet, landsects, Numlandsects, 1, cont_type); 
X	break;
X      case TYPE_DESERT:
X	MakeEarthAtmosphere(&planet, 2) ;
X	Smashup(&planet, double_rand(), LAND, 100, 20, 0);
X	Smashup(&planet, 1.0+double_rand(), MOUNT, 200, 10, 0);
X	Numlandsects = planet.Maxx*planet.Maxy*LANDPERCENTAGE;
X	landsects=0;
X	while (landsects<=Numlandsects)
X	    landsects += Volcano(&planet, landsects, Numlandsects, 0, MOUNT); 
X	break;
X      default:
X	break;
X    }
X    Makesurface(&planet);  /* determine surface geology based on environment */
X  
X    /* make crystal deposits */
X    for (y=0; y<planet.Maxy; y++)
X	for (x=0; x<planet.Maxx; x++) {
X	    s = &Sector(planet,x,y);
X	    if(!int_rand(0, 200))
X		s->crystals=int_rand(1,10);
X	    else
X		s->crystals = 0;
X	}
X    return planet;
X}
X
Xvoid MakeEarthAtmosphere(planettype *pptr, int chance)
X{
X    int atmos = 100 ;
X  
X    if (int_rand(0,chance)) {
X	/* oxygen-reducing atmosphere */
X	atmos -= pptr->conditions[OXYGEN] = int_rand(10, 25) ;
X	atmos -= pptr->conditions[NITROGEN] = int_rand(20, atmos-20);
X	atmos -= pptr->conditions[CO2] = int_rand(10, atmos/2);
X	atmos -= pptr->conditions[HELIUM] = int_rand(2, atmos/8+1);
X	atmos -= pptr->conditions[METHANE] = random()&01;
X	atmos -= pptr->conditions[SULFUR] = 0;
X	atmos -= pptr->conditions[HYDROGEN] = 0;
X	pptr->conditions[OTHER] = atmos;
X    } else {
X	/* methane atmosphere */
X	atmos -= pptr->conditions[METHANE] = int_rand(70, 80) ;
X	atmos -= pptr->conditions[HYDROGEN] = int_rand(1, atmos/2);
X	atmos -= pptr->conditions[HELIUM] = 1 + (random()&01) ;
X	atmos -= pptr->conditions[OXYGEN] = 0;
X	atmos -= pptr->conditions[CO2] = 1 + (random()&01) ;
X	atmos -= pptr->conditions[SULFUR] = (random()&01) ;
X	atmos -= pptr->conditions[NITROGEN] = int_rand(1, atmos/2);
X	pptr->conditions[OTHER] = atmos;
X    }
X}
X
X/* 
X * Smash psuedo-meteors into a planet
X */
Xvoid Smashup(planettype *pptr, double f, char desig, int res, int fert, 
X	     int waste)
X{
X    reg int r,x,y;
X    reg int x2,y2, xx;
X    reg sectortype *s;
X    double rr ;
X    
X    int n = round_rand(f) ;
X  
X    while (n--) {
X	x = int_rand(0, pptr->Maxx-1);
X	y = int_rand(0, pptr->Maxy-1);
X	rr = 0.7 + double_rand() * int_rand(1, round_rand(pptr->Maxy/3.0)) ;
X	r = round_rand(rr) ;
X	rr *= rr ;
X	for (x2=x-r; x2<=x+r; x2++) {
X	    if (x2 < 0)
X		xx = x2 + pptr->Maxx ;
X	    else if (x2 >= pptr->Maxx)
X		xx = x2 - pptr->Maxx ;
X	    else 
X		xx = x2 ;
X	    for (y2=y-r; y2<=y+r; y2++) {
X		if (y2 < 0)
X		    continue ;
X		if (y2 >= pptr->Maxy)
X		    break ;
X		if (round_rand(rr - DistmapSq(x,y,x2,y2)) > 0) {
X		    s = &Sector(*pptr, xx, y2) ;
X		    s->type = desig ;
X		    s->condition = s->type;
X		    if (waste) s->condition = WASTED;
X		    if (res)   s->resource += int_rand(res/2, res*2);
X		    if (fert)  s->fert += int_rand(fert/2, fert*2);
X		}
X	    }
X	}
X    }
X}
X
X
Xdouble DistmapSq(int x, int y, int x2, int y2)
X{
X#if 0
X    return fabs((double)(x-x2)) / RATIOXY + fabs( (double)(y-y2));
X#else
X    return (0.8*(x-x2)*(x-x2) + (y-y2)*(y-y2)) ;
X#endif
X}
X
X
Xint SectorTemp(planettype *pptr, int x, int y)
X{		
X    int p_x, p_xg ;       /* X of the pole, and the ghost pole. */
X    int p_y ;             /* Y of the nearest pole. */
X    double f, d ;         /* `distance' to pole. */
X    static double renorm[] = 
X    {0, 1.0/1.0, 2.0/2.0, 4.0/3.0, 6.0/4.0, 9.0/5.0, 12.0/6.0, 16.0/7.0,
X	 20.0/8.0, 25.0/9.0, 30.0/10.0, 36.0/11.0, 42.0/12.0, 49.0/13.0} ;
X    /*                        @   o   O   #   ~   .   (   -    */
X    static int variance[] = {25, 40, 40, 40, 10, 20, 30, 30} ;
X    
X
X  /* I use pptr->sectormappos to calculate the pole position from.
X     This in spite of the fact that the two have nothing to do with each other.
X     I did it because (a) I don't want the pole to move, and sectormappos will
X     also not change, and (b) sectormappos will not show up to the player in
X     any other fashion. */
X    p_x = pptr->sectormappos % pptr->Maxx ;
X    if (y < (pptr->Maxy / 2.0))
X	p_y = -1 ;
X    else {
X	p_y = pptr->Maxy ;
X	p_x = p_x + pptr->Maxx / 2.0 ;
X	if (p_x >= pptr->Maxx)
X	    p_x -= pptr->Maxx ;
X    }
X    if (p_x <= (pptr->Maxy / 2))
X	p_xg = p_x + pptr->Maxy ;
X    else
X	p_xg = p_x - pptr->Maxy ;
X    d = (y-p_y) * (y-p_y) ;
X
X    f = (x-p_x+0.2) / pptr->Maxx ;
X    if (f < 0.0)
X	f = -f ;
X    if (f > 0.5)
X	f = 1.0 - f ;
X    d = sqrt(d + f - 0.5) ;
X    return (pptr->conditions[RTEMP] + 
X	    variance[pptr->type] * (d - renorm[pptr->Maxy])) ;
X}
X
Xint Volcano(planettype *pptr, int landsectors, int Numlandsects, 
X	    int continent, char type)
X{		
X    reg int x,y;
X    sectortype *s;
X  
X    x = int_rand(0, pptr->Maxx-1);
X    y = int_rand(0, pptr->Maxy-1);
X    s = &Sector(*pptr,x,y);
X
X    if ((random() & 01) && (random() & 01))
X	return 1 ;
X    if ((continent) && 
X	(Numneighbors(pptr,x,y,LAND) || Numneighbors(pptr,x,y,type))) {
X   /*	s->des=(landsectors>(MAP_MOUNT_PERCENT*Numlandsects))?LAND:type;*/
X	s->type = int_rand(0,1) ? LAND : type;
X	s->condition = s->type;
X	s->resource = round_rand((double)(Numlandsects - landsectors + 5)
X				 / (double)Numlandsects * 100);
X	/* min content prop to dist from sea */
X	if (s->type == SEA)
X	    s->fert = round_rand((double)(landsectors + 5) 
X				 / (double)Numlandsects * 100);
X	/* fert content prop to dist from center of continent */
X	return(1);
X    }
X    return(0) ;
X}
X
X
X/* 
X * Returns # of neighbors of a given designation that a sector has. 
X */
Xint Numneighbors(planettype *p, int x, int y, int des)
X{
X    int l = x - 1 ;
X    int r = x + 1 ;    /* Left and right columns. */
X    int n = 0 ;        /* Number of neighbors so far. */
X
X    if (x == 0)
X	l = p->Maxx - 1 ;
X    else if (r == p->Maxx)
X	r = 0 ;
X    if (y > 0)
X	n += (Sector(*p,x,y-1).type == des) ;
X    n += ((Sector(*p,l,y).type == des) +
X	  (Sector(*p,r,y).type == des)) ;
X    if (y < p->Maxy-1)
X	n += (Sector(*p,x,y+1).type == des) ;
X    return n ;
X}
X
Xvoid Makesurface(planettype *p)
X{
X    reg int r,x,y;
X    reg int x2,y2, xx, temp;
X    reg sectortype *s;
X    double rr;
X
X    if(p->type==GAS) 
X	return;
X    for(x=0; x<p->Maxx; x++) {
X	for(y=0;y<p->Maxy; y++) {
X	    s = &Sector(*p, x, y);
X	    temp = SectTemp(p, y);
X	    switch(s->type) {
X	      case SEA:
X		if(success(-temp))
X		    s->condition = ICE;
X		break;
X	      case LAND:
X		if(success(-temp))
X		    s->condition = ICE;
X		else if(success(temp/2))
X		    s->condition = DESERT;
X		else if(success(p->conditions[CO2]+p->conditions[NITROGEN])) {
X		    if(p->type==TYPE_FOREST) {
X			if(success(3*temp))
X			    s->condition = FOREST;
X		    } else if(p->type==TYPE_EARTH) {
X			if(success(temp))
X			    s->condition = FOREST;
X		    }
X		}
X		break;
X	      case MOUNT:
X		if(success(-temp))
X		    s->condition = ICE;
X		else if(success(temp/2))
X		    s->condition = DESERT;
X		else if(success(p->conditions[CO2]+p->conditions[NITROGEN])) {
X		    if(p->type==TYPE_FOREST) {
X			if(success(2*temp))
X			    s->condition = FOREST;
X		    } else if(p->type==TYPE_EARTH) {
X			if(success(temp))
X			    s->condition = FOREST;
X		    }
X		}
X		break;
X	    }
X	}
X    }
X}
X
X#define TFAC 10
X
Xshort SectTemp(planettype *p, int y)
X{
X  register int i, dy, mid, temp;
X
X  temp = p->conditions[TEMP];
X  mid = (p->Maxy+1)/2-1;
X  dy = abs(y-mid);
X
X  temp -= TFAC*dy*dy;
X  return temp;
X/*  return(p->conditions[TEMP]); */
X}
END_OF_FILE
if test 16391 -ne `wc -c <'utils/makeplanet.c'`; then
    echo shar: \"'utils/makeplanet.c'\" unpacked with wrong size!
fi
# end of 'utils/makeplanet.c'
fi
echo shar: End of archive 6 \(of 21\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
