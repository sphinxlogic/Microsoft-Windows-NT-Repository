Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i030:  gbp - Galactic Bloodshed+, an empire-like war game, Part18/21
Message-ID: <4558@master.CNA.TEK.COM>
Date: 12 Feb 93 17:33:09 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1956
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1709

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 30
Archive-name: gbp/Part18
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 18 (of 21)."
# Contents:  doc/CLIENT_PROTOCOL hdrs/config.h hdrs/config.h.SH
#   hdrs/racegen.h user/map.c user/tele.c utils/enroll.c utils/psmap.c
# Wrapped by billr@saab on Fri Feb 12 09:14:30 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/CLIENT_PROTOCOL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/CLIENT_PROTOCOL'\"
else
echo shar: Extracting \"'doc/CLIENT_PROTOCOL'\" \(6911 characters\)
sed "s/^X//" >'doc/CLIENT_PROTOCOL' <<'END_OF_FILE'
X------------------------------------------------------------------------
XCLIENT - SERVER PROTOCOL (CSP) Data File for GB+ (A product of GBDT)
X------------------------------------------------------------------------
XStarted by: Evan Koffler <koffleva@darkwing.uoregon.edu>
XOn: Sat Jan 23 19:42:09 PST 1993
X------------------------------------------------------------------------
XModification History:
X
X------------------------------------------------------------------------
X
XThis file is to explain the client <-> server protocols that
Xhave developed over the past few years of me (Evan Koffler)
Xworking on the client and server.
X
XFirst off, the server should NEVER make a ship with the letter
X\ or |. These 2 characters are reserved for client-server protocol
X(hereafter referred to as CSP).
X
XTo introduce a NEW CSP or to change an existing CSP, PLEASE POST
Xall relevant information on the appropriate newsgroup (alt.games.gb)
Xcurrently and if a client or server developers mail list exist then
Xsend a message to them as well. Allow enough time to pass for discussion
Xabout the appropriateness of the arguments in the command output
Xand then add the information to this file. This helps prevent
Xfrequent changes to the commands and informs all client developers
Xof any changes they may need to cope with in the future. The road
Xhas been paved so far for you, continue to pave it for those who
Xfollow.
X
X------------------------------------------------------------------------
XThe standard format for the numeric protocol is:
X
X<client char> <number> [<arg1> <arg2> ..... <argn>]
X
XThe client character is:    |
XWhile the <number> should be distinct ranges. That is, a command
Xuses 101 then, the next one should be at 150 or even 200
Xso that there is room to grow, and there is no confusion for
Xthe commands.
X
X------------------------------------------------------------------------
XFormat of this file
X
XEach CSP range should be presented in the following format.
X
XCommand name: <command>
XResponse Range: X-Y
XInput formats:
X	<command> <arguments or options> (X-Y responses for command)
X	<command> <another way of getting information> [X-Y]
X
XOutput formats:
XX format: "scanf/printf format. preferably the scanf format so the
Xclient can be modified to read it easily by copying the line"
X
X------------------------------------------------------------------------
XAt present there are 2 commands that were old server formats
Xthat do not follow this format. The two commands are map and orbit.
XThe format for them follows.
X
XMap:
X$<Planet Name>;<X>;<Y>;<SHOW>;<sector info>
X
XThe $ in position 0 denotes this is a map command.
X<Planet Name> is a string ending in a ;.
X<X> is the width of the planet.
X<Y> is the height of the planet.
X<SHOW> is unused.
X<sector info> is a single digit number followed by a character.
XThe digit means 1 of 2 things, depending if the toggle color option
Xis set on the server.  If color is NOT set, then the digit will
Xbe either a 1 or a 0 if you own or do not own the sector. If color
Xis set then it will be a unique number for coloring the sector.
XAfter the color/ownership information comes the actual character
Xto be used to represent this sector.  The sector info continues for
XX * Y pairs of sectors.
X
XExample:
X$Test;2;2;1*1*0^0^
XThis planet is named Test, is a 2 x 2 planet. You own the
Xfirst 2 sectors, which are land, and do not own the 2 mtn sectors
Xbelow. (assuming color is off).
XMap in a working client would display:
X     'Test'
X   00
X   01
X00 **  <- these 2 sectors would be colored/highlighted to represent ownership
X01 ^^
X
X
XOrbit:
X#<stand1> <X> <Y> <array> <symbol> <stand2> <Name>;[<stand1> <X> <Y> <array> <symbol> <stand2> <Name>;]
X<stand1> is whether the planet is 'explored' by the player and should be
Xhighlighted.
X<X> is x coords.
X<Y> is y coords.
X<array> is the special output array index indicating which array to be
Xdisplayed. Which specific array to be used is determined by the <symbol>
X<symbol> if a 'm' or 'M' then a mirror should be displayed, if it is '*'
Xand array > 0 then a nova should be displayed else it is a normal orbit map.
XAlso, <symbol> will contain a ship letter if the data here is a ship
Xand <stand1> and <stand2> will a positive number if the player owns the ship.
X<stand2> is whether the planet has population of the player on it.
X
XStandard convention is to highlight the symbol if the planet has been
Xowned, and highlight the name if the player has colonized the planet.
X(ie, highlight symbol if <stand1> and name if <stand2>)
X
XExample:
X#1 100 100 0 * 1 Minos;1 93 104 0 o 0 Earth;1 90 90 0 D 1 456;
X
XA star (*) named Minos is not undergoing a nova (since array is 0)
Xand is located at coords 100,100. The player has 'knowledge' of the
Xtype (stand1) and 'owns' the star (meaning popn in the system) (stand2).
XNext is a planet Earth (o) located at 93,104 which the player has
Xexplored (1 for stand1) but does not have popn on (stand2 is 0). The
Xarray has no meaning here so is 0.
XThe last field is a ship (D) located at 90,90 owned by the player
X(stand1 and stand2 are 1). Again, array of 0 has no meaning. And the
Xship is #456 (as specified in the name spot).
X
X------------------------------------------------------------------------
XThe other client server protocols follow the | <number> convention
Xoutlined above.
X
X------------------------------------------------------------------------
XCommand name: client_survey
XResponse Range: 101-103
XInput formats:
X	client_survey -					(101-103)
X	client_survey minx[:maxx],miny[:maxy]		(102-103)
X
XThe - will request ALL sectors. That is, client_survey 0:MAXX,0:MAXY.
X
XOutput formats:
X101 format: "| 101 %d %d %s %s %d %d %d %d %d %d %lf %d"
X| 101 <maxX> <maxY> <star name> <planet name> <res> <fuel> <des> <popn>
X<max popn> <toxicity> <compat %> <enslaved>
XmaxX:		int		width of planet
XmaxY:		int		height of planet
Xstar name:	word		char * of star name
Xplanet name:	word		char * of planet name
Xres:		int		amt of res on planet
Xfuel:		int		amt of fuel on planet
Xdes:		int		amt of des on planet
Xpopn:		int		amt of popn on planet
Xmax popn:	int		amt of max popn for planet
Xtoxicity:	int		current toxicity of planet
Xcompat %:	double		% compat with planet
Xenslaved:	boolen		is planet enslaved.
X
X102 format: "| 102 %d %d %c %c %d %d %d %d %d %d %d %d %d %d"
X| 102 <x> <y> <sectc> <des> <wasted> <own> <eff> <frt> <mob> <xtal> <res> <civ> <mil> <mpopn>
Xx:		int		x of sector
Xy:		int		y of sector (x,y)
Xsectc:		char		type of sector #^*)-o.
Xdes:		char		server description. could be mil/ship ltr
Xwasted:		boolean		is sector wasted.
Xown:		int		player#
Xeff:		int		eff%
Xfrt:		int		frt in sector
Xmob:		int		mobility of sector
Xxtal:		boolean		is sector xtal.		
Xres:		int		res in sector
Xciv:		int		# civ on sector
Xmil:		int		# mil on sector
Xmax popn:	int		max popn for sector
X
X103 format: "| 103"
X| 103
X103 has NO arguments. It is END OF COMMAND.
X------------------------------------------------------------------------
X
END_OF_FILE
if test 6911 -ne `wc -c <'doc/CLIENT_PROTOCOL'`; then
    echo shar: \"'doc/CLIENT_PROTOCOL'\" unpacked with wrong size!
fi
# end of 'doc/CLIENT_PROTOCOL'
fi
if test -f 'hdrs/config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdrs/config.h'\"
else
echo shar: Extracting \"'hdrs/config.h'\" \(6484 characters\)
sed "s/^X//" >'hdrs/config.h' <<'END_OF_FILE'
X/* config.h
X * This file was produced by running the config.h.SH script, which
X * gets its values from config.sh, which is generally produced by
X * running Configure.
X *
X * Feel free to modify any of this as the need arises.  Note, however,
X * that running config.h.SH again will wipe out any changes you've made.
X * For a more permanent change edit config.sh and rerun config.h.SH.
X */
X
X /*  CONFIG.H FILE FOR GB+ Version 1 JPD 12.10.92 */
X
X/* BIN:
X *	This symbol holds the name of the directory in which the user wants
X *	to put publicly executable images for the package in question.  It
X *	is most often a local directory such as /usr/local/bin.
X */
X#define BIN ""             /**/
X
X/* BYTEORDER:
X *	This symbol contains an encoding of the order of bytes in a long.
X *	Usual values (in octal) are 01234, 04321, 02143, 03412...
X */
X#define BYTEORDER 0x4321		/**/
X
X/* CPPSTDIN:
X *	This symbol contains the first part of the string which will invoke
X *	the C preprocessor on the standard input and produce to standard
X *	output.	 Typical value of "cc -E" or "/lib/cpp".
X */
X/* CPPMINUS:
X *	This symbol contains the second part of the string which will invoke
X *	the C preprocessor on the standard input and produce to standard
X *	output.  This symbol will have the value "-" if CPPSTDIN needs a minus
X *	to specify standard input, otherwise the value is "".
X */
X#define CPPSTDIN "/usr/lib/cpp"
X#define CPPMINUS ""
X
X/* GETOPT:
X *	This symbol, if defined, indicates that the getopt() routine exists.
X */
X#define	GETOPT		/**/
X
X/* HOSTNAME:
X *	This symbol contains name of the host the program is going to run on.
X *	The domain is not kept with hostname, but must be gotten from MYDOMAIN.
X *	The dot comes with MYDOMAIN, and need not be supplied by the program.
X *	If gethostname() or uname() exist, HOSTNAME may be ignored.
X */
X/* MYDOMAIN:
X *	This symbol contains the domain of the host the program is going to
X *	run on.  The domain must be appended to HOSTNAME to form a complete
X *	host name.  The dot comes with MYDOMAIN, and need not be supplied by
X *	the program.  If the host name is derived from PHOSTNAME, the domain
X *	may or may not already be there, and the program should check.
X */
X/* GB_HOST:
X *	The full qualified hostname and domainname of the GB server
X */
X/* GB_PORT:
X *  This symbol contains the port number that GB will run on.
X */
X#define HOSTNAME "harpo"		/**/
X#define MYDOMAIN "nyu.edu"		/**/
X
X#define GB_HOST  "harpo.cims"        /**/
X#define GB_PORT  2010		    /**/
X
X
X/*
X * THRESHLOADING:
X *   Use the threshloading code?
X */
X#define THRESHLOADING /**/
X
X/*
X * AUTOSCRAP:
X *   Use the autoscrap code?
X */
X#define AUTOSCRAP /**/
X
X/* 
X * SUPERPODS:
X *   Use superpods (cost 9r Success 75%)
X */
X/*#undef SUPER_PODS /**/
X
X/*
X * SPORE_SUCCESS_RATE:
X *   Chance of spore survial.  (was in tweakables.h before 
X */
X#define SPORE_SUCCESS_RATE 25
X
X/* 
X * MULTIPLE_COMM_CHANNELS:
X *   Use 3 communications channels instead of 1
X */
X/*#undef MULTIPLE_COMM_CHANNELS /**/
X
X/* MAX_LOGSIZE:
X
X/* MAX_LOGSIZE:
X *  Size in bytes of the log when it truncates
X */
X#define MAX_LOGSIZE 100000  /**/
X/* I_TIME:
X *	This symbol is defined if the program should include <time.h>.
X */
X/* I_SYSTIME:
X *	This symbol is defined if the program should include <sys/time.h>.
X */
X/* I_SYSTIMEKERNEL:
X *	This symbol is defined if the program should include <sys/time.h>
X *	with KERNEL defined.
X */
X/*#undef		I_TIME	 	/**/
X#define	I_SYSTIME 	/**/
X/*#undef	SYSTIMEKERNEL 	/**/
X
X/* CONFIGURE_DATE
X *	This symbol contains the last date that configure was run for Gb -v output.
X */
X#define		CONFIGURE_DATE	"02/01/93 05:55"
X#define   	VERS			"02/01/93 05:55"
X
X/* XENIX:
X *	This symbol, if defined, indicates this is a Xenix system,
X *	for knocking  out the far keyword in selected places.
X */
X/* BSD:
X *	This symbol, if defined, indicates this is a BSD type system,
X */
X/*#undef	XENIX	/**/
X#define	BSD	/**/
X
X/* ------------------------------------------------ */
X/* Below are the variables not changed by configure */
X/*   You should not modify these unless you know    */
X/*                 you are doing!!                  */
X/* ------------------------------------------------ */
X
X/* COMMAND_TIME_MSEC	
X *  The time slice lenght in milliseconds
X */
X#define COMMAND_TIME_MSEC  	250
X
X/* COMMANDS_PER_TIME
X *  Commands per time slice after burst 
X */
X#define COMMANDS_PER_TIME       1
X
X/* COMMAND_BURST_SIZE	
X *  Commands allowed per user in a burst
X */
X#define COMMAND_BURST_SIZE		250
X
X/* DISCONNECT_TIME 
X *  Maximum idle time
X */
X#define DISCONNECT_TIME			7200
X
X/* MAX_OUTPUT
X *  ?????
X */
X#define MAX_OUTPUT				32768
X
X/* QUIT_COMMAND
X * WHO_COMMAND 
X * HELP_COMMAND
X * EMULATE_COMMAND
X */
X#define QUIT_COMMAND 			"quit"
X#define WHO_COMMAND				"who"
X#define HELP_COMMAND			"help"
X#define EMULATE_COMMAND			"emulate"
X
X/* WELCOME_FILE
X * HELP_FILE
X * LEAVE_MESSAGE
X */
X#define WELCOME_FILE    "welcome.txt"
X#define HELP_FILE       "help.txt"
X#define LEAVE_MESSAGE   "\n*** Thank you for playing Galactic Bloodshed ***\n"
X
X/* EXTERNAL_TRIGGER 
X *  Used in the older versions with GB_daemon
X */
X/*define EXTERNAL_TRIGGER /* if you wish to allow the below passwords to
X                             trigger updates and movement segments */
X#ifdef EXTERNAL_TRIGGER
X#define UPDATE_PASSWORD         "put_your_update_password_here"
X#define SEGMENT_PASSWORD        "put_your_segment_password_here"
X#endif
X
X/* DEBUG 
X *  Uncomment if you want to use memory debugging
X */
X/* #define DEBUG  */
X
X/* MARKET
X * comment out if you dont want the market
X */
X#define MARKET 
X
X/* VICTORY
X *  if you want to use victory conditions
X */
X/* #define VICTORY */
X
X/* DISSOLVE
X *  If you want to allow players to dissolve mid-game 
X *  CAUTION: THIS CAN CORRUPT THE DATABASE
X */
X/*#define DISSOLVE  */
X
X/* DEFENSE 
X *  If you want to allow planetary defenses
X */
X#define DEFENSE 
X
X/* VOTING
X *  If you want the voting code 
X */
X#define VOTING 
X
X/* ACCESS_CHECK
X *  If you want the access-checking code
X */
X/*#define ACCESS_CHECK */
X
X/* NOMANDS
X *  If you want to allow min # of sexes to always colonize
X */
X/*#define NOMADS */
X
X/* MONITOR 
X *  allows deity to monitor messages etc (deity can set with
X * 'toggle monitor' option. I use it to watch battles in progress.
X */
X#define MONITOR
X
X/* SHOW_COWARDS
X * If you want the number of invisible players to be shown to other players 
X */
X#define SHOW_COWARDS
X
X/* POD_TERRAFORM
X *  If pods will terraform sectors they infect 
X */
X/* #define POD_TERRAFORM */
X
X/* END OF CONFIG.H */
END_OF_FILE
if test 6484 -ne `wc -c <'hdrs/config.h'`; then
    echo shar: \"'hdrs/config.h'\" unpacked with wrong size!
fi
# end of 'hdrs/config.h'
fi
if test -f 'hdrs/config.h.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdrs/config.h.SH'\"
else
echo shar: Extracting \"'hdrs/config.h.SH'\" \(6925 characters\)
sed "s/^X//" >'hdrs/config.h.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X	echo "Using config.sh from above..."
X    fi
X    . ./config.sh
X    ;;
Xesac
Xecho "Extracting config.h (with variable substitutions)"
Xsed <<!GROK!THIS! >config.h -e 's!^#undef!/\*#undef!'
X/* config.h
X * This file was produced by running the config.h.SH script, which
X * gets its values from config.sh, which is generally produced by
X * running Configure.
X *
X * Feel free to modify any of this as the need arises.  Note, however,
X * that running config.h.SH again will wipe out any changes you've made.
X * For a more permanent change edit config.sh and rerun config.h.SH.
X */
X
X /*  CONFIG.H FILE FOR GB+ Version 1 JPD 12.10.92 */
X
X/* BIN:
X *	This symbol holds the name of the directory in which the user wants
X *	to put publicly executable images for the package in question.  It
X *	is most often a local directory such as /usr/local/bin.
X */
X#define BIN "$bin"             /**/
X
X/* BYTEORDER:
X *	This symbol contains an encoding of the order of bytes in a long.
X *	Usual values (in octal) are 01234, 04321, 02143, 03412...
X */
X#define BYTEORDER 0x$byteorder		/**/
X
X/* CPPSTDIN:
X *	This symbol contains the first part of the string which will invoke
X *	the C preprocessor on the standard input and produce to standard
X *	output.	 Typical value of "cc -E" or "/lib/cpp".
X */
X/* CPPMINUS:
X *	This symbol contains the second part of the string which will invoke
X *	the C preprocessor on the standard input and produce to standard
X *	output.  This symbol will have the value "-" if CPPSTDIN needs a minus
X *	to specify standard input, otherwise the value is "".
X */
X#define CPPSTDIN "$cppstdin"
X#define CPPMINUS "$cppminus"
X
X/* GETOPT:
X *	This symbol, if defined, indicates that the getopt() routine exists.
X */
X#$d_getopt	GETOPT		/**/
X
X/* HOSTNAME:
X *	This symbol contains name of the host the program is going to run on.
X *	The domain is not kept with hostname, but must be gotten from MYDOMAIN.
X *	The dot comes with MYDOMAIN, and need not be supplied by the program.
X *	If gethostname() or uname() exist, HOSTNAME may be ignored.
X */
X/* MYDOMAIN:
X *	This symbol contains the domain of the host the program is going to
X *	run on.  The domain must be appended to HOSTNAME to form a complete
X *	host name.  The dot comes with MYDOMAIN, and need not be supplied by
X *	the program.  If the host name is derived from PHOSTNAME, the domain
X *	may or may not already be there, and the program should check.
X */
X/* GB_HOST:
X *	The full qualified hostname and domainname of the GB server
X */
X/* GB_PORT:
X *  This symbol contains the port number that GB will run on.
X */
X#define HOSTNAME "$hostname"		/**/
X#define MYDOMAIN "$mydomain"		/**/
X
X#define GB_HOST  "$host"        /**/
X#define GB_PORT  $port		    /**/
X
X
X/*
X * THRESHLOADING:
X *   Use the threshloading code?
X */
X#$d_threshloading THRESHLOADING /**/
X
X/*
X * AUTOSCRAP:
X *   Use the autoscrap code?
X */
X#$d_autoscrap AUTOSCRAP /**/
X
X/* 
X * SUPERPODS:
X *   Use superpods (cost 9r Success 75%)
X */
X#$d_superpod SUPER_PODS /**/
X
X/*
X * SPORE_SUCCESS_RATE:
X *   Chance of spore survial.  (was in tweakables.h before 
X */
X#define SPORE_SUCCESS_RATE $spore_success_rate
X
X/* 
X * MULTIPLE_COMM_CHANNELS:
X *   Use 3 communications channels instead of 1
X */
X#$d_multi_comm MULTIPLE_COMM_CHANNELS /**/
X
X/* MAX_LOGSIZE:
X
X/* MAX_LOGSIZE:
X *  Size in bytes of the log when it truncates
X */
X#define MAX_LOGSIZE $maxlogsize  /**/
X/* I_TIME:
X *	This symbol is defined if the program should include <time.h>.
X */
X/* I_SYSTIME:
X *	This symbol is defined if the program should include <sys/time.h>.
X */
X/* I_SYSTIMEKERNEL:
X *	This symbol is defined if the program should include <sys/time.h>
X *	with KERNEL defined.
X */
X#$i_time		I_TIME	 	/**/
X#$i_systime	I_SYSTIME 	/**/
X#$d_systimekernel	SYSTIMEKERNEL 	/**/
X
X/* CONFIGURE_DATE
X *	This symbol contains the last date that configure was run for Gb -v output.
X */
X#define		CONFIGURE_DATE	"$c_date"
X#define   	VERS			"$c_date"
X
X/* XENIX:
X *	This symbol, if defined, indicates this is a Xenix system,
X *	for knocking  out the far keyword in selected places.
X */
X/* BSD:
X *	This symbol, if defined, indicates this is a BSD type system,
X */
X#$d_xenix	XENIX	/**/
X#$d_bsd	BSD	/**/
X
X/* ------------------------------------------------ */
X/* Below are the variables not changed by configure */
X/*   You should not modify these unless you know    */
X/*                 you are doing!!                  */
X/* ------------------------------------------------ */
X
X/* COMMAND_TIME_MSEC	
X *  The time slice lenght in milliseconds
X */
X#define COMMAND_TIME_MSEC  	250
X
X/* COMMANDS_PER_TIME
X *  Commands per time slice after burst 
X */
X#define COMMANDS_PER_TIME       1
X
X/* COMMAND_BURST_SIZE	
X *  Commands allowed per user in a burst
X */
X#define COMMAND_BURST_SIZE		250
X
X/* DISCONNECT_TIME 
X *  Maximum idle time
X */
X#define DISCONNECT_TIME			7200
X
X/* MAX_OUTPUT
X *  ?????
X */
X#define MAX_OUTPUT				32768
X
X/* QUIT_COMMAND
X * WHO_COMMAND 
X * HELP_COMMAND
X * EMULATE_COMMAND
X */
X#define QUIT_COMMAND 			"quit"
X#define WHO_COMMAND				"who"
X#define HELP_COMMAND			"help"
X#define EMULATE_COMMAND			"emulate"
X
X/* WELCOME_FILE
X * HELP_FILE
X * LEAVE_MESSAGE
X */
X#define WELCOME_FILE    "welcome.txt"
X#define HELP_FILE       "help.txt"
X#define LEAVE_MESSAGE   "\n*** Thank you for playing Galactic Bloodshed ***\n"
X
X/* EXTERNAL_TRIGGER 
X *  Used in the older versions with GB_daemon
X */
X/*define EXTERNAL_TRIGGER /* if you wish to allow the below passwords to
X                             trigger updates and movement segments */
X#ifdef EXTERNAL_TRIGGER
X#define UPDATE_PASSWORD         "put_your_update_password_here"
X#define SEGMENT_PASSWORD        "put_your_segment_password_here"
X#endif
X
X/* DEBUG 
X *  Uncomment if you want to use memory debugging
X */
X/* #define DEBUG  */
X
X/* MARKET
X * comment out if you dont want the market
X */
X#define MARKET 
X
X/* VICTORY
X *  if you want to use victory conditions
X */
X/* #define VICTORY */
X
X/* DISSOLVE
X *  If you want to allow players to dissolve mid-game 
X *  CAUTION: THIS CAN CORRUPT THE DATABASE
X */
X/*#define DISSOLVE  */
X
X/* DEFENSE 
X *  If you want to allow planetary defenses
X */
X#define DEFENSE 
X
X/* VOTING
X *  If you want the voting code 
X */
X#define VOTING 
X
X/* ACCESS_CHECK
X *  If you want the access-checking code
X */
X/*#define ACCESS_CHECK */
X
X/* NOMANDS
X *  If you want to allow min # of sexes to always colonize
X */
X/*#define NOMADS */
X
X/* MONITOR 
X *  allows deity to monitor messages etc (deity can set with
X * 'toggle monitor' option. I use it to watch battles in progress.
X */
X#define MONITOR
X
X/* SHOW_COWARDS
X * If you want the number of invisible players to be shown to other players 
X */
X#define SHOW_COWARDS
X
X/* POD_TERRAFORM
X *  If pods will terraform sectors they infect 
X */
X/* #define POD_TERRAFORM */
X
X/* END OF CONFIG.H */
X!GROK!THIS!
END_OF_FILE
if test 6925 -ne `wc -c <'hdrs/config.h.SH'`; then
    echo shar: \"'hdrs/config.h.SH'\" unpacked with wrong size!
fi
# end of 'hdrs/config.h.SH'
fi
if test -f 'hdrs/racegen.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdrs/racegen.h'\"
else
echo shar: Extracting \"'hdrs/racegen.h'\" \(7169 characters\)
sed "s/^X//" >'hdrs/racegen.h' <<'END_OF_FILE'
X/* racegen.h - defined values and datatypes for racegen
X * Copyright (c) Leonard Dickens 1991   (leonard@cs.umd.edu)
X *
X * Permission to copy, distribute, and/or alter is granted as long as the copy-
X * right notice and these terms are left unchanged in all derivatives/copies.
X * 
X * Anybody who does alter this program, please take credit!
X */
X#include <stdio.h>
X#define GBVERSION "1.5.3"
X
X/**************
X * Game dependencies.  This file should be gotten from the net, whenever
X * a new game is announced.  It contains #defines for addresses, number
X * of points, and other such stuff that may vary from game to game.
X *
X * Look for a later version of this program where all of this information
X * is read in at run-time.  Recompiling racegen for each new game is klunky.
X */
X#include "game_info.h"
X
X/**************
X * This #define is used to compile the code in this program needed for the
X * enroll program.  Unless you are a game-god, you will never need to use it.
X */
X#ifdef ENROLL
X#define IS_PLAYER 0
X#else
X#define IS_PLAYER 1
X#endif
X
X/**************
X * System dependencies.  These will likely not change much.
X */
X#define MAILER     "/usr/lib/sendmail"
X#define SAVETO     "racegen.save"
X#define TMP        "/tmp/racegen.save"
X
X
X/**************
X * Other stuff.
X */
X#define START_RECORD_STRING "<************"
X#define END_RECORD_STRING "************>"
X#define min(x, y) (((x) < (y)) ? (x) : (y))
X
X#ifdef __STDC__
Xdouble atof(char *nptr) ;
X
Xvoid bcopy(void *src, void *dst, int length) ;
Xvoid bzero(void *b, int length) ;
X
Xint fclose(FILE *stream) ;
Xint fflush(FILE *stream) ;
X
Xint fprintf(FILE *f, const char *format, ...) ;
Xint fscanf(FILE *f, const char *format, ...) ;
Xint printf(const char *format, ...) ;
X
Xint strncasecmp(const char *s1, const char *s2, int len) ;
X
Xvoid exit(int status) ;
Xint system(const char *string) ;
X
X#else
Xdouble atof() ;
X#define const
Xint Dialogue() ;
X#endif
X
X
X
X/**************
X * Attributes, attribute names, and parameters for attribute costs.
X */
X#define FIRST_ATTRIBUTE 0
X#define ADVENT FIRST_ATTRIBUTE
X#define ABSORB (ADVENT+1)
X#define BIRTH  (ABSORB+1)
X#define COL_IQ (BIRTH +1)
X#define FERT   (COL_IQ+1)
X#define A_IQ   (FERT  +1)
X#define FIGHT  (A_IQ  +1)
X#define PODS   (FIGHT +1)
X#define MASS   (PODS  +1)
X#define SEXES  (MASS  +1)
X#define METAB  (SEXES +1)
X#define LAST_ATTRIBUTE (METAB)
X#define N_ATTRIBUTES (LAST_ATTRIBUTE+1)
X
Xtypedef struct {
X  int number ;
X  char print_name[16] ;
X  double e_factor, e_fudge, e_hinge, l_factor, l_fudge ;
X  double minimum, init, maximum ;
X  double cov[N_ATTRIBUTES] ;
X  int is_integral ;
X  } attribute ;
X
X#define ATTR_RANGE(a) (attr[a].maximum - attr[a].minimum)
X
X
X/* The formula for determining the price of any particular attribute
X * is as follows:
X *   exp( (e_fudge * (attribute - e_hinge) )) * e_factor 
X *     + attribute * l_factor + l_fudge
X * This allows great flexibility in generating functions for 
X * attribute costs.      */
X
X/* Increasing an attribute's e_factor will raise the cost of the attribute
X * everywhere (since exp(x)>0 forall x); however, it raises the cost quite
X * disproportionately.  If a correponding decrease in l_fudge is made, this
X * will have little effect on the cost to buy an attribute below the hinge 
X * point, but will have a strong effect on the cost above the hinge.     */
X
X/* Increasing an attribute's e_fudge will have the effect of driving the cost
X * of attributes below the hinge down (slightly), and driving the cost of 
X * attributes above the hinge significantly higher.     */
X
X/* An attribute's e_hinge is the point is that the exponential "takes off";
X * that is, the exponential will have a small effect on the cost for an
X * attribute below this value, but will have a much larger impact for 
X * those over this value.      */
X
X/* An attribute's l_factor (linear factor) allows you to increase the
X * cost over the whole range of the attribute, in a smoothly increasing (or 
X * decreasing) way.      */
X
X/* The l_fudge value is a constant adjustment to the cost of an attribute.  
X * It is used to get the init value of an attribute to cost zero.    
X * It is set automatically at startup, so don't bother to mess with it.    */
X
X
X
X
X
X/**************
X * Home planet types, names, and costs.
X */
X#define FIRST_HOME_PLANET_TYPE 0
X#define H_EARTH   FIRST_HOME_PLANET_TYPE
X#define H_FOREST  (H_EARTH+1)
X#define H_DESERT  (H_FOREST+1)
X#define H_WATER   (H_DESERT+1)
X#define H_AIRLESS (H_WATER+1)
X#define H_ICEBALL (H_AIRLESS+1)
X#define H_JOVIAN  (H_ICEBALL+1)
X#define LAST_HOME_PLANET_TYPE H_JOVIAN
X#define N_HOME_PLANET_TYPES (LAST_HOME_PLANET_TYPE+1)
X
Xextern const char *planet_print_name[N_HOME_PLANET_TYPES] ;
Xextern const int planet_cost[N_HOME_PLANET_TYPES] ;
X
X
X
X/**************
X * Race types, names, and costs
X */
X#define FIRST_RACE_TYPE 0
X#define R_NORMAL        FIRST_RACE_TYPE
X#define R_METAMORPH     (R_NORMAL+1)
X#define LAST_RACE_TYPE  R_METAMORPH
X#define N_RACE_TYPES    (LAST_RACE_TYPE+1)
X
Xextern const char *race_print_name[N_RACE_TYPES] ;
Xextern const int race_cost[N_RACE_TYPES] ;
X
X
X
X/**************
X * Type of privileges this race will have:
X */
X#define FIRST_PRIV_TYPE 0
X#define P_GOD           (FIRST_PRIV_TYPE)
X#define P_GUEST         (P_GOD+1)
X#define P_NORMAL        (P_GUEST+1)
X#define LAST_PRIV_TYPE  (P_NORMAL)
X#define N_PRIV_TYPES    (LAST_PRIV_TYPE+1)
X
Xextern const char *priv_print_name[N_PRIV_TYPES] ;
X
X
X
X/**************
X * Sector types and names.  Sector costs are hardwired in currently.
X */
X#define FIRST_SECTOR_TYPE 0
X#define S_WATER    FIRST_SECTOR_TYPE
X#define S_LAND     (S_WATER+1)
X#define S_MOUNTAIN (S_LAND+1)
X#define S_GAS      (S_MOUNTAIN+1)
X#define S_ICE      (S_GAS+1)
X#define S_FOREST   (S_ICE+1)
X#define S_DESERT   (S_FOREST+1)
X#define S_PLATED   (S_DESERT+1)
X#define LAST_SECTOR_TYPE S_PLATED
X#define N_SECTOR_TYPES (LAST_SECTOR_TYPE+1)
X
Xextern const char *sector_print_name[N_SECTOR_TYPES] ;
Xconst int n_sector_types_cost[N_SECTOR_TYPES] ;
X
X
X/*
X * The covariance between two sectors is:
X *   actual_cost(a1) = base_cost(a1) * 
X *                      (1 + cov[a1][a2] * (a2 - cov[a1][a2].fudge)) ;
X */
Xextern const double compat_cov[N_SECTOR_TYPES][N_SECTOR_TYPES] ;
Xextern const double planet_compat_cov[N_HOME_PLANET_TYPES][N_SECTOR_TYPES] ;
X
X#define STATUS_ENROLLED     -2
X#define STATUS_UNENROLLABLE -1
X#define STATUS_UNBALANCED    0
X#define STATUS_BALANCED      1
X
X/**************
X * Structure for holding information about a race.
X */
Xstruct x {
X  char address[64] ;              /* Person who this is from, or going to. */
X  char filename[64] ;
X  char name[64] ;
X  char password[64] ;
X  char rejection[256] ;           /* Error if this is non-"" */
X  char status ;
X
X  double attr[N_ATTRIBUTES] ;
X  int race_type ;
X  int priv_type ;
X  int home_planet_type ;
X  int n_sector_types ;
X  double compat[N_SECTOR_TYPES] ;
X  } ;
X
X
X
X/**************
X * Global variables for this program.
X */
Xextern struct x race, cost, last ;
X
Xextern int npoints ;
Xextern int last_npoints ;
Xextern int altered ;   /* 1 iff race has been altered since last saved */
Xextern int changed ;   /* 1 iff race has been changed since last printed */
Xextern int please_quit ;   /* 1 iff you want to exit ASAP. */
END_OF_FILE
if test 7169 -ne `wc -c <'hdrs/racegen.h'`; then
    echo shar: \"'hdrs/racegen.h'\" unpacked with wrong size!
fi
# end of 'hdrs/racegen.h'
fi
if test -f 'user/map.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/map.c'\"
else
echo shar: Extracting \"'user/map.c'\" \(6953 characters\)
sed "s/^X//" >'user/map.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * map.c -- display sector map of current planet
X */
X
X#define DISP_DATA 1
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X#include <curses.h>
X
Xracetype       *Race;
Xextern char    *Planet_types[];
X
Xvoid            map(int, int, int);
Xvoid            show_map(int, int, int, int, planettype *, int, int);
Xchar            desshow(int, int, planettype *, int, int, racetype *);
X#include "proto.h"
X
Xvoid 
Xmap(int Playernum, int Governor, int APcount)
X{
X	planettype     *p;
X	placetype       where;
X
X	where = Getplace(Playernum, Governor, args[1], 0);
X
X	if (where.err)
X		return;
X	else if (where.level == LEVEL_SHIP) {
X		notify(Playernum, Governor, "Bad scope.\n");
X		return;
X	} else if (where.level == LEVEL_PLAN) {
X		getplanet(&p, (int) where.snum, (int) where.pnum);
X		show_map(Playernum, Governor, (int) where.snum, (int) where.pnum,
X			 p, DISP_DATA, 0);
X		free(p);
X		if (Stars[where.snum]->stability > 50)
X			notify(Playernum, Governor, "WARNING! This planet's primary is unstable.\n");
X	} else
X		orbit(Playernum, Governor, APcount);	/* make orbit map
X							 * instead */
X}
X
Xvoid 
Xshow_map(int Playernum, int Governor, int snum, int pnum, planettype * p,
X	 int show, int iq)
X{
X	reg int         x, y, i, f = 0, owner, owned1;
X	int             sh;
X	shiptype       *s;
X	char            shiplocs[MAX_X][MAX_Y];
X	hugestr         output;
X
X	bzero((char *) shiplocs, sizeof(shiplocs));
X
X	Race = races[Playernum - 1];
X	getsmap(Smap, p);
X	if (!Race->governor[Governor].toggle.geography) {
X		/*
X		 * traverse ship list on planet; find out if we can look at
X		 * ships here.
X		 */
X		iq = !!p->info[Playernum - 1].numsectsowned;
X		sh = p->ships;
X
X		while (sh) {
X			if (!getship(&s, sh)) {
X				sh = 0;
X				continue;
X			}
X			if (s->owner == Playernum && authorized(Governor, s) &&
X			    (s->popn || (s->type == OTYPE_PROBE)))
X				iq = 1;
X			if (s->alive && landed(s))
X				shiplocs[s->land_x][s->land_y] = Shipltrs[s->type];
X			sh = s->nextship;
X			free(s);
X		}
X	}
X	/* report that this is a planet map */
X	sprintf(output, "$");
X
X	sprintf(buf, "%s;", Stars[snum]->pnames[pnum]);
X	strcat(output, buf);
X
X	sprintf(buf, "%d;%d;%d;", p->Maxx, p->Maxy, show);
X	strcat(output, buf);
X
X	/* send map data */
X	for (y = 0; y < p->Maxy; y++)
X		for (x = 0; x < p->Maxx; x++) {
X			owner = Sector(*p, x, y).owner;
X			owned1 = (owner == Race->governor[Governor].toggle.highlight);
X			if (shiplocs[x][y] && iq) {
X				if (Race->governor[Governor].toggle.color)
X					sprintf(buf, "%c%c", (char) (owner + '?'), shiplocs[x][y]);
X				else {
X					if (owned1 && Race->governor[Governor].toggle.inverse)
X						sprintf(buf, "1%c", shiplocs[x][y]);
X					else
X						sprintf(buf, "0%c", shiplocs[x][y]);
X				}
X			} else {
X				if (Race->governor[Governor].toggle.color)
X					sprintf(buf, "%c%c", (char) (owner + '?'),
X						desshow(Playernum, Governor, p, x, y, Race));
X				else {
X					if (owned1 && Race->governor[Governor].toggle.inverse)
X						sprintf(buf, "1%c", desshow(Playernum, Governor, p, x, y, Race));
X					else
X						sprintf(buf, "0%c", desshow(Playernum, Governor, p, x, y, Race));
X				}
X			}
X			strcat(output, buf);
X		}
X	strcat(output, "\n");
X	notify(Playernum, Governor, output);
X
X	if (show) {
X		sprintf(temp, "Type: %8s   Sects %7s: %3u   Aliens:",
X		Planet_types[p->type], Race->Metamorph ? "covered" : "owned",
X			p->info[Playernum - 1].numsectsowned);
X		if (p->explored || Race->tech >= TECH_EXPLORE) {
X			f = 0;
X			for (i = 1; i < MAXPLAYERS; i++)
X				if (p->info[i - 1].numsectsowned && i != Playernum) {
X					f = 1;
X					sprintf(buf, "%c%d", isset(Race->atwar, i) ? '*' : ' ', i);
X					strcat(temp, buf);
X				}
X			if (!f)
X				strcat(temp, "(none)");
X		} else
X			strcat(temp, "\?\?\?");
X		strcat(temp, "\n");
X		notify(Playernum, Governor, temp);
X		sprintf(temp, "              Guns : %3d             Mob Points : %d\n",
X			p->info[Playernum - 1].guns,
X			p->info[Playernum - 1].mob_points);
X		notify(Playernum, Governor, temp);
X		sprintf(temp, "      Mobilization : %3d (%3d)     Compatibility: %.2f%%",
X			p->info[Playernum - 1].comread,
X			p->info[Playernum - 1].mob_set,
X			compatibility(p, Race));
X		if (p->conditions[TOXIC] > 50) {
X			sprintf(buf, "    (%d%% TOXIC)", p->conditions[TOXIC]);
X			strcat(temp, buf);
X		}
X		strcat(temp, "\n");
X		notify(Playernum, Governor, temp);
X		sprintf(temp, "Resource stockpile : %-9u    Fuel stockpile: %u\n",
X			p->info[Playernum - 1].resource,
X			p->info[Playernum - 1].fuel);
X		notify(Playernum, Governor, temp);
X		sprintf(temp, "      Destruct cap : %-9u%18s: %-5u (%u/%u)\n",
X			p->info[Playernum - 1].destruct,
X		   Race->Metamorph ? "Tons of biomass" : "Total Population",
X			p->info[Playernum - 1].popn, p->popn,
X			round_rand(.01 * (100. - p->conditions[TOXIC]) * p->maxpopn));
X		notify(Playernum, Governor, temp);
X		sprintf(temp, "          Crystals : %-9u%18s: %-5u (%u)\n",
X			p->info[Playernum - 1].crystals,
X		 "Ground forces", p->info[Playernum - 1].troops, p->troops);
X		notify(Playernum, Governor, temp);
X		sprintf(temp, "%d Total Resource Deposits     Tax rate %u%%  New %u%%\n",
X			p->total_resources, p->info[Playernum - 1].tax,
X			p->info[Playernum - 1].newtax);
X		notify(Playernum, Governor, temp);
X		sprintf(temp, "Estimated Production Next Update : %.2f\n",
X			p->info[Playernum - 1].est_production);
X		notify(Playernum, Governor, temp);
X		if (p->slaved_to) {
X			sprintf(temp, "      ENSLAVED to player %d\n", p->slaved_to);
X			notify(Playernum, Governor, temp);
X		}
X	}
X}
X
Xchar 
Xdesshow(int Playernum, int Governor, planettype * p,
X	int x, int y, racetype * r)
X{
X	reg sectortype *s;
X
X	s = &Sector(*p, x, y);
X
X	if (s->troops && !r->governor[Governor].toggle.geography)
X		if (s->owner == Playernum)
X			return CHAR_MY_TROOPS;
X		else if (isset(r->allied, s->owner))
X			return CHAR_ALLIED_TROOPS;
X		else if (isset(r->atwar, s->owner))
X			return CHAR_ATWAR_TROOPS;
X		else
X			return CHAR_NEUTRAL_TROOPS;
X
X	if (s->owner && !r->governor[Governor].toggle.geography &&
X	    !r->governor[Governor].toggle.color) {
X		if (!r->governor[Governor].toggle.inverse ||
X		    s->owner != r->governor[Governor].toggle.highlight)
X			if (!r->governor[Governor].toggle.double_digits)
X				return s->owner % 10 + '0';
X			else {
X				if (s->owner < 10 || x % 2)
X					return s->owner % 10 + '0';
X				else
X					return s->owner / 10 + '0';
X			}
X	}
X	if (s->crystals && (r->discoveries[D_CRYSTAL] || r->God))
X		return CHAR_CRYSTAL;
X
X	switch (s->condition) {
X	case WASTED:
X		return CHAR_WASTED;
X	case SEA:
X		return CHAR_SEA;
X	case LAND:
X		return CHAR_LAND;
X	case MOUNT:
X		return CHAR_MOUNT;
X	case GAS:
X		return CHAR_GAS;
X	case PLATED:
X		return CHAR_PLATED;
X	case ICE:
X		return CHAR_ICE;
X	case DESERT:
X		return CHAR_DESERT;
X	case FOREST:
X		return CHAR_FOREST;
X	default:
X		return ('?');
X	}
X}
END_OF_FILE
if test 6953 -ne `wc -c <'user/map.c'`; then
    echo shar: \"'user/map.c'\" unpacked with wrong size!
fi
# end of 'user/map.c'
fi
if test -f 'user/tele.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/tele.c'\"
else
echo shar: Extracting \"'user/tele.c'\" \(6701 characters\)
sed "s/^X//" >'user/tele.c' <<'END_OF_FILE'
X#ident  "@(#)tele.c	1.7 2/1/93 "
X/***********************************************
X * tele.c
X *
X * Created: ??
X * Author:  Robert Chansky
X *
X * Version: 1.7 00:14:43
X *
X * Contains: purge()
X *           post()
X *           push_telegram_race()
X *           push_telegram()
X *           teleg_read()
X *           news_read()
X *
X ***********************************************/
X
X#define EXTERN extern
X#include "GB_copyright.h"
X#include "vars.h"
X#include "files.h"
X#include "races.h"
X#include "buffers.h"
X#include "power.h"
X#include "ships.h"
X#include <stdio.h>
X#include <ctype.h>
X#include <strings.h>
X#include <errno.h>
X#include <signal.h>
X#include <sys/file.h>
X#include <sys/time.h>
X#include <sys/stat.h>
X
X
Xlong            tm;
XFILE            *teleg_read_fd;
Xchar            telegram_file[PATHLEN];
Xstruct 			stat telestat;
X
X
X/*
X * Prototypes
X */
Xvoid            purge(void);
Xvoid            post(char *, int);
Xvoid            push_telegram_race(int, char *);
Xvoid            push_telegram(int, int, char *);
Xvoid            teleg_read(int, int);
Xvoid            news_read(int, int, int);
X#include "proto.h"
X
Xstruct tm      *current_tm;	/* for watching for next update */
X
X/*
X * purge:
X * 
X * arguments: none
X * 
X * called by: process_commands
X * 
X * description:  Used to purge the News files.
X * 
X */
Xvoid 
Xpurge(void)
X{
X	fclose(fopen(DECLARATIONFL, "w+"));
X	newslength[0] = 0;
X	fclose(fopen(COMBATFL, "w+"));
X	newslength[1] = 0;
X	fclose(fopen(ANNOUNCEFL, "w+"));
X	newslength[2] = 0;
X	fclose(fopen(TRANSFERFL, "w+"));
X	newslength[3] = 0;
X}
X
X/*
X * post:
X * 
X * arguments: msg  The actual message type Type of message.  Valid types are
X * DECLARATION, TRANSFER, COMBAT and ANNOUNCE.
X * 
X * called by:  fire, name, declare, dock, land, dissolve, doship, doturn
X * 
X * description: does the acutal posting of messages to the news files
X * 
X */
Xvoid 
Xpost(char *msg, int type)
X{
X	char            telefl[100];
X	char            pbuf[1024];	/* this is needed, don't use global
X					 * pointer! */
X	FILE           *news_fd;
X	char           *p;
X
X	switch (type) {
X	case DECLARATION:
X		sprintf(telefl, "%s", DECLARATIONFL);
X		break;
X	case TRANSFER:
X		sprintf(telefl, "%s", TRANSFERFL);
X		break;
X	case COMBAT:
X		sprintf(telefl, "%s", COMBATFL);
X		break;
X	case ANNOUNCE:
X		sprintf(telefl, "%s", ANNOUNCEFL);
X		break;
X	default:
X		return;
X	}
X
X	/* look for special symbols */
X	for (p = msg; *p; p++) {
X		if (*p == ';')
X			*p = '\n';
X		else if (*p == '|')
X			*p = '\t';
X	}
X
X	if ((news_fd = fopen(telefl, "a")) == NULL) {
X		return;
X	} else {
X		tm = time(0);
X		current_tm = localtime(&tm);
X		sprintf(pbuf, "%2d/%2d %02d:%02d:%02d %s",
X			current_tm->tm_mon + 1, current_tm->tm_mday, current_tm->tm_hour,
X			current_tm->tm_min, current_tm->tm_sec, msg);
X		fprintf(news_fd, "%s", pbuf);
X		fclose(news_fd);
X		newslength[type] += strlen(pbuf);
X	}
X}
X
X/*
X * push_telegram_race:
X * 
X * arguments: recpient msg
X * 
X * called by:
X * 
X * description:  Sends a message to everyone in the race
X * 
X */
Xvoid
Xpush_telegram_race(int recpient, char *msg)
X{
X	racetype       *Race;
X	reg int         j;
X
X	Race = races[recpient - 1];
X	for (j = 0; j <= MAXGOVERNORS; j++)
X		if (Race->governor[j].active)
X			push_telegram(recpient, j, msg);
X}
X
X/*
X * push_telegram:
X * 
X * arguments: recpient gov msg
X * 
X * called by:
X * 
X * description:  Sends a message to everyone from person to person
X * 
X */
Xvoid 
Xpush_telegram(int recpient, int gov, char *msg)
X{
X	char            telefl[100];
X	FILE           *telegram_fd;
X
X	sprintf(telefl, "%s.%d.%d", TELEGRAMFL, recpient, gov);
X
X	if ((telegram_fd = fopen(telefl, "a")) == NULL)
X		if ((telegram_fd = fopen(telefl, "w+")) == NULL) {
X			perror("teleg_send");
X			return;
X		}
X	tm = time(0);
X	current_tm = localtime(&tm);
X
X	fprintf(telegram_fd, "%2d/%2d %02d:%02d:%02d %s\n",
X	   current_tm->tm_mon + 1, current_tm->tm_mday, current_tm->tm_hour,
X		current_tm->tm_min, current_tm->tm_sec, msg);
X	fclose(telegram_fd);
X}
X/*
X * *	read_teleg.c -- (try to) read telegrams *	 the first byte in
X * each telegram is the sending player #, or 254 *	 to denote
X * autoreport.  then the time sent, then the message itself, *	 terminated
X * by TELEG_DELIM.
X */
X/*
X * teleg_read:
X * 
X * arguments: Playernum Governor
X * 
X * called by: process_commands
X * 
X * description:  Read the telegrams for the player.  The first byte in each
X * telegram is the sending player number or 254 to denote an autoreport.
X * Then the time send, then the message, then terminated by TELEG_DELIM
X */
Xvoid
Xteleg_read(int Playernum, int Governor)
X{
X	char           *p;
X	sprintf(telegram_file, "%s.%d.%d", TELEGRAMFL, Playernum, Governor);
X
X	if ((teleg_read_fd = fopen(telegram_file, "r")) != 0) {
X		notify(Playernum, Governor, "Telegrams:");
X		stat(telegram_file, &telestat);
X		if (telestat.st_size > 0) {
X			notify(Playernum, Governor, "\n");
X			while (fgets(buf, sizeof buf, teleg_read_fd)) {
X				for (p = buf; *p; p++)
X					if (*p == '\n') {
X						*p = '\0';
X						break;
X					}
X				strcat(buf, "\n");
X				notify(Playernum, Governor, buf);
X			}
X		} else {
X			notify(Playernum, Governor, " None.\n");
X		}
X
X		fclose(teleg_read_fd);
X		teleg_read_fd = fopen(telegram_file, "w+");	/* trunc file */
X		fclose(teleg_read_fd);
X	} else {
X		sprintf(buf, "\nTelegram file %s non-existent.\n", telegram_file);
X		notify(Playernum, Governor, buf);
X		loginfo(ERRORLOG, NOERRNO,
X			"Telegram file for %s non-existant", telegram_file);
X		return;
X	}
X}
X/*
X * news_read:
X * 
X * arguments: Playernum Governor Type
X * 
X * description:  Read the news file
X * 
X */
Xvoid 
Xnews_read(int Playernum, int Governor, int type)
X{
X	char           *p;
X	racetype       *Race;
X
X	switch (type) {
X	case DECLARATION:
X		sprintf(telegram_file, "%s", DECLARATIONFL);
X		break;
X	case TRANSFER:
X		sprintf(telegram_file, "%s", TRANSFERFL);
X		break;
X	case COMBAT:
X		sprintf(telegram_file, "%s", COMBATFL);
X		break;
X	case ANNOUNCE:
X		sprintf(telegram_file, "%s", ANNOUNCEFL);
X		break;
X	default:
X		return;
X	}
X
X	if ((teleg_read_fd = fopen(telegram_file, "r")) != 0) {
X		Race = races[Playernum - 1];
X		if (Race->governor[Governor].newspos[type] > newslength[type])
X			Race->governor[Governor].newspos[type] = 0;
X
X		fseek(teleg_read_fd, Race->governor[Governor].newspos[type], 0);
X		while (fgets(buf, sizeof buf, teleg_read_fd)) {
X			for (p = buf; *p; p++)
X				if (*p == '\n') {
X					*p = '\0';
X					break;
X				}
X			strcat(buf, "\n");
X			notify(Playernum, Governor, buf);
X		}
X
X		fclose(teleg_read_fd);
X		Race->governor[Governor].newspos[type] = newslength[type];
X		putrace(Race);
X	} else {
X		sprintf(buf, "\nNews file %s non-existent.\n", telegram_file);
X		notify(Playernum, Governor, buf);
X		loginfo(ERRORLOG, NOERRNO,
X			"Telegram file for %s non-existant", telegram_file);
X		return;
X	}
X}
END_OF_FILE
if test 6701 -ne `wc -c <'user/tele.c'`; then
    echo shar: \"'user/tele.c'\" unpacked with wrong size!
fi
# end of 'user/tele.c'
fi
if test -f 'utils/enroll.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/enroll.c'\"
else
echo shar: Extracting \"'utils/enroll.c'\" \(5980 characters\)
sed "s/^X//" >'utils/enroll.c' <<'END_OF_FILE'
X/* enroll - racegen interface for Galactic Bloodshed race enrollment program.
X * Copyright (c) Leonard Dickens 1991   (leonard@cs.umd.edu)
X *
X * Permission to copy, distribute, and/or alter is granted as long as the copy-
X * right notice and these terms are left unchanged in all derivatives/copies.
X * 
X * Anybody who does alter this program, please take credit!
X */
X#include "racegen.h"
X
X#define DEFAULT_ENROLLMENT_FILENAME "enroll.saves"
X#define DEFAULT_ENROLLMENT_FAILURE_FILENAME "failures.saves"
X
X#ifdef __STDC__
Xextern int enroll_valid_race(void) ;
X#else
Xextern int enroll_valid_race() ;
X#endif
X
X/*
X * Returns: 0 if the race was successfully enrolled, or 1 if not.
X */
Xint enroll_player_race(failure_filename)
X     char *failure_filename ;
X{
X  char c[128] ;
X  FILE *f, *g ;
X  int n ;
X  static int recursing = 0 ;
X  static int successful_enroll_in_fix_mode = 0 ;
X
X  while (n = critique_to_file(NULL, 1, 1)) {
X    printf("Race (%s) unacceptable, for the following reason%c:\n",
X	   race.name, (n > 1) ? 's' : '\0') ;
X    critique_to_file(stdout, 1, 1) ;
X    if (recursing) {
X      printf("\"Quit\" to break out of fix mode.\n") ;
X      return 1 ;
X      }
X    if (race.status == STATUS_ENROLLED)
X      return 0 ;
X    n = Dialogue("Abort, enroll anyway, fix, mail rejection?",
X		 "abort", "enroll", "fix", "mail", 0) ;
X    if (n == 1)     /* enroll anyway */
X      break ;
X    if (n == 2) {   /* fix */
X      printf("Recursive racegen.  \"Enroll\" or \"Quit\" to exit.\n") ;
X      recursing = 1 ;
X      modify_print_loop(1) ;
X      please_quit = recursing = 0 ;
X      if (successful_enroll_in_fix_mode) {
X	successful_enroll_in_fix_mode = 0 ;
X	return 0 ;
X	}
X      continue ;
X      }
X    if (failure_filename != NULL) 
X      if (NULL == fopen(failure_filename, "w+")) {
X	printf("Warning: unable to open failures file \"%s\".\n", 
X	       failure_filename) ;
X	printf("Race not saved to failures file.\n") ;
X	}
X      else {
X	print_to_file(f, 0) ;
X	printf("Race appended to failures file \"%s\".\n", failure_filename) ;
X	fclose(f) ;
X	}
X    if (n == 0)    /* Abort */
X      return 1 ;
X    
X    g = fopen(TMP, "w") ;
X    if (g == NULL) {
X      printf("Unable to open file \"%s\".\n", TMP) ;
X      return 1 ;
X      }
X    fprintf(g, "To: %s\n", race.address) ;
X    fprintf(g, "Subject: %s Race Rejection\n", GAME) ;
X    fprintf(g, "\n") ;
X    fprintf(g, "The race you submitted (%s) was not accepted, for the following reason%c:\n", race.name, (n > 1) ? 's' : '\0') ;
X    critique_to_file(g, 1, 1) ;
X    fprintf(g, "\n") ;
X    fprintf(g, "Please re-submit a race if you want to play in %s.\n", GAME);
X    fprintf(g, "(Check to make sure you are using racegen %s)\n", GBVERSION) ;
X    fprintf(g, "\n") ;
X    fprintf(g, "For verification, here is my understanding of your race:\n");
X    print_to_file(g, 1, 0) ;
X    fclose(g) ;
X    
X    printf("Sending critique to %s via %s...", race.address, MAILER) ;
X    fflush(stdout) ;
X    sprintf(c, "cat %s | %s %s", TMP, MAILER, race.address) ;
X    system(c) ;
X    printf("done.\n") ;
X
X    return 1 ;
X    }
X
X  if (enroll_valid_race())
X    return enroll_player_race(failure_filename) ;
X  
X  if (recursing) {
X    successful_enroll_in_fix_mode = 1 ;
X    please_quit = 1 ;
X    }
X  
X  g = fopen(TMP, "w") ;
X  if (g == NULL) {
X    printf("Unable to open file \"%s\".\n", TMP) ;
X    return 0 ;
X    }
X  fprintf(g, "To: %s\n", race.address) ;
X  fprintf(g, "Subject: %s Race Accepted\n", GAME) ;
X  fprintf(g, "\n") ;
X  fprintf(g, "The race you submitted (%s) was accepted.\n", race.name) ;
X#if 0
X  if (race.modified_by_diety) {
X    fprintf(g, "The race was altered in order to be acceptable.\n") ;
X    fprintf(g, "Your race now looks like this:\n") ;
X    fprintf(g, "\n") ;
X    print_to_file(g, verbose, 0) ;
X    fprintf(g, "\n") ;
X    }
X#endif
X  fclose(g) ;
X  
X  printf("Sending acceptance to %s via %s...", race.address, MAILER) ;
X  fflush(stdout) ;
X  sprintf(c, "cat %s | %s %s", TMP, MAILER, race.address) ;
X  system(c) ;
X  printf("done.\n") ;
X  
X  return 0 ;
X  }
X
X
Xint enroll(argc, argv)
X     int argc ;
X     char *argv[] ;
X{
X  int ret ;
X  FILE *g ;
X
X  if (argc < 2)
X    argv[1] = DEFAULT_ENROLLMENT_FAILURE_FILENAME ;
X  g = fopen(argv[1], "w+") ;
X  if (g == NULL)
X    printf("Unable to open failures file \"%s\".\n", argv[1]) ;
X  fclose(g) ;
X  bcopy(&race, &last, sizeof(struct x)) ;
X
X  /*
X   * race.address will be unequal to TO in the instance that this is a
X   * race submission mailed from somebody other than the moderator.  */
X  if (strcmp(race.address, TO))
X    ret = enroll_player_race(argv[1]) ;
X  else
X    if (ret = critique_to_file(NULL, 1, 0)) {
X      printf("Race (%s) unacceptable, for the following reason%c:\n",
X	     race.name, (ret > 1) ? 's' : '\0') ;
X      critique_to_file(stdout, 1, 0) ;
X      }
X    else
X      if (ret = enroll_valid_race())
X	critique_to_file(stdout, 1, 0) ;
X
X  if (ret)
X    printf("Enroll failed.\n") ;
X  return ret ;
X  }
X
X
X/**************
X * Iteratively loads races from a file, and enrolls them.
X */
Xvoid process(argc, argv)
X     int argc ;
X     char *argv[] ;
X{
X  FILE *f, *g ;
X  int n, nenrolled ;
X
X  if (argc < 2)
X    argv[1] = DEFAULT_ENROLLMENT_FILENAME ;
X  f = fopen(argv[1], "r") ;
X  if (f == NULL) {
X    printf("Unable to open races file \"%s\".\n", argv[1]) ;
X    return ;
X    }
X
X  if (argc < 3)
X    argv[2] = DEFAULT_ENROLLMENT_FAILURE_FILENAME ;
X  g = fopen(argv[2], "w") ;
X  if (g == NULL)
X    printf("Unable to open failures file \"%s\".\n", argv[2]) ;
X  fclose(g) ;
X
X  n = 0 ;
X  nenrolled = 0 ;
X  while (! feof(f)) {
X    if (! load_from_file(f))
X      continue ;
X    n++ ;
X    printf("%s, from %s\n", race.name, race.address) ;
X    /* We need the side effects: */
X    last_npoints = npoints ;
X    npoints = STARTING_POINTS - cost_of_race() ;
X    if (! enroll_player_race(argv[2]))
X      nenrolled += 1 ;
X    }
X  fclose(f) ;
X
X  printf("Enrolled %d race%c; %d failure%c saved in file %s.\n",
X	 nenrolled, (nenrolled != 1)?'s':'\0', 
X	 n - nenrolled, (n - nenrolled != 1)?'s':'\0', argv[2]) ;
X  }
END_OF_FILE
if test 5980 -ne `wc -c <'utils/enroll.c'`; then
    echo shar: \"'utils/enroll.c'\" unpacked with wrong size!
fi
# end of 'utils/enroll.c'
fi
if test -f 'utils/psmap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/psmap.c'\"
else
echo shar: Extracting \"'utils/psmap.c'\" \(3514 characters\)
sed "s/^X//" >'utils/psmap.c' <<'END_OF_FILE'
X#include "stdio.h"
X
X/* starmap.c                                                           */
X/* produces a Postscript map from the output of the GB command 'stars' */
X/* Copyright: Andreas Girgensohn (andreasg@cs.colorado.edu)            */
X
Xstruct star {
X  int   x,
X        y;
X  char  name[80];
X};
X
Xstruct star stars[200];
Xint   nstars,
X      highlight_home = 1,
X      highlighted_star = -1,	/* star that will be highlighted */
X      nrings = 20,		/* number of distance rings around the
X				   highlighted star */
X      ring_spacing = 10000;
X
Xmain (argc, argv)
Xint   argc;
Xchar *argv[];
X{
X  scan_stars (stdin);
X  if (nstars == 0)
X    fprintf (stderr, "No stars\n");
X  else
X    produce_postscript ();
X  exit (0);
X}
X
Xscan_stars (fin)
XFILE * fin;
X{
X  char  line[200];
X  int   distance,
X        in_stars = 0;
X
X  nstars = 0;
X  while (fgets (line, 200, fin) != NULL) {
X    if (sscanf (line, "(%*d) %79s ( %d, %d) %d", stars[nstars].name,
X	  &(stars[nstars].x), &(stars[nstars].y), &distance) == 4) {
X      if (highlight_home && distance == 0)
X	highlighted_star = nstars;
X      nstars++;
X      if (!in_stars)
X	in_stars = 1;
X    }
X    else
X      if (in_stars)
X	break;
X  }
X}
X
Xproduce_postscript () {
X  int   min_x,
X        max_x,
X        min_y,
X        max_y,
X        i;
X  double  scale,
X          nscale;
X
X  min_x = max_x = stars[0].x;
X  min_y = max_y = stars[0].y;
X  for (i = 1; i < nstars; i++) {
X    if (stars[i].x < min_x)
X      min_x = stars[i].x;
X    if (stars[i].x > max_x)
X      max_x = stars[i].x;
X    if (stars[i].y < min_y)
X      min_y = stars[i].y;
X    if (stars[i].y > max_y)
X      max_y = stars[i].y;
X  }
X  /* max map size: 8.5in x 11in sheet, 0.5in borders, */
X  /* 0.5in on the right for star names */
X  /* 72 points = 1in */
X  scale = 7.0 * 72 / (max_x - min_x);
X  nscale = 10.0 * 72 / (max_y - min_y);
X  if (nscale < scale)
X    scale = nscale;
X  printf ("%%!PS-Adobe-2.0\n\n");
X  /* 0,0 is in the topleft corner */
X  printf ("0.5 72 mul 10.5 72 mul translate\n");
X  printf ("/drawcircle\n");
X  printf ("{\n");
X  printf ("  newpath 0 360 arc stroke\n");
X  printf ("}\n");
X  printf ("def\n\n");
X  printf ("/drawstar\n");
X  printf ("{\n");
X  printf ("  /starname exch def\n");
X  printf ("  /ypos exch def\n");
X  printf ("  /xpos exch def\n");
X  printf ("  xpos ypos 2 drawcircle\n");
X  printf ("  4 xpos add ypos moveto\n");
X  printf ("  starname show\n");
X  printf ("}\n");
X  printf ("def\n\n");
X  printf ("0 setlinewidth\n");
X  printf ("newpath -10 10 moveto 7.5 72 mul 10 add 10 lineto\n");
X  printf ("7.5 72 mul 10 add %d lineto -10 %d lineto closepath clip\n",
X      (int) ((min_y - max_y) * scale) - 10,
X      (int) ((min_y - max_y) * scale) - 10);
X  if (highlighted_star >= 0 && highlighted_star < nstars) {
X    printf ("\n/Times-Bold findfont 9 scalefont setfont\n\n");
X    draw_star (stars + highlighted_star, min_x, min_y, scale);
X    for (i = 1; i <= nrings; i++)
X      printf ("%d %d %d drawcircle\n",
X	  (int) ((stars[highlighted_star].x - min_x) * scale),
X	  (int) ((min_y - stars[highlighted_star].y) * scale),
X	  (int) (i * ring_spacing * scale));
X  }
X  printf ("\n/Times-Roman findfont 8 scalefont setfont\n\n");
X  for (i = 0; i < nstars; i++)
X    if (i != highlighted_star)
X      draw_star (stars + i, min_x, min_y, scale);
X  printf ("\nshowpage\n");
X}
X
Xdraw_star (star, min_x, min_y, scale)
Xstruct star *star;
Xint   min_x,
X      min_y;
Xdouble  scale;
X{
X  printf ("%d %d (%s) drawstar\n", (int) ((star -> x - min_x) * scale),
X      (int) ((min_y - star -> y) * scale), star -> name);
X}
X
END_OF_FILE
if test 3514 -ne `wc -c <'utils/psmap.c'`; then
    echo shar: \"'utils/psmap.c'\" unpacked with wrong size!
fi
# end of 'utils/psmap.c'
fi
echo shar: End of archive 18 \(of 21\).
cp /dev/null ark18isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
