Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i020:  gbp - Galactic Bloodshed+, an empire-like war game, Part08/21
Message-ID: <4548@master.CNA.TEK.COM>
Date: 12 Feb 93 17:30:56 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1913
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1699

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 20
Archive-name: gbp/Part08
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 21)."
# Contents:  buildfiles.sh user/order.c user/shootblast.c
# Wrapped by billr@saab on Fri Feb 12 09:14:25 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'buildfiles.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'buildfiles.sh'\"
else
echo shar: Extracting \"'buildfiles.sh'\" \(96 characters\)
sed "s/^X//" >'buildfiles.sh' <<'END_OF_FILE'
X#!/bin/sh
X
Xcat user/build.c1 user/build.c2 > user/build.c
Xrm user/build.c1 user/build.c2
Xexit 0
END_OF_FILE
if test 96 -ne `wc -c <'buildfiles.sh'`; then
    echo shar: \"'buildfiles.sh'\" unpacked with wrong size!
fi
chmod +x 'buildfiles.sh'
# end of 'buildfiles.sh'
fi
if test -f 'user/order.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/order.c'\"
else
echo shar: Extracting \"'user/order.c'\" \(32144 characters\)
sed "s/^X//" >'user/order.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * order.c -- give orders to ship
X */
X
X#include <curses.h>
X#include <ctype.h>
X#include <signal.h>
X#include <math.h>
X#include <strings.h>
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X
Xvoid            order(int, int, int);
Xvoid            give_orders(int, int, int, shiptype *);
Xchar           *prin_aimed_at(int, int, shiptype *);
Xchar           *prin_ship_dest(int, int, shiptype *);
Xvoid            mk_expl_aimed_at(int, int, shiptype *);
Xvoid            DispOrdersHeader(int, int);
Xvoid            DispOrders(int, int, shiptype *);
Xvoid            route(int, int, int);
X#include "proto.h"
X
Xvoid 
Xorder(int Playernum, int Governor, int APcount)
X{
X	int             shipno, nextshipno;
X	shiptype       *ship;
X
X	if (argn == 1) {	/* display all ship orders */
X		DispOrdersHeader(Playernum, Governor);
X		nextshipno = start_shiplist(Playernum, Governor, "test");
X		while (shipno = do_shiplist(&ship, &nextshipno))
X			if (ship->owner == Playernum && authorized(Governor, ship)) {
X				DispOrders(Playernum, Governor, ship);
X				free(ship);
X			} else
X				free(ship);
X	} else if (argn >= 2) {
X		DispOrdersHeader(Playernum, Governor);
X		nextshipno = start_shiplist(Playernum, Governor, args[1]);
X		while (shipno = do_shiplist(&ship, &nextshipno))
X			if (in_list(Playernum, args[1], ship, &nextshipno) &&
X			    authorized(Governor, ship)) {
X				if (argn > 2)
X					give_orders(Playernum, Governor, APcount, ship);
X				DispOrders(Playernum, Governor, ship);
X				free(ship);
X			} else
X				free(ship);
X	} else
X		notify(Playernum, Governor, "I don't understand what you mean.\n");
X}
X
Xvoid 
Xgive_orders(int Playernum, int Governor, int APcount, shiptype * ship)
X{
X	int             i = 0, j = 0;
X	placetype       where, pl;
X	planettype     *planet;
X	shiptype       *tmpship;
X
X	if (!ship->active) {
X		sprintf(buf, "%s is irradiated (%d); it cannot be give orders.\n",
X			Ship(ship), ship->rad);
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	if (ship->type != OTYPE_TRANSDEV && !ship->popn && Max_crew(ship)) {
X		sprintf(buf, "%s has no crew and is not a robotic ship.\n", Ship(ship));
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	if (match(args[2], "defense")) {
X		if (can_bombard(ship)) {
X			if (match(args[3], "off"))
X				ship->protect.planet = 0;
X			else
X				ship->protect.planet = 1;
X		} else {
X			notify(Playernum, Governor, "That ship cannot be assigned those orders.\n");
X			return;
X		}
X	} else if (match(args[2], "scatter")) {
X		if (ship->type != STYPE_MISSILE) {
X			notify(Playernum, Governor, "Only missiles can be given this order.\n");
X			return;
X		}
X		ship->special.impact.scatter = 1;
X	} else if (match(args[2], "impact")) {
X		int             x, y;
X		if (ship->type != STYPE_MISSILE) {
X			notify(Playernum, Governor, "Only missiles can be designated for this.\n");
X			return;
X		}
X		sscanf(args[3], "%d,%d", &x, &y);
X		ship->special.impact.x = x;
X		ship->special.impact.y = y;
X		ship->special.impact.scatter = 0;
X	} else if (match(args[2], "jump")) {
X		if (ship->docked) {
X			notify(Playernum, Governor, "That ship is docked. Use 'launch' or 'undock' first.\n");
X			return;
X		}
X		if (ship->hyper_drive.has) {
X			if (match(args[3], "off"))
X				ship->hyper_drive.on = 0;
X			else {
X				if (ship->whatdest != LEVEL_STAR && ship->whatdest != LEVEL_PLAN) {
X					notify(Playernum, Governor, "Destination must be star or planet.\n");
X					return;
X				}
X				ship->hyper_drive.on = 1;
X				ship->navigate.on = 0;
X				if (ship->mounted) {
X					ship->hyper_drive.charge = 1;
X					ship->hyper_drive.ready = 1;
X				}
X			}
X		} else {
X			notify(Playernum, Governor, "This ship does not have hyper drive capability.\n");
X			return;
X		}
X#ifdef THRESHLOADING
X    } else if (match(args[2], "threshload")) {
X    /* CWL threshold loading */
X      if (argn == 3) { /* Clear all thresholds */
X	int i;
X	for (i=0;i<=TH_CRYSTALS;i++) 
X	  ship->threshload[i] = 0;
X	notify(Playernum, Governor, "All threshloads cleared.\n");
X      } else if (argn == 4 || argn == 5) { /* Clear one threshold */
X	unsigned amount;
X	char *c;
X	amount = (argn == 5) ? (unsigned)atoi(args[4]) : 1000; 
X	c = args[3];
X	while (*c) {
X	  if (*c == 'r') {
X	    if (amount > ship->max_resource)
X	      ship->threshload[TH_RESOURCE] = ship->max_resource;
X	    else
X	      ship->threshload[TH_RESOURCE] = amount;
X	  } else if (*c == 'd') {
X	    if (amount > ship->max_destruct)
X	      ship->threshload[TH_DESTRUCT] = ship->max_destruct;
X	    else
X	      ship->threshload[TH_DESTRUCT] = amount;
X	  } else if (*c == 'f') {
X	    if (amount > (int)ship->max_fuel)
X	      ship->threshload[TH_FUEL] = ship->max_fuel;
X	    else
X	      ship->threshload[TH_FUEL] = amount;
X	  } else if (*c == 'x') {
X	    if (amount > Max_crystals(s))
X	      ship->threshload[TH_CRYSTALS] = Max_crystals(s);
X	    else
X	      ship->threshload[TH_CRYSTALS] = amount;
X	  } else 
X	     notify(Playernum, Governor, "Unknown commodity; use rdfx.\n");
X	  c++;
X	} /* end while */
X      }
X      else
X	notify(Playernum, Governor, "threshold <rdfx> [amount]\n");
X#endif 
X#ifdef AUTOSCRAP
X    } else if (match(args[2], "autoscrap")) { /* AUTOSCRAP */
X      ship->autoscrap = !ship->autoscrap;
X#endif 
X	} else if (match(args[2], "protect")) {
X		if (argn > 3)
X			sscanf(args[3] + (args[3][0] == '#'), "%d", &j);
X		else
X			j = 0;
X		if (j == ship->number) {
X			notify(Playernum, Governor, "You can't do that.\n");
X			return;
X		}
X		if (can_bombard(ship)) {
X			if (!j) {
X				ship->protect.on = 0;
X			} else {
X				ship->protect.on = 1;
X				ship->protect.ship = j;
X			}
X		} else {
X			notify(Playernum, Governor, "That ship cannot protect.\n");
X			return;
X		}
X	} else if (match(args[2], "navigate")) {
X		if (argn >= 5) {
X			ship->navigate.on = 1;
X			ship->navigate.bearing = atoi(args[3]);
X			ship->navigate.turns = atoi(args[4]);
X		} else
X			ship->navigate.on = 0;
X		if (ship->hyper_drive.on)
X			ship->hyper_drive.on = 0;
X	} else if (match(args[2], "switch")) {
X		if (ship->type == OTYPE_FACTORY) {
X			notify(Playernum, Governor, "Use \"on\" to bring factory online.\n");
X			return;
X		}
X		if (has_switch(ship)) {
X			if (ship->whatorbits == LEVEL_SHIP) {
X				notify(Playernum, Governor, "That ship is being transported.\n");
X				return;
X			}
X			ship->on = !ship->on;
X		} else {
X			sprintf(buf, "That ship does not have an on/off setting.\n");
X			notify(Playernum, Governor, buf);
X			return;
X		}
X		if (ship->on) {
X			switch (ship->type) {
X			case STYPE_MINE:
X				notify(Playernum, Governor, "Mine armed and ready.\n");
X				break;
X			case OTYPE_TRANSDEV:
X				notify(Playernum, Governor, "Transporter ready to receive.\n");
X				break;
X			default:
X				break;
X			}
X		} else {
X			switch (ship->type) {
X			case STYPE_MINE:
X				notify(Playernum, Governor, "Mine disarmed.\n");
X				break;
X			case OTYPE_TRANSDEV:
X				notify(Playernum, Governor, "No longer receiving.\n");
X				break;
X			default:
X				break;
X			}
X		}
X	} else if (match(args[2], "destination")) {
X		if (speed_rating(ship)) {
X			if (ship->docked) {
X				notify(Playernum, Governor, "That ship is docked; use undock or launch first.\n");
X				return;
X			}
X			where = Getplace(Playernum, Governor, args[3], 1);
X			if (!where.err) {
X				if (where.level == LEVEL_SHIP) {
X					(void) getship(&tmpship, where.shipno);
X					if (!followable(ship, tmpship)) {
X						notify(Playernum, Governor, "Warning: that ship is out of range.\n");
X						free(tmpship);
X						return;
X					}
X					free(tmpship);
X					ship->destshipno = where.shipno;
X					ship->whatdest = LEVEL_SHIP;
X				} else {
X					/* to foil cheaters */
X					if (where.level != LEVEL_UNIV &&
X					    ((ship->storbits != where.snum) && where.level != LEVEL_STAR) &&
X					    isclr(Stars[where.snum]->explored, ship->owner)) {
X						notify(Playernum, Governor, "You haven't explored this system.\n");
X						return;
X					}
X					ship->whatdest = where.level;
X					ship->deststar = where.snum;
X					ship->destpnum = where.pnum;
X				}
X			} else
X				return;
X		} else {
X			notify(Playernum, Governor, "That ship cannot be launched.\n");
X			return;
X		}
X	} else if (match(args[2], "evade")) {
X		if (Max_crew(ship) && Max_speed(ship)) {
X			if (match(args[3], "on"))
X				ship->protect.evade = 1;
X			else if (match(args[3], "off"))
X				ship->protect.evade = 0;
X		} else
X			return;
X	} else if (match(args[2], "bombard")) {
X		if (ship->type != OTYPE_OMCL) {
X			if (can_bombard(ship)) {
X				if (match(args[3], "off"))
X					ship->bombard = 0;
X				else if (match(args[3], "on"))
X					ship->bombard = 1;
X			} else
X				notify(Playernum, Governor, "This type of ship cannot be set to retaliate.\n");
X		}
X	} else if (match(args[2], "retaliate")) {
X		if (ship->type != OTYPE_OMCL) {
X			if (can_bombard(ship)) {
X				if (match(args[3], "off"))
X					ship->protect.self = 0;
X				else if (match(args[3], "on"))
X					ship->protect.self = 1;
X			} else
X				notify(Playernum, Governor, "This type of ship cannot be set to retaliate.\n");
X		}
X	} else if (match(args[2], "focus")) {
X		if (ship->laser) {
X			if (match(args[3], "on"))
X				ship->focus = 1;
X			else
X				ship->focus = 0;
X		} else
X			notify(Playernum, Governor, "No laser.\n");
X	} else if (match(args[2], "laser")) {
X		if (ship->laser) {
X			if (can_bombard(ship)) {
X				if (ship->mounted) {
X					if (match(args[3], "on"))
X						ship->fire_laser = atoi(args[4]);
X					else
X						ship->fire_laser = 0;
X				} else
X					notify(Playernum, Governor, "You do not have a crystal mounted.\n");
X			} else
X				notify(Playernum, Governor, "This type of ship cannot be set to retaliate.\n");
X		} else
X			notify(Playernum, Governor, "This ship is not equipped with combat lasers.\n");
X	} else if (match(args[2], "merchant")) {
X		if (match(args[3], "off"))
X			ship->merchant = 0;
X		else {
X			j = atoi(args[3]);
X			if (j < 0 || j > MAX_ROUTES) {
X				notify(Playernum, Governor, "Bad route number.\n");
X				return;
X			}
X			ship->merchant = j;
X		}
X	} else if (match(args[2], "speed")) {
X		if (speed_rating(ship)) {
X			j = atoi(args[3]);
X			if (j < 0) {
X				notify(Playernum, Governor, "Specify a positive speed.\n");
X				return;
X			} else {
X				if (j > speed_rating(ship))
X					j = speed_rating(ship);
X				ship->speed = j;
X			}
X		} else {
X			notify(Playernum, Governor, "This ship does not have a speed rating.\n");
X			return;
X		}
X	} else if (match(args[2], "salvo")) {
X		if (can_bombard(ship)) {
X			j = atoi(args[3]);
X			if (j < 0) {
X				notify(Playernum, Governor, "Specify a positive number of guns.\n");
X				return;
X			} else {
X				if (ship->guns == PRIMARY && j > ship->primary)
X					j = ship->primary;
X				else if (ship->guns == SECONDARY && j > ship->secondary)
X					j = ship->secondary;
X				else if (ship->guns == NONE)
X					j = 0;
X
X				ship->retaliate = j;
X			}
X		} else {
X			notify(Playernum, Governor, "This ship cannot be set to retaliate.\n");
X			return;
X		}
X	} else if (match(args[2], "primary")) {
X		if (ship->primary) {
X			if (argn < 4) {
X				ship->guns = PRIMARY;
X				if (ship->retaliate > ship->primary)
X					ship->retaliate = ship->primary;
X			} else {
X				j = atoi(args[3]);
X				if (j < 0) {
X					notify(Playernum, Governor, "Specify a nonnegative number of guns.\n");
X					return;
X				} else {
X					if (j > ship->primary)
X						j = ship->primary;
X					ship->retaliate = j;
X					ship->guns = PRIMARY;
X				}
X			}
X		} else {
X			notify(Playernum, Governor, "This ship does not have primary guns.\n");
X			return;
X		}
X	} else if (match(args[2], "secondary")) {
X		if (ship->secondary) {
X			if (argn < 4) {
X				ship->guns = SECONDARY;
X				if (ship->retaliate > ship->secondary)
X					ship->retaliate = ship->secondary;
X			} else {
X				j = atoi(args[3]);
X				if (j < 0) {
X					notify(Playernum, Governor, "Specify a nonnegative number of guns.\n");
X					return;
X				} else {
X					if (j > ship->secondary)
X						j = ship->secondary;
X					ship->retaliate = j;
X					ship->guns = SECONDARY;
X				}
X			}
X		} else {
X			notify(Playernum, Governor, "This ship does not have secondary guns.\n");
X			return;
X		}
X	} else if (match(args[2], "explosive")) {
X		switch (ship->type) {
X		case STYPE_MINE:
X		case OTYPE_GR:
X			ship->mode = 0;
X			break;
X		default:
X			return;
X		}
X	} else if (match(args[2], "radiative")) {
X		switch (ship->type) {
X		case STYPE_MINE:
X		case OTYPE_GR:
X			ship->mode = 1;
X			break;
X		default:
X			return;
X		}
X	} else if (match(args[2], "move")) {
X		if ((ship->type == OTYPE_TERRA) || (ship->type == OTYPE_PLOW)) {
X			i = 0;
X			while (args[3][i]) {
X				/*
X				 * Make sure the list of moves is short
X				 * enough.
X				 */
X				if (i == SHIP_NAMESIZE - 1) {
X					sprintf(buf, "Warning: that is more than %d moves.\n", SHIP_NAMESIZE - 1);
X					notify(Playernum, Governor, buf);
X					notify(Playernum, Governor, "These move orders have been truncated.\n");
X					args[3][i] = '\0';
X					break;
X				}
X				/* Make sure this move is OK. */
X				if ((args[3][i] == 'c') || (args[3][i] == 's')) {
X					if ((i == 0) && (args[3][0] == 'c')) {
X						notify(Playernum, Governor, "Cycling move orders can not be empty!\n");
X						return;
X					}
X					if (args[3][i + 1]) {
X						sprintf(buf, "Warning: '%c' should be the last character in the move order.\n", args[3][i]);
X						notify(Playernum, Governor, buf);
X						notify(Playernum, Governor, "These move orders have been truncated.\n");
X						args[3][++i] = '\0';
X						break;
X					}
X				} else if ((args[3][i] < '1') || ('9' < args[3][i])) {
X					sprintf(buf, "'%c' is not a valid move direction.\n", args[3][i]);
X					notify(Playernum, Governor, buf);
X					return;
X				}
X				i++;
X			}
X			if (i == 0)	/* The move list might be empty.. */
X				strcpy(ship->class, "5");
X			else
X				strcpy(ship->class, args[3]);
X			/*
X			 * This is the index keeping track of which order in
X			 * class is next.
X			 */
X			ship->special.terraform.index = 0;
X		} else {
X			notify(Playernum, Governor, "That ship is not a terraformer or a space plow.\n");
X			return;
X		}
X	} else if (match(args[2], "trigger")) {
X		if (ship->type == STYPE_MINE) {
X			if (atoi(args[3]) < 0)
X				ship->special.trigger.radius = 0;
X			else
X				ship->special.trigger.radius = atoi(args[3]);
X		} else {
X			notify(Playernum, Governor, "This ship cannot be assigned a trigger radius.\n");
X			return;
X		}
X	} else if (match(args[2], "transport")) {
X		if (ship->type == OTYPE_TRANSDEV) {
X			ship->special.transport.target = atoi(args[3]);
X			if (ship->special.transport.target == ship->number) {
X				notify(Playernum, Governor, "A transporter cannot transport to itself.");
X				ship->special.transport.target = 0;
X			} else {
X				sprintf(buf, "Target ship is %d.\n", ship->special.transport.target);
X				notify(Playernum, Governor, buf);
X			}
X		} else {
X			notify(Playernum, Governor, "This ship is not a transporter.\n");
X			return;
X		}
X	} else if (match(args[2], "aim")) {
X		if (can_aim(ship)) {
X			if (ship->type == OTYPE_GTELE || ship->type == OTYPE_TRACT
X			    || ship->fuel >= FUEL_MANEUVER) {
X				if (ship->type == STYPE_MIRROR && ship->docked) {
X					sprintf(buf, "docked; use undock or launch first.\n");
X					notify(Playernum, Governor, buf);
X					return;
X				}
X				pl = Getplace(Playernum, Governor, args[3], 1);
X				if (pl.err) {
X					notify(Playernum, Governor, "Error in destination.\n");
X					return;
X				} else {
X					ship->special.aimed_at.level = pl.level;
X					ship->special.aimed_at.pnum = pl.pnum;
X					ship->special.aimed_at.snum = pl.snum;
X					ship->special.aimed_at.shipno = pl.shipno;
X					if (ship->type != OTYPE_TRACT &&
X					    ship->type != OTYPE_GTELE)
X						use_fuel(ship, FUEL_MANEUVER);
X					if (ship->type == OTYPE_GTELE ||
X					    ship->type == OTYPE_STELE)
X						mk_expl_aimed_at(Playernum, Governor, ship);
X					sprintf(buf, "Aimed at %s\n", prin_aimed_at(Playernum, Governor, ship));
X					notify(Playernum, Governor, buf);
X				}
X			} else {
X				sprintf(buf, "Not enough maneuvering fuel (%.2f).\n", FUEL_MANEUVER);
X				notify(Playernum, Governor, buf);
X				return;
X			}
X		} else {
X			notify(Playernum, Governor, "You can't aim that kind of ship.\n");
X			return;
X		}
X	} else if (match(args[2], "intensity")) {
X		if (ship->type == STYPE_MIRROR) {
X			ship->special.aimed_at.intensity = MAX(0, MIN(100, atoi(args[3])));
X		}
X	} else if (match(args[2], "on")) {
X		if (!has_switch(ship)) {
X			notify(Playernum, Governor, "This ship does not have an on/off setting.\n");
X			return;
X		}
X		if (ship->damage && ship->type != OTYPE_FACTORY) {
X			notify(Playernum, Governor, "Damaged ships cannot be activated.\n");
X			return;
X		}
X		if (ship->on) {
X			notify(Playernum, Governor, "This ship is already activated.\n");
X			return;
X		}
X		if (ship->type == OTYPE_FACTORY) {
X			unsigned int    oncost;
X			if (ship->whatorbits == LEVEL_SHIP) {
X				shiptype       *s2;
X				int             hangerneeded;
X
X				(void) getship(&s2, (int) ship->destshipno);
X				if (s2->type == STYPE_HABITAT) {
X					oncost = HAB_FACT_ON_COST * ship->build_cost;
X					if (s2->resource < oncost) {
X						sprintf(buf, "You don't have %d resources on Habitat #%d to activate this factory.\n",
X						  oncost, ship->destshipno);
X						notify(Playernum, Governor, buf);
X						free(s2);
X						return;
X					}
X					hangerneeded = (1 + (int) (HAB_FACT_SIZE * (double) ship_size(ship))) -
X						((s2->max_hanger - s2->hanger) + ship->size);
X					if (hangerneeded > 0) {
X						sprintf(buf, "Not enough hanger space free on Habitat #%d. Need %d more.\n",
X							ship->destshipno, hangerneeded);
X						notify(Playernum, Governor, buf);
X						free(s2);
X						return;
X					}
X					s2->resource -= oncost;
X					s2->hanger -= ship->size;
X					ship->size = 1 + (int) (HAB_FACT_SIZE * (double) ship_size(ship));
X					s2->hanger += ship->size;
X					putship(s2);
X					free(s2);
X				} else {
X					notify(Playernum, Governor, "The factory is currently being transported.\n");
X					free(s2);
X					return;
X				}
X			} else if (!landed(ship)) {
X				notify(Playernum, Governor, "You cannot activate the factory here.\n");
X				return;
X			} else {
X				getplanet(&planet, (int) ship->deststar, (int) ship->destpnum);
X				oncost = 2 * ship->build_cost;
X				if (planet->info[Playernum - 1].resource < oncost) {
X					sprintf(buf, "You don't have %d resources on the planet to activate this factory.\n",
X						oncost);
X					notify(Playernum, Governor, buf);
X					free(planet);
X					return;
X				} else {
X					planet->info[Playernum - 1].resource -= oncost;
X					putplanet(planet, (int) ship->deststar, (int) ship->destpnum);
X					free(planet);
X				}
X			}
X			sprintf(buf, "Factory activated at a cost of %d resources.\n", oncost);
X			notify(Playernum, Governor, buf);
X		}
X		ship->on = 1;
X	} else if (match(args[2], "off")) {
X		if (ship->type == OTYPE_FACTORY && ship->on) {
X			notify(Playernum, Governor, "You can't deactivate a factory once it's online. Consider using 'scrap'.\n");
X			return;
X		}
X		ship->on = 0;
X	}
X	ship->notified = 0;
X	putship(ship);
X}
X
Xchar           *
Xprin_aimed_at(int Playernum, int Governor, shiptype * ship)
X{
X	placetype       targ;
X
X	targ.level = ship->special.aimed_at.level;
X	targ.snum = ship->special.aimed_at.snum;
X	targ.pnum = ship->special.aimed_at.pnum;
X	targ.shipno = ship->special.aimed_at.shipno;
X	return Dispplace(Playernum, Governor, &targ);
X}
X
Xchar           *
Xprin_ship_dest(int Playernum, int Governor, shiptype * ship)
X{
X	placetype       dest;
X
X	dest.level = ship->whatdest;
X	dest.snum = ship->deststar;
X	dest.pnum = ship->destpnum;
X	dest.shipno = ship->destshipno;
X	return Dispplace(Playernum, Governor, &dest);
X}
X
X
X/*
X * mark wherever the ship is aimed at, as explored by the owning player.
X */
Xvoid 
Xmk_expl_aimed_at(int Playernum, int Governor, shiptype * s)
X{
X	double          dist;
X	startype       *str;
X	planettype     *p;
X	double          xf, yf;
X
X	str = Stars[s->special.aimed_at.snum];
X
X	xf = s->xpos;
X	yf = s->ypos;
X
X	switch (s->special.aimed_at.level) {
X	case LEVEL_UNIV:
X		sprintf(buf, "There is nothing out here to aim at.");
X		notify(Playernum, Governor, buf);
X		break;
X	case LEVEL_STAR:
X		sprintf(buf, "Star %s ", prin_aimed_at(Playernum, Governor, s));
X		notify(Playernum, Governor, buf);
X		if ((dist = sqrt(Distsq(xf, yf, str->xpos, str->ypos)))
X		    <= tele_range((int) s->type, s->tech)) {
X			getstar(&str, (int) s->special.aimed_at.snum);
X			setbit(str->explored, Playernum);
X			putstar(str, (int) s->special.aimed_at.snum);
X			sprintf(buf, "Surveyed, distance %g.\n", dist);
X			notify(Playernum, Governor, buf);
X			free(str);
X		} else {
X			sprintf(buf, "Too far to see (%g, max %g).\n",
X				dist, tele_range((int) s->type, s->tech));
X			notify(Playernum, Governor, buf);
X		}
X		break;
X	case LEVEL_PLAN:
X		sprintf(buf, "Planet %s ", prin_aimed_at(Playernum, Governor, s));
X		notify(Playernum, Governor, buf);
X		getplanet(&p, (int) s->special.aimed_at.snum, (int) s->special.aimed_at.pnum);
X		if ((dist = sqrt(Distsq(xf, yf, str->xpos + p->xpos, str->ypos + p->ypos)))
X		    <= tele_range((int) s->type, s->tech)) {
X			setbit(str->explored, Playernum);
X			p->info[Playernum - 1].explored = 1;
X			putplanet(p, (int) s->special.aimed_at.snum, (int) s->special.aimed_at.pnum);
X			sprintf(buf, "Surveyed, distance %g.\n", dist);
X			notify(Playernum, Governor, buf);
X		} else {
X			sprintf(buf, "Too far to see (%g, max %g).\n",
X				dist, tele_range((int) s->type, s->tech));
X			notify(Playernum, Governor, buf);
X		}
X		free(p);
X		break;
X	case LEVEL_SHIP:
X		sprintf(buf, "You can't see anything of use there.\n");
X		notify(Playernum, Governor, buf);
X		break;
X	}
X}
X
Xvoid 
XDispOrdersHeader(int Playernum, int Governor)
X{
X	notify(Playernum, Governor, "    #       name       sp orbits     destin     options\n");
X}
X
Xvoid 
XDispOrders(int Playernum, int Governor, shiptype * ship)
X{
X	double          distfac;
X#ifdef THRESHLOADING
X	int				i;
X#endif
X
X	if (ship->owner != Playernum || !authorized(Governor, ship)
X	    || !ship->alive)
X		return;
X
X	if (ship->docked)
X		if (ship->whatdest == LEVEL_SHIP)
X			sprintf(temp, "D#%d", ship->destshipno);
X		else
X			sprintf(temp, "L%2d,%-2d", ship->land_x, ship->land_y);
X	else
X		strcpy(temp, prin_ship_dest(Playernum, Governor, ship));
X
X	sprintf(buf, "%5d %c %14.14s %c%1u %-10s %-10.10s ",
X		ship->number, Shipltrs[ship->type], ship->name,
X		ship->hyper_drive.has ? (ship->mount ? (ship->mounted ? '+' : '-') : '*') : ' ', 
X		ship->speed,
X		Dispshiploc_brief(ship),
X		temp);
X
X	if (ship->hyper_drive.on) {
X		sprintf(temp, "/jump %s %d", (ship->hyper_drive.ready ? "ready" : "charging"),
X			ship->hyper_drive.charge);
X		strcat(buf, temp);
X	}
X	if (ship->protect.self) {
X		sprintf(temp, "/retal");
X		strcat(buf, temp);
X	}
X	if (ship->guns == PRIMARY) {
X		switch (ship->primtype) {
X		case LIGHT:
X			sprintf(temp, "/lgt primary");
X			break;
X		case MEDIUM:
X			sprintf(temp, "/med primary");
X			break;
X		case HEAVY:
X			sprintf(temp, "/hvy primary");
X			break;
X		default:
X			sprintf(temp, "/none");
X		}
X		strcat(buf, temp);
X	} else if (ship->guns == SECONDARY) {
X		switch (ship->sectype) {
X		case LIGHT:
X			sprintf(temp, "/lgt secondary");
X			break;
X		case MEDIUM:
X			sprintf(temp, "/med secndry");
X			break;
X		case HEAVY:
X			sprintf(temp, "/hvy secndry");
X			break;
X		default:
X			sprintf(temp, "/none");
X		}
X		strcat(buf, temp);
X	}
X	if (ship->fire_laser) {
X		sprintf(temp, "/laser %d", ship->fire_laser);
X		strcat(buf, temp);
X	}
X	if (ship->focus)
X		strcat(buf, "/focus");
X
X	if (ship->retaliate) {
X		sprintf(temp, "/salvo %d", ship->retaliate);
X		strcat(buf, temp);
X	}
X	if (ship->protect.planet)
X		strcat(buf, "/defense");
X	if (ship->protect.on) {
X		sprintf(temp, "/prot %d", ship->protect.ship);
X		strcat(buf, temp);
X	}
X	if (ship->navigate.on) {
X		sprintf(temp, "/nav %d (%d)", ship->navigate.bearing, ship->navigate.turns);
X		strcat(buf, temp);
X	}
X	if (ship->merchant) {
X		sprintf(temp, "/merchant %d", ship->merchant);
X		strcat(buf, temp);
X	}
X	if (has_switch(ship)) {
X		if (ship->on)
X			strcat(buf, "/on");
X		else
X			strcat(buf, "/off");
X	}
X	if (ship->protect.evade)
X		strcat(buf, "/evade");
X	if (ship->bombard)
X		strcat(buf, "/bomb");
X	if (ship->type == STYPE_MINE || ship->type == OTYPE_GR) {
X		if (ship->mode)
X			strcat(buf, "/radiate");
X		else
X			strcat(buf, "/explode");
X	}
X	if (ship->type == OTYPE_TERRA || ship->type == OTYPE_PLOW) {
X		int             i;
X		sprintf(temp, "/move %s", &(ship->class[ship->special.terraform.index]));
X		if (temp[i = (strlen(temp) - 1)] == 'c') {
X			char            c = ship->class[ship->special.terraform.index];
X			ship->class[ship->special.terraform.index] = '\0';
X			sprintf(temp + i, "%sc", ship->class);
X			ship->class[ship->special.terraform.index] = c;
X		}
X		strcat(buf, temp);
X	}
X	if (ship->type == STYPE_MISSILE && ship->whatdest == LEVEL_PLAN) {
X		if (ship->special.impact.scatter)
X			strcat(buf, "/scatter");
X		else {
X			sprintf(temp, "/impact %d,%d",
X			    ship->special.impact.x, ship->special.impact.y);
X			strcat(buf, temp);
X		}
X	}
X	if (ship->type == STYPE_MINE) {
X		sprintf(temp, "/trigger %d", ship->special.trigger.radius);
X		strcat(buf, temp);
X	}
X	if (ship->type == OTYPE_TRANSDEV) {
X		sprintf(temp, "/target %d", ship->special.transport.target);
X		strcat(buf, temp);
X	}
X	if (ship->type == STYPE_MIRROR) {
X		sprintf(temp, "/aim %s/int %d", prin_aimed_at(Playernum, Governor, ship),
X			ship->special.aimed_at.intensity);
X		strcat(buf, temp);
X	}
X#ifdef AUTOSCRAP
X	if (ship->autoscrap) {
X		sprintf(temp, "%s", "/autoscrap");
X		strcat(buf, temp);
X	} 
X#endif 
X#ifdef THRESHLOADING
X	for (i=0;i<=TH_CRYSTALS;i++) {
X		if (ship->threshload[i]) {
X		char c;
X			if (i==TH_RESOURCE) 
X				c = 'r';
X			else if (i==TH_DESTRUCT) 
X				c = 'd';
X			else if (i==TH_FUEL) 
X				c = 'f';
X			else
X			 	c = 'x';
X		sprintf(temp,"/%c%d", c, ship->threshload[i]);
X		strcat(buf,temp);
X		}
X	}
X#endif 
X
X	strcat(buf, "\n");
X	notify(Playernum, Governor, buf);
X	/*
X	 * if hyper space is on estimate how much fuel it will cost to get to
X	 * the destination
X	 */
X	if (ship->hyper_drive.on) {
X		double          dist, fuse;
X
X		dist = sqrt(Distsq(ship->xpos, ship->ypos, Stars[ship->deststar]->xpos,
X				   Stars[ship->deststar]->ypos));
X		distfac = HYPER_DIST_FACTOR * (ship->tech + 100.0);
X		if (ship->mounted && dist > distfac) {
X			fuse = HYPER_DRIVE_FUEL_USE * sqrt(ship->mass)
X				* (dist / distfac);
X		} else {
X			fuse = HYPER_DRIVE_FUEL_USE * sqrt(ship->mass)
X				* (dist / distfac) * (dist / distfac);
X		}
X
X		sprintf(buf, "  *** distance %.0f - jump will cost %.1ff ***\n", dist, fuse);
X		notify(Playernum, Governor, buf);
X		if (ship->max_fuel < fuse)
X			notify(Playernum, Governor, "Your ship cannot carry enough fuel to do this jump.\n");
X	}
X}
X
Xvoid 
Xroute(int Playernum, int Governor, int APcount)
X{
X	int             i, x, y;
X	unsigned char   star, planet, load, unload;
X	char           *c;
X	planettype     *p;
X	placetype       where;
X
X	if (Dir[Playernum - 1][Governor].level != LEVEL_PLAN) {
X		notify(Playernum, Governor, "You have to 'cs' to a planet to examine routes.\n");
X		return;
X	}
X	getplanet(&p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X	if (argn == 1) {	/* display all shipping routes that are
X				 * active */
X		for (i = 1; i <= MAX_ROUTES; i++)
X			if (p->info[Playernum - 1].route[i - 1].set) {
X				star = p->info[Playernum - 1].route[i - 1].dest_star;
X				planet = p->info[Playernum - 1].route[i - 1].dest_planet;
X				load = p->info[Playernum - 1].route[i - 1].load;
X				unload = p->info[Playernum - 1].route[i - 1].unload;
X				sprintf(buf, "%2d  land %2d,%2d   ", i,
X				      p->info[Playernum - 1].route[i - 1].x,
X				     p->info[Playernum - 1].route[i - 1].y);
X				strcat(buf, "load: ");
X				if (Fuel(load))
X					strcat(buf, "f");
X				else
X					strcat(buf, " ");
X				if (Destruct(load))
X					strcat(buf, "d");
X				else
X					strcat(buf, " ");
X				if (Resources(load))
X					strcat(buf, "r");
X				else
X					strcat(buf, " ");
X				if (Crystals(load))
X					strcat(buf, "x");
X				strcat(buf, " ");
X
X				strcat(buf, "  unload: ");
X				if (Fuel(unload))
X					strcat(buf, "f");
X				else
X					strcat(buf, " ");
X				if (Destruct(unload))
X					strcat(buf, "d");
X				else
X					strcat(buf, " ");
X				if (Resources(unload))
X					strcat(buf, "r");
X				else
X					strcat(buf, " ");
X				if (Crystals(unload))
X					strcat(buf, "x");
X				else
X					strcat(buf, " ");
X				sprintf(temp, "  -> %s/%s\n",
X					Stars[star]->name, Stars[star]->pnames[planet]);
X				strcat(buf, temp);
X				notify(Playernum, Governor, buf);
X			}
X		notify(Playernum, Governor, "Done.\n");
X		free(p);
X		return;
X	} else if (argn == 2) {
X		sscanf(args[1], "%d", &i);
X		if (i > MAX_ROUTES || i < 1) {
X			notify(Playernum, Governor, "Bad route number.\n");
X			free(p);
X			return;
X		}
X		if (p->info[Playernum - 1].route[i - 1].set) {
X			star = p->info[Playernum - 1].route[i - 1].dest_star;
X			planet = p->info[Playernum - 1].route[i - 1].dest_planet;
X			load = p->info[Playernum - 1].route[i - 1].load;
X			unload = p->info[Playernum - 1].route[i - 1].unload;
X			sprintf(buf, "%2d  land %2d,%2d   ", i,
X				p->info[Playernum - 1].route[i - 1].x,
X				p->info[Playernum - 1].route[i - 1].y);
X			if (load) {
X				sprintf(temp, "load: ");
X				strcat(buf, temp);
X				if (Fuel(load))
X					strcat(buf, "f");
X				if (Destruct(load))
X					strcat(buf, "d");
X				if (Resources(load))
X					strcat(buf, "r");
X				if (Crystals(load))
X					strcat(buf, "x");
X			}
X			if (unload) {
X				sprintf(temp, "  unload: ");
X				strcat(buf, temp);
X				if (Fuel(unload))
X					strcat(buf, "f");
X				if (Destruct(unload))
X					strcat(buf, "d");
X				if (Resources(unload))
X					strcat(buf, "r");
X				if (Crystals(unload))
X					strcat(buf, "x");
X			}
X			sprintf(temp, "  ->  %s/%s\n",
X			    Stars[star]->name, Stars[star]->pnames[planet]);
X			strcat(buf, temp);
X			notify(Playernum, Governor, buf);
X		}
X		notify(Playernum, Governor, "Done.\n");
X		free(p);
X		return;
X	} else if (argn == 3) {
X		sscanf(args[1], "%d", &i);
X		if (i > MAX_ROUTES || i < 1) {
X			notify(Playernum, Governor, "Bad route number.\n");
X			free(p);
X			return;
X		}
X		if (match(args[2], "activate"))
X			p->info[Playernum - 1].route[i - 1].set = 1;
X		else if (match(args[2], "deactivate"))
X			p->info[Playernum - 1].route[i - 1].set = 0;
X		else {
X			where = Getplace(Playernum, Governor, args[2], 1);
X			if (!where.err) {
X				if (where.level != LEVEL_PLAN) {
X					notify(Playernum, Governor, "You have to designate a planet.\n");
X					free(p);
X					return;
X				}
X				p->info[Playernum - 1].route[i - 1].dest_star = where.snum;
X				p->info[Playernum - 1].route[i - 1].dest_planet = where.pnum;
X				notify(Playernum, Governor, "Set.\n");
X			} else {
X				notify(Playernum, Governor, "Illegal destination.\n");
X				free(p);
X				return;
X			}
X		}
X	} else {
X		sscanf(args[1], "%d", &i);
X		if (i > MAX_ROUTES || i < 1) {
X			notify(Playernum, Governor, "Bad route number.\n");
X			free(p);
X			return;
X		}
X		if (match(args[2], "land")) {
X			sscanf(args[3], "%d,%d", &x, &y);
X			if (x < 0 || x > p->Maxx - 1 || y < 0 || y > p->Maxy - 1) {
X				notify(Playernum, Governor, "Bad sector coordinates.\n");
X				free(p);
X				return;
X			}
X			p->info[Playernum - 1].route[i - 1].x = x;
X			p->info[Playernum - 1].route[i - 1].y = y;
X		} else if (match(args[2], "load")) {
X			p->info[Playernum - 1].route[i - 1].load = 0;
X			c = args[3];
X			while (*c) {
X				if (*c == 'f')
X					p->info[Playernum - 1].route[i - 1].load |= M_FUEL;
X				if (*c == 'd')
X					p->info[Playernum - 1].route[i - 1].load |= M_DESTRUCT;
X				if (*c == 'r')
X					p->info[Playernum - 1].route[i - 1].load |= M_RESOURCES;
X				if (*c == 'x')
X					p->info[Playernum - 1].route[i - 1].load |= M_CRYSTALS;
X				c++;
X			}
X		} else if (match(args[2], "unload")) {
X			p->info[Playernum - 1].route[i - 1].unload = 0;
X			c = args[3];
X			while (*c) {
X				if (*c == 'f')
X					p->info[Playernum - 1].route[i - 1].unload |= M_FUEL;
X				if (*c == 'd')
X					p->info[Playernum - 1].route[i - 1].unload |= M_DESTRUCT;
X				if (*c == 'r')
X					p->info[Playernum - 1].route[i - 1].unload |= M_RESOURCES;
X				if (*c == 'x')
X					p->info[Playernum - 1].route[i - 1].unload |= M_CRYSTALS;
X				c++;
X			}
X		} else {
X			notify(Playernum, Governor, "What are you trying to do?\n");
X			free(p);
X			return;
X		}
X		notify(Playernum, Governor, "Set.\n");
X	}
X	putplanet(p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X	free(p);
X}
END_OF_FILE
if test 32144 -ne `wc -c <'user/order.c'`; then
    echo shar: \"'user/order.c'\" unpacked with wrong size!
fi
# end of 'user/order.c'
fi
if test -f 'user/shootblast.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/shootblast.c'\"
else
echo shar: Extracting \"'user/shootblast.c'\" \(18678 characters\)
sed "s/^X//" >'user/shootblast.c' <<'END_OF_FILE'
X#include <math.h>
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X
X
Xextern int      Defensedata[];
X
Xint             hit_probability;
Xdouble          penetration_factor;
X
Xint 
Xshoot_ship_to_ship(shiptype *, shiptype *, int, int, int, char *,
X		   char *);
X#ifdef DEFENSE
Xint 
Xshoot_planet_to_ship(racetype *, planettype *, shiptype *, int,
X		     char *, char *);
X#endif
Xint 
Xshoot_ship_to_planet(shiptype *, planettype *, int, int, int, int, int,
X		     int, char *, char *);
Xint             do_radiation(shiptype *, double, int, int, char *, char *);
Xint 
Xdo_damage(int, shiptype *, double, int, int, int, int, double, char *,
X	  char *);
Xvoid            ship_disposition(shiptype *, int *, int *, int *);
Xint             CEW_hit(double, int);
Xint 
XNum_hits(double, int, int, double, int, int, int, int, int, int, int,
X	 int);
Xint             hit_odds(double, int *, double, int, int, int, int, int, int, int, int);
Xint             cew_hit_odds(double, int);
Xdouble          gun_range(racetype *, shiptype *, int);
Xdouble          tele_range(int, double);
Xint             current_caliber(shiptype *);
Xvoid            do_critical_hits(int, shiptype *, int *, int *, int, char *);
Xvoid            do_collateral(shiptype *, int, int *, int *, int *, int *);
Xint             getdefense(shiptype *);
Xdouble          p_factor(double, double);
Xint             planet_guns(int);
Xvoid            mutate_sector(sectortype *);
X#include "proto.h"
X
Xint 
Xshoot_ship_to_ship(shiptype * from, shiptype * to, int strength, int cew,
X		   int ignore, char *long_msg, char *short_msg)
X{
X	double          range;
X	int             hits, casualties, casualties1, primgundamage, secgundamage;
X	int             penetrate, crithits, critdam, damage, defense;
X	double          dist, xfrom, yfrom, xto, yto;
X	int             focus, fevade, fspeed, fbody, tevade, tspeed, tbody,
X	                caliber;
X	char            weapon[32], damage_msg[1024];
X
X	range = 0.0;
X	casualties = 0;
X	casualties1 = 0;
X	primgundamage = 0;
X	secgundamage = 0;
X	hits = 0;
X	defense = 1;
X	penetrate = 0;
X	crithits = 0;
X	critdam = 0;
X	if (strength <= 0)
X		return -1;
X
X	if (!(from->alive || ignore) || !to->alive)
X		return -1;
X	if (from->whatorbits == LEVEL_SHIP || from->whatorbits == LEVEL_UNIV)
X		return -1;
X	if (to->whatorbits == LEVEL_SHIP || to->whatorbits == LEVEL_UNIV)
X		return -1;
X	if (from->storbits != to->storbits)
X		return -1;
X	if (has_switch(from) && !from->on)
X		return -1;
X
X	xfrom = from->xpos;
X	yfrom = from->ypos;
X
X	xto = to->xpos;
X	yto = to->ypos;
X	/* compute caliber */
X	caliber = current_caliber(from);
X
X	if (from->type == STYPE_MISSILE)	/* missiles hit at point
X						 * blank range */
X		dist = 0.0;
X	else {
X		dist = sqrt((double) Distsq(xfrom, yfrom, xto, yto));
X		if (from->type == STYPE_MINE) {	/* compute the effective
X						 * range */
X			dist *= dist / 200.0;	/* mines are very effective
X						 * inside 200 */
X		}
X	}
X	range = (double) dist;
X	if ((double) dist > gun_range((racetype *) NULL, from, 0))
X		return -1;
X	/* attack parameters */
X	ship_disposition(from, &fevade, &fspeed, &fbody);
X	ship_disposition(to, &tevade, &tspeed, &tbody);
X	defense = getdefense(to);
X
X	if (laser_on(from) && from->focus)
X		focus = 1;
X	else
X		focus = 0;
X
X	if (cew)
X		hits = strength * CEW_hit((double) dist, (int) from->cew_range);
X	else
X		hits = Num_hits((double) dist, focus, strength, from->tech, (int) from->damage,
X		   fevade, tevade, fspeed, tspeed, tbody, caliber, defense);
X	/* CEW, destruct, lasers */
X	damage = 0;
X	if (from->mode) {
X		damage = do_radiation(to, from->tech, strength,
X				      hits, "radiation", damage_msg);
X		sprintf(short_msg, "%s: %s %s %s\n",
X			Dispshiploc(to), Ship(from),
X			to->alive ? "attacked" : "DESTROYED", Ship(to));
X		strcpy(long_msg, short_msg);
X		strcat(long_msg, damage_msg);
X	} else {
X		if (cew)
X			sprintf(weapon, "strength CEW");
X		else if (laser_on(from)) {
X			if (from->focus)
X				sprintf(weapon, "strength focused laser");
X			else
X				sprintf(weapon, "strength laser");
X		} else
X			switch (caliber) {
X			case LIGHT:
X				sprintf(weapon, "light guns");
X				break;
X			case MEDIUM:
X				sprintf(weapon, "medium guns");
X				break;
X			case HEAVY:
X				sprintf(weapon, "heavy guns");
X				break;
X			default:
X				sprintf(weapon, "pea-shooter");
X				return -1;
X			}
X
X		damage = do_damage((int) from->owner, to, (double) from->tech,
X				   strength, hits, defense,
X				caliber, (double) dist, weapon, damage_msg);
X		sprintf(short_msg, "%s: %s %s %s\n",
X			Dispshiploc(to), Ship(from),
X			to->alive ? "attacked" : "DESTROYED", Ship(to));
X		strcpy(long_msg, short_msg);
X		strcat(long_msg, damage_msg);
X	}
X	return damage;
X}
X
X#ifdef DEFENSE
Xint 
Xshoot_planet_to_ship(racetype * Race, planettype * p, shiptype * ship,
X		     int strength, char *long_msg, char *short_msg)
X{
X	int             hits, casualties, casualties1, primgundamage, secgundamage;
X	int             evade, speed, body;
X	int             damage;
X	char            damage_msg[1024];
X
X	casualties = casualties1 = 0;
X	primgundamage = secgundamage = 0;
X	hits = 0;
X	if (strength <= 0)
X		return -1;
X	if (!ship->alive)
X		return -1;
X
X	if (ship->whatorbits != LEVEL_PLAN)
X		return -1;
X
X	ship_disposition(ship, &evade, &speed, &body);
X
X	hits = Num_hits(0.0, 0, strength, Race->tech, 0,
X			evade, 0, speed, 0, body, MEDIUM, 1);
X
X	damage = do_damage(Race->Playernum, ship,
X			   Race->tech, strength, hits, 0,
X			   MEDIUM, 0.0, "medium guns", damage_msg);
X	sprintf(short_msg, "%s [%d] %s %s\n",
X		Dispshiploc(ship),
X	Race->Playernum, ship->alive ? "attacked" : "DESTROYED", Ship(ship));
X	strcpy(long_msg, short_msg);
X	strcat(long_msg, damage_msg);
X
X	return damage;
X}
X#endif
X
Xint 
Xshoot_ship_to_planet(shiptype * ship, planettype * pl, int strength, int x,
X		     int y, int getmap, int ignore, int caliber,
X		     char *long_msg, char *short_msg)
X{
X	register sectortype *s, *target;
X	register int    x2, y2;
X	int             numdest, kills, oldowner;
X	int             i, num_sectors, sum_mob[MAXPLAYERS];
X	double          d, r, fac;
X
X	numdest = 0;
X	if (strength <= 0)
X		return -1;
X	if (!(ship->alive || ignore))
X		return -1;
X	if (has_switch(ship) && !ship->on)
X		return -1;
X	if (ship->whatorbits != LEVEL_PLAN)
X		return -1;
X
X	if (x < 0 || x > pl->Maxx - 1 || y < 0 || y > pl->Maxy - 1)
X		return -1;
X
X	r = .4 * strength;
X	if (!caliber) {		/* figure out the appropriate gun caliber if
X				 * not given */
X		if (ship->fire_laser)
X			caliber = LIGHT;
X		else
X			switch (ship->guns) {
X			case PRIMARY:
X				caliber = ship->primtype;
X				break;
X			case SECONDARY:
X				caliber = ship->sectype;
X				break;
X			default:
X				caliber = LIGHT;
X			}
X	}
X	if (getmap) {
X		getsmap(Smap, pl);
X	}
X	target = &Sector(*pl, x, y);
X	oldowner = target->owner;
X
X	for (i = 1; i <= Num_races; i++)
X		sum_mob[i - 1] = 0;
X
X	for (y2 = 0; y2 < pl->Maxy; y2++) {
X		for (x2 = 0; x2 < pl->Maxx; x2++) {
X			register int    dx, dy;
X			dx = MIN(abs(x2 - x), abs(x + (pl->Maxx - 1) - x2));
X			dy = abs(y2 - y);
X			d = sqrt((double) (dx * dx + dy * dy));
X			s = &Sector(*pl, x2, y2);
X
X			if (d <= r) {
X				fac = SECTOR_DAMAGE * (double) strength *(double) caliber / (d + 1.);
X
X				if (s->owner) {
X					if (s->popn) {
X						kills = int_rand(0, ((int) (fac / 10.0) * s->popn))
X							/ (1 + (s->condition == PLATED));
X						if (kills > s->popn)
X							s->popn = 0;
X						else
X							s->popn -= kills;
X					}
X					if (s->troops &&
X					    (fac > 5.0 * (double) Defensedata[s->condition])) {
X						kills = int_rand(0, ((int) (fac / 20.0) * s->troops))
X							/ (1 + (s->condition == PLATED));
X						if (kills > s->troops)
X							s->troops = 0;
X						else
X							s->troops -= kills;
X					}
X					if (!(s->popn + s->troops))
X						s->owner = 0;
X				}
X				if (fac >= 5.0 && !int_rand(0, 10))
X					mutate_sector(s);
X
X				if (round_rand(fac) >
X				    Defensedata[s->condition] * int_rand(0, 10)) {
X					if (s->owner)
X						Nuked[s->owner - 1] = 1;
X					s->popn = 0;
X					s->troops = int_rand(0, (int) s->troops);
X					if (!s->troops)	/* troops may survive
X							 * this */
X						s->owner = 0;
X					s->eff = 0;
X					s->resource = s->resource / ((int) fac + 1);
X					s->mobilization = 0;
X					s->fert = 0;	/* all is lost ! */
X					s->crystals = int_rand(0, (int) s->crystals);
X					s->condition = WASTED;
X					numdest++;
X				} else {
X					s->fert = MAX(0, (int) s->fert - (int) fac);
X					s->eff = MAX(0, (int) s->eff - (int) fac);
X					s->mobilization = MAX(0, (int) s->mobilization - (int) fac);
X					s->resource = MAX(0, (int) s->resource - (int) fac);
X				}
X			}
X			if (s->owner)
X				sum_mob[s->owner - 1] += s->mobilization;
X		}
X	}
X	num_sectors = pl->Maxx * pl->Maxy;
X	for (i = 1; i <= Num_races; i++) {
X		pl->info[i - 1].mob_points = sum_mob[i - 1];
X		pl->info[i - 1].comread = sum_mob[i - 1] / num_sectors;
X		pl->info[i - 1].guns = planet_guns(sum_mob[i - 1]);
X	}
X
X	/* planet toxicity goes up a bit */
X	pl->conditions[TOXIC] += (100 - pl->conditions[TOXIC]) *
X		((double) numdest / (double) (pl->Maxx * pl->Maxy));
X
X	sprintf(short_msg, "%s bombards %s [%d]\n", Ship(ship), Dispshiploc(ship),
X		oldowner);
X	strcpy(long_msg, short_msg);
X	sprintf(buf, "\t%d sectors destroyed\n", numdest);
X	strcat(long_msg, buf);
X	if (getmap) {
X		putsmap(Smap, pl);
X	}
X	return numdest;
X}
X
Xint 
Xdo_radiation(shiptype * ship, double tech, int strength, int hits,
X	     char *weapon, char *msg)
X{
X	double          fac, r;
X	int             i, arm, body, penetrate, casualties, casualties1;
X	int             dosage;
X
X	fac = (2. / 3.14159265) * atan((double) (5 * (tech + 1.0) / (ship->tech + 1.0)));
X
X	arm = MAX(0, Armor(ship) - hits / 5);
X	body = Body(ship);
X
X	penetrate = 0;
X	r = 1.0;
X	for (i = 1; i <= arm; i++)
X		r *= fac;
X
X	for (i = 1; i <= hits; i++)	/* check to see how many hits
X					 * penetrate */
X		if (double_rand() <= r)
X			penetrate += 1;
X
X	dosage = round_rand(40. * (double) penetrate / (double) body);
X	dosage = MIN(100, dosage);
X
X	if (dosage > ship->rad)
X		ship->rad = MAX(ship->rad, dosage);
X	if (success(ship->rad))
X		ship->active = 0;
X
X	casualties = 0;
X	casualties1 = 0;
X	sprintf(buf, "\tAttack: %d %s\n\t  Hits: %d\n",
X		strength, weapon, hits);
X	strcat(msg, buf);
X	sprintf(buf, "\t   Rad: %d%% for a total of %d%%\n",
X		dosage, ship->rad);
X	strcat(msg, buf);
X	if (casualties || casualties1) {
X		sprintf(buf, "\tKilled: %d civ + %d mil\n",
X			casualties, casualties1);
X		strcat(msg, buf);
X	}
X	return dosage;
X}
X
Xint 
Xdo_damage(int who, shiptype * ship, double tech, int strength, int hits,
X	  int defense, int caliber, double range, char *weapon, char *msg)
X{
X	double          body;
X	int             i, arm;
X	int             damage;
X	int             penetrate, crithits, critdam;
X	int             casualties, casualties1, primgundamage, secgundamage;
X	double          fac, r;
X	char            critmsg[1024];
X
X	sprintf(buf, "\tAttack: %d %s at a range of %.0f\n",
X		strength, weapon, range);
X	strcpy(msg, buf);
X	sprintf(buf, "\t  Hits: %d  %d%% probability\n", hits, hit_probability);
X	strcat(msg, buf);
X	/* ship may lose some armor */
X	if (ship->armor)
X		if (success(hits * caliber)) {
X			ship->armor--;
X			sprintf(buf, "\t\tArmor reduced to %d\n", ship->armor);
X			strcat(msg, buf);
X		}
X	fac = p_factor(tech, ship->tech);
X	penetration_factor = fac;
X	arm = MAX(0, Armor(ship) + defense - hits / 5);
X	body = sqrt((double) (0.1 * Body(ship)));
X
X	critdam = 0;
X	crithits = 0;
X	penetrate = 0;
X	r = 1.0;
X	for (i = 1; i <= arm; i++)
X		r *= fac;
X
X	for (i = 1; i <= hits; i++)	/* check to see how many hits
X					 * penetrate */
X		if (double_rand() <= r)
X			penetrate += 1;
X
X	damage = round_rand(SHIP_DAMAGE * (double) caliber * (double) penetrate / (double) body);
X
X	do_critical_hits(penetrate, ship, &crithits, &critdam, caliber, critmsg);
X
X	if (crithits)
X		damage += critdam;
X
X	damage = MIN(100, damage);
X	ship->damage = MIN(100, (int) (ship->damage) + damage);
X	do_collateral(ship, damage, &casualties, &casualties1,
X		      &primgundamage, &secgundamage);
X	/* set laser strength for ships to maximum safe limit */
X	if (ship->fire_laser) {
X		int             safe;
X		safe = (int) ((1.0 - .01 * ship->damage) * ship->tech / 4.0);
X		if (ship->fire_laser > safe)
X			ship->fire_laser = safe;
X	}
X	if (penetrate) {
X		sprintf(buf, "\t\t%d penetrations  eff armor=%d defense=%d prob=%.3f\n",
X			penetrate, arm, defense, r);
X		strcat(msg, buf);
X	}
X	if (crithits) {
X		sprintf(buf, "\t\t%d CRITICAL hits do %d%% damage\n",
X			crithits, critdam);
X		strcat(msg, buf);
X		strcat(msg, critmsg);
X	}
X	if (damage) {
X		sprintf(buf, "\tDamage: %d%% damage for a total of %d%%\n",
X			damage, ship->damage);
X		strcat(msg, buf);
X	}
X	if (primgundamage || secgundamage) {
X		sprintf(buf, "\t Other: %d primary/%d secondary guns destroyed\n",
X			primgundamage, secgundamage);
X		strcat(msg, buf);
X	}
X	if (casualties || casualties1) {
X		sprintf(buf, "\tKilled: %d civ + %d mil casualties\n",
X			casualties, casualties1);
X		strcat(msg, buf);
X	}
X	if (ship->damage >= 100)
X		kill_ship(who, ship);
X	ship->build_cost = (int) cost(ship);
X	return damage;
X}
X
Xvoid 
Xship_disposition(shiptype * ship, int *evade, int *speed, int *body)
X{
X	*evade = 0;
X	*speed = 0;
X	*body = Size(ship);
X	if (ship->active && !ship->docked &&
X	    (ship->whatdest || ship->navigate.on)) {
X		*evade = ship->protect.evade;
X		*speed = ship->speed;
X	}
X	return;
X}
X
Xint 
XCEW_hit(double dist, int cew_range)
X{
X	int             prob, hits;
X
X	hits = 0;
X	prob = cew_hit_odds(dist, cew_range);
X
X	if (success(prob))
X		hits = 1;
X
X	return hits;
X}
X
Xint 
XNum_hits(double dist, int focus, int guns, double tech, int fdam,
X	 int fev, int tev, int fspeed, int tspeed, int body,
X	 int caliber, int defense)
X{
X	int             factor;
X	int             i, prob, hits;
X
X	prob = hit_odds(dist, &factor, tech, fdam,
X			fev, tev, fspeed, tspeed, body, caliber, defense);
X
X	hits = 0;
X	if (focus) {
X		if (success(prob * prob / 100))
X			hits = guns;
X		hit_probability = prob * prob / 100;
X	} else {
X		for (i = 1; i <= guns; i++)
X			if (success(prob))
X				hits++;
X		hit_probability = prob;	/* global variable */
X	}
X
X	return hits;
X}
X
Xint 
Xhit_odds(double range, int *factor, double tech, int fdam, int fev,
X	 int tev, int fspeed, int tspeed, int body, int caliber, int defense)
X{
X	int             odds;
X	double          a, b, c;
X
X	if (caliber == NONE) {
X		*factor = 0;
X		return 0;
X	}
X	a = log10(1.0 + (double) tech) * 80.0 * pow((double) body, 0.33333);
X	b = 72.0 / ((2.0 + (double) tev) * (2.0 + (double) fev)
X		    * (18.0 + (double) tspeed + (double) fspeed));
X	c = a * b / (double) caliber;
X	*factor = (int) (c * (1.0 - (double) fdam / 100.));	/* 50% hit range */
X	odds = 0;
X	if (*factor > 0)
X		odds = (int) ((double) ((*factor) * 100) / ((double) ((*factor) + (int) range)));
X	odds = (int) ((double) odds * (1.0 - 0.1 * (double) defense));
X	return odds;
X}
X
Xint 
Xcew_hit_odds(double range, int cew_range)
X{
X	int             odds;
X	double          factor;
X
X	factor = (range + 1.0) / ((double) cew_range + 1.0);	/* maximum chance */
X	odds = (int) (100.0 * exp((double) (-50.0 * (factor - 1.0) * (factor - 1.0))));
X	return odds;
X}
X
X/*
X * gun range of given ship, given race and ship
X */
Xdouble 
Xgun_range(racetype * r, shiptype * s, int mode)
X{
X	if (mode)
X		return (logscale((int) (r->tech + 1.0)) * SYSTEMSIZE);
X	else
X		return (logscale((int) (s->tech + 1.0)) * SYSTEMSIZE);
X}
X
X/*
X * range of telescopes, ground or space, given race and ship
X */
Xdouble 
Xtele_range(int type, double tech)
X{
X	if (type == OTYPE_GTELE)
X		return log1p((double) tech) * 400 + SYSTEMSIZE / 8;
X	else
X		return log1p((double) tech) * 1500 + SYSTEMSIZE / 3;
X}
X
Xint 
Xcurrent_caliber(shiptype * ship)
X{
X	if (ship->laser && ship->fire_laser)
X		return LIGHT;
X	else if (ship->type == STYPE_MINE)
X		return LIGHT;
X	else if (ship->type == STYPE_MISSILE)
X		return HEAVY;
X	else if (ship->guns == PRIMARY)
X		return ship->primtype;
X	else if (ship->guns == SECONDARY)
X		return ship->sectype;
X	else
X		return NONE;
X}
X
Xvoid 
Xdo_critical_hits(int penetrate, shiptype * ship, int *crithits,
X		 int *critdam, int caliber, char *critmsg)
X{
X	int             eff_size, i, dam;
X	*critdam = 0;
X	*crithits = 0;
X	if (caliber < 1) caliber = 1;
X	eff_size = MAX(1, Body(ship) / caliber);
X	for (i = 1; i <= penetrate; i++)
X		if (!int_rand(0, eff_size - 1)) {
X			*crithits += 1;
X			dam = int_rand(0, 100);
X			*critdam += dam;
X		}
X	*critdam = MIN(100, *critdam);
X	/* check for special systems damage */
X	strcpy(critmsg, "\t\tSpecial systems damage: ");
X	if (ship->cew && success(*critdam)) {
X		strcat(critmsg, "CEW ");
X		ship->cew = 0;
X	}
X	if (ship->laser && success(*critdam)) {
X		strcat(critmsg, "Laser ");
X		ship->laser = 0;
X	}
X	if (ship->cloak && success(*critdam)) {
X		strcat(critmsg, "Cloak ");
X		ship->cloak = 0;
X	}
X	if (ship->hyper_drive.has && success(*critdam)) {
X		strcat(critmsg, "Hyper-drive ");
X		ship->hyper_drive.has = 0;
X	}
X	if (ship->max_speed && success(*critdam)) {
X		ship->speed = 0;
X		ship->max_speed = int_rand(0, (int) ship->max_speed - 1);
X		sprintf(buf, "Speed=%d ", ship->max_speed);
X		strcat(critmsg, buf);
X	}
X	if (ship->armor && success(*critdam)) {
X		ship->armor = int_rand(0, (int) ship->armor - 1);
X		sprintf(buf, "Armor=%d ", ship->armor);
X		strcat(critmsg, buf);
X	}
X	strcat(critmsg, "\n");
X}
X
Xvoid 
Xdo_collateral(shiptype * ship, int damage, int *casualties,
X	      int *casualties1, int *primgundamage, int *secgundamage)
X{
X	int             i;
X	/* compute crew/troop casualties */
X	*casualties = 0;
X	*casualties1 = 0;
X	*primgundamage = 0;
X	*secgundamage = 0;
X
X	for (i = 1; i <= ship->popn; i++)
X		*casualties += success(damage);
X	ship->popn -= *casualties;
X	for (i = 1; i <= ship->troops; i++)
X		*casualties1 += success(damage);
X	ship->troops -= *casualties1;
X	for (i = 1; i <= ship->primary; i++)
X		*primgundamage += success(damage);
X	ship->primary -= *primgundamage;
X	for (i = 1; i <= ship->secondary; i++)
X		*secgundamage += success(damage);
X	ship->secondary -= *secgundamage;
X	if (!ship->primary)
X		ship->primtype = NONE;
X	if (!ship->secondary)
X		ship->sectype = NONE;
X}
X
Xint 
Xgetdefense(shiptype * ship)
X{
X	planettype     *p;
X	sectortype     *sect;
X	int             defense = 0;
X
X	if (landed(ship)) {
X		getplanet(&p, (int) ship->storbits, (int) ship->pnumorbits);
X		getsector(&sect, p, (int) ship->land_x, (int) ship->land_y);
X		defense = 2 * Defensedata[sect->condition];
X		free(p);
X		free(sect);
X	}
X	return defense;
X}
X
Xdouble 
Xp_factor(double attacker, double defender)
X{
X	return ((2. / 3.141592) * atan(5 * (double) ((attacker + 1.0) / (defender + 1.0))));
X}
X
Xint 
Xplanet_guns(int points)
X{
X	if (points < 0)
X		return 0;	/* shouldn't happen */
X	return MIN(20, points / 1000);
X}
X
Xvoid 
Xmutate_sector(sectortype * s)
X{
X	if (int_rand(0, 6) >= Defensedata[s->condition])
X		s->condition = s->type;
X}
END_OF_FILE
if test 18678 -ne `wc -c <'user/shootblast.c'`; then
    echo shar: \"'user/shootblast.c'\" unpacked with wrong size!
fi
# end of 'user/shootblast.c'
fi
echo shar: End of archive 8 \(of 21\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
