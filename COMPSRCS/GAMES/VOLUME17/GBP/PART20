Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i032:  gbp - Galactic Bloodshed+, an empire-like war game, Part20/21
Message-ID: <4560@master.CNA.TEK.COM>
Date: 12 Feb 93 17:33:42 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2418
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1711

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 32
Archive-name: gbp/Part20
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 20 (of 21)."
# Contents:  Makefile.SH doc/racegen.novice-info hdrs/files.h.SH
#   misc/help.txt misc/star.list server/client.c server/lists.c
#   server/log.c server/max.c server/misc.c user/autoshoot.c
#   user/chan.c user/examine.c user/vict.c utils/Makefile.SH
#   utils/README_EXSHIP
# Wrapped by billr@saab on Fri Feb 12 09:14:31 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.SH'\"
else
echo shar: Extracting \"'Makefile.SH'\" \(3100 characters\)
sed "s/^X//" >'Makefile.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X    fi
X    . ./config.sh
X    ;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
X
Xcase "$d_symlink" in
X*define*) sln='ln -s' ;;
X*) sln='ln';;
Xesac
X
Xecho "Extracting Makefile (with variable substitutions)"
Xcat >Makefile <<!GROK!THIS!
X#
X#
X#  Top level Makefile for the GB+ program
X#
X#
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#       John Deragon deragon@jethro.cs.nyu.edu
X#
X# Revision %I% %U% jpd
X#
X#
X#
X#	Variables established by Configure
XCAT		=	$cat
XGREP		=	$grep
XECHO		=	$echo
XMAKE		=	$make
XPR		=	$pr
XSHAR		=	$shar -s 60000
XSLEEP		=	$sleep
XTAR		=	$tar
XHOST		=	$host
XPORT		=	$port
XARCHIVE     =   gb+.tar
X
X!GROK!THIS!
Xcat >>Makefile <<'!NO!SUBS!'
X#	Other variables
XSHELL			=	/bin/sh
XSOURCE_FILES		=	`$(GREP) -v 'doc/' MANIFEST`
XDISTRIBUTED_FILES	=	`$(CAT) MANIFEST`
X
X
X# Targets
X#	Give default target first and alone
Xdefault_target:	all
X
X#	Targets that are simply executed in each subordinate makefile as is
Xall:
X		@echo "Making in library in user"
X		cd user; $(MAKE) -$(MAKEFLAGS) $@
X		@echo "Making in server"
X		cd server; $(MAKE) -$(MAKEFLAGS) $@
X		@echo "Makeinf in utils"
X		cd utils; $(MAKE) -$(MAKEFLAGS) $@
X		@echo "Now do a \"make install\""
X		
X
Xshar:
X		$(SHAR) $(DISTRIBUTED_FILES)
X
Xtar:
X		chmod +x Configure
X		$(TAR) cvf $(ARCHIVE) $(DISTRIBUTED_FILES)
X
Xfloppy:
X		$(TAR) cvf /dev/rfd0c $(DISTRIBUTED_FILES)
X
Xclean:
X	cd user; $(MAKE) clean
X	cd server; $(MAKE) clean
X
XGB:
X	cd user; $(MAKE) -$(MAKEFLAGS) all
X	cd server; $(MAKE) -$(MAKEFLAGS) all
X	cd utils; $(MAKE) -$(MAKEFLAGS) all
X
XGBX:
X	@echo "**** Making objects in user"
X	cd user; $(MAKE) -$(MAKEFLAGS) objects
X	@echo "**** Making in server"
X	cd server; $(MAKE) -$(MAKEFLAGS) GBX
X	@echo "**** Now do a \"make installgbx\""
X
Xinstallgbx:
X	@echo "**** Installing in server"
X	cd server; $(MAKE) -$(MAKEFLAGS) installgbx
X	@echo "**** Installing in utils"
X	cd utils; $(MAKE) -$(MAKEFLAGS) install
X	@echo "**** Installing in misc"
X	cd misc; $(MAKE) -$(MAKEFLAGS) install
X	@echo "**** All Done!"
X
Xinstall:
X	@echo "**** Installing in server"
X	cd server; $(MAKE) -$(MAKEFLAGS) install	
X	@echo "**** Installing in utils"
X	cd utils; $(MAKE) -$(MAKEFLAGS) install
X	@echo "**** Installing in misc"
X	cd misc; $(MAKE) -$(MAKEFLAGS) install	
X	@echo "**** All Done!"
X
X#	The dummy dependency here prevents make from thinking the target is the
X#	utils directory that sits in the current directory, rather than
X#	an abstract target.
Xserver: _server
X
X_server:
X	cd server; $(MAKE) -$(MAKEFLAGS) all
X#	The dummy dependency here prevents make from thinking the target is the
X#	utils directory that sits in the current directory, rather than
X#	an abstract target.
Xuser: _user
X
X_user:
X	cd user; $(MAKE) -$(MAKEFLAGS) all
X
X#	The dummy dependency here prevents make from thinking the target is the
X#	utils directory that sits in the current directory, rather than
X#	an abstract target.
Xutils: _utils
X
X_utils:
X	cd utils; $(MAKE) -$(MAKEFLAGS) all
X
X!NO!SUBS!
END_OF_FILE
if test 3100 -ne `wc -c <'Makefile.SH'`; then
    echo shar: \"'Makefile.SH'\" unpacked with wrong size!
fi
# end of 'Makefile.SH'
fi
if test -f 'doc/racegen.novice-info' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/racegen.novice-info'\"
else
echo shar: Extracting \"'doc/racegen.novice-info'\" \(2130 characters\)
sed "s/^X//" >'doc/racegen.novice-info' <<'END_OF_FILE'
X
XHow to get and compile racegen
X
XFirst off, get net access.  Then you can use the file transfer program, ftp,
Xto get racegen from several sites, including scam.berkeley.edu.  Connect to
Xthe remote system, use "anonymous" as your name (any password is OK), cd to
Xthe src/games/gb directory, and get racegen.shar.  The whole process should
Xlook rather like this:
X
X> ftp scam.berkeley.edu
XConnected to scam.berkeley.edu.
X220 scam.Berkeley.EDU FTP server ready.
XName (scam.berkeley.edu:leonard): anonymous
X331 Guest login ok, send ident as password.
XPassword:
X230-Welcome Guest - access restricted.
Xftp> cd src/games/gb
X200 CWD command okay.
Xftp> get racegen.shar
X200 PORT command okay.
X150 Opening data connection for racegen.shar (60101 bytes).
X226 Transfer complete.
Xlocal: racegen.shar remote: racegen.shar
X62071 bytes received in 6.1 seconds (9.9 Kbytes/s)
Xftp> quit
X221 Goodbye.
X> 
X
XWhen a game is announced, the host will specify what sort of races are
Xdesired.  If the game will not use the "vanilla" racegen, the host will post
Xa file called "game_info.h" that you will then use to compile racegen with.
XNote that racegen.shar comes with a default game_info.h file.
X
XNow you can make an executable racegen.  Unshar the archive you just got,
Xand make it:
X
X> sh racegen.shar
Xx - racegen.c
Xx - racegen.h
Xx - game_info.h
Xx - Makefile
Xx - racegen.README
X> make
Xcc -bsd -g  -target sun3 -c  racegen.c
Xcc -o racegen racegen.o -lm
X> ls
XMakefile        racegen*        racegen.c       racegen.o
Xgame_info.h     racegen.README  racegen.h       racegen.shar
X
X
XNow you are ready to go.  Just type "racegen", and it will run.  If it
Xdoes not, make sure you have the current directory "." as a part of
Xyour path:
X
X> printenv PATH
X.:/usr/imports/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin
X>
X
X(Note that the first directory in my path *is* ".".  ':' is used to
Xseparate the directories in this list.)
X
XIf "." is not in your path, you must either put the racegen executable
Xfile in one of the directories that is in your path, or else put "."
Xinto your path.  The second option is much easier:
X
X> setenv PATH .:$PATH
X
XNow you are ready to go!
END_OF_FILE
if test 2130 -ne `wc -c <'doc/racegen.novice-info'`; then
    echo shar: \"'doc/racegen.novice-info'\" unpacked with wrong size!
fi
# end of 'doc/racegen.novice-info'
fi
if test -f 'hdrs/files.h.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdrs/files.h.SH'\"
else
echo shar: Extracting \"'hdrs/files.h.SH'\" \(2392 characters\)
sed "s/^X//" >'hdrs/files.h.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X    ln ../config.sh . || \
X    ln ../../config.sh . || \
X    ln ../../../config.sh . || \
X    (echo "Can't find config.sh."; exit 1)
X    fi
X    . ./config.sh
X    ;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
X
Xcase "$d_symlink" in
X*define*) sln='ln -s' ;;
X*) sln='ln';;
Xesac
X
Xecho "Extracting files.h (with variable substitutions)"
Xcat >files.h <<!GROK!THIS!
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, { * smq@ucscb.ucsc.edu, mods by people in GB.c, enroll.dat.
X * Restrictions in GB.c.
X *
X * files.h
X * This file was produced by running the files.h.SH script, which
X * gets its values from config.sh, which is generally produced by
X * running Configure.
X *
X * Feel free to modify any of this as the need arises.  Note, however,
X * that running files.h.SH again will wipe out any changes you've made.
X * For a more permanent change edit config.h.SH.
X */
X#ident  "@(#)files.h.SH	1.2 12/15/92 "
X
X#define PATH(file)	"${gbpath}/"#file
X#define	DATA(file)	PATH(Data/file)
X#define NEWS(file)      PATH(News/file)
X#define TELE(file)      PATH(Tele/file)
X#define LOG(file)		PATH(Logs/file)
X
X#define PATHLEN		200	/* length of file paths to the game.. */
X
X#define CUTE_MESSAGE	"\nThe Galactic News\n\n"
X#define DECLARATION	0	/* news file index */
X#define TRANSFER	1
X#define COMBAT		2
X#define ANNOUNCE	3
X
X#define DATADIR		Files[0]
X#define DOCSDIR		Files[1]
X#define EXAM_FL		Files[2]
X#define ENROLL_FL	Files[3]
X#define STARDATAFL 	Files[4]
X#define SECTORDATAFL 	Files[5]
X#define PLANETDATAFL 	Files[6]
X#define RACEDATAFL 	Files[7]
X#define BLOCKDATAFL	Files[8]
X#define SHIPDATAFL 	Files[9]
X#define SHIPFREEDATAFL 	Files[10]
X#define DUMMYFL		Files[11]
X#define PLAYERDATAFL 	Files[12]
X#define TELEGRAMDIR 	Files[13]
X#define TELEGRAMFL 	Files[14]
X#define POWFL		Files[15]
X#define NEWSDIR		Files[16]
X#define DECLARATIONFL	Files[17]
X#define TRANSFERFL	Files[18]
X#define COMBATFL	Files[19]
X#define ANNOUNCEFL	Files[20]
X#define COMMODDATAFL	Files[21]
X#define COMMODFREEDATAFL        Files[22]
X#define	UPDATEFL	Files[23]
X#define	SEGMENTFL	Files[24]
X#define ERRLOG		Files[25]
X#define USLOG		Files[26]
X#define UPLOG		Files[27]
X    
X#define PLANETLIST	PATH(planet.list)
X#define STARLIST	PATH(star.list)
X    
X#define NOGOFL		PATH(nogo)
X#define	ADDRESSFL	PATH(Addresses)
X
Xextern char *Files[];
X/* END OF FILES.H */
X!GROK!THIS!
X
END_OF_FILE
if test 2392 -ne `wc -c <'hdrs/files.h.SH'`; then
    echo shar: \"'hdrs/files.h.SH'\" unpacked with wrong size!
fi
# end of 'hdrs/files.h.SH'
fi
if test -f 'misc/help.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/help.txt'\"
else
echo shar: Extracting \"'misc/help.txt'\" \(2372 characters\)
sed "s/^X//" >'misc/help.txt' <<'END_OF_FILE'
X----------------------------------------------------------------------------
XUsage: help <topic>
X
X	CONCEPTS (read these first) -
X		actionpoints    colony          commands        crystal
X                descriptions    lasers          maintain        missiles
X                money           morale          races           scope
X                ships           updates         afv
X
X	COMBAT -
X                assault         bombard         capture         cew
X                defend          enslave         fire
X
X	COMMUNICATIONS -
X                announce        broadcast       highlight       page
X                post            read            send            think
X
X	INFORMATION -
X                analysis        autoreport      colonies        distance
X                dump            examine         explore         governors
X                identify        map             motto           name
X                orbit           personal        power           production
X                profile         report          ship            stars
X                status          survey          victory         fuel
X                mass            schedule
X
X	MILITARY -
X                arm             deploy          disarm          mobilize
X
X	MONETARY -
X                bid             insurgency      pay             sell
X                tax             transfer        treasury
X
X	RELATIONS  -
X                appoint         block           declare         give
X                grant           invite          pledge          relation
X                revoke          uninvite        unpledge
X
X	SHIPS -
X                build           detonate        dismount        dock
X                jettison        land            launch          load
X                make            modify          mount           order
X                scrap           stats           stock           tactical
X                undock          unload          upgrade         weapons
X
X	OTHER -
X                allocate        capital         cs              center
X                dissolve        help            move            repair
X                quit            route           speed           technology
X                time            toggle          toxicity        vote
X                who             zoom
X----------------------------------------------------------------------------
X
END_OF_FILE
if test 2372 -ne `wc -c <'misc/help.txt'`; then
    echo shar: \"'misc/help.txt'\" unpacked with wrong size!
fi
# end of 'misc/help.txt'
fi
if test -f 'misc/star.list' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/star.list'\"
else
echo shar: Extracting \"'misc/star.list'\" \(2354 characters\)
sed "s/^X//" >'misc/star.list' <<'END_OF_FILE'
XAbel
XAchernar
XAcrab
XAdhara
XAdara
XAdonis
XAkbar
XAlbireo
XAlcor
XAldebran
XAleramin
XAlfard
XAlferatz
XAlfwecca
XAlgol
XAlhema
XAlioth
XAlkalurops
XAlmach
XAlnath
XAlnitak
XAlpha
XAltair
XAludra
XAlya
XAnanke
XAndor
XAndromeda
XAntares
XAnthony
XAntlia
XAphrodite
XApocalypse
XApollo
XAquila
XAquarius
XAra
XArchernar
XArcturus
XAres
XAriel
XArioch
XArtemis
XAscella
XAuriga
XAvior
XAyachi
XAzagthoth
XBear
XBeholder
XBellatrix
XBenetnasch
XBeta
XBetelgeuse
XBohr
XBones
XBootes
XBoreas
XBrahe
XBrin
XBrust
XBujold
XByron
XCallisto
XCalrissian
XCalypso
XCamille
XCancer
XCaneb
XCanis
XCanopus
XCapella
XCapricorn
XCard
XCarina
XCarnicula
XCaroli
XCassiopeia
XCastor
XCat
XCentauri
XCepheus
XCetus
XChi
XCiturnae
XColumba
XCopernicus
XCorona
XCorvus
XCrater
XCrusher
XCrux
XCthulhu
XCursa
XCurtis
XCygnus
XCylon
XDalos
XDaphne
XDark
XData
XDeath
XDelphinus
XDelta
XDeneb
XDionysus
XDiphda
XDonaldson
XDorado
XDorcas
XDraco
XDubhe
XEa
XElrond
XEkpe
XEniph
XEpsilon
XEridanus
XErusa
XEshu
XEta
XFantor
XFermi
XFisher
XFomori
XFomalhaut
XFord
XFornax
XFortuna
XFredux
XGamma
XGauss
XGamorae
XGemini
XGerd
XGeinah
XGnur
XGomeisa
XGrus
XGuiness
XGungnir
XHadar
XHalley
XHamal
XHamill
XHawking
XHector
XHeisenberg
XHera
XHerbert
XHercules
XHephiastes
XHodge
XHofstader
XHolly
XHopper
XHorae
XHubble
XHyades
XHydrus
XHyperion
XIki
XInnana
XInterigon
XIota
XIndus
XInus
XIshtar
XIswar
XIzahami
XJade
XJanus
XJhurna
XJocasta
XJones
XJove
XJupiter
XKappa
XKaus
XKeats
XKenobi
XKirk
XKlingon
XKocab
XKornophoros
XKryten
XLamarna
XLambda
XLeia
XLeo
XLepus
XLesath
XLibra
XLister
XLucas
XLupus
XLynx
XLyra
XMagellan
XMars
XMayhew
XMcCaffery
XMcCoy
XMercury
XMesuta
XMegnazon
XMerak
XMeukalinan
XMiaplacidus
XMimosa
XMirach
XMirfak
XMirzam
XMizar
XMonoceros
XMordor
XMuphrid
XMusca
XNemesis
XNeptune
XNessus
XNewton
XNuada
XNunka
XNyx
XOg
XOmega
XOmicron
XOox
XOphiucus
XOrion
XPavo
XPeace
XPegasus
XPelops
XPerseus
XPhakt
XPhecda
XPheonix
XPhi
XPicard
XPictor
XPisces
XPlanck
XPlato
XPleides
XPluto
XPollux
XPolaris
XProcyon
XPsi
XPtolemy
XPuppis
XPyxis
XQrdus
XQuadran
XQuipus
XRastaban
XRegulus
XRemus
XReticulum
XRho
XRigel
XRiker
XRimmer
XRomulus
XRosenberg
XRotarev
XSaberhagen
XSabik
XSadalrud
XSagittarius
XSandage
XSargas
XSaturn
XScorpio
XScott
XSerpens
XShapley
XShaula
XSheat
XSigma
XSimmons
XSirius
XSkywalker
XSol
XSpica
XSpielberg
XSpock
XSulu
XTammuz
XTarazed
XTarkus
XTarsus 
XTaurus
XTeller
XTerl
XTheta
XThuban
XTrinus
XTolkien
XTriangulum
XTucana
XUmbriel
XUnukalkay
XUpsilon
XUranus
XUrsa
XUrth
XVader
XVedas
XVega
XVela
XVenatici
XVenus
XVirgo
XVolans
XWar
XWesen
XWilliams
XWirth
XWoosley
XWorf
XXi
XYima
XYoda
XYuggoth
XYrga
XZarg
XZawijah
XZeus
XZot
XZog
XZozca
XZeta
XZuben
END_OF_FILE
if test 2354 -ne `wc -c <'misc/star.list'`; then
    echo shar: \"'misc/star.list'\" unpacked with wrong size!
fi
# end of 'misc/star.list'
fi
if test -f 'server/client.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/client.c'\"
else
echo shar: Extracting \"'server/client.c'\" \(3671 characters\)
sed "s/^X//" >'server/client.c' <<'END_OF_FILE'
X/***********************************************
X * log.c
X *
X * Created: Sun Jan 31 23:50:18 EST 1993
X * Author:  J. Deragon (deragon@jethro.nyu.edu
X *
X * Version: 1.3 04:35:26
X *
X * Contains:
X *   clearlog()
X *   log()
X *   check_logsize()
X *
X * #ident  "@(#)client.c	1.3 2/1/93 "
X *
X ***********************************************/
X
X#define EXTERN extern 
X#include "vars.h"
X#include "buffers.h"
X#include "races.h"
X#include "power.h"
X#include "ships.h"
X#include "csp.h"
X#include "proto.h"
X
X/* Protoypes */
Xvoid CSP_process_command(int, int);
Xvoid CSP_client_on(int, int);
Xvoid CSP_client_off(int, int);
Xvoid CSP_client_toggle(int,  int, int);
Xvoid CSP_client_version(int, int);
Xvoid strip2args(void);
X
X/* 
X * CSP_process_command
X * 
X * Process the client generated commands. 
X *
X */
Xvoid 
XCSP_process_command(int Playernum, int Governor)
X{
X	int command;
X
X	if (argn < 2) {
X		sprintf(buf, "%c %d %d\n", CSP_CLIENT, CSP_ERR, 
X			CSP_ERR_TOO_FEW_ARGS);
X		notify(Playernum, Governor, buf);
X	}
X
X	command = atoi(args[1]);
X
X	switch (command) {
X		case CSP_VERSION_COMMAND:
X			CSP_client_version(Playernum, Governor);
X			break;
X		case CSP_SURVEY_COMMAND:
X			strip2args();
X			survey(Playernum, Governor, 0, 1);
X			break;
X		case CSP_LOGIN_COMMAND:
X			CSP_client_toggle(Playernum, Governor, 1);
X			break;
X		default:
X			sprintf(buf, "%c %d %d\n", CSP_CLIENT, CSP_ERR, 
X				CSP_ERR_UNKNOWN_COMMAND);
X			notify(Playernum, Governor, buf);
X			break;
X	}
X
X
X}
X
X/*
X * CSP_client_on
X *
X * Send the init string to the client, letting it know we reconize in
X *
X * ** INTERNAL ** Called by CSP_client_toggle()
X *
X */
Xvoid
XCSP_client_on(int Playernum, int Governor)
X{
X	sprintf(buf, "%c %d %d %d\n", CSP_CLIENT, CSP_CLIENT_ON, 
X		Playernum, Governor);
X	notify(Playernum, Governor, buf);
X}
X
X
X/*
X * CSP_client_off
X *
X * Send the logout string to the client.
X *
X * ** INTERNAL ** Called by CSP_client_toggle()
X *
X */
Xvoid
XCSP_client_off(int Playernum, int Governor)
X{
X	sprintf(buf, "%c %d %d %d\n", CSP_CLIENT, CSP_CLIENT_OFF, 
X		Playernum, Governor);
X	notify(Playernum, Governor, buf);
X}
X
X/*
X * CSP_client_toggle
X *
X * Called from the toggle command, and also when a CSP_CLIENT_LOGIN
X * was received from CSP_process_command 
X *
X */
Xvoid
XCSP_client_toggle(int Playernum, int Governor, int Startup)
X{
X	racetype *r;
X	
X	r = races[Playernum - 1];
X
X	if (Startup) {
X		/* forced via a CSP_CLIENT_LOGIN command */
X		r->governor[Governor].CSP_client_info.csp_user = 1;
X		CSP_client_on(Playernum, Governor);
X	} else {
X		if (r->governor[Governor].CSP_client_info.csp_user == 1) {
X			r->governor[Governor].CSP_client_info.csp_user = 0; 
X			CSP_client_off(Playernum, Governor);
X		} else {
X			r->governor[Governor].CSP_client_info.csp_user = 1;
X			CSP_client_on(Playernum, Governor);
X		}
X	}
X
X}
X
X/*
X * CSP_client_version
X *
X * Prints out the server version information, when requested from client
X *
X */
Xvoid
XCSP_client_version(int Playernum, int Governor)
X{
X
X	sprintf(buf, "%c %d Server Version: %s\n",
X		 CSP_CLIENT, CSP_VERSION_INFO, VERSION);
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "%c %d Server Options:", CSP_CLIENT, CSP_VERSION_OPTIONS);
X
X#ifdef SUPER_PODS
X	strcat(buf, " SUPERPODS");
X#endif
X
X#ifdef AUTOSCRAP
X	strcat(buf, " AUTOSCRAP");
X#endif
X
X#ifdef THRESHLOADING
X	strcat(buf, " THRESHLOADING");
X#endif
X
X	strcat(buf, "\n");
X	notify(Playernum, Governor, buf);
X}
X
X
X/*
X * strip2args
X *
X * Strips off two arguments off the args array.  Used only for the
X * survey command currently
X *
X */
Xvoid
Xstrip2args(void)
X{
X
X	int  i;
X	char targs[MAXARGS][COMMANDSIZE];
X
X	argn -= 1;
X
X	for (i = 2; i < MAXARGS; i++)
X		strcpy(targs[i-1], args[i]);
X
X	for (i = 0; i < MAXARGS; i++)
X		strcpy(args[i], targs[i]);
X
X}
END_OF_FILE
if test 3671 -ne `wc -c <'server/client.c'`; then
    echo shar: \"'server/client.c'\" unpacked with wrong size!
fi
# end of 'server/client.c'
fi
if test -f 'server/lists.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/lists.c'\"
else
echo shar: Extracting \"'server/lists.c'\" \(3663 characters\)
sed "s/^X//" >'server/lists.c' <<'END_OF_FILE'
X#include <ctype.h>
X
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "shipdata.h"
X#include "races.h"
X#include "power.h"
X#include "proto.h"
X
X
X/* utilities for dealing with ship lists */
Xvoid 
Xinsert_sh_univ(sdata, s)
X	struct stardata *sdata;
X	shiptype       *s;
X{
X	s->nextship = sdata->ships;
X	sdata->ships = s->number;
X	s->whatorbits = LEVEL_UNIV;
X}
X
Xvoid 
Xinsert_sh_star(star, s)
X	startype       *star;
X	shiptype       *s;
X{
X	s->nextship = star->ships;
X	star->ships = s->number;
X	s->whatorbits = LEVEL_STAR;
X}
X
Xvoid 
Xinsert_sh_plan(pl, s)
X	planettype     *pl;
X	shiptype       *s;
X{
X	s->nextship = pl->ships;
X	pl->ships = s->number;
X	s->whatorbits = LEVEL_PLAN;
X}
X
Xvoid 
Xinsert_sh_ship(s, s2)
X	shiptype       *s;
X	shiptype       *s2;
X{
X	s->nextship = s2->ships;
X	s2->ships = s->number;
X	s->whatorbits = LEVEL_SHIP;
X	s->whatdest = LEVEL_SHIP;
X	s->destshipno = s2->number;
X}
X
Xvoid 
Xremove_sh_star(shiptype * s)
X{
X	int             sh;
X	shiptype       *s2;
X
X	getstar(&Stars[s->storbits], (int) s->storbits);
X	sh = Stars[s->storbits]->ships;
X
X	if (sh == s->number) {
X		Stars[s->storbits]->ships = s->nextship;
X		putstar(Stars[s->storbits], (int) (s->storbits));
X	} else {
X		while (sh != s->number) {
X			(void) getship(&s2, sh);
X			sh = s2->nextship;
X			if (sh != s->number)
X				free(s2);
X		}
X		s2->nextship = s->nextship;
X		putship(s2);
X		free(s2);
X	}
X	s->whatorbits = LEVEL_UNIV;
X	s->nextship = 0;
X}
X
Xvoid 
Xremove_sh_plan(shiptype * s)
X{
X	int             sh;
X	shiptype       *s2;
X	planettype     *p;
X
X	getplanet(&p, (int) s->storbits, (int) s->pnumorbits);
X	sh = p->ships;
X
X	if (sh == s->number) {
X		p->ships = s->nextship;
X		putplanet(p, (int) s->storbits, (int) s->pnumorbits);
X	} else {
X		while (sh != s->number) {
X			(void) getship(&s2, sh);
X			sh = s2->nextship;
X			if (sh != s->number)
X				free(s2);	/* don't free it if it is the
X						 * s2 we wa nt */
X		}
X		s2->nextship = s->nextship;
X		putship(s2);
X		free(s2);
X	}
X	free(p);
X	s->nextship = 0;
X	s->whatorbits = LEVEL_UNIV;
X}
X
Xvoid 
Xremove_sh_ship(shiptype * s, shiptype * ship)
X{
X	int             sh;
X	shiptype       *s2;
X	sh = ship->ships;
X
X	if (sh == s->number)
X		ship->ships = s->nextship;
X	else {
X		while (sh != s->number) {
X			(void) getship(&s2, sh);
X			sh = (int) (s2->nextship);
X			if (sh != s->number)
X				free(s2);
X		}
X		s2->nextship = s->nextship;
X		putship(s2);
X		free(s2);
X	}
X	s->nextship = 0;
X	s->whatorbits = LEVEL_UNIV;	/* put in limbo - wait for
X					 * insert_sh.. */
X}
X
Xdouble 
XGetComplexity(int ship)
X{
X	shiptype        s;
X
X	s.armor = Shipdata[ship][ABIL_ARMOR];
X	s.guns = Shipdata[ship][ABIL_PRIMARY] ? PRIMARY : NONE;
X	s.primary = Shipdata[ship][ABIL_GUNS];
X	s.primtype = Shipdata[ship][ABIL_PRIMARY];
X	s.secondary = Shipdata[ship][ABIL_GUNS];
X	s.sectype = Shipdata[ship][ABIL_SECONDARY] ? SECONDARY : NONE;
X	s.max_crew = Shipdata[ship][ABIL_MAXCREW];
X	s.max_resource = Shipdata[ship][ABIL_CARGO];
X	s.max_hanger = Shipdata[ship][ABIL_HANGER];
X	s.max_destruct = Shipdata[ship][ABIL_DESTCAP];
X	s.max_fuel = Shipdata[ship][ABIL_FUELCAP];
X	s.max_speed = Shipdata[ship][ABIL_SPEED];
X	s.build_type = ship;
X	s.mount = Shipdata[ship][ABIL_MOUNT];
X	s.hyper_drive.has = Shipdata[ship][ABIL_JUMP];
X	s.cloak = 0;
X	s.laser = Shipdata[ship][ABIL_LASER];
X	s.cew = 0;
X	s.cew_range = 0;
X	s.size = ship_size(&s);
X	s.base_mass = getmass(&s);
X	s.mass = getmass(&s);
X
X	return complexity(&s);
X}
X
Xint 
XShipCompare(int *s1, int *s2)
X{
X	return (int) (GetComplexity(*s1) - GetComplexity(*s2));
X}
X
Xint             ShipVector[NUMSTYPES];
Xvoid 
XSortShips(void)
X{
X	int             i;
X
X	for (i = 0; i < NUMSTYPES; i++)
X		ShipVector[i] = i;
X	qsort(ShipVector, NUMSTYPES, sizeof(int), ShipCompare);
X}
END_OF_FILE
if test 3663 -ne `wc -c <'server/lists.c'`; then
    echo shar: \"'server/lists.c'\" unpacked with wrong size!
fi
# end of 'server/lists.c'
fi
if test -f 'server/log.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/log.c'\"
else
echo shar: Extracting \"'server/log.c'\" \(4332 characters\)
sed "s/^X//" >'server/log.c' <<'END_OF_FILE'
X#ident  "@(#)log.c	1.5 1/28/93 "
X/***********************************************
X * log.c
X *
X * Created: Fri Dec 11 03:50:49 EST 1992
X * Author:  J. Deragon (deragon@jethro.nyu.edu
X *
X * Version: 1.5 20:59:33
X *
X * Contains:
X *   clearlog()
X *   log()
X *   check_logsize()
X *
X ***********************************************/
X
X#include <errno.h>
X#include <fcntl.h>
X#include <varargs.h>
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#define EXTERN extern
X#include "vars.h"
X#include "files.h"
X
X
Xint             where;
X
X
X/*
X * clearlog:
X * 
X * arguments: override override is used upon startup, when true it will remove
X * (truncate) _all_ log files.  It is normall set to false. called by: main,
X * check_logsize
X * 
X * description:  Called once from main, upon startup to clear all the log files
X * to prevent disgustingly large log files from eating up the disk, and
X * called from check_logsize. If override is set to false, it will determine
X * the log to truncate from the global variable "where".
X * 
X * JPD Fri Dec 11 03:01:46 EST 1992
X */
X
Xclearlog(override)
X	int             override;
X{
X
X	if (override) {
X		fclose(fopen(ERRLOG, "w+"));
X		fclose(fopen(USLOG, "w+"));
X		fclose(fopen(UPLOG, "w+"));
X	} else {
X		switch (where) {
X		case ERRORLOG:
X			fclose(fopen(ERRLOG, "w+"));
X			loginfo(ERRORLOG, NOERRNO, "Clearing ERRORLOG");
X			break;
X		case USERLOG:
X			fclose(fopen(USLOG, "w+"));
X			loginfo(ERRORLOG, NOERRNO, "Clearing USERLOG");
X			break;
X		case UPDATELOG:
X			fclose(fopen(UPLOG, "w+"));
X			loginfo(ERRORLOG, NOERRNO, "Clearing UPDATE");
X			break;
X		}
X	}
X	/* simple enough eh? */
X}
X/* end of clearlog */
X
X/*
X * loginfo:
X * 
X * arguments: multiple - first is _always_ the log file that the error should be
X * written to.  Either ERRORLOG, USERLOG, or UPDATELOG. second arg is the
X * noerrno flag.  Set to false when we should ignore the errno.  (ie: when we
X * dont care about it) third arg is the data
X * 
X * called by: everyone!
X * 
X * description:  Called whenever something needs to be logged. The most frequent
X * logs are the USERLOG (when someone logs on) and UPDATELOG (details of
X * updates/segments)
X * 
X * JPD Fri Dec 11 03:01:46 EST 1992
X */
X
X
X/* VARARGS */
Xloginfo(va_alist)
Xva_dcl
X{
X	extern char    *index();
X	extern char    *sys_errlist[];
X	extern int      errno;
X	va_list         list;
X	long            now;
X	char            buf[512];
X	char            buf1[512];
X	char           *fmt;	/* The acutal data to be printed */
X	int             noerrno;/* Should we care about the errno? */
X	int             logf;
X	char           *error;
X	char           *p;
X	char           *logfile;/* the acutal log file name */
X
X
X	va_start(list);
X	where = va_arg(list, int);	/* Put is where? */
X	noerrno = va_arg(list, int);	/* Disregard errno? false yes, true
X					 * no */
X	fmt = va_arg(list, char *);	/* data */
X	vsprintf(buf, fmt, list);
X
X
X	/*
X	 * We do this little bit to allow us an easy way to pass the
X	 * filenames back and forth between clearlogs and log.  ie: Pass an
X	 * int, instead of a (char *), so we can use switch.
X	 */
X
X	switch (where) {
X	case ERRORLOG:
X		logfile = ERRLOG;
X		break;
X	case USERLOG:
X		logfile = USLOG;
X		break;
X	case UPDATELOG:
X		logfile = UPLOG;
X		break;
X	default:
X		break;
X	}
X
X	if ((p = index(buf, '\n')) != 0)	/* get rid of the newline */
X		*p = 0;
X
X	(void) time(&now);	/* for the timestamp */
X	error = "log";
X	if (errno != 0 && noerrno)
X		error = sys_errlist[errno];
X
X	(void) sprintf(buf1, "%s; (%s) %s", buf, error, ctime(&now));
X	if ((logf = open(logfile, O_WRONLY | O_CREAT | O_APPEND, 0666)) < 0)
X		return;
X
X	check_logsize(logf);	/* Make sure we dont hog space */
X
X	(void) write(logf, buf1, strlen(buf1));
X	(void) close(logf);
X	errno = 0;
X	va_end(list);
X}
X/* end of loginfo() */
X
X/*
X * check_logsize:
X * 
X * arguments: log_fd:  the log file descriptor (int).
X * 
X * called by: log (local to this file)
X * 
X * description:  Called whenever log attemps to write to a file. Before the
X * write it will check to see if the log is larger then the max log size
X * (default 100K).  If it is, it calls clearlog() to truncate the log.
X * 
X * JPD Fri Dec 11 03:01:46 EST 1992
X */
Xcheck_logsize(log_fd)
X	int             log_fd;
X{
X	struct stat     logstats;
X
X	(void) fstat(log_fd, &logstats);
X
X	if (logstats.st_size > MAX_LOGSIZE)
X		clearlog(0);
X
X}
X
X/* end of check_logsize */
END_OF_FILE
if test 4332 -ne `wc -c <'server/log.c'`; then
    echo shar: \"'server/log.c'\" unpacked with wrong size!
fi
# end of 'server/log.c'
fi
if test -f 'server/max.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/max.c'\"
else
echo shar: Extracting \"'server/max.c'\" \(2653 characters\)
sed "s/^X//" >'server/max.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * maxsupport() -- return how many people one sector can support compatibility()
X * -- return how much race is compatible with planet gravity() -- return
X * gravity for planet prin_ship_orbits() -- prints place ship orbits
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "power.h"
X#include "races.h"
X#include "ships.h"
X#include <math.h>
X
Xint             maxsupport(racetype *, sectortype *, double, int);
Xdouble          compatibility(planettype *, racetype *);
Xdouble          gravity(planettype *);
Xchar           *prin_ship_orbits(shiptype *);
X#include "proto.h"
X
Xint 
Xmaxsupport(reg racetype * r, reg sectortype * s, reg double c, reg int toxic)
X{
X	int             val;
X	double          a, b;
X
X	if (!r->likes[s->condition])
X		return 0.0;
X	a = ((double) s->eff + 1.0) * (double) s->fert;
X	b = (.01 * c);
X
X	val = (int) (a * b * .01 * (100.0 - (double) toxic));
X
X	return val;
X}
X
Xdouble 
Xcompatibility(reg planettype * planet, reg racetype * race)
X{
X	reg int         i; 
X	reg double      add;
X	double          sum, atmosphere = 1.0;
X
X	/* make an adjustment for planetary temperature */
X	add = 0.1 * ((double) planet->conditions[TEMP] - 
X			(double)race->conditions[TEMP]);
X	sum = 1.0 - (double) abs(add) / 100.0;
X
X	/* step through and report compatibility of each planetary gas */
X	for (i = TEMP + 1; i <= OTHER; i++) {
X		add = (double) planet->conditions[i] - (double) race->conditions[i];
X		atmosphere *= 1.0 - (double) abs(add) / 100.0;
X	}
X	sum *= atmosphere;
X	sum *= 100.0 - planet->conditions[TOXIC];
X
X	if (sum < 0.0)
X		return 0.0;
X	return (sum);
X}
X
Xdouble 
Xgravity(planettype * p)
X{
X	return (double) (p->Maxx) * (double) (p->Maxy) * GRAV_FACTOR;
X}
X
Xchar            Dispshiporbits_buf[PLACENAMESIZE + 13];
X
Xchar           *
Xprin_ship_orbits(shiptype * s)
X{
X	shiptype       *mothership;
X	char           *motherorbits;
X
X	switch (s->whatorbits) {
X	case LEVEL_UNIV:
X		sprintf(Dispshiporbits_buf, "/(%.0f,%.0f)", s->xpos, s->ypos);
X		break;
X	case LEVEL_STAR:
X		sprintf(Dispshiporbits_buf, "/%s", Stars[s->storbits]->name);
X		break;
X	case LEVEL_PLAN:
X		sprintf(Dispshiporbits_buf, "/%s/%s",
X			Stars[s->storbits]->name,
X			Stars[s->storbits]->pnames[s->pnumorbits]);
X		break;
X	case LEVEL_SHIP:
X		if (getship(&mothership, s->destshipno)) {
X			motherorbits = prin_ship_orbits(mothership);
X			strcpy(Dispshiporbits_buf, motherorbits);
X			free(mothership);
X		} else
X			strcpy(Dispshiporbits_buf, "/");
X		break;
X	default:
X		break;
X	}
X	return Dispshiporbits_buf;
X}
END_OF_FILE
if test 2653 -ne `wc -c <'server/max.c'`; then
    echo shar: \"'server/max.c'\" unpacked with wrong size!
fi
# end of 'server/max.c'
fi
if test -f 'server/misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/misc.c'\"
else
echo shar: Extracting \"'server/misc.c'\" \(2794 characters\)
sed "s/^X//" >'server/misc.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * scales used in production efficiency etc. input both: int 0-100 output both:
X * float 0.0 - 1.0 (logscaleOB 0.5 - .95)
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "races.h"
X#include "buffers.h"
X#include "fcntl.h"
X#include <math.h>
X
Xdouble          logscale(int);
X
Xdouble
Xlogscale(int x)
X{
X	/* return (x+5.0) / (x+10.0); */
X	return log10((double) x + 1.0) / 2.0;
X}
X
Xvoid
Xadjust_morale(racetype * winner, racetype * loser, int amount)
X{
X	winner->morale += amount;
X	loser->morale -= amount;
X	winner->points[loser->Playernum] += amount;
X}
X
Xvoid
Xload_star_data(void)
X{
X	int             s, t, i, j;
X	startype       *star_arena;
X	planettype     *planet_arena;
X	int             pcount = 0;
X
X	/* get star database */
X	Planet_count = 0;
X	getsdata(&Sdata);
X	star_arena = (startype *) malloc(Sdata.numstars * sizeof(startype));
X	for (s = 0; s < Sdata.numstars; s++) {
X		Stars[s] = &star_arena[s];	/* Initialize star pointers */
X	}
X	for (s = 0; s < Sdata.numstars; s++) {
X		getstar(&(Stars[s]), s);
X		pcount += Stars[s]->numplanets;
X	}
X
X	planet_arena = (planettype *) malloc(pcount * sizeof(planettype));
X
X	for (s = 0; s < Sdata.numstars; s++) {
X		for (t = 0; t < Stars[s]->numplanets; t++) {
X			planets[s][t] = &planet_arena[--pcount];
X			getplanet(&planets[s][t], s, t);
X			if (planets[s][t]->type != TYPE_ASTEROID)
X				Planet_count++;
X		}
X	}
X	/* initialize zoom factors */
X	for (i = 1; i <= Num_races; i++)
X		for (j = 0; j <= MAXGOVERNORS; j++) {
X			Dir[i - 1][j].zoom[0] = 1.0;
X			Dir[i - 1][j].zoom[1] = 0.5;
X			Dir[i - 1][j].lastx[0] = Dir[i - 1][j].lastx[1] = 0.0;
X			Dir[i - 1][j].lasty[0] = Dir[i - 1][j].lasty[1] = 0.0;
X		}
X}
X
Xvoid
Xload_race_data(void)
X{
X	int             i;
X	Num_races = Numraces();
X	for (i = 1; i <= Num_races; i++) {
X		getrace(&races[i - 1], i);	/* allocates into memory */
X		if (races[i - 1]->Playernum != i) {
X			races[i - 1]->Playernum = i;
X			putrace(races[i - 1]);
X		}
X	}
X}
X
Xvoid
Xwelcome_user(struct descriptor_data * d)
X{
X	FILE           *f;
X	char           *p;
X
X	sprintf(buf, "***   Welcome to Galactic Bloodshed %s ***\n", VERS);
X	queue_string(d, buf);
X
X	if ((f = fopen(WELCOME_FILE, "r")) != NULL) {
X		while (fgets(buf, sizeof buf, f)) {
X			for (p = buf; *p; p++)
X				if (*p == '\n') {
X					*p = '\0';
X					break;
X				}
X			queue_string(d, buf);
X			queue_string(d, "\n");
X		}
X		fclose(f);
X	}
X}
X
Xvoid
Xcheck_for_telegrams(int Playernum, int Governor)
X{
X	struct stat     sbuf;
X
X	sprintf(buf, "%s.%d.%d", TELEGRAMFL, Playernum, Governor);
X	stat(buf, &sbuf);
X	if (sbuf.st_size)
X		notify(Playernum, Governor,
X		"You have telegram(s) waiting. Use 'read' to read them.\n");
X}
END_OF_FILE
if test 2794 -ne `wc -c <'server/misc.c'`; then
    echo shar: \"'server/misc.c'\" unpacked with wrong size!
fi
# end of 'server/misc.c'
fi
if test -f 'user/autoshoot.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/autoshoot.c'\"
else
echo shar: Extracting \"'user/autoshoot.c'\" \(4243 characters\)
sed "s/^X//" >'user/autoshoot.c' <<'END_OF_FILE'
X#ident  "@(#)autoshoot.c	1.5 2/1/93 "
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB.c, enroll.dat. Restrictions in
X * GB.c. autoshoot() -- shoot <-> retaliate routine Bombard() -- ship
X * bombards planet
X */
X
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "doturn.h"
X#include "buffers.h"
X
Xextern long     Shipdata[NUMSTYPES][NUMABILS];
X
Xint             Bombard(shiptype *, planettype *, racetype *);
X#include "proto.h"
X
X/*
X * ship #shipno bombards planet, then alert whom it may concern.
X */
Xint 
XBombard(shiptype * ship, planettype * planet, racetype * r)
X{
X	shiptype       *s;
X	int             x, y, x2 = -1, y2, oldown, numdest = 0, found = 0;
X	int             i, sh;
X	int             ok;
X
X	/* for telegramming */
X	bzero((char *) Nuked, sizeof(Nuked));
X
X	/* check to see if PDNs are present */
X	ok = 1;
X	sh = planet->ships;
X	while (sh && ok) {
X		(void) getship(&s, sh);
X		ok = !(s->alive && s->type == OTYPE_PLANDEF && s->owner != ship->owner);
X		sh = s->nextship;
X		free(s);
X	}
X	if (!ok) {
X		sprintf(buf, "Bombardment of %s cancelled, PDNs are present.\n",
X			prin_ship_orbits(ship));
X		warn((int) ship->owner, (int) ship->governor, buf);
X		return 0;
X	}
X	getsmap(Smap, planet);
X
X	/* look for someone to bombard-check for war */
X	(void) Getxysect(planet, 0, 0, 1);	/* reset */
X	while (!found && Getxysect(planet, &x, &y, 0)) {
X		if (Sector(*planet, x, y).owner && Sector(*planet, x, y).owner != ship->owner
X		    && (Sector(*planet, x, y).condition != WASTED)) {
X			if (isset(r->atwar, Sector(*planet, x, y).owner))
X				found = 1;
X			else
X				x2 = x, y2 = y;
X		}
X	}
X	if (x2 != -1) {
X		x = x2;		/* no one we're at war with; bomb someone
X				 * else. */
X		y = y2;
X		found = 1;
X	}
X	if (found) {
X		int             str;
X		str = MIN(Shipdata[ship->type][ABIL_GUNS] * (100 - ship->damage) / 100., ship->destruct);
X		/* save owner of destroyed sector */
X		if (str) {
X			bzero(Nuked, sizeof(Nuked));
X			oldown = Sector(*planet, x, y).owner;
X			ship->destruct -= str;
X			ship->mass -= str * MASS_DESTRUCT;
X
X			numdest = shoot_ship_to_planet(ship, planet, str,
X					x, y, 0, 0, 0, long_buf, short_buf);
X			/* (0=dont get smap) */
X			if (numdest < 0)
X				numdest = 0;
X
X			/* tell the bombarding player about it.. */
X			sprintf(telegram_buf, "REPORT from ship #%d\n\n", ship->number);
X			strcat(telegram_buf, short_buf);
X			sprintf(buf, "sector %d,%d (owner %d).  %d sectors destroyed.\n",
X				x, y, oldown, numdest);
X			strcat(telegram_buf, buf);
X			notify((int) ship->owner, (int) ship->governor, telegram_buf);
X
X			/* notify other player. */
X			sprintf(telegram_buf, "ALERT from planet /%s/%s\n",
X				Stars[ship->storbits]->name,
X			   Stars[ship->storbits]->pnames[ship->pnumorbits]);
X			sprintf(buf, "%c%d %s bombarded sector %d,%d; %d sectors destroyed.\n",
X				Shipltrs[ship->type], ship->number, ship->name, x, y, numdest);
X			strcat(telegram_buf, buf);
X			sprintf(buf, "%c%d %s [%d] bombards %s/%s\n",
X				Shipltrs[ship->type], ship->number, ship->name, ship->owner,
X				Stars[ship->storbits]->name,
X			   Stars[ship->storbits]->pnames[ship->pnumorbits]);
X			for (i = 1; i <= Num_races; i++)
X				if (Nuked[i - 1] && i != ship->owner)
X					warn(i, (int) Stars[ship->storbits]->governor[i - 1], telegram_buf);
X			post(buf, COMBAT);
X
X			/*
X			 * enemy planet retaliates along with defending
X			 * forces
X			 */
X		} else {
X			/* no weapons! */
X			if (!ship->notified) {
X				ship->notified = 1;
X				sprintf(telegram_buf,
X					"Bulletin\n\n %c%d %s has no weapons to bombard with.\n",
X					Shipltrs[ship->type], ship->number, ship->name);
X				warn((int) ship->owner, (int) ship->governor, telegram_buf);
X			}
X		}
X
X		putsmap(Smap, planet);
X
X	} else {
X		/* there were no sectors worth bombing. */
X		if (!ship->notified) {
X			ship->notified = 1;
X			sprintf(telegram_buf, "Report from %c%d %s\n\n",
X			    Shipltrs[ship->type], ship->number, ship->name);
X			sprintf(buf, "Planet /%s/%s has been saturation bombed.\n",
X				Stars[ship->storbits]->name,
X			   Stars[ship->storbits]->pnames[ship->pnumorbits]);
X			strcat(telegram_buf, buf);
X			notify((int) ship->owner, (int) ship->governor, telegram_buf);
X		}
X	}
X	return numdest;
X
X}
END_OF_FILE
if test 4243 -ne `wc -c <'user/autoshoot.c'`; then
    echo shar: \"'user/autoshoot.c'\" unpacked with wrong size!
fi
# end of 'user/autoshoot.c'
fi
if test -f 'user/chan.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/chan.c'\"
else
echo shar: Extracting \"'user/chan.c'\" \(3093 characters\)
sed "s/^X//" >'user/chan.c' <<'END_OF_FILE'
X#ident  "@(#)chan.c	1.3 2/1/93 "
X/***********************************************
X * chan.c
X *
X * Created: Wed Jan 27 20:56:42 EST 1993
X * Author:  John Paul Deragon
X *
X * Version: 1.3 00:14:44
X *
X * Contains: 
X *          
X *
X ***********************************************/
X
X#define EXTERN extern
X#include "GB_copyright.h"
X#include "vars.h"
X#include "races.h"
X#include "ships.h"
X#include "buffers.h"
X#include "power.h"
X#include "config.h"
X#include <stdio.h>
X#include <ctype.h>
X
Xvoid channel(int, int, int, int);
X#include "proto.h"
X
X#ifdef MULTIPLE_COMM_CHANNELS
Xvoid
Xchannel(int Playernum, int Governor, int AP, int startup)
X{
X	int			want;
X
X	if (argn < 2 || startup) 
X		goto dumpchannel;
X	else if (argn == 2) {
X		want = atoi(args[1]);
X		if (isset(races[Playernum -1]->governor[Governor].channel, want)) {
X			clrbit(races[Playernum -1]->governor[Governor].channel, want);
X			clrbit(races[Playernum -1]->governor[Governor].channel, 
X			want + DEFAULT_CHANNEL_MASK);
X		} else
X			setbit(races[Playernum -1]->governor[Governor].channel, want);
X
X		if (isset(races[Playernum -1]->governor[Governor].channel, 
X			want + DEFAULT_CHANNEL_MASK)) {
X			clrbit(races[Playernum -1]->governor[Governor].channel, 
X			want + DEFAULT_CHANNEL_MASK);
X			setbit(races[Playernum -1]->governor[Governor].channel, 
X			COMM_DEF_CHANNEL1);
X			notify(Playernum, Governor, "Setting default comm channel to 1\n");
X		}
X	} else if (argn == 3) {
X		want = atoi(args[1]);
X		if (match(args[2], "default")) {
X			clrbit(races[Playernum -1]->governor[Governor].channel, 
X			COMM_DEF_CHANNEL1);
X			clrbit(races[Playernum -1]->governor[Governor].channel,
X			COMM_DEF_CHANNEL2);
X			clrbit(races[Playernum -1]->governor[Governor].channel, 
X			COMM_DEF_CHANNEL3);
X			if (isclr(races[Playernum -1]->governor[Governor].channel, want)) {
X				setbit(races[Playernum -1]->governor[Governor].channel, want);
X				setbit(races[Playernum -1]->governor[Governor].channel,
X					want + DEFAULT_CHANNEL_MASK);
X			} else
X				setbit(races[Playernum -1]->governor[Governor].channel, 
X					want + DEFAULT_CHANNEL_MASK);
X		}
X	} else {
X		notify(Playernum, Governor, "Syntax: channel <channel> default\n");
X		return;
X	}
X		
X
Xdumpchannel:
X
X		notify(Playernum, Governor, "Channel Status:\n");
X		sprintf(buf, "         One: %s %s\n", 
X			(isset(races[Playernum -1]->governor[Governor].channel, 
X				COMM_CHANNEL1) ? "ON " : "OFF"),
X			(isset(races[Playernum -1]->governor[Governor].channel, 
X				COMM_DEF_CHANNEL1) ? "Default" : "      "));
X		notify(Playernum, Governor, buf); 
X		sprintf(buf, "         Two: %s %s\n", 
X			(isset(races[Playernum -1]->governor[Governor].channel, 
X				COMM_CHANNEL2) ? "ON " : "OFF"),
X			(isset(races[Playernum -1]->governor[Governor].channel, 
X				COMM_DEF_CHANNEL2) ? "Default" : "      "));
X		notify(Playernum, Governor, buf); 
X		sprintf(buf, "         Three: %s %s\n", 
X			(isset(races[Playernum -1]->governor[Governor].channel, 
X				COMM_CHANNEL3) ? "ON " : "OFF"),
X			(isset(races[Playernum -1]->governor[Governor].channel, 
X				COMM_DEF_CHANNEL3) ? "Default" : "      "));
X		notify(Playernum, Governor, buf); 
X
X}
X#endif
END_OF_FILE
if test 3093 -ne `wc -c <'user/chan.c'`; then
    echo shar: \"'user/chan.c'\" unpacked with wrong size!
fi
# end of 'user/chan.c'
fi
if test -f 'user/examine.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/examine.c'\"
else
echo shar: Extracting \"'user/examine.c'\" \(2147 characters\)
sed "s/^X//" >'user/examine.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h. examine -- check out an object
X */
X
X#include <strings.h>
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
Xextern long     Shipdata[NUMSTYPES][NUMABILS];
Xextern char    *Shipnames[];
X
Xvoid            examine(int, int, int);
X#include "proto.h"
X
Xvoid 
Xexamine(int Playernum, int Governor, int APcount)
X{
X	shiptype       *ship;
X	int             t, shipno;
X	FILE           *fd;
X	char            ch;
X
X	if (argn < 2) {
X		notify(Playernum, Governor, "Examine what?\n");
X		return;
X	}
X	sscanf(args[1] + (*args[1] == '#'), "%d", &shipno);
X
X	if (!getship(&ship, shipno)) {
X		return;
X	}
X	if (!ship->alive) {
X		sprintf(buf, "that ship is dead.\n");
X		notify(Playernum, Governor, buf);
X		free(ship);
X		return;
X	}
X	if (ship->whatorbits == LEVEL_UNIV || isclr(Stars[ship->storbits]->inhabited, Playernum)) {
X		sprintf(buf, "That ship it not visible to you.\n");
X		notify(Playernum, Governor, buf);
X		free(ship);
X		return;
X	}
X	if ((fd = fopen(EXAM_FL, "r")) == NULL) {
X		perror(EXAM_FL);
X		free(ship);
X		return;
X	}
X	/* look through ship data file */
X	for (t = 0; t <= ship->type; t++)
X		while (fgetc(fd) != '~');
X
X	/* look through ship data file */
X	sprintf(buf, "\n");
X	/* give report */
X	while ((ch = fgetc(fd)) != '~') {
X		sprintf(temp, "%c", ch);
X		strcat(buf, temp);
X	}
X	notify(Playernum, Governor, buf);
X	fclose(fd);
X
X	if (!ship->examined) {
X		if (ship->whatorbits == LEVEL_UNIV)
X			deductAPs(Playernum, Governor, APcount, 0, 1);	/* ded from sdata */
X		else
X			deductAPs(Playernum, Governor, APcount, (int) ship->storbits, 0);
X
X		ship->examined = 1;
X		putship(ship);
X	}
X	if (has_switch(ship)) {
X		sprintf(buf, "This device has an on/off switch that can be set with order.\n");
X		notify(Playernum, Governor, buf);
X	}
X	if (!ship->active) {
X		sprintf(buf, "This device has been irradiated;\nit's crew is dying and it cannot move for the time being.\n");
X		notify(Playernum, Governor, buf);
X	}
X	free(ship);
X}
END_OF_FILE
if test 2147 -ne `wc -c <'user/examine.c'`; then
    echo shar: \"'user/examine.c'\" unpacked with wrong size!
fi
# end of 'user/examine.c'
fi
if test -f 'user/vict.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/vict.c'\"
else
echo shar: Extracting \"'user/vict.c'\" \(3281 characters\)
sed "s/^X//" >'user/vict.c' <<'END_OF_FILE'
X#ident  "@(#)vict.c	1.5 2/1/93 "
X/***********************************************
X * vict.c
X *
X * Created:
X * Author:  ??
X *
X * Version: 1.5 00:14:40
X *
X * Contains: victory()
X *           create_victory_list()
X *
X *
X ***********************************************/
X
X
X
X#include <errno.h>
X#include <time.h>
X#include <strings.h>
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X
Xextern int      errno;
X
X/*
X * Prototypes
X */
Xvoid            victory(int, int);
Xvoid            create_victory_list(struct vic[MAXPLAYERS]);
Xint             victory_sort(struct vic *, struct vic *);
X#include "proto.h"
X
X/*
X * victory:
X * 
X * arguments: Playernum Playernum who called this function             Governor
X * Governor who called this function called by: main, check_logsize
X * 
X * description:  Called from process_commands
X * 
X * 
X */
Xvoid
Xvictory(int Playernum, int Governor)
X{
X	struct vic      vic[MAXPLAYERS];
X	racetype       *Race;
X	int             i;
X	int             count;
X	int             god = 0;
X
X	count = (argn > 1) ? atoi(args[1]) : Num_races;
X	if (count > Num_races)
X		count = Num_races;
X
X	create_victory_list(vic);
X
X	Race = races[Playernum - 1];
X	if (Race->God)
X		god = 1;
X
X	sprintf(buf, "----==== PLAYER RANKINGS ====----\n");
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "%-4.4s %-15.15s %8s\n", "No.",
X		"Name", (god ? "Score" : ""));
X	notify(Playernum, Governor, buf);
X	for (i = 0; i < count; i++) {
X		if (god)
X			sprintf(buf, "%2d %c [%2d] %-15.15s %5d  %6.2f %3d %s %s\n",
X			    i + 1, vic[i].Thing ? 'M' : ' ', vic[i].racenum,
X				vic[i].name, vic[i].rawscore,
X				vic[i].tech, vic[i].IQ, races[vic[i].racenum - 1]->password,
X			   races[vic[i].racenum - 1]->governor[0].password);
X		else
X			sprintf(buf, "%2d   [%2d] %-15.15s\n", i + 1,
X				vic[i].racenum, vic[i].name);
X		notify(Playernum, Governor, buf);
X	}
X}
X
X/*
X * create_victory_list:
X * 
X * arguments: vic victory structure
X * 
X * called by: victory (local to this file)
X * 
X * description:  Puts together and sorts the races
X * 
X * 
X */
X
Xvoid
Xcreate_victory_list(struct vic vic[MAXPLAYERS])
X{
X	racetype       *vic_races[MAXPLAYERS];
X	int             i, valid_qsort;
X
X	for (i = 1; i <= Num_races; i++) {
X		vic_races[i - 1] = races[i - 1];
X		vic[i - 1].no_count = 0;
X	}
X
X	for (i = 1; i <= Num_races; i++) {
X		vic[i - 1].racenum = i;
X		strcpy(vic[i - 1].name, vic_races[i - 1]->name);
X		/* vic[i-1].rawscore = vic_races[i-1]->victory_score; */
X		vic[i - 1].rawscore = vic_races[i - 1]->morale;
X		vic[i - 1].tech = vic_races[i - 1]->tech;
X		vic[i - 1].Thing = vic_races[i - 1]->Metamorph;
X		vic[i - 1].IQ = vic_races[i - 1]->IQ;
X
X		if (vic_races[i - 1]->God || vic_races[i - 1]->Guest ||
X		    vic_races[i - 1]->dissolved) {
X			vic[i - 1].no_count = 1;
X			valid_qsort = 0; 
X		} else 
X			valid_qsort = 1;
X	
X		
X	}
X	if (valid_qsort) 
X		qsort(vic, Num_races, sizeof(struct vic), victory_sort);
X}
X
X/*
X * victory_sort;
X * 
X * arguments: a, b victory structure
X * 
X * called by: create_victory_list (local to this file)
X * 
X * description:
X * 
X * 
X */
X
Xint 
Xvictory_sort(struct vic * a, struct vic * b)
X{
X	if (a->no_count)
X		return (1);
X	else if (b->no_count)
X		return (-1);
X	else
X		return (b->rawscore - a->rawscore);
X}
END_OF_FILE
if test 3281 -ne `wc -c <'user/vict.c'`; then
    echo shar: \"'user/vict.c'\" unpacked with wrong size!
fi
# end of 'user/vict.c'
fi
if test -f 'utils/Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/Makefile.SH'\"
else
echo shar: Extracting \"'utils/Makefile.SH'\" \(3236 characters\)
sed "s/^X//" >'utils/Makefile.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X    fi
X    . ./config.sh
X    ;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
X
Xecho "Extracting utils/Makefile (with variable substitutions)"
Xcat >Makefile <<!GROK!THIS!
X#
X#  util level Makefile for the GB+ program
X#  This makefile will make the commands library routines
X#
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	John Deragon deragon@jethro.cs.nyu.edu
X#
X# Revision 1.0  92/12/10 jpd
X# 
X#
X# Variables
X#	Variables established by Configure
XCC		=	$cc
XCCFLAGS		=	$ccflags $xencf
XCHGRP		=	$chgrp
XCHMOD		=	$chmod
XCP		=	$cp
XDEST		=	$bin
XECHO		=	$echo
XLFLAGS		=	$ldflags 
XLIB			=
XLIBS2		=
XLIBS		= -lcurses -ltermcap -lm
XLINT		=	$lint
XMV		=	$mv
XOPTIMIZE	=	$optimize
XRM		= 	$rm -f
XAR		= 	$ar
XRANLIB  =   $ranlib
XTOUCH		=	$touch
XPORT        =   $port
XHOST        =   $host
X
X!GROK!THIS!
X
Xcat >>Makefile <<'!NO!SUBS!'
X
X#	Variables you may want to manually edit
X#		If you want debug logging then you'll
X#		want to uncomment the following.
X#DEBUG		=	-DDEBUG
X
X#		If you're on an ACSnet system (Australia) then
X#		you'll want to uncomment the following.
X# DACSNET	=	-DACSNET
X
X#	Other general variables
XBIN		=	../bin
XCFLAGS		=	$(CCFLAGS) $(OPTIMIZE) -I$(INCLDIR) $(DEBUG) $(DACSNET) 
XINCLDIR		=	../hdrs
XLINTFLAGS	=	-I$(INCLDIR)
XSHELL		=	/bin/sh
X
X# 	Lists
XENROL_SRC		=	enrol.c \
X					files_shl.c \
X                    files_rw.c      \
X					files.c \
X					max.c   \
X					perm.c  \
X					rand.c  \
X					shlmisc.c
X
X
XENROL_OBJ		=	enrol.o \
X					files_shl.o \
X                    files_rw.o      \
X					files.o \
X					max.o   \
X					perm.o  \
X					rand.o  \
X					shlmisc.o
X
XMAKEUNIV_SRC    =    makeuniv.c \
X					 makestar.c \
X	                 makeplanet.c \
X                     rand.c \
X	                 perm.c \
X                     files.c
X
XMAKEUNIV_OBJ    =    makeuniv.o \
X					 makestar.o\
X	                 makeplanet.o \
X                     rand.o \
X	                 perm.o \
X                     files.o
X
XRACEGEN_SRCS =       racegen.c
X
XGBRACEGEN_OBJS =	enroll.o \
X					racegen.o   \
X					files_shl.o \
X					files_rw.o  \
X					files.o \
X					max.o   \
X					perm.o  \
X					rand.o  \
X					GB_racegen.o    \
X					shlmisc.o
X
X
XPSMAP_SRCS =         psmap.c
X 
XPSMAP_OBJS =         psmap.o
X
XEXSHIP_SRCS =		 exship.c
X
XEXSHIP_OBJS =        exship.o
X
X# Standard targets
Xall:		enrol makeuniv racegen psmap exship
X
X#	Dependencies and rules for compiling C programs
Xenrol:	$& $(ENROL_OBJ)
X		$(CC) $(LFLAGS) -o $@ $(ENROL_OBJ) $(LIBS) 
X
Xmakeuniv:	$& $(MAKEUNIV_OBJ)
X		$(CC) $(LFLAGS) -o $@ $(MAKEUNIV_OBJ) $(LIBS)
X
Xpsmap:	$& $(PSMAP_OBJS)
X		$(CC) $(LFLAGS) -o $@ $(PSMAP_OBJS)
X
Xexship:	$& $(EXSHIP_OBJS)
X		$(CC) $(LFLAGS) -o $@ $(EXSHIP_OBJS)
X
Xracegen.o:	racegen.c
X		$(CC) $(CFLAGS) -DENROLL racegen.c -c
XGBracegen: $(GBRACEGEN_OBJS)
X		$(CC) -o racegen $(GBRACEGEN_OBJS) -lm
X
Xclean:
X	rm -f $(ENROL_OBJ) $(MAKEUNIV_OBJ) $(RACEGEN_OBJS) $(PSMAP_OBJS)
X	rm -f  $(EXSHIP_OBJS) exship psmap enrol makeuniv racegen
X
Xinstall:
X	install enrol $(BIN)
X	install makeuniv $(BIN)
X	install racegen $(BIN)
X	install psmap $(BIN)
X	install exship $(BIN)
X
X
X!NO!SUBS!
END_OF_FILE
if test 3236 -ne `wc -c <'utils/Makefile.SH'`; then
    echo shar: \"'utils/Makefile.SH'\" unpacked with wrong size!
fi
# end of 'utils/Makefile.SH'
fi
if test -f 'utils/README_EXSHIP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/README_EXSHIP'\"
else
echo shar: Extracting \"'utils/README_EXSHIP'\" \(2615 characters\)
sed "s/^X//" >'utils/README_EXSHIP' <<'END_OF_FILE'
X	This is a small utility to examine the ship database for Galactic
XBloodshed.  It can be used two ways:
X
X	a: run exship with no arguments, and it will scan through the entire
X	   database, looking for ships whose cargo exceeds the maximum allowed.
X
X	b: run exship with a ship_number and it will display a more verbose
X	   listing of the ships.  
X
X	The following are sample outputs from both cases...
X
X	tensha%: exship
X	Number of ships in database is 5
X	Problem with ship number 1
X                Owner: 1
X                Governor: 0
X                Name: Tester
X                Type: @
X
X                popn: 10         max_popn: 10:
X                troops: 0        max_troops: 10
X         -----> resources: 600   max_resources: 500
X                destruct: 100    max_destruct: 100
X                fuel: 1000       max_fuel: 1000
X                speed: 0         max_speed: 0
X                hanger: 0        max_hanger: 0
X	I found a total of 1 bad ships out of 5
X	All Done
X-----
X	
X  As you can see there is a problem with the ship [denoted by the ----->]
X  in which the ship has more resources loaded then it should have.  It also
X  at the top of the screen will display the number of ships in the database.
X
X
X  When run with a argument, the following is the output:
X
X	tensha%: exship 1
X	Number of ships in database is 5
X	Ship Number: 1  Ship Type: @    Ship Owner: 1   Ship Governor 0
X	Ship Name: Tester
X
X	Crew: 10          Troops: 0             Armor: 20
X	Size: 25          Base Mass: 100.0      Base Tech: 100.0
X	Destruct: 100     Resources: 600        Crystals: 0
X	Fuel: 4.1f
X
X	Guns:   Primary: 10 L
X        Secondary:  10 L
X
X	Nextship: 2              (ALIVE)
X	All Done
X
X-----
X	
X	When run with n argument, it displays a short formatted output of
Xthe ship.
X
X
X-----
X
X	Compliling information:
X
X	This program has only been tested on a Suns running Sun OS 4.1.1, and
X	compiled succesfully with the Sun compilier and gcc 1.42.
X
X	compile with the following line:
X
X	gcc -I/work/GB/hdrs -g -o exship exship.c	
X
X	but change /work/GB/hdrs to be the location where the compiler can
X	find the ships.h and shipdata.h files. (these files are part of the GB
X	release)
X
X
X	This is something I hacked together very very quickly to just fix
X	a few problems with the database.  It is not meant to be a catch all
X	for database problems.   If I have some time in the future, I will
X	add new bells and whistles.  Feel free to modify this source, and if
X	you make any improvements, please email them back to me, so I can 
X	merge them into the next version.
X
X
X	John Paul Deragon
X	deragon@jethro.nyu.edu
X	Fri Jan  1 21:58:49 EST 1993
END_OF_FILE
if test 2615 -ne `wc -c <'utils/README_EXSHIP'`; then
    echo shar: \"'utils/README_EXSHIP'\" unpacked with wrong size!
fi
# end of 'utils/README_EXSHIP'
fi
echo shar: End of archive 20 \(of 21\).
cp /dev/null ark20isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
