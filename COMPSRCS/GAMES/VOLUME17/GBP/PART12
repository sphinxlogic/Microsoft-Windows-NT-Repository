Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i024:  gbp - Galactic Bloodshed+, an empire-like war game, Part12/21
Message-ID: <4552@master.CNA.TEK.COM>
Date: 12 Feb 93 17:31:44 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1649
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1703

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 24
Archive-name: gbp/Part12
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 21)."
# Contents:  misc/daemon.txt user/dock.c user/rst.c user/survey.c
# Wrapped by billr@saab on Fri Feb 12 09:14:27 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'misc/daemon.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/daemon.txt'\"
else
echo shar: Extracting \"'misc/daemon.txt'\" \(3421 characters\)
sed "s/^X//" >'misc/daemon.txt' <<'END_OF_FILE'
X	The Galactic Bloodshed game sequence is controlled by
Xtwo defines in tweakables.h.
X
X	The first is DEFAULT_UPDATE_TIME.  This specifies an interval of
Xminutes between updates.
X
X	The second is MOVES_PER_UPDATE.  This specifies how many movement
Xsegments should be included in each update phase.  An update counts as
Xone movement segment; so, if you set this to 1, there will be zero movement
Xsegments between updates.  Setting it to 3 would give you two evenly spaced
Xmovement segments between the updates.  Any movement segments between updates
Xwill be evenly spaced in terms of time.
X
X	To provide a little randomness into the expected update/movement
Xtime, there are two more defines:  DEFAULT_RANDOM_UPDATE_RANGE
Xand DEFAULT_RANDOM_SEGMENT_RANGE.  A random number of minutes between zero
Xand these values will be added to the "programmed" update/movement time.
X(I'm not exactly sure why this is needed, but the old GB_daemon program
X used to do this, so I left it in).
X
X	The server now keeps track of when the last update/movement time
Xwas using two new files:  DFILE(Update.time) and DFILE(Segment.time).
XThe last modification time of these files indicates the last time of that
Xparticular operation.  In addition, the ascii value in Segment.time specifies
Xwhich movement segment was the last one performed.  If this value is
Xless than MOVES_PER_UPDATE, there are more movement segments to do.
XWhen the server starts up, it looks at these files to determine the next
Xupdate/movement times.  If it determines that the time indicated was in
Xthe past (it was down when it would normally have done an update/movment),
Xit will basically "skip" that time and figure the next time from when it
Xwas started (i.e., the next update time will be DEFAULT_UPDATE_TIME minutes
Xinto the future).
X
X	One other file added was PATH(nogo).  If this file exists, the
Xserver will not do any "automatic" updates/movements.  When the file
Xis removed or does not exist, updates/movements will continue normally.
XI have found it useful to make crontab entries to create/delete this
Xfile on weekend, effectively stopping updates/movements during that time.
X
X	You may still connect to the server and give either the update
Xor movement password to cause one of these things to happen.  This overrides
Xthe existence check for the nogo file (just like the old GB_daemon).
X
X
XCAVEATS
X	- This server modification does away with the need for the GB_daemon
X	  program.  The function provided by the daemon program has been
X	  internalized by the server.
X	- DEFAULT_UPDATE_TIME used to specify hours, not minutes.
X
XHISTORICAL Daemon INFORMATION:
X	The Galactic Bloodshed game sequence is controlled by a
X`daemon' program which updates the positions of ships, planets 
Xand stars at a set time interval (usually 1 to 3 hours, set by the
Xgame master). The growth/depletion of the planetary resources, population,
Xfuel and destructive capacity is monitored and updated by this program.
XBetween updates, players may issue commands, construct ships, initiate
Xattacks and do whatever they see fit with the available commands.
X
X	It isn't necessary to be present at all times, since interstellar
Xtravel takes some time, and it takes several iterations of the daemon to
Xgenerate significant changes in planetary status. It is wise, however,
Xto check up on things from time to time to keep yourself from getting
Xoverrun by some hostile race.
X
XSEE ALSO
X	vote, updates
END_OF_FILE
if test 3421 -ne `wc -c <'misc/daemon.txt'`; then
    echo shar: \"'misc/daemon.txt'\" unpacked with wrong size!
fi
# end of 'misc/daemon.txt'
fi
if test -f 'user/dock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/dock.c'\"
else
echo shar: Extracting \"'user/dock.c'\" \(14652 characters\)
sed "s/^X//" >'user/dock.c' <<'END_OF_FILE'
X#ident  "@(#)dock.c	1.6 2/1/93 "
X/*
X * * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, *
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. * Restrictions in
X * GB_copyright.h. *
X * 
X *  dock.c -- dock a ship *  and..... assault -- a very un-PC version of dock
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X#include <signal.h>
X#include <math.h>
X#include <strings.h>
X
Xvoid            dock(int, int, int, int);
X#include "proto.h"
X
Xvoid 
Xdock(int Playernum, int Governor, int APcount, int Assault)
X{
X	shiptype       *s, *s2, *s3, ship;
X	int             boarders = 0, dam = 0, dam2 = 0, booby = 0;
X	int             ship2no, shipno, what, nextshipno;
X	int             old2owner, old2gov;
X	int             casualties = 0, casualties2 = 0, casualties3 = 0,
X	                casualty_scale = 0;
X	double          fuel, bstrength, b2strength;
X	double          Dist;
X	racetype       *Race, *alien;
X	char            dfire[MAXARGS][COMMANDSIZE];
X
X	if (argn < 3) {
X		notify(Playernum, Governor, "Dock with what?\n");
X		return;
X	} if (argn < 5)
X		what = MIL;
X	else if (Assault) {
X		if (match(args[4], "civilians"))
X			what = CIV;
X		else if (match(args[4], "military"))
X			what = MIL;
X		else {
X			notify(Playernum, Governor, "Assault with what?\n");
X			return;
X		}
X	}
X	nextshipno = start_shiplist(Playernum, Governor, args[1]);
X	while (shipno = do_shiplist(&s, &nextshipno))
X		if (in_list(Playernum, args[1], s, &nextshipno) &&
X		    (!Governor || s->governor == Governor)) {
X			if (Assault && s->type == STYPE_POD) {
X				notify(Playernum, Governor, "Sorry. Pods cannot be used to assault.\n");
X				free(s);
X				continue;
X			}
X			if (!Assault) {
X				if (s->docked || s->whatorbits == LEVEL_SHIP) {
X					sprintf(buf, "%s is already docked.\n", Ship(s));
X					notify(Playernum, Governor, buf);
X					free(s);
X					continue;
X				}
X			} else if (s->docked) {
X				notify(Playernum, Governor, "Your ship is already docked.\n");
X				free(s);
X				continue;
X			} else if (s->whatorbits == LEVEL_SHIP) {
X				notify(Playernum, Governor, "Your ship is landed on another ship.\n");
X				free(s);
X				continue;
X			}
X			if (s->whatorbits == LEVEL_UNIV) {
X				if (!enufAP(Playernum, Governor, Sdata.AP[Playernum - 1], APcount)) {
X					free(s);
X					continue;
X				}
X			} else if (!enufAP(Playernum, Governor, Stars[s->storbits]->AP[Playernum - 1],
X					   APcount)) {
X				free(s);
X				continue;
X			}
X			if (Assault && (what == CIV) && !s->popn) {
X				notify(Playernum, Governor, "You have no crew on this ship to assault with.\n");
X				free(s);
X				continue;
X			} else if (Assault && (what == MIL) && !s->troops) {
X				notify(Playernum, Governor, "You have no troops on this ship to assault with.\n");
X				free(s);
X				continue;
X			}
X			sscanf(args[2] + (args[2][0] == '#'), "%d", &ship2no);
X
X			if (shipno == ship2no) {
X				notify(Playernum, Governor, "You can't dock with yourself!\n");
X				free(s);
X				continue;
X			}
X			if (!getship(&s2, ship2no)) {
X				notify(Playernum, Governor, "The ship wasn't found.\n");
X				free(s);
X				return;
X			}
X			if (!Assault && testship(Playernum, Governor, s2)) {
X				notify(Playernum, Governor,
X				    "You are not authorized to do this.\n");
X				free(s2);
X				free(s);
X				return;
X			}
X			/* Check if ships are on same scope level. Maarten */
X			if (s->whatorbits != s2->whatorbits) {
X				notify(Playernum, Governor, "Those ships are not in the same scope.\n");
X				free(s);
X				free(s2);
X				return;
X			}
X			if (s2->docked || (s2->whatorbits == LEVEL_SHIP)) {
X				sprintf(buf, "%s is already docked.\n", Ship(s2));
X				notify(Playernum, Governor, buf);
X				free(s);
X				free(s2);
X				return;
X			}
X			Dist = sqrt((double) Distsq(s2->xpos, s2->ypos, s->xpos, s->ypos));
X			fuel = 0.05 + Dist * 0.025 * (Assault ? 2.0 : 1.0) * sqrt((double) s->mass);
X
X			if (Dist > DIST_TO_DOCK) {
X				sprintf(buf, "%s must be %.2f or closer to %s.\n",
X					Ship(s), DIST_TO_DOCK, Ship(s2));
X				notify(Playernum, Governor, buf);
X				free(s);
X				free(s2);
X				continue;
X			} else if (s->docked && Assault) {
X				/* first undock the target ship */
X				s->docked = 0;
X				s->whatdest = LEVEL_UNIV;
X				(void) getship(&s3, (int) s->destshipno);
X				s3->docked = 0;
X				s3->whatdest = LEVEL_UNIV;
X				putship(s3);
X				free(s3);
X			}
X			if (fuel > s->fuel) {
X				sprintf(buf, "Not enough fuel.\n");
X				notify(Playernum, Governor, buf);
X				free(s);
X				free(s2);
X				continue;
X			}
X			sprintf(buf, "Distance to %s: %.2f.\n", Ship(s2), Dist);
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "This maneuver will take %.2f fuel (of %.2f.)\n\n", fuel, s->fuel);
X			notify(Playernum, Governor, buf);
X
X			if (s2->docked && !Assault) {
X				sprintf(buf, "%s is already docked.\n", Ship(s2));
X				notify(Playernum, Governor, buf);
X				free(s);
X				free(s2);
X				return;
X			}
X			/* defending fire gets defensive fire */
X			bcopy(s2, &ship, sizeof(shiptype));	/* for reports */
X			if (Assault) {
X				strcpy(dfire[0], args[0]);
X				strcpy(dfire[1], args[1]);
X				strcpy(dfire[2], args[2]);
X				sprintf(args[0], "fire");
X				sprintf(args[1], "#%d", ship2no);
X				sprintf(args[2], "#%d", shipno);
X				fire((int) s2->owner, (int) s2->governor, 0, 3);
X				strcpy(args[0], dfire[0]);
X				strcpy(args[1], dfire[1]);
X				strcpy(args[2], dfire[2]);
X				/*
X				 * retrieve ships again, since battle may
X				 * change ship stats
X				 */
X				free(s);
X				free(s2);
X				(void) getship(&s, shipno);
X				(void) getship(&s2, ship2no);
X				if (!s->alive) {
X					free(s);
X					free(s2);
X					continue;
X				} else if (!s2->alive) {
X					free(s);
X					free(s2);
X					return;
X				}
X			}
X			if (Assault) {
X				alien = races[s2->owner - 1];
X				Race = races[Playernum - 1];
X				if (argn >= 4) {
X					sscanf(args[3], "%d", &boarders);
X					if ((what == MIL) && (boarders > s->troops))
X						boarders = s->troops;
X					else if ((what == CIV) && (boarders > s->popn))
X						boarders = s->popn;
X				} else {
X					if (what == CIV)
X						boarders = s->popn;
X					else if (what == MIL)
X						boarders = s->troops;
X				}
X				if (boarders > s2->max_crew)
X					boarders = s2->max_crew;
X
X				/* Allow assault of crewless ships. */
X				if (s2->max_crew && boarders <= 0) {
X					sprintf(buf, "Illegal number of boarders (%d).\n", boarders);
X					notify(Playernum, Governor, buf);
X					free(s);
X					free(s2);
X					continue;
X				}
X				old2owner = s2->owner;
X				old2gov = s2->governor;
X				if (what == MIL)
X					s->troops -= boarders;
X				else if (what == CIV)
X					s->popn -= boarders;
X				s->mass -= boarders * Race->mass;
X				sprintf(buf, "Boarding strength :%.2f       Defense strength: %.2f.\n",
X					bstrength = boarders * (what == MIL ? 10 * Race->fighters : 1)
X					* .01 * Race->tech
X					* morale_factor((double) (Race->morale - alien->morale)),
X
X					b2strength = (s2->popn + 10 * s2->troops * alien->fighters)
X					* .01 * alien->tech
X					* morale_factor((double) (alien->morale - Race->morale))
X					);
X				notify(Playernum, Governor, buf);
X			}
X			/*
X			 * the ship moves into position, regardless of
X			 * success of attack
X			 */
X			use_fuel(s, fuel);
X			s->xpos = s2->xpos + int_rand(-1, 1);
X			s->ypos = s2->ypos + int_rand(-1, 1);
X			if (s->hyper_drive.on) {
X				s->hyper_drive.on = 0;
X				notify(Playernum, Governor, "Hyper-drive deactivated.\n");
X			}
X			if (Assault) {
X				/*
X				 * if the assaulted ship is docked, undock it
X				 * first
X				 */
X				if (s2->docked && s2->whatdest == LEVEL_SHIP) {
X					(void) getship(&s3, (int) s2->destshipno);
X					s3->docked = 0;
X					s3->whatdest = LEVEL_UNIV;
X					s3->destshipno = 0;
X					putship(s3);
X					free(s3);
X
X					s2->docked = 0;
X					s2->whatdest = LEVEL_UNIV;
X					s2->destshipno = 0;
X				}
X				/* nuke both populations, ships */
X				casualty_scale = MIN(boarders, s2->troops + s2->popn);
X
X				if (b2strength) {	/* otherwise the ship
X							 * surrenders */
X					casualties = int_rand(0, round_rand((double) casualty_scale * (b2strength + 1.0) /
X							(bstrength + 1.0)));
X					casualties = MIN(boarders, casualties);
X					boarders -= casualties;
X
X					dam = int_rand(0, round_rand(25. * (b2strength + 1.0) / (bstrength + 1.0)));
X					dam = MIN(100, dam);
X					s->damage = MIN(100, s->damage + dam);
X					if (s->damage >= 100)
X						kill_ship(Playernum, s);
X
X					casualties2 = int_rand(0, round_rand((double) casualty_scale * (bstrength + 1.0) /
X						       (b2strength + 1.0)));
X					casualties2 = MIN(s2->popn, casualties2);
X					casualties3 = int_rand(0, round_rand((double) casualty_scale * (bstrength + 1.0) /
X						       (b2strength + 1.0)));
X					casualties3 = MIN(s2->troops, casualties3);
X					s2->popn -= casualties2;
X					s2->mass -= casualties2 * alien->mass;
X					s2->troops -= casualties3;
X					s2->mass -= casualties3 * alien->mass;
X					/* (their mass) */
X					dam2 = int_rand(0, round_rand(25. * (bstrength + 1.0) / (b2strength + 1.0)));
X					dam2 = MIN(100, dam2);
X					s2->damage = MIN(100, s2->damage + dam2);
X					if (s2->damage >= 100)
X						kill_ship(Playernum, s2);
X				} else {
X					s2->popn = 0;
X					s2->troops = 0;
X					booby = 0;
X					/* do booby traps */
X					/* check for boobytrapping */
X					if (!s2->max_crew && s2->destruct)
X						booby = int_rand(0, 10 * (int) s2->destruct);
X					booby = MIN(100, booby);
X				}
X
X				if ((!s2->popn && !s2->troops) && s->alive && s2->alive) {
X					/* we got 'em */
X					s->docked = 1;
X					s->whatdest = LEVEL_SHIP;
X					s->destshipno = ship2no;
X
X					s2->docked = 1;
X					s2->whatdest = LEVEL_SHIP;
X					s2->destshipno = shipno;
X					old2owner = s2->owner;
X					old2gov = s2->governor;
X					s2->owner = s->owner;
X					s2->governor = s->governor;
X					if (what == MIL)
X						s2->troops = boarders;
X					else
X						s2->popn = boarders;
X					s2->mass += boarders * Race->mass;	/* our mass */
X					if (casualties2 + casualties3) {
X						/*
X						 * You must kill to get
X						 * morale
X						 */
X						adjust_morale(Race, alien, (int) s2->build_cost);
X					}
X				} else {	/* retreat */
X					if (what == MIL)
X						s->troops += boarders;
X					else if (what == CIV)
X						s->popn += boarders;
X					s->mass += boarders * Race->mass;
X					adjust_morale(alien, Race, (int) Race->fighters);
X				}
X
X				/* races find out about each other */
X				alien->translate[Playernum - 1] = MIN(alien->translate[Playernum - 1] + 5, 100);
X				Race->translate[old2owner - 1] = MIN(Race->translate[old2owner - 1] + 5, 100);
X
X				if (!boarders && (s2->popn + s2->troops))	/* boarding party killed */
X					alien->translate[Playernum - 1] = MIN(alien->translate[Playernum - 1] + 25, 100);
X				if (s2->owner == Playernum)	/* captured ship */
X					Race->translate[old2owner - 1] = MIN(Race->translate[old2owner - 1] + 25, 100);
X				putrace(Race);
X				putrace(alien);
X			} else {
X				s->docked = 1;
X				s->whatdest = LEVEL_SHIP;
X				s->destshipno = ship2no;
X
X				s2->docked = 1;
X				s2->whatdest = LEVEL_SHIP;
X				s2->destshipno = shipno;
X			}
X
X			if (Assault) {
X				sprintf(telegram_buf, "%s ASSAULTED by %s at %s\n",
X				Ship(&ship), Ship(s), prin_ship_orbits(s2));
X				sprintf(buf, "Your damage: %d%%, theirs: %d%%.\n", dam2, dam);
X				strcat(telegram_buf, buf);
X				if (!s2->max_crew && s2->destruct) {
X					sprintf(buf, "(Your boobytrap gave them %d%% damage.)\n",
X						booby);
X					strcat(telegram_buf, buf);
X					sprintf(buf, "Their boobytrap gave you %d%% damage!)\n",
X						booby);
X					notify(Playernum, Governor, buf);
X				}
X				sprintf(buf, "Damage taken:  You: %d%% (now %d%%)\n",
X					dam, s->damage);
X				notify(Playernum, Governor, buf);
X				if (!s->alive) {
X					sprintf(buf, "              YOUR SHIP WAS DESTROYED!!!\n");
X					notify(Playernum, Governor, buf);
X					sprintf(buf, "              Their ship DESTROYED!!!\n");
X					strcat(telegram_buf, buf);
X				}
X				sprintf(buf, "              Them: %d%% (now %d%%)\n",
X					dam2, s2->damage);
X				notify(Playernum, Governor, buf);
X				if (!s2->alive) {
X					sprintf(buf, "              Their ship DESTROYED!!!  Boarders are dead.\n");
X					notify(Playernum, Governor, buf);
X					sprintf(buf, "              YOUR SHIP WAS DESTROYED!!!\n");
X					strcat(telegram_buf, buf);
X				}
X				if (s->alive) {
X					if (s2->owner == Playernum) {
X						sprintf(buf, "CAPTURED!\n");
X						strcat(telegram_buf, buf);
X						sprintf(buf, "VICTORY! the ship is yours!\n");
X						notify(Playernum, Governor, buf);
X						if (boarders) {
X							sprintf(buf, "%d boarders move in.\n", boarders);
X							notify(Playernum, Governor, buf);
X						}
X						capture_stuff(s2);
X					} else if (s2->popn + s2->troops) {
X						sprintf(buf, "The boarding was repulsed; try again.\n");
X						notify(Playernum, Governor, buf);
X						sprintf(buf, "You fought them off!\n");
X						strcat(telegram_buf, buf);
X					}
X				} else {
X					sprintf(buf, "The assault was too much for your bucket of bolts.\n");
X					notify(Playernum, Governor, buf);
X					sprintf(buf, "The assault was too much for their ship..\n");
X					strcat(telegram_buf, buf);
X				}
X				if (s2->alive) {
X					if (s2->max_crew && !boarders) {
X						sprintf(buf, "Oh no! They killed your boarding party to the last man!\n");
X						notify(Playernum, Governor, buf);
X					}
X					if (!s->popn && !s->troops) {
X						sprintf(buf, "You killed all their crew!\n");
X						strcat(telegram_buf, buf);
X					}
X				} else {
X					sprintf(buf, "The assault weakened their ship too much!\n");
X					notify(Playernum, Governor, buf);
X					sprintf(buf, "Your ship was weakened too much!\n");
X					strcat(telegram_buf, buf);
X				}
X				sprintf(buf, "Casualties: Yours: %d mil/%d civ    Theirs: %d %s\n",
X					casualties3, casualties2, casualties, what == MIL ? "mil" : "civ");
X				strcat(telegram_buf, buf);
X				sprintf(buf, "Crew casualties: Yours: %d %s    Theirs: %d mil/%d civ\n",
X					casualties, what == MIL ? "mil" : "civ", casualties3, casualties2);
X				notify(Playernum, Governor, buf);
X				warn(old2owner, old2gov, telegram_buf);
X				sprintf(buf, "%s %s %s at %s.\n", Ship(s),
X					s2->alive ? (s2->owner == Playernum ? "CAPTURED" : "assaulted") :
X					"DESTROYED",
X					Ship(&ship), prin_ship_orbits(s));
X				if (s2->owner == Playernum || !s2->alive)
X					post(buf, COMBAT);
X				notify_star(Playernum, Governor, old2owner,
X					    (int) s->storbits, buf);
X			} else {
X				sprintf(buf, "%s docked with %s.\n", Ship(s), Ship(s2));
X				notify(Playernum, Governor, buf);
X			}
X
X			if (Dir[Playernum - 1][Governor].level == LEVEL_UNIV)
X				deductAPs(Playernum, Governor, APcount, 0, 1);
X			else
X				deductAPs(Playernum, Governor, APcount, Dir[Playernum - 1][Governor].snum, 0);
X
X			s->notified = s2->notified = 0;
X			putship(s);
X			putship(s2);
X			free(s2);
X			free(s);
X		} else
X			free(s);
X}
END_OF_FILE
if test 14652 -ne `wc -c <'user/dock.c'`; then
    echo shar: \"'user/dock.c'\" unpacked with wrong size!
fi
# end of 'user/dock.c'
fi
if test -f 'user/rst.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/rst.c'\"
else
echo shar: Extracting \"'user/rst.c'\" \(17462 characters\)
sed "s/^X//" >'user/rst.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * ship -- report -- stock -- tactical -- stuff on ship
X * 
X * Command "factories" programmed by varneyml@gb.erc.clarkson.edu
X */
X
X#define REPORT	0
X#define STOCK	1
X#define TACTICAL 2
X#define SHIP	3
X#define STATUS	4
X#define WEAPONS	5
X#define FACTORIES 6
X
X#define PLANET 1
X
X#include <ctype.h>
X#include <math.h>
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X
Xextern char     Shipltrs[];
X
Xchar            Caliber[] = {' ', 'L', 'M', 'H'};
Xchar            shiplist[256];
X
Xstatic unsigned char Status, SHip, Stock, Report, Tactical, Weapons, Factories,
X                first;
X
Xstruct reportdata {
X	unsigned char   type;	/* ship or planet */
X	shiptype       *s;
X	planettype     *p;
X	short           n;
X	unsigned char   star;
X	unsigned char   pnum;
X	double          x;
X	double          y;
X};
X
Xracetype       *Race;
Xstruct reportdata *rd;
Xint             enemies_only, who;
X
Xvoid            rst(int, int, int, int);
Xvoid            ship_report(int, int, int, unsigned char[]);
Xvoid            plan_getrships(int, int, int, int);
Xvoid            star_getrships(int, int, int);
Xint             Getrship(int, int, int);
Xvoid            Free_rlist(void);
Xint             listed(int, char *);
X#include "proto.h"
X
Xvoid 
Xrst(int Playernum, int Governor, int APcount, int Rst)
X{
X	int             shipno;
X	reg int         shn, i;
X	int             n_ships, num;
X	unsigned char   Report_types[NUMSTYPES];
X
X	for (i = 0; i < NUMSTYPES; i++)
X		Report_types[i] = 1;
X	enemies_only = 0;
X	Num_ships = 0;
X	first = 1;
X	switch (Rst) {
X	case REPORT:
X		Report = 1;
X		Weapons = Status = Stock = SHip = Tactical = Factories = 0;
X		break;
X	case STOCK:
X		Stock = 1;
X		Weapons = Status = Report = SHip = Tactical = Factories = 0;
X		break;
X	case TACTICAL:
X		Tactical = 1;
X		Weapons = Status = Report = SHip = Stock = Factories = 0;
X		break;
X	case SHIP:
X		SHip = Report = Stock = 1;
X		Tactical = 0;
X		Weapons = Status = Factories = 1;
X		break;
X	case STATUS:
X		Status = 1;
X		Weapons = Report = Stock = Tactical = SHip = Factories = 0;
X		break;
X	case WEAPONS:
X		Weapons = 1;
X		Status = Report = Stock = Tactical = SHip = Factories = 0;
X		break;
X	case FACTORIES:
X		Factories = 1;
X		Status = Report = Stock = Tactical = SHip = Weapons = 0;
X		break;
X	}
X	n_ships = Numships();
X	rd = (struct reportdata *) malloc(sizeof(struct reportdata) *
X				   (n_ships + Sdata.numstars * MAXPLANETS));
X	/* (one list entry for each ship, planet in universe) */
X
X	Race = races[Playernum - 1];
X
X	if (argn == 3) {
X		if (isdigit(args[2][0]))
X			who = atoi(args[2]);
X		else {
X			who = 999;	/* treat args[2] as a list of ship
X					 * types */
X			strcpy(shiplist, args[2]);
X		}
X	} else
X		who = 0;
X
X	if (argn >= 2) {
X		if (*args[1] == '#' || isdigit(*args[1])) {
X			/* report on a couple ships */
X			int             l = 1;
X			while (l < MAXARGS && *args[l] != '\0') {
X				sscanf(args[l] + (*args[l] == '#'), "%d", &shipno);
X				if (shipno > n_ships || shipno < 1) {
X					sprintf(buf, "rst: no such ship #%d \n", shipno);
X					notify(Playernum, Governor, buf);
X					free(rd);
X					return;
X				}
X				(void) Getrship(Playernum, Governor, shipno);
X				num = Num_ships;
X				if (rd[Num_ships - 1].s->whatorbits != LEVEL_UNIV) {
X					star_getrships(Playernum, Governor, (int) rd[num - 1].s->storbits);
X					ship_report(Playernum, Governor, num - 1, Report_types);
X				} else
X					ship_report(Playernum, Governor, num - 1, Report_types);
X				l++;
X			}
X			Free_rlist();
X			return;
X		} else {
X			int             l;
X			l = strlen(args[1]);
X			for (i = 0; i < NUMSTYPES; i++)
X				Report_types[i] = 0;
X
X			while (l--) {
X				i = NUMSTYPES;
X				while (--i && Shipltrs[i] != args[1][l]);
X				if (Shipltrs[i] != args[1][l]) {
X					sprintf(buf, "'%c' -- no such ship letter\n", args[1][l]);
X					notify(Playernum, Governor, buf);
X				} else
X					Report_types[i] = 1;
X			}
X		}
X	}
X	switch (Dir[Playernum - 1][Governor].level) {
X	case LEVEL_UNIV:
X		if (!(Rst == TACTICAL && argn < 2)) {
X			shn = Sdata.ships;
X			while (shn && Getrship(Playernum, Governor, shn))
X				shn = rd[Num_ships - 1].s->nextship;
X
X			for (i = 0; i < Sdata.numstars; i++)
X				star_getrships(Playernum, Governor, i);
X			for (i = 0; i < Num_ships; i++)
X				ship_report(Playernum, Governor, i, Report_types);
X		} else {
X			notify(Playernum, Governor, "You can't do tactical option from universe level.\n");
X			free(rd);	/* nothing allocated */
X			return;
X		}
X		break;
X	case LEVEL_PLAN:
X		plan_getrships(Playernum, Governor, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X		for (i = 0; i < Num_ships; i++)
X			ship_report(Playernum, Governor, i, Report_types);
X		break;
X	case LEVEL_STAR:
X		star_getrships(Playernum, Governor, Dir[Playernum - 1][Governor].snum);
X		for (i = 0; i < Num_ships; i++)
X			ship_report(Playernum, Governor, i, Report_types);
X		break;
X	case LEVEL_SHIP:
X		(void) Getrship(Playernum, Governor, Dir[Playernum - 1][Governor].shipno);
X		ship_report(Playernum, Governor, 0, Report_types);	/* first ship report */
X		shn = rd[0].s->ships;
X		Num_ships = 0;
X
X		while (shn && Getrship(Playernum, Governor, shn))
X			shn = rd[Num_ships - 1].s->nextship;
X
X		for (i = 0; i < Num_ships; i++)
X			ship_report(Playernum, Governor, i, Report_types);
X		break;
X	}
X	Free_rlist();
X}
X
Xvoid 
Xship_report(int Playernum, int Governor, int indx, unsigned char rep_on[])
X{
X	shiptype       *s;
X	planettype     *p;
X	int             shipno;
X	reg int         i, sight, caliber;
X	placetype       where;
X	char            orb[PLACENAMESIZE];
X	char            strng[COMMANDSIZE], locstrn[COMMANDSIZE];
X	char            tmpbuf1[10], tmpbuf2[10], tmpbuf3[10], tmpbuf4[10];
X	double          Dist;
X
X	/* last ship gotten from disk */
X	s = rd[indx].s;
X	p = rd[indx].p;
X	shipno = rd[indx].n;
X
X	/* launched canister, non-owned ships don't show up */
X	if ((rd[indx].type == PLANET && p->info[Playernum - 1].numsectsowned)
X	 || (rd[indx].type != PLANET && s->alive && s->owner == Playernum &&
X	     authorized(Governor, s) &&
X	     rep_on[s->type] && !(s->type == OTYPE_CANIST && !s->docked) &&
X	     !(s->type == OTYPE_GREEN && !s->docked))) {
X		if (rd[indx].type != PLANET && Stock) {
X			if (first) {
X				sprintf(buf, "    #       name        x  hanger   res        des         fuel      crew/mil\n");
X				notify(Playernum, Governor, buf);
X				if (!SHip)
X					first = 0;
X			}
X			sprintf(buf, "%5d %c %14.14s%3u%4u:%-3u%5u:%-5d%5u:%-5d%7.1f:%-6d%u/%u:%d\n",
X				shipno, Shipltrs[s->type],
X				(s->active ? s->name : "INACTIVE"),
X				s->crystals, s->hanger, s->max_hanger,
X				s->resource, Max_resource(s), s->destruct, Max_destruct(s),
X				s->fuel, Max_fuel(s), s->popn, s->troops, s->max_crew);
X			notify(Playernum, Governor, buf);
X		}
X		if (rd[indx].type != PLANET && Status) {
X			if (first) {
X				sprintf(buf, "    #       name       las cew hyp    guns   arm tech spd cost  mass size\n");
X				notify(Playernum, Governor, buf);
X				if (!SHip)
X					first = 0;
X			}
X			sprintf(buf, "%5d %c %14.14s %s%s%s%3u%c/%3u%c%4u%5.0f%4u%5u%7.1f%4u",
X				shipno, Shipltrs[s->type],
X				(s->active ? s->name : "INACTIVE"),
X				s->laser ? "yes " : "    ",
X				s->cew ? "yes " : "    ",
X				s->hyper_drive.has ? "yes " : "    ",
X				s->primary, Caliber[s->primtype], s->secondary, Caliber[s->sectype],
X				Armor(s), s->tech, Max_speed(s), Cost(s), Mass(s), Size(s));
X			notify(Playernum, Governor, buf);
X			if (s->type == STYPE_POD) {
X				sprintf(buf, " (%d)", s->special.pod.temperature);
X				notify(Playernum, Governor, buf);
X			}
X			notify(Playernum, Governor, "\n");
X		}
X		if (rd[indx].type != PLANET && Weapons) {
X			if (first) {
X				sprintf(buf, "    #       name      laser   cew     safe     guns    damage   class\n");
X				notify(Playernum, Governor, buf);
X				if (!SHip)
X					first = 0;
X			}
X			sprintf(buf, "%5d %c %14.14s %s  %3d/%-4d  %4d  %3d%c/%3d%c    %3d%%  %c %s\n",
X				shipno, Shipltrs[s->type],
X				(s->active ? s->name : "INACTIVE"),
X			   s->laser ? "yes " : "    ", s->cew, s->cew_range,
X			    (int) ((1.0 - .01 * s->damage) * s->tech / 4.0),
X				s->primary, Caliber[s->primtype],
X				s->secondary, Caliber[s->sectype],
X				s->damage, s->type == OTYPE_FACTORY ? Shipltrs[s->build_type] : ' ',
X				((s->type == OTYPE_TERRA) ||
X			  (s->type == OTYPE_PLOW)) ? "Standard" : s->class);
X			notify(Playernum, Governor, buf);
X		}
X		if (rd[indx].type != PLANET && Factories && (s->type == OTYPE_FACTORY)) {
X			if (first) {
X				sprintf(buf, "   #    Cost Tech Mass Sz A Crw Ful Crg Hng Dst Sp Weapons Lsr CEWs Range Dmg\n");
X				notify(Playernum, Governor, buf);
X				if (!SHip)
X					first = 0;
X			}
X			if ((s->build_type == 0) || (s->build_type == OTYPE_FACTORY)) {
X				sprintf(buf, "%5d               (No ship type specified yet)                      75% (OFF)", shipno);
X				notify(Playernum, Governor, buf);
X			} else {
X				if (s->primtype)
X					sprintf(tmpbuf1, "%2d%s", s->primary, s->primtype == LIGHT ?
X						"L" : s->primtype == MEDIUM ? "M" : s->primtype == HEAVY ? "H" : "N");
X				else
X					strcpy(tmpbuf1, "---");
X				if (s->sectype)
X					sprintf(tmpbuf2, "%2d%s", s->secondary, s->sectype == LIGHT ?
X						"L" : s->sectype == MEDIUM ? "M" : s->sectype == HEAVY ? "H" : "N");
X				else
X					strcpy(tmpbuf2, "---");
X				if (s->cew)
X					sprintf(tmpbuf3, "%4d", s->cew);
X				else
X					strcpy(tmpbuf3, "----");
X				if (s->cew)
X					sprintf(tmpbuf4, "%5d", s->cew_range);
X				else
X					strcpy(tmpbuf4, "-----");
X				sprintf(buf, "%5d %c%4d%6.1f%5.1f%3d%2d%4d%4d%4d%4d%4d %c%1d %s/%s %s %s %s %02d%%%s\n",
X					shipno, Shipltrs[s->build_type],
X					s->build_cost, s->complexity, s->base_mass, ship_size(s),
X					s->armor, s->max_crew, s->max_fuel, s->max_resource,
X					s->max_hanger, s->max_destruct,
X				    s->hyper_drive.has ? (s->mount ? (s->mounted ? '+' : '-')
X						 : '*') : ' ',
X					s->max_speed, tmpbuf1, tmpbuf2, s->laser ? "yes" : " no",
X					tmpbuf3, tmpbuf4, s->damage,
X					s->damage ? (s->on ? "" : "*") : "");
X				notify(Playernum, Governor, buf);
X			}
X		}
X		if (rd[indx].type != PLANET && Report) {
X			if (first) {
X				sprintf(buf, " #      name       gov dam crew mil  des fuel sp orbits     destination\n");
X				notify(Playernum, Governor, buf);
X				if (!SHip)
X					first = 0;
X			}
X			if (s->docked)
X				if (s->whatdest == LEVEL_SHIP)
X					sprintf(locstrn, "D#%d", s->destshipno);
X				else
X					sprintf(locstrn, "L%2d,%-2d", s->land_x, s->land_y);
X			else if (s->navigate.on)
X				sprintf(locstrn, "nav:%d (%d)", s->navigate.bearing,
X					s->navigate.turns);
X			else
X				strcpy(locstrn, prin_ship_dest(Playernum, Governor, s));
X
X			if (!s->active) {
X				sprintf(strng, "INACTIVE(%d)", s->rad);
X				notify(Playernum, Governor, buf);
X			}
X			sprintf(buf, "%c%-5d %12.12s %2d %3u%5u%4u%5u%5.0f %c%1u %-10s %-18s\n",
X				Shipltrs[s->type], shipno,
X				(s->active ? s->name : strng), s->governor,
X				s->damage, s->popn, s->troops,
X				s->destruct, s->fuel,
X				s->hyper_drive.has ? (s->mount ? (s->mounted ? '+' : '-') : '*') : ' ',
X				s->speed, Dispshiploc_brief(s), locstrn,
X				0);
X			notify(Playernum, Governor, buf);
X		}
X		if (Tactical) {
X			int             fev = 0, fspeed = 0, defense, fdam = 0;
X			double          tech;
X
X			sprintf(buf, "\n  #         name        tech    guns  armor size dest   fuel dam spd evad               orbits\n");
X			notify(Playernum, Governor, buf);
X
X			if (rd[indx].type == PLANET) {
X				tech = Race->tech;
X				/* tac report from planet */
X				sprintf(buf, "(planet)%15.15s%4.0f %4dM           %5u %6u\n",
X				Stars[rd[indx].star]->pnames[rd[indx].pnum],
X					tech, p->info[Playernum - 1].guns,
X					p->info[Playernum - 1].destruct,
X					p->info[Playernum - 1].fuel);
X				notify(Playernum, Governor, buf);
X				caliber = MEDIUM;
X			} else {
X				where.level = s->whatorbits;
X				where.snum = s->storbits;
X				where.pnum = s->pnumorbits;
X				tech = s->tech;
X				caliber = current_caliber(s);
X				if ((s->whatdest != LEVEL_UNIV || s->navigate.on) &&
X				    !s->docked && s->active) {
X					fspeed = s->speed;
X					fev = s->protect.evade;
X				}
X				fdam = s->damage;
X				sprintf(orb, "%30.30s", Dispplace(Playernum, Governor, &where));
X				sprintf(buf, "%3d %c %16.16s %4.0f%3d%c/%3d%c%6d%5d%5u%7.1f%3d%%  %d  %3s%21.22s",
X					shipno, Shipltrs[s->type],
X					(s->active ? s->name : "INACTIVE"),
X					s->tech,
X					s->primary, Caliber[s->primtype],
X					s->secondary, Caliber[s->sectype],
X					s->armor, s->size,
X				    s->destruct, s->fuel, s->damage, fspeed,
X					(fev ? "yes" : "   "),
X					orb);
X				notify(Playernum, Governor, buf);
X				if (landed(s)) {
X					sprintf(buf, " (%d,%d)", s->land_x, s->land_y);
X					notify(Playernum, Governor, buf);
X				}
X				if (!s->active) {
X					sprintf(buf, " INACTIVE(%d)", s->rad);
X					notify(Playernum, Governor, buf);
X				}
X				sprintf(buf, "\n");
X				notify(Playernum, Governor, buf);
X			}
X
X			sight = 0;
X			if (rd[indx].type == PLANET)
X				sight = 1;
X			else if (Sight(s))
X				sight = 1;
X
X			/* tactical display */
X			sprintf(buf, "\n  Tactical: #  own typ        name   rng   (50%%) size spd evade hit  dam  loc\n");
X			notify(Playernum, Governor, buf);
X
X			if (sight)
X				for (i = 0; i < Num_ships; i++) {
X					if (i != indx &&
X					    (Dist = sqrt(Distsq(rd[indx].x, rd[indx].y,
X								rd[i].x, rd[i].y))) < gun_range(Race, rd[indx].s, (rd[indx].type == PLANET)))
X						if (rd[i].type == PLANET) {
X							/*
X							 * tac report at
X							 * planet
X							 */
X							sprintf(buf, " %13s(planet)          %8.0f\n",
X								Stars[rd[i].star]->pnames[rd[i].pnum], Dist);
X							notify(Playernum, Governor, buf);
X						} else if (!who || who == rd[i].s->owner ||
X							   (who == 999 && listed((int) rd[i].s->type, shiplist))) {
X							/* tac report at ship */
X							if ((rd[i].s->owner != Playernum || !authorized(Governor, rd[i].s)) &&
X							    rd[i].s->alive &&
X							    rd[i].s->type != OTYPE_CANIST &&
X							    rd[i].s->type != OTYPE_GREEN) {
X								int             tev = 0,
X								                tspeed = 0,
X								                body = 0,
X								                prob = 0;
X								int             factor = 0;
X								if ((rd[i].s->whatdest != LEVEL_UNIV || rd[i].s->navigate.on)
X								    && !rd[i].s->docked && rd[i].s->active) {
X									tspeed = rd[i].s->speed;
X									tev = rd[i].s->protect.evade;
X								}
X								body = Size(rd[i].s);
X								defense = getdefense(rd[i].s);
X								prob = hit_odds(Dist, &factor, tech, fdam, fev, tev, fspeed, tspeed, body, caliber, defense);
X								if (rd[indx].type != PLANET &&
X								    laser_on(rd[indx].s) && rd[indx].s->focus)
X									prob = prob * prob / 100;
X								sprintf(buf, "%13d %s%2d,%1d %c%14.14s %4.0f  %4d   %4d %d  %3s  %3d%% %3u%%%s",
X									rd[i].n, (isset(races[Playernum - 1]->atwar,
X											rd[i].s->owner)) ? "-" :
X									(isset(races[Playernum - 1]->allied,
X									       rd[i].s->owner)) ? "+" : " ",
X									rd[i].s->owner, rd[i].s->governor,
X									Shipltrs[rd[i].s->type],
X									rd[i].s->name, Dist, factor, body, tspeed, (tev ? "yes" : "   "), prob, rd[i].s->damage,
X									(rd[i].s->active ? "" : " INACTIVE"));
X								if ((enemies_only == 0) || ((enemies_only == 1) && (!isset(races[Playernum - 1]->allied, rd[i].s->owner)))) {
X									notify(Playernum, Governor, buf);
X									if (landed(rd[i].s)) {
X										sprintf(buf, " (%d,%d)", rd[i].s->land_x, rd[i].s->land_y);
X										notify(Playernum, Governor, buf);
X									} else {
X										sprintf(buf, "     ");
X										notify(Playernum, Governor, buf);
X									}
X									sprintf(buf, "\n");
X									notify(Playernum, Governor, buf);
X								}
X							}
X						}
X				}
X		}
X	}
X}
X
X
Xvoid 
Xplan_getrships(int Playernum, int Governor, int snum, int pnum)
X{
X	reg int         shn;
X	planettype     *p;
X
X	getplanet(&(rd[Num_ships].p), snum, pnum);
X	p = rd[Num_ships].p;
X	/* add this planet into the ship list */
X	rd[Num_ships].star = snum;
X	rd[Num_ships].pnum = pnum;
X	rd[Num_ships].type = PLANET;
X	rd[Num_ships].n = 0;
X	rd[Num_ships].x = Stars[snum]->xpos + p->xpos;
X	rd[Num_ships].y = Stars[snum]->ypos + p->ypos;
X	Num_ships++;
X
X	if (p->info[Playernum - 1].explored) {
X		shn = p->ships;
X		while (shn && Getrship(Playernum, Governor, shn))
X			shn = rd[Num_ships - 1].s->nextship;
X	}
X}
X
Xvoid 
Xstar_getrships(int Playernum, int Governor, int snum)
X{
X	reg int         shn;
X	int             i;
X
X	if (isset(Stars[snum]->explored, Playernum)) {
X		shn = Stars[snum]->ships;
X		while (shn && Getrship(Playernum, Governor, shn))
X			shn = rd[Num_ships - 1].s->nextship;
X		for (i = 0; i < Stars[snum]->numplanets; i++)
X			plan_getrships(Playernum, Governor, snum, i);
X	}
X}
X
X/* get a ship from the disk and add it to the ship list we're maintaining. */
Xint 
XGetrship(int Playernum, int Governor, int shipno)
X{
X	if (getship(&(rd[Num_ships].s), shipno)) {
X		rd[Num_ships].type = 0;
X		rd[Num_ships].n = shipno;
X		rd[Num_ships].x = rd[Num_ships].s->xpos;
X		rd[Num_ships].y = rd[Num_ships].s->ypos;
X		Num_ships++;
X		return 1;
X	} else {
X		sprintf(buf, "Getrship: error on ship get (%d).\n", shipno);
X		notify(Playernum, Governor, buf);
X		return 0;
X	}
X}
X
Xvoid 
XFree_rlist(void)
X{
X	reg int         i;
X	for (i = 0; i < Num_ships; i++)
X		if (rd[i].type == PLANET)
X			free(rd[i].p);
X		else
X			free(rd[i].s);
X	free(rd);
X}
X
Xint 
Xlisted(int type, char *string)
X{
X	char           *p;
X
X	for (p = string; *p; p++) {
X		if (Shipltrs[type] == *p)
X			return 1;
X	}
X	return 0;
X}
END_OF_FILE
if test 17462 -ne `wc -c <'user/rst.c'`; then
    echo shar: \"'user/rst.c'\" unpacked with wrong size!
fi
# end of 'user/rst.c'
fi
if test -f 'user/survey.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/survey.c'\"
else
echo shar: Extracting \"'user/survey.c'\" \(15363 characters\)
sed "s/^X//" >'user/survey.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * survey.c -- print out survey for planets
X * 
X * Tue Apr 16 16:34:38 MDT 1991 (Evan Koffler) Added the client_survey and mode
X * parts Thu Apr 25 11:37:56 MDT 1991 Added the ships per sector stuff. Works
X * well.
X * 
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X#include "csp.h"
X#include <strings.h>
X#include <ctype.h>
X
X#define MAX_SHIPS_PER_SECTOR	10
X
Xextern char    *Desnames[], Dessymbols[];
X
Xchar           *Tox[] = {
X	"Stage 0, mild",
X	"Stage 1, mild",
X	"Stage 2, semi-mild",
X	"Stage 3, semi-semi mild",
X	"Stage 4, ecologically unsound",
X	"Stage 5: ecologically unsound",
X	"Stage 6: below birth threshold",
X	"Stage 7: ecologically unstable--below birth threshold",
X	"Stage 8: ecologically poisonous --below birth threshold",
X	"Stage 9: WARNING: nearing 100% toxicity",
X	"Stage 10: WARNING: COMPLETELY TOXIC!!!",
X	"???"
X};
X
Xvoid            survey(int, int, int, int);
Xvoid            repair(int, int, int);
X#include "proto.h"
X
Xvoid 
Xsurvey(int Playernum, int Governor, int APcount, int mode)
X{
X	int             lowx, hix, lowy, hiy, x2;
X	char            d;
X	char            sect_char;
X	sectortype     *s;
X	planettype     *p;
X	int             tindex;
X	placetype       where;
X	double          compat;
X	int             avg_fert, avg_resource;
X	int             crystal_count;
X	racetype       *Race;
X	int             all = 0;/* full survey 1, specific 0 */
X	struct numshipstuff {
X		int             pos;
X		struct shipstuff {
X			int             shipno;
X			char            ltr;
X			unsigned char   owner;
X		}               shipstuffs[MAX_SHIPS_PER_SECTOR];
X	};
X	struct numshipstuff shiplocs[MAX_X][MAX_Y];
X	int             inhere;
X	int             shiplist;
X	shiptype       *shipa;
X	int             i;
X
X	if (argn == 1) {	/* no args */
X		where.level = Dir[Playernum - 1][Governor].level;
X		where.snum = Dir[Playernum - 1][Governor].snum;
X		where.pnum = Dir[Playernum - 1][Governor].pnum;
X	} else {
X		/* they are surveying a sector */
X		if ((isdigit(args[1][0]) && index(args[1], ',') != NULL) ||
X		    (*args[1] == '-') && (all = 1)) {
X			if (Dir[Playernum - 1][Governor].level != LEVEL_PLAN) {
X				sprintf(buf, "There are no sectors here.\n");
X				notify(Playernum, Governor, buf);
X				return;
X			} else {
X				where.level = LEVEL_PLAN;
X				where.snum = Dir[Playernum - 1][Governor].snum;
X				where.pnum = Dir[Playernum - 1][Governor].pnum;
X			}
X		} else {
X			where = Getplace(Playernum, Governor, args[1], 0);
X			if (where.err || where.level == LEVEL_SHIP)
X				return;
X		}
X	}
X
X	Race = races[Playernum - 1];
X
X	if (where.level == LEVEL_PLAN) {
X		getplanet(&p, (int) where.snum, (int) where.pnum);
X
X		compat = compatibility(p, Race);
X
X		if ((isdigit(args[1][0]) && index(args[1], ',') != NULL) || all) {
X			getsmap(Smap, p);
X
X			if (!all) {
X				get4args(args[1], &x2, &hix, &lowy, &hiy);
X				/* ^^^ translate from lowx:hix,lowy:hiy */
X				x2 = MAX(0, x2);
X				hix = MIN(hix, p->Maxx - 1);
X				lowy = MAX(0, lowy);
X				hiy = MIN(hiy, p->Maxy - 1);
X			} else {
X				x2 = 0;
X				hix = p->Maxx - 1;
X				lowy = 0;
X				hiy = p->Maxy - 1;
X			}
X
X			if (!mode) {
X				sprintf(buf, " x,y cond/type  owner race eff mob frt  res  mil popn ^popn xtals\n");
X				notify(Playernum, Governor, buf);
X			}
X			if (mode) {
X				if (all) {
X					sprintf(buf,
X						"%c %d %d %d %s %s %d %d %d %d %d %d %.2f %d\n",
X						CSP_CLIENT, CSP_SURVEY_INTRO,
X						p->Maxx, p->Maxy, Stars[where.snum]->name,
X						Stars[where.snum]->pnames[where.pnum],
X					    p->info[Playernum - 1].resource,
X						p->info[Playernum - 1].fuel,
X					    p->info[Playernum - 1].destruct,
X						p->popn, p->maxpopn, p->conditions[TOXIC],
X						compatibility(p, Race), p->slaved_to);
X					notify(Playernum, Governor, buf);
X				}
X				bzero((struct shipstuff *) shiplocs, sizeof(shiplocs));
X				inhere = p->info[Playernum - 1].numsectsowned;
X				shiplist = p->ships;
X				while (shiplist) {
X					(void) getship(&shipa, shiplist);
X					if (shipa->owner == Playernum &&
X					    (shipa->popn || (shipa->type == OTYPE_PROBE)))
X						inhere = 1;
X					if (shipa->alive && landed(shipa) &&
X					    shiplocs[shipa->land_x][shipa->land_y].pos <
X					    MAX_SHIPS_PER_SECTOR) {
X						shiplocs[shipa->land_x][shipa->land_y].shipstuffs[shiplocs[shipa->land_x][shipa->land_y].pos].shipno = shiplist;
X						shiplocs[shipa->land_x][shipa->land_y].shipstuffs[shiplocs[shipa->land_x][shipa->land_y].pos].owner = shipa->owner;
X						shiplocs[shipa->land_x][shipa->land_y].shipstuffs[shiplocs[shipa->land_x][shipa->land_y].pos].ltr = Shipltrs[shipa->type];
X						shiplocs[shipa->land_x][shipa->land_y].pos++;
X					}
X					shiplist = shipa->nextship;
X					free(shipa);
X				}
X			}
X			for (; lowy <= hiy; lowy++)
X				for (lowx = x2; lowx <= hix; lowx++) {
X					s = &Sector(*p, lowx, lowy);
X					/* if (s->owner==Playernum) */
X					if (!mode) {
X						sprintf(buf, "%2d,%-2d ", lowx, lowy);
X						notify(Playernum, Governor, buf);
X						if ((d = desshow(Playernum, Governor, p, lowx, lowy, Race)) == CHAR_CLOAKED) {
X							sprintf(buf, "?  (    ?    )\n");
X							notify(Playernum, Governor, buf);
X						} else {
X							sprintf(buf,
X								" %c   %c   %6u%5u%4u%4u%4u%5u%5u%5d%6d%s\n",
X								Dessymbols[s->condition], Dessymbols[s->type],
X								s->owner, s->race, s->eff,
X								s->mobilization, s->fert, s->resource, s->troops, s->popn,
X								maxsupport(Race, s, compat, p->conditions[TOXIC]),
X								((s->crystals && (Race->discoveries[D_CRYSTAL]
X										  || Race->God)) ? " yes" : " "));
X							notify(Playernum, Governor, buf);
X						}
X					} else {	/* mode */
X						switch (s->condition) {
X						case SEA:
X							sect_char = CHAR_SEA;
X							break;
X						case LAND:
X							sect_char = CHAR_LAND;
X							break;
X						case MOUNT:
X							sect_char = CHAR_MOUNT;
X							break;
X						case GAS:
X							sect_char = CHAR_GAS;
X							break;
X						case PLATED:
X							sect_char = CHAR_PLATED;
X							break;
X						case ICE:
X							sect_char = CHAR_ICE;
X							break;
X						case DESERT:
X							sect_char = CHAR_DESERT;
X							break;
X						case FOREST:
X							sect_char = CHAR_FOREST;
X							break;
X						default:
X							sect_char = '?';
X							break;
X						}
X						sprintf (buf, "%c %d %d %d %c %c %d %u %u %u %u %d %u %u %u %d",
X                             			CSP_CLIENT, CSP_SURVEY_SECTOR, 
X										lowx, lowy, sect_char,
X                             			desshow(Playernum, Governor, p, lowx, lowy, Race), 
X                             			((s->condition == WASTED)  ? 1 : 0),
X                             			s->owner, s->eff, s->fert, s->mobilization,
X                             			((s->crystals &&
X						  (Race->discoveries[D_CRYSTAL]
X                                		  || Race->God)) ? 1 : 0),
X                             			s->resource, s->popn, s->troops,
X                             			maxsupport (Race,s,compat, p->conditions[TOXIC]));
X						notify(Playernum, Governor, buf);
X
X						if (shiplocs[lowx][lowy].pos && inhere) {
X							notify(Playernum, Governor, ";");
X							for (i = 0;
X							     i < shiplocs[lowx][lowy].pos; i++) {
X								sprintf(buf, " %d %c %u;",
X									shiplocs[lowx][lowy].shipstuffs[i].shipno, shiplocs[lowx][lowy].shipstuffs[i].ltr, shiplocs[lowx][lowy].shipstuffs[i].owner);
X								notify(Playernum, Governor, buf);
X							}
X						}
X						notify(Playernum, Governor, "\n");
X					}
X				}
X			if (mode) {
X				sprintf(buf, "%c %d\n", CSP_CLIENT, CSP_SURVEY_END);
X				notify(Playernum, Governor, buf);
X			}
X		} else {
X			/* survey of planet */
X			sprintf(buf, "%s:\n", Stars[where.snum]->pnames[where.pnum]);
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "gravity   x,y absolute     x,y relative to %s\n",
X				Stars[where.snum]->name);
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "%7.2f   %7.1f,%7.1f   %8.1f,%8.1f\n",
X			      gravity(p), p->xpos + Stars[where.snum]->xpos,
X			p->ypos + Stars[where.snum]->ypos, p->xpos, p->ypos);
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "======== Planetary conditions: ========\n");
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "atmosphere concentrations:\n");
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "     methane %02d%%(%02d%%)     oxygen %02d%%(%02d%%)\n",
X			  p->conditions[METHANE], Race->conditions[METHANE],
X			   p->conditions[OXYGEN], Race->conditions[OXYGEN]);
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "         CO2 %02d%%(%02d%%)   hydrogen %02d%%(%02d%%)      temperature: %3d (%3d)\n",
X				p->conditions[CO2], Race->conditions[CO2],
X			p->conditions[HYDROGEN], Race->conditions[HYDROGEN],
X				p->conditions[TEMP], Race->conditions[TEMP]);
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "    nitrogen %02d%%(%02d%%)     sulfur %02d%%(%02d%%)           normal: %3d\n",
X			p->conditions[NITROGEN], Race->conditions[NITROGEN],
X			    p->conditions[SULFUR], Race->conditions[SULFUR],
X				p->conditions[RTEMP]);
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "      helium %02d%%(%02d%%)      other %02d%%(%02d%%)\n",
X			    p->conditions[HELIUM], Race->conditions[HELIUM],
X			     p->conditions[OTHER], Race->conditions[OTHER]);
X			notify(Playernum, Governor, buf);
X			if ((tindex = p->conditions[TOXIC] / 10) < 0)
X				tindex = 0;
X			else if (tindex > 10)
X				tindex = 11;
X			sprintf(buf, "                     Toxicity: %d%% (%s)\n",
X				p->conditions[TOXIC], Tox[tindex]);
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "Total planetary compatibility: %.2f%%\n",
X				compatibility(p, Race));
X			notify(Playernum, Governor, buf);
X
X			getsmap(Smap, p);
X
X			crystal_count = avg_fert = avg_resource = 0;
X			for (lowx = 0; lowx < p->Maxx; lowx++)
X				for (lowy = 0; lowy < p->Maxy; lowy++) {
X					s = &Sector(*p, lowx, lowy);
X					avg_fert += s->fert;
X					avg_resource += s->resource;
X					if (Race->discoveries[D_CRYSTAL] || Race->God)
X						crystal_count += !!s->crystals;
X				}
X			sprintf(buf, "%29s: %d\n%29s: %d\n%29s: %d\n",
X			"Average fertility", avg_fert / (p->Maxx * p->Maxy),
X				"Average resource", avg_resource / (p->Maxx * p->Maxy),
X				"Crystal sectors", crystal_count);
X			notify(Playernum, Governor, buf);
X			if (LIMITED_RESOURCES) {
X				sprintf(buf, "%29s: %d\n", "Total resource deposits",
X					p->total_resources);
X				notify(Playernum, Governor, buf);
X			}
X			sprintf(buf, "fuel_stock  resource_stock dest_pot.   %s    ^%s\n",
X				Race->Metamorph ? "biomass" : "popltn",
X				Race->Metamorph ? "biomass" : "popltn");
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "%10lu  %14lu %9lu  %7lu%11lu\n",
X				p->info[Playernum - 1].fuel,
X				p->info[Playernum - 1].resource,
X				p->info[Playernum - 1].destruct,
X				p->popn, p->maxpopn);
X			notify(Playernum, Governor, buf);
X			if (p->slaved_to) {
X				sprintf(buf, "This planet ENSLAVED to player %d!\n", p->slaved_to);
X				notify(Playernum, Governor, buf);
X			}
X		}
X		free(p);
X	} else if (where.level == LEVEL_STAR) {
X		sprintf(buf, "Star %s\n", Stars[where.snum]->name);
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "locn: %f,%f\n", Stars[where.snum]->xpos, Stars[where.snum]->ypos);
X		notify(Playernum, Governor, buf);
X		if (Race->God) {
X			for (i = 0; i < Stars[where.snum]->numplanets; i++) {
X				getplanet(&p, (int) where.snum, i);
X				sprintf(buf, "%8d \"%s\"\n", p->sectormappos,
X					Stars[where.snum]->pnames[i]);
X				notify(Playernum, Governor, buf);
X				free(p);
X			}
X		}
X		sprintf(buf, "gravity: %.2f\tstability: ", Stars[where.snum]->gravity);
X		notify(Playernum, Governor, buf);
X
X		if (Race->tech >= TECH_SEE_STABILITY || Race->God) {
X			sprintf(buf, "%d%% (%s)\n",
X				Stars[where.snum]->stability,
X			      Stars[where.snum]->stability < 20 ? "stable" :
X			    Stars[where.snum]->stability < 40 ? "unstable" :
X			   Stars[where.snum]->stability < 60 ? "dangerous" :
X				Stars[where.snum]->stability < 100 ?
X				"WARNING! nova iminent!" :
X				"undergoing nova");
X			notify(Playernum, Governor, buf);
X		} else {
X			sprintf(buf, "(cannot determine)\n");
X			notify(Playernum, Governor, buf);
X		}
X		sprintf(buf, "temperature class (1->10) %d\n", Stars[where.snum]->temperature);
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "%d planets are ", Stars[where.snum]->numplanets);
X		notify(Playernum, Governor, buf);
X		for (x2 = 0; x2 < Stars[where.snum]->numplanets; x2++) {
X			sprintf(buf, "%s ", Stars[where.snum]->pnames[x2]);
X			notify(Playernum, Governor, buf);
X		}
X		sprintf(buf, "\n");
X		notify(Playernum, Governor, buf);
X	} else if (where.level == LEVEL_UNIV) {
X		sprintf(buf, "It's just _there_, you know?\n");
X		notify(Playernum, Governor, buf);
X	} else {
X		sprintf(buf, "Illegal scope.\n");
X		notify(Playernum, Governor, buf);
X	}
X}				/* end survey */
X
Xvoid 
Xrepair(int Playernum, int Governor, int APcount)
X{
X	int             lowx, hix, lowy, hiy, x2, sectors, cost;
X	sectortype     *s;
X	planettype     *p;
X	placetype       where;
X	racetype       *Race;
X
X	if (!control(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum])) {
X		notify(Playernum, Governor, "You are not authorized to do that here.\n");
X		return;
X	}
X	if (argn == 1) {	/* no args */
X		where.level = Dir[Playernum - 1][Governor].level;
X		where.snum = Dir[Playernum - 1][Governor].snum;
X		where.pnum = Dir[Playernum - 1][Governor].pnum;
X	} else {
X		/* repairing a sector */
X		if (isdigit(args[1][0]) && index(args[1], ',') != NULL) {
X			if (Dir[Playernum - 1][Governor].level != LEVEL_PLAN) {
X				sprintf(buf, "There are no sectors here.\n");
X				notify(Playernum, Governor, buf);
X				return;
X			} else {
X				where.level = LEVEL_PLAN;
X				where.snum = Dir[Playernum - 1][Governor].snum;
X				where.pnum = Dir[Playernum - 1][Governor].pnum;
X			}
X		} else {
X			where = Getplace(Playernum, Governor, args[1], 0);
X			if (where.err || where.level == LEVEL_SHIP)
X				return;
X		}
X	}
X
X	Race = races[Playernum - 1];
X
X	if (where.level == LEVEL_PLAN) {
X		getplanet(&p, (int) where.snum, (int) where.pnum);
X		if (!p->info[Playernum - 1].numsectsowned) {
X			notify(Playernum, Governor, "You don't own any sectors on this planet.\n");
X			free(p);
X			return;
X		}
X		getsmap(Smap, p);
X		if (isdigit(args[1][0]) && index(args[1], ',') != NULL) {
X			get4args(args[1], &x2, &hix, &lowy, &hiy);
X			/* ^^^ translate from lowx:hix,lowy:hiy */
X			x2 = MAX(0, x2);
X			hix = MIN(hix, p->Maxx - 1);
X			lowy = MAX(0, lowy);
X			hiy = MIN(hiy, p->Maxy - 1);
X		} else {
X			/* repair entire planet */
X			x2 = 0;
X			hix = p->Maxx - 1;
X			lowy = 0;
X			hiy = p->Maxy - 1;
X		}
X		sectors = 0;
X		cost = 0;
X
X		for (; lowy <= hiy; lowy++)
X			for (lowx = x2; lowx <= hix; lowx++) {
X				if (p->info[Playernum - 1].resource >= SECTOR_REPAIR_COST) {
X					s = &Sector(*p, lowx, lowy);
X					if (s->condition == WASTED &&
X					    (s->owner == Playernum || !s->owner)) {
X						s->condition = s->type;
X						s->fert = MIN(100, s->fert + 20);
X						p->info[Playernum - 1].resource -= SECTOR_REPAIR_COST;
X						cost += SECTOR_REPAIR_COST;
X						sectors += 1;
X						putsector(s, p, lowx, lowy);
X					}
X				}
X			}
X		putplanet(p, (int) where.snum, (int) where.pnum);
X		free(p);
X
X		sprintf(buf, "%d sectors repaired at a cost of %d resources.\n", sectors, cost);
X		notify(Playernum, Governor, buf);
X	} else {
X		sprintf(buf, "scope must be a planet.\n");
X		notify(Playernum, Governor, buf);
X	}
X}
X
END_OF_FILE
if test 15363 -ne `wc -c <'user/survey.c'`; then
    echo shar: \"'user/survey.c'\" unpacked with wrong size!
fi
# end of 'user/survey.c'
fi
echo shar: End of archive 12 \(of 21\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
