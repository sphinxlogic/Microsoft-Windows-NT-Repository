Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i027:  gbp - Galactic Bloodshed+, an empire-like war game, Part15/21
Message-ID: <4555@master.CNA.TEK.COM>
Date: 12 Feb 93 17:32:25 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1703
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1706

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 27
Archive-name: gbp/Part15
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 15 (of 21)."
# Contents:  user/Makefile.SH user/build.c1 user/scrap.c
#   utils/makestar.c utils/makeuniv.c
# Wrapped by billr@saab on Fri Feb 12 09:14:28 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'user/Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/Makefile.SH'\"
else
echo shar: Extracting \"'user/Makefile.SH'\" \(10992 characters\)
sed "s/^X//" >'user/Makefile.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X    if test ! -f config.sh; then
X	ln ../config.sh . || \
X	ln ../../config.sh . || \
X	ln ../../../config.sh . || \
X	(echo "Can't find config.sh."; exit 1)
X    fi
X    . ./config.sh
X    ;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
X
Xecho "Extracting user/Makefile (with variable substitutions)"
Xcat >Makefile <<!GROK!THIS!
X#
X#  user level Makefile for the GB+ program
X#  This makefile will make the commands library routines
X#
X# Bug reports, patches, comments, suggestions should be sent to:
X#
X#	John Deragon deragon@jethro.cs.nyu.edu
X#
X# Revision 1.1  93/01/28 jpd
X# 
X#
X# Variables
X#	Variables established by Configure
XCC		=	$cc
XCCFLAGS		=	$ccflags $xencf
XCHGRP		=	$chgrp
XCHMOD		=	$chmod
XCP		=	$cp
XDEST		=	$bin
XECHO		=	$echo
XLFLAGS		=	$ldflags 
XLIB		=	$lib
XLIB2		= 	$libs
XLIBS		=	$termlib 
XLINT		=	$lint
XMV		=	$mv
XOPTIMIZE	=	$optimize
XRM		= 	$rm -f
XAR		= 	$ar
XRANLIB  =   $ranlib
XTOUCH		=	$touch
XPORT        =   $port
XHOST        =   $host
X
X!GROK!THIS!
X
Xcat >>Makefile <<'!NO!SUBS!'
X
X#	Variables you may want to manually edit
X#		If you want debug logging then you'll
X#		want to uncomment the following.
X#DEBUG		=	-DDEBUG
X
X#		If you're on an ACSnet system (Australia) then
X#		you'll want to uncomment the following.
X# DACSNET	=	-DACSNET
X
X#	Other general variables
XBIN		=	../bin
XCFLAGS		=	$(CCFLAGS) $(OPTIMIZE) -I$(INCLDIR) $(DEBUG) $(DACSNET) 
XINCLDIR		=	../hdrs
XLINTFLAGS	=	-I$(INCLDIR)
XSHELL		=	/bin/sh
XARFLAGS     =   cq
XLIBTARGET   =   libuser.a
X
X# 	Lists
XUSER_SRC		=	analysis.c \
X					autoreport.c \
X					autoshoot.c \
X					build.c \
X					capital.c \
X					capture.c \
X					cs.c \
X					declare.c \
X					dissolve.c \
X					dock.c \
X					enslave.c \
X					examine.c \
X					explore.c \
X					fire.c \
X					fuel.c \
X					guardian.c \
X					land.c \
X					launch.c \
X					load.c \
X					map.c \
X					mobiliz.c \
X					move.c \
X					name.c \
X					orbit.c \
X					order.c \
X					power.c \
X					prof.c \
X					relation.c \
X					rst.c \
X					scrap.c \
X					shootblast.c \
X					survey.c \
X					tech.c \
X					tele.c \
X					togg.c \
X					toxi.c \
X					vict.c  \
X					sche.c \
X					help.c \
X					chan.c \
X					zoom.c
X
XUSER_OBJ		=	analysis.o \
X					autoreport.o \
X					autoshoot.o \
X					build.o \
X					capital.o \
X					capture.o \
X					cs.o \
X					declare.o \
X					dissolve.o \
X					dock.o \
X					enslave.o \
X					examine.o \
X					explore.o \
X					fire.o \
X					fuel.o \
X					guardian.o \
X					land.o \
X					launch.o \
X					load.o \
X					map.o \
X					mobiliz.o \
X					move.o \
X					name.o \
X					orbit.o \
X					order.o \
X					power.o \
X					prof.o \
X					relation.o \
X					rst.o \
X					scrap.o \
X					shootblast.o \
X					survey.o \
X					tech.o \
X					tele.o \
X					togg.o \
X					toxi.o \
X					vict.o  \
X					sche.o \
X					help.o \
X					chan.o \
X					zoom.o
X
X
X# Standard targets
Xall:		libuser.a
X
X#	Dependencies and rules for compiling C programs
Xlibuser.a:	$& $(USER_OBJ)
X		$(AR) $(ARFLAGS) $(LIBTARGET) $(USER_OBJ)
X		$(RANLIB) $(LIBTARGET)
X
Xobjects:	$& $(USER_OBJ)
X
Xclean:	
X		$(RM) $(USER_OBJ)
X# DO NOT DELETE THIS LINE -- make depend depends on it.
Xanalysis.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xanalysis.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xanalysis.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h
Xanalysis.o: ../hdrs/proto.h
Xautoreport.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xautoreport.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/proto.h
Xautoreport.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h
Xautoshoot.o: ../hdrs/vars.h ../hdrs/files.h ../hdrs/tweakables.h
Xautoshoot.o: ../hdrs/config.h ../hdrs/ships.h
Xautoshoot.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/doturn.h
Xautoshoot.o: ../hdrs/buffers.h ../hdrs/proto.h
Xbuild.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xbuild.o: ../hdrs/tweakables.h ../hdrs/config.h 
Xbuild.o: ../hdrs/ships.h ../hdrs/races.h ../hdrs/shipdata.h
Xbuild.o: ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xcapital.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xcapital.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xcapital.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xcapture.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xcapture.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xcapture.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xchan.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xchan.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/races.h
Xchan.o: ../hdrs/buffers.h ../hdrs/power.h ../hdrs/proto.h
Xcs.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xcs.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xcs.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xdeclare.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xdeclare.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xdeclare.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xdissolve.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xdissolve.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xdissolve.o: ../hdrs/races.h ../hdrs/doturn.h ../hdrs/power.h
Xdissolve.o: ../hdrs/buffers.h ../hdrs/proto.h
Xdock.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xdock.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xdock.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xenslave.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xenslave.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xenslave.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xexamine.o: ../hdrs/GB_copyright.h ../hdrs/vars.h
Xexamine.o: ../hdrs/files.h ../hdrs/tweakables.h ../hdrs/config.h
Xexamine.o: ../hdrs/ships.h ../hdrs/races.h
Xexamine.o: ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xexplore.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xexplore.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xexplore.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xfire.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xfire.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xfire.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h
Xfuel.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xfuel.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xfuel.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/proto.h
Xhelp.o: ../hdrs/vars.h ../hdrs/files.h
Xhelp.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/buffers.h
Xland.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xland.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xland.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xlaunch.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xlaunch.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xlaunch.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xload.o: ../hdrs/GB_copyright.h ../hdrs/vars.h
Xload.o: ../hdrs/files.h ../hdrs/tweakables.h ../hdrs/config.h
Xload.o: ../hdrs/ships.h ../hdrs/races.h ../hdrs/power.h
Xload.o: ../hdrs/buffers.h ../hdrs/proto.h
Xmap.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xmap.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xmap.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xmobiliz.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xmobiliz.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xmobiliz.o: ../hdrs/buffers.h ../hdrs/races.h ../hdrs/power.h ../hdrs/proto.h
Xmove.o: ../hdrs/GB_copyright.h ../hdrs/vars.h
Xmove.o: ../hdrs/files.h ../hdrs/tweakables.h ../hdrs/config.h
Xmove.o: ../hdrs/ships.h ../hdrs/races.h ../hdrs/power.h
Xmove.o: ../hdrs/buffers.h ../hdrs/proto.h
Xname.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xname.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/races.h
Xname.o: ../hdrs/power.h ../hdrs/ships.h ../hdrs/buffers.h ../hdrs/proto.h
Xorbit.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xorbit.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xorbit.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xorder.o: ../hdrs/GB_copyright.h ../hdrs/vars.h
Xorder.o: ../hdrs/files.h ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xorder.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xpower.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xpower.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xpower.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xprof.o: ../hdrs/GB_copyright.h
Xprof.o: ../hdrs/vars.h ../hdrs/files.h ../hdrs/tweakables.h ../hdrs/config.h
Xprof.o: ../hdrs/races.h ../hdrs/ships.h ../hdrs/buffers.h ../hdrs/proto.h
Xrelation.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xrelation.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/races.h
Xrelation.o: ../hdrs/ships.h ../hdrs/buffers.h ../hdrs/proto.h
Xrst.o: ../hdrs/GB_copyright.h ../hdrs/vars.h
Xrst.o: ../hdrs/files.h ../hdrs/tweakables.h ../hdrs/config.h
Xrst.o: ../hdrs/ships.h ../hdrs/races.h ../hdrs/power.h
Xrst.o: ../hdrs/buffers.h ../hdrs/proto.h
Xsche.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xsche.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/buffers.h
Xscrap.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xscrap.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xscrap.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h
Xshootblast.o: ../hdrs/GB_copyright.h ../hdrs/vars.h
Xshootblast.o: ../hdrs/files.h ../hdrs/tweakables.h ../hdrs/config.h
Xshootblast.o: ../hdrs/ships.h ../hdrs/races.h
Xshootblast.o: ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xsurvey.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xsurvey.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xsurvey.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xtech.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xtech.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xtech.o: ../hdrs/power.h ../hdrs/races.h ../hdrs/buffers.h  ../hdrs/proto.h
Xtele.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xtele.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/races.h
Xtele.o: ../hdrs/buffers.h ../hdrs/power.h ../hdrs/ships.h ../hdrs/proto.h
Xtogg.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xtogg.o: ../hdrs/tweakables.h ../hdrs/config.h  ../hdrs/ships.h
Xtogg.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h ../hdrs/proto.h
Xtoxi.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xtoxi.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xtoxi.o: ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h  ../hdrs/proto.h
Xvict.o: ../hdrs/GB_copyright.h ../hdrs/vars.h
Xvict.o: ../hdrs/files.h ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/proto.h
Xvict.o: ../hdrs/ships.h ../hdrs/races.h ../hdrs/power.h ../hdrs/buffers.h 
Xzoom.o: ../hdrs/GB_copyright.h ../hdrs/vars.h ../hdrs/files.h
Xzoom.o: ../hdrs/tweakables.h ../hdrs/config.h ../hdrs/ships.h
Xzoom.o: ../hdrs/races.h ../hdrs/buffers.h ../hdrs/proto.h
X!NO!SUBS!
END_OF_FILE
if test 10992 -ne `wc -c <'user/Makefile.SH'`; then
    echo shar: \"'user/Makefile.SH'\" unpacked with wrong size!
fi
# end of 'user/Makefile.SH'
fi
if test -f 'user/build.c1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/build.c1'\"
else
echo shar: Extracting \"'user/build.c1'\" \(10636 characters\)
sed "s/^X//" >'user/build.c1' <<'END_OF_FILE'
X#ident  "@(#)build.c	1.7 2/1/93 "
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h build -- build a ship Mon Apr 15 02:07:08 MDT 1991
X * Reformatted the 'make' command when at Factory scope. Evan Koffler
X */
X
X#include "GB_copyright.h"
X
X#include <math.h>
X#include <curses.h>
X#include <setjmp.h>
X#include <signal.h>
X#include <strings.h>
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X
Xextern int      ShipVector[];
X
Xvoid            upgrade(int, int, int);
Xvoid            make_mod(int, int, int, int);
Xvoid            build(int, int, int);
Xint             getcount(int, char *);
Xint             can_build_at_planet(int, int, startype *, planettype *);
Xint             get_build_type(char *);
Xint             can_build_this(int, racetype *, char *);
Xint             can_build_on_ship(int, racetype *, shiptype *, char *);
Xint 
Xcan_build_on_sector(int, racetype *, planettype *, sectortype *, int, int,
X		    char *);
Xint             build_at_ship(int, int, racetype *, shiptype *, int *, int *);
Xvoid 
Xautoload_at_planet(int, shiptype *, planettype *, sectortype *, int *,
X		   double *);
Xvoid            autoload_at_ship(int, shiptype *, shiptype *, int *, double *);
Xvoid            initialize_new_ship(int, int, racetype *, shiptype *, double, int);
Xvoid 
Xcreate_ship_by_planet(int, int, racetype *, shiptype *, planettype *,
X		      int, int, int, int);
Xvoid 
Xcreate_ship_by_ship(int, int, racetype *, int, startype *, planettype *,
X		    shiptype *, shiptype *);
Xdouble          getmass(shiptype *);
Xint             ship_size(shiptype *);
Xdouble          cost(shiptype *);
Xvoid            system_cost(double *, double *, int, int);
Xdouble          complexity(shiptype *);
Xvoid            Getship(shiptype *, int, racetype *);
Xvoid            Getfactship(shiptype *, shiptype *);
Xint             Shipcost(int, racetype *);
Xvoid            sell(int, int, int);
Xvoid            bid(int, int, int);
Xint             shipping_cost(int, int, double *, int);
X#include "proto.h"
X
X/* upgrade ship characteristics */
Xvoid 
Xupgrade(int Playernum, int Governor, int APcount)
X{
X	int             value, oldcost, newcost, netcost;
X	shiptype        ship, *dirship, *s2;
X	double          complex;
X	racetype       *Race;
X
X	if (Dir[Playernum - 1][Governor].level != LEVEL_SHIP) {
X		notify(Playernum, Governor,
X		       "You have to change scope to the ship you wish to upgrade.\n");
X		return;
X	}
X	if (!getship(&dirship, Dir[Playernum - 1][Governor].shipno)) {
X		sprintf(buf, "Illegal dir value.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	if (testship(Playernum, Governor, dirship)) {
X		free(dirship);
X		return;
X	}
X	if (dirship->damage) {
X		notify(Playernum, Governor, "You cannot upgrade damaged ships.\n");
X		free(dirship);
X		return;
X	}
X	if (dirship->type == OTYPE_FACTORY) {
X		notify(Playernum, Governor, "You can't upgrade factories.\n");
X		free(dirship);
X		return;
X	}
X	Race = races[Playernum - 1];
X	bcopy(dirship, &ship, sizeof(shiptype));
X
X	if (argn == 3)
X		sscanf(args[2], "%d", &value);
X	else
X		value = 0;
X
X	if (value < 0) {
X		notify(Playernum, Governor, "That's a ridiculous setting.\n");
X		free(dirship);
X		return;
X	}
X	if (Shipdata[dirship->build_type][ABIL_MOD]) {
X		if (match(args[1], "armor")) {
X			ship.armor = MAX(dirship->armor, MIN(value, 100));
X		} else if (match(args[1], "crew")
X			   && Shipdata[dirship->build_type][ABIL_MAXCREW]) {
X			ship.max_crew = MAX(dirship->max_crew, MIN(value, 10000));
X		} else if (match(args[1], "cargo")
X			   && Shipdata[dirship->build_type][ABIL_CARGO]) {
X			ship.max_resource = MAX(dirship->max_resource, MIN(value, 10000));
X		} else if (match(args[1], "hanger")
X			   && Shipdata[dirship->build_type][ABIL_HANGER]) {
X			ship.max_hanger = MAX(dirship->max_hanger, MIN(value, 10000));
X		} else if (match(args[1], "fuel")
X			   && Shipdata[dirship->build_type][ABIL_FUELCAP]) {
X			ship.max_fuel = MAX(dirship->max_fuel, MIN(value, 10000));
X		} else if (match(args[1], "mount")
X			   && Shipdata[dirship->build_type][ABIL_MOUNT]
X			   && !dirship->mount) {
X			if (!Crystal(Race)) {
X				notify(Playernum, Governor,
X				       "Your race does not now how to utilize crystal power yet.\n");
X				free(dirship);
X				return;
X			}
X			ship.mount = !ship.mount;
X		} else if (match(args[1], "destruct")
X			   && Shipdata[dirship->build_type][ABIL_DESTCAP]) {
X			ship.max_destruct = MAX(dirship->max_destruct, MIN(value, 10000));
X		} else if (match(args[1], "speed")
X			   && Shipdata[dirship->build_type][ABIL_SPEED]) {
X			ship.max_speed = MAX(dirship->max_speed, MAX(1, MIN(value, 9)));
X		} else if (match(args[1], "hyperdrive")
X			   && Shipdata[dirship->build_type][ABIL_JUMP]
X			   && !dirship->hyper_drive.has
X			   && Hyper_drive(Race)) {
X			ship.hyper_drive.has = 1;
X		} else if (match(args[1], "primary")
X			   && Shipdata[dirship->build_type][ABIL_PRIMARY]) {
X			if (match(args[2], "strength")) {
X				if (ship.primtype == NONE) {
X					notify(Playernum, Governor, "No caliber defined.\n");
X					free(dirship);
X					return;
X				}
X				ship.primary = atoi(args[3]);
X				ship.primary = MAX(ship.primary, dirship->primary);
X			} else if (match(args[2], "caliber")) {
X				if (match(args[3], "light"))
X					ship.primtype = MAX(LIGHT, dirship->primtype);
X				else if (match(args[3], "medium"))
X					ship.primtype = MAX(MEDIUM, dirship->primtype);
X				else if (match(args[3], "heavy"))
X					ship.primtype = MAX(HEAVY, dirship->primtype);
X				else {
X					notify(Playernum, Governor, "No such caliber.\n");
X					free(dirship);
X					return;
X				}
X				ship.primtype = MIN(Shipdata[dirship->build_type][ABIL_PRIMARY],
X						    ship.primtype);
X			} else {
X				notify(Playernum, Governor, "No such gun characteristic.\n");
X				free(dirship);
X				return;
X			}
X		} else if (match(args[1], "secondary")
X			 && Shipdata[dirship->build_type][ABIL_SECONDARY]) {
X			if (match(args[2], "strength")) {
X				if (ship.sectype == NONE) {
X					notify(Playernum, Governor, "No caliber defined.\n");
X					free(dirship);
X					return;
X				}
X				ship.secondary = atoi(args[3]);
X				ship.secondary = MAX(ship.secondary, dirship->secondary);
X			} else if (match(args[2], "caliber")) {
X				if (match(args[3], "light"))
X					ship.sectype = MAX(LIGHT, dirship->sectype);
X				else if (match(args[3], "medium"))
X					ship.sectype = MAX(MEDIUM, dirship->sectype);
X				else if (match(args[3], "heavy"))
X					ship.sectype = MAX(HEAVY, dirship->sectype);
X				else {
X					notify(Playernum, Governor, "No such caliber.\n");
X					free(dirship);
X					return;
X				}
X				ship.sectype = MIN(Shipdata[dirship->build_type][ABIL_SECONDARY],
X						   ship.sectype);
X			} else {
X				notify(Playernum, Governor, "No such gun characteristic.\n");
X				free(dirship);
X				return;
X			}
X		} else if (match(args[1], "cew")
X			   && Shipdata[dirship->build_type][ABIL_CEW]) {
X			if (!Cew(Race)) {
X				sprintf(buf, "Your race cannot build confined energy weapons.\n");
X				notify(Playernum, Governor, buf);
X				free(dirship);
X				return;
X			}
X			if (!Shipdata[dirship->build_type][ABIL_CEW]) {
X				notify(Playernum, Governor,
X				       "This kind of ship cannot mount confined energy weapons.\n");
X				free(dirship);
X				return;
X			}
X			value = atoi(args[3]);
X			if (match(args[2], "strength")) {
X				ship.cew = value;
X			} else if (match(args[2], "range")) {
X				ship.cew_range = value;
X			} else {
X				notify(Playernum, Governor, "No such option for CEWs.\n");
X				free(dirship);
X				return;
X			}
X		} else if (match(args[1], "laser")
X			   && Shipdata[dirship->build_type][ABIL_LASER]) {
X			if (!Laser(Race)) {
X				sprintf(buf, "Your race cannot build lasers.\n");
X				notify(Playernum, Governor, buf);
X				free(dirship);
X				return;
X			}
X			if (Shipdata[dirship->build_type][ABIL_LASER])
X				ship.laser = 1;
X			else {
X				notify(Playernum, Governor,
X				       "That ship cannot be fitted with combat lasers.\n");
X				free(dirship);
X				return;
X			}
X		} else {
X			notify(Playernum, Governor,
X			       "That characteristic either doesn't exist or can't be modified.\n");
X			free(dirship);
X			return;
X		}
X	} else {
X		notify(Playernum, Governor, "This ship cannot be upgraded.\n");
X		free(dirship);
X		return;
X	}
X
X	/*
X	 * check to see whether this ship can actually be built by this
X	 * player
X	 */
X	if ((complex = complexity(&ship)) > Race->tech) {
X		sprintf(buf, "This upgrade requires an engineering technology of %.1f.\n", complex);
X		notify(Playernum, Governor, buf);
X		free(dirship);
X		return;
X	}
X	/*
X	 * check to see if the new ship will actually fit inside the hanger
X	 * if it is on another ship. Maarten
X	 */
X	if (dirship->whatorbits == LEVEL_SHIP) {
X		(void) getship(&s2, dirship->destshipno);
X		if (s2->max_hanger - (s2->hanger - dirship->size) < ship_size(&ship)) {
X			sprintf(buf, "Not enough free hanger space on %c%d.\n",
X				Shipltrs[s2->type], dirship->destshipno);
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "%d more needed.\n",
X				ship_size(&ship) - (s2->max_hanger - (s2->hanger - dirship->size)));
X			notify(Playernum, Governor, buf);
X			free(s2);
X			free(dirship);
X			return;
X		}
X	}
X	/* compute new ship costs and see if the player can afford it */
X	newcost = Race->God ? 0 : (int) cost(&ship);
X	oldcost = Race->God ? 0 : dirship->build_cost;
X	netcost = Race->God ? 0 : 2 * (newcost - oldcost);	/* upgrade is expensive */
X	if (newcost < oldcost) {
X		notify(Playernum, Governor, "You cannot downgrade ships!\n");
X		free(dirship);
X		return;
X	}
X	if (!Race->God)
X		netcost += !netcost;
X
X	if (netcost > dirship->resource) {
X		sprintf(buf, "Old value %dr   New value %dr\n", oldcost, newcost);
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "You need %d resources on board to make this modification.\n", netcost);
X		notify(Playernum, Governor, buf);
X	} else if (netcost || Race->God) {
X		sprintf(buf, "Old value %dr   New value %dr\n", oldcost, newcost);
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Characteristic modified at a cost of %d resources.\n", netcost);
X		notify(Playernum, Governor, buf);
X		bcopy(&ship, dirship, sizeof(shiptype));
X		dirship->resource -= netcost;
X		if (dirship->whatorbits == LEVEL_SHIP) {
X			s2->hanger -= dirship->size;
X			dirship->size = ship_size(dirship);
X			s2->hanger += dirship->size;
X			putship(s2);
X		}
X		dirship->size = ship_size(dirship);
X		dirship->base_mass = getmass(dirship);
X		dirship->build_cost = Race->God ? 0 : cost(dirship);
X		dirship->complexity = complexity(dirship);
X
X		putship(dirship);
X	} else
X		notify(Playernum, Governor, "You can not make this modification.\n");
X	free(dirship);
X}
X
END_OF_FILE
if test 10636 -ne `wc -c <'user/build.c1'`; then
    echo shar: \"'user/build.c1'\" unpacked with wrong size!
fi
# end of 'user/build.c1'
fi
if test -f 'user/scrap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/scrap.c'\"
else
echo shar: Extracting \"'user/scrap.c'\" \(8063 characters\)
sed "s/^X//" >'user/scrap.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * scrap.c -- turn a ship to junk
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X#include <signal.h>
X
Xvoid            scrap(int, int, int);
X#include "proto.h"
X
Xvoid 
Xscrap(int Playernum, int Governor, int APcount)
X{
X	planettype     *planet;
X	sectortype     *sect;
X	shiptype       *s, *s2;
X	int             shipno, nextshipno;
X	int             scrapval = 0, destval = 0, crewval = 0, xtalval = 0,
X	                troopval = 0;
X	double          fuelval = 0.0;
X	racetype       *Race;
X
X	if (argn < 2) {
X		notify(Playernum, Governor, "Scrap what?\n");
X		return;
X	}
X	nextshipno = start_shiplist(Playernum, Governor, args[1]);
X
X	while (shipno = do_shiplist(&s, &nextshipno))
X		if (in_list(Playernum, args[1], s, &nextshipno) &&
X		    authorized(Governor, s)) {
X			if (s->max_crew && !s->popn) {
X				notify(Playernum, Governor, "Can't scrap that ship - no crew.\n");
X				free(s);
X				continue;
X			}
X			if (s->whatorbits == LEVEL_UNIV) {
X				continue;
X			} else if (!enufAP(Playernum, Governor, Stars[s->storbits]->AP[Playernum - 1], APcount)) {
X				free(s);
X				continue;
X			}
X			if (s->whatorbits == LEVEL_PLAN && s->type == OTYPE_TOXWC) {
X				sprintf(buf, "WARNING: This will release %d toxin points back into the atmosphere!!\n", s->special.waste.toxic);
X				notify(Playernum, Governor, buf);
X			}
X			if (!s->docked) {
X				sprintf(buf, "%s is not landed or docked.\nNo resources can be reclaimed.\n", Ship(s));
X				notify(Playernum, Governor, buf);
X			}
X			if (s->whatorbits == LEVEL_PLAN) {
X				/* wc's release poison */
X				getplanet(&planet, (int) s->storbits, (int) s->pnumorbits);
X				if (landed(s))
X					getsector(&sect, planet, (int) s->land_x, (int) s->land_y);
X			}
X			if (docked(s)) {
X				if (!getship(&s2, (int) (s->destshipno))) {
X					free(s);
X					continue;
X				}
X				if (!(s2->docked && s2->destshipno == s->number) &&
X				    !s->whatorbits == LEVEL_SHIP) {
X					sprintf(buf, "Warning, other ship not docked..\n");
X					notify(Playernum, Governor, buf);
X					free(s);
X					free(s2);
X					continue;
X				}
X			}
X			scrapval = Cost(s) / 2 + s->resource;
X
X			if (s->docked) {
X				sprintf(buf, "%s: original cost: %d\n", Ship(s), Cost(s));
X				notify(Playernum, Governor, buf);
X				sprintf(buf, "         scrap value%s: %d rp's.\n",
X					s->resource ? "(with stockpile) " : "", scrapval);
X				notify(Playernum, Governor, buf);
X
X				if (s->whatdest == LEVEL_SHIP &&
X				s2->resource + scrapval > Max_resource(s2) &&
X				    s2->type != STYPE_SHUTTLE) {
X					scrapval = Max_resource(s2) - s2->resource;
X					sprintf(buf, "(There is only room for %d resources.)\n", scrapval);
X					notify(Playernum, Governor, buf);
X				}
X				if (s->fuel) {
X					sprintf(buf, "Fuel recovery: %.0f.\n", s->fuel);
X					notify(Playernum, Governor, buf);
X					fuelval = s->fuel;
X					if (s->whatdest == LEVEL_SHIP && s2->fuel + fuelval > Max_fuel(s2)) {
X						fuelval = Max_fuel(s2) - s2->fuel;
X						sprintf(buf, "(There is only room for %.2f fuel.)\n", fuelval);
X						notify(Playernum, Governor, buf);
X					}
X				} else
X					fuelval = 0.0;
X
X				if (s->destruct) {
X					sprintf(buf, "Weapons recovery: %d.\n", s->destruct);
X					notify(Playernum, Governor, buf);
X					destval = s->destruct;
X					if (s->whatdest == LEVEL_SHIP && s2->destruct + destval > Max_destruct(s2)) {
X						destval = Max_destruct(s2) - s2->destruct;
X						sprintf(buf, "(There is only room for %d destruct.)\n", destval);
X						notify(Playernum, Governor, buf);
X					}
X				} else
X					destval = 0;
X
X				if (s->popn + s->troops) {
X					if (s->whatdest == LEVEL_PLAN && sect->owner > 0 && sect->owner != Playernum) {
X						sprintf(buf, "You don't own this sector; no crew can be recovered.\n");
X						notify(Playernum, Governor, buf);
X					} else {
X						sprintf(buf, "Population/Troops recovery: %d/%d.\n",
X							s->popn, s->troops);
X						notify(Playernum, Governor, buf);
X						troopval = s->troops;
X						if (s->whatdest == LEVEL_SHIP && s2->troops + troopval > Max_mil(s2)) {
X							troopval = Max_mil(s2) - s2->troops;
X							sprintf(buf, "(There is only room for %d troops.)\n", troopval);
X							notify(Playernum, Governor, buf);
X						}
X						crewval = s->popn;
X						if (s->whatdest == LEVEL_SHIP && s2->popn + crewval > Max_crew(s2)) {
X							crewval = Max_crew(s2) - s2->popn;
X							sprintf(buf, "(There is only room for %d crew.)\n", crewval);
X							notify(Playernum, Governor, buf);
X						}
X					}
X				} else {
X					crewval = 0;
X					troopval = 0;
X				}
X
X				if (s->crystals + s->mounted) {
X					if (s->whatdest == LEVEL_PLAN && sect->owner > 0 && sect->owner != Playernum) {
X						sprintf(buf, "You don't own this sector; no crystals can be recovered.\n");
X						notify(Playernum, Governor, buf);
X					} else {
X						xtalval = s->crystals + s->mounted;
X						if (s->whatdest == LEVEL_SHIP && s2->crystals + xtalval > Max_crystals(s2)) {
X							xtalval = Max_crystals(s2) - s2->crystals;
X							sprintf(buf, "(There is only room for %d crystals.)\n", xtalval);
X							notify(Playernum, Governor, buf);
X						}
X						sprintf(buf, "Crystal recovery: %d.\n", xtalval);
X						notify(Playernum, Governor, buf);
X					}
X				} else
X					xtalval = 0;
X			}
X			/* more adjustments needed here for hanger. Maarten */
X			if (s->whatorbits == LEVEL_SHIP)
X				s2->hanger -= s->size;
X
X			if (s->whatorbits == LEVEL_UNIV)
X				deductAPs(Playernum, Governor, APcount, 0, 1);
X			else
X				deductAPs(Playernum, Governor, APcount, (int) s->storbits, 0);
X
X			Race = races[Playernum - 1];
X			kill_ship(Playernum, s);
X			putship(s);
X			if (docked(s)) {
X#ifdef NEVER
X				fuelval = MIN(fuelval, 1. * Max_fuel(s2) - s2->fuel);
X				destval = MIN(destval, Max_destruct(s2) - s2->destruct);
X				if (s2->type != STYPE_SHUTTLE)	/* Leave scrapval alone
X								 * for shuttles */
X					scrapval = MIN(scrapval, Max_resource(s2) - s2->resource);
X				troopval = MIN(troopval, Max_crew(s2) - s2->troops);
X				crewval = MIN(crewval, Max_crew(s2) - s2->popn);
X				xtalval = MIN(xtalval, Max_crystals(s2) - s2->crystals);
X#endif
X				s2->crystals += xtalval;
X				rcv_fuel(s2, (double) fuelval);
X				rcv_destruct(s2, destval);
X				rcv_resource(s2, scrapval);
X				rcv_troops(s2, troopval, Race->mass);
X				rcv_popn(s2, crewval, Race->mass);
X				/*
X				 * check for docking status in case scrapped
X				 * ship is landed. Maarten
X				 */
X				if (!(s->whatorbits == LEVEL_SHIP)) {
X					s2->docked = 0;	/* undock the surviving
X							 * ship */
X					s2->whatdest = LEVEL_UNIV;
X					s2->destshipno = 0;
X				}
X				putship(s2);
X				free(s2);
X			}
X			if (s->whatorbits == LEVEL_PLAN) {
X				free(planet);	/* This has already been
X						 * allocated */
X				getplanet(&planet, (int) s->storbits, (int) s->pnumorbits);
X				if (landed(s)) {
X					if (sect->owner == Playernum) {
X						sect->popn += troopval;
X						sect->popn += crewval;
X					} else if (sect->owner == 0) {
X						sect->owner = Playernum;
X						sect->popn += crewval;
X						sect->troops += troopval;
X						planet->info[Playernum - 1].numsectsowned++;
X						planet->info[Playernum - 1].popn += crewval;
X						planet->info[Playernum - 1].popn += troopval;
X						sprintf(buf, "Sector %d,%d Colonized.\n", s->land_x, s->land_y);
X						notify(Playernum, Governor, buf);
X					}
X					planet->info[Playernum - 1].resource += scrapval;
X					planet->popn += crewval;
X					planet->info[Playernum - 1].destruct += destval;
X					planet->info[Playernum - 1].fuel += (int) fuelval;
X					planet->info[Playernum - 1].crystals += (int) xtalval;
X					putsector(sect, planet, (int) s->land_x, (int) s->land_y);
X					free(sect);
X				}
X				putplanet(planet, (int) s->storbits, (int) s->pnumorbits);
X				free(planet);
X			}
X			if (landed(s)) {
X				sprintf(buf, "\nScrapped.\n");
X				notify(Playernum, Governor, buf);
X			} else {
X				sprintf(buf, "\nDestroyed.\n");
X				notify(Playernum, Governor, buf);
X			}
X			free(s);
X		} else
X			free(s);
X}
END_OF_FILE
if test 8063 -ne `wc -c <'user/scrap.c'`; then
    echo shar: \"'user/scrap.c'\" unpacked with wrong size!
fi
# end of 'user/scrap.c'
fi
if test -f 'utils/makestar.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/makestar.c'\"
else
echo shar: Extracting \"'utils/makestar.c'\" \(10604 characters\)
sed "s/^X//" >'utils/makestar.c' <<'END_OF_FILE'
X
X/* makestar.c -- create, name, position, and make planetd for a star.
X *
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, 
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h.
X * Restrictions in GB_copyright.h.
X */
X#if 0
XG.O.D. [1] > methane melts at -182C
XG.O.D. [1] > it boils at -164
XG.O.D. [1] > ammonia melts at -78C
XG.O.D. [1] > boils at -33
X#endif
X
X#include <math.h>
X#include "GB_copyright.h"
X#define EXTERN
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"      /* (for power) */
X
X#define PLANET_DIST_MAX 1900.0
X#define PLANET_DIST_MIN 100.0
X
X#define ALLOCATE(type) ((type *) malloc(sizeof(type)))
X#undef malloc
X#undef realloc
X#undef free 
X/* Just in case */
X
Xextern void place_star(startype *star);
Xextern planettype Makeplanet(double, short, int);
X
Xvoid Makestar_init(void) ;
Xchar *NextStarName(void) ;
Xstartype *Makestar(FILE *, FILE *) ;
Xvoid Makeplanet_init(void) ;
Xchar *NextPlanetName(int);
Xvoid rand_list(int, int *);
X
Xextern double double_rand(void);
Xextern int int_rand(int, int);
Xextern int round_rand(double);
Xextern int rposneg(void);
X
X
Xint Numtypes[TYPE_DESERT+2] = {0, };
Xint Resource[TYPE_DESERT+2] = {0, } ;
Xint Numsects[TYPE_DESERT+2][PLATED+1] = {0, } ;
Xint Fertsects[TYPE_DESERT+2][PLATED+1] = {0, } ;
Xchar *Nametypes[] = {"Earth", "Asteroid", "Airless", "Iceball", "Gaseous",
X                       "Water", "Forest", "Desert", " >>"};
Xchar *Namesects[] = {"sea", "land", "mountain", "gaseous", "ice",
X                       "desert", "forest", "plated"};
X
X
X/*
X * Variables found in makeuniv.c:  */
Xextern int autoname_plan ;
Xextern int autoname_star ;
Xextern int minplanets ;
Xextern int maxplanets ;
Xextern int nstars ;
Xextern int planetlesschance ;
Xextern int printplaninfo ;
Xextern int printstarinfo ;
X
X
X
Xint Temperature(double dist, int stemp)
X{
X  return -269 + stemp * 1315 * 40 / (40 + dist) ;
X} 
X
X
Xvoid PrintStatistics(void)
X{
X  int i, j, y ;
X
X  printf("\nPlanet/Sector distribution -\n") ;
X  printf("Type NP     .    *    ^    ~    #    (    -    NS   Avg     Res    Avg  A/Sec\n") ;
X  for (i=0; i<=TYPE_DESERT+1; i++)
X    {
X    printf("%3.3s%4d ", Nametypes[i], Numtypes[i]);
X    if (i < TYPE_DESERT+1)
X      Numtypes[TYPE_DESERT+1] += Numtypes[i] ;
X    for (j=0; j<PLATED; j++)
X      {
X      printf("%5d", Numsects[i][j]) ;
X      Numsects[i][PLATED] += Numsects[i][j] ;
X      if (i <= TYPE_DESERT)
X        Numsects[TYPE_DESERT+1][j] += Numsects[i][j] ;
X      }
X    printf("%6d %5.1f", Numsects[i][PLATED],
X           (1.0 * Numsects[i][PLATED]) / Numtypes[i]) ;
X    printf("%8d %7.1f %5.1f\n", Resource[i], 
X           ((double)Resource[i]) / Numtypes[i], 
X           ((double)Resource[i]) / Numsects[i][PLATED]) ;
X    Resource[TYPE_DESERT+1] += Resource[i] ;
X    }
X  printf("Average Sector Fertility -\n") ;
X  printf("Type NP     .    *    ^    ~    #    (    -    Fert  /Plan  /Sect\n") ;
X  for (i=0; i<=TYPE_DESERT+1; i++)
X    {
X    printf("%3.3s%4d ", Nametypes[i], Numtypes[i]);
X    y = 0 ;
X    for (j=0; j<PLATED; j++)
X      {
X      if (Numsects[i][j])
X        printf("%5.1f", ((double)Fertsects[i][j]) / Numsects[i][j]) ;
X      else
X        printf("    -") ;
X      y += Fertsects[i][j] ;
X      Fertsects[TYPE_DESERT+1][j] += Fertsects[i][j] ;
X      }
X    printf("%8d %7.1f %5.1f\n", y,
X           (1.0 * y) / Numtypes[i], 
X           (1.0 * y) / Numsects[i][PLATED]) ;
X    }
X  }
X
X
Xint ReadNameList(char ss[1000][20], int n, int m, char *filename)
X{
X  register int i, j ;
X  FILE *f = fopen(filename, "r") ;
X
X  if (f == NULL) {
X    printf("Unable to open \"%s\".\n", filename) ;
X    return -1 ;
X    }
X  for (i = 0; i < n; i++) {
X    for (j = 0; j < m; j++)
X      if ('\n' == (ss[i][j] = getc(f))) {
X        ss[i][j] = '\0' ;
X        goto next ;
X        }
X      else if (EOF == ss[i][j])
X        goto out ;
X    ss[i][j-1] = '\0' ;
X    while ('\n' !=  (j = getc(f)))
X      if (EOF == j)
X        goto out ;
X  next: ;
X    }
X out:
X  fclose(f) ;
X  printf("%d names listed in %s\n", i, filename) ;
X  return i ;
X  }
X
X
Xvoid rand_list(int n, int *list) /* mix up the numbers 0 thru n */
X{
X  short nums[1000], i, j, k ;
X  short kk, ii ;
X
X  for (i=0; i<=n; i++)
X    nums[i] = 0 ;
X  for (j=0; j<=n; j++)
X    {
X    i = k = int_rand(0, n) ;
X    while (nums[k] != 0)
X      k += nums[k] ;
X    list[j] = k ;
X    if (k == n)
X      nums[k] = -n, kk = 0 ;
X    else
X      nums[k] = 1, kk = k + 1 ;
X    /* K is now the next position in the list after the most recent number. */
X    /* Go through the list, making each pointer point to k.  */
X    while (i != k)
X      {
X      ii = i + nums[i] ;
X      nums[i] = kk - i ;
X      i = ii ;
X      }
X    }
X  }
X
X
X
Xint numplist, namepcount ;
Xchar PNames[1000][20] ;
Xint planet_list[1000] ;
X
Xvoid Makeplanet_init(void)
X{
X  numplist = ReadNameList(PNames, 1000, 20, PLANETLIST) ;
X  rand_list(numplist, planet_list) ;
X  if (numplist < 0)
X    exit(0) ;
X  namepcount = 0 ;
X}
X
Xchar *NextPlanetName(int i)
X{
X  static char *Numbers[] = {"1","2","3","4","5","6","7","8","9","10","11",
X                              "12","13","14","15" } ;
X  if (autoname_plan && (namepcount < numplist))
X    return PNames[planet_list[namepcount++]] ;
X  else
X    return Numbers[i] ;
X  }
X
X
Xint numslist, namestcount ;
Xchar SNames[1000][20] ;
Xint star_list[1000] ;
X
Xvoid Makestar_init(void)
X{
X  numslist = ReadNameList(SNames, 1000, 20, STARLIST) ;
X  rand_list(numslist, star_list) ;
X  if (numslist < 0)
X    exit(0) ;
X  namestcount = 0;
X  }
X
Xchar *NextStarName(void)
X{
X  static char buf[20] ;
X  int i ;
X
X  if (autoname_star && (namestcount <= numslist))
X    return SNames[star_list[namestcount++]] ;
X  else {
X    printf("Next star name:") ;
X    for (i=0; i<NAMESIZE-4; i++)
X      putchr('.') ;
X    for (i=0; i<NAMESIZE-4; i++)
X      putchr('\010') ;          /* ^H */
X    scanf("%14[^\n]", buf) ;
X    getchr() ;
X    }
X  return buf ;
X  }
X
Xstartype *Makestar(FILE *planetdata, FILE *sectordata)
X{
X  planettype planet ; 
X  int type, roll, temperature, empty_slots ;
X  int i, y, x ;
X  double dist, distmin, distmax, distsep;
X  double angle, xpos, ypos ;
X  startype *Star ;
X
X  /* get names, positions of stars first */
X  Star = ALLOCATE(startype) ;
X  bzero(Star, sizeof(startype)) ;
X  Star->gravity = int_rand(0, int_rand(0,300)) + 
X    int_rand(0, 300) + int_rand(100,400) + int_rand(0, 9) / 10.0 ;
X  Star->temperature = round_rand(Star->gravity/100.0) ;
X/* + int_rand(0,2) - 1 ; */
X  strcpy(Star->name, NextStarName()) ;
X  place_star(Star);
X  if (printstarinfo)
X    printf("Star %s: gravity %1.1f, temp %d\n", 
X           Star->name, Star->gravity, (int)Star->temperature) ;
X  /* 
X   * Generate planets for this star: */
X  Star->numplanets = int_rand(minplanets, maxplanets) ;
X
X  distmin = PLANET_DIST_MIN;
X  for (i=0; i<Star->numplanets; i++)  {
X      distsep = (PLANET_DIST_MAX - distmin)/(double)(Star->numplanets-i);
X      distmax = distmin + distsep;
X      dist = distmin + double_rand()*(distmax - distmin);
X      distmin = dist;
X
X      temperature = Temperature(dist, Star->temperature);
X    angle = 2.0*M_PI*double_rand() ;
X    xpos = dist * sin(angle) ;
X    ypos = dist * cos(angle) ;
X    
X    strcpy(Star->pnames[i], NextPlanetName(i)) ;
X    
X    roll = int_rand(1,100) ;
X    if ((int_rand(1,100) <= 10) || (temperature > 400))
X      {
X      type = TYPE_ASTEROID;
X      } 
X    else if ((temperature > 100) && (temperature <= 400))
X      {
X      if (roll <= 60)
X        type = TYPE_MARS;
X      else
X        type = TYPE_DESERT;
X      } 
X    else if ((temperature > 30) && (temperature <= 100)) 
X      {
X      if (roll <= 25)
X        type = TYPE_EARTH;
X      else if (roll <= 50)
X        type = TYPE_WATER;
X      else if (roll <= 80)
X        type = TYPE_FOREST;
X      else if (roll <= 90)
X        type = TYPE_DESERT;
X      else 
X        type = TYPE_MARS;
X      } 
X    else if ((temperature > -10) && (temperature <= 30))
X      {
X      if (roll <= 45)
X        type = TYPE_EARTH;
X      else if (roll <= 70)
X        type = TYPE_WATER;
X      else if (roll <= 95)
X        type = TYPE_FOREST;
X      else
X        type = TYPE_DESERT;
X      } 
X    else if ((temperature > -50) && (temperature <= -10))
X      {
X      if (roll <= 30)
X        type = TYPE_DESERT;
X      else if (roll <= 60)
X        type = TYPE_ICEBALL;
X      else if (roll <= 90)
X        type = TYPE_FOREST;
X      else
X        type = TYPE_MARS;
X      } 
X    else if ((temperature > -100) && (temperature <= -50))
X      {
X      if (roll <= 50)
X        type = TYPE_GASGIANT;
X      else if (roll <= 80)
X        type = TYPE_ICEBALL;
X      else
X        type = TYPE_MARS;
X      } 
X    else if (temperature <= -100) 
X      {
X      if (roll <= 80)
X        type = TYPE_ICEBALL;
X      else
X        type = TYPE_GASGIANT;
X      } 
X    planet = Makeplanet(dist, Star->temperature, type);
X    planet.xpos = xpos;
X    planet.ypos = ypos;
X    planet.total_resources = 0; 
X    Numtypes[type]++;
X    if (printplaninfo) {
X      printf("Planet %s: temp %d, type %s (%u)\n", Star->pnames[i],
X             planet.conditions[RTEMP], Nametypes[planet.type], planet.type);
X      printf("Position is (%1.0f,%1.0f) relative to %s; distance %1.0f.\n",
X             planet.xpos, planet.ypos, Star->name, dist);
X      printf("sect map(%dx%d):\n",planet.Maxx,planet.Maxy);
X      for (y=0; y<planet.Maxy; y++) {
X        for (x=0; x<planet.Maxx; x++) {
X          switch (Sector(planet,x,y).condition) {
X          case LAND:   putchr(CHAR_LAND);   break;
X          case SEA:    putchr(CHAR_SEA);    break;
X          case MOUNT:  putchr(CHAR_MOUNT);  break;
X          case ICE:    putchr(CHAR_ICE);    break;
X          case GAS:    putchr(CHAR_GAS);    break;
X          case DESERT: putchr(CHAR_DESERT); break;
X          case FOREST: putchr(CHAR_FOREST); break;
X          default: putchr('?'); break;
X            }
X          }
X        putchr('\n') ;
X        }
X      putchr('\n') ;
X      }
X    /* 
X     * Tabulate statistics for this star's planets. */
X    for (y=0; y<planet.Maxy; y++)
X      for (x=0; x<planet.Maxx; x++) {
X        char d = Sector(planet,x,y).condition ;
X        planet.total_resources += Sector(planet,x,y).resource ;
X        Resource[type] += Sector(planet,x,y).resource ;
X        Numsects[type][d]++ ;
X        Fertsects[type][d] += Sector(planet,x,y).fert ;
X        }
X    Star->planetpos[i] = (int)ftell(planetdata); 
X    /* posn of file-last write*/
X    planet.sectormappos = (int)ftell(sectordata); /* sector map pos */
X    fwrite(&planet,sizeof(planettype),1,planetdata); /* write planet */
X    /* write each sector row */
X    for (y=0; y < planet.Maxy; y++)
X      fwrite( &Sector(planet,0,y), 
X             sizeof(sectortype), planet.Maxx, sectordata) ;
X    }
X  return Star ;
X  }
END_OF_FILE
if test 10604 -ne `wc -c <'utils/makestar.c'`; then
    echo shar: \"'utils/makestar.c'\" unpacked with wrong size!
fi
# end of 'utils/makestar.c'
fi
if test -f 'utils/makeuniv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/makeuniv.c'\"
else
echo shar: Extracting \"'utils/makeuniv.c'\" \(10236 characters\)
sed "s/^X//" >'utils/makeuniv.c' <<'END_OF_FILE'
X/* makeuniv.c -- universe creation program.
X *   Makes various required data files; calls makestar for each star desired.
X * 
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, 
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h.
X * Restrictions in GB_copyright.h.
X */
X
X#include "GB_copyright.h"
X#define EXTERN
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"	/* (for power) */
X#include <math.h>
X
X#undef malloc
X#undef realloc
X#undef free 
X/* Just in case */
X
Xextern int Temperature(double, int);
Xextern void PrintStatistics(void);
Xextern void Makeplanet_init(void);
Xextern void Makestar_init(void);
Xextern startype *Makestar(FILE *, FILE *);
Xvoid InitFile(char *, void *, int) ;
Xvoid EmptyFile(char *);
Xvoid place_star(startype *);
Xvoid produce_postscript(char *);
X
X#define DEFAULT_POSTSCRIPT_MAP_FILENAME "universe.ps"
X#define NRINGS 3
X#define RING_SPACING (10000 * (UNIVSIZE / 10000) / NRINGS)
X
Xint autoname_star = -1 ;
Xint autoname_plan = -1 ;
Xint minplanets = -1 ;
Xint maxplanets = -1 ;
Xint nstars = -1 ;
Xint planetlesschance = 0 ;
Xint printpostscript = 0 ;
Xint printplaninfo = 0 ;
Xint printstarinfo = 0 ;
X
X
Xstatic int occupied[100][100];
X
Xvoid main(int argc, char *argv[])
X{
X  FILE *stardata, *planetdata, *sectordata ;
X  char str[200] ;
X  int c, i, star, x ;
X  double att, xspeed[NUMSTARS], yspeed[NUMSTARS] ;
X  
X  /* 
X   * Initialize: */
X  srandom(getpid());
X  Bzero(Sdata);
X  
X  /*
X   * Read the arguments for values: */
X  for (i=1; i<argc; i++)
X    if (argv[i][0] != '-')
X      goto usage ;
X    else 
X      switch (argv[i][1]) {
X      case 'a': autoname_star = 1 ;  break ;
X      case 'b': autoname_plan = 1 ;  break ;
X      case 'e': planetlesschance = atoi(argv[++i]) ;  break ;
X      case 'l': minplanets = atoi(argv[++i]) ;  break ;
X      case 'm': maxplanets = atoi(argv[++i]) ;  break ;
X      case 'p': printpostscript = 1 ;  break ;
X      case 's': nstars = atoi(argv[++i]) ;  break ;
X      case 'v': printplaninfo = 1 ;  break ;
X      case 'w': printstarinfo = 1 ;  break ;
X      default:
X	printf("\n") ;
X	printf("Unknown option \"%s\".\n", argv[i]) ;
X      usage:
X	printf("\n") ;
X	printf("Usage: makeuniv [-a] [-b] [-e E] [-l MIN] [-m MAX] [-s N] [-v] [-w]\n") ;
X	printf("  -a      Autoload star names.\n") ;
X	printf("  -b      Autoload planet names.\n") ;
X	printf("  -e E    Make E%% of stars have no planets.\n") ;
X	printf("  -l MIN  Other systems will have at least MIN planets.\n") ;
X	printf("  -m MAX  Other systems will have at most  MAX planets.\n") ;
X	printf("  -p      Create postscript map file of the universe.\n") ;
X	printf("  -s S    The universe will have S stars.\n") ;
X	printf("  -v      Print info and map of planets generated.\n") ;
X	printf("  -w      Print info on stars generated.\n") ;
X	printf("\n") ;
X	exit(0) ;
X	}
X
X  /*
X   * Get values for all the switches that still don't have good values. */
X  if (autoname_star == -1) {
X    printf("\nDo you wish to use the file \"%s\" for star names? [y/n]> ",
X	   STARLIST);
X    c = getchr();
X    if (c != '\n')
X      getchr();
X    autoname_star = (c=='y');
X    }
X  if (autoname_plan == -1) {
X    printf("\nDo you wish to use the file \"%s\" for planet names? [y/n]> ",
X	   PLANETLIST) ;
X    c = getchr();
X    if (c != '\n')
X      getchr();
X    autoname_plan = (c=='y');
X    }
X  while ((nstars < 1) || (nstars >= NUMSTARS)) {
X    printf("Number of stars [1-%d]:", NUMSTARS-1) ;
X    scanf("%d", &nstars) ;
X    }
X  while ((minplanets <= 0) || (minplanets > MAXPLANETS)) {
X    printf("Minimum number of planets per system [1-%d]: ", MAXPLANETS) ;
X    scanf("%d", &minplanets) ;
X    }
X  while ((maxplanets < minplanets) || (maxplanets > MAXPLANETS)) {
X    printf("Maximum number of planets per system [%d-%d]: ", 
X	   minplanets, MAXPLANETS) ;
X    scanf("%d", &maxplanets) ;
X    }
X 
X
X  Makeplanet_init() ;
X  Makestar_init() ;
X  Sdata.numstars = nstars ;
X  sprintf(str, "/bin/mkdir %s", DATADIR) ;
X  system(str) ;
X  
X  if (NULL == (planetdata = fopen(PLANETDATAFL,"w+"))) {
X    printf("Unable to open planet data file \"%s\"\n", PLANETDATAFL) ;
X    exit(-1) ;
X    }
X  if (NULL == (sectordata = fopen(SECTORDATAFL,"w+"))) {
X    printf("Unable to open sector data file \"%s\"\n", SECTORDATAFL) ;
X    exit(-1) ;
X    }
X  
X  for (star=0; star<nstars; star++) 
X    {
X    Stars[star] = Makestar(planetdata, sectordata) ;
X    xspeed[star] = 0;
X    yspeed[star] = 0; 
X    }
X  fchmod(planetdata,00660);	/* change data files to group readwrite */
X  fclose(planetdata);
X  fchmod(sectordata,00660);
X  fclose(sectordata);
X  
X  /* 
X   * Try to more evenly space stars.  Essentially this is an inverse-gravity
X   * calculation: the nearer two stars are to each other, the more they
X   * repulse each other.  Several iterations of this will suffice to move all
X   * of the stars nicely apart. */
X
X
X
X
X
X
X  for (i=0; i<CREAT_UNIV_ITERAT; i++)
X    for (star=0; star<Sdata.numstars; star++) {
X      for (x=0; x<Sdata.numstars; x++)	/* star2 */
X	if (x!=star) {
X	  /* find inverse of distance squared */
X	  att = 10*UNIVSIZE / Distsq(Stars[star]->xpos, Stars[star]->ypos, Stars[x]->xpos, Stars[x]->ypos);
X	  xspeed[star] += att * (Stars[star]->xpos - Stars[x]->xpos);
X	  if (Stars[star]->xpos>UNIVSIZE || Stars[star]->xpos< -UNIVSIZE)
X	    xspeed[star] *= -1;
X	  yspeed[star] += att * (Stars[star]->ypos - Stars[x]->ypos);
X	  if (Stars[star]->ypos>UNIVSIZE || Stars[star]->ypos< -UNIVSIZE)
X	    yspeed[star] *= -1;
X	  }
X      Stars[star]->xpos += xspeed[star];
X      Stars[star]->ypos += yspeed[star];
X      }
X  
X
X
X
X
X  if ((stardata = fopen(STARDATAFL,"w+"))==NULL) {
X    printf("Unable to open star data file \"%s\"\n", STARDATAFL) ;
X    exit(-1) ;
X    }
X  fwrite(&(Sdata),sizeof(Sdata),1,stardata);
X  for (star=0; star<Sdata.numstars; star++)
X    fwrite(Stars[star],sizeof(startype),1,stardata);
X  fchmod(stardata,00660);
X  fclose(stardata);
X  
X  EmptyFile(SHIPDATAFL) ;
X  EmptyFile(SHIPFREEDATAFL) ;
X  EmptyFile(COMMODDATAFL) ;
X  EmptyFile(COMMODFREEDATAFL) ;
X  EmptyFile(PLAYERDATAFL) ;
X  EmptyFile(RACEDATAFL) ;
X
X  { 
X  struct power p[MAXPLAYERS];
X  bzero((char *)p, sizeof(p));
X  InitFile(POWFL, p, sizeof(p)) ;
X  }
X  
X  { 
X  struct block p[MAXPLAYERS];
X  bzero((char *)p, sizeof(p));
X  InitFile(BLOCKDATAFL, p, sizeof(p)) ;
X  }
X  
X  /*
X   * Telegram files: directory and a file for each player. */
X  sprintf(str, "/bin/mkdir %s", TELEGRAMDIR );
X  system(str);
X  chmod(TELEGRAMDIR, 00770);
X#if 0  
X  /* Why is this not needed any more? */
X  for (i=1; i<MAXPLAYERS; i++) {
X    sprintf(str, "%s.%d", TELEGRAMFL, i );
X    EmptyFile(str) ;
X    }
X#endif
X
X  /*
X   * News files: directory and the 4 types of news. */
X  sprintf(str, "/bin/mkdir %s", NEWSDIR );
X  system(str);
X  chmod(NEWSDIR, 00770);
X  EmptyFile(DECLARATIONFL) ;
X  EmptyFile(TRANSFERFL) ;
X  EmptyFile(COMBATFL) ;
X  EmptyFile(ANNOUNCEFL) ;
X  
X  PrintStatistics() ;
X
X  if (printpostscript)
X    produce_postscript(DEFAULT_POSTSCRIPT_MAP_FILENAME) ;
X  }
X
Xvoid InitFile(char *filename, void *ptr, int len)
X{
X  FILE *f = fopen(filename, "w+") ;
X
X  if (f == NULL) {
X    printf("Unable to open \"%s\".\n", filename) ;
X    exit(-1) ;
X    }
X  fwrite(ptr, len, 1, f) ;
X  fchmod(f, 00660) ;
X  fclose(f) ;
X}
X
Xvoid EmptyFile(char *filename)
X{
X  InitFile(filename, NULL, 0) ;
X }
X
X/*
X * The procedure below was adapted from a program which is
X * Copyright: Andreas Girgensohn (andreasg@cs.colorado.edu)
X * produces a Postscript map of the universe. */
Xvoid produce_postscript(char *filename)
X{
X  int min_x, max_x, min_y, max_y, i ;
X  double scale, nscale ;
X  FILE *f = fopen(filename, "w+") ;
X
X  if (f == NULL) {
X    printf("Unable to open postscript file \"%s\".\n", filename) ;
X    return ;
X    }
X  printf("Creating postscript file..") ;
X  fflush(stdout) ;
X  min_x = max_x = Stars[0]->xpos;
X  min_y = max_y = Stars[0]->ypos;
X  for (i = 1; i < nstars; i++) {
X    if (Stars[i]->xpos < min_x)
X      min_x = Stars[i]->xpos;
X    if (Stars[i]->xpos > max_x)
X      max_x = Stars[i]->xpos;
X    if (Stars[i]->ypos < min_y)
X      min_y = Stars[i]->ypos;
X    if (Stars[i]->ypos > max_y)
X      max_y = Stars[i]->ypos;
X    }
X  /* max map size: 8.5in x 11in sheet, 0.5in borders, */
X  /* 0.5in on the right for star names */
X  /* 72 points = 1in */
X  scale = 7.0 * 72 / (max_x - min_x);
X  nscale = 10.0 * 72 / (max_y - min_y);
X  if (nscale < scale)
X    scale = nscale;
X  fprintf(f, "%%!PS-Adobe-2.0\n\n");
X  /* 0,0 is in the topleft corner */
X  fprintf(f, "0.5 72 mul 10.5 72 mul translate\n");
X  fprintf(f, "/drawcircle\n");
X  fprintf(f, "{\n");
X  fprintf(f, "  newpath 0 360 arc stroke\n");
X  fprintf(f, "}\n");
X  fprintf(f, "def\n\n");
X  fprintf(f, "/drawstar\n");
X  fprintf(f, "{\n");
X  fprintf(f, "  /starname exch def\n");
X  fprintf(f, "  /ypos exch def\n");
X  fprintf(f, "  /xpos exch def\n");
X  fprintf(f, "  xpos ypos 2 drawcircle\n");
X  fprintf(f, "  4 xpos add ypos moveto\n");
X  fprintf(f, "  starname show\n");
X  fprintf(f, "}\n");
X  fprintf(f, "def\n\n");
X  fprintf(f, "0 setlinewidth\n");
X  fprintf(f, "newpath -10 10 moveto 7.5 72 mul 10 add 10 lineto\n");
X  fprintf(f, "7.5 72 mul 10 add %d lineto -10 %d lineto closepath clip\n",
X      (int) ((min_y - max_y) * scale) - 10,
X      (int) ((min_y - max_y) * scale) - 10);
X#if 0
X  /*
X   * Print scale rings from center of universe (0,0): */
X  fprintf ("\n/Times-Bold findfont 9 scalefont setfont\n\n");
X  for (i = 1; i <= NRINGS; i++)
X    fprintf(f, "%d %d %d drawcircle\n",
X	    (int) ( - min_x * scale), (int) (min_y * scale),
X	    (int) (i * RING_SPACING * scale)) ;
X#endif
X  /*
X   * Print each star. */
X  fprintf(f, "\n/Times-Roman findfont 8 scalefont setfont\n\n");
X  for (i = 0; i < nstars; i++)
X    fprintf(f, "%d %d (%s) drawstar\n", 
X	    (int) ((Stars[i]->xpos - min_x) * scale),
X	    (int) ((min_y - Stars[i]->ypos) * scale), Stars[i]->name) ;
X  fprintf(f, "\nshowpage\n");
X  fclose(f) ;
X  printf("done\n") ;
X}
X
Xvoid place_star(startype *star)
X{
X    int found = 0, i, j;
X    while(!found) {
X	star->xpos = (double)int_rand(-UNIVSIZE, UNIVSIZE);
X	star->ypos = (double)int_rand(-UNIVSIZE, UNIVSIZE);
X        /* check to see if another star is nearby */
X	i = 100*((int)star->xpos + UNIVSIZE)/(2*UNIVSIZE);
X	j = 100*((int)star->xpos + UNIVSIZE)/(2*UNIVSIZE);
X	if(!occupied[i][j])
X	    occupied[i][j] = found = 1;
X    }
X    return;
X}
END_OF_FILE
if test 10236 -ne `wc -c <'utils/makeuniv.c'`; then
    echo shar: \"'utils/makeuniv.c'\" unpacked with wrong size!
fi
# end of 'utils/makeuniv.c'
fi
echo shar: End of archive 15 \(of 21\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
