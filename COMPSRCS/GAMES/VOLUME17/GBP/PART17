Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i029:  gbp - Galactic Bloodshed+, an empire-like war game, Part17/21
Message-ID: <4557@master.CNA.TEK.COM>
Date: 12 Feb 93 17:32:54 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1922
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1708

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 29
Archive-name: gbp/Part17
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 17 (of 21)."
# Contents:  hdrs/tweakables.h server/getplace.c user/fuel.c
#   user/launch.c utils/GB_racegen.c utils/exship.c
# Wrapped by billr@saab on Fri Feb 12 09:14:29 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'hdrs/tweakables.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdrs/tweakables.h'\"
else
echo shar: Extracting \"'hdrs/tweakables.h'\" \(9356 characters\)
sed "s/^X//" >'hdrs/tweakables.h' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, 
X * smq@ucscb.ucsc.edu, mods by people in GB.c, enroll.dat.
X * Restrictions in GB.c.
X *  tweakable constants & other things -- changing the following may cause GB 
X *	to freak if
X *	the functions using them are not recompiled so be careful.
X */
X
X#define VERSION "1.1.4 1/30/93"
X
X#define MOVE_FACTOR	1 
X
X#define DEFAULT_UPDATE_TIME	(4 * 60)	/* update time (minutes!) */
X#define	DEFAULT_RANDOM_UPDATE_RANGE	0	/* again, in minutes. */
X#define	DEFAULT_RANDOM_SEGMENT_RANGE	0	/* again, in minutes. */
X#define	MOVES_PER_UPDATE	3
X/* If MOVES_PER_UPDATE is set to 1, there will be no movement segments */
X/* between updates; the move is counted as part of the update. */
X/* Set this to something higher to have evenly spaced movement segments. */
X
X#define LOGIN_NAME_SIZE 64
X
X#define NUM_TIMES_TO_WAIT_FOR_LOCK 200
X#define NEUTRAL_FD 1000
X
X#define MAXCOMMSTRSIZE 250
X#define COMMANDSIZE 42
X#define MAXARGS 256
X
X#define CHAR_CURR_SCOPE ':'	/* for getplace */
X
X#define RTEMP 	  0		/* regular temp for planet */
X#define TEMP 	  1		/* temperature */
X#define METHANE   2		/* %age of gases for terraforming */
X#define OXYGEN 	  3
X#define CO2 	  4
X#define HYDROGEN  5
X#define NITROGEN  6
X#define SULFUR 	  7
X#define HELIUM 	  8
X#define OTHER 	  9
X#define TOXIC	 10
X
X#define CHAR_LAND 		'*'
X#define CHAR_SEA 		'.'
X#define CHAR_MOUNT 		'^'
X#define CHAR_DIFFOWNED 		'?'
X#define CHAR_PLATED 		'o'
X#define CHAR_WASTED 		'%'
X#define CHAR_GAS 		'~'
X#define CHAR_CLOAKED 		' '
X#define CHAR_ICE		'#'
X#define CHAR_CRYSTAL		'x'
X#define CHAR_DESERT		'-'
X#define CHAR_FOREST		')'
X
X#define CHAR_MY_TROOPS		'X'
X#define CHAR_ALLIED_TROOPS	'A'
X#define CHAR_ATWAR_TROOPS	'E'
X#define CHAR_NEUTRAL_TROOPS	'N'
X
X/* 3.0 feature */
X#define LIMITED_RESOURCES	1 /* set to 0 if you want unlimited resource
X				     availability (pre 3.0)*/
X
X#define NAMESIZE 18
X#define RNAMESIZE 35
X#define MOTTOSIZE 64
X#define PERSONALSIZE 128
X#define PLACENAMESIZE (NAMESIZE + NAMESIZE + 13)
X#define NUMSTARS 256
X#define MAXPLANETS 10
X/*#define MAXMOONS 3*/
X
X
X#define MAX_X 45	/* top range for planet */
X#define MAX_Y 19
X#define RATIOXY 3.70		/* map ratio between x and y */
X				/* ranges of map sizes (x usually ) */
X
X
X#define UNIVSIZE	150000
X#define SYSTEMSIZE	2000
X#define PLORBITSIZE	50
X
X#define WEEKLY		300
X#define DAILY		180
X
X#define VICTORY_PERCENT	10
X#define VICTORY_UPDATES	5
X
X#define AUTO_TELEG_SIZE		2000
X#define UNTRANS_MSG		"[ ? ]"
X/*#define TELEG_TRANS_APCOST	1*/
X#define TELEG_TRANS_RPCOST	5
X#define TELEG_TRANS_AMT		0.45
X#define TELEG_LETTERS		7
X#define TELEG_PLAYER_AUTO	(-2)
X#define TELEG_MAX_AUTO		7   /* when changing, alter field in plinfo */
X#define TELEG_DELIM		'~'
X#define TELEG_NDELIM		"%[^~]"
X
X#define MASS_FUEL 	0.05
X#define MASS_RESOURCE 	0.1
X#define MASS_DESTRUCT 	0.15
X#define MASS_ARMOR	1.0
X#define MASS_SIZE	0.2
X#define MASS_HANGER	0.1
X#define MASS_GUNS	0.2
X
X#define SIZE_GUNS	0.1
X#define SIZE_CREW	0.01
X#define SIZE_RESOURCE	0.02
X#define SIZE_FUEL	0.01
X#define SIZE_DESTRUCT	0.02
X#define SIZE_HANGER	0.1
X
X/* Constants for Factory mass and size */
X#define HAB_FACT_SIZE  0.2
X
X/* Cost factors for factory activation cost */
X#define HAB_FACT_ON_COST        4
X#define PLAN_FACT_ON_COST       2
X
X#define SECTOR_DAMAGE	0.3
X#define SHIP_DAMAGE	2.0
X
X#define VN_RES_TAKE	0.5	/* amt of resource of a sector the VN's take */
X
X#define LAUNCH_GRAV_MASS_FACTOR 0.18	/* fuel use modifier for taking off */
X#define LAND_GRAV_MASS_FACTOR 0.0145
X
X#define FUEL_GAS_ADD 5.0	/* amt of fuel to add to ea ships tanks */
X#define FUEL_GAS_ADD_TANKER 100.0
X#define FUEL_GAS_ADD_HABITAT 200.0
X#define FUEL_GAS_ADD_STATION 100.0
X#define FUEL_USE 0.02		/* fuel use per ship mass pt. per speed
X				   factor */
X#define HABITAT_PROD_RATE		0.05
X#define HABITAT_POP_RATE		0.20
X
X#define REPAIR_RATE 25.0	/* rate at which ships get repaired */
X#define SECTOR_REPAIR_COST 10 /* how much it costs to remove a wasted status from a sector */
X#define NATURAL_REPAIR	5	/* chance of the wasted status being removed/update */
X
X#define CREAT_UNIV_ITERAT 10	/* iterations for star movement */
X
X
X#define GRAV_FACTOR 0.0025	/* not sure as to what this should be*/
X
X
X#define FACTOR_FERT_SUPPORT 1
X			       /* # of people/fert pt sector supports*/
X#define EFF_PROD 		0.20		/* production of effcncy/pop*/
X#define RESOURCE_PRODUCTION 	0.00008 /* adjust these to change prod*/
X#define FUEL_PRODUCTION		0.00008
X
X#define DEST_PRODUCTION 	0.00008
X#define POPN_PROD		0.3
X
X#define HYPER_DRIVE_READY_CHARGE 1
X#define HYPER_DRIVE_FUEL_USE 5.0
X#define HYPER_DIST_FACTOR 200.0
X
X#define TECH_INVEST		0.01	/* invest factor */
X#define TECH_SCALE		2.0 /* investment scale */
X
X#define MOB_COST		0.00   /* mobiliz.c, doplanet.c cost/mob points*/
X/*#define RESOURCE_DEPLETION 	0.015 */
X#define RESOURCE_DEPLETION      0.0
X#define FACTOR_MOBPROD 		0.06	/* mobilization production/person */
X#define MESO_POP_SCALE		20000.0
X
X#define FUEL_COST_TERRA		3.0	/* cost to terraform */
X#define FUEL_COST_QUARRY	2.0	/* cost to mine resources */
X#define FUEL_COST_PLOW		2.0
X#define RES_COST_DOME		1
X#define RES_COST_WPLANT		1
X#define FUEL_COST_WPLANT	1.0
X
X#define ENLIST_TROOP_COST	5	/* money it costs to pay a trooper */
X#define UPDATE_TROOP_COST	1
X
X#define PLAN_FIRE_LIM		20	/* max fire strength from planets */
X
X#define TECH_SEE_STABILITY 15	/* min tech to see star stability */
X
X#define TECH_EXPLORE 	   10	/* min tech to see your whole planet */
X
X#define ENVIR_DAMAGE_TOX	70
X	/* min tox to damage planet */
X
X#define PLANETGRAVCONST 	0.05
X#define SYSTEMGRAVCONST 	150000.0
X
X
X#define FUEL_MANEUVER	0.3	/* order.c-- fuel it costs to change aim */
X#define DIST_TO_LAND 	10.0 	/* moveship.c,land.c -- */
X#define DIST_TO_DOCK 	10.0 	/* changed to fix a bug. Maarten */
X/* description: you could when you just entered planet scope assaault/dock
X   with a ship in close orbit, and then immediately land. */
X
X/*#define DIST_TO_BURN 50	 /* distance from sun needed to destroy ship */
X
X
X#define FACTOR_DAMAGE 		2.0
X#define FACTOR_DESTPLANET 	0.35
X
X	/* various compiler options that may save cpu time/disk space */
X#define NO_SLIDING_SCALE_AUTOMOVE 0	/* move to all four adjacent spots */
X#define POPN_MOVE_SCALE_1 400		/* limit at which popn moves to all */
X#define POPN_MOVE_SCALE_2 3000		/* " " " popn moves to 2 adj. spaces */
X					/* otherwise move to only 1 adj. space*/
X#define SHIP_MOVE_SCALE 3.0
X
X#define reg register
X /* to save object code */
X#define getchr() fgetc(stdin)
X#define putchr(c) fputc((c),stdout)
X/* assorted macros */
X /* sign,abs val of number */
X#define sgn(x) ( ((x)>=0) ? 1 : -1)
X#define abs(x) ( ( (x)<0) ? -(x) : (x) )
X#define MIN(x,y) ( ((x)>(y)) ? (y) : (x) )
X#define MAX(x,y) ( ((x)<(y)) ? (y) : (x) )
X /* positive modulus */
X#define mod(a,b,dum) ((dum)=(a)%(b),abs(dum))
X /* swap two variables */
X#define	swap(a, b)  ((a) ^= (b), (b) ^= (a), (a) ^= (b))
X /* euclidean distance */
X#define Distsq(x1,y1,x2,y2) ( ((x1)-(x2))*((x1)-(x2)) + ((y1)-(y2))*((y1)-(y2)) )
X
X/* look up sector */
X#define Sector(pl,x,y) (Smap[(x) + (y)*(pl).Maxx])
X/* adjust temperature to displayed */
X#define Temp(x) ((int)(x))
X
X /* number of AP's to add to each player in ea. system */
X /*   (look in doturn)  */
X#define LIMIT_APs 255	/* max # of APs you can have */
X
X#define TYPE_EARTH 	0
X#define TYPE_ASTEROID 	1
X#define TYPE_MARS 	2
X#define TYPE_ICEBALL	3
X#define TYPE_GASGIANT 	4
X#define TYPE_WATER	5
X#define TYPE_FOREST	6
X#define TYPE_DESERT	7
X
X/* number of global APs each planet is worth */
X#define EARTH_POINTS	int_rand(5,8)
X#define ASTEROID_POINTS	1
X#define MARS_POINTS	int_rand(2,3)
X#define ICEBALL_POINTS	int_rand(2,3)
X#define GASGIANT_POINTS	int_rand(8,20)
X#define WATER_POINTS	int_rand(2,3)
X#define FOREST_POINTS	int_rand(2,3)
X#define DESERT_POINTS	int_rand(2,3)
X
X#define SEA 	0
X#define LAND 	1
X#define MOUNT 	2
X#define GAS 	3
X#define ICE	4
X#define FOREST	5
X#define DESERT	6
X#define PLATED 	7
X#define WASTED	8
X
X#define CIV		0
X#define MIL		1
X
X#define MAX_SECT_POPN 32767
X
X#define TOXMAX		20	/* max a toxwc can hold */
X
X#define SIGBLOCKS (SIGHUP|SIGTERM|SIGINT|SIGQUIT|SIGSTOP|SIGTSTP)
X				/* signals to block... */
X
X#define Bzero(x)  bzero( (char *)&(x), sizeof(x) )
X#define Malloc(x) (x *)malloc( sizeof(x) )
X
X
X#define _STDLIB_H	/* for compiling on NeXt machines */
X
X#define RESOURCE 0  /* for market */
X#define DESTRUCT 1
X#define FUEL	 2
X#define CRYSTAL  3
X
X#define MERCHANT_LENGTH	200000.0
X#define INCOME_FACTOR	0.002
X#define INSURG_FACTOR	1
X#define UP_BID		0.10
X
X#define GUN_COST	1.00
X#define CREW_COST      	0.05
X#define CARGO_COST	0.05
X#define FUEL_COST	0.05
X#define AMMO_COST	0.05
X#define SPEED_COST	0.50
X#define CEW_COST	0.003
X#define ARMOR_COST	3.50
X#define HANGER_COST	0.50
X
X#define AFV_FUEL_COST	1.0
X
X#define MECH_ATTACK	3.0
X
X# define VICT_SECT	 1000
X# define VICT_SHIP	  333
X# define VICT_TECH	  .10
X# define VICT_MORALE	  200
X# define VICT_RES	  100
X# define VICT_FUEL	   15
X# define VICT_MONEY	    5
X# define VICT_DIVISOR	10000
X
X#define STRIKE_DISTANCE_FACTOR	5.5
X#define COMPLEXITY_FACTOR	10.0  /* determines steepness of design complexity function */
X
X#define REPEAT_CHARACTER ' '	/* this character makes the previous command to
X				   repeat */
X#define MAXGOVERNORS	5
X#define POD_THRESHOLD	18
X#define POD_DECAY	4
X#define AP_FACTOR	50.0	/* how planet size affects the rate of atmosphere processing */
X#define DISSIPATE	80	/* updates to dissipate dust and gases */
X
END_OF_FILE
if test 9356 -ne `wc -c <'hdrs/tweakables.h'`; then
    echo shar: \"'hdrs/tweakables.h'\" unpacked with wrong size!
fi
# end of 'hdrs/tweakables.h'
fi
if test -f 'server/getplace.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/getplace.c'\"
else
echo shar: Extracting \"'server/getplace.c'\" \(7768 characters\)
sed "s/^X//" >'server/getplace.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * Getplace -- returns directory level from string and current Dir Dispplace --
X * returns string from directory level testship(ship) -- tests various things
X * for the ship.
X */
X
X#include <ctype.h>
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "races.h"
X#include "ships.h"
X#include "power.h"
X#include "buffers.h"
X
Xchar            Disps[PLACENAMESIZE];
Xplacetype       Getplace(int, int, char *, int);
Xplacetype       Getplace2(int, int, char *, placetype *, int, int);
Xchar           *Dispshiploc_brief(shiptype *);
Xchar           *Dispshiploc(shiptype *);
Xchar           *Dispplace(int, int, placetype *);
Xint             testship(int, int, shiptype *);
X#include "proto.h"
X
Xplacetype 
XGetplace(int Playernum, int Governor, char *string, int ignoreexpl)
X{
X	placetype       where;	/* return value */
X	racetype       *Race;
X	int             God;
X
X	Bzero(where);
X
X	Race = races[Playernum - 1];
X	God = Race->God;
X
X	where.err = 0;
X
X	switch (*string) {
X	case '/':
X		where.level = LEVEL_UNIV;	/* scope = root (universe) */
X		where.snum = 0;
X		where.pnum = where.shipno = 0;
X		return (Getplace2(Playernum, Governor, string + 1, &where, ignoreexpl, God));
X	case '#':
X		sscanf(++string, "%hd", &where.shipno);
X		if (!getship(&where.shipptr, where.shipno)) {
X			DontOwnErr(Playernum, Governor, where.shipno);
X			where.err = 1;
X			return where;
X		}
X		if ((where.shipptr->owner == Playernum || ignoreexpl || God)
X		    && (where.shipptr->alive || God)) {
X			where.level = LEVEL_SHIP;
X			where.snum = where.shipptr->storbits;
X			where.pnum = where.shipptr->pnumorbits;
X			free(where.shipptr);
X			return where;
X		} else {
X			where.err = 1;
X			free(where.shipptr);
X			return where;
X		}
X	case '-':
X		/* no destination */
X		where.level = LEVEL_UNIV;
X		return where;
X	default:
X		/* copy current scope to scope */
X		where.level = Dir[Playernum - 1][Governor].level;
X		where.snum = Dir[Playernum - 1][Governor].snum;
X		where.pnum = Dir[Playernum - 1][Governor].pnum;
X		if (where.level == LEVEL_SHIP)
X			where.shipno = Dir[Playernum - 1][Governor].shipno;
X		if (*string == CHAR_CURR_SCOPE)
X			return where;
X		else
X			return Getplace2(Playernum, Governor, string, &where, ignoreexpl, God);
X	}
X}
X
Xplacetype 
XGetplace2(int Playernum, int Governor, char *string,
X	  placetype * where, int ignoreexpl, int God)
X{
X	char            substr[NAMESIZE];
X	planettype     *p;
X	register int    i, l;
X	int             tick;
X
X	if (where->err || *string == '\0' || *string == '\n')
X		return (*where);/* base cases */
X	else if (*string == '.') {
X		if (where->level == LEVEL_UNIV) {
X			sprintf(buf, "Can't go higher.\n");
X			notify(Playernum, Governor, buf);
X			where->err = 1;
X			return (*where);
X		} else {
X			if (where->level == LEVEL_SHIP) {
X				(void) getship(&where->shipptr, where->shipno);
X				where->level = where->shipptr->whatorbits;
X				/* Fix 'cs .' for ships within ships. Maarten */
X				if (where->level == LEVEL_SHIP)
X					where->shipno = where->shipptr->destshipno;
X				free(where->shipptr);
X			} else
X				where->level--;
X			while (*string == '.')
X				string++;
X			while (*string == '/')
X				string++;
X			return (Getplace2(Playernum, Governor, string, where, ignoreexpl, God));
X		}
X	} else {
X		/* is a char string, name of something */
X		sscanf(string, "%[^/ \n]", substr);
X		do {
X			/*
X			 * if (isupper(*string) ) (*string) =
X			 * tolower(*string);
X			 */
X			string++;
X		} while (*string != '/' && *string != '\n' && *string != '\0');
X		l = strlen(substr);
X		if (where->level == LEVEL_UNIV) {
X			for (i = 0; i < Sdata.numstars; i++)
X				if (!strncmp(substr, Stars[i]->name, l)) {
X					where->level = LEVEL_STAR;
X					where->snum = i;
X					if (ignoreexpl ||
X					    isset(Stars[where->snum]->explored, Playernum) || God) {
X						tick = (*string == '/');
X						return (Getplace2(Playernum, Governor, string + tick, where, ignoreexpl, God));
X					}
X					sprintf(buf, "You have not explored %s yet.\n",
X						Stars[where->snum]->name);
X					notify(Playernum, Governor, buf);
X					where->err = 1;
X					return (*where);
X				}
X			if (i >= Sdata.numstars) {
X				sprintf(buf, "No such star %s.\n", substr);
X				notify(Playernum, Governor, buf);
X				where->err = 1;
X				return (*where);
X			}
X		} else if (where->level == LEVEL_STAR) {
X			for (i = 0; i < Stars[where->snum]->numplanets; i++)
X				if ((!strncmp(substr, Stars[where->snum]->pnames[i], l)) ||
X					atoi(substr) == i+1) /* JPD && SKF */ {
X					where->level = LEVEL_PLAN;
X					where->pnum = i;
X					getplanet(&p, (int) where->snum, i);
X					if (ignoreexpl || p->info[Playernum - 1].explored || God) {
X						free(p);
X						tick = (*string == '/');
X						return (Getplace2(Playernum, Governor, string + tick, where, ignoreexpl, God));
X					}
X					sprintf(buf, "You have not explored %s yet.\n",
X					     Stars[where->snum]->pnames[i]);
X					notify(Playernum, Governor, buf);
X					where->err = 1;
X					free(p);
X					return (*where);
X				}
X			if (i >= Stars[where->snum]->numplanets) {
X				sprintf(buf, "No such planet %s.\n", substr);
X				notify(Playernum, Governor, buf);
X				where->err = 1;
X				return (*where);
X			}
X		} else {
X			sprintf(buf, "Can't descend to %s.\n", substr);
X			notify(Playernum, Governor, buf);
X			where->err = 1;
X			return (*where);
X		}
X	}
X}
X
Xchar           *
XDispshiploc_brief(shiptype * ship)
X{
X	int             i;
X
X	switch (ship->whatorbits) {
X	case LEVEL_STAR:
X		sprintf(Disps, "/%-4.4s", Stars[ship->storbits]->name);
X		return (Disps);
X	case LEVEL_PLAN:
X		sprintf(Disps, "/%s", Stars[ship->storbits]->name);
X		for (i = 2; (Disps[i] && (i < 5)); i++);
X		sprintf(Disps + i, "/%-4.4s",
X			Stars[ship->storbits]->pnames[ship->pnumorbits]);
X		return (Disps);
X	case LEVEL_SHIP:
X		sprintf(Disps, "#%d", ship->destshipno);
X		return (Disps);
X	case LEVEL_UNIV:
X		strcat(Disps, "/");
X		return (Disps);
X	default:
X		strcat(Disps, "error");
X		return (Disps);
X	}
X}
X
Xchar           *
XDispshiploc(shiptype * ship)
X{
X	switch (ship->whatorbits) {
X		case LEVEL_STAR:
X		sprintf(Disps, "/%s", Stars[ship->storbits]->name);
X		return (Disps);
X	case LEVEL_PLAN:
X		sprintf(Disps, "/%s/%s", Stars[ship->storbits]->name,
X			Stars[ship->storbits]->pnames[ship->pnumorbits]);
X		return (Disps);
X	case LEVEL_SHIP:
X		sprintf(Disps, "#%d", ship->destshipno);
X		return (Disps);
X	case LEVEL_UNIV:
X		sprintf(Disps, "/");
X		return (Disps);
X	default:
X		sprintf(Disps, "error");
X		return (Disps);
X	}
X}
X
Xchar           *
XDispplace(int Playernum, int Governor, placetype * where)
X{
X	switch (where->level) {
X		case LEVEL_STAR:
X		sprintf(Disps, "/%s", Stars[where->snum]->name);
X		return (Disps);
X	case LEVEL_PLAN:
X		sprintf(Disps, "/%s/%s", Stars[where->snum]->name,
X			Stars[where->snum]->pnames[where->pnum]);
X		return (Disps);
X	case LEVEL_SHIP:
X		sprintf(Disps, "#%d", where->shipno);
X		return (Disps);
X	case LEVEL_UNIV:
X		return ("/");
X	default:
X		sprintf(buf, "illegal Dispplace val = %d\n", where->level);
X		notify(Playernum, Governor, buf);
X		where->err = 1;
X		return ("/");
X	}
X}
X
Xint 
Xtestship(int Playernum, int Governor, shiptype * s)
X{
X	reg int         r;
X
X	r = 0;
X
X	if (!s->alive) {
X		sprintf(buf, "%s has been destroyed.\n", Ship(s));
X		notify(Playernum, Governor, buf);
X		r = 1;
X	} else if (s->owner != Playernum || !authorized(Governor, s)) {
X		DontOwnErr(Playernum, Governor, (int) s->number);
X		r = 1;
X	} else {
X		if (!s->active) {
X			sprintf(buf, "%s is irradiated %d%% and inactive.\n", Ship(s), s->rad);
X			notify(Playernum, Governor, buf);
X			r = 1;
X		}
X		/*
X		 * if (!s->popn && s->max_crew) { sprintf(buf,"%s has no crew
X		 * and is not a robotic ship.\n", Ship(s)); notify(Playernum,
X		 * Governor, buf); r = 1; }
X		 */
X	}
X	return r;
X}
END_OF_FILE
if test 7768 -ne `wc -c <'server/getplace.c'`; then
    echo shar: \"'server/getplace.c'\" unpacked with wrong size!
fi
# end of 'server/getplace.c'
fi
if test -f 'user/fuel.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/fuel.c'\"
else
echo shar: Extracting \"'user/fuel.c'\" \(9244 characters\)
sed "s/^X//" >'user/fuel.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * fuel.c -- See estimations in fuel consumption and travel time.
X * 
X * Programmed by varneyml@gb.dorm.clarkson.edu
X */
X
X#include <math.h>
X#include <time.h>
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X
X/*
X * extern long next_segment_time; extern long next_update_time; extern long
X * nsegments_done; extern int update_time;
X */
X
Xchar            plan_buf[1024];
X
Xint             number_segments;
Xdouble          x_0, y_0, x_1, y_1;
Xshiptype       *tmpship;
Xplacetype       tmpdest;
X
Xvoid            proj_fuel(int, int, int);
Xvoid            fuel_output(int, int, double, double, double, double, int);
Xint             do_trip(double, double);
X#include "proto.h"
X
Xvoid 
Xproj_fuel(int Playernum, int Governor, int APcount)
X{
X	int             shipno, trip_resolved, opt_settings, current_settings,
X	                current_segs, computing = 1;
X	double          fuel_usage, level, dist;
X	shiptype       *ship;
X	planettype     *p;
X	char            buf[1024];
X	double          current_fuel = 0.0, gravity_factor = 0.0, gravity_fuel = 0.0;
X
X	if ((argn < 2) || (argn > 3)) {
X		notify(Playernum, Governor, "Invalid number of options.\n\"fuel #<shipnumber> [destination]\"...\n");
X		return;
X	}
X	if (args[1][0] != '#') {
X		notify(Playernum, Governor, "Invalid first option.\n\"fuel #<shipnumber> [destination]\"...\n");
X		return;
X	}
X	sscanf(args[1] + (args[1][0] == '#'), "%d", &shipno);
X	if (shipno > Numships() || shipno < 1) {
X		sprintf(buf, "rst: no such ship #%d \n", shipno);
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	(void) getship(&ship, shipno);
X	if (ship->owner != Playernum) {
X		notify(Playernum, Governor, "You do not own this ship.\n");
X		free(ship);
X		return;
X	}
X	if (landed(ship) && (argn == 2)) {
X		notify(Playernum, Governor, "You must specify a destination for landed or docked ships...\n");
X		free(ship);
X		return;
X	}
X	if (!ship->speed) {
X		notify(Playernum, Governor, "That ship is not moving!\n");
X		free(ship);
X		return;
X	}
X	if ((!speed_rating(ship)) || (ship->type == OTYPE_FACTORY)) {
X		notify(Playernum, Governor, "That ship does not have a speed rating...\n");
X		free(ship);
X		return;
X	}
X	if (landed(ship) && (ship->whatorbits == LEVEL_PLAN)) {
X		getplanet(&p, (int) ship->storbits, (int) ship->pnumorbits);
X		gravity_factor = gravity(p);
X		sprintf(plan_buf, "/%s/%s", Stars[(int) ship->storbits]->name,
X		Stars[(int) ship->storbits]->pnames[(int) ship->pnumorbits]);
X		free(p);
X	}
X	if (argn == 2)
X		strcpy(args[2], prin_ship_dest(Playernum, Governor, ship));
X	tmpdest = Getplace(Playernum, Governor, args[2], 1);
X	if (tmpdest.err) {
X		notify(Playernum, Governor, "fuel:  bad scope.\n");
X		free(ship);
X		return;
X	}
X	if (tmpdest.level == LEVEL_SHIP) {
X		(void) getship(&tmpship, tmpdest.shipno);
X		if (!followable(ship, tmpship)) {
X			notify(Playernum, Governor, "The ship's destination is out of range.\n");
X			free(tmpship);
X			free(ship);
X			return;
X		}
X		free(tmpship);
X	}
X	if (tmpdest.level != LEVEL_UNIV && tmpdest.level != LEVEL_SHIP &&
X	((ship->storbits != tmpdest.snum) && tmpdest.level != LEVEL_STAR) &&
X	    isclr(Stars[tmpdest.snum]->explored, ship->owner)) {
X		notify(Playernum, Governor, "You haven't explored the destination system.\n");
X		free(ship);
X		return;
X	}
X	if (tmpdest.level == LEVEL_UNIV) {
X		notify(Playernum, Governor, "Invalid ship destination.\n");
X		free(ship);
X		return;
X	}
X	x_0 = y_0 = x_1 = y_1 = 0.0;
X
X	x_0 = ship->xpos;
X	y_0 = ship->ypos;
X	free(ship);
X
X	if (tmpdest.level == LEVEL_UNIV) {
X		notify(Playernum, Governor, "That ship currently has no destination orders...\n");
X		return;
X	}
X	if (tmpdest.level == LEVEL_SHIP) {
X		(void) getship(&tmpship, tmpdest.shipno);
X		if (tmpship->owner != Playernum) {
X			notify(Playernum, Governor, "Nice try.\n");
X			return;
X		}
X		x_1 = tmpship->xpos;
X		y_1 = tmpship->ypos;
X		free(tmpship);
X	} else if (tmpdest.level == LEVEL_PLAN) {
X		getplanet(&p, (int) tmpdest.snum, (int) tmpdest.pnum);
X		x_1 = p->xpos + Stars[tmpdest.snum]->xpos;
X		y_1 = p->ypos + Stars[tmpdest.snum]->ypos;
X		free(p);
X	} else if (tmpdest.level == LEVEL_STAR) {
X		x_1 = Stars[tmpdest.snum]->xpos;
X		y_1 = Stars[tmpdest.snum]->ypos;
X	} else
X		printf("ERROR 99\n");
X
X	/* compute the distance */
X	dist = sqrt(Distsq(x_0, y_0, x_1, y_1));
X
X	if (dist <= DIST_TO_LAND) {
X		notify(Playernum, Governor, "That ship is within 10.0 units of the destination.\n");
X		return;
X	}
X	/* First get the results based on current fuel load.  */
X	(void) getship(&tmpship, shipno);
X	level = tmpship->fuel;
X	current_settings = do_trip(tmpship->fuel, gravity_factor);
X	current_segs = number_segments;
X	if (current_settings)
X		current_fuel = level - tmpship->fuel;
X
X	/* 2nd loop to determine lowest fuel needed...  */
X	fuel_usage = level = tmpship->max_fuel;
X	opt_settings = 0;
X	while (computing) {
X		(void) getship(&tmpship, shipno);
X		computing = do_trip(level, gravity_factor);
X		if ((computing) && (tmpship->fuel >= 0.05)) {
X			fuel_usage = level;
X			opt_settings = 1;
X			level -= tmpship->fuel;
X		} else if (computing) {
X			computing = 0;
X			fuel_usage = level;
X		}
X	}
X
X	(void) getship(&tmpship, shipno);
X	sprintf(buf, "\n  ----- ===== FUEL ESTIMATES ===== ----\n\nAt Current Fuel Cargo (%.2ff):\n", tmpship->fuel);
X	domass(tmpship);
X	notify(Playernum, Governor, buf);
X	if (!current_settings) {
X		sprintf(buf, "The ship will not be able to complete the trip.\n");
X		notify(Playernum, Governor, buf);
X	} else
X		fuel_output(Playernum, Governor, dist, current_fuel, gravity_factor, tmpship->mass, current_segs);
X	sprintf(buf, "At Optimum Fuel Level (%.2ff):\n", fuel_usage);
X	notify(Playernum, Governor, buf);
X	if (!opt_settings) {
X		sprintf(buf, "The ship will not be able to complete the trip.\n");
X		notify(Playernum, Governor, buf);
X	} else {
X		tmpship->fuel = fuel_usage;
X		domass(tmpship);
X		fuel_output(Playernum, Governor, dist, fuel_usage, gravity_factor, tmpship->mass, number_segments);
X	}
X	free(tmpship);
X}
X
X
Xvoid 
Xfuel_output(int Playernum, int Governor, double dist, double fuel,
X	    double grav, double mass, int segs)
X{
X	long            effective_time;
X	double          gravity_fuel = 0.0;
X	char            buf[1024], grav_buf[1024];
X
X	if (grav > 0.00)
X		sprintf(grav_buf, " (%.2f used to launch from %s)\n",
X		  (double) (grav * mass * (double) LAUNCH_GRAV_MASS_FACTOR),
X			plan_buf);
X	else
X		sprintf(grav_buf, " ");
X	sprintf(buf, "Total Distance = %.2f   Number of Segments = %d\nFuel = %.2f%s  ", dist, segs, fuel, grav_buf);
X	notify(Playernum, Governor, buf);
X	if (nsegments_done > segments)
X		notify(Playernum, Governor, "Estimated arrival time not available due to segment # discrepancy.\n");
X	else {
X		effective_time = next_segment_time + (long) ((segs - 1) * (update_time / segments) * 60);
X		if (segments == 1)
X			effective_time = next_update_time + (long) ((segs - 1) * (update_time * 60));
X		sprintf(buf, "ESTIMATED Arrival Time: %s\n", ctime(&effective_time));
X		notify(Playernum, Governor, buf);
X		return;
X	}
X}
X
Xint 
Xdo_trip(double fuel, double gravity_factor)
X{
X	int             effective_segment_number, trip_resolved, i;
X	double          gravity_fuel, tmpdist, fuel_level1;
X
X	tmpship->fuel = fuel;	/* load up the pseudo-ship */
X	effective_segment_number = nsegments_done;
X
X	/* Set our temporary destination.... */
X	tmpship->destshipno = (unsigned short) tmpdest.shipno;
X	tmpship->whatdest = tmpdest.level;
X	tmpship->deststar = tmpdest.snum;
X	tmpship->destpnum = tmpdest.pnum;
X	if (tmpship->whatdest == LEVEL_SHIP || tmpship->ships) {
X		/* Bring in the other ships.  Moveship() uses ships[]. */
X		Num_ships = Numships();
X		ships = (shiptype **) malloc(sizeof(shiptype *) * (Num_ships) + 1);
X		for (i = 1; i <= Num_ships; i++)
X			(void) getship(&ships[i], i);
X	}
X	trip_resolved = 0;
X	number_segments = 0;	/* Reset counter.  */
X
X	/* Launch the ship if it's on a planet.  */
X	gravity_fuel = gravity_factor * tmpship->mass * LAUNCH_GRAV_MASS_FACTOR;
X	tmpship->fuel -= gravity_fuel;
X	tmpship->docked = 0;
X
X	while (trip_resolved == 0) {
X		domass(tmpship);
X		fuel_level1 = tmpship->fuel;
X		Moveship(tmpship, (effective_segment_number == segments), 0, 1);
X		number_segments++;
X		effective_segment_number++;
X		if (effective_segment_number == (segments + 1))
X			effective_segment_number = 1;
X		x_0 = (double) tmpship->xpos;
X		y_0 = (double) tmpship->ypos;
X		tmpdist = sqrt(Distsq(x_0, y_0, x_1, y_1));
X		switch ((int) tmpship->whatdest) {
X		case LEVEL_STAR:
X			if (tmpdist <= (double) SYSTEMSIZE)
X				trip_resolved = 1;
X			break;
X		case LEVEL_PLAN:
X			if (tmpdist <= (double) PLORBITSIZE)
X				trip_resolved = 1;
X			break;
X		case LEVEL_SHIP:
X			if (tmpdist <= (double) DIST_TO_LAND)
X				trip_resolved = 1;
X			break;
X		default:
X			trip_resolved = 1;
X		}
X		if (((tmpship->fuel == fuel_level1) && (!tmpship->hyper_drive.on)) && (trip_resolved == 0)) {
X			if (tmpship->whatdest == LEVEL_SHIP) {
X				for (i = 1; i <= Num_ships; i++)
X					free(ships[i]);
X				free(ships);
X			}
X			return (0);
X		}
X	}
X	if (tmpship->whatdest == LEVEL_SHIP || tmpship->ships) {
X		for (i = 1; i <= Num_ships; i++)
X			free(ships[i]);
X		free(ships);
X	}
X	return (1);
X}
END_OF_FILE
if test 9244 -ne `wc -c <'user/fuel.c'`; then
    echo shar: \"'user/fuel.c'\" unpacked with wrong size!
fi
# end of 'user/fuel.c'
fi
if test -f 'user/launch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/launch.c'\"
else
echo shar: Extracting \"'user/launch.c'\" \(7962 characters\)
sed "s/^X//" >'user/launch.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * launch.c -- launch or undock a ship (also undock)
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X#include <signal.h>
X
Xvoid            launch(int, int, int);
X#include "proto.h"
X
Xvoid 
Xlaunch(int Playernum, int Governor, int APcount)
X{
X	int             sh2;
X	shiptype       *s, *s2;
X	planettype     *p;
X	int             shipno, i, nextshipno;
X	double          fuel;
X
X	if (argn < 2) {
X		notify(Playernum, Governor, "Launch what?\n");
X		return;
X	}
X	nextshipno = start_shiplist(Playernum, Governor, args[1]);
X
X	while (shipno = do_shiplist(&s, &nextshipno))
X		if (in_list(Playernum, args[1], s, &nextshipno) &&
X		    authorized(Governor, s)) {
X			if (!speed_rating(s) && landed(s)) {
X				sprintf(buf, "That ship is not designed to be launched.\n");
X				notify(Playernum, Governor, buf);
X				free(s);
X				continue;
X			}
X			if (!(s->docked || s->whatorbits == LEVEL_SHIP)) {
X				sprintf(buf, "%s is not landed or docked.\n", Ship(s));
X				notify(Playernum, Governor, buf);
X				free(s);
X				continue;
X			}
X			if (!landed(s))
X				APcount = 0;
X			if (landed(s) && s->resource > Max_resource(s)) {
X				sprintf(buf, "%s is too overloaded to launch.\n", Ship(s));
X				notify(Playernum, Governor, buf);
X				free(s);
X				continue;
X			}
X			if (s->whatorbits == LEVEL_SHIP) {
X				/*
X				 * Factories cannot be launched once turned
X				 * on. Maarten
X				 */
X				if (s->type == OTYPE_FACTORY && s->on) {
X					notify(Playernum, Governor, "Factories cannot be launched once turned on.\n");
X					notify(Playernum, Governor, "Consider using 'scrap'.\n");
X					free(s);
X					continue;
X				}
X				sh2 = s->destshipno;
X				(void) getship(&s2, sh2);
X				if (landed(s2)) {
X					remove_sh_ship(s, s2);
X					getplanet(&p, (int) s2->storbits, (int) s2->pnumorbits);
X					insert_sh_plan(p, s);
X					putplanet(p, (int) s2->storbits, (int) s2->pnumorbits);
X					s->storbits = s2->storbits;
X					s->pnumorbits = s2->pnumorbits;
X					s->destpnum = s2->pnumorbits;
X					s->deststar = s2->deststar;
X					s->xpos = s2->xpos;
X					s->ypos = s2->ypos;
X					s->land_x = s2->land_x;
X					s->land_y = s2->land_y;
X					s->docked = 1;
X					s->whatdest = LEVEL_PLAN;
X					s2->mass -= s->mass;
X					s2->hanger -= Size(s);
X					sprintf(buf, "Landed on %s/%s.\n", Stars[s->storbits]->name,
X						Stars[s->storbits]->pnames[s->pnumorbits]);
X					notify(Playernum, Governor, buf);
X					free(p);
X					putship(s);
X					putship(s2);
X				} else if (s2->whatorbits == LEVEL_PLAN) {
X					remove_sh_ship(s, s2);
X					sprintf(buf, "%s launched from %s.\n", Ship(s), Ship(s2));
X					notify(Playernum, Governor, buf);
X					s->xpos = s2->xpos;
X					s->ypos = s2->ypos;
X					s->docked = 0;
X					s->whatdest = LEVEL_UNIV;
X					s2->mass -= s->mass;
X					s2->hanger -= Size(s);
X					getplanet(&p, (int) s2->storbits, (int) s2->pnumorbits);
X					insert_sh_plan(p, s);
X					s->storbits = s2->storbits;
X					s->pnumorbits = s2->pnumorbits;
X					putplanet(p, (int) s2->storbits, (int) s2->pnumorbits);
X					sprintf(buf, "Orbiting %s/%s.\n", Stars[s->storbits]->name,
X						Stars[s->storbits]->pnames[s->pnumorbits]);
X					notify(Playernum, Governor, buf);
X					free(p);
X					putship(s);
X					putship(s2);
X				} else if (s2->whatorbits == LEVEL_STAR) {
X					remove_sh_ship(s, s2);
X					sprintf(buf, "%s launched from %s.\n", Ship(s), Ship(s2));
X					notify(Playernum, Governor, buf);
X					s->xpos = s2->xpos;
X					s->ypos = s2->ypos;
X					s->docked = 0;
X					s->whatdest = LEVEL_UNIV;
X					s2->mass -= s->mass;
X					s2->hanger -= Size(s);
X					getstar(&(Stars[s2->storbits]), (int) s2->storbits);
X					insert_sh_star(Stars[s2->storbits], s);
X					s->storbits = s2->storbits;
X					putstar(Stars[s2->storbits], (int) s2->storbits);
X					sprintf(buf, "Orbiting %s.\n", Stars[s->storbits]->name);
X					notify(Playernum, Governor, buf);
X					putship(s);
X					putship(s2);
X				} else if (s2->whatorbits == LEVEL_UNIV) {
X					remove_sh_ship(s, s2);
X					sprintf(buf, "%s launched from %s.\n", Ship(s), Ship(s2));
X					notify(Playernum, Governor, buf);
X					s->xpos = s2->xpos;
X					s->ypos = s2->ypos;
X					s->docked = 0;
X					s->whatdest = LEVEL_UNIV;
X					s2->mass -= s->mass;
X					s2->hanger -= Size(s);
X					getsdata(&Sdata);
X					insert_sh_univ(&Sdata, s);
X					notify(Playernum, Governor, "Universe level.\n");
X					putsdata(&Sdata);
X					putship(s);
X					putship(s2);
X				} else {
X					notify(Playernum, Governor, "You can't launch that ship.\n");
X					free(s2);
X					free(s);
X					continue;
X				}
X				free(s2);
X				free(s);
X			} else if (s->whatdest == LEVEL_SHIP) {
X				sh2 = s->destshipno;
X				(void) getship(&s2, sh2);
X				if (s2->whatorbits == LEVEL_UNIV) {
X					if (!enufAP(Playernum, Governor, Sdata.AP[Playernum - 1], APcount)) {
X						free(s);
X						free(s2);
X						continue;
X					} else
X						deductAPs(Playernum, Governor, APcount, 0, 1);
X				} else {
X					if (!enufAP(Playernum, Governor, Stars[s->storbits]->AP[Playernum - 1], APcount)) {
X						free(s);
X						free(s2);
X						continue;
X					} else
X						deductAPs(Playernum, Governor, APcount, (int) s->storbits, 0);
X				}
X				s->docked = 0;
X				s->whatdest = LEVEL_UNIV;
X				s->destshipno = 0;
X				s2->docked = 0;
X				s2->whatdest = LEVEL_UNIV;
X				s2->destshipno = 0;
X				sprintf(buf, "%s undocked from %s.\n", Ship(s), Ship(s2));
X				notify(Playernum, Governor, buf);
X				putship(s);
X				putship(s2);
X				free(s);
X				free(s2);
X			} else {
X				if (!enufAP(Playernum, Governor, Stars[s->storbits]->AP[Playernum - 1], APcount)) {
X					free(s);
X					return;
X				} else
X					deductAPs(Playernum, Governor, APcount, (int) s->storbits, 0);
X
X				/* adjust x,ypos to absolute coords */
X				getplanet(&p, (int) s->storbits, (int) s->pnumorbits);
X				sprintf(buf, "Planet /%s/%s has gravity field of %.2f\n", Stars[s->storbits]->name,
X					Stars[s->storbits]->pnames[s->pnumorbits], gravity(p));
X				notify(Playernum, Governor, buf);
X				s->xpos = Stars[s->storbits]->xpos + p->xpos +
X					(double) int_rand((int) (-DIST_TO_LAND / 4), (int) (DIST_TO_LAND / 4));
X				s->ypos = Stars[s->storbits]->ypos + p->ypos +
X					(double) int_rand((int) (-DIST_TO_LAND / 4), (int) (DIST_TO_LAND / 4));
X
X				/* subtract fuel from ship */
X				fuel = gravity(p) * s->mass * LAUNCH_GRAV_MASS_FACTOR;
X				if (s->fuel < fuel) {
X					sprintf(buf, "%s does not have enough fuel! (%.1f)\n",
X						Ship(s), fuel);
X					notify(Playernum, Governor, buf);
X					free(p);
X					free(s);
X					return;
X				}
X				use_fuel(s, fuel);
X				s->docked = 0;
X				s->whatdest = LEVEL_UNIV;	/* no destination */
X				switch (s->type) {
X				case OTYPE_CANIST:
X				case OTYPE_GREEN:
X					s->special.timer.count = 0;
X					break;
X				default:
X					break;
X				}
X				s->notified = 0;
X				putship(s);
X				if (!p->explored) {
X					/*
X					 * not yet explored by owner; space
X					 * exploration causes the player to
X					 * see a whole map
X					 */
X					p->explored = 1;
X					putplanet(p, (int) s->storbits, (int) s->pnumorbits);
X				}
X				sprintf(buf, "%s observed launching from planet /%s/%s.\n",
X					Ship(s), Stars[s->storbits]->name,
X				 Stars[s->storbits]->pnames[s->pnumorbits]);
X				for (i = 1; i <= Num_races; i++)
X					if (p->info[i - 1].numsectsowned && i != Playernum)
X						notify(i, (int) Stars[s->storbits]->governor[i - 1], buf);
X				free(p);
X
X				sprintf(buf, "%s launched from planet,", Ship(s));
X				notify(Playernum, Governor, buf);
X				sprintf(buf, " using %.1f fuel.\n", fuel);
X				notify(Playernum, Governor, buf);
X
X				switch (s->type) {
X				case OTYPE_CANIST:
X					notify(Playernum, Governor, "A cloud of dust envelopes your planet.\n");
X					break;
X				case OTYPE_GREEN:
X					notify(Playernum, Governor, "Green house gases surround the planet.\n");
X					break;
X				default:
X					break;
X				}
X				free(s);
X			}
X		} else
X			free(s);
X}
END_OF_FILE
if test 7962 -ne `wc -c <'user/launch.c'`; then
    echo shar: \"'user/launch.c'\" unpacked with wrong size!
fi
# end of 'user/launch.c'
fi
if test -f 'utils/GB_racegen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/GB_racegen.c'\"
else
echo shar: Extracting \"'utils/GB_racegen.c'\" \(9313 characters\)
sed "s/^X//" >'utils/GB_racegen.c' <<'END_OF_FILE'
X/* GB_enroll.c -- GB file interace for GB race enrollment program.
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, 
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h.
X * Restrictions in GB_copyright.h.
X */
X#include <signal.h>
X#include "GB_copyright.h"
X
X#define EXTERN
X#include "vars.h"
X#include "power.h"
X#include "ships.h"
X#include "shipdata.h"
X#include "races.h"
X#include "buffers.h"
X
X#include "racegen.h"
X
Xextern int errno;
Xracetype *Race;
X
X
Xint planet_translate[N_HOME_PLANET_TYPES] =  {0, 6, 7, 5, 2, 3, 4} ;
X
X
X
X#ifdef __STDC__
Xvoid srandom(int seed) ;
Xlong random(void) ;
X
Xint getpid(void) ;
X
Xvoid modify_print_loop(int level) ;
X
X
X 
X#else
X#define const
X#endif
X
Xvoid notify(who, gov, msg)
X     int who, gov;
Xchar *msg;
X{
X  /* this is a dummy routine */
X  }
X
Xvoid warn(who, gov, msg)
X     int who, gov;
Xchar *msg;
X{
X  /* this is a dummy routine */
X  }
X
Xvoid push_message(what, who, msg)
X     int what, who;
Xchar *msg;
X{
X  /* this is a dummy routine */
X  }
X
X
Xvoid init_enroll()
X{
X  srandom(getpid()) ;
X  }
X
X
X/* 
X * Returns 0 if successfully enrolled, or 1 if failure. */
Xint enroll_valid_race()
X{
X  int mask, x, y, star, pnum, i, ppref, Playernum ;
X  int last_star_left, indirect[NUMSTARS] ;
X  sectortype *sect;
X  planettype *planet;
X  startype *star_arena;
X/*
X  if (race.status == STATUS_ENROLLED) {
X    sprintf(race.rejection, "This race has already been enrolled!\n") ;
X    return 1 ;
X    }
X*/
X  open_data_files();	
X  Playernum = Numraces() + 1 ;
X  if ((Playernum == 1) && (race.priv_type != P_GOD)) {
X    close_data_files() ;
X    sprintf(race.rejection,
X	   "The first race enrolled must have God privileges.\n") ;
X    return 1 ;
X    }
X  if (Playernum >= MAXPLAYERS) {
X    close_data_files() ;
X    sprintf(race.rejection,
X	   "There are already %d players; No more allowed.\n", MAXPLAYERS-1);
X    race.status = STATUS_UNENROLLABLE ;
X    return 1 ;
X    }
X
X  getsdata(&Sdata);
X  star_arena = (startype *)malloc(Sdata.numstars * sizeof(startype));
X  for (star=0; star<Sdata.numstars; star++) {
X    Stars[star] = &star_arena[star];
X    getstar(&(Stars[star]),star);
X    }
X
X  printf("Looking for %s..", planet_print_name[race.home_planet_type]);
X  fflush(stdout) ;
X
X  ppref = planet_translate[race.home_planet_type] ;
X  for (i=0; i < Sdata.numstars; i++)
X    indirect[i] = i ;
X  last_star_left = Sdata.numstars - 1 ;
X  while (last_star_left >= 0) {
X    i = int_rand(0, last_star_left) ;
X    star = indirect[i] ;
X
X    printf(".", star) ;
X    fflush(stdout) ;
X    /* 
X     * Skip over inhabited stars and stars with few planets. */
X    if ((Stars[star]->numplanets < 2) ||
X	Stars[star]->inhabited[0] || Stars[star]->inhabited[1]) {
X      }
X    else {
X      /* look for uninhabited planets */
X      for (pnum = 0; pnum < Stars[star]->numplanets; pnum++) {
X	getplanet(&planet, star, pnum) ;
X	if ((planet->type == ppref) &&
X	    (planet->conditions[RTEMP] >= -200) && 
X	    (planet->conditions[RTEMP] <= 100))
X	  goto found_planet ;
X	free(planet);
X	}
X      }
X    /*
X     * Since we are here, this star didn't work out: */
X    indirect[i] = indirect[last_star_left--] ;
X    }
X
X  /*
X   * If we get here, then we did not find any good planet. */
X  printf(" failed!\n") ;
X  sprintf(race.rejection,
X	  "Didn't find any free %s; choose another home planet type.\n",
X	  planet_print_name[race.home_planet_type]);
X  close_data_files();
X  race.status = STATUS_UNENROLLABLE ;
X  return 1 ;
X
X found_planet:
X  printf(" found!\n") ;
X  Race = Malloc(racetype);
X  Bzero(*Race);
X
X  Race->Playernum = Playernum ;
X  Race->God   = (race.priv_type == P_GOD) ;
X  Race->Guest = (race.priv_type == P_GUEST) ;
X  strcpy(Race->name, race.name) ;
X  strcpy(Race->password, race.password) ;
X
X  strcpy(Race->governor[0].password, "0");
X  Race->governor[0].homelevel = Race->governor[0].deflevel = LEVEL_PLAN;
X  Race->governor[0].homesystem = Race->governor[0].defsystem = star;
X  Race->governor[0].homeplanetnum = Race->governor[0].defplanetnum = pnum;
X  /* display options */
X  Race->governor[0].toggle.highlight = Playernum;
X  Race->governor[0].toggle.inverse = 1;
X  Race->governor[0].toggle.color = 0;
X  Race->governor[0].active = 1;
X
X  for (i=0; i<=OTHER; i++)
X    Race->conditions[i] = planet->conditions[i];
X#if 0
X  /* make conditions preferred by your people set to (more or less) 
X     those of the planet : higher the concentration of gas, the higher
X     percentage difference between planet and race */
X  for (j=0; j<=OTHER; j++)
X    Race->conditions[j] = planet->conditions[j]
X      + int_rand(round_rand(-planet->conditions[j]*2.0), 
X		 round_rand(planet->conditions[j]*2.0) ) ;
X#endif
X
X  for (i=0; i<MAXPLAYERS; i++) {
X    /* messages from autoreport, player #1 are decodable */
X    if ((i==Playernum) || (Playernum==1) || Race->God)
X      Race->translate[i-1] = 100;  /* you can talk to own race */
X    else
X      Race->translate[i-1] = 1;
X    }
X
X#if 0
X  /* All of the following zeros are not really needed, because the race
X     was bzero'ed out above. */
X  for (i=0; i<80; i++)
X    Race->discoveries[i] = 0;
X  Race->tech = 0.0;
X  Race->morale = 0;
X  Race->turn = 0;
X  Race->allied[0] = Race->allied[1] = 0;
X  Race->atwar[0] = Race->atwar[1] = 0;
X  for (i=0; i<MAXPLAYERS; i++) 
X    Race->points[i]=0;
X#endif
X
X  /* 
X   * Assign racial characteristics. */
X  Race->absorb        = race.attr[ABSORB] ;
X  Race->collective_iq = race.attr[COL_IQ] ;
X  Race->Metamorph     = (race.race_type == R_METAMORPH) ;
X  Race->pods          = race.attr[PODS] ;
X  
X  Race->fighters      = race.attr[FIGHT] ;
X  if (race.attr[COL_IQ] == 1.0)
X    Race->IQ_limit    = race.attr[A_IQ] ;
X  else
X    Race->IQ          = race.attr[A_IQ] ;
X  Race->number_sexes  = race.attr[SEXES] ;
X
X  Race->fertilize     = race.attr[FERT] * 100;
X
X  Race->adventurism   = race.attr[ADVENT] ;
X  Race->birthrate     = race.attr[BIRTH] ;
X  Race->mass          = race.attr[MASS] ;
X  Race->metabolism    = race.attr[METAB] ;
X
X  /* 
X   * Assign sector compats and determine a primary sector type. */
X  for (i = FIRST_SECTOR_TYPE; i<=LAST_SECTOR_TYPE; i++) {
X    Race->likes[i] = race.compat[i] / 100.0 ;
X    if ((100 == race.compat[i]) &&
X	(1.0 == planet_compat_cov[race.home_planet_type][i]))
X      Race->likesbest = i ;
X    }
X
X  /*
X   * Find sector to build capital on, and populate it: */
X  getsmap(Smap,planet);
X  PermuteSects(planet);
X  Getxysect(planet, 0, 0, 1);
X  while (i = Getxysect(planet, &x, &y, 0))
X    if (Sector(*planet, x, y).condition == Race->likesbest)
X      break ;
X  if (! i)
X    x = y = 0 ;
X  sect = &Sector(*planet, x, y) ;
X  sect->owner = Playernum ;
X  sect->race = Playernum;
X  sect->popn = planet->popn = Race->number_sexes ;
X  sect->fert = 100 ;
X  sect->eff = 10 ;
X  sect->troops = planet->troops = 0;
X
X  Race->governors = 0;
X  
X  mask = sigblock(SIGBLOCKS);
X  /* build a capital ship to run the government */
X  {
X  shiptype s;
X  int shipno;
X  
X  Bzero(s);
X  shipno = Numships() + 1;
X  Race->Gov_ship = shipno;
X  planet->ships = shipno;
X  s.nextship = 0;
X  
X  s.type = OTYPE_GOV;
X  s.xpos = Stars[star]->xpos + planet->xpos;
X  s.ypos = Stars[star]->ypos + planet->ypos;
X  s.land_x = x ;
X  s.land_y = y ;
X  
X  s.speed = 0;
X  s.owner = Playernum;
X  s.race = Playernum;
X  s.governor = 0;
X  
X  s.tech = 100.0;
X  
X  s.build_type = OTYPE_GOV;
X  s.armor = Shipdata[OTYPE_GOV][ABIL_ARMOR];
X  s.guns = PRIMARY;
X  s.primary = Shipdata[OTYPE_GOV][ABIL_GUNS];
X  s.primtype = Shipdata[OTYPE_GOV][ABIL_PRIMARY];
X  s.secondary = Shipdata[OTYPE_GOV][ABIL_GUNS];
X  s.sectype = Shipdata[OTYPE_GOV][ABIL_SECONDARY];
X  s.max_crew = Shipdata[OTYPE_GOV][ABIL_MAXCREW];
X  s.max_destruct = Shipdata[OTYPE_GOV][ABIL_DESTCAP];
X  s.max_resource = Shipdata[OTYPE_GOV][ABIL_CARGO];
X  s.max_fuel = Shipdata[OTYPE_GOV][ABIL_FUELCAP];
X  s.max_speed = Shipdata[OTYPE_GOV][ABIL_SPEED];
X  s.build_cost = Shipdata[OTYPE_GOV][ABIL_COST];
X  s.size = 100;
X  s.base_mass = 100.0;
X  sprintf(s.class, "Standard");
X  
X  s.fuel = 0.0;
X  s.popn = Shipdata[s.type][ABIL_MAXCREW];
X  s.troops = 0;
X  s.mass = s.base_mass + Shipdata[s.type][ABIL_MAXCREW]*Race->mass;
X  s.destruct = s.resource = 0;
X  
X  s.alive = 1;
X  s.active = 1;
X  s.protect.self = 1;
X  
X  s.docked = 1;
X  /* docked on the planet */
X  s.whatorbits = LEVEL_PLAN;
X  s.whatdest = LEVEL_PLAN;
X  s.deststar = star;
X  s.destpnum = pnum;
X  s.storbits = star;
X  s.pnumorbits = pnum;
X  s.rad = 0;
X  s.damage = 0;  /*Shipdata[s.type][ABIL_DAMAGE];*/
X  /* (first capital is 100% efficient */
X  s.retaliate = 0;
X  
X  s.ships = 0;
X  
X  s.on = 1;
X  
X  s.name[0] = '\0';
X  s.number = shipno;
X  putship(&s);
X  }
X
X  putrace(Race);
X
X  planet->info[Playernum-1].numsectsowned = 1;
X  planet->explored = 0;
X  planet->info[Playernum-1].explored = 1;
X  /*planet->info[Playernum-1].autorep = 1;*/
X
X  planet->maxpopn = maxsupport(Race, sect, 100.0,0)
X      * planet->Maxx * planet->Maxy / 2;
X  /* (approximate) */
X
X  putsector(sect, planet, x, y) ;
X  putplanet(planet,star,pnum);
X
X  /* make star explored and stuff */
X  getstar(&Stars[star],star);
X  setbit(Stars[star]->explored,Playernum);
X  setbit(Stars[star]->inhabited,Playernum);
X  Stars[star]->AP[Playernum-1] = 5;
X  putstar(Stars[star],star);
X  close_data_files();
X
X  sigsetmask(mask);
X
X  printf("Player %d (%s) created on sector %d,%d on %s/%s.\n", Playernum, 
X	 race.name, x, y, Stars[star]->name, Stars[star]->pnames[pnum]);
X  race.status = STATUS_ENROLLED ;
X  return 0 ;
X  }
END_OF_FILE
if test 9313 -ne `wc -c <'utils/GB_racegen.c'`; then
    echo shar: \"'utils/GB_racegen.c'\" unpacked with wrong size!
fi
# end of 'utils/GB_racegen.c'
fi
if test -f 'utils/exship.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/exship.c'\"
else
echo shar: Extracting \"'utils/exship.c'\" \(6945 characters\)
sed "s/^X//" >'utils/exship.c' <<'END_OF_FILE'
X#ident  "@(#)exship.c	1.3 1/7/93 "
X/***********************************************
X * exship.c
X *
X * Created: Fri Jan  1 19:34:23 EST 1993
X * Author:  J. Deragon (deragon@jethro.nyu.edu)
X *
X * Version: 1.3 17:02:19
X *
X *	This software is provided "as is" and without any express or
X *	implied warranties, including, without limitation, the implied
X *	warranties of merchantibility and fitness for a particular
X *	purpose.
X *
X ***********************************************/
X
X/*
X * includes
X */
X#include <strings.h>
X#include <signal.h>
X#include <sys/file.h>
X#include <errno.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "shipdata.h"
X
X
X#define DATAFILE "ship"
X
X/*
X * Prototypes
X */
X
Xvoid            check_ship();
Xvoid            check_size();
Xvoid            display_ship();
X#ifdef __STDC__
Xvoid            main(int, char **);
Xvoid            readship(shiptype **, int);
X#else
Xvoid            main();
Xvoid            readship();
X#endif
X
X
X/*
X * Global vars
X */
X
Xstatic int      ship_fd;	/* the file descriptor of the datafile     */
Xstruct stat     buffer;		/* used for getting the size of the file   */
Xint             num_ships;	/* number of total ships in database       */
Xint             bad_ship_count = 0;	/* the number of bad ships in the
X					 * database */
Xshiptype       *display;	/* this ship we are currently working on   */
X
X/*
X * main:
X * 
X * arguments: shipnumber
X * 
X * called by:
X * 
X * description:  If invoked with zero arguments, it will open the ship datafile
X * and go through looking for obvious errors. If invoked with a ship number
X * it will print out a very verbose listing of the requested ship.
X * 
X */
Xvoid
Xmain(argc, argv)
X	int             argc;
X	char           *argv[];
X{
X	int             i;
X
X	if ((ship_fd = open(DATAFILE, 000, 0777)) < 0) {
X		perror(main);
X		printf("unable to open %s\n", DATAFILE);
X		exit(-1);
X	}
X	check_size();
X
X	if (argc == 1) {	/* check the whole database for errors */
X		for (i = 1; i <= num_ships; i++) {
X			readship(&display, i);
X			check_ship();
X			free(display);
X		}
X		printf("I found a total of %d bad ships out of %d\n",
X		       bad_ship_count, num_ships);
X	} else {		/* we want a specific ship display */
X		readship(&display, atoi(argv[1]));
X		display_ship();
X	}
X	printf("All Done \n");
X
X	exit(3);
X}
X
X/*
X * readship:
X * 
X * arguments: shiptype structure, shipnumber
X * 
X * called by:
X * 
X * description:  This funtion reads the actual data from the file.
X * 
X */
X
Xvoid
Xreadship(s, shipnum)
X	shiptype      **s;
X	int             shipnum;
X{
X	int             n;
X
X	if (shipnum <= 0)
X		exit(1);
X
X	if ((*s = (shiptype *) malloc(sizeof(shiptype))) == 0) {
X		printf("getship:Malloc() error\n");
X		exit(0);
X	}
X	if (lseek(ship_fd, (shipnum - 1) * sizeof(shiptype), L_SET) < 0) {
X		perror(lseek);
X		exit(1);
X	}
X	if ((n = read(ship_fd, (char *) *s, sizeof(shiptype))) != sizeof(shiptype))
X		perror(read);
X
X
X
X}
X
X/*
X * check_size:
X * 
X * arguments: none
X * 
X * called by: main
X * 
X * description:  gets the number of ships in the current database
X * 
X */
Xvoid
Xcheck_size()
X{
X
X
X	fstat(ship_fd, &buffer);
X	num_ships = buffer.st_size / sizeof(shiptype);
X	printf("Number of ships in database is %d\n", num_ships);
X}
X
X/*
X * check_ship:
X * 
X * arguments: none
X * 
X * called by: main
X * 
X * description:  checks basic cargo to make sure its within limits of ships
X * ability.
X * 
X */
Xvoid
Xcheck_ship()
X{
X	int             ship_ok = 1;
X	int             pop, troops, res, des, fu, speed, hanger;
X
X	pop = troops = res = des = fu = speed = hanger = 1;
X
X	if (display->type == OTYPE_FACTORY) {
X		if (display->popn > Shipdata[(display)->type][ABIL_MAXCREW])
X			ship_ok = pop = 0;
X		if (display->troops > Shipdata[(display)->type][ABIL_MAXCREW])
X			ship_ok = troops = 0;
X		if ((display->popn + display->troops) >
X		    Shipdata[(display)->type][ABIL_MAXCREW])
X			ship_ok = pop = troops = 0;
X	} else {
X		if (display->popn > display->max_crew)
X			ship_ok = pop = 0;
X		if (display->troops > display->max_crew)
X			ship_ok = troops = 0;
X		if ((display->popn + display->troops) > display->max_crew)
X			ship_ok = pop = troops = 0;
X	}
X	if (display->resource > Max_resource(display))
X		ship_ok = res = 0;
X	if (display->destruct > Max_destruct(display))
X		ship_ok = des = 0;
X	if ((int) display->fuel > Max_fuel(display))
X		ship_ok = fu = 0;
X	if (display->speed > Max_speed(display))
X		ship_ok = speed = 0;
X	if (display->hanger > display->max_hanger)
X		ship_ok = hanger = 0;
X
X	if (!ship_ok) {
X		bad_ship_count++;
X
X		printf("Problem with ship number %d\n", display->number);
X		printf("\t\tOwner: %d\n", display->owner);
X		printf("\t\tGovernor: %d\n", display->governor);
X		printf("\t\tName: %s\n", display->name);
X		printf("\t\tType: %c\n", Shipltrs[display->type]);
X		printf("\n");
X
X		printf("\t %s popn: %d\t max_popn: %d:\n",
X		pop ? "      " : "----->", display->popn, display->max_crew);
X		printf("\t %s troops: %d\t max_troops: %d\n",
X		       troops ? "      " : "----->", display->troops, display->max_crew);
X		printf("\t %s resources: %d\t max_resources: %d\n",
X		       res ? "      " : "----->", display->resource,
X		       display->max_resource);
X		printf("\t %s destruct: %d\t max_destruct: %d\n",
X		       des ? "      " : "----->", display->destruct,
X		       display->max_destruct);
X		printf("\t %s fuel: %d\t max_fuel: %d\n",
X		       fu ? "      " : "----->", (int) display->fuel,
X		       (int) display->max_fuel);
X		printf("\t %s speed: %d\t max_speed: %d\n",
X		       speed ? "      " : "----->", display->speed, display->max_speed);
X		printf("\t %s hanger: %d\t max_hanger: %d\n",
X		       hanger ? "      " : "----->", display->hanger,
X		       display->max_hanger);
X	}
X}
X
X/*
X * display_ship:
X * 
X * arguments: none
X * 
X * called by: main
X * 
X * description:  Prints a _long_ description a a specific ship.
X * 
X */
Xvoid
Xdisplay_ship()
X{
X	printf("Ship Number: %d\tShip Type: %c\tShip Owner: %d\tShip Governor %d\n",
X	       display->number, Shipltrs[display->type],
X	       display->owner, display->governor);
X	printf("Ship Name: %s\n", display->name);
X
X	printf("\nCrew: %-9d\t  Troops: %-6d\tArmor: %d\n",
X	       display->popn, display->troops, display->armor);
X	printf("Size: %-9d\t  Base Mass: %-4.1f\tBase Tech: %4.1f\n",
X	       display->size, display->base_mass, display->tech);
X	printf("Destruct: %-6d  Resources: %-6d\tCrystals: %d\n",
X	       display->destruct, display->resource, display->crystals);
X	printf("Fuel: 4.1f\n", display->fuel);
X	printf("\n");
X	printf("Guns:\tPrimary: %-3d%c\n", display->primary,
X	       (display->primtype == LIGHT ? 'L' :
X		display->primtype == MEDIUM ? 'M' :
X		display->primtype == HEAVY ? 'H' : 'N'));
X	printf("     \tSecondary:  %-3d%c\n", display->primary,
X	       (display->primtype == LIGHT ? 'L' :
X		display->primtype == MEDIUM ? 'M' :
X		display->primtype == HEAVY ? 'H' : 'N'));
X
X	printf("\nNextship: %-6d\t (%s)\n", display->nextship,
X	       display->alive ? "ALIVE" : "DEAD");
X}
END_OF_FILE
if test 6945 -ne `wc -c <'utils/exship.c'`; then
    echo shar: \"'utils/exship.c'\" unpacked with wrong size!
fi
# end of 'utils/exship.c'
fi
echo shar: End of archive 17 \(of 21\).
cp /dev/null ark17isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
