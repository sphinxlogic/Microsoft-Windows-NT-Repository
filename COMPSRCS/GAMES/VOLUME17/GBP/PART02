Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i014:  gbp - Galactic Bloodshed+, an empire-like war game, Part02/21
Message-ID: <4542@master.CNA.TEK.COM>
Date: 12 Feb 93 17:29:51 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1832
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1693

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 14
Archive-name: gbp/Part02
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 21)."
# Contents:  server/perm.c user/build.c2
# Wrapped by billr@saab on Fri Feb 12 09:14:23 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'server/perm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/perm.c'\"
else
echo shar: Extracting \"'server/perm.c'\" \(1355 characters\)
sed "s/^X//" >'server/perm.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * perm.c -- randomly permute a sector list
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X
X#include "races.h"
X#include "ships.h"
X#include "power.h"
X#include "proto.h"
X
Xstruct map {
X	char            x, y;
X}               xymap[(MAX_X + 1) * (MAX_Y + 1)];
X
Xvoid            PermuteSects(planettype *);
Xint             Getxysect(planettype *, int *, int *, int);
X
X/* make a random list of sectors. */
Xvoid 
XPermuteSects(planettype * planet)
X{
X	register int    i, j, x, y, t;
X	struct map      sw;
X
X	t = planet->Maxy * planet->Maxx;
X
X	for (i = x = y = 0; i < t; i++) {
X		xymap[i].x = x;
X		xymap[i].y = y;
X		if (++x >= planet->Maxx)
X			x = 0, y++;
X	}
X	for (i = 0; i < t; i++) {
X		sw = xymap[i];
X		xymap[i] = xymap[j = int_rand(0, t - 1)];
X		xymap[j] = sw;
X	}
X}
X
X/*
X * get the next x,y sector in the list.  if r=1, reset the counter. *
X * increments the counter & returns whether or not this reset it to 0.
X */
X
Xint 
XGetxysect(reg planettype * p, reg int *x, reg int *y, reg int r)
X{
X	static int      getxy, max;
X
X	if (r) {
X		getxy = 0;
X		max = p->Maxx * p->Maxy;
X	} else {
X		*x = xymap[getxy].x;
X		*y = xymap[getxy].y;
X		if (++getxy > max)
X			getxy = 0;
X	}
X	return getxy;
X}
END_OF_FILE
if test 1355 -ne `wc -c <'server/perm.c'`; then
    echo shar: \"'server/perm.c'\" unpacked with wrong size!
fi
# end of 'server/perm.c'
fi
if test -f 'user/build.c2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/build.c2'\"
else
echo shar: Extracting \"'user/build.c2'\" \(51681 characters\)
sed "s/^X//" >'user/build.c2' <<'END_OF_FILE'
Xvoid 
Xmake_mod(int Playernum, int Governor, int APcount, int mode)
X{
X	int             i, value;
X	unsigned short  size;
X	char            shipc;
X	shiptype       *dirship;
X	racetype       *Race;
X	double          cost0;
X
X	if (Dir[Playernum - 1][Governor].level != LEVEL_SHIP) {
X		notify(Playernum, Governor, "You have to change scope to an installation.\n");
X		return;
X	}
X	if (!getship(&dirship, Dir[Playernum - 1][Governor].shipno)) {
X		sprintf(buf, "Illegal dir value.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	if (testship(Playernum, Governor, dirship)) {
X		free(dirship);
X		return;
X	}
X	if (dirship->type != OTYPE_FACTORY) {
X		notify(Playernum, Governor, "That is not a factory.\n");
X		free(dirship);
X		return;
X	}
X	if (dirship->on && argn > 1) {
X		notify(Playernum, Governor, "This factory is already online.\n");
X		free(dirship);
X		return;
X	}
X	Race = races[Playernum - 1];
X
X	/*
X	 * Save  size of the factory, and set it to the correct values for
X	 * the design.  Maarten
X	 */
X	size = dirship->size;
X	dirship->size = ship_size(dirship);
X
X	if (mode == 0) {
X		if (argn < 2) {	/* list the current settings for the factory */
X			if (!dirship->build_type) {
X				notify(Playernum, Governor, "No ship type specified.\n");
X				free(dirship);
X				return;
X			}
X			notify(Playernum, Governor, "  --- Current Production Specifications ---\n");
X			sprintf(buf, "%s\t\t\tArmor:    %4d\t\tGuns:",
X				(dirship->on ? "Online" : "Offline"), dirship->armor);
X			notify(Playernum, Governor, buf);
X			if (Shipdata[dirship->build_type][ABIL_PRIMARY] &&
X			    dirship->primtype != NONE) {
X				sprintf(buf, "%3d%c", dirship->primary,
X					(dirship->primtype == LIGHT ? 'L' :
X					 dirship->primtype == MEDIUM ? 'M' :
X				   dirship->primtype == HEAVY ? 'H' : 'N'));
X				notify(Playernum, Governor, buf);
X			}
X			if (Shipdata[dirship->build_type][ABIL_SECONDARY] &&
X			    dirship->sectype != NONE) {
X				sprintf(buf, "/%d%c", dirship->secondary,
X					(dirship->sectype == LIGHT ? 'L' :
X					 dirship->sectype == MEDIUM ? 'M' :
X				    dirship->sectype == HEAVY ? 'H' : 'N'));
X				notify(Playernum, Governor, buf);
X			}
X			notify(Playernum, Governor, "\n");
X			sprintf(buf, "Ship:  %-16.16s\tCrew:     %4d",
X			 Shipnames[dirship->build_type], dirship->max_crew);
X			notify(Playernum, Governor, buf);
X			if (Shipdata[dirship->build_type][ABIL_MOUNT]) {
X				sprintf(buf, "\t\tXtal Mount: %s\n",
X					(dirship->mount ? "yes" : "no"));
X				notify(Playernum, Governor, buf);
X			} else
X				notify(Playernum, Governor, "\n");
X			sprintf(buf, "Class: %s\t\tFuel:     %4d",
X				dirship->class, dirship->max_fuel);
X			notify(Playernum, Governor, buf);
X			if (Shipdata[dirship->build_type][ABIL_JUMP]) {
X				sprintf(buf, "\t\tHyperdrive: %s\n",
X				 (dirship->hyper_drive.has ? "yes" : "no"));
X				notify(Playernum, Governor, buf);
X			} else
X				notify(Playernum, Governor, "\n");
X			sprintf(buf, "Cost:  %d r\t\tCargo:    %4d",
X				dirship->build_cost, dirship->max_resource);
X			notify(Playernum, Governor, buf);
X			if (Shipdata[dirship->build_type][ABIL_LASER]) {
X				sprintf(buf, "\t\tCombat Lasers: %s\n",
X					(dirship->laser ? "yes" : "no"));
X				notify(Playernum, Governor, buf);
X			} else
X				notify(Playernum, Governor, "\n");
X			sprintf(buf, "Mass:  %.1f\t\tHanger:   %4u",
X				dirship->base_mass, dirship->max_hanger);
X			notify(Playernum, Governor, buf);
X			if (Shipdata[dirship->build_type][ABIL_CEW]) {
X				sprintf(buf, "\t\tCEW: %s\n",
X					(dirship->cew ? "yes" : "no"));
X				notify(Playernum, Governor, buf);
X			} else
X				notify(Playernum, Governor, "\n");
X			sprintf(buf, "Size:  %-6d\t\tDestruct: %4d",
X				dirship->size, dirship->max_destruct);
X			notify(Playernum, Governor, buf);
X			if (Shipdata[dirship->build_type][ABIL_CEW] && dirship->cew) {
X				sprintf(buf, "\t\t   Opt Range: %4d\n", dirship->cew_range);
X				notify(Playernum, Governor, buf);
X			} else
X				notify(Playernum, Governor, "\n");
X			sprintf(buf, "Tech:  %.1f (%.1f)\tSpeed:    %4d",
X			dirship->complexity, Race->tech, dirship->max_speed);
X			notify(Playernum, Governor, buf);
X			if (Shipdata[dirship->build_type][ABIL_CEW] && dirship->cew) {
X				sprintf(buf, "\t\t   Energy:    %4d\n", dirship->cew);
X				notify(Playernum, Governor, buf);
X			} else
X				notify(Playernum, Governor, "\n");
X
X			if (Race->tech < dirship->complexity)
X				notify(Playernum, Governor, "Your engineering capability is not advanced enough to produce this design.\n");
X			free(dirship);
X			return;
X		}
X		shipc = args[1][0];
X
X		i = 0;
X		while ((Shipltrs[i] != shipc) && (i < NUMSTYPES))
X			i++;
X
X		if ((i >= NUMSTYPES) || ((i == STYPE_POD) && (!Race->pods))) {
X			sprintf(buf, "Illegal ship letter.\n");
X			notify(Playernum, Governor, buf);
X			free(dirship);
X			return;
X		}
X		if (!(Shipdata[i][ABIL_BUILD] & Shipdata[OTYPE_FACTORY][ABIL_CONSTRUCT])) {
X			notify(Playernum, Governor, "This kind of ship does not require a factory to construct.\n");
X			free(dirship);
X			return;
X		}
X		dirship->build_type = i;
X		dirship->armor = Shipdata[i][ABIL_ARMOR];
X		dirship->guns = NONE;	/* this keeps track of the factory
X					 * status! */
X		dirship->primary = Shipdata[i][ABIL_GUNS];
X		dirship->primtype = Shipdata[i][ABIL_PRIMARY];
X		dirship->secondary = Shipdata[i][ABIL_GUNS];
X		dirship->sectype = Shipdata[i][ABIL_SECONDARY];
X		dirship->max_crew = Shipdata[i][ABIL_MAXCREW];
X		dirship->max_resource = Shipdata[i][ABIL_CARGO];
X		dirship->max_hanger = Shipdata[i][ABIL_HANGER];
X		dirship->max_fuel = Shipdata[i][ABIL_FUELCAP];
X		dirship->max_destruct = Shipdata[i][ABIL_DESTCAP];
X		dirship->max_speed = Shipdata[i][ABIL_SPEED];
X
X		dirship->mount = Shipdata[i][ABIL_MOUNT] * Crystal(Race);
X		dirship->hyper_drive.has = Shipdata[i][ABIL_JUMP] * Hyper_drive(Race);
X		dirship->cloak = Shipdata[i][ABIL_CLOAK] * Cloak(Race);
X		dirship->laser = Shipdata[i][ABIL_LASER] * Laser(Race);
X		dirship->cew = 0;
X		dirship->mode = 0;
X
X		dirship->size = ship_size(dirship);
X		dirship->complexity = complexity(dirship);
X
X		sprintf(dirship->class, "mod %d", Dir[Playernum - 1][Governor].shipno);
X
X		sprintf(buf, "Factory designated to produce %ss.\n", Shipnames[i]);
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Design complexity %.1f (%.1f).\n", dirship->complexity,
X			Race->tech);
X		notify(Playernum, Governor, buf);
X		if (dirship->complexity > Race->tech)
X			notify(Playernum, Governor, "You can't produce this design yet!\n");
X
X	} else if (mode == 1) {
X
X		if (!dirship->build_type) {
X			notify(Playernum, Governor, "No ship design specified. Use 'make <ship type>' first.\n");
X			free(dirship);
X			return;
X		}
X		if (argn < 2) {
X			notify(Playernum, Governor, "You have to specify the characteristic you wish to modify.\n");
X			free(dirship);
X			return;
X		}
X		if (argn == 3)
X			sscanf(args[2], "%d", &value);
X		else
X			value = 0;
X
X		if (value < 0) {
X			notify(Playernum, Governor, "That's a ridiculous setting.\n");
X			free(dirship);
X			return;
X		}
X		if (Shipdata[dirship->build_type][ABIL_MOD]) {
X
X			if (match(args[1], "armor")) {
X				dirship->armor = MIN(value, 100);
X			} else if (match(args[1], "crew")
X			   && Shipdata[dirship->build_type][ABIL_MAXCREW]) {
X				dirship->max_crew = MIN(value, 10000);
X			} else if (match(args[1], "cargo")
X			     && Shipdata[dirship->build_type][ABIL_CARGO]) {
X				dirship->max_resource = MIN(value, 10000);
X			} else if (match(args[1], "hanger")
X			    && Shipdata[dirship->build_type][ABIL_HANGER]) {
X				dirship->max_hanger = MIN(value, 10000);
X			} else if (match(args[1], "fuel")
X			   && Shipdata[dirship->build_type][ABIL_FUELCAP]) {
X				dirship->max_fuel = MIN(value, 10000);
X			} else if (match(args[1], "destruct")
X			   && Shipdata[dirship->build_type][ABIL_DESTCAP]) {
X				dirship->max_destruct = MIN(value, 10000);
X			} else if (match(args[1], "speed")
X			     && Shipdata[dirship->build_type][ABIL_SPEED]) {
X				dirship->max_speed = MAX(1, MIN(value, 9));
X			} else if (match(args[1], "mount")
X				&& Shipdata[dirship->build_type][ABIL_MOUNT]
X				   && Crystal(Race)) {
X				dirship->mount = !dirship->mount;
X			} else if (match(args[1], "hyperdrive")
X				 && Shipdata[dirship->build_type][ABIL_JUMP]
X				   && Hyper_drive(Race)) {
X				dirship->hyper_drive.has = !dirship->hyper_drive.has;
X			} else if (match(args[1], "primary")
X			   && Shipdata[dirship->build_type][ABIL_PRIMARY]) {
X				if (match(args[2], "strength")) {
X					dirship->primary = atoi(args[3]);
X				} else if (match(args[2], "caliber")) {
X					if (match(args[3], "light"))
X						dirship->primtype = LIGHT;
X					else if (match(args[3], "medium"))
X						dirship->primtype = MEDIUM;
X					else if (match(args[3], "heavy"))
X						dirship->primtype = HEAVY;
X					else {
X						notify(Playernum, Governor, "No such caliber.\n");
X						free(dirship);
X						return;
X					}
X					dirship->primtype = MIN(Shipdata[dirship->build_type][ABIL_PRIMARY],
X							 dirship->primtype);
X				} else {
X					notify(Playernum, Governor, "No such gun characteristic.\n");
X					free(dirship);
X					return;
X				}
X			} else if (match(args[1], "secondary")
X			 && Shipdata[dirship->build_type][ABIL_SECONDARY]) {
X				if (match(args[2], "strength")) {
X					dirship->secondary = atoi(args[3]);
X				} else if (match(args[2], "caliber")) {
X					if (match(args[3], "light"))
X						dirship->sectype = LIGHT;
X					else if (match(args[3], "medium"))
X						dirship->sectype = MEDIUM;
X					else if (match(args[3], "heavy"))
X						dirship->sectype = HEAVY;
X					else {
X						notify(Playernum, Governor, "No such caliber.\n");
X						free(dirship);
X						return;
X					}
X					dirship->sectype = MIN(Shipdata[dirship->build_type][ABIL_SECONDARY],
X							  dirship->sectype);
X				} else {
X					notify(Playernum, Governor, "No such gun characteristic.\n");
X					free(dirship);
X					return;
X				}
X			} else if (match(args[1], "cew")
X			       && Shipdata[dirship->build_type][ABIL_CEW]) {
X				if (!Cew(Race)) {
X					sprintf(buf, "Your race does not understand confined energy weapons.\n");
X					notify(Playernum, Governor, buf);
X					free(dirship);
X					return;
X				}
X				if (!Shipdata[dirship->build_type][ABIL_CEW]) {
X					notify(Playernum, Governor, "This kind of ship cannot mount confined energy weapons.\n");
X					free(dirship);
X					return;
X				}
X				value = atoi(args[3]);
X				if (match(args[2], "strength")) {
X					dirship->cew = value;
X				} else if (match(args[2], "range")) {
X					dirship->cew_range = value;
X				} else {
X					notify(Playernum, Governor, "No such option for CEWs.\n");
X					free(dirship);
X					return;
X				}
X			} else if (match(args[1], "laser")
X			     && Shipdata[dirship->build_type][ABIL_LASER]) {
X				if (!Laser(Race)) {
X					sprintf(buf, "Your race does not understand lasers yet.\n");
X					notify(Playernum, Governor, buf);
X					free(dirship);
X					return;
X				}
X				if (Shipdata[dirship->build_type][ABIL_LASER])
X					dirship->laser = !dirship->laser;
X				else {
X					notify(Playernum, Governor, "That ship cannot be fitted with combat lasers.\n");
X					free(dirship);
X					return;
X				}
X			} else {
X				notify(Playernum, Governor, "That characteristic either doesn't exist or can't be modified.\n");
X				free(dirship);
X				return;
X			}
X		} else if (Hyper_drive(Race)) {
X			if (match(args[1], "hyperdrive")) {
X				dirship->hyper_drive.has = !dirship->hyper_drive.has;
X			} else {
X				notify(Playernum, Governor, "You may only modify hyperdrive installation on this kind of ship.\n");
X				free(dirship);
X				return;
X			}
X		} else {
X			notify(Playernum, Governor, "Sorry, but you can't modify this ship right now.\n");
X			free(dirship);
X			return;
X		}
X	} else {
X		notify(Playernum, Governor, "Weird error.\n");
X		free(dirship);
X		return;
X	}
X	/* compute how much it's going to cost to build the ship */
X
X	if ((cost0 = cost(dirship)) > 65535.0) {
X		notify(Playernum, Governor, "Woah!! YOU CHEATER!!!  The max cost allowed is 65535!!! I'm Telllllllling!!!\n");
X		free(dirship);
X		return;
X	}
X	dirship->build_cost = Race->God ? 0 : (int) cost0;
X	sprintf(buf, "The current cost of the ship is %d resources.\n",
X		dirship->build_cost);
X	notify(Playernum, Governor, buf);
X	dirship->size = ship_size(dirship);
X	dirship->base_mass = getmass(dirship);
X	sprintf(buf, "The current base mass of the ship is %.1f - size is %d.\n",
X		dirship->base_mass, dirship->size);
X	notify(Playernum, Governor, buf);
X	dirship->complexity = complexity(dirship);
X	sprintf(buf, "Ship complexity is %.1f (you have %.1f engineering technology).\n", dirship->complexity, Race->tech);
X	notify(Playernum, Governor, buf);
X
X	/* Restore size to what it was before.  Maarten */
X	dirship->size = size;
X
X	putship(dirship);
X	free(dirship);
X}
X
Xvoid 
Xbuild(int Playernum, int Governor, int APcount)
X{
X	racetype       *Race;
X	char            c;
X	int             i, j, m, n, x, y, count, level, what, outside;
X	int             shipcost, load_crew;
X	int             snum, pnum, build_level;
X	double          load_fuel, tech;
X
X	FILE           *fd;
X	planettype     *planet;
X	sectortype     *sector;
X	shiptype       *builder;
X	shiptype        newship;
X
X	if (argn > 1 && args[1][0] == '?') {
X		/* information request */
X		if (argn == 2) {
X			/* Ship parameter list */
X			notify(Playernum, Governor, "     - Default ship parameters -\n");
X			sprintf(buf, "%1s %-15s %5s %5s %3s %4s %3s %3s %3s %4s %4s %2s %4s %4s\n",
X				"?", "name", "cargo", "hang", "arm", "dest", "gun", "pri",
X				"sec", "fuel", "crew", "sp", "tech", "cost");
X			notify(Playernum, Governor, buf);
X			Race = races[Playernum - 1];
X			for (j = 0; j < NUMSTYPES; j++) {
X				i = ShipVector[j];
X				if (Race->pods || (i != STYPE_POD)) {
X					if (Shipdata[i][ABIL_PROGRAMMED]) {
X						sprintf(buf, "%1c %-15.15s %5d %5d %3d %4d %3d %3d %3d %4d %4d %2d %4.0f %4d\n",
X						  Shipltrs[i], Shipnames[i],
X						    Shipdata[i][ABIL_CARGO],
X						   Shipdata[i][ABIL_HANGER],
X						    Shipdata[i][ABIL_ARMOR],
X						  Shipdata[i][ABIL_DESTCAP],
X						     Shipdata[i][ABIL_GUNS],
X						  Shipdata[i][ABIL_PRIMARY],
X						Shipdata[i][ABIL_SECONDARY],
X						  Shipdata[i][ABIL_FUELCAP],
X						  Shipdata[i][ABIL_MAXCREW],
X						    Shipdata[i][ABIL_SPEED],
X							(double) Shipdata[i][ABIL_TECH],
X							Shipcost(i, Race));
X						notify(Playernum, Governor, buf);
X					}
X				}
X			}
X			return;
X		} else {
X			/* Description of specific ship type */
X			i = 0;
X			while (Shipltrs[i] != args[2][0] && i < NUMSTYPES)
X				i++;
X			if (i < 0 || i >= NUMSTYPES)
X				notify(Playernum, Governor, "No such ship type.\n");
X			else if (!Shipdata[i][ABIL_PROGRAMMED])
X				notify(Playernum, Governor, "This ship type has not been programmed.\n");
X			else {
X				if ((fd = fopen(EXAM_FL, "r")) == NULL) {
X					perror(EXAM_FL);
X					return;
X				} else {
X					/* look through ship description file */
X					sprintf(buf, "\n");
X					for (j = 0; j <= i; j++)
X						while (fgetc(fd) != '~');
X					/* Give description */
X					while ((c = fgetc(fd)) != '~') {
X						sprintf(temp, "%c", c);
X						strcat(buf, temp);
X					}
X					fclose(fd);
X					/* Built where? */
X					if (Shipdata[i][ABIL_BUILD] & 1) {
X						sprintf(temp, "\nCan be constructed on planet.");
X						strcat(buf, temp);
X					}
X					n = 0;
X					sprintf(temp, "\nCan be built by ");
X					for (j = 0; j < NUMSTYPES; j++)
X						if (Shipdata[i][ABIL_BUILD] & Shipdata[j][ABIL_CONSTRUCT])
X							n++;
X					if (n) {
X						m = 0;
X						strcat(buf, temp);
X						for (j = 0; j < NUMSTYPES; j++) {
X							if (Shipdata[i][ABIL_BUILD] &
X							    Shipdata[j][ABIL_CONSTRUCT]) {
X								m++;
X								if (n - m > 1)
X									sprintf(temp, "%c, ", Shipltrs[j]);
X								else if (n - m > 0)
X									sprintf(temp, "%c and ", Shipltrs[j]);
X								else
X									sprintf(temp, "%c ", Shipltrs[j]);
X								strcat(buf, temp);
X							}
X						}
X						sprintf(temp, "type ships.\n");
X						strcat(buf, temp);
X					}
X					/* default parameters */
X					sprintf(temp, "\n%1s %-15s %5s %5s %3s %4s %3s %3s %3s %4s %4s %2s %4s %4s\n",
X						"?", "name", "cargo", "hang", "arm", "dest", "gun",
X						"pri", "sec", "fuel", "crew", "sp", "tech", "cost");
X					strcat(buf, temp);
X					Race = races[Playernum - 1];
X					sprintf(temp, "%1c %-15.15s %5d %5d %3d %4d %3d %3d %3d %4d %4d %2d %4.0f %4d\n",
X						Shipltrs[i], Shipnames[i],
X						Shipdata[i][ABIL_CARGO],
X						Shipdata[i][ABIL_HANGER],
X						Shipdata[i][ABIL_ARMOR],
X						Shipdata[i][ABIL_DESTCAP],
X						Shipdata[i][ABIL_GUNS],
X						Shipdata[i][ABIL_PRIMARY],
X						Shipdata[i][ABIL_SECONDARY],
X						Shipdata[i][ABIL_FUELCAP],
X						Shipdata[i][ABIL_MAXCREW],
X						Shipdata[i][ABIL_SPEED],
X					    (double) Shipdata[i][ABIL_TECH],
X						Shipcost(i, Race));
X					strcat(buf, temp);
X					notify(Playernum, Governor, buf);
X				}
X			}
X		}
X		return;
X	}
X	level = Dir[Playernum - 1][Governor].level;
X	if (level != LEVEL_SHIP && level != LEVEL_PLAN) {
X		notify(Playernum, Governor, "You must change scope to a ship or planet to build.\n");
X		return;
X	}
X	snum = Dir[Playernum - 1][Governor].snum;
X	pnum = Dir[Playernum - 1][Governor].pnum;
X	Race = races[Playernum - 1];
X	count = 0;		/* this used used to reset count in the loop */
X	do {
X		switch (level) {
X		case LEVEL_PLAN:
X			if (!count) {	/* initialize loop variables */
X				if (argn < 2) {
X					notify(Playernum, Governor, "Build what?\n");
X					return;
X				}
X				if ((what = get_build_type(args[1])) < 0) {
X					notify(Playernum, Governor, "No such ship type.\n");
X					return;
X				}
X				if (!can_build_this(what, Race, buf) && !Race->God) {
X					notify(Playernum, Governor, buf);
X					return;
X				}
X				if (!(Shipdata[what][ABIL_BUILD] & 1) && !Race->God) {
X					notify(Playernum, Governor, "This ship cannot be built by a planet.\n");
X					return;
X				}
X				if (argn < 3) {
X					notify(Playernum, Governor, "Build where?\n");
X					return;
X				}
X				getplanet(&planet, snum, pnum);
X				if (!can_build_at_planet(Playernum, Governor, Stars[snum], planet) && !Race->God) {
X					notify(Playernum, Governor, "You can't build that here.\n");
X					free(planet);
X					return;
X				}
X				sscanf(args[2], "%d,%d", &x, &y);
X				if (x < 0 || x >= planet->Maxx || y < 0 || y >= planet->Maxy) {
X					notify(Playernum, Governor, "Illegal sector.\n");
X					free(planet);
X					return;
X				}
X				getsector(&sector, planet, x, y);
X				if (!can_build_on_sector(what, Race, planet, sector, x, y, buf) && !Race->God) {
X					notify(Playernum, Governor, buf);
X					free(planet);
X					free(sector);
X					return;
X				}
X				if (!(count = getcount(argn < 4, args[3]))) {
X					notify(Playernum, Governor,
X					       "Give a positive number of builds.\n");
X					free(planet);
X					free(sector);
X					return;
X				}
X				Getship(&newship, what, Race);
X			}
X			if ((shipcost = newship.build_cost) >
X			    planet->info[Playernum - 1].resource) {
X				sprintf(buf, "You need %dr to construct this ship.\n", shipcost);
X				notify(Playernum, Governor, buf);
X				goto finish;
X			}
X			create_ship_by_planet(Playernum, Governor, Race, &newship, planet, snum, pnum, x, y);
X			if (Race->governor[Governor].toggle.autoload &&
X			    what != OTYPE_TRANSDEV && !Race->God)
X				autoload_at_planet(Playernum, &newship, planet, sector, &load_crew, &load_fuel);
X			else {
X				load_crew = 0;
X				load_fuel = 0.0;
X			}
X			initialize_new_ship(Playernum, Governor, Race, &newship, load_fuel, load_crew);
X			putship(&newship);
X			break;
X		case LEVEL_SHIP:
X			if (!count) {	/* initialize loop variables */
X				(void) getship(&builder, Dir[Playernum - 1][Governor].shipno);
X				outside = 0;
X				if ((build_level = build_at_ship(Playernum, Governor, Race,
X					      builder, &snum, &pnum)) < 0) {
X					notify(Playernum, Governor, "You can't build here.\n");
X					free(builder);
X					return;
X				}
X				switch (builder->type) {
X				case OTYPE_FACTORY:
X					if (!(count = getcount(argn < 2, args[1]))) {
X						notify(Playernum, Governor,
X						       "Give a positive number of builds.\n");
X						free(builder);
X						return;
X					}
X					if (!landed(builder)) {
X						notify(Playernum, Governor, "Factories can only build when landed on a planet.\n");
X						free(builder);
X						return;
X					}
X					Getfactship(&newship, builder);
X					outside = 1;
X					break;
X				case STYPE_SHUTTLE:
X				case STYPE_CARGO:
X					if (landed(builder)) {
X						notify(Playernum, Governor, "This ships cannot build when landed.\n");
X						free(builder);
X						return;
X					}
X					outside = 1;
X				default:
X					if (argn < 2) {
X						notify(Playernum, Governor, "Build what?\n");
X						free(builder);
X						return;
X					}
X					if ((what = get_build_type(args[1])) < 0) {
X						notify(Playernum, Governor, "No such ship type.\n");
X						free(builder);
X						return;
X					}
X					if (!can_build_on_ship(what, Race, builder, buf)) {
X						notify(Playernum, Governor, buf);
X						free(builder);
X						return;
X					}
X					if (!(count = getcount(argn < 3, args[2]))) {
X						notify(Playernum, Governor,
X						       "Give a positive number of builds.\n");
X						free(builder);
X						return;
X					}
X					Getship(&newship, what, Race);
X					break;
X				}
X				if ((tech = builder->type == OTYPE_FACTORY ? complexity(builder) :
X				     Shipdata[what][ABIL_TECH]) > Race->tech && !Race->God) {
X					sprintf(buf, "You are not advanced enough to build this ship.\n%.1f enginering technology needed. You have %.1f.\n",
X						tech, Race->tech);
X					notify(Playernum, Governor, buf);
X					free(builder);
X					return;
X				}
X				if (outside && build_level == LEVEL_PLAN) {
X					getplanet(&planet, snum, pnum);
X					if (builder->type == OTYPE_FACTORY) {
X						if (!can_build_at_planet(Playernum, Governor, Stars[snum], planet)) {
X							notify(Playernum, Governor, "You can't build that here.\n");
X							free(planet);
X							free(builder);
X							return;
X						}
X						x = builder->land_x;
X						y = builder->land_y;
X						what = builder->build_type;
X						getsector(&sector, planet, x, y);
X						if (!can_build_on_sector(what, Race, planet, sector, x, y, buf)) {
X							notify(Playernum, Governor, buf);
X							free(planet);
X							free(sector);
X							free(builder);
X							return;
X						}
X					}
X				}
X			}
X			/* build 'em */
X			switch (builder->type) {
X			case OTYPE_FACTORY:
X				if ((shipcost = newship.build_cost) >
X				    planet->info[Playernum - 1].resource) {
X					sprintf(buf, "You need %dr to construct this ship.\n", shipcost);
X					notify(Playernum, Governor, buf);
X					goto finish;
X				}
X				create_ship_by_planet(Playernum, Governor, Race, &newship, planet, snum, pnum, x, y);
X				if (Race->governor[Governor].toggle.autoload &&
X				    what != OTYPE_TRANSDEV && !Race->God) {
X					autoload_at_planet(Playernum, &newship, planet, sector, &load_crew, &load_fuel);
X				} else {
X					load_crew = 0;
X					load_fuel = 0.0;
X				}
X				break;
X			case STYPE_SHUTTLE:
X			case STYPE_CARGO:
X				if (builder->resource < (shipcost = newship.build_cost)) {
X					sprintf(buf, "You need %dr to construct the ship.\n", shipcost);
X					notify(Playernum, Governor, buf);
X					goto finish;
X				}
X				create_ship_by_ship(Playernum, Governor, Race, 1,
X						    Stars[builder->storbits], planet, &newship, builder);
X				if (Race->governor[Governor].toggle.autoload &&
X				    what != OTYPE_TRANSDEV && !Race->God)
X					autoload_at_ship(Playernum, &newship, builder, &load_crew, &load_fuel);
X				else {
X					load_crew = 0;
X					load_fuel = 0.0;
X				}
X				break;
X			default:
X				if (builder->hanger + ship_size(&newship) > builder->max_hanger) {
X					notify(Playernum, Governor, "Not enough hanger space.\n");
X					goto finish;
X				}
X				if (builder->resource < (shipcost = newship.build_cost)) {
X					sprintf(buf, "You need %dr to construct the ship.\n", shipcost);
X					notify(Playernum, Governor, buf);
X					goto finish;
X				}
X				create_ship_by_ship(Playernum, Governor, Race, 0,
X					     NULL, NULL, &newship, builder);
X				if (Race->governor[Governor].toggle.autoload &&
X				    what != OTYPE_TRANSDEV && !Race->God)
X					autoload_at_ship(Playernum, &newship, builder, &load_crew, &load_fuel);
X				else {
X					load_crew = 0;
X					load_fuel = 0.0;
X				}
X				break;
X			}
X			initialize_new_ship(Playernum, Governor, Race, &newship, load_fuel, load_crew);
X			putship(&newship);
X			break;
X		}
X		count--;
X	} while (count);
X	/* free stuff */
Xfinish:
X	switch (level) {
X	case LEVEL_PLAN:
X		putsector(sector, planet, x, y);
X		putplanet(planet, snum, pnum);
X		free(sector);
X		free(planet);
X		break;
X	case LEVEL_SHIP:
X		if (outside)
X			switch (build_level) {
X			case LEVEL_PLAN:
X				putplanet(planet, snum, pnum);
X				if (landed(builder)) {
X					putsector(sector, planet, x, y);
X					free(sector);
X				}
X				free(planet);
X				break;
X			case LEVEL_STAR:
X				putstar(Stars[snum], snum);
X				break;
X			case LEVEL_UNIV:
X				putsdata(&Sdata);
X				break;
X			}
X		putship(builder);
X		free(builder);
X		break;
X	}
X}
X
Xint 
Xgetcount(int mode, char *string)
X{
X	int             count;
X
X	if (mode)
X		count = 1;
X	else
X		count = atoi(string);
X	if (count <= 0)
X		count = 0;
X
X	return (count);
X}
X
Xint 
Xcan_build_at_planet(int Playernum, int Governor, startype * star,
X		    planettype * planet)
X{
X	if (planet->slaved_to && planet->slaved_to != Playernum) {
X		sprintf(buf, "This planet is enslaved by player %d.\n", planet->slaved_to);
X		notify(Playernum, Governor, buf);
X		return (0);
X	}
X	if (Governor && star->governor[Playernum - 1] != Governor) {
X		notify(Playernum, Governor, "You are not authorized in this system.\n");
X		return (0);
X	}
X	return (1);
X}
X
Xint 
Xget_build_type(char *string)
X{
X	char            shipc;
X	reg int         i = 0;
X
X	shipc = string[0];
X	while (i < NUMSTYPES && Shipltrs[i] != shipc)
X		i++;
X	if (i < 0 || i >= NUMSTYPES)
X		return (-1);
X	return i;
X}
X
Xint 
Xcan_build_this(int what, racetype * Race, char *string)
X{
X	if (what == STYPE_POD && !Race->pods) {
X		sprintf(string, "Only Metamorphic races can build Spore Pods.\n");
X		return (0);
X	}
X	if (!Shipdata[what][ABIL_PROGRAMMED]) {
X		sprintf(string, "This ship type has not been programmed.\n");
X		return (0);
X	}
X	if (what == OTYPE_TRANSDEV && !Avpm(Race)) {
X		sprintf(string, "You have not discovered AVPM technology.\n");
X		return (0);
X	}
X	if (Shipdata[what][ABIL_TECH] > Race->tech && !Race->God) {
X		sprintf(string, "You are not advanced enough to build this ship.\n%.1f enginering technology needed. You have %.1f.\n",
X			(double) Shipdata[what][ABIL_TECH], Race->tech);
X		return (0);
X	}
X	return 1;
X}
X
Xint 
Xcan_build_on_ship(int what, racetype * Race, shiptype * builder,
X		  char *string)
X{
X	if (!(Shipdata[what][ABIL_BUILD] &
X	      Shipdata[builder->type][ABIL_CONSTRUCT]) && !Race->God) {
X		sprintf(string, "This ship type cannot be built by a %s.\n",
X			Shipnames[builder->type]);
X		sprintf(temp, "Use 'build ? %c' to find out where it can be built.\n", Shipltrs[what]);
X		strcat(string, temp);
X		return (0);
X	}
X	return (1);
X}
X
Xint 
Xcan_build_on_sector(int what, racetype * Race, planettype * planet,
X		    sectortype * sector, int x, int y, char *string)
X{
X	shiptype       *s;
X	char            shipc;
X
X	shipc = Shipltrs[what];
X	if (!sector->popn) {
X		sprintf(string, "You have no more civs in the sector!\n");
X		return (0);
X	}
X	if (sector->condition == WASTED) {
X		sprintf(string, "You can't build on wasted sectors.\n");
X		return (0);
X	}
X	if (sector->owner != Race->Playernum && !Race->God) {
X		sprintf(string, "You don't own that sector.\n");
X		return (0);
X	}
X	if ((!Shipdata[what][ABIL_BUILD] & 1) && !Race->God) {
X		sprintf(string, "This ship type cannot be built on a planet.\n");
X		sprintf(temp, "Use 'build ? %c' to find out where it can be built.\n", shipc);
X		strcat(string, temp);
X		return (0);
X	}
X	if (what == OTYPE_QUARRY) {
X		reg int         sh;
X		sh = planet->ships;
X		while (sh) {
X			(void) getship(&s, sh);
X			if (s->alive && s->type == OTYPE_QUARRY &&
X			    s->land_x == x && s->land_y == y) {
X				sprintf(string, "There already is a quarry here.\n");
X				free(s);
X				return (0);
X			}
X			sh = s->nextship;
X			free(s);
X		}
X	}
X	return (1);
X}
X
Xint 
Xbuild_at_ship(int Playernum, int Governor, racetype * Race,
X	      shiptype * builder, int *snum, int *pnum)
X{
X	if (testship(Playernum, Governor, builder))
X		return (-1);
X	if (!Shipdata[builder->type][ABIL_CONSTRUCT]) {
X		notify(Playernum, Governor, "This ship cannot construct other ships.\n");
X		return (-1);
X	}
X	if (!builder->popn) {
X		notify(Playernum, Governor, "This ship has no crew.\n");
X		return (-1);
X	}
X	if (docked(builder)) {
X		notify(Playernum, Governor, "Undock this ship first.\n");
X		return (-1);
X	}
X	if (builder->damage) {
X		notify(Playernum, Governor, "This ship is damaged and cannot build.\n");
X		return (-1);
X	}
X	if (builder->type == OTYPE_FACTORY && !builder->on) {
X		notify(Playernum, Governor, "This factory is not online.\n");
X		return (-1);
X	}
X	if (builder->type == OTYPE_FACTORY && !landed(builder)) {
X		notify(Playernum, Governor, "Factories must be landed on a planet.\n");
X		return (-1);
X	}
X	*snum = builder->storbits;
X	*pnum = builder->pnumorbits;
X	return (builder->whatorbits);
X}
X
Xvoid 
Xautoload_at_planet(int Playernum, shiptype * s, planettype * planet,
X		   sectortype * sector, int *crew, double *fuel)
X{
X	*crew = MIN(s->max_crew, sector->popn);
X	*fuel = MIN((double) s->max_fuel, (double) planet->info[Playernum - 1].fuel);
X	sector->popn -= *crew;
X	if (!sector->popn && !sector->troops)
X		sector->owner = 0;
X	planet->info[Playernum - 1].fuel -= (int) (*fuel);
X}
X
Xvoid 
Xautoload_at_ship(int Playernum, shiptype * s, shiptype * b, int *crew,
X		 double *fuel)
X{
X	*crew = MIN(s->max_crew, b->popn);
X	*fuel = MIN((double) s->max_fuel, (double) b->fuel);
X	b->popn -= *crew;
X	b->fuel -= *fuel;
X}
X
Xvoid 
Xinitialize_new_ship(int Playernum, int Governor, racetype * Race,
X		    shiptype * newship, double load_fuel, int load_crew)
X{
X#ifdef AUTOSCRAP 
X	newship->autoscrap = 0;
X#endif
X#ifdef THRESHLOADING
X	newship->threshload[RESOURCE] = 0;
X	newship->threshload[DESTRUCT] = 0;
X	newship->threshload[FUEL] = 0;
X	newship->threshload[CRYSTAL] = 0;
X#endif 
X	newship->speed = newship->max_speed;
X	newship->owner = Playernum;
X	newship->governor = Governor;
X	newship->fuel = Race->God ? newship->max_fuel : load_fuel;
X	newship->popn = Race->God ? newship->max_crew : load_crew;
X	newship->troops = 0;
X	newship->resource = Race->God ? newship->max_resource : 0;
X	newship->destruct = Race->God ? newship->max_destruct : 0;
X	newship->crystals = 0;
X	newship->hanger = 0;
X	newship->mass = newship->base_mass +
X		(double) newship->popn * Race->mass +
X		(double) newship->fuel * MASS_FUEL +
X		(double) newship->resource * MASS_RESOURCE +
X		(double) newship->destruct * MASS_DESTRUCT;
X	newship->alive = 1;
X	newship->active = 1;
X	newship->protect.self = newship->guns ? 1 : 0;
X	newship->hyper_drive.on = 0;
X	newship->hyper_drive.ready = 0;
X	newship->hyper_drive.charge = 0;
X	newship->mounted = Race->God ? newship->mount : 0;
X	newship->cloak = 0;
X	newship->cloaked = 0;
X	newship->fire_laser = 0;
X	newship->mode = 0;
X	newship->rad = 0;
X	newship->damage = Race->God ? 0 : Shipdata[newship->type][ABIL_DAMAGE];
X	newship->retaliate = newship->primary;
X	newship->ships = 0;
X	newship->on = 0;
X	switch (newship->type) {
X	case STYPE_MINE:
X		newship->special.trigger.radius = 100;	/* trigger radius */
X		notify(Playernum, Governor, "Mine disarmed.\nTrigger radius set at 100.\n");
X		break;
X	case OTYPE_TRANSDEV:
X		newship->special.transport.target = 0;
X		newship->on = 0;
X		notify(Playernum, Governor, "Receive OFF.  Change with order.\n");
X		break;
X	case OTYPE_AP:
X		notify(Playernum, Governor, "Processor OFF.\n");
X		break;
X	case OTYPE_STELE:
X	case OTYPE_GTELE:
X		sprintf(buf, "Telescope range is %.2f.\n",
X			tele_range(newship->type, newship->tech));
X		notify(Playernum, Governor, buf);
X		break;
X	default:
X		break;
X	}
X	if (newship->damage) {
X		sprintf(buf,
X			"Warning: This ship is constructed with a %d%% damage level.\n",
X			newship->damage);
X		notify(Playernum, Governor, buf);
X		if (!Shipdata[newship->type][ABIL_REPAIR] && newship->max_crew)
X			notify(Playernum, Governor,
X			       "It will need resources to become fully operational.\n");
X	}
X	if (Shipdata[newship->type][ABIL_REPAIR] && newship->max_crew)
X		notify(Playernum, Governor, "This ship does not need resources to repair.\n");
X	if (newship->type == OTYPE_FACTORY)
X		notify(Playernum, Governor,
X		       "This factory may not begin repairs until it has been activated.\n");
X	if (!newship->max_crew)
X		notify(Playernum, Governor, "This ship is robotic, and may not repair itself.\n");
X	sprintf(buf, "Loaded with %d crew and %.1f fuel.\n", load_crew, load_fuel);
X	notify(Playernum, Governor, buf);
X}
X
Xvoid 
Xcreate_ship_by_planet(int Playernum, int Governor, racetype * Race,
X		      shiptype * newship, planettype * planet, int snum,
X		      int pnum, int x, int y)
X{
X	int             shipno;
X
X	newship->tech = Race->tech;
X	newship->xpos = Stars[snum]->xpos + planet->xpos;
X	newship->ypos = Stars[snum]->ypos + planet->ypos;
X	newship->land_x = x;
X	newship->land_y = y;
X	sprintf(newship->class, (((newship->type == OTYPE_TERRA) ||
X			(newship->type == OTYPE_PLOW)) ? "5" : "Standard"));
X	newship->whatorbits = LEVEL_PLAN;
X	newship->whatdest = LEVEL_PLAN;
X	newship->deststar = snum;
X	newship->destpnum = pnum;
X	newship->storbits = snum;
X	newship->pnumorbits = pnum;
X	newship->docked = 1;
X	planet->info[Playernum - 1].resource -= newship->build_cost;
X	while ((shipno = getdeadship()) == 0);
X	if (shipno == -1)
X		shipno = Numships() + 1;
X	newship->number = shipno;
X	newship->owner = Playernum;
X	newship->governor = Governor;
X	newship->ships = 0;
X	insert_sh_plan(planet, newship);
X	if (newship->type == OTYPE_TOXWC) {
X		sprintf(buf, "Toxin concentration on planet was %d%%,",
X			planet->conditions[TOXIC]);
X		notify(Playernum, Governor, buf);
X		if (planet->conditions[TOXIC] > TOXMAX)
X			newship->special.waste.toxic = TOXMAX;
X		else
X			newship->special.waste.toxic = planet->conditions[TOXIC];
X		planet->conditions[TOXIC] -= newship->special.waste.toxic;
X		sprintf(buf, " now %d%%.\n", planet->conditions[TOXIC]);
X		notify(Playernum, Governor, buf);
X	}
X	sprintf(buf, "%s built at a cost of %d resources.\n",
X		Ship(newship), newship->build_cost);
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "Technology %.1f.\n", newship->tech);
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "%s is on sector %d,%d.\n",
X		Ship(newship), newship->land_x, newship->land_y);
X	notify(Playernum, Governor, buf);
X}
X
Xvoid 
Xcreate_ship_by_ship(int Playernum, int Governor, racetype * Race,
X		    int outside, startype * star, planettype * planet,
X		    shiptype * newship, shiptype * builder)
X{
X	int             shipno;
X
X	while ((shipno = getdeadship()) == 0);
X	if (shipno == -1)
X		shipno = Numships() + 1;
X	newship->number = shipno;
X	newship->owner = Playernum;
X	newship->governor = Governor;
X	if (outside) {
X		newship->whatorbits = builder->whatorbits;
X		newship->whatdest = LEVEL_UNIV;
X		newship->deststar = builder->deststar;
X		newship->destpnum = builder->destpnum;
X		newship->storbits = builder->storbits;
X		newship->pnumorbits = builder->pnumorbits;
X		newship->docked = 0;
X		switch (builder->whatorbits) {
X		case LEVEL_PLAN:
X			insert_sh_plan(planet, newship);
X			break;
X		case LEVEL_STAR:
X			insert_sh_star(Stars[builder->storbits], newship);
X			break;
X		case LEVEL_UNIV:
X			insert_sh_univ(&Sdata, newship);
X			break;
X		}
X	} else {
X		newship->whatorbits = LEVEL_SHIP;
X		newship->whatdest = LEVEL_SHIP;
X		newship->deststar = builder->deststar;
X		newship->destpnum = builder->destpnum;
X		newship->destshipno = builder->number;
X		newship->storbits = builder->storbits;
X		newship->pnumorbits = builder->pnumorbits;
X		newship->docked = 1;
X		insert_sh_ship(newship, builder);
X	}
X	newship->tech = Race->tech;
X	newship->xpos = builder->xpos;
X	newship->ypos = builder->ypos;
X	newship->land_x = builder->land_x;
X	newship->land_y = builder->land_y;
X	sprintf(newship->class, (((newship->type == OTYPE_TERRA) ||
X			(newship->type == OTYPE_PLOW)) ? "5" : "Standard"));
X	builder->resource -= newship->build_cost;
X
X	sprintf(buf, "%s built at a cost of %d resources.\n",
X		Ship(newship), newship->build_cost);
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "Technology %.1f.\n", newship->tech);
X	notify(Playernum, Governor, buf);
X}
X
Xdouble 
Xgetmass(shiptype * s)
X{
X	return (1.0 + MASS_ARMOR * s->armor
X		+ MASS_SIZE * (s->size - s->max_hanger)
X		+ MASS_HANGER * s->max_hanger
X		+ MASS_GUNS * s->primary * s->primtype
X		+ MASS_GUNS * s->secondary * s->sectype);
X}
X
Xint 
Xship_size(shiptype * s)
X{
X	double          size;
X	size = 1.0 + SIZE_GUNS * s->primary
X		+ SIZE_GUNS * s->secondary
X		+ SIZE_CREW * s->max_crew
X		+ SIZE_RESOURCE * s->max_resource
X		+ SIZE_FUEL * s->max_fuel
X		+ SIZE_DESTRUCT * s->max_destruct
X		+ s->max_hanger;
X	return ((int) size);
X}
X
Xdouble 
Xcost(shiptype * s)
X{
X	int             i;
X	double          factor = 0.0, advantage = 0.0;
X
X	i = s->build_type;
X	/* compute how much it costs to build this ship */
X	factor += (double) Shipdata[i][ABIL_COST];
X	factor += GUN_COST * (double) s->primary;
X	factor += GUN_COST * (double) s->secondary;
X	factor += CREW_COST * (double) s->max_crew;
X	factor += CARGO_COST * (double) s->max_resource;
X	factor += FUEL_COST * (double) s->max_fuel;
X	factor += AMMO_COST * (double) s->max_destruct;
X	factor += SPEED_COST * (double) s->max_speed * (double) sqrt((double) s->max_speed);
X	factor += HANGER_COST * (double) s->max_hanger;
X	factor += ARMOR_COST * (double) s->armor * (double) sqrt((double) s->armor);
X	factor += CEW_COST * (double) (s->cew * s->cew_range);
X	/* additional advantages/disadvantages */
X
X	advantage += 0.5 * !!s->hyper_drive.has;
X	advantage += 0.5 * !!s->laser;
X	advantage += 0.5 * !!s->cloak;
X	advantage += 0.5 * !!s->mount;
X
X	factor *= sqrt(1.0 + advantage);
X	return (factor);
X
X}
X
Xvoid 
Xsystem_cost(double *advantage, double *disadvantage, int value, int base)
X{
X	double          factor;
X
X	factor = (((double) value + 1.0) / (base + 1.0)) - 1.0;
X	if (factor >= 0.0)
X		*advantage += factor;
X	else
X		*disadvantage -= factor;
X}
X
Xdouble 
Xcomplexity(shiptype * s)
X{
X	int             i;
X	double          advantage, disadvantage, factor, temp;
X
X	i = s->build_type;
X
X	advantage = 0.;
X	disadvantage = 0.;
X
X	system_cost(&advantage, &disadvantage, (int) (s->primary),
X		    Shipdata[i][ABIL_GUNS]);
X	system_cost(&advantage, &disadvantage, (int) (s->secondary),
X		    Shipdata[i][ABIL_GUNS]);
X	system_cost(&advantage, &disadvantage, (int) (s->max_crew),
X		    Shipdata[i][ABIL_MAXCREW]);
X	system_cost(&advantage, &disadvantage, (int) (s->max_resource),
X		    Shipdata[i][ABIL_CARGO]);
X	system_cost(&advantage, &disadvantage, (int) (s->max_fuel),
X		    Shipdata[i][ABIL_FUELCAP]);
X	system_cost(&advantage, &disadvantage, (int) (s->max_destruct),
X		    Shipdata[i][ABIL_DESTCAP]);
X	system_cost(&advantage, &disadvantage, (int) (s->max_speed),
X		    Shipdata[i][ABIL_SPEED]);
X	system_cost(&advantage, &disadvantage, (int) (s->max_hanger),
X		    Shipdata[i][ABIL_HANGER]);
X	system_cost(&advantage, &disadvantage, (int) (s->armor),
X		    Shipdata[i][ABIL_ARMOR]);
X	/* additional advantages/disadvantages */
X
X	factor = sqrt((1.0 + advantage) * exp(-(double) disadvantage / 10.0));
X	temp = COMPLEXITY_FACTOR * (factor - 1.0) / sqrt((double) (Shipdata[i][ABIL_TECH] + 1)) + 1.0;
X	factor = temp * temp;
X	return (factor * (double) Shipdata[i][ABIL_TECH]);
X}
X
Xvoid 
XGetship(shiptype * s, int i, racetype * r)
X{
X	bzero((char *) s, sizeof(shiptype));
X	s->type = i;
X	s->armor = Shipdata[i][ABIL_ARMOR];
X	s->guns = Shipdata[i][ABIL_PRIMARY] ? PRIMARY : NONE;
X	s->primary = Shipdata[i][ABIL_GUNS];
X	s->primtype = Shipdata[i][ABIL_PRIMARY];
X	s->secondary = Shipdata[i][ABIL_GUNS];
X	s->sectype = Shipdata[i][ABIL_SECONDARY];
X	s->max_crew = Shipdata[i][ABIL_MAXCREW];
X	s->max_resource = Shipdata[i][ABIL_CARGO];
X	s->max_hanger = Shipdata[i][ABIL_HANGER];
X	s->max_destruct = Shipdata[i][ABIL_DESTCAP];
X	s->max_fuel = Shipdata[i][ABIL_FUELCAP];
X	s->max_speed = Shipdata[i][ABIL_SPEED];
X	s->build_type = i;
X	s->mount = r->God ? Shipdata[i][ABIL_MOUNT] : 0;
X	s->hyper_drive.has = r->God ? Shipdata[i][ABIL_JUMP] : 0;
X	s->cloak = 0;
X	s->laser = r->God ? Shipdata[i][ABIL_LASER] : 0;
X	s->cew = 0;
X	s->cew_range = 0;
X	s->size = ship_size(s);
X	s->base_mass = getmass(s);
X	s->mass = getmass(s);
X	s->build_cost = r->God ? 0 : (int) cost(s);
X}
X
Xvoid 
XGetfactship(shiptype * s, shiptype * b)
X{
X	bzero((char *) s, sizeof(shiptype));
X	s->type = b->build_type;
X	s->armor = b->armor;
X	s->primary = b->primary;
X	s->primtype = b->primtype;
X	s->secondary = b->secondary;
X	s->sectype = b->sectype;
X	s->guns = s->primary ? PRIMARY : NONE;
X	s->max_crew = b->max_crew;
X	s->max_resource = b->max_resource;
X	s->max_hanger = b->max_hanger;
X	s->max_destruct = b->max_destruct;
X	s->max_fuel = b->max_fuel;
X	s->max_speed = b->max_speed;
X	s->build_type = b->build_type;
X	s->build_cost = b->build_cost;
X	s->mount = b->mount;
X	s->hyper_drive.has = b->hyper_drive.has;
X	s->cloak = 0;
X	s->laser = b->laser;
X	s->cew = b->cew;
X	s->cew_range = b->cew_range;
X	s->size = ship_size(s);
X	s->base_mass = getmass(s);
X	s->mass = getmass(s);
X}
X
Xint 
XShipcost(int i, racetype * r)
X{
X	shiptype        s;
X
X	Getship(&s, i, r);
X	return ((int) cost(&s));
X}
X
X#ifdef MARKET
Xchar           *Commod[] = {"resources", "destruct", "fuel", "crystals"};
X
Xvoid 
Xsell(int Playernum, int Governor, int APcount)
X{
X	racetype       *Race;
X	planettype     *p;
X	shiptype       *s;
X	commodtype      c;
X	int             commodno, amount, item, ok = 0, sh;
X	char            commod;
X	int             snum, pnum;
X	reg int         i;
X
X	if (Dir[Playernum - 1][Governor].level != LEVEL_PLAN) {
X		notify(Playernum, Governor, "You have to be in a planet scope to sell.\n");
X		return;
X	}
X	snum = Dir[Playernum - 1][Governor].snum;
X	pnum = Dir[Playernum - 1][Governor].pnum;
X	if (argn < 3) {
X		notify(Playernum, Governor, "Syntax: sell <commodity> <amount>\n");
X		return;
X	}
X	if (Governor && Stars[snum]->governor[Playernum - 1] != Governor) {
X		notify(Playernum, Governor, "You are not authorized in this system.\n");
X		return;
X	}
X	Race = races[Playernum - 1];
X	if (Race->Guest) {
X		notify(Playernum, Governor, "Guest races can't sell anything.\n");
X		return;
X	}
X	/* get information on sale */
X	commod = args[1][0];
X	amount = atoi(args[2]);
X	if (amount <= 0) {
X		notify(Playernum, Governor, "Try using positive values.\n");
X		return;
X	}
X	APcount = MIN(APcount, amount);
X	if (!enufAP(Playernum, Governor, Stars[snum]->AP[Playernum - 1], APcount))
X		return;
X	getplanet(&p, snum, pnum);
X
X	if (p->slaved_to && p->slaved_to != Playernum) {
X		sprintf(buf, "This planet is enslaved to player %d.\n", p->slaved_to);
X		notify(Playernum, Governor, buf);
X		free(p);
X		return;
X	}
X	/* check to see if there is an undamage gov center or space port here */
X	sh = p->ships;
X	while (sh && !ok) {
X		(void) getship(&s, sh);
X		if (s->alive && (s->owner == Playernum) && !s->damage &&
X		    Shipdata[s->type][ABIL_PORT])
X			ok = 1;
X		sh = s->nextship;
X		free(s);
X	}
X	if (!ok) {
X		notify(Playernum, Governor, "You don't have an undamaged space port or government center here.\n");
X		free(p);
X		return;
X	}
X	switch (commod) {
X	case 'r':
X		if (!p->info[Playernum - 1].resource) {
X			notify(Playernum, Governor, "You don't have any resources here to sell!\n");
X			free(p);
X			return;
X		}
X		amount = MIN(amount, p->info[Playernum - 1].resource);
X		p->info[Playernum - 1].resource -= amount;
X		item = RESOURCE;
X		break;
X	case 'd':
X		if (!p->info[Playernum - 1].destruct) {
X			notify(Playernum, Governor, "You don't have any destruct here to sell!\n");
X			free(p);
X			return;
X		}
X		amount = MIN(amount, p->info[Playernum - 1].destruct);
X		p->info[Playernum - 1].destruct -= amount;
X		item = DESTRUCT;
X		break;
X	case 'f':
X		if (!p->info[Playernum - 1].fuel) {
X			notify(Playernum, Governor, "You don't have any fuel here to sell!\n");
X			free(p);
X			return;
X		}
X		amount = MIN(amount, p->info[Playernum - 1].fuel);
X		p->info[Playernum - 1].fuel -= amount;
X		item = FUEL;
X		break;
X	case 'x':
X		if (!p->info[Playernum - 1].crystals) {
X			notify(Playernum, Governor, "You don't have any crystals here to sell!\n");
X			free(p);
X			return;
X		}
X		amount = MIN(amount, p->info[Playernum - 1].crystals);
X		p->info[Playernum - 1].crystals -= amount;
X		item = CRYSTAL;
X		break;
X	default:
X		notify(Playernum, Governor, "Permitted commodities are r, d, f, and x.\n");
X		free(p);
X		return;
X	}
X
X	c.owner = Playernum;
X	c.governor = Governor;
X	c.type = item;
X	c.amount = amount;
X	c.deliver = 0;
X	c.bid = 0;
X	c.bidder = 0;
X	c.star_from = snum;
X	c.planet_from = pnum;
X
X	while ((commodno = getdeadcommod()) == 0);
X
X	if (commodno == -1)
X		commodno = Numcommods() + 1;
X	sprintf(buf, "Lot #%d - %d units of %s.\n",
X		commodno, amount, Commod[item]);
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "Lot #%d - %d units of %s for sale by %s [%d].\n",
X		commodno, amount, Commod[item], races[Playernum - 1]->name,
X		Playernum);
X	post(buf, TRANSFER);
X	for (i = 1; i <= Num_races; i++)
X		notify_race(i, buf);
X	putcommod(&c, commodno);
X	putplanet(p, snum, pnum);
X	free(p);
X	deductAPs(Playernum, Governor, APcount, snum, 0);
X}
X
Xvoid 
Xbid(int Playernum, int Governor, int APcount)
X{
X	racetype       *Race;
X	planettype     *p;
X	commodtype     *c;
X	commodtype     *cc;
X	shiptype       *s;
X	char            commod;
X	int             i, item, bid0, lot, shipping, ok = 0, sh;
X	int             u, shipcost = 0, money_owed = 0;
X	int             minbid;
X	double          dist, rate;
X	int             snum, pnum;
X
X	if (argn == 1) {
X		/* list all market blocks for sale */
X		notify(Playernum, Governor, "+++ Galactic Bloodshed Commodities Market +++\n\n");
X		notify(Playernum, Governor, "  Lot Stock      Type  Owner  Bidder  Amount Cost/Unit    Ship  Dest\n");
X		for (i = 1; i <= Numcommods(); i++) {
X			getcommod(&c, i);
X			if (c->owner && c->amount) {
X				rate = (double) c->bid / (double) c->amount;
X				if (c->bidder == Playernum)
X					sprintf(temp, "%4.4s/%-4.4s", Stars[c->star_to]->name,
X						Stars[c->star_to]->pnames[c->planet_to]);
X				else
X					sprintf(temp, "");
X				sprintf(buf, " %4d%c%5d%10s%7d%8d%8d%10.2f%8d %10s\n",
X					i, c->deliver ? '*' : ' ', c->amount,
X					Commod[c->type], c->owner, c->bidder, c->bid, rate,
X					shipping_cost((int) c->star_from,
X				    (int) Dir[Playernum - 1][Governor].snum,
X						&dist, (int) c->bid), temp);
X				notify(Playernum, Governor, buf);
X			}
X			free(c);
X		}
X	} else if (argn == 2) {
X		/* list all market blocks for sale of the requested type */
X		commod = args[1][0];
X		switch (commod) {
X		case 'r':
X			item = RESOURCE;
X			break;
X		case 'd':
X			item = DESTRUCT;
X			break;
X		case 'f':
X			item = FUEL;
X			break;
X		case 'x':
X			item = CRYSTAL;
X			break;
X		default:
X			notify(Playernum, Governor, "No such type of commodity.\n");
X			return;
X		}
X		notify(Playernum, Governor, "+++ Galactic Bloodshed Commodities Market +++\n\n");
X		notify(Playernum, Governor, "  Lot Stock      Type  Owner  Bidder  Amount Cost/Unit    Ship  Dest\n");
X		for (i = 1; i <= Numcommods(); i++) {
X			getcommod(&c, i);
X			if (c->owner && c->amount && (c->type == item)) {
X				rate = (double) c->bid / (double) c->amount;
X				if (c->bidder == Playernum)
X					sprintf(temp, "%4.4s/%-4.4s", Stars[c->star_to]->name,
X						Stars[c->star_to]->pnames[c->planet_to]);
X				else
X					sprintf(temp, "");
X				sprintf(buf, " %4d%c%5d%10s%7d%8d%8d%10.2f%8d %10s\n",
X					i, c->deliver ? '*' : ' ', c->amount,
X					Commod[c->type], c->owner, c->bidder, c->bid, rate,
X					shipping_cost((int) c->star_from,
X				    (int) Dir[Playernum - 1][Governor].snum,
X						&dist, (int) c->bid), temp);
X				notify(Playernum, Governor, buf);
X			}
X			free(c);
X		}
X	} else {
X		if (Dir[Playernum - 1][Governor].level != LEVEL_PLAN) {
X			notify(Playernum, Governor, "You have to be in a planet scope to buy.\n");
X			return;
X		}
X		snum = Dir[Playernum - 1][Governor].snum;
X		pnum = Dir[Playernum - 1][Governor].pnum;
X		if (Governor && Stars[snum]->governor[Playernum - 1] != Governor) {
X			notify(Playernum, Governor, "You are not authorized in this system.\n");
X			return;
X		}
X		getplanet(&p, snum, pnum);
X		/*
X		 * Cant bid from an enslaved planet
X		 */
X		if (p->slaved_to && p->slaved_to != Playernum) {
X			sprintf(buf, "This planet is enslaved to player %d.\n", p->slaved_to);
X			notify(Playernum, Governor, buf);
X			free(p);
X			return;
X		}
X		/*
X		 * check to see if there is an undamaged gov center or space
X		 * port here
X		 */
X		sh = p->ships;
X		while (sh && !ok) {
X			(void) getship(&s, sh);
X			if (s->alive && (s->owner == Playernum) && !s->damage &&
X			    Shipdata[s->type][ABIL_PORT])
X				ok = 1;
X			sh = s->nextship;
X			free(s);
X		}
X
X		if (!ok) {
X			notify(Playernum, Governor,
X			       "You don't have an undamaged space port or government center here.\n");
X			free(p);
X			return;
X		}
X		lot = atoi(args[1]);
X		bid0 = atoi(args[2]);
X
X		if ((lot <= 0) || lot > Numcommods()) {
X			notify(Playernum, Governor, "Illegal lot number.\n");
X			free(p);
X			return;
X		}
X		/*
X		 * What the HELL does this do?!
X		 */
X		getcommod(&c, lot);
X		if (!c->owner) {
X			notify(Playernum, Governor, "No such lot for sale.\n");
X			free(p);
X			free(c);
X			return;
X		}
X		/*
X		 * if (c->owner == Playernum && (c->star_from !=
X		 * Dir[Playernum-1][c->governor].snum || c->planet_from !=
X		 * Dir[Playernum-1][c->governor].pnum)) { notify(Playernum,
X		 * Governor, "You can only set a minimum price for your lot
X		 * from the location it was sold.\n"); free(p); free(c);
X		 * return; }
X		 */
X		minbid = (int) ((double) c->bid * (1.0 + UP_BID));
X		if (bid0 <= minbid) {
X			sprintf(buf, "You have to bid more than %d.\n", minbid);
X			notify(Playernum, Governor, buf);
X			free(p);
X			free(c);
X			return;
X		}
X		/*
X		 * Don't allow guests to screw things up
X		 */
X		Race = races[Playernum - 1];
X		if (Race->Guest) {
X			notify(Playernum, Governor, "Guest races cannot bid.\n");
X			free(p);
X			free(c);
X			return;
X		}
X		/*
X		 * Make sure they have the bucks
X		 */
X		if (bid0 > Race->governor[Governor].money) {
X			notify(Playernum, Governor, "Sorry, no buying on credit allowed.\n");
X			free(p);
X			free(c);
X			return;
X		}
X		/*
X		 * Make sure we check to see if we have enough for shipping
X		 * costs as well.    --JPD--
X		 */
X		shipcost = shipping_cost((int) c->star_to, (int) c->star_from,
X					 &dist, (int) c->bid);
X
X		if ((bid0 + shipcost) > Race->governor[Governor].money) {
X			sprintf(buf, "The bid (%d) + shipping costs (%d) exceed your money (%d)\n",
X			    bid0, shipcost, Race->governor[Governor].money);
X			notify(Playernum, Governor, buf);
X			free(p);
X			free(c);
X			return;
X		}
X		/*
X		 * Also make sure they have not bid on other things and used
X		 * money earmarked for other lots --JPD--
X		 */
X
X		for (u = 1; u <= Numcommods(); u++) {
X			getcommod(&cc, u);
X			if (cc->bidder == Playernum)
X				money_owed += cc->bid;
X		}
X		free(cc);
X
X		if (((bid0 + shipcost) + money_owed) > Race->governor[Governor].money) {
X			notify(Playernum, Governor, "All your money is used in bids already\n");
X			free(p);
X			free(c);
X			return;
X		}
X		/*
X		 * They passed the credit check, notify the previous bidder
X		 * that he was just outbidded
X		 */
X		if (c->bidder) {
X			sprintf(buf, "The bid on lot #%d (%d %s) has been upped to %d by %s [%d].\n", lot, c->amount, Commod[c->type], bid0, Race->name, Playernum);
X			notify((int) c->bidder, (int) c->bidder_gov, buf);
X		}
X		/*
X		 * Set the commod structs to the new values
X		 */
X		c->bid = bid0;
X		c->bidder = Playernum;
X		c->bidder_gov = Governor;
X		c->star_to = snum;
X		c->planet_to = pnum;
X		shipping = shipcost;
X
X		sprintf(buf, "There will be an additional %d charged to you for shipping costs.\n", shipping);
X		notify(Playernum, Governor, buf);
X		putcommod(c, lot);
X		notify(Playernum, Governor, "Bid accepted.\n");
X		free(p);
X		free(c);
X	}
X}
X
Xint 
Xshipping_cost(int to, int from, double *dist, int value)
X{
X	double          factor, fcost;
X	int             junk;
X
X	*dist = sqrt(Distsq(Stars[to]->xpos, Stars[to]->ypos,
X			    Stars[from]->xpos, Stars[from]->ypos));
X
X	junk = (int) (*dist / 10000.0);
X	junk *= 10000;
X
X	factor = 1.0 - exp(-(double) junk / MERCHANT_LENGTH);
X
X	fcost = factor * (double) value;
X	return (int) fcost;
X
X}
X#endif
END_OF_FILE
if test 51681 -ne `wc -c <'user/build.c2'`; then
    echo shar: \"'user/build.c2'\" unpacked with wrong size!
fi
# end of 'user/build.c2'
fi
echo shar: End of archive 2 \(of 21\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
