Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i026:  gbp - Galactic Bloodshed+, an empire-like war game, Part14/21
Message-ID: <4554@master.CNA.TEK.COM>
Date: 12 Feb 93 17:32:13 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1798
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1705

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 26
Archive-name: gbp/Part14
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 14 (of 21)."
# Contents:  user/capture.c user/explore.c user/orbit.c user/prof.c
#   utils/Makelist.c
# Wrapped by billr@saab on Fri Feb 12 09:14:28 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'user/capture.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/capture.c'\"
else
echo shar: Extracting \"'user/capture.c'\" \(10740 characters\)
sed "s/^X//" >'user/capture.c' <<'END_OF_FILE'
X#ident  "@(#)capture.c	1.5 2/1/93 "
X/*
X * * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, *
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. * Restrictions in
X * GB_copyright.h. *
X * 
X *  capture.c -- capture a ship on the ground *
X * 
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X#include <math.h>
X#include <signal.h>
X#include <strings.h>
X
Xextern int      Defensedata[];
X
Xvoid            capture(int, int, int);
Xvoid            capture_stuff(shiptype *);
X#include "proto.h"
X
Xvoid 
Xcapture(int Playernum, int Governor, int APcount)
X{
X	shiptype       *ship, s;
X	planettype     *p;
X	sectortype     *sect;
X	int             boarders, olddpopn, oldapopn, oldowner, oldgov,
X	                shipdam = 0, booby = 0;
X	int             shipno, nextshipno, x = -1, y = -1, what, olddtroops,
X	                i;
X	int             casualties = 0, casualties1 = 0, casualties2 = 0,
X	                casualty_scale = 0;
X	double          astrength, dstrength;
X	racetype       *Race, *alien;
X	int             snum, pnum;
X
X	if (argn < 2) {
X		notify(Playernum, Governor, "Capture what?\n");
X		return;
X	}
X	snum = Dir[Playernum - 1][Governor].snum;
X	pnum = Dir[Playernum - 1][Governor].pnum;
X	if (Governor && Stars[snum]->governor[Playernum - 1] != Governor) {
X		notify(Playernum, Governor, "You are not authorized in this system.\n");
X		return;
X	}
X	nextshipno = start_shiplist(Playernum, Governor, args[1]);
X	while (shipno = do_shiplist(&ship, &nextshipno))
X		if (ship->owner != Playernum &&
X		    in_list((int) ship->owner, args[1], ship, &nextshipno)) {
X			if (!landed(ship)) {
X				sprintf(buf, "%s #%d is not landed on a planet.\n",
X					Shipnames[ship->type], shipno);
X				notify(Playernum, Governor, buf);
X				free(ship);
X				continue;
X			}
X			if (!enufAP(Playernum, Governor, Stars[ship->storbits]->AP[Playernum - 1], APcount)) {
X				free(ship);
X				continue;
X			}
X			x = ship->land_x;
X			y = ship->land_y;
X
X			getplanet(&p, (int) ship->storbits, (int) ship->pnumorbits);
X			getsector(&sect, p, x, y);
X
X			if (sect->owner != Playernum) {
X				sprintf(buf, "You don't own the sector where the ship is landed [%d].\n",
X					sect->owner);
X				notify(Playernum, Governor, buf);
X				free(sect);
X				free(p);
X				free(ship);
X				continue;
X			}
X			if (argn < 4)
X				what = CIV;
X			else if (match(args[3], "civilians"))
X				what = CIV;
X			else if (match(args[3], "military"))
X				what = MIL;
X			else {
X				notify(Playernum, Governor, "Capture with what?\n");
X				free(sect);
X				free(p);
X				free(ship);
X				continue;
X			}
X
X			if (argn < 3) {
X				if (what == CIV)
X					boarders = sect->popn;
X				else if (what == MIL)
X					boarders = sect->troops;
X			} else
X				boarders = atoi(args[2]);
X
X			if (boarders <= 0) {
X				sprintf(buf, "Illegal number of boarders %d.\n", boarders);
X				notify(Playernum, Governor, buf);
X				free(ship);
X				free(sect);
X				free(p);
X				continue;
X			}
X			if ((boarders > sect->popn) && what == CIV)
X				boarders = sect->popn;
X			else if ((boarders > sect->troops) && what == MIL)
X				boarders = sect->troops;
X
X			Race = races[Playernum - 1];
X			alien = races[ship->owner - 1];
X
X			if (isset(Race->allied, (int) (ship->owner))) {
X				sprintf(buf, "Boarding the ship of your ally, %s\n", alien->name);
X				notify(Playernum, Governor, buf);
X			}
X			oldapopn = boarders;
X			olddpopn = ship->popn;
X			olddtroops = ship->troops;
X			oldowner = ship->owner;
X			oldgov = ship->governor;
X			bcopy(ship, &s, sizeof(shiptype));
X
X			shipdam = 0;
X			casualties = 0;
X			casualties1 = 0;
X			casualties2 = 0;
X
X			if (what == CIV)
X				sect->popn -= boarders;
X			else if (what == MIL)
X				sect->troops -= boarders;
X
X			if (olddpopn + olddtroops) {
X				sprintf(buf, "Attack strength: %.2f     Defense strength: %.2f\n",
X					astrength = (double) boarders
X					* (what == MIL ? (double) Race->fighters * 10.0 : 1.0)
X					* .01 * Race->tech
X				     * (Race->likes[sect->condition] + 0.01)
X					* ((double) Defensedata[sect->condition] + 1.0)
X					* morale_factor((double) (Race->morale - alien->morale)),
X
X					dstrength = ((double) ship->popn + (double) ship->troops * 10.0
X						 * (double) alien->fighters)
X					* .01 * alien->tech
X					* ((double) (Armor(ship)) + 0.01)
X				     * .01 * (100.0 - (double) ship->damage)
X					* morale_factor((double) (alien->morale - Race->morale))
X					);
X				notify(Playernum, Governor, buf);
X				casualty_scale = MIN(boarders, ship->popn + ship->troops);
X				if (astrength > 0.0)
X					casualties = int_rand(0, round_rand((double) casualty_scale * (dstrength + 1.0) /
X							(astrength + 1.0)));
X
X				if (dstrength > 0.0) {
X					casualties1 = int_rand(0, round_rand((double) casualty_scale * (astrength + 1.0) /
X							(dstrength + 1.0)));
X					casualties2 = int_rand(0, round_rand((double) casualty_scale * (astrength + 1.0) /
X							(dstrength + 1.0)));
X					shipdam = int_rand(0, round_rand(25. * (astrength + 1.0) / (dstrength + 1.0)));
X					ship->damage = MIN(100, ship->damage + shipdam);
X				}
X				casualties = MIN(boarders, casualties);
X				boarders -= casualties;
X
X				casualties1 = MIN(olddpopn, casualties1);
X				ship->popn -= casualties1;
X				ship->mass -= casualties1 * alien->mass;
X
X				casualties2 = MIN(olddtroops, casualties2);
X				ship->troops -= casualties2;
X				ship->mass -= casualties2 * alien->mass;
X
X			} else if (ship->destruct) {	/* booby trapped robot
X							 * ships */
X				booby = int_rand(0, 10 * (int) ship->destruct);
X				booby = MIN(100, booby);
X				casualties = casualties2 = 0;
X				for (i = 0; i < boarders; i++)
X					casualties += (int_rand(1, 100) < booby);
X				boarders -= casualties;
X				shipdam += booby;
X				ship->damage += booby;
X			}
X			shipdam = MIN(100, shipdam);
X			if (ship->damage >= 100)
X				kill_ship(Playernum, ship);
X
X			if (!(ship->popn + ship->troops) && ship->alive) {
X				/* we got 'em */
X				ship->owner = Playernum;
X				ship->governor = Governor;
X				if (what == CIV) {
X					ship->popn = MIN(boarders, Max_crew(ship));
X					sect->popn += boarders - ship->popn;
X					ship->mass += ship->popn * Race->mass;
X				} else if (what == MIL) {
X					ship->troops = MIN(boarders, Max_mil(ship));
X					sect->troops += boarders - ship->troops;
X					ship->mass += ship->troops * Race->mass;
X				}
X				if (olddpopn + olddtroops && ship->type != OTYPE_FACTORY)
X					adjust_morale(Race, alien, (int) ship->build_cost);
X				/* unoccupied ships and factories don't count */
X			} else {/* retreat */
X				if (what == CIV)
X					sect->popn += boarders;
X				else if (what == MIL)
X					sect->troops += boarders;
X			}
X
X			if (!(sect->popn + sect->troops))
X				sect->owner = 0;
X
X			sprintf(buf, "BULLETIN from %s/%s!!\n",
X				Stars[ship->storbits]->name, Stars[ship->storbits]->pnames[ship->pnumorbits]);
X			strcpy(telegram_buf, buf);
X			sprintf(buf, "You are being attacked by%s Player #%d (%s)!!!\n",
X			   (isset(alien->allied, Playernum) ? " your ally" :
X			    (isset(alien->atwar, Playernum) ? " your enemy" : " neutral")),
X				Playernum, Race->name);
X			strcat(telegram_buf, buf);
X			sprintf(buf, "%s at sector %d,%d [owner %d] !\n",
X				Ship(ship), x, y, sect->owner);
X			strcat(telegram_buf, buf);
X
X			if (booby) {
X				sprintf(buf, "Booby trap triggered causing %d%% damage.\n", booby);
X				strcat(telegram_buf, buf);
X				notify(Playernum, Governor, buf);
X			}
X			if (shipdam) {
X				sprintf(buf, "Total damage: %d%% (now %d%%)\n", shipdam, ship->damage);
X				strcat(telegram_buf, buf);
X				sprintf(buf, "Damage inflicted:  Them: %d%% (now %d%%)\n",
X					shipdam, ship->damage);
X				notify(Playernum, Governor, buf);
X			}
X			if (!ship->alive) {
X				sprintf(buf, "              YOUR SHIP WAS DESTROYED!!!\n");
X				strcat(telegram_buf, buf);
X				sprintf(buf, "              Their ship DESTROYED!!!\n");
X				notify(Playernum, Governor, buf);
X				sprintf(short_buf, "%s: %s [%d] DESTROYED %s\n",
X					Dispshiploc(ship), Race->name, Playernum, Ship(&s));
X			}
X			if (ship->owner == Playernum) {
X				sprintf(buf, "%s CAPTURED!\n", Ship(&s));
X				notify(oldowner, oldgov, buf);
X				sprintf(buf, "VICTORY! The ship is yours!\n");
X				notify(Playernum, Governor, buf);
X				if (what == CIV)
X					sprintf(buf, "%d boarders move in.\n", MIN(boarders, ship->popn));
X				else if (what == MIL)
X					sprintf(buf, "%d troops move in.\n", MIN(boarders, ship->troops));
X				notify(Playernum, Governor, buf);
X				capture_stuff(ship);
X				sprintf(short_buf, "%s: %s [%d] CAPTURED %s\n",
X					Dispshiploc(ship), Race->name, Playernum, Ship(&s));
X			} else if (ship->popn + ship->troops) {
X				sprintf(buf, "You fought them off!\n");
X				notify(oldowner, oldgov, buf);
X				sprintf(buf, "The boarding was repulsed; try again.\n");
X				notify(Playernum, Governor, buf);
X				sprintf(short_buf, "%s: %s [%d] assaults %s\n",
X					Dispshiploc(ship), Race->name, Playernum, Ship(&s));
X			}
X			if (ship->alive) {
X				if (sect->popn + sect->troops + boarders) {
X					sprintf(buf, "You killed all the aliens in this sector!\n");
X					strcat(telegram_buf, buf);
X					p->info[Playernum - 1].mob_points -= sect->mobilization;
X				}
X				if (!boarders) {
X					sprintf(buf, "Oh no! They killed your party to the last man!\n");
X					notify(Playernum, Governor, buf);
X				}
X			} else {
X				sprintf(buf, "Your ship was weakened too much!\n");
X				strcat(telegram_buf, buf);
X				sprintf(buf, "The assault weakened their ship too much!\n");
X				notify(Playernum, Governor, buf);
X			}
X
X			if (casualties || casualties1 || casualties2) {
X				sprintf(buf, "Casualties: Yours: %d civ/%d mil, Theirs: %d %s\n",
X					casualties1, casualties2, casualties, what == CIV ? "civ" : "mil");
X				strcat(telegram_buf, buf);
X				sprintf(buf, "Casualties: Yours: %d %s, Theirs: %d civ/%d mil\n",
X					casualties, what == CIV ? "civ" : "mil", casualties1, casualties2);
X				notify(Playernum, Governor, buf);
X			}
X			warn(oldowner, oldgov, telegram_buf);
X			if (ship->owner != oldowner || !ship->alive)
X				post(short_buf, COMBAT);
X			notify_star(Playernum, Governor, oldowner,
X				    (int) ship->storbits, short_buf);
X			putship(ship);
X			putsector(sect, p, x, y);
X			putplanet(p, snum, pnum);
X			putrace(Race);
X			putrace(alien);
X			deductAPs(Playernum, Governor, APcount, (int) ship->storbits, 0);
X			free(p);
X			free(ship);
X			free(sect);
X		} else
X			free(ship);
X
X}
X
Xvoid 
Xcapture_stuff(shiptype * ship)
X{
X	int             sh;
X	shiptype       *s;
X
X	sh = ship->ships;
X	while (sh) {
X		(void) getship(&s, sh);
X		capture_stuff(s);	/* recursive call */
X		s->owner = ship->owner;	/* make sure he gets all of the ships
X					 * landed on it */
X		s->governor = ship->governor;
X		putship(s);
X		sprintf(buf, "%s CAPTURED!\n", Ship(s));
X		notify((int) s->owner, (int) s->governor, buf);
X		sh = s->nextship;
X		free(s);
X	}
X}
END_OF_FILE
if test 10740 -ne `wc -c <'user/capture.c'`; then
    echo shar: \"'user/capture.c'\" unpacked with wrong size!
fi
# end of 'user/capture.c'
fi
if test -f 'user/explore.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/explore.c'\"
else
echo shar: Extracting \"'user/explore.c'\" \(12697 characters\)
sed "s/^X//" >'user/explore.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h. explore.c -- display systems/worlds explored (this command
X * written by Dan Corrin, dan@geomech.engrg.uwo.ca)
X * 
X * Thu Apr 11 02:19:44 MDT 1991 Made mods to this prior, but forgot the header.
X * :) Evan Koffler
X */
X#include <math.h>
X#include <strings.h>
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
Xextern char     Psymbol[], *Planet_types[];
X
Xvoid            colonies_at_star(int, int, racetype *, int, int);
Xvoid            colonies(int, int, int, int);
Xvoid            distance(int, int, int);
Xvoid            star_locations(int, int, int);
Xvoid            exploration(int, int, int);
Xvoid            tech_status(int, int, int);
Xvoid            tech_report_star(int, int, startype *, int, int *, double *, double *);
X#include "proto.h"
X
Xvoid 
Xcolonies_at_star(int Playernum, int Governor, racetype * Race, int star, int mode)
X{
X	int             i, j;
X	planettype     *pl;
X
X	getstar(&(Stars[star]), star);
X	if (!isset(Stars[star]->explored, Playernum))
X		return;
X
X	for (i = 0; i < Stars[star]->numplanets; i++) {
X		getplanet(&pl, star, i);
X
X		if (pl->info[Playernum - 1].explored &&
X		    pl->info[Playernum - 1].numsectsowned &&
X		    (!Governor || Stars[star]->governor[Playernum - 1] == Governor)) {
X			switch (mode) {
X			case -1:	/* combined report */
X			case 0:/* colonies */
X				sprintf(buf,
X					" %c %4.4s/%-4.4s%c%4d%3d%5d%8d%3d%6d%5d%6d %3d/%-3d%3.0f/%-3d%3d/%-3d",
X					Psymbol[pl->type],
X					Stars[star]->name,
X					Stars[star]->pnames[i],
X					(pl->info[Playernum - 1].autorep ? '*' : ' '),
X					Stars[star]->governor[Playernum - 1],
X				      pl->info[Playernum - 1].numsectsowned,
X					pl->info[Playernum - 1].tech_invest,
X					pl->info[Playernum - 1].popn,
X					pl->info[Playernum - 1].crystals,
X					pl->info[Playernum - 1].resource,
X					pl->info[Playernum - 1].destruct,
X					pl->info[Playernum - 1].fuel,
X					pl->info[Playernum - 1].tax,
X					pl->info[Playernum - 1].newtax,
X					compatibility(pl, Race),
X					pl->conditions[TOXIC],
X					pl->info[Playernum - 1].comread,
X					pl->info[Playernum - 1].mob_set);
X				notify(Playernum, Governor, buf);
X				for (j = 1; j <= Num_races; j++)
X					if ((j != Playernum) && (pl->info[j - 1].numsectsowned > 0)) {
X						sprintf(buf, " %d", j);
X						notify(Playernum, Governor, buf);
X					}
X				notify(Playernum, Governor, "\n");
X				if (mode == 0)
X					break;
X				/* Fall through if (mode == -1) */
X			case 1:/* production */
X				sprintf(buf,
X					" %c %4.4s/%-4.4s%c%3d%8.4f%8d%3d%6d%5d%6d %6d   %3d%8.2f\n",
X					Psymbol[pl->type],
X				  Stars[star]->name, Stars[star]->pnames[i],
X					(pl->info[Playernum - 1].autorep ? '*' : ' '),
X					Stars[star]->governor[Playernum - 1],
X					pl->info[Playernum - 1].prod_tech,
X					pl->total_resources,
X				      pl->info[Playernum - 1].prod_crystals,
X					pl->info[Playernum - 1].prod_res,
X					pl->info[Playernum - 1].prod_dest,
X					pl->info[Playernum - 1].prod_fuel,
X					pl->info[Playernum - 1].prod_money,
X					pl->info[Playernum - 1].tox_thresh,
X				    pl->info[Playernum - 1].est_production);
X				notify(Playernum, Governor, buf);
X				break;
X			default:
X				break;
X			}
X		}
X		free(pl);
X	}
X}
X
Xvoid 
Xcolonies(int Playernum, int Governor, int APcount, int mode)
X{
X	int             i, star;
X	racetype       *Race;
X	placetype       where;
X
X	switch (mode) {
X	case -1:
X		notify(Playernum, Governor, "          ========= Colonies Prod Report ==========\n");
X		notify(Playernum, Governor, "  Planet     gov sec tech    popn  x   res  des  fuel  tax  cmpt/tox mob   Aliens\n");
X		notify(Playernum, Governor, "               tox  deposit\n");
X		break;
X	case 0:
X		notify(Playernum, Governor, "          ========== Colonization Report ==========\n");
X		notify(Playernum, Governor, "  Planet     gov sec tech    popn  x   res  des  fuel  tax  cmpt/tox mob  Aliens\n");
X		break;
X	case 1:
X		notify(Playernum, Governor, "          ============ Production Report ==========\n");
X		notify(Playernum, Governor, "  Planet     gov    tech deposit  x   res  des  fuel    tax   tox  est prod\n");
X		break;
X	default:
X		notify(Playernum, Governor, "          =============== Unknown Report ==========\n");
X		return;
X	}
X
X	Race = races[Playernum - 1];
X	getsdata(&Sdata);
X
X	if (argn < 2)
X		for (star = 0; star < Sdata.numstars; star++)
X			colonies_at_star(Playernum, Governor, Race, star, mode);
X	else
X		for (i = 1; i < argn; i++) {
X			where = Getplace(Playernum, Governor, args[i], 0);
X			if (where.err || (where.level == LEVEL_UNIV) || (where.level == LEVEL_SHIP)) {
X				sprintf(buf, "Bad location `%s'.\n", args[i]);
X				notify(Playernum, Governor, buf);
X				continue;
X			} else	/* ok, a proper location */
X				colonies_at_star(Playernum, Governor, Race, where.snum, mode);
X		}
X	notify(Playernum, Governor, "\n");
X}
X
X
Xvoid 
Xdistance(int Playernum, int Governor, int APcount)
X{
X	placetype       from, to;
X	planettype     *p;
X	double          x0, y0, x1, y1, dist;
X	shiptype       *ship;
X
X	if (argn < 3) {
X		notify(Playernum, Governor, "Syntax: 'distance <from> <to>'.\n");
X		return;
X	}
X	from = Getplace(Playernum, Governor, args[1], 1);
X	if (from.err) {
X		sprintf(buf, "Bad scope '%s'.\n", args[1]);
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	to = Getplace(Playernum, Governor, args[2], 1);
X	if (to.err) {
X		sprintf(buf, "Bad scope '%s'.\n", args[2]);
X		notify(Playernum, Governor, buf);
X	}
X	x0 = 0.0;
X	y0 = 0.0;
X	x1 = 0.0;
X	y1 = 0.0;
X	/* get position in absolute units */
X	if (from.level == LEVEL_SHIP) {
X		(void) getship(&ship, from.shipno);
X		if (ship->owner != Playernum) {
X			notify(Playernum, Governor, "Nice try.\n");
X			free(ship);
X			return;
X		}
X		x0 = ship->xpos;
X		y0 = ship->ypos;
X		free(ship);
X	} else if (from.level == LEVEL_PLAN) {
X		getplanet(&p, (int) from.snum, (int) from.pnum);
X		x0 = p->xpos + Stars[from.snum]->xpos;
X		y0 = p->ypos + Stars[from.snum]->ypos;
X		free(p);
X	} else if (from.level == LEVEL_STAR) {
X		x0 = Stars[from.snum]->xpos;
X		y0 = Stars[from.snum]->ypos;
X	}
X	if (to.level == LEVEL_SHIP) {
X		(void) getship(&ship, to.shipno);
X		if (ship->owner != Playernum) {
X			notify(Playernum, Governor, "Nice try.\n");
X			free(ship);
X			return;
X		}
X		x1 = ship->xpos;
X		y1 = ship->ypos;
X		free(ship);
X	} else if (to.level == LEVEL_PLAN) {
X		getplanet(&p, (int) to.snum, (int) to.pnum);
X		x1 = p->xpos + Stars[to.snum]->xpos;
X		y1 = p->ypos + Stars[to.snum]->ypos;
X		free(p);
X	} else if (to.level == LEVEL_STAR) {
X		x1 = Stars[to.snum]->xpos;
X		y1 = Stars[to.snum]->ypos;
X	}
X	/* compute the distance */
X	dist = sqrt(Distsq(x0, y0, x1, y1));
X	sprintf(buf, "Distance = %f\n", dist);
X	notify(Playernum, Governor, buf);
X}
X
Xvoid 
Xstar_locations(int Playernum, int Governor, int APcount)
X{
X	reg int         i;
X	double          dist, x, y;
X	int             max;
X
X	x = Dir[Playernum - 1][Governor].lastx[1];
X	y = Dir[Playernum - 1][Governor].lasty[1];
X
X	if (argn > 1)
X		max = atoi(args[1]);
X	else
X		max = 999999;
X
X	for (i = 0; i < Sdata.numstars; i++) {
X		dist = sqrt(Distsq(Stars[i]->xpos, Stars[i]->ypos, x, y));
X		if ((int) dist <= max) {
X			sprintf(buf, "(%2d) %20.20s (%8.0f,%8.0f) %7.0f\n", i,
X				Stars[i]->name, Stars[i]->xpos, Stars[i]->ypos, dist);
X			notify(Playernum, Governor, buf);
X		}
X	}
X}
X
Xvoid 
Xexploration(int Playernum, int Governor, int APcount)
X{
X	int             star, starq, i, j;
X	planettype     *pl;
X	placetype       where;
X	racetype       *Race;
X
X	starq = -1;
X
X	if (argn == 2) {
X		where = Getplace(Playernum, Governor, args[1], 0);
X		if (where.err) {
X			sprintf(buf, "explore: bad scope.\n");
X			notify(Playernum, Governor, buf);
X			return;
X		} else if (where.level == LEVEL_SHIP || where.level == LEVEL_UNIV) {
X			sprintf(buf, "Bad scope '%s'.\n", args[1]);
X			notify(Playernum, Governor, buf);
X			return;
X		}
X		starq = where.snum;
X	}
X	Race = races[Playernum - 1];
X
X	getsdata(&Sdata);
X	sprintf(buf, "         ========== Exploration Report ==========\n");
X	notify(Playernum, Governor, buf);
X	sprintf(buf, " Global action points : [%2d]\n", Sdata.AP[Playernum - 1]);
X	notify(Playernum, Governor, buf);
X	sprintf(buf, " Star  (stability)[AP]   #  Planet [Attributes] Type (Compatibility)\n");
X	notify(Playernum, Governor, buf);
X	for (star = 0; star < Sdata.numstars; star++)
X		if ((starq == -1) || (starq == star)) {
X			getstar(&(Stars[star]), star);
X			if (isset(Stars[star]->explored, Playernum))
X				for (i = 0; i < Stars[star]->numplanets; i++) {
X					getplanet(&pl, star, i);
X					if (i == 0)
X						if (Race->tech >= TECH_SEE_STABILITY) {
X							sprintf(buf, "\n%13s (%2d)[%2d]\n", Stars[star]->name, Stars[star]->stability,
X								Stars[star]->AP[Playernum - 1]);
X							notify(Playernum, Governor, buf);
X						} else {
X							sprintf(buf, "\n%13s (/?/?)[%2d]\n", Stars[star]->name,
X								Stars[star]->AP[Playernum - 1]);
X							notify(Playernum, Governor, buf);
X						}
X
X
X					sprintf(buf, "  #%d. %-15s [ ", i + 1, Stars[star]->pnames[i]);
X					notify(Playernum, Governor, buf);
X					if (pl->info[Playernum - 1].explored) {
X						sprintf(buf, "Ex ");
X						notify(Playernum, Governor, buf);
X						if (pl->info[Playernum - 1].autorep) {
X							sprintf(buf, "Rep ");
X							notify(Playernum, Governor, buf);
X						}
X						if (pl->info[Playernum - 1].numsectsowned) {
X							sprintf(buf, "Inhab ");
X							notify(Playernum, Governor, buf);
X						}
X						if (pl->slaved_to) {
X							sprintf(buf, "SLAVED ");
X							notify(Playernum, Governor, buf);
X						}
X						for (j = 1; j <= Num_races; j++)
X							if (j != Playernum && pl->info[j - 1].numsectsowned) {
X								sprintf(buf, "%d ", j);
X								notify(Playernum, Governor, buf);
X							}
X						if (pl->conditions[TOXIC] > 70) {
X							sprintf(buf, "TOXIC ");
X							notify(Playernum, Governor, buf);
X						}
X						sprintf(buf, "] %s %2.0f%%\n", Planet_types[pl->type],
X						   compatibility(pl, Race));
X						notify(Playernum, Governor, buf);
X					} else {
X						sprintf(buf, "No Data ]\n");
X						notify(Playernum, Governor, buf);
X					}
X					free(pl);
X				}
X		}
X}
X
Xvoid 
Xtech_status(int Playernum, int Governor, int APcount)
X{
X	int             star, k;
X	placetype       where;
X	double          total_gain = 0.0;
X	double          total_max_gain = 0.0;
X	int             total_invest = 0;
X
X	getsdata(&Sdata);
X
X	sprintf(buf, "             ========== Technology Report ==========\n\n");
X	notify(Playernum, Governor, buf);
X
X	sprintf(buf, "       Planet          popn    invest    gain   ^gain\n");
X	notify(Playernum, Governor, buf);
X
X	if (argn == 1) {
X		for (star = 0; star < Sdata.numstars; star++) {
X			getstar(&(Stars[star]), star);
X			tech_report_star(Playernum, Governor, Stars[star], star,
X			       &total_invest, &total_gain, &total_max_gain);
X		}
X	} else {		/* Several arguments */
X		for (k = 1; k < argn; k++) {
X			where = Getplace(Playernum, Governor, args[k], 0);
X			if (where.err || where.level == LEVEL_UNIV || where.level == LEVEL_SHIP) {
X				sprintf(buf, "Bad location `%s'.\n", args[k]);
X				notify(Playernum, Governor, buf);
X				continue;
X			} else {/* ok, a proper location */
X				star = where.snum;
X				getstar(&Stars[star], star);
X				tech_report_star(Playernum, Governor, Stars[star], star,
X				&total_invest, &total_gain, &total_max_gain);
X			}
X		}
X	}
X	sprintf(buf, "       Total Popn:  %7ld\n", Power[Playernum - 1].popn);
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "Tech: %31d%8.3lf%8.3lf\n",
X		total_invest, total_gain, total_max_gain);
X	notify(Playernum, Governor, buf);
X}
X
X
Xvoid 
Xtech_report_star(int Playernum, int Governor, startype * star, int snum,
X		 int *t_invest, double *t_gain, double *t_max_gain)
X{
X	int             i;
X	planettype     *pl;
X	char            str[200];
X	double          gain, max_gain;
X
X	if (isset(star->explored, Playernum) &&
X	    (!Governor || star->governor[Playernum - 1] == Governor)) {
X		for (i = 0; i < star->numplanets; i++) {
X			getplanet(&pl, snum, i);
X			if (pl->info[Playernum - 1].explored
X			    && pl->info[Playernum - 1].numsectsowned) {
X				sprintf(str, "%s/%s%s", star->name, star->pnames[i],
X					(pl->info[Playernum - 1].autorep ? "*" : ""));
X				sprintf(buf, "%16.16s %10d%10d%8.3lf%8.3lf\n", str,
X					pl->info[Playernum - 1].popn,
X					pl->info[Playernum - 1].tech_invest,
X					gain = tech_prod((int) pl->info[Playernum - 1].tech_invest,
X					(int) pl->info[Playernum - 1].popn),
X					max_gain = tech_prod((int) pl->info[Playernum - 1].prod_res,
X				       (int) pl->info[Playernum - 1].popn));
X				notify(Playernum, Governor, buf);
X				*t_invest += pl->info[Playernum - 1].tech_invest;
X				*t_gain += gain;
X				*t_max_gain += max_gain;
X			}
X			free(pl);
X		}
X	}
X}
END_OF_FILE
if test 12697 -ne `wc -c <'user/explore.c'`; then
    echo shar: \"'user/explore.c'\" unpacked with wrong size!
fi
# end of 'user/explore.c'
fi
if test -f 'user/orbit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/orbit.c'\"
else
echo shar: Extracting \"'user/orbit.c'\" \(12472 characters\)
sed "s/^X//" >'user/orbit.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * orbit.c -- display orbits of planets (graphic representation)
X * 
X * OPTIONS -p : If this option is set, ``orbit'' will not display planet names.
X * 
X * -S : Do not display star names.
X * 
X * -s : Do not display ships.
X * 
X * -(number) : Do not display that #'d ship or planet (in case it obstructs the
X * view of another object)
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X#include <curses.h>
X#include <stdio.h>
Xextern char     Shipltrs[];
Xdouble          Lastx, Lasty, Zoom;
Xint             SCALE = 100;
X
Xracetype       *Race;
X
Xchar            Psymbol[] = {'@', 'o', 'O', '#', '~', '.', ')', '-'};
Xchar           *Planet_types[] = {"Class M", "Asteroid", "Airless", "Iceball",
X"Jovian", "Waterball", "Forest", "Desert"};
X
Xvoid            orbit(int, int, int);
Xvoid            DispStar(int, int, int, startype *, int, int, char *);
Xvoid            DispPlanet(int, int, int, planettype *, char *, int, racetype *, char *);
Xvoid            DispShip(int, int, placetype *, shiptype *, planettype *, int, char *);
X#include "proto.h"
X
Xvoid 
Xorbit(int Playernum, int Governor, int APcount)
X{
X	register int    sh, i, iq;
X	int             DontDispNum = -1, flag;
X	planettype     *p;
X	shiptype       *s;
X	placetype       where;
X	int             DontDispPlanets, DontDispShips, DontDispStars;
X	char            output[100000];
X
X	DontDispPlanets = DontDispShips = DontDispStars = 0;
X
X	/* find options, set flags accordingly */
X	for (flag = 1; flag <= argn - 1; flag++)
X		if (*args[flag] == '-') {
X			for (i = 1; args[flag][i] != '\0'; i++)
X				switch (args[flag][i]) {
X				case 's':
X					DontDispShips = 1;
X					break;
X				case 'S':
X					DontDispStars = 1;
X					break;
X				case 'p':
X					DontDispPlanets = 1;
X					break;
X				default:
X					if (sscanf(args[flag] + 1, "%d", &DontDispNum) != 1) {
X						sprintf(buf, "Bad number %s.\n", args[flag] + 1);
X						notify(Playernum, Governor, buf);
X						DontDispNum = -1;
X					}
X					if (DontDispNum)
X						DontDispNum--;	/* make a '1' into a '0' */
X					break;
X				}
X		}
X	if (argn == 1) {
X		where = Getplace(Playernum, Governor, ":", 0);
X		i = (Dir[Playernum - 1][Governor].level == LEVEL_UNIV);
X		Lastx = Dir[Playernum - 1][Governor].lastx[i];
X		Lasty = Dir[Playernum - 1][Governor].lasty[i];
X		Zoom = Dir[Playernum - 1][Governor].zoom[i];
X	} else {
X		where = Getplace(Playernum, Governor, args[argn - 1], 0);
X		Lastx = Lasty = 0.0;
X		Zoom = 1.1;
X	}
X
X	if (where.err) {
X		notify(Playernum, Governor, "orbit: error in args.\n");
X		return;
X	}
X	/* orbit type of map */
X	sprintf(output, "#");
X
X	Race = races[Playernum - 1];
X
X	switch (where.level) {
X	case LEVEL_UNIV:
X		for (i = 0; i < Sdata.numstars; i++)
X			if (DontDispNum != i) {
X				DispStar(Playernum, Governor, LEVEL_UNIV, Stars[i], DontDispStars,
X					 (int) Race->God, buf);
X				strcat(output, buf);
X			}
X		if (!DontDispShips) {
X			sh = Sdata.ships;
X			while (sh) {
X				(void) getship(&s, sh);
X				if (DontDispNum != sh) {
X					DispShip(Playernum, Governor, &where, s, NULL,
X						 (int) Race->God, buf);
X					strcat(output, buf);
X				}
X				sh = s->nextship;
X				free(s);
X			}
X		}
X		break;
X	case LEVEL_STAR:
X		DispStar(Playernum, Governor, LEVEL_STAR, Stars[where.snum],
X			 DontDispStars, (int) Race->God, buf);
X		strcat(output, buf);
X
X		for (i = 0; i < Stars[where.snum]->numplanets; i++)
X			if (DontDispNum != i) {
X				getplanet(&p, (int) where.snum, i);
X				DispPlanet(Playernum, Governor, LEVEL_STAR, p,
X					   Stars[where.snum]->pnames[i], DontDispPlanets, Race, buf);
X				strcat(output, buf);
X				free(p);
X			}
X		/*
X		 * check to see if you have ships at orbiting the star, if so
X		 * you can see enemy ships
X		 */
X		iq = 0;
X		if (Race->God)
X			iq = 1;
X		else {
X			sh = Stars[where.snum]->ships;
X			while (sh && !iq) {
X				(void) getship(&s, sh);
X				if (s->owner == Playernum && Sight(s))
X					iq = 1;	/* you are there to sight,
X						 * need a crew */
X				sh = s->nextship;
X				free(s);
X			}
X		}
X		if (!DontDispShips) {
X			sh = Stars[where.snum]->ships;
X			while (sh) {
X				(void) getship(&s, sh);
X				if (DontDispNum != sh &&
X				    !(s->owner != Playernum && s->type == STYPE_MINE)) {
X					if ((s->owner == Playernum) || (iq == 1)) {
X						DispShip(Playernum, Governor, &where, s, NULL,
X						      (int) Race->God, buf);
X						strcat(output, buf);
X					}
X				}
X				sh = s->nextship;
X				free(s);
X			}
X		}
X		break;
X	case LEVEL_PLAN:
X		getplanet(&p, (int) where.snum, (int) where.pnum);
X		DispPlanet(Playernum, Governor, LEVEL_PLAN, p,
X			   Stars[where.snum]->pnames[where.pnum],
X			   DontDispPlanets, Race, buf);
X		strcat(output, buf);
X
X		/*
X		 * check to see if you have ships at landed or orbiting the
X		 * planet, if so you can see orbiting enemy ships
X		 */
X		iq = 0;
X		sh = p->ships;
X		while (sh && !iq) {
X			(void) getship(&s, sh);
X			if (s->owner == Playernum && Sight(s))
X				iq = 1;	/* you are there to sight, need a
X					 * crew */
X			sh = s->nextship;
X			free(s);
X		}
X		/* end check */
X		if (!DontDispShips) {
X			sh = p->ships;
X			while (sh) {
X				(void) getship(&s, sh);
X				if (DontDispNum != sh) {
X					if (!landed(s)) {
X						if ((s->owner == Playernum) || (iq == 1)) {
X							DispShip(Playernum, Governor, &where, s, p,
X								 (int) Race->God, buf);
X							strcat(output, buf);
X						}
X					}
X				}
X				sh = s->nextship;
X				free(s);
X			}
X		}
X		free(p);
X		break;
X	default:
X		notify(Playernum, Governor, "Bad scope.\n");
X		return;
X	}
X	strcat(output, "\n");
X	notify(Playernum, Governor, output);
X}
X
Xvoid 
XDispStar(int Playernum, int Governor, int level, startype * star,
X	 int DontDispStars, int God, char *string)
X{
X	int             x, y;
X	int             stand;
X	int             iq;
X	double          fac;
X
X	*string = '\0';
X
X	if (level == LEVEL_UNIV) {
X		fac = 1.0;
X		x = (int) (SCALE + ((SCALE * (star->xpos - Lastx)) / (UNIVSIZE * Zoom)));
X		y = (int) (SCALE + ((SCALE * (star->ypos - Lasty)) / (UNIVSIZE * Zoom)));
X	} else if (level == LEVEL_STAR) {
X		fac = 1000.0;
X		x = (int) (SCALE + (SCALE * (-Lastx)) / (SYSTEMSIZE * Zoom));
X		y = (int) (SCALE + (SCALE * (-Lasty)) / (SYSTEMSIZE * Zoom));
X	}
X	/*
X	 * if (star->nova_stage) DispArray(x, y, 11,7,
X	 * Novae[star->nova_stage-1], fac);
X	 */
X	if (y >= 0 && x >= 0) {
X		iq = 0;
X		if (Race->governor[Governor].toggle.color) {
X			stand = (isset(star->explored, Playernum) ? Playernum : 0) + '?';
X			sprintf(temp, "%c %d %d 0 * ", (char) stand, x, y);
X			strcat(string, temp);
X			stand = (isset(star->inhabited, Playernum) ? Playernum : 0) + '?';
X			sprintf(temp, "%c %s;", (char) stand, star->name);
X			strcat(string, temp);
X		} else {
X			stand = (isset(star->explored, Playernum) ? 1 : 0);
X			sprintf(temp, "%d %d %d 0 * ", stand, x, y);
X			strcat(string, temp);
X			stand = (isset(star->inhabited, Playernum) ? 1 : 0);
X			sprintf(temp, "%d %s;", stand, star->name);
X			strcat(string, temp);
X		}
X	}
X}
X
Xvoid 
XDispPlanet(int Playernum, int Governor, int level, planettype * p,
X	   char *name, int DontDispPlanets, racetype * r, char *string)
X{
X	int             x, y;
X	int             stand;
X
X	*string = '\0';
X
X	if (level == LEVEL_STAR) {
X		y = (int) (SCALE + (SCALE * (p->ypos - Lasty)) / (SYSTEMSIZE * Zoom));
X		x = (int) (SCALE + (SCALE * (p->xpos - Lastx)) / (SYSTEMSIZE * Zoom));
X	} else if (level == LEVEL_PLAN) {
X		y = (int) (SCALE + (SCALE * (-Lasty)) / (PLORBITSIZE * Zoom));
X		x = (int) (SCALE + (SCALE * (-Lastx)) / (PLORBITSIZE * Zoom));
X	}
X	if (x >= 0 && y >= 0) {
X		if (r->governor[Governor].toggle.color) {
X			stand = (p->info[Playernum - 1].explored ? Playernum : 0) + '?';
X			sprintf(temp, "%c %d %d 0 %c ", (char) stand, x, y,
X				(stand > '0' ? Psymbol[p->type] : '?'));
X			strcat(string, temp);
X			stand = (p->info[Playernum - 1].numsectsowned ? Playernum : 0) + '?';
X			sprintf(temp, "%c %s", (char) stand, name);
X			strcat(string, temp);
X		} else {
X			stand = p->info[Playernum - 1].explored ? 1 : 0;
X			sprintf(temp, "%d %d %d 0 %c ", stand, x, y,
X				(stand ? Psymbol[p->type] : '?'));
X			strcat(string, temp);
X			stand = p->info[Playernum - 1].numsectsowned ? 1 : 0;
X			sprintf(temp, "%d %s", stand, name);
X			strcat(string, temp);
X		}
X		if (r->governor[Governor].toggle.compat && p->info[Playernum - 1].explored) {
X			sprintf(temp, "(%d)", (int) compatibility(p, r));
X			strcat(string, temp);
X		}
X		strcat(string, ";");
X	}
X}
X
Xvoid 
XDispShip(int Playernum, int Governor, placetype * where, shiptype * ship,
X	 planettype * pl, int God, char *string)
X{
X	int             x, y, wm;
X	int             stand;
X	shiptype       *aship;
X	planettype     *apl;
X	double          xt, yt, slope;
X
X	if (!ship->alive)
X		return;
X
X	*string = '\0';
X
X	switch (where->level) {
X	case LEVEL_PLAN:
X		x = (int) (SCALE + (SCALE * (ship->xpos - (Stars[where->snum]->xpos + pl->xpos)
X					  - Lastx)) / (PLORBITSIZE * Zoom));
X		y = (int) (SCALE + (SCALE * (ship->ypos - (Stars[where->snum]->ypos + pl->ypos)
X					  - Lasty)) / (PLORBITSIZE * Zoom));
X		break;
X	case LEVEL_STAR:
X		x = (int) (SCALE + (SCALE * (ship->xpos - Stars[where->snum]->xpos - Lastx))
X			   / (SYSTEMSIZE * Zoom));
X		y = (int) (SCALE + (SCALE * (ship->ypos - Stars[where->snum]->ypos - Lasty))
X			   / (SYSTEMSIZE * Zoom));
X		break;
X	case LEVEL_UNIV:
X		x = (int) (SCALE + (SCALE * (ship->xpos - Lastx)) / (UNIVSIZE * Zoom));
X		y = (int) (SCALE + (SCALE * (ship->ypos - Lasty)) / (UNIVSIZE * Zoom));
X		break;
X	default:
X		notify(Playernum, Governor, "WHOA! error in DispShip.\n");
X		return;
X	}
X
X	switch (ship->type) {
X	case STYPE_MIRROR:
X		if (ship->special.aimed_at.level == LEVEL_STAR) {
X			xt = Stars[ship->special.aimed_at.snum]->xpos;
X			yt = Stars[ship->special.aimed_at.snum]->ypos;
X		} else if (ship->special.aimed_at.level == LEVEL_PLAN) {
X			if (where->level == LEVEL_PLAN &&
X			    ship->special.aimed_at.pnum == where->pnum) {
X				/* same planet */
X				xt = Stars[ship->special.aimed_at.snum]->xpos + pl->xpos;
X				yt = Stars[ship->special.aimed_at.snum]->ypos + pl->ypos;
X			} else {/* different planet */
X				getplanet(&apl, (int) where->snum, (int) where->pnum);
X				xt = Stars[ship->special.aimed_at.snum]->xpos + apl->xpos;
X				yt = Stars[ship->special.aimed_at.snum]->ypos + apl->ypos;
X				free(apl);
X			}
X		} else if (ship->special.aimed_at.level == LEVEL_SHIP) {
X			if (getship(&aship, (int) ship->special.aimed_at.shipno)) {
X				xt = aship->xpos;
X				yt = aship->ypos;
X				free(aship);
X			} else
X				xt = yt = 0.0;
X		} else
X			xt = yt = 0.0;
X		wm = 0;
X
X		if (xt == ship->xpos) {
X			if (yt > ship->ypos)
X				wm = 4;
X			else
X				wm = 0;
X		} else {
X			slope = (yt - ship->ypos) / (xt - ship->xpos);
X			if (yt == ship->ypos) {
X				if (xt > ship->xpos)
X					wm = 2;
X				else
X					wm = 6;
X			} else if (yt > ship->ypos) {
X				if (slope < -2.414)
X					wm = 4;
X				if (slope > -2.414)
X					wm = 5;
X				if (slope > -0.414)
X					wm = 6;
X				if (slope > 0.000)
X					wm = 2;
X				if (slope > 0.414)
X					wm = 3;
X				if (slope > 2.414)
X					wm = 4;
X			} else if (yt < ship->ypos) {
X				if (slope < -2.414)
X					wm = 0;
X				if (slope > -2.414)
X					wm = 1;
X				if (slope > -0.414)
X					wm = 2;
X				if (slope > 0.000)
X					wm = 6;
X				if (slope > 0.414)
X					wm = 7;
X				if (slope > 2.414)
X					wm = 0;
X			}
X		}
X
X		/* (magnification) */
X		if (x >= 0 && y >= 0) {
X			if (Race->governor[Governor].toggle.color) {
X				sprintf(string, "%c %d %d %d %c %c %d;",
X					(char) (ship->owner + '?'), x, y, wm,
X					Shipltrs[ship->type], (char) (ship->owner + '?'),
X					ship->number);
X			} else {
X				stand = (ship->owner == Race->governor[Governor].toggle.highlight);
X				sprintf(string, "%d %d %d %d %c %d %d;",
X				stand, x, y, wm, Shipltrs[ship->type], stand,
X					ship->number);
X			}
X		}
X		break;
X
X	case OTYPE_CANIST:
X	case OTYPE_GREEN:
X		break;
X
X	default:
X		/* other ships can only be seen when in system */
X		wm = 0;
X		if (ship->whatorbits != LEVEL_UNIV || ((ship->owner == Playernum) || God))
X			if (x >= 0 && y >= 0) {
X				if (Race->governor[Governor].toggle.color) {
X					sprintf(string, "%c %d %d %d %c %c %d;",
X					(char) (ship->owner + '?'), x, y, wm,
X						Shipltrs[ship->type], (char) (ship->owner + '?'),
X						ship->number);
X				} else {
X					stand =
X						(ship->owner == Race->governor[Governor].toggle.highlight);
X					sprintf(string, "%d %d %d %d %c %d %d;",
X						stand, x, y, wm, Shipltrs[ship->type], stand,
X						ship->number);
X				}
X			}
X		break;
X	}
X}
END_OF_FILE
if test 12472 -ne `wc -c <'user/orbit.c'`; then
    echo shar: \"'user/orbit.c'\" unpacked with wrong size!
fi
# end of 'user/orbit.c'
fi
if test -f 'user/prof.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/prof.c'\"
else
echo shar: Extracting \"'user/prof.c'\" \(12249 characters\)
sed "s/^X//" >'user/prof.c' <<'END_OF_FILE'
X#ident  "@(#)prof.c	1.2 12/15/92 "
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h. Tue Apr  9 16:14:58 MDT 1991 (Evan D. Koffler) Reformatted
X * the profile and treasury command.
X * 
X * prof.c -- print out racial profile
X */
X
X#include <strings.h>
X#include <stdio.h>
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "races.h"
X#include "ships.h"
X#include "buffers.h"
X#include "power.h"
X#include "config.h"
X
Xextern char    *Desnames[];
X
Xvoid            whois(int, int, int);
Xvoid            profile(int, int, int);
Xchar           *Estimate_f(double, racetype *, int);
Xchar           *Estimate_i(int, racetype *, int);
Xint             round_perc(int, racetype *, int);
X#include "proto.h"
X
Xvoid 
Xwhois(int Playernum, int Governor, int APcount)
X{
X	int             i, j, numraces;
X	racetype       *Race;
X
X	if (argn <= 1) {
X		sprintf(args[1], "%d", Playernum);	/* The coward's way out */
X		argn = 2;
X	}
X	numraces = Num_races;
X
X	for (i = 1; i <= argn - 1; i++) {
X		j = atoi(args[i]);
X		if (!(j < 1 || j > numraces)) {
X			Race = races[j - 1];
X			if (j == Playernum)
X				sprintf(buf, "[%2d, %d] %s \"%s\"\n",
X					j, Governor, Race->name,
X					Race->governor[Governor].name);
X			else
X				sprintf(buf, "[%2d] %s\n", j, Race->name);
X		} else {
X			sprintf(buf,
X				"Identify: Invalid player number #%d. Try again.\n", j);
X		}
X		notify(Playernum, Governor, buf);
X	}
X}
X
Xvoid 
Xtreasury(int Playernum, int Governor)
X{
X	racetype       *Race;
X
X	Race = races[Playernum - 1];
X
X	sprintf(buf,
X		"Income last update was: %d\t\tCost last update was: %d\n",
X		Race->governor[Governor].income + Race->governor[Governor].profit_market,
X		Race->governor[Governor].maintain + Race->governor[Governor].cost_tech +
X		Race->governor[Governor].cost_market);
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "    Market: %5d                               Market: %5d\n",
X		Race->governor[Governor].profit_market,
X		Race->governor[Governor].cost_market);
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "    Taxes:  %5d                               Tech: %5d\n",
X	Race->governor[Governor].income, Race->governor[Governor].cost_tech);
X	notify(Playernum, Governor, buf);
X
X	sprintf(buf, "                                                Maint: %5d\n", Race->governor[Governor].maintain);
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "You have: %d\n", Race->governor[Governor].money);
X	notify(Playernum, Governor, buf);
X#ifdef MULTIPLE_COMM_CHANNELS
X	channel(Playernum, Governor, 0, 1);
X#endif
X}
X
Xvoid 
Xprofile(int Playernum, int Governor, int APcount)
X{
X	int             p;
X	racetype       *r, *Race;
X
X	Race = races[Playernum - 1];
X
X	if (argn == 1) {
X		sprintf(buf, "--==** Racial profile for %s (player %d) **==--\n",
X			Race->name, Race->Playernum);
X		notify(Playernum, Governor, buf);
X		if (Race->God) {
X			sprintf(buf, "*** Diety Status ***\n");
X			notify(Playernum, Governor, buf);
X		}
X		sprintf(buf, "Personal: %s\n", Race->info);
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Default Scope: /%s/%s\n",
X			Stars[Race->governor[Governor].homesystem]->name,
X			Stars[Race->governor[Governor].homesystem]->pnames[Race->governor[Governor].homeplanetnum]);
X		notify(Playernum, Governor, buf);
X		if (Race->Gov_ship == 0)
X			sprintf(buf, "NO DESIGNATED CAPITAL!!");
X		else
X			sprintf(buf, "Designated Capital: #%-8d", Race->Gov_ship);
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "\t\tRanges:   guns:   %5.0f\n",
X			gun_range(Race, (shiptype *) NULL, 1));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Morale: %5d\t\t\t\t\t    space:  %5.0f\n",
X			Race->morale, tele_range(OTYPE_STELE, Race->tech));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Updates active: %d\t\t\t\t      ground: %5.0f\n\n",
X			Race->turn, tele_range(OTYPE_GTELE, Race->tech));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "%s      Planet Conditions\t      Sector Preferences\n",
X			Race->Metamorph ? "Metamorphic Race\t" :
X			"Normal Race\t\t");
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Fert:    %3d%%           Temp:       %d\n",
X			Race->fertilize, Temp(Race->conditions[TEMP]));
X		notify(Playernum, Governor, buf);
X		sprintf(buf,
X			"Rate:    %3.1f            methane  %5d%%           %-8.8s %c %3.0f%%\n",
X			Race->birthrate,
X			Race->conditions[METHANE],
X			Desnames[SEA], CHAR_SEA,
X			Race->likes[SEA] * 100.);
X		notify(Playernum, Governor, buf);
X		sprintf(buf,
X			"Mass:   %4.2f            oxygen   %5d%%           %-8.8s %c %3.0f%%\n",
X			Race->mass,
X			Race->conditions[OXYGEN],
X			Desnames[GAS], CHAR_GAS,
X			Race->likes[GAS] * 100.);
X		notify(Playernum, Governor, buf);
X		sprintf(buf,
X			"Fight:     %d            helium   %5d%%           %-8.8s %c %3.0f%%\n",
X			Race->fighters,
X			Race->conditions[HELIUM],
X			Desnames[ICE], CHAR_ICE,
X			Race->likes[ICE] * 100.);
X		notify(Playernum, Governor, buf);
X		sprintf(buf,
X			"Metab:  %4.2f            nitrogen %5d%%           %-8.8s %c %3.0f%%\n",
X			Race->metabolism,
X			Race->conditions[NITROGEN],
X			Desnames[MOUNT], CHAR_MOUNT,
X			Race->likes[MOUNT] * 100.);
X		notify(Playernum, Governor, buf);
X		sprintf(buf,
X			"Sexes:     %1d            CO2      %5d%%           %-8.8s %c %3.0f%%\n",
X			Race->number_sexes,
X			Race->conditions[CO2],
X			Desnames[LAND], CHAR_LAND,
X			Race->likes[LAND] * 100.);
X		notify(Playernum, Governor, buf);
X		sprintf(buf,
X			"Explore:  %-3.0f%%          hydrogen %5d%%           %-8.8s %c %3.0f%%\n",
X			Race->adventurism * 100.0,
X			Race->conditions[HYDROGEN],
X			Desnames[DESERT], CHAR_DESERT,
X			Race->likes[DESERT] * 100.);
X		notify(Playernum, Governor, buf);
X		sprintf(buf,
X			"Avg Int: %3d            sulfer   %5d%%           %-8.8s %c %3.0f%%\n",
X			Race->IQ,
X			Race->conditions[SULFUR],
X			Desnames[FOREST], CHAR_FOREST,
X			Race->likes[FOREST] * 100.);
X		notify(Playernum, Governor, buf);
X		sprintf(buf,
X			"Tech:   %-6.2f          other    %5d%%           %-8.8s %c %3.0f%%\n",
X			Race->tech,
X			Race->conditions[OTHER],
X			Desnames[PLATED], CHAR_PLATED,
X			Race->likes[PLATED] * 100.);
X		notify(Playernum, Governor, buf);
X
X		notify(Playernum, Governor, "Discoveries:");
X		if (Crystal(Race))
X			notify(Playernum, Governor, "  Crystals");
X		if (Hyper_drive(Race))
X			notify(Playernum, Governor, "  Hyper-drive");
X		if (Laser(Race))
X			notify(Playernum, Governor, "  Combat Lasers");
X		if (Cew(Race))
X			notify(Playernum, Governor, "  Confined Energy Weapons");
X		if (Tractor_beam(Race))
X			notify(Playernum, Governor, "  Tractor Beam");
X		if (Transporter(Race))
X			notify(Playernum, Governor, "  Transporter");
X		if (Avpm(Race))
X			notify(Playernum, Governor, "  AVPM");
X		if (Cloak(Race))
X			notify(Playernum, Governor, "  Cloaking");
X		if (Wormhole(Race))
X			notify(Playernum, Governor, "  Wormhole");
X		notify(Playernum, Governor, "\n");
X	} else {
X		if (!(p = GetPlayer(args[1]))) {
X			sprintf(buf, "Player does not exist.\n");
X			notify(Playernum, Governor, buf);
X			return;
X		}
X		r = races[p - 1];
X		sprintf(buf, "------ Race report on %s (%d) ------\n", r->name, p);
X		notify(Playernum, Governor, buf);
X		if (Race->God) {
X			if (r->God) {
X				sprintf(buf, "*** Deity Status ***\n");
X				notify(Playernum, Governor, buf);
X			}
X		}
X		sprintf(buf, "Personal: %s\n", r->info);
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "%%Know:  %3d%%\n", Race->translate[p - 1]);
X		notify(Playernum, Governor, buf);
X		if (Race->translate[p - 1] > 50) {
X			sprintf(buf, "%s\t  Planet Conditions\n",
X			r->Metamorph ? "Metamorphic Race" : "Normal Race\t");
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "Fert:    %s",
X				Estimate_i((int) (r->fertilize), Race, p));
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "\t\t  Temp:\t%s\n",
X			  Estimate_i((int) (r->conditions[TEMP]), Race, p));
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "Rate:    %s%%",
X				Estimate_f(r->birthrate * 100.0, Race, p));
X			notify(Playernum, Governor, buf);
X		} else {
X			sprintf(buf, "Unknown Race\t\t  Planet Conditions\n");
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "Fert:    %s",
X				Estimate_i((int) (r->fertilize), Race, p));
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "\t\t  Temp:\t%s\n",
X			  Estimate_i((int) (r->conditions[TEMP]), Race, p));
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "Rate:    %s",
X				Estimate_f(r->birthrate, Race, p));
X			notify(Playernum, Governor, buf);
X		}
X		sprintf(buf, "\t\t  methane  %4s%%\t\tRanges:\n",
X			Estimate_i((int) (r->conditions[METHANE]), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Mass:    %s", Estimate_f(r->mass, Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "\t\t  oxygen   %4s%%",
X			Estimate_i((int) (r->conditions[OXYGEN]), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "\t\t  guns:   %6s\n",
X		   Estimate_f(gun_range(r, (shiptype *) NULL, 1), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Fight:   %s",
X			Estimate_i((int) (r->fighters), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "\t\t  helium   %4s%%",
X			Estimate_i((int) (r->conditions[HELIUM]), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "\t\t  space:  %6s\n",
X		     Estimate_f(tele_range(OTYPE_STELE, r->tech), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Metab:   %s", Estimate_f(r->metabolism, Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "\t\t  nitrogen %4s%%",
X		      Estimate_i((int) (r->conditions[NITROGEN]), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "\t\t  ground: %6s\n",
X		     Estimate_f(tele_range(OTYPE_GTELE, r->tech), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Sexes:   %s",
X			Estimate_i((int) (r->number_sexes), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "\t\t  CO2      %4s%%\n",
X			Estimate_i((int) (r->conditions[CO2]), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Explore: %s%%",
X			Estimate_f(r->adventurism * 100.0, Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "\t\t  hydrogen %4s%%\n",
X		      Estimate_i((int) (r->conditions[HYDROGEN]), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Avg Int: %s",
X			Estimate_i((int) (r->IQ), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "\t\t  sulfer   %4s%%\n",
X			Estimate_i((int) (r->conditions[SULFUR]), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Tech:    %s", Estimate_f(r->tech, Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "\t\t  other    %4s%%",
X			Estimate_i((int) (r->conditions[OTHER]), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "\t\tMorale:   %6s\n",
X			Estimate_i((int) (r->morale), Race, p));
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Sector type preference : %s\n",
X			Race->translate[p - 1] > 80 ? Desnames[r->likesbest] : " ? ");
X		notify(Playernum, Governor, buf);
X	}
X}
X
Xstatic char     est_buf[20];
X
Xchar           *
XEstimate_f(double data, racetype * r, int p)
X{
X	int             est;
X
X	sprintf(est_buf, "?");
X
X	if (r->translate[p - 1] > 10) {
X		est = round_perc((int) data, r, p);
X		if (est < 1000)
X			sprintf(est_buf, "%d", est);
X		else if (est < 10000)
X			sprintf(est_buf, "%.1fK", (double) est / 1000.);
X		else if (est < 1000000)
X			sprintf(est_buf, "%.0fK", (double) est / 1000.);
X		else
X			sprintf(est_buf, "%.1fM", (double) est / 1000000.);
X	}
X	return est_buf;
X}
X
Xchar           *
XEstimate_i(int data, racetype * r, int p)
X{
X	int             est;
X
X	sprintf(est_buf, "?");
X
X	if (r->translate[p - 1] > 10) {
X		est = round_perc((int) data, r, p);
X		if ((int) abs(est) < 1000)
X			sprintf(est_buf, "%d", est);
X		else if ((int) abs(est) < 10000)
X			sprintf(est_buf, "%.1fK", (double) est / 1000.);
X		else if ((int) abs(est) < 1000000)
X			sprintf(est_buf, "%.0fK", (double) est / 1000.);
X		else
X			sprintf(est_buf, "%.1fM", (double) est / 1000000.);
X	}
X	return est_buf;
X}
X
Xint 
Xround_perc(int data, racetype * r, int p)
X{
X	int             k;
X
X#if 0				/* r->captured_prisoners[p-1] is never
X				 * actually used eslewhere. */
X	k = 101 - MIN(r->translate[p - 1] + r->captured_prisoners[p - 1], 100);
X#else
X	k = 101 - MIN(r->translate[p - 1], 100);
X#endif
X	return ((data / k) * k);
X}
END_OF_FILE
if test 12249 -ne `wc -c <'user/prof.c'`; then
    echo shar: \"'user/prof.c'\" unpacked with wrong size!
fi
# end of 'user/prof.c'
fi
if test -f 'utils/Makelist.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/Makelist.c'\"
else
echo shar: Extracting \"'utils/Makelist.c'\" \(2464 characters\)
sed "s/^X//" >'utils/Makelist.c' <<'END_OF_FILE'
X/* Galactic Bloodshed Planet List Consolidator
X *
X * makelist oldlist addlist > newlist
X * 	Errors are to stderr.
X *	Normal output to stdout.
X *	This program takes a list of planets and alphabetizes them.
X *	and then takes the addlist and tries to add unique planet
X *	names up to NUM_CHARS, if it can. Otherwise it informs
X *	which name is being omitted and what name caused the clash.
X *
X *	Tue Apr 16 00:02:36 MDT 1991
X *	Evan Koffler (ekoffler@du.edu)
X */
X
X# include <stdio.h>
X
X# define NUM_CHARS	4
X
Xextern char *malloc ();
Xextern char *index ();
X
Xtypedef struct list {
X	char name[257];
X	struct list *next;
X	struct list *prev;
X} LIST;
X
XLIST *list_head;
X
Xmain (argc, argv)
Xint argc;
Xchar **argv;
X{
XFILE *input;
XFILE *add;
Xchar *c;
Xchar buf[BUFSIZ];
Xint names;
X
X	if (argc !=3) {
X		printf ("Usage: %s oldlist newlist > outputlist\n",
X			argv[0]);
X		exit (1);
X	}
X	
X	if ((input = fopen(argv[1], "r")) == NULL) {
X		printf ("Can not open %s for reading.\n", argv[1]);
X		exit (1);
X	}
X	if ((add = fopen(argv[2], "r")) == NULL) {
X		printf ("Can not open %s for reading.\n", argv[2]);
X		exit (1);
X	}
X
X	if (fgets (buf, BUFSIZ, input)) {
X		list_head = (LIST *) malloc (sizeof (LIST));
X		list_head->prev = NULL;
X		list_head->next = NULL;
X		if ((c = index (buf, '\n')) != NULL)
X			*c = '\0';	
X		strcpy (list_head->name, buf);
X	}
X	while (fgets (buf, BUFSIZ, input))
X		add_to_list (buf);	
X	while (fgets (buf, BUFSIZ, add))
X		add_to_list (buf);	
X	names = print_list ();
X	fprintf (stderr, "Done with makelist. %d names total\n", names);
X}
X
Xadd_to_list (s)
Xchar *s;
X{
XLIST *q;
XLIST *p;
Xint val;
Xchar *c;
X
X	if (c = index (s, '\n'))
X		*c = '\0';	
X	if (*s == '\0') return;
X	for (p = list_head; p; p = p->next) {
X		val = strncmp (p->name, s, NUM_CHARS);
X		if (val > 0) {
X			q = (LIST *) malloc (sizeof (LIST));
X			strcpy (q->name, s);
X			if (p == list_head) {
X				list_head = q;
X				q->prev = NULL;
X				p->prev = q;
X				q->next = p;
X			} else {
X				q->prev = p->prev;
X				p->prev->next = q;	
X				q->next = p;
X				p->prev = q;
X			}
X			return;
X		} else if (val == 0) {
X			fprintf (stderr,
X				"Duplicate name. In list %s. Omitting %s\n", 
X				p->name, s);
X			return;
X		}
X	}
X	if (!p) {
X		for (p = list_head; p->next; p = p->next)
X			;
X		p->next = (LIST *) malloc (sizeof (LIST));
X		strcpy (p->name, s);
X		p->next->prev = p;
X		p->next->next = NULL;
X	}
X}
X
Xint print_list ()
X{
XLIST *p;
Xint i = 0;
X
X	for (p = list_head; p; p = p->next) {
X		printf ("%s\n", p->name);
X		i++;
X	}
X	return (i);
X}
END_OF_FILE
if test 2464 -ne `wc -c <'utils/Makelist.c'`; then
    echo shar: \"'utils/Makelist.c'\" unpacked with wrong size!
fi
# end of 'utils/Makelist.c'
fi
echo shar: End of archive 14 \(of 21\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
