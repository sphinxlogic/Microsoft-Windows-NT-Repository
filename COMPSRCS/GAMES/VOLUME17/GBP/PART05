Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i017:  gbp - Galactic Bloodshed+, an empire-like war game, Part05/21
Message-ID: <4545@master.CNA.TEK.COM>
Date: 12 Feb 93 17:30:25 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1786
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1696

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 17
Archive-name: gbp/Part05
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 21)."
# Contents:  doc/VERSION server/moveship.c user/load.c
# Wrapped by billr@saab on Fri Feb 12 09:14:24 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/VERSION' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/VERSION'\"
else
echo shar: Extracting \"'doc/VERSION'\" \(53 characters\)
sed "s/^X//" >'doc/VERSION' <<'END_OF_FILE'
XThis release can be refered to as GBDT GB+ Ver 1.1.4
END_OF_FILE
if test 53 -ne `wc -c <'doc/VERSION'`; then
    echo shar: \"'doc/VERSION'\" unpacked with wrong size!
fi
# end of 'doc/VERSION'
fi
if test -f 'server/moveship.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/moveship.c'\"
else
echo shar: Extracting \"'server/moveship.c'\" \(16801 characters\)
sed "s/^X//" >'server/moveship.c' <<'END_OF_FILE'
X#ident  "@(#)moveship.c	1.5 1/31/93 "
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * moveship -- moves specified ship according to its orders. also deducts fuel
X * from the ship's stores.
X */
X#include <math.h>
X
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "power.h"
X#include "ships.h"
X#include "races.h"
X#include "doturn.h"
X#include "buffers.h"
X
X/*
X * amount to move for each dir level. I arrived on these #'s only after hours
X * of dilligent tweaking
X */
X/* amount to move for each directory level  */
Xdouble          MoveConsts[] = {600.0, 300.0, 50.0};
X/* amnt to move for each ship speed level (ordered) */
Xdouble          SpeedConsts[] = {0.0, 0.61, 1.26, 1.50, 1.73, 1.81, 1.90, 1.93, 1.96, 1.97};
X/* amount of fuel it costs to move at speed level */
X
Xvoid            Moveship(shiptype *, int, int, int);
Xvoid            msg_OOF(shiptype *);
Xint             followable(shiptype *, shiptype *);
Xint             do_merchant(shiptype *, planettype *);
X#include "proto.h"
X
Xvoid 
XMoveship(shiptype * s, int mode, int send_messages, int checking_fuel)
X{
X	double          stardist, movedist, truedist, dist, xdest, ydest,
X	                sn, cs;
X	double          mfactor, heading, distfac;
X	double          fuse;
X	int             destlevel, deststar = 0, destpnum = 0;
X	shiptype       *dsh;
X	startype       *ost, *dst;
X	planettype     *opl, *dpl;
X
X	if (s->hyper_drive.has && s->hyper_drive.on) {	/* do a hyperspace jump */
X		if (!mode)
X			return;	/* we're not ready to jump until the update */
X		if (s->hyper_drive.ready) {
X			dist = sqrt(Distsq(s->xpos, s->ypos,
X			Stars[s->deststar]->xpos, Stars[s->deststar]->ypos));
X			distfac = HYPER_DIST_FACTOR * (s->tech + 100.0);
X			if (s->mounted && dist > distfac)
X				fuse = HYPER_DRIVE_FUEL_USE * sqrt(s->mass) * (dist / distfac);
X			else
X				fuse = HYPER_DRIVE_FUEL_USE * sqrt(s->mass)
X					* (dist / distfac) * (dist / distfac);
X
X			if (s->fuel < fuse) {
X				sprintf(telegram_buf,
X					"%s at system %s does not have %.1ff to do hyperspace jump.",
X					Ship(s), prin_ship_orbits(s), fuse);
X				if (send_messages)
X					push_telegram((int) (s->owner),
X					   (int) s->governor, telegram_buf);
X				s->hyper_drive.on = 0;
X				return;
X			}
X			use_fuel(s, fuse);
X			heading = atan2(Stars[s->deststar]->xpos - s->xpos,
X					Stars[s->deststar]->ypos - s->ypos);
X			sn = sin(heading);
X			cs = cos(heading);
X			s->xpos = Stars[s->deststar]->xpos - sn * 0.9 * SYSTEMSIZE;
X			s->ypos = Stars[s->deststar]->ypos - cs * 0.9 * SYSTEMSIZE;
X			s->whatorbits = LEVEL_STAR;
X			s->storbits = s->deststar;
X			s->protect.planet = 0;
X			s->hyper_drive.on = 0;
X			s->hyper_drive.ready = 0;
X			s->hyper_drive.charge = 0;
X			sprintf(telegram_buf, "%s arrived at %s.", Ship(s), prin_ship_orbits(s));
X			if (send_messages)
X				push_telegram((int) (s->owner),
X					   (int) s->governor, telegram_buf);
X		} else if (s->mounted) {
X			s->hyper_drive.ready = 1;
X			s->hyper_drive.charge = HYPER_DRIVE_READY_CHARGE;
X		} else {
X			if (s->hyper_drive.charge == HYPER_DRIVE_READY_CHARGE)
X				s->hyper_drive.ready = 1;
X			else
X				s->hyper_drive.charge += 1;
X		}
X		return;
X	} else if (s->speed && !s->docked && s->alive
X		   && (s->whatdest != LEVEL_UNIV || s->navigate.on)) {
X		fuse = 0.5 * s->speed * (1 + s->protect.evade)
X			* s->mass * FUEL_USE / (double) segments;
X		if (s->fuel < fuse) {
X			if (send_messages)
X				msg_OOF(s);	/* send OOF notify */
X			if (s->whatorbits == LEVEL_UNIV && (s->build_cost <= 50)) {
X				sprintf(telegram_buf, "%s has been lost in deep space.",
X					Ship(s));
X				if (send_messages)
X					push_telegram((int) (s->owner),
X					   (int) s->governor, telegram_buf);
X				if (send_messages)
X					kill_ship((int) (s->owner), s);
X			}
X			return;
X		}
X		if (s->navigate.on) {	/* follow navigational orders */
X			heading = .0174329252 * s->navigate.bearing;
X			mfactor = SHIP_MOVE_SCALE * (1.0 - .01 * s->rad)
X				* (1.0 - .01 * s->damage)
X				* SpeedConsts[s->speed] * MoveConsts[s->whatorbits]
X				/ (double) segments;
X			use_fuel(s, (double) fuse);
X			sn = sin(heading);
X			cs = cos(heading);
X			xdest = sn * mfactor;
X			ydest = -cs * mfactor;
X			s->xpos += xdest;
X			s->ypos += ydest;
X			s->navigate.turns--;
X			if (!s->navigate.turns)
X				s->navigate.on = 0;
X			/* check here for orbit breaking as well. Maarten */
X			ost = Stars[s->storbits];
X			opl = planets[s->storbits][s->pnumorbits];
X			if (s->whatorbits == LEVEL_PLAN) {
X				dist = sqrt(Distsq(s->xpos, s->ypos,
X						   ost->xpos + opl->xpos, ost->ypos + opl->ypos));
X				if (dist > PLORBITSIZE) {
X					s->whatorbits = LEVEL_STAR;
X					s->protect.planet = 0;
X				}
X			} else if (s->whatorbits == LEVEL_STAR) {
X				dist = sqrt(Distsq(s->xpos, s->ypos, ost->xpos, ost->ypos));
X				if (dist > SYSTEMSIZE) {
X					s->whatorbits = LEVEL_UNIV;
X					s->protect.evade = 0;
X					s->protect.planet = 0;
X				}
X			}
X		} else {	/* navigate is off            */
X			destlevel = s->whatdest;
X			if (destlevel == LEVEL_SHIP) {
X				dsh = ships[s->destshipno];
X				s->deststar = dsh->storbits;
X				s->destpnum = dsh->pnumorbits;
X				xdest = dsh->xpos;
X				ydest = dsh->ypos;
X				switch (dsh->whatorbits) {
X				case LEVEL_UNIV:
X					break;
X				case LEVEL_PLAN:
X					if (s->whatorbits != dsh->whatorbits ||
X					    s->pnumorbits != dsh->pnumorbits)
X						destlevel = LEVEL_PLAN;
X					break;
X				case LEVEL_STAR:
X					if (s->whatorbits != dsh->whatorbits ||
X					    s->storbits != dsh->storbits)
X						destlevel = LEVEL_STAR;
X					break;
X				}
X				/*
X				 * if (sqrt( (double)Distsq(s->xpos, s->ypos,
X				 * xdest, ydest)) <= DIST_TO_LAND ||
X				 * !(dsh->alive)) { destlevel = LEVEL_UNIV;
X				 * s->whatdest=LEVEL_UNIV; }
X				 */
X			}
X			/* else */
X			if (destlevel == LEVEL_STAR ||
X			    (destlevel == LEVEL_PLAN &&
X			     (s->storbits != s->deststar || s->whatorbits == LEVEL_UNIV))) {
X				destlevel = LEVEL_STAR;
X				deststar = s->deststar;
X				xdest = Stars[deststar]->xpos;
X				ydest = Stars[deststar]->ypos;
X			} else if (destlevel == LEVEL_PLAN && s->storbits == s->deststar) {
X				destlevel = LEVEL_PLAN;
X				deststar = s->deststar;
X				destpnum = s->destpnum;
X				xdest = Stars[deststar]->xpos + planets[deststar][destpnum]->xpos;
X				ydest = Stars[deststar]->ypos + planets[deststar][destpnum]->ypos;
X				if (sqrt(Distsq(s->xpos, s->ypos, xdest, ydest)) <= DIST_TO_LAND)
X					destlevel = LEVEL_UNIV;
X			}
X			dst = Stars[deststar];
X			ost = Stars[s->storbits];
X			dpl = planets[deststar][destpnum];
X			opl = planets[s->storbits][s->pnumorbits];
X			truedist = movedist = sqrt(Distsq(s->xpos, s->ypos, xdest, ydest));
X			/*
X			 * Save some unneccesary calculation and domain
X			 * errors for atan2 Maarten
X			 */
X			if (truedist < DIST_TO_LAND && s->whatorbits == destlevel &&
X			s->storbits == deststar && s->pnumorbits == destpnum)
X				return;
X			heading = atan2((double) (xdest - s->xpos), (double) (-ydest + s->ypos));
X			mfactor = SHIP_MOVE_SCALE * (1. - .01 * (double) s->rad)
X				* (1. - .01 * (double) s->damage)
X				* SpeedConsts[s->speed] * MoveConsts[s->whatorbits]
X				/ (double) segments;
X
X			/* keep from ending up in the middle of the system. */
X			if (destlevel == LEVEL_STAR &&
X			    (s->storbits != deststar || s->whatorbits == LEVEL_UNIV))
X				movedist -= SYSTEMSIZE * 0.90;
X			else if (destlevel == LEVEL_PLAN && s->whatorbits == LEVEL_STAR &&
X			 s->storbits == deststar && truedist >= PLORBITSIZE)
X				movedist -= PLORBITSIZE * 0.90;
X
X			if (s->whatdest == LEVEL_SHIP &&
X			    !followable(s, ships[s->destshipno])) {
X				s->whatdest = LEVEL_UNIV;
X				s->protect.evade = 0;
X				sprintf(telegram_buf,
X					"%s at %s lost sight of destination ship #%d.",
X				Ship(s), prin_ship_orbits(s), s->destshipno);
X				if (send_messages)
X					push_telegram((int) (s->owner),
X					   (int) s->governor, telegram_buf);
X				return;
X			}
X			if (truedist > DIST_TO_LAND) {
X				use_fuel(s, (double) fuse);
X				/* dont overshoot */
X				sn = sin(heading);
X				cs = cos(heading);
X				xdest = sn * mfactor;
X				ydest = -cs * mfactor;
X				if (hypot(xdest, ydest) > movedist) {
X					xdest = sn * movedist;
X					ydest = -cs * movedist;
X				}
X				s->xpos += xdest;
X				s->ypos += ydest;
X			}
X			/***** check if far enough away from object it's orbiting to break orbit *****/
X			if (s->whatorbits == LEVEL_PLAN) {
X				dist = sqrt(Distsq(s->xpos, s->ypos,
X						   ost->xpos + opl->xpos, ost->ypos + opl->ypos));
X				if (dist > PLORBITSIZE) {
X					s->whatorbits = LEVEL_STAR;
X					s->protect.planet = 0;
X				}
X			} else if (s->whatorbits == LEVEL_STAR) {
X				dist = sqrt(Distsq(s->xpos, s->ypos, ost->xpos, ost->ypos));
X				if (dist > SYSTEMSIZE) {
X					s->whatorbits = LEVEL_UNIV;
X					s->protect.evade = 0;
X					s->protect.planet = 0;
X				}
X			}
X			/*******   check for arriving at destination *******/
X			if (destlevel == LEVEL_STAR ||
X			    (destlevel == LEVEL_PLAN &&
X			     (s->storbits != deststar || s->whatorbits == LEVEL_UNIV))) {
X				stardist = sqrt(Distsq(s->xpos, s->ypos, dst->xpos, dst->ypos));
X				if (stardist <= SYSTEMSIZE * 1.5) {
X					s->whatorbits = LEVEL_STAR;
X					s->protect.planet = 0;
X					s->storbits = deststar;
X					/*
X					 * if this system isn't inhabited by
X					 * you, give it to the governor of
X					 * the ship
X					 */
X					if (!checking_fuel && (s->popn || s->type == OTYPE_PROBE)) {
X						if (!isset(dst->inhabited, (int) s->owner))
X							dst->governor[s->owner - 1] = s->governor;
X						setbit(dst->explored, (int) s->owner);
X						setbit(dst->inhabited, (int) s->owner);
X					}
X					sprintf(telegram_buf, "%s arrived at %s.", Ship(s),
X						prin_ship_orbits(s));
X					if (send_messages)
X						push_telegram((int) (s->owner),
X							      (int) s->governor, telegram_buf);
X					if (s->whatdest == LEVEL_STAR)
X						s->whatdest = LEVEL_UNIV;
X				}
X			} else if (destlevel == LEVEL_PLAN && deststar == s->storbits) {
X				/*
X				 * headed for a planet in the same system, &
X				 * not already there..
X				 */
X				dist = sqrt(Distsq(s->xpos, s->ypos,
X						   dst->xpos + dpl->xpos, dst->ypos + dpl->ypos));
X				if (dist <= PLORBITSIZE) {
X					if (!checking_fuel && (s->popn || s->type == OTYPE_PROBE)) {
X						dpl->info[s->owner - 1].explored = 1;
X						setbit(dst->explored, (int) (s->owner));
X						setbit(dst->inhabited, (int) (s->owner));
X					}
X					s->whatorbits = LEVEL_PLAN;
X					s->pnumorbits = destpnum;
X					if (dist <= (double) DIST_TO_LAND) {
X						sprintf(telegram_buf, "%s within landing distance of %s.",
X							Ship(s), prin_ship_orbits(s));
X						if (checking_fuel || !do_merchant(s, dpl))
X							if (s->whatdest == LEVEL_PLAN)
X								s->whatdest = LEVEL_UNIV;
X					} else {
X						sprintf(telegram_buf, "%s arriving at %s.",
X							Ship(s), prin_ship_orbits(s));
X					}
X					if (s->type == STYPE_OAP) {
X						sprintf(buf, "\nEnslavement of the planet is now possible.");
X						strcat(telegram_buf, buf);
X					}
X					if (send_messages)
X						push_telegram((int) (s->owner), (int) s->governor, telegram_buf);
X				}
X			} else if (destlevel == LEVEL_SHIP) {
X				dist = sqrt(Distsq(s->xpos, s->ypos, dsh->xpos, dsh->ypos));
X				if (dist <= PLORBITSIZE) {
X					if (dsh->whatorbits == LEVEL_PLAN) {
X						s->whatorbits = LEVEL_PLAN;
X						s->storbits = dsh->storbits;
X						s->pnumorbits = dsh->pnumorbits;
X					} else if (dsh->whatorbits == LEVEL_STAR) {
X						s->whatorbits = LEVEL_STAR;
X						s->storbits = dsh->storbits;
X						s->protect.planet = 0;
X					}
X				}
X			}
X		}		/* 'destination' orders */
X	}			/* if impulse drive */
X}
X
X
X/*
X * deliver an "out of fuel" message.  Used by a number of ship-updating code
X * segments; so that code isn't duplicated.
X */
Xvoid 
Xmsg_OOF(shiptype * s)
X{
X	sprintf(buf, "%s is out of fuel at %s.", Ship(s), prin_ship_orbits(s));
X	push_telegram((int) (s->owner), (int) s->governor, buf);
X}
X
X
X/* followable: returns 1 iff s1 can follow s2 */
Xint 
Xfollowable(shiptype * s1, shiptype * s2)
X{
X	double          dx, dy;
X	racetype       *r;
X	double          range;
X	int             allied[2];
X
X	if (!s2->alive || !s1->active || s2->whatorbits == LEVEL_SHIP)
X		return 0;
X
X	dx = s1->xpos - s2->xpos;
X	dy = s1->ypos - s2->ypos;
X
X	range = 4.0 * logscale((int) (s1->tech + 1.0)) * SYSTEMSIZE;
X
X	r = races[s2->owner - 1];
X	allied[0] = r->allied[0];
X	allied[1] = r->allied[1];
X	/* You can follow your own ships, your allies' ships, or nearby ships */
X	return (s1->owner == s2->owner) ||
X		(isset(allied, (int) s1->owner)) ||
X		(sqrt(dx * dx + dy * dy) <= range);
X}
X
X
X/*
X * this routine will do landing, launching, loading, unloading, etc for
X * merchant ships. The ship is within landing distance of the target planet
X */
Xint 
Xdo_merchant(shiptype * s, planettype * p)
X{
X	reg int         i, j;
X	double          fuel;
X	char            load, unload;
X	int             amount;
X	sectortype     *sect;
X
X	i = s->owner - 1;
X	j = s->merchant - 1;	/* try to speed things up a bit */
X
X	if (!s->merchant || !p->info[i].route[j].set)	/* not on shipping route */
X		return 0;
X	/* check to see if the sector is owned by the player */
X	getsector(&sect, p, p->info[i].route[j].x, p->info[i].route[j].y);
X	if (sect->owner && (sect->owner != s->owner)) {
X		free(sect);
X		return 0;
X	}
X	free(sect);
X
X	if (!landed(s)) {	/* try to land the ship */
X		fuel = s->mass * gravity(p) * LAND_GRAV_MASS_FACTOR;
X		if (s->fuel < fuel) {	/* ship can't land - cancel all
X					 * orders */
X			s->whatdest = LEVEL_UNIV;
X			strcat(telegram_buf, "\t\tNot enough fuel to land!\n");
X			return 1;
X		}
X		s->land_x = p->info[i].route[j].x;
X		s->land_y = p->info[i].route[j].y;
X		sprintf(buf, "\t\tLanded on sector %d,%d\n",
X			s->land_x, s->land_y);
X		strcat(telegram_buf, buf);
X		s->xpos = p->xpos + Stars[s->storbits]->xpos;
X		s->ypos = p->ypos + Stars[s->storbits]->ypos;
X		use_fuel(s, fuel);
X		s->docked = 1;
X		s->whatdest = LEVEL_PLAN;
X		s->deststar = s->storbits;
X		s->destpnum = s->pnumorbits;
X	}
X	/* load and unload supplies specified by the planet */
X	load = p->info[i].route[j].load;
X	unload = p->info[i].route[j].unload;
X	if (load) {
X		strcat(telegram_buf, "\t\t");
X		if (Fuel(load)) {
X			amount = (int) s->max_fuel - (int) s->fuel;
X			if (amount > p->info[i].fuel)
X				amount = p->info[i].fuel;
X			p->info[i].fuel -= amount;
X			rcv_fuel(s, (double) amount);
X			sprintf(buf, "%df ", amount);
X			strcat(telegram_buf, buf);
X		}
X		if (Resources(load)) {
X			amount = (int) s->max_resource - (int) s->resource;
X			if (amount > p->info[i].resource)
X				amount = p->info[i].resource;
X			p->info[i].resource -= amount;
X			rcv_resource(s, amount);
X			sprintf(buf, "%dr ", amount);
X			strcat(telegram_buf, buf);
X		}
X		if (Crystals(load)) {
X			amount = p->info[i].crystals;
X			p->info[i].crystals -= amount;
X			s->crystals += amount;
X			sprintf(buf, "%dx ", amount);
X			strcat(telegram_buf, buf);
X		}
X		if (Destruct(load)) {
X			amount = (int) s->max_destruct - (int) s->destruct;
X			if (amount > p->info[i].destruct)
X				amount = p->info[i].destruct;
X			p->info[i].destruct -= amount;
X			rcv_destruct(s, amount);
X			sprintf(buf, "%dd ", amount);
X			strcat(telegram_buf, buf);
X		}
X		strcat(telegram_buf, "loaded\n");
X	}
X	if (unload) {
X		strcat(telegram_buf, "\t\t");
X		if (Fuel(unload)) {
X			amount = (int) s->fuel;
X			p->info[i].fuel += amount;
X			sprintf(buf, "%df ", amount);
X			strcat(telegram_buf, buf);
X			use_fuel(s, (double) amount);
X		}
X		if (Resources(unload)) {
X			amount = s->resource;
X			p->info[i].resource += amount;
X			sprintf(buf, "%dr ", amount);
X			strcat(telegram_buf, buf);
X			use_resource(s, amount);
X		}
X		if (Crystals(unload)) {
X			amount = s->crystals;
X			p->info[i].crystals += amount;
X			sprintf(buf, "%dx ", amount);
X			strcat(telegram_buf, buf);
X			s->crystals -= amount;
X		}
X		if (Destruct(unload)) {
X			amount = s->destruct;
X			p->info[i].destruct += amount;
X			sprintf(buf, "%dd ", amount);
X			strcat(telegram_buf, buf);
X			use_destruct(s, amount);
X		}
X		strcat(telegram_buf, "unloaded\n");
X	}
X	/* launch the ship */
X	fuel = s->mass * gravity(p) * LAUNCH_GRAV_MASS_FACTOR;
X	if (s->fuel < fuel) {
X		strcat(telegram_buf, "\t\tNot enough fuel to launch!\n");
X		return 1;
X	}
X	/* ship is ready to fly - order the ship to its next destination */
X	s->whatdest = LEVEL_PLAN;
X	s->deststar = p->info[i].route[j].dest_star;
X	s->destpnum = p->info[i].route[j].dest_planet;
X	s->docked = 0;
X	use_fuel(s, fuel);
X	sprintf(buf, "\t\tDestination set to %s\n",
X		prin_ship_dest((int) s->owner, (int) s->governor, s));
X	strcat(telegram_buf, buf);
X	if (s->hyper_drive.has) {	/* order the ship to jump if it can */
X		if (s->storbits != s->deststar) {
X			s->navigate.on = 0;
X			s->hyper_drive.on = 1;
X			if (s->mounted) {
X				s->hyper_drive.charge = 1;
X				s->hyper_drive.ready = 1;
X			} else {
X				s->hyper_drive.charge = 0;
X				s->hyper_drive.ready = 0;
X			}
X			strcat(telegram_buf, "\t\tJump orders set\n");
X		}
X	}
X	return 1;
X}
END_OF_FILE
if test 16801 -ne `wc -c <'server/moveship.c'`; then
    echo shar: \"'server/moveship.c'\" unpacked with wrong size!
fi
# end of 'server/moveship.c'
fi
if test -f 'user/load.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/load.c'\"
else
echo shar: Extracting \"'user/load.c'\" \(34277 characters\)
sed "s/^X//" >'user/load.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * load.c -- load/unload stuff
X */
X#include <signal.h>
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X
Xextern char     Dessymbols[];
Xextern char    *Desnames[];
Xextern int      Defensedata[];
Xchar            buff[128], bufr[128], bufd[128], bufc[128], bufx[128],
X                bufm[128];
X
Xvoid            load(int, int, int, int);
Xvoid            jettison(int, int, int);
Xint             jettison_check(int, int, int, int);
Xvoid            dump(int, int, int);
Xvoid            transfer(int, int, int);
Xvoid            mount(int, int, int, int);
Xvoid            use_fuel(shiptype *, double);
Xvoid            use_destruct(shiptype *, int);
Xvoid            use_resource(shiptype *, int);
Xvoid            use_popn(shiptype *, int, double);
Xvoid            rcv_fuel(shiptype *, double);
Xvoid            rcv_resource(shiptype *, int);
Xvoid            rcv_destruct(shiptype *, int);
Xvoid            rcv_popn(shiptype *, int, double);
Xvoid            rcv_troops(shiptype *, int, double);
Xvoid            do_transporter(racetype *, int, shiptype *);
Xint             landed_on(shiptype *, int);
Xvoid 
Xunload_onto_alien_sector(int, int, planettype *, shiptype *,
X			 sectortype *, int, int);
X#include "proto.h"
X
Xvoid 
Xload(int Playernum, int Governor, int APcount, int mode)
X{
X	char            commod;
X	unsigned char   sh = 0, diff = 0;
X	int             lolim, uplim, amt;
X	int             transfercrew;
X	shiptype       *s, *s2;
X	planettype     *p;
X	sectortype     *sect;
X	racetype       *Race;
X	int             shipno, nextshipno;
X
X	if (argn < 2) {
X		notify(Playernum, Governor, "Load what?\n");
X		return;
X	}
X	nextshipno = start_shiplist(Playernum, Governor, args[1]);
X
X	while (shipno = do_shiplist(&s, &nextshipno))
X		if (in_list(Playernum, args[1], s, &nextshipno) &&
X		    authorized(Governor, s)) {
X			if (s->owner != Playernum || !s->alive) {
X				free(s);
X				continue;
X			}
X			if (!s->active) {
X				sprintf(buf, "%s is irradiated and inactive.\n", Ship(s));
X				notify(Playernum, Governor, buf);
X				free(s);
X				continue;
X			}
X			if (s->whatorbits == LEVEL_UNIV) {
X				if (!enufAP(Playernum, Governor, Sdata.AP[Playernum - 1], APcount)) {
X					free(s);
X					continue;
X				}
X			} else if (!enufAP(Playernum, Governor, Stars[s->storbits]->AP[Playernum - 1], APcount))
X				continue;
X			if (!s->docked) {
X				sprintf(buf, "%s is not landed or docked.\n", Ship(s));
X				notify(Playernum, Governor, buf);
X				free(s);
X				continue;
X			} else {/* ship has a recipient */
X				if (s->whatdest == LEVEL_PLAN) {
X					sprintf(buf, "%s at %d,%d\n", Ship(s), s->land_x, s->land_y);
X					notify(Playernum, Governor, buf);
X					if (s->storbits != Dir[Playernum - 1][Governor].snum ||
X					    s->pnumorbits != Dir[Playernum - 1][Governor].pnum) {
X						notify(Playernum, Governor, "Change scope to the planet this ship is landed on.\n");
X						free(s);
X						continue;
X					}
X				} else {	/* ship is docked */
X					if (!s->destshipno) {
X						sprintf(buf, "%s is not docked.\n", Ship(s));
X						free(s);
X						continue;
X					}
X					if (!getship(&s2, (int) s->destshipno)) {
X						notify(Playernum, Governor, "Destination ship is bogus.\n");
X						free(s);
X						continue;
X					}
X					if (!s2->alive ||
X					    !(s->whatorbits == LEVEL_SHIP || s2->destshipno == shipno)) {
X						/*
X						 * the ship it was docked
X						 * with died or undocked with
X						 * it or something.
X						 */
X						s->docked = 0;
X						s->whatdest = LEVEL_UNIV;
X						putship(s);
X						sprintf(buf, "%s is not docked.\n", Ship(s2));
X						notify(Playernum, Governor, buf);
X						free(s);
X						free(s2);
X						continue;
X					}
X					if (overloaded(s2) && s2->whatorbits == LEVEL_SHIP) {
X						sprintf(buf, "%s is overloaded!\n", Ship(s2));
X						notify(Playernum, Governor, buf);
X						free(s);
X						free(s2);
X						continue;
X					}
X					sprintf(buf, "%s docked with %s\n", Ship(s), Ship(s2));
X					notify(Playernum, Governor, buf);
X					sh = 1;
X					if (s2->owner != Playernum) {
X						sprintf(buf, "Player %d owns that ship.\n", s2->owner);
X						notify(Playernum, Governor, buf);
X						diff = 1;
X					}
X				}
X			}
X
X			commod = args[2][0];
X			if (argn > 3)
X				amt = atoi(args[3]);
X			else
X				amt = 0;
X
X			if (mode)
X				amt = -amt;	/* unload */
X
X			if (!sh)
X				getplanet(&p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X
X			if (!sh && (commod == 'c' || commod == 'm'))
X				getsector(&sect, p, (int) s->land_x, (int) s->land_y);
X
X			switch (commod) {
X			case 'x':
X			case '&':
X				if (sh) {
X					uplim = diff ? 0 : MIN(s2->crystals, Max_crystals(s) - s->crystals);
X					lolim = diff ? 0 : -MIN(s->crystals, Max_crystals(s2) - s2->crystals);
X				} else {
X					uplim = MIN(p->info[Playernum - 1].crystals, Max_crystals(s) - s->crystals);
X					lolim = -s->crystals;
X				}
X				break;
X			case 'c':
X				if (sh) {
X					uplim = diff ? 0 : MIN(s2->popn, Max_crew(s) - s->popn);
X					lolim = diff ? 0 : -MIN(s->popn, Max_crew(s2) - s2->popn);
X				} else {
X					uplim = MIN(sect->popn, Max_crew(s) - s->popn);
X					lolim = -s->popn;
X				}
X				break;
X			case 'm':
X				if (sh) {
X					uplim = diff ? 0 : MIN(s2->troops, Max_mil(s) - s->troops);
X					lolim = diff ? 0 : -MIN(s->troops, Max_mil(s2) - s2->troops);
X				} else {
X					uplim = MIN(sect->troops, Max_mil(s) - s->troops);
X					lolim = -s->troops;
X				}
X				break;
X			case 'd':
X				if (sh) {
X					uplim = diff ? 0 : MIN(s2->destruct, Max_destruct(s) - s->destruct);
X					lolim = -MIN(s->destruct, Max_destruct(s2) - s2->destruct);
X				} else {
X					uplim = MIN(p->info[Playernum - 1].destruct, Max_destruct(s) - s->destruct);
X					lolim = -s->destruct;
X				}
X				break;
X			case 'f':
X				if (sh) {
X					uplim = diff ? 0 : MIN((int) s2->fuel, (int) Max_fuel(s) - (int) s->fuel);
X					lolim = -MIN((int) s->fuel, (int) Max_fuel(s2) - (int) s2->fuel);
X				} else {
X					uplim = MIN((int) p->info[Playernum - 1].fuel, (int) Max_fuel(s) - (int) s->fuel);
X					lolim = -(int) s->fuel;
X				}
X				break;
X			case 'r':
X				if (sh) {
X					if (s->type == STYPE_SHUTTLE && s->whatorbits != LEVEL_SHIP)
X						uplim = diff ? 0 : s2->resource;
X					else
X						uplim = diff ? 0 : MIN(s2->resource, Max_resource(s) - s->resource);
X					if (s2->type == STYPE_SHUTTLE && s->whatorbits != LEVEL_SHIP)
X						lolim = -s->resource;
X					else
X						lolim = -MIN(s->resource, Max_resource(s2) - s2->resource);
X				} else {
X					uplim = MIN(p->info[Playernum - 1].resource, Max_resource(s) - s->resource);
X					lolim = -s->resource;
X				}
X				break;
X			default:
X				notify(Playernum, Governor, "No such commodity valid.\n");
X				if (sh)
X					free(s2);
X				else
X					free(p);
X				free(s);
X				continue;
X			}
X
X			if (amt < lolim || amt > uplim) {
X				sprintf(buf, "you can only transfer between %d and %d.\n", lolim, uplim);
X				notify(Playernum, Governor, buf);
X
X				if (sh)
X					free(s2);
X				else
X					free(p);
X				free(s);
X				continue;
X			}
X			Race = races[Playernum - 1];
X
X			if (amt == 0)
X				amt = (mode ? lolim : uplim);
X
X			switch (commod) {
X			case 'c':
X				if (sh) {
X					s2->popn -= amt;
X					if (!landed_on(s, sh))
X						s2->mass -= amt * Race->mass;
X					transfercrew = 1;
X				} else if (sect->owner && sect->owner != Playernum) {
X					sprintf(buf, "That sector is already occupied by another player!\n");
X					notify(Playernum, Governor, buf);
X					/* fight a land battle */
X					unload_onto_alien_sector(Playernum, Governor, p, s, sect, CIV, -amt);
X					putship(s);
X					putsector(sect, p, (int) s->land_x, (int) s->land_y);
X					putplanet(p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X					free(s);
X					free(sect);
X					free(p);
X					return;
X				} else {
X					transfercrew = 1;
X					if (!sect->popn && !sect->troops && amt < 0) {
X						p->info[Playernum - 1].numsectsowned++;
X						p->info[Playernum - 1].mob_points += sect->mobilization;
X						sect->owner = Playernum;
X						sprintf(buf, "sector %d,%d COLONIZED.\n",
X						      s->land_x, s->land_y);
X						notify(Playernum, Governor, buf);
X					}
X					sect->popn -= amt;
X					p->popn -= amt;
X					p->info[Playernum - 1].popn -= amt;
X					if (!sect->popn && !sect->troops) {
X						p->info[Playernum - 1].numsectsowned--;
X						p->info[Playernum - 1].mob_points -= sect->mobilization;
X						sect->owner = 0;
X						sprintf(buf, "sector %d,%d evacuated.\n",
X						      s->land_x, s->land_y);
X						notify(Playernum, Governor, buf);
X					}
X				}
X				if (transfercrew) {
X					s->popn += amt;
X					s->mass += amt * Race->mass;
X					sprintf(buf, "crew complement of %s is now %u.\n",
X						Ship(s), s->popn);
X					notify(Playernum, Governor, buf);
X				}
X				break;
X			case 'm':
X				if (sh) {
X					s2->troops -= amt;
X					if (!landed_on(s, sh))
X						s2->mass -= amt * Race->mass;
X					transfercrew = 1;
X				} else if (sect->owner && sect->owner != Playernum) {
X					sprintf(buf, "That sector is already occupied by another player!\n");
X					notify(Playernum, Governor, buf);
X					unload_onto_alien_sector(Playernum, Governor, p, s, sect, MIL, -amt);
X					putship(s);
X					putsector(sect, p, (int) s->land_x, (int) s->land_y);
X					putplanet(p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X					free(s);
X					free(sect);
X					free(p);
X					return;
X				} else {
X					transfercrew = 1;
X					if (!(sect->popn + sect->troops) && amt < 0) {
X						p->info[Playernum - 1].numsectsowned++;
X						p->info[Playernum - 1].mob_points += sect->mobilization;
X						sect->owner = Playernum;
X						sprintf(buf, "sector %d,%d OCCUPIED.\n",
X						      s->land_x, s->land_y);
X						notify(Playernum, Governor, buf);
X					}
X					sect->troops -= amt;
X					p->troops -= amt;
X					p->info[Playernum - 1].troops -= amt;
X					if (!(sect->troops + sect->popn)) {
X						p->info[Playernum - 1].numsectsowned--;
X						p->info[Playernum - 1].mob_points -= sect->mobilization;
X						sect->owner = 0;
X						sprintf(buf, "sector %d,%d evacuated.\n",
X						      s->land_x, s->land_y);
X						notify(Playernum, Governor, buf);
X					}
X				}
X				if (transfercrew) {
X					s->troops += amt;
X					s->mass += amt * Race->mass;
X					sprintf(buf, "troop complement of %s is now %u.\n",
X						Ship(s), s->troops);
X					notify(Playernum, Governor, buf);
X				}
X				break;
X			case 'd':
X				if (sh) {
X					s2->destruct -= amt;
X					if (!landed_on(s, sh))
X						s2->mass -= amt * MASS_DESTRUCT;
X				} else
X					p->info[Playernum - 1].destruct -= amt;
X
X				s->destruct += amt;
X				s->mass += amt * MASS_DESTRUCT;
X				sprintf(buf, "%d destruct transferred.\n", amt);
X				notify(Playernum, Governor, buf);
X				if (!Max_crew(s)) {
X					sprintf(buf, "\n%s ", Ship(s));
X					notify(Playernum, Governor, buf);
X					if (s->destruct) {
X						sprintf(buf, "now boobytrapped.\n");
X					} else {
X						sprintf(buf, "no longer boobytrapped.\n");
X					}
X					notify(Playernum, Governor, buf);
X				}
X				break;
X			case 'x':
X				if (sh) {
X					s2->crystals -= amt;
X				} else
X					p->info[Playernum - 1].crystals -= amt;
X				s->crystals += amt;
X				sprintf(buf, "%d crystal(s) transferred.\n", amt);
X				notify(Playernum, Governor, buf);
X				break;
X			case 'f':
X				if (sh) {
X					s2->fuel -= (double) amt;
X					if (!landed_on(s, sh))
X						s2->mass -= (double) amt *MASS_FUEL;
X				} else
X					p->info[Playernum - 1].fuel -= amt;
X				rcv_fuel(s, (double) amt);
X				sprintf(buf, "%d fuel transferred.\n", amt);
X				notify(Playernum, Governor, buf);
X				break;
X			case 'r':
X				if (sh) {
X					s2->resource -= amt;
X					if (!landed_on(s, sh))
X						s2->mass -= amt * MASS_RESOURCE;
X				} else
X					p->info[Playernum - 1].resource -= amt;
X				rcv_resource(s, amt);
X				sprintf(buf, "%d resources transferred.\n", amt);
X				notify(Playernum, Governor, buf);
X				break;
X			default:
X				notify(Playernum, Governor, "No such commodity.\n");
X
X				if (sh)
X					free(s2);
X				else
X					free(p);
X				free(s);
X				continue;
X			}
X
X			if (sh) {
X				/* ship to ship transfer */
X				buff[0] = bufr[0] = bufd[0] = bufc[0] = '\0';
X				switch (commod) {
X				case 'r':
X					sprintf(buf, "%d resources transferred.\n", amt);
X					notify(Playernum, Governor, buf);
X					sprintf(bufr, "%d Resources\n", amt);
X					break;
X				case 'f':
X					sprintf(buf, "%d fuel transferred.\n", amt);
X					notify(Playernum, Governor, buf);
X					sprintf(buff, "%d Fuel\n", amt);
X					break;
X				case 'd':
X					sprintf(buf, "%d destruct transferred.\n", amt);
X					notify(Playernum, Governor, buf);
X					sprintf(bufd, "%d Destruct\n", amt);
X					break;
X				case 'x':
X				case '&':
X					sprintf(buf, "%d crystals transferred.\n", amt);
X					notify(Playernum, Governor, buf);
X					sprintf(bufd, "%d Crystal(s)\n", amt);
X					break;
X				case 'c':
X					sprintf(buf, "%d popn transferred.\n", amt);
X					notify(Playernum, Governor, buf);
X					sprintf(bufc, "%d %s\n", amt,
X						Race->Metamorph ? "tons of biomass" : "population");
X					break;
X				case 'm':
X					sprintf(buf, "%d military transferred.\n", amt);
X					notify(Playernum, Governor, buf);
X					sprintf(bufm, "%d %s\n", amt,
X						Race->Metamorph ? "tons of biomass" : "population");
X					break;
X				default:
X					break;
X				}
X				putship(s2);
X				free(s2);
X			} else {
X				if (commod == 'c' || commod == 'm') {
X					putsector(sect, p, (int) s->land_x, (int) s->land_y);
X					free(sect);
X				}
X				putplanet(p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X				free(p);
X			}
X
X			/* do transporting here */
X			if (s->type == OTYPE_TRANSDEV && s->special.transport.target && s->on)
X				do_transporter(Race, Governor, s);
X
X			putship(s);
X			free(s);
X		} else
X			free(s);/* make sure you do this! */
X}
X
Xvoid 
Xjettison(int Playernum, int Governor, int APcount)
X{
X	int             Mod = 0;
X	int             shipno, nextshipno;
X	int             amt;
X	char            commod;
X	shiptype       *s;
X	racetype       *Race;
X
X	if (argn < 2) {
X		notify(Playernum, Governor, "Jettison what?\n");
X		return;
X	}
X	nextshipno = start_shiplist(Playernum, Governor, args[1]);
X
X	while (shipno = do_shiplist(&s, &nextshipno))
X		if (in_list(Playernum, args[1], s, &nextshipno) &&
X		    authorized(Governor, s)) {
X			if (s->owner != Playernum || !s->alive) {
X				free(s);
X				continue;
X			}
X			if (landed(s)) {
X				notify(Playernum, Governor, "Ship is landed, cannot jettison.\n");
X				free(s);
X				continue;
X			}
X			if (!s->active) {
X				sprintf(buf, "%s is irradiated and inactive.\n", Ship(s));
X				notify(Playernum, Governor, buf);
X				free(s);
X				continue;
X			}
X			if (s->whatorbits == LEVEL_UNIV) {
X				if (!enufAP(Playernum, Governor, Sdata.AP[Playernum - 1], APcount)) {
X					free(s);
X					continue;
X				}
X			} else if (!enufAP(Playernum, Governor, Stars[s->storbits]->AP[Playernum - 1], APcount)) {
X				free(s);
X				continue;
X			}
X			if (argn > 3)
X				amt = atoi(args[3]);
X			else
X				amt = 0;
X
X			Race = races[Playernum - 1];
X
X			commod = args[2][0];
X			switch (commod) {
X			case 'x':
X				if ((amt = jettison_check(Playernum, Governor, amt, (int) (s->crystals))) > 0) {
X					s->crystals -= amt;
X					sprintf(buf, "%d crystal%s jettisoned.\n", amt, (amt == 1) ? "" : "s");
X					notify(Playernum, Governor, buf);
X					Mod = 1;
X				}
X				break;
X			case 'c':
X				if ((amt = jettison_check(Playernum, Governor, amt, (int) (s->popn))) > 0) {
X					s->popn -= amt;
X					s->mass -= amt * Race->mass;
X					sprintf(buf, "%d crew %s into deep space.\n",
X						amt, (amt == 1) ? "hurls itself" : "hurl themselves");
X					notify(Playernum, Governor, buf);
X					sprintf(buf, "Complement of %s is now %u.\n", Ship(s), s->popn);
X					notify(Playernum, Governor, buf);
X					Mod = 1;
X				}
X				break;
X			case 'm':
X				if ((amt = jettison_check(Playernum, Governor, amt, (int) (s->troops))) > 0) {
X					sprintf(buf, "%d military %s into deep space.\n",
X						amt, (amt == 1) ? "hurls itself" : "hurl themselves");
X					notify(Playernum, Governor, buf);
X					sprintf(buf, "Complement of ship #%d is now %u.\n",
X						shipno, s->troops - amt);
X					notify(Playernum, Governor, buf);
X					s->troops -= amt;
X					s->mass -= amt * Race->mass;
X					Mod = 1;
X				}
X				break;
X			case 'd':
X				if ((amt = jettison_check(Playernum, Governor, amt, (int) (s->destruct))) > 0) {
X					use_destruct(s, amt);
X					sprintf(buf, "%d destruct jettisoned.\n", amt);
X					notify(Playernum, Governor, buf);
X					if (!Max_crew(s)) {
X						sprintf(buf, "\n%s ", Ship(s));
X						notify(Playernum, Governor, buf);
X						if (s->destruct) {
X							notify(Playernum, Governor, "still boobytrapped.\n");
X						} else {
X							notify(Playernum, Governor, "no longer boobytrapped.\n");
X						}
X					}
X					Mod = 1;
X				}
X				break;
X			case 'f':
X				if ((amt = jettison_check(Playernum, Governor, amt, (int) (s->fuel))) > 0) {
X					use_fuel(s, (double) amt);
X					sprintf(buf, "%d fuel jettisoned.\n", amt);
X					notify(Playernum, Governor, buf);
X					Mod = 1;
X				}
X				break;
X			case 'r':
X				if ((amt = jettison_check(Playernum, Governor, amt, (int) (s->resource))) > 0) {
X					use_resource(s, amt);
X					sprintf(buf, "%d resources jettisoned.\n", amt);
X					notify(Playernum, Governor, buf);
X					Mod = 1;
X				}
X				break;
X			default:
X				notify(Playernum, Governor, "No such commodity valid.\n");
X				return;
X			}
X			if (Mod)
X				putship(s);
X			free(s);
X		} else
X			free(s);
X}
X
Xint 
Xjettison_check(int Playernum, int Governor, int amt, int max)
X{
X	if (amt == 0)
X		amt = max;
X	if (amt < 0) {
X		notify(Playernum, Governor, "Nice try.\n");
X		return -1;
X	} else if (amt > max) {
X		sprintf(buf, "You can jettison at most %d\n", max);
X		notify(Playernum, Governor, buf);
X		return -1;
X	}
X	return amt;
X}
X
Xvoid 
Xdump(int Playernum, int Governor, int APcount)
X{
X	int             player, star, i, j;
X	racetype       *Race, *r;
X	placetype       where;
X
X	if (!enufAP(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1], APcount))
X		return;
X
X	if (!(player = GetPlayer(args[1]))) {
X		sprintf(buf, "No such player.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	r = races[player - 1];
X
X	if (r->Guest) {
X		notify(Playernum, Governor, "Cheater!\n");
X		return;
X	}
X	/* transfer all planet and star knowledge to the player */
X	/* get all stars and planets */
X	Race = races[Playernum - 1];
X	if (Race->Guest) {
X		notify(Playernum, Governor, "Cheater!\n");
X		return;
X	}
X	if (Governor) {
X		notify(Playernum, Governor, "Only leaders are allowed to use dump.\n");
X		return;
X	}
X	getsdata(&Sdata);
X
X	if (argn < 3) {
X		for (star = 0; star < Sdata.numstars; star++) {
X			getstar(&Stars[star], star);
X
X			if (isset(Stars[star]->explored, Playernum)) {
X				setbit(Stars[star]->explored, player);
X
X				for (i = 0; i < Stars[star]->numplanets; i++) {
X					getplanet(&planets[star][i], star, i);
X					if (planets[star][i]->info[Playernum - 1].explored) {
X						planets[star][i]->info[player - 1].explored = 1;
X						putplanet(planets[star][i], star, i);
X					}
X				}
X				putstar(Stars[star], star);
X			}
X		}
X	} else {		/* list of places given */
X		for (i = 2; i < argn; i++) {
X			where = Getplace(Playernum, Governor, args[i], 1);
X			if (!where.err && where.level != LEVEL_UNIV &&
X			    where.level != LEVEL_SHIP) {
X				star = where.snum;
X				getstar(&Stars[star], star);
X
X				if (isset(Stars[star]->explored, Playernum)) {
X					setbit(Stars[star]->explored, player);
X
X					for (j = 0; j < Stars[star]->numplanets; j++) {
X						getplanet(&planets[star][j], star, j);
X						if (planets[star][j]->info[Playernum - 1].explored) {
X							planets[star][j]->info[player - 1].explored = 1;
X							putplanet(planets[star][j], star, j);
X						}
X					}
X					putstar(Stars[star], star);
X				}
X			}
X		}
X	}
X
X	deductAPs(Playernum, Governor, APcount, Dir[Playernum - 1][Governor].snum, 0);
X
X	sprintf(buf, "%s [%d] has given you exploration data.\n", Race->name, Playernum);
X	warn_race(player, buf);
X	notify(Playernum, Governor, "Exploration Data transferred.\n");
X}
X
Xvoid 
Xtransfer(int Playernum, int Governor, int APcount)
X{
X	int             Mod = 0, player, give;
X	planettype     *planet;
X	char            commod = 0;
X	racetype       *r;
X
X	if (Dir[Playernum - 1][Governor].level != LEVEL_PLAN) {
X		sprintf(buf, "You need to be in planet scope to do this.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	if (!enufAP(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1], APcount))
X		return;
X
X	if (!(player = GetPlayer(args[1]))) {
X		sprintf(buf, "No such player.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	r = races[player - 1];
X
X	getplanet(&planet, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X
X	sscanf(args[2], "%c", &commod);
X	give = atoi(args[3]);
X
X	if (give < 0) {
X		notify(Playernum, Governor, "You must specify a positive amount.\n");
X		free(planet);
X		return;
X	}
X	sprintf(temp, "%s/%s:", Stars[Dir[Playernum - 1][Governor].snum]->name,
X		Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum]);
X	switch (commod) {
X	case 'r':
X		if (give > planet->info[Playernum - 1].resource) {
X			sprintf(buf, "You don't have %d on this planet.\n", give);
X			notify(Playernum, Governor, buf);
X		} else {
X			planet->info[Playernum - 1].resource -= give;
X			planet->info[player - 1].resource += give;
X			sprintf(buf, "%s %d resources transferred from player %d to player #%d\n",
X				temp, give, Playernum, player);
X			notify(Playernum, Governor, buf);
X			warn_race(player, buf);
X		}
X		break;
X	case 'x':
X	case '&':
X		if (give > planet->info[Playernum - 1].crystals) {
X			sprintf(buf, "You don't have %d on this planet.\n", give);
X			notify(Playernum, Governor, buf);
X		} else {
X			planet->info[Playernum - 1].crystals -= give;
X			planet->info[player - 1].crystals += give;
X			sprintf(buf, "%s %d crystal(s) transferred from player %d to player #%d\n",
X				temp, give, Playernum, player);
X			notify(Playernum, Governor, buf);
X			warn_race(player, buf);
X		}
X		break;
X	case 'f':
X		if (give > planet->info[Playernum - 1].fuel) {
X			sprintf(buf, "You don't have %d fuel on this planet.\n", give);
X			notify(Playernum, Governor, buf);
X		} else {
X			planet->info[Playernum - 1].fuel -= give;
X			planet->info[player - 1].fuel += give;
X			sprintf(buf, "%s %d fuel transferred from player %d to player #%d\n",
X				temp, give, Playernum, player);
X			notify(Playernum, Governor, buf);
X			warn_race(player, buf);
X		}
X		break;
X	case 'd':
X		if (give > planet->info[Playernum - 1].destruct) {
X			sprintf(buf, "You don't have %d destruct on this planet.\n", give);
X			notify(Playernum, Governor, buf);
X		} else {
X			planet->info[Playernum - 1].destruct -= give;
X			planet->info[player - 1].destruct += give;
X			sprintf(buf, "%s %d destruct transferred from player %d to player #%d\n",
X				temp, give, Playernum, player);
X			notify(Playernum, Governor, buf);
X			warn_race(player, buf);
X		}
X		break;
X	default:
X		sprintf(buf, "What?\n");
X		notify(Playernum, Governor, buf);
X	}
X
X	putplanet(planet, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X
X	free(planet);
X	Mod = 1;
X
X	deductAPs(Playernum, Governor, APcount, Dir[Playernum - 1][Governor].snum, 0);
X
X}
X
Xvoid 
Xmount(int Playernum, int Governor, int APcount, int mnt)
X{
X	shiptype       *ship;
X	int             shipno, nextshipno;
X
X	nextshipno = start_shiplist(Playernum, Governor, args[1]);
X	while (shipno = do_shiplist(&ship, &nextshipno))
X		if (in_list(Playernum, args[1], ship, &nextshipno) &&
X		    authorized(Governor, ship)) {
X			if (!ship->mount) {
X				notify(Playernum, Governor, "This ship is not equipped with a crystal mount.\n");
X				free(ship);
X				continue;
X			}
X			if (ship->mounted && mnt) {
X				notify(Playernum, Governor, "You already have a crystal mounted.\n");
X				free(ship);
X				continue;
X			} else if (!ship->mounted && !mnt) {
X				notify(Playernum, Governor, "You don't have a crystal mounted.\n");
X				free(ship);
X				continue;
X			} else if (!ship->mounted && mnt) {
X				if (!ship->crystals) {
X					notify(Playernum, Governor, "You have no crystals on board.\n");
X					free(ship);
X					continue;
X				}
X				ship->mounted = 1;
X				ship->crystals--;
X				notify(Playernum, Governor, "Mounted.\n");
X			} else if (ship->mounted && !mnt) {
X				if (ship->crystals == Max_crystals(ship)) {
X					notify(Playernum, Governor, "You can't dismount the crystal. Max allowed already on board.\n");
X					free(ship);
X					continue;
X				}
X				ship->mounted = 0;
X				ship->crystals++;
X				notify(Playernum, Governor, "Dismounted.\n");
X				if (ship->hyper_drive.charge || ship->hyper_drive.ready) {
X					ship->hyper_drive.charge = 0;
X					ship->hyper_drive.ready = 0;
X					notify(Playernum, Governor, "Discharged.\n");
X				}
X				if (ship->laser && ship->fire_laser) {
X					ship->fire_laser = 0;
X					notify(Playernum, Governor, "Laser deactivated.\n");
X				}
X			} else {
X				notify(Playernum, Governor, "Weird error in 'mount'.\n");
X				free(ship);
X				continue;
X			}
X			putship(ship);
X			free(ship);
X		} else
X			free(ship);
X}
X
Xvoid 
Xuse_fuel(shiptype * s, double amt)
X{
X	s->fuel -= amt;
X	s->mass -= amt * MASS_FUEL;
X}
X
Xvoid 
Xuse_destruct(shiptype * s, int amt)
X{
X	s->destruct -= amt;
X	s->mass -= (double) amt *MASS_DESTRUCT;
X}
X
Xvoid 
Xuse_resource(shiptype * s, int amt)
X{
X	s->resource -= amt;
X	s->mass -= (double) amt *MASS_RESOURCE;
X}
X
Xvoid 
Xuse_popn(shiptype * s, int amt, double mass)
X{
X	s->popn -= amt;
X	s->mass -= (double) amt *mass;
X}
X
Xvoid 
Xrcv_fuel(shiptype * s, double amt)
X{
X	s->fuel += amt;
X	s->mass += amt * MASS_FUEL;
X}
X
Xvoid 
Xrcv_resource(shiptype * s, int amt)
X{
X	s->resource += amt;
X	s->mass += (double) amt *MASS_RESOURCE;
X}
X
Xvoid 
Xrcv_destruct(shiptype * s, int amt)
X{
X	s->destruct += amt;
X	s->mass += (double) amt *MASS_DESTRUCT;
X}
X
Xvoid 
Xrcv_popn(shiptype * s, int amt, double mass)
X{
X	s->popn += amt;
X	s->mass += (double) amt *mass;
X}
X
Xvoid 
Xrcv_troops(shiptype * s, int amt, double mass)
X{
X	s->troops += amt;
X	s->mass += (double) amt *mass;
X}
X
Xvoid 
Xdo_transporter(racetype * Race, int Governor, shiptype * s)
X{
X	int             Playernum;
X	shiptype       *s2;
X
X	Playernum = Race->Playernum;
X
X	if (!landed(s)) {
X		notify(Playernum, Governor, "Origin ship not landed.\n");
X		return;
X	}
X	if (s->storbits != Dir[Playernum - 1][Governor].snum ||
X	    s->pnumorbits != Dir[Playernum - 1][Governor].pnum) {
X		sprintf(buf, "Change scope to the planet the ship is landed on!\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	if (s->damage) {
X		notify(Playernum, Governor, "Origin device is damaged.\n");
X		return;
X	}
X	if (!getship(&s2, (int) s->special.transport.target)) {
X		sprintf(buf, "The hopper seems to be blocked.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	if (!s2->alive || s2->type != OTYPE_TRANSDEV || !s2->on) {
X		sprintf(buf, "The target device is not receiving.\n");
X		notify(Playernum, Governor, buf);
X		free(s2);
X		return;
X	}
X	if (!landed(s2)) {
X		notify(Playernum, Governor, "Target ship not landed.\n");
X		free(s2);
X		return;
X	}
X	if (s2->damage) {
X		notify(Playernum, Governor, "Target device is damaged.\n");
X		free(s2);
X		return;
X	}
X	sprintf(buf, "Zap\07!\n");	/* ^G */
X	notify(Playernum, Governor, buf);
X	/* send stuff to other ship (could be transport device) */
X	if (s->resource) {
X		rcv_resource(s2, (int) s->resource);
X		sprintf(buf, "%d resources transferred.\n", s->resource);
X		notify(Playernum, Governor, buf);
X		sprintf(bufr, "%d Resources\n", s->resource);
X		use_resource(s, (int) s->resource);
X	} else
X		bufr[0] = '\0';
X	if (s->fuel) {
X		rcv_fuel(s2, s->fuel);
X		sprintf(buf, "%g fuel transferred.\n", s->fuel);
X		notify(Playernum, Governor, buf);
X		sprintf(buff, "%g Fuel\n", s->fuel);
X		use_fuel(s, s->fuel);
X	} else
X		buff[0] = '\0';
X
X	if (s->destruct) {
X		rcv_destruct(s2, (int) s->destruct);
X		sprintf(buf, "%d destruct transferred.\n", s->destruct);
X		notify(Playernum, Governor, buf);
X		sprintf(bufd, "%d Destruct\n", s->destruct);
X		use_destruct(s, (int) s->destruct);
X	} else
X		bufd[0] = '\0';
X
X	if (s->popn) {
X		s2->mass += s->popn * Race->mass;
X		s2->popn += s->popn;
X
X		sprintf(buf, "%d population transferred.\n", s->popn);
X		notify(Playernum, Governor, buf);
X		sprintf(bufc, "%d %s\n", s->popn,
X			Race->Metamorph ? "tons of biomass" : "population");
X		s->mass -= s->popn * Race->mass;
X		s->popn -= s->popn;
X	} else
X		bufc[0] = '\0';
X
X	if (s->crystals) {
X		s2->crystals += s->crystals;
X
X		sprintf(buf, "%d crystal(s) transferred.\n", s->crystals);
X		notify(Playernum, Governor, buf);
X		sprintf(bufx, "%d crystal(s)\n", s->crystals);
X
X		s->crystals = 0;
X	} else
X		bufx[0] = '\0';
X
X	if (s2->owner != s->owner) {
X		sprintf(telegram_buf, "Audio-vibatory-physio-molecular transport device #");
X		sprintf(buf, "%s gave your ship %s the following:\n", Ship(s), Ship(s2));
X		strcat(telegram_buf, buf);
X		strcat(telegram_buf, bufr);
X		strcat(telegram_buf, bufd);
X		strcat(telegram_buf, buff);
X		strcat(telegram_buf, bufc);
X		strcat(telegram_buf, bufm);
X		strcat(telegram_buf, bufx);
X		warn((int) s2->owner, (int) s2->governor, telegram_buf);
X	}
X	putship(s2);
X	free(s2);
X}
X
Xint 
Xlanded_on(shiptype * s, int shipno)
X{
X	return (s->whatorbits == LEVEL_SHIP && s->destshipno == shipno);
X}
X
Xvoid 
Xunload_onto_alien_sector(int Playernum, int Governor, planettype * planet,
X			 shiptype * ship, sectortype * sect, int what,
X			 int people)
X{
X	double          astrength, dstrength;
X	int             oldowner, oldgov, oldpopn, old2popn, old3popn;
X	int             casualties, casualties2, casualties3;
X	int             absorbed, defense;
X	racetype       *Race, *alien;
X
X	if (people <= 0) {
X		notify(Playernum, Governor, "You have to unload to assault alien sectors.\n");
X		return;
X	}
X	ground_assaults[Playernum - 1][sect->owner - 1][Dir[Playernum - 1][Governor].snum] += 1;
X	Race = races[Playernum - 1];
X	alien = races[sect->owner - 1];
X	/* races find out about each other */
X	alien->translate[Playernum - 1] = MIN(alien->translate[Playernum - 1] + 5, 100);
X	Race->translate[sect->owner - 1] = MIN(Race->translate[sect->owner - 1] + 5, 100);
X
X	oldowner = (int) sect->owner;
X	oldgov = Stars[Dir[Playernum - 1][Governor].snum]->governor[sect->owner - 1];
X
X	if (what == CIV)
X		ship->popn -= people;
X	else
X		ship->troops -= people;
X	ship->mass -= people * Race->mass;
X	sprintf(buf, "%d %s unloaded...\n", people, what == CIV ? "civ" : "mil");
X	notify(Playernum, Governor, buf);
X	sprintf(buf, "Crew compliment %d civ  %d mil\n", ship->popn, ship->troops);
X	notify(Playernum, Governor, buf);
X
X	sprintf(buf, "%d %s assault %d civ/%d mil\n",
X	     people, what == CIV ? "civ" : "mil", sect->popn, sect->troops);
X
X	notify(Playernum, Governor, buf);
X	oldpopn = people;
X	old2popn = sect->popn;
X	old3popn = sect->troops;
X
X	defense = Defensedata[sect->condition];
X	ground_attack(Race, alien, &people, what, &sect->popn, &sect->troops,
X		      (int) ship->armor, defense,
X	 1.0 - (double) ship->damage / 100.0, alien->likes[sect->condition],
X		      &astrength, &dstrength,
X		      &casualties, &casualties2, &casualties3);
X	sprintf(buf, "Attack: %.2f   Defense: %.2f.\n", astrength, dstrength);
X	notify(Playernum, Governor, buf);
X
X	if (!(sect->popn + sect->troops)) {	/* we got 'em */
X		/* mesomorphs absorb the bodies of their victims */
X		absorbed = 0;
X		if (Race->absorb) {
X			absorbed = int_rand(0, old2popn + old3popn);
X			sprintf(buf, "%d alien bodies absorbed.\n", absorbed);
X			notify(Playernum, Governor, buf);
X			sprintf(buf, "Metamorphs have absorbed %d bodies!!!\n",
X				absorbed);
X			notify(oldowner, oldgov, buf);
X		}
X		if (what == CIV)
X			sect->popn = people + absorbed;
X		else if (what == MIL) {
X			sect->popn = absorbed;
X			sect->troops = people;
X		}
X		sect->owner = Playernum;
X		adjust_morale(Race, alien, (int) alien->fighters);
X	} else {		/* retreat */
X		absorbed = 0;
X		if (alien->absorb) {
X			absorbed = int_rand(0, oldpopn - people);
X			sprintf(buf, "%d alien bodies absorbed.\n", absorbed);
X			notify(oldowner, oldgov, buf);
X			sprintf(buf, "Metamorphs have absorbed %d bodies!!!\n", absorbed);
X			notify(Playernum, Governor, buf);
X			sect->popn += absorbed;
X		}
X		/* load them back up */
X		sprintf(buf, "Loading %d %s\n", people, what == CIV ? "civ" : "mil");
X		notify(Playernum, Governor, buf);
X		if (what == CIV)
X			ship->popn += people;
X		else
X			ship->troops += people;
X		ship->mass -= people * Race->mass;
X		adjust_morale(alien, Race, (int) Race->fighters);
X	}
X	sprintf(telegram_buf, "/%s/%s: %s [%d] %s assaults %s [%d] %c(%d,%d) %s\n",
X		Stars[Dir[Playernum - 1][Governor].snum]->name,
X		Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum],
X	   Race->name, Playernum, Ship(ship), alien->name, alien->Playernum,
X		Dessymbols[sect->condition], ship->land_x, ship->land_y,
X		(sect->owner == Playernum ? "VICTORY" : "DEFEAT"));
X
X	if (sect->owner == Playernum) {
X		sprintf(buf, "VICTORY! The sector is yours!\n");
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "Sector CAPTURED!\n");
X		strcat(telegram_buf, buf);
X		if (people) {
X			sprintf(buf, "%d %s move in.\n", people, what == CIV ? "civilians" : "troops");
X			notify(Playernum, Governor, buf);
X		}
X		planet->info[Playernum - 1].numsectsowned++;
X		planet->info[Playernum - 1].mob_points += (int) sect->mobilization;
X		planet->info[oldowner - 1].numsectsowned--;
X		planet->info[oldowner - 1].mob_points -= (int) sect->mobilization;
X	} else {
X		sprintf(buf, "The invasion was repulsed; try again.\n");
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "You fought them off!\n");
X		strcat(telegram_buf, buf);
X	}
X	if (!(sect->popn + sect->troops + people)) {
X		sprintf(buf, "You killed all of them!\n");
X		strcat(telegram_buf, buf);
X		/* increase modifier */
X		Race->translate[oldowner - 1] = MIN(Race->translate[oldowner - 1] + 5, 100);
X	}
X	if (!people) {
X		sprintf(buf, "Oh no! They killed your party to the last man!\n");
X		notify(Playernum, Governor, buf);
X		/* increase modifier */
X		alien->translate[Playernum - 1] = MIN(alien->translate[Playernum - 1] + 5, 100);
X	}
X	putrace(alien);
X	putrace(Race);
X
X	sprintf(buf, "Casualties: You: %d civ/%d mil, Them: %d %s\n",
X	 casualties2, casualties3, casualties, what == CIV ? "civ" : "mil");
X	strcat(telegram_buf, buf);
X	warn(oldowner, oldgov, telegram_buf);
X	sprintf(buf, "Casualties: You: %d %s, Them: %d civ/%d mil\n",
X	 casualties, what == CIV ? "civ" : "mil", casualties2, casualties3);
X	notify(Playernum, Governor, buf);
X	return;
X}
END_OF_FILE
if test 34277 -ne `wc -c <'user/load.c'`; then
    echo shar: \"'user/load.c'\" unpacked with wrong size!
fi
# end of 'user/load.c'
fi
echo shar: End of archive 5 \(of 21\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
