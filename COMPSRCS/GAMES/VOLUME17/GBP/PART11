Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i023:  gbp - Galactic Bloodshed+, an empire-like war game, Part11/21
Message-ID: <4551@master.CNA.TEK.COM>
Date: 12 Feb 93 17:31:31 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1560
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1702

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 23
Archive-name: gbp/Part11
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 11 (of 21)."
# Contents:  misc/exam.dat user/fire.c user/power.c
# Wrapped by billr@saab on Fri Feb 12 09:14:27 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'misc/exam.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc/exam.dat'\"
else
echo shar: Extracting \"'misc/exam.dat'\" \(20432 characters\)
sed "s/^X//" >'misc/exam.dat' <<'END_OF_FILE'
X~
XSpore Pod
X
X    This is a small seed pod grown by a mesomorphic race and is used 
Xprimarily to colonize other planets. A Pod can be landed like a normal 
Xship upon reaching a destination. However, a Pod can also be warmed by a 
Xstar, causing it to explode, possibly seeding a random planet in that star 
Xsystem. Deterioration builds up in a Pod and will eventually cause it to 
Xdecay. Pods usually last around four updates.
X~
XShuttle
X
X    This is a small, short-range spacecraft, intended for interplanetary
Xexploration and for shuttling things between ground and orbit. This ship is
Xalso useful for assembling other ships in space, as resources can be
Xtransferred from another ship using the load command until it is carrying
Xmore than the maximum cargo. The Shuttle, however, cannot take off or land
Xwith this extra cargo. Shuttles are one of the few classes of ships that can
Xconstruct other ships. They have one light gun for self defense and no
Xarmor.  
X~
XCarrier
X
X    Carriers have huge hangers, enabling them to carry and support many 
Xcompanion ships. Any real battle group will be equipped with one of
Xthese massive machines. They are not amazingly armored, but are armed about
Xequivalent to a Battleship. These ships are so large, they can not land on 
Xplanets and must be built in space.
X    This ship is built with 50% damage. Construction must be completed 
Xmanually.
X~
XDreadnaught
X
X    This ship is the largest and best armored combat vessel. With twice the 
Xgunpower of the Battleship and heavy-duty armor, the Dreadnaught makes an 
Xexcellent flagship for any navy.
X    This ship is built with 50% damage. Construction must be completed 
Xmanually.
X~
XBattleship
X
X    Although not quite the mighty Dreadnaught, the Battleship is the basic 
Xheavy class combat ship. With its excellent armor and heavy firepower, 
Xthis ship works well for general-purpose assaults, and fleet duty.
X    This ship is built with 50% damage. Construction must be completed 
Xmanually.
X~
XInterceptor
X
X    This ship is a step above the Destroyer. Although equipped with the same 
Xarmor, the Interceptor has more firepower and excellent range via its 
Xlarge fuel capacity, which can even outdistance a standard Cruiser class 
Xship. An Interceptor is an excellent choice for lengthy, but potentially 
Xdangerous patrols.
X    This ship is built with 50% damage. Construction must be completed 
Xmanually.
X~
XCruiser
X
X    This ship is a medium class escort/battle vessel. Although without the 
Xrange of the Interceptor, the Cruiser boasts heavy caliber firepower and 
Xsubstantially more armor. These ships can provide a strong foundation for 
Xa powerful fleet.
X    This ship is built with 50% damage. Construction must be completed 
Xmanually.
X~
XDestroyer
X
X    This ship is the smallest of the combat ships. With moderate arms and 
Xarmor, this ship can provide decent star system security at the lower 
Xtechnology levels, and later can be produced en masse to fill in a fleet. 
XIt is always a good choice for escort duty.
X    This ship is built with 50% damage. Construction must be completed 
Xmanually.
X~
XFighter Group
X
X    The Fighter Group is a quick, high power weapon when utilized correctly. 
XTheir short range necessitates transport ships, but the tactical advantage 
Xthese ships can create make them indispensable assets in combat. Fighter 
Xgroups represent up to five individual craft at full strength. This 
Xinterpretation, however, is unimportant with the scale of the game.
X~
XExplorer
X
X    This is a small and fast long-range exploration craft with almost no
Xweapons capacity but some armor. It has much increased range over shuttle
Xcraft and is also faster, and much more heavily armed. This is not a ship
Xto tangle with warships, although it is rather ideal for armed recon.
X~
XSpace Habitat
X
X    This is a residential platform, a space colony. It can be used to
Xmanufacture other ships, as well as safeguard your race against extinction,
Xif you choose to send it into interstellar space as an insurance measure. 
XHabitats can build any ship a warship is able to, and may also build 
Xthese ship types: C, H, S, O, M, @, l, :, F, T and W. Both Factories (F) 
Xand Weapon Plants (W) may be operated in the hanger area of a Habitat. 
XThey are equipped with defensive strength arms and armor.
X    Habitats also have sophisticated manufacturing and refining equipment, 
Xenabling the Habitat to convert fuel into resources (typically at 20 fuel 
Xper resource), in proportion to the number of people staffing it. To 
Xfacilitate the conversion, they also gather fuel at gas giants at a high 
Xrate, normally twice the rate of a Fuel Tanker. The Habitat must be 
Xswitched on with the order command before it will produce resources.
X    Habitats are the only ships in which citizens feel comfortable enough to 
Xreproduce freely.
X    This ship is built with 75% damage. Construction must be completed 
Xmanually.
X~
XSpace Station
X
X    This is an orbital installation useful as a military depot as well 
Xas a perimeter planetary defense base. They do not pack heavy firepower, 
Xthough, and have little armor. It can build any ships that warships or 
Xshuttles can build.
X    Stations are unusual in that they can repair themselves for free,
Xwithout charging resources. Ships docked with or landed on a station can 
Xalso take advantage of this feature.
X    This ship is built with 75% damage. Construction must be completed 
Xmanually.
X~
XOrbital Assault Platform
X
X    This is a huge station-like construction, bristling with firepower.
XIts horribly impressive weaponry system makes it useful for enslaving 
Xrecalcitrant worlds (with the 'enslave' command). It can also be used
Xfor constructing other ships as can shuttles and habitats, however it
Xcannot reproduce citizens or manufacture resources.
X    An OAP must be built in space and is too large to be landed on a planet.
X    This ship is built with 75% damage. Construction must be completed 
Xmanually.
X~
XCargo Ship
X
X    A basic all-purpose transport ship, a cargo ship has long range 
Xcapability, but little defensive capability. Escort ships are a definite 
Xmust when using these ships in volatile areas.
X~
XTanker
X
X    This ship can carry large amounts of fuel and moderate amounts of other 
Xcommodities. In addition, it can also collect fuel at a high rate by 
Xorbiting a gas giant.
X~
XSpace Mine
X
X    This device is a proximity mine, exploding on contact with enemy
Xships or, if set with the 'order' command, showering them with deadly 
Xradiation. Affected ships, when irradiated, can become periodically 
Ximmobile; each turn, an affected ship's crew is reduced by 20%.
X    The mine can be armed/disarmed with 'order', and its trigger radius 
Xalso altered with the 'order' command. 
X    Alien space mines are difficult to detect. They are invisible on the
Xsolar system maps but can be detected with the `tactical' command. 
XTheir precise locations may be difficult to triangulate. They also possess
Xa high defense strength since they are small objects and difficult to hit
Xnonetheless find. A Mine Sweeper can facilitate rooting out these 
Xdangerous surprises.
X    Mines are triggered by ships moving inside of their assigned trigger 
Xradius.
X~
XSpace Mirror
X
X    This is a large plane of reflecting material, suitable for altering 
Xthe ambient temperature of a planet if aimed at one (via the 'order'
Xcommand). The intensity of the reflected beam can also be set with 'order'. 
XThe intensity is the maximum temperature rise of the planet in degrees; 
Xthis amount may be reduced by damage to the Mirror or by range.
X    A Space Mirror may also be used as a weapon if aimed at a ship. The 
Xdamage done to the ship is proportional to the intensity set on the Mirror 
Xand inversely related to the target's size and the range to the target. 
X    This ship also has attitude jets for maneuvering. 
X    This ship is built with 75% damage. Construction must be completed 
Xmanually.
X~
XSpace Telescope
X
X    This is a space-based astronomical facility, with fuel and engines
Xfor launching it into orbit. It has a much longer range than a 
Xground-based telescope. The tech level of a race determines the 
Xtelescope's range at build time. Ranges for telescopes built before the 
Xnext update are listed in a race's profile.
X~
XGround Telescope
X
X    This is a ground-based astronomical facility. It is able to survey
Xthe nearest planets for mapping purposes. The tech level of a race 
Xdetermines the telescope's range at build time. Ranges for telescopes 
Xbuilt before the next update are listed in a race's profile.
X~
XTractor/repulsor beam
X
X    When this device can be aimed at a ship or planet and activated,
Xit will attract/repel the other object. Newton's Law, however, requires
Xthat the smaller of the two objects move more than the larger.
X    This ship has not been programmed in yet.
X~
XAtmosphere Processor
X
X    This is a large machine (of the type in _Aliens_) that sucks in
Xthe atmosphere of a planet, converting it to the type of air preferred by 
Xits owner. You must load fuel and crew into these objects for them to 
Xoperate. The device also must be activated with the order command. 
XLarger planets take longer to convert than smaller planets.
X    The Processor uses three fuel units per turn.
X~
XDust Canister
X
X    This is a small canister of light-absorbing dust. When launched it
Xwill spread into the atmosphere of the planet, lowering its ambient
Xtemperature by ten degrees per update. Multiple Dust Canisters have a 
Xcumulative effect, but the temperature of a planet can not be lowered by 
Xmore than 100 degrees. This can be used to terraforming purposes, when the 
Xtemperature is too high for comfort. 
X    The dust disperses after 80 turns.
X~
XGreenhouse Gases
X
X    This device produces large amounts of greenhouse gases when launched 
Xinto the atmosphere of a planet, raising the temperature near the planet 
Xsurface by ten degrees per update. Launching more than one will warm the 
Xplanet faster, but the temperature of a planet can not be raised by more 
Xthan 100 degrees. This can be used to terraforming purposes, when the 
Xtemperature is too low for comfort.
X    The gases disperse after 80 turns.
X~
XGovernmental Center
X
X    This represents the seat of government of an entire civilization.
XAlthough superficially a ship, it is not designed to be moved; if your
Xcapitol is not landed on a planet, it produces no action points. However
Xit can be launched and landed like any other ship should an emergency 
Xarise. If a capitol is destroyed another one must be designated with the 
X'capitol' command. Note that it is possible to maintain more than one 
Xgovernment center; this has no benefit beyond serving as a backup in the 
Xcase of destruction of the current capitol.
X    This ship is built with 75% damage. Construction must be completed 
Xmanually.
X~
XOrbital Mind-control laser
X
X    This device, when aimed at a ship, produces resonating vibrations
Xwithin the ship's hull, to cause the mental attitude of the crew to
Xbe altered. The crew's response to influence is dependent on the
Xarmor of the affected ship, becoming more and more difficult for the
Xvibrations to be produced as the target ship's armor increases. The laser 
Xhas a range similar to the player's gun range.
X    Response can be toggled by the "desired response" register
Xin the order command: from convincing the crew to trigger their aggressive
Xresponse and kill each other, to converting them to sympathy for your
Xrace and its motivations; each response has a percentage chance of
Xconversion.
X    The orbital mind-control lasers are currently only effective on
Xplanets, and have one setting: to suppress emotion, which causes no 
Xfighting or migrations to take place.
X    This device is not programmed in yet.
X~
XToxic Waste Container
X
X    This is a sealed container used to store environmental poisons.
XWhen toxicity of a planet becomes too high, constructing one of these
Xcontainers will reduce the poison level by 20%. If the container is
Xbreached, however, the toxic waste inside it will escape.
X~
XSpace Probe
X
X    This device is used to sight positions of enemy fleets. The ship is 
Xrobotic and requires no crew, but reports data from its explorations to 
Xthe building race as if it were manned. It is quite fast and can be 
Xuseful for analyzing the strategic deployments of enemy ships. 
X~
XGamma Ray Laser
X
X    This device fires a deadly stream of radiation at its target when
Xfired. It uses destructive capacity in the same manner other ships use it
Xfor their guns. Radiation is not accumulated in target ships; if a ship's
Xradiation level is 10, only a more powerful shot from the laser may 
Xincrease the radiation level. A weaker shot will have no effect at all.
X    Radiation does not kill immediately, but will kill off 20% of the ship's 
Xpopulation each update. Each movement segment, a ship may have a chance  
Xof becoming inactive due to the radiation levels in the ship. 
X    This ship is built with 75% damage. Construction must be completed 
Xmanually.
X~
XFactory
X
X    A Factory is built to produce other ships. To see a list of ships which 
Xmust be built in a Factory, see the help topic 'build'. After being 
Xbuilt, descend to the ship's scope and specify the ship type this Factory 
Xwill be able to produce with the 'make' command. The stats of the ship to 
Xbe produced can then be modified by using the 'modify' command. Finally, 
Xthe Factory must ordered online with the 'order' command. Once activated 
Xit cannot be turned off, nor can the specification of the ships it is to 
Xmanufacture be altered in any way. 
X    A Factory is built with 75% damage. This represents the time it will
Xtake to start up production. Damage will repair itself during movement 
Xsegments automatically. To begin repairing however the ship must first be 
Xordered 'on'.
X    See 'help build' for more information regarding factories.
X~
XTerraforming Device
X
X    This device alters the surface of a planet to better suit its 
Xowner. Once activated and given a move command (see the command 'order' 
Xfor more help), the Terraforming Device moves each update according to 
Xits orders, altering sectors as it goes. If it reaches the north or south 
Xof the planet map, it will bounce off and continue. 
X    It will move first, then terraform, so that it will not destroy the 
Xsector on which it was built. Any sector terraformed will have its 
Xefficiency, mobilization, population, and troop count reduced to 0. 'Gas' 
Xsectors can not be terraformed to any other type of sector, but not 
Xvice versa.
X    Terraforming requires three fuel per update. Terraforming can increase 
Xthe toxicity level of a planet.
X~
XAudio-Vibatory-Physio-Molecular Transport Device
X
X    This device has a hopper for the loading of material. When it detects
Xthe presence of something in the hopper, it will transport this material 
Xinto the hopper of its target device. The target device can be specified 
Xwith the 'order' command.
X    You should specify the number of the receiving Transporter. If the
Xtarget ship is set to `0' cargo will not be transported anywhere and will
Xremain in the hopper. Both the sending and target Transporters must be 
Xlanded and undamaged to transport material.
X    This ship is built with 50% damage. Construction must be completed 
Xmanually.
X~
XMissile
X
X    This weapon can be used to attack enemy planets or ships. In order to
Xattack with a missile, they must be launched and then given a destination. 
XIf the destination is a ship it will detonate upon reaching the enemy 
Xship. If the destination is a planet, the missile will impact on the 
Xdesignated sector. See help on 'order' for designating missile impact 
Xcoordinates. A missile may be designated to impact a specific sector, or 
Xmay be allowed to randomly hit the planet. 
X    A missile aimed for a planet will automatically switch its target to any 
XPlanetary Defense Networks protecting the planet. The only automatic 
Xdefense against missiles is the ABM battery.
X~
XPlanetary Defense Network
X
X    These are powerful, well armored planetary guns which prevent enemy 
Xplayers to fire at planets as long as they are present. Before a player 
Xmay attack sectors with orbiting ships, all planetary defense systems must 
Xbe eliminated.
X    This ship is built with 75% damage. Construction must be completed 
Xmanually.
X~
XQuarry
X
X    This ship is used to mine resources from a sector. The amount of 
Xresources per update mined from a sector with a Quarry is the percentage 
Xof crew complement times the race's metabolism.
X    This disadvantage of Quarries is not only that they will reduce
Xthe fertility of a sector by the amount of resources produced, but they 
Xalso will turn the sector into waste and increase the toxicity on the 
Xplanet.
X    Mining requires two fuel per update.
X~
XSpace Plow
X
X    This type of ship allows you to increase the fertility of sectors.
XOnce activated and given a move command (see the command 'order' for more 
Xhelp), a fully manned and undamaged plow will increase the 
Xfertility of each sector traversed by 10%. If it reaches the north or 
Xsouth of the planet map, it will bounce off and continue.
X    The Space Plow uses two fuel per update. Plowing can increase the 
Xtoxicity level on a planet.
X~
XDome
X
X    This ship can be used to increase sector efficiencies. At maximum crew 
Xthe efficiency an undamaged Dome can increase the efficiency by 5% per 
Xupdate. A Dome must be switched on to be effective. If a Dome is set to 
Xautoscrap (with the 'order' command), the Dome will be automatically 
Xscrapped upon reaching a sector efficiency of 100%.
X    A dome uses one resource per update.
X~
XWeapons Plant
X    
X    This installation produces destruct. Players feed the plant resources 
Xand fuel, and these are converted into destruct during each update. Each 
Xdestruct produced costs one fuel and one resource point. The maximum 
Xamount of destruct a fully manned and undamaged plant can produce in one 
Xupdate is given by the owner's current technology divided by two.
X    This ship is built with 75% damage. Construction must be completed 
Xmanually.
X~
XSpace Port
X
X    This represent a facility set up for merchant shipping. This is its sole 
Xfunction and therefore has little armor and no weapons. In order to buy 
Xor sell from a planet, you must have one of these, or a ship with port 
Xabilities in an undamaged state there. Other than the Space Port, the 
Xonly other ships available to conduct merchant transactions are: @, H, and S.
X    This ship is built with 75% damage. Construction must be completed 
Xmanually.
X~
XAnti-Ballistic Missile Battery
X
X    This unit represent a battery of guns which can be used to
Xattempt to down incoming alien missiles. If activated, each battery
Xwill fire at the predesignated salvo strength at each missile in orbit
Xaround the planet it is based upon during each update. The defensive fire 
Xis evaluated after missile movement, but before impact is evaluated. 
XABMs represent a last line of defense against missile attacks and are
Xexecuted automatically. The more batteries a planet has the more chance
Xof intercepting and incoming missile.
X    This ship is built with 50% damage. Construction must be completed 
Xmanually.
X~
XAFV
X
X    This machine is a land based Armored Fighting Vehicle. These type of 
Xships may fire on other ships if adjacent. The may also bombard adjacent 
Xsectors. AFVs may only attack other landed ships. AFVs can be moved using 
Xthe 'walk' command.
X~
XBunker
X
X    A heavily fortified position. Use it to store supplies and AFVs
Xin, as well as offering a haven for ships.
X    This ship is built with 50% damage. Construction must be completed 
Xmanually.
X~
XLander
X
X    A heavily armored planetary assault ship. This carries a large crew,
Xwith decent hanger space for transporting AFVs. With its heavy armor it
Xcan successfully survive planetary defense fire enough to establish a 
Xsignificantly large landing party on a planet. It also carries plenty of 
Xfirepower for bombarding runs. The Lander is quite slow, however.
X    This ship is built with 50% damage. Construction must be completed 
Xmanually.
X~
XMine Sweeper
X    
X    A medium armored and armed ship, capable of seeking out mines and
Xdestroying them before other ships come in contact with them. The Sweeper 
Xis not particularly fast. It is best used when loaded into a faster ship 
Xand sent out before exploring a unknown system.
X    This ship is built with 50% damage. Construction must be completed 
Xmanually.
X~
END_OF_FILE
if test 20432 -ne `wc -c <'misc/exam.dat'`; then
    echo shar: \"'misc/exam.dat'\" unpacked with wrong size!
fi
# end of 'misc/exam.dat'
fi
if test -f 'user/fire.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/fire.c'\"
else
echo shar: Extracting \"'user/fire.c'\" \(22307 characters\)
sed "s/^X//" >'user/fire.c' <<'END_OF_FILE'
X#ident  "@(#)fire.c	1.5 2/1/93 "
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * fire.c -- fire at ship or planet from ship or planet
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X#include <signal.h>
X
Xvoid            fire(int, int, int, int);
Xvoid            bombard(int, int, int);
Xvoid            defend(int, int, int);
Xvoid            detonate(int, int, int);
Xint             retal_strength(shiptype *);
Xint             adjacent(int, int, int, int, planettype *);
Xint             landed(shiptype *);
Xvoid            check_overload(shiptype *, int, int *);
Xvoid            check_retal_strength(shiptype *, int *);
Xint             laser_on(shiptype *);
X
X#include "proto.h"
X
Xvoid 
Xfire(int Playernum, int Governor, int APcount, int cew)
X{				/* ship vs ship */
X	int             fromship, toship, sh, nextshipno;
X	shiptype       *from, *to, *ship, dummy;
X	planettype     *p;
X	int             strength, maxstrength, retal, damage;
X
X	/* for telegramming and retaliating */
X	bzero((char *) Nuked, sizeof(Nuked));
X
X	if (argn < 3) {
X		notify(Playernum, Governor, "Syntax: 'fire <ship> <target> [<strength>]'.\n");
X		return;
X	}
X	nextshipno = start_shiplist(Playernum, Governor, args[1]);
X	while (fromship = do_shiplist(&from, &nextshipno))
X		if (in_list(Playernum, args[1], from, &nextshipno)
X		    && authorized(Governor, from)) {
X			if (!from->active) {
X				sprintf(buf, "%s is irradiated and inactive.\n", Ship(from));
X				notify(Playernum, Governor, buf);
X				free(from);
X				continue;
X			}
X			if (from->whatorbits == LEVEL_UNIV) {
X				if (!enufAP(Playernum, Governor, Sdata.AP[Playernum - 1], APcount)) {
X					free(from);
X					continue;
X				}
X			} else if (!enufAP(Playernum, Governor, Stars[from->storbits]->AP[Playernum - 1], APcount)) {
X				free(from);
X				continue;
X			}
X			if (cew) {
X				if (!from->cew) {
X					notify(Playernum, Governor, "That ship is not equipped to fire CEWs.\n");
X					free(from);
X					continue;
X				}
X				if (!from->mounted) {
X					notify(Playernum, Governor, "You need to have a crystal mounted to fire CEWs.\n");
X					free(from);
X					continue;
X				}
X			}
X			sscanf(args[2] + (args[2][0] == '#'), "%d", &toship);
X			if (toship <= 0) {
X				notify(Playernum, Governor, "Bad ship number.\n");
X				free(from);
X				continue;
X			}
X			if (toship == fromship) {
X				notify(Playernum, Governor, "Get real.\n");
X				free(from);
X				continue;
X			}
X			if (!getship(&to, toship)) {
X				free(from);
X				continue;
X			}
X			/* save defense attack strength for retaliation */
X			check_retal_strength(to, &retal);
X			bcopy(to, &dummy, sizeof(shiptype));
X
X			if (from->type == OTYPE_AFV) {
X				if (!landed(from)) {
X					sprintf(buf, "%s isn't landed on a planet!\n", Ship(from));
X					notify(Playernum, Governor, buf);
X					free(from);
X					free(to);
X					continue;
X				}
X				if (!landed(to)) {
X					sprintf(buf, "%s isn't landed on a planet!\n", Ship(from));
X					notify(Playernum, Governor, buf);
X					free(from);
X					free(to);
X					continue;
X				}
X			}
X			if (landed(from) && landed(to)) {
X				if ((from->storbits != to->storbits) ||
X				    (from->pnumorbits != to->pnumorbits)) {
X					notify(Playernum, Governor, "Landed ships can only attack other landed ships if they are on the same planet!\n");
X					free(from);
X					free(to);
X					continue;
X				}
X				getplanet(&p, (int) from->storbits, (int) from->pnumorbits);
X				if (!adjacent((int) from->land_x, (int) from->land_y,
X				   (int) to->land_x, (int) to->land_y, p)) {
X					notify(Playernum, Governor, "You are not adjacent to your target!\n");
X					free(from);
X					free(to);
X					free(p);
X					continue;
X				}
X				free(p);
X			}
X			if (cew) {
X				if (from->fuel < (double) from->cew) {
X					sprintf(buf, "You need %d fuel to fire CEWs.\n", from->cew);
X					notify(Playernum, Governor, buf);
X					free(from);
X					free(to);
X					continue;
X				} else if (landed(from) || landed(to)) {
X					notify(Playernum, Governor, "CEWs cannot originate from or targeted to ships landed on planets.\n");
X					free(from);
X					free(to);
X					continue;
X				} else {
X					sprintf(buf, "CEW strength %d.\n", from->cew);
X					notify(Playernum, Governor, buf);
X					strength = from->cew / 2;
X				}
X			} else {
X				check_retal_strength(from, &maxstrength);
X
X				if (argn >= 4)
X					sscanf(args[3], "%d", &strength);
X				else
X					check_retal_strength(from, &strength);
X
X				if (strength > maxstrength) {
X					strength = maxstrength;
X					sprintf(buf, "%s set to %d\n", laser_on(from) ?
X					"Laser strength" : "Guns", strength);
X					notify(Playernum, Governor, buf);
X				}
X			}
X
X			/* check to see if there is crystal overloads */
X			if (laser_on(from) || cew)
X				check_overload(from, cew, &strength);
X
X			if (strength <= 0) {
X				sprintf(buf, "No attack.\n");
X				notify(Playernum, Governor, buf);
X				putship(from);
X				free(from);
X				free(to);
X				continue;
X			}
X			damage = shoot_ship_to_ship(from, to, strength, cew, 0,
X						    long_buf, short_buf);
X
X			if (damage < 0) {
X				notify(Playernum, Governor, "Illegal attack.\n");
X				free(from);
X				free(to);
X				continue;
X			}
X			if (laser_on(from) || cew)
X				use_fuel(from, 2.0 * (double) strength);
X			else
X				use_destruct(from, strength);
X
X			if (!to->alive)
X				post(short_buf, COMBAT);
X			notify_star(Playernum, Governor, (int) to->owner,
X				    (int) from->storbits, short_buf);
X			warn((int) to->owner, (int) to->governor, long_buf);
X			notify(Playernum, Governor, long_buf);
X			/* defending ship retaliates */
X
X			strength = 0;
X			if (retal && damage && to->protect.self) {
X				strength = retal;
X				if (laser_on(to))
X					check_overload(to, 0, &strength);
X
X				if ((damage = shoot_ship_to_ship(&dummy, from, strength, 0, 1,
X					       long_buf, short_buf)) >= 0) {
X					if (laser_on(to))
X						use_fuel(to, 2.0 * (double) strength);
X					else
X						use_destruct(to, strength);
X					if (!from->alive)
X						post(short_buf, COMBAT);
X					notify_star(Playernum, Governor, (int) to->owner,
X					   (int) from->storbits, short_buf);
X					notify(Playernum, Governor, long_buf);
X					warn((int) to->owner, (int) to->governor, long_buf);
X				}
X			}
X			/*
X			 * protecting ships retaliate individually if damage
X			 * was inflicted
X			 */
X			/* AFVs immune to retaliation of this type */
X			if (damage && from->alive && from->type != OTYPE_AFV) {
X				if (to->whatorbits == LEVEL_STAR)	/* star level ships */
X					sh = Stars[to->storbits]->ships;
X				if (to->whatorbits == LEVEL_PLAN) {	/* planet level ships */
X					getplanet(&p, (int) to->storbits, (int) to->pnumorbits);
X					sh = p->ships;
X					free(p);
X				}
X				while (sh && from->alive) {
X					(void) getship(&ship, sh);
X					if (ship->protect.on && (ship->protect.ship == toship)
X					    && (ship->protect.ship == toship)
X					    && sh != fromship && sh != toship && ship->alive
X					    && ship->active) {
X						check_retal_strength(ship, &strength);
X						if (laser_on(ship))
X							check_overload(ship, 0, &strength);
X
X						if ((damage = shoot_ship_to_ship(ship, from, strength,
X										 0, 0, long_buf, short_buf)) >= 0) {
X							if (laser_on(ship))
X								use_fuel(ship, 2.0 * (double) strength);
X							else
X								use_destruct(ship, strength);
X							if (!from->alive)
X								post(short_buf, COMBAT);
X							notify_star(Playernum, Governor, (int) ship->owner,
X								    (int) from->storbits, short_buf);
X							notify(Playernum, Governor, long_buf);
X							warn((int) ship->owner, (int) ship->governor, long_buf);
X						}
X						putship(ship);
X					}
X					sh = ship->nextship;
X					free(ship);
X				}
X			}
X			putship(from);
X			putship(to);
X			deductAPs(Playernum, Governor, APcount, (int) from->storbits, 0);
X
X			free(from);
X			free(to);
X		} else
X			free(from);
X}
X
Xvoid 
Xbombard(int Playernum, int Governor, int APcount)
X{				/* ship vs planet */
X	int             fromship, nextshipno, sh;
X	shiptype       *from, *ship;
X	planettype     *p;
X	int             strength, maxstrength, x, y, ok, numdest, damage;
X	int             i;
X	racetype       *alien;
X
X	/* for telegramming and retaliating */
X	bzero((char *) Nuked, sizeof(Nuked));
X
X	if (argn < 2) {
X		notify(Playernum, Governor, "Syntax: 'bombard <ship> [<x,y> [<strength>]]'.\n");
X		return;
X	}
X	nextshipno = start_shiplist(Playernum, Governor, args[1]);
X	while (fromship = do_shiplist(&from, &nextshipno))
X		if (in_list(Playernum, args[1], from, &nextshipno) &&
X		    authorized(Governor, from)) {
X			if (!from->active) {
X				sprintf(buf, "%s is irradiated and inactive.\n", Ship(from));
X				notify(Playernum, Governor, buf);
X				free(from);
X				continue;
X			}
X			if (from->whatorbits != LEVEL_PLAN) {
X				notify(Playernum, Governor, "You must be in orbit around a planet to bombard.\n");
X				free(from);
X				continue;
X			} if (from->type == OTYPE_AFV && !landed(from)) {
X				notify(Playernum, Governor, "This ship is not landed on the planet.\n");
X				free(from);
X				continue;
X			} else if (!enufAP(Playernum, Governor, Stars[from->storbits]->AP[Playernum - 1], APcount)) {
X				free(from);
X				continue;
X			}
X			check_retal_strength(from, &maxstrength);
X
X			if (argn > 3)
X				sscanf(args[3], "%d", &strength);
X			else
X				check_retal_strength(from, &strength);
X
X			if (strength > maxstrength) {
X				strength = maxstrength;
X				sprintf(buf, "%s set to %d\n", laser_on(from) ?
X					"Laser strength" : "Guns", strength);
X				notify(Playernum, Governor, buf);
X			}
X			/* check to see if there is crystal overload */
X			if (laser_on(from))
X				check_overload(from, 0, &strength);
X
X			if (strength <= 0) {
X				sprintf(buf, "No attack.\n");
X				notify(Playernum, Governor, buf);
X				putship(from);
X				free(from);
X				continue;
X			}
X			/* get planet */
X			getplanet(&p, (int) from->storbits, (int) from->pnumorbits);
X
X			if (argn > 2) {
X				sscanf(args[2], "%d,%d", &x, &y);
X				if (x < 0 || x > p->Maxx - 1 || y < 0 || y > p->Maxy - 1) {
X					notify(Playernum, Governor, "Illegal sector.\n");
X					free(p);
X					free(from);
X					continue;
X				}
X			} else {
X				x = int_rand(0, (int) p->Maxx - 1);
X				y = int_rand(0, (int) p->Maxy - 1);
X			}
X			if (landed(from) &&
X			    !adjacent((int) from->land_x, (int) from->land_y, x, y, p)) {
X				notify(Playernum, Governor, "You are not adjacent to that sector.\n");
X				free(p);
X				free(from);
X				continue;
X			}
X			/*
X			 * check to see if there are any planetary defense
X			 * networks on the planet
X			 */
X			ok = 1;
X			sh = p->ships;
X			while (sh && ok) {
X				(void) getship(&ship, sh);
X				ok = !(ship->alive && ship->type == OTYPE_PLANDEF
X				       && ship->owner != Playernum);
X				sh = ship->nextship;
X				free(ship);
X			}
X
X			if (!ok && !landed(from)) {
X				notify(Playernum, Governor, "Target has planetary defense networks.\nThese have to be eliminated before you can attack sectors.\n");
X				free(p);
X				free(from);
X				continue;
X			}
X			numdest = shoot_ship_to_planet(from, p, strength, x, y, 1, 0, 0,
X						       long_buf, short_buf);
X
X			if (numdest < 0) {
X				notify(Playernum, Governor, "Illegal attack.\n");
X				free(from);
X				free(p);
X				continue;
X			}
X			if (laser_on(from))
X				use_fuel(from, 2.0 * (double) strength);
X			else
X				use_destruct(from, strength);
X
X			post(short_buf, COMBAT);
X			notify_star(Playernum, Governor, 0, (int) from->storbits, short_buf);
X			for (i = 1; i <= Num_races; i++)
X				if (Nuked[i - 1])
X					warn(i, Stars[from->storbits]->governor[i - 1], long_buf);
X			notify(Playernum, Governor, long_buf);
X
X#ifdef DEFENSE
X			/* planet retaliates - AFVs are immune to this */
X			if (numdest && from->type != OTYPE_AFV) {
X				damage = 0;
X				for (i = 1; i <= Num_races; i++)
X					if (Nuked[i - 1] && !p->slaved_to) {
X						/*
X						 * add planet defense
X						 * strength
X						 */
X						alien = races[i - 1];
X						strength = MIN(p->info[i - 1].destruct, p->info[i - 1].guns);
X
X						p->info[i - 1].destruct -= strength;
X
X						damage = shoot_planet_to_ship(alien, p, from, strength,
X						       long_buf, short_buf);
X						warn(i, (int) Stars[from->storbits]->governor[i - 1], long_buf);
X						notify(Playernum, Governor, long_buf);
X						if (!from->alive)
X							post(short_buf, COMBAT);
X						notify_star(Playernum, Governor, i,
X							    (int) from->storbits, short_buf);
X					}
X			}
X#endif
X
X			/*
X			 * protecting ships retaliate individually if damage
X			 * was inflicted
X			 */
X			/* AFVs are immune to this */
X			if (numdest && from->alive && from->type != OTYPE_AFV) {
X				sh = p->ships;
X				while (sh && from->alive) {
X					(void) getship(&ship, sh);
X
X					if (ship->protect.planet && sh != fromship && ship->alive
X					    && ship->active) {
X						if (laser_on(ship))
X							check_overload(ship, 0, &strength);
X
X						check_retal_strength(ship, &strength);
X
X						if ((damage = shoot_ship_to_ship(ship, from, strength, 0,
X										 0, long_buf, short_buf)) >= 0) {
X							if (laser_on(ship))
X								use_fuel(ship, 2.0 * (double) strength);
X							else
X								use_destruct(ship, strength);
X							if (!from->alive)
X								post(short_buf, COMBAT);
X							notify_star(Playernum, Governor, (int) ship->owner,
X								    (int) from->storbits, short_buf);
X							warn((int) ship->owner, (int) ship->governor, long_buf);
X							notify(Playernum, Governor, long_buf);
X						}
X						putship(ship);
X					}
X					sh = ship->nextship;
X					free(ship);
X				}
X			}
X			/* write the stuff to disk */
X			putship(from);
X			putplanet(p, (int) from->storbits, (int) from->pnumorbits);
X			deductAPs(Playernum, Governor, APcount, (int) from->storbits, 0);
X
X			free(from);
X			free(p);
X		} else
X			free(from);
X}
X
X#ifdef DEFENSE
Xvoid 
Xdefend(int Playernum, int Governor, int APcount)
X{				/* planet vs ship */
X	int             toship, sh;
X	shiptype       *to, *ship, dummy;
X	planettype     *p;
X	sectortype     *sect;
X	int             strength, retal, damage, x, y;
X	int             numdest;
X	racetype       *Race;
X
X	/* for telegramming and retaliating */
X	bzero((char *) Nuked, sizeof(Nuked));
X
X	/* get the planet from the players current scope */
X	if (Dir[Playernum - 1][Governor].level != LEVEL_PLAN) {
X		notify(Playernum, Governor, "You have to set scope to the planet first.\n");
X		return;
X	}
X	if (argn < 3) {
X		notify(Playernum, Governor, "Syntax: 'defend <ship> <sector> [<strength>]'.\n");
X		return;
X	}
X	if (Governor && Stars[Dir[Playernum - 1][Governor].snum]->governor[Playernum - 1] != Governor) {
X		notify(Playernum, Governor, "You are not authorized to do that in this system.\n");
X		return;
X	}
X	sscanf(args[1] + (args[1][0] == '#'), "%d", &toship);
X	if (toship <= 0) {
X		notify(Playernum, Governor, "Bad ship number.\n");
X		return;
X	}
X	if (!enufAP(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1], APcount)) {
X		return;
X	}
X	getplanet(&p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X
X	if (!p->info[Playernum - 1].numsectsowned) {
X		notify(Playernum, Governor, "You do not occupy any sectors here.\n");
X		free(p);
X		return;
X	}
X	if (p->slaved_to && p->slaved_to != Playernum) {
X		notify(Playernum, Governor, "This planet is enslaved.\n");
X		free(p);
X		return;
X	}
X	if (!getship(&to, toship)) {
X		free(p);
X		return;
X	}
X	if (to->whatorbits != LEVEL_PLAN) {
X		notify(Playernum, Governor, "The ship is not in planet orbit.\n");
X		free(to);
X		free(p);
X		return;
X	}
X	if (to->storbits != Dir[Playernum - 1][Governor].snum ||
X	    to->pnumorbits != Dir[Playernum - 1][Governor].pnum) {
X		notify(Playernum, Governor, "Target is not in orbit around this planet.\n");
X		free(to);
X		free(p);
X		return;
X	}
X	if (landed(to)) {
X		notify(Playernum, Governor, "Planet guns can't fire on landed ships.\n");
X		free(to);
X		free(p);
X		return;
X	}
X	/* save defense strength for retaliation */
X	check_retal_strength(to, &retal);
X	bcopy(to, &dummy, sizeof(shiptype));
X	if (argn >= 3)
X		sscanf(args[2], "%d,%d", &x, &y);
X
X	if (x < 0 || x > p->Maxx - 1 || y < 0 || y > p->Maxy - 1) {
X		notify(Playernum, Governor, "Illegal sector.\n");
X		free(p);
X		free(to);
X		return;
X	}
X	/* check to see if you own the sector */
X	getsector(&sect, p, x, y);
X	if (sect->owner != Playernum) {
X		notify(Playernum, Governor, "Nice try.\n");
X		free(sect);
X		free(p);
X		free(to);
X		return;
X	}
X	free(sect);
X
X	if (argn >= 4)
X		sscanf(args[3], "%d", &strength);
X	else
X		strength = p->info[Playernum - 1].guns;
X
X	strength = MIN(strength, p->info[Playernum - 1].destruct);
X	strength = MIN(strength, p->info[Playernum - 1].guns);
X
X	if (strength <= 0) {
X		sprintf(buf, "No attack - %d guns, %dd\n", p->info[Playernum - 1].guns,
X			p->info[Playernum - 1].destruct);
X		notify(Playernum, Governor, buf);
X		free(p);
X		free(to);
X		return;
X	}
X	Race = races[Playernum - 1];
X
X	damage = shoot_planet_to_ship(Race, p, to, strength, long_buf, short_buf);
X
X	if (!to->alive && to->type == OTYPE_TOXWC) {
X		/* get planet again since toxicity probably has changed */
X		free(p);
X		getplanet(&p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X	}
X	if (damage < 0) {
X		sprintf(buf, "Target out of range  %.2f!\n", SYSTEMSIZE);
X		notify(Playernum, Governor, buf);
X		free(p);
X		free(to);
X		return;
X	}
X	p->info[Playernum - 1].destruct -= strength;
X	if (!to->alive)
X		post(short_buf, COMBAT);
X	notify_star(Playernum, Governor, (int) to->owner,
X		    (int) to->storbits, short_buf);
X	warn((int) to->owner, (int) to->governor, long_buf);
X	notify(Playernum, Governor, long_buf);
X
X	/* defending ship retaliates */
X
X	strength = 0;
X	if (retal && damage && to->protect.self) {
X		strength = retal;
X		if (laser_on(to))
X			check_overload(to, 0, &strength);
X
X		if ((numdest = shoot_ship_to_planet(&dummy, p, strength, x, y, 1, 0, 0,
X					       long_buf, short_buf)) >= 0) {
X			if (laser_on(to))
X				use_fuel(to, 2.0 * (double) strength);
X			else
X				use_destruct(to, strength);
X
X			post(short_buf, COMBAT);
X			notify_star(Playernum, Governor, (int) to->owner,
X				    (int) to->storbits, short_buf);
X			notify(Playernum, Governor, long_buf);
X			warn((int) to->owner, (int) to->governor, long_buf);
X		}
X	}
X	/* protecting ships retaliate individually if damage was inflicted */
X	if (damage) {
X		sh = p->ships;
X		while (sh) {
X			(void) getship(&ship, sh);
X			if (ship->protect.on && (ship->protect.ship == toship)
X			    && (ship->protect.ship == toship)
X			    && sh != toship && ship->alive && ship->active) {
X				if (laser_on(ship))
X					check_overload(ship, 0, &strength);
X				check_retal_strength(ship, &strength);
X
X				if ((numdest = shoot_ship_to_planet(ship, p, strength,
X							      x, y, 1, 0, 0,
X					       long_buf, short_buf)) >= 0) {
X
X					if (laser_on(ship))
X						use_fuel(ship, 2.0 * (double) strength);
X					else
X						use_destruct(ship, strength);
X					post(short_buf, COMBAT);
X					notify_star(Playernum, Governor, (int) ship->owner,
X					   (int) ship->storbits, short_buf);
X					notify(Playernum, Governor, long_buf);
X					warn((int) ship->owner, (int) ship->governor, long_buf);
X				}
X				putship(ship);
X			}
X			sh = ship->nextship;
X			free(ship);
X		}
X	}
X	/* write the ship stuff out to disk */
X	putship(to);
X	putplanet(p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X
X	deductAPs(Playernum, Governor, APcount, Dir[Playernum - 1][Governor].snum, 0);
X
X	free(p);
X	free(to);
X	return;
X}
X#endif
X
X
Xvoid 
Xdetonate(int Playernum, int Governor, int APcount)
X{
X	shiptype       *s;
X	int             shipno, nextshipno;
X
X	nextshipno = start_shiplist(Playernum, Governor, args[1]);
X
X	while (shipno = do_shiplist(&s, &nextshipno))
X		if (in_list(Playernum, args[1], s, &nextshipno) &&
X		    authorized(Governor, s)) {
X			if (s->type != STYPE_MINE) {
X				notify(Playernum, Governor, "That is not a mine.\n");
X				free(s);
X				continue;
X			} else if (!s->on) {
X				notify(Playernum, Governor, "The mine is not activated.\n");
X				free(s);
X				continue;
X			} else if (s->docked || s->whatorbits == LEVEL_SHIP) {
X				notify(Playernum, Governor, "The mine is docked or landed.\n");
X				free(s);
X				continue;
X			}
X			free(s);
X			domine(shipno, 1);
X		} else
X			free(s);
X}
X
Xint 
Xretal_strength(shiptype * s)
X{
X	int             strength = 0, avail = 0;
X
X	if (!s->alive)
X		return 0;
X	if (!Shipdata[s->type][ABIL_SPEED] && !landed(s))
X		return 0;
X	/* land based ships */
X	if (!s->popn)
X		return 0;
X
X	if (s->guns == PRIMARY)
X		avail = (s->type == STYPE_FIGHTER || s->type == OTYPE_AFV) ?
X			s->primary : MIN(s->popn, s->primary);
X	else if (s->guns == SECONDARY)
X		avail = (s->type == STYPE_FIGHTER || s->type == OTYPE_AFV) ?
X			s->secondary : MIN(s->popn, s->secondary);
X	else
X		avail = 0;
X
X	avail = MIN(s->retaliate, avail);
X	strength = MIN(s->destruct, avail);
X	return strength;
X}
X
Xint 
Xadjacent(int fx, int fy, int tx, int ty, planettype * p)
X{
X	if (abs(fy - ty) <= 1) {
X		if (abs(fx - tx) <= 1)
X			return 1;
X		else if (fx == p->Maxx - 1 && tx == 0)
X			return 1;
X		else if (fx == 0 && tx == p->Maxx - 1)
X			return 1;
X		else
X			return 0;
X	} else
X		return 0;
X}
X
Xint 
Xlanded(shiptype * ship)
X{
X	return (ship->whatdest == LEVEL_PLAN && ship->docked);
X}
X
Xvoid 
Xcheck_overload(shiptype * ship, int cew, int *strength)
X{
X	if ((ship->laser && ship->fire_laser) || cew) {
X		if (int_rand(0, *strength) > (int) ((1.0 - .01 * ship->damage) * ship->tech / 2.0)) {
X			/* check to see if the ship blows up */
X			sprintf(buf,
X				"%s: Matter-antimatter EXPLOSION from overloaded crystal on %s\n",
X				Dispshiploc(ship), Ship(ship));
X			kill_ship((int) (ship->owner), ship);
X			*strength = 0;
X			warn((int) ship->owner, (int) ship->governor, buf);
X			post(buf, COMBAT);
X			notify_star((int) ship->owner, (int) ship->governor,
X				    0, (int) ship->storbits, buf);
X		} else if (int_rand(0, *strength) >
X		    (int) ((1.0 - .01 * ship->damage) * ship->tech / 4.0)) {
X			sprintf(buf, "%s: Crystal damaged from overloading on %s.\n",
X				Dispshiploc(ship), Ship(ship));
X			ship->fire_laser = 0;
X			ship->mounted = 0;
X			*strength = 0;
X			warn((int) ship->owner, (int) ship->governor, buf);
X		}
X	}
X}
X
Xvoid 
Xcheck_retal_strength(shiptype * ship, int *strength)
X{
X	*strength = 0;
X	if (ship->active && ship->alive) {	/* irradiated ships dont
X						 * retaliate */
X		if (laser_on(ship))
X			*strength = MIN(ship->fire_laser, (int) ship->fuel / 2);
X		else
X			*strength = retal_strength(ship);
X	}
X}
X
Xint 
Xlaser_on(shiptype * ship)
X{
X	return (ship->laser && ship->fire_laser);
X}
END_OF_FILE
if test 22307 -ne `wc -c <'user/fire.c'`; then
    echo shar: \"'user/fire.c'\" unpacked with wrong size!
fi
# end of 'user/fire.c'
fi
if test -f 'user/power.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/power.c'\"
else
echo shar: Extracting \"'user/power.c'\" \(8302 characters\)
sed "s/^X//" >'user/power.c' <<'END_OF_FILE'
X#ident  "@(#)power.c	1.5 2/1/93 "
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * Galactic Bloodshed (Robert Chansky, smq@ucscb.ucsc.edu) power.c -- display
X * power report
X */
X
X#include <errno.h>
X#include <time.h>
X#include <strings.h>
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X
Xextern int      errno;
Xextern struct tm *update_tm;
X
Xvoid            block(int, int, int);
Xvoid            power(int, int, int);
Xvoid            prepare_output_line(racetype *, racetype *, int, int);
X#include "proto.h"
X
Xvoid 
Xblock(int Playernum, int Governor, int APcount)
X{
X	register int    i, n;
X	int             p;
X	racetype       *r, *Race;
X	int             dummy_, dummy[2];
X
X	n = Num_races;
X
X	Race = races[Playernum - 1];
X
X	if (argn == 3 && match(args[1], "player")) {
X		if (!(p = GetPlayer(args[2]))) {
X			notify(Playernum, Governor, "No such player.\n");
X			return;
X		}
X		r = races[p - 1];
X		dummy_ = 0;	/* Used as flag for finding a block */
X		sprintf(buf, "Race #%d [%s] is a member of ", p, r->name);
X		notify(Playernum, Governor, buf);
X		for (i = 1; i <= n; i++) {
X			if (isset(Blocks[i - 1].pledge, p) && isset(Blocks[i - 1].invite, p)) {
X				sprintf(buf, "%s%d", (dummy_ == 0) ? " " : ", ", i);
X				notify(Playernum, Governor, buf);
X				dummy_ = 1;
X			}
X		}
X		if (dummy_ == 0)
X			notify(Playernum, Governor, "no blocks\n");
X		else
X			notify(Playernum, Governor, "\n");
X
X		dummy_ = 0;	/* Used as flag for finding a block */
X		sprintf(buf, "Race #%d [%s] has been invited to join ", p, r->name);
X		notify(Playernum, Governor, buf);
X		for (i = 1; i <= n; i++) {
X			if (!isset(Blocks[i - 1].pledge, p) && isset(Blocks[i - 1].invite, p)) {
X				sprintf(buf, "%s%d", (dummy_ == 0) ? " " : ", ", i);
X				notify(Playernum, Governor, buf);
X				dummy_ = 1;
X			}
X		}
X		if (dummy_ == 0)
X			notify(Playernum, Governor, "no blocks\n");
X		else
X			notify(Playernum, Governor, "\n");
X
X		dummy_ = 0;	/* Used as flag for finding a block */
X		sprintf(buf, "Race #%d [%s] has pledged ", p, r->name);
X		notify(Playernum, Governor, buf);
X		for (i = 1; i <= n; i++) {
X			if (isset(Blocks[i - 1].pledge, p) && !isset(Blocks[i - 1].invite, p)) {
X				sprintf(buf, "%s%d", (dummy_ == 0) ? " " : ", ", i);
X				notify(Playernum, Governor, buf);
X				dummy_ = 1;
X			}
X		}
X		if (!dummy_)
X			notify(Playernum, Governor, "no blocks\n");
X		else
X			notify(Playernum, Governor, "\n");
X	} else if (argn > 1) {
X		if (!(p = GetPlayer(args[1]))) {
X			notify(Playernum, Governor, "No such player,\n");
X			return;
X		}
X		r = races[p - 1];
X		/* list the players who are in this alliance block */
X		dummy[0] = (Blocks[p - 1].invite[0] & Blocks[p - 1].pledge[0]);
X		dummy[1] = (Blocks[p - 1].invite[1] & Blocks[p - 1].pledge[1]);
X		sprintf(buf, "         ========== %s Power Report ==========\n",
X			Blocks[p - 1].name);
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "         	       %-64.64s\n",
X			Blocks[p - 1].motto);
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "  #  Name              troops  pop  money ship  plan  res fuel dest know\n");
X		notify(Playernum, Governor, buf);
X
X		for (i = 1; i <= n; i++)
X			if (isset(dummy, i)) {
X				r = races[i - 1];
X				if (!r->dissolved) {
X					sprintf(buf, "%2d %-20.20s ", i, r->name);
X					sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].troops, Race, i));
X					strcat(buf, temp);
X					sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].popn, Race, i));
X					strcat(buf, temp);
X					sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].money, Race, i));
X					strcat(buf, temp);
X					sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].ships_owned, Race, i));
X					strcat(buf, temp);
X					sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].planets_owned, Race, i));
X					strcat(buf, temp);
X					sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].resource, Race, i));
X					strcat(buf, temp);
X					sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].fuel, Race, i));
X					strcat(buf, temp);
X					sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].destruct, Race, i));
X					strcat(buf, temp);
X					sprintf(temp, " %3d%%\n", Race->translate[i - 1]);
X					strcat(buf, temp);
X					notify(Playernum, Governor, buf);
X				}
X			}
X	} else {		/* list power report for all the alliance
X				 * blocks (as of the last update) */
X		sprintf(buf, "         ========== Alliance Blocks as of %s ==========\n",
X			Power_blocks.time);
X		notify(Playernum, Governor, buf);
X		sprintf(buf, " #  Name             memb money popn ship  sys  res fuel dest  VPs know\n");
X		notify(Playernum, Governor, buf);
X		for (i = 1; i <= n; i++)
X			if (Blocks[i - 1].VPs) {
X				sprintf(buf, "%2d %-19.19s%3d", i, Blocks[i - 1].name, Power_blocks.members[i - 1]);
X				sprintf(temp, "%5s", Estimate_i((int) (Power_blocks.money[i - 1]), Race, i));
X				strcat(buf, temp);
X				sprintf(temp, "%5s", Estimate_i((int) (Power_blocks.popn[i - 1]), Race, i));
X				strcat(buf, temp);
X				sprintf(temp, "%5s", Estimate_i((int) (Power_blocks.ships_owned[i - 1]), Race, i));
X				strcat(buf, temp);
X				sprintf(temp, "%5s", Estimate_i((int) (Power_blocks.systems_owned[i - 1]), Race, i));
X				strcat(buf, temp);
X				sprintf(temp, "%5s", Estimate_i((int) (Power_blocks.resource[i - 1]), Race, i));
X				strcat(buf, temp);
X				sprintf(temp, "%5s", Estimate_i((int) (Power_blocks.fuel[i - 1]), Race, i));
X				strcat(buf, temp);
X				sprintf(temp, "%5s", Estimate_i((int) (Power_blocks.destruct[i - 1]), Race, i));
X				strcat(buf, temp);
X				sprintf(temp, "%5s", Estimate_i((int) (Power_blocks.VPs[i - 1]), Race, i));
X				strcat(buf, temp);
X				sprintf(temp, " %3d%%\n", Race->translate[i - 1]);
X				strcat(buf, temp);
X				notify(Playernum, Governor, buf);
X			}
X	}
X}
X
Xvoid 
Xpower(int Playernum, int Governor, int APcount)
X{
X	register int    i, n;
X	int             p;
X	racetype       *r, *Race;
X	struct vic      vic[MAXPLAYERS];
X
X	n = Num_races;
X	p = -1;
X
X	if (argn >= 2) {
X		if (!(p = GetPlayer(args[1]))) {
X			notify(Playernum, Governor, "No such player,\n");
X			return;
X		}
X		r = races[p - 1];
X	}
X	Race = races[Playernum - 1];
X
X	sprintf(buf, "         ========== Galactic Bloodshed Power Report ==========\n");
X	notify(Playernum, Governor, buf);
X
X	if (Race->God)
X		sprintf(buf, "%s  #  Name               VP  mil  civ cash ship pl  res fuel dest morl\n", argn < 2 ? "rank" : "");
X	else
X		sprintf(buf, "%s  #  Name               VP  mil  civ cash ship pl  res fuel dest morl know\n", argn < 2 ? "rank" : "");
X	notify(Playernum, Governor, buf);
X
X	if (argn < 2) {
X		create_victory_list(vic);
X		for (i = 1; i <= n; i++) {
X			p = vic[i - 1].racenum;
X			r = races[p - 1];
X			if (!r->dissolved && Race->translate[p - 1] >= 10) {
X				prepare_output_line(Race, r, p, i);
X				notify(Playernum, Governor, buf);
X			}
X		}
X	} else {
X		r = races[p - 1];
X		prepare_output_line(Race, r, p, 0);
X		notify(Playernum, Governor, buf);
X	}
X}
X
Xvoid 
Xprepare_output_line(racetype * Race, racetype * r, int i, int rank)
X{
X	if (rank)
X		sprintf(buf, "%2d ", rank);
X	else
X		sprintf(buf, "");
X	sprintf(temp, "[%2d]%s%s%-15.15s %5s", i,
X		isset(Race->allied, i) ? "+" :
X		(isset(Race->atwar, i) ? "-" : " "),
X		isset(r->allied, Race->Playernum) ? "+" :
X		(isset(r->atwar, Race->Playernum) ? "-" : " "),
X		r->name, Estimate_i((int) r->victory_score, Race, i));
X	strcat(buf, temp);
X	sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].troops, Race, i));
X	strcat(buf, temp);
X	sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].popn, Race, i));
X	strcat(buf, temp);
X	sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].money, Race, i));
X	strcat(buf, temp);
X	sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].ships_owned, Race, i));
X	strcat(buf, temp);
X	sprintf(temp, "%3s", Estimate_i((int) Power[i - 1].planets_owned, Race, i));
X	strcat(buf, temp);
X	sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].resource, Race, i));
X	strcat(buf, temp);
X	sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].fuel, Race, i));
X	strcat(buf, temp);
X	sprintf(temp, "%5s", Estimate_i((int) Power[i - 1].destruct, Race, i));
X	strcat(buf, temp);
X	sprintf(temp, "%5s", Estimate_i((int) r->morale, Race, i));
X	strcat(buf, temp);
X	sprintf(temp, " %3d%%\n", Race->translate[i - 1]);
X	strcat(buf, temp);
X}
END_OF_FILE
if test 8302 -ne `wc -c <'user/power.c'`; then
    echo shar: \"'user/power.c'\" unpacked with wrong size!
fi
# end of 'user/power.c'
fi
echo shar: End of archive 11 \(of 21\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
