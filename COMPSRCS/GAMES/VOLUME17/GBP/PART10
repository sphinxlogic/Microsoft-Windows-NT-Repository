Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i022:  gbp - Galactic Bloodshed+, an empire-like war game, Part10/21
Message-ID: <4550@master.CNA.TEK.COM>
Date: 12 Feb 93 17:31:20 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1841
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1701

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 22
Archive-name: gbp/Part10
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 10 (of 21)."
# Contents:  server/doship.c server/doturn.c user/mobiliz.c
# Wrapped by billr@saab on Fri Feb 12 09:14:26 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'server/doship.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/doship.c'\"
else
echo shar: Extracting \"'server/doship.c'\" \(24721 characters\)
sed "s/^X//" >'server/doship.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h. doship -- do one ship turn.
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "doturn.h"
X#include "power.h"
X#include "buffers.h"
X#include <math.h>
X#include <strings.h>
X
Xextern long     Shipdata[NUMSTYPES][NUMABILS];
X
Xvoid            doship(shiptype *, int);
Xvoid            domass(shiptype *);
Xvoid            doown(shiptype *);
Xvoid            domissile(shiptype *);
Xvoid            domine(int, int);
Xvoid            doabm(shiptype *);
Xvoid            do_repair(shiptype *);
Xvoid            do_habitat(shiptype *);
Xvoid            do_pod(shiptype *);
Xint             infect_planet(int, int, int);
Xvoid            do_meta_infect(int, planettype *);
Xvoid            do_canister(shiptype *);
Xvoid            do_greenhouse(shiptype *);
Xvoid            do_mirror(shiptype *);
Xvoid            do_god(shiptype *);
Xvoid            do_ap(shiptype *);
Xdouble          crew_factor(shiptype *);
Xdouble          ap_planet_factor(planettype *);
Xvoid            do_oap(shiptype *);
Xint             do_weapon_plant(shiptype *);
X#include "proto.h"
X
Xvoid
Xdoship(shiptype * ship, int update)
X{
X	racetype       *Race;
X	shiptype       *ship2;
X
X	/* ship is active */
X	ship->active = 1;
X
X	if (!ship->owner)
X		ship->alive = 0;
X
X	if (ship->alive) {
X		/* repair radiation */
X		if (ship->rad) {
X			ship->active = 1;
X			/* irradiated ships are immobile.. */
X			/* kill off some people */
X			/* check to see if ship is active */
X			if (success(ship->rad))
X				ship->active = 0;
X			if (update) {
X				ship->popn = round_rand(ship->popn * .80);
X				ship->troops = round_rand(ship->troops * .80);
X				if (ship->rad >= (int) REPAIR_RATE)
X					ship->rad -= int_rand(0, (int) REPAIR_RATE);
X				else
X					ship->rad -= int_rand(0, (int) ship->rad);
X			}
X		} else
X			ship->active = 1;
X
X		if (!ship->popn && Max_crew(ship) && !ship->docked)
X			ship->whatdest = LEVEL_UNIV;
X
X		if (ship->whatorbits != LEVEL_UNIV
X		    && Stars[ship->storbits]->nova_stage > 0) {
X			/* damage ships from supernovae */
X			/*
X			 * Maarten: modified to take into account
X			 * MOVES_PER_UPDATE
X			 */
X			ship->damage += 5 * Stars[ship->storbits]->nova_stage /
X				((Armor(ship) + 1) * segments);
X			if (ship->damage >= 100) {
X				kill_ship((int) (ship->owner), ship);
X				return;
X			}
X		}
X		if (ship->type == OTYPE_FACTORY && !ship->on) {
X			Race = races[ship->owner - 1];
X			ship->tech = Race->tech;
X		}
X		if (ship->active)
X			Moveship(ship, update, 1, 0);
X
X		ship->size = ship_size(ship);	/* for debugging */
X
X		if (ship->whatorbits == LEVEL_SHIP) {
X			(void) getship(&ship2, (int) ship->destshipno);
X			if (ship2->owner != ship->owner) {
X				ship2->owner = ship->owner;
X				ship2->governor = ship->governor;
X				putship(ship2);
X			}
X			free(ship2);
X			/* just making sure */
X		} else if (ship->whatorbits != LEVEL_UNIV &&
X			   (ship->popn || ship->type == OTYPE_PROBE)) {
X			/*
X			 * Though I have often used TWCs for exploring, I
X			 * don't think it is right
X			 */
X			/*
X			 * to be able to map out worlds with this type of
X			 * junk. Either a manned ship,
X			 */
X			/*
X			 * or a probe, which is designed for this kind of
X			 * work.  Maarten
X			 */
X			StarsInhab[ship->storbits] = 1;
X			setbit(Stars[ship->storbits]->inhabited, ship->owner);
X			setbit(Stars[ship->storbits]->explored, ship->owner);
X			if (ship->whatorbits == LEVEL_PLAN) {
X				planets[ship->storbits][ship->pnumorbits]->info[ship->owner - 1].explored = 1;
X			}
X		}
X		/* add ships, popn to total count to add AP's */
X		if (update) {
X			Power[ship->owner - 1].ships_owned++;
X			Power[ship->owner - 1].resource += ship->resource;
X			Power[ship->owner - 1].fuel += ship->fuel;
X			Power[ship->owner - 1].destruct += ship->destruct;
X			Power[ship->owner - 1].popn += ship->popn;
X			Power[ship->owner - 1].troops += ship->troops;
X		}
X		if (ship->whatorbits == LEVEL_UNIV) {
X			Sdatanumships[ship->owner - 1]++;
X			Sdatapopns[ship->owner] += ship->popn;
X		} else {
X			starnumships[ship->storbits][ship->owner - 1]++;
X			/* add popn of ships to popn */
X			starpopns[ship->storbits][ship->owner - 1] += ship->popn;
X			/* set inhabited for ship */
X			/* only if manned or probe.  Maarten */
X			if (ship->popn || ship->type == OTYPE_PROBE) {
X				StarsInhab[ship->storbits] = 1;
X				setbit(Stars[ship->storbits]->inhabited, ship->owner);
X				setbit(Stars[ship->storbits]->explored, ship->owner);
X			}
X		}
X
X		if (ship->active) {
X			/* bombard the planet */
X			if (can_bombard(ship) && ship->bombard
X			    && ship->whatorbits == LEVEL_PLAN
X			    && ship->whatdest == LEVEL_PLAN
X			    && ship->deststar == ship->storbits
X			    && ship->destpnum == ship->pnumorbits) {
X				/* ship bombards planet */
X				Stinfo[ship->storbits][ship->pnumorbits].inhab = 1;
X			}
X			/* repair ship by the amount of crew it has */
X			/*
X			 * industrial complexes can repair (robot ships and
X			 * offline factories can't repair)
X			 */
X			if (ship->damage && Repair(ship))
X				do_repair(ship);
X
X			if (update)
X				switch (ship->type) {	/* do this stuff during
X							 * updates only */
X				case OTYPE_CANIST:
X					do_canister(ship);
X					break;
X				case OTYPE_GREEN:
X					do_greenhouse(ship);
X					break;
X				case STYPE_MIRROR:
X					do_mirror(ship);
X					break;
X				case OTYPE_AP:
X					do_ap(ship);
X					break;
X				case STYPE_OAP:
X					do_oap(ship);
X					break;
X				case STYPE_HABITAT:
X					do_habitat(ship);
X					break;
X				default:
X					break;
X				}
X			if (ship->type == STYPE_POD)
X				do_pod(ship);
X		}
X	}
X}
X
Xvoid
Xdomass(shiptype * ship)
X{
X	double          rmass;
X	int             sh;
X
X	rmass = races[ship->owner - 1]->mass;
X
X	sh = ship->ships;
X	ship->mass = 0.0;
X	ship->hanger = 0;
X	while (sh) {
X		domass(ships[sh]);	/* recursive call */
X		ship->mass += ships[sh]->mass;
X		ship->hanger += ships[sh]->size;
X		sh = ships[sh]->nextship;
X	}
X	ship->mass += getmass(ship);
X	ship->mass += (double) (ship->popn + ship->troops) * rmass;
X	ship->mass += (double) ship->destruct * MASS_DESTRUCT;
X	ship->mass += ship->fuel * MASS_FUEL;
X	ship->mass += (double) ship->resource * MASS_RESOURCE;
X}
X
Xvoid
Xdoown(shiptype * ship)
X{
X	int             sh;
X	sh = ship->ships;
X	while (sh) {
X		doown(ships[sh]);	/* recursive call */
X		ships[sh]->owner = ship->owner;
X		ships[sh]->governor = ship->governor;
X		sh = ships[sh]->nextship;
X	}
X}
X
Xvoid
Xdomissile(shiptype * ship)
X{
X	int             sh2;
X	int             bombx, bomby, numdest, pdn, i;
X	planettype     *p;
X	double          dist;
X	placetype       where;
X
X	if (!ship->alive || !ship->owner)
X		return;
X	if (!ship->on || ship->docked)
X		return;
X
X	/* check to see if it has arrived at it's destination */
X	if (ship->whatdest == LEVEL_PLAN && ship->whatorbits == LEVEL_PLAN &&
X	    ship->destpnum == ship->pnumorbits) {
X		p = planets[ship->storbits][ship->pnumorbits];
X		/* check to see if PDNs are present */
X		pdn = 0;
X		sh2 = p->ships;
X		while (sh2 && !pdn) {
X			if (ships[sh2]->alive && ships[sh2]->type == OTYPE_PLANDEF) {
X				/* attack the PDN instead */
X				ship->whatdest = LEVEL_SHIP;	/* move missile to PDN
X								 * for attack */
X				ship->xpos = ships[sh2]->xpos;
X				ship->ypos = ships[sh2]->ypos;
X				ship->destshipno = sh2;
X				pdn = sh2;
X			}
X			sh2 = ships[sh2]->nextship;
X		}
X		if (!pdn) {
X			if (ship->special.impact.scatter) {
X				bombx = int_rand(1, (int) p->Maxx) - 1;
X				bomby = int_rand(1, (int) p->Maxy) - 1;
X			} else {
X				bombx = ship->special.impact.x % p->Maxx;
X				bomby = ship->special.impact.y % p->Maxy;
X			}
X			sprintf(buf, "%s dropped on sector %d,%d at planet %s.\n",
X			  Ship(ship), bombx, bomby, prin_ship_orbits(ship));
X			where.level = LEVEL_PLAN;
X			where.snum = ship->storbits;
X			where.pnum = ship->pnumorbits;
X
X			numdest = shoot_ship_to_planet(ship, p, (int) ship->destruct,
X						  bombx, bomby, 1, 0, HEAVY,
X						       long_buf, short_buf);
X			push_telegram((int) ship->owner, (int) ship->governor, long_buf);
X			kill_ship((int) ship->owner, ship);
X			sprintf(buf, "%s dropped on %s.\n\t%d sectors destroyed.\n",
X				Ship(ship), prin_ship_orbits(ship), numdest);
X			for (i = 1; i <= Num_races; i++)
X				if (p->info[i - 1].numsectsowned && i != ship->owner)
X					push_telegram(i, Stars[ship->storbits]->governor[i - 1], buf);
X			if (numdest) {
X				sprintf(buf, "%s dropped on %s.\n", Ship(ship),
X					prin_ship_orbits(ship));
X				post(buf, COMBAT);
X			}
X		}
X	} else if (ship->whatdest == LEVEL_SHIP) {
X		sh2 = ship->destshipno;
X		dist = sqrt(Distsq(ship->xpos, ship->ypos,
X				   ships[sh2]->xpos, ships[sh2]->ypos));
X		if (dist <= ((double) ship->speed * STRIKE_DISTANCE_FACTOR
X			     * (100.0 - (double) ship->damage) / 100.0)) {
X			/* do the attack */
X			(void) shoot_ship_to_ship(ship, ships[sh2], (int) ship->destruct, 0, 0,
X						  long_buf, short_buf);
X			push_telegram((int) ship->owner, (int) ship->governor, long_buf);
X			push_telegram((int) ships[sh2]->owner, (int) ships[sh2]->governor,
X				      long_buf);
X			kill_ship((int) ship->owner, ship);
X			post(short_buf, COMBAT);
X		}
X	}
X}
X
Xvoid
Xdomine(int shipno, int detonate)
X{
X	int             sh, sh2, i;
X	shiptype       *s, *ship;
X	planettype     *planet;
X	racetype       *r;
X
X	(void) getship(&ship, shipno);
X
X	if (ship->type != STYPE_MINE || !ship->alive || !ship->owner) {
X		free(ship);
X		return;
X	}
X	/* check around and see if we should explode. */
X	if (ship->on || detonate) {
X		int             rad = 0;
X		double          xd, yd, range;
X
X		switch (ship->whatorbits) {
X		case LEVEL_STAR:
X			sh = Stars[ship->storbits]->ships;
X			break;
X		case LEVEL_PLAN:
X			getplanet(&planet, (int) ship->storbits, (int) ship->pnumorbits);
X			sh = planet->ships;
X			free(planet);
X			break;
X		default:
X			free(ship);
X			return;
X		}
X		sh2 = sh;
X		/*
X		 * traverse the list, look for ships that are closer than the
X		 * trigger radius...
X		 */
X		rad = 0;
X		if (!detonate) {
X			r = races[ship->owner - 1];
X			while (sh && !rad) {
X				(void) getship(&s, sh);
X				xd = s->xpos - ship->xpos;
X				yd = s->ypos - ship->ypos;
X				range = sqrt(xd * xd + yd * yd);
X				if (!isset(r->allied, s->owner) && (s->owner != ship->owner) &&
X				    ((int) range <= ship->special.trigger.radius))
X					rad = 1;
X				else
X					sh = s->nextship;
X				free(s);
X			}
X		} else
X			rad = 1;
X
X		if (rad) {
X			int             rez;	/* result from shoot */
X			sh = sh2;
X			while (sh && ship->alive) {
X				getship(&s, sh);
X				if ((s->type == STYPE_SWEEPER) && (sh != shipno) && s->alive) {
X					int             amount_to_use;
X					int             chance_to_see;
X					int             roll;
X
X					chance_to_see = (int) (5 + (2 * (sqrt(s->tech))));
X					if (s->guns == PRIMARY)
X						amount_to_use = MIN(s->popn, s->primary);
X					else
X						amount_to_use = MIN(s->popn, s->secondary);
X					roll = int_rand(1, 100);
X					sprintf(buf, "Mine exploding: Minesweeper detect chance %d/%d \n",
X						chance_to_see, roll);
X					warn((int)s->owner, (int)s->governor, buf);
X					if (roll <= chance_to_see) {
X						rez = shoot_ship_to_ship(s, ship, amount_to_use, 0, 0,
X						       long_buf, short_buf);
X						warn_star(s->owner, ship->owner, (int) s->storbits, short_buf);
X						warn((int)s->owner, (int)s->governor, long_buf);
X						warn((int)ship->owner, (int)ship->governor, long_buf);
X						use_destruct(s, amount_to_use);
X						putship(s);
X					}	/* chance_to_see */
X				}
X					sh = s->nextship;
X					free(s);
X			}
X		}
X
X		if (ship->alive) {
X			if (rad) {
X	     sprintf(buf, "Mine %s detonated at %s\n", Ship(ship), 
X			prin_ship_orbits(ship));
X		 post(buf, COMBAT);
X		 warn((int)ship->owner, (int)ship->governor, buf);
X		 notify_star((int)ship->owner, (int)ship->governor, 0,
X             (int)ship->storbits, buf);
X
X			/* kill off the ships nearby */
X
X			sh = sh2;
X			while (sh) {
X				getship(&s, sh);
X				if (sh != shipno && s->alive &&
X				   (s->type != OTYPE_CANIST) && (s->type != OTYPE_GREEN)
X					&& (s->owner != ship->owner)) {
X					rad = shoot_ship_to_ship(ship, s, (int)(ship->destruct), 
X						0, 0, long_buf, short_buf);
X					if (rad > 0) {
X						post(short_buf, COMBAT);	
X						warn((int)s->owner, (int)s->governor, long_buf);
X						warn((int)ship->owner, (int)ship->governor, long_buf);
X						putship(s);
X					}
X				}
X			  sh = s->nextship;
X			  free(s);
X			}
X			/*
X			 * if the mine is in orbit around a planet, nuke the
X			 * planet too!
X			 */
X			if (ship->whatorbits == LEVEL_PLAN) {
X				/* pick a random sector to nuke */
X				reg int         x, y, numdest;
X				getplanet(&planet, (int) ship->storbits, (int) ship->pnumorbits);
X				if (landed(ship)) {
X					x = ship->land_x;
X					y = ship->land_y;
X				} else {
X					x = int_rand(0, (int) planet->Maxx - 1);
X					y = int_rand(0, (int) planet->Maxy - 1);
X				}
X				numdest = shoot_ship_to_planet(ship, planet,
X				  (int) (ship->destruct), x, y, 1, 0, LIGHT,
X						       long_buf, short_buf);
X				putplanet(planet, (int) ship->storbits, (int) ship->pnumorbits);
X				
X				post(short_buf, COMBAT);	
X				warn((int)s->owner, (int)s->governor, long_buf);
X
X				sprintf(telegram_buf, "%s", buf);
X				if (numdest > 0) {
X					sprintf(buf, " - %d sectors destroyed.", numdest);
X					strcat(telegram_buf, buf);
X				}
X				strcat(telegram_buf, "\n");
X				for (i = 1; i <= Num_races; i++)
X					if (Nuked[i - 1])
X						warn(i, (int) Stars[ship->storbits]->governor[i - 1],
X						     telegram_buf);
X				notify((int) (ship->owner), (int) ship->governor, telegram_buf);
X				free(planet);
X			}
X			kill_ship((int) (ship->owner), ship);
X		}
X	  } /* if alive */
X		putship(ship);
X	}
X	free(ship);
X}
X
Xvoid
Xdoabm(shiptype * ship)
X{
X	int             sh2;
X	int             numdest, caliber;
X	planettype     *p;
X
X	if (!ship->alive || !ship->owner)
X		return;
X	if (!ship->on || !ship->retaliate || !ship->destruct)
X		return;
X
X	if (landed(ship)) {
X		p = planets[ship->storbits][ship->pnumorbits];
X		caliber = current_caliber(ship);
X		/* check to see if missiles/mines are present */
X		sh2 = p->ships;
X		while (sh2 && ship->destruct) {
X			if (ships[sh2]->alive &&
X			    ((ships[sh2]->type == STYPE_MISSILE) ||
X			     (ships[sh2]->type == STYPE_MINE)) &&
X			    (ships[sh2]->owner != ship->owner) &&
X			    !(isset(races[ship->owner - 1]->allied, ships[sh2]->owner) &&
X			      isset(races[ships[sh2]->owner - 1]->allied, ship->owner))) {
X				/*
X				 * added last two tests to prevent mutually
X				 * allied missiles getting shot up.
X				 */
X				/* attack the missile/mine */
X				numdest = retal_strength(ship);
X				numdest = MIN(numdest, ship->destruct);
X				numdest = MIN(numdest, ship->retaliate);
X				ship->destruct -= numdest;
X				(void) shoot_ship_to_ship(ship, ships[sh2], numdest, 0, 0,
X						       long_buf, short_buf);
X				push_telegram((int) (ship->owner), (int) ship->governor, long_buf);
X				push_telegram((int) (ships[sh2]->owner),
X				      (int) ships[sh2]->governor, long_buf);
X				post(short_buf, COMBAT);
X			}
X			sh2 = ships[sh2]->nextship;
X		}
X	}
X}
X
Xvoid
Xdo_repair(shiptype * ship)
X{
X	reg int         drep, cost;
X	reg double      maxrep;
X
X	maxrep = REPAIR_RATE / (double) segments;
X	/* stations repair for free, and ships docked with them */
X	if (Shipdata[ship->type][ABIL_REPAIR])
X		cost = 0;
X	else if (ship->docked && ship->whatdest == LEVEL_SHIP &&
X		 ships[ship->destshipno]->type == STYPE_STATION)
X		cost = 0;
X	else if (ship->docked && ship->whatorbits == LEVEL_SHIP &&
X		 ships[ship->destshipno]->type == STYPE_STATION)
X		cost = 0;
X	else {
X		maxrep *= (double) (ship->popn) / (double) ship->max_crew;
X		cost = (int) (0.005 * maxrep * Cost(ship));
X	}
X	if (cost <= ship->resource) {
X		use_resource(ship, cost);
X		drep = (int) maxrep;
X		ship->damage = MAX(0, (int) (ship->damage) - drep);
X	} else {
X		/* use up all of the ships resources */
X		drep = (int) (maxrep * ((double) ship->resource / (int) cost));
X		use_resource(ship, ship->resource);
X		ship->damage = MAX(0, (int) (ship->damage) - drep);
X	}
X}
X
Xvoid
Xdo_habitat(shiptype * ship)
X{
X	reg int         sh;
X	int             add;
X	double          fuse;
X
X	/* In v5.0+ Habitats make resources out of fuel */
X	if (ship->on) {
X		fuse = ship->fuel * ((double) ship->popn / (double) ship->max_crew)
X			* (1.0 - .01 * (double) ship->damage);
X		add = (int) fuse / HABITAT_PROD_RATE;
X		if (ship->resource + add > ship->max_resource)
X			add = ship->max_resource - ship->resource;
X		fuse = HABITAT_PROD_RATE * (double) add;
X		rcv_resource(ship, add);
X		use_fuel(ship, fuse);
X
X		sh = ship->ships;
X		while (sh) {
X			if (ships[sh]->type == OTYPE_WPLANT)
X				rcv_destruct(ship, do_weapon_plant(ships[sh]));
X			sh = ships[sh]->nextship;
X		}
X	}
X	add = round_rand((double) ship->popn * races[ship->owner - 1]->birthrate);
X	if (ship->popn + add > Max_crew(ship))
X		add = Max_crew(ship) - ship->popn;
X	rcv_popn(ship, add, races[ship->owner - 1]->mass);
X}
X
Xvoid
Xdo_pod(shiptype * ship)
X{
X	reg int         i;
X
X	if (ship->whatorbits == LEVEL_STAR) {
X		if (ship->special.pod.temperature >= POD_THRESHOLD) {
X			i = int_rand(0, (int) Stars[ship->storbits]->numplanets - 1);
X			sprintf(telegram_buf, "%s has warmed and exploded at %s\n",
X				Ship(ship), prin_ship_orbits(ship));
X			if (infect_planet((int) ship->owner, (int) ship->storbits, i)) {
X				sprintf(buf, "\tmeta-colony established on %s.",
X					Stars[ship->storbits]->pnames[i]);
X			} else
X				strcat(buf, "        no spores have survived.");
X			strcat(telegram_buf, buf);
X			push_telegram((int) (ship->owner), (int) ship->governor, telegram_buf);
X			kill_ship((int) (ship->owner), ship);
X		} else
X			ship->special.pod.temperature +=
X				round_rand((double) Stars[ship->storbits]->temperature /
X					   (double) segments);
X	} else if (ship->whatorbits == LEVEL_PLAN) {
X		if (ship->special.pod.decay >= POD_DECAY) {
X			sprintf(telegram_buf, "%s has decayed at %s\n", Ship(ship),
X				prin_ship_orbits(ship));
X			push_telegram((int) ship->owner, (int) ship->governor, telegram_buf);
X			kill_ship((int) ship->owner, ship);
X		} else {
X			ship->special.pod.decay += round_rand(1.0 / (double) segments);
X		}
X	}
X}
X
Xint
Xinfect_planet(int who, int star, int p)
X{
X	if (success(SPORE_SUCCESS_RATE)) {
X		do_meta_infect(who, planets[star][p]);
X		return 1;
X	} else
X		return 0;
X}
X
Xvoid
Xdo_meta_infect(int who, planettype * p)
X{
X	int             owner, x, y;
X
X	getsmap(Smap, p);
X	PermuteSects(p);
X	bzero((char *) Sectinfo, sizeof(Sectinfo));
X	x = int_rand(0, p->Maxx - 1);
X	y = int_rand(0, p->Maxy - 1);
X	owner = Sector(*p, x, y).owner;
X	if (!owner || (who != owner && (double) int_rand(1, 100) >
X		    100.0 * (1.0 - exp(-((double) (Sector(*p, x, y).troops *
X				   races[owner - 1]->fighters / 50.0)))))) {
X		p->info[who - 1].explored = 1;
X		p->info[who - 1].numsectsowned += 1;
X		Sector(*p, x, y).troops = 0;
X		Sector(*p, x, y).popn = races[who - 1]->number_sexes;
X		Sector(*p, x, y).owner = who;
X		Sector(*p, x, y).condition = Sector(*p, x, y).type;
X#ifdef POD_TERRAFORM
X		Sector(*p, x, y).condition = races[who - 1]->likesbest;
X#endif
X		putsmap(Smap, p);
X	}
X}
X
Xvoid
Xdo_canister(shiptype * ship)
X{
X	if (ship->whatorbits == LEVEL_PLAN && !landed(ship)) {
X		if (++ship->special.timer.count < DISSIPATE) {
X			if (Stinfo[ship->storbits][ship->pnumorbits].temp_add < -90)
X				Stinfo[ship->storbits][ship->pnumorbits].temp_add = -100;
X			else
X				Stinfo[ship->storbits][ship->pnumorbits].temp_add -= 10;
X		} else {	/* timer expired; destroy canister */
X			reg int         j = 0;
X			kill_ship((int) (ship->owner), ship);
X			sprintf(telegram_buf, "Canister of dust previously covering %s has dissipated.\n",
X				prin_ship_orbits(ship));
X			for (j = 1; j <= Num_races; j++)
X				if (planets[ship->storbits][ship->pnumorbits]->info[j - 1].numsectsowned)
X					push_telegram(j, (int) Stars[ship->storbits]->governor[j - 1],
X						      telegram_buf);
X		}
X	}
X}
X
Xvoid
Xdo_greenhouse(shiptype * ship)
X{
X	if (ship->whatorbits == LEVEL_PLAN && !landed(ship)) {
X		if (++ship->special.timer.count < DISSIPATE) {
X			if (Stinfo[ship->storbits][ship->pnumorbits].temp_add > 90)
X				Stinfo[ship->storbits][ship->pnumorbits].temp_add = 100;
X			else
X				Stinfo[ship->storbits][ship->pnumorbits].temp_add += 10;
X		} else {	/* timer expired; destroy canister */
X			reg int         j = 0;
X
X			kill_ship((int) (ship->owner), ship);
X			sprintf(telegram_buf, "Greenhouse gases at %s have dissipated.\n",
X				prin_ship_orbits(ship));
X			for (j = 1; j <= Num_races; j++)
X				if (planets[ship->storbits][ship->pnumorbits]->info[j - 1].numsectsowned)
X					push_telegram(j, (int) Stars[ship->storbits]->governor[j - 1],
X						      telegram_buf);
X		}
X	}
X}
X
Xvoid
Xdo_mirror(shiptype * ship)
X{
X	switch (ship->special.aimed_at.level) {
X		case LEVEL_SHIP:/* ship aimed at is a legal ship now */
X		/* if in the same system */
X		if ((ship->whatorbits == LEVEL_STAR || ship->whatorbits == LEVEL_PLAN)
X		    && (ships[ship->special.aimed_at.shipno] != NULL)
X		    && (ships[ship->special.aimed_at.shipno]->whatorbits == LEVEL_STAR ||
X			ships[ship->special.aimed_at.shipno]->whatorbits == LEVEL_PLAN)
X		    && ship->storbits == ships[ship->special.aimed_at.shipno]->storbits
X		    && ships[ship->special.aimed_at.shipno]->alive) {
X			shiptype       *s;
X			reg int         i;
X			double          range;
X			s = ships[ship->special.aimed_at.shipno];
X			range = sqrt(Distsq(ship->xpos, ship->ypos, s->xpos, s->ypos));
X			i = int_rand(0, round_rand((2. / ((double) (Body(s))))
X						   * (double) (ship->special.aimed_at.intensity) / (range / PLORBITSIZE + 1.0)));
X			sprintf(telegram_buf, "%s aimed at %s\n", Ship(ship), Ship(s));
X			s->damage += i;
X			if (i) {
X				sprintf(buf, "%d%% damage done.\n", i);
X				strcat(telegram_buf, buf);
X			}
X			if (s->damage >= 100) {
X				sprintf(buf, "%s DESTROYED!!!\n", Ship(s));
X				strcat(telegram_buf, buf);
X				kill_ship((int) (ship->owner), s);
X			}
X			push_telegram((int) s->owner, (int) s->governor, telegram_buf);
X			push_telegram((int) ship->owner, (int) ship->governor, telegram_buf);
X		}
X		break;
X	case LEVEL_PLAN:{
X			reg int         i;
X			double          range;
X			range = sqrt(Distsq(ship->xpos, ship->ypos,
X					    Stars[ship->storbits]->xpos
X			  + planets[ship->storbits][ship->pnumorbits]->xpos,
X					    Stars[ship->storbits]->ypos
X			+ planets[ship->storbits][ship->pnumorbits]->ypos));
X			if (range > PLORBITSIZE)
X				i = PLORBITSIZE * ship->special.aimed_at.intensity / range;
X			else
X				i = ship->special.aimed_at.intensity;
X
X			i = round_rand(.01 * (100.0 - (double) (ship->damage)) * (double) i);
X			Stinfo[ship->storbits][ship->special.aimed_at.pnum].temp_add += i;
X		} break;
X	case LEVEL_STAR:{
X			/*
X			 * have to be in the same system as the star;
X			 * otherwise it's not too fair..
X			 */
X			if (ship->special.aimed_at.snum > 0 && ship->special.aimed_at.snum < Sdata.numstars &&
X			    ship->whatorbits > LEVEL_UNIV &&
X			    ship->special.aimed_at.snum == ship->storbits)
X				Stars[ship->special.aimed_at.snum]->stability += random() & 01;
X		} break;
X	case LEVEL_UNIV:
X		break;
X	}
X}
X
Xvoid
Xdo_god(shiptype * ship)
X{
X	/* gods have infinite power.... heh heh heh */
X	if (races[ship->owner - 1]->God) {
X		ship->fuel = Max_fuel(ship);
X		ship->destruct = Max_destruct(ship);
X		ship->resource = Max_resource(ship);
X	}
X}
X
Xvoid
Xdo_ap(shiptype * ship)
X{
X	racetype       *Race;
X
X	/* if landed on planet, change conditions to be like race */
X	if (landed(ship) && ship->on) {
X		int             j, d;
X		planettype     *p;
X		p = planets[ship->storbits][ship->pnumorbits];
X		Race = races[ship->owner - 1];
X		if (ship->fuel >= 3.0) {
X			use_fuel(ship, 3.0);
X			for (j = RTEMP + 1; j <= OTHER; j++) {
X				d = round_rand(ap_planet_factor(p) * crew_factor(ship) *
X					       (double) (Race->conditions[j] - p->conditions[j]));
X				if (d)
X					p->conditions[j] += d;
X			}
X		} else if (!ship->notified) {
X			ship->notified = 1;
X			ship->on = 0;
X			msg_OOF(ship);
X		}
X	}
X}
X
Xdouble
Xcrew_factor(shiptype * ship)
X{
X	int             maxcrew;
X
X	if (!(maxcrew = Shipdata[ship->type][ABIL_MAXCREW]))
X		return 0.0;
X	return ((double) ship->popn / (double) maxcrew);
X}
X
Xdouble
Xap_planet_factor(planettype * p)
X{
X	double          x;
X
X	x = (double) p->Maxx * (double) p->Maxy;
X	return (AP_FACTOR / (AP_FACTOR + x));
X}
X
Xvoid
Xdo_oap(shiptype * ship)
X{
X	/* "indimidate" the planet below, for enslavement purposes. */
X	if (ship->whatorbits == LEVEL_PLAN)
X		Stinfo[ship->storbits][ship->pnumorbits].intimidated = 1;
X}
X
Xint
Xdo_weapon_plant(shiptype * ship)
X{
X	int             maxrate, rate;
X	maxrate = (int) (races[ship->owner - 1]->tech / 2.0);
X
X	rate = round_rand(MIN((double) ship->resource / (double) RES_COST_WPLANT,
X			      ship->fuel / FUEL_COST_WPLANT)
X			  * (1. - .01 * (double) ship->damage)
X			  * (double) ship->popn / (double) ship->max_crew);
X	rate = MIN(rate, maxrate);
X	use_resource(ship, (rate * RES_COST_WPLANT));
X	use_fuel(ship, ((double) rate * FUEL_COST_WPLANT));
X	return rate;
X}
END_OF_FILE
if test 24721 -ne `wc -c <'server/doship.c'`; then
    echo shar: \"'server/doship.c'\" unpacked with wrong size!
fi
# end of 'server/doship.c'
fi
if test -f 'server/doturn.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/doturn.c'\"
else
echo shar: Extracting \"'server/doturn.c'\" \(22753 characters\)
sed "s/^X//" >'server/doturn.c' <<'END_OF_FILE'
X#ident  "@(#)doturn.c	1.5 1/31/93 "
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h. doturn -- does one turn.
X */
X
X#include <math.h>
X#include <ctype.h>
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "doturn.h"
X#include "power.h"
X#include "buffers.h"
X
XFILE           *fopen();
Xextern char    *Commod[];
Xextern long     Shipdata[NUMSTYPES][NUMABILS];
X
Xvoid            do_turn(int);
Xint             APadd(int, int, racetype *);
Xint             governed(racetype *);
Xvoid            fix_stability(startype *);
Xvoid            do_reset(int);
Xvoid            handle_victory(void);
Xvoid            make_discoveries(racetype *);
X#ifdef MARKET
Xvoid            maintain(racetype *, int, int);
X#endif
Xint             attack_planet(shiptype *);
Xvoid            output_ground_attacks(void);
Xint             planet_points(planettype *);
X#include "proto.h"
X
Xvoid 
Xdo_turn(int update)
X{
X	int             star, i, j;
X	commodtype     *c;
X	int             dummy[2], temp;
X	double          dist;
X	struct victstruct {
X		int             numsects;
X		int             shipcost;
X		int             shiptech;
X		int             morale;
X		int             res;
X		int             des;
X		int             fuel;
X		int             money;
X	}              *victory;
X
X	/* make all 0 for first iteration of doplanet */
X	if (update) {
X		bzero((char *) starpopns, sizeof(starpopns));
X		bzero((char *) starnumships, sizeof(starnumships));
X		bzero((char *) Sdatanumships, sizeof(Sdatanumships));
X		bzero((char *) Stinfo, sizeof(Stinfo));
X		bzero((char *) StarsInhab, sizeof(StarsInhab));
X		bzero((char *) Power, sizeof(Power));
X		bzero((char *) inhabited, sizeof(inhabited));
X	}
X	Num_ships = Numships();
X
X	for (i = 1; i <= Num_ships; i++)
X		domine(i, 0);
X
X	ships = (shiptype **) malloc(sizeof(shiptype *) * (Num_ships + 1));
X	for (i = 1; i <= Num_ships; i++)
X		(void) getship(&ships[i], i);
X
X	/* get all stars and planets */
X	getsdata(&Sdata);
X	Planet_count = 0;
X	for (star = 0; star < Sdata.numstars; star++) {
X		getstar(&Stars[star], star);
X		if (update)
X			fix_stability(Stars[star]);	/* nova */
X
X		for (i = 0; i < Stars[star]->numplanets; i++) {
X			getplanet(&planets[star][i], star, i);
X			if (planets[star][i]->type != TYPE_ASTEROID)
X				Planet_count++;
X			if (update)
X				moveplanet(star, planets[star][i], i);
X			if (Stars[star]->pnames[i] == '\0')
X				sprintf(Stars[star]->pnames[i], "NULL-%d", i);
X		}
X		if (Stars[star]->name[0] == '\0')
X			sprintf(Stars[star]->name, "NULL-%d", star);
X	}
X
X	for (i = 1; i <= Num_races; i++) {
X		/* increase tech; change to something else */
X		if (update) {
X			reg int         j;
X			/* Reset controlled planet count */
X			races[i - 1]->controlled_planets = 0;
X			races[i - 1]->planet_points = 0;
X			for (j = 0; j <= MAXGOVERNORS; j++)
X				if (races[i - 1]->governor[j].active) {
X#ifdef MARKET
X					races[i - 1]->governor[j].maintain = 0;
X					races[i - 1]->governor[j].cost_market = 0;
X					races[i - 1]->governor[j].profit_market = 0;
X#endif
X					races[i - 1]->governor[j].cost_tech = 0;
X					races[i - 1]->governor[j].income = 0;
X				}
X		}
X#ifdef VOTING
X		/* Reset their vote for Update go. */
X		races[i - 1]->votes &= ~VOTE_UPDATE_GO;
X#endif
X	}
X	output_ground_attacks();
X#ifdef MARKET
X	if (update) {
X		/* reset market */
X		Num_commods = Numcommods();
X		clr_commodfree();
X		for (i = Num_commods; i >= 1; i--) {
X			getcommod(&c, i);
X			if (!c->deliver) {
X				c->deliver = 1;
X				putcommod(c, i);
X				free(c);
X				continue;
X			}
X			if (c->owner && c->bidder &&
X			    (races[c->bidder - 1]->governor[c->bidder_gov].money >= c->bid)) {
X				races[c->bidder - 1]->governor[c->bidder_gov].money -= c->bid;
X				races[c->owner - 1]->governor[c->governor].money += c->bid;
X				temp = shipping_cost((int) c->star_to,
X				   (int) c->star_from, &dist, (int) c->bid);
X				races[c->bidder - 1]->governor[c->bidder_gov].cost_market +=
X					c->bid + temp;
X				races[c->owner - 1]->governor[c->governor].profit_market += c->bid;
X				maintain(races[c->bidder - 1], (int) c->bidder_gov, temp);
X				switch (c->type) {
X				case RESOURCE:
X					planets[c->star_to][c->planet_to]->info[c->bidder - 1].resource += c->amount;
X					break;
X				case FUEL:
X					planets[c->star_to][c->planet_to]->info[c->bidder - 1].fuel += c->amount;
X					break;
X				case DESTRUCT:
X					planets[c->star_to][c->planet_to]->info[c->bidder - 1].destruct += c->amount;
X					break;
X				case CRYSTAL:
X					planets[c->star_to][c->planet_to]->info[c->bidder - 1].crystals += c->amount;
X					break;
X				}
X				sprintf(buf, "Lot %d purchased from %s [%d] at a cost of %d.\n   %d %s arrived at /%s/%s\n",
X				     i, races[c->owner - 1]->name, c->owner,
X					c->bid, c->amount, Commod[c->type],
X					Stars[c->star_to]->name,
X				   Stars[c->star_to]->pnames[c->planet_to]);
X				push_telegram((int) c->bidder, (int) c->bidder_gov, buf);
X				sprintf(buf, "Lot %d (%d %s) sold to %s [%d] at a cost of %d.\n",
X					i, c->amount, Commod[c->type],
X				      races[c->bidder - 1]->name, c->bidder,
X					c->bid);
X				push_telegram((int) c->owner, (int) c->governor, buf);
X				c->owner = c->governor = 0;
X				c->bidder = c->bidder_gov = 0;
X			} else {
X				c->bidder = c->bidder_gov = 0;
X				c->bid = 0;
X			}
X			if (!c->owner)
X				makecommoddead(i);
X			putcommod(c, i);
X			free(c);
X		}
X	}
X#endif
X
X	/* check ship masses - ownership */
X	for (i = 1; i <= Num_ships; i++)
X		if (ships[i]->alive) {
X			domass(ships[i]);
X			doown(ships[i]);
X		}
X	/* do all ships one turn - do slower ships first */
X	for (j = 0; j <= 9; j++)
X		for (i = 1; i <= Num_ships; i++) {
X			if (ships[i]->alive && ships[i]->speed == j) {
X				doship(ships[i], update);
X				if ((ships[i]->type == STYPE_MISSILE) && !attack_planet(ships[i]))
X					domissile(ships[i]);
X			}
X		}
X
X#ifdef MARKET
X	/* do maintenance costs */
X	if (update)
X		for (i = 1; i <= Num_ships; i++)
X			if (ships[i]->alive && Shipdata[ships[i]->type][ABIL_MAINTAIN]) {
X				if (ships[i]->popn)
X					races[ships[i]->owner - 1]->governor[ships[i]->governor].maintain +=
X						ships[i]->build_cost;
X				if (ships[i]->troops)
X					races[ships[i]->owner - 1]->governor[ships[i]->governor].maintain +=
X						UPDATE_TROOP_COST * ships[i]->troops;
X			}
X#endif
X
X	/* prepare dead ships for recycling */
X	clr_shipfree();
X	for (i = 1; i <= Num_ships; i++)
X		if (!ships[i]->alive)
X			makeshipdead(i);
X
X	/* erase next ship pointers - reset in insert_sh_... */
X	for (i = 1; i <= Num_ships; i++) {
X		ships[i]->nextship = 0;
X		ships[i]->ships = 0;
X	}
X	/* clear ship list for insertion */
X	Sdata.ships = 0;
X	for (star = 0; star < Sdata.numstars; star++) {
X		Stars[star]->ships = 0;
X		for (i = 0; i < Stars[star]->numplanets; i++)
X			planets[star][i]->ships = 0;
X	}
X
X	/* insert ship into the list of wherever it might be */
X	for (i = Num_ships; i >= 1; i--) {
X		if (ships[i]->alive) {
X			switch (ships[i]->whatorbits) {
X			case LEVEL_UNIV:
X				insert_sh_univ(&Sdata, ships[i]);
X				break;
X			case LEVEL_STAR:
X				insert_sh_star(Stars[ships[i]->storbits], ships[i]);
X				break;
X			case LEVEL_PLAN:
X				insert_sh_plan(planets[ships[i]->storbits][ships[i]->pnumorbits], ships[i]);
X				break;
X			case LEVEL_SHIP:
X				insert_sh_ship(ships[i], ships[ships[i]->destshipno]);
X				break;
X			default:
X				break;
X			}
X		}
X	}
X
X	/*
X	 * put ABMs and surviving missiles here because ABMs need to have the
X	 * missile in the shiplist of the target planet  Maarten
X	 */
X	for (i = 1; i <= Num_ships; i++)	/* ABMs defend planet */
X		if ((ships[i]->type == OTYPE_ABM) && ships[i]->alive)
X			doabm(ships[i]);
X
X	for (i = 1; i <= Num_ships; i++)
X		if ((ships[i]->type == STYPE_MISSILE) && ships[i]->alive
X		    && attack_planet(ships[i]))
X			domissile(ships[i]);
X
X	for (i = Num_ships; i >= 1; i--)
X		putship(ships[i]);
X
X	for (star = 0; star < Sdata.numstars; star++) {
X		for (i = 0; i < Stars[star]->numplanets; i++) {
X			/* store occupation for VPs */
X			for (j = 1; j <= Num_races; j++) {
X				if (planets[star][i]->info[j - 1].numsectsowned) {
X					setbit(inhabited[star], j);
X					setbit(Stars[star]->inhabited, j);
X				}
X				if (planets[star][i]->type != TYPE_ASTEROID &&
X				    (planets[star][i]->info[j - 1].numsectsowned >
X				     planets[star][i]->Maxx * planets[star][i]->Maxy / 2))
X					races[j - 1]->controlled_planets++;
X
X				if (planets[star][i]->info[j - 1].numsectsowned)
X					races[j - 1]->planet_points += planet_points(planets[star][i]);
X			}
X			if (update) {
X				if (doplanet(star, planets[star][i], i)) {
X					/*
X					 * save smap gotten & altered by
X					 * doplanet only if the planet is
X					 * expl
X					 */
X					putsmap(Smap, planets[star][i]);
X				}
X			}
X			putplanet(planets[star][i], star, i);
X		}
X		/* do AP's for ea. player  */
X		if (update)
X			for (i = 1; i <= Num_races; i++) {
X				if (starpopns[star][i - 1])
X					setbit(Stars[star]->inhabited, i);
X				else
X					clrbit(Stars[star]->inhabited, i);
X
X				if (isset(Stars[star]->inhabited, i)) {
X					reg int         APs;
X
X					APs = Stars[star]->AP[i - 1] +
X						APadd((int) starnumships[star][i - 1],
X						      (int) starpopns[star][i - 1], races[i - 1]);
X					if (APs < LIMIT_APs)
X						Stars[star]->AP[i - 1] = APs;
X					else
X						Stars[star]->AP[i - 1] = LIMIT_APs;
X				}
X				/* compute victory points for the block */
X				if (inhabited[star][0] + inhabited[star][1]) {
X					dummy[0] = (Blocks[i - 1].invite[0] & Blocks[i - 1].pledge[0]);
X					dummy[1] = (Blocks[i - 1].invite[1] & Blocks[i - 1].pledge[1]);
X					Blocks[i - 1].systems_owned += ((inhabited[star][0] | dummy[0]) == dummy[0]) && ((inhabited[star][1] | dummy[1]) == dummy[1]);
X				}
X			}
X		putstar(Stars[star], star);
X	}
X
X	/* add APs to sdata for ea. player */
X	if (update)
X		for (i = 1; i <= Num_races; i++) {
X			Blocks[i - 1].systems_owned = 0;	/* recount systems owned */
X			if (governed(races[i - 1])) {
X				reg int         APs;
X
X				APs = Sdata.AP[i - 1] + races[i - 1]->planet_points;
X				if (APs < LIMIT_APs)
X					Sdata.AP[i - 1] = APs;
X				else
X					Sdata.AP[i - 1] = LIMIT_APs;
X			}
X		}
X
X	putsdata(&Sdata);
X
X	/* here is where we do victory calculations. */
X	if (update) {
X		victory = (struct victstruct *) malloc(Num_races *
X						 sizeof(struct victstruct));
X		for (i = 1; i <= Num_races; i++) {
X			victory[i - 1].numsects = 0;
X			victory[i - 1].shipcost = 0;
X			victory[i - 1].shiptech = 0;
X			victory[i - 1].morale = races[i - 1]->morale;
X			victory[i - 1].res = 0;
X			victory[i - 1].des = 0;
X			victory[i - 1].fuel = 0;
X			victory[i - 1].money = races[i - 1]->governor[0].money;
X			for (j = 1; j <= MAXGOVERNORS; j++)
X				if (races[i - 1]->governor[j].active)
X					victory[i - 1].money += races[i - 1]->governor[j].money;
X		}
X
X		for (star = 0; star < Sdata.numstars; star++) {
X			/* do planets in the star next */
X			for (i = 0; i < Stars[star]->numplanets; i++) {
X				for (j = 0; j < Num_races; j++) {
X					if (!planets[star][i]->info[j].explored)
X						continue;
X					victory[j].numsects += (int) planets[star][i]->info[j].numsectsowned;
X					victory[j].res += (int) planets[star][i]->info[j].resource;
X					victory[j].des += (int) planets[star][i]->info[j].destruct;
X					victory[j].fuel += (int) planets[star][i]->info[j].fuel;
X				}
X			}	/* end of planet searchings */
X		}		/* end of star searchings */
X
X		for (i = 1; i <= Num_ships; i++) {
X			if (!ships[i]->alive)
X				continue;
X			victory[ships[i]->owner - 1].shipcost += ships[i]->build_cost;
X			victory[ships[i]->owner - 1].shiptech += ships[i]->tech;
X			victory[ships[i]->owner - 1].res += ships[i]->resource;
X			victory[ships[i]->owner - 1].des += ships[i]->destruct;
X			victory[ships[i]->owner - 1].fuel += ships[i]->fuel;
X		}
X		/* now that we have the info.. calculate the raw score */
X
X		for (i = 0; i < Num_races; i++) {
X			races[i]->victory_score = (VICT_SECT * (int) victory[i].numsects) +
X				(VICT_SHIP * ((int) victory[i].shipcost +
X				 (VICT_TECH * (int) victory[i].shiptech))) +
X				(VICT_RES * ((int) victory[i].res +
X					     (int) victory[i].des)) +
X				(VICT_FUEL * (int) victory[i].fuel) +
X				(VICT_MONEY * (int) victory[i].money);
X			races[i]->victory_score /= VICT_DIVISOR;
X			races[i]->victory_score
X				= (int) (morale_factor((double) victory[i].morale) *
X					 races[i]->victory_score);
X
X		}
X		free(victory);
X	}			/* end of if (update) */
X	for (i = 1; i <= Num_ships; i++) {
X		putship(ships[i]);
X		free(ships[i]);
X	}
X
X	if (update) {
X		for (i = 1; i <= Num_races; i++) {
X			/* collective intelligence */
X			if (races[i - 1]->collective_iq) {
X				double          x = ((2. / 3.14159265) *
X						     atan((double) Power[i - 1].popn / MESO_POP_SCALE));
X				races[i - 1]->IQ = races[i - 1]->IQ_limit * x * x;
X			}
X			races[i - 1]->tech += (double) (races[i - 1]->IQ) / 100.0;
X			races[i - 1]->morale += Power[i - 1].planets_owned;
X			make_discoveries(races[i - 1]);
X			races[i - 1]->turn += 1;
X			if (races[i - 1]->controlled_planets >=
X			    Planet_count * VICTORY_PERCENT / 100)
X				races[i - 1]->victory_turns++;
X			else
X				races[i - 1]->victory_turns = 0;
X
X			if (races[i - 1]->controlled_planets >= Planet_count * VICTORY_PERCENT / 200)
X				for (j = 1; j <= Num_races; j++)
X					races[j - 1]->translate[i - 1] = 100;
X
X			Blocks[i - 1].VPs = 10 * Blocks[i - 1].systems_owned;
X#ifdef MARKET
X			for (j = 0; j <= MAXGOVERNORS; j++)
X				if (races[i - 1]->governor[j].active)
X					maintain(races[i - 1], j, (int) races[i - 1]->governor[j].maintain);
X#endif
X		}
X		for (i = 1; i <= Num_races; i++)
X			putrace(races[i - 1]);
X	}
X	free(ships);
X
X	if (update) {
X		compute_power_blocks();
X		for (i = 1; i <= Num_races; i++) {
X			Power[i - 1].money = 0;
X			for (j = 0; j <= MAXGOVERNORS; j++)
X				if (races[i - 1]->governor[j].active)
X					Power[i - 1].money += races[i - 1]->governor[j].money;
X		}
X		Putpower(Power);
X		Putblock(Blocks);
X	}
X	for (j = 1; j <= Num_races; j++) {
X		if (update)
X			notify_race(j, "Finished with update.\n");
X		else
X			notify_race(j, "Finished with movement segment.\n");
X	}
X}
X
X/*
X * routine for number of AP's to add to each player in ea. system,scaled by
X * amount of crew in their palace
X */
X
Xint 
XAPadd(int sh, int popn, racetype * race)
X{
X	int             APs;
X
X	APs = round_rand((double) sh / 10.0 + 5. * log10(1.0 + (double) popn));
X
X	if (governed(race))
X		return APs;
X	else			/* dont have an active gov center */
X		return round_rand((double) APs / 20.);
X}
X
Xint 
Xgoverned(racetype * race)
X{
X	return (race->Gov_ship && race->Gov_ship <= Num_ships &&
X	    ships[race->Gov_ship] != NULL && ships[race->Gov_ship]->alive &&
X		ships[race->Gov_ship]->docked &&
X		(ships[race->Gov_ship]->whatdest == LEVEL_PLAN ||
X		 (ships[race->Gov_ship]->whatorbits == LEVEL_SHIP &&
X	  ships[ships[race->Gov_ship]->destshipno]->type == STYPE_HABITAT &&
X		  (ships[ships[race->Gov_ship]->destshipno]->whatorbits == LEVEL_PLAN ||
X		   ships[ships[race->Gov_ship]->destshipno]->whatorbits == LEVEL_STAR))));
X}
X
X/* fix stability for stars */
Xvoid 
Xfix_stability(startype * s)
X{
X	int             a, i;
X
X	if (s->nova_stage > 0) {
X		if (s->nova_stage > 14) {
X			s->stability = 20;
X			s->nova_stage = 0;
X			sprintf(telegram_buf, "Notice\n");
X			sprintf(buf, "\n  Scientists report that star %s\n",
X				s->name);
X			strcat(telegram_buf, buf);
X			sprintf(buf, "is no longer undergoing nova.\n");
X			strcat(telegram_buf, buf);
X			for (i = 1; i <= Num_races; i++)
X				push_telegram_race(i, telegram_buf);
X
X			/* telegram everyone when nova over? */
X		} else
X			s->nova_stage++;
X	} else if (s->stability > 20) {
X		a = int_rand(-1, 3);
X		/* nova just starting; notify everyone */
X		if ((s->stability + a) > 100) {
X			s->stability = 100;
X			s->nova_stage = 1;
X			sprintf(telegram_buf, "***** BULLETIN! ******\n");
X			sprintf(buf, "\n  Scientists report that star %s\n", s->name);
X			strcat(telegram_buf, buf);
X			sprintf(buf, "is undergoing nova.\n");
X			strcat(telegram_buf, buf);
X			for (i = 1; i <= Num_races; i++)
X				push_telegram_race(i, telegram_buf);
X		} else
X			s->stability += a;
X	} else {
X		a = int_rand(-1, 1);
X		if (((int) s->stability + a) < 0)
X			s->stability = 0;
X		else
X			s->stability += a;
X	}
X}
X
Xvoid 
Xdo_reset(int time_reset)
X{
X	int             star, i;
X
X	Num_ships = Numships();
X
X	ships = (shiptype **) malloc(sizeof(shiptype *) * (Num_ships + 1));
X	for (i = 1; i <= Num_ships; i++)
X		(void) getship(&ships[i], i);
X
X	/* get all stars and planets */
X	getsdata(&Sdata);
X	for (star = 0; star < Sdata.numstars; star++) {
X		getstar(&Stars[star], star);
X		for (i = 0; i < Stars[star]->numplanets; i++)
X			getplanet(&planets[star][i], star, i);
X	}
X	output_ground_attacks();
X
X	/* erase next ship pointers - reset in insert_sh_... */
X	for (i = 1; i <= Num_ships; i++) {
X		ships[i]->nextship = 0;
X		ships[i]->ships = 0;
X	}
X
X	/* clear ship list for insertion */
X	Sdata.ships = 0;
X	for (star = 0; star < Sdata.numstars; star++) {
X		Stars[star]->ships = 0;
X		for (i = 0; i < Stars[star]->numplanets; i++)
X			planets[star][i]->ships = 0;
X	}
X
X	/* insert ship into the list of wherever it might be */
X	for (i = Num_ships; i >= 1; i--) {
X		if (ships[i]->alive) {
X			switch (ships[i]->whatorbits) {
X			case LEVEL_UNIV:
X				insert_sh_univ(&Sdata, ships[i]);
X				break;
X			case LEVEL_STAR:
X				insert_sh_star(Stars[ships[i]->storbits], ships[i]);
X				break;
X			case LEVEL_PLAN:
X				insert_sh_plan(planets[ships[i]->storbits][ships[i]->pnumorbits], ships[i]);
X				ships[i]->xpos = planets[ships[i]->storbits][ships[i]->pnumorbits]->xpos
X					+ Stars[ships[i]->storbits]->xpos;
X				ships[i]->ypos = planets[ships[i]->storbits][ships[i]->pnumorbits]->ypos
X					+ Stars[ships[i]->storbits]->ypos;
X				break;
X			case LEVEL_SHIP:
X				insert_sh_ship(ships[i], ships[ships[i]->destshipno]);
X				break;
X			default:
X				break;
X			}
X		}
X	}
X
X	/* check ship masses */
X	for (i = 1; i <= Num_ships; i++)
X		if (ships[i]->alive) {
X			domass(ships[i]);
X			doown(ships[i]);
X		}
X	for (star = 0; star < Sdata.numstars; star++) {
X		if (!isascii(*Stars[star]->name))
X			sprintf(Stars[star]->name, "%d", star);
X		for (i = 0; i < Stars[star]->numplanets; i++) {
X			if (!isascii(*Stars[star]->pnames[i]))
X				sprintf(Stars[star]->pnames[i], "%d", i);
X			putplanet(planets[star][i], star, i);
X		}
X		putstar(Stars[star], star);
X	}
X	putsdata(&Sdata);
X
X	for (i = 1; i <= Num_ships; i++) {
X		putship(ships[i]);
X		free(ships[i]);
X	}
X	free(ships);
X
X	for (i = 1; i <= Num_races; i++) {
X		putrace(races[i - 1]);
X		if (!send_special_string(i, RESET_END))
X			notify_race(i, "Finished with reset.\n");
X	}
X}
X
X#define BIG_WINNER 1
X#define LITTLE_WINNER 2
X
Xvoid 
Xhandle_victory(void)
X{
X	int             i, j;
X	int             game_over = 0;
X	int             win_category[64];
X
X#ifndef VICTORY
X	return;
X#endif
X
X	for (i = 1; i <= Num_races; i++) {
X		win_category[i - 1] = 0;
X		if (races[i - 1]->controlled_planets >=
X		    Planet_count * VICTORY_PERCENT / 100) {
X			win_category[i - 1] = LITTLE_WINNER;
X		}
X		if (races[i - 1]->victory_turns >= VICTORY_UPDATES) {
X			game_over++;
X			win_category[i - 1] = BIG_WINNER;
X		}
X	}
X	if (game_over) {
X		for (i = 1; i <= Num_races; i++) {
X			strcat(telegram_buf, "*** Attention ***");
X			push_telegram_race(i, telegram_buf);
X			strcat(telegram_buf,
X			   "This game of Galactic Bloodshed is now *over*");
X			push_telegram_race(i, telegram_buf);
X			sprintf(telegram_buf, "The big winner%s",
X				(game_over == 1) ? " is" : "s are");
X			push_telegram_race(i, telegram_buf);
X			for (j = 1; j <= Num_races; j++)
X				if (win_category[j - 1] == BIG_WINNER) {
X					sprintf(telegram_buf, "*** [%2d] %-30.30s ***",
X						j, races[j - 1]->name);
X					push_telegram_race(i, telegram_buf);
X				}
X			strcat(telegram_buf, "Lesser winners:");
X			push_telegram_race(i, telegram_buf);
X			for (j = 1; j <= Num_races; j++)
X				if (win_category[j - 1] == LITTLE_WINNER) {
X					sprintf(telegram_buf, "+++ [%2d] %-30.30s +++", j, races[j - 1]->name);
X					push_telegram_race(i, telegram_buf);
X				}
X		}
X	}
X}
X
Xvoid 
Xmake_discoveries(racetype * r)
X{
X	/* would be nicer to do this with a loop of course - but it's late */
X	if (!Hyper_drive(r) && r->tech >= TECH_HYPER_DRIVE) {
X		push_telegram_race(r->Playernum,
X			    "You have discovered HYPERDRIVE technology.\n");
X		r->discoveries[D_HYPER_DRIVE] = 1;
X	}
X	if (!Laser(r) && r->tech >= TECH_LASER) {
X		push_telegram_race(r->Playernum,
X				 "You have discovered LASER technology.\n");
X		r->discoveries[D_LASER] = 1;
X	}
X	if (!Cew(r) && r->tech >= TECH_CEW) {
X		push_telegram_race(r->Playernum,
X				   "You have discovered CEW technology.\n");
X		r->discoveries[D_CEW] = 1;
X	}
X	if (!Tractor_beam(r) && r->tech >= TECH_TRACTOR_BEAM) {
X		push_telegram_race(r->Playernum,
X			  "You have discovered TRACTOR BEAM technology.\n");
X		r->discoveries[D_TRACTOR_BEAM] = 1;
X	}
X	if (!Transporter(r) && r->tech >= TECH_TRANSPORTER) {
X		push_telegram_race(r->Playernum,
X			   "You have discovered TRANSPORTER technology.\n");
X		r->discoveries[D_TRANSPORTER] = 1;
X	}
X	if (!Avpm(r) && r->tech >= TECH_AVPM) {
X		push_telegram_race(r->Playernum,
X				   "You have discovered AVPM technology.\n");
X		r->discoveries[D_AVPM] = 1;
X	}
X	if (!Cloak(r) && r->tech >= TECH_CLOAK) {
X		push_telegram_race(r->Playernum,
X				 "You have discovered CLOAK technology.\n");
X		r->discoveries[D_CLOAK] = 1;
X	}
X	if (!Wormhole(r) && r->tech >= TECH_WORMHOLE) {
X		push_telegram_race(r->Playernum,
X			      "You have discovered WORMHOLE technology.\n");
X		r->discoveries[D_WORMHOLE] = 1;
X	}
X	if (!Crystal(r) && r->tech >= TECH_CRYSTAL) {
X		push_telegram_race(r->Playernum,
X			       "You have discovered CRYSTAL technology.\n");
X		r->discoveries[D_CRYSTAL] = 1;
X	}
X}
X
X#ifdef MARKET
Xvoid 
Xmaintain(racetype * r, int gov, int amount)
X{
X	if (r->governor[gov].money >= amount)
X		r->governor[gov].money -= amount;
X	else {
X		r->morale -= (amount - r->governor[gov].money) / 10;
X		r->governor[gov].money = 0;
X	}
X}
X#endif
X
Xint 
Xattack_planet(shiptype * ship)
X{
X	if (ship->whatdest == LEVEL_PLAN)
X		return 1;
X	else
X		return 0;
X}
X
Xvoid 
Xoutput_ground_attacks(void)
X{
X	int             star, i, j;
X
X	for (star = 0; star < Sdata.numstars; star++)
X		for (i = 1; i <= Num_races; i++)
X			for (j = 1; j <= Num_races; j++)
X				if (ground_assaults[i - 1][j - 1][star]) {
X					sprintf(buf, "%s: %s [%d] assaults %s [%d] %d times.\n",
X						Stars[star]->name,
X						races[i - 1]->name, i, races[j - 1]->name, j,
X					ground_assaults[i - 1][j - 1][star]);
X					post(buf, COMBAT);
X					ground_assaults[i - 1][j - 1][star] = 0;
X				}
X}
X
Xint 
Xplanet_points(planettype * p)
X{
X	switch (p->type) {
X		case TYPE_ASTEROID:return ASTEROID_POINTS;
X	case TYPE_EARTH:
X		return EARTH_POINTS;
X	case TYPE_MARS:
X		return MARS_POINTS;
X	case TYPE_ICEBALL:
X		return ICEBALL_POINTS;
X	case TYPE_GASGIANT:
X		return GASGIANT_POINTS;
X	case TYPE_WATER:
X		return WATER_POINTS;
X	case TYPE_FOREST:
X		return FOREST_POINTS;
X	case TYPE_DESERT:
X		return DESERT_POINTS;
X	default:
X		return 0;
X	}
X}
END_OF_FILE
if test 22753 -ne `wc -c <'server/doturn.c'`; then
    echo shar: \"'server/doturn.c'\" unpacked with wrong size!
fi
# end of 'server/doturn.c'
fi
if test -f 'user/mobiliz.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/mobiliz.c'\"
else
echo shar: Extracting \"'user/mobiliz.c'\" \(3604 characters\)
sed "s/^X//" >'user/mobiliz.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * mobiliz.c -- persuade people to build military stuff. Sectors that are
X * mobilized produce Destructive Potential in proportion to the % they are
X * mobilized.  they are also more damage-resistant.
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "buffers.h"
X#include "races.h"
X#include "power.h"
X#include <signal.h>
X#include <ctype.h>
X
Xvoid            mobilize(int, int, int);
Xvoid            tax(int, int, int);
Xint             control(int, int, startype *);
X#include "proto.h"
X
Xvoid 
Xmobilize(int Playernum, int Governor, int APcount)
X{
X	int             sum_mob = 0;
X	planettype     *p;
X
X	if (Dir[Playernum - 1][Governor].level != LEVEL_PLAN) {
X		sprintf(buf, "scope must be a planet.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	if (!control(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum])) {
X		notify(Playernum, Governor, "You are not authorized to do this here.\n");
X		return;
X	}
X	if (!enufAP(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1], APcount)) {
X		return;
X	}
X	getplanet(&p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X
X	getsmap(Smap, p);
X
X	if (argn < 2) {
X		sprintf(buf, "Current mobilization: %d    Quota: %d\n",
X			p->info[Playernum - 1].comread, p->info[Playernum - 1].mob_set);
X		notify(Playernum, Governor, buf);
X		free(p);
X		return;
X	}
X	sum_mob = atoi(args[1]);
X
X	if (sum_mob > 100 || sum_mob < 0) {
X		sprintf(buf, "Illegal value.\n");
X		notify(Playernum, Governor, buf);
X		free(p);
X		return;
X	}
X	p->info[Playernum - 1].mob_set = sum_mob;
X	putplanet(p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X	deductAPs(Playernum, Governor, APcount, Dir[Playernum - 1][Governor].snum, 0);
X
X	free(p);
X}
X
Xvoid 
Xtax(int Playernum, int Governor, int APcount)
X{
X	int             sum_tax = 0;
X	planettype     *p;
X	racetype       *Race;
X
X	if (Dir[Playernum - 1][Governor].level != LEVEL_PLAN) {
X		sprintf(buf, "scope must be a planet.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	if (!control(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum])) {
X		notify(Playernum, Governor, "You are not authorized to do that here.\n");
X		return;
X	}
X	Race = races[Playernum - 1];
X	if (!Race->Gov_ship) {
X		notify(Playernum, Governor, "You have no government center active.\n");
X		return;
X	}
X	if (Race->Guest) {
X		notify(Playernum, Governor, "Sorry, but you can't do this when you are a guest.\n");
X		return;
X	}
X	if (!enufAP(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1], APcount)) {
X		return;
X	}
X	getplanet(&p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X
X	if (argn < 2) {
X		sprintf(buf, "Current tax rate: %d%%    Target: %d%%\n",
X		 p->info[Playernum - 1].tax, p->info[Playernum - 1].newtax);
X		notify(Playernum, Governor, buf);
X		free(p);
X		return;
X	}
X	sum_tax = atoi(args[1]);
X
X	if (sum_tax > 100 || sum_tax < 0) {
X		sprintf(buf, "Illegal value.\n");
X		notify(Playernum, Governor, buf);
X		free(p);
X		return;
X	}
X	p->info[Playernum - 1].newtax = sum_tax;
X	putplanet(p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X
X	deductAPs(Playernum, Governor, APcount, Dir[Playernum - 1][Governor].snum, 0);
X	notify(Playernum, Governor, "Set.\n");
X	free(p);
X}
X
Xint 
Xcontrol(int Playernum, int Governor, startype * star)
X{
X	return (!Governor || star->governor[Playernum - 1] == Governor);
X}
END_OF_FILE
if test 3604 -ne `wc -c <'user/mobiliz.c'`; then
    echo shar: \"'user/mobiliz.c'\" unpacked with wrong size!
fi
# end of 'user/mobiliz.c'
fi
echo shar: End of archive 10 \(of 21\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
