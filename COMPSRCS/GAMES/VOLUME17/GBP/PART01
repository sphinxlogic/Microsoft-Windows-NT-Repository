Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i013:  gbp - Galactic Bloodshed+, an empire-like war game, Part01/21
Message-ID: <4541@master.CNA.TEK.COM>
Date: 12 Feb 93 17:28:13 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1670
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1692

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 13
Archive-name: gbp/Part01
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses


[ From the author...
   This is a new version of Galactic Bloodshed (GB), called GB+.
Up to about 2 months ago the main author was Garrett VanCleef,
but he has since relinquished all the work to me, and the gbdt
(Galactic Bloodshed Development team).
   I am currently the main author for the work, and I am responsible
for releases of it. (This is also available via ftp from scam.berkeley.edu.)

John Deragon		   deragon@cs.nyu.edu | deragon@jethro.cs.nyu.edu ]


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 21)."
# Contents:  README MANIFEST doc hdrs hdrs/buffers.h misc server user
#   utils utils/racegen.c
# Wrapped by billr@saab on Fri Feb 12 09:14:23 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(2607 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
X
X	This is the new and improved GB.  At least in the installation
Xportion anyway! :-)
X
X	Basically the whole directory structure has been redone.  It also
Xcomes with Larry Walls "Configure" script to ease the pain of installtion,
Xthe the manual editing of files.
X
X
X	Given the fact you are reading this, I take it you extracted the
Xarchive alread.  It will probably be best if you extracted the contents
Xof the archive into an empty directory called GB.  
X
X	Regardless, you should have a handfull of directorys now, (hdrs,
Xserver, doc, misc, utils and user).  A few README files, a MANIFEST,
Xand a Makefile.SH.
X
X
X	Your first step is to run configure.  Either type Configure
Xor sh Configure, your choice.   It will go through and ask you some
Xquestions about your system, and the host that GB will run on and the
Xport and such.  The only questions you really gotta watch out for
Xand make sure are right are:
X
X	the hostname and domaniname
X	the port
X	and where the datafiles are to be kept.
X
X	Out of all of them the datafiles is the most important.  The default
Xshould be fine in most cases.  (it will take your current directory).
X
X	After you answer all the questions, it will extract the Makefiles,
Xand perform a few symbolic links.  (the links are for the utilites 
Xprograms, which share some of the server modules.)
X
X	After all the Makefiles are extracted and the links are made you
Xshould inspect the hdrs/files.h and hdrs/config.h files to make sure
Xthe look ok.  If you dont know what they are supposed to look like,
Xassume they are ok!  *wink*
X
X
X	Well... now for the moment of truth...
X
X	From the top level directory (where this file resides), type
X
X	make all
X
X	You should see it changing into the various directorys, and do
Xthe compiles.  After it is done...  you should type...
X
X
X	make install
X
X
X	This will take all the binaries, (GB, enrol, makeuniv) and the
Xsupport files, (planet.list, welcome.txt, ship.dat) and place the
Xwhole deal in the bin directory.
X
X	THATS IT!!  Just cd to bin, and start things up...
X
X	(You know, makeuniv, then enrol, then GB).
X
X
X	If you need to debug the user files (via dbx or gbx or whatever),
Xuse the make target GBX.  This will not link with a library, and instead
Xwill link with all the .o files in user.  (The list of the .o files, is
Xmaintained in ./user/OBJECTS.  I know there must be another way of maintaining
Xthis list, but I have not found it)
X
X	If you have _any_ problems, please drop me a line at
X		deragon@jethro.nyu.edu
X
X	and let me know what went wrong.
X
X
X	Thanks...
X
X	John Paul Deragon
X	deragon@jethro.nyu.edu
X	Thu Dec 10 23:28:29 EST 1992
X	1.2 17:03:57
END_OF_FILE
if test 2607 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(3989 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Configure                  4	
X MANIFEST                   1	This shipping list
X Makefile.SH               20	
X README                     1	
X buildfiles.sh              8	
X doc                        1	
X doc/CHANGES               19	
X doc/CLIENT_PROTOCOL       18	
X doc/README_OLD            19	
X doc/VERSION                5	
X doc/racegen.README        21	
X doc/racegen.novice-info   20	
X doc/races.doc             19	
X hdrs                       1	
X hdrs/GB_copyright.h       21	
X hdrs/TinyMUD_copyright.h  21	
X hdrs/buffers.h             1	
X hdrs/config.h             18	
X hdrs/config.h.SH          18	
X hdrs/csp.h                16	
X hdrs/doturn.h             21	
X hdrs/file.h                4	
X hdrs/files.h              21	
X hdrs/files.h.SH           20	
X hdrs/game_info.h          21	
X hdrs/interface.h           6	
X hdrs/power.h              21	
X hdrs/proto.h               7	
X hdrs/racegen.h            18	
X hdrs/races.h              19	
X hdrs/shipdata.h           16	
X hdrs/ships.h              16	
X hdrs/tweakables.h         17	
X hdrs/vars.h               16	
X misc                       1	
X misc/Makefile.SH          21	
X misc/daemon.txt           12	
X misc/exam.dat             11	
X misc/help.txt             20	
X misc/planet.list          19	
X misc/ship.dat             21	
X misc/star.list            20	
X misc/welcome.txt           4	
X server                     1	
X server/GB_server.c         3	
X server/Makefile.SH        19	
X server/access.c            3	
X server/client.c           20	
X server/doplanet.c          7	
X server/dosector.c         19	
X server/doship.c           10	
X server/doturn.c           10	
X server/files.c            21	
X server/files_rw.c         21	
X server/files_shl.c        13	
X server/get4args.c         21	
X server/getplace.c         17	
X server/lists.c            20	
X server/log.c              20	
X server/max.c              20	
X server/misc.c             20	
X server/moveplanet.c       21	
X server/moveship.c          5	
X server/perm.c              2	
X server/rand.c             21	
X server/shlmisc.c           9	
X user                       1	
X user/Makefile.SH          15	
X user/OBJECTS              21	
X user/SOURCES              21	
X user/analysis.c           13	
X user/autoreport.c         21	
X user/autoshoot.c          20	
X user/build.c1             15	
X user/build.c2              2	
X user/capital.c            21	
X user/capture.c            14	
X user/chan.c               20	
X user/cs.c                 16	
X user/declare.c            16	
X user/dissolve.c           19	
X user/dock.c               12	
X user/enslave.c            19	
X user/examine.c            20	
X user/explore.c            14	
X user/fire.c               11	
X user/fuel.c               17	
X user/guardian.c           21	
X user/help.c               21	
X user/land.c               13	
X user/launch.c             17	
X user/load.c                5	
X user/map.c                18	
X user/mobiliz.c            10	
X user/move.c                9	
X user/name.c                6	
X user/orbit.c              14	
X user/order.c               8	
X user/power.c              11	
X user/prof.c               14	
X user/relation.c           21	
X user/rst.c                12	
X user/sche.c               21	
X user/scrap.c              15	
X user/shootblast.c          8	
X user/survey.c             12	
X user/tech.c               21	
X user/tele.c               18	
X user/togg.c               19	
X user/toxi.c               21	
X user/vict.c               20	
X user/zoom.c               21	
X utils                      1	
X utils/GB_racegen.c        17	
X utils/Makefile.SH         20	
X utils/Makelist.c          14	
X utils/README_EXSHIP       20	
X utils/enrol.c             13	
X utils/enroll.c            18	
X utils/exship.c            17	
X utils/makeplanet.c         6	
X utils/makestar.c          15	
X utils/makeuniv.c          15	
X utils/psmap.c             18	
X utils/racegen.c            1	
END_OF_FILE
if test 3989 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test ! -d 'doc' ; then
    echo shar: Creating directory \"'doc'\"
    mkdir 'doc'
fi
if test ! -d 'hdrs' ; then
    echo shar: Creating directory \"'hdrs'\"
    mkdir 'hdrs'
fi
if test -f 'hdrs/buffers.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hdrs/buffers.h'\"
else
echo shar: Extracting \"'hdrs/buffers.h'\" \(133 characters\)
sed "s/^X//" >'hdrs/buffers.h' <<'END_OF_FILE'
XEXTERN char buf[2047];
XEXTERN char long_buf[1024], short_buf[256];
XEXTERN char telegram_buf[AUTO_TELEG_SIZE];
XEXTERN char temp[128];
END_OF_FILE
if test 133 -ne `wc -c <'hdrs/buffers.h'`; then
    echo shar: \"'hdrs/buffers.h'\" unpacked with wrong size!
fi
# end of 'hdrs/buffers.h'
fi
if test ! -d 'misc' ; then
    echo shar: Creating directory \"'misc'\"
    mkdir 'misc'
fi
if test ! -d 'server' ; then
    echo shar: Creating directory \"'server'\"
    mkdir 'server'
fi
if test ! -d 'user' ; then
    echo shar: Creating directory \"'user'\"
    mkdir 'user'
fi
if test ! -d 'utils' ; then
    echo shar: Creating directory \"'utils'\"
    mkdir 'utils'
fi
if test -f 'utils/racegen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/racegen.c'\"
else
echo shar: Extracting \"'utils/racegen.c'\" \(39848 characters\)
sed "s/^X//" >'utils/racegen.c' <<'END_OF_FILE'
X/* racegen - a Galactic Bloodshed race creation program.
X * Copyright (c) Leonard Dickens 1991   (leonard@cs.umd.edu)
X *
X * Permission to copy, distribute, and/or alter is granted as long as the copy-
X * right notice and these terms are left unchanged in all derivatives/copies.
X * 
X * Anybody who does alter this program, please take credit!
X */
X
X#include <varargs.h>
X
X/* Slightly hacked version: altered to use varargs by Tom Boutell. */
X
X/*
X * History:
X * 09-13-91 1.0.0 LD Started work
X * 09-14-91 1.0.0 LD Finished except for tweaking cost parameters.
X * 09-15-91 1.0.0 LD Added linear parameterizations for all attributes.
X *   Added exponential portions to most of the attributes.  Structured 
X *   attributes to allow easy expansion.
X * 09-15-91 1.1.0 LD Added load and save (non-verbose), and print-to-file.
X * 09-16-91 1.2.0 LD Added sector cost-covariances.
X * 09-16-91 1.2.1 LD Added attribute cost-covariances.  Tweaked n_sector costs.
X * 09-17-91       LD Posted the program.  Let's see what the net digs up.
X * 09-18-91 1.2.2 LD Tweaked help to not display plated as a sector option.
X *   Made gas races unable to have any other sector compat.  Made default
X *   IQ be only 125.  Made max birthrate be 1.0.
X * 09-19-91 1.2.3 LD More tweaks to get attribute costs like I want them.
X * 09-20-91 1.2.4 LD Added new #defines and prints for more game-dependent
X *   information for the players' edification.
X * 09-20-91 1.3.0 LD Added all morph attributes separately; removed race costs.
X * 09-25-91 1.4.0 LD Added ENROLL variant code.
X * 09-25-91       LD Posted the program again.  
X * 09-30-91 1.4.1 LD Yeck, this is more complicated than I thought.  Sigh.
X *   Added an address field to the race structure.  Separated critique info
X *   out from modify to allow it to be called from enroll.  Added "last"
X *   race in order to always have a valid race to fall back on.  Added
X *   rejection field to x structure for enroll to use.
X * 09-31-91 1.4.2 LD Added cost extra cost for non-typical sectors.  This
X *   if in essense just a planet_type-compat covariance.
X * 10-01-91 1.4.3 LD Separated out modify-print loop in order to allow
X *   enroll to recursively edit.
X * 10-03-91 1.4.4 LD Mods to compile with old GB enroll.  Changed "IQ" to
X *   something else...A_IQ.  Changed OTHER to OTHER_STUFF.  Changed order
X *   of sector defines to match DES_ defines in tweakables.h
X * 10-03-91 1.5.0 LD File breakup to promote separate compilation.
X * 10-04-91 1.5.1 LD Added Dialogue command to centralize simple exchanges.
X *   this is really just a CS major nicety; it is not needed.
X * 10-06-91 1.5.2 LD Fixed bug in critique that squelched jovian compat.
X * 10-07-91 1.5.3 LD Fixed iq/iq_limit load covariance problem.
X * 12-15-92 1.5.3 JPD Added 1.5.3 to GB+ distribution.  Added racegen.c to
X *   utils directory, racegen.h to hdrs directory, and docs to docs direc.
X * 
X *
X * Thanks to:
X * Clay Luther for the original, (perl) racegen.  I made sure to look at it
X *   before starting this, and in got much of the linear aspects of my
X *   attribute cost functions from his program.  Also, the 125 IQ is Clay's.
X * Keesh, for the numbers, too.  At least, Clay thanks him for them, so I
X *   think I should too.
X * Paul A Daniels for pointing out that help displayed plated as a possible
X *   argument for modify.
X * jtop@cs.kun.nl for the race with gas and other compats too.  My blind spot.
X * Doug Ingram for suggesting more game-dependent info be included.
X *
X * Version: (sccs) 1.4 05:32:31
X */
X#include <math.h>
X#include <signal.h>
X#include <stdio.h>
X#include <string.h>
X
X
X
X/**************
X * Definitions for data types and such used in the program.
X */
X#include "racegen.h"
X
X
Xattribute attr[N_ATTRIBUTES] = {
X  {ADVENT, "Adventurism",
X     0.0, 0.0, 0.0, 300.0, 0.0,
X     0.05, 0.4, 0.99,
X     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
X     0},
X  {ABSORB, "Absorb",
X     0.0, 0.0, 0.0, 150.0, 0.0,
X     0.00, 0.00, 1.00,
X     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
X     2},
X  {BIRTH, "Birthrate", 
X     0.0, 0.0, 0.0, 500.0, 0.0,
X     0.2, 0.6, 1.0, 
X     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
X     0},
X  {COL_IQ, "Collective IQ",
X     0.0, 0.0, 0.0, -350.5, 0.0,
X     0.00, 0.00, 1.00,
X     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
X     2},
X  {FERT, "Fertilize", 
X     200.0, 1.0, 1.0, 300.0, 0.0,
X     0.0, 0.0, 1.0, 
X     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
X     0},
X  {A_IQ, "IQ", 
X     100.0, 0.03, 140, 6, 0.0,
X     50, 125, 220,
X     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
X     1},
X  {FIGHT, "Fight", 
X     10.0, 0.4, 6.0, 65.0, 0.0,
X     1, 4, 20, 
X     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
X     1},
X  {PODS, "Pods",
X     0.0, 0.0, 0.0, 250.0, 0.0,
X     0.00, 0.00, 1.00,
X     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
X     2},
X  {MASS, "Mass", 
X     100.0, 1.0, 3.1, -100.0, 0.0,
X     0.1, 1.0, 3.0, 
X     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
X     0},
X  {SEXES, "Sexes", 
X     2.2, -0.5, 9.0, -3.0, 0.0, 
X     1, 2, 53, 
X     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
X     1},
X  {METAB, "Metabolism", 
X     300.0, 0.8, 1.3, 700.0, 0.0,
X     0.1, 0.8, 4.0, 
X     {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
X     0}
X  } ;
X
Xconst char *planet_print_name[N_HOME_PLANET_TYPES] = {
X"Earth", "Forest", "Desert", "Water", "Airless", "Iceball", "Jovian"} ;
Xconst int planet_cost[N_HOME_PLANET_TYPES] = {
X75, 50, 50, 50, -25, -25, 700} ;
X
Xconst char *race_print_name[N_RACE_TYPES] = {"Normal", "Metamorph"} ;
Xconst int race_cost[N_RACE_TYPES] = {0, 0} ;
X
Xconst char *priv_print_name[N_PRIV_TYPES] = {"God", "Guest", "Normal"} ;
X
Xconst char *sector_print_name[N_SECTOR_TYPES] = {
X"Water", "Land", "Mountain", "Gas", "Ice", "Forest", "Desert", "Plated"} ;
X
Xconst double compat_cov[N_SECTOR_TYPES][N_SECTOR_TYPES] = {
X/*  .       *        ^       ~       #       )       -      o  */
X  {0.0,    },
X  { .001,  0.0      },
X  { .002,  -.0005,  0.0,    },
X  {999,    999,     999,    0.0,    },
X  { .001,  0.0,     -.002,  999,    0.0,    },
X  {0.0,    -.001,   0.0,    999,     .001,  0.0,    },
X  { .003,  -.0005,  0.0,    999,    0.0,     .001,  0.0},
X  {0.0,    0.0,     0.0,    999,    0.0,    0.0,    0.0,   0.0}
X  } ;
X
Xconst double planet_compat_cov[N_HOME_PLANET_TYPES][N_SECTOR_TYPES] = {
X         /*  .      *      ^      ~      #      )      -      o  */
X/* @ */  { 1.00,  1.00,  1.50, 99.00,  1.01,  1.01,  1.50,  1.01},
X/* ) */  { 1.01,  1.01,  1.50, 99.00,  1.01,  1.00,  3.00,  1.01},
X/* - */  { 3.00,  1.01,  1.50, 99.00,  1.01,  3.00,  1.00,  1.01},
X/* . */  { 1.00,  1.01,  1.50, 99.00,  1.01,  1.01,  3.00,  1.01},
X/* O */  { 3.00,  1.00,  1.50, 99.00,  2.00,  3.00,  1.01,  1.01},
X/* # */  { 3.00,  2.00,  1.00, 99.00,  1.00,  3.00,  2.00,  1.01},
X/* ~ */  {99.00, 99.00, 99.00,  1.00, 99.00, 99.00, 99.00, 99.00}
X	 } ;
X
X
X/**************
X * Global variables for this program.
X */
Xstruct x race, cost, last ;
X
Xint npoints = STARTING_POINTS ;
Xint last_npoints = STARTING_POINTS ;
Xint altered = 0 ;       /* 1 iff race has been altered since last saved */
Xint changed = 1 ;       /* 1 iff race has been changed since last printed */
Xint please_quit = 0 ;   /* 1 iff you want to exit ASAP. */
X
X
X
X/**************
X * Price function for racegen.  Finds the cost of `race', and returns it.
X * As a side effect the costs for all the individual fields of `race' get
X * stuffed into `cost' for later printing.
X */
Xint cost_of_race()
X{
X  int i, j, sum = 0 ;
X
X#define ROUND(f) ((int) (0.5 + (f)))
X  for (i=FIRST_ATTRIBUTE; i<=LAST_ATTRIBUTE; i++)
X    cost.attr[i] = (exp(attr[i].e_fudge * (race.attr[i] - attr[i].e_hinge)) 
X		    * attr[i].e_factor + race.attr[i] * attr[i].l_factor) ; 
X#ifdef COVARIANCES
X  for (i=FIRST_ATTRIBUTE; i<=LAST_ATTRIBUTE; i++)
X    for (j=FIRST_ATTRIBUTE; j<=LAST_ATTRIBUTE; j++)
X      if (attr[i].cov[j] != 0.0)
X	cost.attr[i] *= (1.0 + attr[i].cov[j] * race.attr[j]) ;
X#endif
X  for (i=FIRST_ATTRIBUTE; i<=LAST_ATTRIBUTE; i++)
X    sum += (cost.attr[i] = ROUND(cost.attr[i] + attr[i].l_fudge)) ;
X		  
X  sum += (cost.home_planet_type = planet_cost[race.home_planet_type]) ;
X  sum += (cost.race_type = race_cost[race.race_type]) ;
X  race.n_sector_types = 0 ;
X  for (i=FIRST_SECTOR_TYPE; i<=LAST_SECTOR_TYPE; i++) {
X    if (race.compat[i] != 0.0)
X      race.n_sector_types += 1 ;
X    /* Get the base costs: */
X    cost.compat[i] = race.compat[i]*0.5 + 10.8*log(1.0+race.compat[i]) ;
X    }
X#ifdef COVARIANCES
X  for (i=FIRST_SECTOR_TYPE; i<=LAST_SECTOR_TYPE; i++)
X    for (j=i+1; j<=LAST_SECTOR_TYPE; j++)
X      if (compat_cov[j][i] != 0.0) {
X	cost.compat[i] *= (1.0 + compat_cov[j][i] * race.compat[j]) ;
X	cost.compat[j] *= (1.0 + compat_cov[j][i] * race.compat[i]) ;
X	}
X  for (i=FIRST_SECTOR_TYPE; i<=LAST_SECTOR_TYPE; i++)
X    if (planet_compat_cov[race.home_planet_type][i] > 1.01)
X      cost.compat[i] *= planet_compat_cov[race.home_planet_type][i] ;
X#endif
X  for (i=FIRST_SECTOR_TYPE; i<=LAST_SECTOR_TYPE; i++)
X    sum += (cost.compat[i] = ROUND(cost.compat[i])) ;
X  sum += (cost.n_sector_types = n_sector_types_cost[race.n_sector_types]) ;
X  return sum ;
X  }
X
X
Xvoid metamorph()
X{
X  /* Adventurousness is not correlated with Max IQ. */
X  attr[ADVENT].cov[A_IQ]    =  0.00 ;
X  /* A high birthrate is easier if few sexes, high metab, and low mass.*/
X  /** Morphs are not born, they hatch.  THus the mass limitation is smaller:**/
X  attr[BIRTH].cov[MASS]   =  0.10 / ATTR_RANGE(MASS) ;
X  attr[BIRTH].cov[SEXES]  =  0.90 / ATTR_RANGE(SEXES) ;
X  attr[BIRTH].cov[METAB]  = -0.20 / ATTR_RANGE(METAB) ;
X  /* Natural fertilization is ultimately associated with metabolic activity */ 
X  /** Morphs are naturally adept at fertilization. **/
X  attr[FERT].cov[METAB]   = -0.60 / ATTR_RANGE(METAB) ;
X  /* Fighting is easier for independent, high-mass, high-metab races:   */
X  attr[FIGHT].cov[ADVENT] = -0.05 / ATTR_RANGE(ADVENT) ;
X  attr[FIGHT].cov[MASS]   = -0.20 / ATTR_RANGE(MASS) ;
X  attr[FIGHT].cov[METAB]  = -0.05 / ATTR_RANGE(METAB) ;
X  /* A high metabolism is hard to support if you have high mass: */
X  /** Due to general squishiness, this effect is not as strong for mesos. **/
X  attr[METAB].cov[MASS]   =  0.05 / ATTR_RANGE(MASS) ;
X  /* However, a large IQ is easier with high mass; (lot of brain space): */
X  /** IQ represents max IQ, thus, no go. **/
X  attr[A_IQ].cov[MASS]      =  0.00 ;
X  /* IQ is cheaper by virtue of collective intelligence: */
X  attr[A_IQ].cov[COL_IQ]    =  -0.4 / ATTR_RANGE(COL_IQ) ;
X
X  strcpy(attr[A_IQ].print_name, "IQ Limit") ;
X  }
X
Xvoid normal()
X{
X  /* Adventurousness is more likely with people smart enough to do it. */
X  attr[ADVENT].cov[A_IQ]  = -0.10 / ATTR_RANGE(A_IQ) ;
X  /* A high birthrate is easier if few sexes, high metab, and low mass.*/
X  attr[BIRTH].cov[MASS]   =  0.40 / ATTR_RANGE(MASS) ;
X  attr[BIRTH].cov[SEXES]  =  0.90 / ATTR_RANGE(SEXES) ;
X  attr[BIRTH].cov[METAB]  = -0.20 / ATTR_RANGE(METAB) ;
X  /* Natural fertilization is ultimately associated with metabolic activity */ 
X  attr[FERT].cov[METAB]   = -0.20 / ATTR_RANGE(METAB) ;
X  /* Fighting is easier for independent, high-mass, high-metab races:   */
X  attr[FIGHT].cov[ADVENT] = -0.05 / ATTR_RANGE(ADVENT) ;
X  attr[FIGHT].cov[MASS]   = -0.20 / ATTR_RANGE(MASS) ;
X  attr[FIGHT].cov[METAB]  = -0.05 / ATTR_RANGE(METAB) ;
X  /* A high metabolism is hard to support if you have high mass: */
X  attr[METAB].cov[MASS]   =  0.15 / ATTR_RANGE(MASS) ;
X  /* However, a large IQ is easier with high mass; (lot of brain space): */
X  attr[A_IQ].cov[MASS]    = -0.10 / ATTR_RANGE(MASS) ;
X  /* IQ is cheaper by virtue of collective intelligence: */
X  attr[A_IQ].cov[COL_IQ]    =  -0.4 / ATTR_RANGE(COL_IQ) ;
X
X  strcpy(attr[A_IQ].print_name, "IQ") ;
X  }
X
X
Xvoid fix_up_iq()
X{
X  if (race.attr[COL_IQ] == 1.0)
X    strcpy(attr[A_IQ].print_name, "IQ Limit") ;
X  else
X    strcpy(attr[A_IQ].print_name, "IQ") ;
X  }
X
X
X
X/**************
X * VERY IMPORTANT FUNCTION: this function is a representation function
X * for the race datatype.  That is, it will return a positive integer iff 
X * the race is NOT valid.  It is thus useful both when modifying a race and
X * when loading a race.  The file f should be NULL if you do not want to
X * print out descriptions of the errors; otherwise, error message(s) will be 
X * printed to that file.  
X */
Xint critique_to_file(f, rigorous_checking, is_player_race)
X     FILE *f ;
X     int rigorous_checking ;
X     int is_player_race ;
X{
X#ifdef TRADITIONAL_RACES
X  static char *tr_caveat = " in traditional GB" ;
X#endif
X  int i, nerrors = 0 ;
X
X#define FPRINTF if (f != NULL) fprintf
X  
X  /*
X   * Check for valid attributes: */
X  for (i = FIRST_ATTRIBUTE; i<=LAST_ATTRIBUTE; i++) {
X    if ((attr[i].is_integral == 2) && 
X	(race.attr[i] != 0.0) && (race.attr[i] != 1.0)) {
X      FPRINTF(f, "%s is boolean valued.  Use \"yes\" or \"no\".\n", 
X	     attr[i].print_name) ;
X      nerrors += 1 ;
X      }
X    if (race.attr[i] < attr[i].minimum) {
X      FPRINTF(f, "%s must be at least %0.2f.\n", 
X	     attr[i].print_name, attr[i].minimum) ;
X      nerrors += 1 ;
X      }
X    if (race.attr[i] > attr[i].maximum) {
X      FPRINTF(f, "%s may be at most %0.2f.\n", 
X	     attr[i].print_name, attr[i].maximum) ;
X      nerrors += 1 ;
X      }
X    /* Warning, but no error: */
X    if (attr[i].is_integral) {
X      if (race.attr[i] != ((double)((int)race.attr[i])))
X	FPRINTF(f, "%s is integral; truncated to %1.0f.\n", attr[i].print_name, 
X	       race.attr[i] = ((double)((int)race.attr[i]))) ;
X	}
X    else 
X      if (race.attr[i] != (((double)((int)(100.0*race.attr[i])))/100.0))
X	FPRINTF(f, "%s truncated to next lowest hundredth (%1.2f).\n",
X	       attr[i].print_name, 
X	       race.attr[i] = (((double)((int)(100.0*race.attr[i])))/100.0)) ;
X    }
X
X
X  /* 
X   * Check for valid normal race attributes: */
X  if (race.race_type == R_NORMAL) {
X    if (race.attr[ABSORB] != 0.0) {
X      FPRINTF(f, "Normal races do not absorb their enemies in combat.\n") ;
X      nerrors += 1 ;
X      }
X    if (race.attr[PODS] != 0.0) {
X      FPRINTF(f, "Normal races do not make pods.\n") ;
X      nerrors += 1 ;
X      }
X#ifdef TRADITIONAL_RACES
X    if (race.attr[COL_IQ] != 0.0) {
X      FPRINTF(f, "Normal races may not have collective iq%s.\n", tr_caveat) ;
X      nerrors += 1 ;
X      }
X    if (race.attr[FERT] != 0.0) {
X      FPRINTF(f, "Normal races do not fertilize%s.\n", tr_caveat) ;
X      nerrors += 1 ;
X      }
X    if (race.attr[SEXES] < 2.0) {
X      FPRINTF(f, "Normal races must have at least two sexes%s.\n", tr_caveat) ;
X      nerrors += 1 ;
X      }
X#endif
X    }
X  
X
X  /* 
X   * Check for valid morph race attributes: */
X  if (race.race_type == R_METAMORPH) {
X    if (race.attr[SEXES] > 1.0) {
X      FPRINTF(f, "Metamorphs always have only one sex.\n") ;
X      nerrors += 1 ;
X      }
X
X#ifdef TRADITIONAL_RACES
X    if (race.attr[A_IQ] != DEFAULT_MESO_IQ_LIMIT) {
X      FPRINTF(f, "Metamorphs' IQ limit may not be changed%s.\n", tr_caveat) ;
X      nerrors += 1 ;
X      } 
X#endif
X    }
X
X  /*
X   * Check for valid name:  */
X  if (0 == strlen(race.name)) {
X    FPRINTF(f, "Use a non-empty name.\n") ;
X    nerrors += 1 ;
X    }
X
X  /*
X   * Check for valid privileges:  */
X  if ((race.priv_type < FIRST_PRIV_TYPE) ||
X      (race.priv_type > LAST_PRIV_TYPE)) {
X    FPRINTF(f, "Privileges out of valid range.\n") ;
X    nerrors += 1 ;
X    }
X  if ((race.priv_type != P_NORMAL) && is_player_race) {
X    FPRINTF(f, "Players may not create %s races.\n", 
X	   priv_print_name[race.priv_type]) ;
X    nerrors += 1 ;
X    }
X
X  /*
X   * Check for valid home planet: */
X  if ((race.home_planet_type < FIRST_HOME_PLANET_TYPE) ||
X      (race.home_planet_type > LAST_HOME_PLANET_TYPE)) {
X    FPRINTF(f, "Home planet type out of valid range.\n") ;
X    nerrors += 1 ;
X    }
X
X  /*
X   * Check for valid race: */
X  if ((race.race_type < FIRST_RACE_TYPE) ||
X      (race.race_type > LAST_RACE_TYPE)) {
X    FPRINTF(f, "Home planet type out of valid range.\n") ;
X    nerrors += 1 ;
X    }
X
X  /*
X   * Check for valid sector compats: */
X  if ((race.home_planet_type != H_JOVIAN)&&(race.compat[S_PLATED] != 100.0)) {
X    FPRINTF(f, "Non-jovian races must have 100%% plated compat.\n") ;
X    nerrors += 1 ;
X    }
X  for (i = FIRST_SECTOR_TYPE+1; i<=LAST_SECTOR_TYPE; i++) {
X    if (race.compat[i] < 0.0) {
X      FPRINTF(f, "Sector compatibility is at minimum 0%%.\n") ;
X      nerrors += 1 ;
X      }
X    if (race.compat[i] > 100.0) {
X      FPRINTF(f, "Sector compatibility may be at most 100%%.\n") ;
X      nerrors += 1 ;
X      }
X    if ((i == S_GAS) && (race.compat[i] != 0.0) &&
X	(race.home_planet_type != H_JOVIAN)) {
X      FPRINTF(f, "Non-jovian races may never have gas compatibility!\n") ;
X      nerrors += 1 ;
X      }
X    if ((i != S_GAS) && (race.compat[i] != 0.0) &&
X	(race.home_planet_type == H_JOVIAN)) {
X      FPRINTF(f, "Jovian races may have no compatibility other than gas!\n") ;
X      nerrors += 1 ;
X      }
X    /* A warning, but no error: */
X    if (race.compat[i] != ((double)((int)race.compat[i])))
X      FPRINTF(f, "Sector compatibilities are integral; truncated to %1.0f.\n",
X	     race.compat[i] = ((double)((int)race.compat[i]))) ;
X    }
X
X
X
X  if (rigorous_checking) {
X    /*
X     * Any rejection notice is an error: */
X    if (strlen(race.rejection)) {
X      FPRINTF(f, "%s", race.rejection) ;
X      nerrors += 1 ;
X      }
X    /*
X     * Check for valid password: */
X    if (MIN_PASSWORD_LENGTH > strlen(race.password)) {
X      FPRINTF(f, "Passwords are required to be at least %d characters long.\n",
X	      MIN_PASSWORD_LENGTH) ;
X      nerrors += 1 ;
X      }
X    /*
X     * Check that race isn't 'superrace': */
X    if (npoints < 0) {
X      FPRINTF(f, "You can't have negative points left!\n");
X      nerrors += 1 ;
X      }
X    /*
X     * Check that sector compats are reasonable. */
X    if ((race.home_planet_type != H_JOVIAN) && (race.n_sector_types == 1)) {
X      FPRINTF(f, "Non-jovian races must be compat with at least one sector type besides plated.\n") ;
X      nerrors += 1 ;
X      }
X    for (i=FIRST_SECTOR_TYPE; i<=LAST_SECTOR_TYPE; i++)
X      if ((planet_compat_cov[race.home_planet_type][i] == 1.0) &&
X	  (race.compat[i] == 100.0))
X	break ;
X    if (i == N_SECTOR_TYPES) {
X      FPRINTF(f, "You must have 100%% compat with at least one sector type that is common on\n  your home planet type.  (Marked with a '*')\n") ;
X      nerrors += 1 ;
X      }
X    }
X  if (race.status >= 0)
X    race.status = (nerrors == 0) ? STATUS_BALANCED : STATUS_UNBALANCED ;
X  return nerrors ;
X#undef FPRINTF
X  }
X
X
Xint critique_modification()
X{
X  int nerrors ;
X
X  race.rejection[0] = '\0' ;
X  nerrors = critique_to_file(stdout, 0, IS_PLAYER) ;
X  if (nerrors)
X    bcopy(&last, &race, sizeof(struct x)) ;
X  else
X    changed = altered = 1 ;
X  race.status = (nerrors == 0) ? STATUS_BALANCED : STATUS_UNBALANCED ;
X  return nerrors ;
X  }
X
X
X
X
X/**************
X * Initialize the race to the init value, and set the l_fudge values
X * accordingly so that the cost of this race's attributes is zero.
X */
Xvoid initialize()
X{
X  int i ;
X
X  bzero(&race, sizeof(race)) ;
X  for (i=FIRST_ATTRIBUTE; i<=LAST_ATTRIBUTE; i++)
X    race.attr[i] = attr[i].init ;
X  race.race_type = R_NORMAL ;
X  race.priv_type = P_NORMAL ;
X  race.home_planet_type = H_EARTH ;
X  race.n_sector_types = 1 ;
X  race.compat[S_PLATED] = 100 ;
X  strcpy(race.name, "Unknown") ;
X  strcpy(race.password, "XXX") ;
X  strcpy(race.address, TO) ;
X  normal() ;
X  bcopy(&race, &last, sizeof(struct x)) ;
X  cost_of_race() ;
X  for (i=FIRST_ATTRIBUTE; i<=LAST_ATTRIBUTE; i++)
X    attr[i].l_fudge += -cost.attr[i] ;
X  cost_of_race() ;
X#ifdef ENROLL
X  init_enroll() ;
X#endif
X  }
X
X
X
X/**************
X * Now the functions that implement racegen's commands.  Rather than me
X * trying to tell you about them here, just run the program and diddle
X * with it to get the idea.
X */
Xvoid help(argc, argv)
X     int argc ;
X     char *argv[] ;
X{
X#ifdef ENROLL
X  int enroll, process ;
X#endif
X  int i, j, helpp, load, modify, print, save, send, quit ;
X
X  if (argc == 1) {
X#ifdef ENROLL
X    enroll = process =
X#endif
X    helpp = load = modify = print = save = send = quit = 1 ;
X printf("\n") ;
X printf("To execute a command, type it at the command line.  All commands\n") ;
X printf("and command arguments maybe either upper or lower case, and/or\n") ;
X printf("abbreviated.  The available commands are:\n") ;
X    }
X  else {
X#ifdef ENROLL
X    enroll = process =
X#endif
X    helpp = load = modify = print = save = send = quit = 0 ;
X    for (i=1; i<argc; i++) {
X      j = strlen(argv[i]) ;
X#ifdef ENROLL
X      if      (! strncasecmp(argv[i], "enroll", j))
X	enroll = 1 ;   else
X#endif
X      if      (! strncasecmp(argv[i], "help", j))
X	helpp = 1 ;
X      else if (! strncasecmp(argv[i], "load", j))
X	load = 1 ;
X      else if (! strncasecmp(argv[i], "modify", j))
X	modify = 1 ;
X      else if (! strncasecmp(argv[i], "print", j))
X	print = 1 ;
X#ifdef ENROLL
X      else if (! strncasecmp(argv[i], "process", j))
X	process = 1 ;
X#endif
X      else if (! strncasecmp(argv[i], "save", j))
X	save = 1 ;
X      else if (! strncasecmp(argv[i], "send", j))
X	send = 1 ;
X      else if (! strncasecmp(argv[i], "quit", j))
X	quit = 1 ;
X      else {
X	printf("\n") ;
X	printf("\"%s\" is not a command.\n", argv[i]) ;
X	}
X      }
X    }
X    
X#ifdef ENROLL
X  if (enroll) {
X    printf("\n") ;
X    printf("Enroll\n") ;
X    printf("\t\t This command will add the current race to the game,\n") ;
X    printf("\t\t after checking to make sure it has all points spent, and\n") ;
X    printf("\t\t other such administrivia.\n") ;
X    }
X#endif
X
X  if (helpp) {
X    printf("\n") ;
X    printf("Help [command]*\n") ;
X    printf("\t\t This command gives you information about racegen's\n") ;
X    printf("\t\t commands.  If called with no arguments, it will print\n") ;
X    printf("\t\t information about all available commands.  Otherwise it\n") ;
X    printf("\t\t only prints information about the specified commands.\n") ;
X    }
X
X  if (load) {
X    printf("\n") ;
X    printf("Load [filename]\n") ;
X    printf("\t\t This command will load your race from the file specified\n") ;
X    printf("\t\t in the optional first argument, or from the file \"%s\"\n", 
X	   (race.filename[0] ? race.filename : SAVETO)) ;
X    printf("\t\t if no argument is given.\n") ;
X    }
X
X  if (modify) {
X    printf("\n") ;
X    printf("Modify arg1 arg2\n") ;
X    printf("\t\t This command allows you to change the values of your\n") ;
X    printf("\t\t race's name, password, type, attributes, planet, and compats.\n") ;
X    printf("\t\t The syntax is as follows:\n") ;
X    printf("\t\t   <modify>     ::= modify <attr> <value>\n") ;
X#ifdef ENROLL
X    printf("\t\t                  | modify from <string>\n") ;
X#endif
X    printf("\t\t                  | modify name <string>\n") ;
X    printf("\t\t                  | modify password <string>\n") ;
X    printf("\t\t                  | modify planet <planettype>\n") ;
X#ifdef ENROLL
X    printf("\t\t                  | modify privilege <privtype>\n") ;
X#endif
X    printf("\t\t                  | modify race <racetype>\n") ;
X    printf("\t\t                  | modify <sectortype> <value>\n") ;
X
X    printf("\t\t   <attribute>  ::= %s", attr[0].print_name) ;
X    for (i = FIRST_ATTRIBUTE+1; i<LAST_ATTRIBUTE; i++) {
X      printf(" | %s", attr[i].print_name) ;
X      if ((i % 3) == 2)
X	printf("\n\t\t                 ") ;
X      }
X    printf("\n") ;
X
X    printf("\t\t   <planettype> ::= %s", planet_print_name[0]) ;
X    for (i = FIRST_HOME_PLANET_TYPE+1; i<=min(4,LAST_HOME_PLANET_TYPE); i++)
X      printf(" | %s", planet_print_name[i]) ;
X    printf("\n\t\t                 ") ;
X    for (; i<=LAST_HOME_PLANET_TYPE; i++)
X      printf(" | %s", planet_print_name[i]) ;
X    printf("\n") ;
X
X    printf("\t\t   <racetype>   ::= %s", race_print_name[0]) ;
X    for (i = FIRST_RACE_TYPE+1; i<=LAST_RACE_TYPE; i++)
X      printf(" | %s", race_print_name[i]) ;
X    printf("\n") ;
X
X    printf("\t\t   <sectortype> ::= %s", sector_print_name[1]) ;
X    for (i = FIRST_SECTOR_TYPE+2; i<=min(5,LAST_SECTOR_TYPE); i++)
X      printf(" | %s", sector_print_name[i]) ;
X    printf("\n\t\t                 ") ;
X    for (; i<=LAST_SECTOR_TYPE; i++)
X      printf(" | %s", sector_print_name[i]) ;
X    printf("\n") ;
X    }
X
X  if (print) {
X    printf("\n") ;
X    printf("Print [filename]\n") ;
X    printf("\t\t With no argument, this command prints your race to the\n") ;
X    printf("\t\t screen.  It is automatically executed after each modify.\n") ;
X    printf("\t\t Otherwise it saves a text copy of your race to the file\n") ;
X    printf("\t\t specified in the first argument.\n") ;
X    }
X
X#ifdef ENROLL
X  if (process) {
X    printf("\n") ;
X    printf("Process filename\n") ;
X    printf("\t\t This command will repeatedly load races from filename,\n") ;
X    printf("\t\t and then try to enroll them.  You can thus easily \n") ;
X    printf("\t\t enroll tens of players at once.  \n") ;
X    }
X#endif
X
X  if (save) {
X    printf("\n") ;
X    printf("Save [filename]\n") ;
X    printf("\t\t This command will save your race to the file specified in\n");
X    printf("\t\t the optional first argument, or to the file \"%s\"\n", 
X	   (race.filename[0] ? race.filename : SAVETO)) ;
X    printf("\t\t if no argument is given.\n") ;
X    }
X
X  if (send) {
X    printf("\n") ;
X    printf("Send\n") ;
X    printf("\t\t This command will send your race to God, (%s).\n", TO) ;
X    printf("\t\t It will not work unless you have spent all your points.\n") ;
X    }
X
X  if (quit) {
X    printf("\n") ;
X    printf("Quit\n") ;
X    printf("\t\t This command will prompt you to save your work if you\n") ;
X    printf("\t\t haven't already, and then exit this program.\n") ;
X    }
X
X  printf("\n") ;
X  }
X
X
X/*
X * Return non-zero on failure, zero on success. */
Xint load_from_file(g)
X     FILE *g ;
X{
X  int i ;
X  char buf[80], from_address[80] ;
X
X#define FSCANF(file, format, variable) \
X  if (EOF == fscanf((file), (format), (variable))) \
X    goto premature_end_of_file
X  
X  do {
X    FSCANF(g, " %s", buf) ;
X    if (0 == strcmp(buf, "From:")) {
X      FSCANF(g, " %s", buf) ;
X      strcpy(from_address, buf) ;
X      }
X    }
X  while (strcmp(buf, START_RECORD_STRING)) ;
X
X  race.status = STATUS_BALANCED ;
X  FSCANF(g, " %s", race.address) ;
X  if (from_address[0])
X    strcpy(race.address, from_address) ;
X  FSCANF(g, " %s", race.name) ;
X  FSCANF(g, " %s", race.password) ;
X  FSCANF(g, " %d", &race.priv_type) ;
X  FSCANF(g, " %d", &race.home_planet_type) ;
X  FSCANF(g, " %d", &race.race_type) ;
X  if (race.race_type == R_NORMAL)
X    normal() ;
X  else
X    metamorph() ;
X  for (i=FIRST_ATTRIBUTE; i<=LAST_ATTRIBUTE; i++)
X    FSCANF(g, " %lf", &race.attr[i]) ;
X  fix_up_iq() ;
X  for (i=FIRST_SECTOR_TYPE;  i<=LAST_SECTOR_TYPE; i++)
X    FSCANF(g, " %lf", &race.compat[i]) ;
X  do {
X    FSCANF(g, " %s", buf) ;
X    }
X  while (strcmp(buf, END_RECORD_STRING)) ;
X  return 0 ;
X premature_end_of_file:
X  printf("Error: premature end of file.\n") ;
X  return 1 ;
X  }
X
X/*
X * Return non-zero on failure, zero on success. */
Xstatic int load_from_filename(filename)
X     char *filename ;
X{
X  int ret ;
X  FILE *f = fopen(filename, "r") ;
X
X  if (f == NULL) {
X    printf("Unable to open file \"%s\".\n", filename) ;
X    return 1 ;
X    }
X  ret = load_from_file(f) ;
X  fclose(f) ;
X  return ret ;
X  }
X
Xvoid load(argc, argv)
X     int argc ;
X     char *argv[] ;
X{
X  char c[64] ;
X  int i ;
X
X  bcopy(&race, &last, sizeof(struct x)) ;
X  if (altered) {
X    i = Dialogue("This race has been altered; load anyway?", "yes", "no", 0) ;
X    if (i == 1)
X      return ;
X    }
X  if (argc > 1)
X    strcpy(c, argv[1]) ;
X  else if (! race.filename[0])
X    strcpy(c, SAVETO) ;
X  if (load_from_filename(c)) {
X    printf("Load from file \"%s\" failed.\n", c) ;
X    bcopy(&last, &race, sizeof(struct x)) ;
X    }
X  else {
X    printf("Loaded race from file \"%s\".\n", c) ;
X    strcpy(race.filename, c) ;
X    altered = 0 ;
X    changed = 1 ;
X    }
X  }
X
Xint modify(argc, argv)
X     int argc ;
X     char *argv[] ;
X{
X  int i, j ;
X  static char *help_strings[2] = {NULL, "modify"} ;
X  double f ;
X
X  if (argc < 3) {
X    help(2, help_strings) ;
X    return -1 ;
X    }
X  j = strlen(argv[1]) ;
X
X  bcopy(&race, &last, sizeof(struct x)) ;
X
X  /*
X   * Check for attribute modification: */
X  for (i = FIRST_ATTRIBUTE; i<=LAST_ATTRIBUTE; i++)
X    if (! strncasecmp(argv[1], attr[i].print_name, j)) {
X      if (attr[i].is_integral == 2) {    /* Boolean attribute. */
X	j = strlen(argv[2]) ;
X	if (! strncasecmp(argv[2], "no", j))
X	  f = 0.0 ;
X	else if (! strncasecmp(argv[2], "yes", j))
X	  f = 1.0 ;
X	else
X	  f = atof(argv[2]) ;
X	}
X      else
X	f = atof(argv[2]) ;
X      
X      race.attr[i] = f ;
X      fix_up_iq() ;
X      return critique_modification() ;
X      }
X
X  /*
X   * Check for name modification:  */
X  if (! strncasecmp(argv[1], "name", j)) {
X    strcpy(race.name, argv[2]) ;
X    return critique_modification() ;
X    }
X
X#ifdef ENROLL
X  /*
X   * Check for from-address modification:  */
X  if (! strncasecmp(argv[1], "from:", j)) {
X    strcpy(race.address, argv[2]) ;
X    return critique_modification() ;
X    }
X  /*
X   * Check for privilege modification:  */
X  if (! strncasecmp(argv[1], "privilege", j)) {
X    j = strlen(argv[2]) ;
X    for (i = FIRST_PRIV_TYPE; i<=LAST_PRIV_TYPE; i++)
X      if (! strncasecmp(argv[2], priv_print_name[i], j)) {
X	race.priv_type = i ;
X	return critique_modification() ;
X	}
X    race.priv_type = atof(argv[2]) ;
X    return critique_modification() ;
X    }
X#endif
X
X  /*
X   * Check for planet modification:  */
X  if (! strncasecmp(argv[1], "planet", j)) {
X    j = strlen(argv[2]) ;
X    for (i = FIRST_HOME_PLANET_TYPE; i<=LAST_HOME_PLANET_TYPE; i++)
X      if (! strncasecmp(argv[2], planet_print_name[i], j)) {
X	if (i == H_JOVIAN) {
X	  bzero(race.compat, sizeof(race.compat)) ;
X	  race.compat[S_GAS] = 100.0 ;
X	  }
X	else if (race.home_planet_type == H_JOVIAN) {
X	  race.compat[S_PLATED] = 100.0 ;
X	  race.compat[S_GAS] = 0.0 ;
X	  }
X	race.home_planet_type = i ;
X	return critique_modification() ;
X	}
X    printf("\"%s\" is not a valid planet type.\n", argv[2]) ;
X    return -1 ;
X    }
X
X  /*
X   * Check for password modification:  */
X  if (! strncasecmp(argv[1], "password", j)) {
X    strcpy(race.password, argv[2]) ;
X    return critique_modification() ;
X    }
X
X  /*
X   * Check for race modification:  */
X  if (! strncasecmp(argv[1], "race", j)) {
X    j = strlen(argv[2]) ;
X    for (i = FIRST_RACE_TYPE; i<=LAST_RACE_TYPE; i++)
X      if (! strncasecmp(argv[2], race_print_name[i], j)) {
X	if (i == R_METAMORPH) {
X	  race.attr[ABSORB] = 1 ;
X	  race.attr[PODS] = 1 ;
X	  race.attr[COL_IQ] = 1 ;
X	  race.attr[SEXES] = 1 ;
X	  race.attr[A_IQ] = DEFAULT_MESO_IQ_LIMIT ;
X	  metamorph() ;
X	  }
X	else {
X	  race.attr[ABSORB] = 0 ;
X	  race.attr[PODS] = 0 ;
X	  race.attr[COL_IQ] = 0 ;
X	  race.attr[SEXES] = 2 ;
X	  race.attr[A_IQ] = 125 ;
X	  normal() ;
X	  }
X	race.race_type = i ;
X	return critique_modification() ;
X	}
X    printf("\"%s\" is not a valid race type.\n", argv[2]) ;
X    return -1 ;
X    }
X
X
X  /*
X   * Check for sector_type modification: */
X  for (i = FIRST_SECTOR_TYPE; i<=LAST_SECTOR_TYPE; i++)
X#ifndef ENROLL
X    if (i == S_PLATED)
X      continue ;    /* Players should never need to modify this. */
X    else
X#endif
X    if (! strncasecmp(argv[1], sector_print_name[i], j)) {
X      race.compat[i] = atof(argv[2]) ;
X      return critique_modification() ;
X      }
X  
X  /*
X   * Print error */
X  printf("\n") ;
X  printf("Modify: didn't recognize the first argument \"%s\".\n", argv[1]) ;
X  printf("Type \"help modify\" for more information on modify.\n") ;
X  printf("\n") ;
X  return -1 ;
X  }
X
Xvoid print_to_file(f, verbose)
X     FILE *f ;
X     int verbose ;
X{
X#define FPRINTF if (verbose) fprintf
X  int i ;
X
X#ifdef ENROLL
X  FPRINTF(f, "From:") ;
X#endif
X  if (! verbose) {
X    fprintf(f, START_RECORD_STRING) ;
X    fprintf(f, " %s", race.address) ;
X    }
X#ifdef ENROLL
X  else
X    fprintf(f, " %s", race.address) ;
X#endif
X  FPRINTF(f, "\n") ;
X
X  FPRINTF(f, "Name:") ;
X  fprintf(f, " %16.16s", race.name) ;
X  FPRINTF(f, "\n") ;
X
X  FPRINTF(f, "Password:") ;
X  fprintf(f, " %12.12s", race.password) ;
X  FPRINTF(f, "\n") ;
X
X#ifdef ENROLL
X  FPRINTF(f, "Privileges:") ;
X  if (verbose)
X    fprintf(f, "%11.11s", priv_print_name[race.priv_type]) ;
X  else
X#endif
X  if (! verbose)
X    fprintf(f, " %d", race.priv_type) ;
X#ifdef ENROLL
X  FPRINTF(f, "\n") ;
X#endif
X
X  FPRINTF(f, "Home Planet:") ;
X  if (verbose)
X    fprintf(f, " %9.9s", planet_print_name[race.home_planet_type]) ;
X  else
X    fprintf(f, " %d", race.home_planet_type) ;
X  FPRINTF(f, "  [%4d]\n", cost.home_planet_type) ;
X
X  FPRINTF(f, "Race type:") ;
X  if (verbose)
X    fprintf(f, "%12.12s", race_print_name[race.race_type]) ;
X  else
X    fprintf(f, " %d", race.race_type) ;
X  FPRINTF(f, "  [%4d]\n", cost.race_type) ;
X  FPRINTF(f, "\n") ;
X
X  FPRINTF(f, "Attributes:\n") ;
X  for (i=FIRST_ATTRIBUTE; i<=LAST_ATTRIBUTE; i++) {
X    FPRINTF(f, "%13.13s:", attr[i].print_name) ;
X    if (verbose && (attr[i].is_integral == 2))
X      fprintf(f, (race.attr[i] > 0.0) ? "  yes   " : "   no   ") ;
X    else
X      fprintf(f, " %7.2f", race.attr[i]) ;
X    FPRINTF(f, "  [%4.0f]", cost.attr[i]) ;
X    FPRINTF(f, (i & 01) ? "\n" : "     ") ;
X    }
X  if (i & 01)
X    FPRINTF(f, "\n") ;
X  FPRINTF(f, "\n") ;
X
X  FPRINTF(f, "Sector Types:    %2d     [%4d]\n", 
X	  race.n_sector_types, cost.n_sector_types) ;
X  for (i=FIRST_SECTOR_TYPE;  i<=LAST_SECTOR_TYPE; i++) {
X    FPRINTF(f, "%13.13s: ", sector_print_name[i]) ;
X    fprintf(f, " %3.0f", race.compat[i]) ;
X    FPRINTF(f, "%%   %c[%4.0f]", 
X	    (planet_compat_cov[race.home_planet_type][i] == 1.0) ? '*' : ' ',
X	    cost.compat[i]) ;
X    FPRINTF(f, (i & 01) ? "\n" : "     ") ;
X    }
X
X  if (! verbose)
X    fprintf(f, END_RECORD_STRING) ;
X  FPRINTF(f, "\n") ;
X  FPRINTF(f, "Points left: %d          Previous value: %d\n", 
X	  npoints, last_npoints) ;
X  fprintf(f, "\n") ;
X#undef FPRINTF
X  }
X
Xstatic int print_to_filename(filename, verbose)
X     char *filename ;
X     int verbose ;
X{
X  FILE *f = fopen(filename, "w") ;
X
X  if (f == NULL) {
X    printf("Unable to open file \"%s\".\n", filename) ;
X    return 0 ;
X    }
X  print_to_file(f, verbose) ;
X  fclose(f) ;
X  return 1 ;
X  }
X
Xvoid print(argc, argv)
X     int argc ;
X     char *argv[] ;
X{
X  if (argc == 1)
X    print_to_file(stdout, 1) ;
X  else if (print_to_filename(argv[1], 1))
X    printf("Printed race to file \"%s\".\n", argv[1]) ;
X  }
X
Xvoid save(argc, argv)
X     int argc ;
X     char *argv[] ;
X{
X  if (argc > 1)
X    strcpy(race.filename, argv[1]) ;
X  else if (! race.filename[0])
X    strcpy(race.filename, SAVETO) ;
X  if (print_to_filename(race.filename, 0)) {
X    printf("Saved race to file \"%s\".\n", race.filename) ;
X    altered = 0 ;
X    }
X  }
X
Xvoid send(argc, argv)
X     int argc ;
X     char *argv[] ;
X{
X  FILE *f ;
X  char sys[64] ;
X
X  bcopy(&race, &last, sizeof(struct x)) ;
X  if (critique_to_file(stdout, 1, IS_PLAYER))
X    return ;
X
X  f = fopen(TMP, "w") ;
X  if (f == NULL) {
X    printf("Unable to open file \"%s\".\n", TMP) ;
X    return ;
X    }
X  fprintf(f, "To: %s\n", race.address) ;
X  fprintf(f, "Subject: %s Race Submission\n", GAME) ;
X  fprintf(f, "\n") ;
X  print_to_file(f, 0) ;
X  fclose(f) ;
X
X  printf("Sending to %s via %s...", TO, MAILER) ;
X  fflush(stdout) ;
X  sprintf(sys, "cat %s | %s %s", TMP, MAILER, TO) ;
X  system(sys) ;
X  printf("done.\n") ;
X  }
X
Xint Dialogue(prompt, va_alist)
X     char *prompt;
X		 va_dcl 
X{
X	va_list ap;
X  char input[128] ;
X  char *carg;
X	int len, i, argc = 0 ;
X  int init = 0;
X	char *argv[16] ;
X  printf("%s", prompt) ;
X  va_start(ap);
X	while ((carg = va_arg(ap, char *))!=0) {
X    if (!init) {
X			printf(" [%s", carg) ;
X			init = 1;
X		} else {
X			printf("/%s", carg);
X		}
X    argv[argc++] = carg++ ;
X  }
X	va_end(ap);
X  if (argc)
X    printf("]") ;
X  printf("> ") ;
X  while (1) {
X    fgets(input, 128, stdin) ;
X    if (argc == 0)
X      return -1 ;
X    len = strlen(input) - 1 ;
X    
X    for (i = 0; i < argc; i++)
X      if (! strncasecmp(argv[i], input, len))
X	return i ;
X    /*
X     * The input did not match any of the valid responses: */
X    printf("Please enter ") ;
X    for (i = 0; i < argc-1; i++)
X      printf("\"%s\", ", argv[i]) ;
X    printf("or \"%s\"> ", argv[i]) ;
X    }
X  }
X
X
Xvoid quit(argc, argv)
X     int argc ;
X     char *argv[] ;
X{
X  int i ;
X
X  if (please_quit)  /* This could happen if ^c is hit while here. */
X    exit(0) ;
X  please_quit = 1 ;
X  if (altered) {
X    i = Dialogue("Save this race before quitting?", "yes", "no", "abort", 0) ;
X    if (i == 0)   
X      save(1, NULL) ;
X    else if (i == 2)
X      please_quit = 0 ;
X    }
X  }
X
X
X
Xstatic void control_c_handler()
X{
X  printf("\n") ;
X  exit(0) ;
X  }
X
X
X/**************
X * This function merely takes the space-parsed command line and executes
X * one of the commands above.
X */
Xvoid execute(argc, argv)
X     int argc ;
X     char *argv[] ;
X{
X  int i ;
X
X#if 0
X  for (i=0; i < argc; i++)
X    printf("%d: \"%s\"\n", i, argv[i]) ;
X#endif
X  if (argc == 0) {
X    printf("Type \"help\" for help.\n") ;
X    return ;
X    }
X  i = strlen(argv[0]) ;
X#ifdef ENROLL
X  if      (! strncasecmp(argv[0], "enroll", i))
X    enroll(argc, argv) ;
X  else
X#endif
X  if      (! strncasecmp(argv[0], "help", i))
X    help(argc, argv) ;
X  else if (! strncasecmp(argv[0], "load", i))
X    load(argc, argv) ;
X  else if (! strncasecmp(argv[0], "modify", i))
X    modify(argc, argv) ;
X  else if (! strncasecmp(argv[0], "print", i))
X    print(argc, argv) ;
X#ifdef ENROLL
X  else if (! strncasecmp(argv[0], "process", i))
X    process(argc, argv) ;
X#endif
X  else if (! strncasecmp(argv[0], "save", i))
X    save(argc, argv) ;
X  else if (! strncasecmp(argv[0], "send", i))
X    send(argc, argv) ;
X  else if (! strncasecmp(argv[0], "quit", i))
X    quit(argc, argv) ;
X  else {
X    printf("Unknown command \"%s\".  Type \"help\" for help.\n", argv[0]) ;
X    return ;
X    }
X  }
X
X
X
X
X/**************
X * Here is the main loop, where I print the command prompt, parse it into
X * words using spaces as the separator, and call execute.  Level is the
X * number of higher level modify print loops above this one.  It will
X * always be zero for player racegens.
X */
Xvoid modify_print_loop(level)
X     int level ;
X{
X  char buf[128], *com, *args[4] ;
X  int i ;
X
X  while (! please_quit) {
X    last_npoints = npoints ;
X    npoints = STARTING_POINTS - cost_of_race() ;
X
X    if (changed) {
X      print_to_file(stdout, 1) ;
X      changed = 0 ;
X      }
X#ifdef ENROLL
X    printf("%s [enroll/help/load/modify/print/process/save/send/quit]> ",
X	   level ? "Fix" : "Command") ;
X#else
X    printf("Command [help/load/modify/print/save/send/quit]> ") ;
X#endif
X    fflush(stdout) ;
X    com = fgets(buf, 128, stdin) ;
X    buf[strlen(buf)-1] = '\0' ;
X
X    for (i=0; i<4; i++) {
X      while (*com && (*com == ' '))   
X	*com++ = '\0' ;
X      if (! *com)
X	break ;
X      args[i] = com ;
X      while (*com && (*com != ' '))   
X	com++ ;
X      }
X    execute(i, args) ;
X    }
X  printf("\n") ;
X  }
X
X
X/**************
X * Print out initial info and then call modify-print loop.
X */
Xint main(argc, argv)
X     int argc ;
X     char *argv[] ;
X{
X  signal(SIGINT, control_c_handler) ;
X  signal(SIGQUIT, control_c_handler) ;
X  initialize() ;
X  printf("\n") ;
X  printf("\n") ;
X  printf("Galactic Bloodshed Race Generator %s\n", GBVERSION) ;
X  printf("\n") ;
X  printf("Finished races will be sent to %s.\n", TO) ;
X  printf("***************************************************************\n") ;
X  printf("Game: %s, using %s\n", GAME, GB_VERSION) ;
X  printf("Address: %s\n", LOCATION) ;
X  printf("God: %s\n", MODERATOR) ;
X  printf("Starts: %s\n", STARTS) ;
X  printf("Stars: %s; Players: %s\n", STARS, PLAYERS) ;
X  printf("Any race may be refused or modified by God for any reason!\n") ;
X  printf("\n") ;
X  printf("DEADLINE: %s\n", DEADLINE) ;
X  printf("***************************************************************\n") ;
X  printf("Update schedule:\n") ;
X  printf("%s\n", UPDATE_SCH) ;
X  printf("\n") ;
X  printf("If you cannot make this update schedule, do NOT send in a race!\n") ;
X  printf("***************************************************************\n") ;
X  printf(OTHER_STUFF) ;
X  printf("\n") ;
X  Dialogue("Hit return", 0) ;
X 
X  modify_print_loop(0) ;
X
X  return 0 ;
X  }
END_OF_FILE
if test 39848 -ne `wc -c <'utils/racegen.c'`; then
    echo shar: \"'utils/racegen.c'\" unpacked with wrong size!
fi
# end of 'utils/racegen.c'
fi
echo shar: End of archive 1 \(of 21\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
