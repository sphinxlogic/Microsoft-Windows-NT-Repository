Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v17i021:  gbp - Galactic Bloodshed+, an empire-like war game, Part09/21
Message-ID: <4549@master.CNA.TEK.COM>
Date: 12 Feb 93 17:31:08 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1794
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1700

Submitted-by: deragon@harpo.cs.nyu.edu (Seeker)
Posting-number: Volume 17, Issue 21
Archive-name: gbp/Part09
Supersedes: gb3: Volume 10, Issue 1-14
Environment: sockets, curses



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 21)."
# Contents:  server/shlmisc.c user/move.c
# Wrapped by billr@saab on Fri Feb 12 09:14:26 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'server/shlmisc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/shlmisc.c'\"
else
echo shar: Extracting \"'server/shlmisc.c'\" \(22987 characters\)
sed "s/^X//" >'server/shlmisc.c' <<'END_OF_FILE'
X/*
X * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky,
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. Restrictions in
X * GB_copyright.h.
X * 
X * miscellaneous stuff included in the shell
X */
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "races.h"
X#include "power.h"
X#include "ships.h"
X#include "buffers.h"
X#include <curses.h>
X#include <signal.h>
X#include <ctype.h>
X#include <stdio.h>
X#include <math.h>
X#include <time.h>
X
Xchar           *Ship(shiptype * s);
Xvoid            grant(int, int, int);
Xvoid            governors(int, int, int);
Xvoid            do_revoke(racetype *, int, int);
Xint             authorized(int, shiptype *);
Xint             start_shiplist(int, int, char *);
Xint             do_shiplist(shiptype **, int *);
Xint             in_list(int, char *, shiptype *, int *);
Xvoid            fix(int, int);
Xint             match(char *, char *);
Xvoid            DontOwnErr(int, int, int);
Xint             enufAP(int, int, unsigned short, int);
Xint             Getracenum(char *, char *, int *, int *);
Xint             GetPlayer(char *);
Xvoid            allocateAPs(int, int, int);
Xvoid            deductAPs(int, int, int, int, int);
Xvoid            list(int, int);
Xdouble          morale_factor(double);
X#if DEBUG
Xchar           *DEBUGmalloc(int, char *, int);
Xvoid            DEBUGfree(char *);
Xchar           *DEBUGrealloc(char *, int, char *, int);
Xvoid            DEBUGcheck(int, int);
Xvoid            DEBUGreset(int, int);
X#endif
X#include "proto.h"
X
Xchar           *
XShip(shiptype * s)
X{
X	adr = !adr;		/* switch between 0 and 1 - adr is a global
X				 * variable */
X	sprintf(junk[adr], "%c%d %s [%d]",
X		Shipltrs[s->type], s->number, s->name, s->owner);
X	return junk[adr];	/* junk is a global buffer */
X}
X
Xvoid 
Xgrant(int Playernum, int Governor, int APcount)
X{
X	racetype       *Race;
X	int             gov, nextshipno, shipno;
X	shiptype       *ship;
X
X
X	Race = races[Playernum - 1];
X	if (argn < 3) {
X		notify(Playernum, Governor, "Syntax: grant <governor> star\n");
X		notify(Playernum, Governor, "        grant <governor> ship <shiplist>\n");
X		notify(Playernum, Governor, "        grant <governor> money <amount>\n");
X		return;
X	}
X	if ((gov = atoi(args[1])) < 0 || gov > MAXGOVERNORS) {
X		notify(Playernum, Governor, "Bad governor number.\n");
X		return;
X	} else if (!Race->governor[gov].active) {
X		notify(Playernum, Governor, "That governor is not active.\n");
X		return;
X	} else if (match(args[2], "star")) {
X		int             snum;
X		if (Dir[Playernum - 1][Governor].level != LEVEL_STAR) {
X			notify(Playernum, Governor, "Please cs to the star system first.\n");
X			return;
X		}
X		snum = Dir[Playernum - 1][Governor].snum;
X		Stars[snum]->governor[Playernum - 1] = gov;
X		sprintf(buf, "\"%s\" has granted you control of the /%s star system.\n",
X			Race->governor[Governor].name, Stars[snum]->name);
X		warn(Playernum, gov, buf);
X		putstar(Stars[snum], snum);
X	} else if (match(args[2], "ship")) {
X		nextshipno = start_shiplist(Playernum, Governor, args[3]);
X		while (shipno = do_shiplist(&ship, &nextshipno))
X			if (in_list(Playernum, args[3], ship, &nextshipno) &&
X			    authorized(Governor, ship)) {
X				ship->governor = gov;
X				sprintf(buf, "\"%s\" granted you %s at %s\n",
X				  Race->governor[Governor].name, Ship(ship),
X					prin_ship_orbits(ship));
X				warn(Playernum, gov, buf);
X				putship(ship);
X				sprintf(buf, "%s granted to \"%s\"\n",
X				      Ship(ship), Race->governor[gov].name);
X				notify(Playernum, Governor, buf);
X				free(ship);
X			} else
X				free(ship);
X	} else if (match(args[2], "money")) {
X		int             amount;
X		if (argn < 4) {
X			notify(Playernum, Governor, "Indicate the amount of money.\n");
X			return;
X		}
X		amount = atoi(args[3]);
X		if (amount < 0 && Governor) {
X			notify(Playernum, Governor, "Only leaders may make take away money.\n");
X			return;
X		}
X
X/*
X		if (amount > Race->governor[Governor].money)
X			amount = Race->governor[Governor].money;
X		else if (-amount > (int)Race->governor[gov].money)
X			amount = (int)-Race->governor[gov].money; 
X*/
X
X	if ((long)amount > Race->governor[Governor].money &&
X		(long)-amount > -Race->governor[Governor].money) {
X			notify(Playernum, Governor, "Illegal amount\n");
X			return;
X	}
X		
X		printf("Amount is %d\n", amount);	
X
X		if (amount > 0) { /* add to a gov */
X			sprintf(buf, "\"%s\" granted you %d money.\n",
X				Race->governor[Governor].name, amount);
X			warn(Playernum, gov, buf);
X			Race->governor[Governor].money -= abs(amount);
X			Race->governor[gov].money += abs(amount);
X		} else if (amount < 0) {  /* deduct from a gov */
X			sprintf(buf, "\"%s\" docked you %d money.\n",
X				Race->governor[Governor].name, -amount);
X			warn(Playernum, gov, buf);
X			Race->governor[Governor].money += abs(amount);
X			Race->governor[gov].money -= abs(amount);
X			
X		}
X		putrace(Race);
X		return;
X	} else
X		notify(Playernum, Governor, "You can't grant that.\n");
X
X}
X
Xvoid 
Xgovernors(int Playernum, int Governor, int APcount)
X{
X	racetype       *Race;
X	reg int         i;
X	int             gov;
X
X	Race = races[Playernum - 1];
X	if (Governor || argn < 3) {	/* the only thing governors can do
X					 * with this */
X		for (i = 0; i <= MAXGOVERNORS; i++) {
X			if (Governor)
X				sprintf(buf, "%d %-15.15s %8s %10d %s",
X					i, Race->governor[i].name,
X					Race->governor[i].active ? "ACTIVE" : "INACTIVE",
X					Race->governor[i].money,
X					ctime(&Race->governor[i].login));
X			else
X				sprintf(buf, "%d %-15.15s %-10.10s %8s %10d %s",
X					i, Race->governor[i].name,
X					Race->governor[i].password,
X					Race->governor[i].active ? "ACTIVE" : "INACTIVE",
X					Race->governor[i].money,
X					ctime(&Race->governor[i].login));
X			notify(Playernum, Governor, buf);
X		}
X	} else if ((gov = atoi(args[1])) < 0 || gov > MAXGOVERNORS) {
X		notify(Playernum, Governor, "No such governor.\n");
X		return;
X	} else if (match(args[0], "appoint")) {
X		/* Syntax: 'appoint <gov> <password>' */
X		if (Race->governor[gov].active) {
X			notify(Playernum, Governor, "That governor is already appointed.\n");
X			return;
X		}
X		Race->governor[gov].active = 1;
X		Race->governor[gov].homelevel = Race->governor[gov].deflevel =
X			Race->governor[0].deflevel;
X		Race->governor[gov].homesystem = Race->governor[gov].defsystem =
X			Race->governor[0].defsystem;
X		Race->governor[gov].homeplanetnum = Race->governor[gov].defplanetnum =
X			Race->governor[0].defplanetnum;
X		Race->governor[gov].money = 0;
X		Race->governor[gov].toggle.highlight = Playernum;
X		Race->governor[gov].toggle.inverse = 1;
X		strncpy(Race->governor[gov].password, args[2], RNAMESIZE - 1);
X		putrace(Race);
X		notify(Playernum, Governor, "Governor activated.\n");
X		return;
X	} else if (match(args[0], "revoke")) {
X		reg int         j;
X		if (!gov) {
X			notify(Playernum, Governor, "You can't revoke your leadership!\n");
X			return;
X		}
X		if (!Race->governor[gov].active) {
X			notify(Playernum, Governor, "That governor is not active.\n");
X			return;
X		}
X		if (argn < 4)
X			j = 0;
X		else
X			j = atoi(args[3]);	/* who gets this governors
X						 * stuff */
X		if (j < 0 || j > MAXGOVERNORS) {
X			notify(Playernum, Governor, "You can't give stuff to that governor!\n");
X			return;
X		}
X		if (!strcmp(Race->governor[gov].password, args[2])) {
X			notify(Playernum, Governor, "Incorrect password.\n");
X			return;
X		}
X		if (!Race->governor[j].active || j == gov) {
X			notify(Playernum, Governor, "Bad target governor.\n");
X			return;
X		}
X		do_revoke(Race, gov, j);	/* give stuff from gov to j */
X		putrace(Race);
X		notify(Playernum, Governor, "Done.\n");
X		return;
X	} else if (match(args[2], "password")) {
X		if (Race->Guest) {
X			notify(Playernum, Governor, "Guest races cannot change passwords.\n");
X			return;
X		}
X		if (argn < 4) {
X			notify(Playernum, Governor, "You must give a password.\n");
X			return;
X		}
X		if (!Race->governor[gov].active) {
X			notify(Playernum, Governor, "That governor is inactive.\n");
X			return;
X		}
X		strncpy(Race->governor[gov].password, args[3], RNAMESIZE - 1);
X		putrace(Race);
X		notify(Playernum, Governor, "Password changed.\n");
X		return;
X	} else
X		notify(Playernum, Governor, "Bad option.\n");
X}
X
Xvoid 
Xdo_revoke(racetype * Race, int gov, int j)
X{
X	register int    i;
X	char            revoke_buf[1024];
X	shiptype       *ship;
X
X	sprintf(revoke_buf, "*** Transferring [%d,%d]'s ownings to [%d,%d] ***\n\n", Race->Playernum, gov, Race->Playernum, j);
X	notify(Race->Playernum, 0, revoke_buf);
X
X	/* First do stars....  */
X
X	for (i = 0; i < Sdata.numstars; i++)
X		if (Stars[i]->governor[Race->Playernum - 1] == gov) {
X			Stars[i]->governor[Race->Playernum - 1] = j;
X			sprintf(revoke_buf, "Changed juridiction of /%s...\n", Stars[i]->name);
X			notify(Race->Playernum, 0, revoke_buf);
X			putstar(Stars[i], i);
X		}
X	/* Now do ships....  */
X	Num_ships = Numships();
X	for (i = 1; i <= Num_ships; i++) {
X		(void) getship(&ship, i);
X		if (ship->alive && (ship->owner == Race->Playernum) &&
X		    (ship->governor == gov)) {
X			ship->governor = j;
X			sprintf(revoke_buf, "Changed ownership of %c%d...\n", Shipltrs[ship->type], i);
X			notify(Race->Playernum, 0, revoke_buf);
X			putship(ship);
X		}
X		free(ship);
X	}
X
X	/* And money too....  */
X
X	sprintf(revoke_buf, "Transferring %d money...\n", Race->governor[gov].money);
X	notify(Race->Playernum, 0, revoke_buf);
X	Race->governor[j].money = Race->governor[j].money + Race->governor[gov].money;
X	Race->governor[gov].money = 0;
X
X	/* And last but not least, flag the governor as inactive.... */
X
X	Race->governor[gov].active = 0;
X	strcpy(Race->governor[gov].password, "");
X	strcpy(Race->governor[gov].name, "");
X	sprintf(revoke_buf, "\n*** Governor [%d,%d]'s powers have been REVOKED ***\n", Race->Playernum, gov);
X	notify(Race->Playernum, 0, revoke_buf);
X	sprintf(revoke_buf, "rm %s.%d.%d", TELEGRAMFL, Race->Playernum, gov);
X	system(revoke_buf);	/* Remove the telegram file too....  */
X
X	return;
X}
X
Xint 
Xauthorized(int Governor, shiptype * ship)
X{
X	return (!Governor || ship->governor == Governor);
X}
X
Xint 
Xstart_shiplist(int Playernum, int Governor, char *string)
X{
X	char           *p;
X	planettype     *planet;
X	shiptype       *ship;
X	int             st, pl, sh;
X	p = string;
X
X	if (*p == '#')
X		return (atoi(++p));
X	if (isdigit(*p))
X		return (atoi(p));
X
X	/* ship number not given */
X	st = Dir[Playernum - 1][Governor].snum;
X	pl = Dir[Playernum - 1][Governor].pnum;
X	switch (Dir[Playernum - 1][Governor].level) {
X	case LEVEL_UNIV:
X		getsdata(&Sdata);
X		return Sdata.ships;
X	case LEVEL_STAR:
X		getstar(&Stars[st], st);	/* Stars doesn't need to be
X						 * freed */
X		return Stars[st]->ships;
X	case LEVEL_PLAN:
X		getplanet(&planet, st, pl);
X		sh = planet->ships;
X		free(planet);
X		return sh;
X	case LEVEL_SHIP:
X		(void) getship(&ship, Dir[Playernum - 1][Governor].shipno);
X		sh = ship->ships;
X		free(ship);
X		return sh;
X	default:
X		break;
X	}
X	return 0;
X}
X
X/* Step through linked list at current player scope */
Xint 
Xdo_shiplist(shiptype ** s, int *nextshipno)
X{
X	int             shipno;
X
X	if (!(shipno = *nextshipno))
X		return 0;
X
X	if (!getship(s, shipno))/* allocate memory, free in loop */
X		return 0;
X
X	if (!(*s)->alive)	/* this prevents it from returning a dead
X				 * ship */
X		return 0;	/* ie: try to scrap a dead ship   JPD          */
X
X	*nextshipno = (*s)->nextship;
X	return shipno;
X}
X
Xint 
Xin_list(int Playernum, char *list, shiptype * s, int *nextshipno)
X{
X	char           *p, q;
X	if (s->owner != Playernum || !s->alive)
X		return 0;
X	q = Shipltrs[s->type];
X	p = list;
X	if (*p == '#' || isdigit(*p)) {
X		if (s->owner != Playernum || !s->alive)
X			return 0;
X		*nextshipno = 0;
X		return s->number;
X	}
X	for (; *p; p++)
X		if (*p == q || *p == '*')
X			return s->number;	/* '*' is a wildcard */
X	return 0;
X}
X
X/* Deity fix-it utilities */
Xvoid 
Xfix(int Playernum, int Governor)
X{
X	planettype     *p;
X	shiptype       *s;
X
X	if (match(args[1], "planet")) {
X		if (Dir[Playernum - 1][Governor].level != LEVEL_PLAN) {
X			notify(Playernum, Governor, "Change scope to the planet first.\n");
X			return;
X		}
X		getplanet(&p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X		if (match(args[2], "Maxx")) {
X			if (argn > 3)
X				p->Maxx = atoi(args[3]);
X			sprintf(buf, "Maxx = %d\n", p->Maxx);
X		} else if (match(args[2], "Maxy")) {
X			if (argn > 3)
X				p->Maxy = atoi(args[3]);
X			sprintf(buf, "Maxy = %d\n", p->Maxy);
X		} else if (match(args[2], "xpos")) {
X			if (argn > 3)
X				p->xpos = (double) atoi(args[3]);
X			sprintf(buf, "xpos = %f\n", p->xpos);
X		} else if (match(args[2], "ypos")) {
X			if (argn > 3)
X				p->ypos = (double) atoi(args[3]);
X			sprintf(buf, "ypos = %f\n", p->ypos);
X		} else if (match(args[2], "ships")) {
X			if (argn > 3)
X				p->ships = atoi(args[3]);
X			sprintf(buf, "ships = %d\n", p->ships);
X		} else if (match(args[2], "sectormappos")) {
X			if (argn > 3)
X				p->sectormappos = atoi(args[3]);
X			sprintf(buf, "sectormappos = %d\n", p->sectormappos);
X		} else if (match(args[2], "rtemp")) {
X			if (argn > 3)
X				p->conditions[RTEMP] = atoi(args[3]);
X			sprintf(buf, "RTEMP = %d\n", p->conditions[RTEMP]);
X		} else if (match(args[2], "temperature")) {
X			if (argn > 3)
X				p->conditions[TEMP] = atoi(args[3]);
X			sprintf(buf, "TEMP = %d\n", p->conditions[TEMP]);
X		} else if (match(args[2], "methane")) {
X			if (argn > 3)
X				p->conditions[METHANE] = atoi(args[3]);
X			sprintf(buf, "METHANE = %d\n", p->conditions[METHANE]);
X		} else if (match(args[2], "oxygen")) {
X			if (argn > 3)
X				p->conditions[OXYGEN] = atoi(args[3]);
X			sprintf(buf, "OXYGEN = %d\n", p->conditions[OXYGEN]);
X		} else if (match(args[2], "co2")) {
X			if (argn > 3)
X				p->conditions[CO2] = atoi(args[3]);
X			sprintf(buf, "CO2 = %d\n", p->conditions[CO2]);
X		} else if (match(args[2], "hydrogen")) {
X			if (argn > 3)
X				p->conditions[HYDROGEN] = atoi(args[3]);
X			sprintf(buf, "HYDROGEN = %d\n", p->conditions[HYDROGEN]);
X		} else if (match(args[2], "nitrogen")) {
X			if (argn > 3)
X				p->conditions[NITROGEN] = atoi(args[3]);
X			sprintf(buf, "NITROGEN = %d\n", p->conditions[NITROGEN]);
X		} else if (match(args[2], "sulfur")) {
X			if (argn > 3)
X				p->conditions[SULFUR] = atoi(args[3]);
X			sprintf(buf, "SULFUR = %d\n", p->conditions[SULFUR]);
X		} else if (match(args[2], "helium")) {
X			if (argn > 3)
X				p->conditions[HELIUM] = atoi(args[3]);
X			sprintf(buf, "HELIUM = %d\n", p->conditions[HELIUM]);
X		} else if (match(args[2], "other")) {
X			if (argn > 3)
X				p->conditions[OTHER] = atoi(args[3]);
X			sprintf(buf, "OTHER = %d\n", p->conditions[OTHER]);
X		} else if (match(args[2], "toxic")) {
X			if (argn > 3)
X				p->conditions[TOXIC] = atoi(args[3]);
X			sprintf(buf, "TOXIC = %d\n", p->conditions[TOXIC]);
X		} else {
X			notify(Playernum, Governor, "No such option for 'fix planet'.\n");
X			free(p);
X			return;
X		}
X		notify(Playernum, Governor, buf);
X		if (argn > 3)
X			putplanet(p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X		free(p);
X		return;
X	} if (match(args[1], "ship")) {
X		if (Dir[Playernum - 1][Governor].level != LEVEL_SHIP) {
X			notify(Playernum, Governor, "Change scope to the ship you wish to fix.\n");
X			return;
X		}
X		(void) getship(&s, Dir[Playernum - 1][Governor].shipno);
X		if (match(args[2], "fuel")) {
X			if (argn > 3)
X				s->fuel = (double) atoi(args[3]);
X			sprintf(buf, "fuel = %f\n", s->fuel);
X		} else if (match(args[2], "max_fuel")) {
X			if (argn > 3)
X				s->max_fuel = atoi(args[3]);
X			sprintf(buf, "fuel = %d\n", s->max_fuel);
X		} else if (match(args[2], "destruct")) {
X			if (argn > 3)
X				s->destruct = atoi(args[3]);
X			sprintf(buf, "destruct = %d\n", s->destruct);
X		} else if (match(args[2], "resource")) {
X			if (argn > 3)
X				s->resource = atoi(args[3]);
X			sprintf(buf, "resource = %d\n", s->resource);
X		} else if (match(args[2], "damage")) {
X			if (argn > 3)
X				s->damage = atoi(args[3]);
X			sprintf(buf, "damage = %d\n", s->damage);
X		} else if (match(args[2], "alive")) {
X			s->alive = 1;
X			s->damage = 0;
X			sprintf(buf, "%s resurrected\n", Ship(s));
X		} else if (match(args[2], "dead")) {
X			s->alive = 0;
X			s->damage = 100;
X			sprintf(buf, "%s destroyed\n", Ship(s));
X		} else {
X			notify(Playernum, Governor, "No such option for 'fix ship'.\n");
X			free(s);
X			return;
X		}
X		notify(Playernum, Governor, buf);
X		putship(s);
X		free(s);
X		return;
X	} else
X		notify(Playernum, Governor, "Fix what?\n");
X}
X
Xint 
Xmatch(char *p, char *q)
X{
X	return (!strncmp(p, q, strlen(p)));
X}
X
Xvoid 
XDontOwnErr(int Playernum, int Governor, int shipno)
X{
X	sprintf(buf, "You don't own ship #%d.\n", shipno);
X	notify(Playernum, Governor, buf);
X}
X
Xint 
XenufAP(int Playernum, int Governor, unsigned short AP, int x)
X{
X	reg int         blah;
X
X	if (blah = (AP < x)) {
X		sprintf(buf, "You don't have %d action points there.\n", x);
X		notify(Playernum, Governor, buf);
X	}
X	return (!blah);
X}
X
Xint 
XGetracenum(char *racepass, char *govpass, int *racenum, int *govnum)
X{
X	reg int         i, j;
X	for (i = 1; i <= Num_races; i++) {
X		if (!strcmp(racepass, races[i - 1]->password)) {
X			*racenum = i;
X			for (j = 0; j <= MAXGOVERNORS; j++) {
X				if (*races[i - 1]->governor[j].password &&
X				    !strcmp(govpass, races[i - 1]->governor[j].password)) {
X					*govnum = j;
X					return;
X				}
X			}
X		}
X	}
X	*racenum = *govnum = 0;
X}
X
X/* returns player # from string containing that players name or #. */
X
Xint 
XGetPlayer(char *name)
X{
X	int             rnum;
X	reg int         i;
X
X	rnum = 0;
X
X	if (isdigit(*name)) {
X		if ((rnum = atoi(name)) < 1 || rnum > Num_races)
X			return 0;
X		return rnum;
X	} else {
X		for (i = 1; i <= Num_races; i++)
X			if (match(name, races[i - 1]->name))
X				return i;
X		return 0;
X	}
X}
X
Xvoid 
XallocateAPs(int Playernum, int Governor, int APcount)
X{
X	int             maxalloc;
X	int             alloc;
X
X	if (Dir[Playernum - 1][Governor].level == LEVEL_UNIV) {
X		sprintf(buf, "Change scope to the system you which to transfer global APs to.\n");
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	alloc = atoi(args[1]);
X	if (alloc <= 0) {
X		notify(Playernum, Governor, "You must specify a positive amount of APs to allocate.\n");
X		return;
X	}
X	getsdata(&Sdata);
X	maxalloc = MIN(Sdata.AP[Playernum - 1], LIMIT_APs -
X	       Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1]);
X	if (alloc > maxalloc) {
X		sprintf(buf, "Illegal value (%d) - maximum = %d\n", alloc, maxalloc);
X		notify(Playernum, Governor, buf);
X		return;
X	}
X	Sdata.AP[Playernum - 1] -= alloc;
X	putsdata(&Sdata);
X	getstar(&Stars[Dir[Playernum - 1][Governor].snum], Dir[Playernum - 1][Governor].snum);
X	Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1] =
X		MIN(LIMIT_APs, Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1]
X		    + alloc);
X	putstar(Stars[Dir[Playernum - 1][Governor].snum], Dir[Playernum - 1][Governor].snum);
X	sprintf(buf, "Allocated\n");
X	notify(Playernum, Governor, buf);
X}
X
Xvoid 
XdeductAPs(int Playernum, int Governor, int n, int snum, int sdata)
X{
X	if (n) {
X
X		if (!sdata) {
X			getstar(&Stars[snum], snum);
X
X			if (Stars[snum]->AP[Playernum - 1] >= n)
X				Stars[snum]->AP[Playernum - 1] -= n;
X			else {
X				Stars[snum]->AP[Playernum - 1] = 0;
X				sprintf(buf, "WHOA!  You cheater!  Oooohh!  OOOOH!\n  I'm tellllllllliiiiiiinnnnnnnnnggggggggg!!!!!!!\n");
X				notify(Playernum, Governor, buf);
X			}
X
X			putstar(Stars[snum], snum);
X
X			if (Dir[Playernum - 1][Governor].level != LEVEL_UNIV && Dir[Playernum - 1][Governor].snum == snum) {
X				/* fix the prompt */
X				sprintf(Dir[Playernum - 1][Governor].prompt + 5, "%02d", Stars[snum]->AP[Playernum - 1]);
X				Dir[Playernum - 1][Governor].prompt[7] = ']';	/* fix bracket (made
X										 * '\0' by sprintf) */
X			}
X		} else {
X			getsdata(&Sdata);
X			Sdata.AP[Playernum - 1] = MAX(0, Sdata.AP[Playernum - 1] - n);
X			putsdata(&Sdata);
X
X			if (Dir[Playernum - 1][Governor].level == LEVEL_UNIV) {
X				sprintf(Dir[Playernum - 1][Governor].prompt + 2, "%02d", Sdata.AP[Playernum - 1]);
X				Dir[Playernum - 1][Governor].prompt[3] = ']';
X			}
X		}
X	}
X}
X
X/* lists all ships in current scope for debugging purposes */
Xvoid 
Xlist(int Playernum, int Governor)
X{
X	shiptype       *ship;
X	planettype     *p;
X	int             sh;
X
X	switch (Dir[Playernum - 1][Governor].level) {
X	case LEVEL_UNIV:
X		sh = Sdata.ships;
X		break;
X	case LEVEL_STAR:
X		getstar(&Stars[Dir[Playernum - 1][Governor].snum], Dir[Playernum - 1][Governor].snum);
X		sh = Stars[Dir[Playernum - 1][Governor].snum]->ships;
X		break;
X	case LEVEL_PLAN:
X		getplanet(&p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X		sh = p->ships;
X		free(p);
X		break;
X	case LEVEL_SHIP:
X		sh = Dir[Playernum - 1][Governor].shipno;
X		break;
X	}
X
X	while (sh) {
X		(void) getship(&ship, sh);
X		sprintf(buf, "%15s #%d '%s' (pl %d) -> #%d %s\n", Shipnames[ship->type],
X			sh, ship->name, ship->owner, ship->nextship,
X			ship->alive ? "" : "(dead)");
X		notify(Playernum, Governor, buf);
X		sh = ship->nextship;
X		free(ship);
X	}
X
X}
X
Xdouble 
Xmorale_factor(double x)
X{
X	return (atan((double) x / 10000.) / 3.14159565 + .5);
X}
X
X
X#ifdef DEBUG
X/* Debugging malloc routines, check for leaks, by Brian Scearce */
X#undef malloc
X#undef realloc
X#undef free
X
X#define FNAMESIZE 20
X#define DEBUGGING_STACK 100
Xstruct allocated {
X	char           *addr;
X	char            fname[FNAMESIZE + 1];
X	int             lineno;
X};
X
Xstatic struct allocated current[DEBUGGING_STACK];
Xstatic char     error_buf[1024];
X
Xchar           *
XDEBUGmalloc(int size, char *fname, int lineno)
X{
X	char           *p;
X	int             i;
X
X	if ((p = malloc(size)) == 0) {
X		/* DEBUGcheck(0); /* send to noone */
X		sprintf(error_buf, "Out of memory on malloc call from %s line %d\n",
X			fname, lineno);
X		/* panic(error_buf); */
X		exit(-1);
X	} else {
X		for (i = 0; i < DEBUGGING_STACK; i++)
X			if (current[i].addr == 0)
X				break;
X		if (i < DEBUGGING_STACK) {	/* We found one */
X			current[i].addr = p;
X			current[i].lineno = lineno;
X			strncpy(current[i].fname, fname, FNAMESIZE);
X		}
X	}
X	return p;
X}
X
X
Xvoid 
XDEBUGfree(char *p)
X{
X	int             i;
X
X	for (i = 0; i < DEBUGGING_STACK; i++)
X		if (current[i].addr == p)
X			break;
X
X	if (i < DEBUGGING_STACK)/* We found it */
X		current[i].addr = 0;
X
X	free(p);
X}
X
X
Xchar           *
XDEBUGrealloc(char *p, int newsize, char *fname, int lineno)
X{
X	int             i;
X	char           *q;
X
X	if ((q = realloc(p, newsize)) == 0) {
X		/* DEBUGcheck(0); /* send to noone */
X		sprintf(error_buf, "Out of memory on realloc call from %s line %d\n",
X			fname, lineno);
X		/* panic(error_buf); */
X		exit(-1);
X	} else {
X		for (i = 0; i < DEBUGGING_STACK; i++)
X			if (current[i].addr == p)
X				break;
X		if (i < DEBUGGING_STACK) {
X			current[i].addr = q;
X			current[i].lineno = lineno;
X			strncpy(current[i].fname, fname, FNAMESIZE);
X		}
X	}
X	return q;
X}
X
Xvoid 
XDEBUGcheck(int Playernum, int Governor)
X{
X	int             i;
X
X	if (Playernum) {
X		for (i = DEBUGGING_STACK - 1; i >= 0; i--)
X			if (current[i].addr != 0) {
X				sprintf(buf, "%3d malloc in %s l.%d not freed\n",
X				    i, current[i].fname, current[i].lineno);
X				notify(Playernum, Governor, buf);
X			}
X	}
X}
X
Xvoid 
XDEBUGreset(int Playernum, int Governor)
X{
X	int             i;
X
X	for (i = 0; i < DEBUGGING_STACK; i++)
X		current[i].addr = 0;
X}
X#endif
END_OF_FILE
if test 22987 -ne `wc -c <'server/shlmisc.c'`; then
    echo shar: \"'server/shlmisc.c'\" unpacked with wrong size!
fi
# end of 'server/shlmisc.c'
fi
if test -f 'user/move.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user/move.c'\"
else
echo shar: Extracting \"'user/move.c'\" \(28104 characters\)
sed "s/^X//" >'user/move.c' <<'END_OF_FILE'
X/*
X * * Galactic Bloodshed, copyright (c) 1989 by Robert P. Chansky, *
X * smq@ucscb.ucsc.edu, mods by people in GB_copyright.h. * Restrictions in
X * GB_copyright.h. *
X * 
X *  move.c -- move population and assault aliens on target sector
X */
X
X#include <signal.h>
X#include <math.h>
X#include <strings.h>
X
X#include "GB_copyright.h"
X#define EXTERN extern
X#include "vars.h"
X#include "ships.h"
X#include "races.h"
X#include "power.h"
X#include "buffers.h"
X
X/* defense 5 is inpenetrable */
Xint             Defensedata[] = {1, 1, 3, 2, 2, 3, 2, 4, 0};
X
Xextern char    *Desnames[];
Xextern char     Dessymbols[];
X
Xvoid            arm(int, int, int, int);
Xvoid            move_popn(int, int, int);
Xvoid            walk(int, int, int);
Xint             get_move(char, int, int, int *, int *, planettype *);
Xvoid 
Xmech_defend(int, int, int *, int, planettype *, int, int, sectortype *,
X	    int, int, sectortype *);
Xvoid 
Xmech_attack_people(shiptype *, int *, int *, racetype *, racetype *,
X		   sectortype *, int, int, int, char *, char *);
Xvoid 
Xpeople_attack_mech(shiptype *, int, int, racetype *, racetype *,
X		   sectortype *, int, int, char *, char *);
Xvoid 
Xground_attack(racetype *, racetype *, int *, int, unsigned short *,
X	      unsigned short *, unsigned int, unsigned int,
X	      double, double, double *, double *, int *, int *, int *);
X#include "proto.h"
X
X
Xvoid 
Xarm(int Playernum, int Governor, int APcount, int mode)
X{
X	planettype     *planet;
X	sectortype     *sect;
X	racetype       *Race;
X	int             x = -1, y = -1, amount = 0, cost = 0, enlist_cost,
X	                max_allowed;
X
X	if (Dir[Playernum - 1][Governor].level != LEVEL_PLAN) {
X		notify(Playernum, Governor, "Change scope to planet level first.\n");
X		return;
X	}
X	if (!control(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum])) {
X		notify(Playernum, Governor, "You are not authorized to do that here.\n");
X		return;
X	}
X	getplanet(&planet, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X
X	if (planet->slaved_to > 0 && planet->slaved_to != Playernum) {
X		notify(Playernum, Governor, "That planet has been enslaved!\n");
X		free(planet);
X		return;
X	}
X	sscanf(args[1], "%d,%d", &x, &y);
X	if (x < 0 || y < 0 || x > planet->Maxx - 1 || y > planet->Maxy - 1) {
X		notify(Playernum, Governor, "Illegal coordinates.\n");
X		free(planet);
X		return;
X	}
X	getsector(&sect, planet, x, y);
X	if (sect->owner != Playernum) {
X		notify(Playernum, Governor, "You don't own that sector.\n");
X		free(planet);
X		free(sect);
X		return;
X	}
X	if (mode) {
X		max_allowed = MIN(sect->popn,
X				  planet->info[Playernum - 1].destruct * (sect->mobilization + 1));
X		if (argn < 3)
X			amount = max_allowed;
X		else {
X			sscanf(args[2], "%d", &amount);
X			if (amount <= 0) {
X				notify(Playernum, Governor, "You must specify a positive number of civs to arm.\n");
X				free(planet);
X				free(sect);
X				return;
X			}
X		}
X		amount = MIN(amount, max_allowed);
X		if (!amount) {
X			notify(Playernum, Governor, "You can't arm any civilians now.\n");
X			free(planet);
X			free(sect);
X			return;
X		}
X		Race = races[Playernum - 1];
X		/* enlist_cost = ENLIST_TROOP_COST * amount; */
X		enlist_cost = Race->fighters * amount;
X		if (enlist_cost > Race->governor[Governor].money) {
X			sprintf(buf, "You need %d money to enlist %d troops.\n",
X				enlist_cost, amount);
X			notify(Playernum, Governor, buf);
X			free(planet);
X			free(sect);
X			return;
X		}
X		Race->governor[Governor].money -= enlist_cost;
X		putrace(Race);
X
X		cost = MAX(1, amount / (sect->mobilization + 1));
X		sect->troops += amount;
X		sect->popn -= amount;
X		planet->popn -= amount;
X		planet->info[Playernum - 1].popn -= amount;
X		planet->troops += amount;
X		planet->info[Playernum - 1].troops += amount;
X		planet->info[Playernum - 1].destruct -= cost;
X		sprintf(buf, "%d population armed at a cost of %dd (now %d civilians, %d military)\n",
X			amount, cost, sect->popn, sect->troops);
X		notify(Playernum, Governor, buf);
X		sprintf(buf, "This mobilization cost %d money.\n", enlist_cost);
X		notify(Playernum, Governor, buf);
X	} else {
X		if (argn < 3)
X			amount = sect->troops;
X		else {
X			sscanf(args[2], "%d", &amount);
X			if (amount <= 0) {
X				notify(Playernum, Governor, "You must specify a positive number of civs to arm.\n");
X				free(planet);
X				free(sect);
X				return;
X			}
X			amount = MIN(sect->troops, amount);
X		}
X		sect->popn += amount;
X		sect->troops -= amount;
X		planet->popn += amount;
X		planet->troops -= amount;
X		planet->info[Playernum - 1].popn += amount;
X		planet->info[Playernum - 1].troops -= amount;
X		sprintf(buf, "%d troops disarmed (now %d civilians, %d military)\n",
X			amount, sect->popn, sect->troops);
X		notify(Playernum, Governor, buf);
X	}
X	putsector(sect, planet, x, y);
X	putplanet(planet, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X	free(sect);
X	free(planet);
X}
X
Xvoid 
Xmove_popn(int Playernum, int Governor, int what)
X{
X	int             Assault, APcost;	/* unfriendly movement */
X	int             casualties, casualties2, casualties3;
X
X	planettype     *planet;
X	sectortype     *sect, *sect2;
X	int             people, oldpopn, old2popn, old3popn, x = -1, y = -1,
X	                x2 = -1, y2 = -1;
X	int             old2owner, old2gov, absorbed, n, done;
X	double          astrength, dstrength;
X	racetype       *Race, *alien;
X
X	if (Dir[Playernum - 1][Governor].level != LEVEL_PLAN) {
X		sprintf(buf, "Wrong scope\n");
X		return;
X	}
X	if (!control(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum])) {
X		notify(Playernum, Governor, "You are not authorized to do that here.\n");
X		return;
X	}
X	getplanet(&planet, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X
X	if (planet->slaved_to > 0 && planet->slaved_to != Playernum) {
X		sprintf(buf, "That planet has been enslaved!\n");
X		notify(Playernum, Governor, buf);
X		free(planet);
X		return;
X	}
X	sscanf(args[1], "%d,%d", &x, &y);
X	if (x < 0 || y < 0 || x > planet->Maxx - 1 || y > planet->Maxy - 1) {
X		sprintf(buf, "Origin coordinates illegal.\n");
X		notify(Playernum, Governor, buf);
X		free(planet);
X		return;
X	}
X	/* movement loop */
X	done = 0;
X	n = 0;
X	while (!done) {
X		getsector(&sect, planet, x, y);
X		if (sect->owner != Playernum) {
X			sprintf(buf, "You don't own sector %d,%d!\n", x, y);
X			notify(Playernum, Governor, buf);
X			free(planet);
X			free(sect);
X			return;
X		}
X		if (!get_move(args[2][n++], x, y, &x2, &y2, planet)) {
X			notify(Playernum, Governor, "Finished.\n");
X			putplanet(planet, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X			free(sect);
X			free(planet);
X			return;
X		}
X		if (x2 < 0 || y2 < 0 || x2 > planet->Maxx - 1 || y2 > planet->Maxy - 1) {
X			sprintf(buf, "Illegal coordinates %d,%d.\n", x2, y2);
X			notify(Playernum, Governor, buf);
X			putplanet(planet, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X			free(sect);
X			free(planet);
X			return;
X		}
X		if (!adjacent(x, y, x2, y2, planet)) {
X			sprintf(buf, "Illegal move - to adjacent sectors only!\n");
X			notify(Playernum, Governor, buf);
X			free(planet);
X			free(sect);
X			return;
X		}
X		/* ok, the move is legal */
X		getsector(&sect2, planet, x2, y2);
X		if (argn >= 4) {
X			sscanf(args[3], "%d", &people);
X			if (people < 0)
X				if (what == CIV)
X					people = sect->popn + people;
X				else if (what == MIL)
X					people = sect->troops + people;
X		} else {
X			if (what == CIV)
X				people = sect->popn;
X			else if (what == MIL)
X				people = sect->troops;
X		}
X
X		if ((what == CIV && (abs(people) > sect->popn)) ||
X		    (what == MIL && (abs(people) > sect->troops)) ||
X		    people <= 0) {
X			if (what == CIV)
X				sprintf(buf, "Bad value - %d civilians in [%d,%d]\n",
X					sect->popn, x, y);
X			else if (what == MIL)
X				sprintf(buf, "Bad value - %d troops in [%d,%d]\n", sect->troops, x, y);
X			notify(Playernum, Governor, buf);
X			putplanet(planet, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X			free(sect);
X			free(sect2);
X			free(planet);
X			return;
X		}
X		sprintf(buf, "%d %s moved.\n", people, what == CIV ? "population" : "troops");
X		notify(Playernum, Governor, buf);
X
X		/* check for defending mechs */
X		mech_defend(Playernum, Governor, &people, what, planet, x, y, sect, x2, y2, sect2);
X		if (!people) {
X			putsector(sect, planet, x, y);
X			putsector(sect2, planet, x2, y2);
X			putplanet(planet, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X			free(sect);
X			free(sect2);
X			free(planet);
X			notify(Playernum, Governor, "Attack aborted.\n");
X			return;
X		}
X		if (sect2->owner && (sect2->owner != Playernum))
X			Assault = 1;
X		else
X			Assault = 0;
X
X		/*
X		 * action point cost depends on the size of the group being
X		 * moved
X		 */
X		if (what == CIV)
X			APcost = MOVE_FACTOR * ((int) log(1.0 + (double) people) + Assault) + 1;
X		else if (what == MIL)
X			APcost = MOVE_FACTOR * ((int) log10(1.0 + (double) people) + Assault) + 1;
X
X		if (!enufAP(Playernum, Governor, Stars[Dir[Playernum - 1][Governor].snum]->AP[Playernum - 1],
X			    APcost)) {
X			free(sect);
X			free(sect2);
X			putplanet(planet, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X			free(planet);
X			return;
X		}
X		if (Assault) {
X			ground_assaults[Playernum - 1][sect2->owner - 1][Dir[Playernum - 1][Governor].snum] += 1;
X			Race = races[Playernum - 1];
X			alien = races[sect2->owner - 1];
X			/* races find out about each other */
X			alien->translate[Playernum - 1] = MIN(alien->translate[Playernum - 1] + 5,
X							      100);
X			Race->translate[sect2->owner - 1] = MIN(Race->translate[sect2->owner - 1] + 5,
X								100);
X
X			old2owner = (int) (sect2->owner);
X			old2gov = Stars[Dir[Playernum - 1][Governor].snum]->governor[sect2->owner - 1];
X			if (what == CIV)
X				sect->popn = MAX(0, sect->popn - people);
X			else if (what == MIL)
X				sect->troops = MAX(0, sect->troops - people);
X
X			if (what == CIV)
X				sprintf(buf, "%d civ assault %d civ/%d mil\n",
X					people, sect2->popn, sect2->troops);
X			else if (what == MIL)
X				sprintf(buf, "%d mil assault %d civ/%d mil\n",
X					people, sect2->popn, sect2->troops);
X			notify(Playernum, Governor, buf);
X			oldpopn = people;
X			old2popn = sect2->popn;
X			old3popn = sect2->troops;
X
X			ground_attack(Race, alien, &people, what, &sect2->popn, &sect2->troops,
X				      Defensedata[sect->condition],
X				      Defensedata[sect2->condition],
X				      Race->likes[sect->condition],
X				      alien->likes[sect2->condition],
X				      &astrength, &dstrength,
X				   &casualties, &casualties2, &casualties3);
X
X			sprintf(buf, "Attack: %.2f   Defense: %.2f.\n", astrength, dstrength);
X			notify(Playernum, Governor, buf);
X
X			if (!(sect2->popn + sect2->troops)) {	/* we got 'em */
X				sect2->owner = Playernum;
X				/*
X				 * mesomorphs absorb the bodies of their
X				 * victims
X				 */
X				absorbed = 0;
X				if (Race->absorb) {
X					absorbed = int_rand(0, old2popn + old3popn);
X					sprintf(buf, "%d alien bodies absorbed.\n", absorbed);
X					notify(Playernum, Governor, buf);
X					sprintf(buf, "Metamorphs have absorbed %d bodies!!!\n",
X						absorbed);
X					notify(old2owner, old2gov, buf);
X				}
X				if (what == CIV)
X					sect2->popn = people + absorbed;
X				else if (what == MIL) {
X					sect2->popn = absorbed;
X					sect2->troops = people;
X				}
X				adjust_morale(Race, alien, (int) alien->fighters);
X			} else {/* retreat */
X				absorbed = 0;
X				if (alien->absorb) {
X					absorbed = int_rand(0, oldpopn - people);
X					sprintf(buf, "%d alien bodies absorbed.\n",
X						absorbed);
X					notify(old2owner, old2gov, buf);
X					sprintf(buf, "Metamorphs have absorbed %d bodies!!!\n",
X						absorbed);
X					notify(Playernum, Governor, buf);
X					sect2->popn += absorbed;
X				}
X				if (what == CIV)
X					sect->popn += people;
X				else if (what == MIL)
X					sect->troops += people;
X				adjust_morale(alien, Race, (int) Race->fighters);
X			}
X
X			sprintf(telegram_buf, "/%s/%s: %s [%d] %c(%d,%d) assaults %s [%d] %c(%d,%d) %s\n",
X			     Stars[Dir[Playernum - 1][Governor].snum]->name,
X				Stars[Dir[Playernum - 1][Governor].snum]->pnames[Dir[Playernum - 1][Governor].pnum],
X				Race->name, Playernum, Dessymbols[sect->condition], x, y,
X				alien->name, alien->Playernum,
X				Dessymbols[sect2->condition], x2, y2,
X			(sect2->owner == Playernum ? "VICTORY" : "DEFEAT"));
X
X			if (sect2->owner == Playernum) {
X				sprintf(buf, "VICTORY! The sector is yours!\n");
X				notify(Playernum, Governor, buf);
X				sprintf(buf, "Sector CAPTURED!\n");
X				strcat(telegram_buf, buf);
X				if (people) {
X					sprintf(buf, "%d %s move in.\n",
X						people, what == CIV ? "civilians" : "troops");
X					notify(Playernum, Governor, buf);
X				}
X				planet->info[Playernum - 1].mob_points += (int) sect2->mobilization;
X				planet->info[old2owner - 1].mob_points -= (int) sect2->mobilization;
X			} else {
X				sprintf(buf, "The invasion was repulsed; try again.\n");
X				notify(Playernum, Governor, buf);
X				sprintf(buf, "You fought them off!\n");
X				strcat(telegram_buf, buf);
X				done = 1;	/* end loop */
X			}
X
X			if (!(sect->popn + sect->troops + people)) {
X				sprintf(buf, "You killed all of them!\n");
X				strcat(telegram_buf, buf);
X				/* increase modifier */
X				Race->translate[old2owner - 1] = MIN(Race->translate[old2owner - 1] + 5,
X								     100);
X			}
X			if (!people) {
X				sprintf(buf, "Oh no! They killed your party to the last man!\n");
X				notify(Playernum, Governor, buf);
X				/* increase modifier */
X				alien->translate[Playernum - 1] = MIN(alien->translate[Playernum - 1] + 5,
X								      100);
X			}
X			putrace(alien);
X			putrace(Race);
X
X			sprintf(buf, "Casualties: You: %d civ/%d mil, Them: %d %s\n",
X				casualties2, casualties3,
X				casualties, what == CIV ? "civ" : "mil");
X			strcat(telegram_buf, buf);
X			warn(old2owner, old2gov, telegram_buf);
X			sprintf(buf, "Casualties: You: %d %s, Them: %d civ/%d mil\n",
X				casualties, what == CIV ? "civ" : "mil",
X				casualties2, casualties3);
X			notify(Playernum, Governor, buf);
X		} else {
X			if (what == CIV) {
X				sect->popn -= people;
X				sect2->popn += people;
X			} else if (what == MIL) {
X				sect->troops -= people;
X				sect2->troops += people;
X			}
X			if (!sect2->owner)
X				planet->info[Playernum - 1].mob_points += (int) sect2->mobilization;
X			sect2->owner = Playernum;
X		}
X
X		if (!(sect->popn + sect->troops)) {
X			planet->info[Playernum - 1].mob_points -= (int) sect->mobilization;
X			sect->owner = 0;
X		}
X		if (!(sect2->popn + sect2->troops)) {
X			sect2->owner = 0;
X			done = 1;
X		}
X		putsector(sect, planet, x, y);
X		putsector(sect2, planet, x2, y2);
X		free(sect);
X		free(sect2);
X
X		deductAPs(Playernum, Governor, APcost, Dir[Playernum - 1][Governor].snum, 0);
X		x = x2;
X		y = y2;		/* get ready for the next round */
X	}
X	notify(Playernum, Governor, "Finished.\n");
X	free(planet);
X}
X
Xvoid 
Xwalk(int Playernum, int Governor, int APcount)
X{
X	shiptype       *ship, *ship2, dummy;
X	planettype     *p;
X	sectortype     *sect;
X	int             shipno, x, y, i, sh, succ = 0, civ, mil;
X	int             damage, oldowner, oldgov;
X	int             strength, strength1;
X	racetype       *Race, *alien;
X
X	if (argn < 2) {
X		notify(Playernum, Governor, "Walk what?\n");
X		return;
X	}
X	sscanf(args[1] + (args[1][0] == '#'), "%d", &shipno);
X	if (!getship(&ship, shipno)) {
X		notify(Playernum, Governor, "No such ship.\n");
X		return;
X	}
X	if (testship(Playernum, Governor, ship)) {
X		notify(Playernum, Governor, "You do not control this ship.\n");
X		free(ship);
X		return;
X	}
X	if (ship->type != OTYPE_AFV) {
X		notify(Playernum, Governor, "This ship doesn't walk!\n");
X		free(ship);
X		return;
X	}
X	if (!landed(ship)) {
X		notify(Playernum, Governor, "This ship is not landed on a planet.\n");
X		free(ship);
X		return;
X	}
X	if (!ship->popn) {
X		notify(Playernum, Governor, "No crew.\n");
X		free(ship);
X		return;
X	}
X	if (ship->fuel < AFV_FUEL_COST) {
X		sprintf(buf, "You don't have %.1f fuel to move it.\n", AFV_FUEL_COST);
X		notify(Playernum, Governor, buf);
X		free(ship);
X		return;
X	}
X	if (!enufAP(Playernum, Governor, Stars[ship->storbits]->AP[Playernum - 1], APcount)) {
X		free(ship);
X		return;
X	}
X	getplanet(&p, (int) ship->storbits, (int) ship->pnumorbits);
X	Race = races[Playernum - 1];
X
X	if (!get_move(args[2][0], (int) ship->land_x, (int) ship->land_y, &x, &y, p)) {
X		notify(Playernum, Governor, "Illegal move.\n");
X		free(p);
X		free(ship);
X		return;
X	}
X	if (x < 0 || y < 0 || x > p->Maxx - 1 || y > p->Maxy - 1) {
X		sprintf(buf, "Illegal coordinates %d,%d.\n", x, y);
X		notify(Playernum, Governor, buf);
X		free(ship);
X		putplanet(p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X		free(p);
X		return;
X	}
X	/* check to see if player is permited on the sector type */
X	getsector(&sect, p, x, y);
X	if (!Race->likes[sect->condition]) {
X		notify(Playernum, Governor, "Your ships cannot walk into that sector type!\n");
X		free(ship);
X		free(p);
X		free(sect);
X		return;
X	}
X	/*
X	 * if the sector is occupied by non-aligned AFVs, each one will
X	 * attack
X	 */
X	sh = p->ships;
X	while (sh && ship->alive) {
X		(void) getship(&ship2, sh);
X		if (ship2->owner != Playernum && ship2->type == OTYPE_AFV &&
X		    landed(ship2) && retal_strength(ship2) &&
X		    (ship2->land_x == x) && (ship2->land_y == y)) {
X			alien = races[ship2->owner - 1];
X			if (!isset(Race->allied, (int) ship2->owner) ||
X			    !isset(alien->allied, Playernum)) {
X				while ((strength = retal_strength(ship2)) &&
X				       (strength1 = retal_strength(ship))) {
X					bcopy(ship, &dummy, sizeof(shiptype));
X					damage = shoot_ship_to_ship(ship2, ship,
X					strength, 0, 0, long_buf, short_buf);
X					use_destruct(ship2, strength);
X					notify(Playernum, Governor, long_buf);
X					warn((int) ship2->owner, (int) ship2->governor, long_buf);
X					if (!ship2->alive)
X						post(short_buf, COMBAT);
X					notify_star(Playernum, Governor, (int) ship2->owner,
X					   (int) ship->storbits, short_buf);
X					if (strength1) {
X						damage = shoot_ship_to_ship(&dummy, ship2,
X									    strength1, 0, 1, long_buf, short_buf);
X						use_destruct(ship, strength1);
X						notify(Playernum, Governor, long_buf);
X						warn((int) ship2->owner, (int) ship2->governor, long_buf);
X						if (!ship2->alive)
X							post(short_buf, COMBAT);
X						notify_star(Playernum, Governor, (int) ship2->owner,
X							    (int) ship->storbits, short_buf);
X					}
X				}
X				putship(ship2);
X			}
X		}
X		sh = ship2->nextship;
X		free(ship2);
X	}
X	/* if the sector is occupied by non-aligned player, attack them first */
X	if (ship->popn && ship->alive && sect->owner && sect->owner != Playernum) {
X		oldowner = sect->owner;
X		oldgov = Stars[ship->storbits]->governor[sect->owner - 1];
X		alien = races[oldowner - 1];
X		if (!isset(Race->allied, oldowner) || !isset(alien->allied, Playernum)) {
X			if (!retal_strength(ship)) {
X				notify(Playernum, Governor, "You have nothing to attack with!\n");
X				free(ship);
X				free(p);
X				free(sect);
X				return;
X			}
X			while ((sect->popn + sect->troops) && retal_strength(ship)) {
X				civ = (int) sect->popn;
X				mil = (int) sect->troops;
X				mech_attack_people(ship, &civ, &mil,
X						 Race, alien, sect, x, y, 0,
X						   long_buf, short_buf);
X				notify(Playernum, Governor, long_buf);
X				warn(alien->Playernum, oldgov, long_buf);
X				notify_star(Playernum, Governor, oldowner, (int) ship->storbits,
X					    short_buf);
X				post(short_buf, COMBAT);
X
X				people_attack_mech(ship, (int) sect->popn,
X						   (int) sect->troops,
X						   alien, Race, sect, x, y,
X						   long_buf, short_buf);
X				notify(Playernum, Governor, long_buf);
X				warn(alien->Playernum, oldgov, long_buf);
X				notify_star(Playernum, Governor, oldowner, (int) ship->storbits,
X					    short_buf);
X				if (!ship->alive)
X					post(short_buf, COMBAT);
X
X				sect->popn = civ;
X				sect->troops = mil;
X				if (!(sect->popn + sect->troops)) {
X					p->info[sect->owner - 1].mob_points -=
X						(int) sect->mobilization;
X					sect->owner = 0;
X				}
X			}
X		}
X		putrace(alien);
X		putrace(Race);
X		putplanet(p, Dir[Playernum - 1][Governor].snum, Dir[Playernum - 1][Governor].pnum);
X		putsector(sect, p, x, y);
X	}
X	if ((sect->owner == Playernum || isset(Race->allied, (int) sect->owner) ||
X	     !sect->owner) && ship->alive)
X		succ = 1;
X
X	if (ship->alive && ship->popn && succ) {
X		sprintf(buf, "%s moving from %d,%d to %d,%d on %s.\n", Ship(ship),
X			(int) ship->land_x, (int) ship->land_y, x, y, Dispshiploc(ship));
X		ship->land_x = x;
X		ship->land_y = y;
X		use_fuel(ship, AFV_FUEL_COST);
X		for (i = 1; i <= Num_races; i++)
X			if (i != Playernum && p->info[i - 1].numsectsowned)
X				notify(i, (int) Stars[Dir[Playernum - 1][Governor].snum]->governor[i - 1], buf);
X	}
X	putship(ship);
X	deductAPs(Playernum, Governor, APcount, (int) ship->storbits, 0);
X	free(ship);
X	free(p);
X	free(sect);
X}
X
Xint 
Xget_move(char direction, int x, int y, int *x2, int *y2,
X	 planettype * planet)
X{
X	switch (direction) {
X		case '1':
X		case 'b':
X		*x2 = x - 1;
X		*y2 = y + 1;
X		if (*x2 == -1)
X			*x2 = planet->Maxx - 1;
X		return 1;
X	case '2':
X	case 'k':
X		*x2 = x;
X		*y2 = y + 1;
X		return 1;
X	case '3':
X	case 'n':
X		*x2 = x + 1;
X		*y2 = y + 1;
X		if (*x2 == planet->Maxx)
X			*x2 = 0;
X		return 1;
X	case '4':
X	case 'h':
X		*x2 = x - 1;
X		*y2 = y;
X		if (*x2 == -1)
X			*x2 = planet->Maxx - 1;
X		return 1;
X	case '6':
X	case 'l':
X		*x2 = x + 1;
X		*y2 = y;
X		if (*x2 == planet->Maxx)
X			*x2 = 0;
X		return 1;
X	case '7':
X	case 'y':
X		*x2 = x - 1;
X		*y2 = y - 1;
X		if (*x2 == -1)
X			*x2 = planet->Maxx - 1;
X		return 1;
X	case '8':
X	case 'j':
X		*x2 = x;
X		*y2 = y - 1;
X		return 1;
X	case '9':
X	case 'u':
X		*x2 = x + 1;
X		*y2 = y - 1;
X		if (*x2 == planet->Maxx)
X			*x2 = 0;
X		return 1;
X	default:
X		*x2 = x;
X		*y2 = y;
X		return 0;
X	}
X}
X
Xvoid 
Xmech_defend(int Playernum, int Governor, int *people, int type,
X	    planettype * p, int x, int y, sectortype * s, int x2, int y2,
X	    sectortype * s2)
X{
X	int             sh;
X	shiptype       *ship;
X	int             civ = 0, mil = 0;
X	int             oldgov;
X	racetype       *Race, *alien;
X
X	if (type == CIV)
X		civ = *people;
X	else
X		mil = *people;
X
X	sh = p->ships;
X	Race = races[Playernum - 1];
X	while (sh && (civ + mil)) {
X		(void) getship(&ship, sh);
X		if (ship->owner != Playernum && ship->type == OTYPE_AFV && landed(ship) &&
X		    retal_strength(ship) && (ship->land_x == x2) && (ship->land_y == y2)) {
X			alien = races[ship->owner - 1];
X			if (!isset(Race->allied, (int) ship->owner) ||
X			    !isset(alien->allied, Playernum)) {
X				while ((civ + mil) && retal_strength(ship)) {
X					oldgov = Stars[ship->storbits]->governor[alien->Playernum - 1];
X					mech_attack_people(ship, &civ, &mil,
X						 alien, Race, s2, x2, y2, 1,
X						       long_buf, short_buf);
X					notify(Playernum, Governor, long_buf);
X					warn(alien->Playernum, oldgov, long_buf);
X					if (civ + mil) {
X						people_attack_mech(ship, civ, mil,
X						    Race, alien, s2, x2, y2,
X						       long_buf, short_buf);
X						notify(Playernum, Governor, long_buf);
X						warn(alien->Playernum, oldgov, long_buf);
X					}
X				}
X			}
X			putship(ship);
X		}
X		sh = ship->nextship;
X		free(ship);
X	}
X	*people = civ + mil;
X}
X
Xvoid 
Xmech_attack_people(shiptype * ship, int *civ, int *mil, racetype * Race,
X		   racetype * alien, sectortype * sect, int x, int y,
X		   int ignore, char *long_msg, char *short_msg)
X{
X	int             strength, oldciv, oldmil;
X	double          astrength, dstrength;
X	int             cas_civ, cas_mil, ammo;
X
X	oldciv = *civ;
X	oldmil = *mil;
X
X	strength = retal_strength(ship);
X	astrength = MECH_ATTACK * ship->tech * (double) strength
X		* ((double) ship->armor + 1.0)
X		* .01 * (100.0 - (double) ship->damage)
X		* .01 * (Race->likes[sect->condition] + 1.0)
X		* morale_factor((double) (Race->morale - alien->morale));
X
X	dstrength =
X		(double) (10 * oldmil * alien->fighters + oldciv) * 0.01 * alien->tech
X		* .01 * (alien->likes[sect->condition] + 1.0)
X		* ((double) Defensedata[sect->condition] + 1.0)
X		* morale_factor((double) (alien->morale - Race->morale));
X
X	if (ignore) {
X		ammo = (int) log10((double) dstrength + 1.0) - 1;
X		ammo = MIN(MAX(ammo, 0), strength);
X		use_destruct(ship, ammo);
X	} else
X		use_destruct(ship, strength);
X
X	cas_civ = int_rand(0, round_rand((double) oldciv * astrength / dstrength));
X	cas_civ = MIN(oldciv, cas_civ);
X	cas_mil = int_rand(0, round_rand((double) oldmil * astrength / dstrength));
X	cas_mil = MIN(oldmil, cas_mil);
X	*civ -= cas_civ;
X	*mil -= cas_mil;
X	sprintf(short_msg, "%s: %s %s %s [%d]\n",
X		Dispshiploc(ship), Ship(ship),
X		(*civ + *mil) ? "attacked" : "slaughtered",
X		alien->name, alien->Playernum);
X	strcpy(long_msg, short_msg);
X	sprintf(buf, "\tBattle at %d,%d %s: %d guns fired on %d civ/%d mil\n",
X		x, y, Desnames[sect->condition], strength, oldciv, oldmil);
X	strcat(long_msg, buf);
X	sprintf(buf, "\tAttack: %.3f   Defense: %.3f.\n", astrength, dstrength);
X	strcat(long_msg, buf);
X	sprintf(buf, "\t%d civ/%d mil killed.\n", cas_civ, cas_mil);
X	strcat(long_msg, buf);
X}
X
Xvoid 
Xpeople_attack_mech(shiptype * ship, int civ, int mil, racetype * Race,
X		   racetype * alien, sectortype * sect, int x, int y,
X		   char *long_msg, char *short_msg)
X{
X	int             strength;
X	double          astrength, dstrength;
X	int             cas_civ, cas_mil, pdam, sdam, damage;
X	int             ammo;
X
X	strength = retal_strength(ship);
X
X	dstrength = MECH_ATTACK * ship->tech * (double) strength
X		* ((double) ship->armor + 1.0)
X		* .01 * (100.0 - (double) ship->damage)
X		* .01 * (alien->likes[sect->condition] + 1.0)
X		* morale_factor((double) (alien->morale - Race->morale));
X
X	astrength =
X		(double) (10 * mil * Race->fighters + civ) * .01 * Race->tech
X		* .01 * (Race->likes[sect->condition] + 1.0)
X		* ((double) Defensedata[sect->condition] + 1.0)
X		* morale_factor((double) (Race->morale - alien->morale));
X	ammo = (int) log10((double) astrength + 1.0) - 1;
X	ammo = MIN(strength, MAX(0, ammo));
X	use_destruct(ship, ammo);
X	damage = int_rand(0, round_rand(100.0 * astrength / dstrength));
X	damage = MIN(100, damage);
X	ship->damage += damage;
X	if (ship->damage >= 100) {
X		ship->damage = 100;
X		kill_ship(Race->Playernum, ship);
X	}
X	do_collateral(ship, damage, &cas_civ, &cas_mil, &pdam, &sdam);
X	sprintf(short_msg, "%s: %s [%d] %s %s\n",
X		Dispshiploc(ship), Race->name, Race->Playernum,
X		ship->alive ? "attacked" : "DESTROYED", Ship(ship));
X	strcpy(long_msg, short_msg);
X	sprintf(buf, "\tBattle at %d,%d %s: %d civ/%d mil assault %s\n",
X	  x, y, Desnames[sect->condition], civ, mil, Shipnames[ship->type]);
X	strcat(long_msg, buf);
X	sprintf(buf, "\tAttack: %.3f   Defense: %.3f.\n", astrength, dstrength);
X	strcat(long_msg, buf);
X	sprintf(buf, "\t%d%% damage inflicted for a total of %d%%\n",
X		damage, ship->damage);
X	strcat(long_msg, buf);
X	sprintf(buf, "\t%d civ/%d mil killed   %d prim/%d sec guns knocked out\n",
X		cas_civ, cas_mil, pdam, sdam);
X	strcat(long_msg, buf);
X}
X
Xvoid 
Xground_attack(racetype * Race, racetype * alien, int *people, int what,
X	      unsigned short *civ, unsigned short *mil,
X	      unsigned int def1, unsigned int def2,
X	      double alikes, double dlikes, double *astrength,
X	      double *dstrength, int *casualties, int *casualties2,
X	      int *casualties3)
X{
X	int             casualty_scale;
X
X	*astrength = (double) (*people * Race->fighters * (what == MIL ? 10 : 1))
X		* (alikes + 1.0) * ((double) def1 + 1.0)
X		* morale_factor((double) (Race->morale - alien->morale));
X	*dstrength = (double) ((*civ + *mil * 10) * alien->fighters)
X		* (dlikes + 1.0) * ((double) def2 + 1.0)
X		* morale_factor((double) (alien->morale - Race->morale));
X	/* nuke both populations */
X	casualty_scale = MIN(*people * (what == MIL ? 10 : 1) * Race->fighters,
X			     (*civ + *mil * 10) * alien->fighters);
X
X	*casualties = int_rand(0, round_rand((double) ((casualty_scale /
X						     (what == MIL ? 10 : 1))
X					       * *dstrength / *astrength)));
X	*casualties = MIN(*people, *casualties);
X	*people -= *casualties;
X
X	*casualties2 = int_rand(0, round_rand((double) casualty_scale
X					      * *astrength / *dstrength));
X	*casualties2 = MIN(*civ, *casualties2);
X	*civ -= *casualties2;
X	/* and for troops */
X	*casualties3 = int_rand(0, round_rand((double) (casualty_scale / 10)
X					      * *astrength / *dstrength));
X	*casualties3 = MIN(*mil, *casualties3);
X	*mil -= *casualties3;
X}
END_OF_FILE
if test 28104 -ne `wc -c <'user/move.c'`; then
    echo shar: \"'user/move.c'\" unpacked with wrong size!
fi
# end of 'user/move.c'
fi
echo shar: End of archive 9 \(of 21\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    echo "Now type './buildfiles.sh'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
