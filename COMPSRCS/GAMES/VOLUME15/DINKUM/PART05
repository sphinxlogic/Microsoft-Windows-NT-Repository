Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v15i025:  dinkum - australian text adventure game, Part05/06
Message-ID: <3983@master.CNA.TEK.COM>
Date: 29 Nov 92 20:31:58 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1867
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1524

Submitted-by: Gary Allen <gary@sun.mech.uq.oz.au>
Posting-number: Volume 15, Issue 25
Archive-name: dinkum/Part05
Environment: Unix, DOS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 6)."
# Contents:  actor.c opener.c parse.c
# Wrapped by billr@saab on Sun Nov 29 12:25:49 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'actor.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'actor.c'\"
else
echo shar: Extracting \"'actor.c'\" \(18250 characters\)
sed "s/^X//" >'actor.c' <<'END_OF_FILE'
X#define ACTOR
X#include "dink_sym.h"
X#include "dink_glb.h"
X 
Xvoid actor(n)
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr.  12 March 1989,  Version: Mk 1.1 */
X/*           (c) Copyright 1989 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
Xint n ;
X{
X#ifdef __TURBOC__
Xvoid objector(int) ;
X#endif
X
Xint i ;
Xstatic int sw_door_kick = FALSE ;
X
Xswitch(n) {
X
X	/* mine elevator */
X	case R_lift_entr:
X		if (room[R_lift_entr][M_rm_status] == S_closed) {
Xprintf("The lift doors are closed and the lift call button ");
Xprintf("is not glowing. It \nseems the electrical power has ");
Xprintf("been turned off at the main switch. \n"); }
X		if (room[R_lift_entr][M_rm_status] == S_flashing) {
Xprintf("The lift doors are closed.  However the call button");
Xprintf(" is flashing. There \nis the sound of electrical equipment ");
Xprintf("humming within the mine lift. \n"); }
X		if (room[R_lift_entr][M_rm_status] == S_open) {
Xprintf("The lift doors are standing open. \n");
X		}
X		break;
X 
X	/* office building door */
X	case R_office_entr:
X		switch(room[R_office_entr][M_rm_status]) {
X			case S_open:
Xprintf("      --- The office front door is open. --- \n");
X				break;
X			case S_kicked:
X				if (!sw_door_kick) {
Xprintf("The lock of the front door has been shot at several times.\n"); 
Xprintf("The door itself has been kicked in and is broken off at\n") ;
Xprintf("the hinges.  The passage way is free to enter.\n");
X				sw_door_kick = TRUE ;
X				}
X				else {
Xprintf("The front door of the office has been kicked in. \n") ;
X				}
X				break ;
X			default:
Xprintf("The office has a front door with a sun faded sign \n"); 
Xprintf("upon which is written:  \"Sorry, We are CLOSED\". \n");
Xprintf("      --- The office door is shut. --- \n");
X				break ;
X		}
X		break ;
X 
X	/* Site Managers Office */
X	case R_office_mang:
X		if (room[R_office_mang][M_rm_status] == S_closed) {
Xprintf("On the wall is a picture of a platypus wearing a hat with");
X		printf(" corks \ndangling from the hat's rim.\n");
X			break;
X		}
Xif ((room[R_office_mang][M_rm_status] == S_revealed)||
X	(room[n][M_rm_status] ==S_dialed)) {
Xprintf("Before you is a picture hinged to the wall that has been ");
Xprintf("swung \nopen revealing a closed combination dial wall safe.\n");
X			break;}
X		if (room[n][M_rm_status] == S_open) {
Xprintf("Before you is a picture hinged to the wall that has been");
Xprintf(" swung \nout revealing a wall safe with an open door.\n");
X		for (i=0; i <= objcnt; i++) {
X			if (object[i][J_loc] == B_in_safe) 
X				goto safelist;
X		}
X		if (gleep_safe != 0) {
Xprintf("There is nothing in the safe except ") ;
X			if (gleep_safe == 1) 
X				printf("a single gleep.\n") ;
X			else
X				printf("%d gleeps.\n",gleep_safe) ;
X			break ;
X		}
X		printf("---The safe is empty.--- \n");
X		break ;
Xsafelist:
X		printf ("You see the following inside the safe: \n");
X		for (i=0; i <= objcnt; i++) {
X			if (object[i][J_loc] == B_in_safe) {
X				printf ("        ");
X				objector(i) ;
X				printf ("\n") ;
X			}
X		}				
X		if (gleep_safe != 0) {
X			printf ("        ");
X			if (gleep_safe == 1) 
X				printf("one gleep\n") ;
X			else
X				printf("%d gleeps\n",gleep_safe) ;
X		}
X			break;
X		}
X
X	/* store room */
X	case R_store_room:
Xprintf("There is a 1500 Volt circuit breaker box on the wall");
X		if (room[n][M_rm_status] == S_off) 
Xprintf(" which has \na switch set in the \"off\" position. \n"); 
X		else
Xprintf(" which has \na switch set in the \"on\" position. \n"); 
X		break;
X
X	/* lift compartment */
X	case R_lift_inside:
X		if (room[n][M_rm_status] == S_L0) 
Xprintf("The level button with the number zero is flashing. \n"); 
X		if (room[n][M_rm_status] == S_L49) 
Xprintf("The level button with the number forty-nine is flashing. \n"); 
X		if (room[n][M_rm_status] == S_L67) 
Xprintf("The level button with the number sixty-seven is flashing. \n");
X		if (room[n][M_rm_status] == S_L82) 
Xprintf("The level button with the number eighty-two is flashing. \n"); 
X		break;
X
X} 
X} /* --- end of subroutine "actor"--- */
X
Xvoid objector(i)
Xint i ;
X{
Xstatic char *obj[] = {
X"an empty can of Fourex beer",
X"a cigarette butt",
X"an empty bottle of Black Swan Lager",
X"an old doormat with \"ACME Gold Mines Ltd.\" written on it",
X"a large brass key",
X"a ripped and bent up umbrella",
X"a two meter length of fishing tackle without a hook",
X"a broken drill bit",
X"a very old but detailed map of the ACME Mine",       /*  5  */
X"a fragment of a map showing the ACME Mine",
X"a sheet of paper with some writing on it",
X"a gold bar weighing ten kilograms",
X"a hydraulic jack which is rusted solid",
X"a large stick of dynamite",
X"an M16 ammo clip designed to hold up to 200 rounds",
X"a fountain pen which is dried up and useless",
X"an orange M16 ammo clip which is glowing a faint pale blue",
X"a mechanical pencil without any leads",
X"an unloaded, fully automatic M16 infantry rifle",    /*  10 */
X"a piece of copper wire",
X"a short length of galvanized iron pipe",
X"a blasting cap with 20 cm. of fuse attached",
X"a box of \"Red Head\" matches",
X"a diamond ring with a three carat flawless blue diamond",
X"a can opener",
X"a bright red ruby the size of an egg",               /*  15 */
X"an antique sterling silver teapot with \"N.K.\" engraved on it",
X"a silver Syracusian Dekadrachma coin",
X"an electrical extension cord",
X"a $100 dollar bill",
X"an autographed photo of Sir Joh",
X"an old folding chair",
X"a burned out light bulb",
X"a packet containing atropine pills",
X"a high quality artificial saphire",
X"a huge uncut emerald",
X"an oily rag",
X"a burned out fluorescent tube",
X"a filthy worn out carpet",
X"a branch from a gum tree",
X"a thick airmail letter, marked \"Postage Due\"",
X"a cork from a wine bottle",
X"a high intensity battery powered torch",
X"an old cockroach trap",
X"an empty butane cigarette lighter",
X"a small black cube with a blue push button on one side", 
X"an ancient and priceless gong clapper made of ivory and gold",
X"a Semtex explosive detector with a push button switch",
X"a broken shoe lace",
X"a dirty old comb",
X"a Cornetto ice cream cone wrapper",
X"a bald automobile tyre",
X"an empty broken egg shell",
X"a broken piece of brick",
X"a one meter length of rope",
X"an empty package of Stradbroke cigarettes",
X"a broken automobile fan belt",
X"a used automobile oil filter",
X"a short piece of string"
X};
X
X/* Deal with transformed objects */
Xif (object[i][J_type] == Z_alias) {
X	if (i == O_rifle) {
Xprintf("an M16 infantry rifle with an ammunition clip inserted") ;
X		return ;
X	}
X	if (i == O_dynamite) {
Xprintf("a large stick of dynamite with a fuse type blasting cap") ;
X		return ;
X	}
X}
Xelse printf("%s",obj[i]) ;
X} /* --- end of subroutine "objector"--- */
X 
Xvoid killer(n)
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 22 January 1989  Version: Mk 1.3 */
X/*           (c) Copyright 1989 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
Xint n ;
X{
X#ifdef __TURBOC__
Xvoid ender(int) ;
X#endif
Xregister int i, j ;
Xint hits, j_point, i_10, i_fract ;
Xint sw_kill, target_k_flag, sw_see, sw_other_object ;
Xstatic int sw_hurt = FALSE ;
X
Xif (tag[V_VERB_ONLY]&&(verb == V_kill)) {
Xprintf("It may be obvious to you, but you are going to have to tell\n");
Xprintf("me exactly what it is you want to have killed, and \n") ;
Xprintf("with what sort of weapon. \n") ;
X	return;
X}
X
X/* set the subroutine local flags */
Xif (verb == V_kill) sw_kill = FALSE ;
Xif (verb == V_shoot) sw_kill = TRUE;
Xtarget_k_flag = V_NULL ;
Xsw_see =  FALSE ;
Xsw_other_object = FALSE ;
X 
Xif (tag[V_ned]) {
X	if (enemy[N_ned][E_location] == B_destroyed) {
Xprintf("Forget it, you drongo!! Ned Kelly is already dead!\n") ;
X		return ;
X	}
X	if (enemy[N_ned][E_status] == F_asleep) {
Xprintf("There is no Ned Kelly here for me to kill! \n") ;
X		return ;
X	}
X	j_point = 0 ; 
X	sw_see =  TRUE ;
X	target_k_flag = V_ned ;
X}
X
Xif (tag[V_bear]) {
X	for (j = 2; j <= 5; j++) {
X		if (enemy[j][E_status] != F_asleep) {
X			j_point = j ; 
X			goto bear_see ;
X		}
X	}
X	printf("I see no drop bear for me to kill! \n") ;
X	return ;
Xbear_see:
X	sw_see =  TRUE ;
X	target_k_flag = V_bear ;
X}
X
Xif (tag[V_wombat]) {
X	if (enemy[N_wombat][E_status] == F_asleep) {
X		printf("I see no wombat for me to kill!\n");
X		return ;
X	}
X	j_point = N_wombat ; 
X	sw_see =  TRUE ;
X	target_k_flag = V_wombat ;
X}
X
Xif (tag[V_snake]) {
X	for (j = 6; j <= 13; j++) {
X		if (enemy[j][E_status] != F_asleep) {
X			j_point = j ; 
X			goto hoop_see ;
X		}
X	}
X	printf("I see no hoop snake for me to kill! \n") ;
X	return ;
Xhoop_see:
X	sw_see =  TRUE ;
X	target_k_flag = V_snake ;
X}
X
Xif (tag[V_rifle]) sw_kill = TRUE ;
X
X/* see if the safe is being shot at */
Xif (tag[V_safe]&&(n == R_office_mang)) {
Xprintf("The safe is made out of harden steel.  You'll only waste ") ;
Xprintf("ammunition \nshooting at it.  Try to open it instead. \n") ;
Xreturn ;
X}
X
X/* see if the target is in the room or holding it */
Xfor (j=0; j <= objcnt; j++) {
X	if (tag[object[j][J_parse_id]]){
X 		if (object[j][J_parse_id] == V_rifle) continue ;
X		sw_other_object = TRUE ;
X		if (object[j][J_loc] == n) {
X			sw_see =  TRUE ;
X			target_k_flag = object[j][J_parse_id] ;
X			break ;
X		}
X		if (object[j][J_loc] == B_have) {
Xprintf("I will ***NOT*** shoot at something that I'm holding!!\n");
X			return ;
X		}
X	}
X}
X
Xif (tag[V_rifle] && (!sw_other_object)) tag[V_VERB_ONLY] = TRUE ;
X
Xif ((!tag[V_VERB_ONLY]) && (!tag[V_DIRECTION])) {
X	if (!sw_see) {
X		printf("I don't see it here to shoot at it. \n") ;
X		return; 
X	}
X
X	if (target_k_flag == V_NULL) {
Xprintf("It may be obvious to you, but you are going to have to tell\n");
Xprintf("me exactly what it is you want to have killed.\n");
X		return ;
X	}
X}
X
X/* resolve killing errors */
Xif (!sw_kill) {
X	printf("What weapon am I suppose to use? \n") ;
X	return ;
X}
X
Xif (object[O_rifle][J_loc] != B_have) {
Xprintf("I would do that.  Only there is one small problem.... \n") ;
X	printf("You don't have a rifle in your possesion! \n") ;
X	return ;
X}
X 
X/* Shoot the gun (or at least try to) */
Xprintf("You pull the trigger... \n\n") ;
X 
Xif (clip_flag == F_no_clip) {
Xprintf("Nothing happens!  \n") ;
Xprintf("Your rifle doesn't have an ammunition clip in it.\n") ;
X	return ;
X}
X 
Xif (object[O_rifle][J_property] <= 0) {
X	printf("Nothing happens!  The ammo clip is out of bullets.\n") ;
X	return ;
X}
X 
Xswitch(rifle_flag) {
Xcase F_safety:
X	printf("Nothing happens!  The rifle's safety is still on.\n");
X	return ;
X			
Xcase F_single:
X	printf("Bam! \n\n") ;
X	--object[O_rifle][J_property] ;
X	if (clip_flag == F_normal_clip) hits = 1;
X		else hits = 100 ;
X	break ;
X
Xcase F_triple:
X	if (object[O_rifle][J_property] >= 3) {
X		printf("Bam! Bam! Bam! \n\n") ;
X		object[O_rifle][J_property] -= 3 ;
X		if (clip_flag == F_normal_clip) hits = 3;
X			else hits = 300 ;
X	}
X	else {
X		for (i = 1; i <= object[O_rifle][J_property]; i++) 
X			printf("Bam! ") ;
X			printf("\n\nYou've run out of bullets. \n\n") ;
X		if (clip_flag == F_normal_clip) 
X			hits = object[O_rifle][J_property];
X			else hits = object[O_rifle][J_property]*100 ;
X		object[O_rifle][J_property] = 0 ;
X	}
X	break ;
X
Xcase F_auto:
X	if (object[O_rifle][J_property] >= 30) {
X		for (i = 1; i <= 3; i++) 
Xprintf("Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! \n") ;
X		object[O_rifle][J_property] -= 30 ;
X		hits = 30;
X	}
X	else {
X		i_10 = object[O_rifle][J_property]/10 ;
X		i_fract = object[O_rifle][J_property]-(i_10*10) ;
X		for (i = 1; i <= i_10; i++) 
Xprintf("Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! \n") ;
X		for (i = 1; i <= i_fract; i++) 
X			printf("Bam! ") ;
X			printf("\n\nYou've run out of bullets. \n") ;
X		if (clip_flag == F_normal_clip) 
X			hits = object[O_rifle][J_property];
X			else hits = object[O_rifle][J_property]*100 ;
X		object[O_rifle][J_property] = 0 ;
X	}
X	printf("\n") ;
X	break ;
X}
X 
X
X/* Target Seen block */
Xif (sw_see) {
X	/* Toggle the hurt switch if this is the first hit */
X	if (enemy[j_point][E_hits] == 0)  sw_hurt = FALSE ;
X	enemy[j_point][E_hits] += hits ;
X
X	switch(target_k_flag) {
X	case V_ned:
Xprintf("Ned Kelly keels over dead.  His body suddenly glows a bright ");
Xprintf("orange like it\nis being consummed by a heatless flame ");
Xprintf("and then the late Ned Kelly disappears\ninto a puff of ") ;
Xprintf("blue smoke. \n\n") ;
Xprintf("By the way, the recently deceased bushranger ***was*** ");
Xprintf("wearing iron body\narmour.  However thin sheets of iron ");
Xprintf("would just barely work against nineteenth\ncentury firearms ");
Xprintf("at long range.  Against a modern infantry rifle, Ned's\n");
Xprintf("armour offered about as much protection as a dunny paper ");
Xprintf("bandage. \n") ;
X		enemy[N_ned][E_location] = B_destroyed ;
X		enemy[N_ned][E_status] = F_asleep ;
X		monster_flag = F_no_monster ;
X		room[R_hideout][M_monster] = 0 ;
X	
X		/* create Ned Kelly's silver teapot */
X		++room[R_hideout][M_obj_cnt] ;
X		object[O_teapot][J_loc] = R_hideout ;
X		return ;
X
X	/* shoot the drop bear */
X	case V_bear:
X		if (enemy[j_point][E_hits] < 30) {
X			if (enemy[j_point][E_hits] == 1) {
Xprintf("Your bullet hit the drop bear causing it to howl in ");
Xprintf("anguish.  However drop\n");
Xprintf("bears are pretty tough and just one bullet isn't ");
Xprintf("going to kill it.\n") ;
X			}
X			else {
X				if (!sw_hurt) {
Xprintf("You've hit the drop bear and it is bleeding fairly ");
Xprintf("heavily.\n");
Xprintf("Unfortunately it is still alive and kicking and wants ") ;
Xprintf("your blood \n");
Xprintf("in payment for its.\n") ;
X					sw_hurt = TRUE ;
X				}
X				else {
Xprintf("You've hit the drop bear again.  It is weakening but still ");
Xprintf("alive.\n");
X				}
X			}
X			monster_flag = F_wounded ;
X			goto mad_bear ;
X		}
X
X		if (rifle_flag == F_single) {
Xprintf("That last bullet was the straw which broke the drop ") ;
Xprintf("bear's back.\n") ;
Xprintf("The blasted thing is finally dead! \n") ;
X		}
X		else {
Xprintf("The bullets riddled the drop bear with holes, killing it ") ;
Xprintf("instantly. \n") ; 
X		}
Xprintf("Suddenly the drop bear's corpse turns into a cloud of greasy ");
Xprintf("blue smoke,\n") ;
Xprintf("which floats away without a trace.\n") ;
X		sw_hurt = FALSE ;
X		enemy[j_point][E_location] = B_destroyed ;
X		enemy[j_point][E_status] = F_asleep ;
X		monster_flag = F_no_monster ;
X		room[n][M_monster] = 0 ;
X		return ;
X 
X		/* shoot the mutant wombat */
X	case V_wombat:
X		if (enemy[N_wombat][E_hits] < 300) {
X			if (enemy[N_wombat][E_hits] == 1) {
Xprintf("Your bullet hit the wombat causing it some minor discomfort.");
Xprintf("  Judging from its \n");
Xprintf("behavior, killing this beast is going to be tough! \n") ;
X			}
X			else {
X				if (!sw_hurt) {
Xprintf("You've hit the wombat and gotten its attention ") ;
Xprintf("but you've not\n");
Xprintf("seriously wounded it.  In fact, you've made it more fierce ");
Xprintf("than before.\n");
X					sw_hurt = TRUE ;
X				}
X				else {
Xprintf("You've hit the wombat again, but it is still going ");
Xprintf("strong.\n");
X				}
X			}
X			monster_flag = F_wounded ;
X			return ;
X		}
X
X		if (rifle_flag == F_single) {
Xprintf("That last bullet was the straw which broke the ") ;
Xprintf("wombat's back.\n") ;
Xprintf("The blasted thing is finally dead!\n\n") ;
X		}
X		else {
Xprintf("The bullets did the trick on the wretched thing.  It's ") ;
Xprintf("dead as a doornail.\n\n") ;
X		}
Xprintf("Suddenly the wombat's corpse starts to glow with an intense");
Xprintf(" white light.\n") ;
Xprintf("There is then a crackling sound as its body starts to burn.");
Xprintf("  You can\n");
Xprintf("smell the stench of burning hair.  Then the white light");
Xprintf(" begins to dim,\n");
Xprintf("leaving no trace left of the once formidable monster.\n");
X		sw_hurt = FALSE ;
X		enemy[N_wombat][E_location] = B_destroyed ;
X		enemy[N_wombat][E_status] = F_asleep ;
X		monster_flag = F_no_monster ;
X		room[n][M_monster] = 0 ;
X		return ;
X 
X	/* shoot the hoop snake */
X	case V_snake:
X		if ((rifle_flag == F_single)&&
X			(enemy[j_point][E_hits] < 3)) {
X			if (enemy[j_point][E_hits] == 1) {
Xprintf("Your bullet hit the hoop snake.  However the hoop snake's ");
Xprintf("thick scales \n");
Xprintf("slowed the bullet down.  The hoop snake is now hissing ");
Xprintf("furiously. \n") ;
X			}
X			else {
Xprintf("You've hit the hoop snake again, and it's hurting.  However ");
Xprintf("it is still \n");
Xprintf("alive and full of venom. \n") ;
X			}
X			monster_flag = F_wounded ;
X			return ;
X		}
X
X		if (rifle_flag == F_single) {
Xprintf("The bullet hit the hoop snake finishing the horrible ") ;
Xprintf("creature off. \n") ;
X		}
X		else {
Xprintf("The bullets hit the hoop snake splatting it into a mass of ") ;
Xprintf("mince meat. \n") ; 
X		}
Xprintf("Suddenly the bullet holed snake glows red and whooshes ");
Xprintf("into a cloud \n") ;
Xprintf("steam, leaving no traces behind.\n\n") ;
X		enemy[j_point][E_location] = B_destroyed ;
X		enemy[j_point][E_status] = F_asleep ;
X		monster_flag = F_no_monster ;
X		room[n][M_monster] = 0 ;
X		return ;
X
X	case V_can:
X	case V_beer:
X	case V_fourex:
X	case V_Fourex:
Xprintf("The can is hit by a bullet and flies off out of sight.\n");
X		object[O_can][J_loc] = B_destroyed ;
X		return;
X
X
X	case V_bottle:
X	case V_lager:
Xprintf("It is hit by a bullet and shatters into a million pieces.\n");
X		object[O_bottle][J_loc] = B_destroyed ;
X		return;
X
X	} /* end of target switch group */
X} /* end of the "target seen" block */
X 
X/* There was no target specified so the shot was wasted */
Xif (tag[V_VERB_ONLY]) { 
Xprintf("You didn't specify a target. So the rifle was pointed\n") ;
Xprintf("in a random direction and the ammunition wasted.\n") ;
X}
Xelse 
Xprintf("Except for wasting ammunition, nothing much happened.\n") ;
Xreturn ;
X
Xmad_bear:
Xif (enemy[j_point][E_hits] < 10) return ;
Xprintf("\nThe drop bear has been shot at so many times, that it ");
Xprintf("has gone mad\n") ;
Xprintf("with rage.  It leaps three meters and rips out your ") ;
Xprintf("throat with a\n");
Xprintf("single swish of its claws.  You die instantly. \n") ;
Xender(F_died) ;
X} /* --- end of the 'killer' subroutine --- */
END_OF_FILE
if test 18250 -ne `wc -c <'actor.c'`; then
    echo shar: \"'actor.c'\" unpacked with wrong size!
fi
# end of 'actor.c'
fi
if test -f 'opener.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'opener.c'\"
else
echo shar: Extracting \"'opener.c'\" \(12761 characters\)
sed "s/^X//" >'opener.c' <<'END_OF_FILE'
X#define OPNR
X#include "dink_sym.h"
X#include "dink_glb.h"
X
Xvoid dialer(n)
X/*****************************/
X/*      "dial" command"      */
X/*     Version:  Mk 1.1      */
X/*      29 October 1989      */
X/*****************************/
Xint n ;
X{
X
X/* deal with the question of "What is the combination?" */
Xif (tag[V_what]) {
Xprintf("I really don't know.  You might try looking around for a\n") ;
Xprintf("series of numbers. Sometimes that can be a clue to the\n") ;
Xprintf("actual combination.\n") ;
X	return ;
X}
X
X/* See if the combination was dialed in the right place */
Xif ((n == R_office_mang)&&
X	(room[R_office_mang][M_rm_status] >= S_revealed)) {
X	if (tag[V_0] && tag[V_49] && tag[V_67] && tag[V_82]) {
X		printf ("Click!! \n");
X		room[R_office_mang][M_rm_status] = S_dialed ;
X		return ; 
X	}
Xprintf ("You turned the dial but nothing happened.  I think you \n");   
Xprintf ("dialed the wrong thing. \n");
X	return ; 
X}
Xprintf ("How am I supposed to dial that? \n");
X} /* --- end of the "dialer" subroutine --- */
X
X 
Xvoid inventer()
X/*****************************/
X/*   "inventory" command     */
X/*     Version:  Mk 1.0      */
X/*       11 March 1989       */
X/*****************************/
X{
X#ifdef __TURBOC__
Xvoid objector(int) ;
X#endif
X
Xregister int i;
Xint i_ws, j_ws ;
X 
Xi_ws = 0 ;
Xj_ws = 0 ;
Xfor (i = 0; i <= objcnt; i++) if (object[i][J_loc] == B_have)  {
X	++j_ws;
X	i_ws = i ;
X	} ;
Xif ((j_ws == 0)&&(gleep_count == 0)) {
X	printf("You've got NOTHING!! \n") ;
X	return ;
X}
Xif (j_ws >= 1) {
X	if (j_ws == 1) {
X		printf("You are carrying ") ;
X		objector(i_ws);
X		printf ("\n") ;
X	}
X	else {
X		printf ("You are carrying the following: \n");
X		for (i = 0; i <= objcnt; i++) {
X			if (object[i][J_loc] == B_have) {
X				printf ("        ") ;
X				objector(i);
X				printf ("\n") ;
X			}
X		}
X	}
X}
Xif (gleep_count > 0) {
X	if (gleep_count == 1) {
X		printf("You have one gleep.\n") ;
X		return ;
X	}
X	printf("You are carrying %d gleeps. \n",gleep_count) ;
X}
X
X} /* --- end of the "inventor" subroutine --- */
X 
Xvoid drinker()
X/*****************************/
X/*     "drink" command       */
X/*     Version:  Mk 1.0      */
X/*       11 March 1989       */
X/*****************************/
X{
X
Xif (tag[V_can]) {
X	if (object[O_can][J_loc] == B_have) {
X		printf("The XXXX keeps on coming on ? \n") ;
Xprintf("I think not, for there is no Fourex left for me to drink!\n") ;
X	}
X	else goto no_booze ;
X	return ;
X}
X
Xif (tag[V_bottle]) {
X	if (object[O_bottle][J_loc] == B_have) {
Xprintf("Some greedy larrikin has drunk up all of the Black Swan! \n") ;
X	printf("Bad on Him! There is none left for me! \n") ;
X	return ;
X	}
Xno_booze:
X	printf ("You don't have it in your possession to drink!\n");
X	return ;
X}
X
Xif (tag[V_water]) {
X	printf("There is no water here that I am willing to drink.\n") ;
X	return ;
X}
X	
Xprintf ("What exactly do you want me to drink? \n");
Xreturn; 
X
X} /* --- end of the "drinker" subroutine --- */
X 
Xvoid reader()
X/*****************************/
X/*      "read" command       */
X/*     Version:  Mk 1.1      */
X/*        21 April 1989      */
X/*****************************/
X{
X#ifdef __TURBOC__
Xvoid rdtxt(int) ;
X#endif
X
Xint k ;
X
X/* reject an isolated "read" command */
Xif (tag[V_VERB_ONLY]) { 
X		printf ("What exactly do you want me to read? \n");
X		return;
X}
X
Xfor (;;) {
X	/* map from the manager's office */
X	if (tag[V_map]) {
X		k = O_map_frag ;
X		break;
X	}
X
X	/* Qadaffi's letter */
X	if (tag[V_letter]) {
X		k = O_letter ;
X		break ;
X	}
X
X	/* paper from the safe */
X	if (tag[V_paper]) {
X		k = O_paper ;
X		break;
X	}
X
X	/* Deal with unreadable objects */
X	printf("There is no way in which I can read that. \n");
X		return ;
X} /* end of the infinite for loop */
X
Xif (object[k][J_loc] == B_have) rdtxt(k) ;
Xelse printf ("I can't read it because it isn't in my possession. \n");
X}         /* --- end of the subroutine "reader" --- */
X
Xvoid unlocker(n)
X/*****************************/
X/*     "unlock" command      */
X/*      Version: Mk 1.1      */
X/*      16 September 1989    */
X/*****************************/
Xint n ;
X{
X 
Xif (tag[V_VERB_ONLY]) {
X	printf ("What do you want me to unlock? \n");
X	return; 
X}
X
Xif (room[n][M_rm_type] == T_action_obj) {
X	switch (n) {
X
X	/* Managers office */
X	case R_office_mang:
X		if (tag[V_safe]) {
Xprintf("This is a combination type safe (no key hole).  You must\n");
Xprintf("dial a combination in order to open this safe. \n");
X		}
X		else 
Xprintf("You're wasting your time.  You can't unlock that! \n");
X		return;
X
X	/* office entrance */
X	case R_office_entr:
X	if (tag[V_door]) {
X		if (room[R_office_entr][M_rm_status] == S_open) {
X			printf("The door is already open! \n");
X			return;
X		}
X		if (room[R_office_entr][M_rm_status] == S_kicked) {
X			printf("The door has been kicked in! \n");
X			return;
X		}
X		if (room[R_office_entr][M_rm_status] == S_unlocked) {
Xprintf("The door is already unlocked.  However it is still closed! \n");
X			return;
X		}
X		/* The door has to still be unlocked */
X		if (tag[V_key]) {
X		if (object[O_key][J_loc] != B_have) {
Xprintf("You don't have the key to this door in your possession! \n");
X		}
X		else {
X			printf("You turn the key in the lock and ") ;
X			printf("hear a satisfying \"click\".\n");
X			room[R_office_entr][M_rm_status] = S_unlocked ;
X		}
X		}
X		else printf ("With what shall I unlock the door? \n");
X		return; 
X	}
X
X	default:
Xprintf("I don't think that is the sort of thing one unlocks.\n") ;
X	}  /* end of "unlock" room scan switch */
X} /* end of "unmovable action device" block */
Xelse printf("There is nothing here that can be unlocked! \n");
Xreturn ;
X}  /* --- end of the "unlocker" subroutine --- */
X
Xvoid closer(n)
X/*****************************/
X/*     "close" command       */
X/*     Version:  Mk 1.0      */
X/*     12 November 1988      */
X/*****************************/
Xint n ;
X{
X 
X/* scan "close" sentence */
Xif (room[n][M_rm_type] != T_action_obj) {
Xprintf("There is nothing here that can be closed! \n");
X	return; 
X}
X
Xif (tag[V_VERB_ONLY]) {
X	printf ("What exactly do you want me to close? \n");
X	return; 
X}
X
Xswitch (n) {
X	/* office door */
X	case R_office_entr:
X		if (!tag[V_door]) break ;
X		if (room[R_office_entr][M_rm_status] == S_kicked) {
Xprintf("The door has been kicked in!  It'll never be closed again.\n");
X			return;
X		}
X		if (room[R_office_entr][M_rm_status] == S_open) {
X		printf("The office door closes with a slam. \n");
X			room[R_office_entr][2] = -1 ;
X			room[R_office_entr][M_rm_status] = S_closed ;
X			return ;
X		}
X		else printf("The office door is already closed! \n");
X		return ;
X
X	/* managers office */
X	case R_office_mang:
X	if ((!tag[V_picture])&&(!tag[V_safe])) break;
X	if (tag[V_safe]) {
X		if (room[R_office_mang][M_rm_status] < S_dialed) 
X		printf("The safe is already closed. \n");
X		else {
X	printf("The safe door closes and locks with a \"click\". \n");
X			room[R_office_mang][M_rm_status] = S_revealed ;
X		}
X	}
X	if (tag[V_picture]) {
X		if (room[R_office_mang][M_rm_status] == S_closed) 
X		printf("The platypus picture is already closed. \n");
X		else  {
Xprintf("The picture swings flush against the wall, hiding the safe.\n");
X			room[R_office_mang][M_rm_status] = S_closed ;
X		}
X	}
X	return ;
X
X} /* end of the "close" switch */
Xprintf ("I really don't see how one would close that? \n");
Xreturn; 
X} /* --- end of the "closer" subroutine --- */
X
Xvoid opener(n)
X/*****************************/
X/*      "open" command       */
X/*     Version:  Mk 2.1      */
X/*     25 April 1990         */
X/*****************************/
Xint n ;
X{
X#ifdef __TURBOC__
Xvoid boom(void), ender(int), objector(int) ;
X#endif
X
Xregister int i ;
X
X/* deal with a terse command */
Xif (tag[V_VERB_ONLY]) {
X	printf ("What exactly do you want me to open? \n");
X	return; }
X 
Xif (tag[V_can]) {
X	if (object[O_can][J_loc] == B_have) 
Xprintf("Some bugger has already drunk it up. The stubee is empty!\n");
X	else printf("You don't have a can to open! \n") ;
X	return; 
X}
X
Xif (tag[V_letter]) {
X	if (object[O_letter][J_loc] == B_have) {
X		boom() ; /* cause an explosion */
Xprintf("It's not polite to read other people's mail!!  As you lay\n") ;
Xprintf("bleeding on the floor with your hands and arms blown away,\n") ;
Xprintf("you realize that envelope actually contained a letter bomb!\n");
Xprintf("(A trick widely used by terrorists in the 1970s).  However\n");
Xprintf("the knowledge does you little good since your spirit soon\n");
Xprintf("departs this mortal coil.\n");
X		ender(F_died) ;
X	}
X	else printf("You don't have a letter to open!\n") ;
X	return ;
X}
X
Xif (tag[V_bottle]) {
X	if (object[O_bottle][J_loc] == B_have)
Xprintf("Some bugger has already drunk it up. The bottle is Empty! \n");
X	else printf("You don't have a bottle to open! \n") ;
X	return; 
X}
X
Xif (tag[V_umbrella]) {
X	if (object[O_umbrella][J_loc] == B_have) {
Xprintf("You open the umbrella but find it's full of holes and\n");
Xprintf("its clasp is broken.  As soon as you release it, the\n");
Xprintf("umbrella snaps shut.\n") ;
X	}
X	else printf("You don't have an umbrella to open! \n") ;
X	return; 
X}
X 
X/* Now check to see if the location is consistent with the command */
Xif (room[n][M_rm_type] != T_action_obj) { 
X	printf ("I don't understand what you want me to open. \n") ;
X	return ;
X}
X
Xswitch (n) {
X	/* office entrance (door) */
X	case R_office_entr:
X		if (tag[V_door]) {
X		switch (room[R_office_entr][M_rm_status]) {
X			case S_kicked:
Xprintf("The door has been kicked in!  You don't need to open it.\n");
X				return;
X		
X			case S_open:
X				printf("The door is already open! \n");
X				return ;
X		
X			case S_unlocked:
Xprintf("As you push open the office door, the rusty hinges creak \n");
Xprintf("from long disuse.  Darkness and stale air seem to exude \n");
Xprintf("from the vacant office.  The way is free for you to enter. \n");
X				room[R_office_entr][2] = R_office_hall ;
X			room[R_office_entr][M_rm_status] = S_open ;
X				return ;
X		
X			case S_closed:
Xprintf("The office door is locked tight.");
Xprintf("  You need to unlock it with a key. \n");
X				return ;
X		} /* end of room status switch */
X		} /* end of the door "if" block */
X		break ;
X
X	/* managers office */
X	case R_office_mang:
X		if ((!tag[V_picture])&&(!tag[V_safe])) {
Xprintf("I don't understand how I would open that.\n") ;
X			return ;
X		}
X
X		if (tag[V_picture]) {
X		switch (room[R_office_mang][M_rm_status]) {
X		case S_closed:
Xprintf("You swing open the platypus picture revealing a large wall \n");
Xprintf("safe with a combination dial. \n");
X			room[R_office_mang][M_rm_status] = S_revealed ;
X			break ;
X		default:
Xprintf("The picture is already swung out.  The problem is to open \n");
Xprintf("the safe!!  Hint:  Dial in a combination. \n");
X			return ;
X		}
X		} /* end of the picture "if" block */
X
X		if (tag[V_safe]) {
X		switch (room[R_office_mang][M_rm_status]) {
X		case S_closed:
Xprintf("I can see no safe in this office for me to open.  Perhaps\n");
Xprintf("there is a safe hidden in this office somewhere.\n");
X			return ;
X
X		case S_revealed:
Xprintf("The safe is locked.  You must first dial the combination\n");
Xprintf("in order to open it.  See if you can find the combination. \n");
X			return ;
X		
X		case S_dialed:
X	printf("The safe door swings open smoothly and easily. \n");
X			room[R_office_mang][M_rm_status] = S_open ;
X			sw_active = TRUE ;
X			for (i=0; i <= objcnt; i++) 
X			if (object[i][J_loc] == B_in_safe) {
Xprintf ("Inside the safe, you see the following: \n");
X				for (i=0; i <= objcnt; i++) {
X				if (object[i][J_loc] == B_in_safe) {
X					printf ("        ") ;
X					objector(i);
X					printf ("\n") ;
X				}
X				}				
X				return ;
X			}
X		printf("---The safe is empty.--- \n");
X			return ;
X
X		case S_open:
X			printf("The safe is already open! \n");
X			return ;
X		} /* end of the "safe" status switch */
X		} /* end of the safe "if" block */
X		return ; /* this return statement must remain */
X
X	/* Lift door(s) */
X	case R_lift_entr:
X		if (tag[V_door]||tag[V_lift]) {
Xprintf("It is not exactly clear how I would open these doors.\n") ;
Xprintf("However I see a push button next to the lift doors.\n") ;
Xprintf("Perhaps if I pressed the button something would happen.\n") ;
X		}
X		else printf("I'm confused about what I should open.\n");
X		return ;
X		
X} /* end of the "open" room switch */
Xprintf ("I see nothing here that I can open. \n") ;
X} /* --- end of the "opener" subroutine --- */
X
Xvoid boom()
X{
Xprintf("\n\n");
Xprintf("BBBBBB      OOOOO        OOOOO      MM        MM      !!!\n");
Xprintf("B    BB   OO     OO    OO     OO    M M      M M      !!!\n");
Xprintf("B    BB   OO     OO    OO     OO    M  M    M  M      !!!\n");
Xprintf("BBBBBB    OO     OO    OO     OO    M   M  M   M      !!!\n");
Xprintf("B    BB   OO     OO    OO     OO    M    MM    M      !!!\n");
Xprintf("B    BB   OO     OO    OO     OO    M          M\n");
Xprintf("BBBBBB      OOOOO        OOOOO      M          M      !!!\n\n");
X} /* --- end of the "boom" subroutine --- */
END_OF_FILE
if test 12761 -ne `wc -c <'opener.c'`; then
    echo shar: \"'opener.c'\" unpacked with wrong size!
fi
# end of 'opener.c'
fi
if test -f 'parse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'parse.c'\"
else
echo shar: Extracting \"'parse.c'\" \(14440 characters\)
sed "s/^X//" >'parse.c' <<'END_OF_FILE'
X#define PARSE
X#include "dink_sym.h"
X#include "dink_glb.h"
X#include <string.h>
X 
Xvoid parse()
X/*********************************************************/
X/*                                                       */
X/*      --- English Language Parsing Subroutine ---      */
X/*                                                       */
X/*  This subroutine parses a sentence of up to nineteen  */
X/*  words and decodes the words into integers and passes */
X/*  a twenty element vector back to the calling          */
X/*  program.  The digit 0, implies an unused word.  The  */
X/*  digit -1 (V_LINE_END), indicates end of sentence.    */
X/*                                                       */
X/*      Program by Gary A. Allen, Jr.   5 March 1990     */
X/*        (c) Copywrite 1990 by Gary A. Allen, Jr.       */
X/*                                                       */
X/*********************************************************/
X{
X#ifdef __TURBOC__ 
Xchar getche(void) ;
Xvoid purge(int, int*) ;
X#endif
X
Xregister int i, j ;
Xint m, n, j_point, jacc, i_ws, sw_adverb, sw_purge, j_purge, sw_punct ;
Xint sw_movement, sw_adverb_fnd ;
Xint j_old = 0 ; /* this is to keep Lint happy */
X/* a sentence can have 19 words of 15 letters */ 
Xchar words[20][15], word[15] ;
Xchar letter ;
X
X/* flush the "sent vector" */
Xfor (i=0; i<=19; i++) sent[i]=0 ;
X
X/* flush the tag vector */
Xfor (i=0; i<= tag_max; i++) tag[i] = FALSE ;
X
X/* Parse and load in the words */
Xinput:
Xsw_punct = FALSE ;
Xfor (i=0; i <= 18; i++) {
X	for (j=0; j <= 14; j++) {
X#ifndef __TURBOC__
X		letter = getchar() ;	
X#endif
X
X#ifdef __TURBOC__
X		letter = getche() ;	
X#endif
X
X		switch (letter) {
X			case '\n':
X			case 13 :
X				if ((i == 0) && (j == 0)) goto input ;
X				words[i][j] = '\0' ;  
X				goto decode; 
X
X			case 8:
X				if (sw_punct) {
X					if (--i < 0) i = 0 ;
X					j = j_old ;
X					sw_punct = FALSE ;
X				}
X				else if (--j < 0) j = 0 ;
X				--j ;
X				continue ;
X
X			case '\"':
X			case ' ':
X			case ',':
X			case '.':
X			case ';':
X			case ':':
X			case '?':
X			case '!':
X			case '&':
X			case '{':
X			case '}':
X			case '[':
X			case ']':
X			case ')':
X			case '(':
X			case '\'':
X			case '`':
X			case '\t':
X				words[i][j] = '\0' ;  
X				sw_punct = TRUE ;
X				j_old = j ;
X				break;
X
X			default:
X				words[i][j] = letter ;
X				sw_punct = FALSE ;
X				continue ;
X		}
X		break ;
X	}
X	if (j > 14) {
Xprintf("\nYou're saying nonsense! Type the sentence again. \n");
X		break ;
X	}
X	if (j == 0) i-- ;
X}
Xif (i > 18) 
Xprintf ("\nYour sentence is too long. Type something shorter! \n") ;
X
X#ifndef __TURBOC__
X/* Purge the input buffer */
X	for (;;) if ('\n' == getchar()) break ;
Xgoto input;
X/* decode the words from the known vocabulary */
Xdecode:
X#endif
X
X#ifdef __TURBOC__
Xgoto input;
X/* decode the words from the known vocabulary */
Xdecode:
Xprintf("\n") ;
X#endif
X
Xm=i ;
Xjacc=0;
Xfor (i=0; i<=m; i++) {
X	for (j=0; j<=14; j++) {
X		word[j] = words[i][j] ; 
X	}
X	for (j=0; j<=letmax; j++) {
X		n = strcmp (word,vocab[j]);
X		if (n == 0) {
X			if ((j>9)&&(j<20)) j -= 10;
X			sent[jacc++]=j+1 ;
X			break; 
X		}
X	}
X}
X
Xif (jacc == 0) {
X	printf ("Nothing you said was understandable! Try again. \n");
X	goto input; 
X}
X 
X/* mark last word */
Xsent[jacc] = V_LINE_END ;
X 
X/* Check to see if this is a simple move command */
Xif (sent[0] <= 10) {
X	tag[V_MOVE] = TRUE ;
X	tag[V_DIRECTION] = TRUE ;
X	verb = sent[0] ;
X	return ; 
X}
X 
X/* adjective and "in/out" preposition scan */
Xsw_purge = FALSE ;
Xfor (j = 0; j <= jacc-1; j++) {
X
X	/* check for adjectives*/
X	for (i = 0; i <= adj_max; i++) {
X		if (sent[j] == adjective[i][Aj_adj]) {
X
X		/* does a noun have to be ignored ? */
X		if (adjective[i][Aj_adj_cmd] == F_ignore) {
X		if (adjective[i][Aj_trig_noun] != sent[j+1]) break ;
X		}
X
X		/* does a noun have to be replaced? */
X		if (adjective[i][Aj_adj_cmd] == F_replace) {
X			if (adjective[i][Aj_trig_noun] == sent[j+1]) {
X			sent[j+1] = adjective[i][Aj_act_noun] ;
X			}
X		}
X		sw_purge = TRUE ;
X		j_purge = j ;
X		}
X	}
X}
X
X/* purge processed adjective from sentence */
Xif (sw_purge) purge(j_purge, &jacc) ;
X 
X/* Verb grammer check */
X/* see if the sentence is of a command sentax */
Xfor (i = 0; i <= verb_max; i++) {
X	if (sent[0] == verb_table[i]) goto synonym ;
X}
X 
X/* the first word is --not-- a verb, so one must be swapped in */
Xif (jacc != 1) for (j = 1; j <= jacc-1; j++) {
X	/* Check to see if the word is a move command */
X	if (sent[j] <= 10) {
X		tag[V_MOVE] = TRUE ;
X		i_ws = sent[0] ;
X		sent[0] = sent[j] ;
X		sent[j] = i_ws ;
X		goto synonym ;
X	}
X	/* if not a move command then check the verb table */
X	for (i = 0; i <= verb_max; i++) {
X		if (sent[j] == verb_table[i]) {
X			i_ws = sent[0] ;
X			sent[0] = sent[j] ;
X			sent[j] = i_ws ;
X			goto synonym ;
X		}
X	}
X}
X
X/* Check to see if this is a "question" sentence */
Xfor (i = 0; i <= quest_max; i++) {
X	if (sent[0] == quest[i]) {
X		/* shift the sentence over and load in "question" */ 
X		for (j = jacc; j >= 0; j--) sent[j+1] = sent[j] ;
X		sent[0] = V_QUESTION ;
X		tag[V_QUESTION] = TRUE ; 
X		if (++jacc == 2) {
X		/* Sentence is a one word command */
X			tag[V_VERB_ONLY] = TRUE ;
X			tag[sent[1]] = TRUE ;
X			verb = V_QUESTION ;
X			return ;
X		}
X		goto synonym ;
X	} 
X}
X
X/* Verb error routine */
Xprintf ("If there was a verb in that sentence, I didn't understand ") ;
Xprintf ("it.\n") ;
Xgoto input ;
X
Xsynonym:
X/* prescan for verb connected movement commands */
Xswitch(sent[0]) { 
Xcase V_go:
Xcase V_move:
Xcase V_walk:
Xcase V_run:
Xcase V_jump:
Xcase V_bop:
Xcase V_hop:
Xcase V_stroll:
Xcase V_saunter:
Xcase V_swagger:
X	sw_movement = TRUE ;
X	break ;
Xdefault:
X	sw_movement = FALSE ;
X}
X
X/* adverb scan, sent[0] is the verb */
Xsw_adverb = FALSE ;
Xsw_adverb_fnd = FALSE ;
Xfor (i = 0; i <= adv_max; i++) {
X	for (j = 1; j <= jacc-1; j++) {
X		/* see if this is an adverb */
X		if (sent[j] == adverb[i][Av_adv]) {
X			j_point = j ;
X			sw_adverb = TRUE ;
X
X			/* does the sentence have the companion verb? */
X			if (adverb[i][Av_verb_old] == sent[0]) {
X				sent[0] = adverb[i][Av_verb_new] ;
X				sw_adverb = FALSE ;
X				sw_adverb_fnd = TRUE ;
X
X			/* purge processed adverb from sentence */
X				purge(j, &jacc) ;
X			}
X		}
X	}
X}
X
X/* purge unprocessed adverb from sentence */
Xif (sw_adverb && (!sw_movement)) purge(j_point, &jacc) ;
X 
X/* scan the sentence for the movement direction */
Xif ((!sw_adverb_fnd) && sw_movement) {
X	for (j = 0; j <= jacc-1; j++) {
X		if (sent[j] <= 10) {
X			tag[V_MOVE] = TRUE ;
X			tag[V_DIRECTION] = TRUE ;
X			verb = sent[j] ;
X			return ;
X		}
X		if (sent[j] == V_LINE_END) break ;
X	}
X	printf("Where to?  In what direction?\n") ;
X	goto input ;
X} 
X
Xtag[sent[0]] = TRUE ;  /* activate the tag for the verb */
X 
Xif (jacc == 1) {
X/* Sentence is a one word command */
X	tag[V_VERB_ONLY] = TRUE ;
X	verb = sent[0] ;
X	if (sent[0] <= 4) return ; /* first 5 elements are reserved */
X	return ;
X}
X
X/* Load the "tag" matrix for detected words and synonyms */
Xfor (j=1; j <= 19; j++) {
X	if (sent[j] == V_LINE_END) break ;
X	if (sent[j] <= 10) tag[V_DIRECTION] = TRUE ;
X	if (sent[j] <= 4) continue ; /* first 5 elements are reserved */
X	tag[sent[j]] = TRUE ;  /* activate an element for each word */
X
X	/* Deal with synonym nouns */
X	switch(sent[j]) {
X
X	case V_automatic:
X	case V_AUTO:
X		tag[V_auto] = TRUE ;
X		continue ;
X 
X	case V_bar:
X		tag[V_gold] = TRUE ;
X		continue ;
X
X	case V_beer:
X	case V_fourex:
X	case V_Fourex:
X		tag[V_can] = TRUE ;
X		continue ;
X
X	case V_cockroaches:
X		tag[V_PLURAL] = TRUE ;
X		tag[V_cockroach] = TRUE ;
X		continue ;
X 
X	case V_diamond:
X		tag[V_ring] = TRUE ;
X		continue ;
X 
X	case V_doormat:
X		tag[V_mat] = TRUE ;
X		continue ;
X
X	case V_drop:
X		tag[V_bear] = TRUE ;
X		continue ;
X
X	case V_everything:
X		tag[V_all] = TRUE ;
X		continue ;
X
X	case V_lager:
X		tag[V_bottle] = TRUE ;
X		continue ;
X
X	case V_fuse:
X		tag[V_cap] = TRUE ;
X		continue ;
X
X	case V_gleeps:
X		tag[V_PLURAL] = TRUE ;
X		tag[V_gleep] = TRUE ;
X		continue ;
X
X	case V_hoop:
X		tag[V_snake] = TRUE ;
X		continue ;
X
X	case V_M16:
X	case V_m16:
X	case V_gun:
X		tag[V_rifle] = TRUE ;
X		continue ;
X
X	case V_kangaroos:
X		tag[V_PLURAL] = TRUE ;
X		tag[V_kangaroo] = TRUE ;
X		continue ;
X
X	case V_magazine:
X	case V_ammo:
X		tag[V_clip] = TRUE ;
X		continue ;
X
X	case V_mail:
X	case V_envelope:
X		tag[V_letter] = TRUE ;
X		continue ;
X
X	case V_matches:
X		tag[V_PLURAL] = TRUE ;
X		tag[V_match] = TRUE ;
X		continue ;
X
X	case V_Ned:
X	case V_kelly:
X	case V_Kelly:
X		tag[V_ned] = TRUE ;
X		continue ;
X
X	case V_off_q:
X		tag[V_off] = TRUE ;
X		continue ;
X
X	case V_on_q:
X		tag[V_on] = TRUE ;
X		continue ;
X 
X	case V_plan:
X		tag[V_map] = TRUE ;
X		continue ;
X
X	case V_painting:
X		tag[V_picture] = TRUE ;
X		continue ;
X
X	case V_doors:
X		tag[V_PLURAL] = TRUE ;
X		tag[V_door] = TRUE ;
X		continue ;
X
X	case V_pills:
X	case V_packet:
X		tag[V_PLURAL] = TRUE ;
X	case V_atropine:
X		tag[V_pill] = TRUE ;
X		continue ;
X
X	case V_safety:
X	case V_SAFE:
X		tag[V_safe] = TRUE ;
X		continue ;
X 
X	case V_silver:
X		tag[V_coin] = TRUE ;
X		continue ;
X
X	case V_spinifexes:
X		tag[V_PLURAL] = TRUE ;
X		tag[V_spinifex] = TRUE ;
X		continue ;
X
X	case V_stick:
X		tag[V_dynamite] = TRUE ;
X		continue ;
X
X	case V_switch:
X		tag[V_button] = TRUE ;
X		continue ;
X
X	case V_treasure:
X		tag[V_all] = TRUE ;
X		continue ;
X
X	case V_I:
X		tag[V_single] = TRUE ;
X		continue ;
X
X	case V_III:
X		tag[V_triple] = TRUE ;
X		continue ;
X
X	case V_zero:
X		tag[V_0] = TRUE ;
X		continue ;
X
X	case V_forty_nine:
X		tag[V_49] = TRUE ;
X		continue ;
X
X	case V_sixty_seven:
X		tag[V_67] = TRUE ;
X		continue ;
X
X	case V_eighty_two:
X		tag[V_82] = TRUE ;
X		continue ;
X
X	default:
X		continue ;
X	}
X} /* end of sentence tag word scan */
Xverb = sent[0] ;
Xreturn ;
X
X} /* --- end of "parse" subroutine --- */
X
Xvoid purge(k_start, k_finish)
X/***********************************/
X/*                                 */
X/*   Sentence Purging Subroutine   */
X/*                                 */
X/* Version: Mk 1.0  3 March 1990   */
X/*                                 */
X/***********************************/
X
Xint k_start, *k_finish ;
X{
Xregister int k ;
Xint k_end ;
X
Xk_end = *k_finish ;
Xfor (k = k_start; k <= k_end-1; k++) sent[k] = sent[k+1] ;
X*k_finish = --k_end ;
X} /* --- end of "purge" subroutine --- */
X
Xvoid filler()
X/***********************************/
X/*                                 */
X/*        Looker Subroutine        */
X/*                                 */
X/* Version: Mk 1.0  18 August 1989 */
X/*                                 */
X/***********************************/
X{
X
Xif (tag[V_VERB_ONLY]) {
X	printf("Fill what?\n") ;
X	return ;
X}
Xif (tag[V_can]) {
X	if (object[O_can][J_loc] != B_have) 
Xprintf("You don't have the Fourex can in your possession!\n") ;
Xelse printf("I can't do it!  There's a hole in the can's bottom.\n") ;
X	return ;
X}
Xif (tag[V_bottle]) {
X	if (object[O_bottle][J_loc] != B_have) 
Xprintf("You don't have the bottle in your possession!\n") ;
Xelse printf("I can't do it!  The bottle has a crack in it's bottom.\n");
X	return ;
X}
Xprintf("I can't fill that!\n") ;
X} /* --- end of the "filler" subroutine --- */
X
Xvoid looker(n)
X/***********************************/
X/*                                 */
X/*        Looker Subroutine        */
X/*                                 */
X/* Version: Mk 1.0  18 August 1989 */
X/*                                 */
X/***********************************/
Xint n ;
X{
X#ifdef __TURBOC__
Xvoid long_descp(int), describe(int), objlooker(int), gleeper(int) ;
Xvoid actor(int), rdtxt(int) ;
X#endif
X
Xint m ;
X
X/* an isolated "look" means to just look at the room */
Xif (tag[V_VERB_ONLY]) { 
X	/* goto long description test*/
X	if ((room[n][M_rm_type] == T_was_long)||(n == R_lift_inside))
X	   long_descp(n);
X	else describe (n) ;
X	objlooker(n) ; /* Check if there are objects in the room */
X	gleeper(n) ;   /* check for gleeps and update the gleep count */
X	/* describe unmovable action objects and status */
X	if (room[n][M_rm_type] == T_action_obj) actor(n) ;
X	return ;
X}
X
X/* Gleep tank */
Xif (tag[V_tank]) {
X	if (n == R_gleep_tank) {
Xprintf("You look inside the gleep tank and see a blue fluid which\n") ;
Xprintf("smells of chlorine") ;
X		if (gleep_score == 0) {
Xprintf(".\n") ;
X			return ;
X		}
X		if (gleep_score == 1) {
Xprintf(" and a single gleep submerged in the fluid.\n") ;
X			return ;
X		}
Xprintf(" and %d gleeps submerged in the fluid.\n",
X		gleep_score) ;
X		return ;
X	}
X	else {
X		printf("There is no gleep tank here!\n") ;
X		return ;
X	}
X}
X
X/* wall safe */
Xif (tag[V_safe]) {
X	if ((n == R_office_mang)&&
X		(room[R_office_mang][M_rm_status] >= S_revealed)) {
X		m = O_safe ;
X		rdtxt(m);
X	}
X	else printf("I see no safe here for me to describe.\n");
X	return ;
X}
X
Xfor (;;) {
X	/* map from the manager's office */
X	if (tag[V_map]) {
X		m = O_map_frag ;
X		break ;
X	}
X
X	/* Fourex can */
X	if (tag[V_can]) {
X		m = O_can ;
X		break ;
X	}
X
X	/* Atropine pills */
X	if (tag[V_pill]) {
X		m = O_pills ;
X		break ;
X	}
X
X	/* Qadaffi's letter bomb */
X	if (tag[V_letter]) {
X		m = O_letter ;
X		break ;
X	}
X
X	/* paper from the safe */
X	if (tag[V_paper]) {
X		 m = O_paper ;
X		break ;
X	}
X
X	/* ammo clip */            
X	if (tag[V_clip]) {
X		m = O_clip ;
X		break ;
X	}
X
X	/* orange clip */
X	if (tag[V_org_clip]) {
X		m = O_org_clip ;
X		break ;
X	}
X
X	/* rifle */
X	if (tag[V_rifle]) {
X		m = O_rifle ;
X		break ;
X	}
X
X	/* Semtex detector */
X	if (tag[V_detector]) {
X		m = O_detector ;
X		break ;
X	}
X 
X	/* Deal with unreadable objects */
X	printf("There is nothing more that I can describe about it.\n");
X	return ;
X} /* end of infinite for block */
X
Xif (object[m][J_loc] == B_have) rdtxt(m);
Xelse 
Xprintf("I can examine an object only if it is in my possession.\n");
X
X} /* --- end of the "looker" subroutine --- */
X
Xvoid pass()
X/***********************************/
X/*                                 */
X/*        Password Subroutine      */
X/*                                 */
X/* Version: Mk 1.0  29 July 1989   */
X/*                                 */
X/***********************************/
X{
X
X#ifdef __TURBOC__
Xvoid exit(int);
Xchar getch(void) ;
X#endif
X
Xregister int i ;
Xchar chr ;
Xstatic char *passwd = "2Xngootx7Ysd4Du9" ;
X
X/* Request password */
Xprintf("Enter password:  ") ;
X
X#ifndef __TURBOC__
Xfor (i = 2; i <= 7; i++) {
X	chr = getchar() ;
X	if (chr+i-1 != passwd[i]) exit(0) ;
X}	
Xif (getchar() != '\n') exit(0) ;
Xprintf(".\n") ;  /* indicate that the password was accepted */
X#endif
X
X#ifdef __TURBOC__
Xfor (i = 2; i <= 7; i++) {
X	chr = getch() ;
X	if (chr+i-1 != passwd[i]) { 
X		for (;;) if (getch() == 3) break ;
X		printf("\r                    \n") ;
X		exit(0) ;
X	}
X}
Xprintf("\r.                     \n") ;
X#endif
X
Xsw_wizard = TRUE ; /* toggle wizard switch */
X
X} /* --- end of the "pass" subroutine */
END_OF_FILE
if test 14440 -ne `wc -c <'parse.c'`; then
    echo shar: \"'parse.c'\" unpacked with wrong size!
fi
# end of 'parse.c'
fi
echo shar: End of archive 5 \(of 6\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
