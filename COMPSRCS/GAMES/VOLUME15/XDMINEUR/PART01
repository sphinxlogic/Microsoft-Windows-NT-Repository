Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v15i052:  xdemineur - another minesweeper game, Part01/03
Message-ID: <4227@master.CNA.TEK.COM>
Date: 18 Jan 93 20:39:46 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1364
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1551

Submitted-by: baudoin@bertrand.ensta.fr (Marc Baudoin)
Posting-number: Volume 15, Issue 52
Archive-name: xdemineur/Part01
Environment: X11, Xlib


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  README MANIFEST bitmaps bitmaps/xdemineur.bm main.c
#   xdemineur.c
# Wrapped by billr@saab on Mon Jan 18 12:34:57 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(213 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XXdemineur is another implementation of the minesweeper game for X. Although
Xall the documentation is in French, it should be easy enough to figure out
Xthe basics. This version, unlike some others, does use color.
END_OF_FILE
if test 213 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1726 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Imakefile                  2	
X LISEZMOI                   2	
X MANIFEST                   1	This shipping list
X Makefile.test              2	
X README                     1	
X bitmaps                    1	
X bitmaps/bof.bm             2	
X bitmaps/case.bm            3	
X bitmaps/croix.bm           3	
X bitmaps/drapeau.bm         3	
X bitmaps/heureux.bm         2	
X bitmaps/icone.bm           2	
X bitmaps/icone_blanc.bm     2	
X bitmaps/icone_gris.bm      2	
X bitmaps/interro.bm         3	
X bitmaps/joue.bm            2	
X bitmaps/manquee.bm         3	
X bitmaps/mine.bm            3	
X bitmaps/num_case_0.bm      3	
X bitmaps/num_case_1.bm      3	
X bitmaps/num_case_2.bm      3	
X bitmaps/num_case_3.bm      3	
X bitmaps/num_case_4.bm      3	
X bitmaps/num_case_5.bm      3	
X bitmaps/num_case_6.bm      3	
X bitmaps/num_case_7.bm      3	
X bitmaps/num_case_8.bm      3	
X bitmaps/numero_0.bm        2	
X bitmaps/numero_1.bm        2	
X bitmaps/numero_2.bm        2	
X bitmaps/numero_3.bm        2	
X bitmaps/numero_4.bm        2	
X bitmaps/numero_5.bm        2	
X bitmaps/numero_6.bm        2	
X bitmaps/numero_7.bm        2	
X bitmaps/numero_8.bm        2	
X bitmaps/numero_9.bm        2	
X bitmaps/pied.bm            3	
X bitmaps/reflet.bm          3	
X bitmaps/reflet_manquee.bm  2	
X bitmaps/relief_blanc.bm    3	
X bitmaps/relief_gris.bm     3	
X bitmaps/select_blanc.bm    2	
X bitmaps/select_gris.bm     2	
X bitmaps/triste.bm          2	
X bitmaps/xdemineur.bm       1	
X demineur.c                 2	
X demineur.h                 2	
X main.c                     1	
X xdemineur.c                1	
X xdemineur.h                2	
X xdemineur.man              2	
END_OF_FILE
if test 1726 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test ! -d 'bitmaps' ; then
    echo shar: Creating directory \"'bitmaps'\"
    mkdir 'bitmaps'
fi
if test -f 'bitmaps/xdemineur.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/xdemineur.bm'\"
else
echo shar: Extracting \"'bitmaps/xdemineur.bm'\" \(2279 characters\)
sed "s/^X//" >'bitmaps/xdemineur.bm' <<'END_OF_FILE'
X#define xdemineur_width 50
X#define xdemineur_height 50
Xstatic char xdemineur_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04,
X   0x00, 0x00, 0x00, 0x00, 0x0e, 0x60, 0x0c, 0xe0, 0x00, 0x00, 0x00, 0x12,
X   0x1c, 0x70, 0x90, 0x00, 0x00, 0x00, 0x22, 0x03, 0x80, 0x89, 0x00, 0x00,
X   0x00, 0xc4, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x20,
X   0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00,
X   0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
X   0x08, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x40, 0x00,
X   0x00, 0x00, 0x04, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
X   0x40, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0xc0, 0x03,
X   0x80, 0x03, 0x80, 0x07, 0x00, 0x30, 0x00, 0x40, 0x04, 0x00, 0x18, 0x00,
X   0x10, 0x00, 0x40, 0x04, 0x00, 0x10, 0x00, 0x30, 0x00, 0x40, 0x04, 0x00,
X   0x18, 0x00, 0xc0, 0x03, 0x80, 0x03, 0x80, 0x07, 0x00, 0x00, 0x02, 0x00,
X   0x00, 0x80, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
X   0x04, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x40, 0x00,
X   0x00, 0x00, 0x08, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
X   0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10,
X   0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x20, 0x00, 0x00,
X   0x00, 0xc4, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x22, 0x03, 0x80, 0x89,
X   0x00, 0x00, 0x00, 0x12, 0x1c, 0x70, 0x90, 0x00, 0x00, 0x00, 0x0e, 0x60,
X   0x0c, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x03,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00};
END_OF_FILE
if test 2279 -ne `wc -c <'bitmaps/xdemineur.bm'`; then
    echo shar: \"'bitmaps/xdemineur.bm'\" unpacked with wrong size!
fi
# end of 'bitmaps/xdemineur.bm'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(17690 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/* ********************************************************************** */
X/*                                                                        */
X/* xdemineur - Jeu de reflexion sous X, version 1.0                       */
X/*                                                                        */
X/* Copyright : Marc Baudoin (baudoin@ensta.fr)                            */
X/*                                                                        */
X/*            |\                                                          */
X/*          |\| \                                                         */
X/*          |//  )                                                        */
X/*        |\ /  /        /\/\_                                            */
X/*        |//  /        /. . /                                            */
X/*      |\ /  /     ___/    |_                                            */
X/*      |//  /     (____/    /_/\_                                        */
X/*       |__|      (_____/ __     >                                       */
X/*     /| ___  ________ _< \ \__  >                                       */
X/*     \|| __\| _|_   _/ \\ \___\/                                        */
X/*       | __\____ | |/ _ \\    >                                         */
X/*     /||___\_____|___/ \_\\  _>                                         */
X/*     \|____           ____ \|                                           */
X/*       \   \_________/   /                                              */
X/*        \   _    _      /                                               */
X/*         \_//   //_____/                                                */
X/*           (_   \ (_  _\                                                */
X/*             |/\|   \/                                                  */
X/*                                                                        */
X/* Ecole Nationale Superieure de Techniques Avancees (ENSTA)              */
X/* 32, boulevard Victor - 75015 Paris - France                            */
X/*                                                                        */
X/* Vous avez le droit d'utiliser et de distribuer xdemineur et sa         */
X/* documentation pourvu que cette notice de copyright apparaisse sur      */
X/* toutes les copies et que vous ne tiriez aucun profit de mon programme. */
X/*                                                                        */
X/* ********************************************************************** */
X
X
X
X#include <stdio.h>
X#include <string.h>
X#include <sys/time.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X
X#include "demineur.h"
X#include "xdemineur.h"
X
X#include "bitmaps/xdemineur.bm"
X
Xextern struct jeu    **tableau ;
Xextern int             nb_lig , nb_col , nb_mines ;
Xextern time_t          temps ;
Xextern BOOLEAN         perdu , gagne , jeu , ouvre ;
X
XDisplay   *display ;
Xint        screen ;
XWindow     window ;
XGC         gc ;
X
X/* ~~~~~~~~~~~~~~~~~~~~~~~~~~ Programme principal ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
X
Xmain ( argc , argv )
Xint   argc ;
Xchar *argv [ ] ;
X{
X   int             i ;
X   char           *display_name = NULL ;
X   Bool            option_m = False ;
X
X   char           *window_title = "Demineur" , *icon_title = "Demineur" ;
X   XTextProperty   window_name , icon_name ;
X   Pixmap          icon_bitmap ;
X   XSizeHints      size_hints ;
X   XWMHints        wm_hints ;
X   XClassHint      class_hint ;
X   Atom            protocol [ 1 ] ;
X
X   time_t          ref , courant , ancien ;
X
X   XEvent          event ;
X   int             lig , col , l , c , bouton = 0 ;
X   enum { CASE , DOUBLE_CLIC , ICONE , RIEN } quoi ;
X   Bool            focus = False ;
X   Region          region ;
X   XRectangle      rectangle ;
X
X   nb_mines = NB_MINES ;
X
X   /* arguments de la ligne de commande */
X
X   for ( i = 1 ; i < argc ; i ++ )
X   {
X      if ( strcmp ( argv [ i ] , "-display" ) == 0 )
X      {
X         display_name = argv [ ++ i ] ;
X      }
X      else if ( strcmp ( argv [ i ] , "-l" ) == 0 )
X      {
X         nb_lig = atoi ( argv [ ++ i ] ) ;
X         if ( nb_lig < 5 )
X         {
X            nb_lig = 5 ;
X         }
X         if ( ! option_m )
X         {
X            nb_mines = NB_MINES ;
X         }
X      }
X      else if ( strcmp ( argv [ i ] , "-c" ) == 0 )
X      {
X         nb_col = atoi ( argv [ ++ i ] ) ;
X         if ( nb_col < 10 )
X         {
X            nb_col = 10 ;
X         }
X         if ( ! option_m )
X         {
X            nb_mines = NB_MINES ;
X         }
X      }
X      else if ( strcmp ( argv [ i ] , "-m" ) == 0 )
X      {
X         option_m = True ;
X         nb_mines = atoi ( argv [ ++ i ] ) ;
X         if ( nb_mines >= nb_lig * nb_col )
X         {
X            nb_mines = NB_MINES ;
X         }
X      }
X      else if ( strcmp ( argv [ i ] , "-ouvre" ) == 0 )
X      {
X         ouvre = TRUE ;
X      }
X      else
X      {
X         fprintf ( stderr ,
X"Usage: xdemineur [-display display] [-l lignes] [-c colonnes] [-m mines]\n" ) ;
X         fprintf ( stderr ,
X"                 [-ouvre]\n" ) ;
X         exit ( 1 ) ;
X      }
X   }
X
X   /* initialisation de X */
X
X   if ( ( display = XOpenDisplay ( display_name ) ) == NULL )
X   {
X      fprintf ( stderr , "%s : impossible de se connecter au serveur X.\n" ,
X                         argv [ 0 ] ) ;
X      exit ( 1 ) ;
X   }
X
X   screen = DefaultScreen ( display ) ;
X
X   while ( HAUTEUR_FEN > DisplayHeight ( display , screen ) )
X   {
X      nb_lig -- ;
X      if ( ! option_m )
X      {
X         nb_mines = NB_MINES ;
X      }
X   }
X   while ( LARGEUR_FEN > DisplayWidth ( display , screen ) )
X   {
X      nb_col -- ;
X      if ( ! option_m )
X      {
X         nb_mines = NB_MINES ;
X      }
X   }
X
X   window = XCreateSimpleWindow ( display , RootWindow ( display , screen ) ,
X                                  X_FEN , Y_FEN , LARGEUR_FEN , HAUTEUR_FEN , 2 ,
X                                  BlackPixel ( display , screen ) ,
X                                  WhitePixel ( display , screen ) ) ;
X   XSelectInput ( display , window , ButtonPressMask | ButtonReleaseMask |
X                                     FocusChangeMask | ExposureMask ) ;
X
X   XStringListToTextProperty ( &window_title , 1 , &window_name ) ;
X   XStringListToTextProperty ( &icon_title   , 1 , &icon_name   ) ;
X
X   icon_bitmap = XCreateBitmapFromData ( display , RootWindow ( display , screen ) ,
X                                         xdemineur_bits ,
X                                         xdemineur_width , xdemineur_height ) ;
X
X   size_hints . flags         = USPosition | PSize | PMinSize | PMaxSize ;
X   size_hints . min_width     = size_hints . max_width  = LARGEUR_FEN ;
X   size_hints . min_height    = size_hints . max_height = HAUTEUR_FEN ;
X
X   wm_hints   . flags         = InputHint | StateHint | IconPixmapHint ;
X   wm_hints   . input         = True ;
X   wm_hints   . initial_state = NormalState ;
X   wm_hints   . icon_pixmap   = icon_bitmap ;
X
X   class_hint . res_name      = argv [ 0 ] ;
X   class_hint . res_class     = "XDemineur" ;
X
X   XSetWMProperties ( display , window ,
X                      &window_name , &icon_name ,
X                      argv , argc ,
X                      &size_hints , &wm_hints , &class_hint ) ;
X
X   protocol [ 0 ] = XInternAtom ( display , "WM_DELETE_WINDOW" , False ) ;
X   XSetWMProtocols ( display , window , protocol , 1 ) ;
X
X   gc = XCreateGC ( display , window , 0 , NULL ) ;
X   XSetForeground ( display , gc , BlackPixel ( display , screen ) ) ;
X   XSetBackground ( display , gc , WhitePixel ( display , screen ) ) ;
X
X   cree_pixmaps ( ) ;
X
X   XMapWindow ( display , window ) ;
X
X   /* initialisation du jeu */
X   
X   /* on rajoute deux rangees supplementaires pour ne pas avoir a s'occuper *
X    * des effets de bord lors du comptage du nombre de mines adjacentes     */
X 
X   tableau = ( struct jeu ** ) malloc ( ( nb_lig + 2 ) *
X                                        sizeof ( struct jeu * ) ) ;
X   for ( i = 0 ; i < nb_lig + 2 ; i ++ )
X   {
X      tableau [ i ] = ( struct jeu * ) malloc ( ( nb_col + 2 ) *
X                                                sizeof ( struct jeu ) );
X   }
X
X   remplis_et_compte ( ) ;
X
X   /* le jeu */
X
X   region = XCreateRegion ( ) ;
X   while ( True )
X   {
X      while ( XPending ( display ) )
X      {
X         XNextEvent ( display , &event ) ;
X         switch ( event . type )
X         {
X         case ButtonPress :
X            bouton ++ ;
X
X            if ( event . xbutton . y >= Y_ICONE              &&
X                 event . xbutton . y <= Y_ICONE + HAUT_ICONE &&
X                 event . xbutton . x >= X_ICONE              &&
X                 event . xbutton . x <= X_ICONE + LARG_ICONE &&
X                 event . xbutton . button == Button1         &&
X                 bouton == 1 )   /* nouveau jeu */
X            {
X               quoi = ICONE ;
X               icone_activee ( ) ;
X            }
X            else if ( event . xbutton . x > X_JEU            &&
X                      event . xbutton . x < X_JEU + LARG_JEU &&
X                      event . xbutton . y > Y_JEU            &&
X                      event . xbutton . y < Y_JEU + HAUT_JEU &&
X                      ! perdu && ! gagne )
X            {
X               if ( ( event . xbutton . x - X_JEU ) % ( LARG_CASE + 1 ) == 0 ||
X                    ( event . xbutton . y - Y_JEU ) % ( HAUT_CASE + 1 ) == 0 )
X               {
X                  quoi = RIEN ;   /* on a clique sur une ligne donc on ne fait rien */
X               }
X               else
X               {
X                  icone_joue ( ) ;
X
X                  lig = 1 + ( event . xbutton . y - Y_JEU ) / ( HAUT_CASE + 1 ) ;
X                  col = 1 + ( event . xbutton . x - X_JEU ) / ( LARG_CASE + 1 ) ;
X
X                  if ( event . xbutton . button == Button1          &&
X                       tableau [ lig ] [ col ] . etat != DECOUVERTE &&
X                       tableau [ lig ] [ col ] . etat != MARQUEE    &&
X                       bouton == 1 )
X                  {
X                     quoi = CASE ;
X                     case_vide ( lig , col ) ;
X                  }
X                  else if ( tableau [ lig ] [ col ] . etat == DECOUVERTE &&
X                            bouton == 2 )
X                  {
X                     quoi = DOUBLE_CLIC ;
X                     cases_vides ( lig , col ) ;
X                  }
X                  else if ( event . xbutton . button == Button3          &&
X                            tableau [ lig ] [ col ] . etat != DECOUVERTE &&
X                            bouton == 1 )
X                  {
X                     quoi = CASE ;
X                     marque ( lig , col ) ;
X
X                     if ( ! jeu && ! gagne && ! perdu )
X                     {
X                        jeu = TRUE ;
X                        ancien = ref = time ( 0 ) ;
X                     }
X                  }
X                  else
X                  {
X                     quoi = RIEN ;
X                  }
X               }
X            }
X            else
X            {
X               quoi = RIEN ;
X            }
X            break ;
X         case ButtonRelease :
X            bouton -- ;
X            if ( bouton != 0 )
X            {
X               break ;
X            }
X
X            if ( event . xbutton . y >= Y_ICONE              &&
X                 event . xbutton . y <= Y_ICONE + HAUT_ICONE &&
X                 event . xbutton . x >= X_ICONE              &&
X                 event . xbutton . x <= X_ICONE + LARG_ICONE &&
X                 event . xbutton . button == Button1         &&
X                 quoi == ICONE )   /* nouveau jeu */
X            {
X               remplis_et_compte ( ) ;
X               affiche_jeu ( ) ;
X            }
X            else if ( quoi == ICONE )
X            {
X               icone_perdu_gagne ( ) ;
X            }
X            if ( ( event . xbutton . y < Y_JEU            ||
X                   event . xbutton . y > Y_JEU + HAUT_JEU ||
X                   event . xbutton . x < X_JEU            ||
X                   event . xbutton . x > X_JEU + LARG_JEU ) &&
X                 quoi == CASE )
X            {
X               affiche_case ( lig , col ) ;
X            }
X            else if ( event . xbutton . x > X_JEU            &&
X                      event . xbutton . x < X_JEU + LARG_JEU &&
X                      event . xbutton . y > Y_JEU            &&
X                      event . xbutton . y < Y_JEU + HAUT_JEU &&
X                      ! perdu && ! gagne                     &&
X                      event . xbutton . button == Button1    &&
X                      quoi == CASE )
X            {
X               if ( ( event . xbutton . y - Y_JEU ) % ( HAUT_CASE + 1 ) == 0 ||
X                    ( event . xbutton . x - X_JEU ) % ( LARG_CASE + 1 ) == 0 )
X               {
X                  affiche_case ( lig , col ) ;   /* on a clique sur une ligne donc on ne fait rien */
X               }
X               else
X               {
X                  l = 1 + ( event . xbutton . y - Y_JEU ) / ( HAUT_CASE + 1 ) ;
X                  c = 1 + ( event . xbutton . x - X_JEU ) / ( LARG_CASE + 1 ) ;
X
X                  if ( tableau [ lig ] [ col ] . etat != DECOUVERTE &&
X                       tableau [ lig ] [ col ] . etat != MARQUEE    &&
X                       lig == l && col == c )
X                  {
X                     joue ( lig , col ) ;
X
X                     if ( ! jeu && !gagne && ! perdu )
X                     {
X                        jeu = TRUE ;
X                        ancien = ref = time ( 0 ) ;
X                     }
X                  }
X                  else
X                  {
X                     affiche_case ( lig , col ) ;
X                  }
X               }
X            }
X            else if ( ( event . xbutton . y < Y_JEU            ||
X                        event . xbutton . y > Y_JEU + HAUT_JEU ||
X                        event . xbutton . x < X_JEU            ||
X                        event . xbutton . x > X_JEU + LARG_JEU ) &&
X                        quoi == DOUBLE_CLIC )
X            {
X               affiche_bloc ( lig , col ) ;
X            }
X            else if ( event . xbutton . x > X_JEU            &&
X                      event . xbutton . x < X_JEU + LARG_JEU &&
X                      event . xbutton . y > Y_JEU            &&
X                      event . xbutton . y < Y_JEU + HAUT_JEU &&
X                      ! perdu && ! gagne                     &&
X                      quoi == DOUBLE_CLIC )
X            {
X               if ( ( event . xbutton . y - Y_JEU ) % ( HAUT_CASE + 1 ) == 0 ||
X                    ( event . xbutton . x - X_JEU ) % ( LARG_CASE + 1 ) == 0 )
X               {
X                  affiche_bloc ( lig , col ) ;   /* on a clique sur une ligne donc on ne fait rien */
X               }
X               else
X               {
X                  l = 1 + ( event . xbutton . y - Y_JEU ) / ( HAUT_CASE + 1 ) ;
X                  c = 1 + ( event . xbutton . x - X_JEU ) / ( LARG_CASE + 1 ) ;
X
X                  if ( tableau [ lig ] [ col ] . etat == DECOUVERTE &&
X                       tableau [ lig ] [ col ] . nombre ==
X                          nombre_de_drapeaux ( lig , col )          &&
X                       lig == l && col == c )
X                  {
X                     double_clic ( lig , col ) ;
X                  }
X                  else
X                  {
X                     affiche_bloc ( lig , col ) ;
X                  }
X               }
X            }
X            icone_perdu_gagne ( ) ;
X            break ;
X         case FocusIn :
X            focus = True ;
X            ref = time ( 0 ) - temps ;
X            break ;
X         case FocusOut :
X            focus = False ;
X            break ;
X         case Expose :
X            rectangle . x      = ( short )          event . xexpose . x ;
X            rectangle . y      = ( short )          event . xexpose . y ;
X            rectangle . width  = ( unsigned short ) event . xexpose . width ;
X            rectangle . height = ( unsigned short ) event . xexpose . height ;
X            XUnionRectWithRegion ( &rectangle , region , region ) ;
X            if ( event . xexpose . count == 0 )
X            {
X               XSetRegion ( display , gc , region ) ;
X               affiche_jeu ( ) ;
X               XSetClipMask ( display , gc , None ) ;
X               XDestroyRegion ( region ) ;
X               region = XCreateRegion ( ) ;
X            }
X            break ;
X         case ClientMessage :
X            if ( event . xclient . data . l [ 0 ] == protocol [ 0 ] )
X            {
X               for ( i = 0 ; i < nb_lig + 2 ; i ++ )
X               {
X                  free ( tableau [ i ] ) ;
X               }
X               free ( tableau ) ;
X               detruit_pixmaps ( ) ;
X               XDestroyWindow ( display , window ) ;
X               XCloseDisplay ( display ) ;
X               exit ( 0 ) ;
X            }
X            break ;
X         }
X      }
X      if ( jeu && focus )
X      {
X         courant = time ( 0 ) ;
X         if ( ancien != courant )
X         {
X            ancien = courant ;
X            temps = courant - ref ;
X            if ( temps > 999 )
X            {
X               temps %= 1000 ;
X            }
X            chronometre ( ) ;
X         }
X      }
X   }
X}
X
Xint nombre_de_drapeaux ( lig , col )
Xint lig , col ;
X{
X   return ( drapeau01 ( lig - 1 , col - 1 ) +
X            drapeau01 ( lig - 1 , col     ) +
X            drapeau01 ( lig - 1 , col + 1 ) +
X            drapeau01 ( lig     , col - 1 ) +
X            drapeau01 ( lig     , col + 1 ) +
X            drapeau01 ( lig + 1 , col - 1 ) +
X            drapeau01 ( lig + 1 , col     ) +
X            drapeau01 ( lig + 1 , col + 1 ) ) ;
X}
X
Xint drapeau01 ( lig , col )
Xint lig , col ;
X{
X   return ( ( tableau [ lig ] [ col ] . etat == MARQUEE ) ? 1 : 0 ) ;
X}
END_OF_FILE
if test 17690 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'xdemineur.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdemineur.c'\"
else
echo shar: Extracting \"'xdemineur.c'\" \(27206 characters\)
sed "s/^X//" >'xdemineur.c' <<'END_OF_FILE'
X/* ********************************************************************** */
X/*                                                                        */
X/* xdemineur - Jeu de reflexion sous X, version 1.0                       */
X/*                                                                        */
X/* Copyright : Marc Baudoin (baudoin@ensta.fr)                            */
X/*                                                                        */
X/*            |\                                                          */
X/*          |\| \                                                         */
X/*          |//  )                                                        */
X/*        |\ /  /        /\/\_                                            */
X/*        |//  /        /. . /                                            */
X/*      |\ /  /     ___/    |_                                            */
X/*      |//  /     (____/    /_/\_                                        */
X/*       |__|      (_____/ __     >                                       */
X/*     /| ___  ________ _< \ \__  >                                       */
X/*     \|| __\| _|_   _/ \\ \___\/                                        */
X/*       | __\____ | |/ _ \\    >                                         */
X/*     /||___\_____|___/ \_\\  _>                                         */
X/*     \|____           ____ \|                                           */
X/*       \   \_________/   /                                              */
X/*        \   _    _      /                                               */
X/*         \_//   //_____/                                                */
X/*           (_   \ (_  _\                                                */
X/*             |/\|   \/                                                  */
X/*                                                                        */
X/* Ecole Nationale Superieure de Techniques Avancees (ENSTA)              */
X/* 32, boulevard Victor - 75015 Paris - France                            */
X/*                                                                        */
X/* Vous avez le droit d'utiliser et de distribuer xdemineur et sa         */
X/* documentation pourvu que cette notice de copyright apparaisse sur      */
X/* toutes les copies et que vous ne tiriez aucun profit de mon programme. */
X/*                                                                        */
X/* ********************************************************************** */
X
X
X
X#include <X11/Xlib.h>
X
X#include "demineur.h"
X#include "xdemineur.h"
X
X#include "bitmaps/numero_0.bm"
X#include "bitmaps/numero_1.bm"
X#include "bitmaps/numero_2.bm"
X#include "bitmaps/numero_3.bm"
X#include "bitmaps/numero_4.bm"
X#include "bitmaps/numero_5.bm"
X#include "bitmaps/numero_6.bm"
X#include "bitmaps/numero_7.bm"
X#include "bitmaps/numero_8.bm"
X#include "bitmaps/numero_9.bm"
X
X#include "bitmaps/icone_blanc.bm"
X#include "bitmaps/icone_gris.bm"
X#include "bitmaps/select_blanc.bm"
X#include "bitmaps/select_gris.bm"
X#include "bitmaps/icone.bm"
X#include "bitmaps/bof.bm"
X#include "bitmaps/heureux.bm"
X#include "bitmaps/triste.bm"
X#include "bitmaps/joue.bm"
X
X#include "bitmaps/relief_blanc.bm"
X#include "bitmaps/relief_gris.bm"
X#include "bitmaps/case.bm"
X#include "bitmaps/pied.bm"
X#include "bitmaps/drapeau.bm"
X#include "bitmaps/interro.bm"
X#include "bitmaps/num_case_0.bm"
X#include "bitmaps/num_case_1.bm"
X#include "bitmaps/num_case_2.bm"
X#include "bitmaps/num_case_3.bm"
X#include "bitmaps/num_case_4.bm"
X#include "bitmaps/num_case_5.bm"
X#include "bitmaps/num_case_6.bm"
X#include "bitmaps/num_case_7.bm"
X#include "bitmaps/num_case_8.bm"
X#include "bitmaps/mine.bm"
X#include "bitmaps/reflet.bm"
X#include "bitmaps/manquee.bm"
X#include "bitmaps/croix.bm"
X#include "bitmaps/reflet_manquee.bm"
X
Xextern struct jeu    **tableau ;
Xextern int             nb_lig , nb_col , mines ;
Xextern time_t          temps ;
Xextern BOOLEAN         perdu , gagne ;
X
Xextern Display        *display ;
Xextern int             screen ;
Xextern Window          window ;
Xextern GC              gc ;
X
Xstatic Pixmap   numero [ 10 ] ,
X                bof , heureux , triste , joue , icone_select ,
X                case_relief , marquee , interro ,
X                num_case [ 9 ] , mine , mine_perdu , manquee ;
Xstatic char    *couleur [ ] = { "blue" , "green" , "red" , "navyblue" ,
X                                "plum" , "seagreen" , "sienna" , "deeppink" } ;
X
Xstatic unsigned long noir , blanc , gris ;
X
Xtypedef struct mon_pixmap
X{
X   char *bits ;
X   unsigned long couleur ;
X}
XMON_PIXMAP ;
X
X/* ~~~~~~~~~~~~~~~~~~~~~~~~~ Gestion de l'affichage ~~~~~~~~~~~~~~~~~~~~~~~~~ */
X
XPixmap copie ( pixmap , width , height , nb )
Xstruct mon_pixmap pixmap [ ] ;
Xunsigned int width , height ;
Xint nb ;
X{
X   Pixmap result ;
X   int i , x , y , n , m ;
X
X   result = XCreatePixmapFromBitmapData ( display ,
X                                          RootWindow ( display , screen ) ,
X                                          pixmap [ 0 ] . bits ,
X                                          width  , height ,
X                                          pixmap [ 0 ] . couleur ,
X                                          BlackPixel ( display , screen ) ,
X                                          DefaultDepth ( display , screen ) ) ;
X
X   for ( i = 1 ; i < nb ; i ++ )
X   {
X      XSetForeground ( display , gc , pixmap [ i ] . couleur ) ;
X      n = m = 0 ;
X      for ( y = 0 ; y < height ; y ++ )
X      {
X         if ( m != 0 )
X         {
X            n ++ ;
X         }
X         m = 0 ;
X         for ( x = 0 ; x < width ; x ++ )
X         {
X            if ( pixmap [ i ] . bits [ n ] & ( 1 << m ) )
X            {
X               XDrawPoint ( display , result , gc , x , y ) ;
X            }
X            m ++ ;
X            if ( m == 8 )
X            {
X               m = 0 ;
X               n ++ ;
X            }
X         }
X      }
X   }
X   return result ;
X}
X
Xcree_pixmaps ( )
X{
X   Colormap        default_colormap ;
X   XColor          color ;
X   unsigned long   gris_clair , jaune , rouge , fore [ 10 ] ;
X   int             i ;
X   Window          root_window ;
X   unsigned int    default_depth ;
X   MON_PIXMAP      pixmap [ 4 ] ;
X
X   default_colormap = DefaultColormap ( display , screen ) ;
X   XParseColor ( display , default_colormap , "black" , &color ) ;
X   XAllocColor ( display , default_colormap , &color ) ;
X   noir = color . pixel ;
X   XParseColor ( display , default_colormap , "white" , &color ) ;
X   XAllocColor ( display , default_colormap , &color ) ;
X   blanc = color . pixel ;
X   XParseColor ( display , default_colormap , "gray" , &color ) ;
X   XAllocColor ( display , default_colormap , &color ) ;
X   gris = color . pixel ;
X   XParseColor ( display , default_colormap , "lightgray" , &color ) ;
X   XAllocColor ( display , default_colormap , &color ) ;
X   gris_clair = color . pixel ;
X   XParseColor ( display , default_colormap , "yellow" , &color ) ;
X   XAllocColor ( display , default_colormap , &color ) ;
X   jaune = color . pixel ;
X   fore [ 0 ] = gris_clair ;
X   for ( i = 1 ; i <= 8 ; i ++ )
X   {
X      XParseColor ( display , default_colormap , couleur [ i - 1 ] , &color ) ;
X      XAllocColor ( display , default_colormap , &color ) ;
X      fore [ i ] = color . pixel ;
X   }
X   rouge = fore [ 3 ] ;
X
X   XSetWindowBackground ( display , window , gris_clair ) ;
X
X   root_window   = RootWindow   ( display , screen ) ;
X   default_depth = DefaultDepth ( display , screen ) ;
X
X   numero [ 0 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                numero_0_bits ,
X                                                numero_0_width , numero_0_height ,
X                                                rouge , noir ,
X                                                default_depth ) ;
X   numero [ 1 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                numero_1_bits ,
X                                                numero_1_width , numero_1_height ,
X                                                rouge , noir ,
X                                                default_depth ) ;
X   numero [ 2 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                numero_2_bits ,
X                                                numero_2_width , numero_2_height ,
X                                                rouge , noir ,
X                                                default_depth ) ;
X   numero [ 3 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                numero_3_bits ,
X                                                numero_3_width , numero_3_height ,
X                                                rouge , noir ,
X                                                default_depth ) ;
X   numero [ 4 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                numero_4_bits ,
X                                                numero_4_width , numero_4_height ,
X                                                rouge , noir ,
X                                                default_depth ) ;
X   numero [ 5 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                numero_5_bits ,
X                                                numero_5_width , numero_5_height ,
X                                                rouge , noir ,
X                                                default_depth ) ;
X   numero [ 6 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                numero_6_bits ,
X                                                numero_6_width , numero_6_height ,
X                                                rouge , noir ,
X                                                default_depth ) ;
X   numero [ 7 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                numero_7_bits ,
X                                                numero_7_width , numero_7_height ,
X                                                rouge , noir ,
X                                                default_depth ) ;
X   numero [ 8 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                numero_8_bits ,
X                                                numero_8_width , numero_8_height ,
X                                                rouge , noir ,
X                                                default_depth ) ;
X   numero [ 9 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                numero_9_bits ,
X                                                numero_9_width , numero_9_height ,
X                                                rouge , noir ,
X                                                default_depth ) ;
X
X   pixmap [ 0 ] . bits    = icone_blanc_bits ;
X   pixmap [ 0 ] . couleur = blanc ;
X   pixmap [ 1 ] . bits    = icone_gris_bits ;
X   pixmap [ 1 ] . couleur = gris ;
X   pixmap [ 2 ] . bits    = icone_bits ;
X   pixmap [ 2 ] . couleur = gris_clair ;
X   pixmap [ 3 ] . bits    = bof_bits ;
X   pixmap [ 3 ] . couleur = jaune ;
X   bof = copie ( pixmap , bof_width , bof_height , 4 ) ;
X
X   pixmap [ 3 ] . bits = heureux_bits ;
X   heureux = copie ( pixmap , heureux_width , heureux_height , 4 ) ;
X
X   pixmap [ 3 ] . bits = triste_bits ;
X   triste = copie ( pixmap , triste_width , triste_height , 4 ) ;
X
X   pixmap [ 3 ] . bits = joue_bits ;
X   joue = copie ( pixmap , joue_width , joue_height , 4 ) ;
X
X   pixmap [ 0 ] . bits    = select_gris_bits ;
X   pixmap [ 0 ] . couleur = gris ;
X   pixmap [ 1 ] . bits    = select_blanc_bits ;
X   pixmap [ 1 ] . couleur = blanc ;
X   pixmap [ 2 ] . bits    = icone_bits ;
X   pixmap [ 2 ] . couleur = gris_clair ;
X   pixmap [ 3 ] . bits    = bof_bits ;
X   pixmap [ 3 ] . couleur = jaune ;
X   icone_select = copie ( pixmap , bof_width , bof_height , 4 ) ;
X
X   pixmap [ 0 ] . bits    = relief_blanc_bits ;
X   pixmap [ 0 ] . couleur = blanc ;
X   pixmap [ 1 ] . bits    = relief_gris_bits ;
X   pixmap [ 1 ] . couleur = gris ;
X   pixmap [ 2 ] . bits    = case_bits ;
X   pixmap [ 2 ] . couleur = gris_clair ;
X   case_relief = copie ( pixmap , case_width , case_height , 3 ) ;
X
X   pixmap [ 2 ] . bits    = pied_bits ;
X   pixmap [ 3 ] . bits    = drapeau_bits ;
X   pixmap [ 3 ] . couleur = rouge ;
X   marquee = copie ( pixmap , drapeau_width , drapeau_height , 4 ) ;
X
X   pixmap [ 2 ] . bits = interro_bits ;
X   interro = copie ( pixmap , interro_width , interro_height , 3 ) ;
X
X   num_case [ 0 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                  num_case_0_bits ,
X                                                  num_case_0_width , num_case_0_height ,
X                                                  fore [ 0 ] , gris_clair ,
X                                                  default_depth ) ;
X   num_case [ 1 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                  num_case_1_bits ,
X                                                  num_case_1_width , num_case_1_height ,
X                                                  fore [ 1 ] , gris_clair ,
X                                                  default_depth ) ;
X   num_case [ 2 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                  num_case_2_bits ,
X                                                  num_case_2_width , num_case_2_height ,
X                                                  fore [ 2 ] , gris_clair ,
X                                                  default_depth ) ;
X   num_case [ 3 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                  num_case_3_bits ,
X                                                  num_case_3_width , num_case_3_height ,
X                                                  fore [ 3 ] , gris_clair ,
X                                                  default_depth ) ;
X   num_case [ 4 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                  num_case_4_bits ,
X                                                  num_case_4_width , num_case_4_height ,
X                                                  fore [ 4 ] , gris_clair ,
X                                                  default_depth ) ;
X   num_case [ 5 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                  num_case_5_bits ,
X                                                  num_case_5_width , num_case_5_height ,
X                                                  fore [ 5 ] , gris_clair ,
X                                                  default_depth ) ;
X   num_case [ 6 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                  num_case_6_bits ,
X                                                  num_case_6_width , num_case_6_height ,
X                                                  fore [ 6 ] , gris_clair ,
X                                                  default_depth ) ;
X   num_case [ 7 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                  num_case_7_bits ,
X                                                  num_case_7_width , num_case_7_height ,
X                                                  fore [ 7 ] , gris_clair ,
X                                                  default_depth ) ;
X   num_case [ 8 ] = XCreatePixmapFromBitmapData ( display , root_window ,
X                                                  num_case_8_bits ,
X                                                  num_case_8_width , num_case_8_height ,
X                                                  fore [ 8 ] , gris_clair ,
X                                                  default_depth ) ;
X
X   pixmap [ 0 ] . bits    = mine_bits ;
X   pixmap [ 0 ] . couleur = gris_clair ;
X   pixmap [ 1 ] . bits    = reflet_bits ;
X   pixmap [ 1 ] . couleur = blanc ;
X   mine = copie ( pixmap , mine_width , mine_height , 2 ) ;
X
X   pixmap [ 0 ] . bits    = mine_bits ;
X   pixmap [ 0 ] . couleur = rouge ;
X   pixmap [ 1 ] . bits    = reflet_bits ;
X   pixmap [ 1 ] . couleur = blanc ;
X   mine_perdu = copie ( pixmap , mine_width , mine_height , 2 ) ;
X
X   pixmap [ 0 ] . bits    = manquee_bits ;
X   pixmap [ 0 ] . couleur = gris_clair ;
X   pixmap [ 1 ] . bits    = croix_bits ;
X   pixmap [ 1 ] . couleur = rouge ;
X   pixmap [ 2 ] . bits    = reflet_manquee_bits ;
X   pixmap [ 2 ] . couleur = blanc ;
X   manquee = copie ( pixmap , manquee_width , manquee_height , 3 ) ;
X}
X
Xaffiche_jeu ( )
X{
X   int l , c ;
X
X   bord ( ) ;
X   nombre_de_mines ( ) ;
X   icone_perdu_gagne ( ) ;
X   chronometre ( ) ;
X   grille ( ) ;
X   for ( l = 1 ; l <= nb_lig ; l ++ )
X   {
X      for ( c = 1 ; c <= nb_col ; c ++ )
X      {
X         affiche_case ( l , c  ) ;
X      }
X   }
X}
X
Xbord ( )
X{
X   int coord ;
X
X   XSetForeground ( display , gc , blanc ) ;
X
X   for ( coord = 0 ; coord < LARG_BORD ; coord ++ )
X   {
X      XDrawLine ( display , window , gc ,
X                  0 , coord , LARGEUR_FEN - 2 - coord , coord ) ;
X      XDrawLine ( display , window , gc ,
X                  coord , 0 , coord , HAUTEUR_FEN - 2 - coord ) ;
X      XDrawLine ( display , window , gc ,
X                  BORD - LARG_BORD + coord + 1               ,
X                  MARGE_HAUT  - BORD - 1 - coord + LARG_BORD ,
X                  LARGEUR_FEN - BORD + LARG_BORD - 1         ,
X                  MARGE_HAUT  - BORD - 1 - coord + LARG_BORD ) ;
X      XDrawLine ( display , window , gc ,
X                  LARGEUR_FEN - BORD + LARG_BORD - coord - 1 ,
X                  BORD - LARG_BORD + coord + 1               ,
X                  LARGEUR_FEN - BORD + LARG_BORD - coord - 1 ,
X                  MARGE_HAUT - BORD - 1 + LARG_BORD ) ;
X      XDrawLine ( display , window , gc ,
X                  BORD - 1 - coord       , HAUTEUR_FEN - BORD + coord ,
X                  LARGEUR_FEN - BORD - 1 , HAUTEUR_FEN - BORD + coord ) ;
X      XDrawLine ( display , window , gc ,
X                  LARGEUR_FEN - BORD + coord ,
X                  MARGE_HAUT - coord         ,
X                  LARGEUR_FEN - BORD + coord ,
X                  HAUTEUR_FEN - BORD + LARG_BORD - 1 ) ;
X   }
X
X   XSetForeground ( display , gc , gris ) ;
X
X   for ( coord = 0 ; coord < LARG_BORD ; coord ++ )
X   {
X      XDrawLine ( display , window , gc ,
X                  coord           , HAUTEUR_FEN - 1 - coord ,
X                  LARGEUR_FEN - 1 , HAUTEUR_FEN - 1 - coord ) ;
X      XDrawLine ( display , window , gc ,
X                  LARGEUR_FEN - 1 - coord , coord ,
X                  LARGEUR_FEN - 1 - coord , HAUTEUR_FEN - 1 ) ;
X      XDrawLine ( display , window , gc ,
X                  BORD - 1                    , BORD - 1 - coord ,
X                  LARGEUR_FEN - BORD  + coord , BORD - 1 - coord ) ;
X      XDrawLine ( display , window , gc ,
X                  BORD - 1 - coord , BORD - LARG_BORD ,
X                  BORD - 1 - coord , MARGE_HAUT - BORD  + coord ) ;
X      XDrawLine ( display , window , gc ,
X                  BORD - 1                   , MARGE_HAUT - 1 - coord ,
X                  LARGEUR_FEN - BORD + coord , MARGE_HAUT - 1 - coord  ) ;
X      XDrawLine ( display , window , gc ,
X                  BORD - 1 - coord , MARGE_HAUT - LARG_BORD ,
X                  BORD - 1 - coord , HAUTEUR_FEN - BORD + coord ) ;
X   }
X}
X
Xnombre_de_mines ( )
X{
X   int n [ 3 ] ;
X
X   n [ 0 ] = mines / 100 ;
X   n [ 1 ] = ( mines % 100 ) / 10 ;
X   n [ 2 ] = mines - ( n [ 0 ] * 100 ) - ( n [ 1 ] * 10 ) ;
X
X   XCopyArea ( display , numero [ n [ 0 ] ] , window , gc ,
X               0 , 0 , LARG_NUMERO , HAUT_NUMERO ,
X               X_NB_MINES , Y_NB_MINES ) ;
X   XCopyArea ( display , numero [ n [ 1 ] ] , window , gc ,
X               0 , 0 , LARG_NUMERO , HAUT_NUMERO ,
X               X_NB_MINES + LARG_NUMERO , Y_NB_MINES ) ;
X   XCopyArea ( display , numero [ n [ 2 ] ] , window , gc ,
X               0 , 0 , LARG_NUMERO , HAUT_NUMERO ,
X               X_NB_MINES + 2 * LARG_NUMERO , Y_NB_MINES ) ;
X
X   XSetForeground ( display , gc , blanc ) ;
X
X   XDrawLine ( display , window , gc ,
X               X_NB_MINES                   , Y_NB_MINES + HAUT_NUMERO ,
X               X_NB_MINES + 3 * LARG_NUMERO , Y_NB_MINES + HAUT_NUMERO ) ;
X   XDrawLine ( display , window , gc ,
X               X_NB_MINES + 3 * LARG_NUMERO , Y_NB_MINES ,
X               X_NB_MINES + 3 * LARG_NUMERO , Y_NB_MINES + HAUT_NUMERO) ;
X
X   XSetForeground ( display , gc , gris ) ;
X
X   XDrawLine ( display , window , gc ,
X               X_NB_MINES - 1               , Y_NB_MINES - 1 ,
X               X_NB_MINES + 3 * LARG_NUMERO , Y_NB_MINES - 1 ) ;
X   XDrawLine ( display , window , gc ,
X               X_NB_MINES - 1 , Y_NB_MINES - 1 ,
X               X_NB_MINES - 1 , Y_NB_MINES + HAUT_NUMERO ) ;
X}
X
Xicone_perdu_gagne ( )
X{
X   if ( perdu )
X   {
X      XCopyArea ( display , triste , window , gc ,
X                  0 , 0 , LARG_ICONE , HAUT_ICONE , X_ICONE , Y_ICONE ) ;
X   }
X   else if ( gagne )
X   {
X      XCopyArea ( display , heureux , window , gc ,
X                  0 , 0 , LARG_ICONE , HAUT_ICONE , X_ICONE , Y_ICONE ) ;
X   }
X   else
X   {
X      XCopyArea ( display , bof , window , gc ,
X                  0 , 0 , LARG_ICONE , HAUT_ICONE , X_ICONE , Y_ICONE ) ;
X   }
X}
X
Xchronometre ( )
X{
X   int n [ 3 ] ;
X
X   n [ 0 ] = ( int ) ( temps / 100 ) ;
X   n [ 1 ] = ( int ) ( ( temps % 100 ) / 10 ) ;
X   n [ 2 ] = ( int ) ( temps - ( n [ 0 ] * 100 ) - ( n [ 1 ] * 10 ) ) ;
X
X   XCopyArea ( display , numero [ n [ 0 ] ] , window , gc ,
X               0 , 0 , LARG_NUMERO , HAUT_NUMERO ,
X               X_CHRONO , Y_CHRONO ) ;
X   XCopyArea ( display , numero [ n [ 1 ] ] , window , gc ,
X               0 , 0 , LARG_NUMERO , HAUT_NUMERO ,
X               X_CHRONO + LARG_NUMERO , Y_CHRONO ) ;
X   XCopyArea ( display , numero [ n [ 2 ] ] , window , gc ,
X               0 , 0 , LARG_NUMERO , HAUT_NUMERO ,
X               X_CHRONO + 2 * LARG_NUMERO , Y_CHRONO ) ;
X
X   XSetForeground ( display , gc , blanc ) ;
X
X   XDrawLine ( display , window , gc ,
X               X_CHRONO                   , Y_CHRONO + HAUT_NUMERO ,
X               X_CHRONO + 3 * LARG_NUMERO , Y_CHRONO + HAUT_NUMERO ) ;
X   XDrawLine ( display , window , gc ,
X               X_CHRONO + 3 * LARG_NUMERO , Y_CHRONO ,
X               X_CHRONO + 3 * LARG_NUMERO , Y_CHRONO + HAUT_NUMERO) ;
X
X   XSetForeground ( display , gc , gris ) ;
X
X   XDrawLine ( display , window , gc ,
X               X_CHRONO - 1               , Y_CHRONO - 1 ,
X               X_CHRONO + 3 * LARG_NUMERO , Y_CHRONO - 1 ) ;
X   XDrawLine ( display , window , gc ,
X               X_CHRONO - 1 , Y_CHRONO - 1 ,
X               X_CHRONO - 1 , Y_CHRONO + HAUT_NUMERO ) ;
X}
X
Xgrille ( )
X{
X   int coord ;
X
X   XSetForeground ( display , gc , noir ) ;
X
X   for ( coord = X_JEU ; coord < X_JEU + LARG_JEU ; coord += LARG_CASE + 1 )
X   {
X      XDrawLine ( display , window , gc ,
X                  coord , Y_JEU , coord , Y_JEU + HAUT_JEU - 1 ) ;
X   }
X
X   for ( coord = Y_JEU ; coord < Y_JEU + HAUT_JEU ; coord += HAUT_CASE + 1 )
X   {
X      XDrawLine ( display , window , gc ,
X                  X_JEU , coord , X_JEU + LARG_JEU - 1 , coord ) ;
X   }
X}
X
Xaffiche_case ( lig , col )
Xint lig , col ;
X{
X   int x , y ;
X
X   if ( lig < 1 || lig > nb_lig || col < 1 || col > nb_col )
X   {
X      return ;
X   }
X
X   x = X_JEU + 1 + ( col - 1 ) * ( LARG_CASE + 1 ) ;
X   y = Y_JEU + 1 + ( lig - 1 ) * ( HAUT_CASE + 1 ) ;
X
X   switch ( tableau [ lig ] [ col ] . etat )
X   {
X   case COUVERTE :
X      if ( perdu && tableau [ lig ] [ col ] . mine )
X      {
X         XCopyArea ( display , mine , window , gc ,
X                     0 , 0 , mine_width , mine_height , x , y ) ;
X      }
X      else
X      {
X         XCopyArea ( display , case_relief , window , gc ,
X                     0 , 0 , relief_blanc_width , relief_blanc_height , x , y ) ;
X      }
X      break ;
X   case DECOUVERTE :
X      if ( ! tableau [ lig ] [ col ] . mine )
X      {
X         XCopyArea ( display , num_case [ tableau [ lig ] [ col ] . nombre ] ,
X                     window , gc ,
X                     0 , 0 , num_case_0_width , num_case_0_height , x , y ) ;
X      }
X      else
X      {
X         XCopyArea ( display , mine_perdu , window , gc ,
X                     0 , 0 , mine_width , mine_height , x , y ) ;
X      }
X      break ;
X   case MARQUEE :
X      if ( perdu && ! tableau [ lig ] [ col ] . mine )
X      {
X         XCopyArea ( display , manquee , window , gc ,
X                     0 , 0 , manquee_width , manquee_height , x , y ) ;
X      }
X      else
X      {
X         XCopyArea ( display , marquee , window , gc ,
X                     0 , 0 , drapeau_width , drapeau_height , x , y ) ;
X      }
X      break ;
X   case INTERRO :
X      if ( perdu && tableau [ lig ] [ col ] . mine )
X      {
X         XCopyArea ( display , mine , window , gc ,
X                     0 , 0 , mine_width , mine_height , x , y ) ;
X      }
X      else
X      {
X         XCopyArea ( display , interro , window , gc ,
X                     0 , 0 , interro_width , interro_height , x , y ) ;
X      }
X      break ;
X   }
X}
X
Xicone_joue ( )
X{
X   XCopyArea ( display , joue , window , gc ,
X               0 , 0 , LARG_ICONE , HAUT_ICONE , X_ICONE , Y_ICONE ) ;
X}
X
Xicone_activee ( )
X{
X   XCopyArea ( display , icone_select , window , gc ,
X               0 , 0 , LARG_ICONE , HAUT_ICONE , X_ICONE , Y_ICONE ) ;
X}
X
Xcase_vide ( lig , col )
Xint lig , col ;
X{
X   int x , y ;
X
X   if ( lig < 1 || lig > nb_lig || col < 1 || col > nb_col )
X   {
X      return ;
X   }
X
X   x = X_JEU + 1 + ( col - 1 ) * ( LARG_CASE + 1 ) ;
X   y = Y_JEU + 1 + ( lig - 1 ) * ( HAUT_CASE + 1 ) ;
X
X   XCopyArea ( display , num_case [ 0 ] , window , gc ,
X               0 , 0 , num_case_0_width , num_case_0_height , x , y ) ;
X}
X
Xcases_vides ( lig , col )
Xint lig , col ;
X{
X   int l , c ;
X
X   for ( l = lig - 1 ; l <= lig + 1 ; l ++ )
X   {
X      for ( c = col - 1 ; c <= col + 1 ; c ++ )
X      {
X         if ( tableau [ l ] [ c ] . etat == COUVERTE ||
X              tableau [ l ] [ c ] . etat == INTERRO )
X         {
X            case_vide ( l , c ) ;
X         }
X      }
X   }
X}
X
Xaffiche_bloc ( lig , col )
Xint lig , col ;
X{
X   int l , c ;
X
X   for ( l = lig - 1 ; l <= lig + 1 ; l ++ )
X   {
X      for ( c = col - 1 ; c <= col + 1 ; c ++ )
X      {
X         affiche_case ( l , c ) ;
X      }
X   }
X}
X
Xdetruit_pixmaps ( )
X{
X   register int i ;
X
X   for ( i = 0 ; i <= 9 ; i ++ )
X   {
X      XFreePixmap ( display , numero [ i ] ) ;
X   }
X   XFreePixmap ( display , bof          ) ;
X   XFreePixmap ( display , heureux      ) ;
X   XFreePixmap ( display , triste       ) ;
X   XFreePixmap ( display , joue         ) ;
X   XFreePixmap ( display , icone_select ) ;
X   XFreePixmap ( display , case_relief  ) ;
X   XFreePixmap ( display , marquee      ) ;
X   XFreePixmap ( display , interro      ) ;
X   for ( i = 0 ; i <= 8 ; i ++ )
X   {
X      XFreePixmap ( display , num_case [ i ] ) ;
X   }
X   XFreePixmap ( display , mine       ) ;
X   XFreePixmap ( display , mine_perdu ) ;
X   XFreePixmap ( display , manquee    ) ;
X}
END_OF_FILE
if test 27206 -ne `wc -c <'xdemineur.c'`; then
    echo shar: \"'xdemineur.c'\" unpacked with wrong size!
fi
# end of 'xdemineur.c'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
