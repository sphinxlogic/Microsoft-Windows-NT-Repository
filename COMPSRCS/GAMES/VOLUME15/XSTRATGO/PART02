Path: uunet!ogicse!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v15i012:  xstratego - X Windows stratego interface for two players, Part02/04
Message-ID: <3817@master.CNA.TEK.COM>
Date: 26 Oct 92 23:52:10 GMT
Article-I.D.: master.3817
Sender: news@master.CNA.TEK.COM
Lines: 1771
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1511

Submitted-by: Henk-Jan Visscher <hjvissc@cs.vu.nl>
Posting-number: Volume 15, Issue 12
Archive-name: xstratego/Part02
Environment: X11, Xaw



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 4)."
# Contents:  Imakefile buzz.c callback.c icons/captain_mask.h
#   icons/colonel_mask.h icons/enemy_mask.h icons/general_mask.h
#   icons/lieutenant.h icons/lieutenant_mask.h icons/major_mask.h
#   icons/marshal_mask.h icons/miner_mask.h icons/scout_mask.h
#   icons/sergeant_mask.h init.c message.c register.c socket.c
#   stratego.h
# Wrapped by billr@saab on Mon Oct 26 15:47:07 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(280 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
XLOCAL_LIBRARIES = XawClientLibs
X	DEPLIBS = XawClientDepLibs
X
XSRCS = buzz.c callback.c dialog.c init.c main.c message.c play.c register.c setup.c socket.c
XOBJS = buzz.o callback.o dialog.o init.o main.o message.o play.o register.o setup.o socket.o
X
XComplexProgramTarget(xstratego)
END_OF_FILE
if test 280 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'buzz.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'buzz.c'\"
else
echo shar: Extracting \"'buzz.c'\" \(6956 characters\)
sed "s/^X//" >'buzz.c' <<'END_OF_FILE'
X/*
X * "buzz.c"
X */
X
X#include "buzz.h"
X
X#define		NIL_CHAR	((char *) 0)
X#define 	MEND		{NIL_CHAR, 101}	/* table closer */
X
XMESSAGE	move_opponent [] = {		/* moving enemy piece */
X	{"Sorry, no response!", 100},
X	{"The Bomb turns around and says: \"I should have blown you to bits\"",
X		10},
X	{"The Marshall turns around and says: \"Burp!\"", 10},
X	{"The enemy piece turns around and says: \"Hands off\"", 50},
X	{"The enemy piece turns around and says: \"Ok, I'll help you.  \
XWhat's it worth?\"", 50},
X	{"The enemy piece turns around and says: \"Go away thy fiend!\"", 50},
X	{"The Spy turns around and says: \"Clever!  How did you find out?\"",
X		10},
X	{"The enemy piece turns around and says: \"Stick to your own\"", 50},
X	{"C'mon that's no way to win.", 100},
X	{"I think you're playing the other color.", 100},
X	{"Boom!!!  It turned out to be a Bomb!", 50},
X	{"Move yer own, will ya..", 100},
X	{"The General won't answer.", 10},
X	{"The Scout won't answer.", 10},
X	{"The Bomb won't answer.", 10},
X	{"Try again.  He might give himself away.", 100},
X	{"Don't, your opponent is watching.", 100},
X	{"It seems to speak a different language.", 100},
X	{"Your opponent won't agree.", 100},
X	{"Ask the other player.", 100},
X	MEND
X};
X
XMESSAGE	move_empty [] = {		/* trying to move empty location */
X 	{"There is nothing there!", 100},
X	{"You thought someone dug a hole here?", 100},
X	{"He moved out.", 100},
X	{"You start digging...", 100},
X	{"You continue digging...", 50},
X	{"The ground is to hard to dig into.", 50},
X	{"You dug a pit.", 50},
X	{"Vell, vell.  Und vere's all zat void going, hah?", 50},
X	{"Don't use innocent civilians, dirtbag!", 50},
X	{"Trying to dig up a corpse are ya?", 50},
X	MEND
X};
X
XMESSAGE	move_flag [] = {		/* flag movement */
X	{"But it hasn't got any legs!", 100},
X	{"It seems to be stuck.", 100},
X	{"With enormous effort, you move the flag.", 50},
X	{"No no, read page 546, paragraph 93a of the manual.", 100},
X	{"Get somebody to help.", 50},
X	{"Its no use, your going to lose anyway.", 50},
X	{"I wouldn't try to attack anything with it.", 100},
X	{"It's surrounded by bombs!", 50},
X	{"Leider zis here fahn von't move.", 50},
X	MEND
X};
X
XMESSAGE	move_bomb [] = {		/* bomb movement */
X	{"Don't muck about with explosives. You might get your head blown off.",		100},
X	{"Ask an enemy miner to help you.", 100},
X	{"That's a ball.  Try kicking it.", 100},
X	{"Not implemented yet.", 100},
X	{"You fool, you put it out of order!", 50},
X	{"No no, read page 546, paragraph 93b of the manual.", 100},
X	{"A bomb once laid, is a joy forever.", 100},
X	{"C'mon, there are so many other nice pieces waiting to be moved.", 50},
X	{"It iz unwize to fumble wiz beumbs.", 50},
X	MEND
X};
X
XMESSAGE	kill_own [] = {			/* trying to "hit" one of your own */
X	{"You traitor! You're attacking your own army.", 100},
X	{"It turned out to be a draw.  They return to their positions.", 50},
X	{"Yeez, watch out will ye.  Somebody's gonna get hurt!", 100},
X	{"Oh you cannibal, you will be sorry for this!", 50},
X	{"Fortunately, your subordinates do have brains.", 100},
X	{"It can't be that hopeless.", 50},
X	{"Wait, wait, I think that's page 546, paragraph 93c of the manual.",
X		100},
X	{"Rebellion!  There's a coup going on!", 100},
X	MEND
X};
X
XMESSAGE	illegal [] = {			/* all other illegal moves */
X	{"Illegal move.", 100},
X	{"Read page 546, paragraph 93d of the manual.", 50},
X	{"Wait!  Read page 546, paragraph 93e of the manual.", 50},
X	{"No!  Read page 546, paragraph 93f of the manual.", 50},
X	{"\"Mother, somebody is cheating again\"", 50},
X	{"No dice, sucker...", 100},
X	{"End of input?", 50},
X	{"Interesting...", 100},
X	{"Something wrong with your eyes, squarehead?", 100},
X	{"Take a day off.", 100},
X	{"Ha ha.", 50},
X	MEND
X};
X
XMESSAGE	finished_premature [] = {	/* illegal board setup */
X	{"Don't fool around", 100},
X	{"Something's missing...", 100},
X	{"No no, I insist you get a fair chance.", 100},
X	MEND
X};
X
XMESSAGE in_water [] = {			/* moving a piece into the water */
X	{"If you wanted that piece to swim across, \
Xyou should have said \"swim\".", 50},
X	{"He can't. The piranhas will eat him.", 100},
X	{"Blub. Bloeb.", 100},
X	{"You'll first have to teach him how to swim!", 50},
X	{"Remember the Titanic...", 100},
X	MEND
X};
X	
XMESSAGE	win_capture [] = {		/* hitting enemy piece (and winning) */
X	{"Bang!!", 50},
X	{"Did you consider the possibility that his marshall was there?", 10},
X	{"You'll lose either way.", 100},
X	{"You'll win anyway.", 50},
X	{"Try to move one of his, you might find out what it is!", 50},
X	{"I'd have moved the other one.", 100},
X	{"WARNING:  It's against the rules to click Give Up.", 50},
X	{"Ok, how about Remise now.", 50},
X	{"His flag is more to the left.", 10},
X	{"Ok, who's to get slaughtered next?", 100},
X	{"Well, at least there's more room now.", 100},
X	{"D-d-d-d-destruction!!!", 50},
X	{"Dead and buried.", 100},
X	{"Surprise!", 100},
X	{"Kling, klang!", 100},
X	MEND
X};
X
XMESSAGE	lose_capture [] = {		/* hitting enemy piece (and losing) */
X	{"Bang!!", 50},
X	{"NOW he does it!", 50},
X	{"You really blew it, sucker.", 50},
X	{"Did you consider the possibility that his marshall was there?", 10},
X	{"You'll lose either way.", 100},
X	{"You'll win anyway.", 50},
X	{"Try to move one of his, you might find out what it is!", 50},
X	{"You should have put a bomb in front.", 50},
X	{"I would have moved the other one.", 100},
X	{"Oh oh, somebody is coming.", 100},
X	{"WARNING:  It's against the rules to click Give Up.", 50},
X	{"Ok, how about an Remise now.", 50},
X	{"Ok, who will be slaughtered next?", 100},
X	{"Well, at least there's more room now.", 100},
X	{"D-d-d-d-destruction!!!", 50},
X	{"Dead and buried.", 100},
X	{"Surprise!", 100},
X	{"Klang, kling!", 100},
X	MEND
X};
X
X/*
X * Returns message of m (ptr).
X */
X#define		mesg(m)		(m->_mesg)
X
X/*
X * Retruns chance of m (ptr).
X */
X#define		chance(m)	(m->_chance)
X
X/*
X * Returns 1 if chance of m > 100, else 0.
X */
X#define		mnul(m)		(chance (m) > 100)
X
Xextern 	rand ();	/* Returns number between 0 .. very large */
X
X/*
X * Buzz returns pointer to (random) message from mesg_tab.
X * Mesg_tab is seen as array of MESSAGE's, terminated by a MNUL entry.
X * All messages with equal "chance" (>=0, <=100) have equal chance to be
X * selected.  All messages with chance k.X have a
X * k times bigger chance as all messages with chance X.
X */
Xchar *
Xbuzz (mesg_tab)
XMESSAGE	*mesg_tab;
X{
X#	define	lowrand		1		/* lower bound random number */
X	register unsigned upprand = 0;		/* upper bound random number */
X	register unsigned chanceacc = 0;	/* accumulated chances  */
X	register unsigned chancebound;		/* usable random number  */
X	register MESSAGE  *m;
X
X	if (mesg_tab == (MESSAGE *) 0)
X		return NIL_CHAR;
X
X	for (m = mesg_tab; !mnul (m); m++)
X		upprand += chance (m);
X	
X	if (upprand != 0)
X		chancebound = ((rand () % (upprand - lowrand + 1))) + lowrand;
X	else
X		chancebound = 1;
X
X	for (m = mesg_tab; !mnul (m); m++) {
X		chanceacc += chance (m);
X		if (chancebound <= chanceacc)
X			return mesg (m);
X	}
X
X	return NIL_CHAR;
X}
END_OF_FILE
if test 6956 -ne `wc -c <'buzz.c'`; then
    echo shar: \"'buzz.c'\" unpacked with wrong size!
fi
# end of 'buzz.c'
fi
if test -f 'callback.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'callback.c'\"
else
echo shar: Extracting \"'callback.c'\" \(2651 characters\)
sed "s/^X//" >'callback.c' <<'END_OF_FILE'
X/*
X * Callback.c
X */
X
X#include "stratego.h"
X
X/*
X * BoardPosition Callback Routine.
X */
XXtCallbackProc ActivateBoardPosition (widget, board_pos)
XWidget widget;
XBOARD_POS *board_pos;
X{
X	if (players[0].confirm)
X		ConfirmMove ();
X
X	if (players[0].status == PL_SETUP)
X		setup_tile (board_pos);
X	else if (players[0].status == PL_ENDGAME)
X		message ("The game has ended!");
X	else if (players[0].status >= PL_PLAYING)
X		play_tile (board_pos);
X	else
X		message ("It is not your turn %s.", players[0].name);
X}
X
Xvoid AssignBoardPosition (board_pos, tile, owner)
XBOARD_POS *board_pos;
XTILE *tile;
Xint owner;
X{
X	Pixmap pixmap;
X	Arg args[1];
X
X	if (owner == O_ENEMY && tile->value >= FLAG && tile->value <= BOMB)
X		pixmap = tiles[ENEMY].pixmap;
X	else
X		pixmap = tile->pixmap;
X
X	board_pos->owner = owner;
X	board_pos->value = tile->value;
X
X	XtSetArg (args[0], XtNbitmap, pixmap);
X	XtSetValues (board_pos->widget, args, 1);
X}
X
Xvoid MarkBoardPosition (board_pos, reveal)
XBOARD_POS *board_pos;
XBoolean reveal;
X{
X	Pixmap pixmap;
X	Arg args[1];
X
X	if (reveal == True)
X		pixmap = tiles[board_pos->value].stippled_pixmap;
X	else if (board_pos->owner == O_ENEMY) 
X		pixmap = tiles[ENEMY].pixmap;
X	else
X		pixmap = tiles[board_pos->value].pixmap;
X
X	XtSetArg (args[0], XtNbitmap, pixmap);
X	XtSetValues (board_pos->widget, args, 1);
X}
X
Xvoid UpdateTileCount (tile, delta)
XTILE *tile;
Xint delta;
X{
X	Arg args[2];
X	char num_buf[5];
X
X	tile->count += delta;
X
X	if (tile->count == 0) {
X		strcpy (num_buf, " - ");
X		XtSetArg (args[0], XtNhighlightThickness, 0);
X		XtSetArg (args[1], XtNbitmap, tile->stippled_pixmap);
X		XtSetValues (tile->bitmap_widget, args, 2);
X	}
X	else {
X		sprintf (num_buf, " %d ", tile->count);
X		if (tile->count == delta) {
X			if (players[0].status == PL_SETUP)
X				XtSetArg (args[0], XtNhighlightThickness, 1);
X			else
X				XtSetArg (args[0], XtNhighlightThickness, 0);
X			XtSetArg (args[1], XtNbitmap, tile->pixmap);
X			XtSetValues (tile->bitmap_widget, args, 2);
X		}
X	}
X
X	XtSetArg (args[0], XtNlabel, num_buf);
X	XtSetValues (tile->count_widget, args, 1);
X}
X
XXtActionHookProc ButtonPressHook (widget, data, action_name, event, params, cnt)
XWidget widget;
XXtPointer data;
XString action_name;
XXEvent *event;
XString *params;
XCardinal *cnt;
X{
X	if (event->type == ButtonPress) {
X		message ("");
X		if (players[0].confirm)
X			ConfirmMove ();
X	}
X}
X
X#include <varargs.h>
X
X/*VARARGS0*/
Xvoid message (va_alist)
Xva_dcl
X{
X	static char msg_buf[BUFSIZ];
X	va_list arglist;
X	char *fmt;
X	Arg args[1];
X
X	va_start (arglist);
X	fmt = va_arg (arglist, char *);
X
X	vsprintf (msg_buf, fmt, arglist);
X	va_end (arglist);
X
X	XtSetArg (args[0], XtNlabel, msg_buf);
X	XtSetValues (Message, args, 1);
X}
END_OF_FILE
if test 2651 -ne `wc -c <'callback.c'`; then
    echo shar: \"'callback.c'\" unpacked with wrong size!
fi
# end of 'callback.c'
fi
if test -f 'icons/captain_mask.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icons/captain_mask.h'\"
else
echo shar: Extracting \"'icons/captain_mask.h'\" \(1502 characters\)
sed "s/^X//" >'icons/captain_mask.h' <<'END_OF_FILE'
X#define captain_mask_width 35
X#define captain_mask_height 43
X#define captain_mask_x_hot -1
X#define captain_mask_y_hot -1
Xstatic char captain_mask_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
X   0x00, 0x00, 0x00, 0x80, 0x0f, 0x3e, 0x00, 0x00, 0x80, 0xef, 0x3f, 0x00,
X   0x00, 0x80, 0xff, 0x7f, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00,
X   0xfe, 0x7f, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x00, 0x00, 0x00, 0xfc, 0xff,
X   0x00, 0x00, 0x00, 0xfc, 0xff, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x01, 0x00,
X   0x00, 0xfc, 0xff, 0x01, 0x00, 0x00, 0xfe, 0xff, 0x01, 0x00, 0x00, 0xfe,
X   0xff, 0x01, 0x00, 0x00, 0xfc, 0xff, 0x03, 0x00, 0x00, 0xf8, 0xff, 0x03,
X   0x00, 0x00, 0xf8, 0xff, 0x03, 0x00, 0x00, 0xf8, 0xff, 0x07, 0x00, 0x00,
X   0xf8, 0xff, 0x07, 0x00, 0x00, 0xf8, 0xff, 0x07, 0x00, 0x80, 0xf8, 0xff,
X   0x07, 0x00, 0x80, 0xff, 0xff, 0x07, 0x00, 0x00, 0xf8, 0xff, 0x07, 0x00,
X   0x00, 0xf8, 0xff, 0x07, 0x00, 0x00, 0xf8, 0xff, 0x07, 0x00, 0x00, 0xfc,
X   0xff, 0x03, 0x00, 0x00, 0xfc, 0xff, 0x03, 0x00, 0x00, 0xfe, 0xff, 0x03,
X   0x00, 0x00, 0xfe, 0xff, 0x01, 0x00, 0x00, 0xfc, 0xff, 0x01, 0x00, 0x00,
X   0xf8, 0xff, 0x01, 0x00, 0x00, 0xf8, 0xff, 0x01, 0x00, 0x00, 0xf8, 0xff,
X   0x01, 0x00, 0x00, 0xf0, 0xff, 0x01, 0x00, 0x00, 0xe0, 0xff, 0x01, 0x00,
X   0x00, 0xe0, 0xff, 0x01, 0x00, 0x00, 0xe0, 0xff, 0x01, 0x00, 0x00, 0xc0,
X   0xff, 0x01, 0x00, 0x00, 0xc0, 0xff, 0x00, 0x00, 0x00, 0xc0, 0x1f, 0x00,
X   0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1502 -ne `wc -c <'icons/captain_mask.h'`; then
    echo shar: \"'icons/captain_mask.h'\" unpacked with wrong size!
fi
# end of 'icons/captain_mask.h'
fi
if test -f 'icons/colonel_mask.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icons/colonel_mask.h'\"
else
echo shar: Extracting \"'icons/colonel_mask.h'\" \(1502 characters\)
sed "s/^X//" >'icons/colonel_mask.h' <<'END_OF_FILE'
X#define colonel_mask_width 35
X#define colonel_mask_height 43
X#define colonel_mask_x_hot -1
X#define colonel_mask_y_hot -1
Xstatic char colonel_mask_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00,
X   0xfc, 0x03, 0x00, 0x00, 0x00, 0xfe, 0x07, 0x00, 0x00, 0x00, 0xff, 0x0f,
X   0x00, 0x00, 0x80, 0xff, 0x0f, 0x00, 0x00, 0x80, 0xff, 0x1f, 0x00, 0x00,
X   0x80, 0xff, 0x1f, 0x00, 0x00, 0x80, 0xff, 0x1f, 0x00, 0x00, 0x80, 0xff,
X   0x3f, 0x00, 0x00, 0xe0, 0xff, 0x3f, 0x00, 0x00, 0xf8, 0xff, 0x3f, 0x00,
X   0x00, 0xfe, 0xff, 0x3f, 0x00, 0x80, 0xff, 0xff, 0x1f, 0x00, 0xe0, 0xff,
X   0xff, 0x1f, 0x00, 0xf0, 0xff, 0xff, 0x1f, 0x00, 0xf0, 0xff, 0xff, 0x1f,
X   0x00, 0xf0, 0xff, 0xff, 0x0f, 0x00, 0xf0, 0xff, 0xff, 0x03, 0x00, 0xf0,
X   0xff, 0xff, 0x03, 0x00, 0x70, 0xff, 0xff, 0x03, 0x00, 0x20, 0xfe, 0xff,
X   0x03, 0x00, 0x20, 0xfc, 0xff, 0x03, 0x00, 0x00, 0xf0, 0xff, 0x03, 0x00,
X   0x00, 0xf0, 0xff, 0x03, 0x00, 0x00, 0xf0, 0xff, 0x07, 0x00, 0x00, 0xf0,
X   0xff, 0x07, 0x00, 0x00, 0xf0, 0xff, 0x07, 0x00, 0x00, 0xf0, 0xff, 0x03,
X   0x00, 0x00, 0xf0, 0xff, 0x03, 0x00, 0x00, 0xf0, 0xff, 0x03, 0x00, 0x00,
X   0xe0, 0xff, 0x03, 0x00, 0x00, 0xe0, 0xff, 0x01, 0x00, 0x80, 0xc0, 0xff,
X   0x01, 0x00, 0xc0, 0x81, 0xff, 0x01, 0x00, 0xe0, 0x83, 0xff, 0x01, 0x00,
X   0xe0, 0x83, 0xff, 0x01, 0x00, 0xf0, 0xc7, 0xff, 0x03, 0x00, 0xf8, 0xcf,
X   0xff, 0x03, 0x00, 0xf0, 0xc7, 0xff, 0x03, 0x00, 0xf0, 0x87, 0xff, 0x01,
X   0x00, 0xf8, 0x0f, 0xfe, 0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1502 -ne `wc -c <'icons/colonel_mask.h'`; then
    echo shar: \"'icons/colonel_mask.h'\" unpacked with wrong size!
fi
# end of 'icons/colonel_mask.h'
fi
if test -f 'icons/enemy_mask.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icons/enemy_mask.h'\"
else
echo shar: Extracting \"'icons/enemy_mask.h'\" \(1492 characters\)
sed "s/^X//" >'icons/enemy_mask.h' <<'END_OF_FILE'
X#define enemy_mask_width 35
X#define enemy_mask_height 43
X#define enemy_mask_x_hot -1
X#define enemy_mask_y_hot -1
Xstatic char enemy_mask_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x39, 0xe0, 0x9c, 0xe3, 0xce, 0x39,
X   0xe0, 0x9c, 0xe3, 0xfe, 0x3f, 0xe0, 0xff, 0xe3, 0xfe, 0x3f, 0xe0, 0xff,
X   0xe3, 0xfe, 0x3f, 0xff, 0xff, 0xe3, 0xf0, 0x07, 0x1f, 0x7f, 0xe0, 0xf0,
X   0x87, 0x1f, 0x7f, 0xe0, 0xf0, 0xc7, 0x3f, 0x7f, 0xe0, 0xf0, 0xc7, 0x3f,
X   0x7f, 0x00, 0xf0, 0xc7, 0x3f, 0x7f, 0x00, 0xf0, 0xc7, 0x7f, 0x7f, 0x00,
X   0xf0, 0xc7, 0x7f, 0x7f, 0x00, 0xf0, 0xc7, 0x7f, 0x7f, 0x00, 0xf0, 0xff,
X   0xff, 0x7f, 0x00, 0xf0, 0xff, 0xff, 0x7f, 0x00, 0xf0, 0xff, 0xff, 0x7f,
X   0x00, 0xf0, 0xff, 0xff, 0x7f, 0x00, 0xf0, 0xff, 0xff, 0x7f, 0x00, 0xf0,
X   0xff, 0xff, 0x7f, 0x00, 0xf0, 0xff, 0xff, 0x7f, 0x00, 0xfc, 0xff, 0xff,
X   0x7f, 0x00, 0xfc, 0xff, 0xff, 0xff, 0x01, 0xfe, 0xff, 0xff, 0xff, 0x03,
X   0xfe, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xff,
X   0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff,
X   0x03, 0xfe, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff, 0x03, 0xfe,
X   0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xff,
X   0xff, 0x03, 0xfe, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff, 0x03,
X   0xfe, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xff,
X   0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff,
X   0x03, 0xfc, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1492 -ne `wc -c <'icons/enemy_mask.h'`; then
    echo shar: \"'icons/enemy_mask.h'\" unpacked with wrong size!
fi
# end of 'icons/enemy_mask.h'
fi
if test -f 'icons/general_mask.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icons/general_mask.h'\"
else
echo shar: Extracting \"'icons/general_mask.h'\" \(1502 characters\)
sed "s/^X//" >'icons/general_mask.h' <<'END_OF_FILE'
X#define general_mask_width 35
X#define general_mask_height 43
X#define general_mask_x_hot -1
X#define general_mask_y_hot -1
Xstatic char general_mask_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x80, 0xff,
X   0x01, 0x00, 0x00, 0x80, 0xff, 0x01, 0x00, 0x00, 0x80, 0xff, 0x01, 0x00,
X   0x00, 0x80, 0xff, 0x81, 0x10, 0x00, 0x80, 0xff, 0xc1, 0x39, 0x00, 0x00,
X   0xff, 0xe1, 0x7f, 0x00, 0x00, 0xff, 0xc1, 0x39, 0x00, 0x00, 0xfe, 0x80,
X   0x10, 0x00, 0x00, 0xfc, 0x83, 0x10, 0x00, 0x00, 0xfc, 0xc7, 0x39, 0x00,
X   0x00, 0xfe, 0xef, 0x7f, 0x00, 0x00, 0xfe, 0xcf, 0x39, 0x00, 0x00, 0xff,
X   0x9f, 0x10, 0x00, 0x00, 0xff, 0x1f, 0x00, 0x00, 0x80, 0xff, 0x1f, 0x00,
X   0x00, 0x80, 0xff, 0x3f, 0x00, 0x00, 0x80, 0xff, 0x3f, 0x00, 0x00, 0x80,
X   0xff, 0x3f, 0x00, 0x00, 0x80, 0xff, 0x7f, 0x00, 0x00, 0x80, 0xff, 0xff,
X   0x00, 0x00, 0x80, 0xff, 0xff, 0x00, 0x00, 0xc0, 0xff, 0xff, 0x00, 0x00,
X   0xe0, 0xff, 0xff, 0x00, 0x00, 0xe0, 0xff, 0x1f, 0x00, 0x00, 0xe0, 0xff,
X   0x1f, 0x00, 0x00, 0xe0, 0xff, 0x1f, 0x00, 0x00, 0x00, 0xfe, 0x1f, 0x00,
X   0x00, 0x00, 0xfe, 0x1f, 0x00, 0x00, 0x00, 0xfe, 0x1f, 0x00, 0x00, 0x00,
X   0xfe, 0x1f, 0x00, 0x00, 0x80, 0xff, 0x1f, 0x00, 0x00, 0xc0, 0xff, 0x1f,
X   0x00, 0x00, 0xf0, 0xff, 0x3f, 0x00, 0x00, 0xf0, 0xff, 0x7f, 0x00, 0x00,
X   0xf0, 0xff, 0x7f, 0x00, 0x00, 0xf0, 0xff, 0x7f, 0x00, 0x00, 0xf0, 0xff,
X   0x7f, 0x00, 0x00, 0xf0, 0xff, 0x3f, 0x00, 0x00, 0xe0, 0xff, 0x3f, 0x00,
X   0x00, 0xe0, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1502 -ne `wc -c <'icons/general_mask.h'`; then
    echo shar: \"'icons/general_mask.h'\" unpacked with wrong size!
fi
# end of 'icons/general_mask.h'
fi
if test -f 'icons/lieutenant.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icons/lieutenant.h'\"
else
echo shar: Extracting \"'icons/lieutenant.h'\" \(1492 characters\)
sed "s/^X//" >'icons/lieutenant.h' <<'END_OF_FILE'
X#define lieutenant_width 35
X#define lieutenant_height 43
X#define lieutenant_x_hot 17
X#define lieutenant_y_hot 24
Xstatic char lieutenant_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0xa0, 0x0a, 0x00, 0x00, 0x00, 0xf0, 0x0f, 0x00,
X   0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
X   0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0xc0, 0x03,
X   0x00, 0x00, 0x00, 0x80, 0x0f, 0x00, 0x00, 0x00, 0xf0, 0xfe, 0x00, 0x00,
X   0x00, 0xcc, 0x3e, 0x01, 0x00, 0x00, 0xf2, 0xfe, 0x01, 0x00, 0x00, 0xff,
X   0xfe, 0x01, 0x00, 0x00, 0x6f, 0x7e, 0x01, 0x00, 0x00, 0x7a, 0x3d, 0x00,
X   0x00, 0x00, 0xf2, 0x5c, 0x01, 0x00, 0x00, 0xcb, 0x47, 0x01, 0x00, 0x00,
X   0x3b, 0xf0, 0x01, 0x00, 0x00, 0xfa, 0xff, 0x00, 0x00, 0x00, 0xf2, 0xff,
X   0x00, 0x00, 0x00, 0xf2, 0xff, 0x00, 0x00, 0x00, 0xfa, 0xff, 0x00, 0x00,
X   0x00, 0x52, 0x57, 0x00, 0x00, 0x00, 0x12, 0x40, 0x00, 0x00, 0x00, 0x32,
X   0x43, 0x00, 0x00, 0x00, 0x16, 0x20, 0x00, 0x00, 0x00, 0x66, 0x20, 0x00,
X   0x00, 0x00, 0xe4, 0x38, 0x00, 0x00, 0x00, 0xa4, 0x2f, 0x00, 0x00, 0x00,
X   0x64, 0x77, 0x00, 0x00, 0x00, 0xe4, 0x7a, 0x00, 0x00, 0xf0, 0xef, 0xfd,
X   0xff, 0x00, 0xf8, 0xff, 0xff, 0xff, 0x01, 0xf8, 0x4f, 0x10, 0xff, 0x01,
X   0xd8, 0x03, 0x00, 0xbc, 0x01, 0x58, 0x27, 0x20, 0xae, 0x01, 0x50, 0x03,
X   0x00, 0xac, 0x00, 0x50, 0x13, 0x80, 0xac, 0x00, 0x40, 0x03, 0x00, 0x2c,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1492 -ne `wc -c <'icons/lieutenant.h'`; then
    echo shar: \"'icons/lieutenant.h'\" unpacked with wrong size!
fi
# end of 'icons/lieutenant.h'
fi
if test -f 'icons/lieutenant_mask.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icons/lieutenant_mask.h'\"
else
echo shar: Extracting \"'icons/lieutenant_mask.h'\" \(1517 characters\)
sed "s/^X//" >'icons/lieutenant_mask.h' <<'END_OF_FILE'
X#define lieutenant_mask_width 35
X#define lieutenant_mask_height 43
X#define lieutenant_mask_x_hot -1
X#define lieutenant_mask_y_hot -1
Xstatic char lieutenant_mask_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
X   0x1f, 0x00, 0x00, 0x00, 0xf8, 0x1f, 0x00, 0x00, 0x00, 0xf8, 0x1f, 0x00,
X   0x00, 0x00, 0xf8, 0x1f, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00,
X   0xc0, 0x03, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0xe0, 0x1f,
X   0x00, 0x00, 0x00, 0xf8, 0xff, 0x01, 0x00, 0x00, 0xfe, 0xff, 0x03, 0x00,
X   0x00, 0xff, 0xff, 0x03, 0x00, 0x80, 0xff, 0xff, 0x03, 0x00, 0x80, 0xff,
X   0xff, 0x03, 0x00, 0x80, 0xff, 0xff, 0x03, 0x00, 0x80, 0xff, 0xff, 0x03,
X   0x00, 0x80, 0xff, 0xff, 0x03, 0x00, 0x80, 0xff, 0xff, 0x03, 0x00, 0x80,
X   0xff, 0xff, 0x03, 0x00, 0x80, 0xff, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff,
X   0x01, 0x00, 0x00, 0xff, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x01, 0x00,
X   0x00, 0xff, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff,
X   0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00,
X   0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x00, 0x00, 0x00,
X   0xfe, 0xff, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0x01, 0xfc, 0xff, 0xff,
X   0xff, 0x03, 0xfc, 0xff, 0xff, 0xff, 0x03, 0xfc, 0xff, 0xff, 0xff, 0x03,
X   0xfc, 0xff, 0xff, 0xff, 0x03, 0xfc, 0xff, 0xff, 0xff, 0x03, 0xfc, 0xff,
X   0xff, 0xff, 0x03, 0xf8, 0xff, 0xff, 0xff, 0x01, 0xf8, 0xff, 0xff, 0xff,
X   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1517 -ne `wc -c <'icons/lieutenant_mask.h'`; then
    echo shar: \"'icons/lieutenant_mask.h'\" unpacked with wrong size!
fi
# end of 'icons/lieutenant_mask.h'
fi
if test -f 'icons/major_mask.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icons/major_mask.h'\"
else
echo shar: Extracting \"'icons/major_mask.h'\" \(1492 characters\)
sed "s/^X//" >'icons/major_mask.h' <<'END_OF_FILE'
X#define major_mask_width 35
X#define major_mask_height 43
X#define major_mask_x_hot -1
X#define major_mask_y_hot -1
Xstatic char major_mask_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa0, 0x04, 0x00, 0x00, 0x00, 0xf8, 0x07, 0x00, 0x00, 0xe0, 0xff, 0x0f,
X   0x00, 0x00, 0xf8, 0xff, 0x0f, 0x00, 0x00, 0xfc, 0xff, 0x0f, 0x00, 0x00,
X   0xff, 0xff, 0x1f, 0x00, 0x00, 0xff, 0xff, 0x3f, 0x00, 0x80, 0xff, 0xff,
X   0x3f, 0x00, 0x80, 0xff, 0xff, 0x7f, 0x00, 0xc0, 0xff, 0xff, 0x3f, 0x00,
X   0xc0, 0xff, 0xff, 0x7f, 0x00, 0x80, 0xff, 0xff, 0x3f, 0x00, 0x80, 0xff,
X   0xff, 0x3f, 0x00, 0x00, 0xdf, 0xff, 0x3f, 0x00, 0x00, 0xcc, 0xff, 0x1f,
X   0x00, 0x00, 0xe0, 0xff, 0x1f, 0x00, 0x00, 0xe0, 0xff, 0x1f, 0x00, 0x00,
X   0xf0, 0xff, 0x0f, 0x00, 0x00, 0xf8, 0xff, 0x0f, 0x00, 0x00, 0xfc, 0xff,
X   0x07, 0x00, 0x00, 0xfe, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0x07, 0x00,
X   0x80, 0xff, 0xff, 0x03, 0x00, 0xc0, 0xff, 0xff, 0x03, 0x00, 0xe0, 0xff,
X   0xff, 0x01, 0x00, 0xf0, 0xff, 0xff, 0x01, 0x00, 0xf0, 0xff, 0xff, 0x01,
X   0x00, 0x80, 0xff, 0xff, 0x03, 0x00, 0x80, 0xff, 0xff, 0x07, 0x00, 0x80,
X   0xff, 0xff, 0x07, 0x00, 0x80, 0xff, 0xff, 0x07, 0x00, 0x00, 0xff, 0x7f,
X   0x00, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x08, 0x00,
X   0x00, 0xff, 0x7f, 0x1c, 0x00, 0x00, 0xff, 0x7f, 0x3e, 0x00, 0x00, 0xfe,
X   0x1f, 0x1c, 0x00, 0x00, 0xfe, 0x83, 0xff, 0x00, 0x00, 0x7e, 0x80, 0xff,
X   0x00, 0x00, 0x0e, 0x80, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1492 -ne `wc -c <'icons/major_mask.h'`; then
    echo shar: \"'icons/major_mask.h'\" unpacked with wrong size!
fi
# end of 'icons/major_mask.h'
fi
if test -f 'icons/marshal_mask.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icons/marshal_mask.h'\"
else
echo shar: Extracting \"'icons/marshal_mask.h'\" \(1502 characters\)
sed "s/^X//" >'icons/marshal_mask.h' <<'END_OF_FILE'
X#define marshal_mask_width 35
X#define marshal_mask_height 43
X#define marshal_mask_x_hot -1
X#define marshal_mask_y_hot -1
Xstatic char marshal_mask_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x07, 0x00, 0x00, 0xf0,
X   0xff, 0x07, 0x00, 0x00, 0xf0, 0xff, 0x3f, 0x00, 0x00, 0xf8, 0xff, 0x7f,
X   0x00, 0x00, 0xf8, 0xff, 0xff, 0x00, 0x98, 0xf9, 0xff, 0xff, 0x00, 0x9c,
X   0xfb, 0xff, 0xff, 0x00, 0x90, 0xf8, 0xff, 0x7f, 0x00, 0x60, 0xf8, 0xff,
X   0x7f, 0x00, 0x60, 0xf8, 0xff, 0x7f, 0x00, 0x90, 0xf8, 0xff, 0x1f, 0x00,
X   0x9c, 0xfb, 0xff, 0x3f, 0x00, 0x98, 0xfd, 0xff, 0x3f, 0x00, 0x00, 0xfe,
X   0xff, 0x1f, 0x00, 0x00, 0xff, 0xff, 0x07, 0x00, 0x80, 0xff, 0xff, 0x07,
X   0x00, 0xc0, 0xff, 0xff, 0x07, 0x00, 0xe0, 0xff, 0xff, 0x07, 0x00, 0xf0,
X   0xff, 0xff, 0x07, 0x00, 0xf8, 0xff, 0xff, 0x0f, 0x00, 0xfe, 0xff, 0xff,
X   0x0f, 0x00, 0xfe, 0xff, 0xff, 0x0f, 0x00, 0xfe, 0xff, 0xff, 0x0f, 0x00,
X   0xfc, 0xff, 0xff, 0x0f, 0x00, 0xfc, 0xff, 0xff, 0x00, 0x00, 0xf8, 0xff,
X   0xff, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x00,
X   0x00, 0xf0, 0xff, 0xff, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0x00, 0xe0,
X   0xff, 0xff, 0xff, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x00, 0xf0, 0xff, 0xff,
X   0xff, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x00, 0xf8, 0xff, 0xff, 0xff, 0x00,
X   0xf8, 0xff, 0xff, 0xff, 0x00, 0xf8, 0xff, 0xff, 0xff, 0x00, 0xf8, 0xff,
X   0xff, 0xff, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x00, 0xf0, 0xff, 0xff, 0xff,
X   0x00, 0xc0, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1502 -ne `wc -c <'icons/marshal_mask.h'`; then
    echo shar: \"'icons/marshal_mask.h'\" unpacked with wrong size!
fi
# end of 'icons/marshal_mask.h'
fi
if test -f 'icons/miner_mask.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icons/miner_mask.h'\"
else
echo shar: Extracting \"'icons/miner_mask.h'\" \(1492 characters\)
sed "s/^X//" >'icons/miner_mask.h' <<'END_OF_FILE'
X#define miner_mask_width 35
X#define miner_mask_height 43
X#define miner_mask_x_hot -1
X#define miner_mask_y_hot -1
Xstatic char miner_mask_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x03, 0x00, 0x00, 0x80,
X   0xff, 0x1f, 0x00, 0x00, 0xc0, 0xff, 0x3f, 0x00, 0x00, 0xe0, 0xff, 0x7f,
X   0x00, 0x00, 0xf8, 0xff, 0xff, 0x00, 0x00, 0xfc, 0xff, 0xff, 0x01, 0x00,
X   0xfe, 0xff, 0xff, 0x03, 0x00, 0xff, 0xff, 0xff, 0x03, 0x00, 0xff, 0xff,
X   0xff, 0x03, 0x80, 0xff, 0xff, 0xff, 0x03, 0x80, 0xff, 0xff, 0xff, 0x03,
X   0xc0, 0xff, 0xff, 0xff, 0x03, 0xc0, 0xff, 0xff, 0xff, 0x03, 0xf0, 0xff,
X   0xff, 0xff, 0x03, 0xf0, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff,
X   0x03, 0xfe, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff, 0x03, 0xfe,
X   0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff, 0x03, 0xc0, 0xff, 0xff,
X   0xff, 0x03, 0xe0, 0xff, 0xff, 0xff, 0x03, 0xe0, 0xff, 0xff, 0xff, 0x03,
X   0xe0, 0xff, 0xff, 0xff, 0x03, 0xe0, 0xff, 0xff, 0xff, 0x03, 0xe0, 0xff,
X   0xff, 0xff, 0x03, 0xe0, 0xff, 0xff, 0x1f, 0x00, 0xc0, 0xff, 0xff, 0x1f,
X   0x00, 0x80, 0xff, 0xff, 0x1f, 0x00, 0x80, 0xff, 0xff, 0x1f, 0x00, 0x80,
X   0xff, 0xff, 0x1f, 0x00, 0x80, 0xff, 0xff, 0x1f, 0x00, 0x80, 0xff, 0xff,
X   0x1f, 0x00, 0x80, 0xff, 0xff, 0x1f, 0x00, 0x00, 0xfe, 0xff, 0x1f, 0x00,
X   0x00, 0xfe, 0xff, 0x1f, 0x00, 0x00, 0xfe, 0xff, 0x1f, 0x00, 0x00, 0xfe,
X   0xff, 0x03, 0x00, 0x00, 0xfe, 0x7f, 0x00, 0x00, 0x00, 0xfe, 0x07, 0x00,
X   0x00, 0x00, 0xfe, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1492 -ne `wc -c <'icons/miner_mask.h'`; then
    echo shar: \"'icons/miner_mask.h'\" unpacked with wrong size!
fi
# end of 'icons/miner_mask.h'
fi
if test -f 'icons/scout_mask.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icons/scout_mask.h'\"
else
echo shar: Extracting \"'icons/scout_mask.h'\" \(1492 characters\)
sed "s/^X//" >'icons/scout_mask.h' <<'END_OF_FILE'
X#define scout_mask_width 35
X#define scout_mask_height 43
X#define scout_mask_x_hot -1
X#define scout_mask_y_hot -1
Xstatic char scout_mask_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x03, 0x00, 0x00, 0x00, 0xf8,
X   0x03, 0x00, 0x00, 0x00, 0xf8, 0x7f, 0x00, 0x00, 0x00, 0xf8, 0xff, 0x00,
X   0x00, 0x00, 0xfc, 0xff, 0x01, 0x00, 0x00, 0xfc, 0xff, 0x03, 0x00, 0x00,
X   0xfe, 0xff, 0x07, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0x00, 0xfe, 0xff,
X   0x0f, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00,
X   0x00, 0xfe, 0xff, 0x0f, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0x00, 0xfe,
X   0xff, 0x0f, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0x00, 0xfe, 0xff, 0x0f,
X   0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0x00,
X   0xfe, 0xff, 0x0f, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0x00, 0xfe, 0xff,
X   0x0f, 0x00, 0x00, 0xfc, 0xff, 0x0f, 0x00, 0x00, 0xfc, 0xff, 0x0f, 0x00,
X   0x00, 0xf8, 0xff, 0x0f, 0x00, 0x00, 0xf8, 0xff, 0x1f, 0x00, 0x00, 0xf8,
X   0xff, 0x1f, 0x00, 0x00, 0xf0, 0xff, 0x1f, 0x00, 0x00, 0xf8, 0xff, 0x1f,
X   0x00, 0xf0, 0xff, 0xff, 0x7f, 0x00, 0xf0, 0xff, 0xff, 0x7f, 0x00, 0xf0,
X   0xff, 0xff, 0x7f, 0x00, 0xf0, 0xff, 0xff, 0x7f, 0x00, 0xf0, 0xff, 0xff,
X   0x7f, 0x00, 0xf0, 0xff, 0xff, 0x7f, 0x00, 0xf0, 0xff, 0xff, 0x7f, 0x00,
X   0xf0, 0xff, 0xff, 0x7f, 0x00, 0xf0, 0xff, 0xff, 0x7f, 0x00, 0xf0, 0xff,
X   0xff, 0x7f, 0x00, 0x00, 0xff, 0xff, 0x3f, 0x00, 0x00, 0xff, 0xff, 0x0f,
X   0x00, 0x00, 0xf0, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1492 -ne `wc -c <'icons/scout_mask.h'`; then
    echo shar: \"'icons/scout_mask.h'\" unpacked with wrong size!
fi
# end of 'icons/scout_mask.h'
fi
if test -f 'icons/sergeant_mask.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icons/sergeant_mask.h'\"
else
echo shar: Extracting \"'icons/sergeant_mask.h'\" \(1507 characters\)
sed "s/^X//" >'icons/sergeant_mask.h' <<'END_OF_FILE'
X#define sergeant_mask_width 35
X#define sergeant_mask_height 43
X#define sergeant_mask_x_hot -1
X#define sergeant_mask_y_hot -1
Xstatic char sergeant_mask_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x1f, 0x00, 0x00, 0x3e,
X   0xc0, 0x3f, 0x00, 0x00, 0xff, 0xf1, 0x3f, 0x00, 0x00, 0xff, 0xff, 0x3f,
X   0x00, 0x00, 0xff, 0xff, 0x3f, 0x00, 0x80, 0xff, 0xff, 0x3f, 0x00, 0xc0,
X   0xff, 0xff, 0x3f, 0x00, 0xc0, 0xff, 0xff, 0x3f, 0x00, 0xe0, 0xff, 0xff,
X   0x3f, 0x00, 0xe0, 0xff, 0xff, 0x3f, 0x00, 0xe0, 0xff, 0xff, 0x3f, 0x00,
X   0xc0, 0xff, 0xff, 0x7f, 0x00, 0x80, 0xff, 0xff, 0x7f, 0x00, 0x00, 0xfe,
X   0xff, 0x7f, 0x00, 0x00, 0xfe, 0xff, 0x7f, 0x00, 0x00, 0xfc, 0xff, 0x7f,
X   0x00, 0x00, 0xfc, 0xff, 0x7f, 0x00, 0x00, 0xfe, 0xff, 0x7f, 0x00, 0x00,
X   0xfe, 0xff, 0x7f, 0x00, 0x00, 0xfe, 0xff, 0x7f, 0x00, 0x00, 0xfe, 0xff,
X   0x3f, 0x00, 0x00, 0xff, 0xff, 0x1f, 0x00, 0x80, 0xff, 0xff, 0x1f, 0x00,
X   0x80, 0xff, 0xff, 0x1f, 0x00, 0x80, 0xff, 0xff, 0x0f, 0x00, 0xc0, 0xff,
X   0xff, 0x0f, 0x00, 0xe0, 0xff, 0xff, 0x0f, 0x00, 0xe0, 0xff, 0xff, 0x0f,
X   0x00, 0xe0, 0xff, 0xff, 0x0f, 0x00, 0xc0, 0xff, 0xff, 0x0f, 0x00, 0x80,
X   0xff, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff,
X   0x0f, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0x00, 0xfc, 0xff, 0x0f, 0x00,
X   0x00, 0xfc, 0xff, 0x0f, 0x00, 0x00, 0xfc, 0xff, 0x07, 0x00, 0x00, 0xfc,
X   0xff, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00, 0xfc, 0x03, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1507 -ne `wc -c <'icons/sergeant_mask.h'`; then
    echo shar: \"'icons/sergeant_mask.h'\" unpacked with wrong size!
fi
# end of 'icons/sergeant_mask.h'
fi
if test -f 'init.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'init.c'\"
else
echo shar: Extracting \"'init.c'\" \(4891 characters\)
sed "s/^X//" >'init.c' <<'END_OF_FILE'
X/*
X * Init.c
X *
X * Icon declarations followed by Initialised tile structures.
X * Initialisation routines.
X */
X
X#include "stratego.h"
X
X#include "icons/free.h"
X#include "icons/free_s.h"
X#include "icons/free_mask.h"
X
X#include "icons/enemy.h"
X#include "icons/enemy_s.h"
X#include "icons/enemy_mask.h"
X
X#include "icons/flag.h"
X#include "icons/flag_s.h"
X#include "icons/flag_mask.h"
X
X#include "icons/marshal.h"
X#include "icons/marshal_s.h"
X#include "icons/marshal_mask.h"
X
X#include "icons/general.h"
X#include "icons/general_s.h"
X#include "icons/general_mask.h"
X
X#include "icons/colonel.h"
X#include "icons/colonel_s.h"
X#include "icons/colonel_mask.h"
X
X#include "icons/major.h"
X#include "icons/major_s.h"
X#include "icons/major_mask.h"
X
X#include "icons/captain.h"
X#include "icons/captain_s.h"
X#include "icons/captain_mask.h"
X
X#include "icons/lieutenant.h"
X#include "icons/lieutenant_s.h"
X#include "icons/lieutenant_mask.h"
X
X#include "icons/sergeant.h"
X#include "icons/sergeant_s.h"
X#include "icons/sergeant_mask.h"
X
X#include "icons/miner.h"
X#include "icons/miner_s.h"
X#include "icons/miner_mask.h"
X
X#include "icons/scout.h"
X#include "icons/scout_s.h"
X#include "icons/scout_mask.h"
X
X#include "icons/spy.h"
X#include "icons/spy_s.h"
X#include "icons/spy_mask.h"
X
X#include "icons/bomb.h"
X#include "icons/bomb_s.h"
X#include "icons/bomb_mask.h"
X
X#include "icons/boat_cursor.h"
X#include "icons/boat_cursor_mask.h"
X
X#include "icons/board_cursor.h"
X#include "icons/board_cursor_mask.h"
X
X#include "icons/account_cursor.h"
X#include "icons/account_cursor_mask.h"
X
X#define TILE_ENTRY(name, value, count)	\
X	{ value, "name", name/**/_bits, name/**/_s_bits, name/**/_mask_bits, \
X	  (Pixmap) 0, (Pixmap) 0, (Cursor) 0, \
X	  name/**/_x_hot, name/**/_y_hot, name/**/_width, name/**/_height, \
X	  count, count }
X
X#define CURSOR_ENTRY(name) \
X	{ 0, NULL, name/**/_bits, NULL, name/**/_mask_bits, \
X	  (Pixmap) 0, (Pixmap) 0, (Cursor) 0, \
X	  name/**/_x_hot, name/**/_y_hot, name/**/_width, name/**/_height, 0,0 }
X
XTILE tiles[MAX_TILES + MAX_CURSORS] = {
X	TILE_ENTRY (free,       FREE,       1),
X	TILE_ENTRY (enemy,      ENEMY,      0),
X	TILE_ENTRY (flag,       FLAG,       1),
X	TILE_ENTRY (marshal,    MARSHAL,    1),
X	TILE_ENTRY (general,    GENERAL,    1),
X	TILE_ENTRY (colonel,    COLONEL,    2),
X	TILE_ENTRY (major,      MAJOR,      3),
X	TILE_ENTRY (captain,    CAPTAIN,    4),
X	TILE_ENTRY (lieutenant, LIEUTENANT, 4),
X	TILE_ENTRY (sergeant,   SERGEANT,   4),
X	TILE_ENTRY (miner,      MINER,      5),
X	TILE_ENTRY (scout,      SCOUT,      8),
X	TILE_ENTRY (spy,        SPY,        1),
X	TILE_ENTRY (bomb,       BOMB,       6),
X	CURSOR_ENTRY (boat_cursor),
X	CURSOR_ENTRY (board_cursor),
X	CURSOR_ENTRY (account_cursor)
X};
X
X/* Create tile pixmaps and cursors on board window */
Xvoid init_icons ()
X{
X	Display *display = XDISPLAY;
X	Pixmap pixmap_mask;
X	XColor black_color, white_color;
X	TILE *tile;
X	int i;
X
X	XLookupColor (display, DefaultColormap (display, XSCREEN), "black",
X		      &black_color, &black_color);
X	XLookupColor (display, DefaultColormap (display, XSCREEN), "white",
X		      &white_color, &white_color);
X
X        for (i = 0; i < MAX_TILES + MAX_CURSORS; i++) {
X                tile = &tiles[i];
X                tile->pixmap = XCreateBitmapFromData (display, XROOTWINDOW,
X                                        tile->bitmap,
X                                        tile->width, tile->height);
X                pixmap_mask  = XCreateBitmapFromData (display, XROOTWINDOW,
X                                            tile->bitmap_mask,
X                                            tile->width, tile->height);
X
X                tile->cursor = XCreatePixmapCursor (display, tile->pixmap,
X                                        pixmap_mask,
X                                        &black_color, &white_color,
X                                        tile->hotspot_x, tile->hotspot_y);
X                XFreePixmap (display, pixmap_mask);
X                XFreePixmap (display, tile->pixmap);
X
X		if (tile->name == NULL)
X			continue;		/* Cursor entry */
X
X                tile->pixmap = XCreateBitmapFromData (display, XROOTWINDOW,
X                                        tile->bitmap,
X                                        tile->width, tile->height);
X                tile->stippled_pixmap = XCreateBitmapFromData (display,
X						XROOTWINDOW,
X                                        	tile->stippled_bitmap,
X                                        	tile->width, tile->height);
X        }
X
X	XFreeCursor (display, tiles[FREE].cursor);
X	tiles[FREE].cursor = tiles[BOARD_CURSOR].cursor;
X}
X
Xvoid init_board ()
X{
X	int y, x;
X
X	for (y = MAX_ROWS - 1; y >= 0; y--)
X		for (x = MAX_COLS - 1; x >= 0; x--)
X			board[y][x].owner = O_NOBODY;
X
X	board[4][2].value = board[4][3].value = WATER;
X	board[5][2].value = board[5][3].value = WATER;
X
X	board[4][6].value = board[4][7].value = WATER;
X	board[5][6].value = board[5][7].value = WATER;
X}
END_OF_FILE
if test 4891 -ne `wc -c <'init.c'`; then
    echo shar: \"'init.c'\" unpacked with wrong size!
fi
# end of 'init.c'
fi
if test -f 'message.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'message.c'\"
else
echo shar: Extracting \"'message.c'\" \(5315 characters\)
sed "s/^X//" >'message.c' <<'END_OF_FILE'
X/*
X * Message.c
X *
X * Player to player messages module.
X */
X
X#include "stratego.h"
X
X#include <sys/filio.h>
X#include <varargs.h>
X
X#define REMISE_CONFIRMED	0
X#define REMISE_DENIED		1
X
X#define T_MOVE		'0'		/* Messages during play */
X#define T_REMISE	'1'
X#define T_REMISE_ANSWER	'2'
X
X#define T_PLACED_TILE	'3'		/* Messages during setup */
X#define T_SETUP_READY	'4'
X#define T_CLEAR_BOARD	'5'
X
X#define T_QUIT		'6'		/* General messages */
X#define T_MAIL		'7'
X
X#define MESSAGE_LENGTH	125
X
Xstatic char message_buffer[MESSAGE_LENGTH];
Xstatic char message_length[4];
X
Xstatic void receive_ready (), receive_move (), receive_placed_tile (),
X	    receive_remise_answer (), receive_clear_board (),
X	    receive_quit ();
X
Xvoid end_communications()
X{
X	if (players[1].fd > 0) {
X		XtRemoveInput (EnemyID);
X		players[1].fd = -1;
X	}
X}
X
Xstatic void read_data (fd, output, length)
Xint fd, length;
Xchar *output;
X{
X	extern int errno;
X
X	if (read (fd, output, length) == length)
X		return;
X
X	if (errno != 0)
X		perror ("read_data()");
X
X	printf("Communications breakdown. Host/Program crash on other side?\n");
X
X	XtDestroyApplicationContext (app_con);
X	exit (1);
X}
X
XXtInputCallbackProc EnemyInterrupt (client_data, source, id)
XXtPointer client_data;
Xint *source;
XXtInputId *id;
X{
X	if (players[1].fd == -1)
X		return;
X
X	read_data (players[1].fd, message_length, sizeof(message_length));
X	read_data (players[1].fd, message_buffer, atoi (message_length));
X
X	switch (message_buffer[0]) {
X	case T_CLEAR_BOARD:
X		receive_clear_board ();
X		break;
X	case T_SETUP_READY:
X		receive_ready ();
X		break;
X	case T_MOVE:
X		receive_move ();
X		break;
X	case T_QUIT:
X		end_communications ();
X		receive_quit ();
X		return;
X	case T_PLACED_TILE:
X		receive_placed_tile ();
X		break;
X	case T_REMISE:
X		RemiseOffered ();
X		break;
X	case T_REMISE_ANSWER:
X		receive_remise_answer ();
X		break;
X	case T_MAIL:
X		message ("%s: \"%s\"", players[1].name,
X			 &message_buffer[2]);
X		break;
X	default:
X		message ("Unknown input from opponent (type [%o] %c)",
X			  message_buffer[0], message_buffer[0]);
X	}
X}
X
Xstatic void receive_clear_board ()
X{
X	int y, x;
X
X	for (y = 0; y < 4; y++) {
X		for (x = 0; x < MAX_COLS; x++) {
X			if (board[y][x].value != FREE)
X				AssignBoardPosition (&board[y][x],
X						     &tiles[FREE], O_NOBODY);
X		}
X	}
X}
X
Xstatic void receive_ready ()
X{
X	players[1].status = PL_SETUP_READY;
X	if (players[0].status == PL_SETUP)
X		message ("%s just finished his board setup. Hurry up %s!",
X		 	 players[1].name, players[0].name);
X	else
X		start_play ();
X}
X
Xstatic void receive_quit ()
X{
X	if (players[0].status <= PL_SETUP_READY)
X		message ("%s decided to quit his setup!", players[1].name);
X	else
X		message ("You win %s, because %s admitted your superior strategy!", players[0].name, players[1].name);
X
X	end_game ();
X}
X
Xstatic void receive_placed_tile ()
X{
X	int x, y, tile_value;
X
X	sscanf (&message_buffer[1], "%d %d %d", &x, &y, &tile_value);
X	y = (MAX_ROWS - 1) - y;
X	x = (MAX_COLS - 1) - x;
X
X	AssignBoardPosition (&board[y][x], &tiles[tile_value], O_ENEMY);
X}
X
Xstatic void receive_move ()
X{
X	int from_y, from_x, to_y, to_x;
X
X	sscanf (&message_buffer[1], "%d %d %d %d", &from_y, &from_x,
X				    		   &to_y, &to_x);
X
X	from_x = (MAX_COLS - 1) - from_x;
X	from_y = (MAX_ROWS - 1) - from_y;
X	to_x   = (MAX_COLS - 1) - to_x;
X	to_y   = (MAX_ROWS - 1) - to_y;
X
X	switch (execute_move (&board[from_y][from_x],
X			      &board[to_y][to_x])) {
X	case REMISE_MOVE:
X	case WIN_MOVE:
X		end_game ();
X		break;
X	default:
X		check_can_play (O_PLAYER);
X		players[0].status = PL_PLAYING;
X
X		EnableRemiseButton();
X	}
X
X}
X
Xstatic void receive_remise_answer ()
X{
X	static char msg_buf[100];
X	int answer;
X
X	sscanf (&message_buffer[1], "%d", &answer);
X	
X	if (answer == REMISE_DECLINED)
X		sprintf (msg_buf, "%s declined your remise offer %s.",
X			  players[1].name, players[0].name);
X
X	else
X		sprintf (msg_buf, "%s accepted your remise offer %s.",
X			  players[1].name, players[0].name);
X
X	(void) DialogBoxResult (msg_buf, NULL, 0, NO_CANCEL);
X
X	if (answer == REMISE_ACCEPTED)
X		end_game ();
X}
X
X
X/*
X * Send module.
X */
X
X/*VARARGS0*/
Xstatic void send_buffer (va_alist)
Xva_dcl
X{
X	va_list arglist;
X	char *fmt;
X
X	if (players[0].status == PL_ENDGAME || players[0].setup_only)
X		return;
X
X	va_start (arglist);
X	fmt = va_arg (arglist, char *);
X
X	vsprintf (message_buffer, fmt, arglist);
X	va_end (arglist);
X
X	sprintf (message_length, "%d", strlen (message_buffer) + 1);
X
X	write (players[1].fd, message_length, sizeof (message_length));
X	write (players[1].fd, message_buffer, atoi (message_length));
X}
X
Xvoid send_ready ()
X{
X	send_buffer ("%c", T_SETUP_READY);
X}
X
Xvoid send_clear_board ()
X{
X	send_buffer ("%c", T_CLEAR_BOARD);
X}
X
Xvoid send_tile_placed (board_pos)
XBOARD_POS *board_pos;
X{
X	send_buffer ("%c %d %d %d", T_PLACED_TILE,
X		     board_pos->x, board_pos->y, board_pos->value);
X}
X
Xvoid send_move (from_pos, to_pos)
XBOARD_POS *from_pos, *to_pos;
X{
X	send_buffer ("%c %d %d %d %d", T_MOVE,
X		 from_pos->y, from_pos->x, to_pos->y, to_pos->x);
X}
X
Xvoid send_remise_answer (answer)
Xint answer;
X{
X	send_buffer ("%c %d", T_REMISE_ANSWER, answer);
X}
X
Xvoid send_remise_offer ()
X{
X	send_buffer ("%c", T_REMISE);
X}
X
Xvoid send_quit ()
X{
X	send_buffer ("%c", T_QUIT);
X	signal (SIGIO, SIG_IGN);
X}
X
Xvoid send_mail (mail)
Xchar *mail;
X{
X	if (players[0].status == PL_ENDGAME)
X		return;
X
X	send_buffer ("%c %s", T_MAIL, mail);
X}
END_OF_FILE
if test 5315 -ne `wc -c <'message.c'`; then
    echo shar: \"'message.c'\" unpacked with wrong size!
fi
# end of 'message.c'
fi
if test -f 'register.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'register.c'\"
else
echo shar: Extracting \"'register.c'\" \(2198 characters\)
sed "s/^X//" >'register.c' <<'END_OF_FILE'
X/*
X * Register.c
X */
X
X#include "stratego.h"
X
X/*
X * Game Status Register structure definition.
X */
Xtypedef struct s_game_status {
X	int  count;		/* # times position has been registered */
X	char board_layout[MAX_ROWS * MAX_COLS + 1];
X	struct s_game_status *next;
X} GameStatusRec, *GameStatus;
X
Xstatic GameStatus status_list = NULL;
X
X#define BoardValue(y, x)	(board[(y)][(x)].owner * MAX_TILES + \
X				 board[(y)][(x)].value + ' ')
X
X/*
X * Prints remise messages. Confirms for actual remise move.
X */
Xstatic Boolean RemiseSituation(player)
Xint player;
X{
X	static char header[] = "Remise Warning!\nThis board setup has occurred twice before.\n";
X	char msg_buf[250];
X
X	if (player == O_ENEMY) {
X		sprintf (msg_buf, "%sI hereby declare a cease fire!", header);
X		(void) DialogBoxResult (msg_buf, NULL, 0, NO_CANCEL);
X		return REMISE_MOVE;
X	}
X
X	sprintf (msg_buf, "%sPlaying this move will effectuate a remise.",
X		 header);
X
X	if (DialogBoxResult(msg_buf, NULL, 0, ADD_CANCEL) == False)
X		return UNDO_MOVE;
X
X	return REMISE_MOVE;
X}
X
X/*
X * Registers a board setup. Checks if position has occurred before.
X *
X * Issues a warning if position has been registered before
X * Ends game if position has been registers twice already.
X */
Xint register_board (player)
Xint player;				/* The one who is moving */
X{
X	GameStatus new, ptr;
X	int y, x;
X
X	new = XtNew(GameStatusRec);
X	for (y = 0; y < MAX_ROWS; y++)
X		for (x = 0; x < MAX_COLS; x++)
X			new->board_layout[y * MAX_ROWS + x] = BoardValue(y, x);
X	
X	new->board_layout[MAX_ROWS * MAX_COLS] = '\0';
X
X	for (ptr = status_list; ptr != NULL; ptr = ptr->next) {
X		if (!strcmp (ptr->board_layout, new->board_layout)) {
X			XtFree (new);
X
X			if (++ptr->count >= 3)
X				return RemiseSituation(player);
X
X			(void) DialogBoxResult (
X		      "Remise Warning!\nThis board setup has occurred before!",
X				NULL, 0, NO_CANCEL);
X			break;
X		}
X	}
X
X	if (ptr == NULL) {
X		new->count = 1;
X		new->next = status_list;
X		status_list = new;
X	}
X
X	return DO_MOVE;
X}
X
X/*
X * Registers a tile hit. Invalidates all previous positions.
X */
Xvoid register_hit ()
X{
X	GameStatus ptr, next;
X
X	for (ptr = status_list; ptr != NULL; ptr = next) {
X		next = ptr->next;
X		XtFree (ptr);
X	}
X
X	status_list = NULL;
X}
END_OF_FILE
if test 2198 -ne `wc -c <'register.c'`; then
    echo shar: \"'register.c'\" unpacked with wrong size!
fi
# end of 'register.c'
fi
if test -f 'socket.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'socket.c'\"
else
echo shar: Extracting \"'socket.c'\" \(6060 characters\)
sed "s/^X//" >'socket.c' <<'END_OF_FILE'
X/*
X * Socket.h
X *
X * Initial handshake and pecking order determination module.
X */
X
X#include "stratego.h"
X
X#include <signal.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <fcntl.h>
X#include <netinet/in.h>
X#include <netdb.h>
X
Xstatic struct sockaddr_in channel;
X
Xstatic void read_player_data (), write_player_data ();
Xstatic void read_data (), write_data ();
X
Xstatic void perror_exit (label)
Xchar *label;
X{
X	perror (label);
X	exit (-1);
X}
X
Xstatic int generate_port (name)
Xchar *name;
X{
X	int port = 1;
X
X	while (*name != '\0')
X		port *= (*name++ & 0xFF);
X
X	return (port & ~0x8000) | 0x4000;
X}
X
Xstatic void setup_channel (machine, port_name)
Xchar *machine;
Xchar *port_name;
X{
X	struct hostent *hostentry;
X
X	if ((hostentry = gethostbyname (machine)) == NULL) {
X		fprintf (stderr, "%s: No such host\n", machine);
X		exit (-1);
X	}
X
X	channel.sin_family = AF_INET;
X	channel.sin_port   = htons (generate_port (port_name));
X	channel.sin_addr   = (*(struct in_addr *) hostentry->h_addr);
X}
X
Xstatic int connect_socket (machine, port_name)
Xchar *machine;
Xchar *port_name;
X{
X	int s, retries;
X
X	setup_channel (machine, port_name);
X
X	for (retries = 60; retries > 0; retries--) {
X		if ((s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
X			perror_exit ("connect_socket: socket()");
X
X		if (connect (s, (struct sockaddr *) &channel, sizeof (channel))
X			>=0) break;
X
X		sleep (2);
X		close(s);
X	}
X
X	return retries ? s : -1;
X}
X
Xstatic int make_socket (machine, port_name)
Xchar *machine;
Xchar *port_name;
X{
X	int s, size;
X	struct sockaddr_in get_chan;
X
X	setup_channel (machine, port_name);
X
X	if ((s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
X		perror_exit ("make_socket: socket()");
X
X	if (bind (s, (struct socketaddr *) &channel, sizeof (channel)) < 0)
X		return -1;
X
X	if (listen (s, 1) < 0)
X		perror_exit ("make_socket: listen()");
X
X	size = sizeof (get_chan);
X	if ((s = accept (s, &get_chan, &size)) < 0)
X		perror_exit ("make_socket: accept()");
X
X	return s;
X}
X
Xvoid setup_communication (name, opponent, machine)
Xchar *name, *opponent, *machine;
X{
X	struct hostent *hostentry;
X	char new_port[20];
X	int fd, cmp;
X	Boolean master;
X	char *port, *ptr;
X	time_t start;
X
X	strcpy (players[0].name, name);
X	strcpy (players[0].login, cuserid (NULL));
X
X	if (gethostname (players[0].machine, MAXHOSTNAMELEN) < 0)
X		perror_exit ("Can't find your machine name.\n");
X
X/* Strip domain name from machine name (if any) */
X	for (ptr = players[0].machine; *ptr != '\0' && *ptr != '.'; ptr++)
X		;
X	*ptr = '\0';
X
X	if (getdomainname (players[0].domain, NAME_LENGTH) < 0)
X		perror_exit ("Can't find your domain name.\n");
X
X	if ((hostentry = gethostbyname (machine)) == NULL)
X		perror_exit ("Can't find opponents machine name.\n");
X	
X	strcpy  (players[1].login, opponent);
X	strncpy (players[1].machine, hostentry->h_name, MAXHOSTNAMELEN);
X	players[1].machine[MAXHOSTNAMELEN - 1] = '\0';
X
X/* Strip domain name from machine name (if any) */
X	for (ptr = players[1].machine; *ptr != '\0' && *ptr != '.'; ptr++)
X		;
X	*ptr = '\0';
X
X	if ((cmp = strcmp (players[0].login, players[1].login)) == 0)
X		cmp = strcmp (players[0].machine, players[1].machine);
X
X	master  = (cmp <= 0) ? True : False;
X
X	if (master == True) {
X		machine = players[0].machine;
X		port    = players[0].login;
X
X		printf ("Waiting for response from \"%s@%s\"...",
X			players[1].login, players[1].machine);
X		fflush (stdout);
X		if ((fd = make_socket (machine, port)) < 0) {
X			if (cmp != 0)
X				perror_exit ("Cannot setup communications channel to opponent");
X			master = False;
X		}
X	}
X
X	if (master == False) {
X		machine = players[1].machine;
X		port    = players[1].login;
X
X		printf ("Connecting to \"%s@%s\"...", port, machine);
X		fflush (stdout);
X		if ((fd = connect_socket (machine, port)) < 0)
X			perror_exit ("Cannot setup communications channel to opponent");
X	}
X
X	printf ("\n\nConnected.\n");
X	fflush (stdout);
X
X	if (master == False) {
X		read_data (fd, new_port, sizeof (new_port));
X		close (fd);
X
X		start = time (NULL);
X		do {
X			fd = connect_socket (machine, new_port);
X		} while (fd == -1 && time (NULL) < start + 5);
X
X		if (fd == -1)
X			perror_exit ("Cannot reconnect to opponent");
X
X		write_player_data (fd, &players[0]);
X		read_player_data  (fd, &players[1]);
X		players[0].has_first_move = !players[1].has_first_move;
X	}
X	else {
X		sprintf (new_port, "comm%u", time(0));
X		write_data (fd, new_port, sizeof (new_port));
X		close (fd);
X
X		if ((fd = make_socket (machine, new_port)) < 0)
X			perror_exit ("Cannot recontact opponent");
X
X		srand ((time (NULL) ^ getpid ()) >> 3);
X		players[0].has_first_move = (rand () >> 4) & 0x01;
X
X		read_player_data  (fd, &players[1]);
X		write_player_data (fd, &players[0]);
X	}
X
X	players[1].fd = fd;
X
X	signal (SIGIO, SIG_IGN);
X	fcntl (fd, F_SETFL, FASYNC);
X	fcntl (fd, F_SETOWN, getpid ());
X}
X
Xstatic void read_player_data (fd, player)
Xint fd;
XPLAYER *player;
X{
X	read_data (fd, player->name,	sizeof (player->name));
X	read_data (fd, player->login,	sizeof (player->login));
X	read_data (fd, player->machine,	sizeof (player->machine));
X	read_data (fd, player->domain,	sizeof (player->domain));
X	read_data (fd, &player->has_first_move, sizeof (player->has_first_move));
X}
X
Xstatic void write_player_data (fd, player)
Xint fd;
XPLAYER *player;
X{
X	write_data (fd, player->name,	 sizeof (player->name));
X	write_data (fd, player->login,	 sizeof (player->login));
X	write_data (fd, player->machine, sizeof (player->machine));
X	write_data (fd, player->domain,	 sizeof (player->domain));
X	write_data (fd, &player->has_first_move, sizeof(player->has_first_move));
X}
X
Xstatic void read_data (fd, output, length)
Xint fd, length;
Xchar *output;
X{
X	int bytes;
X
X	if ((bytes = read (fd, output, length)) != length) {
X		fprintf (stderr, "Read %d instead of %d bytes.\n", bytes,
X			 length);
X		perror_exit ("read_data: read()");
X	}
X}
X
Xstatic void write_data (fd, input, length)
Xint fd, length;
Xchar *input;
X{
X	while (length > 0) {
X		int r, persist = 30;
X
X		while ((r = write (fd, input, length)) < 0) {
X			if (--persist == 0)
X				perror_exit ("write_data: write()");
X			sleep (2);
X		}
X		input  += r;
X		length -= r;
X	}
X}
END_OF_FILE
if test 6060 -ne `wc -c <'socket.c'`; then
    echo shar: \"'socket.c'\" unpacked with wrong size!
fi
# end of 'socket.c'
fi
if test -f 'stratego.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stratego.h'\"
else
echo shar: Extracting \"'stratego.h'\" \(2621 characters\)
sed "s/^X//" >'stratego.h' <<'END_OF_FILE'
X/*
X * Stratego.h
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <sys/param.h>
X
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X
X#include <X11/Xaw/AsciiText.h>
X#include <X11/Xaw/Cardinals.h>
X#include <X11/Xaw/Label.h>
X#include <X11/Xaw/Command.h>
X#include <X11/Xaw/Box.h>
X#include <X11/Xaw/Form.h>
X#include <X11/Xaw/Dialog.h>
X
X#include "tiles.h"
X
X#define XDISPLAY	XtDisplay (Toplevel)
X#define XSCREEN		DefaultScreen (XDISPLAY)
X#define XROOTWINDOW	RootWindowOfScreen (XtScreen (Toplevel))
X#define XWINDOW		XtWindow (Toplevel)
Xextern XtAppContext app_con;
Xextern XtInputId EnemyID;
Xextern Widget Toplevel, Stratego, Board, Tiles, Message;
X
X/*
X * Dialog widget interface
X */
X#define ADD_CANCEL	0
X#define NO_CANCEL	1
Xextern Bool DialogBoxResult();
X
Xtypedef struct s_button {
X	char *label;
X	XtCallbackProc (*callback) ();
X	Boolean sensitive;
X	Widget widget;
X} BUTTON;
X
Xtypedef struct s_board_pos {
X	Widget widget;
X	int owner;
X	int value;
X	int y, x;
X} BOARD_POS;
X
X#define MAX_ROWS	10
X#define MAX_COLS	10
X
X#define O_NOBODY	0
X#define O_PLAYER	1
X#define O_ENEMY		2
X
Xextern BOARD_POS board[MAX_ROWS][MAX_COLS];
X
X#define DO_MOVE		0	/* Move results */
X#define UNDO_MOVE	1
X#define WIN_MOVE	2
X#define REMISE_MOVE	3
X
X/*
X * Player status.
X */
X#define PL_SETUP	0
X#define PL_SETUP_READY	1	/* Setting up board below this value */
X#define PL_READY	2
X#define PL_ENDGAME	3
X#define PL_PLAYING	4	/* Playing mode activated after this value */
X#define PL_PICKED_UP	5
X
X#define REMISE_ACCEPTED		1
X#define REMISE_DECLINED		2
X
X#define NAME_LENGTH	80
X#define LOGIN_LENGTH	10
X
Xtypedef struct s_player {
X	char name[NAME_LENGTH];
X  	char login[LOGIN_LENGTH];
X  	char machine[MAXHOSTNAMELEN];
X  	char domain[NAME_LENGTH];
X  	int fd;				/* For player to player comm. */
X	Boolean	setup_only;		/* If not playing but making board */
X	char has_first_move;		/* Only for player 0 */
X	int status;
X	int tile_select;
X	BOARD_POS *from_pos, *to_pos;	/* Move record holders */
X	TILE *to_tile;	
X	int to_owner;
X	Boolean confirm;
X} PLAYER;
X
Xextern PLAYER players[2];
X
X/*
X * Funny messages (buzz module) on illegal moves.
X */
X#include "buzz.h"
X#define display_error(table)	message (buzz (table))
X
X#define abs(x)	((x < 0) ? -(x) : (x))
X
X/*
X * Callbacks.
X */
Xextern XtCallbackProc WipeCursor (), Clear (), Load (), Store (), Ready (),
X		      Quit (), Mail ();
X#ifdef DEBUG
Xextern XtCallbackProc Debug ();
X#endif
Xextern XtCallbackProc SelectSetupBoardCursor (), ActivateBoardPosition ();
X
Xextern XtInputCallbackProc EnemyInterrupt ();
Xextern XtActionHookProc ButtonPressHook ();
X
X
Xextern void place_button_box (), message (), end_game ();
X
END_OF_FILE
if test 2621 -ne `wc -c <'stratego.h'`; then
    echo shar: \"'stratego.h'\" unpacked with wrong size!
fi
# end of 'stratego.h'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
