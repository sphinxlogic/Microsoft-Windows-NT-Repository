Path: uunet!ogicse!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v15i011:  xstratego - X Windows stratego interface for two players, Part01/04
Message-ID: <3816@master.CNA.TEK.COM>
Date: 26 Oct 92 23:51:50 GMT
Article-I.D.: master.3816
Sender: news@master.CNA.TEK.COM
Lines: 2029
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1510

Submitted-by: Henk-Jan Visscher <hjvissc@cs.vu.nl>
Posting-number: Volume 15, Issue 11
Archive-name: xstratego/Part01
Environment: X11, Xaw


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 4)."
# Contents:  README MANIFEST Makefile.std dialog.c icons main.c play.c
#   setup.c xstratego.6
# Wrapped by billr@saab on Mon Oct 26 15:47:07 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(276 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
XXstratego is a X windows based stratego interface for two players.
XYou can either play against another player (on the same or different host)
Xor create a board setup for later use.
X
XThe man page includes a summary of the Stratego rules, in case you haven't
Xplayed in awhile.
END_OF_FILE
if test 276 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2255 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Imakefile                  2	
X MANIFEST                   1	This shipping list
X Makefile                   4	
X Makefile.std               1	
X README                     1	
X buzz.c                     2	
X buzz.h                     4	
X callback.c                 2	
X dialog.c                   1	
X icons                      1	
X icons/account_cursor.h     4	
X icons/account_cursor_mask.h  4	
X icons/board_cursor.h       4	
X icons/board_cursor_mask.h  4	
X icons/boat_cursor.h        4	
X icons/boat_cursor_mask.h   4	
X icons/bomb.h               3	
X icons/bomb_mask.h          3	
X icons/bomb_s.h             3	
X icons/c.c                  4	
X icons/captain.h            3	
X icons/captain_mask.h       2	
X icons/captain_s.h          3	
X icons/colonel.h            3	
X icons/colonel_mask.h       2	
X icons/colonel_s.h          3	
X icons/enemy.h              3	
X icons/enemy_mask.h         2	
X icons/enemy_s.h            3	
X icons/flag.h               3	
X icons/flag_mask.h          3	
X icons/flag_s.h             3	
X icons/free.h               3	
X icons/free_mask.h          3	
X icons/free_s.h             3	
X icons/general.h            3	
X icons/general_mask.h       2	
X icons/general_s.h          3	
X icons/lieutenant.h         2	
X icons/lieutenant_mask.h    2	
X icons/lieutenant_s.h       3	
X icons/major.h              3	
X icons/major_mask.h         2	
X icons/major_s.h            3	
X icons/marshal.h            3	
X icons/marshal_mask.h       2	
X icons/marshal_s.h          3	
X icons/miner.h              3	
X icons/miner_mask.h         2	
X icons/miner_s.h            3	
X icons/scout.h              3	
X icons/scout_mask.h         2	
X icons/scout_s.h            3	
X icons/sergeant.h           3	
X icons/sergeant_mask.h      2	
X icons/sergeant_s.h         3	
X icons/spy.h                3	
X icons/spy_mask.h           3	
X icons/spy_s.h              4	
X init.c                     2	
X main.c                     1	
X message.c                  2	
X play.c                     1	
X register.c                 2	
X setup.c                    1	
X socket.c                   2	
X stratego.h                 2	
X tiles.h                    3	
X xstratego.6                1	
END_OF_FILE
if test 2255 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile.std' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.std'\"
else
echo shar: Extracting \"'Makefile.std'\" \(10382 characters\)
sed "s/^X//" >'Makefile.std' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.69 91/09/09 18:23:59 rws Exp $
X
X# operating system:  SunOS 4.1.1
X
X# $XConsortium: sunLib.rules,v 1.6 91/03/24 17:55:58 rws Exp $
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.137 91/07/30 22:57:01 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/lib
X           BINDIR = /usr/bin/X11
X          INCROOT = /usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X	        MANPATH = /usr/man:/usr/local/man
X	   MANSOURCEPATH = $(MANPATH)/man
X	       MANSUFFIX = 1
X	    LIBMANSUFFIX = 3
X	          MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X	       LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X	          NLSDIR = $(LIBDIR)/nls
X	       PEXAPIDIR = $(LIBDIR)/PEX
X	     XAPPLOADDIR = $(LIBDIR)/app-defaults
X	      FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X# $XConsortium: sunLib.tmpl,v 1.11 91/07/31 11:32:08 rws Exp $
X
XSHLIBLDFLAGS = -assert pure-text
XPICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
XLOCAL_LIBRARIES = $(XAWLIB) $(XMULIB) $(XTOOLLIB) $(XLIB)
X	DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
XSRCS = buzz.c callback.c dialog.c init.c main.c message.c play.c register.c setup.c socket.c
XOBJS = buzz.o callback.o dialog.o init.o main.o message.o play.o register.o setup.o socket.o
X
X PROGRAM = stratego
X
Xall:: stratego
X
Xstratego: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xsaber_stratego:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xosaber_stratego:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xinstall:: stratego
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  stratego $(DESTDIR)$(BINDIR)
X
Xinstall.man:: stratego.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) stratego.man $(DESTDIR)$(MANDIR)/stratego.$(MANSUFFIX)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	# load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	# load $(ALLDEFINES) $(OBJS)
X
X# -------------------------------------------------------------------------
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
if test 10382 -ne `wc -c <'Makefile.std'`; then
    echo shar: \"'Makefile.std'\" unpacked with wrong size!
fi
# end of 'Makefile.std'
fi
if test -f 'dialog.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dialog.c'\"
else
echo shar: Extracting \"'dialog.c'\" \(2998 characters\)
sed "s/^X//" >'dialog.c' <<'END_OF_FILE'
X/*
X * Dialog.c
X */
X
X#include "stratego.h"
X
X#define CHAR_WIDTH(f)	((f)->max_bounds.rbearing - (f)->min_bounds.lbearing -2)
X#define CHAR_HEIGHT(f)	((f)->max_bounds.ascent + (f)->max_bounds.descent - 2)
X
X#define max(a, b)	((a) > (b) ? (a) : (b))
X
X#define DIALOG_OK		0
X#define DIALOG_CANCEL		1
X#define DIALOG_UNDECIDED	2
X
Xstatic int dialog_status;
X
Xstatic XtCallbackProc DialogOk ()
X{
X	dialog_status = DIALOG_OK;
X}
X
Xstatic XtCallbackProc DialogCancel ()
X{
X	dialog_status = DIALOG_CANCEL;
X}
X
XBool DialogBoxResult (prompt, input_buffer, edit_length, cancel_fl)
Xchar *prompt, *input_buffer;
Xint edit_length, cancel_fl;
X{
X	Widget Popupshell, Dialog, Editfield;
X	Dimension width, twidth, theight, dwidth;
X	XFontStruct *font;
X	XEvent event;
X	Dimension right_margin, left_margin;
X	Position x, y;
X	Arg args[3];
X	int argc;
X
X	Popupshell = XtCreatePopupShell ("PopupShell", overrideShellWidgetClass,
X					 Toplevel, NULL, ZERO);
X
X	XtSetArg (args[0], XtNlabel, prompt);
X	argc = 1;
X
X	if (input_buffer != NULL) {
X		if (strlen (input_buffer) > edit_length)
X			edit_length = strlen (input_buffer);
X		XtSetArg (args[1], XtNvalue, input_buffer);
X		argc = 2;
X	}
X	Dialog = XtCreateManagedWidget ("Popup", dialogWidgetClass,
X					Popupshell, args, argc);
X
X	XawDialogAddButton (Dialog, "   OK   ", DialogOk, NULL);
X	if (cancel_fl == ADD_CANCEL)
X		XawDialogAddButton (Dialog, " CANCEL ", DialogCancel, NULL);
X
X	font = NULL;
X	XtSetArg (args[0], XtNfont, &font);
X	XtGetValues (Dialog, args, 1);
X	if (font != NULL)
X		dwidth = CHAR_WIDTH (font) * strlen(prompt);
X	else
X		dwidth = 150;
X
X	if (edit_length > 0) {
X		Editfield = XtNameToWidget (Dialog, "value");
X		XtSetArg (args[0], XtNfont, &font);
X		XtSetArg (args[1], XtNrightMargin, &right_margin);
X		XtSetArg (args[2], XtNleftMargin, &left_margin);
X		XtGetValues (Editfield, args, 3);
X		width = right_margin + left_margin +
X			CHAR_WIDTH (font) * edit_length;
X
X		XtSetArg (args[0], XtNwidth, width);
X		XtSetValues (Editfield, args, 1);
X
X		dwidth = max (dwidth, width);
X	}
X
X/* Position Dialog box in center of application */
X	XtSetArg (args[0], XtNwidth, &twidth);
X	XtSetArg (args[1], XtNheight, &theight);
X	XtGetValues (Board, args, 2);
X
X	XtTranslateCoords (Board, (Position) (twidth - dwidth) / 2,
X				     (Position) (theight - 58) / 2, &x, &y);
X	
X	XtMoveWidget (Popupshell, x, y);
X	XtPopup (Popupshell, XtGrabExclusive);
X
X	dialog_status = DIALOG_UNDECIDED;
X
X	do {
X		XtAppNextEvent (app_con, &event);
X		XtDispatchEvent (&event);
X	} while (dialog_status == DIALOG_UNDECIDED);
X
X	if (input_buffer != NULL)
X		strcpy (input_buffer, XawDialogGetValueString(Dialog));
X
X	XtPopdown (Popupshell);
X	XtDestroyWidget (Dialog);
X	
X	if (dialog_status == DIALOG_CANCEL) {
X		message ("Operation cancelled.");
X		return False;
X	}
X
X	return True;
X}
X
X
X/*
X * Dialog value box Return Key redefinition.
X */
Xstatic XtActionsRec actions[] = {
X	{ "DialogOk", 	(void (*)()) DialogOk }
X};
X
Xvoid init_dialog ()
X{
X	XtAppAddActions (XtWidgetToApplicationContext (Toplevel),
X			 actions, XtNumber (actions));
X}
END_OF_FILE
if test 2998 -ne `wc -c <'dialog.c'`; then
    echo shar: \"'dialog.c'\" unpacked with wrong size!
fi
# end of 'dialog.c'
fi
if test ! -d 'icons' ; then
    echo shar: Creating directory \"'icons'\"
    mkdir 'icons'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(8622 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/*
X * Main.c
X */
X
X#include "stratego.h"
X
XXtAppContext app_con;
XXtInputId EnemyID;
XWidget Toplevel, Stratego, Board, Tiles, Message;
X
Xstatic void init_actions ();
Xvoid new_button_box ();
X
Xstatic String fallback_resources[] = { 
X	"*PopupShell.allowShellResize:  True",
X	"*PopupShell.borderWidth:       4",
X	"*PopupShell.Dialog*shapeStyle: oval",
X	"*PopupShell.Dialog.value.translations: #override \\n \
X						<Key>Return: DialogOk()",
X	"*Board.borderWidth: 		    4",
X	"*Board.defaultDistance: 	    1",
X
X	"*Water.highlightThickness: 	    0",
X
X	"*BoardPosition.highlightThickness: 0",
X
X	"*Tiles.borderWidth: 		    2",
X	"*Tiles.defaultDistance: 	    2",
X	"*TilePosition.orientation:	    horizontal",
X
X	"*TileBitmap.borderWidth:	    0",
X	"*TileBitmap.highlightThickness:    1",
X
X	"*ButtonSet.borderWidth:	    0",
X	"*ButtonSet.defaultDistance:	    10",
X
X	"*Button.shapeStyle:		    oval",
X
X	"*Message.resizable:		    True",
X	"*Message.borderWidth:		    0",
X	"*translations:			    #augment \\n \
X					    <Btn2Down>: CaughtByHook() \\n \
X					    <Btn3Down>: CaughtByHook()",
X	NULL
X};
X
Xstatic BUTTON setup_buttons[] = {
X	" Cursor  ", WipeCursor, TRUE, NULL,
X	"  Load   ", Load,	 TRUE, NULL,
X	"  Ready  ", Ready,	 TRUE, NULL,
X	" Message ", Mail,	 TRUE, NULL,
X	"  Clear  ", Clear,	 TRUE, NULL,
X	"  Store  ", Store,	 TRUE, NULL,
X	"   Quit  ", Quit,	 TRUE, NULL,
X#ifdef DEBUG
X	"  Debug  ", Debug,	 TRUE, NULL,
X#endif
X};
X
Xstatic void create_board (), create_tiles ();
XBOARD_POS board[MAX_ROWS][MAX_COLS];
XPLAYER players[2];
X
Xstatic void Usage()
X{
X	fprintf (stderr, "Usage: xstratego opponent@machine <Your name>.\n");
X	fprintf (stderr, "       or xstratego -s to set up a board.\n");
X	exit (1);
X}
X
Xmain (argc, argv)
Xint argc;
Xchar *argv[];
X{
X	Arg args[2];
X	char *at_sym;
X	char name_buf[100];
X	int i;
X
X	Toplevel = XtAppInitialize (&app_con, "Xstratego", NULL, ZERO,
X				    &argc, argv, fallback_resources, NULL,ZERO);
X
X	if (argc == 2 && !strcmp (argv[1], "-s")) {
X		strcpy (players[0].name, "Nobody");
X		players[0].setup_only = TRUE;
X
X		for (i = 0; i < XtNumber(setup_buttons); i++) {
X			if (setup_buttons[i].callback == Ready || 
X					      setup_buttons[i].callback == Mail)
X				setup_buttons[i].sensitive = FALSE;
X		}
X	}
X	else if (argc == 3 && (at_sym = strchr (argv[1], '@')) != NULL) {
X		*at_sym++ = '\0';
X		setup_communication (argv[2], argv[1], at_sym);
X	}
X	else
X		Usage ();
X
X	Stratego = XtCreateManagedWidget ("Stratego", formWidgetClass, Toplevel,
X					  NULL, ZERO);
X
X	XtSetArg (args[0], XtNlabel, "  ");
X	Message = XtCreateManagedWidget ("Message", labelWidgetClass, Stratego,
X					 args, 1);
X
X	init_icons ();
X	init_board ();
X	init_dialog ();
X	init_actions ();
X
X	create_board (Stratego);
X	create_tiles (Stratego);
X
X	new_button_box (setup_buttons, XtNumber(setup_buttons));
X	
X	XtSetArg (args[0], XtNfromHoriz, NULL);
X	XtSetArg (args[1], XtNfromVert, NULL);
X	XtSetValues (Board, args, 2);
X
X	XtSetArg (args[0], XtNfromHoriz, Board);
X	XtSetArg (args[1], XtNfromVert, NULL);
X	XtSetValues (Tiles, args, 2);
X
X	XtSetArg (args[0], XtNfromHoriz, NULL);
X	XtSetArg (args[1], XtNfromVert, Board);
X	XtSetValues (Message, args, 2);
X
X	if (players[0].setup_only == FALSE) {
X		sprintf (name_buf, "Stratego (%s) [%s@%s.%s]", players[0].name,
X			 players[0].login, players[0].machine,
X			 players[0].domain);
X		EnemyID = XtAppAddInput (app_con, players[1].fd,
X					 XtInputReadMask,
X					 EnemyInterrupt, NULL);
X	}
X	else
X		strcpy (name_buf, "Stratego (Setup Board)");
X
X	XtSetArg (args[0], XtNtitle, name_buf);
X	XtSetValues (Toplevel, args, 1);
X
X	XtRealizeWidget (Toplevel);
X	XtAppMainLoop (app_con);
X}
X
Xstatic void CaughtByHook()
X{
X	/* Action already done by action hook proecedure "ButtonPressHook" */
X}
X
Xstatic XtActionsRec default_actions[] = {
X	"CaughtByHook",	CaughtByHook
X};
X
Xstatic void init_actions ()
X{
X	XtAppAddActions (app_con, default_actions, XtNumber (default_actions));
X	XtAppAddActionHook (app_con, ButtonPressHook, NULL);
X}
X
Xstatic Widget Underneath (y, x)
Xint y, x;
X{
X	if (y == 0)
X		return NULL;
X	
X	if (y == 6 && (x == 2 || x == 3 || x == 6 || x == 7))
X		return board[4][x & ~0x01].widget;
X	
X	return board[y - 1][x].widget;
X}
X
Xstatic Widget Nextto (y, x)
Xint y, x;
X{
X	if (x == 0)
X		return NULL;
X	
X	if ((y == 4 || y == 5) && (x == 4 || x == 8))
X		return board[4][x - 2].widget;
X	
X	return board[y][x - 1].widget;
X}
X
Xstatic void create_water (parent, y, x)
XWidget parent;
Xint y, x;
X{
X	Dimension wg_width, wg_height, wg_borderwidth;
X	int df_distance, height, width;
X	Arg args[5];
X
X	XtSetArg (args[0], XtNdefaultDistance, &df_distance);
X	XtGetValues (parent, args, 1);
X
X	XtSetArg (args[0], XtNwidth, &wg_width);
X	XtSetArg (args[1], XtNheight, &wg_height);
X	XtSetArg (args[2], XtNborderWidth, &wg_borderwidth);
X	XtGetValues (board[0][0].widget, args, 3);
X
X	width  = df_distance + 2 * (wg_width  + wg_borderwidth);
X	height = df_distance + 2 * (wg_height + wg_borderwidth);
X
X	XtSetArg (args[0], XtNwidth, width);
X	XtSetArg (args[1], XtNheight, height);
X	XtSetArg (args[2], XtNcursor, tiles[BOAT_CURSOR].cursor);
X	XtSetArg (args[3], XtNfromVert, board[y - 1][x].widget);
X	XtSetArg (args[4], XtNfromHoriz, board[y][x - 1].widget);
X
X	board[y][x].widget = XtCreateManagedWidget ("Water", commandWidgetClass,
X						    parent, args, 5);
X
X	XtAddCallback (board[y][x].widget, XtNcallback,
X		       ActivateBoardPosition, &board[y][x]);
X}
X
Xstatic void create_board (parent)
XWidget parent;
X{
X	Arg args[4];
X	int x, y;
X
X	Board = XtCreateManagedWidget ("Board", formWidgetClass, parent,
X				       NULL, ZERO);
X
X	XtSetArg (args[0], XtNbitmap, tiles[FREE].pixmap);
X	XtSetArg (args[1], XtNcursor, tiles[BOARD_CURSOR].cursor);
X	for (y = 0; y < MAX_ROWS; y++) {
X		for (x = 0; x < MAX_COLS; x++) {
X			if (board[y][x].value == WATER) {
X				if (y == 4 && (x == 2 || x == 6))
X					create_water (Board, y, x);
X				continue;
X			}
X
X			XtSetArg (args[2], XtNfromVert, Underneath (y, x));
X			XtSetArg (args[3], XtNfromHoriz, Nextto (y, x));
X			board[y][x].widget = XtCreateManagedWidget (
X						"BoardPosition",
X						 commandWidgetClass,
X						 Board, args, 4);
X
X			XtAddCallback (board[y][x].widget, XtNcallback,
X				       ActivateBoardPosition, &board[y][x]);
X
X			board[y][x].y = y;
X			board[y][x].x = x;
X		}
X	}
X}
X
Xstatic void create_tiles (parent)
XWidget parent;
X{
X	Arg box_args[3], command_args[2], label_args[1];
X	int i;
X
X	Tiles = XtCreateManagedWidget ("Tiles", formWidgetClass, parent,
X				       NULL, ZERO);
X
X	XtSetArg (box_args[0],    XtNcursor, tiles[ACCOUNT_CURSOR].cursor);
X	XtSetArg (command_args[0], XtNcursor, tiles[ACCOUNT_CURSOR].cursor);
X
X	for (i = FLAG; i <= BOMB; i++) {
X		XtSetArg (box_args[1], XtNfromVert,
X			  (i == FLAG || i == LIEUTENANT) ? NULL : 
X						tiles[i - 1].box_widget);
X		XtSetArg (box_args[2], XtNfromHoriz,
X			  (i < LIEUTENANT) ? NULL :
X				tiles[i - (LIEUTENANT - FLAG)].box_widget);
X		tiles[i].box_widget = XtCreateManagedWidget ("TilePosition",
X							     boxWidgetClass,
X							     Tiles, box_args,3);
X
X		XtSetArg (command_args[1], XtNbitmap, tiles[i].pixmap);
X		tiles[i].bitmap_widget = XtCreateManagedWidget ("TileBitmap",
X						commandWidgetClass,
X						tiles[i].box_widget,
X						command_args, 2);
X		XtAddCallback (tiles[i].bitmap_widget, XtNcallback, 
X			       SelectSetupBoardCursor, &tiles[i]);
X
X		XtSetArg (label_args[0], XtNlabel, "   ");
X		tiles[i].count_widget = XtCreateManagedWidget ("TileCount",
X					      labelWidgetClass, 
X					      tiles[i].box_widget,
X					      label_args, 1);
X		UpdateTileCount (&tiles[i], 0);
X	}
X}
X
Xvoid new_button_box (list, nr_buttons)
XBUTTON *list;
Xint nr_buttons;
X{
X	static BUTTON *prev_set;
X	static int prev_nr_buttons;
X	static Widget ButtonSet;
X	Arg args[3];
X	int i, split;
X
X	if (prev_set != (BUTTON *) 0) {
X		for (i = 0; i < prev_nr_buttons; i++) {
X			XtUnmanageChild (prev_set[i].widget);
X			XtDestroyWidget (prev_set[i].widget);
X		}
X	}
X	else {
X		XtSetArg (args[0], XtNfromHoriz, Board);
X		XtSetArg (args[1], XtNfromVert,  Tiles);
X		ButtonSet = XtCreateManagedWidget ("ButtonSet", formWidgetClass,
X						   Stratego, args, 2);
X	}
X
X	prev_set = list;
X	prev_nr_buttons = nr_buttons;
X
X	split = (nr_buttons + 1) / 2;
X	for (i = 0; i < nr_buttons; i++) {
X		XtSetArg (args[0], XtNlabel, list[i].label);
X		XtSetArg (args[1], XtNfromHoriz,
X				   (i < split) ? NULL : list[i - split].widget);
X		XtSetArg (args[2], XtNfromVert,
X				   (i % split) ? list[i - 1].widget : NULL);
X		list[i].widget = XtCreateManagedWidget ("Button",
X							commandWidgetClass,
X							ButtonSet, args, 3);
X		if (list[i].callback)
X			XtAddCallback (list[i].widget, XtNcallback, 
X				       list[i].callback, NULL);
X		if (list[i].sensitive == FALSE)
X			XtSetSensitive(list[i].widget, FALSE);
X	}
X}
END_OF_FILE
if test 8622 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'play.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'play.c'\"
else
echo shar: Extracting \"'play.c'\" \(8802 characters\)
sed "s/^X//" >'play.c' <<'END_OF_FILE'
X/*
X * Play.c
X */
X
X#include "stratego.h"
X
Xstatic void announce_loser ();
Xvoid check_can_play ();
X
X/*
X * Remise Button Callback Routine.
X */
Xstatic Widget remise_button_widget = NULL;
X
Xvoid EnableRemiseButton()
X{
X	if (remise_button_widget != NULL) {
X		XtSetSensitive(remise_button_widget, True);
X		remise_button_widget = NULL;
X	}
X}
X
Xstatic XtCallbackProc Remise (widget)
XWidget widget;
X{
X	remise_button_widget = widget;
X
X	XtSetSensitive (widget, FALSE);
X
X	send_remise_offer ();
X
X	message ("On its way...");
X}
X
X/*
X * Incoming remise offer.
X */
Xvoid RemiseOffered ()
X{
X	char msg_buf[100];
X
X	sprintf (msg_buf, "%s offers a Remise. Do you accept %s?",
X		 players[1].name, players[0].name);
X
X	if (DialogBoxResult (msg_buf, NULL, 0, ADD_CANCEL) == True) {
X		send_remise_answer (REMISE_ACCEPTED);
X		end_game ();
X	}
X	else
X		send_remise_answer (REMISE_DECLINED);
X}
X
X/*
X * GiveUp button
X */
Xstatic XtCallbackProc GiveUp (widget)
XWidget widget;
X{
X	if (DialogBoxResult ("Loser!", NULL, 0, ADD_CANCEL) == True) {
X		send_quit ();
X		message ("You surrender unconditionally to %s...",
X			 players[1].name);
X		end_game ();
X	}
X}
X
X
X/*
X * Play module.
X */
Xstatic BUTTON play_buttons[] = {
X	" Remise  ", Remise,    TRUE, NULL,
X	" Message ", Mail,      TRUE, NULL,
X	" Give Up ", GiveUp,    TRUE, NULL,
X};
X
Xvoid start_play ()
X{
X	int i;
X
X	players[players[0].has_first_move ? 0 : 1].status = PL_PLAYING;
X
X	new_button_box (play_buttons, XtNumber(play_buttons));
X
X	if (players[0].has_first_move) {
X		players[0].status = PL_PLAYING;
X		message ("It is your move %s!", players[0].name);
X		check_can_play (O_PLAYER);
X	}
X	else {
X		message ("It is %s'%s move %s!", players[1].name, 
X			(players[1].name[strlen (players[1].name) - 1] == 's') ? "" : "s", players[0].name);
X		check_can_play (O_ENEMY);
X	}
X	
X	for (i = FLAG; i <= BOMB; i++)
X		UpdateTileCount (&tiles[i], tiles[i].available);
X}
X
Xstatic Boolean legal_movement (from_pos, to_pos)
XBOARD_POS *from_pos, *to_pos;
X{
X	int y, x, dx, dy, dist_x, dist_y;
X	int from_x, from_y;
X	int legal;
X
X	from_x = from_pos->x;
X	from_y = from_pos->y;
X	y = to_pos->y;
X	x = to_pos->x;
X
X	dx = ((dist_x = from_x - x) < 0) ? 1 : -1;
X	dy = ((dist_y = from_y - y) < 0) ? 1 : -1;
X
X	if ((dist_x && dist_y) || (dist_x == 0 && dist_y == 0))
X		return False;
X
X	legal = 1;
X
X	if (abs (dist_x) > 1 || abs (dist_y) > 1) {
X		if (from_pos->value != SCOUT)
X			return False;
X
X		if (dist_x != 0) {	/* Horizontal movement */
X			do {
X				from_x += dx;
X				legal = (board[from_y][from_x].value == FREE);
X			} while (from_x != x && legal);
X		}
X		else if (dist_y != 0) {	/* Vertical movement */
X			do {
X				from_y += dy;
X				legal = (board[from_y][from_x].value == FREE);
X			} while (from_y != y && legal);
X		}
X	}
X
X	return legal ? True : False;
X}
X
Xvoid play_tile (board_pos)
XBOARD_POS *board_pos;
X{
X	BOARD_POS *from_pos = players[0].from_pos;
X
X	if (players[0].status == PL_PLAYING) {
X		if (board_pos->value == FREE)
X			display_error (move_empty);
X		else if (board_pos->value == WATER)
X			display_error (illegal);
X		else if (board_pos->owner == O_ENEMY)
X			display_error (move_opponent);
X		else if (board_pos->value == FLAG)
X			display_error (move_flag);
X		else if (board_pos->value == BOMB)
X			display_error (move_bomb);
X		else {
X			players[0].status   = PL_PICKED_UP;
X			players[0].from_pos = board_pos;
X			MarkBoardPosition (board_pos, True);
X		}
X	}
X	else if (players[0].status == PL_PICKED_UP) {
X		if (board_pos->value == WATER)
X			display_error (in_water);
X		else if (board_pos == from_pos)
X			;
X		else if (board_pos->owner == O_PLAYER)
X			display_error (kill_own);
X		else if (board_pos->value == FREE || board_pos->owner==O_ENEMY){
X			if (legal_movement (from_pos, board_pos)) {
X				switch (execute_move (from_pos, board_pos)) {
X				case DO_MOVE:
X					send_move (from_pos, board_pos);
X					players[0].status = PL_READY;
X					check_can_play (O_ENEMY);
X					break;
X				case REMISE_MOVE:
X				case WIN_MOVE:
X					send_move (from_pos, board_pos);
X					end_game ();
X				case UNDO_MOVE:
X					players[0].status = PL_PLAYING;
X					break;
X				}
X				return;
X			}
X
X			display_error (illegal);
X		}
X
X	/* Cancel move */
X		if (players[0].status == PL_PICKED_UP)
X			MarkBoardPosition (from_pos, False);
X
X		players[0].status = PL_PLAYING;
X
X	}
X}
X
Xvoid ConfirmMove ()
X{
X	AssignBoardPosition (players[0].from_pos, &tiles[FREE], O_NOBODY);
X	AssignBoardPosition (players[0].to_pos, players[0].to_tile,
X			     players[0].to_owner);
X
X	players[0].confirm = False;
X}
X
Xint execute_move (from_pos, to_pos)
XBOARD_POS *from_pos, *to_pos;
X{
X	TILE *from_tile, *to_tile;
X	int winner, move_type;
X
X	if (players[0].confirm)
X		ConfirmMove ();
X
X	players[0].from_pos = from_pos;
X	players[0].to_pos   = to_pos;
X
X	from_tile = &tiles[from_pos->value];
X	to_tile   = &tiles[to_pos->value];
X
X	if (to_pos->owner == O_NOBODY) {
X	/* Player move */
X		if (from_pos->owner == O_PLAYER) {
X			AssignBoardPosition (from_pos, &tiles[FREE], O_NOBODY);
X			AssignBoardPosition (to_pos, from_tile, O_PLAYER);
X
X			move_type = register_board (O_PLAYER);
X			if (move_type == UNDO_MOVE) {
X				AssignBoardPosition (from_pos, from_tile,
X						     O_PLAYER);
X				AssignBoardPosition (to_pos, &tiles[FREE],
X						     O_NOBODY);
X			}
X
X			return move_type;
X		}
X
X	/* Enemy move */
X		players[0].to_owner = from_pos->owner;
X		players[0].to_tile  = from_tile;
X		players[0].confirm  = True;
X
X	/* Show move on board */
X		AssignBoardPosition (from_pos, &tiles[ENEMY], from_pos->owner);
X		AssignBoardPosition (to_pos,   &tiles[ENEMY], from_pos->owner);
X		MarkBoardPosition (from_pos, True);
X		MarkBoardPosition (to_pos,   True);
X
X	/* Fill in right board values to register board setup */
X		from_pos->owner = O_NOBODY;
X		from_pos->value = tiles[FREE].value;
X		to_pos->owner   = O_ENEMY;
X		to_pos->value   = from_tile->value;
X
X		return register_board (O_ENEMY);
X	}
X
X/* Battle stations */
X	MarkBoardPosition (from_pos, True);
X	MarkBoardPosition (to_pos,   True);
X
X	if (to_tile->value == FLAG) {
X		UpdateTileCount (&tiles[FLAG], -1);
X		announce_loser (to_pos->owner);
X		return WIN_MOVE;
X	}
X
X	players[0].confirm = True;
X
X	if ((from_tile->value == SPY   && to_tile->value == MARSHAL) ||
X	    (from_tile->value == MINER && to_tile->value == BOMB) ||
X	    (from_tile->value < to_tile->value && to_tile->value != BOMB)) {
X		players[0].to_owner = from_pos->owner;
X		players[0].to_tile  = from_tile;
X		if ((winner = from_pos->owner) == O_PLAYER)
X			UpdateTileCount (to_tile, -1);
X	}
X	else if (to_tile->value == from_tile->value) {
X		players[0].to_owner = O_NOBODY;
X		players[0].to_tile  = &tiles[FREE];
X		winner = (time (NULL) & 0x01) ? O_PLAYER : O_ENEMY;
X		UpdateTileCount (to_tile, -1);
X	}
X	else {
X		players[0].to_owner = to_pos->owner;
X		players[0].to_tile  = to_tile;
X		winner = to_pos->owner;
X		if ((winner = to_pos->owner) == O_PLAYER)
X			UpdateTileCount (from_tile, -1);
X	}
X
X	display_error ((winner == O_PLAYER) ? win_capture : lose_capture);
X
X	register_hit ();
X
X	return DO_MOVE;
X}
X
Xstatic void announce_loser (loser)
Xint loser;
X{
X	if (loser == O_PLAYER)
X		message ("I'm afraid you bought it, old boy.");
X	else
X		message ("Nice one %s!", players[0].name);
X}
X
Xvoid check_can_play (owner)
Xint owner;
X{
X	BOARD_POS *board_pos;
X	int y, x, enemy;
X
X	enemy = (owner == O_PLAYER) ? O_ENEMY : O_PLAYER;
X
X	for (y = 0; y < MAX_ROWS; y++) {
X	    for (x = 0; x < MAX_COLS; x++) {
X		board_pos = &board[y][x];
X		if (board_pos->owner != owner || board_pos->value <= FLAG  ||
X		    				 board_pos->value >= BOMB)
X			continue;
X
X		if (y - 1 >= 0 && (board[y - 1][x].value == FREE ||
X		    		   board[y - 1][x].owner == enemy))
X			return;
X
X		if (y + 1 < MAX_ROWS && (board[y + 1][x].value == FREE ||
X					 board[y + 1][x].owner == enemy))
X			return;
X
X		if (x - 1 >= 0 && (board[y][x - 1].value == FREE ||
X		    		   board[y][x - 1].owner == enemy))
X			return;
X
X		if (x + 1 < MAX_COLS && (board[y][x + 1].value == FREE ||
X					 board[y][x + 1].owner == enemy))
X			return;
X
X	    }
X	}
X
X	announce_loser (owner);
X	end_game ();
X}
X
X/*
X * End game routines.
X */
X
X
XXtCallbackProc FastQuit (widget)
XWidget widget;
X{
X	XtDestroyApplicationContext (app_con);
X	exit (0);
X}
X
Xstatic BUTTON endgame_buttons[] = {
X	" Quit ",  FastQuit,  TRUE, NULL,
X	" Store ", Store,     TRUE, NULL
X};
X
X
Xvoid end_game ()
X{
X	BOARD_POS *board_pos;
X	int nr_buttons = XtNumber (endgame_buttons) - 1;
X	int y, x;
X
X	end_communications ();
X
X	if (players[0].confirm)
X		ConfirmMove ();
X
X	if (players[0].status <= PL_SETUP_READY)
X		nr_buttons++;		/* Allow saving current position */
X	else {				/* Show board 			 */
X		for (y = 0; y < MAX_ROWS; y++) { 
X			for (x = 0; x < MAX_COLS; x++) { 
X				if (board[y][x].owner == O_ENEMY) {
X				       board_pos = &board[y][x];
X				       board_pos->value = abs(board_pos->value);
X				       MarkBoardPosition (board_pos, True);
X				}
X			}
X		}
X	}
X
X	new_button_box (endgame_buttons, nr_buttons);
X
X	players[0].status = PL_ENDGAME;
X}
END_OF_FILE
if test 8802 -ne `wc -c <'play.c'`; then
    echo shar: \"'play.c'\" unpacked with wrong size!
fi
# end of 'play.c'
fi
if test -f 'setup.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'setup.c'\"
else
echo shar: Extracting \"'setup.c'\" \(7918 characters\)
sed "s/^X//" >'setup.c' <<'END_OF_FILE'
X/*
X * Setup.c
X */
X
X#include "stratego.h"
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X/*	HJV:	Normally found in stdlib.h, but some systems do not
X		have this include file, or have it at another location.
X		Hoping they will not change the value of F_OK, I hereby
X		declare it as zero, as it should be.
X*/
X
X#ifndef F_OK
X#define F_OK 0
X#endif
X
Xstatic void SelectBoardCursor ();
X
X/*
X * Setup buttonbox Callback routines.
X */
X
X/*
X * WipeCursor Button Callback Routine.
X */
XXtCallbackProc WipeCursor (widget)
XWidget widget;
X{
X	SelectBoardCursor (&tiles[FREE]);
X}
X
X
X/*
X * Clear Button Callback Routine.
X */
XXtCallbackProc Clear (widget)
XWidget widget;
X{
X	int y, x;
X
X	for (y = MAX_ROWS - 4; y < MAX_ROWS; y++) {
X		for (x = 0; x < MAX_COLS; x++) { 
X			if (board[y][x].value != FREE) {
X				UpdateTileCount (&tiles[board[y][x].value],
X						 1);
X				AssignBoardPosition (&board[y][x], &tiles[FREE],
X						     O_NOBODY);
X			}
X		}
X	}
X	send_clear_board ();
X
X	SelectBoardCursor (&tiles[FREE]);
X}
X
X
X/*
X * Message Button Callback Routine.
X */
X
XXtCallbackProc Mail (widget)
XWidget widget;
X{
X	char msg_buf[100];
X
X	msg_buf[0] = '\0';
X	if (DialogBoxResult ("Enter Message", msg_buf, 80, ADD_CANCEL) == True)
X		send_mail (msg_buf);
X}
X
X
X/*
X * Ready Button Callback Routine.
X */
Xstatic BUTTON ready_buttons[] = {
X	" Message ", Mail, TRUE, NULL,
X	"  Quit   ", Quit, TRUE, NULL,
X};
X
XXtCallbackProc Ready (widget)
XWidget widget;
X{
X	char msg_buf[100];
X	int i;
X
X	for (i = FLAG; i <= BOMB; i++) {
X		if (tiles[i].count) {
X			display_error (finished_premature);
X			return;
X		}
X	}
X
X	sprintf (msg_buf, "You will no longer be able to change your setup.");
X	if (DialogBoxResult (msg_buf, NULL, 0, ADD_CANCEL) == True) {
X		players[0].status = PL_SETUP_READY;
X		send_ready ();
X
X		if (players[1].status != PL_SETUP_READY) {
X			message ("Waiting for %s to finish his setup...",
X				 players[1].name);
X			new_button_box (ready_buttons, XtNumber(ready_buttons));
X		}
X		else
X			start_play ();
X	}
X}
X
X
X/*
X * Quit Button Callback Routine.
X */
XXtCallbackProc Quit (widget)
XWidget widget;
X{
X	if (DialogBoxResult ("Please Confirm Quit", NULL, 0,
X						    ADD_CANCEL) == True) {
X		send_quit ();
X		XtDestroyApplicationContext (app_con);
X		exit (0);
X	}
X}
X
X
X/*
X * Store Button Callback Routine.
X */
Xstatic char filename[NAME_LENGTH] = "board.dat";
X
XXtCallbackProc Store (widget)
XWidget widget;
X{
X	char file_buf[80];
X	char msg_buf[100];
X	FILE *fp;
X	int x, y;
X
X	strcpy (file_buf, filename);
X
X	if (DialogBoxResult ("Enter Filename to Store", file_buf, 50,
X							ADD_CANCEL) == False)
X		return;
X	
X	if (access (file_buf, F_OK) == 0) {
X		sprintf (msg_buf, "\"%s\" already exists. Overwrite?",file_buf);
X		if (DialogBoxResult (msg_buf, NULL, 0, ADD_CANCEL) == False)
X			return;
X	}
X
X	if ((fp = fopen (file_buf, "w")) == NULL) {
X		message ("Cannot open datafile \"%s\".", file_buf);
X		return;
X	}
X
X	strcpy (filename, file_buf);
X
X	for (y = 6; y < MAX_ROWS; y++)
X		for (x = 0; x < MAX_COLS; x++)
X			fprintf (fp, "%d ", board[y][x].value);
X	fclose (fp);
X
X	chmod (filename, 0600);
X	
X	message ("Board setup saved in \"%s\".", filename);
X}
X
X
X/*
X * Load Button Callback Routine.
X */
XXtCallbackProc Load (widget)
XWidget widget;
X{
X	char file_buf[80];
X	FILE *fp;
X	int y, x, tile_value;
X	TILE *tile;
X	BOARD_POS *board_pos;
X	Boolean failed = FALSE;
X
X	strcpy (file_buf, filename);
X
X	if (DialogBoxResult ("Enter Filename to Load", file_buf, 50,
X						       ADD_CANCEL) == False)
X		return;
X
X	strcpy (filename, file_buf);
X
X	if ((fp = fopen (filename, "r")) == NULL) {
X		extern int errno, sys_nerr;
X		extern char *sys_errlist[];
X
X		message ("Cannot open datafile \"%s\": %s", filename,
X			 (errno < 0 || errno >= sys_nerr) ? "Unknown error" :
X							    sys_errlist[errno]);
X		return;
X	}
X
X	Clear (widget, (XtPointer) NULL, (XtPointer) NULL);
X
X	for (y = 6; y < MAX_ROWS && failed == False; y++) {
X		for (x = 0; x < MAX_COLS && failed == False; x++) {
X			if (fscanf (fp, "%d ", &tile_value) != 1) {
X				message ("Datafile damaged!");
X				failed = True;
X			}
X			else if (tile_value >= FLAG && tile_value <= BOMB) {
X				board_pos = &board[y][x];
X				tile = &tiles[tile_value];
X				if (tile->count == 0) {
X					message ("Hmmm, seems like a cheat file to me %s!", players[0].name);
X					failed = True;
X				}
X				AssignBoardPosition (board_pos, tile, O_PLAYER);
X				UpdateTileCount (tile, -1);
X				send_tile_placed (board_pos);
X			}
X			else if (tile_value != 0) {
X				message ("Datafile damaged!");
X				failed = True;
X			}
X		}
X	}
X
X	fclose (fp);
X
X	if (failed == True)
X		Clear (widget, (XtPointer) NULL, (XtPointer) NULL);
X	else
X		message ("Board setup loaded from \"%s\".", filename);
X}
X
X
X/*
X * TileBitmap widget class callback routines.
X */
Xstatic void SelectBoardCursor (tile)
XTILE *tile;
X{
X	int y, x, limit;
X	Arg args[1];
X
X	if (players[0].status == PL_ENDGAME) {	/* Opponent quitted the game */
X		message ("The game has ended!");
X		return;
X	}
X
X	limit = (players[0].status == PL_SETUP) ? MAX_ROWS - 4 : 0;
X
X	XtSetArg (args[0], XtNcursor, tile->cursor);
X	for (y = MAX_ROWS - 1; y >= limit; y--)
X		for (x = MAX_COLS - 1; x >= 0; x--)
X			XtSetValues (board[y][x].widget, args, 1);
X	
X	players[0].tile_select = tile->value;
X}
X
XXtCallbackProc SelectSetupBoardCursor (widget, tile)
XWidget widget;
XTILE *tile;
X{
X	if (players[0].status != PL_SETUP)
X		return;
X
X	if (tile->count == 0) {
X		message ("You have no more %ss left!", tile->name);
X		return;
X	}
X
X	SelectBoardCursor (tile);
X}
X
X
X/*
X * Called from callback routine of BoardPosition widget class.
X */
Xvoid setup_tile (board_pos)
XBOARD_POS *board_pos;
X{
X	TILE *tile;
X
X	if (board_pos->value == WATER) {
X		message ("Splash blup blup.");
X		return;
X	}
X
X	if (board_pos->y < MAX_ROWS - 4) {
X		message ("You cannot put a tile on enemy territory.");
X		return;
X	}
X
X	if (board_pos->value != FREE) {
X		UpdateTileCount (&tiles[board_pos->value], 1);
X		AssignBoardPosition (board_pos, &tiles[FREE], O_NOBODY);
X		send_tile_placed (board_pos);
X		if (players[0].tile_select == FREE)
X			return; /* Erasing */
X	}
X
X	tile = &tiles[players[0].tile_select];
X	if (tile->value < FLAG || tile->value > BOMB) {
X		/* No tile selected */
X		message ("You must select a tile first.");
X		return;
X	}
X
X	AssignBoardPosition (board_pos, tile, O_PLAYER);
X	UpdateTileCount (tile, -1);
X	send_tile_placed (board_pos);
X
X	if (tile->count == 0)
X		SelectBoardCursor (&tiles[FREE]);
X}
X
X#ifdef DEBUG
XXtCallbackProc Debug ()
X{
X	char file_buf[80];
X	FILE *fp;
X	int y, x, tile_value;
X	TILE *tile;
X	BOARD_POS *board_pos;
X	Boolean failed = FALSE;
X	char msg_buf[100];
X	int i;
X	char filename[100];
X
X	strcpy (filename, "board.dat");
X	if (DialogBoxResult ("Enter file", filename, sizeof(filename), ADD_CANCEL) == False)
X		return;
X
X	if ((fp = fopen (filename, "r")) == NULL) {
X		extern int errno, sys_nerr;
X		extern char *sys_errlist[];
X
X		message ("Cannot open datafile \"%s\": %s", filename,
X			 (errno < 0 || errno >= sys_nerr) ? "Unknown error" :
X							    sys_errlist[errno]);
X		return;
X	}
X
X	Clear ();
X
X	for (y = 6; y < MAX_ROWS && failed == False; y++) {
X		for (x = 0; x < MAX_COLS && failed == False; x++) {
X			if (fscanf (fp, "%d ", &tile_value) != 1) {
X				message ("Datafile damaged!");
X				failed = True;
X			}
X			else if (tile_value >= FLAG && tile_value <= BOMB) {
X				board_pos = &board[y][x];
X				tile = &tiles[tile_value];
X				if (tile->count == 0) {
X					message ("Hmmm, seems like a cheat file to me %s!", players[0].name);
X					failed = True;
X				}
X				AssignBoardPosition (board_pos, tile, O_PLAYER);
X				UpdateTileCount (tile, -1);
X				send_tile_placed (board_pos);
X			}
X			else if (tile_value != 0) {
X				message ("Datafile damaged!");
X				failed = True;
X			}
X		}
X	}
X
X	fclose (fp);
X
X	if (failed == True)
X		Clear ();
X	else
X		message ("Board setup loaded from \"%s\".", filename);
X
X		players[0].status = PL_SETUP_READY;
X		send_ready ();
X
X	if (players[1].status != PL_SETUP_READY) {
X		message ("Waiting for %s to finish his setup...",
X			 players[1].name);
X	}
X	else
X		start_play ();
X}
X#endif
END_OF_FILE
if test 7918 -ne `wc -c <'setup.c'`; then
    echo shar: \"'setup.c'\" unpacked with wrong size!
fi
# end of 'setup.c'
fi
if test -f 'xstratego.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xstratego.6'\"
else
echo shar: Extracting \"'xstratego.6'\" \(7526 characters\)
sed "s/^X//" >'xstratego.6' <<'END_OF_FILE'
X.TH XSTRATEGO 6 "17 March 1991"
X.SH NAME
Xxstratego \- X windows based
X.I stratego
Xinterface for two players.
X.SH SYNOPSIS
X.B xstratego
X.IB login @ hostname
X.B playername
X.br
X.B xstratego
X.B \-s
X.SH DESCRIPTION
X.LP
XThe first command line version lets you play against another player, where
X.TP 15
X.I login
Xis your opponents login name.
X.TP 15
X.I hostname
Xis the name of the host he (or she) is currently logged on.
X.TP 15
X.B playername
Xis the name under which you want to play.
X.LP
XThe second version gives you the opportunity to create a board setup and save
Xit for later use.
X.SH GAME BASICS
X.B
XStratego
Xis a famous board game that has been around for many years. Here is an
Xoverview of the rules for those who are not familiar with them.
X.br
XThe game is played on a board consisting of ten by ten squares. Each
Xplayer has forty tiles which are placed upon the lower half of the
Xboard. Each of these tiles has a certain value and move capability. The
Xvalue of a tile is symbolized by an army rank. In the table below is an
Xoverview of the tiles and their capabilities. The
X.I Amount
Xcolumn shows the number of tiles you have of each type.
X.sp
X.TS
Xlw(.25i) lw(.25i) lw(.25i) lw(.25i) lw(.25i) lw(.25i).
X_
X.sp 3p
X.TB
XRank	Name	Amount	Can Take	Can be taken by	Movement
X.sp 3p
X_
X.sp 3p
X 1	Marshal	      1	All	Spy	Normal (one square)
X 2	General	      1	Lower rank	Higher rank	Normal
X 3	Colonel	      2	Lower rank	Higher rank	Normal
X 4	Major	      3	Lower rank	Higher rank	Normal
X 5	Captain	      4	Lower rank	Higher rank	Normal
X 6	Lieutenant	      4	Lower rank	Higher rank	Normal
X 7	Sergeant	      4	Lower rank	Higher rank	Normal
X 8	Miner	      5	Lower rank and Bombs	Higher rank	Normal
X 9	Scout	      8	Lower rank	Higher rank	Several squares
X10	Spy	      1	Flag and Marshall	Higher rank	Normal
X11	Bomb	      6	All except Miners	Miner	None
X12	Flag	      1	None	All	None
X.sp 3p
X_
X.TE
X.sp
XEight board positions are designated as water. Nobody can swim. The
Xobject of the game is to take your opponents flag. The values of your
Xopponents tiles are (of course) not visible to you.
X.br
XThe players now take turns. There are two type of moves, moving or
Xattacking a tile. A move consists of moving a tile horizontal or
Xvertical. Diagonal moves are not permitted. When you attack an enemy
Xtile, both the attacking and attacked tile will reveil their value.
XNormally the highest rank will win (see table) and the other tile will
Xbe taken off the board. If you attack the enemy and win, your tile will
Xtake the enemies tile position on the board.
X.br
XThe game has ended if one of the following cases occur:
X.IP \(bu
XThe flag of one of the players is taken. The winner is the one who's
Xflag is still standing.
X.IP \(bu
XOne of the players can no longer make a valid move. This player will
Xhave lost the game.
X.IP \(bu
XIf the same board setup occurs three times, without a tile being taken
Xon either side the game is said to have ended in remise. Xstratego will
Xwarn you whenever a board setup occurs for the second time. It will ask
Xfor confirmation for the move that will end the game in remise.
X.SH XSTRATEGO DESCRIPTION
X.B xstratego
Xwill start up in
X.I setup mode.
XThe tiles are represented by bitmaps and displayed to the right in the
X.I
Xtile window
Xof the application. They are positioned in two columns and in ranking
Xorder, starting at the flag and moving from the marshal beneath it via
Xthe general, colonel, major, captain, lieutenant, sergeant, miner,
Xscout and spy to the bomb. To the right of each tile is a counter
Xdisplaying the number of tiles of that type you still have to place on
Xthe board.
X.br
XYou can place a tile on the board by clicking on its bitmap in the
X.I
Xtile window
Xwith the left mouse button. Your cursor will change into the selected
Xtile. Place the cursor on the board position you want to put the tile
Xand click the left mouse button again. You can remove tiles from the
Xboard by clicking the left mouse button on the corresponding board
Xposition with a neutral cursor (see
X.I Cursor
Xbelow)
XClick
X.I Ready
Xif you have completed your setup. When your opponent has finished as
Xwell, both players will automatically enter
X.I
Xplay mode.
X.br
XThe buttons on the right hand side of your screen have the following
Xmeaning:
X.TP 15
X.B Cursor
XThis will reset your cursor to the
X.I neutral
Xcursor.
X.TP 15
X.B Clear
XClears your setup.
X.TP 15
X.B Load
XYou will be prompted for a filename which should contain a board setup.
XYour current setup will be replaced by the new one.
X.TP 15
X.B Store
XYou will be prompted for a filename in which you can save your
X(possibly incomplete) board setup.
X.TP 15
X.B Ready
XIf you have placed all your tiles on the board and want to start play
Xwith this setup then click
X.I Ready.
XAll you have to do now is wait for your opponent to do the same.
X.TP 15
X.B Quit
XIf you decide to chicken out.
X.TP 15
X.B Message
XWill give you an opportunity to send a message to your opponent.
X.sp
X.LP
XIf both players have completed their setup, the computer will decide
Xwho will go first. The
X.I
Xtile window
Xnow indicates how many tiles of each type your opponent has left. You
Xcan move a tile by clicking on it with the left mouse button. This tile
Xwill be redrawn in grey. Click again on the board position you want to
Xmove the tile to. The tile will be placed on the new position if the
Xmove was legal.
X.br
XYou can attack an enemy tile by clicking the tile you want to attack
Xwith first and then the enemy tile you want to attack. If the movement
Xis legal, you will be shown the value of the enemy tile and the losing
Xtile(s) will be taken off the board.
X.br
XWhen your opponent has made a move, you will be shown the results. The
Xtile that moved will be shown in grey at two places: at the position
Xwhere it came from and at the position where it moved to. Pressing any
Xmouse button at an arbitrary place in the application will complete the
Xmove.
X.br
XThe new buttons on the right hand side have the following meaning:
X.TP 15
X.B Remise
XThis will send a remise offer to your opponent. It can either be
Xaccepted or declined. You will be informed of the results.
X.TP 15
X.B
XGive Up
XFor losers only!
X.TP 15
X.B Message
XFor the diplomatic communication.
X.SH XSTRATEGO RESOURCES
XXstratego is build from the following components:
X.TP 15
X.B *Stratego
XToplevel form widget. Contains all other widgets.
X.TP 15
X.B *Stratego.Board
XForm widget with defaultDistance resource set to 1.
X.TP 15
X.B *Stratego.Board.BoardPosition
XIndividual command widgets that make up the board.
X.TP 15
X.B *Stratego.Board.Water
XCommand widgets that contain the water areas inside the board
X.TP 15
X.B *Stratego.Tiles
XThe
X.I
Xtile window
Xform widget that contains the tile positions.
X.TP 15
X.B *Stratego.Tiles.TilePosition
XBox widget container for tile bitmap and counter.
X.TP 15
X.B *Stratego.Tiles.TilePosition.TileBitmap
XCommand widget that contains the tile bitmap
X.TP 15
X.B *Stratego.Tiles.TilePosition.TileCount
XLabel widget displaying the counter associated with the tile.
X.TP 15
X.B *Stratego.Message
XLabel widget at the bottom of the board. Functions as message display
Xarea.
X.TP 15
X.B *Stratego.ButtonSet
XForm widget functioning as container for right hand side buttons.
X.TP 15
X.B *Stratego.ButtonSet.Button
XCommand widgets inside ButtonSet.
X.TP 15
X.B *PopupShell.Dialog
XDialogbox widget inside popup shell.
X.SH BUGS
XThere should be an option to save and restore a game.
X.SH AUTHOR
XMichiel Huisjes (huisjes@cs.vu.nl)
X.br
XI would like to thank Peter Valkenburg (valke@psy.vu.nl) without whom
Xthe random messages would be a lot less funny.
END_OF_FILE
if test 7526 -ne `wc -c <'xstratego.6'`; then
    echo shar: \"'xstratego.6'\" unpacked with wrong size!
fi
# end of 'xstratego.6'
fi
echo shar: End of archive 1 \(of 4\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
