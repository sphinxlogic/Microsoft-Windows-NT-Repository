Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v15i028:  xmines2 - another minefield game for X11, Part01/01
Message-ID: <4000@master.CNA.TEK.COM>
Date: 1 Dec 92 01:00:54 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1348
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1527

Submitted-by: lourakis@csd.uch.gr (Manolis Lourakis)
Posting-number: Volume 15, Issue 28
Archive-name: xmines2/Part01
Environment: X11, XView, ANSI-C



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  README MANIFEST Copyright Imakefile Makefile xmines.c
#   xmines.h xmines.icons
# Wrapped by billr@saab on Sun Nov 29 18:29:21 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(2085 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X1. About xmines
XXmines creates a rectangle on the screen,divided into equally sized cells.
XEach cell may contain 
X	-a mine (hence the name xmines)
X	-a number indicating the number of mines present in the 8-neighboring
X         cells 
Xor it may be empty.Initially,all cells are covered with tiles.A tile can be
Xremoved uncovering the cell below, by clicking the left mouse button on it.
XIn addition,a cell can be marked as containing a mine by clicking the right
Xmouse button on it.Note however that marking a cell as containing a mine
Xdoes not necessarily mean that the cell really contains a mine!
XClicking the middle mouse button on a tile,marks it with a question mark
Xacting as a reminder mechanism.
XThe user can use the numbers in the uncovered cells to find (or sometimes guess...)
Xwhich cells contain mines and which do not.
XA game ends when all cells not containing mines have been uncovered and
Xall cells containing mines have been marked.
XThe user can alter some default settings by using the following command-line
Xarguments:
X-w value : Use value cells per row
X-h value : Use value rows of cells
X-m value : Use value mines
X-q value : Record playing time every value seconds
X
X2. Compiling
XXmines runs under the X-Window System.It is written using the XView window package.
XSupposing that you have XView installed,all you have to do to compile xmines is
Xto set the environment variable OPENWINHOME to point to the directory where XView
Xfiles are stored,type xmkmf to create the appropriate makefile and finally type
Xmake to start compilation.If OPENWINHOME is not set,the makefile will try to
Xuse directory /usr/openwin. The compiler used by the makefile is the gcc,
Xalthough there shouldn't be any serious problems using any other c compiler.
X
X3. Availability
XXmines is available via anonymous ftp from crete.csd.uch.gr (147.52.16.2)
XSources are in /pub/X/xmines-0.1.tar.Z
X
XXmines has been implemented in a couple of days,while doing other things,so there are
Xmany things that can be added.Fell free to sent your suggestions or modifications to
Xlourakis@csd.uch.gr
X
XHave fun
END_OF_FILE
if test 2085 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(362 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Copyright                  1	
X Imakefile                  1	
X MANIFEST                   1	This shipping list
X Makefile                   1	
X README                     1	
X xmines.c                   1	
X xmines.h                   1	
X xmines.icons               1	
END_OF_FILE
if test 362 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Copyright' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Copyright'\"
else
echo shar: Extracting \"'Copyright'\" \(836 characters\)
sed "s/^X//" >'Copyright' <<'END_OF_FILE'
X/* 
X * Xmines. Copyright (c) 1992 by M.Lourakis - S.Kostomanolakis
X *
X * Handmade by Manolis Lourakis       (lourakis@csd.uch.gr) and
X *             Stavros Kostomanolakis (kostoman@csd.uch.gr).
X * Computer Science Department,
X * University of Crete, HELLAS
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided 
X * that the above copyright notice appear in all copies and that both that 
X * copyright notice and this permission notice appear in supporting 
X * documentation.The authors make no representations about the 
X * suitability of this software for any purpose.It is provided "as is"
X * without express or implied warranty.
X *
X * Questions, bug reports, modifications, etc can be sent to any of the
X * above addresses.
X *
X */
X
X
END_OF_FILE
if test 836 -ne `wc -c <'Copyright'`; then
    echo shar: \"'Copyright'\" unpacked with wrong size!
fi
# end of 'Copyright'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(307 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
XWHERE :sh = (tmp=`echo /usr/openwin`;echo ${OPENWINHOME:=$tmp})
X
XCC = gcc
XINCLUDES = -I${WHERE}/include
XLOCAL_LIBRARIES = -L${WHERE}/lib
X
XSYS_LIBRARIES = -lxview -lolgx -lX11 -lm
X
XSRCS = xmines.c 
XOBJS = xmines.o
X
X/*CDEBUGFLAGS = -g  */
X/*CDEBUGFLAGS = -O4 */
XCDEBUGFLAGS = -O
X
XComplexProgramTarget(xmines)
END_OF_FILE
if test 307 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(10220 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.69 91/09/09 18:23:59 rws Exp $
X
X# operating system:  SunOS 4.1.1
X
X# $XConsortium: sunLib.rules,v 1.6 91/03/24 17:55:58 rws Exp $
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES = -DX_WCHAR -DX_LOCALE
X      STD_DEFINES = -DX_WCHAR -DX_LOCALE
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X      PROJECTROOT = /usr/local/X11R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/local/X11R5/lib
X           BINDIR = /usr/local/X11R5/bin
X          INCROOT = /usr/local/X11R5/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/local/X11R5/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X# $XConsortium: sunLib.tmpl,v 1.11 91/07/31 11:32:08 rws Exp $
X
XSHLIBLDFLAGS = -assert pure-text
XPICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
XWHERE :sh = (tmp=`echo /usr/openwin`;echo ${OPENWINHOME:=$tmp})
X
XCC = gcc
XINCLUDES = -I${WHERE}/include
XLOCAL_LIBRARIES = -L${WHERE}/lib
X
XSYS_LIBRARIES = -lxview -lolgx -lX11 -lm
X
XSRCS = xmines.c
XOBJS = xmines.o
X
XCDEBUGFLAGS = -O4
X
X PROGRAM = xmines
X
Xall:: xmines
X
Xxmines: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xinstall:: xmines
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  xmines $(DESTDIR)$(BINDIR)
X
Xinstall.man:: xmines.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) xmines.man $(DESTDIR)$(MANDIR)/xmines.$(MANSUFFIX)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
X# -------------------------------------------------------------------------
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
if test 10220 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'xmines.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xmines.c'\"
else
echo shar: Extracting \"'xmines.c'\" \(13496 characters\)
sed "s/^X//" >'xmines.c' <<'END_OF_FILE'
X#include <math.h>
X#include <sys/types.h>
X#include <sys/timeb.h>
X#include <sys/time.h>
X#include <signal.h>
X#include <stdio.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <xview/xview.h>
X#include <xview/panel.h>
X#include <xview/frame.h>
X#include <xview/canvas.h>
X#include <xview/notice.h>
X#include "xmines.h"
X
X#include "xmines.icons"
X
X#define CREATE_ICON(bits,width,height) XCreateBitmapFromData(display,RootWindow(display,screen),\
X					bits,width,height) 
X#define PLACE_ICON(icon,wherey,wherex) XCopyPlane(display,icon,pmap,def_gc,0,0, \
X                                          IC_WIDTH,IC_HEIGHT,wherex,wherey,1L)
X/*#define DEBUG */
X
X#define POW(x,y)        pow((double)(x),(double)(y))
X#define INITRAND        srandom(time((time_t *)0))
X#define MAXRANDOM       2147483648 /* 2^31 */
X#define RAND01          (((double)(random()))/MAXRANDOM)
X#define FRAND(min,max)  (RAND01*((max)-(min))+(min))
X#define RAND(min,max)   (int)FRAND(min,max)
X
X#ifndef lint
Xstatic char     sccsid[] = "@(#)xmines,v0.1 by Manolis Lourakis.";
Xstatic char     Copyright[] = "(c) 1992 Lourakis Manolis.\n";
Xstatic char     Mail[] = "lourakis@csd.uch.gr";
X#endif
X
X
Xextern char     *optarg ;
Xextern int      optind ;
X
Xvoid canvas_event_proc(Xv_Window, Event*); 
Xvoid canvas_repaint_proc(void);
Xvoid settime(void);
Xvoid finish(char *);
X
X
XDisplay *display;
XVisual *visual;
Xint screen;
XGC def_gc;
X
XFrame frame;
XPanel panel1,panel2;
XPanel_item pmsg,smsg,tmsg;
XCanvas canvas;
X
XWindow dr_win;
XPixmap pmap,icons[NUM_ICONS];
Xcell *Cells;
Xchar buff[256];
X
Xint quit_proc(),init();
Xint place_tiles(int,int);
Xint mark_tile(int,int);
Xint open_tile(int,int);
Xint auto_open(int,int);
X
Xint mines_2_go,closed_tiles,playing,checks,secs;
Xint width=HORIZ_CELLS,
X    height=VERT_CELLS,
X    mines=NUM_MINES,
X    quantum=QUANTUM;
X
Xstruct itimerval timer;
Xint first_tile;
X
Xvoid main(int argc, char *argv[]){
X  int ret,tmp;
X  register int i,j;
X  int   errflag = 0,gc;
X  XWMHints        wm_hints;
X  XClassHint      class_hints;
X  XTextProperty   windowName, iconName;
X  char           *window_name = "Xmines";
X  char           *icon_name = "Xmines";
X  
X  xv_init (XV_INIT_ARGC_PTR_ARGV, &argc, argv, NULL);
X  while ((gc = getopt(argc, argv, "w:h:m:q:")) != EOF)
X  switch (gc) {
X      case 'w' :
X              tmp=atoi(optarg);
X	      if(tmp>0) width=tmp;
X              break ;
X      case 'h' :
X	      tmp=atoi(optarg);
X	      if(tmp>0) height=tmp;
X              break ;
X      case 'm' :
X	      tmp=atoi(optarg);
X	      if(tmp>0) mines=tmp;
X              break;
X      case 'q' :
X	      tmp=atoi(optarg);
X	      if(tmp>0) quantum=tmp;
X	      break;
X      case '?' :
X              errflag++;
X              break ;
X  }
X  if(errflag){
X	fprintf(stderr,
X	"Usage: xmines [-w width] [-h height] [-m mines] [-q quantum]\n");
X	exit(1);
X  }
X  if(mines>=width*height){
X     fprintf(stderr,"xmines: Too many mines, using defaults\n");
X     width=HORIZ_CELLS;
X     height=VERT_CELLS;
X     mines=NUM_MINES;
X  }
X  
X  Cells=(cell *)malloc(width*height*sizeof(cell));
X  if(Cells==NULL){
X     fprintf(stderr,"xmines: malloc failed\n");
X     exit(1);
X  }
X
X  frame = (Frame) xv_create (NULL, FRAME,
X			     FRAME_LABEL,PROG_NAME,
X			     XV_WIDTH,width*IC_WIDTH,
X                             NULL);
X  display = (Display *)xv_get (frame, XV_DISPLAY);
X  screen = DefaultScreen(display);
X  visual = DefaultVisual(display, screen);
X  def_gc = DefaultGC(display, screen);
X
X  panel1 = xv_create (frame, PANEL,
X		      PANEL_LAYOUT,PANEL_HORIZONTAL,
X                      NULL);
X
X       xv_create (panel1, PANEL_BUTTON,
X                   PANEL_LABEL_STRING, "Quit",
X                   PANEL_NOTIFY_PROC, quit_proc,
X                   NULL);
X	xv_create (panel1, PANEL_BUTTON,
X                    PANEL_LABEL_STRING, "New",
X                    PANEL_NOTIFY_PROC, init,
X                    NULL);
X	tmsg=xv_create (panel1, PANEL_MESSAGE,
X			PANEL_LABEL_STRING,"Time:  0:0",
X			PANEL_LABEL_BOLD,TRUE,
X		        NULL);
X	window_fit_height(panel1);
X  panel2 = xv_create (frame, PANEL,
X                      PANEL_LAYOUT,PANEL_HORIZONTAL,
X                      NULL);
X
X    sprintf(buff,"Mines: %d\n",mines);
X	 xv_create(panel2,PANEL_MESSAGE,
X                   PANEL_LABEL_STRING,buff,
X		   PANEL_LABEL_BOLD,TRUE,
X                   NULL);
X    sprintf(buff,"Checks: 0");
X    pmsg=xv_create(panel2,PANEL_MESSAGE,
X		   PANEL_LABEL_STRING,buff,
X		   PANEL_LABEL_BOLD,TRUE,
X		   NULL);
X    smsg=xv_create(panel2,PANEL_MESSAGE,
X                   XV_SHOW, FALSE,
X                   NULL);
X    window_fit_height(panel2);
X		    
X  canvas = xv_create (frame, CANVAS,
X			CANVAS_X_PAINT_WINDOW, TRUE,
X			XV_WIDTH,IC_WIDTH*width,
X			XV_HEIGHT,IC_HEIGHT*height,
X			WIN_EVENT_PROC, canvas_event_proc,
X			CANVAS_REPAINT_PROC, canvas_repaint_proc,
X			NULL);
X  xv_set (canvas_paint_window (canvas), WIN_CONSUME_EVENTS,
X	  WIN_MOUSE_BUTTONS,
X   	  NULL,
X	  WIN_EVENT_PROC, canvas_event_proc,
X	  NULL);
X
X  dr_win = xv_get(canvas_paint_window (canvas), XV_XID);
X
X  pmap=XCreatePixmap(display,dr_win,IC_WIDTH*width,
X                     IC_HEIGHT*height,DefaultDepth(display,screen)); 
X
X  icons[EMPTY]=CREATE_ICON(empty_bits,empty_width,empty_height);
X  icons[ONE]=CREATE_ICON(one_bits,one_width,one_height);
X  icons[TWO]=CREATE_ICON(two_bits,two_width,two_height);
X  icons[THREE]=CREATE_ICON(three_bits,three_width,three_height);
X  icons[FOUR]=CREATE_ICON(four_bits,four_width,four_height);
X  icons[FIVE]=CREATE_ICON(five_bits,five_width,five_height);
X  icons[SIX]=CREATE_ICON(six_bits,six_width,six_height);
X  icons[SEVEN]=CREATE_ICON(seven_bits,seven_width,seven_height); 
X  icons[EIGHT]=CREATE_ICON(eight_bits,eight_width,eight_height);
X  icons[CLOSED]=CREATE_ICON(closed_bits,closed_width,closed_height);
X  icons[MARKED]=CREATE_ICON(marked_bits,marked_width,marked_height);
X  icons[MINE]=CREATE_ICON(mine_bits,mine_width,mine_height);
X  icons[QUEST]=CREATE_ICON(quest_bits,quest_width,quest_height);
X  
X  if (XStringListToTextProperty(&window_name, 1, &windowName) == 0) {
X    fprintf(stderr, "structure allocation for windowName failed\n");
X    exit(1);
X  }
X  if (XStringListToTextProperty(&icon_name, 1, &iconName) == 0) {
X    fprintf(stderr, "structure allocation for windowName failed\n");
X    exit(1);
X  }
X  wm_hints.initial_state = NormalState;
X  wm_hints.input = True;
X  wm_hints.icon_pixmap = icons[MINE];
X  wm_hints.flags = StateHint | IconPixmapHint | InputHint;
X
X  class_hints.res_name = "Xmines";
X  class_hints.res_class = "Games";
X
X  XSetWMProperties(display, xv_get(frame,XV_XID), &windowName, &iconName, argv,
X                   argc, NULL, &wm_hints, &class_hints);
X
X 
X  
X  timer.it_interval.tv_sec=quantum;
X  timer.it_interval.tv_usec=0;
X
X  timer.it_value.tv_sec=quantum;
X  timer.it_value.tv_usec=0;
X
X  init();
X  window_fit(frame);
X  xv_main_loop(frame);
X}
X
X
Xvoid
Xcanvas_repaint_proc ()
X{ 
X  XCopyArea(display,pmap,dr_win,def_gc,0,0,
X             width*IC_WIDTH,height*IC_HEIGHT,0,0);
X}
X
Xvoid
Xcanvas_event_proc (Xv_Window window, Event *event)
X{
Xint x,y;
Xcell *aux;
X
X  if(!playing) return;
X  switch (event_xevent (event)->type)
X    {
X    case ButtonRelease:
X      get_cell(event_xevent (event)->xbutton.x,event_xevent (event)->xbutton.y,
X                        &x,&y);
X      switch (event_xevent (event)->xbutton.button){
X	case Button1: 
X          if(open_tile(x,y)){
X            XCopyArea(display,pmap,dr_win,def_gc,0,0,
X               width*IC_WIDTH,height*IC_HEIGHT,0,0);
X           }
X          if(mines_2_go==0 && closed_tiles==mines)
X		   finish("  Successful");
X	  break;
X	case Button2:
X	  aux=Cells+x*width+y;
X	  if(aux->out_state!=CLOSED) break;
X	  PLACE_ICON(icons[QUEST],x*IC_WIDTH,
X                              y*IC_HEIGHT);
X          aux->out_state=QUEST;
X	  XCopyArea(display,pmap,dr_win,def_gc,0,0,
X               width*IC_WIDTH,height*IC_HEIGHT,0,0);
X	  break;
X	case Button3:
X          if(mark_tile(x,y)){
X             XCopyArea(display,pmap,dr_win,def_gc,0,0,
X                width*IC_WIDTH,height*IC_HEIGHT,0,0);
X          }
X	  if(mines_2_go==0 && closed_tiles==mines)
X		finish("  Successful");
X
X	  break;
X	}
X      break;
X    default:
X      break;
X    }
X}
X
Xerror(char *msg)
X{
X fprintf(stderr,"xmines: %s\n",msg);
X exit(1);
X}
X
Xget_cell(int where_x,int where_y,int *i,int *j)
X{
X register int k;
X
X for(k=0;k*IC_WIDTH<where_x;k++)
X	  ;
X *j=k-1;
X for(k=0;k*IC_HEIGHT<where_y;k++)
X          ;
X *i=k-1;
X}
X
Xquit_proc()
X{
X  int          result;
X
X  result = notice_prompt(panel1, NULL,
X        NOTICE_MESSAGE_STRINGS,
X                "Realy Quit?",
X                "Press YES to confirm",
X                "Press NO to cancel",
X                NULL,
X        NOTICE_BUTTON_YES,      "YES",
X        NOTICE_BUTTON_NO,       "NO",
X        NULL);
X
X  switch(result) {
X        case NOTICE_YES:
X            exit(0);
X            break;
X        case NOTICE_NO:
X            break;
X        case NOTICE_FAILED:
X        default: break;
X    }
X}
X
X
Xplace_tiles(int len,int num_mines)
X{
X register int i,j;
X int where,aux,cnt;
X
X for(i=0;i<len;i++){
X  (Cells+i)->in_state=EMPTY;
X  (Cells+i)->out_state=CLOSED;
X }
X 
X INITRAND;
X
X for(i=0;i<num_mines; ){
X   aux=RAND(0,len);
X   if((Cells+aux)->in_state==MINE) continue;
X   (Cells+aux)->in_state=MINE;
X   i++;
X }
X
X for(j=0;j<width;j++)
X  for(i=0;i<height;i++){
X
X     where=i*width+j;
X     if((Cells+where)->in_state==MINE) continue;
X
X    cnt=0;
X    if(i-1>=0){
X       if((Cells+where-width)->in_state==MINE) cnt++;
X	if(j-1>=0)
X	  if((Cells+where-width-1)->in_state==MINE) cnt++;
X	if(j+1<width)
X	  if((Cells+where-width+1)->in_state==MINE) cnt++;
X    }
X    if(i+1<height){
X       if((Cells+where+width)->in_state==MINE) cnt++;
X	if(j-1>=0)
X	  if((Cells+where+width-1)->in_state==MINE) cnt++;
X	if(j+1<width)
X	  if((Cells+where+width+1)->in_state==MINE) cnt++;
X    }
X    if(j-1>=0)
X       if((Cells+where-1)->in_state==MINE) cnt++;
X	  
X    if(j+1<width)
X       if((Cells+where+1)->in_state==MINE) cnt++;
X    (Cells+where)->in_state=cnt;
X }
X
X#ifdef DEBUG
X for(i=0;i<height;i++){
X  for(j=0;j<width;j++)
X   if((Cells+i*width+j)->in_state==MINE) printf("* "); else
X   printf("%d ",(Cells+i*width+j)->in_state);
X  printf("\n");
X }
X#endif
X 
X}   
X   
X
Xopen_tile(int i,int j)
X{
X cell *aux;
X
X if (first_tile) {
X      signal(SIGALRM,settime);
X      setitimer(ITIMER_REAL,&timer,NULL);
X      first_tile=0;
X }
X aux=Cells+i*width+j;
X if(aux->out_state!=CLOSED && aux->out_state!=MARKED && aux->out_state!=QUEST) 
X	return FALSE;
X
X if(aux->in_state==MINE){
X         finish("  Game Over");
X  }
X  else if(aux->in_state==EMPTY)
X           return auto_open(i,j); 
X       else {
X	  if(aux->out_state==MARKED){
X		checks--;
X		sprintf(buff,"Checks: %d\n",checks);
X		xv_set(pmsg,PANEL_LABEL_STRING,buff,NULL);
X 	  }
X
X          PLACE_ICON(icons[aux->in_state],i*IC_WIDTH,
X                              j*IC_HEIGHT);
X          aux->out_state=aux->in_state;
X          closed_tiles--;
X          return TRUE;
X       }
X}
X
Xmark_tile(int i,int j)
X{
X cell *aux;
X
X aux=Cells+i*width+j;
X
X if(aux->out_state==MARKED || aux->out_state!=CLOSED && aux->out_state!=QUEST)
X		 return FALSE;
X
X PLACE_ICON(icons[MARKED],i*IC_WIDTH,j*IC_HEIGHT);
X aux->out_state=MARKED;
X checks++;
X
X if(aux->in_state==MINE)
X    mines_2_go--;
X
X sprintf(buff,"Checks: %d\n",checks);
X xv_set(pmsg,PANEL_LABEL_STRING,buff,NULL);
X return TRUE;
X}
X
Xauto_open(int i,int j)
X{
X int where;
X cell *ptr;
X
X  ptr=Cells+i*width+j;
X  if(ptr->out_state!=CLOSED && ptr->out_state!=MARKED && ptr->out_state!=QUEST
X		 || ptr->in_state>EIGHT) return FALSE;
X
X  if(ptr->out_state==MARKED){
X        checks--;
X        sprintf(buff,"Checks: %d\n",checks);
X        xv_set(pmsg,PANEL_LABEL_STRING,buff,NULL);
X  }
X
X  PLACE_ICON(icons[ptr->in_state],i*IC_WIDTH,j*IC_HEIGHT);
X  ptr->out_state=ptr->in_state;
X  closed_tiles--;
X 
X   if(ptr->in_state==EMPTY){
X     if(i-1>=0){ 
X	auto_open(i-1,j);
X	if(j-1>=0) auto_open(i-1,j-1);
X	if(j+1<width) auto_open(i-1,j+1);
X     }
X     if(i+1<height){
X	 auto_open(i+1,j);
X	 if(j-1>=0) auto_open(i+1,j-1);
X        if(j+1<width) auto_open(i+1,j+1);
X     }
X
X     if(j-1>=0) auto_open(i,j-1);
X     if(j+1<width) auto_open(i,j+1);
X
X     return TRUE;
X  }
X}
X   
Xint init(){
Xregister int i;
Xint j;
X
X  place_tiles(width*height,mines);
X  mines_2_go=mines;
X  playing=TRUE;
X  j=closed_tiles=width*height;
X  checks=0;
X  for(i=0;i<j;i++)
X#ifndef DEBUG
X     PLACE_ICON(icons[CLOSED],(i/width)*IC_WIDTH,(i%width)*IC_HEIGHT);
X#else
X     PLACE_ICON(icons[(Cells+i)->in_state],(i/width)*IC_WIDTH,(i%width)*IC_HEIGHT);
X#endif
X
X  XCopyArea(display,pmap,dr_win,def_gc,0,0,
X             width*IC_WIDTH,height*IC_HEIGHT,0,0);
X  xv_set(smsg,XV_SHOW,FALSE,NULL);
X  xv_set(tmsg,PANEL_LABEL_STRING,"Time:  0:0",NULL);
X  xv_set(pmsg,PANEL_LABEL_STRING,"Checks: 0",NULL);
X  secs=0;
X  first_tile=1;
X  signal(SIGALRM,SIG_IGN);
X}
X   
X
Xshow_placements(int len){
X register int i;
X
X for(i=0;i<len;i++)
X    if((Cells+i)->in_state==MINE) PLACE_ICON(icons[MINE],(i/width)*IC_WIDTH,
X						(i%width)*IC_HEIGHT);
X XCopyArea(display,pmap,dr_win,def_gc,0,0,
X             width*IC_WIDTH,height*IC_HEIGHT,0,0);
X}
X
Xvoid settime(void)
X{
X  secs+=quantum;
X  sprintf(buff,"Time:  %2d:%2d",secs/60,secs%60);
X  xv_set(tmsg,PANEL_LABEL_STRING,buff,NULL);
X}
X
Xvoid finish(char *result)
X{
X	playing=FALSE;
X	show_placements(width*height);
X        xv_set(smsg,PANEL_LABEL_STRING,result,
X                    XV_SHOW,TRUE,
X                    NULL);
X	 getitimer(ITIMER_REAL,&timer);
X	 secs+=quantum-timer.it_value.tv_sec;
X	 sprintf(buff,"Time:  %2d:%2d",secs/60,secs%60);
X         xv_set(tmsg,PANEL_LABEL_STRING,buff,NULL);
X         signal(SIGALRM,SIG_IGN);
X}
X
END_OF_FILE
if test 13496 -ne `wc -c <'xmines.c'`; then
    echo shar: \"'xmines.c'\" unpacked with wrong size!
fi
# end of 'xmines.c'
fi
if test -f 'xmines.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xmines.h'\"
else
echo shar: Extracting \"'xmines.h'\" \(572 characters\)
sed "s/^X//" >'xmines.h' <<'END_OF_FILE'
X#define PROG_NAME    "Xmines"
X
X#define HORIZ_CELLS  10
X#define VERT_CELLS   10
X#define NUM_MINES    15 
X#define IC_WIDTH   32
X#define IC_HEIGHT  32
X
X#define EMPTY   0
X#define ONE     1
X#define TWO     2
X#define THREE   3
X#define FOUR    4
X#define FIVE 	5
X#define SIX	6
X#define SEVEN	7
X#define EIGHT   8
X#define CLOSED  9
X#define MARKED  10 
X#define MINE    11 
X#define QUEST   12
X#define NUM_ICONS 13 
X
X
X#define FALSE      0
X#define TRUE       1
X
X#define QUANTUM   5 
X
X
Xtypedef struct _cell {
X	int in_state;  /* core state */
X	int out_state; /* displayed state */
X} cell;
END_OF_FILE
if test 572 -ne `wc -c <'xmines.h'`; then
    echo shar: \"'xmines.h'\" unpacked with wrong size!
fi
# end of 'xmines.h'
fi
if test -f 'xmines.icons' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xmines.icons'\"
else
echo shar: Extracting \"'xmines.icons'\" \(13143 characters\)
sed "s/^X//" >'xmines.icons' <<'END_OF_FILE'
X#define closed_width 32
X#define closed_height 32
Xstatic char closed_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0xe0, 0x05, 0x00, 0x00, 0xd0,
X   0xf9, 0xff, 0xff, 0xaf, 0xf9, 0xff, 0xff, 0xdf, 0xf9, 0xff, 0xff, 0xaf,
X   0xf9, 0xff, 0xff, 0xdf, 0xf9, 0xff, 0xff, 0xaf, 0xf9, 0xff, 0xff, 0xdf,
X   0xf9, 0xff, 0xff, 0xaf, 0xf9, 0xff, 0xff, 0xdf, 0xf9, 0xff, 0xff, 0xaf,
X   0xf9, 0xff, 0xff, 0xdf, 0xf9, 0xff, 0xff, 0xaf, 0xf9, 0xff, 0xff, 0xdf,
X   0xf9, 0xff, 0xff, 0xaf, 0xf9, 0xff, 0xff, 0xdf, 0xf9, 0xff, 0xff, 0xaf,
X   0xf9, 0xff, 0xff, 0xdf, 0xf9, 0xff, 0xff, 0xaf, 0xf9, 0xff, 0xff, 0xdf,
X   0xf9, 0xff, 0xff, 0xaf, 0xf9, 0xff, 0xff, 0xdf, 0xf9, 0xff, 0xff, 0xaf,
X   0xf9, 0xff, 0xff, 0xdf, 0xf9, 0xff, 0xff, 0xaf, 0xf9, 0xff, 0xff, 0xdf,
X   0xf9, 0xff, 0xff, 0xaf, 0xa9, 0xaa, 0xaa, 0xda, 0x55, 0x55, 0x55, 0xb5,
X   0xab, 0xaa, 0xaa, 0xea, 0xff, 0xff, 0xff, 0xff};
X#define eight_width 32
X#define eight_height 32
Xstatic char eight_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0xf0, 0x03, 0x80, 0x01, 0xf0, 0x0f, 0x80,
X   0x01, 0x0c, 0x1e, 0x80, 0x01, 0x0e, 0x1c, 0x80, 0x01, 0x0e, 0x1c, 0x80,
X   0x01, 0x1e, 0x1c, 0x80, 0x01, 0x3e, 0x0e, 0x80, 0x01, 0xfe, 0x0f, 0x80,
X   0x01, 0xfc, 0x03, 0x80, 0x01, 0xf0, 0x0f, 0x80, 0x01, 0xfc, 0x1f, 0x80,
X   0x01, 0x0e, 0x1f, 0x80, 0x01, 0x0e, 0x3e, 0x80, 0x01, 0x0e, 0x3c, 0x80,
X   0x01, 0x0e, 0x1c, 0x80, 0x01, 0x0e, 0x1c, 0x80, 0x01, 0x1e, 0x0f, 0x80,
X   0x01, 0xfc, 0x03, 0x80, 0x01, 0xf0, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff};
X#define empty_width 32
X#define empty_height 32
Xstatic char empty_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff};
X#define five_width 32
X#define five_height 32
Xstatic char five_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0xf0, 0x3f, 0x80, 0x01, 0xf8, 0x1f, 0x80,
X   0x01, 0xf8, 0x0f, 0x80, 0x01, 0xf8, 0x07, 0x80, 0x01, 0x08, 0x00, 0x80,
X   0x01, 0x08, 0x00, 0x80, 0x01, 0x08, 0x00, 0x80, 0x01, 0xf8, 0x0f, 0x80,
X   0x01, 0x18, 0x0f, 0x80, 0x01, 0x08, 0x1e, 0x80, 0x01, 0x08, 0x1e, 0x80,
X   0x01, 0x00, 0x3c, 0x80, 0x01, 0x18, 0x3c, 0x80, 0x01, 0x3c, 0x3c, 0x80,
X   0x01, 0x3e, 0x1e, 0x80, 0x01, 0x1c, 0x1e, 0x80, 0x01, 0x0c, 0x0f, 0x80,
X   0x01, 0xf0, 0x01, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff};
X#define four_width 32
X#define four_height 32
Xstatic char four_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x04, 0x80,
X   0x01, 0x00, 0x04, 0x80, 0x01, 0x00, 0x07, 0x80, 0x01, 0x80, 0x07, 0x80,
X   0x01, 0xc0, 0x07, 0x80, 0x01, 0xc0, 0x07, 0x80, 0x01, 0xa0, 0x07, 0x80,
X   0x01, 0xb0, 0x07, 0x80, 0x01, 0x98, 0x07, 0x80, 0x01, 0x9c, 0x07, 0x80,
X   0x01, 0x8c, 0x07, 0x80, 0x01, 0x83, 0x07, 0x80, 0x01, 0x83, 0x07, 0x80,
X   0x01, 0xff, 0x3f, 0x80, 0x01, 0xff, 0x3f, 0x80, 0x01, 0x80, 0x07, 0x80,
X   0x01, 0x80, 0x07, 0x80, 0x01, 0x80, 0x07, 0x80, 0x01, 0xe0, 0x3f, 0x80,
X   0x01, 0xe0, 0x3f, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff};
X#define marked_width 32
X#define marked_height 32
Xstatic char marked_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0xe0, 0x05, 0x00, 0x00, 0xd0,
X   0xf9, 0xff, 0xff, 0xaf, 0xf9, 0xff, 0xff, 0xdf, 0xf9, 0xff, 0xff, 0xaf,
X   0xf9, 0xff, 0xff, 0xdf, 0xf9, 0xff, 0x3f, 0xae, 0xf9, 0xff, 0x3f, 0xde,
X   0xf9, 0xff, 0x1f, 0xaf, 0xf9, 0xff, 0x1f, 0xdf, 0xf9, 0xff, 0x8f, 0xaf,
X   0xf9, 0xff, 0x8f, 0xdf, 0xf9, 0xff, 0xc7, 0xaf, 0xf9, 0xff, 0xc7, 0xdf,
X   0xf9, 0xf0, 0xe3, 0xaf, 0xf9, 0xe1, 0xe3, 0xdf, 0xf9, 0xc3, 0xf1, 0xaf,
X   0xf9, 0x87, 0xf1, 0xdf, 0xf9, 0x0f, 0xf8, 0xaf, 0xf9, 0x1f, 0xf8, 0xdf,
X   0xf9, 0x3f, 0xfc, 0xaf, 0xf9, 0x7f, 0xfc, 0xdf, 0xf9, 0xff, 0xfe, 0xaf,
X   0xf9, 0xff, 0xff, 0xdf, 0xf9, 0xff, 0xff, 0xaf, 0xf9, 0xff, 0xff, 0xdf,
X   0xf9, 0xff, 0xff, 0xaf, 0xa9, 0xaa, 0xaa, 0xda, 0x55, 0x55, 0x55, 0xb5,
X   0xab, 0xaa, 0xaa, 0xea, 0xff, 0xff, 0xff, 0xff};
X#define mine_width 32
X#define mine_height 32
Xstatic char mine_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x41, 0xec, 0x00, 0x80, 0x01, 0x12, 0x03, 0x80, 0x01, 0x12, 0x03, 0x80,
X   0x81, 0x0d, 0x03, 0x80, 0x01, 0x80, 0x07, 0x80, 0x01, 0x80, 0x07, 0x80,
X   0x41, 0x82, 0x07, 0x80, 0x01, 0xf0, 0x3f, 0x80, 0x01, 0xf0, 0x3f, 0x80,
X   0x01, 0xf0, 0x3f, 0x80, 0x01, 0xfc, 0xff, 0x80, 0x01, 0xfc, 0xe7, 0x80,
X   0x01, 0xfc, 0xe7, 0x80, 0x01, 0xfc, 0xe7, 0x80, 0x01, 0xfc, 0xe7, 0x80,
X   0x01, 0xfc, 0xe7, 0x80, 0x01, 0xf0, 0x3b, 0x80, 0x01, 0xf0, 0x3f, 0x80,
X   0x01, 0xf0, 0x3f, 0x80, 0x01, 0x80, 0x07, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff};
X#define nine_width 32
X#define nine_height 32
Xstatic char nine_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0xc0, 0x01, 0x80, 0x01, 0x78, 0x0f, 0x80, 0x01, 0x3c, 0x1e, 0x80,
X   0x01, 0x3e, 0x3c, 0x80, 0x01, 0x1e, 0x3c, 0x80, 0x01, 0x1e, 0x78, 0x80,
X   0x01, 0x1e, 0x78, 0x80, 0x01, 0x3e, 0x7c, 0x80, 0x01, 0x3e, 0x7e, 0x80,
X   0x01, 0xfc, 0x7b, 0x80, 0x01, 0xf0, 0x78, 0x80, 0x01, 0x00, 0x78, 0x80,
X   0x01, 0x00, 0x78, 0x80, 0x01, 0x0c, 0x38, 0x80, 0x01, 0x1e, 0x3c, 0x80,
X   0x01, 0x1e, 0x1c, 0x80, 0x01, 0x1e, 0x1e, 0x80, 0x01, 0x0c, 0x0f, 0x80,
X   0x01, 0xf8, 0x07, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff};
X#define one_width 32
X#define one_height 32
Xstatic char one_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x02, 0x80, 0x01, 0x80, 0x03, 0x80, 0x01, 0xf8, 0x03, 0x80,
X   0x01, 0xf8, 0x03, 0x80, 0x01, 0xc0, 0x03, 0x80, 0x01, 0xc0, 0x03, 0x80,
X   0x01, 0xc0, 0x03, 0x80, 0x01, 0xc0, 0x03, 0x80, 0x01, 0xc0, 0x03, 0x80,
X   0x01, 0xc0, 0x03, 0x80, 0x01, 0xc0, 0x03, 0x80, 0x01, 0xc0, 0x03, 0x80,
X   0x01, 0xc0, 0x03, 0x80, 0x01, 0xc0, 0x03, 0x80, 0x01, 0xc0, 0x03, 0x80,
X   0x01, 0xc0, 0x03, 0x80, 0x01, 0xc0, 0x03, 0x80, 0x01, 0xc0, 0x03, 0x80,
X   0x01, 0xf8, 0x3f, 0x80, 0x01, 0xf8, 0x3f, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff};
X#define quest_width 32
X#define quest_height 32
Xstatic char quest_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0xe0, 0x05, 0x00, 0x00, 0xd0,
X   0xf9, 0xff, 0xff, 0xaf, 0xf9, 0xff, 0xff, 0xdf, 0xf9, 0xff, 0xff, 0xaf,
X   0xf9, 0xff, 0xff, 0xdf, 0xf9, 0x3f, 0xfc, 0xaf, 0xf9, 0x0f, 0xf0, 0xdf,
X   0xf9, 0x07, 0xe0, 0xaf, 0xf9, 0xc7, 0xe0, 0xdf, 0xf9, 0xc7, 0xe1, 0xaf,
X   0xf9, 0xc7, 0xe1, 0xdf, 0xf9, 0xc7, 0xe1, 0xaf, 0xf9, 0xc7, 0xe1, 0xdf,
X   0xf9, 0xff, 0xe1, 0xaf, 0xf9, 0xff, 0xf0, 0xdf, 0xf9, 0x7f, 0xf8, 0xaf,
X   0xf9, 0x7f, 0xfc, 0xdf, 0xf9, 0x3f, 0xfe, 0xaf, 0xf9, 0x3f, 0xff, 0xdf,
X   0xf9, 0x3f, 0xff, 0xaf, 0xf9, 0xff, 0xff, 0xdf, 0xf9, 0xff, 0xff, 0xaf,
X   0xf9, 0x1f, 0xfc, 0xdf, 0xf9, 0x1f, 0xfc, 0xaf, 0xf9, 0x1f, 0xfc, 0xdf,
X   0xf9, 0xff, 0xff, 0xaf, 0xa9, 0xaa, 0xaa, 0xda, 0x55, 0x55, 0x55, 0xb5,
X   0xab, 0xaa, 0xaa, 0xea, 0xff, 0xff, 0xff, 0xff};
X#define seven_width 32
X#define seven_height 32
Xstatic char seven_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0xfc, 0x3f, 0x80, 0x01, 0xfc, 0x3f, 0x80,
X   0x01, 0xfc, 0x1f, 0x80, 0x01, 0xfc, 0x1f, 0x80, 0x01, 0x04, 0x0c, 0x80,
X   0x01, 0x04, 0x0c, 0x80, 0x01, 0x00, 0x06, 0x80, 0x01, 0x00, 0x06, 0x80,
X   0x01, 0x00, 0x07, 0x80, 0x01, 0x80, 0x03, 0x80, 0x01, 0x80, 0x03, 0x80,
X   0x01, 0xc0, 0x03, 0x80, 0x01, 0xc0, 0x03, 0x80, 0x01, 0xc0, 0x03, 0x80,
X   0x01, 0xe0, 0x03, 0x80, 0x01, 0xe0, 0x03, 0x80, 0x01, 0xe0, 0x03, 0x80,
X   0x01, 0xe0, 0x03, 0x80, 0x01, 0xc0, 0x01, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff};
X#define six_width 32
X#define six_height 32
Xstatic char six_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0xc0, 0x07, 0x80, 0x01, 0xe0, 0x0f, 0x80,
X   0x01, 0x78, 0x1e, 0x80, 0x01, 0x38, 0x1e, 0x80, 0x01, 0x3c, 0x1e, 0x80,
X   0x01, 0x1c, 0x00, 0x80, 0x01, 0x1c, 0x00, 0x80, 0x01, 0x1c, 0x00, 0x80,
X   0x01, 0x9c, 0x07, 0x80, 0x01, 0xfc, 0x3f, 0x80, 0x01, 0x3c, 0x3c, 0x80,
X   0x01, 0x1c, 0x3c, 0x80, 0x01, 0x1c, 0x38, 0x80, 0x01, 0x1c, 0x38, 0x80,
X   0x01, 0x1c, 0x38, 0x80, 0x01, 0x3c, 0x3c, 0x80, 0x01, 0x78, 0x1e, 0x80,
X   0x01, 0xf0, 0x0f, 0x80, 0x01, 0xe0, 0x07, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff};
X#define three_width 32
X#define three_height 32
Xstatic char three_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0xf0, 0x03, 0x80, 0x01, 0xfc, 0x0f, 0x80, 0x01, 0x1c, 0x1f, 0x80,
X   0x01, 0x1e, 0x3e, 0x80, 0x01, 0x3e, 0x3e, 0x80, 0x01, 0x3e, 0x3e, 0x80,
X   0x01, 0x1c, 0x3e, 0x80, 0x01, 0x00, 0x1f, 0x80, 0x01, 0xe0, 0x03, 0x80,
X   0x01, 0xe0, 0x01, 0x80, 0x01, 0x00, 0x0f, 0x80, 0x01, 0x00, 0x3f, 0x80,
X   0x01, 0x00, 0x3e, 0x80, 0x01, 0x1c, 0x3c, 0x80, 0x01, 0x3e, 0x3c, 0x80,
X   0x01, 0x3e, 0x3c, 0x80, 0x01, 0x1e, 0x3e, 0x80, 0x01, 0x1c, 0x3f, 0x80,
X   0x01, 0xfc, 0x0f, 0x80, 0x01, 0xe0, 0x03, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff};
X#define two_width 32
X#define two_height 32
Xstatic char two_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0xf0, 0x03, 0x80, 0x01, 0xfc, 0x0f, 0x80, 0x01, 0x1c, 0x1f, 0x80,
X   0x01, 0x1e, 0x3c, 0x80, 0x01, 0x3e, 0x3c, 0x80, 0x01, 0x3e, 0x3c, 0x80,
X   0x01, 0x3c, 0x3e, 0x80, 0x01, 0x1c, 0x1e, 0x80, 0x01, 0x00, 0x0f, 0x80,
X   0x01, 0x80, 0x07, 0x80, 0x01, 0xc0, 0x03, 0x80, 0x01, 0xc0, 0x01, 0x80,
X   0x01, 0xc0, 0x20, 0x80, 0x01, 0x60, 0x20, 0x80, 0x01, 0x38, 0x30, 0x80,
X   0x01, 0xfc, 0x3f, 0x80, 0x01, 0xfc, 0x3f, 0x80, 0x01, 0xfe, 0x3f, 0x80,
X   0x01, 0xfe, 0x3f, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff};
X#define zero_width 32
X#define zero_height 32
Xstatic char zero_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0xc0, 0x03, 0x80, 0x01, 0xe0, 0x07, 0x80, 0x01, 0x70, 0x0e, 0x80,
X   0x01, 0x38, 0x1c, 0x80, 0x01, 0x3c, 0x3c, 0x80, 0x01, 0x3c, 0x3c, 0x80,
X   0x01, 0x3c, 0x3c, 0x80, 0x01, 0x3c, 0x3c, 0x80, 0x01, 0x3c, 0x3c, 0x80,
X   0x01, 0x3c, 0x3c, 0x80, 0x01, 0x3c, 0x3c, 0x80, 0x01, 0x3c, 0x3c, 0x80,
X   0x01, 0x3c, 0x3c, 0x80, 0x01, 0x3c, 0x3c, 0x80, 0x01, 0x3c, 0x3c, 0x80,
X   0x01, 0x3c, 0x3c, 0x80, 0x01, 0x38, 0x1c, 0x80, 0x01, 0x70, 0x0e, 0x80,
X   0x01, 0xe0, 0x07, 0x80, 0x01, 0xc0, 0x03, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff};
END_OF_FILE
if test 13143 -ne `wc -c <'xmines.icons'`; then
    echo shar: \"'xmines.icons'\" unpacked with wrong size!
fi
# end of 'xmines.icons'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
