Path: uunet!ogicse!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v15i001:  gtetris -  Generic Tetris for X11, Part01/02
Message-ID: <3645@master.CNA.TEK.COM>
Date: 23 Sep 92 19:12:31 GMT
Article-I.D.: master.3645
Sender: news@master.CNA.TEK.COM
Lines: 1818
Approved: billr@saab.CNA.TEK.COM

Submitted-by: "Qiang Alex Zhao" <azhao@cs.arizona.edu>
Posting-number: Volume 15, Issue 1
Archive-name: gtetris/Part01
Environment: X11R4/5, Xlib

	[I built and ran this, just changing the paths in the Makefile.  -br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 2)."
# Contents:  README MANIFEST COPYRIGHT data.h tetris.c tetris.h
# Wrapped by billr@saab on Wed Sep 23 12:10:55 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(2210 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X	GENERIC TETRIS
X	==============	Yet Another Tetris Game on X, V1.3
X
X
XWHY ANOTHER?
X
X    Because this one is simple, easy to build, and portable -- actually
X    the blocks are bigger, more comfortable for your eyes. It only uses
X    Xlib -- no "toolkit" kind of thing. I have tested it without
X    modification on the following platforms:
X
X	Sun4, SPARC-2		SunOS 4.1.1	X11R4, X11R5
X	Iris 4D			IRIX 4.0.1	X11R4
X	Sequent S81		DYNIX 3.2.0	X11R5
X
X    If your's is not in this list, please let me know -- thanks.
X
X
XHOW TO BUILD?
X
X    "Make" it. If you want to put the score-file at a different
X    location (I bet you would), edit the Makefile correspondingly.
X
X    "Tetris" is the game. It only lists the top 15 players at the end.
X    "Tscores" will list all the players/scores for you.
X
X
XANYTHING SPECIAL IN PLAYING?
X
X    Use "j" to move left; "l" to move right; "k" to rotate. Left-handed
X    people may want to use "s", "d", "f" respectively. Use the space
X    bar to drop a block quickly.
X
X    Use CTRL-L key combination to redraw -- in case it mess somthing up.
X
X    As usual, "+" and "-" will speed up or lower down the speed. Note
X    that you don't need to press the SHIFT key -- "=" and "_" also
X    work.
X
X    If you press CTRL-S or "p", the game will be paused, and the window
X    will be iconified -- just in case your boss suddenly appears at
X    your door. ;o)
X
X
XFOUND A BUG?
X
X    Send bugs (or their reports, or fixes) to the author:
X
X	Qiang Alex Zhao,	azhao@cs.arizona.edu
X	Computer Science Department
X	University of Arizona
X	Tucson, AZ 85721
X
X    Refter to the "COPYRIGHT" notice in the "COPYRIGHT" file (yeah, as
X    its name implies).
X
X
XHISTORY -- Oh no, not again: I failed in my history course!
XWell ... ACKNOWLEDGEMENTS
X
X    I studied an old tetris game for X10, wrote by Wayne Christopher
X    <faustus@cs.berkeley.edu> in 1988; then I adopted the ideas in
X    representing those "blocks" and rotating them, and added X11
X    stuff. Also I learned a lot from Nathan Sidwell's great game
X    "xmris", e.g. the "iconifying pause".
X
XCHANGES
X
X  [Sep 23, 92]  V1.3: Scoring -- a line in a higher level worth more
X		points; "tscores" program.
X
X  [Sep ??, 92]	First set of versions, 1.0 through 1.2.
X
END_OF_FILE
if test 2210 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(393 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X COPYRIGHT                  1	
X MANIFEST                   1	This shipping list
X Makefile                   2	
X README                     1	
X data.h                     1	
X die.c                      2	
X tetris.c                   1	
X tetris.h                   1	
X tscores.c                  2	
END_OF_FILE
if test 393 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'COPYRIGHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'COPYRIGHT'\"
else
echo shar: Extracting \"'COPYRIGHT'\" \(848 characters\)
sed "s/^X//" >'COPYRIGHT' <<'END_OF_FILE'
X# GENERIC X-WINDOW-BASED TETRIS
X#
X#  Copyright (C) 1992	Qiang Alex Zhao
X#			Computer Science Dept, University of Arizona
X#			azhao@cs.arizona.edu
X#
X#			All Rights Reserved
X#
X#  Permission to use, copy, modify, and distribute this software and
X#  its documentation for any purpose and without fee is hereby granted,
X#  provided that the above copyright notice appear in all copies and
X#  that both that copyright notice and this permission notice appear in
X#  supporting documentation, and that the name of the author not be
X#  used in advertising or publicity pertaining to distribution of the
X#  software without specific, written prior permission.
X#
X#  This program is distributed in the hope that it will be "playable",
X#  but WITHOUT ANY WARRANTY; without even the implied warranty of
X#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
X#
X
END_OF_FILE
if test 848 -ne `wc -c <'COPYRIGHT'`; then
    echo shar: \"'COPYRIGHT'\" unpacked with wrong size!
fi
# end of 'COPYRIGHT'
fi
if test -f 'data.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data.h'\"
else
echo shar: Extracting \"'data.h'\" \(19903 characters\)
sed "s/^X//" >'data.h' <<'END_OF_FILE'
X/*
X# GENERIC X-WINDOW-BASED TETRIS
X#
X#	data.h
X#
X###
X#
X#  Copyright (C) 1992	Qiang Alex Zhao
X#			Computer Science Dept, University of Arizona
X#			azhao@cs.arizona.edu
X#
X#			All Rights Reserved
X#
X#  Permission to use, copy, modify, and distribute this software and
X#  its documentation for any purpose and without fee is hereby granted,
X#  provided that the above copyright notice appear in all copies and
X#  that both that copyright notice and this permission notice appear in
X#  supporting documentation, and that the name of the author not be
X#  used in advertising or publicity pertaining to distribution of the
X#  software without specific, written prior permission.
X#
X#  This program is distributed in the hope that it will be "playable",
X#  but WITHOUT ANY WARRANTY; without even the implied warranty of
X#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
X#
X*/
X
X#define rot00_width 30
X#define rot00_height 30
Xstatic char rot00_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x03, 0xf8, 0xff, 0xff, 0x07,
X   0x5c, 0x55, 0x55, 0x0f, 0xae, 0xaa, 0xaa, 0x1e, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0x6a, 0xaa, 0x1a,
X   0x56, 0x95, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x5e, 0x55, 0x55, 0x1d, 0xbc, 0xaa, 0xaa, 0x0e,
X   0xf8, 0xff, 0xff, 0x07, 0xf0, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00};
X
X#define rot01_width 30
X#define rot01_height 30
Xstatic char rot01_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x03, 0xff, 0xff, 0xff, 0x07,
X   0x55, 0x55, 0x55, 0x0f, 0xaa, 0xaa, 0xaa, 0x1e, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0x6a, 0xaa, 0x1a,
X   0x55, 0x95, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x0e,
X   0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00};
X
X#define rot02_width 30
X#define rot02_height 30
Xstatic char rot02_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x03, 0xf8, 0xff, 0xff, 0x07,
X   0x5c, 0x55, 0x55, 0x0f, 0xae, 0xaa, 0xaa, 0x1e, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0x6a, 0xaa, 0x1a,
X   0x56, 0x95, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d};
X
X#define rot03_width 30
X#define rot03_height 30
Xstatic char rot03_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x03, 0xff, 0xff, 0xff, 0x07,
X   0x55, 0x55, 0x55, 0x0f, 0xaa, 0xaa, 0xaa, 0x1e, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0x6a, 0xaa, 0x1a,
X   0x55, 0x95, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x57, 0x55, 0x55, 0x1d, 0xaf, 0xaa, 0xaa, 0x1a, 0x57, 0x55, 0x55, 0x1d};
X
X#define rot04_width 30
X#define rot04_height 30
Xstatic char rot04_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x3f, 0xf8, 0xff, 0xff, 0x3f,
X   0x5c, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0x6a, 0xaa, 0x2a,
X   0x56, 0x95, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x5e, 0x55, 0x55, 0x15, 0xbc, 0xaa, 0xaa, 0x2a,
X   0xf8, 0xff, 0xff, 0x3f, 0xf0, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00};
X
X#define rot05_width 30
X#define rot05_height 30
Xstatic char rot05_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0x3f,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0x6a, 0xaa, 0x2a,
X   0x55, 0x95, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00};
X
X#define rot06_width 30
X#define rot06_height 30
Xstatic char rot06_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x3f, 0xf8, 0xff, 0xff, 0x3f,
X   0x5c, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0x6a, 0xaa, 0x2a,
X   0x56, 0x95, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x3d, 0xae, 0xaa, 0xaa, 0x3a, 0x56, 0x55, 0x55, 0x3d};
X
X#define rot07_width 30
X#define rot07_height 30
Xstatic char rot07_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0x3f,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0x6a, 0xaa, 0x2a,
X   0x55, 0x95, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0x57, 0x55, 0x55, 0x3d, 0xaf, 0xaa, 0xaa, 0x3a, 0x57, 0x55, 0x55, 0x3d};
X
X#define rot08_width 30
X#define rot08_height 30
Xstatic char rot08_bits[] = {
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0x6a, 0xaa, 0x1a,
X   0x56, 0x95, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x5e, 0x55, 0x55, 0x1d, 0xbc, 0xaa, 0xaa, 0x0e,
X   0xf8, 0xff, 0xff, 0x07, 0xf0, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00};
X
X#define rot09_width 30
X#define rot09_height 30
Xstatic char rot09_bits[] = {
X   0xaf, 0xaa, 0xaa, 0x1a, 0x57, 0x55, 0x55, 0x1d, 0xaf, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0x6a, 0xaa, 0x1a,
X   0x55, 0x95, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x0e,
X   0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00};
X
X#define rot10_width 30
X#define rot10_height 30
Xstatic char rot10_bits[] = {
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0x6a, 0xaa, 0x1a,
X   0x56, 0x95, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d};
X
X#define rot11_width 30
X#define rot11_height 30
Xstatic char rot11_bits[] = {
X   0xaf, 0xaa, 0xaa, 0x1a, 0x57, 0x55, 0x55, 0x1d, 0xaf, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0x6a, 0xaa, 0x1a,
X   0x55, 0x95, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x57, 0x55, 0x55, 0x1d, 0xaf, 0xaa, 0xaa, 0x1a, 0x57, 0x55, 0x55, 0x1d};
X
X#define rot12_width 30
X#define rot12_height 30
Xstatic char rot12_bits[] = {
X   0xae, 0xaa, 0xaa, 0x3a, 0x56, 0x55, 0x55, 0x3d, 0xae, 0xaa, 0xaa, 0x3a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0x6a, 0xaa, 0x2a,
X   0x56, 0x95, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x5e, 0x55, 0x55, 0x15, 0xbc, 0xaa, 0xaa, 0x2a,
X   0xf8, 0xff, 0xff, 0x3f, 0xf0, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00};
X
X#define rot13_width 30
X#define rot13_height 30
Xstatic char rot13_bits[] = {
X   0xaf, 0xaa, 0xaa, 0x3a, 0x57, 0x55, 0x55, 0x3d, 0xaf, 0xaa, 0xaa, 0x3a,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0x6a, 0xaa, 0x2a,
X   0x55, 0x95, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00};
X
X#define rot14_width 30
X#define rot14_height 30
Xstatic char rot14_bits[] = {
X   0xae, 0xaa, 0xaa, 0x3a, 0x56, 0x55, 0x55, 0x3d, 0xae, 0xaa, 0xaa, 0x3a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0x6a, 0xaa, 0x2a,
X   0x56, 0x95, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x3d, 0xae, 0xaa, 0xaa, 0x3a, 0x56, 0x55, 0x55, 0x3d};
X
Xstruct bitmap_datum {
X    char           *data;
X    int             height, width;
X}               bitmap_data[] = {
X
X    {
X	rot00_bits, rot00_height, rot00_width
X    },
X    {
X	rot01_bits, rot01_height, rot01_width
X    },
X    {
X	rot02_bits, rot02_height, rot02_width
X    },
X    {
X	rot03_bits, rot03_height, rot03_width
X    },
X    {
X	rot04_bits, rot04_height, rot04_width
X    },
X    {
X	rot05_bits, rot05_height, rot05_width
X    },
X    {
X	rot06_bits, rot06_height, rot06_width
X    },
X    {
X	rot07_bits, rot07_height, rot07_width
X    },
X    {
X	rot08_bits, rot08_height, rot08_width
X    },
X    {
X	rot09_bits, rot09_height, rot09_width
X    },
X    {
X	rot10_bits, rot10_height, rot10_width
X    },
X    {
X	rot11_bits, rot11_height, rot11_width
X    },
X    {
X	rot12_bits, rot12_height, rot12_width
X    },
X    {
X	rot13_bits, rot13_height, rot13_width
X    },
X    {
X	rot14_bits, rot14_height, rot14_width
X    }
X};
X
Xpattern_t       patterns[] = {
X    {0, "magenta", "white", 0, 0, 0},
X    {1, "magenta", "white", 0, 0, 0},
X    {2, "magenta", "white", 0, 0, 0},
X    {3, "magenta", "white", 0, 0, 0},
X    {4, "magenta", "white", 0, 0, 0},
X    {5, "magenta", "white", 0, 0, 0},
X    {6, "magenta", "white", 0, 0, 0},
X    {7, "magenta", "white", 0, 0, 0},
X    {8, "magenta", "white", 0, 0, 0},
X    {9, "magenta", "white", 0, 0, 0},
X    {10, "magenta", "white", 0, 0, 0},
X    {11, "magenta", "white", 0, 0, 0},
X    {12, "magenta", "white", 0, 0, 0},
X    {13, "magenta", "white", 0, 0, 0},
X    {14, "magenta", "white", 0, 0, 0},
X    {0, "magenta", "white", 0, 0, 0},
X    {0, "forest green", "white", 0, 0, 0},
X    {1, "forest green", "white", 0, 0, 0},
X    {2, "forest green", "white", 0, 0, 0},
X    {3, "forest green", "white", 0, 0, 0},
X    {4, "forest green", "white", 0, 0, 0},
X    {5, "forest green", "white", 0, 0, 0},
X    {6, "forest green", "white", 0, 0, 0},
X    {7, "forest green", "white", 0, 0, 0},
X    {8, "forest green", "white", 0, 0, 0},
X    {9, "forest green", "white", 0, 0, 0},
X    {10, "forest green", "white", 0, 0, 0},
X    {11, "forest green", "white", 0, 0, 0},
X    {12, "forest green", "white", 0, 0, 0},
X    {13, "forest green", "white", 0, 0, 0},
X    {14, "forest green", "white", 0, 0, 0},
X    {0, "forest green", "white", 0, 0, 0},
X    {0, "blue", "white", 0, 0, 0},
X    {1, "blue", "white", 0, 0, 0},
X    {2, "blue", "white", 0, 0, 0},
X    {3, "blue", "white", 0, 0, 0},
X    {4, "blue", "white", 0, 0, 0},
X    {5, "blue", "white", 0, 0, 0},
X    {6, "blue", "white", 0, 0, 0},
X    {7, "blue", "white", 0, 0, 0},
X    {8, "blue", "white", 0, 0, 0},
X    {9, "blue", "white", 0, 0, 0},
X    {10, "blue", "white", 0, 0, 0},
X    {11, "blue", "white", 0, 0, 0},
X    {12, "blue", "white", 0, 0, 0},
X    {13, "blue", "white", 0, 0, 0},
X    {14, "blue", "white", 0, 0, 0},
X    {0, "blue", "white", 0, 0, 0},
X    {0, "red", "white", 0, 0, 0},
X    {1, "red", "white", 0, 0, 0},
X    {2, "red", "white", 0, 0, 0},
X    {3, "red", "white", 0, 0, 0},
X    {4, "red", "white", 0, 0, 0},
X    {5, "red", "white", 0, 0, 0},
X    {6, "red", "white", 0, 0, 0},
X    {7, "red", "white", 0, 0, 0},
X    {8, "red", "white", 0, 0, 0},
X    {9, "red", "white", 0, 0, 0},
X    {10, "red", "white", 0, 0, 0},
X    {11, "red", "white", 0, 0, 0},
X    {12, "red", "white", 0, 0, 0},
X    {13, "red", "white", 0, 0, 0},
X    {14, "red", "white", 0, 0, 0},
X    {0, "red", "white", 0, 0, 0},
X    {0, "dark turquoise", "white", 0, 0, 0},
X    {1, "dark turquoise", "white", 0, 0, 0},
X    {2, "dark turquoise", "white", 0, 0, 0},
X    {3, "dark turquoise", "white", 0, 0, 0},
X    {4, "dark turquoise", "white", 0, 0, 0},
X    {5, "dark turquoise", "white", 0, 0, 0},
X    {6, "dark turquoise", "white", 0, 0, 0},
X    {7, "dark turquoise", "white", 0, 0, 0},
X    {8, "dark turquoise", "white", 0, 0, 0},
X    {9, "dark turquoise", "white", 0, 0, 0},
X    {10, "dark turquoise", "white", 0, 0, 0},
X    {11, "dark turquoise", "white", 0, 0, 0},
X    {12, "dark turquoise", "white", 0, 0, 0},
X    {13, "dark turquoise", "white", 0, 0, 0},
X    {14, "dark turquoise", "white", 0, 0, 0},
X    {0, "dark turquoise", "white", 0, 0, 0},
X    {0, "black", "white", 0, 0, 0},
X    {1, "black", "white", 0, 0, 0},
X    {2, "black", "white", 0, 0, 0},
X    {3, "black", "white", 0, 0, 0},
X    {4, "black", "white", 0, 0, 0},
X    {5, "black", "white", 0, 0, 0},
X    {6, "black", "white", 0, 0, 0},
X    {7, "black", "white", 0, 0, 0},
X    {8, "black", "white", 0, 0, 0},
X    {9, "black", "white", 0, 0, 0},
X    {10, "black", "white", 0, 0, 0},
X    {11, "black", "white", 0, 0, 0},
X    {12, "black", "white", 0, 0, 0},
X    {13, "black", "white", 0, 0, 0},
X    {14, "black", "white", 0, 0, 0},
X    {0, "brown", "white", 0, 0, 0},
X    {0, "brown", "white", 0, 0, 0},
X    {1, "brown", "white", 0, 0, 0},
X    {2, "brown", "white", 0, 0, 0},
X    {3, "brown", "white", 0, 0, 0},
X    {4, "brown", "white", 0, 0, 0},
X    {5, "brown", "white", 0, 0, 0},
X    {6, "brown", "white", 0, 0, 0},
X    {7, "brown", "white", 0, 0, 0},
X    {8, "brown", "white", 0, 0, 0},
X    {9, "brown", "white", 0, 0, 0},
X    {10, "brown", "white", 0, 0, 0},
X    {11, "brown", "white", 0, 0, 0},
X    {12, "brown", "white", 0, 0, 0},
X    {13, "brown", "white", 0, 0, 0},
X    {14, "brown", "white", 0, 0, 0},
X    {0, "brown", "white", 0, 0, 0}
X};
X
X#define NUM_PATTERNS	(sizeof (patterns) / sizeof (patterns[0]))
X
Xint             num_patterns = NUM_PATTERNS;
X
Xthing_t         possible[] = {
X
X    {{{0, 0, 0, 0},
X    {1, 1, 1, 1},
X    {0, 0, 0, 0},
X    {0, 0, 0, 0}}, 0, 0, 4, 1},
X
X    {{{0, 1, 0, 0},
X    {0, 1, 0, 0},
X    {1, 1, 0, 0},
X    {0, 0, 0, 0}}, 0, 0, 3, 1},
X
X    {{{1, 0, 0, 0},
X    {1, 0, 0, 0},
X    {1, 1, 0, 0},
X    {0, 0, 0, 0}}, 0, 0, 3, 1},
X
X    {{{0, 1, 0, 0},
X    {1, 1, 0, 0},
X    {1, 0, 0, 0},
X    {0, 0, 0, 0}}, 0, 0, 3, 1},
X
X    {{{1, 0, 0, 0},
X    {1, 1, 0, 0},
X    {0, 1, 0, 0},
X    {0, 0, 0, 0}}, 0, 0, 3, 1},
X
X    {{{1, 1, 0, 0},
X    {1, 1, 0, 0},
X    {0, 0, 0, 0},
X    {0, 0, 0, 0}}, 0, 0, 2, 1},
X
X    {{{0, 1, 0, 0},
X    {1, 1, 1, 0},
X    {0, 0, 0, 0},
X    {0, 0, 0, 0}}, 0, 0, 3, 2},
X};
X
X#define NUM_POSSIBLE	(sizeof (possible) / sizeof (possible[0]))
X
Xint             speeds[NUM_LEVELS] =
X	{100, 80, 65, 50, 40, 33, 26, 20, 15, 10, 7, 5};
X
Xint             thresh[NUM_LEVELS] =
X	{10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, INF};
X
X/* variables used in tetris.c */
X
XXColor          bgcolor, bdcolor, titlecolor, textcolor;
XColormap        cmap;
X
XDisplay        *disp;
XGC              gc_t;
XGC              gc_w;
XGC              gc_w2;
XGC              gc_ttx;
XGC              gc_wtx;
XGC              gc_pat[NUM_PATTERNS];
XXGCValues       gcv;
XXGCValues       color;
XXGCValues       text;
X
END_OF_FILE
if test 19903 -ne `wc -c <'data.h'`; then
    echo shar: \"'data.h'\" unpacked with wrong size!
fi
# end of 'data.h'
fi
if test -f 'tetris.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tetris.c'\"
else
echo shar: Extracting \"'tetris.c'\" \(23128 characters\)
sed "s/^X//" >'tetris.c' <<'END_OF_FILE'
X/*
X# GENERIC X-WINDOW-BASED TETRIS
X#
X#	tetris.c
X#
X###
X#
X#  Copyright (C) 1992	Qiang Alex Zhao
X#			Computer Science Dept, University of Arizona
X#			azhao@cs.arizona.edu
X#
X#			All Rights Reserved
X#
X#  Permission to use, copy, modify, and distribute this software and
X#  its documentation for any purpose and without fee is hereby granted,
X#  provided that the above copyright notice appear in all copies and
X#  that both that copyright notice and this permission notice appear in
X#  supporting documentation, and that the name of the author not be
X#  used in advertising or publicity pertaining to distribution of the
X#  software without specific, written prior permission.
X#
X#  This program is distributed in the hope that it will be "playable",
X#  but WITHOUT ANY WARRANTY; without even the implied warranty of
X#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
X#
X*/
X
X/* first tetris.h, then data.h */
X#include "tetris.h"
X#include "data.h"
X
Xvoid
Xmain(argc, argv)
X    int             argc;
X    char          **argv;
X{
X    int             start_level = 0, lines_full = 0;
X    field_t        *field;
X    thing_t        *thing = NULL;
X    int             readfds, writefds, exceptfds;
X    struct timeval  nextfall, now, delay;
X    struct timezone tzone;
X    Bool            reset_time = True;
X    char            buf[100];
X
X
X    fprintf(stderr, "\t\tGENERIC TETRIS V1.3\n");
X    fprintf(stderr, "\tCopyright (C) 1992	Qiang Alex Zhao\n\n");
X    fprintf(stderr, "GENERIC TETRIS comes with ABSOLUTELY NO WARRANTY.\n");
X    fprintf(stderr, "Send bug-reports/fixes/comments to:\n");
X    fprintf(stderr, "\tQiang Alex Zhao,	azhao@cs.arizona.edu\n");
X    fprintf(stderr, "\tComputer Science Dept, University of Arizona, Tucson\n\n");
X
X    /* initialization */
X
X    start_level = 3;
X    lines_full = 0;
X
X    if (argc > 3) {
X	Usage(argv);
X    }
X    if (argc > 1) {
X	if (sscanf(argv[1], "%d", &start_level) < 1) {
X	    Usage(argv);
X	}
X    }
X    if (argc > 2) {
X	if (sscanf(argv[2], "%d", &lines_full) < 1) {
X	    Usage(argv);
X	}
X    }
X
X    if (start_level < 0) start_level = 0;
X    if (start_level >= NUM_LEVELS) start_level = NUM_LEVELS - 1;
X    if (lines_full < 0) lines_full = 0;
X    if (lines_full >= DEF_HEIGHT - 2) lines_full = DEF_HEIGHT - 3;
X
X    srandom((int) time(NULL));
X
X    if ((disp = XOpenDisplay(NULL)) == NULL) {
X	fprintf(stderr, "Error: can't open display \"%s\".\n\n",
X		XDisplayName(NULL));
X	showHighScores(SHOWNSCORES/2);
X	exit(1);
X    }
X
X    /* rebinding keypad */
X    XRebindKeysym(disp, XK_R7,    NULL, 0, "j", sizeof(char));
X    XRebindKeysym(disp, XK_R10,   NULL, 0, "j", sizeof(char));
X    XRebindKeysym(disp, XK_R13,   NULL, 0, "j", sizeof(char));
X    XRebindKeysym(disp, XK_Left,  NULL, 0, "j", sizeof(char));
X    XRebindKeysym(disp, XK_R8,    NULL, 0, "k", sizeof(char));
X    XRebindKeysym(disp, XK_R11,   NULL, 0, "k", sizeof(char));
X    XRebindKeysym(disp, XK_R14,   NULL, 0, "k", sizeof(char));
X    XRebindKeysym(disp, XK_Up,    NULL, 0, "k", sizeof(char));
X    XRebindKeysym(disp, XK_Down,  NULL, 0, "k", sizeof(char));
X    XRebindKeysym(disp, XK_R9,    NULL, 0, "l", sizeof(char));
X    XRebindKeysym(disp, XK_R12,   NULL, 0, "l", sizeof(char));
X    XRebindKeysym(disp, XK_R15,   NULL, 0, "l", sizeof(char));
X    XRebindKeysym(disp, XK_Right, NULL, 0, "l", sizeof(char));
X
X    /* setting color */
X    if (XDisplayPlanes(disp, DefaultScreen(disp)) == 1) {
X	bgcolor.pixel = WhitePixel(disp, DefaultScreen(disp));
X	bdcolor.pixel = BlackPixel(disp, DefaultScreen(disp));
X	titlecolor.pixel = BlackPixel(disp, DefaultScreen(disp));
X	textcolor.pixel = BlackPixel(disp, DefaultScreen(disp));
X    } else {
X	cmap = XDefaultColormap(disp, DefaultScreen(disp));
X	XParseColor(disp, cmap, BG_COLOR, &bgcolor);
X	XAllocColor(disp, cmap, &bgcolor);
X	XParseColor(disp, cmap, BD_COLOR, &bdcolor);
X	XAllocColor(disp, cmap, &bdcolor);
X	XParseColor(disp, cmap, TITLE_COLOR, &titlecolor);
X	XAllocColor(disp, cmap, &titlecolor);
X	XParseColor(disp, cmap, TEXT_COLOR, &textcolor);
X	XAllocColor(disp, cmap, &textcolor);
X    }
X
X    /* initialize the playground */
X
X    field = initField(DEF_WIDTH, DEF_HEIGHT, lines_full);
X    XSelectInput(disp, field->title, ExposureMask);
X
X    initPixmaps(field);
X
X    field->level = start_level;
X
X    drawField(field);
X
X    sleep(1);
X    XSelectInput(disp, field->frame, KeyPressMask | ExposureMask | 
X	StructureNotifyMask);
X
X    while (True) {
X	if (reset_time) {
X	    gettimeofday(&nextfall, &tzone);
X	    nextfall.tv_usec += 10000 * speeds[field->level];
X	    normTimeVal(&nextfall);
X	}
X	if (XPending(disp))
X	    handleEvents(field, &thing, False);
X	gettimeofday(&now, &tzone);
X	delay.tv_sec = nextfall.tv_sec - now.tv_sec;
X	delay.tv_usec = nextfall.tv_usec - now.tv_usec;
X	normTimeVal(&delay);
X	if (delay.tv_sec >= 0) {
X	    writefds = exceptfds = 0;
X	    readfds = 1 << ConnectionNumber(disp);
X	    (void) select(sizeof(int) * 8, (fd_set *) &readfds, (fd_set *)
X		&writefds, (fd_set *) &exceptfds, &delay);
X	}
X	gettimeofday(&now, &tzone);
X	if ((now.tv_sec > nextfall.tv_sec) ||
X		((now.tv_sec == nextfall.tv_sec) &&
X		 (now.tv_usec > nextfall.tv_usec))) {
X	    handleEvents(field, &thing, True);
X	    reset_time = True;
X	} else {
X	    handleEvents(field, &thing, False);
X	    reset_time = False;
X	}
X    }
X    /* never come to here */
X}
X
Xvoid
XnormTimeVal(tv)
X    struct timeval *tv;
X{
X    while (tv->tv_usec < 0) {
X	tv->tv_sec--;
X	tv->tv_usec += MILLION;
X    }
X    while (tv->tv_usec >= MILLION) {
X	tv->tv_sec++;
X	tv->tv_usec -= MILLION;
X    }
X
X    return;
X}
X
Xvoid
XfallDown(field, thingp, eat)
X    field_t        *field;
X    thing_t       **thingp;
X    Bool            eat;
X{
X    int             lines;
X    XEvent          event;
X
X    putBoxes(field, *thingp);
X
X    lines = checkLine(field);
X    field->score += 5 + 5 * field->level * field->level * lines;
X    field->lines += lines;
X    if (field->lines >= thresh[field->level])
X    	field->level++;
X    updateScore(field);
X
X    free((char *) *thingp);
X    if (eat) {
X	*thingp = NULL;
X	while (XPending(disp)) XNextEvent(disp, &event);
X    }
X    *thingp = makeNewThing(field);
X    if (overlapping(field, *thingp)) die(field);
X    drawThing(field, *thingp);
X}
X
Xvoid
XhandleEvents(field, thingp, fall_down)
X    field_t        *field;
X    thing_t       **thingp;
X    Bool            fall_down;
X{
X    static Bool     frozen = False;
X    XEvent          event;
X    int             highest;
X    char            s[4];
X    int             n;
X
X    if (frozen) fall_down = False;
X
X    if (!*thingp) {
X	*thingp = makeNewThing(field);
X	if (overlapping(field, *thingp))
X	    die(field);
X	drawThing(field, *thingp);
X	XSync(disp, 0);
X    }
X    if (fall_down && atBottom(field, *thingp)) {
X	fallDown(field, thingp, False);
X	fall_down = False;
X    }
X    if (!XPending(disp) && !frozen)
X	moveOne(field, *thingp, NONE, fall_down);
X
X    while (XPending(disp)) {
X	if (overlapping(field, *thingp))
X	    die(field);
X
X	XNextEvent(disp, &event);
X	switch (event.type) {
X	case KeyPress:
X	    n = XLookupString(&event, s, 4, NULL, NULL);
X	    if (!n)
X		break;
X	    switch (*s) {
X	    case 'j':		/* Move left. */
X	    case 'J':
X	    case 's':
X	    case 'S':
X		if (!frozen)
X		    moveOne(field, *thingp, LEFT,
X			    fall_down);
X		break;
X
X	    case 'k':		/* Rotate. */
X	    case 'K':
X	    case 'd':
X	    case 'D':
X		if (!frozen)
X		    moveOne(field, *thingp, ROTATE,
X			    fall_down);
X		break;
X
X	    case 'l':		/* Move right. */
X	    case 'L':
X	    case 'f':
X	    case 'F':
X		if (!frozen)
X		    moveOne(field, *thingp, RIGHT,
X			    fall_down);
X		break;
X
X	    case ' ':		/* Drop. */
X	    case '\n':
X		if (!frozen) {
X		    moveOne(field, *thingp, DROP, fall_down);
X		    fallDown(field, thingp, True);
X		}
X		return;
X		break;
X
X	    case 'q':		/* Quit. */
X	    case 'Q':
X		die(field);
X		break;
X
X	    case '+':		/* Speed up. */
X	    case '=':
X		if (field->level < NUM_LEVELS - 1) {
X		    field->level++;
X		    updateScore(field);
X		}
X		break;
X
X	    case '-':		/* Slow down. */
X	    case '_':
X		if (field->level > 0) {
X		    field->level--;
X		    updateScore(field);
X		}
X		break;
X
X	    case '\023':	/* Freeze / continue. */
X	    case 'p':
X	    case 'P':
X		frozen = (frozen ? False : True);
X		/* flow to next */
X
X	    case '\014':		/* Redraw. */
X		/* "... Hi Boss, I'm working hard as usual ..." */
X		XClearWindow(disp, field->win);
X		drawField(field);
X		if (*thingp)
X		    drawThing(field, *thingp);
X		if (frozen) {
X		    banner(field, PAUSED_MESG);
X		    XIconifyWindow(disp, field->frame, DefaultScreen(disp));
X		}
X		/* flow to next */
X
X	    default:
X		XBell(disp, -25);
X		XFlush(disp);
X		break;
X	    }
X	    break;		/* processing key press */
X
X	case UnmapNotify:
X	    frozen = True;
X	    break;
X
X	case Expose:
X	    drawField(field);
X	    if (*thingp)
X		drawThing(field, *thingp);
X	    if (frozen) {
X		banner(field, PAUSED_MESG);
X	    }
X	    XFlush(disp);
X	    break;
X
X	}
X
X	fall_down = False;
X    }
X
X    return;
X}
X
Xvoid
XmoveOne(field, thing, what, fall_down)
X    field_t        *field;
X    thing_t        *thing;
X    command_t       what;
X    Bool            fall_down;
X{
X    thing_t         old;
X
X    old = *thing;
X
X    if (tryMove(field, thing, what, fall_down))
X	drawThingDiff(field, thing, &old);
X
X    XSync(disp, 0);
X    return;
X}
X
XBool
XtryMove(field, thing, what, fall_down)
X    field_t        *field;
X    thing_t        *thing;
X    command_t       what;
X    Bool            fall_down;
X{
X    int             x, y;
X    thing_t         temp;
X    Bool            ok = True;
X
X    temp = *thing;
X
X    if (fall_down)
X	temp.ypos--;
X    switch (what) {
X    case LEFT:
X	temp.xpos--;
X	break;
X
X    case RIGHT:
X	temp.xpos++;
X	break;
X
X    case ROTATE:
X	rotateThing(&temp);
X	break;
X
X    case DROP:
X	while (!overlapping(field, &temp)) {
X	    field->score += field->level;
X	    temp.ypos--;
X	}
X	temp.ypos++;
X	break;
X
X    case NONE:
X	break;
X    }
X
X    for (x = 0; x < temp.size; x++)
X	for (y = 0; y < temp.size; y++) {
X	    if (temp.map[x][y]) {
X		if ((temp.xpos + x < 0) ||
X			(temp.xpos + x >= field->width) ||
X			(temp.ypos + y < 0) ||
X			(temp.ypos + y >= field->height) ||
X			(field->full[temp.xpos + x]
X			 [temp.ypos + y]))
X		    ok = False;
X	    }
X	}
X
X    if (ok)
X	*thing = temp;
X
X    if (overlapping(field, thing)) {
X	return (False);
X    } else {
X	return (True);
X    }
X}
X
XBool
XatBottom(field, thing)
X    field_t        *field;
X    thing_t        *thing;
X{
X    int             x, y;
X
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++)
X	    if (thing->map[x][y]) {
X		if (thing->ypos + y <= 0)
X		    return (True);
X		if (field->full[thing->xpos + x]
X			[thing->ypos + y - 1])
X		    return (True);
X	    }
X    return (False);
X}
X
Xvoid
XdrawThing(field, thing)
X    field_t        *field;
X    thing_t        *thing;
X{
X    int             x, y;
X
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++)
X	    if (thing->map[x][y])
X		doBox(field, thing->xpos + x, thing->ypos + y,
X		      thing->map[x][y]);
X    return;
X}
X
Xvoid
XdrawThingDiff(field, thing, oldthing)
X    field_t        *field;
X    thing_t        *thing, *oldthing;
X{
X    int             x, y;
X    int             ox, oy;
X
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++) {
X	    ox = x - oldthing->xpos + thing->xpos;
X	    oy = y - oldthing->ypos + thing->ypos;
X	    if (thing->map[x][y])
X		doBox(field, thing->xpos + x, thing->ypos + y,
X		      thing->map[x][y]);
X	}
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++) {
X	    ox = x - thing->xpos + oldthing->xpos;
X	    oy = y - thing->ypos + oldthing->ypos;
X	    if (oldthing->map[x][y] &&
X		    ((ox < 0) || (ox >= thing->size) ||
X		     (oy < 0) || (oy >= thing->size) ||
X		     !thing->map[ox][oy]))
X		doBox(field, oldthing->xpos + x,
X		      oldthing->ypos + y,
X		      0);
X	}
X    return;
X}
X
Xvoid
XdoBox(field, x, y, pat)
X    field_t        *field;
X    int             x, y;
X    int             pat;
X{
X    if ((x < 0) || (x >= field->width) || (y < 0) || (y >= field->height))
X	abort();
X    if (pat == 0)
X	XFillRectangle(disp, field->win, gc_w2,
X		       x * BOX_WIDTH + X_MARGIN,
X		       ytr((y + 1) * BOX_HEIGHT + Y_MARGIN) - 1,
X		       BOX_WIDTH + 1, BOX_HEIGHT + 1);
X    else {
X	if (XDisplayPlanes(disp, DefaultScreen(disp)) == 1) {
X	    pat = pat % 16 - 1;
X	    XCopyPlane(disp, patterns[pat].pixmap, field->win, gc_w,
X		       0, 0,
X		       BOX_WIDTH, BOX_HEIGHT,
X		       x * BOX_WIDTH + X_MARGIN,
X		       ytr((y + 1) * BOX_HEIGHT + Y_MARGIN), 1);
X	} else {
X	    pat -= 1;
X	    XCopyPlane(disp, patterns[pat].pixmap, field->win,
X		       gc_pat[pat],
X		       0, 0,
X		       BOX_WIDTH, BOX_HEIGHT,
X		       x * BOX_WIDTH + X_MARGIN,
X		       ytr((y + 1) * BOX_HEIGHT + Y_MARGIN), 1);
X	}
X    }
X    return;
X}
X
XBool
Xoverlapping(field, thing)
X    field_t        *field;
X    thing_t        *thing;
X{
X    int             x, y;
X
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++) {
X	    if (thing->map[x][y] && (thing->ypos + y < 0))
X		return (True);
X	    if (thing->map[x][y] && field->full[thing->xpos + x]
X		    [thing->ypos + y])
X		return (True);
X	}
X    return (False);
X}
X
Xint
XputBoxes(field, thing)
X    field_t        *field;
X    thing_t        *thing;
X{
X    int             x, y;
X    int             highest = 0;
X
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++)
X	    if (thing->map[x][y]) {
X		if ((thing->xpos + x < 0) ||
X			(thing->xpos + x >= field->width) ||
X			(thing->ypos + y < 0) ||
X			(thing->ypos + y >= field->height))
X		    abort();
X		field->full[thing->xpos + x][thing->ypos + y]
X		    = thing->map[x][y];
X		if (thing->ypos + y > highest)
X		    highest = thing->ypos + y;
X	    }
X    return (highest);
X}
X
Xfield_t        *
XinitField(width, height, lines_full)
X    int             width, height;
X    int             lines_full;
X{
X    Cursor          cursor;
X    XSizeHints      sh;
X    field_t        *field = (field_t *) malloc(sizeof(field_t));
X    int             x, y, w, h;;
X
X    w = width * BOX_WIDTH + 2 * X_MARGIN;
X    h = height * BOX_HEIGHT + 2 * Y_MARGIN + TITLE_HEIGHT;
X
X    field->width = width;
X    field->height = height;
X    field->score = 0;
X    field->level = 1;
X    field->lines = 0;
X
X    field->frame = XCreateSimpleWindow(disp, DefaultRootWindow(disp),
X	BASE_XPOS, BASE_YPOS, w, h, BORDER_WIDTH, bdcolor.pixel, bgcolor.pixel);
X
X    cursor = XCreateFontCursor(disp, XC_exchange);
X    XDefineCursor(disp, field->frame, cursor);
X    XSetStandardProperties(disp, field->frame, "GENERIC TETRIS",
X	"GENERIC TETRIS", None, NULL, 0, NULL);
X
X    sh.flags = PSize | PMinSize | PMaxSize;
X    sh.width = (sh.min_width = (sh.max_width = w));
X    sh.height = (sh.min_height = (sh.max_height = h));
X    XSetWMNormalHints(disp, field->frame, &sh);
X
X    field->title = XCreateSimpleWindow(disp, field->frame,
X	-BORDER_WIDTH, -BORDER_WIDTH, w, TITLE_HEIGHT, BORDER_WIDTH,
X	bdcolor.pixel, bgcolor.pixel);
X
X    field->win = XCreateSimpleWindow(disp, field->frame,
X	-BORDER_WIDTH, TITLE_HEIGHT - BORDER_WIDTH, w, h - TITLE_HEIGHT,
X	BORDER_WIDTH, bdcolor.pixel, bgcolor.pixel);
X
X    if (XDisplayPlanes(disp, DefaultScreen(disp)) == 1)
X	num_patterns = NUM_BITMAPS;
X
X    field->full = (int **) malloc(sizeof(int *) * width);
X    for (x = 0; x < width; x++) {
X	field->full[x] = (int *) malloc(sizeof(int) * height);
X	for (y = 0; y < height; y++)
X	    if ((y < lines_full) && nrandom(2))
X		field->full[x][y] = nrandom(num_patterns);
X	    else
X		field->full[x][y] = 0;
X    }
X
X    /* loading fonts */
X    field->tfont = XLoadQueryFont(disp, TITLE_FONT);
X    field->sfont = XLoadQueryFont(disp, SCORE_FONT);
X    if (field->tfont == NULL) {
X	field->tfont = XLoadQueryFont(disp, "-*-fixed-*-r-*-*-24-*-*-*-*-*-*-*");
X	assert(field->tfont);
X    }
X    if (field->sfont == NULL) {
X	field->sfont = XLoadQueryFont(disp, "-*-fixed-*-r-*-*-12-*-*-*-*-*-*-*");
X	assert(field->sfont);
X    }
X
X    field->winheight = field->height * BOX_HEIGHT + 2 * Y_MARGIN;
X    field->winwidth = field->width * BOX_WIDTH + 2 * X_MARGIN;
X
X    XMapWindow(disp, field->title);
X    XMapWindow(disp, field->win);
X    XMapRaised(disp, field->frame);
X
X    gcv.function = GXcopy;
X    gcv.foreground = bdcolor.pixel;
X    gcv.background = bgcolor.pixel;
X
X    gc_t = XCreateGC(disp, field->title, (GCForeground | GCBackground |
X					  GCFunction), &gcv);
X    gc_w = XCreateGC(disp, field->win, (GCForeground | GCBackground |
X					GCFunction), &gcv);
X
X    gcv.background = bdcolor.pixel;
X    gcv.foreground = bgcolor.pixel;
X
X    gc_w2 = XCreateGC(disp, field->win, (GCForeground | GCBackground |
X					 GCFunction), &gcv);
X
X    text.function = GXcopy;
X    text.font = field->tfont->fid;
X    text.foreground = bdcolor.pixel;
X    text.background = bgcolor.pixel;
X    gc_ttx = XCreateGC(disp, field->title, (GCFunction | GCFont |
X				       GCForeground | GCBackground), &text);
X    text.font = field->sfont->fid;
X    gc_wtx = XCreateGC(disp, field->title, (GCFunction | GCFont |
X				       GCForeground | GCBackground), &text);
X
X    XFlush(disp);
X    return (field);
X}
X
Xvoid
XdrawField(field)
X    field_t        *field;
X{
X    int             x, y;
X
X    for (x = 0; x < field->width; x++)
X	for (y = 0; y < field->height; y++)
X	    doBox(field, x, y, field->full[x][y]);
X
X    XDrawImageString(disp, field->title, gc_ttx, 3, 30, "TETRIS", 6);
X
X    updateScore(field);
X
X    XFlush(disp);
X    return;
X}
X
Xvoid
XupdateScore(field)
X    field_t        *field;
X{
X    char            buf[100];
X
X    (void) sprintf(buf, "Score: %-7d", field->score);
X    XDrawImageString(disp, field->title, gc_wtx,
X		     SCORE_XPOS1, SCORE_YPOS1, buf, strlen(buf));
X
X    (void) sprintf(buf, "Level: %-7d", field->level);
X    XDrawImageString(disp, field->title, gc_wtx,
X		     SCORE_XPOS1, SCORE_YPOS2, buf, strlen(buf));
X
X    (void) sprintf(buf, "Lines: %-7d", field->lines);
X    XDrawImageString(disp, field->title, gc_wtx,
X		     SCORE_XPOS2, SCORE_YPOS2, buf, strlen(buf));
X
X    XFlush(disp);
X    return;
X}
X
Xthing_t        *
XmakeNewThing(field)
X    field_t        *field;
X{
X    int             i, j, k;
X    int             pat;
X    int             whichone;
X    thing_t        *thing = (thing_t *) malloc(sizeof(thing_t));
X
X    i = 0;
X    for (j = 0; j < NUM_POSSIBLE; j++)
X	i += possible[j].probability;
X
X    k = nrandom(i);
X
X    for (j = 0; j < NUM_POSSIBLE; j++) {
X	k -= possible[j].probability;
X	if (k < 0)
X	    break;
X    }
X
X    *thing = possible[j];
X    whichone = j;
X    for (i = 0; i < thing->size; i++)
X	for (j = 0; j < thing->size; j++)
X	    if (thing->map[i][j]) {
X		pat = 1;
X		if (i != 0 && thing->map[i - 1][j])
X		    pat += 1;
X		if (j != 0 && thing->map[i][j - 1])
X		    pat += 2;
X		if (i < thing->size - 1 && thing->map[i + 1][j])
X		    pat += 4;
X		if (j < thing->size - 1 && thing->map[i][j + 1])
X		    pat += 8;
X		thing->map[i][j] = pat + whichone * 16;
X	    }
X    for (i = nrandom(4); i > 0; i--)
X	rotateThing(thing);
X
X    thing->ypos = field->height - thing->size;
X    thing->xpos = nrandom((field->width - 2 * thing->size) + thing->size);
X
X    return (thing);
X}
X
Xvoid
XrotateThing(thing)
X    thing_t        *thing;
X{
X    thing_t         temp;
X    int             lpoint = thing->size;
X    int             nlpoint = thing->size;
X    int             x, y;
X    int             pattype;
X
X    temp = *thing;
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++)
X	    if (thing->map[x][y] && (lpoint < y))
X		lpoint = y;
X
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++) {
X	    pattype = (temp.map[y][thing->size - x - 1] - 1) / 16;
X	    thing->map[x][y] =
X		((((temp.map[y][thing->size - x - 1] & 15) - 1) * 2) % 15 + 1)
X		+ pattype * 16;
X	    if (thing->map[x][y] < 0)
X		thing->map[x][y] = 0;
X	}
X
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++)
X	    if (thing->map[x][y] && (nlpoint < y))
X		nlpoint = y;
X
X    thing->ypos += lpoint - nlpoint;
X
X    return;
X}
X
Xint
XcheckLine(field)
X    field_t        *field;
X{
X    int            *set = (int *) malloc(sizeof(int) * field->height);
X    int             i, x, y, nset = 0, h;
X
X    for (y = 0; y < field->height; y++) {
X	for (x = 0; x < field->width; x++)
X	    if (!field->full[x][y])
X		break;
X	if (x == field->width) {
X	    set[y] = 1;
X	    nset++;
X	} else
X	    set[y] = 0;
X    }
X
X    if (nset) {
X	for (i = 0; i < NUM_FLASHES / nset; i++) {
X	    for (y = 0; y < field->height; y++)
X		if (set[y]) {
X		    XFillRectangle(disp, field->win, gc_w,
X				   X_MARGIN,
X				   ytr((y + 1) * BOX_HEIGHT +
X				       Y_MARGIN),
X				   field->width * BOX_WIDTH,
X				   BOX_HEIGHT);
X		    XFlush(disp);
X		}
X	}
X	for (y = 0; y < field->height; y++)
X	    if (set[y]) {
X		for (i = y; i < field->height - 1; i++)
X		    for (x = 0; x < field->width; x++)
X			field->full[x][i] =
X			    field->full[x][i + 1];
X		for (x = 0; x < field->width; x++)
X		    field->full[x][field->height - 1] = 0;
X
X		h = (field->height - y - 1) * BOX_HEIGHT;
X		if (h > field->winheight - BOX_HEIGHT -
X			Y_MARGIN)
X		    h = field->winheight - BOX_HEIGHT -
X			Y_MARGIN;
X		XCopyArea(disp, field->win, field->win, gc_w,
X			  X_MARGIN, Y_MARGIN,
X			  field->winwidth, h,
X			  X_MARGIN, BOX_HEIGHT + Y_MARGIN);
X
X		for (i = y; i < field->height - 1; i++)
X		    set[i] = set[i + 1];
X		set[field->height - 1] = 0;
X		y--;
X	    }
X	XBell(disp, -60);
X	XSync(disp, 0);
X    }
X    free((char *) set);
X
X    return (nset);
X}
X
Xvoid
XinitPixmaps(field)
X    field_t        *field;
X{
X    Pixmap          bms[NUM_BITMAPS];
X    int             i, j;
X    char           *lastFg = "", *lastBg = "";
X    XColor          lastFgC, lastBgC;
X
X    for (i = 0; i < NUM_BITMAPS; i++) {
X	bms[i] = XCreateBitmapFromData(disp, field->win,
X				       bitmap_data[i].data,
X				       bitmap_data[i].width,
X				       bitmap_data[i].height);
X	assert(bms[i]);
X    }
X    if (XDisplayPlanes(disp, DefaultScreen(disp)) == 1) {
X	for (i = 0; i < NUM_BITMAPS; i++) {
X	    patterns[i].pixmap = bms[i];
X	}
X	return;
X    }
X    for (i = 0; i < NUM_PATTERNS; i++) {
X	j = 0;
X	if (strcmp(patterns[i].fgname, lastFg) != 0) {
X	    assert(XParseColor(disp, cmap,
X			       patterns[i].fgname, &patterns[i].fg));
X	    assert(XAllocColor(disp, cmap, &patterns[i].fg));
X	    lastFg = patterns[i].fgname;
X	    lastFgC = patterns[i].fg;
X	    j = 1;
X	} else {
X	    patterns[i].fg = lastFgC;
X	}
X	if (strcmp(patterns[i].bgname, lastBg) != 0) {
X	    assert(XParseColor(disp, cmap,
X			       patterns[i].bgname, &patterns[i].bg));
X	    assert(XAllocColor(disp, cmap, &patterns[i].bg));
X	    lastBg = patterns[i].bgname;
X	    lastBgC = patterns[i].bg;
X	    j = 1;
X	} else {
X	    patterns[i].bg = lastBgC;
X	}
X
X	if (j) {
X	    color.function = GXcopy;
X	    color.foreground = patterns[i].fg.pixel;
X	    color.background = patterns[i].bg.pixel;
X
X	    gc_pat[i] = XCreateGC(disp, field->win, (GCForeground |
X					GCBackground | GCFunction), &color);
X	} else
X	    gc_pat[i] = gc_pat[i - 1];
X
X	patterns[i].pixmap = bms[patterns[i].whichbitmap];
X	assert(patterns[i].pixmap);
X    }
X    return;
X}
X
Xint
Xnrandom(n)
X    int             n;
X{
X    return ((((double) random()) / ((double) 0x7fffffff)) * n);
X}
X
Xvoid
XUsage(argv)
X    char          **argv;
X{
X    fprintf(stderr, "Usage:\t%s [ starting_level [ raws_pre-filled ] ]\n\n",
X	argv[0]);
X    showHighScores(SHOWNSCORES/2);
X    exit(255);
X}
X
END_OF_FILE
if test 23128 -ne `wc -c <'tetris.c'`; then
    echo shar: \"'tetris.c'\" unpacked with wrong size!
fi
# end of 'tetris.c'
fi
if test -f 'tetris.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tetris.h'\"
else
echo shar: Extracting \"'tetris.h'\" \(4639 characters\)
sed "s/^X//" >'tetris.h' <<'END_OF_FILE'
X/*
X# GENERIC X-WINDOW-BASED TETRIS
X#
X#	tetris.h
X#
X###
X#
X#  Copyright (C) 1992	Qiang Alex Zhao
X#			Computer Science Dept, University of Arizona
X#			azhao@cs.arizona.edu
X#
X#			All Rights Reserved
X#
X#  Permission to use, copy, modify, and distribute this software and
X#  its documentation for any purpose and without fee is hereby granted,
X#  provided that the above copyright notice appear in all copies and
X#  that both that copyright notice and this permission notice appear in
X#  supporting documentation, and that the name of the author not be
X#  used in advertising or publicity pertaining to distribution of the
X#  software without specific, written prior permission.
X#
X#  This program is distributed in the hope that it will be "playable",
X#  but WITHOUT ANY WARRANTY; without even the implied warranty of
X#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
X#
X*/
X
X/*
X * Common defs
X */
X
X#include	<stdio.h>
X#include	<sys/types.h>
X#include	<sys/errno.h>
X#include	<sys/file.h>
X#include	<string.h>
X#include	<pwd.h>
X
X#ifdef	HPUX
X#include	<time.h>
X#define	random()	lrand48()
X#define	srandom(x)	srand48(x)
X#else
X#include	<sys/time.h>
X#endif
X
X#include	<X11/Xlib.h>
X#include	<X11/Xutil.h>
X#include	<X11/cursorfont.h>
X#include	<X11/keysym.h>
X
X#define	assert(E)	if (E); else fprintf(stderr,"Assertion failed, line %d, fill %s\n", __LINE__, __FILE__),exit(0)
X
X/*
X * Tetris defs
X */
X
X/* score file */
X#ifndef	SCOREFILE
X#define SCOREFILE	"/usr/games/.tetris.scores"
X#endif
X
X/* Maximum # of scores allowed per person */
X#ifndef	MAXSCORES
X#define MAXSCORES 3
X#endif
X
X/* number of scores shown */
X#ifndef	SHOWNSCORES
X#define	SHOWNSCORES	15
X#endif
X
X/* fonts */
X#define TITLE_FONT      "-*-new century schoolbook-bold-r-*-*-24-*-*-*-*-*-*-*"
X#define SCORE_FONT      "-*-times-bold-r-*-*-12-*-*-*-*-*-*-*"
X
X/****************************/
X
X#define	NAMELEN		12
X
X#define NUM_BITMAPS	(sizeof (bitmap_data) / sizeof (bitmap_data[0]))
X
X#define eq(a, b)	(!strcmp((a), (b)))
X
X#define DEF_WIDTH	10
X#define DEF_HEIGHT	20
X
X#define BOX_HEIGHT	30
X#define BOX_WIDTH	30
X
X#define BOX_SPACE	1
X
X#define X_MARGIN	1
X#define Y_MARGIN	1
X
X#define THING_SIZE	4
X
X#define BASE_XPOS	100
X#define BASE_YPOS	100
X
X#define BORDER_WIDTH	3
X
X#define TITLE_HEIGHT	40
X
X#define NUM_FLASHES	15
X
X#define SCORE_XPOS1	130
X#define SCORE_XPOS2	230
X#define SCORE_YPOS1	18
X#define SCORE_YPOS2	32
X
X#define BG_COLOR	"lightyellow"
X#define BD_COLOR	"darkgreen"
X#define TITLE_COLOR	"blue"
X#define TEXT_COLOR	"red"
X
Xtypedef struct score_s {
X    char            myname[NAMELEN], myhost[NAMELEN], mytime[27];
X    char            score[10];
X    char            level[4];
X    char            lines[5];
X}               score_t;
X#define SCORELEN	sizeof(score_t)
X
Xtypedef struct pattern_s {
X    int             whichbitmap;
X    char           *fgname, *bgname;
X    XColor          fg, bg;
X    Pixmap          pixmap;
X}               pattern_t;
X
Xtypedef enum {
X    NONE, LEFT, RIGHT, ROTATE, DROP
X}               command_t;
X
Xtypedef struct field_s {
X    Window          frame;
X    Window          title;
X    Window          win;
X    XFontStruct    *tfont;
X    XFontStruct    *sfont;
X    int           **full;
X    int             height, width;
X    int             winheight, winwidth;
X    long            score;
X    int             level;
X    int             lines;
X}               field_t;
X
Xtypedef struct thing_s {
X    int             map[THING_SIZE][THING_SIZE];
X    int             xpos, ypos;
X    int             size;
X    int             probability;
X}               thing_t;
X
X#define	DIE_MESG	"GAME OVER"
X#define	PAUSED_MESG	"PAUSED"
X
X#define ytr(y)		(field->winheight - (y))
X
X#define NUM_LEVELS	12
X
X#define INF		10000000
X
X#define MILLION		1000000
X
Xextern XColor   bgcolor, bdcolor, titlecolor, textcolor;
X
Xextern Bool     atBottom();
Xextern Bool     overlapping();
Xextern Bool     tryMove();
Xextern field_t *initField();
Xextern int      checkLine();
Xextern int      putBoxes();
Xextern long     time();
Xextern thing_t *makeNewThing();
Xextern void	Usage();
Xextern void     addHighScore();
Xextern void     banner();
Xextern void     die();
Xextern void     doBox();
Xextern void     drawField();
Xextern void     drawThing();
Xextern void     drawThingDiff();
Xextern void     fallDown();
Xextern void     handleEvents();
Xextern void     initPixmaps();
Xextern void     moveOne();
Xextern void     normTimeVal();
Xextern void     rotateThing();
Xextern void     showHighScores();
Xextern void     updateScore();
X
Xextern Display *disp;
Xextern Window   win;
Xextern XGCValues gcv;
Xextern XGCValues text;
Xextern GC       gc_w;
Xextern GC       gc_w2;
Xextern GC       gc_t;
Xextern GC       gc_wtx;
Xextern GC       gc_ttx;
X
END_OF_FILE
if test 4639 -ne `wc -c <'tetris.h'`; then
    echo shar: \"'tetris.h'\" unpacked with wrong size!
fi
# end of 'tetris.h'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
