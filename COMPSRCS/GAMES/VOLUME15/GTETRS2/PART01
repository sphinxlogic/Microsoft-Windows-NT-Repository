Path: uunet!ogicse!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v15i005:  gtetris2 -  Generic Tetris for X11, V1.8, Part01/02
Message-ID: <3733@master.CNA.TEK.COM>
Date: 9 Oct 92 00:49:47 GMT
Article-I.D.: master.3733
Sender: news@master.CNA.TEK.COM
Lines: 1804
Approved: billr@saab.CNA.TEK.COM

Submitted-by: "Qiang Alex Zhao" <azhao@cs.arizona.edu>
Posting-number: Volume 15, Issue 5
Archive-name: gtetris2/Part01
Supersedes: gtetris: Volume 15, Issue 1-2
Environment: X11R4/5, Xlib

	[This is an updated version of gtetris. Some files were changed
	 and added so this is a complete repost, rather than just diffs. -br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 2)."
# Contents:  README MANIFEST data.h tetris.h utils.c
# Wrapped by billr@saab on Thu Oct  8 17:46:30 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(3942 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X	GENERIC TETRIS
X	==============	Yet Another Tetris Game on X, V1.8
X
X
XWHY ANOTHER?
X
X    Because this one is simple, easy to build, and portable -- actually
X    the blocks are bigger, more comfortable for your eyes. It only uses
X    Xlib -- no "toolkit" kind of thing. People have tested it on the
X    following platforms:
X
X	DEC 5000		Ultrix 4.2A	X11R4
X	HP 9000			HP-UX 7.0	Motif
X	IBM RS6000		AIX 3.1		Motif
X	Iris 4D			IRIX 4.0.1	Motif
X	Sun4, SPARC-2		SunOS 4.1.1	X11R4, X11R5
X	Sequent S81		DYNIX 3.2.0	X11R5
X
X    If your's is not in this list, please let me know -- thanks. The
X    most updated source could be found on export.lcs.mit.edu under
X    /contrib.
X
X    A System V port (Sequent Dynix/ptx) has been added by
X    "Hans-Wolfgang Loidl" (hwloidl@risc.uni-linz.ac.at). The source can
X    be retrieved by anonymous FTP to:
X	Host:	melmac.risc.uni-linz.ac.at
X	File:	/pub/misc/gtetris.tar.Z
X
X
XHOW TO BUILD?
X
X    If you want to put the score-file at a different location (I bet
X    you would), edit the Makefile correspondingly with the make mathod
X    you choose from the following:
X
X    If you you have xmkmf:
X	xmkmf
X	make
X
X    Or use the standard Makefile:
X	make -f Makefile.std
X
X    Also check "local settings" -- if your system is listed there,
X    change "LOCAL_DEFS", "LOCAL_LIBS" and "LINK_LIBS" accordingly.
X
X    "Tetris" is the game. It only lists the top 15 players at the end,
X    each player may has at most three scores.  "Tscores" will list all
X    the players/scores for you.
X
X
XANYTHING SPECIAL IN PLAYING?
X
X    Use "j" to move left; "l" to move right; "k" to rotate. Left-handed
X    people may want to use "s", "d", "f" respectively. Use the space
X    bar to drop a block quickly.
X
X    Use CTRL-L key combination to redraw -- in case it mess somthing up.
X
X    As usual, "+" and "-" will speed up or lower down the speed. Note
X    that you don't need to press the SHIFT key -- "=" and "_" also
X    work. The "b" key can be used to toggle "beep".
X
X    If you press CTRL-S or "p", the game will be paused, and the window
X    will be iconified -- just in case your boss suddenly appears at
X    your door. ;o)
X
X
XFOUND A BUG?
X
X    Send bugs (or their reports, or fixes) to the author:
X
X	Qiang Alex Zhao,	azhao@cs.arizona.edu
X	Computer Science Department
X	University of Arizona
X	Tucson, AZ 85721
X
X    Refter to the "COPYRIGHT" notice in the "COPYRIGHT" file (yeah, as
X    its name implies). And note: my first name is *NOT* spelled as
X    "Quiang".
X
X
XHISTORY -- Oh no, not again: I failed in my history course!
XWell ... ACKNOWLEDGEMENTS
X
X    I studied an old tetris game for X10, wrote by Wayne Christopher
X    <faustus@cs.berkeley.edu> in 1988; then I adopted the ideas in
X    representing those "blocks" and rotating them, and added X11
X    stuff. Also I learned a lot from Nathan Sidwell's great game
X    "xmris", e.g. the "iconifying pause".
X
X    Thanks go to people who helped me in improving the program (see
X    CHANGES).
X
X
XCHANGES
X
X  [Oct 04, 92]  V1.8: Corrected some typos, <herbison@erlang.enet.dec.com>.
X		Added man-page.  Gregg Townsend <gmt@cs.arizona.edu>
X		provided hints for some problems on HP-UX. Imakefile.
X
X  [Sep 27, 92]  V1.6: Changed speed coefficients. Improved window
X		manager hints. Several rows at once worth more points.
X
X  [Sep 25, 92]  V1.5: HP-UX fixes by "Richard van Denzel"
X		<raet-sh!richard@relay.nluug.nl>. Added 'b' to toggle
X		"beep". Rewrote window creation/initialization to fix
X		the "losing input focus" problem.
X
X  [Sep 24, 92]  V1.4: Added <sys/select.h> and -lbsd for AIX (by "Daryl
X		Green" <darylg@amex-trs.com>).
X
X  [Sep 23, 92]  V1.3: Scoring -- a line in a higher level worth more
X		points; "tscores" program. Submitted to
X		comp.sources.games (volumn 15, issues 1-2; it has
X		nothing to do with GNU, but it was called "gtetris",
X		pronounced as "Gee, tetris", by the newsgroup
X		moderator).
X
X  [Sep ??, 92]  First set of versions, 1.0 through 1.2. Put on
X		export.lcs.mit.edu.
X
END_OF_FILE
if test 3942 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(455 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X COPYRIGHT                  2	
X Imakefile                  2	
X MANIFEST                   1	This shipping list
X Makefile.std               2	
X README                     1	
X data.h                     1	
X die.c                      2	
X tetris.c                   2	
X tetris.h                   1	
X tetris.man                 2	
X utils.c                    1	
END_OF_FILE
if test 455 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'data.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data.h'\"
else
echo shar: Extracting \"'data.h'\" \(21038 characters\)
sed "s/^X//" >'data.h' <<'END_OF_FILE'
X/*
X# GENERIC X-WINDOW-BASED TETRIS
X#
X#	data.h
X#
X###
X#
X#  Copyright (C) 1992	Qiang Alex Zhao
X#			Computer Science Dept, University of Arizona
X#			azhao@cs.arizona.edu
X#
X#			All Rights Reserved
X#
X#  Permission to use, copy, modify, and distribute this software and
X#  its documentation for any purpose and without fee is hereby granted,
X#  provided that the above copyright notice appear in all copies and
X#  that both that copyright notice and this permission notice appear in
X#  supporting documentation, and that the name of the author not be
X#  used in advertising or publicity pertaining to distribution of the
X#  software without specific, written prior permission.
X#
X#  This program is distributed in the hope that it will be "playable",
X#  but WITHOUT ANY WARRANTY; without even the implied warranty of
X#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
X#
X*/
X
X#define rot00_width 30
X#define rot00_height 30
Xstatic char rot00_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x03, 0xf8, 0xff, 0xff, 0x07,
X   0x5c, 0x55, 0x55, 0x0f, 0xae, 0xaa, 0xaa, 0x1e, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0x6a, 0xaa, 0x1a,
X   0x56, 0x95, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x5e, 0x55, 0x55, 0x1d, 0xbc, 0xaa, 0xaa, 0x0e,
X   0xf8, 0xff, 0xff, 0x07, 0xf0, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00};
X
X#define rot01_width 30
X#define rot01_height 30
Xstatic char rot01_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x03, 0xff, 0xff, 0xff, 0x07,
X   0x55, 0x55, 0x55, 0x0f, 0xaa, 0xaa, 0xaa, 0x1e, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0x6a, 0xaa, 0x1a,
X   0x55, 0x95, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x0e,
X   0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00};
X
X#define rot02_width 30
X#define rot02_height 30
Xstatic char rot02_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x03, 0xf8, 0xff, 0xff, 0x07,
X   0x5c, 0x55, 0x55, 0x0f, 0xae, 0xaa, 0xaa, 0x1e, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0x6a, 0xaa, 0x1a,
X   0x56, 0x95, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d};
X
X#define rot03_width 30
X#define rot03_height 30
Xstatic char rot03_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x03, 0xff, 0xff, 0xff, 0x07,
X   0x55, 0x55, 0x55, 0x0f, 0xaa, 0xaa, 0xaa, 0x1e, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0x6a, 0xaa, 0x1a,
X   0x55, 0x95, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x57, 0x55, 0x55, 0x1d, 0xaf, 0xaa, 0xaa, 0x1a, 0x57, 0x55, 0x55, 0x1d};
X
X#define rot04_width 30
X#define rot04_height 30
Xstatic char rot04_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x3f, 0xf8, 0xff, 0xff, 0x3f,
X   0x5c, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0x6a, 0xaa, 0x2a,
X   0x56, 0x95, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x5e, 0x55, 0x55, 0x15, 0xbc, 0xaa, 0xaa, 0x2a,
X   0xf8, 0xff, 0xff, 0x3f, 0xf0, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00};
X
X#define rot05_width 30
X#define rot05_height 30
Xstatic char rot05_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0x3f,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0x6a, 0xaa, 0x2a,
X   0x55, 0x95, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00};
X
X#define rot06_width 30
X#define rot06_height 30
Xstatic char rot06_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x3f, 0xf8, 0xff, 0xff, 0x3f,
X   0x5c, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0x6a, 0xaa, 0x2a,
X   0x56, 0x95, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x3d, 0xae, 0xaa, 0xaa, 0x3a, 0x56, 0x55, 0x55, 0x3d};
X
X#define rot07_width 30
X#define rot07_height 30
Xstatic char rot07_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0x3f,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0x6a, 0xaa, 0x2a,
X   0x55, 0x95, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0x57, 0x55, 0x55, 0x3d, 0xaf, 0xaa, 0xaa, 0x3a, 0x57, 0x55, 0x55, 0x3d};
X
X#define rot08_width 30
X#define rot08_height 30
Xstatic char rot08_bits[] = {
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0x6a, 0xaa, 0x1a,
X   0x56, 0x95, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x5e, 0x55, 0x55, 0x1d, 0xbc, 0xaa, 0xaa, 0x0e,
X   0xf8, 0xff, 0xff, 0x07, 0xf0, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00};
X
X#define rot09_width 30
X#define rot09_height 30
Xstatic char rot09_bits[] = {
X   0xaf, 0xaa, 0xaa, 0x1a, 0x57, 0x55, 0x55, 0x1d, 0xaf, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0x6a, 0xaa, 0x1a,
X   0x55, 0x95, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x0e,
X   0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00};
X
X#define rot10_width 30
X#define rot10_height 30
Xstatic char rot10_bits[] = {
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0x6a, 0xaa, 0x1a,
X   0x56, 0x95, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d,
X   0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a,
X   0x56, 0x55, 0x55, 0x1d, 0xae, 0xaa, 0xaa, 0x1a, 0x56, 0x55, 0x55, 0x1d};
X
X#define rot11_width 30
X#define rot11_height 30
Xstatic char rot11_bits[] = {
X   0xaf, 0xaa, 0xaa, 0x1a, 0x57, 0x55, 0x55, 0x1d, 0xaf, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0x6a, 0xaa, 0x1a,
X   0x55, 0x95, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d,
X   0xaa, 0xaa, 0xaa, 0x1a, 0x55, 0x55, 0x55, 0x1d, 0xaa, 0xaa, 0xaa, 0x1a,
X   0x57, 0x55, 0x55, 0x1d, 0xaf, 0xaa, 0xaa, 0x1a, 0x57, 0x55, 0x55, 0x1d};
X
X#define rot12_width 30
X#define rot12_height 30
Xstatic char rot12_bits[] = {
X   0xae, 0xaa, 0xaa, 0x3a, 0x56, 0x55, 0x55, 0x3d, 0xae, 0xaa, 0xaa, 0x3a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0x6a, 0xaa, 0x2a,
X   0x56, 0x95, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x5e, 0x55, 0x55, 0x15, 0xbc, 0xaa, 0xaa, 0x2a,
X   0xf8, 0xff, 0xff, 0x3f, 0xf0, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00};
X
X#define rot13_width 30
X#define rot13_height 30
Xstatic char rot13_bits[] = {
X   0xaf, 0xaa, 0xaa, 0x3a, 0x57, 0x55, 0x55, 0x3d, 0xaf, 0xaa, 0xaa, 0x3a,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0x6a, 0xaa, 0x2a,
X   0x55, 0x95, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15,
X   0xaa, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0x15, 0xaa, 0xaa, 0xaa, 0x2a,
X   0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00};
X
X#define rot14_width 30
X#define rot14_height 30
Xstatic char rot14_bits[] = {
X   0xae, 0xaa, 0xaa, 0x3a, 0x56, 0x55, 0x55, 0x3d, 0xae, 0xaa, 0xaa, 0x3a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0x6a, 0xaa, 0x2a,
X   0x56, 0x95, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15,
X   0xae, 0xaa, 0xaa, 0x2a, 0x56, 0x55, 0x55, 0x15, 0xae, 0xaa, 0xaa, 0x2a,
X   0x56, 0x55, 0x55, 0x3d, 0xae, 0xaa, 0xaa, 0x3a, 0x56, 0x55, 0x55, 0x3d};
X
Xbitmap_t        bitmap_data[] = {
X    {
X	rot00_bits, rot00_height, rot00_width
X    },
X    {
X	rot01_bits, rot01_height, rot01_width
X    },
X    {
X	rot02_bits, rot02_height, rot02_width
X    },
X    {
X	rot03_bits, rot03_height, rot03_width
X    },
X    {
X	rot04_bits, rot04_height, rot04_width
X    },
X    {
X	rot05_bits, rot05_height, rot05_width
X    },
X    {
X	rot06_bits, rot06_height, rot06_width
X    },
X    {
X	rot07_bits, rot07_height, rot07_width
X    },
X    {
X	rot08_bits, rot08_height, rot08_width
X    },
X    {
X	rot09_bits, rot09_height, rot09_width
X    },
X    {
X	rot10_bits, rot10_height, rot10_width
X    },
X    {
X	rot11_bits, rot11_height, rot11_width
X    },
X    {
X	rot12_bits, rot12_height, rot12_width
X    },
X    {
X	rot13_bits, rot13_height, rot13_width
X    },
X    {
X	rot14_bits, rot14_height, rot14_width
X    }
X};
X
Xpattern_t       patterns[] = {
X    {0, "magenta", "white", DUMC, DUMC, DUMP},
X    {1, "magenta", "white", DUMC, DUMC, DUMP},
X    {2, "magenta", "white", DUMC, DUMC, DUMP},
X    {3, "magenta", "white", DUMC, DUMC, DUMP},
X    {4, "magenta", "white", DUMC, DUMC, DUMP},
X    {5, "magenta", "white", DUMC, DUMC, DUMP},
X    {6, "magenta", "white", DUMC, DUMC, DUMP},
X    {7, "magenta", "white", DUMC, DUMC, DUMP},
X    {8, "magenta", "white", DUMC, DUMC, DUMP},
X    {9, "magenta", "white", DUMC, DUMC, DUMP},
X    {10, "magenta", "white", DUMC, DUMC, DUMP},
X    {11, "magenta", "white", DUMC, DUMC, DUMP},
X    {12, "magenta", "white", DUMC, DUMC, DUMP},
X    {13, "magenta", "white", DUMC, DUMC, DUMP},
X    {14, "magenta", "white", DUMC, DUMC, DUMP},
X    {0, "magenta", "white", DUMC, DUMC, DUMP},
X    {0, "forest green", "white", DUMC, DUMC, DUMP},
X    {1, "forest green", "white", DUMC, DUMC, DUMP},
X    {2, "forest green", "white", DUMC, DUMC, DUMP},
X    {3, "forest green", "white", DUMC, DUMC, DUMP},
X    {4, "forest green", "white", DUMC, DUMC, DUMP},
X    {5, "forest green", "white", DUMC, DUMC, DUMP},
X    {6, "forest green", "white", DUMC, DUMC, DUMP},
X    {7, "forest green", "white", DUMC, DUMC, DUMP},
X    {8, "forest green", "white", DUMC, DUMC, DUMP},
X    {9, "forest green", "white", DUMC, DUMC, DUMP},
X    {10, "forest green", "white", DUMC, DUMC, DUMP},
X    {11, "forest green", "white", DUMC, DUMC, DUMP},
X    {12, "forest green", "white", DUMC, DUMC, DUMP},
X    {13, "forest green", "white", DUMC, DUMC, DUMP},
X    {14, "forest green", "white", DUMC, DUMC, DUMP},
X    {0, "forest green", "white", DUMC, DUMC, DUMP},
X    {0, "blue", "white", DUMC, DUMC, DUMP},
X    {1, "blue", "white", DUMC, DUMC, DUMP},
X    {2, "blue", "white", DUMC, DUMC, DUMP},
X    {3, "blue", "white", DUMC, DUMC, DUMP},
X    {4, "blue", "white", DUMC, DUMC, DUMP},
X    {5, "blue", "white", DUMC, DUMC, DUMP},
X    {6, "blue", "white", DUMC, DUMC, DUMP},
X    {7, "blue", "white", DUMC, DUMC, DUMP},
X    {8, "blue", "white", DUMC, DUMC, DUMP},
X    {9, "blue", "white", DUMC, DUMC, DUMP},
X    {10, "blue", "white", DUMC, DUMC, DUMP},
X    {11, "blue", "white", DUMC, DUMC, DUMP},
X    {12, "blue", "white", DUMC, DUMC, DUMP},
X    {13, "blue", "white", DUMC, DUMC, DUMP},
X    {14, "blue", "white", DUMC, DUMC, DUMP},
X    {0, "blue", "white", DUMC, DUMC, DUMP},
X    {0, "red", "white", DUMC, DUMC, DUMP},
X    {1, "red", "white", DUMC, DUMC, DUMP},
X    {2, "red", "white", DUMC, DUMC, DUMP},
X    {3, "red", "white", DUMC, DUMC, DUMP},
X    {4, "red", "white", DUMC, DUMC, DUMP},
X    {5, "red", "white", DUMC, DUMC, DUMP},
X    {6, "red", "white", DUMC, DUMC, DUMP},
X    {7, "red", "white", DUMC, DUMC, DUMP},
X    {8, "red", "white", DUMC, DUMC, DUMP},
X    {9, "red", "white", DUMC, DUMC, DUMP},
X    {10, "red", "white", DUMC, DUMC, DUMP},
X    {11, "red", "white", DUMC, DUMC, DUMP},
X    {12, "red", "white", DUMC, DUMC, DUMP},
X    {13, "red", "white", DUMC, DUMC, DUMP},
X    {14, "red", "white", DUMC, DUMC, DUMP},
X    {0, "red", "white", DUMC, DUMC, DUMP},
X    {0, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {1, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {2, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {3, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {4, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {5, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {6, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {7, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {8, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {9, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {10, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {11, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {12, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {13, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {14, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {0, "dark turquoise", "white", DUMC, DUMC, DUMP},
X    {0, "black", "white", DUMC, DUMC, DUMP},
X    {1, "black", "white", DUMC, DUMC, DUMP},
X    {2, "black", "white", DUMC, DUMC, DUMP},
X    {3, "black", "white", DUMC, DUMC, DUMP},
X    {4, "black", "white", DUMC, DUMC, DUMP},
X    {5, "black", "white", DUMC, DUMC, DUMP},
X    {6, "black", "white", DUMC, DUMC, DUMP},
X    {7, "black", "white", DUMC, DUMC, DUMP},
X    {8, "black", "white", DUMC, DUMC, DUMP},
X    {9, "black", "white", DUMC, DUMC, DUMP},
X    {10, "black", "white", DUMC, DUMC, DUMP},
X    {11, "black", "white", DUMC, DUMC, DUMP},
X    {12, "black", "white", DUMC, DUMC, DUMP},
X    {13, "black", "white", DUMC, DUMC, DUMP},
X    {14, "black", "white", DUMC, DUMC, DUMP},
X    {0, "brown", "white", DUMC, DUMC, DUMP},
X    {0, "brown", "white", DUMC, DUMC, DUMP},
X    {1, "brown", "white", DUMC, DUMC, DUMP},
X    {2, "brown", "white", DUMC, DUMC, DUMP},
X    {3, "brown", "white", DUMC, DUMC, DUMP},
X    {4, "brown", "white", DUMC, DUMC, DUMP},
X    {5, "brown", "white", DUMC, DUMC, DUMP},
X    {6, "brown", "white", DUMC, DUMC, DUMP},
X    {7, "brown", "white", DUMC, DUMC, DUMP},
X    {8, "brown", "white", DUMC, DUMC, DUMP},
X    {9, "brown", "white", DUMC, DUMC, DUMP},
X    {10, "brown", "white", DUMC, DUMC, DUMP},
X    {11, "brown", "white", DUMC, DUMC, DUMP},
X    {12, "brown", "white", DUMC, DUMC, DUMP},
X    {13, "brown", "white", DUMC, DUMC, DUMP},
X    {14, "brown", "white", DUMC, DUMC, DUMP},
X    {0, "brown", "white", DUMC, DUMC, DUMP}
X};
X
X#define NUM_PATTERNS	(sizeof (patterns) / sizeof (patterns[0]))
X
Xint             num_patterns = NUM_PATTERNS;
X
Xthing_t         possible[] = {
X
X    {{{0, 0, 0, 0},
X    {1, 1, 1, 1},
X    {0, 0, 0, 0},
X    {0, 0, 0, 0}}, 0, 0, 4, 1},
X
X    {{{0, 1, 0, 0},
X    {0, 1, 0, 0},
X    {1, 1, 0, 0},
X    {0, 0, 0, 0}}, 0, 0, 3, 1},
X
X    {{{1, 0, 0, 0},
X    {1, 0, 0, 0},
X    {1, 1, 0, 0},
X    {0, 0, 0, 0}}, 0, 0, 3, 1},
X
X    {{{0, 1, 0, 0},
X    {1, 1, 0, 0},
X    {1, 0, 0, 0},
X    {0, 0, 0, 0}}, 0, 0, 3, 1},
X
X    {{{1, 0, 0, 0},
X    {1, 1, 0, 0},
X    {0, 1, 0, 0},
X    {0, 0, 0, 0}}, 0, 0, 3, 1},
X
X    {{{1, 1, 0, 0},
X    {1, 1, 0, 0},
X    {0, 0, 0, 0},
X    {0, 0, 0, 0}}, 0, 0, 2, 1},
X
X    {{{0, 1, 0, 0},
X    {1, 1, 1, 0},
X    {0, 0, 0, 0},
X    {0, 0, 0, 0}}, 0, 0, 3, 2},
X};
X
X#define NUM_POSSIBLE	(sizeof (possible) / sizeof (possible[0]))
X
Xint             speeds[NUM_LEVELS] =
X	{100, 92, 84, 76, 68, 60, 52, 43, 37, 31, 25, 19, 13, 7, 5, 3, 0};
X
Xint             thresh[NUM_LEVELS] =
X	{10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, INF};
X
X/* variables used in tetris.c */
X
XXColor          bgcolor, bdcolor, titlecolor, textcolor;
XColormap        cmap;
X
XDisplay        *disp;
XGC              gc_t;
XGC              gc_w;
XGC              gc_w2;
XGC              gc_ttx;
XGC              gc_wtx;
XGC              gc_pat[NUM_PATTERNS];
XXGCValues       gcv;
XXGCValues       color;
XXGCValues       text;
X
XBool            beep = False;
Xchar           *winName = "GENERIC TETRIS";
Xchar           *iconName = "TETRIS";
X
Xint             rootScreen;
Xint             rootDepth;
X
END_OF_FILE
if test 21038 -ne `wc -c <'data.h'`; then
    echo shar: \"'data.h'\" unpacked with wrong size!
fi
# end of 'data.h'
fi
if test -f 'tetris.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tetris.h'\"
else
echo shar: Extracting \"'tetris.h'\" \(5752 characters\)
sed "s/^X//" >'tetris.h' <<'END_OF_FILE'
X/*
X# GENERIC X-WINDOW-BASED TETRIS
X#
X#	tetris.h
X#
X###
X#
X#  Copyright (C) 1992	Qiang Alex Zhao
X#			Computer Science Dept, University of Arizona
X#			azhao@cs.arizona.edu
X#
X#			All Rights Reserved
X#
X#  Permission to use, copy, modify, and distribute this software and
X#  its documentation for any purpose and without fee is hereby granted,
X#  provided that the above copyright notice appear in all copies and
X#  that both that copyright notice and this permission notice appear in
X#  supporting documentation, and that the name of the author not be
X#  used in advertising or publicity pertaining to distribution of the
X#  software without specific, written prior permission.
X#
X#  This program is distributed in the hope that it will be "playable",
X#  but WITHOUT ANY WARRANTY; without even the implied warranty of
X#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
X#
X*/
X
X/*
X * Common defs
X */
X
X#include	<stdio.h>
X#include	<sys/types.h>
X#include	<sys/errno.h>
X#include	<sys/file.h>
X#include	<pwd.h>
X
X#ifdef	SYSV	/* for Imake */
X#include	<string.h>
X#else
X#include	<strings.h>
X#endif
X
X#ifdef	HPUX
X#include	<unistd.h>
X#include	<time.h>
X#define	random()	lrand48()
X#define	srandom(x)	srand48(x)
X#define	LOCK(X)		lockf((X), F_LOCK, 0)
X#define	ULOCK(X)	lockf((X), F_ULOCK, 0)
X#else
X#include	<sys/time.h>
X#define	LOCK(X)		flock((X), LOCK_EX)
X#define	ULOCK(X)	flock((X), LOCK_UN)
X#endif
X
X#ifdef	AIX
X#include	<sys/select.h>
X#endif
X
X/*
X * X related
X */
X
X#include	<X11/Xlib.h>
X#include	<X11/Xutil.h>
X#include	<X11/cursorfont.h>
X#include	<X11/keysym.h>
X
X/*
X * Assertion
X */
X
X#define	assert(E, X)	if ((E)==0) \
X			{ fprintf(stderr, \
X			 "Assertion failed, line %d, fill %s: %s\n", \
X			 __LINE__, __FILE__, (X)); \
X			 exit(-1); }
X
X/*
X * Tetris defs
X */
X
X/* score file */
X#ifndef	SCOREFILE
X#define SCOREFILE	"/usr/games/.tetris.scores"
X#endif
X
X/* Maximum # of scores allowed per person */
X#ifndef	MAXSCORES
X#define MAXSCORES 3
X#endif
X
X/* number of scores shown */
X#ifndef	SHOWNSCORES
X#define	SHOWNSCORES	15
X#endif
X
X/* fonts */
X#define TITLE_FONT      "-*-new century schoolbook-bold-r-*-*-24-*-*-*-*-*-*-*"
X#define SCORE_FONT      "-*-times-bold-r-*-*-12-*-*-*-*-*-*-*"
X
X/* if the above fonts cannot be allocated, try the following */
X#define	TITLE_FONT2	"-*-*-bold-r-*-*-24-*-*-*-*-*-*-*"
X#define SCORE_FONT2	"-*-*-bold-r-*-*-12-*-*-*-*-*-*-*"
X
X/****************************/
X
X#define	NAMELEN		12
X
X#define NUM_BITMAPS	(sizeof (bitmap_data) / sizeof (bitmap_data[0]))
X
X#define DEF_WIDTH	10
X#define DEF_HEIGHT	20
X
X#define BOX_HEIGHT	30
X#define BOX_WIDTH	30
X
X#define BOX_SPACE	1
X
X#define X_MARGIN	1
X#define Y_MARGIN	1
X
X#define THING_SIZE	4
X
X#define BASE_XPOS	100
X#define BASE_YPOS	100
X
X#define BORDER_WIDTH	3
X
X#define TITLE_HEIGHT	40
X
X#define NUM_FLASHES	15
X
X#define SCORE_XPOS1	150
X#define SCORE_XPOS2	230
X#define SCORE_YPOS1	18
X#define SCORE_YPOS2	32
X
X#define BG_COLOR	"lightyellow"
X#define BD_COLOR	"darkgreen"
X#define TITLE_COLOR	"blue"
X#define TEXT_COLOR	"red"
X
Xtypedef struct score_s {
X    char            myname[NAMELEN], myhost[NAMELEN], mytime[27];
X    char            score[10];
X    char            level[4];
X    char            lines[5];
X}               score_t;
X#define SCORELEN	sizeof(score_t)
X
X#define	DUMC	{0, 0, 0, 0, '\0', '\0'}
X#define	DUMP	((Pixmap) 0)
Xtypedef struct pattern_s {
X    int             whichbitmap;
X    char           *fgname, *bgname;
X    XColor          fg, bg;
X    Pixmap          pixmap;
X}               pattern_t;
X
Xtypedef enum {
X    NONE, LEFT, RIGHT, ROTATE, DROP
X}               command_t;
X
Xtypedef struct field_s {
X    Window          frame;
X    Window          title;
X    Window          win;
X    Atom            delw;
X    XFontStruct    *tfont;
X    XFontStruct    *sfont;
X    int           **full;
X    int             height, width;
X    int             winheight, winwidth;
X    long int        score;
X    int             level;
X    int             lines;
X}               field_t;
X
Xtypedef struct thing_s {
X    int             map[THING_SIZE][THING_SIZE];
X    int             xpos, ypos;
X    int             size;
X    int             probability;
X}               thing_t;
X
Xtypedef struct bitmap_datum {
X    char           *data;
X    int             height, width;
X}               bitmap_t;
X
X#define	DIE_MESG	"GAME OVER"
X#define	PAUSED_MESG	"PAUSED"
X
X#define ytr(y)		(field->winheight - (y))
X
X#define NUM_LEVELS	17
X
X#define INF		10000000
X
X#define MILLION		1000000
X
Xextern XColor   bgcolor, bdcolor, titlecolor, textcolor;
X
Xextern Bool     atBottom();
Xextern Bool     overlapping();
Xextern Bool     tryMove();
Xextern field_t *initField();
Xextern int      checkLine();
Xextern int      putBoxes();
Xextern thing_t *makeNewThing();
Xextern void	Usage();
Xextern void     addHighScore();
Xextern void     banner();
Xextern void     die();
Xextern void     doBox();
Xextern void     drawField();
Xextern void     drawThing();
Xextern void     drawThingDiff();
Xextern void     fallDown();
Xextern void     handleEvents();
Xextern void     initPixmaps();
Xextern void     moveOne();
Xextern void     normTimeVal();
Xextern void     rotateThing();
Xextern void     showHighScores();
Xextern void     updateScore();
X
Xextern Display *disp;
Xextern Window   win;
Xextern GC       gc_t;
Xextern GC       gc_w;
Xextern GC       gc_w2;
Xextern GC       gc_wtx;
Xextern GC       gc_ttx;
Xextern GC       gc_pat[];
Xextern XGCValues gcv;
Xextern XGCValues text;
Xextern XGCValues color;
X
Xextern pattern_t patterns[];
Xextern bitmap_t bitmap_data[];
Xextern int      num_patterns;
Xextern thing_t  possible[];
Xextern int      speeds[];
Xextern int      thresh[];
Xextern XColor   bgcolor, bdcolor, titlecolor, textcolor;
Xextern Colormap cmap;
Xextern int      rootDepth;
Xextern int      rootScreen;
X
Xextern Bool     beep;
Xextern char    *winName;
Xextern char    *iconName;
X
END_OF_FILE
if test 5752 -ne `wc -c <'tetris.h'`; then
    echo shar: \"'tetris.h'\" unpacked with wrong size!
fi
# end of 'tetris.h'
fi
if test -f 'utils.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils.c'\"
else
echo shar: Extracting \"'utils.c'\" \(20459 characters\)
sed "s/^X//" >'utils.c' <<'END_OF_FILE'
X/*
X# GENERIC X-WINDOW-BASED TETRIS
X#
X#	tetris.c
X#
X###
X#
X#  Copyright (C) 1992	Qiang Alex Zhao
X#			Computer Science Dept, University of Arizona
X#			azhao@cs.arizona.edu
X#
X#			All Rights Reserved
X#
X#  Permission to use, copy, modify, and distribute this software and
X#  its documentation for any purpose and without fee is hereby granted,
X#  provided that the above copyright notice appear in all copies and
X#  that both that copyright notice and this permission notice appear in
X#  supporting documentation, and that the name of the author not be
X#  used in advertising or publicity pertaining to distribution of the
X#  software without specific, written prior permission.
X#
X#  This program is distributed in the hope that it will be "playable",
X#  but WITHOUT ANY WARRANTY; without even the implied warranty of
X#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
X#
X*/
X
X#include "tetris.h"
X#include "data.h"
X
Xvoid
XnormTimeVal(tv)
X    struct timeval *tv;
X{
X    while (tv->tv_usec < 0) {
X	tv->tv_sec--;
X	tv->tv_usec += MILLION;
X    }
X    while (tv->tv_usec >= MILLION) {
X	tv->tv_sec++;
X	tv->tv_usec -= MILLION;
X    }
X    return;
X}
X
Xvoid
XfallDown(field, thingp, eat)
X    field_t        *field;
X    thing_t       **thingp;
X    Bool            eat;
X{
X    int             lines;
X    XEvent          event;
X
X    putBoxes(field, *thingp);
X
X    lines = checkLine(field);
X    field->score += 5 + 4 * field->level * field->level * lines * lines;
X    field->lines += lines;
X    if (field->lines >= thresh[field->level])
X    	field->level++;
X    updateScore(field);
X
X    free((char *) *thingp);
X    if (eat) {
X	*thingp = NULL;
X	while (XPending(disp)) XNextEvent(disp, &event);
X    }
X    *thingp = makeNewThing(field);
X    if (overlapping(field, *thingp)) die(field);
X    drawThing(field, *thingp);
X}
X
Xvoid
XhandleEvents(field, thingp, fall_down)
X    field_t        *field;
X    thing_t       **thingp;
X    Bool            fall_down;
X{
X    static Bool     frozen = False;
X    XEvent          event;
X    char            s[4];
X
X    if (frozen) fall_down = False;
X
X    if (!*thingp) {
X	*thingp = makeNewThing(field);
X	if (overlapping(field, *thingp)) die(field);
X	drawThing(field, *thingp);
X	XSync(disp, 0);
X    }
X    if (fall_down && atBottom(field, *thingp)) {
X	fallDown(field, thingp, False);
X	fall_down = False;
X    }
X    if (!XPending(disp) && !frozen)
X	moveOne(field, *thingp, NONE, fall_down);
X
X    while (XPending(disp)) {
X	if (overlapping(field, *thingp)) die(field);
X
X	XNextEvent(disp, &event);
X	switch (event.type) {
X	case KeyPress:
X	    if (!XLookupString((XKeyEvent *) &event, s, 4, NULL, NULL)) break;
X	    switch (*s) {
X	    case 'j':		/* Move left. */
X	    case 'J':
X	    case 's':
X	    case 'S':
X		if (!frozen)
X		    moveOne(field, *thingp, LEFT, fall_down);
X		break;
X
X	    case 'k':		/* Rotate. */
X	    case 'K':
X	    case 'd':
X	    case 'D':
X		if (!frozen)
X		    moveOne(field, *thingp, ROTATE, fall_down);
X		break;
X
X	    case 'l':		/* Move right. */
X	    case 'L':
X	    case 'f':
X	    case 'F':
X		if (!frozen)
X		    moveOne(field, *thingp, RIGHT, fall_down);
X		break;
X
X	    case ' ':		/* Drop. */
X	    case '\n':
X		if (!frozen) {
X		    moveOne(field, *thingp, DROP, fall_down);
X		    fallDown(field, thingp, True);
X		}
X		return;
X		break;
X
X	    case 'q':		/* Quit. */
X	    case 'Q':
X		die(field);
X		break;
X
X	    case '+':		/* Speed up. */
X	    case '=':
X		if (field->level < NUM_LEVELS - 1) {
X		    field->level++;
X		    updateScore(field);
X		}
X		break;
X
X	    case '-':		/* Slow down. */
X	    case '_':
X		if (field->level > 0) {
X		    field->level--;
X		    updateScore(field);
X		}
X		break;
X
X	    case 'b':
X	    case 'B':
X		beep = !beep;
X		if (beep) XBell(disp, -90);
X		break;
X
X	    case '\023':	/* Freeze / continue. */
X	    case 'p':
X	    case 'P':
X		if (beep) XBell(disp, -90);
X		frozen = (frozen ? False : True);
X		if (frozen) {
X		/* "... Hi Boss, I'm working hard as usual ..." */
X		    XIconifyWindow(disp, field->frame, rootScreen);
X		} else {
X		    XClearWindow(disp, field->win);
X		    drawField(field);
X		    if (*thingp) drawThing(field, *thingp);
X		}
X		XFlush(disp);
X		break;
X
X	    case '\014':		/* Redraw. */
X		XClearWindow(disp, field->win);
X		drawField(field);
X		if (*thingp)
X		    drawThing(field, *thingp);
X		/* flow to next */
X
X	    default:
X		XBell(disp, -90);
X		XFlush(disp);
X		break;
X	    }
X	    break;		/* processing key press */
X
X	case UnmapNotify:
X	    frozen = True;
X	    break;
X
X	case Expose:
X	    if (event.xexpose.count == 0) {
X	    	drawField(field);
X	    	if (*thingp) drawThing(field, *thingp);
X	    	if (frozen) banner(field, PAUSED_MESG);
X	    }
X	    XFlush(disp);
X	    break;
X
X	case ClientMessage:
X	    if ((Atom) event.xclient.data.l[0] == field->delw)
X		die(field);
X	    break;
X
X	case DestroyNotify:
X	    die(field);
X	    break;
X
X	}
X
X	fall_down = False;
X    }
X
X    return;
X}
X
Xvoid
XmoveOne(field, thing, what, fall_down)
X    field_t        *field;
X    thing_t        *thing;
X    command_t       what;
X    Bool            fall_down;
X{
X    thing_t         old;
X
X    old = *thing;
X
X    if (tryMove(field, thing, what, fall_down))
X	drawThingDiff(field, thing, &old);
X
X    XSync(disp, 0);
X    return;
X}
X
XBool
XtryMove(field, thing, what, fall_down)
X    field_t        *field;
X    thing_t        *thing;
X    command_t       what;
X    Bool            fall_down;
X{
X    int             x, y;
X    thing_t         temp;
X    Bool            ok = True;
X
X    temp = *thing;
X
X    if (fall_down) temp.ypos--;
X
X    switch (what) {
X    case LEFT:
X	temp.xpos--;
X	break;
X
X    case RIGHT:
X	temp.xpos++;
X	break;
X
X    case ROTATE:
X	rotateThing(&temp);
X	break;
X
X    case DROP:
X	while (!overlapping(field, &temp)) {
X	    field->score += field->level;
X	    temp.ypos--;
X	}
X	temp.ypos++;
X	break;
X
X    case NONE:
X	break;
X    }
X
X    for (x = 0; (x < temp.size) && ok; x++)
X	for (y = 0; (y < temp.size) && ok; y++) {
X	    if (temp.map[x][y]) {
X		if ((temp.xpos + x < 0) ||
X			(temp.xpos + x >= field->width) ||
X			(temp.ypos + y < 0) ||
X			(temp.ypos + y >= field->height) ||
X			(field->full[temp.xpos + x]
X			 [temp.ypos + y]))
X		    ok = False;
X	    }
X	}
X
X    if (ok) *thing = temp;
X
X    if (overlapping(field, thing)) {
X	return False;
X    } else {
X	return True;
X    }
X}
X
XBool
XatBottom(field, thing)
X    field_t        *field;
X    thing_t        *thing;
X{
X    int             x, y;
X
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++)
X	    if (thing->map[x][y]) {
X		if (thing->ypos + y <= 0)
X		    return True;
X		if (field->full[thing->xpos + x]
X			[thing->ypos + y - 1])
X		    return True;
X	    }
X    return False;
X}
X
Xvoid
XdrawThing(field, thing)
X    field_t        *field;
X    thing_t        *thing;
X{
X    int             x, y;
X
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++)
X	    if (thing->map[x][y])
X		doBox(field, thing->xpos + x, thing->ypos + y,
X		      thing->map[x][y]);
X    return;
X}
X
Xvoid
XdrawThingDiff(field, thing, oldthing)
X    field_t        *field;
X    thing_t        *thing, *oldthing;
X{
X    int             x, y;
X    int             ox, oy;
X
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++) {
X	    ox = x - oldthing->xpos + thing->xpos;
X	    oy = y - oldthing->ypos + thing->ypos;
X	    if (thing->map[x][y])
X		doBox(field, thing->xpos + x, thing->ypos + y,
X		      thing->map[x][y]);
X	}
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++) {
X	    ox = x - thing->xpos + oldthing->xpos;
X	    oy = y - thing->ypos + oldthing->ypos;
X	    if (oldthing->map[x][y] &&
X		    ((ox < 0) || (ox >= thing->size) ||
X		     (oy < 0) || (oy >= thing->size) ||
X		     !thing->map[ox][oy]))
X		doBox(field, oldthing->xpos + x,
X		      oldthing->ypos + y,
X		      0);
X	}
X    return;
X}
X
Xvoid
XdoBox(field, x, y, pat)
X    field_t        *field;
X    int             x, y;
X    int             pat;
X{
X    if ((x < 0) || (x >= field->width) || (y < 0) || (y >= field->height))
X	abort();
X    if (pat == 0)
X	XFillRectangle(disp, field->win, gc_w2,
X		       x * BOX_WIDTH + X_MARGIN,
X		       ytr((y + 1) * BOX_HEIGHT + Y_MARGIN) - 1,
X		       BOX_WIDTH + 1, BOX_HEIGHT + 1);
X    else {
X	if (rootDepth == 1) {
X	    pat = pat % 16 - 1;
X	    XCopyPlane(disp, patterns[pat].pixmap, field->win, gc_w,
X		       0, 0,
X		       BOX_WIDTH, BOX_HEIGHT,
X		       x * BOX_WIDTH + X_MARGIN,
X		       ytr((y + 1) * BOX_HEIGHT + Y_MARGIN), 1);
X	} else {
X	    pat -= 1;
X	    XCopyPlane(disp, patterns[pat].pixmap, field->win,
X		       gc_pat[pat],
X		       0, 0,
X		       BOX_WIDTH, BOX_HEIGHT,
X		       x * BOX_WIDTH + X_MARGIN,
X		       ytr((y + 1) * BOX_HEIGHT + Y_MARGIN), 1);
X	}
X    }
X    return;
X}
X
XBool
Xoverlapping(field, thing)
X    field_t        *field;
X    thing_t        *thing;
X{
X    int             x, y;
X
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++) {
X	    if (thing->map[x][y] && (thing->ypos + y < 0))
X		return True;
X	    if (thing->map[x][y] && field->full[thing->xpos + x]
X		    [thing->ypos + y])
X		return True;
X	}
X    return False;
X}
X
Xint
XputBoxes(field, thing)
X    field_t        *field;
X    thing_t        *thing;
X{
X    int             x, y;
X    int             highest = 0;
X
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++)
X	    if (thing->map[x][y]) {
X		if ((thing->xpos + x < 0) ||
X			(thing->xpos + x >= field->width) ||
X			(thing->ypos + y < 0) ||
X			(thing->ypos + y >= field->height))
X		    abort();
X		field->full[thing->xpos + x][thing->ypos + y]
X		    = thing->map[x][y];
X		if (thing->ypos + y > highest)
X		    highest = thing->ypos + y;
X	    }
X    return highest;
X}
X
Xfield_t        *
XinitField(width, height, lines_full, argc, argv)
X    int             width, height, lines_full, argc;
X    char           *argv[];
X{
X    XTextProperty   wName, iName;
X    XWMHints        wmhints;
X    XClassHint      classhints;
X    unsigned int    attvm;
X    XSetWindowAttributes att;
X    Cursor          cursor;
X    XSizeHints      sh;
X    field_t        *field = (field_t *) malloc(sizeof(field_t));
X    int             x, y, w, h;;
X
X    w = width * BOX_WIDTH + 2 * X_MARGIN;
X    h = height * BOX_HEIGHT + 2 * Y_MARGIN + TITLE_HEIGHT;
X
X    field->width = width;
X    field->height = height;
X    field->score = 0;
X    field->level = 1;
X    field->lines = 0;
X
X    cursor = XCreateFontCursor(disp, XC_exchange);
X
X    /* create window */
X    attvm = CWBackPixel | CWBorderPixel | CWEventMask | 
X	CWDontPropagate | CWCursor;
X    att.background_pixel = bgcolor.pixel;
X    att.border_pixel = bdcolor.pixel;
X    att.event_mask = ExposureMask | StructureNotifyMask;
X    att.do_not_propagate_mask = KeyPressMask | KeyReleaseMask |
X	ButtonPressMask | ButtonReleaseMask | PointerMotionMask |
X	ButtonMotionMask | Button1MotionMask | Button2MotionMask |
X	Button3MotionMask | Button4MotionMask | Button5MotionMask ;
X    att.cursor = cursor;
X
X    field->frame = XCreateWindow(disp, DefaultRootWindow(disp),
X	BASE_XPOS, BASE_YPOS, w, h, BORDER_WIDTH, CopyFromParent,
X	InputOutput, CopyFromParent, attvm, &att);
X
X    /* title */
X    assert(XStringListToTextProperty(&winName, 1, &wName), "Window Name");
X    assert(XStringListToTextProperty(&iconName, 1, &iName), "Icon Name");
X
X    /* size hints */
X    sh.flags = PSize | PMinSize | PMaxSize;
X    sh.width = (sh.min_width = (sh.max_width = w));
X    sh.height = (sh.min_height = (sh.max_height = h));
X
X    /* wm hints */
X    wmhints.initial_state = NormalState;
X    wmhints.input = True;
X    wmhints.icon_pixmap = None;
X    wmhints.flags = StateHint | InputHint | IconPixmapHint;
X    classhints.res_name = argv[0];
X    classhints.res_class = "GTetris";
X
X    /* set wm properties */
X    XSetWMProperties(disp, field->frame, &wName, &iName,
X	argv, argc, &sh, &wmhints, &classhints);
X
X    /* get ready to receive WM_DELETE_WINDOW */
X    field->delw = XInternAtom(disp, "WM_DELETE_WINDOW", False);
X    XSetWMProtocols(disp, field->frame, &(field->delw), 1);
X
X    /* "title" sub-window */
X    field->title = XCreateSimpleWindow(disp, field->frame,
X	-BORDER_WIDTH, -BORDER_WIDTH, w, TITLE_HEIGHT, BORDER_WIDTH,
X	bdcolor.pixel, bgcolor.pixel);
X    XSelectInput(disp, field->title, KeyPressMask | ExposureMask);
X
X    /* "ground" sub-window */
X    field->win = XCreateSimpleWindow(disp, field->frame,
X	-BORDER_WIDTH, TITLE_HEIGHT - BORDER_WIDTH, w, h - TITLE_HEIGHT,
X	BORDER_WIDTH, bdcolor.pixel, bgcolor.pixel);
X    XSelectInput(disp, field->win, KeyPressMask | ExposureMask);
X
X    if (rootDepth == 1)
X	num_patterns = NUM_BITMAPS;
X
X    field->full = (int **) malloc(sizeof(int *) * width);
X    for (x = 0; x < width; x++) {
X	field->full[x] = (int *) malloc(sizeof(int) * height);
X	for (y = 0; y < height; y++)
X	    if ((y < lines_full) && nrandom(2))
X		field->full[x][y] = nrandom(num_patterns);
X	    else
X		field->full[x][y] = 0;
X    }
X
X    /* loading fonts */
X    field->tfont = XLoadQueryFont(disp, TITLE_FONT);
X    field->sfont = XLoadQueryFont(disp, SCORE_FONT);
X    if (field->tfont == NULL) {
X	field->tfont = XLoadQueryFont(disp, TITLE_FONT2);
X	assert(field->tfont, "Title Font");
X    }
X    if (field->sfont == NULL) {
X	field->sfont = XLoadQueryFont(disp, SCORE_FONT2);
X	assert(field->sfont, "Banner Font");
X    }
X
X    field->winheight = field->height * BOX_HEIGHT + 2 * Y_MARGIN;
X    field->winwidth = field->width * BOX_WIDTH + 2 * X_MARGIN;
X
X    /* map windows */
X    XMapWindow(disp, field->title);
X    XMapWindow(disp, field->win);
X    XMapRaised(disp, field->frame);
X
X    gcv.function = GXcopy;
X    gcv.foreground = bdcolor.pixel;
X    gcv.background = bgcolor.pixel;
X
X    gc_t = XCreateGC(disp, field->title,
X	(GCForeground | GCBackground | GCFunction), &gcv);
X    gc_w = XCreateGC(disp, field->win,
X	(GCForeground | GCBackground | GCFunction), &gcv);
X
X    gcv.background = bdcolor.pixel;
X    gcv.foreground = bgcolor.pixel;
X
X    gc_w2 = XCreateGC(disp, field->win, (GCForeground | GCBackground |
X					 GCFunction), &gcv);
X
X    text.function = GXcopy;
X    text.font = field->tfont->fid;
X    text.foreground = bdcolor.pixel;
X    text.background = bgcolor.pixel;
X    gc_ttx = XCreateGC(disp, field->title, (GCFunction | GCFont |
X				       GCForeground | GCBackground), &text);
X    text.font = field->sfont->fid;
X    gc_wtx = XCreateGC(disp, field->title, (GCFunction | GCFont |
X				       GCForeground | GCBackground), &text);
X
X    XFlush(disp);
X    return (field);
X}
X
Xvoid
XdrawField(field)
X    field_t        *field;
X{
X    int             x, y;
X
X    for (x = 0; x < field->width; x++)
X	for (y = 0; y < field->height; y++)
X	    doBox(field, x, y, field->full[x][y]);
X
X    XDrawImageString(disp, field->title, gc_ttx, 5, 30, "TETRIS", 6);
X
X    updateScore(field);
X
X    XFlush(disp);
X    return;
X}
X
Xvoid
XupdateScore(field)
X    field_t        *field;
X{
X    char            buf[100];
X
X    (void) sprintf(buf, "Score: %-7d", field->score);
X    XDrawImageString(disp, field->title, gc_wtx,
X		     SCORE_XPOS1, SCORE_YPOS1, buf, strlen(buf));
X
X    (void) sprintf(buf, "Level: %-7d", field->level);
X    XDrawImageString(disp, field->title, gc_wtx,
X		     SCORE_XPOS1, SCORE_YPOS2, buf, strlen(buf));
X
X    (void) sprintf(buf, "Lines: %-7d", field->lines);
X    XDrawImageString(disp, field->title, gc_wtx,
X		     SCORE_XPOS2, SCORE_YPOS2, buf, strlen(buf));
X
X    XFlush(disp);
X    return;
X}
X
Xthing_t        *
XmakeNewThing(field)
X    field_t        *field;
X{
X    int             i, j, k;
X    int             pat;
X    int             whichone;
X    thing_t        *thing = (thing_t *) malloc(sizeof(thing_t));
X
X    i = 0;
X    for (j = 0; j < NUM_POSSIBLE; j++)
X	i += possible[j].probability;
X
X    k = nrandom(i);
X
X    for (j = 0; j < NUM_POSSIBLE; j++) {
X	k -= possible[j].probability;
X	if (k < 0)
X	    break;
X    }
X
X    *thing = possible[j];
X    whichone = j;
X    for (i = 0; i < thing->size; i++)
X	for (j = 0; j < thing->size; j++)
X	    if (thing->map[i][j]) {
X		pat = 1;
X		if (i != 0 && thing->map[i - 1][j])
X		    pat += 1;
X		if (j != 0 && thing->map[i][j - 1])
X		    pat += 2;
X		if (i < thing->size - 1 && thing->map[i + 1][j])
X		    pat += 4;
X		if (j < thing->size - 1 && thing->map[i][j + 1])
X		    pat += 8;
X		thing->map[i][j] = pat + whichone * 16;
X	    }
X    for (i = nrandom(4); i > 0; i--)
X	rotateThing(thing);
X
X    thing->ypos = field->height - thing->size;
X    thing->xpos = nrandom((field->width - 2 * thing->size) + thing->size);
X
X    return (thing);
X}
X
Xvoid
XrotateThing(thing)
X    thing_t        *thing;
X{
X    thing_t         temp;
X    int             lpoint = thing->size;
X    int             nlpoint = thing->size;
X    int             x, y;
X    int             pattype;
X
X    temp = *thing;
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++)
X	    if (thing->map[x][y] && (lpoint < y))
X		lpoint = y;
X
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++) {
X	    pattype = (temp.map[y][thing->size - x - 1] - 1) / 16;
X	    thing->map[x][y] =
X		((((temp.map[y][thing->size - x - 1] & 15) - 1) * 2) % 15 + 1)
X		+ pattype * 16;
X	    if (thing->map[x][y] < 0)
X		thing->map[x][y] = 0;
X	}
X
X    for (x = 0; x < thing->size; x++)
X	for (y = 0; y < thing->size; y++)
X	    if (thing->map[x][y] && (nlpoint < y))
X		nlpoint = y;
X
X    thing->ypos += lpoint - nlpoint;
X
X    return;
X}
X
Xint
XcheckLine(field)
X    field_t        *field;
X{
X    int            *set = (int *) malloc(sizeof(int) * field->height);
X    int             i, x, y, nset = 0, h;
X
X    for (y = 0; y < field->height; y++) {
X	for (x = 0; x < field->width; x++)
X	    if (!field->full[x][y])
X		break;
X	if (x == field->width) {
X	    set[y] = 1;
X	    nset++;
X	} else
X	    set[y] = 0;
X    }
X
X    if (nset) {
X	for (i = 0; i < NUM_FLASHES / nset; i++) {
X	    for (y = 0; y < field->height; y++)
X		if (set[y]) {
X		    XFillRectangle(disp, field->win, gc_w,
X				   X_MARGIN,
X				   ytr((y + 1) * BOX_HEIGHT +
X				       Y_MARGIN),
X				   field->width * BOX_WIDTH,
X				   BOX_HEIGHT);
X		    XFlush(disp);
X		}
X	}
X	for (y = 0; y < field->height; y++)
X	    if (set[y]) {
X		for (i = y; i < field->height - 1; i++)
X		    for (x = 0; x < field->width; x++)
X			field->full[x][i] =
X			    field->full[x][i + 1];
X		for (x = 0; x < field->width; x++)
X		    field->full[x][field->height - 1] = 0;
X
X		h = (field->height - y - 1) * BOX_HEIGHT;
X		if (h > field->winheight - BOX_HEIGHT -
X			Y_MARGIN)
X		    h = field->winheight - BOX_HEIGHT -
X			Y_MARGIN;
X		XCopyArea(disp, field->win, field->win, gc_w,
X			  X_MARGIN, Y_MARGIN,
X			  field->winwidth, h,
X			  X_MARGIN, BOX_HEIGHT + Y_MARGIN);
X
X		for (i = y; i < field->height - 1; i++)
X		    set[i] = set[i + 1];
X		set[field->height - 1] = 0;
X		y--;
X	    }
X	if (beep) XBell(disp, -90);
X	XSync(disp, 0);
X    }
X    free((char *) set);
X
X    return nset;
X}
X
Xvoid
XinitPixmaps(field)
X    field_t        *field;
X{
X    Pixmap          bms[NUM_BITMAPS];
X    int             i, j;
X    char           *lastFg = "", *lastBg = "";
X    XColor          lastFgC, lastBgC;
X
X    for (i = 0; i < NUM_BITMAPS; i++) {
X	bms[i] = XCreateBitmapFromData(disp, field->win,
X				       bitmap_data[i].data,
X				       bitmap_data[i].width,
X				       bitmap_data[i].height);
X	assert(bms[i], "Bitmap");
X    }
X    if (rootDepth == 1) {
X	for (i = 0; i < NUM_BITMAPS; i++) {
X	    patterns[i].pixmap = bms[i];
X	}
X	return;
X    }
X    for (i = 0; i < NUM_PATTERNS; i++) {
X	j = 0;
X	if (strcmp(patterns[i].fgname, lastFg) != 0) {
X	    assert(XParseColor(disp, cmap,
X		patterns[i].fgname, &patterns[i].fg), "Parse Color");
X	    assert(XAllocColor(disp, cmap, &patterns[i].fg), "Allocate Color");
X	    lastFg = patterns[i].fgname;
X	    lastFgC = patterns[i].fg;
X	    j = 1;
X	} else {
X	    patterns[i].fg = lastFgC;
X	}
X	if (strcmp(patterns[i].bgname, lastBg) != 0) {
X	    assert(XParseColor(disp, cmap,
X		patterns[i].bgname, &patterns[i].bg), "Parse Color");
X	    assert(XAllocColor(disp, cmap, &patterns[i].bg), "Allocate Color");
X	    lastBg = patterns[i].bgname;
X	    lastBgC = patterns[i].bg;
X	    j = 1;
X	} else {
X	    patterns[i].bg = lastBgC;
X	}
X
X	if (j) {
X	    color.function = GXcopy;
X	    color.foreground = patterns[i].fg.pixel;
X	    color.background = patterns[i].bg.pixel;
X
X	    gc_pat[i] = XCreateGC(disp, field->win, (GCForeground |
X					GCBackground | GCFunction), &color);
X	} else
X	    gc_pat[i] = gc_pat[i - 1];
X
X	patterns[i].pixmap = bms[patterns[i].whichbitmap];
X	assert(patterns[i].pixmap, "Pixmap");
X    }
X    return;
X}
X
Xint
Xnrandom(n)
X    int             n;
X{
X    return ((((double) random()) / ((double) 0x7fffffff)) * n);
X}
X
Xvoid
XUsage(argv)
X    char          **argv;
X{
X    fprintf(stderr, "Usage:  %s [ starting_level [ rows_pre-filled ] ]\n\n",
X	argv[0]);
X    exit(255);
X}
X
END_OF_FILE
if test 20459 -ne `wc -c <'utils.c'`; then
    echo shar: \"'utils.c'\" unpacked with wrong size!
fi
# end of 'utils.c'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
