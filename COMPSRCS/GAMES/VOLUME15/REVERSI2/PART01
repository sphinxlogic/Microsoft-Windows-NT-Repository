Path: uunet!ogicse!news.u.washington.edu!uw-beaver!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v15i018:  reversi2 - another reversi game, Part01/02
Message-ID: <3833@master.CNA.TEK.COM>
Date: 29 Oct 92 16:26:06 GMT
Article-I.D.: master.3833
Sender: news@master.CNA.TEK.COM
Lines: 2228
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1517

Submitted-by: esafern@shearson.COM (Eric Safern)
Posting-number: Volume 15, Issue 18
Archive-name: reversi2/Part01
Environment: curses

	[Although this was submitted by Eric, he didn't write it. I couldn't
	 find any author information so if you recognize this, please send
	 me a note so I can give proper credit. I pieced together the README
	 file from looking at the code.  -br]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 2)."
# Contents:  README MANIFEST makeedge.c makeedge.y ulex.l user.y
# Wrapped by billr@saab on Thu Oct 29 08:20:57 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1233 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XReversi plays a game of reversi between a computer and human player, between
Xtwo computer players or two human players.
X
XCommand line arguments accepted are:
X	-b computer is black
X	-w computer is white
X	-11 first player (human) is white
X	-10 first player (human) is black
X	-s show the score file
X
XOnce the game is started, help can be obtained by entering "help" at the
Xprompt. "nohelp" removes the help text. Moves are entered as two numbers
X(row column) seperated by a space and/or comma. Other commands are:
X
X	[no] grid			turn the grid on or off
X	hint				provide a hint for the next move
X	play white|black|both|none	selects which side the computer plays
X	white|black first		selects which color goes first
X	white|black second		selects which color goes second
X	level number			selects the difficulty level
X	[no] score			display (don't display) the score
X	new				start a new game
X	eval				give white's score at the current state
X	record filename			record plays into a file
X	replay filename			replay a previously recorded game
X	save filename			save the game into a file
X	undo				undo the previous move
X	quit				quit the game
X	debug <str>			where <str> is one or more of:
X						'm', 's' or '!'
X	[no] help			turn help display on or off
X
END_OF_FILE
if test 1233 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(672 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X README                     1	
X corners.c                  2	
X count.c                    2	
X display.c                  2	
X edges.c                    2	
X fini.c                     2	
X genedge.c                  2	
X hasmove.c                  2	
X makeedge.c                 1	
X makeedge.y                 1	
X makefile                   2	
X minmax.c                   2	
X move.c                     2	
X reversi.h                  2	
X score.c                    2	
X ulex.l                     1	
X user.y                     1	
END_OF_FILE
if test 672 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'makeedge.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makeedge.c'\"
else
echo shar: Extracting \"'makeedge.c'\" \(30399 characters\)
sed "s/^X//" >'makeedge.c' <<'END_OF_FILE'
Xextern char *malloc(), *realloc();
X
X# line 2 "makeedge.y"
X/*
X *	ex:set ts=8 sw=8:
X */
Xint	score;
Xextern int	position;
X
X# line 8 "makeedge.y"
Xtypedef union  {
X	struct {
X		int	width;
X		int	position;
X		int	base;
X	} field;
X	int	ival;
X} YYSTYPE;
X# define WHITE 257
X# define BLACK 258
X# define EMPTY 259
X# define NL 260
X#define yyclearin yychar = -1
X#define yyerrok yyerrflag = 0
Xextern int yychar;
Xextern int yyerrflag;
X#ifndef YYMAXDEPTH
X#define YYMAXDEPTH 150
X#endif
XYYSTYPE yylval, yyval;
X# define YYERRCODE 256
X
X# line 381 "makeedge.y"
X
X
X# include	<stdio.h>
X
Xmain ()
X{
X	return yyparse ();
X}
X
Xchar	line[80];
Xchar	*lp = line;
X
Xyyerror (s)
Xchar *s;
X{
X	fprintf (stderr, "%s in %s\n", s, line);
X}
X
Xyywrap ()
X{
X	return 1;
X}
X
Xint position = 1;
X
Xint base[] = { 0, 20, -30, 15, -5, -5, 15, -30, 20, 0 };
X
Xyylex ()
X{
X	char *gets();
X
X	if (*lp == '\0')
X		if (fgets (line, 80, stdin) == 0)
X			return -1;
X		else
X			lp = line;
X	for (;;) {
X		switch (*lp++) {
X		case ' ':
X		case '\t':
X			break;
X		case '\n':
X			lp[-1] = '\0';
X			position = 1;
X			return NL;
X		case 'O':
X			yylval.field.base = -
X				base[yylval.field.position = position++];
X			yylval.field.width = 1;
X			return BLACK;
X		case '*':
X			yylval.field.base =
X				base[yylval.field.position = position++];
X			yylval.field.width = 1;
X			return WHITE;
X		case '-':
X			yylval.field.base = 0;
X			yylval.field.position = position++;
X			yylval.field.width = 1;
X			return EMPTY;
X		}
X	}
X}
Xint yyexca[] ={
X-1, 1,
X	0, -1,
X	-2, 0,
X	};
X# define YYNPROD 50
X# define YYLAST 189
Xint yyact[]={
X
X     6,    14,    12,     9,     7,    12,     6,     7,    26,     6,
X    14,    50,     9,     7,    47,     6,    14,    41,     9,     7,
X    38,     6,     7,    12,     6,     7,     5,    14,    12,     9,
X    56,    12,    25,    36,    32,    22,     6,     7,     6,    26,
X     7,    59,     1,    31,    30,    27,    29,    60,     4,    35,
X    10,    37,    20,    21,    17,     2,     0,    46,     8,     0,
X     0,     0,    33,     0,    13,     0,    39,    55,     0,     0,
X    10,     0,     0,     0,     0,    49,     0,    66,     0,    69,
X     0,    68,    45,     0,    72,    65,    74,    62,    63,    10,
X    62,     0,     0,     0,    28,     0,     3,    71,    54,    15,
X    19,    64,    78,     0,    58,    23,    80,     0,    39,     0,
X    83,     0,    84,     0,     0,    42,     0,    81,    82,     0,
X     0,     0,    62,    62,    52,    70,     0,     0,    15,    11,
X    16,    18,    73,    57,    15,    61,    24,    75,    61,     0,
X     0,    34,    67,    76,     0,    40,    43,    77,     0,    44,
X     0,    79,     0,     0,    48,    51,     0,    42,     0,    53,
X     0,     0,     0,     0,     0,    16,     0,     0,    11,     0,
X    61,    61,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,    40,    43 };
Xint yypact[]={
X
X -1000,  -233, -1000,  -254,  -257,  -236, -1000, -1000,  -225, -1000,
X  -257,  -251, -1000,  -226, -1000,  -254,  -251,  -227,  -251,  -239,
X  -242, -1000, -1000,  -254,  -251, -1000, -1000, -1000,  -245,  -248,
X -1000, -1000, -1000,  -257,  -251, -1000, -1000,  -230,  -219,  -257,
X  -251,  -218,  -254,  -251,  -251, -1000, -1000,  -219,  -251,  -231,
X  -218,  -251,  -228,  -251, -1000, -1000, -1000,  -228, -1000, -1000,
X -1000,  -254,  -257,  -231, -1000, -1000, -1000,  -228, -1000,  -221,
X  -220,  -231, -1000,  -221, -1000,  -221,  -221,  -221, -1000,  -221,
X -1000, -1000, -1000, -1000, -1000 };
Xint yypgo[]={
X
X     0,    55,    94,    46,   125,    79,    58,    64,    41,    47,
X    54,    32,    45,    44,    43,    42 };
Xint yyr1[]={
X
X     0,    15,    15,     1,     1,     1,     1,     6,     6,     6,
X     6,     6,     6,     7,     7,     7,     7,     7,     7,    11,
X    11,     2,     2,     3,     3,     4,     4,     8,     8,    10,
X    10,    10,     9,     9,     9,     9,     9,     9,    12,    12,
X    12,    12,    12,    12,    12,    12,    13,    14,     5,     5 };
Xint yyr2[]={
X
X     0,     5,     0,     7,     7,     7,     9,     9,     7,     7,
X     3,     5,     1,     9,     7,     7,     3,     5,     1,     3,
X     1,     5,     3,     5,     3,     5,     3,     3,     1,    11,
X    11,     2,     7,     7,     7,     7,     3,     3,    11,     7,
X    11,     7,     3,     3,     3,     3,     9,     9,     3,     1 };
Xint yychk[]={
X
X -1000,   -15,    -1,    -2,    -3,   259,   257,   258,    -6,   257,
X    -3,    -4,   259,    -7,   258,    -2,    -4,   -10,    -4,    -2,
X    -3,    -9,   260,    -2,    -4,   -11,   259,   -12,    -2,    -3,
X   -13,   -14,   260,    -3,    -4,   -11,   260,   -11,   259,    -3,
X    -4,   259,    -2,    -4,    -4,    -6,   -11,   259,    -4,    -3,
X   259,    -4,    -2,    -4,    -7,   -11,   260,    -2,    -7,    -8,
X    -9,    -2,    -3,    -3,    -6,    -8,   -11,    -2,   -11,    -5,
X    -4,    -3,   -11,    -5,   -11,    -5,    -5,    -5,   -11,    -5,
X   -11,    -8,    -8,   -11,   -11 };
Xint yydef[]={
X
X     2,    -2,     1,    12,    18,     0,    22,    24,     0,    21,
X    10,    20,    26,     0,    23,    16,    20,     0,    20,    36,
X    37,    31,     3,    12,    20,    11,    25,    19,    42,    43,
X    44,    45,     4,    18,    20,    17,     5,     0,    26,    18,
X    28,    26,    12,    28,    20,     8,     9,    26,    20,    49,
X    26,    20,    49,    20,    14,    15,     6,    49,    32,    34,
X    27,    36,    37,    49,    33,    35,     7,    49,    39,    20,
X    48,    49,    41,    20,    13,    28,    28,    20,    46,    20,
X    47,    29,    30,    38,    40 };
Xtypedef struct { char *t_name; int t_val; } yytoktype;
X#ifndef YYDEBUG
X#	define YYDEBUG	0	/* don't allow debugging */
X#endif
X
X#if YYDEBUG
X
Xyytoktype yytoks[] =
X{
X	"WHITE",	257,
X	"BLACK",	258,
X	"EMPTY",	259,
X	"NL",	260,
X	"-unknown-",	-1	/* ends search */
X};
X
Xchar * yyreds[] =
X{
X	"-no such reduction-",
X	"lines : lines line",
X	"lines : /* empty */",
X	"line : whites type1 NL",
X	"line : blacks type2 NL",
X	"line : EMPTY type3 NL",
X	"line : EMPTY empties otype4 NL",
X	"type1 : blacks whites empties otype4",
X	"type1 : blacks whites type1",
X	"type1 : blacks empties otype4",
X	"type1 : blacks",
X	"type1 : empties otype4",
X	"type1 : /* empty */",
X	"type2 : whites blacks empties otype4",
X	"type2 : whites blacks type2",
X	"type2 : whites empties otype4",
X	"type2 : whites",
X	"type2 : empties otype4",
X	"type2 : /* empty */",
X	"otype4 : type4",
X	"otype4 : /* empty */",
X	"whites : whites WHITE",
X	"whites : WHITE",
X	"blacks : blacks BLACK",
X	"blacks : BLACK",
X	"empties : empties EMPTY",
X	"empties : EMPTY",
X	"otype3e : type3e",
X	"otype3e : /* empty */",
X	"type3 : whites EMPTY whites oempties otype3e",
X	"type3 : blacks EMPTY blacks oempties otype3e",
X	"type3 : type3e",
X	"type3e : whites blacks type2",
X	"type3e : blacks whites type1",
X	"type3e : whites empties otype3e",
X	"type3e : blacks empties otype3e",
X	"type3e : whites",
X	"type3e : blacks",
X	"type4 : whites EMPTY whites oempties otype4",
X	"type4 : whites empties otype4",
X	"type4 : blacks EMPTY blacks oempties otype4",
X	"type4 : blacks empties otype4",
X	"type4 : whites",
X	"type4 : blacks",
X	"type4 : type4.w",
X	"type4 : type4.b",
X	"type4.w : whites blacks oempties otype4",
X	"type4.b : blacks whites oempties otype4",
X	"oempties : empties",
X	"oempties : /* empty */",
X};
X#endif /* YYDEBUG */
X#line 1 "/usr/lib/yaccpar"
X/*	@(#)yaccpar 1.10 89/04/04 SMI; from S5R3 1.10	*/
X
X/*
X** Skeleton parser driver for yacc output
X*/
X
X/*
X** yacc user known macros and defines
X*/
X#define YYERROR		goto yyerrlab
X#define YYACCEPT	{ free(yys); free(yyv); return(0); }
X#define YYABORT		{ free(yys); free(yyv); return(1); }
X#define YYBACKUP( newtoken, newvalue )\
X{\
X	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
X	{\
X		yyerror( "syntax error - cannot backup" );\
X		goto yyerrlab;\
X	}\
X	yychar = newtoken;\
X	yystate = *yyps;\
X	yylval = newvalue;\
X	goto yynewstate;\
X}
X#define YYRECOVERING()	(!!yyerrflag)
X#ifndef YYDEBUG
X#	define YYDEBUG	1	/* make debugging available */
X#endif
X
X/*
X** user known globals
X*/
Xint yydebug;			/* set to 1 to get debugging */
X
X/*
X** driver internal defines
X*/
X#define YYFLAG		(-1000)
X
X/*
X** static variables used by the parser
X*/
Xstatic YYSTYPE *yyv;			/* value stack */
Xstatic int *yys;			/* state stack */
X
Xstatic YYSTYPE *yypv;			/* top of value stack */
Xstatic int *yyps;			/* top of state stack */
X
Xstatic int yystate;			/* current state */
Xstatic int yytmp;			/* extra var (lasts between blocks) */
X
Xint yynerrs;			/* number of errors */
X
Xint yyerrflag;			/* error recovery flag */
Xint yychar;			/* current input token number */
X
X
X/*
X** yyparse - return 0 if worked, 1 if syntax error not recovered from
X*/
Xint
Xyyparse()
X{
X	register YYSTYPE *yypvt;	/* top of value stack for $vars */
X	unsigned yymaxdepth = YYMAXDEPTH;
X
X	/*
X	** Initialize externals - yyparse may be called more than once
X	*/
X	yyv = (YYSTYPE*)malloc(yymaxdepth*sizeof(YYSTYPE));
X	yys = (int*)malloc(yymaxdepth*sizeof(int));
X	if (!yyv || !yys)
X	{
X		yyerror( "out of memory" );
X		return(1);
X	}
X	yypv = &yyv[-1];
X	yyps = &yys[-1];
X	yystate = 0;
X	yytmp = 0;
X	yynerrs = 0;
X	yyerrflag = 0;
X	yychar = -1;
X
X	goto yystack;
X	{
X		register YYSTYPE *yy_pv;	/* top of value stack */
X		register int *yy_ps;		/* top of state stack */
X		register int yy_state;		/* current state */
X		register int  yy_n;		/* internal state number info */
X
X		/*
X		** get globals into registers.
X		** branch to here only if YYBACKUP was called.
X		*/
X	yynewstate:
X		yy_pv = yypv;
X		yy_ps = yyps;
X		yy_state = yystate;
X		goto yy_newstate;
X
X		/*
X		** get globals into registers.
X		** either we just started, or we just finished a reduction
X		*/
X	yystack:
X		yy_pv = yypv;
X		yy_ps = yyps;
X		yy_state = yystate;
X
X		/*
X		** top of for (;;) loop while no reductions done
X		*/
X	yy_stack:
X		/*
X		** put a state and value onto the stacks
X		*/
X#if YYDEBUG
X		/*
X		** if debugging, look up token value in list of value vs.
X		** name pairs.  0 and negative (-1) are special values.
X		** Note: linear search is used since time is not a real
X		** consideration while debugging.
X		*/
X		if ( yydebug )
X		{
X			register int yy_i;
X
X			(void)printf( "State %d, token ", yy_state );
X			if ( yychar == 0 )
X				(void)printf( "end-of-file\n" );
X			else if ( yychar < 0 )
X				(void)printf( "-none-\n" );
X			else
X			{
X				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
X					yy_i++ )
X				{
X					if ( yytoks[yy_i].t_val == yychar )
X						break;
X				}
X				(void)printf( "%s\n", yytoks[yy_i].t_name );
X			}
X		}
X#endif /* YYDEBUG */
X		if ( ++yy_ps >= &yys[ yymaxdepth ] )	/* room on stack? */
X		{
X			/*
X			** reallocate and recover.  Note that pointers
X			** have to be reset, or bad things will happen
X			*/
X			int yyps_index = (yy_ps - yys);
X			int yypv_index = (yy_pv - yyv);
X			int yypvt_index = (yypvt - yyv);
X			yymaxdepth += YYMAXDEPTH;
X			yyv = (YYSTYPE*)realloc((char*)yyv,
X				yymaxdepth * sizeof(YYSTYPE));
X			yys = (int*)realloc((char*)yys,
X				yymaxdepth * sizeof(int));
X			if (!yyv || !yys)
X			{
X				yyerror( "yacc stack overflow" );
X				return(1);
X			}
X			yy_ps = yys + yyps_index;
X			yy_pv = yyv + yypv_index;
X			yypvt = yyv + yypvt_index;
X		}
X		*yy_ps = yy_state;
X		*++yy_pv = yyval;
X
X		/*
X		** we have a new state - find out what to do
X		*/
X	yy_newstate:
X		if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG )
X			goto yydefault;		/* simple state */
X#if YYDEBUG
X		/*
X		** if debugging, need to mark whether new token grabbed
X		*/
X		yytmp = yychar < 0;
X#endif
X		if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
X			yychar = 0;		/* reached EOF */
X#if YYDEBUG
X		if ( yydebug && yytmp )
X		{
X			register int yy_i;
X
X			(void)printf( "Received token " );
X			if ( yychar == 0 )
X				(void)printf( "end-of-file\n" );
X			else if ( yychar < 0 )
X				(void)printf( "-none-\n" );
X			else
X			{
X				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
X					yy_i++ )
X				{
X					if ( yytoks[yy_i].t_val == yychar )
X						break;
X				}
X				(void)printf( "%s\n", yytoks[yy_i].t_name );
X			}
X		}
X#endif /* YYDEBUG */
X		if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) )
X			goto yydefault;
X		if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
X		{
X			yychar = -1;
X			yyval = yylval;
X			yy_state = yy_n;
X			if ( yyerrflag > 0 )
X				yyerrflag--;
X			goto yy_stack;
X		}
X
X	yydefault:
X		if ( ( yy_n = yydef[ yy_state ] ) == -2 )
X		{
X#if YYDEBUG
X			yytmp = yychar < 0;
X#endif
X			if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
X				yychar = 0;		/* reached EOF */
X#if YYDEBUG
X			if ( yydebug && yytmp )
X			{
X				register int yy_i;
X
X				(void)printf( "Received token " );
X				if ( yychar == 0 )
X					(void)printf( "end-of-file\n" );
X				else if ( yychar < 0 )
X					(void)printf( "-none-\n" );
X				else
X				{
X					for ( yy_i = 0;
X						yytoks[yy_i].t_val >= 0;
X						yy_i++ )
X					{
X						if ( yytoks[yy_i].t_val
X							== yychar )
X						{
X							break;
X						}
X					}
X					(void)printf( "%s\n", yytoks[yy_i].t_name );
X				}
X			}
X#endif /* YYDEBUG */
X			/*
X			** look through exception table
X			*/
X			{
X				register int *yyxi = yyexca;
X
X				while ( ( *yyxi != -1 ) ||
X					( yyxi[1] != yy_state ) )
X				{
X					yyxi += 2;
X				}
X				while ( ( *(yyxi += 2) >= 0 ) &&
X					( *yyxi != yychar ) )
X					;
X				if ( ( yy_n = yyxi[1] ) < 0 )
X					YYACCEPT;
X			}
X		}
X
X		/*
X		** check for syntax error
X		*/
X		if ( yy_n == 0 )	/* have an error */
X		{
X			/* no worry about speed here! */
X			switch ( yyerrflag )
X			{
X			case 0:		/* new error */
X				yyerror( "syntax error" );
X				goto skip_init;
X			yyerrlab:
X				/*
X				** get globals into registers.
X				** we have a user generated syntax type error
X				*/
X				yy_pv = yypv;
X				yy_ps = yyps;
X				yy_state = yystate;
X				yynerrs++;
X			skip_init:
X			case 1:
X			case 2:		/* incompletely recovered error */
X					/* try again... */
X				yyerrflag = 3;
X				/*
X				** find state where "error" is a legal
X				** shift action
X				*/
X				while ( yy_ps >= yys )
X				{
X					yy_n = yypact[ *yy_ps ] + YYERRCODE;
X					if ( yy_n >= 0 && yy_n < YYLAST &&
X						yychk[yyact[yy_n]] == YYERRCODE)					{
X						/*
X						** simulate shift of "error"
X						*/
X						yy_state = yyact[ yy_n ];
X						goto yy_stack;
X					}
X					/*
X					** current state has no shift on
X					** "error", pop stack
X					*/
X#if YYDEBUG
X#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
X					if ( yydebug )
X						(void)printf( _POP_, *yy_ps,
X							yy_ps[-1] );
X#	undef _POP_
X#endif
X					yy_ps--;
X					yy_pv--;
X				}
X				/*
X				** there is no state on stack with "error" as
X				** a valid shift.  give up.
X				*/
X				YYABORT;
X			case 3:		/* no shift yet; eat a token */
X#if YYDEBUG
X				/*
X				** if debugging, look up token in list of
X				** pairs.  0 and negative shouldn't occur,
X				** but since timing doesn't matter when
X				** debugging, it doesn't hurt to leave the
X				** tests here.
X				*/
X				if ( yydebug )
X				{
X					register int yy_i;
X
X					(void)printf( "Error recovery discards " );
X					if ( yychar == 0 )
X						(void)printf( "token end-of-file\n" );
X					else if ( yychar < 0 )
X						(void)printf( "token -none-\n" );
X					else
X					{
X						for ( yy_i = 0;
X							yytoks[yy_i].t_val >= 0;
X							yy_i++ )
X						{
X							if ( yytoks[yy_i].t_val
X								== yychar )
X							{
X								break;
X							}
X						}
X						(void)printf( "token %s\n",
X							yytoks[yy_i].t_name );
X					}
X				}
X#endif /* YYDEBUG */
X				if ( yychar == 0 )	/* reached EOF. quit */
X					YYABORT;
X				yychar = -1;
X				goto yy_newstate;
X			}
X		}/* end if ( yy_n == 0 ) */
X		/*
X		** reduction by production yy_n
X		** put stack tops, etc. so things right after switch
X		*/
X#if YYDEBUG
X		/*
X		** if debugging, print the string that is the user's
X		** specification of the reduction which is just about
X		** to be done.
X		*/
X		if ( yydebug )
X			(void)printf( "Reduce by (%d) \"%s\"\n",
X				yy_n, yyreds[ yy_n ] );
X#endif
X		yytmp = yy_n;			/* value to switch over */
X		yypvt = yy_pv;			/* $vars top of value stack */
X		/*
X		** Look in goto table for next state
X		** Sorry about using yy_state here as temporary
X		** register variable, but why not, if it works...
X		** If yyr2[ yy_n ] doesn't have the low order bit
X		** set, then there is no action to be done for
X		** this reduction.  So, no saving & unsaving of
X		** registers done.  The only difference between the
X		** code just after the if and the body of the if is
X		** the goto yy_stack in the body.  This way the test
X		** can be made before the choice of what to do is needed.
X		*/
X		{
X			/* length of production doubled with extra bit */
X			register int yy_len = yyr2[ yy_n ];
X
X			if ( !( yy_len & 01 ) )
X			{
X				yy_len >>= 1;
X				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
X				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
X					*( yy_ps -= yy_len ) + 1;
X				if ( yy_state >= YYLAST ||
X					yychk[ yy_state =
X					yyact[ yy_state ] ] != -yy_n )
X				{
X					yy_state = yyact[ yypgo[ yy_n ] ];
X				}
X				goto yy_stack;
X			}
X			yy_len >>= 1;
X			yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
X			yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
X				*( yy_ps -= yy_len ) + 1;
X			if ( yy_state >= YYLAST ||
X				yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
X			{
X				yy_state = yyact[ yypgo[ yy_n ] ];
X			}
X		}
X					/* save until reenter driver code */
X		yystate = yy_state;
X		yyps = yy_ps;
X		yypv = yy_pv;
X	}
X	/*
X	** code supplied by user is placed in this switch
X	*/
X	switch( yytmp )
X	{
X		
Xcase 1:
X# line 22 "makeedge.y"
X{ printf ("\t%5d,\t/*%s */\n", yypvt[-0].field.base, line); } break;
Xcase 3:
X# line 26 "makeedge.y"
X{ yyval.field.base = 20 * yypvt[-2].field.width + yypvt[-1].field.base; } break;
Xcase 4:
X# line 28 "makeedge.y"
X{ yyval.field.base = -20 * yypvt[-2].field.width + yypvt[-1].field.base; } break;
Xcase 5:
X# line 30 "makeedge.y"
X{ yyval.field.base = yypvt[-1].field.base; } break;
Xcase 6:
X# line 32 "makeedge.y"
X{ yyval.field.base = yypvt[-1].field.base; } break;
Xcase 7:
X# line 35 "makeedge.y"
X{
X				yyval.field.base = yypvt[-0].field.base;
X				switch (yypvt[-2].field.position) {
X				case 7:
X					yyval.field.base -= (yypvt[-2].field.width + yypvt[-3].field.width+1) * 15;
X					break;
X				default:
X					if (yypvt[-1].field.width == 1)
X						yyval.field.base -=
X						(yypvt[-3].field.width + yypvt[-2].field.width+1) * 15;
X					else
X						yyval.field.base +=
X						(yypvt[-2].field.width - yypvt[-3].field.width) * 20;
X					break;
X				}
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-3].field.width + yypvt[-2].field.width + yypvt[-1].field.width;
X			} break;
Xcase 8:
X# line 54 "makeedge.y"
X{
X				yyval.field.base = yypvt[-0].field.base;
X				yyval.field.base -= (yypvt[-2].field.width - yypvt[-1].field.width) * 20;
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-2].field.width + yypvt[-1].field.width + yypvt[-0].field.width;
X			} break;
Xcase 9:
X# line 61 "makeedge.y"
X{
X				yyval.field.base = (yypvt[-2].field.width + 1) * 15 + yypvt[-0].field.base;
X				yyval.field.width = yypvt[-2].field.width + yypvt[-1].field.width + yypvt[-0].field.width;
X				yyval.field.position = yypvt[-0].field.position;
X			} break;
Xcase 10:
X# line 67 "makeedge.y"
X{
X				yyval.field = yypvt[-0].field;
X				yyval.field.base = - yypvt[-0].field.width * 20;
X			} break;
Xcase 11:
X# line 72 "makeedge.y"
X{
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-1].field.width+yypvt[-0].field.width;
X				yyval.field.base = yypvt[-0].field.base;
X			} break;
Xcase 12:
X# line 78 "makeedge.y"
X{ yyval.field.position = position; yyval.field.width = 0; yyval.field.base = 0; } break;
Xcase 13:
X# line 81 "makeedge.y"
X{
X				yyval.field.base = yypvt[-0].field.base;
X				switch (yypvt[-2].field.position) {
X				case 7:
X					yyval.field.base += (yypvt[-2].field.width + yypvt[-3].field.width+1) * 15;
X					break;
X				default:
X					if (yypvt[-1].field.width == 1)
X						yyval.field.base +=
X						(yypvt[-3].field.width + yypvt[-2].field.width+1) * 15;
X					else
X						yyval.field.base -=
X						(yypvt[-2].field.width - yypvt[-3].field.width) * 20;
X					break;
X				}
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-3].field.width + yypvt[-2].field.width + yypvt[-1].field.width
X					 + yypvt[-0].field.width;
X			} break;
Xcase 14:
X# line 101 "makeedge.y"
X{
X				yyval.field.base = yypvt[-0].field.base;
X				yyval.field.base += (yypvt[-2].field.width - yypvt[-1].field.width) * 20;
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-2].field.width + yypvt[-1].field.width + yypvt[-0].field.width;
X			} break;
Xcase 15:
X# line 108 "makeedge.y"
X{
X				yyval.field.base = - (yypvt[-2].field.width + 1) * 15 + yypvt[-0].field.base;
X				yyval.field.width = yypvt[-2].field.width + yypvt[-1].field.width + yypvt[-0].field.width;
X				yyval.field.position = yypvt[-0].field.position;
X			} break;
Xcase 16:
X# line 114 "makeedge.y"
X{
X				yyval.field = yypvt[-0].field;
X				yyval.field.base = yypvt[-0].field.width * 20;
X			} break;
Xcase 17:
X# line 119 "makeedge.y"
X{
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-1].field.width+yypvt[-0].field.width;
X				yyval.field.base = yypvt[-0].field.base;
X			} break;
Xcase 18:
X# line 125 "makeedge.y"
X{ yyval.field.position = 0; yyval.field.width = 0; yyval.field.base = 0; } break;
Xcase 19:
X# line 128 "makeedge.y"
X{ yyval.field = yypvt[-0].field; } break;
Xcase 20:
X# line 130 "makeedge.y"
X{ yyval.field.position = position; yyval.field.width = 0; yyval.field.base = 0; } break;
Xcase 21:
X# line 133 "makeedge.y"
X{
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-1].field.width + yypvt[-0].field.width;
X				yyval.field.base = yypvt[-1].field.base + yypvt[-0].field.base;
X			} break;
Xcase 22:
X# line 139 "makeedge.y"
X{ yyval.field = yypvt[-0].field; } break;
Xcase 23:
X# line 142 "makeedge.y"
X{
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-1].field.width + yypvt[-0].field.width;
X				yyval.field.base = yypvt[-1].field.base + yypvt[-0].field.base;
X			} break;
Xcase 24:
X# line 148 "makeedge.y"
X{ yyval.field = yypvt[-0].field; } break;
Xcase 25:
X# line 151 "makeedge.y"
X{
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-1].field.width + yypvt[-0].field.width;
X				yyval.field.base = yypvt[-1].field.base + yypvt[-0].field.base;
X			} break;
Xcase 26:
X# line 157 "makeedge.y"
X{ yyval.field = yypvt[-0].field; } break;
Xcase 27:
X# line 160 "makeedge.y"
X{ yyval.field = yypvt[-0].field; } break;
Xcase 28:
X# line 162 "makeedge.y"
X{ yyval.field.position = position; yyval.field.width = 0; yyval.field.base = 0; } break;
Xcase 29:
X# line 165 "makeedge.y"
X{
X				yyval.field.base = -(yypvt[-4].field.width + yypvt[-2].field.width + 2) * 15 +
X					yypvt[-0].field.base;
X				yyval.field.width = yypvt[-4].field.width + yypvt[-3].field.width + yypvt[-2].field.width 
X					 + yypvt[-1].field.width + yypvt[-0].field.width;
X				yyval.field.position = yypvt[-0].field.position;
X			} break;
Xcase 30:
X# line 173 "makeedge.y"
X{
X				yyval.field.base = (yypvt[-4].field.width + yypvt[-2].field.width + 2) * 15 +
X					yypvt[-0].field.base;
X				yyval.field.width = yypvt[-4].field.width + yypvt[-3].field.width + yypvt[-2].field.width 
X					 + yypvt[-1].field.width + yypvt[-0].field.width;
X				yyval.field.position = yypvt[-0].field.position;
X			} break;
Xcase 32:
X# line 183 "makeedge.y"
X{
X				yyval.field.base = -15 * (yypvt[-2].field.width + yypvt[-1].field.width + 1);
X				yyval.field.width = yypvt[-2].field.width + yypvt[-1].field.width + yypvt[-0].field.width;
X				yyval.field.position = yypvt[-0].field.position;
X			} break;
Xcase 33:
X# line 189 "makeedge.y"
X{
X				yyval.field.base = 15 * (yypvt[-2].field.width + yypvt[-1].field.width + 1);
X				yyval.field.width = yypvt[-2].field.width + yypvt[-1].field.width + yypvt[-0].field.width;
X				yyval.field.position = yypvt[-0].field.position;
X			} break;
Xcase 34:
X# line 195 "makeedge.y"
X{
X				if (yypvt[-2].field.position - yypvt[-2].field.width == 1) {
X					switch (yypvt[-2].field.width) {
X					case 1:
X						yyval.field.base = -30;
X						break;
X					case 6:
X						yyval.field.base = -20;
X						break;
X					case 2:
X						yyval.field.base = -15;
X						break;
X					case 3:
X						yyval.field.base = -10;
X						break;
X					case 4:
X						yyval.field.base = -5;
X						break;
X					case 5:
X						yyval.field.base = 10;
X						break;
X					default:
X						yyerror ("weirdo");
X						break;
X					}
X				} else {
X					yyval.field.base = yypvt[-2].field.base;
X				}
X				yyval.field.base += yypvt[-0].field.base;
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-2].field.width + yypvt[-1].field.width + yypvt[-0].field.width;
X			} break;
Xcase 35:
X# line 228 "makeedge.y"
X{
X				if (yypvt[-2].field.position - yypvt[-2].field.width == 1) {
X					switch (yypvt[-2].field.width) {
X					case 1:
X						yyval.field.base = 30;
X						break;
X					case 6:
X						yyval.field.base = 20;
X					break;
X					case 2:
X						yyval.field.base = 15;
X						break;
X					case 3:
X						yyval.field.base = 10;
X						break;
X					case 4:
X						yyval.field.base = 5;
X						break;
X					case 5:
X						yyval.field.base = -10;
X						break;
X					default:
X						yyerror ("weirdo");
X						break;
X					}
X				} else {
X					yyval.field.base = yypvt[-2].field.base;
X				}
X				yyval.field.base += yypvt[-0].field.base;
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-2].field.width + yypvt[-1].field.width + yypvt[-0].field.width;
X			} break;
Xcase 36:
X# line 261 "makeedge.y"
X{
X				yyval.field.base = 20 * yypvt[-0].field.width;
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-0].field.width;
X			} break;
Xcase 37:
X# line 267 "makeedge.y"
X{
X				yyval.field.base = -20 * yypvt[-0].field.width;
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-0].field.width;
X			} break;
Xcase 38:
X# line 274 "makeedge.y"
X{
X			if (yypvt[-1].field.position == 8) {
X				yyval.field.base = -(yypvt[-4].field.width + yypvt[-2].field.width + 2) * 15;
X			} else {
X				yyval.field.base = 0;
X				if (yypvt[-4].field.position - yypvt[-4].field.width + 1 == 3)
X					yyval.field.base = yypvt[-4].field.width * 15;
X				else
X					yyval.field.base = yypvt[-4].field.base;
X				if (yypvt[-2].field.position == 6)
X					yyval.field.base += yypvt[-2].field.width * 15;
X				else
X					yyval.field.base += yypvt[-2].field.base;
X				yyval.field.base += yypvt[-0].field.base;
X			}
X			yyval.field.width = yypvt[-4].field.width + yypvt[-3].field.width + yypvt[-2].field.width
X				 + yypvt[-1].field.width + yypvt[-0].field.width;
X			yyval.field.position = yypvt[-0].field.position;
X		} break;
Xcase 39:
X# line 294 "makeedge.y"
X{
X				if (yypvt[-2].field.position - yypvt[-2].field.width + 1 == 3)
X					yyval.field.base = yypvt[-2].field.width * 15 + yypvt[-0].field.base;
X				else if (yypvt[-2].field.position == 6)
X					yyval.field.base = yypvt[-2].field.width * 15 + yypvt[-0].field.base;
X				else
X					yyval.field.base = yypvt[-2].field.base + yypvt[-0].field.base;
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-2].field.width + yypvt[-1].field.width + yypvt[-0].field.width;
X			} break;
Xcase 40:
X# line 305 "makeedge.y"
X{
X			if (yypvt[-1].field.position == 8) {
X				yyval.field.base = (yypvt[-4].field.width + yypvt[-2].field.width + 2) * 15;
X			} else {
X				yyval.field.base = 0;
X				if (yypvt[-4].field.position - yypvt[-4].field.width + 1 == 3)
X					yyval.field.base = -yypvt[-4].field.width * 15;
X				else
X					yyval.field.base = yypvt[-4].field.base;
X				if (yypvt[-2].field.position == 6)
X					yyval.field.base +=  -yypvt[-2].field.width * 15;
X				else
X					yyval.field.base += yypvt[-2].field.base;
X				yyval.field.base += yypvt[-0].field.base;
X			}
X			yyval.field.width = yypvt[-4].field.width + yypvt[-3].field.width + yypvt[-2].field.width
X				 + yypvt[-1].field.width + yypvt[-0].field.width;
X			yyval.field.position = yypvt[-0].field.position;
X		} break;
Xcase 41:
X# line 325 "makeedge.y"
X{
X				if (yypvt[-2].field.position - yypvt[-2].field.width + 1 == 3)
X					yyval.field.base = -yypvt[-2].field.width * 15 + yypvt[-0].field.base;
X				else if (yypvt[-2].field.position == 6)
X					yyval.field.base = -yypvt[-2].field.width * 15 + yypvt[-0].field.base;
X				else
X					yyval.field.base = yypvt[-2].field.base + yypvt[-0].field.base;
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-2].field.width + yypvt[-1].field.width + yypvt[-0].field.width;
X			} break;
Xcase 42:
X# line 336 "makeedge.y"
X{
X				yyval.field.base = 20 * yypvt[-0].field.width;
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-0].field.width;
X			} break;
Xcase 43:
X# line 342 "makeedge.y"
X{
X				yyval.field.base = -20 * yypvt[-0].field.width;
X				yyval.field.position = yypvt[-0].field.position;
X				yyval.field.width = yypvt[-0].field.width;
X			} break;
Xcase 44:
X# line 348 "makeedge.y"
X{ yyval.field = yypvt[-0].field; } break;
Xcase 45:
X# line 350 "makeedge.y"
X{ yyval.field = yypvt[-0].field; } break;
Xcase 46:
X# line 353 "makeedge.y"
X{
X			if (yypvt[-2].field.position == 8)
X				yyval.field.base = - (yypvt[-3].field.width + yypvt[-2].field.width + 1) * 15;
X			else if (yypvt[-1].field.position == 8 && yypvt[-1].field.width == 1)
X				yyval.field.base = (yypvt[-3].field.width + yypvt[-2].field.width + 1) * 10;
X			else
X				yyval.field.base = yypvt[-3].field.base + yypvt[-2].field.base + yypvt[-0].field.base;
X			yyval.field.position = yypvt[-0].field.position;
X			yyval.field.width = yypvt[-3].field.width + yypvt[-2].field.width + yypvt[-1].field.width + yypvt[-0].field.width;
X		} break;
Xcase 47:
X# line 365 "makeedge.y"
X{
X			if (yypvt[-2].field.position == 8)
X				yyval.field.base = (yypvt[-3].field.width + yypvt[-2].field.width + 1) * 15;
X			else if (yypvt[-1].field.position == 8 && yypvt[-1].field.width == 1)
X				yyval.field.base = - (yypvt[-3].field.width + yypvt[-2].field.width + 1) * 10;
X			else
X				yyval.field.base = yypvt[-3].field.base + yypvt[-2].field.base + yypvt[-0].field.base;
X			yyval.field.position = yypvt[-0].field.position;
X			yyval.field.width = yypvt[-3].field.width + yypvt[-2].field.width + yypvt[-1].field.width + yypvt[-0].field.width;
X		} break;
Xcase 48:
X# line 377 "makeedge.y"
X{ yyval.field = yypvt[-0].field; } break;
Xcase 49:
X# line 379 "makeedge.y"
X{ yyval.field.position = position; yyval.field.width = 0; yyval.field.base = 0; } break;
X	}
X	goto yystack;		/* reset registers in driver code */
X}
END_OF_FILE
if test 30399 -ne `wc -c <'makeedge.c'`; then
    echo shar: \"'makeedge.c'\" unpacked with wrong size!
fi
# end of 'makeedge.c'
fi
if test -f 'makeedge.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makeedge.y'\"
else
echo shar: Extracting \"'makeedge.y'\" \(9001 characters\)
sed "s/^X//" >'makeedge.y' <<'END_OF_FILE'
X%{
X/*
X *	ex:set ts=8 sw=8:
X */
Xint	score;
Xextern int	position;
X%}
X%union {
X	struct {
X		int	width;
X		int	position;
X		int	base;
X	} field;
X	int	ival;
X}
X%type  <field>	line whites blacks empties oempties
X%type  <field>	type1 type2 otype3e type3e type3 otype4 type4 type4.w type4.b
X%token <field>	WHITE BLACK EMPTY
X%token <ival>	NL
X%%
Xlines	:	lines line
X			{ printf ("\t%5d,\t/*%s */\n", $2.base, line); }
X	|
X	;
Xline	:	whites type1 NL
X			{ $$.base = 20 * $1.width + $2.base; }
X	|	blacks type2 NL
X			{ $$.base = -20 * $1.width + $2.base; }
X	|	EMPTY type3 NL
X			{ $$.base = $2.base; }
X	|	EMPTY empties otype4 NL
X			{ $$.base = $3.base; }
X	;
Xtype1	:	blacks whites empties otype4
X			{
X				$$.base = $4.base;
X				switch ($2.position) {
X				case 7:
X					$$.base -= ($2.width + $1.width+1) * 15;
X					break;
X				default:
X					if ($3.width == 1)
X						$$.base -=
X						($1.width + $2.width+1) * 15;
X					else
X						$$.base +=
X						($2.width - $1.width) * 20;
X					break;
X				}
X				$$.position = $4.position;
X				$$.width = $1.width + $2.width + $3.width;
X			}
X	|	blacks whites type1
X			{
X				$$.base = $3.base;
X				$$.base -= ($1.width - $2.width) * 20;
X				$$.position = $3.position;
X				$$.width = $1.width + $2.width + $3.width;
X			}
X	|	blacks empties otype4
X			{
X				$$.base = ($1.width + 1) * 15 + $3.base;
X				$$.width = $1.width + $2.width + $3.width;
X				$$.position = $3.position;
X			}
X	|	blacks
X			{
X				$$ = $1;
X				$$.base = - $1.width * 20;
X			}
X	|	empties otype4
X			{
X				$$.position = $2.position;
X				$$.width = $1.width+$2.width;
X				$$.base = $2.base;
X			}
X	|
X			{ $$.position = position; $$.width = 0; $$.base = 0; }
X	;
Xtype2	:	whites blacks empties otype4
X			{
X				$$.base = $4.base;
X				switch ($2.position) {
X				case 7:
X					$$.base += ($2.width + $1.width+1) * 15;
X					break;
X				default:
X					if ($3.width == 1)
X						$$.base +=
X						($1.width + $2.width+1) * 15;
X					else
X						$$.base -=
X						($2.width - $1.width) * 20;
X					break;
X				}
X				$$.position = $4.position;
X				$$.width = $1.width + $2.width + $3.width
X					 + $4.width;
X			}
X	|	whites blacks type2
X			{
X				$$.base = $3.base;
X				$$.base += ($1.width - $2.width) * 20;
X				$$.position = $3.position;
X				$$.width = $1.width + $2.width + $3.width;
X			}
X	|	whites empties otype4
X			{
X				$$.base = - ($1.width + 1) * 15 + $3.base;
X				$$.width = $1.width + $2.width + $3.width;
X				$$.position = $3.position;
X			}
X	|	whites
X			{
X				$$ = $1;
X				$$.base = $1.width * 20;
X			}
X	|	empties otype4
X			{
X				$$.position = $2.position;
X				$$.width = $1.width+$2.width;
X				$$.base = $2.base;
X			}
X	|
X		{ $$.position = 0; $$.width = 0; $$.base = 0; }
X	;
Xotype4	:	type4
X			{ $$ = $1; }
X	|
X			{ $$.position = position; $$.width = 0; $$.base = 0; }
X	;
Xwhites	:	whites WHITE
X			{
X				$$.position = $2.position;
X				$$.width = $1.width + $2.width;
X				$$.base = $1.base + $2.base;
X			}
X	|	WHITE
X			{ $$ = $1; }
X	;
Xblacks	:	blacks BLACK
X			{
X				$$.position = $2.position;
X				$$.width = $1.width + $2.width;
X				$$.base = $1.base + $2.base;
X			}
X	|	BLACK
X			{ $$ = $1; }
X	;
Xempties	:	empties EMPTY
X			{
X				$$.position = $2.position;
X				$$.width = $1.width + $2.width;
X				$$.base = $1.base + $2.base;
X			}
X	|	EMPTY
X			{ $$ = $1; }
X	;
Xotype3e	:	type3e
X			{ $$ = $1; }
X	|
X			{ $$.position = position; $$.width = 0; $$.base = 0; }
X	;
Xtype3	:	whites EMPTY whites oempties otype3e
X			{
X				$$.base = -($1.width + $3.width + 2) * 15 +
X					$5.base;
X				$$.width = $1.width + $2.width + $3.width 
X					 + $4.width + $5.width;
X				$$.position = $5.position;
X			}
X	|	blacks EMPTY blacks oempties otype3e
X			{
X				$$.base = ($1.width + $3.width + 2) * 15 +
X					$5.base;
X				$$.width = $1.width + $2.width + $3.width 
X					 + $4.width + $5.width;
X				$$.position = $5.position;
X			}
X	|	type3e
X	;
Xtype3e	:	whites blacks type2
X			{
X				$$.base = -15 * ($1.width + $2.width + 1);
X				$$.width = $1.width + $2.width + $3.width;
X				$$.position = $3.position;
X			}
X	|	blacks whites type1
X			{
X				$$.base = 15 * ($1.width + $2.width + 1);
X				$$.width = $1.width + $2.width + $3.width;
X				$$.position = $3.position;
X			}
X	|	whites empties otype3e
X			{
X				if ($1.position - $1.width == 1) {
X					switch ($1.width) {
X					case 1:
X						$$.base = -30;
X						break;
X					case 6:
X						$$.base = -20;
X						break;
X					case 2:
X						$$.base = -15;
X						break;
X					case 3:
X						$$.base = -10;
X						break;
X					case 4:
X						$$.base = -5;
X						break;
X					case 5:
X						$$.base = 10;
X						break;
X					default:
X						yyerror ("weirdo");
X						break;
X					}
X				} else {
X					$$.base = $1.base;
X				}
X				$$.base += $3.base;
X				$$.position = $3.position;
X				$$.width = $1.width + $2.width + $3.width;
X			}
X	|	blacks empties otype3e
X			{
X				if ($1.position - $1.width == 1) {
X					switch ($1.width) {
X					case 1:
X						$$.base = 30;
X						break;
X					case 6:
X						$$.base = 20;
X					break;
X					case 2:
X						$$.base = 15;
X						break;
X					case 3:
X						$$.base = 10;
X						break;
X					case 4:
X						$$.base = 5;
X						break;
X					case 5:
X						$$.base = -10;
X						break;
X					default:
X						yyerror ("weirdo");
X						break;
X					}
X				} else {
X					$$.base = $1.base;
X				}
X				$$.base += $3.base;
X				$$.position = $3.position;
X				$$.width = $1.width + $2.width + $3.width;
X			}
X	|	whites
X			{
X				$$.base = 20 * $1.width;
X				$$.position = $1.position;
X				$$.width = $1.width;
X			}
X	|	blacks
X			{
X				$$.base = -20 * $1.width;
X				$$.position = $1.position;
X				$$.width = $1.width;
X			}
X	;
Xtype4	:	whites EMPTY whites oempties otype4
X		{
X			if ($4.position == 8) {
X				$$.base = -($1.width + $3.width + 2) * 15;
X			} else {
X				$$.base = 0;
X				if ($1.position - $1.width + 1 == 3)
X					$$.base = $1.width * 15;
X				else
X					$$.base = $1.base;
X				if ($3.position == 6)
X					$$.base += $3.width * 15;
X				else
X					$$.base += $3.base;
X				$$.base += $5.base;
X			}
X			$$.width = $1.width + $2.width + $3.width
X				 + $4.width + $5.width;
X			$$.position = $5.position;
X		}
X	|	whites empties otype4
X			{
X				if ($1.position - $1.width + 1 == 3)
X					$$.base = $1.width * 15 + $3.base;
X				else if ($1.position == 6)
X					$$.base = $1.width * 15 + $3.base;
X				else
X					$$.base = $1.base + $3.base;
X				$$.position = $3.position;
X				$$.width = $1.width + $2.width + $3.width;
X			}
X	|	blacks EMPTY blacks oempties otype4
X		{
X			if ($4.position == 8) {
X				$$.base = ($1.width + $3.width + 2) * 15;
X			} else {
X				$$.base = 0;
X				if ($1.position - $1.width + 1 == 3)
X					$$.base = -$1.width * 15;
X				else
X					$$.base = $1.base;
X				if ($3.position == 6)
X					$$.base +=  -$3.width * 15;
X				else
X					$$.base += $3.base;
X				$$.base += $5.base;
X			}
X			$$.width = $1.width + $2.width + $3.width
X				 + $4.width + $5.width;
X			$$.position = $5.position;
X		}
X	|	blacks empties otype4
X			{
X				if ($1.position - $1.width + 1 == 3)
X					$$.base = -$1.width * 15 + $3.base;
X				else if ($1.position == 6)
X					$$.base = -$1.width * 15 + $3.base;
X				else
X					$$.base = $1.base + $3.base;
X				$$.position = $3.position;
X				$$.width = $1.width + $2.width + $3.width;
X			}
X	|	whites
X			{
X				$$.base = 20 * $1.width;
X				$$.position = $1.position;
X				$$.width = $1.width;
X			}
X	|	blacks
X			{
X				$$.base = -20 * $1.width;
X				$$.position = $1.position;
X				$$.width = $1.width;
X			}
X	|	type4.w
X			{ $$ = $1; }
X	|	type4.b
X			{ $$ = $1; }
X	;
Xtype4.w	:	whites blacks oempties otype4
X		{
X			if ($2.position == 8)
X				$$.base = - ($1.width + $2.width + 1) * 15;
X			else if ($3.position == 8 && $3.width == 1)
X				$$.base = ($1.width + $2.width + 1) * 10;
X			else
X				$$.base = $1.base + $2.base + $4.base;
X			$$.position = $4.position;
X			$$.width = $1.width + $2.width + $3.width + $4.width;
X		}
X	;
Xtype4.b	:	blacks whites oempties otype4
X		{
X			if ($2.position == 8)
X				$$.base = ($1.width + $2.width + 1) * 15;
X			else if ($3.position == 8 && $3.width == 1)
X				$$.base = - ($1.width + $2.width + 1) * 10;
X			else
X				$$.base = $1.base + $2.base + $4.base;
X			$$.position = $4.position;
X			$$.width = $1.width + $2.width + $3.width + $4.width;
X		}
X	;
Xoempties:	empties
X			{ $$ = $1; }
X	|
X			{ $$.position = position; $$.width = 0; $$.base = 0; }
X	;
X%%
X
X# include	<stdio.h>
X
Xmain ()
X{
X	return yyparse ();
X}
X
Xchar	line[80];
Xchar	*lp = line;
X
Xyyerror (s)
Xchar *s;
X{
X	fprintf (stderr, "%s in %s\n", s, line);
X}
X
Xyywrap ()
X{
X	return 1;
X}
X
Xint position = 1;
X
Xint base[] = { 0, 20, -30, 15, -5, -5, 15, -30, 20, 0 };
X
Xyylex ()
X{
X	char *gets();
X
X	if (*lp == '\0')
X		if (fgets (line, 80, stdin) == 0)
X			return -1;
X		else
X			lp = line;
X	for (;;) {
X		switch (*lp++) {
X		case ' ':
X		case '\t':
X			break;
X		case '\n':
X			lp[-1] = '\0';
X			position = 1;
X			return NL;
X		case 'O':
X			yylval.field.base = -
X				base[yylval.field.position = position++];
X			yylval.field.width = 1;
X			return BLACK;
X		case '*':
X			yylval.field.base =
X				base[yylval.field.position = position++];
X			yylval.field.width = 1;
X			return WHITE;
X		case '-':
X			yylval.field.base = 0;
X			yylval.field.position = position++;
X			yylval.field.width = 1;
X			return EMPTY;
X		}
X	}
X}
END_OF_FILE
if test 9001 -ne `wc -c <'makeedge.y'`; then
    echo shar: \"'makeedge.y'\" unpacked with wrong size!
fi
# end of 'makeedge.y'
fi
if test -f 'ulex.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ulex.l'\"
else
echo shar: Extracting \"'ulex.l'\" \(1162 characters\)
sed "s/^X//" >'ulex.l' <<'END_OF_FILE'
X%{
X/*
X *	ex:set ts=8 sw=8:
X */
X# include	"y.tab.h"
Xextern int	yylval;
Xextern char	sbuf[];
X#undef input
X#define input()	lexgetc()
X#undef unput
X#define unput(c)	lexungetc(c)
X%}
X%%
X[ \t]		;
X\004		return EOG;
Xblack		{ yylval = -1; return BL; }
Xboth		return BOTH;
Xcomputer	return COMPUTER;
Xdebug		return DEBUG;
Xeval		return EVAL;
Xfile		return FILEe;
Xfirst		return FIRST;
Xfrom		return FROM;
Xgame		return GAME;
Xgrid		return GRID;
Xhelp		return HELP;
Xhint		return HINT;
Xhuman		return HUMAN;
Xinto		return INTO;
Xlevel		return LEVEL;
Xme		return HUMAN;
Xmove		return MOVE;
Xnew		return NEW;
Xneither		return NEITHER;
Xno		return NO;
Xnogrid		return NOGRID;
Xnohelp		return NOHELP;
Xnoscore		return NOSCORE;
Xnone		return NONE;
Xplay		return PLAY;
Xquit		return QUIT;
Xrecord		return RECORD;
Xreplay		return REPLAY;
Xrestart		return RESTART;
Xsave		return SAVE;
Xscore		return SCORE;
Xsecond		return SECOND;
Xto		return TO;
Xundo		return UNDO;
Xwhite		{ yylval =  1; return WH; }
Xyou		return COMPUTER;
X\n		return NL;
X[0-9]+		{ yylval = atoi (yytext); return NUMBER; }
X","		return COMMA;
X";"		return SEMI;
X\"[^"]*\"	{ strcpy (sbuf, yytext+1); sbuf[yyleng-2]='\0'; return STRING; }
X.		return ERR;
END_OF_FILE
if test 1162 -ne `wc -c <'ulex.l'`; then
    echo shar: \"'ulex.l'\" unpacked with wrong size!
fi
# end of 'ulex.l'
fi
if test -f 'user.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user.y'\"
else
echo shar: Extracting \"'user.y'\" \(7739 characters\)
sed "s/^X//" >'user.y' <<'END_OF_FILE'
X%{
X/*
X *	ex:set ts=8 sw=8:
X *	user interface
X */
X
X# include	"reversi.h"
X# include	<stdio.h>
X# include	<signal.h>
X
XboardT	board, saveBoard;
Xint	saved;
Xint	savePlayer;
Xint	atend;
Xint	atbegin;
Xint	level;
Xint	player;
Xextern int	maxlev, movex, movey;
Xint	com;
Xint	gotsignal;
Xchar	sbuf[80];
Xchar	ebuf[80];
Xint	sdebug = 0, mdebug = 0;
Xint	record = 0;
XFILE	*rfile;
Xint	first = WHITE;
Xint	defcom = BLACK;
Xint	showScore = 1;
X
Xstruct move {
X	int	p, x, y;
X};
X
Xstruct move	saveGame[64];
Xstruct move	*saveP;
X
X%}
X%token	MOVE LEVEL COMPUTER UNDO HINT PLAY
X%token	RECORD REPLAY SAVE
X%token	RESTART NEW GAME QUIT
X%token	GRID NOGRID HELP NOHELP SCORE NOSCORE
X%token	DEBUG EVAL
X%token	FROM INTO TO FILEe NO
X%token	NUMBER COMMA NL STRING SEMI EOG ERR
X%token	WH BL HUMAN BOTH NEITHER NONE FIRST SECOND
X%%
Xgame	:	game commands NL prompt
X	|	prompt
X	;
Xprompt	:
X	{
X		if (!atend) {
X			loop:	;
X			dispTurn (player);
X			if (!hasmove (player, board)) {
X				if (!hasmove (-player, board)) {
X					fini (board);
X					if (com == 0)
X						com = BLACK;
X					++atend;
X					dispTurn (EMPTY);
X					goto nomove;
X				} else {
X					if (player == WHITE)
X						dispError ("white has no move");
X					else
X						dispError ("black has no move");
X					player = -player;
X				}
X			}
X			if (com == 0 || com == player) {
X				dispError ("thinking...");
X				if (computer (player, board, level)) {
X					atbegin = 0;
X					sprintf (ebuf, "I move to %d, %d\n",
X						movex, movey);
X					dispError (ebuf);
X					saveP->x = movex;
X					saveP->y = movey;
X					saveP->p = player;
X					++saveP;
X					if (record)
X						fprintf (rfile, "%d: %d,%d\n",
X						    player, movex, movey);
X					player = -player;
X					display (board);
X					if (gotsignal && com != 0)
X						gotsignal = 0;
X				}
X				if (gotsignal && com == 0) {
X					com = -player;
X					gotsignal = 0;
X				}
X				goto loop;
X			}
X		}
X	nomove:	;
X		readLine ();
X	}
X	;
Xcommands:	commands SEMI command
X	|	command
X	|	error oerror
X		{
X			dispHelp ();
X		}
X	;
Xcommand	:	
X	|	EOG
X		{
X			YYACCEPT;
X		}
X	|	omove NUMBER ocomma NUMBER
X		{
X			if (1 <= $2 && $2 <= SIZE &&
X			    1 <= $4 && $4 <= SIZE &&
X			    legal (player, $2, $4, board)) {
X				copy (saveBoard, board);
X				savePlayer = player;
X				++saved;
X				move (player, $2, $4, board);
X				atbegin = 0;
X				if (record)
X					fprintf (rfile, "%d: %d,%d\n",
X					    player, $2, $4);
X				saveP->x = $2;
X				saveP->y = $4;
X				saveP->p = player;
X				++saveP;
X				player = -player;
X				display (board);
X			} else {
X				sprintf (ebuf, "illegal move: %d, %d", $2, $4);
X				dispError (ebuf);
X			}
X		}
X	|	DEBUG STRING
X		{
X			register char	*s;
X			register int	v;
X
X			v = 1;
X			for (s = sbuf; *s; ++s)
X				switch (*s) {
X				case 'm':
X					mdebug = v;
X					break;
X				case 's':
X					sdebug = v;
X					break;
X				case '!':
X					v = !v;
X					break;
X				}
X		}
X	|	GRID
X		{
X			dispGrid ();
X		}
X	|	NO GRID
X		{
X			dispNoGrid ();
X		}
X	|	NOGRID
X		{
X			dispNoGrid ();
X		}
X	|	SCORE
X		{
X			showScore = 1;
X			dispScore (board);
X		}
X	|	NOSCORE
X		{
X			showScore = 0;
X			dispNoScore ();
X		}
X	|	NO SCORE
X		{
X			showScore = 0;
X			dispNoScore ();
X		}
X	|	LEVEL NUMBER
X		{
X			level = $2;
X		}
X	|	LEVEL oerror
X		{
X			sprintf (ebuf, "current level is %d", level);
X			dispError (ebuf);
X		}
X	|	PLAY whichp
X		{
X			if ($2 == WHITE || $2 == BLACK) 
X				defcom = $2;
X			com = $2;
X		}
X	|	PLAY oerror
X		{
X			dispError ("play (white black both none)");
X		}
X	|	whichp FIRST
X		{
X			if ($1 == WHITE || $1 == BLACK)
X				first = $1;
X			if (atbegin)
X				player = first;
X		}
X	|	FIRST oerror
X		{
X			dispError ("(white black you me) first");
X		}
X	|	whichp SECOND
X		{
X			if ($1 == WHITE || $1 == BLACK)
X				first = - $1;
X			if (atbegin)
X				player = first;
X		}
X	|	SECOND oerror
X		{
X			dispError ("(white black you me) second");
X		}
X	|	HELP
X		{
X			dispHelp ();
X		}
X	|	NOHELP
X		{
X			dispNoHelp ();
X		}
X	|	NO HELP
X		{
X			dispNoHelp ();
X		}
X	|	QUIT
X		{
X			YYACCEPT;
X		}
X	|	UNDO
X		{
X			if (saved) {
X				copy (board, saveBoard);
X				player = savePlayer;
X				saved = 0;
X				display (board);
X			}
X		}
X	|	NEW ogame eoc
X		{
X			YYABORT;
X		}
X	|	RESTART eoc
X		{
X			YYABORT;
X		}
X	|	EVAL
X		{
X			sprintf (ebuf, "score: %d\n", score (board, WHITE));
X			dispError (ebuf);
X		}
X	|	RECORD ointo ofile STRING
X		{
X			if ((rfile = fopen (sbuf, "w")) == NULL) {
X				sprintf (ebuf, "could not open %s", sbuf);
X				dispError (ebuf);
X				record = 0;
X			} else
X				++record;
X		}
X	|	RECORD oerror
X		{
X			dispError ("record \"file\"");
X		}
X	|	REPLAY whichp ofrom ofile STRING
X		{
X			replay ($2, sbuf);
X		}
X	|	REPLAY oerror
X		{
X			dispError ("replay (both white black) \"file\"");
X		}
X	|	SAVE ointo ofile STRING
X		{
X			struct move	*m;
X
X			if ((rfile = fopen (sbuf, "w")) == NULL) {
X				sprintf (ebuf, "could not open %s", sbuf);
X				dispError (ebuf);
X			} else {
X				m = saveGame;
X				fprintf (rfile, "%d: -1,-1\n", m->p);
X				for (; m != saveP; m++)
X					fprintf (rfile, "%d: %d,%d\n",
X					    m->p, m->x, m->y);
X				fclose (rfile);
X				rfile = 0;
X			}
X		}
X	|	SAVE oerror
X		{
X			dispError ("save \"file\"");
X		}
X	|	HINT
X		{
X			if (hasmove (player, board)) {
X				char	buf[80];
X				hint (player, board, level);
X				sprintf (buf, "I suggest %d, %d", movex, movey);
X				dispError (buf);
X			}
X		}
X	;
Xeoc	:	SEMI
X	|	NL
X	;
Xomove	:	MOVE
X	|
X	;
Xogame	:	GAME
X	|
X	;
Xocomma	:	COMMA
X	|
X	;
Xoerror	:	oerror error
X		{
X			yyerrok;
X		}
X	|	oerror ERR
X	|
X	;
Xointo	:	TO
X	|	INTO
X	|
X	;
Xofrom	:	FROM
X	|
X	;
Xofile	:	FILEe
X	|
X	;
Xwhichp	:	WH
X		{ $$ = WHITE; }
X	|	BL
X		{ $$ = BLACK; }
X	|	COMPUTER
X		{ $$ = com==WHITE?WHITE:BLACK; }
X	|	HUMAN
X		{ $$ = com==WHITE?BLACK:WHITE; }
X	|	BOTH
X		{ $$ = 0; }
X	|	none
X		{ $$ = 2; }
X	;
Xnone	:	NONE
X	|	NEITHER
X	;
X%%
Xyyerror (s)
Xchar	*s;
X{
X	dispError (s);
X}
X
Xcaught ()
X{
X	gotsignal++;
X	signal (SIGINT, caught);
X}
X
Xmain (argc, argv)
Xchar **argv;
X{
X	signal (SIGINT, caught);
X	level = 2;
X	dispInit ();
X	srand (getpid());
X	while (*++argv && **argv == '-') {
X		while (*++*argv) {
X			switch (**argv) {
X			case 'b':
X				defcom = BLACK;
X				break;
X			case 'w':
X				defcom = WHITE;
X				break;
X			case '1':
X				if (!*++*argv)
X					continue;
X				if (**argv == WHITE)
X					first = WHITE;
X				else
X					first = BLACK;
X				break;
X			case 'g':
X				dispGrid ();
X				break;
X			case 's':
X				showScore = 1;
X			}
X		}
X	}
X	do {
X		if (rfile)
X			fclose (rfile);
X		rfile = 0;
X		player = first;
X		com = defcom;
X		atend = 0;
X		atbegin = 1;
X		setup ();
X		saved = 0;
X		saveP = saveGame;
X		display (board);
X		if (*argv) {
X			replay (0, *argv);
X			++argv;
X		}
X	} while (yyparse ());
X	dispEnd ();
X}
X
Xyywrap ()
X{
X	return 1;
X}
X
Xsetup ()
X{
X	register int	i,j;
X
X	for (i = 1; i <= SIZE; i++)
X		for (j = 1; j <= SIZE; j++)
X			board[i][j] = 0;
X	board[4][4] = WHITE;
X	board[4][5] = BLACK;
X	board[5][4] = BLACK;
X	board[5][5] = WHITE;
X}
X
Xreplay (who, file)
Xchar *file;
X{
X	int	x, y, p;
X	if (rfile)
X		fclose (rfile);
X	if ((rfile = fopen (file, "r")) == NULL) {
X		sprintf (ebuf, "could not open %s", file);
X		dispError (ebuf);
X		return;
X	}
X	while (fscanf (rfile, "%d: %d, %d\n", &p, &x, &y) == 3) {
X		if (x == -1 && y == -1) {
X			player = p;
X			continue;
X		}
X		if (!hasmove (player, board)) {
X			player = -player;
X			if (!hasmove (player, board))
X				return;
X		}
X		if (p != player) {
X			sprintf (ebuf, "not %s's turn\n",
X			    player == WHITE? "white":"black");
X			dispError (ebuf);
X			return;
X		}
X		if (who == 0 || p == who) {
X			if (!legal (p, x, y, board)) {
X				sprintf(ebuf, "illegal move: %d, %d\n", x, y);
X				dispError (ebuf);
X				return;
X			}
X			move (p, x, y, board);
X			atbegin = 0;
X			player = -player;
X			display (board);
X		}
X		else if (player == com) {
X			if (hasmove (player, board)) {
X				dispError ("thinking...");
X				dispTurn (EMPTY);
X				if (computer (player, board, level)) {
X					dispError ("");
X					atbegin = 0;
X					player = -player;
X					display (board);
X				}
X			}
X		}
X	}
X	fclose (rfile);
X	rfile = 0;
X}
END_OF_FILE
if test 7739 -ne `wc -c <'user.y'`; then
    echo shar: \"'user.y'\" unpacked with wrong size!
fi
# end of 'user.y'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
