Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v15i034:  robot_hunt - original hunt with a robot, Part03/04
Message-ID: <4190@master.CNA.TEK.COM>
Date: 14 Jan 93 03:14:08 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2465
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1533

Submitted-by: whatis@ucsd.edu (Steve Boswell)
Posting-number: Volume 15, Issue 34
Archive-name: robot_hunt/Part03
Environment: Curses, Sockets


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 4)."
# Contents:  answer.c draw.c execute.c hunt.6 hunt.h playit.c
# Wrapped by billr@saab on Wed Jan 13 19:04:32 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'answer.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'answer.c'\"
else
echo shar: Extracting \"'answer.c'\" \(8280 characters\)
sed "s/^X//" >'answer.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1985 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
Xstatic char sccsid[] = "@(#)answer.c	5.2 (Berkeley) 6/27/88";
X#endif /* not lint */
X
X/*
X *  Hunt
X *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold
X *  San Francisco, California
X */
X
X# include	"hunt.h"
X# include	<errno.h>
X
X# define	MAXPERMACH	3	/* Max player/monitor per machine */
X
Xstatic char	Ttyname[NAMELEN];
X
Xanswer()
X{
X	register PLAYER		*pp;
X	register int		newsock;
X	register FILE		*tmpfd;
X# ifdef MONITOR
X	static FLAG		monitor;
X# endif MONITOR
X	static char		name[NAMELEN];
X	static int		socklen;
X	static u_long		machine;
X	static u_long		uid;
X	static SOCKET		sockstruct;
X# ifdef OLDIPC
X	extern SOCKET		Daemon;
X# endif OLDIPC
X
X# ifdef INTERNET
X	socklen = sizeof sockstruct;
X# else
X	socklen = sizeof sockstruct - 1;
X# endif INTERNET
X	errno = 0;
X# ifndef OLDIPC
X	if ((newsock = accept(Socket, &sockstruct, &socklen)) < 0)
X# else OLDIPC
X	if (accept(Socket, &sockstruct) < 0)
X# endif OLDIPC
X	{
X		if (errno == EINTR)
X			return;
X		perror("accept");
X		cleanup(1);
X	}
X# ifdef OLDIPC
X	newsock = Socket;
X	Socket = socket(SOCK_STREAM, 0, (struct sockaddr *) &Daemon,
X		SO_ACCEPTCONN);
X	if (Socket < 0) {
X		perror("new accept socket");
X		cleanup(1);
X	}
X	Sock_mask = (1 << Socket);
X	Fds_mask |= Sock_mask;
X	if (Socket >= Num_fds)
X		Num_fds = Socket + 1;
X# endif OLDIPC
X
X	tmpfd = fdopen(newsock, "w");
X
X# ifdef INTERNET
X	machine = ntohl(((struct sockaddr_in *) &sockstruct)->sin_addr.s_addr);
X# else INTERNET
X	if (machine == 0)
X		machine = gethostid();
X# endif INTERNET
X	(void) putw(getpid(), tmpfd);
X	(void) read(newsock, (char *) &uid, sizeof uid);
X	uid = ntohl(uid);
X	(void) read(newsock, name, NAMELEN);
X	(void) read(newsock, Ttyname, NAMELEN);
X# ifdef MONITOR
X	(void) read(newsock, (char *) &monitor, sizeof monitor);
X# endif MONITOR
X
X	if (reached_limit(machine)) {
X		socklen = 0;
X		(void) write(newsock, (char *) &socklen, sizeof socklen);
X		(void) close(newsock);
X# ifdef OLDIPC
X		Fds_mask &= ~(1 << newsock);
X# endif OLDIPC
X		return;
X	}
X
X# ifdef MONITOR
X	if (monitor)
X		if (End_monitor < &Monitor[MAXMON])
X			pp = End_monitor++;
X		else {
X			socklen = 0;
X			(void) write(newsock, (char *) &socklen,
X				sizeof socklen);
X			(void) close(newsock);
X			return;
X		}
X	else
X# endif MONITOR
X		if (End_player < &Player[MAXPL])
X			pp = End_player++;
X		else {
X			socklen = 0;
X			(void) write(newsock, (char *) &socklen,
X				sizeof socklen);
X			(void) close(newsock);
X			return;
X		}
X
X	pp->p_ident = get_ident(machine, uid, name);
X	pp->p_output = tmpfd;
X	pp->p_death[0] = '\0';
X	pp->p_fd = newsock;
X	pp->p_mask = (1 << pp->p_fd);
X# ifndef OLDIPC
X	Fds_mask |= pp->p_mask;
X	if (pp->p_fd >= Num_fds)
X		Num_fds = pp->p_fd + 1;
X# endif OLDIPC
X
X	pp->p_y = 0;
X	pp->p_x = 0;
X
X# ifdef MONITOR
X	if (monitor)
X		stmonitor(pp);
X	else
X# endif MONITOR
X		stplayer(pp);
X}
X
X# ifdef MONITOR
Xstmonitor(pp)
Xregister PLAYER	*pp;
X{
X	register int	line;
X	register PLAYER	*npp;
X
X	bcopy((char *) Maze, (char *) pp->p_maze, sizeof Maze);
X
X	drawmaze(pp);
X
X	(void) sprintf(Buf, "%5.5s%c%-10.10s", " ", stat_char(pp),
X		pp->p_ident->i_name);
X	line = STAT_MON_ROW + 1 + (pp - Monitor);
X	for (npp = Player; npp < End_player; npp++) {
X		cgoto(npp, line, STAT_NAME_COL);
X		outstr(npp, Buf, STAT_NAME_LEN);
X	}
X	for (npp = Monitor; npp < End_monitor; npp++) {
X		cgoto(npp, line, STAT_NAME_COL);
X		outstr(npp, Buf, STAT_NAME_LEN);
X	}
X
X	sendcom(pp, REFRESH);
X	sendcom(pp, READY, 0);
X	(void) fflush(pp->p_output);
X}
X# endif MONITOR
X
Xstplayer(newpp)
Xregister PLAYER	*newpp;
X{
X	register int	x, y;
X	register PLAYER	*pp;
X
X	Nplayer++;
X
X	for (y = 0; y < UBOUND; y++)
X		for (x = 0; x < WIDTH; x++)
X			newpp->p_maze[y][x] = Maze[y][x];
X	for (     ; y < DBOUND; y++) {
X		for (x = 0; x < LBOUND; x++)
X			newpp->p_maze[y][x] = Maze[y][x];
X		for (     ; x < RBOUND; x++)
X			newpp->p_maze[y][x] = SPACE;
X		for (     ; x < WIDTH;  x++)
X			newpp->p_maze[y][x] = Maze[y][x];
X	}
X	for (     ; y < HEIGHT; y++)
X		for (x = 0; x < WIDTH; x++)
X			newpp->p_maze[y][x] = Maze[y][x];
X
X	do {
X		x = rand_num(WIDTH - 1) + 1;
X		y = rand_num(HEIGHT - 1) + 1;
X	} while (Maze[y][x] != SPACE);
X	newpp->p_over = SPACE;
X	newpp->p_x = x;
X	newpp->p_y = y;
X	newpp->p_undershot = FALSE;
X
X# ifdef	START_FLYING
X	/* This is only for debugging */
X	newpp->p_flying = rand_num(20);
X	newpp->p_flyx = 2 * rand_num(6) - 5;
X	newpp->p_flyy = 2 * rand_num(6) - 5;
X	newpp->p_face = FLYER;
X# else START_FLYING
X	newpp->p_flying = -1;
X	rand_face(newpp);
X# endif START_FLYING
X	newpp->p_damage = 0;
X	newpp->p_damcap = MAXDAM;
X	newpp->p_nchar = 0;
X	newpp->p_ncount = 0;
X	newpp->p_nexec = 0;
X	newpp->p_ammo = ISHOTS;
X	newpp->p_scan = -1;
X	newpp->p_cloak = CLOAKLEN;
X	newpp->p_ncshot = 0;
X
X	do {
X		x = rand_num(WIDTH - 1) + 1;
X		y = rand_num(HEIGHT - 1) + 1;
X	} while (Maze[y][x] != SPACE);
X	Maze[y][x] = GMINE;
X# ifdef MONITOR
X	for (pp = Monitor; pp < End_monitor; pp++)
X		check(pp, y, x);
X# endif MONITOR
X
X	do {
X		x = rand_num(WIDTH - 1) + 1;
X		y = rand_num(HEIGHT - 1) + 1;
X	} while (Maze[y][x] != SPACE);
X	Maze[y][x] = MINE;
X# ifdef MONITOR
X	for (pp = Monitor; pp < End_monitor; pp++)
X		check(pp, y, x);
X# endif MONITOR
X
X	(void) sprintf(Buf, "%5.2f%c%-10.10s", newpp->p_ident->i_score,
X		stat_char(newpp), newpp->p_ident->i_name);
X	y = STAT_PLAY_ROW + 1 + (newpp - Player);
X	for (pp = Player; pp < End_player; pp++) {
X		if (pp != newpp) {
X			char	smallbuf[10];
X
X			pp->p_ammo += NSHOTS;
X			newpp->p_ammo += NSHOTS;
X			cgoto(pp, y, STAT_NAME_COL);
X			outstr(pp, Buf, STAT_NAME_LEN);
X			(void) sprintf(smallbuf, "%3d", pp->p_ammo);
X			cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
X			outstr(pp, smallbuf, 3);
X		}
X	}
X# ifdef MONITOR
X	for (pp = Monitor; pp < End_monitor; pp++) {
X		cgoto(pp, y, STAT_NAME_COL);
X		outstr(pp, Buf, STAT_NAME_LEN);
X	}
X# endif MONITOR
X
X	drawmaze(newpp);
X	drawplayer(newpp, TRUE);
X	look(newpp);
X# ifdef START_FLYING
X	/* Make sure that the position you enter in will be erased */
X	showexpl(newpp->p_y, newpp->p_x, FLYER);
X# endif START_FLYING
X	sendcom(newpp, REFRESH);
X	sendcom(newpp, READY, 0);
X	(void) fflush(newpp->p_output);
X}
X
X/*
X * rand_face:
X *	Give the player a random facing direction
X */
Xrand_face(pp)
Xregister PLAYER	*pp;
X{
X	switch (rand_num(4)) {
X	  case 0:
X		pp->p_face = LEFTS;
X		break;
X	  case 1:
X		pp->p_face = RIGHT;
X		break;
X	  case 2:
X		pp->p_face = BELOW;
X		break;
X	  case 3:
X		pp->p_face = ABOVE;
X		break;
X	}
X}
X
X/*
X * get_ident:
X *	Get the score structure of a player
X */
XIDENT *
Xget_ident(machine, uid, name)
Xu_long	machine;
Xu_long	uid;
Xchar	*name;
X{
X	register IDENT	*ip;
X	static IDENT	punt;
X
X	for (ip = Scores; ip != NULL; ip = ip->i_next)
X		if (ip->i_machine == machine && ip->i_uid == uid &&
X		    strncmp(ip->i_name, name, NAMELEN) == 0)
X			break;
X
X	if (ip != NULL) {
X		ip->i_entries++;
X		ip->i_score = ip->i_kills / (double) ip->i_entries;
X	}
X	else {
X		ip = (IDENT *) malloc(sizeof (IDENT));
X		if (ip == NULL) {
X			/* Fourth down, time to punt */
X			ip = &punt;
X		}
X		ip->i_machine = machine;
X		ip->i_uid = uid;
X		strncpy(ip->i_name, name, NAMELEN);
X		ip->i_kills = 0;
X		ip->i_entries = 1;
X		ip->i_score = 0;
X		ip->i_next = Scores;
X		Scores = ip;
X	}
X
X	return ip;
X}
X
X/*
X * reached_limit:
X *	Returns whether the limit of x persons per machine has been reached
X */
Xreached_limit(machine)
Xu_long	machine;
X{
X	register PLAYER	*pp;
X	register int	count;
X
X	count = 0;
X	for (pp = Player; pp < End_player; pp++)
X		if (pp->p_ident->i_machine == machine)
X			count++;
X	for (pp = Monitor; pp < End_monitor; pp++)
X		if (pp->p_ident->i_machine == machine)
X			count++;
X	return count >= MAXPERMACH;
X}
END_OF_FILE
if test 8280 -ne `wc -c <'answer.c'`; then
    echo shar: \"'answer.c'\" unpacked with wrong size!
fi
# end of 'answer.c'
fi
if test -f 'draw.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'draw.c'\"
else
echo shar: Extracting \"'draw.c'\" \(8245 characters\)
sed "s/^X//" >'draw.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1985 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
Xstatic char sccsid[] = "@(#)draw.c	5.2 (Berkeley) 6/27/88";
X#endif /* not lint */
X
X/*
X *  Hunt
X *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold
X *  San Francisco, California
X */
X
X# include	"hunt.h"
X
Xdrawmaze(pp)
Xregister PLAYER	*pp;
X{
X	register int	x;
X	register char	*sp;
X	register int	y;
X	register char	*endp;
X
X	clrscr(pp);
X	outstr(pp, pp->p_maze[0], WIDTH);
X	for (y = 1; y < HEIGHT - 1; y++) {
X		endp = &pp->p_maze[y][WIDTH];
X		for (x = 0, sp = pp->p_maze[y]; sp < endp; x++, sp++)
X			if (*sp != SPACE) {
X				cgoto(pp, y, x);
X				if (pp->p_x == x && pp->p_y == y)
X					outch(pp, translate(*sp));
X				else
X					outch(pp, *sp);
X			}
X	}
X	cgoto(pp, HEIGHT - 1, 0);
X	outstr(pp, pp->p_maze[HEIGHT - 1], WIDTH);
X	drawstatus(pp);
X}
X
X/*
X * drawstatus - put up the status lines (this assumes the screen
X *		size is 80x24 with the maze being 64x24)
X */
Xdrawstatus(pp)
Xregister PLAYER	*pp;
X{
X	register int	i;
X	register PLAYER	*np;
X
X	(void) sprintf(Buf, "%-13.13s", pp->p_ident->i_name);
X	cgoto(pp, STAT_NAME_ROW, STAT_LABEL_COL);
X	outstr(pp, Buf, 13);
X
X	cgoto(pp, STAT_AMMO_ROW, STAT_LABEL_COL);
X	outstr(pp, "Ammo:", 5);
X	(void) sprintf(Buf, "%3d", pp->p_ammo);
X	cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
X	outstr(pp, Buf, 3);
X
X	cgoto(pp, STAT_CLOAK_ROW, STAT_LABEL_COL);
X	outstr(pp, "Cloak:", 6);
X	cgoto(pp, STAT_CLOAK_ROW, STAT_VALUE_COL);
X	outstr(pp, (pp->p_cloak < 0) ? "   " : " on", 3);
X
X	cgoto(pp, STAT_SCAN_ROW, STAT_LABEL_COL);
X	outstr(pp, "Scan:", 5);
X	cgoto(pp, STAT_SCAN_ROW, STAT_VALUE_COL);
X	outstr(pp, (pp->p_scan < 0) ? "   " : " on", 3);
X
X	cgoto(pp, STAT_GUN_ROW, STAT_LABEL_COL);
X	outstr(pp, "Gun:", 4);
X	cgoto(pp, STAT_GUN_ROW, STAT_VALUE_COL);
X	outstr(pp, (pp->p_ncshot < MAXNCSHOT) ? " ok" : "   ", 3);
X
X	cgoto(pp, STAT_DAM_ROW, STAT_LABEL_COL);
X	outstr(pp, "Damage:", 7);
X	(void) sprintf(Buf, "%2d/%2d", pp->p_damage, pp->p_damcap);
X	cgoto(pp, STAT_DAM_ROW, STAT_VALUE_COL);
X	outstr(pp, Buf, 5);
X
X	cgoto(pp, STAT_KILL_ROW, STAT_LABEL_COL);
X	outstr(pp, "Kills:", 6);
X	(void) sprintf(Buf, "%3d", (pp->p_damcap - MAXDAM) / 2);
X	cgoto(pp, STAT_KILL_ROW, STAT_VALUE_COL);
X	outstr(pp, Buf, 3);
X
X	cgoto(pp, STAT_PLAY_ROW, STAT_LABEL_COL);
X	outstr(pp, "Player:", 7);
X	for (i = STAT_PLAY_ROW + 1, np = Player; np < End_player; np++) {
X		(void) sprintf(Buf, "%5.2f%c%-10.10s", np->p_ident->i_score,
X			stat_char(np), np->p_ident->i_name);
X		cgoto(pp, i++, STAT_NAME_COL);
X		outstr(pp, Buf, STAT_NAME_LEN);
X	}
X
X# ifdef MONITOR
X	cgoto(pp, STAT_MON_ROW, STAT_LABEL_COL);
X	outstr(pp, "Monitor:", 8);
X	for (i = STAT_MON_ROW + 1, np = Monitor; np < End_monitor; np++) {
X		(void) sprintf(Buf, "%5.5s %-10.10s", " ", np->p_ident->i_name);
X		cgoto(pp, i++, STAT_NAME_COL);
X		outstr(pp, Buf, STAT_NAME_LEN);
X	}
X# endif MONITOR
X}
X
X# ifndef CPUHOG
Xlook(pp)
Xregister PLAYER	*pp;
X{
X	register int	x, y;
X
X	x = pp->p_x;
X	y = pp->p_y;
X
X	check(pp, y - 1, x - 1);
X	check(pp, y - 1, x    );
X	check(pp, y - 1, x + 1);
X	check(pp, y    , x - 1);
X	check(pp, y    , x    );
X	check(pp, y    , x + 1);
X	check(pp, y + 1, x - 1);
X	check(pp, y + 1, x    );
X	check(pp, y + 1, x + 1);
X
X	switch (pp->p_face) {
X	  case LEFTS:
X		see(pp, LEFTS);
X		see(pp, ABOVE);
X		see(pp, BELOW);
X		break;
X	  case RIGHT:
X		see(pp, RIGHT);
X		see(pp, ABOVE);
X		see(pp, BELOW);
X		break;
X	  case ABOVE:
X		see(pp, ABOVE);
X		see(pp, LEFTS);
X		see(pp, RIGHT);
X		break;
X	  case BELOW:
X		see(pp, BELOW);
X		see(pp, LEFTS);
X		see(pp, RIGHT);
X		break;
X# ifdef FLY
X	  case FLYER:
X		break;
X# endif FLY
X	}
X	cgoto(pp, y, x);
X}
X
Xsee(pp, face)
Xregister PLAYER	*pp;
Xint		face;
X{
X	register char	*sp;
X	register int	y, x, i, cnt;
X
X	x = pp->p_x;
X	y = pp->p_y;
X
X	switch (face) {
X	  case LEFTS:
X		sp = &Maze[y][x];
X		for (i = 0; See_over[*--sp]; i++)
X			continue;
X
X		if (i == 0)
X			break;
X
X		cnt = i;
X		x = pp->p_x - 1;
X		--y;
X		while (i--)
X			check(pp, y, --x);
X		i = cnt;
X		x = pp->p_x - 1;
X		++y;
X		while (i--)
X			check(pp, y, --x);
X		i = cnt;
X		x = pp->p_x - 1;
X		++y;
X		while (i--)
X			check(pp, y, --x);
X		break;
X	  case RIGHT:
X		sp = &Maze[y][++x];
X		for (i = 0; See_over[*sp++]; i++)
X			continue;
X
X		if (i == 0)
X			break;
X
X		cnt = i;
X		x = pp->p_x + 1;
X		--y;
X		while (i--)
X			check(pp, y, ++x);
X		i = cnt;
X		x = pp->p_x + 1;
X		++y;
X		while (i--)
X			check(pp, y, ++x);
X		i = cnt;
X		x = pp->p_x + 1;
X		++y;
X		while (i--)
X			check(pp, y, ++x);
X		break;
X	  case ABOVE:
X		sp = &Maze[--y][x];
X		if (!See_over[*sp])
X			break;
X		do {
X			--y;
X			sp -= sizeof Maze[0];
X			check(pp, y, x - 1);
X			check(pp, y, x    );
X			check(pp, y, x + 1);
X		} while (See_over[*sp]);
X		break;
X	  case BELOW:
X		sp = &Maze[++y][x];
X		if (!See_over[*sp])
X			break;
X		do {
X			y++;
X			sp += sizeof Maze[0];
X			check(pp, y, x - 1);
X			check(pp, y, x    );
X			check(pp, y, x + 1);
X		} while (See_over[*sp]);
X		break;
X	}
X}
X
X# else CPUHOG
X
Xlook(pp)
Xregister PLAYER	*pp;
X{
X	switch (pp->p_face) {
X	  case LEFTS:
X		lookquad2(pp, pp->p_y, pp->p_x);
X		lookquad3(pp, pp->p_y, pp->p_x);
X		break;
X	  case RIGHT:
X		lookquad1(pp, pp->p_y, pp->p_x);
X		lookquad4(pp, pp->p_y, pp->p_x);
X		break;
X	  case ABOVE:
X		lookquad3(pp, pp->p_y, pp->p_x);
X		lookquad4(pp, pp->p_y, pp->p_x);
X		break;
X	  case BELOW:
X		lookquad1(pp, pp->p_y, pp->p_x);
X		lookquad2(pp, pp->p_y, pp->p_x);
X		break;
X	}
X	cgoto(pp, pp->p_y, pp->p_x);
X}
X# endif CPUHOG
X
Xcheck(pp, y, x)
XPLAYER	*pp;
Xint	y, x;
X{
X	register int	index;
X	register int	ch;
X	register PLAYER	*rpp;
X
X	index = y * sizeof Maze[0] + x;
X	ch = ((char *) Maze)[index];
X	if (ch != ((char *) pp->p_maze)[index]) {
X		rpp = pp;
X		cgoto(rpp, y, x);
X		if (x == rpp->p_x && y == rpp->p_y)
X			outch(rpp, translate(ch));
X		else
X			outch(rpp, ch);
X		((char *) rpp->p_maze)[index] = ch;
X	}
X}
X
X/*
X * showstat
X *	Update the status of players
X */
Xshowstat(pp)
Xregister PLAYER	*pp;
X{
X	register PLAYER	*np;
X	register int	y;
X	register char	c;
X
X	y = STAT_PLAY_ROW + 1 + (pp - Player);
X	c = stat_char(pp);
X# ifdef MONITOR
X	for (np = Monitor; np < End_monitor; np++) {
X		cgoto(np, y, STAT_SCAN_COL);
X		outch(np, c);
X	}
X# endif MONITOR
X	for (np = Player; np < End_player; np++) {
X		cgoto(np, y, STAT_SCAN_COL);
X		outch(np, c);
X	}
X}
X
X/*
X * drawplayer:
X *	Draw the player on the screen and show him to everyone who's scanning
X *	unless he is cloaked.
X */
Xdrawplayer(pp, draw)
XPLAYER	*pp;
XFLAG	draw;
X{
X	register PLAYER	*newp;
X	register int	x, y;
X
X	x = pp->p_x;
X	y = pp->p_y;
X	Maze[y][x] = draw ? pp->p_face : pp->p_over;
X
X# ifdef MONITOR
X	for (newp = Monitor; newp < End_monitor; newp++)
X		check(newp, y, x);
X# endif MONITOR
X
X	for (newp = Player; newp < End_player; newp++) {
X		if (!draw || newp == pp) {
X			check(newp, y, x);
X			continue;
X		}
X		if (newp->p_scan == 0) {
X			cgoto(newp, STAT_SCAN_ROW, STAT_VALUE_COL);
X			outstr(newp, "   ", 3);
X			newp->p_scan--;
X			showstat(newp);
X		}
X		else if (newp->p_scan > 0) {
X			if (pp->p_cloak < 0)
X				check(newp, y, x);
X			newp->p_scan--;
X		}
X	}
X	if (!draw || pp->p_cloak < 0)
X		return;
X	if (pp->p_cloak-- == 0) {
X		cgoto(pp, STAT_CLOAK_ROW, STAT_VALUE_COL);
X		outstr(pp, "   ", 3);
X		showstat(pp);
X	}
X}
X
Xmessage(pp, s)
Xregister PLAYER	*pp;
Xchar		*s;
X{
X	cgoto(pp, HEIGHT, 0);
X	outstr(pp, s, strlen(s));
X	ce(pp);
X}
X
X/*
X * translate:
X *	Turn a charcter into the right direction character if we are
X *	looking at the current player.
X */
Xtranslate(ch)
Xchar	ch;
X{
X	switch (ch) {
X	  case LEFTS:
X		return PLAYER_LEFT;
X	  case RIGHT:
X		return PLAYER_RIGHT;
X	  case ABOVE:
X		return PLAYER_ABOVE;
X	  case BELOW:
X		return PLAYER_BELOW;
X	}
X	return ch;
X}
END_OF_FILE
if test 8245 -ne `wc -c <'draw.c'`; then
    echo shar: \"'draw.c'\" unpacked with wrong size!
fi
# end of 'draw.c'
fi
if test -f 'execute.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'execute.c'\"
else
echo shar: Extracting \"'execute.c'\" \(9279 characters\)
sed "s/^X//" >'execute.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1985 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
Xstatic char sccsid[] = "@(#)execute.c	5.2 (Berkeley) 6/27/88";
X#endif /* not lint */
X
X/*
X *  Hunt
X *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold
X *  San Francisco, California
X */
X
X# include	"hunt.h"
X
X# undef CTRL
X# define	CTRL(x)	('x' & 037)
X
X# ifdef MONITOR
X/*
X * mon_execute:
X *	Execute a single monitor command
X */
Xmon_execute(pp)
Xregister PLAYER	*pp;
X{
X	register char	ch;
X
X	ch = pp->p_cbuf[pp->p_ncount++];
X	switch (ch) {
X	  case CTRL(L):
X		sendcom(pp, REDRAW);
X		break;
X	  case 'q':
X		(void) strcpy(pp->p_death, "| Quit |");
X		break;
X	}
X}
X# endif MONITOR
X
X/*
X * execute:
X *	Execute a single command
X */
Xexecute(pp)
Xregister PLAYER	*pp;
X{
X	register char	ch;
X
X	ch = pp->p_cbuf[pp->p_ncount++];
X
X# ifdef	FLY
X	if (pp->p_flying >= 0) {
X		switch (ch) {
X		  case CTRL(L):
X			sendcom(pp, REDRAW);
X			break;
X		  case 'q':
X			(void) strcpy(pp->p_death, "| Quit |");
X			break;
X		}
X		return;
X	}
X# endif	FLY
X
X	switch (ch) {
X	  case CTRL(L):
X		sendcom(pp, REDRAW);
X		break;
X	  case 'h':
X		move(pp, LEFTS);
X		break;
X	  case 'H':
X		face(pp, LEFTS);
X		break;
X	  case 'j':
X		move(pp, BELOW);
X		break;
X	  case 'J':
X		face(pp, BELOW);
X		break;
X	  case 'k':
X		move(pp, ABOVE);
X		break;
X	  case 'K':
X		face(pp, ABOVE);
X		break;
X	  case 'l':
X		move(pp, RIGHT);
X		break;
X	  case 'L':
X		face(pp, RIGHT);
X		break;
X	  case 'f':
X		fire(pp, SHOT);
X		break;
X	  case 'g':
X		fire(pp, GRENADE);
X		break;
X	  case 'F':
X		fire(pp, SATCHEL);
X		break;
X	  case 'G':
X		fire(pp, BOMB);
X		break;
X# ifdef	OOZE
X	  case 'o':
X		fire_slime(pp, SLIMEREQ);
X		break;
X	  case 'O':
X		fire_slime(pp, SSLIMEREQ);
X		break;
X# endif	OOZE
X	  case 's':
X		scan(pp);
X		break;
X	  case 'c':
X		cloak(pp);
X		break;
X	  case 'q':
X		(void) strcpy(pp->p_death, "| Quit |");
X		break;
X	}
X}
X
X/*
X * move:
X *	Execute a move in the given direction
X */
Xmove(pp, dir)
Xregister PLAYER	*pp;
Xint		dir;
X{
X	register PLAYER	*newp;
X	register int	x, y;
X	register FLAG	moved;
X	register BULLET	*bp;
X
X	y = pp->p_y;
X	x = pp->p_x;
X
X	switch (dir) {
X	  case LEFTS:
X		x--;
X		break;
X	  case RIGHT:
X		x++;
X		break;
X	  case ABOVE:
X		y--;
X		break;
X	  case BELOW:
X		y++;
X		break;
X	}
X
X	moved = FALSE;
X	switch (Maze[y][x]) {
X	  case SPACE:
X# ifdef RANDOM
X	  case DOOR:
X# endif RANDOM
X		moved = TRUE;
X		break;
X	  case WALL1:
X	  case WALL2:
X	  case WALL3:
X# ifdef REFLECT
X	  case WALL4:
X	  case WALL5:
X# endif REFLECT
X		break;
X	  case MINE:
X	  case GMINE:
X		if (dir == pp->p_face)
X			pickup(pp, y, x, 5, Maze[y][x]);
X		else if (opposite(dir, pp->p_face))
X			pickup(pp, y, x, 95, Maze[y][x]);
X		else
X			pickup(pp, y, x, 50, Maze[y][x]);
X		Maze[y][x] = SPACE;
X		moved = TRUE;
X		break;
X	  case SHOT:
X	  case GRENADE:
X	  case SATCHEL:
X	  case BOMB:
X		bp = is_bullet(y, x);
X		if (bp != NULL)
X			bp->b_expl = TRUE;
X		Maze[y][x] = SPACE;
X		moved = TRUE;
X		break;
X	  case LEFTS:
X	  case RIGHT:
X	  case ABOVE:
X	  case BELOW:
X# ifdef FLY
X	  case FLYER:
X# endif FLY
X		if (dir != pp->p_face)
X			sendcom(pp, BELL);
X		else {
X			newp = play_at(y, x);
X			checkdam(newp, pp, pp->p_ident, STABDAM, KNIFE);
X		}
X		break;
X	}
X	if (moved) {
X		if (pp->p_ncshot > 0)
X			if (--pp->p_ncshot == MAXNCSHOT) {
X				cgoto(pp, STAT_GUN_ROW, STAT_VALUE_COL);
X				outstr(pp, " ok", 3);
X			}
X		if (pp->p_undershot) {
X			fixshots(pp->p_y, pp->p_x, pp->p_over);
X			pp->p_undershot = FALSE;
X		}
X		drawplayer(pp, FALSE);
X		pp->p_over = Maze[y][x];
X		pp->p_y = y;
X		pp->p_x = x;
X		drawplayer(pp, TRUE);
X	}
X}
X
X/*
X * face:
X *	Change the direction the player is facing
X */
Xface(pp, dir)
Xregister PLAYER	*pp;
Xregister int	dir;
X{
X	if (pp->p_face != dir) {
X		pp->p_face = dir;
X		drawplayer(pp, TRUE);
X	}
X}
X
X/*
X * fire:
X *	Fire a shot of the given type in the given direction
X */
Xfire(pp, type)
Xregister PLAYER	*pp;
Xregister char	type;
X{
X	register int	req_index;
X	static int	req[4] = { BULREQ, GRENREQ, SATREQ, BOMBREQ };
X	static int	shot_type[4] = { SHOT, GRENADE, SATCHEL, BOMB };
X
X	if (pp == NULL)
X		return;
X	if (pp->p_ammo == 0) {
X		message(pp, "No more charges.");
X		return;
X	}
X	if (pp->p_ncshot > MAXNCSHOT)
X		return;
X	if (pp->p_ncshot++ == MAXNCSHOT) {
X		cgoto(pp, STAT_GUN_ROW, STAT_VALUE_COL);
X		outstr(pp, "   ", 3);
X	}
X	switch (type) {
X	  case SHOT:
X		req_index = 0;
X		break;
X	  case GRENADE:
X		req_index = 1;
X		break;
X	  case SATCHEL:
X		req_index = 2;
X		break;
X	  case BOMB:
X		req_index = 3;
X		break;
X# ifdef DEBUG
X	  default:
X		message(pp, "What you do!!!");
X		return;
X# endif DEBUG
X	}
X	while (pp->p_ammo < req[req_index])
X		req_index--;
X	pp->p_ammo -= req[req_index];
X	(void) sprintf(Buf, "%3d", pp->p_ammo);
X	cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
X	outstr(pp, Buf, 3);
X
X	add_shot(shot_type[req_index], pp->p_y, pp->p_x, pp->p_face,
X		req[req_index], pp, FALSE, pp->p_face);
X	pp->p_undershot = TRUE;
X
X	/*
X	 * Show the object to everyone
X	 */
X	showexpl(pp->p_y, pp->p_x, shot_type[req_index]);
X	for (pp = Player; pp < End_player; pp++)
X		sendcom(pp, REFRESH);
X# ifdef MONITOR
X	for (pp = Monitor; pp < End_monitor; pp++)
X		sendcom(pp, REFRESH);
X# endif MONITOR
X}
X
X# ifdef	OOZE
X/*
X * fire_slime:
X *	Fire a slime shot in the given direction
X */
Xfire_slime(pp, req)
Xregister PLAYER	*pp;
Xregister int	req;
X{
X	if (pp == NULL)
X		return;
X	if (pp->p_ammo < req) {
X		message(pp, "Not enough charges.");
X		return;
X	}
X	if (pp->p_ncshot > MAXNCSHOT)
X		return;
X	if (pp->p_ncshot++ == MAXNCSHOT) {
X		cgoto(pp, STAT_GUN_ROW, STAT_VALUE_COL);
X		outstr(pp, "   ", 3);
X	}
X	pp->p_ammo -= req;
X	(void) sprintf(Buf, "%3d", pp->p_ammo);
X	cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
X	outstr(pp, Buf, 3);
X
X	add_shot(SLIME, pp->p_y, pp->p_x, pp->p_face, req, pp, FALSE,
X		pp->p_face);
X
X	/*
X	 * Show the object to everyone
X	 */
X	showexpl(pp->p_y, pp->p_x, SLIME);
X	for (pp = Player; pp < End_player; pp++)
X		sendcom(pp, REFRESH);
X# ifdef MONITOR
X	for (pp = Monitor; pp < End_monitor; pp++)
X		sendcom(pp, REFRESH);
X# endif MONITOR
X}
X# endif	OOZE
X
X/*
X * create_shot:
X *	Create a shot with the given properties
X */
Xadd_shot(type, y, x, face, charge, owner, expl, over)
Xint	type;
Xint	y, x;
Xchar	face;
Xint	charge;
XPLAYER	*owner;
Xint	expl;
Xchar	over;
X{
X	register BULLET	*bp;
X
X# ifdef CONSTANT_MOVE
X	/*
X	 * if there are no bullets in flight, set up the alarm
X	 */
X
X	if (Bullets == NULL)
X		bul_alarm(1);
X# endif CONSTANT_MOVE
X
X	bp = create_shot(type, y, x, face, charge, owner,
X		(owner == NULL) ? NULL : owner->p_ident, expl, over);
X	bp->b_next = Bullets;
X	Bullets = bp;
X}
X
XBULLET *
Xcreate_shot(type, y, x, face, charge, owner, score, expl, over)
Xint	type;
Xint	y, x;
Xchar	face;
Xint	charge;
XPLAYER	*owner;
XIDENT	*score;
Xint	expl;
Xchar	over;
X{
X	register BULLET	*bp;
X
X	bp = (BULLET *) malloc(sizeof (BULLET));	/* NOSTRICT */
X	if (bp == NULL) {
X		if (owner != NULL)
X			message(owner, "Out of memory");
X		return NULL;
X	}
X
X	bp->b_face = face;
X	bp->b_x = x;
X	bp->b_y = y;
X	bp->b_charge = charge;
X	bp->b_owner = owner;
X	bp->b_score = score;
X	bp->b_type = type;
X	bp->b_expl = expl;
X	bp->b_over = over;
X	bp->b_next = NULL;
X
X	return bp;
X}
X
X/*
X * cloak:
X *	Turn on or increase length of a cloak
X */
Xcloak(pp)
Xregister PLAYER	*pp;
X{
X	if (pp->p_ammo <= 0) {
X		message(pp, "No more charges");
X		return;
X	}
X	(void) sprintf(Buf, "%3d", --pp->p_ammo);
X	cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
X	outstr(pp, Buf, 3);
X
X	pp->p_cloak += CLOAKLEN;
X	cgoto(pp, STAT_CLOAK_ROW, STAT_VALUE_COL);
X	outstr(pp, " on", 3);
X
X	if (pp->p_scan >= 0) {
X		pp->p_scan = -1;
X		cgoto(pp, STAT_SCAN_ROW, STAT_VALUE_COL);
X		outstr(pp, "   ", 3);
X	}
X
X	showstat(pp);
X}
X
X/*
X * scan:
X *	Turn on or increase length of a scan
X */
Xscan(pp)
Xregister PLAYER	*pp;
X{
X	if (pp->p_ammo <= 0) {
X		message(pp, "No more charges");
X		return;
X	}
X	(void) sprintf(Buf, "%3d", --pp->p_ammo);
X	cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
X	outstr(pp, Buf, 3);
X
X	pp->p_scan += SCANLEN;
X	cgoto(pp, STAT_SCAN_ROW, STAT_VALUE_COL);
X	outstr(pp, " on", 3);
X
X	if (pp->p_cloak >= 0) {
X		pp->p_cloak = -1;
X		cgoto(pp, STAT_CLOAK_ROW, STAT_VALUE_COL);
X		outstr(pp, "   ", 3);
X	}
X
X	showstat(pp);
X}
X
X/*
X * pickup:
X *	check whether the object blew up or whether he picked it up
X */
Xpickup(pp, y, x, prob, obj)
Xregister PLAYER	*pp;
Xregister int	y, x;
Xint		prob;
Xint		obj;
X{
X	register int	req;
X
X	switch (obj) {
X	  case MINE:
X		req = BULREQ;
X		break;
X	  case GMINE:
X		req = GRENREQ;
X		break;
X	  default:
X		abort();
X	}
X	if (rand_num(100) < prob)
X		add_shot(obj, y, x, LEFTS, req, (PLAYER *) NULL,
X			TRUE, pp->p_face);
X	else {
X		pp->p_ammo += req;
X		(void) sprintf(Buf, "%3d", pp->p_ammo);
X		cgoto(pp, STAT_AMMO_ROW, STAT_VALUE_COL);
X		outstr(pp, Buf, 3);
X	}
X}
END_OF_FILE
if test 9279 -ne `wc -c <'execute.c'`; then
    echo shar: \"'execute.c'\" unpacked with wrong size!
fi
# end of 'execute.c'
fi
if test -f 'hunt.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hunt.6'\"
else
echo shar: Extracting \"'hunt.6'\" \(8633 characters\)
sed "s/^X//" >'hunt.6' <<'END_OF_FILE'
X.\" Copyright (c) 1985 The Regents of the University of California.
X.\" All rights reserved.
X.\"
X.\" Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold
X.\"
X.\" Redistribution and use in source and binary forms are permitted
X.\" provided that the above copyright notice and this paragraph are
X.\" duplicated in all such forms and that any documentation,
X.\" advertising materials, and other materials related to such
X.\" distribution and use acknowledge that the software was developed
X.\" by the University of California, Berkeley.  The name of the
X.\" University may not be used to endorse or promote products derived
X.\" from this software without specific prior written permission.
X.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X.\" IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X.\" WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X.\"
X.\"	@(#)hunt.6	6.4 (Berkeley) 9/23/88
X.\"
X.TH HUNT 6 "September 23, 1988"
X.UC 6
X.SH NAME
Xhunt \- a multi-player multi-terminal game
X.SH SYNOPSIS
X\fB/usr/games/hunt\fP [-q] [\fB-m\fP] [-r [-d] ] [hostname] [\fB-l\fP name]
X.SH DESCRIPTION
XThe object of the game
X.I hunt
Xis to kill off the other players.
XThere are no rooms, no treasures, and no monsters.
XInstead, you wander around a maze, find grenades, trip mines, and shoot down
Xwalls and players.
XThe more players you kill before you die, the better your score is.
XIf the
X.B \-m
Xflag is given,
Xyou enter the game as a monitor
X(you can see the action but you cannot play).
X.PP
X.I Hunt
Xnormally looks for an active game on the local network; if none is found,
Xit starts one up on the local host.  One may specify the location of the
Xgame by giving the \fIhostname\fP argument.  The player name may be specified
Xon the command line by using the \fB-l\fP option.  This command syntax was
Xchosen for \fIrlogin/rsh\fP compatibility.
XIf the
X.B \-q
Xflag is given,
X.I hunt
Xqueries the network and reports if an active game were found.
XThis is useful for .login scripts.
X.PP
XThe
X.B \-r
Xflag makes the current player a robot.  The
X.B \-d
Xflag in conjunction with the
X.B \-r
Xflag allows the robot to play in the background, as a daemon.  This
Xis useful when you want to set up a couple of robots to play against.
X.PP
X.I Hunt
Xonly works on crt (vdt) terminals with at least 24 lines, 80 columns, and
Xcursor addressing.
XThe screen is divided in to 3 areas.
XOn the right hand side is the status area.
XIt shows you how much damage you've sustained,
Xhow many charges you have left,
Xwho's in the game,
Xwho's scanning (the asterisk in front of the name),
Xwho's cloaked (the plus sign in front of the name),
Xand other players' scores.
XMost of the rest of the screen is taken up by your map of the maze,
Xexcept for the 24th line,
Xwhich is used for longer messages that don't fit in the status area.
X.PP
X.I Hunt
Xuses the same keys to move as
X.I vi
Xdoes,
X.IR i.e. ,
X.BR h , j , k ,
Xand
X.B l
Xfor left, down, up, right respectively.
XTo change which direction you're facing in the maze,
Xuse the upper case version of the movement key (\c
X.IR i.e. ,
XHJKL).
X.TP
XOther commands are:
X.sp
X.nf
X.ta
X.ta \w'>\|<\|^\|v\ \ 'u
Xf	\- Fire (in the direction you're facing) (Takes 1 charge)
Xg	\- Throw grenade (in the direction you're facing) (Takes 9 charges)
XF	\- Throw satchel charge (Takes 25 charges)
XG	\- Throw bomb (Takes 49 charges)
Xo	\- Throw small slime bomb (Takes 15 charges)
XO	\- Throw big slime bomb (Takes 30 charges)
Xs	\- Scan (show where other players are) (Takes 1 charge)
Xc	\- Cloak (hide from scanners) (Takes 1 charge)
X
X^L	\- Redraw screen
Xq	\- Quit
X.fi
X.TP
XKnowing what the symbols on the screen often helps:
X.sp
X.nf
X.ta
X.ta \w'>\|<\|^\|v\ \ 'u
X\-\||\|+	\- walls
X/\|\\	\- diagonal (deflecting) walls
X#	\- doors (dispersion walls)
X;	\- small mine
Xg	\- large mine
X:	\- shot
Xo	\- grenade
XO	\- satchel charge
X@	\- bomb
Xs	\- small slime bomb
X$	\- big slime bomb
X>\|<\|^\|v	\- you facing right, left, up, or down
X}\|{\|i\|!	\- other players facing right, left, up, or down
X\(**	\- explosion
X.ne 3
X.cs R 24
X.cs I 24
X\fR\\|/\fP
X.cs R
X\fI\-\(**\-\fP	\- grenade and large mine explosion
X.fl
X.cs R 24
X\fR/|\\\fP
X.cs R
X.cs I
X.fi
X.TP
XSatchel and bomb explosions are larger than grenades (5x5, 7x7,
Xand 3x3 respectively).
X.LP
XOther helpful hints:
X.sp
X.ie n .ds b []
X.el .ds b \(bu
X.ta
X.ta \w'\*b\ \|'u
X.nr In \n(.i
X.de MP
X.br
X.in \n(Inu+\w'\*b\ \|'u
X.ti \n(Inu
X\*b	\c
X..
X.MP
XYou can only fire in the direction you are facing.
X.MP
XYou can only fire three shots in a row, then the gun must cool.
X.MP
XA shot only affects the square it hits.
X.MP
XShots and grenades move 5 times faster than you do.
X.MP
XTo stab someone,
Xyou must face that player and move at them.
X.MP
XStabbing does 2 points worth of damage and shooting does 5 points.
X.MP
XSlime does 5 points of damage each time it hits.
X.MP
XYou start with 15 charges and get 5 more for every new player.
X.MP
XA grenade affects the nine squares centered about the square it hits.
X.MP
XA satchel affects the twenty-five squares centered about the square it hits.
X.MP
XA bomb affects the forty-nine squares centered about the square it hits.
X.MP
XSlime affects all squares it oozes over (15 or 30 respectively).
X.MP
XOne small mine and one large mine is placed in the maze for every new player.
XA mine has a 5% probability of tripping when you walk directly at it;
X50% when going sideways on to it;
X95% when backing up on to it.
XTripping a mine costs you 5 points or 10 points respectively.
XDefusing a mine is worth 1 charge or 9 charges respectively.
X.MP
XYou cannot see behind you.
X.MP
XScanning lasts for (20 times the number of players) turns.
XScanning takes 1 ammo charge,
Xso don't waste all your charges scanning.
X.MP
XCloaking lasts for 20 turns.
X.MP
XWhenever you kill someone,
Xyou get 2 more damage capacity points and 2 damage points taken away.
X.MP
XMaximum typeahead is 5 characters.
X.MP
XA shot destroys normal (\c
X.IR i.e., 
Xnon-diagonal, non-door) walls.
X.MP
XDiagonal walls deflect shots and change orientation.
X.MP
XDoors disperse shots in random directions (up, down, left, right).
X.MP
XDiagonal walls and doors cannot be destroyed by direct shots but may
Xbe destroyed by an adjacent grenade explosion.
X.MP
XSlime goes around walls, not through them.
X.MP
XWalls regenerate, reappearing in the order they were destroyed.
XOne percent of the regenerated walls will be diagonal walls or doors.
XWhen a wall is generated directly beneath a player, he is thrown in
Xa random direction for a random period of time.  When he lands, he
Xsustains damage (up to 20 percent of the amount of damage he had before
Ximpact); that is, the less damage he had, the more nimble he is and
Xtherefore less likely to hurt himself on landing.
X\".MP
X\"There is a volcano close to the center of the maze which goes off
X\"close to every 100 deaths.
X.MP
XThe environment variable
X.B HUNT
Xis checked to get the player name.
XIf you don't have this variable set,
X.I hunt
Xwill ask you what name you want to play under.
XIf it is set,
Xyou may also set up a single character keyboard map, but then you have to
Xenumerate the options:
X.br
X.ti +1i
X\fIe.g.\fP setenv HUNT ``name=Sneaky,mapkey=zoFfGg1f2g3F4G''
X.br
Xsets the player name to Sneaky,
Xand the maps \fBz\fP to \fBo\fP, \fBF\fP to \fBf\fP, \fBG\fP to \fBg\fP,
X\fB1\fP to \fBf\fP,
X\fB2\fP to \fBg\fP, \fB3\fP to \fBF\fP, and \fB4\fP to \fBG\fP.
XThe \fImapkey\fP option must be last.
X.MP
XIt's a boring game if you're the only one playing.
X.PP
XYour score is the ratio of number of kills to number
Xof times you entered the game and is only kept for the duration
Xof a single session of \fIhunt\fP.
X.PP
X.I Hunt
Xnormally drives up the load average to be about
X(number_of_players + 0.5) greater than it would be without a
X.I hunt 
Xgame executing.  A limit of three players per host and nine players
Xtotal is enforced by \fIhunt\fP.
X.SH FILES
X.nf
X.ta
X.ta \w'/usr/games/lib/hunt.driver\ \ \ 'u
X/usr/games/lib/hunt.driver	game coordinator
X.DT
X.fi
X.SH AUTHORS
XConrad Huang,
XKen Arnold,
Xand Greg Couch,
XUniversity of California, San Francisco, Computer Graphics Lab.
X.PP
XRobot written by Steve Boswell, University of California, San Diego.
X.SH ACKNOWLEDGEMENTS
XWe thank Don Kneller,
XJohn Thomason, Eric Pettersen,
Xand Scott Weiner for providing
Xendless hours of play-testing to improve the character of the game.
XWe hope their significant others will forgive them;
Xwe certainly don't.
X.PP
XSteve would like to thank Jimmy Lang for providing skilled competition
Xfor the robot during its development, and for all the feedback.
X.SH BUGS
XTo keep up the pace, not everything is as realistic as possible.
X.PP
XThe robot sometimes gets into steady states.
END_OF_FILE
if test 8633 -ne `wc -c <'hunt.6'`; then
    echo shar: \"'hunt.6'\" unpacked with wrong size!
fi
# end of 'hunt.6'
fi
if test -f 'hunt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hunt.h'\"
else
echo shar: Extracting \"'hunt.h'\" \(6817 characters\)
sed "s/^X//" >'hunt.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1985 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X *
X *	@(#)hunt.h	5.2 (Berkeley) 6/27/88
X */
X
X/*
X *  Hunt
X *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold
X *  San Francisco, California
X */
X
X# ifndef _H_hunt
X# define _H_hunt
X
X# include	<stdio.h>
X# ifndef OLDIPC
X# include	<sgtty.h>
X# include	<sys/types.h>
X# include	<sys/uio.h>
X# else OLDIPC
X# include	<sys/localopts.h>
X# include	<sys/types.h>
X# include	<sys/netltoshort.h>
X# endif OLDIPC
X# include	<sys/socket.h>
X# ifdef	INTERNET
X# include	<netinet/in.h>
X# include	<netdb.h>
X# ifndef OLDIPC
X# include	<arpa/inet.h>
X# endif !OLDIPC
X# ifdef BROADCAST
X# include	<net/if.h>
X# endif BROADCAST
X# else	INTERNET
X# include	<sys/un.h>
X# endif	INTERNET
X
X# ifdef	INTERNET
X# define	SOCK_FAMILY	AF_INET
X# else	INTERNET
X# define	SOCK_FAMILY	AF_UNIX
X# define	AF_UNIX_HACK		/* 4.2 hack; leaves files around */
X# endif	INTERNET
X
X# define	ADDCH		('a' | 0200)
X# define	MOVE		('m' | 0200)
X# define	REFRESH		('r' | 0200)
X# define	CLRTOEOL	('c' | 0200)
X# define	ENDWIN		('e' | 0200)
X# define	CLEAR		('C' | 0200)
X# define	REDRAW		('R' | 0200)
X# define	LAST_PLAYER	('l' | 0200)
X# define	BELL		('b' | 0200)
X# define	READY		('g' | 0200)
X
X/*
X * Choose MAXPL and MAXMON carefully.  The screen is assumed to be
X * 23 lines high and will only tolerate (MAXPL == 12 && MAXMON == 0)
X * or (MAXPL + MAXMON <= 10).
X */
X# define	MAXPL		9
X# ifdef MONITOR
X# define	MAXMON		1
X# endif MONITOR
X# define	NAMELEN		20
X# define	MSGLEN		80
X# define	DECAY		50.0
X
X# define	NASCII		128
X
X# ifndef REFLECT
X# ifndef RANDOM
X# define RANDOM
X# endif RANDOM
X# endif REFLECT
X
X# define	WIDTH	59
X# define	WIDTH2	64	/* Next power of 2 >= WIDTH (for fast access) */
X# define	HEIGHT	23
X# define	UBOUND	1
X# define	DBOUND	22
X# define	LBOUND	1
X# define	RBOUND	(WIDTH - 1)
X
X# define	STAT_LABEL_COL	60
X# define	STAT_VALUE_COL	74
X# define	STAT_NAME_COL	61
X# define	STAT_SCAN_COL	(STAT_NAME_COL + 5)
X# define	STAT_NAME_ROW	0
X# define	STAT_AMMO_ROW	2
X# define	STAT_SCAN_ROW	3
X# define	STAT_CLOAK_ROW	4
X# define	STAT_GUN_ROW	5
X# define	STAT_DAM_ROW	7
X# define	STAT_KILL_ROW	8
X# define	STAT_PLAY_ROW	10
X# ifdef MONITOR
X# define	STAT_MON_ROW	(STAT_PLAY_ROW + MAXPL + 1)
X# endif MONITOR
X# define	STAT_NAME_LEN	16
X
X# define	DOOR	'#'
X# define	WALL1	'-'
X# define	WALL2	'|'
X# define	WALL3	'+'
X# ifdef REFLECT
X# define	WALL4	'/'
X# define	WALL5	'\\'
X# endif REFLECT
X# define	KNIFE	'K'
X# define	SHOT	':'
X# define	GRENADE	'o'
X# define	SATCHEL	'O'
X# define	BOMB	'@'
X# define	MINE	';'
X# define	GMINE	'g'
X# ifdef	OOZE
X# define	SLIME	'$'
X# endif	OOZE
X# ifdef	VOLCANO
X# define	LAVA	'~'
X# endif	VOLCANO
X# ifdef FLY
X# define	FALL	'F'
X# endif FLY
X# define	SPACE	' '
X
X# define	ABOVE	'i'
X# define	BELOW	'!'
X# define	RIGHT	'}'
X# define	LEFTS	'{'
X# ifdef FLY
X# define	FLYER	'&'
X# endif FLY
X
X# define	PLAYER_ABOVE	'^'
X# define	PLAYER_BELOW	'v'
X# define	PLAYER_RIGHT	'>'
X# define	PLAYER_LEFT		'<'
X
X# define	NORTH	01
X# define	SOUTH	02
X# define	EAST	010
X# define	WEST	020
X
X# ifndef TRUE
X# define	TRUE	1
X# define	FALSE	0
X# endif TRUE
X# ifndef CTRL
X# define	CTRL(x)	('x' & 037)
X# endif CTRL
X
X# define	BULSPD		5		/* bullets movement speed */
X# define	ISHOTS		15
X# define	NSHOTS		5
X# define	MAXNCSHOT	2
X# define	MAXDAM		10
X# define	MINDAM		5
X# define	STABDAM		2
X
X# define	BULREQ		1
X# define	GRENREQ		9
X# define	SATREQ		25
X# define	BOMBREQ		49
X# ifdef	OOZE
X# define	SLIMEREQ	15
X# define	SSLIMEREQ	30
X# define	SLIMESPEED	5
X# endif	OOZE
X# ifdef	VOLCANO
X# define	LAVASPEED	2
X# endif VOLCANO
X
X# define	CLOAKLEN	20
X# define	SCANLEN		(Nplayer * 20)
X# define	EXPLEN		4
X
X# ifdef FLY
X# define	_cloak_char(pp)	(((pp)->p_cloak < 0) ? ' ' : '+')
X# define	_scan_char(pp)	(((pp)->p_scan < 0) ? _cloak_char(pp) : '*')
X# define	stat_char(pp)	(((pp)->p_flying < 0) ? _scan_char(pp) : FLYER)
X# else FLY
X# define	_cloak_char(pp)	(((pp)->p_cloak < 0) ? ' ' : '+')
X# define	stat_char(pp)	(((pp)->p_scan < 0) ? _cloak_char(pp) : '*')
X# endif FLY
X
Xtypedef int			FLAG;
Xtypedef struct bullet_def	BULLET;
Xtypedef struct expl_def		EXPL;
Xtypedef struct player_def	PLAYER;
Xtypedef struct ident_def	IDENT;
Xtypedef struct regen_def	REGEN;
X# ifdef	INTERNET
Xtypedef struct sockaddr_in	SOCKET;
X# else	INTERNET
Xtypedef struct sockaddr_un	SOCKET;
X# endif	INTERNET
Xtypedef struct sgttyb		TTYB;
X
Xstruct ident_def {
X	char	i_name[NAMELEN];
X	long	i_machine;
X	long	i_uid;
X	int	i_kills;
X	int	i_entries;
X	float	i_score;
X	IDENT	*i_next;
X};
X
Xstruct player_def {
X	IDENT	*p_ident;
X	int	p_face;
X	char	p_over;
X	int	p_undershot;
X# ifdef	FLY
X	int	p_flying;
X	int	p_flyx, p_flyy;
X# endif FLY
X	FILE	*p_output;
X	int	p_fd;
X	int	p_mask;
X	int	p_damage;
X	int	p_damcap;
X	int	p_ammo;
X	int	p_ncshot;
X	int	p_scan;
X	int	p_cloak;
X	int	p_x, p_y;
X	int	p_ncount;
X	int	p_nexec;
X	long	p_nchar;
X	char	p_death[MSGLEN];
X	char	p_maze[HEIGHT][WIDTH2];
X	int	p_curx, p_cury;
X	int	p_lastx, p_lasty;
X	int	p_changed;
X	char	p_cbuf[BUFSIZ];
X};
X
Xstruct bullet_def {
X	int	b_x, b_y;
X	int	b_face;
X	int	b_charge;
X	char	b_type;
X	char	b_over;
X	PLAYER	*b_owner;
X	IDENT	*b_score;
X	FLAG	b_expl;
X	BULLET	*b_next;
X};
X
Xstruct expl_def {
X	int	e_x, e_y;
X	char	e_char;
X	EXPL	*e_next;
X};
X
Xstruct regen_def {
X	int	r_x, r_y;
X	REGEN	*r_next;
X};
X
X/*
X * external variables
X */
X
Xextern FLAG	Last_player;
X
Xextern char	Buf[BUFSIZ], Maze[HEIGHT][WIDTH2], Orig_maze[HEIGHT][WIDTH2];
X
Xextern char	*Sock_name, *Driver;
X
Xextern int	errno, Have_inp, Nplayer, Num_fds, Socket;
Xextern long	Fds_mask, Sock_mask;
X
X# ifdef INTERNET
Xextern int	Test_port;
Xextern int	Sock_port;
X# else INTERNET
Xextern char	*Sock_name;
X# endif INTERNET
X
X# ifdef VOLCANO
Xextern int	volcano;
X# endif	VOLCANO
X
Xextern int	See_over[NASCII];
X
Xextern BULLET	*Bullets;
X
Xextern EXPL	*Expl[EXPLEN];
X
Xextern IDENT	*Scores;
X
Xextern PLAYER	Player[MAXPL], *End_player;
X
X# ifdef MONITOR
Xextern FLAG	Am_monitor;
Xextern PLAYER	Monitor[MAXMON], *End_monitor;
X# endif MONITOR
X
X/*
X * function types
X */
X
Xchar	*getenv(), *malloc(), *strcpy(), *strncpy();
X
XIDENT	*get_ident();
X
Xint	moveshots();
X
XBULLET	*is_bullet(), *create_shot();
X
XPLAYER	*play_at();
X
X#ifdef DAEMON
X#define COLS 80
X#define LINES 24
X#endif DAEMON
X
X# endif _H_hunt
END_OF_FILE
if test 6817 -ne `wc -c <'hunt.h'`; then
    echo shar: \"'hunt.h'\" unpacked with wrong size!
fi
# end of 'hunt.h'
fi
if test -f 'playit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'playit.c'\"
else
echo shar: Extracting \"'playit.c'\" \(8542 characters\)
sed "s/^X//" >'playit.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1985 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that the above copyright notice and this paragraph are
X * duplicated in all such forms and that any documentation,
X * advertising materials, and other materials related to such
X * distribution and use acknowledge that the software was developed
X * by the University of California, Berkeley.  The name of the
X * University may not be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
Xstatic char sccsid[] = "@(#)playit.c	5.3 (Berkeley) 6/27/88";
X#endif /* not lint */
X
X/*
X *  Hunt
X *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold
X *  San Francisco, California
X */
X
X# include	<curses.h>
X# include	<ctype.h>
X# include	<signal.h>
X# include	<errno.h>
X# include	"hunt.h"
X# include	<sys/file.h>
X# include	<sys/time.h>
X# include	"player.h"
X
X
X#ifdef ROBOT
Xextern int daemon_player, robot_player;
X#endif ROBOT
X
Xint		input();
Xstatic int	nchar_send;
Xstatic int	in	= FREAD;
Xchar		screen[24][80], blanks[80];
Xint		cur_row, cur_col;
XFILE *inf;
X# ifdef OTTO
Xint		Otto_count;
Xint		Otto_mode;
Xstatic int	otto_y, otto_x;
Xstatic char	otto_face;
X# endif OTTO
X
X# define	MAX_SEND	5
X
X/*
X * ibuf is the input buffer used for the stream from the driver.
X * It is small because we do not check for user input when there
X * are characters in the input buffer.
X */
Xchar ibuf[20];
X
Xextern int		_putchar();
X
X/*
X * setup_to_play:
X *	Do final setup, so a human or robot can play.
X */
Xvoid
Xsetup_to_play()
X{
X	extern int		Master_pid;
X	extern int		errno;
X
X	errno = 0;
X	while ((inf = fdopen(Socket, "r")) == NULL)
X		if (errno == EINTR)
X			errno = 0;
X		else {
X			perror("fdopen of socket");
X			exit(1);
X		}
X	setbuffer(inf, ibuf, sizeof ibuf);
X	Master_pid = getw(inf);
X	if (Master_pid == 0 || Master_pid == EOF) {
X		bad_con();
X		/* NOTREACHED */
X	}
X}
X
X/*
X * playit:
X *	Play a given game, handling all the curses commands from
X *	the driver.
X */
Xplayit()
X{
X	register int		ch;
X	register unsigned int	y, x;
X
X# ifdef OTTO
X	Otto_count = 0;
X# endif OTTO
X	nchar_send = MAX_SEND;
X	while ((ch = GETCHR(inf)) != EOF) {
X# ifdef DEBUG
X		fputc(ch, stderr);
X# endif DEBUG
X		switch (ch & 0377) {
X		  case MOVE:
X			y = GETCHR(inf);
X			x = GETCHR(inf);
X			if (!daemon_player)
X			{
X				mvcur(cur_row, cur_col, y, x);
X			}
X			cur_row = y;
X			cur_col = x;
X			break;
X		  case ADDCH:
X			ch = GETCHR(inf);
X# ifdef OTTO
X			switch (ch) {
X
X			case '<':
X			case '>':
X			case '^':
X			case 'v':
X				otto_face = ch;
X				getyx(stdscr, otto_y, otto_x);
X				break;
X			}
X# endif OTTO
X			put_ch(ch);
X			break;
X		  case CLRTOEOL:
X			clear_eol();
X			break;
X		  case CLEAR:
X			clear_screen();
X			break;
X		  case REFRESH:
X			fflush(stdout);
X			break;
X		  case REDRAW:
X			redraw_screen();
X			fflush(stdout);
X			break;
X		  case ENDWIN:
X			fflush(stdout);
X			if ((ch = GETCHR(inf)) == LAST_PLAYER)
X				Last_player = TRUE;
X			ch = EOF;
X			goto out;
X		  case BELL:
X			if (!daemon_player)
X			{
X				putchar(CTRL(G));
X			}
X			break;
X
X		  case READY:
X			(void) fflush(stdout);
X			if (nchar_send < 0)
X				(void) ioctl(fileno(stdin), TIOCFLUSH, &in);
X			nchar_send = MAX_SEND;
X# ifndef OTTO
X			(void) GETCHR(inf);
X# else OTTO
X			Otto_count -= (GETCHR(inf) & 255);
X			if (!Am_monitor) {
X# ifdef DEBUG
X				fputc('0' + Otto_count, stderr);
X# endif DEBUG
X				if (Otto_count == 0 && Otto_mode)
X					otto(otto_y, otto_x, otto_face);
X			}
X# endif OTTO
X			break;
X		  default:
X# ifdef OTTO
X			switch (ch) {
X
X			case '<':
X			case '>':
X			case '^':
X			case 'v':
X				otto_face = ch;
X				getyx(stdscr, otto_y, otto_x);
X				break;
X			}
X# endif OTTO
X			put_ch(ch);
X			break;
X		}
X	}
Xout:
X	(void) fclose(inf);
X}
X
X/*
X * getchr:
X *	Grab input and pass it along to the driver
X *	Return any characters from the driver
X *	When this routine is called by GETCHR, we already know there are
X *	no characters in the input buffer.
X */
Xgetchr(fd)
Xregister FILE	*fd;
X{
X	long	nchar;
X	long	readfds, s_readfds;
X	int	driver_mask, stdin_mask;
X	int	nfds, s_nfds;
X	extern int	errno;
X
X	driver_mask = 1L << fileno(fd);
X	stdin_mask = 1L << fileno(stdin);
X	s_readfds = driver_mask;
X	if (!robot_player)
X		s_readfds |= stdin_mask;
X	s_nfds = (robot_player && driver_mask < stdin_mask)
X		? fileno(stdin) : fileno(fd);
X	s_nfds++;
X
Xone_more_time:
X	do {
X		errno = 0;
X		readfds = s_readfds;
X		nfds = s_nfds;
X# ifndef OLDIPC
X		nfds = select(nfds, &readfds, NULL, NULL, NULL);
X# else OLDIPC
X		nfds = select(nfds, &readfds, (int *) NULL, 32767);
X# endif OLDIPC
X	} while (nfds <= 0 && errno == EINTR && !robot_player);
X
X	if (!robot_player && !daemon_player)
X	{
X		if (readfds & stdin_mask)
X			send_stuff();
X	}
X	if ((readfds & driver_mask) == 0)
X	{
X		if (robot_player)
X			return READY;
X		else
X			goto one_more_time;
X	}
X	return _filbuf(fd);
X}
X
X/*
X * send_stuff:
X *	Send standard input characters to the driver
X */
Xsend_stuff()
X{
X	register int	count;
X	register char	*sp, *nsp;
X	static char	inp[sizeof Buf];
X	extern char	map_key[256];
X
X	count = read(fileno(stdin), Buf, sizeof Buf);
X	if (count <= 0)
X		return;
X	if (nchar_send <= 0) {
X		(void) write(1, "\7", 1);
X		return;
X	}
X
X	/*
X	 * look for 'q'uit commands; if we find one,
X	 * confirm it.  If it is not confirmed, strip
X	 * it out of the input
X	 */
X	Buf[count] = '\0';
X	nsp = inp;
X	for (sp = Buf; *sp != '\0'; sp++)
X		if ((*nsp = map_key[*sp]) == 'q')
X			intr();
X# ifdef OTTO
X		else if (*nsp == CTRL(O))
X			Otto_mode = !Otto_mode;
X# endif OTTO
X		else
X			nsp++;
X	count = nsp - inp;
X	if (count) {
X# ifdef OTTO
X		Otto_count += count;
X# endif OTTO
X		nchar_send -= count;
X		if (nchar_send < 0)
X			count += nchar_send;
X		(void) write(Socket, inp, count);
X	}
X}
X
X/*
X * quit:
X *	Handle the end of the game when the player dies
X */
Xquit()
X{
X	register int	explain, ch;
X
X	if (Last_player)
X		return TRUE;
X# ifdef OTTO
X	if (Otto_mode)
X		return FALSE;
X# endif OTTO
X	if (!daemon_player)
X	{
X		mvcur(cur_row, cur_col, HEIGHT, 0);
X	}
X	cur_row = HEIGHT;
X	cur_col = 0;
X	put_str("Re-enter game? ");
X	clear_eol();
X	fflush(stdout);
X	explain = FALSE;
X	for (;;) {
X		if (isupper(ch = getchar()))
X			ch = tolower(ch);
X		if (ch == 'y') {
X			sleep(2);
X			return FALSE;
X		}
X		else if (ch == 'n')
X			return TRUE;
X		(void) putchar(CTRL(G));
X		if (!explain) {
X			put_str("(Y or N) ");
X			explain = TRUE;
X		}
X		fflush(stdout);
X	}
X}
X
Xput_ch(ch)
X	char	ch;
X{
X	if (!isprint(ch)) {
X# ifdef DEBUG
X		fprintf(stderr, "r,c,ch: %d,%d,%d", cur_row, cur_col, ch);
X# endif DEBUG
X		return;
X	}
X	screen[cur_row][cur_col] = ch;
X	if (!daemon_player)
X	{
X		putchar(ch);
X	}
X	if (++cur_col >= COLS) {
X	if (!daemon_player)
X	{
X		if (!AM || XN)
X			putchar('\n');
X	}
X		cur_col = 0;
X		if (++cur_row >= LINES)
X			cur_row = LINES;
X	}
X}
X
Xput_str(s)
X	char	*s;
X{
X	while (*s)
X		put_ch(*s++);
X}
X
Xclear_screen()
X{
X	register int	i;
X
X	if (blanks[0] == '\0')
X		for (i = 0; i < 80; i++)
X			blanks[i] = ' ';
X
X	if (!daemon_player && CL != NULL)
X		tputs(CL, LINES, _putchar);
X	if (daemon_player || CL != NULL) {
X		for (i = 0; i < 24; i++)
X			bcopy(blanks, screen[i], 80);
X	}
X	if (!daemon_player && CL != NULL) {
X		for (i = 0; i < 24; i++) {
X			mvcur(cur_row, cur_col, 0, 0);
X			cur_row = i;
X			cur_col = 0;
X			clear_eol();
X		}
X		mvcur(cur_row, cur_col, 0, 0);
X	}
X	cur_row = cur_col = 0;
X}
X
Xclear_eol()
X{
X	if (!daemon_player)
X	{
X		if (CE != NULL)
X			tputs(CE, 1, _putchar);
X		else {
X			fwrite(blanks, sizeof (char), 80 - cur_col, stdout);
X			if (COLS != 80)
X				mvcur(cur_row, 80, cur_row, cur_col);
X			else if (AM)
X				mvcur(cur_row + 1, 0, cur_row, cur_col);
X			else
X				mvcur(cur_row, 79, cur_row, cur_col);
X		}
X	}
X
X	bcopy(blanks, &screen[cur_row][cur_col], 80 - cur_col);
X}
X
Xredraw_screen()
X{
X	if (!daemon_player)
X	{
X		register int	i;
X		static int	first = 1;
X
X		if (first) {
X			if ((curscr = newwin(24, 80, 0, 0)) == NULL) {
X				fprintf(stderr, "Can't create curscr\n");
X				exit(1);
X			}
X			for (i = 0; i < 24; i++)
X				curscr->_y[i] = screen[i];
X			first = 0;
X		}
X		curscr->_cury = cur_row;
X		curscr->_curx = cur_col;
X		wrefresh(curscr);
X#ifdef	NOCURSES
X		mvcur(cur_row, cur_col, 0, 0);
X		for (i = 0; i < 23; i++) {
X			fwrite(screen[i], sizeof (char), 80, stdout);
X			if (COLS > 80 || (COLS == 80 && !AM))
X				putchar('\n');
X		}
X		fwrite(screen[23], sizeof (char), 79, stdout);
X		mvcur(23, 79, cur_row, cur_col);
X#endif
X	}
X}
END_OF_FILE
if test 8542 -ne `wc -c <'playit.c'`; then
    echo shar: \"'playit.c'\" unpacked with wrong size!
fi
# end of 'playit.c'
fi
echo shar: End of archive 3 \(of 4\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
