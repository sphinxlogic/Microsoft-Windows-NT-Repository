Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v15i037:  dinkum2 - australian text adventure game, Part02/07
Message-ID: <4193@master.CNA.TEK.COM>
Date: 14 Jan 93 03:25:43 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1779
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1536

Submitted-by: Gary Allen <gary@sun.mech.uq.oz.au>
Posting-number: Volume 15, Issue 37
Archive-name: dinkum2/Part02
Supersedes: dinkum: Volume 15, Issue 21-26
Environment: Unix, DOS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 7)."
# Contents:  dinkum.c pusher.c
# Wrapped by billr@saab on Wed Jan 13 19:20:18 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dinkum.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dinkum.c'\"
else
echo shar: Extracting \"'dinkum.c'\" \(32399 characters\)
sed "s/^X//" >'dinkum.c' <<'END_OF_FILE'
X#define DINKUM.C
X#include "dink_sym.h"
X#include "dink_glb.h"
X#include <stdlib.h>
X#define Failed		0
X#define Request		1
X
X/* ---------------- Version Date --------------- */
Xchar *lb_date = "5 January 1993" ;
X/* --------------------------------------------- */
X
X/*  ---- Version Number  ---- */
Xchar *lb_version = "2.3" ;
X/*  ------------------------- */
X
X/* ---------------- Version Type --------------- */
Xchar *lb_share = "[GAMES.SOURCES Version]" ;
X/* --------------------------------------------- */
X
X/*  ---- Serial Number  ---- */
X#define S_number 	1
Xint serial = S_number ;
X/*  ------------------------ */
X 
X/* Global variables local to this file only */
Xint sw_help = FALSE, sw_null = FALSE, sw_number = FALSE, sw_standard = FALSE ;
X
X/* MAIN PROGRAM --- MAIN PROGRAM --- MAIN PROGRAM --- MAIN PROGRAM */
Xvoid main(argc,argv)
X/*********************************************************************/
X/*                                                                   */
X/*                   --- The Dinkum Program ---                      */
X/*                                                                   */
X/* Software by Gary A. Allen, Jr.  5 January 1993   Version: Mk 2.3  */
X/*            (c) Copyright 1993 by Gary A. Allen, Jr.               */
X/*                                                                   */
X/*********************************************************************/
X
Xint argc ;
Xchar *argv[] ;
X{
Xregister int i, j ;
X
Xint dig_1, dig_2, sw_loop ;
Xint pnt, i_rand1, i_rand2, i_rand3, loc[3] ;
Xlong l_pass, l_time, l_base, start_time, *time_arg = 0 ;
Xchar chr, cmd[8] ;
X
Xstruct monster_struct *mnstr ;
X
X#if (PROTOTYPE)
X/* Function prototypes */
Xvoid cmd_switch(char[8], int, int, char *[]) ;
Xvoid bugs(int), help(void) ;
Xvoid kelly(int), long_descp(int), objlooker(int), killer(int) ;
Xvoid gleeper(int), actor(int), ender(int), closer(int), opener(int) ;
Xvoid dialer(int), taker(int), dropper(int), describe(int) ;
Xvoid igniter(int), switcher(int), unlocker(int), sounder(int) ;
Xvoid loader(void), eater(void), filler(void), looker(int), exit(int) ;
Xvoid monster(int[3]), new_score(void), boom(void), parse(void) ;
Xint mover(int,int[3]) ; 
Xvoid inventer(void), drinker(void), reader(int), pusher(int*);
Xvoid cheater(void) ; 
Xvoid pass(void), unloader(int) ;
Xlong time(long*) ;
Xchar getch(void), getche(void) ;
X#endif
X
X/* Software security */
Xif (serial != S_number) exit(0) ;  /* abort if serial number changed */
X
X/* Scan the after the DOS/Unix command for switches or file name */
Xif (argc > 1) {
Xfor (i = 1; i <= argc-1; i++) {
X	/* Flush command vector */
X	for (j = 0; j <= 7; j++) cmd[j] = '\0' ;
X	/* Get command vector */
X	sscanf(argv[i],"%c%c%c%c%c%c%c%c%c", &chr, &cmd[0], &cmd[1],
X		&cmd[2], &cmd[3], &cmd[4], &cmd[5], &cmd[6], &cmd[7]) ;
X	sw_null = FALSE ;
X	if (chr == '?') help() ;
X	if (chr == '-') {
X		for (j = 0; j <= 7; j++) {
X			cmd_switch(cmd, j, i, argv) ;
X			if (sw_number) {
X				i++ ;
X				sw_number = FALSE ;
X				break ;
X			}
X			if (sw_null) break ;
X		} /* end of command "for" loop */
X
X		if (j > 7) {
Xprintf("\n!!!! Too many commands on one \"-\" switch group.\n") ;
Xprintf("!!!! Break up the commands into several \"-\" switch groups.\n") ;
X			bugs(Failed) ;
X		}  
X	} /* end of the "-" marker block */
X
X	/* Deal with garbage on the command line */
X	else {
Xprintf ("\n!!!! The following on the command line was not understood:  %s \n",
X	argv[i]);
X		bugs(Failed) ;
X	} /* Nondefault scratch file opening block */
X
X} /* end of argument token "for" loop */
X
Xif (sw_help) help() ;
X} /* end of the command switch block */
X
X/* Deal with someone cheating with switch "-s" */
Xif (sw_standard && (!sw_wizard)) {
X	printf("!!!! Command line switch -s is unknown.\n") ;
X	bugs(Failed) ;
X}
X 
X/* Software security */
Xif (serial != S_number) exit(0) ;  /* abort if serial number changed */
X
X/* Initialize the program */
Xsw_warned = FALSE ;
Xl_time = time(time_arg) ;
Xl_base = l_time/10 ;
Xl_base *= 10 ;
Xl_pass = l_time - l_base ;
Xdig_1 = (int)l_pass ;
Xloc[2] = 0 ; 	/* zero out the "old" location */
X
Xprintf("                    ") ;
Xprintf("                   --- Dinkum --- \n");
Xprintf("                    ") ;
Xprintf("     (c) Copyright 1993 by Gary A. Allen, Jr.\n") ;
Xprintf("                    ") ;
Xprintf("  All Rights Reserved. Version %s, %s\n\n",
X	lb_version, lb_date);
X
Xprintf("Would like some initial help with Dinkum?\n") ;
X
Xfor (;;) {
X
X#ifndef __TURBOC__
X	do {
X		printf("(Answer:  Yes or No) ") ; 
X	} while ('\n' == (chr = getchar())) ;
X
X	while ('\n' != getchar()) ;
X#endif
X
X#ifdef __TURBOC__
X	printf("\n") ;
X	do {
X		printf("(Answer:  Yes or No) ") ; 
X	} while ('\n' == (chr = getch())) ;
X	printf("\n") ;
X#endif
X
X	if (('n' == chr)||('N' == chr)||('y' == chr)||('Y' == chr)) {
X		if (('y' == chr)||('Y' == chr)) {
Xprintf("\nG'day Mate!  Welcome to \"Dinkum\" the Australian adventure");
Xprintf("\ngame.  In Dinkum you'll search for treasure in the\n") ;
Xprintf("Australian Outback.  You give the commands and I'll do the\n");
Xprintf("dangerous work. I understand most plain English sentences.\n");
Xprintf("If you want me to go east then type \"Will you please go\n");
Xprintf("east?\" and press the RETURN or ENTER key.  If you don't\n") ;
Xprintf("enjoy typing then just type \"e\" and press RETURN.  I'll\n");
Xprintf("still go east.  After you have gathered up some things\n") ;
Xprintf("you can see what you have by typing \"inventory\".\n") ;
Xprintf("Sometimes you can learn more about an object by typing\n");
Xprintf("\"examine NAME-OF-OBJECT\".  I understand many other\n") ;
Xprintf("commands and words.  However I'll let you have the fun of\n") ;
Xprintf("finding out what I can and can not understand. Good luck!\n\n");
X		}
X		break ;
X	}
X}
X
X/* produce two random numbers ranging from 0-9 based on system clock*/
Xl_time = time(time_arg) ;
Xstart_time = l_time ;
Xl_base = l_time/10 ;
Xl_base *= 10 ;
Xl_pass = l_time - l_base ;
Xdig_2 = (int)l_pass ;
X
X/* generate the actual random array pointers */
Xif (sw_standard) {
X	i_rand1 = 2 ; 
X	i_rand2 = 3 ;
X	i_rand3 = 1 ;
X}
Xelse {
X	i_rand3 = (dig_1 + dig_2)/2 ;
X	i_rand2 = dig_2/3 ;
X	i_rand1 = (dig_1/3) + 1 ;
X}
X
Xprintf("\nIt's a hot summer day (in January) in ") ;
Xprintf("Queensland, Australia.\n") ;
Xloc[1] = R_meadow ;
Xloc[0] = R_meadow ;
X
X/* Software security */
Xif (serial != S_number) exit(0) ;  /* abort if serial number changed */
X
X/* load objects into the rooms */
Xfor (i = 0; i <= obj_init_max; i++) 
X	object[obj_init[i][0]][J_loc] = obj_init[i][i_rand1] ;
X
Xif (sw_script) object[O_recorder][J_loc] = R_meadow ;
X
Xcarry_count = 0 ;
Xcarry_weight = 0 ;
X
Xfor (i = 0; i <= objcnt; i++) {
X	j = object[i][J_loc] ;
X	if ((j >= 0) && (object[i][J_type] != Z_unmovable))
X		 ++room[j][M_obj_cnt] ;
X}
X
X/* Initialize the Monsters */
Xif ((monster_start = (struct monster_struct *)calloc((unsigned)(enemy_max+1),
X		sizeof(struct monster_struct))) == 0) {
X	printf("\n---- PROBLEMS ----\n") ;
X	printf("RAM memory is full!\n") ; 
X	printf(" PROGRAM ABORTED\n") ;
X	exit(0) ;
X}
X
XNed = (monster_start + N_ned) ;        /* point to the Ned Kelly structure */
XGuards = (monster_start + N_guards) ;  /* point to the Guards structure */
XWombat = (monster_start + N_wombat) ;  /* point to the Wombat structure */
XMullah = (monster_start + N_mullah) ;  /* point to the Mullah structure */
X
X/* Load up the monster data structure */
Xfor (i = 0; i <= enemy_max; i++) { 
X	mnstr = (monster_start + i) ; 	/* point to the monster */
X
X 	/* locate the monster */
X	if (i == 0) mnstr->Location = B_unmade ;
X	else mnstr->Location = mon_init[i-1][i_rand2] ;
X
X	/* All monsters are initially asleep */
X	mnstr->Status = F_asleep ;
X
X	/* Load Type numbers for the different monsters */
X	switch(i) {
X	case 2:
X	case 3:
X	case 4:
X	case 5:
X		mnstr->Type = N_drop_bear ;
X		break ;
X	case 6:
X	case 7:
X	case 8:
X	case 9:
X	case 10:
X	case 11:
X	case 12:
X	case 13:
X		mnstr->Type = N_hoop_snake ;
X		break ;
X	default:
X		mnstr->Type = i ;
X	} /* end of the monster Type switch block */
X
X	/* Monsters are initially healthy */
X	mnstr->Hits = 0 ;	
X
X	j = mnstr->Location ;
X	if (j != B_unmade) ++room[j][M_monster] ;
X} /* end of the monster data structure loadup "for" loop */
X 
X/* load the gleep reproductive locations and seed gleep */
Xfor (i = 0; i <= 9; i++)  
X	gleep_spot[i] = gleep_init[i][i_rand2] ;
Xroom[gleep_spot[0]-1][M_gleep] = 1 ; /* seed a nonreproductive spot */ 
X
X/* load safe passage for end-game killing passages  */
Xroom[218 + i_rand3][M_rm_type] = T_short_descp ;
X
X/* Beginning of outer infinite "for" loop */
Xfor(;;) {
X/* special action routine */
Xnew_score() ;  /* update the score */
X
X/* See if the game has timed out */
Xl_time = time(time_arg) ;
Xif ((!sw_warned) && (l_time > start_time + 3300)) {
X	sw_warned = TRUE ;
X	start_time = l_time ;
Xprintf("There's suddenly a puff of blue smoke which fills the room\n") ;
Xprintf("with a hazy cloud.  Slowly this cloud coalesces into a\n") ;
Xprintf("ghostly human form.  This ethereal being is wearing a grey\n") ;
Xprintf("flannel suit, a bowler hat, and glancing at a gold pocket\n") ;
Xprintf("watch which is attached to a long golden chain.  You can\n");
Xprintf("hear \"Waltzing Matilda\" being played softly in the\n") ;
Xprintf("background.  You know what?  I think this ethereal being\n") ;
Xprintf("is none other than the ghost of Banjo Patterson!  With\n") ;
Xprintf("this realization Banjo looks up in your direction and\n") ;
Xprintf("begins to speak:\n\n") ;
Xprintf("\"Sorry mate, you've been at this for too long!  You've\n") ;
Xprintf("got five more minutes to go and then you're history!\"\n\n") ;
Xprintf("Then just as suddenly Banjo Patterson dissolves back into\n") ;
Xprintf("smoke and disappears from view.\n\n") ;
X}
Xif (sw_warned && (l_time > start_time + 300)) {
Xprintf("You hear someone clearing his throat behind you.  You turn\n") ;
Xprintf("around and see Banjo Patterson has appeared once again.  An\n");
Xprintf("old brass chain is hanging from mid air next to Banjo.  On\n") ;
Xprintf("the end of the chain is a white porcelain tear drop shaped\n");
Xprintf("nob with the word \"PULL\" written on it in black letters.\n") ;
Xprintf("Banjo reaches for the nob and says the following:\n\n\"Sorry") ;
Xprintf(" mate, your time has come!  Better luck next time!\"\n\n");
Xprintf("He gives the chain a quick jerk and everything around you\n") ;
Xprintf("slowly fades from view.\n\n") ;
X	ender(F_quit) ;
X}
X
Xkelly(loc[0]) ; /* check if Ned Kelly can do something */
X 
X/* Check if there is a long description */
Xif ((!((room[R_hideout][M_monster] > 0) && (loc[0] == R_hideout))) &&
X	(!((monster_flag == F_monster_active) && (loc[2] == loc[0])))) {
X
X	loc[2] = 0 ;
X
X/* Check if there is to be a long room description */
Xif (room[loc[0]][M_rm_type] == T_long_descp) long_descp(loc[0]) ;
Xelse {
X	describe(loc[0]) ;  /* short description */
X
X	/* describe unmovable action objects and status */
X	if (room[loc[0]][M_rm_type] == T_action_obj) actor(loc[0]) ;
X}
X
Xobjlooker(loc[0]) ; /* Check if there are objects in the room */
Xgleeper(loc[0]) ;   /* check for gleeps and update the gleep count */
X
X/* see if the spaceship's transporter is active */
Xif (sw_transport) {
X	if (loc[0] == R_ship_passage) sw_transport = FALSE ;
X	else if (loc[0] == R_transport) {
X		loc[0] = R_closet ;
X		sw_transport = FALSE ;
Xprintf("\nSuddenly radiant energy seems to surge from the hexagons\n");
Xprintf("around you.  Then there is a bright flash and you find\n");
Xprintf("yourself in.....\n\n") ;
Xprintf("A closet stinking of moth balls full of nondescript junk.\n") ;
Xprintf("The only exit is to the north through a curtain hanging\n");
Xprintf("over the entrance.\n\n") ; 
X	}
X} /* end of the "transporter" block */
X} /* end of long description check block */
X
Xfor(;;) {
Xsw_loop = FALSE ;
X
X/* monster check */
Xif ((room[loc[0]][M_monster] > 0)||(monster_flag != F_no_monster)) {
X	if (monster_flag == F_wounded) monster_flag = F_monster_active ;
X	else monster(loc) ;
X} /* end of the monster check block */
X
X/* parse in the command */
Xparse();
X
X/* poison check */
X/* remove atropine drug with each game cycle */
Xif (i_poison > 0) --i_poison ;
Xelse {
X	/* accumulate poison if holding the orange clip */
X	if (object[O_org_clip][J_loc] == B_have) {
X		--i_poison ;
X		switch (i_poison) {
X		case -20:
X	printf("You've developed a nervous tick near your eye.\n") ;
X			break ;
X		case -30:
X	printf("You're hands are starting to shake ") ;
X	printf("and you're sweating like a pig.\n") ;	
X			break ;
X		case -35:
X	printf("You're shaking so bad you can barely stand and you ");
X	printf("could lose your lunch\nat any moment.\n") ;
X			break ;
X		case -40:
Xprintf("The toxic fumes coming off of the orange ammo clip you were ") ;
Xprintf("carrying finally\ncaught up with you.  You fall over DEAD!\n") ;
X			ender(F_died) ;
X		}
X	}
X	/* remove poison after release of orange clip */
X	else if (i_poison < 0) ++i_poison ;
X} /* end of the poison check block */
X
X/* clock check */
Xif (sw_clock) {
X	switch (flag_clock) {
X	/* see if the blasting cap is to explode */
X	case V_cap:
X		if (time(time_arg) > clock_explode) {
X			if (object[O_cap][J_loc] == B_have) {
Xprintf("                           POP!!\n") ;
Xprintf("The blasting cap which you were stupidly holding in your\n") ;
Xprintf("hand just blew up and took two of your fingers with it!\n") ;
Xprintf("Good thing you've got another eight fingers to spare!\n\n") ;
X				carry_count-- ;
X				carry_weight -= object[O_cap][J_weight];
X			}
X			else {
Xprintf("Far down the tunnel you hear a POP!\n") ;
Xprintf("The blasting cap has finally exploded, not that it\n");
Xprintf("achieved much except make a loud noise.\n\n") ;
X			}
X			object[O_cap][J_loc] = B_destroyed ;
X			sw_clock = FALSE ;
X		}
X		break ;
X	
X	/* see if the dynamite is to explode */
X	case V_dynamite:
X		if (time(time_arg) > clock_explode) {
X			/* player dies if he is holding the dynamite */
X			if (object[O_dynamite][J_loc] == B_have) {
X			boom() ;
X
Xprintf("The dynamite which you were holding and had earlier ignited\n");
Xprintf("the fuse has finally exploded.  That was a rather noisy\n");
Xprintf("and messy way to commit suicide!  Needless to say there is\n");
Xprintf("nothing left of you but a greasy spot.\n") ;
X			ender(F_died) ;
X			}
X			/* player dies if too close during explosion */
X			else {
X				if (((loc[0] <= 185) && (loc[0] >= 178))
X				  || ((loc[0] <= 170) && (loc[0] >= 166))) {
X					boom() ;
X
Xprintf("You weren't far enough away from the dynamite when it\n");
Xprintf("exploded!  The shock wave was still strong enough to blow\n");
Xprintf("your brains out your ears.  Next time try to get to the\n") ;
Xprintf("upper level before the dynamite goes off.\n") ;
X					ender(F_died) ;
X				}
X
X				/* dynamite explodes and player survives */
X				else {
Xprintf("Far down the tunnel you hear a low BOOM!\n") ;
Xprintf("That dynamite you set burning has finally exploded.\n\n");
X
X/* open up the passage to the UFO */
Xif (object[O_dynamite][J_loc] == R_blast_point) {
X	room[R_blast_point][1] = 186 ;
X	room[R_blast_point][M_descp] = 55 ;
X					}
X				}
X			}
X			object[O_dynamite][J_loc] = B_destroyed ;
X			sw_clock = FALSE ;
X		} /* end of the dynamite explodes block */
X		break ;
X	}
X} /* end of the clock block */
X
X/* the command is a simple move command */
Xif (tag[V_MOVE]) {
X	if (mover(verb,loc)) break ;
X	continue ;
X} /* end of the "move" block */
X
X/* complicated command decoder */
Xswitch (verb) {
X 
X/* "help" command */
Xcase V_help:
Xcase V_info:
Xprintf("There is no help available.  You're on your own!\n") ;
X	break ;
X 
X/* "quit" command */
Xcase V_quit:
X	ender(F_quit) ;
X
X/* "question" command */
Xcase V_QUESTION:
X	if (tag[V_VERB_ONLY]) {
X		if (tag[V_how]) {
Xprintf("That's for you to figure out.\n") ;
X			break ;
X		}
Xprintf("I don't have a clue!\n") ;
X		break ;
X	}
X
X	/* Question "Where am I?" */
X	if (tag[V_where] && tag[V_am]) {
X		tag[V_VERB_ONLY] = TRUE ; /* This is for "looker" */
X		looker(loc[0]) ;
X		break ;
X	}
X
X	/* Question "What have I got?" */
X	if (tag[V_what] && tag[V_have]) {
X		inventer() ;
X		break ;
X	}
X
X	/* Question which can't be processed */
Xprintf("You asked a question.  Unfortunately I have no answers.\n") ;
X	break ;
X
X/* "inventory" command */
Xcase V_inventory: 
Xcase V_invent:
X	inventer() ;
X	break;
X
X/* "close" command  */
Xcase V_close:
Xcase V_shut:
X	closer(loc[0]) ;
X	break;
X
X/* "open" command  */
Xcase V_open:
Xcase V_swing:
X	opener(loc[0]) ;
X	break;
X
X/* "dial" command  */
Xcase V_dial:
Xcase V_combination:
X	dialer(loc[0]) ;
X	break ;
X 
X/* "drink" command */
Xcase V_drink: 
X	drinker() ;
X	break ;
X
X/* "ignite" command */
Xcase V_ignite: 
Xcase V_light: 
X	igniter(loc[0]) ;
X	break ;
X
X/* "read" command  */
Xcase V_read:
X	reader(loc[0]) ;
X	break;
X 
X/* "push" command  */
Xcase V_push:
Xcase V_press:
X	pusher(&loc[0]) ; 
X	break ;
X 
X/* "turn", "switch" command */
Xcase V_switch:
Xcase V_turn:
Xcase V_select:
Xcase V_set:
X	switcher(loc[0]) ;
X	break ;
X 
X/* "shoot" command  */
Xcase V_shoot:
Xcase V_fire:
Xcase V_kill:
X	killer(loc[0]) ;
X	break;
X 
X/* "unlock" command  */
Xcase V_unlock:
X	unlocker(loc[0]) ;
X	break;
X 
X/* "eat" command  */
Xcase V_eat:
Xcase V_swallow:
X	eater() ;
X	break;
X 
X/* "fill" command  */
Xcase V_fill:
X	filler() ;
X	break;
X 
X/* "sound" command  */
Xcase V_sound:
Xcase V_bang:
Xcase V_hit:
Xcase V_strike:
X	sounder(loc[0]) ;
X	break;
X
X/* "SVC" wizard move command */
Xcase V_svc:
X	if (sw_wizard) {
X		printf ("Enter room coordinate number:  ");
X		scanf ("%d",&loc[0]);
X		sw_loop = TRUE ;
X		break ;
X	}
X	else cheater() ;
X
X/* "STATS" game statistics */
Xcase V_stats :
X		printf("      --- Dinkum --- \n");
X		printf("Version: %s, %s\n\n", lb_version, lb_date);
X		printf("i_rand1 = %d, i_rand2 = %d, i_rand3 = %d\n",
X			i_rand1, i_rand2, i_rand3) ;
X		printf("Room Number = %d\n", loc[0]) ;
X		printf("Room object count = %d \n",
X			room[loc[0]][M_obj_cnt]) ;
X		printf("Room monster count = %d\n",
X			room[loc[0]][M_monster]) ; 
X		printf("Gleeps on room's floor count = %d\n",
X			room[loc[0]][M_gleep]) ;
X		printf("Poison level = %d\n",i_poison) ;
X		printf("Gleep count = %d\n", gleep_count) ;
X		printf("carry_count = %d, carry_weight = %d\n",
X			carry_count, carry_weight) ;
X		break ;
X
X/* "SU" wizard initiation command */
Xcase V_su:
X	pass() ;
X	break ;
X
X/* "JSYS" wizard command which deactivates a monster */
Xcase V_jsys:
X	if (sw_wizard) monster_flag = F_no_monster ;
X	else cheater() ;
X	break ;
X
X/* "score" command */
Xcase V_score: 
X	new_score() ;
X	if ((gleep_score == 0)&&(score == 0)) {
Xprintf("You haven't scored anything at all, Bozo! Try putting\n");
Xprintf("a valuable into the safe or find some gleeps.\n") ;
X		break ;
X	}
X	if (score == 0) { 
X		if (gleep_score > 1) {
Xprintf("You haven't scored any points but you splashed ") ;
Xprintf ("%d gleeps into the gleep tank.\n",gleep_score) ;
X		}
X		else {
Xprintf("You haven't scored any points at all but you did put a\n");
Xprintf ("gleep in the gleep tank (big deal!).\n") ;
X		}
X	}
X	else {
Xprintf ("You scored %d points ",score) ;
X		if (gleep_score == 0) 
Xprintf ("but have yet to put any gleeps in the gleep tank.\n") ;
X		else {
X			if (gleep_score > 1) 
Xprintf ("and put %d gleeps into the gleep tank.\n",gleep_score) ;
X	
X			else 
Xprintf ("and put a gleep in the gleep tank.\n") ;
X		}
X	}
X	break ;
X 
X/* "enter" command  */
Xcase V_enter:
Xswitch (loc[0]) {
X 
X	/* Lift entrance at the ground level */
X	case R_lift_entr:
X		if (room[R_lift_entr][2] == R_wall) {
Xprintf("I can't do it!  The lift door needs to be opened.\n") ;
X			continue ;
X		}
X		pnt = V_east ;
X		break ;
X	/* office door */
X	case R_office_entr:
X		if (room[R_office_entr][2] == R_wall) {
Xprintf("I can't go in!  The office door needs to be opened.\n") ;
X			continue ;
X		}
X		pnt = V_east ;
X		break ;
X	/* Lift entrance at level #49 */
X	case R_L49_entr:
X		pnt = V_east ;
X		break ;
X	/* Entrance to Ned Kelly's hideout */
X	case R_hideout_entr:
X		pnt = V_east ;
X		break ;
X
X	/* Enter gleep tank (and suicide) */
X	case R_gleep_tank:
X		if (tag[V_tank]) {
Xprintf("\nYou climb up onto the edge of the gleep tank and dip your\n");
Xprintf("foot into the dark blue fluid.  Suddenly the fluid begins a\n");
Xprintf("furious boiling that instantly reduces your foot into\n") ;
Xprintf("bleached white bones.  The shock and pain disturbs your\n");
Xprintf("balance and you fall into the horrible stuff!!  There is\n");
Xprintf("once again a furious boiling.  Eventually the fluid stills\n");
Xprintf("and becomes clear again.  On the bottom of the tank can\n") ;
Xprintf("be seen a white, clean, \"medical school quality\" human\n");
Xprintf("skeleton.\n") ;
X			ender(F_died) ;
X		}
X 
X	default:
X	printf("I don't understand exactly how to enter. \n");
X		continue ;
X} /* end of the "enter" switch block */
Xif (mover(pnt,loc)) sw_loop = TRUE ;
Xbreak ;
X
X/* "exit" command  */
Xcase V_exit:
Xcase V_leave:
Xcase V_depart:
Xswitch (loc[0]) {
X 
X	/* Lift entrance at the ground level */
X	case R_lift_inside:
X		pnt = V_west ;
X		break ;
X	/* office door */
X	case R_office_hall:
X		pnt = V_west ;
X		break ;
X	/* Ned Kelly's hideout */
X	case R_hideout :
X		pnt = V_west ;
X		break ;
X	default:
Xprintf("I don't understand exactly how you want to exit.\n");
X		continue ;
X} /* end of the "depart" switch block */
Xif (mover(pnt,loc)) sw_loop = TRUE ;
Xbreak ;
X
X/* "dig" command */
Xcase V_dig:
Xprintf("You get on your knees and scrape away at the ground for\n") ;
Xprintf("awhile. Except for getting your hands dirty you didn't\n") ;
Xprintf("achieve much.\n") ;
X	break ;
X
X/* "stand" command */
Xcase V_stand:
Xprintf("You're standing there very nicely.  However you're not\n");
Xprintf("achieving much by doing so.\n") ;
X	break ;
X
X/* "load" rifle command */
Xcase V_load:
X	loader() ;
X	break ;
X
X/* "unload" rifle command */
Xcase V_unload:
X	unloader(loc[0]) ;
X	break ;
X
X/* "pull" command */
Xcase V_pull:
X	if (tag[V_trigger]) {
X		/* alias in the "shoot" command */
X		verb = V_shoot ;
X		tag[V_VERB_ONLY] = TRUE ;
X		killer(loc[0]) ;   /* "pull trigger" */
X	}
X	else  printf("I don't see how I could pull that.\n") ;
X	break ;
X
X/* "climb" command */
Xcase V_climb:
Xprintf("I'm not climbing anything!  (I'm afraid of heights.)\n") ;
X	break ;
X
X/* "swim" command */
Xcase V_swim:
Xprintf("I'm not going for a swim!  (I'm afraid of the water.)\n") ;
X	break ;
X
X/* Go backwards to previous location */
Xcase V_back:
X	loc[0] = loc[1] ;
X	sw_loop = TRUE ;
X	break ;
X 
X/* "take", "get", "lift" command */
Xcase V_take:
Xcase V_get:
Xcase V_lift:
Xcase V_pick:
Xcase V_grab:
Xcase V_remove:
Xcase V_attach:
Xcase V_hold:
X	taker(loc[0]) ;
X	break ;
X 
X/* "drop", "throw", "put" command */
Xcase V_drop:
Xcase V_throw:
Xcase V_put:
Xcase V_fling:
Xcase V_insert:
Xcase V_give:
Xcase V_eject:
Xcase V_slow_drop:
X	dropper(loc[0]) ;
X	break ;
X
X/* "look" command */
Xcase V_look:
Xcase V_l:
Xcase V_examine:
Xcase V_describe:
X	looker(loc[0]) ;
X	break;
X
X/* gibberish command */
Xdefault:
Xprintf("Huh?  You will have to make yourself clearer! \n");
X
X} /* end of "decoder" switch */
Xif (sw_loop) break ;
X} /* end of the inner infinite "for" loop */
X} /* end of the outer infinite "for" loop */
X
X} /* --- end of Main routine --- */
X
Xvoid cmd_switch(cmd, cmd_arg, i_point, argv)
X/*****************************************************/
X/*                                                   */
X/*         --- Command line Switch Parser ---        */
X/*                                                   */
X/*  (c) Copyright 1992,   University of Queensland   */
X/*        Program written by Gary A. Allen, Jr.      */
X/*           Version:  Mk 1.1   24 February 1992     */
X/*                                                   */
X/*****************************************************/
X
Xchar cmd[8], *argv[] ;
Xint cmd_arg, i_point ;
X{
X
X#if (PROTOTYPE)
Xvoid bugs(int)  ;
X#endif
X
Xswitch (cmd[cmd_arg]) {
Xcase '\0':
Xcase -1:
X	sw_null = TRUE ;
X	return ;
X
X/* Activate save script capability */
Xcase 's':
Xcase 'S':
X	sw_script = TRUE ;
X	break ;
X
X/* Version verification command switch */
Xcase 'v':
X	if ((cmd[cmd_arg+1] == 'e')&&(cmd[cmd_arg+2] == 'r')) {
X		printf("Version: %s, Serial Number: %06d %s \n", 
X			lb_version, serial, lb_share) ;
X		bugs(Request) ;
X	}
X	else {
X		printf("!!!! Command line switch -v is unknown.\n") ;
X		bugs(Failed) ;
X	}
X
X/* Wizard mode command switch */
Xcase 'w':
Xcase 'W':
X	pass() ;
X	break ;
X
X/* Standard matrix load command switch */
Xcase 'x':
Xcase 'X':
X	sw_standard = TRUE ;
X	break ;
X
X/* Rubbish option to supress a warning */
Xcase 'y':
Xcase 'Y':
X	sw_number = TRUE ;
X	printf("y = %d\n", atoi(argv[i_point+1])) ;
X	return ;
X
X/* Help option */
Xcase '?':
Xcase 'h':
Xcase 'H':
X	sw_help = TRUE ;
X	return ;
X
Xcase ' ':
Xcase '-':
Xcase '1':
Xcase '2':
Xcase '3':
Xcase '4':
Xcase '5':
Xcase '6':
Xcase '7':
Xcase '8':
Xcase '9':
X	return ;
X
Xdefault:
Xprintf("!!!! Command line switch -%c is unknown.\n", cmd[cmd_arg]) ;
X	bugs(Failed) ;
X}
X} /* --- end of the cmd_switch subroutine --- */
X
Xvoid bugs(i_type)
X/***************************************************************/
X/*                                                             */
X/*       (c) Copyright 1992,   University of Queensland        */
X/*            Program written by Gary A. Allen, Jr.            */
X/*             Version:  Mk 1.0        24 April 1992           */
X/*                                                             */
X/***************************************************************/
Xint i_type ;
X{
Xswitch(i_type) {
Xcase Failed:
X	printf("!!!! If confused, type:  dinkum -h \n");
X	printf("!!!! --- Program ABORTED --- \n");
X	break ;
X
Xcase Request:
X	printf("Program terminated by user request.\n") ;
X	break ;
X}
Xexit (0) ; 
X} /* --- end of the "bugs" subroutine --- */
X
Xvoid help() 
X/*****************************************************/
X/*                                                   */
X/*                    Help Routine                   */
X/*                                                   */
X/*  (c) Copyright 1992,   University of Queensland   */
X/*        Program written by Gary A. Allen, Jr.      */
X/*           Version:  Mk 1.0    24 April 1992       */
X/*                                                   */
X/*****************************************************/
X{
Xchar chr ;
X
Xprintf("                    --- Dinkum --- \n");
Xprintf("       (c) Copyright 1993 by Gary A. Allen, Jr.\n") ;
Xprintf("   All Rights Reserved. Version: %s, %s\n\n", 
X		lb_version, lb_date);
X
Xprintf("      Dinkum is a text style \"adventure\" game.\n\n") ;
X
Xprintf("You are free to use, copy and distribute Dinkum provided:\n") ;
Xprintf("       NO FEE IS CHARGED FOR USE, COPYING OR DISTRIBUTION.\n") ;
Xprintf("       THIS PROGRAM IS FOR PRIVATE, NONCOMMERICAL USE ONLY.\n");
Xprintf("       THE PROGRAM MAY NOT BE MODIFIED IN ANY WAY.\n\n") ;
X
Xprintf("This program is provided AS IS without any warranty,\n") ;
Xprintf("expressed or implied, including but not limited to fitness\n") ;
Xprintf("for any particular purpose.\n\n") ;
X
X/* keep the screen from scrolling */
X#ifndef __TURBOC__
Xprintf("         [Press RETURN or ENTER to continue]") ;
Xchr = getchar() ;
X#endif
X
X#ifdef __TURBOC__
Xprintf("  [Press \"q\" to quit or any other key to continue]") ;
Xchr = getche() ;
Xprintf("\r                                                        \r") ;
X#endif
X
Xif ((chr == 'q')||(chr == 'Q')) exit (0) ;
X
Xprintf("If you start the game by typing \"dinkum -s\" rather than \n");
Xprintf("simply \"dinkum\" then the game creates a \"data recorder\" \n"); 
Xprintf("which appears in the beginning  of  the game.  The data \n"); 
Xprintf("recorder acts like a tape recorder allowing the user to \n"); 
Xprintf("save moves and play them back in the current  or  later \n"); 
Xprintf("games.  The generated file is in ASCII format  and  can \n"); 
Xprintf("be  edited  after  finishing  Dinkum.    Type  \"examine \n"); 
Xprintf("recorder\" after having taken it and Dinkum will explain \n"); 
Xprintf("how to use it.  This data  recorder  has  a  couple  of \n"); 
Xprintf("important  limitations:   Unlike  most adventure games, \n"); 
Xprintf("Dinkum is  dynamic,  viz.  the  game changes every time \n"); 
Xprintf("you play it.  So if you record  a  script  for  a  game \n"); 
Xprintf("which takes you to a room where you find a  weapon  and \n"); 
Xprintf("then to another room where you find a monster, then the \n"); 
Xprintf("next time you use  that script you may find the monster \n"); 
Xprintf("where you  previously  found  the  weapon (leading to a \n"); 
Xprintf("fairly short game). The other limitation  of  the  data \n"); 
Xprintf("recorder is if you use the \"dinkum -s\" switch then  you \n"); 
Xprintf("will  not  be  admitted  into  the  end  game  with the \n"); 
Xprintf("consequence being that  \"winning\" Dinkum is impossible. \n"); 
Xprintf("To win Dinkum you must  play  it  \"on your own\" without \n"); 
Xprintf("the unfair advantage of script files and data recorders.\n\n");
X
X/* keep the screen from scrolling */
X#ifndef __TURBOC__
Xprintf("         [Press RETURN or ENTER to continue]") ;
Xchr = getchar() ;
X#endif
X
X#ifdef __TURBOC__
Xprintf("  [Press \"q\" to quit or any other key to continue]") ;
Xchr = getche() ;
Xprintf("\r                                                        \r") ;
X#endif
X
Xif ((chr == 'q')||(chr == 'Q')) exit (0) ;
X
Xprintf("When corresponding please state the current version of\n") ;
Xprintf("Dinkum which you are using.  Contributions and questions\n") ;
Xprintf("about this program should be sent to the following address:\n\n") ;
Xprintf("          E-mail address:     gary@sun.mech.uq.oz.au\n\n") ;
Xprintf("          Postal address:     Gary A. Allen, Jr. \n");
Xprintf("                              P.O. Box 13\n") ;       
Xprintf("                              St. Lucia, Queensland  4067\n");
Xprintf("		 	 	            Australia\n") ;
X
Xexit(0);
X} /* ---- end of the "help" subroutine ---- */
X
Xvoid cheater() 
X/*****************************************************/
X/*                                                   */
X/*  (c) Copyright 1992,   University of Queensland   */
X/*        Program written by Gary A. Allen, Jr.      */
X/*           Version:  Mk 1.0   9 December 1992      */
X/*                                                   */
X/*****************************************************/
X{
Xprintf("Rather than cheat at this game by using a disassembler, you\n");
Xprintf("should send the author $150 and he'll gladly send you\n") ;
Xprintf("the source code.  If you just want a clue, then send $20\n") ;
Xprintf("with your question and he'll provide the answer.  You can find\n") ;
Xprintf("the author's address by typing:  dinkum -h\n") ;
X		exit(0) ;
X} /* ---- end of the "cheater" subroutine ---- */
X
Xint mover(direction,loc)
X/*****************************************************/
X/*                                                   */
X/*  (c) Copyright 1992,   University of Queensland   */
X/*        Program written by Gary A. Allen, Jr.      */
X/*           Version:  Mk 1.0  17 December 1992      */
X/*                                                   */
X/*****************************************************/
Xint direction, loc[3] ;
X{
X
X#if (PROTOTYPE)
X/* Function prototypes */
Xvoid long_descp(int), ender(int), boom(void) ;
X#endif
X
X/* see if this movement prohibits blasting caps */
Xif (((direction == V_u)||(direction == V_up)) &&
X		((loc[0] == R_manhole_1)||(loc[0] == R_manhole_2))) {
X
X	if (object[O_cap][J_loc] == B_have) {
Xprintf("As you were climbing up through the hole in the ceiling,\n");
Xprintf("the blasting cap slipped from your grasp and fell to the\n") ;
Xprintf("floor below where it detonated on impact.  The explosion\n") ;
Xprintf("was deafening, but caused no damage.\n") ;
X		carry_count-- ;
X		carry_weight -= object[O_cap][J_weight] ;
X		object[O_cap][J_loc] = B_destroyed; 
X	}
X	else {
X		if ((object[O_dynamite][J_loc] == B_have)&&
X			(object[O_dynamite][J_type] == Z_alias)) {
X			boom() ;
X
Xprintf("As you were climbing up through the hole in the ceiling,\n");
Xprintf("the dynamite with the blasting cap inside slipped from\n") ;
Xprintf("your grasp and fell to the floor below where it detonated\n") ;
Xprintf("on impact.  At that point you literally became a human\n");
Xprintf("cannon ball as the shock wave carried you up the vertical\n");
Xprintf("passage and splattered you into protoplasmic jelly on the\n");
Xprintf("ceiling above.\n") ; 
X			ender(F_died) ;
X		}
X	}
X} /* end of the cap/manhole block */
X
Xdirection-- ;
Xif (room[loc[0]][direction] == R_wall) {
X	printf("You can't go that way. \n");
X	return(FALSE) ;
X}
X
X/* save previous location */
Xloc[1] = loc[0] ;
Xloc[0] = room[loc[0]][direction] ;
X
X/* See if player walked into a lethal room */
Xif (room[loc[0]][M_rm_type] == T_lethal) {
X	long_descp(loc[0]) ;
X	ender(F_died) ;
X}
Xreturn(TRUE) ;
X} /* --- end of the "mover" function --- */
END_OF_FILE
if test 32399 -ne `wc -c <'dinkum.c'`; then
    echo shar: \"'dinkum.c'\" unpacked with wrong size!
fi
# end of 'dinkum.c'
fi
if test -f 'pusher.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pusher.c'\"
else
echo shar: Extracting \"'pusher.c'\" \(18897 characters\)
sed "s/^X//" >'pusher.c' <<'END_OF_FILE'
X#define PUSHER
X#include "dink_sym.h"
X#include "dink_glb.h"
X
Xvoid pusher(n_arg) 
X/********************************************************************/
X/*                                                                  */
X/*                  --- The Pusher Subroutine ---                   */
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 14 June 1989,    Version: Mk 1.2 */
X/*           (c) Copyright 1988 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
Xint *n_arg ;
X{
Xregister int i ;
Xint n ;
Xchar file_name[80] ;
X
X#if (PROTOTYPE)
Xvoid which_button(void) ; 
Xvoid lift_moves(void) ; 
Xvoid nothing_happens(void) ; 
Xvoid cubic(void) ; 
Xvoid no_gray(void) ; 
Xvoid no_switch(void) ; 
Xvoid no_cube(void) ; 
X#endif
X 
X/* pass the room pointer */
Xn = *n_arg ;
X
X/* reject an isolated "push" command */
Xif (tag[V_VERB_ONLY]) {
X	printf ("What exactly do you want me to push? \n");
X	return; 
X}
X
X/* Deal with the recorder */
Xif ((tag[V_red_button] || tag[V_white_button] || tag[V_green_button])) {
X	if (sw_script) {
X	if (object[O_recorder][J_loc] == B_have) {
X		if (tag[V_red_button]) {
X			if (sw_recording || sw_playing) {
X				if (sw_recording) {
X					sw_recording = FALSE;
Xprintf("--- The data recorder has stopped recording. ---\n") ;
X				}
X				else sw_playing = FALSE;
X				fclose(fp) ;
X			}
X			else printf("Nothing happened!\n") ;
X			return ;
X		}
X		if (tag[V_white_button]) {
X			printf("Type in the file name for reading from:  ") ;
X			scanf("%s",file_name) ;
X			if ((fp = fopen(file_name,"r")) == 0) {
Xprintf("I could not open the file:  %s \n",file_name);
Xprintf("This file probably doesn't exit.\n") ;
Xprintf("Try pressing the white button again and using a different name.\n") ;
X			}
X			else sw_playing = TRUE ;
X			return ;
X		}
X		if (tag[V_green_button]) {
X			printf("Type in the file name for writing to:  ") ;
X			scanf("%s",file_name) ;
X			if ((fp = fopen(file_name,"w")) == 0) {
Xprintf ("I could not open the file:  %s \n",file_name);
Xprintf("Try pressing the green button again and using a different name.\n") ;
X			}
X			else {
X				sw_recording = TRUE ;
X				printf("--- Recording ---\n") ;
X			}
X			return ;
X		}
X	}
X	else printf("You don't have the recorder in your possession!\n") ;
X	}
X	else printf("I have never seen a button of that color.\n") ;
X	return ;
X}
X
Xswitch (n) {
X/* Lift entrance at the ground level */
Xcase R_lift_entr:
X	if (tag[V_gray_button]) {
X		no_gray() ;
X		return ;
X	}
X	if (!tag[V_button]) {
X		if (!tag[V_blue_button]) {
X			printf ("I don't see why I should push that! \n");
X		}
X		else nothing_happens() ;
X		return ;
X	}
X	if (room[R_lift_entr][M_rm_status] == S_flashing ) {
Xprintf ("You push the call button and there is a loud \"whirr\" from ");
Xprintf ("an electric motor. \nThe massive steel doors slide open ");
Xprintf ("revealing a huge lift that could hold \ntwenty men at once. ");
Xprintf ("The way is now open for you to enter. \n");
X		room[R_lift_entr][M_rm_status] = S_open ;
X		room[R_lift_entr][2] = R_lift_inside ;
X		break ;
X	}
X	else {
X		if (room[R_lift_entr][M_rm_status] == S_open) {
Xprintf ("You push the call button and there is a loud \"whirr\" from ");
Xprintf ("an electric motor. \nThe massive steel doors slide shut, ");
Xprintf ("closing off access to the lift.\n");
X			room[R_lift_entr][M_rm_status] = S_flashing ;
X			room[R_lift_entr][2] = R_wall ;
X			break ;
X		}
X		else {
Xprintf("You pushed the lift call button, but nothing happened.\n");
Xprintf("I think the electrical power has been turned off at the\n") ;
Xprintf("circuit breaker.\n") ;
X		break ;
X		}
X	}
X 
X/* Lift Compartment */
Xcase R_lift_inside:
X	if (tag[V_gray_button]) {
X		no_gray() ;
X		return ;
X	}
X 
X	/* scan push sentence */
X	/* zero level */
X	if (tag[V_0]) {
X		if (room[R_lift_inside][M_rm_status]== S_L0) {
Xprintf ("You pushed the flashing button, but nothing happened.\n");
X			break ;
X		}
Xprintf ("The steel doors slam shut and you feel heavy as the lift ");
Xprintf ("accelerates \nupwards.  Finally the lift jerks to a halt ");
Xprintf ("and the doors whirr open.  \nSunlight is streaming in. ");
Xprintf ("Once again you are breathing the fresh air.\n");
X		room[R_lift_inside][M_rm_status] = S_L0;
X		room[R_lift_inside][3] = R_lift_entr;
X		room[R_lift_inside][7] = R_lift_entr;
X		return ;
X	}
X 
X	/* forty-ninth level */
X	if (tag[V_49]) {
X		if (room[R_lift_inside][M_rm_status]== S_L49) {
Xprintf ("You pushed the forty-nine button, but nothing happened.\n");
X			return ;
X		}	
X		room[R_lift_inside][M_rm_status] = S_L49 ;
X		room[R_lift_inside][3] = R_L49_entr;
X		room[R_lift_inside][7] = R_L49_entr;
X		lift_moves() ;
X		return ;
X	}
X 
X	/* sixty-seventh level */
X	if (tag[V_67]) {
X		if (room[R_lift_inside][M_rm_status]== S_L67) {
Xprintf ("You pushed the sixty-seven button, but nothing happened.\n");
X			return ;
X		}	
X		room[R_lift_inside][M_rm_status] = S_L67;
X		room[R_lift_inside][3] = R_L67_entr;
X		room[R_lift_inside][7] = R_L67_entr;
X		lift_moves() ;
X		return ;
X	}
X
X	/* eighty-second level */
X	if (tag[V_82]) {
X		if (room[R_lift_inside][M_rm_status]== S_L82) {
Xprintf ("You pushed the eighty-two button, but nothing happened.\n");
X			return ;
X		}	
X		room[R_lift_inside][M_rm_status] = S_L82;
X		room[R_lift_inside][3] = R_L82_entr;
X		room[R_lift_inside][7] = R_L82_entr;
Xprintf ("The steel doors slam shut and you feel a sense of ");
Xprintf ("weightlessness as \nthe lift plummets down the mine shaft. ");
Xprintf ("Finally the lift comes to a halt \n");
Xprintf ("and the doors whirr open. \n");
X		return ;
X	}
X	if (tag[V_blue_button]) {
X		nothing_happens() ;
X		return ;
X	}
Xprintf ("This lift can go only to levels 0, 49, 67, or 82 \n");
X	return ;
X
X/* inside the closet at the Iranian Parliament */
Xcase R_closet:
X	if (tag[V_gray_button]) {
X		no_gray() ;
X		return ;
X	}
X	if (tag[V_blue_button] || tag[V_button]) {
X		/* Is the command for the black cube */
X		if (object[O_cube][J_loc] != B_have) {
X			no_switch() ;
X		}
Xprintf("There is a bright flash of light! Then suddenly you are\n");
Xprintf("back in the hexagon chamber of the ancient spaceship.\n\n");
X		*n_arg = R_transport ;
X	}
X	else no_switch() ;
X	return ;
X 
X
X/* the transporter control panel room */
Xcase R_panel:
X	if (tag[V_button]) {
X		which_button() ;
X		return;
X	}
X	if (tag[V_blue_button]) {
X		if (object[O_cube][J_loc]==B_have) cubic() ;
X		else no_cube() ;
X		return ;
X	}
X	if (tag[V_gray_button]) {
X		if (sw_transport != TRUE) {
Xprintf("Lots of the \"Sanskrit\" text is flashing by on the display\n");
Xprintf("panel's CRTs.  There is a whirring noise coming out of the\n");
Xprintf("equipment around you which is increasing in both loudness\n");
Xprintf("and pitch. You've turned something on, that's for sure!\n") ;
X			sw_transport = TRUE ;
X		}
X		else nothing_happens() ;
X		return ;
X	}
Xdefault:
X	/* Semtex explosive detector */
X	if (tag[V_detector] || tag[V_yellow_button] ||
X		((object[O_cube][J_loc] != B_have) &&
X		(object[O_detector][J_loc] == B_have))) { 
X			if (object[O_detector][J_loc] == B_have) {
X				/* press Semtex detector button */
Xprintf("You press the button on the Semtex explosive detector and\n");
X				for (i = 0; i <= 9; i++) {
X					if ((n == i+207)||(n == i+228)) {
Xif (room[227-i][M_rm_type] == T_lethal) {
X	printf("hear a \"beep, beep, beep\".\n") ;
X	return ;
X}
X					}
X				}
X				printf("the yellow light flashed.\n") ;
X			}
X			else {
Xprintf("You don't have the detector in your possession.\n") ;
X			}
X			return ;
X		}
X		/* Transporter return device */
X		if (object[O_cube][J_loc] == B_have) {
X			if ((object[O_detector][J_loc] == B_have) && 
X				(!tag[V_blue_button])) {
X					which_button() ;
X					return;
X			}
X			cubic() ;
X			return ;
X		}
X		if (tag[V_blue_button]) {
X			no_cube() ;
X			return ;
X		}
X		if (tag[V_gray_button]) {
X			no_gray() ;
X			return ;
X		}
X
Xprintf ("You can push as much as you like, but nothing will happen.\n");
X} /* end of the switch block */
Xreturn; 
X
X} /* --- end of the "pusher" subroutine --- */
X
Xvoid which_button() 
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 8 December 1992  Version: Mk 1.0 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xprintf("Which button do you want me to push? \n") ;
Xreturn; 
X} /* --- end of the "which_button" subroutine --- */
X
Xvoid lift_moves() 
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 8 December 1992  Version: Mk 1.0 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xprintf ("The steel doors slam shut and you feel the vibration of ");
Xprintf ("the lift \nmoving in its shaft. Finally the lift jerks ");
Xprintf ("to a halt and the doors whirr open. \n");
Xreturn; 
X} /* --- end of the "lift_moves" subroutine --- */
X
Xvoid nothing_happens() 
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 8 December 1992  Version: Mk 1.0 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xprintf("Nothing happens!\n");
Xreturn; 
X} /* --- end of the "nothing_happens" subroutine --- */
X 
Xvoid cubic() 
X/********************************************************************/
X/*                                                                  */
X/*              Press cube button in wrong place.                   */
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 8 December 1992  Version: Mk 1.0 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xprintf("You press the button on the cube but nothing happens.\n");
Xreturn; 
X} /* --- end of the "cubic" subroutine --- */
X 
Xvoid no_gray() 
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 8 December 1992  Version: Mk 1.0 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xprintf("I see no gray button to push!\n");
Xreturn; 
X} /* --- end of the "no_gray" subroutine --- */
X 
Xvoid no_switch() 
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 8 December 1992  Version: Mk 1.0 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xprintf("There is nothing here with a push button switch.\n");
Xreturn; 
X} /* --- end of the "no_switch" subroutine --- */
X 
Xvoid no_cube() 
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 8 December 1992  Version: Mk 1.0 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
X{
Xprintf("You don't have the black cube with the blue button in your") ;
Xprintf(" possession!\n") ;
Xreturn; 
X} /* --- end of the "no_cube" subroutine --- */
X 
X 
Xvoid switcher(n) 
X/********************************************************************/
X/*                                                                  */
X/*                --- The Switcher Subroutine ---                   */
X/*                                                                  */
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 29 October 1989  Version: Mk 1.4 */
X/*           (c) Copyright 1988 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
Xint n ;
X{
Xint flag_switch, flag_rifle_md ;
X
X#if (PROTOTYPE)
Xvoid dialer(int) ;
X#endif
X
X/* deal with single verb commands */
Xif (tag[V_VERB_ONLY]) {
X	if (tag[V_turn]) printf("Turn what?\n") ;
X	if (tag[V_set]) printf("Set what?\n") ;
X	if (tag[V_select]) printf("Select what?\n") ;
X	if (tag[V_switch]) printf("Switch what?\n") ;
X	return ;
X}
X
X/* Deal with changing the safety on the rifle */
Xif (tag[V_safety]) {
X	if (object[O_rifle][J_loc] == B_have) {
X		if (tag[V_off]) {
X			rifle_flag = F_single ;
Xprintf("The M16 rifle is set to single shot mode ") ;
Xprintf("with the safey off.\n") ;
X			return ;
X		}
X		if (tag[V_on]) {
X			rifle_flag = F_safety ;
Xprintf("The M16 rifle's safety has been turned on.\n") ;
X			return ;
X		}
X	printf("How do you want the safety set?\n") ;
X	}
X	else printf("You're not holding the rifle!\n") ;
X	return ;
X}
X
X/* deal with special case "turn (safe) dial 0 49 67 82" */
Xif (tag[V_turn] && tag[V_dial] && (!tag[V_rifle])) {
X	dialer(n) ;
X	return ;
X}
X
X/* deal with special case "turn safe ..." */
Xif (tag[V_turn] && (!tag[V_dial]) && tag[V_safe]) {
X	if (n != R_office_mang) {
Xprintf("There is no safe here to turn!\n") ;
X		return  ;
X	}
Xprintf("Since the safe is set in a concrete wall, turning it would\n");
Xprintf("be rather difficult!  Perhaps I should turn the safe's\n") ;
Xprintf("dial instead?\n") ;
X	return ;
X}
X
X/* initialize the local switches */
Xflag_switch = F_no_argument ; 
Xif (tag[V_on]) flag_switch = TRUE ;
Xif (tag[V_off]) flag_switch = FALSE ;
Xif (verb == V_light) flag_switch = TRUE ;
X
Xflag_rifle_md = F_no_argument ;
Xif (tag[V_safe]) flag_rifle_md = F_safety ;
Xif (tag[V_triple]) flag_rifle_md = F_triple ;
Xif (tag[V_single]) flag_rifle_md = F_single ;
Xif (tag[V_auto]) flag_rifle_md = F_auto ;
X
Xif ((flag_switch == F_no_argument)&&(flag_rifle_md == F_no_argument)) {
Xprintf("You will have to be a little more specific than that. \n") ;
X	return ;
X}
X
X/* see if it is a simple "on/off" power equipment switch command */
Xif ((!tag[V_torch])&&(!tag[V_rifle])&&
X	(flag_rifle_md == F_no_argument)) {
Xif (n == R_store_room) {
X	/* The circuit breaker is switched off */
X	if (flag_switch == FALSE) {
X	if (room[R_store_room][M_rm_status] == S_off) {
X		printf ("The circuit breaker is already turned off! \n");
X	}
X	else {
Xprintf ("As you pull the switch lever, there is a bright blue \n");
Xprintf ("arc and then all of the lights go out. \n");
X		room[R_store_room][M_rm_status] = S_off ;
X		room[R_lift_entr][M_rm_status] = S_closed ;
X	}
X	return;
X	}
X	/* The circuit breaker is switched on */
X	if (flag_switch == TRUE) {
X	if (room[R_store_room][M_rm_status] == S_on) {
X	printf ("The circuit breaker is already turned on! \n");
X	}
X	else {
Xprintf ("As you pull the switch lever, there is a loud \"CLUNK\" \n");
Xprintf ("and you see a POWER ON light glowing. \n");
X		room[R_store_room][M_rm_status] = S_on ;
X		room[R_lift_entr][M_rm_status] = S_flashing ;
X	}
X	return;
X	}
X}          
X
X/* Deal with a garbage command */
Xprintf("I don't understand what you want me to switch. \n") ;
Xreturn ;
X} /* end of the simple "on/off" switch group */
X
X/* the switch command is to select an M16 rifle firing mode */
Xif (tag[V_rifle]) {
X	if (object[O_rifle][J_loc] == B_have) {
X
X		/* turn the rifle on naively */
X		if ((flag_switch==TRUE)||
X	           ((flag_rifle_md==F_safety)&&(flag_switch==FALSE))) {
X			if (rifle_flag != F_safety) {
Xprintf("The rifle's safety is already off! \n") ; 
X				return;
X			}
X			rifle_flag = F_single ;
Xprintf("The M16 rifle has been set to single shot mode. \n") ;
X			return ;
X		} 
X/* turn on the safety */
X	if ((flag_switch==FALSE)||
X	  ((flag_rifle_md==F_safety)&&((flag_switch==TRUE)||
X	  (flag_switch==F_no_argument)))) {
X				if (rifle_flag == F_safety) {
Xprintf("The rifle's safety is already on! \n") ; 
X				return;
X				}
X			rifle_flag = F_safety ;
Xprintf("The M16 rifle's safety has now been turned on. \n") ;
X			return ;
X	} 
X		/* select single shot mode */  
X		if (flag_rifle_md == F_single) {
X			if (rifle_flag == F_single) {
Xprintf("The rifle has already been set to single shot mode.\n");
X				return;
X			}
X			rifle_flag = F_single ;
Xprintf("The M16 rifle has been set to single shot mode. \n") ;
X			return ;
X		} 
X		/* select triple fire mode */  
X		if (flag_rifle_md == F_triple) {
X			if (rifle_flag == F_triple) {
Xprintf("The rifle has already been set to triple fire mode.\n");
X				return;
X			}
X			rifle_flag = F_triple ;
Xprintf("The M16 rifle has been set to triple fire mode. \n") ;
X			return ;
X		} 
X		/* select to fully automatice mode */
X		if (flag_rifle_md == F_auto) {
X			if (rifle_flag == F_auto) {
Xprintf("The rifle has already been set to fully automatic.\n");
X				return;
X			}
X			rifle_flag = F_auto ;
Xprintf("The M16 rifle has been set to fully automatic. \n") ;
X			return ;
X		} 
X	}
X	/* This is the rifle nonpossession error handler */
X	else {
Xprintf("You don't have a rifle in your possession! \n") ;
X		return ;
X	}
X} /* end of the rifle mode switching block */
X
X/* the switch command is to turn the torch off or on. */
Xif (tag[V_torch]) {
X	if (object[O_torch][J_loc] == B_have) {
X		/* "switch torch on" command */
X		if (flag_switch==TRUE) {
X			if (object[O_torch][J_property]) {
Xprintf("The torch is already turned on.\n") ;
X				return ;
X			}
Xprintf("An intense beam of light is projected from the torch.\n") ;
X			object[O_torch][J_property] = TRUE ;
X			return ;
X		}
X		/* "switch torch off" command */
X		if (flag_switch==FALSE) {
X			if (!object[O_torch][J_property]) {
Xprintf("The torch isn't switched on.\n") ;
X				return ;
X			}
Xprintf("The torch switches off with a \"click\".\n") ;
X			object[O_torch][J_property] = FALSE ;
X			return ;
X		}
X	}
Xprintf("You don't have a torch in your possession to switch! \n") ;
X	return ;
X}
X
X} /* --- end of the "switcher" subroutine --- */
X
Xvoid new_score() 
X/* This subroutine calculates the score based on treasure in the safe */
X{
Xint i ;
X	score = 0 ;
X for (i = 0; i <= objcnt; i++) if (object[i][J_loc] == B_in_safe)  {
X		score += object[i][J_value] ;
X	} ;
X} /* --- end of the "new_score" subroutine --- */
X
END_OF_FILE
if test 18897 -ne `wc -c <'pusher.c'`; then
    echo shar: \"'pusher.c'\" unpacked with wrong size!
fi
# end of 'pusher.c'
fi
echo shar: End of archive 2 \(of 7\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
