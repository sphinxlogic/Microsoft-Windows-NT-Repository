Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v15i038:  dinkum2 - australian text adventure game, Part03/07
Message-ID: <4194@master.CNA.TEK.COM>
Date: 14 Jan 93 03:25:50 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1788
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1537

Submitted-by: Gary Allen <gary@sun.mech.uq.oz.au>
Posting-number: Volume 15, Issue 38
Archive-name: dinkum2/Part03
Supersedes: dinkum: Volume 15, Issue 21-26
Environment: Unix, DOS



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 7)."
# Contents:  actor.c taker.c
# Wrapped by billr@saab on Wed Jan 13 19:20:18 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'actor.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'actor.c'\"
else
echo shar: Extracting \"'actor.c'\" \(18535 characters\)
sed "s/^X//" >'actor.c' <<'END_OF_FILE'
X#define ACTOR
X#include "dink_sym.h"
X#include "dink_glb.h"
X 
Xvoid actor(n)
X/********************************************************************/
X/*                                                                  */
X/* Software by Gary A. Allen, Jr. 12 December 1992, Version: Mk 1.3 */
X/*           (c) Copyright 1992 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
Xint n ;
X{
X#if (PROTOTYPE)
Xvoid objector(int) ;
X#endif
X
Xregister int i, j ;
Xint sw_found ;
Xstatic int sw_door_kick = FALSE ;
X
Xswitch(n) {
X
X	/* mine elevator */
X	case R_lift_entr:
X		if (room[R_lift_entr][M_rm_status] == S_closed) {
Xprintf("The lift doors are closed and the lift call button ");
Xprintf("is not glowing. It \nseems the electrical power has ");
Xprintf("been turned off at the main switch. \n");
X		}
X		if (room[R_lift_entr][M_rm_status] == S_flashing) {
Xprintf("The lift doors are closed.  However the call button");
Xprintf(" is flashing. There \nis the sound of electrical equipment ");
Xprintf("humming within the mine lift. \n");
X		}
X		if (room[R_lift_entr][M_rm_status] == S_open) {
Xprintf("The lift doors are standing open. \n");
X		}
X		break;
X 
X	/* office building door */
X	case R_office_entr:
X		switch(room[R_office_entr][M_rm_status]) {
X			case S_open:
Xprintf("      --- The office front door is open. --- \n");
X				break;
X			case S_kicked:
X				if (!sw_door_kick) {
Xprintf("The lock of the front door has been shot at several times.\n"); 
Xprintf("The door itself has been kicked in and is broken off at\n") ;
Xprintf("the hinges.  The passage way is free to enter.\n");
X				sw_door_kick = TRUE ;
X				}
X				else {
Xprintf("The front door of the office has been kicked in. \n") ;
X				}
X				break ;
X			default:
Xprintf("The office has a front door with a sun faded sign \n"); 
Xprintf("upon which is written:  \"Sorry, We are CLOSED\". \n");
Xprintf("      --- The office door is shut. --- \n");
X				break ;
X		}
X		break ;
X 
X	/* Site Managers Office */
X	case R_office_mang:
X		if (room[R_office_mang][M_rm_status] == S_closed) {
Xprintf("On the wall is a picture of a platypus wearing a hat with");
X		printf(" corks \ndangling from the hat's rim.\n");
X			break;
X		}
Xif ((room[R_office_mang][M_rm_status] == S_revealed)||
X	(room[n][M_rm_status] ==S_dialed)) {
Xprintf("Before you is a picture hinged to the wall that has been ");
Xprintf("swung \nopen revealing a closed combination dial wall safe.\n");
X			break;
X}
X		if (room[n][M_rm_status] == S_open) {
Xprintf("Before you is a picture hinged to the wall that has been");
Xprintf(" swung \nout revealing a wall safe with an open door.\n");
X		sw_found = FALSE ;
X		for (i = 0; i <= objcnt; i++) {
X			if (object[i][J_loc] == B_in_safe) {
X				sw_found = TRUE ;
Xprintf ("You see the following inside the safe: \n");
X				for (j = 0; j <= objcnt; j++) {
X					if (object[j][J_loc] == B_in_safe) {
X						printf ("        ");
X						objector(j) ;
X						printf("\n") ;
X					}
X				}				
X				if (gleep_safe != 0) {
X					printf ("        ");
X					if (gleep_safe == 1) 
X						printf("one gleep\n") ;
X					else
X						printf("%d gleeps\n",gleep_safe) ;
X				}
X				break;
X			}
X		}
X		if (sw_found) break ;
X		if (gleep_safe != 0) {
Xprintf("There is nothing in the safe except ") ;
X			if (gleep_safe == 1) 
X				printf("a single gleep.\n") ;
X			else
X				printf("%d gleeps.\n",gleep_safe) ;
X			break ;
X		}
X		printf("---The safe is empty.--- \n");
X		break ;
X		} /* end of the "safe open" block */
X
X	/* store room */
X	case R_store_room:
Xprintf("There is a 1500 Volt circuit breaker box on the wall");
X		if (room[n][M_rm_status] == S_off) 
Xprintf(" which has \na switch set in the \"off\" position. \n"); 
X		else
Xprintf(" which has \na switch set in the \"on\" position. \n"); 
X		break;
X
X	/* lift compartment */
X	case R_lift_inside:
X		if (room[n][M_rm_status] == S_L0) 
Xprintf("The level button with the number zero is flashing. \n"); 
X		if (room[n][M_rm_status] == S_L49) 
Xprintf("The level button with the number forty-nine is flashing. \n"); 
X		if (room[n][M_rm_status] == S_L67) 
Xprintf("The level button with the number sixty-seven is flashing. \n");
X		if (room[n][M_rm_status] == S_L82) 
Xprintf("The level button with the number eighty-two is flashing. \n"); 
X		break;
X
X} 
X} /* --- end of subroutine "actor"--- */
X
Xvoid objector(i)
Xint i ;
X{
Xstatic char *obj[] = {
X"an empty can of Fourex beer",
X"a cigarette butt",
X"an empty bottle of Black Swan Lager",
X"an old doormat with \"ACME Gold Mines Ltd.\" written on it",
X"a large brass key",
X"a ripped and bent up umbrella",
X"a two metre length of fishing tackle without a hook",
X"a broken drill bit",
X"a very old but detailed map of the ACME Mine",       /*  5  */
X"a fragment of a map showing the ACME Mine",
X"a sheet of paper with some writing on it",
X"a gold bar weighing ten kilograms",
X"a hydraulic jack which is rusted solid",
X"a large stick of dynamite",
X"an M16 ammo clip designed to hold up to 200 rounds",
X"a fountain pen which is dried up and useless",
X"an orange M16 ammo clip which is glowing a faint pale blue",
X"a mechanical pencil without any leads",
X"an unloaded, fully automatic M16 infantry rifle",    /*  10 */
X"a piece of copper wire",
X"a short length of galvanized iron pipe",
X"a blasting cap with 20 cm. of fuse attached",
X"a box of \"Red Head\" matches",
X"a diamond ring with a three carat flawless blue diamond",
X"a can opener",
X"a bright red ruby the size of an egg",               /*  15 */
X"an antique sterling silver teapot with \"N.K.\" engraved on it",
X"a silver Syracusian Dekadrachma coin",
X"an electrical extension cord",
X"a $100 dollar bill",
X"an autographed photo of Sir Joh",
X"an old folding chair",
X"a burned out light bulb",
X"a packet containing atropine pills",
X"a high quality artificial saphire",
X"a huge uncut emerald",
X"an oily rag",
X"a burned out fluorescent tube",
X"a filthy worn out carpet",
X"a branch from a gum tree",
X"a thick airmail letter, marked \"Postage Due\"",
X"a cork from a wine bottle",
X"a high intensity battery powered torch",
X"an old cockroach trap",
X"an empty butane cigarette lighter",
X"a small black cube with a blue push button on one side", 
X"an ancient and priceless gong clapper made of ivory and gold",
X"a Semtex explosive detector with a push button switch",
X"a broken shoe lace",
X"a dirty old comb",
X"a Cornetto ice cream cone wrapper",
X"a bald automobile tyre",
X"an empty broken egg shell",
X"a broken piece of brick",
X"a one metre length of rope",
X"an empty package of Stradbroke cigarettes",
X"a broken automobile fan belt",
X"a used automobile oil filter",
X"a short piece of string",
X"a data recorder having three coloured buttons"
X} ;  /* end of the "obj" character string matrix */
X
X/* Deal with transformed objects */
Xif (object[i][J_type] == Z_alias) {
X	if (i == O_rifle) {
Xprintf("an M16 infantry rifle with an ammunition clip inserted") ;
X		return ;
X	}
X	if (i == O_dynamite) {
Xprintf("a large stick of dynamite with a fuse type blasting cap") ;
X		return ;
X	}
X}
Xelse printf("%s",obj[i]) ;
X} /* --- end of subroutine "objector"--- */
X 
Xvoid killer(n)
X/********************************************************************/
X/*                                                                  */
X/*  Software by Gary A. Allen, Jr. 22 January 1989  Version: Mk 1.3 */
X/*           (c) Copyright 1989 by Gary A. Allen, Jr.               */
X/*                                                                  */
X/********************************************************************/
Xint n ;
X{
Xregister int i, j ;
X
Xint hits, j_point, i_10, i_fract ;
Xint sw_kill, target_k_flag, sw_see, sw_other_object ;
Xstatic int sw_hurt = FALSE ;
X
Xstruct monster_struct *mnstr ; 
X
X#if (PROTOTYPE)
Xvoid ender(int) ;
X#endif
X
Xif (tag[V_VERB_ONLY]&&(verb == V_kill)) {
Xprintf("It may be obvious to you, but you are going to have to tell\n");
Xprintf("me exactly what it is you want to have killed, and \n") ;
Xprintf("with what sort of weapon. \n") ;
X	return;
X}
X
X/* set the subroutine local flags */
Xif (verb == V_kill) sw_kill = FALSE ;
Xif (verb == V_shoot) sw_kill = TRUE;
Xtarget_k_flag = V_NULL ;
Xsw_see =  FALSE ;
Xsw_other_object = FALSE ;
X 
Xif (tag[V_ned]) {
X	if (Ned->Location == B_destroyed) {
Xprintf("Forget it, you drongo!! Ned Kelly is already dead!\n") ;
X		return ;
X	}
X	if (Ned->Status == F_asleep) {
Xprintf("There is no Ned Kelly here for me to kill! \n") ;
X		return ;
X	}
X	j_point = 0 ; 
X	sw_see =  TRUE ;
X	target_k_flag = V_ned ;
X}
X
Xif (tag[V_bear]) {
X	for (j = 2; j <= 5; j++) {
X		mnstr = (monster_start + j) ;  /* point to the monster */
X		if (mnstr->Status != F_asleep) {
X			j_point = j ; 
X			sw_see =  TRUE ;
X			target_k_flag = V_bear ;
X			break ;
X		}
X	}
X	if (j > 5) {
X		printf("I see no drop bear for me to kill! \n") ;
X		return ;
X	}
X}
X
Xif (tag[V_wombat]) {
X	if (Wombat->Status == F_asleep) {
X		printf("I see no wombat for me to kill!\n");
X		return ;
X	}
X	j_point = N_wombat ; 
X	sw_see =  TRUE ;
X	target_k_flag = V_wombat ;
X}
X
Xif (tag[V_snake]) {
X	for (j = 6; j <= 13; j++) {
X		mnstr = (monster_start + j) ;  /* point to the monster */
X		if (mnstr->Status != F_asleep) {
X			j_point = j ; 
X			sw_see =  TRUE ;
X			target_k_flag = V_snake ;
X			break ;
X		}
X	}
X	if (j > 13) {
X		printf("I see no hoop snake for me to kill! \n") ;
X		return ;
X	}
X}
X
Xif (tag[V_rifle]) sw_kill = TRUE ;
X
X/* see if the safe is being shot at */
Xif (tag[V_safe]&&(n == R_office_mang)) {
Xprintf("The safe is made out of harden steel.  You'll only waste ") ;
Xprintf("ammunition \nshooting at it.  Try to open it instead. \n") ;
Xreturn ;
X}
X
X/* see if the target is in the room or holding it */
Xfor (j=0; j <= objcnt; j++) {
X	if (tag[object[j][J_parse_id]]){
X 		if (object[j][J_parse_id] == V_rifle) continue ;
X		sw_other_object = TRUE ;
X		if (object[j][J_loc] == n) {
X			sw_see =  TRUE ;
X			target_k_flag = object[j][J_parse_id] ;
X			break ;
X		}
X		if (object[j][J_loc] == B_have) {
Xprintf("I will ***NOT*** shoot at something that I'm holding!!\n");
X			return ;
X		}
X	}
X}
X
Xif (tag[V_rifle] && (!sw_other_object)) tag[V_VERB_ONLY] = TRUE ;
X
Xif ((!tag[V_VERB_ONLY]) && (!tag[V_DIRECTION])) {
X	if (!sw_see) {
X		printf("I don't see it here to shoot at it. \n") ;
X		return; 
X	}
X
X	if (target_k_flag == V_NULL) {
Xprintf("It may be obvious to you, but you are going to have to tell\n");
Xprintf("me exactly what it is you want to have killed.\n");
X		return ;
X	}
X}
X
X/* resolve killing errors */
Xif (!sw_kill) {
X	printf("What weapon am I suppose to use? \n") ;
X	return ;
X}
X
Xif (object[O_rifle][J_loc] != B_have) {
Xprintf("I would do that.  Only there is one small problem.... \n") ;
X	printf("You don't have a rifle in your possesion! \n") ;
X	return ;
X}
X 
X/* Shoot the gun (or at least try to) */
Xprintf("You pull the trigger... \n\n") ;
X 
Xif (clip_flag == F_no_clip) {
Xprintf("Nothing happens!  \n") ;
Xprintf("Your rifle doesn't have an ammunition clip in it.\n") ;
X	return ;
X}
X 
Xif (object[O_rifle][J_property] <= 0) {
X	printf("Nothing happens!  The ammo clip is out of bullets.\n") ;
X	return ;
X}
X 
Xswitch(rifle_flag) {
Xcase F_safety:
X	printf("Nothing happens!  The rifle's safety is still on.\n");
X	return ;
X			
Xcase F_single:
X	printf("Bam! \n\n") ;
X	--object[O_rifle][J_property] ;
X	if (clip_flag == F_normal_clip) hits = 1;
X		else hits = 100 ;
X	break ;
X
Xcase F_triple:
X	if (object[O_rifle][J_property] >= 3) {
X		printf("Bam! Bam! Bam! \n\n") ;
X		object[O_rifle][J_property] -= 3 ;
X		if (clip_flag == F_normal_clip) hits = 3;
X			else hits = 300 ;
X	}
X	else {
X		for (i = 1; i <= object[O_rifle][J_property]; i++) 
X			printf("Bam! ") ;
X			printf("\n\nYou've run out of bullets. \n\n") ;
X		if (clip_flag == F_normal_clip) 
X			hits = object[O_rifle][J_property];
X			else hits = object[O_rifle][J_property]*100 ;
X		object[O_rifle][J_property] = 0 ;
X	}
X	break ;
X
Xcase F_auto:
X	if (object[O_rifle][J_property] >= 30) {
X		for (i = 1; i <= 3; i++) 
Xprintf("Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! \n") ;
X		object[O_rifle][J_property] -= 30 ;
X		hits = 30;
X	}
X	else {
X		i_10 = object[O_rifle][J_property]/10 ;
X		i_fract = object[O_rifle][J_property]-(i_10*10) ;
X		for (i = 1; i <= i_10; i++) 
Xprintf("Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! \n") ;
X		for (i = 1; i <= i_fract; i++) 
X			printf("Bam! ") ;
X			printf("\n\nYou've run out of bullets. \n") ;
X		if (clip_flag == F_normal_clip) 
X			hits = object[O_rifle][J_property];
X			else hits = object[O_rifle][J_property]*100 ;
X		object[O_rifle][J_property] = 0 ;
X	}
X	printf("\n") ;
X	break ;
X}
X 
X
X/* Target Seen block */
Xif (sw_see) {
X	/* Toggle the hurt switch if this is the first hit */
X	mnstr = (monster_start + j_point) ;  /* point to the monster */
X	if (mnstr->Hits == 0)  sw_hurt = FALSE ;
X	mnstr->Hits += hits ;
X
X	switch(target_k_flag) {
X	case V_ned:
Xprintf("Ned Kelly keels over dead.  His body suddenly glows a bright ");
Xprintf("orange like it\nis being consummed by a heatless flame ");
Xprintf("and then the late Ned Kelly disappears\ninto a puff of ") ;
Xprintf("blue smoke. \n\n") ;
Xprintf("By the way, the recently deceased bushranger ***was*** ");
Xprintf("wearing iron body\narmour.  However thin sheets of iron ");
Xprintf("would just barely work against nineteenth\ncentury firearms ");
Xprintf("at long range.  Against a modern infantry rifle, Ned's\n");
Xprintf("armour offered about as much protection as a dunny paper ");
Xprintf("bandage. \n") ;
X		Ned->Location = B_destroyed ;
X		Ned->Status = F_asleep ;
X		monster_flag = F_no_monster ;
X		room[R_hideout][M_monster] = 0 ;
X	
X		/* create Ned Kelly's silver teapot */
X		++room[R_hideout][M_obj_cnt] ;
X		object[O_teapot][J_loc] = R_hideout ;
X		return ;
X
X	/* shoot the drop bear */
X	case V_bear:
X		if (mnstr->Hits < 30) {
X			/* Bear freaks out from being shot too much */
X			if (sw_hurt && (mnstr->Hits >= 10)) {
Xprintf("The drop bear has been shot at so many times, that it ");
Xprintf("has gone mad\n") ;
Xprintf("with rage.  It leaps three metres and rips out your ") ;
Xprintf("throat with a\n");
Xprintf("single swish of its claws.  You die instantly. \n") ;
X				ender(F_died) ;
X			}
X
X			if (mnstr->Hits == 1) {
Xprintf("Your bullet hit the drop bear causing it to howl in ");
Xprintf("anguish.  However drop\n");
Xprintf("bears are pretty tough and just one bullet isn't ");
Xprintf("going to kill it.\n") ;
X			}
X			else {
X				if (!sw_hurt) {
Xprintf("You've hit the drop bear and it is bleeding fairly ");
Xprintf("heavily.\n");
Xprintf("Unfortunately it is still alive and kicking and wants ") ;
Xprintf("your blood \n");
Xprintf("in payment for its.\n") ;
X					sw_hurt = TRUE ;
X				}
X				else {
Xprintf("You've hit the drop bear again.  It is weakening but still ");
Xprintf("alive.\n");
X				}
X			}
X			monster_flag = F_wounded ;
X			return ;
X		}
X
X		if (rifle_flag == F_single) {
Xprintf("That last bullet was the straw which broke the drop ") ;
Xprintf("bear's back.\n") ;
Xprintf("The blasted thing is finally dead! \n") ;
X		}
X		else {
Xprintf("The bullets riddled the drop bear with holes, killing it ") ;
Xprintf("instantly. \n") ; 
X		}
Xprintf("Suddenly the drop bear's corpse turns into a cloud of greasy ");
Xprintf("blue smoke,\n") ;
Xprintf("which floats away without a trace.\n") ;
X		sw_hurt = FALSE ;
X		mnstr->Location = B_destroyed ;
X		mnstr->Status = F_asleep ;
X		monster_flag = F_no_monster ;
X		room[n][M_monster] = 0 ;
X		return ;
X 
X		/* shoot the mutant wombat */
X	case V_wombat:
X		if (Wombat->Hits < 300) {
X			if (Wombat->Hits == 1) {
Xprintf("Your bullet hit the wombat causing it some minor discomfort.");
Xprintf("  Judging from its \n");
Xprintf("behavior, killing this beast is going to be tough! \n") ;
X			}
X			else {
X				if (!sw_hurt) {
Xprintf("You've hit the wombat and got its attention ") ;
Xprintf("but you've not\n");
Xprintf("seriously wounded it.  In fact, you've made it more fierce ");
Xprintf("than before.\n");
X					sw_hurt = TRUE ;
X				}
X				else {
Xprintf("You've hit the wombat again, but it is still going ");
Xprintf("strong.\n");
X				}
X			}
X			monster_flag = F_wounded ;
X			return ;
X		}
X
X		if (rifle_flag == F_single) {
Xprintf("That last bullet was the straw which broke the ") ;
Xprintf("wombat's back.\n") ;
Xprintf("The blasted thing is finally dead!\n\n") ;
X		}
X		else {
Xprintf("The bullets did the trick on the wretched thing.  It's ") ;
Xprintf("dead as a doornail.\n\n") ;
X		}
Xprintf("Suddenly the wombat's corpse starts to glow with an intense");
Xprintf(" white light.\n") ;
Xprintf("There is then a crackling sound as its body starts to burn.");
Xprintf("  You can\n");
Xprintf("smell the stench of burning hair.  Then the white light");
Xprintf(" begins to dim,\n");
Xprintf("leaving no trace left of the once formidable monster.\n");
X		sw_hurt = FALSE ;
X		Wombat->Location = B_destroyed ;
X		Wombat->Status = F_asleep ;
X		monster_flag = F_no_monster ;
X		room[n][M_monster] = 0 ;
X		return ;
X 
X	/* shoot the hoop snake */
X	case V_snake:
X		if ((rifle_flag == F_single)&&
X			(mnstr->Hits < 3)) {
X			if (mnstr->Hits == 1) {
Xprintf("Your bullet hit the hoop snake.  However the hoop snake's ");
Xprintf("thick scales \n");
Xprintf("slowed the bullet down.  The hoop snake is now hissing ");
Xprintf("furiously. \n") ;
X			}
X			else {
Xprintf("You've hit the hoop snake again, and it's hurting.  However ");
Xprintf("it is still \n");
Xprintf("alive and full of venom. \n") ;
X			}
X			monster_flag = F_wounded ;
X			return ;
X		}
X
X		if (rifle_flag == F_single) {
Xprintf("The bullet hit the hoop snake finishing the horrible ") ;
Xprintf("creature off. \n") ;
X		}
X		else {
Xprintf("The bullets hit the hoop snake splatting it into a mass of ") ;
Xprintf("mince meat. \n") ; 
X		}
Xprintf("Suddenly the bullet holed snake glows red and whooshes ");
Xprintf("into a cloud \n") ;
Xprintf("steam, leaving no traces behind.\n\n") ;
X		mnstr->Location = B_destroyed ;
X		mnstr->Status = F_asleep ;
X		monster_flag = F_no_monster ;
X		room[n][M_monster] = 0 ;
X		return ;
X
X	case V_can:
X	case V_beer:
X	case V_fourex:
X	case V_Fourex:
Xprintf("The can is hit by a bullet and flies off out of sight.\n");
X		object[O_can][J_loc] = B_destroyed ;
X		return;
X
X
X	case V_bottle:
X	case V_lager:
Xprintf("It is hit by a bullet and shatters into a million pieces.\n");
X		object[O_bottle][J_loc] = B_destroyed ;
X		return;
X
X	} /* end of target switch group */
X} /* end of the "target seen" block */
X 
X/* There was no target specified so the shot was wasted */
Xif (tag[V_VERB_ONLY]) { 
Xprintf("You didn't specify a target. So the rifle was pointed\n") ;
Xprintf("in a random direction and the ammunition wasted.\n") ;
X}
Xelse 
Xprintf("Except for wasting ammunition, nothing much happened.\n") ;
Xreturn ;
X
X} /* --- end of the 'killer' subroutine --- */
X
END_OF_FILE
if test 18535 -ne `wc -c <'actor.c'`; then
    echo shar: \"'actor.c'\" unpacked with wrong size!
fi
# end of 'actor.c'
fi
if test -f 'taker.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'taker.c'\"
else
echo shar: Extracting \"'taker.c'\" \(31011 characters\)
sed "s/^X//" >'taker.c' <<'END_OF_FILE'
X#define TAKER
X#include "dink_sym.h"
X#include "dink_glb.h"
X 
Xvoid taker(n)
X/*********************************************************/
X/*                                                       */
X/*           --- Object Taking Subroutine ---            */
X/*                                                       */
X/*      Program by Gary A. Allen, Jr.   20 May 1990      */
X/*        (c) Copyright 1992 by Gary A. Allen, Jr.       */
X/*                                                       */
X/*********************************************************/
Xint n ;
X{
Xregister int i, j ;
Xint  sw_done, gleep_holder, ammo_flag ;
X
X#if (PROTOTYPE)
Xvoid clip_in(int), clip_out(int), ender(int), eater(void) ;
X#endif
X
X/* Alias in the object for the single word "take" command */
Xif (tag[V_VERB_ONLY]) {
X	j = 0 ;
X	/* See if there is only one object on the floor */
X	for (i = 0; i <= objcnt; i++) if (n == object[i][J_loc]) {
X		j++ ;
X		tag[object[i][J_parse_id]] = TRUE ;
X	}
X
X	if (room[n][M_gleep] != 0) {
X		j++ ;
X		tag[V_gleep] = TRUE ;
X		if (room[n][M_gleep] > 1) tag[V_PLURAL] = TRUE ;
X	}
X
X	/* Complain if there isn't a single object on the ground */
X	if (j > 1) {
X		printf ("What exactly do you want me to take? \n");
X		return ;
X	}
X}
X
Xammo_flag = F_no_clip ;
Xif (tag[V_clip]) ammo_flag = F_normal_clip ;
Xif (tag[V_org_clip]) ammo_flag = F_org_clip ;
X
X/* deal with special case of "orange clip" implied by its being alone */
Xif (tag[V_clip]&&(object[O_clip][J_loc] != n)&&
X   (object[O_org_clip][J_loc] == n)) {
X	tag[V_org_clip] = TRUE ;
X	tag[V_clip] = FALSE ;
X	if (V_clip == sent[1]) sent[1] = V_org_clip ;
X}
X
X/* deal with the verb "attach" */
Xif (verb == V_attach) {
X	if (tag[V_rifle]&&(ammo_flag != F_no_clip)) {
X		clip_in(ammo_flag) ;
X		return ;
X	}
X	if ((n != R_office_mang)&&(room[n][M_obj_cnt] <= 0)) {
X		printf ("There is nothing here that I can attach!\n");
X		return ;
X	}
X}
X
X/* Check to see if player already has the item */
Xfor (i = 0; i <= objcnt; i++) { 
X	if (object[i][J_parse_id] == sent[1]) {
X		if (object[i][J_loc] == B_have) {
Xprintf ("You already have a %s in your possession.\n",vocab[sent[1]-1]);
X			return ;
X		}
X		else break ;
X	}
X}
X
Xsw_done = FALSE ;
X
Xif (tag[V_safe]) {
X	if (n != R_office_mang) {
X		printf("There is no safe here. \n") ;
X		return ;
X	}
X	if (room[R_office_mang][M_rm_status] != S_open) {
X		printf("I can't do it because the safe is closed. \n") ;
X		return ;
X	}
X}
X
X/* Special case of "take pill" */
Xif ((tag[V_pill])&&(object[O_pills][J_loc] == B_have)) {
X	eater() ;
X	return ;
X}
X
X/* Reject "take" command when there is nothing to take */
Xif ((n != R_office_mang)&&(verb != V_attach)&&(verb != V_remove)&&
X	(room[n][M_obj_cnt] <= 0)&&(room[n][M_gleep] == 0)&&
X	(!((n == R_gleep_tank)&&(gleep_score > 0)))&&
X	(room[n][M_rm_type] != T_unmovable_obj)) {
X	printf ("There is nothing here that you can take! \n");
X	return ;
X}
X
X/* player takes something from the gleep tank */
Xif (tag[V_tank]) {
X	if (n != R_gleep_tank) {
Xprintf("I see no gleep tank to take anything from. \n") ;
X		return ;
X	}
Xprintf("\nYou climb up onto the edge of the gleep tank and reach\n");
Xprintf("into the dark blue fluid.  Suddenly the fluid begins a\n");
Xprintf("furious boiling that instantly reduces your hand into\n") ;
Xprintf("bleached white bones.  The shock and pain disturbs your\n");
Xprintf("balance and you fall into the horrible stuff!!  There is\n");
Xprintf("once again a furious boiling.  Eventually the fluid stills\n");
Xprintf("and becomes clear again.  On the bottom of the tank can\n") ;
Xprintf("be seen a white, clean, \"medical school quality\" human\n");
Xprintf("skeleton.\n") ;
X	ender(F_died) ;
X}
X 
X/* gleep taking routine */
Xif (tag[V_gleep]) {
Xif (!tag[V_safe]) {
X
X	/* This block is for inaccessible or nonexistant gleeps */
X	if ((room[n][M_gleep] == 0)&&(!((n == R_office_mang)&&
X(room[R_office_mang][M_rm_status] == S_open)&&(gleep_safe != 0)))) {
X
X		if ((n != R_gleep_tank)||(gleep_score == 0)) {
Xprintf("There are no gleeps here to take!\n") ;
X			return ;
X		}
X		else {
Xprintf("There are no gleeps on the floor but I see ") ;
X			if (gleep_score == 1) 
X				printf("a gleep in the gleep tank.\n");
X			else
Xprintf("%d gleeps in the gleep tank.\n",gleep_score) ;
X			return ;
X		}
X	}
X
X	/* This block is for accessible gleeps */
X	if ((n == R_office_mang)&&
X(room[R_office_mang][M_rm_status] == S_open)&&(gleep_safe != 0)) {
X		gleep_holder = gleep_safe ;
X	}
X	else gleep_holder = 0 ;
X
X	if ((!tag[V_PLURAL])||
X		(room[n][M_gleep]+gleep_holder == 1)) {
X		printf("Gleep taken. \n") ; 
X		++gleep_count ;
X		if (gleep_holder == 0) --room[n][M_gleep] ;
X		else --gleep_holder ;
X	}
X	else {
X		printf("Gleeps taken. \n") ; 
X		gleep_count += room[n][M_gleep] + gleep_holder ;
X		room[n][M_gleep] = 0 ;
X		gleep_holder = 0 ;
X	}
X	gleep_safe = gleep_holder ;
X	return ;
X}
Xelse {
X	if ((n == R_office_mang)&&
X(room[R_office_mang][M_rm_status] == S_open)&&(gleep_safe != 0)) { 
X		if (tag[V_PLURAL]) {
X			printf("Gleeps taken from safe. \n") ; 
X			gleep_count += gleep_safe ;
X			gleep_safe = 0 ;
X		}
X		else {
X			printf("Gleep taken from safe. \n") ; 
X			++gleep_count ;
X			--gleep_safe ;
X		}
X	}
X	else printf("There are no gleeps in the safe!\n") ;
X	return ;
X}
X} /* end of the gleep taking block */
X
X/* deal with the special case of the platypus picture */
Xif ((n == R_office_mang) && tag[V_picture]) {
Xprintf("The picture can not be removed.  It appears to be hinged ");
Xprintf("to the wall. \n");
X	return ;
X}
X
X/* treat the verb "remove" in the context of "remove clip from rifle" */
Xif (verb == V_remove) {
X	if ((!tag[V_safe])&&(ammo_flag != F_no_clip)) {
X		clip_out(n) ;
X		return ;
X	}
X}
X
Xif (carry_count > 5) {
Xprintf("I can't do it!\n") ;
Xprintf("I'm holding so many things that I can't take anymore!\n") ;
X	return ;
X}
X
Xif (carry_weight >= 800) {
Xprintf("I can't do it!\n") ;
Xprintf("This junk I'm carrying is too heavy! I can't carry anymore!\n");
X	return ;
X}
X
X
X/* find the object(s) in this room */
Xfor (i = 0; i <= objcnt; i++) {
X
X	if ((carry_count > 5)||(carry_weight >= 800)) break ;
X
X	/* See if the object is in the safe and was requested */
X	if ((n == R_office_mang)&&(object[i][J_loc] == B_in_safe)&&
X        (tag[object[i][J_parse_id]]||tag[V_all])&&
X	(room[R_office_mang][M_rm_status] == S_open)&&
X	((!tag[V_treasure])||(object[i][J_value] > 0))) {
X		object[i][J_loc] = B_have; 
X		carry_count++ ;
X		carry_weight += object[i][J_weight] ; 
X		sw_done = TRUE ;
X	} 
X	
X	/* See if the object is in the room and was requested */
X	if ((object[i][J_loc] == n)&&(tag[object[i][J_parse_id]]||
X		tag[V_all])&&
X		((!tag[V_treasure])||(object[i][J_value] > 0))) {
X		/* see if the object can be taken */
X		if ((object[i][J_type] == Z_normal)||
X			(object[i][J_type] == Z_alias)) {
X			--room[n][M_obj_cnt] ;
X			carry_count++ ;
X			carry_weight += object[i][J_weight] ; 
X			object[i][J_loc] = B_have; 
X			sw_done = TRUE ;
X		} 
X
X		/* see if this is a nonmovable, nonacting object */
X		if ((object[i][J_type] == Z_unmovable) &&
X			(object[i][J_loc] == n) && (!tag[V_all])) {
X
X			switch(object[i][J_parse_id]) {
X			case V_bulldust:
Xprintf("The bulldust is so fine that it wafts away with a touch.\n") ;
X				return ;
X
X			/* Silver gong */
X			case V_gong:
Xprintf("The siver gong is about three metres in diameter and weighs at\n") ;
Xprintf("least a ton!  There is no way I could move it, let alone get\n") ;
Xprintf("it through the tunnel!\n") ;
X				return ;
X
X			/* Cockroach(es) */
X			case V_cockroach:
Xprintf("I will not touch the filthy things!\n") ;
X				return ;
X
X			/* Kangaroo(s) */
X			case V_kangaroo:
Xprintf("I will not touch a dead maggoty kangaroo!  ") ;
Xprintf("The smell is bad enough!\n") ;
X				return ;
X
X			case V_poster:
Xprintf("I think this sort of poster is best left on the wall.\n") ;
X				return ;
X
X			/* Spinifex(es) */
X			case V_spinifex:
Xprintf("The thorns on the spinifex are large and nasty.\n") ;
Xprintf("I'll just leave them to roll about.\n") ;
X				return ;
X			} /* end of switch block */
X		} /* end of nonmovable object block */ 
X
X		/* see if taking the object causes special action */
X		if (object[i][J_type] == Z_transform) {
X			switch(object[i][J_parse_id]) {
X			/* ACME doormat */
X			case V_mat:
Xprintf("As you lift up the dirty old doormat, you find half \n") ;
Xprintf("hidden in the dust....  a large brass key. \n") ;
X				object[O_mat][J_type] = Z_normal ;
X				carry_count++ ;
X				carry_weight += object[O_mat][J_weight];
X				object[O_mat][J_loc] = B_have;
X				object[O_key][J_loc] =R_office_entr ;
X				sw_done = TRUE ;
X				return ;
X
X			/* Map of the ACME Mine */
X			case V_map:
Xprintf("As you picked up the old map from the floor, most of it");
Xprintf(" crumbled into \ndust leaving only one small piece. \n") ;
X				object[O_map][J_loc] = B_unmade ;
X				object[O_map_frag][J_loc] = B_have ;
X				carry_count++ ;
X			carry_weight += object[O_map_frag][J_weight] ;
X				--room[n][M_obj_cnt] ;
X				sw_done = TRUE ;
X				return ;
X			}
X		} /* end of the special action block */ 
X	} 
X} /* end of the object scan loop */
X
X/* take all gleeps if any */
Xif (tag[V_all]&&(!tag[V_treasure])) {
X	if (room[n][M_gleep] > 0) { 
X		gleep_count += room[n][M_gleep] ;
X		room[n][M_gleep] = 0 ;
X		sw_done = TRUE ;
X	}
X	if ((gleep_safe != 0)&&(n == R_office_mang)&&
X		(room[R_office_mang][M_rm_status] == S_open)) {
X		gleep_count +=  gleep_safe ;
X		gleep_safe = 0 ;
X		sw_done = TRUE ;
X	}
X}
X
X/* Announce the "take" was successful */
Xif (sw_done) {
X	if (((carry_count > 5)||(carry_weight >= 800))&&(tag[V_all])) 
X		printf("You've taken as much as you can.\n") ;
X	else printf ("Done \n");
X}
X/* --or-- announce the "take" was unsuccessful */
Xelse  {
X	if (tag[V_all]) printf("I see nothing which I can take.\n") ;
X	else { 
X		if (tag[V_VERB_ONLY]) 
X			printf("What exactly should I take?\n") ;
X		else {
X			printf ("I don't see a") ;
X			if (tag[V_PLURAL]) printf("ny") ;
X			printf (" %s around here. \n",vocab[sent[1]-1]);
X		}
X	}
X}
Xreturn ;
X
X} /* --- end of the "taker" subroutine --- */
X
Xvoid loader()
X/*********************************************************/
X/*                                                       */
X/*           --- Rifle Loading Subroutine ---            */
X/*                                                       */
X/*      Program by Gary A. Allen, Jr.  29 April 1990     */
X/*        (c) Copyright 1992 by Gary A. Allen, Jr.       */
X/*                                                       */
X/*********************************************************/
X{
X
Xint ammo_flag ;
X
X#if (PROTOTYPE)
Xvoid clip_in(int) ;
X#endif
X
X/* Reject single verb load command */
Xif (tag[V_VERB_ONLY]) {
Xprintf("What exactly do you want me to load?\n") ;
X	return ;
X}
Xif (!tag[V_rifle]) {
Xprintf("I don't know how I could load that.\n") ;
X	return ;
X}
X
X/* Deal with implied clip type command */
Xif (!tag[V_clip]) {
Xif ((object[O_clip][J_loc] != B_have)&&
X	(object[O_org_clip][J_loc] == B_have)) ammo_flag = F_org_clip ;
Xif ((object[O_clip][J_loc] == B_have)&&
X     (object[O_org_clip][J_loc] != B_have)) ammo_flag = F_normal_clip ;
X	/* the case were there is no clip is found in clip_in */
X}
X
X/* Deal with specific "load [orange] clip" command */
Xelse {
X	if (tag[V_orange]) {
X		if (object[O_org_clip][J_loc] == B_have) 
X			ammo_flag = F_org_clip ;
X		else {
Xprintf("You don't possess the orange ammunition clip.\n") ;
X			return ;
X		}
X	}
X	else {
X		if (object[O_clip][J_loc] == B_have)
X			ammo_flag = F_normal_clip ;
X
X/* assume "load clip" with no normal clip implies orange clip */
X		else {
X			if (object[O_org_clip][J_loc] == B_have) 
X				ammo_flag = F_org_clip ;
X			else{
Xprintf("You don't possess an ammunition clip to load.\n") ;
X				return ;
X			}
X		}
X	}
X}
X
Xclip_in(ammo_flag) ;
X} /* --- end of the "loader" subroutine --- */
X
Xvoid unloader(n)
X/*********************************************************/
X/*                                                       */
X/*          --- Rifle Unloading Subroutine ---           */
X/*                                                       */
X/*      Program by Gary A. Allen, Jr.  29 April 1990     */
X/*        (c) Copyright 1992 by Gary A. Allen, Jr.       */
X/*                                                       */
X/*********************************************************/
Xint n ;
X{
X#if (PROTOTYPE)
Xvoid clip_out(int) ;
X#endif
X
X/* Reject single verb load command */
Xif (tag[V_VERB_ONLY]) {
Xprintf("What exactly do you want me to unload?\n") ;
X	return ;
X}
Xif (!tag[V_rifle]) {
Xprintf("I don't know how I could unload that.\n") ;
X	return ;
X}
Xclip_out(n) ;
X} /* --- end of the "unloader" subroutine --- */
X
Xvoid dropper(n)
X/*********************************************************/
X/*                                                       */
X/*          --- Object Dropping Subroutine ---           */
X/*                                                       */
X/*      Program by Gary A. Allen, Jr.  21 May 1990       */
X/*        (c) Copyright 1992 by Gary A. Allen, Jr.       */
X/*                                                       */
X/*********************************************************/
Xint n ;
X{
Xregister int i, k ;
X
Xint sw_possess, sw_done, ammo_flag, sw_object, i_10, i_fract ;
Xint sw_found ;
X
X#if (PROTOTYPE)
Xvoid clip_in(int), clip_out(int), boom(void) ;
Xvoid objlooker(int), gleeper(int), unlocker(int) ;
Xvoid cap_drop(void), dynamite_drop(void), destroy_all(void) ;
Xvoid dropped_gun(void) ;
X#endif
X
X/* respond to "verb only" command */
Xif (tag[V_VERB_ONLY]) {
X	printf ("You'll have to be more specific. \n");
X	return ;
X}
X
X/* deal with special case of "orange clip" implied by its being alone */
Xif (tag[V_clip]&&(object[O_clip][J_loc] != B_have)&&
X	(clip_flag != F_normal_clip)&&
X   ((object[O_org_clip][J_loc] == B_have)||(clip_flag == F_org_clip))) {
X	tag[V_org_clip] = TRUE ;
X	tag[V_clip] = FALSE ;
X	if (V_clip == sent[1]) sent[1] = V_org_clip ;
X}
X
Xammo_flag = F_no_clip ;
Xif (tag[V_clip])  ammo_flag = F_normal_clip ;
Xif (tag[V_org_clip])  ammo_flag = F_org_clip ;
X
X/* deal with special cases of the verbs */
Xswitch(verb) {
Xcase V_put:
X	/* special case of putting (destroying) an object in water */
X	if (tag[V_tank]||tag[V_gleep]||tag[V_safe]||
X		tag[V_river]||tag[V_billabong]||tag[V_stream]) break ;
X
X	/* special case of "put key in door(lock)" */
X	if (tag[V_key] && tag[V_door]) {
X		unlocker(n) ;
X		return ;
X	}
X
X	if (!tag[V_cap]) {
X		if ((!tag[V_rifle])&&(ammo_flag != F_no_clip)) {
X			printf("What am I to put the clip into? \n") ;
X			return ;
X		}
X		if (tag[V_rifle]&&(ammo_flag != F_no_clip))  
X				clip_in(ammo_flag) ;
X		else 
Xprintf("I don't understand what this is to be put into. \n") ;
X		return ;
X	}
X
Xcase V_insert:
X	if (tag[V_safe]) break ;
X	if (ammo_flag != F_no_clip) {
X		if (!tag[V_rifle]) {
Xprintf("What am I to insert the clip into? \n") ;
X		}
X		else {
X			clip_in(ammo_flag) ;
X		}
X		return ;
X	}
X	if (tag[V_cap]) {
X		if (!tag[V_dynamite]) {
Xprintf("I see no reason why I should put a blasting cap into that.\n") ;
X			return ;
X		}
X		/* Cap insertion routine */
X		else {
X			/* see if your are holding the dynamite or the cap */
X			if ((object[O_cap][J_loc] != B_have)&&
X				(object[O_dynamite][J_loc] != B_have)) {
Xprintf("You bloody dill!  You have neither the dynamite or a ");
Xprintf("blasting cap.\n") ;
X				return ;
X			}
X			if (object[O_cap][J_loc] != B_have) {
Xprintf("You've got the dynamite but you need a blasing cap.\n") ;
X				return ;
X			}
X				if (object[O_dynamite][J_loc] != B_have) {
Xprintf("You've got the blasting cap but you need some dynamite.\n") ;
X				return ;
X			}
X/* transform the two objects into one */
Xprintf("With some trepidation, you slide the blasting cap into\n");
Xprintf("the dynamite.  What you are now holding is VERY dangerous.\n");
X			object[O_cap][J_loc] = B_unmade ; 
X			object[O_dynamite][J_type] = Z_alias ;
X			carry_weight -= object[O_cap][J_weight] ;
X			carry_count-- ;
X			return ;
X		} /* end of the cap insertion block */
X	}
Xprintf("I can think of some interesing places to insert this. \n") ;
Xprintf("However I shall not reduce myself to such vulgarity.\n");
X	return ;
X	
Xcase V_eject:
X/* Command "eject clip" ejects clip from rifle no matter what type*/
X	if ((ammo_flag == F_normal_clip)&&(clip_flag == F_org_clip)) 
X		ammo_flag = F_org_clip ; 
Xcase V_drop:
X	if (((ammo_flag == F_org_clip)&&(clip_flag == F_org_clip))|| 
X	((ammo_flag == F_normal_clip)&&(clip_flag == F_normal_clip))) { 
X		clip_out(n) ;
X		return ;
X	}
X	break ;
X
X} /* end of switch */
X
X/* Deal with "drop" when player has no objects */
Xif (tag[V_all]&&(carry_count == 0)&&(gleep_count == 0)) {
X	printf("You dill!  You have nothing to drop!\n") ;
X	return ;
X}
X
X/* deal with "drop in safe ..." errors */
Xif (tag[V_safe]) {
X/* see if this is the managers office */
X	if (n != R_office_mang) {    	
X		printf("There is no safe here! \n");
X		return ;
X	}
X/* See if the safe is open */
X	if (room[R_office_mang][M_rm_status] != S_open) {
X		printf ("I can't do it!  The safe is closed. \n");
X		return ;
X	}
X}
X 
X/* gleep droping routine */
Xif (tag[V_gleep]||tag[V_tank]) {
X	/* drop gleeps in a normal way */
X	if (!tag[V_tank]) {
X		if (gleep_count == 0) { 
X			printf("You have no gleeps to drop! \n") ;
X			return ;
X		}
X		if ((!tag[V_PLURAL])||(gleep_count == 1)) {
X			if (tag[V_safe]) {
X				printf("Gleep put into safe.\n") ;
X				++gleep_safe ;
X				--gleep_count ;
X			}
X			else {
X				printf("Gleep dropped. \n") ; 
X				--gleep_count ;
X				++room[n][M_gleep] ;
X			}
X		}
X		else {
X			if (tag[V_safe]) {
X				printf("Gleeps put into safe.\n") ;
X				gleep_safe += gleep_count ;
X				gleep_count = 0 ;
X			}
X			else {
X				printf("Gleeps dropped. \n") ; 
X				room[n][M_gleep] += gleep_count ;
X				gleep_count = 0 ;
X			}
X		}
X		gleep_drop = TRUE ;
X		return ;
X	}
X	/* drop objects(including gleeps) into a gleep tank */
X	else {
X		sw_found = FALSE ;
X		if (n != R_gleep_tank) {
X			printf("I don't see a gleep tank here. \n") ;
X			return ;
X		}
X		if (tag[V_gleep]) {
X			if (gleep_count <= 0) {
Xprintf("You have no gleeps to put in the tank. \n") ; 
X				return ;
X			}
X			sw_found = TRUE ;
X			if ((!tag[V_PLURAL])||(gleep_count == 1)) {
Xprintf("Your gleep falls into the tank with a \"plonk\".\n") ;
X				++gleep_score ;
X				--gleep_count ;
X			}
X			if (tag[V_PLURAL]&&(gleep_count > 1)) {
Xprintf("Your gleeps fall into the tank causing a splash.\n") ;
X				gleep_score += gleep_count ;
X				gleep_count = 0 ;
X			}
X		}
X
X		/* drop non-gleeps into the tank */
X
X		/* the "drop all" routine */
X		if (tag[V_all]) {
X			sw_possess = FALSE ;
X			for (i = 0; i <= objcnt; i++) {
X				if ((object[i][J_loc] == B_have)&&
X					((!tag[V_treasure])||
X					(object[i][J_value] > 0))) {
X					sw_possess = TRUE ;
X					object[i][J_loc] = B_destroyed; 
X					carry_count-- ;
X				carry_weight -= object[i][J_weight] ;
X				}
X			}
X			if (gleep_count == 0) {
X				if (sw_possess) {
Xprintf("You dump everything into the gleep tank. There is a furious\n");
Xprintf("bubbling as the corrosive fluid of the tank turns the\n");
Xprintf("objects into NOTHING.\n") ;
X				}
X				else 
Xprintf("You've got nothing to throw into the tank.\n") ;
X			}
X			else {
X				if (sw_possess) {
Xprintf("You fling everything into the gleep tank.  The gleep");
X				if (gleep_count > 1) {
Xprintf("s\nsplash into the tank and settle to the bottom of the\n") ;
X				}
X				else {
Xprintf("\nplonks into the tank and settles to the bottom of the\n") ;
X				}
Xprintf("tank.  However the other objects begin to dissolve the\n");
Xprintf("moment the tank's fluid touches them.  Time passes and\n");
Xprintf("the objects dissolve into NOTHING.\n") ;
X				}
X				/* you possess no non-gleeps */
X				else {
X				if (gleep_count == 1) 
Xprintf("Your gleep falls into the tank with a \"plonk\".\n") ;
X				else
Xprintf("Your gleeps fall into the tank causing a splash.\n") ;
X				}
X			gleep_score += gleep_count ;
X			gleep_count = 0 ;
X			}
X			return ;
X		} /* end of the "drop all" if block */
X
X		/* Individual non-gleeps are dropped into the tank */
X
X		/* see if your are holding the object(s) */
X		for (i=0; i <= objcnt; i++) {
X 			if (tag[object[i][J_parse_id]]) {
X				if (object[i][J_loc] == B_have) {
Xprintf ("You fling the %s into the gleep tank.  As soon as it\n",
X	vocab[object[i][J_parse_id]-1]);
Xprintf ("touched the tank's fluid there was a furious effervescence\n");
Xprintf ("as it began to dissolve.  With the passage of time, the\n") ;
Xprintf ("fluid stills and there is NOTHING left.\n") ;
X					carry_count-- ;
X				carry_weight -= object[i][J_weight] ;
X					object[i][J_loc] = B_destroyed; 
X				}
X				else {
Xprintf("You don't have a %s to toss into the gleep tank.\n",
X	vocab[object[i][J_parse_id]-1]);
X				}
X				return ;
X			}
X		} /* object scan "for" loop */
X
X		/* deal with garbage object to drop */
Xif (!sw_found) printf("I don't understand what you want me to drop.\n") ;
X		return ;
X	}
X}
X
Xsw_done = FALSE ;
X
X/* the "drop all" routine */
Xif (tag[V_all]) {
X
X	/* Deal with throwing stuff into water */
X	if(tag[V_stream]) {
X		if (n == R_stream) {
Xprintf("You fling everything into the stream.\n");
X			destroy_all() ;
X			return ;
X		}
X		else
Xprintf("I see no stream to toss stuff into.\n") ;
X		return ;
X	}
X	if(tag[V_billabong]) {
X		if ((n == R_stream)||(n == R_slime)||
X			(n == R_billabong)) { 
Xprintf("You fling everything into the billabong.\n");
X			destroy_all() ;
X			return ;
X		}
X		else
Xprintf("I see no billabong to toss stuff into.\n") ;
X		return ;
X	}
X	if(tag[V_river]) {
X		if ((n == R_dike)||(n == R_river_edge)||
X			(n == R_river_exit)) {
Xprintf("You fling everything into the river.\n");
X			destroy_all() ;
X			return ;
X		}
X		else
Xprintf("I see no river to toss stuff into.\n") ;
X		return ;
X	}
X
X	if (!tag[V_safe]) {
X/* normal drop */
Xif (room[n][M_rm_type] != T_looping) {
X	/* normal room */
X	for (i = 0; i <= objcnt; i++) {
X		if ((object[i][J_loc] == B_have)&&
X			((!tag[V_treasure]) || (object[i][J_value] > 0))) {
X
X		sw_done = TRUE ;
X
X		/* see if the blasting cap was hard dropped */
X		if ((i == O_cap)&&(verb != V_slow_drop)) {
X			cap_drop() ;
X			return ;
X		}
X
X/* see if the dynamite with blasting cap was hard dropped */
X		if ((i == O_dynamite)&&(object[O_dynamite][J_type] == Z_alias)
X			&&(verb != V_slow_drop)) dynamite_drop() ;
X		++room[n][M_obj_cnt] ;
X		carry_count-- ;
X		carry_weight -= object[i][J_weight] ;
X		object[i][J_loc] = n; 
X/* set valuable switch if valuable object dropped in Ned's area */
X		if (object[i][J_value] > 0) {
X			for (k = 22; k <= 41; k++) 
X				if (k == n) sw_valuable = TRUE;
X			for (k = 144; k <= 146; k++) 
X			 	if (k == n) sw_valuable = TRUE;
X		}
X	}
X}
X			/* drop all gleeps */
X			if ((gleep_count > 0) &&
X					(!tag[V_treasure])) {
X				room[n][M_gleep] += gleep_count ;
X				gleep_count = 0 ;
X				sw_done = TRUE ;
X				gleep_drop = TRUE ;
X			}
X
X			if (sw_done) {
X				printf ("Done\n");
X				objlooker(n) ;
X				gleeper(n) ; 
X			} 
X			else printf("Don't have it to drop.\n") ;
X			return ;
X		}
X		/* object destroyer room */
X		else {
X		/* Code assumes that player has something to drop */
Xprintf ("You dropped everything you had in a heap, which \n");
Xprintf ("promptly vaporized into a bright blue flash followed \n");
Xprintf ("by a low \"BOOM\". \n") ; 
Xprintf ("       --- You've blown it Bozo!! ---\n") ;
X			destroy_all() ;
X			return ;
X		}
X	}
X	/* "drop all into the safe" routine */
X	else {
X		for (i = 0; i <= objcnt; i++) {
X			if ((object[i][J_loc] == B_have) &&
X				((!tag[V_treasure])||
X				(object[i][J_value] > 0))) {
X				object[i][J_loc] = B_in_safe ;	
X				carry_count-- ;
X				carry_weight -= object[i][J_weight] ;
X				sw_done = TRUE ;
X			}
X		}
X		if (!tag[V_treasure]) {
X			gleep_safe += gleep_count ;
X			gleep_count = 0 ;
X			sw_done = TRUE ;
X		}
X		if (sw_done) printf ("Done \n");
X		else printf("You don't have it to put in the safe!\n") ;
X		return ;
X	}
X}
X
X/* see if your are holding the object(s) */
Xfor (i=0; i <= objcnt; i++) {
X	sw_object = FALSE ;
X	if (tag[object[i][J_parse_id]]) {
X		sw_object = TRUE ;
X 		if (object[i][J_loc] == B_have) {
X			/* Safe storage routine */
X			if (tag[V_safe]) {
X				object[i][J_loc] = B_in_safe ;	
Xprintf ("The %s is now inside the safe. \n", 
X	vocab[object[i][J_parse_id]-1]);
X				sw_done = TRUE ;
X				carry_count-- ;
X				carry_weight -= object[i][J_weight] ;
X				continue ;
X			}
X 
X			/* Single 'drop' routine */
X			if (tag[V_river]||tag[V_billabong]||
X				tag[V_stream]) {
X		/* The object is to be dropped in water */
X				if(tag[V_stream]) {
X					if (n == R_stream) {
Xprintf("You fling the %s into the stream.\n", 
X	vocab[object[i][J_parse_id]-1]);
X					carry_count-- ;
X				carry_weight -= object[i][J_weight] ;
X					object[i][J_loc] = B_destroyed; 
X					return ;
X					}
X					else
Xprintf("I see no stream to toss it into.\n") ;
X					return ;
X				}
X			if(tag[V_billabong]) {
X				if ((n == R_stream)||
X				(n == R_slime)||(n == R_billabong)) { 
Xprintf("You fling the %s into the billabong.\n",
X	vocab[object[i][J_parse_id]-1]);
X					carry_count-- ;
X				carry_weight -= object[i][J_weight] ;
X					object[i][J_loc] = B_destroyed; 
X					return ;
X				}
X				else
Xprintf("I see no billabong to toss it into.\n") ;
X				return ;
X			}
X			if(tag[V_river]) {
X				if ((n == R_dike)||(n == R_river_edge)||
X					(n == R_river_exit)) {
Xprintf("You fling the %s into the river.\n", 
X	vocab[object[i][J_parse_id]-1]);
X					carry_count-- ;
X				carry_weight -= object[i][J_weight] ;
X					object[i][J_loc] = B_destroyed; 
X					return ;
X				}
X				else
Xprintf("I see no river to toss it into.\n") ;
X				return ;
X			}
X		}
X		/* Normal Drop */
X		else if (room[n][M_rm_type] != T_looping) {
X			if ((i == O_cap)&&(verb != V_slow_drop)) {
X				cap_drop() ;
X				return ;
X			}
X			if ((i==O_dynamite)&&(verb != V_slow_drop)&&
X		(object[O_dynamite][J_type] == Z_alias)) dynamite_drop();
X
X/* If the he rifle is dropped.  See if it kills the player */
Xif (i==O_rifle) {
X	if ((clip_flag != F_no_clip) && 
X(object[O_rifle][J_property] > 0)) switch(rifle_flag) {
X	case F_safety:
X		break ;
X			
X	case F_single:
X		printf("\nBam!\n") ;
X		dropped_gun() ;
X
X	case F_triple:
X		printf("\n") ;
X		if (object[O_rifle][J_property] >= 3) {
X			printf("Bam! Bam! Bam! \n\n") ;
X		}
X		else {
X		for (i = 1; i <= object[O_rifle][J_property]; i++) 
X			printf("Bam! ") ;
X		}
X		dropped_gun() ;
X
X	case F_auto:
X		printf("\n") ;
X		if (object[O_rifle][J_property] >= 30) {
X			for (i = 1; i <= 3; i++) 
Xprintf("Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! \n") ;
X		}
X		else {
X			i_10 = object[O_rifle][J_property]/10 ;
X		i_fract = object[O_rifle][J_property]-(i_10*10) ;
X			for (i = 1; i <= i_10; i++) 
Xprintf("Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! Bam! \n") ;
X			for (i = 1; i <= i_fract; i++) 
X				printf("Bam! ") ;
X		}
X		dropped_gun() ;
X	} /* end of the switch block */
X} /* end of "drop rifle" block */
X
X			carry_count-- ;
X			carry_weight -= object[i][J_weight] ;
X			++room[n][M_obj_cnt] ;
X			object[i][J_loc] = n; 
X			sw_done = TRUE ;
X/* set valuable switch if valuable object dropped in Ned's area */
X			if (object[i][J_value] > 0) {
X				for (k = 22; k <= 41; k++) 
X					if (k == n) sw_valuable = TRUE ;
X				for (k = 144; k <= 146; k++) 
X					if (k == n) sw_valuable = TRUE ;
X			}
X			continue ;
X		}
X		else {
Xprintf ("As the %s left your possession there was a bright \n",
X	vocab[object[i][J_parse_id]-1]);
Xprintf ("blue flash, followed by a low \"BOOM\" as it vaporized \n");
Xprintf ("into nonexistence. \n");
X			carry_count-- ;
X			carry_weight -= object[i][J_weight] ;
X			object[i][J_loc] = B_destroyed; 
X			return ;
X		}
X		}
X 		if (object[i][J_loc] == B_unmade) continue ;
X	} /* end of the object requested block */
X	if ((!sw_done)&&sw_object) {
Xprintf("You do not possess a %s.\n", vocab[object[i][J_parse_id]-1]);
X		return ;
X	}
X} /* end of the object scan loop */
Xif (sw_done) {
X	printf ("Done \n");
X	objlooker(n) ;
X	gleeper(n) ; 
X} 
Xelse 
Xprintf("I don't understand what it is I'm supposed to drop.\n") ;
X
Xreturn ;
X
X
X} /* --- end of the "dropper" subroutine --- */
X
Xvoid cap_drop()
X/*********************************************************/
X/*                                                       */
X/*         --- Blasing Cap Dropping Subroutine ---       */
X/*                                                       */
X/*      Program by Gary A. Allen, Jr.  6 December 1992   */
X/*        (c) Copyright 1992 by Gary A. Allen, Jr.       */
X/*                                                       */
X/*********************************************************/
X{
Xprintf("Bang!! The blasting cap you were carrying detonated when\n") ;
Xprintf("it hit the ground.  Fortunately no damage was caused.\n") ;  
Xobject[O_cap][J_loc] = B_destroyed; 
Xcarry_count-- ;
Xcarry_weight -= object[O_cap][J_weight] ;
X
X} /* --- end of the "cap_drop" subroutine --- */
X
Xvoid dynamite_drop()
X/*********************************************************/
X/*                                                       */
X/*           --- Dynamite Dropping Subroutine ---        */
X/*                                                       */
X/*      Program by Gary A. Allen, Jr.  6 December 1992   */
X/*        (c) Copyright 1992 by Gary A. Allen, Jr.       */
X/*                                                       */
X/*********************************************************/
X{
X#if (PROTOTYPE)
Xvoid ender(int), boom(void) ;
X#endif
X
Xboom() ;
Xprintf("Dropping a stick of dynamite with a blasting cap in it\n");
Xprintf("ranks high as one of the dumbest things a person can do.\n") ;
Xprintf("Needless to say you were blown to bits. Next time drop\n") ;
Xprintf("the dynamite slowly or gently.\n") ;
Xender(F_died) ;
X
X} /* --- end of the "dynamite_drop" subroutine --- */
X
Xvoid destroy_all()
X/*********************************************************/
X/*                                                       */
X/*        --- Destroy Everything Held Subroutine ---     */
X/*                                                       */
X/*      Program by Gary A. Allen, Jr.  6 December 1992   */
X/*        (c) Copyright 1992 by Gary A. Allen, Jr.       */
X/*                                                       */
X/*********************************************************/
X{
Xregister int i ;
X
Xgleep_count = 0 ;
Xcarry_count = 0 ;
Xcarry_weight = 0 ;
Xfor (i = 0; i <= objcnt; i++) {
X	if (object[i][J_loc] == B_have)  object[i][J_loc] = B_destroyed; 
X}
X} /* --- end of the "destroy_all" subroutine --- */
X
Xvoid dropped_gun()
X/*********************************************************/
X/*                                                       */
X/*     --- Player Suicides by Dropping Armed Rifle ---   */
X/*                                                       */
X/*      Program by Gary A. Allen, Jr.  31 December 1992  */
X/*        (c) Copyright 1992 by Gary A. Allen, Jr.       */
X/*                                                       */
X/*********************************************************/
X{
X#if (PROTOTYPE)
Xvoid ender(int) ;
X#endif
X
Xprintf("\n") ;
Xprintf("Dropping a loaded and armed automatic rifle is a stupid way\n");
Xif ((object[O_rifle][J_property] == 1) || (rifle_flag == F_single)) {
Xprintf("to commit suicide.  Needless to say you were hit by the\n") ;
Xprintf("bullet after the rifle went off.\n") ;
X}
Xelse {
Xprintf("to commit suicide.  The bullets shot from the rifle fly\n") ;
Xprintf("around.  One of them bounces back and hits you!\n") ;
X}
Xender(F_died) ;
X} /* --- end of the "dropped_gun" subroutine --- */
END_OF_FILE
if test 31011 -ne `wc -c <'taker.c'`; then
    echo shar: \"'taker.c'\" unpacked with wrong size!
fi
# end of 'taker.c'
fi
echo shar: End of archive 3 \(of 7\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
