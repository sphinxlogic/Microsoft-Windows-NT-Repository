Path: uunet!news.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v15i048:  xbomb - minesweeper game with extra features, Part01/04
Message-ID: <4223@master.CNA.TEK.COM>
Date: 18 Jan 93 20:08:38 GMT
Sender: news@master.CNA.TEK.COM
Lines: 1855
Approved: billr@saab.CNA.TEK.COM
Xref: uunet comp.sources.games:1547

Submitted-by: johnh@FICUS.CS.UCLA.EDU (John Heidemann)
Posting-number: Volume 15, Issue 48
Archive-name: xbomb/Part01
Environment: X11, Xlib

[From the authors:]
[[xbomb is an rewrite and extension of the minesweeper game found on
various PCs.  The object of the game is to clear a field of deadly
bombs.  To do this requires only two mouse buttons, one key and a
devastatingly clever man page which describes the game in greater
detail.

This version of minesweeper has MANY MANY features not available
in other versions.  We have:

        o Ted Mode--you'll love it (it's hard to explain, but you
          *will* love it

        o User-defined solvers (for that "boring" stuff between the
          fun part

        o A new and different scoring function

And much much more!]]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 4)."
# Contents:  README MANIFEST Makefile.std bitmaps bitmaps/old
#   bitmaps/roman bitmaps/standard graphics.c map.c patchlevel.h
#   xbomb.man
# Wrapped by billr@saab on Mon Jan 18 12:03:06 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1625 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
Xxbomb is Copyright (C) 1992 by Matthew Merzbacher, Los Angeles, CA.
XAll rights reserved.  Permission is granted to freely distribute
Xthis as long as this copyright message is retained intact.
XPermission to distribute this as part of a commerical product
Xrequires explicit permission of the author.
X
X------------------------------------------------------------
X
XPermission is also granted to play xbomb while bathing,
Xprovided appropriate electrical protection is in place.
X
X------------------------------------------------------------
X
Xxbomb is an rewrite and extension of the minesweeper game found on
Xvarious PCs.  The object of the game is to clear a field of deadly
Xbombs.  To do this requires only two mouse buttons, one key and a
Xdevastatingly clever man page which describes the game in greater
Xdetail.
X
XThis version of minesweeper has MANY MANY features not available
Xin other versions.  We have:
X
X	o Ted Mode--you'll love it (it's hard to explain, but you
X          *will* love it
X	
X	o User-defined solvers (for that "boring" stuff between the
X	  fun part
X
X	o A new and different scoring function
X
XAnd much much more!
X
XTo install:
X
X0.  Edit the Imakefile as necessary.
X1.  xmkmf
X2.  make depend
X3.  make
X4.  make install
X5.  make install.man
X
XThe latest version of xbomb is available for anonymous ftp
Xfrom ftp.cs.ucla.edu in pub/ficus.
X
XXbomb has been successfully built and installed on:
X	Sun4, SunOS 4.1.1, X11R5
X	Sun4, SunOS 4.1.1, X11R4
X	Sun3, unknown OS and X version
X	DECstation, unknown OS and X version
X	SGI, unknown OS and X version
X
XIf you successfully build this on other platforms, please let us know.
X
END_OF_FILE
if test 1625 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2308 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Imakefile                  2	
X MANIFEST                   1	This shipping list
X Makefile.std               1	
X README                     1	
X TODO                       4	
X actions.c                  2	
X applications.c             3	
X bitmap.files               2	
X bitmaps                    1	
X bitmaps/old                1	
X bitmaps/old/bomb.bit       4	
X bitmaps/old/ebomb.bit      4	
X bitmaps/old/empty.bit      4	
X bitmaps/old/flag.bit       4	
X bitmaps/old/icon.bit       4	
X bitmaps/old/known0.bit     4	
X bitmaps/old/known1.bit     3	
X bitmaps/old/known2.bit     4	
X bitmaps/old/known3.bit     4	
X bitmaps/old/known4.bit     3	
X bitmaps/old/known5.bit     3	
X bitmaps/old/known6.bit     3	
X bitmaps/old/known7.bit     3	
X bitmaps/old/known8.bit     3	
X bitmaps/old/known9.bit     4	
X bitmaps/roman              1	
X bitmaps/roman/known0.bit   3	
X bitmaps/roman/known1.bit   3	
X bitmaps/roman/known2.bit   3	
X bitmaps/roman/known3.bit   3	
X bitmaps/roman/known4.bit   3	
X bitmaps/roman/known5.bit   3	
X bitmaps/roman/known6.bit   3	
X bitmaps/roman/known7.bit   3	
X bitmaps/roman/known8.bit   3	
X bitmaps/roman/known9.bit   3	
X bitmaps/standard           1	
X bitmaps/standard/blank.bit  3	
X bitmaps/standard/bomb.bit  3	
X bitmaps/standard/ebomb.bit  3	
X bitmaps/standard/empty.bit  3	
X bitmaps/standard/flag.bit  3	
X bitmaps/standard/known0.bit  3	
X bitmaps/standard/known1.bit  3	
X bitmaps/standard/known2.bit  3	
X bitmaps/standard/known3.bit  3	
X bitmaps/standard/known4.bit  3	
X bitmaps/standard/known5.bit  3	
X bitmaps/standard/known6.bit  3	
X bitmaps/standard/known7.bit  3	
X bitmaps/standard/known8.bit  3	
X bitmaps/standard/known9.bit  3	
X bitmaps/standard/think.bit  3	
X debug_solver               3	
X forced_solver.c            3	
X graphics.c                 1	
X icon.bit                   4	
X infer_solver.c             2	
X main.c                     2	
X map.c                      1	
X patchlevel.h               1	
X pattern_solver.c           2	
X prob_solver.c              3	
X score.c                    2	
X solver_io.c                2	
X solver_io.h                4	
X solvers.c                  2	
X statistics                 3	
X xbomb.h                    3	
X xbomb.man                  1	
END_OF_FILE
if test 2308 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile.std' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.std'\"
else
echo shar: Extracting \"'Makefile.std'\" \(14703 characters\)
sed "s/^X//" >'Makefile.std' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.72.1.1 92/03/18 13:13:37 rws Exp $
X
X# operating system:  SunOS 4.1.1
X
X# $XConsortium: sunLib.rules,v 1.7 91/12/20 11:19:47 rws Exp $
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = etags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS = -s
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -g kmem -m 2755
X
X      PROJECTROOT = /usr/local
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS =
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = $(DESTDIR)/usr/local/lib
X           BINDIR = $(DESTDIR)/usr/dist/bin
X          INCROOT = $(DESTDIR)/usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(DESTDIR)/usr/lib/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/dist/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = 1
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X# $XConsortium: sunLib.tmpl,v 1.14.1.1 92/03/17 14:58:46 rws Exp $
X
XSHLIBLDFLAGS = -assert pure-text
XPICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X       XMULIBONLY = -lXmu
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
X#
X# xbomb imakefile
X#
X# %W% (UCLA) %G%
X#
X
X#
X# BEGIN: User customizable things.
X#
X
X# You probably want to change where things go
X         EXEDIR = /usr/dist/games
X       XBLIBDIR = /usr/dist/games/lib/xbomb
X      SCOREFILE = $(XBLIBDIR)/xbomb_score
X      BITMAPDIR = $(XBLIBDIR)/bitmaps
X
X      SOLVERDIR = $(XBLIBDIR)/solvers
X
X# You may want to make things not-setuid.
X# If so, scores must be world-writable.
X     XBOMBFLAGS = -o games -m 4755
X    SOLVERFLAGS = -o games
X    BITMAPFLAGS = -o games -m 644
X    CDEBUGFLAGS = -g
X
X           PERL = /usr/local/bin/perl
X
X# Your man pages may have funny endings.
X GAMESMANSUFFIX = 6
X
X# Things for various kinds of system brain-damange.
X
X# If your C libraries lack strdup, define LACKS_STRDUP.
X# (It's such a hard thing to QA, I can see why they don't provide it.)
X
X#
X# END: User customizable things.
X#
X
XDEFINES = -D_PATH_SCORE='"$(SCOREFILE)"' -D_PATH_SOLVERS='"$(SOLVERDIR)"' -D_PATH_BITMAPS='"$(BITMAPDIR)"'
X
XSRCS = $(XBOMB_SRCS) pattern_solver.c forced_solver.c prob_solver.c \
X	solver_io.c infer_solver.c
XTOSHAR += $(SRCS)
X
XHFILES = patchlevel.h solver_io.h xbomb.h icon.bit
XTOSHAR += $(HFILES)
X
XMANPAGE = xbomb.man
X
XTOSHAR += $(MANPAGE)
X
X#
X# xbomb is done by hand
X#
XXBOMB_SRCS = main.c map.c applications.c actions.c graphics.c solvers.c score.c
XXBOMB_OBJS = main.o map.o applications.o actions.o graphics.o solvers.o score.o
X
Xall:: xbomb
X
Xxbomb: $(XBOMB_OBJS)
X	$(RM) $@
X	$(CC) -o $@ $(XBOMB_OBJS) $(LDOPTIONS)  $(LDLIBS) $(XLIB) $(EXTRA_LOAD_FLAGS)
X
Xclean::
X	$(RM) xbomb
X
Xinstall:: xbomb
X	@if [ -d $(DESTDIR)$(EXEDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(EXEDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS) $(XBOMBFLAGS) xbomb $(DESTDIR)$(EXEDIR)
X
Xinstall.man:: xbomb.man
X	@if [ -d $(DESTDIR)$(OURMANSUFFIX) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(OURMANSUFFIX)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) xbomb.man $(MANSOURCEPATH)$(GAMESMANSUFFIX)/xbomb.$(GAMESMANSUFFIX)
X
Xclean::
X	$(RM) xbomb
X
X#
X# solvers follow
X#
X
Xall:: pattern_solver
X
Xpattern_solver: pattern_solver.o solver_io.o
X	$(RM) $@
X	$(CC) -o $@ pattern_solver.o solver_io.o $(LDOPTIONS)  $(LDLIBS)  $(EXTRA_LOAD_FLAGS)
X
Xclean::
X	$(RM) pattern_solver
X
Xinstall:: pattern_solver
X	@if [ -d $(DESTDIR)$(SOLVERDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(SOLVERDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS) $(SOLVERFLAGS) pattern_solver $(DESTDIR)$(SOLVERDIR)
X
Xclean::
X	$(RM) $(PROGRAM)
X
Xall:: forced_solver
X
Xforced_solver: forced_solver.o solver_io.o
X	$(RM) $@
X	$(CC) -o $@ forced_solver.o solver_io.o $(LDOPTIONS)  $(LDLIBS)  $(EXTRA_LOAD_FLAGS)
X
Xclean::
X	$(RM) forced_solver
X
Xinstall:: forced_solver
X	@if [ -d $(DESTDIR)$(SOLVERDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(SOLVERDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS) $(SOLVERFLAGS) forced_solver $(DESTDIR)$(SOLVERDIR)
X
Xclean::
X	$(RM) $(PROGRAM)
X
Xall:: prob_solver
X
Xprob_solver: prob_solver.o solver_io.o
X	$(RM) $@
X	$(CC) -o $@ prob_solver.o solver_io.o $(LDOPTIONS)  $(LDLIBS)  $(EXTRA_LOAD_FLAGS)
X
Xclean::
X	$(RM) prob_solver
X
Xinstall:: prob_solver
X	@if [ -d $(DESTDIR)$(SOLVERDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(SOLVERDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS) $(SOLVERFLAGS) prob_solver $(DESTDIR)$(SOLVERDIR)
X
Xclean::
X	$(RM) $(PROGRAM)
X
Xall:: infer_solver
X
Xinfer_solver: infer_solver.o solver_io.o
X	$(RM) $@
X	$(CC) -o $@ infer_solver.o solver_io.o $(LDOPTIONS)  $(LDLIBS)  $(EXTRA_LOAD_FLAGS)
X
Xclean::
X	$(RM) infer_solver
X
Xinstall:: infer_solver
X	@if [ -d $(DESTDIR)$(SOLVERDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(SOLVERDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS) $(SOLVERFLAGS) infer_solver $(DESTDIR)$(SOLVERDIR)
X
Xclean::
X	$(RM) $(PROGRAM)
X
Xstatistics.script: statistics
X	sed "s;/usr/.*/perl;$(PERL);" <statistics >statistics.script
X
XTOSHAR += statistics
X
Xinstall:: statistics.script
X	@if [ -d $(DESTDIR)$(SOLVERDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(SOLVERDIR)); fi
X	$(INSTALL) -c $(INSTBINFLAGS) statistics.script $(DESTDIR)$(SOLVERDIR)/statistics
X
Xdebug_solver.script: debug_solver
X	sed "s;/usr/.*/perl;$(PERL);" <debug_solver >debug_solver.script
X
XTOSHAR += debug_solver
X
Xinstall:: debug_solver.script
X	@if [ -d $(DESTDIR)$(SOLVERDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(SOLVERDIR)); fi
X	$(INSTALL) -c $(INSTBINFLAGS) debug_solver.script $(DESTDIR)$(SOLVERDIR)/debug_solver
X
X#
X# administrative stuff
X#
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
X# bitmap installation
X
Xinstall:: install.bitmaps
X
Xinstall.bitmaps: bitmap.files
X	@if [ -d $(BITMAPDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(BITMAPDIR)); fi
X	for i in `cat bitmap.files`; \
X	do \
X		j=`echo $$i|sed 's:^./bitmaps:./:'`; \
X		if [ "$$j" != "./" ]; then \
X			if [ -d $$i ]; then \
X				echo Installing dir $$i...; \
X				@if [ -d $(BITMAPDIR)/$$j ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(BITMAPDIR)/$$j); fi; \
X			else \
X				echo Installing bitmap $$i...; \
X				$(INSTALL) -c $(BITMAPFLAGS) $$i $(BITMAPDIR)/`dirname $$j`; \
X			fi; \
X		fi; \
X	done
X	@echo Bitmaps installed.
X
X#
X# distribution
X#
X
XTOSHAR += README TODO Imakefile Makefile.std
X
Xbitmap.files:
X	find ./bitmaps \( -name \*.bit -o -type d \) -print >bitmap.files
X
Xkit: Makefile.std
X	makekit $(TOSHAR) `cat bitmap.files`
X
Xshar: Makefile.std
X	shar $(TOSHAR) `cat bitmap.files` >xbomb.shar
X
XMakefile.std:
X	cp Makefile Makefile.std
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -tw *.[ch]
X
Xsaber:
X	# load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	# load $(ALLDEFINES) $(OBJS)
X
X# -------------------------------------------------------------------------
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
if test 14703 -ne `wc -c <'Makefile.std'`; then
    echo shar: \"'Makefile.std'\" unpacked with wrong size!
fi
# end of 'Makefile.std'
fi
if test ! -d 'bitmaps' ; then
    echo shar: Creating directory \"'bitmaps'\"
    mkdir 'bitmaps'
fi
if test ! -d 'bitmaps/old' ; then
    echo shar: Creating directory \"'bitmaps/old'\"
    mkdir 'bitmaps/old'
fi
if test ! -d 'bitmaps/roman' ; then
    echo shar: Creating directory \"'bitmaps/roman'\"
    mkdir 'bitmaps/roman'
fi
if test ! -d 'bitmaps/standard' ; then
    echo shar: Creating directory \"'bitmaps/standard'\"
    mkdir 'bitmaps/standard'
fi
if test -f 'graphics.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'graphics.c'\"
else
echo shar: Extracting \"'graphics.c'\" \(13258 characters\)
sed "s/^X//" >'graphics.c' <<'END_OF_FILE'
X
X/*
X * graphics.c
X * @(#)graphics.c	1.32 (UCLA) 10/16/92
X *
X * xbomb is Copyright (C) 1992 by Matthew Merzbacher, Los Angeles, CA.
X * All rights reserved.  Permission is granted to freely distribute
X * this as long as this copyright message is retained intact.
X * Permission to distribute this as part of a commerical product
X * requires explicit permission of the author.
X *
X */
X
X#include "icon.bit"
X
X#include "xbomb.h"
X#include <sys/param.h>
X
X	
Xint borderWidth = -1;
Xchar *geom = "";
Xchar *bitdir = NULL;
X
X	
XDisplay     *dpy;
Xint         screen;
XGC          gc;
X	
XWindow      rootWindow, puzzleWindow;
Xlong        FgPixel, BgPixel, BdPixel;
X	
XPixmap pixmaps[20];
X	
X
X
XPixmap
XpiecePixmap(x,y) 
X	int x, y;
X{ 
X	if (map[x][y].status == KEMPTY) {
X		if (!ted)
X			return(pixmaps[map[x][y].neighbors]);
X		else
X			return(pixmaps[map[x][y].neighbors - map[x][y].neighbor_kbombs]);
X	}
X	if (map[x][y].status == KBOMB)
X		return(pixmaps[BOMB]);
X	if (map[x][y].status == EBOMB)
X		return(pixmaps[EBOMB]);
X	if (map[x][y].flag)
X		return(pixmaps[FLAG]);
X	if (map[x][y].status == BOMB)
X		return(pixmaps[EMPTY]);
X	if (map[x][y].status == EMPTY)
X		return(pixmaps[EMPTY]);
X	
X	fprintf(stderr,"Unknown status: (%d, %d) %d\n", x, y, map[x][y].status);
X}
X
Xvoid
Xputpix(c, r)
X	int c, r;
X{
X	XCopyPlane(dpy, piecePixmap(c,r), puzzleWindow, gc,
X		   0, 0, WIDTH, HEIGHT,
X		   c*WIDTH, (r+1)*HEIGHT, 1);
X}
X
X
Xint
Xxfcb(file, w, h, ret)
X	char *file;
X	int *w, *h;
X	Pixmap *ret;
X{
X	int hx, hy;
X	int retcode;
X	char s[80];
X
X	retcode = XReadBitmapFile(dpy, rootWindow, file, w, h, ret, &hx, &hy);
X
X	if ((retcode == BitmapOpenFailed) || (retcode == BitmapSuccess)) {
X		return(retcode);
X	}
X
X	switch(retcode) {
X	case BitmapFileInvalid:
X		sprintf(s,"Invalid bitmap file format: %s", file);
X		bail(s);
X		break;
X	case BitmapNoMemory:
X		sprintf(s,"Insufficient Memory opening file: %s", file);
X		bail(s);
X		break;
X	default:
X		bail("A very bad thing has happened while reading a bitmap");
X	}
X}
X
X
Xstatic struct bit_to_load {
X	char *name;
X	int place;
X} btl[] = {
X	"bomb.bit", BOMB,
X	"empty.bit", EMPTY,
X	"ebomb.bit", EBOMB,
X	"flag.bit", FLAG,
X	"blank.bit", BLANK,
X	"think.bit", THINK,
X	"known0.bit", 0,
X	"known1.bit", 1,
X	"known2.bit", 2,
X	"known3.bit", 3,
X	"known4.bit", 4,
X	"known5.bit", 5,
X	"known6.bit", 6,
X	"known7.bit", 7,
X	"known8.bit", 8,
X	"known9.bit", 9,
X	NULL, 19
X	};
X
X
Xmake_bitmaps()
X{
X	int dummyw, dummyh;
X	int i, gotit;
X	char filename[MAXPATHLEN];
X
X	static char *defbitdir = "standard";
X
X	for (i = 0; btl[i].name != NULL; i++) {
X		gotit = 0;
X		if (bitdir) {
X			sprintf(filename, "%s/%s/%s", 
X				_PATH_BITMAPS, bitdir, btl[i].name);
X			if (xfcb(filename, &dummyw, &dummyh, 
X			     &(pixmaps[btl[i].place])) == BitmapSuccess)
X				gotit = 1;
X		}
X		if (!gotit) {
X			sprintf(filename, "%s/%s/%s", 
X				_PATH_BITMAPS, defbitdir, btl[i].name);
X			if (xfcb(filename, &dummyw, &dummyh, 
X				 &(pixmaps[btl[i].place])) == BitmapOpenFailed)
X			{
X				sprintf(filename, "Unable to open bitmap: %s", 
X					btl[i].name);
X				bail(filename);
X			}
X		}
X	}
X							
X
X/***
X	xfcb("bitmaps/bomb.bit", &dummyw, &dummyh, &(pixmaps[BOMB]));
X	xfcb("bitmaps/empty.bit", &dummyw, &dummyh, &(pixmaps[EMPTY]));
X	xfcb("bitmaps/ebomb.bit", &dummyw, &dummyh, &(pixmaps[EBOMB]));
X	xfcb("bitmaps/flag.bit", &dummyw, &dummyh, &(pixmaps[FLAG]));
X	xfcb("bitmaps/blank.bit", &dummyw, &dummyh, &(pixmaps[BLANK]));
X	xfcb("bitmaps/think.bit", &dummyw, &dummyh, &(pixmaps[THINK]));
X	xfcb("bitmaps/known0.bit", &dummyw, &dummyh, &(pixmaps[0]));
X	xfcb("bitmaps/known1.bit", &dummyw, &dummyh, &(pixmaps[1]));
X	xfcb("bitmaps/known2.bit", &dummyw, &dummyh, &(pixmaps[2]));
X	xfcb("bitmaps/known3.bit", &dummyw, &dummyh, &(pixmaps[3]));
X	xfcb("bitmaps/known4.bit", &dummyw, &dummyh, &(pixmaps[4]));
X	xfcb("bitmaps/known5.bit", &dummyw, &dummyh, &(pixmaps[5]));
X	xfcb("bitmaps/known6.bit", &dummyw, &dummyh, &(pixmaps[6]));
X	xfcb("bitmaps/known7.bit", &dummyw, &dummyh, &(pixmaps[7]));
X	xfcb("bitmaps/known8.bit", &dummyw, &dummyh, &(pixmaps[8]));
X	xfcb("bitmaps/known9.bit", &dummyw, &dummyh, &(pixmaps[9]));
X***/
X}
X
Xvoid
Xcleanup_pixmaps()
X{
X	if (pixmaps[EMPTY] != NULL) XFreePixmap(dpy, pixmaps[EMPTY]);
X	if (pixmaps[BOMB] != NULL) XFreePixmap(dpy, pixmaps[BOMB]);
X	if (pixmaps[EBOMB] != NULL) XFreePixmap(dpy, pixmaps[EBOMB]);
X	if (pixmaps[FLAG] != NULL) XFreePixmap(dpy, pixmaps[FLAG]);
X	if (pixmaps[BLANK] != NULL) XFreePixmap(dpy, pixmaps[BLANK]);
X	if (pixmaps[THINK] != NULL) XFreePixmap(dpy, pixmaps[THINK]);
X	if (pixmaps[0] != NULL) XFreePixmap(dpy, pixmaps[0]);
X	if (pixmaps[1] != NULL) XFreePixmap(dpy, pixmaps[1]);
X	if (pixmaps[2] != NULL) XFreePixmap(dpy, pixmaps[2]);
X	if (pixmaps[3] != NULL) XFreePixmap(dpy, pixmaps[3]);
X	if (pixmaps[4] != NULL) XFreePixmap(dpy, pixmaps[4]);
X	if (pixmaps[5] != NULL) XFreePixmap(dpy, pixmaps[5]);
X	if (pixmaps[6] != NULL) XFreePixmap(dpy, pixmaps[6]);
X	if (pixmaps[7] != NULL) XFreePixmap(dpy, pixmaps[7]);
X	if (pixmaps[8] != NULL) XFreePixmap(dpy, pixmaps[8]);
X	if (pixmaps[9] != NULL) XFreePixmap(dpy, pixmaps[9]);
X}
X
X
XrequestColor(name)
X	char *name;
X{
X	XColor truecolor, availcolor;
X	
X	if (XAllocNamedColor(dpy,
X			     DefaultColormap(dpy, DefaultScreen(dpy)),
X			     name, &availcolor, &truecolor) == 0) {
X		fprintf(stderr, "Color '%s' unknown\n", name);
X		exit(1);
X	}
X#if 0
X	if (truecolor.red != availcolor.red ||
X	    truecolor.green != availcolor.green ||
X	    truecolor.blue != availcolor.blue) {
X		fprintf(stderr, "Warning: %s color may be wrong\n", name);
X	}
X#endif
X	
X	return availcolor.pixel;
X}
X
X
X
Xvoid 
Xxmess(mess) 
X	char *mess;
X{
X	XDrawString(dpy, puzzleWindow, gc, 10, HEIGHT*(height + 2) + 8, 
X		mess, strlen(mess));
X}
X
X
Xint
Xeventloop()
X{
X	XEvent event;
X	XExposeEvent *ee = (XExposeEvent *)&event;
X	XKeyPressedEvent *ke = (XKeyPressedEvent *)&event;
X	XButtonPressedEvent *be = (XButtonPressedEvent *)&event;
X	char keybuff[10];
X	int nchar;
X	char *mess1 = "You won!";
X	char *mess2 = "(press anything to exit - 'r' to get your seed - 'n' to play again)";
X	char *mess2a = "(press anything to play again - 'r' to get your seed - 'q' to quit)";
X	char *mess3 = "Kabooom!";
X	char *autosolstr = "!@#$%^&*()";
X	char *solstr = "1234567890";
X	char schar;
X	int i, r, c;
X	int row, column, nrow, ncolumn;
X
X	while(1) {
X		if (dead || ((numempty == 1) && (numflags == 0))) {
X			if (!dead) xmess(mess1);
X			else {
X				reveal();
X				xmess(mess3);
X			}
X			if (playagain)
X				XDrawString(dpy, puzzleWindow, gc, 10, 
X					    HEIGHT*(height + 2) + 25, mess2a, 
X					    strlen(mess2a));
X			else
X				XDrawString(dpy, puzzleWindow, gc, 10, 
X					    HEIGHT*(height + 2) + 25, mess2, 
X					    strlen(mess2));
X			while (1) {
X				XNextEvent(dpy, &event);
X				switch(event.type) {
X				case KeyPress:
X					nchar = XLookupString(ke, keybuff, 1, NULL, NULL);
X					if (nchar > 0) {
X						if (keybuff[0] == 'r')
X							printf("Using seed: %i\n",seed);
X						if ((playagain && keybuff[0] != 'q') || (keybuff[0] == 'n'))
X							return(1);
X					}
X					finish();
X					break;
X
X				case ButtonPress:
X					if (playagain)
X						return(1);
X					finish();
X					break;
X
X				case Expose:
X					if (! ee->count)
X						repaint();
X					break;
X
X				default:
X					break;
X				}
X			}
X		}
X
X		XNextEvent(dpy, &event);
X		switch(event.type) {
X		case KeyPress:
X			nchar = XLookupString(ke, keybuff, 1, NULL, NULL);
X			i = 0;
X			
X			if (nchar > 0) {
X				switch (keybuff[0]) {
X				case '\021':
X					finish();
X
X				case 'g':
X				case 'G':
X					place_random(keybuff[0]=='g' ? EMPTY : BOMB);
X					break;
X
X				case 'S':
X				case 's':
X					scan_em();
X					break;
X
X				case 'p':
X					place_em();
X					print_score();
X					break;
X				
X				case 'P':
X				case 'B':
X				case 'b':
X					while (place_em() || scan_em())
X						print_score();
X					print_score();
X					break;
X
X				case 'h':
X				case 'H':
X				case '?':
X					help_me();
X					break;
X					
X				case '0':
X					keybuff[0] += 10;
X				case '1':
X				case '2':
X				case '3':
X				case '4':
X				case '5':
X				case '6':
X				case '7':
X				case '8':
X				case '9':
X					for (i = 0; solstr[i] != keybuff[0]; i++);
X					invoke_solvers(i,
X						       XTOCOLUMN(be->x),
X						       YTOROW(be->y));
X					print_score();
X					break;
X				
X				case '!':
X				case '@':
X				case '#':
X				case '$':
X				case '%':
X				case '^':
X				case '&':
X				case '*':
X				case '(':
X				case ')':
X					for (i = 0; autosolstr[i] != keybuff[0]; i++);
X
X					if (solvers[i]) {
X						while (invoke_solvers(i, -1, -1) ||
X						       place_em() || 
X						       scan_em())
X							print_score();
X						}
X					break;
X				}
X			}
X			break;
X			
X		case ButtonPress:
X			button = event.xbutton.button;
X			shifted = (event.xbutton.state & ShiftMask) ? 1 : 0;
X			column = XTOCOLUMN(be->x);
X			row = YTOROW(be->y);
X			break;
X			
X		case ButtonRelease:
X			ncolumn = XTOCOLUMN(be->x);
X			nrow = YTOROW(be->y);
X			if ((button == event.xbutton.button)
X			    && (ncolumn == column) && (nrow == row)
X			    && (column > 0) && (column <= width)
X			    && (row > 0) && (row <= height))
X				do_move(column, row);
X			break;
X			
X		case Expose:
X			if (! ee->count)
X				repaint();
X			break;
X			
X		default:
X			break;
X		}
X	}
X}
X
Xreveal()
X{
X	int c, r;
X	
X	for (c = 1; c <= width; c++)
X		for (r = 1; r <= height; r++) {
X			if (map[c][r].status == BOMB) map[c][r].status = EBOMB;
X		}
X	
X	repaint();
X	
X}
X
Xhelp_me() {
X	int sm;
X	char *mess1 = "Keyboard: s = scan; p = place; b = both (s & p); ^Q = quit";
X	char *mess2 = "Mouse: Left = empty; Right|Center|<Shift>-Any = flag";
X
X	sm = strlen(mess1);
X	XDrawString(dpy, puzzleWindow, gc, WIDTH, 
X		    (height+3)*HEIGHT-25, mess1, sm);
X
X	sm = strlen(mess2);
X	XDrawString(dpy, puzzleWindow, gc, WIDTH,
X		    (height+3)*HEIGHT-5, mess2, sm);
X
X}
X
Xrepaint()
X{
X	int c, r;
X	char *mess1 = "!sbmoB";
X	char *mess2 = "? for help";
X	int sm;
X
X	XClearWindow(dpy, puzzleWindow);
X	
X	for (c = 1; c <= width; c++)
X		for (r = 1; r <= height; r++) {
X			putpix(c, r);
X		}
X	
X	print_score();
X
X	sm = strlen(mess1);
X	XDrawString(dpy, puzzleWindow, gc, WIDTH*((width+1)/2) - sm, 
X		    HEIGHT+12, mess1, sm);
X
X	sm = strlen(mess2);
X	XDrawString(dpy, puzzleWindow, gc, WIDTH*((width+1)/2) - sm, 
X		    HEIGHT+30, mess2, sm);
X	
X}
X
X
Xdo_move(c, r)
X	int c, r;
X{
X	int move;
X	
X	move = FLAG;
X	
X	if ((button == Button1) & !shifted) move = CHECK;
X	
X	switch (move) {
X		
X	case CHECK:
X		move_somewhere(c, r);
X		break;
X		
X	case FLAG:
X		place_flag(c, r);
X		break;
X	}
X	
X	putpix(c, r);
X	
X	print_score();
X	
X}
X
X
X
X
Xgraphics_main(argc, argv)
X	int argc;
X	char **argv;
X{
X	int i, temp;
X	Visual visual;
X	XGCValues xgcv;
X	XSetWindowAttributes xswa;
X	XSizeHints sizehints;
X	
X	int total_width, total_height;
X	int maxwidth, maxheight;
X
X	/*************************************/
X	/** configure the window size hints **/
X	/*************************************/
X	
X	maxwidth = DisplayWidth(dpy, screen)/WIDTH - 2;
X	maxheight = DisplayHeight(dpy, screen)/HEIGHT - 4;
X	
X	if (maxwidth > MAXWIDTH) maxwidth = MAXWIDTH;
X	if (maxheight > MAXHEIGHT) maxheight = MAXHEIGHT;
X	
X	if (width < 2)
X		width = DEFWIDTH;
X	
X	if (width > maxwidth)
X		width = maxwidth;
X	
X	if (height < 2)
X		height = DEFHEIGHT;
X	
X	if (height > maxheight)
X		height = maxheight;
X	
X	if (numbombs < 1)
X		numbombs = width*height/4;
X	
X	if (numbombs > (width*height)/2)
X		numbombs = (width*height)/2;
X	
X	
X	total_width = (WIDTH * (width+2));
X	total_height = (HEIGHT * (height+3));
X	
X	sizehints.flags = PMinSize | PMaxSize | PPosition | PSize;
X	sizehints.min_width = total_width;
X	sizehints.min_height = total_height;
X	sizehints.max_width = total_width;
X	sizehints.max_height = total_height;
X	sizehints.width = total_width;
X	sizehints.height = total_height;
X	sizehints.x = 100;
X	sizehints.y = 300;
X	
X	if (geom && strlen(geom)) {
X		int mmwidth, mmheight, flags;
X		
X		flags = XParseGeometry(geom, &sizehints.x, &sizehints.y,
X				       &mmwidth, &mmheight);
X		if (flags & (XValue | YValue))
X			sizehints.flags |= USPosition;
X	}
X	
X	/*******************************************************************/
X	/** create the puzzle main window and set its standard properties **/
X	/*******************************************************************/
X	
X	xswa.event_mask = ExposureMask | ButtonPressMask |
X		ButtonReleaseMask | KeyPressMask;
X	xswa.background_pixel = BgPixel;
X	xswa.border_pixel = BdPixel;
X	xswa.cursor = XCreateFontCursor(dpy, XC_hand1);
X	
X	visual.visualid = CopyFromParent;
X	
X	rootWindow = RootWindow(dpy, screen);
X	
X	puzzleWindow = XCreateWindow(dpy, rootWindow,
X				     sizehints.x, sizehints.y,
X				     sizehints.width, sizehints.height,
X				     borderWidth,
X				     DefaultDepth(dpy,screen),
X				     InputOutput,
X				     &visual,
X				     CWCursor | CWEventMask | CWBackPixel | CWBorderPixel,
X				     &xswa);
X	
X	/*******************************************************************/
X	/** define its name and icon-bitmap                               **/
X	/*******************************************************************/
X	
X	XSetStandardProperties(dpy, puzzleWindow, "!sbmob","!sbmoB",
X			       XCreateBitmapFromData(dpy, rootWindow,
X						     icon_bits,
X						     icon_width, icon_height),
X			       argv, argc, &sizehints);
X	
X	XMapWindow(dpy, puzzleWindow);
X	
X	xgcv.foreground = FgPixel;
X	xgcv.background = BgPixel;
X	xgcv.line_width = 0;
X	xgcv.font = XLoadFont(dpy, "rk16");
X	gc = XCreateGC(dpy, puzzleWindow,
X		       GCForeground|GCBackground|GCLineWidth|GCFont,
X		       &xgcv);
X	
X	make_bitmaps();
X}
END_OF_FILE
if test 13258 -ne `wc -c <'graphics.c'`; then
    echo shar: \"'graphics.c'\" unpacked with wrong size!
fi
# end of 'graphics.c'
fi
if test -f 'map.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'map.c'\"
else
echo shar: Extracting \"'map.c'\" \(2414 characters\)
sed "s/^X//" >'map.c' <<'END_OF_FILE'
X
X/*
X * map.c
X * @(#)map.c	1.27 (UCLA) 10/22/92
X *
X * xbomb is Copyright (C) 1992 by Matthew Merzbacher, Los Angeles, CA.
X * All rights reserved.  Permission is granted to freely distribute
X * this as long as this copyright message is retained intact.
X * Permission to distribute this as part of a commerical product
X * requires explicit permission of the author.
X *
X */
X
X#include "xbomb.h"
X
X
Xstruct cell map[MAXWIDTH+2][MAXHEIGHT+2];
X
Xvoid
Xcreate_cute_map()
X{
X	int x, y;
X	int mode=0;
X	int nb = numbombs;
X	int ns = width * height;
X
X	onlyprint = 1;   /* so they can't score */
X
X	for (x = 1; x <= width; x++)
X		for (y = 1; y <= height; y++)
X			switch (mode) {
X			case 0:
X				map[x][y].status = EMPTY;
X				ns--;
X				if (lrand48() % ns >= nb)
X					break;
X				mode = 1;
X			case 1:
X				map[x][y].status = BOMB;
X				if (!--nb)
X					mode = 2;
X				break;
X			case 2:
X				map[x][y].status = EMPTY;
X				break;
X			};
X}
X
X
Xcreate_map()
X{
X	int x, y, nb, nok;
X
X	for (x = 1; x <= width; x++)
X		for (y = 1; y <= height; y++) {
X			map[x][y].status = EMPTY;
X			map[x][y].flag = 0;
X			map[x][y].neighbors = 0;
X			map[x][y].neighbor_kbombs = 0;
X		}
X	
X	for (x = 0; x <= width+1; x++) {
X		map[x][0].status = BORDER;
X		map[x][height+1].status = BORDER;
X	}
X	
X	for (y = 0; y <= height+1; y++) {
X		map[0][y].status = BORDER;
X		map[width+1][y].status = BORDER;
X	}
X
X	for (nb = numbombs; nb > 0; nb--) {
X		do {
X			x = lrand48()%width + 1;
X			y = lrand48()%height + 1;
X			nok = (map[x][y].status != EMPTY);
X			if (!startwithzero) 
X			  nok = nok || ((x == 1) && (y == 1));
X		} while (nok);
X		map[x][y].status = BOMB;
X	}
X
X
X	numempty = width*height - numbombs;
X	numflags = numbombs;
X
X	/* if (lrand48() % 20 == 0) create_cute_map(); */
X
X	
X	for (x = 1; x <= width; x++)
X		for (y = 1; y <= height; y++)
X			if (map[x][y].status == EMPTY) {
X				map[x][y].neighbors = 0;
X				apply_neighbor(x,y,apply_inc_if_bomb, &map[x][y].neighbors);
X			};
X
X	if (startwithzero) {
X		for (x = 1; x <= width; x++)
X			for (y = 1; y <= height; y++)
X				if ((map[x][y].status == EMPTY) &&
X				    (map[x][y].neighbors == 0)) {
X					map[x][y].status = KEMPTY;
X					follow(x,y);
X					return(0);
X					}
X		for (x = 1; x <= width; x++)
X			for (y = 1; y <= height; y++)
X				if (map[x][y].status == EMPTY) {
X					map[x][y].status = KEMPTY;
X					return(0);
X					}
X		}
X	
X	if (map[1][1].status == EMPTY) {
X		map[1][1].status = KEMPTY;
X		if (map[1][1].neighbors == 0) follow(1,1);
X	};
X}
X
END_OF_FILE
if test 2414 -ne `wc -c <'map.c'`; then
    echo shar: \"'map.c'\" unpacked with wrong size!
fi
# end of 'map.c'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(39 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X#define VERSION 1
X#define PATCHLEVEL 2
END_OF_FILE
if test 39 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
if test -f 'xbomb.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xbomb.man'\"
else
echo shar: Extracting \"'xbomb.man'\" \(10580 characters\)
sed "s/^X//" >'xbomb.man' <<'END_OF_FILE'
X.TH XBOMB 6 "5 October 1992"
X
X.SH NAME
Xxbomb \- hunt the bombs
X
X.SH SYNOPSIS
X.B xbomb
X[
X.B options
X]
X
X.SH DESCRIPTION
X.LP
X.B xbomb
Xis an rewrite and extension of the
X.B minesweeper
Xgame found on various PCs.  The object of the game is to clear a field
Xof deadly bombs.  To do this requires only two mouse buttons, one key
Xand devastatingly clever wit.
X
XThe board is a rectangle of hidden bombs and empty spots.  When a bomb
Xis stepped on, you die, and the game is over.  When an empty spot is 
Xstepped on, you find out how many bombs are adjacent to the spot (horizontally,
Xvertically or diagonally).  With clever deduction, you can figure out where 
Xthe bombs must lie (and the bombs never lie).
X
XThe left mouse button establishes that a space on the board is empty.
XIt's as if you strolled onto that particular space.  If it is empty, then
Xit immediately becomes a number (as described above).  If there's a bomb,
Xthen, well, you can always play again.
X
XAny non-left mouse button (or 
X.I any 
Xshifted button) toggles a flag.  Flags are reminders to yourself that
Xthere's probably a bomb at that particular spot.  To help you out, the
Xtotal number of bombs left unflagged is presented in the upper left.
XIf you misplace a flag, then the number is decremented, but you don't
Xdie.
X
XThere are a few keystrokes that can help you (or kill you).
X
X.IP "\fB^Q\fP"
XQuit the game.  Always the best key to know when running a new program.
X
X.IP \fBg,G\fP
XMake a random guess somewhere on the board.  If it's empty, then you
Xget some knowledge.  If not, you die.  True afficianados scoff at this
Xmove.
X
X.IP \fBs,S\fP
XScan the board.  This turns all flags into bombs.  If a flag was placed
Xon an empty spot, then you die.  If not, it's a good way of establishing
Xyour hypotheses.
X
X.IP \fBp\fP
XPlace obvious flags.  Sometimes a flag position is obvious.  If, for example,
Xyou have an 8 on the board, then all of its neighbors must have bombs.
XThe 'p' key places any obvious flags.
X
X.IP "\fBP,B, or b\fP"
XPlace and Scan (both).  This places obvious flags, scans 'em, and repeats.
XMost useful.
X
X.IP "\fB0, 1, 2 ... 9\fP"
XInvoke a solver.  Solvers are set with the -S option, described below.
X
XYou are now ready to play, but you should probably use a few of the more
Xconvenient options, so read on...
X
X.SH "OPTIONS"
X.B Xbomb
Xhas more options than you can shake a stick at.  Here they are, in
Xsome kind of bizarre order, starting with common X options.  You are not
Xobliged to specify any of these, and you can specify most of them in your 
X.Xdefaults file as well (see below).  We recommend the latter approach.
X
X.IP "\fB-bg color\fP"
Xuse the specified color as the background color.
X
X.IP "\fB -fg color \fP"
Xuse the specified color as the foreground color.
X
X.IP "\fB -bd color \fP"
Xuse the specified color as the border color.
X
X.IP "\fB -bw width \fP"
Xspecify the border width.
X
X.IP "\fB -d display \fP"
Xuse a different server for display.
X
X.IP "\fB -g geometry \fP"
Xspecify the geometry.  The actual size of the window for 
X.B xbomb
Xis dictated by
Xthe width and height, but you can give an initial position.  I like +2+2 to
Xput it in the (almost) upper left.
X
XNow for the more interesting Non-X options...
X
X.IP "\fB -A \fP"
XAuto-replay mode.  If this is set, then when you die, you have to explicitly
Xquit to get out of the game.
X
X.IP "\fB -h height \fP"
XUse a board that is height spaces high.  A good value for this is 24.
XDefault is 20.
X
X.IP "\fB -w width \fP"
XUse a board that is width spaces wide.  A good value for this is 34.
XDefault is 20.
X
X.IP "\fB -f \fP"
XUse a better follow algorithm.  Consider an empty spot that has three
Xadjacent bombs.  If all three bombs have been established (using the 's'
Xkey), then the remainder of the neighbor spots must be empty.  The better
Xfollowing algorithm does this for you.  Playing the game without it a few
Xtimes will convince you that it's a godsend.
X
X.IP "\fB -n N \fP"
XHide N bombs on the map.  By default, N will be one quarter of the width
Xtimes the height.  Maximum, N will be one half the width times the height.
XSolving a maze filled with a quarter bombs is tough,
Xand solving a maze filled with more than a quarter bombs can quite ridiculious.
XOur record (for a 24x34 map) is 225 bombs (204 is one quarter).
X
X.IP "\fB -na name \fP"
XPlay using name instead of your userid.  The name must be at most 8 
Xcharacters long.
X
X.IP "\fB -q \fP"
XQuiet mode.  Only report the scores if you manage to break into the 
Xhigh scorers list.
X
X.IP "\fB -r seed \fP"
XPlay with a particular random seed.  This disables scoring, so don't
Xeven try it.  You can find out the random seed for a game when you die
Xby hitting 'r'.
X
X.IP "\fB -Re e \fP"
XStart the game with e random guessed empty squares.  Pretty dangerous, but
Xit's only a game.
X
X.IP "\fB -Rb f \fP"
XStart the game with f random guessed flags.  Extremely dangerous!
X
X.IP "\fB -s \fP"
XPrint the high score list.  By default (in the regular game), only the
Xtop 5 plus any scores you got are printed.  This prints the entire list.
X
X.IP "\fB -S solver \fP or \fB -S[1-9] solver \fP"
XAssign a solver.  Solvers (described below) are user programs that
Xdo better jobs of figuring out where empty spots and flags should be.
XThere are several solvers distributed with 
X.B xbomb ,
Xand this manual page
Xdescribes how to build them yourself.  A solver is bound to a given number key
Xso that when you hit that key, the solver is invoked.  If you don't
Xspecify a number, 
X.B xbomb
Xuses the next available spot.
X
XSolvers are given by pathname relative to the current directory,
Xor relative to the xbomb library (perhaps
X.B /usr/local/games/lib/xbomb
X).
X
X.IP "\fB -t \fP"
XTed mode!  Ted mode automatically decrements numbers whenever a bomb has
Xbeen established next to them.  Thus, when you do an 's' the numbers all
Xdecrement.  Now the numbers indicate the number of neighboring unplaced
Xbombs rather than the total number, and which makes the game lots easier
X(and more fun, if you ask me).
XWhy is it called Ted mode?  Ask Ted.
X
X.IP "\fB -z \fP"
XInstead of starting the game in the upper left corner, this will find a zero
Xsomewhere in the maze and start you there.  It makes the game easier, but
Xit also eliminates you from high scoring.
X
X.SH "X RESOURCES"
X
XMost of the options listed above can be specified as 
X.B xbomb
Xresources.  
XOf course, command line options override resources.
XHere's a full list.  Hopefully they're obvious from the corresponding
Xoptions listed above.
X
X.nf
Xxbomb.Foreground:		color
Xxbomb.Background:  		color
Xxbomb.BorderColor: 		color
Xxbomb.BorderWidth: 		width
Xxbomb.Display:     		display
Xxbomb.Geometry:    		geometry
Xxbomb.AutoPlay:			on
Xxbomb.Follow:      		on
Xxbomb.Width:       		width
Xxbomb.Height:			height
Xxbomb.NumberBombs:		N
Xxbomb.Name:			name
Xxbomb.RandomEmpty:		e
Xxbomb.RandomBombs:		b
Xxbomb.Quiet:			on
Xxbomb.Solver[1-9]:		solver
Xxbomb.TedMode:			on
Xxbomb.StartWithZero:	on
X.fi
X
X
XI personally like the following:
X
X.nf
Xxbomb.Foreground:               PapayaWhip
Xxbomb.Background:               DarkBlue
Xxbomb.AutoPlay:                 on
Xxbomb.Follow:                   on
Xxbomb.TedMode:                  on
Xxbomb.Geometry:                 +2+2
Xxbomb.Height:                   24
Xxbomb.Width:                    34
Xxbomb.Solver1:                  pattern_solver
Xxbomb.Solver2:			statistics
Xxbomb.Solver3:                  prob_solver
Xxbomb.Quiet:                    on
X.fi
X
XNote that I have to specify the number of bombs on the command line, or
XI'll get the default (one quarter).
X
X.SH "SOLVER INTERFACE"
X
X.B Xbomb
Xallows ``solvers'' to assist the player in doing tedious parts
Xof the game.
XTo allow flexibility (and prevent cheating),
Xthese solvers are separate programs from the game itself.
XSolvers communcate only through standard input and output
Xwith the game.
X
XEach a user invokes a solver,
X.B xbomb 
Xprints the current state of the game to the
Xsolver's standard input (after starting the solver, of course).
XThe format of the game is:
X
X	INFORMATION
X
X	MAP
X
X``Information'' is a number line containing either ``numbombs N''
Xor ``mouse X Y'' (N, X, and Y are numbers).
X``Map'' is the line ``map'' followed by an ASCII copy of the map
Xterminated by a blank line.
XIn the map,
Xdigits show the number of neighboring bombs,
XX's show bombs that have been verified,
Xf's designate flags,
Xe's indicate squares flagged as ``empty'' (not yet implemented),
Xand periods are unknown squares.
X
XAfter a solver receives a map,
Xit must respond with any actions it wishes to take
Xfollowed by a blank line.  Each action is of the form ``X Y A''
Xwhere X and Y are the grid location and A is either ``f''
Xfor flag as a bomb, ``m'' for move to this location,
Xor ``e'' for flag as empty (``e'' is not yet implemented).
XA solver 
X.I must
Xrespond with at least a single blank line
Xor the game will not continue.
X
X.B xbomb
Xcomes with a bunch of solvers,  Well, three (or so).  Try 'em out.
XIn particular, 
X.B pattern_solver
Xis a must if you want to get anywhere in the world.  There is *no*
Xtruth to the rumor that it will be entered in next year's Obfuscated
XC code contest.
X
X.SH AUTHORS
X
X.B xbomb 
Xis mostly the fault of Matthew Merzbacher (matthew@cs.ucla.edu),
Xwho created absolutely no bugs at all.
XHe had altogether too much help from John Heidemann (johnh@cs.ucla.edu), 
Xwho was responsible for the solver interface,
Xand so introduced a bug allowing anyone to write the score file.
XMichial Gunter (gunter@cs.ucla.edu)
Xdid the random seed code,
Xintroducing a bug allowing anyone to complete any maze perfectly.
X
XLots of playtesters could
Xfill this man page, but we'll mention only Dave Ratner (ratner@cs.ucla.edu)
Xbecause he likes to see his name in print, Scott Turner (srt@aero.org)
Xbecause he was the first non-UCLA installer and because he always mentions
Xus in his man pages,
Xand Trent Bills (tbills@cse.unl.edu)
Xbecause we want him to include us in his man pages someday.
X
XIf you like this code, send us thanks, money, 
Xor a postcard from your next vacation.
X
X.nf
XMatthew Merzbacher
XJohn Heidemann
XMichial Gunter
XDave Ratner
X
XUCLA Computer Science
X3436 Boelter Hall
X405 Hilgard Ave.
XLos Angeles, CA
X90024
X.fi
X
X.SH LEGALESE
X
X.B xbomb
Xis Copyright (C) 1992 by Matthew Merzbacher, Los Angeles, CA.
XAll rights reserved.  Permission is granted to freely distribute
Xthis as long as this copyright message is retained intact.
XPermission to distribute this as part of a commerical product
Xrequires explicit permission of the author.
X
X
X.SH BUGS
XRapid, repeated solver invocations cause the program to bomb
Xwith a failed pipe.  Fix this, and you win a cookie.
X
X.SH "SEE ALSO"
X.BR X11(1)
END_OF_FILE
if test 10580 -ne `wc -c <'xbomb.man'`; then
    echo shar: \"'xbomb.man'\" unpacked with wrong size!
fi
# end of 'xbomb.man'
fi
echo shar: End of archive 1 \(of 4\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
