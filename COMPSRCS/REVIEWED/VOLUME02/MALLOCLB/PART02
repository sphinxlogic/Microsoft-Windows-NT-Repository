From: Conor P. Cahill <cpcahil%virtech@uunet.UU.NET>
Subject: v02i003: malloclib - Malloc Debugging Library, Part02/05
Newsgroups: comp.sources.reviewed
Approved: csr@calvin.dgbt.doc.ca

Submitted-by: Conor P. Cahill <cpcahil%virtech@uunet.UU.NET>
Posting-number: Volume 2, Issue 3
Archive-name: malloclib/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 5)."
# Contents:  free.c m_init.c m_perror.c malloc.3 malloc.h
# Wrapped by cpcahil@virtech on Tue Jan 28 16:46:33 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'free.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'free.c'\"
else
echo shar: Extracting \"'free.c'\" \(6163 characters\)
sed "s/^X//" >'free.c' <<'END_OF_FILE'
X/*
X * (c) Copyright 1990, 1991 Conor P. Cahill (uunet!virtech!cpcahil).  
X * You may copy, distribute, and use this software as long as this
X * copyright statement is not removed.
X */
X#include <stdio.h>
X#include "mallocint.h"
X#include "debug.h"
X
X/*
X * Function:	free()
X *
X * Purpose:	to deallocate malloced data
X *
X * Arguments:	ptr	- pointer to data area to deallocate
X *
X * Returns:	nothing of any value
X *
X * Narrative:
X *		verify pointer is within malloc region
X *		get mlist pointer from passed address
X *		verify magic number
X *		verify inuse flag
X *		verify pointer connections with surrounding segments
X *		turn off inuse flag
X *		verify no data overrun into non-malloced area at end of segment
X *		IF possible join segment with next segment
X *		IF possible join segment with previous segment
X *		Clear all data in segment (to make sure it isn't reused)
X *
X */
X#ifndef lint
Xstatic
Xchar rcs_hdr[] = "$Id: free.c,v 1.17 1992/01/28 14:30:18 cpcahil Exp $";
X#endif
X
XVOIDTYPE
Xfree(cptr)
X	DATATYPE	* cptr;
X{
X	debug_free((char *)NULL, 0, cptr);
X}
X
XVOIDTYPE
Xdebug_free(file,line,cptr)
X	const char	* file;
X	int		  line;
X	DATATYPE	* cptr;
X{
X	DBFfree("free",file,line,cptr);
X}
X
XVOIDTYPE
XDBFfree(func,file,line,cptr)
X	const char	* func;
X	const char	* file;
X	int		  line;
X	DATATYPE	* cptr;
X{
X	int			  i;
X	register struct mlist	* oldptr;
X	register struct mlist	* ptr;
X
X	/*
X	 * initialize the malloc sub-system.
X	 */
X	MALLOC_INIT();
X
X	/*
X	 * IF malloc chain checking is on, go do it.
X	 */
X	if( malloc_checking )
X	{
X		VOIDCAST DBFmalloc_chain_check(func,file,line,1);
X	}
X
X#if __STDC__ && ! defined(NO_ANSI_NULLS)
X
X	if( cptr == NULL )
X	{
X		return;
X	}
X
X#endif
X
X	/*
X	 * verify that cptr is within the malloc region...
X	 */
X	if( cptr < malloc_data_start || cptr > malloc_data_end )
X	{
X		malloc_errno = M_CODE_BAD_PTR;
X		malloc_warning(func,file,line,(struct mlist *)NULL);
X		return;
X	}
X
X	/* 
X	 * convert pointer to mlist struct pointer.  To do this we must 
X	 * move the pointer backwards the correct number of bytes...
X	 */
X	
X	ptr = (struct mlist *) (((char *)cptr) - M_SIZE);
X
X	/*
X	 * check the magic number 
X	 */	
X	if( (ptr->flag&M_MAGIC_BITS) != M_MAGIC )
X	{
X		malloc_errno = M_CODE_BAD_MAGIC;
X		malloc_warning(func,file,line,(struct mlist *)NULL);
X		return;
X	}
X
X	/*
X	 * if this segment is not flagged as being in use
X	 */
X	if( ! (ptr->flag & M_INUSE) )
X	{
X		malloc_errno = M_CODE_NOT_INUSE;
X		malloc_warning(func,file,line,ptr);
X		return;
X	}
X
X	/*
X	 * check to see that the pointers are still connected
X	 */
X 	if( (ptr->prev && (ptr->prev->next != ptr) ) ||
X	    (ptr->next && (ptr->next->prev != ptr) ) ||
X	    ((ptr->next == NULL) && (ptr->prev == NULL)) )
X	{
X		malloc_errno = M_CODE_BAD_CONNECT;
X		malloc_warning(func,file,line,ptr);
X		return;
X	}
X
X	/*
X	 * if we are filling the area with fill bytes, check to see if the
X	 * program has gone beyond the end of the assigned area
X	 */
X	if( malloc_fill_area )
X	{
X		for(i=ptr->r_size; i < ptr->s.size; i++)
X		{
X			if( ptr->data[i] != M_FILL )
X			{
X				malloc_errno = M_CODE_OVERRUN;
X				malloc_warning(func,file,line,ptr);
X				break;
X			}
X		}
X	}
X
X	/*
X	 * flag block as freed
X	 */
X	ptr->flag &= ~M_INUSE;
X
X	DEBUG3(10,"pointers: prev: 0x%.7x,  ptr: 0x%.7x, next: 0x%.7x",
X			ptr->prev, ptr, ptr->next);
X	
X	DEBUG3(10,"size:     prev: %9d,  ptr: %9d, next: %9d",
X			ptr->prev->s.size, ptr->s.size, ptr->next->s.size);
X	
X	DEBUG3(10,"flags:    prev: 0x%.7x,  ptr: 0x%.7x, next: 0x%.7x",
X			ptr->prev->flag, ptr->flag, ptr->next->flag);
X	
X	/*
X	 * check to see if this block can be combined with the next and/or
X	 * previous block.  Since it may be joined with the previous block
X	 * we will save a pointer to the previous block and test to verify
X	 * if it is joined (it's next ptr will no longer point to ptr).
X 	 */
X	malloc_join(ptr,ptr->next,0,0);
X	
X	oldptr = ptr->prev;
X
X	malloc_join(ptr->prev, ptr,0,0);
X
X	if( oldptr->next != ptr )
X	{
X		DEBUG0(10,"Oldptr was changed");
X		ptr = oldptr;
X	}
X	/*
X	 * else, since the oldptr did not change, ptr is now a new free segment
X	 * that must be added to the free list, so go do it.
X	 */
X	else
X	{
X		malloc_freeseg(M_FREE_ADD,ptr);
X	}
X	
X	/*
X	 * fill this block with '\02's to ensure that nobody is using a 
X	 * pointer to already freed data...
X	 */
X	if( malloc_fill_area )
X	{
X		malloc_aligned_memset(ptr->data,M_FREE_FILL,(int)ptr->s.size);
X	}
X
X}
X
X/*
X * $Log: free.c,v $
X * Revision 1.17  1992/01/28  14:30:18  cpcahil
X * Changes from the c.s.r second review
X *
X * Revision 1.16  1992/01/10  17:28:03  cpcahil
X * Added support for overriding void datatype
X *
X * Revision 1.15  1991/12/06  17:58:44  cpcahil
X * added cfree() for compatibility with some wierd systems
X *
X * Revision 1.14  91/12/06  08:54:17  cpcahil
X * cleanup of __STDC__ usage and addition of CHANGES file
X * 
X * Revision 1.13  91/12/04  09:23:37  cpcahil
X * several performance enhancements including addition of free list
X * 
X * Revision 1.12  91/12/02  19:10:09  cpcahil
X * changes for patch release 5
X * 
X * Revision 1.11  91/11/25  14:41:53  cpcahil
X * Final changes in preparation for patch 4 release
X * 
X * Revision 1.10  91/11/24  00:49:25  cpcahil
X * first cut at patch 4
X * 
X * Revision 1.9  90/08/29  21:22:48  cpcahil
X * miscellaneous lint fixes
X * 
X * Revision 1.8  90/05/11  00:13:08  cpcahil
X * added copyright statment
X * 
X * Revision 1.7  90/02/25  11:00:18  cpcahil
X * added support for malloc chain checking.
X * 
X * Revision 1.6  90/02/24  21:50:18  cpcahil
X * lots of lint fixes
X * 
X * Revision 1.5  90/02/24  17:29:13  cpcahil
X * changed $Header to $Id so full path wouldnt be included as part of rcs 
X * id string
X * 
X * Revision 1.4  90/02/24  15:15:32  cpcahil
X * 1. changed ALREADY_FREE errno to NOT_INUSE so that the same errno could
X *    be used by both free and realloc (since it was the same error).
X * 2. fixed coding bug
X * 
X * Revision 1.3  90/02/24  14:23:45  cpcahil
X * fixed malloc_warning calls
X * 
X * Revision 1.2  90/02/24  13:59:10  cpcahil
X * added function header.
X * Modified calls to malloc_warning/malloc_fatal to use new code error messages
X * Added support for malloc_errno setting of error codes.
X * 
X * Revision 1.1  90/02/22  23:17:43  cpcahil
X * Initial revision
X * 
X */
END_OF_FILE
if test 6163 -ne `wc -c <'free.c'`; then
    echo shar: \"'free.c'\" unpacked with wrong size!
fi
# end of 'free.c'
fi
if test -f 'm_init.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'m_init.c'\"
else
echo shar: Extracting \"'m_init.c'\" \(2609 characters\)
sed "s/^X//" >'m_init.c' <<'END_OF_FILE'
X/*
X * (c) Copyright 1990, 1991 Conor P. Cahill (uunet!virtech!cpcahil).  
X * You may copy, distribute, and use this software as long as this
X * copyright statement is not removed.
X */
X
X#ifndef lint
Xstatic
Xchar rcs_hdr[] = "$Id: m_init.c,v 1.11 1992/01/10 17:28:03 cpcahil Exp $";
X#endif
X
X#include <stdio.h>
X#include "mallocint.h"
X
X/*
X * Function:	malloc_init()
X *
X * Purpose:	to initialize the pointers and variables use by the
X *		malloc() debugging library
X *
X * Arguments:	none
X *
X * Returns:	nothing of any value
X *
X * Narrative:	Just initialize all the needed variables.  Use mallopt
X *		to set options taken from the environment.
X *
X */
XVOIDTYPE
Xmalloc_init()
X{
X	char			* cptr;
X	char			* getenv();
X	union malloptarg	  m;
X
X	/*
X 	 * If already initialized...
X	 */
X	if( malloc_data_start != (char *) 0)
X	{
X		return;
X	}
X
X
X	malloc_data_start = sbrk(0);
X	malloc_data_end = malloc_data_start;
X	malloc_start.s.size = 0;
X	malloc_end = &malloc_start;
X	
X	if( (cptr=getenv("MALLOC_WARN")) != NULL )
X	{
X		m.i = atoi(cptr);
X		VOIDCAST mallopt(MALLOC_WARN,m);
X	}
X
X	if( (cptr=getenv("MALLOC_FATAL")) != NULL)
X	{
X		m.i = atoi(cptr);
X		VOIDCAST mallopt(MALLOC_FATAL,m);
X	}
X
X	if( (cptr=getenv("MALLOC_CKCHAIN")) != NULL)
X	{
X		m.i = atoi(cptr);
X		VOIDCAST mallopt(MALLOC_CKCHAIN,m);
X	}
X
X	if( (cptr=getenv("MALLOC_LOWFRAG")) != NULL)
X	{
X		m.i = atoi(cptr);
X		VOIDCAST mallopt(MALLOC_LOWFRAG,m);
X	}
X
X	if( (cptr=getenv("MALLOC_ERRFILE")) != NULL)
X	{
X		m.str = cptr;
X		VOIDCAST mallopt(MALLOC_ERRFILE,m);
X	}
X
X	if( (cptr=getenv("MALLOC_FILLAREA")) != NULL)
X	{
X		m.i = atoi(cptr);
X		VOIDCAST mallopt(MALLOC_FILLAREA,m);
X	}
X
X}
X
X/*
X * $Log: m_init.c,v $
X * Revision 1.11  1992/01/10  17:28:03  cpcahil
X * Added support for overriding void datatype
X *
X * Revision 1.10  1991/12/31  21:31:26  cpcahil
X * changes for patch 6.  See CHANGES file for more info
X *
X * Revision 1.9  1991/12/04  09:23:38  cpcahil
X * several performance enhancements including addition of free list
X *
X * Revision 1.8  91/11/25  14:41:54  cpcahil
X * Final changes in preparation for patch 4 release
X * 
X * Revision 1.7  91/11/24  00:49:26  cpcahil
X * first cut at patch 4
X * 
X * Revision 1.6  90/08/29  22:23:21  cpcahil
X * fixed mallopt to use a union as an argument.
X * 
X * Revision 1.5  90/08/29  21:22:50  cpcahil
X * miscellaneous lint fixes
X * 
X * Revision 1.4  90/05/11  15:53:35  cpcahil
X * fixed bug in initialization code.
X * 
X * Revision 1.3  90/05/11  00:13:08  cpcahil
X * added copyright statment
X * 
X * Revision 1.2  90/02/24  21:50:20  cpcahil
X * lots of lint fixes
X * 
X * Revision 1.1  90/02/24  17:10:53  cpcahil
X * Initial revision
X * 
X */
END_OF_FILE
if test 2609 -ne `wc -c <'m_init.c'`; then
    echo shar: \"'m_init.c'\" unpacked with wrong size!
fi
# end of 'm_init.c'
fi
if test -f 'm_perror.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'m_perror.c'\"
else
echo shar: Extracting \"'m_perror.c'\" \(2419 characters\)
sed "s/^X//" >'m_perror.c' <<'END_OF_FILE'
X/*
X * (c) Copyright 1990, 1991 Conor P. Cahill (uunet!virtech!cpcahil).  
X * You may copy, distribute, and use this software as long as this
X * copyright statement is not removed.
X */
X
X#ifndef lint
Xstatic
Xchar rcsid[] = "$Id: m_perror.c,v 1.9 1992/01/10 17:28:03 cpcahil Exp $";
X#endif
X
X#include "mallocint.h"
X
X/*
X * malloc errno error strings...
X */
X
Xchar *malloc_err_strings[] = 
X{
X	"No errors",
X	"Malloc chain is corrupted, pointers out of order",
X	"Malloc chain is corrupted, end before end pointer",
X	"Pointer is not within malloc area",
X	"Malloc region does not have valid magic number in header",
X	"Pointers between this segment and ajoining segments are invalid",
X	"Data has overrun beyond requested number of bytes",
X	"Data in free'd area has been modified",
X	"Data are is not in use (can't be freed or realloced)",
X	"Unable to get additional memory from the system",
X	"Pointer within malloc region, but outside of malloc data bounds",
X	"Malloc segment in free list is in-use",
X	(char *) 0
X};
X
X/*
X * Function:	malloc_perror()
X *
X * Purpose:	to print malloc_errno error message
X *
X * Arguments:	str	- string to print with error message
X *
X * Returns:	nothing of any value
X *
X * Narrative:
X */
XVOIDTYPE
Xmalloc_perror(str)
X	char	* str;
X{
X	register char 	* s;
X	register char 	* t;
X
X	if( str && *str)
X	{
X		for(s=str; *s; s++)
X		{
X			/* do nothing */;
X		}
X
X		VOIDCAST write(2,str,(unsigned)(s-str));
X		VOIDCAST write(2,": ",(unsigned)2);
X	}
X
X	t = malloc_err_strings[malloc_errno];
X
X	for(s=t; *s; s++)
X	{
X		/* do nothing */;
X	}
X
X	VOIDCAST write(2,t,(unsigned)(s-t));
X
X	VOIDCAST write(2,"\n",(unsigned)1);
X}
X
X/*
X * $Log: m_perror.c,v $
X * Revision 1.9  1992/01/10  17:28:03  cpcahil
X * Added support for overriding void datatype
X *
X * Revision 1.8  1991/12/04  09:23:38  cpcahil
X * several performance enhancements including addition of free list
X *
X * Revision 1.7  91/11/25  14:41:55  cpcahil
X * Final changes in preparation for patch 4 release
X * 
X * Revision 1.6  91/11/24  00:49:27  cpcahil
X * first cut at patch 4
X * 
X * Revision 1.5  90/08/29  21:25:08  cpcahil
X * added additional error message that was missing (and 
X * caused a core dump)
X * 
X * Revision 1.4  90/05/11  00:13:08  cpcahil
X * added copyright statment
X * 
X * Revision 1.3  90/02/24  21:50:21  cpcahil
X * lots of lint fixes
X * 
X * Revision 1.2  90/02/24  17:39:55  cpcahil
X * 1. added function header
X * 2. added rcs id and log strings.
X * 
X */
END_OF_FILE
if test 2419 -ne `wc -c <'m_perror.c'`; then
    echo shar: \"'m_perror.c'\" unpacked with wrong size!
fi
# end of 'm_perror.c'
fi
if test -f 'malloc.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'malloc.3'\"
else
echo shar: Extracting \"'malloc.3'\" \(27763 characters\)
sed "s/^X//" >'malloc.3' <<'END_OF_FILE'
X.TH DEBUG_MALLOC 3 "VTI" "" "1.4"
X.ds ]T 
X'\"/*
X'\" * (c) Copyright 1990,1991 Conor P. Cahill (uunet!virtech!cpcahil).  
X'\" * You may copy, distribute, and use this software as long as this
X'\" * copyright statement is not removed.
X'\" */
X'\" 
X'\" $Id: malloc.3,v 1.11 1992/01/28 18:01:06 cpcahil Exp $
X'\" 
X'\" eX macro -  this macro is used to set up code/picture examples.  It changes
X'\"             the point size & type of font, indents the example 1/2 inch,
X'\"		and turns off fill mode.  To use it just place a .eX before and
X'\"		after your example
X.de eX
X.ie \\n(eX>0 \{\
X.nr eX 0
X.ft
X.fi
X.vs
X.ps
X.in
X.sp \}
X.el \{\
X.nr eX 1
X.br
X.ne 5
X.sp
X.nf
X.ie \\n(.$>0 .in +\\$1
X.el .in +.5i
X.ie \\n(.$=2 .ps -\\$2
X.el .ps -2
X.ie \\n(.$=2 .vs -\\$2
X.el .vs -2
X.ft CW \}
X..
X.nr eX 0
X'\" 
X'\" fake set of VL LI and LE macros for man pages.  This set does handle nested
X'\" calls, but does absolutely NO error checking (so you better do it right).
X'\" 
X.de VL
X.br
X.ie t .nr VL 0\\$1
X.el .nr VL 0\\$1*2
X.ds VS \\$1 \\*(VS
X.in +\\n(VL
X.if t .in +.25i
X..
X.de LI
X.br
X.ti -\\n(VL
X.nr Vw \\n(VLm-\w'\\$1'
X.if \w'\\$1' \&\\$1\h'\\n(Vwu'\&\\c
X..
X.de LE
X.br
X.Le \\*(VS 
X..
X.de Le
X.in -\\n(VL
X.if t .in -.25i
X.ie t .nr VL \\$2
X.el .nr VL \\$2*2
X.ds VS \\$2 \\$3 \\$4 \\$5 \\$6 \\$7
X..
X.ds VS
X.nr VL 0
X.deMP
X.sp\\n(PDu
X..
X.SH NAME
Xmalloc \t- debugging malloc library
X.SH SYNOPSIS
X.nf
X\fB#include <malloc.h>
X.MP
Xchar * calloc(nelem,elsize);
Xunsigned nelem, elsize;
X.MP
Xvoid cfree(ptr)
Xchar * ptr;
X.MP
Xvoid free(ptr);
Xchar * ptr;
X.MP
Xchar * malloc(size);
Xunsigned size;
X.MP
Xint malloc_chain_check(flag);
Xint flag;
X.MP
Xvoid malloc_dump(fd);
Xint fd;
X.MP
Xvoid malloc_list(fd,histid1,histid2);
Xint fd;
Xunsigned long histid1, histid2;
X.MP
Xunsigned long malloc_size(histidptr);
Xunsigned long * histidptr;
X.MP
Xint mallopt(cmd,val);
Xint cmd; 
Xunion malloptarg val;
X.MP
Xchar * realloc(ptr,size);
Xchar * ptr;
Xunsigned size;\fP
X.fi
X.SH DESCRIPTION
XThis malloc library is a replacement for the standard library to be used
Xduring software development/debugging.  See the standard malloc(3) pages
Xfor more information on the use of the following functions:
X.MP
X.nf
X.in +.5i
X\fBcalloc\fP(), \fBcfree\fP(), \fBfree\fP(), \fBmalloc\fP(), \fBrealloc\fP()
X.in -.5i
X.fi
X.MP
XThis library differs from the standard malloc library in the
Xfollowing ways:
X.P
X1. Each malloc segment contains a magic number so that free can 
Xverify that the pointer passed points to a valid malloc segment.
X.P
X2. Each malloc segment is filled with a non-zero pattern so that code that
Xdepends upon malloc segments being null will fail.
X.P
X3. The size of each segment will be at least 1 byte larger than requested
Xand the extra bytes will be filled with a non-zero pattern.  When free is
Xcalled, it will verify that you did not go beyond the number of bytes 
Xyou asked for.
X.P
X4. When a segment is freed, it will be filled with a different non-zero pattern
Xto ensure that the program doesn't depend upon the use of already freed data.
X.P
X.ne 5
X5. Whenever any of the string or memory functions (str*, b*, mem*) are 
Xcalled with a pointer that is within the malloc arena,  the operation is
Xchecked to verify that it does not overrun the malloced segment.  A failure
Xof this check is considered a "warning level error" (described later) and
Xis handled accordingly.
X.P
X6. Run time checking can include verification of the malloc chain at each
Xand every call to one of the malloc functions or manually by calling the
Xmalloc_chain_check function.
X.P
X.br
X.ne 15
XWhen a problem is found, the following error message is displayed:
X.eX
XMALLOC Warning from funcname() (called from filename.c line ###):
XWarning message goes here
X.eX
X\fBfuncname\fP is the name of the function that has found the problem
Xand will usually be an entry point into the library.  The information
Xthat identifies where the function is called from will only be 
Xavailable if the source module was compiled with the \fBmalloc.h\fP
Xfile included.
X.P
XIf the error is caused by a problem in the malloc chain and the offending
Xchain element can be identified, the following information is also
Xdisplayed (NOTE: this is just a guess by the software, it may not
Xbe the actual culprit):
X.eX
XThis error is *probably* associated with the following allocation:
X
X   A call to malloc for 33 bytes in program.c on line 834.
X   This was the 172nd call to malloc.
X.eX
X.br
X.ne 15
XThis example assumes that \fBprogram.c\fP included the debugging 
Xlibrary \fBmalloc.h\fP file.  If not, the identification information
Xwill be as follows:
X.eX
XThis error is *probably* associated with the following allocation:
X
X   A call to malloc for 33 bytes in an unknown file.
X   This was the 172nd call to malloc.
X.eX
XThe identification of which call to malloc is associated with the 
Xproblem is helpful in that it gives you the information necessary
Xto set the breakpoint on the allocation function for that particular
Xinvocation (breakpoints usually can have counters associated with
Xthem).  The counters for the three primary allocation entry points (malloc,
Xcalloc, and realloc) are managed separately.
X.P
X.br
X.ne 5
XNOTE 1: if you want to set a breakpoint to capture this invocation
Xof malloc, the actual function that is being called is \fBdebug_malloc\fP
X(or \fBdebug_realloc\fP for \fBrealloc\fP and \fBdebug_calloc\fP for
X\fBcalloc\fP) and that is where the breakpoint should be set.
X.P
X.br
X.ne 19
XNOTE 2: Since the software is guessing at the offending malloc
Xchain segment, it is possible that one of the nearby segments 
Xis actually the culprit.  If the environment variable \s-2MALLOC_SHOW_LINKS\s+2
Xis set, both the segment preceding and the segment following the accused
Xsegment will also be identified.  The following is a sample output:
X.eX
XThis error is *probably* associated with the following allocation:
X
X    A call to malloc for 33 bytes in an unknown file.
X    This was the 172nd call to malloc.
X
X    The malloc chain element prior to the suspect allocation is from:
X
X    A call to calloc for 512 bytes in main.c line 16.
X    This was the 4th call to calloc.  This block has been freed.
X 
X    The malloc chain element following the suspect allocation is from: 
X
X    A call to realloc for 4096 bytes in func.c line 376.
X    This was the 1st call to realloc.
X.eX
X.br
X.ne 15
XOnce the error message has been displayed, the software will then 
Xdetermine how to handle the error.  This handling will be based upon
Xthe type of error level (warning or fatal) and the error handling in effect
Xfor that error level (as specified by calls to mallopt or via environment
Xvariables).  The coding for the error handling is as follows:
X.MP
X.VL 3
X.LI "\0\00"
Xcontinue operations
X.LI "\0\01"
Xdrop core and exit
X.LI "\0\02"
Xjust exit
X.LI "\0\03"
Xdrop core, but continue executing.  Core files will
Xbe placed into core.[PID].[counter] i.e: core.00123.001
X.LI "128"
Xdump malloc chain and continue
X.LI "129"
Xdump malloc chain, dump core, and exit
X.LI "130"
Xdump malloc chain, exit
X.LI "131"
Xdump malloc chain, dump core, continue processing
X.LE
X.P
X\fBmallopt\fP() is used to set the malloc debugging options. The
Xfollowing options can be set:
X.MP
X.VL 10
X.LI "\s-2MALLOC_WARN(100)\s+2"
Xset the error handling for warning level errors.  \fBval.i\fP is
Xan integer that can contain any one of the following values:
X.MP
X.VL 10
X.LI "\s-2M_HANDLE_IGNORE(0)\s+2"
Xignore error
X.LI "\s-2M_HANDLE_ABORT(1)\s+2"
Xdrop core and exit
X.LI "\s-2M_HANDLE_EXIT(2)\s+2"
Xjust exit (no core drop)
X.LI "\s-2M_HANDLE_CORE(3)\s+2"
Xdrop core, but keep on going
X.LE
X.MP
XIn addition, \s-2M_HANDLE_DUMP\s+2(128) may be or'd in to cause a dump
Xof the current malloc chain.
X.MP
X.LI "\s-2MALLOC_FATAL(101)\s+2"
Xset the error handling for fatal level errors.  \fBval.i\fP is
Xequivalent to \fBval.i\fP for MALLOC_WARN.
X.MP
X.LI "\s-2MALLOC_ERRFILE(102)\s+2"
Xset the destination for malloc error messages.  \fBval.str\fP
Xis a pointer to a character string containing the name of the file to be used
Xfor error messages.
X.MP
X.ne 3
X.LI "\s-2MALLOC_CKCHAIN(103)\s+2"
Xset the malloc chain checking flag.  If \fBval.i\fP is
Xnon-zero, chain checking at every call to malloc is turned on.
X.MP
X.LI "\s-2MALLOC_FILLAREA(104)\s+2"
Xset the malloc fill area flag.  If \fBval.i\fP is zero, malloc and free will
Xnot fill allocated/freed memory regions with special fill patterns.  Utilizing
Xthis feature increases the performance of the library while decreasing the
Xeffectiveness of tracking down overrun problems.  It is strongly recommended
Xthat this option not be used.
X.MP
X.LI "\s-2MALLOC_LOWFRAG(105)\s+2"
Xset the malloc allocation fragmentation handling level.  By default, malloc
Xuses a first fit algorithm for new allocations.  Under certain allocation
Xscenarios, this can lead to significant memory fragmentation because of
Xthe fact that little allocations can break big blocks up.
X.MP
XIf \fBval.i\fP is non-zero, malloc uses a best fit algorithm which will reduce
Xfragmentation.  This mechanism, while using less memory, is slower because
Xthe entire free list is checked instead of just checking until we find a
Xsegment that is at least big enough.  Normally you will not need to set
Xthis variable.
X.LE
X.MP
X.ne 10
XFor example, to set up the session to generate a core file for
Xevery malloc warning, to drop core and exit on a malloc fatal, and 
Xto log all messages to the file "malloc_log" do the following:
X.eX
X#include <malloc.h>
Xunion malloptarg  m;
X
Xm.i = 131;
Xmallopt(MALLOC_WARN,m);
X
Xm.i = 1;
Xmallopt(MALLOC_FATAL,m);
X
Xm.str = "malloc_log";
Xmallopt(MALLOC_ERRFILE,m);
X.eX
X\fBmallopt\fP() can be used to set/alter the debugging options at any
Xtime (i.e. you may want to turn on chain-checking after the program startup if
Xthe program startup does a lot of allocations which are known to be OK).
X.P
X.ne 5
X\fBmalloc_chain_check\fP() will check the status of the malloc arena.
XIf \fBflag\fP is non-zero, an error found in the chain will cause a 
Xfatal error.  \fBmalloc_chain_check\fP() returns zero when there are no
Xproblems found in the malloc chain, non-zero otherwise.
X.P
X.ne 5
X\fBmalloc_dump\fP() will dump a list of all in-use malloc segments 
Xand the first few bytes of each segment.  If the environment variable
X\s-1MALLOC_DETAIL\s+1 is set, all segments (including those that have
Xbeen freed) are listed and additional internal information is displayed.
X\fBfd\fP is the file descriptor to write the data to.
X.P
X.ne 6
X\fBmalloc_list\fP() will dump a list in the same format as \fBmalloc_dump\fP but
Xonly the items that are still in use and which have been allocated within
Xthe malloc history id range specified by \fBhistid1\fP and
X\fBhistid2\fP, inclusive.  The \fBhistid\fPs are obtained from calls
Xto \fBmalloc_size\fP(). This is especially useful in tracking down memory
Xleaks.  \fBfd\fP is the file descriptor to write the data to.
X.P
X.ne 6
X\fBmalloc_size\fP() returns the amount of malloc data that is currently
Xin use (in bytes).  If \fBhistidptr\fP is not NULL, it is taken to be a pointer
Xto a place to store the current malloc history id which can be used later
Xwhen \fBmalloc_list\fP is called to list items that are still in use.
X.P
X.ne 10
XThe following example shows the typical use of the \fBmalloc_size\fP and
X\fBmalloc_list\fP functions in tracking down memory leaks:
X.eX
Xunsigned long	histid1, histid2, orig_size, current_size;
X
Xorig_size = malloc_size(&histid1);
X
X/* ..... go do lots of stuff ...... */
X
Xcurrent_size = malloc_size(&histid2);
X
Xif( current_size != orig_size )
X{
X	malloc_list(2,histid1,histid2);
X}
X.eX
X.br
X.ne 20
X.SH "USAGE"
XThe library can be used in several modes, each increasingly intrusive (i.e. 
Xrequiring changes to be made to the build process and/or source code).  However,
Xthe extra cost of a little intrusiveness is repaid in much better problem
Xidentification.  Each mode is built upon the previous modes and therefore
Xrequires the changes and/or commands specified in the lower modes.
X.P
X.ne 10
X\fBMODE 1 - library substitution\fP
X.P
XThe simplest use is to just link the object module with the \fBlibdbmalloc.a\fP.
XBe sure to have this library before the C library (\fBlibc.a\fP) on the
Xlink command (this is automatic if you use \fBcc\fP to link and specify the 
Xdebug library without specifying the C library).
X.P
XThis mode links in all of the debug versions of the library modules and
Xwill trap as many errors as it can (yes, there are errors that the malloc
Xlibrary cannot catch).  Environment variables can be used to control the
Xbehavior of the library.
X.P
X.ne 15
X\fBMODE 2 - malloc.h inclusion\fP
X.P
XThis mode involves including the \fBmalloc.h\fP file included with the 
Xdebugging library.  The malloc.h file includes macros that will identify
Xthe source line and file name for each debugging function called.  This
Xis how the library is able to tell you that it was the call to malloc
Xon line 55 in file junk.c.
X.P
X.ne 8
XTypically you should always include malloc.h in your source files and just
Xuse the -I INCLUDEDIR directive for the compiler to point the compiler to
Xthe debugging version of the header file instead of the normal file.  That
Xway you don't have to change the source files when you want to turn off
Xthe debugging library.
X.P
XNOTE: Once you compile code in this mode, you must recompile the code 
Xwithout the debugging malloc.h include file in order to get the software
Xto use the non-debugging functions.
X.P
X.ne 10
X\fBMODE 3 - run-time specification of options\fP
X.P
XEnvironment variables can be used to control the behavior of the debugging
Xlibrary to some extent.  However, this control is very coarse in that
Xyou only have one setting available for the entire running of the program.
X.P
XThis can be a problem if you want to turn on malloc chain checking, but
Xknow that the problem occurs between a relatively narrow portion of the
Xcode and don't want to take the hit of having chain checking on for the
Xentire program execution.  
X.P
X.ne 15
XThe solution to this problem is to include calls to mallopt() with the
Xdebugging options which set the appropriate modes when you want them set.
XSince you don't want to have to change the code to remove and add these
Xfunctions every time you decide to include malloc debugging or not, the 
X\fBmalloc.h\fP file defines the preprocessor symbol \s-2_DEBUG_MALLOC_INC\s+2
Xwhich can be used in your code as follows:
X.eX
X#ifdef _DEBUG_MALLOC_INC
X	mallopt(.... );
X#endif
X.eX
XIn addition to setting behavior options, you might want to make use of
Xthe memory leak detection routines in this mode.  These calls should
Xalso be surrounded by #ifdefs for the debug malloc symbol so that you
Xcan leave them in the code and automatically get
Xthe increased functionality whenever you compile with the debugging library.
X.br
X.ne 15
X.SH "ENVIRONMENT VARIABLES"
XEnvironment variables can be used to control error handling, error logging
Xand malloc chain checking at run time.  The following environment variables
Xare used:
X.P
X.VL 10
X.br
X.ne 4
X.LI "\s-2MALLOC_CKCHAIN\s+2"
Xif 1, turns on malloc chain checking at every call to any
Xof the malloc functions.
X.br
X.ne 4
X.LI "\s-2MALLOC_DETAIL\s+2"
Xif set, \fBmalloc_dump\fP shows some internal detail for each 
Xentry in the chain.  This info is probably only of use if you are debugging 
Xthe malloc library itself.
X.br
X.ne 4
X.LI "\s-2MALLOC_ERRFILE\s+2"
Xspecifies the error log file for error messages.  
X.br
X.ne 4
X.LI "\s-2MALLOC_FATAL\s+2"
Xspecifies the error handling for fatal errors
X.br
X.ne 4
X.LI "\s-2MALLOC_FILLAREA\s+2"
Xspecifies the fill area flag setting.  If zero, malloc/free area filling 
Xand checking is disabled (thereby increasing performance, while decreasing
Xeffectiveness of the library).
X.br
X.ne 4
X.LI "\s-2MALLOC_LOWFRAG\s+2"
Xif 1, turns on best fit allocation algorithm.  Otherwise, first fit algorithm
Xis used for finding allocation segments (which can cause memory fragmentation).
X.br
X.ne 4
X.LI "\s-2MALLOC_SHOW_LINKS\s+2"
Xwhen an error is found, the suspected allocation is
Xdisplayed.  However, since it is possible that the next or previous allocation
Xin the malloc chain was the actual culprit these links may be of interest.
XIf this variable is set to non-zero (i.e. 1) the links will also be shown.
X.br
X.ne 2
X.LI "\s-2MALLOC_WARN\s+2"
Xspecifies the error handling for warning errors
X.LE
X.P
XAs an example, to set up the session to generate a core file for
Xevery malloc warning, to drop core and exit on a malloc fatal, and 
Xto log all messages to the file "malloc_log" do the following:
X.eX
XMALLOC_WARN=131
XMALLOC_FATAL=1
XMALLOC_ERRFILE=malloc_log
X
Xexport MALLOC_WARN MALLOC_FATAL MALLOC_ERRFILE
X.eX
X.br
X.ne 15
X.SH "ERROR MESSAGES"
XThe following error messages are reported by the library:
X.VL 15
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_BAD_CONNECT(5)\s+2"
XPointers between this segment and adjoining segments are invalid.
X.MP
XThis error indicates that the malloc chain has been corrupted.
XThis is most often caused by an overwrite of the malloc header
Xby an access via the previous malloc segment.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_BAD_MAGIC(4)\s+2"
XMalloc region does not have a valid magic number in header.
X.MP
XThis error is caused by several mechanisms including \fBfree\fP()ing
Xthe same pointer twice or a pointer that was not returned by \fBmalloc\fP(),
Xor writing beyond the end of a segment.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_BAD_PTR(3)\s+2"
XPointer is not within malloc region.
X.MP
XThe pointer passed to \fBfree\fP or\fPrealloc\fP is not pointer 
Xreturned by \fBmalloc\fP.  Another cause is corruption of the
Xmalloc chain by writing beyond the end of a segment.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_CHAIN_BROKE(1)\s+2"
XMalloc chain is corrupted, pointers out of order.
X.MP
XCorruption has been detected in the malloc chain that is
Xrelated to the relative positions of the malloc chain segments
Xin memory.  This is an indication that someone has overwritten
Xbeyond the amount they allocated.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_FREELIST_BAD(11)\s+2"
XMalloc segment in free list is in-use.
X.MP
XA segment that is in the free-list is flagged as in-use.  This is usually
Xcaused by overwriting from the previous segment in the malloc chain.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_NOMORE_MEM(9)\s+2"
XUnable to get additional memory from the system.
X.MP
XThe system call \fBsbrk\fP failed to obtain more memory
Xfor the program.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_NOT_INUSE(8)\s+2"
XData is not in use (can't be freed or reallocated).
X.MP
XA pointer to a malloc segment has been passed to \fBfree\fP() or
X\fBrealloc\fP(), but this segment has already been freed.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_NO_END(2)\s+2"
XMalloc chain is corrupted, end before end pointer.
X.MP
XYet another overwrite problem.   This error means that we got to 
Xwhat we believe is the end of the chain, but it does not match
Xthe recorded end of the chain.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_OUTOF_BOUNDS(10)\s+2"
XPointer within malloc region, but outside of malloc data bounds.
X.MP
XThis is caused by a call to one of the string/memory functions
Xthat attempt to read/write bytes that are not included in
Xthe allocation associated with that memory.  This is the
Xmost typical error that you will see from the malloc library.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_OVERRUN(6)\s+2"
XData has overrun beyond requested number of bytes.
X.MP
XThis error is detected by \fBfree\fP() and indicates that the
Xcurrent segment has written data beyond the number of bytes that
Xit requested.  This only catches overwrites when they are within
Xthe extra space allocated with each segment (this can range from
Xone to eight bytes).  If the overwrite occurs further along it
Xwill usually cause some corruption in the malloc chain.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_REUSE(7)\s+2"
XData in free'd area has been modified.
X.MP
XData in a freed segment has been modified.  This usually indicates
Xthat the program is using a pointer after it called free, but it
Xmay also be caused by an overwrite from a previous segment in 
Xthe chain.
X.LE
X.P
X.br
X.ne 15
X.SH "DUMP OUTPUT"
XSample dump/list output:
X.eX
X************************** Dump of Malloc Chain ****************************
XPOINTER     FILE  WHERE         LINE      ALLOC        DATA     HEX DUMP   
XTO DATA      ALLOCATED         NUMBER     FUNCT       LENGTH  OF BYTES 1-7 
X-------- -------------------- ------- -------------- ------- --------------
X0x403DB4 testerr.c                 15 malloc(1)           40 01010101010101  
X0x403E0C testerr.c                 16 realloc(1)          20 01010101010101  
X.eX
XThe info in each column is as follows:
X.MP
X.VL 10
X.br
X.ne 4
X.LI "\s-2POINTER\s+2"
Xthe pointer returned by the allocation function (the pointer
Xthe the allocated data area).
X.MP
X.br
X.ne 8
X.LI "\s-2FILE\s+2"
Xthe name of the file where the allocation function was called.  This
Xinformation is only available if the source file includes the \fBmalloc.h\fP
Xfile from this library (as opposed to the system include file).  If
Xthe source file did not include this file, the file will be listed
Xas unknown and the line number will be blank.
XNote that any malloc calls from system libraries will probably not have been
Xcompiled with the \fBmalloc.h\fP file included and will therefore
Xappear as unknown.
X.MP
X.br
X.ne 4
X.LI "\s-2LINE NUM\s+2"
XThe line number of the line that called the allocation function.  This 
Xfield will be left blank if the \fBmalloc.h\fP from this library
Xwas not included in the source file when it was compiled. 
X.MP
X.br
X.ne 5
X.LI "\s-2ALLOC FUNC\s+2"
XThe allocation function called: \fBmalloc\fP, \fBrealloc\fP, or \fBcalloc\fP.
XThe number in parenthesis following the function name is the call number
Xfor that particular function.  For example: malloc(1) means that this
Xallocation was the 1st call to malloc.
X.MP
X.br
X.ne 2
X.LI "\s-2DATA LEN\s+2"
XThe number of bytes allocated.
X.MP
X.br
X.ne 6
X.LI "\s-2HEX DUMP\s+2"
XA hexidecimal dump of the first seven bytes in the allocated data.  This example
Xshows the bytes filled with 0x01s which happen to be the fill pattern used
Xby the malloc library (to make sure that one doesn't depend upon the 
Xfact that some calls to malloc result in NULL bytes).  So the
Xallocations that are shown haven't stored any data in the area yet.
X.LE
X.MP
X.br
X.ne 15
XIf the environment variable \s-2MALLOC_DETAIL\s+2 is defined, the 
Xfollowing additional information will be included:
X.eX
X************************************************************** Du... 
X                             FREE     FREE                  ACTUAL SIZE    ...
X  PTR      NEXT     PREV     NEXT     PREV      FLAGS       INT    HEX     ...
X-------- -------- -------- -------- -------- ---------- -------- --------- ...
X0x403C94 0x403CEC 0x40326C 0x000000 0x000000 0x03156111       48(0x000030) ...
X0x403CEC 0x403D2C 0x403C94 0x000000 0x000000 0x03156121       24(0x000018) ...
X0x403D2C 0x403D6C 0x403CEC 0x000000 0x403D6C 0x03156120       24(0x000018) ...
X0x403D6C 0x000000 0x403D2C 0x403D2C 0x000000 0x03156120       24(0x000018) ...
X
XMalloc start:      0x40326C
XMalloc end:        0x403D2C
XMalloc data start: 0x403C94
XMalloc data end:   0x405C94
XMalloc free list:  0x403D6C
X                -> 0x403D2C
X.eX
XNOTE that I cut off the example at the point where the normal output
Xwould begin (hence the ...).
X.MP
XThe info in each column is as follows:
X.MP
X.VL 8
X.LI "\s-2PTR\s+2"
XThe malloc chain pointer for the segment (the address of the segment).
X.MP
X.LI "\s-2NEXT\s+2"
XThe pointer to the next segment in the chain.
X.MP
X.LI "\s-2PREV\s+2"
XThe pointer to the previous segment in the chain.
X.MP
X.LI "\s-2FREE NEXT\s+2"
XThe pointer to the next segment in the free list.
X.MP
X.LI "\s-2FREE PREV\s+2"
XThe pointer to the previous segment in the free list.
X.MP
X.ne 10
X.LI "\s-2FLAGS\s+2"
XThe flags associated with this segment.  This is a long
Xinteger which contains the following fields
X.MP
X.VL 6
X.LI "0xFFFFFF00"
Xthe magic number.  This should be 0x03156100 (probably 
Xsomeone's birthday).
X.MP
X.LI "0x00000070"
Xthe type of allocation function. Malloc (x010), realloc (0x20), or
Xcalloc (0x30) are the only valid values for this field).
X.MP
X.LI "0x00000001"
Xthe in-use flag.  if this value is non-zero, the indicated segment
Xis currently in use (not freed).
X.LE
X.MP
X.LI "\s-2ACTUAL SIZE\s+2"
XThe actual size reserved for the allocation in both decimal and
Xhex.  This will be at least one byte more than the requested size, and
Xas much as 8, so that we can check to see if the allocation has been
Xoverrun.
X.LE
X.MP
XMalloc \fBstart\fP and \fBend\fP are pointers to the first and
Xlast malloc chain segment, respectively.
X.MP
XMalloc \fBdata start\fP and \fBdata end\fP are the lowest and highest
Xdata bytes managed my the malloc sub-system.  These are only used as
Xa quick check to see if a pointer is in the malloc region before we
Xgo hunting down the chain trying to identify the segment it belongs to.
X.MP
XMalloc \fBfree list\fP is a chain of the elements in the free list (so 
Xit is easier for the programmer to follow the free list if they choose 
Xto).  The address of each element in the list follows below the list head.
X.br
X.ne 15
X.SH PERFORMANCE
XThis malloc library and its associated string and memory functions are
Xmuch less efficient than the standard functions due in part to the extra
Xerror checking.  You do not want to use this library when generating a
Xproduction (i.e. releasable) version of your software.  It should only
Xbe used during development and testing.
X.P
X.ne 10
XThe following environment variable settings will give you the best
Xperformance (at the expense of some additional error checking):
X.eX
XMALLOC_CKCHAIN=0
XMALLOC_FILLAREA=0
XMALLOC_LOWFRAG=0
X.eX
XWe strongly recommend against setting MALLOC_FILLAREA to zero because, while
Xit will increase the performance considerably, it takes away the capability
Xto uncover small malloc overruns which don't overrite the pointers surrounding
Xthe malloc regions.
X.P
X.ne 5
XAnyway, with these settings, the malloc library runs at about 1/2 the
Xspeed (things only take twice as long) as the standard library.  If you program
Xspends most of its time in malloc, it will still be slow (but perhaps this is
Xan indication that you need to consider changing the way you are using 
Xmalloc).
X.br
X.ne 15
X.SH WARNINGS
XThe include file for this library "malloc.h" should be included after
Xthe includes for any system related information.  This is because "malloc.h"
Xredefines several system functions including string and memory routines
Xand this will usually cause compilation errors if malloc.h is processed
Xfirst (of course, the compile errors will talk about errors in the other
Xsystem include files like string.h).
X.P
XThere is a possibility that the use of \fBsbrk\fP() by other modules
Xwill cause this library to get confused and possibly report 
Xsome pointers as bad when the really aren't part of the malloc chain
Xitself.  Therefore the direct use of \fBsbrk\fP() is strongly discouraged.
X.P
XThis library attempts to trap errors and exit/handle them gracefully.  
XHowever, the nature of the problems may be such that it causes the 
Xcode in the library itself to crash.  There is no way to avoid this,
Xbut if it does occur,  turn on chain checking to narrow the place where
Xit will occur.
X.P
XThe functions in this library will often conflict with duplicate functions
Xin shared library versions of libc.a.  This is usually due to the 
Xfact that some shared library modules have explicit references to shared
Xlibrary versions of the debug functions.  The only way around this is
Xto not use the shared library when linking.
X.P
XThis malloc library, like most malloc libraries, is not re-entrant 
Xand therefore should not be called from interrupt handlers because of the
Xpotential for receiving an interrupt in the middle of a call to malloc
Xwhich would really mess things up.
X.SH SEE ALSO
Xmalloc(3)
X.SH AUTHOR
X.nf
XConor P. Cahill
XVirtual Technologies Incorporated
X46030 Manekin Plaza, Suite 160
XSterling VA 22170
X703-430-9247
X.MP
Xuunet!virtech!cpcahil
END_OF_FILE
if test 27763 -ne `wc -c <'malloc.3'`; then
    echo shar: \"'malloc.3'\" unpacked with wrong size!
fi
# end of 'malloc.3'
fi
if test -f 'malloc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'malloc.h'\"
else
echo shar: Extracting \"'malloc.h'\" \(13852 characters\)
sed "s/^X//" >'malloc.h' <<'END_OF_FILE'
X/*
X * (c) Copyright 1990, 1991 Conor P. Cahill (uunet!virtech!cpcahil).  
X * You may copy, distribute, and use this software as long as this
X * copyright statement is not removed.
X */
X/*
X * $Id: malloc.h,v 1.20 1992/01/28 21:42:25 cpcahil Exp $
X */
X
X#ifndef _DEBUG_MALLOC_INC
X#define _DEBUG_MALLOC_INC 1
X
X/*
X * The following lines will probably need to be changed depending
X * upon the OS to which this library is ported.  Typically, older BSD
X * systems will need:
X *
X *		typedef char	DATATYPE;
X *		typedef int	SIZETYPE;
X *		typedef int	VOIDTYPE;
X *
X * System V style systems with compilers that understand void will usually
X * use:
X *
X *		typedef char	DATATYPE;
X *		typedef int	SIZETYPE;
X *		typedef void	VOIDTYPE;
X *
X * ANSI-C and/or c++ compilers will usually use:
X *
X *		typedef void	DATATYPE;
X *		typedef int	SIZETYPE;
X *		typedef void	VOIDTYPE;
X *
X * (Note: while the library can be linked with c++ modules, it itself 
X *  cannot be compiled with c++ - yet.  This header file has been modified
X *  so that it can be included by C++ modules that use malloc)
X * 
X * And some other systems will require sizetype to be one of the following:
X * 
X * 		typedef unsigned int	SIZETYPE;
X * or
X *
X *		typedef size_t		SIZETYPE;
X *
X * Because I am lazy, I have setup #ifdefs for the few systems that I normally
X * test the library on (so if you are on one of these systems, you are lucky
X * and don't have to worry about changing it - hopefully)
X * 
X * NOTE: for those of you who are wondering why I dont just use a command line
X * option on the compiler (set via the makefile) to determint these settings:
X * the reason is that this file must be able to be included in existing 
X * software modules with no changes to the code and with as little changes
X * as possible to the command line.  It is easier to edit this file once, when
X * you install the system, than have to specify three -Ds on each compile 
X * when it is used.
X *
X * NOTE2: if void is not supported, then you also need to disable or remove
X * the VOIDCAST #define
X */
X
X#if __hpux	/* HP/UX (at least 8.0 and above) */
X		typedef	void	DATATYPE;
X		typedef size_t	SIZETYPE;
X		typedef void	VOIDTYPE;
X#else
X#if i386
X#if __STDC__ || __cplusplus
X		typedef void		DATATYPE;
X		typedef unsigned int	SIZETYPE;
X		typedef void		VOIDTYPE;
X#else
X		typedef char		DATATYPE;
X		typedef int		SIZETYPE;
X		typedef void		VOIDTYPE;
X#endif /* __STDC__ */
X#else  /* i386     */
X#if _IBMR2
X		typedef void		DATATYPE;
X		typedef unsigned long	SIZETYPE;
X		typedef void		VOIDTYPE;
X#else  /* _IBMR2   */
X	"you need to define entries here"
X#endif /* _IBMR2   */
X#endif /* i386     */
X#endif /* __hpux   */
X
X/*
X * Comment out the following line if your compiler doesn't support the VOID
X * data type.
X */
X#define VOIDCAST (void)
X
X/*
X * since we redefine much of the stuff that is #defined in string.h and 
X * memory.h, we should do what we can to make sure that they don't get 
X * included after us.  This is typically accomplished by a special symbol
X * (similar to _DEBUG_MALLOC_INC defined above) that is #defined when the
X * file is included.  Since we don't want the file to be included we will
X * #define the symbol ourselves.  These will typically have to change from
X * one system to another.  I have put in several standard mechanisms used to
X * support this mechanism, so hopefully you won't have to modify this file.
X */
X#ifndef _H_STRING
X#define _H_STRING		1
X#endif 
X#ifndef __STRING_H
X#define __STRING_H		1
X#endif 
X#ifndef _STRING_H_
X#define _STRING_H_		1
X#endif 
X#ifndef _STRING_INCLUDED
X#define _STRING_INCLUDED	1
X#endif
X#ifndef _H_MEMORY
X#define _H_MEMORY		1
X#endif
X#ifndef __MEMORY_H
X#define __MEMORY_H		1
X#endif
X#ifndef _MEMORY_H_
X#define _MEMORY_H_		1
X#endif
X#ifndef _MEMORY_INCLUDED
X#define _MEMORY_INCLUDED	1
X#endif
X
X/*
X * Malloc warning/fatal error handler defines...
X */
X#define M_HANDLE_DUMP	0x80  /* 128 */
X#define M_HANDLE_IGNORE	0
X#define M_HANDLE_ABORT	1
X#define M_HANDLE_EXIT	2
X#define M_HANDLE_CORE	3
X	
X/*
X * Mallopt commands and defaults
X *
X * the first four settings are ignored by the debugging mallopt, but are
X * here to maintain compatibility with the system malloc.h.
X */
X#define M_MXFAST	1		/* ignored by mallopt		*/
X#define M_NLBLKS	2		/* ignored by mallopt		*/
X#define M_GRAIN		3		/* ignored by mallopt		*/
X#define M_KEEP		4		/* ignored by mallopt		*/
X#define MALLOC_WARN	100		/* set malloc warning handling	*/
X#define MALLOC_FATAL	101		/* set malloc fatal handling	*/
X#define MALLOC_ERRFILE	102		/* specify malloc error file	*/
X#define MALLOC_CKCHAIN	103		/* turn on chain checking	*/
X#define MALLOC_FILLAREA	104		/* turn off area filling	*/
X#define MALLOC_LOWFRAG	105		/* use best fit allocation mech	*/
X
Xunion malloptarg
X{
X	int	  i;
X	char	* str;
X};
X
X/*
X * Malloc warning/fatal error codes
X */
X
X#define M_CODE_CHAIN_BROKE	1	/* malloc chain is broken	*/
X#define M_CODE_NO_END		2	/* chain end != endptr		*/
X#define M_CODE_BAD_PTR		3	/* pointer not in malloc area	*/
X#define M_CODE_BAD_MAGIC	4	/* bad magic number in header	*/
X#define M_CODE_BAD_CONNECT	5	/* chain poingers corrupt	*/
X#define M_CODE_OVERRUN		6	/* data overrun in malloc seg	*/
X#define M_CODE_REUSE		7	/* reuse of freed area		*/
X#define M_CODE_NOT_INUSE	8	/* pointer is not in use	*/
X#define M_CODE_NOMORE_MEM	9	/* no more memory available	*/
X#define M_CODE_OUTOF_BOUNDS	10	/* gone beyound bounds 		*/
X#define M_CODE_FREELIST_BAD	11	/* inuse segment on freelist	*/
X
X#ifndef __stdcargs
X#if  __STDC__ || __cplusplus
X#define __stdcargs(a) a
X#else
X#define __stdcargs(a) ()
X#endif
X#endif
X
X#if __cplusplus
Xextern "C" {
X#endif
X
XVOIDTYPE	  malloc_dump __stdcargs((int));
XVOIDTYPE	  malloc_list __stdcargs((int,unsigned long, unsigned long));
Xint		  mallopt __stdcargs((int, union malloptarg));
XDATATYPE	* debug_calloc __stdcargs((const char *,int,SIZETYPE,SIZETYPE));
XVOIDTYPE	  debug_cfree __stdcargs((const char *, int, DATATYPE *));
XVOIDTYPE	  debug_free __stdcargs((const char *, int, DATATYPE *));
XDATATYPE	* debug_malloc __stdcargs((const char *,int, SIZETYPE));
XDATATYPE	* debug_realloc __stdcargs((const char *,int,
X					    DATATYPE *,SIZETYPE));
Xunsigned long	  DBmalloc_size __stdcargs((const char *,int,unsigned long *));
Xint		  DBmalloc_chain_check __stdcargs((const char *,int,int));
X
X/*
X * memory(3) related prototypes
X */
XDATATYPE 	* DBmemccpy __stdcargs((const char *file, int line,
X					DATATYPE *ptr1, const DATATYPE *ptr2,
X					int ch, SIZETYPE len));
XDATATYPE 	* DBmemchr __stdcargs((const char *file, int line,
X					const DATATYPE *ptr1, int ch,
X					SIZETYPE len));
XDATATYPE	* DBmemmove __stdcargs((const char *file, int line,
X					DATATYPE *ptr1, const DATATYPE *ptr2,
X					SIZETYPE len));
XDATATYPE	* DBmemcpy __stdcargs((const char *file, int line,
X					DATATYPE *ptr1, const DATATYPE *ptr2,
X					SIZETYPE len));
Xint		  DBmemcmp __stdcargs((const char *file, int line,
X					const DATATYPE *ptr1,
X					const DATATYPE *ptr2, SIZETYPE len));
XDATATYPE	* DBmemset __stdcargs((const char *file, int line,
X					DATATYPE *ptr1, int ch, SIZETYPE len));
XDATATYPE	* DBbcopy __stdcargs((const char *file, int line,
X					const DATATYPE *ptr2, DATATYPE *ptr1,
X					SIZETYPE len));
XDATATYPE 	* DBbzero __stdcargs((const char *file, int line,
X					DATATYPE *ptr1, SIZETYPE len));
Xint		  DBbcmp __stdcargs((const char *file, int line,
X					const DATATYPE *ptr2,
X					const DATATYPE *ptr1, SIZETYPE len));
X
X/*
X * string(3) related prototypes
X */
Xchar		* DBstrcat __stdcargs((const char *file,int line, char *str1,
X					const char *str2));
Xchar		* DBstrdup __stdcargs((const char *file, int line,
X					const char *str1));
Xchar		* DBstrncat __stdcargs((const char *file, int line, char *str1,
X					const char *str2, SIZETYPE len));
Xint		  DBstrcmp __stdcargs((const char *file, int line,
X					const char *str1, const char *str2));
Xint		  DBstrncmp __stdcargs((const char *file, int line,
X					const char *str1, const char *str2,
X					SIZETYPE len));
Xchar		* DBstrcpy __stdcargs((const char *file, int line, char *str1,
X					const char *str2));
Xchar		* DBstrncpy __stdcargs((const char *file, int line, char *str1,
X					const char *str2, SIZETYPE len));
XSIZETYPE	  DBstrlen __stdcargs((const char *file, int line,
X					const char *str1));
Xchar		* DBstrchr __stdcargs((const char *file, int line,
X					const char *str1, int c));
Xchar		* DBstrrchr __stdcargs((const char *file, int line,
X					const char *str1, int c));
Xchar		* DBindex __stdcargs((const char *file, int line,
X					const char *str1, int c));
Xchar		* DBrindex __stdcargs((const char *file, int line,
X					const char *str1, int c));
Xchar		* DBstrpbrk __stdcargs((const char *file, int line,
X					const char *str1, const char *str2));
XSIZETYPE	  DBstrspn __stdcargs((const char *file, int line,
X					const char *str1, const char *str2));
XSIZETYPE	  DBstrcspn __stdcargs((const char *file, int line,
X					const char *str1, const char *str2));
Xchar		* DBstrstr __stdcargs((const char *file, int line,
X					const char *str1, const char *str2));
Xchar		* DBstrtok __stdcargs((const char *file, int line, char *str1,
X					const char *str2));
X
X#if __cplusplus
X};
X#endif
X
X/*
X * Macro which enables logging of the file and line number for each allocation
X * so that it is easier to determine where the offending malloc comes from.
X *
X * NOTE that only code re-compiled with this include file will have this 
X * additional info.  Calls from libraries that have not been recompiled will
X * just have a null string for this info.
X */
X#ifndef IN_MALLOC_CODE
X
X/*
X * allocation functions
X */
X#define malloc(len)		debug_malloc( __FILE__,__LINE__, (len))
X#define realloc(ptr,len)	debug_realloc(__FILE__,__LINE__, (ptr), (len))
X#define calloc(numelem,size)	debug_calloc(__FILE__,__LINE__,(numelem),(size))
X#define cfree(ptr)		debug_cfree(__FILE__,__LINE__,(ptr))
X#define free(ptr)		debug_free(__FILE__,__LINE__,(ptr))
X#define malloc_size(histptr)	DBmalloc_size(__FILE__,__LINE__,(histptr))
X#define malloc_chain_check(todo) DBmalloc_chain_check(__FILE__,__LINE__,(todo))
X
X/*
X * memory(3) related functions
X */
X#define memccpy(ptr1,ptr2,ch,len) DBmemccpy(__FILE__,__LINE__,ptr1,ptr2,ch,len)
X#define memchr(ptr1,ch,len)	  DBmemchr(__FILE__,__LINE__,ptr1,ch,len)
X#define memmove(ptr1,ptr2,len)    DBmemmove(__FILE__,__LINE__,ptr1, ptr2, len)
X#define memcpy(ptr1,ptr2,len)     DBmemcpy(__FILE__, __LINE__, ptr1, ptr2, len)
X#define memcmp(ptr1,ptr2,len)     DBmemcmp(__FILE__,__LINE__,ptr1, ptr2, len)
X#define memset(ptr1,ch,len)       DBmemset(__FILE__,__LINE__,ptr1, ch, len)
X#define bcopy(ptr2,ptr1,len)      DBbcopy(__FILE__,__LINE__,ptr2,ptr1,len)
X#define bzero(ptr1,len)           DBbzero(__FILE__,__LINE__,ptr1,len)
X#define bcmp(ptr2,ptr1,len)       DBbcmp(__FILE__, __LINE__, ptr2, ptr1, len)
X
X/*
X * string(3) related functions
X */
X#define index(str1,c)		  DBindex(__FILE__, __LINE__, str1, c)
X#define rindex(str1,c)		  DBrindex(__FILE__, __LINE__, str1, c)
X#define strcat(str1,str2)	  DBstrcat(__FILE__,__LINE__,str1,str2)
X#define strchr(str1,c)		  DBstrchr(__FILE__, __LINE__, str1,c)
X#define strcmp(str1,str2)	  DBstrcmp(__FILE__, __LINE__, str1, str2)
X#define strcpy(str1,str2)	  DBstrcpy(__FILE__, __LINE__, str1, str2)
X#define strcspn(str1,str2)	  DBstrcspn(__FILE__, __LINE__, str1,str2)
X#define strdup(str1)		  DBstrdup(__FILE__, __LINE__, str1)
X#define strlen(str1)		  DBstrlen(__FILE__, __LINE__, str1)
X#define strncat(str1,str2,len)	  DBstrncat(__FILE__, __LINE__, str1,str2,len)
X#define strncpy(str1,str2,len)	  DBstrncpy(__FILE__,__LINE__,str1,str2,len)
X#define strncmp(str1,str2,len)	  DBstrncmp(__FILE__, __LINE__, str1,str2,len)
X#define strpbrk(str1,str2)	  DBstrpbrk(__FILE__, __LINE__, str1,str2)
X#define strrchr(str1,c)		  DBstrrchr(__FILE__,__LINE__,str1,c)
X#define strspn(str1,str2)	  DBstrspn(__FILE__, __LINE__, str1,str2)
X#define strstr(str1,str2)	  DBstrstr(__FILE__, __LINE__, str1, str2)
X#define strtok(str1,str2)	  DBstrtok(__FILE__, __LINE__, str1, str2)
X
X#endif
X
X#endif /* _DEBUG_MALLOC_INC */
X
X/*
X * $Log: malloc.h,v $
X * Revision 1.20  1992/01/28  21:42:25  cpcahil
X * changes for the ibmRS6000
X *
X * Revision 1.19  1992/01/28  18:05:37  cpcahil
X * misc fixes for patch 7
X *
X * Revision 1.18  1992/01/22  16:21:35  cpcahil
X * added code to prevent inclusions of string.h and memory.h after malloc.h
X * was included.
X *
X * Revision 1.17  1992/01/10  17:26:46  cpcahil
X * fixed prototypes use of void.
X *
X * Revision 1.16  1992/01/10  16:53:39  cpcahil
X * added more info on sizetype and datatype. added support for overriding
X * use of void type.
X *
X * Revision 1.15  1992/01/09  17:19:11  cpcahil
X * put the close brace in the correct position.
X *
X * Revision 1.14  1992/01/09  17:12:36  cpcahil
X * added code to support inclusion in C++ modules
X *
X * Revision 1.13  1991/12/31  21:31:26  cpcahil
X * changes for patch 6.  See CHANGES file for more info
X *
X * Revision 1.12  1991/12/26  22:31:29  cpcahil
X * added check to make sure file is not included twice.
X *
X * Revision 1.11  1991/12/06  17:58:46  cpcahil
X * added cfree() for compatibility with some wierd systems
X *
X * Revision 1.10  91/12/06  08:54:18  cpcahil
X * cleanup of __STDC__ usage and addition of CHANGES file
X * 
X * Revision 1.9  91/12/04  09:23:40  cpcahil
X * several performance enhancements including addition of free list
X * 
X * Revision 1.8  91/12/02  19:10:11  cpcahil
X * changes for patch release 5
X * 
X * Revision 1.7  91/11/25  14:42:00  cpcahil
X * Final changes in preparation for patch 4 release
X * 
X * Revision 1.6  91/11/24  00:49:28  cpcahil
X * first cut at patch 4
X * 
X * Revision 1.5  91/11/20  11:54:10  cpcahil
X * interim checkin
X * 
X * Revision 1.4  90/08/29  22:23:38  cpcahil
X * fixed mallopt to use a union as an argument.
X * 
X * Revision 1.3  90/05/11  11:04:10  cpcahil
X * took out some extraneous lines
X * 
X * Revision 1.2  90/05/11  00:13:09  cpcahil
X * added copyright statment
X * 
X * Revision 1.1  90/02/23  07:09:03  cpcahil
X * Initial revision
X * 
X */
END_OF_FILE
if test 13852 -ne `wc -c <'malloc.h'`; then
    echo shar: \"'malloc.h'\" unpacked with wrong size!
fi
# end of 'malloc.h'
fi
echo shar: End of archive 2 \(of 5\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
