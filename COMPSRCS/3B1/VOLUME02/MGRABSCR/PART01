Path: comp-sources-3b1
From: John R MacMillan <john@chance.gts.org>
Subject:  v02i032:  Capture MGR screen images & View MGR bitmaps, Part01/01
Newsgroups: comp.sources.3b1
Approved: dave@galaxia.network23.com
X-Checksum-Snefru: b4566e6a 27c69f5b 8d6a4d30 0003f6f2

Submitted-by: John R MacMillan <john@chance.gts.org>
Posting-number: Volume 2, Issue 32
Archive-name: mgrabscr/part01

These are sufficiently UNIXpc-specific that I did not feel they
belonged in comp.sources.misc.  Granted, they are of little or no use
to non-MGR 3b1-ers (except for the MIME plug), but some folks may find
them useful.

They perform similar functions to the MGR "snap" and "show" programs,
but I found them unsuitable for what I wanted.

#!/bin/sh
#  This is a shar file.  To extract, sh this file
#
#  Contents:
#	ReadMe
#	Makefile
#	mgrabscr.man
#	mview.man
#	mgrabscr.c
#	mview.c
#	abspath.c
#	mime.overview
#	mhn-mgr
#	mailcap
#
#  Wrapped by john@chance.UUCP ; Mon Jan 25 11:14:47 EST 1993
#
if [ -f "ReadMe" ] ; then
	echo "shar: Will not overwrite existing file ReadMe"
else
	echo "shar: extracting ReadMe (4881 characters)"
	sed 's/^X//' <<'BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM' > ReadMe
XMview and mgrabscr                                     93/01/25
X==================
X
XMview and mgrabscr are programs for viewing and creating (from the
Xdisplay, not editing) MGR bitmaps.  The programs are at present
Xspecific to the UNIXpc version of MGR, as I no longer have any others
Xto play with.  If you wish to port them to another MGR system, see
X"Porting Notes" below.
X
XThese programs evolved (mutated, really) out of my desire to have
Xdecent bitmap display and composition tools while I was involved with
Xthe RFC1341 (MIME) mailing list.  This has influenced the way they
Xwork, and mview especially changed a lot as I played with more MIME
Xmail messages.  Unfortunately, this means mview could probably use a
Xrewrite, but I'm simply too lazy, I mean, uh, busy.  Both could
Xprobably use a better user interface, but they are more in line with
Xwhat I wanted than any of the demo programs that came with MGR.
X
XThis code is in the Public Domain, though I would appreciate receiving
Xfixes and enhancements, and would prefer not to be represented as the
Xauthor of changes I did not make.  No guarantee of suitability for any
Xpurpose whatsoever, except possibly test cases for rm(1), is made
Xunless your needs, wants and desires are the same as mine, in which
Xcase, I feel these programs are tolerably suitable.
X
XBuild Procedure
X===============
X
XEdit the Makefile to customize the things marked CUSTOMIZE, and
Xanything else you feel comfortable changing.  Both mview and mgrabscr
Xneed libmgr.a and the term.h and dump.h include files that usually get
Xinstalled somewhere when you install MGR.  Mgrabscr also requires
Xblitlib.a and bitmap.h, which I do not think are usually installed
Xbut are in the MGR source directory "lib".
X
XWhen you're happy with the Makefile, just "make" to make the binaries,
Xor "make man" to format the manual pages.
X
XSo What is MIME?
X================
X
XMIME, or Multipurpose Internet Mail Extensions, is a "mechanism for
Xspecifying and describing the format of Internet message bodies"
Xdescribed in RFC 1341.  What it includes is a method for including
Ximages, audio, different character sets, etc. in a mail message.  The
Xlatest version of many popular UNIX mail user agents are MIME capable;
Xsome directly (like MH6.8), others by using Nathaniel Borenstein's
XMetamail package (Nathaniel is co-author of RFC 1341, from Bellcore,
Xhome of MGR, coincidentally).
X
XThis may sound like an ad for MIME, and it is a bit.  I think MIME
Xwill become more and more common in the near future, both in mail and
Xnews, and I would encourage people to look into making themselves and
Xtheir mailers "MIME capable".
X
XFor MH users, I've included my $MHN file for use with mgr, called
Xmhn-mgr.  The "richtext" program mentioned in it is from the Metamail
Xdistribution, available via anonymous FTP from thumper.bellcore.com.
XFor Metamail users, I've included a sample mailcap that uses mview for
Xdisplay (untested; I do not yet use Metamail, though I intend to when
XI can get around to building trn with the Metamail patches).  Note
Xthat the "X-*" image types are not sanctioned by the RFC (early drafts
Xhad the p?m types, but they were removed), but they may be useful for
Xexchanging images with "known" recipients.
X
XIf you're interested in MIME, you can get RFC 1341, or poke around in
Xcomp.mail.mime and see what's up.  Mark Grand (mdg@netcom.netcom.com)
Xhas prepared an overview and technical summary, available via
Xanonymous FTP from adad.premenos.sf.ca.us in the /pub directory,
Xcalled mime.ps (PostScript) or mime.txt (ASCII text).  I've included
Xthe overview portion of mime.txt as mime.overview.
X
XPorting Notes
X=============
X
XBoth programs are basically System V-ish; they use uname() to get the
Xnode name instead of gethostname(), include <string.h>, and that sort
Xof thing.
X
XIn mview, the bitmap file reading may not be correct for colour MGRs
X(ie. with a bit depth greater than 1).
X
XIn mgrabscr, the bitmap file writing flips the bits around because the
XUNIXpc screen stores them "backwards", and the screen device is
Xessentially ignored.
X
XMiscellaneous
X=============
X
XMview was never intended as something to manipulate (rotate, stretch,
Xetc.) bitmaps.  You can always use the PBM utilities to do this, but
Xsuch a tool would be neat if somebody else would write it...
X
XThe only image types that are blessed by the RFC are image/gif and
Ximage/jpeg.  Going from a GIF to an MGR bitmap with the PBM utilities
Xis pretty slow, and JPEG to MGR is likewise not fast.  I may try and
Xdo GIF to MGR and JPEG to MGR programs based on the PBM and JPEG
Xwork.  If anybody else does this, please let me know.
X
XI don't use the normal UNIXpc window system much, but I would like an
X"s4grabscr"-like program to go with pbmto3b1 for those rare
Xoccasions.  Anyone know of one?
X
XI'd like bug reports, enhancements, etc.  Mail them to me:
X
Xjohn@chance.gts.org
X
XEnjoy!
X
XJohn R. MacMillan
BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM
	set -- `wc -c ReadMe`
	if [ "$1" != "4881" ] ; then
		echo "shar: ReadMe unpacked with wrong size!"
	fi
	chmod u=r,g=r,o=r ReadMe
fi
if [ -f "Makefile" ] ; then
	echo "shar: Will not overwrite existing file Makefile"
else
	echo "shar: extracting Makefile (1207 characters)"
	sed 's/^X//' <<'BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM' > Makefile
X# @(#)Makefile	2.1	93/01/25
X
X# CUSTOMIZE the next two for your site to point to the area where
X# MGR include files are kept, and the MGR library, and anything
X# else you might want.
X
XINCLUDES= -I/usr/local/lib/mgr/include
XLIBS=/usr/local/lib/mgr/lib/libmgr.a
X
X# CUSTOMIZE these two.  They are in the lib directory in the MGR source
X# area, but you may have them elsewhere (I have them in the same area
X# as above, for instance).
X
XBITINCLUDES=
XBITLIBS=/usr/local/lib/mgr/lib/blitlib.a
X
X# CUSTOMIZE as appropriate.  Remember to include relevant flags to
X# pick up libraries in LIBS if you didn't include full paths.
X
XCC= cc
XOPTIM= -O
XLDFLAGS= -s
X#CC= gcc
X#OPTIM= -O
X#LDFLAGS= -s -shlib
X
XCFLAGS= $(OPTIM) $(INCLUDES)
X
XTARGETS= mview mgrabscr
X
Xall:	$(TARGETS)
X
Xmview: mview.o abspath.o
X	$(CC) $(LDFLAGS) -o $@ mview.o abspath.o $(LIBS)
X
Xmgrabscr: mgrabscr.o abspath.o
X	$(CC) $(LDFLAGS) -o $@ mgrabscr.o abspath.o $(BITLIBS) $(LIBS)
X
Xmgrabscr.o: mgrabscr.c
X	$(CC) $(CFLAGS) $(BITINCLUDES) -c mgrabscr.c
X
Xman: mview.1 mgrabscr.1
X
Xmview.1: mview.man
X	nroff -man mview.man > mview.1
X
Xmgrabscr.1: mgrabscr.man
X	nroff -man mgrabscr.man > mgrabscr.1
X
Xclean:
X	rm -f *.o *.out core
X
Xclobber: clean
X	rm -f $(TARGETS) *.1
BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM
	set -- `wc -c Makefile`
	if [ "$1" != "1207" ] ; then
		echo "shar: Makefile unpacked with wrong size!"
	fi
	chmod u=rw,g=r,o=r Makefile
fi
if [ -f "mgrabscr.man" ] ; then
	echo "shar: Will not overwrite existing file mgrabscr.man"
else
	echo "shar: extracting mgrabscr.man (3338 characters)"
	sed 's/^X//' <<'BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM' > mgrabscr.man
X.TH MVIEW 1 "93/01/25" "MGR"
X.SH NAME
Xmgrabscr \- grab portion of MGR display
X.SH SYNOPSIS
X.B mview
X[\fB\-r\fP|\fB\-w\fP|\fB\-s\fP]
X[\fB\-d\fP \fIdelay\fP|\fB\-D\fP \fIdelay\fP]
X[\fB\-v\fP]
X.I [file]
X.SH DESCRIPTION
X.I Mgrabscr
Xgrabs a portion of an MGR display and writes it out as a bitmap to
X.I file
Xor to standard out if no file is given.  The portion can either be the
Xentire screen, a particular window, or a rectangle swept out by the
Xuser.
X.LP
XThe portion grabbed is dictated by the arguments, as described below.
XIf no arguments are given which indicate what should be grabbed, the
Xoperation of \fImgrabscr\fP is controlled by a menu available on
Xeither mouse button.  The menu allows the user to select what should
Xbe grabbed, and to initiate the grab when the desired mode is
Xselected.  The current grab mode is indicated in the menu with an
Xasterisk (\fB*\fP).  When the \fBDo Grab\fP menu item is selected, the
Xgrab will proceed as if the selected mode had been given on the
Xcommand line, as described below.
X.LP
XOccasionally it may be desirable to rearrange the screen prior to the
Xgrab taking place but after the area has been selected (to hide the
Xwindow \fImgrabscr\fP is running in, for instance).  To allow this
Xdelay may be specified on the command line or selected from the menu.
XThe default delay, if not given on the command line but selected from
Xthe menu, is 10 seconds.
X.LP
X\fIMgrabscr\fP works only on the same host that MGR is running on.
X.IP "\fB\-r\fP"
XSweep out a rectangle.  Pressing either mouse button will fix one
Xcorner of a rectangle which may be swept out in the normal manner of
XMGR.  \fIMgrabscr\fP will then write the contents of this rectangle as
Xthe bitmap, in new bitmap format.  If possible, the mouse cursor will
Xbe moved out of the rectangle so as not to appear in the bitmap.  Not
Xsweeping an area (ie. clicking either mouse button) will abort the
Xgrab.
X.LP
X.IP "\fB\-w\fP"
XPressing either mouse button over a window (which may be partially
Xobscured) will cause the contents of that window to be written out in
Xthe bitmap format in use by MGR (see the \fB\-n\fP option of the
X\fImgr\fP(1) command).  Pressing either mouse button over a non-window
Xwill abort the grab.
X.LP
X.IP "\fB\-s\fP"
XClicking either mouse button will cause the entire screen contents to
Xbe written out in the new bitmap format.  The mouse cursor will appear
Xin the bitmap, so you may wish to move it somewhere unobtrusive before
Xclicking.
X.LP
X.IP "\fB\-d\fP \fIdelay\fP"
XSet the delay time to \fIdelay\fP seconds.  If none of
X\fB\-r\fP, \fB\-w\fP, or \fB\-s\fP is given, the menu option for
Xdelaying will be selected initially.  \fIMgrabscr\fP will flash the
Xscreen and beep immediately before the image is actually grabbed.
X.LP
X.IP "\fB\-D\fP \fIdelay\fP"
XLike \fB\-d\fP except that the menu option for delaying will not be
Xselected initially.  This allows the user to change the default delay
Xfor the menu mode without actually causing a delay.
X.LP
X.IP "\fB\-v\fP"
XSends some instructions and status information to standard error.
X.SH SEE ALSO
Xmgr(1), bitmap(5)
X.SH AUTHOR
XJohn R. MacMillan
X.sp
XE\-mail: john@chance.gts.org or ...!{scocan.sco.com,sq.com}!chance!john
X.SH BUGS
X.LP
XThere should be some way to do remote grabs.
X.LP
XWindow grabs will be written out in a bitmap format dependent upon how
XMGR was invoked.
BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM
	set -- `wc -c mgrabscr.man`
	if [ "$1" != "3338" ] ; then
		echo "shar: mgrabscr.man unpacked with wrong size!"
	fi
	chmod u=r,g=r,o=r mgrabscr.man
fi
if [ -f "mview.man" ] ; then
	echo "shar: Will not overwrite existing file mview.man"
else
	echo "shar: extracting mview.man (4732 characters)"
	sed 's/^X//' <<'BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM' > mview.man
X.TH MVIEW 1 "93/01/25" "MGR"
X.SH NAME
Xmview \- MGR bitmap viewer
X.SH SYNOPSIS
X.B mview
X[\fB\-x\fP \fIxpos\fP]
X[\fB\-y\fP \fIypos\fP]
X[\fB\-w\fP \fIwidth\fP]
X[\fB\-h\fP \fIheight\fP]
X[\fB\-s\fP \fIseconds\fP]
X[\fB\-f\fP]
X[\fB\-r\fP]
X[\fB\-v\fP]
X[\fB\-c\fP]
X.I [file ...]
X.SH DESCRIPTION
X.I Mview
Xdisplays MGR bitmap files on an MGR display.  Bitmaps are displayed in
Xsuccession in an alternate window; if no \fIfile\fPs are given, the
Xbitmap is read from standard input.  Entering
X\fBN<RETURN>\fP or \fB<RETURN>\fP will advance to the next bitmap,
X\fBP<RETURN>\fP will move to the previous bitmap, and pressing the
Xinterrupt character or entering \fBQ<RETURN>\fP will terminate the
Xprogram.  These actions are also available from a menu on both user
Xmouse buttons.
X.LP
XBy default, \fImview\fP places the alternate window randomly to
Xallow as much of the bitmap as possible to be displayed.  If a
Xsubsequent bitmap is larger, the window will normally be moved to
Xaccommodate the larger image.  This behaviour can be changed with
Xthe options below.
X.LP
XIf the image does not fit in the window, \fImview\fP can scroll the
Xwindow over image.  The direction names for scrolling are for moving
Xthe window over the image; the window starts displaying the top left
Xcorner of the image.  Pressing \fBF<RETURN>\fP or \fBD<RETURN>\fP will
Xmove the window down the image by a full or half window, respectively.
XPressing \fBB<RETURN>\fP or \fBU<RETURN>\fP return will move the
Xwindow up a full or half window.  \fBR<RETURN>\fP or \fB><RETURN>\fP
Xwill move the window right by a half window, \fBL<RETURN>\fP or
X\fB<<RETURN>\fP will move the window right a half window.  The menu
Xcan also be used to perform these functions.
X.LP
XIf the \fImview\fP window is reshaped or moved, \fImview\fP will use
Xthe new shape and position.  Note that the image is not scaled; it is
Xsimply cropped.  This is the only way to reposition a window if it has
Xbeen forced to a particular position with \fB\-f\fP (see below).
X.LP
X.IP "\fB\-x\fP \fIxpos\fP"
XSet the \fIx\fP position of the alternate window in display
Xco-ordinates.  The window may be moved to accommodate larger images
Xunless \fB\-f\fP is set (see below).
X.LP
X.IP "\fB\-y\fP \fIypos\fP"
XSet the \fIy\fP position of the alternate window in display
Xco-ordinates.  The window may be moved to accommodate larger images
Xunless \fB\-f\fP is set (see below).
X.LP
X.IP "\fB\-w\fP \fIwidth\fP"
XSet the maximum width of the alternate window to \fIwidth\fP
Xpixels.  Images larger than this will be cropped.
X.LP
X.IP "\fB\-h\fP \fIheight\fP"
XSet the maximum height of the alternate window to \fIheight\fP
Xpixels.  Images larger than this will be cropped.
X.LP
X.IP "\fB\-s\fP \fIseconds\fP"
XUse slideshow mode.  After \fIseconds\fP seconds, move automatically
Xto the next image.  This option is ignored if the bitmap is being read
Xfrom standard input.
X.LP
X.IP "\fB\-f\fP"
XForce the position of the alternate window, even if this means the
Ximage will be cropped.  If \fB\-x\fP or \fB\-y\fP are not specified
Xthe random position chosen for the first bitmap will be used.
X.LP
X.IP "\fB\-r\fP"
XReverse the sense of black/white pixels when displaying each bitmap.
XAn item on the menu may be used to toggle this once mview is running.
X.LP
X.IP "\fB\-v\fP"
XBe verbose.  Information about the size and position of the bitmap
X(and size of the image if it was cropped) is displayed in the main
Xwindow.
X.LP
X.IP "\fB\-c\fP"
XCycle through images.  The ``next'' image after the last one on the
Xcommand line is the first one, and the ``previous'' from the first is
Xthe last.  This option is ignored if the bitmap is being read from
Xstandard input.
X.LP
XIf \fImview\fP is run on a different host than MGR, there must be an
X8 bit clean path between the two.
X.SH SEE ALSO
Xmgr(1), bitmap(5)
X.SH AUTHOR
XJohn R. MacMillan
X.sp
XE\-mail: john@chance.gts.org or ...!{scocan.sco.com,sq.com}!chance!john
X.SH BUGS
X.LP
XSince \fImview\fP uses an alternate window to display the bitmap, you
Xcan't run it in the background, or run several simultaneously from the
Xsame window, without it fighting for the keyboard.
X.LP
XThere is no way to use standard input as one of several bitmaps to be
Xdisplayed.  If this is required, save standard input in a temporary
Xfile before invoking \fImview\fP.
X.LP
XIf \fImview\fP and MGR are on the same host, the filenames are
Xinterpreted by MGR (though \fImview\fP will provide MGR with absolute
Xpathnames) so files such as \fB/dev/stdin\fP will not work as expected.
X.LP
XIn slideshow mode, if the user is selecting from a menu when the
Xslideshow timer expires, the menu item may not take effect.
X.LP
XIt would be nice to enhance the keyboard commands to allow single
Xkeypress commands, with vi-like and emacs-like bindings.
BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM
	set -- `wc -c mview.man`
	if [ "$1" != "4732" ] ; then
		echo "shar: mview.man unpacked with wrong size!"
	fi
	chmod u=r,g=r,o=r mview.man
fi
if [ -f "mgrabscr.c" ] ; then
	echo "shar: Will not overwrite existing file mgrabscr.c"
else
	echo "shar: extracting mgrabscr.c (8716 characters)"
	sed 's/^X//' <<'BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM' > mgrabscr.c
X/*
X * Grab an MGR bitmap from the screen
X *
X * @(#)mgrabscr.c	2.1	93/01/25
X */
X
X#include <stdio.h>
X#include <signal.h>
X#include <string.h>
X#include <sys/utsname.h>
X#include "term.h"
X#include "dump.h"
X#include "bitmap.h"
X
X#ifndef lint
Xstatic char *SCCS = "@(#)mgrabscr.c	2.1 93/01/25";
X#endif
X
X#ifndef SCREEN
X#define SCREEN "/dev/null"	/* UNIXpc MGR doesn't use screen dev */
X#endif
X
X#define OPTIONS	"wrsd:D:v"
X#define USAGE	"[-r|-w|-s] [-d delay|-D delay] [-v] [file]"
X
Xint rect = 0;				/* Sweep a rectangle */
Xint window = 0;				/* Grab window contents */
Xint screen = 0;				/* Grab whole screen */
Xint verbose = 0;			/* Be verbose */
Xint delay = 0;				/* Seconds to delay */
X
Xint quit = 0;
Xint dodelay = 0;
X
Xchar menufmt[] = "|%c Rectangle|%c Window|%c Screen|-----------|%c Delay|%c No Delay|-----------|  Do Grab|  Quit|R\n|W\n|S\n||D\n|N\n||G\n|Q\n|";
X
Xchar *prog;
X
X#define abs(a)		(((a) < 0) ? -(a) : (a))
X#define min(a,b)	(((a) < (b)) ? (a) : (b))
X#define DEF_DELAY	10
X#define MARK(n)		((n) ? '*' : ' ')
X
Xextern int ckmgrterm(), m_setup(), m_ttyset(), m_ttyreset();
X
Xmain(argc, argv)
Xint argc;
Xchar  **argv;
X{
X	int ret;
X	char *file;
X	int w, h;
X	int c;
X	char buf[80];
X	char node[9];
X	struct utsname uts;
X	extern int optind, opterr;
X	extern char *optarg;
X	extern int getopt(), atoi();
X	extern int uname(), unlink();
X	extern void exit();
X	extern char *abspath();
X	static int catch(), grabrect(), grabwindow(), grabarea(), cat();
X	static void usage(), getmode();
X
X	prog = strrchr(argv[0], '/');
X	if (prog)
X		prog++;
X	else
X		prog = argv[0];
X
X	opterr = 0;
X	while ((c = getopt(argc, argv, OPTIONS)) != EOF) {
X		switch (c) {
X		case 'r':
X			rect = 1;
X			break;
X		case 'w':
X			window = 1;
X			break;
X		case 's':
X			screen = 1;
X			break;
X		case 'd':
X			dodelay = 1;
X			/* FALLTHROUGH */
X		case 'D':
X			delay = atoi(optarg);
X			break;
X		case 'v':
X			verbose = 1;
X			break;
X		default:
X			usage();
X			break;
X		}
X	}
X
X	if (rect + window + screen > 1 || argc - optind > 1)
X		usage();
X
X	(void) signal(SIGHUP, catch);
X	(void) signal(SIGINT, catch);
X	(void) signal(SIGQUIT, catch);
X	(void) signal(SIGTERM, catch);
X
X	/* MGR setup */
X
X	ckmgrterm();
X
X	(void) m_setup(M_FLUSH);
X	(void) m_ttyset();
X	m_flags |= M_MODEOK;
X	m_push(P_MENU|P_EVENT|P_FLAGS);
X	m_setmode(M_ABS);
X
X	m_getinfo(G_SYSTEM);
X	m_gets(buf);
X	(void) sscanf(buf, "%s %d %d", node, &w, &h);
X	if (uname(&uts) != -1 && strcmp(node, uts.nodename) != 0) {
X		m_popall();
X		(void) m_ttyreset();
X		fprintf(stderr, "%s: can only grab on host %s\n", prog,
X			node);
X		exit(1);
X	}
X
X	if (optind == argc) {
X		/* Use stdout */
X		file = tempnam(NULL, "mgs");
X		if (file == NULL) {
X			m_popall();
X			(void) m_ttyreset();
X			fprintf(stderr, "%s: unable to get temporary file name\n",
X				prog);
X			exit(1);
X		}
X	} else {
X		file = abspath(argv[optind]);
X		if (file == NULL) {
X			m_popall();
X			(void) m_ttyreset();
X			fprintf(stderr, "%s: unable to convert %s to absolute path\n",
X				prog, argv[optind]);
X			exit(1);
X		}
X	}
X
X	/* Set mode if not specified */
X
X	if (rect + window + screen == 0) {
X		if (verbose) {
X			(void) m_ttyreset();
X			fprintf(stderr, "Select grab mode with menu, and then \"Do Grab\" to grab\n");
X			(void) m_ttyset();
X		}
X		getmode();
X		if (dodelay && delay == 0)
X			delay = DEF_DELAY;
X	} else {
X		/* Let -D or -d work if one of -r, -w, -s given */
X		if (delay != 0)
X			dodelay++;
X	}
X
X	if (rect) {
X		if (verbose) {
X			(void) m_ttyreset();
X			fprintf(stderr, "Sweep out rectangle to grab with the mouse\n");
X			(void) m_ttyset();
X		}
X		ret = grabrect(file, w, h);
X	} else if (window) {
X		if (verbose) {
X			(void) m_ttyreset();
X			fprintf(stderr, "Click on the window to grab\n");
X			(void) m_ttyset();
X		}
X		ret = grabwindow(file);
X	} else if (screen) {
X		if (verbose) {
X			(void) m_ttyreset();
X			fprintf(stderr, "Click to grab screen\n");
X			(void) m_ttyset();
X		}
X		m_setevent(BUTTON_1, "\n");
X		m_setevent(BUTTON_2, "\n");
X		m_gets(buf);
X		ret = grabarea(file, 0, 0, w, h);
X	} else {
X		ret = 1;
X	}
X
X	if (verbose) {
X		(void) m_ttyreset();
X		fprintf(stderr, "Grab %s\n", (ret || quit) ? "aborted" : "complete");
X		(void) m_ttyset();
X	}
X
X	m_popall();
X	(void) m_ttyreset();
X
X	if (optind == argc) {
X		if (ret == 0 && quit == 0)
X			ret = cat(file);
X		unlink(file);
X	}
X
X	exit(ret || quit);
X}
X
Xstatic int
Xcatch(n)
Xint n;
X{
X	(void) signal(n, catch);
X	quit++;
X	return 0;
X}
X
Xstatic void
Xusage()
X{
X	extern void exit();
X
X	(void) fprintf(stderr, "Usage: %s %s\n", prog, USAGE);
X	exit(1);
X}
X
Xstatic void
Xgetmode()
X{
X	char menubuf[sizeof(menufmt)];
X	char buf[80];
X
X	m_push(P_MENU);
X	do {
X		sprintf(menubuf, menufmt, MARK(rect), MARK(window),
X			MARK(screen), MARK(dodelay), MARK(!dodelay));
X		m_loadmenu(1, menubuf);
X		m_selectmenu(1);
X		m_selectmenu2(1);
X		buf[0] = '\0';
X		m_gets(buf);
X		switch(buf[0]) {
X		case 'R':
X			rect = 1;
X			screen = window = 0;
X			break;
X		case 'W':
X			window = 1;
X			rect = screen = 0;
X			break;
X		case 'S':
X			screen = 1;
X			rect = window = 0;
X			break;
X		case 'D':
X			dodelay = 1;
X			break;
X		case 'N':
X			dodelay = 0;
X			break;
X		case 'Q':
X			rect = screen = window = 0;
X			quit = 1;
X			break;
X		case 'G':
X			if (rect + screen + window == 0) {
X				buf[0] = '\0';
X				if (verbose) {
X					(void) m_ttyreset();
X					fprintf(stderr, "No grab mode; select one from the menu before grabbing\n");
X					(void) m_ttyset();
X				}
X			}
X			break;
X		default:
X			break;
X		}
X	} while (!quit && buf[0] != 'G');
X	m_pop();
X}
X
Xstatic int
Xgrabrect(file, xmax, ymax)
Xchar *file;
Xint xmax;
Xint ymax;
X{
X	char buf[80];
X	int sx, sy, ex, ey;
X	int w, h;
X	static int grabarea();
X
X	m_setevent(BUTTON_1, "%R\n");
X	m_setevent(BUTTON_2, "%R\n");
X	m_gets(buf);
X	if (sscanf(buf, "%d %d %d %d", &sx, &sy, &ex, &ey) != 4)
X		return 1;
X
X	w = abs(sx - ex);
X	h = abs(sy - ey);
X
X	if (w == 16 && h == 16)
X		return 1;
X
X	sx = min(sx, ex);
X	sy = min(sy, ey);
X
X	m_push(P_MOUSE);
X	if (sx > 16 || sy > 16)
X		m_movemouse(0, 0);
X	else 
X		m_movemouse(xmax-17, ymax-17);
X
X	return grabarea(file, sx, sy, w, h);
X}
X
Xstatic int
Xgrabwindow(file)
Xchar *file;
X{
X	char buf[80];
X	int x, y, id, sub;
X
X	m_setevent(BUTTON_1, "\n");
X	m_setevent(BUTTON_2, "\n");
X	m_gets(buf);
X	if (!quit) {
X		m_getinfo(G_MOUSE);
X		m_gets(buf);
X		if (sscanf(buf, "%d %d", &x, &y) != 2) {
X			return 1;
X		}
X		m_whatsat(x, y);
X		m_gets(buf);
X		if (sscanf(buf, "%*s %*s %d %d", &sub, &id) != 2) {
X			return 1;
X		}
X		m_othersave(id, sub, file);
X
X		/* Delay until MGR has written file */
X
X		m_sendme("delay\n");
X		m_gets(buf);
X	}
X	return 0;
X}
X
Xstatic int
Xgrabarea(file, x, y, wide, high)
Xchar *file;
Xint x;
Xint y;
Xint wide;
Xint high;
X{
X	BITMAP *screen, *scratch;
X	FILE *fp;
X	struct b_header hdr;
X	int filerow, memrow, n;
X	char *bp;
X	unsigned short s, *sp;
X	extern int sleep();
X	extern void free();
X
X	/* Get everything ready */
X
X	if ((screen = bit_open(SCREEN)) == NULL) {
X		(void) m_ttyreset();
X		fprintf(stderr, "%s: unable to open screen\n", prog);
X		return 1;
X	}
X
X	if ((scratch = bit_alloc(wide, high, BIT_NULL, DEPTH)) == NULL) {
X		(void) m_ttyreset();
X		fprintf(stderr, "%s: unable to allocate memory for bitmap\n",
X			prog);
X		return 1;
X	}
X	wide = BIT_WIDE(scratch);
X	high = BIT_HIGH(scratch);
X
X	if ((fp = fopen(file, "w")) == NULL) {
X		(void) m_ttyreset();
X		fprintf(stderr, "%s: unable to open bitmap file %s\n",
X			prog, file);
X		return 1;
X	}
X
X	/* Delay if requested */
X
X	if (dodelay) {
X		if (verbose) {
X			(void) m_ttyreset();
X			fprintf(stderr, "Waiting %d seconds...", delay);
X			fflush(stderr);
X			(void) m_ttyset();
X		}
X		while (delay = sleep(delay))
X			;
X		m_bell();
X	}
X
X	/* Get the bitmap */
X
X	bit_blit(scratch, 0, 0, wide, high, BIT_SRC, screen, x, y);
X
X	/* Write it out */
X
X	B_PUTHDR8(&hdr, wide, high, DEPTH);
X	filerow = B_SIZE8(wide, 1, DEPTH);
X	memrow = BIT_Size(wide, 1, DEPTH);
X	bp = (char *)BIT_DATA(scratch);
X
X	if (fwrite(&hdr, B_HSIZE, 1, fp) != 1) {
X		(void) m_ttyreset();
X		fprintf(stderr, "%s: unable to write bitmap header to %s\n",
X			prog, file);
X		return 1;
X	}
X
X	while (high--) {
X		/* On the UNIXpc we have to flip stuff around */
X		for (n = memrow / 2, sp = (unsigned short *)bp; n--; sp++) {
X			s = ((*sp >> 8) & 0x00ff) | ((*sp << 8) & 0xff00);
X			s = ((s >> 4) & 0x0f0f) | ((s << 4) & 0xf0f0);
X			s = ((s >> 2) & 0x3333) | ((s << 2) & 0xcccc);
X			*sp = ((s >> 1) & 0x5555) | ((s << 1) & 0xaaaa);
X		}
X		if (fwrite(bp, 1, filerow, fp) != filerow) {
X			(void) m_ttyreset();
X			fprintf(stderr, "%s: error writing bitmap file %s\n",
X				prog, file);
X			return 1;
X		}
X		bp += memrow;
X	}
X
X	fclose(fp);
X	free(scratch);
X
X	return 0;
X}
X
Xstatic int
Xcat(file)
Xchar *file;
X{
X	FILE *fp;
X	char buf[BUFSIZ];
X	int n;
X
X	if ((fp = fopen(file, "r")) != NULL) {
X		do {
X			n = fread(buf, 1, BUFSIZ, fp);
X			fwrite(buf, 1, n, stdout);
X		} while (!feof(fp) && !ferror(fp));
X		fclose(fp);
X	}
X
X	return !fp || ferror(fp);
X}
BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM
	set -- `wc -c mgrabscr.c`
	if [ "$1" != "8716" ] ; then
		echo "shar: mgrabscr.c unpacked with wrong size!"
	fi
	chmod u=r,g=r,o=r mgrabscr.c
fi
if [ -f "mview.c" ] ; then
	echo "shar: Will not overwrite existing file mview.c"
else
	echo "shar: extracting mview.c (12808 characters)"
	sed 's/^X//' <<'BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM' > mview.c
X/*
X * Bitmap viewer for MGR
X *
X * @(#)mview.c	2.1	93/01/25
X */
X
X#include <stdio.h>
X#include <signal.h>
X#include <string.h>
X#include <sys/utsname.h>
X#include "term.h"
X#include "dump.h"
X
X#ifndef lint
Xstatic char *SCCS = "@(#)mview.c	2.1 93/01/25";
X#endif
X
X#define SCRATCH	1
X#define	MAINWIN	0
X
X#define OPTIONS	"x:y:h:w:frvs:-c"
X#define USAGE	"[-x n] [-y n] [-h n] [-w n] [-s secs] [-frvc] [file] ..."
X
Xchar *prog;
X
Xint xpos = -1, ypos = -1;		/* User set (x,y) position */
Xint maxh = -1, maxw = -1;		/* Max height and width */
Xint slideshow = -1;			/* Seconds to sleep in slideshow */
Xint force = 0;			/* Force holding (x,y) pos */
Xint reverse = 0;			/* Reverse bitmaps */
Xint verbose = 0;			/* Be verbose about bitmaps */
Xint cycle = 0;			/* Cycle around file list */
X
Xint quit = 0;			/* Exit indicator */
Xint win;				/* Alternate window id */
Xint direction;			/* Direction indicator */
Xint remote = 0;			/* MGR is on remote host */
X
X#define MENU_STAT	0
X#define MENU_FWD	1
X#define MENU_BACK	2
X
Xstruct menu_item {
X	int show;			/* Show menu item */
X	int dir;			/* "Direction" of item */
X	char *item;			/* Menu item */
X	char *action;		/* Menu item action */
X} menu[] = {
X	{ 0,	MENU_FWD,	"down half",	"D\r" },
X	{ 0,	MENU_FWD,	"     full",	"F\r" },
X	{ 0,	MENU_FWD,	"right",	"R\r" },
X	{ 0,	MENU_FWD,	"next",		"N\r" },
X	{ 0,	MENU_BACK,	"up half",	"U\r" },
X	{ 0,	MENU_BACK,	"   full",	"B\r" },
X	{ 0,	MENU_BACK,	"left",		"L\r" },
X	{ 0,	MENU_BACK,	"prev",		"P\r" },
X	{ 1,	MENU_STAT,	"reverse",	"I\r" },
X	{ 1,	MENU_STAT,	"quit",		"Q\r" },
X};
X
X#define MENU_HALFD	0
X#define MENU_FULLD	1
X#define MENU_RIGHT	2
X#define MENU_NEXT	3
X#define MENU_HALFU	4
X#define MENU_FULLU	5
X#define MENU_LEFT	6
X#define MENU_PREV	7
X#define MENU_REVERSE	8
X#define MENU_QUIT	9
X
Xextern int ckmgrterm(), m_setup(), m_ttyset(), m_ttyreset();
X
Xmain(argc, argv)
Xint argc;
Xchar  **argv;
X{
X	int n, c;
X	char *file, *p;
X	int x, y, w, h, bw;
X	int ret;
X	char buf[80];
X	char node[9];
X	struct utsname uts;
X	extern char *optarg;
X	extern int optind, opterr;
X	extern int getopt(), atoi(), uname();
X	extern long strtol(), time();
X	extern void srand48(), exit();
X	extern char *abspath();
X	static int catch(), timer(), display();
X	static void usage();
X
X	prog = strrchr(argv[0], '/');
X	if (prog)
X		prog++;
X	else
X		prog = argv[0];
X
X	opterr = 0;
X	while ((c = getopt(argc, argv, OPTIONS)) != EOF) {
X		switch (c) {
X		case 'x':
X			xpos = (int) strtol(optarg, &p, 10);
X			if (p == optarg || *p || xpos < 0)
X				usage();
X			break;
X		case 'y':
X			ypos = (int) strtol(optarg, &p, 10);
X			if (p == optarg || *p || ypos < 0)
X				usage();
X			break;
X		case 'h':
X			maxh = (int) strtol(optarg, &p, 10);
X			if (p == optarg || *p || maxh < 0)
X				usage();
X			break;
X		case 'w':
X			maxw = (int) strtol(optarg, &p, 10);
X			if (p == optarg || *p || maxw < 0)
X				usage();
X			break;
X		case 's':
X			slideshow = (int) strtol(optarg, &p, 10);
X			if (p == optarg || *p  || slideshow < 0)
X				usage();
X			break;
X		case 'f':
X			force++;
X			break;
X		case 'r':
X			reverse++;
X			break;
X		case 'v':
X			verbose++;
X			break;
X		case 'c':
X			cycle++;
X			break;
X		default:
X			usage();
X			break;
X		}
X	}
X
X	(void) signal(SIGHUP, catch);
X	(void) signal(SIGINT, catch);
X	(void) signal(SIGQUIT, catch);
X	(void) signal(SIGTERM, catch);
X	(void) signal(SIGALRM, timer);
X
X	srand48(time((long *)0));
X
X	/* MGR setup */
X
X	ckmgrterm();
X
X	(void) m_setup(M_FLUSH);
X	(void) m_ttyset();
X	m_flags |= M_MODEOK;
X	m_push(P_MENU|P_EVENT|P_FLAGS);
X	m_setmode(M_ABS);
X
X	/*
X	 * Set up the alternate window, overlapping current window.
X	 */
X
X	m_getinfo(G_COORDS);
X	m_gets(buf);
X	(void) sscanf(buf, "%d %d %d %d", &x, &y, &w, &h);
X	m_getinfo(G_SYSTEM);
X	m_gets(buf);
X	(void) sscanf(buf, "%s %*d %*d %d", node, &bw);
X	if (uname(&uts) != -1 && strcmp(node, uts.nodename) != 0)
X		remote++;
X	h += 2 * bw;
X	w += 2 * bw;
X	m_newwin(x, y, w, h);
X	m_gets(buf);
X	if (buf[0] == '\n') {
X		/* Couldn't create window; complain */
X		(void) m_ttyreset();
X		(void) fprintf(stderr, "unable to create new window\n");
X		m_popall();
X		exit(1);
X	}
X	win = atoi(buf);
X	m_selectwin(win);
X	m_setmode(M_ABS);
X	m_setcursor(CS_INVIS);
X	m_setevent(RESHAPE, "S\r");
X	m_setevent(MOVE, "M\r");
X	m_setevent(REDRAW, "W\r");
X	m_setevent(DESTROY, "Q\r");
X
X	/* Display each bitmap */
X
X	n = optind;
X	if (n == argc) {
X		/* Use stdin */
X		cycle = 0;
X		slideshow = 0;
X		display("<stdin>", NULL);
X	} else {
X		while (n < argc && !quit) {
X
X			if (argc - optind <= 1) {
X				menu[MENU_NEXT].show = 0;
X				menu[MENU_PREV].show = 0;
X			} else if (!cycle) {
X				menu[MENU_PREV].show = (n != optind);
X				menu[MENU_NEXT].show = (n < argc - 1);
X			} else {
X				menu[MENU_NEXT].show = 1;
X				menu[MENU_PREV].show = 1;
X			}
X
X			/* Make file name absolute if it's not */
X
X			if (!remote)
X				file = abspath(argv[n]);
X			else
X				file = argv[n];
X			if (file) {
X				ret = display(argv[n], file);
X			} else {
X				(void) m_ttyreset();
X				m_selectwin(MAINWIN);
X				(void) fprintf(stderr, "unable to get cwd for \"%s\"\n",
X					argv[n]);
X				m_selectwin(win);
X				(void) m_ttyset();
X				ret = 1;
X			}
X			if (ret) {
X				n += ret;
X				if (n < optind)
X					n = cycle ? argc - 1 : optind;
X				else if (cycle && n >= argc)
X					n = optind;
X			} else {
X				quit = 1;
X			}
X		}
X	}
X
X	m_clearevent(DESTROY);
X	m_selectwin(MAINWIN);
X	m_destroywin(win);
X	m_popall();
X	(void) m_ttyreset();
X
X	exit(0);
X}
X
Xstatic int
Xcatch(n)
Xint n;
X{
X	(void) signal(n, catch);
X	quit++;
X	return 0;
X}
X
Xstatic int
Xtimer(n)
Xint n;
X{
X	(void) signal(n, timer);
X	return 0;
X}
X
Xstatic void
Xusage()
X{
X	extern void exit();
X
X	(void) fprintf(stderr, "Usage: %s %s\n", prog, USAGE);
X	exit(1);
X}
X
X/*
X * Display a bitmap, waiting for input.  If input requests local motion,
X * redisplay.
X */
X
Xstatic int
Xdisplay(arg, file)
Xchar  *arg;
Xchar  *file;
X{
X	char buf[80];
X	int ch;
X	int bm_x, bm_y, bm_w, bm_h, w, h;
X	int redisplay;
X	int ret = 0;
X	static int adjust();
X	static void loadmap(), makemenu(), placewindow();
X	extern int alarm(), toupper();
X
X	if (remote || !file) {
X		loadmap(SCRATCH, file, buf);
X	} else {
X		m_bitfromfile(SCRATCH, file);
X		m_gets(buf);
X	}
X	if (sscanf(buf, "%d %d", &w, &h) != 2) {
X		/* Couldn't read bitmap */
X		(void) m_ttyreset();
X		m_selectwin(MAINWIN);
X		(void) fprintf(stderr, "unable to load bitmap %s\n", file ? file : "<stdin>");
X		m_selectwin(win);
X		(void) m_ttyset();
X		ret = 1;
X	} else {
X		/* Set up to display bitmap*/
X
X		m_clear();
X		bm_w = w;
X		bm_h = h;
X		bm_x = bm_y = 0;
X		redisplay = 1;
X		placewindow(arg, &w, &h);
X		m_func(reverse ? B_COPYINVERTED : B_COPY);
X
X		/* Display bitmap, and handle local motion */
X
X		while (redisplay && !quit) {
X			m_bitcopyto(0, 0, w, h, bm_x, bm_y, MAINWIN, SCRATCH);
X
X			/* Set up menu */
X
X			menu[MENU_LEFT].show = bm_x;
X			menu[MENU_HALFU].show = menu[MENU_FULLU].show = bm_y;
X			menu[MENU_RIGHT].show = (bm_x + w < bm_w);
X			menu[MENU_HALFD].show =
X				menu[MENU_FULLD].show = (bm_y + h < bm_h); 
X			makemenu();
X
X			/* Get input */
X
X			buf[0] = '\0';
X			if (slideshow)
X				(void) alarm(slideshow);
X			m_gets(buf);
X			if (slideshow)
X				(void) alarm(0);
X
X			/* Act on local motion, or next/prev */
X
X			ch = toupper((int)buf[0]);
X			switch(ch) {
X			case 'W':
X				/* REDRAW event */
X				break;
X			case 'S':
X			case 'M':
X				/* RESHAPE or MOVE (minor cheat) event */
X				m_getinfo(G_COORDS);
X				m_gets(buf);
X				(void) sscanf(buf, "%d %d %d %d", &xpos,
X					      &ypos, &w, &h);
X				if (w > bm_w || h > bm_h) {
X					if (w > bm_w)
X						w = bm_w;
X					if (h > bm_h)
X						h = bm_h;
X					m_shapewindow(xpos, ypos, w, h);
X				}
X				break;
X			case 'F':
X			case '\006':	/* ^F */
X			case '\026':	/* ^V */
X				/* Down full */
X				direction = MENU_FWD;
X				bm_y = adjust(bm_y, h, h, bm_h);
X				break;
X			case 'D':
X			case '\004':	/* ^D */
X				/* Down half */
X				direction = MENU_FWD;
X				bm_y = adjust(bm_y, h / 2, h, bm_h);
X				break;
X			case 'B':
X			case '\002':	/* ^B */
X				/* Up full */
X				direction = MENU_BACK;
X				bm_y = adjust(bm_y, -h , h, 0);
X				break;
X			case 'U':
X			case '\025':	/* ^U */
X				direction = MENU_BACK;
X				bm_y = adjust(bm_y, -h / 2, h, 0);
X				break;
X			case 'R':
X			case '>':
X				direction = MENU_FWD;
X				bm_x = adjust(bm_x, w / 2, w, bm_w);
X				break;
X			case 'L':
X			case '<':
X				direction = MENU_BACK;
X				bm_x = adjust(bm_x, -w / 2, w, 0);
X				break;
X			case 'I':
X				reverse = !reverse;
X				m_func(reverse ? B_COPYINVERTED : B_COPY);
X				break;
X			case 'P':
X				direction = MENU_BACK;
X				redisplay = 0;
X				ret = -1;
X				break;
X			case 'Q':
X				redisplay = 0;
X				ret = 0;
X				break;
X			default:
X				direction = MENU_FWD;
X				redisplay = 0;
X				ret = 1;
X				break;
X			}
X		}
X	}
X	m_bitdestroy(SCRATCH);
X
X	return ret;
X}
X
X/*
X * Load a bitmap from a file, complete with all the ugliness inherent in
X * the multiple formats.
X */
X
Xstatic void
Xloadmap(to, file, buf)
Xint  to;
Xchar   *file;
Xchar   *buf;
X{
X	int wide, high, depth, size, bw, pad, n, ch;
X	FILE *fp;
X	union {
X		struct b_header hdr;
X		struct old_b_header oldhdr;
X	} h;
X
X	*buf = '\0';
X	if (file)
X		fp = fopen(file, "r");
X	else
X		fp = stdin;
X
X	if (!fp)
X		return;
X
X	/* Get the header */
X
X	if (fread(h.hdr.magic, sizeof(h.hdr.magic), 1, fp) != 1)
X		return;
X	if (B_ISHDR8(&h.hdr)) {
X		if (fread(&h.hdr.h_wide, B_HSIZE - sizeof(h.hdr.magic), 1, fp) != 1)
X			return;
X		B_GETHDR8(&h.hdr, wide, high, depth);
X		size = B_SIZE8(wide, high, depth);
X		bw = wide / 8 + ((wide % 8) ? 1 : 0);
X		pad = (bw % 2) ? 1 : 0;
X	} else if (B_ISHDR(&h.oldhdr)) {
X		if (fread(&h.hdr.h_wide, B_OHSIZE - sizeof(h.oldhdr.magic), 1, fp) != 1)
X			return;
X		B_GETOLDHDR(&h.oldhdr, wide, high);
X		size = B_SIZE16(wide, high, 1);
X		bw = wide / 8 + ((wide % 8) ? 1 : 0);
X		bw += (bw % 2) ? 1 : 0;
X		pad = 0;
X	} else {
X		return;
X	}
X
X	/*
X	 * Loop through and read; we'll do it byte at a time to simplify
X	 * our work converting old style bitmaps to new.
X	 */
X
X	sprintf(buf, "%d %d", wide, high);
X	m_bitldto(wide, high, 0, 0, to, size + (high * pad));
X	while (high--) {
X		for (n = 0; n < bw; n++) {
X			ch = getc(fp);
X			putc(ch, m_termout);
X		}
X		if (pad)
X			putc('\0', m_termout);
X		m_flush();
X	}
X}
X
X/*
X * Place the window on the screen, possibly adjusting for the size of the
X * bitmap.
X */
X
Xstatic void
Xplacewindow(arg, wp, hp)
Xchar *arg;
Xint *wp, *hp;
X{
X	int x, y, maxx, maxy, w, h;
X	char buf[80];
X	static int dispw, disph, border;
X	extern double drand48();
X
X	/* Get display information */
X
X	if (!dispw) {
X		m_getinfo(G_SYSTEM);
X		m_gets(buf);
X		(void) sscanf(buf, "%*s %d %d %d", &dispw, &disph, &border);
X		border *= 2;
X	}
X
X	/*
X	 * Place the window.  First find the maximum (x,y) pos that will
X	 * fit the bitmap.
X	 */
X
X	w = (maxw >= 0 && *wp > maxw) ? maxw : *wp;
X	maxx = dispw - w - border;
X	if (maxx < 0)
X		maxx = 0;
X	h = (maxh >= 0 && *hp > maxh) ? maxh : *hp;
X	maxy = disph - h - border;
X	if (maxy < 0)
X		maxy = 0;
X
X	/*
X	 * If we haven't been given a positon, pick one.  If we've got
X	 * one, but the bitmap won't fit, adjust unless the user has set
X	 * -f.
X	 */
X
X	if (xpos < 0) {
X		xpos = drand48() * (maxx + 1);
X	} else if (xpos > maxx && !force) {
X		xpos = maxx;
X	}
X	if (ypos < 0) {
X		ypos = drand48() * (maxy + 1);
X	} else if (ypos > maxy && !force) {
X		ypos = maxy;
X	}
X
X	/* Adjust window size */
X
X	m_shapewindow(xpos, ypos, w + border, h + border);
X	m_getinfo(G_COORDS);
X	m_gets(buf);
X	(void) sscanf(buf, "%d %d %d %d", &x, &y, &w, &h);
X
X	if (verbose) {
X		(void) m_ttyreset();
X		m_selectwin(MAINWIN);
X		(void) printf("%s: %dx%d at (%d, %d)", arg, *wp, *hp, xpos, ypos);
X		if (w != *wp || h != *hp)
X			(void) printf(", cropped to %dx%d", w, h);
X		putchar('\n');
X		m_selectwin(win);
X		(void) m_ttyset();
X	}
X
X	*wp = w;
X	*hp = h;
X}
X
X/*
X * Calculate new position for local motions, starting at "from",
X * adjusting by "by", with a window width or height of "use", not to
X * exceed "limit". (Whew!)
X */
X
Xstatic int
Xadjust(from, by, use, limit)
Xint from;
Xint by;
Xint use;
Xint limit;
X{
X	if (by > 0) {
X		if (from + by + use > limit)
X			from = limit - use;
X		else
X			from += by;
X	} else {
X		if (from + by < limit)
X			from = limit;
X		else
X			from += by;
X	}
X	return from;
X}
X
X/*
X * Construct a menu string based on what in the menu[] array says it
X * should be shown.
X */
X
Xstatic void
Xmakemenu()
X{
X	char mbuf[512], *p;
X	int order[3];
X	int i, n;
X
X	if (direction == MENU_FWD) {
X		order[0] = MENU_FWD;
X		order[1] = MENU_BACK;
X	} else {
X		order[0] = MENU_BACK;
X		order[1] = MENU_FWD;
X	}
X	order[2] = MENU_STAT;
X
X	p = mbuf;
X	for (i = 0; i < sizeof(order) / sizeof(int); i++) {
X		for (n = 0; n <= MENU_QUIT; n++) {
X			if (menu[n].show && menu[n].dir == order[i])
X				p += sprintf(p, "%c%s", M_DELIM, menu[n].item);
X		}
X	}
X	for (i = 0; i < sizeof(order) / sizeof(int); i++) {
X		for (n = 0; n <= MENU_QUIT; n++) {
X			if (menu[n].show && menu[n].dir == order[i])
X				p += sprintf(p, "%c%s", M_DELIM,
X					     menu[n].action);
X		}
X	}
X	*p++ = M_DELIM;
X	*p++ = '\0';
X
X	m_loadmenu(1, mbuf);
X	m_selectmenu(1);
X	m_selectmenu2(1);
X}
BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM
	set -- `wc -c mview.c`
	if [ "$1" != "12808" ] ; then
		echo "shar: mview.c unpacked with wrong size!"
	fi
	chmod u=r,g=r,o=r mview.c
fi
if [ -f "abspath.c" ] ; then
	echo "shar: Will not overwrite existing file abspath.c"
else
	echo "shar: extracting abspath.c (511 characters)"
	sed 's/^X//' <<'BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM' > abspath.c
X/*
X * Convert to absolute pathname; may return pointer to static buffer
X *
X * @(#)abspath.c	2.1	93/01/25
X */
X
X#ifndef lint
Xstatic char *SCCS = "@(#)abspath.c	2.1 93/01/25";
X#endif
X
X#include <stdio.h>
X
Xchar *
Xabspath(file)
Xchar  *file;
X{
X	static char absfile[1024];
X	static char cwd[512];
X	extern char *getcwd();
X
X	if (*file != '/') {
X		if (cwd[0] == '\0') {
X			if (getcwd(cwd, sizeof(cwd)) == NULL) {
X				return NULL;
X			}
X		}
X		(void) sprintf(absfile, "%s/%s", cwd, file);
X		file = absfile;
X	}
X	return file;
X}
BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM
	set -- `wc -c abspath.c`
	if [ "$1" != "511" ] ; then
		echo "shar: abspath.c unpacked with wrong size!"
	fi
	chmod u=r,g=r,o=r abspath.c
fi
if [ -f "mime.overview" ] ; then
	echo "shar: Will not overwrite existing file mime.overview"
else
	echo "shar: extracting mime.overview (4136 characters)"
	sed 's/^X//' <<'BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM' > mime.overview
X
X
X                            MIME Overview
X
X                by Mark Grand <mark@premenos.sf.ca.us>
X
XInternet e-mail allows mail messages to be exchanged between users of
Xcomputers around the world and occasionally beyond... to space
Xshuttles.  One of the main reasons that Internet e-mail has achieved
Xsuch wide use is because it provides a standard mechanism for messages
Xto be exchanged between over 1,000,000 computers connected to the
XInternet.
X
XThe standards that are the basis for Internet e-mail were established
Xin 1982.  Though they were state of the art in 1982, in the
Xintervening years they have begun to show their age.  The 1982
Xstandards allow for mail messages that contain a single human readable
Xmessage with the restrictions that:
X
X    * the message contains only ASCII characters.
X
X    * the message contains no lines longer than 1000 characters.
X
X    * the message does not exceed a certain length
X
XThe 1982 standards do not allow EDI to be transmitted through Internet
Xmail, since EDI messages can violate all of these restrictions.  There
Xare a number of other types of messages and services that have are
Xsupported by other mail standards that have been designed more
Xrecently.  In June of 1992 a new Internet mail standard was approved.
XThis new standard is called MIME.
X
XMIME is an acronym for Multipurpose Internet Mail Extensions.  It
Xbuilds on the older standard by standardizing additional fields for
Xmail message headers that describe new types of content and
Xorganization for messages.
X
XMIME allows mail messages to contain:
X
X    * Multiple objects in a single message.
X
X    * Text having unlimited line length or overall length.
X
X    * Character sets other than ASCII.
X
X    * Multi-font messages.
X
X    * Binary or application specific files.
X
X    * Images, Audio, Video and multi-media messages.
X
XMIME defines the following new header fields:
X
X1.  A MIME-Version header field, which uses a version number to
X    declare that a message conforms to the MIME standard.
X
X2.  A Content-Type header field, which can be used to specify the type
X    and subtype of data in the body of a message and to fully specify
X    the encoding of such data.
X
X    2.a.  A Text Content-Type value, which can be used to represent
X          textual information in a number of character sets and
X          formatted text description languages in a standardized
X          manner.
X
X    2.b.  A Multipart Content-Type value, which can be used to combine
X          several body parts, possibly of differing types of data,
X          into a single message.
X
X    2.c.  An Application Content-Type value, which can be used to
X          transmit application data or binary data.
X
X    2.d.  A Message Content-Type value, for encapsulating a mail
X          message.
X
X    2.e.  An Image Content-Type value, for transmitting still image
X          (picture) data.
X
X    2.f.  An Audio Content-Type value, for transmitting audio or voice
X          data.
X
X    2.g.  A Video Content-Type value, for transmitting video or moving
X          image data, possibly with audio as part of the composite
X          video data format.
X
X3.  A Content-Transfer-Encoding header field, that specifies how the
X    data is encoded to allow it to pass through mail transports having
X    data or character set limitations.
X
X4.  Two optional header fields that can be used to further describe
X    the data in a message body, the Content-ID and Content-Description
X    header fields.
X
XMIME is an extensible mechanism.  It is expected that the set of
Xcontent-type/subtype pairs and their associated parameters will grow
Xwith time.  Several other MIME fields, such as character set names,
Xare likely to have new values defined over time.  To ensure that the
Xset of such values develops in an orderly, and public manner, MIME
Xdefines a registration process which uses the Internet Assigned
XNumbers Authority (IANA) as a central registry for such values.
X
XTo promote interoperability between implementations, the MIME standard
Xdocument specifies a minimal subset of the above mechanisms that are
Xrequired for an implementation to claim to conform to the MIME
Xstandard.
BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM
	set -- `wc -c mime.overview`
	if [ "$1" != "4136" ] ; then
		echo "shar: mime.overview unpacked with wrong size!"
	fi
	chmod u=rw,g=rw,o=rw mime.overview
fi
if [ -f "mhn-mgr" ] ; then
	echo "shar: Will not overwrite existing file mhn-mgr"
else
	echo "shar: extracting mhn-mgr (566 characters)"
	sed 's/^X//' <<'BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM' > mhn-mgr
Xmhn-compose-image/X-mgr:	mgrabscr
Xmhn-compose-image/X-pbm:	mgrabscr | mgrtopbm
Xmhn-compose-image/gif:		mgrabscr | mgrtopbm | ppmtogif
Xmhn-show-image/X-mgr:	mview -v %F
Xmhn-show-image/X-pbm:	pbmtomgr %F | mview -v
Xmhn-show-image/X-pgm:	pgmtopbm %F | pbmtomgr | mview -v
Xmhn-show-image/X-ppm:	ppmtopgm %F | pgmtopbm | pbmtomgr | mview -v
Xmhn-show-image/gif:	giftoppm %F | ppmtopgm | pgmtopbm | pbmtomgr | mview -v
Xmhn-show-image/jpeg:	djpeg -pnm -grayscale %F | pgmtopbm | pbmtomgr | mview -v
Xmhn-show-text/plain:	less %F
Xmhn-show-text/richtext:	richtext -o %F | less
BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM
	set -- `wc -c mhn-mgr`
	if [ "$1" != "566" ] ; then
		echo "shar: mhn-mgr unpacked with wrong size!"
	fi
	chmod u=rw,g=r,o=r mhn-mgr
fi
if [ -f "mailcap" ] ; then
	echo "shar: Will not overwrite existing file mailcap"
else
	echo "shar: extracting mailcap (995 characters)"
	sed 's/^X//' <<'BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM' > mailcap
X# Untested mailcaps for images on MGR using mview and mgrabscr, in
X# conjuction with the PBM and djpeg tools.
X# There's no composition rules for JPEG, since you probably would want
X# to do that manually, and no composition rules for PGM or PPM, since
X# anything that could understand them should work with PBM as well.
Ximage/gif; giftoppm %s | ppmtopgm | pgmtopbm | pbmtomgr | mview -v; \
X	needsterminal; compose="mgrabscr -v | mgrtopbm | ppmtogif > %s"; \
X	description="An MGR screen image in GIF format";
Ximage/jpeg; djpeg -pnm -grayscale %s | pgmtopbm | pbmtomgr | mview -v; \
X	needsterminal;
Ximage/x-mgr; mview %s; needsterminal; compose="mgrabscr -v %s"; \
X	description="An MGR screen image in MGR format";
Ximage/X-pbm; pbmtomgr %s | mview -v; needsterminal; \
X	compose="mgrabscr -v | mgrtopbm > %s"; \
X	description="An MGR screen image in PBM format";
Ximage/X-pgm; pgmtopbm %s | pbmtomgr | mview -v; needsterminal;
Ximage/X-ppm; ppmtopgm %s | pgmtopbm | pbmtomgr | mview -v; needsterminal;
BOP_BOP_A_LOO_WOP_BO_LOP_BAM_BOOM
	set -- `wc -c mailcap`
	if [ "$1" != "995" ] ; then
		echo "shar: mailcap unpacked with wrong size!"
	fi
	chmod u=rw,g=r,o=r mailcap
fi
exit

-- 
David H. Brierley
Home: dave@galaxia.network23.com; Work: dhb@quahog.ssd.ray.com
Send comp.sources.3b1 submissions to comp-sources-3b1@galaxia.network23.com
%% Pardon me Professor, can I be excused, my brain is full. **
