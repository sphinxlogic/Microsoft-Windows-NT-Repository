Path: comp-sources-3b1
From: vern@zebra.alphacdc.com (vern)
Subject:  v02i009:  Klondike, version 2, Part01/06
Newsgroups: comp.sources.3b1
Approved: dave@galaxia.network23.com
X-Checksum-Snefru: 8053e686 b5bea1bf 1b3ad936 c7c6f2ed

Submitted-by: vern@zebra.alphacdc.com (vern)
Posting-number: Volume 2, Issue 9
Archive-name: klondike2/part01

[ Vern doesn't really call this "version 2" but since there was already an  ]
[ existing klondike in the archives I have taken the liberty of adding the  ]
[ version number.  Consider this as meaning "the second version of klondike ]
[ that was posted in this newsgroup".                                       ]
[     Dave.                                                                 ]

This is the same 'klondike' game that Tom Tkacik posted some time ago.
I have hacked in some additional compile time options. These new
"features"?? are:

SCORES:	Calculate and display the score when playing the "Vegas" style.
	Scoring starts at -52 points for each new hand and all cards in
	the upper our stacks count +5 points except for uncovered Aces.
	Another way to state this is that Aces count zero, Dueces count
	+10 and all other cards count +5.

	Scores are displayed for the current hand, accumulated scores
	for this session and accumulated scores since forever.  You can
	reset "forever" with the 'F7', ZERO HIST, key.

CHEAT:	This displays a prompt if you attempt to turn over a card from
	the down deck and another play can be made on the board.  The
	suggested play is not necessarily the best play, it is the just
	the first one the computer found.

	A second click on the left mouse button will ignore the prompt
	and allow you to proceed.

	This option can enabled or disabled at any time with the 'F4',
	CHEAT ON/OFF, key.

UNDO:	Now we are getting into some serious cheating.  The 'F5', UNDO,
	key or the 'Undo' key on the left of the keyboard allows you to
	backtrack one play at a time.  This will continue until you reach
	the original display.  A quicker way of starting over is to press
	the 'F3', REPLAY HAND, key.

MARKS:	Keeping on with more and better cheating, The 'Mark' key at the
	lower left corner of the keyboard can be pressed at any time.
	Later, should you care to return to this display, use the 'Slect'
	or 'Shift Mark' key.

	The number of marked displays is indicated just below the unturned
	deck.

RUN:	This was suggested Kris Kugel and Tom Tkacik.  After all the down
	cards have been turned up, the game has been essentially won.
	The 'F6' key is activated and is identified on the screen as "RUN".
	Selecting RUN lets the computer move all the up cards to the upper
	out stacks and finish the game.

	You can still UNDO or Slect marked displays if winning isn't all
	you have in mind.

Included in this package are several ways to install this game.  Check
the README for instructions.  This not truly an "+IN" type suite, it does
not contain the binaries.  However it does have the scripts needed
to 'Install' via the User Agent.

If you would like to test the RUN feature, try "klondike -n2533814".
This hand is hard to lose.  For a more challenging win, try playing
"klondike -n6287970".  It can be won!

vern

Vernon C. Hoxie                            {ncar,boulder}!scicom!zebra!vern
3975 W. 29th Ave.                                       voice: 303-477-1780
Denver, Colo., 80212                                     uucp: 303-455-2670

------------------------------ cut here -----------------------------------

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 6)."
# Contents:  Files History INSTALL.sh Install MAKEcpio MAKEflop
#   MANIFEST Makefile Name Office README Remove Size Toybox cards.c
#   drag.c klondike.6 klondike.h window.c
# Wrapped by vern@zebra on Tue Jun 23 07:22:36 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f Files -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Files\"
else
echo shar: Extracting \"Files\" \(267 characters\)
sed "s/^X//" >Files <<'END_OF_Files'
X.
X./Files
X./History
X./INSTALL.sh
X./Install
X./MAKEcpio
X./MAKEflop
X./Makefile
X./Name
X./Office
X./README
X./Remove
X./Size
X./Toybox
X./cards.c
X./check.c
X./club.c
X./diamond.c
X./drag.c
X./heart.c
X./klondike.6
X./klondike.c
X./klondike.h
X./other.c
X./patch.01
X./spade.c
X./window.c
END_OF_Files
if test 267 -ne `wc -c <Files`; then
    echo shar: \"Files\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f History -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"History\"
else
echo shar: Extracting \"History\" \(4750 characters\)
sed "s/^X//" >History <<'END_OF_History'
XKlondike is that most popular of solitaire card games you learned as a child.
XThis version was written specifically for the AT&T UnixPC (3B1 or 7300).
XIt uses UnixPC graphics, and will probably not be very easy to port to
Xother machines, (though I don't doubt that someone try it.:-)
X
XIt is played with a single deck of cards, and the goal is to move as many
Xcards as possible from their initial positions (the tableau),
Xto output piles, (or foundations).
XThe game is won if all of the cards are removed from the tableau.
X
XI must thank Kent Quander for allowing me to
Xuse and distribute his wonderfully drawn playing cards.
X
XThere are a couple of compile time options.
XNormally the games beeps when you make a mistake, but I got tired of the
Xnoise, so there is a NOBEEP option which will make it keep quiet.
X
XI have also included an alternative to Kent's Ace of spades.
XLeaving off the BYQ option, you will see it.
X(The original is more imaginative.)
X
XAnd finally, I had trouble getting the mouse to repond properly when I
Xcompiled it with cc.  I had no problems with gcc.
XI added a couple of patches, (invoked with BADMOUSE), which fixed things.
XYou should not need it, but it does not hurt.
XYou can try leaving it out if you want.
X
XI do not like the borders on the standard windows, so (as is my practice),
XI made my own.  All that is lacking are the move and resize icons.
XIf anyone can figure out how they might be implemented, I would
Xlike to hear about it.
X
XType make, and have fun.
X
XTom Tkacik
Xtkacik@kyzyl.mi.org
X...!rphroy!kyzyl!tkacik
X
XNov. 2, 1991
X
XI added the scoring and cheating features.
X
X"Scoring" provides a score keeping facility.  It is active only for the
X"Vegas" style of playing.  Each new game starts at -52.  Then each card
Xover a covered ace counts +5.  With these rules, uncovered aces count
Xnothing.  Dueces count +10 and all subsequent cards in that suit count
X+5 points.
X
XUpon exiting, the three display score are added together and saved with
Xthe players login name until the next time the game is played.
X
XThe "cheating" feature will beep if another play is available when you
Xtry to turn over a new card from the down deck.  This feature may be
Xdisabled/enabled with the 'F4' function key.  If you prefer to ignore
Xany possible moves, a second push on the left mouse button will go ahead
Xand turn over the next card.
X
XIn this mode, one possible move is displayed at the bottom of the playing
Xarea.  This is not the only move possible nor the smartest move, it is
Xonly one posibility.  In 'Vegas' mode, an additional push on the left
Xmouse button will check for any final moves.
X
XThese features may be eliminated at compile time by commenting out the
X"#define CHEAT" and/or "#define SCORES" lines in 'klondike.h'.
X
XHave fun!
X
Xvern
X
XVernon C. Hoxie                            {ncar,boulder}!scicom!zebra!vern
X3975 W. 29th Ave.                                       voice: 303-477-1780
XDenver, Colo., 80212                          TB+        uucp: 303-455-2670
X
XJune 5, 1992
X
XSome refinments were added to the CHEAT option.
X
XThe UNDO feature was added.  Each time the F5 button is pressed, the
Xdisplay is moved back one move.  Like CHEAT and SCORES, this is a
Xcompile time option.  
X
XThe MARKS option was added.  This allows a specific screen to be marked
Xby pressing the Mark Key ( lower left corner of the 3b1 keyboard ).  It
Xis then recalled by pressing the Slect Key ( shift Mark Key ).  The UNDO
Xoption must be implemented to use this feature.
X
XThe window initialization routine was modified to easier define the
X"slk" lines depending upon the options selected.
X
XThe BADMOUSE, BYQ and NOBEEP options were moved from the Makefile to
Xklondike.h so that all the compile time options could be set at one
Xlocation.
X
Xvern
X
XVernon C. Hoxie                            {ncar,boulder}!scicom!zebra!vern
X3975 W. 29th Ave.                                       voice: 303-477-1780
XDenver, Colo., 80212                          TB+        uucp: 303-455-2670
X
XJune 15, 1992
X
XAt the suggestion of Kris Kugel and Tom Tkacik, I added RUN.  This
Xactivates the F6 key when all the cards have been turned over.  It will
Xthen move all the cards to the out stacks.
X
XJine 23, 1992
X
XCleaned up some glitches in the RUN option.  The cards were getting
Xclipped when they were moved to the top stacks.  Also the "RUN" slck
Xline didn't reset after an UNDO.  I also revised the scoring display
Xafter and UNDO.
X
XJust for the heck of it, I activated the 'Undo' key to operate as an
Xalternative to the 'F5' key.
X
Xvern
X
XVernon C. Hoxie                            {ncar,boulder}!scicom!zebra!vern
X3975 W. 29th Ave.                                       voice: 303-477-1780
XDenver, Colo., 80212                          TB+        uucp: 303-455-2670
END_OF_History
if test 4750 -ne `wc -c <History`; then
    echo shar: \"History\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f INSTALL.sh -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"INSTALL.sh\"
else
echo shar: Extracting \"INSTALL.sh\" \(723 characters\)
sed "s/^X//" >INSTALL.sh <<'END_OF_INSTALL.sh'
X# This script allows installation of a game from a Unix shell rather
X# than from an "Install" window.  It works best if you are 'root'!
X
XNAME=KLONDIKE+IN
X
Xmessage -c "You must be 'root' to run the Install script."
Xif [ "$?" != "0" ]
Xthen
X	exit
Xfi
X
Xif [ ! -f "$NAME" ]
Xthen
X	MAKEcpio
Xfi
X/usr/bin/Instcpio.sh $NAME
X
X# This does leave you in one of those obnoxious, undersized windows.
X# Maybe someone can tell me how to stretch them back to full size
X# without exiting the shell.
X
X# To remove 'klondike', run /usr/bin/Uninstall.sh.  This will get you a
X# menu to select what to remove.  Once again, you will end up in ome of
X# those obnoxious, undersized windows.
X
X# I have learned that 'windy' will restore the full window.
END_OF_INSTALL.sh
if test 723 -ne `wc -c <INSTALL.sh`; then
    echo shar: \"INSTALL.sh\" unpacked with wrong size!
fi
chmod +x INSTALL.sh
# end of overwriting check
fi
if test -f Install -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Install\"
else
echo shar: Extracting \"Install\" \(1008 characters\)
sed "s/^X//" >Install <<'END_OF_Install'
XUA=/usr/lib/ua
XDIR=/usr/games
XGAME="klondike"
XTITLE="Klondike"
XMAN=/usr/man/cat
X
Xif [ ! -d $DIR ] ; then
X	mkdir $DIR
X	chmod 755 $DIR
X	chown bin $DIR
X	chgrp users $DIR
Xfi
X
Xif [ ! -f $GAME -a ! -f $DIR/$GAME ]
Xthen
X	make
X	ret=$?
X	if [ $ret -ne "0" ]
X	then
X		echo "Couldn't make $GAME" $ret
X		exit
X	fi
X	make clean
Xfi
X
Xif [ ! -d ${MAN}6 ]
Xthen
X	mkdir ${MAN}6
X	chmod 777 ${MAN}6
X	chown bin ${MAN}6
X	chgrp users ${MAN}6
Xfi
X
Xif [ ! -d ${MAN}6/$GAME\.6 ]
Xthen
X	cp $GAME\.6 ${MAN}6/$GAME\.6
X	chmod 666 ${MAN}6/$GAME\.6
X	chown bin ${MAN}6/$GAME\.6
X	chgrp users ${MAN}6/$GAME\.6
Xfi
X
Xif [ -f $GAME ]
Xthen
X	echo "copying $GAME into $DIR:"
X
X	for fn in $GAME
X	do
X		mv $fn $DIR/$fn
X		chmod 755 $DIR/$fn
X		chown bin $DIR/$fn
X		chgrp bin $DIR/$fn
X	done
X
X	if [ -s $UA/Toybox ]
X	then
X		uaupd -r $TITLE -a Toybox Toybox
X	else
X		ln Toybox $UA/Toybox
X		chown bin $UA/Toybox
X		chgrp bin $UA/Toybox
X		chmod 666 $UA/Toybox
X		uaupd -r Toybox -a Office Office
X	fi
X	message -i "$TITLE is now installed.
XPress <Enter> to continue.\n"
Xfi
X
END_OF_Install
if test 1008 -ne `wc -c <Install`; then
    echo shar: \"Install\" unpacked with wrong size!
fi
chmod +x Install
# end of overwriting check
fi
if test -f MAKEcpio -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"MAKEcpio\"
else
echo shar: Extracting \"MAKEcpio\" \(49 characters\)
sed "s/^X//" >MAKEcpio <<'END_OF_MAKEcpio'
XGAME=KLONDIKE
X
Xcat Files | cpio -ocBv > $GAME+IN
END_OF_MAKEcpio
if test 49 -ne `wc -c <MAKEcpio`; then
    echo shar: \"MAKEcpio\" unpacked with wrong size!
fi
chmod +x MAKEcpio
# end of overwriting check
fi
if test -f MAKEflop -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"MAKEflop\"
else
echo shar: Extracting \"MAKEflop\" \(52 characters\)
sed "s/^X//" >MAKEflop <<'END_OF_MAKEflop'
XGAME=KLONDIKE
X
Xcat Files | cpio -ocBv > /dev/rfp021
END_OF_MAKEflop
if test 52 -ne `wc -c <MAKEflop`; then
    echo shar: \"MAKEflop\" unpacked with wrong size!
fi
chmod +x MAKEflop
# end of overwriting check
fi
if test -f MANIFEST -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"MANIFEST\"
else
echo shar: Extracting \"MANIFEST\" \(1574 characters\)
sed "s/^X//" >MANIFEST <<'END_OF_MANIFEST'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Files                     1	A listing of the files in this archive
X History                   1	A development history
X INSTALL.sh                1	Script for installing from any directory
X Install                   1	Script for "Install from floppy"
X MAKEcpio                  1	Generates KLONDIKE+IN cpio file
X MAKEflop                  1	Generates an installable floppy
X MANIFEST                  1	This shipping list
X Makefile                  1	'make' script
X Name                      1	required by UA install script
X Office                    1	Makes a 'Toybox' window
X README                    1	Installation instructions
X Remove                    1	Removal script for UA
X Size                      1	Required by UA
X Toybox                    1	Put's 'Klondike' in 'Toybox' window
X cards.c                   1	An array of the unshuffled deck
X check.c                   2	CHEAT, SCORE, UNDO and MARKS routines
X club.c                    3	Bitmap arrays for Clubs suit
X diamond.c                 4	Bitmap arrays for Diamonds suit
X drag.c                    1	Mouse dragging routines
X heart.c                   5	Bitmap arrays for Hearts suit
X klondike.6                1	Manual
X klondike.c                2	The main playing routines
X klondike.h                1	Defines and Macros
X other.c                   2	Bitmap arrays for Blank, Back and Joker cards
X spade.c                   6	Bitmap arrays for Spade suit
X window.c                  1	window generation routines
END_OF_MANIFEST
if test 1574 -ne `wc -c <MANIFEST`; then
    echo shar: \"MANIFEST\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Makefile -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile\"
else
echo shar: Extracting \"Makefile\" \(1452 characters\)
sed "s/^X//" >Makefile <<'END_OF_Makefile'
X#
X# The Makefile for the solitaire game klondike
X#
X# This makefile uses the shared libraries
X# just type make
X#
X
X# Uncomment the next two lines if you have GCC
X#CC = /gnu/bin/gcc
X#GNULIB = /gnu/lib/gcc-gnulib
X
XCFLAGS = -O
XLDFLAGS = -s
XSHAREDLIB = /lib/crt0s.o /lib/shlib.ifile
XNAME = klondike
XBIN = /usr/games
XMANDIR = /usr/man/cat6
XLINT = lint -xbp
X
XSRC=klondike.c drag.c window.c cards.c spade.c heart.c club.c \
X	diamond.c other.c check.c
XOBJ=klondike.o drag.o window.o cards.o spade.o heart.o club.o \
X	diamond.o other.o check.o
X
Xall: $(NAME)
X
X$(NAME): $(OBJ) Makefile
X	$(LD) $(LDFLAGS) -o $(NAME) $(SHAREDLIB) $(OBJ) $(GNULIB)
X
Xinstall: $(NAME)
X	cp $(NAME) $(BIN)/$(NAME)
X	chgrp bin $(BIN)/$(NAME)
X	chown bin $(BIN)/$(NAME)
X	cp $(NAME).6 $(MANDIR)/$(NAME).6
X	@if [ ! -d $(BIN)/lib ]; \
X	then \
X		mkdir $(BIN)/lib; \
X		chown bin $(BIN)/lib; \
X		chgrp bin $(BIN)/lib; \
X	fi
X	rm -f $(BIN)/lib/klon*
X
Xcpio:
X	cpio -oBvcd < Files > KLONDIKE+IN
X	compress KLONDIKE+IN
X
Xclean:
X	rm -f *.o core
X
Xshar:
X	shar -h shar1 README Makefile klondike.6 cards.c diamond.c
X	shar -h shar2 klondike.c club.c
X	shar -h shar3 drag.c heart.c klondike.h window.c
X	shar -h shar4 other.c spade.c
X
Xlint:
X	$(LINT) $(SRC)
X
X# Depedencies
Xklondike.o : klondike.c klondike.h
Xdrag.o : drag.c klondike.h
Xwindow.o : window.c klondike.h
Xcheck.o : check.c klondike.h
Xcards.o : cards.c klondike.h
Xclub.o : club.c
Xdiamond.o : diamond.c
Xheart.o : heart.c
Xspade.o : spade.c
Xother.o : other.c
X
END_OF_Makefile
if test 1452 -ne `wc -c <Makefile`; then
    echo shar: \"Makefile\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Name -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Name\"
else
echo shar: Extracting \"Name\" \(45 characters\)
sed "s/^X//" >Name <<'END_OF_Name'
XKlondike, a game of solitaire by Tom Tkacik.
END_OF_Name
if test 45 -ne `wc -c <Name`; then
    echo shar: \"Name\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Office -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Office\"
else
echo shar: Extracting \"Office\" \(47 characters\)
sed "s/^X//" >Office <<'END_OF_Office'
XName=Toybox
XExpert
XDefault=Open
XOpen=UA Toybox
END_OF_Office
if test 47 -ne `wc -c <Office`; then
    echo shar: \"Office\" unpacked with wrong size!
fi
chmod +x Office
# end of overwriting check
fi
if test -f README -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"README\"
else
echo shar: Extracting \"README\" \(1602 characters\)
sed "s/^X//" >README <<'END_OF_README'
XJune 16, 1992
X
XIf you received this from 'comp.sources.3b1', place all the prsts into a
Xseparate directory.  Then:
X	unshar *
X
XIf you received this as KLONDIKE+IN.Z, place this file in a separate
Xdirectory then:
X	uncompress KLONDIKE+IN.Z
X	cpio -iBvcd < KLONDIKE+IN
X
XYou will then have four choices of how to install the program.  If you
Xdo not have "Klondike" in your User Agent Toybox, you can use options 1,
X2, or 3.  If already have "Klondike" in the Toybox window or if you
Xdon't care for any UA interface, use option 4.
X
X1.  a. Place a formatted disk in the disk drive and enter the command:
X	MAKEfloppy
X
X    b. Go to the "install" login.
X
X    c. From the "Office of install" window, select "Administration".
X
X    d. From the "Administration" window, select "Software Setup".
X
X    e. From the "Software Setup" window, select "Install Software from Floppy".
X
X2.  a.Enter MAKEcpio and move the resulting KLONDIKE+IN file to
X/usr/spool/uucppublic.
X
X    b. Perform step b, c and d listed above.
X
X    c. From the "Software Setup" window, select "Install Software sent
Xby Electronic Mail".
X
X3.  a. Enter "INSTALL.sh".  This performs all the steps required from
Xthe current directory.
X
X4.  a. Enter "make install".
X
XYou must login as 'root' to perform options 3 or 4.
X
XTo produce a back up disk for options 2, 3, or 4, you can execute
X"make cpio".  The resulting "KLONDIKE+IN.Z" file can then be copied to
Xany formatted floppy.
X
Xvern
X
X--------
XVernon C. Hoxie		       {ncar,nbires,boulder,isis}!scicom!zebra!vern
X3975 W. 29th Ave.					voice: 303-477-1780
XDenver, Colo., 80212				  TB+	 uucp: 303-455-2670
END_OF_README
if test 1602 -ne `wc -c <README`; then
    echo shar: \"README\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Remove -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Remove\"
else
echo shar: Extracting \"Remove\" \(796 characters\)
sed "s/^X//" >Remove <<'END_OF_Remove'
X# This gets moved to /usr/installed with an entry in the
X# /usr/installed/CONTENTS file.  You can remove any installed software
X# from a full screen Unix window by calling /usr/bin/Uninstall.sh.
X# This will provide you with a menu to select which package you wish
X# to remove.  Unfortunately, it leaves you with an obnoxious, undersized
X# window which I don't know how to resize. --vch
X
XUA=/usr/lib/ua
XDIR=/usr/games
XGAME="klondike"
XTITLE="Klondike"
XMAN=/usr/man/cat
X
Xecho "removing $TITLE ..."
X
Xuaupd -r $TITLE Toybox
X
Xif [ ! -s $UA/Toybox ]
Xthen
X	/bin/rm -f $UA/Toybox
X	uaupd -r Toybox Office
Xfi
X
Xfor fn in $DIR/$GAME $DIR/$GAME/lib/TetScores
Xdo
X	/bin/rm -f $fn
Xdone
X
Xrm -f ${MAN}6/$GAME\.6
X
Xrm -f ${DIR}/lib/klon*
X
Xmessage -i "$TITLE the game has been removed. \nPress <Enter> to continue.\n"
END_OF_Remove
if test 796 -ne `wc -c <Remove`; then
    echo shar: \"Remove\" unpacked with wrong size!
fi
chmod +x Remove
# end of overwriting check
fi
if test -f Size -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Size\"
else
echo shar: Extracting \"Size\" \(4 characters\)
sed "s/^X//" >Size <<'END_OF_Size'
X400
END_OF_Size
if test 4 -ne `wc -c <Size`; then
    echo shar: \"Size\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Toybox -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Toybox\"
else
echo shar: Extracting \"Toybox\" \(59 characters\)
sed "s/^X//" >Toybox <<'END_OF_Toybox'
XName=Klondike
XDefault=Run
XRun=EXEC -wd /usr/games/klondike
END_OF_Toybox
if test 59 -ne `wc -c <Toybox`; then
    echo shar: \"Toybox\" unpacked with wrong size!
fi
chmod +x Toybox
# end of overwriting check
fi
if test -f cards.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"cards.c\"
else
echo shar: Extracting \"cards.c\" \(1131 characters\)
sed "s/^X//" >cards.c <<'END_OF_cards.c'
X/*
X *	Copyright 1990, Thomas E. Tkacik
X *			tkacik@kyzyl.mi.org
X *
X *	Acknowledgments to Kent Quander allowing me to
X *	 use and distribute his wonderfully drawn playing cards.
X *
X *	Permission is given to copy and distribute for non-profit purposes.
X *
X */
X
X#include "klondike.h"
X
X/* define the card locations */
Xint deck[52];
X
Xint outcard[4];	/* number of cards played out */
X
Xint down[7][7];	/* cards down in each column */
Xint numdown[7];
Xint up[7][13];		/* cards showing in each column */
Xint numup[7];
X
Xunsigned short *images[NUMCARDS] = {
X	spadea[0], spade2[0], spade3[0], spade4[0], spade5[0], spade6[0],
X	spade7[0], spade8[0], spade9[0], spade10[0], spadej[0], spadeq[0],
X	spadek[0],
X	hearta[0], heart2[0], heart3[0], heart4[0], heart5[0], heart6[0],
X	heart7[0], heart8[0], heart9[0], heart10[0], heartj[0], heartq[0],
X	heartk[0],
X	cluba[0], club2[0], club3[0], club4[0], club5[0], club6[0],
X	club7[0], club8[0], club9[0], club10[0], clubj[0], clubq[0],
X	clubk[0],
X	diama[0], diam2[0], diam3[0], diam4[0], diam5[0],
X	diam6[0], diam7[0], diam8[0], diam9[0], diam10[0],
X	diamj[0], diamq[0], diamk[0],
X	joker[0], joker[0]
X};
END_OF_cards.c
if test 1131 -ne `wc -c <cards.c`; then
    echo shar: \"cards.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f drag.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"drag.c\"
else
echo shar: Extracting \"drag.c\" \(5636 characters\)
sed "s/^X//" >drag.c <<'END_OF_drag.c'
X/*
X *	Copyright 1990, Thomas E. Tkacik
X *			tkacik@kyzyl.mi.org
X *
X *	Acknowledgments to Kent Quander allowing me to
X *	 use and distribute his wonderfully drawn playing cards.
X *
X *	Permission is given to copy and distribute for non-profit purposes.
X *
X */
X
X/*
X * double buffered dragging of the selected cards with the mouse
X */
X
X#include <malloc.h>
X#include <sys/window.h>
X#include "klondike.h"
X
X/* card that the mouse should drag */
Xextern int ucard;
X
X/* location of the upper left corner of the card  */
X/* the mouse pointer is at the center of the card */
Xstatic int x_screenoff, y_screenoff;
X
X/* the visible size of the card -- it may be against an edge */
Xstatic int drag_w, drag_h;
X
X/* buffer for holding the drag region */
Xstatic unsigned short dragged[12*FACE_SEP+CARD_H][5];
X
X/* number of bytes in the image buffer */
Xstatic unsigned int region_size = 0;
X
X/* pointer to dynamically allocated image buffer */
Xstatic unsigned short *save_region = 0;
X
X/*
X * set up parameters to be able to drag a card
X * and draw the card where the mouse is
X */
X
Xstart_dragging(x,y)
Xint x,y;  /* current mouse position */
X{
X
X	int x_cardoff, y_cardoff;
X
X     /* parameters required to display cards in the proper position */
X
X	x_screenoff = x - (w_cards/2);
X	y_screenoff = y - (h_cards/2);
X	drag_w = w_cards;
X	drag_h = h_cards;
X	x_cardoff = 0;
X	y_cardoff = 0;
X
X   	/* modify the parameters if the cards are only partially
X		 * on the screen */
X
X	if(x_screenoff <= SIDEBORDER + 1) {
X		x_cardoff = SIDEBORDER - x_screenoff + 1;
X		drag_w -= x_cardoff;
X		x_screenoff = SIDEBORDER + 1;
X	}
X	else if(x_screenoff >= WIND_W-SIDEBORDER-w_cards-1) {
X		drag_w = WIND_W - SIDEBORDER - x_screenoff - 1;
X	}
X	if(y_screenoff <= TOPBORDER + 1) {
X		y_cardoff = TOPBORDER - y_screenoff + 1;
X		drag_h -= y_cardoff;
X		y_screenoff = TOPBORDER + 1;
X	}
X	else if(y_screenoff >= WIND_H-TOPBORDER-h_cards-1) {
X		drag_h = WIND_H - TOPBORDER - y_screenoff - 1;
X	}
X
X     /* save the current area */
X
X	wrastop(wn, (unsigned short *)0, 0, dragged[0], 10,
X		x_screenoff, y_screenoff, 0, 0,
X		drag_w, drag_h, SRCSRC, DSTSRC, (unsigned short *)0);
X
X     /* draw the cards */
X
X	wrastop(wn, cards[0], 10, (unsigned short *)0, 0,
X		x_cardoff, y_cardoff, x_screenoff, y_screenoff,
X		drag_w, drag_h, SRCSRC, DSTSRC, (unsigned short *)0);
X}
X
X/*
X * clean up after placing the cards
X */
X
Xstop_dragging()
X{
X     /* redisplay the saved current area */
X
X	wrastop(wn, dragged[0], 10, (unsigned short *)0, 0,
X		0, 0, x_screenoff, y_screenoff,
X		drag_w, drag_h, SRCSRC, DSTSRC, (unsigned short *)0);
X}
X
X/*
X * restore the screen under the old position
X * and display the cards where the mouse is currently
X */
X
Xkeep_dragging(x,y)
Xint x, y;	/* current mouse position */
X{
X	int xmin, ymin, xmax, ymax;
X	int rows, cols, bytes_per_row;
X	int byte_count;
X	int new_x, new_y, newoff_x, newoff_y, new_w, new_h;
X
X
X     /* paramters for the new mouse location */
X
X	new_x = x - (w_cards/2);
X	new_y = y - (h_cards/2);
X	new_w = w_cards;
X	new_h = h_cards;
X	newoff_x = 0;
X	newoff_y = 0;
X
X     /* modify them if the cards run off the screen */
X
X	if(new_x <= SIDEBORDER + 1) {
X		newoff_x = SIDEBORDER - new_x + 1;
X		new_w -= newoff_x;
X		new_x = SIDEBORDER + 1;
X	}
X	else if(new_x >= WIND_W-SIDEBORDER-w_cards-1) {
X		new_w = WIND_W - SIDEBORDER - new_x - 1;
X	}
X	if(new_y <= TOPBORDER + 1) {
X		newoff_y = TOPBORDER - new_y + 1;
X		new_h -= newoff_y;
X		new_y = TOPBORDER + 1;
X	}
X	else if(new_y >= WIND_H-TOPBORDER-h_cards-1) {
X		new_h = WIND_H - TOPBORDER - new_y - 1;
X	}
X
X     /* need an off screen version of the playing area containing */
X     /* both the old mouse position and the new one */
X
X	xmin = (new_x < x_screenoff) ? new_x : x_screenoff;
X	ymin = (new_y < y_screenoff) ? new_y : y_screenoff;
X	xmax = (new_x+new_w > x_screenoff+drag_w) ?
X					new_x+new_w : x_screenoff+drag_w;
X	ymax = (new_y+new_h > y_screenoff+drag_h) ?
X					new_y+new_h : y_screenoff+drag_h;
X
X     /* how big an array is required to hold this part */
X     /*  the playing area? */
X
X	rows = ymax - ymin + 1;
X	cols = xmax - xmin + 1;
X	bytes_per_row = ((cols/16) + (((cols%16)>0)?1:0))*2;
X	byte_count = rows * bytes_per_row;
X
X     /* if the array is too small, make it bigger */
X
X	if(save_region == 0) {
X		region_size = byte_count;
X		save_region = (unsigned short*)malloc(region_size);
X	 } else if(byte_count > region_size) {
X		region_size = byte_count;
X		save_region = (unsigned short*)
X				realloc((char*)save_region, region_size);
X	}
X
X
X     /* now drag the cards */
X     /* do everything in the off screen buffer first */
X     /* so we do not see ghost images */
X
X     /* buffer the region we need to mess around with */
X
X	wrastop(wn, (unsigned short *)0, 0, save_region, bytes_per_row,
X		xmin, ymin, 0, 0,
X		cols, rows, SRCSRC, DSTSRC, (unsigned short *)0);
X
X     /* restore the image */
X
X	wrastop(wn, dragged[0], 10, save_region, bytes_per_row,
X		0, 0, x_screenoff-xmin, y_screenoff-ymin,
X		drag_w, drag_h, SRCSRC, DSTSRC, (unsigned short *)0);
X
X     /* save the area that will be overdrawn by the cards */
X
X	wrastop(wn, save_region, bytes_per_row, dragged[0], 10,
X		new_x-xmin, new_y-ymin, 0, 0,
X		new_w, new_h, SRCSRC, DSTSRC, (unsigned short *)0);
X		
X     /* draw the cards */
X
X	wrastop(wn, cards[0], 10, save_region, bytes_per_row,
X		newoff_x, newoff_y, new_x-xmin, new_y-ymin,
X		new_w, new_h, SRCSRC, DSTSRC, (unsigned short *)0);
X
X     /* put the whole thing back on the screen */
X
X	wrastop(wn, save_region, bytes_per_row, (unsigned short *)0, 0,
X		0, 0, xmin, ymin,
X		cols, rows, SRCSRC, DSTSRC, (unsigned short *)0);
X
X     /* update parameters */
X
X	x_screenoff = new_x;
X	y_screenoff = new_y;
X	drag_w = new_w;
X	drag_h = new_h;
X}
END_OF_drag.c
if test 5636 -ne `wc -c <drag.c`; then
    echo shar: \"drag.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f klondike.6 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"klondike.6\"
else
echo shar: Extracting \"klondike.6\" \(5032 characters\)
sed "s/^X//" >klondike.6 <<'END_OF_klondike.6'
X.\"	Copyright 1990 Thomas E. Tkacik
X.\"			tkacik@kyzyl.mi.org
X.\"
X.\"	Acknowledgments to Kent Quander allowing me to
X.\"	 use and distribute his wonderfully drawn playing cards.
X.\"
X.\"	Permission is given to copy and distribute for non-profit purposes.
X.\"
X.TH KLONDIKE 6 "6 October 1990"
X.SH NAME
Xklondike \- solitaire card game
X.SH SYNOPSIS
X.B /usr/games/klondike
X[\fB-v\fP] [ \fB-n \fI###\fR ]
X.SH DESCRIPTION
X.I Klondike
Xis that most popular of solitaire card games you learned as a child.
XIt is played with a single deck of cards, and the goal is to move as many
Xcards as possible from their initial positions (the tableau),
Xto output piles, (or foundations).
XThe game is won if all of the cards are removed from the tableau.
X.SH LAYOUT
XInitially, there are seven piles making up the tableau,
Xwith from one to seven cards in each pile.
XThe top most card is turned face up.
XAbove the tableau are the four output piles (foundations), initially empty.
XTo the left of the tableau is the stock, the unused cards, turned down.
X.SH PLAY
XThe mouse is used to move cards from either one of the piles, or the stock,
Xto another pile, or the foundation.
XA card may be moved onto another pile if it is a different color, and is one
Xless than the top card, (which is actually shown at the bottom of the screen).
XAll of the face up cards in a pile may be moved together.
X
XAfter moving the visible cards from a pile, the next card is turned up.
XWhen a pile is empty, a King may be played there.
XThis is the only way a King may be moved.
X
XA press of the left mouse button selects a card to move.
XA second press of left button postitions the card.
XThe middle button may be pressed to unselect a card.
X
XIf the left mouse button is pressed while the pointer is on the face down
Xcards of the stock, three cards are turned up.
XWhen the stock is empty, the face up cards are turned over, and you may
Xgo through them again.
X(If the \fB-v\fP option was given, then only one card is turned up, and
Xyou may only go through them once.)
X
XUsing the right mouse button to select a card, will move it from the tableau
Xto the proper foundation.
XA card may only be moved to the foundation if it is one greater than the
Xcard of the same suit showing already showing in the foundation.
XAn Ace may be moved to the foundation at any time.
XOnce a card has been moved to the foundation, it may not be moved back to
Xthe tableau.
X
XScore keeping capabilty has been included.  Each new game starts with a
Xscore of -52.  As cards are added to the upper region, +5 points are
Xadded to the score.  Only covered aces are scored.  That is, uncovered
Xaces score nothing and dueces score +10.  All other cards count +5.
X
XA summary score is maintained for all games in the current session.  An
Xall time score is saved from session to session on disk.  Separate
Xhistory files are maintained for each players login name.
X
XPrompting or "CHEAT"ing is also available.  This may be turned on and
Xoff with the F4 function key.  When ON, missed moves are printed on the
Xlower portion of the playing area.  These are computed when the left
Xmouse button is pressed with the mouse pointer in the unturned deck
Xregion.
X
XThe play displayed is not the only play possible nor is it the best play
Xpossible.  If you wish to ignore the play displayed, press the left
Xmouse button a second time.  To check for possible plays after turning
Xover all the card in 'Vegas' mode, put the mouse pointer in the empty
Xunturned deck region and press the left mouse button.
X
XMoves may be deleted by pressing F5 ( UNDO ).
X
XWhen all the cards from the deck have been played and all the down cards
Xon the tableau have been turned over, the RUN option will appear over
XF6.  When F6 is pressed, all the cards will move to the upper stacks.
X
X.SH OPTIONS
X.IP \fB-v\fP
XPlay Las Vegas style.
XTurn up one card at a time from the stock, and go through the stock only once.
XNormally three cards are turned, and you may go through the stock any number
Xof times.
X.IP \fB\-n \fI###\fR
XStart by dealing hand number ###.
X.SH BUTTONS
X\fIVEGAS RULES\fP plays a new hand, using Vegas style of play.
X\fIHOUSE RULES\fP plays a new hand, using the house rules, (turn three
Xcards at a time).
X\fIREPLAY HAND\fP does the obvious.  The only way to play the same hand
Xagain, but with different rules is to quit (either \fIQUIT\fP or \fIExit\fP)
Xand restart \fIklondike\fP.
X\fCHEAT ON\OFF\fP to provide missed play prompting.
X\fUNDO\fP redisplay the previous board.
X\RUN\fP put all exposed cards into the out decks.
X\fZERO HIST\fP reset all scores to zero.
X\fMark\fP mark this board for redisplaying.
X\fSlectlP return to the most recently 'marked' board.
X.SH AKNOWLEDGEMENTS
XThe playing cards are By Q.  They are the artistic creation of Kent Quander.
X.SH FILES
X/usr/games/klondike			executable
X.SH AUTHOR
XCopyright 1988 Thomas E. Tkacik
X.br
Xtkacik@kyzyl.mi.org
X.br
X<kyzyl!tkacik>
X.SH ADDITIONAL CONTRIBUTION
XProvided Nov. 2, 1991 and June 5, 1992 by Vernon C. Hoxie
X.br
X<zebra!vern>
X.SH BUGS
XHopefully none, but I am not betting on it.
END_OF_klondike.6
if test 5032 -ne `wc -c <klondike.6`; then
    echo shar: \"klondike.6\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f klondike.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"klondike.h\"
else
echo shar: Extracting \"klondike.h\" \(6330 characters\)
sed "s/^X//" >klondike.h <<'END_OF_klondike.h'
X/*
X *	Copyright 1990, Thomas E. Tkacik
X *			tkacik@kyzyl.mi.org
X *
X *	Acknowledgments to Kent Quander allowing me to
X *	 use and distribute his wonderfully drawn playing cards.
X *
X *	Permission is given to copy and distribute for non-profit purposes.
X *
X */
X
X		/* 
X		 * The following are the compile time options.
X		 * They may be invoked by removing the leading comment
X		 * symbol or omitted by adding a leading comment symbol
X		 * at the left.
X		 */
X/*
X * Define VEGAS 0 for House Rules default
X * or VEGAS 1 for Las Vegas Rules default.
X */
X#define VEGAS 1
X
X/* Uncomment if you would like to see the original ByQ A of spades */
X/* #define DByQ	/* */
X
X/* Uncomment one or the other of the following. */
X/* #define beep()						/* Uncomment to inhibit beeping. */
X#define beep()	wputc(wn, 007)		/* Uncomment to enable beeping. */
X
X/* 
X * Uncomment if the mouse refuses to let go of the cards.
X * I need to define BADMOUSE when I compile with cc, but not with gcc
X * I do not know why:-(.  You should never need it.
X * I would like to hear if this works with cc and BADMOUSE undefined
X */
X#define BADMOUSE	/*  */
X
X				/* CHEAT added by VCH 11-2-91 */
X				/* CHEAT revised by VCH 6-3-92 */
X/* Uncomment the next line to display missed moves. */
X#define CHEAT	/*  */
X
X				/* SCORES added by VCH 11-2-91 */
X/* Uncomment the next line to compute and save scores. */
X#define SCORES	/*  */
X
X				/* UNDO added by VCH 6-3-92 */
X/* Uncomment the next line to activate undo. */
X#define UNDO	/*  */
X
X				/* MARKS added by VCH 6-7-92 */
X/* Uncomment the next line to activate marking of screens */
X#define MARKS	/*  */
X
X				/* RUN added by VCH 6-15-92 */
X/* Uncomment the next line to activate running of tableau */
X#define RUN		/*  */
X
X/* 
X * End of Compile time options.
X */
X
X/* The MARKS option requires use of UNDO */
X#ifdef MARKS
X#ifndef UNDO
X#define UNDO
X#endif
X#endif
X
X#define	NUMCARDS  54		/* number of different images */
X
X#define COLOR(x) (((x)/13)&1)
X#define VALUE(x) (((x)%13)+1)
X#define SUIT(x)  ((x)/13)
X
X/* window size and offset */
X#define  SIDEBORDER 6
X#define  TOPBORDER  4
X#define  WINDOW_X   4		/* characters */
X#define  WINDOW_Y   1		/* characters */
X#define  ROWS       24		/* characters */
X#define  COLS       74		/* characters */
X#define  WIND_H     (ROWS*12)
X#define  WIND_W     (COLS*9)
X
X/* CARD size and offsets */
X#define  CARD_W	71							/* each card 71 pixels wide */
X#define  CARD_H	65							/* each card 65 pixels high */
X#define  TOP		6
X#define  DECK		16
X#define  LEFT		(16 + DECK + CARD_W)
X#define  SUIT_SEP	1
X#define  ROW_SEP	8
X#define  BACK_SEP	6  
X#define	FACE_SEP	10
X
X#define	CARDSHORTS ((CARD_W/16)+((CARD_W%16)?1:0)) /* shorts per row */
X#define	CARDSIZE (CARD_H * CARDSHORTS)             /* shorts per image */
X
Xextern int deck[52];
X
Xextern int outcard[4];	/* number of cards played in each suit */
X
Xextern int down[7][7];	/* cards down in each column */
Xextern int numdown[7];	/* number down cards in each column */
Xextern int up[7][13];	/* cards showing in each column */
Xextern int numup[7];		/* number of cards showing in each column */
X
X/* individual cards */
Xextern unsigned short spadea[65][5];
Xextern unsigned short spade2[65][5];
Xextern unsigned short spade3[65][5];
Xextern unsigned short spade4[65][5];
Xextern unsigned short spade5[65][5];
Xextern unsigned short spade6[65][5];
Xextern unsigned short spade7[65][5];
Xextern unsigned short spade8[65][5];
Xextern unsigned short spade9[65][5];
Xextern unsigned short spade10[65][5];
Xextern unsigned short spadej[65][5];
Xextern unsigned short spadeq[65][5];
Xextern unsigned short spadek[65][5];
Xextern unsigned short hearta[65][5];
Xextern unsigned short heart2[65][5];
Xextern unsigned short heart3[65][5];
Xextern unsigned short heart4[65][5];
Xextern unsigned short heart5[65][5];
Xextern unsigned short heart6[65][5];
Xextern unsigned short heart7[65][5];
Xextern unsigned short heart8[65][5];
Xextern unsigned short heart9[65][5];
Xextern unsigned short heart10[65][5];
Xextern unsigned short heartj[65][5];
Xextern unsigned short heartq[65][5];
Xextern unsigned short heartk[65][5];
Xextern unsigned short cluba[65][5];
Xextern unsigned short club2[65][5];
Xextern unsigned short club3[65][5];
Xextern unsigned short club4[65][5];
Xextern unsigned short club5[65][5];
Xextern unsigned short club6[65][5];
Xextern unsigned short club7[65][5];
Xextern unsigned short club8[65][5];
Xextern unsigned short club9[65][5];
Xextern unsigned short club10[65][5];
Xextern unsigned short clubj[65][5];
Xextern unsigned short clubq[65][5];
Xextern unsigned short clubk[65][5];
Xextern unsigned short diama[65][5];
Xextern unsigned short diam2[65][5];
Xextern unsigned short diam3[65][5];
Xextern unsigned short diam4[65][5];
Xextern unsigned short diam5[65][5];
Xextern unsigned short diam6[65][5];
Xextern unsigned short diam7[65][5];
Xextern unsigned short diam8[65][5];
Xextern unsigned short diam9[65][5];
Xextern unsigned short diam10[65][5];
Xextern unsigned short diamj[65][5];
Xextern unsigned short diamq[65][5];
Xextern unsigned short diamk[65][5];
Xextern unsigned short back[65][5];
Xextern unsigned short blank[65][5];
Xextern unsigned short joker[65][5];
X
X/* card image definitions */
Xextern unsigned short *images[NUMCARDS];
X
X/* cards to be dragged */
Xextern unsigned short cards[12*FACE_SEP+CARD_H][5];
X
X/* size of cards to be dragged, in pixels */
Xextern int h_cards, w_cards;
X
X/* built-in pattern used for wrastop() */
Xextern unsigned short patwhite[];
Xextern unsigned short patblack[];
X
X/* window discriptor */
Xextern int wn;
X
X#ifdef SCORES
X		/* Where the history scores are stored. */
X#define	SFILE "/usr/games/lib/klon."
X
X		/* The struct saved in SCORES */
Xtypedef struct {
X	char name[16];
X	int score;
X} str_score;
X#endif	/* SCORES */
X
X#ifdef UNDO
X
X#define UFILE "/usr/tmp/klon.undo"
Xextern int fu;				/* UNDO file descriptor */
Xextern int rec_num;		/* number of moves recorded */
X
Xtypedef struct {
X	int rec_indeck;		/* number of cards in down deck */
X	int rec_over;			/* number of cards turned over */
X	int rec_deck[52];		/* the unplayed deck */
X	int rec_outcard[4];	/* number of cards played in each suit */
X	int rec_down[7][7];	/* cards down in each column */
X	int rec_numdown[7];	/* number down cards in each column */
X	int rec_up[7][13];	/* cards showing in each column */
X	int rec_numup[7];		/* number of cards showing in each column */
X} record;
X
X#endif	/* UNDO */
X
X	
END_OF_klondike.h
if test 6330 -ne `wc -c <klondike.h`; then
    echo shar: \"klondike.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f window.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"window.c\"
else
echo shar: Extracting \"window.c\" \(4698 characters\)
sed "s/^X//" >window.c <<'END_OF_window.c'
X/*
X *	Copyright 1990, Thomas E. Tkacik
X *			tkacik@kyzyl.mi.org
X *
X *	Acknowledgments to Kent Quander allowing me to
X *	 use and distribute his wonderfully drawn playing cards.
X *
X *	Permission is given to copy and distribute for non-profit purposes.
X *
X */
X
X/*
X * window routines
X */
X
X#include <stdio.h>
X#include <fcntl.h>
X#include <termio.h>
X#include <sys/signal.h>
X#include <sys/window.h>
X#include <sys/font.h>
X#include "klondike.h"
X
Xint (*signal())();
X
X/* window discriptor */
Xint wn;
X
X/* window width and height */
Xint win_width, win_height;
X
Xint reborder(), leave();
X
X/*
X * initialize window and draw initial borders
X */
X
Xinitwindow()
X{
X     /* start with a clean window */
X     /*  this needs to be done because winit() uses the */
X     /*  current window first, so we open a new one     */
X
X	void do_slk();
X
X	(void)close(0);
X	(void)close(1);
X	(void)close(2);
X	wn = open("/dev/window", O_RDWR );
X	(void)dup(wn);
X	(void)dup(wn);
X
X     /* initialize the tam routines */
X
X	winit();
X
X     /* can only be run on the unixpc screen */
X     /* this is the official way to do this, but it does not
X	   * work properly. I still do not have a correct method
X	   * to do this */
X
X	if(iswind()==0) {
X		(void)fprintf(stderr, "must use bitmapped screen\n");
X		wexit(1);
X	}
X
X     /* open the playing window */
X
X	if((wn = wcreate(WINDOW_Y, WINDOW_X, ROWS, COLS, NBORDER)) == -1) {
X		(void)fprintf(stderr, "could not open window  wn = %d\n",wn);
X		wexit(1);
X	}
X
X     /* draw the initial border around the playing region */
X
X	do_slk( );									/* set cheating on */
X	initborder();
X
X     /* set up function keys */
X	wuser(wn, "klondike");
X
X     /* allow mouse inputs in 8 bit mode */
X
X	keypad(0,1);
X
X     /* turn off the cursor */
X
X	wputs(wn,"\033[=1C");
X
X     /* catch the signals */
X
X	(void)signal(SIGHUP,  leave);
X	(void)signal(SIGINT,  leave);
X	(void)signal(SIGQUIT, leave);
X	(void)signal(SIGWIND, reborder);
X}
X
X#ifdef CHEAT
X	extern int cheat;
X#endif
X#ifdef RUN
X	extern int run_deck;
X#endif
X
Xvoid
Xdo_slk( )
X{
X	char *upper, *lower;
X	char *p, *q;
X
X	upper =
X"  VEGAS    HOUSE    REPLAY                                              QUIT  ";
X	lower =
X"  RULES    RULES     HAND                                            ";
X
X#ifdef CHEAT
X	p = upper + 31;
X	q = "  CHEAT ";
X	while ( *q ) *p++ = *q++;
X	p = lower + 31;
X	if ( cheat ) q = "   ON   ";
X	else q = "   OFF  ";
X	while ( *q ) *p++ = *q++;
X#endif
X#ifdef UNDO
X	p = upper + 40;
X	q = "  UNDO  ";
X	while ( *q ) *p++ = *q++;
X#endif
X#ifdef RUN
X	p = upper + 52;
X	if ( run_deck ) q = "  RUN   ";
X	else q = "        ";
X	while ( *q ) *p++ = *q++;
X#endif
X#ifdef SCORES
X	p = upper + 61;
X	q = "  ZERO  ";
X	while ( *q ) *p++ = *q++;
X	p = lower + 61;
X	q = "  HIST  ";
X	while ( *q ) *p++ = *q++;
X#endif
X	wslk(wn, 0, upper, lower );
X}
X
X/*
X * draw the initial border around the playing window
X */
X
Xinitborder()
X{
X	struct uwdata win;
X
X     /* determine the initial window size in pixels */
X
X	(void)ioctl(wn, WIOCGETD, &win);
X
X     /* save the size so that everyone can use it */
X
X	win_width  = win.uw_width;
X	win_height = win.uw_height;
X
X     /* draw the border in the screen image */ 
X
X	wrastop(wn, (unsigned short *)0, 0, (unsigned short *)0, 0,
X		0, 0, 0, 0,
X		win_width, TOPBORDER, SRCPAT, DSTSRC, patwhite);
X	wrastop(wn, (unsigned short *)0, 0, (unsigned short *)0, 0,
X		0, 0, 0, win_height-TOPBORDER,
X		win_width, TOPBORDER, SRCPAT, DSTSRC, patwhite);
X	wrastop(wn, (unsigned short *)0, 0, (unsigned short *)0, 0,
X		0, 0, 0, 0,
X		SIDEBORDER, win_height, SRCPAT, DSTSRC, patwhite);
X	wrastop(wn, (unsigned short *)0, 0, (unsigned short *)0, 0,
X		0, 0, win_width-SIDEBORDER, 0,
X		SIDEBORDER, win_height, SRCPAT, DSTSRC, patwhite);
X}
X
X/*
X * catch SIGWIND -- draw border as forground or background
X */
X
Xreborder()
X{
X	unsigned short *pat;
X	struct uwdata win;
X
X     /* determine if the window is on top */
X
X	(void)ioctl(wn, WIOCGETD, &win);
X
X     /* if current window then add border interior, else remove it */
X
X	pat = (win.uw_uflags & KBDWIN) ? patwhite : patblack;
X
X	wrastop(wn, (unsigned short *)0, 0, (unsigned short *)0, 0,
X		0, 0, 1, 1,
X		win_width-2, TOPBORDER-2, SRCPAT, DSTSRC, pat);
X	wrastop(wn, (unsigned short *)0, 0, (unsigned short *)0, 0,
X		0, 0, 1, win_height-TOPBORDER+1,
X		win_width-2, TOPBORDER-2, SRCPAT, DSTSRC, pat);
X	wrastop(wn, (unsigned short *)0, 0, (unsigned short *)0, 0,
X		0, 0, 1, 1,
X		SIDEBORDER-2, win_height-2, SRCPAT, DSTSRC, pat);
X	wrastop(wn, (unsigned short *)0, 0, (unsigned short *)0, 0,
X		0, 0, win_width-SIDEBORDER+1, 1,
X		SIDEBORDER-2, win_height-2, SRCPAT, DSTSRC, pat);
X
X     /* reset signal trap */
X
X	(void) signal(SIGWIND, reborder);
X}
X
X/*
X * SIGINT, SIGQUIT -- close windows and cleanup
X */
X
Xleave()
X{
X	wdelete(wn);
X	wexit(0);
X}
END_OF_window.c
if test 4698 -ne `wc -c <window.c`; then
    echo shar: \"window.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of archive 1 \(of 6\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
David H. Brierley
Home: dave@galaxia.network23.com; Work: dhb@quahog.ssd.ray.com
Send comp.sources.3b1 submissions to comp-sources-3b1@galaxia.network23.com
%% Can I be excused, my brain is full. **
