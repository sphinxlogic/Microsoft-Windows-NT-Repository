Path: comp-sources-3b1
From: dave@galaxia.network23.com (David H. Brierley)
Subject:  v02i015:  Include files for use with GCC on the 3B1, Part01/01
Newsgroups: comp.sources.3b1
Approved: dave@galaxia.network23.com
X-Checksum-Snefru: dbc7e70a d1cc0f17 337a203b 15af9260

Submitted-by: dave@galaxia.network23.com (David H. Brierley)
Posting-number: Volume 2, Issue 15
Archive-name: gcc-incl/part01

A couple of people have experienced problems compiling some of the stuff
I've posted recently and more are bound to have even more problems with
the upcoming stuff.  Almost all of the problems relate to missing or
incorrect include files.  To head of any more problems, here is a dump of
my gcc-include directory (/usr/local/lib/gcc-include).  I think most of
the files are pretty much standard gcc stuff but some of them have been
obtained from elsewhere and some have been tweaked for use on the 3b1.
Unfortunately, I'm not sure which is which because all of the files are
dated from the day I had to rebuild my hard disk.

For a more complete set of ansi style include files you might want to check
out "volume01/ansihdr", which is a complete set of "ansi"-fied include files
that was posted by Alex Crain.

Not included in this posting are the network related include files which I
extracted from the uipc code that was also posted by Alex Crain (and which
is also available in volume01).  You might need those to compile the network
related routines from the compatibility library I posted a while ago.

Dave.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  MANIFEST assert.h ctype.h curses.h float.h limits.h
#   malloc.h memory.h proto.h stdarg.h stddef.h stdio.h stdlib.h
#   string.h sys sys/file.h sys/stat.h sys/types.h time.h unistd.h
#   va-i860.h va-mips.h va-pyr.h va-sparc.h va-spur.h varargs.h
# Wrapped by dave@galaxia on Mon Jun 29 19:22:03 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(902 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	
X assert.h                   1	
X ctype.h                    1	
X curses.h                   1	
X float.h                    1	
X limits.h                   1	
X malloc.h                   1	
X memory.h                   1	
X proto.h                    1	
X stdarg.h                   1	
X stddef.h                   1	
X stdio.h                    1	
X stdlib.h                   1	
X string.h                   1	
X sys                        1	
X sys/file.h                 1	
X sys/stat.h                 1	
X sys/types.h                1	
X time.h                     1	
X unistd.h                   1	
X va-i860.h                  1	
X va-mips.h                  1	
X va-pyr.h                   1	
X va-sparc.h                 1	
X va-spur.h                  1	
X varargs.h                  1	
END_OF_FILE
if test 902 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'assert.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'assert.h'\"
else
echo shar: Extracting \"'assert.h'\" \(846 characters\)
sed "s/^X//" >'assert.h' <<'END_OF_FILE'
X/* Allow this file to be included multiple times
X   with different settings of NDEBUG.  */
X#undef assert
X#undef __assert
X
X#ifdef NDEBUG
X#define assert(ignore)  ((void)0)
X#else
X
Xvoid __eprintf ();		/* Defined in gnulib */
X
X#ifdef __STDC__
X
X#define assert(expression)  \
X  ((void) ((expression) ? 0 : __assert (#expression, __FILE__, __LINE__)))
X
X#define __assert(expression, file, lineno)  \
X  (__eprintf ("Failed assertion `%s' at line %d of `%s'.\n",	\
X	      expression, lineno, file), 0)
X
X#else /* no __STDC__; i.e. -traditional.  */
X
X#define assert(expression)  \
X  ((void) ((expression) ? 0 : __assert (expression, __FILE__, __LINE__)))
X
X#define __assert(expression, file, lineno)  \
X  (__eprintf ("Failed assertion `%s' at line %d of `%s'.\n",	\
X	      "expression", lineno, file), 0)
X
X#endif /* no __STDC__; i.e. -traditional.  */
X
X#endif
END_OF_FILE
if test 846 -ne `wc -c <'assert.h'`; then
    echo shar: \"'assert.h'\" unpacked with wrong size!
fi
# end of 'assert.h'
fi
if test -f 'ctype.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ctype.h'\"
else
echo shar: Extracting \"'ctype.h'\" \(823 characters\)
sed "s/^X//" >'ctype.h' <<'END_OF_FILE'
X/* Some systems (e.g. SunOS 4.1) do not contain either macros or function
X   declarations for the function which ought to be provided within <ctype.h>.
X   This file assures that such declarations are available.
X
X   This file may be used with the GNU C compiler and may be placed into the
X   GNU_LIBDIR/gcc-include directory.  GCC will then use it instead of your
X   system's own native <stdio.h> file.
X
X   This file includes your native <ctype.h> file and then makes sure that all
X   functions which ought to be declared within <ctype.h> are in fact declared.
X*/
X
X#ifndef _GNU_CTYPE_H
X#define _GNU_CTYPE_H
X
X
X#ifdef __STDC__
X#define __(x) x
X#else
X#define __(x) ()
X#endif
X
Xextern int toupper __((int __ch));
Xextern int tolower __((int __ch));
X
X#undef __
X
X#include </usr/include/ctype.h>
X
X#endif /* !defined (_GNU_CTYPE_H) */
END_OF_FILE
if test 823 -ne `wc -c <'ctype.h'`; then
    echo shar: \"'ctype.h'\" unpacked with wrong size!
fi
# end of 'ctype.h'
fi
if test -f 'curses.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'curses.h'\"
else
echo shar: Extracting \"'curses.h'\" \(21044 characters\)
sed "s/^X//" >'curses.h' <<'END_OF_FILE'
X#ifndef		__STDC__
X# include	"/usr/include/curses.h"
X#else
X
X/*	Copyright (c) 1984 AT&T	*/
X/*	  All Rights Reserved  	*/
X
X/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
X/*	The copyright notice above does not evidence any   	*/
X/*	actual or intended publication of such source code.	*/
X
X#ident	"@(#)curses:screen/curses.form	1.4.1.4"
X/*
X * curses.h - this file is automatically made from caps, curses.form and
X *	curses.ed.
X *	Don't make changes directly to curses.h!
X */
X#ifndef _SUBWIN
X
X/*
X	The definition for 'reg' is not standard, and is provided for
X	compatibility reasons. User's are discouraged from using this.
X*/
X# define	reg	register
X
X# ifndef 	NONSTANDARD
X#ifndef stdin
X#  include  <stdio.h>
X#endif /* stdin */
X  /*
X   * This trick is used to distinguish between SYSV and V7 systems.
X   * We assume that L_ctermid is only defined in stdio.h in SYSV
X   * systems, but not in V7 or Berkeley UNIX.
X   */
X#  ifdef L_ctermid
X#   undef  SYSV
X#   define SYSV
X#  endif
X   /* Some V7 systems define L_ctermid - we list those here */
X#  ifdef sun
X#   undef SYSV
X#  endif
X
X#  include  <unctrl.h>
X#  ifdef SYSV
X#ifndef VINTR
X#   include <termio.h>
X#endif /* VINTR */
X   typedef struct termio SGTTY;
X#endif /* SYSV */
X#  ifndef SYSV
X#ifndef _SGTTYB_
X#   include <sgtty.h>
X#endif /* _SGTTYB_ */
X   typedef struct sgttyb SGTTY;
X/*
X * Here we attempt to improve portability by providing some #defines
X * for SYSV functions on non-SYSV systems.
X */
X#   define memcpy(dst, src, len)	bcopy((src), (dst), (len))
X#   define strchr			index
X#   define strrchr			rindex
X#  endif
X# else		/* NONSTANDARD */
X/*
X * NONSTANDARD is intended for a standalone program (no UNIX)
X * that manages screens.  The specific program is Alan Hewett's
X * ITC, which runs standalone on an 11/23 (at least for now).
X * It is unclear whether this code needs to be supported anymore.
X * It hasn't been tested in quite awhile.
X */
X# define NULL 0
X# endif		/* NONSTANDARD */
X
Xtypedef	char bool;
X
X/*
X * chtype is the type used to store a character together with attributes.
X * It can be set to "char" to save space, or "long" to get more attributes.
X */
X# ifdef	CHTYPE
X	typedef	CHTYPE chtype;
X# else
X	typedef unsigned short chtype;
X# endif /* CHTYPE */
X
X/* TRUE and FALSE get defined so many times, */
X/* let's not get in the way of other definitions. */
X#if	!defined(TRUE) || ((TRUE) != 1)
X# define	TRUE	(1)
X#endif
X#if	!defined(FALSE) || ((FALSE) != 0)
X# define	FALSE	(0)
X#endif
X#if	!defined(ERR) || ((ERR) != -1)
X# define	ERR	(-1)
X#endif
X#if	!defined(OK) || ((OK) != 0)
X# define	OK	(0)
X#endif
X
X/* values for win->_flags */
X# define	_SUBWIN		01
X# define	_ENDLINE	02
X# define	_FULLWIN	04
X# define	_SCROLLWIN	010
X# define	_FLUSH		020
X# define	_ISPAD		040
X# define	_WINCHANGED	0100
X# define	_WINMOVED	0200
X
X/* _firstch is initially set to this */
X# define	_NOCHANGE	-1
X
Xstruct _win_st {
X	short	_cury, _curx;
X	short	_maxy, _maxx;
X	short	_begy, _begx;
X	short	_flags;
X	chtype	_attrs;
X	bool	_clear;
X	bool	_leave;
X	bool	_scroll;
X	bool	_use_idl;	/* 0=no, 1=yes, 2=go by need_idl */
X	bool	_use_keypad;	/* 0=no, 1=yes, 2=yes/timeout */
X	bool	_use_meta;	/* T=use the meta key */
X	bool	_nodelay;	/* T=don't wait for tty input */
X	chtype	**_y;
X	short	*_firstch;
X	short	*_lastch;
X	short	_tmarg,_bmarg;
X	/* end of Vr2 structure */
X	bool	_need_idl;	/* T=have done ins/del line/scroll recently */
X	bool	_notimeout;	/* T=do wait for rest of function key */
X	short	_pminrow, _pmincol, _sminrow, _smincol, _smaxrow, _smaxcol;
X	short	_yoffset;
X};
X
Xextern int	LINES, COLS;
X
Xtypedef struct _win_st	WINDOW;
Xextern WINDOW	*stdscr, *curscr;
X
Xextern char	*Def_term, ttytype[];
X
X#ifdef lint
X/*
X * Various tricks to shut up lint about things that are perfectly fine.
X */
X# ifndef CURSES				/* if not internal to curses source */
Xstruct screen {
X	int _nobody_;
X};
X# endif /* CURSES */
X#endif /* lint */
X
Xtypedef struct screen	SCREEN;
X
X# ifndef NOMACROS
X
X#  ifndef MINICURSES
X/*
X * psuedo functions for standard screen
X */
X# define	addch(ch)	waddch(stdscr, ch)
X# define	getch()		wgetch(stdscr)
X# define	addstr(str)	waddstr(stdscr, str)
X# define	getstr(str)	wgetstr(stdscr, str)
X# define	move(y, x)	wmove(stdscr, y, x)
X# define	clear()		wclear(stdscr)
X# define	erase()		werase(stdscr)
X# define	clrtobot()	wclrtobot(stdscr)
X# define	clrtoeol()	wclrtoeol(stdscr)
X# define	insertln()	winsertln(stdscr)
X# define	deleteln()	wdeleteln(stdscr)
X# define	refresh()	wrefresh(stdscr)
X# define	inch()		winch(stdscr)
X# define	insch(c)	winsch(stdscr,c)
X# define	delch()		wdelch(stdscr)
X# define	standout()	wstandout(stdscr)
X# define	standend()	wstandend(stdscr)
X# define	attron(at)	wattron(stdscr,at)
X# define	attroff(at)	wattroff(stdscr,at)
X# define	attrset(at)	wattrset(stdscr,at)
X# define	echochar(ch)	wechochar(stdscr, ch)
X
X# define	setscrreg(t,b)	wsetscrreg(stdscr, t, b)
X# define	wsetscrreg(win,t,b)	(win->_tmarg=(t),win->_bmarg=(b))
X
X/*
X * mv functions
X */
X#define	mvwaddch(win,y,x,ch)	(wmove(win,y,x)==ERR?ERR:waddch(win,ch))
X#define	mvwgetch(win,y,x)	(wmove(win,y,x)==ERR?ERR:wgetch(win))
X#define	mvwaddstr(win,y,x,str)	(wmove(win,y,x)==ERR?ERR:waddstr(win,str))
X#define	mvwgetstr(win,y,x,str)	(wmove(win,y,x)==ERR?ERR:wgetstr(win,str))
X#define	mvwinch(win,y,x)	(wmove(win,y,x)==ERR?ERR:winch(win))
X#define	mvwdelch(win,y,x)	(wmove(win,y,x)==ERR?ERR:wdelch(win))
X#define	mvwinsch(win,y,x,c)	(wmove(win,y,x)==ERR?ERR:winsch(win,c))
X#define	mvaddch(y,x,ch)		mvwaddch(stdscr,y,x,ch)
X#define	mvgetch(y,x)		mvwgetch(stdscr,y,x)
X#define	mvaddstr(y,x,str)	mvwaddstr(stdscr,y,x,str)
X#define	mvgetstr(y,x,str)	mvwgetstr(stdscr,y,x,str)
X#define	mvinch(y,x)		mvwinch(stdscr,y,x)
X#define	mvdelch(y,x)		mvwdelch(stdscr,y,x)
X#define	mvinsch(y,x,c)		mvwinsch(stdscr,y,x,c)
X
X#  else /* MINICURSES */
X/*
X * MINICURSES is not documented or supported anymore.  The intent was
X * to avoid the window handling stuff for a smaller curses.  However,
X * the bulk of the code is below refresh (3/4 or so) so the savings
X * are insignificant.  This version of curses just isn't well suited
X * to a 16 bit processor, except with a tiny application.
X */
X
X# define	addch(ch)		m_addch(ch)
X# define	addstr(str)		m_addstr(str)
X# define	move(y, x)		m_move(y, x)
X# define	clear()			m_clear()
X# define	erase()			m_erase()
X# define	refresh()		m_refresh()
X# define	standout()		wstandout(stdscr)
X# define	standend()		wstandend(stdscr)
X# define	attron(at)		wattron(stdscr,at)
X# define	attroff(at)		wattroff(stdscr,at)
X# define	attrset(at)		wattrset(stdscr,at)
X# define	mvaddch(y,x,ch)		move(y, x), addch(ch)
X# define	mvaddstr(y,x,str)	move(y, x), addstr(str)
X# define	initscr			m_initscr
X# define	newterm			m_newterm
X# define	echochar(ch)		(m_addch(ch) == ERR ? ERR : m_refresh())
X
X/*
X * These functions don't exist in minicurses, so we define them
X * to nonexistent functions to help the user catch the error.
X */
X#define	getch		m_getch
X#define	getstr		m_getstr
X#define	clrtobot	m_clrtobot
X#define	clrtoeol	m_clrtoeol
X#define	insertln	m_insertln
X#define	deleteln	m_deleteln
X#define	inch		m_inch
X#define	insch		m_insch
X#define	delch		m_delch
X/* mv functions that aren't valid */
X#define	mvwaddch	m_mvwaddch
X#define	mvwgetch	m_mvwgetch
X#define	mvwaddstr	m_mvaddstr
X#define	mvwgetstr	m_mvwgetstr
X#define	mvwinch		m_mvwinch
X#define	mvwdelch	m_mvwdelch
X#define	mvwinsch	m_mvwinsch
X#define	mvgetch		m_mvwgetch
X#define	mvgetstr	m_mvwgetstr
X#define	mvinch		m_mvwinch
X#define	mvdelch		m_mvwdelch
X#define	mvinsch		m_mvwinsch
X/* Real functions that aren't valid */
X#define box		m_box
X#define delwin		m_delwin
X#define longname	m_longname
X#define makenew		m_makenew
X#define mvprintw	m_mvprintw
X#define mvscanw		m_mvscanw
X#define mvwin		m_mvwin
X#define mvwprintw	m_mvwprintw
X#define mvwscanw	m_mvwscanw
X#define newwin		m_newwin
X#define _outchar	m_outchar
X#define overlay		m_overlay
X#define overwrite	m_overwrite
X#define printw		m_printw
X#define putp		m_putp
X#define scanw		m_scanw
X#define scroll		m_scroll
X#define subwin		m_subwin
X#define touchwin	m_touchwin
X#define _tscroll	m_tscroll
X#define _tstp		m_tstp
X#define vidattr		m_vidattr
X#define waddch		m_waddch
X#define waddstr		m_waddstr
X#define wclear		m_wclear
X#define wclrtobot	m_wclrtobot
X#define wclrtoeol	m_wclrtoeol
X#define wdelch		m_wdelch
X#define wdeleteln	m_wdeleteln
X#define werase		m_werase
X#define wgetch		m_wgetch
X#define wgetstr		m_wgetstr
X#define winsch		m_winsch
X#define winsertln	m_winsertln
X#define wmove		m_wmove
X#define wprintw		m_wprintw
X#define wrefresh	m_wrefresh
X#define wscanw		m_wscanw
X#define setscrreg	m_setscrreg
X#define wsetscrreg	m_wsetscrreg
X
X#  endif /* MINICURSES */
X
X/*
X * psuedo functions
X */
X
X#define	getyx(win,y,x)		y = win->_cury, x = win->_curx
X#define	getbegyx(win,y,x)	y = win->_begy, x = win->_begx
X#define	getmaxyx(win,y,x)	y = win->_maxy, x = win->_maxx
X#define getsyx(y,x)		_getsyx(&y,&x)
X#define	winch(win)		(win->_y[win->_cury][win->_curx])
X
X/* Various video attributes */
X#define A_STANDOUT	0000200
X#define	_STANDOUT	A_STANDOUT    /* for compatability with old curses */
X#define A_UNDERLINE	0000400
X#define A_REVERSE	0001000
X#define A_BLINK		0002000
X#define A_DIM		0004000
X#define A_BOLD		0010000
X#define A_ALTCHARSET	0100000
X
X/* The next two are subject to change so don't depend on them */
X#define A_INVIS		0020000
X#define A_PROTECT	0040000
X
X#define A_NORMAL	0000000
X#define A_ATTRIBUTES	0177600
X#define A_CHARTEXT	0000177
X
X/*
X * Standard alternate character set.  The current ACS world is evolving,
X * so we support only a widely available subset: the line drawing characters
X * from the VT100, plus a few from the Teletype 5410.  Eventually there
X * may be support of more sophisticated ACS line drawing, such as that
X * in the Teletype 5410, the HP line drawing set, and the like.  There may
X * be support for some non line oriented characters as well.
X *
X * Line drawing ACS names are of the form ACS_trbl, where t is the top, r
X * is the right, b is the bottom, and l is the left.  t, r, b, and l might
X * be B (blank), S (single), D (double), or T (thick).  The subset defined
X * here only uses B and S.
X */
X#define ACS_BSSB	(acs_map['l'])
X#define ACS_SSBB	(acs_map['m'])
X#define ACS_BBSS	(acs_map['k'])
X#define ACS_SBBS	(acs_map['j'])
X#define ACS_SBSS	(acs_map['u'])
X#define ACS_SSSB	(acs_map['t'])
X#define ACS_SSBS	(acs_map['v'])
X#define ACS_BSSS	(acs_map['w'])
X#define ACS_BSBS	(acs_map['q'])
X#define ACS_SBSB	(acs_map['x'])
X#define ACS_SSSS	(acs_map['n'])
X
X/*
X * Human readable names for the most commonly used characters.
X * "Upper", "right", etc. are chosen to be consistent with the vt100 manual.
X */
X#define ACS_ULCORNER	ACS_BSSB
X#define ACS_LLCORNER	ACS_SSBB
X#define ACS_URCORNER	ACS_BBSS
X#define ACS_LRCORNER	ACS_SBBS
X#define ACS_RTEE	ACS_SBSS
X#define ACS_LTEE	ACS_SSSB
X#define ACS_BTEE	ACS_SSBS
X#define ACS_TTEE	ACS_BSSS
X#define ACS_HLINE	ACS_BSBS
X#define ACS_VLINE	ACS_SBSB
X#define ACS_PLUS	ACS_SSSS
X#define ACS_S1		(acs_map['o'])		/* scan line 1 */
X#define ACS_S9		(acs_map['s'])		/* scan line 9 */
X#define ACS_DIAMOND	(acs_map['`'])		/* diamond */
X#define ACS_CKBOARD	(acs_map['a'])		/* checker board (stipple) */
X#define ACS_DEGREE	(acs_map['f'])		/* degree symbol */
X#define ACS_PLMINUS	(acs_map['g'])		/* plus/minus */
X#define ACS_BULLET	(acs_map['~'])		/* bullet */
X	/* Teletype 5410/5420 symbols */
X#define ACS_LARROW	(acs_map[','])		/* arrow pointing left */
X#define ACS_RARROW	(acs_map['+'])		/* arrow pointing right */
X#define ACS_DARROW	(acs_map['.'])		/* arrow pointing down */
X#define ACS_UARROW	(acs_map['-'])		/* arrow pointing up */
X#define ACS_BOARD	(acs_map['h'])		/* board of squares */
X#define ACS_LANTERN	(acs_map['i'])		/* lantern symbol */
X#define ACS_BLOCK	(acs_map['0'])		/* solid square block */
X
Xextern chtype *acs_map;
X
X/* Funny "characters" enabled for various special function keys for input */
X/* This list is created from caps and curses.ed. Do not edit it! */
X#define KEY_BREAK	0401		/* break key (unreliable) */
X#define KEY_DOWN	0402		/* Sent by terminal down arrow key */
X#define KEY_UP		0403		/* Sent by terminal up arrow key */
X#define KEY_LEFT	0404		/* Sent by terminal left arrow key */
X#define KEY_RIGHT	0405		/* Sent by terminal right arrow key */
X#define KEY_HOME	0406		/* Sent by home key. */
X#define KEY_BACKSPACE	0407		/* Sent by backspace key */
X#define KEY_F0		0410		/* function key f0. */
X#define KEY_F(n)	(KEY_F0+(n))	/* Space for 64 function keys is reserved. */
X#define KEY_DL		0510		/* Sent by delete line key. */
X#define KEY_IL		0511		/* Sent by insert line. */
X#define KEY_DC		0512		/* Sent by delete character key. */
X#define KEY_IC		0513		/* Sent by ins char/enter ins mode key. */
X#define KEY_EIC		0514		/* Sent by rmir or smir in insert mode. */
X#define KEY_CLEAR	0515		/* Sent by clear screen or erase key. */
X#define KEY_EOS		0516		/* Sent by clear-to-end-of-screen key. */
X#define KEY_EOL		0517		/* Sent by clear-to-end-of-line key. */
X#define KEY_SF		0520		/* Sent by scroll-forward/down key */
X#define KEY_SR		0521		/* Sent by scroll-backward/up key */
X#define KEY_NPAGE	0522		/* Sent by next-page key */
X#define KEY_PPAGE	0523		/* Sent by previous-page key */
X#define KEY_STAB	0524		/* Sent by set-tab key */
X#define KEY_CTAB	0525		/* Sent by clear-tab key */
X#define KEY_CATAB	0526		/* Sent by clear-all-tabs key. */
X#define KEY_ENTER	0527		/* Enter/send (unreliable) */
X#define KEY_SRESET	0530		/* soft (partial) reset (unreliable) */
X#define KEY_RESET	0531		/* reset or hard reset (unreliable) */
X#define KEY_PRINT	0532		/* print or copy */
X#define KEY_LL		0533		/* Sent by home-down key */
X					/* The keypad is arranged like this: */
X					/*    a1    up    a3   */
X					/*   left   b2  right  */
X					/*    c1   down   c3   */
X#define KEY_A1		0534		/* Upper left of keypad */
X#define KEY_A3		0535		/* Upper right of keypad */
X#define KEY_B2		0536		/* Center of keypad */
X#define KEY_C1		0537		/* Lower left of keypad */
X#define KEY_C3		0540		/* Lower right of keypad */
X#define KEY_BTAB	0541		/* Back tab key */
X#define KEY_BEG		0542		/* beg(inning) key */
X#define KEY_CANCEL	0543		/* cancel key */
X#define KEY_CLOSE	0544		/* close key */
X#define KEY_COMMAND	0545		/* cmd (command) key */
X#define KEY_COPY	0546		/* copy key */
X#define KEY_CREATE	0547		/* create key */
X#define KEY_END		0550		/* end key */
X#define KEY_EXIT	0551		/* exit key */
X#define KEY_FIND	0552		/* find key */
X#define KEY_HELP	0553		/* help key */
X#define KEY_MARK	0554		/* mark key */
X#define KEY_MESSAGE	0555		/* message key */
X#define KEY_MOVE	0556		/* move key */
X#define KEY_NEXT	0557		/* next object key */
X#define KEY_OPEN	0560		/* open key */
X#define KEY_OPTIONS	0561		/* options key */
X#define KEY_PREVIOUS	0562		/* previous object key */
X#define KEY_REDO	0563		/* redo key */
X#define KEY_REFERENCE	0564		/* ref(erence) key */
X#define KEY_REFRESH	0565		/* refresh key */
X#define KEY_REPLACE	0566		/* replace key */
X#define KEY_RESTART	0567		/* restart key */
X#define KEY_RESUME	0570		/* resume key */
X#define KEY_SAVE	0571		/* save key */
X#define KEY_SBEG	0572		/* shifted beginning key */
X#define KEY_SCANCEL	0573		/* shifted cancel key */
X#define KEY_SCOMMAND	0574		/* shifted command key */
X#define KEY_SCOPY	0575		/* shifted copy key */
X#define KEY_SCREATE	0576		/* shifted create key */
X#define KEY_SDC		0577		/* shifted delete char key */
X#define KEY_SDL		0600		/* shifted delete line key */
X#define KEY_SELECT	0601		/* select key */
X#define KEY_SEND	0602		/* shifted end key */
X#define KEY_SEOL	0603		/* shifted clear line key */
X#define KEY_SEXIT	0604		/* shifted exit key */
X#define KEY_SFIND	0605		/* shifted find key */
X#define KEY_SHELP	0606		/* shifted help key */
X#define KEY_SHOME	0607		/* shifted home key */
X#define KEY_SIC		0610		/* shifted input key */
X#define KEY_SLEFT	0611		/* shifted left arrow key */
X#define KEY_SMESSAGE	0612		/* shifted message key */
X#define KEY_SMOVE	0613		/* shifted move key */
X#define KEY_SNEXT	0614		/* shifted next key */
X#define KEY_SOPTIONS	0615		/* shifted options key */
X#define KEY_SPREVIOUS	0616		/* shifted prev key */
X#define KEY_SPRINT	0617		/* shifted print key */
X#define KEY_SREDO	0620		/* shifted redo key */
X#define KEY_SREPLACE	0621		/* shifted replace key */
X#define KEY_SRIGHT	0622		/* shifted right arrow */
X#define KEY_SRSUME	0623		/* shifted resume key */
X#define KEY_SSAVE	0624		/* shifted save key */
X#define KEY_SSUSPEND	0625		/* shifted suspend key */
X#define KEY_SUNDO	0626		/* shifted undo key */
X#define KEY_SUSPEND	0627		/* suspend key */
X#define KEY_UNDO	0630		/* undo key */
X
X# endif /* NOMACROS */
X#endif /* _SUBWIN */
X
X/* ansi prototype definitions */
Xint baudrate(void);
Xvoid beep(void);
Xvoid box(WINDOW *win, chtype vert, chtype hor);
Xvoid cbreak(void);
Xvoid clearok(WINDOW *win, int bf);
Xint copywin(WINDOW *Srcwin, WINDOW *Dstwin, int minRowSrc, int minColSrc, int minRowDst, int minColDst, int maxRowDst, int maxColDst, int overlay);
Xvoid crmode(void);
Xint curs_set(int vis);
Xvoid def_prog_mode(void);
Xint delay_output(int ms);
Xvoid delwin(WINDOW *win);
Xint doupdate(void);
Xint draino(int ms);
Xvoid echo(void);
Xvoid endwin(void);
Xchar erasechar(void);
Xvoid filter(void);
Xvoid fixterm(void);
Xvoid flash(void);
Xvoid flushinp(void);
Xvoid garbagedlines(WINDOW *win, int beg, int num);
Xvoid _getsyx(int *y, int *x);
Xvoid gettmode(void);
Xvoid halfdelay(int tenths);
Xint has_ic(void);
Xint has_il(void);
Xvoid idlok(WINDOW *win, int bf);
XWINDOW *initscr(void);
Xvoid intrflush(WINDOW *win, int bf);
Xchar *keyname(int key);
Xvoid keypad(WINDOW *win, int bf);
Xchar killchar(void);
Xvoid leaveok(WINDOW *win, int bf);
Xchar *longname(void);
Xint m_addch(chtype c);
Xint m_addstr(char *str);
Xvoid m_clear(void);
Xvoid m_erase(void);
XWINDOW *m_initscr(void);
Xvoid m_move(int row, int col);
XSCREEN *m_newterm(char *type, FILE *ofd, FILE *ifd);
Xint m_refresh(void);
Xvoid m_tstp(void);
Xint meta(WINDOW *win, int bf);
Xvoid mvcur(int ly, int lx, int y, int x);
Xint mvprintw(int y, int x, char *fmt, ...);
Xint mvscanw(int y, int x, char *fmt, ...);
Xint mvwin(WINDOW *win, int by, int bx);
Xint mvwprintw(WINDOW *win, int y, int x, char *fmt, ...);
Xint mvwscanw(WINDOW *win, int y, int x, char *fmt, ...);
Xint napms(int ms);
XWINDOW *newpad(int nlines, int ncols);
XSCREEN *newterm(char *type, FILE *ofd, FILE *ifd);
XWINDOW *newwin(int num_lines, int num_cols, int begy, int begx);
Xvoid nl(void);
Xvoid nocbreak(void);
Xvoid nocrmode(void);
Xvoid nodelay(WINDOW *win, int bf);
Xvoid noecho(void);
Xvoid nonl(void);
Xvoid noraw(void);
Xint overlay(WINDOW *Src, WINDOW *Dst);
Xint overwrite(WINDOW *Src, WINDOW *Dst);
Xint pechochar(WINDOW *pad, chtype ch);
Xint pnoutrefresh(WINDOW *pad, int pminrow, int pmincol, int sminrow, int smincol, int smaxrow, int smaxcol);
Xint prefresh(WINDOW *pad, int pminrow, int pmincol, int sminrow, int smincol, int smaxrow, int smaxcol);
Xvoid putp(char *str);
Xint printw(char *fmt, ...);
Xvoid raw(void);
Xvoid reset_prog_mode(void);
Xvoid reset_shell_mode(void);
Xvoid resetterm(void);
Xvoid resetty(void);
Xvoid restartterm(char *term, int file, int *err);
Xvoid ripoffline(int line, int (*init )());
Xvoid saveterm(void);
Xvoid savetty(void);
Xint scanw(char *fmt, ...);
Xint scr_dump(char *file);
Xint scr_init(char *file);
Xint scr_restore(char *file);
Xint scroll(WINDOW *win);
Xint scrollok(WINDOW *win, int bf);
XSCREEN *set_term(SCREEN *new);
Xvoid setsyx(int y, int x);
Xint setterm(char *type);
Xint setupterm(char *term, int file, int *err);
Xvoid slk_clear(void);
Xvoid slk_init(int fmt);
Xchar *slk_label(int num);
Xvoid slk_noutrefresh(void);
Xint slk_refresh(void);
Xvoid slk_restore(void);
Xint slk_set(int num, char *lab, int fmt);
Xvoid slk_touch(void);
XWINDOW *subwin(WINDOW *orig, int nlines, int ncols, int by, int bx);
XWINDOW *subpad(WINDOW *orig, int nlines, int ncols, int by, int bx);
Xint tgetent(char *bp, char *name);
Xint tgetflag(char *id);
Xint tgetnum(char *id);
Xchar *tgetstr(char *id, char **area);
Xchar *tgoto(char *cap, int col, int row);
Xint tigetflag(char *id);
Xint tigetnum(char *id);
Xchar *tigetstr(char *id);
Xvoid touchwin(WINDOW *win);
Xvoid touchline(WINDOW *win, int fline, int num);
Xchar *tparm(char *instring, int parms);
Xvoid tputs(char *cp, int affcnt, int (*outc )());
Xvoid traceoff(void);
Xvoid traceon(void);
Xvoid _tstp(void);
Xint typeahead(int fd);
Xvoid ungetch(int key);
Xvoid vidattr(int newmode);
Xvoid vidputs(int nmode, int (*outc )());
Xint vwscanw(WINDOW *win, char *fmt, ...);
Xint vwprintw(WINDOW *win, char *fmt, ...);
Xint waddch(WINDOW *win, chtype c);
Xint waddstr(WINDOW *win, char *str);
Xint wattroff(WINDOW *win, int attrs);
Xint wattron(WINDOW *win, int attrs);
Xint wattrset(WINDOW *win, chtype attrs);
Xint wclear(WINDOW *win);
Xint wclrtobot(WINDOW *win);
Xint wclrtoeol(WINDOW *win);
Xint wdelch(WINDOW *win);
Xvoid wdeleteln(WINDOW *win);
Xint wechochar(WINDOW *win, chtype ch);
Xvoid werase(WINDOW *win);
Xint wgetch(WINDOW *win);
Xint wgetstr(WINDOW *win, char *str);
Xint winsch(WINDOW *win, chtype c);
Xint winsertln(WINDOW *win);
Xint wmove(WINDOW *win, int y, int x);
Xint wnoutrefresh(WINDOW *win);
Xint wprintw(WINDOW *win, char *fmt, ...);
Xint wrefresh(WINDOW *win);
Xint wscanw(WINDOW *win, char *fmt, ...);
Xint wstandend(WINDOW *win);
Xint wstandout(WINDOW *win);
X
X#endif /*__STDC__*/
END_OF_FILE
if test 21044 -ne `wc -c <'curses.h'`; then
    echo shar: \"'curses.h'\" unpacked with wrong size!
fi
# end of 'curses.h'
fi
if test -f 'float.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'float.h'\"
else
echo shar: Extracting \"'float.h'\" \(962 characters\)
sed "s/^X//" >'float.h' <<'END_OF_FILE'
X/* float.h */
X/* Produced by hard-params version 4.1, CWI, Amsterdam */
X
X#define FLT_RADIX 2
X#define FLT_MANT_DIG 24
X#define FLT_DIG 6
X#define FLT_ROUNDS 1
X#define FLT_EPSILON ((float)5.96046448e-08)
X#define FLT_MIN_EXP (-125)
X#define FLT_MIN ((float)1.17549435e-38)
X
X/* *** WARNING: Possibly bad output from printf above */
X/*     expected value around 1.17549435e-38, bit pattern:
X    00000000 10000000 00000000 00000000 */
X/*     sscanf gave           0.00000000e+00, bit pattern:
X    00000000 00000000 00000000 00000000 */
X/*     difference= 1.17549435e-38 */
X
X#define FLT_MIN_10_EXP (-37)
X#define FLT_MAX_EXP 128
X#define FLT_MAX ((float)3.40282347e+38)
X#define FLT_MAX_10_EXP 38
X
X#define DBL_MANT_DIG 53
X#define DBL_DIG 15
X#define DBL_EPSILON 2.2204460492503131e-16
X#define DBL_MIN_EXP (-1021)
X#define DBL_MIN 2.2250738585072014e-308
X#define DBL_MIN_10_EXP (-307)
X#define DBL_MAX_EXP 1024
X#define DBL_MAX 1.7976931348623157e+308
X#define DBL_MAX_10_EXP 308
X
END_OF_FILE
if test 962 -ne `wc -c <'float.h'`; then
    echo shar: \"'float.h'\" unpacked with wrong size!
fi
# end of 'float.h'
fi
if test -f 'limits.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'limits.h'\"
else
echo shar: Extracting \"'limits.h'\" \(1170 characters\)
sed "s/^X//" >'limits.h' <<'END_OF_FILE'
X/* Number of bits in a `char'.  */
X#define CHAR_BIT 8
X
X/* No multibyte characters supported yet.  */
X#define MB_LEN_MAX 1
X
X/* Minimum and maximum values a `signed char' can hold.  */
X#define SCHAR_MIN (-128)
X#define SCHAR_MAX 127
X
X/* Maximum value an `unsigned char' can hold.  (Minimum is 0).  */
X#define UCHAR_MAX 255U
X
X/* Minimum and maximum values a `char' can hold.  */
X#ifdef __CHAR_UNSIGNED__
X#define CHAR_MIN 0
X#define CHAR_MAX 255U
X#else
X#define CHAR_MIN (-128)
X#define CHAR_MAX 127
X#endif
X
X/* Minimum and maximum values a `signed short int' can hold.  */
X#define SHRT_MIN (-32768)
X#define SHRT_MAX 32767
X
X/* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  */
X#define USHRT_MAX 65535U
X
X/* Minimum and maximum values a `signed int' can hold.  */
X#define INT_MIN (-INT_MAX-1)
X#define INT_MAX 2147483647
X
X/* Maximum value an `unsigned int' can hold.  (Minimum is 0).  */
X#define UINT_MAX 4294967295U
X
X/* Minimum and maximum values a `signed long int' can hold.
X   (Same as `int').  */
X#define LONG_MIN (-LONG_MAX-1)
X#define LONG_MAX 2147483647
X
X/* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  */
X#define ULONG_MAX 4294967295U
END_OF_FILE
if test 1170 -ne `wc -c <'limits.h'`; then
    echo shar: \"'limits.h'\" unpacked with wrong size!
fi
# end of 'limits.h'
fi
if test -f 'malloc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'malloc.h'\"
else
echo shar: Extracting \"'malloc.h'\" \(1270 characters\)
sed "s/^X//" >'malloc.h' <<'END_OF_FILE'
X/* According to the ANSI-C standard, all of the functions declared in this
X   file should be declared in <stdlib.h>, but many older versions of UN*X
X   did not have a file called <stdlib.h> and so many older C programs still
X   contain #include directives for <malloc.h>.
X
X   This file may be used with the GNU C compiler to make sure that programs
X   which #include <malloc.h> will get ANSI-conformant declarations of the
X   functions declared below.
X
X   This file may be placed into the GNU_LIBDIR/gcc-include directory.  GCC
X   will then use it instead of your system's own native <malloc.h> file.
X
X   This file includes your native <malloc.h> file and then makes sure that
X   all functions normally declared within <malloc.h> have ANSI-conformant
X   declarations.
X
X   Note that older versions of UN*X have malloc, realloc, and calloc returning
X   a char* but the ANSI C standard calls for these functions to return void*.
X   This file effectively corrects such problems.
X*/
X
X#ifndef _GNU_MALLOC_H
X#define _GNU_MALLOC_H
X
X#define malloc ___malloc
X#define realloc ___realloc
X#define calloc ___calloc
X#define free ___free
X#include </usr/include/malloc.h>
X#undef malloc
X#undef realloc
X#undef calloc
X#undef free
X
X#include <stdlib.h>
X
X#endif /* !defined (_GNU_MALLOC_H) */
END_OF_FILE
if test 1270 -ne `wc -c <'malloc.h'`; then
    echo shar: \"'malloc.h'\" unpacked with wrong size!
fi
# end of 'malloc.h'
fi
if test -f 'memory.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'memory.h'\"
else
echo shar: Extracting \"'memory.h'\" \(421 characters\)
sed "s/^X//" >'memory.h' <<'END_OF_FILE'
X#ifndef		__STDC__
X# include	"/usr/include/memory.h"
X#else
X
X#sccs	"@(#)inchead:memory.h	1.1"
X
X/*	Convergent Technologies - System V - May 1983	*/
X
Xextern char    *memccpy (char *a, char *b, int c, int n);
Xextern char    *memchr (char *s, int c, int n);
Xextern int      memcmp (char *a, char *b, int n);
Xextern char    *memcpy (char *a, char *b, int n);
Xextern char    *memset (char *s, int c, int n);
X
X#endif	/*__STDC__*/
END_OF_FILE
if test 421 -ne `wc -c <'memory.h'`; then
    echo shar: \"'memory.h'\" unpacked with wrong size!
fi
# end of 'memory.h'
fi
if test -f 'proto.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'proto.h'\"
else
echo shar: Extracting \"'proto.h'\" \(137 characters\)
sed "s/^X//" >'proto.h' <<'END_OF_FILE'
X/* This header file is to avoid trouble with semi-ANSI header files
X   on the Convex in system version 8.0.  */
X
X#define _PROTO(list) ()
END_OF_FILE
if test 137 -ne `wc -c <'proto.h'`; then
    echo shar: \"'proto.h'\" unpacked with wrong size!
fi
# end of 'proto.h'
fi
if test -f 'stdarg.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stdarg.h'\"
else
echo shar: Extracting \"'stdarg.h'\" \(1118 characters\)
sed "s/^X//" >'stdarg.h' <<'END_OF_FILE'
X#ifndef _STDARG_H
X#define _STDARG_H
X
X/* The macro _VA_LIST_ is the same thing used by this file in Ultrix.  */
X#ifndef _VA_LIST_
X#define _VA_LIST_
Xtypedef char *va_list;
X#endif
X
X/* Amount of space required in an argument list for an arg of type TYPE.
X   TYPE may alternatively be an expression whose type is used.  */
X
X#define __va_rounded_size(TYPE)  \
X  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))
X
X#ifndef __sparc__
X#define va_start(AP, LASTARG) 						\
X (AP = ((char *) __builtin_next_arg ()))
X#else
X#define va_start(AP, LASTARG) 						\
X (__builtin_saveregs (),						\
X  AP = ((char *) __builtin_next_arg ()))
X#endif
X
Xvoid va_end (va_list);		/* Defined in gnulib */
X#define va_end(AP)
X
X#ifdef __mips__
X#define va_arg(AP, mode) ((mode *)(AP = \
X	(char *) (sizeof(mode) > 4 ? ((int)AP + 2*8 - 1) & -8 \
X				   : ((int)AP + 2*4 - 1) & -4)))[-1]
X#else /* not __mips__ */
X#define va_arg(AP, TYPE)						\
X (*((TYPE *) (AP += __va_rounded_size (TYPE),				\
X	      AP - (sizeof (TYPE) < 4 ? sizeof (TYPE)			\
X		    : __va_rounded_size (TYPE)))))
X#endif /* not __mips__ */
X
X#endif /* _STDARG_H */
END_OF_FILE
if test 1118 -ne `wc -c <'stdarg.h'`; then
    echo shar: \"'stdarg.h'\" unpacked with wrong size!
fi
# end of 'stdarg.h'
fi
if test -f 'stddef.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stddef.h'\"
else
echo shar: Extracting \"'stddef.h'\" \(1213 characters\)
sed "s/^X//" >'stddef.h' <<'END_OF_FILE'
X#ifndef _STDDEF_H
X#define _STDDEF_H
X
X/* Signed type of difference of two pointers.  */
X
X#ifndef _PTRDIFF_T	/* in case <sys/types.h> has defined it. */
X#ifndef _T_PTRDIFF
X#ifndef __PTRDIFF_T
X#ifndef _PTRDIFF_T_
X#ifndef ___int_ptrdiff_t_h
X#define _PTRDIFF_T
X#define _T_PTRDIFF
X#define __PTRDIFF_T
X#define _PTRDIFF_T_
X#define ___int_ptrdiff_t_h
Xtypedef long ptrdiff_t;
X#endif /* ___int_ptrdiff_t_h */
X#endif /* _PTRDIFF_T_ */
X#endif /* __PTRDIFF_T */
X#endif /* _T_PTRDIFF */
X#endif /* _PTRDIFF_T */
X
X/* Unsigned type of `sizeof' something.  */
X
X#ifndef _SIZE_T	/* in case <sys/types.h> has defined it. */
X#ifndef _T_SIZE
X#ifndef __SIZE_T
X#ifndef _SIZE_T_
X#ifndef ___int_size_t_h
X#define _SIZE_T
X#define _T_SIZE
X#define __SIZE_T
X#define _SIZE_T_
X#define ___int_size_t_h
Xtypedef unsigned long size_t;
X#endif /* ___int_size_t_h */
X#endif /* _SIZE_T_ */
X#endif /* __SIZE_T */
X#endif /* _T_SIZE */
X#endif /* _SIZE_T */
X
X/* A null pointer constant.  */
X
X#undef NULL		/* in case <stdio.h> has defined it. */
X#ifdef __STDC__
X#define NULL ((void *)0)
X#else
X#define NULL 0
X#endif
X
X/* Offset of member MEMBER in a struct of type TYPE.  */
X
X#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
X
X#endif /* _STDDEF_H */
END_OF_FILE
if test 1213 -ne `wc -c <'stddef.h'`; then
    echo shar: \"'stddef.h'\" unpacked with wrong size!
fi
# end of 'stddef.h'
fi
if test -f 'stdio.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stdio.h'\"
else
echo shar: Extracting \"'stdio.h'\" \(4900 characters\)
sed "s/^X//" >'stdio.h' <<'END_OF_FILE'
X/* According to the ANSI-C standard, all of the functions declared in this
X   file should be declared in <stdio.h>, but on some operating systems (most
X   notably SunOS 4.0 and SunOS 4.1) some/many of these functions are not
X   declared in <stdio.h> as they should be.
X
X   This file may be used with the GNU C compiler and may be placed into the
X   GNU_LIBDIR/gcc-include directory.  GCC will then use it instead of your
X   system's own native <stdio.h> file.
X
X   This file includes your native <stdio.h> file and then makes sure that all
X   functions which ANSI-C requires to be declared within <stdio.h> are in
X   fact declared.
X
X   Note that SunOS and some other BSD-derived systems have sprintf() returning
X   a char* but the ANSI C standard calls for it to return an int.  These two
X   possibilities are radically incompatible, but here we allow SunOS to have
X   its way (even though that means deviating from the ANSI-C standard).
X*/
X
X#ifndef _GNU_STDIO_H
X#define _GNU_STDIO_H
X
X#define fprintf ___fprintf
X#define fscanf ___fscanf
X#define printf ___printf
X#define scanf ___scanf
X#define sprintf ___sprintf
X#define sscanf ___sscanf
X#define remove ___remove
X#define fopen ___fopen
X#define freopen ___freopen
X#define setvbuf ___setvbuf
X#define vprintf ___vprintf
X#define vfprintf ___vfprintf
X#define vsprintf ___vsprintf
X#define fputs ___fputs
X#define puts ___puts
X#define fread ___fread
X#define fwrite ___fwrite
X#define fsetpos ___fsetpos
X#define perror ___perror
X#include </usr/include/stdio.h>
X#undef fprintf
X#undef fscanf
X#undef printf
X#undef scanf
X#undef sprintf
X#undef sscanf
X#undef remove
X#undef fopen
X#undef freopen
X#undef setvbuf
X#undef vprintf
X#undef vfprintf
X#undef vsprintf
X#undef fputs
X#undef puts
X#undef fread
X#undef fwrite
X#undef fsetpos
X#undef perror
X
X/* The type size_t is always defined as `unsigned long' for GNU C.  */
X
X#define _SIZE_T_TYPE unsigned long
X
X/* The type fpos_t is probably type `long'.  If that's not correct for your
X   system, change the following define.  */
X
X#define _FPOS_T_TYPE long
X
X#ifdef __STDC__
X#define __(x) x
X#else
X#define __(x) ()
X#endif
X
Xextern int remove __((const char *__filename));
Xextern int rename __((const char *__old, const char *__new));
Xextern FILE *tmpfile __((void));
Xextern char *tmpnam __((char *__s));
Xextern int fclose __((FILE *__stream));
Xextern int fflush __((FILE *__stream));
Xextern FILE *fopen __((const char *__filename, const char *__mode));
Xextern FILE *freopen __((const char *__filename, const char *__mode, FILE *__stream));
Xextern void setbuf __((FILE *__stream, char *__buf));
Xextern int setvbuf __((FILE *__stream, char *__buf, int __mode, _SIZE_T_TYPE __size));
Xextern int fprintf __((FILE *__stream, const char *__format, ...));
Xextern int fscanf __((FILE *__stream, const char *__format, ...));
Xextern int printf __((const char *__format, ...));
Xextern int scanf __((const char *__format, ...));
Xextern
X#if defined(sun) || defined(bsd4_2) || defined (bsd43) || (defined(ultrix) && !defined(SYSTEM_FIVE)) || defined (alliant) || defined (aegis) || defined (convex) || defined (tahoe) || defined (is68k) || defined (NeXT) || defined (pyr) || defined (sequent)
X	char *
X#else
X	int
X#endif
X		sprintf __((char *__s, const char *__format, ...));
Xextern int sscanf __((const char *__s, const char *__format, ...));
X#if defined(va_list) || defined(_VA_LIST_)
Xextern int vfprintf __((FILE *__stream, const char *__format, va_list __arg));
Xextern int vprintf __((const char *__format, va_list __arg));
Xextern int vsprintf __((char *__s, const char *__format, va_list __arg));
X#endif
Xextern int fgetc __((FILE *__stream));
Xextern char *fgets __((char *__s, int __n, FILE *__stream));
Xextern int fputc __((int __c, FILE *__stream));
Xextern int fputs __((const char *__s, FILE *__stream));
X#ifndef getc
Xextern int getc __((FILE *__stream));
X#endif
X#ifndef getchar
Xextern int getchar __((void));
X#endif
Xextern char *gets __((char *__s));
X#ifndef putc
Xextern int putc __((int __c, FILE *__stream));
X#endif
X#ifndef putchar
Xextern int putchar __((int __c));
X#endif
Xextern int puts __((const char *__s));
Xextern int ungetc __((int __c, FILE *__stream));
Xextern _SIZE_T_TYPE fread __((void *__ptr, _SIZE_T_TYPE __size, _SIZE_T_TYPE __nmemb, FILE *__stream));
Xextern _SIZE_T_TYPE fwrite __((const void *__ptr, _SIZE_T_TYPE __size, _SIZE_T_TYPE __nmemb, FILE *__stream));
Xextern int fgetpos __((FILE *__stream, _FPOS_T_TYPE *__pos));
Xextern int fseek __((FILE *__stream, long int __offset, int __whence));
Xextern int fsetpos __((FILE *__stream, const _FPOS_T_TYPE *__pos));
Xextern long int ftell __((FILE *__stream));
Xextern void rewind __((FILE *__stream));
X#ifndef clearerr
Xextern void clearerr __((FILE *__stream));
X#endif
X#ifndef feof
Xextern int feof __((FILE *__stream));
X#endif
X#ifndef ferror
Xextern int ferror __((FILE *__stream));
X#endif
Xextern void perror __((const char *__s));
X
X#undef __
X
X#endif /* !defined (_GNU_STDIO_H) */
END_OF_FILE
if test 4900 -ne `wc -c <'stdio.h'`; then
    echo shar: \"'stdio.h'\" unpacked with wrong size!
fi
# end of 'stdio.h'
fi
if test -f 'stdlib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stdlib.h'\"
else
echo shar: Extracting \"'stdlib.h'\" \(5644 characters\)
sed "s/^X//" >'stdlib.h' <<'END_OF_FILE'
X/* This is a <stdlib.h> fix file which can be used either for older UN*X
X   systems (e.g. SunOS 4.0, System V.3, and ULTRIX 3.x) which don't have
X   their own <stdlib.h> file or for newer systems (e.g. SunOS 4.1) which
X   have incomplete or slightly non-standard <stdlib.h> files.
X
X   (Note that <stdlib.h> is required (by the ANSI C standard) to be present
X   for a "hosted" C implementation.)
X
X   Note that SunOS 4.1, System V.4, and Ultrix 4.x each have a <stdlib.h>
X   file, so I guess that progress is being made towards ANSI-C conformance.
X
X   This file should always be installed in the special GNU include directory.
X   Even if your system already has its own <stdlib.h> file, having this file
X   in the GNU include directory should cause no particular harm.
X
X   The contents of this file are based upon specifications given in the
X   ANSI C standard (a public document).  It is believed that the material
X   contained herein is therefore non-copyrighted and non-copyrightable.
X*/
X
X#ifndef _GNU_STDLIB_H
X#define _GNU_STDLIB_H
X
X#define atof ___atof
X#define atoi ___atoi
X#define atol ___atol
X#define strtod ___strtod
X#define strtol ___strtol
X#define strtoul ___strtoul
X#define rand ___rand
X#define srand ___srand
X#define calloc ___calloc
X#define free ___free
X#define malloc ___malloc
X#define realloc ___realloc
X#define abort ___abort
X#define atexit ___atexit
X#define exit ___exit
X#define getenv ___getenv
X#define system ___system
X#define bsearch ___bsearch
X#define qsort ___qsort
X#define abs ___abs
X#define div ___div
X#define labs ___labs
X#define ldiv ___ldiv
X/* #define mblen ___mblen */
X#define mbtowc ___mbtowc
X#define wctomb ___wctomb
X#define mbstowcs ___mbstowcs
X#define wcstombs ___wcstombs
X#undef atof
X#undef atoi
X#undef atol
X#undef strtod
X#undef strtol
X#undef strtoul
X#undef rand
X#undef srand
X#undef calloc
X#undef free
X#undef malloc
X#undef realloc
X#undef abort
X#undef atexit
X#undef exit
X#undef getenv
X#undef system
X#undef bsearch
X#undef qsort
X#undef abs
X#undef div
X#undef labs
X#undef ldiv
X/* #undef mblen */
X#undef mbtowc
X#undef wctomb
X#undef mbstowcs
X#undef wcstombs
X
X#ifndef _SIZE_T
X#ifndef _T_SIZE
X#ifndef __SIZE_T
X#ifndef _SIZE_T_
X#ifndef ___int_size_t_h
X#define _SIZE_T
X#define _T_SIZE
X#define __SIZE_T
X#define _SIZE_T_
X#define ___int_size_t_h
Xtypedef unsigned long size_t;   /* GCC likes size_t to be unsigned long */
X#endif /* ___int_size_t_h */
X#endif /* _SIZE_T_ */
X#endif /* __SIZE_T */
X#endif /* _T_SIZE */
X#endif /* _SIZE_T */
X
X#ifndef _WCHAR_T
X#ifndef _T_WCHAR
X#ifndef __WCHAR_T
X#ifndef _WCHAR_T_
X#ifndef ___int_wchar_t_h
X#define _WCHAR_T
X#define _T_WCHAR
X#define __WCHAR_T
X#define _WCHAR_T_
X#define ___int_wchar_t_h
X
X#ifdef ultrix
Xtypedef unsigned char wchar_t;          /* Correct for Ultrix 4.0 */
X#else
X#ifdef sun
Xtypedef unsigned short wchar_t;         /* Correct for SunOS 4.1 */
X#else
Xtypedef long wchar_t;                   /* Correct for System V.4 */
X#endif
X#endif
X
X#endif /* ___int_wchar_t_h */
X#endif /* _WCHAR_T_ */
X#endif /* __WCHAR_T */
X#endif /* _T_WCHAR */
X#endif /* _WCHAR_T */
X
X/* If we got _STDLIB_H or _STDLIB_H_ defined, then we probably are on
X   a System V.4 system or on an Ultrix 4.0 system (respectively) so the
X   types div_t and ldiv_t have been defined already by the "native"
X   system <stdlib.h> file.
X*/
X
X#if !defined (_STDLIB_H) && !defined(_STDLIB_H_)
X
Xtypedef	struct {
X	 int	quot;
X	 int	rem;
X	} div_t;
X
Xtypedef struct {
X	 long	quot;
X	 long	rem;
X	} ldiv_t;
X
X#endif /* !defined(_STDLIB_H) && !defined(_STDLIB_H_) */
X
X#undef NULL		/* in case <stdio.h> has defined it. */
X#ifdef __STDC__
X#define NULL ((void *)0)
X#else
X#define NULL 0
X#endif
X
X#ifndef EXIT_FAILURE
X#define EXIT_FAILURE 1
X#endif
X
X#ifndef EXIT_SUCCESS
X#define EXIT_SUCCESS 0
X#endif
X
X#ifndef RAND_MAX
X#define RAND_MAX	32767
X#endif
X
X#ifndef MB_CUR_MAX
X/* Use 1 for lack of a better value.  */
X#define MB_CUR_MAX	1
X#endif
X
X#ifdef __STDC__
X#define __(x) x
X#else
X#define __(x) ()
X#endif
X
Xextern double atof __((const char *__nptr));
Xextern int atoi __((const char *__nptr));
Xextern long int atol __((const char *__nptr));
Xextern double strtod __((const char *__nptr, char **__endptr));
Xextern long int strtol __((const char *__nptr, char **__endptr, int __base));
Xextern unsigned long int strtoul __((const char *__nptr, char **__endptr, int __base));
X
Xextern int rand __((void));
Xextern void srand __((unsigned int __seed));
X
Xextern char *calloc __((size_t __nmemb, size_t __size));
Xextern void free __((void *__ptr));
Xextern char *malloc __((size_t __size));
Xextern char *realloc __((void *__ptr, size_t __size));
X
Xextern void abort __((void));
Xextern int atexit __((void (*__func)(void)));
Xextern void exit __((int __status));
Xextern char *getenv __((const char *__name));
Xextern int system __((const char *__string));
X
Xextern void *bsearch __((const void *__key, const void *__base,
X			 size_t __nmemb, size_t __size,
X			 int (*__compar)(const void *, const void *)));
Xextern void qsort __((void *__base, size_t __nmemb, size_t __size,
X		      int (*__compar)(const void *, const void *)));
X
Xextern int abs __((int __j));
Xextern div_t div __((int __numer, int __denom));
Xextern long int labs __((long int __j));
Xextern ldiv_t ldiv __((long int __numer, long int __denom));
X
X/* NOTE: SunOS 4.1 defines mblen as a macro.  */
X
X#ifndef mblen
Xextern int mblen __((const char *__s, size_t __n));
X#endif
Xextern int mbtowc __((wchar_t *__pwc, const char *__s, size_t __n));
Xextern int wctomb __((char *__s, wchar_t __wchar));
X
Xextern size_t mbstowcs __((wchar_t *__pwcs, const char *__s, size_t __n));
Xextern size_t wcstombs __((char *__s, const wchar_t *__pwcs, size_t __n));
X
X#undef __
X
X#endif 	/* !defined __((_GNU_STDLIB_H) */
END_OF_FILE
if test 5644 -ne `wc -c <'stdlib.h'`; then
    echo shar: \"'stdlib.h'\" unpacked with wrong size!
fi
# end of 'stdlib.h'
fi
if test -f 'string.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'string.h'\"
else
echo shar: Extracting \"'string.h'\" \(787 characters\)
sed "s/^X//" >'string.h' <<'END_OF_FILE'
X#ifndef		__STDC__
X# include	"/usr/include/string.h"
X#else
X
X#sccs	"@(#)inchead:string.h	1.3"
X
X/*	Convergent Technologies - System V - May 1983	*/
X
Xchar           *strcat (char *a, char *b);
Xchar           *strchr (char *a, int b);
Xint             strcmp (char *a, char *b);
Xint             strcasecmp (char *a, char *b);
Xchar           *strcpy (char *a, char *b);
Xint             strcspn (char *a, char *b);
Xint             strlen (char *s);
Xchar           *strncat (char *a, char *b, int n);
Xint             strncmp (char *a, char *b, int n);
Xchar           *strncpy (char *a, char *b, int n);
Xchar           *strpbrk (char *a, char *b);
Xchar           *strrchr (char *a, int b);
Xint             strspn (char *a, char *b);
Xchar           *strtok (char *a, char *b);
X
X#endif	/*__STDC__*/
END_OF_FILE
if test 787 -ne `wc -c <'string.h'`; then
    echo shar: \"'string.h'\" unpacked with wrong size!
fi
# end of 'string.h'
fi
if test ! -d 'sys' ; then
    echo shar: Creating directory \"'sys'\"
    mkdir 'sys'
fi
if test -f 'sys/file.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/file.h'\"
else
echo shar: Extracting \"'sys/file.h'\" \(984 characters\)
sed "s/^X//" >'sys/file.h' <<'END_OF_FILE'
X/* According to the ANSI-C standard, an unprototyped declaration of a
X   function may not preceed or follow a prototyped declaration of that
X   same function if the prototype for the function includes an ellipsis.
X
X   In order to avoid running afowl of this rule, this file is provided
X   for use with the GNU C compiler when it is installed on an Ultrix 4.1
X   system.
X
X   This file may be used with the GNU C compiler and may be placed into the
X   GNU_LIBDIR/gcc-include directory.  GCC will then use it instead of your
X   system's own native <sys/file.h> file.
X
X   This file includes your native <sys/file.h> file and then makes sure that
X   a proper prototype for the `open' function is provided.
X*/
X
X#ifndef _GNU_SYS_FILE_H
X#define _GNU_SYS_FILE_H
X
X#define open ___open
X#include </usr/include/sys/file.h>
X#undef open
X
X#ifdef __STDC__
X#define __(x) x
X#else
X#define __(x) ()
X#endif
X
Xextern int open __((const char *, int, ...));
X
X#undef __
X
X#endif /* !defined (_GNU_SYS_FILE_H) */
END_OF_FILE
if test 984 -ne `wc -c <'sys/file.h'`; then
    echo shar: \"'sys/file.h'\" unpacked with wrong size!
fi
# end of 'sys/file.h'
fi
if test -f 'sys/stat.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/stat.h'\"
else
echo shar: Extracting \"'sys/stat.h'\" \(1075 characters\)
sed "s/^X//" >'sys/stat.h' <<'END_OF_FILE'
X#ifndef		__STDC__
X# include	"/usr/include/sys/stat.h"
X#else
X
X#sccs	"@(#)uts/kern/sys:stat.h	1.1"
X
X/*	Convergent Technologies - System V - May 1983	*/
X
X#ifndef stat_h
X#define stat_h
X
X#include <sys/types.h>
X
X/*
X * Structure of the result of stat
X */
X
Xstruct	stat
X{
X	dev_t	st_dev;
X	ino_t	st_ino;
X	ushort 	st_mode;
X	short  	st_nlink;
X	ushort 	st_uid;
X	ushort 	st_gid;
X	dev_t	st_rdev;
X	off_t	st_size;
X	time_t	st_atime;
X	time_t	st_mtime;
X	time_t	st_ctime;
X};
X
X#define	S_IFMT	0170000		/* type of file */
X#define		S_IFDIR	0040000	/* directory */
X#define		S_IFCHR	0020000	/* character special */
X#define		S_IFBLK	0060000	/* block special */
X#define		S_IFREG	0100000	/* regular */
X#define		S_IFIFO	0010000	/* fifo */
X#define	S_ISUID	04000		/* set user id on execution */
X#define	S_ISGID	02000		/* set group id on execution */
X#define	S_ISVTX	01000		/* save swapped text even after use */
X#define	S_IREAD	00400		/* read permission, owner */
X#define	S_IWRITE	00200		/* write permission, owner */
X#define	S_IEXEC	00100		/* execute/search permission, owner */
X
X#endif
X
X#endif	/*__STDC__*/
END_OF_FILE
if test 1075 -ne `wc -c <'sys/stat.h'`; then
    echo shar: \"'sys/stat.h'\" unpacked with wrong size!
fi
# end of 'sys/stat.h'
fi
if test -f 'sys/types.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys/types.h'\"
else
echo shar: Extracting \"'sys/types.h'\" \(1970 characters\)
sed "s/^X//" >'sys/types.h' <<'END_OF_FILE'
X/* This file is provided for the sake of older UN*X systems which do an
X   unprotected typedef of size_t within their <sys/types.h> file (e.g.
X   System V.3, SunOS 4.0, Ultrix 3.x, etc.
X
X   There are two problems with the typedefs within the <sys/types.h> file
X   in these older systems.
X
X   First, they are not protected by #ifdef _SIZE_T as they should be.  This
X   fact can lead to conflicts with other typedef's of size_t which must
X   also be present in other "system" include files (e.g. <stdlib.h>).
X
X   Second, for the GNU C compiler, the type size_t needs to be typedef'd
X   as `unsigned long' so that prototypes of functions like __builtin_memcpy
X   will match up correctly with GCC's own internal idea of the prototypes
X   for these builtin functions.
X
X   This file helps to overcome both problems.
X*/
X
X#ifndef _GNU_SYS_TYPES_H
X#define _GNU_SYS_TYPES_H
X
X#define size_t ___size_t
X#define wchar_t ___wchar_t
X#include </usr/include/sys/types.h>
X#undef size_t
X#undef wchar_t
X
X#ifndef _SIZE_T
X#ifndef _T_SIZE
X#ifndef __SIZE_T
X#ifndef _SIZE_T_
X#ifndef ___int_size_t_h
X#define _SIZE_T
X#define _T_SIZE
X#define __SIZE_T
X#define _SIZE_T_
X#define ___int_size_t_h
Xtypedef unsigned long size_t;   /* GCC likes size_t to be unsigned long */
X#endif /* ___int_size_t_h */
X#endif /* _SIZE_T_ */
X#endif /* __SIZE_T */
X#endif /* _T_SIZE */
X#endif /* _SIZE_T */
X
X#ifndef _WCHAR_T
X#ifndef _T_WCHAR
X#ifndef __WCHAR_T
X#ifndef _WCHAR_T_
X#ifndef ___int_wchar_t_h
X#define _WCHAR_T
X#define _T_WCHAR
X#define __WCHAR_T
X#define _WCHAR_T_
X#define ___int_wchar_t_h
X
X#ifdef ultrix
Xtypedef unsigned char wchar_t;          /* Correct for Ultrix 4.0 */
X#else
X#ifdef sun
Xtypedef unsigned short wchar_t;         /* Correct for SunOS 4.1 */
X#else
Xtypedef long wchar_t;                   /* Correct for System V.4 */
X#endif
X#endif
X
X#endif /* ___int_wchar_t_h */
X#endif /* _WCHAR_T_ */
X#endif /* __WCHAR_T */
X#endif /* _T_WCHAR */
X#endif /* _WCHAR_T */
X
Xtypedef int uid_t;
Xtypedef int gid_t;
X
X#endif
END_OF_FILE
if test 1970 -ne `wc -c <'sys/types.h'`; then
    echo shar: \"'sys/types.h'\" unpacked with wrong size!
fi
# end of 'sys/types.h'
fi
if test -f 'time.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'time.h'\"
else
echo shar: Extracting \"'time.h'\" \(596 characters\)
sed "s/^X//" >'time.h' <<'END_OF_FILE'
X#ifndef		__STDC__
X# include	"/usr/include/time.h"
X#else
X
X#sccs	"@(#)inchead:time.h	1.1"
X
X/*	Convergent Technologies - System V - May 1983	*/
X
Xstruct	tm {	/* see ctime(3) */
X	int	tm_sec;
X	int	tm_min;
X	int	tm_hour;
X	int	tm_mday;
X	int	tm_mon;
X	int	tm_year;
X	int	tm_wday;
X	int	tm_yday;
X	int	tm_isdst;
X};
X
Xlong            time (long *t);
Xchar           *ctime (long *t);
Xstruct tm      *localtime (long *c);
Xstruct tm      *gmtime (long *c);
Xchar           *asctime (struct tm * t);
Xvoid            tzset (void);
X
Xextern long timezone;
Xextern int daylight;
Xextern char *tzname[];
X
X#endif	/*__STDC__*/
END_OF_FILE
if test 596 -ne `wc -c <'time.h'`; then
    echo shar: \"'time.h'\" unpacked with wrong size!
fi
# end of 'time.h'
fi
if test -f 'unistd.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'unistd.h'\"
else
echo shar: Extracting \"'unistd.h'\" \(3954 characters\)
sed "s/^X//" >'unistd.h' <<'END_OF_FILE'
X/* According to the POSIX standard, most of the functions declared in this
X   file should be declared in <unistd.h>, but on some older versions of UN*X,
X   the native <unistd.h> file fails to declare any functions at all.
X
X   This file may be used with the GNU C compiler and may be placed into the
X   GNU_LIBDIR/gcc-include directory.  GCC will then use it instead of your
X   system's own native <unistd.h> file.
X
X   This file includes your system's own native <unistd.h> file (if your
X   system has one) and then makes sure that all functions which POSIX
X   requires to be declared within <unistd.h> are in fact declared (here).
X*/
X
X#ifndef _GNU_UNISTD_H
X#define _GNU_UNISTD_H
X
X#define execl ___execl
X#define execlp ___execlp
X#define execle ___execle
X#include </usr/include/unistd.h>
X#undef execl
X#undef execlp
X#undef execle
X
X#ifdef __STDC__
X#define __(x) x
X#else
X#define __(x) ()
X#endif
X
X#define __Pid_t int
X#define __Uid_t int
X#define __Gid_t int
X#define __Off_t long
X
Xstruct stat;
X
Xextern int access __((const char *, int));
Xextern unsigned alarm __((unsigned));
Xextern int brk __((void *));
Xextern int chdir __((const char *));
Xextern int chmod __((const char *, int));
Xextern int chown __((const char *, __Uid_t, __Gid_t));
Xextern int chroot __((const char *));
Xextern int close __((int));
Xextern char *ctermid __((char *));
Xextern char *cuserid __((char *));
Xextern int dup __((int));
Xextern int dup2 __((int, int));
Xextern int execl __((const char *, const char *, ...));
Xextern int execle __((const char *, const char *, ...));
Xextern int execlp __((const char *, const char *, ...));
Xextern int execv __((const char *, char *const *));
Xextern int execve __((const char *, char *const *, char *const *));
Xextern int execvp __((const char *, char *const *));
Xextern void exit __((int));
Xextern void _exit __((int));
Xextern __Pid_t fork __((void));
Xextern long fpathconf __((int, int));
Xextern int fstat __((int, struct stat *));
Xextern char *getcwd __((char *, int));
Xextern gid_t getegid __((void));
Xextern uid_t geteuid __((void));
Xextern gid_t getgid __((void));
Xextern int getgroups __((int, __Gid_t *));
Xextern char *getlogin __((void));
Xextern __Pid_t getpgid __((__Pid_t));
Xextern __Pid_t getpid __((void));
Xextern __Pid_t getppid __((void));
Xextern __Pid_t getpgrp __((void));
Xextern uid_t getuid __((void));
X#ifdef sun
Xextern char *getwd  __((char *));
X#endif
Xextern int ioctl __((int, int, ...));
Xextern int isatty __((int));
Xextern int kill __((__Pid_t, int));
Xextern int link __((const char *, const char *));
Xextern int lchown __((const char *, __Uid_t, __Gid_t));
Xextern off_t lseek __((int, __Off_t, int));
Xextern int nice __((int));
Xextern int open __((const char *, int, ...));
Xextern long int pathconf __((char *, int));
Xextern int pause __((void));
Xextern int pipe __((int *));
Xextern void profil __((unsigned short *, unsigned int, unsigned int, unsigned int));
Xextern int ptrace __((int, __Pid_t, int, int));
Xextern int read __((int, void *, unsigned));
Xextern int readlink __((const char *, void *, int));
Xextern int rename __((const char *, const char *));
Xextern int rmdir __((const char *));
Xextern void *sbrk __((int));
Xextern int setgid __((__Gid_t));
Xextern int setpgid __((__Pid_t, __Pid_t));
Xextern __Pid_t setpgrp __((void));
Xextern __Pid_t setsid __((void));
Xextern int setuid __((__Uid_t));
Xextern unsigned sleep __((unsigned));
Xextern int stat __((const char *, struct stat *));
Xextern int symlink __((const char *, const char *));
Xextern void sync __((void));
Xextern long sysconf __((int));
Xextern __Pid_t tcgetpgrp __((int));
Xextern int tcsetpgrp __((int, __Pid_t));
Xextern int truncate __((const char *, __Off_t));
Xextern char *ttyname __((int));
Xextern int unlink __((const char *));
Xextern __Pid_t vfork __((void));
Xextern int wait __((int *));
Xextern int write __((int, const void *, unsigned));
X
X#undef __
X#undef __Uid_t
X#undef __Gid_t
X#undef __Pid_t
X#undef __Off_t
X
X#endif /* !defined(_GNU_UNISTD_H) */
END_OF_FILE
if test 3954 -ne `wc -c <'unistd.h'`; then
    echo shar: \"'unistd.h'\" unpacked with wrong size!
fi
# end of 'unistd.h'
fi
if test -f 'va-i860.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'va-i860.h'\"
else
echo shar: Extracting \"'va-i860.h'\" \(1616 characters\)
sed "s/^X//" >'va-i860.h' <<'END_OF_FILE'
X#ifndef _VA_LIST
X#define _VA_LIST
Xstruct __va_struct { int fixed[12]; int floating[8]; };
X
Xtypedef struct __va_ctl
X{
X  struct __va_struct *__regs;
X  void *__stack;
X  int __nfixed, __nfloating;
X} va_list;
X#endif /* _VA_LIST */
X
X#define va_alist
X
X#define va_dcl
X
X#define va_start(pvar) \
X (memcpy (&(pvar), (struct __va_ctl *) __builtin_saveregs (), 16))
X#define va_end(pvar)
X
X#define va_arg(pvar,type)					\
X({ type __va_temp;						\
X   *((__builtin_classify_type (__va_temp) < 8			\
X      && sizeof __va_temp < 8)					\
X     ? ((pvar).__nfixed < 12					\
X	? (type *) &(pvar).__regs->fixed[(pvar).__nfixed++]	\
X	: ({							\
X	     int temp						\
X	       = ((int) ((pvar).__stack + __alignof__ (type) - 1) \
X		  & ~(__alignof__ (type) - 1));			\
X	     (pvar).__stack = (void *) (temp + sizeof (type));	\
X	     (type *) temp; 					\
X	   }))							\
X     : __builtin_classify_type (__va_temp) < 9			\
X     ? ((pvar).__nfloating < 8					\
X	? ((pvar).__nfloating					\
X	     = (((pvar).__nfloating + 2 * (sizeof __va_temp / 4) - 1) \
X		& ~(sizeof __va_temp / 4 - 1)),			\
X	   (type *) &(pvar).__regs->floating[(pvar).__nfloating - (sizeof __va_temp / 4)]) \
X	: ({							\
X	     int temp						\
X	       = ((int) ((pvar).__stack + __alignof__ (type) - 1) \
X		  & ~(__alignof__ (type) - 1));			\
X	     (pvar).__stack = (void *) (temp + sizeof (type));	\
X	     (type *) temp; 					\
X	   }))							\
X     : ({							\
X	  int temp						\
X	    = ((int) ((pvar).__stack + __alignof__ (type) - 1)	\
X	       & ~(__alignof__ (type) - 1));			\
X	  (pvar).__stack = (void *) (temp + sizeof (type));	\
X	  (type *) temp; 					\
X	})); })
END_OF_FILE
if test 1616 -ne `wc -c <'va-i860.h'`; then
    echo shar: \"'va-i860.h'\" unpacked with wrong size!
fi
# end of 'va-i860.h'
fi
if test -f 'va-mips.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'va-mips.h'\"
else
echo shar: Extracting \"'va-mips.h'\" \(940 characters\)
sed "s/^X//" >'va-mips.h' <<'END_OF_FILE'
X/* ---------------------------------------- */
X/*           VARARGS  for MIPS/GNU CC       */
X/*                                          */
X/*                                          */
X/*                                          */
X/*                                          */
X/* ---------------------------------------- */
X
X
X/* These macros implement traditional (non-ANSI) varargs
X   for GNU C.  */
X
X#define va_alist  __builtin_va_alist
X#define va_dcl    int __builtin_va_alist;
X#ifndef _VA_LIST_
X#define _VA_LIST_
X#define va_list   char *
X#endif
X
X#define va_start(AP)  AP = (char *) &__builtin_va_alist
X#define va_end(AP)
X
X#ifdef lint	/* complains about constant in conditional context */
X#define va_arg(list, mode) ((mode *)(list += sizeof(mode)))[-1]
X
X#else		/* !lint */
X#define va_arg(AP, mode) ((mode *)(AP = \
X	(char *) (sizeof(mode) > 4 ? ((int)AP + 2*8 - 1) & -8 \
X				   : ((int)AP + 2*4 - 1) & -4)))[-1]
X#endif		/* lint */
END_OF_FILE
if test 940 -ne `wc -c <'va-mips.h'`; then
    echo shar: \"'va-mips.h'\" unpacked with wrong size!
fi
# end of 'va-mips.h'
fi
if test -f 'va-pyr.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'va-pyr.h'\"
else
echo shar: Extracting \"'va-pyr.h'\" \(3136 characters\)
sed "s/^X//" >'va-pyr.h' <<'END_OF_FILE'
X/**
X *
X * 	Varargs for PYR/GNU CC
X *
X * WARNING -- WARNING -- DANGER
X *
X * The code in this file implements varargs for gcc on a pyr in
X * a way that is compatible with code compiled by the Pyramid Technology
X * C compiler.
X * As such, it depends strongly on the Pyramid conventions for
X * parameter passing.ct and indepenent implementation. 
X * These (somewhat bizarre) paramter-passing conventions are described
X * in the ``OSx Operating System Porting Guide''.
X * 
X * A quick summary is useful:
X * 12 of the 48 register-windowed regs available for
X * parameter passing.  Parameters of a function call that are eligible
X * to be passed in registers are assigned registers from TR0/PR0 onwards;
X * all other arguments are passed on the stack.
X * Structure and union parameters are *never* passed in registers,
X * even if they are small enough to fit.  They are always passed on
X * the stack.
X *
X * Double-sized parameters cannot be passed in TR11, because
X * TR12 is not used for passing parameters.  If, in the absence of this
X * rule, a double-sized param would have been passed in TR11,
X * that parameter is passed on the stack and no parameters are
X * passed in TR11.
X * 
X * It is only known to work for passing 32-bit integer quantities
X * (ie chars, shorts, ints/enums, longs), doubles, or pointers. 
X * Passing structures on a Pyramid via varargs is a loser.
X * Passing an object larger than 8 bytes on a pyramid via varargs may
X * also be a loser.
X * 
X */
X
X
X/*
X *  pointer to next stack parameter in __va_buf[0]
X *  pointer to next parameter register in __va_buf[1]
X *  Count of registers seen at __va_buf[2]
X *  saved pr0..pr11 in __va_buf[3..14]
X *  # of calls to va_arg (debugging) at __va_buf[15]
X */
X
Xtypedef void *__voidptr;
X#if 1
X
Xtypedef struct __va_regs {
X      __voidptr __stackp,__regp,__count;
X      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;
X  } __va_regs;
X
Xtypedef __va_regs __va_buf;
X#else
X
X/* __va_buf[0] = address of next arg passed on the stack
X   __va_buf[1] = address of next arg passed in a register
X   __va_buf[2] = register-# of next arg passed in a register
X*/
Xtypedef __voidptr(*__va_buf);
X
X#endif
X
X#define va_alist \
X  __va0,__va1,__va2,__va3,__va4,__va5,__va6,__va7,__va8,__va9,__va10,__va11, \
X  __builtin_va_alist
X
X#define va_dcl __voidptr va_alist;
X
X#define va_list __va_buf
X
X
X/* __asm ("rcsp %0" : "=r" ( _AP [0]));*/
X
X#define va_start(_AP)  \
X  _AP =  ((struct __va_regs) {						\
X   &(_AP.__pr0), (void*)&__builtin_va_alist, (void*)0,			\
X        __va0,__va1,__va2,__va3,__va4,__va5,				\
X	__va6,__va7,__va8,__va9,__va10,__va11})
X 
X  
X	 
X
X#define va_arg(_AP, _MODE)	\
X({__voidptr *__ap = (__voidptr*)&_AP;					\
X  register int __size = sizeof (_MODE);					\
X  register int __onstack =						\
X	  (__size > 8 || ( (int)(__ap[2]) > 11) ||			\
X	    (__size==8 && (int)(__ap[2])==11));				\
X  register int* __param_addr =  ((int*)((__ap) [__onstack]));		\
X									\
X  ((void *)__ap[__onstack])+=__size;					\
X    if (__onstack==0 || (int)(__ap[2])==11)				\
X      __ap[2]+= (__size >> 2);						\
X  *(( _MODE *)__param_addr);						\
X})
X
X#define va_end(_X)
END_OF_FILE
if test 3136 -ne `wc -c <'va-pyr.h'`; then
    echo shar: \"'va-pyr.h'\" unpacked with wrong size!
fi
# end of 'va-pyr.h'
fi
if test -f 'va-sparc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'va-sparc.h'\"
else
echo shar: Extracting \"'va-sparc.h'\" \(1361 characters\)
sed "s/^X//" >'va-sparc.h' <<'END_OF_FILE'
X/* This is just like the default gvarargs.h
X   except for differences decribed below.  */
X
X/* va_list is a structure instead of a char*.  */
Xtypedef struct __va_ctl
X{
X  char *__stack;   /* Current pointer for fetching args.  */
X  char *__beg;     /* Pointer to position of first saved register arg.  */
X} va_list;
X
X#define va_alist  __builtin_va_alist
X#define va_dcl    int __builtin_va_alist;
X
X/* The difference is to store the stack address in both components
X   instead of in AP itself.  */
X#define va_start(AP) 						\
X (__builtin_saveregs (),					\
X (AP).__beg = (AP).__stack = ((char *) &__builtin_va_alist))
X#define va_end(pvar)
X
X#define __va_rounded_size(TYPE)  \
X  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))
X
X/* The difference is that, for an aggregate that is not word-aligned,
X   we advance (pvar).__stack to the first non-reg slot.  */
X#define va_arg(pvar,TYPE)					\
X({ TYPE __va_temp;						\
X   ((__builtin_classify_type (__va_temp) < 12			\
X     || __alignof__ __va_temp >= 4)				\
X    ? ((pvar).__stack += __va_rounded_size (TYPE),		\
X       *((TYPE *) ((pvar).__stack - __va_rounded_size (TYPE))))	\
X    : ((((pvar).__stack - (pvar).__beg < 24)			\
X	? (pvar).__stack = (pvar).__beg + 24 : 0),		\
X       (pvar).__stack += __va_rounded_size (TYPE),		\
X       *((TYPE *) ((pvar).__stack - __va_rounded_size (TYPE)))));})
END_OF_FILE
if test 1361 -ne `wc -c <'va-sparc.h'`; then
    echo shar: \"'va-sparc.h'\" unpacked with wrong size!
fi
# end of 'va-sparc.h'
fi
if test -f 'va-spur.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'va-spur.h'\"
else
echo shar: Extracting \"'va-spur.h'\" \(1268 characters\)
sed "s/^X//" >'va-spur.h' <<'END_OF_FILE'
X/*  varargs.h for SPUR */
X
X/* NB.  This is NOT the definition needed for the new ANSI proposed
X   standard */
X 
X
Xstruct __va_struct { char __regs[20]; };
X
X#define va_alist __va_regs, __va_stack
X
X#define va_dcl struct __va_struct __va_regs; int __va_stack;
X
Xtypedef struct {
X    int __pnt;
X    char *__regs;
X    char *__stack;
X} va_list;
X
X#define va_start(pvar) \
X     ((pvar).__pnt = 0, (pvar).__regs = __va_regs.__regs, \
X      (pvar).__stack = (char *) &__va_stack)
X#define va_end(pvar)
X
X#define va_arg(pvar,type)  \
X    ({  type __va_result; \
X        if ((pvar).__pnt >= 20) { \
X           __va_result = *( (type *) ((pvar).__stack + (pvar).__pnt - 20)); \
X	   (pvar).__pnt += (sizeof(type) + 7) & ~7; \
X	} \
X	else if ((pvar).__pnt + sizeof(type) > 20) { \
X	   __va_result = * (type *) (pvar).__stack; \
X	   (pvar).__pnt = 20 + ( (sizeof(type) + 7) & ~7); \
X	} \
X	else if (sizeof(type) == 8) { \
X	   union {double d; int i[2];} __u; \
X	   __u.i[0] = *(int *) ((pvar).__regs + (pvar).__pnt); \
X	   __u.i[1] = *(int *) ((pvar).__regs + (pvar).__pnt + 4); \
X	   __va_result = * (type *) &__u; \
X	   (pvar).__pnt += 8; \
X	} \
X	else { \
X	   __va_result = * (type *) ((pvar).__regs + (pvar).__pnt); \
X	   (pvar).__pnt += (sizeof(type) + 3) & ~3; \
X	} \
X	__va_result; })
END_OF_FILE
if test 1268 -ne `wc -c <'va-spur.h'`; then
    echo shar: \"'va-spur.h'\" unpacked with wrong size!
fi
# end of 'va-spur.h'
fi
if test -f 'varargs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'varargs.h'\"
else
echo shar: Extracting \"'varargs.h'\" \(1402 characters\)
sed "s/^X//" >'varargs.h' <<'END_OF_FILE'
X#ifndef __GNUC__
X/* Use the system's macros with the system's compiler.  */
X#include <varargs.h>
X#else
X/* Record that varargs.h is defined; this turns off stdarg.h.  */
X
X#ifndef _VARARGS_H
X#define _VARARGS_H
X
X#ifdef __sparc__
X#include "va-sparc.h"
X#else
X#ifdef __spur__
X#include "va-spur.h"
X#else
X#ifdef __mips__
X#include "va-mips.h"
X#else
X#ifdef __i860__
X#include "va-i860.h"
X#else
X#ifdef __pyr__
X#include "va-pyr.h"
X#else
X
X#ifdef __NeXT__
X
X/* On Next, erase any vestiges of stdarg.h.  */
X
X#undef va_alist
X#undef va_dcl
X#undef va_list
X#undef va_start
X#undef va_end
X#undef __va_rounded_size
X#undef va_arg
X#endif  /* __NeXT__ */
X
X/* These macros implement traditional (non-ANSI) varargs
X   for GNU C.  */
X
X#define va_alist  __builtin_va_alist
X#define va_dcl    int __builtin_va_alist;
X#define va_list   char *
X
X#ifdef __sparc__
X#define va_start(AP) 						\
X (__builtin_saveregs (),					\
X  AP = ((void *) &__builtin_va_alist))
X#else
X#define va_start(AP)  AP=(char *) &__builtin_va_alist
X#endif
X#define va_end(AP)
X
X#define __va_rounded_size(TYPE)  \
X  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))
X
X#define va_arg(AP, TYPE)					\
X (*((TYPE *) (AP += __va_rounded_size (TYPE),			\
X	      AP - __va_rounded_size (TYPE))))
X
X#endif /* not pyr */
X#endif /* not i860 */
X#endif /* not mips */
X#endif /* not spur */
X#endif /* not sparc */
X#endif /* not _VARARGS_H */
X#endif /* __GNUC__ */
END_OF_FILE
if test 1402 -ne `wc -c <'varargs.h'`; then
    echo shar: \"'varargs.h'\" unpacked with wrong size!
fi
# end of 'varargs.h'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
David H. Brierley
Home: dave@galaxia.network23.com; Work: dhb@quahog.ssd.ray.com
Send comp.sources.3b1 submissions to comp-sources-3b1@galaxia.network23.com
%% Can I be excused, my brain is full. **
