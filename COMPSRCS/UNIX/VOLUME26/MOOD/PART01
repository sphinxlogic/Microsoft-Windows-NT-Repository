Newsgroups: comp.sources.unix
From: quanstro@stolaf.edu (goon)
Subject: v26i118: mood - social programs including rwhod, rwho replacements, Part01/01
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: quanstro@stolaf.edu (goon)
Posting-Number: Volume 26, Issue 118
Archive-Name: mood/part01

Mood 0.92a --- a collection of "social" programs. 

     This was compiled on a SPARC running SunOS 4.1.2, VAX running
     XINU Unix, and a NeXT running NeXTOS 2.1. I make no claims about
     portability of these programs to other systems. If you have a bug
     fix please mail me at quanstro@stolaf.edu. I will endevour to
     answer all questions promptly but can make no promises that all
     bugs will actually be fixed. (How I wish I could!)

     * what is a mood? A mood is whatever one want's it to be. For
     example, on my system, these were the moods on 2. Feb 1992:
     [moberg  ]  Jennie is feeling that life is wonderful.
     [knobel  ]  Laura is butt sore from her 2nd big
                 bike ride of the season . . . Oh where are all
                 those wonderful backrubs when you need them???
                 Curse interim break!  *sigh*
     [...]

     * fmood: gets other user's moods and displays them in various and
     sundry formats. (there is a shell script which is installed by
     make install which can be useful if fmood is not compiled for a
     particular architecture)

     * daemon: this is the daemon for doing remote moods. Mood is
     perfectly happy attempting to connect to a remote mood server
     with the constructs "mood dek@foo.bar.com" or "mood
     dek@131.21.3.1". 

     * ffriends: prints out the log in names of your "friends" (the
     people whose login names appear in ~/.friends. (There is also a
     slower shell-script version which provides more information but
     this verbose output is harder to manipulate and to format to
     one's own liking)

     * theirmail: reports on the status of other user's mailboxes.

     * geeks: reports on the ten geekiest people on the system (by
     number of hours logged in)

     * in.rwhod: the daemon for my implementation of rwho. This
     implemenation is minimally 2n! faster than Berkeley rwho and is
     noticablly faster than finger (1) even on a SPARC II. 

     When run with the command like `-c <server>' then in.rwhod does
     the client thing, reporting when necessary back to the server.
     When run without these options, in.rwhod does the server thing
     collecting information from clients and responding to queries. 

     * rwho: the user-level interface to the in.rwhod server.
     typical output looks like
     [mari.acc.stolaf]  quanstro ttyp3    (loki4.cs.stolaf.)
     [mari.acc.stolaf]  quanstro ttyp4    (loki4.cs.stolaf.)
     [mari.acc.stolaf]  tremlh   ttyp5    (g-atalk2.atalk.s)
     [mari.acc.stolaf]  matgress ttyp6    (xyplex1.stolaf.e)
     [mari.acc.stolaf]  fritchie ttyp8    (spare2.acc.stola)
     [asgaard.acc.sto]  gruetzne ttyp0    (131.234.128.231 )
     [asgaard.acc.sto]  tremlh   ttyp1    (g-atalk2.atalk.s)

     * rw: a reformatter for rwho output. Typical output looks like
     [mari.acc.stolaf] schultej quanstro quanstro quanstro quanstro
                       tremlh matgress fritchie
     [asgaard.acc.sto] gruetzne tremlh math12c fritchie
     [newton.acc.stol] quanstro

Have fun and happy hacking!

	quanstro@stolaf.edu (goon, ewq)

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  ChangeLog MANIFEST Makefile README TODO UNSHAR.HDR
#   daemon.8 daemon.c ffriends.1 ffriends.c fmood.1 fmood.c friends.1
#   friends.5 friends.d geeks.1 geeks.d hist in.rwhod.8 in.rwhod.c
#   mitime.d mood.1 mood.d moodmail.1 moodmail.d rfriends.d rw.1 rw.d
#   rwho.1 rwho.c theirmail.1 theirmail.d
# Wrapped by vixie@gw.home.vix.com on Sat Apr 10 00:55:12 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ChangeLog' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ChangeLog'\"
else
echo shar: Extracting \"'ChangeLog'\" \(328 characters\)
sed "s/^X//" >'ChangeLog' <<'END_OF_FILE'
Thu May 21 20:27:34 1992  Erik Quanstrom  (quanstro at newton.acc.stolaf.edu)
X
X	* in.rwhod: fixed a fencepost error in the client. Did some more
X	code housecleaning.
X
Wed Apr 29 16:34:17 1992  Erik Quanstrom  (quanstro at asgaard.acc.stolaf.edu)
X
X	* in.rwhod: fixed race the client_wait function. Did some
X	code-housecleaning.
X
END_OF_FILE
if test 328 -ne `wc -c <'ChangeLog'`; then
    echo shar: \"'ChangeLog'\" unpacked with wrong size!
fi
# end of 'ChangeLog'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1106 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X ChangeLog                  1	
X MANIFEST                   1	This shipping list
X Makefile                   1	
X README                     1	
X TODO                       1	
X UNSHAR.HDR                 1	
X daemon.8                   1	
X daemon.c                   1	
X ffriends.1                 1	
X ffriends.c                 1	
X fmood.1                    1	
X fmood.c                    1	
X friends.1                  1	
X friends.5                  1	
X friends.d                  1	
X geeks.1                    1	
X geeks.d                    1	
X hist                       1	
X in.rwhod.8                 1	
X in.rwhod.c                 1	
X mitime.d                   1	
X mood.1                     1	
X mood.d                     1	
X moodmail.1                 1	
X moodmail.d                 1	
X rfriends.d                 1	
X rw.1                       1	
X rw.d                       1	
X rwho.1                     1	
X rwho.c                     1	
X theirmail.1                1	
X theirmail.d                1	
END_OF_FILE
if test 1106 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(5199 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#########################################################################
X# file:		Makefile for the mood program suite			#
X#									#
X# Object:	be social						#
X# 									#
X# Version:	.50							#
X#									#
X# Erik Quanstrom							#
X# 9. Januar 1992							#
X#########################################################################
X# here is where you start modifying the makefile
X
X# this should be the "root" of the project. This directory normally
X# contains the subdirs bin, man and lib. But where the files end up is 
X# determined by following paramaters.
X#ROOT		=	/usr/local
ROOT		=	/home/accserv1/stub/e/quanstro
X
X# ROOT_SH is just an escaped version of $(ROOT). These _must_ be the 
X# same and because of the quoting wierdness of the shell, double
X# slashes are required.
X#ROOT_SH  		=	\\/usr\\/local
ROOT_SH 		=	\\/home\\/accserv1\\/stub\\/e\\/quanstro
X
X# this is the directory where the binaries go.
X#BIN_DIR	=	$(ROOT)/bin
X#BIN_DIR 	=	$(ROOT)/SPARCbin
X#BIN_DIR 	=	$(ROOT)/SUN3bin
X#BIN_DIR  	=	$(ROOT)/NeXTbin
BIN_DIR  	=	$(ROOT)/VAXbin
X
X# this is the directory where the executable shell scripts go.
BIN_SH_DIR	=	$(ROOT)/bin
X
X# this is where the man files go. We are expecting to have at least
X# the subdirectories man1 man5 and man8. 
MAN_DIR		=	$(ROOT)/man
X
X# this is the file which daemon exec's to find the mood of a user
X# when querried by a remote host. Other possibilities are mood, but 
X# this will be slower
X#EXEC_FILE	=	"\"$(ROOT)/bin/fmood\""
X#EXEC_FILE	=	"\"$(ROOT)/SPARCbin/fmood\""
X#EXEC_FILE	=	"\"$(ROOT)/SUN3bin/fmood\""
X#EXEC_FILE	=	"\"$(ROOT)/NeXTbin/fmood\""
XEXEC_FILE	=	"\"$(ROOT)/VAXbin/fmood\""
X
X# This is the default rwho server. I suggest that a NIS alias be set
X# up so that the local server can be referenced by the name
X# "rwhoserv." Sometimes it is convienient to specify the full domain
X# as well. Numbers are generally a bad idea because you really don't
X# want to recompile this thing if you change ip numbers. (This seems
X# like a bug to me, but probablly won't get fixed right away)
X#DEFAULT_SERV	=	"\"rwhoserv.stolaf.edu\""
DEFAULT_SERV	=	"\"mari.acc.stolaf.edu\""
X
X# set the parms for the shell files
X
X# this is where the mail on your system resides
MAIL_DIR	=	\\/usr\\/spool\\/mail
X
X# this is where the list of "mooders<" for moodmail resides
MOODERS		=	$(ROOT_SH)\\/lib\\/mooders
X
X# and this is the path for shell scripts. I have the SPARCbin in
X# there, because I work in a hetrogenious environment. This means that
X# I am faced with several sets of executables. If this program is
X# going to be intstalled in /usr/local/bin or some other standars
X# place, there is nothing to worry about, but if not, then it would be
X# wise to edit this to perhaps read `/bin/arch` instead of $h.
X# ($h := $(ROOT))
PATH		=	$h/SPARCbin:/bin:/usr/bin:/usr/ucb:/usr/local/bin
SH_PATH		= 	\\$$h\\/SPARCbin:\/bin:\\/usr\\/bin:\\/usr\\/ucb:\\/usr\\/local\\/bin
X
X# finally: what CC are you using? It must be ANSII, because I make 
X# heavy use of prototypes, etc. I did all my work with GCC.
X#CC		=	gcc -g		# debug
CC		=	gcc -O4		# install
X
X# okay --- you can run make now
X
SH_SOURCE	=	geeks.d mood.d friends.d moodmail.d\
X			theirmail.d rw.d rfriends.d
SH_EXEC		=	geeks mood friends moodmail theirmail rw rfriends
C_SOURCE	=	daemon.c ffriends.c fmood.c in.rwhod.c rwho.c
MAN1_SOURCE	=	ffriends.1 fmood.1 friends.1 geeks.1 mood.1\
X			moodmail.1 theirmail.1 rw.1 rwho.1 
MAN5_SOURCE	=	friends.5
MAN8_SOURCE	=	daemon.8 in.rwhod.8
PROGRAM		=	daemon ffriends fmood in.rwhod rwho
X
X.SUFFIXES: .d $(.SUFFIXES)
X
ALL: $(PROGRAM) $(SH_EXEC)
X
daemon: daemon.c
X	$(CC) -DMOOD=$(EXEC_FILE) -o daemon daemon.c
X
fmood:  fmood.c
X	$(CC) -o fmood fmood.c
X
rwho:	rwho.c
X	$(CC) -DSERVER=$(DEFAULT_SERV) -o rwho rwho.c
X
ffriends: ffriends.c
X	$(CC) -o ffriends ffriends.c
X
in.rwhod: in.rwhod.c
X	$(CC) -o in.rwhod in.rwhod.c
X
rfriends friends geeks mood rw: rfriends.d friends.d geeks.d mood.d rw.d
X	@echo editing $@
X	@cp $@.d $@
X	@(echo '/^h=' ; echo 's/=.*/='$(ROOT_SH)'/';\
X	  echo '/^PATH=' ; echo 's/=.*/='$(SH_PATH)'/';\
X	  echo 'w' ; echo 'q') | ed $@ > /dev/null 2>&1
X	@chmod a+x $@
X
theirmail: theirmail.d
X	@echo editing $@
X	@cp $@.d $@
X	@(echo '/^h=' ; echo 's/=.*/='$(MAIL_DIR)'/';\
X	  echo '/^PATH=' ; echo 's/=.*/='$(SH_PATH)'/';\
X	  echo 'w' ; echo 'q') | ed $@ > /dev/null 2>&1
X	@chmod a+x $@
X
moodmail: moodmail.d
X	@echo editing $@
X	@cp $@.d $@
X	@(echo '/^h=' ; echo 's/=.*/='$(ROOT_SH)'/'; echo '/^mfile=';\
X	  echo 's/=.*/='$(MOODERS)'/';\
X	  echo '/^PATH=' ; echo 's/=.*/='$(SH_PATH)'/';\
X	  echo 'w' ; echo 'q') | ed $@ > /dev/null 2>&1
X	@chmod a+x $@;
X
X####
clean::
X	rm -f $(O_SOURCE) $(PROGRAM) $(SH_EXEC)
X
spotless: clean
X	rm -f $(C_SOURCE:.c=.c~) $(MAN1_SOURCE:.1=.1~)$(MAN5_SOURCE:.5=.5~)\
X	      $(MAN8_SOURCE:.8=.8~)
X
install: ALL install_man install_sh
X	-strip $(PROGRAM) ;\
X	   install -g staff -m 755 -o root $(PROGRAM) $(BIN_DIR)
X
install_sh:
X	-install -g staff -m 755 -o root $(SH_EXEC) $(BIN_SH_DIR)
X#	-ln -s $(BIN_SH_DIR)/friends $(BIN_SH_DIR)/rfriends
X	
install_man:
X	-install -g staff -m 644 -o root $(MAN5_SOURCE) $(MAN_DIR)/man5
X	-install -g staff -m 644 -o root $(MAN1_SOURCE) $(MAN_DIR)/man1
X	-install -g staff -m 644 -o root $(MAN8_SOURCE) $(MAN_DIR)/man8
END_OF_FILE
if test 5199 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(3994 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
Mood 0.90 --- a collection of "social" programs. 
X
X     This was compiled on a SPARC running SunOS 4.1.2, VAX running
X     XINU Unix, and a NeXT running NeXTOS 2.1. I make no claims about
X     portability of these programs to other systems. If you have a bug
X     fix please mail me at quanstro@stolaf.edu. I will endevour to
X     answer all questions promptly but can make no promises that all
X     bugs will actually be fixed. (How I wish I could!)
X
X     * what is a mood? A mood is whatever one want's it to be. For
X     example, on my system, these were the moods on 2. Feb 1992:
X     [moberg  ]  Jennie is feeling that life is wonderful.
X     [knobel  ]  Laura is butt sore from her 2nd big
X                 bike ride of the season . . . Oh where are all
X                 those wonderful backrubs when you need them???
X                 Curse interim break!  *sigh*
X     [percival]  Daniel is feeling it.  Yes, again.
X     [moore   ]  Michael is feeling lethargic.  Two days, 9 things.
X     [millerjl]  Jeffrey is feeling that lonliness, since it is
X                 everlasting, is actually the god which rules the
X                 universe.
X     [quanstro]  goon is feeling like ralphing, again.
X     [avelsgaa]  Sarah is feeling very hungry.  I think I will go
X                 bite Jeffery's big toe.
X     [knappenp]  Paul is feeling like the Magical Mister
X                 Mistoffiles.
X     [alannarm]  Alanna is feeling ...hmmm how do you i feel, pretty
X                 good, almost confident, and definitely kinky...
X                 the question is: is this a good thing???
X                 enstappy?
X     [jeff    ]  Jeff is feeling happy.  I feel happy.  I feel ...
X                 *bonk*
X     [andersow]  W is feeling like break is ending too soon........
X
X     * fmood: gets other user's moods and displays them in various and
X     sundry formats. (there is a shell script which is installed by
X     make install which can be useful if fmood is not compiled for a
X     particular architecture)
X
X     * daemon: this is the daemon for doing remote moods. Mood is
X     perfectly happy attempting to connect to a remote mood server
X     with the constructs "mood dek@foo.bar.com" or "mood
X     dek@131.21.3.1". 
X
X     * ffriends: prints out the log in names of your "friends" (the
X     people whose login names appear in ~/.friends. (There is also a
X     slower shell-script version which provides more information but
X     this verbose output is harder to manipulate and to format to
X     one's own liking)
X
X     * theirmail: reports on the status of other user's mailboxes.
X
X     * geeks: reports on the ten geekiest people on the system (by
X     number of hours logged in)
X
X     * in.rwhod: the daemon for my implementation of rwho. This
X     implemenation is minimally 2n! faster than Berkeley rwho and is
X     noticablly faster than finger (1) even on a SPARC II. 
X
X     When run with the command like `-c <server>' then in.rwhod does
X     the client thing, reporting when necessary back to the server.
X     When run without these options, in.rwhod does the server thing
X     collecting information from clients and responding to queries. 
X     
X     * rwho: the user-level interface to the in.rwhod server.
X     typical output looks like
X     [mari.acc.stolaf]  quanstro ttyp3    (loki4.cs.stolaf.)
X     [mari.acc.stolaf]  quanstro ttyp4    (loki4.cs.stolaf.)
X     [mari.acc.stolaf]  tremlh   ttyp5    (g-atalk2.atalk.s)
X     [mari.acc.stolaf]  matgress ttyp6    (xyplex1.stolaf.e)
X     [mari.acc.stolaf]  fritchie ttyp8    (spare2.acc.stola)
X     [asgaard.acc.sto]  gruetzne ttyp0    (131.234.128.231 )
X     [asgaard.acc.sto]  tremlh   ttyp1    (g-atalk2.atalk.s)
X	
X     * rw: a reformatter for rwho output. Typical output looks like
X     [mari.acc.stolaf] schultej quanstro quanstro quanstro quanstro
X                       tremlh matgress fritchie
X     [asgaard.acc.sto] gruetzne tremlh math12c fritchie
X     [newton.acc.stol] quanstro
X
Have fun and happy hacking!
X
ewq
END_OF_FILE
if test 3994 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'TODO' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TODO'\"
else
echo shar: Extracting \"'TODO'\" \(1123 characters\)
sed "s/^X//" >'TODO' <<'END_OF_FILE'
X-*- indented-text -*-
X
fmood:	 * control characters are passwd through. This is not a
X	 feature! In fact, this can really munge up terminals, etc.
X
X	 * fix formatting. Here several things need to be done. First
X	 double spacing (on account of newlines) should not happen.
X	 Second, tabs, should act more like tabs. Thirdly, newlines
X	 should act like newlines. 
X
X	 * should the moods be stored in a centeral repository? this
X	 would make lookups FAST. How should this work? Perhaps
X	 moodmail -a  could cache them? This would be an easy scheme
X	 to implement.
X
in.rwhod * how should this program handle domains? There are several
X	 options here, and it's not really clear which is the best.
X	 A single server could handle multiple domains, doing
X	 on-the-fly lookup. 
X
rwho:	 * server lookup: can this be done in a portable way? 
X
rw,
friends: * this is a problem because of the path settings. The
X	 wrong executable will come across the path first if you are
X	 on the wrong archetecture. :( This is rather a pain in the
X	 butt. I could have an arch environment variable, I think that
X	 is the ticket. (for _me_, at least)
END_OF_FILE
if test 1123 -ne `wc -c <'TODO'`; then
    echo shar: \"'TODO'\" unpacked with wrong size!
fi
# end of 'TODO'
fi
if test -f 'UNSHAR.HDR' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'UNSHAR.HDR'\"
else
echo shar: Extracting \"'UNSHAR.HDR'\" \(4918 characters\)
sed "s/^X//" >'UNSHAR.HDR' <<'END_OF_FILE'
Return-Path: news@stolaf.edu
Received: by cognition.pa.dec.com; id AA19501; Tue, 26 May 92 12:52:19 -0700
Received: by inet-gw-2.pa.dec.com; id AA21734; Tue, 26 May 92 12:50:03 -0700
Received: from relay1.UU.NET by rodan.UU.NET with SMTP (5.61/UUNET-mail-drop) id AA08927; Tue, 26 May 92 15:49:42 -0400
Received: from stolaf.edu (via nic.stolaf.edu) by relay1.UU.NET with SMTP (5.61/UUNET-internet-primary) id AA00390; Tue, 26 May 92 15:49:07 -0400
Received: from news.stolaf.edu by stolaf.edu (4.1/SMI-4.1)id AA13766; Tue, 26 May 92 14:48:23 CDT
Newsgroups: comp.sources.unix
Path: news.stolaf.edu!quanstro
XFrom: quanstro@stolaf.edu (goon)
Subject: mood-0.92a (includes complete rwho replacement)
Message-Id: <QUANSTRO.92May26144742@asgaard.StOlaf.edu>
Sender: news@stolaf.edu
Organization: St. Olaf College, Northfield, MN USA
Distribution: comp
Date: 26 May 92 14:47:42
Apparently-To: <comp-sources-unix@uunet.uu.net>
X
Mood 0.92a --- a collection of "social" programs. 
X
X     This was compiled on a SPARC running SunOS 4.1.2, VAX running
X     XINU Unix, and a NeXT running NeXTOS 2.1. I make no claims about
X     portability of these programs to other systems. If you have a bug
X     fix please mail me at quanstro@stolaf.edu. I will endevour to
X     answer all questions promptly but can make no promises that all
X     bugs will actually be fixed. (How I wish I could!)
X
X     * what is a mood? A mood is whatever one want's it to be. For
X     example, on my system, these were the moods on 2. Feb 1992:
X     [moberg  ]  Jennie is feeling that life is wonderful.
X     [knobel  ]  Laura is butt sore from her 2nd big
X                 bike ride of the season . . . Oh where are all
X                 those wonderful backrubs when you need them???
X                 Curse interim break!  *sigh*
X     [percival]  Daniel is feeling it.  Yes, again.
X     [moore   ]  Michael is feeling lethargic.  Two days, 9 things.
X     [millerjl]  Jeffrey is feeling that lonliness, since it is
X                 everlasting, is actually the god which rules the
X                 universe.
X     [quanstro]  goon is feeling like ralphing, again.
X     [avelsgaa]  Sarah is feeling very hungry.  I think I will go
X                 bite Jeffery's big toe.
X     [knappenp]  Paul is feeling like the Magical Mister
X                 Mistoffiles.
X     [alannarm]  Alanna is feeling ...hmmm how do you i feel, pretty
X                 good, almost confident, and definitely kinky...
X                 the question is: is this a good thing???
X                 enstappy?
X     [jeff    ]  Jeff is feeling happy.  I feel happy.  I feel ...
X                 *bonk*
X     [andersow]  W is feeling like break is ending too soon........
X
X     * fmood: gets other user's moods and displays them in various and
X     sundry formats. (there is a shell script which is installed by
X     make install which can be useful if fmood is not compiled for a
X     particular architecture)
X
X     * daemon: this is the daemon for doing remote moods. Mood is
X     perfectly happy attempting to connect to a remote mood server
X     with the constructs "mood dek@foo.bar.com" or "mood
X     dek@131.21.3.1". 
X
X     * ffriends: prints out the log in names of your "friends" (the
X     people whose login names appear in ~/.friends. (There is also a
X     slower shell-script version which provides more information but
X     this verbose output is harder to manipulate and to format to
X     one's own liking)
X
X     * theirmail: reports on the status of other user's mailboxes.
X
X     * geeks: reports on the ten geekiest people on the system (by
X     number of hours logged in)
X
X     * in.rwhod: the daemon for my implementation of rwho. This
X     implemenation is minimally 2n! faster than Berkeley rwho and is
X     noticablly faster than finger (1) even on a SPARC II. 
X
X     When run with the command like `-c <server>' then in.rwhod does
X     the client thing, reporting when necessary back to the server.
X     When run without these options, in.rwhod does the server thing
X     collecting information from clients and responding to queries. 
X     
X     * rwho: the user-level interface to the in.rwhod server.
X     typical output looks like
X     [mari.acc.stolaf]  quanstro ttyp3    (loki4.cs.stolaf.)
X     [mari.acc.stolaf]  quanstro ttyp4    (loki4.cs.stolaf.)
X     [mari.acc.stolaf]  tremlh   ttyp5    (g-atalk2.atalk.s)
X     [mari.acc.stolaf]  matgress ttyp6    (xyplex1.stolaf.e)
X     [mari.acc.stolaf]  fritchie ttyp8    (spare2.acc.stola)
X     [asgaard.acc.sto]  gruetzne ttyp0    (131.234.128.231 )
X     [asgaard.acc.sto]  tremlh   ttyp1    (g-atalk2.atalk.s)
X	
X     * rw: a reformatter for rwho output. Typical output looks like
X     [mari.acc.stolaf] schultej quanstro quanstro quanstro quanstro
X                       tremlh matgress fritchie
X     [asgaard.acc.sto] gruetzne tremlh math12c fritchie
X     [newton.acc.stol] quanstro
X
Have fun and happy hacking!
X
ewq
X
END_OF_FILE
if test 4918 -ne `wc -c <'UNSHAR.HDR'`; then
    echo shar: \"'UNSHAR.HDR'\" unpacked with wrong size!
fi
# end of 'UNSHAR.HDR'
fi
if test -f 'daemon.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'daemon.8'\"
else
echo shar: Extracting \"'daemon.8'\" \(1197 characters\)
sed "s/^X//" >'daemon.8' <<'END_OF_FILE'
X.TH daemon 8 "14. January 1992"
X.SH NAME
daemon 0.90 \- the daemon for 
X.BR mood (1)
remote moods.
X.SH SYNOPSIS
daemon [\-p 
X.IR port ] 
X[[\-e] 
X.IR exec_file ]
X.SH DESCRIPTION
X.B Daemon
lurks in the background, waiting for a connection on a port, which
defaults to 9302 (this is an utterly random number) or be specified on
the command line via the \-p option. When 
X.B daemon 
receives a connection, then it sends all the input from the socket
to 
X.I exec_file,
which defaults to /usr/local/bin/fmood. The standard output and
standard input from 
X.I exec_file
are send over the socket back to the calling process. 
X.SH BUGS
X.B Daemon
seems to be bug free. (Knock on wood!)
X.SH "SEE ALSO"
X.BR friends (1),
X.BR friends (5),
X.BR moodmail (1),
X.BR mood (1),
X.BR fmood (1),
X.SH AUTHOR
Copyright (C) 1991, 1992 by Erik Quanstrom
X
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.  This software is provided ``as is'' without express or
implied warranty.
X
END_OF_FILE
if test 1197 -ne `wc -c <'daemon.8'`; then
    echo shar: \"'daemon.8'\" unpacked with wrong size!
fi
# end of 'daemon.8'
fi
if test -f 'daemon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'daemon.c'\"
else
echo shar: Extracting \"'daemon.c'\" \(7144 characters\)
sed "s/^X//" >'daemon.c' <<'END_OF_FILE'
X/************************************************************************
X * file:	daemon.c						*
X * 									*
X * Object:	provied a mood daemon					*
X * 									*
X *									*
X *									*
X * Copyright (C) Erik Quanstrom, 1992					*
X * Under the terms expressed in the manual page				*
X *									*
X * Erik Quanstrom							*
X * 14. Januar 1992							*
X ************************************************************************/
X#define DEFAULT_PORT 	9302
X#ifndef MOOD
X#define MOOD		"/usr/local/bin/fmood"
X#endif
X#define BSIZE 		1024 * 8
X#define SPECIAL		'*'
X#define FLAG		'-'
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/file.h>
X#include <sys/socket.h>
X#include <netdb.h>
X#include <netinet/in.h>
X
typedef struct sockaddr SOCK;
typedef struct sockaddr_in SOCK_IN;
X
char **Envp;	/* pass on the same environment */
char *host;	/* only figure out what the host name is once */
char *program;
char *path = NULL;
X
int open_socket(int port);
void process_connection(int s);
int wait_for_connection(int s);
void die(int c);
void warn(void);
char *strdup(char *s);
X
X/************************************************************************
X * function:	main()							*
X * 									*
X * object: 	provide an rmood server					*
X * 									*
X * Erik Quanstrom							*
X * 2. Oktober 1991							*
X ************************************************************************/
int main ( int argc, char **argv, char **envp) 
X{
X  int s;
X  int port = DEFAULT_PORT;
X
X  program = *argv;
X
X  host = (char *)malloc(100 * sizeof (char));
X  gethostname (host, 100);
X  
X  while (++argv && *argv)
X    {
X      if (**argv == FLAG)
X	{
X	  if (!*(argv + 1))
X	    usage();
X
X	  switch (*(*argv + 1))
X	    {
X	    case 'p': /* port */
X	      argv++;
X	      port = atoi(*argv);
X	      break;
X	    case 'r': /* run */
X	      if (path)
X		usage();
X
X	      path = *argv;
X	      break;
X	    default:
X	      usage();
X	      /* NOT_REACHED */
X	    }
X	}
X      else
X	path = *argv;
X    }
X
X  if (!path)
X    path = MOOD;
X  
X  s = open_socket( port );
X
X  Envp = envp;
X  
X  do
X    process_connection(wait_for_connection(s));
X  while (1);
X
X  close(s);
X
X  return 0;
X}
X
X/************************************************************************
X * function:	usage()							*
X * 									*
X * object: 	print out the usage message				*
X * 									*
X * Erik Quanstrom							*
X * 14. Jaunar 1992							*
X ************************************************************************/
int usage(void)
X{
X  fprintf(stderr, "usage: %s [-p port] [[-r] program]\n", program);
X  exit(1);
X}
X
X/************************************************************************
X * function:	wait_for_connection()					*
X * 									*
X * object: 	sit and wait for a connection				*
X * 									*
X * Erik Quanstrom							*
X * 2. Oktober 1991							*
X ************************************************************************/
int wait_for_connection(int s)
X{
X  int new,
X      newlen = sizeof(SOCK_IN);
X  
X  SOCK_IN *new_socket = (SOCK_IN *)malloc(sizeof(SOCK_IN));
X  
X  if ((new = accept(s, new_socket, &newlen)) < 0)
X    die(-4);
X  
X  return new;
X}
X
X/************************************************************************
X * function:	process_connection()					*
X * 									*
X * object: 	return the requested information across the socket	*
X * 									*
X * Erik Quanstrom							*
X * 2. Oktober 1991							*
X ************************************************************************/
void process_connection(int s)
X{
X  int child;
X  
X  switch (fork())
X    {
X    case 0:
X      break;
X    case -1:
X      warn();
X      break;
X    default:
X      {
X	int n;
X	int argv_size = 100;
X	int csize = 0;
X	
X	FILE *f;
X      
X	char **argv = (char **)malloc(argv_size * sizeof(char *));
X	char **argv_base = argv;
X	char *p;
X	
X	*argv_base = strdup( path );
X	argv++;
X
X	f = fdopen(s, "r");
X      
X	while ((n = getc(f)) != EOF)
X	  {
X	    if (n == SPECIAL)
X	      break;
X	    
X	    if (n == ' ' || n == '\t' || n == '\n')
X	      {
X		if ((argv - argv_base) >= argv_size)
X		  {
X		    int diff = argv - argv_base;
X		    
X		    argv_size += 100;
X		    argv_base = (char **)realloc((void *)argv_base, argv_size);
X		    argv = argv_base + diff;
X		    
X		    csize = 0;
X		  }
X
X		argv++;
X		*argv = NULL;
X	      }
X	    else
X	      {
X		if (!*argv)
X		  {
X		    csize = 50;
X		    p = *argv = (char *)malloc(sizeof(char) * csize);
X		  }
X		else if ((p - *argv) > csize)
X		  {
X		    int diff = p - *argv;
X		    csize += 50;
X		    
X		    *argv = (char *)realloc((void *)*argv, csize);
X		    
X		    p = *argv + diff;
X		  }
X	      
X		*p = n;
X		p++;
X	      
X	      }
X	  }
X      
X	if (*argv)
X	  ++argv, *argv = NULL; /* terminate the vector */
X
X	fflush(f);
X	close(f);
X
X	write(s, "[", 1);
X	write(s, host, strlen(host));
X	write(s, "]\n", 2);
X
X	dup2(s, 1); /* stdout is socket */
X	dup2(s, 2); /* stderr is socket */
X
X	execve( path, argv_base, Envp);
X	/* NOT REACHED */
X      }
X    }
X  
X  wait(NULL);
X  close(s);
X}  
X
X/************************************************************************
X * function:	open_socket()						*
X * 									*
X * object: 	open a internet domain socket for connections		*
X * 									*
X * Erik Quanstrom							*
X * 2. Oktober 1991							*
X ************************************************************************/
int open_socket(int port)
X{
X  int s;
X  SOCK_IN *sin = (SOCK_IN *)malloc(sizeof(SOCK_IN));
X
X  if ( (s = socket(PF_INET,SOCK_STREAM, 0)) == -1 )
X    die(-1);
X
X  sin->sin_addr.s_addr = INADDR_ANY;
X  sin->sin_family = AF_INET;
X  sin->sin_port = htons( port );
X
X  if (bind(s, sin, sizeof(SOCK_IN)) < 0)
X    die(-2);
X
X
X  if (listen(s, 5))
X    die(-3);
X  
X  return s;
X}  
X
void die(int c)
X{
X  perror(program);
X  exit(c);
X}
X
X/************************************************************************
X * funciton:    warn();                                                 *
X *                                                                      *
X * object:      print warning messages on failed system calls		*
X *                                                                      *
X * Erik Quanstrom                                                       *
X * 25. Januar 1992                                                      *
X ************************************************************************/
void warn(void)
X{
X  long t = time(NULL);
X  static char s[20];
X  
X  perror((char *)sprintf(s, "%15.15s ", (char *)(ctime(&t) + 4)));
X}
X
X/************************************************************************
X * funciton:    strdup();                                               *
X *                                                                      *
X * object:      malloc and copy a string                                *
X *                                                                      *
X * Erik Quanstrom                                                       *
X * 20. Juli 1991                                                        *
X ************************************************************************/
char *strdup(char *foo)
X{
X  char *tmp = (char *)malloc(sizeof(char) * strlen(foo) ),
X       *p = tmp;
X
X  /* make sure to copy the NULL */
X  do
X    *tmp++ = *foo;
X  while ( *foo++ );
X
X  return p;
X}
END_OF_FILE
if test 7144 -ne `wc -c <'daemon.c'`; then
    echo shar: \"'daemon.c'\" unpacked with wrong size!
fi
# end of 'daemon.c'
fi
if test -f 'ffriends.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ffriends.1'\"
else
echo shar: Extracting \"'ffriends.1'\" \(1232 characters\)
sed "s/^X//" >'ffriends.1' <<'END_OF_FILE'
X.TH friends 1 " 2. December 1991"
X.SH NAME
ffriends 0.90 \- print out friends logged in.
X
X.SH SYNOPSIS
ffriends [\-f 
X.IR friends_file ]
X
X.SH DESCRIPTION
X.B Ffriends
displays the login name of each person listed in the ~/.friends file,
one per line.
The output of friends is intentionally terse as this sort of output
is best suited for input into other programs.
X
X.SH OPTIONS
These are the current (supported) options:
X.TP 10
X\fB\-f file 
use 
X.I file 
instead of ~/.friends.
X
X.SH BUGS
None have surfaced yet.
X
X.SH "SEE ALSO"
X.BR mood (1)
X.BR fmood (1)
X.BR moodmail (1)
X.BR friends (1)
X.BR friends (5)
X
X.SH FILES
X.PD 0
X.TP 20
X.B ~/.friends
friends file
X.TP
X.B /etc/utmp
who is logged in
X.TP
X.B /etc/passwd
for users' names
X.TP
X.B /var/adm/lastlog
last login times
X.TP
X.B /etc/ttytab
terminal locations
X.PD
X.SH AUTHOR
Copyright (C) 1991, 1992 by Erik Quanstrom
X
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.  This software is provided ``as is'' without express or
implied warranty.
END_OF_FILE
if test 1232 -ne `wc -c <'ffriends.1'`; then
    echo shar: \"'ffriends.1'\" unpacked with wrong size!
fi
# end of 'ffriends.1'
fi
if test -f 'ffriends.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ffriends.c'\"
else
echo shar: Extracting \"'ffriends.c'\" \(2828 characters\)
sed "s/^X//" >'ffriends.c' <<'END_OF_FILE'
X/************************************************************************
X * file:	ffriends.c						*
X * 									*
X * object:	print out all friends names on the system		*
X * 									*
X * Copyright (C) Erik Quanstrom, 1992					*
X * Under the terms expressed in the manual page				*
X * 									*
X * Erik Quanstrom							*
X * 8. Jan 1992								*
X ************************************************************************/
X#include <stdio.h>
X#include <sys/types.h>
X#include <time.h>
X
X#include <utmp.h>
X#include <lastlog.h>
X
X#define	FLAG	'-'
X#define UTMP	"/etc/utmp"
X
typedef struct utmp Utmp;
X
void usage(char *name);
int find_friends(FILE *f, FILE *u);
X
X#ifndef nonuser
X#define nonuser(ut) ((ut).ut_host[0] == 0 && \
X	strncmp((ut).ut_line, "tty", 3) == 0 && ((ut).ut_line[3] == 'p' \
X					      || (ut).ut_line[3] == 'q' \
X					      || (ut).ut_line[3] == 'r' \
X					      || (ut).ut_line[3] == 's'))
X
X#endif /* !nonuser */
X
int main(int argc, char **argv, char **envp) 
X{
X  FILE *f = NULL;
X  FILE *u;
X  
X  char *program = *argv;
X  
X  /* parse arguments */
X  while (*++argv)
X    {
X      if (**argv == FLAG)
X	switch (*(*argv + 1))
X	  {
X	  case 'f':
X	    argv++;
X	    if (!*argv)
X	      usage(program);
X	    
X	    if (!(f = fopen(*argv, "r")))
X	      {
X		perror(program);
X		exit(1);
X	      }
X	    break;
X	  default:
X	    usage(program);
X	    /* NOT_REACHED */;
X	  }
X      else
X	usage(argv[0]);
X    }
X
X  /* open ~/.friends */
X  if (!f)
X    if (!(f = fopen((char *)strcat(getenv("HOME"), "/.friends"), "r")))
X      {
X	fprintf(stderr, "%s: $HOME/.friends not found.\n", program);
X	exit (1);
X      }
X  
X  /* try to open /usr/etc/utmp */
X
X  if (!(u = fopen(UTMP, "r")))
X    {
X      perror(argv[0]);
X      exit(1);
X    }
X
X  return find_friends(f,u);
X}
X
int find_friends(FILE *f, FILE *u)
X{
X  Utmp utmp_entry;
X  int size = 100;
X  char **friend = (char **)malloc(sizeof(char *) * size);
X  char **friendp = friend;
X
X  /* initilize the array */
X
X  while (!feof(f))
X    {
X      if (friendp - friend > size)
X	{
X	  int diff = friendp - friend;
X	  
X	  size+=100;
X	  friend = (char **)realloc((void *)friend, size * sizeof(char *));
X	  friendp = friend + diff;
X	}
X      
X      *friendp = (char *)malloc(16 * sizeof(char));
X      
X      fscanf(f,"%8s", *friendp);	/* this is a hack, but efficient */
X      
X      friendp++;
X    }
X      
X  *friendp = NULL;
X  
X  while (!feof(u))
X    {
X      fread(&utmp_entry, sizeof(Utmp), 1, u);
X      if ((!*utmp_entry.ut_name) || (nonuser(utmp_entry)))
X	continue;
X      
X
X      friendp = friend;
X      while (friendp && *friendp)
X	{
X	  if (!strncmp(utmp_entry.ut_name, *friendp, 8))
X	    {
X	      fprintf(stdout, "%s\n", *friendp);
X	      break;
X	    }
X	  friendp++;
X	}
X    }
X  return 0;
X}
X
void usage(char *name)
X{
X  fprintf(stderr, "usage: %s [-f <friends_file>]\n", name);
X  exit(1);
X  /* NOT_REACHED */
X}  
END_OF_FILE
if test 2828 -ne `wc -c <'ffriends.c'`; then
    echo shar: \"'ffriends.c'\" unpacked with wrong size!
fi
# end of 'ffriends.c'
fi
if test -f 'fmood.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fmood.1'\"
else
echo shar: Extracting \"'fmood.1'\" \(4790 characters\)
sed "s/^X//" >'fmood.1' <<'END_OF_FILE'
X.TH fmood 1 " 12. January 1991"
X.SH NAME
fmood 0.90 \- get a user's mood
X.SH SYNOPSIS
fmood [\-m] < 
X.I new_mood
X.LP
fmood [\-vfa[#]] [\-] [
X.IR user1 [\h'-0.5m'
X.IR @host1 ] 
X.IR user2 [\h'-0.5m'
X.IR @host2 ]
X  .\|.\|. ] 
X.SH DESCRIPTION
X.BR Fmood
prints out the ``mood'' of different users in various and sundry formats.
When run with no arguments, 
X.BR fmood
trys to use
X.BR getpass (3)
to read the users login name. If that fails, 
X.BR fmood 
exits with status 1. 
If 
X.BR fmood 
has arguments and the \-m flag has not been specified, then it will
try to find the ``mood'' of each user in the argument list, trying to
connect to a remote mood server if the host is specified. If a user is
not found using  
X.BR getpwnam (3)
then 
X.BR fmood
prints:
X.IP
X.BI "just who the heck is <" name "> anyway?
X.LP
on standard error.
If a user has no ~/.mood file or a user's ~/.mood file cannot be read,
then 
X.I fmood
prints:
X.IP
X.BI "<" name "> is a stoic dweeb."
X.LP
on standard error.
If the file is readable, then 
X.I fmood 
will output
X.IP
X.BI "<" firstname "> is feeling <" contents_of_moodfile">"
X.LP
X
X.SH OPTIONS
These are the current (supported) options:
X.TP 10
X\fB\-v 
changes the output format of 
X.I fmood 
to include the user name and suppresses ``stoic dweeb'' and ``unknown
user'' error messages.
X.TP 10
X\fB\-f
gets the ``moods'' of all the people in your friends file (see 
X.BR friends (1))
X.TP 10
X\fB\-e[#]
Sets the expire time for moods. If # is not set then all the moods will be
printed. Otherwise, all the moods less than # days old will be printed.
X.TP 10
X\fB\-m
sets your ``mood'' to whatever is read from the standard input. Note
that control characters are not ignored, but unlike previous versions of 
X.BR mood (1),
this version prints out the entire file. Formatting will not
necessarily be preserved.
X.TP 10
X\fB\-
forces
X.B fmood
to take user names from standard input. For each occurrence of `\-' in
the argument list, standard input is read until 
X.SM EOF.
X.SH HISTORY
Glenn Elliott (whose infamous reputation for horrendous coding style,
said to be a result of first coding in
BASIC
and then converting the results to C, is truly undeserved) wrote the first
and quite possibly the best version of 
X.BR mood
at St. Olaf College in the fall of 1986. Pete TerMaat wrote his version of 
X.BR mood
in 1987, his Junior year at St. Olaf in 
X.BR sh (1)
and added a few features. In 1987 the 
X.I moodmail (1) 
mailing list got started by Pete and was a huge success but in the Fall of
X1988, since Pete had graduated, Brett M. Rabe and Henry Pierce raced to get
moodmail up-and-running. Brett was given the source by Pete but it is not
clear if Henry had gotten the source from tape or written a new version of
X.B mood 
himself. Henry had obtained the user-of-the-day and word-of-the-day as well
as the moodmail scripts but did not have the actual moodmail program. Brett,
on the other hand, had the mood program but none of the other stuff. In the
end, Brett became the new moodmailman. When Brett left St. Olaf in January
of 1989, Jeff Marker became the new moodmailman although he though that his
position was temporarly and so he left the program and the sources in Brett's
account.
X.PP
During the 90-91 school year, Brett's account was removed, forcing Jeff to
rewrite the program yet again, this time adding support for 
X.BR rmood
and a Sunday edition of the mood mailing list. Also added to the 
X.BR moodmail (1)
mailing list were, at various times, quotes from the Bible and the 
Kama Sutra.
X
In the Fall of 1991, Erik Quanstrom rewrote the entire package from scratch,
deleting many of the old features and adding some of his own, most notably
direct support for 
X.IP
X.BI "mood user@host" 
X.LP
remote moods. Erik set up his own mailing list when Jeff's account was
suspended, not realizing that Jeff Miller was temporarly running moodmail. 
X.SH BUGS
X.BR Fmood
will not preserve formatting. To some extent this cannot be
avoided in line breaking, but
X.B fmood 
should to a better job with this.
X.PP
X.BR Fmood
will pass non-ascii characters as well as non-printing characters to the
standard output. 
X.BR Mail (1)
has lots of problems with this and this encourages people to do
terminal-specific things in there moods.
X.SH "SEE ALSO"
X.BR daemon (8).
X.BR friends (1),
X.BR friends (5),
X.BR mood (1),
X.BR moodmail (1),
X
X.SH FILES
X~/.mood ~/.friends
X.SH AUTHOR
Copyright (C) 1991, 1992 by Erik Quanstrom
X
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.  This software is provided ``as is'' without express or
implied warranty.
END_OF_FILE
if test 4790 -ne `wc -c <'fmood.1'`; then
    echo shar: \"'fmood.1'\" unpacked with wrong size!
fi
# end of 'fmood.1'
fi
if test -f 'fmood.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fmood.c'\"
else
echo shar: Extracting \"'fmood.c'\" \(12721 characters\)
sed "s/^X//" >'fmood.c' <<'END_OF_FILE'
X/************************************************************************
X * file:	fmood	(0.90.00)					* 
X * 									* 
X * object:	to users moods (quickly)				*
X *									*
X * 		the ephisis here is on correctness and speed. No 	*
X * 		thoughts were given during development to portability.	*
X * 		However the only routine which may not be portable is 	*
X * 		tty_width()						*
X * 									*
X * files:	~user/.mood						*
X * 		"/.friends						*
X *									*
X * Copyright (C) Erik Quanstrom, 1992					*
X * Under the terms expressed in the manual page				*
X * 									*
X * Erik Quanstrom							*
X * 11. Jaunuar 1992							*
X ************************************************************************/
X#include <stdio.h>
X#include <sys/types.h>
X#include <pwd.h>
X#include <sys/ioctl.h>
X#include <sys/stat.h>
X#include <sys/socket.h>
X#include <sys/time.h>
X#include <netdb.h>
X#include <netinet/in.h>
X#include <sys/errno.h>
X
X#include <ctype.h>
X#include <string.h>
X/*#include "string.h"*/
X
X#define FLAG '-'
X#define DEFAULT_PORT  9302
X#define SPECIAL "*"
X#define SEC_IN_DAY 3600l * 24l
X
X#ifndef S_IXOTH
X#define S_IROTH  0000004
X#define EXEC_ALL 0000111
X#else
X#define EXEC_ALL S_IXOTH | S_IXGRP | S_IXUSR
X#endif
X
extern char *getenv(char *key);
extern char *getlogin(void);
X
char *get_pty_login(void);
int mood(char *name);
int rmood(char *name);
int Mood(char *name);
void usage(void);
void format(char *s, int len);
int tty_width(void);
char **read_friends(char *file);
void die(int status);
void warn(void);
char *strdup(char *s);
char *concat(char *a, char *b);
X
typedef struct sockaddr SOCK;
typedef struct sockaddr_in SOCK_IN;
X
enum bool
X{
X  false,
X  true
X} boolean;
X
X/* flags */
int dashv = 0;
int dashe = -1;
long dashe_days;
X
long TimeNow;
char *program;
int WindowSize;
X
int main(int argc, char **argv)
X{
X  int status = 0,
X      seen = false;
X  
X  TimeNow = time(NULL);
X  program = *argv;
X  
X  WindowSize = tty_width();
X
X  while (++argv && *argv)
X    if (**argv == FLAG && !strchr(*argv, '@'))
X      if (*(*argv +1) == '\0')
X	{
X	  seen++;
X	  mood_stdin();
X	}
X      else
X	while (++*argv && **argv)
X	  {
X	    switch (**argv)
X	      {
X	      case 'a':
X		{
X		  char *offset = *argv + 1;
X		  
X		  if (isdigit(*offset))
X		    {
X		      dashe = 0;
X		      for ( ; isdigit(*offset); offset++)
X			{
X			  dashe *= 10;
X			  dashe += *offset - '0';
X			}
X		  
X		      dashe_days = (SEC_IN_DAY) * (long)dashe;
X		  
X		      *argv = offset - 1;
X		    }
X		}
X		seen++;
X		mood_all(dashe);
X		break;
X	      case 'm':
X		{
X		  struct stat buf;
X		  char *home = getenv("HOME");
X		  char c;
X		  FILE *moodfile;
X		  
X		  seen++;
X		  
X		  if (-1 == stat(home, &buf))die(1);
X		  if (-1 == chmod(home, buf.st_mode | EXEC_ALL)) die(1);
X		  if (-1 == chdir(home)) die(1);
X		  if (!(moodfile = fopen(".mood", "w"))) die(1);
X	    
X		  while ((c = getc(stdin)) != EOF)
X		    putc(c, moodfile);
X
X		  close(moodfile);
X		  break;
X		}
X	      case 'v':
X		dashv++;
X		break;
X	      case 'f':
X		{
X		  char **friends;
X		  
X		  seen++;
X		  
X		  friends = read_friends(strcat(getenv("HOME"), "/.friends"));
X
X		  if (!friends)
X		    break;
X	      
X		  while (**friends)
X		    {
X		      mood(*friends);
X		      ++friends;
X		    }
X	        }
X		break;
X	      default:
X		usage();
X		/* NOT_REACHED */
X	      }
X	  }
X    else	
X      seen++, status = mood(*argv);
X
X  if (!seen)
X    {
X      char *tmp;
X      
X      if ((tmp = getlogin()) || (tmp = get_pty_login()))
X	seen++, mood(strdup(tmp));
X      else 
X	{
X	  fprintf(stderr, "%s: getlogin() failed. Is this a tty?\n", program);
X	  exit(1);
X	}
X    }
X  
X  return status;
X}
X
char *get_pty_login(void)
X{
X  struct passwd *p;
X  
X  if (!isatty(0) && !isatty(1))
X    return (char *)NULL;
X  
X  return getpwuid(getuid())->pw_name;
X}
X
int mood_stdin(void)
X{
X  int s;
X  char *name = (char *)malloc(266 * sizeof(char));
X  char *namep = name;
X      
X  while ((*namep = getc(stdin)) != EOF)
X    {
X      if (*namep == ' ' || *namep == '\t' || *namep == '\n')
X	if (namep - name)
X	  {
X	    *namep = '\0';
X	    s += mood(strdup(name));
X	    namep = name;
X	    continue;
X	  }
X      namep++;
X    }
X      
X  if (namep - name)
X    {
X      namep = '\0';
X      mood(name);
X      namep = name;
X    }
X
X  return s;
X}
X
void usage(void)
X{
X  fprintf(stderr, 
X    "usage %s [-m new_mood] [-fva] [-e[#]] user1[@host1] ...\n", 
X	  program);
X  exit(1);
X}
X
int mood(char *name)
X{
X  if (strchr(name, '@'))
X    return rmood(name);
X  else 
X    return Mood(name);
X}
X
int rmood(char *name)
X{
X  char *host;
X  char *user = strdup(name);
X  char *userp = user;
X  static char buf[1024 * 8];
X  struct hostent *hp;
X  int  s, n;
X  SOCK_IN * sin = (SOCK_IN *)malloc(sizeof(SOCK_IN));
X  
X  while (*userp != '@')
X    userp++;
X
X  *userp = '\0';
X  userp++;
X  
X  host = strdup(userp);
X  
X  if ( (sin->sin_addr.s_addr = inet_addr( host )) != -1)
X    sin->sin_family = AF_INET;
X  else
X    if (hp = gethostbyname(host))
X      {
X        sin->sin_family = hp->h_addrtype;
X        bcopy(hp->h_addr, &sin->sin_addr, hp->h_length);
X      }
X    else
X      {
X        fprintf(stderr, "unknown host %s\n", host);
X        exit(1);
X      } 
X
X  sin->sin_port = htons( (int)DEFAULT_PORT );
X
X  if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0)
X    {
X      perror(program);
X      return 1;
X    }
X
X  if (connect(s, sin, sizeof(SOCK_IN)) < 0)
X    {
X      perror(program);
X      close (s);
X      return 1;
X    }
X
X  if ((write(s, user, strlen(user)) < 0) || (write(s, SPECIAL, 1) < 0))
X    {
X      perror(program);
X      close(s);
X      return 1;
X    }
X
X  while (n = read(s, buf, 8 * 1024))
X    fwrite(buf, n, sizeof(char), stdout);
X    
X  close(s);
X  
X  free((void *)user);
X  free((void *)host);
X  /* do not free hp --- static memory */
X
X  return 0;
X}
X
int Mood(char *name)
X{
X  struct passwd *g;
X  static struct stat *s = NULL;
X  static int bufalloc = 0;
X  static char *buf = NULL; 
X  char *path;
X  FILE *f;
X  long fsize;
X  extern int errno;
X  
X  if (!s)
X    s = (struct stat *)malloc(sizeof(struct stat));
X
X  if (!(g = getpwnam(name)))
X    {
X      if (!dashv)
X      	fprintf(stderr, "just who the heck is %s anyway?\n", name);
X      return 2;
X    }
X
X  /* warn if that is is the thing to do */
X  if ((stat(path = concat(g->pw_dir, "/.mood"), s) < 0) && 
X      (errno != EACCES) && (errno != ENOENT))
X    {
X      warn();
X      return 1;
X    }
X  
X  /* Should we test for some cases of bad permissions? 
X     this could be useful for those users who tend to
X     make inexperienced mistakes like setting the permissions
X     wrong
X   */
X
X  if ( ((dashe > 0) && ((TimeNow - s->st_mtime - dashe_days) > 0)) ||
X      !s->st_size || /* <- is this one the Right Thing to do? */
X      !(f = fopen(concat(g->pw_dir, "/.mood"), "r"))) 
X    {
X      if (!dashv)
X	fprintf(stderr, "%s is a stoic dweeb\n", strtok(g->pw_gecos, " ,"));
X	
X      return 1;
X    }
X  
X  if ((fsize = s->st_size) > bufalloc)
X    {
X      if (fsize < 8 * 1024L)
X	bufalloc = 8 * 1024;
X      else
X	bufalloc = (int)fsize;
X
X      if (!buf && (!(buf = (char *)malloc(bufalloc))))
X	die(2);
X      else if (!(buf = (char *)realloc((void *)buf, bufalloc)))
X	die(2);
X    }
X  
X  fread(buf, (int)fsize, sizeof(char), f);
X  fclose(f);
X  
X  if (dashv)
X    {
X      char *s = (char *)malloc(14 * sizeof(char));
X      sprintf(s, "[%-8s]   ", g->pw_name);
X      format(s, 12);
X      free((void *)s);
X    }
X 
X  format(g->pw_gecos, strcspn(g->pw_gecos, ", "));
X  
X  format(" is feeling ", 12);
X  format(buf, fsize);
X  format(NULL , 0); /* send end of line */
X  
X  return 0;
X}
X
void format(char *s, int len)
X{
X  static int pos = 0;
X  int p = pos;
X
X  char *spoint = s;
X  char *smin = s;
X  char *smax = s + len - 1;
X
X  /* line break */
X  if (!s && !len)
X    {
X      fwrite("\n",1,sizeof(char),stdout);
X      pos = 0;
X      return;
X    }
X
X  /* now do the word breaking */
X  while (spoint <= smax)
X    {
X      spoint = smin;
X      while ((p < WindowSize ) && (spoint <= smax))
X	{
X	  if (*spoint == ' ' || *spoint == '\t' || *spoint == '\n')
X	    {
X	      fwrite(smin, spoint - smin, sizeof(char),stdout);
X	      fwrite(" ",1,sizeof(char),stdout);
X	      pos += spoint - smin + 1;
X	      smin = spoint + 1;
X	    }
X	  spoint++;
X	  p++;
X	}
X      
X      if ( p >= WindowSize)
X	{
X	  /* word is bigger than the window */
X	  if (((pos + spoint - smin) >= WindowSize) && (spoint - smin >20))
X	    {
X	      int d = WindowSize - pos - 1;
X
X	      fwrite(smin, d, sizeof(char),stdout);
X	      smin += d;
X	      spoint = smin;
X	    }
X
X	  p = pos = 12;
X	  fwrite("\n            ", 13, sizeof(char), stdout);
X	}
X    }
X
X  fwrite(smin, smax - smin + 1, sizeof(char),stdout);
X
X  pos += smax - smin + 1;
X}
X
int tty_width(void)
X{
X  struct winsize win;
X  int fd;
X
X  if ((fd = open("/dev/tty", 0)) == -1)
X    return 79;
X
X  ioctl(fd, TIOCGWINSZ, &win);
X
X  if (win.ws_col != 0)
X    return win.ws_col - 1;
X
X  return 79;
X}
X
char **read_friends(char *file)
X{
X  FILE *f = fopen(file, "r");
X  int size = 100;
X  char **friend;
X  char **friendp;
X  
X  if (!f)
X    return (char **)NULL;
X
X  friendp = friend = (char **)malloc(size * sizeof(char *));
X  
X  while (!feof(f))
X    {
X      if (friendp - friend > size)
X	{
X	  int diff = friendp - friend;
X	  
X	  size+=100;
X	  friend = (char **)realloc((void *)friend, size * sizeof(char *));
X	  friendp = friend + diff;
X	}
X      
X      *friendp = (char *)malloc(16 * sizeof(char));
X      
X      fscanf(f,"%8s", *friendp);	/* this is a hack, but efficient */
X      
X      friendp++;
X    }
X      
X  *friendp = NULL;
X
X  fclose(f);
X  return friend;
X}
X
int mood_all(int days)
X{
X  struct passwd *g;
X  struct stat *status = (struct stat *)malloc(sizeof(struct stat));
X  char *file;
X
X  int arraysize = 1000;  
X  char **array = (char **)malloc(arraysize * sizeof(char *));
X  char **arrayp = array;
X  char **arraymax = arrayp + arraysize;
X  
X  if (days == -1)
X    dashe_days = (long)3 * (SEC_IN_DAY);
X  
X  for ( g = getpwent(); g ; g = getpwent())
X    {
X      file = concat(g->pw_dir, "/.mood");
X      
X      if (stat(file, status))
X	continue;
X      
X      if ((status->st_mode & S_IROTH) && 
X	  (!dashe_days || ((TimeNow - status->st_mtime  - dashe_days) < 0)))
X	{
X	  *arrayp = strdup(g->pw_name);
X	  arrayp++;
X	  
X	  if (arrayp == arraymax)
X	    {
X	      int diff = arraysize;
X	      
X	      arraysize += 300;
X	      array = (char **)realloc((void *)array, arraysize);
X	      arrayp = array + diff;
X	    }
X	}
X
X      /* free((void *)file); */
X    }
X
X  while ((array <= arrayp) && *array)
X    {
X      mood(*array);
X      array++;
X    }
X  
X  return 0;
X}
X
void die(int stat)
X{
X  perror(program);
X  exit(stat);
X}
X
X/************************************************************************
X * funciton:    warn();                                                 *
X *                                                                      *
X * object:      print warning messages on failed system calls		*
X *                                                                      *
X * Erik Quanstrom                                                       *
X * 25. Januar 1992                                                      *
X ************************************************************************/
void warn(void)
X{
X  long t = time(NULL);
X  static char s[20];
X  
X  perror((char *)sprintf(s, "%15.15s ", (char *)(ctime(&t) + 4)));
X}
X
X/************************************************************************
X * funciton:    strdup();                                               *
X *                                                                      *
X * object:      malloc and copy a string                                *
X *                                                                      *
X * Erik Quanstrom                                                       *
X * 20. Juli 1991                                                        *
X ************************************************************************/
char *strdup(char *foo)
X{
X  char *tmp = (char *)malloc(sizeof(char) * strlen(foo) ),
X       *p = tmp;
X
X  /* make sure to copy the NULL */
X  do
X    *tmp++ = *foo;
X  while ( *foo++ );
X
X  return p;
X}
X
X/************************************************************************
X * funciton:	concat();						*
X * 									*
X * object:	malloc and copy	2 strings --- and don't die or do 	*
X *		aything else anti-social if either is null		*
X * 									*
X * Erik Quanstrom 							*
X * 20. Juli 1991							*
X ************************************************************************/
char *concat( char *a, char *b )
X{
X  char *tmp, *p;
X  
X  if ( !a ) 
X    if ( b )
X      return strdup(b);
X    else
X      return b;
X  
X  if ( !b ) 
X    return strdup(a);
X  
X  p = tmp = (char *)malloc( sizeof (char) * (strlen(a) + strlen(b) + 2) );
X  
X  while ( *a )
X    *tmp++ = *a++;
X  
X  /* make sure to copy the NULL */
X  do
X    *tmp++ = *b;
X  while ( *b++ );
X  
X  return p;
X}
END_OF_FILE
if test 12721 -ne `wc -c <'fmood.c'`; then
    echo shar: \"'fmood.c'\" unpacked with wrong size!
fi
# end of 'fmood.c'
fi
if test -f 'friends.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'friends.1'\"
else
echo shar: Extracting \"'friends.1'\" \(1436 characters\)
sed "s/^X//" >'friends.1' <<'END_OF_FILE'
X.TH friends 1 " 2. December 1991"
X.SH NAME
friends, rfriends 0.90 \- print out friends logged in.
X.SH SYNOPSIS
friends
X.LP
rfriends
X.SH DESCRIPTION
X.B Friends
displays the login name, full name, terminal name (prepended with a `*'
if write permission is denied), idle time, login time, and location
X(comment field in /etc/ttytab for local users, hostname for remote
users) for all people listed in ~/.friends.
X
Idle time is minutes if it is a single integer, hours and minutes if a
X':' is present, or days and hours if a d is present
X
X.B Rfriends
displays 
X.BR rwho (1)
information for all peole listed in ~/.friends.
X.SH BUGS
X.B Friends 
is too slow. See 
X.B ffriends (1) 
for a faster but more terse version.
X.SH "SEE ALSO"
X.BR mood (1),
X.BR moodmail (1),
X.BR fmood (1),
X.BR ffriends (1),
X.BR friends (5),
X.SH FILES
X.PD 0
X.TP 20
X.B ~/.friends
friends file
X.TP
X.B /etc/utmp
who is logged in
X.TP
X.B /etc/passwd
for users' names
X.TP
X.B /var/adm/lastlog
last login times
X.TP
X.B /etc/ttytab
terminal locations
X.PD
X.SH AUTHOR
Copyright (C) 1991, 1992 by Erik Quanstrom
X
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.  This software is provided ``as is'' without express or
implied warranty.
END_OF_FILE
if test 1436 -ne `wc -c <'friends.1'`; then
    echo shar: \"'friends.1'\" unpacked with wrong size!
fi
# end of 'friends.1'
fi
if test -f 'friends.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'friends.5'\"
else
echo shar: Extracting \"'friends.5'\" \(574 characters\)
sed "s/^X//" >'friends.5' <<'END_OF_FILE'
X.TH friends 5 " 2. December 1991"
X.SH NAME
friends \- the friends file specification
X.SH SYNOPSIS
X~/.friends
X.SH DESCRIPTION
The 
X.I friends
file format is used by the programs 
X.BR friends (1)
and 
X.BR mood(1) 
for specifying a users friends. The 
X.I friends
file (usually ~/.friends) contains the login names of a users friends,
seperated by whitespace (newline, tab, or space). The entries in a
friends file may be in any order.
X.SH "SEE ALSO"
X.BR moodmail (1), 
X.BR friends(1),
X.BR mood(1) 
X.SH FILES
X.PD 0
X.TP 20
X.B ~/.mood 
mood file
X.TP 20
X.B ~/.friends
friends file
END_OF_FILE
if test 574 -ne `wc -c <'friends.5'`; then
    echo shar: \"'friends.5'\" unpacked with wrong size!
fi
# end of 'friends.5'
fi
if test -f 'friends.d' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'friends.d'\"
else
echo shar: Extracting \"'friends.d'\" \(739 characters\)
sed "s/^X//" >'friends.d' <<'END_OF_FILE'
X#!/bin/sh
X#########################################################################
X# file: 	friends							#
X#									#
X# object:	are any of my friends on the system?			#
X#									#
X# Erik Quanstrom							#
X# 10. Juli 1991								#
X#########################################################################
h=/usr/local/bin
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:$h/SPARCbin
X
case $0 in
X  friends | */friends)
X    p=finger;
X    program='friends';;
X  rfriends | */rfriends)
X    p=rwho;
X    program='rfriends';
esac
X
if test '!' -f $HOME/.friends; then
X  echo $program: '$'HOME/.friends not found. 2>&1;
fi
X
case $# in 
X  0) ;;
X  *) 
X     echo usage: $program 1>&2;
X     exit 1;;
esac
X
X$p | egrep -e "`tr ' ' '\012' < $HOME/.friends `"
END_OF_FILE
if test 739 -ne `wc -c <'friends.d'`; then
    echo shar: \"'friends.d'\" unpacked with wrong size!
fi
# end of 'friends.d'
fi
if test -f 'geeks.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'geeks.1'\"
else
echo shar: Extracting \"'geeks.1'\" \(956 characters\)
sed "s/^X//" >'geeks.1' <<'END_OF_FILE'
X.TH geeks 1 " 17. January 1992"
X.SH NAME
geeks 0.90 \- report on the top users of the week.
X.SH SYNOPSIS
geeks [\-n
X.I number
X]
X.SH DESCRIPTION
X.B Geeks 
querries the system time as to the total login time of each user on
the local machine and
then reports on the top 
X.I number
X``geeks.'' The default for 
X.I number 
is ten.
X
X.SH BUGS
X.B Geeks
is too slow.
X
X.SH "SEE ALSO"
X.BR mood (1),
X.BR moodmail (1),
X.BR fmood (1),
X.BR ffriends (1),
X.BR friends (5),
X.BR theirmail (1)
X
X.SH FILES
X.PD 0
X.TP 20
X.B /usr/spool/mail/*
mail files
X
X.SH AUTHOR
Copyright (C) 1991, 1992 by Erik Quanstrom
X
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.  This software is provided ``as is'' without express or
implied warranty.
END_OF_FILE
if test 956 -ne `wc -c <'geeks.1'`; then
    echo shar: \"'geeks.1'\" unpacked with wrong size!
fi
# end of 'geeks.1'
fi
if test -f 'geeks.d' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'geeks.d'\"
else
echo shar: Extracting \"'geeks.d'\" \(1137 characters\)
sed "s/^X//" >'geeks.d' <<'END_OF_FILE'
X#!/bin/sh
X#########################################################################
X# file: 	geeks							#
X#									#
X# object:	print out the n geekiest users				#
X#									#
X# usage:	geeks [-n geeks] 					#
X#		geeks -geeks						#
X#									#
X# Erik Quanstrom							#
X# 10. Juli 1991								#
X#########################################################################
h=/home/accserv1/stub/e/quanstro
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:$h/SPARCbin
X
case $# in
X 0) n=10;;
X 1) n=`echo $1 | sed 's/-//'`
X    if echo $n | egrep -v '[0-9]+' > /dev/null; then
X      echo "usage: $0 [-n geeks]";
X      exit 1;
X    fi;;
X 2) case $1 in 
X      -n) if echo $2 | egrep '[0-9]+' > /dev/null; then
X 	    n=$2;
X          else
X	    echo "usage: $0 [-n geeks]";
X	    exit 1;
X          fi;;
X       *) echo "usage: $0 [-n geeks]";
X	  exit 1;;
X    esac;;
X *) echo "usage: $0 [-n geeks]"
X    exit 1;;
esac
X    
X/usr/etc/ac -p | awk ' /^\ttotal/ { exit; }
X{
X  if (NF == 1)
X    print substr($1, 1, 8)" "substr($1, 9, 10);
X  else 
X    {
X      if ( length($1) == 8 )
X	print $1" "$2;
X      else
X	print $1"	 "$2;
X    }
X}' | sort +1rn | head -$n;
X
exit 0;
END_OF_FILE
if test 1137 -ne `wc -c <'geeks.d'`; then
    echo shar: \"'geeks.d'\" unpacked with wrong size!
fi
# end of 'geeks.d'
fi
if test ! -d 'hist' ; then
    echo shar: Creating directory \"'hist'\"
    mkdir 'hist'
fi
if test -f 'in.rwhod.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'in.rwhod.8'\"
else
echo shar: Extracting \"'in.rwhod.8'\" \(1760 characters\)
sed "s/^X//" >'in.rwhod.8' <<'END_OF_FILE'
X.TH in.rwhod 8 "14. January 1992"
X.SH NAME
in.rwhod 0.90 \- a lazy daemon for reporting on remote users.
X.SH SYNOPSIS
in.rwhod [\-d]  [\-c 
X.IR server ]
X.SH DESCRIPTION
X.B In.rwhod
lurks in the background, in either server or client (\-c) mode. If 
X.B in.rwhod
receives a connection in server mode, it first determines if the
connection is a query or a report. A query is recognized by the first
byte of the transmision being a `*.' (One can use 
X.BR telnet (1) 
instead of 
X.B rwho (1)
to connect to the server and send a `*' and then a 
X.SC CR
on a line to recieve a report.) If 
X.B In.rwhod 
is asked for a report, it is sent out on the socket. If it is provided
with a report (the contents of /etc/termcap),  this is remembered. 
X
In client mode,
X.B in.rwhod
send a report each time /etc/utmp is updated, but not more often than
once a minute.
X
X.SH BUGS
X.B In.rwhod 
assumes that the clients are alwats sending current and correct
reports. In addition, there is no authentication of either remote querries
or client servers.
X
X.SH "SEE ALSO" 
X.BR friends (1), 
X.BR friends (5), 
X.BR moodmail (1), 
X.BR mood (1), 
X.BR fmood (1)
X
X.SH files
X.PD 0
X.TP 20
X.B ~/.friends
friends file
X.TP
X.B /etc/utmp
who is logged in
X.TP
X.B /etc/passwd
for users' names
X.TP
X.B /var/adm/lastlog
last login times
X.TP
X.B /etc/ttytab
terminal locations
X.PD
X.SH AUTHOR
Copyright (C) 1991, 1992 by Erik Quanstrom
X
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.  This software is provided ``as is'' without express or
implied warranty.
X
END_OF_FILE
if test 1760 -ne `wc -c <'in.rwhod.8'`; then
    echo shar: \"'in.rwhod.8'\" unpacked with wrong size!
fi
# end of 'in.rwhod.8'
fi
if test -f 'in.rwhod.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'in.rwhod.c'\"
else
echo shar: Extracting \"'in.rwhod.c'\" \(13611 characters\)
sed "s/^X//" >'in.rwhod.c' <<'END_OF_FILE'
X/************************************************************************
X * file:	in.rwhod.c						*
X *									*
X * object:	to provide rwho information in a way that makes the 	*
X *		least demands on the network _while_ remaining 		*
X *		fully dynamic. That is, hosts should be added 		*
X * 		automatically and removed automatically by in.rwhod.	*
X *		To accomplish this, it is necessary to			*
X * 		1) not have ruptime information				*
X *		2) to leave it up to the clients to pass on new 	*
X *		   information using lazy updating.			*
X *									*
X * Copyright (C) Erik Quanstrom, 1992					*
X * Under the terms expressed in the manual page				*
X *									*
X * Erik Quanstrom							*
X * 17. Januar 1992							*
X ************************************************************************/
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/file.h>
X#include <sys/param.h>
X#include <sys/socket.h>
X#include <sys/stat.h>
X#include <sys/time.h>
X#include <netdb.h>
X#include <netinet/in.h>
X#include <utmp.h>
X#include <lastlog.h>
X
X#define PORT 5002 			/* this is really arbitrary */
X#define BSIZE 1024 * 8
X#define SPECIAL '*'
X#define FLAG '-'
X#define INFO_REQUEST '*'
X#define INFO_TRANSMISSION '#'
X#define INFO_TRANSMISSIONs "#"
X
X#ifndef nonuser
X#define nonuser(ut) ((ut).ut_host[0] == 0 && \
X	strncmp((ut).ut_line, "tty", 3) == 0 && ((ut).ut_line[3] == 'p' \
X					      || (ut).ut_line[3] == 'q' \
X					      || (ut).ut_line[3] == 'r' \
X					      || (ut).ut_line[3] == 's'))
X
X#endif /* !nonuser */
X
X/* this is a hack for the NeXT */
X
X#define HOST_LEN 64
X
X/* end of hack for the NeXT */
X
typedef struct sockaddr SOCK;
typedef struct sockaddr_in SOCK_IN; 
X
typedef struct utmp Utmp;
X
typedef enum 
X{
X  false,
X  true
X} boolean;
X
typedef struct 
X{
X  char *machine;
X  Utmp *utmp;
X  int size;	/* this is assumed to be volatile */
X  int reserved; /* therefore, so is this          */
X} Who;
X
void usage(void);
int open_socket(int port);
int open_socket_send(char *host, int port);
void process_connection(int s);
int wait_for_connection(int s);
int lazy_client(char *host, int port);
int client_report(char *server, int port);
int client_wait(void);
int info_request(int s);
X
void die(int c);
void warn(void);
void debug(FILE *f, char *format);
X
void *xmalloc(size_t size);
void *xrealloc(void *object, size_t size);
X
char *strdup(char *s);
X
Who *who_alloc(void);
Who *who_lookup(char *machine);
Who *who_add(char *machine, Utmp *utmp, int size, int alloc);
X
char *program;
Utmp *users = NULL;
int  utmp_size;
Who **who = NULL;
int dashd = 0;
X
int main(int argc, char **argv)
X{
X  int s;
X  int port = PORT;
X
X  program = *argv;
X  
X  while (++argv && *argv && **argv)
X    {
X      if (**argv == FLAG)
X	while (++*argv && **argv)
X	  {
X	    switch (**argv)
X	      {
X	      case 'c':
X		if (*(*argv +1) || !*(++argv))
X		  usage();
X
X		lazy_client(*argv, port);
X	      case 'd':
X		dashd++;
X		break;
X	      case 's':
X		break;
X	      default:
X		usage();
X		/* NOT_REACHED */
X	      }
X	  }
X    }
X
X  if (argv && *argv)
X    usage();
X  
X  if ((s = open_socket( port )) == -1)
X    exit(1);
X
X  do
X    process_connection(wait_for_connection(s));
X  while (1);
X
X  /* NOT_REACHED */
X
X  close(s);
X  return 0;
X}
X
X/************************************************************************
X * function:	usage()							*
X * 									*
X * object: 	print out the usage message				*
X * 									*
X * Erik Quanstrom							*
X * 14. Jaunar 1992							*
X ************************************************************************/
void usage(void)
X{
X  fprintf(stderr, "usage: %s [-d] [-c server]\n", program);
X  exit(1);
X}
X
X/************************************************************************
X * function:	wait_for_connection()					*
X * 									*
X * object: 	sit and wait for a connection				*
X * 									*
X * Erik Quanstrom							*
X * 2. Oktober 1991							*
X ************************************************************************/
int wait_for_connection(int s)
X{
X  int new,
X      newlen = sizeof(SOCK);
X  
X  SOCK *new_socket = (SOCK *)xmalloc(newlen);
X  
X  if ((new = accept(s, new_socket, &newlen)) < 0)
X    die(1);
X  
X  return new;
X}
X
X/************************************************************************
X * function:	process_connection()					*
X * 									*
X * object: 	return the requested information across the socket	*
X * 									*
X * Erik Quanstrom							*
X * 2. Oktober 1991							*
X ************************************************************************/
void process_connection(int s)
X{
X  FILE *f;
X  char c;
X  Who *w;
X  static char *machine = NULL;
X  Utmp *utmpp;
X  int tmp;
X  
X  read(s, &c, 1);
X
X  if (c == INFO_REQUEST)
X    {
X      debug(stderr, "info request\n");
X      info_request(s);
X    }
X  else
X    {
X      if (!machine)
X	machine = (char *)xmalloc(HOST_LEN * sizeof(char));
X  
X      if (!(f = fdopen(s, "r")))
X	{
X	  warn();
X	  close (s);
X	  return;
X	}
X
X      if (!fread(machine, sizeof(char), HOST_LEN, f))
X	{
X	  warn();
X	  fclose(f);
X	  close(s);
X	  return;
X	}
X
X      if (!(w = who_lookup(machine)))
X	{
X	  w = who_add((char *)NULL, (Utmp *)NULL, 0, 54);
X	  w->utmp = (Utmp *)xmalloc(sizeof(Utmp) * 54);
X	  w->machine = strdup(machine);
X	}
X
X      utmpp = w->utmp;
X      w->size = fread(utmpp, sizeof(Utmp), w->reserved, f);
X
X      while (!feof(f))
X	{
X	  tmp = (utmpp - w->utmp) + 54;
X	  
X	  w->reserved += 54;
X	    
X	  utmpp = w->utmp = (Utmp *)realloc((void *)w->utmp, 
X					    w->reserved * sizeof(Utmp));
X	  utmpp += tmp;
X	  w->size += fread(utmpp, sizeof(Utmp), 54, f);
X	}
X  
X      fflush(f);
X      fclose(f);
X    }
X
X  close (s);
X}  
X
int info_request(int s)
X{
X  FILE *f = fdopen(s, "w");
X  Who **w = who;
X  Utmp *u;
X  Utmp *u_top;
X
X  static char *fmachine = NULL;
X  
X  if (!fmachine)
X    fmachine = (char *)xmalloc(HOST_LEN * sizeof(char));
X  
X  while (w && *w)
X    {
X      u_top = u = ((Who *)*w)->utmp;
X      u_top += ((Who *)*w)->size;
X     
X      sprintf(fmachine, "[%-15.15s]  ", ((Who *)*w)->machine);
X
X      do
X	if (u->ut_name[0] && !(nonuser(*u)))
X	  {
X	    fwrite(fmachine, 15 + 4, 1, f);
X	    fprintf(f, "%-8.8s %-8s (%-16.16s)\n", 
X		    u->ut_name, u->ut_line, u->ut_host);
X	  }
X      while (++u <= u_top);
X      
X      w++;
X    }
X  
X  fflush(f);
X  fclose(f);
X
X  return 0;
X}
X
X/************************************************************************
X * function:	lazy_client()						*
X * 									*
X * object: 	be a lazy client					*
X * 									*
X * Erik Quanstrom							*
X * 2. Oktober 1991							*
X ************************************************************************/
int lazy_client(char *server, int port)
X{
X  do 
X    {
X      client_wait();
X      client_report(server, port);
X    }
X  while (1);
X  
X  /* NOT_REACHED */
X  return 0;
X}
X
int client_report(char *server, int port)
X{
X  int s, utmp;
X  static char *host = NULL;
X
X  if ((s = open_socket_send(server, port)) == -1)
X    return -1;
X      
X  debug(stderr, "sending report\n");
X  
X  if (!host)
X    {
X      host = (char *)xmalloc(HOST_LEN * sizeof(char));
X      gethostname(host, HOST_LEN);
X    }
X
X  if ((utmp = open("/etc/utmp", 0)) < 0)
X    die(1);
X
X  /* preformace bug: this should be one write with the HOST_LEN
X     snuck in at the beginning
X   */
X  read(utmp, users, utmp_size);
X
X  write(s, INFO_TRANSMISSIONs, 1); /* type */
X  write(s, host, HOST_LEN);
X  write(s, users, utmp_size);
X  
X  close(s);
X  close(utmp);
X
X  debug(stderr, "finished \n");
X  return 0;
X}
X
int client_wait(void)
X{
X  static long t = 0;
X  struct stat buf;
X  boolean changed = false;
X  
X  for (;;)
X    {
X      if (stat("/etc/utmp", &buf))
X	die(1);
X
X      if (buf.st_mtime > t) 
X	{
X	  users = (Utmp *)xmalloc(utmp_size = (int)buf.st_size); /* ick! */
X
X	  t = buf.st_mtime;
X	  break;
X	}
X
X      sleep(30);
X    }
X  return 0;
X}
X
X/************************************************************************
X * function:	open_socket()						*
X * 									*
X * object: 	open a internet domain socket for connections		*
X * 									*
X * Erik Quanstrom							*
X * 2. Oktober 1991							*
X ************************************************************************/
int open_socket(int port)
X{
X  int s;
X  SOCK_IN *sin = (SOCK_IN *)xmalloc(sizeof(SOCK_IN));
X
X  if ( (s = socket(PF_INET, SOCK_STREAM, 0)) == -1 )
X    {
X      warn();
X      return -1;
X    }
X
X  sin->sin_addr.s_addr = INADDR_ANY;
X  sin->sin_family = AF_INET;
X  sin->sin_port = htons( port );
X
X  if (bind(s, sin, sizeof(SOCK_IN)) < 0)
X    die(1);
X
X  if (listen(s, 5))
X    die(1);
X  
X  return s;
X}  
X
X/************************************************************************
X * function:	open_socket_send()					*
X * 									*
X * object: 	open a internet domain socket for sending info		*
X * 									*
X * Erik Quanstrom							*
X * 2. Oktober 1991							*
X ************************************************************************/
int open_socket_send(char *host, int port)
X{
X  struct hostent *hp;
X  SOCK_IN *sin = (SOCK_IN *)xmalloc(sizeof(SOCK_IN));
X  int s;
X
X  if ( (sin->sin_addr.s_addr = inet_addr( host )) != -1)
X    sin->sin_family = AF_INET;
X  else
X    if (hp = gethostbyname(host)) 
X      {
X	sin->sin_family = hp->h_addrtype;
X	bcopy(hp->h_addr, &sin->sin_addr, hp->h_length);
X      } 
X    else 
X      {
X	fprintf(stderr, "unknown host %s\n", host);
X	exit(1);
X      }
X  
X  sin->sin_port = htons( port );
X  
X  if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
X    {
X      warn();
X      return -1;
X    }
X  
X  if (connect(s, sin, sizeof(SOCK_IN)) < 0)
X    {
X      warn();
X      close(s);
X      return -1;
X    }
X  
X  return s;
X}
X
Who *who_alloc(void)
X{
X  static int who_size;
X  static int who_alloc = 0;
X  static Who **p = NULL;
X
X  who_alloc++;
X  
X  /* who is a ** so this may only increase by one each time */
X  if (!who)
X    {
X      who_size = 20/*# of hosts*/; 
X      p = who = (Who **)xmalloc(who_size * sizeof(Who *));
X    }
X  else if (who_size < who_alloc)
X    {
X      who_size += 20;
X      p = who = (Who **)realloc((void *)who, who_size * sizeof(Who *));
X      p += who_size - 20;
X    }
X
X  *p = (Who *)xmalloc(sizeof(Who));
X  
X  p++;
X  *p = NULL;
X  
X  return *(p - 1);
X}
X
Who *who_lookup(char *machine)
X{
X  Who **w = who;
X
X  /* this takes care of the starting condition */
X  if (!w)
X    return NULL;
X  
X  while (*w && strcmp((*w)->machine, machine))
X    w++;
X
X  return *w;
X}
X
Who *who_add(char *machine, Utmp *utmp, int size, int reserved)
X{
X  Who *w = who_alloc(); /* get a slot in the ptr to utmp list */
X
X  w->machine = machine;
X  w->utmp = utmp;
X  w->size = size;
X  w->reserved = reserved;
X
X  return w;
X}
X
X/************************************************************************
X * funciton:    die();                                                  *
X *                                                                      *
X * object:      print out error message and exit.			*
X *                                                                      *
X * Erik Quanstrom                                                       *
X * 25. Januar 1992                                                      *
X ************************************************************************/  
void die(int c)
X{
X  perror(program);
X  exit(c);
X}
X
X/************************************************************************
X * funciton:    debug();                                                *
X *                                                                      *
X * object:      print debugging information if debugging is turned on	*
X *                                                                      *
X * Erik Quanstrom                                                       *
X * 25. Januar 1992                                                      *
X ************************************************************************/
void debug(FILE *f, char *format)
X{
X  long t;
X  
X  if (!dashd)
X    return;
X  
X  t = time(NULL);
X  
X  fprintf(f, "%15.15s %s", (char *)(ctime(&t) + 4), format);
X}
X
X/************************************************************************
X * funciton:    warn();                                                 *
X *                                                                      *
X * object:      print warning messages on failed system calls		*
X *                                                                      *
X * Erik Quanstrom                                                       *
X * 25. Januar 1992                                                      *
X ************************************************************************/
void warn(void)
X{
X  long t = time(NULL);
X  static char s[20];
X  
X  perror((char *)sprintf(s, "%15.15s ", (char *)(ctime(&t) + 4)));
X}
X
X/************************************************************************
X * funciton:    strdup();                                               *
X *                                                                      *
X * object:      malloc and copy a string                                *
X *                                                                      *
X * Erik Quanstrom                                                       *
X * 20. Juli 1991                                                        *
X ************************************************************************/
char *strdup(char *foo)
X{
X  char *tmp, *p;
X
X  /* make sure to copy the NULL */
X  if (p = tmp = (char *)xmalloc (sizeof(char) * (strlen(foo) + 1)))
X    while (*tmp++ = *foo++)
X      ;
X  
X  return p;
X}
X
void *xmalloc(size_t size)
X{
X  void *tmp;
X  
X  if (!(tmp = (void *)malloc(size)))
X    die(1);
X  
X  return tmp;
X}
X
void *xrealloc(void *object, size_t size)
X{
X  void *tmp;
X  
X  if (!object)
X    tmp = (void *)malloc(size);
X  else
X    tmp = (void *)realloc(object, size);
X  
X  if (!tmp)
X    die(1);
X  
X  return tmp;
X}
END_OF_FILE
if test 13611 -ne `wc -c <'in.rwhod.c'`; then
    echo shar: \"'in.rwhod.c'\" unpacked with wrong size!
fi
# end of 'in.rwhod.c'
fi
if test -f 'mitime.d' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mitime.d'\"
else
echo shar: Extracting \"'mitime.d'\" \(752 characters\)
sed "s/^X//" >'mitime.d' <<'END_OF_FILE'
X#!/bin/sh 
X#########################################################################
X# function:	mitime							#
X#									#
X# object:	imiatte /usr/etc/ac -p 					#
X# 									#
X# Erik Quanstrom							#
X# 25. M"arz 1992							#
X#########################################################################
h=/usr/local
PATH=/bin:/usr/bin:/usr/local/bin:/usr/ucb
X
if test -z "${*}"; then
X  $0 `whoami`;
fi;
X
if test $0 -eq 0; then
X  printname=false;
fi;
X
return_code=0;
X
for named in ${*}; do
X  last $named | sed -e 's/.*(//g' -e 's/)//g' | awk -F':' \
X    '{
X        h += $1; 
X        m += $2;
X     }
X
X     END { 
X        while (m >= 60) {
X          m -= 60;
X          h++;
X        }
X     printf "'$named	'%d:%d\n", h, m;
X     }'
X
done;
X
exit $return_code;
END_OF_FILE
if test 752 -ne `wc -c <'mitime.d'`; then
    echo shar: \"'mitime.d'\" unpacked with wrong size!
fi
# end of 'mitime.d'
fi
if test -f 'mood.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mood.1'\"
else
echo shar: Extracting \"'mood.1'\" \(3509 characters\)
sed "s/^X//" >'mood.1' <<'END_OF_FILE'
X.TH mood 1 "2. December 1991"
X.SH NAME
mood 0.90 \- get a user's mood
X.SH SYNOPSIS
mood [\-m 
X.I new_mood
X] [ [\-f] 
X.I user1 user2 
X.\|.\|. ] 
X.SH DESCRIPTION
X.BR Mood
prints out the ``mood'' of users in various and sundry formats.  When
invoked, 
X.BR mood
reads the file ~/.mood and prepends 
X.IR ``user is 
feeling'' to that file which is then the user's ``mood.'' These are
the current (supported) options:
X.TP 10
X\fB\-f
gets the moods of all the people in your friends file (see 
X.BR friends (1))
X.TP 10
X\fB\-m
sets your mood to whatever you type after the flag. Note that control
characters are ignored, but unlike previous versions of 
X.BR mood (1), 
this version prints out the entire file. Formatting will not be
preserved. 
X.SH HISTORY
to take user names from standard input. For each occurrence of `\-' in
the argument list, standard input is read until 
X.SM EOF.
X.SH HISTORY
Glenn Elliott (whose infamous reputation for horrendous coding style,
said to be a result of first coding in
BASIC
and then converting the results to C, is truly undeserved) wrote the first
and quite possibly the best version of 
X.BR mood
at St. Olaf College in the fall of 1986. Pete TerMaat wrote his version of 
X.BR mood
in 1987, his Junior year at St. Olaf in 
X.BR sh (1)
and added a few features. In 1987 the 
X.I moodmail (1) 
mailing list got started by Pete and was a huge success but in the Fall of
X1988, since Pete had graduated, Brett M. Rabe and Henry Pierce raced to get
moodmail up-and-running. Brett was given the source by Pete but it is not
clear if Henry had gotten the source from tape or written a new version of
X.BR mood 
himself. Henry had obtained the user-of-the-day and word-of-the-day as well
as the moodmail scripts but did not have the actual moodmail program. Brett,
on the other hand, had the mood program but none of the other stuff. In the
end, Brett became the new moodmailman. When Brett left St. Olaf in January
of 1989, Jeff Marker became the new moodmailman although he though that his
position was temporarly and so he left the program and the sources in
Brett's
account.
X.PP
During the 90-91 school year, Brett's account was removed, forcing Jeff to
rewrite the program yet again, this time adding support for 
X.BR rmood
and a Sunday edition of the mood mailing list. Also added to the 
X.BR moodmail (1)
mailing list were, at various times, quotes from the Bible and the 
Kama Sutra.
X
In the Fall of 1991, Erik Quanstrom rewrote the entire package from scratch,
deleting many of the old features and adding some of his own, most notably
direct support for 
X.IP
X.BI "mood user@host" 
X.LP
remote moods. Erik set up his own mailing list when Jeff's account was
suspended, not realizing that Jeff Miller was temporarly running moodmail. 
X
X.SH BUGS
X.BR Mood
requires NIS
X
X.B Mood
will not preserve formatting. To some extent this cannot be
avoided, but
X.B Mood 
should to a better job with this
X
X.B Mood
assumes an 80 column display.
X.SH "SEE ALSO"
X.BR moodmail(1), 
X.BR friends(1),
X.SH FILES
X.PD 0
X.TP 20
X.B ~/.mood 
mood file
X.TP 20
X.B  ~/.friends
friends file
X
X.SH AUTHOR
Copyright (C) 1991, 1992 by Erik Quanstrom
X
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.  This software is provided ``as is'' without express or
implied warranty.
END_OF_FILE
if test 3509 -ne `wc -c <'mood.1'`; then
    echo shar: \"'mood.1'\" unpacked with wrong size!
fi
# end of 'mood.1'
fi
if test -f 'mood.d' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mood.d'\"
else
echo shar: Extracting \"'mood.d'\" \(2787 characters\)
sed "s/^X//" >'mood.d' <<'END_OF_FILE'
X#!/bin/sh 
X#########################################################################
X# function:	mood 0.90.00						#
X#									#
X# object:	print out users moods					#
X# 									#
X# Erik Quanstrom							#
X# 25. Noveber 1991							#
X#########################################################################
h=/usr/local
PATH=/bin:/usr/bin:/usr/local/bin:/usr/ucb
X
if test -z "${*}"; then
X  $0 `whoami`;
fi;
X
return_code=0;
X
for named in ${*};
X  do
X    {
X      shift;
X      case $named in
X	-f | -vf | -fv)
X	  $0 -v `cat $HOME/.friends`;;
X	-m)
X	  cd $HOME;
X	  echo $* > .mood;
X	  chmod a+x .;
X	  chmod a+r ./.mood;
X	  exit 0;;
X	-v)
X	  FLAG=v;;
X	-*) 
X	  echo mood: bad argument \"$named\".;
X	  exit 0;;
X	*@*)
X          echo $named | awk -F@ '{print $1}' |\
X	    send `echo $named | awk -F@ '{print $2;}'`;;
X        *)
X	  {
X	    info=`ypmatch $named passwd 2> /dev/null`;
X      
X	    if test -z "$info" ; then
X	      {
X                echo "Who the heck is $named anyway?";
X                return_code=2;
X              }
X	    else 
X              {
X	        homedir=`echo $info | awk -F: '{print $6;}'`/.mood;
X	        firstname=`echo $info | awk -F: '
X	        {
X		  for (i=1; i < length($5); i++)
X		    if ((substr($5,i,1) == ",") || (substr($5,i,1) == " "))
X		      {
X			print substr($5, 1, i-1);
X			exit;
X		      }
X
X		  print $5;
X		}'`
X	      
X	        if test -r $homedir; then 
X		  {
X		   case $FLAG in
X		     *v*)
X			string="[$named] ";;
X		   esac;
X   	          echo -n "$string$firstname is feeling " |\
X			 cat - $homedir | awk '
X		 {
X		    if (substr($1,1,1) == "[")		
X		      {
X		        verbose=1;
X			linepos = 11;
X		        saved = sprintf "%s%s", $1, substr("           ",\
X			    1, 11 - length($1) - 1);
X		      }
X		    else
X		      {
X			saved=$1;
X			linpos=length($1);
X		      }
X
X                    for (i = 2; i <= NF ; i++) 
X                      {
X                        if ( ( 2 + linepos + length($i)) >= 79 ) 
X                          {
X                            printf "%s\n", saved;
X			    if (verbose != 1)
X			      {
X	                        saved = "\t";
X                                linepos=7;
X			      }
X			    else
X			     {
X			        saved = "          ";
X				linepos=11;
X			     }
X                          }
X 
X                         linepos += length($i);
X                         saved = sprintf("%s %s", saved, $i);
X                         linepos++;
X                       }
X  
X                    if (saved != "\t")
X                      print saved;
X                  }'
X		
X		  return_code=0;
X		  }
X	        else 
X		  {
X	  	    case $FLAG in
X		      *v*)
X			;;
X		      *)
X		        echo "$firstname is a stoic dweeb.";;
X		    esac;
X
X		    return_code=1;
X		  }
X	        fi;
X	    }
X	  fi;
X        }
X      esac;
X    }
done;
X
exit $return_code;
END_OF_FILE
if test 2787 -ne `wc -c <'mood.d'`; then
    echo shar: \"'mood.d'\" unpacked with wrong size!
fi
# end of 'mood.d'
fi
if test -f 'moodmail.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'moodmail.1'\"
else
echo shar: Extracting \"'moodmail.1'\" \(1210 characters\)
sed "s/^X//" >'moodmail.1' <<'END_OF_FILE'
X.TH moodmail 1 " 2. December 1991"
X.SH NAME
moodmail 0.90 \- a tool for creating mood mailing lists
X.SH SYNOPSIS
moodmail [\-e
X.I expire
X] [ 
X.I mailing_list
X] 
X.SH DESCRIPTION
X.B Moodmail 
compiles a list of recently changed (less than 
X.I expire
days old) moods
and then uses mood to create a file containing the recent moods. This
file is then sent to all people in the 
X.I mailing_list 
file. The default mailing list is located in /usr/local/lib/mooders.
X
These are the current (supported) options:
X.TP 10
X\fB\-e expire
set the expire date explicitly. The default is three days. If 
X.I expire
is 0, then all moods are reported, regardless of age.
X
X.SH BUGS
None have surfaced, so far.
X
X.SH "SEE ALSO"
X.BR mood (1),
X.BR friends (1),
X.BR friends (5)
X
X.SH FILES
X/usr/local/lib/mooders
X
X.SH AUTHOR
Copyright (C) 1991,1992 by Erik Quanstrom
X
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.  This software is provided "as is" without express or
implied warranty.
END_OF_FILE
if test 1210 -ne `wc -c <'moodmail.1'`; then
    echo shar: \"'moodmail.1'\" unpacked with wrong size!
fi
# end of 'moodmail.1'
fi
if test -f 'moodmail.d' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'moodmail.d'\"
else
echo shar: Extracting \"'moodmail.d'\" \(1935 characters\)
sed "s/^X//" >'moodmail.d' <<'END_OF_FILE'
X#!/bin/sh
X#########################################################################
X# file:         moodmail (0.99.08)                                      #
X#                                                                       #
X# object:       do the mood mailing list                                #
X#                                                                       #
X#               emphisis on portability _and_ avoiding the cost of an   #
X#               executable, not on execution speed. This script is      #
X#               slow, but tolorable when run in the middle of the       #
X#               night as an at script.                                  #
X#                                                                       #
X# files:        $h/lib/moodies          default mailing list            #
X#               $h/bin/mood             program to do mood              #
X#               /tmp/mood$$...          mood tmp file                   #
X#                                                                       #
X# Erik Quanstrom                                                        #
X# 10. Januar 1992                                                       #
X#########################################################################
h=/home/accserv1/stub/e/quanstro
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:$h/SPARCbin
X
mfile=/home/accserv1/stub/e/quanstro/lib/mooders
X
case $# in
X 0 | 1 | 2) : 
X   ;;
X *)
X   echo "usage: $0 [-e expire] [mailing_list]";
X   exit 1;;
esac
X
while test $# -gt 0; do
X  case $1 in
X    -e) if test $# -lt 2; then
X	  echo usage: $0 [-e expire] [mailing_list];
X	  exit 1;
X	fi
X	shift;
X	expire=a"$1";;
X    -e[0-9] | -e[0-9][0-9] | -e[0-9][0-9][0-9])
X	expire=a`echo $1 | sed 's/-e//'`;;
X    *)  if test -f $1; then
X	  mfile=$1;
X	else
X	  echo "$0: file $1 not found."
X	  exit 1;
X        fi
X  esac;
X  shift;
done;
X
fmood -va"$expire" | Mail -s 'Mood mail' `cat $mfile`;
exit 0;
END_OF_FILE
if test 1935 -ne `wc -c <'moodmail.d'`; then
    echo shar: \"'moodmail.d'\" unpacked with wrong size!
fi
# end of 'moodmail.d'
fi
if test -f 'rfriends.d' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rfriends.d'\"
else
echo shar: Extracting \"'rfriends.d'\" \(908 characters\)
sed "s/^X//" >'rfriends.d' <<'END_OF_FILE'
X#!/bin/sh
X#########################################################################
X# file:         rfriends                                                #
X#                                                                       #
X# object:       are any of my friends on the system?                    #
X#                                                                       #
X# Erik Quanstrom                                                        #
X# 19. Mai 1992                                                          #
X#########################################################################
h=/home/accserv1/stub/e/quanstro
PATH=/bin:/usr/local/bin:$binpath
X
X$HOME/SPARCbin/rwho | nawk '
BEGIN {
X  x = 0;
X  while ( 1 == (getline < friends  ) ) {
X    for (i = 1; i <= NF; i++)
X	a[$i] = 1;
X  }
X  close(friends);
X}
X
X{
X  if (1 == a[$2] ) {
X    print $0;
X    continue;
X  }
X}' friends="$HOME"/.friends
X
END_OF_FILE
if test 908 -ne `wc -c <'rfriends.d'`; then
    echo shar: \"'rfriends.d'\" unpacked with wrong size!
fi
# end of 'rfriends.d'
fi
if test -f 'rw.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rw.1'\"
else
echo shar: Extracting \"'rw.1'\" \(1180 characters\)
sed "s/^X//" >'rw.1' <<'END_OF_FILE'
X.TH rw 1 "14. January 1992"
X.SH NAME
rw 0.90 \- reports on remote users 
X.IR tersly .
X.SH SYNOPSIS
rw [
X.I server 
X] [
X.I port
X]
X.SH DESCRIPTION
X.B Rw
connects to the server on the commmand line, or if no server is
given, the default server which is compiled in at make-time to find
out who's logged in.
X.B Rw
reports the first 16 characters of the machine name in square
brackets, then lists the users who are logged into that machine. Lines
are wrapped to eighty columns to make the output more readable.
X.SH BUGS
X.B Rw
assumes an 80 column display.
X
X.SH "SEE ALSO" 
X.BR friends (1), 
X.BR friends (5), 
X.BR fmood (1),
X.BR moodmail (1), 
X.BR mood (1), 
X.BR rw (1)
X
X.SH FILES
X.PD 0
X.TP 20
X.B ~/.friends
friends file
X.TP
X.B /etc/utmp
who is logged in
X.PD
X.SH AUTHOR
Copyright (C) 1991, 1992 by Erik Quanstrom
X
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.  This software is provided ``as is'' without express or
implied warranty.
X
END_OF_FILE
if test 1180 -ne `wc -c <'rw.1'`; then
    echo shar: \"'rw.1'\" unpacked with wrong size!
fi
# end of 'rw.1'
fi
if test -f 'rw.d' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rw.d'\"
else
echo shar: Extracting \"'rw.d'\" \(981 characters\)
sed "s/^X//" >'rw.d' <<'END_OF_FILE'
X#!/bin/sh
X#########################################################################
X# file:		rw							#
X#									#
X# object:	put rwho (1) output into a shorter format		#
X#									#
X# Copyright (C) 1992 Erik Quanstrom					#
X#									#
X# 22. Mai 1992								#
X#########################################################################
h=/home/accserv1/stub/e/quanstro
PATH=$h/SPARCbin:/bin:/usr/bin:/usr/ucb/bin
X
rwho $* | awk '
X
BEGIN { old = ""; }
X
X{
X  if ($1 != old)
X    {
X      if (old != "")
X	printf "\n";
X
X      printf "%s %s ", $1, $2;
X    }
X  else
X    {
X      printf "%s ", $2;
X    }
X
X  old = $1;
X}' | awk '
X{
X  linepos = length($1);
X  saved = sprintf("%s", $1);
X  
X  for (i = 2; i <= NF ; i++) 
X    {
X      if ( ( 1 + linepos + length($i)) > 79 ) 
X	{
X	  printf "%s\n", saved;
X	  saved = "                 ";
X	  linepos=17;
X	}
X
X      linepos += length($i);
X      saved = sprintf("%s %s", saved, $i);
X      linepos++;
X    }
X  
X  if (saved != "\t")
X    print saved;
X}'
X
X  
X
X
END_OF_FILE
if test 981 -ne `wc -c <'rw.d'`; then
    echo shar: \"'rw.d'\" unpacked with wrong size!
fi
# end of 'rw.d'
fi
if test -f 'rwho.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rwho.1'\"
else
echo shar: Extracting \"'rwho.1'\" \(1225 characters\)
sed "s/^X//" >'rwho.1' <<'END_OF_FILE'
X.TH rwho 1 "14. January 1992"
X.SH NAME
rwho 0.90 \- reports on remote users
X.SH SYNOPSIS
rwho [
X.IR server ] 
X[
X.I port
X]
X.SH DESCRIPTION
X.B Rwho
connects to the server on the commmand line, or if no server is
given, the default server which is compiled in at make-time to find
out who's logged in.
X.B Rwho 
reports the first 16 characters of the machine name in square
brackets, then the user name, the terminal and finally, in round
brackets, the machine from which the user has logged in.
X.SH BUGS
Haven't found any yet.
X
X.SH "SEE ALSO" 
X.BR friends (1), 
X.BR friends (5), 
X.BR moodmail (1), 
X.BR mood (1), 
X.BR fmood (1),
X.BR rw (1)
X.SH files
X.PD 0
X.TP 20
X.B ~/.friends
friends file
X.TP
X.B /etc/utmp
who is logged in
X.TP
X.B /etc/passwd
for users' names
X.TP
X.B /etc/ttytab
terminal locations
X.PD
X.SH AUTHOR
Copyright (C) 1991, 1992 by Erik Quanstrom
X
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.  This software is provided ``as is'' without express or
implied warranty.
X
END_OF_FILE
if test 1225 -ne `wc -c <'rwho.1'`; then
    echo shar: \"'rwho.1'\" unpacked with wrong size!
fi
# end of 'rwho.1'
fi
if test -f 'rwho.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rwho.c'\"
else
echo shar: Extracting \"'rwho.c'\" \(2087 characters\)
sed "s/^X//" >'rwho.c' <<'END_OF_FILE'
X/************************************************************************
X * file:        rwho.c							*
X * 									*
X * Object:	talk to the rwho server and get info			*
X * 									*
X * Copyright (C) Erik Quanstrom, 1992					*
X *									*
X * Erik Quanstrom							*
X * 23. Januar 1992							*
X ************************************************************************/
X#define DEFAULT_PORT 5002
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/file.h>
X#include <sys/socket.h>
X#include <netdb.h>
X#include <netinet/in.h>
X
X#define INFO_REQUESTs "*"
X
typedef struct sockaddr SOCK;
typedef struct sockaddr_in SOCK_IN;
X
void die(int status);
char *program;
X
X#ifndef SERVER
X#define SERVER "mari.acc.stolaf.edu"
X#endif
X
X/************************************************************************
X * function:	main()							*
X * 									*
X * object:	get info from the rwho daemon on the server		*
X * 									*
X * Erik Quanstrom 							*
X * 23. Januar 1992							*
X ************************************************************************/
int main ( int argc, char **argv, char **envp) 
X{
X  struct hostent *hp;
X  SOCK_IN *sin = (SOCK_IN *)malloc(sizeof(SOCK_IN));
X  int s,
X      c;
X
X  FILE *f;
X  
X  program = *argv;
X  
X  if (argc > 3 )
X    {
X      printf("usage: %s hostname [port-number]\n", *argv);
X      exit (1);
X    }
X  
X  if (!argv[1])
X    argv[1] = SERVER;
X  
X  if ( (sin->sin_addr.s_addr = inet_addr( argv[1] )) != -1)
X    sin->sin_family = AF_INET;
X  else
X    if (hp = gethostbyname(argv[1])) 
X      {
X	sin->sin_family = hp->h_addrtype;
X	bcopy(hp->h_addr, &sin->sin_addr, hp->h_length);
X      } 
X    else 
X      die(1);
X  
X  if ( argc > 2 )
X    sin->sin_port = htons( atoi(argv[2]));
X  else
X    sin->sin_port = htons( (int)DEFAULT_PORT );
X  
X  
X  if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
X    die(1);
X
X  if (connect(s, sin, sizeof(SOCK_IN)) < 0)
X    die(1);
X
X  write(s, INFO_REQUESTs, 1);
X      
X  if (!(f = fdopen(s, "r")))
X    die(1);
X  
X  while((c = getc(f)) != EOF)
X    putc(c, stdout);
X
X  return 0;
X}
X		 
void die(int status)
X{
X  perror( program );
X  exit (status);
X}
END_OF_FILE
if test 2087 -ne `wc -c <'rwho.c'`; then
    echo shar: \"'rwho.c'\" unpacked with wrong size!
fi
# end of 'rwho.c'
fi
if test -f 'theirmail.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'theirmail.1'\"
else
echo shar: Extracting \"'theirmail.1'\" \(1126 characters\)
sed "s/^X//" >'theirmail.1' <<'END_OF_FILE'
X.TH theirmail 1 " 17. January 1992"
X.SH NAME
theirmail 0.90 \- reports on other user's mail
X.SH SYNOPSIS
theirmail [-s
X.IR spool_dir ]
X.I user1 
X.IR user2 .\|.\|.
X.SH DESCRIPTION
XFor each user in its argument list, 
X.B theirmail
displays either
X.IP
X.BI "no mail for <" user ">
X.LP
or, if the user's mailbox has a positive size, 
X.IP
X.BI "<" user "> has mail (last recieved: <" date "> )"
X.LP
If the \-s flag is given, then 
X.I spool_dir 
is used instead of the default (usually /usr/spool/mail). 
X.SH BUGS
X.B Theirmail 
is too slow.
X.SH "SEE ALSO"
X.BR mood (1),
X.BR moodmail (1),
X.BR fmood (1),
X.BR ffriends (1),
X.BR friends (5),
X.BR geeks (1)
X
X.SH FILES
X.PD 0
X.TP 20
X.B /usr/spool/mail/*
mail files
X
X.SH AUTHOR
Copyright (C) 1991, 1992 by Erik Quanstrom
X
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.  This software is provided ``as is'' without express or
implied warranty.
END_OF_FILE
if test 1126 -ne `wc -c <'theirmail.1'`; then
    echo shar: \"'theirmail.1'\" unpacked with wrong size!
fi
# end of 'theirmail.1'
fi
if test -f 'theirmail.d' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'theirmail.d'\"
else
echo shar: Extracting \"'theirmail.d'\" \(1355 characters\)
sed "s/^X//" >'theirmail.d' <<'END_OF_FILE'
X#!/bin/sh
X#########################################################################
X#                             Theirmail                                 #
X#                    Produces one line of output                        #
X#                    for each argument (logname)                        #
X#			Assumes that no arg =				#
X#			    your log name				#
X#									#
X#                       Erik Walter Quanstrom,                          #
X#                         Jeffrey S. Marker                             #
X#                           Brett M. Rabe                               #
X#########################################################################
X#version 1.03
h=/usr/spool/mail
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:$h/SPARCbin
status=0;
X
case $1 in
X  -s) shift;
X      if test -z "${*}"; then
X        echo "usage: $0 [-s spool_dir] user1 user2 ..."
X        exit 1;
X      fi   
X   
X      h=$1;
X      if test '!' -d $h; then
X        echo "$0: $h is not a directory."
X        exit 1;
X      fi;
X
X      shift;;
esac;
X
if test -z "${*}"; then
X  $0 `whoami`;
X else
X  for user in ${*}; do
X    if test -s "$h"/"${user}"; then
X      echo -n "${user} has mail (last recieved: ";
X      ls -l "$h"/"${user}" |\
X	awk '{print $5" "$6" "$7")"}';
X    else
X      echo "no mail for ${user}."
X      status=1;
X    fi;
X  done;
fi;
X
exit $status;
END_OF_FILE
if test 1355 -ne `wc -c <'theirmail.d'`; then
    echo shar: \"'theirmail.d'\" unpacked with wrong size!
fi
# end of 'theirmail.d'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
