Newsgroups: comp.sources.unix
From: gray@antaire.com (Gray Watson)
Subject: v26i102: malloc - debugging version of malloc, V1.2.0, Part05/05
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: gray@antaire.com (Gray Watson)
Posting-Number: Volume 26, Issue 102
Archive-Name: malloc-1.2.0/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 5)."
# Contents:  configure.in dbg_tokens.h dbg_values.h heap.c heap.h
#   malloc.h malloc_dbg.c malloc_loc.h malloc_lp.c malloc_lp.h
#   malloc_str.c malloc_str.h sample.c version.h
# Wrapped by gray@toaster.antaire.com on Tue Apr  6 01:24:07 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'configure.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'configure.in'\"
else
echo shar: Extracting \"'configure.in'\" \(1711 characters\)
sed "s/^X//" >'configure.in' <<'END_OF_FILE'
Xdnl
Xdnl Process this file with autoconf to produce a configure script.
Xdnl Copyright 1992 by Gray Watson and the Antaire Corporation
Xdnl
XAC_INIT(malloc.c)
XAC_CONFIG_HEADER(conf.h)
Xdnl
Xecho Configuring for the malloc-debug library
Xecho .
Xecho checking programs:
XAC_PROG_CC
XAC_PROG_INSTALL
XAC_PROG_RANLIB
Xdnl
Xecho .
Xecho checking functions:
XAC_HAVE_FUNCS(bcmp bcopy memcmp memcpy memset)
Xdnl this is necessary because index is a m4 function
Xecho checking for _index
XAC_TEST_PROGRAM([
Xmain() { exit(0); }
Xt() {
X#ifdef __stub_index
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char index(); index();
X#endif
X }
X], [
XAC_DEFINE(HAVE_INDEX, 1)
X], [
XAC_DEFINE(HAVE_INDEX, 0)
X])
XAC_HAVE_FUNCS(rindex)
XAC_HAVE_FUNCS(strcat strcmp strlen strtok)
Xecho .
Xecho checking various functions for string checking
XAC_HAVE_FUNCS(bzero)
XAC_HAVE_FUNCS(memccpy memchr)
XAC_HAVE_FUNCS(strchr strrchr strcpy strncpy strcasecmp strncasecmp)
XAC_HAVE_FUNCS(strspn strcspn strncat strncmp strpbrk strstr)
Xdnl
Xecho .
Xecho PLEASE WATCH: checking for very important functionality:
XAC_HAVE_FUNCS(sbrk)
Xecho checking for heap ordering...
XAC_TEST_PROGRAM([
Xmain()
X{
X  char	* first, *next;
X  first = sbrk(1024);
X  next = sbrk(1024);
X  if (next > first)
X    exit(0);
X  else
X    exit(1);
X}
X], [
XAC_DEFINE(HEAP_GROWS_UP, 1)
Xecho '   FYI: your heap seems to grow up.'
X], [
XAC_DEFINE(HEAP_GROWS_UP, 0)
Xecho '   FYI: your heap seems to grow down.'
Xecho '   WARNING: the library has little support for this.'
X])
Xdnl
Xecho .
XAC_OUTPUT(Makefile)
Xecho .
Xecho Done!!
Xecho created conf.h and Makefile.
Xecho Please check-out Makefile and especially conf.h to make sure that
Xecho     sane configuration values were a result.
END_OF_FILE
if test 1711 -ne `wc -c <'configure.in'`; then
    echo shar: \"'configure.in'\" unpacked with wrong size!
fi
# end of 'configure.in'
fi
if test -f 'dbg_tokens.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dbg_tokens.h'\"
else
echo shar: Extracting \"'dbg_tokens.h'\" \(2293 characters\)
sed "s/^X//" >'dbg_tokens.h' <<'END_OF_FILE'
X/*
X * tokens attributes for the malloc_dbg program
X *
X * Copyright 1992 by Gray Watson and the Antaire Corporation
X *
X * This file is part of the malloc-debug package.
X *
X * This library is free software; you can redistribute it and/or
X * modify it under the terms of the GNU Library General Public
X * License as published by the Free Software Foundation; either
X * version 2 of the License, or (at your option) any later version.
X *
X * This library is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X * Library General Public License for more details.
X *
X * You should have received a copy of the GNU Library General Public
X * License along with this library (see COPYING-LIB); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * The author of the program may be contacted at gray.watson@antaire.com
X *
X * $Id: dbg_tokens.h,v 1.5 1993/04/05 22:30:04 gray Exp $
X */
X
X#ifndef __DBG_TOKENS_H__
X#define __DBG_TOKENS_H__
X
X#include "malloc.h"			/* for LOCAL and bool stuff */
X#include "dbg_values.h"			/* for debug codes */
X
Xtypedef struct {
X  char		*at_string;		/* attribute string */
X  int		at_value;		/* value for the item*/
X} attr_t;
X
XLOCAL	attr_t		attributes[] = {
X  { "none",			0 },
X  
X  { "log-stats",		DEBUG_LOG_STATS },
X  { "log-non-free",		DEBUG_LOG_NONFREE },
X  { "log-perror",		DEBUG_LOG_PERROR },
X  { "log-trans",		DEBUG_LOG_TRANS },
X  { "log-bad-pnt",		DEBUG_LOG_BAD_POINTER },
X  { "log-admin",		DEBUG_LOG_ADMIN },
X  { "log-blocks",		DEBUG_LOG_BLOCKS },
X  { "log-unknown",		DEBUG_LOG_UNKNOWN },
X  
X  { "check-fence",		DEBUG_CHECK_FENCE },
X  { "check-heap",		DEBUG_CHECK_HEAP },
X  { "check-lists",		DEBUG_CHECK_LISTS },
X  { "check-dblock",		DEBUG_CHECK_DBLOCK },
X  { "check-dblock-fence",	DEBUG_CHECK_DB_FENCE },
X  { "check-free",		DEBUG_CHECK_FREE },
X  { "check-funcs",		DEBUG_CHECK_FUNCS },
X  
X  { "realloc-copy",		DEBUG_REALLOC_COPY },
X  { "free-blank",		DEBUG_FREE_BLANK },
X  { "error-abort",		DEBUG_ERROR_ABORT },
X  { "alloc-blank",		DEBUG_ALLOC_BLANK },
X  { "heap-check-map",		DEBUG_HEAP_CHECK_MAP },
X  { "print-perror",		DEBUG_PRINT_PERROR },
X  
X  { NULL }
X};
X
X#endif /* ! __DBG_TOKENS_H__ */
END_OF_FILE
if test 2293 -ne `wc -c <'dbg_tokens.h'`; then
    echo shar: \"'dbg_tokens.h'\" unpacked with wrong size!
fi
# end of 'dbg_tokens.h'
fi
if test -f 'dbg_values.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dbg_values.h'\"
else
echo shar: Extracting \"'dbg_values.h'\" \(2848 characters\)
sed "s/^X//" >'dbg_values.h' <<'END_OF_FILE'
X/*
X * debug values for MALLOC_DEBUG and _malloc_debug
X *
X * Copyright 1992 by Gray Watson and the Antaire Corporation
X *
X * This file is part of the malloc-debug package.
X *
X * This library is free software; you can redistribute it and/or
X * modify it under the terms of the GNU Library General Public
X * License as published by the Free Software Foundation; either
X * version 2 of the License, or (at your option) any later version.
X *
X * This library is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X * Library General Public License for more details.
X *
X * You should have received a copy of the GNU Library General Public
X * License along with this library (see COPYING-LIB); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * The author of the program may be contacted at gray.watson@antaire.com
X *
X * $Id: dbg_values.h,v 1.3 1993/04/05 22:30:05 gray Exp $
X */
X
X#ifndef __DBG_VALUES_H__
X#define __DBG_VALUES_H__
X
X/*
X * special debug codes which detail what debug features are enabled
X */
X
X/* logging */
X#define DEBUG_LOG_STATS		BIT_FLAG(0)	/* generally log statistics */
X#define DEBUG_LOG_NONFREE	BIT_FLAG(1)	/* report non-freed pointers */
X#define DEBUG_LOG_PERROR	BIT_FLAG(2)	/* log perror problems */
X#define DEBUG_LOG_TRANS		BIT_FLAG(3)	/* log memory transactions */
X#define DEBUG_LOG_BAD_POINTER	BIT_FLAG(4)	/* log pointer info on error */
X#define DEBUG_LOG_ADMIN		BIT_FLAG(5)	/* log background admin info */
X#define DEBUG_LOG_BLOCKS	BIT_FLAG(6)	/* log blocks when heap-map */
X#define DEBUG_LOG_UNKNOWN	BIT_FLAG(7)	/* report unknown non-freed */
X
X/* checking */
X#define DEBUG_CHECK_FENCE	BIT_FLAG(10)	/* check fence-post errors  */
X#define DEBUG_CHECK_HEAP	BIT_FLAG(11)	/* examine heap adm structs */
X#define DEBUG_CHECK_LISTS	BIT_FLAG(12)	/* check the free lists */
X#define DEBUG_CHECK_DBLOCK	BIT_FLAG(13)	/* closely examine dblocks */
X#define DEBUG_CHECK_DB_FENCE	BIT_FLAG(14)	/* check fences for dblocks */
X#define DEBUG_CHECK_FREE	BIT_FLAG(15)	/* check free blocks of 0's */
X#define DEBUG_CHECK_FUNCS	BIT_FLAG(16)	/* check functions */
X
X/* misc */
X#define DEBUG_REALLOC_COPY	BIT_FLAG(20)	/* copy all reallocations */
X#define DEBUG_FREE_BLANK	BIT_FLAG(21)	/* write over free'd memory */
X#define DEBUG_ERROR_ABORT	BIT_FLAG(22)	/* abort on error else exit */
X#define DEBUG_ALLOC_BLANK	BIT_FLAG(23)	/* write over to-be-alloced */
X#define DEBUG_HEAP_CHECK_MAP	BIT_FLAG(24)	/* heap-map on heap-check */
X#define DEBUG_PRINT_PERROR	BIT_FLAG(25)	/* print errors to STDERR */
X
X/*
X * special flags that after being set or not/set and process start-up, cannot
X * be reset.
X */
X#define DEBUG_NOT_CHANGEABLE	(DEBUG_CHECK_FREE)
X
X#endif /* ! __DBG_VALUES_H__ */
END_OF_FILE
if test 2848 -ne `wc -c <'dbg_values.h'`; then
    echo shar: \"'dbg_values.h'\" unpacked with wrong size!
fi
# end of 'dbg_values.h'
fi
if test -f 'heap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'heap.c'\"
else
echo shar: Extracting \"'heap.c'\" \(2785 characters\)
sed "s/^X//" >'heap.c' <<'END_OF_FILE'
X/*
X * system specific memory routines
X *
X * Copyright 1992 by Gray Watson and the Antaire Corporation
X *
X * This file is part of the malloc-debug package.
X *
X * This library is free software; you can redistribute it and/or
X * modify it under the terms of the GNU Library General Public
X * License as published by the Free Software Foundation; either
X * version 2 of the License, or (at your option) any later version.
X *
X * This library is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X * Library General Public License for more details.
X *
X * You should have received a copy of the GNU Library General Public
X * License along with this library (see COPYING-LIB); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * The author of the program may be contacted at gray.watson@antaire.com
X */
X
X/*
X * These are the system/machine specific routines for allocating space on the
X * heap as well as reporting the current position of the heap.
X */
X
X#define MALLOC_DEBUG_DISABLE
X
X#include "malloc.h"
X#include "malloc_loc.h"
X
X#include "chunk.h"
X#include "compat.h"
X#include "conf.h"
X#include "error.h"
X#include "error_val.h"
X#include "heap.h"
X
X#if INCLUDE_RCS_IDS
XLOCAL	char	*rcs_id =
X  "$Id: heap.c,v 1.18 1993/04/05 01:29:03 gray Exp $";
X#endif
X
X/* external routines */
X#if HAVE_SBRK
XIMPORT	char		*sbrk(int incr);	/* to extend the heap */
X#define SBRK_ERROR	((char *)-1)		/* sbrk error code */
X#endif
X
X/* exported variables */
XEXPORT	char		*_heap_base = NULL;	/* base of our heap */
XEXPORT	char		*_heap_last = NULL;	/* end of our heap */
X
X/*
X * function to get SIZE memory bytes from the end of the heap
X */
XEXPORT	char	*_heap_alloc(unsigned int size)
X{
X  char		*ret = HEAP_ALLOC_ERROR;
X  
X#if HAVE_SBRK
X  ret = sbrk(size);
X  if (ret == SBRK_ERROR) {
X    malloc_errno = MALLOC_ALLOC_FAILED;
X    _malloc_perror("_heap_alloc");
X    ret = HEAP_ALLOC_ERROR;
X  }
X  else {
X    /* increment last pointer */
X    _heap_last += size;
X  }
X#endif
X  
X  return ret;
X}
X
X/*
X * return a pointer to the current end of the heap
X */
XEXPORT	char	*_heap_end(void)
X{
X  char		*ret = HEAP_ALLOC_ERROR;
X  
X#if HAVE_SBRK
X  ret = sbrk(0);
X  if (ret == SBRK_ERROR) {
X    malloc_errno = MALLOC_ALLOC_FAILED;
X    _malloc_perror("_heap_end");
X    ret = HEAP_ALLOC_ERROR;
X  }
X#endif
X  
X  return ret;
X}
X
X/*
X * initialize heap pointers
X */
XEXPORT	void	_heap_startup(void)
X{
X  _heap_base = _heap_last = _heap_end();
X}
X
X/*
X * align (by extending) _heap_base to BASE byte boundary
X */
XEXPORT	char	*_heap_align_base(int base)
X{
X  int	diff;
X  
X  diff = (long)_heap_base % base;
X  _heap_base += base - diff;
X  
X  return _heap_alloc(base - diff);
X}
END_OF_FILE
if test 2785 -ne `wc -c <'heap.c'`; then
    echo shar: \"'heap.c'\" unpacked with wrong size!
fi
# end of 'heap.c'
fi
if test -f 'heap.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'heap.h'\"
else
echo shar: Extracting \"'heap.h'\" \(2524 characters\)
sed "s/^X//" >'heap.h' <<'END_OF_FILE'
X/*
X * defines for the system specific memory routines
X *
X * Copyright 1992 by Gray Watson and the Antaire Corporation
X *
X * This file is part of the malloc-debug package.
X *
X * This library is free software; you can redistribute it and/or
X * modify it under the terms of the GNU Library General Public
X * License as published by the Free Software Foundation; either
X * version 2 of the License, or (at your option) any later version.
X *
X * This library is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X * Library General Public License for more details.
X *
X * You should have received a copy of the GNU Library General Public
X * License along with this library (see COPYING-LIB); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * The author of the program may be contacted at gray.watson@antaire.com
X *
X * $Id: heap.h,v 1.9 1993/03/26 09:16:41 gray Exp $
X */
X
X#ifndef __HEAP_H__
X#define __HEAP_H__
X
X#include "malloc.h"			/* for LOCAL and bool stuff */
X
X/*
X * error code returned by heap allocation routine
X */
X#define HEAP_ALLOC_ERROR	((char *)-1)
X
X/*
X * probably machine specific defines used for certain calculations
X */
X#if HEAP_GROWS_UP
X
X/* test whether pointer P is in the heap space */
X#define IS_IN_HEAP(p)		\
X  ((char *)(p) >= _heap_base && (char *)(p) < _heap_last)
X
X/* turn pointer P into a block index */
X#define WHICH_BLOCK(p)		(((p) - _heap_base) / BLOCK_SIZE)
X
X/* get a pointer to the memory block number C */
X#define BLOCK_POINTER(c)	(_heap_base + (c) * BLOCK_SIZE)
X
X/* test whether pointer P is on a block boundary */
X#define ON_BLOCK(p)		(((p) - _heap_base) % BLOCK_SIZE == 0)
X
X/* calculate the size of heap */
X#define HEAP_SIZE		(_heap_last - _heap_base)
X
X#endif
X
X/*<<<<<<<<<<  The below prototypes are auto-generated by fillproto */
X
XIMPORT	char		*_heap_base;  /* base of our heap */
X
XIMPORT	char		*_heap_last;  /* end of our heap */
X
X/*
X * function to get SIZE memory bytes from the end of the heap
X */
XIMPORT	char	*_heap_alloc(unsigned int size);
X
X/*
X * return a pointer to the current end of the heap
X */
XIMPORT	char	*_heap_end(void);
X
X/*
X * initialize heap pointers
X */
XIMPORT	void	_heap_startup(void);
X
X/*
X * align (by extending) _heap_base to BASE byte boundary
X */
XIMPORT	char	*_heap_align_base(int base);
X
X/*<<<<<<<<<<   This is end of the auto-generated output from fillproto. */
X
X#endif /* ! __HEAP_H__ */
END_OF_FILE
if test 2524 -ne `wc -c <'heap.h'`; then
    echo shar: \"'heap.h'\" unpacked with wrong size!
fi
# end of 'heap.h'
fi
if test -f 'malloc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'malloc.h'\"
else
echo shar: Extracting \"'malloc.h'\" \(9046 characters\)
sed "s/^X//" >'malloc.h' <<'END_OF_FILE'
X/*
X * defines for the malloc-debug library
X *
X * Copyright 1992 by Gray Watson and the Antaire Corporation
X *
X * This file is part of the malloc-debug package.
X *
X * This library is free software; you can redistribute it and/or
X * modify it under the terms of the GNU Library General Public
X * License as published by the Free Software Foundation; either
X * version 2 of the License, or (at your option) any later version.
X *
X * This library is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X * Library General Public License for more details.
X *
X * You should have received a copy of the GNU Library General Public
X * License along with this library (see COPYING-LIB); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * The author of the program may be contacted at gray.watson@antaire.com
X *
X * $Id: malloc.h,v 1.21 1993/04/06 04:48:09 gray Exp $
X */
X
X#ifndef __MALLOC_H__
X#define __MALLOC_H__
X
X/*
X * malloc function return codes
X */
X#define CALLOC_ERROR		0		/* error from calloc */
X#define MALLOC_ERROR		0		/* error from malloc */
X#define REALLOC_ERROR		0		/* error from realloc */
X
X#define FREE_ERROR		0		/* error from free */
X#define FREE_NOERROR		1		/* no error from free */
X
X#define MALLOC_VERIFY_ERROR	0		/* checks failed, error */
X#define MALLOC_VERIFY_NOERROR	1		/* checks passed, no error */
X
X/*
X * default values if _malloc_file and _malloc_line are not set
X */
X#define MALLOC_DEFAULT_FILE	"unknown"
X#define MALLOC_DEFAULT_LINE	0
X
X/*
X * global variable and procedure scoping for code readability
X */
X#undef	EXPORT
X#define	EXPORT
X
X#undef	IMPORT
X#define	IMPORT		extern
X
X#undef	LOCAL
X#define	LOCAL		static
X
X#if __GNUC__ < 2
X/*
X * prototype for memory copy.  needed for below macros.
X */
XIMPORT	char	*memcpy(char * to, char * from, int length);
X#endif
X
X/*
X * memory copy: copy SIZE bytes from pointer FROM to pointer TO
X */
X#define MEMORY_COPY(from, to, size)	(void)memcpy((char *)to, \
X						     (char *)from, size)
X
X/*
X * alloc macros to improve memory usage readibility...
X */
X#undef ALLOC
X#undef CALLOC
X#undef MALLOC
X#undef REALLOC
X#undef REMALLOC
X#undef FREE
X
X#define ALLOC(type, count) \
X  (type *)malloc((unsigned int)(sizeof(type) * (count)))
X
X#define MALLOC(size) \
X  (char *)malloc((unsigned int)(size))
X
X/* WARNING: notice that the arguments are REVERSED from normal calloc() */
X#define CALLOC(type, count) \
X  (type *)calloc((unsigned int)(count), (unsigned int)sizeof(type))
X
X#define REALLOC(ptr, type, count) \
X  (type *)realloc((char *)(ptr), (unsigned int)(sizeof(type) * (count)))
X
X#define REMALLOC(ptr, size) \
X  (char *)realloc((char *)(ptr), (unsigned int)(size))
X
X#define FREE(ptr) \
X  free((char *)(ptr))
X
X/*
X * some small allocation macros
X */
X
X#ifdef __GNUC__
X
X/*
X * duplicate BUF of SIZE bytes
X */
X#define BDUP(buf, size)	({ \
X			  char	*_ret; \
X			  int	_size = (size); \
X			   \
X			  _ret = MALLOC(_size); \
X			  if (_ret != NULL) \
X			    MEMORY_COPY((buf), _ret, _size); \
X			   \
X			  _ret; \
X			})
X
X/*
X * the strdup() function in macro form.  duplicate string STR
X */
X#define STRDUP(str)	({ \
X			  const char *_strp = (str); \
X			  char	*_ret; \
X			  int	_len; \
X			   \
X			  _len = strlen(_strp); \
X			  _ret = MALLOC(_len + 1); \
X			  if (_ret != NULL) \
X			    MEMORY_COPY(_strp, _ret, _len + 1); \
X			   \
X			  _ret; \
X			})
X
X#else /* ! __GNUC__ */
X
X/*
X * duplicate BUF of SIZE and return the new address in OUT
X */
X#define BDUP(buf, size, out)	do { \
X				  char	*_ret; \
X				  int	_size = (size); \
X				   \
X				  _ret = MALLOC(_size); \
X				  if (_ret != NULL) \
X				    MEMORY_COPY((buf), _ret, _size); \
X				   \
X				  (out) = _ret; \
X				} while(0)
X
X/*
X * strdup() in macro form.  duplicate string STR and return a copy in OUT
X */
X#define STRDUP(str, out)	do { \
X				  const char *_strp = (str); \
X				  char	*_ret; \
X				  int	_len; \
X				   \
X				  _len = strlen(_strp); \
X				  _ret = MALLOC(_len + 1); \
X				  if (_ret != NULL) \
X				    MEMORY_COPY(_strp, _ret, _len + 1); \
X				   \
X				  (out) = _ret; \
X				} while(0)
X
X#endif /* ! __GNUC__ */
X
X/*<<<<<<<<<<  The below prototypes are auto-generated by fillproto */
X
X/* logfile for dumping malloc info, MALLOC_LOGFILE env. var overrides this */
XIMPORT	char		*malloc_logpath;
X
X/* internal malloc error number for reference purposes only */
XIMPORT	int		malloc_errno;
X
X/*
X * shutdown memory-allocation module, provide statistics if necessary
X */
XIMPORT	void	malloc_shutdown(void);
X
X/*
X * allocate and return a SIZE block of bytes
X */
XIMPORT	char	*malloc(unsigned int size);
X
X/*
X * allocate and return a block of bytes able to hold NUM_ELEMENTS of elements
X * of SIZE bytes and zero the block
X */
XIMPORT	char	*calloc(unsigned int num_elements, unsigned int size);
X
X/*
X * resizes OLD_PNT to SIZE bytes and return the new space after either copying
X * all of OLD_PNT to the new area or truncating
X */
XIMPORT	char	*realloc(char * old_pnt, unsigned int new_size);
X
X/*
X * release PNT in the heap, returning FREE_[NO]ERROR
X */
XIMPORT	int	free(char * pnt);
X
X/*
X * call through to _heap_map function, returns [NO]ERROR
X */
XIMPORT	int	malloc_heap_map(void);
X
X/*
X * verify pointer PNT, if PNT is 0 then check the entire heap.
X * returns MALLOC_VERIFY_[NO]ERROR
X */
XIMPORT	int	malloc_verify(char * pnt);
X
X/*
X * set the global debug functionality flags to DEBUG (0 to disable).
X * returns [NO]ERROR
X */
XIMPORT	int	malloc_debug(int debug);
X
X/*
X * examine pointer PNT and returns SIZE, and FILE / LINE info on it
X * if any of the pointers are not NULL.
X * returns NOERROR or ERROR depending on whether PNT is good or not
X */
XIMPORT	int	malloc_examine(char * pnt, unsigned int * size,
X			       char ** file, unsigned int * line);
X
X/*
X * malloc version of strerror to return the string version of ERRNUM
X * returns the string for MALLOC_BAD_ERRNO if ERRNUM is out-of-range.
X */
XIMPORT	char	*malloc_strerror(int errnum);
X
X/*<<<<<<<<<<   This is end of the auto-generated output from fillproto. */
X
X/*
X * alloc macros to provide for memory FILE/LINE debugging information.
X */
X
X#ifndef MALLOC_DEBUG_DISABLE
X
X#define malloc(size) \
X  _malloc_leap(__FILE__, __LINE__, size)
X#define calloc(count, size) \
X  _calloc_leap(__FILE__, __LINE__, count, size)
X#define realloc(ptr, size) \
X  _realloc_leap(__FILE__, __LINE__, ptr, size)
X#define free(ptr) \
X  _free_leap(__FILE__, __LINE__, ptr)
X
X#ifdef MALLOC_FUNC_CHECK
X
X/*
X * do debugging on the following functions.  this may cause compilation or
X * other problems depending on your architecture, hence the need for the
X * MALLOC_STRING_DISABLE define.
X */
X#define bcmp(b1, b2, len)		_malloc_bcmp(b1, b2, len)
X#define bcopy(from, to, len)		_malloc_bcopy(from, to, len)
X
X#define memcmp(b1, b2, len)		_malloc_memcmp(b1, b2, len)
X#define memcpy(to, from, len)		_malloc_memcpy(to, from, len)
X#define memset(buf, ch, len)		_malloc_memset(buf, ch, len)
X
X#define index(str, ch)			_malloc_index(str, ch)
X#define rindex(str, ch)			_malloc_rindex(str, ch)
X
X#define strcat(to, from)		_malloc_strcat(to, from)
X#define strcmp(s1, s2)			_malloc_strcmp(s1, s2)
X#define strlen(str)			_malloc_strlen(str)
X#define strtok(str, sep)		_malloc_strtok(str, sep)
X
X#define bzero(buf, len)			_malloc_bzero(buf, len)
X
X#define memccpy(s1, s2, ch, len)	_malloc_memccpy(s1, s2, ch, len)
X#define memchr(s1, ch, len)		_malloc_memchr(s1, ch, len)
X
X#define strchr(str, ch)			_malloc_strchr(str, ch)
X#define strrchr(str, ch)		_malloc_strrchr(str, ch)
X
X#define strcpy(to, from)		_malloc_strcpy(to, from)
X#define strncpy(to, from, len)		_malloc_strncpy(to, from, len)
X#define strcasecmp(s1, s2)		_malloc_strcasecmp(s1, s2)
X#define strncasecmp(s1, s2, len)	_malloc_strncasecmp(s1, s2, len)
X#define strspn(str, list)		_malloc_strspn(str, list)
X#define strcspn(str, list)		_malloc_strcspn(str, list)
X#define strncat(to, from, len)		_malloc_strncat(to, from, len)
X#define strncmp(s1, s2, len)		_malloc_strncmp(s1, s2, len)
X#define strpbrk(str, list)		_malloc_strpbrk(str, list)
X#define strstr(str, pat)		_malloc_strstr(str, pat)
X
X/*
X * feel free to add your favorite functions here and to malloc_str.[ch]
X */
X
X#endif /* MALLOC_FUNC_CHECK */
X
X/*
X * copied directly from malloc_lp.h
X */
X
X/* to inform the malloc-debug library from which file the call comes from */
XIMPORT	char		*_malloc_file;
X
X/* to inform the library from which line-number the call comes from */
XIMPORT	unsigned int	_malloc_line;
X
X/*
X * leap routine to calloc
X */
XIMPORT	char	*_calloc_leap(const char * file, const int line,
X			      unsigned int elen, unsigned int size);
X
X/*
X * leap routine to free
X */
XIMPORT	int	_free_leap(const char * file, const int line, char * pnt);
X
X/*
X * leap routine to malloc
X */
XIMPORT	char	*_malloc_leap(const char * file, const int line,
X			      unsigned int size);
X
X/*
X * leap routine to realloc
X */
XIMPORT	char	*_realloc_leap(const char * file, const int line, char * oldp,
X			       unsigned int new_size);
X
X#endif /* MALLOC_DEBUG_DISABLE */
X
X#endif /* ! __MALLOC_H__ */
END_OF_FILE
if test 9046 -ne `wc -c <'malloc.h'`; then
    echo shar: \"'malloc.h'\" unpacked with wrong size!
fi
# end of 'malloc.h'
fi
if test -f 'malloc_dbg.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'malloc_dbg.c'\"
else
echo shar: Extracting \"'malloc_dbg.c'\" \(13170 characters\)
sed "s/^X//" >'malloc_dbg.c' <<'END_OF_FILE'
X/*
X * program that handles the malloc debug variables.
X *
X * Copyright 1992 by Gray Watson and the Antaire Corporation
X *
X * This file is part of the malloc-debug package.
X *
X * This library is free software; you can redistribute it and/or
X * modify it under the terms of the GNU Library General Public
X * License as published by the Free Software Foundation; either
X * version 2 of the License, or (at your option) any later version.
X *
X * This library is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X * Library General Public License for more details.
X *
X * You should have received a copy of the GNU Library General Public
X * License along with this library (see COPYING-LIB); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * The author of the program may be contacted at gray.watson@antaire.com
X */
X
X/*
X * This is the malloc_dbg program which is designed to enable the user
X * to easily enable the multitude of malloc-debug capabilities.
X *
X * NOTE: all stdout output from this program is designed to be run through
X *   eval by default.  Any messages for the user should be fprintf to stderr.
X */
X
X#include <stdarg.h>				/* for vsprintf handling */
X#include <stdio.h>				/* for stderr */
X
X#define MALLOC_DEBUG_DISABLE
X
X#include "malloc.h"
X#include "malloc_loc.h"
X
X#include "compat.h"
X#include "conf.h"
X#include "dbg_tokens.h"
X#include "version.h"
X
X#if INCLUDE_RCS_IDS
XLOCAL	char	*rcs_id =
X  "$Id: malloc_dbg.c,v 1.6 1993/04/06 04:24:39 gray Exp $";
X#endif
X
X#define HOME_ENVIRON	"HOME"			/* home directory */
X#define DEFAULT_CONFIG	"%s/.mallocrc"		/* default config file */
X#define TOKENIZE_CHARS	" \t,="			/* for tag lines */
X
X#define USAGE_STRING	"--usage"		/* show the usage message */
X#define VERSION_STRING	"--version"		/* show the version message */
X#define NO_VALUE	(-1)			/* no value ... value */
X
X/* local variables */
XLOCAL	char	printed		= FALSE;	/* did we outputed anything? */
XLOCAL	char	*program	= NULL;		/* our program name */
X
X/* argument variables */
XLOCAL	char	*address	= NULL;		/* for ADDRESS */
XLOCAL	char	bourne		= FALSE;	/* set bourne shell output */
XLOCAL	char	clear		= FALSE;	/* clear variables */
XLOCAL	int	debug		= NO_VALUE;	/* for DEBUG */
XLOCAL	int	errno_to_print	= NO_VALUE;	/* to print the error string */
XLOCAL	char	*inpath		= NULL;		/* for config-file path */
XLOCAL	int	interval	= NO_VALUE;	/* for setting INTERVAL */
XLOCAL	char	*logpath	= NULL;		/* for LOGFILE setting */
XLOCAL	char	*start		= NULL;		/* for START settings */
XLOCAL	char	*tag		= NULL;		/* the debug tag */
X
X/*
X * hexadecimal STR to long translation
X */
XLOCAL	int	hex_to_int(char * str)
X{
X  int		ret;
X  
X  /* strip off spaces */
X  for (; *str == ' ' || *str == '\t'; str++);
X  
X  /* skip a leading 0[xX] */
X  if (*str == '0' && (*(str + 1) == 'x' || *(str + 1) == 'X'))
X    str += 2;
X  
X  for (ret = 0;; str++) {
X    if (*str >= '0' && *str <= '9')
X      ret = ret * 16 + (*str - '0');
X    else if (*str >= 'a' && *str <= 'f')
X      ret = ret * 16 + (*str - 'a' + 10);
X    else if (*str >= 'A' && *str <= 'F')
X      ret = ret * 16 + (*str - 'A' + 10);
X    else
X      break;
X  }
X  
X  return ret;
X}
X
X/*
X * print a usage message for the program.
X */
XLOCAL	void	usage(void)
X{
X  (void)fprintf(stderr,	"Usage: %s\n", program);
X  (void)fprintf(stderr,	"  [-a address:#]    = stop when malloc sees address "
X		"[for #th time] %%s\n");
X  (void)fprintf(stderr,	"  [-b]              = set the output for bourne "
X		"shells (sh, ksh) %%t\n");
X  (void)fprintf(stderr,	"  [-c]              = clear all variables not "
X		"specified %%t\n");
X  (void)fprintf(stderr,	"  [-d bitmask]      = hex flag to directly set debug "
X		"mask %%x\n");
X  (void)fprintf(stderr,	"  [-e errno]        = print the error string for "
X		"errno %%d\n");
X  (void)fprintf(stderr,	"  [-f file]         = config file to read from when "
X		"not ~/.mallocrc %%s\n");
X  (void)fprintf(stderr, "  [-i number]       = check heap every number times "
X		"%%d\n");
X  (void)fprintf(stderr,	"  [-l file]         = file to log messages to %%s\n");
X  (void)fprintf(stderr, "  [-s file:line]    = start checking heap after "
X		"seeing file [and line] %%s\n");
X  (void)fprintf(stderr, "  [tag]             = debug token to find in mallocrc"
X		"\n");
X  (void)fprintf(stderr, "if no arguments are specified then it dumps the "
X		"current env setings.\n");
X}
X
X/*
X * process the command-line arguments
X * I've got a great library to do this automatically.  sigh.
X */
XLOCAL	void	process_arguments(int argc, char ** argv)
X{
X  program = rindex(*argv, '/');
X  if (program == NULL)
X    program = *argv;
X  else
X    program++;
X  
X  argc--, argv++;
X  
X  for (; argc > 0; argc--, argv++) {
X    
X    /* special usage message */
X    if (strcmp(*argv, USAGE_STRING) == 0) {
X      usage();
X      exit(0);
X    }
X    
X    /* special version message */
X    if (strcmp(*argv, VERSION_STRING) == 0) {
X      (void)fprintf(stderr, "Version '%s'\n", malloc_version);
X      exit(0);
X    }
X    
X    /* if no - then assume it is the tag */
X    if (**argv != '-') {
X      if (tag != NULL) {
X	(void)fprintf(stderr,
X		      "Usage problem: debug-tag was already specified\n");
X	usage();
X	exit(1);
X      }
X      tag = *argv;
X      continue;
X    }
X    
X    /* can only handle -a not -ab */
X    if ((*argv)[1] == NULLC || (*argv)[2] != NULLC) {
X      (void)fprintf(stderr, "Usage problem: incorrect argument format '%s'\n",
X		    *argv);
X      usage();
X      exit(1);
X    }
X    
X    switch ((*argv)[1]) {
X      
X    case 'a':
X      argc--, argv++;
X      if (argc == 0) {
X	(void)fprintf(stderr, "Usage problem: missing argument to -a\n");
X	usage();
X	exit(1);
X      }
X      address = *argv;
X      break;
X      
X    case 'b':
X      bourne = TRUE;
X      break;
X      
X    case 'c':
X      clear = TRUE;
X      break;
X      
X    case 'd':
X      argc--, argv++;
X      if (argc == 0) {
X	(void)fprintf(stderr, "Usage problem: missing argument to -d\n");
X	usage();
X	exit(1);
X      }
X      debug = hex_to_int(*argv);
X      break;
X      
X    case 'e':
X      argc--, argv++;
X      if (argc == 0) {
X	(void)fprintf(stderr, "Usage problem: missing argument to -e\n");
X	usage();
X	exit(1);
X      }
X      errno_to_print = atoi(*argv);
X      break;
X      
X    case 'f':
X      argc--, argv++;
X      if (argc == 0) {
X	(void)fprintf(stderr, "Usage problem: missing argument to -f\n");
X	usage();
X	exit(1);
X      }
X      inpath = *argv;
X      break;
X      
X    case 'i':
X      argc--, argv++;
X      if (argc == 0) {
X	(void)fprintf(stderr, "Usage problem: missing argument to -i\n");
X	usage();
X	exit(1);
X      }
X      interval = atoi(*argv);
X      break;
X      
X    case 'l':
X      argc--, argv++;
X      if (argc == 0) {
X	(void)fprintf(stderr, "Usage problem: missing argument to -l\n");
X	usage();
X	exit(1);
X      }
X      logpath = *argv;
X      break;
X      
X    case 's':
X      argc--, argv++;
X      if (argc == 0) {
X	(void)fprintf(stderr, "Usage problem: missing argument to -s\n");
X	usage();
X	exit(1);
X      }
X      start = *argv;
X      break;
X      
X    default:
X      (void)fprintf(stderr, "Usage problem: unknown argument '%s'\n", *argv);
X      usage();
X      exit(1);
X      break;
X    }
X  }
X}
X
X/*
X * process the user configuration looking for the tag.  if tag is null then
X * look for DEBUG_VALUE in the file and return the token for it in STR.
X * routine returns the new debug value matching tag.
X */
XLOCAL	int	process(int debug_value, char ** strp)
X{
X  static char	token[128];
X  FILE		*infile = NULL;
X  char		path[1024], buf[1024], *homep;
X  char		found, cont;
X  int		new_debug = 0;
X  
X  /* do we need to have a home variable? */
X  if (inpath == NULL) {
X    homep = (char *)getenv(HOME_ENVIRON);
X    if (homep == NULL) {
X      (void)fprintf(stderr, "%s: could not find variable '%s'\n",
X		    program, HOME_ENVIRON);
X      exit(1);
X    }
X    
X    (void)sprintf(path, DEFAULT_CONFIG, homep);
X    inpath = path;
X  }
X  
X  infile = fopen(inpath, "r");
X  if (infile == NULL) {
X    (void)fprintf(stderr, "%s: could not read '%s': ", program, inpath);
X    (void)perror("");
X    exit(1);
X  }
X  
X  /* read each of the lines looking for the tag */
X  found = FALSE;
X  cont = FALSE;
X  
X  while (fgets(buf, sizeof(buf), infile) != NULL) {
X    int		attrc;
X    char	*tokp, *endp;
X    
X    /* ignore comments and empty lines */
X    if (buf[0] == '#' || buf[0] == '\n')
X      continue;
X    
X    /* chop off the ending \n */
X    endp = rindex(buf, '\n');
X    if (endp != NULL)
X      *endp = NULLC;
X    
X    tokp = strtok(buf, TOKENIZE_CHARS);
X    
X    /* if we're not continuing then we need to process a tag */
X    if (! cont) {
X      (void)strcpy(token, tokp);
X      new_debug = 0;
X      
X      if (tag != NULL && strcmp(tag, tokp) == 0)
X	found = TRUE;
X      
X      tokp = strtok(NULL, TOKENIZE_CHARS);
X    }
X    
X    cont = FALSE;
X    
X    do {
X      /* do we have a continuation character */
X      if (strcmp(tokp, "\\") == 0) {
X	cont = TRUE;
X	break;
X      }
X      
X      /* are we processing the tag of choice? */
X      if (found || tag == NULL) {
X	for (attrc = 0; attributes[attrc].at_string != NULL; attrc++) {
X	  if (strcmp(tokp, attributes[attrc].at_string) == 0)
X	    break;
X	}
X	
X	if (attributes[attrc].at_string == NULL) {
X	  (void)fprintf(stderr, "%s: unknown token '%s'\n",
X			program, tokp);
X	}
X	else
X	  new_debug |= attributes[attrc].at_value;
X      }
X      
X      tokp = strtok(NULL, TOKENIZE_CHARS);
X    } while (tokp != NULL);
X    
X    if (tag == NULL && ! cont && new_debug == debug_value) {
X      found = TRUE;
X      if (strp != NULL)
X	*strp = token;
X      break;
X    }
X    
X    /* are we done? */
X    if (found && ! cont)
X      break;
X  }
X  
X  (void)fclose(infile);
X  
X  /* did we find the correct value in the file? */
X  if (tag == NULL && ! found) {
X    if (strp != NULL)
X      *strp = "unknown";
X  }
X  else if (! found && tag != NULL) {
X    (void)fprintf(stderr, "%s: could not find tag '%s' in '%s'\n",
X		  program, tag, inpath);
X    exit(1);
X  }
X  
X  return new_debug;
X}
X
X/*
X * dump the current settings of the malloc variables
X */
XLOCAL	void	dump_current(void)
X{
X  char		*str;
X  int		num;
X  
X  str = (char *)getenv(DEBUG_ENVIRON);
X  if (str == NULL)
X    (void)fprintf(stderr, "%s not set\n", DEBUG_ENVIRON);
X  else {
X    num = hex_to_int(str);
X    (void)process(num, &str);
X    (void)fprintf(stderr, "%s == '%#lx' (%s)\n", DEBUG_ENVIRON, num, str);
X  }
X  
X  str = (char *)getenv(ADDRESS_ENVIRON);
X  if (str == NULL)
X    (void)fprintf(stderr, "%s not set\n", ADDRESS_ENVIRON);
X  else
X    (void)fprintf(stderr, "%s == '%s'\n", ADDRESS_ENVIRON, str);
X  
X  str = (char *)getenv(INTERVAL_ENVIRON);
X  if (str == NULL)
X    (void)fprintf(stderr, "%s not set\n", INTERVAL_ENVIRON);
X  else {
X    num = atoi(str);
X    (void)fprintf(stderr, "%s == '%d'\n", INTERVAL_ENVIRON, num);
X  }
X  
X  str = (char *)getenv(LOGFILE_ENVIRON);
X  if (str == NULL)
X    (void)fprintf(stderr, "%s not set\n", LOGFILE_ENVIRON);
X  else
X    (void)fprintf(stderr, "%s == '%s'\n", LOGFILE_ENVIRON, str);
X  
X  str = (char *)getenv(START_ENVIRON);
X  if (str == NULL)
X    (void)fprintf(stderr, "%s not set\n", START_ENVIRON);
X  else
X    (void)fprintf(stderr, "%s == '%s'\n", START_ENVIRON, str);
X}
X
X/*
X * output the code to set env VAR to VALUE using printf FORMAT
X */
XLOCAL	void	set_variable(char * var, char * format, ...)
X{
X  char		value[256];
X  va_list	args;
X  
X  /* write the format + info into str */
X  va_start(args, format);
X  (void)vsprintf(value, format, args);
X  va_end(args);
X  
X  if (bourne)
X    (void)printf("%s=%s; export %s;\n", var, value, var);
X  else
X    (void)printf("setenv %s %s;\n", var, value);
X  
X  printed = TRUE;
X}
X
X/*
X * output the code to un-set env VAR
X */
XLOCAL	void	unset_variable(char * var)
X{
X  if (bourne)
X    (void)printf("unset %s;\n", var);
X  else
X    (void)printf("unsetenv %s;\n", var);
X  
X  printed = TRUE;
X}
X
XEXPORT	int	main(int argc, char ** argv)
X{
X  /* turn off debugging for this program */
X  (void)malloc_debug(0);
X  
X  process_arguments(argc, argv);
X  
X  /* get a new debug value from tag */
X  if (tag != NULL) {
X    if (debug != NO_VALUE)
X      (void)fprintf(stderr, "%s: warning -d option ignored, processing tag "
X		    "'%s'\n",
X		    program, tag);
X    debug = process(0, NULL);
X  }
X  
X  if (tag != NULL || debug != NO_VALUE)
X    set_variable(DEBUG_ENVIRON, "%#lx", debug);
X  
X  if (address != NULL)
X    set_variable(ADDRESS_ENVIRON, "%s", address);
X  else if (clear)
X    unset_variable(ADDRESS_ENVIRON);
X  
X  if (interval != NO_VALUE)
X    set_variable(INTERVAL_ENVIRON, "%d", interval);
X  else if (clear)
X    unset_variable(INTERVAL_ENVIRON);
X  
X  if (logpath != NULL)
X    set_variable(LOGFILE_ENVIRON, "%s", logpath);
X  else if (clear)
X    unset_variable(LOGFILE_ENVIRON);
X  
X  if (start != NULL)
X    set_variable(START_ENVIRON, "%s", start);
X  else if (clear)
X    unset_variable(START_ENVIRON);
X  
X  if (errno_to_print != NO_VALUE) {
X    (void)fprintf(stderr, "%s: malloc_errno value '%d' = \n",
X		  program, errno_to_print);
X    (void)fprintf(stderr, "   '%s'\n", malloc_strerror(errno_to_print));
X  }
X  else if (! printed)
X    dump_current();
X  
X  exit(0);
X}
END_OF_FILE
if test 13170 -ne `wc -c <'malloc_dbg.c'`; then
    echo shar: \"'malloc_dbg.c'\" unpacked with wrong size!
fi
# end of 'malloc_dbg.c'
fi
if test -f 'malloc_loc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'malloc_loc.h'\"
else
echo shar: Extracting \"'malloc_loc.h'\" \(2622 characters\)
sed "s/^X//" >'malloc_loc.h' <<'END_OF_FILE'
X/*
X * local definitions for the user allocation level
X *
X * Copyright 1992 by Gray Watson and the Antaire Corporation
X *
X * This file is part of the malloc-debug package.
X *
X * This library is free software; you can redistribute it and/or
X * modify it under the terms of the GNU Library General Public
X * License as published by the Free Software Foundation; either
X * version 2 of the License, or (at your option) any later version.
X *
X * This library is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X * Library General Public License for more details.
X *
X * You should have received a copy of the GNU Library General Public
X * License along with this library (see COPYING-LIB); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * The author of the program may be contacted at gray.watson@antaire.com
X *
X * $Id: malloc_loc.h,v 1.15 1993/03/26 09:16:50 gray Exp $
X */
X
X#ifndef __MALLOC_LOC_H__
X#define __MALLOC_LOC_H__
X
X/* fence post checking defines */
X#define FENCE_BOTTOM		(1 << ALLOCATION_ALIGNMENT_IN_BITS)
X#define FENCE_TOP		sizeof(long)
X#define FENCE_OVERHEAD		(FENCE_BOTTOM + FENCE_TOP)
X#define FENCE_MAGIC_BASE	0xC0C0AB1B
X#define FENCE_MAGIC_TOP		0xFACADE69
X
X/*
X * env variables
X */
X#define ADDRESS_ENVIRON		"MALLOC_ADDRESS"
X#define DEBUG_ENVIRON		"MALLOC_DEBUG"
X#define INTERVAL_ENVIRON	"MALLOC_INTERVAL"
X#define LOGFILE_ENVIRON		"MALLOC_LOGFILE"
X#define START_ENVIRON		"MALLOC_START"
X
X/******************************* useful defines ******************************/
X
X/*
X * standard int return codes
X */
X#undef	ERROR
X#define	ERROR		(-1)
X
X#undef	NOERROR
X#define	NOERROR		0
X
X/*
X * generic constants
X */
X#undef	NULL
X#define NULL		0
X
X#undef	NULLC
X#define NULLC		'\0'
X
X#undef	FALSE
X#define FALSE		0
X
X#undef	TRUE
X#define TRUE		(! FALSE)
X
X/*
X * standard i/o file descriptors
X */
X#undef	STDIN
X#define	STDIN		0		/* fileno(stdin) */
X
X#undef	STDOUT
X#define	STDOUT		1		/* fileno(stdout) */
X
X#undef	STDERR
X#define	STDERR		2		/* fileno(stderr) */
X
X/*
X * min/max macros
X *
X * WARNING: these use their arguments multiple times which may be bad
X */
X#undef MAX
X#define MAX(a,b)	(((a) > (b)) ? (a) : (b))
X#undef MIN
X#define MIN(a,b)	(((a) < (b)) ? (a) : (b))
X
X/*
X * bitflag tools for Variable and a Flag
X */
X#undef BIT_FLAG
X#define BIT_FLAG(x)		(1 << (x))
X#undef BIT_SET
X#define BIT_SET(v,f)		(v) |= (f)
X#undef BIT_CLEAR
X#define BIT_CLEAR(v,f)		(v) &= ~(f)
X#undef BIT_IS_SET
X#define BIT_IS_SET(v,f)		((v) & (f))
X
X#endif /* ! __MALLOC_LOC_H__ */
END_OF_FILE
if test 2622 -ne `wc -c <'malloc_loc.h'`; then
    echo shar: \"'malloc_loc.h'\" unpacked with wrong size!
fi
# end of 'malloc_loc.h'
fi
if test -f 'malloc_lp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'malloc_lp.c'\"
else
echo shar: Extracting \"'malloc_lp.c'\" \(4059 characters\)
sed "s/^X//" >'malloc_lp.c' <<'END_OF_FILE'
X/*
X * leap-frog point to allow malloc-debug on/off via relink.
X *
X * Copyright 1992 by Gray Watson and the Antaire Corporation
X *
X * This file is part of the malloc-debug package.
X *
X * This library is free software; you can redistribute it and/or
X * modify it under the terms of the GNU Library General Public
X * License as published by the Free Software Foundation; either
X * version 2 of the License, or (at your option) any later version.
X *
X * This library is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X * Library General Public License for more details.
X *
X * You should have received a copy of the GNU Library General Public
X * License along with this library (see COPYING-LIB); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * The author of the program may be contacted at gray.watson@antaire.com
X */
X
X/*
X * If anyone can think of a better way to do this *please* let me know.
X *
X * The goal is to allow people to use the debug library during development
X * and then disable and return to the system (or more efficient) malloc
X * functions by just relinking with another library.
X *
X * The problem is that we want to provide the library with file/line
X * information with each call.  Backtracing the stack-frame is neither
X * portable or necessarily easy so the cpp __FILE__ and __LINE__ directives
X * are used instead.  But how to pass this information to the library is
X * the challange.  How can we do this in a graceful and sane manner while
X * still providing the "quick-release" functionality above?
X *
X * I have decided on this leap-frog file that will have to *always* be
X * compiled in.  It will have the special _malloc_file and _malloc_line
X * variables and will set them whether malloc-debug routines are linked
X * in to use them or not.
X *
X * This *will* mean an extra function call per memory interaction but on
X * most systems this is pretty cheap.  It will also mean that this file
X * needs to be compiled into your programs whether or not they use the
X * debug library unless you want to recompile all .c files with
X * -DMALLOC_DEBUG_DISABLE.
X *
X * Please mail me with any reasonable ideas.
X */
X
X#define MALLOC_DEBUG_DISABLE
X
X#include "malloc.h"
X
X#if INCLUDE_RCS_IDS
Xstatic	char	*rcs_id =
X  "$Id: malloc_lp.c,v 1.5 1993/04/01 04:59:25 gray Exp $";
X#endif
X
X/*
X * exported variables
X */
X/* to inform the malloc-debug library from which file the call comes from */
XEXPORT	char		*_malloc_file = MALLOC_DEFAULT_FILE;
X
X/* to inform the library from which line-number the call comes from */
XEXPORT	unsigned int	_malloc_line = MALLOC_DEFAULT_LINE;
X
X/*
X * leap routine to calloc
X */
XEXPORT	char	*_calloc_leap(const char * file, const int line,
X			      unsigned int elen, unsigned int size)
X{
X  char	*ret;
X  
X  _malloc_file = (char *)file;
X  _malloc_line = line;
X  
X  ret = calloc(elen, size);
X  
X  _malloc_file = MALLOC_DEFAULT_FILE;
X  _malloc_line = MALLOC_DEFAULT_LINE;
X  
X  return ret;
X}
X
X/*
X * leap routine to free
X */
XEXPORT	int	_free_leap(const char * file, const int line, char * pnt)
X{
X  int	ret;
X  
X  _malloc_file = (char *)file;
X  _malloc_line = line;
X  
X  ret = free(pnt);
X  
X  _malloc_file = MALLOC_DEFAULT_FILE;
X  _malloc_line = MALLOC_DEFAULT_LINE;
X  
X  return ret;
X}
X
X/*
X * leap routine to malloc
X */
XEXPORT	char	*_malloc_leap(const char * file, const int line,
X			      unsigned int size)
X{
X  char	*ret;
X  
X  _malloc_file = (char *)file;
X  _malloc_line = line;
X  
X  ret = malloc(size);
X  
X  _malloc_file = MALLOC_DEFAULT_FILE;
X  _malloc_line = MALLOC_DEFAULT_LINE;
X  
X  return ret;
X}
X
X/*
X * leap routine to realloc
X */
XEXPORT	char	*_realloc_leap(const char * file, const int line, char * oldp,
X			       unsigned int new_size)
X{
X  char	*ret;
X  
X  _malloc_file = (char *)file;
X  _malloc_line = line;
X  
X  ret = realloc(oldp, new_size);
X  
X  _malloc_file = MALLOC_DEFAULT_FILE;
X  _malloc_line = MALLOC_DEFAULT_LINE;
X  
X  return ret;
X}
END_OF_FILE
if test 4059 -ne `wc -c <'malloc_lp.c'`; then
    echo shar: \"'malloc_lp.c'\" unpacked with wrong size!
fi
# end of 'malloc_lp.c'
fi
if test -f 'malloc_lp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'malloc_lp.h'\"
else
echo shar: Extracting \"'malloc_lp.h'\" \(2034 characters\)
sed "s/^X//" >'malloc_lp.h' <<'END_OF_FILE'
X/*
X * defines for the malloc-leap routines.
X *
X * Copyright 1992 by Gray Watson and the Antaire Corporation
X *
X * This file is part of the malloc-debug package.
X *
X * This library is free software; you can redistribute it and/or
X * modify it under the terms of the GNU Library General Public
X * License as published by the Free Software Foundation; either
X * version 2 of the License, or (at your option) any later version.
X *
X * This library is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X * Library General Public License for more details.
X *
X * You should have received a copy of the GNU Library General Public
X * License along with this library (see COPYING-LIB); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * The author of the program may be contacted at gray.watson@antaire.com
X *
X * $Id: malloc_lp.h,v 1.3 1993/03/26 09:16:54 gray Exp $
X */
X
X#ifndef __MALLOC_LP_H__
X#define __MALLOC_LP_H__
X
X#undef	IMPORT
X#define	IMPORT		extern
X
X/*<<<<<<<<<<  The below prototypes are auto-generated by fillproto */
X
X/* to inform the malloc-debug library from which file the call comes from */
XIMPORT	char		*_malloc_file;
X
X/* to inform the library from which line-number the call comes from */
XIMPORT	unsigned int	_malloc_line;
X
X/*
X * leap routine to calloc
X */
XIMPORT	char	*_calloc_leap(const char * file, const int line,
X			      unsigned int elen, unsigned int size);
X
X/*
X * leap routine to free
X */
XIMPORT	int	_free_leap(const char * file, const int line, char * pnt);
X
X/*
X * leap routine to malloc
X */
XIMPORT	char	*_malloc_leap(const char * file, const int line,
X			      unsigned int size);
X
X/*
X * leap routine to realloc
X */
XIMPORT	char	*_realloc_leap(const char * file, const int line, char * oldp,
X			       unsigned int new_size);
X
X/*<<<<<<<<<<   This is end of the auto-generated output from fillproto. */
X
X#endif /* ! __MALLOC_LP_H__ */
END_OF_FILE
if test 2034 -ne `wc -c <'malloc_lp.h'`; then
    echo shar: \"'malloc_lp.h'\" unpacked with wrong size!
fi
# end of 'malloc_lp.h'
fi
if test -f 'malloc_str.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'malloc_str.c'\"
else
echo shar: Extracting \"'malloc_str.c'\" \(13374 characters\)
sed "s/^X//" >'malloc_str.c' <<'END_OF_FILE'
X/*
X * functions for testing of string routines arguments.
X *
X * Copyright 1992 by Gray Watson and the Antaire Corporation
X *
X * This file is part of the malloc-debug package.
X *
X * This library is free software; you can redistribute it and/or
X * modify it under the terms of the GNU Library General Public
X * License as published by the Free Software Foundation; either
X * version 2 of the License, or (at your option) any later version.
X *
X * This library is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X * Library General Public License for more details.
X *
X * You should have received a copy of the GNU Library General Public
X * License along with this library (see COPYING-LIB); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * The author of the program may be contacted at gray.watson@antaire.com
X */
X
X/*
X * This file contains functions to be used to verify the arguments of
X * string functions.   If enabled these can discover problems with
X * heap-based strings (such as fence errors) much closer to the error.
X */
X
X#define MALLOC_DEBUG_DISABLE
X
X#include "malloc.h"
X#include "malloc_loc.h"
X
X#include "conf.h"
X#include "chunk.h"
X#include "dbg_values.h"
X#include "error.h"
X#include "malloc_str.h"
X
X#if INCLUDE_RCS_IDS
XLOCAL	char	*rcs_id =
X  "$Id: malloc_str.c,v 1.3 1993/04/06 04:24:41 gray Exp $";
X#endif
X
X#if HAVE_BCMP
X/*
X * dummy function for checking bcmp's arguments.
X */
XEXPORT	int	_malloc_bcmp(void * b1, void * b2, int len)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("bcmp", b1, 1, len) != NOERROR
X	|| _chunk_pnt_check("bcmp", b2, 1, len) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in bcmp");
X  }
X  return bcmp(b1, b2, len);
X}
X#endif
X
X#if HAVE_BCOPY
X/*
X * dummy function for checking bcopy's arguments.
X */
XEXPORT	void	_malloc_bcopy(char * from, char * to, int len)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("bcopy", from, 1, len) != NOERROR
X	|| _chunk_pnt_check("bcopy", to, 1, len) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in bcopy");
X  }
X  bcopy(from, to, len);
X}
X#endif
X
X#if HAVE_MEMCMP
X/*
X * dummy function for checking memcmp's arguments.
X */
XEXPORT	int	_malloc_memcmp(void * b1,
X			       void * b2, int len)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("memcmp", b1, 1, len) != NOERROR
X	|| _chunk_pnt_check("memcmp", b2, 1, len) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in memcmp");
X  }
X  return memcmp(b1, b2, len);
X}
X#endif
X
X#if HAVE_MEMCPY
X/*
X * dummy function for checking memcpy's arguments.
X */
XEXPORT	char	*_malloc_memcpy(char * to, char * from, int len)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("memcpy", to, 1, len) != NOERROR
X	|| _chunk_pnt_check("memcpy", from, 1, len) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in memcpy");
X  }
X  return (char *)memcpy(to, from, len);
X}
X#endif
X
X#if HAVE_MEMSET
X/*
X * dummy function for checking memset's arguments.
X */
XEXPORT	char	*_malloc_memset(void * buf, char ch, int len)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("memset", buf, 1, len) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in memset");
X  }
X  return (char *)memset(buf, ch, len);
X}
X#endif
X
X#if HAVE_INDEX
X/*
X * dummy function for checking index's arguments.
X */
XEXPORT	char	*_malloc_index(char * str, char ch)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("index", str, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in index");
X  }
X  return (char *)index(str, ch);
X}
X#endif
X
X#if HAVE_RINDEX
X/*
X * dummy function for checking rindex's arguments.
X */
XEXPORT	char	*_malloc_rindex(char * str, char ch)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("rindex", str, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in rindex");
X  }
X  return (char *)rindex(str, ch);
X}
X#endif
X
X#if HAVE_STRCAT
X/*
X * dummy function for checking strcat's arguments.
X */
XEXPORT	char	*_malloc_strcat(char * to, char * from)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    /* maybe should check to, strlen(to) + strlen(from) */
X    if (_chunk_pnt_check("strcat", to, 1, 0) != NOERROR
X	|| _chunk_pnt_check("strcat", from, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strcat");
X  }
X  return (char *)strcat(to, from);
X}
X#endif
X
X#if HAVE_STRCMP
X/*
X * dummy function for checking strcmp's arguments.
X */
XEXPORT	int	_malloc_strcmp(char * s1,
X			       char * s2)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("strcmp", s1, 1, 0) != NOERROR
X	|| _chunk_pnt_check("strcmp", s2, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strcmp");
X  }
X  return strcmp(s1, s2);
X}
X#endif
X
X#if HAVE_STRLEN
X/*
X * dummy function for checking strlen's arguments.
X */
XEXPORT	int	_malloc_strlen(char * str)
X{
X  if (BIT_IS_SET(_malloc_debug,
X		 DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("strlen", str, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strlen");
X  }
X  return strlen(str);
X}
X#endif
X
X#if HAVE_STRTOK
X/*
X * dummy function for checking strtok's arguments.
X */
XEXPORT	char	*_malloc_strtok(char * str, char * sep)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("strtok", str, 1, 0) != NOERROR
X	|| _chunk_pnt_check("strtok", sep, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strtok");
X  }
X  return (char *)strtok(str, sep);
X}
X#endif
X
X#if HAVE_BZERO
X/*
X * dummy function for checking bzero's arguments.
X */
XEXPORT	void	_malloc_bzero(void * buf,
X			      int len)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("bzero", buf, 1, len) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in bzero");
X  }
X  bzero(buf, len);
X}
X#endif
X
X#if HAVE_MEMCCPY
X/*
X * dummy function for checking memccpy's arguments.
X */
XEXPORT	char	*_malloc_memccpy(char * s1, char * s2, char ch, int len)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    /* maybe len maybe first ch */
X    if (_chunk_pnt_check("memccpy", s1, 1, 0) != NOERROR
X	|| _chunk_pnt_check("memccpy", s2, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in memccpy");
X  }
X  return (char *)memccpy(s1, s2, ch, len);
X}
X#endif
X
X#if HAVE_MEMCHR
X/*
X * dummy function for checking memchr's arguments.
X */
XEXPORT	char	*_malloc_memchr(char * s1, char ch, int len)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("memchr", s1, 1, len) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in memchr");
X  }
X  return (char *)memchr(s1, ch, len);
X}
X#endif
X
X#if HAVE_STRCHR
X/*
X * dummy function for checking strchr's arguments.
X */
XEXPORT	char	*_malloc_strchr(char * str, char ch)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("strchr", str, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strchr");
X  }
X  return (char *)strchr(str, ch);
X}
X#endif
X
X#if HAVE_STRRCHR
X/*
X * dummy function for checking strrchr's arguments.
X */
XEXPORT	char	*_malloc_strrchr(char * str, char ch)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("strrchr", str, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strrchr");
X  }
X  return (char *)strrchr(str, ch);
X}
X#endif
X
X#if HAVE_STRCPY
X/*
X * dummy function for checking strcpy's arguments.
X */
XEXPORT	char	*_malloc_strcpy(char * to, char * from)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    /* maybe to, strlen(from) */
X    if (_chunk_pnt_check("strcpy", to, 1, 0) != NOERROR
X	|| _chunk_pnt_check("strcpy", from, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strcpy");
X  }
X  return (char *)strcpy(to, from);
X}
X#endif
X
X#if HAVE_STRNCPY
X/*
X * dummy function for checking strncpy's arguments.
X */
XEXPORT	char	*_malloc_strncpy(char * to, char * from, int len)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    /* len or until nullc */
X    if (_chunk_pnt_check("strncpy", to, 1, 0) != NOERROR
X	|| _chunk_pnt_check("strncpy", from, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strncpy");
X  }
X  return (char *)strncpy(to, from, len);
X}
X#endif
X
X#if HAVE_STRCASECMP
X/*
X * dummy function for checking strcasecmp's arguments.
X */
XEXPORT	int	_malloc_strcasecmp(char * s1, char * s2)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("strcasecmp", s1, 1, 0) != NOERROR
X	|| _chunk_pnt_check("strcasecmp", s2, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strcasecmp");
X  }
X  return strcasecmp(s1, s2);
X}
X#endif
X
X#if HAVE_STRNCASECMP
X/*
X * dummy function for checking strncasecmp's arguments.
X */
XEXPORT	int	_malloc_strncasecmp(char * s1, char * s2, int len)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    /* len or until nullc */
X    if (_chunk_pnt_check("strncasecmp", s1, 1, 0) != NOERROR
X	|| _chunk_pnt_check("strncasecmp", s2, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strncasecmp");
X  }
X  return strncasecmp(s1, s2, len);
X}
X#endif
X
X#if HAVE_STRSPN
X/*
X * dummy function for checking strspn's arguments.
X */
XEXPORT	int	_malloc_strspn(char * str, char * list)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("strspn", str, 1, 0) != NOERROR
X	|| _chunk_pnt_check("strspn", list, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strspn");
X  }
X  return strspn(str, list);
X}
X#endif
X
X#if HAVE_STRCSPN
X/*
X * dummy function for checking strcspn's arguments.
X */
XEXPORT	int	_malloc_strcspn(char * str, char * list)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("strcspn", str, 1, 0) != NOERROR
X	|| _chunk_pnt_check("strcspn", list, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strcspn");
X  }
X  return strcspn(str, list);
X}
X#endif
X
X#if HAVE_STRNCAT
X/*
X * dummy function for checking strncat's arguments.
X */
XEXPORT	char	*_malloc_strncat(char * to, char * from, int len)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    /* either len or nullc */
X    if (_chunk_pnt_check("strncat", to, 1, 0) != NOERROR
X	|| _chunk_pnt_check("strncat", from, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strncat");
X  }
X  return (char *)strncat(to, from, len);
X}
X#endif
X
X#if HAVE_STRNCMP
X/*
X * dummy function for checking strncmp's arguments.
X */
XEXPORT	int	_malloc_strncmp(char * s1, char * s2, int len)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    /* either len or nullc */
X    if (_chunk_pnt_check("strncmp", s1, 1, 0) != NOERROR
X	|| _chunk_pnt_check("strncmp", s2, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strncmp");
X  }
X  return strncmp(s1, s2, len);
X}
X#endif
X
X#if HAVE_STRPBRK
X/*
X * dummy function for checking strpbrk's arguments.
X */
XEXPORT	char	*_malloc_strpbrk(char * str, char * list)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("strpbrk", str, 1, 0) != NOERROR
X	|| _chunk_pnt_check("strpbrk", list, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strpbrk");
X  }
X  return (char *)strpbrk(str, list);
X}
X#endif
X
X#if HAVE_STRSTR
X/*
X * dummy function for checking strstr's arguments.
X */
XEXPORT	char	*_malloc_strstr(char * str, char * pat)
X{
X  if (BIT_IS_SET(_malloc_debug, DEBUG_CHECK_FUNCS)) {
X    if (_chunk_pnt_check("str", str, 1, 0) != NOERROR
X	|| _chunk_pnt_check("str", pat, 1, 0) != NOERROR)
X      if (BIT_IS_SET(_malloc_debug, DEBUG_LOG_BAD_POINTER))
X	_malloc_message("bad pointer argument found in strstr");
X  }
X  return (char *)strstr(str, pat);
X}
X#endif
END_OF_FILE
if test 13374 -ne `wc -c <'malloc_str.c'`; then
    echo shar: \"'malloc_str.c'\" unpacked with wrong size!
fi
# end of 'malloc_str.c'
fi
if test -f 'malloc_str.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'malloc_str.h'\"
else
echo shar: Extracting \"'malloc_str.h'\" \(4281 characters\)
sed "s/^X//" >'malloc_str.h' <<'END_OF_FILE'
X/*
X * defines for malloc string routines...
X *
X * Copyright 1992 by Gray Watson and the Antaire Corporation
X *
X * This file is part of the malloc-debug package.
X *
X * This library is free software; you can redistribute it and/or
X * modify it under the terms of the GNU Library General Public
X * License as published by the Free Software Foundation; either
X * version 2 of the License, or (at your option) any later version.
X *
X * This library is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X * Library General Public License for more details.
X *
X * You should have received a copy of the GNU Library General Public
X * License along with this library (see COPYING-LIB); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * The author of the program may be contacted at gray.watson@antaire.com
X *
X * $Id: malloc_str.h,v 1.4 1993/04/06 04:24:42 gray Exp $
X */
X
X#ifndef __MALLOC_STR_H__
X#define __MALLOC_STR_H__
X
X/*<<<<<<<<<<  The below prototypes are auto-generated by fillproto */
X
X/*
X * dummy function for checking bcmp's arguments.
X */
XIMPORT	int	_malloc_bcmp(void * b1, void * b2, int len);
X
X/*
X * dummy function for checking bcopy's arguments.
X */
XIMPORT	void	_malloc_bcopy(char * from, char * to, int len);
X
X/*
X * dummy function for checking memcmp's arguments.
X */
XIMPORT	int	_malloc_memcmp(void * b1,
X			       void * b2, int len);
X
X/*
X * dummy function for checking memcpy's arguments.
X */
XIMPORT	char	*_malloc_memcpy(char * to, char * from, int len);
X
X/*
X * dummy function for checking memset's arguments.
X */
XIMPORT	char	*_malloc_memset(void * buf, char ch, int len);
X
X/*
X * dummy function for checking index's arguments.
X */
XIMPORT	char	*_malloc_index(char * str, char ch);
X
X/*
X * dummy function for checking rindex's arguments.
X */
XIMPORT	char	*_malloc_rindex(char * str, char ch);
X
X/*
X * dummy function for checking strcat's arguments.
X */
XIMPORT	char	*_malloc_strcat(char * to, char * from);
X
X/*
X * dummy function for checking strcmp's arguments.
X */
XIMPORT	int	_malloc_strcmp(char * s1,
X			       char * s2);
X
X/*
X * dummy function for checking strlen's arguments.
X */
XIMPORT	int	_malloc_strlen(char * str);
X
X/*
X * dummy function for checking strtok's arguments.
X */
XIMPORT	char	*_malloc_strtok(char * str, char * sep);
X
X/*
X * dummy function for checking bzero's arguments.
X */
XIMPORT	void	_malloc_bzero(void * buf,
X			      int len);
X
X/*
X * dummy function for checking memccpy's arguments.
X */
XIMPORT	char	*_malloc_memccpy(char * s1, char * s2, char ch, int len);
X
X/*
X * dummy function for checking memchr's arguments.
X */
XIMPORT	char	*_malloc_memchr(char * s1, char ch, int len);
X
X/*
X * dummy function for checking strchr's arguments.
X */
XIMPORT	char	*_malloc_strchr(char * str, char ch);
X
X/*
X * dummy function for checking strrchr's arguments.
X */
XIMPORT	char	*_malloc_strrchr(char * str, char ch);
X
X/*
X * dummy function for checking strcpy's arguments.
X */
XIMPORT	char	*_malloc_strcpy(char * to, char * from);
X
X/*
X * dummy function for checking strncpy's arguments.
X */
XIMPORT	char	*_malloc_strncpy(char * to, char * from, int len);
X
X/*
X * dummy function for checking strcasecmp's arguments.
X */
XIMPORT	int	_malloc_strcasecmp(char * s1, char * s2);
X
X/*
X * dummy function for checking strncasecmp's arguments.
X */
XIMPORT	int	_malloc_strncasecmp(char * s1, char * s2, int len);
X
X/*
X * dummy function for checking strspn's arguments.
X */
XIMPORT	int	_malloc_strspn(char * str, char * list);
X
X/*
X * dummy function for checking strcspn's arguments.
X */
XIMPORT	int	_malloc_strcspn(char * str, char * list);
X
X/*
X * dummy function for checking strncat's arguments.
X */
XIMPORT	char	*_malloc_strncat(char * to, char * from, int len);
X
X/*
X * dummy function for checking strncmp's arguments.
X */
XIMPORT	int	_malloc_strncmp(char * s1, char * s2, int len);
X
X/*
X * dummy function for checking strpbrk's arguments.
X */
XIMPORT	char	*_malloc_strpbrk(char * str, char * list);
X
X/*
X * dummy function for checking strstr's arguments.
X */
XIMPORT	char	*_malloc_strstr(char * str, char * pat);
X
X/*<<<<<<<<<<   This is end of the auto-generated output from fillproto. */
X
X#endif /* ! __MALLOC_STR_H__ */
END_OF_FILE
if test 4281 -ne `wc -c <'malloc_str.h'`; then
    echo shar: \"'malloc_str.h'\" unpacked with wrong size!
fi
# end of 'malloc_str.h'
fi
if test -f 'sample.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample.c'\"
else
echo shar: Extracting \"'sample.c'\" \(609 characters\)
sed "s/^X//" >'sample.c' <<'END_OF_FILE'
X/*
X * sample malloc library usage program.
X */
X
X#include "malloc.h"
X
Xstatic	char	*rcs_id =
X  "$Id: sample.c,v 1.2 1992/12/22 04:55:38 gray Exp $";
X
Xmain(int argc, char ** argv)
X{
X  char	*pnt;
X  long	*longp;
X  
X  /* allocate 10-bytes */
X  pnt = MALLOC(10);
X  
X  /* free the pointer */
X  FREE(pnt);
X  
X  /* allocate 50-longs */
X  longp = ALLOC(long, 50);
X  
X  /* realloc to 100-longs */
X  longp = REALLOC(longp, long, 100);
X  /* don't free them */
X  
X#ifdef MALLOC_DEBUG
X  /* check out the heap and shut everything down if we are in debug mode */
X  malloc_verify(0);
X  malloc_shutdown();
X#endif
X  
X  exit(0);
X}
END_OF_FILE
if test 609 -ne `wc -c <'sample.c'`; then
    echo shar: \"'sample.c'\" unpacked with wrong size!
fi
# end of 'sample.c'
fi
if test -f 'version.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'version.h'\"
else
echo shar: Extracting \"'version.h'\" \(1036 characters\)
sed "s/^X//" >'version.h' <<'END_OF_FILE'
X/*
X * version string for the library
X *
X * Copyright 1992 by Gray Watson and the Antaire Corporation
X *
X * This file is part of the malloc-debug package.
X *
X * This library is free software; you can redistribute it and/or
X * modify it under the terms of the GNU Library General Public
X * License as published by the Free Software Foundation; either
X * version 2 of the License, or (at your option) any later version.
X *
X * This library is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X * Library General Public License for more details.
X *
X * You should have received a copy of the GNU Library General Public
X * License along with this library (see COPYING-LIB); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * The author of the program may be contacted at gray.watson@antaire.com
X */
X
X#include "malloc.h"
X
XLOCAL	char	*malloc_version = "1.2.0";
END_OF_FILE
if test 1036 -ne `wc -c <'version.h'`; then
    echo shar: \"'version.h'\" unpacked with wrong size!
fi
# end of 'version.h'
fi
echo shar: End of archive 5 \(of 5\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    echo "Do a 'sh ./configure' to configure the library"
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
