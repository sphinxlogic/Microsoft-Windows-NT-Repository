Newsgroups: comp.sources.unix
From: dbell@pdact.pd.necisa.oz.au (David I. Bell)
Subject: v26i046: CALC - An arbitrary precision C-like calculator, Part20/21
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: dbell@pdact.pd.necisa.oz.au (David I. Bell)
Posting-Number: Volume 26, Issue 46
Archive-Name: calc/part20

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 20 (of 21)."
# Contents:  func.c
# Wrapped by dbell@elm on Tue Feb 25 15:21:18 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'func.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'func.c'\"
else
echo shar: Extracting \"'func.c'\" \(47105 characters\)
sed "s/^X//" >'func.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1992 David I. Bell
X * Permission is granted to use, distribute, or modify this source,
X * provided that this copyright notice remains intact.
X *
X * Built-in functions implemented here
X */
X
X#include <sys/types.h>
X#include <sys/times.h>
X#include <time.h>
X
X#include "calc.h"
X#include "opcodes.h"
X#include "token.h"
X#include "func.h"
X#include "string.h"
X
X
X/* if HZ & CLK_TCK are not defined, pick typical values, hope for the best */
X#if !defined(HZ)
X#  define HZ 60
X#endif
X#if !defined(CLK_TCK)
X# undef CLK_TCK
X# define CLK_TCK HZ
X#endif
X
Xextern int errno;
X
X
X/*
X * Totally numeric functions.
X */
Xstatic NUMBER *f_cfsim();	/* simplify number using continued fractions */
Xstatic NUMBER *f_ilog();	/* return log of one number to another */
Xstatic NUMBER *f_faccnt();	/* count of divisions */
Xstatic NUMBER *f_min();		/* minimum of several arguments */
Xstatic NUMBER *f_max();		/* maximum of several arguments */
Xstatic NUMBER *f_hmean();	/* harmonic mean */
Xstatic NUMBER *f_trunc();	/* truncate number to specified decimal places */
Xstatic NUMBER *f_btrunc();	/* truncate number to specified binary places */
Xstatic NUMBER *f_gcd();		/* greatest common divisor */
Xstatic NUMBER *f_lcm();		/* least common multiple */
Xstatic NUMBER *f_xor();		/* xor of several arguments */
Xstatic NUMBER *f_ceil();	/* ceiling of a fraction */
Xstatic NUMBER *f_floor();	/* floor of a fraction */
Xstatic NUMBER *f_meq();		/* numbers are same modular value */
Xstatic NUMBER *f_isrel();	/* two numbers are relatively prime */
Xstatic NUMBER *f_ismult();	/* whether one number divides another */
Xstatic NUMBER *f_mne();		/* whether a and b are not equal modulo c */
Xstatic NUMBER *f_isset();	/* tests if a bit of a num (base 2) is set */
Xstatic NUMBER *f_highbit();	/* high bit number in base 2 representation */
Xstatic NUMBER *f_lowbit();	/* low bit number in base 2 representation */
Xstatic NUMBER *f_near();	/* whether two numbers are near each other */
Xstatic NUMBER *f_legtoleg();	/* positive form of leg to leg */
Xstatic NUMBER *f_ilog10();	/* integer log of number base 10 */
Xstatic NUMBER *f_ilog2();	/* integer log of number base 2 */
Xstatic NUMBER *f_digits();	/* number of digits of number */
Xstatic NUMBER *f_digit();	/* digit at specified decimal place of number */
Xstatic NUMBER *f_places();	/* number of decimal places of number */
Xstatic NUMBER *f_primetest();	/* primality test */
Xstatic NUMBER *f_issquare();	/* whether number is a square */
Xstatic NUMBER *f_runtime();	/* user runtime in seconds */
X
X
X/*
X * General functions.
X */
Xstatic VALUE f_bround();	/* round number to specified binary places */
Xstatic VALUE f_round();		/* round number to specified decimal places */
Xstatic VALUE f_det();		/* determinant of matrix */
Xstatic VALUE f_mattrans();	/* return transpose of matrix */
Xstatic VALUE f_matdim();	/* dimension of matrix */
Xstatic VALUE f_matmax();	/* maximum index of matrix dimension */
Xstatic VALUE f_matmin();	/* minimum index of matrix dimension */
Xstatic VALUE f_matfill();	/* fill matrix with values */
Xstatic VALUE f_listpush();	/* push element onto front of list */
Xstatic VALUE f_listpop();	/* pop element from front of list */
Xstatic VALUE f_listappend();	/* append element to end of list */
Xstatic VALUE f_listremove();	/* remove element from end of list */
Xstatic VALUE f_listinsert();	/* insert element into list */
Xstatic VALUE f_listdelete();	/* delete element from list */
Xstatic VALUE f_strlen();	/* length of string */
Xstatic VALUE f_char();		/* character value of integer */
Xstatic VALUE f_substr();	/* extract substring */
Xstatic VALUE f_strcat();	/* concatenate strings */
Xstatic VALUE f_ord();		/* get ordinal value for character */
Xstatic VALUE f_avg();		/* average of several arguments */
Xstatic VALUE f_ssq();		/* sum of squares */
Xstatic VALUE f_poly();		/* result of evaluating polynomial */
Xstatic VALUE f_sqrt();		/* square root of a number */
Xstatic VALUE f_root();		/* number taken to root of another */
Xstatic VALUE f_exp();		/* complex exponential */
Xstatic VALUE f_ln();		/* complex natural logarithm */
Xstatic VALUE f_power();		/* one value to another power */
Xstatic VALUE f_cos();		/* complex cosine */
Xstatic VALUE f_sin();		/* complex sine */
Xstatic VALUE f_polar();		/* polar representation of complex number */
Xstatic VALUE f_arg();		/* argument of complex number */
Xstatic VALUE f_list();		/* create a list */
Xstatic VALUE f_size();		/* number of elements in object */
Xstatic VALUE f_search();	/* search matrix or list for match */
Xstatic VALUE f_rsearch();	/* search matrix or list backwards for match */
Xstatic VALUE f_cp();		/* cross product of vectors */
Xstatic VALUE f_dp();		/* dot product of vectors */
Xstatic VALUE f_prompt();	/* prompt for input line */
Xstatic VALUE f_eval();		/* evaluate string into value */
Xstatic VALUE f_str();		/* convert value to string */
Xstatic VALUE f_fopen();		/* open file for reading or writing */
Xstatic VALUE f_fprintf();	/* print data to file */
Xstatic VALUE f_strprintf();	/* return printed data as a string */
Xstatic VALUE f_fgetline();	/* read next line from file */
Xstatic VALUE f_fgetc();		/* read next char from file */
Xstatic VALUE f_fflush();	/* flush output to file */
Xstatic VALUE f_printf();	/* print data to stdout */
Xstatic VALUE f_fclose();	/* close file */
Xstatic VALUE f_ferror();	/* whether error occurred */
Xstatic VALUE f_feof();		/* whether end of file reached */
Xstatic VALUE f_files();		/* return file handle or number of files */
X
X
X#define IN 100		/* maximum number of arguments */
X#define	FE 0x01		/* flag to indicate default epsilon argument */
X#define	FA 0x02		/* preserve addresses of variables */
X
X
X/*
X * List of primitive built-in functions
X */
Xstatic struct builtin {
X	char *b_name;		/* name of built-in function */
X	short b_minargs;	/* minimum number of arguments */
X	short b_maxargs;	/* maximum number of arguments */
X	short b_flags;		/* special handling flags */
X	short b_opcode;		/* opcode which makes the call quick */
X	NUMBER *(*b_numfunc)();	/* routine to calculate numeric function */
X	VALUE (*b_valfunc)();	/* routine to calculate general values */
X	char *b_desc;		/* description of function */
X} builtins[] = {
X	"abs", 1, 2, 0, OP_ABS, 0, 0, "absolute value within accuracy b",
X	"acos", 1, 2, FE, OP_NOP, qacos, 0, "arccosine of a within accuracy b",
X	"acosh", 1, 2, FE, OP_NOP, qacosh, 0, "hyperbolic arccosine of a within accuracy b",
X	"append", 2, 2, FA, OP_NOP, 0, f_listappend, "append value to end of list",
X	"appr", 1, 2, FE, OP_NOP, qbappr, 0, "approximate a with simpler fraction to within b",
X	"arg", 1, 2, 0, OP_NOP, 0, f_arg, "argument (the angle) of complex number",
X	"asin", 1, 2, FE, OP_NOP, qasin, 0, "arcsine of a within accuracy b",
X	"asinh", 1, 2, FE, OP_NOP, qasinh, 0, "hyperbolic arcsine of a within accuracy b",
X	"atan", 1, 2, FE, OP_NOP, qatan, 0, "arctangent of a within accuracy b",
X	"atan2", 2, 3, FE, OP_NOP, qatan2, 0, "angle to point (b,a) within accuracy c",
X	"atanh", 1, 2, FE, OP_NOP, qatanh, 0, "hyperbolic arctangent of a within accuracy b",
X	"avg", 1, IN, 0, OP_NOP, 0, f_avg, "arithmetic mean of values",
X	"bround", 1, 2, 0, OP_NOP, 0, f_bround, "round value a to b number of binary places",
X	"btrunc", 1, 2, 0, OP_NOP, f_btrunc, 0, "truncate a to b number of binary places",
X	"ceil", 1, 1, 0, OP_NOP, f_ceil, 0, "smallest integer greater than or equal to number",
X	"cfappr", 1, 2, FE, OP_NOP, qcfappr, 0, "approximate a within accuracy b using continued fractions",
X	"cfsim", 1, 1, 0, OP_NOP, f_cfsim, 0, "simplify number using continued fractions",
X	"char", 1, 1, 0, OP_NOP, 0, f_char, "character corresponding to integer value",
X	"cmp", 2, 2, 0, OP_CMP, 0, 0, "compare values returning -1, 0, or 1",
X	"comb", 2, 2, 0, OP_NOP, qcomb, 0, "combinatorial number a!/b!(a-b)!",
X	"config", 1, 2, 0, OP_SETCONFIG, 0, 0, "set or read configuration value",
X	"conj", 1, 1, 0, OP_CONJUGATE, 0, 0, "complex conjugate of value",
X	"cos", 1, 2, 0, OP_NOP, 0, f_cos, "cosine of value a within accuracy b",
X	"cosh", 1, 2, FE, OP_NOP, qcosh, 0, "hyperbolic cosine of a within accuracy b",
X	"cp", 2, 2, 0, OP_NOP, 0, f_cp, "Cross product of two vectors",
X	"delete", 2, 2, FA, OP_NOP, 0, f_listdelete, "delete element from list a at position b",
X	"den", 1, 1, 0, OP_DENOMINATOR, qden, 0, "denominator of fraction",
X	"det", 1, 1, 0, OP_NOP, 0, f_det, "determinant of matrix",
X	"digit", 2, 2, 0, OP_NOP, f_digit, 0, "digit at specified decimal place of number",
X	"digits", 1, 1, 0, OP_NOP, f_digits, 0, "number of digits in number",
X	"dp", 2, 2, 0, OP_NOP, 0, f_dp, "Dot product of two vectors",
X	"epsilon", 0, 1, 0, OP_SETEPSILON, 0, 0, "set or read allowed error for real calculations",
X	"eval", 1, 1, 0, OP_NOP, 0, f_eval, "Evaluate expression from string to value",
X	"exp", 1, 2, 0, OP_NOP, 0, f_exp, "exponential of value a within accuracy b",
X	"fcnt", 2, 2, 0, OP_NOP, f_faccnt, 0, "count of times one number divides another",
X	"fib", 1, 1, 0, OP_NOP, qfib, 0, "fibonacci number F(n)",
X	"frem", 2, 2, 0, OP_NOP, qfacrem, 0, "number with all occurances of factor removed",
X	"fact", 1, 1, 0, OP_NOP, qfact, 0, "factorial",
X	"fclose", 1, 1, 0, OP_NOP, 0, f_fclose, "close file",
X	"feof", 1, 1, 0, OP_NOP, 0, f_feof, "whether EOF reached for file",
X	"ferror", 1, 1, 0, OP_NOP, 0, f_ferror, "whether error occurred for file",
X	"fflush", 1, 1, 0, OP_NOP, 0, f_fflush, "flush output to file",
X	"fgetc", 1, 1, 0, OP_NOP, 0, f_fgetc, "read next char from file",
X	"fgetline", 1, 1, 0, OP_NOP, 0, f_fgetline, "read next line from file",
X	"files", 0, 1, 0, OP_NOP, 0, f_files, "return opened file or max number of opened files",
X	"floor", 1, 1, 0, OP_NOP, f_floor, 0, "greatest integer less than or equal to number",
X	"fopen", 2, 2, 0, OP_NOP, 0, f_fopen, "open file name a in mode b",
X	"fprintf", 2, IN, 0, OP_NOP, 0, f_fprintf, "print formatted output to opened file",
X	"frac", 1, 1, 0, OP_FRAC, qfrac, 0, "fractional part of value",
X	"gcd", 1,IN, 0, OP_NOP, f_gcd, 0, "greatest common divisor",
X	"gcdrem", 2, 2, 0, OP_NOP, qgcdrem, 0, "a divided repeatedly by gcd with b",
X	"highbit", 1, 1, 0, OP_NOP, f_highbit, 0, "high bit number in base 2 representation",
X	"hmean", 1,IN, 0, OP_NOP, f_hmean, 0, "harmonic mean of values",
X	"hypot", 2, 3, FE, OP_NOP, qhypot, 0, "hypotenuse of right triangle within accuracy c",
X	"ilog", 2, 2, 0, OP_NOP, f_ilog, 0, "integral log of one number with another",
X	"ilog10", 1, 1, 0, OP_NOP, f_ilog10, 0, "integral log of a number base 10",
X	"ilog2", 1, 1, 0, OP_NOP, f_ilog2, 0, "integral log of a number base 2",
X	"im", 1, 1, 0, OP_IM, 0, 0, "imaginary part of complex number",
X	"insert", 3, 3, FA, OP_NOP, 0, f_listinsert, "insert value c into list a at position b",
X 	"int", 1, 1, 0, OP_INT, qint, 0, "integer part of value",
X	"inverse", 1, 1, 0, OP_INVERT, 0, 0, "multiplicative inverse of value",
X	"iroot", 2, 2, 0, OP_NOP, qiroot, 0, "integer b'th root of a",
X	"iseven", 1, 1, 0, OP_ISEVEN, 0, 0, "whether a value is an even integer",
X	"isfile", 1, 1, 0, OP_ISFILE, 0, 0, "whether a value is a file",
X	"isint", 1, 1, 0, OP_ISINT, 0, 0, "whether a value is an integer",
X	"islist", 1, 1, 0, OP_ISLIST, 0, 0, "whether a value is a list",
X	"ismat", 1, 1, 0, OP_ISMAT, 0, 0, "whether a value is a matrix",
X	"ismult", 2, 2, 0, OP_NOP, f_ismult, 0, "whether a is a multiple of b",
X	"isnull", 1, 1, 0, OP_ISNULL, 0, 0, "whether a value is the null value",
X	"isnum", 1, 1, 0, OP_ISNUM, 0, 0, "whether a value is a number",
X	"isobj", 1, 1, 0, OP_ISOBJ, 0, 0, "whether a value is an object",
X	"isodd", 1, 1, 0, OP_ISODD, 0, 0, "whether a value is an odd integer",
X	"isqrt", 1, 1, 0, OP_NOP, qisqrt, 0, "integer part of square root",
X	"isreal", 1, 1, 0, OP_ISREAL, 0, 0, "whether a value is a real number",
X	"isset", 2, 2, 0, OP_NOP, f_isset, 0, "whether bit b of abs(a) (in base 2) is set",
X	"isstr", 1, 1, 0, OP_ISSTR, 0, 0, "whether a value is a string",
X	"isrel", 2, 2, 0, OP_NOP, f_isrel, 0, "whether two numbers are relatively prime",
X	"issimple", 1, 1, 0, OP_ISSIMPLE, 0, 0, "whether value is a simple type",
X	"issq", 1, 1, 0, OP_NOP, f_issquare, 0, "whether or not number is a square",
X 	"istype", 2, 2, 0, OP_ISTYPE, 0, 0, "whether the type of a is same as the type of b",
X	"jacobi", 2, 2, 0, OP_NOP, qjacobi, 0, "-1 => a is not quadratic residue mod b\n\t\t 1 => b is composite, or a is quad residue of b",
X	"lcm", 1, IN, 0, OP_NOP, f_lcm, 0, "least common multiple",
X	"lcmfact", 1, 1, 0, OP_NOP, qlcmfact, 0, "lcm of all integers up till number",
X	"lfactor", 2, 2, 0, OP_NOP, qlowfactor, 0, "lowest prime factor of a in first b primes",
X	"list", 0, IN, 0, OP_NOP, 0, f_list, "create list of specified values",
X	"ln", 1, 2, 0, OP_NOP, 0, f_ln, "natural logarithm of value a within accuracy b",
X	"lowbit", 1, 1, 0, OP_NOP, f_lowbit, 0, "low bit number in base 2 representation",
X	"ltol", 1, 2, FE, OP_NOP, f_legtoleg, 0, "leg-to-leg of unit right triangle (sqrt(1 - a^2))",
X	"matdim", 1, 1, 0, OP_NOP, 0, f_matdim, "number of dimensions of matrix",
X	"matfill", 2, 3, FA, OP_NOP, 0, f_matfill, "fill matrix with value b (value c on diagonal)",
X	"matmax", 2, 2, 0, OP_NOP, 0, f_matmax, "maximum index of matrix a dim b",
X	"matmin", 2, 2, 0, OP_NOP, 0, f_matmin, "minimum index of matrix a dim b",
X	"mattrans", 1, 1, 0, OP_NOP, 0, f_mattrans, "transpose of matrix",
X	"max", 1, IN, 0, OP_NOP, f_max, 0, "maximum value",
X	"meq", 3, 3, 0, OP_NOP, f_meq, 0, "whether a and b are equal modulo c",
X	"min", 1, IN, 0, OP_NOP, f_min, 0, "minimum value",
X	"minv", 2, 2, 0, OP_NOP, qminv, 0, "inverse of a modulo b",
X	"mmin", 2, 2, 0, OP_NOP, qminmod, 0, "a mod b value with smallest abs value",
X	"mne", 3, 3, 0, OP_NOP, f_mne, 0, "whether a and b are not equal modulo c",
X	"near", 2, 3, 0, OP_NOP, f_near, 0, "sign of (abs(a-b) - c)",
X	"norm", 1, 1, 0, OP_NORM, 0, 0, "norm of a value (square of absolute value)",
X	"null", 0, 0, 0, OP_UNDEF, 0, 0, "null value",
X	"num", 1, 1, 0, OP_NUMERATOR, qnum, 0, "numerator of fraction",
X	"ord", 1, 1, 0, OP_NOP, 0, f_ord, "integer corresponding to character value",
X	"param", 1, 1, 0, OP_ARGVALUE, 0, 0, "value of parameter n (or parameter count if n is zero)",
X	"perm", 2, 2, 0, OP_NOP, qperm, 0, "permutation number a!/(a-b)!",
X	"pfact", 1, 1, 0, OP_NOP, qpfact, 0, "product of primes up till number",
X	"pi", 0, 1, FE, OP_NOP, qpi, 0, "value of pi accurate to within epsilon",
X	"places", 1, 1, 0, OP_NOP, f_places, 0, "places after decimal point (-1 if infinite)",
X	"pmod", 3, 3, 0, OP_NOP, qpowermod,0, "mod of a power (a ^ b (mod c))",
X	"polar", 2, 3, 0, OP_NOP, 0, f_polar, "complex value of polar coordinate (a * exp(b*1i))",
X	"poly", 2, IN, 0, OP_NOP, 0, f_poly, "(a1,a2,...,an,x) = a1*x^n+a2*x^(n-1)+...+an",
X	"pop", 1, 1, FA, OP_NOP, 0, f_listpop, "pop value from front of list",
X	"power", 2, 3, 0, OP_NOP, 0, f_power, "value a raised to the power b within accuracy c",
X	"ptest", 2, 2, 0, OP_NOP, f_primetest, 0, "probabilistic primality test",
X	"printf", 1, IN, 0, OP_NOP, 0, f_printf, "print formatted output to stdout",
X	"prompt", 1, 1, 0, OP_NOP, 0, f_prompt, "prompt for input line using value a",
X	"push", 2, 2, FA, OP_NOP, 0, f_listpush, "push value onto front of list",
X	"quomod", 4, 4, 0, OP_QUOMOD, 0, 0, "set c and d to quotient and remainder of a divided by b",
X	"rcin", 2, 2, 0, OP_NOP, qredcin, 0, "convert normal number a to REDC number mod b",
X	"rcmul", 3, 3, 0, OP_NOP, qredcmul, 0, "multiply REDC numbers a and b mod c",
X	"rcout", 2, 2, 0, OP_NOP, qredcout, 0, "convert REDC number a mod b to normal number",
X	"rcpow", 3, 3, 0, OP_NOP, qredcpower, 0, "raise REDC number a to power b mod c",
X	"rcsq", 2, 2, 0, OP_NOP, qredcsquare, 0, "square REDC number a mod b",
X	"re", 1, 1, 0, OP_RE, 0, 0, "real part of complex number",
X	"remove", 1, 1, FA, OP_NOP, 0, f_listremove, "remove value from end of list",
X	"root", 2, 3, 0, OP_NOP, 0, f_root, "value a taken to the b'th root within accuracy c",
X	"round", 1, 2, 0, OP_NOP, 0, f_round, "round value a to b number of decimal places",
X	"rsearch", 2, 3, 0, OP_NOP, 0, f_rsearch, "reverse search matrix or list for value b starting at index c",
X	"runtime", 0, 0, 0, OP_NOP, f_runtime, 0, "user mode cpu time in seconds",
X	"scale", 2, 2, 0, OP_SCALE, 0, 0, "scale value up or down by a power of two",
X	"search", 2, 3, 0, OP_NOP, 0, f_search, "search matrix or list for value b starting at index c",
X	"sgn", 1, 1, 0, OP_SGN, qsign, 0, "sign of value (-1, 0, 1)",
X	"sin", 1, 2, 0, OP_NOP, 0, f_sin, "sine of value a within accuracy b",
X	"sinh", 1, 2, FE, OP_NOP, qsinh, 0, "hyperbolic sine of a within accuracy b",
X	"size", 1, 1, 0, OP_NOP, 0, f_size, "total number of elements in value",
X	"sqrt", 1, 2, 0, OP_NOP, 0, f_sqrt, "square root of value a within accuracy b",
X	"ssq", 1, IN, 0, OP_NOP, 0, f_ssq, "sum of squares of values",
X	"str", 1, 1, 0, OP_NOP, 0, f_str, "simple value converted to string",
X	"strcat", 1,IN, 0, OP_NOP, 0, f_strcat, "concatenate strings together",
X	"strlen", 1, 1, 0, OP_NOP, 0, f_strlen, "length of string",
X	"strprintf", 1, IN, 0, OP_NOP, 0, f_strprintf, "return formatted output as a string",
X	"substr", 3, 3, 0, OP_NOP, 0, f_substr, "substring of a from position b for c chars",
X	"swap", 2, 2, 0, OP_SWAP, 0, 0, "swap values of variables a and b (can be dangerous)",
X	"tan", 1, 2, FE, OP_NOP, qtan, 0, "tangent of a within accuracy b",
X	"tanh", 1, 2, FE, OP_NOP, qtanh, 0, "hyperbolic tangent of a within accuracy b",
X	"trunc", 1, 2, 0, OP_NOP, f_trunc, 0, "truncate a to b number of decimal places",
X	"xor", 1, IN, 0, OP_NOP, f_xor, 0, "logical xor",
X	NULL, 0, 0, 0, OP_NOP, 0, 0, NULL /* end of table */
X};
X
X
X/*
X * Call a built-in function.
X * Arguments to the function are on the stack, but are not removed here.
X * Functions are either purely numeric, or else can take any value type.
X */
XVALUE
Xbuiltinfunc(index, argcount, stack)
X	long index;
X	VALUE *stack;		/* arguments on the stack */
X{
X	VALUE *sp;		/* pointer to stack entries */
X	VALUE **vpp;		/* pointer to current value address */
X	struct builtin *bp;	/* builtin function to be called */
X	long i;			/* index */
X	NUMBER *numargs[IN];	/* numeric arguments for function */
X	VALUE *valargs[IN];	/* addresses of actual arguments */
X	VALUE result;		/* general result of function */
X
X	if ((unsigned long)index >= (sizeof(builtins) / sizeof(builtins[0])) - 1)
X		error("Bad built-in function index");
X	bp = &builtins[index];
X	if (argcount < bp->b_minargs)
X		error("Too few arguments for builtin function \"%s\"", bp->b_name);
X	if ((argcount > bp->b_maxargs) || (argcount > IN))
X		error("Too many arguments for builtin function \"%s\"", bp->b_name);
X	/*
X	 * If an address was passed, then point at the real variable,
X	 * otherwise point at the stack value itself (unless the function
X	 * is very special).
X	 */
X	sp = stack - argcount + 1;
X	vpp = valargs;
X	for (i = argcount; i > 0; i--) {
X		if ((sp->v_type != V_ADDR) || (bp->b_flags & FA))
X			*vpp = sp;
X		else
X			*vpp = sp->v_addr;
X		sp++;
X		vpp++;
X	}
X	/*
X	 * Handle general values if the function accepts them.
X	 */
X	if (bp->b_valfunc) {
X		vpp = valargs;
X		if ((bp->b_minargs == 1) && (bp->b_maxargs == 1))
X			result = (*bp->b_valfunc)(vpp[0]);
X		else if ((bp->b_minargs == 2) && (bp->b_maxargs == 2))
X			result = (*bp->b_valfunc)(vpp[0], vpp[1]);
X		else if ((bp->b_minargs == 3) && (bp->b_maxargs == 3))
X			result = (*bp->b_valfunc)(vpp[0], vpp[1], vpp[2]);
X		else
X			result = (*bp->b_valfunc)(argcount, vpp);
X		return result;
X	}
X	/*
X	 * Function must be purely numeric, so handle that.
X	 */
X	vpp = valargs;
X	for (i = 0; i < argcount; i++) {
X		if ((*vpp)->v_type != V_NUM)
X			error("Non-real argument for builtin function %s", bp->b_name);
X		numargs[i] = (*vpp)->v_num;
X		vpp++;
X	}
X	result.v_type = V_NUM;
X	if (!(bp->b_flags & FE) && (bp->b_minargs != bp->b_maxargs)) {
X		result.v_num = (*bp->b_numfunc)(argcount, numargs);
X		return result;
X	}
X	if ((bp->b_flags & FE) && (argcount < bp->b_maxargs))
X		numargs[argcount++] = _epsilon_;
X
X	switch (argcount) {
X		case 0:
X			result.v_num = (*bp->b_numfunc)();
X			break;
X		case 1:
X			result.v_num = (*bp->b_numfunc)(numargs[0]);
X			break;
X		case 2:
X			result.v_num = (*bp->b_numfunc)(numargs[0], numargs[1]);
X			break;
X		case 3:
X			result.v_num = (*bp->b_numfunc)(numargs[0], numargs[1], numargs[2]);
X			break;
X		default:
X			error("Bad builtin function call");
X	}
X	return result;
X}
X
X
Xstatic VALUE
Xf_eval(vp)
X	VALUE *vp;
X{
X	FUNC	*oldfunc;
X	FUNC	*newfunc;
X	VALUE	result;
X
X	if (vp->v_type != V_STR)
X		error("Evaluating non-string argument");
X	(void) openstring(vp->v_str);
X	oldfunc = curfunc;
X	if (evaluate(TRUE)) {
X		freevalue(stack--);
X		newfunc = curfunc;
X		curfunc = oldfunc;
X		result = newfunc->f_savedvalue;
X		newfunc->f_savedvalue.v_type = V_NULL;
X		if (newfunc != oldfunc)
X			free(newfunc);
X		return result;
X	}
X	newfunc = curfunc;
X	curfunc = oldfunc;
X	freevalue(&newfunc->f_savedvalue);
X	newfunc->f_savedvalue.v_type = V_NULL;
X	if (newfunc != oldfunc)
X		free(newfunc);
X	error("Evaluation error");
X	/*NOTREACHED*/
X}
X
X
Xstatic VALUE
Xf_prompt(vp)
X	VALUE *vp;
X{
X	VALUE result;
X	char *cp;
X	char *newcp;
X
X	if (inputisterminal()) {
X		printvalue(vp, PRINT_SHORT);
X		math_flush();
X	}
X	cp = nextline();
X	if (cp == NULL)
X		error("End of file while prompting");
X	if (*cp == '\0') {
X		result.v_type = V_STR;
X		result.v_subtype = V_STRLITERAL;
X		result.v_str = "";
X		return result;
X	}
X	newcp = (char *)malloc(strlen(cp) + 1);
X	if (newcp == NULL)
X		error("Cannot allocate string");
X	strcpy(newcp, cp);
X	result.v_str = newcp;
X	result.v_type = V_STR;
X	result.v_subtype = V_STRALLOC;
X	return result;
X}
X
X
Xstatic VALUE
Xf_str(vp)
X	VALUE *vp;
X{
X	VALUE result;
X	char *cp;
X
X	switch (vp->v_type) {
X		case V_STR:
X			copyvalue(vp, &result);
X			return result;
X		case V_NULL:
X			result.v_str = "";
X			result.v_type = V_STR;
X			result.v_subtype = V_STRLITERAL;
X			return result;
X		case V_NUM:
X			divertio();
X			qprintnum(vp->v_num, MODE_DEFAULT);
X			cp = getdivertedio();
X			break;
X		case V_COM:
X			divertio();
X			comprint(vp->v_com);
X			cp = getdivertedio();
X			break;
X		default:
X			error("Non-simple type for string conversion");
X	}
X	result.v_str = cp;
X	result.v_type = V_STR;
X	result.v_subtype = V_STRALLOC;
X	return result;
X}
X
X
Xstatic VALUE
Xf_poly(count, vals)
X	VALUE **vals;
X{
X	VALUE *x;
X	VALUE result, tmp;
X
X	x = vals[--count];
X	copyvalue(*vals++, &result);
X	while (--count > 0) {
X		mulvalue(&result, x, &tmp);
X		freevalue(&result);
X		addvalue(*vals++, &tmp, &result);
X		freevalue(&tmp);
X	}
X	return result;
X}
X
X
Xstatic NUMBER *
Xf_mne(val1, val2, val3)
X	NUMBER *val1, *val2, *val3;
X{
X	return itoq((long) qcmpmod(val1, val2, val3));
X}
X
X
Xstatic NUMBER *
Xf_isrel(val1, val2)
X	NUMBER *val1, *val2;
X{
X	if (qisfrac(val1) || qisfrac(val2))
X		error("Non-integer for isrel");
X	return itoq((long) zrelprime(val1->num, val2->num));
X}
X
X
Xstatic NUMBER *
Xf_issquare(vp)
X	NUMBER *vp;
X{
X	return itoq((long) qissquare(vp));
X}
X
X
Xstatic NUMBER *
Xf_primetest(val1, val2)
X	NUMBER *val1, *val2;
X{
X	return itoq((long) qprimetest(val1, val2));
X}
X
X
Xstatic NUMBER *
Xf_isset(val1, val2)
X	NUMBER *val1, *val2;
X{
X	if (qisfrac(val2))
X		error("Non-integral bit position");
X	if (qiszero(val1) || (qisint(val1) && qisneg(val2)))
X		return qlink(&_qzero_);
X	if (isbig(val2->num)) {
X		if (qisneg(val2))
X			error("Very large bit position");
X		return qlink(&_qzero_);
X	}
X	return itoq((long) qisset(val1, qtoi(val2)));
X}
X
X
Xstatic NUMBER *
Xf_digit(val1, val2)
X	NUMBER *val1, *val2;
X{
X	if (qisfrac(val2))
X		error("Non-integral digit position");
X	if (qiszero(val1) || (qisint(val1) && qisneg(val2)))
X		return qlink(&_qzero_);
X	if (isbig(val2->num)) {
X		if (qisneg(val2))
X			error("Very large digit position");
X		return qlink(&_qzero_);
X	}
X	return itoq((long) qdigit(val1, qtoi(val2)));
X}
X
X
Xstatic NUMBER *
Xf_digits(val)
X	NUMBER *val;
X{
X	return itoq((long) qdigits(val));
X}
X
X
Xstatic NUMBER *
Xf_places(val)
X	NUMBER *val;
X{
X	return itoq((long) qplaces(val));
X}
X
X
Xstatic NUMBER *
Xf_xor(count, vals)
X	NUMBER **vals;
X{
X	NUMBER *val, *tmp;
X
X	val = qlink(*vals);
X	while (--count > 0) {
X		tmp = qxor(val, *++vals);
X		qfree(val);
X		val = tmp;
X	}
X	return val;
X}
X
X
Xstatic NUMBER *
Xf_min(count, vals)
X	NUMBER **vals;
X{
X	NUMBER *val, *tmp;
X
X	val = qlink(*vals);
X	while (--count > 0) {
X		tmp = qmin(val, *++vals);
X		qfree(val);
X		val = tmp;
X	}
X	return val;
X}
X
X
Xstatic NUMBER *
Xf_max(count, vals)
X	NUMBER **vals;
X{
X	NUMBER *val, *tmp;
X
X	val = qlink(*vals);
X	while (--count > 0) {
X		tmp = qmax(val, *++vals);
X		qfree(val);
X		val = tmp;
X	}
X	return val;
X}
X
X
Xstatic NUMBER *
Xf_gcd(count, vals)
X	NUMBER **vals;
X{
X	NUMBER *val, *tmp;
X
X	val = qlink(*vals);
X	while (--count > 0) {
X		tmp = qgcd(val, *++vals);
X		qfree(val);
X		val = tmp;
X		if (qisunit(val))
X			break;
X	}
X	return val;
X}
X
X
Xstatic NUMBER *
Xf_lcm(count, vals)
X	NUMBER **vals;
X{
X	NUMBER *val, *tmp;
X
X	val = qlink(*vals);
X	while (--count > 0) {
X		tmp = qlcm(val, *++vals);
X		qfree(val);
X		val = tmp;
X	}
X	return val;
X}
X
X
Xstatic VALUE
Xf_avg(count, vals)
X	VALUE **vals;
X{
X	int i;
X	VALUE result;
X	VALUE tmp;
X	VALUE div;
X
X	result.v_num = qlink(&_qzero_);
X	result.v_type = V_NUM;
X	for (i = count; i > 0; i--) {
X		addvalue(&result, *vals++, &tmp);
X		freevalue(&result);
X		result = tmp;
X	}
X	if (count <= 1)
X		return result;
X	div.v_num = itoq((long) count);
X	div.v_type = V_NUM;
X	divvalue(&result, &div, &tmp);
X	qfree(div.v_num);
X	return tmp;
X}
X
X
Xstatic NUMBER *
Xf_hmean(count, vals)
X	NUMBER **vals;
X{
X	NUMBER *val, *tmp, *tmp2;
X
X	val = qinv(*vals);
X	while (--count > 0) {
X		tmp2 = qinv(*++vals);
X		tmp = qadd(val, tmp2);
X		qfree(tmp2);
X		qfree(val);
X		val = tmp;
X	}
X	tmp = qinv(val);
X	qfree(val);
X	return tmp;
X}
X
X
Xstatic VALUE
Xf_ssq(count, vals)
X	VALUE **vals;
X{
X	VALUE result, tmp1, tmp2;
X
X	squarevalue(*vals++, &result);
X	while (--count > 0) {
X		squarevalue(*vals++, &tmp1);
X		addvalue(&tmp1, &result, &tmp2);
X		freevalue(&tmp1);
X		freevalue(&result);
X		result = tmp2;
X	}
X	return result;
X}
X
X
Xstatic NUMBER *
Xf_ismult(val1, val2)
X	NUMBER *val1, *val2;
X{
X	return itoq((long) qdivides(val1, val2));
X}
X
X
Xstatic NUMBER *
Xf_meq(val1, val2, val3)
X	NUMBER *val1, *val2, *val3;
X{
X	NUMBER *tmp, *res;
X
X	tmp = qsub(val1, val2);
X	res = itoq((long) qdivides(tmp, val3));
X	qfree(tmp);
X	return res;
X}
X
X
Xstatic VALUE
Xf_exp(count, vals)
X	VALUE **vals;
X{
X	VALUE result;
X	NUMBER *err;
X
X	err = _epsilon_;
X	if (count == 2) {
X		if (vals[1]->v_type != V_NUM)
X			error("Non-real epsilon value for exp");
X		err = vals[1]->v_num;
X	}
X	switch (vals[0]->v_type) {
X		case V_NUM:
X			result.v_num = qexp(vals[0]->v_num, err);
X			result.v_type = V_NUM;
X			break;
X		case V_COM:
X			result.v_com = cexp(vals[0]->v_com, err);
X			result.v_type = V_COM;
X			break;
X		default:
X			error("Bad argument type for exp");
X	}
X	return result;
X}
X
X
Xstatic VALUE
Xf_ln(count, vals)
X	VALUE **vals;
X{
X	VALUE result;
X	COMPLEX temp;
X	NUMBER *err;
X
X	err = _epsilon_;
X	if (count == 2) {
X		if (vals[1]->v_type != V_NUM)
X			error("Non-real epsilon value for ln");
X		err = vals[1]->v_num;
X	}
X	switch (vals[0]->v_type) {
X		case V_NUM:
X			if (!qisneg(vals[0]->v_num) && !qiszero(vals[0]->v_num)) {
X				result.v_num = qln(vals[0]->v_num, err);
X				result.v_type = V_NUM;
X				break;
X			}
X			temp.real = vals[0]->v_num;
X			temp.imag = &_qzero_;
X			result.v_com = cln(&temp, err);
X			result.v_type = V_COM;
X			break;
X		case V_COM:
X			result.v_com = cln(vals[0]->v_com, err);
X			result.v_type = V_COM;
X			break;
X		default:
X			error("Bad argument type for ln");
X	}
X	return result;
X}
X
X
Xstatic VALUE
Xf_cos(count, vals)
X	VALUE **vals;
X{
X	VALUE result;
X	COMPLEX *c;
X	NUMBER *err;
X
X	err = _epsilon_;
X	if (count == 2) {
X		if (vals[1]->v_type != V_NUM)
X			error("Non-real epsilon value for cos");
X		err = vals[1]->v_num;
X	}
X	switch (vals[0]->v_type) {
X		case V_NUM:
X			result.v_num = qcos(vals[0]->v_num, err);
X			result.v_type = V_NUM;
X			break;
X		case V_COM:
X			c = ccos(vals[0]->v_com, err);
X			result.v_com = c;
X			result.v_type = V_COM;
X			if (cisreal(c)) {
X				result.v_num = qlink(c->real);
X				result.v_type = V_NUM;
X				comfree(c);
X			}
X			break;
X		default:
X			error("Bad argument type for cos");
X	}
X	return result;
X}
X
X
Xstatic VALUE
Xf_sin(count, vals)
X	VALUE **vals;
X{
X	VALUE result;
X	COMPLEX *c;
X	NUMBER *err;
X
X	err = _epsilon_;
X	if (count == 2) {
X		if (vals[1]->v_type != V_NUM)
X			error("Non-real epsilon value for sin");
X		err = vals[1]->v_num;
X	}
X	switch (vals[0]->v_type) {
X		case V_NUM:
X			result.v_num = qsin(vals[0]->v_num, err);
X			result.v_type = V_NUM;
X			break;
X		case V_COM:
X			c = csin(vals[0]->v_com, err);
X			result.v_com = c;
X			result.v_type = V_COM;
X			if (cisreal(c)) {
X				result.v_num = qlink(c->real);
X				result.v_type = V_NUM;
X				comfree(c);
X			}
X			break;
X		default:
X			error("Bad argument type for sin");
X	}
X	return result;
X}
X
X
Xstatic VALUE
Xf_arg(count, vals)
X	VALUE **vals;
X{
X	VALUE result;
X	COMPLEX *c;
X	NUMBER *err;
X
X	err = _epsilon_;
X	if (count == 2) {
X		if (vals[1]->v_type != V_NUM)
X			error("Non-real epsilon value for arg");
X		err = vals[1]->v_num;
X	}
X	result.v_type = V_NUM;
X	switch (vals[0]->v_type) {
X		case V_NUM:
X			if (qisneg(vals[0]->v_num))
X				result.v_num = qpi(err);
X			else
X				result.v_num = qlink(&_qzero_);
X			break;
X		case V_COM:
X			c = vals[0]->v_com;
X			if (ciszero(c))
X				result.v_num = qlink(&_qzero_);
X			else
X				result.v_num = qatan2(c->imag, c->real, err);
X			break;
X		default:
X			error("Bad argument type for arg");
X	}
X	return result;
X}
X
X
Xstatic NUMBER *
Xf_legtoleg(val1, val2)
X	NUMBER *val1, *val2;
X{
X	return qlegtoleg(val1, val2, FALSE);
X}
X
X
Xstatic NUMBER *
Xf_trunc(count, vals)
X	NUMBER **vals;
X{
X	NUMBER *val;
X
X	val = &_qzero_;
X	if (count == 2)
X		val = vals[1];
X	return qtrunc(*vals, val);
X}
X
X
Xstatic VALUE
Xf_bround(count, vals)
X	VALUE **vals;
X{
X	VALUE *vp, tmp, res;
X
X	if (count > 1)
X		vp = vals[1];
X	else {
X		tmp.v_type = V_INT;
X		tmp.v_num = 0;
X		vp = &tmp;
X	}
X	broundvalue(vals[0], vp, &res);
X	return res;
X}
X
X
Xstatic VALUE
Xf_round(count, vals)
X	VALUE **vals;
X{
X	VALUE *vp, tmp, res;
X
X	if (count > 1)
X		vp = vals[1];
X	else {
X		tmp.v_type = V_INT;
X		tmp.v_num = 0;
X		vp = &tmp;
X	}
X	roundvalue(vals[0], vp, &res);
X	return res;
X}
X
X
Xstatic NUMBER *
Xf_btrunc(count, vals)
X	NUMBER **vals;
X{
X	NUMBER *val;
X
X	val = &_qzero_;
X	if (count == 2)
X		val = vals[1];
X	return qbtrunc(*vals, val);
X}
X
X
Xstatic NUMBER *
Xf_near(count, vals)
X	NUMBER **vals;
X{
X	NUMBER *val;
X
X	val = _epsilon_;
X	if (count == 3)
X		val = vals[2];
X	return itoq((long) qnear(vals[0], vals[1], val));
X}
X
X
Xstatic NUMBER *
Xf_cfsim(val)
X	NUMBER *val;
X{
X	return qcfappr(val, NULL);
X}
X
X
Xstatic NUMBER *
Xf_ceil(val)
X	NUMBER *val;
X{
X	NUMBER *val2;
X
X	if (qisint(val))
X		return qlink(val);
X	val2 = qint(val);
X	if (qisneg(val2))
X		return val2;
X	val = qinc(val2);
X	qfree(val2);
X	return val;
X}
X
X
Xstatic NUMBER *
Xf_floor(val)
X	NUMBER *val;
X{
X	NUMBER *val2;
X
X	if (qisint(val))
X		return qlink(val);
X	val2 = qint(val);
X	if (!qisneg(val2))
X		return val2;
X	val = qdec(val2);
X	qfree(val2);
X	return val;
X}
X
X
Xstatic NUMBER *
Xf_highbit(val)
X	NUMBER *val;
X{
X	if (qiszero(val))
X		error("Highbit of zero");
X	if (qisfrac(val))
X		error("Highbit of non-integer");
X	return itoq(zhighbit(val->num));
X}
X
X
Xstatic NUMBER *
Xf_lowbit(val)
X	NUMBER *val;
X{
X	if (qiszero(val))
X		error("Lowbit of zero");
X	if (qisfrac(val))
X		error("Lowbit of non-integer");
X	return itoq(zlowbit(val->num));
X}
X
X
Xstatic VALUE
Xf_sqrt(count, vals)
X	VALUE **vals;
X{
X	VALUE *vp, err, result;
X
X	if (count > 1)
X		vp = vals[1];
X	else {
X		err.v_num = _epsilon_;
X		err.v_type = V_NUM;
X		vp = &err;
X	}
X	sqrtvalue(vals[0], vp, &result);
X	return result;
X}
X
X
Xstatic VALUE
Xf_root(count, vals)
X	VALUE **vals;
X{
X	VALUE *vp, err, result;
X
X	if (count > 2)
X		vp = vals[3];
X	else {
X		err.v_num = _epsilon_;
X		err.v_type = V_NUM;
X		vp = &err;
X	}
X	rootvalue(vals[0], vals[1], vp, &result);
X	return result;
X}
X
X
Xstatic VALUE
Xf_power(count, vals)
X	VALUE **vals;
X{
X	VALUE *vp, err, result;
X
X	if (count > 2)
X		vp = vals[2];
X	else {
X		err.v_num = _epsilon_;
X		err.v_type = V_NUM;
X		vp = &err;
X	}
X	powervalue(vals[0], vals[1], vp, &result);
X	return result;
X}
X
X
Xstatic VALUE
Xf_polar(count, vals)
X	VALUE **vals;
X{
X	VALUE *vp, err, result;
X	COMPLEX *c;
X
X	if (count > 2)
X		vp = vals[2];
X	else {
X		err.v_num = _epsilon_;
X		err.v_type = V_NUM;
X		vp = &err;
X	}
X	if ((vals[0]->v_type != V_NUM) || (vals[1]->v_type != V_NUM))
X		error("Non-real argument for polar");
X	if ((vp->v_type != V_NUM) || qisneg(vp->v_num) || qiszero(vp->v_num))
X		error("Bad epsilon value for polar");
X	c = cpolar(vals[0]->v_num, vals[1]->v_num, vp->v_num);
X	result.v_com = c;
X	result.v_type = V_COM;
X	if (cisreal(c)) {
X		result.v_num = qlink(c->real);
X		result.v_type = V_NUM;
X		comfree(c);
X	}
X	return result;
X}
X
X
Xstatic NUMBER *
Xf_ilog(val1, val2)
X	NUMBER *val1, *val2;
X{
X	return itoq(qilog(val1, val2));
X}
X
X
Xstatic NUMBER *
Xf_ilog2(val)
X	NUMBER *val;
X{
X	return itoq(qilog2(val));
X}
X
X
Xstatic NUMBER *
Xf_ilog10(val)
X	NUMBER *val;
X{
X	return itoq(qilog10(val));
X}
X
X
Xstatic NUMBER *
Xf_faccnt(val1, val2)
X	NUMBER *val1, *val2;
X{
X	return itoq(qdivcount(val1, val2));
X}
X
X
Xstatic VALUE
Xf_matfill(count, vals)
X	VALUE **vals;
X{
X	VALUE *v1, *v2, *v3;
X	VALUE result;
X
X	v1 = vals[0];
X	v2 = vals[1];
X	v3 = (count == 3) ? vals[2] : NULL;
X	if (v1->v_type != V_ADDR)
X		error("Non-variable argument for matfill");
X	v1 = v1->v_addr;
X	if (v1->v_type != V_MAT)
X		error("Non-matrix for matfill");
X	if (v2->v_type == V_ADDR)
X		v2 = v2->v_addr;
X	if (v3 && (v3->v_type == V_ADDR))
X		v3 = v3->v_addr;
X	matfill(v1->v_mat, v2, v3);
X	result.v_type = V_NULL;
X	return result;
X}
X
X
Xstatic VALUE
Xf_mattrans(vp)
X	VALUE *vp;
X{
X	VALUE result;
X
X	if (vp->v_type != V_MAT)
X		error("Non-matrix argument for mattrans");
X	result.v_type = V_MAT;
X	result.v_mat = mattrans(vp->v_mat);
X	return result;
X}
X
X
Xstatic VALUE
Xf_det(vp)
X	VALUE *vp;
X{
X	if (vp->v_type != V_MAT)
X		error("Non-matrix argument for det");
X	return matdet(vp->v_mat);
X}
X
X
Xstatic VALUE
Xf_matdim(vp)
X	VALUE *vp;
X{
X	VALUE result;
X
X	if (vp->v_type != V_MAT)
X		error("Non-matrix argument for matdim");
X	result.v_type = V_NUM;
X	result.v_num = itoq((long) vp->v_mat->m_dim);
X	return result;
X}
X
X
Xstatic VALUE
Xf_matmin(v1, v2)
X	VALUE *v1, *v2;
X{
X	VALUE result;
X	NUMBER *q;
X	long i;
X
X	if ((v1->v_type != V_MAT) || (v2->v_type != V_NUM))
X		error("Bad argument type for matmin");
X	q = v2->v_num;
X	i = qtoi(q);
X	if (qisfrac(q) || qisneg(q) || (i <= 0) || (i > v1->v_mat->m_dim))
X		error("Bad dimension value for matmin");
X	result.v_type = V_NUM;
X	result.v_num = itoq(v1->v_mat->m_min[i - 1]);
X	return result;
X}
X
X
Xstatic VALUE
Xf_matmax(v1, v2)
X	VALUE *v1, *v2;
X{
X	VALUE result;
X	NUMBER *q;
X	long i;
X
X	if ((v1->v_type != V_MAT) || (v2->v_type != V_NUM))
X		error("Bad argument type for matmax");
X	q = v2->v_num;
X	i = qtoi(q);
X	if (qisfrac(q) || qisneg(q) || (i <= 0) || (i > v1->v_mat->m_dim))
X		error("Bad dimension value for matmax");
X	result.v_type = V_NUM;
X	result.v_num = itoq(v1->v_mat->m_max[i - 1]);
X	return result;
X}
X
X
Xstatic VALUE
Xf_cp(v1, v2)
X	VALUE *v1, *v2;
X{
X	VALUE result;
X
X	if ((v1->v_type != V_MAT) || (v2->v_type != V_MAT))
X		error("Non-matrix argument for cross product");
X	result.v_type = V_MAT;
X	result.v_mat = matcross(v1->v_mat, v2->v_mat);
X	return result;
X}
X
X
Xstatic VALUE
Xf_dp(v1, v2)
X	VALUE *v1, *v2;
X{
X	if ((v1->v_type != V_MAT) || (v2->v_type != V_MAT))
X		error("Non-matrix argument for dot product");
X	return matdot(v1->v_mat, v2->v_mat);
X}
X
X
Xstatic VALUE
Xf_strlen(vp)
X	VALUE *vp;
X{
X	VALUE result;
X
X	if (vp->v_type != V_STR)
X		error("Non-string argument for strlen");
X	result.v_type = V_NUM;
X	result.v_num = itoq((long) strlen(vp->v_str));
X	return result;
X}
X
X
Xstatic VALUE
Xf_strcat(count, vals)
X	VALUE **vals;
X{
X	register VALUE **vp;
X	register char *cp;
X	int i;
X	long len;
X	long lengths[IN];
X	VALUE result;
X
X	len = 1;
X	vp = vals;
X	for (i = 0; i < count; i++) {
X		if ((*vp)->v_type != V_STR)
X			error("Non-string argument for strcat");
X		lengths[i] = strlen((*vp)->v_str);
X		len += lengths[i];
X		vp++;
X	}
X	cp = (char *)malloc(len);
X	if (cp == NULL)
X		error("No memory for strcat");
X	result.v_str = cp;
X	result.v_type = V_STR;
X	result.v_subtype = V_STRALLOC;
X	i = 0;
X	for (vp = vals; count-- > 0; vp++) {
X		strcpy(cp, (*vp)->v_str);
X		cp += lengths[i++];
X	}
X	return result;
X}
X
X
Xstatic VALUE
Xf_substr(v1, v2, v3)
X	VALUE *v1, *v2, *v3;
X{
X	NUMBER *q1, *q2;
X	long i1, i2, len;
X	char *cp;
X	VALUE result;
X
X	if (v1->v_type != V_STR)
X		error("Non-string argument for substr");
X	if ((v2->v_type != V_NUM) || (v3->v_type != V_NUM))
X		error("Non-numeric positions for substr");
X	q1 = v2->v_num;
X	q2 = v3->v_num;
X	if (qisfrac(q1) || qisneg(q1) || qisfrac(q2) || qisneg(q2))
X		error("Illegal positions for substr");
X	i1 = qtoi(q1);
X	i2 = qtoi(q2);
X	cp = v1->v_str;
X	len = strlen(cp);
X	result.v_type = V_STR;
X	if (i1 > 0)
X		i1--;
X	if (i1 >= len) {	/* indexing off of end */
X		result.v_subtype = V_STRLITERAL;
X		result.v_str = "";
X		return result;
X	}
X	cp += i1;
X	len -= i1;
X	if ((i2 >= len) && (v1->v_subtype == V_STRLITERAL)) {
X		result.v_subtype = V_STRLITERAL;
X		result.v_str = cp;
X		return result;
X	}
X	if (len > i2)
X		len = i2;
X	if (len == 1) {
X		result.v_subtype = V_STRLITERAL;
X		result.v_str = charstr(*cp);
X		return result;
X	}
X	result.v_subtype = V_STRALLOC;
X	result.v_str = (char *)malloc(len + 1);
X	if (result.v_str == NULL)
X		error("No memory for substr");
X	strncpy(result.v_str, cp, len);
X	result.v_str[len] = '\0';
X	return result;
X}
X
X
Xstatic VALUE
Xf_char(vp)
X	VALUE *vp;
X{
X	long num;
X	NUMBER *q;
X	VALUE result;
X
X	if (vp->v_type != V_NUM)
X		error("Non-numeric argument for char");
X	q = vp->v_num;
X	num = qtoi(q);
X	if (qisneg(q) || qisfrac(q) || isbig(q->num) || (num > 255))
X		error("Illegal number for char");
X	result.v_type = V_STR;
X	result.v_subtype = V_STRLITERAL;
X	result.v_str = charstr((int) num);
X	return result;
X}
X
X
Xstatic VALUE
Xf_ord(vp)
X	VALUE *vp;
X{
X	char *str;
X	VALUE result;
X
X	if (vp->v_type != V_STR)
X		error("Non-string argument for ord");
X	str = vp->v_str;
X	if (str[0] && str[1])
X		error("Multi-character string given for ord");
X	result.v_type = V_NUM;
X	result.v_num = itoq((long) (*str & 0xff));
X	return result;
X}
X
X
Xstatic VALUE
Xf_size(vp)
X	VALUE *vp;
X{
X	long count;
X	VALUE result;
X
X	switch (vp->v_type) {
X		case V_NULL:	count = 0; break;
X		case V_MAT:	count = vp->v_mat->m_size; break;
X		case V_LIST:	count = vp->v_list->l_count; break;
X		case V_OBJ:	count = vp->v_obj->o_actions->count; break;
X		default:	count = 1; break;
X	}
X	result.v_type = V_NUM;
X	result.v_num = itoq(count);
X	return result;
X}
X
X
Xstatic VALUE
Xf_search(count, vals)
X	VALUE **vals;
X{
X	VALUE *v1, *v2;
X	NUMBER *q;
X	long start;
X	long index;
X	VALUE result;
X
X	v1 = *vals++;
X	v2 = *vals++;
X	start = 0;
X	if (count == 3) {
X		if ((*vals)->v_type != V_NUM)
X			error("Non-numeric start index for search");
X		q = (*vals)->v_num;
X		if (qisfrac(q) || qisneg(q))
X			error("Bad start index for search");
X		start = qtoi(q);
X	}
X	switch (v1->v_type) {
X		case V_MAT:
X			index = matsearch(v1->v_mat, v2, start);
X			break;
X		case V_LIST:
X			index = listsearch(v1->v_list, v2, start);
X			break;
X		default:
X			error("Bad argument type for search");
X	}
X	result.v_type = V_NULL;
X	if (index >= 0) {
X		result.v_type = V_NUM;
X		result.v_num = itoq(index);
X	}
X	return result;
X}
X
X
Xstatic VALUE
Xf_rsearch(count, vals)
X	VALUE **vals;
X{
X	VALUE *v1, *v2;
X	NUMBER *q;
X	long start;
X	long index;
X	VALUE result;
X
X	v1 = *vals++;
X	v2 = *vals++;
X	start = MAXFULL;
X	if (count == 3) {
X		if ((*vals)->v_type != V_NUM)
X			error("Non-numeric start index for rsearch");
X		q = (*vals)->v_num;
X		if (qisfrac(q) || qisneg(q))
X			error("Bad start index for rsearch");
X		start = qtoi(q);
X	}
X	switch (v1->v_type) {
X		case V_MAT:
X			index = matrsearch(v1->v_mat, v2, start);
X			break;
X		case V_LIST:
X			index = listrsearch(v1->v_list, v2, start);
X			break;
X		default:
X			error("Bad argument type for rsearch");
X	}
X	result.v_type = V_NULL;
X	if (index >= 0) {
X		result.v_type = V_NUM;
X		result.v_num = itoq(index);
X	}
X	return result;
X}
X
X
Xstatic VALUE
Xf_list(count, vals)
X	VALUE **vals;
X{
X	VALUE result;
X
X	result.v_type = V_LIST;
X	result.v_list = listalloc();
X	while (count-- > 0)
X		insertlistlast(result.v_list, *vals++);
X	return result;
X}
X
X
Xstatic VALUE
Xf_listinsert(v1, v2, v3)
X	VALUE *v1, *v2, *v3;
X{
X	VALUE result;
X
X	if ((v1->v_type != V_ADDR) || (v1->v_addr->v_type != V_LIST))
X		error("Inserting into non-list variable");
X	if (v2->v_type == V_ADDR)
X		v2 = v2->v_addr;
X	if ((v2->v_type != V_NUM) || qisfrac(v2->v_num))
X		error("Non-integral index for list insert");
X	if (v3->v_type == V_ADDR)
X		v3 = v3->v_addr;
X	insertlistmiddle(v1->v_addr->v_list, qtoi(v2->v_num), v3);
X	result.v_type = V_NULL;
X	return result;
X}
X
X
Xstatic VALUE
Xf_listpush(v1, v2)
X	VALUE *v1, *v2;
X{
X	VALUE result;
X
X	if ((v1->v_type != V_ADDR) || (v1->v_addr->v_type != V_LIST))
X		error("Pushing onto non-list variable");
X	if (v2->v_type == V_ADDR)
X		v2 = v2->v_addr;
X	insertlistfirst(v1->v_addr->v_list, v2);
X	result.v_type = V_NULL;
X	return result;
X}
X
X
Xstatic VALUE
Xf_listappend(v1, v2)
X	VALUE *v1, *v2;
X{
X	VALUE result;
X
X	if ((v1->v_type != V_ADDR) || (v1->v_addr->v_type != V_LIST))
X		error("Appending to non-list variable");
X	if (v2->v_type == V_ADDR)
X		v2 = v2->v_addr;
X	insertlistlast(v1->v_addr->v_list, v2);
X	result.v_type = V_NULL;
X	return result;
X}
X
X
Xstatic VALUE
Xf_listdelete(v1, v2)
X	VALUE *v1, *v2;
X{
X	VALUE result;
X
X	if ((v1->v_type != V_ADDR) || (v1->v_addr->v_type != V_LIST))
X		error("Deleting from non-list variable");
X	if (v2->v_type == V_ADDR)
X		v2 = v2->v_addr;
X	if ((v2->v_type != V_NUM) || qisfrac(v2->v_num))
X		error("Non-integral index for list delete");
X	removelistmiddle(v1->v_addr->v_list, qtoi(v2->v_num), &result);
X	return result;
X}
X
X
Xstatic VALUE
Xf_listpop(vp)
X	VALUE *vp;
X{
X	VALUE result;
X
X	if ((vp->v_type != V_ADDR) || (vp->v_addr->v_type != V_LIST))
X		error("Popping from non-list variable");
X	removelistfirst(vp->v_addr->v_list, &result);
X	return result;
X}
X
X
Xstatic VALUE
Xf_listremove(vp)
X	VALUE *vp;
X{
X	VALUE result;
X
X	if ((vp->v_type != V_ADDR) || (vp->v_addr->v_type != V_LIST))
X		error("Removing from non-list variable");
X	removelistlast(vp->v_addr->v_list, &result);
X	return result;
X}
X
X
X/*
X * Return the current runtime of calc in seconds.
X * This is the user mode time only.
X */
Xstatic NUMBER *
Xf_runtime()
X{
X	struct tms buf;
X
X	times(&buf);
X	return iitoq((long) buf.tms_utime, (long) CLK_TCK);
X}
X
X
Xstatic VALUE
Xf_fopen(v1, v2)
X	VALUE *v1, *v2;
X{
X	VALUE result;
X	FILEID id;
X
X	if (v1->v_type != V_STR)
X		error("Non-string filename for fopen");
X	if (v2->v_type != V_STR)
X		error("Non-string mode for fopen");
X	id = openid(v1->v_str, v2->v_str);
X	if (id == FILEID_NONE) {
X		result.v_type = V_NUM;
X		result.v_num = itoq((long) errno);
X	} else {
X		result.v_type = V_FILE;
X		result.v_file = id;
X	}
X	return result;
X}
X
X
Xstatic VALUE
Xf_fclose(vp)
X	VALUE *vp;
X{
X	VALUE result;
X
X	if (vp->v_type != V_FILE)
X		error("Non-file for fclose");
X	if (closeid(vp->v_file)) {
X		result.v_type = V_NUM;
X		result.v_num = itoq((long) errno);
X	} else
X		result.v_type = V_NULL;
X	return result;
X}
X
X
Xstatic VALUE
Xf_ferror(vp)
X	VALUE *vp;
X{
X	VALUE result;
X
X	if (vp->v_type != V_FILE)
X		error("Non-file for ferror");
X	result.v_type = V_NUM;
X	result.v_num = itoq((long) errorid(vp->v_file));
X	return result;
X}
X
X
Xstatic VALUE
Xf_feof(vp)
X	VALUE *vp;
X{
X	VALUE result;
X
X	if (vp->v_type != V_FILE)
X		error("Non-file for feof");
X	result.v_type = V_NUM;
X	result.v_num = itoq((long) eofid(vp->v_file));
X	return result;
X}
X
X
Xstatic VALUE
Xf_fflush(vp)
X	VALUE *vp;
X{
X	VALUE result;
X
X	if (vp->v_type != V_FILE)
X		error("Non-file for fflush");
X	flushid(vp->v_file);
X	result.v_type = V_NULL;
X	return result;
X}
X
X
Xstatic VALUE
Xf_fprintf(count, vals)
X	VALUE **vals;
X{
X	VALUE result;
X
X	if (vals[0]->v_type != V_FILE)
X		error("Non-file for fprintf");
X	if (vals[1]->v_type != V_STR)
X		error("Non-string format for fprintf");
X	idprintf(vals[0]->v_file, vals[1]->v_str, count - 2, vals + 2);
X	result.v_type = V_NULL;
X	return result;
X}
X
X
Xstatic VALUE
Xf_printf(count, vals)
X	VALUE **vals;
X{
X	VALUE result;
X
X	if (vals[0]->v_type != V_STR)
X		error("Non-string format for printf");
X	idprintf(FILEID_STDOUT, vals[0]->v_str, count - 1, vals + 1);
X	result.v_type = V_NULL;
X	return result;
X}
X
X
Xstatic VALUE
Xf_strprintf(count, vals)
X	VALUE **vals;
X{
X	VALUE result;
X
X	if (vals[0]->v_type != V_STR)
X		error("Non-string format for strprintf");
X	divertio();
X	idprintf(FILEID_STDOUT, vals[0]->v_str, count - 1, vals + 1);
X	result.v_str = getdivertedio();
X	result.v_type = V_STR;
X	result.v_subtype = V_STRALLOC;
X	return result;
X}
X
X
Xstatic VALUE
Xf_fgetc(vp)
X	VALUE *vp;
X{
X	VALUE result;
X	int ch;
X
X	if (vp->v_type != V_FILE)
X		error("Non-file for fgetc");
X	ch = getcharid(vp->v_file);
X	result.v_type = V_NULL;
X	if (ch != EOF) {
X		result.v_type = V_STR;
X		result.v_subtype = V_STRLITERAL;
X		result.v_str = charstr(ch);
X	}
X	return result;
X}
X
X
Xstatic VALUE
Xf_fgetline(vp)
X	VALUE *vp;
X{
X	VALUE result;
X	char *str;
X
X	if (vp->v_type != V_FILE)
X		error("Non-file for fgetline");
X	readid(vp->v_file, &str);
X	result.v_type = V_NULL;
X	if (str) {
X		result.v_type = V_STR;
X		result.v_subtype = V_STRALLOC;
X		result.v_str = str;
X	}
X	return result;
X}
X
X
Xstatic VALUE
Xf_files(count, vals)
X	VALUE **vals;
X{
X	VALUE result;
X
X	if (count == 0) {
X		result.v_type = V_NUM;
X		result.v_num = itoq((long) MAXFILES);
X		return result;
X	}
X	if ((vals[0]->v_type != V_NUM) || qisfrac(vals[0]->v_num))
X		error("Non-integer for files");
X	result.v_type = V_NULL;
X	result.v_file = indexid(qtoi(vals[0]->v_num));
X	if (result.v_file != FILEID_NONE)
X		result.v_type = V_FILE;
X	return result;
X}
X
X
X/*
X * Show the list of primitive built-in functions
X */
Xvoid
Xshowbuiltins()
X{
X	register struct builtin *bp;	/* current function */
X
X	printf("\nName\tArgs\tDescription\n\n");
X	for (bp = builtins; bp->b_name; bp++) {
X		printf("%-9s ", bp->b_name);
X		if (bp->b_maxargs == IN)
X			printf("%d+    ", bp->b_minargs);
X		else if (bp->b_minargs == bp->b_maxargs)
X			printf("%-6d", bp->b_minargs);
X		else
X			printf("%d-%-4d", bp->b_minargs, bp->b_maxargs);
X		printf(" %s\n", bp->b_desc);
X	}
X	printf("\n");
X}
X
X
X/*
X * Return the index of a built-in function given its name.
X * Returns minus one if the name is not known.
X */
Xgetbuiltinfunc(name)
X	char *name;
X{
X	register struct builtin *bp;
X
X	for (bp = builtins; bp->b_name; bp++) {
X		if ((*name == *bp->b_name) && (strcmp(name, bp->b_name) == 0))
X		return (bp - builtins);
X	}
X	return -1;
X}
X
X
X/*
X * Given the index of a built-in function, return its name.
X */
Xchar *
Xbuiltinname(index)
X	long index;
X{
X	if ((unsigned long)index >= (sizeof(builtins) / sizeof(builtins[0])) - 1)
X		return "";
X	return builtins[index].b_name;
X}
X
X
X/*
X * Given the index of a built-in function, and the number of arguments seen,
X * determine if the number of arguments are legal.  This routine is called
X * during parsing time.
X */
Xvoid
Xbuiltincheck(index, count)
X	long index;
X{
X	register struct builtin *bp;
X
X	if ((unsigned long)index >= (sizeof(builtins) / sizeof(builtins[0])) - 1)
X		error("Unknown built in index");
X	bp = &builtins[index];
X	if (count < bp->b_minargs)
X		scanerror(T_NULL, "Too few arguments for builtin function \"%s\"",
X	bp->b_name);
X	if (count > bp->b_maxargs)
X		scanerror(T_NULL, "Too many arguments for builtin function \"%s\"",
X			bp->b_name);
X}
X
X
X/*
X * Return the opcode for a built-in function that can be used to avoid
X * the function call at all.
X */
Xbuiltinopcode(index)
X	long index;
X{
X	if ((unsigned long)index >= (sizeof(builtins) / sizeof(builtins[0])) - 1)
X		return OP_NOP;
X	return builtins[index].b_opcode;
X}
X
X/* END CODE */
END_OF_FILE
if test 47105 -ne `wc -c <'func.c'`; then
    echo shar: \"'func.c'\" unpacked with wrong size!
fi
# end of 'func.c'
fi
echo shar: End of archive 20 \(of 21\).
cp /dev/null ark20isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
