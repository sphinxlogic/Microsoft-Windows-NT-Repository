Newsgroups: comp.sources.unix
From: jpr@jpr.com (Jean-Pierre Radley)
Subject: v26i150: xc-4.1 - a serial communications program, V4.1, Part01/03
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: jpr@jpr.com (Jean-Pierre Radley)
Posting-Number: Volume 26, Issue 150
Archive-Name: xc-4.1/part01

[ Note: in spite of its name beginning with an "x", this is not an X11 client.
									--vix ]

  XC is a communications program for Unix/Xenix.
  It runs either interactively or from scripts (samples included).
  It includes Xmodem capabilities, but it can attach the modem's
       stdin/stdout to standalone Zmodem programs.
  It incorporates CompuServe's B+ Protocol.
  Ascii uploads from disk files; ascii captures to disk files.
  Dialing directory, with pre- and post-session commands for the modem.
  Respects cu/uucp LCK..file conventions.
  Carriage returns are discarded in incoming text, and can optionally
       be inserted for outgoing material or B+ uploads.
  Selectable 7e2, 7o2, or 8n1.
  Selectable XON/XOFF flow control.
  Key-bindings.

	jpr@jpr.com (Jean-Pierre Radley)

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  .aus .autocis .callhq .cisdial .exrc .pass .phonelist .rz
#   .sz .temp_opt .uni .xc Configure Copyright MANIFEST Makefile
#   Makefile.in README bsdinst.sh call callback cisdownload myman
#   xc.h.in xcdbglog.c xcdial.c xcsubs.c xcterm.c
# Wrapped by vixie@gw.home.vix.com on Wed Apr 14 00:22:46 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f '.aus' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.aus'\"
else
echo shar: Extracting \"'.aus'\" \(1169 characters\)
sed "s/^X//" >'.aus' <<'END_OF_FILE'
X# .asu or .aus : visit SCOForum and UnixForum
X#	non-stop read, and Prompt Char set to '^h' in all Fora.
X#debug "on"
set cis off
set proto 7e2
X
call ".cisdial"
X
pause 3; transmit "^C"
assign SERVICE eq "scoforum"
call ".pass"
X
X#debug "on"
X
set cfile "/pub/jpr/comm/sco"
waitfor "moment please..."
capture "on"
if waitfor "forum !^h"  75
then
X	call ".temp_opt"			
X	assign Upload eq `ls scoR 2>/dev/null`
X	if Upload eq "scoR"
X	then	capture "off"
X		type "scoR"
X		transmit "^M"
X		while ! waitfor "% choice required"
X			do; done
X		shell "mv scoR /pub/rescue/scoR$$"
X		capture "on"
X	fi
X	transmit "rea new^M^M"
X	while ! waitfor "% choice required"
X		do; done
X	capture "off"
else
X	beep
fi
X
set cfile "/pub/jpr/comm/uni"
transmit "g unixforum^M"
waitfor "moment please..."
capture "on"
if waitfor "forum !^h" 75
then
X	call ".temp_opt"			
X	assign Upload eq `ls uniR 2>/dev/null`
X	if Upload eq "uniR"
X	then	capture "off"
X		type "uniR"
X		transmit "^M"
X		while ! waitfor "% choice required"
X			do; done
X		shell "mv uniR /pub/rescue/uniR$$"
X		capture "on"
X	fi
X	transmit "rea new^M^M"
X	while ! waitfor "% choice required"
X		do; done
X	capture "off"
else
X	beep
fi
X
transmit "off^M"
quit
END_OF_FILE
if test 1169 -ne `wc -c <'.aus'`; then
    echo shar: \"'.aus'\" unpacked with wrong size!
fi
# end of '.aus'
fi
if test -f '.autocis' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.autocis'\"
else
echo shar: Extracting \"'.autocis'\" \(3533 characters\)
sed "s/^X//" >'.autocis' <<'END_OF_FILE'
X# .autocis - xc script to visit CIS automagically.
X# This file uses 4-character tabstops.
X# It will log in, visit CIS Mail (if mail is waiting), then the
X#  PRACTICE and UNIX Fora, uploading any prepared files, downloading
X#  all new messages, and capture them into three separate files.
X
X# The following assumption is made about your CIS interactions:
X#  You are in "expert" mode in MAIL.
X#  You are in Command mode in all Fora.
X#  You have opted for continuous reading in all Fora.
X#  You have set your Prompt Char set to '^H' --backspace-- in all Fora.
X#	This last is VERY critical to the properly trigger the WAITFORs
X
X# This script will call another script, .temp_opt, to set Forum options
X# for only the current login
X
tty "on"		# echo to the tty while script is running (default anyways)
debug "on"		# capture in debug.log providing file pre-exists
set proto 7e2	# CIS is happier
set bps 2400
set cis off		# don't trigger on any stray ENQ character
set xoff on		# set XON/XOFF signalling
X
X#  if linked; then  # this alternate routine calls a
X#	call .cisdial	# sub-script with the dialing information
X#  endif
X
if ! linked; then dial "7662080"; endif	# dial this number
while ! waitfor "CONNECT" 52			# give modem 52 secs to say "CONNECT"
X	do
X		redial
X	done
X
pause 2						# let network catch up
transmit "^C"				# First thing to send CIS
pause 3						# let network catch up
X
debug "off"					# so as not to display the password
X# Now send CIS one string with PPN, first service to go to, and password
transmit "72160,1341/go:mail\\beige*screw^M"
debug "on"
X
if waitfor "CompuServe Mail^M" 8			# we already asked to GO MAIL
then if ! waitfor "No messages pending" 4	# unless nothing waiting, then
X	 set cfile "email"						# use this capture file
X		capture "on"						# open it
X		file echo `date`					# time stamp it
X		transmit "rec all^M"				# ask to read everything
X		while ! waitfor "Mail!"				#  until this string appears
X			do; done						#  script does nothing
X		transmit "del all^M"				# remove msgs from CIS mbox
X		capture "off"						# close the capture file
X	fi
else
X	beep							# beep if we never get to CISMail
endif
X
set cfile "pra"						# new capture file
transmit "g practice^M"				# new Forum
waitfor "moment please..."			# "Welcome" should follow this
capture "on"						# start appending to 'pra'
if waitfor "forum !^H" 60			# prompt with a backspace
then
X	call ".temp_opt"				# set Forum options for this session.
X	assign Upload eq `ls rp 2>/dev/null`
X	if Upload eq "praR"				# is there a 'praR' file
X	then	capture "off"			# then turn off capturing
X		type "praR"					# transmit the 'praR' file
X		transmit "^M"				# this extra newline will trigger
X		while ! waitfor "% choice required"	# this response after the upload
X			do; done
X		shell "mv praR /usr/tmp/praR$$"	# rename the 'praR' file
X		capture "on"				# start capturing again
X	fi
X	transmit "rea new^M^M"			# read all new messages
X	while ! waitfor "% choice required"
X		do; done
X	capture "off"
else
X	beep							# beep if Forum closed, or you get bumped
fi
X
set cfile "uni"						# same stuff in another Forum
transmit "g unixforum^M"
waitfor "moment please..."
capture "on"
if waitfor "forum !^h" 60
then
X	call ".temp_opt"			
X	assign Upload eq `ls ru 2>/dev/null`
X	if Upload eq "uniR"
X	then	capture "off"
X		type "uniR"
X		transmit "^M"
X		while ! waitfor "% choice required"
X			do; done
X		shell "mv uniR /usr/tmp/uniR$$"
X		capture "on"
X	fi
X	transmit "rea new^M^M"
X	while ! waitfor "% choice required"
X		do; done
X	capture "off"
else
X	beep
fi
X
transmit "off^M"
quit
END_OF_FILE
if test 3533 -ne `wc -c <'.autocis'`; then
    echo shar: \"'.autocis'\" unpacked with wrong size!
fi
# end of '.autocis'
fi
if test -f '.callhq' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.callhq'\"
else
echo shar: Extracting \"'.callhq'\" \(849 characters\)
sed "s/^X//" >'.callhq' <<'END_OF_FILE'
X# .callhq
X# script to call and login to a Unix/Xenix system that
X# needs BREAK signals to switch bps rates
X
X	debug "on"		# turn on verbose script reporting
X	tty "on"		# echo received characters to screen
X	set bps 9600 ; 	# extraneous semicolons don't matter
X
X	#dial, if we haven't already from the dial directory
X	if ! linked		# note the space after the "!"
X	then
X		dial "2127874639"
X	endif
X
X	while ! waitfor "CONNECT" 40		# redial forever
X	do
X		redial
X	done
X
X	# try five times to get a login prompt
X	assign counter eq 5
X	while ! waitfor "login:" 10
X	do
X		decr counter; if counter lessthan 1; then quit; fi
X		xmitbrk				# send a BREAK signal
X	done
X
X	# now connected, at login prompt
X	beep					# just a personal touch
X	pause 3
X	transmit "username^M"
X	waitfor "word:" 5
X	debug "off"
X	transmit "password^M"
X	debug "on"
X	exit					# out to terminal mode
END_OF_FILE
if test 849 -ne `wc -c <'.callhq'`; then
    echo shar: \"'.callhq'\" unpacked with wrong size!
fi
# end of '.callhq'
fi
if test -f '.cisdial' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.cisdial'\"
else
echo shar: Extracting \"'.cisdial'\" \(453 characters\)
sed "s/^X//" >'.cisdial' <<'END_OF_FILE'
X# .cisdial - a script to dial CIS on different modems and log in.
X
assign modem eq portname
if ! linked
then	
X	if	modem eq "/dev/ttyA01"
X	then	transmit "ATs0=0 &K2^M"
X		pause 1
X		dial "7662080"
X	fi
X	if	modem eq "/dev/ttyA02"
X		modem eq "/dev/ttyA03"
X	then	transmit "ATs0=0 s58=3^M"
X		pause 1
X		dial "7662080"
X	fi
X	if	modem eq "/dev/tty1A"
X	then	transmit "ATs0=0 s50=3^M"
X		pause 1
X		dial "6086021"
X	fi
fi
X
while ! waitfor "CONNECT" 52; do; redial; done
END_OF_FILE
if test 453 -ne `wc -c <'.cisdial'`; then
    echo shar: \"'.cisdial'\" unpacked with wrong size!
fi
# end of '.cisdial'
fi
if test -f '.exrc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.exrc'\"
else
echo shar: Extracting \"'.exrc'\" \(812 characters\)
sed "s/^X//" >'.exrc' <<'END_OF_FILE'
X" the leading '"' makes this line a comment
X" uncomment lines by removing the leading '"'
X"
X" tab settings for all XC source files 
set ts=4 sw=4
X"
X" macros for handling CompuServe downloads
X" make sure the ^M below are true Ctrl-M
X" make sure the ^[ below are true ESCAPE
X"
X" set wm=1 
X"
X" F5 squeezes out empty lines, marks new setion with 'm'
X" map	#5	/^welcome to /--mm/^Forum !\/d`mSmm:.,$g/^ *$/d'm
X"
X" F2 deletes from current line to mark 'm', and leaves a new mark 'm'
X" map	#2	d`mSmmz
X"
X" with cursor within a message, F1 sets up for a reply
X" map	#1	?^#: \([1-9][0-9]*\) .*S[0-9]*/.*?Y/
X" map		P:s;;re\1;mao/post unfmbO
X"
X" ^X takes a reply prepared after an F1, and appends it to an upload file
X" map		'aO:'a,'b w>>%R:'a,'b d
X"
X" F8 places next message at top of screen
X" map	#8	/#:/z
END_OF_FILE
echo shar: 8 control characters may be missing from \"'.exrc'\"
if test 812 -ne `wc -c <'.exrc'`; then
    echo shar: \"'.exrc'\" unpacked with wrong size!
fi
# end of '.exrc'
fi
if test -f '.pass' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.pass'\"
else
echo shar: Extracting \"'.pass'\" \(833 characters\)
sed "s/^X//" >'.pass' <<'END_OF_FILE'
X#.pass   This script should be protected, it has all your passwords!
X
debug "off"	# prevent screen echoing of the password!
pause 2
X
if SERVICE eq "unixforum"
then
X	set cfile "uni"
X	#set auto "on"
X	set cis "on"
X	transmit "72160.1341/go:unixforum\\harsh#words^M"
X	exit
fi
X
if SERVICE eq "scoforum"
then
X	set cfile "sco"
X	#set auto "on"
X	set cis "on"
X	transmit "72160.1341/go:scoforum\\harsh#words^M"
X	exit
fi
X
if SERVICE eq "mail"
then
X	set cfile "email"
X	#set auto "on"
X	set cis "off"
X	transmit "72160.1341/go:mail\\harsh#words^M"
X	exit
fi
X
if SERVICE eq "cis"
then
X	set cfile "cis"
X	#set auto "on"
X	set cis "off"
X	transmit "72160.1341\\harsh#words^M"
X	exit
fi
X
if SERVICE eq "jpr"
then
X	transmit "jpr^M"
X	waitfor "word:"
X	transmit "enTHuse^M"
fi
X
if SERVICE eq "root"
then
X	transmit "root^M"
X	waitfor "word:"
X	transmit "up&down"
fi
END_OF_FILE
if test 833 -ne `wc -c <'.pass'`; then
    echo shar: \"'.pass'\" unpacked with wrong size!
fi
# end of '.pass'
fi
if test -f '.phonelist' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.phonelist'\"
else
echo shar: Extracting \"'.phonelist'\" \(1221 characters\)
sed "s/^X//" >'.phonelist' <<'END_OF_FILE'
X766-2080 AutoLogin CompuServe	SCRIPT=.aus PROTO=8n1 BPS=57600 PREFIX=ats0=0s50=6
X766-2080 AutoLogin CompuServe	SCRIPT=.autocis PROTO=8n1 BPS=57600 PREFIX=ats0=0s250=6
X766-2080 9600 CompuServe PM9600	PROTO=8n1 BPS=38400 PREFIX=ATs0=0&K2
X766-2080 9600 CompuServe T3000	PROTO=8n1 BPS=57600 PREFIX=ATs0=0s50=6
X608-6021 2400 CompuServe	SCRIPT=.autocis PROTO=7e2 BPS=2400 PREFIX=ATs0s50=3
X608-6021 2400 CompuServe	SCRIPT=.uni PROTO=7e2 BPS=2400 PREFIX=ATs0s50=3
X1-718-335-8784 The Wall-2	PROTO=8n1 BPS=2400 #CHARCOAL
X675-8438 marob/tb	PROTO=8n1 BPS=19200 SCRIPT=.marob PREFIX=ats111=20s110=1s50=255
X675-7059 marob/24	PROTO=8n1 BPS=2400 SCRIPT=.marob24
X677-9487 magpie	PROTO=8n1 BPS=19200 PREFIX=ats110=0s111=0
X529-0498 pcsi	PROTO=8n1 BPS=2400 SCRIPT=.pcsi
X769-0550 nycenet	PROTO=8n1 BPS=2400
X924-4352	Chelsea Square Magpie	PROTO=8n1 BPS=2400
X473-2744	CSig BBS		PROTO=8n1 BPS=2400
X781-4723	Friends!		PROTO=8n1 BPS=2400
X764-3834	Mofo	PROTO=7e2 BPS=1200	# CR, CR
X1-401-351-1465	Macintosh Tree		PROTO=8n1 BPS=2400
X1-408-378-6745	Doug Stein's Magpie	PROTO=8n1 BPS=2400
X10444-1-516-536-8723	Sound of Music		PROTO=8n1 BPS=2400
X1-503-621-3746	Telegodzilla		PROTO=8n1 BPS=2400
X749-8427	INFO BROKER - GO	PROTO=8n1 BPS=2400 PREFIX=ATs0=0
END_OF_FILE
if test 1221 -ne `wc -c <'.phonelist'`; then
    echo shar: \"'.phonelist'\" unpacked with wrong size!
fi
# end of '.phonelist'
fi
if test -f '.rz' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.rz'\"
else
echo shar: Extracting \"'.rz'\" \(152 characters\)
sed "s/^X//" >'.rz' <<'END_OF_FILE'
echo -n "What files are to be received? "
read FILES
transmit "sz -y "
transmit FILES
transmit "^M"
echo "Starting ZMODEM Receive (rz -y)"
pipe "rz -y"
END_OF_FILE
if test 152 -ne `wc -c <'.rz'`; then
    echo shar: \"'.rz'\" unpacked with wrong size!
fi
# end of '.rz'
fi
if test -f '.sz' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.sz'\"
else
echo shar: Extracting \"'.sz'\" \(115 characters\)
sed "s/^X//" >'.sz' <<'END_OF_FILE'
echo -n "What files are to be sent? "
read FILES
echo "Starting ZMODEM send (sz -y " FILES ")"
pipe "sz -y " FILES
END_OF_FILE
if test 115 -ne `wc -c <'.sz'`; then
    echo shar: \"'.sz'\" unpacked with wrong size!
fi
# end of '.sz'
fi
if test -f '.temp_opt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.temp_opt'\"
else
echo shar: Extracting \"'.temp_opt'\" \(459 characters\)
sed "s/^X//" >'.temp_opt' <<'END_OF_FILE'
X# .temp_opt	 set CIS options for auto-scripts.
capture "off"
transmit "opt;"
transmit "1;1;"		# Forum first
transmit "2;3;"		# command mode
transmit "3;N;"		# never stop
transmit "6;2;"		# editor
transmit "9;N;"		# no info. on replies
transmit "10;N;" 	# no waiting messages
transmit "11;N;"	# no skip own messages
transmit "5^M"
waitfor "prompt: "
transmit "\^H^M"	# set prompt to Ctrl-H
waitfor "choice !"
transmit "T^MS^M"	# [T]op ; [S]ession
capture "on"
END_OF_FILE
if test 459 -ne `wc -c <'.temp_opt'`; then
    echo shar: \"'.temp_opt'\" unpacked with wrong size!
fi
# end of '.temp_opt'
fi
if test -f '.uni' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.uni'\"
else
echo shar: Extracting \"'.uni'\" \(1290 characters\)
sed "s/^X//" >'.uni' <<'END_OF_FILE'
X#.uni
X# sample script to call CompuServe, go to the UnixForum,
X# and enter terminal mode
X
X	debug "on"		# turn on verbose script reporting
X	tty "on"		# echo received characters to screen
X	set bps 2400	# numbers don't need literal quotes
X	set proto 7E2	# CIS is happier
X
X	if ! linked; then		# dial if we haven't already
X		dial "9687790"
X	endif
X
X	while ! waitfor "CONNECT" 35	# redial forever
X	do
X		redial
X	done
X
X	pause 2				# wait for network to catch up
X
X	# wait for a "User ID" prompt, but put a cap on how long
X	transmit "^C"
X	assign counter eq 1
X	while ! waitfor " ID" 20
X	do
X		incr counter
X		if counter morethan 5; then quit; endif
X		transmit "^C"
X	done
X
X	pause 2				# wait for network to catch up
X	transmit "72160,1341^M"		# send user ID number (PPN)
X
X	# if no "Password:" prompt in 20 seconds, bomb out
X	if ! waitfor "word" 20 ; then quit; endif
X
X	debug "off"			# password protection
X	pause 1; transmit "My*Password^M"
X	debug "on"
X
X	waitfor "!" 20
X
X	transmit "g unixfo^M"
X
X	# if we don't see "Welcome", we're not in the Forum
X	if ! waitfor "Welcome" 20
X	then				# <- NEVER forget the "then"!
X		transmit "bye^M"
X		quit			# this is total program death
X	else
X		beep			# just a personal touch
X	endif
X
X	set cis on			# enable auto-startup of CIS B+ transfers
X
X	exit				# enter terminal mode
END_OF_FILE
if test 1290 -ne `wc -c <'.uni'`; then
    echo shar: \"'.uni'\" unpacked with wrong size!
fi
# end of '.uni'
fi
if test -f '.xc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.xc'\"
else
echo shar: Extracting \"'.xc'\" \(1284 characters\)
sed "s/^X//" >'.xc' <<'END_OF_FILE'
X# .xc -- startup script
set bps 57600
set cis off
set proto 8N1
set cr on
set nl on
set xoff on
set hdplx off
set menu on
set auto on
set XCAPE 
X
X#assign modem eq portname
X# setting different default speeds for assorted modems
X# note that the following means: if ANY of the three conditions are met
if modem eq "/dev/ttyA01"; modem eq "/dev/ttyA02"; modem eq "/dev/ttyA03" ; modem eq "/dev/ttyA08"
then
X	set bps 38400
else
X	set bps 2400
endif
X
X#####
X# Dynamic keyboard binding feature
X#####
X
X# Set terminal mode escape character ("XCAPE") to Control-Z:
X# set escape ^Z
X
X# Bind XCAPE-0 to set Telebit T2500 to not require MNP:
bind_string "AAAAT S95=0^M" 48
X
X# Bind XCAPE-1 to set Telebit T2500 to attempt LAP/M and then MNP:
bind_string 49 "AAAAT S95=1 S96=1 S97=1 S98=3 S106=0^M"
X
X# Bind XCAPE-^S to receive a file using sz (.sz included in distribution)
bind_script 19 "/usr/lib/xc/.sz"
X
X# Bind XCAPE-^R to receive a file using rz (.rz included in distribution)
bind_script 18 "/usr/lib/xc/.rz"
X
X# Bind XCAPE-^Z to exit out of XC (a la vi).  Note that this is dangerous
X# because you no longer have a way of emitting a XCAPE through the modem,
X# except by embedding the command into a "bind_string" or "bind_script".
X# It's still a neat exit command...
X
bind_function 26 "quitchr"
END_OF_FILE
echo shar: 1 control character may be missing from \"'.xc'\"
if test 1284 -ne `wc -c <'.xc'`; then
    echo shar: \"'.xc'\" unpacked with wrong size!
fi
# end of '.xc'
fi
if test -f 'Configure' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Configure'\"
else
echo shar: Extracting \"'Configure'\" \(8960 characters\)
sed "s/^X//" >'Configure' <<'END_OF_FILE'
X#! /bin/sh
X
trap "rm -f tmp*; exit 0" 0
trap "rm -f tmp*; exit 1" 1 2 3 15
X
die()
X{
X    echo "$*"
X    exit 1
X}
X
yorn()
X{
X    while :
X    do
X        read ans
X
X	case "${ans:-$1}" in
X	[Yy]*)	return 0
X		;;
X	[Nn]*)	return 1
X		;;
X	*)	nonl "Please respond 'Y' or 'N': "
X		;;
X	esac
X    done
X}
X
find_exe()
X{
for i in `echo $PATH |
X	  sed -e 's/^:/.:/' \
X		  -e 's/::/:.:/g' \
X		  -e 's/:$/:./' \
X		  -e 's/:/ /g`
do
X	if [ -x "$i/$1" ]
X	then
X		return 0
X	fi
done
return 1
X}
X
case `echo -n` in
X-n)	nonl() { echo "$*\c"; };;
X*)	nonl() { echo -n "$*"; };;
esac
X
echo
echo "XC Configuration Utility -- written by lar3ry gensch, ESQ"
echo
echo "When a default answer is suggested [in brackets],"
echo "you may accept it by just hitting <ENTER>."
echo
X
need_answers=true
X
if [ -f configure.out ]
then
X    echo "Configure has already been run."
X    nonl "Do you wish to use the previous results? (Y/N) [N]: "
X    if yorn N
X    then
X		. ./configure.out
X		need_answers=false
X    fi
fi
X
if $need_answers
then
X    UUCPLIBDIR=/usr/lib/uucp
X
X    if [ ! -d "$UUCPLIBDIR" ]
X    then
X		echo "*** Warning:  Cannot determine UUCP lib directory"
X		echo "***           Using $UUCPLIBDIR"
X		echo
X    fi
X
X    if [ -f $UUCPLIBDIR/ungetty -a -f /xenix ]
X    then
X		DIDO="2"	
X    elif [ -d /var/spool/locks -a -f /usr/include/sys/mkdev.h ]
X    then
X		DIDO="4"
X    elif [ -f /unix ]
X    then
X		DIDO="3"
X    else
X		DIDO="0"
X    fi
X
X    echo
X    echo "Determining compile environment..."
X
X    CC=""
X    COPTS=""
X
X	while :
X	do
X		if find_exe gcc
X		then
X			CC=gcc
X			COPTS="-O2"
X		elif find_exe cc
X		then
X			CC=cc
X			COPTS="-O"
X		else
X			CC=""
X		fi
X
X		nonl "C compiler to use [${CC}]: "
X		read cc
X
X		[ -n "$cc" ] && CC="$cc"
X
X		if find_exe $CC
X		then
X		   break
X		fi
X	done
X
X    echo
X    echo "C Compiler is $CC"
X
X    default="$COPTS"
X    while :
X    do
X		echo
X		nonl "Enter compiler options [$default]: "
X		read ans
X
X		[ -n "$ans" ] && COPTS="$ans"
X
X		echo "main() { }" >tmp.c
X		$CC $COPTS tmp.c -o tmp >/dev/null 2>&1 && break
X
X		echo "Those options don't seem quite right... try again."
X    done
X
X	echo
X	echo "Determining where to find screen control functions..."
X
X	echo "main() { tgetent(); }" >tmp.c
X	for LDFLAGS in -ltermcap -ltinfo -lcurses ""
X	do
X		$CC tmp.c -o tmp $LDFLAGS >/dev/null 2>&1 && break
X	done
X		
X	if [ ! $LDFLAGS ]
X	then
X		echo
X		echo "*** We tried -ltermcap, -ltinfo, and -lcurses without success."
X		while :
X		do
X			nonl "Enter a '-lLIB' option for a screen control library: "
X			read LDFLAGS
X
X			$CC tmp.c -o tmp $LDFLAGS >/dev/null 2>&1 && break
X
X			echo "That isn't finding the tgetent() function... try again."
X			echo
X		done
X	fi
X
X    if [ -f /lib/libc_s.a -o -f /usr/lib/libc_s.a ]
X    then
X		LDFLAGS="$LDFLAGS -lc_s"
X    fi
X
X	echo
X    echo "LDFLAGS = $LDFLAGS"
X
X    echo
X    echo "Checking run time library for functions..."
X
X    eval `for i in "dup2(i,j)" \
X		   "memset(s,c,i)" \
X		   "strchr(s,c)" \
X		   "strrchr(s,c)" \
X		   "strdup(s)" \
X		   "strstr(s,t)"
X    do
X		funct=\`echo "$i" | sed 's/(.*$//'\`
X
X		cat >tmp.c <<!
int i,j;
char *s,*t;
char c;
main() { $i; }
X!
X
X		$CC $COPTS -o tmp tmp.c $LDFLAGS >/dev/null 2>&1 || rm -f tmp
X		if [ -f tmp ]
X		then
X			val="1"
X			echo "    $funct was found" 1>&2
X		else
X			val="0"
X			echo "    $funct was not found" 1>&2
X		fi
X
X		rm -f tmp*
X		echo "have_${funct}=$val"
X    done`
X
X    echo
X    echo "Checking <sys/types.h> for typedefs..."
X
X    eval `for i in pid_t ulong unchar ushort
X    do
X		if [ ! -f /usr/include/sys/types.h ]
X		then
X			echo "have_$i=false"
X			continue
X		fi
X
X		cat >tmp.c <<!
X#include <sys/types.h>
X$i foo;
X!
X
X		$CC $COPTS -c tmp.c >/dev/null 2>&1
X		if [ -f tmp.o ]
X		then
X			val=1
X			echo "    $i was found" 1>&2
X		else
X			val=0
X			echo "    $i was not found" 1>&2
X		fi
X
X		echo "have_$i=$val"
X		rm -f tmp*
X    done`
X
X    echo
X    echo "XC Local Configuration Section"
X
X    while :
X    do
X		nonl "Enter user name to own xc [uucp]: "
X
X		read ans
X
X		OWNER="${ans:-uucp}"
X
X		case "$OWNER" in
X		*:*)	echo "Invalid user name"
X			;;
X		*)	grep "^${OWNER}:" /etc/passwd >/dev/null 2>&1 && break
X			echo "User $OWNER not found in /etc/passwd"
X			;;
X		esac
X    done
X
X    while :
X    do
X		nonl "Enter group name to own xc [uucp]: "
X
X		read ans
X
X		GROUP="${ans:-uucp}"
X
X		case "$GROUP" in
X		*:*)	echo "Invalid group name"
X			;;
X		*)	grep "^${GROUP}:" /etc/group >/dev/null 2>&1 && break
X			echo "Group $GROUP not found in /etc/group"
X		;;
X		esac
X    done
X
X    while :
X    do
X		nonl "Enter permissions for xc executable [4755]: "
X
X		read ans
X
X		BINMODE="${ans:-4755}"
X
X		case "$BINMODE" in
X		[0-1][0-7][0-7][0-7]|[0-7][0-7][0-7])
X			echo "*** Warning permissions are not SUID or SGID"
X			INSTALL="install"
X			break
X			;;
X
X		[2-7][0-7][0-7][0-7])
X			INSTALL="install.suid"
X			INSTPREF="su to 'root', and then "
X			break
X			;;
X		*)	echo "Invalid permissions"
X			;;
X		esac
X    done
X
X    echo
X
X    MDIR=""
X    MANDIR=""
X    MANEXT=""
X
X    for i in /usr/local/man /usr/catman /usr/man
X    do
X        if [ -d "$i" ]
X	then
X	    MANDIR=$i
X	    break
X	fi
X    done
X
X    if [ -z "$MANDIR" ]
X    then
X		echo "*** Warning:  Cannot determine MANDIR"
X		echo "              Using /usr/man/mann"
X		MANDIR=/usr/man
X		MDIR=mann
X		MANEXT=n
X	else
X        eval `for i in cat man
X		do
X			for j in n l 1 L LOCAL
X			do
X				dir=${i}${j}
X				if [ -d "$MANDIR/$dir" ]
X				then
X					echo MDIR=$dir
X					echo MANEXT=$j
X					break 2
X				fi
X				dir=${i}.${j}
X				if [ -d "$MANDIR/$dir" ]
X				then
X					echo MDIR=$dir
X					echo MANEXT=$j
X					break 2
X				fi
X			done
X		done`
X
X		if [ -z "$MDIR" ]
X		then
X			echo "*** Warning: Could not locate online man pages"
X			MDIR=mann
X			MANEXT=n
X		fi
X    fi
X
X    echo "Using MANDIR $MANDIR/$MDIR ..."
X    echo
X
X    case "$MDIR" in
X    cat*)	CATMAN=true
X		;;
X    *)		CATMAN=false
X		;;
X    esac
X
X    default=""
X	for i in /usr/local/bin /pub/bin /usr/lbin /usr/bin/local /u/bin
X	do
X		if [ -d "$i" ]
X		then
X			default="$i"
X			break
X		fi
X	done
X
X    while :
X    do
X		nonl "Enter installation directory [$default]: "
X		read ans
X
X		INSDIR="${ans:-$default}"
X
X		case "$INSDIR" in
X		/*)	[ -d "$INSDIR" ] && break
X			echo "Directory $ans was not found"
X			;;
X		*)	echo "Directory $ans is not an absolute path"
X			;;
X		esac
X	done
X
X    echo
X    nonl "Do you wish to add DEBUG code into XC? (Y/N) [Y]: "
X    if yorn Y
X	then
X		DEBUG="1"
X    else
X		DEBUG="0"
X    fi
X
X    echo
X    nonl "Do you wish to disallow shell escapes? (Y/N) [N]: "
X
X    if yorn N
X	then
X		NOSHELL="1"
X    else
X		NOSHELL="0"
X    fi
X
X    echo
X    nonl "Does dropping carrier cause your modem to hang up? (Y/N) [Y]: "
X
X    if yorn Y
X	then
X		DTR_DROPS_CARRIER="1"
X    else
X		DTR_DROPS_CARRIER="0"
X    fi
X
X    default=""
X    for i in /usr/local/lib /usr/lib/local /usr/lib /u/lib
X    do
X        if [ -d "$i" ]
X	then
X	    default="$i/xc"
X	    break
X	fi
X    done
X
X    echo
X    while :
X    do
X		nonl "Enter default XC data file directory [$default]: "
X
X		read ans
X
X		LIBDIR=${ans:-$default}
X
X		case "$LIBDIR" in
X		/*)	[ -d "$LIBDIR" ] && break
X			parent=`dirname $LIBDIR`
X			[ -d "$parent" -a ! -f $LIBDIR ] && break
X			if [ -d "$parent" ]
X			then
X				echo "$LIBDIR is not a directory"
X			else
X				echo "Parent directory $parent not found"
X			fi
X			;;
X		*)	echo "Directory $LIBDIR is not an absolute path"
X			;;
X		esac
X	done
X
X    DATE=`date`
X	USER=`id | sed -e 's/[^(]*(//' -e s'/).*$//'`
X
X    cat >./configure.out <<!
BINMODE="$BINMODE"
CATMAN="$CATMAN"
CC="$CC"
COPTS="$COPTS"
DATE="$DATE"
DEBUG="$DEBUG"
DIDO="$DIDO"
DTR_DROPS_CARRIER="$DTR_DROPS_CARRIER"
GROUP="$GROUP"
have_dup2="$have_dup2"
have_memset="$have_memset"
have_pid_t="$have_pid_t"
have_strchr="$have_strchr"
have_strdup="$have_strdup"
have_strrchr="$have_strrchr"
have_strstr="$have_strstr"
have_ulong="$have_ulong"
have_unchar="$have_unchar"
have_ushort="$have_ushort"
INSDIR="$INSDIR"
INSTALL="$INSTALL"
INSTPREF="$INSTPREF"
LDFLAGS="$LDFLAGS"
LIBDIR="$LIBDIR"
MANDIR="$MANDIR"
MANEXT="$MANEXT"
MDIR="$MDIR"
NOSHELL="$NOSHELL"
OWNER="$OWNER"
USER="$USER"
X!
fi
X
set -e
X
echo
echo "Creating xc.h ..."
X
sed "
s;{{DATE}};$DATE;g
s;{{DEBUG}};$DEBUG;g
s;{{DIDO}};$DIDO;g
s;{{DTR_DROPS_CARRIER}};$DTR_DROPS_CARRIER;g
s;{{HAVE_DUP2}};$have_dup2;g
s;{{HAVE_MEMSET}};$have_memset;g
s;{{HAVE_PID_T}};$have_pid_t;g
s;{{HAVE_STRCHR}};$have_strchr;g
s;{{HAVE_STRDUP}};$have_strdup;g
s;{{HAVE_STRRCHR}};$have_strrchr;g
s;{{HAVE_STRSTR}};$have_strstr;g
s;{{HAVE_ULONG}};$have_ulong;g
s;{{HAVE_UNCHAR}};$have_unchar;g
s;{{HAVE_USHORT}};$have_ushort;g
s;{{LIBDIR}};$LIBDIR;g
s;{{NOSHELL}};$NOSHELL;g
s;{{USER}};$USER;g
X" xc.h.in >xc.h
X
echo
echo "Creating Makefile.xc ..."
X
sed "
s;{{BINMODE}};$BINMODE;g
s;{{CATMAN}};$CATMAN;g
s;{{CC}};$CC;g
s;{{COPTS}};$COPTS;g
s;{{DATE}};$DATE;g
s;{{GROUP}};$GROUP;g
s;{{INSDIR}};$INSDIR;g
s;{{INSTALL}};$INSTALL;g
s;{{INSTPREF}};$INSTPREF;g
s;{{LDFLAGS}};$LDFLAGS;g
s;{{LIBDIR}};$LIBDIR;g
s;{{MANDIR}};$MANDIR;g
s;{{MANEXT}};$MANEXT;g
s;{{MDIR}};$MDIR;g
s;{{OWNER}};$OWNER;g
s;{{USER}};$USER;g
X" Makefile.in >Makefile.xc
X
echo
echo "XC Configuration is now complete..."
X
exit 0
END_OF_FILE
if test 8960 -ne `wc -c <'Configure'`; then
    echo shar: \"'Configure'\" unpacked with wrong size!
fi
chmod +x 'Configure'
# end of 'Configure'
fi
if test -f 'Copyright' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Copyright'\"
else
echo shar: Extracting \"'Copyright'\" \(496 characters\)
sed "s/^X//" >'Copyright' <<'END_OF_FILE'
XXC and its source files and sample scripts and manual page are Copyright
X1993 by Jean-Pierre Radley.
X
Permission is granted to the public to use this code in any manner, without
any warranty, implied or otherwise, of fitness for a particular purpose.
X
By virtue of a restriction previously placed upon all code derivative from
XXCOMM, the XC code and associated files may not be sold by anyone to anyone,
nor incorporated into any product that is not also free. It's OK to transfer
them for free.
END_OF_FILE
if test 496 -ne `wc -c <'Copyright'`; then
    echo shar: \"'Copyright'\" unpacked with wrong size!
fi
# end of 'Copyright'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1150 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X .aus                       1	
X .autocis                   1	
X .callhq                    1	
X .cisdial                   1	
X .exrc                      1	
X .pass                      1	
X .phonelist                 1	
X .rz                        1	
X .sz                        1	
X .temp_opt                  1	
X .uni                       1	
X .xc                        1	
X Configure                  1	
X Copyright                  1	
X MANIFEST                   1	
X Makefile                   1	
X Makefile.in                1	
X README                     1	
X bsdinst.sh                 1	
X call                       1	
X callback                   1	
X cisdownload                1	
X myman                      1	
X xc.h.in                    1	
X xc.nro                     3	
X xcb+.c                     2	
X xcdbglog.c                 1	
X xcdial.c                   1	
X xcmain.c                   2	
X xcport.c                   2	
X xcscrpt.c                  3	
X xcsubs.c                   1	
X xcterm.c                   1	
X xcxmdm.c                   2	
END_OF_FILE
if test 1150 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(283 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile for XC
SHELL=/bin/sh
X
all \
xc \
install \
install.suid \
xc.man \
install.man \
clean \
shar \
tah \
taz \
lha \
shark:			Makefile.xc xc.h
X				make $(MFLAGS) -f Makefile.xc $@
X
Makefile.xc:	Makefile.in Configure
X				./Configure
X
xc.h:			xc.h.in Configure
X				./Configure
END_OF_FILE
if test 283 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'Makefile.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.in'\"
else
echo shar: Extracting \"'Makefile.in'\" \(2405 characters\)
sed "s/^X//" >'Makefile.in' <<'END_OF_FILE'
X# Makefile for XC
X# This file was generated by Configure on {{DATE}} by {{USER}}
X
BINMODE	= {{BINMODE}}
CATMAN	= {{CATMAN}}
CC		= {{CC}}
CFLAGS	= {{COPTS}}
GROUP	= {{GROUP}}
INSDIR	= {{INSDIR}}
LIBDIR	= {{LIBDIR}}
LDFLAGS	= {{LDFLAGS}}
MANDIR	= {{MANDIR}}/{{MDIR}}
MANEXT	= {{MANEXT}}
MANMODE	= 0444
OWNER	= {{OWNER}}
X
X# you should have all of these files:
X
MANIFEST	=\
X	.aus\
X	.autocis\
X	.callhq\
X	.cisdial\
X	.exrc\
X	.pass\
X	.phonelist\
X	.rz\
X	.sz\
X	.temp_opt\
X	.uni\
X	.xc\
X	Configure\
X	Copyright\
X	Makefile\
X	Makefile.in\
X	README\
X	bsdinst.sh\
X	call\
X	callback\
X	cisdownload\
X	myman\
X	xc.h.in\
X	xc.nro\
X	xcb+.c\
X	xcdbglog.c\
X	xcdial.c\
X	xcmain.c\
X	xcport.c\
X	xcscrpt.c\
X	xcsubs.c\
X	xcterm.c\
X	xcxmdm.c
X
OBJS =	xcb+.o\
X		xcdbglog.o\
X		xcdial.o\
X		xcmain.o\
X		xcport.o\
X		xcscrpt.o\
X		xcsubs.o\
X		xcterm.o\
X		xcxmdm.o
X
all:	xc
X	@echo "All targets are up to date"
X	@echo "Now you must {{INSTPREF}}execute 'make {{INSTALL}}'"
X
xc:		$(OBJS)
X	$(CC) $(CFLAGS) $(OBJS) -o xc $(LDFLAGS) 
X
X{{INSTALL}}: 	xc
X	-mv $(INSDIR)/xc $(INSDIR)/xc-
X	./bsdinst.sh -c -o $(OWNER) -g $(GROUP) -m $(BINMODE) -s xc $(INSDIR)/xc
X	-@ls -l ./xc $(INSDIR)/xc $(INSDIR)/xc-
X	@echo
X	@echo "The sample xc scripts (.aus .autocis .callhq .cisdial .exrc"
X	@echo ".pass .phonelist .rz .sz .temp_opt .uni .xc) should be manually"
X	@echo "moved to the $(LIBDIR) directory.  The shell scripts (call"
X	@echo "callback cisdownload) should be moved to the $(INSDIR) directory."
X	@echo
X	@echo "We do not do this automatically, as you may want to recompile xc"
X	@echo "with different options, yet not touch these scripts once you've"
X	@echo "personalized them with your own passwords and telephone numbers."
X
install.man:	xc.out
X	./bsdinst.sh -c -m $(MANMODE) xc.out $(MANDIR)/xc.$(MANEXT)
X	touch install.man
X
xc.out:	xc.man
X	if $(CATMAN); then				\
X		nroff xc.man | col >xc.out;	\
X	else							\
X			cat xc.man >xc.out;		\
X	fi
X
xc.man:	myman xc.nro
X	cat myman xc.nro | grep -v '^\.tm ' | tbl >xc.man
X
clean:;	rm -f $(OBJS) xc xc.man xc.out core man catman\
X		configure.out Makefile.xc xc.h *~ *\#
X
X$(OBJS):	xc.h
X
xc.h:	xc.h.in Configure
X	./Configure
X
shar:
X	shar -awF -L51 -nXC -oXC -s jpr@jpr.com $(MANIFEST)
X	@ls -l XC.??
X
taz:
X	tar cf - $(MANIFEST) | compress > XC.TAR.Z
X	@ls -l *.Z
X
tah:
X	tar cf - $(MANIFEST) | compress -H > XC.TAR.Z
X	@ls -l *.Z
X
lha:
X	lha c XC $(MANIFEST)
X	@ls -L XC.A XC.lha
X
shark:
X	shark $(MANIFEST) > XC.SHK
X	@ls -l *SHK
END_OF_FILE
if test 2405 -ne `wc -c <'Makefile.in'`; then
    echo shar: \"'Makefile.in'\" unpacked with wrong size!
fi
# end of 'Makefile.in'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(14633 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X@(#) XC README, patchlevel 4.1 JPRadley 10 April 1993
This file (and almost every other one in the distribution) uses 4-character
tabstops.
The supplied .exrc file sets ts=4 and sw=4, for vi's purposes.
X
X
X	B A C K G R O U N D
X
Once upon a time (in 1985 or so), a fellow named Eric Coe wrote a Unix dialout
telecommunications program with xmodem called XCOMM. This program was
substantially upgraded and improved by another fellow named Larry Gensch, who
brought XCOMM up to Version 2.2. Version 2.2 included a simple script
language, 128-byte Xmodem and Compuserve Quick-B file-transfer protocols, and
some other stuff. Fred Buck then changed the program name to XCMALT, which it
maintained until June 1991, when Jean-Pierre Radley renamed it XC. 
X
XXC is a massive expansion and modification of XCOMM 2.2. Many bugs in
XXCOMM 2.2 have been fixed, and many advertised features that didn't work in
XXCOMM 2.2 do work in XC. Also, XC includes a fullscreen dialing directory; a
totally rewritten and much more powerful script language allowing, among other
things, remote execution of shell commands and unattended protocol-controlled
file transfer (provided that your system also has Chuck Forsberg's "rz/sz"
XXmodem/Ymodem/Zmodem program, available as shareware from many sources), a
flexible variable mechanism, including access to shell environment variables,
and more; BREAK-signal capability; the capability to upload a file in ASCII
from within a script; and miscellaneous cosmetic changes.
X
But while XC incorporates much of Larry Gensch's work, it's not supported by
Larry Gensch (although he contributed the key-binding features starting with
XXC3.2a). The changes from XCOMM 2.2 are the product of Steve Manes, who
installed uucp LCKfile support and special compile-time tuning for SCO Xenix,
and who wrote the fullscreen dialing directory; Fred Buck, who rewrote the
script language, performed various bugfixes and alterations, and installed
special compile-time tuning for the Tandy 6000; and Jean-Pierre Radley, who
installed the B+ Protocol, used more termcap features, and is now the
X"caretaker" of XC.
X
X
X	I N S T A L L A T I O N
X
Run Configure. There are various definitions that have to be set according
to your flavor of Unix, your preference for default directories, and other
user-definable items.
X
Typing just "make" will compile XC. On most systems, XC should be run "suid
uucp", and in order to do this, you should have chosen "uucp" as the user
to own the program, and 4755 as its permissions. If so, typing "make
install.suid" willl strip out its symbol table, place the program in INSDIR,
and change its modes and permissions accordingly. If you did not elect
this when running Configure, you can type "make install", but XC's permissions
will probably not allow it to properly cope with dial-in/dial-out ports.
X
The "xc.nro" file is 'nroff' source for a manual page which describes the
command-line options, the various commands once you're running XC, script
language, file transfers, and the price of milk in Soviet Georgia in 1986.
This file MUST pass through 'tbl' and 'col', e.g.,
X	"tbl xc.nro | nroff -man | col > /usr/man/cat.L/xc.L".
X
Some distribution files that you might adapt to your own purposes:
X
X	.exrc		sets tabstops and shiftwidth to 4, which is necessary
X				to properly view almost every file in the XC distribution.
X				It also contains, commented out, macros to help read
X				CompuServe message downloads, and to prepare replies.
X
X	.xc			sample startup script, demonstrates keyboard bindings
X
X	.phonelist	sample dialing directory data file
X
X	.callhq		sample script to call a Unix/Xenix system
X
X	.uni		sample script to call CompuServe and enter UnixForum
X
X	.aus		sample script to call CompuServe and enter, in turn,
X				SCOForum and UnixForum, uploading any prepared messages,
X				capturing all new messages into separate files, and
X				hanging up.
X
X	.autocis	sample script to call CompuServe, get any waiting
X				Mail into a capture file, then visit the PRACTICE
X				and the Unix Fora in turn, uploading any prepared
X				messages, capturing all new messages into separate
X				files, then hanging up.
X
X	.cisdial	meant to be called as a sub-script for dialing
X				CompuServe.
X
X	.temp_opt	meant to be called as a sub-script for temporary
X				setting of Options in a CompuServe Forum to make
X				efficient use of .autocis, .aus, or .uni.
X
X	.pass		a subscript containing passwords for various sites.
X				This should have very restrictive permissions.
X
X	.rz			sample script to receive files using the public
X				domain "rz/sz" package.
X
X	.sz			sample script to send files using the public domain
X				"rz/sz" package.
X
X	call		a Bourne shell script to use a spare modem to dial
X				voice calls for you.
X
X	callback	a Bourne shell script to call a site and have it
X				return the call and present a 'login:' prompt.
X
X	cisdownload a Bourne shell script to fetch a file from a Library
X				in a CompuServe Forum.
X
X
X	X C  R E V I S I O N  H I S T O R Y
X
Version 4.1 Gensch & Radley 4 Apr 93
X	Added Configure script
X	Took out T6000 conditional
X	Changed 7e|7o|8n to 7e2|7o2|8n1, with CSTOPB as needed
X
Version 3.4 Radley 13 Feb 1993
X	Took out bitmask and 7bit stuff, now have 7E, 7O, or 8N capability
X	Sleep(1) after PREFIX to allow modem to react (clue from Doug Scothorne)
X	Fixed newbmask signalling to prevent leak into B+ (clue from Jim Asman)
X	Deleted for-loops in s_dial and s_term (clue Brian Ferguson)
X	Tested for CO if no CN (clue Roy Johnson)
X
Version 4.0 Radley 11 Jun 1992
X	Used ANSI Prototype function declarations
X		(this road will not be travelled further...)
X
Version 3.3 Radley 25 May 1992
X	Provided call (clue from John Esak) and cisdownload shell scripts
X	Do not fork to terminal mode if stderr is not a tty
X	Added mini-menu
X	Merged Larry Gensch's 3.2a additions into xcscript.c
X	Used Larry Gensch's NIL-pointer macro throughout
X	Make a local copy of scriptname within S_Call()
X	Renamed isig() to mode()
X	Rearranged sections of the manual
X	Restored newbmask (clue from Doug Scothorne)
X	Set ptr = word early in k_waitfor (clue from Peter Smithem)
X	B+ Packet_Size requests 2k if bps > 2400 (CIS may eventually do this)
X	Use BS=c_cc[VERASE] == user's ERASE key (clue from Peter Gutmann)
X	Used oldmode before printing help or dialdir (clue from Bill Greene)
X	SYSVR4 mods for xcport.c (Larry Rosenman)
X
Version 3.2a Larry Gensch 22 Sep 1991
X	Made hard-coded terminal mode escape character a SETable value 
X	Added dynamic keyboard binding module
X	Added bind_function, bind_script, and bind_function to script language
X	Added fullword synonyms for command line keywords (eg, quit, term)
X	Incorporated show_bindings() into help display
X	Modified help display into more readable (to me, anyway) format
X	Added show_bindings() as a terminal mode function (esc - ?)
X	Fixed command line input routine
X
Version 3.2 Radley 24 Aug 1991
X	Set terminal's c_oflag to 0 (clue from Ronald Khoo)
X	Openfile fix (Peter Smithem)
X	Undefined toupper/tolower macros
X	Removed toggle() and introduced capt_on() and capt_off()
X	Changed diversion pacing back to using waitfor()
X	Changed send_slowly to send_string; left out inter-character delay
X	Removed newbmask
X	Purge() before doing a %take (clue from Bob Stockler)
X	Reinstalled xmodem crcheck as it was in 2.5 (clue from Volker Beyer)
X	Rearranged some modules to make gcc happier
X	Renamed intdel() to isig()
X	Unscrambled the SUCCESS/FAILURE nonsense in xcscrpt.c
X	Dropped trminp() in favor of fgetc()
X	Reworked signal handling
X
Version 3.1 Radley 14 Jul 1991
X	Purge() before starting B+ (Al Bolduc)
X	Eliminated purge as a set option.
X	Send \r, not \n, after the Byeptr (Al Bolduc)
X	When diverting from a script, pace by reading modem one line at a time
X	Combined capture/captflag, and cf/cfp
X
Version 3.0b Radley 08 Jul 1991
X	Eliminated mklow/mkhigh in favor of tolower/toupper
X	Shortened inter-line delay in script transmittal
X
Version 3.0a Radley 29 Jun 1991
X	Bugs re DIDO ports logic
X	Spelling errors in xc.nro
X	Added Buck-type CIS macros to .exrc
X
Version 3.0 Radley	06 Jun 1991
X	Program name XC replace XCMALT, by Jean-Pierre Radley
X
X	Ditched nap() in favor of times()
X	Cleaned up error handling in xcscrpt.c
X	Used NULLS and NULLF where appropriate
X	Used same crc table for xmodem and B+ (Mike Barton)
X	Increased size of f[] in xcdial.c (Tom Cattrall)
X	Introduced XC_PATH (Dan Everhart)
X	Won't mistake a directory for a script (clue from Bob Stockler)
X	Added "hangup" script keyword (Dan Everhart)
X	Forced 8N1 setting on opening port (clue from John James & Russ Ranshaw)
X	Cleaned up manual page
X	Included 38400 speed
X	Deleted ioctl(TCFLSH) from s_exit() (David Kindred)
X	Fixed spurious return to dialing directory after B_Transfer (David Kindred)
X	Fixed auto toggle after dialing without a script (clue from Roger Chaplin)
X	Use carat-char for a ctrl-char in waitfor as well as in transmit
X	Added MY_ESC-Q to quit XC from terminal mode (clue from Bill Hobson)
X
X
X	X C M A L T  R E V I S I O N  H I S T O R Y
X
X
Version 2.9 Radley 02 Sep 1990
X	Fixed error messages and file opening in xcb+.c when permission denied.
X
Version 2.8 Radley 01 Sep 1990
X	Fixed interrupt handling when dialing from phonelist (clue from Jim Asman)
X	Merged xcparse.c into xcscrpt.c
X	Fixed backspace handling in getline()
X	Used getline() inside man_dial()
X	Did away with using /dev/tty
X	For cron: do not bother with TERM if !isatty()
X	Fixed page counting in dial directory routines (clue from Mike Squires)
X	Changed Msg[80] to Msg[SM_BUFF] (clue from Dave Cardinal )
X	Fixed a bad tgetstr() call (clue from Per Bilse)
X
Version 2.7 Radley 12 June 1990
X	Merge install.doc into xcmalt.h and README
X	Change xcmalt.doc to nroff source
X	Add cr_add flag to insert [or not] CRs after NLs in B+ uploads
X
Version 2.6.1 Betz, Cattrall, Roberts, Scothorne, Radley 13 May 90
X	Use separate rxbuf and kbbuf for port/keyboard input (Tom Cattrall)
X	Stretched some sleep and nap delays (Doug Scothorne)
X	Removed '/' from INSDIR definition in Makefile (Tom Betz)
X	Fixed bug in while/do/call script/done logic (clue from Tom Roberts)
X	Removed dd_done variable
X	Fixed terminal(todir) logic
X
Version 2.6 Radley 29 April 1990
X	Reinstated SCO 2.2 ungetty calls
X	Deleted crc setting, xmodem now always done with CRC
X	Added auto flag, automatically start capture on entering terminal mode
X	Used tputs() for screen control strings.
X
Version 2.5 George Pontis & Jean-Pierre Radley 19 April 1990
X	Use ioctl.h only for the T6000
X	Fixed calls to nap() for BSD
X	Fixed statbuf() declaration bug in xcport.c
X	Included mklow()/mkhigh() as frontends to tolower()/toupper()
X	Included NOSHELL option
X	Exits mopen() if no port specified
X
Version 2.4 Radley	31 Mar 1990
X	Made all identifiers unique in first seven characters.
X	Replaced incorrect references to "baud" and "baud-rate" by
X	 "bps" and "bits/second"
X
Version 2.3 Radley 19 Feb 1990
X	B-Plus replaces Quick-B
X	Reinstated xclog code
X	No mungmode variable; overwriting of a file interactively confirmed.
X	No term variable; all transfers return to Terminal mode.
X	Added timer.c, to calibrate the built-in nap() code.
X
Version 2.2	Radley	05 Jan 1990
X	Removed XCLUDE termio setting, which locked port on first fopen()
X	Change setuid to be uid of 'uucp'
X	Fixed set/get/uid routines
X	Revised menu display
X	Removed xclog code from xccisb.c
X	Changed many TCSETAW ioctl calls to TCSETA
X
Version 2.1	Radley	12 Dec 1989
X	Revised all inverse video displays
X	Took out more unnecessary routines
X	Permitted operation from 'cron' or 'at'
X	Fixed some of the interrupt routines
X	Removed PUT_TAKE manifest, code for put/take now always included
X	Fixed some of the mopen() routines.
X	Did away with DRIBBLE, use nap() instead
X
Version 2.0	Radley	9 Aug 1989
X	Added openfile routine (credit to George Pontis)
X	Added LIBDIR (credit to George Pontis)
X	Used setbuf on local tty (credit to George Pontis)
X	Eliminated fflush() calls
X	Fixed put and take code
X	Deleted SCO 2.2 ungetty stuff
X
Version 1.0 ...all in or about, oh, say, 1988.
X	CD-independent modem opening added by Fred Buck/J-P Radley
X	Broken shell-escape mechanism fixed by Fred Buck
X	Tandy 6000 LCKfile support added by Fred Buck
X	Flexible LCKfile support added by Steve Manes
X	Same, for SCO 2.2, added by J-P Radley
X	Fullscreen dialing directory added by Steve Manes
X	Fullscreen dialing directory tuned by Fred Buck/J-P Radley
X	Shell-escape ignore-SIGINT bug fixed by Fred Buck
X	Command-mode ignore-xon/xoff bug fixed by Fred Buck
X	Script parsing greatly extended by Fred Buck
X	"BYE" sequence to modem on exit added by Fred Buck
X
X	Program named XCMALT instead of XCOMM, by Fred Buck
X
X
X	X C O M M  R E V I S I O N  H I S T O R Y
X
X
Version 2.2	larry gensch	14 Dec 87	Major code restructure
X	Reduced program and command options
X	Added SET command for setting various parameters
X	Added HANGUP command for disconnecting modem
X	Modified xccisb.c code to support CIS "Quick B" Protocol
X	Added xcscrpt.c code for processing script files
X	Added SCRIPT= parameter to phonebook processing (auto-logon scripts)
X	Added CIS parameter for CIS <ENQ> auto transfers
X	Added NL parameter for newline translation
X	Added HANGUP command from terminal mode
X	Added SCRIPT command from terminal mode
X
Version 2.1b	larry gensch	11 Nov 87	Bug Fix release
X	(no bugs in the code, just some portability fixes)
X	Changed "sigset" in xccisb to "signal"
X	Removed #include <setjmp.h> from xcxmdm
X
Version 2.1a	larry gensch	28 Oct 87	General Update
X	Added CIS "B" Protocol (c, ct commands)
X	Added BAUD= & BITS= parameters to phonelist file.
X	Switched some command letters
X	Revised command line parsing to use getopt()
X
Version 2.0	larry gensch	19 Oct 87	Revisions for System V.3
X	Changed <sgtty> references to <termio> (modified ioctl(2) calls)
X	Changed terminal mode function keys to <ESC> sequences; added
X		getconchr()
X
Version 1.1	Eric E Coe	21 Jul 85
X	Autodial for Hayes-compatible modem.
X	General rearranging of the code
X
Version 1.0	Eric E Coe	12 Apr 85
X	Program created
X
X
X===================================
X
X
Note: in the original XCOMM file "install.doc", Larry Gensch gave his
various mail addresses for users to reach him about bug reports, upgrade
requests, and the like. But Larry doesn't support (or in fact have anything
to do with) XC/XCMALT, except as a contributor, and the fact that
XXCMALT is based on XCOMM 2.2, so there's no point in including this
information here. 
XFred Buck, who made the major changes from XCOMM to XCMALT, passed away in
early 1989.
Jean-Pierre Radley has since been shepherding the program as it evolved from
XXCMALT to XC.
X
Gripes, bugs, and comments accepted by:
X	Jean-Pierre Radley
X	  jpr@jpr.com
X	  72160.1341@compuserve.com
END_OF_FILE
if test 14633 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'bsdinst.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bsdinst.sh'\"
else
echo shar: Extracting \"'bsdinst.sh'\" \(1648 characters\)
sed "s/^X//" >'bsdinst.sh' <<'END_OF_FILE'
X#! /bin/sh
X#
X# This accepts bsd-style install arguments and executes them
X#
X
die()
X{
X    echo "$*" 1>&2
X    exit 1
X}
X
dest=""
src=""
strip="false"
owner=""
group=""
mode="755"
X
while [ -n "$1" ]
do
X    case $1 in 
X    -c)	;;
X
X    -m)	mode="$2"
X		shift
X		;;
X
X    -o) owner="$2"
X		shift
X		;;
X
X    -g) group="$2"
X		shift
X		;;
X
X    -s) strip="true"
X		;;
X
X    -*)	die "Illegal option"
X		;;
X
X    *)	if [ -z "$2" ]
X		then
X			dest="$1"
X			break
X		fi
X
X    	src="$src $1"
X
X    	if [ ! -f "$1" -o ! -r "$1" ]
X		then
X			die "$1: file does not exist or is not readable"
X		fi
X	;;
X    esac
X
X    shift
done
X
X[ -n "$dest" ] || die "No destination specified"
X
X[ -n "$src" ] || die "No file specified"
X
if [ ! -d "$dest" ]
then
X    count=0
X    for i in $src
X    do
X		count=`expr $count + 1`
X    done
X
X    if [ "$count" -eq 1 ]
X    then
X		parent=`dirname $dest`
X		if [ -d "$parent" ]
X		then
X			newname=`basename $dest`
X			dest=$parent
X		fi
X    fi
X
X    [ -n "$newname" ] || die "$dest: No such directory"
fi
X
X# Here's where the real work happens.  Note that on some systems, chown
X# clears SUID and SGID bits for non-superusers.  Thus, the chmod has to
X# follow chown.  However, under System V, you can not chmod SUID or SGID
X# permissions unless you are the owner or superuser.
X# If you are in doubt, "su" first!
X
for i in $src
do
X    set -e
X
X    ofile=$dest/${newname:-$i}
X
X    rm -f $ofile
X
X    cp $i $ofile
X
X    if $strip
X    then
X		strip $ofile
X		if i386
X		then
X			mcs -d $ofile
X		fi
X    fi
X
X    if [ -n "$group" ]
X    then
X		chgrp $group $ofile
X    fi
X
X    if [ -n "$owner" ]
X    then
X		chown $owner $ofile
X    fi
X
X    chmod $mode $ofile
X
X    set +e
done
X
exit 0
END_OF_FILE
if test 1648 -ne `wc -c <'bsdinst.sh'`; then
    echo shar: \"'bsdinst.sh'\" unpacked with wrong size!
fi
chmod +x 'bsdinst.sh'
# end of 'bsdinst.sh'
fi
if test -f 'call' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'call'\"
else
echo shar: Extracting \"'call'\" \(1989 characters\)
sed "s/^X//" >'call' <<'END_OF_FILE'
X: <<AH_SO
X	"call": @(#) JPRadley Mon Jun 01 20:49:48 EDT 1992 v. 0.3
X	This file uses 8-character tabstops.
X  An ecological recycling program for obsolete modems.
X  Uses 'xc' to dial on port M, giving a key ($1) to look up in file P, whose
lines have the format "one or more keys<TAB>number"
X  Thus, if P has "mom dad hometown<TAB>1-234-567-8900", this will dial that
number by typing "call mom", "call dad", "call home", "call town"; pick up
the handset within 10 seconds, talk to the folks.
X  If $1 isn't a valid key in P, then dial $1 itself, so that "call 12024561000"
will dial the White House in DC.
X  "call grklfitch" does no harm: the modem won't react to ATDTgrklfitch.
X  Unless you have version 3.3 or higher of 'xc', do NOT hit the BREAK key while
this script is running; you may be left with scads of orphaned 'xc' processes.
AH_SO
X
X[ $# -lt 1 ] && exit    # one argument, key or number, needed
M=ttyA07                # voice line with a modem on it
P=/pub/jpr/lib/numbers  # data file
X                        # next line: <TAB> between '*' and '/'
N=`sed -n "/$1/{s/.*$1.*	//p
q
X}" $P`
N=${N:-$1}              # if $1 wasn't a key, use $1 itself
S=/usr/tmp/call_$$      # temporary script for xc to use
X
trap "rm $S" 0          # clean up
X
cat >$S <<JPR
set bps 300             # override whatever the .xc startup file sets
set cfile "/dev/tty"    # set up a hack for screen display, since later we
capture "on"            #  redirect the usual xc output to the bit bucket
file echo "dialing $N"  # spring the hack
dial "W$N"              # precede by a 'w' to wait for dial tone
pause 10                # give a human a chance to pick up the handset
X#hangup                 # dropping DTR may not work on old modems
transmit "ath^m"        #   so use this instead
pause 1                 # it's an old modem, give it a chance to react
quit                    # xc quits and the modem is off the voice line
JPR
X
xc -l$M -s$S 2>/dev/null     # shut off normal xc screen output
END_OF_FILE
if test 1989 -ne `wc -c <'call'`; then
    echo shar: \"'call'\" unpacked with wrong size!
fi
chmod +x 'call'
# end of 'call'
fi
if test -f 'callback' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'callback'\"
else
echo shar: Extracting \"'callback'\" \(3377 characters\)
sed "s/^X//" >'callback' <<'END_OF_FILE'
X#!/bin/sh
X# @(#) callback - JPRadley v1.0 920921 - makes and uses an 'xc' script to
X# @(#)   call a remote site, have it ring us back with a login prompt.
X
echo -n "Remote system name? "
read SYSTEM                     # where are we calling?
echo -n "Their modem number? "
read NUMBER                     # what's the telephone number?
echo -n "Login name on $SYSTEM? "
read LOGIN                      # how shall we log in?
echo -n "Password for $LOGIN? "
stty -echo                      # but of course!
read PASSWD
stty echo
echo -n "\nBaud remote should use? "
read RSPEED                     # computer-modem speed on the remote
echo
X
What_To_Do=/usr/tmp/$SYSTEM.$$  # script for 'xc' to use
OURPORT=ttyA02                  # we'll dial out on this port and the remote
OURNBR=7874639                  #  calls this number to ring this port
CAPTURE=/pub/jpr/logs/$SYSTEM   # our log file for the session
X
trap "rm $What_To_Do" 0         # clean up when we leave
X
cat >$What_To_Do <<TeMpLaTe
debug "off"
tty "off"
set cfile $CAPTURE                
set auto "off"                  # no capturing -- yet
set cis "off"                   # don't react to a spurious ^E
X
transmit "ats0=0e1q0v1^M"       # modem should not be mute
waitfor "ok"
X
dial "$NUMBER"
echo "        Dialing $NUMBER to get on to $SYSTEM"
while ! waitfor "connect" 70
do
X        echo "        No connection; redialing"
X        redial                        
done
X
transmit "^M"                   # can't hurt
X
assign PATIENCE eq 3            # loop counter
while ! waitfor "ogin:" 6       # waiting 6 secs for the prompt
do
X        if PATIENCE eq 0
X        then    echo "Can't get a login prompt"
X                beep; quit
X        fi
X        xmitbrk
X        decr PATIENCE
done
X
pause 2
X
transmit "$LOGIN^M"
echo "        We're logging in now"
X
if ! waitfor "word:"
then
X        echo "Login failed, sorry!" ; beep; quit
else
X        transmit "$PASSWD^M^M"  # the second CR is to cope with a possible
endif                           #  tset command, and accept its default
X
transmit "/1/2/3^M"             # an absolute pathname that shouldn't exist
if waitfor "not found"
then
X        echo "        OK, we're on $SYSTEM; now we'll set up a callback"
else
X        echo "Login failed, sorry!" ; beep; quit
fi
X
transmit "echo 'yes|ct -w3 -s$RSPEED $OURNBR 2>/dev/null' | at now next min^M"
waitfor "job"                   # the 'at' command reports a job number
transmit "exit^M"               # get off the remote system
X
pause 2                         # disconnect might reset modem, so again:
transmit "ats0=1e1q0v1^M"       #  not mute, and auto-answer
waitfor "ok"
X
echo "        It might be a couple of minutes until $SYSTEM rings us"
if ! waitfor "connect" 190
then
X        echo "        It ain't gonna happen; sorry!"
X        beep; quit
endif
X
transmit "^M"
assign PATIENCE eq 3
while ! waitfor "ogin:" 6
do
X        if PATIENCE eq 0; then beep; quit; fi
X        xmitbrk; decr PATIENCE
done
pause 1; transmit "$LOGIN^M"
if ! waitfor "word:"; then beep; quit
else transmit "$PASSWD^M^M"
fi
X
set auto "on"                   # capturing starts when we hit terminal mode
X
transmit "/1/2/3; echo Thanks, \`uname\`, for providing this connection!^M"
waitfor "not found"
beep
TeMpLaTe
X
xc -s$What_To_Do -l$OURPORT
X
X# th-th-aaa-t's all, folks, just drop those nickels & dimes in the slot...
X
X# eof(callback)
END_OF_FILE
if test 3377 -ne `wc -c <'callback'`; then
    echo shar: \"'callback'\" unpacked with wrong size!
fi
chmod +x 'callback'
# end of 'callback'
fi
if test -f 'cisdownload' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cisdownload'\"
else
echo shar: Extracting \"'cisdownload'\" \(1688 characters\)
sed "s/^X//" >'cisdownload' <<'END_OF_FILE'
X: << README
This file uses 8-character tabstops.
cisdownload @(#)Download CIS LIB file with XC   JPRadley 20 May 92 vers 0.1
Assumes System-wide preference for B+ set in GO PROFILE.
Assumes Prompt character in all Fora is ^H.
X
Could use more checks. Providing a non-existent Forum, or one which one
has not joined; providing an incorrect or inaccessible LIB number;
providing a non-existent filename: all of these will cause failure
while the meter's ticking.
But if "all systems are go", then this should save a few pennies.
README
X
echo "\n\tDownload a file from CompuServe using XC"
echo "\n\tDefault answers are in brackets"
X
echo "\nWhat Forum [unixforum] ? \c"
read GO
XFORUM=`echo ${GO:=UnixForum} | tr '[A-Z]' '[a-z]'`
X
echo -n "\nWhat Library [1] ? \c"
read RARY
LIB="LIB "${RARY:=1}
X
until test "$THERE"
do
X	echo "\nName (case-insensitive) of the file on CIS? \c"
X	read THERE
done
X
WHERE="[$THERE] "
while :
do
echo -n "\nPathname (case-sensitive) to use here $WHERE? "
X	read AND
X	HERE=${AND:-$THERE}
X	if test -f "$HERE" || test -d "$HERE"
X	then
X		echo "\n'$HERE' already exists. You may BREAK from this"
X		echo "script and either remove or rename '$HERE',"
X		echo "or choose another name instead.\n"
X		WHERE=''
X	else
X		break
X	fi
done
X
S=/usr/tmp/Download$$	# not publicly readable, to protect CIS password
trap 'rm $S' 0 2 3
X
cat >$S <<sCrIpT
set cis "on"
X
call ".cisdial"
X
pause 3; transmit "^C"
assign SERVICE eq "$FORUM"
call ".pass"
tty "on"
X
waitfor "moment please..."
if ! waitfor "forum !^H" 60; then transmit "bye^M"; quit; endif
X
transmit "$LIB^M"
waitfor "$LIB !^H"
transmit "DOW $THERE^M"
transmit "$HERE^M"
X
waitfor "$LIB !^H"
transmit "off^M"
X
quit
sCrIpT
X
xc -s$S
END_OF_FILE
if test 1688 -ne `wc -c <'cisdownload'`; then
    echo shar: \"'cisdownload'\" unpacked with wrong size!
fi
chmod +x 'cisdownload'
# end of 'cisdownload'
fi
if test -f 'myman' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'myman'\"
else
echo shar: Extracting \"'myman'\" \(2569 characters\)
sed "s/^X//" >'myman' <<'END_OF_FILE'
X'''\"	JPRadley 'myman' macros June 1989
X.dsx1 XENIX/UNIX
X..
X.de}E
X.ft1
X.in\\n()Ru+\\n(INu
X.ll\\n(LLu
X.lt\\n(LLu
X.pl\\n()Lu
X..
X.deDT
X..
X.de}H
X.ev1
X'  .lt7.5i
X.}E
X.ie@@\\*(]L@ .tl @\\*(]H@\\*(]D@\\*(]W@
X.el.tl @\\*(]H@\\*(]D \|\\*(]L@\\*(]W@
X.sp
X.ev
X.ns
X..
X.deTH
X.nrIN \\n()Mu
X.ds]H \\$1(\\$2)
X.ds]D \*(x1
X.ds]L
X.if!@\\$3@@ .ds ]L (\^\\$3\^)
X.if!@\\$4@@ .ds ]D \\$4
X.}H
X.nr)I \\n()Mu
X.nr)R 0
X.}E
X.na
X.hy14
X..
X.deSH
X.}X 0 "\\$1" smaller
X.nr)E 2
X\&\\$1 \|\\$2 \|\\$3 \|\\$4 \|\\$5 \|\\$6
X..
X.deSS
X.}X3n "" ""
X.nr)E 2
X\&\\$1 \|\\$2 \|\\$3 \|\\$4 \|\\$5 \|\\$6
X..
X.de}X
X.}E
X.ti\\$1
X.sp
X.nr)R 0
X.fi
X.it1 }N
X.if!@\\$3@@ .SM
X..
X.de}2
X.nr)E 0
X.}E
X.nr)I \\n()Mu
X.ns
X..
X.deSM
X.if!@\\$1@@ \&\\$1
X.if!@\\$2@@ \&\\$2
X.if!@\\$3@@ \&\\$3
X.if!@\\$4@@ \&\\$4
X.if!@\\$5@@ \&\\$5
X.if!@\\$6@@ \&\\$6
X.if@\\$1@@ .it 1 }N
X..
X.deI
X.ft2
X.it1 }N
X.if!@\\$1@@ \&\\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
X..
X.deB
X.ft3
X.it1 }N
X.if!@\\$1@@ \&\\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
X..
X.deRI
X.}S1 2 \& "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7" "\\$8" "\\$9"
X..
X.deIR
X.}S2 1 \& "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7" "\\$8" "\\$9"
X..
X.deIB
X.}S2 3 \& "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7" "\\$8" "\\$9"
X..
X.deRB
X.}S1 3 \& "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7" "\\$8" "\\$9"
X..
X.deBR
X.}S3 1 \& "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7" "\\$8" "\\$9"
X..
X.deBI
X.}S3 2 \& "\\$1" "\\$2" "\\$3" "\\$4" "\\$5" "\\$6" "\\$7" "\\$8" "\\$9"
X..
X.de}S
X.ds]F
X.if@\\$1@2@ .if !@\\$5@@ .ds ]F\^
X.ie!@\\$4@@ .}S \\$2 \\$1 "\\$3\f\\$1\\$4\\*(]F" "\\$5" "\\$6" "\\$7" "\\$8" "\\$9"
X.el\\$3
X.ft1
X..
X.dePP
X.sp
X.}E
X.nr)I \\n()Mu
X.ns
X..
X.deP
X.PP
X..
X.deLP
X.PP
X..
X.deHP
X.sp
X.if!@\\$1@@ .nr )I \\$1n
X.ll\\n(LLu
X.in\\n()Ru+\\n(INu+\\n()Iu
X.ti\\n()Ru+\\n(INu
X.ft1
X..
X.deIP
X.TP \\$2
X\&\\$1
X..
X.deTP
X.if!@\\$1@@ .nr )I \\$1n
X.sp
X.in\\n()Ru
X.ns
X.it1 }N
X.nr)E 1
X.di]B
X..
X.de}1
X.ds]X \&\\*(]B\\
X.rm]B
X.nr)E 0
X.if!@\\$1@@ .nr )I \\$1n
X.ft1
X.ll\\n(LLu
X.in\\n()Ru+\\n(INu+\\n()Iu
X.ti\\n(INu
X.ie!\\n()Iu+\\n()Ru-\w@\\*(]X@u-3p \{\\*(]X
X.br\}
X.el\\*(]X\h@|\\n()Iu+\\n()Ru@\c
X.ft1
X..
X.de}N
X.if\\n()E .br
X.di
X.if@\\n()E@0@ .ft1
X.if@\\n()E@1@ .}1
X.if@\\n()E@2@ .}2
X..
X.deRS
X.nr]\\n+()p \\n()I
X.nr)\\n()p \\n()R
X.ie!@\\$1@@ .nr )R +\\$1n
X.el.nr )R +\\n()I
X.nr)I \\n()Mu
X.}E
X..
X.deRE
X.if!@\\$1@@ \{.ie @\\$1@0@ .nr )p 1 1
X.el.nr )p \\$1 1 \}
X.ds]i \\*(]I\\n()p
X.ds]r \\*(]R\\n()p
X.nr)I \\*(]i
X.nr)R \\*(]r
X.if\\n()p .nr )p -1
X.}E
X..
X.dePM
X..
X.nr )L 0
X.nrLL 7.9i
X.dsR (Reg.)
X.nr)p 0 1
X.ds]I \\\\n(]
X.ds]R \\\\n()
X.ds ]W (printed \n(mo/\n(dy/\n(yr)
X.pl\n()Lu
X.ll\n(LLu
X.lt\n(LLu
X.ft1
X.nr )M 8n
END_OF_FILE
if test 2569 -ne `wc -c <'myman'`; then
    echo shar: \"'myman'\" unpacked with wrong size!
fi
# end of 'myman'
fi
if test -f 'xc.h.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xc.h.in'\"
else
echo shar: Extracting \"'xc.h.in'\" \(7656 characters\)
sed "s/^X//" >'xc.h.in' <<'END_OF_FILE'
X/*	xc.h -- header  file for XC
X	This file was generated by configure on {{DATE}} by {{USER}}
X	This file uses 4-character tabstops
X*/
X
X/* Local preferences and modems */
X
X/*	CAPTFILE
X	This is the default name given to the capture buffer in terminal mode (and
X	during script processing). You can always reset this while running the
X	program.
X*/
X#define	CAPTFILE "capture.log"	/* Default capture file */
X
X/*	LIBDIR
X	This is the default name given to a directory where PHFILE, STARTUP, and
X	any XC scripts might be found. XC will search for such files
X		1st) in a path in a colon-separated list of directories in
X			 XC_PATH, if such an environment variable exists,
X		2nd) in the current directory,
X		3rd) in your HOME directory, if HOME is an environment variable,
X		4th) in LIBDIR.
X*/
X#define LIBDIR "{{LIBDIR}}"
X
X/*	PHFILE
X	This is the default name given to the dialing directory.
X*/
X#define PHFILE ".phonelist"		/* Default phonelist file */
X
X/*	STARTUP
X	This is the default name of the startup script for XC. If this file is
X	found it will be executed immediately on XC startup.
X*/
X#define STARTUP ".xc"			/* XC Startup Script */
X
X/*	DIALSTR
X	A format string to send a telephone number to the modem with the
X	appropriate dialing command.
X*/
X#define DIALSTR "ATDT %s\r"	/* printf format for modem dial command */
X/*#define DIALSTR "AAATDT%s\r"	/* printf format for older Telebits */
X
X/* DTR_DROPS_CARRIER
X	On some (most?) modems, dropping the DTR signal will instruct the modem
X	to disconnect the phone line. On most (some?) Unix systems, setting a
X	bit/second rate of 0 will drop carrier.
X
X	If either of these conditions do NOT apply to your setup, set this value to
X	0 and an alternate hangup function will be used. This alternate function
X	sends the modem the ATTEN string, waits a few seconds, and then sends the
X	HANGUP string, so check if those are correct for your modem.
X*/
X#define	DTR_DROPS_CARRIER	{{DTR_DROPS_CARRIER}}
X#if !DTR_DROPS_CARRIER		/* If not, then we need the next two defines */
X# define ATTEN "+++"		/* Modem "attention" signal */
X# define HANGUP "ATH\r"		/* Modem "hang up" command */
X#endif
X
X/* DEBUG
X	If this manifest is set to 1, then whenever XC is run within a
X	directory that contains a file called "debug.log", XC will append to
X	that file a copy of all XC output, whether to the terminal "file" or
X	to standard error. This can be useful for debugging scripts, coupled
X	with the "debug" script command, which causes the lines of a script
X	to be echoed to the terminal as they get executed. Since often such
X	output passes up the terminal screen too quickly to read, the
X	"debug.log" file provides a hard-copy of the XC session.
X	No echoing to a "debug.log" file is done if XC is also capturing
X	incoming text to a capture file. If no "debug.log" file exists in the
X	current directory, then no such echoing is done regardless of whether
X	the DEBUG is here defined as 0 or 1.
X*/
X#define DEBUG	{{DEBUG}}
X#if DEBUG && !NODEBUG
X# define fprintf Fprintf
X# define fputc Fputc
X# define fputs Fputs
X#endif
X
X/* NOSHELL
X	Set this to 1 to disallow shell escapes. Both the "!" and "$" mechanisms
X	from the XC prompt, and the analogous SHELL and PIPE keywords in scripts,
X	silently do nothing. However the standard output of backquoted shell
X	commands can still be assigned to a script variable.
X*/
X#define NOSHELL	{{NOSHELL}}
X
X/* For XC, the following definitions are significant:
X	DIDO=0
X		This will not include any of the LCK..file code respected by cu/uucp.
X
X	DIDO=2
X	DIDO=3
X	DIDO=4
X		For a Dial-In/Dial-Out port.
X
X		2 is for SCO Xenix 2.2 which uses ungetty.
X		3 is for SCO Xenix 2.3 whose getty is effectively a uugetty,
X		  for SCO Unix, or for other sites using uugetty.
X		4 is for Unix Sys V Release 4
X*/
X#define DIDO	{{DIDO}}
X
X/* Local Unix peculiarities */
X
X/*	STRCHR and STRRCHR vs. INDEX and RINDEX
X	Some Berkely and Xenix systems have index() and rindex() which are
X	functionally identical to the more standard strchr() and strrchr()
X	functions. These two defines should be 0 if your Unix uses index and
X	rindex instead of strchr and strrchr.
X*/
X#define	HAVE_STRCHR		{{HAVE_STRCHR}}
X#define	HAVE_STRRCHR	{{HAVE_STRCHR}}
X#if !HAVE_STRCHR
X# define	strchr	index
X#endif
X#if !HAVE_STRRCHR
X# define	strrchr	rindex
X#endif
X
X/*	DUP2
X	dup2() is not included with all versions of Unix. If your implementation
X	does not have dup2() (or if you are just not sure), define this as 0 and a
X	functional equivalent will be included in the source code.
X*/
X#define	DUP2	{{HAVE_DUP2}}
X
X/*	STRSTR
X	The draft Ansi C standard specifies the "strstr" function to return the
X	position of a substring within a string. This is NOT included in many Unix
X	systems, so code for this function is included unless you define this as 1.
X*/
X#define	STRSTR	{{HAVE_STRSTR}}
X#if !STRSTR
X extern char *strstr();
X#endif
X
X/*	MEMSET
X	This function is not on earlier implementations of Unix. Define this as 0
X	if you don't have it; making it 1 will not include our equivalent code.
X*/
X#define MEMSET	{{HAVE_MEMSET}}
X
X/*	STRDUP
X	Again, a function not present on earlier versions of Unix, and again,
X	defining this as 0 will thereby include our functional equivalent.
X*/
X#define STRDUP	{{HAVE_STRDUP}}
X#if !STRDUP
X extern char *strdup();
X#endif
X
X/* If you don't have these typedefs in your /usr/include/sys/types.h, then
X   the following should be 0.
X*/
X#define	HAVE_USHORT	{{HAVE_USHORT}}
X#define	HAVE_UNCHAR	{{HAVE_UNCHAR}}
X#define	HAVE_ULONG	{{HAVE_ULONG}}
X#define	HAVE_PID_T	{{HAVE_PID_T}}
X
X#if !HAVE_USHORT
X typedef unsigned short ushort;
X#endif
X#if !HAVE_UNCHAR
X typedef unsigned char unchar;
X#endif
X#if !HAVE_ULONG
X typedef unsigned long ulong;
X#endif
X#if !HAVE_PID_T
X typedef short pid_t;
X#endif
X
X
X/* The reader is kindly invited to leave the rest of this just as it is! */
X
X#define SOH		0x1		/* ^A */
X#define ETX		0x3		/* ^C */
X#define EOT		0x4		/* ^D */
X#define ENQ		0x5		/* ^E */
X#define ACK		0x6		/* ^F */
X#define DLE		0x10	/* ^P */
X#define XON		0x11	/* ^Q */
X#define XOFF	0x13	/* ^S */
X#define NAK	 	0x15	/* ^U */
X#define CAN		0x18	/* ^X */
X
X#ifndef TRUE
X# define TRUE	1
X# define FALSE	0
X#endif
X#define SUCCESS	1
X#define FAILURE	0
X
X#define NEWMODE	0
X#define SIGMODE	1
X#define OLDMODE	2
X
X#ifdef toupper
X# undef toupper
X# undef tolower
X#endif
X
X#define SM_BUFF	 256
X#define LG_BUFF 2048
X#define S		show(1,Msg)
X#define S0(x)	show(0,x)
X#define S1(x)	show(1,x)
X#define S2(x)	show(2,x)
X
X/*	I prefer this NIL macro to present a NIL pointer than most other
X	variations that I have seen (eg, NULL, 0, or (cast) 0.
X	Comme ci, comme ca. - larry gensch
X*/
X#ifndef NIL
X# define	NIL(type)	(type *) 0
X#endif
X
X/* globals in three or more files */
X
extern int		CO, LI, my_escape, beep(), hangup(), show_bindings(), cbaud;
extern short	capture, cismode, flowflag, linkflag, reterm;
extern char		captfile[], ddsname[], phonefile[], *mport(), word[],
X				*wptr, line[], Msg[], *lptr, Name[], *getenv(), *unctrl(),
X				protocol[];
extern unsigned	mrate(), sleep();
extern unchar	BS, LK;
extern ushort	getuid(), getgid(), geteuid(), getegid();
extern void		cls(), cur_on(), cur_off(), default_bindings(), do_script(),
X				drawline(), exit(), free(), getline(), getword(), mode(),
X				lc_word(), msecs(), purge(), send_mbyte(), send_string(),
X				sendbyte(), show(), show_abort(), ttgoto(), xc_setflow();
extern FILE		*tfp,			/* the local terminal */
X				*openfile(), *QueryCreate();
extern struct	termio oldmode, newmode, sigmode;
X
typedef enum {
X    ENDCHAR = 128,		/* Higher than any valid keyboard code */
X    CAPTYES,
X    CAPTEND,
X    DIVCHAR,
X    DIALCHR,
X    HUPCHAR,
X    SCRPCHR,
X    BRKCHAR,
X    HLPCHAR,
X    QUITCHR,
X    EMITSTR,
X    DOSCRPT,
X    BADFUNC = 0
X} bindfunc_t;
END_OF_FILE
if test 7656 -ne `wc -c <'xc.h.in'`; then
    echo shar: \"'xc.h.in'\" unpacked with wrong size!
fi
# end of 'xc.h.in'
fi
if test -f 'xcdbglog.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xcdbglog.c'\"
else
echo shar: Extracting \"'xcdbglog.c'\" \(907 characters\)
sed "s/^X//" >'xcdbglog.c' <<'END_OF_FILE'
X/*	xcdbglog.c -- debug logging module for XC
X	This file uses 4-character tabstops
X*/
X
X#include <stdio.h>
X#include <time.h>
X#include <sys/types.h>
X#define NODEBUG 1	/* prevents xc.h from defining DEBUG */
X#include "xc.h"
X
X#if DEBUG
static FILE *dfp;
X
void
dbglog()
X{
X	long todnow;
X
X	time(&todnow);
X	if (!access("debug.log",0) && (dfp=fopen("debug.log","w")))
X		setbuf(dfp, NIL(char)),
X		fprintf(dfp,(char*)asctime(localtime(&todnow)));
X	return;
X}
X
XFputc(c, stream)
register c;
XFILE *stream;
X{
X	if (!capture && dfp && c != '\r')
X		fputc(c,dfp);
X	return(fputc(c,stream));
X}
X
XFputs(s, stream)
register char *s;
XFILE *stream;
X{
X	if (!capture && dfp)
X		fputs(s,dfp);
X	return(fputs(s,stream));
X}
X
XFprintf(stream, format, a, b, c, d, e, f, g)
XFILE *stream;
char *format;
long a, b, c, d, e, f, g;
X{
X	if (!capture && dfp)
X		fprintf(dfp,format,a,b,c,d,e,f,g);
X	return(fprintf(stream,format,a,b,c,d,e,f,g));
X}
X
X#endif
END_OF_FILE
if test 907 -ne `wc -c <'xcdbglog.c'`; then
    echo shar: \"'xcdbglog.c'\" unpacked with wrong size!
fi
# end of 'xcdbglog.c'
fi
if test -f 'xcdial.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xcdial.c'\"
else
echo shar: Extracting \"'xcdial.c'\" \(6654 characters\)
sed "s/^X//" >'xcdial.c' <<'END_OF_FILE'
X/*	xcdial.c -- dialing directory module for XC
X	This file uses 4-character tabstops
X	Author: Steve Manes 8/26/88
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <termio.h>
X#include <fcntl.h>
X#include "xc.h"
X
X#define NAME	25	/* display for system name */
X#define NUMBER	22	/*	  "		"  phone number */
X#define BPS	 	 5	/*	  "		"  speed */
X#define PROTO	 3	/*	  "		"  protocol */
X#define SCRIPT	14	/*	  "		"  script name */
X
static FILE *dirf;
static long pages[57];	/* offsets into phonefile */
static short dirnum, thispage, lastpage;
static char *last_nbr = NIL(char);
static char format[46];
extern short s_flag;
extern void cl_end(), newbmask();
X
struct {
X	char *speed;
X} speed[] = {
X	"300",
X	"600",
X	"1200",
X	"2400",
X	"4800",
X	"9600",
X#ifdef B19200
X	"19200",
X#endif
X#ifdef B38400
X	"38400",
X	"57600",
X#endif
X	NIL(char)
X};
X
struct {
X	char *proto;
X} proto[] = {
X	"8N1",
X	"7E2",
X	"7O2",
X	NIL(char)
X};
X
X/*	show a single, formatted dialdir entry.
X	check its format integrity as we go
X*/
static void 
showentry(choice, entry)
short choice;
char *entry;
X{
X	char name[NAME +1], num[NUMBER +1],
X		bps[BPS +1], prot[PROTO+1], script[SCRIPT +1];
X	char *s;
X	int i, j;
X
X	s = entry;
X
X	/* get phone number */
X	while (isspace(*s))
X		s++;
X
X	for (i=0; i < NUMBER && !isspace(*s); i++, s++)
X		num[i] = *s;
X	num[i]='\0';
X
X	/* get name */
X	while (!isspace(*s))
X		s++;
X	while (isspace(*s))
X		s++;
X	for (i=0; i < NAME && *s != '\t' && *s != '\n'; i++, s++)
X		name[i] = *s;
X	name[i] = '\0';
X
X	/* get bps */
X	memset(bps,0,BPS+1);
X	if (s = strstr(entry, "BPS=")){
X		s += 4;
X		for (i=0; i < BPS && isdigit(*s); i++, s++)
X			bps[i] = *s;
X		for (i = 0, j = 0 ; speed[i].speed ; i++)
X				if (!strcmp(bps,speed[i].speed))
X					j++;
X		if (!j){
X			beep();
X			sprintf(Msg,"Invalid BPS= for '%s'",name);
X			S;
X			return;
X		}
X	}
X
X	memset(prot,0,PROTO+1);
X	if (s = strstr(entry, "PROTO=")){
X		s += 6;
X		for (i=0; i < PROTO && isalnum(*s); i++, s++)
X			prot[i] = *s;
X		prot[i]='\0';
X		uc_word(prot);
X		for (i=0, j=0; proto[i].proto; i++)
X			if (!strcmp(prot,proto[i].proto))
X				j++;
X		if (!j){
X			beep();
X			sprintf(Msg,"Invalid PROT= for '%s'",name);
X			S;
X			return;
X		}
X	}
X
X	memset(script,0, SCRIPT+1);
X	if (s = strstr(entry, "SCRIPT=")){
X		s += 7;
X		for (i=0; i < SCRIPT && !isspace(*s); i++, s++)
X			script[i] = *s;
X	}
X	fprintf(tfp, format, choice, name, num, script, bps, prot);
X}
X
X/* scroll directory at current filepos */
static void
scroll_dir()
X{
X	short i;
X	char buf[120];
X
X	mode(OLDMODE);
X	ttgoto(4, 0);
X	cur_off();
X	cl_end();
X
X	fseek(dirf, pages[thispage], 0),
X	dirnum = thispage * (LI - 6);
X	for (i=0; i < LI - 6; i++){
X		if (!fgets(buf, 120, dirf)){
X			lastpage = thispage;
X			break;
X		}
X		showentry(++dirnum, buf);
X	}
X
X	pages[thispage + 1] = ftell(dirf);
X	if (!fgets(buf, 120, dirf))
X		lastpage = thispage;
X	cur_on();
X	mode(NEWMODE);
X}
X
X/* Dial a phone number, using proper format and delay. */
void
xcdial(s)
char *s;
X{
X	char buffer[SM_BUFF];
X
X	if (last_nbr)
X		free(last_nbr);
X
X	last_nbr = strdup(s);
X
X	sprintf(buffer, DIALSTR, s);
X	send_string(buffer);
X}
X
static
parse_entry(buf)
char *buf;
X{
X	int i;
X	char *s, *t, *nbr, bps[BPS+1], prot[PROTO+1];
X
X	if (s = strchr(buf,'\n'))
X		*s = '\0';
X
X	if (s = strstr(buf, "BPS=")){
X		s += 4;
X		for (i=0; i < BPS && isdigit(*s); i++, s++)
X			bps[i] = *s;
X		bps[i]='\0';
X		if (!mrate(bps)){
X			S0("Invalid BPS=");
X			return FAILURE;
X		}
X	}
X
X	if (s = strstr(buf, "PROTO=")){
X		s += 6;
X		for (i=0; i < PROTO && isalnum(*s); i++, s++)
X			prot[i] = *s;
X		prot[i]='\0';
X		uc_word(prot);
X		if (!xc_setproto(prot)){
X			S0("Invalid PROTO=");
X			return FAILURE;
X		}
X	}
X
X	cls();
X	sprintf(Msg,"Calling %s",buf);
X	S;
X
X	if (s = strstr(buf, "PREFIX="))
X		s += 7,
X		send_string("\r"),
X		send_string(s),
X		send_string("\r"),
X		s -= 7,
X		*s = '\0',
X		sleep(1);
X
X	while (isspace(*buf) && *buf)
X		buf++;
X
X	if (!(*buf))
X		return FAILURE;
X
X	for (nbr = buf; !isspace(*buf) && *buf; buf++)
X		;
X
X	*buf = '\0';
X	xcdial(nbr);
X
X	if (s = strstr(++buf, "SCRIPT=")){
X		s += 7;
X		t = s;
X		while (*t && !isspace(*t))
X			t++;
X		*t = '\0';
X		sprintf(ddsname,"%s",s);
X		s_flag = linkflag = TRUE;
X	}
X	return SUCCESS;
X}
X
static
dial_entry(choice)
short choice;
X{
X	char buf[120];
X
X	if (!choice)
X		return FAILURE;
X	rewind(dirf);
X	while (choice--){
X		if (!fgets(buf, 120, dirf)){
X			S0("Nonexistent entry");
X			return FAILURE;
X		}
X	}
X	return (parse_entry(buf));
X}
X
static
man_dial()
X{
X	ttgoto(LI-1, 0);
X	cl_end();
X	fputs("Number to dial: ",tfp);
X	getline();
X	if (!line[0])
X		return FAILURE;
X	return (parse_entry(line));
X}
X
dial_dir()
X{
X	int i, c;
X	char buf[5];
X
X	if (!(dirf = openfile(phonefile))){
X		sprintf(Msg,"Phonelist '%s' not found",phonefile);
X		S;
X		return FAILURE;
X	}
X
X	dirnum = thispage = 0;
X	lastpage = -1;
X	cls();
X	drawline(0, 0, CO);
X	ttgoto(1,(CO-strlen(phonefile))/2 -1);
X	show(-1,phonefile);
X	drawline(2, 0, CO);
X	ttgoto(3, 0);
X	sprintf(format,"     %%-%ds %%%ds %%-%ds %%%ds %%%ds%*s\n\r",
X		NAME, NUMBER, SCRIPT, BPS, PROTO,
X		CO-NAME-NUMBER-BPS-PROTO-SCRIPT-7, "");
X	sprintf(Msg, format, "NAME", "NUMBER", "SCRIPT", "BPS", "PRO");
X	show(-1,Msg);
X	sprintf(format,"%%3d - %%-%ds %%%ds %%-%ds %%%ds %%%ds\n\r",
X		NAME, NUMBER, SCRIPT, BPS, PROTO);
X	scroll_dir();
X	for (;;){
X		ttgoto(LI-1, 0);
X		fputs(
X		"==>     [#] Dial Entry   [M]anual Dial   [X]it   [N]ext   [P]revious",			tfp);
X		ttgoto(LI-1, 4);
X		while (1){
X			c = toupper(fgetc(stdin));
X			if (c == BS)
X				continue;
X			if (c == 'N' || c == '\n' || c == ' '){
X				if (thispage > (int)((1000/(LI-6))-1) || thispage == lastpage)
X					S0("Last page");
X				else
X					thispage++,
X					scroll_dir();
X				break;
X			}
X			else if (c == 'P' && dirnum > 1){
X				if (!thispage)
X					S0("First page");
X				else
X					thispage--,
X					scroll_dir();
X				break;
X			}
X			else if (c == 'X'){
X				cls();
X				fclose(dirf);
X				return FAILURE;
X			}
X			else if (c == 'M'){
X				if (man_dial()){
X					fclose(dirf);
X					reterm = TRUE;
X					return SUCCESS;
X				}
X				reterm = FALSE;
X				break;
X			}
X			else if (isdigit(c)){
X				buf[0] = c;
X				fputc(c,tfp);
X				for (i=1; i<4; ++i){
X					buf[i] = getchar();
X					if (buf[i]==BS){
X						if (i>0)
X							fputs("\b \b",tfp),
X							i -= 2;
X						else
X							i = -1;
X						continue;
X					}
X					fputc(buf[i],tfp);
X					if (buf[i]=='\n' || buf[i]=='\r')
X						break;
X				}
X				if (!i){
X					reterm = FALSE;
X					break;
X				}
X				buf[++i] = '\0';
X				if (dial_entry(atoi(buf))){
X					fclose(dirf);
X					reterm = TRUE;
X					return SUCCESS;
X				}
X				reterm = FALSE;
X				break;
X			}
X		}
X	}
X}
X
redial()
X{
X	char *s;
X
X	if (!last_nbr){
X		S1("REDIAL FAILURE");
X		return -1;
X	}
X
X	s = strdup(last_nbr);
X	xcdial(s);
X	free(s);
X	return SUCCESS;
X}
END_OF_FILE
if test 6654 -ne `wc -c <'xcdial.c'`; then
    echo shar: \"'xcdial.c'\" unpacked with wrong size!
fi
# end of 'xcdial.c'
fi
if test -f 'xcsubs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xcsubs.c'\"
else
echo shar: Extracting \"'xcsubs.c'\" \(7179 characters\)
sed "s/^X//" >'xcsubs.c' <<'END_OF_FILE'
X/*	xcsubs.c -- subroutines for XC
X	This file uses 4-character tabstops
X*/
X
X#include <stdio.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/times.h>
X#include <sys/param.h>
X#include <sys/stat.h>
X#include <ctype.h>
X#include <signal.h>
X#include <termio.h>
X#ifdef T6000
X#include <sys/ioctl.h>
X#endif
X#include <setjmp.h>
X#include "xc.h"
X
extern jmp_buf erret;
X
char line[SM_BUFF],	/* Input line */
X	 word[SM_BUFF],	/* Parsed word */
X	 *wptr, *lptr,	/* Word and line pointers */
X	 *tgetstr(), *tgoto();
int	LI,	/* One less than screen length in termcap entry */
X	CO;	/* Screen width */
short ospeed;
static char tc[LG_BUFF],	/* termcap buffer */
X			tbuf[LG_BUFF], PC, *CD, *CE, *CF, *CL, *CM, *CN, *SO, *SE;
X
void show();
X
X#define Tgetstr(code) ((s = tgetstr(code,&p)) ? s : "")
X
X#if	!STRSTR		/* For those that do not have strstr() */
X/*	Find first occurence of str2 in str1 and return a pointer to it */
char *
strstr(str1, str2)
char *str1, *str2;
X{
X	register char *Sptr, *Tptr;
X	int len = strlen(str1) -strlen(str2) + 1;
X
X	if (*str2)
X		for (; len > 0; len--, str1++){
X			if (*str1 != *str2)
X				continue;
X
X			for (Sptr = str1, Tptr = str2; *Tptr != '\0'; Sptr++, Tptr++)
X				if (*Sptr != *Tptr)
X					break;
X
X			if (*Tptr == '\0')
X				return str1;
X		}
X
X	return NIL(char);
X}
X#endif
X
X#if !DUP2		/* For those that do not have dup2() */
X#include <fcntl.h>
dup2(oldfd, newfd)
int oldfd, newfd;
X{
X	if (fcntl(oldfd, F_GETFL, 0) == -1)		/* Valid file descriptor? */
X		return (-1);						/* No, return an error */
X	close(newfd);							/* Ensure newfd is closed */
X	return (fcntl(oldfd, F_DUPFD, newfd));	/* Dup oldfd into newfd */
X}
X#endif /* !DUP2	Thanks to Bill Allie CIS: 76703,2061 */
X
X#if !STRDUP	/* For those that do not have strdup() */
char *
strdup(s)
char *s;
X{ return strcpy((char *)malloc(strlen(s)+1), s); }
X#endif
X
X#if !MEMSET		/* For those that do not have memset() */
char *
memset(dst, chr, len)
char *dst;
register chr, len;
X{
X	char *d;
X	for (d = dst; --len >= 0; *d++ = chr)
X		;
X	return dst;
X}
X#endif
X
void
msecs(t)
long t;
X{
X	long start;
X	struct tms Tbuf;
X
X	start = times(&Tbuf);
X	while ((times(&Tbuf)-start) < (t*HZ)/1000)
X		;
X}
X
X/*	Do the fork call, packaging the error return so that the caller
X	need not have code for it.
X*/
forkem()
X{
X	int i;
X
X	if ((i = fork()) < 0){
X		S1("XC: Fork failed");
X		longjmp(erret,1);
X	}
X	return i;
X}
X
X/*	Throw away all input characters until no more are sent. */
void 
purge(void) { while (readbyte(1) != -1) ; }
X
X/*	Line input routine to be used when the raw terminal mode is in effect. */
void 
getline()
X{
X	int c, i = 0;
X	char *ptr;
X
X	lptr = line;
X	memset(line, 0, SM_BUFF);
X
X	while ((c = getchar()) != '\r' && c != '\n'){
X		if (c == BS){
X			if (i > 0){
X				ptr = unctrl(line[--i]);
X				line[i] = '\0';
X				while (*ptr++ != '\0')
X					fputs("\b \b",tfp);
X			} else
X				beep();
X			continue;
X		}
X		if (c == LK){
X			while (i > 0){
X				ptr = unctrl(line[--i]);
X				while (*ptr++ != '\0')
X					fputs("\b \b",tfp);
X			}
X			memset(line, 0, SM_BUFF);
X			continue;
X		}
X		if (c == ('v' & 0x1f))
X			c = getchar();
X
X		line[i++] = c;
X		fputs(unctrl(c), tfp);
X	}
X}
X
X/*	Parse the "line" array for a word */
void 
getword()
X{
X	char quote, *ptr = word;
X	short carat = FALSE, backslash = FALSE;
X
X	wptr = lptr;
X	memset(word, 0, SM_BUFF);
X
X	while (isspace(*lptr))
X		lptr++;
X
X	if (*lptr == '\0')
X		return;
X
X	if (*lptr == '\'' || *lptr == '\"')
X		quote = *lptr++;
X	else
X		quote = '\0';
X
X	for (; *lptr != '\0'; lptr++){
X		if (quote){
X			if (*lptr == '\0'){
X				word[0] = '\0';
X				sprintf(Msg,"Unmatched quote: %s", line);
X				S;
X				s_exit();
X			}
X			if (*lptr == quote)
X				break;
X		} else if (!backslash && isspace(*lptr))
X			break;
X
X		if (carat)
X			*ptr++ = *lptr & 0x1f,
X			carat = FALSE;
X		else if (backslash)
X			*ptr++ = *lptr,
X			backslash = FALSE;
X		else if (*lptr == '^')
X			carat = TRUE;
X		else if (*lptr == '\\')
X			backslash = TRUE;
X		else
X			*ptr++ = *lptr;
X	}
X
X	lptr++;
X}
X
X/*	Make the specified word all lower case */
void 
lc_word(ptr)
char *ptr;
X{
X	while (*ptr){
X		*ptr = tolower(*ptr);
X		ptr++;
X	}
X}
X
X/*	Make the specified word all upper case */
void uc_word(ptr)
char *ptr;
X{
X	while (*ptr){
X		*ptr = toupper(*ptr);
X		ptr++;
X	}
X}
X
void 
mode(flag)
int flag;
X{
X	if (flag == NEWMODE)
X		ioctl(0, TCSETAF, &newmode);
X	else if (flag == SIGMODE)
X		ioctl(0, TCSETAF, &sigmode);
X	else if (flag == OLDMODE)
X		ioctl(0, TCSETAF, &oldmode);
X}
X
beep()
X{
X	putc(7,tfp);
X	return SUCCESS;
X}
X
X/*	initialize termcap stuff */
void 
get_ttype()
X{
X	char *ttytype;
X	char *p = tbuf;
X	char *s;
X
X	if (!(ttytype = getenv("TERM"))){
X		S1("TERM not set");
X		exit(6);
X	}
X	if (tgetent(tc, ttytype) != 1){
X		sprintf(Msg,"Can't load %s", ttytype);
X		S;
X		exit(7);
X	}
X	ospeed = newmode.c_cflag & CBAUD;
X	LI = tgetnum("li") - 1;
X	CO = tgetnum("co");
X	if (!(s=Tgetstr("pc")))
X		PC = '\0';
X	else
X		PC = *s;
X	
X	CD = Tgetstr("cd");
X	CE = Tgetstr("ce");
X	CL = Tgetstr("cl");
X	CM = Tgetstr("cm");
X	SE = Tgetstr("se");
X	SO = Tgetstr("so");
X	CF = Tgetstr("CF");
X	CN = Tgetstr("CN");
X	if (CF && ! CN)
X		CN = Tgetstr("CO");
X}
X
X/*	putchr() is a routine to pass to tputs() */
void
putchr(int c) { putc(c,tfp); }
X
void
cls(void) { tputs(CL,LI,putchr); }
X
void
cur_on(void) { tputs(CN,1,putchr); }
X
void
cur_off(void) { tputs(CF,1,putchr); }
X
void
cl_line(void) { tputs(CE,1,putchr); }
X
void
cl_end(void) { tputs(CD,LI,putchr); }
X
void 
ttgoto(int row, int col) { tputs(tgoto(CM, col, row),1,putchr); }
X
void 
drawline(row, col, len)
int row, col, len;
X{
X
X	ttgoto(row, col);
X	while (len--)
X		fputc('-', tfp);
X}
X
void 
show(flag, str)
short flag;
char *str;
X{
X	if (!flag){
X		beep();
X		ttgoto(LI,0),
X		cl_line(),
X		ttgoto(LI,(CO-strlen(str))/2 -1);
X	}
X	if (flag == 2)
X		putc('\n',tfp),
X		putc('\r',tfp);
X	tputs(SO,1,putchr);
X	putc(' ',tfp);
X	fputs(str, tfp);
X	putc(' ',tfp);
X	tputs(SE,1,putchr);
X	if (flag > 0)
X		putc('\n',tfp),
X		putc('\r',tfp);
X}
X
void 
show_abort(void) { S2("USER ABORT"); }
X
XFILE *
isregfile(pathname)
char *pathname;
X{
X	struct stat statbuf;
X
X	if (stat(pathname,&statbuf) || (statbuf.st_mode & S_IFMT) != S_IFREG)
X		return NIL(FILE);
X	return fopen(pathname, "r");
X}
X
X
XFILE *
openfile(name)
char *name;
X{
X	FILE *fp = NIL(FILE);
X	char *home, fullname[SM_BUFF], *path, *pathend;
X	int pathlen;
X
X	if ((path = getenv("XC_PATH"))){
X		while (!fp){
X			if (!(pathend = strchr(path, ':')))
X				pathlen = strlen(path);
X			else
X				pathlen = pathend - path;
X
X			sprintf(fullname, "%.*s/%s", pathlen, path, name);
X			fp = isregfile(fullname);
X
X			path += pathlen;
X			if (*path == '\0')
X				break;
X			path++;
X		}
X	}
X
X	if (!fp)
X		fp = isregfile(name);
X	
X	if (!fp){
X		if ((home = getenv("HOME")))
X			sprintf(fullname, "%s/%s", home, name);
X		fp = isregfile(fullname);
X	}
X
X	if (!fp){
X		sprintf(fullname, "%s/%s", LIBDIR, name);
X		fp = isregfile(fullname);
X	}
X
X	return fp;
X}
X
X/*	Translate the character specified by 'c' to its ASCII display name.
X	Note:	This routine is specific to the ASCII character set.
X*/
char *
unctrl(c)
int c;
X{
X	static char buffer[3], buf1[2];
X
X	memset(buffer, 0, 3);
X	memset(buf1, 0, 2);
X
X	if (c == 0x7f)
X		strcpy(buffer, "^?");
X	else {
X		if (iscntrl(c))
X			strcpy(buffer, "^"),
X			c += '@';
X		buf1[0] = c;
X		strcat(buffer, buf1);
X	}
X
X	return buffer;
X}
END_OF_FILE
if test 7179 -ne `wc -c <'xcsubs.c'`; then
    echo shar: \"'xcsubs.c'\" unpacked with wrong size!
fi
# end of 'xcsubs.c'
fi
if test -f 'xcterm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xcterm.c'\"
else
echo shar: Extracting \"'xcterm.c'\" \(5283 characters\)
sed "s/^X//" >'xcterm.c' <<'END_OF_FILE'
X/*	xcterm.c -- terminal mode module for XC
X	This file uses 4-character tabstops
X*/
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <ctype.h>
X#include <signal.h>
X#include <setjmp.h>
X#include <termio.h>
X#include "xc.h"
X
char captfile[SM_BUFF] = CAPTFILE,	/* capture file's name */
X	 phonefile[SM_BUFF] = PHFILE,	/* phone number file's name */
X	 ddsname[SM_BUFF];
XFILE	*cfp;				/* capture file pointer */
static FILE	*fp;			/* file to transmit */
static child_pid;			/* ID of child process */
static jmp_buf rtm, stop;
static void (*oldvec)();
short	s_flag, capture = FALSE;
extern short autoflag, hdplxflag, nl2cr;
extern get_bound_char();
X
X/*  start capturing */
static void 
capt_on(junk)
int junk;
X{
X	if (capture)
X		sprintf(Msg, "Already capturing to \"%s\"", captfile);
X	else {
X		if (!(cfp = fopen(captfile, "a")))
X			sprintf(Msg,"Can't open \"%s\" for capturing",captfile);
X		else
X			capture = TRUE,
X			sprintf(Msg,"Capturing to \"%s\"",captfile),
X			setbuf(cfp, NIL(char));
X	}
X	S2(Msg);
X
X	signal(SIGUSR1, capt_on);	/* set signal for next capt_on */
X}
X
X/*  stop capturing */
static void 
capt_off(junk)
int junk;
X{
X	if (!capture)
X		sprintf(Msg,"Sorry, we haven't been capturing lately");
X	else
X		fclose(cfp),
X		capture = FALSE,
X		sprintf(Msg,"\"%s\" closed for capturing",captfile);
X
X	S2(Msg);
X
X	signal(SIGUSR2, capt_off);	/* set signal for next capt_off */
X}
X
X/*	cleanup, flush and exit */
static void 
cleanup(junk)
int junk;
X{
X	if (capture)
X		fclose(cfp),
X		sprintf(Msg,"\"%s\" closed for capturing",captfile),
X		S2(Msg);
X
X	exit(0);
X}
X
static void 
cisbmode(junk)
int junk;
X{
X	cismode = 2;
X	signal(SIGCLD, SIG_IGN);
X	longjmp(rtm,1);
X}
X
static void 
end_divert(junk)
int junk;
X{
X	show_abort();
X	fclose(fp);
X	signal(SIGINT, oldvec);
X	longjmp(stop,1);
X}
X
X/*	Divert file into input stream, with delay after each newline. */
void 
divert(script)
short script;
X{
X	int c;
X	long i = 1;
X
X	if (!script)
X		fputc('\r',tfp),
X		fputc('\n',tfp),
X		show(-1,"File?"),
X		getline(),
X		getword();
X
X	if (word[0] == '\0')
X		return;
X
X	if (!(fp = fopen(word, "r"))){
X		sprintf(Msg,"Can't access '%s'",word);
X		S2(Msg);
X		return;
X	}
X
X	oldvec = signal(SIGINT,end_divert);
X	if (setjmp(stop))
X		return;
X
X	while ((c = getc(fp)) != EOF){
X		if (c != '\n')
X			sendbyte(c),
X			i++;
X		else {
X			sendbyte(nl2cr ? '\r' : '\n');
X			/*i = (CBAUD-cbaud)*80 + 4*i + 50; /* season to taste... */
X			i *= 3;
X			if (script)
X				k_waitfor(-i, "");
X			else
X				msecs(i);
X			i = 1;
X		}
X	}
X	fclose(fp);
X	signal(SIGINT,oldvec);
X}
X
X/*	Select a script file. */
static 
get_script()
X{
X	fputc('\r',tfp),
X	fputc('\n',tfp);
X	show(-1,"Enter script file:");
X	fputc(' ',tfp);
X	getline();
X	if (line[0] == '\0'){
X		fputc('\r',tfp),
X		fputc('\n',tfp);
X		S1("Script file not specified");
X		return FAILURE;
X	}
X	linkflag = FALSE;
X	getword();
X	sprintf(ddsname,"%s",word);
X	return SUCCESS;
X}
X
void 
terminal(todir)
short todir;
X{
X	register c;
X	short doneyet_dd = FALSE;
X
X
Reterm:
X	if (setjmp(rtm) || doneyet_dd)
X		return;
X
X	mode(NEWMODE);
X	s_flag = FALSE;		/* reset scripting flag */
X
X	if (!todir)
X		sprintf(Msg, "Entering TERMINAL mode - Escape character is '%s'",
X					   unctrl(my_escape)),
X		S2(Msg);
X
X	/* split into read and write processes */
X	if ((child_pid = forkem()) == 0){
X		/* child, read proc: read from port and write to tty */
X		cfp = NIL(FILE);
X		if (autoflag && !todir)
X			capt_on(0);
X		signal(SIGUSR1, capt_on);
X		signal(SIGUSR2, capt_off);
X		signal(SIGTERM, cleanup);
X
X		while (1){
X			while ((c = readbyte(0)) == -1)
X				;
X			if (cismode && c == ENQ)
X				cleanup(0);
X
X			fputc(c,tfp);
X
X			if (capture && c != '\r')
X				fputc(c,cfp);
X		}
X		/*NOTREACHED*/
X	}
X	/* parent, write proc: read from tty and write to port */
X	if (cismode)
X		signal(SIGCLD, cisbmode);
X
X	if (todir)
X		goto dialdir;
X	do {
X		switch (c = get_bound_char()){
X		case CAPTYES:		/* signal child to open capture file */
X			kill(child_pid, SIGUSR1);
X			break;
X
X		case CAPTEND:		/* signal child to close capture file */
X			kill(child_pid, SIGUSR2);
X			break;
X
X		case DIVCHAR:		/* divert a file through modem port */
X			mode(SIGMODE);
X			divert(FALSE);
X			mode(NEWMODE);
X			break;
X	
X		case BRKCHAR:
X			xmitbrk();
X			break;
X
X		case HLPCHAR:
X			show_bindings();
X			break;
X
X		case SCRPCHR:		/* execute a script file */
X			if (get_script()==FAILURE)
X				break;
X
X			/* fall through...  */
X
X		case DOSCRPT:		/* named script file */
X			s_flag = TRUE;
X			goto filicide;
X
X		case DIALCHR:		/* select and dial a phone number */
dialdir:
X			doneyet_dd = TRUE;
X			if ((dial_dir()==FAILURE && todir) || s_flag)
X				goto filicide;
X			break;
X
X		case ENDCHAR:		/* signal child to cleanup and exit */
filicide:
X			c = ENDCHAR;
X			signal(SIGCLD, SIG_IGN);
X			kill(child_pid, SIGTERM);
X			break;
X		
X		case QUITCHR:
X			signal(SIGCLD, SIG_IGN);
X			kill(child_pid, SIGTERM);
X			s_exit();
X			break;
X
X		case HUPCHAR:		/* Hangup */
X			hangup();
X			break;
X
X		case '\n':		/* See if NL translation in effect */
X			if (nl2cr)
X				c = '\r';
X
X		default:	/* just send the character to the port */
X			sendbyte(c);
X			if (hdplxflag)
X				fputc(c,tfp);
X			break;
X		}
X		todir = FALSE;
X	} while (c != ENDCHAR);
X
X	while (wait(NIL(int)) >= 0)	/* wait for the read process to die */
X		;
X
X	if (s_flag){
X		mode(SIGMODE);
X		do_script(ddsname);
X		goto Reterm;
X	}
X
X	reterm = FALSE;
X}
END_OF_FILE
if test 5283 -ne `wc -c <'xcterm.c'`; then
    echo shar: \"'xcterm.c'\" unpacked with wrong size!
fi
# end of 'xcterm.c'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
