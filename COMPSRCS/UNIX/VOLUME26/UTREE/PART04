Newsgroups: comp.sources.unix
From: klin@iat.uni-paderborn.de (Peter Klingebiel)
Subject: v26i067: utree - screen oriented filesystem utility (V3.03b-um), Part04/08
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: klin@iat.uni-paderborn.de (Peter Klingebiel)
Posting-Number: Volume 26, Issue 67
Archive-Name: utree/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 8)."
# Contents:  src/bind.c src/comm.c src/main.c src/utree.prlist.c
# Wrapped by vixie@cognition.pa.dec.com on Mon Sep  7 14:39:55 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/bind.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/bind.c'\"
else
echo shar: Extracting \"'src/bind.c'\" \(17641 characters\)
sed "s/^X//" >'src/bind.c' <<'END_OF_FILE'
X/*
X *      BIND.C
X *      UTREE key binding routines.
X *      3.03-um klin, Sun Feb 23 18:45:19 1992
X *              klin, Fri Mar  6 07:24:23 1992, Minor changes
X *            a klin, Sun Mar 15 19:08:25 1992, Bug fixes in bindings()
X *                                              and insertbinding()
X *
X *      Copyright (c) 1991/92 by Peter Klingebiel & UNIX Magazin Muenchen.
X *      For copying and distribution information see the file COPYRIGHT.
X */
X#ifndef lint
static char sccsid[] = "@(#) utree 3.03a-um (klin) Mar 15 1992 bind.c";
X#endif
X
X#include "defs.h"
X
X/* ---- Local variables and definitions ------------------------------- */
X
X/*
X *      All default keys and some function keys are defined in static
X *      arrays of type struct _ktable. The default keys are hold in the
X *      array defkeys[] and bound at startup to the defined utree keys.
X *      The function keys whose termcap names are stored in the array
X *      are extracted from terminfo/termcap and bound to the default
X *      utree keys if they are defined in the database.
X */
X
LOCAL struct {                 /* Default key bindings                 */
X  char *string;                 /*   Key string                         */
X  ksym symbol;                  /*   Key symbol known by utree          */
X} defkeys[] = {
X  { "\200", K_MARK },           /*   C-@: Set mark                      */
X  { "\001", K_HOME },           /*   C-a: Beginning                     */
X  { "\002", K_BACK },           /*   C-b: Backward                      */
X  { "\003", K_BRK  },           /*   C-c: Break                         */
X  { "\004", K_DOWN },           /*   C-d: Scroll down/delete char       */
X  { "\005", K_END  },           /*   C-e: End                           */
X  { "\006", K_FORW },           /*   C-f: Forward                       */
X  { "\007", K_GOTO },           /*   C-g: Goto mark                     */
X  { "\010", K_DEL  },           /*   C-h: Goto parent/delete char back  */
X  { "\011", K_TAG  },           /*   C-i: Goto tag/transpose chars      */
X  { "\012", K_SEL  },           /*   C-j: Select/accept line            */
X  { "\013", K_KILL },           /*   C-k: Kill line                     */
X  { "\014", K_REFR },           /*   C-l: Refresh screen/line           */
X  { "\015", K_SEL  },           /*   C-m: Select/accept line            */
X  { "\016", K_NEXT },           /*   C-n: Next                          */
X  { "\017", K_INS  },           /*   C-o: Change to/toggle insert mode  */
X  { "\020", K_PREV },           /*   C-p: Previous                      */
X  { "\022", K_HELP },           /*   C-r: Help                          */
X  { "\024", K_TAG  },           /*   C-t: Goto tag/transpose characters */
X  { "\025", K_UP   },           /*   C-u: Scroll up                     */
X  { "\026", K_NPAG },           /*   C-v: Next page/scroll forw line    */
X  { "\027", K_PPAG },           /*   C-w: Prev page/scroll back line    */
X  { "\030", K_CANC },           /*   C-x: Delete input line             */
X  { "\031", K_BRK  },           /*   C-y: Break                         */
X  { "\032", K_EOF  },           /*   C-z: Exit                          */
X  { "\177", K_DEL  },           /*   C-?: Delete                        */
X  { NULL,   K_INV  },           /* End of default key table             */
X};
X
X#define DTSTR(n)        (defkeys[n].string)
X#define DTSYM(n)        (defkeys[n].symbol)
X
LOCAL struct {                 /* Function key table                   */
X  char *string;                 /*   Termcap name                       */
X  ksym symbol;                  /*   Key symbol known by utree          */
X  char *name;                   /*   Key name                           */
X} funkeys[] = {
X  { "ku", K_PREV, "CursorUp-Key"        },
X  { "kd", K_NEXT, "CursorDown-Key"      },
X  { "kl", K_BACK, "CursorBackward-Key"  },
X  { "kr", K_FORW, "CursorForward-Key"   },
X  { "kh", K_HOME, "Home-Key"            },
X#ifdef  XENIX   /* RG 11/22/91 */
X  { "HM", K_HOME, "Begin-Key"           },
X  { "EN", K_END,  "End-Key"             },
X  { "PD", K_NPAG, "NextPage-Key"        },
X  { "PU", K_PPAG, "PrevPage-Key"        },
X#else   /* !XENIX */
X  { "@1", K_HOME, "Begin-Key"           },
X  { "@7", K_END,  "End-Key"             },
X  { "kN", K_NPAG, "NextPage-Key"        },
X  { "kP", K_PPAG, "PrevPage-Key"        },
X#endif  /* XENIX */
X  { "kR", K_UP,   "ScrollUp-Key"        },
X  { "kF", K_DOWN, "ScrollDown-Key"      },
X  { "kI", K_INS,  "Insert-Key"          },
X  { "kD", K_DOWN, "Delete-Key"          },
X  { "kC", K_REFR, "Clear-Key"           },
X  { "%1", K_HELP, "Help-Key"            },
X  { "*6", K_SEL,  "Select-Key"          },
X  { "@4", K_SEL,  "Do/Command-Key"      },
X  { "%2", K_MARK, "Mark-Key"            },
X  { "@8", K_SEL,  "Enter-Key"           },
X  { NULL, K_INV,  NULL   },     /*   End function key table             */
X};
X
X#define FTSTR(n)        (funkeys[n].string)
X#define FTSYM(n)        (funkeys[n].symbol)
X#define FTNAM(n)        (funkeys[n].name)
X
X#define KEYLEN 32               /* Max length of key strings            */
X#define KCOL   12
X#define EOL(c)          (c==' ' || c=='\t' || c=='#' || c=='\n' || c=='\0')
X
LOCAL int klchg = 0;            /* Changes in key bindings list         */
LOCAL char *unknown = "UNKNOWN";
X
X/* ---- External variables and functions ------------------------------ */
X
XEXTRN char *tgetstr();
XEXTRN char *getversion();
XEXTRN char *strclean();
X
X/* ---- Functions and procedures -------------------------------------- */
X
X/*
X *      INTERNAL USED ROUTINES
X */
X
X/* Insert keybinding from string str to symbol sym into binding list */
LOCAL int insertbinding(str, sym, nam, ins, usr)
X  register kchar *str;
X  register ksym sym;
X  register char *nam, *ins;
X  register int usr;
X{
X  register klist *kp, *pp, *p;
X
X  if(str == UNULL)
X    return(0);
X
X  /* Search for string in key binding list */
X  for(kp = kroot; kp; kp = (klist *) KBNXT(kp))
X    if(EQU(str, KBSTR(kp)))
X      break;
X
X  /* Replace an existing key binding */
X  if(kp)  {
X    if(KBSYM(kp) == K_STR && KBINS(kp))
X      ufree(KBINS(kp));
X    if(sym == K_STR && ins)
X      KBINS(kp) = strsav(ins);
X    else
X      KBINS(kp) = NULL;
X    KBSYM(kp) = sym;
X    KBUSR(kp) = usr;
X    return(1);
X  }
X
X  /* Create a new binding */
X  kp = (klist *) ualloc(1, sizeof(klist));
X  KBSTR(kp) = (kchar *) strsav((char *) str);
X  KBINS(kp) = sym == K_STR && ins ? strsav(ins) : NULL;
X  KBNAM(kp) = nam ? strsav(nam) : NULL;
X  KBSYM(kp) = sym;
X  KBUSR(kp) = usr;
X
X  /* Insert the binding into key binding list in reverse lexical order */
X  if(kroot && CMP(str, KBSTR(kroot)) < 0) {
X    for(pp = kroot; KBNXT(pp); pp = (klist *) KBNXT(pp)) {
X      p = (klist *) KBNXT(pp);
X      if(CMP((char *) str, KBSTR(p)) > 0)
X       break;
X    }
X    KBPRV(kp) = (glist *) pp;
X    KBNXT(kp) = KBNXT(pp);
X    if(p = (klist *) KBNXT(pp))
X      KBPRV(p) = (glist *) kp;
X    KBNXT(pp) = (glist *) kp;
X  }
X  else {
X    if(kroot)
X      KBPRV(kroot) = (glist *) kp;
X    KBPRV(kp) = GNULL;
X    KBNXT(kp) = (glist *) kroot;
X    kroot = kp;
X  }
X  return(1);
X
X} /* insertbinding() */
X
X/* Compare key name and return symbol */
LOCAL ksym getkeysymbol(s)
X  register char *s;
X{
X  register int i;
X
X  if(*s == '\"') {              /* Bind key to string to insert */
X    *s++ = '\0';
X    while(*s && *s != '\"')
X      ++s;
X    if(*s == '\"') {
X      *s = '\0';
X      return(K_STR);
X    }
X  }
X  else {                        /* Bind key to utree key */
X    strupper(s);
X    for(i = 0; KNNAM(i); i++)
X      if(EQU(s, KNNAM(i)))
X       return(KNSYM(i));
X  }
X  return(K_INV);
X
X} /* getkeysymbol() */
X
X/* Create a key string from ascii string s */
LOCAL kchar *getkeystring(s)
X  register char *s;
X{
X  static kchar st[KEYLEN+2];
X  register int i, o;
X
X  for(i = 0; !EOL(*s) && i < KEYLEN; i++) {
X    if(*s == '\\') {
X      ++s;
X      if(EOL(*s))
X       return(UNULL);
X      switch(*s) {
X       default:                /* As it is */
X         st[i] = *s;
X         break;
X       case 'e':               /* Escape */
X       case 'E':
X         st[i] = 0x1b;
X         break;
X       case 'n':               /* Newline */
X         st[i] = '\n';
X         break;
X       case 'r':               /* Carriage return */
X         st[i] = '\r';
X         break;
X       case 't':               /* Tab */
X         st[i] = '\t';
X         break;
X       case 's':               /* Space */
X         st[i] = ' ';
X         break;
X       case 'f':               /* Formfeed */
X         st[i] = '\f';
X         break;
X       case 'b':               /* Backspace */
X         st[i] = '\b';
X         break;
X       case '0':               /* Octal given value */
X       case '1':
X       case '2':
X       case '3':
X       case '4':
X       case '5':
X       case '6':
X       case '7':
X         o = 0;
X         do {
X           if(o < 0377) {
X             o <<= 3;
X             o |= *s - '0';
X           }
X           ++s;
X         } while(*s && *s >= '0' && *s <= '7');
X         st[i] = (kchar) o;
X         break;
X      }
X    }
X    else if(*s == '^') {
X      ++s;
X      if(EOL(*s))
X       return(UNULL);
X      if(*s == '?')                     /* DEL */
X       st[i] = 0x7f;
X      else if(*s == '@')                /* NUL */
X       st[i] = 0x80;
X      else if(*s >= 'A' && *s <= '_')   /* SOH .. US */
X       st[i] = *s - '@';
X      else if(*s >= 'a' && *s <= 'z')   /* SOH .. SUB */
X       st[i] = *s - '`';
X      else
X       return(UNULL);
X    }
X    else
X      st[i] = *s;
X    if(*s)
X      ++s;
X  }
X  st[i] = '\0';
X
X  return(i > 0 ? st : UNULL);
X
X} /* getkeystring() */
X
X/* Get and return ascii readable string from key string s */
LOCAL char *keystring(s, buf)
X  register kchar *s;
X  register char *buf;
X
X{
X  if(*s == '\0')
X    return("INVALID");
X  *buf = '\0';
X  while(*s) {
X    switch(*s) {
X      case 0x80:                /* Terminfo: ASCII-NUL */
X       (void) strcat(buf, "^@");
X       break;
X      case 0x1b:                /* ESC */
X       (void) strcat(buf, "\\e");
X       break;
X      case '\b':                /* BS */
X       (void) strcat(buf, "\\b");
X       break;
X      case 0x7f:                /* DEL */
X       (void) strcat(buf, "^?");
X       break;
X      case ' ':                 /* SP */
X       (void) strcat(buf, "\\s");
X       break;
X      case '\n':                /* NL */
X       (void) strcat(buf, "\\n");
X       break;
X      case '\r':                /* CR */
X       (void) strcat(buf, "\\r");
X       break;
X      case '\t':                /* TAB */
X       (void) strcat(buf, "\\t");
X       break;
X      case '\f':                /* FF */
X       (void) strcat(buf, "\\f");
X       break;
X      default:                  /* Others */
X       if(*s < ' ')            /* Control character */
X         (void) sprintf(buf, "%s^%c", buf, *s + '@');
X       else if(*s > 0x80)      /* Most significant bit set */
X         (void) sprintf(buf, "%s\\%03o", buf, *s);
X       else                    /* Printable character */
X         (void) sprintf(buf, "%s%c", buf, *s);
X       break;
X    }
X    ++s;
X  }
X  return(buf);
X
X} /* keystring() */
X
X/* Get and return name of symbol k */
LOCAL char *keysymbol(k)
X  register ksym k;
X{
X  register int i;
X
X  for(i = 0; KNNAM(i); i++)
X    if(KNSYM(i) == k)
X      return(KNNAM(i));
X  return(unknown);
X
X} /* keysymbol() */
X
X/* Get and return meaning of symbol k */
LOCAL char *keymeaning(k)
X  register ksym k;
X{
X  register int i;
X
X  for(i = 0; KNNAM(i); i++)
X    if(KNSYM(i) == k)
X      return(KNCOM(i));
X  return(unknown);
X
X} /* keymeaning() */
X
X/* Show all key bindings */
LOCAL int showbindings()
X{
X  char str[INPLEN];
X  register klist *kp;
X  register char *ks;
X  register int l, c, kl;
X
X  l = firstline;
X  c = RV_OK;
X  clearwindow(firstline, lastline);
X  for(kp = kroot; KBNXT(kp); kp = (klist *) KBNXT(kp))
X    ;
X  for(l = firstline; kp; kp = (klist *) KBPRV(kp)) {
X    ks = keystring(KBSTR(kp), str);
X    kl = strlen(ks);
X    if(KBSYM(kp) == K_STR && KBINS(kp))
X      c = putfxy(kl < KCOL ? KCOL-kl : 0,  l, 0, "%s=\"%s\"", ks, KBINS(kp));
X    else
X      c = putfxy(kl < KCOL ? KCOL-kl : 0,  l, 0, "%s=%s", ks, keysymbol(KBSYM(kp)));
X    if(KBNAM(kp))
X      (void) putfxy(c > columns/2 ? c : columns/2, l, 0, "#%s", KBNAM(kp));
X    else
X      (void) putfxy(c > columns/2 ? c : columns/2, l, 0, "#%s", keymeaning(KBSYM(kp)));
X    if(++l > lastline && KBNXT(kp)) {
X      puthelp("%s (CR:continue  ELSE:quit)", who);
X      c = hitakey("More key bindings ?", echoline, DA_NONE);
X      if( !(c == ' ' || c == '\n'))
X       return(c);
X      clearwindow(firstline, lastline);
X      l = firstline;
X    }
X  }
X  return(c);
X
X} /* showbindings() */
X
X/* Insert a key binding from a startup file line s. Ingore errors */
LOCAL int setbinding(s)
X  register char *s;
X{
X  register char *sp, *cp, *ep;
X  register kchar *str;
X  register ksym sym;
X
X  /* First scan and clean keystring and keyname/string to insert */
X  if((sp = strchr(s, '=')) == NULL)
X    return(0);
X  *sp++ = '\0';
X  s = strclean(s);
X
X  /* Get additional comment and clean binding/comment */
X  if(cp = strchr(sp, '#')) {
X    *cp++ = '\0';
X    cp = strclean(cp);
X  }
X  sp = strclean(sp);
X
X  /* Get key string from s and key symbol from sp */
X  if((str = getkeystring(s)) == UNULL || (sym = getkeysymbol(sp)) == K_INV)
X    return(1);
X  return(insertbinding(str, sym, cp && *cp ? cp : NULL, sym == K_STR ? ++sp : NULL, 1));
X
X} /* setbinding() */
X
X/*
X *      KEY BINDING ROUTINES
X */
X
X/* Initialize key bindings */
GLOBL VOID initbindings(term, cp)
X  register char *term, **cp;
X{
X  char buf[NAMELEN], bind[NAMELEN];
X  register FILE *fp;
X  register kchar *k;
X  register int i;
X
X  /* First: Initialize and link keyname list */
X  KNNXT(0) = KNLST(1);
X  for(i = 1; KNNAM(i+1); i++) {
X    KNNXT(i) = KNLST(i+1);
X    KNPRV(i) = KNLST(i-1);
X  }
X  KNPRV(i) = KNLST(i-1);
X
X  /* Second: Get default keys and insert into list */
X  for(i = 0; DTSTR(i); i++)
X    (void) insertbinding(DTSTR(i), DTSYM(i), NULL, NULL, 0);
X
X  /* Third: Get default function keys from database and insert into list */
X  for(i = 0; FTSTR(i) ; i++)
X    if(k = (kchar *) tgetstr(FTSTR(i), cp))
X      (void) insertbinding(k, FTSYM(i), FTNAM(i), NULL, 0);
X
X#ifdef  UTSTART
X  /* Last: Get global or user defined key bindings and insert into list */
X  (void) sprintf(bind, "%s-%s", UTSTART, term);
X  if(startup(buf, bind) && (fp = fopen(buf, "r"))) {
X    while(fgets(buf, sizeof(buf), fp))
X      if(VALID(buf[0]))
X       (void) setbinding(buf);
X    (void) fclose(fp);
X  }
X#endif  /* UTSTART */
X
X} /* initbindings() */
X
X/* Save user defined key bindings */
GLOBL VOID savebindings(term)
X  register char *term;
X{
X#ifdef  UTSTART
X  char buf[NAMELEN];
X  register klist *kp;
X  register FILE *fp;
X  time_t t;
X
X  if(VARVAL(V_AS) && klchg) {
X    (void) sprintf(buf, ".%s-%s", UTSTART, term);
X    (void) strcpy(buf, pathname(buf, home));
X    if(fp = fopen(buf, "w")) {
X      t = time((time_t *) 0);
X      (void) fprintf(fp, "# %s: ~/.%s-%s, %s", getversion(), UTSTART, term, ctime(&t));
X      for(kp = kroot; kp; kp = (klist *) KBNXT(kp))
X       if(KBUSR(kp)) {
X         (void) fprintf(fp, "%s=", keystring(KBSTR(kp), buf));
X         if(KBSYM(kp) == K_STR && KBINS(kp))
X           (void) fprintf(fp, "\"%s\"", KBINS(kp));
X         else
X           (void) fprintf(fp, "%s", keysymbol(KBSYM(kp)));
X         if(KBNAM(kp))
X           (void) fprintf(fp, "\t#%s\n", KBNAM(kp));
X         else
X           (void) fprintf(fp, "\n");
X       }
X      (void) fclose(fp);
X    }
X  }
X#endif  /* UTSTART */
X
X} /* savebindings() */
X
X/* Show all key bindings */
GLOBL int bindings()
X{
X  char buf[INPLEN], key[KEYLEN], com[INPLEN], k[2];
X  register klist *kp;
X  register char *kb;
X  register int c, f;
X
X  who = "KEY BINDINGS";
X  /* Key bindings loop */
X  f = 1;
X  while(1) {
X    if(f && ((c = showbindings())  < RV_NUL || c == 'q'))
X      break;
X    buf[0] = com[0] = k[1] = '\0';
X    /* Get key sequence terminated with CR */
X    puthelp("%s: Enter key to bind (NO EDIT! CR:quit)", who);
X    (void) putecho("Bind:");
X    cursorset(CF_VISIBLE);
X    k[0] = getchar();
X    if(k[0] == '\n' || k[0] == '\r')
X      break;
X    else if(k[0] == '\0')
X      k[0] = '\200';
X    (void) strcat(buf, keystring(k ,key));
X    puthelp("%s: Enter key to bind (NO EDIT! CR:terminate string)", who);
X    while(1){
X      (void) putecho("Bind: %s", buf);
X      k[0] = getchar();
X      if(k[0] == '\n' || k[0] == '\r')
X       break;
X      else if(k[0] == '\0')
X       k[0] = '\200';
X      (void) strcat(buf, keystring(k ,key));
X    }
X    /* Get utree key to bind to */
X    for(kp = kroot; kp; kp = (klist *) KBNXT(kp))
X      if(EQU(KBSTR(kp), getkeystring(buf)))
X       break;
X    if(kp) {
X      if(KBSYM(kp) == K_STR && KBINS(kp)) {
X       (void) sprintf(key, "\"%s\"", KBINS(kp));
X       kb = key;
X      }
X      else
X       kb = keysymbol(KBSYM(kp));
X    }
X    else
X      kb = NULL;
X    puthelp("%s: Give utree keyname for binding (CR:quit)", who);
X    c = putecho("Bind %s to:", buf);
X    if((c = getline(key, sizeof(key), c, 'k', kb, KNLST(0), 1)) <= RV_NUL)
X      break;
X    /* Get additional comment */
X    (void) sprintf(buf, "%s=%s", buf, key);
X    if(getkeysymbol(key) != K_INV) {
X      puthelp("%s: Give comment for binding", who);
X      c = putecho("Comment for key binding:");
X      if((c = getline(com, sizeof(com), c, 0, NULL, GNULL, 0)) < RV_NUL)
X       break;
X      if(com[0])
X       (void) sprintf(buf, "%s #%s", buf, com);
X      /* Do the binding */
X      if(setbinding(buf)) {
X       f = 1;
X       klchg = 1;
X       continue;
X      }
X    }
X    f = 0;
X    puthelp("%s %s", who, hitkey);
X    if((c = errequest(buf, "Error in setting")) < RV_NUL)
X      break;
X  }
X
X  cursorset(CF_INVISIBLE);
X  treeflag = fileflag = SF_FULL;
X  return(c);
X
X} /* bindings() */
X
END_OF_FILE
if test 17641 -ne `wc -c <'src/bind.c'`; then
    echo shar: \"'src/bind.c'\" unpacked with wrong size!
fi
# end of 'src/bind.c'
fi
if test -f 'src/comm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/comm.c'\"
else
echo shar: Extracting \"'src/comm.c'\" \(16221 characters\)
sed "s/^X//" >'src/comm.c' <<'END_OF_FILE'
X/*
X *      COMM.C
X *      UTREE common tree and file commands.
X *      3.01-um klin, Tue Jun  4 14:16:30 1991
X *              klin, Mon Oct  7 15:16:22 1991, File size patterns added
X *              klin, Sat Oct 26 15:07:06 1991, Sorting and zooming filelists changed
X *      3.02-um klin, Fri Nov  1 13:42:28 1991, Minor changes
X *              klin, Sun Nov 24 19:30:43 1991, Cd to current directory before
X *                                              executing some commands
X *      3.03-um klin, Tue Feb 11 19:40:06 1992, Status screen into stat.c
X *                                              getline() changed
X *
X *      Copyright (c) 1991/92 by Peter Klingebiel & UNIX Magazin Muenchen.
X *      For copying and distribution information see the file COPYRIGHT.
X */
X#ifndef lint
static char sccsid[] = "@(#) utree 3.03-um (klin) Feb 11 1992 comm.c";
X#endif  /* !lint */
X
X#include "defs.h"
X
X/* ---- Local variables and definitions ------------------------------- */
X
X#define CCOLUMN -8              /* Column for clock                     */
X
X/* Tokens for file pattern and time pattern matching                    */
X#define TK_ERR  'F'             /* Error                                */
X#define TK_END  'E'             /* End of pattern                       */
X#define TK_WORD 'W'             /* Word or file pattern matching        */
X#define TK_OR   '|'             /* ORing patterns                       */
X#define TK_AND  '&'             /* ANDing pattern                       */
X#define TK_SEQ  '='             /* Filesize equate                      */
X#define TK_SNE  '!'             /* Filesize unequate                    */
X#define TK_SGT  '>'             /* Filesize bigger                      */
X#define TK_SLT  '<'             /* Filesize smaller                     */
X#define TK_MNE  ')'             /* File     modified within (newer)     */
X#define TK_MOL  '('             /* File not modified within (older)     */
X
X/* States from token()                                                  */
X#define ST_NORM 0               /* Normal state                         */
X#define ST_WORD 1               /* In word                              */
X#define ST_QUOT 2               /* In quotes                            */
X#define ST_BRCK 3               /* In brackets                          */
X
LOCAL int patpos;               /* Current position in pattern          */
LOCAL char patbuf[PATLEN];      /* Pattern buffer for internal use      */
X
X/* ---- External variables and functions ------------------------------ */
X
XEXTRN struct tm *localtime();
X
X/* ---- Functions and procedures -------------------------------------- */
X
X/*
X *      COMMON COMMANDS
X */
X
X/* Display current date and time in echo line */
GLOBL int printdate()
X{
X  time_t tloc;
X
X  tloc = time((time_t *) 0);
X  puthelp("DATE: Current date and time %s", hitkey);
X  (void) putecho("%s", ctime(&tloc));
X  return(hitakey(NULL));
X
X} /* printdate() */
X
X/* Display current directory in echo line */
GLOBL int printcwd()
X{
X  puthelp("WHERE: Pathname of current directory %s", hitkey);
X  (void) putecho("%s", CPNAM);
X  return(hitakey(NULL));
X
X} /* printcwd() */
X
X/*
X *      CLOCK ROUTINES
X */
X
X#ifdef  UTCLOCK
X/* Turn on clock in echo line, update every second */
GLOBL VOID clockon()
X{
X  time_t tloc;
X  register struct tm *tm;
X
X  /* Get and display current time in echo line */
X  tloc = time((time_t *) 0);
X  tm   = localtime(&tloc);
X  if(cursorcap & CF_SAVE);
X    cursorset(CF_SAVE);
X  (void) putfxy(CCOLUMN, echoline, 0, "%02d:%02d:%02d",
X               tm->tm_hour, tm->tm_min, tm->tm_sec);
X  if(cursorcap & CF_RESTORE);
X    cursorset(CF_RESTORE);
X  flushout();
X  /* Set alarm for the next second and catch signal SIGALRM */
X  (void) alarm(1);
X  (void) signal(SIGALRM, clockon);
X
X} /* clockon() */
X
X/* Turn off clock in echo line */
GLOBL VOID clockoff()
X{
X  (void) alarm(0);              /* Suppress alarm */
X
X} /* clockoff() */
X#endif  /* UTCLOCK */
X
X/*
X *      FILE AND TIME STAMP PATTERN MATCHING ROUTINES
X */
X
X/* Get and return next token. If a word is found copy it to wp */
LOCAL int token(wp)
X  register char *wp;
X{
X  register int s;
X  register char c, *w;
X
X  s = ST_NORM;
X  w = wp;
X  /* Get token loop */
X  while(1) {
X    c = patbuf[patpos++];
X    switch(s) {
X      case ST_NORM:             /* Normal state */
X       switch(c) {
X         case '\n':
X         case '\r':
X         case '\0':
X           c = TK_END;
X           /*Fall thru*/
X         case TK_END:
X         case TK_AND:
X         case TK_OR:
X         case TK_SEQ:
X         case TK_SNE:
X         case TK_SGT:
X         case TK_SLT:
X         case TK_MNE:
X         case TK_MOL:
X           return(c);
X         case ' ':
X         case '\t':
X           continue;
X         case '"':
X         case '\'':
X           s = ST_QUOT;
X           continue;
X         case '[':
X           s = ST_BRCK;
X           *w++ = c;
X           continue;
X         case '\\':
X           if((c = patbuf[patpos++]) == '\0')
X             return(TK_ERR);
X           /*Fall thru*/
X         default:
X           s = ST_WORD;
X           *w++ = c;
X           continue;
X       }
X      case ST_BRCK:             /* In brackets */
X       switch(c) {
X         case '\n':
X         case '\r':
X         case '\0':
X           return(TK_ERR);
X         case ']':
X           s = ST_WORD;
X           /*Fall thru*/
X         default:
X           *w++ = c;
X           continue;
X       }
X      case ST_QUOT:             /* In quotes */
X       switch(c) {
X         case '"':
X         case '\'':
X           *w = '\0';
X           return(TK_WORD);
X         case '\\':
X           if((c = patbuf[patpos++]) == '\0')
X             return(TK_ERR);
X           /*Fall thru*/
X         default:
X           *w++ = c;
X           continue;
X       }
X      case ST_WORD:             /* In word */
X       switch(c) {
X         case TK_AND:
X         case TK_OR:
X         case TK_SEQ:
X         case TK_SNE:
X         case TK_SGT:
X         case TK_SLT:
X         case TK_MNE:
X         case TK_MOL:
X         case '\n':
X         case ' ':
X         case '\t':
X         case '\0':
X           --patpos;
X           *w = '\0';
X           return(TK_WORD);
X         case '[':
X           s = ST_BRCK;
X           *w++ = c;
X           continue;
X         case '\\':
X           if((c = patbuf[patpos++]) == '\0')
X             return(TK_ERR);
X           /*Fall thru*/
X         default:
X           *w++ = c;
X           continue;
X       }
X    }
X  }
X  /*NOT REACHED*/
X
X} /* token() */
X
X/* Token parsing and file/size/time pattern matching */
LOCAL int imatch(dp, f)
X  register dlist *dp;
X  register int f;
X{
X  static int lt;
X  char w[PATLEN];
X  register time_t ct;
X  register off_t fs;
X  register int t, i;
X
X  /* Inner matching loop */
X  while(1) {
X    switch(t = token(w)) {      /* Get next token */
X      default:                  /* Unknown */
X       t = TK_ERR;
X       /*Fall thru*/
X      case TK_ERR:              /* Return as it is */
X       return(t);
X      case TK_END:              /* End of pattern */
X      case TK_OR:               /* ORing patterns */
X      case TK_AND:              /* ANDing patterns */
X       if(lt != TK_WORD)
X         return(TK_ERR);
X       return(lt = t);
X      case TK_WORD:             /* File pattern matching */
X       lt = t;
X       if(dp)
X         return(match(FFNAM(dp, f), w));
X       return(1);
X      case TK_SEQ:              /* Filesize equate   */
X      case TK_SNE:              /* Filesize unequate */
X      case TK_SGT:              /* Filesize bigger   */
X      case TK_SLT:              /* Filesize smaller  */
X       if((lt = token(w)) != TK_WORD || !isdigit(w[0]))
X         return(TK_ERR);
X       fs = (off_t) 0;
X       for(i = 0; w[i] && isdigit(w[i]); i++)
X         fs = fs * (off_t) 10 + (off_t) (w[i] - '0');
X       switch(w[i]) {
X         default:              /* Error */
X           return(TK_ERR);
X         case 'm':             /* Megabytes */
X           fs *= (off_t) 1024;
X           /*Fall thru*/
X         case 'k':             /* Kilobytes */
X           fs *= (off_t) 1024;
X           /*Fall thru*/
X         case 'b':             /* Bytes (default) */
X         case '\0':
X           break;
X       }
X       if(dp) {
X         switch(t) {
X           case TK_SEQ:
X             return(FSIZE(dp,f ) == fs);
X           case TK_SNE:
X             return(FSIZE(dp, f) != fs);
X           case TK_SGT:
X             return(FSIZE(dp, f)  > fs);
X           case TK_SLT:
X             return(FSIZE(dp,f )  < fs);
X         }
X       }
X       return(1);
X      case TK_MNE:              /* Modified within     days/hours/minutes */
X      case TK_MOL:              /* Not modified within days/hours/minutes */
X       if((lt = token(w)) != TK_WORD || !isdigit(w[0]))
X         return(TK_ERR);
X       ct = (time_t) 0;
X       for(i = 0; w[i] && isdigit(w[i]); i++)
X         ct = ct * (time_t) 10 + (time_t) (w[i] - '0');
X       switch(w[i]) {
X         default:              /* Error */
X           return(TK_ERR);
X         case 'w':             /* Weeks */
X           ct *= (time_t) 7;
X           /*Fall thru*/
X         case 'd':             /* Days */
X           ct *= (time_t) 24;
X           /*Fall thru*/
X         case 'h':             /* Hours (default) */
X         case '\0':
X           ct *= (time_t) 60;
X           /*Fall thru*/
X         case 'm':             /* Minutes */
X           ct *= (time_t) 60;
X           break;
X       }
X       if(ct == (time_t) 0)
X         return(TK_ERR);
X       else if(dp) {
X         ct = time((time_t *) 0) - ct;
X         return(t == TK_MNE ? FMTIM(dp, f) > ct : FMTIM(dp, f) <= ct);
X       }
X       return(1);
X    }
X  }
X  /*NOT REACHED*/
X
X} /* imatch() */
X
X/* Do/combine file/size/time pattern matching */
GLOBL int umatch(dp, f, p)
X  register dlist *dp;
X  register int f;
X  register char *p;
X{
X  register int rv;
X
X  (void) strcpy(patbuf, p);
X  patpos = 0;
X  rv = -1;
X  /* Outer matching loop */
X  while(1) {
X    switch(imatch(dp, f)) {
X      case TK_END:              /* End */
X       return(rv <= 0 ? 0 : 1);
X      case 1:                   /* Match */
X       rv = 1;
X       break;
X      case 0:                   /* No match */
X       rv = 0;
X       break;
X      case TK_OR:               /* ORing */
X       if(rv < 0)
X         return(rv);
X       else
X         rv = (rv || imatch(dp, f) == 1) ? 1 : 0;
X       if(dp && rv)
X         return(rv);
X       break;
X      case TK_AND:              /* ANDing */
X       if(rv < 0)
X         return(rv);
X       else
X         rv = (rv && imatch(dp, f) == 1) ? 1 : 0;
X       if(dp && rv == 0)
X         return(rv);
X       break;
X      default:
X      case TK_ERR:
X       return(-1);
X    }
X  }
X  /*NOT REACHED*/
X
X} /* umatch() */
X
X/* Get file/size/time pattern and test it */
GLOBL int getpattern(p, m)
X  register char *p, *m;
X{
X  register int c;
X
X  /* Get/test pattern loop */
X  while(1) {
X    c = putecho(m);
X    c = getline(p, PATLEN, c, 'p', NULL, GNULL, 0);
X    if(c == RV_OK && umatch(DNULL, 0, p) < 0)
X      if((c = errequest(p, "Bad file pattern")) >= RV_NUL)
X       continue;
X    break;
X  }
X  return(c);
X
X} /* getpattern() */
X
X/*
X *      COMMON DIRECTORY AND FILE ROUTINES
X */
X
X/* Change current working directory to directory list entry dp */
GLOBL int changelist(dp, who)
X  register dlist *dp;
X{
X  if(cwlist == dp)                  /* Is already cwd */
X    return(RV_OK);
X  else if(DCANC(dp) && chdir(DPNAM(dp)) == 0) {
X    cwlist = dp;
X    return(RV_OK);
X  }
X  else if(who) {
X    puthelp("%s: %s %s", who, CFNAM, hitkey);
X    return(errequest(CFNAM, "Cannot change"));
X  }
X  return(RV_NUL);
X
X} /* changelist() */
X
X/* Check if operation for file fn with mode m is allowed */
GLOBL int isallowed(fn, m)
X  register char *fn;
X  register int m;
X{
X#ifdef  S_IFLNK
X  struct stat st;
X#endif  /* S_IFLNK */
X  register char *err;
X
X  switch(m) {
X    default:                    /* Others */
X      return(1);
X#ifdef  S_IFLNK
X    case FF_SLNK:               /* Check symbolic link */
X      if( !ISDIR(fn, st))
X       return(1);
X      /* Fall thru */
X#endif  /* S_IFLNK */
X    case FF_DIR:                /* Is directory */
X      err = "Is a directory";
X      break;
X    case FF_ERR:                /* Error in stat */
X      err = "Cannot stat";
X      break;
X  }
X  setvideo(DA_ERROR);
X  (void) putecho("!! %s: %s", fn, err);
X  setvideo(DA_NORMAL);
X  return(0);
X
X} /* isallowed() */
X
X/* Set sort flag to f and sort/resort filelist */
GLOBL int sortlist(dp, f)
X  register dlist *dp;
X  register int f;
X{
X  register char *n;
X
X  if(DSORT(dp) != f) {
X    DSORT(dp) = f;
X    if(DNFIL(dp) > 0) {
X      n = FFNAM(dp, DFCUR(dp));
X      sortflist(dp);
X      DFTOP(dp) = DFCUR(dp) = 0;
X      while(*n != *FFNAM(dp, DFCUR(dp)) || CMP(n, FFNAM(dp, DFCUR(dp))))
X       (void) gofile(dp, 1);
X    }
X  }
X  return(DNFIL(dp) ? RV_OK : RV_NUL);
X
X} /* sortlist() */
X
X/* Rebuild file list with new zoom pattern pat */
GLOBL int zoomlist(dp, pat)
X  register dlist *dp;
X  register char *pat;
X{
X  register int n;
X
X  if(DZOOM(dp)) {               /* Free old pattern */
X    ufree(DZOOM(dp));
X    DZOOM(dp) = NULL;
X  }
X  if(pat && pat[0])             /* Save new pattern */
X    DZOOM(dp) = strsav(pat);
X
X  n = DNFIL(dp);
X  if(DFLAG(dp) != FL_NUL) {     /* Rebuild filelist */
X    (void) newflist(dp);
X    if(n != DNFIL(dp));
X      return(1);
X  }
X
X  return(0);
X
X} /* zoomlist() */
X
X/* Search for pattern in file f from directory dp */
GLOBL int grepfile(dp, f)
X  register dlist *dp;
X  register int f;
X{
X  char buf[EXECLEN];
X  register int rv;
X
X  (void) sprintf(buf, "%s %s \"%s\" %s",
X                GRFILE, GROPTS, gpattern, pathname(FFNAM(dp, f), DPNAM(dp)));
X  if((rv = callsystem(buf, 0, 0)) == RV_INT)
X    return(errequest("Grep", "Interrupted"));
X  return(rv);
X
X} /* grepfile() */
X
X/* Find file f in directory dp */
GLOBL int findfile(dp, f)
X  dlist *dp;
X  register int f;
X{
X
X  if(f < DNFIL(dp) && umatch(dp, f, fpattern))
X    return(RV_OK);
X  return(RV_NUL);
X
X} /* findfile() */
X
X/* Remove file f from directory dp */
GLOBL int removefile(dp, f, req)
X  register dlist *dp;
X  register int f, req;
X{
X  char name[NAMELEN], buf[EXECLEN];
X  register int c;
X
X  /* Check if file can be removed */
X  if( !isallowed(FFNAM(dp, f), (int) FMODE(dp, f)))
X    return(hitakey(NULL));
X
X  (void) strcpy(name, pathname(FFNAM(dp, f), DPNAM(dp)));
X  if(req) {
X    (void) putecho("Remove %s ?", FFNAM(dp, f));
X    if((c = hitakey(NULL)) != 'y')
X      return(c);
X  }
X  else {
X    (void) putecho("Removing %s", FFNAM(dp, f));
X    flushout();
X  }
X  (void) sprintf(buf, "%s %s", RMFILE, name);
X  if(callsystem(buf, 0, 0) != RV_OK)
X    return(errequest(FFNAM(dp, f), "Cannot remove"));
X
X  /* Preserve current file, delete flist and set flags */
X  if(f < DFCUR(dp))
X    (void) gofile(dp, -1);
X  deleteflist(dp, f);
X  ++buildflag;
X  DFLAG(dp) = FL_CHG;
X
X  return(RV_OK);
X
X} /* removefile() */
X
X/* Copy file f from directory dp to directory/file to */
GLOBL int copyfile(dp, f, to, req)
X  register dlist *dp;
X  register int f, req;
X  register char *to;
X{
X  char from[NAMELEN], buf[EXECLEN];
X  register int c;
X
X  /* Check if copying is allowed */
X  if( !isallowed(FFNAM(dp, f), (int) FMODE(dp, f)))
X    return(hitakey(NULL));
X
X  (void) strcpy(from, pathname(FFNAM(dp, f), CPNAM));
X  if(req) {
X    (void) putecho("Copy %s ?", FFNAM(dp, f));
X    if((c = hitakey(NULL)) != 'y')
X      return(c);
X  }
X
X  (void) putecho("Copying %s to %s", FFNAM(dp, f), to);
X  (void) sprintf(buf, "%s %s %s", CPFILE, from, to);
X  if(callsystem(buf, 0, 0) != RV_OK)
X    return(errequest(FFNAM(dp, f), "Error in copying"));
X
X  return(RV_OK);
X
X} /* copyfile() */
X
X/* Move file f from directory dp to directory/file to */
GLOBL int movefile(dp, f, to, req)
X  register dlist *dp;
X  register int f, req;
X  register char *to;
X{
X  char from[NAMELEN], buf[EXECLEN];
X  register int c;
X
X  /* Check if moving is allowed */
X  if( !isallowed(FFNAM(dp, f), (int) FMODE(dp, f)))
X    return(hitakey(NULL));
X
X  (void) strcpy(from, pathname(FFNAM(dp, f), CPNAM));
X  if(req) {
X    (void) putecho("Move %s to %s ?", FFNAM(dp, f), to);
X    if((c = hitakey(NULL)) != 'y')
X      return(c);
X  }
X
X  (void) putecho("Moving %s to %s", FFNAM(dp, f), to);
X  (void) sprintf(buf, "%s %s %s", MVFILE, from, to);
X  if(callsystem(buf, 0, 0) != RV_OK)
X    return(errequest(FFNAM(dp, f), "Error in moving"));
X
X  return(RV_OK);
X
X} /* movefile() */
X
END_OF_FILE
if test 16221 -ne `wc -c <'src/comm.c'`; then
    echo shar: \"'src/comm.c'\" unpacked with wrong size!
fi
# end of 'src/comm.c'
fi
if test -f 'src/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/main.c'\"
else
echo shar: Extracting \"'src/main.c'\" \(21728 characters\)
sed "s/^X//" >'src/main.c' <<'END_OF_FILE'
X/*
X *      MAIN.C
X *      UTREE main routine.
X *      3.01-um klin, Sat May  4 15:45:02 1991
X *              klin, Tue Oct 15 12:26:53 1991, Option -L added
X *              klin, Sat Oct 26 15:04:54 1991, writedlist() changed
X *      3.02-um klin, Fri Nov  1 10:46:14 1991, Option -u changed to -n
X *                                              Option -u added
X *              klin, Sun Nov 10 19:37:45 1991, buildlist() changed
X *              klin, Sun Nov 24 19:30:43 1991, Cd to current directory before
X *                                              executing some commands
X *      3.03-um klin, Tue Feb 11 22:35:55 1992, Shell command history added
X *              klin, Sat Feb 15 19:18:30 1992, Video handling and option -v
X *                                              changed
X *                                              Partinioning of directory and
X *                                              file windows changed and
X *                                              option -p added
X *              klin, Sun Feb 23 18:45:19 1992, Keybindings, variable AUTOSAVE
X *                                              and option -o added
X *
X *      Copyright (c) 1991/92 by Peter Klingebiel & UNIX Magazin Muenchen.
X *      For copying and distribution information see the file COPYRIGHT.
X */
X#ifndef lint
static char sccsid[] = "@(#) utree 3.03-um (klin) Feb 23 1992 main.c";
X#endif  /* !lint */
X
X/*
X *      Usage:  utree   [-LSVabcghnoqrstuw] [-d var=[val]] [-d cmd:[typ]] [-f lst]
X *                      [-f lst] [-i ind] [-l lev] [-p lin] [-v mod] [-x cmd]
X *                      [rootdir]
X *
X *      Options:        -L              Follow symbolic links
X *                      -S              Ignore minimal screen size.
X *                      -V              Display program version.
X *                      -a              Read in all dirs including hidden.
X *                      -b              No bell
X *                      -c              No clock display/update in echoline.
X *                      -d var=[val]    Define/undefine variable var.
X *                      -d typ:[cmd]    Define/undefine command for type typ.
X *                      -f lst          Build tree from list file lst.
X *                      -g              No graphic characters.
X *                      -h              Display some help about options.
X *                      -i ind          Set tree indention to ind (3..9)
X *                      -l lev          Build tree up to level lev.
X *                      -n              No scan tree for changes.
X *                      -o              Omit saving definition/history changes.
X *                      -p lin          Set file window to lin lines (1..9)
X *                      -q              Build tree up to level 2 (like -l 2).
X *                      -r              Recreate tree list (always scan disk).
X *                      -s              No hardware scrolling.
X *                      -t              Sort files by modification times.
X *                      -u              Update directory tree.
X *                      -v mod          Set video attribute settings (0,1,2)
X *                      -w              No warning about unreadable dirs.
X *                      -x cmd          Use string cmd as initial input.
X *                      The options bcginopsvw may also be set in the environment
X *                      variable $UTREE.
X *
X *      Directory:      /usr/local/bin
X *
X *      Environment:    $EDITOR $HOME $PAGER $SHELL $TERM $UTREE $UTLIB
X *
X *      Files:          $UTLIB/utree.help       - Utree help pages.
X *                      $UTLIB/utree            - Global startup file.
X *                      $UTLIB/utree-$TERM      - Global key bindings for $TERM
X *                      $HOME/.utree            - User's startupfile.
X *                      $HOME/.utreelist        - User's tree list file.
X *                      $HOME/.utreehist        - Shell command history.
X *                      $HOME/.utree-$TERM      - Users key bindings for $TERM
X *                      $PATH/utree.prlist      - Tree display program
X *                      $PATH/utree.backup      - Backup shell script.
X *                      $PATH/utree.mklist      - Create tree list.
X *
X *      Libraries:      -lcurses (SYSV), -ltermcap or -ltermlib (BSD)
X *
X *      Bugs:           Changes in filesystem after shell or editor escape
X *                      are not always detected!
X *                      Directory tree depth > 32 may confuse utree!
X *                      Symbolic links to directories may confuse utree!
X *                      Chown() and chgrp() for normal users on some BSD
X *                      systems are not allowed!
X */
X
X#define _MAIN_                          /* Declare external variables   */
X#include "defs.h"                       /* defined in header files      */
X
X/* ---- Gobal variables and definitions ------------------------------- */
X
X#define USES1   "[-LSVabcghnoqrstuw] [-d var=[val]] [-d cmd:[typ]] [-f lst]"
X#define USES2   "[-i ind] [-l lev] [-p lin] [-v mod] [-x cmd] [rootdir]"
X#define UOPTS   "LSVabcd:f:ghi:nl:p:qrstuv:wx:" /* String for getopt()  */
X
GLOBL int helpline,   echoline;         /* Help/echo lines              */
GLOBL int firstline,  lastline;         /* First/last lines             */
GLOBL int firstdline, lastdline;        /* First/last tree lines        */
GLOBL int ndlines;                      /* # dir lines on tree screen   */
GLOBL int firstfline, lastfline;        /* First/last file lines        */
GLOBL int nflines;                      /* # file lines on tree screen  */
GLOBL int maxnflines = DEFFIL;          /* Max file lines               */
GLOBL int fperpage,   fperline;         /* Files per page/line          */
GLOBL int treeflag,   fileflag;         /* Screen update flags          */
GLOBL int filecount,  dircount;         /* # of files/directories       */
GLOBL int indent = -1;                  /* Tree indention: 2..9         */
GLOBL int videomode = VMODE2;           /* Video mode: all attributes   */
GLOBL int videoattr = VA_NORMAL;        /* Video attribute              */
GLOBL int graphattr = GC_OFF;           /* Graphic character set flag   */
GLOBL int maxindent = 0;                /* User defined tree indention  */
GLOBL int maxlevel;                     /* Current max tree level       */
GLOBL int buildflag  = 0;               /* Rebuild directory flag       */
GLOBL int writeflag  = 0;               /* Rewrite tree list file       */
GLOBL int sortbytime = 0;               /* Sort file by mod times       */
GLOBL int hiddendirs = 0;               /* Build up hidden directories  */
GLOBL int sizechange = 0;               /* Screen size changed          */
GLOBL int (*statfun)() = lstat;         /* Follow symbolic links        */
GLOBL dlist *droot   = DNULL;           /* Root of directory list       */
GLOBL dlist *cdlist  = DNULL;           /* Current directory list       */
GLOBL dlist *cwlist  = DNULL;           /* Current working directory    */
GLOBL char fpattern[PATLEN] = { '\0' }; /* Search pattern file search   */
GLOBL char gpattern[PATLEN] = { '\0' }; /* Search pattern file grep     */
GLOBL char tpattern[PATLEN] = { '\0' }; /* Tag pattern file tag         */
GLOBL char rootdir[NAMELEN];            /* Root directory name          */
GLOBL char utreemenu[MINCOLS];          /* User command tree menu line  */
GLOBL char ufilemenu[MINCOLS];          /* User command file menu line  */
GLOBL char *prgname;                    /* Program name/version         */
GLOBL char *home;                       /* Home directory               */
X#ifdef  BSD
GLOBL jmp_buf winchjump;                /* Global goto for SIGWINCH     */
GLOBL int atread;                       /* Flag if we are in getchar()  */
X#endif
X
GLOBL char *who;                        /* Name of current command      */
GLOBL char *hitkey = "(Hit a key)";
X
X/* ---- External variables and functions ------------------------------ */
X
XEXTRN char *optarg;                     /* From getopt()                */
XEXTRN int optind;                       /*   "     "                    */
XEXTRN char *initscreen();
XEXTRN int exitscreen();
XEXTRN char *calloc();
XEXTRN char *writedlist();
X
X/* ---- Functions and procedures -------------------------------------- */
X
X/*
X *      INTERNAL USED ROUTINES
X */
X
X/* Display usage message and some help about options if flag f is set */
LOCAL VOID usage(f)
X  register int f;
X{
X  (void) fprintf(stderr, "Usage:\t%s\t%s\n\t\t%s\n", prgname, USES1, USES2);
X  if(f) {
X    (void) fprintf(stderr, "\t-L\t\tFollow symbolic links\n");
X    (void) fprintf(stderr, "\t-S\t\tIgnore minimal screen size\n");
X    (void) fprintf(stderr, "\t-V\t\tDisplay program version\n");
X    (void) fprintf(stderr, "\t-a\t\tRead in all (incl hidden) directories\n");
X    (void) fprintf(stderr, "\t-b\t\tSuppress ringing of the bell\n");
X    (void) fprintf(stderr, "\t-c\t\tDon't display and update a clock\n");
X    (void) fprintf(stderr, "\t-d var=[val]\tSet/unset variable\n");
X    (void) fprintf(stderr, "\t-d typ:[cmd]\tSet/unset filetype command\n");
X    (void) fprintf(stderr, "\t-f lst\t\tBuild tree from list file lst\n");
X    (void) fprintf(stderr, "\t-g\t\tDon't use graphic characters\n");
X    (void) fprintf(stderr, "\t-h\t\tDisplay some help about options\n");
X    (void) fprintf(stderr, "\t-i ind\t\tSet tree indention to ind (3..9)\n");
X    (void) fprintf(stderr, "\t-l lev\t\tBuild tree up to level lev\n");
X    (void) fprintf(stderr, "\t-n\t\tDon't scan tree for changes in tree\n");
X    (void) fprintf(stderr, "\t-o\t\tOmit saving definition/history changes\n");
X    (void) fprintf(stderr, "\t-p lin\t\tSet file lines on tree screen to lin (1..9)\n");
X    (void) fprintf(stderr, "\t-q\t\tBuild tree up to level 2 (like -l 2)\n");
X    (void) fprintf(stderr, "\t-r\t\tRecreate tree list (always scan disk)\n");
X    (void) fprintf(stderr, "\t-s\t\tDon't use hardware scrolling\n");
X    (void) fprintf(stderr, "\t-t\t\tSort files by modification times\n");
X    (void) fprintf(stderr, "\t-u\t\tUpdate file lists in directory tree\n");
X    (void) fprintf(stderr, "\t-v mod\t\tSet video attribute mode to mod (0, 1 or 2)\n");
X    (void) fprintf(stderr, "\t-w\t\tNo warning about unreadable directories\n");
X    (void) fprintf(stderr, "\t-x cmd\t\tUse string cmd as initial input\n");
X  }
X
X} /* usage() */
X
X/* Exit utree on error */
LOCAL VOID uerror(err)
X  register char *err;
X{
X  (void) cursorxy(0, lines - 1);
X  clearline();
X  flushout();
X  terminalreset(1);
X  (void) fprintf(stderr, "%s: ", prgname);
X  perror(err);
X  exit(1);
X  /*NOTREACHED*/
X
X} /* uerror() */
X
X/*
X *      SETUP VARIABLES
X */
X/* Set up terminal dependent variables */
LOCAL int setupscreen(sig)
X  register int sig;
X{
X#if     defined(SIGWINCH) && defined(TIOCGWINSZ)
X  struct winsize ws;
X
X  /* Signal SIGWINCH catched: get new screen size */
X  if(sig && ioctl(fileno(stdin), TIOCGWINSZ, (char *) &ws) == 0) {
X    if(ws.ws_row > 0)
X      lines = ws.ws_row;
X    if(ws.ws_col > 0)
X      columns = ws.ws_col;
X    sizechange = 1;
X    if(lines < MINLINS)
X      bell(1);
X    if(columns < MINCOLS)
X      bell(1);
X    flushout();
X  }
X  /* Catch signal SIGWINCH for window changes */
X  (void) signal(SIGWINCH, setupscreen);
X#endif  /* SIGWINCH && TIOCGWINSZ */
X
X  /* Set up some screen size dependent variables */
X  echoline   = 0;
X  helpline   = 1;
X  firstline  = 2;
X  lastline   = lines-1;
X  firstdline = firstline;
X  lastfline  = lastline;
X  fperline   = columns/FWINSZ;
X  fperpage   = (lines-2) * fperline;
X  if(fperline <= 0)
X    fperline = 1;
X  /* Check some variables */
X  if(fperpage <= 0)
X    fperpage = 1;
X  checklines(1);
X  (void) setvideomode(videomode);
X
X#if     defined(BSD) && defined(SIGWINCH) && defined(TIOCGWINSZ)
X  /* BSD: Because signal SIGWINCH doesn't interrupt the systemcall */
X  /*      read use the global goto longjmp() to return to getchar  */
X  if(sig && atread && sizechange)
X    longjmp(winchjump, 1);
X#endif  /* BSD && SIGWINCH && TIOCGWINSZ */
X
X} /* setupscreen() */
X
X/*
X *      GET STARTUPFILES
X */
X
X/* Build startupfile name from file f and copy it to buffer b */
GLOBL int startup(b, f)
X  register char *b, *f;
X{
X  register char *e;
X
X  /* First: Try user's home directory */
X  (void) sprintf(b, ".%s", f);
X  (void) strcpy(b, pathname(b, home));
X  if(access(b, 04) == 0)
X    return(1);
X  /* Second: Try libdir if defined in environment */
X  if(e = getenv("UTLIB")) {
X    (void) strcpy(b, pathname(f, e));
X    if(access(b, 04) == 0)
X      return(1);
X  }
X  /* Third: Try global libdir if defined */
X#ifdef  UTLIB
X  (void) strcpy(b, pathname(f, UTLIB));
X  if(access(b, 04) == 0)
X    return(1);
X#endif  /* UTLIB */
X  return(0);
X
X} /* startup() */
X
X/*
X *      MEMORY ALLOCATION
X */
X
X/* Allocate memory. Exit on error */
GLOBL char *ualloc(n, s)
X  register unsigned n, s;
X{
X  register char *p;
X
X  if(p = calloc(n, s))
X    return(p);
X  uerror("ualloc");
X  /*NOTREACHED*/
X
X} /* ualloc() */
X
X/* Free allocated memory */
GLOBL VOID ufree(p)
X  register char *p;
X{
X  if(p)
X    free(p);
X
X} /* ufree() */
X
X/*
X *      MAIN ROUTINE
X */
X
GLOBL VOID main(argc, argv)
X  int argc;
X  char **argv;
X{
X  char list[NAMELEN], name[NAMELEN], cwd[NAMELEN];
X  struct stat st;
X  FILE *fp;
X  char *lst = NULL;
X  char *cp, *root, *term;
X  int hard = 0, level = 0, siz = 1, update = 0;
X  int opt, any, rval, i;
X
X  /* Set up programs name and commandline variables */
X  prgname = basename(argv[0]);
X
X  /* Get users home directory */
X  if((home = getenv("HOME")) == NULL) {
X    (void) fprintf(stderr, "%s: Can't get your home directory\n", prgname);
X    exit(1);
X  }
X
X  /* Check if utree is running from a terminal */
X  if( !isatty(fileno(stdin)) || !isatty(fileno(stdout))) {
X    (void) fprintf(stderr, "%s: Not attached to a terminal\n", prgname);
X    exit(1);
X  }
X
X  /* Init utree variables before parsing command line options */
X  initvariables();
X
X  /* Parse and check command line options */
X  while((opt = getopt(argc, argv, UOPTS)) != EOF)
X    switch(opt) {
X      default:                  /* Bad option or missing argument */
X       usage(0);
X       exit(1);
X      case 'L':                 /* Follow symbolic links */
X       statfun = stat;
X       break;
X      case 'S':                 /* Ignore minimal screen size */
X       siz = 0;
X       break;
X      case 'V':                 /* Show utree version */
X       utreeversion();
X       exit(0);
X      case 'a':                 /* Build up all directories */
X       hiddendirs = 1;
X       break;
X      case 'b':                 /* No bell */
X       (void) setvariable("BL=", VC_SET);
X       break;
X      case 'c':                 /* No clock showing and update */
X       (void) setvariable("CL=", VC_SET);
X       break;
X      case 'd':                 /* Define or undefine variables */
X       if(strchr(optarg, '=')) {
X         (void) setvariable(optarg, VC_SET);
X         break;
X       }
X       else if(strchr(optarg, ':')) {
X         (void) setcommand(optarg, VC_SET);
X         break;
X       }
X       (void) fprintf(stderr, "%s: bad assignment -- %s\n",
X                      prgname, optarg);
X       usage(0);
X       exit(1);
X      case 'f':                 /* Tree list file given */
X       lst = optarg;
X       break;
X      case 'g':                 /* No graphic characters */
X       (void) setvariable("GC=", VC_SET);
X       break;
X      case 'h':                 /* Display some help */
X       utreeversion();
X       usage(1);
X       exit(0);
X      case 'i':                 /* Tree level indention */
X       (void) sprintf(list, "TI=%s", optarg);
X       if(setvariable(list, VC_SET) < 0) {
X         (void) fprintf(stderr, "%s: bad tree indention (must be 3 .. 9) -- %s\n",
X                        prgname, optarg);
X         usage(0);
X         exit(1);
X       }
X       break;
X      case 'l':                 /* Level to build up the tree */
X       if((level = atoi(optarg)) <= 0) {
X         (void) fprintf(stderr, "%s: bad tree level (must be > 0) -- %s\n",
X                        prgname, optarg);
X         usage(0);
X         exit(1);
X       }
X       break;
X      case 'n':                 /* No scan tree for changes */
X       (void) setvariable("ST=", VC_SET);
X       break;
X      case 'o':                 /* Omit saving definition changes */
X       (void) setvariable("AS=", VC_SET);
X       break;
X      case 'p':                 /* Number of file lines on tree screen */
X       (void) sprintf(list, "FL=%s", optarg);
X       if(setvariable(list, VC_SET) < 0) {
X         (void) fprintf(stderr, "%s: bad number of lines (must be 1 .. 9) -- %s\n",
X                        prgname, optarg);
X         usage(0);
X         exit(1);
X       }
X       break;
X      case 'q':                 /* Build tree up to level 2 */
X       level = 2;
X       break;
X      case 'r':                 /* Hard build up the tree */
X       hard = writeflag = 1;
X       break;
X      case 's':                 /* No terminal scrolling */
X       (void) setvariable("TS=", VC_SET);
X       break;
X      case 't':                 /* Sort files by modification times */
X       (void) setvariable("LS=", VC_SET);
X       break;
X      case 'u':                 /* Update filelists in tree */
X       update = buildflag = 1;
X       break;
X      case 'v':                 /* Set video mode */
X       (void) sprintf(list, "VM=%s", optarg);
X       if(setvariable(list, VC_SET) < 0) {
X         (void) fprintf(stderr, "%s: bad mode (use 0, 1 or 2) -- %s\n",
X                        prgname, optarg);
X         usage(0);
X         exit(1);
X       }
X       break;
X      case 'w':                 /* No warning about unreadable directories */
X       (void) setvariable("WD=", VC_SET);
X       break;
X      case 'x':                 /* Fill input buffer */
X       if(ungetstring(optarg)) {
X         (void) fprintf(stderr, "%s: bad input string -- %s\n",
X                        prgname, optarg);
X         usage(0);
X         exit(1);
X       }
X       break;
X    }
X
X  /* Get current working directory */
X  (void) getcwd(cwd, NAMELEN-2);
X
X  /* Check list file if given and setup rootdirectory */
X  if(lst) {
X    if( !(fp = fopen(lst, "r"))) {
X      (void) fprintf(stderr, "%s: Cannot open list file %s\n", prgname, lst);
X      exit(1);
X    }
X    while(fgets(name, sizeof(name), fp)) {
X      if(VALID(name[0]) && (name[0] == '/' || name[0] == '.')) {
X       if(name[i = strlen(name) - 1] == '\n')
X         name[i] = '\0';
X       (void) fclose(fp);
X       goto OUT;
X      }
X    }
X    (void) fclose(fp);
X    (void) fprintf(stderr, "%s: No root found in list file %s\n", prgname, lst);
X    exit(1);
X  }
OUT:
X
X  /* Get root directory from where to build up the directory tree */
X  switch(argc - optind) {
X    case 0:                     /* Root from list file */
X      if(lst) {
X       (void) strcpy(list, pathname(lst, cwd));
X       root = pathname(name, cwd);
X      }
X      else {                    /* Root is users home directory */
X       (void) strcpy(list, pathname(UTLIST, home));
X       root = home;
X      }
X      break;
X    case 1:                     /* Root is given in command line */
X      root = pathname(argv[optind], cwd);
X      break;
X    default:                    /* Too many arguments */
X      usage(0);
X      exit(1);
X  }
X
X  /* Test and change to root directory */
X  if( !ISDIR(root, st)) {
X    (void) fprintf(stderr, "%s: Root %s is not a directory\n", prgname, root);
X    exit(1);
X  }
X  if(chdir(root)) {
X    (void) fprintf(stderr, "%s: Can't change to root %s\n", prgname, root);
X    exit(1);
X  }
X  (void) strcpy(rootdir, root);
X  any = strncmp(root, home, strlen(home));
X
X  /* Init screen and check screen size */
X  term = getenv("TERM");
X  if(cp = initscreen(term)) {
X    (void) fprintf(stderr, "%s: %s\n", prgname, cp);
X    exit(1);
X  }
X  else if(siz && (columns < MINCOLS || lines < MINLINS)) {
X    (void) fprintf(stderr, "%s: Screen too small, %dx%d instead of %dx%d\n",
X                  prgname, columns, lines, MINCOLS, MINLINS);
X    exit(1);
X  }
X  (void) setupscreen(0);
X
X  /* Init history list, help pages, key bindings and graphical character set */
X  inithistory();
X  inithelp();
X  initgraphics(VARSET(V_GC));
X
X  /* Catch signals and set terminal to raw mode. ATTENTION:  */
X  /* SIGKILL cannot be caught. This leaves tty in raw state! */
X  terminalraw(1);
X  (void) signal(SIGQUIT, exitscreen);
X  (void) signal(SIGINT,  exitscreen);
X  (void) signal(SIGTERM, exitscreen);
X  enablesignals();
X
X  /* Show initial screen */
X  clearscreen();
X  (void) putversion(helpline, NULL);
X  flushout();
X
X  /* Build up directory tree and file lists */
X  if(lst)
X    rval = buildlist(rootdir, cwd, list);
X  else if(level) {
X    update = 0;
X    rval = buildread(rootdir, 1, level, 0);
X  }
X  else if(hard || any) {
X    update = 0;
X    rval = buildread(rootdir, 1, HLEVEL, 0);
X  }
X  else if((rval = buildlist(rootdir, cwd, list)) != RV_OK) {
X    update = 0;
X    writeflag = 1;
X    rval = buildread(rootdir, 1, HLEVEL, 0);
X  }
X
X  /* Exit on error at building tree */
X  if(rval != RV_OK)
X    uerror(rootdir);
X
X  /* Disable/ignore signals */
X  disablesignals();
X  (void) signal(SIGQUIT, SIG_IGN);
X  (void) signal(SIGINT,  SIG_IGN);
X  cursorset(CF_INVISIBLE);
X  flushout();
X
X  /* Call the tree menu */
X  cwlist = droot;
X  rval = treemenu(update);
X
X  /* Write/rewrite tree and command history lists if needed */
X  if(EQU(rootdir, home)) {
X    if(writeflag && !(level || any)) {
X      (void) strcpy(list, pathname(UTLIST, home));
X      (void) writedlist(list, droot, "home", 'd');
X    }
X  }
X
X  /* Save history list, variables, commands and key bindings */
X  savehistory();
X  savevariables();
X  savebindings(term);
X
X  /* Clear screen, reset terminal and exit */
X  clearscreen();
X  exitscreen(rval == RV_ERR ? 1 : 0);
X
X} /* main() */
X
END_OF_FILE
if test 21728 -ne `wc -c <'src/main.c'`; then
    echo shar: \"'src/main.c'\" unpacked with wrong size!
fi
# end of 'src/main.c'
fi
if test -f 'src/utree.prlist.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/utree.prlist.c'\"
else
echo shar: Extracting \"'src/utree.prlist.c'\" \(16227 characters\)
sed "s/^X//" >'src/utree.prlist.c' <<'END_OF_FILE'
X/*
X *      UTREE.PRLIST.C
X *      Filter for utree 3.02-um tree list files for different devices.
X *      3.02-um klin, Sun Nov 10 13:13:35 1991
X *              klin, Sun Nov 24 12:07:16 1991, XENIX graphset handling
X *      3.03-um klin, Sun Feb 16 15:34:37 1992, Minor changes
X *            a klin, Sun Mar 15 19:08:25 1992, Minor changes for AIX 3.2
X *
X *      Copyright (c) 1991/92 by Peter Klingebiel & UNIX Magazin Muenchen.
X *      For copying and distribution information see the file COPYRIGHT.
X */
static char sccsid[] = "@(#) utree 3.03a-um (klin) Mrz 15 1992 utree.prlist.c";
X
X/*
X *      Usage:  utree.prlist [-Vhr] [-d dev] [-f fnt] [i ind] [-s siz] listfile
X *      Options:        -V      Display program version.
X *                      -T dev  or
X *                      -d dev  Output for device dev.
X *                              Supported devices are:
X *                              ascii   ascii meta characters.
X *                              850     printers with ibm pc850 charset.
X *                              ps      postscript.
X *                              term    terminal (default).
X *                      -f fnt  Font to use (postscript only)
X *                      -h      Display usage and help.
X *                      -i ind  Set tree indention to ind.
X *                      -s siz  Font size (postscript only)
X *      Remarks:        Formatted utree tree list files can be created
X *                      with the write-tree command (o) and option list (l)
X *                      from tree-screen.
X *      Directory:      /usr/local/bin
X *      Environment:    $TERM
X *      Defines:        AIX     for IBM AIX systems
X *                      BSD     for BSD systems
X *                      XENIX   for XENIX systems
X *      Libraries:      -lm -lcurses (SYSV), -ltermcap or -ltermlib (BSD)
X */
X
static char usage[] = "@(#) Usage: utree.prlist [-Vr][-d dev][-f fnt][-i ind][-s siz] listfile";
static char pvers[] = "UTREE 3.03-um";
X
X#include <stdio.h>
X#include <signal.h>
X
X#define MAXLEN  512             /* Buffer length                */
X#define DEFIND  6               /* Default indention            */
X#define MININD  3               /* Minimal indention            */
X#define MAXIND  9               /* Maxinal indention            */
X#define OPTIONS "T:Vd:f:hi:rs:" /* Optionstring for getopt()    */
X#define UNULL   ((unsigned char *) 0)
X
static char *pname;
static char *title = "Tree";
static char root[MAXLEN];
X
X/* The generic graphical character set                          */
static unsigned char *grafset = UNULL;
X#define H grafset[0]            /* Horizontal bar               */
X#define V grafset[1]            /* Vertical bar                 */
X#define U grafset[2]            /* Upper left corner            */
X#define L grafset[3]            /* Lower left corner            */
X#define T grafset[4]            /* Left tee                     */
X#define I grafset[5]            /* Indention                    */
X#define S grafset[6]            /* Space                        */
X
X/* The fix coded character sets for ascii, acsc, ibm and ps     */
X/*                                    H   V   U   L   T   I   S */
static unsigned char asciiset[7] = { '-','|','+','+','|',' ',' ' };
static unsigned char acscset[7]  = { '-','|','+','+','|',' ',' ' };
static unsigned char ibmset[7]   = { 196,179,218,192,195,' ',' ' };
static unsigned char psset[7]    = { 'H','V','U','L','T','I','S' };
X
static int indent = DEFIND;     /* Indention                    */
static int rflag  = 1;          /* Print rootdirectory flag     */
static int isps   = 0;          /* Postscript output            */
X
static unsigned char *acsc  = UNULL;    /* Alternate char set   */
static unsigned char *enacs = UNULL;    /* Enable alt char set  */
static unsigned char *smacs = UNULL;    /* Alt char set on      */
static unsigned char *rmacs = UNULL;    /* Alt char set off     */
X#define ACSCON  if(acsc && smacs) tputs(smacs, 1, putchar)
X#define ACSCOFF if(acsc && rmacs) tputs(rmacs, 1, putchar)
X#undef  putchar
X
X/* Postscript definitions and variables                         */
X#define PSFONT  "Courier-Bold"  /* Default postscript font      */
X#define PSSIZE   10.0           /* Default postscript font size */
X#define PSMIN    50.0           /* Lower y position             */
X#define PSMAX   780.0           /* Upper y position             */
X#define PSIND    85.0           /* Most left x position         */
X#define PSWID   475.0           /* Page header width            */
X#define PSEOF   (0x04)          /* C-d: EOF for postscript      */
static int psp = 0;             /* Page counter                 */
static double psy;              /* Current y position           */
static double pps = PSSIZE;     /* Font size                    */
static double pvs = PSSIZE+2;   /* Vertical space               */
static char *pft = PSFONT;      /* Font                         */
X
extern double atof();
X#ifdef  BSD
X#define strrchr rindex
extern char *rindex();
X#else   /* !BSD */
extern char *strrchr();
X#endif  /* BSD */
X
X/*
X *      Output one character
X */
static int putchar(c)
X  int c;
X{
X  putc((unsigned char) c, stdout);
X  return(c);
X
X} /* putchar() */
X
X/*
X *      Catch signals SIGINT, SIGQUIT and SIGTERM
X */
static int catchsig(sig)
X  int sig;
X{
X  ACSCOFF;
X  if(sig == SIGQUIT)
X    abort();
X  exit(1);
X
X} /* catchsig() */
X
X/*
X *      Init terminal and graphical character set for terminal
X */
static void initterm(f)
X  int f;
X{
X  static char termbuf[1024];
X  char termcap[1024], *term;
X  char *tp = termbuf;
X  extern char *getenv();
X  extern unsigned char *tgetstr();
X
X  grafset = asciiset;           /* Default character set */
X  if(f && !isatty(fileno(stdout)))
X    return;
X  else if((term = getenv("TERM")) && tgetent(termcap, term) > 0) {
X#ifdef  AIX
X    if(acsc = tgetstr("bx", &tp)) {
X      grafset = acscset;
X      if( !(smacs = tgetstr("as", &tp)))
X     smacs = tgetstr("f1", &tp);     /* AIX 3.2: font1 instead of smacs */
X      if( !(rmacs = tgetstr("ae", &tp)))
X     rmacs = tgetstr("f0", &tp);     /* AIX 3.2: font0 instead of rmacs */
X      U = acsc[0];
X      L = acsc[5];
X      H = acsc[1];
X      T = acsc[9];
X      V = acsc[3];
X    }
X#else   /* !AIX */
X    if(acsc = tgetstr("ac", &tp)) {
X      grafset = acscset;
X      if(enacs = tgetstr("eA", &tp))
X       tputs(enacs, 1, putchar);
X      smacs = tgetstr("as", &tp);
X      rmacs = tgetstr("ae", &tp);
X      do
X       switch(*acsc) {
X         default:              /* Skip */
X           ++acsc; break;
X         case 'l':             /* Upper left corner */
X           U = *++acsc; break;
X         case 'm':             /* Lower left corner */
X           L = *++acsc; break;
X         case 'q':             /* Horizontal bar */
X           H = *++acsc; break;
X         case 't':             /* Left tee */
X           T = *++acsc; break;
X         case 'x':             /* Vertical bar */
X           V = *++acsc; break;
X       }
X      while(*acsc && *++acsc);
X    }
X# ifdef XENIX
X    else {
X      unsigned char *gp;
X
X      grafset = acscset;
X      acsc  = acscset;          /* Use as flag */
X      smacs = tgetstr("GS", &tp);
X      rmacs = tgetstr("GE", &tp);
X      if(gp = tgetstr("G2", &tp))
X       U = *gp;                /* Upper left corner */
X      if(gp = tgetstr("G3", &tp))
X       L = *gp;                /* Lower left corner */
X      if(gp = tgetstr("GH", &tp))
X       H = *gp;                /* Horizontal bar */
X      if(gp = tgetstr("GR", &tp))
X       T = *gp;                /* Left tee */
X      if(gp = tgetstr("GV", &tp))
X       V = *gp;                /* Vertical bar */
X    }
X# endif /* XENIX */
X#endif  /* AIX */
X    signal(SIGINT,  catchsig);
X    signal(SIGQUIT, catchsig);
X    signal(SIGTERM, catchsig);
X  }
X
X} /* initterm() */
X
X/*
X *      Select graphical character set for device d
X */
static int initgraf(d)
X  char *d;
X{
X  switch(*d) {
X    default:                    /* Bad device */
X      return(0);
X    case 'a':                   /* ASCII meta characters */
X      grafset = asciiset;
X      break;
X    case '8':                   /* IBM PC850 character set */
X      grafset = ibmset;
X      break;
X    case 'p':                   /* Postscript */
X      grafset = psset;
X      ++isps;
X      break;
X    case 't':
X      initterm(0);              /* Terminal */
X      break;
X  }
X  return(1);
X
X} /* initgraf() */
X
X/*
X *      Write out graphic character c from current character set
X */
static void putgraf(c)
X  int c;
X{
X  switch(c) {
X    case 'I':                   /* Indention */
X      putchar(I); break;
X    case 'S':                   /* Space */
X      putchar(S); break;
X    default:                    /* Graphical characters */
X      ACSCON;
X      switch(c) {
X       case 'H':               /* Horizontal bar */
X         putchar(H); break;
X       case 'L':               /* Lower left corner */
X         putchar(L); break;
X       case 'T':               /* Left tee */
X         putchar(T); break;
X       case 'U':               /* Upper left corner */
X         putchar(U); break;
X       case 'V':               /* Vertical bar */
X         putchar(V); break;
X      }
X      ACSCOFF;
X      break;
X  }
X  if(isps)
X    putchar(' ');
X
X} /* putgraf() */
X
X/*
X *      Write header lines
X */
static void putheader()
X{
X  if(isps) {
X    printf("%%!PS-Adobe-2.0\n");
X    printf("%%%%Creator: %s\n", &sccsid[5]);
X    printf("%%%%Title: %s: %s\n", title, root);
X    printf("%%%%DocumentFont: %s\n", pft);
X    printf("%%%%Pages: (atend)\n");
X    printf("%% Copyright (c) 1991 by Peter Klingebiel & UNIX Magazin Muenchen\n");
X    printf("%%%%EndComments\n");
X    printf("%% Variables for font, fontsize, vertical space and indentions\n");
X    printf("/ft /%s def\n", pft);
X    printf("/ps %3.2lf def\n", pps);
X    printf("/vs %3.2lf def\n", pvs);
X    printf("/s1 %3.2lf def\n", pvs / 6.0);
X    printf("/s2 %3.2lf def\n", pvs / 3.0);
X    printf("/s3 %3.2lf def\n", pvs * 2.0 / 3.0);
X    printf("%% Procedures for drawing and printing\n");
X    if(rflag) {
X      printf("/Z { gsave 0.95 setgray\n");
X      printf("     0 ps s3 add     rlineto  %3.2lf 0 rlineto\n", PSWID);
X      printf("     0 ps s3 add neg rlineto -%3.2lf 0 rlineto\n", PSWID);
X      printf("     fill grestore s2 s2 rmoveto\n");
X      printf("     gsave show grestore %3.2lf setlinewidth } bind def\n", pps / 20.0);
X    }
X    else
X      printf("/Z { %3.2lf setlinewidth } bind def\n", pps / 20.0);
X    printf("/F { findfont exch scalefont setfont } bind def\n");
X    printf("/P { gsave s1 s1 rmoveto show grestore stroke } bind def\n");
X    printf("/G { moveto } bind def\n");
X    printf("/U { 0 s2 rlineto s2 0 rlineto 0 s2 neg rmoveto } bind def\n");
X    printf("/L { 0 vs rmoveto 0 s3 neg rlineto s2 0 rlineto 0 s2 neg rmoveto } bind def\n");
X    printf("/V { 0 vs rlineto s2 vs neg rmoveto } bind def\n");
X    printf("/T { 0 vs rlineto 0 s3 neg rmoveto s2 0 rlineto 0 s2 neg rmoveto } bind def\n");
X    printf("/S { s2 0 rmoveto } bind def\n");
X    printf("/I { s2 %d mul 0 rmoveto } bind def\n", indent);
X    printf("/H { 0 s2 rmoveto s2 %d mul 0 rlineto 0 s2 neg rmoveto } bind def\n", indent-1);
X    printf("%%%%EndProlog\n");
X    printf("ps ft F\n");
X  }
X  else if(rflag)
X    printf("\n%s  %s: %s\n\n", pvers, title, root);
X
X} /* putheader() */
X
X/*
X *      Write trailing lines
X */
static void puttrailer()
X{
X  if(isps) {
X    printf("showpage\n");
X    printf("%%%%Trailer\n");
X    printf("%%%%Pages: %d\n", psp);
X    putchar(PSEOF);
X  }
X
X} /* puttrailer() */
X
X/*
X *      Scan one entry line and write out
X */
static void putentry(s)
X  char *s;
X{
X  int c, i;
X
X  if(isps) {
X    if(psp == 0 || psy < PSMIN) {
X      if(psp)
X       printf("showpage\n");
X      printf("%%%%Page %d\n", ++psp);
X      if(rflag) {
X       printf("%3.2lf %3.2lf G (%s  %s    Page %d) Z\n", PSIND, PSMAX, title, root, psp);
X       psy = PSMAX - 2.0 * pvs;
X      }
X      else {
X       printf("Z\n");
X       psy = PSMAX;
X      }
X    }
X    printf("%3.2lf %3.2lf G ", PSIND, psy);
X    psy -= pvs;
X  }
X  else
X    putgraf(*s++);              /* First column */
X  while(c = *s++)
X    switch(c) {
X      default:                  /* Bad format */
X       return;
X      case 'H':                 /* Horizontal bar + file name */
X       if(isps) {
X         putgraf(c);
X         printf("(%s) P\n", s);
X       }
X       else {
X         for(i = 1; i < indent; i++)
X           putgraf(c);
X         printf(" %s\n", s);
X       }
X       return;
X      case 'I':                 /* Indention */
X       if(isps)
X         putgraf(c);
X       else
X         for(i = 0; i < indent; i++)
X           putgraf(c);
X       break;
X      case 'S':                 /* One space */
X      case 'L':                 /* Lower left corner */
X      case 'T':                 /* Left tee */
X      case 'U':                 /* Upper left corner */
X      case 'V':                 /* Vertical bar */
X       putgraf(c);
X       break;
X    }
X
X} /* putentry() */
X
X/*
X *      Main routine
X */
main(argc, argv)
X  int argc;
X  char **argv;
X{
X  char line[MAXLEN], *list;
X  FILE *fp;
X  int c;
X  extern char *optarg;          /* From getopt() */
X  extern int optind;
X
X  /* Get programs name */
X  if(pname = strrchr(argv[0], '/'))
X    ++pname;
X  else
X    pname = argv[0];
X
X  /* Parse and check command line options */
X  while((c = getopt(argc, argv, OPTIONS)) != EOF) {
X    switch(c) {
X      default:                  /* Bad option */
X       fprintf(stderr, "%s\n", &sccsid[5]);
X       exit(1);
X      case 'V':                 /* Version */
X       fprintf(stderr, "%s\n", &sccsid[5]);
X       exit(0);
X      case 'h':                 /* Some help */
X       fprintf(stderr, "%s\n", &usage[5]);
X       fprintf(stderr, "\t-T dev\t\tOutput for device dev\n");
X       fprintf(stderr, "\t-V\t\tDisplay program version\n");
X       fprintf(stderr, "\t-d dev\t\tOutput for device dev\n");
X       fprintf(stderr, "\t-f fnt\t\tUse font fnt (ps only, default: Courier-Bold)\n");
X       fprintf(stderr, "\t-h\t\tDisplay some help\n");
X       fprintf(stderr, "\t-i ind\t\tSet tree indention to ind (3..9)\n");
X       fprintf(stderr, "\t-s siz\t\tUse font size siz (ps only, default: 10)\n");
X       fprintf(stderr, "\t\t\tCurrently supported output devices are:\n");
X       fprintf(stderr, "\t\t\tascii\tAscii meta graphic characters\n");
X       fprintf(stderr, "\t\t\t850\tPrinters using IBM PC850 character set\n");
X       fprintf(stderr, "\t\t\tps\tPostscript\n");
X       fprintf(stderr, "\t\t\tterm\tTerminal (default)\n");
X       exit(0);
X      case 'T':                 /* Device for graphical character set */
X      case 'd':
X       if(initgraf(optarg))
X         break;
X       fprintf(stderr, "%s: device not supported -- %s\n", pname, optarg);
X       exit(1);
X      case 'r':                 /* Suppress pathname of rootdirectory */
X       rflag = 0;
X       break;
X      case 'i':                 /* Indention */
X       if((indent = atoi(optarg)) < MININD || indent > MAXIND) {
X         fprintf(stderr, "%s: bad indention -- %d\n", pname, indent);
X         exit(1);
X       }
X       break;
X     case 'f':                  /* Postscript font */
X       pft = optarg;
X       break;
X     case 's':                  /* Font size */
X       pps = atof(optarg);
X       pvs = pps + 2.0;
X       break;
X    }
X  }
X
X  /* Get and tree list file name */
X  if((argc - optind) != 1) {
X    fprintf(stderr, "%s\n", &usage[5]);
X    exit(1);
X  }
X  else
X    list = argv[optind];
X
X  /* Open directory tree list file */
X  if( !(fp = fopen(list, "r"))) {
X    fprintf(stderr, "%s: Cannot open list file %s\n", pname, list);
X    exit(1);
X  }
X
X  /* Init default graphical character set if needed */
X  if(grafset == UNULL)
X    initterm(1);
X
X  /* Read, scan and write tree list file line by line */
X  while(fgets(line, sizeof(line), fp)) {
X    line[strlen(line)-1] = '\0';
X    switch(c = line[0]) {
X      default:                  /* Ignore */
X       break;
X      case 'R':                 /* Pathname of rootdirectory */
X       strncpy(root, &line[1], sizeof(root));
X       putheader();
X       break;
X      case 'H':                 /* Valid tree list entry */
X      case 'L':
X      case 'U':
X      case 'V':
X       putentry(line);
X       break;
X    }
X  }
X  fclose(fp);
X
X  /* Write trailer and exit */
X  puttrailer();
X  exit(0);
X
X} /* main() */
X
END_OF_FILE
if test 16227 -ne `wc -c <'src/utree.prlist.c'`; then
    echo shar: \"'src/utree.prlist.c'\" unpacked with wrong size!
fi
# end of 'src/utree.prlist.c'
fi
echo shar: End of archive 4 \(of 8\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
