Newsgroups: comp.sources.unix
From: robert@olsen.ch (Robert Ward)
Subject: v26i024: sps3 - show process status, Part01/03
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: robert@olsen.ch (Robert Ward)
Posting-Number: Volume 26, Issue 24
Archive-Name: sps3/part01

[ I've been using various versions of "sps" for many years.  It is so much
  better than the "ps" you got with your system (no matter what system), that
  you will wonder how you ever got along without it.  It builds and installs
  trivially on my Ultrix systems, which according to the README are the least
  supported.  In other words, this thing is on greased skids.  Use it!  --vix ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  BUG-libkvm MANIFEST Makefile.4.1 Makefile.4.2 Makefile.4.3
#   Makefile.4.3+NFS Makefile.sun.2.0 Makefile.sun.3.0
#   Makefile.sun.3.2 Makefile.sun.4.0 Makefile.sun.4.0+386i
#   Makefile.sun.4.1 Makefile.sun4.3.2 Makefile.ultrix.2.0
#   Makefile.ultrix.3.0 Makefile.ultrix.4.0 README RELEASENOTES
#   filecount.c findtty.c flags.h flagsetup.c globals1.c hashuid.c
#   initialise.c mktree.c percentmem.c prcmd.c prcpu.c prheader.c
#   printall.c prsummary.c readstatus.c selectproc.c selecttty.c
#   termwidth.c vmstat.c
# Wrapped by vixie@cognition.pa.dec.com on Sat May  9 22:30:50 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'BUG-libkvm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BUG-libkvm'\"
else
echo shar: Extracting \"'BUG-libkvm'\" \(1656 characters\)
sed "s/^X//" >'BUG-libkvm' <<'END_OF_FILE'
There is a bug in kvm_getcmd(3) which occurs when the arguments for a command
contain an '=', or if an '=' in the environment is removed.  In user space,
command arguments are laid out like this:
X
a r g 0 '\0' a r g 1 '\0' ... e n v 1 = e n v '\0' e n v 2 = e n v ...
X
The only way to tell where the arguments end and the environment begins is to
look for arguments which contain '=', or environment strings which don't.  Most
programs used to use the first approach.  The libkvm library uses the latter,
and gets it wrong if it sees a '=' in any strings before the last string
which doesn't have one.  The korn shell nulls out some '=' in it's environment,
and if you have it, it's the most noticable tickler of this bug.  But even if
you don't, you can tickle it with "vi a=b c".
X
Here's the fix.  You could probably patch the binary to ignore the
X"&& (argd.cnt == 0)" test, which will cause slightly incorrect results,
but ones a bit closer to the truth.  Just search for "\0=" in the
library, and look past it a bit.
X
X*** /tmp/,RCSt1a01687	Wed Sep 28 01:50:36 1988
X--- kvmgetcmd.c	Mon Aug 29 23:23:43 1988
X***************
X*** 141,150 ****
X  			if (*cp == '=')
X  				eqseen++;
X  			if (*cp-- == '\0') {
X! 				if (eqseen && (argd.cnt == 0)) {
X  					envd.cnt++;
X  					envd.sp = Uvaddr(cp+2);
X  					eqseen = 0;
X  				} else {
X  					argd.cnt++;
X  				}
X--- 141,154 ----
X  			if (*cp == '=')
X  				eqseen++;
X  			if (*cp-- == '\0') {
X! 				if (eqseen) {
X  					envd.cnt++;
X  					envd.sp = Uvaddr(cp+2);
X  					eqseen = 0;
X+ 					if (argd.cnt != 0) {
X+ 						envd.cnt += argd.cnt;
X+ 						argd.cnt = 0;
X+ 					}
X  				} else {
X  					argd.cnt++;
X  				}
END_OF_FILE
if test 1656 -ne `wc -c <'BUG-libkvm'`; then
    echo shar: \"'BUG-libkvm'\" unpacked with wrong size!
fi
# end of 'BUG-libkvm'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1708 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X BUG-libkvm                 1	
X MANIFEST                   1	
X Makefile.4.1               1	
X Makefile.4.2               1	
X Makefile.4.3               1	
X Makefile.4.3+NFS           1	
X Makefile.sun.2.0           1	
X Makefile.sun.3.0           1	
X Makefile.sun.3.2           1	
X Makefile.sun.4.0           1	
X Makefile.sun.4.0+386i      1	
X Makefile.sun.4.1           1	
X Makefile.sun4.3.2          1	
X Makefile.ultrix.2.0        1	
X Makefile.ultrix.3.0        1	
X Makefile.ultrix.4.0        1	
X README                     1	
X RELEASENOTES               1	
X filecount.c                1	
X findtty.c                  1	
X flagdecode.c               2	
X flags.h                    1	
X flagsetup.c                1	
X getcmd.c                   3	
X getupage.c                 2	
X globals1.c                 1	
X globals2.c                 2	
X hashuid.c                  1	
X initialise.c               1	
X initsymbols.c              2	
X inittty.c                  2	
X main.c                     2	
X mktree.c                   1	
X needed.c                   2	
X openfiles.c                2	
X percentmem.c               1	
X prcmd.c                    1	
X prcpu.c                    1	
X prheader.c                 1	
X printall.c                 1	
X printproc.c                3	
X prsummary.c                1	
X readstatus.c               1	
X selectproc.c               1	
X selecttty.c                1	
X sps.1                      3	
X sps.h                      2	
X stream.c                   2	
X termwidth.c                1	
X ttystatus.c                2	
X vmstat.c                   1	
X waitingfor.c               3	
END_OF_FILE
if test 1708 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile.4.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.4.1'\"
else
echo shar: Extracting \"'Makefile.4.1'\" \(882 characters\)
sed "s/^X//" >'Makefile.4.1' <<'END_OF_FILE'
X# Makefile for SPS (4.1BSD UNIX Version)
X
PROG    =       sps
OBJS    =       filecount.o findtty.o flagdecode.o flagsetup.o \
X		getcmd.o getupage.o globals1.o globals2.o hashuid.o \
X		initialise.o initsymbols.o inittty.o main.o mktree.o \
X		needed.o openfiles.o percentmem.o prcmd.o prcpu.o \
X		prheader.o printall.o printproc.o prsummary.o readstatus.o \
X		selectproc.o selecttty.o termwidth.o ttystatus.o waitingfor.o
X
INCS    =       sps.h
LIBS    =       -ltermlib
CFLAGS  =       -I/usr/src/sys -DCHAOS
X
all:            $(PROG)
X.c.o:
X		cc $(CFLAGS) -c -O -R $<
globals1.o waitingfor.o:
X		cc $(CFLAGS) -c -O $<
X
X$(OBJS):        $(INCS)
X
X$(PROG):        $(OBJS)
X		cc -o $@ $(OBJS) $(LIBS)
X
install:        $(PROG)
X		strip $(PROG)
X		mv $(PROG) /bin/$(PROG)
X		/etc/chown root /bin/$(PROG)
X		chmod 4711 /bin/$(PROG)
X
lint:
X		lint -x -b $(CFLAGS) *.c
clean:
X		rm -f $(OBJS) $(PROG)
END_OF_FILE
if test 882 -ne `wc -c <'Makefile.4.1'`; then
    echo shar: \"'Makefile.4.1'\" unpacked with wrong size!
fi
# end of 'Makefile.4.1'
fi
if test -f 'Makefile.4.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.4.2'\"
else
echo shar: Extracting \"'Makefile.4.2'\" \(977 characters\)
sed "s/^X//" >'Makefile.4.2' <<'END_OF_FILE'
X# Makefile for SPS (Vax 4.2BSD and Ultrix1.2 UNIX Version)
X
PROG    =       sps
OBJS    =       filecount.o findtty.o flagdecode.o flagsetup.o \
X		getcmd.o getupage.o globals1.o globals2.o hashuid.o \
X		initialise.o initsymbols.o inittty.o main.o mktree.o \
X		needed.o openfiles.o percentmem.o prcmd.o prcpu.o \
X		prheader.o printall.o printproc.o prsummary.o readstatus.o \
X		selectproc.o selecttty.o termwidth.o ttystatus.o waitingfor.o
INCS    =       sps.h
CC      =       cc
CFLAGS  =       -DBSD42 -I/sys
LIBS    =       -ltermlib
DIRINSTALL =	/bin
X
all:		    $(PROG)
X.c.o:
X		$(CC) $(CFLAGS) -c -O -R $<
X	
globals1.o waitingfor.o:
X		$(CC) $(CFLAGS) -c -O $<
X
X$(OBJS):		$(INCS)
X
X$(PROG):		$(OBJS)
X		$(CC) -o $@ $(OBJS) $(LIBS)
X
install:		$(PROG)
X		strip $(PROG)
X		mv $(PROG) $(DIRINSTALL)/$(PROG)
X		/etc/chown root $(DIRINSTALL)/$(PROG)
X		chgrp kmem $(DIRINSTALL)/$(PROG)
X		chmod 2755 $(DIRINSTALL)/$(PROG)
X
lint:
X		lint -x -b $(CFLAGS) *.c
clean:
X		rm -f $(OBJS) $(PROG)
END_OF_FILE
if test 977 -ne `wc -c <'Makefile.4.2'`; then
    echo shar: \"'Makefile.4.2'\" unpacked with wrong size!
fi
# end of 'Makefile.4.2'
fi
if test -f 'Makefile.4.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.4.3'\"
else
echo shar: Extracting \"'Makefile.4.3'\" \(966 characters\)
sed "s/^X//" >'Makefile.4.3' <<'END_OF_FILE'
X# Makefile for SPS (Vax 4.3BSD Version)
X
PROG    =       sps
OBJS    =       filecount.o findtty.o flagdecode.o flagsetup.o \
X		getcmd.o getupage.o globals1.o globals2.o hashuid.o \
X		initialise.o initsymbols.o inittty.o main.o mktree.o \
X		needed.o openfiles.o percentmem.o prcmd.o prcpu.o \
X		prheader.o printall.o printproc.o prsummary.o readstatus.o \
X		selectproc.o selecttty.o termwidth.o ttystatus.o waitingfor.o
INCS    =       sps.h
CC      =       cc
CFLAGS  =       -DBSD42 -DBSD43 -I/sys
LIBS    =       -ltermlib
DIRINSTALL =	/bin
X
all:		    $(PROG)
X.c.o:
X		$(CC) $(CFLAGS) -c -O -R $<
X	
globals1.o waitingfor.o:
X		$(CC) $(CFLAGS) -c -O $<
X
X$(OBJS):		$(INCS)
X
X$(PROG):		$(OBJS)
X		$(CC) -o $@ $(OBJS) $(LIBS)
X
install:		$(PROG)
X		strip $(PROG)
X		mv $(PROG) $(DIRINSTALL)/$(PROG)
X		/etc/chown root $(DIRINSTALL)/$(PROG)
X		chgrp kmem $(DIRINSTALL)/$(PROG)
X		chmod 2755 $(DIRINSTALL)/$(PROG)
X
lint:
X		lint -x -b $(CFLAGS) *.c
clean:
X		rm -f $(OBJS) $(PROG)
END_OF_FILE
if test 966 -ne `wc -c <'Makefile.4.3'`; then
    echo shar: \"'Makefile.4.3'\" unpacked with wrong size!
fi
# end of 'Makefile.4.3'
fi
if test -f 'Makefile.4.3+NFS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.4.3+NFS'\"
else
echo shar: Extracting \"'Makefile.4.3+NFS'\" \(976 characters\)
sed "s/^X//" >'Makefile.4.3+NFS' <<'END_OF_FILE'
X# Makefile for SPS (Vax 4.3BSD+NFS Version)
X
PROG    =       sps
OBJS    =       filecount.o findtty.o flagdecode.o flagsetup.o \
X		getcmd.o getupage.o globals1.o globals2.o hashuid.o \
X		initialise.o initsymbols.o inittty.o main.o mktree.o \
X		needed.o openfiles.o percentmem.o prcmd.o prcpu.o \
X		prheader.o printall.o printproc.o prsummary.o readstatus.o \
X		selectproc.o selecttty.o termwidth.o ttystatus.o waitingfor.o
INCS    =       sps.h
CC      =       cc
CFLAGS  =       -DBSD42 -DBSD43 -DNFS -I/sys
LIBS    =       -ltermlib
DIRINSTALL =	/bin
X
all:		    $(PROG)
X.c.o:
X		$(CC) $(CFLAGS) -c -O -R $<
X	
globals1.o waitingfor.o:
X		$(CC) $(CFLAGS) -c -O $<
X
X$(OBJS):		$(INCS)
X
X$(PROG):		$(OBJS)
X		$(CC) -o $@ $(OBJS) $(LIBS)
X
install:		$(PROG)
X		strip $(PROG)
X		mv $(PROG) $(DIRINSTALL)/$(PROG)
X		/etc/chown root $(DIRINSTALL)/$(PROG)
X		chgrp kmem $(DIRINSTALL)/$(PROG)
X		chmod 2755 $(DIRINSTALL)/$(PROG)
X
lint:
X		lint -x -b $(CFLAGS) *.c
clean:
X		rm -f $(OBJS) $(PROG)
END_OF_FILE
if test 976 -ne `wc -c <'Makefile.4.3+NFS'`; then
    echo shar: \"'Makefile.4.3+NFS'\" unpacked with wrong size!
fi
# end of 'Makefile.4.3+NFS'
fi
if test -f 'Makefile.sun.2.0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.sun.2.0'\"
else
echo shar: Extracting \"'Makefile.sun.2.0'\" \(1009 characters\)
sed "s/^X//" >'Makefile.sun.2.0' <<'END_OF_FILE'
X# Makefile for SPS (Sun-2, Sun UNIX 4.2 Release 2.x Version)
X
PROG    =       sps
OBJS    =       filecount.o findtty.o flagdecode.o flagsetup.o \
X		getcmd.o getupage.o globals1.o globals2.o hashuid.o \
X		initialise.o initsymbols.o inittty.o main.o mktree.o \
X		needed.o openfiles.o percentmem.o prcmd.o prcpu.o \
X		prheader.o printall.o printproc.o prsummary.o readstatus.o \
X		selectproc.o selecttty.o termwidth.o ttystatus.o waitingfor.o
INCS    =       sps.h
CC      =       cc
CFLAGS  =       -DSUN -DBSD42 -DNFS -DNOQUOTA -I/sys
LIBS    =       -ltermlib
DIRINSTALL	= /bin
X
all:		    $(PROG)
X.c.o:
X		$(CC) $(CFLAGS) -c -O -R $<
X	
globals1.o waitingfor.o:
X		$(CC) $(CFLAGS) -c -O $<
X
X$(OBJS):		$(INCS)
X
X$(PROG):		$(OBJS)
X		$(CC) -o $@ $(OBJS) $(LIBS)
X
install:		$(PROG)
X		strip $(PROG)
X		mv $(PROG) $(DIRINSTALL)/$(PROG)
X		/etc/chown root $(DIRINSTALL)/$(PROG)
X		chgrp kmem $(DIRINSTALL)/$(PROG)
X		chmod 2755 $(DIRINSTALL)/$(PROG)
X
lint:
X		lint -x -b $(CFLAGS) *.c $(LIBS)
clean:
X		rm -f $(OBJS) $(PROG)
END_OF_FILE
if test 1009 -ne `wc -c <'Makefile.sun.2.0'`; then
    echo shar: \"'Makefile.sun.2.0'\" unpacked with wrong size!
fi
# end of 'Makefile.sun.2.0'
fi
if test -f 'Makefile.sun.3.0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.sun.3.0'\"
else
echo shar: Extracting \"'Makefile.sun.3.0'\" \(1009 characters\)
sed "s/^X//" >'Makefile.sun.3.0' <<'END_OF_FILE'
X# Makefile for SPS (Sun-2 and Sun-3, Sun UNIX 4.2 Release 3.0 Version)
X
PROG    =       sps
OBJS    =       filecount.o findtty.o flagdecode.o flagsetup.o \
X		getcmd.o getupage.o globals1.o globals2.o hashuid.o \
X		initialise.o initsymbols.o inittty.o main.o mktree.o \
X		needed.o openfiles.o percentmem.o prcmd.o prcpu.o \
X		prheader.o printall.o printproc.o prsummary.o readstatus.o \
X		selectproc.o selecttty.o termwidth.o ttystatus.o waitingfor.o
INCS    =       sps.h
CC      =       cc
CFLAGS  =       -DSUN -DBSD42 -DNFS -I/sys
LIBS    =       -ltermlib
DIRINSTALL	= /bin
X
all:		    $(PROG)
X.c.o:
X		$(CC) $(CFLAGS) -c -O -R $<
X	
globals1.o waitingfor.o:
X		$(CC) $(CFLAGS) -c -O $<
X
X$(OBJS):		$(INCS)
X
X$(PROG):		$(OBJS)
X		$(CC) -o $@ $(OBJS) $(LIBS)
X
install:		$(PROG)
X		strip $(PROG)
X		mv $(PROG) $(DIRINSTALL)/$(PROG)
X		/etc/chown root $(DIRINSTALL)/$(PROG)
X		chgrp kmem $(DIRINSTALL)/$(PROG)
X		chmod 2755 $(DIRINSTALL)/$(PROG)
X
lint:
X		lint -x -b $(CFLAGS) *.c $(LIBS)
clean:
X		rm -f $(OBJS) $(PROG)
END_OF_FILE
if test 1009 -ne `wc -c <'Makefile.sun.3.0'`; then
    echo shar: \"'Makefile.sun.3.0'\" unpacked with wrong size!
fi
# end of 'Makefile.sun.3.0'
fi
if test -f 'Makefile.sun.3.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.sun.3.2'\"
else
echo shar: Extracting \"'Makefile.sun.3.2'\" \(1019 characters\)
sed "s/^X//" >'Makefile.sun.3.2' <<'END_OF_FILE'
X# Makefile for SPS (Sun-2 and Sun-3, Sun UNIX 4.2 Release 3.x Version)
X
PROG    =       sps
OBJS    =       filecount.o findtty.o flagdecode.o flagsetup.o \
X		getcmd.o getupage.o globals1.o globals2.o hashuid.o \
X		initialise.o initsymbols.o inittty.o main.o mktree.o \
X		needed.o openfiles.o percentmem.o prcmd.o prcpu.o \
X		prheader.o printall.o printproc.o prsummary.o readstatus.o \
X		selectproc.o selecttty.o termwidth.o ttystatus.o waitingfor.o
INCS    =       sps.h
CC      =       cc
CFLAGS  =       -DSUN -DBSD42 -DNFS -DVPRINTF -I/sys
LIBS    =       -ltermlib
DIRINSTALL	= /bin
X
all:		    $(PROG)
X.c.o:
X		$(CC) $(CFLAGS) -c -O -R $<
X	
globals1.o waitingfor.o:
X		$(CC) $(CFLAGS) -c -O $<
X
X$(OBJS):		$(INCS)
X
X$(PROG):		$(OBJS)
X		$(CC) -o $@ $(OBJS) $(LIBS)
X
install:		$(PROG)
X		strip $(PROG)
X		mv $(PROG) $(DIRINSTALL)/$(PROG)
X		/etc/chown root $(DIRINSTALL)/$(PROG)
X		chgrp kmem $(DIRINSTALL)/$(PROG)
X		chmod 2755 $(DIRINSTALL)/$(PROG)
X
lint:
X		lint -x -b $(CFLAGS) *.c $(LIBS)
clean:
X		rm -f $(OBJS) $(PROG)
END_OF_FILE
if test 1019 -ne `wc -c <'Makefile.sun.3.2'`; then
    echo shar: \"'Makefile.sun.3.2'\" unpacked with wrong size!
fi
# end of 'Makefile.sun.3.2'
fi
if test -f 'Makefile.sun.4.0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.sun.4.0'\"
else
echo shar: Extracting \"'Makefile.sun.4.0'\" \(1134 characters\)
sed "s/^X//" >'Makefile.sun.4.0' <<'END_OF_FILE'
X# Makefile for SPS (Sun-2, Sun-3 and Sun-4, SunOS 4.0 Version)
X
PROG    =       sps
OBJS    =       filecount.o findtty.o flagdecode.o flagsetup.o \
X		getcmd.o getupage.o globals1.o globals2.o hashuid.o \
X		initialise.o initsymbols.o inittty.o main.o mktree.o \
X		needed.o openfiles.o percentmem.o prcmd.o prcpu.o \
X		prheader.o printall.o printproc.o prsummary.o readstatus.o \
X		selectproc.o selecttty.o stream.o termwidth.o ttystatus.o \
X		vmstat.o waitingfor.o
INCS    =       sps.h
CC      =       cc
CFLAGS  =       -DSUN -DBSD42 -DNFS -DVPRINTF -DKVM -DSUNOS40 -Isys
LIBS    =       -ltermlib -lkvm
DIRINSTALL	= /usr/kvm
X
all:		    $(PROG)
X.c.o:
X		$(CC) $(CFLAGS) -c -O -R $<
X	
globals1.o stream.o waitingfor.o:
X		$(CC) $(CFLAGS) -c -O $<
X
X$(OBJS):		sys $(INCS)
X
sys:
X		-mkdir sys
X		-ln -s /sys/* sys
X		-ln -s /sys/sys sys/h
X
X$(PROG):		$(OBJS)
X		$(CC) -o $@ $(OBJS) $(LIBS)
X
install:		$(PROG)
X		strip $(PROG)
X		mv $(PROG) $(DIRINSTALL)/$(PROG)
X		/etc/chown root $(DIRINSTALL)/$(PROG)
X		chgrp kmem $(DIRINSTALL)/$(PROG)
X		chmod 2755 $(DIRINSTALL)/$(PROG)
X
lint:
X		lint -x -b $(CFLAGS) *.c $(LIBS)
clean:
X		rm -f $(OBJS) $(PROG)
END_OF_FILE
if test 1134 -ne `wc -c <'Makefile.sun.4.0'`; then
    echo shar: \"'Makefile.sun.4.0'\" unpacked with wrong size!
fi
# end of 'Makefile.sun.4.0'
fi
if test -f 'Makefile.sun.4.0+386i' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.sun.4.0+386i'\"
else
echo shar: Extracting \"'Makefile.sun.4.0+386i'\" \(1144 characters\)
sed "s/^X//" >'Makefile.sun.4.0+386i' <<'END_OF_FILE'
X# Makefile for SPS (Sun-2, Sun-3 and Sun-4, SunOS 4.0 Version)
X
PROG    =       sps
OBJS    =       filecount.o findtty.o flagdecode.o flagsetup.o \
X		getcmd.o getupage.o globals1.o globals2.o hashuid.o \
X		initialise.o initsymbols.o inittty.o main.o mktree.o \
X		needed.o openfiles.o percentmem.o prcmd.o prcpu.o \
X		prheader.o printall.o printproc.o prsummary.o readstatus.o \
X		selectproc.o selecttty.o stream.o termwidth.o ttystatus.o \
X		vmstat.o waitingfor.o
INCS    =       sps.h
CC      =       cc
CFLAGS  =       -DSUN -DBSD42 -DNFS -DVPRINTF -DKVM -DSUNOS40 -DSUN386I -Isys
LIBS    =       -ltermlib -lkvm
DIRINSTALL	= /usr/kvm
X
all:		    $(PROG)
X.c.o:
X		$(CC) $(CFLAGS) -c -O -R $<
X	
globals1.o stream.o waitingfor.o:
X		$(CC) $(CFLAGS) -c -O $<
X
X$(OBJS):		sys $(INCS)
X
sys:
X		-mkdir sys
X		-ln -s /sys/* sys
X		-ln -s /sys/sys sys/h
X
X$(PROG):		$(OBJS)
X		$(CC) -o $@ $(OBJS) $(LIBS)
X
install:		$(PROG)
X		strip $(PROG)
X		mv $(PROG) $(DIRINSTALL)/$(PROG)
X		/etc/chown root $(DIRINSTALL)/$(PROG)
X		chgrp kmem $(DIRINSTALL)/$(PROG)
X		chmod 2755 $(DIRINSTALL)/$(PROG)
X
lint:
X		lint -x -b $(CFLAGS) *.c $(LIBS)
clean:
X		rm -f $(OBJS) $(PROG)
END_OF_FILE
if test 1144 -ne `wc -c <'Makefile.sun.4.0+386i'`; then
    echo shar: \"'Makefile.sun.4.0+386i'\" unpacked with wrong size!
fi
# end of 'Makefile.sun.4.0+386i'
fi
if test -f 'Makefile.sun.4.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.sun.4.1'\"
else
echo shar: Extracting \"'Makefile.sun.4.1'\" \(1210 characters\)
sed "s/^X//" >'Makefile.sun.4.1' <<'END_OF_FILE'
X# Makefile for SPS (Sun-2, Sun-3 and Sun-4, SunOS 4.1 Version)
X
PROG    =       sps
OBJS    =       filecount.o findtty.o flagdecode.o flagsetup.o \
X		getcmd.o getupage.o globals1.o globals2.o hashuid.o \
X		initialise.o initsymbols.o inittty.o main.o mktree.o \
X		needed.o openfiles.o percentmem.o prcmd.o prcpu.o \
X		prheader.o printall.o printproc.o prsummary.o readstatus.o \
X		selectproc.o selecttty.o stream.o termwidth.o ttystatus.o \
X		vmstat.o waitingfor.o
INCS    =       sps.h
CC      =       cc
X# You'll need both "-DSUNOS40" and "-DSUNOS41" for SunOS 4.1
CFLAGS  =	-DSUN -DBSD42 -DNFS -DVPRINTF -DKVM -DSUNOS40 -DSUNOS41 -Isys
LIBS    =       -ltermlib -lkvm
DIRINSTALL	= /usr/kvm
X
all:		    $(PROG)
X.c.o:
X		$(CC) $(CFLAGS) -c -O -R $<
X
globals1.o stream.o waitingfor.o filecount.o:
X		$(CC) $(CFLAGS) -c -O $<
X
X$(OBJS):		sys $(INCS)
X
sys:
X		-mkdir sys
X		-ln -s /sys/* sys
X		-ln -s /sys/sys sys/h
X
X$(PROG):		$(OBJS)
X		$(CC) -o $@ $(OBJS) $(LIBS)
X
install:		$(PROG)
X		strip $(PROG)
X		mv $(PROG) $(DIRINSTALL)/$(PROG)
X		/etc/chown root $(DIRINSTALL)/$(PROG)
X		chgrp kmem $(DIRINSTALL)/$(PROG)
X		chmod 2755 $(DIRINSTALL)/$(PROG)
X
lint:
X		lint -x -b $(CFLAGS) *.c $(LIBS)
clean:
X		rm -f $(OBJS) $(PROG)
END_OF_FILE
if test 1210 -ne `wc -c <'Makefile.sun.4.1'`; then
    echo shar: \"'Makefile.sun.4.1'\" unpacked with wrong size!
fi
# end of 'Makefile.sun.4.1'
fi
if test -f 'Makefile.sun4.3.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.sun4.3.2'\"
else
echo shar: Extracting \"'Makefile.sun4.3.2'\" \(1066 characters\)
sed "s/^X//" >'Makefile.sun4.3.2' <<'END_OF_FILE'
X# Makefile for SPS (Sun-4, SunOS Sys 4-3.2 Version)
X
PROG    =       sps
OBJS    =       filecount.o findtty.o flagdecode.o flagsetup.o \
X		getcmd.o getupage.o globals1.o globals2.o hashuid.o \
X		initialise.o initsymbols.o inittty.o main.o mktree.o \
X		needed.o openfiles.o percentmem.o prcmd.o prcpu.o \
X		prheader.o printall.o printproc.o prsummary.o readstatus.o \
X		selectproc.o selecttty.o termwidth.o ttystatus.o waitingfor.o
INCS    =       sps.h
CC      =       cc
CFLAGS  =       -DSUN -DBSD42 -DNFS -DVPRINTF -Isys
LIBS    =       -ltermlib
DIRINSTALL	= /bin
X
all:		    $(PROG)
X.c.o:
X		$(CC) $(CFLAGS) -c -O -R $<
X	
globals1.o waitingfor.o:
X		$(CC) $(CFLAGS) -c -O $<
X
X$(OBJS):		sys $(INCS)
X
sys:
X		-mkdir sys
X		-ln -s /sys/* sys
X		-ln -s /sys/sys sys/h
X
X$(PROG):		$(OBJS)
X		$(CC) -o $@ $(OBJS) $(LIBS)
X
install:		$(PROG)
X		strip $(PROG)
X		mv $(PROG) $(DIRINSTALL)/$(PROG)
X		/etc/chown root $(DIRINSTALL)/$(PROG)
X		chgrp kmem $(DIRINSTALL)/$(PROG)
X		chmod 2755 $(DIRINSTALL)/$(PROG)
X
lint:
X		lint -x -b $(CFLAGS) *.c $(LIBS)
clean:
X		rm -f $(OBJS) $(PROG)
END_OF_FILE
if test 1066 -ne `wc -c <'Makefile.sun4.3.2'`; then
    echo shar: \"'Makefile.sun4.3.2'\" unpacked with wrong size!
fi
# end of 'Makefile.sun4.3.2'
fi
if test -f 'Makefile.ultrix.2.0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.ultrix.2.0'\"
else
echo shar: Extracting \"'Makefile.ultrix.2.0'\" \(984 characters\)
sed "s/^X//" >'Makefile.ultrix.2.0' <<'END_OF_FILE'
X# Makefile for SPS (Ultrix 2.0 UNIX Version)
X
PROG    =       sps
OBJS    =       filecount.o findtty.o flagdecode.o flagsetup.o \
X		getcmd.o getupage.o globals1.o globals2.o hashuid.o \
X		initialise.o initsymbols.o inittty.o main.o mktree.o \
X		needed.o openfiles.o percentmem.o prcmd.o prcpu.o \
X		prheader.o printall.o printproc.o prsummary.o readstatus.o \
X		selectproc.o selecttty.o termwidth.o ttystatus.o waitingfor.o
INCS    =       sps.h
CC      =       cc
CFLAGS  =       -DBSD42 -DULTRIX20 -DVPRINTF -I/sys
LIBS    =       -ltermlib
DIRINSTALL =	/bin
X
all:		    $(PROG)
X.c.o:
X		$(CC) $(CFLAGS) -c -O -R $<
X	
globals1.o waitingfor.o:
X		$(CC) $(CFLAGS) -c -O $<
X
X$(OBJS):		$(INCS)
X
X$(PROG):		$(OBJS)
X		$(CC) -o $@ $(OBJS) $(LIBS)
X
install:		$(PROG)
X		strip $(PROG)
X		mv $(PROG) $(DIRINSTALL)/$(PROG)
X		/etc/chown root $(DIRINSTALL)/$(PROG)
X		chgrp kmem $(DIRINSTALL)/$(PROG)
X		chmod 2755 $(DIRINSTALL)/$(PROG)
X
lint:
X		lint -x -b $(CFLAGS) *.c
clean:
X		rm -f $(OBJS) $(PROG)
END_OF_FILE
if test 984 -ne `wc -c <'Makefile.ultrix.2.0'`; then
    echo shar: \"'Makefile.ultrix.2.0'\" unpacked with wrong size!
fi
# end of 'Makefile.ultrix.2.0'
fi
if test -f 'Makefile.ultrix.3.0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.ultrix.3.0'\"
else
echo shar: Extracting \"'Makefile.ultrix.3.0'\" \(995 characters\)
sed "s/^X//" >'Makefile.ultrix.3.0' <<'END_OF_FILE'
X# Makefile for SPS (Ultrix 2.0 UNIX Version)
X
PROG    =       sps
OBJS    =       filecount.o findtty.o flagdecode.o flagsetup.o \
X		getcmd.o getupage.o globals1.o globals2.o hashuid.o \
X		initialise.o initsymbols.o inittty.o main.o mktree.o \
X		needed.o openfiles.o percentmem.o prcmd.o prcpu.o \
X		prheader.o printall.o printproc.o prsummary.o readstatus.o \
X		selectproc.o selecttty.o termwidth.o ttystatus.o waitingfor.o
INCS    =       sps.h
CC      =       cc
CFLAGS  =       -DBSD42 -DULTRIX20 -DULTRIX30 -DVPRINTF -I/sys
LIBS    =       -ltermlib
DIRINSTALL =	/bin
X
all:		    $(PROG)
X.c.o:
X		$(CC) $(CFLAGS) -c -O -R $<
X	
globals1.o waitingfor.o:
X		$(CC) $(CFLAGS) -c -O $<
X
X$(OBJS):		$(INCS)
X
X$(PROG):		$(OBJS)
X		$(CC) -o $@ $(OBJS) $(LIBS)
X
install:		$(PROG)
X		strip $(PROG)
X		mv $(PROG) $(DIRINSTALL)/$(PROG)
X		/etc/chown root $(DIRINSTALL)/$(PROG)
X		chgrp kmem $(DIRINSTALL)/$(PROG)
X		chmod 2755 $(DIRINSTALL)/$(PROG)
X
lint:
X		lint -x -b $(CFLAGS) *.c
clean:
X		rm -f $(OBJS) $(PROG)
END_OF_FILE
if test 995 -ne `wc -c <'Makefile.ultrix.3.0'`; then
    echo shar: \"'Makefile.ultrix.3.0'\" unpacked with wrong size!
fi
# end of 'Makefile.ultrix.3.0'
fi
if test -f 'Makefile.ultrix.4.0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.ultrix.4.0'\"
else
echo shar: Extracting \"'Makefile.ultrix.4.0'\" \(1006 characters\)
sed "s/^X//" >'Makefile.ultrix.4.0' <<'END_OF_FILE'
X# Makefile for SPS (Ultrix 2.0 UNIX Version)
X
PROG    =       sps
OBJS    =       filecount.o findtty.o flagdecode.o flagsetup.o \
X		getcmd.o getupage.o globals1.o globals2.o hashuid.o \
X		initialise.o initsymbols.o inittty.o main.o mktree.o \
X		needed.o openfiles.o percentmem.o prcmd.o prcpu.o \
X		prheader.o printall.o printproc.o prsummary.o readstatus.o \
X		selectproc.o selecttty.o termwidth.o ttystatus.o waitingfor.o
INCS    =       sps.h
CC      =       cc
CFLAGS  =       -DBSD42 -DULTRIX20 -DULTRIX30 -DULTRIX40 -DVPRINTF -I/sys
LIBS    =       -ltermlib
DIRINSTALL =	/bin
X
all:		    $(PROG)
X.c.o:
X		$(CC) $(CFLAGS) -c -O -R $<
X	
globals1.o waitingfor.o:
X		$(CC) $(CFLAGS) -c -O $<
X
X$(OBJS):		$(INCS)
X
X$(PROG):		$(OBJS)
X		$(CC) -o $@ $(OBJS) $(LIBS)
X
install:		$(PROG)
X		strip $(PROG)
X		mv $(PROG) $(DIRINSTALL)/$(PROG)
X		/etc/chown root $(DIRINSTALL)/$(PROG)
X		chgrp kmem $(DIRINSTALL)/$(PROG)
X		chmod 2755 $(DIRINSTALL)/$(PROG)
X
lint:
X		lint -x -b $(CFLAGS) *.c
clean:
X		rm -f $(OBJS) $(PROG)
END_OF_FILE
if test 1006 -ne `wc -c <'Makefile.ultrix.4.0'`; then
    echo shar: \"'Makefile.ultrix.4.0'\" unpacked with wrong size!
fi
# end of 'Makefile.ultrix.4.0'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(4667 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X		SPS  -  Show Process Status
X		===========================
X
X
Introduction:
X    SPS is a intended to be used as a replacement for the standard
X    ps(1) program. Its advantages over ps(1) are that it shows more
X    useful information, that the displayed information is more
X    comprehensible and that it is faster.
X
X
X    SPS is currently implemented for the following operating systems and
X    architectures.  The corresponding Makefiles are also shown here:
X
X	Makefile.4.1		Standard 4.1bsd for Vax
X	Makefile.4.2		Standard 4.2bsd, Ultrix 1.x for Vax
X	Makefile.4.3		Standard 4.3bsd (or 4.3-tahoe) for Vax
X	Makefile.4.3+NFS	4.3bsd+NFS from Wisconsin (Mt. Xinu?, others?)
X	Makefile.sun.2.0	Sun 4.2 UNIX Release 2.0 - 2.2 for Sun-2
X	Makefile.sun.3.0	Sun 4.2 UNIX Release 3.0 for Sun-2, Sun-3
X	Makefile.sun.3.2	Sun 4.2 UNIX Release 3.2 for Sun-2, Sun-3
X	Makefile.sun.4.0	SunOS 4.0 for Sun-2, Sun-3, Sun-4
X	Makefile.sun.4.0+386i	SunOS 4.0 for Sun 386i
X	Makefile.sun.4.1	SunOS 4.1 for Sun-2, Sun-3, Sun-4
X	Makefile.sun4.3.2	SunOS Sys 4-3.2 for Sun-4
X	Makefile.ultrix.2.0	DEC Ultrix 2.0 - 2.2
X	Makefile.ultrix.3.0	DEC Ultrix 3.0
X	Makefile.ultrix.4.0	DEC Ultrix 4.x
X
X    (I also have a somewhat ancient implementation for V7 on a PDP-11 as well
X    as Unisoft Version 1.3 on a MC68000 if anyone is interested).
X
X
What SPS does:
X    SPS displays wait channels symbolically, rather than as hexadecimal
X    addresses.  (If you wish to teach SPS about a new sort of device,
X    you must add an entry in the symbol table (globals2.c) as well as
X    increasing the size of that table (NWAITSTATE in sps.h)).
X
X    SPS sorts processes before listing them, the order reflecting the
X    relationship of the processes.  A child process is listed
X    underneath its corresponding parent and is indented to depict the
X    exact relationship.  SPS also indicates setuid processes.
X
X    SPS displays such values as the resident and virtual sizes of
X    system processes.  It accepts a whole range of options to control
X    the output.  By default, SPS lists information about one's own
X    processes.  Other options instruct it to be verbose (the "v"
X    option), to list all the command arguments of a process (the "w"
X    option) or to list the environment strings of that process (the "e"
X    option).  Similarly, there are options to control which processes
X    are to be displayed.  The "a" option tells it to describe all
X    processes and the "b" option tells it to describe "busy" processes;
X    the latter is useful if you wish to find out what is loading your
X    system.  There are also options to select the output according to
X    user, controlling tty or process number.
X
X    SPS keeps its information in an information file; by default, this
X    is /tmp/.spsinfo. This means that it can avoid having to do an
X    expensive nlist() operation each time it is run.  It must be
X    reinitialised (with the "i" option) if new users are added to
X    /etc/passwd or if a new version of /vmunix is installed.
X
X
How to build SPS:
X    1. In order to compile and install SPS, first unbundle the three shell
X       archive files.
X    2. Check that the define statements in sps.h are large enough for
X       your system.  In particular, you may need to increase MAXTTYS
X       to reflect the number of tty devices in /dev.  The parameter
X       MAXUSERS defines the maximum number of users defined in the
X       password file (or through the Yellow Pages).  Because the
X       user-ids are held in an internal hash table, this should
X       probably be at least double the number of actual users.
X    3. Choose an appropriate Makefile from the table above and compile
X       the source files.  For example:
X	   % make -f Makefile.sun.3.2
X    4. Try running SPS.  First, a suitable information file must be
X       initialised.  It should then be able to display information
X       concerning running processes on your system:
X	     # Initialise SPS.  Ignore any error messages at this stage.
X	   % sps i
X	     # Instruct SPS to list all active processes in verbose format.
X	   % sps va
X    5. If this all works, install SPS with the appropriate Makefile
X       and reinitialise it:
X	   % make -f Makefile.sun.3.2 install
X	   % sps -i
X
X
Bug reports:
X    Send all bug reports, fixes, comments and suggestions to Robert Ward at -
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X    J. Robert Ward,
X    Olsen & Associates AG, Seefeldstrasse 233, CH-8008 Zuerich, Switzerland
X
Tel.:   +41 1 552224           Fax: +41 1 552282
XEmail:  robert@olsen.ch        Uucp:  uunet!olsen!robert
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
END_OF_FILE
if test 4667 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'RELEASENOTES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'RELEASENOTES'\"
else
echo shar: Extracting \"'RELEASENOTES'\" \(1230 characters\)
sed "s/^X//" >'RELEASENOTES' <<'END_OF_FILE'
X		YET  ANOTHER  RELEASE  OF  SPS
X		==============================
X
X
This release of sps corrects some bugs in previous versions.  It also
includes support for Ultrix 4.x on DecStation 3100s and related animals as
well as on Vaxen.
X
The Ultrix 4.x support does not function as well as on other operating
systems.  Command line arguments are not determined.  However the name of
the running program and other upage information is found correctly.  (If
anyone knows how to make this work properaly, please let me know).
X
Many thanks to all those who provided bug reports and other input and to
those too who helped in beta-testing.  The latter include Jamie Watson
X<jw@pan.adasoft.ch> and Robert Owen <owen@hasler.ascom.ch>.
X
No thanks at all to DEC who made the Ultrix 4.x internals so painfully and
obscurely different from any other version of Unix known to mankind.
X
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X    J. Robert Ward,
X    Olsen & Associates AG, Seefeldstrasse 233, CH-8008 Zuerich, Switzerland
X
Tel.:   +41 1 552224           Fax: +41 1 552282
XEmail:  robert@olsen.ch        Uucp:  uunet!olsen!robert
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
END_OF_FILE
if test 1230 -ne `wc -c <'RELEASENOTES'`; then
    echo shar: \"'RELEASENOTES'\" unpacked with wrong size!
fi
# end of 'RELEASENOTES'
fi
if test -f 'filecount.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'filecount.c'\"
else
echo shar: Extracting \"'filecount.c'\" \(1586 characters\)
sed "s/^X//" >'filecount.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)filecount.c	1.3\t8/22/91" ;
X# endif
X
X# include       "sps.h"
X
X/* FILECOUNT - Counts the # open files for the current process */
filecount ( p )
X
struct process         *p ;
X
X{
X	register int            i ;
X	register struct file    **f ;
X	register int            count ;
X	extern union userstate  User ;
X# ifdef SUNOS41
X	/*
X	 * The open file list is in User.u_us.u_ofile_arr
X	 * if User.u_us.u_ofile points to it; otherwise we'll have
X	 * do it the hard way by reading the list from kmem.
X	 *
X	 * Read the comment to u_ofile in /usr/include/sys/user.h.
X	 */
X
X	int			len ;
X	static char		*files = 0 ;
X	static int		 files_len = 0 ;
X	extern char		*getcore () ;
X# endif SUNOS41
X
X
X# ifdef SUNOS41
X
X#  ifndef offsetof
X#   define offsetof(type,member)	((long) &(((type *) 0)->member))
X#  endif offsetof
X
X	if ( (long) User.u_us.u_ofile ==
X	    (long) p->pr_p.p_uarea + offsetof(struct user, u_ofile_arr[0]) )
X		f = &User.u_us.u_ofile_arr[ 0 ] ;
X	else
X	{
X		len = User.u_us.u_lastfile * sizeof (struct file *) ;
X		if (len <= 0)
X			return 0;
X		if (files == 0 || len > files_len)
X		{
X			if (files != 0)
X				free (files) ;
X			files = (char *) getcore(len) ;
X			files_len = len ;
X		}
X		if ( getkmem( (long)User.u_us.u_ofile, (char *)files, len)
X		!= len )
X			return 0 ;
X		f = (struct file **)files ;
X	}
X	count = 0 ;
X	for ( i = 0 ; i < User.u_us.u_lastfile ; i++ )
X		if ( *f++ )
X			count++ ;
X	return ( count ) ;
X# else SUNOS41
X	count = 0 ;
X	for ( i = 0, f = User.u_us.u_ofile ; i < NOFILE ; i++ )
X		if ( *f++ )
X			count++ ;
X	return ( count ) ;
X# endif SUNOS41
X}
END_OF_FILE
if test 1586 -ne `wc -c <'filecount.c'`; then
    echo shar: \"'filecount.c'\" unpacked with wrong size!
fi
# end of 'filecount.c'
fi
if test -f 'findtty.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'findtty.c'\"
else
echo shar: Extracting \"'findtty.c'\" \(1324 characters\)
sed "s/^X//" >'findtty.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)findtty.c	1.4\t8/6/90" ;
X# endif
X
X# include       "sps.h"
X# include       <h/ioctl.h>
X# ifdef SUNOS40
X# include       <h/stream.h>
X# else
X# include       <h/tty.h>
X# endif
X# ifdef SUNOS41
X# include	<h/session.h>
X# endif
X
X/* FINDTTY - Attempts to determine to which tty a process is connected */
struct ttyline  *findtty ( p )
X
register struct process         *p ;
X
X{
X	register struct ttyline *lp ;
X	extern struct info      Info ;
X	extern struct ttyline   Notty ;
X# ifdef SUNOS41
X	struct sess		*s ;
X	extern struct sess	*find_session () ;
X# else
X	extern union userstate  User ;
X# endif SUNOS41
X
X
X# ifdef SUNOS41
X	if ( !p->pr_p.p_pgrp || !p->pr_p.p_sessp )
X		return ( &Notty ) ;
X	s = find_session( p->pr_p.p_sessp ) ;
X	if ( s == 0 || s->s_ttyp == 0 )
X		return &Notty;
X	for ( lp = Info.i_ttyline ; lp->l_name[0] ; lp++ )
X		if ( lp->l_dev == s->s_ttyd )
X			return ( lp ) ;
X	/* Kludge from outer space	++sja */
X	if ( s->s_ttyd == 256 )
X		return &Info.i_ttyline[0] ;
X	return ( &Notty ) ;
X# else
X#  ifdef ULTRIX30
X	if ( !p->pr_p.p_pgrp || !p->pr_p.p_ttyp )
X#  else
X	if ( !p->pr_p.p_pgrp || !User.u_us.u_ttyp )
X#  endif
X		return ( &Notty ) ;
X	for ( lp = Info.i_ttyline ; lp->l_name[0] ; lp++ )
X		if ( lp->l_dev == User.u_us.u_ttyd )
X			return ( lp ) ;
X	return ( &Notty ) ;
X#endif SUNOS41
X}
END_OF_FILE
if test 1324 -ne `wc -c <'findtty.c'`; then
    echo shar: \"'findtty.c'\" unpacked with wrong size!
fi
# end of 'findtty.c'
fi
if test -f 'flags.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flags.h'\"
else
echo shar: Extracting \"'flags.h'\" \(2638 characters\)
sed "s/^X//" >'flags.h' <<'END_OF_FILE'
X# ifndef lint
static char FlagsHId[] =  "@(#)flags.h	1.1\t10/1/88" ;
X# endif
X
X/* Structure holding information specified in the option list ... */
union flaglist
X{
X	char                    *f_chp ;        /* Option specified as string */
X	int                     f_uid ;         /* Numerical user id */
X	int                     f_pid ;         /* Numerical process id */
X	struct ttyline          *f_ttyline ;    /* Specified tty */
X} ;
X
X/* Structure holding global information specifed by arg list options ... */
struct flags
X{
X	int                     flg_c:1 ;       /* print command from upage */
X	int                     flg_d:1 ;       /* disc orientated output */
X	int                     flg_e:1 ;       /* print environment string */
X	int                     flg_f:1 ;       /* print process father # */
X	int                     flg_g:1 ;       /* print process group # */
X	int                     flg_i:1 ;       /* initialise sps */
X	char                    *flg_j ;        /* Use this as the info file */
X	char                    *flg_k ;        /* Use this as the {k}mem file*/
X	int                     flg_o:1 ;       /* avoid the swap device */
X	int                     flg_q:1 ;       /* show user time only */
X	int                     flg_r:1 ;       /* repeat output */
X	unsigned                flg_rdelay ;    /* ... with this much delay */
X	char                    *flg_s ;        /* Use this as the symbol file*/
X	int                     flg_v:1 ;       /* print verbose listing */
X	int                     flg_w:1 ;       /* print wide output */
X	int                     flg_y:1 ;       /* print tty information */
X	int                     flg_A:1 ;       /* print all processes */
X	int                     flg_B:1 ;       /* print busy processes */
X	int                     flg_F:1 ;       /* print foreground processes */
X	int                     flg_N:1 ;       /* print no processes */
X	int                     flg_P:1 ;       /* print specified process #'s*/
X	int                     flg_S:1 ;       /* print stopped processes */
X	int                     flg_T:1 ;       /* print procs for given ttys */
X	int                     flg_U:1 ;       /* print procs for given users*/
X	int                     flg_W:1 ;       /* print waiting processes */
X	int                     flg_Z:1 ;       /* print zombie processes */
X	int                     flg_AZ:1 ;      /* One of A to Z was specified*/
X	union flaglist          *flg_Plist ;    /* List of specified processes*/
X	union flaglist          *flg_Tlist ;    /* List of specified ttys */
X	union flaglist          *flg_Ulist ;    /* List of specified users */
X} ;
END_OF_FILE
if test 2638 -ne `wc -c <'flags.h'`; then
    echo shar: \"'flags.h'\" unpacked with wrong size!
fi
# end of 'flags.h'
fi
if test -f 'flagsetup.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flagsetup.c'\"
else
echo shar: Extracting \"'flagsetup.c'\" \(2151 characters\)
sed "s/^X//" >'flagsetup.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)flagsetup.c	1.2\t6/27/91" ;
X# endif
X
X# include       "sps.h"
X# include       "flags.h"
X# include       <h/ioctl.h>
X# ifdef SUNOS40
X# include       <h/stream.h>
X# endif
X# include       <h/tty.h>
X
X/*
X** FLAGSETUP - Replaces any users or processes specified by flagdecode()
X** with numerical equivalents. The lists are terminated by negative values.
X** or null pointers. Ttystatus() must have been previously called to
X** initialise the Info structure with chaos tty values.
X*/
flagsetup ()
X{
X	register union flaglist *fp ;
X	register char           *chp ;
X	register int            i ;
X	register struct ttyline *lp ;
X	int                     found ;
X	extern struct flags     Flg ;
X	extern struct info      Info ;
X
X	/* Look for specified users */
X	if ( Flg.flg_U )                
X	{
X		if ( !Flg.flg_Ulist->f_chp )
X			prexit( "sps - User name was expected after -u flag\n");
X		for ( fp = Flg.flg_Ulist ; chp = fp->f_chp ; fp++ )
X		{
X			found = 0 ;
X			for ( i = 0 ; i < MAXUSERS ; i++ )
X				if ( !strncmp( chp, Info.i_hnames[i].h_uname,
X					UNAMELEN ) )
X				{
X					fp->f_uid = Info.i_hnames[i].h_uid ;
X					found = 1 ;
X					break ;
X				}
X			if ( !found )
X				prexit( "sps - Unknown user: %s\n", chp ) ;
X		}
X		fp->f_uid = -1 ;
X	}
X	/* Look for specified process ids */
X	if ( Flg.flg_P )                
X	{
X		if ( !Flg.flg_Plist->f_chp )
X			prexit(
X			     "sps - Process id was expected after -p flag\n" ) ;
X		for ( fp = Flg.flg_Plist ; chp = fp->f_chp ; fp++ )
X		{
X			if ( chp[0] < '0' || chp[0] > '9' )
X				prexit( "sps - Bad process id: %s\n", chp ) ;
X			fp->f_pid = atoi( chp ) ;
X		}
X		fp->f_pid = -1 ;
X	}
X	/* Look for specified ttys */
X	if ( !Flg.flg_T )               
X		return ;
X	if ( !Flg.flg_Tlist->f_chp )
X		prexit( "sps - Tty name was expected after -t flag\n" ) ;
X	for ( fp = Flg.flg_Tlist ; chp = fp->f_chp ; fp++ )
X	{
X		found = 0 ;
X		for ( lp = Info.i_ttyline ; lp->l_name[0] ; lp++ )
X			if ( !strncmp( chp, lp->l_name, 2 ) )
X			{
X				fp->f_ttyline = lp ;
X				found = 1 ;
X				break ;
X			}
X		if ( !found )
X			prexit( "sps - Unknown tty name: %.2s\n", chp ) ;
X	}
X	fp->f_ttyline = (struct ttyline*)0 ;
X}
END_OF_FILE
if test 2151 -ne `wc -c <'flagsetup.c'`; then
    echo shar: \"'flagsetup.c'\" unpacked with wrong size!
fi
# end of 'flagsetup.c'
fi
if test -f 'globals1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'globals1.c'\"
else
echo shar: Extracting \"'globals1.c'\" \(945 characters\)
sed "s/^X//" >'globals1.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)globals1.c	1.1\t10/1/88" ;
X# endif
X
X# include       "sps.h"
X# include       "flags.h"
X# ifdef KVM
X# include       <kvm.h>
X# endif
X
X/* Read/Write Variables global to the code of sps */
X
struct info                     Info ;          /* Information structure */
X
struct flags                    Flg ;           /* Flag options */
X
struct summary                  Summary ;       /* Summary of processes */
X
union  userstate                User ;          /* Upage of one process */
X
X# ifdef KVM
kvm_t                          *Flkvm ;         /* Kernel VM descriptor */
X# else
int                             Flmem, Flkmem, Flswap ; /* File descriptors */
X# endif
X
unsigned                        Termwidth ;     /* Width of output device */
X
short                           Lastpgrp ;      /* Last process pgrp printed */
X
short                           Lastuid ;       /* Last process uid printed */
END_OF_FILE
if test 945 -ne `wc -c <'globals1.c'`; then
    echo shar: \"'globals1.c'\" unpacked with wrong size!
fi
# end of 'globals1.c'
fi
if test -f 'hashuid.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hashuid.c'\"
else
echo shar: Extracting \"'hashuid.c'\" \(1515 characters\)
sed "s/^X//" >'hashuid.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)hashuid.c	1.1\t10/1/88" ;
X# endif
X
X# include       "sps.h"
X
X/* The hashing functions themselves ... */
X# define        HASHFN1( a )            (((unsigned)(a)*91 + 17) % MAXUSERS)
X# define        HASHFN2( a )            (((unsigned)(a) + 47) % MAXUSERS)
X
X/*
X** HASHUID - Returns a pointer to a slot in the hash table that corresponds
X** to the hash table entry for `uid'. It returns a null pointer if there is
X** no such slot.
X*/
struct hashtab  *hashuid ( uid )
X
int                             uid ;
X
X{
X	register struct hashtab *hp ;
X	register int            i ;
X	register int            j ;
X	extern struct info      Info ;
X
X	j = HASHFN1( uid ) ;
X	for ( i = 0 ; i < MAXUSERS ; i++ )
X	{
X		hp = &Info.i_hnames[ j ] ;
X		if ( !hp->h_uname[0] )
X			return ( (struct hashtab*)0 ) ;
X		if ( hp->h_uid == uid )
X			return ( hp ) ;
X		j = HASHFN2( j ) ;
X	}
X	return ( (struct hashtab*)0 ) ;
X}
X
X/*
X** HASHNEXT - Returns a pointer to the next slot in the hash table that
X** may be use for storing information for `uid'. It returns a null pointer
X** if there are no more free slots available.
X*/
struct hashtab  *hashnext ( uid )
X
int                             uid ;
X
X{
X	register struct hashtab *hp ;
X	register int            i ;
X	register int            j ;
X	extern struct info      Info ;
X
X	j = HASHFN1( uid ) ;
X	for ( i = 0 ; i < MAXUSERS ; i++ )
X	{
X		hp = &Info.i_hnames[ j ] ;
X		if ( !hp->h_uname[0] )
X			return ( hp ) ;
X		j = HASHFN2( j ) ;
X	}
X	return ( (struct hashtab*)0 ) ;
X}
END_OF_FILE
if test 1515 -ne `wc -c <'hashuid.c'`; then
    echo shar: \"'hashuid.c'\" unpacked with wrong size!
fi
# end of 'hashuid.c'
fi
if test -f 'initialise.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'initialise.c'\"
else
echo shar: Extracting \"'initialise.c'\" \(1986 characters\)
sed "s/^X//" >'initialise.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)initialise.c	1.1\t10/1/88" ;
X# endif
X
X# include       "sps.h"
X# include       "flags.h"
X# include       <pwd.h>
X# include       <stdio.h>
X
X/*
X** INITIALISE - Called to reset the `Info' structure with new kernel
X** addresses and user and tty information.
X*/
initialise ()
X{
X	register FILE           *fd ;
X	char                    *fileinfo ;
X	extern struct flags     Flg ;
X	extern struct info      Info ;
X	FILE                    *fopen() ;
X
X	fileinfo = Flg.flg_j ? Flg.flg_j : FILE_INFO ;
X	/* Read kernel addresses */
X	initsymbols() ;                 
X	/* Read user names */
X	initusers() ;                   
X	(void)umask( ~0644 ) ;          
X	if ( !(fd = fopen( fileinfo, "w" )) )
X	{
X		fprintf( stderr, "sps - Can't create info file %s", fileinfo ) ;
X		sysperror() ;
X	}
X	/* Find tty addresses */
X	inittty() ;                     
X	if ( fwrite( (char*)&Info, sizeof( struct info ), 1, fd ) != 1 )
X	{
X		fprintf( stderr, "sps - Can't write info file %s", fileinfo ) ;
X		sysperror() ;
X		exit( 1 ) ;
X	}
X	(void)fclose( fd ) ;
X	printf( "sps is initialised\n" ) ;
X}
X
X/* INITUSERS - Read the passwd file and fill in the user name arrays */
initusers ()
X{
X	register struct passwd  *pw ;
X	register struct hashtab *hp ;
X	struct passwd           *getpwent() ;
X	char                    *strncpy() ;
X	struct hashtab          *hashuid(), *hashnext() ;
X
X	while ( pw = getpwent() )
X	{       /* For each user in the passwd file, first see if that uid
X		   has been already allocated in the hash table. */
X		if ( hp = hashuid( pw->pw_uid ) )
X		{
X			fprintf( stderr,
X		   "sps - Names %s and %s conflict in passwd file for uid %d\n",
X				hp->h_uname, pw->pw_name, pw->pw_uid ) ;
X			continue ;
X		}
X		/* Try to find a free slot in the hash table and fill it. */
X		if ( !(hp = hashnext( pw->pw_uid )) )
X			prexit( "sps - Too many users in passwd file\n" ) ;
X		hp->h_uid = pw->pw_uid ;
X		(void)strncpy( hp->h_uname, pw->pw_name, UNAMELEN ) ;
X	}
X	(void)endpwent() ;
X}
END_OF_FILE
if test 1986 -ne `wc -c <'initialise.c'`; then
    echo shar: \"'initialise.c'\" unpacked with wrong size!
fi
# end of 'initialise.c'
fi
if test -f 'mktree.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mktree.c'\"
else
echo shar: Extracting \"'mktree.c'\" \(1703 characters\)
sed "s/^X//" >'mktree.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)mktree.c	1.1\t10/1/88" ;
X# endif
X
X# include       "sps.h"
X
X/*
X** MKTREE - Sort the needed processes by subtree and at the top by user.
X** This procedure takes a list of processes (as returned by needed())
X** and returnes a pointer to a sorted list.
X*/
struct process  *mktree ( process, plist )
X
struct process                  *process ;
struct process                  *plist ;
X
X{
X	register struct process *p ;
X	register struct process *pp ;
X	register struct process *lp ;
X	struct process          *op ;
X	struct process          proot ;
X
X	proot.pr_sibling = (struct process*)0 ;
X	for ( p = plist ; p ; p = p->pr_plink )
X	{
X		if ( p->pr_pptr > &process[1] )
X		{
X			for ( pp = plist ; pp ; pp = pp->pr_plink )
X			{
X				if ( pp != p->pr_pptr )
X					continue ;
X				if ( lp = pp->pr_child )
X				{       /* Does process have children ? */
X					op = (struct process*)0 ;
X					while (lp &&
X					lp->pr_p.p_pid < p->pr_p.p_pid )
X					{
X						op = lp ;
X						lp=lp->pr_sibling ;
X					}
X					if ( op )
X					{
X						p->pr_sibling = lp ;
X						op->pr_sibling = p ;
X						break ;
X					}
X				}       
X				p->pr_sibling = lp ;
X				pp->pr_child = p ;
X				break ;
X			}
X			if ( pp )
X				continue ;
X		}
X		/* We have a top level process, sort into top level list.
X		   The top level is sorted firstly by user-id and then
X		   by process-id. */
X		lp = &proot ;
X		pp = lp->pr_sibling ;
X		while ( pp )
X		{
X			if ( p->pr_p.p_uid < pp->pr_p.p_uid )
X				break ;
X			if ( p->pr_p.p_uid == pp->pr_p.p_uid
X			&& p->pr_p.p_pid < pp->pr_p.p_pid )
X				break ;
X			lp = pp, pp = pp->pr_sibling ;
X		}
X		p->pr_sibling = lp->pr_sibling ;
X		lp->pr_sibling = p ;
X	}
X	return ( proot.pr_sibling ) ;
X}
END_OF_FILE
if test 1703 -ne `wc -c <'mktree.c'`; then
    echo shar: \"'mktree.c'\" unpacked with wrong size!
fi
# end of 'mktree.c'
fi
if test -f 'percentmem.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'percentmem.c'\"
else
echo shar: Extracting \"'percentmem.c'\" \(1186 characters\)
sed "s/^X//" >'percentmem.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)percentmem.c	1.2\t6/26/91" ;
X# endif
X
X# include       "sps.h"
X# ifndef SUNOS40
X# include       <h/text.h>
X# endif
X# ifdef BSD42
X# include	<machine/pte.h>
X# else
X# include       <h/pte.h>
X# include       <h/vmparam.h>
X# endif
X# include       <h/vmmac.h>
X
X/* PERCENTMEM - Returns the percentage of real memory used by this process */
double  percentmem ( p )
X
register struct process         *p ;
X
X{
X# ifndef SUNOS40
X	register struct text    *tp ;
X# endif
X	int                     szptudot ;
X	double                  fracmem ;
X	extern struct info      Info ;
X
X# ifdef SUNOS40
X	if ( !(p->pr_p.p_flag & SLOAD) )
X		return ( 0.0 ) ;
X	szptudot = UPAGES ;
X	fracmem = ( (double)p->pr_p.p_rssize + szptudot ) ;
X# else
X	tp = p->pr_p.p_textp ;
X# ifdef ULTRIX40
X	if ( !(p->pr_p.p_sched & SLOAD) || !tp )
X# else
X	if ( !(p->pr_p.p_flag & SLOAD) || !tp )
X# endif
X		return ( 0.0 ) ;
X	szptudot = UPAGES + clrnd( ctopt( p->pr_p.p_dsize + p->pr_p.p_ssize ) );
X	fracmem = ( (double)p->pr_p.p_rssize + szptudot ) / CLSIZE ;
X	if ( tp->x_ccount )
X		fracmem += ((double)tp->x_rssize)/CLSIZE/tp->x_ccount ;
X# endif
X	return ( 100.0 * fracmem / (double)Info.i_ecmx ) ;
X}
END_OF_FILE
if test 1186 -ne `wc -c <'percentmem.c'`; then
    echo shar: \"'percentmem.c'\" unpacked with wrong size!
fi
# end of 'percentmem.c'
fi
if test -f 'prcmd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prcmd.c'\"
else
echo shar: Extracting \"'prcmd.c'\" \(785 characters\)
sed "s/^X//" >'prcmd.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)prcmd.c	1.1\t10/1/88" ;
X# endif
X
X# include       "sps.h"
X# include       "flags.h"
X
X/* PRCMD - Prints the command arguments according to the switches */
prcmd ( p, lpad, width )
X
register struct process         *p ;
int                             lpad ;
int                             width ;
X
X{
X	extern struct flags     Flg ;
X	extern unsigned         Termwidth ;
X
X	printf( "%*d ", lpad, p->pr_p.p_pid ) ;
X	if ( Flg.flg_f )
X	{
X		printf( "%5d ", p->pr_p.p_ppid ) ;
X		width -= 6 ;
X	}
X	if ( Flg.flg_g )
X	{
X		printf( "%5d ", p->pr_p.p_pgrp ) ;
X		width -= 6 ;
X	}
X	width += Termwidth ;
X	if ( Flg.flg_w )
X		printf( "%s\n", p->pr_cmd ) ;
X	else if ( width > 0 )
X		printf( "%-.*s\n", width, p->pr_cmd ) ;
X	if ( p->pr_csaved )
X		free( p->pr_cmd ) ;
X}
END_OF_FILE
if test 785 -ne `wc -c <'prcmd.c'`; then
    echo shar: \"'prcmd.c'\" unpacked with wrong size!
fi
# end of 'prcmd.c'
fi
if test -f 'prcpu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prcpu.c'\"
else
echo shar: Extracting \"'prcpu.c'\" \(1614 characters\)
sed "s/^X//" >'prcpu.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)prcpu.c	1.1\t10/1/88" ;
X# endif
X
X# include       "sps.h"
X
X# ifdef BSD42
X
X/* PRCPU - Print cpu time */
prcpu ( time, utime )
X
register time_t                 time ;
time_t                          utime ;
X
X{
X	time += utime / 1000000 ;
X	utime %= 1000000 ;
X	if ( time < 0L )
X	{       /* Ignore negative times */
X		printf( "     " ) ;     
X		return ;
X	}
X	if ( time < 60L*10L )
X	{       /* Print as seconds if less than 1000 seconds */
X		printf( "%3d.%1d", (int)time, (int)utime/100000 ) ;
X		return ;
X	}
X	/* Print as minutes if less than 10 hours ; print as hours if less than
X	   10 days, else print as days. */
X	if ( time < 60L*60L*10L )               
X		printf( "%3D M", time/60L ) ;
X	else if ( time < 24L*60L*60L*10L )
X		printf( "%3D H", time/60L/60L ) ;
X	else
X		printf( "%3D D", time/60L/60L/24L ) ;
X}
X
X# else
X
X/* PRCPU - Print cpu time */
prcpu ( time )
X
register time_t                 time ;
X
X{
X	extern struct info      Info ;
X
X	if ( time < 0L )
X	{       /* Ignore negative times */
X		printf( "     " ) ;     
X		return ;
X	}
X	if ( time < Info.i_hz*60L*10L )
X	{       /* Less than 10 minutes */
X		printf( "%3D.%1D", time/Info.i_hz,
X			(time % Info.i_hz / (Info.i_hz/10L)) ) ;
X		return ;
X	}
X	/* If less than 10 hours, print as minutes */
X	time /= Info.i_hz ;
X	/* Print as minutes if less than 10 hours ; print as hours if less than
X	   10 days, else print as days. */
X	if ( time < 60L*60L*10L )               
X		printf( "%3D M", time/60L ) ;
X	else if ( time < 24L*60L*60L*10L )
X		printf( "%3D H", time/60L/60L ) ;
X	else
X		printf( "%3D D", time/60L/60L/24L ) ;
X}
X
X# endif
END_OF_FILE
if test 1614 -ne `wc -c <'prcpu.c'`; then
    echo shar: \"'prcpu.c'\" unpacked with wrong size!
fi
# end of 'prcpu.c'
fi
if test -f 'prheader.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prheader.c'\"
else
echo shar: Extracting \"'prheader.c'\" \(683 characters\)
sed "s/^X//" >'prheader.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)prheader.c	1.1\t10/1/88" ;
X# endif
X
X# include       "sps.h"
X# include       "flags.h"
X
X/* PRHEADER - Print a header according to the switches */
prheader ()
X{
X	extern struct flags     Flg ;
X
X	printf( "Ty User    %s Proc#", Flg.flg_v ?
X# ifdef SUNOS40
X# ifdef OLDSTATS
X		" Status Fl Nice Virt Res %M  Time Child %C" :
X# else
X		" Status Fl Nice Prv  Shr  Res %M  Time Child %C" :
X# endif
X# else
X		" Status Fl Nice Virtual Resident %M  Time Child %C" :
X# endif
X		Flg.flg_d ?
X		"  Files    PageFaults Swap BlockI/O Kbytsecs" : "" ) ;
X	if ( Flg.flg_f )
X		printf( " Ppid#" ) ;
X	if ( Flg.flg_g )
X		printf( " Pgrp#" ) ;
X	printf( " Command\n" ) ;
X}
END_OF_FILE
if test 683 -ne `wc -c <'prheader.c'`; then
    echo shar: \"'prheader.c'\" unpacked with wrong size!
fi
# end of 'prheader.c'
fi
if test -f 'printall.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'printall.c'\"
else
echo shar: Extracting \"'printall.c'\" \(509 characters\)
sed "s/^X//" >'printall.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)printall.c	1.1\t10/1/88" ;
X# endif
X
X# include       <stdio.h>
X# include       "sps.h"
X
X/* PRINTALL - Recursively print the process tree. */
printall ( p, md )
X
register struct process         *p ;
register int                    md ;
X
X{
X	while ( p )
X	{       /* Print this process */
X		printproc( p, md ) ;    
X		(void)fflush( stdout ) ;
X		/* Print child processes */
X		printall( p->pr_child, md+1 ) ;
X		/* Print brother processes */
X		p = p->pr_sibling ;     
X	}
X}
END_OF_FILE
if test 509 -ne `wc -c <'printall.c'`; then
    echo shar: \"'printall.c'\" unpacked with wrong size!
fi
# end of 'printall.c'
fi
if test -f 'prsummary.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prsummary.c'\"
else
echo shar: Extracting \"'prsummary.c'\" \(712 characters\)
sed "s/^X//" >'prsummary.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)prsummary.c	1.1\t10/1/88" ;
X# endif
X
X# include       "sps.h"
X
X/* PRSUMMARY - Print the summarising information */
prsummary ()
X{
X	extern struct summary   Summary ;
X
X	printf(
X"%D (%Dk) processes, %D (%Dk) busy, %D (%Dk) loaded, %D (%Dk) swapped\n",
X		Summary.sm_ntotal, KBYTES( Summary.sm_ktotal ),
X		Summary.sm_nbusy, KBYTES( Summary.sm_kbusy ),
X		Summary.sm_nloaded, KBYTES( Summary.sm_kloaded ),
X		Summary.sm_nswapped, KBYTES( Summary.sm_kswapped ) ) ;
X	Summary.sm_ntotal = 0L ;
X	Summary.sm_ktotal = 0L ;
X	Summary.sm_nbusy = 0L ;
X	Summary.sm_kbusy = 0L ;
X	Summary.sm_nloaded = 0L ;
X	Summary.sm_kloaded = 0L ;
X	Summary.sm_nswapped = 0L ;
X	Summary.sm_kswapped = 0L ;
X}
END_OF_FILE
if test 712 -ne `wc -c <'prsummary.c'`; then
    echo shar: \"'prsummary.c'\" unpacked with wrong size!
fi
# end of 'prsummary.c'
fi
if test -f 'readstatus.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'readstatus.c'\"
else
echo shar: Extracting \"'readstatus.c'\" \(1281 characters\)
sed "s/^X//" >'readstatus.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)readstatus.c	1.1\t10/1/88" ;
X# endif
X
X# include       "sps.h"
X# ifndef SUNOS40
X# include       <h/text.h>
X# endif
X
X/* READSTATUS - Reads the kernel memory for current processes and texts */
X# ifdef SUNOS40
readstatus ( process )
X
register struct process         *process ;
X
X# else
X
readstatus ( process, text )
X
register struct process         *process ;
struct text                     *text ;
X
X# endif
X{
X	register struct proc    *p ;
X	register struct proc    *p0 ;
X	register struct process *pr ;
X	int                     size ;
X	extern struct info      Info ;
X	char                    *getcore() ;
X
X# ifndef SUNOS40
X	/* Read current text information */
X	size = Info.i_ntext * sizeof( struct text ) ;
X	if ( getkmem( (long)Info.i_text0, (char*)text, size ) != size )
X		prexit( "sps - Can't read system text table\n" ) ;
X# endif
X	/* Read current process information */
X	size = Info.i_nproc * sizeof( struct proc ) ;
X	p0 = (struct proc*)getcore( size ) ;
X	if ( getkmem( (long)Info.i_proc0, (char*)p0, size ) != size )
X		prexit( "sps - Can't read system process table\n" ) ;
X	/* Copy process information into our own array */
X	for ( p = p0, pr = process ; pr < &process[ Info.i_nproc ] ; p++, pr++ )
X		pr->pr_p = *p ;
X	free( (char*)p0 ) ;
X}
END_OF_FILE
if test 1281 -ne `wc -c <'readstatus.c'`; then
    echo shar: \"'readstatus.c'\" unpacked with wrong size!
fi
# end of 'readstatus.c'
fi
if test -f 'selectproc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'selectproc.c'\"
else
echo shar: Extracting \"'selectproc.c'\" \(2248 characters\)
sed "s/^X//" >'selectproc.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)selectproc.c	1.2\t6/15/90" ;
X# endif
X
X# include       "sps.h"
X# include       "flags.h"
X# ifdef USELOGINUID
X# include	<pwd.h>
X# endif USELOGINUID
X
X/*
X** SELECTPROC - Given a process structure, this procedure decides whether
X** the process is a candidate for printing.
X*/
selectproc ( p, process, thisuid )
X
register struct process         *p ;            
register struct process         *process ;      
int				thisuid ;
X
X{
X	register union flaglist *fp ;
X	register struct process *pp ;
X#ifdef USELOGINUID
X	char			*username ;
X	struct passwd		*pw ;
X	char			*getlogin() ;
X	struct passwd		*getpwnam() ;
X#endif USELOGINUID
X	extern struct flags     Flg ;
X
X	/* Flg.flg_AZ is an internal flag set if one of flags `A' to `Z'
X	   was specified. If this is not set, a process is listed only
X	   if it or one of its ancestors belongs to the invoking user. */
X	if ( !Flg.flg_AZ )
X	{
X#ifdef USELOGINUID
X		thisuid = (username = getlogin())
X			&& (pw = getpwnam( username )) ? pw->pw_uid : getuid() ;
X#endif USELOGINUID
X		for ( pp = p ; pp > &process[1] ; pp = pp->pr_pptr )
X			if ( thisuid == pp->pr_p.p_uid )
X				return ( 1 ) ;
X	}
X	if ( Flg.flg_A )
X		return ( 1 ) ;
X	if ( Flg.flg_P )
X		for ( fp = Flg.flg_Plist ; fp->f_pid >= 0 ; fp++ )
X			if ( fp->f_pid == p->pr_p.p_pid )
X				return ( 1 ) ;
X	if ( Flg.flg_U )
X		for ( pp = p ; pp > &process[1] ; pp = pp->pr_pptr )
X			for ( fp = Flg.flg_Ulist ; fp->f_uid >= 0 ; fp++ )
X				if ( fp->f_uid == pp->pr_p.p_uid )
X					return ( 1 ) ;
X	switch ( p->pr_p.p_stat )
X	{
X		case SRUN :
X			if ( Flg.flg_B )
X# ifdef SUNOS40
X				/* Ignore the idle processes */
X				return ( p->pr_p.p_pid != 3
X				    && p->pr_p.p_pid != 4 ) ;
X# else
X				return ( 1 ) ;
X# endif SUNOS40
X			break ;
X		case SSLEEP :
X			if ( Flg.flg_B
X			&&   p->pr_p.p_pri < PZERO && p->pr_p.p_pid > MSPID )
X# ifdef SUNOS40
X				/* Ignore the idle processes */
X				return ( p->pr_p.p_pid != 3
X				    && p->pr_p.p_pid != 4 ) ;
X# else
X				return ( 1 ) ;
X# endif SUNOS40
X		case SWAIT :
X		case SIDL :
X			if ( Flg.flg_W )
X				return ( 1 ) ;
X			break ;
X		case SSTOP :
X			if ( Flg.flg_S )
X				return ( 1 ) ;
X			break ;
X		case SZOMB :
X			if ( Flg.flg_Z )
X				return ( 1 ) ;
X			break ;
X		default :
X			break ;
X	}
X	return ( 0 ) ;
X}
END_OF_FILE
if test 2248 -ne `wc -c <'selectproc.c'`; then
    echo shar: \"'selectproc.c'\" unpacked with wrong size!
fi
# end of 'selectproc.c'
fi
if test -f 'selecttty.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'selecttty.c'\"
else
echo shar: Extracting \"'selecttty.c'\" \(448 characters\)
sed "s/^X//" >'selecttty.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)selecttty.c	1.1\t10/1/88" ;
X# endif
X
X# include       "sps.h"
X# include       "flags.h"
X
X/* SELECTTTY - Decides whether this process is interesting for its tty */
selecttty ( p )
X
register struct process         *p ;
X
X{
X	register union flaglist *fp ;
X	extern struct flags     Flg ;
X
X	for ( fp = Flg.flg_Tlist ; fp->f_ttyline ; fp++ )
X		if ( fp->f_ttyline == p->pr_tty )
X			return ( 1 ) ;
X	return ( 0 ) ;
X}
END_OF_FILE
if test 448 -ne `wc -c <'selecttty.c'`; then
    echo shar: \"'selecttty.c'\" unpacked with wrong size!
fi
# end of 'selecttty.c'
fi
if test -f 'termwidth.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'termwidth.c'\"
else
echo shar: Extracting \"'termwidth.c'\" \(978 characters\)
sed "s/^X//" >'termwidth.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)termwidth.c	1.3\t8/6/90" ;
X# endif
X
X# include	<sys/ioctl.h>
X
X/*
X** TERMWIDTH - Sets the external variable `Termwidth' to the # of columns
X** on the terminal.
X*/
termwidth ()
X{
X	register char           *termtype ;
X	register int            twidth ;
X# ifdef TIOCGWINSZ
X	struct winsize		w ;
X# else
X# ifdef TIOCGSIZE
X	struct ttysize          w ;
X# endif
X# endif
X	char                    buf[ 1025 ] ;
X	extern unsigned         Termwidth ;
X	char                    *getenv() ;
X
X# ifdef TIOCGWINSZ
X	w.ws_col = 0 ;
X	if ( !ioctl( 0, TIOCGWINSZ, &w ) && w.ws_col )
X	{
X		Termwidth = w.ws_col ;
X		return ;
X	}
X# else
X# ifdef TIOCGSIZE
X	w.ts_cols = 0 ;
X	if ( !ioctl( 0, TIOCGSIZE, &w ) && w.ts_cols )
X	{
X		Termwidth = w.ts_cols ;
X		return ;
X	}
X# endif
X# endif
X	Termwidth = 80 ;
X	if ( !(termtype = getenv( "TERM" )) )
X		return ;
X	if ( tgetent( buf, termtype ) != 1 )
X		return ;
X	twidth = tgetnum( "co" ) ;
X	if ( twidth > 40 )
X		Termwidth = twidth ;
X}
END_OF_FILE
if test 978 -ne `wc -c <'termwidth.c'`; then
    echo shar: \"'termwidth.c'\" unpacked with wrong size!
fi
# end of 'termwidth.c'
fi
if test -f 'vmstat.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vmstat.c'\"
else
echo shar: Extracting \"'vmstat.c'\" \(1902 characters\)
sed "s/^X//" >'vmstat.c' <<'END_OF_FILE'
X# ifndef lint
static char SccsId[] =  "@(#)vmstat.c	1.1\t10/1/88" ;
X# endif
X
X# ifdef SUNOS40
X# ifndef OLDSTATS
X# include "sps.h"
X# include <h/mman.h>
X# include <vm/hat.h>
X# include <vm/as.h>
X# include <vm/seg.h>
X# include <vm/seg_vn.h>
X
seg_count ( p )
X
struct process                  *p ;
X
X{
X	extern struct info      Info ;
X	struct as               as ;		/* address space */
X	struct seg              seg ;		/* segment in addr space */
X	struct segvn_data       vn_data ;
X	unsigned                private = 0 ;
X	unsigned                shared = 0 ;
X
X	p->pr_private = 0 ;
X	p->pr_shared = 0 ;
X
X	if ( getkmem( (long)p->pr_p.p_as, &as, sizeof( as ) ) != sizeof( as ) )
X		return( -1 ) ;
X	seg.s_next = as.a_segs ;	/* setup for loop */
X	do
X	{
X		if ( ( getkmem( seg.s_next, &seg, sizeof( seg ) ) )
X		!= sizeof( seg ) )
X			break ;
X		if ( seg.s_as != p->pr_p.p_as )
X			continue ;	/* invalid segment */
X		if ( seg.s_ops != Info.i_segvn_ops )
X		{			/* mapped device is "shared" */
X			shared += seg.s_size ;
X			continue ;
X		}
X		if ( getkmem( (long)seg.s_data, &vn_data, sizeof( vn_data ) )
X		!= sizeof( vn_data ) )
X			continue ;
X		/*
X		 * If a segment has an anonymous mapping, it is in the swap
X		 * area.  If it is also MAP_PRIVATE, we consider it "private"
X		 * (even though it may be shared between parent and child after
X		 * a fork() call).  Segments without an anonymous mapping are
X		 * considered to be "shared".  [Should we worry about swap
X		 * space reserved for copy-on-write shared segments?]
X		 */
X
X		if ( vn_data.amp && (vn_data.type & MAP_TYPE) == MAP_PRIVATE )
X			private += seg.s_size ;
X		else
X			shared += seg.s_size ;
X	}
X	while ( seg.s_next != as.a_segs ) ;
X
X# define BYTETOPAGE(x) (((x)+(PAGESIZE-1))>>PGSHIFT)
X
X	p->pr_private = BYTETOPAGE( private ) ;
X	p->pr_shared = BYTETOPAGE( shared ) ;
X	p->pr_p.p_rssize = as.a_rss ;	/* update count of resident pages */
X	return( 0 ) ;
X}
X# endif
X# endif
END_OF_FILE
if test 1902 -ne `wc -c <'vmstat.c'`; then
    echo shar: \"'vmstat.c'\" unpacked with wrong size!
fi
# end of 'vmstat.c'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
