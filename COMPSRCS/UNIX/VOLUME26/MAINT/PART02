Newsgroups: comp.sources.unix
From: peirce@gw.wmich.edu (Leonard J. Peirce)
Subject: v26i050: maint - full-screen file and directory maintenance tool, Part02/07
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: peirce@gw.wmich.edu (Leonard J. Peirce)
Posting-Number: Volume 26, Issue 50
Archive-Name: maint/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 7)."
# Contents:  info.c maint.h.dist options.c pool.c slot.c
# Wrapped by vixie@cognition.pa.dec.com on Thu May 14 23:05:42 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'info.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'info.c'\"
else
echo shar: Extracting \"'info.c'\" \(13653 characters\)
sed "s/^X//" >'info.c' <<'END_OF_FILE'
X/******************************************************************************
X*******************************************************************************
X
X   Site:	Western Michigan University Academic Computer Center
X
X   System:	Directory/File System Maintenance
X  
X   Program:	maint
X
X   Version=01	Level=00	01/24/92	Leonard J. Peirce
X
X   Purpose:	Give full information about a file, including size, pro-
X		tection mode, inode, and file commands, among other info.
X
X   Arguments:	See individual routine(s).
X
X   External variables:	None
X
X   Maint external functions:
X
X	Defined:	info
X
X	Called:		add_filetype, get_group, get_owner, prot_val_to_str,
X			put_line, readlink
X
X   Files accessed:	File passed to info routine
X
X   Return codes:	See individual routines
X
X   Compiling instructions:	See Makefile
X
X   Linking instructions:	See Makefile
X
X   Other information:	(C) Copyright 1992, Leonard J. Peirce
X
X********************************************************************************
X*******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*                        # I N C L U D E   F I L E S                         */
X/*                                                                            */
X/******************************************************************************/
X
X#if !defined(SYSV) || defined(sun)
X#include <sys/types.h>
X#endif
X#ifdef ultrix
X#include <cursesX.h>
X#else
X#include <curses.h>
X#endif
X#include <stdio.h>
X#include <string.h>
X#include <errno.h>
X#include <time.h>
X#include "maint.h"
X#include <sys/stat.h>
X
X/******************************************************************************/
X/*                                                                            */
X/*                             # D E F I N E S                                */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*          S T R U C T U R E S ,   U N I O N S ,   T Y P E D E F S           */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*   E X T E R N A L   D E F I N I T I O N S   &   D E C L A R A T I O N S    */
X/*                                                                            */
X/******************************************************************************/
X
extern	 char	  *prot_val_to_str(),
X		  *get_owner(),
X		  *get_group();
X
extern	 int	  readlink();
X
extern	 u_short  add_filetype();
X
extern	 short	  put_line();
X
X	 short	  info();
X
X/******************************************************************************/
X/*                                                                            */
X/*     S T A T I C   D E F I N I T I O N S   &   D E C L A R A T I O N S      */
X/*                                                                            */
X/******************************************************************************/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	info
X
X  Purpose:	Display all the information about the file that the user could
X		possibly want.  Basically, all of the information on the file
X		is displayed, along with any of the commands that might be
X		associated with the file.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	  0			completed successfully
X	CANT_DISPLAY		can't get file attributes to display
X
X********************************************************************************
X*******************************************************************************/
X
short info(ent,args)
X					/*******   FORMAL  PARAMETERS   *******/
register ENT_DEF  *ent;			/* file entry pointer		      */
X	 ARG_DEF  *args;		/* run-time arguments		      */
X
X{	/*** info ***/
X					/********   LOCAL  VARIABLES   ********/
register COM_DEF  *comm_ptr;		/* pointer to file commands for file  */
X	 WINDOW	  *window;		/* window to use		      */
X	 long	  temp;			/* temporary time value		      */
struct	 stat	  statbuf;		/* for getting file information	      */
X	 int	  row = 0,		/* what row is being written to	      */
X		  length,		/* length of string from readlink()   */
X		  status,		/* return code status holder	      */
X		  max_row,		/* max. usable row for window	      */
X		  i, j ;		/* simple counters 		      */
X	 char	  buf[MAXNAMLEN*2],	/* formatting buffer		      */
X		  buf2[MAXNAMLEN+10],	/* for getting symbolic link info     */
X		  time1[TIME_STR_MAX+2], /* time string formatting buffer     */
X		  time2[TIME_STR_MAX+2], /* time string formatting buffer     */
X		  time3[TIME_STR_MAX+2]; /* time string formatting buffer     */
u_short  	  prot ;		/* protection word value	      */
static	 char	  indent_str[] = {"    "},
X		  copy_str[] = {"Copy to: "},
X		  rename_str[] = {"Rename to: "},
X		  delete_str[] = {"Delete"},
X		  protect_str[] = {"Protection: "},
X		  text_str[] = {"Text descriptor: "},
X		  owner_str[] = {"Owner: "},
X		  group_str[] = {"Group: "},
X		  link_str[] = {"Symbolic link to: "};
static char	  *who_perm[ 3 ] = {
X					"Owner",
X					"Group",
X					"Others"
X					} ;
static char	  *dir_permissions[] = {
X	"   %s can%s read (list) the directory",
X	"   %s can%s create, delete and rename files in the directory",
X	"   %s can%s pass through the directory to other files or dirs",
X	} ;
static char	  *file_permissions[] = {
X	"   %s can%s read the file",
X	"   %s can%s change the file",
X	"   %s can%s run the program or shell script in the file",
X	} ;
char		  **perm_details = file_permissions ;
X
X	
X
X   /* first create a window to use */
X
X   window = newwin(LINES - SPEC_WINDOW_ROWS,COLS,SPEC_WINDOW_ROWS,0);
X   werase(window);
X   keypad(window,TRUE);
X   max_row = LINES - (SPEC_WINDOW_ROWS + 1);
X
X   /* get the info for the file */
X
X#if !defined(SYSV) || defined(sun)
X   status = lstat(ent->filename,&statbuf);
X#else
X   status = stat(ent->filename,&statbuf);
X#endif
X
X   if(status != 0)
X      return(FAILURE);
X
X   /* now write the stuff to the screen */
X
X   strtcpy(buf,ent->filename);		/* make control chars printable first */
X   put_buf(window,buf,&row,max_row,0,A_BOLD,FALSE,' ',FALSE);
X   put_buf(window,"",&row,max_row,0,A_BOLD,FALSE,' ',FALSE);
X
X#if !defined(SYSV) || defined(sun)
X   if(ent->type == LINK)
X   {
X      /* get what it's linked to */
X
X      length = readlink(ent->filename,buf2,MAXNAMLEN+10);
X
X      if(length > 0)
X      {
X	 buf2[length] = '\0';		/* make it a string		      */
X	 cat(3,buf,link_str,buf2);
X         put_buf(window,buf,&row,max_row,sizeof(link_str),A_NORMAL,FALSE,' ',
X		 FALSE);
X      }
X   }
X#endif
X
X   prot = add_filetype(ent->type,ent->prot);
X   sprintf(buf,"Protection: %s	Owner: %s		Group: %s",
X	   prot_val_to_str(prot), get_owner(ent->uid),get_group(ent->gid));
X
X   put_buf(window,buf,&row,max_row,0,A_NORMAL,FALSE,' ',FALSE);
X
X   /* first determine what type of file it is */
X
X   switch(prot & S_IFMT)
X   {
X      case(S_IFREG):
X	 put_buf(window,"This is a standard file.",&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X#if !defined(SYSV) || defined(sun)
X         sprintf(buf,"Size in bytes: %d	Size in blocks: %d",statbuf.st_size,
X	   statbuf.st_blocks);
X#else
X         sprintf(buf,"Size in bytes: %d",statbuf.st_size);
X#endif
X	 put_buf(window,buf,&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X	 break;
X      case(S_IFDIR):
X	 put_buf(window,"This file is a directory.",&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X	 perm_details = dir_permissions ;
X#if !defined(SYSV)
X         if(prot & S_ISGID)
X	   put_buf(window,"  Files created in this directory will be of the same group as the directory.",&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X	 else
X	   put_buf(window,"  Files created in this directory will be of the same group as your default.",&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X#endif
X	 break;
X      case(S_IFCHR):
X	 put_buf(window,"This file represents a character device.",&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X         sprintf(buf,"  The major device number is %d, minor number %d.",statbuf.st_size,
X	   statbuf.st_blocks);
X	 put_buf(window,buf,&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X	 break;
X      case(S_IFBLK):
X	 put_buf(window,"This file represents a block device.",&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X         sprintf(buf,"  The major device number is %d, minor number %d.",statbuf.st_size,
X	   statbuf.st_blocks);
X	 put_buf(window,buf,&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X	 break;
X      case(S_IFIFO):
X	 put_buf(window,"This file is a named pipe.",&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X         sprintf(buf,"  There are %d unread bytes in the pipe",statbuf.st_size);
X	 put_buf(window,buf,&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X	 break;
X#if defined(S_IFLNK)
X      case(S_IFLNK):
X	 put_buf(window,"This file is a symbolic link.",&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X	 break;
X#endif
X      default:
X	 put_buf(window,"This file is an unknown type.",&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X	 break;
X   }
X
X   /* create and print the detailed permission string */
X
X   put_buf(window,"Details on permissions:",&row,max_row,0,A_NORMAL,FALSE,' ',FALSE);
X   for(i = j = 0 ; i < 3 ; i++, j+=3 )
X   {
X      sprintf( buf, perm_details[ 0 ], who_perm[ i ],
X	 (prot & (S_IREAD >> j)) ? "" : "not" ) ;
X      put_buf(window,buf,&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X      sprintf( buf, perm_details[ 1 ], who_perm[ i ],
X	 (prot & (S_IWRITE >> j)) ? "" : "not" ) ;
X      put_buf(window,buf,&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X      sprintf( buf, perm_details[ 2 ], who_perm[ i ],
X	 (prot & (S_IEXEC >> j)) ? "" : "not" ) ;
X      put_buf(window,buf,&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X   }
X
X   if(prot & S_ISUID)
X      put_buf(window,"The setuid bit is set.",&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X
X   if(prot & S_ISGID)
X      put_buf(window,"The sgid bit is set.",&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X
X   if(prot & S_ISVTX)
X      put_buf(window,"The sticky bit is set.",&row,max_row,0,A_NORMAL,FALSE,' ',FALSE) ;
X
X   sprintf(buf,"Inode #: %d		Number of links: %d",statbuf.st_ino,
X	   statbuf.st_nlink);
X
X   put_buf(window,buf,&row,max_row,0,A_NORMAL,FALSE,' ',FALSE);
X
X   temp = (long) statbuf.st_atime;
X   strcpy(time1,ctime(&temp));
X   temp = (long) statbuf.st_mtime;
X   strcpy(time2,ctime(&temp));
X   temp = (long) statbuf.st_ctime;
X   strcpy(time3,ctime(&temp));
X
X   time1[TIME_STR_MAX] = '\0';		/* lop off the \n's		      */
X   time2[TIME_STR_MAX] = '\0';
X   time3[TIME_STR_MAX] = '\0';
X
X   cat(3,buf,"Last access:		",time1);
X   put_buf(window,buf,&row,max_row,0,A_NORMAL,FALSE,' ',FALSE);
X
X   cat(3,buf,"Last modification:	",time2);
X   put_buf(window,buf,&row,max_row,0,A_NORMAL,FALSE,' ',FALSE);
X
X   cat(3,buf,"Last status change:	",time3);
X   put_buf(window,buf,&row,max_row,0,A_NORMAL,FALSE,' ',FALSE);
X
X   if(args->text)
X   {
X      if(ent->text == NULL)
X	 strcpy(buf,"Text descriptor:	None");
X      else
X	 cat(3,buf,"Text descriptor:	",ent->text);
X
X      put_buf(window,buf,&row,max_row,0,A_NORMAL,FALSE,' ',FALSE);
X   }
X   
X   if(ent->command)
X   {
X      put_buf(window,"",&row,max_row,0,A_NORMAL,FALSE,' ',FALSE);
X      put_buf(window,"File commands:",&row,max_row,0,A_BOLD,FALSE,' ',FALSE);
X
X      comm_ptr = ent->command;
X
X      if(comm_ptr->comm_copy)
X      {
X	 cat(4,buf,indent_str,copy_str,comm_ptr->copy_name);
X	 put_buf(window,buf,&row,max_row,sizeof(indent_str) + sizeof(copy_str),
X		 A_NORMAL,FALSE,' ',FALSE);
X      }
X
X      if(comm_ptr->comm_ren)
X      {
X	 cat(4,buf,indent_str,rename_str,comm_ptr->ren_name);
X	 put_buf(window,buf,&row,max_row,sizeof(indent_str) +
X		 sizeof(rename_str),A_NORMAL,FALSE,' ',FALSE);
X      }
X
X      if(comm_ptr->comm_prot)
X      {
X	 cat(4,buf,indent_str,protect_str,
X	     prot_val_to_str(add_filetype(ent->type,comm_ptr->prot)));
X	 put_buf(window,buf,&row,max_row,sizeof(indent_str) +
X		 sizeof(protect_str),A_NORMAL,FALSE,' ',FALSE);
X      }
X
X      if(comm_ptr->comm_text)
X      {
X	 cat(4,buf,indent_str,text_str,comm_ptr->text);
X	 put_buf(window,buf,&row,max_row,sizeof(indent_str) + sizeof(text_str),
X		 A_NORMAL,FALSE,' ',FALSE);
X      }
X
X      if(comm_ptr->comm_own)
X      {
X	 cat(4,buf,indent_str,owner_str,get_owner(comm_ptr->owner));
X	 put_buf(window,buf,&row,max_row,sizeof(indent_str) + sizeof(owner_str),
X		 A_NORMAL,FALSE,' ',FALSE);
X      }
X
X      if(comm_ptr->comm_grp)
X      {
X	 cat(4,buf,indent_str,group_str,get_group(comm_ptr->group));
X	 put_buf(window,buf,&row,max_row,sizeof(indent_str) + sizeof(group_str),
X		 A_NORMAL,FALSE,' ',FALSE);
X      }
X
X      if(comm_ptr->comm_del)
X      {
X	 cat(3,buf,indent_str,delete_str);
X	 put_buf(window,buf,&row,max_row,sizeof(indent_str) +
X		 sizeof(delete_str),A_NORMAL,FALSE,' ',FALSE);
X      }
X   }
X   else
X      put_buf(window,"File commands:		None",&row,max_row,0,A_NORMAL,
X	       FALSE,' ',FALSE);
X
X
X   put_buf(window," ",&row,max_row,0,A_REVERSE,TRUE,' ',TRUE);
X   delwin(window);			/* get rid of the window	      */
X   return(SUCCESS);
X
X}	/*** info ***/
END_OF_FILE
if test 13653 -ne `wc -c <'info.c'`; then
    echo shar: \"'info.c'\" unpacked with wrong size!
fi
# end of 'info.c'
fi
if test -f 'maint.h.dist' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'maint.h.dist'\"
else
echo shar: Extracting \"'maint.h.dist'\" \(15883 characters\)
sed "s/^X//" >'maint.h.dist' <<'END_OF_FILE'
X#ifndef MAINT_H
X/******************************************************************************
X*******************************************************************************
X
X   Installation:  Western Michigan University Academic Computer Center
X
X   System:	Directory/File System Maintenance
X  
X   Program:	maint
X
X   Header name:	maint.h
X
X   Version=01	Level=00	01/24/92	Leonard J. Peirce
X
X   Purpose:  Header file for the MAINT program.  This header file should
X	     only be used by MAINT as it would be of no use to any other
X	     program.
X
X   Other information:	(C) Copyright 1992, Leonard J. Peirce
X
X********************************************************************************
X*******************************************************************************/
X
X#define MAINT_H 1			/* to prevent multiple inclusion      */
X
X/******************************************************************************/
X/*                                                                            */
X/*                        # I N C L U D E   F I L E S                         */
X/*                                                                            */
X/******************************************************************************/
X
X#include <sys/types.h>
X#include <dirent.h>
X
X/******************************************************************************/
X/*                                                                            */
X/*                             # D E F I N E S                                */
X/*                                                                            */
X/******************************************************************************/
X
X/* HELPFILE contains on-line help for maint and should be defined in the
X * Makefile so that maints knows where it's supposed to be and so that it
X * it gets installed in the right spot; if you don't want to define it in
X * the Makefile you'll need to make sure that the path to the help file is
X * correct in both spots
X */
X
X#ifndef HELPFILE
X#define HELPFILE "/usr/local/lib/maint.help"
X#endif
X
X#define MAX_SCREEN_ROWS 65		/* max. # of rows for screens	      */
X#define MAX_SCREEN_COLS 132		/* max. # of columns for screens      */
X#define DEFAULT_PAGER "less"		/* less is better than cat.....:-)    */
X#define DEFAULT_EDITOR "vi"		/* sigh.....			      */
X#define DEFAULT_SHELL "csh"
X
X/* the following stuff you probably won't want to touch */
X
X#define TRUE (1)
X#define FALSE (0)
X#define NULLPTR (char *) 0
X
X#define LEFT 0
X#define RIGHT 1
X
X#define SPEC_WINDOW_ROWS 2		/* # of rows in directory spec window */
X#define SPEC_WINDOW_START_ROW 0		/* starting row # of dir spec window  */
X#define STAT_WINDOW_ROWS 2		/* # of rows in statistics window     */
X#define STAT_WINDOW_START_ROW 0
X
X#define SUCCESS 1
X#define FAILURE 0
X
X#define NO_REBUILD 0			/* return values from config()	      */
X#define REBUILD_WITH_FILEMARKS 1
X#define REBUILD_SCREEN 2
X#define REBUILD_DIRECTORY 4
X#define REBUILD_WITH_SORT 8
X
X#define CANT_OPEN -1			/* can't open file to display it      */
X#define CANT_DISPLAY -2			/* can't display file on screen	      */
X#define EMPTY_FILE -3			/* selected file is empty	      */
X#define BAD_FILE -4			/* file format invalid		      */
X#define DONT_CREATE -5			/* do not create file		      */
X#define NO_FILE -6			/* file does not exist		      */
X#define NEW_FILE -7			/* new file had to be created	      */
X#define BAD_SCREEN_NO -8		/* bad screen number read in	      */
X#define CANT_ALLOCATE -9		/* can't allocate necessary memory    */
X#define CANT_OPEN_DEST -10		/* can't open destination file	      */
X#define CANT_STAT -11			/* can't stat a file		      */
X#define CANT_WRITE -12			/* can't write to a file	      */
X#define CANT_CHMOD -13			/* chmod() failed on a file	      */
X#define BAD_GROUP -14			/* invalid group specified	      */
X#define BAD_OWNER -15			/* invalid owner specified	      */
X#define DISPLAY_TEXT 1			/* text descriptors to be displayed   */
X#define SLOT_OVF 2			/* text descriptor overflows slot     */
X
X					/**    return codes for proc_dir()   **/
X#define RECALL_PROC 1			/* force proc_dir() to be recalled    */
X#define EMPTY_DIR 2			/* selected directory is empty	      */
X
X#define NORMAL 1
X#define HIGHLITE 2
X
X#define PROT_MAX 10			/* max. length of protection string   */
X#define DATE_MAX 12			/* max. length of date/time string    */
X#define DNAME_MAX 14			/* max. length of displayed filename  */
X#define FILEMARK_MAX 1			/* max. length of filetype mark	      */
X#define DISP_MAX DNAME_MAX+FILEMARK_MAX /* max. length of filename & mark     */
X#define SIZE_MAX 8			/* max. length of filesize string     */
X#define OWNER_MAX 8			/* max. length of owner string	      */
X#define GROUP_MAX 8			/* max. length of group string	      */
X#define FIELD_GAP 2			/* space between fields in a slot     */
X#define SLOT_GAP 3			/* space between slots on a screen    */
X#define FULL_MAX PROT_MAX + DATE_MAX + DISP_MAX + OWNER_MAX + \
SIZE_MAX + GROUP_MAX + (FIELD_GAP * 5)
X#define MESS_MAX 255			/* max. length of broadcast message   */
X#define STR_MAX 255			/* max. length of help input line     */
X#define TYPE_MAX 3			/* max. length of displayed filetype  */
X#define SPEC_MAX 255			/* max. length of filename	      */
X#define FULL_SPEC_MAX 255		/* max. length of full file spec      */
X#define RESP_MAX 80			/* max. length of response from tty   */
X#define COMMAND_MAX 4			/* max. number of commands per file   */
X#define TEXT_MAX 40			/* max. length of text descriptor     */
X#define DIR_TEXT_MAX 70			/* max. length of directory text desc */
X#define DATE_TIME_MAX 23		/* max. length of a date/time string  */
X#define BUF_MAX 16384			/* buffer size for block mode copying */
X#define PAGE_NO_MAX 4			/* max. digits in screen number	      */
X#define DIR_NAME_MAX MAXNAMLEN		/* this is system-dependent	      */
X#define PROMPT_MAX 80			/* max.length of a prompt string      */
X#define ID_STR_MAX 16			/* max. length of uid/gid string      */
X#define TIME_STR_MAX 24			/* time string from ctime(3)	      */
X#define PROT_INP_MAX 9			/* max. length of protect str read in */
X					/* from the screen		      */
X
X/* maximum number of file rows; this is used to allocate the static array
X * for holding file scree nodes
X */
X
X#define MAX_NODE_ROW (MAX_SCREEN_ROWS - (SPEC_WINDOW_ROWS + \
X STAT_WINDOW_ROWS + 1))
X
X#define MAX_NODE_COL ((MAX_SCREEN_COLS + (DISP_MAX + \
SLOT_GAP - 1))/(DISP_MAX + SLOT_GAP))
X
X#define MIN_SLOT_WIDTH 16		/* minimum slot width		      */
X#define MIN_DISP_LEN 5			/* display >= 5 chars for inputting   */
X#define FLAG_CHAR '+'			/* long filename flag character	      */
X#define TAG_CHAR '>'			/* tag for making marks on files      */
X#define OPT_STRING_MAX 40		/* option id string		      */
X
X#define GROUP_SAVE 150			/* number of gids to save	      */
X#define OWNER_SAVE 150			/* number of uids to save	      */
X
X#define IN_REC_SIZE 512			/* size of input record buffer	      */
X#define TEXT_REC_MAX 112		/* max. length of text descriptor rec */
X#define FUDGE_FACTOR 35			/* multiplied by number of elements   */
X					/* needed to get the size of the      */
X					/* memory pool to allocate	      */
X
X/* these must coincide with the fields in the arg_strings structure that
X * is defined in main.c
X */
X
X#define SIZE_OPT 0
X#define PROT_OPT 1
X#define DATE_OPT 2
X#define GROUP_OPT 3
X#define OWNER_OPT 4
X#define CONFIRM_OPT 5
X#define AUTO_FEED_OPT 6
X#define TEXT_OPT 7
X#define DOT_FILES_OPT 8
X#define FILEMARKS_OPT 9
X#define SORT_OPT 10
X#define NUM_OPT_STRINGS 11
X
X#define TEXT_FILE ".maint.tdf"		/* name of text descriptor file	      */
X
X#define DELETE 'd'			/* file command definitions	      */
X#define RENAME 'r'
X#define COPY 'c'
X#define PROTECT 'p'
X#define TEXT 't'
X#define GROUP 'g'
X#define OWNER 'o'
X					/* -S option flag values	      */
X#define FILENAME 1			/* sort by filename		      */
X#define TYPE 2				/* sort by file type		      */
X#define SIZE 3				/* sort by file size		      */
X#define DATE 4				/* sort by date			      */
X#define NUM_SORT_OPT 4			/* number of highest sort option      */
X
X#define REGULAR '-'
X#define DIRECTORY 'd'
X#define CHARACTER 'c'
X#define BLOCK 'b'
X#define FIFO 'p'
X#define SOCKET 's'
X#define LINK 'l'
X
X#define CONTROL_B 0x2
X#define CONTROL_D 0x4
X#define CONTROL_F 0x6
X#define CONTROL_G 0x7
X#define CONTROL_H 0x8
X#define CONTROL_I 0x9
X#define CONTROL_K 0xB
X#define CONTROL_L 0xC
X#define CONTROL_P 0x10
X#define CONTROL_R 0x12
X#define CONTROL_W 0x17
X#define CONTROL_Z 0x1a
X#define LINEFEED 0xA
X#define CARRIAGE_RETURN 0xD
X#define BACKSPACE 0x8
X#define ESCAPE 0x1b
X
X#define kbytes(size) (((size) + 1023) / 1024)
X#define info_mess(message) write_mess(message,A_BOLD,0)
X#define xmess(message,prefix_len) write_mess(message,A_REVERSE,prefix_len)
X
X#if defined(SYSV) && !defined(sun)
X
X/* stuff that needs to be defined for System V */
X
X#define vfork fork			/* no vfork()			      */
X#define dbtob(db) ((unsigned)(db) << BSHIFT)
X#define R_OK 04				/* for access()			      */
X
X#endif
X
X/******************************************************************************/
X/*                                                                            */
X/*          S T R U C T U R E S ,   U N I O N S ,   T Y P E D E F S           */
X/*                                                                            */
X/******************************************************************************/
X
X#if defined(SYSV) && !defined(sun)
X
typedef unsigned long int u_long;	/* I like underscores....	      */
typedef unsigned int u_int;
typedef unsigned short int u_short;
typedef unsigned char u_char;
typedef int gid_t,uid_t;
X
X#endif
X
X#ifdef SUNOS3
X
X/* weird...SunOS 3.X doesn't have typedefs for uid_t and gid_t in sys/types.h;
X * however, SunOS 4.0 does and it doesn't match the pw_uid and pw_gid fields
X * in the passwd struct in pwd.h -- they are ints and the typedefs for uid_t
X * and gid_t in sys/types.h are u_short.....sigh.....
X */
X
typedef	 int	  uid_t, gid_t;		
X
X#endif
X
typedef	 struct	  NODE_TYP {		/* screen position node		      */
X	 short	  left_row,	   	/* row-coordinate for node array      */
X		  left_col,		/* column-coordinate for node array   */
X		  right_row,		/* row-coordinate for node array      */
X		  right_col,		/* column-coordinate for node array   */
X		  down_row,		/* row-coordinate for node array      */
X		  down_col,		/* column-coordinate for node array   */
X		  up_row,		/* row-coordinate for node array      */
X		  up_col,		/* column-coordinate for node array   */
X		  row,			/* cursor row coordinate for node     */
X		  column;		/* cursor column coordinate for node  */
X} NODE_DEF;
X
typedef	 struct	  ARG_TYP {		/* run-time argument flags	      */
X	 short	  sort,			/* wants files sorted		      */
X		  size,			/* wants size field included	      */
X		  prot,			/* wants protection field included    */
X		  date,			/* wants date field included	      */
X		  def,			/* wants just default info	      */
X		  group,		/* wants group field		      */
X		  owner,		/* wants owner field		      */
X		  wide,			/* wants 132-column mode	      */
X		  confirm,		/* wants to be asked before Xecuting  */
X		  auto_feed,		/* wants autofeed on Delete/Unmark    */
X		  text_startup,		/* set if -t on command line	      */
X		  text,			/* wants text descriptors included    */
X		  dot_files,		/* wants files starting with .	      */
X		  filemarks;		/* / for dirs, * for executables, etc */
X} ARG_DEF;
X
typedef	 struct	  ARG_STR_TYP {		/* strings for configuring on the fly */
X	 char	  string[OPT_STRING_MAX+1];
X	 short	  *ptr;			/* pointer into arg structure	      */
X} ARG_STR;
X
typedef	 struct	  COM_TYP {		/* file command definition type	      */
X	 char	  *copy_name,		/* new filename for copying	      */
X		  *ren_name,		/* new filename for renaming	      */
X		  *text;		/* text descriptor string	      */
X	 gid_t	  group;		/* new group value		      */
X	 uid_t	  owner;		/* new owner for file		      */
X	 u_short  prot;			/* protection value		      */
X	 short	  copy_len,		/* max. length of copy filename str.  */
X		  ren_len,		/* max. length of rename filename str */
X		  text_len;		/* max. length of text string	      */
X	 char	  comm_text,		/* text descriptor for file	      */
X		  comm_del,		/* file is to be deleted	      */
X		  comm_prot,		/* new protection for file	      */
X		  comm_copy,		/* file is to be copied		      */
X		  comm_ren,		/* file is to be renamed	      */
X		  comm_grp,		/* change group of file		      */
X		  comm_own;		/* change owner of file		      */
X	 char	  dummy[3];		/* pad-out; might not be necessary    */
X} COM_DEF;
X
typedef	 struct	  ENT_TYP {		/* file entry definition type	      */
X	 COM_DEF  *command;		/* commands for file		      */
X  	 char	  *filename,		/* real filename		      */
X		  *text;		/* text descriptor		      */
X	 size_t	  size;			/* in blocks			      */
X	 time_t	  time;			/* whatever type of time desired..... */
X	 uid_t	  uid;			/* owner id of file		      */
X	 gid_t	  gid;			/* group id of file		      */
X	 u_short  prot,			/* integer protection value	      */
X		  name_len,		/* length of scr_name minus padding   */
X		  disp_len;		/* displayed length of full filename  */
X	 u_char	  type,			/* file type			      */
X		  mark_flag;		/* set if file is Marked	      */
X	 char	  scr_name[DISP_MAX+1];	/* displayed filename and filemark    */
X} ENT_DEF;
X
typedef	 struct	  POOL_TYP {		/* memory pool node structure	      */
X	 char	  *ptr,			/* pointer to next byte in pool	      */
X		  *first;		/* pointer to beginning of pool	      */
struct	 POOL_TYP *next_pool;		/* pointer to next memory pool	      */
X	 size_t	  remaining,		/* # of remaining bytes in pool	      */
X		  length;		/* original length of pool	      */
X} POOL_DEF;
X
typedef	 struct	  OPT_TYPE {		/* displayed options definition	      */
X	 char	  *keystr,		/* keystroke for command	      */
X	  	  *remaining,		/* rest of chars in command	      */
X		  key_len,		/* length of keystroke for command    */
X		  rem_len,		/* length of rest of chars in command */
X		  spaces;		/* number of spaces after command def */
X} OPT_DEF;
X
typedef	 struct	  {			/* saved uid/gid entry		      */
X	 uid_t	  id;			/* uid/gid saved		      */
X	 char	  str[ID_STR_MAX+1];	/* associated string		      */
X} ID_ENT;
X
typedef	 struct	  {			/* summary info of directory entries  */
X	 ENT_DEF  *ptr;			/* pointer to directory info	      */
X	 short	  num_file;		/* number of files in directory	      */
X} DIR_SUMM;
X
typedef	 struct	  DIR_TYPE {		/* directory info link structure      */
X	 ENT_DEF  *dirptr;		/* pointer to directory information   */
X	 char	  *dir_name;		/* name of directory		      */
struct	 DIR_TYPE *prev,		/* pointer to previous directory node */
X		  *next;		/* pointer to next directory node     */
X	 POOL_DEF *first_pool,		/* first memory pool for directory    */
X		  *curr_pool;		/* current memory pool for directory  */
X	 size_t	  pool_length;		/* length for allocating new pools    */
X	 time_t	  stat_time;		/* when directory was last modified   */
X	 u_short  count;		/* number of times directory entered  */
X	 short	  num_file;		/* number of files in directory	      */
X} DIR_PTR;
X
X/******************************************************************************/
X/*                                                                            */
X/*   E X T E R N A L   D E F I N I T I O N S   &   D E C L A R A T I O N S    */
X/*                                                                            */
X/******************************************************************************/
X
X
X/******************************************************************************/
X/*                                                                            */
X/*     S T A T I C   D E F I N I T I O N S   &   D E C L A R A T I O N S      */
X/*                                                                            */
X/******************************************************************************/
X
X#endif
END_OF_FILE
if test 15883 -ne `wc -c <'maint.h.dist'`; then
    echo shar: \"'maint.h.dist'\" unpacked with wrong size!
fi
# end of 'maint.h.dist'
fi
if test -f 'options.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'options.c'\"
else
echo shar: Extracting \"'options.c'\" \(12468 characters\)
sed "s/^X//" >'options.c' <<'END_OF_FILE'
X/******************************************************************************
X*******************************************************************************
X
X   Site:	Western Michigan University Academic Computer Center
X
X   System:	Directory/File System Maintenance
X  
X   Program:	maint
X
X   Version=01	Level=00	01/24/92	Leonard J. Peirce
X
X   Purpose:	Allow the user to change the configuration options on the fly.
X
X   Arguments:	See individual routine(s).
X
X   External variables:	None
X
X   Maint external functions:
X
X	Defined:	config_options
X
X	Called:
X
X   Files accessed:	None
X
X   Return codes:	See individual routine(s).
X
X   Compiling instructions:	See Makefile
X
X   Linking instructions:	See Makefile
X
X   Other information:	(C) Copyright 1992, Leonard J. Peirce
X
X********************************************************************************
X*******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*                        # I N C L U D E   F I L E S                         */
X/*                                                                            */
X/******************************************************************************/
X
X#ifdef ultrix
X#include <cursesX.h>
X#else
X#include <curses.h>
X#endif
X#include "maint.h"
X
X/******************************************************************************/
X/*                                                                            */
X/*                             # D E F I N E S                                */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*          S T R U C T U R E S ,   U N I O N S ,   T Y P E D E F S           */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*   E X T E R N A L   D E F I N I T I O N S   &   D E C L A R A T I O N S    */
X/*                                                                            */
X/******************************************************************************/
X
extern	 ARG_STR  arg_strings[];
X
X	 int	  config_options();
X
X/******************************************************************************/
X/*                                                                            */
X/*     S T A T I C   D E F I N I T I O N S   &   D E C L A R A T I O N S      */
X/*                                                                            */
X/******************************************************************************/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	config_options
X
X  Purpose:	Let the user view/change configuration options.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	REBUILD_DIRECTORY	entire directory must be reinitialized
X	REBUILD_SCREEN		only screen layout was affected
X	REBUILD_WITH_FILEMARKS	include filemarks for files
X	REBUILD_WITH_SORT	sort files when rebuild is performed
X	NO_REBUILD		don't have to rebuild anything
X
X********************************************************************************
X*******************************************************************************/
X
int config_options(args)
X					/*******   FORMAL  PARAMETERS   *******/
register ARG_DEF *args;			/* run-time arguments		      */
X
X{	/*** config_options ***/
X					/********   LOCAL  VARIABLES   ********/
register short	  term_code;		/* keystroke read in		      */
X	 WINDOW	  *window;		/* for displaying/reading options     */
X	 int	  rows,			/* rows in option window	      */
X		  columns,		/* columns in option window	      */
X		  curr_row,		/* current screen row		      */
X		  curr_col,		/* current screen column	      */
X		  retval;		/* return code			      */
X	 short	  i;			/* loop and array index		      */
X	 ARG_DEF  tmp_args;		/* for saving current arguments	      */
X	 char	  buf[MAX_SCREEN_COLS+1];
static	 char	  *opt_banner[] = {
X"                               Configuration menu",
X"      Use Arrow Keys to select, space to toggle option, control-D to finish"};
X
X
X   /* save current run-time arguments to see if anything has actually
X    * changed when the user is done
X    */
X
X   memcpy(&tmp_args,args,sizeof(tmp_args));
X
X   /* set up the screen */
X
X   rows = LINES - SPEC_WINDOW_ROWS;
X   columns = COLS;
X   window = newwin(rows,columns,2,0);
X   werase(window);
X   keypad(window,TRUE);
X   curr_row = 0;
X
X   /* write the configuration options and their current values */
X
X   while(curr_row < NUM_OPT_STRINGS)
X   {
X      /* create the line first */
X
X      if(curr_row == SORT_OPT)
X      {
X	 strcpy(buf,arg_strings[SORT_OPT].string);
X
X	 switch(args->sort)
X	 {
X	    case(DATE):
X
X	       strcat(buf,"date    ");
X	       break;
X
X	    case(SIZE):
X
X	       strcat(buf,"size    ");
X	       break;
X
X	    case(FILENAME):
X
X	       strcat(buf,"filename");
X	       break;
X
X	    default:
X
X	       strcat(buf,"none    ");
X	       break;
X	 }
X      }
X      else
X      {
X	 strcpy(buf,arg_strings[curr_row].string);
X	 strcat(buf,*(arg_strings[curr_row].ptr) ? "yes" : "no ");
X      }
X
X      mvwaddstr(window,curr_row++,1,buf);
X   }
X
X   /* print the instructions for changing the options */
X
X   i = rows - (sizeof(opt_banner) / sizeof(char *));
X
X   while(curr_row < i)
X   {
X      wmove(window,curr_row,0);
X      waddch(window,'X');
X      wmove(window,curr_row,0);
X      wclrtoeol(window);
X      curr_row++;
X   }
X
X   /* write the instructions to the screen */
X
X   i = 0;
X   wattron(window,A_BOLD);
X
X   while(i < (sizeof(opt_banner) / sizeof(char *)))
X      mvwaddstr(window,curr_row++,0,opt_banner[i++]);
X
X   curr_row = 0;
X   curr_col = 0;
X   wmove(window,curr_row,curr_col);
X   wrefresh(window);
X
X   /* now ask for input until the user presses ESCAPE to exit */
X
X   term_code = wgetch(window);
X
X   while(term_code != CONTROL_D)
X   {
X      switch(term_code)
X      {
X	 case('G'):
X	 case('g'):
X	    term_code = ' ';
X	    curr_row = GROUP_OPT;
X	    break;
X
X	 case('O'):
X	 case('o'):
X	    term_code = ' ';
X	    curr_row = OWNER_OPT;
X	    break;
X
X	 case('s'):
X	    term_code = ' ';
X	    curr_row = SIZE_OPT;
X	    break;
X
X	 case('P'):
X	 case('p'):
X	    term_code = ' ';
X	    curr_row = PROT_OPT;
X	    break;
X
X	 case('D'):
X	 case('d'):
X	    term_code = ' ';
X	    curr_row = DATE_OPT;
X	    break;
X
X	 case('T'):
X	 case('t'):
X	    term_code = ' ';
X	    curr_row = TEXT_OPT;
X	    break;
X
X	 case('C'):
X	 case('c'):
X	    term_code = ' ';
X	    curr_row = CONFIRM_OPT;
X	    break;
X
X	 case('A'):
X	    term_code = ' ';
X	    curr_row = AUTO_FEED_OPT;
X	    break;
X
X	 case('a'):
X	    term_code = ' ';
X	    curr_row = DOT_FILES_OPT;
X	    break;
X
X	 case('f'):
X	    term_code = ' ';
X	    curr_row = FILEMARKS_OPT;
X	    break;
X
X	 case('S'):
X	    term_code = ' ';
X	    curr_row = SORT_OPT;
X	    break;
X
X	 default:
X	    break;
X      }
X
X      switch(term_code)
X      {
X	 case('j'):
X	 case('J'):
X	 case(CARRIAGE_RETURN):
X	 case(KEY_DOWN):
X	 case(LINEFEED):
X
X	    if(curr_row < (NUM_OPT_STRINGS - 1))
X	       wmove(window,++curr_row,curr_col);
X	    else
X	    {
X	       curr_row = 0;
X	       wmove(window,curr_row,curr_col);
X	    }
X
X	    break;
X
X	 case('^'):
X	 case('K'):
X	 case('k'):
X	 case(KEY_UP):
X
X	    if(curr_row > 0)
X	       wmove(window,--curr_row,curr_col);
X	    else
X	    {
X	       curr_row = NUM_OPT_STRINGS - 1;
X	       wmove(window,curr_row,curr_col);
X	    }
X
X	    break;
X
X	 case(' '):
X
X	    /* see where the user was when they toggled */
X
X	    switch(curr_row)
X	    {
X	       case(SIZE_OPT):
X
X		  args->size = !args->size;
X		  strcpy(buf,arg_strings[SIZE_OPT].string);
X		  strcat(buf,*(arg_strings[SIZE_OPT].ptr) ? "yes" : "no ");
X		  mvwaddstr(window,curr_row,1,buf);
X		  wmove(window,curr_row,0);
X		  break;
X
X	       case(PROT_OPT):
X
X		  args->prot = !args->prot;
X		  strcpy(buf,arg_strings[PROT_OPT].string);
X		  strcat(buf,*(arg_strings[PROT_OPT].ptr) ? "yes" : "no ");
X		  mvwaddstr(window,curr_row,1,buf);
X		  wmove(window,curr_row,0);
X		  break;
X
X	       case(DATE_OPT):
X
X		  args->date = !args->date;
X		  strcpy(buf,arg_strings[DATE_OPT].string);
X		  strcat(buf,*(arg_strings[DATE_OPT].ptr) ? "yes" : "no ");
X		  mvwaddstr(window,curr_row,1,buf);
X		  wmove(window,curr_row,0);
X		  break;
X
X	       case(GROUP_OPT):
X
X		  args->group = !args->group;
X		  strcpy(buf,arg_strings[GROUP_OPT].string);
X		  strcat(buf,*(arg_strings[GROUP_OPT].ptr) ? "yes" : "no ");
X		  mvwaddstr(window,curr_row,1,buf);
X		  wmove(window,curr_row,0);
X		  break;
X
X	       case(OWNER_OPT):
X
X		  args->owner = !args->owner;
X		  strcpy(buf,arg_strings[OWNER_OPT].string);
X		  strcat(buf,*(arg_strings[OWNER_OPT].ptr) ? "yes" : "no ");
X		  mvwaddstr(window,curr_row,1,buf);
X		  wmove(window,curr_row,0);
X		  break;
X
X	       case(CONFIRM_OPT):
X
X		  args->confirm = !args->confirm;
X		  strcpy(buf,arg_strings[CONFIRM_OPT].string);
X		  strcat(buf,*(arg_strings[CONFIRM_OPT].ptr) ? "yes" : "no ");
X		  mvwaddstr(window,curr_row,1,buf);
X		  wmove(window,curr_row,0);
X		  break;
X
X	       case(AUTO_FEED_OPT):
X
X		  args->auto_feed = !args->auto_feed;
X		  strcpy(buf,arg_strings[AUTO_FEED_OPT].string);
X		  strcat(buf,*(arg_strings[AUTO_FEED_OPT].ptr) ? "yes" : "no ");
X		  mvwaddstr(window,curr_row,1,buf);
X		  wmove(window,curr_row,0);
X		  break;
X
X	       case(TEXT_OPT):
X
X		  args->text = !args->text;
X
X		  /* set the text_startup flag so that the width of the
X		   * of the text descriptors won't be taken into account
X		   * when updating def_slot_wid in set_args()
X		   */
X
X		  args->text_startup = !args->text_startup;
X		  strcpy(buf,arg_strings[TEXT_OPT].string);
X		  strcat(buf,*(arg_strings[TEXT_OPT].ptr) ? "yes" : "no ");
X		  mvwaddstr(window,curr_row,1,buf);
X		  wmove(window,curr_row,0);
X		  break;
X
X	       case(DOT_FILES_OPT):
X
X		  args->dot_files = !args->dot_files;
X		  strcpy(buf,arg_strings[DOT_FILES_OPT].string);
X		  strcat(buf,*(arg_strings[DOT_FILES_OPT].ptr) ? "yes" : "no ");
X		  mvwaddstr(window,curr_row,1,buf);
X		  wmove(window,curr_row,0);
X		  break;
X
X	       case(FILEMARKS_OPT):
X
X		  args->filemarks = !args->filemarks;
X		  strcpy(buf,arg_strings[FILEMARKS_OPT].string);
X		  strcat(buf,*(arg_strings[FILEMARKS_OPT].ptr) ? "yes" : "no ");
X		  mvwaddstr(window,curr_row,1,buf);
X		  wmove(window,curr_row,0);
X		  break;
X
X	       case(SORT_OPT):
X
X		  args->sort = (args->sort + 1) % (NUM_SORT_OPT + 1);
X		  strcpy(buf,arg_strings[SORT_OPT].string);
X
X		  switch(args->sort)
X		  {
X		     case(DATE):
X
X			strcat(buf,"date    ");
X			break;
X
X		     case(TYPE):
X
X			strcat(buf,"type    ");
X			break;
X
X		     case(SIZE):
X
X			strcat(buf,"size    ");
X			break;
X
X		     case(FILENAME):
X
X			strcat(buf,"filename");
X			break;
X
X		     default:
X
X			strcat(buf,"none    ");
X			break;
X		  }
X
X		  mvwaddstr(window,curr_row,1,buf);
X		  wmove(window,curr_row,0);
X		  break;
X
X	       default:			/* shouldn't happen		      */
X
X		  break;
X	    }
X
X	    break;
X
X	 default:
X
X	    beep();
X	    break;
X      }
X
X      wrefresh(window);
X      term_code = wgetch(window);
X   }
X
X   werase(window);			/* kill everything		      */
X   wrefresh(window);
X   delwin(window);
X
X   retval = NO_REBUILD;
X
X   if(memcmp(&tmp_args,args,sizeof(tmp_args)) != 0)
X   {
X      /* something really happened */
X
X      if(args->dot_files != tmp_args.dot_files)
X	 retval |= REBUILD_DIRECTORY;
X
X      if(args->size != tmp_args.size ||
X	 args->prot != tmp_args.prot ||
X	 args->date != tmp_args.date ||
X	 args->owner != tmp_args.owner ||
X	 args->group != tmp_args.group ||
X	 args->filemarks != tmp_args.filemarks ||
X	 args->sort != tmp_args.sort ||
X	 args->text != tmp_args.text)
X	 retval |= REBUILD_SCREEN;
X
X      if(args->filemarks != tmp_args.filemarks)
X	 retval |= REBUILD_WITH_FILEMARKS;
X
X      if(args->sort && !tmp_args.filemarks)
X	 retval |= REBUILD_WITH_SORT;
X   }
X
X   return(retval);
X
X}	/*** config_options ***/
END_OF_FILE
if test 12468 -ne `wc -c <'options.c'`; then
    echo shar: \"'options.c'\" unpacked with wrong size!
fi
# end of 'options.c'
fi
if test -f 'pool.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pool.c'\"
else
echo shar: Extracting \"'pool.c'\" \(13024 characters\)
sed "s/^X//" >'pool.c' <<'END_OF_FILE'
X/******************************************************************************
X*******************************************************************************
X
X   Site:	Western Michigan University Academic Computer Center
X
X   System:	Directory/File System Maintenance
X  
X   Program:	maint
X
X   Version=01	Level=00	01/24/92	Leonard J. Peirce
X
X   Purpose:	Routines for handling memory pools.
X
X   Arguments:	See individual routines.
X
X   External variables:	See individual routines.
X
X   External functions:
X
X	Defined:	free_pool, get_pool_mem, init_pool, new_pool, put_pool,
X			reset_pool
X
X	Called:		None
X
X   Files accessed:	None
X
X   Return codes:	See individual routines
X
X   Compiling instructions:	See Makefile
X
X   Linking instructions:	See Makefile
X
X   Other information:	Copyright (C) 1992, Leonard J. Peirce
X
X********************************************************************************
X*******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*                        # I N C L U D E   F I L E S                         */
X/*                                                                            */
X/******************************************************************************/
X
X#include <stdio.h>
X#include <malloc.h>
X#include "maint.h"
X#include <string.h>
X
X/******************************************************************************/
X/*                                                                            */
X/*                             # D E F I N E S                                */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*          S T R U C T U R E S ,   U N I O N S ,   T Y P E D E F S           */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*   E X T E R N A L   D E F I N I T I O N S   &   D E C L A R A T I O N S    */
X/*                                                                            */
X/******************************************************************************/
X
X	 char	  *get_pool_mem();
X
X	 POOL_DEF *new_pool();
X
X	 void	  init_pool(),
X		  put_pool(),
X		  free_pool(),
X		  reset_pool();
X
X/******************************************************************************/
X/*                                                                            */
X/*     S T A T I C   D E F I N I T I O N S   &   D E C L A R A T I O N S      */
X/*                                                                            */
X/******************************************************************************/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	init_pool
X
X  Purpose:	Allocate the first memory pool for the current directory,
X		initializing the pool structure node and initialize all of
X		the other structures to point to null pools.  The remaining
X		pool node structures are linked together in a linked list.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X                 
X	Code			Reason
X	----			------
X	none
X
X  Termination Codes:
X
X	Code			Reason
X	----			------
X	CANT_ALLOC		cannot allocate memory
X
X********************************************************************************
X*******************************************************************************/
X
void init_pool(pool,pool_length)
X					/*******   FORMAL  PARAMETERS   *******/
X	 POOL_DEF **pool;		/* array of pool node structures      */
X	 size_t	  pool_length;		/* length of pool to allocate	      */
X
X{	/*** init_pool ***/
X					/********   LOCAL  VARIABLES   ********/
register POOL_DEF *tptr;		/* temporary pool node structure ptr  */
X
X
X   /* allocate memory for the pool node structure first */
X
X   tptr = (POOL_DEF *) malloc(sizeof(POOL_DEF));
X
X   if(tptr == NULL)
X   {
X      puts("*ERROR*  Cannot allocate memory in init_pool #1");
X      exit(CANT_ALLOCATE);
X   }
X
X   /* allocate memory for the first pool and initialize all of the other
X    * accounting stuff associated with it
X    */
X
X   tptr->first = (char *) malloc((u_int) pool_length);
X
X   if(tptr == NULL)
X   {
X      puts("*ERROR*  Cannot allocate memory in init_pool #2");
X      exit(CANT_ALLOCATE);
X   }
X
X   /* set up the other stuff for the first memory pool */
X
X   tptr->ptr = tptr->first;		/* set pointer to available memory    */
X   tptr->remaining = pool_length;	/* all bytes in pool available	      */
X   tptr->next_pool = NULL;		/* terminate the linked list....      */
X   tptr->length = pool_length;		/* save original length of pool	      */
X   *pool = tptr;			/* start everything....		      */
X
X   return;
X
X}	/*** init_pool ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	reset_pool
X
X  Purpose:	Reset the pool pointers so that the memory allocated for them
X		can be used again without reallocating the memory.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	none
X
X********************************************************************************
X*******************************************************************************/
X
void reset_pool(pool)
X					/*******   FORMAL  PARAMETERS   *******/
register POOL_DEF *pool;		/* memory pool node structures	      */
X
X{	/*** reset_pool ***/                 
X
X   while(pool != NULL)
X   {
X      pool->ptr = pool->first;		/* reset available byte pointer	      */
X      pool->remaining = pool->length;	/* reset number of bytes available    */
X      pool = pool->next_pool;		/* go to next pool node structure     */
X   }
X
X   return;
X
X}	/*** reset_pool ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	new_pool
X
X  Purpose:	allocate memory for a pool node structure and the actual
X		memory for the pool; also link the pool to the pool list.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	none
X
X********************************************************************************
X*******************************************************************************/
X
POOL_DEF *new_pool(pool,pool_length)
X					/*******   FORMAL  PARAMETERS   *******/
register POOL_DEF *pool;		/* pointer to current memory pool     */
X	 size_t	  pool_length;		/* length of pool to allocate	      */
X
X{	/*** new_pool ***/
X					/********   LOCAL  VARIABLES   ********/
X	 POOL_DEF *tptr;		/* temporary pool pointer	      */
X
X
X   /* first see if there is a pool already out there; if there is,
X    * just return so that we don't have to reuse the memory
X    */
X
X   if(pool->next_pool != NULL)		/* is there a pool out there?	      */
X      return(pool->next_pool);		/* yes, just return a pointer to it   */
X
X   /* at this point we have conceded that a new memory pool is needed; allocate
X    * the structure to hold the new pool's accounting information
X    */
X
X   init_pool(&tptr,pool_length);
X
X   pool->next_pool = tptr;		/* link to current pool		      */
X   pool = pool->next_pool;		/* move to new pool structure	      */
X
X   return(tptr);			/* return pointer to new pool struct. */
X
X}	/*** new_pool ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	put_pool
X
X  Purpose:	Copy a string to a memory pool.  If the current pool does not
X		have enough memory to accomodate the string, allocate a new
X		pool first and then copy the string to the new pool.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	none
X
X********************************************************************************
X*******************************************************************************/
X
void put_pool(dest,pool,str,length,pool_length)
X					/*******   FORMAL  PARAMETERS   *******/
X	 char	  **dest;		/* where to store pointer to str      */
X	 POOL_DEF **pool;		/* current memory pool structure      */
X	 char	  *str;			/* string to be stored in memory pool */
X	 size_t	  length;		/* length of string to be stored      */
X	 size_t	  pool_length;		/* length of pool if we need another  */
X                
X{	/*** put_pool ***/
X					/********   LOCAL  VARIABLES   ********/
register POOL_DEF *tptr;		/* temporary pool structure pointer   */
X
X
X   if((*pool)->remaining < (length + 1)) /* has the pool run dry....?	      */
X   {
X      *pool = new_pool(*pool,pool_length); /* yes, get another pool	      */
X   }
X
X   tptr = *pool;			/* set up temporary pool struct. ptr. */
X   strcpy(tptr->ptr,str);		/* copy the string to the pool	      */
X   *dest = tptr->ptr;			/* set the pointer to the string      */
X   tptr->ptr = tptr->ptr + length + 1;	/* update available memory pointer    */
X   tptr->remaining = tptr->remaining - (length + 1);
X
X   return;
X
X}	/*** put_pool ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	get_pool_mem
X
X  Purpose:	Return a pointer to a memory slot that will satisfy the request.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	retptr			pointer to memory slot
X
X********************************************************************************
X*******************************************************************************/
X
char *get_pool_mem(pool,pool_length,length)
X					/*******   FORMAL  PARAMETERS   *******/
register POOL_DEF **pool;		/* current memory pool		      */
X	 size_t	  pool_length,		/* length of pool to request	      */
X		  length;		/* length of memory slot needed	      */
X
X{	/*** get_pool_mem ***/
X					/********   LOCAL  VARIABLES   ********/
register char	  *retptr;		/* pointer to return		      */
register POOL_DEF *tptr;		/* used to speed things up a bit....  */
X
X
X   /* is there enough room in the current memory pool?  If not, allocate
X    * another one and get the memory from there
X    */
X
X   if((*pool)->remaining < (length + 1))
X      *pool = new_pool(*pool,pool_length);
X
X   tptr = *pool;			/* make a pointer		      */
X
X   /* we have the memory, whether it is in a new pool or the one we had on
X    * entry; update the pool structure to reflect the memory that we need
X    * to take from it
X    */
X
X   retptr = tptr->ptr;			/* save pointer to memory slot	      */
X   tptr->ptr = tptr->ptr + length + 1L;
X   tptr->remaining = tptr->remaining - (length + 1);
X   
X   return(retptr);			/* return pointer to slot	      */
X
X}	/*** get_pool_mem ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	free_pool
X
X  Purpose:	Free the memory of all of the memory pools for a directory,
X		including the node structures for all of the nodes.  This
X		routine will be called when exiting a directory.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code 			Reason
X	----			------
X	none
X
X********************************************************************************
X*******************************************************************************/
X
void free_pool(pool)
X					/*******   FORMAL  PARAMETERS   *******/
register POOL_DEF *pool;		/* first pool in pool node list	      */
X
X{	/*** free_pool ***/
X					/********   LOCAL  VARIABLES   ********/
register POOL_DEF *tpool;		/* temporary pool node pointer	      */
X
X
X
X   while(pool != NULL)
X   {
X      /* free the memory for the pool first */
X
X      tpool = pool->next_pool;		/* save pointer to next pool node     */
X      free(pool->first);		/* free the memory		      */
X      free((char *) pool);		/* free memory for pool node struct.  */
X      pool = tpool;			/* move to next pool in list	      */
X   }
X
X   return;
X
X}	/*** free_pool ***/
END_OF_FILE
if test 13024 -ne `wc -c <'pool.c'`; then
    echo shar: \"'pool.c'\" unpacked with wrong size!
fi
# end of 'pool.c'
fi
if test -f 'slot.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'slot.c'\"
else
echo shar: Extracting \"'slot.c'\" \(16586 characters\)
sed "s/^X//" >'slot.c' <<'END_OF_FILE'
X/******************************************************************************
X*******************************************************************************
X
X   Site:	Western Michigan University Academic Computer Center
X
X   System:	Directory/File System Maintenance
X  
X   Program:	maint
X
X   Version=01	Level=00	01/24/92	Leonard J. Peirce
X
X   Purpose:	Routines for creating file slots and gathering info for
X		Expanding.
X
X   Arguments:	See individual routines.
X
X   External variables:	None
X
X   WMU external functions:
X
X          Defined:	get_group, get_owner, make_slot
X
X          Called:	add_filetype, mystrcpy, mystrmcpy, padcpy,
X			prot_val_to_str, set_date
X
X   Files accessed:	See individual routines.
X
X   Return codes:	See individual routines.
X
X   Compiling instructions:	See Makefile.
X
X   Linking instructions:	See Makefile.
X
X   Other information:	(C) Copyright 1992, Leonard J. Peirce
X
X********************************************************************************
X*******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*                        # I N C L U D E   F I L E S                         */
X/*                                                                            */
X/******************************************************************************/
X
X#ifdef ultrix
X#include <cursesX.h>
X#else
X#include <curses.h>
X#endif
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X#include <pwd.h>
X#include <grp.h>
X#include "maint.h"
X
X/******************************************************************************/
X/*                                                                            */
X/*                             # D E F I N E S                                */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*          S T R U C T U R E S ,   U N I O N S ,   T Y P E D E F S           */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*   E X T E R N A L   D E F I N I T I O N S   &   D E C L A R A T I O N S    */
X/*                                                                            */
X/******************************************************************************/
X
extern	 char	  *mystrcpy(),
X		  *mystrmcpy(),
X		  *prot_val_to_str(),
X		  *padcpy(),
X		  *set_date();
X
X#if defined(SYSV) || defined(sun)
extern	 void	  setpwent(),
X		  setgrent();
X#else
extern	 int	  setpwent(),
X		  setgrent();
X#endif
X
extern	 u_short  add_filetype();
X
X	 char	  *get_owner(),
X		  *get_group();
X
X	 int	  make_slot();
X
X/******************************************************************************/
X/*                                                                            */
X/*     S T A T I C   D E F I N I T I O N S   &   D E C L A R A T I O N S      */
X/*                                                                            */
X/******************************************************************************/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	make_slot
X
X  Purpose:	Make a slot to be displayed on the screen for a file depending
X		on the (possible) commands associated with the file.  In
X		some cases, some funny stuff will be done with the screen
X		slot to connotate that the file has some commands associated
X		with it.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	A_NORMAL		file slot is normal
X	A_BOLD			file has commands; highlite it
X
X********************************************************************************
X*******************************************************************************/
X
int make_slot(buf,ent,args,slot_width,text_flag)
X			 		/*******   FORMAL  PARAMETERS   *******/
X	 char	  *buf;			/* where to put the screen slot	      */
register ENT_DEF  *ent;			/* file entry pointer		      */
register ARG_DEF  *args;		/* run-time arguments		      */
X	 short	  slot_width,		/* width of a screen slot	      */
X		  text_flag;		/* whether we display text descrips   */
X
X{	/*** make_slot ***/
X					/********   LOCAL  VARIABLES   ********/
register char	  *tptr;		/* temporary pointer		      */
X	 char	  *text_ptr = NULL;	/* pointer to text descriptor	      */
X	 COM_DEF  *ptr;			/* pointer to possible command struct */
static	 u_short  pass;			/* set if we've been here before      */
static	 char	  gap_buf[FIELD_GAP+1],	/* inter-field gap buffer	      */
X		  gap_buf2[SLOT_GAP+1], /* inter-slot gap buffer	      */
X		  text_buf[TEXT_MAX+1],	/* for formatting text descriptors    */
X		  size_buf[SIZE_MAX+1],	/* for formatting size of file	      */
X		  blnk_text[TEXT_MAX+1], /* blank text descriptor	      */
X		  del_str1[] = {"<del>"},
X		  del_str2[] = {"<delete>"};
X
X
X   if(!pass)
X   {
X      for(pass = 0; pass < FIELD_GAP; pass++)
X	 gap_buf[pass] = ' ';
X      for(pass = 0; pass < SLOT_GAP; pass++)
X	 gap_buf2[pass] = ' ';
X      for(pass = 0; pass < TEXT_MAX; pass++)
X	 blnk_text[pass] = ' ';
X      pass = 1;
X   }
X
X   /* now see if there are commands associated with the file; we do things
X    * a little differently if there are
X    */
X
X   ptr = ent->command;
X
X   if(ptr != NULL)
X   {
X      if(ptr->comm_del)			/* is the file going to be deleted?   */
X      {
X	 /* yes, now see if there is enough room to put in the "<delete>"
X	  * string
X	  */
X
X	 if(slot_width <= (DISP_MAX + sizeof(del_str2)))
X	 {
X	    /* the slot is only big enough to use <del> to signify that the
X	     * file is marked for deletion
X	     */
X
X	    strcpy(buf,ent->scr_name);
X	    strcpy(&buf[DISP_MAX - sizeof(del_str1) + 1],del_str1);
X
X	    if(ent->disp_len > (DISP_MAX - sizeof(del_str1) + 1))
X	    {
X	       buf[slot_width] = FLAG_CHAR;
X	       buf[slot_width + 1] = '\0';
X	    }
X	 }
X	 else
X	 {
X	    /* use the regular "<delete>" string to show that the user
X	     * marked the file to be deleted
X	     */
X
X	    sprintf(buf,"%s%s                                         \
X                                    ",ent->scr_name,del_str2);
X
X	    if(ent->disp_len > DISP_MAX)
X	        buf[DISP_MAX + sizeof(del_str2) - 1] = FLAG_CHAR;
X
X	    *(buf + slot_width + SLOT_GAP) = '\0';
X	 }
X
X	 return((int) A_BOLD);		/* just return from here	      */
X      }
X
X      /* no, the file is not going to be deleted, but it might have some other
X       * command associated with it; check them to be sure
X       */
X
X      /* which text descriptor pointer should we use? */
X
X      if(text_flag == DISPLAY_TEXT)	/* should we display text descriptor? */
X      {
X	 /* yes, text descriptors are to be displayed on the screen; now
X	  * determine which, if any, text descriptor to use for the
X	  * current file
X	  */
X
X	 if(ptr->comm_text)		/* use new text descriptor?	      */
X	 {
X	    /* use the new text descriptor for the slot */
X
X	    padcpy(text_buf,ptr->text,TEXT_MAX);
X	    text_ptr = text_buf;	/* set the pointer to the text desc.  */
X	 }
X	 else if(ent->text != NULL)	/* or should we use the original?     */
X	 {
X	    /* use the original text descriptor for the file */
X
X	    padcpy(text_buf,ent->text,TEXT_MAX);
X	    text_ptr = text_buf;	/* set the pointer to the text desc.  */
X	 }
X	 else				/* or should we use a blank desc?     */
X	 {
X	    /* this file has no text descriptor; use a blank one to make
X	     * sure that we completely write over any text descriptor that
X	     * might been written in the current slot before this
X	     */
X
X	    text_ptr = blnk_text;	/* use a blank text descriptor	      */
X	 }
X      }
X   }
X
X   /* now create the slot */
X
X   if(text_flag == DISPLAY_TEXT && !text_ptr)
X   {
X      /* yes, we want text descriptors, they don't overflow the slots,
X       * and this file doesn't have a new one specified for it
X       */
X
X      if(ent->text != NULL)		/* is there a text descriptor?	      */
X      {
X	 /* there IS a text descriptor for this file; pad the text descriptor
X	  * on the right with spaces so that if there was a descriptor on the
X	  * screen in this slot (perhaps from a previous page) it will be
X	  * completely overwritten by the current one
X	  */
X
X	 padcpy(text_buf,ent->text,TEXT_MAX);
X	 text_ptr = text_buf;		/* set the pointer to the text desc.  */
X      }
X      else
X	 text_ptr = blnk_text;		/* use a blank text descriptor	      */
X   }
X
X   /* collect all of the information necessary to make the slot */
X
X   tptr = buf;
X   tptr = mystrcpy(buf,ent->scr_name);
X
X   /* write a gap buf just in case a file still has a FLAG_CHAR there
X    * from before; this can happen when the displayed filename will just fit
X    * on the screen, the user selects Delete, and then Unmarks it;
X    * we don't move tptr because if there is anything else that will
X    * go into this slot, it will just overwrite the extra gap_buf
X    */
X
X   mystrcpy(tptr,gap_buf);
X
X   if(args->owner)
X   {
X      tptr = mystrcpy(tptr,gap_buf);
X      tptr = mystrmcpy(tptr,get_owner(ent->uid),OWNER_MAX);
X   }
X
X   if(args->group)
X   {
X      tptr = mystrcpy(tptr,gap_buf);
X      tptr = mystrmcpy(tptr,get_group(ent->gid),GROUP_MAX);
X   }
X
X   if(args->size)			/* should the size be included?	      */
X   { 
X      tptr = mystrcpy(tptr,gap_buf);
X      sprintf(size_buf,"%8d",ent->size);
X      tptr = mystrcpy(tptr,size_buf);
X   }
X
X   if(args->date)
X   {
X      tptr = mystrcpy(tptr,gap_buf);
X      tptr = mystrcpy(tptr,set_date(ent->time));
X   }
X
X   if(args->prot)
X   {
X      tptr = mystrcpy(tptr,gap_buf);
X      tptr = mystrcpy(tptr,prot_val_to_str(ent->prot));
X   }
X
X   if(text_flag == DISPLAY_TEXT)	/* do we display the text descrips?   */
X   {
X      /* yes, they don't overflow the file slots; now see if there is one
X       * for the current file
X       */
X
X      tptr = mystrcpy(tptr,gap_buf);
X
X      if(text_ptr != NULL)		/* use new text descriptor?	      */
X	 tptr = mystrcpy(tptr,text_ptr);
X      else
X	 tptr = mystrcpy(tptr,blnk_text);
X   }
X
X   if(ent->name_len > DNAME_MAX)	/* flag it if it's too long	      */
X   {
X      if(buf[DISP_MAX] == '\0')
X      {
X	 buf[DISP_MAX] = FLAG_CHAR;
X	 buf[DISP_MAX+1] = '\0';
X      }
X      else
X	 buf[DISP_MAX] = FLAG_CHAR;
X
X      tptr++;
X   }
X
X   tptr = mystrcpy(tptr,gap_buf2);
X
X   return(ent->command ? (int) A_BOLD : (int) A_NORMAL);
X
X}	/*** make_slot ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	get_group	
X
X  Purpose:	Return the string associated with a group id.  Gids that are
X		successfully translated are saved to speed up future trans-
X		lations.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	retptr			pointer to group string, padded out to
X				ID_STR_MAX with spaces
X
X********************************************************************************
X*******************************************************************************/
X
char *get_group(gid)
X					/*******   FORMAL  PARAMETERS   *******/
X	 gid_t	  gid;			/* group id value		      */
X
X{	/*** get_group ***/
X					/********   LOCAL  VARIABLES   ********/
struct	 group	  *gptr;		/* for using getgrent		      */
X	 char	  *retptr;		/* group string to return	      */
X	 u_short  i;			/* loop and array index		      */
static	 u_short  count;		/* number of group ids saved	      */
static	 ID_ENT	  groups[GROUP_SAVE];	/* list of groups already retrieved   */
static	 char	  buf[ID_STR_MAX+1];	/* used for formatting		      */
X
X
X   /* first search the groups that are already saved */
X
X   i = 0;
X   while((i < count) && gid != groups[i].id)
X      ++i;
X
X   if(i >= count)			/* did we find the gid?		      */
X   {
X      gptr = getgrgid((int) gid);	/* nope, go get it....		      */
X
X      if(gptr != NULL)			/* did we find it?		      */
X      {
X	 /* we found it; now save it if we have room */
X
X	 if(count < GROUP_SAVE)		/* do we have room?		      */
X	 {
X	    groups[count].id = gid;	/* yes, save the gid and string...    */
X	    padcpy(groups[count].str,gptr->gr_name,ID_STR_MAX);
X	    retptr = groups[count].str;
X	    count++;			/* count it since we saved it	      */
X	 }
X	 else
X	 {
X	    /* no room to save it; put it in buf, padded with spaces on the
X	     * right
X	     */
X
X	    padcpy(buf,gptr->gr_name,ID_STR_MAX);
X	    retptr = buf;
X	 }
X      }
X      else
X      {
X	 /* we didn't find it; convert the gid to a string and use that */	    
X	 sprintf(buf,"%-8d",gid);
X
X	 /* we might as well save it just in case we get another file
X	  * that has the same gid
X	  */
X
X	 if(count < GROUP_SAVE)		/* do we have room?		      */
X	 {
X	    groups[count].id = gid;	/* yes, save the gid and string...    */
X	    padcpy(groups[count].str,buf,ID_STR_MAX);
X	    retptr = groups[count].str;	/* set return pointer		      */
X	    count++;
X	 }
X	 else
X	    retptr = buf;		/* no room to save it		      */
X      }
X
X      setgrent();			/* to rewind the file, basically..... */
X   }
X   else
X      retptr = groups[i].str;		/* we found it....		      */
X
X   return(retptr);
X
X}	/*** get_group ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	get_owner	
X
X  Purpose:	Return the string corresponding to the owner of a file
X		based on the uid that is passed.  Uids that are successfully
X		translated are saved to speed up future translations.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	retptr			pointer to owner string, padded out to
X				ID_STR_MAX with spaces
X
X********************************************************************************
X*******************************************************************************/
X
char *get_owner(uid)
X					/*******   FORMAL  PARAMETERS   *******/
X	 uid_t	  uid;			/* user id value		      */
X
X{	/*** get_owner ***/
X					/********   LOCAL  VARIABLES   ********/
struct	 passwd	  *uptr;		/* for using getpwuid		      */
X	 char	  *retptr;		/* owner string to return	      */
X	 u_short  i;			/* loop and array index		      */
static	 u_short  count;		/* number of user ids saved	      */
static	 ID_ENT	  owners[OWNER_SAVE];	/* list of user ids already retrieved */
static	 char	  buf[ID_STR_MAX+1];	/* used for formatting		      */
X
X
X   /* first search the uids that are already saved */
X
X   i = 0;
X   while((i < count) && uid != owners[i].id)
X      ++i;
X
X   if(i >= count)			/* did we find the uid?		      */
X   {
X      uptr = getpwuid((int) uid);	/* nope, go get it....		      */
X
X      if(uptr != NULL)			/* did we find it?		      */
X      {
X	 /* we found it; now save it if we have room */
X
X	 if(count < OWNER_SAVE)		/* do we have room?		      */
X	 {
X	    owners[count].id = uid;	/* yes, save the uid and string...    */
X	    padcpy(owners[count].str,uptr->pw_name,ID_STR_MAX);
X	    retptr = owners[count].str;
X	    count++;			/* count it since we saved it	      */
X	 }
X	 else
X	 {
X	    /* no room to save it; put it in buf, padded with spaces on the
X	     * right
X	     */
X
X	    padcpy(buf,uptr->pw_name,ID_STR_MAX);
X	    retptr = buf;
X	 }
X      }
X      else
X      {
X	 /* we didn't find it; convert the gid to a string and use that */	    
X	 sprintf(buf,"%-8d",uid);
X
X	 /* we might as well save it just in case we get another file
X	  * that has the same uid
X	  */
X
X	 if(count < OWNER_SAVE)		/* do we have room?		      */
X	 {
X	    owners[count].id = uid;	/* yes, save the gid and string...    */
X	    padcpy(owners[count].str,buf,ID_STR_MAX);
X	    retptr = owners[count].str;
X	    count++;			/* count it since we saved it	      */
X	 }
X	 else
X	    retptr = buf;
X      }
X
X      setpwent();			/* to rewind the file, basically..... */
X   }
X   else
X      retptr = owners[i].str;		/* we found it....		      */
X
X   return(retptr);
X
X}	/*** get_owner ***/
END_OF_FILE
if test 16586 -ne `wc -c <'slot.c'`; then
    echo shar: \"'slot.c'\" unpacked with wrong size!
fi
# end of 'slot.c'
fi
echo shar: End of archive 2 \(of 7\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
