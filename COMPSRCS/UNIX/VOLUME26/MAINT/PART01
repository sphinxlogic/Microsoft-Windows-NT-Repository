Newsgroups: comp.sources.unix
From: peirce@gw.wmich.edu (Leonard J. Peirce)
Subject: v26i049: maint - full-screen file and directory maintenance tool, Part01/07
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: peirce@gw.wmich.edu (Leonard J. Peirce)
Posting-Number: Volume 26, Issue 49
Archive-Name: maint/part01

   Maint is a full-screen file and directory maintenance program.  It will
allow you to do all sorts of things to files and directories with just a few
keystrokes.  It also makes it easier to scan a bunch of directories and sub-
directories very quickly.  It has a number of different startup options for
formatting the information on the screen and the a whole slew of commands
that may be specified.

Leonard J. Peirce               Internet:  peirce@mickey.acs.wmich.edu
Western Michigan University                peirce@gw.wmich.edu
Academic Computing Services
Kalamazoo, MI  49008            Voice:     (616) 387-5469

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 7)."
# Contents:  COPYRIGHT MANIFEST Makefile.dist README args.c edit.c
#   help.c locate.c maint.1 maint.help mem.c select.c sort.c
# Wrapped by vixie@cognition.pa.dec.com on Thu May 14 23:05:42 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'COPYRIGHT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'COPYRIGHT'\"
else
echo shar: Extracting \"'COPYRIGHT'\" \(2928 characters\)
sed "s/^X//" >'COPYRIGHT' <<'END_OF_FILE'
X	       Maint Directory/File Maintenance General Public License
X
X		    (C) Copyright 1992 by Leonard J. Peirce
X
X
X			  	COPYING POLICIES
X
X   Permission is hereby  granted for copying and distribution of copies of the
Maint source  files, and that of  any part  thereof, subject to  the following
license conditions:
X
X    1. You may, without  additional permission from the author, distribute 
X       Maint or components of  Maint, with or without  additions developed
X       by you or by  others at no charge.   You may also  distribute Maint
X       along with any other product  for sale, provided  that the  cost of
X       the bundled  package is the same regardless of whether Maint is in-
X       cluded, and provided that  those interested  only in Maint  must be
X       notified that it is a product freely available from the author.
X
X    2. Furthermore, if you  distribute Maint  software or  parts of Maint,
X       with or without additions developed by you or others, then you must 
X       either  make  available the  source to  all  portions  of the Maint
X       system (exclusive  of any additions made by  you or by others) upon
X       request, or instead you may notify anyone requesting source that it
X       is freely available from the author.
X
X    3. In  addition, you  may  not  omit any of the  copyright  notices on
X       either the source files, the executable file, or the documentation.
X
X    4. Also, you  may not omit transmission of this License agreement with 
X       whatever portions of Maint that are distributed.
X
X    5. Lastly, any  users of  this  software must be  notified that  it is
X       without  warrantee or guarantee  of any nature, express or implied, 
X       nor is there any fitness for use represented.
X
Software is  a malleable  thing and the  author can in  no way  guarantee that
using this  program will not cause grevious  damage to your system.  Of course
this  isn't anticipated, but  if it  does  happen, the author  cannot  be held
liable for any damages either directly or indirectly caused by this event.
X
Modification of the  system is encouraged, providing  that the portions of the
system that  are from the original still  carry the  appropriate copyright no-
tices  and  that the  changed  sections  are clearly  delimited  as such.  The
author requests copies of any changes made to ensure that the various versions
stay reasonably in sync with each other.
X
Note that it is not  permitted to copy, sublicense, distribute or transfer any
of the Maint software except as expressly  indicated herein.  Any  attempts to
do otherwise will be considered a violation of this license and your rights to
the Maint software will be voided.
X
X
Comments on  the system  and/or this licensing agreement are encouraged.  Send
electronic  mail to peirce@gw.wmich.edu.  The text  of this  copyright license
was borrowed from the ELM(tm) Mail System with permission from Dave Taylor.
END_OF_FILE
if test 2928 -ne `wc -c <'COPYRIGHT'`; then
    echo shar: \"'COPYRIGHT'\" unpacked with wrong size!
fi
# end of 'COPYRIGHT'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(871 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X COPYRIGHT                  1	
X MANIFEST                   1	
X Makefile.dist              1	
X README                     1	
X args.c                     1	
X edit.c                     1	
X help.c                     1	
X info.c                     2	
X locate.c                   1	
X main.c                     7	
X maint.1                    1	
X maint.h.dist               2	
X maint.help                 1	
X mark.c                     3	
X mem.c                      1	
X misc.c                     5	
X misc.c.orig                6	
X options.c                  2	
X pool.c                     2	
X screen.c                   4	
X select.c                   1	
X slot.c                     2	
X sort.c                     1	
X text.c                     3	
X xecute.c                   3	
END_OF_FILE
if test 871 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile.dist' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.dist'\"
else
echo shar: Extracting \"'Makefile.dist'\" \(3691 characters\)
sed "s/^X//" >'Makefile.dist' <<'END_OF_FILE'
X################################################################################
X#
X#   Installation:  Western Michigan University Academic Computer Center
X#
X#   System:	Software Tools
X#
X#   Program:	maint
X#
X#   Version=01	Level=00	05/31/90	Leonard J. Peirce
X#
X#   Purpose:	Makefile for building maint.
X#
X#   Syntax:	% make			to build maint
X#		% make install		to install maint
X#
X#   Other:	(C) Copyright 1992, Leonard J. Peirce
X#
X###############################################################################
X
X# INSTRUCTIONS:
X#
X# Pick the correct CC, LIB, and CFLAGS for your site from the examples below.
X# Default values are provided and might be pretty good choices if you're not
X# sure what to use.  Also, set BINDIR, BINMODE, etc., if you want to use
X# the makefile to install maint for you.  HELPFILE has a default below but
X# you should make sure it's correct.
X
X# SunOS:
X# The System V stuff must be installed because maint needs the System V
X# curses.h and curses and termcap libraries; Terminfo must also be installed;
X# gcc can be used but CFLAGS must be modified to include -I/usr/5include and
X# and LFLAGS must be modified to pick up the curses and termcap libraries in
X# /usr/5lib;
X# Also, if you are running SunOS 3.X, you need to add -DSUNOS3 to CFLAGS.
X# Examples:
X#   The following works with the System V C compiler:
X#
X#CC = /usr/5bin/cc
X#DEBUGOPT = -O4
X#CFLAGS = $(DEBUGOPT) -c -DHELPFILE=\"${HELPDIR}/maint.help\"
X#LIBS = -lcurses -ltermcap
X#
X#   If you want to use gcc, you might try:
X#
X#CC = gcc
X#DEBUGOPT = -O
X#CFLAGS = -I/usr/5include $(DEBUGOPT) -c -DHELPFILE=\"${HELPDIR}/maint.help\"
X#LIBS = /usr/5lib/libcurses.a /usr/5lib/libtermcap.a
X
X
X# ULTRIX:
X# ULTRIX needs -lcursesX; realize that maint will only build for ULTRIX 3.0+;
X# the curses library in the older versions won't work
X# ULTRIX sites can also use vcc or gcc for the C compiler
CC = cc
DEBUGOPT = -O
CFLAGS = $(DEBUGOPT) -c -DHELPFILE=\"${HELPDIR}/maint.help\"
LIBS = -lcursesX -ltermcap
X
X# System V:
X# Haven't done much testing in this environment.  It worked fine the last
X# time someone tested it for me (System V Release 3 on a 3b2)
X#CC = cc
X#DEBUGOPT = -O
X#CFLAGS = -DMAXPATHLEN=1024 -DSYSV $(DEBUGOPT) -c -DHELPFILE=\"${HELPDIR}/maint.help\"
X#LIBS = -lcurses -ltermcap
X
X# Set these if you want to use the Makefile to install maint for you
X#
X# BINDIR - where the executable will live
X# BINMODE - protection mode for the executable
X# MANDIR - where the man page will live
X# MANMODE - protection mode for the man page
X# HELPDIR - where the on-line help file will live
X# HELPMODE - protection mode for help file
X# OWNER - of executable, the man page, and the help file
X# GROUP - ditto
X
BINDIR = /usr/local/bin
BINMODE = 755
MANDIR = /usr/local/man/man1
MANMODE = 644
HELPDIR = /usr/local/lib
HELPMODE = 644
OWNER = root
GROUP = daemon
X
X# End of configuration section
X
LDFLAGS = $(DEBUGOPT)
X
OBJECTS = main.o args.o edit.o help.o info.o locate.o mark.o mem.o\
X	  misc.o options.o pool.o screen.o select.o slot.o sort.o text.o\
X	  xecute.o
X
SOURCES = main.c args.c edit.c help.c info.c locate.c mark.c mem.c\
X	  misc.c options.c pool.c screen.c select.c slot.c sort.c text.c\
X	  xecute.c
X
INCLUDES = maint.h
LINTFLAGS = -chxz
X
maint:		${OBJECTS}
X		${CC} ${LDFLAGS} ${OBJECTS} ${LIBS} -o maint
X
X${OBJECTS}:	${INCLUDES}
X
X.c.o:
X		${CC} ${CFLAGS} $*.c
X
clean:
X		-rm -f *.o core a.out
X
lint:
X		-lint ${LINTFLAGS} ${SOURCES} >lint.out
X
tags:		${SOURCES} ${INCLUDES}
X		ctags -t *.[ch]
X
install:	maint
X		install -c -m ${BINMODE} -o ${OWNER} -g ${GROUP} maint ${BINDIR}
X		install -c -m ${MANMODE} -o ${OWNER} -g ${GROUP} maint.1 ${MANDIR}
X		install -c -m ${HELPMODE} -o ${OWNER} -g ${GROUP} maint.hlp ${HELPDIR}
END_OF_FILE
if test 3691 -ne `wc -c <'Makefile.dist'`; then
    echo shar: \"'Makefile.dist'\" unpacked with wrong size!
fi
# end of 'Makefile.dist'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(6597 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
Last update:  01/24/90
X
INTRODUCTION
X   Maint is a full-screen file and directory maintenance program.  It will
allow you to do all sorts of things to files and directories with just a few
keystrokes.  It also makes it easier to scan a bunch of directories and sub-
directories very quickly.  It has a number of different startup options for
formatting the information on the screen and the a whole slew of commands
that may be specified.
X
X   I know the above paragraph seems a little sketchy but after you start using
Maint, I think that you will find that it can be a very useful tool.  We have
been using it for quite a while here and I have gotten a lot of positive feed-
back on it, including many suggestions for improving it.
X
X   I also realize that there are things like Open Window's filemgr and
DECwindows user executive for managing files and directories.  They are
both nice but I personally find maint to be much faster and easier to use
when I'm dealing with *lots* of files and directories.  I'm sure that some
people won't agree with this but hey it's a free country, right? :-)
X
DISTRIBUTION
X   The source code is included so feel free to redistribute it.  I don't
mind as long as the copyright notice (COPYRIGHT) stays with it and you don't
claim you wrote it or try to make money from it.
X
REQUIREMENTS
X   About the only thing that is really needed to build and run maint is a
good version of curses.  System V comes with them by default.  ULTRIX docu-
mentation calls theirs X/Open curses and you have to link with a different
curses library.  I've also heard them called the Terminfo curses.  Basically,
if your curses library has the keypad() routine, you have a pretty good chance
of making maint work.  Maint depends on it and won't build without it.  Systems
that I *know* maint will build and run on are:
X
X	o ULTRIX (3.0 or higher; 2.X doesn't have keypad)
X
X	o SunOS 3.X, 4.X - you must have the System V software installed
X	  because needs the some header files and libraries that contain
X	  the necessary curses stuff.  You can use gcc to compile as long
X	  as you specify the right include directory and link with the
X	  necessary SysV libraries.  Check the Makefile for details.
X
X	  If you're building on a 3.X system, you need to define -DSUNOS3;
X	  it's in the Makefile.
X
X	o System V Release 3
X
X   I would like to say that maint will work on HP/UX, AIX, etc., but I
can't because I don't have access to them.  If you make it work on a system
not listed above, let me know what you had to do and I'll see what I can do
about including your fixes in the next release.
X
X   I'm also pretty anxious to get it ported to Xenix.  If anyone out there
wants to take the time to port it and send me the diffs, I'll be more than
happy to include them.
X
INSTALLATION
X  1.  Copy Makefile.dist to Makefile and copy maint.h.dist to maint.h.
X
X  2.  Look at maint.h and change the #defines for MAX_SCREEN_ROWS and
X      MAX_SCREEN_COLS maximum number of rows/columns for the screens at
X      your site.  The default values are for terminals that are 24x80.  If
X      you use workstations with big windows, adjust them accordingly.  For
X      example, on a Sun 3/60 with a fullscreen window, 60 for MAX_SCREEN_ROWS
X      and 140 for MAX_SCREEN_COLS is nice.  Making them larger than what
X      you need won't cause any problems but might make the executable a
X      little bigger.
X
X      Other things that you might want to change in maint.h:
X
X      - DEFAULT_PAGER - the default is more; make it whatever you want
X      - DEFAULT_EDITOR - default is vi
X      - DEFAULT_SHELL - default is csh
X
X  3.  Look at Makefile and pick what CC, LIBS, and CFLAGS should be used for
X      your site.  Also, set the BINDIR, BINMODE, etc., if you want to use
X      the Makefile to install maint for you.  Make sure to add -DSUNOS3
X      to the CFLAGS definition if you're building on a Sun and you are
X      running SunOS 3.X; this turns on a few typedefs that maint needs.
X
X  4.  Type "make" to build maint.
X
X  5.  Type "make install" if you feel like it.
X
X  6.  That's it.....
X
If you have problems building/installing maint, feel free to call me or send
me some e-mail and let me know how I blew it.  I'll do what I can to make sure
that maint can be installed at your site.
X
HACKING ON THE CODE
X   Since the source is distributed, feel free to hack on the code.  There is
nothing that is real complicated in maint; the code itself is pretty straight-
forward (at least I think so! :^).  You might want to look at the comments at
the top of main.c to get an idea about some of the data structures.
X
X   If you find a bug, you can either 1) fix it yourself, contact me, and
send me the fix, or 2) let me know about it and I'll see what I can do.  I'll
be sending out patches when appropriate.
X
THANKS
X   To Dory Leifer and Mark Knopper @ Merit for letting me borrow a System V
machine for testing and to Dan Bidwell @ Andrews University for doing the
final System V testing.  Also to Steve Simmons at ITI for his suggestions and
code improvements.
X
CONCLUSION
X   I put a lot of work into maint and I would appreciate any comments/
suggestions/flames that you might have.  If you get maint up and running, I
would appreciate it if you would either send me e-mail or phone me, letting
me know that you installed maint and what your thoughts are about it.
X
X   Also, if you port maint to a machine that wasn't listed above and you'd
like the changes encorporated in the next release, send me e-mail describing
what you did.  *DON'T* just send me the diffs.  First describe what you had
to do and THEN send me the diffs.  I get a lot of mail and it is very easy
for me delete the diffs by accident but if I know they're coming, I'll be
especially careful.
X
X   There are a lot of things that I have planned but I haven't implemented
them yet because I felt like maint was suffering from what someone once called
X"creeping featurism."  Thus, if I waited until I had every possible option
and nicety installed it would be quite a while before I could unleash this
on the world.  I feel that in it's current state that it can be quite helpful.
If you have a suggestion feel free to send me e-mail.
X
While I'm sure maint doesn't do everything that everyone could ever want,
I still feel that you will find it useful.  At any rate, I use it quite a
bit, even if no one else does. :-)
X
X--
Leonard J. Peirce               Internet:  peirce@mickey.acs.wmich.edu
Western Michigan University                peirce@gw.wmich.edu
Academic Computing Services
Kalamazoo, MI  49008            Voice:     (616) 387-5469
END_OF_FILE
if test 6597 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'args.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'args.c'\"
else
echo shar: Extracting \"'args.c'\" \(6104 characters\)
sed "s/^X//" >'args.c' <<'END_OF_FILE'
X/******************************************************************************
X*******************************************************************************
X
X   Site:	Western Michigan University Academic Computer Center
X
X   System:	Directory/File System Maintenance
X
X   Program:	maint
X
X   Version=01	Level=00	01/24/92	Leonard J. Peirce
X
X   Purpose:	Routine(s) for parsing run-time arguments.
X
X   Arguments:	See individual routine(s).
X
X   External variables:	See below
X
X   Maint external functions:
X
X	Defined:	get_args
X
X	Called:		None
X
X   Files accessed:	None
X
X   Return codes:	None
X
X   Compiling instructions:	See Makefile
X
X   Linking instructions:	See Makefile
X
X   Other information:	(C) Copyright 1992, Leonard J. Peirce
X
X********************************************************************************
X*******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*                        # I N C L U D E   F I L E S                         */
X/*                                                                            */
X/******************************************************************************/
X
X#include <stdio.h>
X#include <string.h>
X#include "maint.h"
X
X/******************************************************************************/
X/*                                                                            */
X/*                             # D E F I N E S                                */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*          S T R U C T U R E S ,   U N I O N S ,   T Y P E D E F S           */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*   E X T E R N A L   D E F I N I T I O N S   &   D E C L A R A T I O N S    */
X/*                                                                            */
X/******************************************************************************/
X
extern	 char	  *optarg;		/* getopt() externals		      */
X
extern	 int	  optind,
X		  opterr;
X
X	 void	  get_args();
X
X/******************************************************************************/
X/*                                                                            */
X/*     S T A T I C   D E F I N I T I O N S   &   D E C L A R A T I O N S      */
X/*                                                                            */
X/******************************************************************************/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	get_args
X
X  Purpose:	Process the command-line arguments, setting the flags for
X		what arguments are specified and determining the slot width.
X		Also calculate the entry size memory allocation factor for
X		allocating memory pools.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	opt_size		   X      X     X
X	optarg			   X		X
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	none
X
X********************************************************************************
X*******************************************************************************/
X
void get_args(argc,argv,args)
X					/*******   FORMAL  PARAMETERS   *******/
X	 int	  argc;			/* number of run-time arguments	      */
X	 char	  **argv;		/* run-time arguments		      */
register ARG_DEF  *args;		/* run-time argument flags	      */
X
X{	/*** get_args ***/
X					/********   LOCAL  VARIABLES   ********/
X	 int	  c;			/* argument from getopt()	      */
X	 size_t	  opt_size;		/* length of an option string	      */
X
X
X   /* start parsing the arguments; when we're done, look at what they
X    * are and set some values accordingly
X    */
X
X   args->sort = FILENAME;		/* assume we want to sort by filename */
X
X   while((c = getopt(argc,argv,"acdfgopstwAFS:")) != EOF)
X   {
X      switch(c)
X      {
X	 case('a'):
X
X	    args->dot_files = TRUE;
X	    break;
X
X	 case('A'):
X
X	    args->auto_feed = TRUE;
X	    break;
X
X	 case('c'):
X
X	    args->confirm = TRUE;
X	    break;
X
X	 case('d'):
X
X	    args->date = TRUE;
X	    break;
X
X	 case('f'):
X
X	    args->date = TRUE;
X	    args->size = TRUE;
X	    args->prot = TRUE;
X	    args->owner = TRUE;
X	    args->group = TRUE;
X	    break;
X
X	 case('g'):
X
X	    args->group = TRUE;
X	    break;
X
X	 case('o'):
X
X	    args->owner = TRUE;
X	    break;
X
X	 case('p'):
X
X	    args->prot = TRUE;
X	    break;
X
X	 case('s'):
X
X	    args->size = TRUE;
X	    break;
X
X	 case('t'):
X
X	    args->text = DISPLAY_TEXT;
X	    args->text_startup = TRUE;
X	    break;
X
X	 case('w'):
X
X	    args->wide = TRUE;
X	    break;
X
X	 case('S'):
X
X	    /* see what we should sort by */
X
X	    opt_size = strlen(optarg);
X
X	    if(opt_size)
X	    {
X	       /* something specified after the option; see what it is */
X
X	       if(strncmp("date",optarg,opt_size) == 0)
X	       {
X		  args->sort = DATE;
X	       }
X	       else if(strncmp("size",optarg,opt_size) == 0)
X	       {
X		  args->sort = SIZE;
X	       }
X	       else if(strncmp("filename",optarg,opt_size) == 0)
X	       {
X		  args->sort = FILENAME;
X	       }
X	       else if(strncmp("none",optarg,opt_size) == 0)
X	       {
X		  args->sort = 0;
X	       }
X	       else
X	       {
X		  fprintf(stderr,"maint -- illegal sort option %s\n",optarg);
X		  exit(1);
X	       }
X	    }
X
X	    break;
X
X	 case('F'):
X
X	    args->filemarks = TRUE;
X	    break;
X
X	 default:
X
X	    exit(1);
X      }
X   }
X
X   return;
X
X}	/*** get_args ***/
END_OF_FILE
if test 6104 -ne `wc -c <'args.c'`; then
    echo shar: \"'args.c'\" unpacked with wrong size!
fi
# end of 'args.c'
fi
if test -f 'edit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'edit.c'\"
else
echo shar: Extracting \"'edit.c'\" \(5188 characters\)
sed "s/^X//" >'edit.c' <<'END_OF_FILE'
X/******************************************************************************
X*******************************************************************************
X
X   Site:	Western Michigan University Academic Computer Center
X
X   System:	Directory/File System Maintenance
X  
X   Program:	maint
X
X   Version=01	Level=00	01/24/92	Leonard J. Peirce
X
X   Purpose:	Call an editor for a file.  The EDITOR variable is first
X		examined; if it's not defined, DEFAULT_EDITOR is used.
X
X   Arguments:	See individual routine(s).
X
X   External variables:	None
X
X   Maint external functions:
X
X	Defined:	edit
X
X	Called:		None
X
X   Files accessed:	File to be edited, passed through parameter list
X
X   Return codes:	See individual routine(s).
X
X   Compiling instructions:	See Makefile
X
X   Linking instructions:	See Makefile
X
X   Other information:	(C) Copyright 1992, Leonard J. Peirce
X
X********************************************************************************
X*******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*                        # I N C L U D E   F I L E S                         */
X/*                                                                            */
X/******************************************************************************/
X
X#include <stdio.h>
X#include <string.h>
X#if !defined(SYSV) || defined(sun)
X#include <sys/wait.h>
X#endif
X#include "maint.h"
X
X/******************************************************************************/
X/*                                                                            */
X/*                             # D E F I N E S                                */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*          S T R U C T U R E S ,   U N I O N S ,   T Y P E D E F S           */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*   E X T E R N A L   D E F I N I T I O N S   &   D E C L A R A T I O N S    */
X/*                                                                            */
X/******************************************************************************/
X
extern	 char	  *getenv();
X
extern	 int	  access(),
X		  wait(),
X		  fork(),
X		  execlp();
X
X	 int	  edit();
X
X/******************************************************************************/
X/*                                                                            */
X/*     S T A T I C   D E F I N I T I O N S   &   D E C L A R A T I O N S      */
X/*                                                                            */
X/******************************************************************************/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	edit
X
X  Purpose:	Call an editor for a file.  If the user has an EDITOR
X		environment variable, use it.  Otherwise, the default is
X		DEFAULT_EDITOR.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	SUCCESS
X	FAILURE
X
X********************************************************************************
X*******************************************************************************/
X
int edit(filename)
X					/*******   FORMAL  PARAMETERS   *******/
X	 char	  *filename;		/* name of file to be edited	      */
X
X{	/*** edit ***/
X					/********   LOCAL  VARIABLES   ********/
X	 char	  *editor,		/* editor to use		      */
X		  *tptr;		/* pointer to last level of command   */
X	 int	  child,		/* pid of child process		      */
X		  i;			/* loop and return value	      */
X#if !defined(SYSV) || defined(sun)
union	 wait	  status;		/* exit status for child process      */
X#else
X	 int	  status;
X#endif
X
X
X   /* see if the user has an EDITOR */
X
X   editor = getenv("EDITOR");
X
X   if(editor == NULL || *editor == '\0')
X      editor = DEFAULT_EDITOR;		/* user doesn't have an EDITOR	      */
X
X   tptr = strrchr(editor,'/');		/* get last level to pass to execlp   */
X
X   if(tptr == NULL)
X      tptr = editor;
X   else
X      tptr++;
X
X   if((child = vfork()) == 0)
X   {
X      /* we're in the child */
X
X      endwin();
X      execlp(editor,tptr,filename,NULL);
X      return(FAILURE);			/* execlp failed if we get here	      */
X   }
X   else if(child > 0)
X   {
X      /* we're in the parent; wait for the child to finish */
X
X      while(((i = wait(&status)) != child) && i > 0)
X	 ;
X   }
X   else
X      return(FAILURE);
X
X   return(SUCCESS);
X
X}	/*** edit ***/
END_OF_FILE
if test 5188 -ne `wc -c <'edit.c'`; then
    echo shar: \"'edit.c'\" unpacked with wrong size!
fi
# end of 'edit.c'
fi
if test -f 'help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help.c'\"
else
echo shar: Extracting \"'help.c'\" \(7499 characters\)
sed "s/^X//" >'help.c' <<'END_OF_FILE'
X/******************************************************************************
X*******************************************************************************
X
X   Site:	Western Michigan University Academic Computer Center
X
X   System:	Directory/File System Maintenance
X  
X   Program:	maint
X
X   Version=01	Level=00	01/24/92	Leonard J. Peirce
X
X   Purpose:	On-line help for maint.
X
X   Arguments:	See individual routine(s).
X
X   External variables:	None
X
X   Maint external functions:
X
X	Defined:	give_help
X
X	Called:		info_mess, clear_mess
X
X   Files accessed:	None
X
X   Return codes:	See individual routine(s).
X
X   Compiling instructions:	See Makefile
X
X   Linking instructions:	See Makefile
X
X   Other information:	(C) Copyright 1992, Leonard J. Peirce
X
X********************************************************************************
X*******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*                        # I N C L U D E   F I L E S                         */
X/*                                                                            */
X/******************************************************************************/
X
X#ifdef ultrix
X#include <cursesX.h>
X#else
X#include <curses.h>
X#endif
X#include "maint.h"
X
X/******************************************************************************/
X/*                                                                            */
X/*                             # D E F I N E S                                */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*          S T R U C T U R E S ,   U N I O N S ,   T Y P E D E F S           */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*   E X T E R N A L   D E F I N I T I O N S   &   D E C L A R A T I O N S    */
X/*                                                                            */
X/******************************************************************************/
X
extern	 void	  clear_mess();
X
X	 void	  give_help();
X
X/******************************************************************************/
X/*                                                                            */
X/*     S T A T I C   D E F I N I T I O N S   &   D E C L A R A T I O N S      */
X/*                                                                            */
X/******************************************************************************/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	give_help
X
X  Purpose:	Give the user some on-line help for a single key.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	none
X
X********************************************************************************
X*******************************************************************************/
X
void give_help(window)
X					/*******   FORMAL  PARAMETERS   *******/
X	 WINDOW	  *window;		/* where to read/write		      */
X
X{	/*** give_help ***/
X
X	 char	  buf[MAXNAMLEN + 100];
X
X   
X   info_mess("Key you want help with [use `?' for detailed help] ? ");
X
X   switch(wgetch(window))
X   {
X      case(CONTROL_I):
X      case(' '):
X      case('>'):
X      case('L'):
X      case('l'):
X      case(KEY_RIGHT):
X
X	 info_mess("Right -- Move right one column");
X	 break;
X
X      case(BACKSPACE):
X      case('<'):
X      case('H'):
X      case(KEY_BACKSPACE):
X      case('h'):
X      case(KEY_LEFT):
X
X	 info_mess("Left -- Move left one column");
X	 break;
X
X      case(LINEFEED):
X      case('J'):
X      case('j'):
X      case(KEY_DOWN):
X
X	 info_mess("Down -- Move down one row");
X	 break;
X
X      case('^'):
X      case('K'):
X      case('k'):
X      case(KEY_UP):
X
X	 info_mess("Up -- Move up one row");
X         break;
X
X      case(CARRIAGE_RETURN):
X
X	 info_mess("Down and Left -- Move down one row, left of screen");
X	 break;
X
X      case('='):
X      case('+'):
X      case(CONTROL_F):
X      case(KEY_NPAGE):
X
X	 info_mess("Next Page -- Move forward one page");
X	 break;
X
X      case('_'):
X      case('-'):
X      case(CONTROL_B):
X      case(KEY_PPAGE):
X
X	 info_mess("Previous Page -- Move backward one page");
X	 break;
X
X      case('/'):
X
X	 info_mess("/Search -- Search for filename");
X	 break;
X 
X      case('U'):
X      case('u'):
X
X	 info_mess("Unmark -- Cancel all marks for a file");
X	 break;
X
X      case('S'):
X      case('s'):
X
X	 info_mess("Select -- Select file (browse) or directory (change \
directory)");
X	 break;
X
X      case('B'):
X      case('b'):
X
X	 info_mess("Branch -- Branch to another directory");
X	 break;
X
X      case('X'):
X      case('x'):
X
X	 info_mess("Xecute -- Perform the commands in the current directory");
X	 break;
X
X      case(CONTROL_R):
X
X	 info_mess("Rebuild -- Rebuild directory information");
X	 break;
X
X      case('D'):
X      case('d'):
X
X	 info_mess("Delete -- Delete file/directory");
X	 break;
X
X      case('P'):
X      case('p'):
X
X	 info_mess("Protect -- Set protection (mode) for file");
X	 break;
X
X      case('F'):
X      case('f'):
X
X	 info_mess("Finish -- Finish directory, returning to previous \
directory");
X	 break;
X
X      case('E'):
X      case('e'):
X
X	 info_mess("Edit -- Call editor for file");
X	 break;
X
X      case('I'):
X      case('i'):
X
X	 info_mess("Info -- Give full information for file");
X	 break;
X
X      case('R'):
X      case('r'):
X
X	 info_mess("Rename -- Rename file to another file");
X	 break;
X
X      case('C'):
X      case('c'):
X
X	 info_mess("Copy -- Copy file to another file");
X	 break;
X
X      case('T'):
X      case('t'):
X
X	 info_mess("Text -- Enter text mode or add/edit text descriptor for \
file");
X	 break;
X
X      case('Q'):
X      case('q'):
X
X	 info_mess("Quit -- Leave maint and return to shell");
X	 break;
X
X      case('!'):
X
X	 info_mess("! -- Escape to shell");
X	 break;
X
X      case(CONTROL_W):
X      case(CONTROL_L):
X
X	 info_mess("Refresh -- Refresh screen");
X	 break;
X
X      case(CONTROL_G):
X
X	 info_mess("^Goto -- Goto specific page in directory");
X	 break;
X
X      case('W'):
X      case('w'):
X
X	 info_mess("Who -- Display name of author");
X	 break;
X
X      case('V'):
X      case('v'):
X
X	 info_mess("Version -- Display current version");
X	 break;
X
X      case('O'):
X      case('o'):
X
X	 info_mess("Owner -- Change owner of file/directory");
X	 break;
X     
X      case('G'):
X      case('g'):
X
X	 info_mess("Group -- Change group of file/directory");
X	 break;
X
X      case('.'):
X
X	 info_mess("Repeat -- repeat last file command");
X	 break;
X
X      case('?'):
X
X	 if (!file_select(HELPFILE))
X	 {
X	   (void) sprintf(buf,"Error accessing help file `%s'",HELPFILE);
X	   info_mess(buf);
X	 }
X
X	 /* fall through and clear the message */
X
X      case(ESCAPE):
X      default:
X
X	 clear_mess(window);
X	 break;
X   }
X
X   return;
X
X}	/*** give_help ***/
END_OF_FILE
if test 7499 -ne `wc -c <'help.c'`; then
    echo shar: \"'help.c'\" unpacked with wrong size!
fi
# end of 'help.c'
fi
if test -f 'locate.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'locate.c'\"
else
echo shar: Extracting \"'locate.c'\" \(8424 characters\)
sed "s/^X//" >'locate.c' <<'END_OF_FILE'
X/******************************************************************************
X*******************************************************************************
X
X   Site:	Western Michigan University Academic Computer Center
X
X   System:	Directory/File System Maintenance
X  
X   Program:	maint
X
X   Version=01	Level=00	01/24/92	Leonard J. Peirce
X
X   Purpose:	Search for a file in the current directory and return its
X		location.
X
X   Arguments:	See individual routines
X
X   External variables:	See individual routines
X
X   Maint external functions:
X
X	Defined:	file_locate, file_ptr_locate
X
X	Called:		prompt_getstr
X
X   Files accessed:	None
X
X   Return codes:	See individual routines
X
X   Compiling instructions:	See Makefile
X
X   Linking instructions:	See Makefile
X
X   Other information:	(C) Copyright 1992, Leonard J. Peirce
X
X********************************************************************************
X*******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*                        # I N C L U D E   F I L E S                         */
X/*                                                                            */
X/******************************************************************************/
X
X#ifdef ultrix
X#include <cursesX.h>
X#else
X#include <curses.h>
X#endif
X#include <ctype.h>
X#include "maint.h"
X
X/******************************************************************************/
X/*                                                                            */
X/*                             # D E F I N E S                                */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*          S T R U C T U R E S ,   U N I O N S ,   T Y P E D E F S           */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*   E X T E R N A L   D E F I N I T I O N S   &   D E C L A R A T I O N S    */
X/*                                                                            */
X/******************************************************************************/
X
extern	 int	  main_rows;
X
extern	 void	  prompt_getstr();
X
X	 int	  file_locate(),
X		  file_search(),
X		  file_ptr_search();
X
X/******************************************************************************/
X/*                                                                            */
X/*     S T A T I C   D E F I N I T I O N S   &   D E C L A R A T I O N S      */
X/*                                                                            */
X/******************************************************************************/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	file_locate
X
X  Purpose:	Get the filename prefix that is desired by the user and
X		search for it.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	main_rows				X
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	file_search()		return code from file_search
X
X********************************************************************************
X*******************************************************************************/
X
int file_locate(window,dirptr,num_file)
X					/*******   FORMAL  PARAMETERS   *******/
X	 WINDOW	  *window;		/* where to read/write		      */
X	 ENT_DEF  *dirptr;		/* pointer to directory entry memory  */
X	 short	  num_file;		/* number of files in directory	      */
X
X{	/*** file_locate ***/
X					/********   LOCAL  VARIABLES   ********/
X	 char	  prefix[SPEC_MAX+1];	/* filename prefix read in	      */
X
X
X   /* prompt and ye shall receive....... */
X
X   prompt_getstr(window,"Search for: ",prefix,main_rows,SPEC_MAX);
X
X   /* now search for the filename prefix in the directory entries */
X
X   return(file_search(dirptr,prefix,num_file,strlen(prefix)));
X
X}	/*** file_locate ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	file_search
X
X  Purpose:	Search for the filename prefix specified
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	 i			number of file in directory
X	 -1			file prefix not found in directory
X
X********************************************************************************
X*******************************************************************************/
X                                   
int file_search(dirptr,prefix,num_file,length)
X					/*******   FORMAL  PARAMETERS   *******/
register ENT_DEF  *dirptr;		/* pointer to directory entries	      */
register char	  *prefix;		/* filename prefix to find	      */
register short	  num_file;		/* number of files in directory	      */
X	 int	  length;		/* length of prefix string	      */
X
X{	/*** file_search ***/
X					/********   LOCAL  VARIABLES   ********/
register short	  i = 0;		/* loop index and file entry counter  */
X	 short	  done = 0;		/* loop control flag		      */
X
X
X   /* search from the beginning for the filename prefix until 1) we find
X    * what we are looking for or 2) we run out of files; when we exit the
X    * loop we look at why we exited to see if we found the file or not
X    */
X
X   while((i < num_file) && (!done))
X   {
X      if(!strncmp(dirptr->filename,prefix,length))
X	 done++;			/* we found it; stop searching....    */
X      else
X      {
X	 ++i;				/* count this file entry	      */
X	 ++dirptr;			/* go to next file entry	      */
X      }
X   }
X
X   /* did we find what we were looking for? */
X
X   if(i == num_file)			/* did we find the filename prefix?   */
X      i = -1;				/* nope.....			      */
X
X   return((int) i);			/* say whether or not we found it...  */
X
X}	/*** file_search ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	file_ptr_search
X
X  Purpose:	Search for the filename by comparing pointers to the
X		memory in the memory pool holding the memory.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	 i			number of file in directory
X	 -1			file prefix not found in directory
X
X********************************************************************************
X*******************************************************************************/
X
int file_ptr_search(dirptr,filename,num_file)
X					/*******   FORMAL  PARAMETERS   *******/
register ENT_DEF  *dirptr;		/* pointer to directory entries	      */
register char	  *filename;		/* pointer to memory holding filename */
register short	  num_file;		/* number of files in directory	      */
X
X{	/*** file_ptr_search ***/
X					/********   LOCAL  VARIABLES   ********/
register short	  i = 0;		/* loop index and file entry counter  */
X	 short	  done = 0;		/* loop control flag		      */
X
X
X   /* search from the beginning for the filename pointer until 1) we find
X    * what we are looking for or 2) we run out of files; when we exit the
X    * loop we look at why we exited to see if we found the file or not
X    */
X
X   while((i < num_file) && (!done))
X   {
X      if(dirptr->filename == filename)
X	 done++;			/* we found it; stop searching....    */
X      else
X      {
X	 ++i;				/* count this file entry	      */
X	 ++dirptr;			/* go to next file entry	      */
X      }
X   }
X
X   /* did we find what we were looking for? */
X
X   if(i == num_file)			/* did we find the filename prefix?   */
X      i = -1;				/* nope.....			      */
X
X   return((int) i);			/* say whether or not we found it...  */
X
X}	/*** file_ptr_search ***/
END_OF_FILE
if test 8424 -ne `wc -c <'locate.c'`; then
    echo shar: \"'locate.c'\" unpacked with wrong size!
fi
# end of 'locate.c'
fi
if test -f 'maint.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'maint.1'\"
else
echo shar: Extracting \"'maint.1'\" \(10994 characters\)
sed "s/^X//" >'maint.1' <<'END_OF_FILE'
X.TH MAINT 1 "1 Jan 1992"
X.ad
X.SH "NAME"
maint - Full-screen file/directory maintenance
X.SH "SYNOPSIS"
maint [-acdfgopst] [-S [\fIsort-field\fR]]
X.SH "DESCRIPTION"
X.I maint
is a file/directory maintenance utility that combines the functionality of
many well-known Unix utilities, adds some new capabilities, and packages
them into a full-screen interface that gives you the capability of working
with entire directories at one time instead of working with a few files and
having to run
X.IR ls (1)
to see the current state of the directory.
X
Directories are presented as a series of one or more screens, making it possible
to associate individual commands with each file/directory.  These commands are
not actually performed until the directory is "executed" and then all of the
commands in the directory will be performed.  This allows plenty of time to
change or cancel commands with individual files before a possible catastrophe.
X
Other capabilities, such as browsing and editing files, changing directories,
and associating "text descriptors" with files and directories make it possible
manage multiple files/directories quickly, easily, and efficiently.
X.SH "OPTIONS"
X.IP -a
Include all files, including those beginning with a period (.).
X.IP -c
Ask for confirmation before eXecuting commands in a directory.
X.IP -d
Include date field for files.
X.IP -f
Include full information for files.  Implies -odgsp.
X.IP -g
Include group name for files.
X.IP -o
Include owner field for files.
X.IP -p
Include protection (mode) field for files.
X.IP -s
Include size (in bytes) field for files.
X.IP -t
Start up in text mode.  If maint.tdf does not exist in current directory,
this flag is ignored.
X.IP -A
Auto-advance the cursor on Delete or Unmark commands.
X.IP -F
Marks directories with trailing slash (/), sockets with a trailing equal sign
X(=), symbolic links with a trailing at sign (@), and executable files with a
trailing asterisk (*).
X.IP \fB-S\fIsort-field\fR 0.3i
Sort files by sort-field; legal value are: size, date, filename.
Default is filename.
X.SH "DISPLAY"
The screen is divided into three regions.  The first region is the directory
specification window, along the top of the screen.  This window is two lines
and contains:
X.IP o
The current directory specification.  If the current directory is a descendant
of your home directory, the home directory portion will not be specified in
order to save space.  If the current directory is your home directory, the
full directory specification will be used.
X.IP o
The current page and the total number of pages in the directory.
X.IP o
The text descriptor for the directory (if you are in Text mode).
X.PP
The middle section is the main screen, and will contain information about the
individual files and directories.  Each file/directory on the screen occupies
a "slot".  Each file slot can have different characteristics, depending on
filename length and commands.
X.IP o
If for any reason the full filename of a file won't fit in a file slot, it
will be flagged with an asterisk.
X.IP o
If the file has any commands associated with it, it will be displayed in
bold (or possibly reverse, if your terminal doesn't support bolding).  If
the file has been marked for deletion, a string signifying such will also
appear.
X.PP
The bottom section is the option line that will display the most commonly-used
commands with the character used to invoke them displayed in bold (or reverse).
The number of files and the total number of blocks in the directory are
also displayed.
X.SH "FEATURES"
X.BR "Moving Around."
X.PP
There are a number of different ways to move around the screen and change
the current screen.  The following table describes the keystrokes that can
be used; be aware that not all keys may be defined on every terminal.  If there
is a key that looks like it might work, try it. :-)
X.IP "right (move right one column)"
l, Right Arrow, Space, Tab, Greater Than >
X.IP "left (move left one column)"
h, Left Arrow, Less Than <
X.IP "up (move up one row)"
k, Up Arrow, Caret ^
X.IP "down (move down one row)"
j, Down Arrow
X.IP "plus page (go to next screen in directory)"
X+, =, Next Screen, control-F
X.IP "minus page (go to previous screen in directory)"
X-, _, Previous Screen, control-B
X.IP "go to page (go to a specific screen in directory)"
control-G; prompt will appear for specific page number.
X.PP
X.BR "File Commands."
X.PP
XEach file/directory can one or more individual commands associated with it.
These commands will not be performed until you actually "execute" them with
the Xecute command (see below).  To add a command to a file/directory,
position the cursor next to it and press the appropriate key.  You will be
prompted for any necessary information.
X
To see what commands are associated with a file/directory, use the Information
command.
X
The individual commands and appropriate keystrokes are:
X.IP "Copy file (C or c)"
Copy file to another file.  Invalid for directories.
X.IP "Delete file (D, d, Remove)"
Delete file/directory.
X.IP "Rename file (R or r)"
Rename the file to a new filename.
X.IP "Change group (G or g)"
Change group of file/directory.  Usually only works for superuser on non-System
V machines.
X.IP "Change owner (o)"
Change owner of file/directory.  Usually only works for superuser on non-System
V machines.
X.IP "Change protection (P or p)"
Change the protection (mode) of a file/directory.  The mode can be specified
in one of two forms:  1) the way it appears on screen, i.e. rw-r--r--, or 2)
octal format, i.e. 755.
X.IP "Repeat previous file command (.)"
Repeat the last file command specified in the current directory.
X.IP "Text descriptor (T or t)"
Add/change a text descriptor for a file/directory.  See below for more
information about text descriptors.
X.PP
X.BR "Other Commands."
X.PP
Other commands and non-eXecutable file commands available in
X.I maint
are:
X.IP "Escape to shell (!)"
Starts up a subshell.  Exiting the subshell will cause a return to
X.I maint.
X.IP "Search for a file (/)"
Search for a filename in the current directory.  A prefix search is done so
only enough of the filename to identify it is necessary.
X.IP "Rebuild directory (control-R)"
Rebuild the current directory, discarding all file commands for the directory.
This is sometimes necessary in very volatile directories where the information
in
X.I maint
might not be in sync with the current state of the directory.
X.IP "Edit file (E or e)
XEdit the current file.  The EDITOR environment variable will be used for
the editor if it is defined.  The default is vi.
X.IP "Finish directory (F or f)"
XExit the current directory and return to previous directory if one exists.  If
the current directory is the top-level directory, this key is invalid.  If
any commands exist in the current directory,
X.I maint
will ask for confirmation before leaving the directory.
X.IP "Quit (Q or q)"
XExit
X.I maint
immediately.  If file commands exist in
X.I any
directory,
X.I maint
will ask for confirmation before quitting.
X.IP "Information (I or i)"
Give full information on file/directory including size, mode, access date,
modification date, creation date, owner, group, text descriptor (if any), and
any file commands.
X.IP "Unmark file (U or u)"
Cancel all marks for the file/directory.
X.IP "Select file/directory (S, s, Select)"
If Selecting a file, invoke the a pager on it to allow the file to be browsed.
The PAGER environment variable is checked first.   If PAGER is not set, the
default pager for the system is used.  Exiting the pager will cause a return
to
X.I maint.
X
If Selecting a directory, change to that directory, saving the state of the
current directory.
X.IP Repaint screen (control-W)
Refresh the current screen.
X.IP Options (O)
Change the current configuration for maint.  The Configuration Menu will be
displayed, showing the current configuration values.  Use j and k to select
a parameter (or use the run-time argument letter (for example, g for Group))
and press the space bar to turn the parameter on/off.  Enter control-D to
return to the main display.  The display will be updated to reflect the new
configuration.
X.PP
X.BR "Text Descriptors."
X.PP
X.I maint
has the ability to maintain extended textual descriptors for files
within a given directory.  What text descriptors do is allow you to associate
up to a 40-character description with any file in a directory, along
with having up to a 70-character description of the directory itself.  This
is particularly useful when maintaining directories with a large number of
files.  To use the extended file descriptor facility, do the following:
X.IP 1.
Run
X.I maint.
X.IP 2.
Type a T (Text) command.
X.IP 3.
X.I maint
will ask
X.nf
Text descriptor file maint.tdf does not exist.  Create it [y]?
X.fi
X.IP 4.
Respond with something other than N or n for the file to be created.
X.IP 5.
X.I maint
will then ask
X.nf
Text descriptor for directory:
X.fi
X.IP 6.
XEnter a text descriptor (up to 70 characters) for the DIRECTORY.  This will
serve as a descriptor of the group of files in the DIRECTORY and will appear
at the top of the screen.
X.IP 7.
X.I maint
will then ask
X.nf
Commands will be wiped out.  eXecute them? [y]
X.fi
X.IP 8.
XEnter something other than N or n to have all of the current file commands
eXecuted when the text descriptor file maint.tdf.
X.IP 9.
X.I maint
will rebuild the directory information and rebuild the screen, including the
text descriptors for the directory and text descriptor file itself, provided
they will fit on the screen.  Even if they can't fit on the screen, they are
still available for each file via the I (Info) command.
X.PP
The text descriptor file has now been created.  To add or modify a text
descriptor for a file, move to a the file and type a T (Text) command.  You
will be prompted for the text descriptor for the file.  It will be updated
when you Xecute the commands for the directory.
X.PP
On subsequent uses of
X.I maint,
text mode may be entered by one of two methods:
X.IP 1.
Use the -t on the command line.  This will cause
X.I maint
to use text mode if the file maint.tdf exists.
X.IP 2.
Use the T (Text) command.  Again, if maint.tdf exists,
X.I maint
will enter text mode.
X.PP
XEither way, once in text mode, the T (Text) command may be used to add or
change the text descriptor for a file.
X.PP
X.SH "ENVIRONMENT"
X.nf
XEDITOR   used for Edit command
PAGER    pager to use for Select command on a file
SHELL    shell to invoke for shell escapes
X.SH "RESTRICTIONS"
Could experience unpredictable results on terminals with that are less
than 24 X 80.
X
There is no limitation on the number of files in a directory that
X.I maint
can handle other than the amount of memory that it can request from the
operating system.
X
As of this writing, the function and arrow keys won't work on Ultrix 3.0. :-(
X.SH "SEE ALSO "
X.IR chmod (1),
X.IR chgrp (1),
X.IR chown (1),
X.IR csh (1),
X.IR more (1),
X.IR ls (1),
X.IR mv (1),
X.IR rm (1),
X.IR sh (1).
X.SH AUTHOR
Leonard J. Peirce @ Western Michigan University Academic Computing Services
X(peirce@gw.wmich.edu).
END_OF_FILE
if test 10994 -ne `wc -c <'maint.1'`; then
    echo shar: \"'maint.1'\" unpacked with wrong size!
fi
# end of 'maint.1'
fi
if test -f 'maint.help' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'maint.help'\"
else
echo shar: Extracting \"'maint.help'\" \(4568 characters\)
sed "s/^X//" >'maint.help' <<'END_OF_FILE'
Maint is a program for browsing through your files and doing basic
tasks on them.  It prints a full screen of file data and allows you
to operate on the 'current' file.  The 'current file' is the file the
cursor is next to.
X
Maint does a number of functions on the files and directories:
X
X	o  Move around among your files within a directory.
X	o  Move from directory to directory.
X	o  Mark a file for change (copy, delete or rename).
X	o  Mark a file to changing characteristics.
X	o  Execute or cancel pending marks.
X	o  Examine a file (edit, view, list characteristics).
X	o  Assign descriptive text to a file or directory.
X	o  Other misc. commands
X
XEach of these groups is described individually below.
X
Sometimes there is more than one command to do the same thing.  Multiple
commands are separated by commas.  Upper and lower case are the same.
X
Maint has a number of commands selecting the current file from those
on the screen.  You may simply move around the screen by giving the
following motion commands.
X
X	l,>,space,tab	- move right one column.
X	h,<		- move left one column.
X	k,^		- move up one row.
X	j		- move down one row.
X
You may ask for a file by name:
X	/	- search for a file by name.  Make it the new current
X		  file.
X
If you have more files than will fit on the screen, maint breaks them
up into pages.
X
X	+,=	- go to next page of files (if you have more files
X		  than can be printed in a single screenful)
X	-,_	- go to next page of files (if you have more files
X		  than can be printed in a single screenful)
X
Maint offers you a number of ways of moving from directory to directory:
X
X	b - BRANCH to a directory.  You will be prompted for the
X	    name of the new directory.
X	s - SELECT current file to become the new directory.
X	    If the file is not a directory, it is viewed instead.
X
The maint commands for changing individual files are:
X
X	c - COPY current to another file (same directory only).
X	    You will be prompted for a file to be copied to.
X	r - mark the current file to be RENAMED.  You will
X	    be prompted for the new name, which must be in the
X	    same directory only.
X	d - mark the current file for DELETE.
X
Maint allow you to change various characteristics of a file:
X
X	g - Mark the current file to change the GROUP membership of
X	    the file.  This command can only be used by the system manager.
X	o - Mark a file to change the OWNER of the file.  This command
X	    can only be used by the system manager.
X	p - Mark a file to change the PROTECTION of the file.  Currently
X	    you must set the protection either by typing the individual
X	    bits (eg, 755) or by mimicing the permission string
X	    (eg `rw-r--r--', etc.)
X
Commands which mark a file are not executed immediately.  The marks
be marked
X
X	x -	EXECUTE all marks immediately.  This causes all
X		pending deletions, renames, etc, to be done.
X	u -	UNMARK (cancel) pending marks for the current file.
X	control-r - REBUILD the current directory.  This
X		cancels all pending marks.
X
Maint will let you get various information and views of a file:
X
X	i - give INFORMATION about characteristics of the current
X	    file.  This includes type, size, last usage, etc.
X	e - EDIT the current file.  The editor used will be
X	    whatever is specified in your EDITOR environment,
X	    or the system default (vi).
X	s - SELECT current file for viewing (if an ordinary file).
X	    The viewer used will be whatever is specified in your
X	    PAGER environment, or the system default (less).  If
X	    the file is a directory, it is BRANCHED to (see 'b')
X
Maint will let you assign descriptive text to a file or directory.
The 't' command functions as follows:
X
If there is no descriptive text in the current directory, you will
prompted for the creation of a 'Text descriptor file'.  Type [y] if
you really want to add descriptions.  If you say [y], you will then
be prompted for a brief description of the directory (up to 70 letters).
X
Once there is a text descriptor file, you may then added up to 40
characters of description for any file in the directory.  Select the
file with the motion commands, then type 't'.
X
Misc maint commands:
X
X	! - go to the system to execute commands, return to
X	    maint when done.
X	q - QUIT maint.  If there are pending marks, you will
X	    be asked if they should be EXECUTED.
X	O - Change display options.  A menu will be displayed and
X	    you will allowed to select what information should be
X	    displayed for each file.
X	^L/^W (control-L or control-W) - redraw the screen.
X
There are more maint commands; try '!man maint' to see them all.
END_OF_FILE
if test 4568 -ne `wc -c <'maint.help'`; then
    echo shar: \"'maint.help'\" unpacked with wrong size!
fi
# end of 'maint.help'
fi
if test -f 'mem.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mem.c'\"
else
echo shar: Extracting \"'mem.c'\" \(7083 characters\)
sed "s/^X//" >'mem.c' <<'END_OF_FILE'
X/******************************************************************************
X*******************************************************************************
X
X   Site:	Western Michigan University Academic Computer Center
X
X   System:	Directory/File System Maintenance
X  
X   Program:	maint
X
X   Version=01	Level=00	01/24/92	Leonard J. Peirce
X
X   Purpose:	Memory allocation/initialization routines for command
X		structures.
X
X   Arguments:	See individual routines
X
X   External variables:	See individual routines
X
X   External functions:
X
X          Defined:	free_com, free_comstr, new_comm
X
X          Called:	None
X
X   Files accessed:	None
X
X   Return codes:	See individual routines
X
X   Compiling instructions:	See Makefile
X
X   Linking instructions:	See Makefile
X
X   Other information:	(C) Copyright 1992, Leonard J. Peirce
X
X********************************************************************************
X*******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*                        # I N C L U D E   F I L E S                         */
X/*                                                                            */
X/******************************************************************************/
X
X#include <malloc.h>
X#if defined(SYSV) || !defined(sun)
X#include <stdio.h>
X#endif
X#include "maint.h"
X
X/******************************************************************************/
X/*                                                                            */
X/*                             # D E F I N E S                                */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*          S T R U C T U R E S ,   U N I O N S ,   T Y P E D E F S           */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*   E X T E R N A L   D E F I N I T I O N S   &   D E C L A R A T I O N S    */
X/*                                                                            */
X/******************************************************************************/
X
X#ifndef ultrix
extern	 void	  free();
X#endif
X
X	 void	  free_comm(),
X		  free_comstr();
X
X	 COM_DEF  *new_comm();
X
X/******************************************************************************/
X/*                                                                            */
X/*     ST A T I C   D E F I N I T I O N S   &   D E C L A R A T I O N S       */
X/*                                                                            */
X/******************************************************************************/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	free_com
X
X  Purpose:	Free the memory that was allocated for all of the command
X		structures for a directory, including all of the memory that
X		may have been allocated to hold things such as the copy name,
X		the rename name, and the text descriptor.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	none
X
X********************************************************************************
X*******************************************************************************/
X
void free_comm(dirptr,num_file)
X					/*******   FORMAL  PARAMETERS   *******/
register ENT_DEF  *dirptr;		/* pointer to directory entries	      */
register short	  num_file;		/* number of files in directory	      */
X
X{	/*** free_comm ***/
X
X
X   while(num_file-- > 0)		/* delete all command structs	      */
X   {
X      if(dirptr->command != NULL) 	/* command struct for this entry?     */
X      {
X	 /* free up the command structure and everything associated with it */
X
X	 free_comstr(dirptr->command);
X      }
X
X      dirptr++;				/* go to next command strucure	      */
X   }
X
X   return;
X
X}	/*** free_comm ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	free_comstr
X
X  Purpose:	Free the memory that belongs to a specific command structure.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	none
X
X  Termination Codes:
X
X	Code			Reason
X	----			------
X	status			failure freeing memory
X
X********************************************************************************
X*******************************************************************************/
X 
void free_comstr(command_str)
X       					/*******   FORMAL  PARAMETERS   *******/
register COM_DEF  *command_str;		/* pointer to structure to be freed   */
X
X{	/*** free_comstr ***/
X
X   if(command_str->copy_name != NULL)
X   {
X      /* free up the memory for the copy name */
X
X      free(command_str->copy_name);
X   }
X
X   if(command_str->ren_name != NULL)
X   {
X      /* free up the memory for the rename name */
X
X      free(command_str->ren_name);
X   }
X
X   if(command_str->text != NULL)
X   {
X      /* free up the memory for the copy name */
X
X      free(command_str->text);
X   }
X
X   /* now free up the command structure itself */
X
X   free((char *) command_str);
X
X   return;
X
X}	/*** free_comstr ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	new_comm
X
X  Purpose:	Allocate memory for a new command structure and return a
X		pointer to the memory.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	ptr			pointer to allocated memory
X	NULL			problems allocating memory
X
X********************************************************************************
X*******************************************************************************/
X
COM_DEF *new_comm()
X
X{	/*** new_comm ***/
X					/*******   FORMAL  PARAMETERS   *******/
register COM_DEF  *ptr;			/* pointer to allocated memory	      */
X
X
X   ptr = (COM_DEF *) malloc((u_int) sizeof(COM_DEF));
X
X   if(ptr == NULL)
X      return(NULL);
X
X   memset(ptr,0,sizeof(COM_DEF));	/* initialize it		      */
X   ptr->copy_name = NULL;
X   ptr->text = NULL;
X   ptr->ren_name = NULL;
X
X   return(ptr);				/* return pointer to the structure    */
X
X}	/*** new_comm ***/
END_OF_FILE
if test 7083 -ne `wc -c <'mem.c'`; then
    echo shar: \"'mem.c'\" unpacked with wrong size!
fi
# end of 'mem.c'
fi
if test -f 'select.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'select.c'\"
else
echo shar: Extracting \"'select.c'\" \(5472 characters\)
sed "s/^X//" >'select.c' <<'END_OF_FILE'
X/******************************************************************************
X*******************************************************************************
X
X   Site:	Western Michigan University Academic Computer Center
X
X   System:	Directory/File System Maintenance
X  
X   Program:	maint
X
X   Version=01	Level=00	01/24/92	Leonard J. Peirce
X
X   Purpose:	Allow a user to browse a file using a "pager" of some sort.
X		If the user has a PAGER environment variable, use it.  The
X		default is DEFAULT_PAGER
X
X   Arguments:	See individual routine(s)
X
X   External variables:	See individual routine(s)
X
X   Maint external functions:
X
X          Defined:	file_select
X
X          Called:	none
X
X   Files accessed:	filename	file to be browsed
X
X   Return codes:	See individual routine(s)
X
X   Compiling instructions:	See Makefile
X
X   Linking instructions:	See Makefile
X
X   Other information:	(C) Copyright 1992, Leonard J. Peirce
X
X********************************************************************************
X*******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*                        # I N C L U D E   F I L E S                         */
X/*                                                                            */
X/******************************************************************************/
X
X#include "maint.h"
X#include <stdio.h>
X#ifdef ultrix
X#include <cursesX.h>
X#include <unistd.h>			/* recommended for access(2)	      */
X#else
X#include <curses.h>
X#include <sys/file.h>
X#endif
X#include <string.h>
X#if !defined(SYSV) || defined(sun)
X#include <sys/wait.h>
X#endif
X#include <sys/stat.h>
X
X/******************************************************************************/
X/*                                                                            */
X/*                             # D E F I N E S                                */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*          S T R U C T U R E S ,   U N I O N S ,   T Y P E D E F S           */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*   E X T E R N A L   D E F I N I T I O N S   &   D E C L A R A T I O N S    */
X/*                                                                            */
X/******************************************************************************/
X
extern	 char	  *getenv();
X
extern	 int	  access(),
X		  wait(),
X		  fork(),
X		  execlp();
X
X	 int	  file_select();
X
X/******************************************************************************/
X/*                                                                            */
X/*     S T A T I C   D E F I N I T I O N S   &   D E C L A R A T I O N S      */
X/*                                                                            */
X/******************************************************************************/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	file_select
X
X  Purpose:	Process a file that has been selected.  If the user has a
X		PAGER environment variable, use the pager specified.  The
X		default pager is DEFAULT_PAGER.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	SUCCESS
X	FAILURE
X
X********************************************************************************
X*******************************************************************************/
X
int file_select(filename)
X					/*******   FORMAL  PARAMETERS   *******/
X	 char	  *filename;		/* name of file to be accessed	      */
X
X{	/*** file_select ***/
X					/********   LOCAL  VARIABLES   ********/
X	 char	  *pager,		/* pager for looking at a file	      */
X		  *tptr;		/* pointer to last level of command   */
X	 int	  child,		/* pid of child process		      */
X		  i;			/* loop and return value	      */
X#if !defined(SYSV) || defined(sun)
union	 wait	  status;		/* exit status for child process      */
X#else
X	 int	  status;
X#endif
X
X   /* see if the user has a PAGER */
X
X   pager = getenv("PAGER");
X
X   if(pager == NULL || *pager == '\0')
X      pager = DEFAULT_PAGER;		/* user doesn't have a PAGER	      */
X
X   tptr = strrchr(pager,'/');		/* get last level to pass to execlp   */
X
X   if(tptr == NULL)
X      tptr = pager;
X   else
X      tptr++;
X
X   if((child = vfork()) == 0)
X   {
X      /* we're in the child */
X
X      endwin();
X      execlp(pager,tptr,filename,NULL);
X      return(FAILURE);			/* execlp failed if we get here	      */
X   }
X   else if(child > 0)
X   {
X      /* we're in the parent; wait for the child to finish */
X
X      while(((i = wait(&status)) != child) && i > 0)
X	 ;
X   }
X   else
X      return(FAILURE);
X
X   return(SUCCESS);
X
X}	/*** file_select ***/
END_OF_FILE
if test 5472 -ne `wc -c <'select.c'`; then
    echo shar: \"'select.c'\" unpacked with wrong size!
fi
# end of 'select.c'
fi
if test -f 'sort.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sort.c'\"
else
echo shar: Extracting \"'sort.c'\" \(10451 characters\)
sed "s/^X//" >'sort.c' <<'END_OF_FILE'
X/******************************************************************************
X*******************************************************************************
X
X   Site:	Western Michigan University Academic Computer Center
X
X   System:	Directory/File System Maintenance
X  
X   Program:	maint
X
X   Version=01	Level=00	01/24/92	Leonard J. Peirce
X
X   Purpose:	Sort routines for the different sort options.
X
X   Arguments:	See individual routines.
X
X   External variables:	None
X
X   External functions:
X
X          Defined:	date_qsort, name_qsort, size_qsort, sort_files
X
X          Called:	None
X
X   Files accessed:	See individual routines.
X
X   Return codes:	See individual routines.
X
X   Compiling instructions:	See Makefile
X
X   Linking instructions:	See Makefile
X
X   Other information:	(C) Copyright 1992, Leonard J. Peirce
X
X********************************************************************************
X*******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*                        # I N C L U D E   F I L E S                         */
X/*                                                                            */
X/******************************************************************************/
X
X#include <string.h>
X#include "maint.h"
X
X/******************************************************************************/
X/*                                                                            */
X/*                             # D E F I N E S                                */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*          S T R U C T U R E S ,   U N I O N S ,   T Y P E D E F S           */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/*   E X T E R N A L   D E F I N I T I O N S   &   D E C L A R A T I O N S    */
X/*                                                                            */
X/******************************************************************************/
X
extern	 ENT_DEF  *baseptr;
X
X	 void	  date_qsort(),
X		  size_qsort(),
X		  name_qsort(),
X		  sort_files();
X
X/******************************************************************************/
X/*                                                                            */
X/*     S T A T I C   D E F I N I T I O N S   &   D E C L A R A T I O N S      */
X/*                                                                            */
X/******************************************************************************/
X
static	 void	  swap_entries();
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	size_qsort
X
X  Purpose:	Sort the directory entries by size.
X
X		Algorithm for quicksort from "Fundamentals of Data Structures",
X		Ellis Horowitz and Sartaj Sahni, page 137.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	baseptr					X
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	none
X
X********************************************************************************
X*******************************************************************************/
X
void size_qsort(m,n)
X					/*******   FORMAL  PARAMETERS   *******/
register short	  m,			/* lower-bound of sub-array to be     */
X					/* sorted			      */
X		  n;			/* upper-bound of sub-array to be     */
X					/* sorted			      */
X
X{	/*** size_qsort ***/
X					/********   LOCAL  VARIABLES   ********/
register short	  i,			/* loop and array index		      */
X		  j;			/*  "    "    "     "		      */
static	 u_long	  key;			/* key size entry for sorting	      */
X
X
X   if(m < n)
X   {
X      i = m;
X      j = n + 1;
X      key = baseptr[m].size;
X
X      for(;;)
X      {
X	 do
X	 {
X	    ++i;
X	 }
X	 while(baseptr[i].size < key);
X
X	 do
X	 {
X	    --j;
X	 }
X	 while(baseptr[j].size > key);
X
X	 if(i < j)
X	 {
X	    /* swap the file entries */
X
X	    swap_entries(&baseptr[i],&baseptr[j]);
X	 }
X	 else
X	    break;
X
X      } /* for(;;) */
X
X      swap_entries(&baseptr[m],&baseptr[j]);
X      size_qsort(m,j-1);
X      size_qsort(j+1,n);
X
X   } /* if(m < n) */
X
X   return;
X
X}	/*** size_qsort ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	date_qsort
X
X  Purpose:	Sort the directory entries by last access date.
X
X		Algorithm for quicksort from "Fundamentals of Data Structures",
X		Ellis Horowitz and Sartaj Sahni, page 137.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	baseptr					X
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	none
X
X********************************************************************************
X*******************************************************************************/
X
void date_qsort(m,n)
X					/*******   FORMAL  PARAMETERS   *******/
register short	  m,			/* lower-bound of sub-array to be     */
X					/* sorted			      */
X		  n;			/* upper-bound of sub-array to be     */
X					/* sorted			      */
X
X{	/*** date_qsort ***/
X					/********   LOCAL  VARIABLES   ********/
register short	  i,			/* loop and array index		      */
X		  j;			/*  "    "    "     "		      */
static	 time_t	  key;			/* key size entry for sorting	      */
X
X
X   if(m < n)
X   {
X      i = m;
X      j = n + 1;
X      key = baseptr[m].time;
X
X      for(;;)
X      {
X	 do
X	 {
X	    ++i;
X	 }
X	 while(baseptr[i].time < key);
X
X	 do
X	 {
X	    --j;
X	 }
X	 while(baseptr[j].time > key);
X
X	 if(i < j)
X	 {
X	    /* swap the file entries */
X
X	    swap_entries(&baseptr[i],&baseptr[j]);
X	 }
X	 else
X	    break;
X
X      } /* for(;;) */
X
X      swap_entries(&baseptr[m],&baseptr[j]);
X      date_qsort(m,j-1);
X      date_qsort(j+1,n);
X
X   } /* if(m < n) */
X
X   return;
X
X}	/*** date_qsort ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	swap_entries
X
X  Purpose:	Swap two file entries.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	none
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	none
X
X********************************************************************************
X*******************************************************************************/
X
static void swap_entries(a,b)
X					/*******   FORMAL  PARAMETERS   *******/
X	 ENT_DEF  *a,			/* first to be swapped 		      */
X		  *b;			/* other entry to be swapped	      */
X
X{	/*** swap_entries ***/
X					/********   LOCAL  VARIABLES   ********/
static	 ENT_DEF  temp;			/* temporary entry for swapping	      */
X
X   memcpy((char *) &temp,(char *) a, sizeof(temp));
X   memcpy((char *) a,(char *) b, sizeof(temp));
X   memcpy((char *) b,(char *) &temp, sizeof(temp));
X
X}	/*** swap_entries ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	name_qsort
X
X  Purpose:	Sort the directory entries by filename.
X
X		Algorithm for quicksort from "Fundamentals of Data Structures",
X		Ellis Horowitz and Sartaj Sahni, page 137.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	baseptr					X
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	none
X
X********************************************************************************
X*******************************************************************************/
X
void name_qsort(m,n)
X					/*******   FORMAL  PARAMETERS   *******/
register short	  m,			/* lower-bound of sub-array to be     */
X					/* sorted			      */
X		  n;			/* upper-bound of sub-array to be     */
X					/* sorted			      */
X
X{	/*** name_qsort ***/
X					/********   LOCAL  VARIABLES   ********/
register short	  i,			/* loop and array index		      */
X		  j;			/*  "    "    "     "		      */
static	 char	  *key;			/* pointer to key value		      */
X
X
X   if(m < n)
X   {
X      i = m;
X      j = n + 1;
X      key = (baseptr+m)->filename;	/* get pointer to filename key	      */
X
X      for(;;)
X      {
X	 do
X	 {
X	    ++i;
X	 }
X	 while(strcmp((baseptr+i)->filename,key) < 0);
X
X	 do
X	 {
X	    --j;
X	 }
X	 while(strcmp((baseptr+j)->filename,key) > 0);
X
X	 if(i < j)
X	 {
X	    /* swap the pointers to the filenames and the flags that indicate
X	     * whether or not the filename is too long for all of it to be
X	     * displayed on the screen
X	     */
X
X	    swap_entries(&baseptr[i],&baseptr[j]);
X	 }
X	 else
X	    break;
X
X      } /* for(;;) */
X
X      swap_entries(&baseptr[m],&baseptr[j]);
X      name_qsort(m,j-1);
X      name_qsort(j+1,n);
X
X   } /* if(m < n) */
X
X   return;
X
X}	/*** name_qsort ***/
X
X/*******************************************************************************
X********************************************************************************
X
X  Function:	sort_files
X
X  Purpose:	Sort the directory based on the sort type.
X
X  Global variables:
X
X	Name			Examine/Modify/Use/Read/Write
X	----			-----------------------------
X	baseptr					X
X
X  Return Codes:
X
X	Code			Reason
X	----			------
X	none
X
X********************************************************************************
X*******************************************************************************/
X
void sort_files(num_file,sort_type)
X					/*******   FORMAL  PARAMETERS   *******/
X	short	  num_file,		/* number of files in directory	      */
X		  sort_type;		/* field to sort on		      */
X
X{	/*** sort_files ***/
X
X
X   switch(sort_type)
X   {
X      case(FILENAME):
X	 name_qsort(0,num_file);
X	 break;
X
X      case(DATE):
X	 date_qsort(0,num_file);
X	 break;
X
X      case(SIZE):
X	 size_qsort(0,num_file);
X	 break;
X
X      default:
X	 break;
X   }
X
X   return;
X
X}	/*** sort_files ***/
END_OF_FILE
if test 10451 -ne `wc -c <'sort.c'`; then
    echo shar: \"'sort.c'\" unpacked with wrong size!
fi
# end of 'sort.c'
fi
echo shar: End of archive 1 \(of 7\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
