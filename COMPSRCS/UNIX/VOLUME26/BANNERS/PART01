Newsgroups: comp.sources.unix
From: fkk@stasys.sta.sub.org (Frank Kaefer)
Subject: v26i109: banners - a collection of banner programs, Part01/05
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: fkk@stasys.sta.sub.org (Frank Kaefer)
Posting-Number: Volume 26, Issue 109
Archive-Name: banners/part01

[ this is an unusual posting in that it contains no top-level Makefile and
  no man pages.  i am publishing it anyway, since as a collection of related
  software (all are banner programs of one kind or another), i believe that
  it is useful even if it doesn't build up into a shiny package of binaries
  and man pages.  comments on this kind of posting are encouraged.  this kind
  of posting, in general, is discouraged.				--vix ]

Hi Paul!

I am sending you a 5 part shell archive and would like to ask you to post it
in comp.sources.unix. The shell archive contains a collection of banner
programs that might be interesting for many netters.

	Cheers,
	Frank
	-- 
	| Frank Kaefer | fkk@stasys.sta.sub.org | Starnberg, Germany |
	| Compuserve: 72427,2101  |  Internet: frank.kaefer@Sun.COM  |
	| unido!sunde!fkaefer     |      fkaefer@Germany.Sun.COM     |

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 5)."
# Contents:  MANIFEST README banner-1 banner-1/banner.c
#   banner-1/makefile banner-10 banner-10/scripto.alt
#   banner-10/scripto.doc banner-10/scripto.pas banner-10/scripto.set
#   banner-11 banner-11/Read.Me banner-11/mb.c banner-2 banner-3
#   banner-3/Makefile banner-3/README banner-3/banr.f0
#   banner-3/banr.f1 banner-3/banr.f2.uu banner-4
#   banner-4/sysvbanner.c banner-5 banner-5/3db.c banner-5/Banner.doc
#   banner-5/kban.c banner-5/kban.hlp banner-5/lban.c
#   banner-5/lban.dat banner-5/leb.c banner-5/sban.dat banner-5/seb.c
#   banner-6 banner-6/banner.6 banner-7 banner-7/banner.c banner-8
#   banner-9 banner-9/Makefile banner-9/TODO banner-9/block.c
#   cursive-1 cursive-1/Makefile cursive-1/README cursive-1/cursive.6
#   cursive-1/cursive.h cursive-2 cursive-2/Makefile
#   cursive-2/cursive.6 cursive-2/cursive.h gothic
# Wrapped by vixie@gw.home.vix.com on Thu Apr  8 12:26:11 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2253 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X README                     1	
X banner-1                   1	
X banner-1/banner.c          1	
X banner-1/font.c            2	
X banner-1/makefile          1	
X banner-10                  1	
X banner-10/scripto.alt      1	
X banner-10/scripto.doc      1	
X banner-10/scripto.pas      1	
X banner-10/scripto.set      1	
X banner-11                  1	
X banner-11/MB_Font.uu       2	
X banner-11/Read.Me          1	
X banner-11/mb.c             1	
X banner-2                   1	
X banner-2/banner.c          3	
X banner-3                   1	
X banner-3/Makefile          1	
X banner-3/README            1	
X banner-3/banr.c            3	
X banner-3/banr.f0           1	
X banner-3/banr.f1           1	
X banner-3/banr.f2.uu        1	
X banner-4                   1	
X banner-4/sysvbanner.c      1	
X banner-5                   1	
X banner-5/3db.c             1	
X banner-5/Banner.doc        1	
X banner-5/block.c           2	
X banner-5/cursive.c         3	
X banner-5/kban.c            1	
X banner-5/kban.hlp          1	
X banner-5/kbandat.c         3	
X banner-5/lban.c            1	
X banner-5/lban.dat          1	
X banner-5/leb.c             1	
X banner-5/sban.c            2	
X banner-5/sban.dat          1	
X banner-5/seb.c             1	
X banner-5/vban.c            4	
X banner-6                   1	
X banner-6/banner.6          1	
X banner-6/banner.c          5	
X banner-7                   1	
X banner-7/banner.c          1	
X banner-8                   1	
X banner-8/banner.c          2	
X banner-8/banner.c-org      2	
X banner-9                   1	
X banner-9/Makefile          1	
X banner-9/TODO              1	
X banner-9/block.c           1	
X banner-9/data.c            3	
X cursive-1                  1	
X cursive-1/Makefile         1	
X cursive-1/README           1	
X cursive-1/cursive.6        1	
X cursive-1/cursive.c        2	
X cursive-1/cursive.h        1	
X cursive-1/font.c           2	
X cursive-2                  1	
X cursive-2/Makefile         1	
X cursive-2/cursive.6        1	
X cursive-2/cursive.c        2	
X cursive-2/cursive.h        1	
X cursive-2/font.c           3	
X gothic                     1	
X gothic/gothic.c            2	
END_OF_FILE
if test 2253 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1463 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
Return-Path: stasys!fkk@Germany.Sun.COM
Received: by cognition.pa.dec.com; id AA14191; Sun, 19 Apr 92 08:21:13 -0700
Received: by inet-gw-1.pa.dec.com; id AA19652; Sun, 19 Apr 92 08:21:13 -0700
Received: from snail.Sun.COM (snail.Corp.Sun.COM) by Sun.COM (4.1/SMI-4.1)id AA23626; Sun, 19 Apr 92 08:21:12 PDT
Received: from Germany.Sun.COM (sungy) by snail.Sun.COM (4.1/SMI-4.1)id AA08616; Sun, 19 Apr 92 08:21:10 PDT
Received: from sunde.Germany.Sun.COM by Germany.Sun.COM (4.1/SMI-4.1e.fkk)id AA04595; Sun, 19 Apr 92 17:21:08 +0200
Received: from stasys.UUCP by sunde.Germany.Sun.COM (4.1/SMI-4.1-MHS-7.0)id AA15486; Sun, 19 Apr 92 17:21:06 +0200
Received: by stasys.sta.sub.org [129.157.154.4] (/\==/\ Smail3.1.25.1 #25.1)id <m0lcdFN-000Dv0C@stasys.sta.sub.org>; Sun, 19 Apr 92 16:52 MET DST
Message-Id: <m0lcdFN-000Dv0C@stasys.sta.sub.org>
XFrom: fkk@stasys.sta.sub.org (Frank Kaefer)
Subject: Submission vor comp.sources.unix
To: vixie
Date: Sun, 19 Apr 92 16:52:05 MET DST
Reply-To: jason@Germany.Sun.COM
XX-Mailer: ELM [version 2.3 PL11]
X
Hi Paul!
X
I am sending you a 5 part shell archive and would like to ask you to post
it in comp.sources.unix. The shell archive contains a collection of banner
programs that might be interesting for many netters.
X
Cheers,
XFrank
X-- 
X| Frank Kaefer | fkk@stasys.sta.sub.org | Starnberg, Germany |
X| Compuserve: 72427,2101  |  Internet: frank.kaefer@Sun.COM  |
X| unido!sunde!fkaefer     |      fkaefer@Germany.Sun.COM     |
END_OF_FILE
if test 1463 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test ! -d 'banner-1' ; then
    echo shar: Creating directory \"'banner-1'\"
    mkdir 'banner-1'
fi
if test -f 'banner-1/banner.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-1/banner.c'\"
else
echo shar: Extracting \"'banner-1/banner.c'\" \(5255 characters\)
sed "s/^X//" >'banner-1/banner.c' <<'END_OF_FILE'
X/*
X * The ultimative banner.
X *
X * Written in 1987 by Wolfgang Ocker, reccoware systems, Puchheim
X *
X * It's *not* fast, but nice ...
X *
X * Tested on OS-9/68000, SunOS
X */
X
X#include <stdio.h>
X#ifdef OSK
X#include <modes.h>
X#else
X#define S_IREAD 0
X#endif
X
X
X#define TRUE  1
X#define FALSE 0
X
extern unsigned char charset;      /* Zeichensatz */
extern int           errno;
X
X#ifdef OSK
X/*
X * Signal Handler (Dummy)
X */
int sighandler()
X{
X}
X#endif
X
X/*
X * m a i n
X */
main(argc, argv)
X  int  argc;
X  char *argv[];
X{
X  char          *str, strbuf[200];
X  int           linenum, chnum, i, j, k, count, strnum;
X  unsigned char ch;
X  int           ch_off;
X  unsigned char *ch_addr;
X  unsigned char *font;
X  int           italic, dblsize, samechar;
X  char          bannerchar;
X  FILE          *infp;  
X  char          *from, *plife;
X
X  italic     = dblsize = samechar = FALSE;
X  strnum     = 0;
X  from       = NULL;
X  bannerchar = '*';
X  plife      = NULL;
X
X  /*
X   * Get the arguments. I *hate* getopt(:-). This works nice (and is
X   * simpler).
X   */
X  for (i = 1; i < argc; i++)
X    if (argv[i][0] == '-')
X      for (j = 1; j < strlen(argv[i]); j++)
X        switch(tolower(argv[i][j])) {
X          case '?':
X            usage();
X            exit(1);
X            
X          case 'i':     /* italic printing */
X            italic = TRUE;
X            break;          
X
X          case 'd':     /* double sized characters */
X            dblsize = TRUE;
X            break;
X  
X          case 's':     /* use character to build large char, e.g.
X                         * c becomes
X                         *
X                         *  ccc
X                         * c   
X                         * c          (or so ...)
X                         *  ccc
X                         */
X            samechar = TRUE;
X            break;
X
X#ifdef OSK          
X          case 'l':
X            plife = argv[i] + j + (argv[i][j+1] == '=' ? 2 : 1);
X            j = strlen(argv[i]);
X            break;
X#endif
X  
X          case 'c':       /* character for banner */
X            j += argv[i][j+1] == '=' ? 2 : 1;
X            bannerchar = argv[i][j];
X            break;
X 
X          case 'z':       /* get text from ... */
X            if (from) {
X              usage();
X              fputs("multiple 'z' option not allowed\n", stderr);
X              exit(1);
X            }
X
X            from = argv[i] + j + (argv[i][j+1] == '=' ? 2 : 1);
X            j = strlen(argv[i]);
X            break;
X
X          default:
X            usage();
X            fprintf(stderr, "banner: unknown option '%c'\n", argv[i][j]);
X            exit(1);
X        }
X    else
X      strnum++;     /* count number of strings */
X
X  if (strnum == 0 && from == NULL) {
X    usage();
X#ifdef OSK
X    exit(_errmsg(1, "no string given\n"));
X#else
X    exit(fputs("no string given\n", stderr), 1);
X#endif
X  }
X
X  if (strnum && from) {
X    usage();
X#ifdef OSK
X    exit(_errmsg(1, "'z' option not allowed if string(s) given\n"));
X#else
X  exit(fputs("'z' option not allowed if string(s) given\n", stderr), 1);
X#endif
X  }
X
X  if (from) {
X    if (from[0]) {
X      if ((infp = fopen(from, "r")) == NULL)
X#ifdef OSK
X        exit(_errmsg(errno, "can't open '%s'\n", from));
X#else
X        exit(fprintf(stderr, "can't open '%s'\n", from), errno);
X#endif
X    }
X    else
X      infp = stdin;
X
X  }
X
X#ifdef OSK
X  if (plife && !strcmp(plife, "dont_kill_me"))
X    intercept(sighandler);
X#endif
X
X  font = &charset;
X  str  = strbuf;
X
X  i = 1;
X  while (TRUE) {
X    if (from) {     /* read strings from file/stdin */
X      if (fgets(strbuf, sizeof(strbuf)-1, infp) == NULL)
X        break;
X      strbuf[strlen(strbuf)-1] = '\0';
X    }
X    else {        /* get strings from argument line */
X      if ((str = argv[i++]) == NULL)
X        break;
X      if (str[0] == '-')
X        continue;
X    }
X       
X    for (linenum = 0; linenum < 8; linenum++) {     /* 8 lines per char */
X      for (j = 0; j < (dblsize ? 2 : 1); j++) {
X        putchar('\n');
X
X        if (italic)     /* shift for italics */
X          for (k = linenum; k < 7; k++)
X            fputs(dblsize ? "  " : " ", stdout);
X
X        for (chnum = 0; chnum < strlen(str); chnum++) {
X          ch      = str[chnum];
X          ch_off  = (int) ch * 8;
X          ch_addr = font + ch_off + linenum;
X          outline(ch, *ch_addr, dblsize, bannerchar, samechar);
X        }
X      } 
X    }
X  }
X
X  putchar('\n');
X}
X
X/*
X * o u t l i n e
X */
outline(outchar, outbyte, dblsize, bannerchar, samechar)
X  char outchar, outbyte, bannerchar;
X  int  dblsize, samechar;
X
X{
X  int bc, j;
X
X  for (bc = 7; bc >= 0; bc--)
X    for (j = 0; j < (dblsize ? 2 : 1); j++)
X      if (outbyte & (0x01 << bc))
X        putchar((samechar) ? outchar : bannerchar);
X      else
X        putchar(' ');
X}
X
X/*
X * u s a g e
X */
usage()
X{
X  fputs("Syntax: banner [<opts>] {<string>} [<opts>]\n", stderr);
X  fputs("Function: prints a banner to stdout\n", stderr);
X  fputs("Options:\n", stderr);
X  fputs("     -i          prints italic\n", stderr);
X  fputs("     -d          double size\n", stderr);
X  fputs("     -c=<char>   character\n", stderr);
X  fputs("     -s          use same character\n", stderr);
X  fputs("     -z          read strings from standard input\n", stderr);
X  fputs("     -z=<file>   read strings from <file>\n", stderr);
X}
END_OF_FILE
if test 5255 -ne `wc -c <'banner-1/banner.c'`; then
    echo shar: \"'banner-1/banner.c'\" unpacked with wrong size!
fi
# end of 'banner-1/banner.c'
fi
if test -f 'banner-1/makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-1/makefile'\"
else
echo shar: Extracting \"'banner-1/makefile'\" \(142 characters\)
sed "s/^X//" >'banner-1/makefile' <<'END_OF_FILE'
OBJECTS = banner.o font.o
X
Banner: $(OBJECTS)
X	cc $(OBJECTS) -o Banner
X
banner.o: banner.c
X	cc -c -O banner.c
font.o: font.c
X	cc -c -O font.c
END_OF_FILE
if test 142 -ne `wc -c <'banner-1/makefile'`; then
    echo shar: \"'banner-1/makefile'\" unpacked with wrong size!
fi
# end of 'banner-1/makefile'
fi
if test ! -d 'banner-10' ; then
    echo shar: Creating directory \"'banner-10'\"
    mkdir 'banner-10'
fi
if test -f 'banner-10/scripto.alt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-10/scripto.alt'\"
else
echo shar: Extracting \"'banner-10/scripto.alt'\" \(2107 characters\)
sed "s/^X//" >'banner-10/scripto.alt' <<'END_OF_FILE'
A
X .--.
X( / :
X /--+
X/   |
X
X
B
X .--.
X( / )
X /-<
X/___)
X
X
C
X   .-.
X  /  :
X /
X(__./ @
X
X
D
X .---.
X( /  |
X /   |
X/__,/
X
X
XE
X .----
X( /__
X /
X/___ @
X
X
XF
X .----
X( /__
X /
X/    @
X
X
G
X   .-.
X  /  '
X / -+-
X(__.:
X
X
H
X .-- --
X( /_ /
X /  /
X/  /  @
X
X
I
X   .---
X  ( /
X   /
X__/__ @
X
X
J
X
X    '|
X   / |
X  (__|_@
X  /  |
X (___'
K
X .--   ,
X( / . '
X /-<
X/   \_ @
X
X
L
X    .-.
X   /
X  /
X./____.
X
X
M
X .--..-.
X( ) )  |
X /  |  |
X/   :  | @
X
X
N
X .--.  --
X( ) )  /
X /  | /
X/   :/ @
X
X
O
X .---.
X( /   :
X /    |
X :__ /
X
X
P
X .---.
X( /   )
X /---'
X/      @
X
X
Q
X .---.
X( /   :
X /    |
X :_(><_
X
X
R
X .--.
X( /  )
X /--<
X/    \
X
X
S
X  .-.
X (   '
X  >.
X(___) @
X
X
T
X .-----
X(  /
X  /
X /   @
X
X
U
X .--  --
X( /  /
X /  /
X(_./ @
X
X
V
X .--  --
X( |   /
X  |  /
X  :_/ @
X
X
W
X .--   --
X( |    /
X  | : /
X  :/:/ @
X
X
XX
X .-.  ,-
X(   |/
X  ./|
X /  :__
X
X
Y
X .--  --
X( |   /
X  :_./
X    /  @
X ._/
X
Z
X .----.-
X(   .'
X  ,'
X.'____/
X
X
a
X
X __
X __)
X(__(_
X
X
b
X   /
X  /_
X /  )
X(__/
X
X
c
X
X  ___
X /
X(___
X
X
d
X      /
X  __ /
X /  /
X(__(_ @
X
X
e
X
X  __
X /__)
X(___
X
X  
f
X     .-
X    /
X   /
X__/_ @
X /
X/
g
X
X   __ ,
X  /  /
X (__/_ @
X   /
X(_/
h
X   /
X  /_
X /  )
X/   (_
X
X
i
X
X  *
X /
X(_
X
X
j
X
X     *
X    /
X   / @
X(_/
X
k
X   /
X  /__
X /<
X/  \_
X
X
l
X   /)
X  //
X /
X(_
X
X
m
X
X  _  _
X )' |' )
X/;  :  (_
X
X
n
X
X   _
X )' )
X/;  (_
X
X
o
X
X  __
X /  )
X(__/
X
X
p
X
X    __
X   /  )
X  /_./
X /
X/
q
X
X  __
X /  /
X(_./ @
X  /
X (_
r
X
X  ,__.
X /  /
X/  (__
X
X
s
X
X  __
X (_
X___)
X
X
t
X
X __/_
X  /
X (__
X
X
u
X
X  .  .
X /  /
X(_.(_
X
X
v
X
X .  _
X |  )
X :_/
X
X
w
X
X .     _
X |  .  )
X :_/|_/
X
X
x
X
X  : /
X .+'
X/ :__
X
X
y
X
X .   .
X |  /
X :_/ @
X  /
X-'
z
X
X  __
X  ./
X /__
X
X
X. 
X
X
X
X@ @
X
X
X,
X
X
X
X@ @
X'
X
X(
X  /
X,'
X:
X \ @
X
X
X)
X  \
X   :
X  ,'
X / @
X
X
X-
X
X____
X
X     @
X
X
X&
X    |)
X   /|
X /  |)
X(___/\
X
X
X!
X   /
X  /
X /
X@  @
X
X
X/
X   /
X  /
X /
X/  @
X
X
X?
X  .-.
X (   )
X   /
X  .  @
X
X
X'
X  @
X  '
X
X  @
X
X
X:
X
X  @
X
X @ @
X
X
X;
X
X  @
X
X @ @
X '
X
X%
X() /
X  /
X /
X/ ()
X
X
X*
X
X_\|/_
X /|\
X     @
X
X
X$
X  .-/-
X (_/_
X  /  )
X-/--'
X
X
X0
X   __
X  /  :
X /  /
X:__/
X
X
X1
X   _
X   /
X  /
X_/_
X
X
X2
X  __
X    )
X .--'
X(___
X
X
X3
X  __
X    )
X  -<
X.___)
X
X
X4
X  . .
X / /
X'-/-
X /  @
X
X
X5
X  __
X /
X'--.
X___)
X
X
X6
X   __
X  /
X /-.
X(__)
X
X
X7
X ___
X   /
X  /
X :  @
X
X
X8
X  __
X (  )
X /-<
X(___)
X
X
X9
X  __
X /  )
X '-/
X_./ @
X
X
X=
X     .---
X    ( /
X_    /
X(___/  @
X
X
END_OF_FILE
if test 2107 -ne `wc -c <'banner-10/scripto.alt'`; then
    echo shar: \"'banner-10/scripto.alt'\" unpacked with wrong size!
fi
# end of 'banner-10/scripto.alt'
fi
if test -f 'banner-10/scripto.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-10/scripto.doc'\"
else
echo shar: Extracting \"'banner-10/scripto.doc'\" \(1195 characters\)
sed "s/^X//" >'banner-10/scripto.doc' <<'END_OF_FILE'
X
X  .-.
X (   '   ___  ,_.    *    __  __/_  __ 
X  >.    /    /  :   /    /  )  /   /  )
X(___)  (___ /   :_ (_   /_./  (__ (__/ 
X                       /               
X                      /                
X
Scripto is a program for building cursive writing from text.  To run scripto,
the file scripto.set must be in the current directory.  You may run scripto
interactively by starting the program and entering any readable text.  The
cursive equivalent will appear on the screen.  Of course, input and output may
be redirected so it is possible to type cursive to disk by running this way:
X"scripto >cursive.txt" or disk to disk using "scripto <input.txt >output.txt"
or to printer with "scripto >prn" (note: when writing to printer - dot matrix
only - compressed mode is recommended).
X
If you wish, you may add or change the "font" dataset: scripto.set. After
looking at a few examples, it should become obvious how a font is stored.
XEach character uses the same number of lines.  The "@" sometimes found on the
X"base" line marks where the next cursive letter would be written.  It is a
primitive form of proportional spacing.
X
XEnjoy!
X
manny juan
manny@wet.UUCP or manny@tcomeng.COM
X5/22/91
END_OF_FILE
if test 1195 -ne `wc -c <'banner-10/scripto.doc'`; then
    echo shar: \"'banner-10/scripto.doc'\" unpacked with wrong size!
fi
# end of 'banner-10/scripto.doc'
fi
if test -f 'banner-10/scripto.pas' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-10/scripto.pas'\"
else
echo shar: Extracting \"'banner-10/scripto.pas'\" \(1585 characters\)
sed "s/^X//" >'banner-10/scripto.pas' <<'END_OF_FILE'
program cursive;
type
X  line=array[0..255]of char;
X  str255=string[255];
X  str80=string[80];
X  fontch=array[-3..2,1..11]of char;
X  fontrec=record
X    width:byte;
X    def:fontch;
X  end;
X
var
X  A:string[255];
X  fonts:array[0..255]of fontrec;
X  Inp:str80;
X  Buf:array[1..6]of str255;
X  Oup:array[-3..2]of line absolute Buf;
X
procedure loadfont;
var
X  f:text;
X  Ltr:byte;
X  S:string[12];
X  i,j,
X  m:integer;
begin
X  assign(f,'scripto.set');
X  reset(f);
X  A:='';
X  fillchar(fonts,sizeof(fonts),#0);
X  while not(eof(f)) do
X    begin
X    readln(f,S);
X    A:=A+S;
X    Ltr:=ord(S[1]);
X    for i:=-3 to 2 do
X      begin
X      readln(f,S);
X      if(i=0)then
X        begin
X        if(copy(S,length(S),1)='@')then
X          delete(S,length(S),1);
X        fonts[Ltr].width:=length(S);
X        end;
X      for j:=1 to length(S) do
X        begin
X        fonts[Ltr].def[i,j]:=S[j];
X        end;
X      end;
X    end;
X  {make blank 6 chars wide}
X  fonts[ord(' ')].width:=6;
end; {loadfont}
X
procedure scripto(Inp:str80);
var
X  ch:char;
X  Ltr:byte;
X  i,j,n,c:integer;
begin
X  fillchar(Oup,sizeof(Oup),' ');
X  c:=0;
X  for n:=1 to length(Inp) do
X    begin
X    Ltr:=ord(Inp[n]);
X    for i:=-3 to 2 do
X      begin
X      for j:=1 to 11 do
X        begin
X        ch:=fonts[Ltr].def[i,j];
X        if(ch>' ')then
X          Oup[i,c+j]:=ch;
X        end;
X      end;
X      c:=c+fonts[Ltr].width+1;
X    end;
X  for i:=1 to 6 do
X    begin
X    Buf[i][0]:=chr(c);
X    writeln(Buf[i]);
X    end;
end; {scripto}
X
begin
X  loadfont;
X  readln(Inp);
X  while not(Inp='') do
X    begin
X    scripto(Inp);
X    readln(Inp);
X    end;
end.
END_OF_FILE
if test 1585 -ne `wc -c <'banner-10/scripto.pas'`; then
    echo shar: \"'banner-10/scripto.pas'\" unpacked with wrong size!
fi
# end of 'banner-10/scripto.pas'
fi
if test -f 'banner-10/scripto.set' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-10/scripto.set'\"
else
echo shar: Extracting \"'banner-10/scripto.set'\" \(2066 characters\)
sed "s/^X//" >'banner-10/scripto.set' <<'END_OF_FILE'
A
X .--.
X( / :
X /--+
X/   |
X
X
B
X .--.
X( / )
X /-<
X/___)
X
X
C
X   .-.
X  /  :
X /
X(__./ @
X
X
D
X .---.
X( /  |
X /   |
X/__,/
X
X
XE
X .----
X( /__
X /
X/___ @
X
X
XF
X .----
X( /__
X /
X/    @
X
X
G
X   .-.
X  /  '
X / -+
X(__.:
X
X
H
X .-- --
X( /_ /
X /  /
X/  /  @
X
X
I
X   .---
X  ( /
X   /
X__/__ @
X
X
J
X     .---
X    ( /
X_    /
X(___/  @
X
X
K
X .--   ,
X( / . '
X /-<
X/   \_ @
X
X
L
X    .-.
X   /
X  /
X./____.
X
X
M
X .--..-.
X( / |  |
X /  |  |
X/   :  | @
X
X
N
X .--.  --
X( / |  /
X /  | /
X/   :/ @
X
X
O
X .---.
X( /   :
X /    |
X :__ /
X
X
P
X .---.
X( /   )
X /---'
X/      @
X
X
Q
X .---.
X( /   :
X /    |
X :_(><_
X
X
R
X .--.
X( /  )
X /--<
X/    \
X
X
S
X  .-.
X (   '
X  >.
X(___) @
X
X
T
X .-----
X(  /
X  /
X /   @
X
X
U
X .--  --
X( /  /
X /  /
X(_./ @
X
X
V
X .--  --
X( |   /
X  |  /
X  :_/ @
X
X
W
X .--   --
X( |    /
X  | : /
X  :/:/ @
X
X
XX
X .-.  ,-
X(   |/
X  ./|
X /  :__
X
X
Y
X .--  --
X( |   /
X  :_./
X    /  @
X ._/
X
Z
X .----.-
X(   .'
X  ,'
X.'____/
X
X
a
X
X __
X __)
X(__(_
X
X
b
X   /
X  /_
X /  )
X(__/
X
X
c
X
X  ___
X /
X(___
X
X
d
X      /
X  __ /
X /  /
X(__(_ @
X
X
e
X
X  __
X /__)
X(___
X
X  
f
X     .-
X    /
X   /
X__/_ @
X /
X/
g
X
X   __ ,
X  /  /
X (__/_ @
X   /
X(_/
h
X   /
X  /_
X /  )
X/   (_
X
X
i
X
X  *
X /
X(_
X
X
j
X
X     *
X    /
X   / @
X(_/
X
k
X   /
X  /__
X /<
X/  \_
X
X
l
X   /)
X  //
X /
X(_
X
X
m
X
X   _  _
X )' |' )
X/   :  (_
X
X
n
X
X   _
X )' )
X/   (_
X
X
o
X
X  __
X /  )
X(__/
X
X
p
X
X    __
X   /  )
X  /_./
X /
X/
q
X
X  __
X /  /
X(_./ @
X  /
X (_
r
X
X  ,_.
X /  :
X/   :_
X
X
s
X
X  __
X (_
X___)
X
X
t
X
X __/_
X  /
X (__
X
X
u
X
X  .  .
X /  /
X(_.(_
X
X
v
X
X .  _
X |  )
X :_/
X
X
w
X
X .     _
X |  .  )
X :_/|_/
X
X
x
X
X  : /
X .+'
X/ :__
X
X
y
X
X .   .
X |  /
X :_/ @
X  /
X-'
z
X
X  __
X  ./
X /__
X
X
X. 
X
X
X
X@ @
X
X
X,
X
X
X
X@ @
X'
X
X(
X  /
X,'
X:
X \ @
X
X
X)
X  \
X   :
X  ,'
X / @
X
X
X-
X
X____
X
X     @
X
X
X&
X    |)
X   /|
X /  |)
X(___/\
X
X
X!
X   /
X  /
X /
X@  @
X
X
X/
X   /
X  /
X /
X/  @
X
X
X?
X  .-.
X (   )
X   /
X  .  @
X
X
X'
X  @
X  '
X
X  @
X
X
X:
X
X  @
X
X @ @
X
X
X;
X
X  @
X
X @ @
X '
X
X%
X() /
X  /
X /
X/ ()
X
X
X*
X
X_\|/_
X /|\
X     @
X
X
X$
X  .-/-
X (_/_
X  /  )
X-/--'
X
X
X0
X   __
X  /  :
X /  /
X:__/
X
X
X1
X   _
X   /
X  /
X_/_
X
X
X2
X  __
X    )
X .--'
X(___
X
X
X3
X  __
X    )
X  -<
X.___)
X
X
X4
X  . .
X / /
X'-/-
X /  @
X
X
X5
X  __
X /
X'--.
X___)
X
X
X6
X   __
X  /
X /-.
X(__)
X
X
X7
X ___
X   /
X  /
X :  @
X
X
X8
X  __
X (  )
X /-<
X(___)
X
X
X9
X  __
X /  )
X '-/
X_./ @
X
X
END_OF_FILE
if test 2066 -ne `wc -c <'banner-10/scripto.set'`; then
    echo shar: \"'banner-10/scripto.set'\" unpacked with wrong size!
fi
# end of 'banner-10/scripto.set'
fi
if test ! -d 'banner-11' ; then
    echo shar: Creating directory \"'banner-11'\"
    mkdir 'banner-11'
fi
if test -f 'banner-11/Read.Me' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-11/Read.Me'\"
else
echo shar: Extracting \"'banner-11/Read.Me'\" \(4473 characters\)
sed "s/^X//" >'banner-11/Read.Me' <<'END_OF_FILE'
mb - and just another banner program.
X
No makefile, No manualpage included.
X
It's just another senseless program but I couldn't resist in writing
it. It should just compile ok under OS-9/68k, any *IX flavour and on
nearly every other system (with same small changes...). I could only
test it on OS-9/68k.
X
The main difference to other programs: It uses an external font-file,
so you can change this as you want. The format is very easy:
X256 characters each in a size of 16 byte, displaying in following
order
bit     7 6 5 4 3 2 1 0
byte 0  X X X X X X X X
byte 1  X X X X X X X X
byte 2  X X X X X X X X
byte 3  X X X X X X X X
byte 4  X X X X X X X X
byte 5  X X X X X X X X
byte 6  X X X X X X X X
byte 7  X X X X X X X X
byte 8  X X X X X X X X
byte 9  X X X X X X X X
byte 10 X X X X X X X X
byte 11 X X X X X X X X
byte 12 X X X X X X X X
byte 13 X X X X X X X X
byte 14 X X X X X X X X
byte 15 X X X X X X X X
X
Then 256 characters with a size of 8 bytes each follows, order is the
same as above (but only 8 lines).
X
This file may be prefixed by an OS-9/68k module header of 48 bytes
X(these font files are used on an OS-9 implementation for the Atari ST).
X
The format itself can be found in the Atari ST TOS world very often,
so it's easy to get other fonts (I haven't included any, 'cause I
don't if they are copyrighted, sigh).
X
There is no difference to other programs of the same type, the most
common options are available:
X-f=<file>  use this fontfile instead of $HOME/.font or
X           /dd/SYS/MB_Font (OS-9) / /etc/MB_Font (*IX)
X-l         use the larger (16x8) font (default is 8x8 font)
X-c         print the letters cursive (well not really cursive...)
X-i         invert the printing (exchange for- and background pattern)
X-f=<char>  use <char> as the forground (i.e. write) pattern
X           (default `*')
X-b=<char>  the background (default ` ')
X-s         use the character itself as the forground pattern
X
If no string is given, the strings are read in from stdin until
an EOF is detected.
X
You can print a leading `-' with a construct `--'
X
The included font file represents roughly the ISO 8859/1 character
set.
X
Bug: if a fontfile starts with the bytes 0x4a 0xfc then it is assumed
to be a OS-9 Module and the first 48 bytes are skipped...
X
Some expamples:
X% mb Foo Bar
X*******                 
X **   *                 
X ** *    ****    ****   
X ****   **  **  **  **  
X ** *   **  **  **  **  
X **     **  **  **  **  
X****     ****    ****   
X                        
X******                  
X **  **                 
X **  **  ****   ** ***  
X *****      **   *** ** 
X **  **  *****   **  ** 
X **  ** **  **   **     
X******   *** ** ****    
X                        
X
X$ mb "Foo Bar"
X*******                         ******                  
X **   *                          **  **                 
X ** *    ****    ****            **  **  ****   ** ***  
X ****   **  **  **  **           *****      **   *** ** 
X ** *   **  **  **  **           **  **  *****   **  ** 
X **     **  **  **  **           **  ** **  **   **     
X****     ****    ****           ******   *** ** ****    
X                                                        
X$ mb -lcfXb. "--Foo Bar"
X...............................................................................
X...............................................................................
X...............................................................................
X....................XXXXXXX.........................XXXXXX.....................
X...................XX..............................XX...XX.....................
X..................XX..............................XX...XX......................
X.................XX.......XXXXX...XXXXX..........XX...XX..XXXXX..XXXXXX........
X.........XXXXXX.XXXXX...XX...XX.XX...XX.........XXXXXX.......XX.XX...XX........
X...............XX......XX...XX.XX...XX.........XX...XX..XXXXXX.XX...XX.........
X..............XX......XX...XX.XX...XX.........XX...XX.XX...XX.XX...............
X.............XX......XX...XX.XX...XX.........XX...XX.XX...XX.XX................
X............XX......XX...XX.XX...XX.........XX...XX.XX...XX.XX.................
X...........XX.......XXXXX...XXXXX..........XXXXXX...XXXXXX.XX..................
X...............................................................................
X...............................................................................
X...............................................................................
X
END_OF_FILE
if test 4473 -ne `wc -c <'banner-11/Read.Me'`; then
    echo shar: \"'banner-11/Read.Me'\" unpacked with wrong size!
fi
# end of 'banner-11/Read.Me'
fi
if test -f 'banner-11/mb.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-11/mb.c'\"
else
echo shar: Extracting \"'banner-11/mb.c'\" \(6396 characters\)
sed "s/^X//" >'banner-11/mb.c' <<'END_OF_FILE'
X/*
X *	mb:	another banner program with external fontfiles
X *
X *	(C) Copyrighted 1992 by Ulrich Dessauer, Germering, Germany
X *
X *	You can copy, forward, redistribute the whole package as long
X *	as you make no profit and this copyright messages stays untouched!
X */
X# include	<stdio.h>
X# include	<errno.h>
X# ifdef		OSK
X# include	<modes.h>
X# include	<module.h>
X# define	R_OK		S_IREAD
X# define	MODHEADSIZ	sizeof (struct modhcom)
X# else		/* OSK */
X# include	<fcntl.h>
X# ifndef	R_OK
X# define	R_OK		O_RDONLY
X# endif		/* R_OK */
X# define	MODSYNC		((unsigned long) 0x4afc)
X# define	MODHEADSIZ	0x30
X# if		defined (USG) || defined (SYSV) || defined (SYS5) || defined (HAS_STRCHR)
X# define	index		strchr
X# endif		/* defined (USG) || defined (SYSV) || defined (SYS5) || defined (HAS_STRCHR) */
X# endif		/* OSK */
X
X	/* use an extended cursive mode (fill left and right margin) */
X# define	XTEND_CURSIVE
X	/* binary read for fopen */
X# if		defined (MSDOS) || defined (msdos) || defined (TOS)
X# define	READ_BINARY	"rb"
X# else		/* defined (MSDOS) || defined (msdos) || defined (TOS) */
X# define	READ_BINARY	"r"
X# endif		/* defined (MSDOS) || defined (msdos) || defined (TOS) */
X
X# define	FALSE		(0 == 1)
X# define	TRUE		(1 == 1)
X
X# ifdef		OSK
X# define	DEF_FONTFILE	"/dd/SYS/MB_Font"
X# else		/* OSK */
X# define	DEF_FONTFILE	"/etc/MB_Font"
X# endif		/* OSK */
X
X# define	NO_MEM		exit (_errmsg (errno, "Out of memory!\n"));
X
extern char	*getenv ();
extern char	*index ();
extern char	*malloc ();
X
typedef unsigned char	byte;
X
static char		*fontfile;
static int		large;
static int		cursive;
static int		invers;
static char		forground;
static char		background;
X
X# ifndef	OSK
X/*
X *	Not very portable....
X */
int
X_errmsg (error, fmt, a, b, c)
int error;
char *fmt;
void *a, *b, *c;
X{
X	fputs ("mb: ", stderr);
X	fprintf (stderr, fmt, a, b, c);
X	return (error);
X}
X# endif		/* OSK */
X
static void
banner (s, cset)
char *s;
byte *cset;
X{
X	register byte	*ptr;
X	register int	n;
X	register int	t;
X	register byte	b;
X	register int	max;
X	char		space[16];
X
X	if (cursive)
X# ifdef		XTEND_CURSIVE
X		memset (space, invers ? forground : background, sizeof (space));
X# else		/* XTEND_CURSIVE */
X		strcpy (space, "               ");
X# endif		/* XTEND_CURSIVE */
X	max = large ? 16 : 8;
X	for (n = 0; n < max; ++n) {
X		if (cursive) {
X			space[max- n - 1] = '\0';
X			fputs (space, stdout);
X		}
X		ptr = (byte *) s;
X		while (*ptr) {
X			b = cset[(*ptr << (large ? 4 : 3)) + n];
X			for (t = 7; t >= 0; --t)
X				if (((b & (1 << t)) != 0) ^ invers)
X					putchar (forground ? forground : *ptr);
X				else
X					putchar (background);
X			++ptr;
X		}
X# ifdef		XTEND_CURSIVE
X		if (cursive)
X			for (t = 0; t < n; ++t)
X				putchar (invers ? forground : background);
X# endif		/* XTEND_CURSIVE */
X		putchar ('\n');
X	}
X}
X
static char	*help[] = {
X	"Syntax: mb [<opts>] [<string(s)] [<opts>]\n",
X	"Function: prints a string in large letter\n",
X	"Options:\n",
X	"     -o=<file> Use <file> instead of default font-file\n",
X	"     -l        print an even larger banner than default\n",
X	"     -c        make the banner cursive (eek, not real cursive...)\n",
X	"     -i        invert the characters\n",
X	"     -f=<char> use <char> as the forground pattern\n",
X	"     -b=<char> use <char> as the background pattern\n",
X	"     -s        use the printed character as the forground pattern\n",
X	NULL
X};
X
static void
usage ()
X{
X	register int	t;
X
X	for (t = 0; help[t]; ++t)
X		fputs (help[t], stderr);
X}
X
int
main (ac, av)
int ac;
char *av[];
X{
X	FILE	*fp;
X	byte	msync[2];
X	byte	*csetl, *csets;
X	int	t, err;
X	char	*ptr, *tmp;
X	int	use_char;
X	int	found_string;
X
X	fontfile = NULL;
X	large = FALSE;
X	cursive = FALSE;
X	invers = FALSE;
X	forground = '*';
X	background = ' ';
X	use_char = FALSE;
X	found_string = FALSE;
X	for (t = 1; t < ac; ++t)
X		if ((av[t][0] == '-') && (av[t][1] != '-')) {
X			ptr = av[t] + 1;
X			while (*ptr) {
X				switch (*ptr) {
X					case 'o':
X						ptr += *(ptr + 1) == '=' ? 2 : 1;
X						fontfile = ptr;
X						while (*ptr)
X							++ptr;
X						break;
X					case 'l':
X						large = TRUE;
X						break;
X					case 'c':
X						cursive = TRUE;
X						break;
X					case 'i':
X						invers = TRUE;
X						break;
X					case 'f':
X						ptr += *(ptr + 1) == '=' ? 2 : 1;
X						forground = *ptr;
X						break;
X					case 'b':
X						ptr += *(ptr + 1) == '=' ? 2 : 1;
X						background = *ptr;
X						break;
X					case 's':
X						use_char = TRUE;
X						break;
X					case '?':
X					case 'h':
X					default:
X						usage ();
X						exit (((*ptr == '?') || (*ptr == 'h')) ? 0 :
X							_errmsg (1, "Unknown option '%c'.\n", *ptr));
X				}
X				if (*ptr)
X					++ptr;
X			}
X		} else
X			found_string = TRUE;
X	if (use_char)
X		forground = '\0';
X	if (large) {
X		if (! (csetl = (byte *) malloc (256 * 16)))
X			NO_MEM
X		csets = NULL;
X	} else {
X		if (! (csets = (byte *) malloc (256 * 8)))
X			NO_MEM
X		csetl = NULL;
X	}
X	if (! fontfile) {
X		if (ptr = getenv ("HOME"))
X			if (tmp = malloc (strlen (ptr) + 16)) {
X				sprintf (tmp, "%s/.font", ptr);
X				if (access (tmp, R_OK) != -1)
X					fontfile = tmp;
X				else
X					free (tmp);
X			}
X		if (! fontfile)
X			fontfile = DEF_FONTFILE;
X	}
X	if (! (fp = fopen (fontfile, READ_BINARY)))
X		exit (_errmsg (errno, "Can't open %s.\n", fontfile));
X	if (fread (msync, sizeof (byte), 2, fp) != 2) {
X		fclose (fp);
X		exit (_errmsg (errno, "Can't read first %d byte%s.\n",
X			sizeof (short), sizeof (short) > 1 ? "s" : ""));
X	}
X	if ((msync[0] == (byte) ((MODSYNC >> 8) & 0xff)) && (msync[1] == (byte) (MODSYNC & 0xff)))
X		err = fseek (fp, MODHEADSIZ, 0);
X	else
X		err = fseek (fp, 0, 0);
X	if (err == -1) {
X		fclose (fp);
X		exit (_errmsg (errno, "Can't fseek to start of font data!\n"));
X	}
X	if (large) {
X		if (fread (csetl, sizeof (byte), 16 * 256, fp) != 16 * 256) {
X			fclose (fp);
X			exit (_errmsg (errno, "Can't read font data (large).\n"));
X		}
X	} else {
X		if (fseek (fp, 256 * 16, 1) == -1) {
X			fclose (fp);
X			exit (_errmsg (errno, "Can't fseek to font data.\n"));
X		}
X		if (fread (csets, sizeof (byte), 8 * 256, fp) != 8 * 256) {
X			fclose (fp);
X			exit (_errmsg (errno, "Can't read font data (small).\n"));
X		}
X	}
X	fclose (fp);
X	if (found_string) {
X		for (t = 1; t < ac; ++t)
X			if ((av[t][0] != '-') || (av[t][1] == '-'))
X				banner (av[t] + (av[t][0] == '-' ? 1 : 0), large ? csetl : csets);
X	} else if (ptr = malloc (130)) {
X		while (fgets (ptr, 128, stdin)) {
X			if (tmp = index (ptr, '\n'))
X				*tmp = '\0';
X			banner (ptr, large ? csetl : csets);
X		}
X		free (ptr);
X	}
X}
END_OF_FILE
if test 6396 -ne `wc -c <'banner-11/mb.c'`; then
    echo shar: \"'banner-11/mb.c'\" unpacked with wrong size!
fi
# end of 'banner-11/mb.c'
fi
if test ! -d 'banner-2' ; then
    echo shar: Creating directory \"'banner-2'\"
    mkdir 'banner-2'
fi
if test ! -d 'banner-3' ; then
    echo shar: Creating directory \"'banner-3'\"
    mkdir 'banner-3'
fi
if test -f 'banner-3/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-3/Makefile'\"
else
echo shar: Extracting \"'banner-3/Makefile'\" \(70 characters\)
sed "s/^X//" >'banner-3/Makefile' <<'END_OF_FILE'
CFLAGS = -O -s
X
all: banr
X
banr:
X	cc $(CFLAGS) banr.c -o $@ -ltermcap
END_OF_FILE
if test 70 -ne `wc -c <'banner-3/Makefile'`; then
    echo shar: \"'banner-3/Makefile'\" unpacked with wrong size!
fi
# end of 'banner-3/Makefile'
fi
if test -f 'banner-3/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-3/README'\"
else
echo shar: Extracting \"'banner-3/README'\" \(656 characters\)
sed "s/^X//" >'banner-3/README' <<'END_OF_FILE'
banr is a banner program with a relatively small (4 line) font.  It uses the
terminal's underline capability (from termcap) if found and not suppressed
X(with -n) to produce a more readable font.
X
This program is in the public domain.  Do whatever you want with/to it.
X
Installation:
X
X	Compile with "make".
X
X	It was successfully built on SunOS 3.5 - 4.1.1.
X
X	rindex() can be replaced by strrchr() [or throw it away -- it doesn't
X	do anything important].
X
Included are test/demonstration files produced by:
X
X	banr -n < banr.f0 > banr.f1
X	banr < banr.f0 > banr.f2	(on an xterm)
X
X _  __  ___ 
X/_\ |_)  |  
X| | | \  |  
X
Art Messenger
art@wilbur.coyote.trw.com
END_OF_FILE
if test 656 -ne `wc -c <'banner-3/README'`; then
    echo shar: \"'banner-3/README'\" unpacked with wrong size!
fi
# end of 'banner-3/README'
fi
if test -f 'banner-3/banr.f0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-3/banr.f0'\"
else
echo shar: Extracting \"'banner-3/banr.f0'\" \(101 characters\)
sed "s/^X//" >'banner-3/banr.f0' <<'END_OF_FILE'
ABCDEFGHIJKLM
NOPQRSTUVWXYZ
abcdefghijklm
nopqrstuvwxyz
X0123456789
X!"#$%&'()*+;-./
X:;<=>?@[\]^_`{|}~
END_OF_FILE
if test 101 -ne `wc -c <'banner-3/banr.f0'`; then
    echo shar: \"'banner-3/banr.f0'\" unpacked with wrong size!
fi
# end of 'banner-3/banr.f0'
fi
if test -f 'banner-3/banr.f1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-3/banr.f1'\"
else
echo shar: Extracting \"'banner-3/banr.f1'\" \(1292 characters\)
sed "s/^X//" >'banner-3/banr.f1' <<'END_OF_FILE'
X _  __   _  __  ___ ___  _  _ _ _  _ _ _ _   _  _ 
X/_\ |_) / ' | \ |_  |_  / _ |_| |  | |_/ |   |\/| 
X| | |_) \_, |_/ |__ |   \_| | | | \/ | \ |__ |  | 
X                                                  
X_  _  _  __   _  __   _  ___ _ _ _  _ _  _ _ _ _ _ __ 
X|\ | / \ |_) / \ |_) (_'  |  | | \  / |  | \_/ \_/  / 
X| \| \_/ |   \_X | \ ,_)  |  \_/  \/  \/\/ / \  |  /_ 
X                                                      
X                    _                         
X _. |_   _  _|  _  |_  _  |_  .  . |  | ._ _  
X(_| |_) |_ (_| (-' |  (_| | | |  | |< | | | | 
X                      ._)       ./            
X                                            
X._   _  ._   _. ._ _ |                    _ 
X| | (_) |_) (_| |  \ | |_| \/ \/\/ >< \_/ / 
X        |     |                       _/    
X _    _  _       __     __  _   _  
X/.\ |  ) _) /_| |_   /   / (_) (_) 
X\_/ | /_ _)   | ._) (_) /  (_)  /  
X                                   
X          __                              
X| // |_| (|  o/ o  / / \ \/ _|_ o __    / 
X.    |_| _|) /o (X   \ / /\  |  o    o /  
X     | |                        /         
X            _      __    __                  
o o / __ \ ' )  _  |  \   | /\    \ ( | ) ^v 
o o \ __ /  !  (Q) |_  \ _|    __   ( | )    
X  /                                          
END_OF_FILE
if test 1292 -ne `wc -c <'banner-3/banr.f1'`; then
    echo shar: \"'banner-3/banr.f1'\" unpacked with wrong size!
fi
# end of 'banner-3/banr.f1'
fi
if test -f 'banner-3/banr.f2.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-3/banr.f2.uu'\"
else
echo shar: Extracting \"'banner-3/banr.f2.uu'\" \(3638 characters\)
sed "s/^X//" >'banner-3/banr.f2.uu' <<'END_OF_FILE'
begin 644 banr.f2
M(!M;-&T@&UMM(" ;6S1M(!M;;1M;-&T@&UMM(" @&ULT;2 ;6VT@(!M;-&T@
M&UMM&ULT;2 ;6VT@(!M;-&T@&UMM&ULT;2 ;6VT;6S1M(!M;;2 ;6S1M(!M;
M;1M;-&T@&UMM&ULT;2 ;6VT@(!M;-&T@&UMM(" ;6S1M(!M;;2 ;6S1M(!M;
M;2 ;6S1M(!M;;2 @&ULT;2 ;6VT@&ULT;2 ;6VT@&ULT;2 ;6VT@&ULT;2 ;
M6VT@(" ;6S1M(!M;;2 @&ULT;2 ;6VT@"B\;6S1M(!M;;5P@?!M;-&T@&UMM
M*2 O("<@?"!<('P;6S1M(!M;;2 @?!M;-&T@&UMM(" O(!M;-&T@&UMM('P;
M6S1M(!M;;7P@?" @?"!\&ULT;2 ;6VTO('P@("!\7"]\( H;6S1M?!M;;2 ;
M6S1M?!M;;2 ;6S1M?!M;;1M;-&T@&UMM*2!<&ULT;2 ;6VTL(!M;-&U\&UMM
M&ULT;2 ;6VTO(!M;-&U\&UMM&ULT;2 ;6VT;6S1M(!M;;2 ;6S1M?!M;;2 @
M(%P;6S1M(!M;;7P@&ULT;7P;6VT@&ULT;7P;6VT@&ULT;7P;6VT@7"\@&ULT
M;7P;6VT@&ULT;5P;6VT@&ULT;7P;6VT;6S1M(!M;;1M;-&T@&UMM(!M;-&U\
M&UMM(" ;6S1M?!M;;2 *(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @
M(" @(" @(" @(" @(" @(" @(" *&ULT;2 ;6VT@(!M;-&T@&UMM(" ;6S1M
M(!M;;2 @&ULT;2 ;6VT;6S1M(!M;;2 @(!M;-&T@&UMM(" ;6S1M(!M;;1M;
M-&T@&UMM(" @&ULT;2 ;6VT@(!M;-&T@&UMM&ULT;2 ;6VT;6S1M(!M;;2 ;
M6S1M(!M;;2 ;6S1M(!M;;2 ;6S1M(!M;;2 @&ULT;2 ;6VT@&ULT;2 ;6VT@
M(!M;-&T@&UMM(!M;-&T@&UMM(!M;-&T@&UMM(!M;-&T@&UMM(!M;-&T@&UMM
M(!M;-&T@&UMM&ULT;2 ;6VT@"GQ<('P@+R!<('P;6S1M(!M;;2D@+R!<('P;
M6S1M(!M;;2D@*!M;-&T@&UMM)R @?" @?"!\(%P@("\@?" @?"!<&ULT;2 ;
M6VTO(%P;6S1M(!M;;2\@("\@"AM;-&U\&UMM(%P;6S1M?!M;;2!<&ULT;2 ;
M6VTO(!M;-&U\&UMM(" @7!M;-&T@&UMM6" ;6S1M?!M;;2 ;6S1M7!M;;2 L
M&ULT;2 ;6VTI(" ;6S1M?!M;;2 @7!M;-&T@&UMM+R @7"\@(%PO7"\@&ULT
M;2\;6VT@&ULT;5P;6VT@(!M;-&U\&UMM(" ;6S1M+QM;;1M;-&T@&UMM( H@
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @
M(" @(" @(" *(" @(" @(" @(" @(" @(" @(" ;6S1M(!M;;2 @(" @(" @
M(" @(" @(" @(" @(" @(" *(!M;-&T@&UMM+B!\&ULT;2 ;6VT@(" ;6S1M
M(!M;;2 @&ULT;2 ;6VU\(" ;6S1M(!M;;2 @&ULT;7P;6VT;6S1M(!M;;2 @
M&ULT;2 ;6VT@('P;6S1M(!M;;2 @+B @+B!\("!\("X;6S1M(!M;;2 ;6S1M
M(!M;;2 @"B@;6S1M(!M;;7P@?!M;-&T@&UMM*2!\&ULT;2 ;6VT@*!M;-&T@
M&UMM?" H&ULT;2T;6VTG('P@("@;6S1M(!M;;7P@?"!\('P@('P@?#P@&ULT
M;7P;6VT@?"!\('P@"B @(" @(" @(" @(" @(" @(" @(" N&ULT;2 ;6VTI
M(" @(" @("XO(" @(" @(" @(" @"B @(" @(" @(" @(" @(" @(" @(" @
M(" @(" @(" @(" @(" @(" @(" @"BX;6S1M(!M;;2 @(!M;-&T@&UMM(" N
M&ULT;2 ;6VT@(" ;6S1M(!M;;2X@+AM;-&T@&UMM(!M;-&T@&UMM(!M;-&U\
M&UMM(" @(" @(" @(" @(" @(" @(" ;6S1M(!M;;2 *?"!\("@;6S1M(!M;
M;2D@?!M;-&T@&UMM*2 H&ULT;2 ;6VU\('P@(!M;-&U<&UMM('P@?!M;-&T@
M&UMM?"!<+R!<+UPO(#X\(%P;6S1M(!M;;2\@&ULT;2\;6VT@"B @(" @(" @
M?" @(" @?" @(" @(" @(" @(" @(" @(" @(" @&ULT;2 ;6VTO(" @( H@
M&ULT;2 ;6VT@(" @&ULT;2 ;6VT@(!M;-&T@&UMM(" @(" @(!M;-&T@&UMM
M&ULT;2 ;6VT@(" @(!M;-&T@&UMM&ULT;2 ;6VT@(!M;-&T@&UMM(" @&ULT
M;2 ;6VT@( HO+EP@?" @*2 ;6S1M(!M;;2D@&ULT;2\;6VT;6S1M(!M;;7P@
M?!M;-&T@&UMM(" @&ULT;2\;6VT@(" O("@;6S1M(!M;;2D@*!M;-&T@&UMM
M*2 *7!M;-&T@&UMM+R!\(!M;-&TO&UMM&ULT;2 ;6VT@&ULT;2 ;6VTI(" @
M?" N&ULT;2 ;6VTI("@;6S1M(!M;;2D@+R @*!M;-&T@&UMM*2 @+R @"B @
M(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @"B @(" @(" @(" ;
M6S1M(!M;;1M;-&T@&UMM(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @
M"GP@+R\@&ULT;7P;6VT;6S1M(!M;;1M;-&U\&UMM("@;6S1M?!M;;2 @;R\@
M;R @+R O(%P@&ULT;5P;6VT;6S1M+QM;;2 ;6S1M(!M;;1M;-&U\&UMM&ULT
M;2 ;6VT@;R ;6S1M(!M;;1M;-&T@&UMM(" @("\@"BX@(" @&ULT;7P;6VT;
M6S1M(!M;;1M;-&U\&UMM(!M;-&T@&UMM&ULT;7P;6VTI("]O("A8(" @7" O
M("]<("!\("!O(" @(&\@+R @"B @(" @?"!\(" @(" @(" @(" @(" @(" @
M(" @(" @+R @(" @(" @( H@(" @(" @(" @(" ;6S1M(!M;;2 @(" @(!M;
M-&T@&UMM&ULT;2 ;6VT@(" @&ULT;2 ;6VT;6S1M(!M;;2 @(" @(" @(" @
M(" @(" @( IO(&\@+R ;6S1M(!M;;1M;-&T@&UMM(%P@)R I(" ;6S1M(!M;
M;2 @?" @7" @('P@+UP@(" @7" H('P@*2!>=B *;R!O(%P@&ULT;2 ;6VT;
M6S1M(!M;;2 O(" A(" H&ULT;5$;6VT;6S1M*1M;;2 ;6S1M?!M;;1M;-&T@
M&UMM("!<(!M;-&T@&UMM&ULT;7P;6VT@(" @&ULT;2 ;6VT;6S1M(!M;;2 @
M("@@?" I(" @( H@("\@(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @
X,(" @(" @(" @(" *
X 
end
END_OF_FILE
if test 3638 -ne `wc -c <'banner-3/banr.f2.uu'`; then
    echo shar: \"'banner-3/banr.f2.uu'\" unpacked with wrong size!
fi
# end of 'banner-3/banr.f2.uu'
fi
if test ! -d 'banner-4' ; then
    echo shar: Creating directory \"'banner-4'\"
    mkdir 'banner-4'
fi
if test -f 'banner-4/sysvbanner.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-4/sysvbanner.c'\"
else
echo shar: Extracting \"'banner-4/sysvbanner.c'\" \(6293 characters\)
sed "s/^X//" >'banner-4/sysvbanner.c' <<'END_OF_FILE'
X/*****************************************************************
X * 
X * SYSVbanner.c
X * 
X * This is a PD version of the SYS V banner program (at least I think 
X * it is compatible to SYS V) which I wrote to use with the clock 
X * program written by:
X **     DCF, Inc.
X **     14623 North 49th Place
X **     Scottsdale, AZ 85254
X * and published in the net comp.sources.misc newsgroup in early July 
X * since the BSD banner program works quite differently.
X * 
X * There is no copyright or responsibility accepted for the use
X * of this software.
X * 
X * Brian Wallis, brw@jim.odr.oz, 4 July 1988
X *
X *****************************************************************/
X
char *glyphs[] = {
X"         @@@  @@@ @@@  @ @   @@@@@ @@@   @  @@     @@@  ",
X"         @@@  @@@ @@@  @ @  @  @  @@ @  @  @  @    @@@   ",
X"         @@@   @   @ @@@@@@@@  @   @@@ @    @@      @   ",
X"          @            @ @   @@@@@    @    @@@     @    ",
X"                     @@@@@@@   @  @  @ @@@@   @ @       ",
X"         @@@           @ @  @  @  @ @  @ @@    @        ",
X"         @@@           @ @   @@@@@ @   @@@ @@@@ @       ",
X
X"   @@    @@                                            @",
X"  @        @   @   @    @                             @ ",
X" @          @   @ @     @                            @  ",
X" @          @ @@@ @@@ @@@@@   @@@   @@@@@           @   ",
X" @          @   @ @     @     @@@           @@@    @    ",
X"  @        @   @   @    @      @            @@@   @     ",
X"   @@    @@                   @             @@@  @      ",
X
X"  @@@     @    @@@@@  @@@@@ @      @@@@@@@ @@@@@ @@@@@@@",
X" @   @   @@   @     @@     @@    @ @      @     @@    @ ",
X"@ @   @ @ @         @      @@    @ @      @          @  ",
X"@  @  @   @    @@@@@  @@@@@ @@@@@@@ @@@@@ @@@@@@    @   ",
X"@   @ @   @   @            @     @       @@     @  @    ",
X" @   @    @   @      @     @     @ @     @@     @  @    ",
X"  @@@   @@@@@ @@@@@@@ @@@@@      @  @@@@@  @@@@@   @    ",
X
X" @@@@@  @@@@@    @     @@@      @           @     @@@@@ ",
X"@     @@     @  @ @    @@@     @             @   @     @",
X"@     @@     @   @            @     @@@@@     @        @",
X" @@@@@  @@@@@@         @@@   @                 @     @@ ",
X"@     @      @   @     @@@    @     @@@@@     @     @   ",
X"@     @@     @  @ @     @      @             @          ",
X" @@@@@  @@@@@    @     @        @           @       @   ",
X
X" @@@@@    @   @@@@@@  @@@@@ @@@@@@ @@@@@@@@@@@@@@ @@@@@ ",
X"@     @  @ @  @     @@     @@     @@      @      @     @",
X"@ @@@ @ @   @ @     @@      @     @@      @      @      ",
X"@ @ @ @@     @@@@@@@ @      @     @@@@@@  @@@@@  @  @@@@",
X"@ @@@@ @@@@@@@@     @@      @     @@      @      @     @",
X"@     @@     @@     @@     @@     @@      @      @     @",
X" @@@@@ @     @@@@@@@  @@@@@ @@@@@@ @@@@@@@@       @@@@@ ",
X
X"@     @  @*@        @@    @ @      @     @@     @@@@@@@@",
X"@     @   @         @@   @  @      @@   @@@@    @@     @",
X"@     @   @         @@  @   @      @ @ @ @@ @   @@     @",
X"@@@@@@@   @         @@@@    @      @  @  @@  @  @@     @",
X"@     @   @   @     @@  @   @      @     @@   @ @@     @",
X"@     @   @   @     @@   @  @      @     @@    @@@     @",
X"@     @  @@@   @@@@@ @    @ @@@@@@@@     @@     @@@@@@@@",
X
X"@@@@@@  @@@@@ @@@@@@  @@@@@ @@@@@@@@     @@     @@     @",
X"@     @@     @@     @@     @   @   @     @@     @@  @  @",
X"@     @@     @@     @@         @   @     @@     @@  @  @",
X"@@@@@@ @     @@@@@@@  @@@@@    @   @     @@     @@  @  @",
X"@      @   @ @@   @        @   @   @     @ @   @ @  @  @",
X"@      @    @ @    @ @     @   @   @     @  @ @  @  @  @",
X"@       @@@@ @@     @ @@@@@    @    @@@@@    @    @@ @@ ",
X
X"@     @@     @@@@@@@@ @@@@@ @       @@@@@    @          ",
X" @   @  @   @      @  @      @          @   @ @         ",
X"  @ @    @ @      @   @       @         @  @   @        ",
X"   @      @      @    @        @        @               ",
X"  @ @     @     @     @         @       @               ",
X" @   @    @    @      @          @      @               ",
X"@     @   @   @@@@@@@ @@@@@       @ @@@@@        @@@@@@@",
X
X"  @@@                                                   ",
X"  @@@     @@   @@@@@   @@@@  @@@@@  @@@@@@ @@@@@@  @@@@ ",
X"   @     @  @  @    @ @    @ @    @ @      @      @    @",
X"    @   @    @ @@@@@  @      @    @ @@@@@  @@@@@  @     ",
X"        @@@@@@ @    @ @      @    @ @      @      @  @@@",
X"        @    @ @    @ @    @ @    @ @      @      @    @",
X"        @    @ @@@@@   @@@@  @@@@@  @@@@@@ @       @@@@ ",
X 
X"                                                        ",
X" @    @    @        @ @    @ @      @    @ @    @  @@@@ ",
X" @    @    @        @ @   @  @      @@  @@ @@   @ @    @",
X" @@@@@@    @        @ @@@@   @      @ @@ @ @ @  @ @    @",
X" @    @    @        @ @  @   @      @    @ @  @ @ @    @",
X" @    @    @   @    @ @   @  @      @    @ @   @@ @    @",
X" @    @    @    @@@@  @    @ @@@@@@ @    @ @    @  @@@@ ",
X 
X"                                                        ",
X" @@@@@   @@@@  @@@@@   @@@@   @@@@@ @    @ @    @ @    @",
X" @    @ @    @ @    @ @         @   @    @ @    @ @    @",
X" @    @ @    @ @    @  @@@@     @   @    @ @    @ @    @",
X" @@@@@  @  @ @ @@@@@       @    @   @    @ @    @ @ @@ @",
X" @      @   @  @   @  @    @    @   @    @  @  @  @@  @@",
X" @       @@@ @ @    @  @@@@     @    @@@@    @@   @    @",
X 
X"                       @@@     @     @@@   @@    @ @ @ @",
X" @    @  @   @ @@@@@@ @        @        @ @  @  @ @ @ @ ",
X"  @  @    @ @      @  @        @        @     @@ @ @ @ @",
X"   @@      @      @  @@                 @@        @ @ @ ",
X"   @@      @     @    @        @        @        @ @ @ @",
X"  @  @     @    @     @        @        @         @ @ @ ",
X" @    @    @   @@@@@@  @@@     @     @@@         @ @ @ @"};
X
X
main(argc,argv)
X     int argc;
X     char *argv[];
X{
X  int a,b,c,len,ind;
X  char line[80];
X
X  for(argv++;--argc;argv++){
X    len=strlen(*argv);
X    if(len>10)
X      len=10;
X    for(a=0;a<7;a++){
X      for(b=0;b<len;b++){
X        if((ind=(*argv)[b]-' ')<0)
X          ind=0;
X        for(c=0;c<7;c++){
X          line[b*8+c] = glyphs[(ind/8*7)+a][(ind%8*7)+c];
X        }
X        line[b*8+7] = ' ';
X      }
X      for(b=len*8-1;b>=0;b--){
X        if(line[b]!=' ')
X          break;
X        line[b]='\0';
X      }
X      puts(line);
X    }
X    puts("");
X  }
X}
END_OF_FILE
if test 6293 -ne `wc -c <'banner-4/sysvbanner.c'`; then
    echo shar: \"'banner-4/sysvbanner.c'\" unpacked with wrong size!
fi
# end of 'banner-4/sysvbanner.c'
fi
if test ! -d 'banner-5' ; then
    echo shar: Creating directory \"'banner-5'\"
    mkdir 'banner-5'
fi
if test -f 'banner-5/3db.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-5/3db.c'\"
else
echo shar: Extracting \"'banner-5/3db.c'\" \(5167 characters\)
sed "s/^X//" >'banner-5/3db.c' <<'END_OF_FILE'
X/* 3db : three-dimensional banner
X *
X * Who the heck wrote original Pascal version?
X *
X * C version by Han, Yun-Su
X * 880505 KAIST undergraduate Dept of Life Science
X */
X
X#include <stdio.h>
X
main(argc, argv)
int argc;
char **argv;
X{
X	char line[256];
X
X	if (argc < 2)	{
X		fprintf(stderr, "&:^)\n");
X		exit(1);
X		}
X	getline(line, argc, argv);
X	lowerline(line);
X	putline(line);
X}
X
getline(s, n, v)
char *s;
int n;
char *v[];
X{
X	int i, j;
X
X	strcpy(s, "");
X	for (i = 1; i < n; i++, s++)	{
X		for (j = 0; v[i][j] != '\0'; j++, s++)
X			*s = v[i][j];
X		*s = ' ';
X		}
X	s--;
X	*s = '\0';
X}
X
lowerline(s)
char *s;
X{
X	char *p;
X
X	for (p = s; *p != '\0'; p++)
X		if (*p >= 'A' && *p <= 'Z')
X			*p = *p - 'A' + 'a';
X}
X
X#define	Height		8	/* Height of 3D Font */
X#define	Blank		"     "
putline(s)
char *s;
X{
X	static char *data[] = {
X		"     ____    ",
X		"   /____/ \\  ",
X		" /|     \\ /| ",
X		"| |______| | ",
X		"|/_______| | ",
X		"| |      | | ",
X		"| |      | | ",
X		"|/       |/  ",
X		"  _______    ",
X		" /______/ \\  ",
X		"| |     \\ /| ",
X		"| |______|/  ",
X		"|/______/ \\  ",
X		"| |     \\ /| ",
X		"| |______|/  ",
X		"|/______/    ",
X		"     _____    ",
X		"   /____ / \\  ",
X		" /|      \\ /| ",
X		"| |       |/  ",
X		"| |           ",
X		"| |        /| ",
X		"|/ \\______|/  ",
X		" \\ /_____/    ",
X		"  _______    ",
X		" /______/ \\  ",
X		"| |     \\ /| ",
X		"| |      | | ",
X		"| |      | | ",
X		"| |      | | ",
X		"| |______|/  ",
X		"|/______/    ",
X		"  __________ ",
X		" /_________/ ",
X		"| |          ",
X		"| |______    ",
X		"|/______/    ",
X		"| |          ",
X		"| |_________ ",
X		"|/_________/ ",
X		"  __________ ",
X		" /_________/ ",
X		"| |          ",
X		"| |______    ",
X		"|/______/    ",
X		"| |          ",
X		"| |          ",
X		"|/           ",
X		"     _____    ",
X		"   /____ / \\  ",
X		" /|      \\ /| ",
X		"| |       |/  ",
X		"| |       __  ",
X		"| |     /_ /| ",
X		"|/ \\______|/  ",
X		" \\ /_____/    ",
X		"             ",
X		" /|       /| ",
X		"| |      | | ",
X		"| |______| | ",
X		"|/_______| | ",
X		"| |      | | ",
X		"| |      | | ",
X		"|/       |/  ",
X		" _____ ",
X		"/____/ ",
X		"  | |  ",
X		"  | |  ",
X		"  | |  ",
X		"  | |  ",
X		" _| |_ ",
X		"/_|/_/ ",
X		"          ",
X		"       /| ",
X		"      | | ",
X		"      | | ",
X		"      | | ",
X		"      | | ",
X		"/ \\___|/  ",
X		"\\ /__/    ",
X		"            ",
X		" /|      /  ",
X		"| |    /    ",
X		"| |  /      ",
X		"| |/  \\     ",
X		"|/| \\   \\   ",
X		"| |   \\   \\ ",
X		"|/      \\ / ",
X		"           ",
X		" /|        ",
X		"| |        ",
X		"| |        ",
X		"| |        ",
X		"| |        ",
X		"| |_______ ",
X		"|/_______/ ",
X		"               ",
X		" / \\        /| ",
X		"|\\  \\      / | ",
X		"| \\  \\    /| | ",
X		"| |\\  \\  / | | ",
X		"| | \\  \\/  | | ",
X		"| |  \\ /   | | ",
X		"|/         |/  ",
X		"           ",
X		" / \\    /| ",
X		"|\\  \\  | | ",
X		"| \\  \\ | | ",
X		"| |\\  \\| | ",
X		"| | \\  | | ",
X		"| |  \\ | | ",
X		"|/    \\|/  ",
X		"     ____    ",
X		"   /___ / \\  ",
X		" /|     \\ /| ",
X		"| |      | | ",
X		"| |      | | ",
X		"| |      | | ",
X		"|/ \\ ____|/  ",
X		" \\ /____/    ",
X		"  _______    ",
X		" /______/ \\  ",
X		"| |     \\ /| ",
X		"| |______|/  ",
X		"|/______/    ",
X		"| |          ",
X		"| |          ",
X		"|/           ",
X		"     ____     ",
X		"   /___ / \\   ",
X		" /|     \\ /|  ",
X		"| |      | |  ",
X		"| |      | |  ",
X		"| |     /| |  ",
X		"|/ \\ ___\\|/ \\ ",
X		" \\ /____/ \\ / ",
X		"  _______    ",
X		" /______/ \\  ",
X		"| |     \\ /| ",
X		"| |______|/  ",
X		"|/______/    ",
X		"| | \\   \\    ",
X		"| |   \\   \\  ",
X		"|/      \\ /  ",
X		"     _____    ",
X		"   /____ / \\  ",
X		" /|      \\ /  ",
X		"|/ \\ _____    ",
X		" \\ /____ / \\  ",
X		"         \\ /| ",
X		" / \\ _____|/  ",
X		" \\ /_____/    ",
X		" _______________ ",
X		"/______________/ ",
X		"       | |       ",
X		"       | |       ",
X		"       | |       ",
X		"       | |       ",
X		"       | |       ",
X		"       |/        ",
X		"             ",
X		" /|       /| ",
X		"| |      | | ",
X		"| |      | | ",
X		"| |      | | ",
X		"| |      | | ",
X		"|/ \\ ____|/  ",
X		" \\ /____/    ",
X		"              ",
X		"/ \\         / ",
X		"\\  \\       /  ",
X		" \\  \\     /   ",
X		"  \\  \\   /    ",
X		"   \\  \\ /     ",
X		"    \\  /      ",
X		"     \\/       ",
X		"                     ",
X		"/ \\                / ",
X		"\\  \\              /  ",
X		" \\  \\     /\\     /   ",
X		"  \\  \\   /  \\   /    ",
X		"   \\  \\ / \\  \\ /     ",
X		"    \\  /   \\  /      ",
X		"     \\/     \\/       ",
X		"              ",
X		"/ \\         / ",
X		"\\   \\     /   ",
X		"  \\   \\ /     ",
X		"    \\ / \\     ",
X		"    / \\   \\   ",
X		"  /     \\   \\ ",
X		"/         \\ / ",
X		"              ",
X		"/ \\         / ",
X		"\\   \\     /   ",
X		"  \\   \\ /     ",
X		"    \\ /|      ",
X		"     | |      ",
X		"     | |      ",
X		"     |/       ",
X		" ____________ ",
X		"/___________/ ",
X		"          /   ",
X		"        /     ",
X		"      /       ",
X		"    /         ",
X		"  /__________ ",
X		"/___________/ ",
X		""
X		};
X	int i;
X	char *p;
X
X	for (i = 0; i < Height; i++)	{
X		for (p = s; *p != '\0'; p++)
X			if (*p < 'a' || *p > 'z')
X				printf(Blank);
X			else
X				printf("%s", data[(*p - 'a') * Height + i]);
X		printf("\n");
X		}
X}
END_OF_FILE
if test 5167 -ne `wc -c <'banner-5/3db.c'`; then
    echo shar: \"'banner-5/3db.c'\" unpacked with wrong size!
fi
# end of 'banner-5/3db.c'
fi
if test -f 'banner-5/Banner.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-5/Banner.doc'\"
else
echo shar: Extracting \"'banner-5/Banner.doc'\" \(854 characters\)
sed "s/^X//" >'banner-5/Banner.doc' <<'END_OF_FILE'
X===============================================================================
Banner : Collected by Han YoonSoo KAIST undergradute 880505
X===============================================================================
file name	: description
X===============================================================================
block.c		: block style banner (english)
cursive.c	: cursive (english)
kban.c		: semi's banner (korean and english)
kbandat.c	: data file for 'kban.c'
kban.hlp	: help file for 'kban'
lban.c		: large korean banner
lban.dat	: data file for 'lban.c'
sban.c		: small korean banner
sban.dat	: data file for 'sban.c'
vban.c		: vertical banner (english)
X3db.c		: three-dimensional banner (english)
leb.c		: large english banner
seb.c		: small english banner
X-------------------------------------------------------------------------------
END_OF_FILE
if test 854 -ne `wc -c <'banner-5/Banner.doc'`; then
    echo shar: \"'banner-5/Banner.doc'\" unpacked with wrong size!
fi
# end of 'banner-5/Banner.doc'
fi
if test -f 'banner-5/kban.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-5/kban.c'\"
else
echo shar: Extracting \"'banner-5/kban.c'\" \(5312 characters\)
sed "s/^X//" >'banner-5/kban.c' <<'END_OF_FILE'
X/********************************************************/
X/*							*/
X/*	SEMI's BANNER ( Ver 1.21- ) :			*/
X/*							*/
X/*		made	by Koh,BongGyun			*/
X/*			in '91.4 ( Ver 1.0- )		*/
X/*			   '91.5 ( Ver 1.11- )		*/
X/*			   '91.9			*/
X/*							*/
X/*		e-mail to e910017@xserver.kaist.ac.kr	*/
X/*							*/
X/********************************************************/
X
X#include <stdio.h>
X
X#define	END	'\0'
X#define	NO	-1
X#define DATFILE	"kbandat.c"
X
X#include DATFILE
X
char	*data;				/* data inputed */
short	font[ _WIDTH+2 ][ MAX_LEN ];	/* font data to output */
X	/* font[ _WIDTH ] : width of letter, font[ _WIDTH+1 ] : cmode */
X
short	count;	/* pass1: now reading count-th character in data */
X		/* output: now reading count-th font */
short	digit;	/* pass1: now making digit-th font */
X		/* output: total digits of font */
X
main( argc, argv )
X	short	argc;
X	char	*argv[];
X{
X	int	i;
X	void	pass1(), output();
X
X	if ( argc == 1 )	puts( ":)" );	/* refuse if no strings */
X	else	for ( i=1 ; i < argc ; ++i ) {
X			data = argv[ i ];	/* data is the i-th string */
X			count = digit = 0;
X
X			pass1();	/* making font */
X			output();	/* output font with compression */
X		}
X}
X
void	pass1()		/* making font following data */
X{
X	short	kor =NO, i;
X	void	make_eng(), make_kor();
X
X	while ( data[ count ] != END )
X		if ( data[ count ] == CMD_CHR )
X			if ( data[ ++count ] == CMD_CHR )	/* double CMD_CHR is one normal character */
X				make_eng();
X			else
X			switch ( instr( mod_chr, data[ count ] ) + 1 ) {
X			  case 0:	/* toggle Korean mode */
X				kor = -kor;	break;
X			  case 1:	/* change choice char's */
X				if ( ( i = data[ ++count ] - '0' ) < 0 || i >= N_CMODE )
X					cmode = 0;
X				else {	cmode = i;		++count; }
X				break;
X			  case 2:	/* change English letter types */
X				if ( ( i = data[ ++count ] - '0' ) < 0 || i >= N_MODE )
X					mode = 0;
X				else {	mode = i;		++count; }
X			}
X		else if ( kor == NO )	make_eng();
X		else			make_kor();
X}
X
void	output()	/* output font with compression */
X{
X	short	i;
X	void	output1();
X
X	for ( i=0 ; i < WIDTH ; i+=2 ) {
X		output1( font[ i ], font[ i+1 ] );	/* compress two lines into one line and output it */
X		putchar( '\n' );
X	}
X}
X
void	output1( font1, font2 )		/* compress two lines and output */
X	short	*font1, *font2;
X{
X	short	i;
X	void	output2();
X
X	for ( i=0 ; i < digit ; ++i )
X		output2( font1[ i ], font2[ i ], font[ _WIDTH ][ i ], font[ _WIDTH+1 ][ i ] );	/* output one digit font in two lines with compression */
X}
X
void	output2( f1, f2, len, cmode )		/* output a digit font with compression */
X	short	f1, f2;
X	short	len;
X	short	cmode;
X{
X	short	choice, i;
X
X	for ( i=stepspace ; i > 0 ; --i )
X		putchar( font_choice[ cmode ][ 0 ] );
X	while ( ( len /= 2 ) > 0 ) {
X		choice = ( f1 / len ) * 2 + ( f2 / len );	/* get the choice determining the character to output */
X		putchar( font_choice[ cmode ][ choice ] );	/* output a bit character */
X		f1 %= len; f2 %= len;
X	}
X}
X
void	make_eng()	/* making font in English mode */
X{
X	short	i, in;
X
X	if ( ( in = instr( eng_chr, data[ count++ ] ) ) != NO ) {
X		for ( i=0 ; i < WIDTH ; ++i )
X			font[ i ][ digit ] = eng_fnt[ mode ][ in ][ i ];	/* read font */
X		font[ _WIDTH ][ digit ] = eng_fnt[ mode ][ in ][ i ];		/* read the width */
X		font[ _WIDTH+1 ][ digit++ ] = cmode;
X	}
X}
X
void	make_kor()	/* making font in Korean mode */
X{
X	short	fir, sec, thi, i;
X	short	att_f =0, att_s =0;
X
X	if ( ( fir = instr( kor_key[ 0 ], data[ count ] ) ) != NO )
X		++count;
X	if ( ( sec = instr( kor_key[ 1 ], data[ count ] ) ) != NO ) {
X		if ( sec >= 9 ) {
X			++att_f;
X			switch ( instr( "hnm", data[ count++ ] ) + 1 ) {
X			  case 1:
X				if ( ( i = instr( "kol", data[ count ] ) ) != NO ) {
X					sec += i+1;	++count;	++att_f;
X				}
X				break;
X			  case 2:
X				if ( ( i = instr( "jpl", data[ count ] ) ) != NO ) {
X					sec += i+1;	++count;	++att_f;
X				}
X				break;
X			  case 3:
X				if ( data[ count ] == 'l' ) {
X					++sec;		++count;	++att_f;
X				}
X			}
X		}
X		else	++count;
X		if ( ( thi = instr( kor_key[ 2 ], data[ count ] ) ) != NO &&
X			 instr( kor_key[ 1 ], data[ count+1 ] ) == NO ) {
X			att_f += 3;	att_s = 1;
X			if ( ( i = instr( "rsfq", data[ count++ ] ) ) != NO &&
X				 instr( kor_key[ 1 ], data[ count+1 ] ) == NO ) {
X				switch ( i ) {
X				  case 0:
X					if ( data[ count ] == 't' ) {
X						++thi;		++count;
X					}
X					break;
X				  case 1:
X					if ( ( i = instr( "wg", data[ count ] ) ) != NO ) {
X						thi += i+1;	++count;
X					}
X					break;
X				  case 2:
X					if ( ( i = instr( "raqtxvg", data[ count ] ) ) != NO ) {
X						thi += i+1;	++count;
X					}
X					break;
X				  case 3:
X					if ( data[ count ] == 't' ) {
X						++thi;		++count;
X					}
X				}
X			}
X		}
X	}
X
X	if ( fir == NO && sec == NO )
X		make_eng();	/* if not Korean letter, deal it as English */
X	else {
X		for ( i=0 ; i < WIDTH ; ++i ) {
X			font[ i ][ digit ] = ( fir != NO ) ? fir_fnt[ att_f ][ fir ][ i ] : 0;
X			if ( sec != NO ) {
X				font[ i ][ digit ] |= sec_fnt[ att_s ][ sec ][ i ];
X				if ( att_s != 0 )	font[ i ][ digit ] |= thi_fnt[ 0 ][ thi ][ i ];
X			}
X		}
X		font[ _WIDTH ][ digit ] = KOR_LEN;
X		font[ _WIDTH+1 ][ digit++ ] = cmode;
X	}
X}
X
instr( str, ch )	/* return the position of ch in str, if no position, NO */
X	char	*str;
X	char	ch;
X{
X	short	i =0;
X
X	while ( ch != str[ i ] && str[ i ] != END )	++i;
X	if ( str[ i ] == END )	i = NO;		/* if no position, return NO */
X	return( i );
X}
X
END_OF_FILE
if test 5312 -ne `wc -c <'banner-5/kban.c'`; then
    echo shar: \"'banner-5/kban.c'\" unpacked with wrong size!
fi
# end of 'banner-5/kban.c'
fi
if test -f 'banner-5/kban.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-5/kban.hlp'\"
else
echo shar: Extracting \"'banner-5/kban.hlp'\" \(1379 characters\)
sed "s/^X//" >'banner-5/kban.hlp' <<'END_OF_FILE'
X
X--#1	How to use
X
X   The character '/' has special power...called CMD_CHR.  By it alone, it can
X  toggle the Korean/English letter mode.  With '.' or '+' after it, it changes
X  output letter mode or writing-type.  Now, there is only one writing-type,
X  Roman, so '+' is useless in Ver1.21-.  If you want to know the power of trick
X  by '.' after '/', try followings :
X
X	kban /.0Hello
X	kban /.1Hello
X	kban /.2Hello
X	 :     :
X	kban /.5Hello
X
X  Now, there are 6 (0~5) letter modes and the initial value is 0 ( you can
X  change this at the line '#define CMODE 0' in kbandat.c ).
X
X   Here are some examples of usage :
X
X	kban /dkssud/____semi
X	kban Hello,,,,/.3/tpadl
X
X--#2	How to compile
X
X   First, you must change the line '#define DATFILE xxxxx' in kban.c to inform
X  where kbandat.c exists.
X   Then, just 'cc kban.c -o kban' is all.
X
X--#3	Info
X
X   This banner can cover Korean and English both.  Moreover, it has a special
X  function(/.# : # is number) and it's fonts are quite pretty.  But now, there
X  are no fonts for numbers and other letters though there will be soon.
X   All unknown characters are treated as 1 vertical space, so ',' and '_' can
X  be used as space in above examples.
X   Help option for this program is not ready yet.  I can support this help file
X  only now.  sorry.
X
X   If you have any question or any suggestion, e-mail to :
X
X	e910017@xserver.kaist.ac.kr
X
END_OF_FILE
if test 1379 -ne `wc -c <'banner-5/kban.hlp'`; then
    echo shar: \"'banner-5/kban.hlp'\" unpacked with wrong size!
fi
# end of 'banner-5/kban.hlp'
fi
if test -f 'banner-5/lban.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-5/lban.c'\"
else
echo shar: Extracting \"'banner-5/lban.c'\" \(6638 characters\)
sed "s/^X//" >'banner-5/lban.c' <<'END_OF_FILE'
X/* Large Korean Banner */
X
X#include <stdio.h>
X
X#define TOTAL 37
X
X#define CW   6   /* character width */
X#define CL   3   /* character length */ 
X
X#define SD   2   /* shift down */ 
X#define SR   3   /* shift right */ 
X#define SB   1   /* shift below */
X
X#define MC   6  /* max characters */
X
X#define DFName "/ufo2/fcode/e880505/Bin/lban.dat"	/* data file name */
X
static char alpha[]={"abcdefghijklmnopqrstuvwxyzQWERTOP?!.,"};
static char c[]={"acdefgqrstvwxzQWERT"};  /* consonant */
static char v1[]={"ijklopuOP"}; 
static char v2[]={"bhmny"};
static char s[]={"?!.,"};
X
struct FONT  {
X	int   address;
X	short type;
X	}  a[TOTAL];  
X
int  b[MC*4];    /*  board  */
int  t[MC*4];    /*  taget  */
X
char board[2*CL+3][(CW*2-1)*MC+3]; 
char *receiver;
X
short  word_counter = 0;
X
main(argc,argv)
int argc;
char *argv[];
X{ 
X	int number ; 
X	
X	if( argc != 2 && argc !=3 ) {Error("?"); Quit();} 
X	if(argc == 3 )  receiver = argv[2];
X	make_font(); 
X	clear_board();
X	number=make_board(argv[1]);
X	load_board(number);
X	print_board(argc-2);
X	fflush(stdout);
X}
clear_board()
X{
X	int i,j;
X
X	for(i=0;i<2*CL+3; i++ ){
X		for( j=0; j< (CW*2-1)*MC; j++)
X			board[i][j] = ' ';
X		board[i][j] = 0;
X	}
X}
X
contractor( index ,num)
int index;
int num;
X{
X	int i,j;
X	int what, mwhat;
X			
X	switch( t[index] ){
X		case 3:
X			return 0;
X			break;
X		case 1: 
X			if( index > 0 ) {
X					if( t[index-1] ==2 ) return 2;
X					else return 1;
X					}
X			else return 1;
X			break;
X		case 2:
X			return 3;
X			break;
X		case 0:
X			if(index==0 ) return 0;
X			if( index <num-1 ) { 
X				what = contractor(index+1, num );
X				if( what ==1 || what ==2 || what == 3 ) return 0;
X				if( what == 0 ) {
X					mwhat = t[index-1] ;
X					if( mwhat== 1 ) {
X						mwhat = contractor(index-1, num );
X						if( mwhat== 1) return 8;
X						if(mwhat == 2) return 9;
X						}
X					if( mwhat == 2) {
X							return 6;
X						}
X					if( mwhat== 0) {
X						mwhat = contractor( index-2);
X						if(mwhat == 1) return 5;
X						if(mwhat == 2) return 7;
X						if(mwhat == 3) return 7;
X						}
X					} /* if */
X				  else{ 
X					mwhat = contractor( index-1, num );
X					if(mwhat == 1 ) return 4;
X					if(mwhat == 2 ) return 6;
X					if(mwhat == 3 ) return 6;
X					}
X				}	/*  if */
X			else { 
X				what = t[index-1];
X				if(what == 0) {
X					mwhat = contractor(index-2, num);
X					if( mwhat == 3 )  return 7;
X					if( mwhat == 1 ) return 5;
X					if(mwhat ==2 ) return 7;
X					}
X				what = contractor( index-1 , num );
X				if( what == 3 ) return 6;
X				if( what == 1 ) return 8;
X				if( what == 2 ) return 9;
X				}
X		break;
X		} /* swtich */
X} /* end of procedure */
X
X
X
load_board( num )
int num;
X{
X	int i;
X	int x=0 ,y=0 ;    /* location of a charcater */
X	int tx, ty ;   /* location of a alphabet */ 
X	short  what;
X	
X	for( i=0; i< num ; i++ ){ 
X		what = contractor(i,num); 
X		switch( what ){
X			case 0:
X				if(i!=0) { x+=CW*2-1 ;  }
X				tx=x; ty = y;
X				word_counter++;
X				if( word_counter > MC ) {Error("Too many characters");Quit();}
X				break;
X			case 1:
X				tx = x+CW ;
X				ty=y;
X				break;
X			case 2: 
X				tx= x+CW;
X				ty= y+SB ;
X				break; 
X			case 3: 
X				tx = x; 
X				ty = y+CL ;
X				break;
X			case 4:
X				tx = x ;
X				ty = y+CL ;
X				break; 
X			case 5:
X				tx= x+CW ;
X				ty = y+CL;
X				break;
X			case 6:
X				tx = x;
X				ty = y+CL+SD ;
X				break;
X			case 7:
X				tx = x+CW;
X				ty = y+CL+SD;
X				break;
X			case 8:
X				tx = x+ SR;
X				ty = y+CL;
X				break;
X			case 9:
X				tx = x +SR;
X				ty= y+CL+SD;
X				break;
X			default:
X				break;
X				}  /* switch */
X		sculpture( tx,ty, b[i] );
X		}   /*  for */
X}   /*  end of function */	
X
sculpture( x, y, index )
int x,y, index;
X{
X	FILE *fptr;
X	char str[20],len;
X	int i,j;
X
X	if( NULL == (fptr=fopen(DFName,"r"))) { Error("!"); Quit();}
X	fseek(fptr, (long)(a[index].address), 0 );
X	for(i=0; i< CL ; i++ ){
X		fgets( str, CW+5, fptr);
X		len = strlen( str );
X		str[ len-1] =' '; len--;
X		for(j=0 ; j <len ; j++ ){
X			board[y+i][x+j] = str[j] ; 
X		}  /*  for */
X	}  /* for */
X	fclose(fptr);
X}
compress(str)
char *str;
X{
X	int i,len ;
X	len = strlen(str);
X	for(i=0; i<len ; i++ )
X		if( str[i] != ' ')  return 1;
X	return 0;
X}
X
X
print_board(mode)
short mode;
X{
X	int i,  limit;
X
X	for(i=0; i < CL*2+3 ; i++ )
X		if( compress(board[i]) ) limit=i;
X
X	board_optimize( limit );
X	board_compress( limit );
X		
X	if(mode == 0 ) {
puts("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
X		for(i=0 ; i <= limit ; i++ ){
X					puts( board[i]);
X					fflush(stdout);
X					}
puts("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n");
X	fflush(stdout);
X				}
X	else if( mode==1 )   for(i=0 ; i <= limit ; i++ )
X							printf("%s:%s\n",receiver,board[i]);
X}
X
board_compress( max )
int max;
X{
X	int i,j;
X	int end;
X	int sw = 0;
X	char tablet[CL*3+2];
X
X	end = strlen(board[0]);
X
X	for(i=0 ; i<end-1 ; i++ ){
X		for(j=0; j<= max ; j++ ) tablet[j]= board[j][i];
X		tablet[j] = 0;
X		if( strClen(tablet) ==0 ){ 
X			sw++; 
X			if (sw==3){
X				exec_compress(i,max,end);
X				sw--;
X				end--;
X				i--;  } /* if */
X				}  /* if */
X		else sw=0;
X		}  /* for i */
X}
X
exec_compress( i, max, end)
int i,max,end;
X{
X	int j,k;
X
X	for(j=0 ; j<=max ; j++ ){
X		for(k=i; k<end-1; k++ )
X			board[j][k]=board[j][k+1];
X		board[j][k] = 0 ;
X		}
X}
strClen(str)
char *str;
X{
X	int len, i;
X	len=strlen(str);
X	for(i=0 ; i<len ; i++)
X		if(str[i]!=' ') return 1;
X	return 0;
X}
board_optimize( max )
int max;
X{
X	int i,j,k;
X	int local_max;
X	int delta ;
X
X	for(i=0; i< word_counter ; i++ ){
X		local_max= local_scan(i,max);
X		if( local_max <= max-2) {
X			delta = (max-local_max)/2 ;
X			for( j=i*(CW*2-1); j< (i+1)*(CW*2-1) ; j++) 
X				for(k=local_max ; k>=0 ; k--){
X					board[k+delta][j] = board[k][j];
X					board[k][j]=' ';
X					}  /*  for k */
X				} /*  if  */
X		} /* for i */
X}
X
local_scan(i,max)
int i;
int max;
X{
X	int j,k;
X	int local=0;
X
X	for( j=i*(CW*2-1); j< (i+1)*(CW*2-1) ; j++) 
X		for(k=max; k>0 ; k--) 
X			if( board[k][j] != ' ') { if(k>local) local=k ; break; }
X	return local;
X}
X		
make_board(str)
char *str;
X{
X	int i,len,defect=0 ;
X
X	len = strlen(str); 
X	
X	for(i=0; i<len ; i++ ) { 
X		b[i+defect] = where( str[i], alpha );
X		if( b[i+defect] == -1 ) defect--;
X		else t[i+defect] = a[b[i+defect]].type;
X		}
X	return i+defect; 
X}
make_font()
X{
X	int i;
X	for(i=0; i<TOTAL ; i++ ) { 
X		a[i].type = exist( alpha[i] );
X		a[i].address = i*(CL*(CW+1)+1) ;
X		}
X}
X	
exist( ch )
X{
X	if( where(ch, c ) >-1 )  return 0;
X	else if( where( ch, v1) > -1 ) return 1;
X	else if( where(ch, v2) >-1 ) return 2;
X	return 3;
X}
where( ch, str )
char ch;
char *str;
X{
X	int i, len;
X
X	len=strlen(str);
X	for(i=0; i<len ; i++ ) 
X		if( ch == str[i] )  return i;
X	return -1;
X}
XError(str)
char *str;
X{
X}
Quit()
X{
X	puts("-------");
X	exit(0);
X}
X
X
END_OF_FILE
if test 6638 -ne `wc -c <'banner-5/lban.c'`; then
    echo shar: \"'banner-5/lban.c'\" unpacked with wrong size!
fi
# end of 'banner-5/lban.c'
fi
if test -f 'banner-5/lban.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-5/lban.dat'\"
else
echo shar: Extracting \"'banner-5/lban.dat'\" \(813 characters\)
sed "s/^X//" >'banner-5/lban.dat' <<'END_OF_FILE'
X .___.
X |   |
X +---+
X
X _____
X  | | 
X  | | 
X
X __|__
X  / \ 
X /   \
X
X  ___ 
X /   \
X \___/
X
X .____
X |    
X |____
X
X .___.
X .___|
X |___.
X
X __|__
X /   \
X \___/
X
X   |  
X --+--
X      
X
X |__  
X |__  
X |    
X
X   |  
X --|  
X   |  
X
X  |   
X  |-- 
X  |   
X
X  |   
X  |   
X  |   
X
X _____
X      
X      
X
X _____
X   |  
X      
X
X  | | 
X  |-| 
X  | | 
X
X  | | 
X -| | 
X  | | 
X
X .   .
X |___|
X |___|
X
X ----+
X     |
X     |
X
X .    
X |    
X +----
X
X   .  
X  / \ 
X /   \
X
X __|  
X __|  
X   |  
X
X _____
X  | | 
X -+-+-
X
X _____
X  / \ 
X /   \
X
X .____
X |____
X |____
X
X  | | 
X -+-+-
X      
X
X ----+
X ____|
X     |
X
X . . .
X |_|_|
X |_|_|
X
X _____
X  / / 
X /\/ \
X
X .____
X | |  
X |_|__
X
X ____.
X   | |
X   | |
X
X  ..  
X // \ 
X// \ \
X
X |_|  
X |_|  
X | |  
X
X _| | 
X _| | 
X  | | 
X
X .---.
X  .--'
X  @   
X
X  ||  
X  |   
X  @   
X
X      
X  @   
X
X      
X      
X @@   
X  /
X
X
X
END_OF_FILE
if test 813 -ne `wc -c <'banner-5/lban.dat'`; then
    echo shar: \"'banner-5/lban.dat'\" unpacked with wrong size!
fi
# end of 'banner-5/lban.dat'
fi
if test -f 'banner-5/leb.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-5/leb.c'\"
else
echo shar: Extracting \"'banner-5/leb.c'\" \(3633 characters\)
sed "s/^X//" >'banner-5/leb.c' <<'END_OF_FILE'
X/* leb : Large English Banner
X *
X * Who the heck wrote original Pascal version?
X *
X * C version by Han, Yun-Su
X * 880505 KAIST undergraduate Dept of Life Science
X */
X
X#include <stdio.h>
X
main(argc, argv)
int argc;
char **argv;
X{
X	char line[256];
X
X	if (argc < 2)	{
X		fprintf(stderr, "&:^)\n");
X		exit(1);
X		}
X	getline(line, argc, argv);
X	lowerline(line);
X	putline(line);
X}
X
getline(s, n, v)
char *s;
int n;
char *v[];
X{
X	int i, j;
X
X	strcpy(s, "");
X	for (i = 1; i < n; i++, s++)	{
X		for (j = 0; v[i][j] != '\0'; j++, s++)
X			*s = v[i][j];
X		*s = ' ';
X		}
X	s--;
X	*s = '\0';
X}
X
lowerline(s)
char *s;
X{
X	char *p;
X
X	for (p = s; *p != '\0'; p++)
X		if (*p >= 'A' && *p <= 'Z')
X			*p = *p - 'A' + 'a';
X}
X
X#define	Height		6	/* Height of 3D Font */
X#define	Blank		"     "
putline(s)
char *s;
X{
X	static char *data[] = {
X		"     __      ",
X		"    /  \\     ",
X		"   /    \\    ",
X		"  /  /\\  \\   ",
X		" /  ____  \\  ",
X		"/__/    \\__\\ ",
X		" ______   ",
X		"|  __  \\  ",
X		"| |__|  | ",
X		"|  __  <  ",
X		"| |__|  | ",
X		"|______/  ",
X		"  _____  ",
X		" / ____| ",
X		"| |      ",
X		"| |      ",
X		"| |____  ",
X		" \\_____| ",
X		" ______   ",
X		"|  ___ \\  ",
X		"| |   | | ",
X		"| |   | | ",
X		"| |___| | ",
X		"|______/  ",
X		" _______  ",
X		"|  _____| ",
X		"| |___    ",
X		"|  ___|   ",
X		"| |_____  ",
X		"|_______| ",
X		" _______  ",
X		"|  _____| ",
X		"| |___    ",
X		"|  ___|   ",
X		"| |       ",
X		"|_|       ",
X		"  ______   ",
X		" / _____|  ",
X		"| |   ___  ",
X		"| |  |_  | ",
X		"| |____| | ",
X		" \\______/  ",
X		" _     _  ",
X		"| |   | | ",
X		"| |___| | ",
X		"|  ___  | ",
X		"| |   | | ",
X		"|_|   |_| ",
X		" _  ",
X		"| | ",
X		"| | ",
X		"| | ",
X		"| | ",
X		"|_| ",
X		"     _  ",
X		"    | | ",
X		"    | | ",
X		" _  | | ",
X		"| |_| | ",
X		" \\___/  ",
X		" _   __ ",
X		"| | / / ",
X		"| |/ /  ",
X		"|   <   ",
X		"| |\\ \\  ",
X		"|_| \\_\\ ",
X		" _       ",
X		"| |      ",
X		"| |      ",
X		"| |      ",
X		"| |____  ",
X		"|______| ",
X		" ___    ___  ",
X		"|   \\  /   | ",
X		"| |\\ \\/ /| | ",
X		"| | \\__/ | | ",
X		"| |      | | ",
X		"|_|      |_| ",
X		" __    _  ",
X		"|  \\  | | ",
X		"|   \\ | | ",
X		"| |\\ \\| | ",
X		"| | \\   | ",
X		"|_|  \\__| ",
X		"  ______   ",
X		" / ____ \\  ",
X		"| |    | | ",
X		"| |    | | ",
X		"| |____| | ",
X		" \\______/  ",
X		" _____   ",
X		"|  __ \\  ",
X		"| |__| | ",
X		"|  ___/  ",
X		"| |      ",
X		"|_|      ",
X		"  ______    ",
X		" / ____ \\   ",
X		"| |    | |  ",
X		"| |    | |  ",
X		"| |___|  |  ",
X		" \\________| ",
X		" _____   ",
X		"|  __ \\  ",
X		"| |__| | ",
X		"|  _  /  ",
X		"| | \\ \\  ",
X		"|_|  \\_\\ ",
X		"  _____   ",
X		" / ____|  ",
X		"| |____   ",
X		" \\____ \\  ",
X		"  ____| | ",
X		" |_____/  ",
X		" _________  ",
X		"|___   ___| ",
X		"    | |     ",
X		"    | |     ",
X		"    | |     ",
X		"    |_|     ",
X		" _     _  ",
X		"| |   | | ",
X		"| |   | | ",
X		"| |   | | ",
X		"| |___| | ",
X		" \\_____/  ",
X		"__        __ ",
X		"\\ \\      / / ",
X		" \\ \\    / /  ",
X		"  \\ \\  / /   ",
X		"   \\ \\/ /    ",
X		"    \\__/     ",
X		"__            __ ",
X		"\\ \\          / / ",
X		" \\ \\        / /  ",
X		"  \\ \\  /\\  / /   ",
X		"   \\ \\/  \\/ /    ",
X		"    \\__/\\__/     ",
X		"__    __ ",
X		"\\ \\  / / ",
X		" \\ \\/ /  ",
X		"  >  <   ",
X		" / /\\ \\  ",
X		"/_/  \\_\\ ",
X		"__     __ ",
X		"\\ \\   / / ",
X		" \\ \\_/ /  ",
X		"  \\   /   ",
X		"   | |    ",
X		"   |_|    ",
X		" _______  ",
X		"|____  /  ",
X		"    / /   ",
X		"   / /    ",
X		"  / /___  ",
X		" /______| ",
X		};
X	int i;
X	char *p;
X
X	for (i = 0; i < Height; i++)	{
X		for (p = s; *p != '\0'; p++)
X			if (*p < 'a' || *p > 'z')
X				printf(Blank);
X			else
X				printf("%s", data[(*p - 'a') * Height + i]);
X		printf("\n");
X		}
X}
END_OF_FILE
if test 3633 -ne `wc -c <'banner-5/leb.c'`; then
    echo shar: \"'banner-5/leb.c'\" unpacked with wrong size!
fi
# end of 'banner-5/leb.c'
fi
if test -f 'banner-5/sban.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-5/sban.dat'\"
else
echo shar: Extracting \"'banner-5/sban.dat'\" \(412 characters\)
sed "s/^X//" >'banner-5/sban.dat' <<'END_OF_FILE'
X_.
L|
X
TT
X  
X
X_L
X/\
X
X  
X()
X
r-
L_
X
X-)
X(_
X
X_L
X()
X
X_L
X  
X
X|_
X|-
X
X |
X-|
X
X|_
X| 
X
X| 
X| 
X
X  
X__
X
X-r
X  
X
X|J
X||
X
J|
X||
X
L|
L|
X
X_.
X |
X
X. 
X|_
X
X .
X/\
X
X_|
X-|
X
X__
JL
X
X__
X/\
X
X==
L_
X
JL
X  
X
X__
X-/
X
UU
UU
X
X__
X^^
X
X__
LL
X
X__
X//
X
X..
X^^
X
L|
r|
X
J|
T|
X
X?)
o 
X
X|7
o 
X
X  
o 
X
X  
X, 
X
o 
o 
X
AA
X  
X
oo
X\/
X
oo
X/\
X
X**
X\/
X
X**
X/\
X
X..
X\/
X
X..
X/\
X
X'`
X\/
X
X`'
X/\
X
X^^
X U
X
X^^
U 
X
X'|
X |
X
X')
X<_
X
X')
X_)
X
X||
X-+
X
X.-
X_)
X
X| 
X()
X
X->
X/ 
X
X()
X()
X
X()
X |
X
X/\
X\/
END_OF_FILE
if test 412 -ne `wc -c <'banner-5/sban.dat'`; then
    echo shar: \"'banner-5/sban.dat'\" unpacked with wrong size!
fi
# end of 'banner-5/sban.dat'
fi
if test -f 'banner-5/seb.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-5/seb.c'\"
else
echo shar: Extracting \"'banner-5/seb.c'\" \(3119 characters\)
sed "s/^X//" >'banner-5/seb.c' <<'END_OF_FILE'
X/* seb : Small English Banner
X *
X * Who the heck wrote original Pascal version?
X *
X * C version by Han, Yun-Su
X * 880505 KAIST undergraduate Dept of Life Science
X */
X
X#include <stdio.h>
X
main(argc, argv)
int argc;
char **argv;
X{
X	char line[256];
X
X	if (argc < 2)	{
X		fprintf(stderr, "&:^)\n");
X		exit(1);
X		}
X	getline(line, argc, argv);
X	putline(line);
X}
X
getline(s, n, v)
char *s;
int n;
char *v[];
X{
X	int i, j;
X
X	strcpy(s, "");
X	for (i = 1; i < n; i++, s++)	{
X		for (j = 0; v[i][j] != '\0'; j++, s++)
X			*s = v[i][j];
X		*s = ' ';
X		}
X	s--;
X	*s = '\0';
X}
X
X#define	Height		4	/* Height of Font */
X#define	Blank		"     "
putline(s)
char *s;
X{
X	static char *upper[] = {
X		"     ",
X		"  /\\ ",
X		" /--\\",
X		"     ",
X		"  _ ",
X		" |_)",
X		" |_)",
X		"    ",
X		"  __",
X		" /  ",
X		" \\__",
X		"    ",
X		"  _ ",
X		" | \\",
X		" |_/",
X		"    ",
X		"  __",
X		" |_ ",
X		" |__",
X		"    ",
X		"  __",
X		" |_ ",
X		" |  ",
X		"    ",
X		"  _ ",
X		" / _",
X		" \\_|",
X		"    ",
X		"    ",
X		" |_|",
X		" | |",
X		"    ",
X		"  ",
X		" |",
X		" |",
X		"  ",
X		"    ",
X		"   |",
X		" |_|",
X		"    ",
X		"    ",
X		" |_/",
X		" | \\",
X		"    ",
X		"    ",
X		" |  ",
X		" |__",
X		"    ",
X		"       ",
X		" |\\  /|",
X		" | \\/ |",
X		"       ",
X		"     ",
X		" |\\ |",
X		" | \\|",
X		"     ",
X		"  _ ",
X		" / \\",
X		" \\_/",
X		"    ",
X		"  _ ",
X		" |_)",
X		" |  ",
X		"    ",
X		"  _ ",
X		" / \\",
X		" \\_\\",
X		"    ",
X		"  _ ",
X		" |_)",
X		" | \\",
X		"    ",
X		"  _ ",
X		" (_ ",
X		"  _)",
X		"    ",
X		" ___",
X		"  | ",
X		"  | ",
X		"    ",
X		"     ",
X		" |  |",
X		" |__|",
X		"     ",
X		"     ",
X		" \\  /",
X		"  \\/ ",
X		"     ",
X		"       ",
X		" \\    /",
X		"  \\/\\/ ",
X		"       ",
X		"    ",
X		" \\_/",
X		" / \\",
X		"    ",
X		"    ",
X		" \\_/",
X		"  | ",
X		"    ",
X		" __",
X		"  /",
X		" /_",
X		"   ",
X		""
X		};
X	static char *lower[] = {
X		"    ",
X		"  _ ",
X		" (_|",
X		"    ",
X		"    ",
X		" |_ ",
X		" |_)",
X		"    ",
X		"   ",
X		"  _",
X		" (_",
X		"   ",
X		"    ",
X		"  _|",
X		" (_|",
X		"    ",
X		"   ",
X		"  _",
X		" (=",
X		"   ",
X		"   _",
X		" _|_",
X		"  | ",
X		"    ",
X		"    ",
X		"  _ ",
X		" (_|",
X		"  _/",
X		"    ",
X		" |_ ",
X		" | |",
X		"    ",
X		"  ",
X		" .",
X		" |",
X		"  ",
X		"   ",
X		"  .",
X		"  |",
X		" _/",
X		"   ",
X		" |_",
X		" |\\",
X		"   ",
X		"  ",
X		" |",
X		" |",
X		"  ",
X		"      ",
X		"  _ _ ",
X		" | | |",
X		"      ",
X		"    ",
X		"  _ ",
X		" | |",
X		"    ",
X		"    ",
X		"  _ ",
X		" (_)",
X		"    ",
X		"    ",
X		"  _ ",
X		" |_)",
X		" |  ",
X		"    ",
X		"  _ ",
X		" (_|",
X		"   |",
X		"   ",
X		"  _",
X		" | ",
X		"   ",
X		"  ",
X		"  ",
X		" S",
X		"  ",
X		"    ",
X		" _|_",
X		"  |_",
X		"    ",
X		"    ",
X		"    ",
X		" |_|",
X		"    ",
X		"    ",
X		"    ",
X		" \\_/",
X		"    ",
X		"      ",
X		"      ",
X		" \\_|_/",
X		"      ",
X		"   ",
X		"   ",
X		" ><",
X		"   ",
X		"    ",
X		"    ",
X		" \\_/",
X		" _/ ",
X		"   ",
X		" _ ",
X		" /_",
X		"   ",
X		"   ",
X		""
X		};
X	int i;
X	char *p;
X
X	for (i = 0; i < Height; i++)	{
X		for (p = s; *p != '\0'; p++)
X			if (*p >= 'a' && *p <= 'z')
X				printf("%s", lower[(*p - 'a') * Height + i]);
X			else if (*p >= 'A' && *p <= 'Z')
X				printf("%s", upper[(*p - 'A') * Height + i]);
X			else
X				printf(Blank);
X		printf("\n");
X		}
X}
END_OF_FILE
if test 3119 -ne `wc -c <'banner-5/seb.c'`; then
    echo shar: \"'banner-5/seb.c'\" unpacked with wrong size!
fi
# end of 'banner-5/seb.c'
fi
if test ! -d 'banner-6' ; then
    echo shar: Creating directory \"'banner-6'\"
    mkdir 'banner-6'
fi
if test -f 'banner-6/banner.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-6/banner.6'\"
else
echo shar: Extracting \"'banner-6/banner.6'\" \(2979 characters\)
sed "s/^X//" >'banner-6/banner.6' <<'END_OF_FILE'
X.\" Copyright (c) 1980 The Regents of the University of California.
X.\" All rights reserved.
X.\"
X.\" Redistribution and use in source and binary forms, with or without
X.\" modification, are permitted provided that the following conditions
X.\" are met:
X.\" 1. Redistributions of source code must retain the above copyright
X.\"    notice, this list of conditions and the following disclaimer.
X.\" 2. Redistributions in binary form must reproduce the above copyright
X.\"    notice, this list of conditions and the following disclaimer in the
X.\"    documentation and/or other materials provided with the distribution.
X.\" 3. All advertising materials mentioning features or use of this software
X.\"    must display the following acknowledgement:
X.\"	This product includes software developed by the University of
X.\"	California, Berkeley and its contributors.
X.\" 4. Neither the name of the University nor the names of its contributors
X.\"    may be used to endorse or promote products derived from this software
X.\"    without specific prior written permission.
X.\"
X.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X.\" SUCH DAMAGE.
X.\"
X.\"	@(#)banner.6	6.4 (Berkeley) 6/23/90
X.\"
X.TH BANNER 6 "June 23, 1990"
X.UC
X.SH NAME
banner \- print large banner on printer
X.SH SYNOPSIS
X.B /usr/games/banner
X[
X.BI \-w n
X]
message ...
X.SH DESCRIPTION
X.I Banner
prints a large, high quality banner on the standard output.
If the message is omitted, it prompts for and
reads one line of its standard input.  If
X.B \-w
is given, the output is scrunched down from a width of 132 to
X.I n ,
suitable for a narrow terminal.  If
X.I n
is omitted, it defaults to 80.
X.PP
The output should be printed on a hard-copy device, up to 132 columns wide,
with no breaks between the pages. The volume is great enough that you 
may want
a printer or a fast hardcopy terminal, but if you are patient, a
decwriter or other 300 baud terminal will do.
X.SH BUGS
Several ASCII characters are not defined, notably <, >, [, ], \\,
X^, _, {, }, |, and ~.  Also, the characters ", ', and & are funny
looking (but in a useful way.)
X.PP
The
X.B \-w
option is implemented by skipping some rows and columns.
The smaller it gets, the grainier the output.
Sometimes it runs letters together.
X.SH AUTHOR
Mark Horton
END_OF_FILE
if test 2979 -ne `wc -c <'banner-6/banner.6'`; then
    echo shar: \"'banner-6/banner.6'\" unpacked with wrong size!
fi
# end of 'banner-6/banner.6'
fi
if test ! -d 'banner-7' ; then
    echo shar: Creating directory \"'banner-7'\"
    mkdir 'banner-7'
fi
if test -f 'banner-7/banner.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-7/banner.c'\"
else
echo shar: Extracting \"'banner-7/banner.c'\" \(6380 characters\)
sed "s/^X//" >'banner-7/banner.c' <<'END_OF_FILE'
X#include <stdio.h>
X
static char *chars[][4] = {
X/***************/
X"  ",
X"  ",
X"  ",
X"  ",
X/***************/
X".",
X"|",
X"|",
X".",
X/***************/
X"_ _",
X"| |",
X"   ",
X"   ",
X/***************/
X" . . ",
X"_|_|_",
X"_|_|_",
X" | | ",
X/***************/
X" ___",
X"| | ",
X" \\| ",
X" _|)",
X/***************/
X" _ ",
X" -/",
X" / ",
X"/ =",
X/***************/
X"  _  ",
X" | | ",
X" /\\  ",
X"(__|\\",
X/***************/
X" _",
X" /",
X"  ",
X"  ",
X/***************/
X"  _",
X" / ",
X"|  ",
X" \\_",
X/***************/
X"_  ",
X" \\ ",
X"  |",
X"_/ ",
X/***************/
X"      ",
X"  \\|/ ",
X" --*--",
X"  /|\\ ",
X/***************/
X"     ",
X"  |  ",
X"--+--",
X"  |  ",
X/***************/
X" ",
X" ",
X"_",
X"/",
X/***************/
X"    ",
X"____",
X"    ",
X"    ",
X/***************/
X"   ",
X"   ",
X"___",
X"|_|",
X/***************/
X"    _",
X"   / ",
X"  /  ",
X"_/   ",
X/***************/
X"  ___/ ",
X" /  /\\ ",
X"| /   |",
X"/\\___/ ",
X/***************/
X" . ",
X"/| ",
X" | ",
X"_|_",
X/***************/
X"  __  ",
X" /  ) ",
X"   /  ",
X"  /___",
X/***************/
X" ___ ",
X" __/ ",
X"   \\ ",
X"\\___)",
X/***************/
X"  _. ",
X" / | ",
X"/__|_",
X"  _|_",
X/***************/
X".___",
X"|__ ",
X"   \\",
X"\\__/",
X/***************/
X"  __ ",
X" /__ ",
X"/   \\",
X"\\___/",
X/***************/
X"___.",
X"  / ",
X" /  ",
X"/   ",
X/***************/
X" __ ",
X"(__)",
X"/  \\",
X"\\__/",
X/***************/
X" ___ ",
X"(___|",
X"   / ",
X"__/  ",
X/***************/
X"  ",
X"||",
X"  ",
X"||",
X/***************/
X"  ",
X"||",
X"  ",
X"|/",
X/***************/
X"  .",
X" / ",
X" \\ ",
X"  \\",
X/***************/
X"    ",
X"____",
X"____",
X"    ",
X/***************/
X".  ",
X" \\ ",
X" / ",
X"/  ",
X/***************/
X" __ ",
X"/  )",
X"  | ",
X"  . ",
X/***************/
X"  ___  ",
X" ___ \\ ",
X"| |_\\ |",
X" \\___/ ",
X/***************/
X  "   _   ",
X  "  / \\  ",
X  " /___\\ ",
X  "/     \\",
X/***************/
X  "___ ",
X  "|__)",
X  "|  \\",
X  "|__/",
X/***************/
X  "  __ ",
X  " /  \\",
X  "|    ",
X  " \\__/",
X/***************/
X  " __  ",
X  "|  \\ ",
X  "|   |",
X  "|__/ ",
X/***************/
X  " ___",
X  "|__ ",
X  "|   ",
X  "|___",
X/***************/
X  " ___",
X  "|__ ",
X  "|   ",
X  "|   ",
X/***************/
X  "  __ ",
X  " /  \\",
X  "|  __",
X  " \\__|",
X/***************/
X  "_   _",
X  "|___|",
X  "|   |",
X  "|   |",
X/***************/
X  "___",
X  " | ",
X  " | ",
X  "_|_",
X/***************/
X  " ___",
X  "   |",
X  "   |",
X  "\\_/ ",
X/***************/
X  "_  _",
X  "| / ",
X  "|/\\ ",
X  "|  \\",
X/***************/
X  "_   ",
X  "|   ",
X  "|   ",
X  "|___",
X/***************/
X  "_    _",
X  "|\\  /|",
X  "| \\/ |",
X  "|    |",
X/***************/
X  "__   _",
X  "| \\  |",
X  "|  \\ |",
X  "|   \\|",
X/***************/
X  "  ___  ",
X  " /   \\ ",
X  "|     |",
X  " \\___/ ",
X/***************/
X  "____ ",
X  "|   \\",
X  "|___/",
X  "|    ",
X/***************/
X  "  ___  ",
X  " /   \\ ",
X  "|   \\ |",
X  " \\___\\ ",
X/***************/
X  "____ ",
X  "|   \\",
X  "|___/",
X  "|  \\ ",
X/***************/
X  " __  ",
X  "|  \\ ",
X  " \\__ ",
X  "\\___|",
X/***************/
X  "_____",
X  "  |  ",
X  "  |  ",
X  "  |  ",
X/***************/
X  "_    _",
X  "|    |",
X  "|    |",
X  " \\__/ ",
X/***************/
X  "_      _",
X  " \\    / ",
X  "  \\  /  ",
X  "   \\/   ",
X/***************/
X  "_          _",
X  " \\        / ",
X  "  \\  /\\  /  ",
X  "   \\/  \\/   ",
X/***************/
X  "_   _",
X  " \\ / ",
X  " / \\ ",
X  "/   \\",
X/***************/
X  "_   _",
X  " \\ / ",
X  "  /  ",
X  " /   ",
X/***************/
X  "____ ",
X  "   / ",
X  "  /  ",
X  " /___",
X/***************/
X" __",
X"|  ",
X"|  ",
X"|__",
X/***************/
X".   ",
X" \\  ",
X"  \\ ",
X"   \\",
X/***************/
X"__ ",
X"  |",
X"  |",
X"__|",
X/***************/
X" . ",
X"/ \\",
X"   ",
X"   ",
X/***************/
X"    ",
X"    ",
X"    ",
X"____",
X/***************/
X"_ ",
X"\\ ",
X"  ",
X"  ",
X/***************/
X  "   _   ",
X  "  / \\  ",
X  " /___\\ ",
X  "/     \\",
X/***************/
X  "___ ",
X  "|__)",
X  "|  \\",
X  "|__/",
X/***************/
X  "  __ ",
X  " /  \\",
X  "|    ",
X  " \\__/",
X/***************/
X  " __  ",
X  "|  \\ ",
X  "|   |",
X  "|__/ ",
X/***************/
X  " ___",
X  "|__ ",
X  "|   ",
X  "|___",
X/***************/
X  " ___",
X  "|__ ",
X  "|   ",
X  "|   ",
X/***************/
X  "  __ ",
X  " /  \\",
X  "|  __",
X  " \\__|",
X/***************/
X  "_   _",
X  "|___|",
X  "|   |",
X  "|   |",
X/***************/
X  "___",
X  " | ",
X  " | ",
X  "_|_",
X/***************/
X  " ___",
X  "   |",
X  "   |",
X  "\\_/ ",
X/***************/
X  "_  _",
X  "| / ",
X  "|/\\ ",
X  "|  \\",
X/***************/
X  "_   ",
X  "|   ",
X  "|   ",
X  "|___",
X/***************/
X  "_    _",
X  "|\\  /|",
X  "| \\/ |",
X  "|    |",
X/***************/
X  "__   _",
X  "| \\  |",
X  "|  \\ |",
X  "|   \\|",
X/***************/
X  "  ___  ",
X  " /   \\ ",
X  "|     |",
X  " \\___/ ",
X/***************/
X  "____ ",
X  "|   \\",
X  "|___/",
X  "|    ",
X/***************/
X  "  ___  ",
X  " /   \\ ",
X  "|   \\ |",
X  " \\___\\ ",
X/***************/
X  "____ ",
X  "|   \\",
X  "|___/",
X  "|  \\ ",
X/***************/
X  " __  ",
X  "|  \\ ",
X  " \\__ ",
X  "\\___|",
X/***************/
X  "_____",
X  "  |  ",
X  "  |  ",
X  "  |  ",
X/***************/
X  "_    _",
X  "|    |",
X  "|    |",
X  " \\__/ ",
X/***************/
X  "_      _",
X  " \\    / ",
X  "  \\  /  ",
X  "   \\/   ",
X/***************/
X  "_          _",
X  " \\        / ",
X  "  \\  /\\  /  ",
X  "   \\/  \\/   ",
X/***************/
X  "_   _",
X  " \\ / ",
X  " / \\ ",
X  "/   \\",
X/***************/
X  "_   _",
X  " \\ / ",
X  "  /  ",
X  " /   ",
X/***************/
X  "____ ",
X  "   / ",
X  "  /  ",
X  " /___",
X/***************/
X"  __",
X"_(  ",
X" (  ",
X"  \\_",
X/***************/
X".",
X"|",
X"|",
X"|",
X/***************/
X"__  ",
X"  )_",
X"  ) ",
X"_/  ",
X/***************/
X" _  .",
X"/ \\/ ",
X"     ",
X"     ",
X};
X
X#define LINLEN 79
static int filled;
static char buf[4][LINLEN+1];
X
main(argc, argv)
int argc;
char *argv[];
X{
X  int i,j,max;
X
X  for (i=1; i<argc; i++) {
X    for (j=0, max=strlen(argv[i]); j<max; j++) {
X      print1char(argv[i][j]);
X    }
X    flushit();
X  }
X}
X
print1char(ch) 
char ch;
X{
X  int c=ch-' ';
X  int charlen;
X
X
X  charlen=strlen(chars[c][0]);
X
X  if (charlen+filled+(filled?1:0) > LINLEN) flushit();
X
X  strcat(buf[0]," ");
X  strcat(buf[0],chars[c][0]);
X  strcat(buf[1]," ");
X  strcat(buf[1],chars[c][1]);
X  strcat(buf[2]," ");
X  strcat(buf[2],chars[c][2]);
X  strcat(buf[3]," ");
X  strcat(buf[3],chars[c][3]);
X  filled+=charlen+1;
X}
X
flushit()
X{
X  puts(buf[0]);
X  puts(buf[1]);
X  puts(buf[2]);
X  puts(buf[3]);
X  putchar('\n');
X  buf[0][0]=buf[1][0]=buf[2][0]=buf[3][0]='\0';
X  filled=0;
X}
END_OF_FILE
if test 6380 -ne `wc -c <'banner-7/banner.c'`; then
    echo shar: \"'banner-7/banner.c'\" unpacked with wrong size!
fi
# end of 'banner-7/banner.c'
fi
if test ! -d 'banner-8' ; then
    echo shar: Creating directory \"'banner-8'\"
    mkdir 'banner-8'
fi
if test ! -d 'banner-9' ; then
    echo shar: Creating directory \"'banner-9'\"
    mkdir 'banner-9'
fi
if test -f 'banner-9/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-9/Makefile'\"
else
echo shar: Extracting \"'banner-9/Makefile'\" \(96 characters\)
sed "s/^X//" >'banner-9/Makefile' <<'END_OF_FILE'
block: block.o data.o
X	cc block.o data.o -o block
X
prtout: *.c TODO
X	pr TODO *.c | PRMAN -setup
END_OF_FILE
if test 96 -ne `wc -c <'banner-9/Makefile'`; then
    echo shar: \"'banner-9/Makefile'\" unpacked with wrong size!
fi
# end of 'banner-9/Makefile'
fi
if test -f 'banner-9/TODO' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-9/TODO'\"
else
echo shar: Extracting \"'banner-9/TODO'\" \(259 characters\)
sed "s/^X//" >'banner-9/TODO' <<'END_OF_FILE'
X8702.171220
X
X*	Set up with display buffer instead of stream to allow for adding
X	special features.
X	(added: 8702.201336)
X
X8702.201337
X
X*	Set up to use flag to set print width, possibly add feature to
X	use an environment variable.
X
X*	Modify to use font files.
END_OF_FILE
if test 259 -ne `wc -c <'banner-9/TODO'`; then
    echo shar: \"'banner-9/TODO'\" unpacked with wrong size!
fi
# end of 'banner-9/TODO'
fi
if test -f 'banner-9/block.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-9/block.c'\"
else
echo shar: Extracting \"'banner-9/block.c'\" \(1401 characters\)
sed "s/^X//" >'banner-9/block.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <string.h>
X
X#define LINES		  10
X#define BUFFERSIZE	1024
X
extern char	*data[][LINES];
X
char		buffer[LINES][BUFFERSIZE+1];
X
int min(a,b)
int	a,
X	b;
X{
X    if (a>b)
X	return(b);
X    return(a);
X}
X
main(argc,argv)
int	argc;
char	**argv;
X{
X    short	i,
X		j,
X		k,
X		l,
X		m,
X		idx,
X		idx2,
X		al,
X		sw,
X		tmp,
X		tmp2;
X    char	*p,
X		*ptr;
X
X    while (--argc) {
X	argv++;
X/*
X	for (i=0; i<LINES; i++) {
X	    p = *argv;
X	    while (*p != '\0')
X		printf("%s ",data[*p++][i]);
X	    printf("\n");
X	}
X*/
X	p = *argv;
X	idx = 0;
X	idx2 = 0;
X	for (i=0; i<LINES; i++)
X	    for (j=0; j<BUFFERSIZE; j++)
X		buffer[i][j] = ' ';
X	while (*p != '\0') {
X	    al = strlen(data[*p][0]);
X	    sw = al;
X	    l = 0; m = 0;
X	    for (i=0; i<LINES; i++) {
X		for (j=1; j<=idx2 && buffer[i][idx-j]==' '; j++);
X		for (k=0; *p!=' ' && k<al && data[*p][i][k]==' '; k++);
X		sw = min(sw,j+k);
X		if (i) {
X		    sw = min(sw,j+m);
X		    sw = min(sw,l+k);
X		}
X		l = j; m = k;
X	    }
X	    if (sw)
X		--sw;
X	    tmp = idx + al - sw;
X	    tmp2 = idx-sw+1;
X	    for (i=0; i<LINES; i++)
X		for (j=0; j<min(al,BUFFERSIZE-tmp); j++)
X		    if (data[*p][i][j]!=' ')
X			buffer[i][tmp2+j]=data[*p][i][j];
X	    idx2 = ( *p==' ' ? 0 : tmp);
X	    idx = tmp + 1;
X	    p++;
X	    if (idx>=BUFFERSIZE) {
X		idx = BUFFERSIZE;
X		*p = '\0';
X	    }
X	}
X	for (i=0; i<LINES; i++) {
X	    buffer[i][idx] = '\0';
X	    printf("%s\n",buffer[i]);
X	}
X    }
X}
END_OF_FILE
if test 1401 -ne `wc -c <'banner-9/block.c'`; then
    echo shar: \"'banner-9/block.c'\" unpacked with wrong size!
fi
# end of 'banner-9/block.c'
fi
if test ! -d 'cursive-1' ; then
    echo shar: Creating directory \"'cursive-1'\"
    mkdir 'cursive-1'
fi
if test -f 'cursive-1/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cursive-1/Makefile'\"
else
echo shar: Extracting \"'cursive-1/Makefile'\" \(466 characters\)
sed "s/^X//" >'cursive-1/Makefile' <<'END_OF_FILE'
CFLAGS = -g
X
cursive: cursive.o x.o xs.o
X	cc -g -o cursive cursive.o x.o xs.o
X
x.o: x.c
X
xs.o: xs.c
X
x.c: font.c
X	xstr font.c
X
xs.c: font.c
X	xstr font.c
X
X# This is for use if you haven't got the xstr command.  The program works
X# the same, but is slightly bigger.
X
lcursive: cursive.o font.o
X	cc -g -o lcursive cursive.o font.o
X
cursive.shar: cursive.c font.c cursive.h cursive.6 Makefile shar
X	shar cursive.c font.c cursive.h cursive.6 Makefile shar > cursive.shar
END_OF_FILE
if test 466 -ne `wc -c <'cursive-1/Makefile'`; then
    echo shar: \"'cursive-1/Makefile'\" unpacked with wrong size!
fi
# end of 'cursive-1/Makefile'
fi
if test -f 'cursive-1/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cursive-1/README'\"
else
echo shar: Extracting \"'cursive-1/README'\" \(424 characters\)
sed "s/^X//" >'cursive-1/README' <<'END_OF_FILE'
This is a program for generating horizontal cursive banners.  It's main
use is for generating cute signatures for email.  It is copyrighted by
Jan Wolter, but may be distributed freely.  Have what fun you can...
X
X				  ___                _     __  _
X				 (   >              ' )   /   // _/_
X				  __/___.  ____      / / / __|/  /  _  __
X				 / / (_/|_/ / <__   (_(_/ (_) \_<__</_/ (__
X				<_/
X					janc@crim.eecs.umich.edu
X
END_OF_FILE
if test 424 -ne `wc -c <'cursive-1/README'`; then
    echo shar: \"'cursive-1/README'\" unpacked with wrong size!
fi
# end of 'cursive-1/README'
fi
if test -f 'cursive-1/cursive.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cursive-1/cursive.6'\"
else
echo shar: Extracting \"'cursive-1/cursive.6'\" \(1300 characters\)
sed "s/^X//" >'cursive-1/cursive.6' <<'END_OF_FILE'
X.TH CURSIVE 6 "24 July 1985"
X.UC
X.SH NAME
cursive \- print text in cursive script
X.SH SYNOPSIS
X.B /usr/games/cursive
X[
X.BI \-i n
X]
X[
X.BI \-t n
X]
X[message]
X.SH DESCRIPTION
X.I Cursive
prints a line of text in a rather crude cursive script.
It is intended for use mainly for the generation of decorative signatures
for electronic mail.
If message text is given on the command line, that text is used.
Otherwise the text will be read from standard input up to an end of file.
The
X.B \-i
option sets the minimum spacing between adjacent characters.
The default is
X.B \-i1 .
The
X.B \-t
option sets the length of the trailing lines on the end of each word.
The default is
X.B \-t1 .
X.PP
The '_' character is treated in a special way.  It may be inserted in
the text anywhere you wish to lengthen a connecting line between two
letters.
X.SH BUGS
Many ASCII characters are not defined, notably the numbers and symbols.
Punctuation is mostly available.
Some characters are rather ugly.
The author has lousy handwriting.
X.SH AUTHOR
Jan Wolter.  UUCP mail to janc@crim.eecs.umich.edu
X.SH COPYRIGHT
This program and the cursive font it generates are copyrighted by Jan Wolter.
Both may be freely used and distributed in any way whatsoever, so long as
the author's name is left in the source code and documentation.
END_OF_FILE
if test 1300 -ne `wc -c <'cursive-1/cursive.6'`; then
    echo shar: \"'cursive-1/cursive.6'\" unpacked with wrong size!
fi
# end of 'cursive-1/cursive.6'
fi
if test -f 'cursive-1/cursive.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cursive-1/cursive.h'\"
else
echo shar: Extracting \"'cursive-1/cursive.h'\" \(544 characters\)
sed "s/^X//" >'cursive-1/cursive.h' <<'END_OF_FILE'
struct letter {
X	char *line[6];			/* What's on each of the six lines */
X	char spcs[6];			/* Number of leading spaces for each */
X	short tailin,tailout;		/* Where the lines in and out go */
X	};
X
X/* Special Codes for Character Table */
X
X#define XX  -1		/* Ignore character */
X#define SP  -2          /* Space */
X#define ST  -3          /* Extend trailer */
X#define SA  -4		/* Alternate font number */	/* Not used */
X#define SN  -5		/* Numbers */			/* Not used */
X
X#define CHARWIDTH 10
X
extern struct letter list[];
extern short code1[], code2[];
END_OF_FILE
if test 544 -ne `wc -c <'cursive-1/cursive.h'`; then
    echo shar: \"'cursive-1/cursive.h'\" unpacked with wrong size!
fi
# end of 'cursive-1/cursive.h'
fi
if test ! -d 'cursive-2' ; then
    echo shar: Creating directory \"'cursive-2'\"
    mkdir 'cursive-2'
fi
if test -f 'cursive-2/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cursive-2/Makefile'\"
else
echo shar: Extracting \"'cursive-2/Makefile'\" \(466 characters\)
sed "s/^X//" >'cursive-2/Makefile' <<'END_OF_FILE'
CFLAGS = -O
X
cursive: cursive.o x.o xs.o
X	cc -g -o cursive cursive.o x.o xs.o
X
x.o: x.c
X
xs.o: xs.c
X
x.c: font.c
X	xstr font.c
X
xs.c: font.c
X	xstr font.c
X
X# This is for use if you haven't got the xstr command.  The program works
X# the same, but is slightly bigger.
X
lcursive: cursive.o font.o
X	cc -g -o lcursive cursive.o font.o
X
cursive.shar: cursive.c font.c cursive.h cursive.6 Makefile shar
X	shar cursive.c font.c cursive.h cursive.6 Makefile shar > cursive.shar
END_OF_FILE
if test 466 -ne `wc -c <'cursive-2/Makefile'`; then
    echo shar: \"'cursive-2/Makefile'\" unpacked with wrong size!
fi
# end of 'cursive-2/Makefile'
fi
if test -f 'cursive-2/cursive.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cursive-2/cursive.6'\"
else
echo shar: Extracting \"'cursive-2/cursive.6'\" \(1300 characters\)
sed "s/^X//" >'cursive-2/cursive.6' <<'END_OF_FILE'
X.TH CURSIVE 6 "24 July 1985"
X.UC
X.SH NAME
cursive \- print text in cursive script
X.SH SYNOPSIS
X.B /usr/games/cursive
X[
X.BI \-i n
X]
X[
X.BI \-t n
X]
X[message]
X.SH DESCRIPTION
X.I Cursive
prints a line of text in a rather crude cursive script.
It is intended for use mainly for the generation of decorative signatures
for electronic mail.
If message text is given on the command line, that text is used.
Otherwise the text will be read from standard input up to an end of file.
The
X.B \-i
option sets the minimum spacing between adjacent characters.
The default is
X.B \-i1 .
The
X.B \-t
option sets the length of the trailing lines on the end of each word.
The default is
X.B \-t1 .
X.PP
The '_' character is treated in a special way.  It may be inserted in
the text anywhere you wish to lengthen a connecting line between two
letters.
X.SH BUGS
Many ASCII characters are not defined, notably the numbers and symbols.
Punctuation is mostly available.
Some characters are rather ugly.
The author has lousy handwriting.
X.SH AUTHOR
Jan Wolter.  UUCP mail to janc@crim.eecs.umich.edu
X.SH COPYRIGHT
This program and the cursive font it generates are copyrighted by Jan Wolter.
Both may be freely used and distributed in any way whatsoever, so long as
the author's name is left in the source code and documentation.
END_OF_FILE
if test 1300 -ne `wc -c <'cursive-2/cursive.6'`; then
    echo shar: \"'cursive-2/cursive.6'\" unpacked with wrong size!
fi
# end of 'cursive-2/cursive.6'
fi
if test -f 'cursive-2/cursive.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cursive-2/cursive.h'\"
else
echo shar: Extracting \"'cursive-2/cursive.h'\" \(544 characters\)
sed "s/^X//" >'cursive-2/cursive.h' <<'END_OF_FILE'
struct letter {
X	char *line[6];			/* What's on each of the six lines */
X	char spcs[6];			/* Number of leading spaces for each */
X	short tailin,tailout;		/* Where the lines in and out go */
X	};
X
X/* Special Codes for Character Table */
X
X#define XX  -1		/* Ignore character */
X#define SP  -2          /* Space */
X#define ST  -3          /* Extend trailer */
X#define SA  -4		/* Alternate font number */	/* Not used */
X#define SN  -5		/* Numbers */			/* Not used */
X
X#define CHARWIDTH 10
X
extern struct letter list[];
extern short code1[], code2[];
END_OF_FILE
if test 544 -ne `wc -c <'cursive-2/cursive.h'`; then
    echo shar: \"'cursive-2/cursive.h'\" unpacked with wrong size!
fi
# end of 'cursive-2/cursive.h'
fi
if test ! -d 'gothic' ; then
    echo shar: Creating directory \"'gothic'\"
    mkdir 'gothic'
fi
echo shar: End of archive 1 \(of 5\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
