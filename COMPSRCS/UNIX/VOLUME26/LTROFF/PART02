Newsgroups: comp.sources.unix
From: ado@elsie.nci.nih.gov (Arthur David Olson)
Subject: v26i295: ltroff - troff-classic to laserjet 4 filter (incl scalable fonts), Part02/02
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: ado@elsie.nci.nih.gov (Arthur David Olson)
Posting-Number: Volume 26, Issue 295
Archive-Name: ltroff/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 2)."
# Contents:  ansic.h catsup.c testfile tlc.c
# Wrapped by vixie@gw.home.vix.com on Thu Jul 15 16:33:18 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ansic.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ansic.h'\"
else
echo shar: Extracting \"'ansic.h'\" \(9305 characters\)
sed "s/^X//" >'ansic.h' <<'END_OF_FILE'
X#ifndef ANSIC_H
X
X#define ANSIC_H
X
X/*
X** ID
X*/
X
X#ifndef ID
X#ifndef lint
X#ifndef NOID
X#define ID(name, value)	static char	(name)[] = value;
X#endif /* !defined NOID */
X#endif /* !defined lint */
X#ifndef ID
X#define ID(name, value)	/* static char	(name)[] = value; */
X#endif /* !defined ID */
X#endif /* !defined ID */
X
X#ifndef ELSIEID
X#define ELSIEID(value)	ID(elsieid, (value))
X#endif /* !defined ELSIEID */
X
XID(ansichid, "@(#)ansic.h	4.1")
X
X/*
X** Cover for stupid IBM PC/RT compilers (pcc and hc);
X** they fib about being __STDC__ when they lack standard header files
X** ("locale.h" for one).
X*/
X
X#ifdef ibm032
X#undef __STDC__
X#define VOID_OK
X#endif /* defined ibm032 */
X
X#ifdef sgi
X#define STDIO_H	<stdio.h>
X#define MATH_H	<math.h>
X#define remove	unlink
X#endif /* defined sgi */
X
X/*
X** const
X*/
X
X#ifndef const
X
X#ifndef CONST_OK
X#ifndef CONST_NO
X#ifdef __convexc__
X/*
X** Workaround for Convex CC bug that muffs
X**	func(int * const * const p){}
X*/
X#define CONST_NO
X#endif /* defined __convexc__ */
X#endif /* !defined CONST_NO */
X#endif /* !defined CONST_OK */
X
X#ifndef CONST_OK
X#ifndef CONST_NO
X#ifdef __STDC__
X#define CONST_OK
X#endif /* defined __STDC__ */
X#endif /* !defined CONST_NO */
X#endif /* !defined CONST_OK */
X
X#ifndef CONST_OK
X#define const
X#endif /* !defined CONST_OK */
X
X#endif /* !defined const */
X
X/*
X** void
X*/
X
X#ifndef void
X
X#ifndef VOID_NO
X#ifndef VOID_OK
X
X#ifdef __STDC__
X#define VOID_OK
X#endif /* defined __STDC__ */
X
X#ifdef sun
X#define VOID_OK
X#endif /* defined sun */
X
X#ifdef __convexc__
X#define VOID_OK
X#endif /* defined __convexc__ */
X
X#endif /* !defined VOID_OK */
X#endif /* !defined VOID_NO */
X
X#ifndef VOID_OK
X#define void char
X#endif /* !defined VOID_OK */
X
X#endif /* !defined void */
X
X/*
X** P((args))
X*/
X
X#ifndef P
X
X#ifndef PROTO_OK
X#ifndef PROTO_NO
X#ifdef __STDC__
X#define PROTO_OK
X#endif /* defined __STDC__ */
X#endif /* !defined PROTO_NO */
X#endif /* !defined PROTO_OK */
X
X#ifdef PROTO_OK
X#define P(x)	x
X#endif /* defined PROTO_OK */
X
X#ifndef PROTO_OK
X#define P(x)	()
X#endif /* !defined PROTO_OK */
X
X#endif /* !defined P */
X
X/*
X** Includes.  First the ones we expect to show up on all systems.
X*/
X
X/*
X** <assert.h>
X*/
X
X#ifdef ASSERT_H
X#include ASSERT_H
X#endif /* defined ASSERT_H */
X
X#ifndef ASSERT_H
X#include "assert.h"
X#endif /* !defined ASSERT_H */
X
X/*
X** <ctype.h>
X*/
X
X#ifdef CTYPE_H
X#include CTYPE_H
X#endif /* defined CTYPE_H */
X
X#ifndef CTYPE_H
X#include "ctype.h"
X#ifdef sun
X#ifndef tolower
Xextern int	tolower P((
X			int /*c*/
X			));
Xextern int	toupper P((
X			int /*c*/
X			));
X#endif /* !defined tolower */
X#endif /* defined sun */
X#endif /* !defined CTYPE_H */
X
X/*
X** <errno.h>
X*/
X
X#ifdef ERRNO_H
X#include ERRNO_H
X#endif /* defined ERRNO_H */
X
X#ifndef ERRNO_H
X#include "errno.h"
X#ifndef errno
Xextern int	errno;
X#endif /* !defined errno */
X#endif /* !defined ERRNO_H */
X
X/*
X** <math.h>
X*/
X
X#ifdef MATH_H
X#include MATH_H
X#endif /* defined MATH_H */
X
X#ifndef MATH_H
X#include "math.h"
X#ifndef __STDC__
X#ifndef mips
X/*
X** This declaration is missing in the 4.1BSD math.h;
X** we'll play it safe.
X*/
Xextern double	erf();
X#endif /* !defined mips */
X#endif  /* !defined __STDC__ */
X#endif /* !defined MATH_H */
X
X/*
X** <setjmp.h>
X*/
X
X#ifdef SETJMP_H
X#include SETJMP_H
X#endif /* defined SETJMP_H */
X
X#ifndef SETJMP_H
X#include "setjmp.h"
X#endif /* !defined SETJMP_H */
X
X/*
X** <signal.h>
X*/
X
X#ifdef SIGNAL_H
X#include SIGNAL_H
X#endif /* defined SIGNAL_H */
X
X#ifndef SIGNAL_H
X#include "signal.h"
X#ifdef mips
X/*
X** For the benefit of MIPS boxes, where signal isn't declared.
X*/
Xextern void (*	signal P((
X			int /*sig*/,
X			void (* /*func*/)()
X			)))();
X#endif /* defined mips */
X#endif /* !defined SIGNAL_H */
X
X/*
X** <stdio.h>
X*/
X
X#ifdef STDIO_H
X#include STDIO_H
X#endif /* defined STDIO_H */
X
X#ifndef STDIO_H
X#include "stdio.h"
X
X/*
X** We get to do stdio prototypes if we are not __STDC__ or we are __GNUC__
X*/
X
X#ifndef DO_STDIO_PROTOS
X#ifdef __GNUC__
X#define DO_STDIO_PROTOS
X#endif /* defined __GNUC__ */
X#endif /* !defined DO_STDIO_PROTOS */
X
X#ifndef DO_STDIO_PROTOS
X#ifndef __STDC__
X#ifndef __convexc__
X#define DO_STDIO_PROTOS
X#endif /* !defined __convexc__ */
X#endif /* !defined __STDC__ */
X#endif /* !defined DO_STDIO_PROTOS */
X
X#ifdef DO_STDIO_PROTOS
Xextern int	fclose P((
X			FILE * /*stream*/
X			));
Xextern int	fflush P((
X			FILE * /*stream*/
X			));
Xextern int	fprintf P((
X			FILE * /*stream*/,
X			const char * /*format*/,
X			...
X			));
Xextern int	fputc P((
X			int /*c*/,
X			FILE * /*stream*/
X			));
Xextern int	fputs P((
X			const char * /*s*/,
X			FILE * /*stream*/
X			));
Xextern int	fread P((
X			void * /*p*/,
X			int /*s*/,
X			int /*n*/,
X			FILE * /*stream*/
X			));
Xextern int	fscanf P((
X			FILE * /*stream*/,
X			const char * /*format*/,
X			...
X			));
Xextern int	fseek P((
X			FILE * /*stream*/,
X			long int /*offset*/,
X			int /*whence*/
X			));
Xextern int	fwrite P((
X			const void * /*p*/,
X			int /*s*/,
X			int /*n*/,
X			FILE * /*stream*/
X			));
Xextern int	printf P((
X			const char * /*format*/,
X			...
X			));
Xextern int	scanf P((
X			const char * /*format*/,
X			...
X			));
Xextern int	sscanf P((
X			const char * /*string*/,
X			const char * /*format*/,
X			...
X			));
Xextern char *	tmpnam P((
X			const char * /*name*/
X			));
Xextern int	ungetc P((
X			int /*c*/,
X			FILE * /*stream*/
X			));
X/*
X** To prevent gcc squawks when in "prototypes required" mode. . .
X*/
Xextern int	_filbuf P((
X			FILE * /*stream*/
X			));
Xextern int	_flsbuf P((
X			unsigned char /*c*/,
X			FILE * /*stream*/
X			));
X
X/*
X** And last but not least among the common stuff. . .
X*/
X#ifndef remove
Xextern int	unlink P((
X			const char * /*filename*/
X			));
X#define remove	unlink
X#endif /* !defined remove */
X
X#ifdef USG
Xextern void	rewind P((
X			FILE * /*stream*/
X			));
X#ifndef sun
Xextern int	sprintf P((
X			char * /*string*/,
X			const char * /*format*/,
X			...
X			));
X#endif /* !defined sun */
X#endif /* defined USG */
X#ifndef USG
Xextern int	rewind P((
X			FILE * /*stream*/
X			));
X#ifndef sun
Xextern char *	sprintf P((
X			char * /*string*/,
X			const char * /*format*/,
X			...
X			));
X#endif /* !defined sun */
X#endif /* !defined USG */
X
X#endif /* defined DO_STDIO_PROTOS */
X
X#endif /* !defined STDIO_H */
X
X/*
X** <string.h>
X*/
X
X#ifdef STRING_H
X#include STRING_H
X#endif /* defined STRING_H */
X
X#ifndef STRING_H
X#include "string.h"
X#ifdef sun
X#include "memory.h"
X#endif /* defined sun */
X#endif /* !defined STRING_H */
X
X/*
X** <time.h>
X*/
X
X#ifdef TIME_H
X#include TIME_H
X#endif /* defined TIME_H */
X
X#ifndef TIME_H
X#include "time.h"
X#endif /* !defined TIME_H */
X
X/*
X** ANSI inventions--float, limits, locale, stdarg, stddef, and stdlib.
X** GCC 1.28 comes with stddef.h, but using it causes clashes if you
X** also (directly or indirectly) include <sys/types.h>.  So we don't
X** use it here.
X*/
X
X#ifdef __STDC__
X
X#ifndef LIMITS_H
X#define LIMITS_H	"limits.h"
X#endif /* !defined LIMITS_H */
X
X#ifndef __GNUC__
X
X#ifndef STDARG_H
X#define STDARG_H	"stdarg.h"
X#endif /* !defined STDARG_H */
X
X#ifndef FLOAT_H
X#define FLOAT_H		"float.h"
X#endif /* !defined FLOAT_H */
X
X#ifndef LOCALE_H
X#define LOCALE_H	"locale.h"
X#endif /* !defined LOCALE_H */
X
X#ifndef STDDEF_H
X#define STDDEF_H	"stddef.h"
X#endif /* !defined STDDEF_H */
X
X#ifndef STDLIB_H
X#define STDLIB_H	"stdlib.h"
X#endif /* !defined STDLIB_H */
X
X#endif /* !defined __GNUC__ */
X#endif /* defined __STDC__ */
X
X#ifdef FLOAT_H
X#include FLOAT_H
X#endif /* defined FLOAT_H */
X
X#ifdef LIMITS_H
X#include LIMITS_H
X#endif /* defined LIMITS_H */
X
X#ifndef CHAR_BIT
X#define CHAR_BIT	8
X#endif /* !defined CHAR_BIT */
X
X#ifndef USHRT_MAX
X#define USHRT_MAX	((unsigned short) ~0)
X#endif /* !defined USHRT_MAX */
X
X#ifdef LOCALE_H
X#include LOCALE_H
X#endif /* defined LOCALE_H */
X
X#ifdef STDARG_H
X#include STDARG_H
X#endif /* defined STDARG_H */
X
X#ifdef STDDEF_H
X#include STDDEF_H
X#endif /* defined STDDEF_H */
X
X#ifdef STDLIB_H
X#include STDLIB_H
X#endif /* defined STDLIB_H */
X
X#ifndef STDLIB_H
Xextern int	atoi P((
X			const char * /*nptr*/
X			));
Xextern char *	getenv P((
X			const char * /*name*/
X			));
Xextern char *	malloc P((
X			unsigned /*size*/
X			));
Xextern char *	calloc P((
X			unsigned /*nelem*/,
X			unsigned /*elsize*/
X			));
Xextern char *	realloc P((
X			void * /*pointer*/,
X			unsigned /*size*/
X			));
Xextern int	system P((
X			const char * /*command*/
X			));
Xextern int	abs P((
X			int /*j*/
X			));
X
X#ifdef USG
Xextern void	exit P((
X			int /*status*/
X			));
Xextern void	free P((
X			void * /*pointer*/
X			));
Xextern void	qsort P((
X			void * /*base*/,
X			unsigned /*nmemb*/,
X			unsigned /*size*/,
X			int (*/*compar*/)(
X				const void * /*left*/,
X				const void * /*right*/
X				)
X			));
X#endif /* defined USG */
X#ifndef USG
X#ifdef sun
Xextern void	exit P((
X			int /*status*/
X			));
X#endif /* defined sun */
X#ifndef sun
Xextern int	exit P((
X			int /*status*/
X			));
X#endif /* !defined sun */
Xextern int	free P((
X			void * /*pointer*/
X			));
Xextern int	qsort P((
X			void * /*base*/,
X			unsigned /*nmemb*/,
X			unsigned /*size*/,
X			int (*/*compar*/)(
X				const void * /*left*/,
X				const void * /*right*/
X				)
X			));
X#endif /* !defined USG */
X#endif /* !defined STDLIB_H */
X
X#ifndef EXIT_FAILURE
X#define EXIT_FAILURE	1
X#endif /* !defined EXIT_FAILURE */
X
X#ifndef EXIT_SUCCESS
X#define EXIT_SUCCESS	0
X#endif /* !defined EXIT_SUCCESS */
X
X/*
X** One last bit of business. . .
X*/
X
X#ifndef isascii
X#define isascii(a_r_g)	(((unsigned) (a_r_g)) <= 127)
X#endif /* !defined isascii */
X
X#endif /* !defined ANSIC_H */
END_OF_FILE
if test 9305 -ne `wc -c <'ansic.h'`; then
    echo shar: \"'ansic.h'\" unpacked with wrong size!
fi
# end of 'ansic.h'
fi
if test -f 'catsup.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'catsup.c'\"
else
echo shar: Extracting \"'catsup.c'\" \(15726 characters\)
sed "s/^X//" >'catsup.c' <<'END_OF_FILE'
X/*LINTLIBRARY*/
X
X#include "ansic.h"
X#include "cat.h"
X
X#ifndef lint
X#ifndef NOID
Xstatic char	elsieid[] = "@(#)catsup.c	4.1";
X#endif /* !defined NOID */
X#endif /* !defined lint */
X
Xextern int	qsort();
X
X#if !defined TRUE
X#define TRUE	1
X#define FALSE	0
X#endif /* !defined TRUE */
X
Xtypedef struct {
X	int	c_special;
X	int	c_tophalf;
X	int	c_catcode;
X	int	c_vfindex;
X	int	c_ftindex;
X	char	c_ntname[3];
X} catinfo;
X
Xstatic catinfo	cattbl[] = {
X	/*	SPECIAL	TOPHALF	CATCODE	VFINDEX	FTINDEX	NTNAME	*/
X	{	-1,	-1,	-1,	-1,	32,	" " },
X	{	-1,	-1,	-1,	-1,	32,	"\\ " },
X	{	FALSE,	TRUE,	37,	33,	33,	"!" },
X	{	TRUE,	FALSE,	24,	34,	34,	"\"" },
X	{	TRUE,	TRUE,	31,	35,	35,	"#" },
X	{	FALSE,	TRUE,	45,	36,	36,	"$" },
X	{	FALSE,	FALSE,	43,	37,	37,	"%" },
X	{	FALSE,	FALSE,	40,	38,	38,	"&" },
X	{	FALSE,	FALSE,	26,	39,	39,	"'" },
X	{	TRUE,	TRUE,	28,	39,	146,	"\\'" },
X	{	FALSE,	TRUE,	26,	40,	40,	"(" },
X	{	FALSE,	TRUE,	27,	41,	41,	")" },
X	{	FALSE,	TRUE,	18,	42,	42,	"*" },
X	{	TRUE,	TRUE,	39,	57,	228,	"**" },
X	{	FALSE,	TRUE,	35,	43,	43,	"+" },
X	{	FALSE,	FALSE,	39,	44,	44,	"," },
X	{	FALSE,	FALSE,	32,	45,	45,	"-" },
X	{	FALSE,	TRUE,	19,	4,	136,	"\\-" },
X	{	TRUE,	TRUE,	21,	8,	205,	"+-" },
X	{	TRUE,	FALSE,	28,	52,	199,	"<-" },
X	{	FALSE,	FALSE,	36,	46,	46,	"." },
X	{	FALSE,	FALSE,	35,	47,	47,	"/" },
X	{	FALSE,	TRUE,	8,	48,	48,	"0" },
X	{	FALSE,	TRUE,	9,	49,	49,	"1" },
X	{	FALSE,	TRUE,	10,	50,	50,	"2" },
X	{	FALSE,	FALSE,	30,	18,	134,	"12" },
X	{	FALSE,	TRUE,	11,	51,	51,	"3" },
X	{	FALSE,	TRUE,	12,	52,	52,	"4" },
X	{	FALSE,	FALSE,	28,	17,	133,	"14" },
X	{	FALSE,	FALSE,	38,	19,	135,	"34" },
X	{	FALSE,	TRUE,	13,	53,	53,	"5" },
X	{	FALSE,	TRUE,	14,	54,	54,	"6" },
X	{	FALSE,	TRUE,	15,	55,	55,	"7" },
X	{	FALSE,	TRUE,	16,	56,	56,	"8" },
X	{	FALSE,	TRUE,	17,	57,	57,	"9" },
X	{	FALSE,	TRUE,	34,	58,	58,	":" },
X	{	FALSE,	FALSE,	19,	59,	59,	";" },
X	{	TRUE,	TRUE,	3,	60,	60,	"<" },
X	{	FALSE,	TRUE,	32,	61,	61,	"=" },
X	{	TRUE,	FALSE,	63,	49,	195,	"~=" },
X	{	TRUE,	TRUE,	22,	9,	192,	"<=" },
X	{	TRUE,	TRUE,	25,	51,	197,	"!=" },
X	{	TRUE,	TRUE,	24,	48,	193,	"==" },
X	{	TRUE,	TRUE,	23,	10,	191,	">=" },
X	{	TRUE,	TRUE,	1,	62,	62,	">" },
X	{	TRUE,	TRUE,	44,	53,	198,	"->" },
X	{	FALSE,	TRUE,	39,	63,	63,	"?" },
X	{	TRUE,	FALSE,	18,	64,	64,	"@" },
X	{	FALSE,	TRUE,	3,	65,	65,	"A" },
X	{	FALSE,	TRUE,	3,	65,	65,	"*A" },
X	{	FALSE,	FALSE,	61,	66,	66,	"B" },
X	{	FALSE,	FALSE,	61,	66,	66,	"*B" },
X	{	FALSE,	FALSE,	56,	67,	67,	"C" },
X	{	TRUE,	TRUE,	2,	78,	180,	"*C" },
X	{	FALSE,	FALSE,	60,	68,	68,	"D" },
X	{	TRUE,	FALSE,	60,	68,	177,	"*D" },
X	{	FALSE,	FALSE,	58,	69,	69,	"E" },
X	{	FALSE,	FALSE,	58,	69,	69,	"*E" },
X	{	FALSE,	TRUE,	1,	70,	70,	"F" },
X	{	TRUE,	FALSE,	45,	85,	185,	"*F" },
X	{	FALSE,	FALSE,	53,	71,	71,	"G" },
X	{	TRUE,	FALSE,	53,	67,	176,	"*G" },
X	{	FALSE,	FALSE,	48,	72,	72,	"H" },
X	{	TRUE,	FALSE,	46,	72,	178,	"*H" },
X	{	FALSE,	FALSE,	54,	73,	73,	"I" },
X	{	FALSE,	FALSE,	54,	73,	73,	"*I" },
X	{	FALSE,	TRUE,	5,	74,	74,	"J" },
X	{	FALSE,	TRUE,	7,	75,	75,	"K" },
X	{	FALSE,	TRUE,	7,	75,	75,	"*K" },
X	{	FALSE,	FALSE,	51,	76,	76,	"L" },
X	{	TRUE,	FALSE,	51,	75,	179,	"*L" },
X	{	FALSE,	FALSE,	50,	77,	77,	"M" },
X	{	FALSE,	FALSE,	50,	77,	77,	"*M" },
X	{	FALSE,	FALSE,	49,	78,	78,	"N" },
X	{	FALSE,	FALSE,	49,	78,	78,	"*N" },
X	{	FALSE,	FALSE,	47,	79,	79,	"O" },
X	{	FALSE,	FALSE,	47,	79,	79,	"*O" },
X	{	FALSE,	FALSE,	55,	80,	80,	"P" },
X	{	TRUE,	FALSE,	55,	80,	181,	"*P" },
X	{	FALSE,	FALSE,	45,	81,	81,	"Q" },
X	{	TRUE,	FALSE,	34,	87,	186,	"*Q" },
X	{	FALSE,	FALSE,	52,	82,	82,	"R" },
X	{	FALSE,	FALSE,	55,	80,	80,	"*R" },
X	{	FALSE,	FALSE,	62,	83,	83,	"S" },
X	{	TRUE,	FALSE,	62,	82,	182,	"*S" },
X	{	FALSE,	FALSE,	46,	84,	84,	"T" },
X	{	FALSE,	FALSE,	46,	84,	84,	"*T" },
X	{	FALSE,	TRUE,	6,	85,	85,	"U" },
X	{	TRUE,	TRUE,	6,	84,	184,	"*U" },
X	{	FALSE,	FALSE,	57,	86,	86,	"V" },
X	{	FALSE,	TRUE,	4,	87,	87,	"W" },
X	{	TRUE,	FALSE,	47,	88,	187,	"*W" },
X	{	FALSE,	TRUE,	2,	88,	88,	"X" },
X	{	FALSE,	TRUE,	2,	88,	88,	"*X" },
X	{	FALSE,	FALSE,	63,	89,	89,	"Y" },
X	{	FALSE,	FALSE,	48,	72,	72,	"*Y" },
X	{	FALSE,	FALSE,	59,	90,	90,	"Z" },
X	{	FALSE,	FALSE,	59,	90,	90,	"*Z" },
X	{	FALSE,	TRUE,	28,	91,	91,	"[" },
X	{	TRUE,	FALSE,	33,	92,	92,	"\\" },
X	{	FALSE,	TRUE,	29,	93,	93,	"]" },
X	{	TRUE,	TRUE,	30,	94,	94,	"^" },
X	{	-1,	-1,	-1,	-1,	150,	"\\^" },
X	{	TRUE,	FALSE,	32,	95,	95,	"_" },
X	{	FALSE,	FALSE,	24,	96,	96,	"`" },
X	{	TRUE,	TRUE,	29,	96,	147,	"\\`" },
X	{	FALSE,	FALSE,	21,	97,	97,	"a" },
X	{	TRUE,	FALSE,	19,	55,	201,	"da" },
X	{	TRUE,	TRUE,	5,	28,	207,	"ca" },
X	{	TRUE,	FALSE,	21,	97,	152,	"*a" },
X	{	TRUE,	TRUE,	28,	39,	146,	"aa" },
X	{	TRUE,	FALSE,	30,	54,	200,	"ua" },
X	{	TRUE,	TRUE,	29,	96,	147,	"ga" },
X	{	FALSE,	FALSE,	10,	98,	98,	"b" },
X	{	TRUE,	TRUE,	15,	23,	235,	"rb" },
X	{	TRUE,	TRUE,	40,	91,	210,	"ib" },
X	{	TRUE,	TRUE,	12,	21,	233,	"lb" },
X	{	TRUE,	FALSE,	10,	98,	153,	"*b" },
X	{	TRUE,	FALSE,	56,	26,	208,	"sb" },
X	{	FALSE,	FALSE,	23,	99,	99,	"c" },
X	{	TRUE,	TRUE,	8,	19,	242,	"rc" },
X	{	TRUE,	TRUE,	45,	56,	144,	"sc" },
X	{	TRUE,	TRUE,	18,	18,	241,	"lc" },
X	{	TRUE,	FALSE,	11,	110,	165,	"*c" },
X	{	FALSE,	FALSE,	9,	100,	100,	"d" },
X	{	TRUE,	FALSE,	59,	121,	213,	"pd" },
X	{	TRUE,	FALSE,	9,	100,	155,	"*d" },
X	{	TRUE,	TRUE,	37,	89,	225,	"dd" },
X	{	FALSE,	FALSE,	25,	101,	101,	"e" },
X	{	TRUE,	FALSE,	25,	101,	156,	"*e" },
X	{	FALSE,	TRUE,	30,	11,	142,	"de" },
X	{	FALSE,	FALSE,	12,	102,	102,	"f" },
X	{	TRUE,	TRUE,	17,	16,	239,	"lf" },
X	{	TRUE,	TRUE,	16,	17,	240,	"rf" },
X	{	TRUE,	FALSE,	13,	117,	172,	"*f" },
X	{	FALSE,	TRUE,	22,	3,	139,	"ff" },
X	{	TRUE,	FALSE,	36,	1,	212,	"if" },
X	{	FALSE,	FALSE,	37,	103,	103,	"g" },
X	{	TRUE,	FALSE,	37,	99,	154,	"*g" },
X	{	FALSE,	TRUE,	31,	12,	143,	"dg" },
X	{	FALSE,	TRUE,	33,	15,	221,	"rg" },
X	{	FALSE,	FALSE,	1,	104,	104,	"h" },
X	{	TRUE,	FALSE,	2,	104,	159,	"*h" },
X	{	TRUE,	FALSE,	40,	4,	226,	"rh" },
X	{	TRUE,	TRUE,	32,	30,	227,	"lh" },
X	{	FALSE,	FALSE,	6,	105,	105,	"i" },
X	{	TRUE,	FALSE,	6,	105,	160,	"*i" },
X	{	TRUE,	FALSE,	52,	45,	194,	"mi" },
X	{	FALSE,	TRUE,	25,	9,	140,	"Fi" },
X	{	FALSE,	TRUE,	20,	1,	137,	"fi" },
X	{	TRUE,	TRUE,	20,	47,	204,	"di" },
X	{	TRUE,	TRUE,	41,	93,	231,	"ci" },
X	{	FALSE,	FALSE,	13,	106,	106,	"j" },
X	{	FALSE,	FALSE,	15,	107,	107,	"k" },
X	{	TRUE,	FALSE,	15,	106,	161,	"*k" },
X	{	TRUE,	TRUE,	14,	25,	237,	"rk" },
X	{	TRUE,	TRUE,	11,	24,	236,	"lk" },
X	{	FALSE,	FALSE,	5,	108,	108,	"l" },
X	{	FALSE,	TRUE,	24,	10,	141,	"Fl" },
X	{	FALSE,	TRUE,	21,	2,	138,	"fl" },
X	{	TRUE,	TRUE,	4,	14,	149,	"sl" },
X	{	TRUE,	FALSE,	5,	107,	162,	"*l" },
X	{	TRUE,	TRUE,	43,	43,	220,	"pl" },
X	{	TRUE,	FALSE,	32,	95,	148,	"ul" },
X	{	FALSE,	FALSE,	4,	109,	109,	"m" },
X	{	FALSE,	TRUE,	40,	13,	145,	"fm" },
X	{	TRUE,	FALSE,	4,	108,	163,	"*m" },
X	{	FALSE,	FALSE,	18,	6,	131,	"em" },
X	{	FALSE,	FALSE,	3,	110,	110,	"n" },
X	{	TRUE,	FALSE,	49,	6,	190,	"rn" },
X	{	TRUE,	FALSE,	3,	109,	164,	"*n" },
X	{	FALSE,	FALSE,	27,	111,	111,	"o" },
X	{	FALSE,	TRUE,	43,	14,	222,	"co" },
X	{	TRUE,	TRUE,	7,	29,	215,	"no" },
X	{	TRUE,	TRUE,	33,	31,	219,	"mo" },
X	{	TRUE,	FALSE,	27,	111,	166,	"*o" },
X	{	FALSE,	FALSE,	17,	112,	112,	"p" },
X	{	TRUE,	FALSE,	17,	112,	167,	"*p" },
X	{	TRUE,	FALSE,	38,	2,	211,	"ip" },
X	{	TRUE,	FALSE,	57,	27,	209,	"sp" },
X	{	TRUE,	FALSE,	58,	50,	196,	"ap" },
X	{	FALSE,	FALSE,	34,	113,	113,	"q" },
X	{	TRUE,	FALSE,	1,	119,	174,	"*q" },
X	{	TRUE,	FALSE,	26,	61,	202,	"eq" },
X	{	FALSE,	TRUE,	44,	8,	130,	"sq" },
X	{	FALSE,	FALSE,	29,	114,	114,	"r" },
X	{	TRUE,	FALSE,	43,	40,	214,	"gr" },
X	{	TRUE,	FALSE,	61,	11,	188,	"sr" },
X	{	TRUE,	FALSE,	22,	124,	230,	"or" },
X	{	TRUE,	FALSE,	29,	113,	168,	"*r" },
X	{	TRUE,	TRUE,	38,	90,	223,	"br" },
X	{	FALSE,	FALSE,	8,	115,	115,	"s" },
X	{	TRUE,	FALSE,	8,	114,	169,	"*s" },
X	{	TRUE,	FALSE,	54,	13,	216,	"is" },
X	{	TRUE,	FALSE,	50,	12,	189,	"ts" },
X	{	TRUE,	FALSE,	35,	7,	229,	"bs" },
X	{	TRUE,	TRUE,	35,	122,	218,	"es" },
X	{	FALSE,	FALSE,	2,	116,	116,	"t" },
X	{	TRUE,	TRUE,	13,	22,	234,	"rt" },
X	{	FALSE,	TRUE,	23,	16,	224,	"ct" },
X	{	TRUE,	TRUE,	9,	20,	232,	"lt" },
X	{	TRUE,	FALSE,	31,	115,	170,	"*t" },
X	{	TRUE,	FALSE,	39,	3,	217,	"pt" },
X	{	FALSE,	FALSE,	14,	117,	117,	"u" },
X	{	TRUE,	FALSE,	48,	5,	206,	"cu" },
X	{	FALSE,	TRUE,	38,	7,	129,	"bu" },
X	{	TRUE,	TRUE,	19,	42,	203,	"mu" },
X	{	FALSE,	FALSE,	22,	5,	132,	"ru" },
X	{	TRUE,	FALSE,	14,	116,	171,	"*u" },
X	{	FALSE,	FALSE,	31,	118,	118,	"v" },
X	{	TRUE,	TRUE,	10,	15,	238,	"bv" },
X	{	FALSE,	FALSE,	33,	119,	119,	"w" },
X	{	TRUE,	FALSE,	41,	120,	175,	"*w" },
X	{	FALSE,	FALSE,	11,	120,	120,	"x" },
X	{	TRUE,	FALSE,	23,	118,	173,	"*x" },
X	{	FALSE,	FALSE,	41,	121,	121,	"y" },
X	{	FALSE,	FALSE,	32,	45,	128,	"hy" },
X	{	TRUE,	FALSE,	12,	103,	158,	"*y" },
X	{	FALSE,	FALSE,	7,	122,	122,	"z" },
X	{	TRUE,	FALSE,	7,	102,	157,	"*z" },
X	{	TRUE,	TRUE,	26,	123,	123,	"{" },
X	{	FALSE,	TRUE,	41,	124,	124,	"|" },
X	{	-1,	-1,	-1,	-1,	127,	"\\|" },
X	{	TRUE,	TRUE,	27,	125,	125,	"}" },
X	{	TRUE,	TRUE,	34,	126,	126,	"~" },
X	{	-1,	-1,	-1,	-1,	0,	"" }
X};
X
X#if !defined NVPC
X#define NVPC	256		/* Number of Values Per Character */
X#endif /* !defined NVPC */
X
Xstatic const catinfo *	code2cip[2][2][CAT_MAX_FLASH + 1];
Xstatic const catinfo *	char2cip[NVPC];
Xstatic int		didinit;
X
Xstatic void
Xtblinit()
X{
X	const catinfo *		acip;
X	const catinfo *		bcip;
X	int			i;
X	int			c;
X
X	if (didinit)
X		return;
X	for (acip = cattbl; acip->c_ntname[0] != '\0'; ++acip) {
X		if ((c = acip->c_ntname[1]) == '\0')
X			c = acip->c_ntname[0];
X		if (char2cip[(unsigned char) c] == NULL)
X			char2cip[(unsigned char) c] = acip;
X		if (acip->c_catcode <= 0)
X			continue;
X		bcip = code2cip[acip->c_special]
X			[acip->c_tophalf]
X			[acip->c_catcode];
X		if (bcip != NULL && (bcip->c_ntname[1] == '\0' ||
X			(acip->c_ntname[1] != '\0' &&
X			acip->c_ntname[1] == '\\')))
X				continue;
X		code2cip[acip->c_special]
X			[acip->c_tophalf]
X			[acip->c_catcode] = acip;
X	}
X	for (i = 0; i < NVPC; ++i)
X		if (char2cip[i] == NULL)
X			char2cip[i] = acip;
X	didinit = TRUE;
X}
X
Xstatic const catinfo *
Xntn2cip(name)
Xchar *	name;
X{
X	const catinfo *	cip;
X	int		c;
X
X	if (!didinit)
X		tblinit();
X	if (name == NULL)
X		return NULL;
X	if (name[1] == '\0')
X		return char2cip[(unsigned char) name[0]];
X	if (name[0] == '\\' && name[1] == '(')
X		name += 2;
X	if (name[0] == '\0')
X		return NULL;
X	if ((c = name[1]) == '\0')
X		c = name[0];
X	else if (name[2] != '\0')
X		return NULL;
X	cip = char2cip[(unsigned char) c];
X	while (cip->c_ntname[0] != '\0')
X		if (cip->c_ntname[0] == name[0] &&
X			cip->c_ntname[1] == name[1])
X				return cip;
X		else	++cip;
X	return NULL;
X}
X
Xint
Xntn2vfi(name)
Xchar * const	name;
X{
X	const catinfo *	cip;
X
X	return ((cip = ntn2cip(name)) == NULL) ? -1 : cip->c_vfindex;
X}
X
Xint
Xntn2fti(name)
Xchar * const	name;
X{
X	const catinfo *	cip;
X
X	return ((cip = ntn2cip(name)) == NULL) ? -1 : cip->c_ftindex;
X}
X
Xconst char *
Xfti2ntn(fti)
Xint const	fti;
X{
X	catinfo *	cip;
X
X	for (cip = cattbl; ; ++cip)
X		if (cip->c_ntname[0] == '\0')
X			return NULL;
X		else if (cip->c_ftindex == fti)
X			return cip->c_ntname;
X}
X
Xint
Xntnons(name)
Xchar * const	name;
X{
X	const catinfo *	cip;
X
X	return ((cip = ntn2cip(name)) == NULL) ? -1 : cip->c_special;
X}
X
Xint
Xntnonr(name)
Xchar * const	name;
X{
X	const catinfo *	cip;
X
X	return ((cip = ntn2cip(name)) == NULL) ? -1 : !cip->c_special;
X}
X
X/*
X** Now here's something we hope you'll really like. . .
X*/
X
Xextern char *	malloc();
Xextern char *	realloc();
X
Xstatic int	curfont = 0;		/* current font */
Xstatic long	horizontal = -16;	/* horizontal position */
Xstatic long	vertical = 0	;	/* vertical position */
Xstatic int	escape_forward = TRUE;	/* should escape forward */
Xstatic int	lead_forward = TRUE;	/* should lead forward */
Xstatic int	tophalf = FALSE;	/* TRUE if top half of font is wanted */
Xstatic int	true_point_size = 10;
X
Xstatic void
Xcatinit()
X{
X	escape_forward = TRUE;
X	lead_forward = TRUE;
X	tophalf = FALSE;
X	curfont = 0;
X	true_point_size = 10;	/* troff default */
X	horizontal = -16;
X}
X
Xtypedef struct {
X	long	horizontal;
X	long	vertical;
X	char	size;
X	char	fontname[3];
X	char	charname[3];
X} memory;
X
Xstatic int
Xmcomp(avp, bvp)
Xvoid * const	avp;
Xvoid * const	bvp;
X{
X	const memory * const	amp = (const memory *) avp;
X	const memory * const	bmp = (const memory *) bvp;
X	long			diff = amp->horizontal - bmp->horizontal;
X
X	if (diff == 0) {
X		diff = amp->size - bmp->size;
X		if (diff == 0)
X			return 0;
X	}
X	return (diff > 0) ? 1 : -1;
X}
X
Xstatic char 	fontnicks[8][3] = {
X	"R",
X	"",
X	"I",
X	"",
X	"B",
X	"",
X	"S",
X	"",
X};
X
Xstatic int
Xdoflash(catcode, outp, dosort)
Xint const	catcode;
Xint (* const	outp)();
Xint const	dosort;
X{
X	const catinfo *	cip;
X	memory *	mp;
X	static memory *	memories;
X	static int	memused;
X	static int	memavail;
X	static memory	zm;
X
X	if (fontnicks[curfont][0] == 'S' && fontnicks[curfont][1] == '\0')
X		cip = code2cip[TRUE][tophalf][catcode];
X	else	cip = code2cip[FALSE][tophalf][catcode];
X	if (!dosort)
X		if (catcode <= 0)
X			return 0;
X		else	return ((*outp)(cip->c_ntname, horizontal, vertical,
X				true_point_size, fontnicks[curfont]) == 0) ?
X					0 : -1;
X	/*
X	** Flush if appropriate.
X	*/
X	if (memused > 0 && (catcode <= 0 || vertical != memories[0].vertical)) {
X		int	i;
X
X		(void) qsort((char *) memories, memused,
X			sizeof *memories, mcomp);
X		for (i = 0; i < memused; ++i) {
X			mp = &memories[i];
X			if ((*outp)(mp->charname,
X				mp->horizontal, mp->vertical,
X				mp->size, mp->fontname) != 0)
X					return -1;
X		}
X		memused = 0;
X	}
X	/*
X	** Remember if appropriate.
X	*/
X	if (catcode <= 0)
X		return 0;
X	if (memused >= memavail) {
X		if (memavail++ == 0)
X			memories = (memory *) malloc(sizeof *memories);
X		else	memories = (memory *) realloc((char *) memories,
X				(unsigned) (memavail * sizeof *memories));
X		if (memories == NULL) {
X			memavail = 0;
X			return -1;
X		}
X		memories[memused] = zm;
X	}
X	mp = &memories[memused];
X	mp->horizontal = horizontal;
X	mp->vertical = vertical;
X	mp->size = true_point_size;
X	mp->fontname[0] = fontnicks[curfont][0];
X	mp->fontname[1] = fontnicks[curfont][1];
X	mp->charname[0] = cip->c_ntname[0];
X	mp->charname[1] = cip->c_ntname[1];
X	++memused;
X	return 0;
X}
X
Xint
Xcatsup(inp, outp, dosort, skipinit)
Xint (* const	inp)();
Xint (* const	outp)();
Xint const	dosort;
Xint const	skipinit;
X{
X	int	c;
X	int	i;
X
X	if (inp == NULL || outp == NULL ||
X		(dosort != TRUE && dosort != FALSE) ||
X		(skipinit != TRUE && skipinit != FALSE))
X			return -1;
X	if (!skipinit) {
X		catinit();
X		vertical = 0;
X	}
X	tblinit();
X	while ((c = (*inp)()) >= 0) {
X		if (CAT_IS_FLASH(c)) {
X			if (doflash(c, outp, dosort) != 0)
X				return -1;
X		} else if (CAT_IS_ESCAPE(c)) {
X			i = CAT_ESCAPE(c);
X			if (escape_forward)
X				horizontal += i;
X			else {
X				horizontal -= i;
X				if (horizontal < 0)
X					horizontal = 0;
X			}
X		} else if (CAT_IS_LEADING(c)) {
X			i = CAT_LEAD(c);
X			if (lead_forward)
X				vertical += i;
X			else	vertical -= i;
X		} else if (CAT_IS_SIZE_CHANGE(c)) {
X			i = CAT_SIZE_CHANGE(c);
X			if (CAT_IS_DOUBLE_TO_SINGLE(true_point_size, i))
X				horizontal += CAT_LENSE_COMPENSATION;
X			else if (CAT_IS_SINGLE_TO_DOUBLE(true_point_size, i)) {
X				horizontal -= CAT_LENSE_COMPENSATION;
X				if (horizontal < 0)
X					horizontal = 0;
X			}
X			true_point_size = i;
X		} else switch (c) {
X			case CAT_INITIALIZE:
X				catinit();
X				break;
X			case CAT_UPPER_RAIL:
X				curfont |= CAT_RAIL;
X				break;
X			case CAT_LOWER_RAIL:
X				curfont &= ~CAT_RAIL;
X				break;
X			case CAT_UPPER_MAGAZINE:
X				curfont |= CAT_MAGAZINE;
X				break;
X			case CAT_LOWER_MAGAZINE:
X				curfont &= ~CAT_MAGAZINE;
X				break;
X			case CAT_TILT_UP:
X				curfont |= CAT_TILT;
X				break;
X			case CAT_TILT_DOWN:
X				curfont &= ~CAT_TILT;
X				break;
X			case CAT_UPPER_FONT:
X				tophalf = TRUE;
X				break;
X			case CAT_LOWER_FONT:
X				tophalf = FALSE;
X				break;
X			case CAT_ESCAPE_FORWARD:
X				escape_forward = TRUE;
X				break;
X			case CAT_ESCAPE_BACKWARD:
X				escape_forward = FALSE;
X				break;
X			case CAT_LEAD_FORWARD:
X				lead_forward = TRUE;
X				break;
X			case CAT_LEAD_BACKWARD:
X				lead_forward = FALSE;
X				break;
X			case CAT_STOP:
X				break;	/* ? */
X			default:
X				return -1;
X		}
X	}
X	if (doflash(0, outp, dosort) != 0)
X		return -1;
X	return 0;
X}
END_OF_FILE
if test 15726 -ne `wc -c <'catsup.c'`; then
    echo shar: \"'catsup.c'\" unpacked with wrong size!
fi
# end of 'catsup.c'
fi
if test -f 'testfile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'testfile'\"
else
echo shar: Extracting \"'testfile'\" \(10005 characters\)
sed "s/^X//" >'testfile' <<'END_OF_FILE'
X'\" @(#)testfile	4.1
X'\" Troff test data
X.po 0
X.ll 8i
X.de 1i
X.sp 1i
X..
X.wh -1i 1i
X.wh 0 1i
X.nf
XSpecial characters in NROFF/TROFF User's Manual Table II order
X.ta .7i +.7i +.7i +.7i
XRoman	\fIItalic\fP	\fBBold\fP	Input	Character
XChar	\fIChar\fP	\fBChar\fP	Name 	Name
X\&'	\fI'\fP	\fB'\fP	'	close quote
X`	\fI`\fP	\fB`\fP	`	open quote
X\(em	\fI\(em\fP	\fB\(em\fP	\e(em	3/4 Em dash
X\(hy	\fI\(hy\fP	\fB\(hy\fP	\e(hy	hyphen or
X-	\fI-\fP	\fB-\fP	-	hyphen
X\-	\fI\-\fP	\fB\-\fP	\e-	current font minus
X\(bu	\fI\(bu\fP	\fB\(bu\fP	\e(bu	bullet
X\(sq	\fI\(sq\fP	\fB\(sq\fP	\e(sq	square
X\(ru	\fI\(ru\fP	\fB\(ru\fP	\e(ru	rule
X\(14	\fI\(14\fP	\fB\(14\fP	\e(14	1/4
X\(12	\fI\(12\fP	\fB\(12\fP	\e(12	1/2
X\(34	\fI\(34\fP	\fB\(34\fP	\e(34	3/4
X\(fi	\fI\(fi\fP	\fB\(fi\fP	\e(fi	fi (ligature)
X\(fl	\fI\(fl\fP	\fB\(fl\fP	\e(fl	fl (ligature)
X\(ff	\fI\(ff\fP	\fB\(ff\fP	\e(ff	ff (ligature)
X\(Fi	\fI\(Fi\fP	\fB\(Fi\fP	\e(Fi	ffi (ligature)
X\(Fl	\fI\(Fl\fP	\fB\(Fl\fP	\e(Fl	ffl (ligature)
X\(de	\fI\(de\fP	\fB\(de\fP	\e(de	degree
X\(dg	\fI\(dg\fP	\fB\(dg\fP	\e(dg	dagger
X\(fm	\fI\(fm\fP	\fB\(fm\fP	\e(fm	foot mark
X\(ct	\fI\(ct\fP	\fB\(ct\fP	\e(ct	cent sign
X\(rg	\fI\(rg\fP	\fB\(rg\fP	\e(rg	registered
X\(co	\fI\(co\fP	\fB\(co\fP	\e(co	copyright
X\(pl	\fI\(pl\fP	\fB\(pl\fP	\e(pl	math plus
X\(mi	\fI\(mi\fP	\fB\(mi\fP	\e(mi	math minus
X\(eq	\fI\(eq\fP	\fB\(eq\fP	\e(eq	math equal
X\(**	\fI\(**\fP	\fB\(**\fP	\e(**	math star
X\(sc	\fI\(sc\fP	\fB\(sc\fP	\e(sc	section
X\(aa	\fI\(aa\fP	\fB\(aa\fP	\e(aa	acute accent
X\(ga	\fI\(ga\fP	\fB\(ga\fP	\e(ga	grave accent
X\(ul	\fI\(ul\fP	\fB\(ul\fP	\e(ul	underrule
X\(sl	\fI\(sl\fP	\fB\(sl\fP	\e(sl	slash (matching backslash)
X\(*a	\fI\(*a\fP	\fB\(*a\fP	\e(*a	alpha
X\(*b	\fI\(*b\fP	\fB\(*b\fP	\e(*b	beta
X\(*g	\fI\(*g\fP	\fB\(*g\fP	\e(*g	gamma
X\(*d	\fI\(*d\fP	\fB\(*d\fP	\e(*d	delta
X\(*e	\fI\(*e\fP	\fB\(*e\fP	\e(*e	epsilon
X\(*z	\fI\(*z\fP	\fB\(*z\fP	\e(*z	zeta
X\(*y	\fI\(*y\fP	\fB\(*y\fP	\e(*y	eta
X\(*h	\fI\(*h\fP	\fB\(*h\fP	\e(*h	theta
X\(*i	\fI\(*i\fP	\fB\(*i\fP	\e(*i	iota
X\(*k	\fI\(*k\fP	\fB\(*k\fP	\e(*k	kappa
X\(*l	\fI\(*l\fP	\fB\(*l\fP	\e(*l	lambda
X\(*m	\fI\(*m\fP	\fB\(*m\fP	\e(*m	mu
X\(*n	\fI\(*n\fP	\fB\(*n\fP	\e(*n	nu
X\(*c	\fI\(*c\fP	\fB\(*c\fP	\e(*c	xi
X\(*o	\fI\(*o\fP	\fB\(*o\fP	\e(*o	omicron
X\(*p	\fI\(*p\fP	\fB\(*p\fP	\e(*p	pi
X\(*r	\fI\(*r\fP	\fB\(*r\fP	\e(*r	rho
X\(*s	\fI\(*s\fP	\fB\(*s\fP	\e(*s	sigma
X\(ts	\fI\(ts\fP	\fB\(ts\fP	\e(ts	terminal sigma
X\(*t	\fI\(*t\fP	\fB\(*t\fP	\e(*t	tau
X\(*u	\fI\(*u\fP	\fB\(*u\fP	\e(*u	upsilon
X\(*f	\fI\(*f\fP	\fB\(*f\fP	\e(*f	phi
X\(*x	\fI\(*x\fP	\fB\(*x\fP	\e(*x	chi
X\(*q	\fI\(*q\fP	\fB\(*q\fP	\e(*q	psi
X\(*w	\fI\(*w\fP	\fB\(*w\fP	\e(*w	omega
X\(*A	\fI\(*A\fP	\fB\(*A\fP	\e(*A	Alpha
X\(*B	\fI\(*B\fP	\fB\(*B\fP	\e(*B	Beta
X\(*G	\fI\(*G\fP	\fB\(*G\fP	\e(*G	Gamma
X\(*D	\fI\(*D\fP	\fB\(*D\fP	\e(*D	Delta
X\(*E	\fI\(*E\fP	\fB\(*E\fP	\e(*E	Epsilon
X\(*Z	\fI\(*Z\fP	\fB\(*Z\fP	\e(*Z	Zeta
X\(*Y	\fI\(*Y\fP	\fB\(*Y\fP	\e(*Y	Eta
X\(*H	\fI\(*H\fP	\fB\(*H\fP	\e(*H	Theta
X\(*I	\fI\(*I\fP	\fB\(*I\fP	\e(*I	Iota
X\(*K	\fI\(*K\fP	\fB\(*K\fP	\e(*K	Kappa
X\(*L	\fI\(*L\fP	\fB\(*L\fP	\e(*L	Lambda
X\(*M	\fI\(*M\fP	\fB\(*M\fP	\e(*M	Mu
X\(*N	\fI\(*N\fP	\fB\(*N\fP	\e(*N	Nu
X\(*C	\fI\(*C\fP	\fB\(*C\fP	\e(*C	Xi
X\(*O	\fI\(*O\fP	\fB\(*O\fP	\e(*O	Omicron
X\(*P	\fI\(*P\fP	\fB\(*P\fP	\e(*P	Pi
X\(*R	\fI\(*R\fP	\fB\(*R\fP	\e(*R	Rho
X\(*S	\fI\(*S\fP	\fB\(*S\fP	\e(*S	Sigma
X\(*T	\fI\(*T\fP	\fB\(*T\fP	\e(*T	Tau
X\(*U	\fI\(*U\fP	\fB\(*U\fP	\e(*U	Upsilon
X\(*F	\fI\(*F\fP	\fB\(*F\fP	\e(*F	Phi
X\(*X	\fI\(*X\fP	\fB\(*X\fP	\e(*X	Chi
X\(*Q	\fI\(*Q\fP	\fB\(*Q\fP	\e(*Q	Psi
X\(*W	\fI\(*W\fP	\fB\(*W\fP	\e(*W	Omega
X\(sr	\fI\(sr\fP	\fB\(sr\fP	\e(sr	square root
X\(rn	\fI\(rn\fP	\fB\(rn\fP	\e(rn	root en extender (over line)
X\(>=	\fI\(>=\fP	\fB\(>=\fP	\e(>=	>=
X\(<=	\fI\(<=\fP	\fB\(<=\fP	\e(<=	<=
X\(==	\fI\(==\fP	\fB\(==\fP	\e(==	identically equal
X\(~=	\fI\(~=\fP	\fB\(~=\fP	\e(~=	approx =
X\(ap	\fI\(ap\fP	\fB\(ap\fP	\e(ap	approximates
X\(!=	\fI\(!=\fP	\fB\(!=\fP	\e(!=	not equal
X\(->	\fI\(->\fP	\fB\(->\fP	\e(->	right arrow
X\(<-	\fI\(<-\fP	\fB\(<-\fP	\e(<-	left arrow
X\(ua	\fI\(ua\fP	\fB\(ua\fP	\e(ua	up arrow
X\(da	\fI\(da\fP	\fB\(da\fP	\e(da	down arrow
X\(mu	\fI\(mu\fP	\fB\(mu\fP	\e(mu	multiply
X\(di	\fI\(di\fP	\fB\(di\fP	\e(di	divide
X\(+-	\fI\(+-\fP	\fB\(+-\fP	\e(+-	plus-minus
X\(cu	\fI\(cu\fP	\fB\(cu\fP	\e(cu	cup (union)
X\(ca	\fI\(ca\fP	\fB\(ca\fP	\e(ca	cap (intersection)
X\(sb	\fI\(sb\fP	\fB\(sb\fP	\e(sb	subset of
X\(sp	\fI\(sp\fP	\fB\(sp\fP	\e(sp	superset of
X\(ib	\fI\(ib\fP	\fB\(ib\fP	\e(ib	improper subset
X\(ip	\fI\(ip\fP	\fB\(ip\fP	\e(ip	improper superset
X\(if	\fI\(if\fP	\fB\(if\fP	\e(if	infinity
X\(pd	\fI\(pd\fP	\fB\(pd\fP	\e(pd	partial derivative
X\(gr	\fI\(gr\fP	\fB\(gr\fP	\e(gr	gradient
X\(no	\fI\(no\fP	\fB\(no\fP	\e(no	not
X\(is	\fI\(is\fP	\fB\(is\fP	\e(is	integral sign
X\(pt	\fI\(pt\fP	\fB\(pt\fP	\e(pt	proportional to
X\(es	\fI\(es\fP	\fB\(es\fP	\e(es	empty set
X\(mo	\fI\(mo\fP	\fB\(mo\fP	\e(mo	member of
X\(br	\fI\(br\fP	\fB\(br\fP	\e(br	box vertical rule
X\(dd	\fI\(dd\fP	\fB\(dd\fP	\e(dd	double dagger
X\(rh	\fI\(rh\fP	\fB\(rh\fP	\e(rh	right hand
X\(lh	\fI\(lh\fP	\fB\(lh\fP	\e(lh	left hand
X\(bs	\fI\(bs\fP	\fB\(bs\fP	\e(bs	Bell System logo (typesetter-dependent)
X\(or	\fI\(or\fP	\fB\(or\fP	\e(or	or
X\(ci	\fI\(ci\fP	\fB\(ci\fP	\e(ci	circle
X\(lt	\fI\(lt\fP	\fB\(lt\fP	\e(lt	left top of big curly bracket
X\(lb	\fI\(lb\fP	\fB\(lb\fP	\e(lb	left bottom
X\(rt	\fI\(rt\fP	\fB\(rt\fP	\e(rt	right top
X\(rb	\fI\(rb\fP	\fB\(rb\fP	\e(rb	right bot
X\(lk	\fI\(lk\fP	\fB\(lk\fP	\e(lk	left center of big curly bracket
X\(rk	\fI\(rk\fP	\fB\(rk\fP	\e(rk	right center of big curly bracket
X\(bv	\fI\(bv\fP	\fB\(bv\fP	\e(bv	bold vertical
X\(lf	\fI\(lf\fP	\fB\(lf\fP	\e(lf	left floor (left bottom of big square bracket)
X\(rf	\fI\(rf\fP	\fB\(rf\fP	\e(rf	right floor (right bottom)
X\(lc	\fI\(lc\fP	\fB\(lc\fP	\e(lc	left ceiling (left top)
X\(rc	\fI\(rc\fP	\fB\(rc\fP	\e(rc	right ceiling (right top)
X\fR
XThe usual suspects:
X\fR
X  ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
X@ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \e ] ^ _
X` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~
X\fI
X  ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
X@ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \e ] ^ _
X` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~
X\fB
X  ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
X@ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \e ] ^ _
X` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~
X\fR
X\s8 \
X\b'\(br\(br\(br' \b'\(bv\(bv\(bv' \
X\b'\(lc\(lf' \b'\(rc\(rf' \b'\(lt\(lb' \b'\(rt\(rb' \
X\b'\(lc\(bv\(lf' \b'\(lt\(lk\(lb' \b'\(lt\(bv\(lb' \
X\b'\(rc\(bv\(rf' \b'\(rt\(rk\(rb' \b'\(rt\(bv\(rb' \
X\s0 \
X\s10 \
X\b'\(br\(br\(br' \b'\(bv\(bv\(bv' \
X\b'\(lc\(lf' \b'\(rc\(rf' \b'\(lt\(lb' \b'\(rt\(rb' \
X\b'\(lc\(bv\(lf' \b'\(lt\(lk\(lb' \b'\(lt\(bv\(lb' \
X\b'\(rc\(bv\(rf' \b'\(rt\(rk\(rb' \b'\(rt\(bv\(rb' \
X\s0 \
X\s12 \
X\b'\(br\(br\(br' \b'\(bv\(bv\(bv' \
X\b'\(lc\(lf' \b'\(rc\(rf' \b'\(lt\(lb' \b'\(rt\(rb' \
X\b'\(lc\(bv\(lf' \b'\(lt\(lk\(lb' \b'\(lt\(bv\(lb' \
X\b'\(rc\(bv\(rf' \b'\(rt\(rk\(rb' \b'\(rt\(bv\(rb' \
X\s0 \
X\(em8, 10, & 12 brackets
X
X.ps 8
X.vs 8
X8/8 root ens, uls, and rus: X_X_X_ a\(rua\(rua\(ru \(sr\(rn \(br\z\(rn_\(br
X8/8 root ens, uls, and rus: \(rnX\(rnX\(rnX
X.ps
X.vs
X
X.ps 10
X.vs 10
X10/10 root ens, uls, and rus: X_X_X_ a\(rua\(rua\(ru \(sr\(rn \(br\z\(rn_\(br
X10/10 root ens, uls, and rus: \(rnX\(rnX\(rnX
X.ps
X.vs
X
X.ps 12
X.vs 12
X12/12 root ens, uls, and rus: X_X_X_ a\(rua\(rua\(ru \(sr\(rn \(br\z\(rn_\(br
X12/12 root ens, uls, and rus: \(rnX\(rnX\(rnX
X.ps
X.vs
X
X8, 10 & 12 point repeats: \
X\s8\(lh\(lh\(lh \(rh\(rh\(rh \(bs\(bs\(bs\s0 \
X\s10\(lh\(lh\(lh \(rh\(rh\(rh \(bs\(bs\(bs\s0 \
X\s12\(lh\(lh\(lh \(rh\(rh\(rh \(bs\(bs\(bs\s0
X.bp
XOverstrikes:
X.ta .6i +.6i +.6i +.6i +.6i +.6i +.6i +.6i +.6i +.6i
X		\e`A	^A	\e`E	^E	"E	^I	"I
X						\e`U	^U	-L
X		\e'Y	\e'y		,C	,c	~N	~n
X				-L	=Y
X	^a	^e	^o	^u	\e'a	\e'e	\e'o	\e'u
X	\e`a	\e`e	\e`o	\e`u	"a	"e	"o	"u
X	\e(deA	^i	/O	AE	\e(dea	\e'i	/o	ae
X	"A	\e`i	"O	"U	\e'E	"i		^O
X	\e'A	~A	~a	-D	-d	\e'I	\e`I	\e'O
X	\e`O	~O	~o			\e'U	"Y	"y
X	IJ	ij	Rx	Th	th	TM	..
X				<<		>>
X	/L	/l	OE	oe
X\fR		\o|\`A|	\o|^A|	\o|\`E|	\o|^E|	\o|"E|	\o|^I|	\o|"I|
X						\o|\`U|	\o|^U|	\o|-L|
X		\o|\'Y|	\o|\'y|		\o|,C|	\o|,c|	\o|~N|	\o|~n|
X				\o|-L|	\o|=Y|
X	\o|^a|	\o|^e|	\o|^o|	\o|^u|	\o|\'a|	\o|\'e|	\o|\'o|	\o|\'u|
X	\o|\`a|	\o|\`e|	\o|\`o|	\o|\`u|	\o|"a|	\o|"e|	\o|"o|	\o|"u|
X	\o|\(deA|	\o|^i|	\o|/O|	\o|AE|	\o|\(dea|	\o|\'i|	\o|/o|	\o|ae|
X	\o|"A|	\o|\`i|	\o|"O|	\o|"U|	\o|\'E|	\o|"i|		\o|^O|
X	\o|\'A|	\o|~A|	\o|~a|	\o|-D|	\o|-d|	\o|\'I|	\o|\`I|	\o|\'O|
X	\o|\`O|	\o|~O|	\o|~o|			\o|\'U|	\o|"Y|	\o|"y|
X	\o|IJ|	\o|ij|	\o|Rx|	\o|Th|	\o|th|	\o|TM|	\o|..|
X				\o|<<|		\o|>>|
X	\o|/L|	\o|/l|	\o|OE|	\o|oe|
X\fI		\o|\`A|	\o|^A|	\o|\`E|	\o|^E|	\o|"E|	\o|^I|	\o|"I|
X						\o|\`U|	\o|^U|	\o|-L|
X		\o|\'Y|	\o|\'y|		\o|,C|	\o|,c|	\o|~N|	\o|~n|
X				\o|-L|	\o|=Y|
X	\o|^a|	\o|^e|	\o|^o|	\o|^u|	\o|\'a|	\o|\'e|	\o|\'o|	\o|\'u|
X	\o|\`a|	\o|\`e|	\o|\`o|	\o|\`u|	\o|"a|	\o|"e|	\o|"o|	\o|"u|
X	\o|\(deA|	\o|^i|	\o|/O|	\o|AE|	\o|\(dea|	\o|\'i|	\o|/o|	\o|ae|
X	\o|"A|	\o|\`i|	\o|"O|	\o|"U|	\o|\'E|	\o|"i|		\o|^O|
X	\o|\'A|	\o|~A|	\o|~a|	\o|-D|	\o|-d|	\o|\'I|	\o|\`I|	\o|\'O|
X	\o|\`O|	\o|~O|	\o|~o|			\o|\'U|	\o|"Y|	\o|"y|
X	\o|IJ|	\o|ij|	\o|Rx|	\o|Th|	\o|th|	\o|TM|	\o|..|
X				\o|<<|		\o|>>|
X	\o|/L|	\o|/l|	\o|OE|	\o|oe|
X\fB		\o|\`A|	\o|^A|	\o|\`E|	\o|^E|	\o|"E|	\o|^I|	\o|"I|
X						\o|\`U|	\o|^U|	\o|-L|
X		\o|\'Y|	\o|\'y|		\o|,C|	\o|,c|	\o|~N|	\o|~n|
X				\o|-L|	\o|=Y|
X	\o|^a|	\o|^e|	\o|^o|	\o|^u|	\o|\'a|	\o|\'e|	\o|\'o|	\o|\'u|
X	\o|\`a|	\o|\`e|	\o|\`o|	\o|\`u|	\o|"a|	\o|"e|	\o|"o|	\o|"u|
X	\o|\(deA|	\o|^i|	\o|/O|	\o|AE|	\o|\(dea|	\o|\'i|	\o|/o|	\o|ae|
X	\o|"A|	\o|\`i|	\o|"O|	\o|"U|	\o|\'E|	\o|"i|		\o|^O|
X	\o|\'A|	\o|~A|	\o|~a|	\o|-D|	\o|-d|	\o|\'I|	\o|\`I|	\o|\'O|
X	\o|\`O|	\o|~O|	\o|~o|			\o|\'U|	\o|"Y|	\o|"y|
X	\o|IJ|	\o|ij|	\o|Rx|	\o|Th|	\o|th|	\o|TM|	\o|..|
X				\o|<<|		\o|>>|
X	\o|/L|	\o|/l|	\o|OE|	\o|oe|
X.bp
X\fR
XFont size samples:
X.vs 36
X\s6 6\s0\
X\s7 7\s0\
X\s8 8\s0\
X\s9 9\s0\
X\s10 10\s0\
X\s11 11\s0\
X\s12 12\s0\
X\s14 14\s0\
X\s16 16\s0\
X\s18 18\s0\
X\s20 20\s0\
X\s22 22\s0\
X\s24 24\s0\
X\s28 28\s0\
X\s36 36\s0
X.vs
END_OF_FILE
if test 10005 -ne `wc -c <'testfile'`; then
    echo shar: \"'testfile'\" unpacked with wrong size!
fi
# end of 'testfile'
fi
if test -f 'tlc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tlc.c'\"
else
echo shar: Extracting \"'tlc.c'\" \(36238 characters\)
sed "s/^X//" >'tlc.c' <<'END_OF_FILE'
X#include "ansic.h"
XID(elsieid, "@(#)tlc.c	4.1")
X
Xextern int		getopt();
Xextern char *		optarg;
Xextern int		optind;
X
X#ifndef BUFSIZ
X#define BUFSIZ		1024
X#endif /* !defined BUFSIZ */
X
X#ifndef MAXFILES
X#define MAXFILES	20
X#endif /* !defined MAXFILES */
X
X#ifndef NVPC
X#define NVPC		256
X#endif /* !defined NVPC */
X
X#ifndef TRUE
X#define TRUE		1
X#define FALSE		0
X#endif /* !defined TRUE */
X
X#define NPPI		72	/* Number of Points Per Inch */
X#define NCHUPI		432	/* Number of C/A/T Horizontal Units Per Inch */
X#define NCVUPI		144	/* Number of C/A/T Vertical Units Per Inch */
X#define NCWUPI		NCHUPI	/* Number of C/A/T Width table Units Per Inch */
X#define CWPS		6	/* C/A/T Width Value Point Size */
X#define DNIPP		11	/* Default Number of Inches Per Page */
X#define NI		256	/* Number of troff width table indices */
X#define MAXPS		36	/* Maxium Point Size */
X
Xstatic struct {
X	const char *	f_fontnick;
X	char *		f_in;		/* how to get into font */
X	char *		f_out;		/* how to get out of font */
X} fontdata[] = {
X	{ "R" },
X	{ "I" },
X	{ "B" },
X	{ "S" }
X};
X
X#define NFONTS	(sizeof fontdata / sizeof fontdata[0])
X
X#define fontisx(font, x) (fontdata[font].f_fontnick[0] == (x))
X#define fontisR(font) (fontisx(font, 'R'))
X#define fontisI(font) (fontisx(font, 'I'))
X#define fontisB(font) (fontisx(font, 'B'))
X#define fontisS(font) (fontisx(font, 'S'))
X
X/* Number of C/A/T Vertical Units Per Page */
X
Xstatic int		ncvupp = NCVUPI * DNIPP;
X
Xstatic float		lwupi;		/* laser width units per inch */
Xstatic float		lwps;		/* laser width point size */
Xstatic float		lcpi;		/* laser characters per inch */
X
Xstatic char *		sizes;		/* how to get into/out of sizes */
X
Xstatic char *		firsts[MAXPS + 1][NFONTS];
X					/* for first time font and size seen */
X
Xstatic int		lowvalue;
X
Xstatic char *		lowstring;
X
Xstatic char *		hormove;	/* horizontal move format */
Xstatic char *		vermove;	/* vertical move format */
Xstatic char *		enddata;	/* data to send when done */
Xstatic char *		newpage;	/* data to send for new page */
Xstatic char *		portrait;	/* to go into portrait mode */
Xstatic char *		landscape;	/* to go into landscape mode */
X
Xstatic int		verunitsperinch;/* printer vertical units per inch */
X
Xstatic int		horunitsperinch;/* printer horizontal units per inch */
X
Xstatic int		leftmargin;	/* unprintable left margin */
X
X/*
X** Per-"character" data.
X*/
X
Xtypedef struct {
X	char *	ssname;			/* symbol set name */
X	char *	inset;			/* how to get into symbol set */
X	char *	outset;			/* how to get out of symbol set */
X	char *	data;			/* character-specific data */
X	int	widths[NFONTS];		/* widths in various fonts */
X	int	lwidths[NFONTS];	/* LJ widths */
X	char	waschar;		/* explicitly-set character */
X} item;
X
Xstatic item		items[2 * NI];
X
Xstatic int		overstruck[NI];
X
Xstatic unsigned char *	overnames[2 * NI];
X
X/*
X** Internal functions.
X*/
X
Xstatic void		LJ_cput();
Xstatic void		LJ_fdput();
Xstatic void		LJ_sput();
Xstatic int		ascends();
Xstatic char *		checkcp();
Xstatic void *		checkvp();
Xstatic int		ctoi();
Xstatic int		descends();
Xstatic FILE *		dfopen();
Xstatic void		disescape();
Xstatic void		dostrike();
Xstatic void		dowidth();
Xstatic char *		ecatalloc();
Xstatic char *		ecpyalloc();
Xstatic void *		emalloc();
Xstatic int		fiswidth();
Xstatic char *		getline();
Xstatic char *		icatalloc();
Xstatic char *		icpyalloc();
Xstatic void		ifree();
Xstatic void *		imalloc();
Xstatic int		inch();
Xstatic void *		irealloc();
Xstatic int		linematch();
Xstatic void		loadinfo();
Xstatic void		loadsub();
Xstatic int		lwtocw();
Xint			main();
Xstatic const char *	namefor();
Xstatic int		nametoindex();
Xstatic int		oscode();
Xstatic int		osfind();
Xstatic int		ouch();
Xstatic const char *	scheck();
Xstatic int		splitos();
Xstatic void		swift();
Xstatic void		tameexit();
Xstatic void		wild2();
Xstatic void		wild2exit();
Xstatic void		wildexit();
Xstatic void		wildline();
Xstatic void		wildrexit();
X
X/*
X** External functions.
X*/
X
Xextern int		catsup();
Xextern const char *	fti2ntn();
Xextern int		ntn2fti();
Xextern int		ntnonr();
Xextern int		ntnons();
X
X/*
X** Messages and exits.
X*/
X
Xstatic const char *	progname;
X
Xstatic void
Xwild2(part1, part2)
Xconst char * const	part1;
Xconst char * const	part2;
X{
X	(void) fflush(stdout);
X	/*
X	** One space after the colon matches what perror does
X	** (although your typing teacher may want a second space).
X	*/
X	(void) fprintf(stderr, "\n%s: wild", progname);
X	if (part1 != NULL && *part1 != '\0')
X		(void) fprintf(stderr, " %s", part1);
X	if (part2 != NULL && *part2 != '\0')
X		(void) fprintf(stderr, " %s", part2);
X	(void) fprintf(stderr, "\n");
X}
X
Xstatic void
Xwild2exit(string1, string2)
Xconst char * const	string1;
Xconst char * const	string2;
X{
X	wild2(string1, string2);
X	exit(EXIT_FAILURE);
X	/*NOTREACHED*/
X}
X
Xstatic void
Xwildexit(string)
Xconst char * const	string;
X{
X	wild2exit(string, (char *) NULL);
X	/*NOTREACHED*/
X}
X
Xstatic void
Xwildrexit(string)
Xconst char * const	string;
X{
X	wild2exit("result from", string);
X	/*NOTREACHED*/
X}
X
Xstatic void
Xtameexit()
X{
X	exit(EXIT_SUCCESS);
X	/*NOTREACHED*/
X}
X
X/*
X** Memory allocation.
X*/
X
X#ifndef alloc_size_t
X#define alloc_size_t	unsigned
X#endif /* !defined alloc_size_t */
X
X#ifndef alloc_pointer_t
X#define alloc_pointer_t char *
X#endif /* !defined alloc_pointer_t */
X
X#ifdef MAL
X#define NULLMAL(x)	((x) == NULL || (x) == MAL)
X#else /* !defined MAL */
X#define NULLMAL(x)	((x) == NULL)
X#endif /* !defined MAL */
X
X#define nonzero(n)	(((n) == 0) ? 1 : (n))
X
Xstatic void *
Ximalloc(n)
Xint const	n;
X{
X#ifdef MAL
X	char *	result;
X
X	result = (void *) malloc((alloc_size_t) nonzero(n));
X	return NULLMAL(result) ? NULL : result;
X#else /* !defined MAL */
X	return (void *) malloc((alloc_size_t) nonzero(n));
X#endif /* !defined MAL */
X}
X
Xstatic void *
Xirealloc(pointer, size)
Xvoid * const	pointer;
Xint const	size;
X{
X	if (NULLMAL(pointer))
X		return imalloc(size);
X	return (void *) realloc((alloc_pointer_t) pointer,
X		(alloc_size_t) nonzero(size));
X}
X
Xstatic char *
Xicatalloc(old, new)
Xchar * const		old;
Xconst char * const	new;
X{
X	char *	result;
X	int	oldsize;
X	int	newsize;
X
X	newsize = NULLMAL(new) ? 0 : strlen(new);
X	if (NULLMAL(old))
X		oldsize = 0;
X	else if (newsize == 0)
X		return old;
X	else	oldsize = strlen(old);
X	result = (char *) irealloc((void *) old, oldsize + newsize + 1);
X	if (result != NULL)
X		if (NULLMAL(new))
X			*(result + oldsize) = '\0';
X		else	(void) strcpy(result + oldsize, new);
X	return result;
X}
X
Xstatic char *
Xicpyalloc(string)
Xconst char * const	string;
X{
X	return icatalloc((char *) NULL, string);
X}
X
Xstatic void
Xifree(p)
Xvoid * const	p;
X{
X	if (!NULLMAL(p))
X#ifdef USG
X		free((alloc_pointer_t) p);
X#endif /* defined USG */
X#ifndef USG
X		(void) free((alloc_pointer_t) p);
X#endif /* !defined USG */
X}
X
Xstatic void *
Xcheckvp(pointer)
Xvoid * const	pointer;
X{
X	if (pointer == NULL)
X		wildrexit("allocating memory");
X	return pointer;
X}
X
Xstatic char *
Xcheckcp(pointer)
Xchar * const	pointer;
X{
X	if (pointer == NULL)
X		wildrexit("allocating memory");
X	return pointer;
X}
X
Xstatic void *
Xemalloc(size)
Xint const	size;
X{
X	return checkvp(imalloc(size));
X}
X
Xstatic char *
Xecatalloc(old, new)
Xchar * const		old;
Xconst char * const	new;
X{
X	return checkcp(icatalloc(old, new));
X}
X
Xstatic char *
Xecpyalloc(string)
Xconst char * const	string;
X{
X	return checkcp(icpyalloc(string));
X}
X
X/*
X** Check a format against a string...
X*/
X
Xstatic const char *
Xscheck(string, format)
Xconst char * const	string;
Xconst char * const	format;
X{
X	char *		fbuf;
X	const char *	fp;
X	char *		tp;
X	int		c;
X	const char *	result;
X	char			dummy;
X
X	result = "";
X	if (string == NULL || format == NULL)
X		return result;
X	/*
X	** Check for stupid systems that let "9e" match "%f".
X	** We only do the easy cases here.
X	*/
X	{
X		int	i;
X
X		i = strlen(format);
X		if (i >= 2 && strcmp(&format[i - 2], "%f") == 0) {
X			i = strlen(string);
X			if (i > 0 &&
X				strchr("0123456789", string[i - 1]) == NULL)
X					return result;
X		}
X	}
X	fbuf = (char *) imalloc(2 * strlen(format) + 4);
X	if (fbuf == NULL)
X		return result;
X	fp = format;
X	tp = fbuf;
X	while ((*tp++ = c = *fp++) != '\0') {
X		if (c != '%')
X			continue;
X		if (*fp == '%') {
X			*tp++ = *fp++;
X			continue;
X		}
X		*tp++ = '*';
X		if (*fp == '*')
X			++fp;
X		while (isascii(*fp) && isdigit(*fp))
X			*tp++ = *fp++;
X		if (*fp == 'l' || *fp == 'h')
X			*tp++ = *fp++;
X		else if (*fp == '[')
X			do {
X				*tp++ = *fp++;
X			} while (*fp != '\0' && *fp != ']');
X		if ((*tp++ = *fp++) == '\0')
X			break;
X	}
X	*(tp - 1) = '%';
X	*tp++ = 'c';
X	*tp = '\0';
X	if (sscanf(string, fbuf, &dummy) != 1)
X		result = format;
X	ifree((void *) fbuf);
X	return result;
X}
X
X/*
X** Get [nt]roff names from a file.
X*/
X
Xstatic const char *	sfilename;
Xstatic int		slinenum;
X
Xstatic void
Xoops(string)
Xconst char * const	string;
X{
X	char	line[132];
X
X	(void) sprintf(line, "file \"%s\", line %d: %s\n",
X		((sfilename == NULL) ? NULL : sfilename), slinenum, string);
X	wildexit(line);
X}
X
Xstatic void
Xgetnames(filename, names)
Xconst char * const	filename;
Xchar ** const		names;
X{
X	FILE *	fp;
X	char *	cp;
X	char *	dp;
X	int	i;
X	int	online;
X	char		line[132];
X
X	sfilename = filename;
X	slinenum = 0;
X	if (names == NULL)
X		oops("NULL names argument");
X	if (filename == NULL)
X		oops("NULL filename argument");
X	if ((fp = fopen(filename, "r")) == NULL) {
X		cp = ecpyalloc(filename);
X		cp = ecatalloc(cp, ".M");
X		fp = fopen(cp, "r");
X		free(cp);
X		if (fp == NULL)
X			oops("can't open file");
X	}
X	i = 0;
X	while (fgets(line, sizeof line, fp) == line) {
X		++slinenum;
X		if ((cp = strchr(line, '\n')) == NULL)
X			oops("line is too long");
X		*cp = '\t';	/* means all fields are tab terminated */
X		for (cp = line; *cp != '\0'; ++cp)
X			if (!isascii(*cp))
X				oops("non-ASCII character in line");
X		cp = line;
X		if (*cp == '#' || *cp == '\0')
X			continue;
X		if (i >= NVPC)
X			oops("too many lines in input");
X		if (!isspace(*cp))
X			oops("data line does not begin with space");
X		for (online = 0; online < 8; ++online) {
X			while (*cp != '\0' && isspace(*cp))
X				++cp;
X			dp = cp;
X			while (*dp != '\0' && !isspace(*dp))
X				++dp;
X			if (dp == NULL)
X				oops("too few fields on line");
X			*dp = '\0';
X			names[i++] = (strcmp(cp, "NULL") == 0) ? NULL :
X				ecpyalloc(cp);
X			cp = dp + 1;
X		}
X		while (isspace(*cp))
X			++cp;
X		if (*cp != '\0')
X			oops("wrong number of fields on line");
X	}
X	if (!feof(fp) || ferror(fp))
X		oops("wild result reading file");
X	if (fclose(fp)) {
X		fp = NULL;
X		oops("wild result closing file");
X	}
X	for ( ; i < NVPC; ++i)
X		names[i] = NULL;
X}
X
X/*
X** And now the real work begins...
X*/
X
Xstatic int
Xfiswidth(font, fti, size)
Xint const	font;
Xint const	fti;
Xint const	size;
X{
X	int	w;
X	int	result;
X
X	w = items[fti].widths[font];
X	result = w * size / CWPS;
X	if (((w * size) % CWPS) >= (CWPS / 2))
X		++result;
X	return result;
X}
X
Xstatic int		vflag;
Xstatic int		wflag;
Xstatic int		xynh;
X
Xstatic int
Xinch()
X{
X	return getchar();
X}
X
Xtypedef struct {
X	int	fti;
X	long	hor;
X	long	ver;
X	int	font;
X	int	size;
X} strike;
X
Xstatic int
Xosfind(a, b)
Xint const	a;
Xint const	b;
X{
X	unsigned char *	ucp;
X	int			i;
X
X	for (i = NI; ; ++i) {
X		ucp = (unsigned char *) overnames[i];
X		if (ucp == NULL || *ucp == '\0')
X			return 0;
X		if (*ucp == a && *(ucp + 1) == b)
X			return i;
X		if (*ucp == b && *(ucp + 1) == a)
X			return i;
X	}
X}
X
Xstatic int
Xoscode(one, two)
Xstrike	one;
Xstrike	two;
X{
X	strike	three;	/* You're out! */
X
X	if (one.ver != two.ver || one.size != two.size)
X		return 0;
X	if (one.font != two.font && !fontisS(one.font) && !fontisS(two.font))
X		return 0;
X	if (!overstruck[one.fti] || !overstruck[two.fti])
X		return 0;
X	if (one.fti == two.fti && one.hor != two.hor)
X		return 0;
X	if (one.hor > two.hor) {
X		three = one;
X		one = two;
X		two = three;
X	}
X	if ((two.hor - one.hor) >= fiswidth(one.font, one.fti, one.size) / 2)
X		return 0;
X	return osfind(one.fti, two.fti);
X}
X
Xstatic int
Xouch(charname, wchor, wcver, wsize, fontnick)
Xconst char * const	charname;
Xlong const		wchor;	/* wanted C/A/T horizontal position */
Xlong			wcver;	/* wanted C/A/T veritcal position */
Xint const		wsize;
Xchar * const		fontnick;
X{
X	int	wfont;
X	int	fti;
X	int	i;
X	strike		s;
X	static strike	ss = { 0, -1, -1, -1, -1 };
X
X	fti = ntn2fti(charname);
X	wcver -= 31;
X	s.fti = fti;
X	s.hor = wchor;
X	s.ver = wcver;
X	for (wfont = 0; ; ++wfont) {
X		if (wfont == NFONTS)
X			wild2exit("font -", fontnick);
X		if (strcmp(fontnick, fontdata[wfont].f_fontnick) == 0)
X			break;
X	}
X	s.font = wfont;
X	s.size = wsize;
X	if ((i = oscode(s, ss)) > 0) {
X		if (s.hor > ss.hor)
X			s.hor = ss.hor;
X		if (fontisS(s.font))
X			s.font = ss.font;
X		s.fti = i;
X		dostrike(s);
X		ss.fti = 0;
X	} else {
X		if (ss.ver != s.ver ||
X			(s.hor - ss.hor) >=
X			fiswidth(ss.font, ss.fti, ss.size) / 2) {
X				dostrike(ss);
X				ss.fti = 0;
X		}
X		if (!overstruck[fti]) {
X			dostrike(s);
X		} else {
X			dostrike(ss);
X			ss = s;
X		}
X	}
X	return 0;
X}
X
Xstatic const char *	cartridge;
X
Xint
Xmain(argc, argv)
Xint	argc;
Xchar *	argv[];
X{
X	int	c;
X	int	nargs;
X
X	if ((progname = strrchr(argv[0], '/')) == NULL)
X		progname = argv[0];
X	else	++progname;
X	while ((c = getopt(argc, argv, "vwx:y:n:h:")) != EOF)
X		if (c == 'x' || c == 'y' || c == 'n' || c == 'h')
X			xynh = TRUE;
X		else if (c == 'v')
X			vflag = TRUE;
X		else if (c == 'w')
X			wflag = TRUE;
X		else	break;
X	nargs = argc - optind;
X	if (c != EOF ||
X	    (vflag && !wflag) ||
X	    nargs != (xynh ? 0 : 1) ||
X	    (nargs == 1 && strcmp(argv[optind], "=") == 0)) {
X		(void) fprintf(stderr,
X			"%s: usage is %s [-wv] fontdir < file\n",
X			progname, progname);
X		if (nargs == 1 && strcmp(argv[optind], "=") == 0)
X			tameexit();
X		else	wildexit("usage");
X	}
X	if (!wflag)
X		if ((c = getchar()) == EOF)
X			tameexit();
X		else	(void) ungetc(c, stdin);
X	if (nargs == 1)
X		cartridge = argv[optind];
X	else {
X		FILE *	fp;
X		char *	cp;
X		static char	buf[132];
X
X		fp = fopen(".railmag", "r");
X		if (fp == NULL)
X			wildrexit("opening .railmag");
X		if (fgets(buf, sizeof buf, fp) != buf)
X			wildrexit("reading .railmag");
X		if (strchr(buf, '\n') == NULL)
X			wildexit("missing newline in .railmag");
X		if ((cp = strrchr(buf, '/')) == NULL)
X			wildexit("missing / in .railmag");
X		if (fclose(fp))
X			wildrexit("closing .railmag");
X		*cp = '\0';
X		/*
X		** Horrid special case.
X		** Maybe should check that directory exists.
X		*/
X		if (strcmp(buf, "/usr/lib/vfont") == 0) {
X			(void) strcpy(buf, DATADIR);
X			(void) strcat(buf, "/default");
X		}
X		cartridge = buf;
X	}
X	loadinfo();
X	if (wflag) {
X		dowidth();
X		tameexit();
X	}
X	if (catsup(inch, ouch, TRUE, FALSE) != 0)
X		wildrexit("catsup");
X	(void) ouch("", 0L, 0L, 0, "R");	/* to flush */
X	if (!feof(stdin) || ferror(stdin))
X		wildrexit("reading standard input");
X	LJ_sput(enddata);
X	if (ferror(stdout))
X		wildrexit("writing");
X	return 0;
X}
X
X/*
X** Convert laser width table units to C/A/T width table units
X*/
X
Xstatic int
Xlwtocw(fti, font, lw)
Xint const	fti;
Xint const	font;
Xint const	lw;
X{
X	int	cw;
X	long	num;
X	long	den;
X	static int	prevind;
X
X	num = (long) lw * NCWUPI * CWPS;
X	den = lwupi * lwps;
X	cw = num / den;
X	/*
X	** Selectively round to ensure that rules meet.
X	*/
X	if (isascii(fti) && isprint(fti) && fti != '_')
X		if ((num % den) >= (den / 2))
X			++cw;
X	if (cw > 077) {
X		if (wflag && fti != prevind) {
X			(void) fprintf(stderr,
X"%s: note: char %s, font %s in %s too wide (%d, %d)\n",
X				progname, fti2ntn(fti),
X				fontdata[font].f_fontnick, cartridge, lw, cw);
X			prevind = fti;
X		}
X		cw = 077;
X	}
X	return cw;
X}
X
Xstatic char *	filenames[MAXFILES];
Xstatic long	linenums[MAXFILES];
Xstatic int	lastfid;
X
Xstatic void
Xwildline(message)
Xconst char * const	message;
X{
X	char *	filename;
X	long	linenum;
X
X	if (lastfid >= 0 && lastfid < MAXFILES) {
X		filename = filenames[lastfid];
X		linenum = linenums[lastfid];
X	} else {
X		filename = NULL;
X		linenum = -1;
X	}
X	(void) fprintf(stderr, "%s: ", progname);
X	if (filename == NULL)
X		(void) fprintf(stderr, "file UNKNOWN, ");
X	else	(void) fprintf(stderr, "file \"%s\", ", filename);
X	(void) fprintf(stderr, "line %ld: ", linenum);
X	(void) fprintf(stderr, "wild %s\n",
X		((message == NULL) ? "line" : message));
X	wildexit("information file");
X}
X
Xstatic int
Xctoi(c)
Xint const	c;
X{
X	const char *	cp;
X	static const char	digits[] = "0123456789";
X
X	cp = strchr(digits, c);
X	return (cp == NULL) ? -1 : (cp - digits);
X}
X
Xstatic void
Xdisescape(cp)
Xchar * const	cp;
X{
X	const char *	fromp;
X	char *		top;
X	int		c;
X	int		i;
X	int		j;
X
X	fromp = top = cp;
X	while ((c = *fromp++) != '\0')
X		if (c != '\\')
X			*top++ = c;
X		else switch ((c = *fromp++)) {
X			case '\0':	--fromp; *top++ = '\\';	break;
X			case 'E':	*top++ = '\033';	break;
X			case 'b':	*top++ = '\b';		break;
X			case 'f':	*top++ = '\f';		break;
X			case 'n':	*top++ = '\n';		break;
X			case 'r':	*top++ = '\r';		break;
X			case 't':	*top++ = '\t';		break;
X			case 'v':	*top++ = '\v';		break;
X			default:
X				i = ctoi(c);
X				if (i < 0 || i > 7) {
X					*top++ = c;
X					break;
X				}
X				if ((j = ctoi(*fromp)) >= 0 && j <= 7) {
X					++fromp;
X					i = i * 8 + j;
X					if ((j = ctoi(*fromp)) >= 0 && j <= 7) {
X						++fromp;
X						i = i * 8 + j;
X					}
X				}
X				*top++ = i;
X				break;
X		}
X	*top = '\0';
X}
X
Xstatic FILE *
Xdfopen(filename, mode, must)
Xconst char * const	filename;
Xconst char * const	mode;
Xint const		must;
X{
X	FILE *	fp;
X	char *	cp;
X	char *	dp;
X	int	fid;
X	int	pass;
X
X	dp = ecpyalloc(cartridge);
X	for (pass = 1; pass <= 2; ++pass) {
X		if (pass == 2)
X			if ((cp = strrchr(dp, '/')) == NULL)
X				(void) strcpy(dp, ".");
X			else	*cp = '\0';
X		cp = ecpyalloc(dp);
X		cp = ecatalloc(cp, "/");
X		cp = ecatalloc(cp, filename);
X		fp = fopen(cp, mode);
X		if (fp == NULL) {
X			free(cp);
X			continue;
X		}
X		fid = fileno(fp);
X		if (fid < 0)
X			wildexit("negative file descriptor!?");
X		if (fid >= MAXFILES)
X			wildexit("large number of files opened");
X		if (filenames[fid] != NULL)
X			free(filenames[fid]);
X		filenames[fid] = cp;
X		linenums[fid] = 0;
X		free(dp);
X		return fp;
X	}
X	free(dp);
X	if (must)
X		wild2exit("result opening file", filename);
X	return NULL;
X}
X
Xstatic const char *
Xnamefor(fp)
XFILE * const	fp;
X{
X	int			fid;
X	static const char	unknown[] = "UNKNOWN";
X
X	if (fp != NULL) {
X		fid = fileno(fp);
X		if (fid >= 0 && fid < MAXFILES && filenames[fid] != NULL)
X			return filenames[fid];
X	}
X	return unknown;
X}
X
Xstatic char *
Xgetline(fp)
XFILE * const	fp;
X{
X	char *	cp;
X	char *	dp;
X	static char	line[BUFSIZ];
X
X	lastfid = fileno(fp);
X	for ( ; ; ) {
X		if (fgets(line, sizeof line, fp) != line) {
X			if (ferror(fp) || !feof(fp))
X				wildline("result from reading");
X			if (fclose(fp))
X				wildline("result from closing");
X			return NULL;
X		}
X		++linenums[(int) fileno(fp)];
X		cp = strchr(line, '\n');
X		if (cp == NULL)
X			wildline("long line");
X		*cp = '\0';
X		/*
X		** Strip comments and trailing space.
X		*/
X		dp = NULL;
X		for (cp = line; *cp != '\0'; ++cp)
X			if (*cp == '#') {
X				*cp = '\0';
X				break;
X			} else if (isascii(*cp) && isspace(*cp)) {
X				if (dp == NULL)
X					dp = cp;
X			} else {
X				dp = NULL;
X				if (*cp == '\\') {
X					if (*++cp == '\0')
X						break;
X				}
X			}
X		if (dp != NULL)
X			*dp = '\0';
X		/*
X		** If we've got something. . .
X		*/
X		if (line[0] != '\0')
X			return line;
X	}
X}
X
Xstatic int
Xsplitos(name, vals)
Xchar * const	name;
Xint		vals[2];
X{
X	char *	cp;
X	int	left;
X	int	right;
X	int	n;
X	int	c;
X
X	if (name == NULL || *name == '\0')
X		return -1;
X	n = 0;
X	for (cp = name + 1; *cp != '\0'; ++cp) {
X		if ((right = ntn2fti(cp)) <= 0)
X			continue;
X		c = *cp;
X		*cp = '\0';
X		left = ntn2fti(name);
X		*cp = c;
X		if (left <= 0)
X			continue;
X		if (++n > 1)
X			return -1;
X		vals[0] = left;
X		vals[1] = right;
X	}
X	return (n == 1) ? 0 : -1;
X}
X
Xstatic int
Xnametoindex(name)
Xconst char * const	name;
X{
X	int		fti;
X	int		vals[2];
X	static int	oi = NI;
X
X	if ((fti = ntn2fti(name)) > 0)
X		return fti;
X	/*
X	** Overstrike mapping?
X	*/
X	if (splitos(name, vals) != 0) {
X		char	minibuf[132];
X
X		(void) sprintf(minibuf, "character name--\"%s\"", name);
X		wildline(minibuf);
X	}
X	if ((fti = osfind(vals[0], vals[1])) > 0)
X		return fti;
X	if (oi >= sizeof items / sizeof items[0])
X		wildline("large number of overstrikes");
X	overstruck[vals[0]] = TRUE;
X	overstruck[vals[1]] = TRUE;
X	overnames[oi] = (unsigned char *) emalloc(3);
X	overnames[oi][0] = vals[0];
X	overnames[oi][1] = vals[1];
X	overnames[oi][2] = 0;
X	return oi++;
X}
X
Xstatic int
Xlinematch(havetype, havecount, wanttype, wantlo, wanthi)
Xconst char * const	havetype;
Xint const		havecount;
Xconst char * const	wanttype;
Xint const		wantlo;
Xint const		wanthi;
X{
X	if (strcmp(havetype, wanttype) != 0)
X		return FALSE;
X	if (havecount < wantlo || havecount > wanthi)
X		wildline("number of fields");
X	return TRUE;
X}
X
Xstatic void
Xloadsub(filename)
Xconst char * const	filename;
X{
X	FILE *	fp;
X	char *	line;
X	item *	ip;
X	int	fti;
X	int	i;
X	int	n;
X	int	font;
X	int	width;
X	int		size;
X	char		t[BUFSIZ];
X	char		f[9][BUFSIZ];
X
X	fp = dfopen(filename, "r", TRUE);
X	for (i = 0; i < 9; ++i)
X		f[i][0] = '\0';
X	while ((line = getline(fp)) != NULL) {
X		n = sscanf(line, "%s %s %s %s %s %s %s %s",
X			t, f[2], f[3], f[4],
X			f[5], f[6], f[7], f[8]);
X		for (i = 2; i <= n; ++i)
X			disescape(f[i]);
X		/*
X		** NEWPAGE data
X		*/
X		if (linematch(t, n, "NEWPAGE", 2, 2)) {
X			newpage = ecpyalloc(f[2]);
X			continue;
X		}
X		/*
X		** PORTRAIT data
X		*/
X		if (linematch(t, n, "PORTRAIT", 2, 2)) {
X			portrait = ecpyalloc(f[2]);
X			continue;
X		}
X		/*
X		** LANDSCAPE data
X		*/
X		if (linematch(t, n, "LANDSCAPE", 2, 2)) {
X			landscape = ecpyalloc(f[2]);
X			continue;
X		}
X		/*
X		** DOWNORIENT--always portrait for now.
X		*/
X		if (linematch(t, n, "DOWNORIENT", 1, 1)) {
X			LJ_sput(portrait);
X			continue;
X		}
X		/*
X		** LEFTMARGIN size
X		*/
X		if (linematch(t, n, "LEFTMARGIN", 2, 2)) {
X			if (sscanf(f[2], scheck(f[2], "%d"),
X				&leftmargin) != 1 || leftmargin < 0)
X					wildline("left margin");
X			continue;
X		}
X		/*
X		** WIDTHUNITSPERINCH size
X		*/
X		if (linematch(t, n, "WIDTHUNITSPERINCH", 2, 2)) {
X			if (sscanf(f[2], scheck(f[2], "%f"), &lwupi) != 1 ||
X				lwupi <= 0)
X					wildline("width units per inch");
X			continue;
X		}
X		/*
X		** WIDTHPOINTSIZE size
X		*/
X		if (linematch(t, n, "WIDTHPOINTSIZE", 2, 2)) {
X			if (sscanf(f[2], scheck(f[2], "%f"), &lwps) != 1 ||
X				lwps <= 0)
X					wildline("width point size");
X			continue;
X		}
X		/*
X		** LOWCHAR value string
X		*/
X		if (linematch(t, n, "LOWCHAR", 3, 3)) {
X			if (sscanf(f[2], scheck(f[2], "%d"), &lowvalue) != 1 ||
X				lowvalue <= 0)
X					wildline("low value");
X			lowstring = ecpyalloc(f[3]);
X			continue;
X		}
X		/*
X		** CPI size
X		*/
X		if (linematch(t, n, "CPI", 2, 2)) {
X			if (sscanf(f[2], scheck(f[2], "%f"), &lcpi) != 1 ||
X				lcpi <= 0)
X					wildline("CPI");
X			continue;
X		}
X		/*
X		** INCLUDE filename
X		*/
X		if (linematch(t, n, "INCLUDE", 2, 2)) {
X			loadsub(f[2]);
X			continue;
X		}
X		/*
X		** DOWNDATA data
X		*/
X		if (linematch(t, n, "DOWNDATA", 2, 2)) {
X			LJ_sput(f[2]);
X			continue;
X		}
X		/*
X		** ENDDATA data
X		*/
X		if (linematch(t, n, "ENDDATA", 2, 2)) {
X			enddata = ecpyalloc(f[2]);
X			continue;
X		}
X		/*
X		** DOWNFILE filename
X		*/
X		if (linematch(t, n, "DOWNFILE", 2, 2)) {
X			FILE *	dfp;
X			char *	cp;
X			int	c;
X
X			cp = ecpyalloc(f[2]);
X			cp = ecatalloc(cp, ".D");
X			dfp = dfopen(cp, "r", TRUE);
X			free(cp);
X			while ((c = getc(dfp)) != EOF)
X				LJ_cput(c);
X			if (ferror(dfp) || !feof(dfp) || fclose(dfp))
X				wildline("result from downloading");
X			continue;
X		}
X		/*
X		** FORGET charname
X		*/
X		if (linematch(t, n, "FORGET", 2, 2)) {
X			fti = nametoindex(f[2]);
X			ip = &items[fti];
X			ip->ssname = ip->inset =
X				ip->outset = ip->data = NULL;
X			ip->waschar = FALSE;
X			continue;
X		}
X		/*
X		** UNITSPERINCH horizontal vertical
X		*/
X		if (linematch(t, n, "UNITSPERINCH", 3, 3)) {
X			int	hupi;
X			int	vupi;
X
X			if (sscanf(f[2], scheck(f[2], "%d"),
X				&hupi) != 1 ||
X				hupi <= 0)
X					wildline("horizontal UNITSPERINCH");
X			if (sscanf(f[2], scheck(f[2], "%d"),
X				&vupi) != 1 ||
X				vupi <= 0)
X					wildline("vertical UNITSPERINCH");
X			if (horunitsperinch != 0 &&
X				(horunitsperinch != hupi ||
X				verunitsperinch != vupi))
X					wildline("repeated UNITSPERINCH");
X			horunitsperinch = hupi;
X			verunitsperinch = vupi;
X			continue;
X		}
X		/*
X		** MOVES horizontal-move vertical-move
X		*/
X		if (linematch(t, n, "MOVES", 3, 3)) {
X			hormove = ecpyalloc(f[2]);
X			vermove = ecpyalloc(f[3]);
X			continue;
X		}
X		/*
X		** FONT name in	out
X		*/
X		if (linematch(t, n, "FONT", 4, 4)) {
X			for (font = 0; font < NFONTS; ++font) {
X				if (strcmp(f[2],
X					fontdata[font].f_fontnick) != 0)
X						continue;
X				fontdata[font].f_in = ecpyalloc(f[3]);
X				fontdata[font].f_out = ecpyalloc(f[4]);
X				break;
X			}
X			if (font == NFONTS)
X				wildline("unknown font name");
X			continue;
X		}
X		/*
X		** SIZES in
X		*/
X		if (linematch(t, n, "SIZES", 2, 2)) {
X			sizes = ecatalloc(sizes, f[2]);
X			continue;
X		}
X		/*
X		** FIRST pointsize font in
X		*/
X		if (linematch(t, n, "FIRST", 4, 4)) {
X			if (sscanf(f[2], scheck(f[2], "%d"), &size) != 1 ||
X				size < 0 ||
X				size >= sizeof firsts / sizeof firsts[0])
X					wildline("size");
X			for (i = 0; ; ++i) {
X				if (i >= NFONTS)
X					wildline("font");
X				if (strcmp(f[3], fontdata[i].f_fontnick) != 0)
X					continue;
X				firsts[size][i] = ecatalloc(firsts[size][i],
X					f[4]);
X				break;
X			}
X			continue;
X		}
X		/*
X		** Need width for rest.
X		*/
X		if (lwupi == 0)
X			wildline("missing WIDTHUNITSPERINCH line");
X		if (lwps == 0)
X			wildline("missing WIDTHPOINTSIZE line");
X		if (horunitsperinch == 0 || verunitsperinch == 0)
X			wildline("missing UNITSPERINCH line");
X		/*
X		** SYMBOLS filename [in [out]]
X		** If cpi != 0 and there's no width file,
X		** all widths are set to lwupi / lcpi.
X		*/
X		if (linematch(t, n, "SYMBOLS", 2, 4)) {
X			FILE *		sfp;
X			const char *	cp;
X			char *		template;
X			char *		names[NI];
X			char *		rwidths[NI];
X			char *		iwidths[NI];
X			char *		bwidths[NI];
X			int		didr;
X			int		didib;
X			char *		ssname;
X			char *		inset;
X			char *		outset;
X
X			ssname = ecpyalloc(f[2]);
X			inset = (n <= 2) ? NULL : ecpyalloc(f[3]);
X			outset = (n <= 3) ? NULL : ecpyalloc(f[4]);
X			template = ecpyalloc(ssname);
X			template = ecatalloc(template, ".X");
X			template[strlen(template) - 1] = 'M';
X			sfp = dfopen(template, "r", TRUE);
X			cp = namefor(sfp);
X			(void) fclose(sfp);
X			getnames(cp, names);
X			template[strlen(template) - 1] = 'R';
X			sfp = dfopen(template, "r", lcpi == 0);
X			didib = FALSE;
X			if (sfp == NULL)
X				didr = FALSE;
X			else {
X				didr = TRUE;
X				cp = namefor(sfp);
X				(void) fclose(sfp);
X				getnames(cp, rwidths);
X
X				template[strlen(template) - 1] = 'I';
X				sfp = dfopen(template, "r", FALSE);
X				if (sfp != NULL) {
X					didib = TRUE;
X					cp = namefor(sfp);
X					(void) fclose(sfp);
X					getnames(cp, iwidths);
X
X					template[strlen(template) - 1] = 'B';
X					sfp = dfopen(template, "r", TRUE);
X					cp = namefor(sfp);
X					(void) fclose(sfp);
X					getnames(cp, bwidths);
X				}
X			}
X			for (i = 0; i < NI; ++i) {
X				if (names[i] == NULL)
X					continue;
X				fti = nametoindex(names[i]);
X				ip = &items[fti];
X				if (ip->ssname != NULL)
X					continue;
X				ip->ssname = ssname;
X				ip->inset = inset;
X				ip->outset = outset;
X				ip->data = emalloc(2);
X				ip->data[0] = i;
X				ip->data[1] = '\0';
X				for (font = 0; font < NFONTS; ++font) {
X					if (!didr)
X						width = lwupi / lcpi;
X					else {
X						cp = rwidths[i];
X						if (didib)
X							if (fontisB(font))
X								cp = bwidths[i];
X							else if (fontisI(font))
X								cp = iwidths[i];
X						if (cp == NULL)
X							width = 0;
X						else	width = atoi(cp);
X					}
X					ip->lwidths[font] = width;
X					ip->widths[font] = lwtocw(i, font,
X						width);
X				}
X			}
X			continue;
X		}
X		/*
X		** And last but not least. . .
X		** CHAR charname symbolset data [wideas offset]
X		*/
X		if (linematch(t, n, "CHAR", 4, 6)) {
X			char *	cp;
X			int		off;
X
X			if (n < 6)
X				off = 0;
X			else if (sscanf(f[6], scheck(f[6], "%d"), &off) != 1)
X				wildline("offset");
X			fti = nametoindex(f[2]);
X			ip = &items[fti];
X			if (n == 4 && ip->ssname == NULL &&
X				strcmp(f[2], "br") != 0)
X					wildline("missing width w/o old width");
X			if (ip->waschar)
X				wildline("multiple lines for same CHAR");
X			ip->waschar = TRUE;
X			for (i = 0; i < NI; ++i) {
X				item *	jp;
X
X				jp = &items[i];
X				if (jp->ssname != NULL &&
X					strcmp(jp->ssname, f[3]) == 0)
X						break;
X			}
X			if (i >= NI)
X				wildline("CHAR symbol set");
X			ip->ssname = items[i].ssname;
X			ip->inset = items[i].inset;
X			ip->outset = items[i].outset;
X			ip->data = ecpyalloc(f[4]);
X			if (n == 4)
X				continue;
X			for (font = 0; font < NFONTS; ++font) {
X				int	w;
X
X				w = off;
X				for (cp = f[5]; *cp != '\0'; ++cp) {
X					if (items[(int) *cp].ssname == NULL)
X						wildline("'wide as' string");
X					w += items[(int) *cp].lwidths[font];
X				}
X				ip->lwidths[font] = w;
X				ip->widths[font] = lwtocw(fti, font, w);
X			}
X			continue;
X		}
X		wildline("line of unknown type");
X	}
X}
X
Xstatic void
Xloadinfo()
X{
X	item *	ip;
X	int	i;
X	int	j;
X	int	font;
X
X	loadsub("table");
X	if (hormove == NULL || vermove == NULL)
X		wildexit("missing MOVES line in table");
X	/*
X	** Characters with multiple width table indices
X	*/
X	i = ntn2fti("ul");
X	j = '_';
X	if (items[i].ssname == NULL)
X		items[i] = items[j];
X	else if (items[j].ssname == NULL)
X		items[j] = items[i];
X	i = ntn2fti("hy");
X	j = '-';
X	if (items[i].ssname == NULL)
X		items[i] = items[j];
X	else if (items[j].ssname == NULL)
X		items[j] = items[i];
X	/*
X	** Overstrike widths.
X	*/
X	for (i = NI; overnames[i] != NULL && overnames[i][0] != '\0'; ++i) {
X		ip = &items[overnames[i][0]];
X		for (font = 0; font < NFONTS; ++font)
X			items[i].widths[font] = ip->widths[font];
X		ip = &items[overnames[i][1]];
X		for (font = 0; font < NFONTS; ++font)
X			if (ip->widths[font] > items[i].widths[font])
X				items[i].widths[font] = ip->widths[font];
X	}
X	if (!vflag)
X		return;
X	(void) printf("CHAR[S]\tSYMBOLSET  %c%c%c%c WIDTHS    DATA\n",
X		*fontdata[0].f_fontnick, *fontdata[1].f_fontnick,
X		*fontdata[2].f_fontnick, *fontdata[3].f_fontnick);
X	for (i = 0;
X	    i < NI || (overnames[i] != NULL && overnames[i][0] != '\0');
X	    ++i) {
X		ip = &items[i];
X		if (ip->ssname == NULL)
X			continue;
X		if (i < NI)
X			(void) printf("%s", fti2ntn(i));
X		else	(void) printf("%s %s", fti2ntn((int) overnames[i][0]),
X				fti2ntn((int) overnames[i][1]));
X		(void) printf("\t%-9s", ip->ssname);
X		for (font = 0; font < NFONTS; ++font)
X			(void) printf("%4d", ip->widths[font]);
X		(void) printf(" ");
X		for (j = 0; ip->data[j] != '\0'; ++j) {
X			int	c;
X
X			c = ip->data[j];
X			if (isascii(c) && isprint(c) && c != ' ')
X				(void) putchar(c);
X			else if (c == '\033')
X				(void) printf("\\E");
X			else	(void) printf("\\%03o", (unsigned char) c);
X		}
X		(void) printf("\n");
X	}
X}
X
Xstatic void
XLJ_cput(c)
Xint const	c;
X{
X	if (!wflag)
X		(void) putchar(c);
X}
X
Xstatic void
XLJ_sput(s)
Xconst char *	s;
X{
X	int	c;
X
X	if (s == NULL)
X		return;
X	while ((c = *s++) != '\0')
X		LJ_cput(c);
X}
X
Xstatic void
XLJ_fdput(f, d)
Xconst char * const	f;
Xint const		d;
X{
X/*
X** 302 / 1000 is log10(2.0) rounded up.
X** Subtract one for the sign bit;
X** add one for integer division truncation;
X** add one more for a minus sign.
X*/
X#define INT_STRLEN_MAXIMUM(type) \
X	((sizeof(type) * CHAR_BIT - 1) * 302 / 1000 + 2)
X
X	static char *	buf;
X	static int	bufsize;
X	int		wantsize;
X
X	wantsize = strlen(f) + INT_STRLEN_MAXIMUM(int) + 1;
X	if (wantsize > bufsize) {
X		ifree(buf);
X		buf = emalloc(wantsize);
X		bufsize = wantsize;
X	}
X	(void) sprintf(buf, f, d);
X	LJ_sput(buf);
X}
X
Xstatic void
Xswift(afont, wfont)
Xint const	afont;
Xint const	wfont;
X{
X	if (afont >= 0)
X		LJ_sput(fontdata[afont].f_out);
X	LJ_sput(fontdata[wfont].f_in);
X}
X
Xstatic void
Xdostrike(s)
Xstrike	s;
X{
X	item *		ip;
X	static long	achor = -1;
X	static long	acver = -1;
X	static int	afont = -1;
X	static int	asize = -1;
X	static int	apage = -1;
X	static item *	curip;
X	static item *	oldip;
X	static int	called;
X
X	if (s.fti <= 0)
X		return;
X	/*
X	** First time downloading.
X	*/
X	if (firsts[s.size][s.font] != NULL) {
X		FILE *	fp;
X		char *	cp;
X		char *	dp;
X		int	c;
X
X		cp = firsts[s.size][s.font];
X		firsts[s.size][s.font] = NULL;
X		while ((c = *cp++) != '\0') {
X			if (c != '<') {
X				LJ_cput(c);
X				continue;
X			}
X			dp = cp;
X			while (*dp != '\0' && *dp != '>')
X				++dp;
X			if (*dp == '\0') {
X				LJ_cput(c);
X				continue;
X			}
X			*dp = '\0';
X			/*
X			** Download the file.
X			*/
X			if ((fp = fopen(cp, "r")) == NULL)
X				wild2exit("result opening", cp);
X			while ((c = getc(fp)) != EOF)
X				LJ_cput(c);
X			if (ferror(fp) || !feof(fp) || fclose(fp))
X				wildexit("result from downloading");
X			*dp++ = '>';
X			cp = dp;
X		}
X		curip = NULL;	/* to get font reselection */
X	}
X	ip = &items[s.fti];
X	/*
X	** Easiest part first.
X	*/
X	if (curip != NULL && curip->outset != NULL &&
X		curip->ssname != ip->ssname) {
X			LJ_sput(curip->outset);
X			curip = oldip;
X			oldip = NULL;
X	}
X	if (curip == NULL || ip->ssname != curip->ssname) {
X		LJ_sput(ip->inset);
X		if (ip->outset != NULL)
X			oldip = curip;
X		curip = ip;
X	}
X	/*
X	** Get to right page; modulate vertical offset.
X	*/
X	{
X		int	wpage;
X
X		wpage = s.ver / ncvupp;
X		if (wpage != apage) {
X
X			if (called)
X				LJ_sput(newpage);
X			apage = wpage;
X			acver = 0;
X		}
X		s.ver %= ncvupp;
X	}
X	/*
X	** Get to right horizontal place.
X	*/
X	/*
X	** Always position repeated root ens and underlines.
X	*/
X	{
X		static int	didindices;
X		static int	rnindex;
X		static int	ulindex;
X		static int	_index;
X		static int	dotindex;
X		static int	prev;
X
X		if (!didindices) {
X			didindices = TRUE;
X			rnindex = ntn2fti("rn");
X			ulindex = ntn2fti("ul");
X			_index = ntn2fti("_");
X			dotindex = ntn2fti(".");
X		}
X		if (s.fti == prev &&
X			(s.fti == rnindex ||
X			s.fti == ulindex ||
X			s.fti  == _index ||
X			s.fti == dotindex))
X				achor = ~s.hor;
X		prev = s.fti;
X	}
X	if (s.hor != achor) {
X		long	wlhor;
X		static long	adjustment;
X
X		wlhor = s.hor * horunitsperinch / NCHUPI;
X		/*
X		** Adjust for stupid left margin.
X		*/
X		if (wlhor < leftmargin)
X			adjustment = leftmargin;
X		wlhor += adjustment;
X		/*
X		** Rustproofing.
X		*/
X		if (wlhor < 0)
X			wlhor = 0;
X		LJ_fdput(hormove, (int) wlhor);
X		achor = s.hor;
X	}
X	/*
X	** Get to right vertical place.
X	*/
X	{
X		long	wlver;
X
X		if (s.ver != acver) {
X			wlver = (long) s.ver * verunitsperinch / NCVUPI;
X			/*
X			** Rustproofing.
X			*/
X			if (wlver < 0)
X				wlver = 0;
X			LJ_fdput(vermove, (int) wlver);
X			acver = s.ver;
X		}
X	}
X	/*
X	** If haven't already changed font. . .
X	*/
X	if (afont != s.font) {
X		swift(afont, s.font);
X		afont = s.font;
X	}
X	if (asize != s.size) {
X		LJ_fdput(sizes, s.size);
X		asize = s.size;
X	}
X	/*
X	** Quote if necessary.
X	*/
X	if (ip->data != NULL && ip->data[0] != 0 && ip->data[1] == 0 &&
X		lowvalue != 0 && ip->data[0] < lowvalue)
X			LJ_sput(lowstring);
X	/*
X	** Finally send out the data.
X	*/
X	if (ip->data != NULL)
X		LJ_sput(ip->data);
X	else if (isascii(s.fti) && isprint(s.fti))
X		LJ_cput(s.fti);
X	else	LJ_cput('\177'); /* make this settable? */
X	/*
X	** Update horizontal position.
X	*/
X	achor += fiswidth(s.font, s.fti, s.size);
X	called = TRUE;
X}
X
X/*
X** The stuff below is used only when generating width tables for use with troff.
X*/
X
Xstatic int
Xascends(name)
Xconst char *	name;
X{
X	if (name[1] == '\0')
X		return isdigit(name[0]) || isupper(name[0]) ||
X			strchr("bdfhijklt", name[0]) != 0;
X	switch (*name++) {
X		case '*': return strchr("bdzhlcfqGDHLCPSUFQW", *name) != 0;
X		case 'f': return strchr("ilf", *name) != 0;
X		case 'F': return strchr("il", *name) != 0;
X		case 'g': return *name == 'r';
X	}
X	return FALSE;
X}
X
Xstatic int
Xdescends(name)
Xconst char * const	name;
X{
X	if (name[1] == '\0')
X		return strchr("Qgjpqy", name[0]) != 0;
X	if (name[0] == '*')
X		return strchr("bgzymcrfxq", name[1]) != 0;
X	return strcmp(name, "ts") == 0;
X}
X
Xstatic void
Xdowidth()
X{
X	FILE *		fp;
X	char *		cp;
X	const char *	name;
X	item *		ip;
X	int		font;
X	int		j;
X	int		w;
X
X	for (font = 0; font < NFONTS; ++font) {
X		cp = ecpyalloc("ft");
X		cp = ecatalloc(cp, fontdata[font].f_fontnick);
X		fp = dfopen(cp, "w", TRUE);
X		free(cp);
X		for (j = 0; j < 256; ++j) {
X			if ((name = fti2ntn(j)) == NULL) {
X				(void) putc(0, fp);
X				continue;
X			}
X			if (fontisS(font) ? ntnonr(name) : ntnons(name)) {
X				(void) putc(0, fp);
X				continue;
X			}
X			if (strcmp(name, "\\^") == 0) 
X				w = (NCHUPI * CWPS) / (NPPI * 12); /* 1/12 em */
X			else if (strcmp(name, "\\|") == 0)
X				w = (NCHUPI * CWPS) / (NPPI * 6); /* 1/6 em */
X			else {
X				ip = &items[j];
X				if (ip->ssname == NULL) {
X					(void) putc(0, fp);
X					continue;
X				}
X				w = ip->widths[font];
X				if (ascends(name))
X					w |= 0200;
X				if (descends(name))
X					w |= 0100;
X			}
X			(void) putc(w, fp);
X		}
X		if (ferror(fp) || fclose(fp))
X			wildline("result writing");
X	}
X}
END_OF_FILE
if test 36238 -ne `wc -c <'tlc.c'`; then
    echo shar: \"'tlc.c'\" unpacked with wrong size!
fi
# end of 'tlc.c'
fi
echo shar: End of archive 2 \(of 2\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
