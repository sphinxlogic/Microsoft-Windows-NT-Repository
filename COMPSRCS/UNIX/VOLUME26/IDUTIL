Newsgroups: comp.sources.unix
From: dtb@otto.bf.rmit.oz.au (David Bath)
Subject: v26i060: idutil - command-line i'face to cuserid(3), getpwnam(3), &etc
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: dtb@otto.bf.rmit.oz.au (David Bath)
Posting-Number: Volume 26, Issue 60
Archive-Name: idutil

[ This package command-line interfaces to the C-library functions that
  handle user- and group-id's.  I would normally reject something that
  has no README file, but since this one has a good Makefile and complete
  man pages, I'm letting it through.				--vix ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  MANIFEST Makefile cuserid.1l cuserid.c getgrgid.1l
#   getgrgid.c getgrnam.1l getgrnam.c getid.c getlogin.1l getlogin.c
#   getpwnam.1l getpwnam.c getpwuid.1l getpwuid.c getuid.1l grinf.c
#   grinf.h pwinf.c pwinf.h
# Wrapped by dtb@cheops on Tue Feb 25 14:01:25 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1171 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	makekit(1) control - this file
X Makefile                   1	Instructions to make the binaries
X cuserid.1l                 1	Manual page
X cuserid.c                  1	Mainline for cuserid(1)
X getgrgid.1l                1	Manual page
X getgrgid.c                 1	Mainline for getgrgid(1)
X getgrnam.1l                1	Manual page
X getgrnam.c                 1	Mainline for getgrnam(1)
X getid.c                    1	Mainline for getuid(1), getgid(1)....
X getlogin.1l                1	Manual page
X getlogin.c                 1	Mainline for getlogin(1)
X getpwnam.1l                1	Manual page
X getpwnam.c                 1	Mainline for getpwnam(1)
X getpwuid.1l                1	Manual page
X getpwuid.c                 1	Mainline for getpwuid(1)
X getuid.1l                  1	Manual page
X grinf.c                    1	grp information format functions
X grinf.h                    1	declarations for grinf.c functions
X pwinf.c                    1	passwd information format functions
X pwinf.h                    1	declarations for pwinf.c functions
END_OF_FILE
if test 1171 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(3267 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# $Header: Makefile,v 1.13 92/02/25 13:26:23 dtb Exp $
X# Makefile for group and user information utilities by David T. Bath
X# Look at the doco under /MAKE VARIABLES/ and /PSEUDOTARGETS/ and
X# edit them as appropriate
X
X######################################################################
X# MAKE VARIABLES
X# CC 		Your C compiler
X# BIN 		Binaries created
X# MAN 		Directory (less the 1) where manual pages live
X# CATMAN 	Name of program that automatically formats man pages
X# CPPOPTS 	Options for cpp
X# LINKLIBS 	Directions for cc(1) to link in libraries
XCC = cc -g
XLOCALBIN = /usr/local/bin
XBIN = cuserid getgrnam getgrgid getpwnam getpwuid getid getlogin
XMAN = /usr/man/local/man
XCATMAN = /usr/catman/local/man
XCPPOPTS = -I/usr/local/include
X
X# For linking, the Pyramid use the version of LINKLIBS with -Wl, in it
XLINKLIBS = -Wl,-L/usr/local/lib/gnu -lfu
X#LINKLIBS = -L/usr/local/lib/gnu -lfu
X
X######################################################################
X# PSEUDOTARGETS
X# all 		Make up all binaries in current directory
X# install 	Link binaries into installation directory
X# xrf 		Create idutil.xrf - cross reference
X# manual 	Copy manual source and format it - change for BSD
X# man 		Format manual pages - change for BSD
X# clean		Remove binaries
X# distshar 	Use makekit(1) to create distribution idutilnn file(s)
X# disttar 	Create distribution tar file
X# distshar 	Create distribution cpio file
X
Xall : $(BIN)
X
Xinstall : all manual
X	- ln $(BIN) $(LOCALBIN) || cp $(BIN) $(LOCALBIN)
X	- mv $(LOCALBIN)/getid $(LOCALBIN)/getuid
X	- ln $(LOCALBIN)/getuid $(LOCALBIN)/geteuid
X	- ln $(LOCALBIN)/getuid $(LOCALBIN)/getegid
X	- ln $(LOCALBIN)/getuid $(LOCALBIN)/getgid
X
Xxrf :
X	cxref $(CPPOPTS) -c -o idutil.xrf *.c
X
Xmanual :
X	cp cuserid.1l $(MAN)1
X	cp getgrnam.1l $(MAN)1
X	cp getgrgid.1l $(MAN)1
X	cp getlogin.1l $(MAN)1
X	cp getpwnam.1l $(MAN)1
X	cp getpwuid.1l $(MAN)1
X	cp getuid.1l   $(MAN)1
X	catman 1 || make man
X
Xman :
X	nroff -man < $(MAN)1/cuserid.1l > $(CATMAN)1/cuserid.1l
X	nroff -man < $(MAN)1/getgrgid.1l > $(CATMAN)1/getgrgid.1l
X	nroff -man < $(MAN)1/getgrnam.1l > $(CATMAN)1/getgrnam.1l
X	nroff -man < $(MAN)1/getlogin.1l > $(CATMAN)1/getlogin.1l
X	nroff -man < $(MAN)1/getpwnam.1l > $(CATMAN)1/getpwnam.1l
X	nroff -man < $(MAN)1/getpwuid.1l > $(CATMAN)1/getpwuid.1l
X	nroff -man < $(MAN)1/getuid.1l > $(CATMAN)1/getuid.1l
X
Xclean : 
X	- rm $(BIN) *.o a.out core *.tar *.cpio
X	echo "Cleanup done"
X
Xdistshar :
X	- makekit -m -nidutil
X
Xdistcpio :
X	- tail +3 MANIFEST | sed 's!^ \([^ 	]*\).*!\1!' | \
X		cpio -oBcv > idutil.cpio
X
Xdisttar :
X	- tar -cvf idutil.tar `tail +3 MANIFEST | sed 's!\(^ [^	 ]*\).*!\1!'`
X
X##### BORING BITS BELOW HERE - YOU SHOULD NOT HAVE TO PLAY WITH THIS #######
X
Xmainutil.o : mainutil.c mainutil.h
X
Xgrinf.o : grinf.c grinf.h
X
Xpwinf.o : pwinf.c pwinf.h
X
Xcuserid : cuserid.c
X	cc $(CPPOPTS) -o $@ $@.c $(LINKLIBS)
X
Xgetgrnam : getgrnam.c grinf.o
X	cc $(CPPOPTS) -o $@ $@.c grinf.o $(LINKLIBS)
X
Xgetgrgid : getgrgid.c grinf.o 
X	cc $(CPPOPTS) -o $@ $@.c grinf.o $(LINKLIBS)
X
Xgetid    : getid.c 
X	cc $(CPPOPTS) -o $@ $@.c $(LINKLIBS)
X
Xgetlogin : getlogin.c
X	cc $(CPPOPTS) -o $@ $@.c $(LINKLIBS)
X
Xgetpwnam : getpwnam.c pwinf.o
X	cc $(CPPOPTS) -o $@ $@.c pwinf.o $(LINKLIBS)
X
Xgetpwuid : getpwuid.c pwinf.o
X	cc $(CPPOPTS) -o $@ $@.c pwinf.o $(LINKLIBS)
X
END_OF_FILE
if test 3267 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'cuserid.1l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cuserid.1l'\"
else
echo shar: Extracting \"'cuserid.1l'\" \(784 characters\)
sed "s/^X//" >'cuserid.1l' <<'END_OF_FILE'
X.TH CUSERID 1 LOCAL
X.SH NAME
Xcuserid \- Get username information
X.SH SYNOPSIS
X.B cuserid
X.I [-Iv] 
X.SH DESCRIPTION
X.LP
X.B cuserid
Xuses
X.I "cuserid(3)"
Xto echo the login name to standard output with optional extra information
Xand verbose leader.
X.LP
X.SH USAGE
X.SS Options
X.I
X.IP \fB\-I\fR
XGives information about the program.
X.IP \fB\-v\fR
XTrue if the command is to work in \fBverbose\fR mode, not suitable for
Xbackquoting and echoing more information to standard output or standard
Xerror.
X.RE
X.LP
X.SH DIAGNOSTICS
XThe following values may be returned to the calling process:
X.RS 
X.IP \fB0\fR
XNo errors noted
X.IP \fB1\fR 
XReturned when the user information is not available.
X.SH "SEE ALSO"
X.BR cuserid(3)
X.BR getlogin(3)
X.BR getlogin(1)
X.SH AUTHOR 
XDavid T. Bath dtb@otto.bf.rmit.oz.au
END_OF_FILE
if test 784 -ne `wc -c <'cuserid.1l'`; then
    echo shar: \"'cuserid.1l'\" unpacked with wrong size!
fi
# end of 'cuserid.1l'
fi
if test -f 'cuserid.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cuserid.c'\"
else
echo shar: Extracting \"'cuserid.c'\" \(1292 characters\)
sed "s/^X//" >'cuserid.c' <<'END_OF_FILE'
X/* 
X** NAME : cuserid.c
X** PURPOSE : Shell level access to cuserid(3)
X*/
X#include <stdio.h>
X#include <errno.h>
X#include <gnu/fileutil.h>
X
Xstatic char *RCSid="$Header: cuserid.c,v 1.1 92/02/25 12:43:31 dtb Exp $";
X
Xint 	fpr_usage();
X
Xstatic char 	*trim_main_name;
Xstatic short 	main_verbose = 0;
X
Xint	main ( argc, argv, envp )
Xint	argc;
Xchar	**argv;
Xchar	**envp;
X{
X	char	*optstring = "Iv" ;
X	int		optchar;
X	extern char	*optarg;
X	extern int	optind;
X	extern int	opterr;
X	char 	*login_name;
X	int 	rval = 0; 				/* Default return success */
X
X	trim_main_name = basename(*argv);
X	main_verbose = 0;		/* verbose off */
X	opterr = 0;
X	while ((optchar = getopt(argc, argv, optstring)) != -1)
X		switch (optchar) {
X		case 'I':
X			fprintf (stderr, "%s %s\n", __FILE__, RCSid);
X			break;
X		case 'v':
X			main_verbose = 1;
X			break;
X		case '?':
X			fpr_usage (stderr);
X			exit (EINVAL);
X		}
X	if ((login_name = cuserid(NULL))==NULL) {
X		if (main_verbose) {
X			fprintf(stderr, "%s: cuserid() returned null\n",
X				trim_main_name);
X			rval = 1;
X		}
X	} else {
X		if (main_verbose) 
X			printf("Your login according to clogin is ");
X		printf ("%s\n", login_name);
X	}
X	return (rval);
X
X}
X
X
Xint 	fpr_usage (fp)
XFILE 	*fp;
X{
X	int 	nout = 0;
X	nout += fprintf (stderr, "Usage: %s [-v]\n", trim_main_name);
X	return (nout);
X}
END_OF_FILE
if test 1292 -ne `wc -c <'cuserid.c'`; then
    echo shar: \"'cuserid.c'\" unpacked with wrong size!
fi
# end of 'cuserid.c'
fi
if test -f 'getgrgid.1l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getgrgid.1l'\"
else
echo shar: Extracting \"'getgrgid.1l'\" \(2342 characters\)
sed "s/^X//" >'getgrgid.1l' <<'END_OF_FILE'
X.TH GETGRGID 1 LOCAL
X.SH NAME
Xgetgrgid \- Group information from group numeric id
X.SH SYNOPSIS
X.B getgrgid
X.I [-Iagmnpv] 
X.I [-d 
Xchar
X.I ] 
X.I [-e 
Xchar
X.I ]
X[ grpnum ... ]
X.SH DESCRIPTION
X.LP
X.B getgrgid
Xechoes group information given a list of group numeric identifiers.
XError messages generated from within the
X.B getgrgid
Xutility are sent to stderr, not stdout, allowing the programmer to use
Xappropriate backquoting for this command.
X.LP
XIf no arguments are given, the current effective group is assumed.
X.LP
X.SH USAGE
X.SS Options
X.I
X.IP \fB\-I\fR
XGives information about the program.
X.IP \fB\-a\fR
XSame as setting npgm flags.  See below.
X.IP \fB\-g\fR
XWill echo group identifier (gid).
X.IP \fB\-n\fR
XWill echo group name.
X.IP \fB\-m\fR
XWill echo group member list.
X.IP \fB\-p\fR
XWill echo group encrypted password.
X.IP \fB\-r\fR
XWill report on exceptions to standard error, for example when groups are
Xnot found.
X.IP \fB\-v\fR
XTrue if the command is to work in \fBverbose\fR mode, not suitable for
Xbackquoting and echoing more information to standard output or standard
Xerror.
X.IP \fB-d\fR
XThe character following the option indication is used as a delimiter
Xbetween output fields.  The default is ':' in line with the format of 
Xthe \fB/etc/group\fR file.
X.IP \fB-e\fR
XThe character following the option indication is used as a delimiter
Xbetween member fields.  The default is ',' in line with the format of 
Xthe \fB/etc/group\fR file.
X.IP \fB\-?\fR
XPresents brief help text to the user.  This option causes an error to
Xbe returned as no group number is echoed.
X.SH EXAMPLE
X.LP
X.nf
Xexample$ getgrgid -a
Xcmim::208:cmim,dtb,asd,rhs,marg,mah,sab,yxn,spl,krf,gxf
Xexample$ getgrgid -rvgn 1 2 6 7
Xgetgrgid: could not find group 7
Xgname=other:gid=1
Xgname=bin:gid=2
Xgname=mail:gid=6
Xexample$ getgrgid -nm -d +
Xcmim+cmim,dtb,asd,rhs,marg,mah,sab,yxn,spl,krf,gxf
Xexample$ getgrgid -vgn -d +
Xgname=cmim+gid=208
X.fi
X.ft R
X.RE
X.LP
X.SH DIAGNOSTICS
XThe following values may be returned to the calling process:
X.RS 
X.IP \fB0\fR
XNo errors noted
X.IP \fB1\fR 
XReturned when the group information is not available.
X.IP \fB12\fR
XENOMEM: Problem with memory.
X.IP \fB22\fR
XEINVAL: Invalid argument supplied.
X.SH FILES
X.B /etc/group
X.SH "SEE ALSO"
X.BR group(4)
X.BR getegid(2)
X.BR getgrgid(2)
X.BR getgrnam(1L)
X.SH AUTHOR 
XDavid T. Bath dtb@otto.bf.rmit.oz.au
END_OF_FILE
if test 2342 -ne `wc -c <'getgrgid.1l'`; then
    echo shar: \"'getgrgid.1l'\" unpacked with wrong size!
fi
# end of 'getgrgid.1l'
fi
if test -f 'getgrgid.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getgrgid.c'\"
else
echo shar: Extracting \"'getgrgid.c'\" \(2188 characters\)
sed "s/^X//" >'getgrgid.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <errno.h>
X#include <grp.h>
X#include "grinf.h"
X#include <gnu/fileutil.h>
X
Xstatic char *RCSid="$Header: getgrgid.c,v 1.6 92/02/25 13:59:51 dtb Exp $";
X
Xint 	fpr_usage();
Xint	process_it();
Xstatic char 	*trim_main_name;
X
Xstatic int 	report_except = 0;
Xstatic char 	all_found     = 1;
X
Xint	main ( argc, argv, envp )
Xint	argc;
Xchar	**argv;
Xchar	**envp;
X{
X	char		*optstring = "ad:e:Igmnprv" ;
X	int		optchar;
X	extern char	*optarg;
X	extern int	optind;
X	extern int 	opterr;
X	struct grinfrq 	*grinf;
X
X	trim_main_name = basename(*argv);
X	if ((grinf = grinfrq_set_dflt (NULL)) == NULL)
X	    exit (ENOMEM);
X	opterr = 0;
X	while ((optchar = getopt(argc, argv, optstring)) != -1)
X		switch (optchar) {
X		case 'I':
X			fprintf (stderr, "%s %s\n", __FILE__, RCSid);
X			grinf_info_fpr (stderr);
X			break;
X		case 'a':
X			grinf->epw = grinf->nam = grinf->mem = grinf->gid = 1;
X			break;
X		case 'd':
X			grinf->dlm = *optarg;
X			break;
X		case 'e' :
X			grinf->mdl = *optarg;
X			break;
X		case 'g':
X			grinf->gid = 1;
X			break;
X		case 'm':
X			grinf->mem = 1;
X			break;
X		case 'n':
X			grinf->nam = 1;
X			break;
X		case 'p':
X			grinf->epw = 1;
X			break;
X		case 'r':
X			report_except = 1;
X			break;
X		case 'v':
X			grinf->vbs = 1;
X			break;
X		case '?':
X			fpr_usage (stderr);
X			exit (EINVAL);
X		}
X	if (optind == argc)
X	    process_it (getegid(), grinf);
X	while (optind < argc) {
X		int 	gid;
X		if (sscanf(*(argv+optind), "%d", &gid) != 1) {
X			fprintf (stderr, "%s: %s not a valid integer\n",
X			    trim_main_name, *(argv+optind));
X			exit (EINVAL);
X		}
X		process_it (gid, grinf);
X		optind++;
X	}
X	exit (all_found ? 0 : 1);
X}
X
X
Xint	process_it( grpgid, grinf)
Xint	grpgid;
Xstruct 	grinfrq 	*grinf;
X{
X	struct 	group *gp;
X	int 	nout = 0;
X
X	if (( gp = (struct group *) getgrgid (grpgid) ) == NULL) {
X		all_found = 0;
X		if (report_except) {
X		    fprintf (stderr, "%s: could not find group %d\n",
X			trim_main_name, grpgid);
X		}
X	} else {
X		nout = grinf_fpr (stdout, gp, grinf);
X	}
X	return (nout);
X}
X
X
Xint 	fpr_usage (fp)
XFILE 	*fp;
X{
X	int 	nout = 0;
X	nout += fprintf (stderr, 
X		"Usage: %s [-%s] [-%s] [-%s] grpname [...]\n",
X		trim_main_name,
X		"Iagmnprv", "d char", "e char" );
X	return (nout);
X}
X
END_OF_FILE
if test 2188 -ne `wc -c <'getgrgid.c'`; then
    echo shar: \"'getgrgid.c'\" unpacked with wrong size!
fi
# end of 'getgrgid.c'
fi
if test -f 'getgrnam.1l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getgrnam.1l'\"
else
echo shar: Extracting \"'getgrnam.1l'\" \(2381 characters\)
sed "s/^X//" >'getgrnam.1l' <<'END_OF_FILE'
X.TH GETGRNAM 1 LOCAL
X.SH NAME
Xgetgrnam \- Group information from group name
X.SH SYNOPSIS
X.B getgrnam
X.I [-Iagmnpv] 
X.I [-d 
Xchar
X.I ] 
X.I [-e 
Xchar
X.I ]
X[ name ... ]
X.SH DESCRIPTION
X.LP
X.B getgrnam
Xechoes group information given a list of possible group names.
XError messages generated from within the
X.B getgrnam
Xutility are sent to stderr, not stdout, allowing the programmer to use
Xappropriate backquoting for this command.
X.LP
XIf no arguments are given, the current effective group is assumed.
X.LP
X.SH USAGE
X.SS Options
X.I
X.IP \fB\-I\fR
XGives information about the program.
X.IP \fB\-a\fR
XSame as setting npgm flags.  (a is for "all"). See below.
X.IP \fB\-g\fR
XWill echo group identifier (gid).
X.IP \fB\-n\fR
XWill echo group name.
X.IP \fB\-m\fR
XWill echo group member list.
X.IP \fB\-p\fR
XWill echo group encrypted password.
X.IP \fB\-r\fR
XWill report on exceptions to standard error, for example when groups are
Xnot found.
X.IP \fB\-v\fR
XTrue if the command is to work in \fBverbose\fR mode, not suitable for
Xbackquoting and echoing more information to standard output or standard
Xerror.
X.IP \fB-d\fR
XThe character following the option indication is used as a delimiter
Xbetween output fields.  The default is ':' in line with the format of 
Xthe \fB/etc/group\fR file.
X.IP \fB-e\fR
XThe character following the option indication is used as a delimiter
Xbetween member fields.  The default is ',' in line with the format of 
Xthe \fB/etc/group\fR file.
X.IP \fB\-?\fR
XPresents brief help text to the user.  This option causes an error to
Xbe returned as no group number is echoed.
X.SH EXAMPLE
X.LP
X.nf
Xexample$ getgrnam -a
Xcmim::208:cmim,dtb,asd,rhs,marg,mah,sab,yxn,spl,krf,gxf
Xexample$ getgrnam -rvgn bin nosuch ftp
Xgetgrnam: could not find group nosuch
Xgname=bin:gid=2
Xgname=ftp:gid=204
Xexample$ getgrnam -nm -d +
Xroot+root,adm,ucbroot,attroot,dtb
Xcmim+cmim,dtb,asd,rhs,marg,mah,sab,yxn,spl,krf,gxf
Xexample$ getgrnam -vpgn -d ,
Xgname=root,pass=,gid=0
X.fi
X.ft R
X.RE
X.LP
X.SH DIAGNOSTICS
XThe following values may be returned to the calling process:
X.RS 
X.IP \fB0\fR
XNo errors noted
X.IP \fB1\fR 
XReturned when the group information is not available.
X.IP \fB12\fR
XENOMEM: Problem with memory.
X.IP \fB22\fR
XEINVAL: Invalid argument supplied.
X.SH FILES
X.B /etc/group
X.SH "SEE ALSO"
X.BR group(4)
X.BR getegid(2)
X.BR getgrnam(2)
X.BR getgrgid(1L)
X.SH AUTHOR 
XDavid T. Bath dtb@otto.bf.rmit.oz.au
END_OF_FILE
if test 2381 -ne `wc -c <'getgrnam.1l'`; then
    echo shar: \"'getgrnam.1l'\" unpacked with wrong size!
fi
# end of 'getgrnam.1l'
fi
if test -f 'getgrnam.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getgrnam.c'\"
else
echo shar: Extracting \"'getgrnam.c'\" \(2400 characters\)
sed "s/^X//" >'getgrnam.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <errno.h>
X#include <grp.h>
X#include <gnu/fileutil.h>
X#include "grinf.h"
X
Xstatic char *RCSid="$Header: getgrnam.c,v 1.7 92/02/25 14:00:01 dtb Exp $";
X
Xint 	fpr_usage();
Xint	process_it();
X
Xstatic int 	report_except = 0;
Xstatic char 	all_found     = 1;
Xstatic char 	*trim_main_name;
X
Xint	main ( argc, argv, envp )
Xint	argc;
Xchar	**argv;
Xchar	**envp;
X{
X	char		*optstring = "ad:e:Igmnprv" ;
X	int		optchar;
X	extern char	*optarg;
X	extern int	optind;
X	extern int 	opterr;
X	struct grinfrq 	*grinf;
X
X	trim_main_name =basename(*argv);
X	if ((grinf = grinfrq_set_dflt (NULL)) == NULL)
X	    exit (ENOMEM);
X	opterr = 0;
X	while ((optchar = getopt(argc, argv, optstring)) != -1)
X		switch (optchar) {
X		case 'I':
X			fprintf (stderr, "%s %s\n", __FILE__, RCSid);
X			grinf_info_fpr (stderr);
X			break;
X		case 'a':
X			grinf->epw = grinf->nam = grinf->mem = grinf->gid = 1;
X			break;
X		case 'd':
X			grinf->dlm = *optarg;
X			break;
X		case 'e' :
X			grinf->mdl = *optarg;
X			break;
X		case 'g':
X			grinf->gid = 1;
X			break;
X		case 'm':
X			grinf->mem = 1;
X			break;
X		case 'n':
X			grinf->nam = 1;
X			break;
X		case 'p':
X			grinf->epw = 1;
X			break;
X		case 'r':
X			report_except = 1;
X			break;
X		case 'v':
X			grinf->vbs = 1;
X			break;
X		case '?':
X			fpr_usage (stderr);
X			exit (EINVAL);
X		}
X	if (optind == argc) {
X	    struct group * gp;
X	    char   	   gnametmp[256];
X	    gp = (struct group *)getgrgid (getegid());
X	    strcpy (gnametmp, gp->gr_name);
X	    /* 
X	    We need a temporary buffer for the current group name
X	    rather than passing gp->gr_name to process_it as the
X	    buffer pointed at by the returning getgrnam call will
X	    overwrite the passed parameter
X	    */
X	    process_it (&gnametmp[0], grinf);
X	}
X	while (optind < argc) {
X		process_it (*(argv+optind++), grinf);
X	}
X	exit (all_found ? 0 : 1);
X}
X
X
Xint	process_it( grpnam, grinf)
Xchar	*grpnam;
Xstruct 	grinfrq 	*grinf;
X{
X	struct 	group *grp;
X	int 	nout = 0;
X
X	grp = (struct group *) getgrnam ( grpnam );
X	if ( grp == NULL) {
X		all_found = 0;
X		if (report_except) {
X		    fprintf (stderr, "%s: could not find group %s\n",
X			trim_main_name, grpnam);
X		}
X	} else {
X		nout = grinf_fpr (stdout, grp, grinf);
X	}
X	return (nout);
X}
X
X
Xint 	fpr_usage (fp)
XFILE 	*fp;
X{
X	int 	nout = 0;
X	nout += fprintf (stderr, 
X		"Usage: %s [-%s] [-%s] [-%s] grpname [...]\n",
X		trim_main_name,
X		"Iagmnprv", "d char", "e char" );
X	return (nout);
X}
X
END_OF_FILE
if test 2400 -ne `wc -c <'getgrnam.c'`; then
    echo shar: \"'getgrnam.c'\" unpacked with wrong size!
fi
# end of 'getgrnam.c'
fi
if test -f 'getid.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getid.c'\"
else
echo shar: Extracting \"'getid.c'\" \(786 characters\)
sed "s/^X//" >'getid.c' <<'END_OF_FILE'
X/*
X * NAME
X * 	getid.c 	- get id information
X * NOTES
X * 	Forms getuid, getgid, geteuid, getegid commands
X * 	all linked to same inode and kept in /usr/local/bin
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <gnu/fileutil.h>
X
X
Xstatic char *RCSid="$Header: getid.c,v 1.3 92/01/23 15:05:31 dtb Exp $";
Xstatic char *trim_main_name;
X
Xint main (argc, argv, envp)
Xint 	argc;
Xchar 	**argv;
Xchar 	**envp;
X{
X    int currid;
X
X    trim_main_name=basename(*argv);
X    if (!strcmp(trim_main_name, "getuid"))
X	currid=getuid();
X    else if (!strcmp(trim_main_name, "geteuid"))
X	currid=geteuid();
X    else if (!strcmp(trim_main_name, "getgid"))
X	currid=getgid();
X    else if (!strcmp(trim_main_name, "getegid"))
X	currid=getegid();
X    else
X	currid=getuid();
X    
X    printf ("%d\n", currid);
X}
X
END_OF_FILE
if test 786 -ne `wc -c <'getid.c'`; then
    echo shar: \"'getid.c'\" unpacked with wrong size!
fi
# end of 'getid.c'
fi
if test -f 'getlogin.1l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getlogin.1l'\"
else
echo shar: Extracting \"'getlogin.1l'\" \(875 characters\)
sed "s/^X//" >'getlogin.1l' <<'END_OF_FILE'
X.TH GETLOGIN 1 LOCAL
X.SH NAME
Xgetlogin \- Get login information
X.SH SYNOPSIS
X.B getlogin
X.I [-Iv] 
X.SH DESCRIPTION
X.LP
X.B getlogin
Xuses
X.I "getlogin(3)"
Xto echo the login name to standard output with optional extra information
Xand verbose leader and has the same problems as
X.I "getlogin(3)"
Xso consider using 
X.I "cuserid(1L)"
Xinstead.
X.LP
X.SH USAGE
X.SS Options
X.I
X.IP \fB\-I\fR
XGives information about the program.
X.IP \fB\-v\fR
XTrue if the command is to work in \fBverbose\fR mode, not suitable for
Xbackquoting and echoing more information to standard output or standard
Xerror.
X.RE
X.LP
X.SH DIAGNOSTICS
XThe following values may be returned to the calling process:
X.RS 
X.IP \fB0\fR
XNo errors noted
X.IP \fB1\fR 
XReturned when the user information is not available.
X.SH "SEE ALSO"
X.BR getlogin(3)
X.BR cuserid(3)
X.BR cuserid(1)
X.SH AUTHOR 
XDavid T. Bath dtb@otto.bf.rmit.oz.au
END_OF_FILE
if test 875 -ne `wc -c <'getlogin.1l'`; then
    echo shar: \"'getlogin.1l'\" unpacked with wrong size!
fi
# end of 'getlogin.1l'
fi
if test -f 'getlogin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getlogin.c'\"
else
echo shar: Extracting \"'getlogin.c'\" \(1305 characters\)
sed "s/^X//" >'getlogin.c' <<'END_OF_FILE'
X/* 
X** NAME : getlogin.c
X** PURPOSE : Shell level access to getlogin(3)
X*/
X#include <stdio.h>
X#include <errno.h>
X#include <gnu/fileutil.h>
X
Xstatic char *RCSid="$Header: getlogin.c,v 1.3 92/02/25 14:00:06 dtb Exp $";
X
Xint 	fpr_usage();
X
Xstatic char 	*trim_main_name;
Xstatic short 	main_verbose = 0;
X
Xint	main ( argc, argv, envp )
Xint	argc;
Xchar	**argv;
Xchar	**envp;
X{
X	char	*optstring = "Iv" ;
X	int		optchar;
X	extern char	*optarg;
X	extern int	optind;
X	extern int	opterr;
X	char 	*login_name;
X	int 	rval = 0; 				/* Default return success */
X
X	trim_main_name = basename(*argv);
X	main_verbose = 0;		/* verbose off */
X	opterr = 0;
X	while ((optchar = getopt(argc, argv, optstring)) != -1)
X		switch (optchar) {
X		case 'I':
X			fprintf (stderr, "%s %s\n", __FILE__, RCSid);
X			break;
X		case 'v':
X			main_verbose = 1;
X			break;
X		case '?':
X			fpr_usage (stderr);
X			exit (EINVAL);
X		}
X	if ((login_name = (char *)getlogin())==NULL) {
X		if (main_verbose) {
X			fprintf(stderr, "%s: getlogin() returned null\n",
X				trim_main_name);
X			rval = 1;
X		}
X	} else {
X		if (main_verbose) 
X			printf("Your login according to /etc/utmp is ");
X		printf ("%s\n", login_name);
X	}
X	return (rval);
X
X}
X
X
Xint 	fpr_usage (fp)
XFILE 	*fp;
X{
X	int 	nout = 0;
X	nout += fprintf (stderr, "Usage: %s [-v]\n", trim_main_name);
X	return (nout);
X}
X
END_OF_FILE
if test 1305 -ne `wc -c <'getlogin.c'`; then
    echo shar: \"'getlogin.c'\" unpacked with wrong size!
fi
# end of 'getlogin.c'
fi
if test -f 'getpwnam.1l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getpwnam.1l'\"
else
echo shar: Extracting \"'getpwnam.1l'\" \(2402 characters\)
sed "s/^X//" >'getpwnam.1l' <<'END_OF_FILE'
X.TH GETPWNAM 1 LOCAL
X.SH NAME
Xgetpwnam \- User information from user name
X.SH SYNOPSIS
X.B getpwnam
X.I [-Iacghnprsuv] 
X.I [-d 
Xchar
X.I ] 
X[ name ... ]
X.SH DESCRIPTION
X.LP
X.B getpwnam
Xechoes user information given a list of possible user names.
XError messages generated from within the
X.B getpwnam
Xutility are sent to stderr, not stdout, allowing the programmer to use
Xappropriate backquoting for this command.
X.LP
XIf no arguments are given, the program will use various means to get a 
Xlogin name, and failing that use the effective user id.
X.LP
X.SH USAGE
X.SS Options
X.I
X.IP \fB\-I\fR
XGives information about the program.
X.IP \fB\-a\fR
XSame as setting cghnpsu flags.  See below.
X.IP \fB\-c\fR
XWill echo comment about user, typically name in English.
X.IP \fB\-g\fR
XWill echo default group identifier (gid).
X.IP \fB\-h\fR
XWill echo home directory.
X.IP \fB\-n\fR
XWill echo user name.
X.IP \fB\-p\fR
XWill echo user encrypted password.
X.IP \fB\-r\fR
XWill report on exceptions to standard error, for example when groups are
Xnot found.
X.IP \fB\-s\fR
XWill echo default user shell.
X.IP \fB\-u\fR
XWill echo user numeric identifier (uid).
X.IP \fB\-v\fR
XTrue if the command is to work in \fBverbose\fR mode, not suitable for
Xbackquoting and echoing more information to standard output or standard
Xerror.
X.IP \fB-d\fR
XThe character following the option indication is used as a delimiter
Xbetween output fields.  The default is ':' in line with the format of 
Xthe \fB/etc/group\fR file.
X.IP \fB\-?\fR
XPresents brief help text to the user.  This option causes an error to
Xbe returned as no user number is echoed.
X.SH EXAMPLE
X.LP
X.nf
Xexample$ getpwnam -a
Xdtb:/j2cPZsqllg3Y:201:208:David T. Bath:/users/dtb:/.ucbbin/ksh
Xexample$ getpwnam -rvgun bin nosuch ftp dtb marg
Xgetpwnam: could not find user nosuch
Xusrname=bin:uid=2:gid=2
Xusrname=dtb:uid=201:gid=208
Xusrname=marg:uid=209:gid=208
Xexample$ getpwnam -vcnugs -d ,
Xusrname=dtb,uid=201,gid=208,comment=David T. Bath,shell=/.ucbbin/ksh
X.fi
X.ft R
X.RE
X.LP
X.SH DIAGNOSTICS
XThe following values may be returned to the calling process:
X.RS 
X.IP \fB0\fR
XNo errors noted
X.IP \fB1\fR 
XReturned when the user information is not available.
X.IP \fB12\fR
XENOMEM: Problem with memory.
X.IP \fB22\fR
XEINVAL: Invalid argument supplied.
X.SH FILES
X.B /etc/passwd
X.SH "SEE ALSO"
X.BR passwd(4)
X.BR geteuid(2)
X.BR getpwnam(2)
X.BR getpwuid(1L)
X.SH AUTHOR 
XDavid T. Bath dtb@otto.bf.rmit.oz.au
END_OF_FILE
if test 2402 -ne `wc -c <'getpwnam.1l'`; then
    echo shar: \"'getpwnam.1l'\" unpacked with wrong size!
fi
# end of 'getpwnam.1l'
fi
if test -f 'getpwnam.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getpwnam.c'\"
else
echo shar: Extracting \"'getpwnam.c'\" \(3026 characters\)
sed "s/^X//" >'getpwnam.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <errno.h>
X#include <pwd.h>
X#include "pwinf.h"
X#include <gnu/fileutil.h>
Xstatic char	*RCSid = "$Header: getpwnam.c,v 1.4 92/02/25 14:00:08 dtb Exp $";
X
Xint	fpr_usage();
Xint	process_it();
X
Xstatic int	report_except = 0;
Xstatic char	all_found     = 1;
Xstatic char	*trim_main_name;
X
X
Xint	main ( argc, argv, envp )
Xint	argc;
Xchar	**argv;
Xchar	**envp;
X{
X	char	*optstring = "acd:Ighnprsuv" ;
X	int	optchar;
X	extern char	*optarg;
X	extern int	optind;
X	extern int	opterr;
X	struct pwinfrq *pwinf;
X
X	trim_main_name = basename(*argv);
X	if ((pwinf = pwinfrq_set_dflt (NULL)) == NULL)
X		exit (ENOMEM);
X	opterr = 0;
X	while ((optchar = getopt(argc, argv, optstring)) != -1)
X		switch (optchar) {
X		case 'I':
X			fprintf (stderr, "%s %s\n", __FILE__, RCSid);
X			pwinf_info_fpr (stderr);
X			break;
X		case 'a':
X			pwinf->epw = pwinf->nam = pwinf->uid = pwinf->gid
X			     = pwinf->age = pwinf->cmt = pwinf->dir =
X			    pwinf->shl = 1;
X			break;
X		case 'c':
X			pwinf->cmt = 1;
X			break;
X		case 'd':
X			pwinf->dlm = *optarg;
X			break;
X		case 'g':
X			pwinf->gid = 1;
X			break;
X		case 'h':
X			pwinf->dir = 1;
X			break;
X		case 'n':
X			pwinf->nam = 1;
X			break;
X		case 'p':
X			pwinf->epw = 1;
X			break;
X		case 'r':
X			report_except = 1;
X			break;
X		case 's':
X			pwinf->shl = 1;
X			break;
X		case 'u':
X			pwinf->uid = 1;
X			break;
X		case 'v':
X			pwinf->vbs = 1;
X			break;
X		case '?':
X			fpr_usage (stderr);
X			exit (EINVAL);
X		}
X	if (optind == argc) {
X		struct passwd *pw = NULL;
X		char	unametmp[256];
X		char	*loginname = NULL;
X
X
X		if ((loginname = cuserid(NULL)) == NULL)
X			loginname = (char *) getlogin();
X		if (loginname != NULL) {
X			if ((pw = (struct passwd *) getpwnam (loginname))
X			    == NULL) {
X				fprintf (stderr, "%s: No password entry for %s\n",
X				     				    trim_main_name, loginname);
X				loginname = NULL;
X			}
X		}
X		if (loginname != NULL) {
X			strcpy (unametmp, loginname);
X		} else {
X			int	euid;
X
X			euid = getuid();
X			if ((pw = (struct passwd *) getpwuid (euid)) == NULL) {
X				unametmp[0] = '\0';
X			} else {
X				strcpy (unametmp, pw->pw_name);
X			}
X		}
X		/* 
X	    We need a temporary buffer for the current user name
X	    rather than passing pw->pw_name to process_it as the
X	    buffer pointed at by the returning getpwnam call will
X	    overwrite the passed parameter
X	    */
X		process_it (&unametmp[0], pwinf);
X	}
X	while (optind < argc) {
X		process_it (*(argv + optind++), pwinf);
X	}
X	exit (all_found ? 0 : 1);
X}
X
X
Xint	process_it( usrnam, pwinf)
Xchar	*usrnam;
Xstruct pwinfrq *pwinf;
X{
X	struct passwd *pwent;
X	int	nout = 0;
X
X	pwent = (struct passwd *) getpwnam ( usrnam );
X	if ( pwent == NULL) {
X		all_found = 0;
X		if (report_except) {
X			fprintf (stderr, "%s: could not find user %s\n",
X			     			    trim_main_name, usrnam);
X		}
X	} else {
X		nout = pwinf_fpr (stdout, pwent, pwinf);
X	}
X	return (nout);
X}
X
X
Xint	fpr_usage (fp)
XFILE 	*fp;
X{
X	int	nout = 0;
X	nout += fprintf (stderr,  "Usage: %s [-%s] [-%s] usrname [...]\n",
X	     	    trim_main_name, "Iacghnprsuv", "d char" );
X	return (nout);
X}
X
X
END_OF_FILE
if test 3026 -ne `wc -c <'getpwnam.c'`; then
    echo shar: \"'getpwnam.c'\" unpacked with wrong size!
fi
# end of 'getpwnam.c'
fi
if test -f 'getpwuid.1l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getpwuid.1l'\"
else
echo shar: Extracting \"'getpwuid.1l'\" \(2355 characters\)
sed "s/^X//" >'getpwuid.1l' <<'END_OF_FILE'
X.TH GETPWUID 1 LOCAL
X.SH NAME
Xgetpwnam \- User information from user numeric identifier
X.SH SYNOPSIS
X.B getpuid
X.I [-Iacghnprsuv] 
X.I [-d 
Xchar
X.I ] 
X[ uid ... ]
X.SH DESCRIPTION
X.LP
X.B getpwuid
Xechoes user information given a list of possible user numeric identifiers.
XError messages generated from within the
X.B getpwuid
Xutility are sent to stderr, not stdout, allowing the programmer to use
Xappropriate backquoting for this command.
X.LP
XIf no arguments are given, the current effective user id is assumed.
X.LP
X.SH USAGE
X.SS Options
X.I
X.IP \fB\-I\fR
XGives information about the program.
X.IP \fB\-a\fR
XSame as setting cghnpsu flags.  See below.
X.IP \fB\-c\fR
XWill echo comment about user, typically name in English.
X.IP \fB\-g\fR
XWill echo default group identifier (gid).
X.IP \fB\-h\fR
XWill echo home directory.
X.IP \fB\-n\fR
XWill echo user name.
X.IP \fB\-p\fR
XWill echo user encrypted password.
X.IP \fB\-r\fR
XWill report on exceptions to standard error, for example when groups are
Xnot found.
X.IP \fB\-s\fR
XWill echo default user shell.
X.IP \fB\-u\fR
XWill echo user numeric identifier (uid).
X.IP \fB\-v\fR
XTrue if the command is to work in \fBverbose\fR mode, not suitable for
Xbackquoting and echoing more information to standard output or standard
Xerror.
X.IP \fB-d\fR
XThe character following the option indication is used as a delimiter
Xbetween output fields.  The default is ':' in line with the format of 
Xthe \fB/etc/group\fR file.
X.IP \fB\-?\fR
XPresents brief help text to the user.  This option causes an error to
Xbe returned as no user number is echoed.
X.SH EXAMPLE
X.LP
X.nf
Xexample$ getpwuid -a
Xdtb:/j2cPZsqllg3Y:201:208:David T. Bath:/users/dtb:/.ucbbin/ksh
Xexample$ getpwuid -rvgun 0 99 201 209
Xgetpwuid: could not find user 99
Xusrname=root:uid=0:gid=0
Xusrname=dtb:uid=201:gid=208
Xusrname=marg:uid=209:gid=208
Xexample$ getpwuid -vcnugs -d ,
Xusrname=dtb,uid=201,gid=208,comment=David T. Bath,shell=/.ucbbin/ksh
X.fi
X.ft R
X.RE
X.LP
X.SH DIAGNOSTICS
XThe following values may be returned to the calling process:
X.RS 
X.IP \fB0\fR
XNo errors noted
X.IP \fB1\fR 
XReturned when the user information is not available.
X.IP \fB12\fR
XENOMEM: Problem with memory.
X.IP \fB22\fR
XEINVAL: Invalid argument supplied.
X.SH FILES
X.B /etc/passwd
X.SH "SEE ALSO"
X.BR passwd(4)
X.BR geteuid(2)
X.BR getpwuid(2)
X.BR getpwnam(1L)
X.SH AUTHOR 
XDavid T. Bath dtb@otto.bf.rmit.oz.au
END_OF_FILE
if test 2355 -ne `wc -c <'getpwuid.1l'`; then
    echo shar: \"'getpwuid.1l'\" unpacked with wrong size!
fi
# end of 'getpwuid.1l'
fi
if test -f 'getpwuid.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getpwuid.c'\"
else
echo shar: Extracting \"'getpwuid.c'\" \(2320 characters\)
sed "s/^X//" >'getpwuid.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <errno.h>
X#include <pwd.h>
X#include <gnu/fileutil.h>
X#include "pwinf.h"
X
Xstatic char *RCSid="$Header: getpwuid.c,v 1.3 92/02/25 14:00:10 dtb Exp $";
X
Xint 	fpr_usage();
Xint	process_it();
X
Xstatic int 	report_except = 0;
Xstatic char 	all_found     = 1;
Xstatic char 	*trim_main_name;
X
Xint	main ( argc, argv, envp )
Xint	argc;
Xchar	**argv;
Xchar	**envp;
X{
X	char		*optstring = "acd:Ighnprsuv" ;
X	int		optchar;
X	extern char	*optarg;
X	extern int	optind;
X	extern int	opterr;
X	struct pwinfrq 	*pwinf;
X
X	trim_main_name = basename(*argv);
X	if ((pwinf = pwinfrq_set_dflt (NULL)) == NULL)
X	    exit (ENOMEM);
X	opterr = 0;
X	while ((optchar = getopt(argc, argv, optstring)) != -1)
X		switch (optchar) {
X		case 'I':
X			fprintf (stderr, "%s %s\n", __FILE__, RCSid);
X			pwinf_info_fpr (stderr);
X			break;
X		case 'a':
X			pwinf->epw = pwinf->nam = pwinf->uid = pwinf->gid
X			    = pwinf->age = pwinf->cmt = pwinf->dir
X			    = pwinf->shl = 1;
X			break;
X		case 'c':
X			pwinf->cmt = 1;
X			break;
X		case 'd':
X			pwinf->dlm = *optarg;
X			break;
X		case 'g':
X			pwinf->gid = 1;
X			break;
X		case 'h':
X			pwinf->dir = 1;
X			break;
X		case 'n':
X			pwinf->nam = 1;
X			break;
X		case 'p':
X			pwinf->epw = 1;
X			break;
X		case 'r':
X			report_except = 1;
X			break;
X		case 's':
X			pwinf->shl = 1;
X			break;
X		case 'u':
X			pwinf->uid = 1;
X			break;
X		case 'v':
X			pwinf->vbs = 1;
X			break;
X		case '?':
X			fpr_usage (stderr);
X			exit (EINVAL);
X		}
X	if (optind == argc)
X	    process_it (geteuid(), pwinf);
X	while (optind < argc) {
X		int 	uid;
X		if (sscanf(*(argv+optind), "%d", &uid) != 1) {
X			fprintf (stderr, "%s: %s not a valid integer\n",
X			    trim_main_name, *(argv+optind));
X			exit (EINVAL);
X		}
X		process_it (uid, pwinf);
X		optind++;
X	}
X	exit (all_found ? 0 : 1);
X
X}
X
X
Xint	process_it( uid, pwinf)
Xint	uid;
Xstruct 	pwinfrq 	*pwinf;
X{
X	struct 	passwd *pwent;
X	int 	nout = 0;
X
X	pwent = (struct passwd *) getpwuid ( uid );
X	if ( pwent == NULL) {
X		all_found = 0;
X		if (report_except) {
X		    fprintf (stderr, "%s: could not find user %d\n",
X			trim_main_name, uid);
X		}
X	} else {
X		nout = pwinf_fpr (stdout, pwent, pwinf);
X	}
X	return (nout);
X}
X
X
Xint 	fpr_usage (fp)
XFILE 	*fp;
X{
X	int 	nout = 0;
X	nout += fprintf (stderr, 
X		"Usage: %s [-%s] [-%s] usrid [...]\n",
X		trim_main_name,
X		"Iacghnprsuv", "d char" );
X	return (nout);
X}
X
END_OF_FILE
if test 2320 -ne `wc -c <'getpwuid.c'`; then
    echo shar: \"'getpwuid.c'\" unpacked with wrong size!
fi
# end of 'getpwuid.c'
fi
if test -f 'getuid.1l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getuid.1l'\"
else
echo shar: Extracting \"'getuid.1l'\" \(501 characters\)
sed "s/^X//" >'getuid.1l' <<'END_OF_FILE'
X.TH GETUID 1 LOCAL
X.SH NAME
Xgetuid, geteuid, getgid, getgid \- get real user, effective user, real group, and effective group IDs
X.SH SYNOPSIS
X.B getuid
X.LP
X.B geteuid
X.LP
X.B getgid
X.LP
X.B getegid
X.SH DESCRIPTION
X.LP
X.B getid,
Xwhen linked to
X.B getuid,
X.B geteuid,
X.B getgid and
X.B getegid
Xechoes the identifexpect given the name similarity to the section 2 system
Xcalls of the same name.
X.SH "SEE ALSO"
X.BR getuid(2)
X.BR getpwnam(1L)
X.BR getgrnam(1L)
X.SH AUTHOR 
XDavid T. Bath dtb@otto.bf.rmit.oz.au
END_OF_FILE
if test 501 -ne `wc -c <'getuid.1l'`; then
    echo shar: \"'getuid.1l'\" unpacked with wrong size!
fi
# end of 'getuid.1l'
fi
if test -f 'grinf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'grinf.c'\"
else
echo shar: Extracting \"'grinf.c'\" \(2017 characters\)
sed "s/^X//" >'grinf.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <memory.h>
X#include <grp.h>
X#include "grinf.h"
X
Xstatic char *RCSid="$Header: grinf.c,v 1.4 92/01/23 15:05:34 dtb Exp $";
X
Xint 	grinf_info_fpr (fp)
XFILE 	* fp;
X{
X	int nout = 0;
X	nout += fprintf (fp, "%s %s\n", __FILE__, GRINF_RCSid);
X	return (nout);
X}
X
X/*
X    grinfrq_set_dflt
X	Puts default values in grinfrq structure.
X	A pointer to the structure is passed as an argument.
X	If a NULL pointer is used as an argument, then memory will
X	be allocated and a pointer to the new structure returned.
X	If a NULL pointer is returned, memory could not be allocated.
X*/
Xstruct grinfrq 	*	grinfrq_set_dflt ( p)
Xstruct grinfrq 	* 	p;
X{
X	if (p == NULL)
X		p = (struct grinfrq *) malloc ( sizeof (struct grinfrq) ) ;
X	if (p != NULL) {
X		(void) memset (p, 0, sizeof (struct grinfrq) );
X		p->dlm = GRINFRQ_DLM_DFLT ;
X		p->mdl = GRINFRQ_MDL_DFLT ; 
X	}
X	return (p);
X}
X
Xint 		grinf_fpr ( fp, grp, grinf)
XFILE 		* 	fp;
Xstruct 	group 	* 	grp;
Xstruct 	grinfrq * 	grinf;
X{
X	int 	nout = 0; 	/* Number of bytes output */
X	int 	dreq = 0; 	/* Is delimiter required */
X
X	if (grinf->nam) {
X		if (grinf->vbs)
X			nout += fprintf (fp, "gname=");
X		nout += fprintf (fp, "%s", grp->gr_name);
X		dreq = 1;
X	}
X	if (grinf->epw) {
X		if (dreq)
X			nout += fprintf (fp, "%c", grinf->dlm);
X		if (grinf->vbs)
X			nout += fprintf (fp, "pass=");
X		nout += fprintf (fp, "%s", grp->gr_passwd);
X	}
X	if (grinf->gid) {
X		if (dreq)
X			nout += fprintf (fp, "%c", grinf->dlm);
X		if (grinf->vbs)
X			nout += fprintf (fp, "gid=");
X		nout += fprintf (fp, "%d", grp->gr_gid);
X	}
X	if (grinf->mem) {
X		int mdreq = 0;
X		int mno = 0;
X		char **vmem = grp->gr_mem;
X		
X		if (dreq)
X			nout += fprintf (fp, "%c", grinf->dlm);
X		if (grinf->vbs)
X			nout += fprintf (fp, "members=");
X		for (; *vmem != NULL; vmem++) {
X		    if (mdreq) {
X			nout += fprintf (fp, "%c", grinf->mdl);
X		    }
X		    nout += fprintf (fp, "%s", *vmem);
X		    mdreq = 1;
X		}
X	}
X	if ( grinf->nam | grinf->epw | grinf->gid | grinf->mem )
X	    nout += fprintf (fp, "\n");
X	return (nout);
X}
X
X
END_OF_FILE
if test 2017 -ne `wc -c <'grinf.c'`; then
    echo shar: \"'grinf.c'\" unpacked with wrong size!
fi
# end of 'grinf.c'
fi
if test -f 'grinf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'grinf.h'\"
else
echo shar: Extracting \"'grinf.h'\" \(826 characters\)
sed "s/^X//" >'grinf.h' <<'END_OF_FILE'
X#ifndef GRINF_INCLUDED
X#define GRINF_INCLUDED
X
Xstatic char *GRINF_RCSid="$Header: grinf.h,v 1.3 91/10/28 10:39:42 dtb Exp $" ;
X
X/* Header for group information utilities by David T. Bath */
X
X/*
X    Structure for specification of group information required and
X    formatting requirements.
X*/
Xstruct 	grinfrq {
X	char 	nam; 	/* Boolean : group name required */
X	char 	epw; 	/* Boolean : encrypted password required */
X	char 	gid; 	/* Boolean : group id required */
X	char 	mem; 	/* Boolean : group member list required */
X	char 	vbs; 	/* Boolean : verbose output required */
X	char 	dlm; 	/* Delimiter between major fields */
X	char 	mdl; 	/* Delimiter between members */
X} ;
X
X#define GRINFRQ_DLM_DFLT ':'
X#define GRINFRQ_MDL_DFLT ','
X
Xstruct 	grinfrq * 	grinfrq_set_dflt ();
Xint 			grinf_fpr ();
Xint 			grinf_info_fpr ();
X
X#endif
END_OF_FILE
if test 826 -ne `wc -c <'grinf.h'`; then
    echo shar: \"'grinf.h'\" unpacked with wrong size!
fi
# end of 'grinf.h'
fi
if test -f 'pwinf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pwinf.c'\"
else
echo shar: Extracting \"'pwinf.c'\" \(2565 characters\)
sed "s/^X//" >'pwinf.c' <<'END_OF_FILE'
X
X#include <stdio.h>
X#include <memory.h>
X#include <pwd.h>
X#include "pwinf.h"
X
Xstatic char *RCSid="$Header: pwinf.c,v 1.1 91/10/28 10:38:25 dtb Exp $";
X
Xint 	pwinf_info_fpr (fp)
XFILE 	* fp;
X{
X	int nout = 0;
X	nout += fprintf (fp, "%s %s\n", __FILE__, PWINF_RCSid);
X	return (nout);
X}
X
X/*
X    pwinfrq_set_dflt
X	Puts default values in pwinfrq structure.
X	A pointer to the structure is passed as an argument.
X	If a NULL pointer is used as an argument, then memory will
X	be allocated and a pointer to the new structure returned.
X	If a NULL pointer is returned, memory could not be allocated.
X*/
Xstruct pwinfrq 	*	pwinfrq_set_dflt ( p)
Xstruct pwinfrq 	* 	p;
X{
X	if (p == NULL)
X		p = (struct pwinfrq *) malloc ( sizeof (struct pwinfrq) ) ;
X	if (p != NULL) {
X		(void) memset (p, 0, sizeof (struct pwinfrq) );
X		p->dlm = PWINFRQ_DLM_DFLT ;
X	}
X	return (p);
X}
X
Xint 		pwinf_fpr ( fp, pwd, pwinf)
XFILE 		* 	fp;
Xstruct 	passwd 	* 	pwd;
Xstruct 	pwinfrq * 	pwinf;
X{
X	int 	nout = 0; 	/* Number of bytes output */
X	int 	dreq = 0; 	/* Is delimiter required */
X
X	if (pwinf->nam) {
X		if (pwinf->vbs)
X			nout += fprintf (fp, "usrname=");
X		nout += fprintf (fp, "%s", pwd->pw_name);
X		dreq = 1;
X	}
X	if (pwinf->epw) {
X		if (dreq)
X			nout += fprintf (fp, "%c", pwinf->dlm);
X		if (pwinf->vbs)
X			nout += fprintf (fp, "pass=");
X		nout += fprintf (fp, "%s", pwd->pw_passwd);
X	}
X	if (pwinf->uid) {
X		if (dreq)
X			nout += fprintf (fp, "%c", pwinf->dlm);
X		if (pwinf->vbs)
X			nout += fprintf (fp, "uid=");
X		nout += fprintf (fp, "%d", pwd->pw_uid);
X	}
X	if (pwinf->gid) {
X		if (dreq)
X			nout += fprintf (fp, "%c", pwinf->dlm);
X		if (pwinf->vbs)
X			nout += fprintf (fp, "gid=");
X		nout += fprintf (fp, "%d", pwd->pw_gid);
X	}
X	/*
X	if (pwinf->age) {
X		if (dreq)
X			nout += fprintf (fp, "%c", pwinf->dlm);
X		if (pwinf->vbs)
X			nout += fprintf (fp, "age=");
X		nout += fprintf (fp, "%s", pwd->pw_age);
X	}
X	*/
X	if (pwinf->cmt) {
X		if (dreq)
X			nout += fprintf (fp, "%c", pwinf->dlm);
X		if (pwinf->vbs)
X			nout += fprintf (fp, "comment=");
X		nout += fprintf (fp, "%s", pwd->pw_comment);
X	}
X	if (pwinf->dir) {
X		if (dreq)
X			nout += fprintf (fp, "%c", pwinf->dlm);
X		if (pwinf->vbs)
X			nout += fprintf (fp, "home_dir=");
X		nout += fprintf (fp, "%s", pwd->pw_dir);
X	}
X	if (pwinf->shl) {
X		if (dreq)
X			nout += fprintf (fp, "%c", pwinf->dlm);
X		if (pwinf->vbs)
X			nout += fprintf (fp, "shell=");
X		nout += fprintf (fp, "%s", pwd->pw_shell);
X	}
X	if ( pwinf->nam | pwinf->epw | pwinf->uid | pwinf->gid | pwinf->age 
X	    | pwinf->cmt | pwinf->dir | pwinf->shl )
X	    nout += fprintf (fp, "\n");
X	return (nout);
X}
X
END_OF_FILE
if test 2565 -ne `wc -c <'pwinf.c'`; then
    echo shar: \"'pwinf.c'\" unpacked with wrong size!
fi
# end of 'pwinf.c'
fi
if test -f 'pwinf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pwinf.h'\"
else
echo shar: Extracting \"'pwinf.h'\" \(948 characters\)
sed "s/^X//" >'pwinf.h' <<'END_OF_FILE'
X#ifndef PWINF_INCLUDED
X#define PWINF_INCLUDED
X
Xstatic char *PWINF_RCSid="$Header: pwinf.h,v 1.1 91/10/28 10:39:58 dtb Exp $" ;
X
X/* Header for passwd information utilities by David T. Bath */
X
X/*
X    Structure for specification of passwd information required and
X    formatting requirements.
X*/
Xstruct 	pwinfrq {
X	char 	nam; 	/* Boolean : user name required */
X	char 	epw; 	/* Boolean : encrypted password required */
X	char 	uid; 	/* Boolean : user id required */
X	char 	gid; 	/* Boolean : group id required */
X	char 	age; 	/* Boolean : age information required */
X	char 	cmt; 	/* Boolean : comment required */
X	char 	dir; 	/* Boolean : home directory required */
X	char 	shl; 	/* Boolean : initial shell required */
X	char 	vbs; 	/* Boolean : verbose output required */
X	char 	dlm; 	/* Delimiter between major fields */
X} ;
X
X#define PWINFRQ_DLM_DFLT ':'
X
Xstruct 	pwinfrq * 	pwinfrq_set_dflt ();
Xint 			pwinf_fpr ();
Xint 			pwinf_info_fpr ();
X
X#endif
END_OF_FILE
if test 948 -ne `wc -c <'pwinf.h'`; then
    echo shar: \"'pwinf.h'\" unpacked with wrong size!
fi
# end of 'pwinf.h'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
