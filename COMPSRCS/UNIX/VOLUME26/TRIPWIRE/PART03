Newsgroups: comp.sources.unix
From: spaf@cs.purdue.edu (Gene Spafford)
Subject: v26i175: tripwire - security integrity monitor, Part03/08
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: spaf@cs.purdue.edu (Gene Spafford)
Posting-Number: Volume 26, Issue 175
Archive-Name: tripwire/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 8)."
# Contents:  tripwire-1.0 tripwire-1.0/sigs tripwire-1.0/sigs/crc32
#   tripwire-1.0/sigs/md4 tripwire-1.0/sigs/md5 tripwire-1.0/src
#   tripwire-1.0/tests tripwire-1.0/tests/tw.db_TEST
#   tripwire-1.0/sigs/md5/md5.doc tripwire-1.0/src/list.c
#   tripwire-1.0/sigs/md4/Makefile tripwire-1.0/sigs/crc32/crc32.h
# Wrapped by spaf@uther.cs.purdue.edu on Tue Nov  3 16:31:55 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'tripwire-1.0' ; then
    echo shar: Creating directory \"'tripwire-1.0'\"
    mkdir 'tripwire-1.0'
fi
if test ! -d 'tripwire-1.0/sigs' ; then
    echo shar: Creating directory \"'tripwire-1.0/sigs'\"
    mkdir 'tripwire-1.0/sigs'
fi
if test ! -d 'tripwire-1.0/sigs/crc32' ; then
    echo shar: Creating directory \"'tripwire-1.0/sigs/crc32'\"
    mkdir 'tripwire-1.0/sigs/crc32'
fi
if test ! -d 'tripwire-1.0/sigs/md4' ; then
    echo shar: Creating directory \"'tripwire-1.0/sigs/md4'\"
    mkdir 'tripwire-1.0/sigs/md4'
fi
if test ! -d 'tripwire-1.0/sigs/md5' ; then
    echo shar: Creating directory \"'tripwire-1.0/sigs/md5'\"
    mkdir 'tripwire-1.0/sigs/md5'
fi
if test ! -d 'tripwire-1.0/src' ; then
    echo shar: Creating directory \"'tripwire-1.0/src'\"
    mkdir 'tripwire-1.0/src'
fi
if test ! -d 'tripwire-1.0/tests' ; then
    echo shar: Creating directory \"'tripwire-1.0/tests'\"
    mkdir 'tripwire-1.0/tests'
fi
if test -f 'tripwire-1.0/tests/tw.db_TEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.0/tests/tw.db_TEST'\"
else
echo shar: Extracting \"'tripwire-1.0/tests/tw.db_TEST'\" \(23405 characters\)
sed "s/^X//" >'tripwire-1.0/tests/tw.db_TEST' <<'END_OF_FILE'
X# Generated by Tripwire, version 1.0 on Tue Nov  3 16:15:43 1992
X@@dbaseversion 1
X/tmp/genek/tripwire-1.0 0 ....5P 40700 51200 12 31018 0 512 .exijy .exiiT .exijt 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/aux 0 ....5P 40700 14336 2 31018 0 512 .exijv .exiiU .exijR 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/aux/types.c 0 ....5P 100600 14337 1 31018 0 1419 .exijQ .exihR .exijQ 0 1H8c6q.HR0nJ16mAQP0nNdh3 /28KZJ.2dvXE0w2a5G15.ln6 .Uovet ...BfA 1SpDHr1Hwj/I.PfrHy/3pt0Q 15rFUi.Xy3KE1M9Qe7.DzU/V 0 0 0 
X/tmp/genek/tripwire-1.0/aux/ntohl.h 0 ....5P 100600 14340 1 31018 0 741 .exijQ .exihS .exijQ 0 0OvjLH103I5P08/w3N176YOi /x/TSN1BrCRB1dC4N0.V1eEC /4dh1. ...8yb 1d7Rb/1aTWFp/pg2do0qL94N /l3Cb01XK4g713Ub6z1cCoR5 0 0 0 
X/tmp/genek/tripwire-1.0/aux/Makefile 0 ....5P 100600 14345 1 31018 0 492 .exijQ .exihS .exijQ 0 14LI1b1.NFLI/xvHZG.O9VIq .Xi8bq.kgYmE/ma.i01AY2xW 0IHz2S ...0rJ 002gbU/NnjeF1YrWbl/8dfWX .c8C.5/x7vVR0kcQhW/dr/5i 0 0 0 
X/tmp/genek/tripwire-1.0/aux/byteorder.c 0 ....5P 100600 14346 1 31018 0 687 .exijQ .exihS .exijQ 0 /9v0Gz0abyKf089Qtl1Jpf3/ 0wuooS1DwM5E16QPAg.XMpio 0/hCnd ...4cp /nxsBQ1e6jvB/hFOCy.w0OPI /dQZDN/kg4KS0dA41a1oW548 0 0 0 
X/tmp/genek/tripwire-1.0/aux/types.sh 0 ....5P 100700 14347 1 31018 0 1153 .exijR .exihT .exijR 0 01HqdM1aPed4.oqIS50odnSP 01FbKv/ndLwY0pwCB2.5bIbl .c5V8R .../Ay .WE94a0GfAFi0kk0gc0TzQAa 1gWYmJ1SI4wk0N5yqF0kA0Vb 0 0 0 
X/tmp/genek/tripwire-1.0/lib 0 ....5P 40700 43008 2 31018 0 512 .exijv .exiiV .exijR 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/lib/tw.config 0 ....5P 100600 43018 1 31018 0 4132 .exijR .exihU .exijR 0 0N20tV/XBLYJ.es9y10QbeRL 0heWH01g/3vy.l3OP91dmGtO 0JcCMX ...9g5 .18jtG1EQ7j/0CA0ZG/r96kR /891/S/27/fl1hfhwu.JSfUB 0 0 0 
X/tmp/genek/tripwire-1.0/README 0 ....5P 100600 51203 1 31018 0 29570 .exijR .exihV .exijR 0 /NfOYR/F4ntU1EhLVu1cymnD .PiCkR0mRUjC/yB5Or.UwjpK /Nrku4 ...DS2 /m4Jsd14Q4Fy.BO0BX0UbLYQ /vouxa1GoRdA1gPlvO.0DP6s 0 0 0 
X/tmp/genek/tripwire-1.0/databases 2 ../zzz 40700 51205 2 31018 0 24 .exijy .exiih .exijS 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/Ported 0 ....5P 100600 51207 1 31018 0 6820 .exijS .exihW .exijS 0 0n00Dc/z3/bC13fCU1/hZ33n 0TU5tQ.0KyW71iZJzf/8V3Zd 1Kys.i ...3xx .3FOlG1nl3Gz1.P/fP1d6kOK /xzTLU1AjUPR.4obJr.07j2J 0 0 0 
X/tmp/genek/tripwire-1.0/TODO 0 ....5P 100600 51208 1 31018 0 485 .exijS .exihW .exijS 0 00Zlic.7DcJx/XufDO1YrL2f .fVfVm18VhZm0KOHj11hUNoT .Q2Zsl ...Dea /Vz5tC.8.HZV1OoFX0.R295U 1EieKB0tOvXm1BGoSS0oB.p0 0 0 0 
X/tmp/genek/tripwire-1.0/Changelog 0 ....5P 100600 51209 1 31018 0 6891 .exijS .exihX .exijS 0 .lYmGK..8Kqj.L41Oj.1QIa7 0796ZX0NFZKH0HQ44q.Ovl8a .UyZnL ...6kP 1WunNg./8ntj/dUxvx.EFjvr 0TUa7m.B0CT81hT9fF.4a1pD 0 0 0 
X/tmp/genek/tripwire-1.0/FAQ 0 ....5P 100600 51210 1 31018 0 2127 .exijS .exihX .exijS 0 1o8lmk.9gnty1nnMkt0C1tMe 0IvgUc0nsFfc/wptS115jSWu 01Q5AY ...BTN 1jIqXR/zbQsE1xWt3W.GREV4 /q8ime/3M6.F.pNFvm1MJWzm 0 0 0 
X/tmp/genek/tripwire-1.0/configs 0 ....5P 40700 4096 2 31018 0 1024 .exijw .exiiV .exijX 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-aix.h 0 ....5P 100600 4098 1 31018 0 985 .exijS .exihY .exijS 0 0EtLXL/9qv7m/PoBGs1kjsQv 0NrrKp0Usuda.RCHYa/V3MaS 193CRp ...2vB /iYPnJ0jofjD.ID7w30lx4Ir /XO4WS1mPj/l0xGOQ4.xc9T2 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-aux3.h 0 ....5P 100600 4107 1 31018 0 1014 .exijS .exihY .exijS 0 0sOrCj.CY2eV1.oBer/O0t3n .KngT0/juynf/L4ITG1XxQDu 0.OjHe ...8wH 1kaLvJ/B4fU9.UB/9z/EtxZs 0JcXsZ/GngLa.LNuze1CypHb 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-bsd.h 0 ....5P 100600 4108 1 31018 0 869 .exijT .exihZ .exijT 0 /m3I3b0JOa3i/Wg5FH/Ro49i /T/VYV0lkLyV.FhU.S//fmVA 0zhRVs .../B2 .lEiMG1afey200ac2k/6apOo .kd/420bTGiS09IN5T1S3S.z 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-dynix.h 0 ....5P 100600 4109 1 31018 0 873 .exijT .exihZ .exijT 0 ./RwWR1T704q.bDseG.bbMe3 0kPDVc0kPpLA1T8ktb0LeTqg 0z8bxN ...CRn 0/1a3S1k10Vq.mSeZ00ET8Eh /mhOXl0pNVCp.0uNhL1OI798 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-epix.h 0 ....5P 100600 4110 1 31018 0 844 .exijT .exihZ .exijT 0 /i1iTL/kjbi11kWaep1EVXaS /irPd5.FpvIv1AXGWe.g7bkT /GQxvK ...3.8 0WsHzL/bPMQL0P7UPt1RZlon 04tZxN1f7H8t00g2vp/jlLYa 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-hpux.h 0 ....5P 100600 4111 1 31018 0 995 .exijT .exihZ .exijT 0 0ziYYN0GVGuG/17YfD/SGUdu 0EmV6M1qkR4k0H8GDM.y9bMe 16FDBA ...2v7 /1tsRx.fyyEq1lhrRz0TdRKb 0sIeqI.ru6iQ1Fvx7T10.NOR 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-irix4.h 0 ....5P 100600 4112 1 31018 0 951 .exijT .exihZ .exijT 0 /D3ayV/SaLRC1S9ZQv/yWn6y 0N4Vtq0ooyCi0wvde7.X9U6x 0PrqNf ...8Gi /Gm1fq/rM.kO/gYAh21w0k8F .V5QNr/GJhPr0HXrl8.y2udz 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-mach.h 0 ....5P 100600 4113 1 31018 0 1119 .exijU .exihb .exijU 0 1S4mAt.PLHqe0jVC7v.ZICLT .dgBWk1cvc/d0qzfwP/nBC6t 0Mzx9U ...3Tq 1aHFDi/vsdhQ0nduO81nNKJk 1olfU8.wm0xD1KVm2r0FvaaJ 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-osf1.h 0 ....5P 100600 4114 1 31018 0 921 .exijU .exihb .exijU 0 0d5glk/Q9pVJ.c3J0T1AYqCp 0Uzq64/F.Atb.SIYFJ0csmNF 0HnZfh ...9.0 /lBCbI1drCEx0HNvu5/dVHQw 1M1it90wSbeA.gTevz/ML1La 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-osx-att.h 0 ....5P 100600 4115 1 31018 0 755 .exijU .exihb .exijU 0 .MWtCn16zn4r1uuqXg1D3Irx 1m/W1H/Bm0Eh/6scop/InfQb 1epMyZ ...2YP /sFYUd/D3rWz/Sc.Vm1oFBVW /20CwV.r06N2/.SFta0hnCN6 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-osx-ucb.h 0 ....5P 100600 4116 1 31018 0 806 .exijU .exihc .exijU 0 .r9iQ5/n5fwu0h7jea1A5FHT /yTmzx1AmAgb1wyV771AorD8 0kGvuY ...79c .t0/ib/wxoDq0tv.6d1IcGCd .VdWQQ.6ZPEs/mSmGw.cokAz 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-riscos.h 0 ....5P 100600 4117 1 31018 0 960 .exijU .exihc .exijU 0 .O6iBs1ELUJu.Nfw/60XriSl 07R2Af/ALKWs/8Oygr0hSXDE .EXBVg ...0.h /paSUQ1r4NXS/87J590X6189 .Pl0Pe0XpEh31.vSdH/61/i1 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-sunos-4.0.h 0 ....5P 100600 4118 1 31018 0 914 .exijV .exihc .exijV 0 /540g4/aEVTm0A3ZYV0ylZRZ 1nZqpc/ktTfU/q0UEa/AT58b 0hxc08 ...87w 1gOVs91EyRDe.tm1Lo/w4Fpk 1Ym.w9.LD9370.7BA1.kKc9h 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-sunos-4.1.h 0 ....5P 100600 4119 1 31018 0 909 .exijV .exihd .exijV 0 0QfpK91pec8./CSZsG1VCFu2 /P973l/Z1FuF1PafPP0a2kSy .4srjd ...1ru 1jq2j6/sGnX40F02S1/vdgVe .pzEg91886P3.Ts3Si1OfZlX 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-svr3.h 0 ....5P 100600 4120 1 31018 0 936 .exijV .exihd .exijV 0 .Ovslg.vNknA1NVPjp.VbBxS .0XMbt/g2VqR0UbMVE/o4yo2 .ZKoL5 ...3jw 1YKayF1J0qm606gfPU/JiOni 0.BCW6.z3CnU/pRljY1cZKDa 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-svr4.h 0 ....5P 100600 4121 1 31018 0 876 .exijV .exihd .exijV 0 .a0Bwc0e5atl1Hizrx0DQvbq .vY4rY0avyn./LVEXX.ypsc. 04C9.4 .../Ye 1johQZ0UIeqh1nFKLt0X4hZ. 0Es/x9/lxGAK1K3UOX/eu1Aw 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-umaxv.h 0 ....5P 100600 4122 1 31018 0 1019 .exijV .exihd .exijV 0 0aILx6.mVHtx/nWbjT.URNyS /OTNOw064C4y.v5k9408uK0t 02m9hD ...3tI /mRbeM.89jiY0/exjB/BPS93 13jdt60CtzFb0bBg5t05FlVp 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-unicos.h 0 ....5P 100600 4123 1 31018 0 1034 .exijV .exihd .exijV 0 09thVS/0oF9K0C.0tn1EuP/O /BhUR40MDw970IsK4r1d6J7. 0PGWnV ...7fI .OXtd./dSkgP1aMTFZ0gek23 0a.2qA/9iak4/iMZAh//N8vl 0 0 0 
X/tmp/genek/tripwire-1.0/configs/tw.conf.hp2 0 ....5P 100600 4124 1 31018 0 5418 .exijV .exihd .exijV 0 11/UDu0uGKrX.q.YXr.Lzn2F 054nfL.9SsPv/wO57r18kOJV 16Vh/X ...1xV /JUAz60SAymj1EhfNW.oUA7X 1Tw5rM1meaNY/iFymZ0AIb23 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-xenix.h 0 ....5P 100600 4125 1 31018 0 977 .exijV .exihe .exijV 0 .BbBAk1LGY0X.9NQEc0yrEbI /m.w8h/JtWS8/kgCmU10XRpz 1.L.9m ...7Jj /OuWDd099zME0TWEj10oCEW. .jtGvV15Eh/o.TckyI0d1ErG 0 0 0 
X/tmp/genek/tripwire-1.0/configs/tw.conf.hpux 0 ....5P 100600 4126 1 31018 0 1776 .exijV .exihe .exijV 0 0fyZSE.TISum/krent170e27 09UxWL1zyE9c1efdtP//vmWN 1xPDw0 ...9kL 1J68kd1WV13J/OCcWN1oC6yo .Qt50B/OcnNe0caifC1U7dTq 0 0 0 
X/tmp/genek/tripwire-1.0/configs/tw.conf.next 0 ....5P 100600 4128 1 31018 0 2892 .exijV .exihe .exijV 0 .Gl7VF/DB5hD/pbbcA.d2V95 .wkEYi04C8eC/JnUh/147TJi .R65ez ...4Ki .t.PBn00ZSpb.m1uGH1j5QlY .cj.sj.eOiwv1dm2ji1doHkC 0 0 0 
X/tmp/genek/tripwire-1.0/configs/tw.conf.s5 0 ....5P 100600 4129 1 31018 0 4729 .exijW .exihe .exijW 0 0v4bvn/AUDpF1QobUF0FWWBW 1RchRx..2ucy.jvY12.iNrmG 0RTy/N ...3vg .h68sL0vrss/0MHkHA0CtmO3 .7hxlC0.itmZ1SdAli08fVbR 0 0 0 
X/tmp/genek/tripwire-1.0/configs/tw.conf.sun 0 ....5P 100600 4130 1 31018 0 5298 .exijW .exihe .exijW 0 1ZnLvo.2IWxk/Oh8oo0yiRUY 1.HoGO0VLhn//o59cc/Ppfc1 .Y2QGn ...1dN /5drxP1nsOr40Pr5cx1ZcVm7 /pFAeb1PyQsG1Jinh41FhgWy 0 0 0 
X/tmp/genek/tripwire-1.0/configs/tw.conf.ultrix 0 ....5P 100600 4131 1 31018 0 592 .exijW .exihe .exijW 0 .3JV811IETxa0VyHms0z14bz 1hX96X.BaqI6.91P.G0Pfb/a /o40p9 ...Dgq .Y1LVe/vU8av/M5dDQ0fiv70 0/TLsC.ps.VA1KZR0O.WsT.P 0 0 0 
X/tmp/genek/tripwire-1.0/configs/conf-convex.h 0 ....5P 100600 4132 1 31018 0 961 .exijW .exihe .exijW 0 .DqGdJ.wFxL2/UEZQ30.sUtI .BTa.l0BIrgY/6UnzH18Dkri .IrMtN ...60r 1RLgEN16TLDD/uES7d/t20Ks .5I/0O/xp/yC1CEYk60Mlw6L 0 0 0 
X/tmp/genek/tripwire-1.0/configs/Makefile.xenix 0 ....5P 100600 4133 1 31018 0 5278 .exijW .exihe .exijW 0 0vOdnW1OLz/k.jMvzF.J86NF .KGc660pOVM30brixx.n8dzm 0ZCbWO ...7wp /nm5Zh19UssQ.4Eop21xKieH 06CfCS/Hu2Ce0OTW1o1FEcGR 0 0 0 
X/tmp/genek/tripwire-1.0/contrib 0 ....5P 40700 10242 2 31018 0 512 .exijw .exiiW .exijZ 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/contrib/README.ASET 0 ....5P 100600 10254 1 31018 0 27138 .exijX .exihg .exijX 0 //7QTk/PgFYy.z5AD8/ttn/1 .bCFNI1P8Sr/.pYehl.aGC4k /8j3SZ ...76R 0UBtiR0PVEGO1L8A.T1jYkOE 07r74i1z2txK/SOOoI0KYaZM 0 0 0 
X/tmp/genek/tripwire-1.0/contrib/CheckConfig 0 ....5P 100700 10255 1 31018 0 618 .exijX .exihg .exijX 0 /.PD0W15YehF/Cy69L04Z1Wd 0hhDqo.ZLApV/3PSM4.k/EbF /BVFUs ...9aa .Hzo1x.fgWHi0n6Ekv.ENzWI 1b3fKS1q7qoh0tLZl6/SYLHn 0 0 0 
X/tmp/genek/tripwire-1.0/contrib/README.CheckConfig 0 ....5P 100600 10256 1 31018 0 1216 .exijX .exihg .exijX 0 0Ppomg/Tg.L20bETYs0fP2no .Xc1NM0TM4Sv.MgTzC.nU5mG 17NJhb ...6Tz /hZPDm1jP24N1Z9SPd0wdt66 1gcKFP17n1TA15aZk50XlcPG 0 0 0 
X/tmp/genek/tripwire-1.0/contrib/README.TRIPWIRE 0 ....5P 100600 10257 1 31018 0 3136 .exijX .exihg .exijX 0 /.ue0P1zxrsy0Yx5d/.21Z0j .SM6hG0tW0Ct.Y7ql0.v1VY4 /Hl4W. ...0.o 1PDKPQ/sQnEr10mRwT/cHKcx /ss2Va/JVzrp//ZQ96/b/qfP 0 0 0 
X/tmp/genek/tripwire-1.0/contrib/README.chk 0 ....5P 100600 10258 1 31018 0 622 .exijX .exihg .exijX 0 .M5yO8/JFOb1/a2ZEd.x3e6h .N9ltK.L6xuA/wJPQx0wr8vP 08Kwiz ...CiF /9tzdL/9WLun/6WPCL.f1TWM 0BmKBt1srlcS0ch8UP.iImBU 0 0 0 
X/tmp/genek/tripwire-1.0/contrib/TRIPWIRE 0 ....5P 100700 10259 1 31018 0 569 .exijY .exihg .exijY 0 1MRglJ1D5rAm/InVH0.Up6yI 1Vgsq4.qlQq/1R5zyt0jNh18 .8mN9G ...09M .Ray/x/le5jX.oj61E0CfBQV 1pk04a0yY3WQ1UHm0h.Tui/y 0 0 0 
X/tmp/genek/tripwire-1.0/contrib/tripwire.chk 0 ....5P 100700 10260 1 31018 0 458 .exijY .exihg .exijY 0 .Jc8rG.LRBLZ/0KXw8/6GNs8 0US0NP/chto81XbgYk.xcZMk .cKh.y ...28b .D.0Rh/ySAnm/iOMcy1jQ2b6 09kIye1FjpNd.M7uh6/cDGL0 0 0 0 
X/tmp/genek/tripwire-1.0/include 0 ....5P 40700 14349 2 31018 0 512 .exijx .exiih .exija 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/include/patchlevel.h 0 ....5P 100600 14357 1 31018 0 86 .exijZ .exihh .exijZ 0 .gnkSo0SYIQW0UlEG2/el0bp 0S5jn90w9F1n.RpxTE0AGILb /s3HgJ ...09g /A5bHL1EB5ZT1IzB0D1jOCEJ 0KEu381fd23M0GauJj.LXCiS 0 0 0 
X/tmp/genek/tripwire-1.0/include/list.h 0 ....5P 100600 14383 1 31018 0 1541 .exijZ .exihi .exijZ 0 /fF4He0M2dMI/3TqcG.M17mC 1g3hMU1umN62.ZzT.u.qlaYz /LVjrG ...1YI /qxa4w0j5lD11KtVnQ1HCwHL 1H3cIy1BDI6S1byWLz1oguWX 0 0 0 
X/tmp/genek/tripwire-1.0/include/tripwire.h 0 ....5P 100600 14384 1 31018 0 7233 .exija .exihi .exija 0 .qDxAV0yckmH0E33Qc.IjXXJ 0B89LT.t7kft.6q7Xf/VPOkM 0K11Ez ...3LG 0Pzggy0EWd5O.KTLr50WhQm1 /68Vn8/6XxiI0wQWth0X0Qy/ 0 0 0 
X/tmp/genek/tripwire-1.0/include/sigs.h 0 ....5P 100600 14385 1 31018 0 613 .exija .exihi .exija 0 /hAfN..MjMmK.NVFb81dGnTF 1r91TP/z3oZc.9voWX1.eNep .EHxxi ...BqE .nOHS/0SOUgn.LUtCg.NweQw 1kJL621DCHJd0szgo5/mrU7m 0 0 0 
X/tmp/genek/tripwire-1.0/man 0 ....5P 40700 16384 2 31018 0 512 .exijx .exiiX .exijb 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/man/tripwire.8 0 ....5P 100600 16385 1 31018 0 7596 .exija .exihl .exija 0 08tWdo.QwqBG1kqYIt/q5TQ7 0BmShx/kgIeS/PT5uX11HUH9 .qBXWe ...3Ya .Mkifa.vmThE19eQNf15yxIB .iEQZ7/mSBeL0DicwM02t97R 0 0 0 
X/tmp/genek/tripwire-1.0/man/Makefile 0 ....5P 100600 16390 1 31018 0 176 .exija .exihl .exija 0 .bfCp//AURO90ffQo8/5SBcm .V.UUs0WlyP01.yWLU.9.cqa 0vIvWe ...C5z 0xUP4D.895hY03Y2MD//sWqc 1cea5P0lQXf5.2Uw1g.7G1Lb 0 0 0 
X/tmp/genek/tripwire-1.0/man/sigfetch.8 0 ....5P 100600 16391 1 31018 0 761 .exijb .exihl .exijb 0 0tb3ER0gMJQK.a8Og5/3NAJJ .KInnp1NmIre0HF7gu/l3wq2 1Up3BX ...C6M 19lWZM15GAMY01.A0x0A1DVw .nBhYJ0sPjKC0WtFbp.RDTuQ 0 0 0 
X/tmp/genek/tripwire-1.0/man/tw.config.5 0 ....5P 100600 16392 1 31018 0 7470 .exijb .exihl .exijb 0 /ILTFM/LMeuo0veAt11S7MbW /mL9Ge.PLEsX/GkEd.0kPUp8 1LOzTD ...BzV 0OpEWi/pEvUf15ajTw.rh8F2 1ZyUF/1z1ABW/gIzeW/Skccs 0 0 0 
X/tmp/genek/tripwire-1.0/sigs 0 ....5P 40700 18432 8 31018 0 512 .exijy .exiiY .exijn 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/crc 0 ....5P 40700 20481 2 31018 0 512 .exijx .exiiY .exijc 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/crc/Makefile 0 ....5P 100600 20483 1 31018 0 238 .exijc .exihr .exijc 0 /YKxSV/DsaDs/SFjnF0THVtC .QMrrK0Mb2qa1IynZo/URQyt .BaMb7 ...8.t .3gfbU/h6R0L.IvMix1wd0SR 1v6Oaj0dqL5q0a5n5m1LYldp 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/crc/crc.c 0 ....5P 100600 20484 1 31018 0 6511 .exijc .exihr .exijc 0 /D5R.U1MY/Pl1vd.qr/nq8QS 0qIi.j.DFghQ.7/Pjd1qQefu 0DKuKO ....9Q 0yk3K4/jqsp7.61IqF0jhKzb .1rl58.sp9zq.LY1TJ15OIhX 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/crc/crc.h 0 ....5P 100600 20487 1 31018 0 77 .exijc .exihr .exijc 0 .RWsUg0rCtYR1/FkrK1HWVq8 /WNRnG1paTN8.5LOuR.mqKy1 /1Vk9d ...8uu 0u2DTE.1YN2b.FFQXy/GYKIc .zf0lk..OK0i1vquTE1BAg3a 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/crc32 0 ....5P 40700 22531 2 31018 0 512 .exijx .exiiZ .exijd 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/crc32/Makefile 0 ....5P 100600 22536 1 31018 0 238 .exijd .exihw .exijd 0 /D.BWf.5Oj7l0hEQ6n/c7Onk 1lvnGE1SE/9T/4xPd8/13TkO .C4akD ...9qW .3gfbU/h6R0L.IvMix1wd0SR /5iAvA0nAdoL0OZp8p1LNk.M 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/crc32/crc32.c 0 ....5P 100600 22559 1 31018 0 8219 .exijd .exihw .exijd 0 06OoUl/6Crbo..Sp1x1BzpKB 0G2bo61RvO.a.eifxL0D4OTV /sqRs5 ...1Oh /cYQzd.R3/AE/9aCUZ.ZR4yc 0R8Ptl.8pPaG/hCn8W0JLa/j 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/crc32/crc32.h 0 ....5P 100600 22560 1 31018 0 81 .exijd .exihw .exijd 0 1CE3OO.3zwMi.rRKxe0fS3dj /30TU./JAUfP.FLnWK1zJYAs 1BzPI4 ...DPp .XzmQb/adio0.4VlPc1smfIq 1YhRSU.4dYrC/yCfWA.awQFL 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md2 0 ....5P 40700 24580 2 31018 0 512 .exijx .exiia .exijf 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md2/Makefile 0 ....5P 100600 24581 1 31018 0 289 .exije .exihx .exije 0 0gUb3V/5Lr7c/FDtEz1cPJdn /1Mpxv.60qr80ZEsGL1LEKoE /CpLLG ...3Gy /W7XV8/5u8GI/eWmuh/cEpWN /WBt.z/P3wn9/Jkyql.LVBLc 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md2/global.h 0 ....5P 100600 24584 1 31018 0 858 .exije .exihx .exije 0 0o9h6R1uvzEq0YedjG0tm3AM .KSZYM1o/Vnl0JKlLc/iRh/e 1BmBo7 ...Bb/ /5fnfR0GVb2U1dDjIS.0z4B7 11LG8q0976JB0WVH4d/diDNi 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md2/md2.c 0 ....5P 100600 24585 1 31018 0 7130 .exije .exihx .exije 0 .ZSRGw/pI3oZ1zcnEE04DNTE .Rskkv/.EdJh05xOaw.oqYvP /II/V8 ...7gR 1d2h1014uV1y.vimRb0p2YfJ /U40iJ1B/HFj0m.adQ.HpdfA 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md2/md2.h 0 ....5P 100600 24589 1 31018 0 1216 .exije .exihx .exije 0 /WHrUD0gkiLS1SXHUS.Vg6jX .cw/a3/f/4mR.8YCqj/81laO 1cIQCP ...4Ht /4igh9/I4De6/.ysj6/hcn/w 0azs6/.dGlu80pn0Jk1deK5M 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md2/md2wrapper.c 0 ....5P 100600 24590 1 31018 0 2177 .exijf .exihx .exijf 0 .dkN/r.Q31bx/lyMSj020w25 /GEisV1O/EHq0OH6wB.16phL 1SyKV8 ...2jG .iBJo2.RdU/x1cd3rJ1OBxd5 /nPGRE/bemAF1t7crT.nJXZL 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md4 0 ....5P 40700 26624 2 31018 0 512 .exijx .exiib .exijh 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md4/Makefile 0 ....5P 100600 26626 1 31018 0 306 .exijg .exihz .exijg 0 0qfw8G.kKrJb18ACno/f.Gel 0ssnyO.Cuct0/A4xkB.ibrn. 06FuXE ...DhW .brLGy0JftVS.QuI.W1BEdEW 1adWm1.J45wT1Ser/20NRacp 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md4/md4.c 0 ....5P 100600 26629 1 31018 0 9435 .exijg .exihz .exijg 0 .nOzmI0Exocr/1riUd1ouuHh 1uNNcS1eKwwX0VGN6M0WtLYm .Z0cA6 ...03. /qcU2D.deZE4.FpmHB1xJrKG .B9QhH/shK0R0qLf7w/h2BPk 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md4/md4.h 0 ....5P 100600 26630 1 31018 0 1922 .exijg .exii. .exijg 0 .Ul92U1MJoV00vzPMT13/q.C .6dj//1bhgig.HXT4r1t7055 1mOTXe ...APw .v.Bqc/hRU4W/hAliF1GL2bc 1f7VPa/QgVps/zNGLa0r290R 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md4/md4wrapper.c 0 ....5P 100600 26641 1 31018 0 1915 .exijg .exii. .exijg 0 0jJ1Rz.Wh1Xg0vtuWJ0n8eAc 0YsLCL0D0MMh1jyYjC0haCIp 1R2t2A ...580 /hoZ2w/67asU.VUmHs1UDrqc /4zkyi0pW96e1Kw9v21Pg8CO 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md5 0 ....5P 40700 36865 2 31018 0 512 .exijy .exiib .exijm 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md5/Makefile 0 ....5P 100600 36866 1 31018 0 305 .exijh .exii0 .exijh 0 .yD.xZ1uMA.T1TGp/O.MaQjv /KInLr18eDuR.KWnUH01yPha 0/qlWt .../8t 1Sf3c21YnHVs.nWWh6/50ZMR 1HtZiq1BBBO10LFyps.Bz.zu 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md5/README.md5 0 ....5P 100600 36867 1 31018 0 2577 .exijh .exii0 .exijh 0 .mPgvL0aqaW81VWNcT/c5AZt 1Zqczb.Pcx/z08AC8i/8vg0x 1r8EED ...C0d 1iq55n1mPyZ8/yfVXR0Iae8O /F6llU/ATZoB04AF9d1QHiHE 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md5/md5.c 0 ....5P 100600 36868 1 31018 0 10291 .exijk .exii0 .exijk 0 05d7Li/Pu5wR.RzUyy.p9VwQ /oPstU.Vb.4w0L2ePq/UJI/S /160AY ...8AY .1zb38/7.MOx07Hf9F0iXDqL 0Phmrk0MPYds/fSw5B1y3Gwg 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md5/md5.doc 0 ....5P 100600 36869 1 31018 0 19066 .exijl .exii0 .exijl 0 /dLp.d0/aWoT1vF1G610yXLx 0W86/X00iksg.Zp/dg.8mFBo /N9cuU ...0W9 0cAUz6/WE/Uo.YZ2PD1HvtDF .1kuF1.NLftC0xIEvw/oonVz 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md5/md5.h 0 ....5P 100600 36887 1 31018 0 1019 .exijl .exii1 .exijl 0 1wTREX0mhfVN1BNIs4/N9Kwp 1joNOa.QWNxr/ATmtN.JlkTb /BkP4X ...AfX .iu1Ua0atQ0B/v4.QJ.ey2xJ 1UxFz51Ok42./C/waS.fGct7 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/md5/md5wrapper.c 0 ....5P 100600 36888 1 31018 0 2121 .exijl .exii1 .exijl 0 1w5W3d./abJS.6VF9U0nbB86 .aV7OY/Kug/k0fEBlO1XkUSt /LSL61 ...0ne 0.At2n/ZgJhd1sLBPV/M2vY9 1TqdKe.K33At0V3ZPQ0biKrR 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/snefru 0 ....5P 40700 38913 2 31018 0 512 .exijy .exiie .exijn 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/snefru/Makefile 0 ....5P 100600 38916 1 31018 0 246 .exijn .exii3 .exijn 0 0E7xMF0v/25S1Bm.2l/4O5gP 1P4cY01oprbj/c1EF1.BNAuw 0de1zN ...8Pd /tCBnh.8gidF0iKLqy1XcR5R .dY9aw01MqQA/Ls3vT.sOWQI 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/snefru/README.snefru 0 ....5P 100600 38922 1 31018 0 8502 .exijn .exii3 .exijn 0 1Gnglh.en6mY1B/W4L/swo.g /u8m17.RepeN/puZCJ.ljYkH /4o6FR ...7pG .YV6.D0SjYy00Qc8h21I6pX9 0SjSuZ12Iw26.9yITJ0Lbtmz 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/snefru/snefru.c 0 ....5P 100600 38930 1 31018 0 78896 .exijn .exii3 .exijn 0 /5Bj32135rkX.WIoy6.WL.CD /nntHr/uHAdZ.DKXkX/mRaQ4 /yIh.n ....F5 057kum.O.q.w19qJuW.7Zfj3 .SR1gZ.r61N0/M2mRi/bIKmT 0 0 0 
X/tmp/genek/tripwire-1.0/sigs/snefru/snefru.h 0 ....5P 100600 38931 1 31018 0 22 .exijn .exii3 .exijn 0 1aZg/w//cRe10kLzca1MnRe5 1DqjoB..Mcrf.5Irn00/0fJ0 /4m2gz ...9Is 1331DZ1swhQY.swblq/C.ZKh 0w3EOe/G6ViD..ftJ2.nuFb7 0 0 0 
X/tmp/genek/tripwire-1.0/src 0 ....5P 40700 40967 2 31018 0 512 .exijy .exiig .exijs 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/src/config.pre.l 0 ....5P 100600 40972 1 31018 0 1728 .exijo .exiiA .exijo 0 /EfQ4n1p/kRc/60WyS.a86/Y 1HU4YA.qHu/r/6rZCF04m52Y .rAKXh ...BPV /kH3l20kl66s1AXLbG.WUwjC /cCC010WfnGu.taMJs12ZAWD 0 0 0 
X/tmp/genek/tripwire-1.0/src/config.pre.y 0 ....5P 100600 40973 1 31018 0 9777 .exijo .exiiA .exijo 0 .h4Qa.0uRdxe1qFusk/zrxl. .PbGtS1J4bCk.eQQ0X1Oe1D5 00.CCv ...CgB .ZSEtm.mx9YD0UL/0g0WnGp. .GhTqd15sTep19r94C/dO8Vc 0 0 0 
X/tmp/genek/tripwire-1.0/src/config.prim.c 0 ....5P 100600 40974 1 31018 0 2728 .exijo .exiiB .exijo 0 0Tqzqh/Jfh.Y.Zb3ST/5BknF /hEISU154z2P/7qGT..Mjget 0KHH5Z ....ML /J4Gu1.7OwND/8W8xj04cnmh 1mnLxM01Xqps0s9VMK/eHC3V 0 0 0 
X/tmp/genek/tripwire-1.0/src/dbase.update.c 0 ....5P 100600 40975 1 31018 0 1599 .exijo .exiiC .exijo 0 /BGuhV04IHe6.MtHJM1kEe0r /kDEzi17fCRm0g6Mhd/a8KBI 0UaKML ...DEQ 1taIvS1Wq4UV/mTT8z1zzGKD 0QasDx0crSN80X68Nw.Ey55t 0 0 0 
X/tmp/genek/tripwire-1.0/src/ignorevec.c 0 ....5P 100600 40984 1 31018 0 3545 .exijo .exiiC .exijo 0 .7O1g21g0Maz1Kz4Ow1evm90 /UDtJD.COate/6EdaG/618Ku .EGc6q .../7M /GdpxG.mIlzP1zyvs9/sETjT .KXYC1/q1k5T.tBxK8/tLuZ6 0 0 0 
X/tmp/genek/tripwire-1.0/src/list.c 0 ....5P 100600 40985 1 31018 0 17081 .exijp .exiiC .exijp 0 /NUjEy/oQI50.4gsAg0.KsCI 1q/4Cz0tvvZ51I6r9z/BDVVW 1D2LWC ...Dkn 0SdmsB/xroW91WX13K.jmFeT 142JQk/H0VQ2.lRbvq1C9w87 0 0 0 
X/tmp/genek/tripwire-1.0/src/main.c 0 ....5P 100600 40986 1 31018 0 10112 .exijp .exiiC .exijp 0 1/BMUg/Bj8Bj0vGcgB1wnyF3 0nL7Yh/6sORL11BC2.0tY7QH /UoTnS ...0QD /ynFVa.J/YV8/RUD0l.C32Ug .lEDEA0MzCC9.RfI64/rYhpF 0 0 0 
X/tmp/genek/tripwire-1.0/src/nullsig.c 0 ....5P 100600 40987 1 31018 0 992 .exijp .exiiC .exijp 0 .x.xKv.cR/w50rFnd31PRH5s /iEGuk.bwEeV/rhvH60D57sl 14TSw6 ...04M 1w.0ID1RMk041UMtEU/uLgvX .r7P.V.CmbCm116VqK.8nbEi 0 0 0 
X/tmp/genek/tripwire-1.0/src/preen.c 0 ....5P 100600 40988 1 31018 0 4868 .exijp .exiiC .exijp 0 .YA6d./kUdFQ1zWabC/IKKCe 1zPldI0w..sX/4oky50XIw7. 018Unm .../Du /N4sM412T/AB.dR7uA.jF4nV 1F87Kn1wenw1.Mom81/UoWdu 0 0 0 
X/tmp/genek/tripwire-1.0/src/preen.interp.c 0 ....5P 100600 40989 1 31018 0 2618 .exijp .exiiD .exijp 0 1mNiE/.Q7PcP/v2VeW0Kjd5t 0pBkpZ/YevPi/DmzT..MmOFY .1OsXC ...8Wp /stnvH.sodId0RTHCG0FBnMd 0WxgqT./HnQK//.f4k.MH1A. 0 0 0 
X/tmp/genek/tripwire-1.0/src/preen.report.c 0 ....5P 100600 40990 1 31018 0 15903 .exijp .exiiD .exijp 0 .UnE3X.0ATcD1bGGeb0UHIcP .Q00NY0yCk0K0qFY2d/w18e7 .TAfOX ...1T3 0kVqbl0OjTE5/LaLlC/JSjiE /r3y6m1VpQFU..h0B809w7U5 0 0 0 
X/tmp/genek/tripwire-1.0/src/Makefile 0 ....5P 100600 40991 1 31018 0 7439 .exijq .exiiD .exijq 0 .J5p4p0EFx8j.OgC8Q1fpM.W 0BXFKS.6.3651XJ.XL1j9pjO 1mWivQ ...9zW /cvaB208RTNI1VkvHR08hF/e /NHzCt0OlKw11NjVcV1EgdUk 0 0 0 
X/tmp/genek/tripwire-1.0/src/utils.c 0 ....5P 100600 40992 1 31018 0 13384 .exijq .exiiE .exijq 0 .nm3S./tf5kL0cUsAs.9zH3d 1Lw4uh1b9YFD.nbqUf.UMZa/ 0cpm6l ...Cnm 0aSzc5.68f7m/mDT1l0Zi0sj /q8Zf40/1bHl0aM/1g/fUYXx 0 0 0 
X/tmp/genek/tripwire-1.0/src/dbase.build.c 0 ....5P 100600 40993 1 31018 0 10027 .exijq .exiiF .exijq 0 0V5WPq1wLs2U.gk8nz/clc7W 0DOfQ.0cKHAX.p0US60HHp3I 18BBCY ...D.M 0pB2w80aGxI7.P4FRU/gBKmO /wxlQx.fsbqk0w8BgG0p0Iy5 0 0 0 
X/tmp/genek/tripwire-1.0/src/sigfetch.c 0 ....5P 100600 40994 1 31018 0 3168 .exijr .exiiG .exijr 0 /M.nXI.PpYvU.17uya/C91Ei /kXZ6P.4PnT/040sER.z09lQ .pqKZx ...Dt4 .jE1hm/8jSJq.hvRc3/zq6a8 /OqmS7.em6Bb1AJhlx/qLDUQ 0 0 0 
X/tmp/genek/tripwire-1.0/src/config.parse.c 0 ....5P 100600 40995 1 31018 0 13058 .exijr .exiiH .exijr 0 /d7AKE.tjzGQ.80piF/6F523 ..fdrs.17GVv.Qlz.10hWwW2 .zeOCj ....gP /hxKMX0d/i3z/g2nHb1jNVZG /Cyqmb/2hJ12.Wfweg.g5LkS 0 0 0 
X/tmp/genek/tripwire-1.0/tests 1 ../zzz 40700 32768 2 31018 0 512 .exijy .exiig .exijt 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/tests/tw.conf.test 1 ../zzz 100600 32784 1 31018 0 4659 .exijs .exiiJ .exijs 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/tests/Makefile 1 ../zzz 100600 32793 1 31018 0 280 .exijs .exiiJ .exijs 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/tests/test1.sh 1 ../zzz 100600 32794 1 31018 0 1412 .exijs .exiiJ .exijs 0 0 0 0 0 0 0 0 0 0 
X/tmp/genek/tripwire-1.0/tests/tw.db_TEST 1 ../zzz 100600 32795 1 31018 0 23648 .exijt .exiiJ .exijt 0 0 0 0 0 0 0 0 0 0 
X@@contents /tmp/genek/tripwire-1.0 0
X@@contents /tmp/genek/tripwire-1.0/tests 1
X@@contents /tmp/genek/tripwire-1.0/databases 2
END_OF_FILE
if test 23405 -ne `wc -c <'tripwire-1.0/tests/tw.db_TEST'`; then
    echo shar: \"'tripwire-1.0/tests/tw.db_TEST'\" unpacked with wrong size!
fi
# end of 'tripwire-1.0/tests/tw.db_TEST'
fi
if test -f 'tripwire-1.0/sigs/md5/md5.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.0/sigs/md5/md5.doc'\"
else
echo shar: Extracting \"'tripwire-1.0/sigs/md5/md5.doc'\" \(19066 characters\)
sed "s/^X//" >'tripwire-1.0/sigs/md5/md5.doc' <<'END_OF_FILE'
X
X
X
X
XNetwork Working Group                                          R. Rivest
XINTERNET-DRAFT                       MIT Laboratory for Computer Science
X                                                                S. Dusse
X                                                 RSA Data Security, Inc.
X                                                            10 July 1991
X
X
X                    The MD5 Message-Digest Algorithm
X
X
XSTATUS OF THIS MEMO
X
X   This draft document will be submitted to the RFC editor as a protocol
X   specification. Comments should be sent to <pem-dev@tis.com> or to the
X   authors. Distribution of this memo is unlimited.
X
X
XACKNOWLEDGEMENT
X
X   We would like to thank Don Coppersmith, Burt Kaliski, Ralph Merkle,
X   David Chaum, and Noam Nisan for numerous helpful comments and
X   suggestions.
X
X
XTable of Contents
X
X   1. Executive Summary                                                1
X   2. Terminology and Notation                                         2
X   3. MD5 Algorithm Description                                        3
X   4. Summary                                                          7
X   5. Summary of Differences Between MD4 and MD5                       7
X   6. Security Considerations                                          7
X   References                                                          8
X   Authors' Addresses                                                  8
X   APPENDIX - Reference Implementation                                 9
X
X
X
X1. Executive Summary
X
X   This document describes the MD5 message-digest algorithm. The
X   algorithm takes as input an input message of arbitrary length and
X   produces as output a 128-bit "fingerprint" or "message digest" of the
X   input. It is conjectured that it is computationally infeasible to
X   produce two messages having the same message digest, or to produce
X   any message having a given prespecified target message digest. The
X   MD5 algorithm is intended for digital signature applications, where a
X   large file must be "compressed" in a secure manner before being
X   encrypted with a private (secret) key under a public-key cryptosystem
X   such as RSA.
X
X
X
X
XRivest and Dusse                                                [Page 1]
XINTERNET-DRAFT      The MD5 Message-Digest Algorithm        10 July 1991
X
X
X   The MD5 algorithm is designed to be quite fast on 32-bit machines. In
X   addition, the MD5 algorithm does not require any large substitution
X   tables; the algorithm can be coded quite compactly.
X
X   The MD5 algorithm is an extension of the MD4 message digest algorithm
X   [1,2]. MD5 is slightly slower than MD4, but is more "conservative" in
X   design. MD5 was designed because it was felt that MD4 was perhaps
X   being adopted for use more quickly than justified by the existing
X   critical review; because MD4 was designed to be exceptionally fast,
X   it is "at the edge" in terms of risking successful cryptanalytic
X   attack. MD5 backs off a bit, giving up a little in speed for a much
X   greater likelihood of ultimate security. It incorporates some
X   suggestions made by various reviewers, and contains additional
X   optimizations.
X
X   The MD5 algorithm is being placed in the public domain for review and
X   possible adoption as a standard.
X
X   A version of this document including the C source code in the
X   appendix is available by FTP from RSA.COM in the file "pub/md5.doc".
X
X   This document may be referred to, unofficially, as Internet draft
X   [MD5-A].
X
X   For OSI-based applications, MD5's object identifier is
X
X   md5 OBJECT IDENTIFIER ::=
X     {iso(1) member-body(2) US(840) rsadsi(113549) digestAlgorithm(2) 5}
X
X   In the X.509 type AlgorithmIdentifier [3], the parameters for MD5
X   should have type NULL.
X
X
X2. Terminology and Notation
X
X   In this document a "word" is a 32-bit quantity and a "byte" is an
X   eight-bit quantity. A sequence of bits can be interpreted in a
X   natural manner as a sequence of bytes, where each consecutive group
X   of eight bits is interpreted as a byte with the high-order (most
X   significant) bit of each byte listed first. Similarly, a sequence of
X   bytes can be interpreted as a sequence of 32-bit words, where each
X   consecutive group of four bytes is interpreted as a word with the
X   low-order (least significant) byte given first.
X
X   Let x_i denote "x sub i". If the subscript is an expression, we
X   surround it in braces, as in x_{i+1}. Similarly, we use ^ for
X   superscripts (exponentiation), so that x^i denotes x to the i-th
X   power.
X
X   Let the symbol "+" denote addition of words (i.e., modulo-2^32
X   addition). Let X <<< s denote the 32-bit value obtained by circularly
X   shifting (rotating) X left by s bit positions. Let not(X) denote the
X
X
XRivest and Dusse                                                [Page 2]
XINTERNET-DRAFT      The MD5 Message-Digest Algorithm        10 July 1991
X
X
X   bit-wise complement of X, and let X v Y denote the bit-wise OR of X
X   and Y. Let X xor Y denote the bit-wise XOR of X and Y, and let XY
X   denote the bit-wise AND of X and Y.
X
X
X3. MD5 Algorithm Description
X
X   We begin by supposing that we have a b-bit message as input, and that
X   we wish to find its message digest. Here b is an arbitrary
X   nonnegative integer; b may be zero, it need not be a multiple of
X   eight, and it may be arbitrarily large. We imagine the bits of the
X   message written down as follows:
X
X                            m_0 m_1 ... m_{b-1}
X
X   The following five steps are performed to compute the message digest
X   of the message.
X
X
X3.1 Step 1. Append Padding Bits
X
X   The message is "padded" (extended) so that its length (in bits) is
X   congruent to 448, modulo 512. That is, the message is extended so
X   that it is just 64 bits shy of being a multiple of 512 bits long.
X   Padding is always performed, even if the length of the message is
X   already congruent to 448, modulo 512 (in which case 512 bits of
X   padding are added).
X
X   Padding is performed as follows: a single "1" bit is appended to the
X   message, and then enough zero bits are appended so that the length in
X   bits of the padded message becomes congruent to 448, modulo 512.
X
X
X3.2 Step 2. Append Length
X
X   A 64-bit representation of b (the length of the message before the
X   padding bits were added) is appended to the result of the previous
X   step. In the unlikely event that b is greater than 2^64, then only
X   the low-order 64 bits of b are used. (These bits are appended as two
X   32-bit words and appended low-order word first in accordance with the
X   previous conventions.)
X
X   At this point the resulting message (after padding with bits and with
X   b) has a length that is an exact multiple of 512 bits. Equivalently,
X   this message has a length that is an exact multiple of 16 (32-bit)
X   words. Let M[0 ... N-1] denote the words of the resulting message,
X   where N is a multiple of 16.
X
X
X
X
X
X
X
XRivest and Dusse                                                [Page 3]
XINTERNET-DRAFT      The MD5 Message-Digest Algorithm        10 July 1991
X
X
X3.3 Step 3. Initialize MD Buffer
X
X   A four-word buffer (A,B,C,D) is used to compute the message digest.
X   Here each of A, B, C, D is a 32-bit register. These registers are
X   initialized to the following values in hexadecimal, low-order bytes
X   first):
X
X                            word A: 01 23 45 67
X                            word B: 89 ab cd ef
X                            word C: fe dc ba 98
X                            word D: 76 54 32 10
X
X
X3.4 Step 4. Process Message in 16-Word Blocks
X
X   We first define four auxiliary functions that each take as input
X   three 32-bit words and produce as output one 32-bit word.
X
X                         F(X,Y,Z) = XY v not(X) Z
X                         G(X,Y,Z) = XZ v Y not(Z)
X                         H(X,Y,Z) = X xor Y xor Z
X                       I(X,Y,Z) = Y xor (X v not(Z))
X
X   In each bit position F acts as a conditional: if X then Y else Z.
X   (The function F could have been defined using + instead of v since XY
X   and not(X)Z will never have 1's in the same bit position.) It is
X   interesting to note that if the bits of X, Y, and Z are independent
X   and unbiased, the each bit of F(X,Y,Z) will be independent and
X   unbiased.
X
X   The functions G, H, and I are similar to the function F, in that they
X   act in "bitwise parallel" to produce their output from the bits of X,
X   Y, and Z, in such a manner that if the corresponding bits of X, Y,
X   and Z are independent and unbiased, then each bit of G(X,Y,Z),
X   H(X,Y,Z), and I(X,Y,Z) will be independent and unbiased. Note that
X   the function H is the bit-wise "xor" or "parity" function of its
X   inputs.
X
X   Do the following:
X
X   /* Process each 16-word block. */
X   For i = 0 to N/16-1 do
X
X       /* Copy block i into X. */
X       For j = 0 to 15 do
X           Set X[j] to M[i*16+j].
X       end /* of loop on j */
X
X       /* Save A as AA, B as BB, C as CC, and D as DD. */
X       AA = A
X       BB = B
X       CC = C
X
X
XRivest and Dusse                                                [Page 4]
XINTERNET-DRAFT      The MD5 Message-Digest Algorithm        10 July 1991
X
X
X       DD = D
X
X       /* Round 1. */
X       /* Let FF(a,b,c,d,X[k],s,t) denote the operation
X           a = b + ((a + F(b,c,d) + X[k] + t) <<< s). */
X       /* Here the additive constants t are chosen as follows:
X          In step i, the additive constant is the integer part of
X          4294967296 times abs(sin(i)), where i is in radians. */
X       /* Let S11 = 7, S12 = 12, S13 = 17, and S14 = 22. */
X       /* Do the following 16 operations. */
X       FF (a, b, c, d, X[ 0], S11, 3614090360); /* Step 1 */
X       FF (d, a, b, c, X[ 1], S12, 3905402710); /* 2 */
X       FF (c, d, a, b, X[ 2], S13,  606105819); /* 3 */
X       FF (b, c, d, a, X[ 3], S14, 3250441966); /* 4 */
X       FF (a, b, c, d, X[ 4], S11, 4118548399); /* 5 */
X       FF (d, a, b, c, X[ 5], S12, 1200080426); /* 6 */
X       FF (c, d, a, b, X[ 6], S13, 2821735955); /* 7 */
X       FF (b, c, d, a, X[ 7], S14, 4249261313); /* 8 */
X       FF (a, b, c, d, X[ 8], S11, 1770035416); /* 9 */
X       FF (d, a, b, c, X[ 9], S12, 2336552879); /* 10 */
X       FF (c, d, a, b, X[10], S13, 4294925233); /* 11 */
X       FF (b, c, d, a, X[11], S14, 2304563134); /* 12 */
X       FF (a, b, c, d, X[12], S11, 1804603682); /* 13 */
X       FF (d, a, b, c, X[13], S12, 4254626195); /* 14 */
X       FF (c, d, a, b, X[14], S13, 2792965006); /* 15 */
X       FF (b, c, d, a, X[15], S14, 1236535329); /* 16 */
X
X       /* Round 2. */
X       /* Let GG(a,b,c,d,X[k],s,t) denote the operation
X           a = b + ((a + G(b,c,d) + X[k] + t) <<< s). */
X       /* Let S21 = 5, S22 = 9, S23 = 14, and S24 = 20. */
X
X       /* Do the following 16 operations. */
X       GG (a, b, c, d, X[ 1], S21, 4129170786); /* 17 */
X       GG (d, a, b, c, X[ 6], S22, 3225465664); /* 18 */
X       GG (c, d, a, b, X[11], S23,  643717713); /* 19 */
X       GG (b, c, d, a, X[ 0], S24, 3921069994); /* 20 */
X       GG (a, b, c, d, X[ 5], S21, 3593408605); /* 21 */
X       GG (d, a, b, c, X[10], S22,   38016083); /* 22 */
X       GG (c, d, a, b, X[15], S23, 3634488961); /* 23 */
X       GG (b, c, d, a, X[ 4], S24, 3889429448); /* 24 */
X       GG (a, b, c, d, X[ 9], S21,  568446438); /* 25 */
X       GG (d, a, b, c, X[14], S22, 3275163606); /* 26 */
X       GG (c, d, a, b, X[ 3], S23, 4107603335); /* 27 */
X       GG (b, c, d, a, X[ 8], S24, 1163531501); /* 28 */
X       GG (a, b, c, d, X[13], S21, 2850285829); /* 29 */
X       GG (d, a, b, c, X[ 2], S22, 4243563512); /* 30 */
X       GG (c, d, a, b, X[ 7], S23, 1735328473); /* 31 */
X       GG (b, c, d, a, X[12], S24, 2368359562); /* 32 */
X
X       /* Round 3. */
X       /* Let HH(a,b,c,d,X[k],s,t) denote the operation
X
X
XRivest and Dusse                                                [Page 5]
XINTERNET-DRAFT      The MD5 Message-Digest Algorithm        10 July 1991
X
X
X           a = b + ((a + H(b,c,d) + X[k] + t) <<< s). */
X       /* Let S31 = 4, S32 = 11, S33 = 16, and S34 = 23. */
X
X       /* Do the following 16 operations. */
X       HH (a, b, c, d, X[ 5], S31, 4294588738); /* 33 */
X       HH (d, a, b, c, X[ 8], S32, 2272392833); /* 34 */
X       HH (c, d, a, b, X[11], S33, 1839030562); /* 35 */
X       HH (b, c, d, a, X[14], S34, 4259657740); /* 36 */
X       HH (a, b, c, d, X[ 1], S31, 2763975236); /* 37 */
X       HH (d, a, b, c, X[ 4], S32, 1272893353); /* 38 */
X       HH (c, d, a, b, X[ 7], S33, 4139469664); /* 39 */
X       HH (b, c, d, a, X[10], S34, 3200236656); /* 40 */
X       HH (a, b, c, d, X[13], S31,  681279174); /* 41 */
X       HH (d, a, b, c, X[ 0], S32, 3936430074); /* 42 */
X       HH (c, d, a, b, X[ 3], S33, 3572445317); /* 43 */
X       HH (b, c, d, a, X[ 6], S34,   76029189); /* 44 */
X       HH (a, b, c, d, X[ 9], S31, 3654602809); /* 45 */
X       HH (d, a, b, c, X[12], S32, 3873151461); /* 46 */
X       HH (c, d, a, b, X[15], S33,  530742520); /* 47 */
X       HH (b, c, d, a, X[ 2], S34, 3299628645); /* 48 */
X
X       /* Round 4. */
X       /* Let II(a,b,c,d,X[k],s,t) denote the operation
X           a = b + ((a + I(b,c,d) + X[k] + t) <<< s). */
X       /* Let S41 = 6, S42 = 10, S43 = 15, and S44 = 21. */
X
X       /* Do the following 16 operations. */
X       II (a, b, c, d, X[ 0], S41, 4096336452); /* 49 */
X       II (d, a, b, c, X[ 7], S42, 1126891415); /* 50 */
X       II (c, d, a, b, X[14], S43, 2878612391); /* 51 */
X       II (b, c, d, a, X[ 5], S44, 4237533241); /* 52 */
X       II (a, b, c, d, X[12], S41, 1700485571); /* 53 */
X       II (d, a, b, c, X[ 3], S42, 2399980690); /* 54 */
X       II (c, d, a, b, X[10], S43, 4293915773); /* 55 */
X       II (b, c, d, a, X[ 1], S44, 2240044497); /* 56 */
X       II (a, b, c, d, X[ 8], S41, 1873313359); /* 57 */
X       II (d, a, b, c, X[15], S42, 4264355552); /* 58 */
X       II (c, d, a, b, X[ 6], S43, 2734768916); /* 59 */
X       II (b, c, d, a, X[13], S44, 1309151649); /* 60 */
X       II (a, b, c, d, X[ 4], S41, 4149444226); /* 61 */
X       II (d, a, b, c, X[11], S42, 3174756917); /* 62 */
X       II (c, d, a, b, X[ 2], S43,  718787259); /* 63 */
X       II (b, c, d, a, X[ 9], S44, 3951481745); /* 64 */
X
X       /* Then perform the following additions. (That is, increment each
X          of the four registers by the value it had before this block
X          was started.) */
X       A = A + AA
X       B = B + BB
X       C = C + CC
X       D = D + DD
X
X
X
XRivest and Dusse                                                [Page 6]
XINTERNET-DRAFT      The MD5 Message-Digest Algorithm        10 July 1991
X
X
X
X   end /* of loop on i */
X
X
X3.5 Step 5. Output
X
X   The message digest produced as output is A, B, C, D. That is, we
X   begin with the low-order byte of A, and end with the high-order byte
X   of D.
X
X   This completes the description of MD5. A reference implementation in
X   C is given in the Appendix.
X
X
X4. Summary
X
X   The MD5 message-digest algorithm is simple to implement, and provides
X   a "fingerprint" or message digest of a message of arbitrary length.
X   It is conjectured that the difficulty of coming up with two messages
X   having the same message digest is on the order of 2^64 operations,
X   and that the difficulty of coming up with any message having a given
X   message digest is on the order of 2^128 operations. The MD5 algorithm
X   has been carefully scrutinized for weaknesses. It is, however, a
X   relatively new algorithm and further security analysis is of course
X   justified, as is the case with any new proposal of this sort.
X
X
X5. Summary of Differences Between MD4 and MD5
X
X   The following are the differences between MD4 and MD5:
X
X     --   A fourth round has been added.
X
X     --   Each step now has a unique additive constant.
X
X     --   The function g in round 2 was changed from (XY v XZ v YZ)
X          to (XZ v Y not(Z)) to make g less symmetric.
X
X     --   Each step now adds in the result of the previous step.
X          This promotes a faster "avalanche effect".
X
X     --   The order in which input words are accessed in rounds 2
X          and 3 is changed, to make these patterns less like each
X          other.
X
X     --   The shift amounts in each round have been approximately
X          optimized, to yield a faster "avalanche effect". The
X          shifts in different rounds are distinct.
X
X
X
X
X
X
XRivest and Dusse                                                [Page 7]
XINTERNET-DRAFT      The MD5 Message-Digest Algorithm        10 July 1991
X
X
X6. Security Considerations
X
X   The level of security discussed in this memo is considered to be
X   sufficient for implementing very high security hybrid digital-
X   signature schemes based on MD5 and a public-key cryptosystem.
X
X
XReferences
X
X     [1]  Rivest, R.L., The MD4 Message Digest Algorithm (RFC 1186),
X          October 1990.
X
X     [2]  Rivest, R.L., The MD4 message digest algorithm, presented at
X          CRYPTO '90 (Santa Barbara, CA, August 11-15, 1990).
X
X     [3]  CCITT, The Directory---Authentication Framework
X          (Recommendation X.509), 1988.
X
X
X
X
XAuthors' Addresses
X
X   Ronald L. Rivest
X   Massachusetts Institute of Technology
X   Laboratory for Computer Science
X   NE43-324
X   545 Technology Square
X   Cambridge, MA  02139-1986
X   Phone: (617) 253-5880
X   EMail: rivest@theory.lcs.mit.edu
X
X   Steve Dusse
X   RSA Data Security, Inc.
X   10 Twin Dolphin Drive
X   Redwood City, CA  94065
X   Phone: (415) 595-8782
X   EMail: dusse@rsa.com
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
XRivest and Dusse                                                [Page 8]
XINTERNET-DRAFT      The MD5 Message-Digest Algorithm        10 July 1991
X
X
X
XAPPENDIX - Reference Implementation
X
X   This appendix contains the following files:
X
X     md5.h -- header file for implementation of MD5
X
X     md5.c -- the source code for MD5 routines
X
X     md5driver.c -- sample test routines
X
X     session -- sample results of running md5driver
X
X   It is not difficult to improve this implementation on particular
X   platforms, an exercise left to the reader. Following are some
X   suggestions:
X
X     1.   Change MD5Update so that the context is not used at all
X          if it is empty (mdi == 0) and 64 or more bytes remain
X          (inLen >= 64). In other words, call Transform with inBuf
X          in this case. (This requires that byte ordering is
X          correct in inBuf.)
X
X     2.   Implement a procedure MD5UpdateLong modeled after
X          MD5Update where inBuf is UINT4 * instead of unsigned char
X          *. MD5UpdateLong would call Transform directly with 16-
X          word blocks from inBuf. Call this instead of MD5Update in
X          general. This works well if you have an I/O procedure
X          that can read long words from a file.
X
X     3.   On "little-endian" platforms where the lowest-address
X          byte in a long word is the least significant (and there
X          are no alignment restrictions), change MD5Update to call
X          Transform directly with 64-byte blocks from inBuf
X          (typecast to a UINT4 *).
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
XRivest and Dusse                                                [Page 9]
XINTERNET-DRAFT      The MD5 Message-Digest Algorithm        10 July 1991
X
X
END_OF_FILE
if test 19066 -ne `wc -c <'tripwire-1.0/sigs/md5/md5.doc'`; then
    echo shar: \"'tripwire-1.0/sigs/md5/md5.doc'\" unpacked with wrong size!
fi
# end of 'tripwire-1.0/sigs/md5/md5.doc'
fi
if test -f 'tripwire-1.0/src/list.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.0/src/list.c'\"
else
echo shar: Extracting \"'tripwire-1.0/src/list.c'\" \(17081 characters\)
sed "s/^X//" >'tripwire-1.0/src/list.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Id: list.c,v 1.3 92/11/03 04:49:45 genek Exp $";
X#endif
X
X/*
X * list.c
X *
X *	generic linked list routines.
X *
X *	These routines generally use a (struct list **) as an argument
X *	(ie: a pointer to a pointer to the head of the list).  This way,
X *	a NULL list pointer will automatically be malloc()'d into existence.
X *
X *	These routines started as extremely simple routines.  Unfortunately, the
X *	O(n) search times made Tripwire extremely slow.  So, v3.1 of
X *	the linked list routines incorporate a hash table into each of
X *	the list structures.  *whew*  It's faster, but it's not simple
X *	anymore.  (The addition of back pointers didn't help either...)
X *
X *	Why?  Well, we need to preserve order for the list of generated files.
X *	So, a hash table won't do, and a simple linked list is too slow.
X *
X *	However, the neat thing is that the object-oriented nature of
X *	the list routines is preserved.
X *
X * Gene Kim
X * Purdue University
X */
X
X#include "../include/config.h"
X#include <stdio.h>
X#ifdef STDLIBH
X#include <stdlib.h>
X#endif
X#include <assert.h>
X#ifdef MALLOCH
X# include <malloc.h>
X#endif
X#ifdef STRINGH
X#include <string.h>
X#else
X#include <strings.h>
X#endif
X#include "../include/list.h"
X
X/* prototypes */
Xstatic unsigned int string_hash ();
X
Xstatic int listdebug = 0;
X
X#define LISTDEBUG(x) if (listdebug >= (x))
X
X/*
X * list_set(pc_name, pc_value, prioirty, pp_list)
X *
X *	insert structure with (name=pc_name) and (value=pc_value)
X *	into the specified list
X */
X
Xvoid
Xlist_set(pc_name, pc_value, priority, pp_list)
X    int priority;
X    char *pc_name, *pc_value;
X    struct list **pp_list;
X{
X    struct list_elem *p;
X    struct list_hash *phash, *qhash;
X    int	clobber = 0;
X    struct list_elem *head;
X    unsigned int hindex;			/* hash index */
X    struct list_hash *hentry;
X
X    /* get the hash value */
X    hindex = string_hash(pc_name);
X
X    /* were we handed a NULL list pointer? */
X    if (*pp_list == NULL)
X	goto INSERT;
X    else
X	head = (*pp_list)->p_head;
X
X    hentry = &( ((*pp_list)->hashtable)[hindex]);
X
X    /*
X     * 1) if pc_name is already in the list, then we compare priority
X     *		levels.  replace only if new priority is higher than
X     *		existing priority.
X     *
X     * 2) if pc_name is not on the list, then we just add it to the
X     *		end of the list
X     */
X
X    /* walk through hash chain */
X    for (phash = hentry; phash && phash->used; qhash = phash,
X							phash = phash->next) {
X	if (strcmp(phash->key, pc_name) == 0) {
X	    /*
X	     * if existing priority is equal or less than this one,
X	     * then go ahead and clobber it.
X	     */
X	    p = phash->lptr;
X	    if (p->priority <= priority) {
X
XLISTDEBUG(10)
Xfprintf(stderr, "list_set(): '%s' variable already found.  Clobbering...\n",
X				pc_name);
X
X		clobber++;
X		goto INSERT;
X	    }				/* end if clobber */
X	    else {
X
XLISTDEBUG(10)
Xfprintf(stderr, "list_set(): variable already found, but not clobbering...\n");
X	
X		return;
X	    }				/* end if not clobber */
X	}
X    }
X    /* back up one if we're not at head of chain */
X    if (phash == (struct list_hash *) NULL)
X	phash = qhash;
X
XINSERT:
X    /* insert the element into the list */
X
X    /* 		do we first need to create the list object? */
X    if (*pp_list == NULL) {
X
X	int i;
X	struct list *pl;
X
X	/* create the list structure pointer */
X	if ((pl = *pp_list = (struct list *) malloc(sizeof(struct list)))
X					== NULL) {
X	    fprintf(stderr, "list_insert(): malloc() failed!\n");
X	    exit(1);
X	}
X
X	/* create the pointers inside the structure */
X	if ((p = (struct list_elem *) malloc(sizeof(struct list_elem)))
X					== NULL) {
X	    fprintf(stderr, "list_insert(): malloc() failed!\n");
X	    exit(1);
X	}
X	/* cauterize the prev pointer */
X	p->prev = NULL;
X	p->varname = NULL;
X
X	/* attach to list structure */
X	pl->p_head = head = pl->p_tail = p;
X	head->next = NULL;
X
X	/* initialize the hash table */
X	for (i = 0; i < LIST_HASHSZ; i++) {
X	    hentry = &( ((*pp_list)->hashtable)[i]);
X	    hentry->key = (char *) NULL;
X	    hentry->used = 0;
X	    hentry->lptr = (struct list_elem *) NULL;
X	    hentry->next = (struct list_hash *) NULL;
X	}
X
X	/* get correct hash bucket */
X	hentry = &( ((*pp_list)->hashtable)[hindex]);
X    }
X    else if (clobber) {
X	    free(p->varname);
X	    free(p->varvalue);
X    }
X    else
X    {
X	/* add a list entry at tail of list */
X	p = (*pp_list)->p_tail;
X
X	if ((p->next = (struct list_elem *)
X				malloc(sizeof(struct list_elem))) == NULL) {
X
X	    fprintf(stderr, "list_insert(): malloc() failed!\n");
X	    exit(1);
X	}
X
X	/* attach the prev pointer */
X	p->next->prev = p;
X
X	/* now the rest */
X	p = p->next;
X	p->next = NULL;
X
X	/* bind to tail */
X	(*pp_list)->p_tail = p;
X
X	if (phash->used) {
X	    /* now create the hash chain entry */
X	    /*	do we need a new structure to chain on? */
X	    if ((qhash = (struct list_hash *) malloc(sizeof(struct list_hash)))
X					== NULL) {
X		fprintf(stderr, "list_insert(): malloc() failed!\n");
X		exit(1);
X	    }
X	    qhash->used = 0;
X	    qhash->next = NULL;
X
X	    phash->next = qhash;
X	    hentry = phash = qhash;
X	}
X    }
X
X    /* start filling in fields */
X    if ((p->varname = (char *) malloc((unsigned) (strlen(pc_name) + 1)))
X				== NULL) {
X	fprintf(stderr, "list_insert(): malloc() failed!\n");
X	exit(1);
X    }
X    (void) strcpy(p->varname, pc_name);
X    if ((p->varvalue = (char *) malloc((unsigned) (strlen(pc_value) + 1)))
X				== NULL) {
X	fprintf(stderr, "list_insert(): malloc() failed!\n");
X	exit(1);
X    }
X    (void) strcpy(p->varvalue, pc_value);
X    p->flag = 0;
X    p->priority = 0;
X
X    /* fill in hash chain structure */
X    hentry->key = p->varname;
X    if (hentry->used == 0)
X	hentry->used++;
X    assert(hentry->used == 1);
X    hentry->lptr = p;
X    hentry->next = NULL;
X
X    return;
X
X}
X
X/*
X * char *
X * list_lookup(pc_name, pp_list)
X *
X *	return the string value assigned to the environment value named
X *	pc_name in the specified list.
X *
X *	you must copy the contents of the (char *).
X */
X
Xchar *
Xlist_lookup(pc_name, pp_list)
X    char *pc_name;
X    struct list **pp_list;
X{
X    struct list_elem *p;
X    struct list_hash *phash;
X    char	*s;
X    unsigned int hindex;
X    struct list_hash *hentry;
X
X    /*
X     * 1) if *pp_list is NULL, then we know it's emtpy
X     * 2) if it's not in the hash table, then return NULL
X     * 3) search hash table chain
X     */
X
X    /* check for empty list */
X    if (*pp_list == NULL) {
X	return NULL;
X    }
X
X    /* look in hash table */
X    hindex = string_hash(pc_name);
X    hentry = &(((*pp_list)->hashtable)[hindex]);
X
X    if (hentry->used == 0) {
X	return NULL;
X    }
X
X    /* now search through hash chain */
X    for (phash = hentry; phash; phash = phash->next) {
X	if (strcmp(phash->key, pc_name) == 0) {
X	    p = phash->lptr;
X	    /*
X	    s = (char *) malloc((unsigned) (strlen(p->varvalue) + 1));
X	    (void) strcpy(s, p->varvalue);
X	    */
X	    s = p->varvalue;
X	    return s;
X	}
X    }
X    return NULL;
X}
X
X/*
X * int
X * list_isthere(pc_name, pp_list)
X *
X *	returns (1) if pc_name is in the specified list.
X *	else returns (0).
X */
X
Xint
Xlist_isthere(pc_name, pp_list)
X    char *pc_name;
X    struct list **pp_list;
X{
X    struct list_hash *phash;
X    unsigned int hindex;
X    struct list_hash *hentry;
X
X    /*
X     * 1) if *pp_list is NULL, then we know it's emtpy
X     * 2) if it's not in the hash table, then return NULL
X     * 3) search hash table chain
X     */
X
X    /* check for empty list */
X    if (*pp_list == NULL) {
X	return 0;
X    }
X
X    /* look in hash table */
X    hindex = string_hash(pc_name);
X    hentry = &(((*pp_list)->hashtable)[hindex]);
X
X    if (hentry->used == 0) {
X	return 0;
X    }
X
X    /* now search through hash chain */
X    for (phash = hentry; phash; phash = phash->next) {
X	if (strcmp(phash->key, pc_name) == 0) {
X	    return 1;
X	}
X    }
X    return 0;
X}
X
X/*
X * list_unset(pc_name, pp_list)
X *	remove the list entry with (varname == pcname) from the
X *	environment
X */
X
Xvoid
Xlist_unset(pc_name, pp_list)
X    char *pc_name;
X    struct list **pp_list;
X{
X    struct list_hash *phash, *qhash = (struct list_hash *) NULL;
X    struct list_elem *plist;
X    unsigned int hindex;
X    struct list_hash *hentry;
X
X    if (*pp_list == NULL)
X	return;
X
X    /*
X     * 1) if pc_name isn't found in the hash chain, return
X     * 2) if found, remove the element from the list, and then remove
X     *		from hash chain.
X     *		check to see if we're the only element on the hash chain,
X     *		too.
X     */
X
X    /* look in hash table */
X    hindex = string_hash(pc_name);
X    hentry = &(((*pp_list)->hashtable)[hindex]);
X
X    /* if not in hash table, return */
X    if (hentry->used == 0) {
X
XLISTDEBUG(0)
Xfprintf(stderr, "list_unset(): couldn't find '%s' in environment\n", pc_name);
X
X	return;
X    }
X
X    /* find the element, but playing pointer tag w/two pointers */
X    for (phash = hentry; phash; qhash = phash, phash = phash->next) {
X	assert(qhash == NULL || qhash->next == phash);
X	if (strcmp(phash->key, pc_name) == 0) {
X	    /* remove the element from the list */
X	    plist = phash->lptr;
X
X	    /* prev->next = this->next
X	     * next->prev = this->prev
X	     */
X
X	    /* are we at the head of the list? */
X	    if (plist->prev) {
X		plist->prev->next = plist->next;
X	    }
X	    /* are we at the end of the list? */
X	    if (plist->next) {
X		plist->next->prev = plist->prev;
X	    }
X	    free((char *) plist);
X
X	    /* now remove from hash chain */
X	    /* if it was at top of list */
X	    if (qhash == NULL) {
X		hentry->used = 0;
X		hentry->next = (struct list_hash *) NULL;
X	    } else {
X		qhash->next = phash->next;
X		free((char *) phash);
X	    }
X	    return;
X	}
X    }
X
X
X    return;
X}
X
X/*
X * list_setflag(pc_name, flag, pp_list)
X *
X *	OR the the specified flag to the existing flag value.
X */
X
Xint
Xlist_setflag(pc_name, flag, pp_list)
X    char *pc_name;
X    int	flag;
X    struct list **pp_list;
X{
X    struct list_elem *plist;
X    struct list_hash *phash, *hentry;
X    unsigned int hindex;
X
X    if (*pp_list == NULL)
X	return -1;
X
X    /*
X     * 1) look in hash table for entry.  if not found, return with error.
X     * 2) walk down hash chain until entry is found, then modify the
X     *		list entry
X     */
X
X    /* look in hash table */
X    hindex = string_hash(pc_name);
X    hentry = &(((*pp_list)->hashtable)[hindex]);
X
X    /* walk down chain */
X    for (phash = hentry; phash && phash->used; phash = phash->next) {
X	if (strcmp(phash->key, pc_name) == 0) {
X	    plist = phash->lptr;
X	    plist->flag |= flag;
X	    return 0;
X	}
X    }
X
X    return 0;
X}
X
X/*
X * list_getflag(pc_name, pp_list)
X *	return the flag value embedded in structure.
X */
X
Xint
Xlist_getflag(pc_name, pp_list)
X    char *pc_name;
X    struct list **pp_list;
X{
X
X    struct list_elem *plist;
X    struct list_hash *phash, *hentry;
X    unsigned int hindex;
X
X    if (*pp_list == NULL)
X	return -1;
X
X    /*
X     * 1) look in hash table for entry.  if not found, return with error.
X     * 2) walk down hash chain until entry is found, then modify the
X     *		list entry
X     */
X
X    /* look in hash table */
X    hindex = string_hash(pc_name);
X    hentry = &(((*pp_list)->hashtable)[hindex]);
X
X    /* walk down chain */
X    for (phash = hentry; phash && phash->used; phash = phash->next) {
X	if (strcmp(phash->key, pc_name) == 0) {
X	    plist = phash->lptr;
X	    return plist->flag;
X	}
X    }
X
X    return -1;
X}
X
X/*
X * list_print()
X *	print out the entire contents of the linked list
X */
X
Xvoid
Xlist_print(pp_list)
X    struct list **pp_list;
X{
X    struct list_elem	*p;
X    struct list_elem *head;
X
X    /* check to see if list is empty */
X    if (*pp_list == NULL)
X	return;
X	
X    head = (*pp_list)->p_head;
X
X    /* walk down entire list */
X    for (p = head; p; p = p->next) {
X	printf("%-40s\t%20s %d\n", p->varname, p->varvalue, p->flag);
X    }
X    return;
X}
X
X/*
X * list_reset()
X *	
X *	given a pointer to a list, delete the entire list, and set the
X *	pointer to NULL;
X */
X
Xvoid
Xlist_reset (pp_list)
X    struct list **pp_list;
X{
X    struct list_elem *p, *q;
X    struct list_hash *phash, *qhash;
X    int i;
X
X    if (*pp_list == NULL)
X	return;
X
X    /* walk down the list, deleting the element that we just came from */
X    for (p = (*pp_list)->p_head; p; q = p, p = p->next, free((char *) q)) ;
X
X    /* walk down the hash table, and remove its hash chain */
X    for (i = 0; i < LIST_HASHSZ; i++) {
X	phash = &(((*pp_list)->hashtable)[i]);
X	if (phash->used) {
X	    /* don't delete the first entry!  it's static! */
X	    for (phash = phash->next; phash; qhash = phash,
X				phash = qhash->next, free((char *) qhash)) ;
X	}
X    }
X
X    /* now free up the list structure */
X    free((char *) *pp_list);
X
X    /* now invalidate the list structure pointer */
X    *pp_list = NULL;
X
X    return;
X}
X
X
X/*
X * list_init ()
X * list_open (struct list **pp_list)
X * list_get  (struct list **pp_list)
X * list_close(struct list **pp_list)
X *
X *	this allows the retrieval of individual list elements through
X *	successive calls to list_get().
X *
X *	0)	list_init() initializes the tables.
X *	1) 	list_open() creates a table entry with *pp_head as the key
X *	2) 	any calls to list_get() will get the next element.  the
X *			index is stored in the table, with *pp_head as the
X *			key.
X *	3) 	list_close() removes the table entry, with *pp_head as the
X *			key.
X */
X
X#define LIST_TABLE_SZ	16
Xstruct list_table_entry {
X    struct list *p_key;			/* pointer to head is used as key */
X    struct list_elem *p_pindex;		/* pointer to current element */
X};
X
Xstatic struct list_table_entry list_table[LIST_TABLE_SZ];
X
Xint
Xlist_init()
X{
X    int i;
X    struct list_table_entry *p;
X
X    /* clear all keys and indexes */
X    for (i = 0; i < LIST_TABLE_SZ; i++) {
X	p = &list_table[i];
X	p->p_key = NULL;
X	p->p_pindex = NULL;
X    }
X    return 0;
X}
X
X/*
X * list_open(struct list **pp_list)
X *
X *	create a table entry with *pp_head as a key.
X *	returns (-1) if an entry with the specified key was already
X *		in the table, else (0).
X */
X
Xint
Xlist_open (pp_list)
X    struct list **pp_list;
X{
X    int i;
X    struct list_table_entry *p;
X
X    /* is the list NULL? */
X    if (*pp_list == NULL) {
X	return 0;				/* we'll fake it later on */
X    }
X
X    /* is there already an entry with a matching key?  is there any
X     * an empty table entry for us?
X     */
X    for (i = 0; i < LIST_TABLE_SZ; i++) {
X	p = &list_table[i];
X	if (p->p_key == NULL)
X	     break;
X	if (p->p_key == *pp_list)
X	     break;
X    }						/* end for loop */
X
X    /*
X     * return with error if there was a collision.  (if the index rolled
X     * all the way to the top, and its index value was non-null, then
X     * we overflowed the table.)
X     */
X    if (i == LIST_TABLE_SZ && p->p_key != NULL)
X	return -1;
X
X    /*
X     * create the table entry.  assertion: p already points to an empty
X     * table entry.   Have index point to the head.
X     */
X    p->p_key = *pp_list;
X    p->p_pindex = (*pp_list)->p_head;
X
X    return 0;
X}
X
X/*
X * struct list_elem *
X * list_get(struct list **pp_list)
X *
X *	get the next entry in the specified list (using *pp_list as the key),
X *		and bump the internal pointer to the next element, ready
X *		for the next call to list_get().
X *	we return NULL if we're sitting on the tail end of the list.
X */
X
Xstruct list_elem *
Xlist_get (pp_list)
X    struct list **pp_list;
X{
X    int i;
X    struct list_table_entry *p, *q;
X    struct list_elem *p_elem;
X
X    /* fake it if you pass it a NULL */
X    if (*pp_list == NULL) {
X	return NULL;
X    }
X
X    /* find entry with matching key */
X    for (i = 0; i < LIST_TABLE_SZ; i++) {
X	p = &list_table[i];
X	if (p->p_key == *pp_list)
X	     break;
X    }						/* end for loop */
X
X    /* bounds checking.  if we rolled through the entire array, then
X     * we never found the key!
X     */
X
X    if (i == LIST_TABLE_SZ)
X	return NULL;
X
X    /* are we already at the end of the list? */
X
X    if (p->p_pindex == NULL)
X	return NULL;
X
X    /* if not, return a pointer to the current list element, and increment
X     * the table pointer.
X     */
X
X    p_elem = p->p_pindex;
X    q = p;
X    q->p_pindex = q->p_pindex->next;		/* walk through pointer */
X
X    return p_elem;
X}
X
X/*
X * list_close(struct list **pp_list)
X *	
X * 	remove the table entry with (*pp_list) as the key.
X *	return -1 if entry not found.  else 0.
X */
X
Xint
Xlist_close (pp_list)
X    struct list **pp_list;
X{
X    int i;
X    struct list_table_entry *p;
X
X    /* fake it if you pass it a NULL */
X    if (*pp_list == NULL) {
X	return 0;
X    }
X
X    /* find entry with matching key */
X    for (i = 0; i < LIST_TABLE_SZ; i++) {
X	p = &list_table[i];
X	if (p->p_key == *pp_list)
X	     break;
X    }						/* end for loop */
X
X    /* bounds checking.  if we rolled through the entire array, then
X     * we never found the key!
X     */
X
X    if (i == LIST_TABLE_SZ)
X	return -1;
X
X    /* remove the entry.  assertion:  p is pointing to our entry */
X    p->p_key = NULL;
X    p->p_pindex = NULL;
X
X    return 0;
X}
X
Xstatic unsigned int
Xstring_hash (string)
X    char *string;
X{
X    unsigned int hindex;
X    char *pc = string;
X
X    hindex = *pc;
X    while (*pc) {
X	hindex = ((hindex << 9) ^ *pc++) % LIST_HASHSZ;
X	/*
X	hindex = ((hindex << 7) | (string[i] + len)) % LIST_HASHSZ;
X	*/
X    }
X    return hindex;
X}
END_OF_FILE
if test 17081 -ne `wc -c <'tripwire-1.0/src/list.c'`; then
    echo shar: \"'tripwire-1.0/src/list.c'\" unpacked with wrong size!
fi
# end of 'tripwire-1.0/src/list.c'
fi
if test -f 'tripwire-1.0/sigs/md4/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.0/sigs/md4/Makefile'\"
else
echo shar: Extracting \"'tripwire-1.0/sigs/md4/Makefile'\" \(306 characters\)
sed "s/^X//" >'tripwire-1.0/sigs/md4/Makefile' <<'END_OF_FILE'
X# $Id: Makefile,v 1.1.1.2 92/11/02 18:21:37 genek Exp $
X#
X# Makefile for MD4 wrapper
X#
X# Gene Kim
X# Purdue University
X# October 18, 1992
X#
X
Xall:	md4.o md4wrapper.o
X
X.c.o:	
X	$(CC) $(CFLAGS) -c $<
X	
Xclean:
X	-rm -rf md4.o md4wrapper.o
X
Xmd4.o: ../../include/byteorder.h
Xmd4wrapper.o: ../../include/byteorder.h
END_OF_FILE
if test 306 -ne `wc -c <'tripwire-1.0/sigs/md4/Makefile'`; then
    echo shar: \"'tripwire-1.0/sigs/md4/Makefile'\" unpacked with wrong size!
fi
# end of 'tripwire-1.0/sigs/md4/Makefile'
fi
if test -f 'tripwire-1.0/sigs/crc32/crc32.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.0/sigs/crc32/crc32.h'\"
else
echo shar: Extracting \"'tripwire-1.0/sigs/crc32/crc32.h'\" \(81 characters\)
sed "s/^X//" >'tripwire-1.0/sigs/crc32/crc32.h' <<'END_OF_FILE'
X/* $Id: crc32.h,v 1.1.1.2 92/11/02 18:21:03 genek Exp $ */
X
Xint sig_crc32_get();
END_OF_FILE
if test 81 -ne `wc -c <'tripwire-1.0/sigs/crc32/crc32.h'`; then
    echo shar: \"'tripwire-1.0/sigs/crc32/crc32.h'\" unpacked with wrong size!
fi
# end of 'tripwire-1.0/sigs/crc32/crc32.h'
fi
echo shar: End of archive 3 \(of 8\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    echo "Now read the README file"
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Gene Spafford
Software Engineering Research Center & Dept. of Computer Sciences
Purdue University, W. Lafayette IN 47907-1398
Internet:  spaf@cs.purdue.edu	phone:  (317) 494-7825
