Newsgroups: comp.sources.unix
From: pk@cs.few.eur.nl (Paul Kranenburg)
Subject: v26i019: munetd - a more universal network superserver
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: pk@cs.few.eur.nl (Paul Kranenburg)
Posting-Number: Volume 26, Issue 19
Archive-Name: munetd

A modified version of the BSD inetd(8) (v 5.25) superserver,
supporting RPC, UNIX domain sockets and PTY connections.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  MANIFEST Makefile README daemon.c getenv.c munetd.8
#   munetd.c setenv.c
# Wrapped by pk@kaa on Fri Jan 17 15:15:15 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(362 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X Makefile                   1	
X README                     1	
X daemon.c                   1	
X getenv.c                   1	
X munetd.8                   1	
X munetd.c                   1	
X setenv.c                   1	
END_OF_FILE
if test 362 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(1036 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# @(#)Makefile	1.7 92/01/17
X#
X
X#
X# Choose path names suitable for your system.
X# Set RPC=0 in DEFINES below if you don't have the routines 
X# `pmap_set' and `pmap_unset' in your libraries.
X#
X
XBINDIR	=	/usr/local/etc
XMANDIR	=	/usr/local/man
XDEFINES	=	-DRPC=1 -D_PATH_INETDCONF=\"/etc/munetd.conf\" \
X			-D_PATH_INETDPID=\"/etc/munetd.pid\"
XCC	=	cc
XCFLAGS	=	-O $(DEFINES)
XOBJS	=	munetd.o
XLIBOBJS	=	daemon.o getenv.o setenv.o
XLIBS	=	-lbsd44
X
Xwithlib	:= LIBSEARCH = -L.
Xwithlib	:= LIBDEP = libbsd44.a
X
Xall: munetd
Xwithlib: $$(LIBDEP) all
X
Xmunetd: $(OBJS) $$(LIBDEP)
X	$(CC) $(CFLAGS) -o $@ $(OBJS) $(LIBSEARCH) $(LIBS)
X
Xlibbsd44.a: $(LIBOBJS)
X	ar crlu $@ $(LIBOBJS)
X	ranlib $@
X
Xinstall: munetd
X	install -o root -m 555 munetd $(BINDIR)
X
Xinstall.man: munetd.8
X	install -o root -m 444 munetd.8 $(MANDIR)/man8
X
Xclean:
X	rm -f core a.out munetd libbsd44.a *.o
X
Xkit:
X	makekit -m README Makefile munetd.8 munetd.c getenv.c setenv.c daemon.c
X
Xtar:
X	tar cf - README Makefile munetd.8 munetd.c getenv.c setenv.c daemon.c | \
X	compress > munetd.tar.Z
END_OF_FILE
if test 1036 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1954 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X#
X# @(#)README	1.1 92/01/17	- A More Universal Network superserver
X#
X
Xmunetd(8) is a modified version of the BSD inetd(8) version 5.25, as distributed
Xby several FTP archive sites. 
X
XFEATURES:
X
X	1) Listening for connections on pseudo-terminals (pty's), useful
X	   for programmes that expect a terminal as their stdio but you
X	   want to run on a network connection (eg. tip(1), lpd(8), uucp).
X	   Example: the configuration entry
X
X	   /dev/ptyrf stream  pty  wait  root  /usr/local/etc/tt.jetd  tt.jetd -h pc-lw
X
X	   would allow lpd(8) or tip(1) to connect to a Laser printer on the
X	   network (`tt.jetd' typically sets up the connection using TCP and
X	   then acts as a bi-directional transfer agent).
X
X	2) Support for AF_UNIX sockets on the local machine.
X	   As yet, I have found no useful purpose for this, but it was
X	   relatively easy to add. A configuration line would go like this:
X
X	   /tmp/your-sock stream unix nowait root /etc/your-daemon <args>
X
X
X	3) Support for RPC based daemons.
X	   Syntax as used by Sun Microsystems, example:
X
X	   rusersd/1-2	dgram	rpc/udp	wait nobody /usr/etc/rpc.rusersd rpc.rusersd
X
X	4) Saving the process ID in a file (typically `/etc/munetd.pid') for
X	   easier installation of configuration changes. This comes in
X	   handy if you automate (as we do) the distribution of configuration
X	   files on a bundle of machines.
X
X	5) Some bug fixes (especially in the handling of HANGUP signals)
X
X
XINSTALLATION
X
X	Define RPC=0 in the makefile if your libraries do not contain
X	the routines `pmap_set' and `pmap_unset'.
X
X	Type `make withlib' if library routines `daemon' or `setenv' 
X	are not available on your system.
X
X
XTODO
X	Do a better job of unregistering RPC services on SIGTERM.
X	Should hold a lock on `/etc/munetd.pid' while running to
X	avoid inadvertent killings.
X
X
XFTP
X
X	`munetd' is available by Anonymous FTP from `kaa.cs.few.eur.nl'
X	(file: `pub/munetd.tar.Z')
X
X
XREMARKS TO
X
X	Paul Kranenburg (pk@cs.few.eur.nl)
END_OF_FILE
if test 1954 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'daemon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'daemon.c'\"
else
echo shar: Extracting \"'daemon.c'\" \(1580 characters\)
sed "s/^X//" >'daemon.c' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1990 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted provided
X * that: (1) source distributions retain this entire copyright notice and
X * comment, and (2) distributions including binaries display the following
X * acknowledgement:  ``This product includes software developed by the
X * University of California, Berkeley and its contributors'' in the
X * documentation or other materials provided with the distribution and in
X * all advertising materials mentioning features or use of this software.
X * Neither the name of the University nor the names of its contributors may
X * be used to endorse or promote products derived from this software without
X * specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)daemon.c	1.2 (Berkeley) 6/29/90";
X#endif /* LIBC_SCCS and not lint */
X
X#include <sys/file.h>
X
Xdaemon(nochdir, noclose)
X	int nochdir, noclose;
X{
X	int cpid;
X
X	if ((cpid = fork()) == -1)
X		return (-1);
X	if (cpid)
X		exit(0);
X	(void) setsid();
X	if (!nochdir)
X		(void) chdir("/");
X	if (!noclose) {
X		int devnull = open("/dev/null", O_RDWR, 0);
X
X		if (devnull != -1) {
X			(void) dup2(devnull, 0);
X			(void) dup2(devnull, 1);
X			(void) dup2(devnull, 2);
X			if (devnull > 2)
X				(void) close(devnull);
X		}
X	}
X}
END_OF_FILE
if test 1580 -ne `wc -c <'daemon.c'`; then
    echo shar: \"'daemon.c'\" unpacked with wrong size!
fi
# end of 'daemon.c'
fi
if test -f 'getenv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getenv.c'\"
else
echo shar: Extracting \"'getenv.c'\" \(2044 characters\)
sed "s/^X//" >'getenv.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1987 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that: (1) source distributions retain this entire copyright
X * notice and comment, and (2) distributions including binaries display
X * the following acknowledgement:  ``This product includes software
X * developed by the University of California, Berkeley and its contributors''
X * in the documentation or other materials provided with the distribution
X * and in all advertising materials mentioning features or use of this
X * software. Neither the name of the University nor the names of its
X * contributors may be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)getenv.c	5.7 (Berkeley) 6/1/90";
X#endif /* LIBC_SCCS and not lint */
X
X#include <stdlib.h>
X#include <stddef.h>
X
X/*
X * getenv --
X *	Returns ptr to value associated with name, if any, else NULL.
X */
Xchar *
Xgetenv(name)
X	char *name;
X{
X	int offset;
X	char *_findenv();
X
X	return(_findenv(name, &offset));
X}
X
X/*
X * _findenv --
X *	Returns pointer to value associated with name, if any, else NULL.
X *	Sets offset to be the offset of the name/value combination in the
X *	environmental array, for use by setenv(3) and unsetenv(3).
X *	Explicitly removes '=' in argument name.
X *
X *	This routine *should* be a static; don't use it.
X */
Xchar *
X_findenv(name, offset)
X	register char *name;
X	int *offset;
X{
X	extern char **environ;
X	register int len;
X	register char **P, *C;
X
X	for (C = name, len = 0; *C && *C != '='; ++C, ++len);
X	for (P = environ; *P; ++P)
X		if (!strncmp(*P, name, len))
X			if (*(C = *P + len) == '=') {
X				*offset = P - environ;
X				return(++C);
X			}
X	return(NULL);
X}
END_OF_FILE
if test 2044 -ne `wc -c <'getenv.c'`; then
    echo shar: \"'getenv.c'\" unpacked with wrong size!
fi
# end of 'getenv.c'
fi
if test -f 'munetd.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'munetd.8'\"
else
echo shar: Extracting \"'munetd.8'\" \(5717 characters\)
sed "s/^X//" >'munetd.8' <<'END_OF_FILE'
X.\" Copyright (c) 1985 The Regents of the University of California.
X.\" All rights reserved.
X.\"
X.\" Redistribution and use in source and binary forms are permitted provided
X.\" that: (1) source distributions retain this entire copyright notice and
X.\" comment, and (2) distributions including binaries display the following
X.\" acknowledgement:  ``This product includes software developed by the
X.\" University of California, Berkeley and its contributors'' in the
X.\" documentation or other materials provided with the distribution and in
X.\" all advertising materials mentioning features or use of this software.
X.\" Neither the name of the University nor the names of its contributors may
X.\" be used to endorse or promote products derived from this software without
X.\" specific prior written permission.
X.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X.\" WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X.\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X.\"
X.\"	@(#)inetd.8	6.6 (Berkeley) 6/24/90
X.\"
X.TH MUNETD 8 "January 16, 1992"
X.UC 6
X.SH NAME
Xmunetd \- network ``super\-server''
X.SH SYNOPSIS
X.B munetd
X[
X.B \-d
X] [ configuration file ]
X.SH DESCRIPTION
X.I Munetd
Xshould be run at boot time by
X.IR /etc/rc.local .
XIt then listens for connections on certain
Xinternet sockets.  When a connection is found on one
Xof its sockets, it decides what service the socket
Xcorresponds to, and invokes a program to service the request.
XAfter the program is
Xfinished, it continues to listen on the socket (except in some cases which
Xwill be described below).  Essentially,
X.I munetd
Xallows running one daemon to invoke several others,
Xreducing load on the system.
X.PP
XUpon execution,
X.I munetd
Xreads its configuration information from a configuration
Xfile which, by default, is
X.IR /etc/munetd.conf .
XThere must be an entry for each field of the configuration
Xfile, with entries for each field separated by a tab or
Xa space.  Comments are denoted by a ``#'' at the beginning
Xof a line.  There must be an entry for each field.  The
Xfields of the configuration file are as follows:
X.br
X	service name
X.br
X	socket type
X.br
X	protocol
X.br
X	wait/nowait
X.br
X	user
X.br
X	server program
X.br
X	server program arguments
X.PP
XThe
X.I service name
Xentry is interpreted according to the
X.I protocol
Xfield. It can be numeric or the name of a valid service in the file
X.IR /etc/services,
X.IR /etc/rpc,
Xa AF_UNIX pipe or a pseudo terminal, respectively for standard INET services,
XRPC services, UNIX services and PTY services.
XFor RPC services, the service name field consists of a name or protocol number
Xfollowed by a slash and a version number or range of version numbers
X(eg. rusers/1-2).
XFor ``internal'' services (discussed below), the service
Xname
X.I must
Xbe the official name of the service (that is, the first entry in
X.IR /etc/services ).
X.PP
XThe
X.I socket type
Xshould be one of ``stream'', ``dgram'', ``raw'', ``rdm'', or ``seqpacket'',
Xdepending on whether the socket is a stream, datagram, raw,
Xreliably delivered message, or sequenced packet socket.
X.PP
XThe
X.I protocol
Xmust be ``unix'', ``pty'' or a valid protocol as given in
X.IR /etc/protocols .
XExamples might be ``tcp'' or ``udp''.
XFor RPC services, the protocol field has the format rpc/\c
X.I proto
Xwhere
X.I proto
Xis the name of the underlying transport service (``tcp'' or ``udp'').
X.PP
XThe
X.I wait/nowait
Xentry is applicable to datagram sockets only (other sockets should
Xhave a ``nowait'' entry in this space).  If a datagram server connects
Xto its peer, freeing the socket so
X.I munetd
Xcan received further messages on the socket, it is said to be
Xa ``multi-threaded'' server, and should use the ``nowait''
Xentry.  For datagram servers which process all incoming datagrams
Xon a socket and eventually time out, the server is said to be
X``single-threaded'' and should use a ``wait'' entry.  ``Comsat'' (``biff'')
Xand ``talk'' are both examples of the latter type of
Xdatagram server.
X.I Tftpd
Xis an exception; it is a datagram server that establishes pseudo-connections.
XIt must be listed as ``wait'' in order to avoid a race;
Xthe server reads the first packet, creates a new socket,
Xand then forks and exits to allow
X.I munetd
Xto check for new service requests to spawn new servers.
XFor PTY services ``wait'' is the only acceptable choice,
Xgiven the nature of this device.
X.PP
XThe
X.I user
Xentry should contain the user name of the user as whom the server
Xshould run.  This allows for servers to be given less permission
Xthan root.
XThe
X.I server program
Xentry should contain the pathname of the program which is to be
Xexecuted by
X.I munetd
Xwhen a request is found on its socket.  If
X.I munetd
Xprovides this service internally, this entry should
Xbe ``internal''.
X.PP
XThe arguments to the server program should be just as they
Xnormally are, starting with argv[0], which is the name of
Xthe program.  If the service is provided internally, the
Xword ``internal'' should take the place of this entry.
X.PP
X.I Munetd
Xprovides several ``trivial'' services internally by use of
Xroutines within itself.  These services are ``echo'',
X``discard'', ``chargen'' (character generator), ``daytime''
X(human readable time), and ``time'' (machine readable time,
Xin the form of the number of seconds since midnight, January
X1, 1900).  All of these services are tcp based.  For
Xdetails of these services, consult the appropriate RFC
Xfrom the Network Information Center.
X.PP
X.I Munetd
Xrereads its configuration file when it receives a hangup signal, SIGHUP.
XServices may be added, deleted or modified when the configuration file
Xis reread.
X.SH "SEE ALSO"
Xcomsat(8), fingerd(8), ftpd(8), rexecd(8), rlogind(8), rshd(8),
Xtelnetd(8), tftpd(8)
END_OF_FILE
if test 5717 -ne `wc -c <'munetd.8'`; then
    echo shar: \"'munetd.8'\" unpacked with wrong size!
fi
# end of 'munetd.8'
fi
if test -f 'munetd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'munetd.c'\"
else
echo shar: Extracting \"'munetd.c'\" \(28032 characters\)
sed "s/^X//" >'munetd.c' <<'END_OF_FILE'
X/*
X * @(#)munetd.c	1.10 92/01/17	- pseudo tty server a la inetd
X *		  based on BSD 4.4 inetd.c
X */
X/*
X * Copyright (c) 1983 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted provided
X * that: (1) source distributions retain this entire copyright notice and
X * comment, and (2) distributions including binaries display the following
X * acknowledgement:  ``This product includes software developed by the
X * University of California, Berkeley and its contributors'' in the
X * documentation or other materials provided with the distribution and in
X * all advertising materials mentioning features or use of this software.
X * Neither the name of the University nor the names of its contributors may
X * be used to endorse or promote products derived from this software without
X * specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
Xchar copyright[] =
X"@(#) Copyright (c) 1983 Regents of the University of California.\n\
X All rights reserved.\n";
X#endif /* not lint */
X
X#ifndef lint
Xstatic char bsdsccsid[] = "@(#)inetd.c     5.25 (Berkeley) 6/29/90";
Xstatic char sccsid[] = "@(#)munetd.c	1.10 (Erasmus) 1/17/92";
X#endif /* not lint */
X
X/*
X * Inetd - Internet super-server
X *
X * This program invokes all internet services as needed.
X * connection-oriented services are invoked each time a
X * connection is made, by creating a process.  This process
X * is passed the connection as file descriptor 0 and is
X * expected to do a getpeername to find out the source host
X * and port.
X *
X * Datagram oriented services are invoked when a datagram
X * arrives; a process is created and passed a pending message
X * on file descriptor 0.  Datagram servers may either connect
X * to their peer, freeing up the original socket for inetd
X * to receive further messages on, or ``take over the socket'',
X * processing all arriving datagrams and, eventually, timing
X * out.	 The first type of server is said to be ``multi-threaded'';
X * the second type of server ``single-threaded''. 
X *
X * Inetd uses a configuration file which is read at startup
X * and, possibly, at some later time in response to a hangup signal.
X * The configuration file is ``free format'' with fields given in the
X * order shown below.  Continuation lines for an entry must being with
X * a space or tab.  All fields must be present in each entry.
X *
X *	service name			must be in /etc/services
X *	socket type			stream/dgram/raw/rdm/seqpacket
X *	protocol			must be in /etc/protocols
X *	wait/nowait			single-threaded/multi-threaded
X *	user				user to run daemon as
X *	server program			full path name
X *	server program arguments	maximum of MAXARGS (20)
X *
X * Comment lines are indicated by a `#' in column 1.
X */
X#include <sys/param.h>
X#include <sys/stat.h>
X#include <sys/ioctl.h>
X#include <sys/socket.h>
X#include <sys/un.h>
X#include <sys/file.h>
X#include <sys/wait.h>
X#include <sys/time.h>
X#include <sys/resource.h>
X
X#include <netinet/in.h>
X#include <arpa/inet.h>
X
X#include <errno.h>
X#include <signal.h>
X#include <netdb.h>
X#include <syslog.h>
X#include <pwd.h>
X#include <stdio.h>
X#include <string.h>
X#if 0
X#include "pathnames.h"
X#endif
X
X#define	TOOMANY		40		/* don't start more than TOOMANY */
X#define	CNT_INTVL	60		/* servers in CNT_INTVL sec. */
X#define	RETRYTIME	(60*10)		/* retry after bind or server fail */
X
X#define	SIGBLOCK	(sigmask(SIGCHLD)|sigmask(SIGHUP)|sigmask(SIGALRM))
X
Xextern	int errno;
X
Xvoid	config(), reapchild(), retry();
Xchar	*index();
Xchar	*malloc();
X
Xint	debug = 0;
Xint	nsock, maxsock;
Xfd_set	allsock;
Xfd_set	allpty;
Xint	options;
Xint	timingout;
Xstruct	servent *sp;
X
Xstruct	servtab {
X	char	*se_service;		/* name of service */
X	int	se_socktype;		/* type of socket to use */
X	int	se_family;		/* address family */
X#define AF_PTY	0xf0000000
X#define isrealsock(sep)	((sep)->se_family == AF_INET || \
X			(sep)->se_family == AF_UNIX)
X	char	*se_proto;		/* protocol used */
X	int	se_rpcprog;		/* rpc program number */
X	int	se_rpcversl;		/* rpc program lowest version */
X	int	se_rpcversh;		/* rpc program highest version */
X#define isrpcservice(sep)	((sep)->se_rpcversl != 0)
X	short	se_wait;		/* single threaded server */
X	short	se_checked;		/* looked at during merge */
X	char	*se_user;		/* user name to run as */
X	struct	biltin *se_bi;		/* if built-in, description */
X	char	*se_server;		/* server program */
X#define	MAXARGV 20
X	char	*se_argv[MAXARGV+1];	/* program arguments */
X	int	se_fd;			/* open descriptor */
X	union {
X		struct	sockaddr se_un_ctrladdr;
X		struct	sockaddr_in se_un_ctrladdr_in;
X		struct	sockaddr_un se_un_ctrladdr_un;
X	} se_un;			/* bound address */
X#define se_ctrladdr	se_un.se_un_ctrladdr
X#define se_ctrladdr_in	se_un.se_un_ctrladdr_in
X#define se_ctrladdr_un	se_un.se_un_ctrladdr_un
X	int	se_ctrladdr_size;
X	int	se_count;		/* number started since se_time */
X	struct	timeval se_time;	/* start of se_count */
X	struct	servtab *se_next;
X} *servtab;
X
Xint echo_stream(), discard_stream(), machtime_stream();
Xint daytime_stream(), chargen_stream();
Xint echo_dg(), discard_dg(), machtime_dg(), daytime_dg(), chargen_dg();
X
Xstruct biltin {
X	char	*bi_service;		/* internally provided service name */
X	int	bi_socktype;		/* type of socket supported */
X	short	bi_fork;		/* 1 if should fork before call */
X	short	bi_wait;		/* 1 if should wait for child */
X	int	(*bi_fn)();		/* function which performs it */
X} biltins[] = {
X	/* Echo received data */
X	"echo",		SOCK_STREAM,	1, 0,	echo_stream,
X	"echo",		SOCK_DGRAM,	0, 0,	echo_dg,
X
X	/* Internet /dev/null */
X	"discard",	SOCK_STREAM,	1, 0,	discard_stream,
X	"discard",	SOCK_DGRAM,	0, 0,	discard_dg,
X
X	/* Return 32 bit time since 1900 */
X	"time",		SOCK_STREAM,	0, 0,	machtime_stream,
X	"time",		SOCK_DGRAM,	0, 0,	machtime_dg,
X
X	/* Return human-readable time */
X	"daytime",	SOCK_STREAM,	0, 0,	daytime_stream,
X	"daytime",	SOCK_DGRAM,	0, 0,	daytime_dg,
X
X	/* Familiar character generator */
X	"chargen",	SOCK_STREAM,	1, 0,	chargen_stream,
X	"chargen",	SOCK_DGRAM,	0, 0,	chargen_dg,
X	0
X};
X
X#define NUMINT	(sizeof(intab) / sizeof(struct inent))
X#ifdef _PATH_INETDCONF
Xchar	*CONFIG = _PATH_INETDCONF;
X#else
Xchar	*CONFIG = "/etc/inetd.conf";
X#endif
X#ifdef _PATH_INETDPID
Xchar	*PIDFILE = _PATH_INETDPID;
X#else
Xchar	*PIDFILE = "/etc/inetd.pid";
X#endif
Xchar	**Argv;
Xchar 	*LastArg;
X
Xmain(argc, argv, envp)
X	int argc;
X	char *argv[], *envp[];
X{
X	extern char *optarg;
X	extern int optind;
X	register struct servtab *sep;
X	register struct passwd *pwd;
X	register int tmpint;
X	struct sigvec sv;
X	int ch, pid, dofork;
X	char buf[50];
X
X	Argv = argv;
X	if (envp == 0 || *envp == 0)
X		envp = argv;
X	while (*envp)
X		envp++;
X	LastArg = envp[-1] + strlen(envp[-1]);
X
X	while ((ch = getopt(argc, argv, "d")) != EOF)
X		switch(ch) {
X		case 'd':
X			debug = 1;
X			options |= SO_DEBUG;
X			break;
X		case '?':
X		default:
X			fprintf(stderr, "usage: munetd [-d]");
X			exit(1);
X		}
X	argc -= optind;
X	argv += optind;
X
X	if (argc > 0)
X		CONFIG = argv[0];
X#ifdef sun
X	bump_nofile();
X#endif
X	if (debug == 0)
X		daemon(0, 0);
X	openlog("munetd", LOG_PID | LOG_NOWAIT, LOG_DAEMON);
X	logpid();
X	bzero((char *)&sv, sizeof(sv));
X	sv.sv_mask = SIGBLOCK;
X	sv.sv_handler = retry;
X	sigvec(SIGALRM, &sv, (struct sigvec *)0);
X	config();
X	sv.sv_handler = config;
X	sigvec(SIGHUP, &sv, (struct sigvec *)0);
X	sv.sv_handler = reapchild;
X	sigvec(SIGCHLD, &sv, (struct sigvec *)0);
X
X	{
X		/* space for daemons to overwrite environment for ps */
X#define	DUMMYSIZE	100
X		char dummy[DUMMYSIZE];
X
X		(void)memset(dummy, 'x', DUMMYSIZE - 1);
X		dummy[DUMMYSIZE - 1] = '\0';
X
X		(void)setenv("inetd_dummy", dummy, 1);
X	}
X
X	for (;;) {
X	    int n, ctrl;
X	    fd_set readable, writable;
X
X	    if (nsock == 0) {
X		(void) sigblock(SIGBLOCK);
X		while (nsock == 0)
X		    sigpause(0L);
X		(void) sigsetmask(0L);
X	    }
X	    readable = allsock;
X	    writable = allpty;
X	    if ((n = select(maxsock + 1, &readable, &writable,
X		(fd_set *)0, (struct timeval *)0)) <= 0) {
X		    if (n < 0 && errno != EINTR)
X			syslog(LOG_WARNING, "select: %m\n");
X		    sleep(1);
X		    continue;
X	    }
X	    for (sep = servtab; n && sep; sep = sep->se_next)
X	    if (sep->se_fd != -1 && (
X			FD_ISSET(sep->se_fd, &readable) ||
X			FD_ISSET(sep->se_fd, &writable)	)) {
X		n--;
X		if (debug)
X			fprintf(stderr, "someone wants %s\n", sep->se_service);
X		if (isrealsock(sep) && sep->se_socktype == SOCK_STREAM) {
X			ctrl = accept(sep->se_fd, (struct sockaddr *)0,
X			    (int *)0);
X			if (debug)
X				fprintf(stderr, "accept, ctrl %d\n", ctrl);
X			if (ctrl < 0) {
X				if (errno == EINTR)
X					continue;
X				syslog(LOG_WARNING, "accept (for %s): %m",
X					sep->se_service);
X				continue;
X			}
X		} else
X			ctrl = sep->se_fd;
X		(void) sigblock(SIGBLOCK);
X		pid = 0;
X		dofork = (sep->se_bi == 0 || sep->se_bi->bi_fork);
X		if (dofork) {
X			if (sep->se_count++ == 0)
X			    (void)gettimeofday(&sep->se_time,
X			        (struct timezone *)0);
X			else if (sep->se_count >= TOOMANY) {
X				struct timeval now;
X
X				(void)gettimeofday(&now, (struct timezone *)0);
X				if (now.tv_sec - sep->se_time.tv_sec >
X				    CNT_INTVL) {
X					sep->se_time = now;
X					sep->se_count = 1;
X				} else {
X					syslog(LOG_ERR,
X			"%s/%s server failing (looping), service terminated\n",
X					    sep->se_service, sep->se_proto);
X					FD_CLR(sep->se_fd, &allsock);
X					if (sep->se_family == AF_PTY)
X						FD_CLR(sep->se_fd, &allpty);
X					(void) close(sep->se_fd);
X					sep->se_fd = -1;
X					sep->se_count = 0;
X					nsock--;
X					sigsetmask(0L);
X					if (!timingout) {
X						timingout = 1;
X						alarm(RETRYTIME);
X					}
X					continue;
X				}
X			}
X			pid = fork();
X		}
X		if (pid < 0) {
X			if (isrealsock(sep) && sep->se_socktype == SOCK_STREAM)
X				close(ctrl);
X			sigsetmask(0L);
X			sleep(1);
X			continue;
X		}
X		if (pid && sep->se_wait) {
X			sep->se_wait = pid;
X			FD_CLR(sep->se_fd, &allsock);
X			if (sep->se_family == AF_PTY)
X				FD_CLR(sep->se_fd, &allpty);
X			nsock--;
X		}
X		sigsetmask(0L);
X		if (pid == 0) {
X			if (debug && dofork)
X				setsid();
X			if (sep->se_bi)
X				(*sep->se_bi->bi_fn)(ctrl, sep);
X			else {
X				if ((pwd = getpwnam(sep->se_user)) == NULL) {
X					syslog(LOG_ERR,
X						"getpwnam: %s: No such user",
X						sep->se_user);
X					if (isrealsock(sep) &&
X						sep->se_socktype != SOCK_STREAM)
X						recv(0, buf, sizeof (buf), 0);
X					_exit(1);
X				}
X				if (pwd->pw_uid) {
X					(void) setgid((gid_t)pwd->pw_gid);
X					initgroups(pwd->pw_name, pwd->pw_gid);
X					(void) setuid((uid_t)pwd->pw_uid);
X				}
X				if (debug)
X					fprintf(stderr, "%d execl %s\n",
X					    getpid(), sep->se_server);
X				dup2(ctrl, 0);
X				close(ctrl);
X				dup2(0, 1);
X				dup2(0, 2);
X				for (tmpint = getdtablesize(); --tmpint > 2; )
X					(void)close(tmpint);
X				execv(sep->se_server, sep->se_argv);
X				if (isrealsock(sep) &&
X					sep->se_socktype != SOCK_STREAM)
X					recv(0, buf, sizeof (buf), 0);
X				syslog(LOG_ERR, "execv %s: %m", sep->se_server);
X				_exit(1);
X			}
X		}
X		if (isrealsock(sep) && sep->se_socktype == SOCK_STREAM)
X			close(ctrl);
X		if (sep->se_family == AF_PTY) {
X			close(sep->se_fd);
X			sep->se_fd = -1;
X		}
X	    }
X	}
X}
X
Xvoid
Xreapchild()
X{
X	union wait status;
X	int pid;
X	register struct servtab *sep;
X
X	for (;;) {
X		pid = wait3(&status, WNOHANG, (struct rusage *)0);
X		if (pid <= 0)
X			break;
X		if (debug)
X			fprintf(stderr, "%d reaped\n", pid);
X		for (sep = servtab; sep; sep = sep->se_next)
X			if (sep->se_wait == pid) {
X				if (status.w_status)
X					syslog(LOG_WARNING,
X					    "%s: exit status 0x%x",
X					    sep->se_server, status.w_retcode);
X				sep->se_wait = 1;
X				if (sep->se_family == AF_PTY) {
X					setuppty(sep);
X				} else {
X					FD_SET(sep->se_fd, &allsock);
X					nsock++;
X				}
X				if (debug)
X					fprintf(stderr, "restored %s, fd %d\n",
X					    sep->se_service, sep->se_fd);
X			}
X	}
X}
X
Xvoid
Xconfig()
X{
X	register struct servtab *sep, *cp, **sepp;
X	struct servtab *getconfigent(), *enter();
X	long omask;
X	int n;
X
X	if (!setconfig()) {
X		syslog(LOG_ERR, "%s: %m", CONFIG);
X		return;
X	}
X	for (sep = servtab; sep; sep = sep->se_next)
X		sep->se_checked = 0;
X	while (cp = getconfigent()) {
X		for (sep = servtab; sep; sep = sep->se_next)
X			if (strcmp(sep->se_service, cp->se_service) == 0 &&
X			    strcmp(sep->se_proto, cp->se_proto) == 0)
X				break;
X		if (sep != 0) {
X			int i;
X
X			omask = sigblock(SIGBLOCK);
X			/*
X			 * sep->se_wait may be holding the pid of a daemon
X			 * that we're waiting for.  If so, don't overwrite
X			 * it unless the config file explicitly says don't 
X			 * wait.
X			 */
X			if (cp->se_bi == 0 && 
X			    (sep->se_wait == 1 || cp->se_wait == 0))
X				sep->se_wait = cp->se_wait;
X#define SWAP(a, b) { char *c = a; a = b; b = c; }
X			if (cp->se_user)
X				SWAP(sep->se_user, cp->se_user);
X			if (cp->se_server)
X				SWAP(sep->se_server, cp->se_server);
X			for (i = 0; i < MAXARGV; i++)
X				SWAP(sep->se_argv[i], cp->se_argv[i]);
X			if (isrpcservice(sep))
X				unregister_rpc(sep);
X			sep->se_rpcversl = cp->se_rpcversl;
X			sep->se_rpcversh = cp->se_rpcversh;
X			sigsetmask(omask);
X			freeconfig(cp);
X			if (debug)
X				print_service("REDO", sep);
X		} else {
X			sep = enter(cp);
X			if (debug)
X				print_service("ADD ", sep);
X		}
X		sep->se_checked = 1;
X
X		switch (sep->se_family) {
X		case AF_UNIX:
X			if (sep->se_fd != -1)
X				break;
X			(void)unlink(sep->se_service);
X			n = strlen(sep->se_service);
X			if (n > sizeof sep->se_ctrladdr_un.sun_path - 1) 
X				n = sizeof sep->se_ctrladdr_un.sun_path - 1;
X			strncpy(sep->se_ctrladdr_un.sun_path, sep->se_service, n);
X			sep->se_ctrladdr_un.sun_family = AF_UNIX;
X			sep->se_ctrladdr_size = n +
X					sizeof sep->se_ctrladdr_un.sun_family;
X			setup(sep);
X			break;
X		case AF_PTY:
X			if (sep->se_fd == -1 && sep->se_wait == 1)
X				setuppty(sep);
X			break;
X		case AF_INET:
X			sep->se_ctrladdr_in.sin_family = AF_INET;
X			sep->se_ctrladdr_size = sizeof sep->se_ctrladdr_in;
X			if (isrpcservice(sep)) {
X				struct rpcent *rp;
X
X				sep->se_rpcprog = atoi(sep->se_service);
X				if (sep->se_rpcprog == 0) {
X					rp = getrpcbyname(sep->se_service);
X					if (rp == 0) {
X						syslog(LOG_ERR,
X							"%s: unknown service",
X							sep->se_service);
X						continue;
X					}
X					sep->se_rpcprog = rp->r_number;
X				}
X				if (sep->se_fd == -1)
X					setup(sep);
X				if (sep->se_fd != -1)
X					register_rpc(sep);
X			} else {
X				u_short port = htons(atoi(sep->se_service));
X
X				if (!port) {
X					sp = getservbyname(sep->se_service,
X								sep->se_proto);
X					if (sp == 0) {
X						syslog(LOG_ERR,
X						    "%s/%s: unknown service",
X						    sep->se_service, sep->se_proto);
X						continue;
X					}
X					port = sp->s_port;
X				}
X				if (port != sep->se_ctrladdr_in.sin_port) {
X					sep->se_ctrladdr_in.sin_port = port;
X					if (sep->se_fd != -1) {
X						FD_CLR(sep->se_fd, &allsock);
X						nsock--;
X						(void) close(sep->se_fd);
X					}
X					sep->se_fd = -1;
X				}
X				if (sep->se_fd == -1)
X					setup(sep);
X			}
X		}
X	}
X	endconfig();
X	/*
X	 * Purge anything not looked at above.
X	 */
X	omask = sigblock(SIGBLOCK);
X	sepp = &servtab;
X	while (sep = *sepp) {
X		if (sep->se_checked) {
X			sepp = &sep->se_next;
X			continue;
X		}
X		*sepp = sep->se_next;
X		if (sep->se_fd != -1) {
X			FD_CLR(sep->se_fd, &allsock);
X			if (sep->se_family == AF_PTY)
X				FD_CLR(sep->se_fd, &allpty);
X			nsock--;
X			(void) close(sep->se_fd);
X		}
X		if (isrpcservice(sep))
X			unregister_rpc(sep);
X		if (sep->se_family == AF_UNIX)
X			(void)unlink(sep->se_service);
X		if (debug)
X			print_service("FREE", sep);
X		freeconfig(sep);
X		free((char *)sep);
X	}
X	(void) sigsetmask(omask);
X}
X
Xvoid
Xretry()
X{
X	register struct servtab *sep;
X
X	timingout = 0;
X	for (sep = servtab; sep; sep = sep->se_next)
X		if (sep->se_fd == -1) {
X			switch (sep->se_family) {
X			case AF_UNIX:
X			case AF_INET:
X				setup(sep);
X				if (sep->se_fd != -1 && isrpcservice(sep))
X					register_rpc(sep);
X				break;
X			case AF_PTY:
X				if (sep->se_wait == 1)
X					setuppty(sep);
X				break;
X			}
X		}
X}
X
Xsetup(sep)
X	register struct servtab *sep;
X{
X	int on = 1;
X
X	if ((sep->se_fd = socket(sep->se_family, sep->se_socktype, 0)) < 0) {
X		syslog(LOG_ERR, "%s/%s: socket: %m",
X		    sep->se_service, sep->se_proto);
X		return;
X	}
X#define	turnon(fd, opt) \
Xsetsockopt(fd, SOL_SOCKET, opt, (char *)&on, sizeof (on))
X	if (strcmp(sep->se_proto, "tcp") == 0 && (options & SO_DEBUG) &&
X	    turnon(sep->se_fd, SO_DEBUG) < 0)
X		syslog(LOG_ERR, "setsockopt (SO_DEBUG): %m");
X	if (turnon(sep->se_fd, SO_REUSEADDR) < 0)
X		syslog(LOG_ERR, "setsockopt (SO_REUSEADDR): %m");
X#undef turnon
X	if (bind(sep->se_fd, &sep->se_ctrladdr, sep->se_ctrladdr_size) < 0) {
X		syslog(LOG_ERR, "%s/%s: bind: %m",
X		    sep->se_service, sep->se_proto);
X		(void) close(sep->se_fd);
X		sep->se_fd = -1;
X		if (!timingout) {
X			timingout = 1;
X			alarm(RETRYTIME);
X		}
X		return;
X	}
X	if (sep->se_socktype == SOCK_STREAM)
X		listen(sep->se_fd, 10);
X
X	FD_SET(sep->se_fd, &allsock);
X	nsock++;
X	if (sep->se_fd > maxsock)
X		maxsock = sep->se_fd;
X}
X
Xregister_rpc(sep)
X	register struct servtab *sep;
X{
X#if RPC
X	int n;
X	struct sockaddr_in sin;
X	struct protoent *pp;
X
X	if ((pp = getprotobyname(sep->se_proto+4)) == NULL) {
X		syslog(LOG_ERR, "%s: getproto: %m",
X		    sep->se_proto);
X		return;
X	}
X	n = sizeof sin;
X	if (getsockname(sep->se_fd, &sin, &n) < 0) {
X		syslog(LOG_ERR, "%s/%s: getsockname: %m",
X		    sep->se_service, sep->se_proto);
X		return;
X	}
X
X	for (n = sep->se_rpcversl; n <= sep->se_rpcversh; n++) {
X		if (debug)
X			fprintf(stderr, "pmap_set: %u %u %u %u\n",
X			sep->se_rpcprog, n, pp->p_proto, sin.sin_port);
X		if (!pmap_set(sep->se_rpcprog, n, pp->p_proto, sin.sin_port))
X			syslog(LOG_ERR, "pmap_set: %u %u %u %u: %m",
X			sep->se_rpcprog, n, pp->p_proto, sin.sin_port);
X	}
X#endif RPC
X}
X
Xunregister_rpc(sep)
X	register struct servtab *sep;
X{
X	int n;
X
X#if RPC
X	for (n = sep->se_rpcversl; n <= sep->se_rpcversh; n++) {
X		if (debug)
X			fprintf(stderr, "pmap_unset(%u, %u)\n",
X				sep->se_rpcprog, n);
X		if (!pmap_unset(sep->se_rpcprog, n))
X			syslog(LOG_ERR, "pmap_unset(%u, %u)\n",
X				sep->se_rpcprog, n);
X	}
X#endif RPC
X}
X
Xsetuppty(sep)
X	register struct servtab *sep;
X{
X	if ((sep->se_fd = open(sep->se_service, O_RDWR, 0)) < 0) {
X		syslog(LOG_ERR, "%s/%s: open: %m",
X		    sep->se_service, sep->se_proto);
X		if (!timingout) {
X			timingout = 1;
X			alarm(RETRYTIME);
X		}
X		return;
X	}
X	FD_SET(sep->se_fd, &allsock);
X	FD_SET(sep->se_fd, &allpty);
X	nsock++;
X	if (sep->se_fd > maxsock)
X		maxsock = sep->se_fd;
X}
X
Xstruct servtab *
Xenter(cp)
X	struct servtab *cp;
X{
X	register struct servtab *sep;
X	long omask;
X
X	sep = (struct servtab *)malloc(sizeof (*sep));
X	if (sep == (struct servtab *)0) {
X		syslog(LOG_ERR, "Out of memory.");
X		exit(-1);
X	}
X	*sep = *cp;
X	sep->se_fd = -1;
X	sep->se_rpcprog = -1;
X	omask = sigblock(SIGBLOCK);
X	sep->se_next = servtab;
X	servtab = sep;
X	sigsetmask(omask);
X	return (sep);
X}
X
XFILE	*fconfig = NULL;
Xstruct	servtab serv;
Xchar	line[256];
Xchar	*skip(), *nextline();
X
Xsetconfig()
X{
X
X	if (fconfig != NULL) {
X		fseek(fconfig, 0L, L_SET);
X		return (1);
X	}
X	fconfig = fopen(CONFIG, "r");
X	return (fconfig != NULL);
X}
X
Xendconfig()
X{
X	if (fconfig) {
X		(void) fclose(fconfig);
X		fconfig = NULL;
X	}
X}
X
Xstruct servtab *
Xgetconfigent()
X{
X	register struct servtab *sep = &serv;
X	int argc;
X	char *cp, *arg, *strdup();
X
Xmore:
X	while ((cp = nextline(fconfig)) && *cp == '#')
X		;
X	if (cp == NULL)
X		return ((struct servtab *)0);
X	bzero((char *)sep, sizeof *sep);
X	sep->se_service = strdup(skip(&cp));
X	arg = skip(&cp);
X	if (strcmp(arg, "stream") == 0)
X		sep->se_socktype = SOCK_STREAM;
X	else if (strcmp(arg, "dgram") == 0)
X		sep->se_socktype = SOCK_DGRAM;
X	else if (strcmp(arg, "rdm") == 0)
X		sep->se_socktype = SOCK_RDM;
X	else if (strcmp(arg, "seqpacket") == 0)
X		sep->se_socktype = SOCK_SEQPACKET;
X	else if (strcmp(arg, "raw") == 0)
X		sep->se_socktype = SOCK_RAW;
X	else
X		sep->se_socktype = -1;
X
X	sep->se_proto = strdup(skip(&cp));
X	if (strcmp(sep->se_proto, "pty") == 0) {
X		sep->se_family = AF_PTY;
X	} else if (strcmp(sep->se_proto, "unix") == 0) {
X		sep->se_family = AF_UNIX;
X	} else {
X		sep->se_family = AF_INET;
X		if (strncmp(sep->se_proto, "rpc/", 4) == 0) {
X#if RPC
X			char *cp, *ccp;
X			cp = index(sep->se_service, '/');
X			if (cp == 0) {
X				syslog(LOG_ERR, "%s: no rpc version",
X				    sep->se_service);
X				goto more;
X			}
X			*cp++ = '\0';
X			sep->se_rpcversl =
X				sep->se_rpcversh = strtol(cp, &ccp, 0);
X			if (ccp == cp) {
X		badafterall:
X				syslog(LOG_ERR, "%s/%s: bad rpc version",
X				    sep->se_service, cp);
X				goto more;
X			}
X			if (*ccp == '-') {
X				cp = ccp + 1;
X				sep->se_rpcversh = strtol(cp, &ccp, 0); 
X				if (ccp == cp)
X					goto badafterall;
X			}
X#else
X			syslog(LOG_ERR, "%s: rpc services not suported",
X			    sep->se_service);
X			goto more;
X#endif RPC
X		}
X	}
X	arg = skip(&cp);
X	sep->se_wait = strcmp(arg, "wait") == 0;
X	if (sep->se_wait == 0 && sep->se_family == AF_PTY) {
X		syslog(LOG_ERR, "pty: only single threaded servers allowed: %s\n", sep->se_service);
X		sep->se_wait = 1;
X	}
X	sep->se_user = strdup(skip(&cp));
X	sep->se_server = strdup(skip(&cp));
X	if (strcmp(sep->se_server, "internal") == 0) {
X		register struct biltin *bi;
X
X		for (bi = biltins; bi->bi_service; bi++)
X			if (bi->bi_socktype == sep->se_socktype &&
X			    strcmp(bi->bi_service, sep->se_service) == 0)
X				break;
X		if (bi->bi_service == 0) {
X			syslog(LOG_ERR, "internal service %s unknown\n",
X				sep->se_service);
X			goto more;
X		}
X		sep->se_bi = bi;
X		sep->se_wait = bi->bi_wait;
X	} else
X		sep->se_bi = NULL;
X	argc = 0;
X	for (arg = skip(&cp); cp; arg = skip(&cp))
X		if (argc < MAXARGV)
X			sep->se_argv[argc++] = strdup(arg);
X	while (argc <= MAXARGV)
X		sep->se_argv[argc++] = NULL;
X	return (sep);
X}
X
Xfreeconfig(cp)
X	register struct servtab *cp;
X{
X	int i;
X
X	if (cp->se_service)
X		free(cp->se_service);
X	if (cp->se_proto)
X		free(cp->se_proto);
X	if (cp->se_user)
X		free(cp->se_user);
X	if (cp->se_server)
X		free(cp->se_server);
X	for (i = 0; i < MAXARGV; i++)
X		if (cp->se_argv[i])
X			free(cp->se_argv[i]);
X}
X
Xchar *
Xskip(cpp)
X	char **cpp;
X{
X	register char *cp = *cpp;
X	char *start;
X
Xagain:
X	while (*cp == ' ' || *cp == '\t')
X		cp++;
X	if (*cp == '\0') {
X		int c;
X
X		c = getc(fconfig);
X		(void) ungetc(c, fconfig);
X		if (c == ' ' || c == '\t')
X			if (cp = nextline(fconfig))
X				goto again;
X		*cpp = (char *)0;
X		return ((char *)0);
X	}
X	start = cp;
X	while (*cp && *cp != ' ' && *cp != '\t')
X		cp++;
X	if (*cp != '\0')
X		*cp++ = '\0';
X	*cpp = cp;
X	return (start);
X}
X
Xchar *
Xnextline(fd)
X	FILE *fd;
X{
X	char *cp;
X
X	if (fgets(line, sizeof (line), fd) == NULL)
X		return ((char *)0);
X	cp = index(line, '\n');
X	if (cp)
X		*cp = '\0';
X	return (line);
X}
X
Xchar *
Xstrdup(cp)
X	char *cp;
X{
X	char *new;
X
X	if (cp == NULL)
X		cp = "";
X	new = malloc((unsigned)(strlen(cp) + 1));
X	if (new == (char *)0) {
X		syslog(LOG_ERR, "Out of memory.");
X		exit(-1);
X	}
X	(void)strcpy(new, cp);
X	return (new);
X}
X
Xsetproctitle(a, s)
X	char *a;
X	int s;
X{
X	int size;
X	register char *cp;
X	struct sockaddr_in sin;
X	char buf[80];
X
X	cp = Argv[0];
X	size = sizeof(sin);
X	if (getpeername(s, &sin, &size) == 0)
X		(void) sprintf(buf, "-%s [%s]", a, inet_ntoa(sin.sin_addr)); 
X	else
X		(void) sprintf(buf, "-%s", a); 
X	strncpy(cp, buf, LastArg - cp);
X	cp += strlen(cp);
X	while (cp < LastArg)
X		*cp++ = ' ';
X}
X
Xlogpid()
X{
X	FILE *fp;
X
X	if ((fp = fopen(PIDFILE, "w")) != NULL) {
X		fprintf(fp, "%u\n", getpid());
X		(void)fclose(fp);
X	}
X}
X
X#ifdef sun
Xbump_nofile()
X{
X	struct rlimit rl;
X
X	if (getrlimit(RLIMIT_NOFILE, &rl) < 0)
X		return -1;
X	rl.rlim_cur = rl.rlim_max;
X	if (setrlimit(RLIMIT_NOFILE, &rl) < 0)
X		return -1;
X	return 0;
X}
X#endif
X
X/*
X * Internet services provided internally by inetd:
X */
X#define	BUFSIZE	4096
X
X/* ARGSUSED */
Xecho_stream(s, sep)		/* Echo service -- echo data back */
X	int s;
X	struct servtab *sep;
X{
X	char buffer[BUFSIZE];
X	int i;
X
X	setproctitle(sep->se_service, s);
X	while ((i = read(s, buffer, sizeof(buffer))) > 0 &&
X	    write(s, buffer, i) > 0)
X		;
X	exit(0);
X}
X
X/* ARGSUSED */
Xecho_dg(s, sep)			/* Echo service -- echo data back */
X	int s;
X	struct servtab *sep;
X{
X	char buffer[BUFSIZE];
X	int i, size;
X	struct sockaddr sa;
X
X	size = sizeof(sa);
X	if ((i = recvfrom(s, buffer, sizeof(buffer), 0, &sa, &size)) < 0)
X		return;
X	(void) sendto(s, buffer, i, 0, &sa, sizeof(sa));
X}
X
X/* ARGSUSED */
Xdiscard_stream(s, sep)		/* Discard service -- ignore data */
X	int s;
X	struct servtab *sep;
X{
X	char buffer[BUFSIZE];
X
X	setproctitle(sep->se_service, s);
X	while ((errno = 0, read(s, buffer, sizeof(buffer)) > 0) ||
X			errno == EINTR)
X		;
X	exit(0);
X}
X
X/* ARGSUSED */
Xdiscard_dg(s, sep)		/* Discard service -- ignore data */
X	int s;
X	struct servtab *sep;
X{
X	char buffer[BUFSIZE];
X
X	(void) read(s, buffer, sizeof(buffer));
X}
X
X#include <ctype.h>
X#define LINESIZ 72
Xchar ring[128];
Xchar *endring;
X
Xinitring()
X{
X	register int i;
X
X	endring = ring;
X
X	for (i = 0; i <= 128; ++i)
X		if (isprint(i))
X			*endring++ = i;
X}
X
X/* ARGSUSED */
Xchargen_stream(s, sep)		/* Character generator */
X	int s;
X	struct servtab *sep;
X{
X	register char *rs;
X	int len;
X	char text[LINESIZ+2];
X
X	setproctitle(sep->se_service, s);
X
X	if (!endring) {
X		initring();
X		rs = ring;
X	}
X
X	text[LINESIZ] = '\r';
X	text[LINESIZ + 1] = '\n';
X	for (rs = ring;;) {
X		if ((len = endring - rs) >= LINESIZ)
X			bcopy(rs, text, LINESIZ);
X		else {
X			bcopy(rs, text, len);
X			bcopy(ring, text + len, LINESIZ - len);
X		}
X		if (++rs == endring)
X			rs = ring;
X		if (write(s, text, sizeof(text)) != sizeof(text))
X			break;
X	}
X	exit(0);
X}
X
X/* ARGSUSED */
Xchargen_dg(s, sep)		/* Character generator */
X	int s;
X	struct servtab *sep;
X{
X	struct sockaddr sa;
X	static char *rs;
X	int len, size;
X	char text[LINESIZ+2];
X
X	if (endring == 0) {
X		initring();
X		rs = ring;
X	}
X
X	size = sizeof(sa);
X	if (recvfrom(s, text, sizeof(text), 0, &sa, &size) < 0)
X		return;
X
X	if ((len = endring - rs) >= LINESIZ)
X		bcopy(rs, text, LINESIZ);
X	else {
X		bcopy(rs, text, len);
X		bcopy(ring, text + len, LINESIZ - len);
X	}
X	if (++rs == endring)
X		rs = ring;
X	text[LINESIZ] = '\r';
X	text[LINESIZ + 1] = '\n';
X	(void) sendto(s, text, sizeof(text), 0, &sa, sizeof(sa));
X}
X
X/*
X * Return a machine readable date and time, in the form of the
X * number of seconds since midnight, Jan 1, 1900.  Since gettimeofday
X * returns the number of seconds since midnight, Jan 1, 1970,
X * we must add 2208988800 seconds to this figure to make up for
X * some seventy years Bell Labs was asleep.
X */
X
Xlong
Xmachtime()
X{
X	struct timeval tv;
X
X	if (gettimeofday(&tv, (struct timezone *)0) < 0) {
X		fprintf(stderr, "Unable to get time of day\n");
X		return (0L);
X	}
X	return (htonl((long)tv.tv_sec + 2208988800));
X}
X
X/* ARGSUSED */
Xmachtime_stream(s, sep)
X	int s;
X	struct servtab *sep;
X{
X	long result;
X
X	result = machtime();
X	(void) write(s, (char *) &result, sizeof(result));
X}
X
X/* ARGSUSED */
Xmachtime_dg(s, sep)
X	int s;
X	struct servtab *sep;
X{
X	long result;
X	struct sockaddr sa;
X	int size;
X
X	size = sizeof(sa);
X	if (recvfrom(s, (char *)&result, sizeof(result), 0, &sa, &size) < 0)
X		return;
X	result = machtime();
X	(void) sendto(s, (char *) &result, sizeof(result), 0, &sa, sizeof(sa));
X}
X
X/* ARGSUSED */
Xdaytime_stream(s, sep)		/* Return human-readable time of day */
X	int s;
X	struct servtab *sep;
X{
X	char buffer[256];
X	time_t time(), clock;
X	char *ctime();
X
X	clock = time((time_t *) 0);
X
X	(void) sprintf(buffer, "%.24s\r\n", ctime(&clock));
X	(void) write(s, buffer, strlen(buffer));
X}
X
X/* ARGSUSED */
Xdaytime_dg(s, sep)		/* Return human-readable time of day */
X	int s;
X	struct servtab *sep;
X{
X	char buffer[256];
X	time_t time(), clock;
X	struct sockaddr sa;
X	int size;
X	char *ctime();
X
X	clock = time((time_t *) 0);
X
X	size = sizeof(sa);
X	if (recvfrom(s, buffer, sizeof(buffer), 0, &sa, &size) < 0)
X		return;
X	(void) sprintf(buffer, "%.24s\r\n", ctime(&clock));
X	(void) sendto(s, buffer, strlen(buffer), 0, &sa, sizeof(sa));
X}
X
X/*
X * print_service:
X *	Dump relevant information to stderr
X */
Xprint_service(action, sep)
X	char *action;
X	struct servtab *sep;
X{
X	fprintf(stderr,
X	    "%s: %s proto=%s, wait=%d, user=%s builtin=%x server=%s\n",
X	    action, sep->se_service, sep->se_proto,
X	    sep->se_wait, sep->se_user, (int)sep->se_bi, sep->se_server);
X}
END_OF_FILE
if test 28032 -ne `wc -c <'munetd.c'`; then
    echo shar: \"'munetd.c'\" unpacked with wrong size!
fi
# end of 'munetd.c'
fi
if test -f 'setenv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'setenv.c'\"
else
echo shar: Extracting \"'setenv.c'\" \(2997 characters\)
sed "s/^X//" >'setenv.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1987 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that: (1) source distributions retain this entire copyright
X * notice and comment, and (2) distributions including binaries display
X * the following acknowledgement:  ``This product includes software
X * developed by the University of California, Berkeley and its contributors''
X * in the documentation or other materials provided with the distribution
X * and in all advertising materials mentioning features or use of this
X * software. Neither the name of the University nor the names of its
X * contributors may be used to endorse or promote products derived
X * from this software without specific prior written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
X * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
X * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)setenv.c	5.4 (Berkeley) 6/1/90";
X#endif /* LIBC_SCCS and not lint */
X
X#include <stddef.h>
X#include <stdlib.h>
X
X/*
X * setenv --
X *	Set the value of the environmental variable "name" to be
X *	"value".  If rewrite is set, replace any current value.
X */
Xsetenv(name, value, rewrite)
X	register char *name, *value;
X	int rewrite;
X{
X	extern char **environ;
X	static int alloced;			/* if allocated space before */
X	register char *C;
X	int l_value, offset;
X	char *_findenv();
X
X	if (*value == '=')			/* no `=' in value */
X		++value;
X	l_value = strlen(value);
X	if ((C = _findenv(name, &offset))) {	/* find if already exists */
X		if (!rewrite)
X			return(0);
X		if (strlen(C) >= l_value) {	/* old larger; copy over */
X			while (*C++ = *value++);
X			return(0);
X		}
X	}
X	else {					/* create new slot */
X		register int	cnt;
X		register char	**P;
X
X		for (P = environ, cnt = 0; *P; ++P, ++cnt);
X		if (alloced) {			/* just increase size */
X			environ = (char **)realloc((char *)environ,
X			    (size_t)(sizeof(char *) * (cnt + 2)));
X			if (!environ)
X				return(-1);
X		}
X		else {				/* get new space */
X			alloced = 1;		/* copy old entries into it */
X			P = (char **)malloc((size_t)(sizeof(char *) *
X			    (cnt + 2)));
X			if (!P)
X				return(-1);
X			bcopy(environ, P, cnt * sizeof(char *));
X			environ = P;
X		}
X		environ[cnt + 1] = NULL;
X		offset = cnt;
X	}
X	for (C = name; *C && *C != '='; ++C);	/* no `=' in name */
X	if (!(environ[offset] =			/* name + `=' + value */
X	    malloc((size_t)((int)(C - name) + l_value + 2))))
X		return(-1);
X	for (C = environ[offset]; (*C = *name++) && *C != '='; ++C);
X	for (*C++ = '='; *C++ = *value++;);
X	return(0);
X}
X
X/*
X * unsetenv(name) --
X *	Delete environmental variable "name".
X */
Xvoid
Xunsetenv(name)
X	char	*name;
X{
X	extern char **environ;
X	register char **P;
X	int offset;
X
X	while (_findenv(name, &offset))		/* if set multiple times */
X		for (P = &environ[offset];; ++P)
X			if (!(*P = *(P + 1)))
X				break;
X}
END_OF_FILE
if test 2997 -ne `wc -c <'setenv.c'`; then
    echo shar: \"'setenv.c'\" unpacked with wrong size!
fi
# end of 'setenv.c'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
