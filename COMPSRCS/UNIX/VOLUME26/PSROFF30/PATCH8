Newsgroups: comp.sources.unix
From: clewis@ferret.ocunix.on.ca (Chris Lewis)
Subject: v26i015: psroff 3.0, Patch08
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: clewis@ferret.ocunix.on.ca (Chris Lewis)
Posting-Number: Volume 26, Issue 15
Archive-Name: psroff3.0/patch8

    This is official patch 08 for Psroff 3.0.
    Please apply it by:
	cd <psroff source directory>
	touch ljdraw.c lj3draw.c	(not necessary for most versions of
					patch, but some need it)
	patch -N -p < <this file>

	Please read the notes below before recompilation.  This
	is a biggie - graphics support on LJ's, and I thought
	I'd get it out before it got any worse ;-)
    
    The base release of psroff3.0 and previous patches were in
    comp.sources.unix volume 24 and 25.

    Major changes:
	1) Support for vertical and horizontal lines (\D) when driving
	   HP Laserjets and II's.  Now groff users can use tbl and
	   get boxes to work on II's and prior.
	2) Full \D support on HP LJ III's - eg: full pic support on
	   III's from ditroff.  This is done by popping into HPGL
	   mode.  This has also necessitated adding a lj3 driver
	   type into troff2ps.  If you are driving a lj3, make sure
	   your psrofflib entry has -Tlj3 instead of -Tlj.
	   Thanks to David Wexelblat.
	3) asc2ps/psxlate now compiles and works under VMS - define VMS
	   in defs.h first.
	4) Improved documentation in defs.h and Makefile for configuration.
	   Read them before rebuilding - ESPECIALLY if Apollo.
	5) Had SHELL assignment in submakes.  Apollos compile better.
	   (maybe Sonys too)  Lessening need for zap program.

Incidentally, psroff is reaching the limits of the functionality I
think it should have.  I'm starting to contemplate doing a full rerelease
as Psroff 4.0.  This would have a patch independent configuration,
integrated hp2pbm and psnup.  Patch 9 will have a replacement for
"make check" that does a FAR better job at figuring out your configuration
than the current one can.  It will also have the rest of the drawing
functionality for non-III LJ's.  Then we'll just shake the thing out
a bit more and rerelease.

If you have trouble configuring psroff before patch 9 comes out, ask me
for a copy of "checker".

	clewis@ferret.ocunix.on.ca (Chris Lewis)

./lib/lj3.lib		HPGL mode initialization
./lib/psrofflib.S	switch lj3 emission over to -Tlj3 to troff2ps
			(you may reject here.  All you need to do is
			change -Tlj to -Tlj3)
./utils/psxlate.c	VMS support
./utils/asc2ps.c	VMS support
./lj.h			graphics stuff
./utils.c		Commoned "require" routine
./ps.c			Commoned "require" routine
./defs.h		PL8, lj3draw support
./INSTALL		Documentation improvements
./TROUBLE		Documentation improvements
./Makefile		Documentation improvements/lj*draw inclusions/SHELL
./t2conf.c		lj3 driver/draw.
./opt.c			SVR4 compiler complaints
./lj.c			graphics
./makeincl.S		SHELL
./ljdraw.c		LJ/LJII graphics driver (hor and vert lines only yet)
./debug.c		SVR4 compiler complaints
./lj3draw.c		LJIII graphics driver

Patchwrapped: 920123145338

Index: ./lib/lj3.lib
*** /tmp/PATCHold/./lib/lj3.lib	Thu Jan 23 14:49:43 1992
--- ./lib/lj3.lib	Thu Jan 23 14:49:44 1992
***************
*** 29,36 ****
  %			\xAABB \022 A %hello
  %			Passes the following bytes: 0xAA, 0xBB, 022, and "A"
  %			through to the laserjet.
! %ident  @(#)lj3.lib: 2.1 Copyright 90/07/18 16:52:26 Chris Lewis"
! \033E\033&k2G			%reset printer, set CR=CR,LF=CRLF,FF=CRFF */
! \033&l6d66p0o0e66f0L		%letter size, portrait, no perf skip */
! \0339				%reset side margins */
! \033&a0r0C			%move cursor to 0,0 */
--- 29,43 ----
  %			\xAABB \022 A %hello
  %			Passes the following bytes: 0xAA, 0xBB, 022, and "A"
  %			through to the laserjet.
! %ident  @(#)lj3.lib: 2.2 Copyright 92/01/23 14:27:59 Chris Lewis"
! \033E\033&k2G			%reset printer, set CR=CR,LF=CRLF,FF=CRFF 
! \033&l6d66p0o0e66f0L		%letter size, portrait, no perf skip
! \0339				%reset side margins
! \033&a0h0V			%move cursor to 0,0
! \033*c6120x7920y0T\033\045 1B	%set HP-GL/2 picture frame, go to HP-GL/2
! IN;WU0;LW0.5;SP1;		%initialize, pen widths in MM, 0.5MM for pen 1
! LA1,4,2,4;			%set round line caps & joins
! TR0;				%set transparency mode off
! IP0,11176,8636,0;		%set orientation to match PCL
! SC0,2550,0,3300;PU0,0;		%scale HP-GL/2 to 300dpi dots like PCL
! \033\045 1A			%return to PCL mode
Index: ./lib/psrofflib.S
*** /tmp/PATCHold/./lib/psrofflib.S	Thu Jan 23 14:49:53 1992
--- ./lib/psrofflib.S	Thu Jan 23 14:49:55 1992
***************
*** 1,4 ****
! #	2.22 91/12/07
  #	This file controls psroff, you can insert additional printer
  #	types here.  These are eval'd *late* in processing, so that
  #	you can insert $copies etc.
--- 1,4 ----
! #	2.23 92/01/23
  #	This file controls psroff, you can insert additional printer
  #	types here.  These are eval'd *late* in processing, so that
  #	you can insert $copies etc.
***************
*** 157,172 ****
  
  #	Laserjet III (built-in fonts, using supplied widths, Times base)
  
! lj3	width=lj3 t2arg='-Tlj -plj3 -W%%FONTDIR%%/lj3'
  lj3	lparg='| lp -d$ptr -og -n$copies' ptr=laser
  #	Laserjet III (built-in fonts, using supplied widths, Univers base)
! lj3u	width=lj3u t2arg='-Tlj -plj3u -W%%FONTDIR%%/lj3u'
  lj3u	lparg='| lp -d$ptr -og -n$copies' ptr=laser
  #	Ditroff:
! dlj3	width=lj3 t2arg='-Tlj -plj3 -N -W%%FONTDIR%%/lj3'
  dlj3	lparg='| lp -d$ptr -og -n$copies' ptr=laser
  #	Ditroff:
! dlj3u	width=lj3u t2arg='-Tlj -plj3u -N -W%%FONTDIR%%/lj3u'
  dlj3u	lparg='| lp -d$ptr -og -n$copies' ptr=laser
  
  
--- 157,172 ----
  
  #	Laserjet III (built-in fonts, using supplied widths, Times base)
  
! lj3	width=lj3 t2arg='-Tlj3 -plj3 -W%%FONTDIR%%/lj3'
  lj3	lparg='| lp -d$ptr -og -n$copies' ptr=laser
  #	Laserjet III (built-in fonts, using supplied widths, Univers base)
! lj3u	width=lj3u t2arg='-Tlj3 -plj3u -W%%FONTDIR%%/lj3u'
  lj3u	lparg='| lp -d$ptr -og -n$copies' ptr=laser
  #	Ditroff:
! dlj3	width=lj3 t2arg='-Tlj3 -plj3 -N -W%%FONTDIR%%/lj3'
  dlj3	lparg='| lp -d$ptr -og -n$copies' ptr=laser
  #	Ditroff:
! dlj3u	width=lj3u t2arg='-Tlj3 -plj3u -N -W%%FONTDIR%%/lj3u'
  dlj3u	lparg='| lp -d$ptr -og -n$copies' ptr=laser
  
  
***************
*** 259,263 ****
  #	width directories/devlj3 for this to work.
  troff=gtroff
  trofftype='-T$width'
! glj3	width=lj3 t2args='-Tlj -plj3 -N -Z -O0 -W%%FONTDIR%%/lj3 -G1'
  glj3	lparg='lp -og -d$ptr -n$copies' ptr=laser
--- 259,263 ----
  #	width directories/devlj3 for this to work.
  troff=gtroff
  trofftype='-T$width'
! glj3	width=lj3 t2args='-Tlj3 -plj3 -N -Z -O0 -W%%FONTDIR%%/lj3 -G1'
  glj3	lparg='lp -og -d$ptr -n$copies' ptr=laser
Index: ./utils/psxlate.c
*** /tmp/PATCHold/./utils/psxlate.c	Thu Jan 23 14:50:09 1992
--- ./utils/psxlate.c	Thu Jan 23 14:50:11 1992
***************
*** 23,29 ****
   */
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)psxlate.c: 2.18 Copyright 91/12/21 13:13:44 Chris Lewis";
  #endif
  
  #ifdef	ALONE
--- 23,29 ----
   */
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)psxlate.c: 2.19 Copyright 92/01/23 14:22:16 Chris Lewis";
  #endif
  
  #ifdef	ALONE
***************
*** 66,72 ****
--- 66,76 ----
  
  char shuffle[100];
  
+ #ifdef VMS
+ char tmp[] = {"SYS$SCRATCH:psxXXXXXX.tmp"};
+ #else
  char tmp[] = {"/tmp/psxXXXXXX"};
+ #endif /* ifdef VMS */
  
  int pagecnt = 0;
  char *progname;
***************
*** 74,80 ****
--- 78,88 ----
  char *mygets();
  
  #ifndef	LIBDIR
+ #ifdef VMS
+ #define	LIBDIR	"PSROFF_POSTSCRIPT"
+ #else
  #define	LIBDIR	"/usr/lib/troff2"
+ #endif /* ifdef VMS */
  #endif
  
  char	cmdbuffer[BUFFERSIZE];	/* for psnup stuff */
***************
*** 94,99 ****
--- 102,113 ----
      char *si = shuffle;
      long offset, oldoffset;
  
+ #ifdef VMS
+     if(!shell$is_shell())
+       shell_mung(&argc,&argv,0,"n-p-s-");
+ #endif /* ifdef VMS */
+ 
+ 
      progname = argv[0];
  
  
***************
*** 144,156 ****
--- 158,178 ----
  		progname, startspot, pages - 1, pages);
  	    psnupok = 0;
  	}
+ #ifdef VMS
+ 	sprintf(cmdbuffer, "%s:nup.pro", LIBDIR);
+ #else
  	sprintf(cmdbuffer, "%s/nup.pro", LIBDIR);
+ #endif /* ifdef VMS */
  	if (access(cmdbuffer, 4) != 0) {
  	    fprintf(stderr, "%s: can't do n-up (no nup.pro at %s)\n",
  		progname, cmdbuffer);
  	    psnupok = 0;
  	}
+ #ifdef VMS
+ 	sprintf(cmdbuffer, "%s:nup.epi", LIBDIR);
+ #else
  	sprintf(cmdbuffer, "%s/nup.epi", LIBDIR);
+ #endif /* ifdef VMS */
  	if (access(cmdbuffer, 4) != 0) {
  	    fprintf(stderr, "%s: can't do n-up (no nup.epi at %s)\n",
  		progname, cmdbuffer);
***************
*** 326,332 ****
--- 348,358 ----
  
  cleanup() {
      if (!debug)
+ #ifdef VMS
+         delete(tmp);
+ #else
  	unlink(tmp);
+ #endif /* ifdef VMS */
  }
  
  emit(fname)
***************
*** 342,348 ****
--- 368,378 ----
  	fputs(magicstr, stdout);
  
      if (psnupwanted) {
+ #ifdef VMS
+ 	sprintf(cmdbuffer, "%s:nup.pro", LIBDIR);
+ #else
  	sprintf(cmdbuffer, "%s/nup.pro", LIBDIR);
+ #endif /* ifdef VMS */
  	emitnup(cmdbuffer, 1);
      }
  
***************
*** 362,368 ****
--- 392,402 ----
      emitsect(file, &epilog);
  
      if (psnupwanted) {
+ #ifdef VMS
+ 	sprintf(cmdbuffer, "%s:nup.epi", LIBDIR);
+ #else
  	sprintf(cmdbuffer, "%s/nup.epi", LIBDIR);
+ #endif /* ifdef VMS */
  	emitnup(cmdbuffer, 0);
      }
  
Index: ./utils/asc2ps.c
*** /tmp/PATCHold/./utils/asc2ps.c	Thu Jan 23 14:50:23 1992
--- ./utils/asc2ps.c	Thu Jan 23 14:50:25 1992
***************
*** 14,20 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)asc2ps.c: 2.5 Copyright 91/05/25 21:27:18 Chris Lewis";
  #endif
  
  #ifndef	STANDALONE
--- 14,20 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)asc2ps.c: 2.6 Copyright 92/01/23 14:22:06 Chris Lewis";
  #endif
  
  #ifndef	STANDALONE
***************
*** 118,123 ****
--- 118,128 ----
      extern char *optarg;
      char buffer[BUFLEN];
  
+ #ifdef VMS
+     if(!shell$is_shell())
+       shell_mung(&argc,&argv,0,"s-");
+ #endif /* ifdef VMS */
+ 
      progname = argv[0];
  
      while((c = getopt(argc, argv, "plPLis:")) != EOF)
***************
*** 203,208 ****
--- 208,217 ----
  char nodename[25];
  
  getnodename() {
+ 
+ #ifdef VMS
+     strcpy(nodename, "<nodename>"); /* ignore getsyi("nodename") */
+ #else
      FILE *uuname;
      if ((uuname = popen(NODECMD, "r")) == NULL)
  	strcpy(nodename, "<noname>");
***************
*** 210,220 ****
--- 219,234 ----
  	fscanf(uuname, "%s", nodename);
  	pclose(uuname);
      }
+ #endif /* ifdef VMS */
  }
  
  doprolog() {
      extern char *ctime();
+ #ifdef VMS   /* dont worry about getjpi("","username") */ 
+ #define getlogin() "<username>"
+ #else
      extern char *getlogin();
+ #endif /* ifdef VMS */
      extern char *strchr();
      long curtime;
      register char *tp;
Index: ./lj.h
*** /tmp/PATCHold/./lj.h	Thu Jan 23 14:50:35 1992
--- ./lj.h	Thu Jan 23 14:50:36 1992
***************
*** 8,17 ****
      Function:		Laserjet Driver definitions
   */
  
! /* 2.2 91/02/20 */
  
! /*	We're using decipoints */
! #define	LJRESOLUTION	720
  
  /*	Troff assumes 7.5" paper width, most macro packages print in
  	6.5" area within that.  Sooo, we'll center the paperwidth on the
--- 8,17 ----
      Function:		Laserjet Driver definitions
   */
  
! /* 2.3 92/01/12 */
  
! /*	We're using dots now */
! #define	LJRESOLUTION	300
  
  /*	Troff assumes 7.5" paper width, most macro packages print in
  	6.5" area within that.  Sooo, we'll center the paperwidth on the
***************
*** 21,27 ****
  /*	11" paper length */
  #define	TROFF2LJY(y) (((long) (y)+pageyoffset)*LJRESOLUTION/TROFFRESOLUTION)
  
! extern int ljProlog(), ljEpilog(), ljChar(), ljPage();
  
  extern struct troff2befont ljSymFont[], ljStdFont[];
  
--- 21,27 ----
  /*	11" paper length */
  #define	TROFF2LJY(y) (((long) (y)+pageyoffset)*LJRESOLUTION/TROFFRESOLUTION)
  
! extern int ljProlog(), ljEpilog(), ljChar(), ljPage(), ljDraw();
  
  extern struct troff2befont ljSymFont[], ljStdFont[];
  
Index: ./utils.c
*** /tmp/PATCHold/./utils.c	Thu Jan 23 14:50:46 1992
--- ./utils.c	Thu Jan 23 14:50:48 1992
***************
*** 12,18 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)utils.c: 2.22 Copyright 91/12/26 17:58:48 Chris Lewis";
  #endif
  
  #ifndef	HEADERSIZE
--- 12,18 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)utils.c: 2.23 Copyright 92/01/12 03:55:40 Chris Lewis";
  #endif
  
  #ifndef	HEADERSIZE
***************
*** 589,591 ****
--- 589,604 ----
      }
      return(opcode);
  }
+ 
+ #ifdef	INSPECIAL
+ require(need, have, cmd, string)
+ int need, have;
+ char *cmd, *string; {
+     if (need != have) {
+ 	fprintf(stderr, "%s: need %d argument%s to draw a %s (%s)\n",
+ 	    progname, need, need == 1? "": "s", cmd, string);
+ 	return(1);
+     } else
+ 	return(0);
+ }
+ #endif
Index: ./ps.c
*** /tmp/PATCHold/./ps.c	Thu Jan 23 14:51:01 1992
--- ./ps.c	Thu Jan 23 14:51:06 1992
***************
*** 15,21 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)ps.c: 2.17 Copyright 91/11/22 03:56:10 Chris Lewis";
  #endif
  
  /*	ps.c will generate some additional "print" commands to cause
--- 15,21 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)ps.c: 2.18 Copyright 92/01/12 03:55:46 Chris Lewis";
  #endif
  
  /*	ps.c will generate some additional "print" commands to cause
***************
*** 463,468 ****
--- 463,469 ----
      emitnum(val);
      putchar(' ');
  }
+ 
  emitnum(val)
  register int val; {
      register int neg;
***************
*** 480,485 ****
--- 481,487 ----
      if (val)
  	printf(".%d", val);
  }
+ 
  putnl(s)
  char *s; {
      fputs(s, stdout);
***************
*** 595,612 ****
  }
  
  #ifdef	INSPECIAL
- 
- static
- require(need, have, cmd, string)
- int need, have;
- char *cmd, *string; {
-     if (need != have) {
- 	fprintf(stderr, "%s: need %d argument%s to draw a %s (%s)\n",
- 	    progname, need, need == 1? "": "s", cmd, string);
- 	return(1);
-     } else
- 	return(0);
- }
  
  /*	Do ditroff drawing command in s from origX,origY.
  	If opcode 0 just moveto
--- 597,602 ----
Index: ./defs.h
*** /tmp/PATCHold/./defs.h	Thu Jan 23 14:51:26 1992
--- ./defs.h	Thu Jan 23 14:51:28 1992
***************
*** 9,15 ****
   */
  
  /*	Official Release and Patch level:	*/
! #define	T2VERSION	"@(#)PSROFF Copyright 91/12/26 Chris Lewis - R3 PL7"
  
  /*	Configuration parameters:
   */
--- 9,15 ----
   */
  
  /*	Official Release and Patch level:	*/
! #define	T2VERSION	"@(#)PSROFF Copyright 92/01/23 Chris Lewis - R3 PL8"
  
  /*	Configuration parameters:
   */
***************
*** 26,32 ****
  			/* a bcopy in your library */
  
  #undef	REGSPILL	/* Define if your compiler gives "infinite register
! 			   spill in utils/psxlate.c (Xenix III) */
  	
  
  /*	The name of a routine that can be called thusly:
--- 26,32 ----
  			/* a bcopy in your library */
  
  #undef	REGSPILL	/* Define if your compiler gives "infinite register
! 			   spill" in utils/psxlate.c (Xenix III) */
  	
  
  /*	The name of a routine that can be called thusly:
***************
*** 45,63 ****
  /* If you have the stand-alone pk2sfp distribution, do not touch
     anything from here on */
  
! /*	Font width file configuration:
  
! 	- If HEADERSIZE defined, use that many bytes as a prefix to the
! 	  compiled font width table.  HEADERSIZE 0 is the correct definition
! 	  for Xenix and most System V [o]troffs.  HEADERSIZE=32 works for Ultrix
! 	  (except RISC, see below).  HEADERSIZE=32 works properly for most Suns.
! 	- If neither are defined, use a BSD/V7 style a.out.h header, this
! 	  is appropriate for V7 and BSD troffs
! 	- If you are running RISC/Ultrix (Mips box? from DEC) define
! 	  ASCIIWIDTHS, and the rest of this stuff will be ignored - Mips
! 	  apparently changed their width table format to an ASCII form,
! 	  and DEC picked it up.  In this case IGNORE any messages about
! 	  HEADERSIZE from "make check".
  
      The headers I write will have something in them if HEADERSIZE > 0
      and there's a font file from your original troff distribution in
--- 45,76 ----
  /* If you have the stand-alone pk2sfp distribution, do not touch
     anything from here on */
  
! /*	Font width file configuration (applicable to CAT troff):
  
! 	1) if the /usr/lib/font/ftR file in your original troff
! 	   installation is 224 bytes long, set HEADERSIZE to 0.
! 	   Most Xenix.
! 
! 	2) If the size of /usr/lib/font/ftR is > 224, and your system
! 	   uses a.out.h headers on executable binaries, HEADERSIZE
! 	   should be the size of the a.out header.  Usually 32.
! 	   (Ie: SunOS, VAX/Ultrix)
! 
! 	3) If the size of /usr/lib/font/ftR is large (around 1K), chances
! 	   are that your system uses COFF headers on font files.
! 	   HEADERSIZE should be set to the offset of the data section
! 	   within /usr/lib/font/ftR.  Which is a bit tricky to find out.
! 	   However, Apollo DomainOS is the only system I know that has
! 	   COFF headers.  SR10.3 needs HEADERSIZE set to 304.  Prior
! 	   DomainOS versions (eg: SR10.2) appear to need 336.
! 
! 	4) If you are DEC Risc/Ultrix (not VAX/Ultrix) define
! 	   ASCIIWIDTHS.  HEADERSIZE is irrelevant.
! 
!     See the description of HEADERSIZE, and the "HEADERSIZE Calculations"
!     section in the TROUBLE document if you have difficulty.  There is
!     extensive instructions on how to determine this parameter.  This
!     parameter is the most common cause of problems.
  
      The headers I write will have something in them if HEADERSIZE > 0
      and there's a font file from your original troff distribution in
***************
*** 110,115 ****
--- 123,129 ----
  /*	Basic drivers: */
  #define	PS	/* Postscript */
  #define	LJ	/* Laserjet - utils programs will not build with this undef'd */
+ #define	LJ3	/* Laserjet 3 - does LJ + HP-GL/2 for PIC */
  #define	DT	/* ditroff */
  #define	DIT	/* ditroff *front-end* */
  
***************
*** 176,181 ****
--- 190,201 ----
  			   you have to do this, please contact me with the
  			   particulars of the problem and your configuration */
  
+ #undef LJ3_7BIT		/* define to make repeated vector encoding (HP-GL/2
+ 			   PE command) use 7-bit encoding.  Define this only
+ 			   if driver will be used on a 7-bit serial path.
+ 			   This is rarely helpful, because font downloading
+ 			   needs a 8 bit path */
+ 
  /*	Edit no more .... */
  
  #define	MAXDLFONTS (MDLF - PRELOAD)	/* # fonts troff2ps can download */
***************
*** 401,406 ****
--- 421,427 ----
  #define	D_PK	0x20	/* PK font handling */
  #define	D_VERB	0x40	/* very verbose */
  #define	D_FLSH	0x80	/* flush after each fprintf */
+ #define D_PIC	0x100	/* show pic commands */
  
  extern int debug;
  
Index: ./INSTALL
*** /tmp/PATCHold/./INSTALL	Thu Jan 23 14:51:39 1992
--- ./INSTALL	Thu Jan 23 14:51:41 1992
***************
*** 1,5 ****
  		Psroff 3.0 Installation Instructions
! 			2.16 91/08/29
  
  Please see the TROUBLE file if you have difficulties.
  The README file does provide a bit more background on some
--- 1,5 ----
  		Psroff 3.0 Installation Instructions
! 			2.17 92/01/12
  
  Please see the TROUBLE file if you have difficulties.
  The README file does provide a bit more background on some
***************
*** 56,61 ****
--- 56,63 ----
  	  will abort with "Error n" without any other diagnostic information.
  	  (Tested on RISC/Ultrix 4.2)
  
+ 	  On Apollo, set SHELL to /bin/ksh.
+ 
  	- If you're building for ditroff input only, ignore the discussions
  	  on HEADERSIZE and trofftype.
  
***************
*** 87,102 ****
  	  see if we can get DEC to put it in as a update]
  
  	  Apollos need the -F trofftype variant.  Their HEADERSIZE
! 	  calculation is strange.  You should set HEADERSIZE
! 	  to 0, and proceed with these instructions, but do NOT
! 	  install psroff.  Once you've built psroff, consult
! 	  the TROUBLE file on how to run "dumpft -gv", which
! 	  will tell you what your HEADERSIZE should be, then you
! 	  should rebuild, test and install.
! 
! 	  The dumpft -gv trick will actually work on most systems
! 	  (except RISC/Ultrix), but it requires you to rebuild psroff
! 	  twice...
  
  	- NOTE: during installs as root, the makefiles attempt to be
  	  careful about the modes of the files it creates.  HOWEVER,
--- 89,98 ----
  	  see if we can get DEC to put it in as a update]
  
  	  Apollos need the -F trofftype variant.  Their HEADERSIZE
! 	  calculation is strange.  If you are SR10.3, set HEADERSIZE
! 	  to 304.  On SR10.2 and earlier, set HEADERSIZE to 336.
! 	  If this doesn't work out, consult the TROUBLE file
! 	  on "HEADERSIZE calculations".
  
  	- NOTE: during installs as root, the makefiles attempt to be
  	  careful about the modes of the files it creates.  HOWEVER,
***************
*** 146,157 ****
  	  is copiously documented there.
  
  	- edit defs.h and define either BSD or ATT.  A few other options will
! 	  pertain to you.  Take special note of HEADERSIZE.  Take a look
! 	  at /usr/lib/font/ftR.  Is it 224 bytes long?  If so, HEADERSIZE
! 	  should be 0.  Otherwise you will probably have to set it to the
! 	  size of your a.out.h structure.  VAX Ultrix and Sun appear to always
! 	  be HEADERSIZE = 32.  See remark about RISC Ultrix above.  If you're
! 	  Apollo, see remark above, plus info in TROUBLE file about Apollos.
  
  	  With Laserjet driving:
  
--- 142,148 ----
  	  is copiously documented there.
  
  	- edit defs.h and define either BSD or ATT.  A few other options will
! 	  pertain to you.  Take special note of HEADERSIZE.
  
  	  With Laserjet driving:
  
***************
*** 303,308 ****
--- 294,302 ----
  
  	  Once you've printed the test sheet, if there seems to be any problems,
  	  consult the "TEST SHEET ANALYSIS" section of the TROUBLE files.
+ 
+ 	  You can also consult the "Last Ditch Defense" section in the
+ 	  TROUBLE file as part of your analysis of what went wrong.
  
  	- If you're running Postscript and you want to use n-up printing
  	  (see psxlate(1)), you should obtain the psnup distribution
Index: ./TROUBLE
*** /tmp/PATCHold/./TROUBLE	Thu Jan 23 14:51:55 1992
--- ./TROUBLE	Thu Jan 23 14:51:58 1992
***************
*** 1,4 ****
! 		Psroff 3.0 Trouble Shooting.... 2.16 91/11/13
  
  (psroff 1.0 users can use this to a certain extent.  This is relatively
  unchanged from Psroff 2.0 except for the ditroff input capability)
--- 1,4 ----
! 		Psroff 3.0 Trouble Shooting.... 2.17 92/01/12
  
  (psroff 1.0 users can use this to a certain extent.  This is relatively
  unchanged from Psroff 2.0 except for the ditroff input capability)
***************
*** 16,21 ****
--- 16,22 ----
  odd to warrant mention here: if your makes blow up without much
  in the way of diagnostics, refer to the INSTALL file regarding
  the setting of SHELL, MAKE and use of "s5make" instead of "make".
+ Apollo seems to like SHELL set to /bin/ksh.
  
  Unless specified, the remarks in this file pertain to CAT troff input,
  not ditroff input.
***************
*** 70,136 ****
  		M<string>
  	  These are back-end directives and they're supposed to be
  	  there during psroff debug - ignore them.
- 	- HEADERSIZE: most troff's need an a.out.h header on the front
- 	  of the width table files.  HEADERSIZE (defs.h) allows you to
- 	  specify an arbitrary number of bytes on the front of the table
- 	  in the width file.  Check /usr/lib/font/ftR (should be part
- 	  of your original troff installation).  Is ftR 224 bytes long?
- 	  If so, HEADERSIZE should be zero.  If not (eg: Ultrix,
- 	  BSD's, some older Xenix, V7), you will have to specify
- 	  HEADERSIZE.  SunOS, VAX/Ultrix wants 32.  (should be the size
- 	  of an a.out header structure - od -c may give you some hints).
- 	  Another way to tell is to run "file" on /usr/lib/font/ftR.
- 	  Does it say "data"?  Then it probably needs HEADERSIZE 0.
- 	  If it says "ascii" something, you're probably RISC/Ultrix, and you
- 	  need ASCIIWIDTHS set.  If it says "executable" or "object" of some
- 	  kind, you will have to set HEADERSIZE.
- 
- 	  RISC/Ultrix uses an ASCII format width table.  You can
- 	  tell this if the following command:
- 		echo ".fp 1 R" | troff -t > /dev/null
- 	  says something about non-ascii /usr/lib/font/ftR.  If
- 	  it does, define ASCIIWIDTHS.
- 
- 	  If you're still having problems, use the "dumpft" trick
- 	  shown below for Apollos.
- 
- 	  HEADERSIZE can be left as 0 for use with ditroff input.
- 	  (Eg: it only matters for CAT troff)
- 
- NOTE for PSROFF 1.0 users:
- 
-     psroff 1.0 does not have a psroff.lib file, so changes (eg:
-     width option specifications) have to be made directly to
-     the psroff.sh shell script.  Further, in the library, many of
-     the files names are reversed - eg: lj.lib in release 2.0 is lib.lj
-     in 1.0.
  
  Most initial problems are due to width table installation/specification -
  this varies from system to system and is *very* confusing.  I'm sorry about
! that, but there's no other way.  As a simple guide: if the /usr/lib/font/ftR
! file in your original troff installation is not 224 bytes long, you *will*
! have to set HEADERSIZE to something other than 0.
  
  After successful installation/testing, most problems are due to troff
  errors that you don't get to see.
  
- Two notes on HEADERSIZE/ASCIIWID/etc.:
-     1) Some versions of troff will accept the -T option, but ignore
-        it.  Eg: Apollo and SunOS.  If the widths don't seem right, try the -F
-        option.  make check will usually tell you -F in this case.
-     2) If /usr/lib/font/ftR is substantially larger than 224 bytes,
-        ie, over 500 or 600, you probably have special headers.
-        Eg: Apollos.  What you should do is type the following:
- 	    cd utils
- 	    ./dumpft -gv < /usr/lib/font/ftR | grep Guess
-        Which will output a series of lines which contains both
-        a HEADERSIZE guess, plus an error count.  The errorcount
-        will have a minimum value, ideally zero.  Set
-        the HEADERSIZE to the guess with the minimum error
-        count and rebuild and retry everything.  I won't attempt
-        to supply these numbers for each of these systems because
-        the number changes from release to release in some systems.
- 
  Build/Execute gross failures:
  
  Shell scripts die horrible deaths:
--- 71,219 ----
  		M<string>
  	  These are back-end directives and they're supposed to be
  	  there during psroff debug - ignore them.
  
+ 	- HEADERSIZE: Most versions of troff use a initialized C
+ 	  array of characters 224 bytes long that is compiled using
+ 	  the C compiler.  Troff reads this file, and skips the
+ 	  various header structures to get at the data section of the
+ 	  compiled binary.  Psroff doesn't go this route of compiling
+ 	  C programs to determine the format of the width tables it
+ 	  needs to construct - you have to determine the size
+ 	  of the various structures, and set HEADERSIZE to this
+ 	  value.
+ 
+ 	  Many vendors have fiddled with this, and it's sometimes quite
+ 	  difficult to tell what the correct HEADERSIZE value is.
+ 	  Worse, some vendor supplied versions of troff (Risc Ultrix,
+ 	  Apollo DomainOS SR10.3) cannot even read the width tables
+ 	  that are supplied with them.  Thus, analysing your existing
+ 	  width tables isn't always going to result in the correct
+ 	  answer.
+ 
+ 	  See HEADERSIZE Calculations below:
+ 
+ HEADERSIZE Calculations:
+ 
  Most initial problems are due to width table installation/specification -
  this varies from system to system and is *very* confusing.  I'm sorry about
! that, but there's no other way.  Symptoms are "floating exceptions"
! from troff, often wild, but sometimes moderately subtle bad character
! spacing, and sometimes mysterious silent aborts.
  
+ Detailed guide:
+ 
+ 	1) if the /usr/lib/font/ftR file in your original troff installation
+ 	   224 bytes, set HEADERSIZE to 0.
+ 
+ 	2) If the size of /usr/lib/font/ftR is > 224, and your system
+ 	   uses a.out.h headers on executable binaries, HEADERSIZE
+ 	   should be the size of the a.out header.  Usually 32.
+ 
+ 	3) If the size of /usr/lib/font/ftR is large (around 1K), chances
+ 	   are that your system uses COFF headers on font files.
+ 	   HEADERSIZE should be set to the offset of the data section
+ 	   within /usr/lib/font/ftR.  Which is a bit tricky to find out.
+ 	   However, Apollo DomainOS is the only system I know that has
+ 	   COFF headers.  SR10.3 needs HEADERSIZE set to 304.  Prior
+ 	   DomainOS versions (eg: SR10.2) appears to need 336.
+ 	   (The dumpft trick below will report 336 for both).
+ 
+ 	4) If you are DEC Risc/Ultrix (not VAX/Ultrix) define
+ 	   ASCIIWIDTHS.  HEADERSIZE is irrelevant.
+ 
+ 	5) You can usually find out the proper HEADERSIZE value by
+ 	   using the "dumpft trick".
+ 
+ Dumpft Trick:
+ 
+     You can try to test for the correct HEADERSIZE by using the
+     "dumpft trick":
+ 
+     After building psroff (with any HEADERSIZE), type the following:
+ 
+ 	cd utils
+ 	./dumpft -gv < /usr/lib/font/ftR | grep Guess
+ 
+     Which will output a series of lines which contains both
+     a HEADERSIZE guess, plus an error count.  The errorcount
+     will have a minimum value, ideally zero.  Set
+     the HEADERSIZE to the guess with the minimum error
+     count and rebuild and retry everything.
+ 
+     Note however, some versions of troff can't even read their
+     own width tables (Apollo DomainOS SR10.3), which will
+     throw the dumpft trick's guess off.  And this won't work
+     with RISC/Ultrix either.
+ 
+ Last ditch defence:
+ 
+     If you still have problems that seem to have something to do
+     with width tables, here is a procedure that will both demonstrate
+     to you that psroff *does* work, and give some additional analysis
+     for your problems with constructing width tables.
+ 
+     Create a file called "A" containing:
+ 
+     .in |1i
+     .sp |1i
+     This is a test of the computer.
+ 
+     Create a second file called "B" which is a copy of "A",
+     except that ".fp 1 R" has been prepended before the ".in".
+ 
+     Each of the tests below should result in the line of text
+     appearing one inch down, and approximately 1.5" to the right
+     of the left edge of the page.
+ 
+     Test 1: Basic troff and troff2ps sanity test:
+ 
+ 	troff -t A | troff2ps -T<lj|ps> | <your print spooler>
+ 
+ 	Pass: troff and troff2ps basic operation okay.
+ 
+ 	Fail: troff or troff2ps broken.  Nothing to do with
+ 		width tables.
+ 	
+ 	This, by the way, is a functioning CAT troff to postscript
+ 	or laserjet pipeline.  Effectively a thack replacement.
+ 	However, the widths aren't correct (especially lj), and the
+ 	results will be suboptimal.
+ 
+     Test 2: Vendor-supplied width table test:
+ 
+ 	troff -t B | troff2ps -T<lj|ps> | <your print spooler>
+ 
+ 	Pass: Vendor-supplied width tables are okay.  Dumpft valid.
+ 
+ 	Fail: Vendor-supplied width tables are wrong.  DomainOS SR10.3
+ 		and RISC/Ultrix fail this test.
+ 
+ 	Note: the output quality won't be any better than test 1.
+ 
+     Test 3: Psroff width table test:
+ 
+ 	troff -t <widthoption> B | troff2ps -T<lj|ps> | <spooler>
+ 
+ 	Where <widthoption> is either -T<lj|ps>, or
+ 	-F/usr/lib/font/<lj|ps>/ftXX.  (trofftype)
+ 
+ 	Output should be perfect.
+ 
+ 	Pass: Psroff supplied width tables work.  Your problems lie
+ 		elsewhere.  Likely psrofflib or your print spooler.
+ 
+ 	Fail: Psroff supplied width tables don't work.  HEADERSIZE
+ 		or ASCIIWIDTHS need changing.
+ 
+ Width table related details:
+ 
+     Some versions of troff will accept the -T option, but ignore it.
+     Eg: Apollo and SunOS.  If the widths don't seem right, try the -F
+     option.  make check will usually tell you -F in this case.
+ 
  After successful installation/testing, most problems are due to troff
  errors that you don't get to see.
  
  Build/Execute gross failures:
  
  Shell scripts die horrible deaths:
***************
*** 222,228 ****
      This is because you've not installed or properly configured more fonts
      than came with psroff, and psroff can't find a font close enough
      in size, and is letting the printer guess - and has selected a font
!     that it had previously incrementally downloaded.
  
      Get more fonts and make sure that lj.fonts is up-to-date with
      the font set you have.   LJIII and LASERFONTS discusses font
--- 305,312 ----
      This is because you've not installed or properly configured more fonts
      than came with psroff, and psroff can't find a font close enough
      in size, and is letting the printer guess - and has selected a font
!     that it had previously incrementally downloaded but hasn't had a
!     "6" downloaded yet.
  
      Get more fonts and make sure that lj.fonts is up-to-date with
      the font set you have.   LJIII and LASERFONTS discusses font
Index: ./Makefile
*** /tmp/PATCHold/./Makefile	Thu Jan 23 14:52:18 1992
--- ./Makefile	Thu Jan 23 14:52:20 1992
***************
*** 7,13 ****
  #    Function: Upper level makefile; configuration options.
  #
  #
! #ident  "@(#)Makefile: 2.28 Copyright 91/12/07 02:20:15 Chris Lewis"
  
  #	If you're not sure whether you have a System V make, leave
  #	this alone, and run the make anyways.  If it dies horribly
--- 7,13 ----
  #    Function: Upper level makefile; configuration options.
  #
  #
! #ident  "@(#)Makefile: 2.30 Copyright 92/01/23 14:23:19 Chris Lewis"
  
  #	If you're not sure whether you have a System V make, leave
  #	this alone, and run the make anyways.  If it dies horribly
***************
*** 21,26 ****
--- 21,27 ----
  #	Only uncomment the following braindamage if your MAKE doesn't
  #	understand "include".  These are very rare and indicate you don't
  #	have a System V make - see the "Broken Makes" section in MISC.
+ #	This is necessary for Sony's.
  #MAKE	= sed -e '/^include/r ../makeincl' -e '/include/d' Makefile | make -f -
  
  #	Set to where you want the user-interfaces to go.  /usr/lbin
***************
*** 65,77 ****
  
  #	Set this to -lc_s if you have 386/ix style shared libraries and you
  #	wish to use them.  Don't know about any other system's shared libraries.
! LIBFLAGS =
  
  #	Bourne shell.  *All* Bourne shells with the exception of extremely
! #	braindamaged ones (such as Ultrix or vanilla BSD) will work fine.
! #	Ultrix/Dynix may need the ... s5bin/sh one.  ksh and bash
! #	*should* work just fine, but I've never tested 'em.  /usr/bin/sh5
! #	should be used on Ultrix.
  #
  #	This is also here for make, but if you have SHELL defined in your
  #	*own* environment, you can't trust this to work anyways.
--- 66,78 ----
  
  #	Set this to -lc_s if you have 386/ix style shared libraries and you
  #	wish to use them.  Don't know about any other system's shared libraries.
! #	Math library (usually -lm) needed for lj3draw.
! LIBFLAGS = -lm
  
  #	Bourne shell.  *All* Bourne shells with the exception of extremely
! #	braindamaged ones (such as Ultrix, vanilla BSD, Sony, Apollo) will
! #	work fine.  Ultrix: use /usr/bin/sh5.  Korn shell does work here
! #	(Apollos and Ultrix)
  #
  #	This is also here for make, but if you have SHELL defined in your
  #	*own* environment, you can't trust this to work anyways.
***************
*** 178,184 ****
  
  #	Drivers:
  
! BACKENDS = lj.o pk.o pkc.o ps.o dt.o dit.o
  
  DEFINES	= '-DLIBDIR="$(LIBDIR)/lib"' '-DFONTDIR="$(FONTDIR)"'\
  	'-DLJF="$(LJF)"' $(CCFLAGS)
--- 179,185 ----
  
  #	Drivers:
  
! BACKENDS = lj.o pk.o pkc.o ljdraw.o lj3draw.o ps.o dt.o dit.o
  
  DEFINES	= '-DLIBDIR="$(LIBDIR)/lib"' '-DFONTDIR="$(FONTDIR)"'\
  	'-DLJF="$(LJF)"' $(CCFLAGS)
***************
*** 188,193 ****
--- 189,195 ----
  SEDSCRIPT =	"sed -e 's;%%LIBDIR%%;$(LIBDIR);g' \
  		     -e 's;%%LJF%%;$(LJF);g' \
  		     -e 's;%%STARTSHELL%%;'\"$(STARTSHELL)\"';g' \
+ 		     -e 's;%%SHELL%%;'\"$(SHELL)\"';g' \
  		     -e 's;%%COMPILE%%;$(COMPILE);g' \
  		     -e 's;%%FONTDIR%%;$(FONTDIR);g' \
  		     -e 's;%%MANDIR%%;$(MANDIR);g' \
***************
*** 344,349 ****
--- 346,353 ----
  ps.o:	defs.h ps.h
  dt.o:	defs.h dt.h
  lj.o:	defs.h lj.h pkc.h pk.h
+ ljdraw.o:	defs.h lj.h
+ lj3draw.o:	defs.h lj.h
  
  pk.o:	defs.h pk.h pkc.h
  pkc.o:	defs.h pk.h pkc.h
Index: ./t2conf.c
*** /tmp/PATCHold/./t2conf.c	Thu Jan 23 14:52:31 1992
--- ./t2conf.c	Thu Jan 23 14:52:32 1992
***************
*** 12,18 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)t2conf.c: 2.3 Copyright 91/02/20 09:06:48 Chris Lewis";
  #endif
  
  #ifdef	PS
--- 12,18 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)t2conf.c: 2.5 Copyright 92/01/23 14:23:44 Chris Lewis";
  #endif
  
  #ifdef	PS
***************
*** 19,25 ****
  #include "ps.h"
  #endif
  
! #ifdef	LJ
  #include "lj.h"
  #endif
  
--- 19,25 ----
  #include "ps.h"
  #endif
  
! #if defined(LJ) || defined(LJ3)
  #include "lj.h"
  #endif
  
***************
*** 57,63 ****
  
  #ifdef	LJ
      { "lj",	ljProlog,	ljEpilog,	ljChar,	ljPage,	FontSel,
! 		NULL,		NULL,		NULL, NULL,
  		ljStdFont,	ljSymFont },
  #endif
      { NULL }
--- 57,69 ----
  
  #ifdef	LJ
      { "lj",	ljProlog,	ljEpilog,	ljChar,	ljPage,	FontSel,
! 		NULL,		NULL,		NULL, ljDraw,
! 		ljStdFont,	ljSymFont },
! #endif
! 
! #ifdef	LJ3
!     { "lj3",	ljProlog,	ljEpilog,	ljChar,	ljPage,	FontSel,
! 		NULL,		NULL,		NULL, lj3Draw,
  		ljStdFont,	ljSymFont },
  #endif
      { NULL }
Index: ./opt.c
*** /tmp/PATCHold/./opt.c	Thu Jan 23 14:52:39 1992
--- ./opt.c	Thu Jan 23 14:52:41 1992
***************
*** 16,22 ****
  #ifdef	OPT
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)opt.c: 2.7 Copyright 92/01/03 11:33:47 Chris Lewis";
  #endif
  
  struct insbuf {
--- 16,22 ----
  #ifdef	OPT
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)opt.c: 2.8 Copyright 92/01/23 14:23:52 Chris Lewis";
  #endif
  
  struct insbuf {
***************
*** 157,163 ****
  		p = tabS[nc].ch_name;
  	    else
  		p = tabN[nc].ch_name;
! 	    if (strlen(p) >= 2) {
  		if (strcmp(p, "hy") == 0 ||
  		    strcmp(p, "mi") == 0 ||
  		    strcmp(p, "\\-") == 0)
--- 157,163 ----
  		p = tabS[nc].ch_name;
  	    else
  		p = tabN[nc].ch_name;
! 	    if ((int)strlen(p) >= 2) {
  		if (strcmp(p, "hy") == 0 ||
  		    strcmp(p, "mi") == 0 ||
  		    strcmp(p, "\\-") == 0)
Index: ./lj.c
*** /tmp/PATCHold/./lj.c	Thu Jan 23 14:52:50 1992
--- ./lj.c	Thu Jan 23 14:52:52 1992
***************
*** 32,38 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)lj.c: 2.7 Copyright 91/03/10 03:12:47 Chris Lewis";
  #endif
  
  struct troff2befont ljStdFont[108] = {
--- 32,38 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)lj.c: 2.8 Copyright 92/01/23 14:24:06 Chris Lewis";
  #endif
  
  struct troff2befont ljStdFont[108] = {
***************
*** 319,325 ****
  putoct(s)
  char *s; {
      int d;
!     if (strlen(s) < 3) {
  	fprintf(stderr, "%s: octal sequence in fonts.l[kj] bad\n", progname);
  	exit(1);
      }
--- 319,325 ----
  putoct(s)
  char *s; {
      int d;
!     if ((int)strlen(s) < 3) {
  	fprintf(stderr, "%s: octal sequence in fonts.l[kj] bad\n", progname);
  	exit(1);
      }
***************
*** 709,725 ****
      DBP((D_BEND,"AFTER (sequence,x,y,font,points) = (%s,%d,%d,%d,%d)\n",
  	sequence, nx, ny, font, points));
  
- /*	Egads, I discovered that 42% of the time in troff2ps was spent
- 	doing these damn conversions! */
- 
- #define	XYS	"\033&a%dh%dV%s"
- #define	XS	"\033&a%dH%s"
- 
      if (lastYPos != ny) {
! 	printf(XYS, nx, ny, sequence);
  	lastYPos = ny;
      } else
! 	printf(XS, nx, sequence);
  }
  
  ljProlog() {
--- 709,721 ----
      DBP((D_BEND,"AFTER (sequence,x,y,font,points) = (%s,%d,%d,%d,%d)\n",
  	sequence, nx, ny, font, points));
  
      if (lastYPos != ny) {
! 	printf(XY, nx, ny);
  	lastYPos = ny;
      } else
! 	printf(X, nx);
!     
!     fputs(sequence, stdout);
  }
  
  ljProlog() {
***************
*** 902,905 ****
  	c = getc(library);
      }
  }
! #endif
--- 898,902 ----
  	c = getc(library);
      }
  }
! 
! #endif /* LJ */
Index: ./makeincl.S
*** /tmp/PATCHold/./makeincl.S	Thu Jan 23 14:53:07 1992
--- ./makeincl.S	Thu Jan 23 14:53:08 1992
***************
*** 4,10 ****
  #    See the LICENSE file for a full description of the restrictions
  #    under which this software is provided.
  #
! #	Makefile overrides 2.6 91/11/22
  CC	= %%CC%%
  CFLAGS	= %%CCFLAGS%% -I../
  FONTDIR = %%FONTDIR%%
--- 4,10 ----
  #    See the LICENSE file for a full description of the restrictions
  #    under which this software is provided.
  #
! #	Makefile overrides 2.7 92/01/12
  CC	= %%CC%%
  CFLAGS	= %%CCFLAGS%% -I../
  FONTDIR = %%FONTDIR%%
***************
*** 21,26 ****
--- 21,27 ----
  T2DIR = %%T2DIR%%
  MAKEDEV = %%MAKEDEV%%
  PERL = %%PERL%%
+ SHELL = %%SHELL%%
  
  #	This override is because apparently a .s suffix on a file will
  #	cause make to not select a ".S:" rule when the target is .s
Index: ./ljdraw.c
*** /tmp/PATCHold/./ljdraw.c	Thu Jan 23 14:53:14 1992
--- ./ljdraw.c	Thu Jan 23 14:53:16 1992
***************
*** 0 ****
--- 1,249 ----
+ /*
+ 	Copyright 1992 Chris Lewis
+ 		All Rights Reserved
+ 
+     See the LICENSE file for a full description of restrictions under which
+     this software is provided.
+ 
+     Function:		LaserJet driver, drawing code.
+ 
+ 			Needs LJII or later (rules)
+ 
+ */
+ 
+ #include "defs.h"
+ 
+ #if	defined(LJ) && defined(INSPECIAL)
+ #include "lj.h"
+ 
+ #ifndef	lint
+ static char SCCSid[] =
+     "@(#)ljdraw.c: 1.1 Copyright 92/01/23 14:26:18 Chris Lewis";
+ #endif
+ 
+ static int ljLine();
+ 
+ /*	Do ditroff drawing command in s from origX,origY.
+ 	If opcode 0 just moveto
+ 
+ 	This is hardly complete.  Consider it a skeleton
+ 	for further work.  Before extending it beyond
+ 	horizontal and vertical lines, I'm going to switch
+ 	the whole driver over to 300ths from 720ths.
+ 	Which should eliminate a little jitter, and removes
+ 	a lot of excess work in line drawing.
+  */
+ ljDraw(origX, origY, opcode, ctindex, numbers, saves)
+ int origX, origY;
+ int opcode;
+ char *saves;
+ int ctindex;
+ short *numbers; {
+ 
+     int i, fill = 0;
+     static float curfill = 0;
+     static int curthick = 1;
+     static int warned = 0;
+ 
+     /* map absolute beginning position. */
+     origX = TROFF2LJX(origX);
+     origY = TROFF2LJY(origY);
+ 
+     if (!opcode) {
+ 	printf(XY, origX, origY);
+ 	lastYPos = origY;
+ 	return;
+     }
+ 
+     if (opcode != 'l')
+ 	if (!warned) {
+ 	    fprintf(stderr, "%s: only lines are currently supported\n", progname);
+ 	    warned = 1;
+ 	    return;
+ 	}
+ 
+     switch (opcode) {
+ 	case 'f':
+ 	    if (ctindex == 2)
+ 		ctindex = 1;
+ 	    if (!require(1, ctindex, "set fill", saves))
+ 		curfill = (double) numbers[0] / 1000;
+ 	    return;
+ 	case 't':
+ 	    if (ctindex == 2)
+ 		ctindex = 1;
+ 	    if (!require(1, ctindex, "set thick", saves))
+ 		curthick = numbers[0];
+ 	    return;
+     }
+ 
+ 
+     DBP((D_CAT, "ljDraw: (%d,%d): %s\n", origX, origY, saves));
+ 
+     switch (opcode) {
+ 	case 'C':
+ 	    if (ctindex == 2)
+ 		ctindex = 1;
+ 	case 'E':
+ 	case 'P':
+ 	    fill = 1;
+ 	    if (opcode != 'P')
+ 		break;
+ 	case 'l':
+ 	case 'a':
+ 	case 'p':
+ 	case '~':
+ 	    for (i = 0; i < ctindex; i++)
+ 		numbers[i] = numbers[i] * LJRESOLUTION / TROFFRESOLUTION;
+     }
+     switch(opcode) {
+ 	case 'l':
+ 	    if (require(2, ctindex, "line", saves))
+ 		return;
+ 	    DBP((D_CAT, "drawline: %d, %d\n", numbers[0], numbers[1]));
+ 	    ljLine(origX, origY, origX + numbers[0], origY + numbers[1]);
+ 	    break;
+ #if	0
+ 	case 'a':
+ 	    if (require(4, ctindex, "arc", saves))
+ 		return;
+ 	    for (i = 0; i < 4; i++) {
+ 		emitnums(numbers[i]);
+ 	    }
+ 	    putnl("Arc");
+ 	    break;
+ 	case 'C':
+ 	case 'c':
+ 	    if (require(1, ctindex, "circle", saves))
+ 		return;
+ 	    numbers[1] = numbers[0];
+ 	    ctindex++;
+ 	case 'E':
+ 	case 'e':
+ 	    if (require(2, ctindex, "ellipse", saves))
+ 		return;
+ 	    DBP((D_CAT, "drawellipse: %d, %d\n", numbers[0], numbers[1]));
+ 	    emitnums((int) numbers[0]);
+ 	    emitnums((int) numbers[1]);
+ 	    putnl("Ellipse");
+ 	    break;
+ 	case 'P':
+ 	case 'p':
+ 	    if (ctindex&1) {
+ 		fprintf(stderr, "%s: even number of points for polygon: %s\n",
+ 		    progname, saves);
+ 		break;
+ 	    }
+ 	    for (i = 0; i < ctindex; i += 2) {
+ 		emitnums((int) numbers[i]);
+ 		emitnums((int) numbers[i+1]);
+ 		putnl("rlineto");
+ 	    }
+ 	    putnl(" closepath");
+ 	    break;
+ 	case '~':
+ 	    if (ctindex < 4) {
+ 		fprintf(stderr, "%s: too few points to spline: %s\n",
+ 		    progname, saves);
+ 		break;
+ 	    }
+ 	    emitnums(numbers[0]/2);
+ 	    emitnums(numbers[1]/2);
+ 	    putnl("rlineto");
+ 	    /* NUM/DEN should be between 0 and 1; the closer it is to 1
+ 		the tighter the curve will be to the guiding lines; 2/3
+ 		is the standard value */
+ #define	NUM	2
+ #define	DEN	3
+ 	    for (i = 0; i < ctindex - 2; i += 2) {
+ 		emitnums((numbers[i]*NUM)/(2*DEN));
+ 		emitnums((numbers[i + 1]*NUM)/(2*DEN));
+ 		emitnums(numbers[i]/2 + (numbers[i + 2]*(DEN - NUM))/(2*DEN));
+ 		emitnums(numbers[i + 1]/2 + (numbers[i + 3]*(DEN - NUM))/(2*DEN));
+ 		emitnums((numbers[i] - numbers[i]/2) + numbers[i + 2]/2);
+ 		emitnums((numbers[i + 1] - numbers[i + 1]/2) + numbers[i + 3]/2);
+ 		putnl("rcurveto");
+ 	    }
+ 	    emitnums(numbers[ctindex - 2] - numbers[ctindex - 2]/2);
+ 	    emitnums(numbers[ctindex - 1] - numbers[ctindex - 1]/2);
+ 	    putnl("rlineto");
+ 	    break;
+ #endif
+ 	default:
+ 	    fprintf(stderr, "%s: invalid draw code %c (%s)\n", progname, opcode,
+ 		saves);
+ 	    break;
+     }
+ }
+ 
+ static
+ linwid() {
+     register int a;
+     a = lastPoints / 4;
+     if (!a)
+ 	a = 1;
+     else if (a > 10)
+ 	a = 10;
+     return(a);
+ }
+     
+ 
+ static ljPos(x, y)
+ register int x, y; {
+     printf(XY, x, y);
+     lastYPos = y;
+ }
+ 
+ static
+ ljHLine(x0, y0, x1, y1)
+ int x0, y0, x1, y1; {
+     static int warning = 0;
+     if (!warning) {
+ 	fprintf(stderr, "%s: contains non-vertical or horizontal lines.  Ignored\n",
+ 	    progname);
+ 	warning = 1;
+     }
+ }
+ 
+ static
+ ljVerLine(x0, y0, y1)
+ register int x0, y0, y1; {
+     register int t;
+     if (y0 > y1) {
+ 	t = y0;
+ 	y0 = y1;
+ 	y1 = t;
+     }
+     t = linwid();
+     ljPos(x0, y0-t+1);
+     printf("\033*c%da%db0P", t, y1-y0+t);
+ }
+ 
+ static
+ ljHorLine(x0, y0, x1)
+ register int x0, y0, x1; {
+     register int t = linwid();
+     if (x0 > x1) {
+ 	t = x0;
+ 	x0 = x1;
+ 	x1 = t;
+     }
+     t = linwid();
+     ljPos(x0, y0-t+1);
+     printf("\033*c%da%db0P", x1-x0+t, t);
+ }
+ 
+ static
+ ljLine(x0, y0, x1, y1)
+ register int x0, y0, x1, y1; {
+     if (y0 == y1)
+ 	ljHorLine(x0, y0, x1);
+     else if (x0 == x1)
+ 	ljVerLine(x0, y0, y1);
+     else
+ 	ljHLine(x0, y0, x1, y1);
+ 
+ }
+ 
+ 
+ #endif
Index: ./debug.c
*** /tmp/PATCHold/./debug.c	Thu Jan 23 14:53:24 1992
--- ./debug.c	Thu Jan 23 14:53:25 1992
***************
*** 11,17 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)debug.c: 2.6 Copyright 91/02/20 09:00:22 Chris Lewis";
  #endif
  
  #ifdef	DEBUG
--- 11,17 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)debug.c: 2.7 Copyright 92/01/23 14:24:37 Chris Lewis";
  #endif
  
  #ifdef	DEBUG
***************
*** 30,35 ****
--- 30,36 ----
      {'b', D_BEND},
      {'p', D_PK},
      {'v', D_VERB},
+     {'P', D_PIC},
      {'A', ~0},
      {0, 0}
  };
Index: ./lj3draw.c
*** /tmp/PATCHold/./lj3draw.c	Thu Jan 23 14:53:30 1992
--- ./lj3draw.c	Thu Jan 23 14:53:33 1992
***************
*** 0 ****
--- 1,282 ----
+ /*
+ 	Copyright 1992 David E. Wexelblat
+ 
+ 	Inspiration for the struction of these functions taken from ps.c
+ 
+ 	Copyright tranferred to Chris Lewis on the condition that the
+ 	original author's name remain with this code upon any 
+ 	subsequent distribution.
+ 
+ 	Copyright 1992 Chris Lewis
+ 		All Rights Reserved
+ 
+     See the LICENSE file for a full description of restrictions under which
+     this software is provided.
+ 
+     Function:		Provides translation of Ditroff \D commands to
+ 			HP-GL/2 for HP Laserjet III series (PCL5) printers.
+ */
+ 
+ #include "defs.h"
+ 
+ #ifdef LJ3
+ #include "lj.h"
+ #include <math.h>
+ 
+ #ifndef	lint
+ static char SCCSid[] =
+     "@(#)lj3draw.c: 1.1 Copyright 92/01/23 14:26:29 Chris Lewis";
+ #endif
+ 
+ #define to_deg(a)	((180.0/M_PI) * (a))
+ #define XSCALE 		(int)(8.5 * LJRESOLUTION)
+ #define YSCALE		(int)(11 * LJRESOLUTION)
+ #define SPLINE_STEPS 	20
+ 
+ #define ENTER_HPGL2	fputs("\033%1B", stdout)
+ #define EXIT_HPGL2	fputs("\033%0A", stdout)
+ 
+ #ifdef LJ3_7BIT
+ # define BASE		32
+ # define END		95
+ #else
+ # define BASE		64
+ # define END		191
+ #endif
+ 
+ typedef struct {
+     int x, y;
+ } Pt;
+ 
+ encode_coord(x)
+ int x;
+ {
+     int x1;
+ 
+     x1 = (x >= 0) ? x << 1 : ((-x) << 1) + 1;
+     while (x1 >= BASE) {
+ 	putchar(63 + (x1 % BASE));
+ 	x1 /= BASE;
+     }
+     putchar(END + x1);
+ }
+ /*	Do ditroff drawing command in s from origX,origY.
+ 	If opcode 0 just moveto
+  */
+ lj3Draw(origX, origY, opcode, ctindex, numbers, s)
+ int origX, origY;		/* Origin for draw command */
+ int opcode;			/* Draw function */
+ int ctindex;			/* Number of parameters */
+ short *numbers; 		/* Parameters */
+ char *s;			/* Draw command */
+ {
+ 
+     register int i, j;
+     double a1, a2;
+     int sweep;
+     int n, x1, y1, x0, y0;
+     double w, t1, t2, t3;
+     char *command;
+     Pt *p;
+ 
+ 
+     /* map absolute beginning position */
+     origX = TROFF2LJX(origX);
+     origY = TROFF2LJY(origY);
+ 
+     switch (opcode) {
+ 	case 'f':
+ 	    if (ctindex == 2)
+ 		ctindex = 1;
+ 	    if (!require(1, ctindex, "set fill", s)) {
+ 	    	DBP((D_PIC, "lj3Draw: fill: %d\n", numbers[0]));
+ 
+ 		if ((numbers[0] < 0) || (numbers[0] > 1000))
+ 		    fprintf(stderr, "%s: fill %d out of range [0,1000]\n",
+ 			numbers[0]);
+ 		else {
+ 		    ENTER_HPGL2;
+ 	    	    printf("FT10,%d;",(100-(numbers[0]/10)));
+ 		    EXIT_HPGL2;
+ 		}
+ 	    }
+ 	    return;
+ 	case 't':
+ 	    if (ctindex == 2)
+ 		ctindex = 1;
+ 	    if (!require(1, ctindex, "set thick", s)) {
+ 	    	DBP((D_PIC, "lj3Draw: thich: %d\n", numbers[0]));
+ 		/* width 1 = 1mm, troff resolution = 432 dpi */
+ 		ENTER_HPGL2;
+ 	    	printf("\033%%1BLW%.2f;\033%%0A\n", numbers[0]/17.0);
+ 		EXIT_HPGL2;
+ 	    }
+ 
+ 	    return;
+     }
+     printf(XY,origX,origY);
+     if (!opcode)
+ 	return;
+ 
+     DBP((D_PIC, "lj3Draw: (%d,%d): %s\n", origX, origY, s));
+ 
+     switch (opcode) {
+ 	case 'c':
+ 	    if (ctindex == 2)
+ 		ctindex = 1;
+ 	    /* FALLTHRU */
+ 	case 'e':
+ 	    command = "CI";
+ 	    break;
+ 	case 'C':
+ 	    /* FALLTHRU */
+ 	    if (ctindex == 2)
+ 		ctindex = 1;
+ 	case 'E':
+ 	    command = "WG";
+ 	    break;
+ 	case 'p':
+ 	    command = "EP";
+ 	    break;
+ 	case 'P':
+ 	    command = "FP";
+ 	    break;
+     }
+ 
+     for (i = 0; i < ctindex; i++)
+ 	numbers[i] = numbers[i] * LJRESOLUTION / TROFFRESOLUTION;
+ 
+     switch (opcode) {
+ 	case 'l':
+ 	    if (require(2, ctindex, "line", s))
+ 		break;
+ 	    DBP((D_PIC, "lj3Draw: line: %d, %d\n", numbers[0], numbers[1]));
+ 	    ENTER_HPGL2;
+ 	    printf("PD;PR%d,%d;", numbers[0], numbers[1]);
+ 	    EXIT_HPGL2;
+ 	    break;
+ 	case 'a':
+ 	    if (require(4, ctindex, "arc", s))
+ 		break;
+ 	    DBP((D_PIC, "lj3Draw: arc: %d, %d, %d, %d\n",
+ 		numbers[0], numbers[1], numbers[2], numbers[3]));
+ 	    a1 = atan2((double)(-numbers[0]), (double)(-numbers[1]));
+ 	    a2 = atan2((double)(numbers[2]), (double)(numbers[3]));
+ 	    sweep = to_deg(a2-a1);
+ 	    if (sweep < 0)
+ 		sweep += 360;
+ 	    sweep = -sweep;	/* HP-GL/2 wants it in the other direction */
+ 	    DBP((D_PIC, "lj3Draw: arc a1=%f a2=%f sweep=%d\n", a1, a2, sweep));
+ 	    ENTER_HPGL2;
+ 	    printf("PD;AR%d,%d,%d;", numbers[0], numbers[1], sweep);
+ 	    EXIT_HPGL2;
+ 	    break;
+ 	case 'C':
+ 	case 'c':
+ 	    if (require(1, ctindex, (opcode=='C')?"filled circle":"circle", s))
+ 		break;
+ 	    DBP((D_PIC, "lj3Draw: %scircle: %d\n", 
+ 		(opcode == 'C' ? "filled " : ""), numbers[0]));
+ 	    /* Use 'CI r;' for circle, 'WG r,0,360;' for filled circle */
+ 	    ENTER_HPGL2;
+ 	    printf("PU;PR%d,0;%s%d%s;", numbers[0]/2, command, numbers[0]/2,
+ 		(opcode == 'C' ? ",0,360" : ""));
+ 	    EXIT_HPGL2;
+ 	    break;
+ 	case 'e':
+ 	case 'E':
+ 	    if (require(2,ctindex,(opcode=='E')?"filled ellipse":"ellipse",s))
+ 		break;
+ 	    DBP((D_PIC, "lj3Draw: %sellipse: %d, %d\n", 
+ 		(opcode == 'E' ? "filled " : ""), numbers[0], numbers[1]));
+ 	    /* Use 'CI r;' for ellipse, 'WG r,0,360;' for filled ellipse */
+ 	    ENTER_HPGL2;
+ 	    printf("PU;PR%d,0;SC0,%d,0,%d;", numbers[0]/2, 
+ 		(int)(XSCALE * ((float)numbers[1]/numbers[0])), YSCALE);
+ 	    printf("%s%d%s;SC0,%d,0,%d", command, numbers[1]/2,
+ 		(opcode == 'E' ? ",0,360" : ""), XSCALE, YSCALE);
+ 	    EXIT_HPGL2;
+ 	    break;
+ 	case 'p':
+ 	case 'P':
+ 	    if (ctindex&1) {
+ 		fprintf(stderr, 
+ 		    "%s: even number of points for %spolygon: %s\n",
+ 		    progname, (opcode == 'P' ? "filled " : ""), s);
+ 		break;
+ 	    }
+ 	    DBP((D_PIC, "lj3Draw: %spolygon:",
+ 		(opcode == 'P' ? "filled " : "")));
+ #	    ifdef DEBUG
+ 	    for (i=0; i < ctindex; i++)
+ 		DBP((D_PIC, " %d", numbers[i]));
+ 	    DBP((D_PIC, "\n"));
+ #	    endif /* DEBUG */
+ 	    ENTER_HPGL2;
+ 	    printf("PM0;PD;PR%d,%d",numbers[0],numbers[1]);
+ 	    for (i = 2; i < ctindex; i+=2)
+ 		printf(",%d,%d",numbers[i],numbers[i+1]);
+ 	    printf(";PM2;%s;", command);
+ 	    EXIT_HPGL2;
+ 	    break;
+ 	case '~':
+ 	    if (ctindex < 4) {
+ 		fprintf(stderr, "%s: too few points for spline: %s\n",
+ 		    progname, s);
+ 		break;
+ 	    }
+ 	    DBP((D_PIC, "lj3Draw: spline:"));
+ #	    ifdef DEBUG
+ 	    for (i=0; i < ctindex; i++)
+ 		DBP((D_PIC, " %d", numbers[i]));
+ 	    DBP((D_PIC, "\n"));
+ #	    endif /* DEBUG */
+ 	    n = ctindex/2 + 3;
+ 	    p = (Pt *)malloc(sizeof(Pt) * n);
+ 	    p[1].x = origX;
+ 	    p[1].y = origY;
+ 	    for (i = 2; i < n-1; i++) {
+ 		p[i].x = numbers[(i-2)*2]+p[i-1].x;
+ 		p[i].y = numbers[(i-2)*2+1]+p[i-1].y;
+ 	    }
+ 	    p[0] = p[1];
+ 	    p[n-1] = p[n-2];
+ 	    for (i = 0; i < n; i++)
+ 		DBP((D_PIC, "Pt %d: <%d,%d>\n", i, p[i].x, p[i].y));
+ 
+ 	    ENTER_HPGL2;
+ #ifdef LJ3_7BIT
+ 	    fputs("PD;PE7", stdout);
+ #else
+ 	    fputs("PD;PE", stdout);
+ #endif
+ 	    x0 = origX;
+ 	    y0 = origY;
+ 	    for (i = 0; i < n-2; i++) {
+ 		for (j = 0; j < SPLINE_STEPS; j++) {
+ 		    w = (double)j / SPLINE_STEPS;
+ 		    t1 = w * w / 2 ;
+ 		    w = w - 0.5;
+ 		    t2 = 0.75 - w * w;
+ 		    w = w - 0.5;
+ 		    t3 = w * w / 2;
+ 		    x1 = t1*p[i+2].x + t2*p[i+1].x + t3*p[i].x + 0.5;
+ 		    y1 = t1*p[i+2].y + t2*p[i+1].y + t3*p[i].y + 0.5;
+ 		    encode_coord(x1-x0);
+ 		    encode_coord(y1-y0);
+ 		    x0 = x1;
+ 		    y0 = y1;
+ 		}
+ 	    }
+ 	    putchar(';');
+ 	    EXIT_HPGL2;
+ 	    free(p);
+             break;
+ 	default:
+ 	    fprintf(stderr, "%s: invalid draw code %c (%s)\n",
+ 		progname, opcode, s);
+ 	    break;
+     }
+ }
+ 
+ #endif /* LJ3 */
