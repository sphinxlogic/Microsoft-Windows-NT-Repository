Newsgroups: comp.sources.unix
From: clewis@ferret.ocunix.on.ca (Chris Lewis)
Subject: v26i207: psroff 3.0, Patch15
Sender: unix-sources-moderator@efficacy.home.vix.com
Approved: WhoAmI@efficacy.home.vix.com

Submitted-By: clewis@ferret.ocunix.on.ca (Chris Lewis)
Posting-Number: Volume 26, Issue 207
Archive-Name: psroff3.0/patch15

Archive-name: psroff3.0/Patch.15
Submitted-by: clewis@ferret.ocunix.on.ca (Chris Lewis)

    This is official patch 15 for Psroff 3.0.
    Please apply it by:
	cd <psroff source directory>
	patch -N -p < <this file>
    
    The base release of psroff3.0 and first four patches were in
    comp.sources.unix volume 24.

This is a monster.  Sorry.  Lots of teensy little changes, plus one
major functionality upgrade and LJ-critical bug fix.  If this is truncated
at your site, please let me know.

This is probably going to be the last feature upgrade before Psroff 4.0.
Subsequent patches to 3.0 are only going to be bug fixes.  The only
thing currently scheduled for Psroff 4.0 is some cleanup and hp2pbm
integration.  If you have any other feature suggestions for Psroff 4.0
please email me.

These patches will also be available on ftp.cs.toronto.edu in
pub/psroff-3.0.  A fully patched set of shars will be available
on ftp.uunet.ca in distrib/chris_lewis/psroff3.0pl15.

Changes:
	1) Now supports landscape/simplex/duplex/page feed/spooler
	   passthru options with LJ and PS.  See psroff(1) for details.
	   Note Makefile config for PAPER and ORIENTATION.
	   Thanks to Dave Wexelblat for pestering me enough to do it.
	2) Bug fix to prevent dumping on some machines when LJ fonts
	   are on-the-fly scaled.
	3) Resolved malloc typing for once and all.  See MALLRET in
	   defs.h.
	4) Many niggly doc fixes.
	5) Fixed cmtt.ROMAN8 so that buildljfonts/calcfonts/pk2sfp-created
	   Courier fonts have digits.
	6) Fixed pk.c rounding bug in point size whilst reading SFP
	   (results in bad widths generated from SFPs - especially
	   via calcfonts without sfp2pk)
	7) \(ss support in LJ personalities (widths probably off)
	8) Numerous build and install nigglies.
	9) -man macros should now support -rL<length> hack.

Patchwrapped: 930113022141

Index: ./man/pk2sfp.1.S
*** /tmp/PATCHold/./man/pk2sfp.1.S	Wed Jan 13 01:55:15 1993
--- ./man/pk2sfp.1.S	Wed Jan 13 01:55:23 1993
***************
*** 1,4 ****
! .\"Copyright 1988 by Chris Lewis 92/05/19
  .TH PK2SFP %%MANEXT%% "Psroff %%T2VERSION%%"
  .SH NAME
  pk2sfp,pk2ditwid,pktype,pk2ps \- PK/SFP format font file handling utilities
--- 1,4 ----
! .\"Copyright 1988 by Chris Lewis 92/12/05
  .TH PK2SFP %%MANEXT%% "Psroff %%T2VERSION%%"
  .SH NAME
  pk2sfp,pk2ditwid,pktype,pk2ps \- PK/SFP format font file handling utilities
***************
*** 233,239 ****
  Right?
  .PP
  Well, not always.
! Not only to the formats change from one font format to another, but
  .B encodings
  do too.
  If you simply converted Knuth's fonts in PK format to SFP and used them
--- 233,239 ----
  Right?
  .PP
  Well, not always.
! Not only do the formats change from one font format to another, but
  .B encodings
  do too.
  If you simply converted Knuth's fonts in PK format to SFP and used them
Index: ./man/psroff.1.S
*** /tmp/PATCHold/./man/psroff.1.S	Wed Jan 13 01:55:56 1993
--- ./man/psroff.1.S	Wed Jan 13 01:56:02 1993
***************
*** 1,4 ****
! .\"Copyright 1988 by Chris Lewis 2.8 91/10/01
  .TH PSROFF %%MANEXT%% "Psroff %%T2VERSION%%"
  .SH NAME
  psroff,ljroff,xxroff,catconv \- troff to PostScript or other printers
--- 1,4 ----
! .\"Copyright 1988 by Chris Lewis 2.11 93/01/10
  .TH PSROFF %%MANEXT%% "Psroff %%T2VERSION%%"
  .SH NAME
  psroff,ljroff,xxroff,catconv \- troff to PostScript or other printers
***************
*** 8,18 ****
--- 8,21 ----
  .BI "[\-d" ptr "]"
  .BI "[\-rL" length "]"
  .BI "[\-P" prologs "]"
+ .BI "[\-l" lpargs "]"
  .BI "[\-D" deb "]"
  [\-X] [\-M] [\-F]
  .BI "[\-R" nn "]"
  .BI "[\-O" off "]"
  .BI "[\-Y" off "]"
+ .BI "[\-pO" orientation "]"
+ .BI "[\-pS" paper "]"
  .BI [ troffopts ]
  files ...
  .sp
***************
*** 29,35 ****
  can be any of the normal
  .I troff
  arguments, in particular \-m directives for specifying macro package.
! Note that the semantics of "\-t" are changed - it means send the Postscript
  (or HP Laserjet) output to stdout rather than the printer.
  .PP
  Most of the options you shouldn't need to use, except for
--- 32,38 ----
  can be any of the normal
  .I troff
  arguments, in particular \-m directives for specifying macro package.
! Note that the semantics of ``\-t'' are changed - it means send the Postscript
  (or HP Laserjet) output to stdout rather than the printer.
  .PP
  Most of the options you shouldn't need to use, except for
***************
*** 63,69 ****
--- 66,163 ----
  .IR troff ,
  and
  must be invoked *after* \-T if \-T is used.
+ .SH "PAPER AND PRINT SPOOLER CONTROL"
  .PP
+ The ``\-pO'' option allows you to specify the paper orientation.
+ Possible values are
+ .B landscape
+ and
+ .BR portrait .
+ Default is
+ .BR %%ORIENTATION%% .
+ .PP
+ The ``\-pS'' option allows you to specify the size of paper.
+ Legal values are: 
+ .BR letter ,
+ .BR legal ,
+ .BR executive ,
+ .BR a4 ,
+ .BR com ,
+ .BR monarch ,
+ .BR c5 ,
+ and
+ .BR dl .
+ The default is
+ .BR %%PAPER%% .
+ .PP
+ Both paper and orientation can be shortened to minimum distinguishing
+ length.
+ Eg: ``\-pOlet'' specifies letter.
+ .PP
+ .B "IMPORTANT NOTE:"
+ Specifying orientation or paper size does
+ .B NOT
+ tell
+ .I troff
+ itself anything about text geometry.
+ It just tells the backends what commands to issue to get the paper in the
+ correct orientation, and how large the text areas could possibly be.
+ You have to tell
+ .I troff
+ yourself what the page length or width should be.
+ For example, with the
+ .B "\-mm"
+ macros, specifying "\-rL8.5i" to psroff will do the right thing when you're
+ trying to do landscape on ``letter'' size paper.
+ The adapter libraries may also make this work with other macro packages
+ (especially 
+ .BR "-man" "),"
+ but
+ if not, you're on your own.
+ With the
+ .B ME
+ macros try specifying a ``.pl''.
+ .PP
+ The ``\-P'' option is especially useful here using an ``X'' suffix.
+ Each different printer type supports additional features such as
+ duplex, simplex, envelope feed and so on.
+ Consult the
+ .IB type ".lib"
+ file for precise details of what is available.
+ However, 
+ .BR lj ,
+ .BR lj3 ,
+ .BR lj3u
+ and
+ .B ps
+ all support ``duplex_short'' (short side binding), ``duplex_long'' (long
+ side binding) and ``simplex'' plus various bin control codes.
+ You can, for example, print landscape duplex with:
+ .BR "``\-pOland \-PXduplex_short''" .
+ .PP
+ NOTE: the control codes are implemented using HP's PCL and
+ PostScript extensions (ie: ``settumble'' and ``setdumplexmode'').
+ A given PCL or PostScript printer may not implement these features
+ at all, or implement them in a different way.
+ Theoretically, if your printer doesn't support these features, the
+ mode selects will be ignored.
+ .PP
+ Details of how this is done, and enough hints to extend it yourself
+ can be seen in the appropriate
+ .IB type ".lib"
+ file.
+ .PP
+ The ``\-l'' option passes its argument through to the print spooler.
+ Eg: \-l'\-onobanner' passes ``\-onobanner'' through to the print spooler.
+ Consult your print spooler's manual page (probably
+ .B lp
+ or
+ .BR lpr )
+ for further details of what options can be used.
+ With
+ .B lp
+ you may have to consult the printer interface file under /usr/spool/lp/interface.
+ .PP
  .I Psroff
  can be made to generate several different printer output formats.
  If the environment variable PSROFF is set, it is used.
***************
*** 84,89 ****
--- 178,185 ----
  understands ``ps'' (postscript), ``tp'' (ditroff\(->tpscript also postscript),
  ``jt'' (ditroff\(->jetroff (HP PCL)),
  ``lj'' (HP PCL),
+ ``lj3'' (HP PCL5),
+ ``lj3u'' (HP PCL5 with CG Univers base fonts),
  and
  ``dt'' (Ditroff output, no printer).
  However, this list may be different at your site - see
Index: ./man/psxlate.1.S
*** /tmp/PATCHold/./man/psxlate.1.S	Wed Jan 13 01:56:36 1993
--- ./man/psxlate.1.S	Wed Jan 13 01:56:42 1993
***************
*** 1,4 ****
! .\"Copyright 1991 by Chris Lewis 2.9 92/11/11
  .TH PSXLATE %%MANEXT%% "Psroff %%T2VERSION%%"
  .SH NAME
  psxlate \- General Postscript page flipper etcetera
--- 1,4 ----
! .\"Copyright 1991 by Chris Lewis 2.10 92/12/22
  .TH PSXLATE %%MANEXT%% "Psroff %%T2VERSION%%"
  .SH NAME
  psxlate \- General Postscript page flipper etcetera
***************
*** 23,30 ****
  have pages that are prefixed with ``%%Page:'' comments and have a trailer
  prefixed by ``%%Trailer:''.
  Case is significant.
! It also PostScript that contains embedded EPS files provided that they are
! compliant with the DSC and use BeginDocument/EndDocument.
  .PP
  If you have
  .B psnup
--- 23,31 ----
  have pages that are prefixed with ``%%Page:'' comments and have a trailer
  prefixed by ``%%Trailer:''.
  Case is significant.
! .B Psxlate
! will also work with PostScript that contains embedded EPS files,
! provided that they are compliant with the DSC and use BeginDocument/EndDocument.
  .PP
  If you have
  .B psnup
***************
*** 51,57 ****
  .PP
  On the other hand, if the file starts with ``%!'', but not ``%!PS-Adobe-'',
  the file is treated as Postscript, but since it can't be trusted to
! conform to the DSC, none of the convertions are performed -
  .B psxlate
  does nothing to the file.
  .PP
--- 52,58 ----
  .PP
  On the other hand, if the file starts with ``%!'', but not ``%!PS-Adobe-'',
  the file is treated as Postscript, but since it can't be trusted to
! conform to the DSC, none of the conversions are performed -
  .B psxlate
  does nothing to the file.
  .PP
***************
*** 61,67 ****
  does not manipulate the file in-memory,
  hence there are fewer restrictions on the size of the file.
  The only restrictions are that
! .B Psxlate
  has to allocate sufficient memory to hold the longest line of Postscript,
  plus 2 long integers per page (possibly doubled - see notes) and that
  there is enough disk space for an additional copy of the file.
--- 62,68 ----
  does not manipulate the file in-memory,
  hence there are fewer restrictions on the size of the file.
  The only restrictions are that
! .B psxlate
  has to allocate sufficient memory to hold the longest line of Postscript,
  plus 2 long integers per page (possibly doubled - see notes) and that
  there is enough disk space for an additional copy of the file.
***************
*** 265,284 ****
  Otherwise the second pass will print upside-down.
  .PP
  Also note that the Apple LaserWriter IINT printer has a nasty habit of
! curling the paper bad enough during the first pass that the second pass
! may jam or wrinkle.
  .PP
  If groff is used as the troff processor, then the resulting PostScript file
  can be edited and made to print upside-down.
  Then the paper can be moved from the output tray to the paper tray,
  without turning it around 180 degrees.
  .PP
  Place the following lines into an executable file named
  .BR upsxlate :
  .PP
  .nf
  #!/bin/sh
  sed -e "/1 -1 scale/s/scale/scale 612 PL translate 180 rotate/" | psxlate $*
  .fi
  .PP
  Using the exact same syntax as
--- 266,290 ----
  Otherwise the second pass will print upside-down.
  .PP
  Also note that the Apple LaserWriter IINT printer has a nasty habit of
! curling the leading edge of the paper bad enough during the first pass
! that the second pass may jam or wrinkle.
  .PP
  If groff is used as the troff processor, then the resulting PostScript file
  can be edited and made to print upside-down.
  Then the paper can be moved from the output tray to the paper tray,
  without turning it around 180 degrees.
+ By turning the paper around,
+ the trailing edge of the previous printing pass is used,
+ which isn't curled and won't jam in the LWIINT printer.
  .PP
  Place the following lines into an executable file named
  .BR upsxlate :
  .PP
  .nf
+ .in +12p
  #!/bin/sh
  sed -e "/1 -1 scale/s/scale/scale 612 PL translate 180 rotate/" | psxlate $*
+ .in -12p
  .fi
  .PP
  Using the exact same syntax as
***************
*** 302,307 ****
--- 308,339 ----
  When the second batch is printed, all of the even pages will be done in
  ascending order.
  When completed, the output stack will be in the correct order.
+ .PP
+ If you are using FrameMaker, the PostScript output can also be edited so that
+ it too can be turned upside down.
+ But, the PostScript prologue that is used does not contain the correct magic
+ header.
+ To fix this problem, edit the FrameMaker file
+ .I .fminit2.0.ps/postscript_prolog
+ and change to first line to
+ .IR %!PS-Adobe-3.0 .
+ The 3.0 is necessary for NeWSprint 2.0 rev C.
+ Any other value will cause NeWSprint to always print the file in ascending
+ order.
+ .PP
+ To print FrameMaker files upside down,
+ place the following lines into an executable file called
+ .BR fupsxlate :
+ .PP
+ .nf
+ .in +12p
+ #!/bin/csh
+ sed -e "/3.86 setmiterlimit/s/setmiterlimit/setmiterlimit 612 792 translate 180 rotate/" | psxlate $*
+ .in -12p
+ .fi
+ .PP
+ The 612 and 792 must be changed to reflect the size of the paper you are using.
+ The values shown are for letter paper.
  .PP
  On a non-reversing printer, the
  .B \-r
Index: ./lib/Makefile
*** /tmp/PATCHold/./lib/Makefile	Wed Jan 13 01:57:19 1993
--- ./lib/Makefile	Wed Jan 13 01:57:22 1993
***************
*** 1,4 ****
! #2.5 92/03/03
  
  include ../makeincl
  
--- 1,4 ----
! #2.6 92/12/02
  
  include ../makeincl
  
***************
*** 25,30 ****
--- 25,31 ----
  	cd $(LIBDIR)/lib ; rm -f $(LIBS) lj3u.lib
  	cp $(LIBS) $(LIBDIR)/lib
  	cd $(LIBDIR)/lib ; \
+ 	    chmod 444 $(LIBS) ; \
  	    for i in lj3u ; \
  	    do \
  		ln lj3.lib $$i.lib ; \
Index: ./lib/lj.fonts
*** /tmp/PATCHold/./lib/lj.fonts	Wed Jan 13 01:57:51 1993
--- ./lib/lj.fonts	Wed Jan 13 01:57:55 1993
***************
*** 1,4 ****
! #@(#)lj.fonts 2.1 90/07/18
  #	four fields:
  #
  #	troff-name english-name HPLJ-code-to-transmit flags
--- 1,4 ----
! #@(#)lj.fonts 2.2 92/12/22
  #	four fields:
  #
  #	troff-name english-name HPLJ-code-to-transmit flags
***************
*** 68,71 ****
--- 68,72 ----
  LB LinePrinter-Bold \033(8U\033(s0p0s03b00T nnnnnnnnnnnnnnn
  H  Helvetica-Roman  \033(8U\033(s1p0s00b04T nnnnpnnnnnnnnnn
  HI Helvetica-Italic \033(8U\033(s1p1s-3b04T nnnnpnnnnnnnnnn
+ HO Helvetica-Italic \033(8U\033(s1p1s-3b04T nnnnpnnnnnnnnnn
  HB Helvetica-Bold   \033(8U\033(s1p0s03b04T nnnnnnnnnnnnnnn
Index: ./lib/lj.lib
*** /tmp/PATCHold/./lib/lj.lib	Wed Jan 13 01:58:21 1993
--- ./lib/lj.lib	Wed Jan 13 01:58:26 1993
***************
*** 29,36 ****
  %			\xAABB \022 A %hello
  %			Passes the following bytes: 0xAA, 0xBB, 022, and "A"
  %			through to the laserjet.
! %ident  @(#)lj.lib: 2.1 Copyright 90/07/18 16:52:26 Chris Lewis"
! \033E\033&k2G			%reset printer, set CR=CR,LF=CRLF,FF=CRFF */
! \033&l6d66p0o0e66f0L		%letter size, portrait, no perf skip */
  \0339				%reset side margins */
  \033&a0r0C			%move cursor to 0,0 */
--- 29,97 ----
  %			\xAABB \022 A %hello
  %			Passes the following bytes: 0xAA, 0xBB, 022, and "A"
  %			through to the laserjet.
! %ident  @(#)lj.lib: 2.3 Copyright 93/01/07 01:45:29 Chris Lewis"
! 
! \033E				% comment-out if your spooler resets
! 				% the printer between jobs.  This is
! 				% the preferable configuration - allows
! 				% the spooler to supply defaults.  Ie:
! 				% spooler-imposed default duplexing.
! 
! \033&k2G			%set CR=CR,LF=CRLF,FF=CRFF */
! 
! %	Orientation handling.
! #if _eval(landscape)
!     \033&l1O
! #elif _eval(portrait)
!     \033&l0O
! #elif _eval(reverse_portrait)
!     \033&l2O
! #elif _eval(reverse_landscape)
!     \033&l3O
! #elif default
!     %	Default orientation.  Leave both undefined if you want the spooler
!     %	to control things.
!     \033&l0O			% uncomment for portrait default
!     %\033&l1O			% uncomment for landscape default
! #endif
! 
! %	Simplex/Duplex handling.  If your spooler can handle
! %	duplexing options (and you've removed the reset), comment
! %	out all entries in the default section.  Generally speaking,
! %	you don't have to do anything if your printer doesn't support
! %	these options.
! #if _eval(duplex_long)
!     \033&l1S
! #elif _eval(duplex_short)
!     \033&l2S
! #elif _eval(simplex)
!     \033&l0S
! #elif default
!     %\033&l0S			% uncomment for simplex default
!     \033&l1S			% uncomment for duplex_long default
!     %\033&l2S			% uncomment for duplex_short default
! #endif
! 
! %	Paper input control:
! #if (paper_upper)
!     \033&l1H
! #elif (paper_manual)
!     \033&l2H
! #elif (envelope_manual)
!     \033&l3H
! #elif (paper_lower)
!     \033&l4H
! #elif (paper_deck)
!     \033&l5H
! #elif (envelope_feeder)
!     \033&l6H
! #elif (print_current)
!     \033&l0H
! #elif default
!     \033&l0H
! #endif
! 
! \033&l0l0E			% no perf skip, no top margin
! \033*r0F			% rasters follow page orientation
  \0339				%reset side margins */
  \033&a0r0C			%move cursor to 0,0 */
Index: ./lib/lj3.fonts
*** /tmp/PATCHold/./lib/lj3.fonts	Wed Jan 13 01:58:59 1993
--- ./lib/lj3.fonts	Wed Jan 13 01:59:06 1993
***************
*** 1,4 ****
! #@(#)lj3.fonts 2.14 92/04/12
  #	Laserjet III fonts file.
  #	See lj.fonts for more explanation.
  #	The first ten fonts are the built-in scaleable typefaces.
--- 1,4 ----
! #@(#)lj3.fonts 2.16 93/01/02
  #	Laserjet III fonts file.
  #	See lj.fonts for more explanation.
  #	The first ten fonts are the built-in scaleable typefaces.
***************
*** 53,59 ****
  co N \033(7J\245\033(8U
  sq N \033(7J\273\033(8U
  symbol
! br N | -80 0
  eq S =
  ts S \133
  mi S -
--- 53,60 ----
  co N \033(7J\245\033(8U
  sq N \033(7J\273\033(8U
  symbol
! br N | -110 0
! ul N _ -10 0
  eq S =
  ts S \133
  mi S -
***************
*** 156,158 ****
--- 157,160 ----
  ~a	N	\342
  ~n	N	\267
  ~o	N	\352
+ ss	N	\336
Index: ./lib/lj3.lib
*** /tmp/PATCHold/./lib/lj3.lib	Wed Jan 13 01:59:52 1993
--- ./lib/lj3.lib	Wed Jan 13 01:59:58 1993
***************
*** 29,43 ****
  %			\xAABB \022 A %hello
  %			Passes the following bytes: 0xAA, 0xBB, 022, and "A"
  %			through to the laserjet.
! %ident  @(#)lj3.lib: 2.4 Copyright 92/04/12 22:01:19 Chris Lewis"
! \033E\033&k2G			%reset printer, set CR=CR,LF=CRLF,FF=CRFF 
! \033&l6d66p0o0e66f0L		%letter size, portrait, no perf skip
! \0339				%reset side margins
! \033&a0h0V			%move cursor to 0,0
! \033*c6120x7920y0T\033\045 1B	%set HP-GL/2 picture frame, go to HP-GL/2
! IN;WU0;PW0.2;SP1;		%initialize, pen widths in MM, 0.36MM for pen 1
! LA1,4,2,4;			%set round line caps & joins
  TR0;				%set transparency mode off
! IP0,11176,8636,0;		%set orientation to match PCL
! SC0,2550,0,3300;PU0,0;		%scale HP-GL/2 to 300dpi dots like PCL
  \033\045 1A			%return to PCL mode
--- 29,108 ----
  %			\xAABB \022 A %hello
  %			Passes the following bytes: 0xAA, 0xBB, 022, and "A"
  %			through to the laserjet.
! %ident  @(#)lj3.lib: 2.6 Copyright 93/01/07 01:45:32 Chris Lewis"
! 
! \033E				% comment-out if your spooler resets
! 				% the printer between jobs.  This is
! 				% the preferable configuration - allows
! 				% the spooler to supply defaults.  Ie:
! 				% spooler-imposed default duplexing.
! 
! \033&k2G			%set CR=CR,LF=CRLF,FF=CRFF */
! 
! %	Orientation handling.
! #if _eval(landscape)
!     \033&l1O
! #elif _eval(portrait)
!     \033&l0O
! #elif _eval(reverse_portrait)
!     \033&l2O
! #elif _eval(reverse_landscape)
!     \033&l3O
! #elif default
!     %	Default orientation.  Leave both undefined if you want the spooler
!     %	to control things.
!     \033&l0O			% uncomment for portrait default
!     %\033&l1O			% uncomment for landscape default
! #endif
! 
! %	Simplex/Duplex handling.  If your spooler can handle
! %	duplexing options (and you've removed the reset), comment
! %	out all entries in the default section.  Generally speaking,
! %	you don't have to do anything if your printer doesn't support
! %	these options.
! #if _eval(duplex_long)
!     \033&l1S
! #elif _eval(duplex_short)
!     \033&l2S
! #elif _eval(simplex)
!     \033&l0S
! #elif default
!     %\033&l0S			% uncomment for simplex default
!     \033&l1S			% uncomment for duplex_long default
!     %\033&l2S			% uncomment for duplex_short default
! #endif
! 
! %	Paper input control:
! #if (paper_upper)
!     \033&l1H
! #elif (paper_manual)
!     \033&l2H
! #elif (envelope_manual)
!     \033&l3H
! #elif (paper_lower)
!     \033&l4H
! #elif (paper_deck)
!     \033&l5H
! #elif (envelope_feeder)
!     \033&l6H
! #elif (print_current)
!     \033&l0H
! #elif default
!     \033&l0H
! #endif
! 
! \033&l0l0E			%no perf skip, no top margin
! \033*r0F			%rasters follow page orientation
! \0339				%reset side margins */
! \033&a0r0C			%move cursor to 0,0 */
! %	HP/GL2 control
! \033*c_eval(pagewidth,d)x_eval(pagelength,d)y0T	% HP/GL pictureframe
! \033\045 1B			%go into HP-GL/2
! IN;WU0;PW0.2;SP1;		%initialize, penwidths in MM, .2MM for pen 1
! LA1,4,2,4;			%round line caps and joins
  TR0;				%set transparency mode off
! 				%set orientation to match PCL
! IP0,_eval(pagelength,1016),_eval(pagewidth,1016),0;
! 				%scale HP-GL/2 to 300dpi dots like PCL
! SC0,_eval(pagewidth),0,_eval(pagelength);PU0,0;
  \033\045 1A			%return to PCL mode
Index: ./lib/ps.fonts
*** /tmp/PATCHold/./lib/ps.fonts	Wed Jan 13 02:00:34 1993
--- ./lib/ps.fonts	Wed Jan 13 02:00:38 1993
***************
*** 1,4 ****
! #@(#)ps.fonts 2.6 92/05/21 01:56:49
  #	DO NOT CHANGE THE ORDER OF THE FIRST FOUR LINES - THESE ARE
  #	THE DEFAULT TROFF FONTS IN POSITIONS 1-5.  IN PARTICULAR, IF
  #	SYMBOL ISN'T THE FOURTH ENTRY AND BRACKETFONT ISN'T THE FIFTH,
--- 1,4 ----
! #@(#)ps.fonts 2.7 92/12/02 01:57:04
  #	DO NOT CHANGE THE ORDER OF THE FIRST FOUR LINES - THESE ARE
  #	THE DEFAULT TROFF FONTS IN POSITIONS 1-5.  IN PARTICULAR, IF
  #	SYMBOL ISN'T THE FOURTH ENTRY AND BRACKETFONT ISN'T THE FIFTH,
***************
*** 24,35 ****
--- 24,38 ----
  BR	Bookman-Light
  BX	Bookman-DemiItalic
  C	Courier
+ CW	Courier
  CB	Courier-Bold
  CO	Courier-Oblique
+ CI	Courier-Oblique
  CX	Courier-BoldOblique
  H	Helvetica
  HB	Helvetica-Bold
  HO	Helvetica-Oblique
+ HI	Helvetica-Oblique
  HX	Helvetica-BoldOblique
  Hb	Helvetica-Narrow-Bold
  Hr	Helvetica-Narrow
***************
*** 115,118 ****
  AE	N	\341
  Ye	N	\245
  ..	N	\310
! 
--- 118,121 ----
  AE	N	\341
  Ye	N	\245
  ..	N	\310
! ss	N	\373
Index: ./lib/ps.lib
*** /tmp/PATCHold/./lib/ps.lib	Wed Jan 13 02:01:18 1993
--- ./lib/ps.lib	Wed Jan 13 02:01:25 1993
***************
*** 9,15 ****
  %	Module:		ps.lib
  %	Author: 	Chris Lewis
  %	Specs:		Predefinitions for PostScript
! %ident  @(#)ps.lib: 92/08/09 Copyright 92/08/09 23:48:32 Chris Lewis"
  
  /Y { 3 1 roll dup /CurY exch def moveto show } bind def
  /X { exch CurY moveto show } bind def
--- 9,15 ----
  %	Module:		ps.lib
  %	Author: 	Chris Lewis
  %	Specs:		Predefinitions for PostScript
! %ident  @(#)ps.lib: 2.18 Copyright 92/12/30 02:43:45 Chris Lewis"
  
  /Y { 3 1 roll dup /CurY exch def moveto show } bind def
  /X { exch CurY moveto show } bind def
***************
*** 227,232 ****
--- 227,240 ----
  
  %	Emitted at beginning of page.
  /StartPage {
+ #if _eval(landscape)
+     % landscape pages.
+     _eval(pagelength) 0 translate 90 rotate
+ #elif _eval(portrait)
+     % portrait pages.
+ #elif default
+     % default (portrait)
+ #endif
      Form
  } def
  
***************
*** 561,563 ****
--- 569,619 ----
      currentpoint 18 sub exch pop 8.5 72 mul 2 idiv exch translate
  } def
  /PE { SAVE restore } def
+ #if _eval(simplex)
+     statusdict /setduplexmode known {
+ 	statusdict begin
+ 	    false setduplexmode
+ 	end
+     } if
+ #elif _eval(duplex_long)
+     statusdict /settumble known {
+ 	statusdict begin
+ 	    true setduplexmode
+ 	    false settumble
+ 	end
+     } if
+ #elif _eval(duplex_short)
+     statusdict /settumble known {
+ 	statusdict begin
+ 	    true setduplexmode
+ 	    true settumble
+ 	end
+     } if
+ #elif default
+ %	Uncomment for default set by psroff, instead of via spooler.
+ %    statusdict /setduplexmode known {
+ %	statusdict begin
+ %	    false setduplexmode
+ %	end
+ %    } if
+ #endif
+ 
+ #if _eval(paper_upper)
+     userdict /setpapertray known {
+ 	userdict begin
+ 	    0 setpapertray
+ 	end
+     } if
+ #elif _eval(paper_lower)
+     userdict /setpapertray known {
+ 	userdict begin
+ 	    1 setpapertray
+ 	end
+     } if
+ #elif _eval(envelope)
+     userdict /setpapertray known {
+ 	userdict begin
+ 	    2 setpapertray
+ 	end
+     } if
+ #endif
Index: ./lib/psrofflib.S
*** /tmp/PATCHold/./lib/psrofflib.S	Wed Jan 13 02:02:00 1993
--- ./lib/psrofflib.S	Wed Jan 13 02:02:07 1993
***************
*** 1,4 ****
! #	2.28 92/06/01
  #	This file controls psroff, you can insert additional printer
  #	types here.  These are eval'd *late* in processing, so that
  #	you can insert $copies etc.
--- 1,4 ----
! #	2.29 92/12/02
  #	This file controls psroff, you can insert additional printer
  #	types here.  These are eval'd *late* in processing, so that
  #	you can insert $copies etc.
***************
*** 262,274 ****
  cdps	lparg="> /tmp/dps$$; %%LIBDIR%%/dodps /tmp/dps$$; rm /tmp/dps$$'
  
  #	Using groff (gtroff actually) and driving LJ3:
! #	You have to copy the lj3 widths to gtroff's width directories.
! #	Standard groff install:
! #	copy widths/widthlj3/[A-Z]* /usr/local/lib/groff/font/devlj3
! #	copy widths/widthlj3u/[A-Z]* /usr/local/lib/groff/font/devlj3u
! #	Remove the ligatures from devlj3*/[A-Z]
  #
! troff=gtroff
  trofftype='-T$width'
  glj3	width=lj3 t2arg='-Tlj3 -plj3 -N -Z -O0 -W%%FONTDIR%%/lj3 -G1'
  glj3	lparg='| lp -og -d$ptr -n$copies' ptr=laser
--- 262,273 ----
  cdps	lparg="> /tmp/dps$$; %%LIBDIR%%/dodps /tmp/dps$$; rm /tmp/dps$$'
  
  #	Using groff (gtroff actually) and driving LJ3:
! #	"make installwidths" installs the width tables and driver
! #	entries so that groff -T{lj3,lj3u,lj} will work as well as
! #	psroff -Tg{lj3,lj3u,lj}
  #
! #	Assumes "standard" install location
! troff=/usr/local/bin/gtroff
  trofftype='-T$width'
  glj3	width=lj3 t2arg='-Tlj3 -plj3 -N -Z -O0 -W%%FONTDIR%%/lj3 -G1'
  glj3	lparg='| lp -og -d$ptr -n$copies' ptr=laser
***************
*** 275,280 ****
--- 274,282 ----
  #	Univers base:
  glj3u	width=lj3u t2arg='-Tlj3 -plj3u -N -Z -O0 -W%%FONTDIR%%/lj3u -G1'
  glj3u	lparg='| lp -og -d$ptr -n$copies' ptr=laser
+ #	Groff driving HP Laserjet PCL4
+ glj	width=lj t2arg='-Tlj -N -Z -O0 -W%%FONTDIR%%/lj -G1'
+ glj	lparg='| lp -og -d$ptr -n$copies' ptr=laser
  #
  #	Driving a Epson 24 pin printer with hp2pbm/pbm2e24/CAT troff
  #	The quoting in lparg is very picky.
Index: ./lib/lj3u.fonts
*** /tmp/PATCHold/./lib/lj3u.fonts	Wed Jan 13 02:02:39 1993
--- ./lib/lj3u.fonts	Wed Jan 13 02:02:42 1993
***************
*** 1,4 ****
! #@(#)lj3u.fonts 2.8 92/04/12
  #	Laserjet III fonts file.  Shuffled for Universal as primary typeface.
  #	See lj.fonts for more explanation.
  #	The first ten fonts are the built-in scaleable typefaces.
--- 1,4 ----
! #@(#)lj3u.fonts 2.10 93/01/02
  #	Laserjet III fonts file.  Shuffled for Universal as primary typeface.
  #	See lj.fonts for more explanation.
  #	The first ten fonts are the built-in scaleable typefaces.
***************
*** 53,59 ****
  co N \033(7J\245\033(8U
  sq N \033(7J\273\033(8U
  symbol
! br N | -80 0
  eq S =
  ts S \133
  mi S -
--- 53,60 ----
  co N \033(7J\245\033(8U
  sq N \033(7J\273\033(8U
  symbol
! br N | -110 0
! ul N _ -10 0
  eq S =
  ts S \133
  mi S -
***************
*** 156,158 ****
--- 157,160 ----
  ~a	N	\342
  ~n	N	\267
  ~o	N	\352
+ ss	N	\336
Index: ./widths/widthps/B
2c2
< #2.3 92/08/09
---
> #2.4 92/12/02
185a186
> ss	56	2	0373	germandbls
Index: ./widths/widthps/BI
2c2
< #2.3 92/08/09
---
> #2.4 92/12/02
185a186
> ss	50	2	0373	germandbls
Index: ./widths/widthps/C
2c2
< #2.3 92/08/09
---
> #2.4 92/12/02
180a181
> ss	60	2	0373	germandbls
Index: ./widths/widthps/CB
2c2
< #2.3 92/08/09
---
> #2.4 92/12/02
180a181
> ss	60	2	0373	germandbls
Index: ./widths/widthps/CO
2c2
< #2.3 92/08/09
---
> #2.4 92/12/02
180a181
> ss	60	2	0373	germandbls
Index: ./widths/widthps/CX
2c2
< #2.3 92/08/09
---
> #2.4 92/12/02
180a181
> ss	60	2	0373	germandbls
Index: ./widths/widthps/DESC
1c1
< #	2.5 92/06/06 (From tpscript) extended for use with ditroff
---
> #	2.6 92/12/02 (From tpscript) extended for use with ditroff
32c32
< ul vS vs ~= ~A ~N ~O ~a ~n ~o
---
> ul vS vs ~= ~A ~N ~O ~a ~n ~o ss
Index: ./widths/widthps/H
2c2
< #2.3 92/08/09
---
> #2.4 92/12/02
185a186
> ss	61	2	0373	germandbls
Index: ./widths/widthps/HB
2c2
< #2.4 92/08/09
---
> #2.5 92/12/02
185a186
> ss	61	2	0373	germandbls
Index: ./widths/widthps/HO
2c2
< #2.4 92/08/09
---
> #2.5 92/12/02
185a186
> ss	61	2	0373	germandbls
Index: ./widths/widthps/HX
2c2
< #2.4 92/08/09
---
> #2.5 92/12/02
185a186
> ss	61	2	0373	germandbls
Index: ./widths/widthps/I
2c2
< #2.3 92/08/09
---
> #2.4 92/12/02
185a186
> ss	50	3	0373	germandbls
Index: ./widths/widthps/R
2c2
< #2.3 92/08/09
---
> #2.4 92/12/02
185a186
> ss	50	2	0373	germandbls
Index: ./widths/widthlj3/DESC
*** /tmp/PATCHold/./widths/widthlj3/DESC	Wed Jan 13 02:10:41 1993
--- ./widths/widthlj3/DESC	Wed Jan 13 02:10:44 1993
***************
*** 1,4 ****
! #	2.5 92/02/13
  #	special fonts have to go at the end or else troff
  #	won't know about their numbers unless you do .fp
  #
--- 1,4 ----
! #	2.6 93/01/01
  #	special fonts have to go at the end or else troff
  #	won't know about their numbers unless you do .fp
  #
***************
*** 23,26 ****
  dg di em eq es ff fi fl fm ga gr hy ib if ip is lb lc lf lh
  lk lt mi mo mu no oA oa or pd pl pt r! r? rb rc rf rg rh rk
  rn rt ru sb sc sl sp sq sr ts ua ul ~= ~A ~N ~O ~a ~n ~o vs
! vS
--- 23,26 ----
  dg di em eq es ff fi fl fm ga gr hy ib if ip is lb lc lf lh
  lk lt mi mo mu no oA oa or pd pl pt r! r? rb rc rf rg rh rk
  rn rt ru sb sc sl sp sq sr ts ua ul ~= ~A ~N ~O ~a ~n ~o vs
! vS ss
Index: ./widths/widthlj3/I
*** /tmp/PATCHold/./widths/widthlj3/I	Wed Jan 13 02:11:22 1993
--- ./widths/widthlj3/I	Wed Jan 13 02:11:25 1993
***************
*** 1,5 ****
  # Times-Italic
! #2.6 92/03/03
  name I
  internalname TmsItalic
  ligatures fi fl 0
--- 1,5 ----
  # Times-Italic
! #2.7 93/01/01
  name I
  internalname TmsItalic
  ligatures fi fl 0
***************
*** 193,195 ****
--- 193,196 ----
  ~a	18	2	0342	atilde
  ~n	18	2	0267	ntilde
  ~o	18	2	0352	otilde
+ ss	18	2	0336	germandbls (width a guess)
Index: ./widths/widthlj3/R
*** /tmp/PATCHold/./widths/widthlj3/R	Wed Jan 13 02:11:54 1993
--- ./widths/widthlj3/R	Wed Jan 13 02:11:58 1993
***************
*** 1,5 ****
  # Times-Roman
! #2.6 92/03/03
  name R
  internalname TmsRoman
  ligatures fi fl 0
--- 1,5 ----
  # Times-Roman
! #2.7 93/01/01
  name R
  internalname TmsRoman
  ligatures fi fl 0
***************
*** 193,195 ****
--- 193,196 ----
  ~a	16	2	0342	atilde
  ~n	18	2	0267	ntilde
  ~o	18	2	0352	otilde
+ ss	18	2	0336	germandbls (width a guess)
Index: ./widths/widthlj3/X
*** /tmp/PATCHold/./widths/widthlj3/X	Wed Jan 13 02:12:28 1993
--- ./widths/widthlj3/X	Wed Jan 13 02:12:31 1993
***************
*** 1,5 ****
  # Times-BoldItalic
! #2.7 92/03/03
  name X
  internalname TmsBdIt
  ligatures fi fl 0
--- 1,5 ----
  # Times-BoldItalic
! #2.8 93/01/01
  name X
  internalname TmsBdIt
  ligatures fi fl 0
***************
*** 193,195 ****
--- 193,196 ----
  ~a	18	2	0342	atilde
  ~n	20	2	0267	ntilde
  ~o	18	2	0352	otilde
+ ss	18	2	0336	germandbls (width a guess)
Index: ./widths/widthlj3/B
*** /tmp/PATCHold/./widths/widthlj3/B	Wed Jan 13 02:13:01 1993
--- ./widths/widthlj3/B	Wed Jan 13 02:13:05 1993
***************
*** 1,5 ****
  # Times-Bold
! #2.6 92/03/03
  name B
  internalname TmsBold
  ligatures fi fl 0
--- 1,5 ----
  # Times-Bold
! #2.7 93/01/01
  name B
  internalname TmsBold
  ligatures fi fl 0
***************
*** 193,195 ****
--- 193,196 ----
  ~a	18	2	0342	atilde
  ~n	20	2	0267	ntilde
  ~o	18	2	0352	otilde
+ ss	18	2	0336	germandbls (width a guess)
Index: ./widths/Makefile
*** /tmp/PATCHold/./widths/Makefile	Wed Jan 13 02:13:33 1993
--- ./widths/Makefile	Wed Jan 13 02:13:38 1993
***************
*** 4,10 ****
  #    See the LICENSE file for a full description of the restrictions
  #    under which this software is provided.
  #
! #2.20 91/12/26
  SCRIPTS	= gfnttab genext installdit
  TD	= testdir
  PSW	= \
--- 4,10 ----
  #    See the LICENSE file for a full description of the restrictions
  #    under which this software is provided.
  #
! #2.22 92/12/22
  SCRIPTS	= gfnttab genext installdit
  TD	= testdir
  PSW	= \
***************
*** 18,23 ****
--- 18,24 ----
  	widthps/BI widthps/Hr widthps/PI widthps/BO widthps/H \
  	widthps/Hx widthps/PR \
  	widthlj/DESC
+ ALIASES	= widthps/CW widthps/CI widthps/HI
  LJ3W	= \
  	widthlj3/DESC widthlj3/S2 \
  	    widthlj3/B widthlj3/I widthlj3/R widthlj3/S widthlj3/X \
***************
*** 26,36 ****
  
  include ../makeincl
  
! all:	subst.done $(PSW) $(LJ3W) lj3ext dit2catwid $(SCRIPTS) ljwidths \
  	widths extensions
  
! unsccswidths:	$(PSW) $(LJ3W)
  
  lj3ext:		$(LJ3W)
  	@$(IGNORESH) for i in R I B X ; \
  	do \
--- 27,39 ----
  
  include ../makeincl
  
! all:	subst.done $(PSW) $(ALIASES) $(LJ3W) lj3ext dit2catwid $(SCRIPTS) ljwidths \
  	widths extensions
  
! unsccswidths:	$(PSW) $(ALIASES) $(LJ3W)
  
+ aliases:	$(ALIASES)
+ 
  lj3ext:		$(LJ3W)
  	@$(IGNORESH) for i in R I B X ; \
  	do \
***************
*** 47,52 ****
--- 50,71 ----
  	@eval `echo $@ | sed -e 's/\(.*\)\/\([^\/]*\)$$/d=\1 f=s.\2 n=&/'` ; \
  	    cd $$d ; echo Extracting $$n ; $(GET) -s $(GFLAGS) $$f
  
+ #	Aliasing/compability with Transcript etc.
+ widthps/CW:	widthps/C
+ 	rm -f widthps/CW tmp
+ 	sed -e 's/name C[ 	]*$$/name CW/' widthps/C > tmp
+ 	mv tmp widthps/CW
+ 
+ widthps/CI:	widthps/CO
+ 	rm -f widthps/CI tmp
+ 	sed -e 's/name CO[ 	]*$$/name CI/' widthps/CO > tmp
+ 	mv tmp widthps/CI
+ 
+ widthps/HI:	widthps/HO
+ 	rm -f widthps/HI tmp
+ 	sed -e 's/name HO[ 	]*$$/name HI/' widthps/HO > tmp
+ 	mv tmp widthps/HI
+ 
  ditwidths:
  	cd ../lib ; $(MAKE) psrofflib
  	./installdit
***************
*** 201,206 ****
--- 220,226 ----
  			args= ; \
  		    fi ; \
  		    echo "Creating widthlj/$$font from $$file" ; \
+ 		    echo ../utils/pk2ditwid $$args $$file ; \
  		    ../utils/pk2ditwid $$args $$file >> pk2dit.log \
  			2>> pk2dit.err ; \
  		    if [ $$? != 0 ] ; \
***************
*** 294,299 ****
--- 314,320 ----
  	rm -f gfnttab.log pk2dit.log pk2sep.log pk2dit.err pk2sep.err
  	rm -f */[A-Z]*.out */*.ext lj3ext
  	rm -f widthlj3/U[RIBX] widthlj3u/T[RIBX]
+ 	rm -f $(ALIASES)
  
  dit2catwid.o:	../defs.h
  
Index: ./widths/dit2catwid.c
*** /tmp/PATCHold/./widths/dit2catwid.c	Wed Jan 13 02:14:05 1993
--- ./widths/dit2catwid.c	Wed Jan 13 02:14:13 1993
***************
*** 10,16 ****
  
  #ifndef	lint
  static char SCCSID[] =
!     "@(#)dit2catwid.c 2.10 Copyright 91/10/17 19:56:13 Chris Lewis";
  #endif
  
  #include <stdio.h>
--- 10,16 ----
  
  #ifndef	lint
  static char SCCSID[] =
!     "@(#)dit2catwid.c 2.11 Copyright 92/12/04 23:18:26 Chris Lewis";
  #endif
  
  #include <stdio.h>
***************
*** 334,340 ****
  mustmalloc(n)
  register int n; {
      register char *p;
-     extern char *malloc();
      p = malloc(n);
      if (!p) {
  	fprintf(stderr, "%s: cannot alloc %d bytes\n", progname, n);
--- 334,339 ----
Index: ./widths/widthlj3u/B
*** /tmp/PATCHold/./widths/widthlj3u/B	Wed Jan 13 02:14:50 1993
--- ./widths/widthlj3u/B	Wed Jan 13 02:14:51 1993
***************
*** 1,5 ****
  # Univers-Bold
! #2.6 92/03/03
  name B
  internalname UniBold
  ligatures fi fl 0
--- 1,5 ----
  # Univers-Bold
! #2.7 93/01/02
  name B
  internalname UniBold
  ligatures fi fl 0
***************
*** 193,195 ****
--- 193,196 ----
  ~a	19	2	0342	atilde
  ~n	21	2	0267	ntilde
  ~o	21	2	0352	otilde
+ ss	18	2	0336	germandbls (width a guess)
Index: ./widths/widthlj3u/I
*** /tmp/PATCHold/./widths/widthlj3u/I	Wed Jan 13 02:15:10 1993
--- ./widths/widthlj3u/I	Wed Jan 13 02:15:13 1993
***************
*** 1,5 ****
  # Univers-Italic
! #2.6 92/03/03
  name I
  internalname UniItalic
  ligatures fi fl 0
--- 1,5 ----
  # Univers-Italic
! #2.7 93/01/02
  name I
  internalname UniItalic
  ligatures fi fl 0
***************
*** 193,195 ****
--- 193,196 ----
  ~a	19	2	0342	atilde
  ~n	21	2	0267	ntilde
  ~o	21	2	0352	otilde
+ ss	18	2	0336	germandbls (width a guess)
Index: ./widths/widthlj3u/R
*** /tmp/PATCHold/./widths/widthlj3u/R	Wed Jan 13 02:15:30 1993
--- ./widths/widthlj3u/R	Wed Jan 13 02:15:32 1993
***************
*** 1,5 ****
  # Univers-Roman
! #2.6 92/03/03
  name R
  internalname UniRoman
  ligatures fi fl 0
--- 1,5 ----
  # Univers-Roman
! #2.7 93/01/02
  name R
  internalname UniRoman
  ligatures fi fl 0
***************
*** 193,195 ****
--- 193,196 ----
  ~a	19	2	0342	atilde
  ~n	21	2	0267	ntilde
  ~o	21	2	0352	otilde
+ ss	18	2	0336	germandbls (width a guess)
Index: ./widths/widthlj3u/X
*** /tmp/PATCHold/./widths/widthlj3u/X	Wed Jan 13 02:15:40 1993
--- ./widths/widthlj3u/X	Wed Jan 13 02:15:41 1993
***************
*** 1,5 ****
  # Univers-BoldItalic
! #2.6 92/03/03
  name X
  internalname UniBdIt
  ligatures fi fl 0
--- 1,5 ----
  # Univers-BoldItalic
! #2.7 93/01/02
  name X
  internalname UniBdIt
  ligatures fi fl 0
***************
*** 193,195 ****
--- 193,196 ----
  ~a	19	2	0342	atilde
  ~n	21	2	0267	ntilde
  ~o	21	2	0352	otilde
+ ss	18	2	0336	germandbls (width a guess)
Index: ./widths/widthlj3u/DESC
*** /tmp/PATCHold/./widths/widthlj3u/DESC	Wed Jan 13 02:15:50 1993
--- ./widths/widthlj3u/DESC	Wed Jan 13 02:15:51 1993
***************
*** 1,4 ****
! #	2.3 92/02/13
  #	special fonts have to go at the end or else troff
  #	won't know about their numbers unless you do .fp
  #
--- 1,4 ----
! #	2.4 93/01/01
  #	special fonts have to go at the end or else troff
  #	won't know about their numbers unless you do .fp
  #
***************
*** 23,26 ****
  dg di em eq es ff fi fl fm ga gr hy ib if ip is lb lc lf lh
  lk lt mi mo mu no oA oa or pd pl pt r! r? rb rc rf rg rh rk
  rn rt ru sb sc sl sp sq sr ts ua ul ~= ~A ~N ~O ~a ~n ~o vs
! vS
--- 23,26 ----
  dg di em eq es ff fi fl fm ga gr hy ib if ip is lb lc lf lh
  lk lt mi mo mu no oA oa or pd pl pt r! r? rb rc rf rg rh rk
  rn rt ru sb sc sl sp sq sr ts ua ul ~= ~A ~N ~O ~a ~n ~o vs
! vS ss
Index: ./utils/maps/cmtt.ROMAN8
*** /tmp/PATCHold/./utils/maps/cmtt.ROMAN8	Wed Jan 13 02:16:00 1993
--- ./utils/maps/cmtt.ROMAN8	Wed Jan 13 02:16:01 1993
***************
*** 1,4 ****
! #	2.1 90/07/18
  #	cmtt family roman.
  !
  0x22	0x22	"
--- 1,4 ----
! #	2.2 92/12/30
  #	cmtt family roman.
  !
  0x22	0x22	"
***************
*** 15,30 ****
  -
  .
  /
! 0
! 1
! 2
! 3
! 4
! 5
! 6
! 7
! 8
! 9
  :
  ;
  <
--- 15,30 ----
  -
  .
  /
! 0x30
! 0x31
! 0x32
! 0x33
! 0x34
! 0x35
! 0x36
! 0x37
! 0x38
! 0x39
  :
  ;
  <
Index: ./utils/Makefile
*** /tmp/PATCHold/./utils/Makefile	Wed Jan 13 02:16:13 1993
--- ./utils/Makefile	Wed Jan 13 02:16:14 1993
***************
*** 4,10 ****
  #    See the LICENSE file for a full description of the restrictions
  #    under which this software is provided.
  #
! #2.12 92/10/30
  SCRIPTS	= psdtwd showfont mkenctab calcfonts catconv dodps
  PROGRAMS = hpinterp psxlate pk2sfp pk2ditwid pktype dumpft pk2ps lj2ps \
  	asc2ps
--- 4,10 ----
  #    See the LICENSE file for a full description of the restrictions
  #    under which this software is provided.
  #
! #2.13 92/12/04
  SCRIPTS	= psdtwd showfont mkenctab calcfonts catconv dodps
  PROGRAMS = hpinterp psxlate pk2sfp pk2ditwid pktype dumpft pk2ps lj2ps \
  	asc2ps
***************
*** 34,39 ****
--- 34,43 ----
  	cd ../ ; ./troff2ps -Tlj -z > utils/T
  	./mkenctab T ljtab.c
  	rm -f T
+ 
+ ../lib/lj.fonts:
+ 	cd ../lib ; make lj.fonts
+ 
  
  #	This isn't perfect, but close
  ../debug.o ../pk.o ../cattab.o ../pkscale.o: ../defs.h ../pk.h
Index: ./utils/catconv.S
*** /tmp/PATCHold/./utils/catconv.S	Wed Jan 13 02:16:23 1993
--- ./utils/catconv.S	Wed Jan 13 02:16:24 1993
***************
*** 10,16 ****
  #
  #	This does a very simpleminded conversion of ditroff-only-isms
  #	(such as graphics) into something handleable by CAT troff.
! #	1.12 92/11/26
  $cc{'em'}=1; $cc{'ru'}=1; $cc{'14'}=1; $cc{'12'}=1; $cc{'hy'}=1;
  $cc{'34'}=1; $cc{'fi'}=1; $cc{'fl'}=1; $cc{'ff'}=1; $cc{'ct'}=1;
  $cc{'Fl'}=1; $cc{'Fi'}=1; $cc{'de'}=1; $cc{'dg'}=1; $cc{'rg'}=1;
--- 10,16 ----
  #
  #	This does a very simpleminded conversion of ditroff-only-isms
  #	(such as graphics) into something handleable by CAT troff.
! #	1.13 92/12/22
  $cc{'em'}=1; $cc{'ru'}=1; $cc{'14'}=1; $cc{'12'}=1; $cc{'hy'}=1;
  $cc{'34'}=1; $cc{'fi'}=1; $cc{'fl'}=1; $cc{'ff'}=1; $cc{'ct'}=1;
  $cc{'Fl'}=1; $cc{'Fi'}=1; $cc{'de'}=1; $cc{'dg'}=1; $cc{'rg'}=1;
***************
*** 114,120 ****
  	    } else {
  		printf STDERR "Don't know the width of \\($char";
  	    }
! 	    $newline .= "\\ka\\o'\\(bs\\(bs'C$char\\(bs\\h'|\\nau+\\w\"$w\"'";
  	}
      }
      $newline .= $line;
--- 114,120 ----
  	    } else {
  		printf STDERR "Don't know the width of \\($char";
  	    }
! 	    $newline .= "\\ka\\o'\\(bs\\(bs'C$char\\(bs\\h'|\\nau+\\w$w'";
  	}
      }
      $newline .= $line;
Index: ./utils/pk2ditwid.c
*** /tmp/PATCHold/./utils/pk2ditwid.c	Wed Jan 13 02:16:32 1993
--- ./utils/pk2ditwid.c	Wed Jan 13 02:16:33 1993
***************
*** 10,16 ****
  
  #ifndef	lint
  static char SCCSID[] =
!     "@(#)pk2ditwid.c 2.5 Copyright 92/11/26 19:45:39 Chris Lewis";
  #endif
  
  #include "defs.h"
--- 10,16 ----
  
  #ifndef	lint
  static char SCCSID[] =
!     "@(#)pk2ditwid.c 2.6 Copyright 92/12/22 09:02:30 Chris Lewis";
  #endif
  
  #include "defs.h"
***************
*** 32,38 ****
  FILE *fout = NULL;
  char *progname;
  
! #define	UNITWIDTH	10
  
  main(argc, argv)
  int argc;
--- 32,39 ----
  FILE *fout = NULL;
  char *progname;
  
! int unitwidth = 10;
! int outputres = OUTRES;
  
  main(argc, argv)
  int argc;
***************
*** 45,52 ****
      struct enctab *et;
  
      progname = argv[0];
!     while((c = getopt(argc, argv, "AD:sS")) != EOF) {
  	switch(c) {
  	    case 's':
  		silent = 1;
  		break;
--- 46,69 ----
      struct enctab *et;
  
      progname = argv[0];
!     while((c = getopt(argc, argv, "AD:sSr:u:")) != EOF) {
  	switch(c) {
+ 	    case 'u':
+ 		unitwidth = atoi(optarg);
+ 		if (unitwidth < 1) {
+ 		    fprintf(stderr, "%s: invalid unitwidth: -u%s\n",
+ 			progname, optarg);
+ 		    exit(1);
+ 		}
+ 		break;
+ 	    case 'r':
+ 		outputres = atoi(optarg);
+ 		if (outputres < 1) {
+ 		    fprintf(stderr, "%s: invalid outputres: -u%s\n",
+ 			progname, optarg);
+ 		    exit(1);
+ 		}
+ 		break;
  	    case 's':
  		silent = 1;
  		break;
***************
*** 123,129 ****
  	if (allflag) {
  	    fprintf(fout,
  		"Width: width of character at %d points at %dDPI\n",
! 		UNITWIDTH, OUTRES);
  	    fprintf(fout,
  		"Kern: 2 for ascenders, 1 for descenders or'd together\n");
  	    fprintf(fout, "Code: Hexidecimal code\n");
--- 140,146 ----
  	if (allflag) {
  	    fprintf(fout,
  		"Width: width of character at %d points at %dDPI\n",
! 		unitwidth, outputres);
  	    fprintf(fout,
  		"Kern: 2 for ascenders, 1 for descenders or'd together\n");
  	    fprintf(fout, "Code: Hexidecimal code\n");
***************
*** 131,140 ****
  	} else {
  	    fprintf(fout, "# %s\n", buf);
  	    fprintf(fout, "# Generated by pk2ditwid\n");
  	    fprintf(fout, "name %s\n", buf);
  	    if (buf[0] == 'S')
  		fprintf(fout, "special\n");
! 	    fprintf(fout, "spacewidth 22\n");
  	    fprintf(fout, "charset\n");
  	}
  
--- 148,159 ----
  	} else {
  	    fprintf(fout, "# %s\n", buf);
  	    fprintf(fout, "# Generated by pk2ditwid\n");
+ 	    fprintf(fout, "# -u%d -r%d\n", unitwidth, outputres);
  	    fprintf(fout, "name %s\n", buf);
  	    if (buf[0] == 'S')
  		fprintf(fout, "special\n");
! 	    fprintf(fout, "spacewidth %d\n", 22 * unitwidth * outputres / 
! 		(10 * OUTRES));
  	    fprintf(fout, "charset\n");
  	}
  
***************
*** 145,153 ****
  				/* get # pixels */
  		long widval = ((double) pc->pkc_dx / pow2(16)) *
  				/* normalize by actual resolution */
! 			      ((double) OUTRES / pk->pkp_res) *
  				/* normalize to UNITWIDTH points */
! 			      ((double) UNITWIDTH * pow2(20) / pk->pkp_ds) +
  				/* round ... */
  			      0.5;
  		int kern = ((pk->pkp_kh < pc->pkc_y_off) << 1) |
--- 164,172 ----
  				/* get # pixels */
  		long widval = ((double) pc->pkc_dx / pow2(16)) *
  				/* normalize by actual resolution */
! 			      ((double) outputres / pk->pkp_res) *
  				/* normalize to UNITWIDTH points */
! 			      ((double) unitwidth * pow2(20) / pk->pkp_ds) +
  				/* round ... */
  			      0.5;
  		int kern = ((pk->pkp_kh < pc->pkc_y_off) << 1) |
***************
*** 208,216 ****
  				/* get # pixels */
  		long widval = ((double) pc->pkc_dx / pow2(16)) *
  				/* normalize by actual resolution */
! 			      ((double) OUTRES / p->pkp_res) *
  				/* normalize to UNITWIDTH points */
! 			      ((double) UNITWIDTH * pow2(20) / p->pkp_ds) +
  				/* round ... */
  			      0.5;
  		int kern = ((p->pkp_kh < pc->pkc_y_off) << 1) |
--- 227,235 ----
  				/* get # pixels */
  		long widval = ((double) pc->pkc_dx / pow2(16)) *
  				/* normalize by actual resolution */
! 			      ((double) outputres / p->pkp_res) *
  				/* normalize to UNITWIDTH points */
! 			      ((double) unitwidth * pow2(20) / p->pkp_ds) +
  				/* round ... */
  			      0.5;
  		int kern = ((p->pkp_kh < pc->pkc_y_off) << 1) |
Index: ./utils/psxlate.c
*** /tmp/PATCHold/./utils/psxlate.c	Wed Jan 13 02:16:44 1993
--- ./utils/psxlate.c	Wed Jan 13 02:16:46 1993
***************
*** 23,29 ****
   */
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)psxlate.c: 2.20 Copyright 92/03/12 01:11:56 Chris Lewis";
  #endif
  
  #ifdef	ALONE
--- 23,29 ----
   */
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)psxlate.c: 2.21 Copyright 92/12/04 23:16:31 Chris Lewis";
  #endif
  
  #ifdef	ALONE
***************
*** 243,249 ****
  FILE *in;
  FILE *out;
  char *buffer; {
-     extern char *malloc();
      long offset;
      int state = PROLOG;
      int seen;
--- 243,248 ----
***************
*** 574,580 ****
      register char *p;
      register long curlength;
      register int ch;
-     extern char *realloc();
  
      if (count != (long *) NULL)
  	*count = curcount;
--- 573,578 ----
Index: ./tests/exttab.m
*** /tmp/PATCHold/./tests/exttab.m	Wed Jan 13 02:16:59 1993
--- ./tests/exttab.m	Wed Jan 13 02:17:00 1993
***************
*** 1,4 ****
! .\" DITROFF extensions 1.5
  .DS
  .EQ
  G(z)~mark =~ e sup { ln ~ G(z) }
--- 1,6 ----
! .\" DITROFF extensions 1.7
! .ps 20
! .vs 24p
  .DS
  .EQ
  G(z)~mark =~ e sup { ln ~ G(z) }
***************
*** 45,51 ****
  _
  \(vs	\e(vs	\(~A	\e(~A	\(~N	\e(~N	\(~O	\e(~O
  _
! \(~a	\e(~a	\(~n	\e(~n	\(~o	\e(~o	
  .TE
  .bp
  .sp 1i
--- 47,53 ----
  _
  \(vs	\e(vs	\(~A	\e(~A	\(~N	\e(~N	\(~O	\e(~O
  _
! \(~a	\e(~a	\(~n	\e(~n	\(~o	\e(~o	\(ss	\e(ss
  .TE
  .bp
  .sp 1i
Index: ./adapters/tmac.an.S
*** /tmp/PATCHold/./adapters/tmac.an.S	Wed Jan 13 02:17:19 1993
--- ./adapters/tmac.an.S	Wed Jan 13 02:17:21 1993
***************
*** 1,4 ****
! .\"@(#)ident tmac.an 2.1 90/07/18
  .so %%LIBDIR%%/adapters/cmn.pre
  .so %%RTMACDIR%%/tmac.an
  .\"Default offset (my version of the man macros uses it).
--- 1,4 ----
! .\"@(#)ident tmac.an 2.2 93/01/01
  .so %%LIBDIR%%/adapters/cmn.pre
  .so %%RTMACDIR%%/tmac.an
  .\"Default offset (my version of the man macros uses it).
***************
*** 6,11 ****
--- 6,14 ----
  .\"See if someone's using the -rO option (ala MM)
  .if \nO .nr )O \nOu
  .po \n()Ou
+ .\"Fix up page length (my version of the man macros uses it)
+ .if \nL .nr )L \nLu
+ .pl \n()Lu
  .\"Clobber cut marks.
  .rm }C
  .so %%LIBDIR%%/adapters/cmn.post
Index: ./utils.c
*** /tmp/PATCHold/./utils.c	Wed Jan 13 02:17:39 1993
--- ./utils.c	Wed Jan 13 02:17:41 1993
***************
*** 12,18 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)utils.c: 2.26 Copyright 92/07/09 23:34:53 Chris Lewis";
  #endif
  
  #ifndef	HEADERSIZE
--- 12,18 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)utils.c: 2.31 Copyright 92/12/31 23:54:10 Chris Lewis";
  #endif
  
  #ifndef	HEADERSIZE
***************
*** 33,38 ****
--- 33,50 ----
  
  extern struct cattab tabN[], tabS[];
  
+ char *
+ mystrstr(str, pat)
+ register char *str, *pat; {
+     register int n = strlen(pat);
+     while(*str && (str = strchr(str, *pat))) {
+ 	if (strncmp(str, pat, n) == 0)
+ 	    return(str);
+ 	str++;
+     }
+     return((char *) NULL);
+ }
+ 
  int lastFont, lastPoints;
  int lastYPos, lastXPos;
  
***************
*** 43,50 ****
  struct troff2befont *extchars;
  struct cattab *extidx;
  
- extern char *malloc();
- 
  char *skipblanks(p)
  register char *p; {
      while (*p && isspace(*p)) p++;
--- 55,60 ----
***************
*** 59,64 ****
--- 69,348 ----
      return(p);
  }
  
+ #define	PROCHUNK	20
+ int procount;
+ 
+ #define ST_PASSTHRU	0
+ #define ST_IFPASSTHRU	1
+ #define ST_IFSKIPPING	2
+ #define ST_IFDONE	3
+ 
+ #ifdef DEBUG
+ char *stpr[] = {"passstate", "ifpassstate", "ifskipstate", "ifdonestate"};
+ #endif
+ 
+ #define	SEE_NONE	0
+ #define	SEE_IFELSE	1
+ #define	SEE_ENDIF	2
+ 
+ #ifdef DEBUG
+ char *sepr[] = {"none", "ifelse", "endif"};
+ #endif
+ 
+ void
+ insprolog(arg)
+ char *arg; {
+ 
+     if (!prologs) {
+ 	prologs = (char **) mustmalloc(PROCHUNK * sizeof(char*), "prologs");
+ 	procount = 0;
+     }
+ 
+     prologs[procount] = (char *) mustmalloc(strlen(arg)+1, "prolog item");
+     strcpy(prologs[procount++], arg);
+ 
+     /* insert the null */
+     if ((procount % PROCHUNK) == 0)
+ 	prologs = (char **) realloc((char *) prologs,
+ 	    (procount + PROCHUNK) * sizeof(char *));
+     prologs[procount] = (char *) NULL;
+ }
+ 
+ #ifdef DEBUG
+ dumpprologs() {
+     char **pp;
+     if (!(debug&D_SPEC) || !prologs)
+ 	return;
+     for (pp = prologs; *pp; pp++)
+ 	DBP((D_SPEC, "S prologs: %s\n", *pp));
+ }
+ #endif
+ 
+ void
+ setnp(param, value)
+ char *param;
+ int value; {
+     char buf[30];
+     sprintf(buf, "X%s=%d", param, value);
+     insprolog(buf);
+ }
+ 
+ static int outputres;
+ setparams(outres)
+ int outres; {
+     char buf[30];
+ 
+     outputres = outres;
+ 
+     setnp("pagelength", pagelength * outres / TROFFRESOLUTION);
+     setnp("pagewidth", pagewidth * outres / TROFFRESOLUTION);
+     setnp("pagexoffset", pageoffset * outres / TROFFRESOLUTION);
+     setnp("pageyoffset", pageyoffset * outres / TROFFRESOLUTION);
+     insprolog("Xdefault=1");
+ }
+ 
+ static
+ preeval(line)
+ char *line; {
+     int ret;
+     if (!*line)
+ 	return(0);
+     while(*line && isspace(*line)) line++;
+     ret = atoi(line);
+     DBP((D_SPEC, "S preeval: '%s', returns %d\n", line, ret));
+     return(ret);
+ }
+ 
+ static
+ seetok(line, tok, len)
+ char *line, *tok;
+ int len; {
+     register char *t = line, *f;
+ 
+     line++;
+     while(*line && isspace(*line)) line++;
+     DBP((D_SPEC, "S seetok: (%s,%s,%d)\n", line, tok, len));
+     if (strncmp(line, tok, len) == 0 &&
+ 	(!*(line+len) || isspace(*(line+len)) )) {
+ 
+ 	for (f = line+len; *f && isspace(*f); f++);
+ 	if (!*f)
+ 	    *t = '\0';
+ 	else
+ 	    while(*t++ = *f++);
+ 	return(1);
+     } else
+ 	return(0);
+ }
+ 
+ char *
+ findval(var)
+ char *var; {
+     register char **pro, *pp;
+     int vlen = strlen(var);
+     if (pro = prologs)
+ 	for(;*pro ; pro++)
+ 	    if (**pro == 'X') {
+ 		pp = (*pro) + 1;
+ 		if (strncmp(var, pp, vlen) == 0)
+ 		    if (*(pp + vlen) == '\0') {
+ 			return("1");
+ 		    } else if (*(pp + vlen) == '=') {
+ 			return(pp + vlen + 1);
+ 		    }
+ 	    }
+     return("");
+ }
+ 
+ #define	EVAL	"_eval("
+ #define LENEVAL	6
+ static void
+ domacros(line)
+ char *line; {
+     char temp[512];
+     register char *varptr, *restptr, *subs, *modptr;
+     int value;
+ 
+     while((varptr = mystrstr(line, EVAL))) {
+ 	if (!(restptr = strchr(varptr + LENEVAL, ')'))) {
+ 	    fprintf(stderr, "%s: malformed _eval() in line: %s\n", progname, line);
+ 	    return;
+ 	}
+ 	*varptr = '\0';
+ 	varptr += LENEVAL;
+ 
+ 	*restptr++ = '\0';
+ 
+ 	if (modptr = strchr(varptr, ','))
+ 	    *modptr++ = '\0';
+ 
+ 	DBP((D_SPEC, "S _eval(%s), line: %s|SUBS|%s\n", varptr, line, restptr));
+ 	subs = findval(varptr);
+ 
+ 	strcpy(temp, line);
+ 
+ 	if (!modptr)
+ 	    strcat(temp, subs);
+ 	else {
+ 	    value = atoi(subs);
+ 	    
+ 	    if (isdigit(*modptr))
+ 		value *= atoi(modptr);
+ 	    else
+ 		switch(*modptr) {
+ 		    case 'i':
+ 			break;
+ 		    case 'd':
+ 			value *= 720;
+ 			break;
+ 		    case 'c':
+ 			value *= 2.54;
+ 			break;
+ 		    case 'p':
+ 			value *= 72;
+ 			break;
+ 		    case 'P':
+ 			value *= 6;
+ 			break;
+ 		}
+ 	    value /= outputres;
+ 	    subs = temp + strlen(temp);
+ 	    sprintf(subs, "%d", value);
+ 	}
+ 	strcat(temp, restptr);
+ 	strcpy(line, temp);
+ 	DBP((D_SPEC, "S evalresult: %s\n", line));
+     }
+ }
+ 
+ /*	FSA to do preprocessing:
+ 		#ifelse <condition>
+ 		#ifelse <condition2>
+ 		#endif
+ 
+ 	Returns 1 to pass thru the line.  otherwise 0 means skip it.
+  */
+ int
+ preproc(line, state)
+ char *line;
+ int *state; {
+     int seenflag = SEE_NONE;
+     register char *p;
+ 
+     if (p = strchr(line, '\n'))
+ 	*p = '\0';
+ 
+     domacros(line);
+ 
+     if (line[0] == '#') {
+ 	if (seetok(line, "if", 2) ||
+ 	    seetok(line, "elif", 4))
+ 		seenflag = SEE_IFELSE;
+ 	else if (seetok(line, "endif", 5))
+ 		seenflag = SEE_ENDIF;
+ 	else {
+ 	    fprintf(stderr, "%s: invalid preprocessor directive: %s\n", progname,
+ 		line);
+ 	    return(0);
+ 	}
+ 	DBP((D_SPEC, "S preproc: '%s', line: %s\n", sepr[seenflag], line));
+     }
+ 
+     switch(*state) {
+ 	case ST_PASSTHRU:
+ 	    switch (seenflag) {
+ 	    	case SEE_NONE:
+ 		    break;
+ 		case SEE_ENDIF:
+ 		    fprintf(stderr, "%s: ifelse-less endif\n", progname);
+ 		    break;
+ 		case SEE_IFELSE:
+ 		    if (preeval(line))
+ 			*state = ST_IFPASSTHRU;
+ 		    else
+ 			*state = ST_IFSKIPPING;
+ 		    break;
+ 	    }
+ 	    break;
+ 	case ST_IFPASSTHRU:
+ 	    switch(seenflag) {
+ 		case SEE_NONE:
+ 		    break;
+ 		case SEE_IFELSE:
+ 		    *state = ST_IFDONE;
+ 		    break;
+ 		case SEE_ENDIF:
+ 		    *state = ST_PASSTHRU;
+ 		    break;
+ 	    }
+ 	    break;
+ 	case ST_IFSKIPPING:
+ 	    switch(seenflag) {
+ 		case SEE_NONE:
+ 		    break;
+ 		case SEE_IFELSE:
+ 		    if (preeval(line))
+ 			*state = ST_IFPASSTHRU;
+ 		    break;
+ 		case SEE_ENDIF:
+ 		    *state = ST_PASSTHRU;
+ 		    break;
+ 	    }
+ 	    break;
+ 	case ST_IFDONE:
+ 	    if (seenflag == SEE_ENDIF)
+ 		*state = ST_PASSTHRU;
+ 	    break;
+     }
+     if (seenflag != SEE_NONE || *state == ST_IFSKIPPING || *state == ST_IFDONE)
+ 	seenflag = 0;
+     else
+ 	seenflag = 1;
+     DBP((D_SPEC, "S preproc(%s:%s) line: %s\n", seenflag == 1?"pass":"skip",
+ 	stpr[*state], line));
+     return(seenflag);
+ }
+ 
  interp(buf, xlator, suf)
  char *buf, *suf; FUNC xlator; {
      register char *p;
***************
*** 69,87 ****
  	FILE *inc;
  	binary = (token[0] == 'b') ? 1: 0;
  	p = gettok(p, token);
! 	DBP((D_SPEC, "Trying to include %s\n", token));
  	if (!(inc = fopen(token, "r"))) {
  	    strcat(token, ".");
  	    strcat(token, suf);
! 	    DBP((D_SPEC, "Trying to include %s\n", token));
  	    if (!(inc = fopen(token, "r"))) {
  		char nbuf[512];
  		if (token[0] != '/') {
  		    sprintf(nbuf, "%s/%s", "lib", token);
! 		    DBP((D_SPEC, "Trying to include %s\n", nbuf));
  		    if (!(inc = fopen(nbuf, "r"))) {
  			sprintf(nbuf, "%s/%s", LIBDIR, token);
! 			DBP((D_SPEC, "Trying to include %s\n", nbuf));
  			inc = fopen(nbuf, "r");
  		    }
  		}
--- 353,371 ----
  	FILE *inc;
  	binary = (token[0] == 'b') ? 1: 0;
  	p = gettok(p, token);
! 	DBP((D_SPEC, "S include %s?\n", token));
  	if (!(inc = fopen(token, "r"))) {
  	    strcat(token, ".");
  	    strcat(token, suf);
! 	    DBP((D_SPEC, "S include %s?\n", token));
  	    if (!(inc = fopen(token, "r"))) {
  		char nbuf[512];
  		if (token[0] != '/') {
  		    sprintf(nbuf, "%s/%s", "lib", token);
! 		    DBP((D_SPEC, "S include %s?\n", nbuf));
  		    if (!(inc = fopen(nbuf, "r"))) {
  			sprintf(nbuf, "%s/%s", LIBDIR, token);
! 			DBP((D_SPEC, "S include %s?\n", nbuf));
  			inc = fopen(nbuf, "r");
  		    }
  		}
***************
*** 91,97 ****
  	    fprintf(stderr, "%s: cannot open file %s\n", progname, token);
  	    exit(1);
  	} else {
! 	    DBP((D_SPEC, "Successfull include\n"));
  	    if (binary || !xlator)
  		while ((binary = fread(token, 1, sizeof(token), inc)) > 0)
  		    fwrite(token, 1, binary, stdout);
--- 375,381 ----
  	    fprintf(stderr, "%s: cannot open file %s\n", progname, token);
  	    exit(1);
  	} else {
! 	    DBP((D_SPEC, "S include successful\n"));
  	    if (binary || !xlator)
  		while ((binary = fread(token, 1, sizeof(token), inc)) > 0)
  		    fwrite(token, 1, binary, stdout);
***************
*** 210,216 ****
  			}
  
  			if (state == READEXT) {
- 			    extern char *realloc();
  			    if (!(extcount % EXTCHUNK)) {
  				if (!extchars) {
  				    extchars = (struct troff2befont *)
--- 494,499 ----
***************
*** 284,290 ****
      if (debug&D_CAT) {
  	static char wid[4] = { 2, 25, 30, 10 };
  	for (count = 0; count < tableindex; count++) {
! 	    DBP((D_CAT, "font %2d:", count));
  	    for(i = 0; i < 4; i++) {
  		if (fonttable[count].tab[i])
  		    DBP((D_CAT, " %-*s", wid[i],
--- 567,573 ----
      if (debug&D_CAT) {
  	static char wid[4] = { 2, 25, 30, 10 };
  	for (count = 0; count < tableindex; count++) {
! 	    DBP((D_CAT, "C font %2d:", count));
  	    for(i = 0; i < 4; i++) {
  		if (fonttable[count].tab[i])
  		    DBP((D_CAT, " %-*s", wid[i],
***************
*** 430,436 ****
  #endif
      register struct fonttable *p;
      int intfont;
!     DBP((D_SPEC, "FontSel: %s -> %s\n", from, to));
  
      intfont = atoi(from);
  
--- 713,719 ----
  #endif
      register struct fonttable *p;
      int intfont;
!     DBP((D_SPEC, "S FontSel: %s -> %s\n", from, to));
  
      intfont = atoi(from);
  
***************
*** 449,455 ****
  	intfont = INTFONTS - 1;
      if (strcmp(to, "S") == 0) {
  	symidx = intfont;
! 	DBP((D_CAT, "Special font is: %d\n", symidx));
      }
  
      for (p = fonttable; p->troffName; p++)
--- 732,738 ----
  	intfont = INTFONTS - 1;
      if (strcmp(to, "S") == 0) {
  	symidx = intfont;
! 	DBP((D_CAT, "C Special font is: %d\n", symidx));
      }
  
      for (p = fonttable; p->troffName; p++)
***************
*** 472,478 ****
  #ifdef	DEBUG
      for (i = 0; i < INTFONTS; i++)
  	if (xlatetable[i])
! 	    DBP((D_SPEC, "Font %d->%s\n", i+1, xlatetable[i]->fontName));
  #endif
  }
  
--- 755,761 ----
  #ifdef	DEBUG
      for (i = 0; i < INTFONTS; i++)
  	if (xlatetable[i])
! 	    DBP((D_SPEC, "S Font %d->%s\n", i+1, xlatetable[i]->fontName));
  #endif
  }
  
***************
*** 506,515 ****
  }
  
  doprologs() {
      if (!prologs)
  	return;
!     while(*prologs)
! 	dospecial(*prologs++);
  }
  
  #ifdef	OPT
--- 789,800 ----
  }
  
  doprologs() {
+     register char **pp;
      if (!prologs)
  	return;
!     for(pp = prologs;*pp;pp++)
! 	if (**pp != 'X')
! 	    dospecial(*pp);
  }
  
  #ifdef	OPT
***************
*** 524,530 ****
      p->widthtable = mustmalloc(224, "widthtable");
      strcpy(widthptr, "ft");
      strcat(widthptr, p->troffName);
!     DBP((D_SPEC, "Attempting to read font file %s\n", widthtables));
      if (f = fopen(widthtables, "r")) {
  	for (c = 0; c < HEADERSIZE; c++) getc(f);
  #ifdef	ASCIIWIDTHS
--- 809,815 ----
      p->widthtable = mustmalloc(224, "widthtable");
      strcpy(widthptr, "ft");
      strcat(widthptr, p->troffName);
!     DBP((D_SPEC, "S Attempting to read font file %s\n", widthtables));
      if (f = fopen(widthtables, "r")) {
  	for (c = 0; c < HEADERSIZE; c++) getc(f);
  #ifdef	ASCIIWIDTHS
***************
*** 536,549 ****
  		progname, widthtables);
  	    free(p->widthtable);
  	    p->widthtable = (char *) 1;
! 	    DBP((D_SPEC, "Load of %s failed\n", widthtables));
  	} else {
  	    for (c = 0; c < 224; c++)
  		p->widthtable[c] &= 0x3f;
! 	    DBP((D_SPEC, "Load of %s succeeded\n", widthtables));
  	}
      } else {
! 	DBP((D_SPEC, "Failed to open widthtable %s\n", widthtables));
  	free(p->widthtable);
  	p->widthtable = (char *) 1;
  	/* This isn't really the right way to do this, but.... */
--- 821,834 ----
  		progname, widthtables);
  	    free(p->widthtable);
  	    p->widthtable = (char *) 1;
! 	    DBP((D_SPEC, "S Load of %s failed\n", widthtables));
  	} else {
  	    for (c = 0; c < 224; c++)
  		p->widthtable[c] &= 0x3f;
! 	    DBP((D_SPEC, "S Load of %s succeeded\n", widthtables));
  	}
      } else {
! 	DBP((D_SPEC, "S Failed to open widthtable %s\n", widthtables));
  	free(p->widthtable);
  	p->widthtable = (char *) 1;
  	/* This isn't really the right way to do this, but.... */
Index: ./ps.c
*** /tmp/PATCHold/./ps.c	Wed Jan 13 02:17:57 1993
--- ./ps.c	Wed Jan 13 02:18:00 1993
***************
*** 15,21 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)ps.c: 2.21 Copyright 92/11/26 19:41:28 Chris Lewis";
  #endif
  
  /*	ps.c will generate some additional "print" commands to cause
--- 15,21 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)ps.c: 2.22 Copyright 92/12/20 23:07:00 Chris Lewis";
  #endif
  
  /*	ps.c will generate some additional "print" commands to cause
***************
*** 524,534 ****
      long curtime;
      register struct fonttable *p;
  
      currentPage = 0;
      pagePending = 1;
  
-     library = libopen(printer, "lib");
- 
      time(&curtime);
      strcpy(buffer, ctime(&curtime));
      *strchr(buffer, '\n') = '\0';
--- 524,534 ----
      long curtime;
      register struct fonttable *p;
  
+     setparams(PSRESOLUTION);
+ 
      currentPage = 0;
      pagePending = 1;
  
      time(&curtime);
      strcpy(buffer, ctime(&curtime));
      *strchr(buffer, '\n') = '\0';
***************
*** 560,565 ****
--- 560,567 ----
      printf("flush\n");
  #endif
      printf("usertime /btime exch def\n");
+ 
+     library = libopen(printer, "lib");
      psXlate(library, "lib.ps");
  
      for (p = fonttable; p->troffName; p++) {
***************
*** 606,616 ****
  FILE *library;
  char *libname; {
      char buf[512];
      printf("%%%%BeginDocument: %s\n", libname);
!     while (fgets(buf, sizeof(buf), library))
  	if (0 == strncmp(buf, "%%%", 3))
  	    interp(&buf[3], psXlate, "ps");
! 	else
  	    /* some backends don't like extra %! - eg: PageView */
  	    if (0 == strncmp(buf, "%!", 2)) {
  		buf[1] = '%';
--- 608,622 ----
  FILE *library;
  char *libname; {
      char buf[512];
+     int state = 0;
+ 
      printf("%%%%BeginDocument: %s\n", libname);
!     while (fgets(buf, sizeof(buf), library)) {
! 	if (!preproc(buf, &state))
! 	    continue;
  	if (0 == strncmp(buf, "%%%", 3))
  	    interp(&buf[3], psXlate, "ps");
! 	else {
  	    /* some backends don't like extra %! - eg: PageView */
  	    if (0 == strncmp(buf, "%!", 2)) {
  		buf[1] = '%';
***************
*** 617,622 ****
--- 623,631 ----
  		fputs(&buf[1], stdout);
  	    } else
  		fputs(buf, stdout);
+ 	    putchar('\n');
+ 	}
+     }
      printf("%%%%EndDocument\n");
  }
  
Index: ./dit.c
*** /tmp/PATCHold/./dit.c	Wed Jan 13 02:18:20 1993
--- ./dit.c	Wed Jan 13 02:18:22 1993
***************
*** 12,18 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)dit.c: 1.20 Copyright 92/07/09 23:35:14 Chris Lewis";
  #endif
  
  extern struct cattab tabN[], tabS[], *extidx;
--- 12,18 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)dit.c: 1.23 Copyright 92/12/04 23:39:55 Chris Lewis";
  #endif
  
  extern struct cattab tabN[], tabS[], *extidx;
***************
*** 28,35 ****
  
  struct cattab *ditsearch(str)
  char *str; {
-     /* should do binary search */
      register int l, mid, h, k;
      l = 0;
      h = extcount - 1;
  #ifdef	NEVER
--- 28,35 ----
  
  struct cattab *ditsearch(str)
  char *str; {
      register int l, mid, h, k;
+     struct cattab *dp;
      l = 0;
      h = extcount - 1;
  #ifdef	NEVER
***************
*** 40,48 ****
      while(l <= h) {
  	mid = (l + h) >> 1;
  	k = strcmp(str, spctab[mid]->ch_name);
! 	if (k == 0)
! 	    return(spctab[mid]);
! 	else if (k < 0)
  	    h = mid - 1;
  	else
  	    l = mid + 1;
--- 40,52 ----
      while(l <= h) {
  	mid = (l + h) >> 1;
  	k = strcmp(str, spctab[mid]->ch_name);
! 	if (k == 0) {
! 	    dp = spctab[mid];
! 	    DBP((D_CAT,
! 		"D ditsearch(%s) -> ch_name: %s, set: %d, catidx: %d, wididx: %d, desc: %s\n",
! 		str, dp->ch_name, dp->ch_set, dp->ch_catidx, dp->ch_wididx, dp->ch_desc));
! 	    return(dp);
! 	} else if (k < 0)
  	    h = mid - 1;
  	else
  	    l = mid + 1;
***************
*** 58,72 ****
  addtab(table)
  struct cattab *table; {
      register struct cattab *p;
-     extern char *realloc();
  
      for (p = table; p->ch_name != NOC; p++) {
! 	DBP((D_CAT, "Addtab: %s\n", p->ch_name));
! 	if (p->ch_desc != NOC && p->ch_catidx != NTC)
! 	    if (strlen(p->ch_name) == 1)
  		dittab[p->ch_name[0]] = p;
! 	    else {
! 		DBP((D_CAT, "AddtabS: %s %d\n", p->ch_name, extcount));
  		if (extcount > 0 && !(extcount%EXTCHUNK)) {
  		    spctab = (struct cattab **) realloc(spctab,
  			sizeof(struct cattab *) * (extcount + EXTCHUNK + 1));
--- 62,75 ----
  addtab(table)
  struct cattab *table; {
      register struct cattab *p;
  
      for (p = table; p->ch_name != NOC; p++) {
! 	if (p->ch_desc != NOC && p->ch_catidx != NTC) {
! 	    DBP((D_CAT, "D addtab: %s, desc: %s, catidx: %d\n", p->ch_name,
! 		p->ch_desc, p->ch_catidx));
! 	    if (strlen(p->ch_name) == 1) {
  		dittab[p->ch_name[0]] = p;
! 	    } else {
  		if (extcount > 0 && !(extcount%EXTCHUNK)) {
  		    spctab = (struct cattab **) realloc(spctab,
  			sizeof(struct cattab *) * (extcount + EXTCHUNK + 1));
***************
*** 76,87 ****
  		}
  		spctab[extcount++] = p;
  	    }
      }
  }
  
  fixtab() {
      register int i;
-     extern char *malloc();
  
      dittab = (struct cattab **) mustmalloc(sizeof(struct cattab *) * 256,
  	"dittab");
--- 79,90 ----
  		}
  		spctab[extcount++] = p;
  	    }
+ 	}
      }
  }
  
  fixtab() {
      register int i;
  
      dittab = (struct cattab **) mustmalloc(sizeof(struct cattab *) * 256,
  	"dittab");
***************
*** 100,135 ****
      dittab['-'] = &tabN[31];
      dittab['_'] = &tabS[31];
  
!     DBP((D_CAT, "End addtab: %d characters\n", extcount));
  
      spctab[extcount] = NULL;
  
-     DBP((D_CAT, "After NULL\n"));
- 
- #ifdef DEBUG
-     if (debug&D_CAT) {
- 
- 	for (ts = spctab; *ts; ts++)
- 	    DBP((D_CAT, "%s -> %08x (%d)\n", (*ts)->ch_name, *ts,
- 		(*ts)->ch_catidx));
- 
-     }
- #endif
- 
      qsort(spctab, extcount, sizeof (struct cattab *), catcmp);
  
-     DBP((D_CAT, "After qsort\n"));
- 
  #ifdef DEBUG
      if (debug&D_CAT) {
  
  	for (ts = spctab; *ts; ts++)
! 	    DBP((D_CAT, "%s -> %08x (%d)\n", (*ts)->ch_name, *ts,
  		(*ts)->ch_catidx));
  
  	for (i = 0; i < 256; i++)
  	    if (dittab[i])
! 		DBP((D_CAT, "%d:%02x:%c: %d/%d\n", i, i, i, dittab[i]->ch_set,
  		dittab[i]->ch_catidx));
      }
  #endif
--- 103,127 ----
      dittab['-'] = &tabN[31];
      dittab['_'] = &tabS[31];
  
!     DBP((D_CAT, "D end addtab: %d characters\n", extcount));
  
      spctab[extcount] = NULL;
  
      qsort(spctab, extcount, sizeof (struct cattab *), catcmp);
  
  #ifdef DEBUG
      if (debug&D_CAT) {
+ 	int i;
+ 
+ 	DBP((D_CAT, "D after qsort\n"));
  
  	for (ts = spctab; *ts; ts++)
! 	    DBP((D_CAT, "D %s -> %08x (%d)\n", (*ts)->ch_name, *ts,
  		(*ts)->ch_catidx));
  
  	for (i = 0; i < 256; i++)
  	    if (dittab[i])
! 		DBP((D_CAT, "D %d:%02x:%c: %d/%d\n", i, i, i, dittab[i]->ch_set,
  		dittab[i]->ch_catidx));
      }
  #endif
***************
*** 152,158 ****
      register struct cattab *last = (struct cattab *) NULL;
      char special[512];
      fixtab();
-     DBP((D_CAT, "Finished fixtab\n"));
      cmd = skipwhite();
      if (cmd == 0x40) {
  	fprintf(stderr, "%s: illegal starting sequence for ditroff.\n",
--- 144,149 ----
***************
*** 172,178 ****
  	    case 's':
  		points = getnum();
  		points /= sizescale;
! 		DBP((D_CAT, "Pointsize %d\n", points));
  		break;
  	    case 'f':
  		font = getnum();
--- 163,169 ----
  	    case 's':
  		points = getnum();
  		points /= sizescale;
! 		DBP((D_CAT, "D point: %d\n", points));
  		break;
  	    case 'f':
  		font = getnum();
***************
*** 186,192 ****
  		    font = INTFONTS - 1;
  		else
  		    font--;
! 		DBP((D_CAT, "Font %d\n", font));
  		break;
  	    case '0':
  	    case '1':
--- 177,183 ----
  		    font = INTFONTS - 1;
  		else
  		    font--;
! 		DBP((D_CAT, "D font: %d\n", font));
  		break;
  	    case '0':
  	    case '1':
***************
*** 260,265 ****
--- 251,257 ----
  		while((ch = getchar()) != EOF && !isspace(ch))
  		    special[i++] = ch;
  		special[i] = '\0';
+ 		DBP((D_CAT, "D C%s, font: %d\n", special, font));
  		if (last && strcmp(last->ch_name, special) == 0)
  		    p = last;
  		else {
***************
*** 276,286 ****
  			    p->ch_set == N ? -font-1 : -symidx-1,
  			    points, p->ch_catidx,
  			    extchars[p->ch_catidx].t2b_charseq);
! 		    else
! 			ditemit(xpos, ypos,
! 			    p->ch_set == N ? font : symidx,
! 			    points, p->ch_catidx, (char *) NULL);
! 		    DBP((D_CAT, "Special %s\n", special));
  		}
  		break;
  	    case 'x':
--- 268,282 ----
  			    p->ch_set == N ? -font-1 : -symidx-1,
  			    points, p->ch_catidx,
  			    extchars[p->ch_catidx].t2b_charseq);
! 		    else {
! 			int mfont = font;
! 			if (font == symidx && p->ch_set == N)
! 			    mfont = 0;
! 			else if (font != symidx && p->ch_set == S)
! 			    mfont = symidx;
! 			ditemit(xpos, ypos, mfont, points, p->ch_catidx,
! 			    (char *) NULL);
! 		    }
  		}
  		break;
  	    case 'x':
***************
*** 301,307 ****
  		    while((ch = getchar()) != EOF && ch != '\n')
  			special[i++] = ch;
  		    special[i] = '\0';
! 		    DBP((D_CAT, "Command %s\n", special));
  		    i = sscanf(special, "%s %s %s %s", cmd, a1, a2, a3);
  		    if (i <= 0) {
  			fprintf(stderr, "%s: bad x command: %s\n",
--- 297,303 ----
  		    while((ch = getchar()) != EOF && ch != '\n')
  			special[i++] = ch;
  		    special[i] = '\0';
! 		    DBP((D_CAT, "D x: %s\n", special));
  		    i = sscanf(special, "%s %s %s %s", cmd, a1, a2, a3);
  		    if (i <= 0) {
  			fprintf(stderr, "%s: bad x command: %s\n",
***************
*** 320,326 ****
  				exit(1);
  			    }
  			    sprintf(special, "F%s%s", a1, a2);
! 			    DBP((D_CAT, "FONT %s %s\n", a1, a2));
  
  			    if (be->befontsel)
  				(*be->befontsel)(a1,a2);
--- 316,322 ----
  				exit(1);
  			    }
  			    sprintf(special, "F%s%s", a1, a2);
! 			    DBP((D_CAT, "D load: %s %s\n", a1, a2));
  
  			    if (be->befontsel)
  				(*be->befontsel)(a1,a2);
***************
*** 340,358 ****
  				exit(1);
  			    }
  			    halfdtres = indtres / 2;
! 			    DBP((D_CAT, "RES %d\n", indtres));
  			    break;
  			case 'i':
! 			    DBP((D_CAT, "INIT\n"));
  			    if (be->beprolog)
  				(*be->beprolog)();
  			    resetState();
  			    break;
  			case 't':
! 			    DBP((D_CAT, "TRAILER\n"));
  			    break;
  			case 's':
! 			    DBP((D_CAT, "STOP\n"));
  			    return;
  			case 'T':
  			    if (i != 2) {
--- 336,354 ----
  				exit(1);
  			    }
  			    halfdtres = indtres / 2;
! 			    DBP((D_CAT, "D res: %d\n", indtres));
  			    break;
  			case 'i':
! 			    DBP((D_CAT, "D init\n"));
  			    if (be->beprolog)
  				(*be->beprolog)();
  			    resetState();
  			    break;
  			case 't':
! 			    DBP((D_CAT, "D trailer\n"));
  			    break;
  			case 's':
! 			    DBP((D_CAT, "D stop\n"));
  			    return;
  			case 'T':
  			    if (i != 2) {
***************
*** 362,368 ****
  			    }
  			    device = mustmalloc(strlen(a1) + 1, "device");
  			    strcpy(device, a1);
! 			    DBP((D_CAT, "TYPE %s\n", a1));
  			    break;
  			case 'X':
  			    switch(a1[0]) {
--- 358,364 ----
  			    }
  			    device = mustmalloc(strlen(a1) + 1, "device");
  			    strcpy(device, a1);
! 			    DBP((D_CAT, "D type: %s\n", a1));
  			    break;
  			case 'X':
  			    switch(a1[0]) {
***************
*** 384,394 ****
  		break;
  	    case 'H':
  		xpos = getnum();
! 		DBP((D_CAT, "Hor: %d\n", xpos));
  		break;
  	    case 'h':
  		xpos += getnum();
! 		DBP((D_CAT, "Hor (inc): %d\n", xpos));
  		break;
  	    case 'V':
  #ifdef	OPT
--- 380,390 ----
  		break;
  	    case 'H':
  		xpos = getnum();
! 		DBP((D_CAT, "D H: %d\n", xpos));
  		break;
  	    case 'h':
  		xpos += getnum();
! 		DBP((D_CAT, "D Hi: %d\n", xpos));
  		break;
  	    case 'V':
  #ifdef	OPT
***************
*** 395,401 ****
  		canonflush();
  #endif
  		ypos = getnum();
! 		DBP((D_CAT, "Ver: %d\n", ypos));
  		break;
  	    case 'v':
  #ifdef	OPT
--- 391,397 ----
  		canonflush();
  #endif
  		ypos = getnum();
! 		DBP((D_CAT, "D V: %d\n", ypos));
  		break;
  	    case 'v':
  #ifdef	OPT
***************
*** 402,413 ****
  		canonflush();
  #endif
  		ypos += getnum();
! 		DBP((D_CAT, "Ver (inc): %d\n", ypos));
  		break;
  		break;
  	    case 'p':
  		ch = getnum();
! 		DBP((D_CAT, "Page %d\n", ch));
  		if (be->bepage)
  		    (*be->bepage)();
  		break;
--- 398,409 ----
  		canonflush();
  #endif
  		ypos += getnum();
! 		DBP((D_CAT, "D Vi: %d\n", ypos));
  		break;
  		break;
  	    case 'p':
  		ch = getnum();
! 		DBP((D_CAT, "D page: %d\n", ch));
  		if (be->bepage)
  		    (*be->bepage)();
  		break;
***************
*** 435,441 ****
  		while((ch = getchar()) != EOF && ch != '\n')
  		    special[i++] = ch;
  		special[i] = '\0';
! 		DBP((D_CAT, "#/D/! %s\n", special));
  
  		switch(cmd) {
  		    case '#':
--- 431,437 ----
  		while((ch = getchar()) != EOF && ch != '\n')
  		    special[i++] = ch;
  		special[i] = '\0';
! 		DBP((D_CAT, "D passthru: %s\n", special));
  
  		switch(cmd) {
  		    case '#':
***************
*** 471,478 ****
  			    for (i = 0; i < ct; i++)
  				values[i] = DIT2CAT(values[i]);
  
! DBP((D_CAT, "Draw: xpos,ypos,opcode,ct,special = %d,%d,%d,%d,%s\n",
!     xpos, ypos, opcode, ct, special));
  
  			if (be->bedraw)
  			    (*be->bedraw)(DIT2CAT(xpos), DIT2CAT(ypos),
--- 467,474 ----
  			    for (i = 0; i < ct; i++)
  				values[i] = DIT2CAT(values[i]);
  
! 			DBP((D_CAT, "D D: xpos,ypos,opcode,ct,special = %d,%d,%d,%d,%s\n",
! 			    xpos, ypos, opcode, ct, special));
  
  			if (be->bedraw)
  			    (*be->bedraw)(DIT2CAT(xpos), DIT2CAT(ypos),
***************
*** 500,506 ****
      while((c = getchar()) != EOF && isdigit(c))
  	ret = ret * 10 + (c - '0');
      ungetc(c, stdin);
-     DBP((D_CAT, "Getnum: %d\n", ret));
      return(ret);
  }
  
--- 496,501 ----
***************
*** 508,514 ****
  int x, y;
  int font, points, troffChar;
  register char *sequence; {
!     DBP((D_CAT, "x,y: %d/%d -> ", x, y));
      x = DIT2CAT(x);
      y = DIT2CAT(y);
      DBP((D_CAT, "%d/%d (font,points,ch = %d,%d,%d)\n", x, y, font, points,
--- 503,509 ----
  int x, y;
  int font, points, troffChar;
  register char *sequence; {
!     DBP((D_CAT, "D E: x,y: %d/%d -> ", x, y));
      x = DIT2CAT(x);
      y = DIT2CAT(y);
      DBP((D_CAT, "%d/%d (font,points,ch = %d,%d,%d)\n", x, y, font, points,
***************
*** 526,528 ****
--- 521,524 ----
  #endif
  }
  #endif
+ 
Index: ./troff2.c
*** /tmp/PATCHold/./troff2.c	Wed Jan 13 02:18:35 1993
--- ./troff2.c	Wed Jan 13 02:18:37 1993
***************
*** 12,18 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)troff2.c: 2.27 Copyright 92/08/09 23:41:28 Chris Lewis";
  #endif
  
  #define	ESC	0x80
--- 12,18 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)troff2.c: 2.29 Copyright 92/12/20 23:07:29 Chris Lewis";
  #endif
  
  #define	ESC	0x80
***************
*** 47,52 ****
--- 47,53 ----
  #define	CTOINT(val,sig)	((~c)&sig)
  
  int pagelength;
+ int pagewidth;
  int pageoffset;
  int pageyoffset;
  
***************
*** 66,73 ****
  char *device = {"alw"};
  char **prologs = (char **) NULL;
  char *pstrailer = "\004";
- #define	PROCHUNK	20
- int procount;
  
  #ifdef	L_cuserid
  #define	nmMAX	L_cuserid
--- 67,72 ----
***************
*** 90,98 ****
  int	sizescale;
  #endif
  
- extern char *realloc();
  
! #define	OPTLIST	"d:O:Y:T:VD:l:MR:P::zp:W:ZNnSG:g:"
  
  /*	On 386/ix 1.0.6 profiling has a bug in it that leaves
  	two extra longs on the stack between the stack frame and
--- 89,96 ----
  int	sizescale;
  #endif
  
  
! #define	OPTLIST	"d:O:Y:T:VD:l:w:MR:P::zp:W:ZNnSG:g:"
  
  /*	On 386/ix 1.0.6 profiling has a bug in it that leaves
  	two extra longs on the stack between the stack frame and
***************
*** 118,123 ****
--- 116,122 ----
  
  	extern int getopt();
  	extern char *optarg;
+ 	extern void insprolog();
  
  #ifdef	L_cuserid
  
***************
*** 136,145 ****
--- 135,147 ----
  	    sprintf(username, "uid=%d", getuid());
  
  	/* some compilers complain about floating point in initializers... */
+ 
  	pagelength = DEFPL * TROFFRESOLUTION;
+ 	pagewidth = DEFPW * TROFFRESOLUTION;
  	pageoffset = DEFOFF * TROFFRESOLUTION;
  	pageyoffset = DEFYOFF * TROFFRESOLUTION;
  
+ 
  	progname = strrchr(argv[0], '/');
  	if (progname)
  	    progname++;
***************
*** 189,206 ****
  		    break;
  #endif
  		case 'P':
! 		    if (!prologs) {
! 			prologs = (char **) mustmalloc(PROCHUNK * sizeof(char*),
! 			    "prologs");
! 			procount = 0;
! 		    }
! 		    prologs[procount++] = optarg;
! 		    /* insert the null */
! 		    if ((procount % PROCHUNK) == 0) {
! 			prologs = (char **) realloc((char *) prologs,
! 			    (procount + PROCHUNK) * sizeof(char *));
! 		    }
! 		    prologs[procount] = (char *) NULL;
  		    break;
  		case 'p':
  		    printer = optarg;
--- 191,197 ----
  		    break;
  #endif
  		case 'P':
! 		    insprolog(optarg);
  		    break;
  		case 'p':
  		    printer = optarg;
***************
*** 276,287 ****
  			exit(1);
  		    }
  		    break;
  		case '?':
  		default:
  		    usage();
  		    exit(1);
  	    }
! 	
  #ifdef	OPT
  	if (dtopt)
  	    optimize = 1;
--- 267,286 ----
  			exit(1);
  		    }
  		    break;
+ 		case 'w':
+ 		    pagewidth = calc(optarg);
+ 		    if (pagewidth == 0) {
+ 			fprintf(stderr, "%s: Bad pagewidth %s\n", progname,
+ 			    optarg);
+ 			exit(1);
+ 		    }
+ 		    break;
  		case '?':
  		default:
  		    usage();
  		    exit(1);
  	    }
! 
  #ifdef	OPT
  	if (dtopt)
  	    optimize = 1;
***************
*** 303,313 ****
  
  	loadfont(be->bestdfont, be->besymfont);
  #ifdef	DEBUG
! 	if (debug & D_SPEC) {
! 	    for (c = 0; c < procount; c++) {
! 		DBP((D_SPEC, "Prolog %d: %s\n", c, prologs[c]));
! 	    }
! 	}
  #endif
  
  	if (dumpflag) {
--- 302,308 ----
  
  	loadfont(be->bestdfont, be->besymfont);
  #ifdef	DEBUG
! 	dumpprologs();
  #endif
  
  	if (dumpflag) {
Index: ./defs.h
*** /tmp/PATCHold/./defs.h	Wed Jan 13 02:18:52 1993
--- ./defs.h	Wed Jan 13 02:18:54 1993
***************
*** 9,15 ****
   */
  
  /*	Official Release and Patch level:	*/
! #define	T2VERSION	"@(#)PSROFF Copyright 92/10/30 Chris Lewis - R3 PL14"
  
  /*	Configuration parameters:
   */
--- 9,15 ----
   */
  
  /*	Official Release and Patch level:	*/
! #define	T2VERSION	"@(#)PSROFF Copyright 93/01/03 Chris Lewis - R3 PL15"
  
  /*	Configuration parameters:
   */
***************
*** 81,86 ****
--- 81,93 ----
  #define	HEADERSIZE 0	/* size of header in bytes */
  #undef	ASCIIWIDTHS	/* For RISC/Ultrix */
  
+ /* If you have malloc.h, leave this undefined.  If you don't have a
+    malloc.h, define it to be the base type returned by malloc() and
+    realloc().  Ie: if your malloc returns (char *), set MALLRET to char.
+  */
+ 
+ #undef MALLRET
+ 
  /* What do your CAT codes look like?
  
     If BSDHACK defined, the code to magnify the next lead by 64 replaces the
***************
*** 166,178 ****
  #define SPACEOPT	/* hyperoptimization */
  #define OPTSIZ 200	/* size of optimizer buffer */
  
! #define	DEFPL  11	/* Default page length (11 inches).
! 			   DO NOT change unless you absolutely HAVE to.
! 			   You should only need to change this if you
! 			   desire your printer to use something different
! 			   as default.  If so, you'll HAVE to change
! 			   your macro package to agree on the default - RT
! 			   owners take note! (the man macros are wrong) */
  
  #define	DEFOFF 0.5	/* Default page offset.  DO NOT change unless you
  			   absolutely HAVE to.  You should only need this
--- 173,186 ----
  #define SPACEOPT	/* hyperoptimization */
  #define OPTSIZ 200	/* size of optimizer buffer */
  
! #define	DEFPL  11	/* Default page length (11 inches). */
! #define	DEFPW  8.5	/* Default page length (8.5 inches).
! 			   Don't change these.  The PAPER mechanism
! 			   in psroff (with -l/-w options to troff2ps)
! 			   should handle everything the backend needs
! 			   to know).  Convincing the macros to use
! 			   different sizes is a different story.
! 			   -rL works with -mm */
  
  #define	DEFOFF 0.5	/* Default page offset.  DO NOT change unless you
  			   absolutely HAVE to.  You should only need this
***************
*** 246,251 ****
--- 254,265 ----
  #include <stdio.h>
  #include <ctype.h>
  
+ #ifndef MALLRET
+ #include <malloc.h>
+ #else
+ extern MALLRET *malloc(), *realloc();
+ #endif
+ 
  #ifdef BSD
  #include <strings.h>
  #define	strchr	index
***************
*** 362,368 ****
  
  extern int symidx;		/* index of symbol font */
  
! #define	INTFONTS	10	/* maximum number of builtin fonts */
  
  extern struct fonttable fonttable[MAXFONTS+1];
  extern struct fonttable *xlatetable[INTFONTS];
--- 376,386 ----
  
  extern int symidx;		/* index of symbol font */
  
! #define	INTFONTS	15	/* Max simultaneously mounted fonts.
! 				   Don't put more than INTFONTS-1 fonts
! 				   into a ditroff DESC file.  Most
! 				   DWB's have a compiled-in max of 10
! 				   (max DESC value of 9) */
  
  extern struct fonttable fonttable[MAXFONTS+1];
  extern struct fonttable *xlatetable[INTFONTS];
***************
*** 391,396 ****
--- 409,415 ----
  extern int pageoffset;
  extern int pageyoffset;
  extern int pagelength;
+ extern int pagewidth;
  extern int pagePending;
  int dtopt;
  
Index: ./Makefile
*** /tmp/PATCHold/./Makefile	Wed Jan 13 02:19:13 1993
--- ./Makefile	Wed Jan 13 02:19:24 1993
***************
*** 7,13 ****
  #    Function: Upper level makefile; configuration options.
  #
  #
! #ident  "@(#)Makefile: 2.35 Copyright 92/10/30 02:28:20 Chris Lewis"
  
  #	If you're not sure whether you have a System V make, leave
  #	this alone, and run the make anyways.  If it dies horribly
--- 7,13 ----
  #    Function: Upper level makefile; configuration options.
  #
  #
! #ident  "@(#)Makefile: 2.37 Copyright 93/01/10 10:51:43 Chris Lewis"
  
  #	If you're not sure whether you have a System V make, leave
  #	this alone, and run the make anyways.  If it dies horribly
***************
*** 52,57 ****
--- 52,67 ----
  #	is really wierd.
  RTMACDIR = /usr/lib/tmac
  
+ #	Default paper size: valid are: letter, legal, executive, a4,
+ #	com-10, monarch, c5, dl.  Note: it is up to you to get troff
+ #	to get the right page length.  This only makes arrangements with
+ #	the backend.  With -mm, -rL will do the trick.  Other macro
+ #	packages use other arrangements...
+ PAPER	= letter
+ 
+ #	Default output orientation
+ ORIENTATION = portrait
+ 
  #	upper level man directory, with subdirectories man1, man2 etc.
  #	Could be /usr/man/mann, /usr/man/manl, /usr/man/man1, /usr/man/l_man/man1
  MANDIR	= /usr/man/mann
***************
*** 203,208 ****
--- 213,220 ----
  		     -e 's;%%SFP2PK%%;$(SFP2PK);' \
  		     -e 's;%%PKFONTS%%;$(PKFONTS);' \
  		     -e 's;%%NEWFONTS%%;$(NEWFONTS);' \
+ 		     -e 's;%%PAPER%%;$(PAPER);' \
+ 		     -e 's;%%ORIENTATION%%;$(ORIENTATION);' \
  		     -e 's;%%T2DIR%%;$(T2DIR);' \
  		     -e 's;%%MAKEDEV%%;$(MAKEDEV);' \
  		     -e 's;%%PERL%%;$(PERL);' \
***************
*** 289,302 ****
  	if [ "$$files" != 'fonts.lj/*.pk' ] ; \
  	then \
  	    cp fonts.lj/*.pk $(LJF) ; \
- 	    chmod 644 $(LJF)/* ; \
  	fi
  	$(IGNORESH) files=`echo fonts.lj/*.sfp` ; \
  	if [ "$$files" != 'fonts.lj/*.sfp' ] ; \
  	then \
  	    cp fonts.lj/*.sfp $(LJF) ; \
- 	    chmod 644 $(LJF)/* ; \
  	fi
  	@echo "don't panic if the next line dies"
  	$(IGNORESH) test -z "$(PKFONTS)" -o ! -d "$(NEWFONTS)" \
  	    || cp $(NEWFONTS)/* $(LJF)
--- 301,313 ----
  	if [ "$$files" != 'fonts.lj/*.pk' ] ; \
  	then \
  	    cp fonts.lj/*.pk $(LJF) ; \
  	fi
  	$(IGNORESH) files=`echo fonts.lj/*.sfp` ; \
  	if [ "$$files" != 'fonts.lj/*.sfp' ] ; \
  	then \
  	    cp fonts.lj/*.sfp $(LJF) ; \
  	fi
+ 	cd $(LJF); chmod 644 *
  	@echo "don't panic if the next line dies"
  	$(IGNORESH) test -z "$(PKFONTS)" -o ! -d "$(NEWFONTS)" \
  	    || cp $(NEWFONTS)/* $(LJF)
***************
*** 372,377 ****
--- 383,389 ----
  lj.o:	defs.h lj.h pkc.h pk.h
  ljdraw.o:	defs.h lj.h
  lj3draw.o:	defs.h lj.h
+ pkscale.o:	defs.h pk.h
  
  pk.o:	defs.h pk.h pkc.h
  pkc.o:	defs.h pk.h pkc.h
***************
*** 412,419 ****
  	echo ".ds pt \"($(TTYPE))" >> TEST1
  	echo ".ds 2d \"`date`" >> TEST1
  	echo ".sp" > TEST2
! 	echo ".ps 10" >> TEST2
! 	echo ".vs 12p" >> TEST2
  	echo ".ad 1" >> TEST2
  	echo "DEFS.H DEFINITIONS:" >> TEST2
  	sed -n -e '/Edit no more/q' \
--- 424,431 ----
  	echo ".ds pt \"($(TTYPE))" >> TEST1
  	echo ".ds 2d \"`date`" >> TEST1
  	echo ".sp" > TEST2
! 	echo ".ps 9" >> TEST2
! 	echo ".vs 10p" >> TEST2
  	echo ".ad 1" >> TEST2
  	echo "DEFS.H DEFINITIONS:" >> TEST2
  	sed -n -e '/Edit no more/q' \
Index: ./psroff.S
*** /tmp/PATCHold/./psroff.S	Wed Jan 13 02:19:56 1993
--- ./psroff.S	Wed Jan 13 02:19:57 1993
***************
*** 7,17 ****
  #
  #	Specs:		troff2ps driver
  #
! #ident  "@(#)psroff.sh: 2.23 Copyright 92/08/09 23:44:43 Chris Lewis"
  
  LIBDIR="%%LIBDIR%%"
  FONTDIR="%%FONTDIR%%"
  
  term=false
  fail=false
  if [ -n "$PSROFF" ]
--- 7,20 ----
  #
  #	Specs:		troff2ps driver
  #
! #ident  "@(#)psroff.sh: 2.28 Copyright 93/01/10 01:20:52 Chris Lewis"
  
  LIBDIR="%%LIBDIR%%"
  FONTDIR="%%FONTDIR%%"
+ paper=%%PAPER%%
+ orientation=%%ORIENTATION%%
  
+ xlpargs=
  term=false
  fail=false
  if [ -n "$PSROFF" ]
***************
*** 27,33 ****
      fi
  fi
  copies=1
! for i in $*
  do
      case $i in
  	-F)
--- 30,36 ----
      fi
  fi
  copies=1
! for i in "$@"
  do
      case $i in
  	-F)
***************
*** 58,63 ****
--- 61,86 ----
  	-m* | -c*)
  	    macros="$macros `echo $i | sed -e 's/-[cm]//'`"
  	    ;;
+ 	-pS*)
+ 	    case $i in
+ 		-pSlet*) paper=letter ;;
+ 		-pSleg*) paper=legal ;;
+ 		-pSe*) paper=executive ;;
+ 		-pSa4) paper=a4 ;;
+ 		-pSco*) paper='com-10' ;;
+ 		-pSm*) paper=monarch ;;
+ 		-pSc5) paper=c5 ;;
+ 		-pSd*) paper=dl ;;
+ 		*) echo "$0: Illegal paper selection: $i" >&2 ; exit 1 ;;
+ 	    esac
+ 	    ;;
+ 	-pO*)
+ 	    case $i in
+ 		-pOl*) orientation=landscape ;;
+ 		-pOp*) orientation=portrait ;;
+ 		*) echo "$0: Illegal orientation: $i" >&2 ; exit 1 ;;
+ 	    esac
+ 	    ;;
  	-)
  	    files="$files $i"
  	    ;;
***************
*** 78,83 ****
--- 101,109 ----
  	-g*)
  	    garg=$i
  	    ;;
+ 	-l*)
+ 	    xlpargs="$xlpargs `echo $i | sed 's/^-l//'`"
+ 	    ;;
  	-*)
  	    args="$args $i"
  	    ;;
***************
*** 127,132 ****
--- 153,180 ----
      echo "$0: Can't find psrofflib in ., lib, or $LIBDIR/lib" >&2
      exit 1
  fi
+ case "$paper-$orientation" in
+     letter-landscape) pctrl="-l8.50i -w11.00i -PXlandscape" ;;
+     letter-portrait) pctrl="-l11.00i -w8.50i -PXportrait" ;;
+     legal-landscape) pctrl="-l8.50i -w14.00i -PXlandscape" ;;
+     legal-portrait) pctrl="-l14.00i -w8.50i -PXportrait" ;;
+     executive-landscape) pctrl="-l7.25i -w10.50i -PXlandscape" ;;
+     executive-portrait) pctrl="-l10.50i -w7.25i -PXportrait" ;;
+     a4-landscape) pctrl="-l8.27i -w11.69i -PXlandscape" ;;
+     a4-portrait) pctrl="-l11.69i -w8.27i -PXportrait" ;;
+     com-10-landscape) pctrl="-l4.12i -w9.50i -PXlandscape" ;;
+     com-10-portrait) pctrl="-l9.50i -w4.12i -PXportrait" ;;
+     monarch-landscape) pctrl="-l3.87i -w7.50i -PXlandscape" ;;
+     monarch-portrait) pctrl="-l7.50i -w3.87i -PXportrait" ;;
+     c5-landscape) pctrl="-l6.38i -w9.01i -PXlandscape" ;;
+     c5-portrait) pctrl="-l9.01i -w6.38i -PXportrait" ;;
+     dl-landscape) pctrl="-l4.33i -w8.66i -PXlandscape" ;;
+     dl-portrait) pctrl="-l8.66i -w4.33i -PXportrait" ;;
+     *)
+ 	echo "$0: Can't find $paper-$orientation in permissible values" >&2
+ 	exit 1
+ 	;;
+ esac
  
  F=''
  #	If your system has no awk (or a busted one), you may have to
***************
*** 302,307 ****
--- 350,356 ----
  if $term
  then
      lparg='| cat'
+     xlpargs=
  fi
  
  #	Okay, let's DO it!
***************
*** 336,342 ****
  	$troff $otroff $widtharg $args $ml - 2>&1
      else
  	$troff $widtharg $args $ml -
!     fi | eval "$t2 $t2arg $lparg"
      rc=$?
  
  fi
--- 385,391 ----
  	$troff $otroff $widtharg $args $ml - 2>&1
      else
  	$troff $widtharg $args $ml -
!     fi | eval "$t2 $pctrl $t2arg $lparg $xlpargs"
      rc=$?
  
  fi
Index: ./lj.c
*** /tmp/PATCHold/./lj.c	Wed Jan 13 02:20:17 1993
--- ./lj.c	Wed Jan 13 02:20:19 1993
***************
*** 32,38 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)lj.c: 2.13 Copyright 92/11/26 19:43:30 Chris Lewis";
  #endif
  
  struct troff2befont ljStdFont[108] = {
--- 32,38 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)lj.c: 2.15 Copyright 92/12/20 23:06:02 Chris Lewis";
  #endif
  
  struct troff2befont ljStdFont[108] = {
***************
*** 306,312 ****
  ljPage() {
      if (!pagePending) {
  	emitrast();
! 	printf("\033&l0H");
      }
      pagePending = 1;
  }
--- 306,312 ----
  ljPage() {
      if (!pagePending) {
  	emitrast();
! 	putchar('\f');
      }
      pagePending = 1;
  }
***************
*** 798,803 ****
--- 798,805 ----
      sprintf(LJF, "%s/lj", LIBDIR);
  #endif
  
+     setparams(LJRESOLUTION);
+ 
      /* to ensure that the strings are long enough for indexing and
         are sufficiently initialized */
  
***************
*** 897,976 ****
  	Strip out line termination.
  */
  
  ljXlate(library)
  FILE *library; {
!     char buf[4];
!     int c, i;
!     c = getc(library);
!     while(!feof(library)) {
  
!       nextchar:
! 
! 	switch(c) {
! 	    case '%':
! 		/* strip from percent sign to end of line */
! 		/* If line is %%%<something> pass onto interp */
! 		if (((c = getc(library)) == '%') &&
! 		    ((c = getc(library)) == '%')) {
! 		    char buf2[4];
! 		    sprintf(buf2, ".%s", be->bename);
! 		    fgets(buf, strlen(buf), library);
! 		    interp(buf, ljXlate, buf2);
! 		    break;
! 		}
! 		while ((c = getc(library)) != EOF && c != '\n');
! 		break;
! 	    case '\n':	/* throw away real newlines. */
! 		break;
! 	    case '\\':
! 		c = getc(library);
! 		if (c == 'x' || c == 'X') {
! 		    i = 0;
! 		    while(1) {
! 			c = getc(library);
! 
! 			if (c == EOF || !((c >= '0' && c <= '9') ||
! 					  (c >= 'A' && c <= 'F') ||
! 					  (c >= 'a' && c <= 'f')))
! 			    goto nextchar;
! 
! 			buf[i++] = c;
! 			if (i == 2) {
! 			    buf[i] = '\0';
! 			    sscanf(buf, "%x", &i);
! 			    putchar(i);
! 			    i = 0;
! 			}
  		    }
! 		} else {
! 		    buf[0] = c;
! 		    i = 1;
! 		    while(1) {
! 			c = getc(library);
! 			if (c == EOF || c < '0' || c > '7')
! 			    goto nextchar;
! 			buf[i++] = c;
! 			if (i == 3) {
! 			    buf[i] = '\0';
! 			    sscanf(buf, "%o", &i);
! 			    putchar(i);
! 			    i = 0;
  			}
  		    }
- 		}
  		/* NOTREACHED */
  
! 	    case ' ': case '\t':
! 		break;
! 
! 	    case EOF:
! 		fprintf(stderr, "%s: Unexpected eof on ljlib\n", progname);
! 		break;
  
! 	    default:
! 		putchar(c);
  	}
! 	c = getc(library);
      }
  }
  
--- 899,989 ----
  	Strip out line termination.
  */
  
+ #define mgetc(p) (*(p+1) ? *(++p): EOF)
  ljXlate(library)
  FILE *library; {
!     char buf[5];
!     char line[512], *p;
!     int state = 0;
!     register int c;
!     int i;
  
!     while(fgets(line, sizeof(line), library)) {
! 
! 	if (!preproc(line, &state))
! 	    continue;
! 
! 	p = line;
! 
! 	while((c = *p++) != '\0') {
! 
! 	  nextchar:
! 
! 	    switch(c) {
! 		case '%':
! 		    /* strip from percent sign to end of line */
! 		    /* If line is %%%<something> pass onto interp */
! 		    if ( *p == '%' && *(p+1) == '%' ) {
! 			char buf2[14];
! 			sprintf(buf2, ".%s", be->bename);
! 			interp(p+2, ljXlate, buf2);
! 		    }
! 		    goto nextline;
! 		case '\\':
! 		    c = *p++;
! 
! 		    if (c == '\\') {
! 			putchar(c);
! 			continue;
  		    }
! 
! 		    if (c == 'x' || c == 'X') {
! 			i = 0;
! 			while(1) {
! 			    c = *p++;
! 
! 			    if (!c || !((c >= '0' && c <= '9') ||
! 				       (c >= 'A' && c <= 'F') ||
! 				       (c >= 'a' && c <= 'f')))
! 				goto nextchar;
! 
! 			    buf[i++] = c;
! 			    if (i == 2) {
! 				buf[i] = '\0';
! 				sscanf(buf, "%x", &i);
! 				putchar(i);
! 				i = 0;
! 			    }
! 			}
! 		    } else {
! 			buf[0] = c;
! 			i = 1;
! 			while(1) {
! 			    c = *p++;
! 			    if (!c || c < '0' || c > '7')
! 				goto nextchar;
! 			    buf[i++] = c;
! 			    if (i == 3) {
! 				buf[i] = '\0';
! 				sscanf(buf, "%o", &i);
! 				putchar(i);
! 				i = 0;
! 			    }
  			}
  		    }
  		/* NOTREACHED */
  
! 		case ' ': case '\t': case '\n':
! 		    break;
  
! 		default:
! 		    putchar(c);
! 		    break;
! 	    }
  	}
! 
!       nextline:
! 	;
      }
  }
  
Index: ./ljdraw.c
*** /tmp/PATCHold/./ljdraw.c	Wed Jan 13 02:20:39 1993
--- ./ljdraw.c	Wed Jan 13 02:20:41 1993
***************
*** 32,41 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)ljdraw.c: 1.2 Copyright 92/11/26 19:39:27 Chris Lewis";
  #endif
  
! static int ljLine();
  
  /*	Do ditroff drawing command in s from origX,origY.
  	If opcode 0 just moveto
--- 32,42 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)ljdraw.c: 1.6 Copyright 93/01/10 00:40:10 Chris Lewis";
  #endif
  
! static int ljLine(), ljPos(), lineseg();
! int asetbit();
  
  /*	Do ditroff drawing command in s from origX,origY.
  	If opcode 0 just moveto
***************
*** 537,543 ****
  /*	the fill range 0..1000 selects one of these 8
  	rows.  Each row describes a 8x8 fill pattern.
   */
! static char fillpat[9][8] = {
      { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff },
      { 0xc3, 0xa5, 0x24, 0xe9, 0xe9, 0x24, 0xa5, 0xc3 },
      { 0xe7, 0xc3, 0x24, 0x3c, 0x3c, 0x24, 0xc3, 0xe7 },
--- 538,544 ----
  /*	the fill range 0..1000 selects one of these 8
  	rows.  Each row describes a 8x8 fill pattern.
   */
! static unsigned char fillpat[9][8] = {
      { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff },
      { 0xc3, 0xa5, 0x24, 0xe9, 0xe9, 0x24, 0xa5, 0xc3 },
      { 0xe7, 0xc3, 0x24, 0x3c, 0x3c, 0x24, 0xc3, 0xe7 },
***************
*** 562,568 ****
      register int t, td;
      static int lastind = -1;
      register int ind = fill/125;
!     register char fp = fillpat[ind][y&7];
  
  #ifdef DEBUG
      if (lastind != ind) {
--- 563,569 ----
      register int t, td;
      static int lastind = -1;
      register int ind = fill/125;
!     register unsigned char fp = fillpat[ind][y&7];
  
  #ifdef DEBUG
      if (lastind != ind) {
***************
*** 669,675 ****
  
  /* only supports drawing resolution of 300 at the moment. */
  #define DRAWRES	300
- #define BYTESPERLINE (8 * DRAWRES) / 8
  #define RESMULT (LJRESOLUTION / DRAWRES)
  #define ESCLEN 25
  
--- 670,675 ----
***************
*** 705,719 ****
      return(end - start);
  }
  
  emitrast()
  {
      int bperline;
-     int numx = BYTESPERLINE * 8;
-     int numy = pagelength;
      register char *ip, *lineanch, *nip;
      register currow, bcount;
      int linecount = 0;
  
      bperline = ((numx + 7) / 8);
  
      if (!thispage)
--- 705,721 ----
      return(end - start);
  }
  
+ static int numx, numy;
  emitrast()
  {
      int bperline;
      register char *ip, *lineanch, *nip;
      register currow, bcount;
      int linecount = 0;
  
+     numx = pagewidth * LJRESOLUTION/TROFFRESOLUTION;
+     numy = pagelength * LJRESOLUTION/TROFFRESOLUTION;
+ 
      bperline = ((numx + 7) / 8);
  
      if (!thispage)
***************
*** 753,774 ****
  asetbit(x, y)
  register int x, y; {
      thispage = 1;
!     if (y < 0 || y > pagelength) {
! 	/*fprintf(stderr, "y (%d) too big or small (0..%d)\n", y, pagelength);*/
  	return;
      }
!     if (x < 0 || x > BYTESPERLINE * 8) {
! 	/*fprintf(stderr, "x (%d) too big or small (0..%d)\n", x, BYTESPERLINE*8);*/
  	return;
      }
      if (!ljraster) {
! 	ljraster = (char **) mustmalloc(pagelength * sizeof(char *),
  	    "ljraster pointers");
! 	clrarray(ljraster, pagelength * sizeof(char *));
      }
      if (!ljraster[y]) {
! 	ljraster[y] = (char *) mustmalloc(BYTESPERLINE, "ljraster line");
! 	clrarray(ljraster[y], BYTESPERLINE);
      }
      ljraster[y][x >> 3] |= (0x80 >> (x & 0x7));
  }
--- 755,776 ----
  asetbit(x, y)
  register int x, y; {
      thispage = 1;
!     if (y < 0 || y >= numy) {
! 	/*fprintf(stderr, "y (%d) too big or small (0..%d)\n", y, numy);*/
  	return;
      }
!     if (x < 0 || x >= numx) {
! 	/*fprintf(stderr, "x (%d) too big or small (0..%d)\n", x, numx);*/
  	return;
      }
      if (!ljraster) {
! 	ljraster = (char **) mustmalloc(numy * sizeof(char *),
  	    "ljraster pointers");
! 	clrarray(ljraster, numy * sizeof(char *));
      }
      if (!ljraster[y]) {
! 	ljraster[y] = (char *) mustmalloc(numx/8, "ljraster line");
! 	clrarray(ljraster[y], numx/8);
      }
      ljraster[y][x >> 3] |= (0x80 >> (x & 0x7));
  }
Index: ./debug.c
*** /tmp/PATCHold/./debug.c	Wed Jan 13 02:20:53 1993
--- ./debug.c	Wed Jan 13 02:20:54 1993
***************
*** 11,17 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)debug.c: 2.7 Copyright 92/01/23 14:24:37 Chris Lewis";
  #endif
  
  #ifdef	DEBUG
--- 11,17 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)debug.c: 2.8 Copyright 92/12/04 23:18:42 Chris Lewis";
  #endif
  
  #ifdef	DEBUG
***************
*** 104,110 ****
  mustmalloc(n, msg)
  int n;
  char *msg; {
-     extern char *malloc();
      register char *p = malloc((unsigned) n);
      if (!p) {
  	fprintf(stderr, "%s: Out of space! (requesting %d bytes, key: %s)\n",
--- 104,109 ----
Index: ./lj3draw.c
*** /tmp/PATCHold/./lj3draw.c	Wed Jan 13 02:21:02 1993
--- ./lj3draw.c	Wed Jan 13 02:21:03 1993
***************
*** 29,35 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)lj3draw.c: 1.3 Copyright 92/11/26 19:42:32 Chris Lewis";
  #endif
  
  #define to_deg(a)	((180.0/M_PI) * (a))
--- 29,35 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)lj3draw.c: 1.5 Copyright 92/12/22 02:16:58 Chris Lewis";
  #endif
  
  #define to_deg(a)	((180.0/M_PI) * (a))
***************
*** 82,88 ****
--- 82,92 ----
      double w, t1, t2, t3;
      char *command;
      Pt *p;
+     static xscale, yscale = 0;
+     extern char *findval();
  
+     xscale = pagewidth * LJRESOLUTION / TROFFRESOLUTION;
+     yscale = pagelength * LJRESOLUTION / TROFFRESOLUTION;
  
      /* map absolute beginning position */
      origX = TROFF2LJX(origX);
***************
*** 198,206 ****
  	    /* Use 'CI r;' for ellipse, 'WG r,0,360;' for filled ellipse */
  	    ENTER_HPGL2;
  	    printf("PU;PR%d,0;SC0,%d,0,%d;", numbers[0]/2, 
! 		(int)(XSCALE * ((float)numbers[1]/numbers[0])), YSCALE);
  	    printf("%s%d%s;SC0,%d,0,%d", command, numbers[1]/2,
! 		(opcode == 'E' ? ",0,360" : ""), XSCALE, YSCALE);
  	    EXIT_HPGL2;
  	    break;
  	case 'p':
--- 202,210 ----
  	    /* Use 'CI r;' for ellipse, 'WG r,0,360;' for filled ellipse */
  	    ENTER_HPGL2;
  	    printf("PU;PR%d,0;SC0,%d,0,%d;", numbers[0]/2, 
! 		(int)(xscale * ((float)numbers[1]/numbers[0])), yscale);
  	    printf("%s%d%s;SC0,%d,0,%d", command, numbers[1]/2,
! 		(opcode == 'E' ? ",0,360" : ""), xscale, yscale);
  	    EXIT_HPGL2;
  	    break;
  	case 'p':
Index: ./pkscale.c
*** /tmp/PATCHold/./pkscale.c	Wed Jan 13 02:21:18 1993
--- ./pkscale.c	Wed Jan 13 02:21:19 1993
***************
*** 12,18 ****
  #ifdef	PK
  
  #ifndef lint
! static char SCCSid[] = "@(#)pkscale.c 1.3 Copyright 92/10/30 02:27:04 Chris Lewis";
  #endif
  
  #include "pk.h"
--- 12,18 ----
  #ifdef	PK
  
  #ifndef lint
! static char SCCSid[] = "@(#)pkscale.c 1.4 Copyright 92/12/04 23:12:13 Chris Lewis";
  #endif
  
  #include "pk.h"
***************
*** 101,106 ****
--- 101,107 ----
  	npc->pkc_sfpr = r = (struct ras *) mustmalloc(sizeof(struct ras),
  	    "SFP raster header for scale");
  	
+ 	npc->pkc_pkr = (int8 *) NULL;
  	npc->pkc_height = scalenum(sf, npc->pkc_height)+1;
  	npc->pkc_width = scalenum(sf, npc->pkc_width)+1;
  	npc->pkc_dx = scalenum(sf, npc->pkc_dx);
Index: ./pk.c
*** /tmp/PATCHold/./pk.c	Wed Jan 13 02:21:29 1993
--- ./pk.c	Wed Jan 13 02:21:31 1993
***************
*** 13,19 ****
  #ifdef	PK
  
  #ifndef lint
! static char SCCSid[] = "@(#)pk.c 2.4 Copyright 92/03/12 01:11:09 Chris Lewis";
  #endif
  
  #define	DRAW
--- 13,19 ----
  #ifdef	PK
  
  #ifndef lint
! static char SCCSid[] = "@(#)pk.c 2.7 Copyright 93/01/05 23:46:55 Chris Lewis";
  #endif
  
  #define	DRAW
***************
*** 32,38 ****
  
  static FILE *fin;
  static char *filename;	/* name of *current* font being read */
- extern char *malloc();
  
  static long flag_byte;
  static repeatcount;
--- 32,37 ----
***************
*** 674,681 ****
      sfp_hmi = (double) c / 4 + .5;
  
      c = get2int();	/* retrieved *height* */
!     p->pkp_ds = (c * POINT * pow2(20)) / (OUTRES*4);
!     p->pkp_npts = (p->pkp_ds / pow2(20)) + 0.5;
  
      get2int();	/* dummy */
      get1int();	/* dummy */
--- 673,680 ----
      sfp_hmi = (double) c / 4 + .5;
  
      c = get2int();	/* retrieved *height* */
!     p->pkp_npts = (double) (c * POINT) / (OUTRES * 4) + 0.5;
!     p->pkp_ds = p->pkp_npts * pow2(20);
  
      get2int();	/* dummy */
      get1int();	/* dummy */
***************
*** 863,870 ****
  
      fputshort((long) p->pkp_symset, sfp);
  
!     fputshort((long) (OUTRES * p->pkp_npts * 4) / 120, sfp);
!     fputshort((long) (p->pkp_npts * (OUTRES / POINT) * 4), sfp);
      fputshort(0, sfp);
      fputc(0, sfp);
      fputc(p->pkp_style, sfp);
--- 862,869 ----
  
      fputshort((long) p->pkp_symset, sfp);
  
!     fputshort((long) (p->pkp_npts * OUTRES * 4 / 120), sfp);
!     fputshort((long) (p->pkp_npts * OUTRES * 4 / POINT), sfp);
      fputshort(0, sfp);
      fputc(0, sfp);
      fputc(p->pkp_style, sfp);
