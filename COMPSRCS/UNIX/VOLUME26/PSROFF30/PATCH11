Newsgroups: comp.sources.unix
From: clewis@ferret.ocunix.on.ca (Chris Lewis)
Subject: v26i202: psroff 3.0, Patch11
Sender: unix-sources-moderator@efficacy.home.vix.com
Approved: WhoAmI@efficacy.home.vix.com

Submitted-By: clewis@ferret.ocunix.on.ca (Chris Lewis)
Posting-Number: Volume 26, Issue 202
Archive-Name: psroff3.0/patch11

Return-Path: @mail.uunet.ca:clewis@ecicrl
Received: by cognition.pa.dec.com; id AA13413; Sat, 23 May 92 23:36:10 -0700
Received: by inet-gw-2.pa.dec.com; id AA10808; Sat, 23 May 92 23:35:56 -0700
Received: from relay1.UU.NET by rodan.UU.NET with SMTP (5.61/UUNET-mail-drop) id AA06901; Sun, 24 May 92 02:35:50 -0400
Received: from mail.uunet.ca (via uunet.ca) by relay1.UU.NET with SMTP (5.61/UUNET-internet-primary) id AA19773; Sun, 24 May 92 02:35:21 -0400
Received: from ecicrl by mail.uunet.ca with UUCP id <10267>; Sun, 24 May 1992 02:35:14 -0400
Received: by ferret.ocunix.on.ca (smail2.5)id AA23512; 24 May 92 01:48:39 EDT (Sun)
Message-Id: <9205240148.AA23512@ferret.ocunix.on.ca>
Date: Sun, 24 May 1992 01:48:39 -0400
From: clewis@ferret.ocunix.on.ca (Chris Lewis)
To: comp-sources-unix@uunet.UU.NET

Archive-name: psroff3.0/patch.11
Submitted-by: clewis@ferret.ocunix.on.ca (Chris Lewis)

    This is official patch 11 for Psroff 3.0.
    Please apply it by:
	cd <psroff source directory>
	touch checker.S pkscale.c (some v's of patch need this)
	patch -N -p < <this file>
    
    The base release of psroff3.0 patches 1-4 were in
    comp.sources.unix volume 24, 5-7 in volume 25 and 8-10
    in volume26.

Highlights:
	- Many optimization improvements of PostScript output:
		- shortened font change sequences.
		- can optimize horizontal line drawing (LJ3 too)
		- line optimization (as opposed to "word")
		- parameterize "." widths.
		- parameterizable in psrofflib.S
	  For some metrics: perl man page: 1.5Mb unoptimized;
	  550K optimized; 270K with line optimization (better than
	  groff!!! ;-).  Shortened font change stuff saves ~5%.
	  Period width saves ~5%.  See troff2ps manual page "-g"
	  option for more detail.  Default: same as before - set
	  in psrofflib.S file.
	- brand new configuration checker.  Try "make check".
	  Much simpler and more accurate.  "audit" is now obsolete.
	- pk2sfp can now scale Laserjet fonts.  Not real well,
	  but usable, particularly when you're creating small
	  point sizes from big ones.  See manual page.  Eventually,
	  pkscale may be automatic in troff2ps, but for now, strictly
	  an auxiliary program.
	- PostScript now supports European character set, compatible
	  with LJIII and "standard" troff naming conventions.
	  This is only available from CAT troff now.  The width
	  tables will be fixed for ditroff in next patch.  Note
	  "RE" function in ps.lib, and "_" prefixes in ps.fonts.
	- line widths in LJ3 fixed to be consistant with box
	  characters and groff.
	- installdit can now handle other ASCII-width-table-needing
	  ditroffs (eg: DWB 3.x), and installs groff tables properly.
	- install permission fixing.
	- Can handle font numbers > 9 (nonstandard ditroffs,
	  groff and DWB 3)

Files affected in this patch:

    ./man/pk2sfp.1.S
    ./man/troff2ps.1.S
    ./lib/lj3.fonts
    ./lib/lj3.lib
    ./lib/ps.fonts
    ./lib/ps.lib
    ./lib/psrofflib.S
    ./lib/lj3u.fonts
    ./widths/installdit.S
    ./utils/Makefile
    ./utils/pk2ps.c
    ./utils/pk2sfp.c
    ./utils/psxlate.c
    ./utils/showfont.S
    ./adapters/Makefile
    ./checker.S
    ./utils.c
    ./ps.c
    ./dit.c
    ./README
    ./troff2.c
    ./defs.h
    ./INSTALL
    ./Makefile
    ./opt.c
    ./pkscale.c
    ./pk.c

Patchwrapped: 920523223715

Index: ./man/pk2sfp.1.S
*** /tmp/PATCHold/./man/pk2sfp.1.S	Sat May 23 22:29:26 1992
--- ./man/pk2sfp.1.S	Sat May 23 22:29:32 1992
***************
*** 1,4 ****
! .\"Copyright 1988 by Chris Lewis 91/03/20
  .TH PK2SFP %%MANEXT%% "Psroff %%T2VERSION%%"
  .SH NAME
  pk2sfp,pk2ditwid,pktype,pk2ps \- PK/SFP format font file handling utilities
--- 1,4 ----
! .\"Copyright 1988 by Chris Lewis 92/05/19
  .TH PK2SFP %%MANEXT%% "Psroff %%T2VERSION%%"
  .SH NAME
  pk2sfp,pk2ditwid,pktype,pk2ps \- PK/SFP format font file handling utilities
***************
*** 108,113 ****
--- 108,119 ----
  .SH "Additional options for pk2sfp"
  .PP
  The
+ .BI "\-o" size
+ option will scale the input fonts to the point size specified
+ by
+ .BR size .
+ .PP
+ The
  .BI "\-s" na
  option will set the symbol set.
  Eg:
***************
*** 529,534 ****
--- 535,543 ----
  .B pk2sfp "'s"
  partial downloading feature (by including characters that you don't
  really need - which is harmless).
+ .PP
+ The \-o option only really works well when you're going *down*
+ in size.
  .SH "SEE ALSO"
  troff2ps(%%MANEXT%%), \fIlj.fonts\fP,
  Hewlett Packard's HP Laserjet Reference Manuals.
Index: ./man/troff2ps.1.S
*** /tmp/PATCHold/./man/troff2ps.1.S	Sat May 23 22:29:54 1992
--- ./man/troff2ps.1.S	Sat May 23 22:29:56 1992
***************
*** 1,4 ****
! .\"Copyright 1988 by Chris Lewis 2.14 91/11/13
  .TH TROFF2PS %%MANEXT%% "Psroff %%T2VERSION%%"
  .SH NAME
  troff2ps, troff2lj, troff2xx \- convert troff output to Postscript, HP etc.
--- 1,4 ----
! .\"Copyright 1988 by Chris Lewis 2.16 92/05/23
  .TH TROFF2PS %%MANEXT%% "Psroff %%T2VERSION%%"
  .SH NAME
  troff2ps, troff2lj, troff2xx \- convert troff output to Postscript, HP etc.
***************
*** 20,25 ****
--- 20,26 ----
  .B "[\-M]"
  .B "[\-S]"
  .BI "[\-G" ss "]"
+ .BI "[\-g" opt "]"
  .SH DESCRIPTION
  .I Troff2ps
  takes
***************
*** 166,172 ****
  else, or the final directory name is different from the
  .B \-T
  value (ie: with ditroff).
- See psrofflib entry "ops" for an example.
  The
  .B \-W
  option is ignored unless
--- 167,172 ----
***************
*** 173,178 ****
--- 173,219 ----
  .B \-Z
  is specified.
  .PP
+ The
+ .B \-g
+ option is an extended version of
+ .BR \-Z .
+ .B \-g
+ consists of a string containing one or more of the following:
+ a period (``.''), or an l (lower case L) or a decimal number.
+ The decimal number must be last.
+ The period indicates that the width table entries for a period
+ are correct.
+ Many PostScript printers have slightly different metrics for
+ periods.
+ To test, run ``showfont | <your printer>'' and examine the
+ box containing the period.
+ The number second from the bottom on the left side should be 25.
+ If it is, you can supply the ``.'' option.
+ If not, you will have to regenerate all of your width tables
+ using psdtwid before you can safely specify ``.''.
+ Turning ``.'' on typically saves about 10-15% in PostScript
+ file size.
+ .PP
+ The ``l'' suboption enables line optimization.
+ This causes
+ .B troff2ps
+ to assemble whole lines worth of
+ text into single string emissions rather than breaking on
+ inter-word spaces.
+ This can save as much as 50% of the file size and transmission
+ time, as well as significantly speeding up your printer.
+ .PP
+ The decimal number tells the optimizer how big a string to
+ coalesce.
+ The default is 15.
+ Setting ``l'' implies 150.
+ .PP
+ .B \-Z
+ is equivalent to
+ .BR \-g15 .
+ .B \-g.l
+ is the highest possible optimization level.
+ .PP
  Ditroff output is a special case with respect to optimization.
  The optimal form for emitting characters in ditroff is something
  like ``\f3c\f2CnnCnnCnnC\f3w\f1'',
***************
*** 187,192 ****
--- 228,235 ----
  .PP
  If
  .B \-Z
+ or
+ .B \-g
  is specified,
  but
  .B \-n
***************
*** 195,200 ****
--- 238,245 ----
  with any ditroff backend.
  If both
  .B \-Z
+ or
+ .B \-g
  and
  .B \-n
  are specified, ``words'' are emitted as ``\f3t\f2CCCCC\f1'', which
Index: ./lib/lj3.fonts
*** /tmp/PATCHold/./lib/lj3.fonts	Sat May 23 22:30:11 1992
--- ./lib/lj3.fonts	Sat May 23 22:30:12 1992
***************
*** 1,4 ****
! #@(#)lj3.fonts 2.13 92/03/03
  #	Laserjet III fonts file.
  #	See lj.fonts for more explanation.
  #	The first ten fonts are the built-in scaleable typefaces.
--- 1,4 ----
! #@(#)lj3.fonts 2.14 92/04/12
  #	Laserjet III fonts file.
  #	See lj.fonts for more explanation.
  #	The first ten fonts are the built-in scaleable typefaces.
***************
*** 53,59 ****
  co N \033(7J\245\033(8U
  sq N \033(7J\273\033(8U
  symbol
! br N | -92 0
  eq S =
  ts S \133
  mi S -
--- 53,59 ----
  co N \033(7J\245\033(8U
  sq N \033(7J\273\033(8U
  symbol
! br N | -80 0
  eq S =
  ts S \133
  mi S -
Index: ./lib/lj3.lib
*** /tmp/PATCHold/./lib/lj3.lib	Sat May 23 22:30:20 1992
--- ./lib/lj3.lib	Sat May 23 22:30:21 1992
***************
*** 29,41 ****
  %			\xAABB \022 A %hello
  %			Passes the following bytes: 0xAA, 0xBB, 022, and "A"
  %			through to the laserjet.
! %ident  @(#)lj3.lib: 2.3 Copyright 92/02/10 16:48:46 Chris Lewis"
  \033E\033&k2G			%reset printer, set CR=CR,LF=CRLF,FF=CRFF 
  \033&l6d66p0o0e66f0L		%letter size, portrait, no perf skip
  \0339				%reset side margins
  \033&a0h0V			%move cursor to 0,0
  \033*c6120x7920y0T\033\045 1B	%set HP-GL/2 picture frame, go to HP-GL/2
! IN;WU0;PW0.36;SP1;		%initialize, pen widths in MM, 0.36MM for pen 1
  LA1,4,2,4;			%set round line caps & joins
  TR0;				%set transparency mode off
  IP0,11176,8636,0;		%set orientation to match PCL
--- 29,41 ----
  %			\xAABB \022 A %hello
  %			Passes the following bytes: 0xAA, 0xBB, 022, and "A"
  %			through to the laserjet.
! %ident  @(#)lj3.lib: 2.4 Copyright 92/04/12 22:01:19 Chris Lewis"
  \033E\033&k2G			%reset printer, set CR=CR,LF=CRLF,FF=CRFF 
  \033&l6d66p0o0e66f0L		%letter size, portrait, no perf skip
  \0339				%reset side margins
  \033&a0h0V			%move cursor to 0,0
  \033*c6120x7920y0T\033\045 1B	%set HP-GL/2 picture frame, go to HP-GL/2
! IN;WU0;PW0.2;SP1;		%initialize, pen widths in MM, 0.36MM for pen 1
  LA1,4,2,4;			%set round line caps & joins
  TR0;				%set transparency mode off
  IP0,11176,8636,0;		%set orientation to match PCL
Index: ./lib/ps.fonts
*** /tmp/PATCHold/./lib/ps.fonts	Sat May 23 22:30:29 1992
--- ./lib/ps.fonts	Sat May 23 22:30:30 1992
***************
*** 1,4 ****
! #@(#)ps.fonts 2.5 91/08/29
  #	DO NOT CHANGE THE ORDER OF THE FIRST FOUR LINES - THESE ARE
  #	THE DEFAULT TROFF FONTS IN POSITIONS 1-5.  IN PARTICULAR, IF
  #	SYMBOL ISN'T THE FOURTH ENTRY AND BRACKETFONT ISN'T THE FIFTH,
--- 1,4 ----
! #@(#)ps.fonts 2.6 92/05/21 01:56:49
  #	DO NOT CHANGE THE ORDER OF THE FIRST FOUR LINES - THESE ARE
  #	THE DEFAULT TROFF FONTS IN POSITIONS 1-5.  IN PARTICULAR, IF
  #	SYMBOL ISN'T THE FOURTH ENTRY AND BRACKETFONT ISN'T THE FIFTH,
***************
*** 7,15 ****
  #	The first token is the CAT name, the second is the postscript
  #	name, and the third (if present) is a file to punt to the
  #	printer when the font is first referenced.
! R	Times-Roman
! I	Times-Italic
! B	Times-Bold
  S	Symbol
  S2	BracketFont
  AB	AvantGarde-Demi
--- 7,17 ----
  #	The first token is the CAT name, the second is the postscript
  #	name, and the third (if present) is a file to punt to the
  #	printer when the font is first referenced.
! #	If the font name starts with an underscore, the font
! #	is reencoded to permit access to the European character set.
! R	_Times-Roman
! I	_Times-Italic
! B	_Times-Bold
  S	Symbol
  S2	BracketFont
  AB	AvantGarde-Demi
***************
*** 47,137 ****
  HW	HaeberliWriting	/usr/lib/troff2/lib/lj/hwfont
  TE	Tymes-Elfin /usr/lib/troff2/lib/lj/tefont
  extensions
! a^	N	\136
! a~	N	\176
! I!	N	\241
! po	N	\243
! $J	N	\245
! lq	N	\252
! d<	N	\253
! l<	N	\254
! r>	N	\255
! pp	N	\266
! bq	N	\271
! rq	N	\272
! d>	N	\273
! pm	N	\275
! I?	N	\277
! ma	N	\305
! be	N	\306
! dt	N	\307
! ..	N	\310
! ri	N	\312
! cd	N	\313
! ''	N	\315
! og	N	\316
! hc	N	\317
! a:	N	\321
! o:	N	\322
! u:	N	\323
! A:	N	\324
! O:	N	\325
! U:	N	\326
! AE	N	\341
! PL	N	\350
! O/	N	\351
  OE	N	\352
- ae	N	\361
- ui	N	\365
- Pl	N	\370
- o/	N	\371
  oe	N	\372
! ss	N	\373
! fa	S	\042
! te	S	\044
! cm	S	\047
! =~	S	\100
! *A	S	\101
! *B	S	\102
! *X	S	\103
! *E	S	\105
! *Y	S	\110
! *I	S	\111
! *K	S	\113
! *M	S	\115
! *N	S	\116
! *O	S	\117
! *R	S	\122
! *T	S	\124
! *Z	S	\132
! tf	S	\134
! bt	S	\136
! mt	S	\242
! Cc	S	\247
! Cd	S	\250
! Ch	S	\251
! Cs	S	\252
! <>	S	\253
! sd	S	\262
! cr	S	\277
! al	S	\300
! ax	S	\304
! a+	S	\305
! !s	S	\313
! !m	S	\317
! ag	S	\320
! m.	S	\327
! an	S	\331
! lo	S	\332
! io	S	\333
! <:	S	\334
! u=	S	\335
! :>	S	\336
! d=	S	\337
! dm	S	\340
! L<	S	\341
! tm	S	\344
! AL	S	\360
! R>	S	\361
! r1	4	\121
! r2	4	\122
--- 49,118 ----
  HW	HaeberliWriting	/usr/lib/troff2/lib/lj/hwfont
  TE	Tymes-Elfin /usr/lib/troff2/lib/lj/tefont
  extensions
! r!	N	\241
! r?	N	\277
! 'A	N	\001
! 'a	N	\002
! ^A	N	\003
! ^a	N	\004
! :A	N	\005
! :a	N	\006
! `A	N	\007
! `a	N	\010
! oA	N	\011
! oa	N	\012
! ~A	N	\013
! ~a	N	\014
! ,C	N	\015
! ,c	N	\016
! 'E	N	\017
! 'e	N	\020
! ^E	N	\021
! ^e	N	\022
! :E	N	\023
! :e	N	\024
! `E	N	\025
! `e	N	\026
! 'I	N	\027
! 'i	N	\030
! ^I	N	\031
! ^i	N	\032
! :I	N	\033
! :i	N	\034
! `I	N	\035
! `i	N	\036
! ~N	N	\037
! ~n	N	\200
! 'O	N	\201
! 'o	N	\202
! ^O	N	\203
! ^o	N	\204
! :O	N	\205
! :o	N	\206
! `O	N	\207
! `o	N	\210
! ~O	N	\211
! ~o	N	\212
! vS	N	\213
! vs	N	\214
! 'U	N	\215
! 'u	N	\216
! ^U	N	\217
! ^u	N	\220
! :U	N	\221
! :u	N	\222
! `U	N	\223
! `u	N	\224
! :Y	N	\225
! :y	N	\226
! vZ	N	\227
! vz	N	\230
! /O	N	\351
! /o	N	\371
  OE	N	\352
  oe	N	\372
! ae	N	\361
! AE	N	\341
! Ye	N	\245
! ..	N	\310
! 
Index: ./lib/ps.lib
*** /tmp/PATCHold/./lib/ps.lib	Sat May 23 22:30:38 1992
--- ./lib/ps.lib	Sat May 23 22:30:40 1992
***************
*** 9,18 ****
  %	Module:		ps.lib
  %	Author: 	Chris Lewis
  %	Specs:		Predefinitions for PostScript
! %ident  @(#)ps.lib: 2.12 Copyright 92/02/13 01:44:51 Chris Lewis"
  
  /Y { 3 1 roll dup /CurY exch def moveto show } bind def
  /X { exch CurY moveto show } bind def
  /hits 0 def
  /misses 0 def
  /pagecount 0 def
--- 9,27 ----
  %	Module:		ps.lib
  %	Author: 	Chris Lewis
  %	Specs:		Predefinitions for PostScript
! %ident  @(#)ps.lib: 92/05/21 Copyright 92/05/21 01:56:54 Chris Lewis"
  
  /Y { 3 1 roll dup /CurY exch def moveto show } bind def
  /X { exch CurY moveto show } bind def
+ % s cx x y W -
+ /W {
+     dup		% s cx x y y
+     /CurY exch def	% s cx x y
+     moveto	% s cx
+     0 8#040	% s cx 0 8#040
+     4 -1 roll	% cx 0 8#040 s
+     widthshow	% -
+ } bind def
  /hits 0 def
  /misses 0 def
  /pagecount 0 def
***************
*** 76,82 ****
  %	pages.
  %
  %	Trial font cache - I can't think in Polish... ;-)
! /SetFont {
      /curPoints exch def
      /curFont exch def
      %	Concatenate the curFont string with the curPoints to create
--- 85,91 ----
  %	pages.
  %
  %	Trial font cache - I can't think in Polish... ;-)
! /S {
      /curPoints exch def
      /curFont exch def
      %	Concatenate the curFont string with the curPoints to create
***************
*** 110,116 ****
  
  /metrics {
      /psize 16 def
!     /Times-Roman psize SetFont
      /charcount exch def
      /curpos 720 def
      /xpos 72 def
--- 119,125 ----
  
  /metrics {
      /psize 16 def
!     /Times-Roman psize S
      /charcount exch def
      /curpos 720 def
      /xpos 72 def
***************
*** 405,411 ****
    40 C.setl  0 -250 moveto  0 1000 rlineto  stroke
  } def
  /Cru {
! 0 0 -50 -250 1000 0 setcachedevice
    40 C.setl  0 -250 moveto 500 0 rlineto stroke
  } def
  /Crn {
--- 414,420 ----
    40 C.setl  0 -250 moveto  0 1000 rlineto  stroke
  } def
  /Cru {
! 500 0 -50 -250 1000 0 setcachedevice
    40 C.setl  0 -250 moveto 500 0 rlineto stroke
  } def
  /Crn {
***************
*** 445,450 ****
--- 454,461 ----
  } def end
  /BracketFont BracketFontDict definefont pop
  
+ %Drawing support
+ 
  /Ellipse {
  	/Yaxis exch 2 div def
  	/Xaxis exch 2 div def
***************
*** 487,492 ****
--- 498,547 ----
  /dost{
  	currentlinewidth exch 6 div setlinewidth stroke setlinewidth
  } bind def
+ 
+ 
+ %	Font reencoding support function for European characters.
+ %	Requires a leading _ on the ps.fonts files.
+ %	Green book, pg 115-117
+ %	encmap f1 f2 RE
+ %	reencodes f2 to create f1, using map in encmap.
+ /RE {
+     findfont begin
+     currentdict dup length dict begin
+ 	{ %forall
+ 	    1 index /FID ne {def} {pop pop} ifelse
+ 	} forall
+ 	/FontName exch def dup length 0 ne { %if
+ 	    /Encoding Encoding 256 array copy def
+ 	    0 exch { %forall
+ 		dup type /nametype eq { %ifelse
+ 		    Encoding 2 index 2 index put
+ 		    pop 1 add
+ 		}{ %else
+ 		    exch pop
+ 		} ifelse
+ 	    } forall
+ 	} if pop
+     currentdict dup end end
+     /FontName get exch definefont pop
+ } bind def
+ 
+ %	Standard encoding for psroff.
+ %	places 32 characters starting at 0, then the rest at 128.
+ /stdencoding [ 1
+ /Aacute /aacute /Acircumflex /acircumflex /Adieresis /adieresis /Agrave /agrave
+ /Aring /aring /Atilde /atilde
+ /Ccedilla /ccedilla
+ /Eacute /eacute /Ecircumflex /ecircumflex /Edieresis /edieresis /Egrave /egrave
+ /Iacute /iacute /Icircumflex /icircumflex /Idieresis /idieresis /Igrave /igrave
+ /Ntilde
+ 128
+ /ntilde
+ /Oacute /oacute /Ocircumflex /ocircumflex /Odieresis /odieresis /Ograve /ograve
+ /Otilde /otilde
+ /Scaron /scaron /Uacute /uacute /Ucircumflex /ucircumflex /Udieresis /udieresis
+ /Ugrave /ugrave /Ydieresis /ydieresis /Zcaron /zcaron
+ ] def
  
  %	This macro is invoked by ShowPage to display the current form.
  %	Usually redefined to point at a form loaded by an include
Index: ./lib/psrofflib.S
*** /tmp/PATCHold/./lib/psrofflib.S	Sat May 23 22:30:54 1992
--- ./lib/psrofflib.S	Sat May 23 22:30:55 1992
***************
*** 1,4 ****
! #	2.25 92/02/10
  #	This file controls psroff, you can insert additional printer
  #	types here.  These are eval'd *late* in processing, so that
  #	you can insert $copies etc.
--- 1,4 ----
! #	2.27 92/05/23
  #	This file controls psroff, you can insert additional printer
  #	types here.  These are eval'd *late* in processing, so that
  #	you can insert $copies etc.
***************
*** 60,70 ****
  #		-G<sizescale>	If you're driving with groff, and the sizescale
  #				parameter is specified in the DESC file, you
  #				have to supply the sizescale parameter here.
! #		-Z		optimizer
! #		-S		Use "stop" to terminate Postscript instead
! #				of control-D
  #		-W<directory>	location of CAT width tables.  Defaults
  #				to FONTDIR/<type>/ft*
  #
  #	lparg: how to get output to printer.  Note the "-n$copies" and
  #		-d$ptr.  The $ptr is the psroff selected physical printer
--- 60,73 ----
  #		-G<sizescale>	If you're driving with groff, and the sizescale
  #				parameter is specified in the DESC file, you
  #				have to supply the sizescale parameter here.
! #		-Z		optimizer.  If you are using a version of
! #				DWB that needs ASCII width tables, set -G1.
! #		-g[.][l]nnn	Optimizer control.  Leave out initially.
! #				Consult troff2ps man page for more details.
  #		-W<directory>	location of CAT width tables.  Defaults
  #				to FONTDIR/<type>/ft*
+ #		-S		Use "stop" to terminate Postscript instead
+ #				of control-D
  #
  #	lparg: how to get output to printer.  Note the "-n$copies" and
  #		-d$ptr.  The $ptr is the psroff selected physical printer
Index: ./lib/lj3u.fonts
*** /tmp/PATCHold/./lib/lj3u.fonts	Sat May 23 22:31:09 1992
--- ./lib/lj3u.fonts	Sat May 23 22:31:10 1992
***************
*** 1,4 ****
! #@(#)lj3u.fonts 2.7 92/03/03
  #	Laserjet III fonts file.  Shuffled for Universal as primary typeface.
  #	See lj.fonts for more explanation.
  #	The first ten fonts are the built-in scaleable typefaces.
--- 1,4 ----
! #@(#)lj3u.fonts 2.8 92/04/12
  #	Laserjet III fonts file.  Shuffled for Universal as primary typeface.
  #	See lj.fonts for more explanation.
  #	The first ten fonts are the built-in scaleable typefaces.
***************
*** 53,59 ****
  co N \033(7J\245\033(8U
  sq N \033(7J\273\033(8U
  symbol
! br N | -92 0
  eq S =
  ts S \133
  mi S -
--- 53,59 ----
  co N \033(7J\245\033(8U
  sq N \033(7J\273\033(8U
  symbol
! br N | -80 0
  eq S =
  ts S \133
  mi S -
Index: ./widths/installdit.S
*** /tmp/PATCHold/./widths/installdit.S	Sat May 23 22:31:21 1992
--- ./widths/installdit.S	Sat May 23 22:31:22 1992
***************
*** 5,11 ****
  #    See the LICENSE file for a full description of the restrictions
  #    under which this software is provided.
  #
! #1.7 92/02/21
  MAKEDEV=%%MAKEDEV%%
  if [ ! -f "$MAKEDEV" ]
  then
--- 5,11 ----
  #    See the LICENSE file for a full description of the restrictions
  #    under which this software is provided.
  #
! #1.8 92/04/12
  MAKEDEV=%%MAKEDEV%%
  if [ ! -f "$MAKEDEV" ]
  then
***************
*** 96,102 ****
  	    continue
  	fi
  	cd $dir
! 	list="`find . -name '[A-Z]*' -a ! -name '*.out' -print`"
  	if [ -n "$list" ]
  	then
  	    echo "INSTALLING ditroff widths from $dir into $destdir"
--- 96,108 ----
  	    continue
  	fi
  	cd $dir
! 	if [ -z "$Garg" ]
! 	then
! 	    list="`find . -name '*.out' -print`"
! 	else
! 	    list="`find . -name '[A-Z]*' -a ! -name '*.out' -print`"
! 	fi
! 
  	if [ -n "$list" ]
  	then
  	    echo "INSTALLING ditroff widths from $dir into $destdir"
Index: ./utils/Makefile
*** /tmp/PATCHold/./utils/Makefile	Sat May 23 22:31:31 1992
--- ./utils/Makefile	Sat May 23 22:31:32 1992
***************
*** 4,10 ****
  #    See the LICENSE file for a full description of the restrictions
  #    under which this software is provided.
  #
! #2.9 91/10/17
  SCRIPTS	= psdtwd showfont mkenctab calcfonts catconv dodps
  PROGRAMS = hpinterp psxlate pk2sfp pk2ditwid pktype dumpft pk2ps lj2ps \
  	asc2ps
--- 4,10 ----
  #    See the LICENSE file for a full description of the restrictions
  #    under which this software is provided.
  #
! #2.11 92/05/19
  SCRIPTS	= psdtwd showfont mkenctab calcfonts catconv dodps
  PROGRAMS = hpinterp psxlate pk2sfp pk2ditwid pktype dumpft pk2ps lj2ps \
  	asc2ps
***************
*** 69,76 ****
  	$(CC) $(CFLAGS) -o pk2ditwid pk2ditwid.o ../debug.o ../pk.o ljtab.o \
  		$(LIBFLAGS)
  
! pk2sfp:	../pk.o ../debug.o pk2sfp.o ljtab.o
! 	$(CC) $(CFLAGS) -o pk2sfp pk2sfp.o ../debug.o ../pk.o ljtab.o \
  	    $(LIBFLAGS)
  
  dumpft:	dumpft.o ../cattab.o
--- 69,76 ----
  	$(CC) $(CFLAGS) -o pk2ditwid pk2ditwid.o ../debug.o ../pk.o ljtab.o \
  		$(LIBFLAGS)
  
! pk2sfp:	../pk.o ../debug.o pk2sfp.o ljtab.o ../pkscale.o
! 	$(CC) $(CFLAGS) -o pk2sfp pk2sfp.o ../debug.o ../pk.o ljtab.o ../pkscale.o \
  	    $(LIBFLAGS)
  
  dumpft:	dumpft.o ../cattab.o
***************
*** 84,91 ****
  
  install:
  	cd $(LIBDIR) ; rm -f $(SCRIPTS)
! 	$(IGNORESH) cp $(SCRIPTS) $(LIBDIR)
! 	for i in $(PROGRAMS) ; \
  	do \
  	    if [ -f $(LIBDIR)/$$i ] ; \
  	    then \
--- 84,92 ----
  
  install:
  	cd $(LIBDIR) ; rm -f $(SCRIPTS)
! 	cp $(SCRIPTS) $(LIBDIR)
! 	cd $(LIBDIR) ; chmod 555 $(SCRIPTS)
! 	$(IGNORSH) for i in $(PROGRAMS) ; \
  	do \
  	    if [ -f $(LIBDIR)/$$i ] ; \
  	    then \
***************
*** 93,98 ****
--- 94,100 ----
  		cp $(LIBDIR)/$$i $(LIBDIR)/$$i.old 2> /dev/null ; \
  	    fi ; \
  	    cp $$i $(LIBDIR)/$$i ; \
+ 	    chmod 555 $(LIBDIR)/$$i ; \
  	done
  
  #	Try to convert a vendor supplied ft into dit2catwid input
Index: ./utils/pk2ps.c
*** /tmp/PATCHold/./utils/pk2ps.c	Sat May 23 22:31:41 1992
--- ./utils/pk2ps.c	Sat May 23 22:31:42 1992
***************
*** 14,20 ****
  
  #ifndef	lint
  static char SCCSID[] =
!     "@(#)pk2ps.c 2.3 Copyright 91/10/22 03:03:11 Chris Lewis";
  #endif
  #include "defs.h"
  #include "pk.h"
--- 14,20 ----
  
  #ifndef	lint
  static char SCCSID[] =
!     "@(#)pk2ps.c 2.4 Copyright 92/03/12 01:11:48 Chris Lewis";
  #endif
  #include "defs.h"
  #include "pk.h"
***************
*** 26,31 ****
--- 26,53 ----
  long highest = 0;
  int fontonly = 0;
  
+ /* character names in standard Adobe encoding */
+ char *adobecharnames[95] =
+     {	"space", "exclam", "quotedbl", "numbersign",
+ 	"dollar", "percent", "ampersand", "quoteright",
+ 	"parenleft", "parenright", "asterisk", "plus",
+ 	"comma", "hyphen", "period", "slash",
+ 	"zero", "one", "two", "three", "four", "five",
+ 	"six", "seven", "eight", "nine", "colon", "semicolon",
+ 	"less", "equal", "greater", "question",
+ 	"at", "A", "B", "C", "D", "E", "F", "G",
+ 	"H", "I", "J", "K", "L", "M", "N", "O",
+ 	"P", "Q", "R", "S", "T", "U", "V", "W",
+ 	"X", "Y", "Z", "bracketleft",
+ 	"backslash", "bracketright", "asciicircum", "underscore",
+ 	"quoteleft", "a", "b", "c", "d", "e", "f", "g",
+ 	"h", "i", "j", "k", "l", "m", "n", "o",
+ 	"p", "q", "r", "s", "t", "u", "v", "w",
+ 	"x", "y", "z", "braceleft", "bar", "braceright", "asciitilde"
+     };
+ 
+ extern long sfp_hmi;	/* pitch (default HMI) -- width of space */
+ 
  /*	Dummied out for pk.c */
  needchar(a, b)
  int a, b; {
***************
*** 44,52 ****
      struct pkp *pk_read();
      register int i, len;
      int chcount;
  
      progname = argv[0];
!     while((c = getopt(argc, argv, "fD:v")) != EOF)
  	switch(c) {
  	    case 'D':
  #ifdef	DEBUG
--- 66,78 ----
      struct pkp *pk_read();
      register int i, len;
      int chcount;
+     int saw_space;
+     int lx, ly, ux, uy;		/* character bounding box */
+     int flx, fly, fux, fuy;	/* font bounding box */
+     char *fontname = NULL;
  
      progname = argv[0];
!     while((c = getopt(argc, argv, "fD:n:v")) != EOF)
  	switch(c) {
  	    case 'D':
  #ifdef	DEBUG
***************
*** 57,62 ****
--- 83,91 ----
  		    progname);
  		exit(1);
  #endif
+ 	    case 'n':
+ 		fontname = optarg;
+ 		break;
  	    case 'v':
  		verbose = 1;
  		break;
***************
*** 71,80 ****
  	char *filebuf = mustmalloc(strlen(argv[optind]) + 10);
  	register char *cp;
  
- 	printf("%%FILE: %s\n", argv[optind]);
- 
  	highest = 0;
  
  	cp = strrchr(argv[optind], '/');
  
  	if (cp)
--- 100,109 ----
  	char *filebuf = mustmalloc(strlen(argv[optind]) + 10);
  	register char *cp;
  
  	highest = 0;
  
+ 	saw_space = 0;
+ 
  	cp = strrchr(argv[optind], '/');
  
  	if (cp)
***************
*** 85,116 ****
  	if (cp)
  	    *cp = '\0';
  
  	if (!fontonly) {
  	    printf("/saveobj save def\n");
  	}
  
  	printf("10 dict dup begin\n");
  	printf("/FontType 3 def\n");
! 	printf("/FontMatrix [1 0 0 1 0 0] def\n");
! 	printf("/FontBBox [1.28 1.2 -0.16 -.024] def\n");
  	printf("/FontInfo 5 dict def\n");
  	printf("FontInfo begin\n");
  	printf("    /isFixedPitch false def\n");
  	printf("end\n");
  	printf("/Encoding 256 array def\n");
  	printf("0 1 255 {Encoding exch /.notdef put} for\n");
! 	printf("Encoding\n");
! 
! 	p = pk_read(argv[optind]);
! 
  	chcount = 0;
  	for (pc = p->pkp_chars; pc; pc = pc->pkc_next) {
! 	    if (pc->pkc_next)
  		printf("dup ");
! 	    printf("%ld /ch%ld put\n", pc->pkc_char, pc->pkc_char);
! 	    highest = max(highest, pc->pkc_char);
  	    chcount++;
  	}
  
  	if (verbose) {
  	    fprintf(stderr, "Emitting %s, %d codes\n", filebuf, chcount);
--- 114,162 ----
  	if (cp)
  	    *cp = '\0';
  
+ 	if (fontname != NULL) filebuf = fontname;
+ 
+ 	printf("%%%%BeginFont: %s\n", filebuf);
+ 
  	if (!fontonly) {
  	    printf("/saveobj save def\n");
  	}
  
+ 	p = pk_read(argv[optind]);
+ 
+ 	    /* allocate a new dictionary for the font description */
  	printf("10 dict dup begin\n");
+ 	    /* this is a Type 3 font */
  	printf("/FontType 3 def\n");
! 	    /* font translation matrix */
! 	printf("/FontMatrix [.001 0 0 .001 0 0] def\n");
! #ifdef NEVER
  	printf("/FontInfo 5 dict def\n");
  	printf("FontInfo begin\n");
  	printf("    /isFixedPitch false def\n");
  	printf("end\n");
+ #endif
+ 	    /* set up the encoding array */
  	printf("/Encoding 256 array def\n");
  	printf("0 1 255 {Encoding exch /.notdef put} for\n");
! 	printf("Encoding");
  	chcount = 0;
  	for (pc = p->pkp_chars; pc; pc = pc->pkc_next) {
! 	    c = pc->pkc_char;
! 	    if (c == 32) saw_space++;
! 	    printf ((chcount % 3) ? " " : "\n    ");
! 	    if (pc->pkc_next || !saw_space)
  		printf("dup ");
! 	    if (c >= 32 && c <= 126)
! 		 printf("%d /%s put", c, adobecharnames[c-32]);
! 	    else printf("%d /ch%d put", c, c);
! 	    highest = max(highest, c);
  	    chcount++;
  	}
+ 	if (!saw_space) {
+ 	    printf ((chcount % 3) ? " " : "\n    ");
+ 	    printf ("32 /space put\n");
+ 	} else putchar ('\n');
  
  	if (verbose) {
  	    fprintf(stderr, "Emitting %s, %d codes\n", filebuf, chcount);
***************
*** 121,176 ****
  	else
  	    highest = 256;
  
  	printf("/BuildChar\n");
! 	printf("    { 0 begin\n");
  	printf("	/char exch def\n");
  	printf("	/fontdict exch def\n");
  	printf("	/charname fontdict /Encoding get char get def\n");
! 	printf("	/charinfo fontdict /CharData get charname\n");
! 	printf("	    get def\n");
  	printf("	/wx charinfo 0 get def\n");
  	printf("	/charbbox charinfo 1 4 getinterval def\n");
  	printf("	wx 0 charbbox aload pop setcachedevice\n");
  	printf("	charinfo 5 get charinfo 6 get true\n");
  	printf("	fontdict /imagemaskmatrix get\n");
  	printf("	    dup 4 charinfo 7 get put\n");
  	printf("	    dup 5 charinfo 8 get put\n");
  	printf("	charinfo 9 1 getinterval cvx\n");
  	printf("	imagemask\n");
  	printf("    end\n");
! 	printf("} def\n");
  	printf("\n");
  	printf("/BuildChar load 0 6 dict put\n");
  
! #define	DOTS2UNITS(x)	((x) / ((p->pkp_npts / POINT) * 300))
  
! 	printf("/imagemaskmatrix [%.2f 0 0 -%.2f 0 0] def\n",
! 	    1 / DOTS2UNITS((double) 1),
! 	    1 / DOTS2UNITS((double) 1)
  	    );
  	printf("/CharData %d dict def\n", chcount+1);
  	printf("CharData begin\n");
! 
  	for (pc = p->pkp_chars; pc; pc = pc->pkc_next) {
  	    register struct ras *r;
  	    r = pkrast(pc);
  	    if (!r) {
  		fprintf(stderr, "%0: no raster image for %02x\n",
! 		    progname, pc->pkc_char);
  		continue;
  	    }
! 	    printf(
! 	    "    /ch%ld [ %.2f %.2f %.2f %.2f %.2f %ld %ld %.2f %.2f\n\t<",
! 		pc->pkc_char,
! 
! 		DOTS2UNITS((double) pc->pkc_dx / pow2(16)),	/* width */
! 
! 		DOTS2UNITS((double) -pc->pkc_x_off),		/* bblx */
! 		DOTS2UNITS((double) pc->pkc_y_off -
! 		    pc->pkc_height + 1),			/* bbly */
! 		DOTS2UNITS((double) -pc->pkc_x_off + pc->pkc_width),/* bbux */
! 		DOTS2UNITS((double) pc->pkc_height + pc->pkc_y_off),/* bbuy */
! 
  		r->ras_width,
  		r->ras_height,
  		(double) pc->pkc_x_off - .5,			/* shift x */
--- 167,245 ----
  	else
  	    highest = 256;
  
+ 	    /* define the "BuildChar" routine to generate a character */
  	printf("/BuildChar\n");
! 	    /* the "0" will be filled in with a new dictionary below */
! 	printf("{ 0 begin\n");
! 	    /* get the "font dictionary" parameter */
  	printf("	/char exch def\n");
+ 	    /* get the "character number" parameter */
  	printf("	/fontdict exch def\n");
+ 	    /* translate character number into character name from encoding */
  	printf("	/charname fontdict /Encoding get char get def\n");
! 	    /* get character info array */
! 	printf("	/charinfo fontdict /CharData get charname get def\n");
! 	    /* get character width from character info array */
  	printf("	/wx charinfo 0 get def\n");
+ 	    /* get character bounding box from character info array */
  	printf("	/charbbox charinfo 1 4 getinterval def\n");
+ 	    /* arrange to save the character in the font cache */
  	printf("	wx 0 charbbox aload pop setcachedevice\n");
+ 	    /* get bit array dimensions for "imagemask".
+ 	     * "true" means to paint where the 1-bits are */
  	printf("	charinfo 5 get charinfo 6 get true\n");
+ 	    /* get image mask matrix */
  	printf("	fontdict /imagemaskmatrix get\n");
+ 	    /* insert character translation info into image mask matrix */
  	printf("	    dup 4 charinfo 7 get put\n");
  	printf("	    dup 5 charinfo 8 get put\n");
+ 	    /* get bitmap data for the character */
  	printf("	charinfo 9 1 getinterval cvx\n");
+ 	    /* generate the character */
  	printf("	imagemask\n");
  	printf("    end\n");
! 	printf("} def %% BuildChar\n");
  	printf("\n");
+ 	    /* replace the first element (#0) of "BuildChar"
+ 	     * with a reference to a brand-new, empty dictionary */
  	printf("/BuildChar load 0 6 dict put\n");
  
! #define	KDOTS2UNITS(x)	(double) ((1000*(x)) / ((p->pkp_ds / (pow2(20) * POINT)) * 300))
  
! 	    /* define the image mask matrix */
! 	printf("/imagemaskmatrix [%.4f 0 0 -%.4f 0 0] def\n",
! 	    1.0 / KDOTS2UNITS((double) 1),
! 	    1.0 / KDOTS2UNITS((double) 1)
  	    );
+ 
+ 	    /* define the character data (bitmaps) */
+ 	if (!saw_space) chcount++;
  	printf("/CharData %d dict def\n", chcount+1);
  	printf("CharData begin\n");
! 	flx = fly = fux = fuy = 0;
  	for (pc = p->pkp_chars; pc; pc = pc->pkc_next) {
  	    register struct ras *r;
+ 	    c = pc->pkc_char;
  	    r = pkrast(pc);
  	    if (!r) {
  		fprintf(stderr, "%0: no raster image for %02x\n",
! 		    progname, c);
  		continue;
  	    }
! 	    lx = KDOTS2UNITS((double) -pc->pkc_x_off) + 0.5;
! 	    ly = KDOTS2UNITS((double) pc->pkc_y_off - pc->pkc_height + 1) + 0.5;
! 	    ux = KDOTS2UNITS((double) -pc->pkc_x_off + pc->pkc_width) + 0.5;
! 	    uy = KDOTS2UNITS((double) pc->pkc_y_off + 1) + 0.5;
! 	    if (lx < flx) flx = lx;
! 	    if (ly < fly) fly = ly;
! 	    if (ux > fux) fux = ux;
! 	    if (uy > fuy) fuy = uy;
! 	    if (c >= 32 && c <= 126)
! 		 printf ("    /%s ", adobecharnames[c-32]);
! 	    else printf ("    /ch%d ", c);
! 	    printf("[ %d %d %d %d %d %ld %ld %.1f %.1f\n\t<",
! 		(int) (KDOTS2UNITS((double) pc->pkc_dx / pow2(16)) + 0.5),
! 		lx, ly, ux, uy,
  		r->ras_width,
  		r->ras_height,
  		(double) pc->pkc_x_off - .5,			/* shift x */
***************
*** 179,198 ****
  	    len = r->ras_height * r->ras_bline;
  	    for (i = 0; i < len; i++) {
  		printf("%02x", r->ras_raster[i]);
! 		if (i % 30 == 29)
! 		    putchar('\n');
  	    }
  	    printf(">]\n    def\n");
  	    free(r->ras_raster);
  	    free(r);
  	}
! 	printf("    /.notdef [ .24 0 0 0 0 1 0 0 0 <>] def\n");
  
! 	printf("    end\n");
! 	/*	Should be unique enough between Postscript runs	*/
! 	printf("    /UniqueID %ld def\n", (long) getpid() + (optind << 16));
  	printf("end\n");
  	printf("/%s exch definefont pop\n", filebuf);
  
  	/* end of font definition */
  	if (!fontonly) {
--- 248,279 ----
  	    len = r->ras_height * r->ras_bline;
  	    for (i = 0; i < len; i++) {
  		printf("%02x", r->ras_raster[i]);
! 		if (i % 30 == 29 && i < len) printf ("\n\t ");
  	    }
  	    printf(">]\n    def\n");
  	    free(r->ras_raster);
  	    free(r);
  	}
! 	if (!saw_space)
! 	    printf("    /space [ %d 0 0 0 0 1 1 0 0 <>] def\n",
! 		   (int) (KDOTS2UNITS((double) sfp_hmi) + 0.5));
! 	printf("    /.notdef [ 0 0 0 0 0 1 0 0 0 <>] def\n");
! 	printf("end %% CharData\n");
! 
! 	    /* now that we've seen the whole font,
! 	     * we know the font bounding box values */
! 	printf("/FontBBox [%d %d %d %d] def\n", flx, fly, fux, fuy);
! 
! 	    /* set the "unique ID" to a random value.
! 	     * Adobe guarantees values from 4,000,000 to 4,999,999
! 	     * will never be assigned to a commercial font. */
! 	printf("/UniqueID %ld def\n",
! 		4000000 + ((long) getpid() + (optind << 16)) % 1000000);
  
! 	    /* give the font its name */
  	printf("end\n");
  	printf("/%s exch definefont pop\n", filebuf);
+ 	printf("%%%%EndFont: %s\n", filebuf);
  
  	/* end of font definition */
  	if (!fontonly) {
Index: ./utils/pk2sfp.c
*** /tmp/PATCHold/./utils/pk2sfp.c	Sat May 23 22:32:04 1992
--- ./utils/pk2sfp.c	Sat May 23 22:32:08 1992
***************
*** 10,16 ****
  
  #ifndef	lint
  static char SCCSID[] =
!     "@(#)pk2sfp.c 2.4 Copyright 91/02/20 09:09:52 Chris Lewis";
  #endif
  
  #include "defs.h"
--- 10,16 ----
  
  #ifndef	lint
  static char SCCSID[] =
!     "@(#)pk2sfp.c 2.6 Copyright 92/05/19 23:14:44 Chris Lewis";
  #endif
  
  #include "defs.h"
***************
*** 73,78 ****
--- 73,80 ----
  }
  #endif
  
+ int outscale = 0;
+ 
  main(argc, argv)
  int argc;
  char **argv; {
***************
*** 87,94 ****
  
      progname = argv[0];
  
!     while((c = getopt(argc, argv, "D:s:t:w:f:i:vmSpP")) != EOF) {
  	switch(c) {
  	    case 'D':
  #ifdef	DEBUG
  		setdebug(optarg, "diagnostics");
--- 89,104 ----
  
      progname = argv[0];
  
!     while((c = getopt(argc, argv, "o:D:s:t:w:f:i:vmSpP")) != EOF) {
  	switch(c) {
+ 	    case 'o':
+ 		outscale = atoi(optarg);
+ 		if (outscale <= 0) {
+ 		    fprintf(stderr, "%s: invalid -o value: %s\n",
+ 			progname, optarg);
+ 		    exit(1);
+ 		}
+ 		break;
  	    case 'D':
  #ifdef	DEBUG
  		setdebug(optarg, "diagnostics");
***************
*** 164,169 ****
--- 174,185 ----
  
  	/* Read the PK file in-core */
  	pk = pk_read(buf);
+ 	if (outscale) {
+ 	    struct pkp *opkp;
+ 	    opkp = pk;
+ 	    pk = pkscale(opkp, outscale);
+ 	    pk_destroy(opkp);
+ 	}
  
  	/* Overrides */
  	if (symset != NOTSET)
***************
*** 267,273 ****
  
  /*	similar to strtol */
  short
! cvt(p)
  register char *p; {
      register short ret = 0;
      int base = 10;
--- 283,289 ----
  
  /*	similar to strtol */
  short
! strtl(p)
  register char *p; {
      register short ret = 0;
      int base = 10;
***************
*** 282,292 ****
  	} else
  	    base = 8;
      while(*p)
! 	ret = ret * base + ccvt(*p++);
      return(ret);
  }
  
! ccvt(c)
  int c; {
      if (isdigit(c))
  	return(c - '0');
--- 298,308 ----
  	} else
  	    base = 8;
      while(*p)
! 	ret = ret * base + cstrtl(*p++);
      return(ret);
  }
  
! cstrtl(c)
  int c; {
      if (isdigit(c))
  	return(c - '0');
***************
*** 350,357 ****
  	    exit(1);
  	}
  
! 	flast->from = cvt(from);
! 	flast->to = cvt(to);
  	flast++;
      } while (fgets(buffer, sizeof(buffer), f));
      fclose(f);
--- 366,373 ----
  	    exit(1);
  	}
  
! 	flast->from = strtl(from);
! 	flast->to = strtl(to);
  	flast++;
      } while (fgets(buffer, sizeof(buffer), f));
      fclose(f);
Index: ./utils/psxlate.c
*** /tmp/PATCHold/./utils/psxlate.c	Sat May 23 22:32:29 1992
--- ./utils/psxlate.c	Sat May 23 22:32:36 1992
***************
*** 23,29 ****
   */
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)psxlate.c: 2.19 Copyright 92/01/23 14:22:16 Chris Lewis";
  #endif
  
  #ifdef	ALONE
--- 23,29 ----
   */
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)psxlate.c: 2.20 Copyright 92/03/12 01:11:56 Chris Lewis";
  #endif
  
  #ifdef	ALONE
***************
*** 496,502 ****
  	p[i+mid] = pageidx[i * 2 + 1];
      }
  
!     memcpy((char *) pageidx, p, sizeof(struct pagedesc) * pagecnt);
      free(p);
  }
  
--- 496,502 ----
  	p[i+mid] = pageidx[i * 2 + 1];
      }
  
!     memcpy((char *) pageidx, (char *) p, sizeof(struct pagedesc) * pagecnt);
      free(p);
  }
  
***************
*** 554,560 ****
  	p[i] = pageidx[i - mid + 1];
  	p[i+1] = pageidx[end-1];
      }
!     memcpy((char *) pageidx, p, sizeof(struct pagedesc) * pagecnt);
      free(p);
  
  }
--- 554,560 ----
  	p[i] = pageidx[i - mid + 1];
  	p[i+1] = pageidx[end-1];
      }
!     memcpy((char *) pageidx, (char *) p, sizeof(struct pagedesc) * pagecnt);
      free(p);
  
  }
Index: ./utils/showfont.S
*** /tmp/PATCHold/./utils/showfont.S	Sat May 23 22:33:02 1992
--- ./utils/showfont.S	Sat May 23 22:33:04 1992
***************
*** 5,11 ****
  #    See the LICENSE file for a full description of the restrictions
  #    under which this software is provided.
  #
! #@(#)showfont 2.2 91/02/20
  # Shell script to dump postscript fonts with widths into a pretty table
  # usage: showfont <fontname>
  # emits postscript to display the font called <fontname> along with
--- 5,11 ----
  #    See the LICENSE file for a full description of the restrictions
  #    under which this software is provided.
  #
! #@(#)showfont 2.3 92/05/21
  # Shell script to dump postscript fonts with widths into a pretty table
  # usage: showfont <fontname>
  # emits postscript to display the font called <fontname> along with
***************
*** 24,34 ****
  # the Character is displayed at 18 point.
  
  copies=1
- if [ $# = 0 ]
- then
-     echo "usage: showfont <fontname>" >&2
-     exit 1
- fi
  (
  cat << !END!
  %! PS-Adobe 1.0
--- 24,29 ----
***************
*** 49,54 ****
--- 44,52 ----
  case $font in
      /*)
  	font=`echo $font | sed -e 's/^.//'`
+ 	;;
+     '')
+ 	font='Times-Roman'
  	;;
  esac
  cat << !ENDTHING!
Index: ./adapters/Makefile
*** /tmp/PATCHold/./adapters/Makefile	Sat May 23 22:33:14 1992
--- ./adapters/Makefile	Sat May 23 22:33:14 1992
***************
*** 1,4 ****
! # 2.5 91/03/19
  ADAPTERS	= cmn.post cmn.pre tmac.an tmac.m tmac.s tmac.e cmn.dit
  MACROS		= tmac.t2
  
--- 1,4 ----
! # 2.7 92/04/26
  ADAPTERS	= cmn.post cmn.pre tmac.an tmac.m tmac.s tmac.e cmn.dit
  MACROS		= tmac.t2
  
***************
*** 16,20 ****
--- 16,22 ----
  install:
  	cd $(LIBDIR)/adapters ; rm -f $(ADAPTERS)
  	cp $(ADAPTERS) $(LIBDIR)/adapters
+ 	cd $(LIBDIR)/adapters ; chmod 444 $(ADAPTERS)
  	cd $(RTMACDIR) ; rm -f $(MACROS)
  	cp $(MACROS) $(T2DIR)
+ 	cd $(T2DIR) ; chmod 444 $(MACROS)
Index: ./checker.S
*** /tmp/PATCHold/./checker.S	Sat May 23 22:33:21 1992
--- ./checker.S	Sat May 23 22:33:23 1992
***************
*** 0 ****
--- 1,238 ----
+ trap "rm -f /tmp/$$.? ; exit 1" 0 1 2 3 15
+ echo "Automatic Psroff configuration tester.  V1.2 92/04/12"
+ type=
+ header=
+ troffnames="gtroff troff otroff cattroff catroff ditroff"
+ AS=undef
+ make=make
+ perl=
+ shell=/bin/sh
+ if [ -f /usr/apollo/bin/coffdump ]
+ then
+     echo "You're an Apollo!"
+     type=apollo
+     shell=/bin/ksh
+ fi
+ if [ -f /ultrixboot ]
+ then
+     case "`uname -a`" in
+ 	*RISC*)
+ 	    type=rult
+ 	    echo "You're a RISC/Ultrix machine!"
+ 	    ;;
+     esac
+     shell=/usr/bin/sh5
+     make=s5make
+ fi
+ if [ -r /usr/lib/font/ftR ]
+ then
+     header=/usr/lib/font/ftR
+ else
+     echo "No /usr/lib/font/ftR file:  Can't check it for CAT troff HEADERSIZE."
+     either=' either'
+ fi
+ cat > /tmp/$$.c <<\!
+ #include <stdio.h>
+ #include <a.out.h>
+ main() {
+     printf("%d\n", sizeof(struct exec));
+     exit(0);
+ }
+ !
+ cc -o /tmp/$$.a /tmp/$$.c > /dev/null 2>&1
+ if [ $? = 0 -a -f /tmp/$$.a ]
+ then
+     t=`/tmp/$$.a`
+     if [ $? = 0 ]
+     then
+ 	aoutheader=$t
+     fi
+ fi
+ if [ -z "$aoutheader" ]
+ then
+     echo "Can't compile a.out.h test: Can't check it for CAT troff HEADERSIZE$either."
+     echo "(This test only works on V7 or BSDish machines (Ultrix, Sun etc.) anyways.)"
+ fi
+ if [ -n "$header" ]
+ then
+     case "$type" in
+ 	apollo)
+ 	    set A `/usr/apollo/bin/coffdump -h $header | grep '\.data'`
+ 	    HS=`echo "16 i $5 p q" | sed -e 's/0x0*//' | dc`
+ 	    note=' /* Apollo cannot read own width tables - calc from coffdump */'
+ 	    ;;
+ 	rult)
+ 	    AS=define
+ 	    HS=0
+ 	    note=' /* ignored on Risc/Ultrix */'
+ 	    ;;
+ 	*)
+ 	    set A `ls -l $header`
+ 	    case $5 in
+ 		[0-9]*)
+ 		    v=$5
+ 		    ;;
+ 		*)
+ 		    v=$6
+ 		    ;;
+ 	    esac
+ 	    HS=`expr $v - 224`
+ 	    ;;
+ 	esac
+ fi
+ 
+ case $aoutheader.$HS in
+     [0-9]*.[0-9]*)
+ 	if [ $aoutheader -lt $HS ]
+ 	then
+ 	    note=" /* though, might be $HS */"
+ 	    HS=$aoutheader
+ 	elif [ $HS -lt $aoutheader ]
+ 	then
+ 	    note=" /* remotely $aoutheader */"
+ 	else
+ 	    note=" /* a.out.h and .../ftR agree */"
+ 	fi
+ 	;;
+     .)
+ 	note=" Nope, can't figure out HEADERSIZE"
+ 	;;
+ esac
+ 
+ paths=`echo $PATH | sed -e 's/:/ /g'`
+ for i in $paths
+ do
+     for j in $troffnames
+     do
+ 	if [ -f $i/$j ]
+ 	then
+ 	    troffs="$troffs $i/$j"
+ 	fi
+     done
+     if [ -f $i/lpr ]
+     then
+ 	lpr=1
+     fi
+     if [ -f $i/lp ]
+     then
+ 	lp=1
+     fi
+     if [ -f $i/hostname -a -z "$uuname" ]
+     then
+ 	uuname=hostname
+     fi
+     if [ -f $i/uuname -a -z "$uuname" ]
+     then
+ 	uuname='uuname -l'
+     fi
+     if [ -f $i/uname -a -z "$uuname" ]
+     then
+ 	uuname='uname -n'
+     fi
+     if [ -f $i/perl -a -z "$perl" ]
+     then
+ 	perl=$i/perl
+     fi
+ done
+ if [ -z "$perl" ]
+ then
+     perl="Not found: Won't be able to use catconv or buildljfonts"
+ fi
+ if [ -z "$uuname" ]
+ then
+     uuname='echo <your node name>'
+ fi
+ 
+ echo "***  Recommended defs.h settings: ***"
+ echo
+ echo "#define HEADERSIZE $HS$note"
+ echo "#$AS ASCIIWIDTHS"
+ echo '#define NODECMD	"'"$uuname"'"'
+ echo
+ echo "*** Recommended Makefile settings: ***"
+ echo
+ echo "MAKE = $make"
+ echo "SHELL = $shell"
+ echo "PERL = $perl"
+ echo
+ echo "*** psrofflib-related stuff: ***"
+ echo
+ if [ -n "$troffs" ]
+ then
+     for i in $troffs
+     do
+ 	echo "In order to use $i as your troff, you need to set:"
+ 	echo hello | $i > /dev/null 2>&1
+ 	ditroffokay=$?
+ 	echo hello | $i -t > /dev/null 2>&1
+ 	cattroffokay=$?
+ 
+ 	if [ $ditroffokay = 0 -a $cattroffokay != 0 ]
+ 	then
+ 	    echo "    troff=$i # ditroff: use -N option in t2arg"
+ 	    ditroff=1
+ 	    continue
+ 	fi
+ 	if [ $ditroffokay != 0 -a $cattroffokay = 0 ]
+ 	then
+ 	    echo "    troff=$i # is CAT troff"
+ 	    cattroff=1
+ 	    if echo hello | $i -F/usr/lib/font/ftXX -t > /dev/null 2>&1
+ 	    then
+ 		echo "    trofftype='-F%%FONTDIR%%/\$width/ftXX'"
+ 	    elif echo hello | $i -T. -t > /dev/null 2>&1
+ 	    then
+ 		echo "    trofftype='-T\$width'"
+ 		echo "    [ps: FONTDIR MUST be /usr/lib/font]"
+ 	    else
+ 		echo "    trofftype= # Neither -F nor -T seem to work"
+ 	    fi
+ 	    continue
+ 	fi 
+ 	echo "Can't tell what kind of troff $i is"
+     done
+ else
+     echo "Couldn't seem to find any versions of troff out there in your PATH"
+     echo "   (And I looked for $troffnames)"
+     notroff=1
+ fi
+ echo
+ if [ -n "$lpr" ]
+ then
+     echo "You have Berkeley style 'lpr'.  The lparg entry will typically"
+     echo "be something like lparg=| [F |] lpr -P\$ptr -#\$copies'"
+ fi
+ if [ -n "$lp" ]
+ then
+     echo "You have System V style 'lp'.  The lparg entry will typically"
+     echo "be something like lparg=| [F |] lp -n\$copies -d\$ptr'"
+ fi
+ if [ -n "$lp" -o -n "$lpr" ]
+ then
+     echo "Where 'F' is an additional filter, such as psxlate for PostScript"
+ fi
+ 
+ if [ -z "$lp" -a -z "$lpr" ]
+ then
+     echo "Can't find lp or lpr, so I can't make any suggestions on the lparg"
+     echo "entry."
+ fi
+ 
+ echo
+ echo "*** Overall automatic configurator error report) ***"
+ if [ -z "$cattroff" -a -z "$ditroff" ]
+ then
+     echo "- You con't have any kind of troff in your search path."
+     echo "  Unless you can find one, you can't use psroff."
+ fi
+ if [ -n "$cattroff" -a -z "$HS" ]
+ then
+     echo "- You have CAT troff, but I couldn't figure out your HEADERSIZE."
+     echo "  You should probably ask for help."
+ fi
+ if [ -z "$perl" ]
+ then
+     echo "- Couldn't find perl - just means you can't emulate ditroff in CAT troff"
+ fi
+ trap '' 0
+ exit 0
Index: ./utils.c
*** /tmp/PATCHold/./utils.c	Sat May 23 22:33:32 1992
--- ./utils.c	Sat May 23 22:33:34 1992
***************
*** 12,18 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)utils.c: 2.23 Copyright 92/01/12 03:55:40 Chris Lewis";
  #endif
  
  #ifndef	HEADERSIZE
--- 12,18 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)utils.c: 2.24 Copyright 92/05/21 02:58:25 Chris Lewis";
  #endif
  
  #ifndef	HEADERSIZE
***************
*** 410,431 ****
  }
  
  FontSel(from, to)
! char from, *to; {
  #ifdef	DEBUG
      register int i;
  #endif
      register struct fonttable *p;
      int intfont;
!     DBP((D_SPEC, "FontSel: %c -> %s\n", from, to));
! #ifdef	DIT
!     if (from < (ditroff? '0' : '1') || from > '9') {
! #else
!     if (from < '1' || from > '9') {
! #endif
! 	fprintf(stderr, "Bad arguments to FontSel: %c %s\n", from, to);
  	return;
      }
!     intfont = from - '1';
      if (intfont < 0)
  	intfont = INTFONTS - 1;
      if (strcmp(to, "S") == 0) {
--- 410,432 ----
  }
  
  FontSel(from, to)
! char *from, *to; {
  #ifdef	DEBUG
      register int i;
  #endif
      register struct fonttable *p;
      int intfont;
!     DBP((D_SPEC, "FontSel: %s -> %s\n", from, to));
! 
!     intfont = atoi(from);
! 
!     if (intfont < (ditroff? 0 : 1) || intfont >= INTFONTS) {
! 	fprintf(stderr, "Bad arguments to FontSel: %s %s\n", intfont, to);
  	return;
      }
! 
!     intfont -= 1;
! 
      if (intfont < 0)
  	intfont = INTFONTS - 1;
      if (strcmp(to, "S") == 0) {
***************
*** 443,449 ****
  	    break;
  	}
      if (!p->troffName) {
! 	fprintf(stderr, "Could not translate font %c (%s)\n", from, to);
      }
  #ifdef	OPT
      if (p->troffName && !p->widthtable)
--- 444,450 ----
  	    break;
  	}
      if (!p->troffName) {
! 	fprintf(stderr, "Could not translate font %s (%s)\n", from, to);
      }
  #ifdef	OPT
      if (p->troffName && !p->widthtable)
Index: ./ps.c
*** /tmp/PATCHold/./ps.c	Sat May 23 22:33:46 1992
--- ./ps.c	Sat May 23 22:33:48 1992
***************
*** 15,21 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)ps.c: 2.18 Copyright 92/01/12 03:55:46 Chris Lewis";
  #endif
  
  /*	ps.c will generate some additional "print" commands to cause
--- 15,21 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)ps.c: 2.19 Copyright 92/05/19 23:11:03 Chris Lewis";
  #endif
  
  /*	ps.c will generate some additional "print" commands to cause
***************
*** 341,358 ****
  	}
  
  	fp->flags |= USED;
  #ifdef	FONTMACRO
! 	printf("/%s %d SetFont\n", fp->fontName, points);
  #else
  	printf("/%s dup /curFont exch def findfont\n",
  	    fp->fontName);
  	printf("%d dup /curPoints exch def scalefont setfont\n", points);
  #endif
  	lastPoints = points;
  	lastFont = font;
      }
  }
  
  psChar(x, y, font, points, troffChar, sequence)
  int x, y;
  int font, points, troffChar;
--- 341,378 ----
  	}
  
  	fp->flags |= USED;
+ #define NEW
+ #ifdef NEW
+ 	printf("%d F%d\n", points, fp - fonttable);
+ #else
  #ifdef	FONTMACRO
! 	printf("/%s %d S\n", fp->fontName, points);
  #else
  	printf("/%s dup /curFont exch def findfont\n",
  	    fp->fontName);
  	printf("%d dup /curPoints exch def scalefont setfont\n", points);
  #endif
+ #endif
  	lastPoints = points;
  	lastFont = font;
      }
  }
  
+ putseq(sequence)
+ register char *sequence; {
+     putchar('(');
+     while(*sequence) {
+ 	if ((*sequence)&0x80)
+ 	    printf("\\%03o", (*sequence++)&0xff);
+ 	else if (*sequence == '(' || *sequence == ')' ||
+ 	    *sequence == '\\')
+ 	    printf("\\%c", *sequence++);
+ 	else
+ 	    putchar(*sequence++);
+     }
+     putchar(')');
+ }
+ 
  psChar(x, y, font, points, troffChar, sequence)
  int x, y;
  int font, points, troffChar;
***************
*** 423,428 ****
--- 443,462 ----
  
      DBP((D_BEND,"AFTER (sequence,x,y,font,points) = (%s,%d,%d,%d,%d)\n",
  	sequence, nx, ny, font, points));
+     
+ #ifdef SPACEOPT
+     { extern int spcwidth, spccount, spcnom;
+ 	if (spcwidth && spcwidth != spcnom) {
+ 	    putseq(sequence);
+ 	    lastYPos = ny;
+ 	    emitnums(TROFF2PSX(spcwidth) - TROFF2PSX(spcnom)); /* accurate enough? */
+ 	    emitnums(nx);
+ 	    emitnums(ny);
+ 	    putnl("W");
+ 	    return;
+ 	}
+     }
+ #endif
  
      if (rp->t2b_font == D) {
  	emitnums(nx);
***************
*** 434,450 ****
  	    putchar(' ');
  	    emitnum(ny);
  	}
! 	putchar('(');
! 	while(*sequence) {
! 	    if ((*sequence)&0x80)
! 		printf("\\%03o", (*sequence++)&0xff);
! 	    else if (*sequence == '(' || *sequence == ')' ||
! 		*sequence == '\\')
! 		printf("\\%c", *sequence++);
! 	    else
! 		putchar(*sequence++);
! 	}
! 	putchar(')');
  	if (lastYPos != ny) {
  	    lastYPos = ny;
  	    putchar('Y');
--- 468,474 ----
  	    putchar(' ');
  	    emitnum(ny);
  	}
! 	putseq(sequence);
  	if (lastYPos != ny) {
  	    lastYPos = ny;
  	    putchar('Y');
***************
*** 499,504 ****
--- 523,529 ----
      char buffer[30];
      FILE *library;
      long curtime;
+     register struct fonttable *p;
  
      currentPage = 0;
      pagePending = 1;
***************
*** 537,542 ****
--- 562,575 ----
  #endif
      printf("usertime /btime exch def\n");
      psXlate(library, "lib.ps");
+ 
+     for (p = fonttable; p->troffName; p++) {
+ 	if (p->fontName[0] == '_')
+ 	    printf("stdencoding /%s /%s RE\n",
+ 		p->fontName, p->fontName+1);
+ 	printf("/F%d { /%s exch S } bind def\n",
+ 	    p - fonttable, p->fontName);
+     }
      doprologs();
      printf("%%%%EndProlog\n");
      fclose(library);
Index: ./dit.c
*** /tmp/PATCHold/./dit.c	Sat May 23 22:34:04 1992
--- ./dit.c	Sat May 23 22:34:06 1992
***************
*** 12,18 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)dit.c: Copyright 92/03/03 02:25:40 Chris Lewis";
  #endif
  
  extern struct cattab tabN[], tabS[], *extidx;
--- 12,18 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)dit.c: Copyright 92/05/21 02:58:07 Chris Lewis";
  #endif
  
  extern struct cattab tabN[], tabS[], *extidx;
***************
*** 151,158 ****
      char special[512];
      fixtab();
      DBP((D_CAT, "Finished fixtab\n"));
      while(1) {
! 	switch(cmd = skipwhite()) {
  	    case EOF:
  		goto finish;
  	    case 's':
--- 151,170 ----
      char special[512];
      fixtab();
      DBP((D_CAT, "Finished fixtab\n"));
+     cmd = skipwhite();
+     if (cmd == 0x40) {
+ 	fprintf(stderr, "%s: illegal starting sequence for ditroff.\n",
+ 	    progname);
+ 	fprintf(stderr, "I think this is really CAT troff output.\n");
+ 	fprintf(stderr, "Please double check your troff & -N settings.\n");
+ 	exit(1);
+     }
      while(1) {
! 	switch(cmd) {
! 	    default:
! 		fprintf(stderr, "%s: illegal command 0x%02x.\n", progname, cmd);
! 		break;
! 		/*NOTREACHED*/
  	    case EOF:
  		goto finish;
  	    case 's':
***************
*** 278,284 ****
  		    canonflush();
  #endif
  		    /* synchronize special X & Y to current position
! 		       (ie: so psfig will work */
  		    specXPos = DIT2CAT(xpos);
  		    specYPos = DIT2CAT(ypos);
  
--- 290,296 ----
  		    canonflush();
  #endif
  		    /* synchronize special X & Y to current position
! 		       (ie: so psfig will work) */
  		    specXPos = DIT2CAT(xpos);
  		    specYPos = DIT2CAT(ypos);
  
***************
*** 307,313 ****
  			    }
  			    sprintf(special, "F%s%s", a1, a2);
  			    DBP((D_CAT, "FONT %s %s\n", a1, a2));
! 			    dospecial(special);
  			    break;
  			case 'r':	/* specify resolution */
  			    if (i != 4) {
--- 319,328 ----
  			    }
  			    sprintf(special, "F%s%s", a1, a2);
  			    DBP((D_CAT, "FONT %s %s\n", a1, a2));
! 
! 			    if (be->befontsel)
! 				(*be->befontsel)(a1,a2);
! 
  			    break;
  			case 'r':	/* specify resolution */
  			    if (i != 4) {
***************
*** 469,474 ****
--- 484,490 ----
  		}
  		break;
  	}
+ 	cmd = skipwhite();
      }
      finish: ;
  }
Index: ./README
*** /tmp/PATCHold/./README	Sat May 23 22:34:19 1992
--- ./README	Sat May 23 22:34:24 1992
***************
*** 1,4 ****
! 		PSROFF RELEASE 3.0 README 2.23 92/01/28
  
  			Feb 19, 1991
  			Chris Lewis
--- 1,4 ----
! 		PSROFF RELEASE 3.0 README 2.24 92/05/23
  
  			Feb 19, 1991
  			Chris Lewis
***************
*** 397,417 ****
  special commands (eg: the .fp fakeouts) will be converted over to the FSA
  mechanism.
  
- You may have noticed a compile flag called "OPT" which is defined in
- the distributed version of defs.h.  If enabled (via -Z/W), this enables the
- optimizer.  It works well with Postscript output, but not with laserjet
- unless the fonts you use are VERY good.  It's enabled by default for ps.
- The optimizer does two things: it emits as many characters as it can as one
- print directive, rather than one CAT code per print.  On postscript and
- HPLJ's this is a BIG win (printer execution speeds 3 or more times faster),
- and is essential with ditroff output to psdit and xtroff.  The optimizer
- requires access to the CAT troff width tables (even when used with ditroff),
- and if troff2ps can't find them, it will abort.
- 
  Hpinterp was borrowed and converted into a general HP LJ to PBM
  converter.  This permits the output of psroff to be printed on
  just about ANY printer.  The new version of hpinterp (now called
! hp2pbm) will eventually be reintegrated back into psroff.
  
  Psroff limitations:
      - With the use of catconv and CAT troff, psroff supports:
--- 397,407 ----
  special commands (eg: the .fp fakeouts) will be converted over to the FSA
  mechanism.
  
  Hpinterp was borrowed and converted into a general HP LJ to PBM
  converter.  This permits the output of psroff to be printed on
  just about ANY printer.  The new version of hpinterp (now called
! hp2pbm) will eventually be reintegrated back into psroff.  Hp2pbm is
! currently available from comp.sources.misc archives.
  
  Psroff limitations:
      - With the use of catconv and CAT troff, psroff supports:
***************
*** 432,440 ****
  	- Psroff only supports CAT troff sizes in HPPCL (some mechanism to relax
  	  this for HPLJIII's is easy to implement).  All sizes are available in
  	  Postscript and ditroff.
- 	- psroff doesn't implement "w" (word breaks in ditroff output).
- 	- psroff doesn't support "stipple" (I have NO idea what this is -
- 	  apparently a Berkeleyism.)
  
  CONTACT INFO (note that I've moved):
  
--- 422,427 ----
Index: ./troff2.c
*** /tmp/PATCHold/./troff2.c	Sat May 23 22:34:41 1992
--- ./troff2.c	Sat May 23 22:34:43 1992
***************
*** 12,18 ****
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)troff2.c: 2.22 Copyright 91/10/17 11:58:25 Chris Lewis";
  #endif
  
  #define	ESC	0x80
--- 12,18 ----
  
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)troff2.c: 2.25 Copyright 92/05/21 02:58:15 Chris Lewis";
  #endif
  
  #define	ESC	0x80
***************
*** 92,98 ****
  
  extern char *realloc();
  
! #define	OPTLIST	"d:O:Y:T:VD:l:MR:P::zp:W:ZNnSG:"
  
  /*	On 386/ix 1.0.6 profiling has a bug in it that leaves
  	two extra longs on the stack between the stack frame and
--- 92,98 ----
  
  extern char *realloc();
  
! #define	OPTLIST	"d:O:Y:T:VD:l:MR:P::zp:W:ZNnSG:g:"
  
  /*	On 386/ix 1.0.6 profiling has a bug in it that leaves
  	two extra longs on the stack between the stack frame and
***************
*** 114,119 ****
--- 114,120 ----
  	register int nc, c;
  	register int units;
  	register int rail, mag, tilt, half, escape, lead;
+ 	char *p;
  
  	extern int getopt();
  	extern char *optarg;
***************
*** 158,163 ****
--- 159,181 ----
  		case 'Z':
  		    optimize = 1;
  		    break;
+ 		case 'g':
+ 		    optimize = 1;
+ 		    for (p = optarg; *p; p++) {
+ 			if (*p == '.')
+ 			    fixedperiodwidth = 1;
+ 			else if (*p == 'l') {
+ 			    spaceopt = 1;
+ 			    optrun = OPTSIZ - 5;
+ 			} else {
+ 			    optrun = atoi(p);
+ 			    if (optrun > OPTSIZ - 5)
+ 				optrun = OPTSIZ - 5;
+ 			    break;
+ 			}
+ 		    }
+ 		    break;
+ 			
  		case 'W':
  		    widthtables = mustmalloc(strlen(optarg) + 10, "widthname");
  		    strcpy(widthtables, optarg);
***************
*** 321,326 ****
--- 339,353 ----
  	}
  #endif
  
+ 	c = getc(stdin);
+ 	if (c != 0x40) {
+ 	    fprintf(stderr, "%s: first character 0x%02x - not CAT troff output.\n",
+ 		progname, c);
+ 	    fprintf(stderr,
+ 		"Probably ditroff.  Did you forget -N in command line or psrofflib?\n");
+ 	    exit(1);
+ 	}
+ 
  	if (be->beprolog)
  	    (*be->beprolog)();
  
***************
*** 338,344 ****
  	tilt = DOWN;
  	calcfont;
  
! 	while ((c = getc(stdin)) != EOF) {
  		switch(c) {
  		case 0x00:
  			DBP((D_CAT,"NOP\n"));
--- 365,372 ----
  	tilt = DOWN;
  	calcfont;
  
! 
! 	while (c != EOF) {
  		switch(c) {
  		case 0x00:
  			DBP((D_CAT,"NOP\n"));
***************
*** 610,615 ****
--- 638,644 ----
  			DBP((D_CAT,"Illegal: %02x\n", c));
  			break;
  		}
+ 	    c = getc(stdin);
  	}
  #ifdef	OPT
  	canonflush();
***************
*** 802,809 ****
  		}
  
  	    case 'F':
! 		if (be->befontsel)
! 		    (*be->befontsel)(*(string+1), string+2);
  		*string ='\0';
  		return;
  #ifdef	FORM
--- 831,842 ----
  		}
  
  	    case 'F':
! 		if (be->befontsel) {
! 		    char tmp[2];
! 		    tmp[0] = string[1];
! 		    tmp[1] = 0;
! 		    (*be->befontsel)(tmp, string+2);
! 		}
  		*string ='\0';
  		return;
  #ifdef	FORM
Index: ./defs.h
*** /tmp/PATCHold/./defs.h	Sat May 23 22:34:57 1992
--- ./defs.h	Sat May 23 22:34:59 1992
***************
*** 9,15 ****
   */
  
  /*	Official Release and Patch level:	*/
! #define	T2VERSION	"@(#)PSROFF Copyright 92/02/10 Chris Lewis - R3 PL10"
  
  /*	Configuration parameters:
   */
--- 9,15 ----
   */
  
  /*	Official Release and Patch level:	*/
! #define	T2VERSION	"@(#)PSROFF Copyright 92/05/21 Chris Lewis - R3 PL11"
  
  /*	Configuration parameters:
   */
***************
*** 121,131 ****
   */
  
  /*	Basic drivers: */
  #define	PS	/* Postscript */
  #define	LJ	/* Laserjet - utils programs will not build with this undef'd */
  #define	LJ3	/* Laserjet 3 - does LJ + HP-GL/2 for PIC */
  #define	DT	/* ditroff */
- #define	DIT	/* ditroff *front-end* */
  
  /*	Laserjet driver config: */
  #define	PK	/* enable PK font downloading (needs LJ) */
--- 121,132 ----
   */
  
  /*	Basic drivers: */
+ #define	DIT	/* ditroff *front-end* */
  #define	PS	/* Postscript */
+ #ifndef PSONLY
  #define	LJ	/* Laserjet - utils programs will not build with this undef'd */
  #define	LJ3	/* Laserjet 3 - does LJ + HP-GL/2 for PIC */
  #define	DT	/* ditroff */
  
  /*	Laserjet driver config: */
  #define	PK	/* enable PK font downloading (needs LJ) */
***************
*** 137,142 ****
--- 138,144 ----
  #define	PARTIAL	/* partial (not incremental) font downloading */
  
  #define	INCR	/* enable incremental font downloading (needs PARTIAL) */
+ #endif
  
  #define	MDLF	16	/* Max # downloaded fonts permitted by your laserjet
  			   per *page*.  16 is correct for HPLJ+ and most II's.
***************
*** 155,160 ****
--- 157,164 ----
  			   to have this turned on */
  
  #define	OPT		/* CAT code reorder and optimizer */
+ #define SPACEOPT	/* hyperoptimization */
+ #define OPTSIZ 200	/* size of optimizer buffer */
  
  #define	DEFPL  11	/* Default page length (11 inches).
  			   DO NOT change unless you absolutely HAVE to.
***************
*** 225,231 ****
  #include	"Can't define SFP without PK"
  #endif
  
! #if	!defined(LJ) || !defined(PK)
  #include	"Sorry, can't compile without LJ and PK (for now)"
  #endif
  
--- 229,235 ----
  #include	"Can't define SFP without PK"
  #endif
  
! #if	!defined(PSONLY) && (!defined(LJ) || !defined(PK))
  #include	"Sorry, can't compile without LJ and PK (for now)"
  #endif
  
***************
*** 430,435 ****
--- 434,441 ----
  extern char *mustmalloc();
  
  extern char *version, *shortversion;
+ 
+ extern int optrun, fixedperiodwidth, spaceopt;
  
  #define	MAXPAGE	2000
  #ifdef	ALONE
Index: ./INSTALL
*** /tmp/PATCHold/./INSTALL	Sat May 23 22:35:21 1992
--- ./INSTALL	Sat May 23 22:35:25 1992
***************
*** 1,5 ****
  		Psroff 3.0 Installation Instructions
! 			2.17 92/01/12
  
  Please see the TROUBLE file if you have difficulties.
  The README file does provide a bit more background on some
--- 1,5 ----
  		Psroff 3.0 Installation Instructions
! 			2.18 92/05/23
  
  Please see the TROUBLE file if you have difficulties.
  The README file does provide a bit more background on some
***************
*** 89,98 ****
  	  see if we can get DEC to put it in as a update]
  
  	  Apollos need the -F trofftype variant.  Their HEADERSIZE
! 	  calculation is strange.  If you are SR10.3, set HEADERSIZE
! 	  to 304.  On SR10.2 and earlier, set HEADERSIZE to 336.
! 	  If this doesn't work out, consult the TROUBLE file
! 	  on "HEADERSIZE calculations".
  
  	- NOTE: during installs as root, the makefiles attempt to be
  	  careful about the modes of the files it creates.  HOWEVER,
--- 89,97 ----
  	  see if we can get DEC to put it in as a update]
  
  	  Apollos need the -F trofftype variant.  Their HEADERSIZE
! 	  calculation is strange.  It appears that HEADERSIZE should
! 	  always be set to 304.  "make check" should give the right
! 	  result.
  
  	- NOTE: during installs as root, the makefiles attempt to be
  	  careful about the modes of the files it creates.  HOWEVER,
***************
*** 121,138 ****
  	  lib/*.lib) are field-configurable, and it is possible I
  	  will patch a few of them later (particularly lj.fonts).
  
! 	- If you are using the supplied width tables (widths/widthps),
! 	  all is fine.  But, if you're going to be driving another
! 	  package (eg: jetroff, tpscript, psdit etc.) I suggest
! 	  you find the ditroff-format ASCII width tables (DESC, R, I,
! 	  S etc.), copy them to the appropriate widths/width<xx> area,
! 	  modify psrofflib.S to know how to use these width tables,
! 	  and possibly create *.fonts and *.lib files.  psrofflib.S
! 	  has copious comments on how to configure psroff.
  
! 	  xtroff is supposedly already set - it should work
! 	  "out-of-the-box".  Patch level 10 for xtroff is preferred.
! 	  [Contact moraes@cs.toronto.edu for more details]
  
  	  psdit, tpscript, xtroff, Pageview, Display Postscript and
  	  xproof work reasonably well using the Postscript widths in
--- 120,134 ----
  	  lib/*.lib) are field-configurable, and it is possible I
  	  will patch a few of them later (particularly lj.fonts).
  
! 	- Any of the configurations mentioned in psrofflib.S should
! 	  work fine, given that you make the proper configuration
! 	  changes for your system.  In some cases, particularly
! 	  when you want to use a different ditroff-2-something converter
! 	  from CAT troff, you will have to copy the width tables into
! 	  widths/widthxx, and make up your own psrofflib.S entries.
  
! 	  Patch level 10 for xtroff is preferred.  [Contact
! 	  moraes@cs.toronto.edu for more details]
  
  	  psdit, tpscript, xtroff, Pageview, Display Postscript and
  	  xproof work reasonably well using the Postscript widths in
Index: ./Makefile
*** /tmp/PATCHold/./Makefile	Sat May 23 22:35:59 1992
--- ./Makefile	Sat May 23 22:36:06 1992
***************
*** 7,13 ****
  #    Function: Upper level makefile; configuration options.
  #
  #
! #ident  "@(#)Makefile: 2.31 Copyright 92/02/21 09:31:19 Chris Lewis"
  
  #	If you're not sure whether you have a System V make, leave
  #	this alone, and run the make anyways.  If it dies horribly
--- 7,13 ----
  #    Function: Upper level makefile; configuration options.
  #
  #
! #ident  "@(#)Makefile: 2.33 Copyright 92/05/21 02:21:05 Chris Lewis"
  
  #	If you're not sure whether you have a System V make, leave
  #	this alone, and run the make anyways.  If it dies horribly
***************
*** 212,218 ****
  CFLAGS	= $(DEFINES)
  
  all:	troff2ps myuid subst.done makeincl psroff README TROUBLE LASERFONTS \
! 	MISC DITROFF INSTALL LICENSE LJIII zap submakes
  
  subst.done:	sedscript
  	rm -f psroff makeincl
--- 212,218 ----
  CFLAGS	= $(DEFINES)
  
  all:	troff2ps myuid subst.done makeincl psroff README TROUBLE LASERFONTS \
! 	MISC DITROFF INSTALL LICENSE LJIII zap pkscale.o submakes
  
  subst.done:	sedscript
  	rm -f psroff makeincl
***************
*** 284,289 ****
--- 284,290 ----
  	test -d $(LIBDIR) || mkdir $(LIBDIR)
  	test -d $(LIBDIR)/lib || mkdir $(LIBDIR)/lib
  	test -d $(LIBDIR)/lib/lj || mkdir $(LIBDIR)/lib/lj
+ 	chmod 755 $(LIBDIR) $(LIBDIR)/lib $(LIBDIR)/lib/lj
  	$(IGNORESH) files=`echo fonts.lj/*.pk` ; \
  	if [ "$$files" != 'fonts.lj/*.pk' ] ; \
  	then \
***************
*** 312,325 ****
  install:	makeincl myuid
  	test "`./myuid`" = 0 || \
  	    ( echo "ERROR: You must be root to install" ; exit 1 )
! 	test -d $(BINDIR) || mkdir $(BINDIR)
  	test -d $(MANDIR) || \
  	    echo "No MANDIR directory.  Have you got MANDIR right?"
  	test -d $(LIBDIR) || mkdir $(LIBDIR)
  	test -d $(LIBDIR)/adapters || mkdir $(LIBDIR)/adapters
  	test -d $(LIBDIR)/lib || mkdir $(LIBDIR)/lib
! 	test -d $(RTMACDIR) || mkdir $(RTMACDIR)
! 	test -d $(FONTDIR) || mkdir $(FONTDIR)
  	rm -f $(BINDIR)/psroff.old
  	-cp $(BINDIR)/psroff $(BINDIR)/psroff.old 2> /dev/null
  	cp psroff $(BINDIR)/psroff
--- 313,327 ----
  install:	makeincl myuid
  	test "`./myuid`" = 0 || \
  	    ( echo "ERROR: You must be root to install" ; exit 1 )
! 	test -d $(BINDIR) || (mkdir $(BINDIR) ; chmod 755 $(BINDIR) )
  	test -d $(MANDIR) || \
  	    echo "No MANDIR directory.  Have you got MANDIR right?"
  	test -d $(LIBDIR) || mkdir $(LIBDIR)
  	test -d $(LIBDIR)/adapters || mkdir $(LIBDIR)/adapters
  	test -d $(LIBDIR)/lib || mkdir $(LIBDIR)/lib
! 	test -d $(RTMACDIR) || (mkdir $(RTMACDIR) ; chmod 755 $(RTMACDIR) )
! 	test -d $(FONTDIR) || (mkdir $(FONTDIR) ; chmod 755 $(FONTDIR) )
! 	chmod 755 $(LIBDIR) $(LIBDIR)/adapters $(LIBDIR)/lib
  	rm -f $(BINDIR)/psroff.old
  	-cp $(BINDIR)/psroff $(BINDIR)/psroff.old 2> /dev/null
  	cp psroff $(BINDIR)/psroff
***************
*** 440,452 ****
  dittest:	DITTEST
  	eqn DITTEST | tbl | PATH=:.:$(LIBDIR):$$PATH psroff -T$(TTYPE) $(TFLAGS)
  
! check:	audit sedscript makeincl
! 	cd lib ; $(MAKE)
! 	./audit
  
! checkinstall:	audit sedscript makeincl
! 	cd lib ; $(MAKE)
! 	./audit install
  
  #	This is how I build a release - don't even try running this...!
  buildrelease:	clean unpackljfonts
--- 442,452 ----
  dittest:	DITTEST
  	eqn DITTEST | tbl | PATH=:.:$(LIBDIR):$$PATH psroff -T$(TTYPE) $(TFLAGS)
  
! check:	checker.S
! 	sh ./checker.S
  
! checkinstall:
! 	@echo "No longer supported"
  
  #	This is how I build a release - don't even try running this...!
  buildrelease:	clean unpackljfonts
***************
*** 480,482 ****
--- 480,486 ----
  	    ( echo "ERROR: You must be root to fixperms" ; exit 1 )
  	find $(LIBDIR) -type f -exec chmod +r '{}' ';'
  	find $(LIBDIR) $(FONTDIR) -type d -exec chmod +rx '{}' ';'
+ 
+ #	Leaves manual pages and width tables installed.  Oh well.
+ deinstall:
+ 	rm  -fr $(LIBDIR) $(RTMACDIR)/tmac.t2 $(BINDIR)/psroff
Index: ./opt.c
*** /tmp/PATCHold/./opt.c	Sat May 23 22:36:24 1992
--- ./opt.c	Sat May 23 22:36:29 1992
***************
*** 10,22 ****
  
  #include "defs.h"
  
  int specXPos, specYPos;
  extern struct cattab tabN[], tabS[];
  
  #ifdef	OPT
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)opt.c: 2.8 Copyright 92/01/23 14:23:52 Chris Lewis";
  #endif
  
  struct insbuf {
--- 10,29 ----
  
  #include "defs.h"
  
+ int optrun = 15;
+ int fixedperiodwidth = 0;
+ int spaceopt = 0;
+ 
  int specXPos, specYPos;
  extern struct cattab tabN[], tabS[];
+ #ifdef SPACEOPT
+ int spcwidth, spccount, spcnom;
+ #endif
  
  #ifdef	OPT
  #ifndef	lint
  static char SCCSid[] =
!     "@(#)opt.c: 2.11 Copyright 92/05/21 02:21:16 Chris Lewis";
  #endif
  
  struct insbuf {
***************
*** 25,31 ****
  };
  
  #define	INSBUFSIZ	200
- #define	OPTSIZ	100
  struct insbuf insbuf[INSBUFSIZ];
  static struct insbuf *insptr = insbuf;
  static int insypos = -1;
--- 32,37 ----
***************
*** 181,187 ****
  }
  
  int optxpos, optypos;
! int optfont, optpoints, optnc, origxpos;
  char optbuffer[OPTSIZ];
  short optloc[OPTSIZ];
  short *optloci;
--- 187,193 ----
  }
  
  int optxpos, optypos;
! int optfont, optpoints, optnc, origxpos, optsymset, optcnt=0;
  char optbuffer[OPTSIZ];
  short optloc[OPTSIZ];
  short *optloci;
***************
*** 191,196 ****
--- 197,208 ----
  
      if (!optimize)
  	return;
+ #if defined(DEBUG) && defined(SPACEOPT)
+     if ((debug&D_CHAR) && spcwidth) {
+ 	DBP((D_CHAR, "LOPT: x,y,sw,sc,nl,s: %d,%d,%d,%d,%d\n",
+ 	    origxpos, optypos, spcwidth, spccount, spcnom, optbuffer));
+     }
+ #endif
  
      if (optbuffer[0] && be->beputchar)
  	(*be->beputchar)(origxpos, optypos, optfont, optpoints, optnc,
***************
*** 198,203 ****
--- 210,219 ----
      optbuffer[0] = '\0';
      optp = optbuffer;
      optloci = optloc;
+     optcnt = 0;
+ #ifdef SPACEOPT
+     spccount = spcwidth = 0;
+ #endif
  }
  
  optinsert(xpos, ypos, font, points, nc)
***************
*** 209,215 ****
      struct cattab *ct;
      register char *from;
      int cantcache;
!     static int ditind = 0;
  
      if (!optimize) {
  	if (be->beputchar)
--- 225,231 ----
      struct cattab *ct;
      register char *from;
      int cantcache;
!     static int ditind = 0, psind = 0;
  
      if (!optimize) {
  	if (be->beputchar)
***************
*** 232,238 ****
         long multiple-character sequences */
  
      if (ypos != optypos || optfont != font || optpoints != points ||
! 	wp != xlatetable[font]->widthtable ||
  	optp > optbuffer + OPTSIZ - 10)
  	optflush();
  
--- 248,254 ----
         long multiple-character sequences */
  
      if (ypos != optypos || optfont != font || optpoints != points ||
! 	wp != xlatetable[font]->widthtable || optcnt >= optrun ||
  	optp > optbuffer + OPTSIZ - 10)
  	optflush();
  
***************
*** 246,266 ****
  	ct = &tabN[nc];
      }
  
!     cantcache = !wp || (int) wp == 1 || (font == symidx ? bp->t2b_font != S:
! 			     bp->t2b_font != N)
! #ifndef	FIXEDPERIODWIDTH
! 			     /* period widths are screwed in Postscript */
! 			     || (font != symidx && nc == 35)
! #endif
  			;
  
!     if (cantcache || bp->t2b_xc || bp->t2b_yc || bp->t2b_scale)
  	optflush();
  
      DBP((D_CAT, "opt: font: %d/%d xpos: %d/%d\n",
  	optfont, font, optxpos, xpos));
  
!     if (optxpos != xpos)	/* handle spaces one day... */
  	optflush();
  
      if (!optbuffer[0]) {
--- 262,321 ----
  	ct = &tabN[nc];
      }
  
!     cantcache = !wp || (int) wp == 1 
! 			     || bp->t2b_xc || bp->t2b_yc || bp->t2b_scale
! 			     || bp->t2b_font == D
! 			     /* period widths are screwed in some Postscript
! 				interpreters */
! 			     || (!fixedperiodwidth && (font != symidx && nc == 35))
  			;
  
!     if (cantcache || 
! 	(optbuffer[0] ? (bp->t2b_font != optsymset) :
! 	    (font == symidx ? bp->t2b_font != S : bp->t2b_font != N)))
  	optflush();
  
      DBP((D_CAT, "opt: font: %d/%d xpos: %d/%d\n",
  	optfont, font, optxpos, xpos));
  
! #ifdef SPACEOPT
!     if (!psind)
! 	if (strcmp(be->bename, "ps") == 0)
! 	    psind = 1;
! 	else
! 	    psind = -1;
!     if (spaceopt && psind == 1 && optbuffer[0] && optxpos != xpos &&
! 	optcnt < optrun - 5 && bp->t2b_font == N) {
! 	/* possible blank/space optimization */
! 
! 	if (!spcwidth) {	/* first space we've seen this line */
! 	    spcnom = (wp[0] * points + 3) / 6;	/* *nominal* space width.  CAT
! 						   doesn't read it - hardcoded.
! 						   GRRRR. */
! 	    spcwidth = xpos - optxpos;
! 	    spccount = 1;
! 	    *optloci = optxpos;
! 	    optxpos = xpos;
! 	    *optp++ = ' ';
! 	    *optp = '\0';
! 	} else if ((xpos - optxpos) % spcwidth == 0) {
! 	    int sw;
! 	    sw = (xpos - optxpos) / spcwidth;
! 	    if (sw + optcnt < optrun - 5) {
! 		while(sw--) {
! 		    optcnt++;
! 		    spccount++;
! 		    *optloci++ = optxpos;
! 		    *optp++ = ' ';
! 		}
! 		*optp = '\0';
! 		optxpos = xpos;
! 	    }
! 	}
!     }
! #endif
! 
!     if (optxpos != xpos)
  	optflush();
  
      if (!optbuffer[0]) {
***************
*** 268,273 ****
--- 323,329 ----
  	optxpos = xpos;
  	origxpos = xpos;
  	optfont = font;
+ 	optsymset = bp->t2b_font;
  	optnc = nc;
  	optpoints = points;
      }
***************
*** 284,301 ****
  
      from = bp->t2b_charseq;
      if (ditind == 1) {
! 	if (*from == '\\')
  	    *optp++ = '\\';
! 	else if (*(from+1)) {
  	    *optp++ = '\\';
  	    *optp++ = '(';
  	    *optp++ = *from++;
  	}
  	*optp++ = *from++;
  	    
      } else
! 	for (; *from;)
  	    *optp++ = *from++;
      *optp = '\0';
  }
  #endif
--- 340,362 ----
  
      from = bp->t2b_charseq;
      if (ditind == 1) {
! 	if (*from == '\\') {
  	    *optp++ = '\\';
! 	    optcnt++;
! 	} else if (*(from+1)) {
  	    *optp++ = '\\';
  	    *optp++ = '(';
  	    *optp++ = *from++;
+ 	    optcnt += 3;
  	}
  	*optp++ = *from++;
+ 	optcnt++;
  	    
      } else
! 	for (; *from;) {
! 	    optcnt++;
  	    *optp++ = *from++;
+ 	}
      *optp = '\0';
  }
  #endif
Index: ./pkscale.c
*** /tmp/PATCHold/./pkscale.c	Sat May 23 22:36:40 1992
--- ./pkscale.c	Sat May 23 22:36:42 1992
***************
*** 0 ****
--- 1,202 ----
+ /*	Copyright 1992 Chris Lewis
+ 		All Rights Reserved
+ 
+     See the LICENSE file for a full description of restrictions under which
+     this software is provided.
+ 
+     Function: PK/SFP font scaling.  Much hackery.  Results so-so.
+  */
+ 
+ #include "defs.h"
+ 
+ #ifdef	PK
+ 
+ #ifndef lint
+ static char SCCSid[] = "@(#)pkscale.c 1.2 Copyright 92/05/19 23:10:53 Chris Lewis";
+ #endif
+ 
+ #include "pk.h"
+ 
+ long
+ scalenum(sf, num)
+ double sf;
+ long num; {
+     if (num < 0)
+ 	return((long) (sf * num - .5));
+     else
+ 	return((long) (sf * num + .5));
+ }
+ 
+ static short *sl = (short *) NULL;
+ static sln = 0;
+ 
+ struct pkp *
+ pkscale(pkp, target)
+ struct pkp *pkp;
+ int target; {
+     struct pkp *npkp;
+     register int i,j;
+     register struct pkc *pc, *npc;
+     extern struct ras *pkrast();
+     double sf;
+ 
+     if (!target || target == pkp->pkp_npts)
+ 	return(pkp);
+ 
+     if (sl) {
+ 	free(sl);
+ 	sl = (short *) NULL;
+ 	sln = 0;
+     }
+     
+     sf = (double) target / pkp->pkp_npts;
+ 
+     npkp = (struct pkp *) mustmalloc(sizeof(struct pkp),
+ 	"New PK header for scale");
+     *npkp = *pkp;
+     npkp->pkp_list = (struct pkc **)
+ 	mustmalloc(sizeof(struct pkc *) * pkp->pkp_num,
+ 	"New PK sort list for scale");
+ 
+     npkp->pkp_chars = (struct pkc *) NULL;
+     npkp->pkp_last = (struct pkc *) NULL;
+ 
+     npkp->pkp_ds = scalenum(sf, npkp->pkp_ds);
+     npkp->pkp_npts = scalenum(sf, npkp->pkp_npts);
+     npkp->pkp_bmax = scalenum(sf, npkp->pkp_bmax);
+     npkp->pkp_dmax = scalenum(sf, npkp->pkp_dmax);
+     npkp->pkp_wmax = scalenum(sf, npkp->pkp_wmax);
+     npkp->pkp_xomax = scalenum(sf, npkp->pkp_xomax);
+     npkp->pkp_kh = scalenum(sf, npkp->pkp_kh);
+     npkp->pkp_kl = scalenum(sf, npkp->pkp_kl);
+ 
+     for (i = 0; i < pkp->pkp_num; i++) {
+ 	register struct ras *r;
+ 	pc = pkp->pkp_list[i];
+ 
+ 	/* create new char descriptor, initialized to old */
+ 	npc = (struct pkc *) mustmalloc(sizeof(struct pkc),
+ 	    "New PK character descriptor");
+ 	*npc = *pc;
+ 	if (!npkp->pkp_chars)
+ 	    npkp->pkp_chars = npc;
+ 	npkp->pkp_last = npc;
+ 	npkp->pkp_list[i] = npc;
+ 
+ 	/* get a raster to play with */
+ 	pc->pkc_sfpr = pkrast(pc);
+ 	if (pc->pkc_pkr)
+ 	    free((char *) pc->pkc_pkr);
+ 	pc->pkc_pkr = (int8 *) NULL;
+ 
+ 	npc->pkc_sfpr = r = (struct ras *) mustmalloc(sizeof(struct ras),
+ 	    "SFP raster header for scale");
+ 	
+ 	npc->pkc_height = scalenum(sf, npc->pkc_height)+1;
+ 	npc->pkc_width = scalenum(sf, npc->pkc_width)+1;
+ 	npc->pkc_dx = scalenum(sf, npc->pkc_dx);
+ 	npc->pkc_dy = scalenum(sf, npc->pkc_dy);
+ 	npc->pkc_x_off = scalenum(sf, npc->pkc_x_off);
+ 	npc->pkc_y_off = scalenum(sf, npc->pkc_y_off);
+ 
+ 	r->ras_height = npc->pkc_height;
+ 	r->ras_width = npc->pkc_width;
+ 	r->ras_bline = (npc->pkc_width + 7) / 8;
+ 	r->ras_bytes = r->ras_height * r->ras_bline;
+ 	r->ras_raster = (int8 *) mustmalloc((int) r->ras_bytes,
+ 	    "SFP raster for scale");
+ 	
+ 	rastscale(r, pc->pkc_sfpr, sf);
+ 
+     }
+     pk_destroy(pkp);
+     return(npkp);
+ }
+ 
+ #define seton(x,y,r) r->ras_raster[y * r->ras_bline + (x >> 3)] |= (0x80 >> (x&7))
+ #define biton(x,y,r) r->ras_raster[y * r->ras_bline + (x >> 3)] & (0x80 >> (x&7))
+ 
+ #define BLOT
+ #ifdef BLOT
+ short blot1[] = {-1, 0,
+ 		 0, 1,
+ 		 1, 0,
+ 		 0, -1,
+ 		 0, 0};
+ short blot2[] = {-2,0,
+ 		-1,0,
+ 		-1,1,
+ 		0,1,
+ 		0,2,
+ 		1,1,
+ 		1,0,
+ 		2,0,
+ 		1,-1,
+ 		0,-1,
+ 		0,-2,
+ 		-1,-1,
+ 		0,0};
+ short *blotlist[] = {blot1, blot2, blot2, blot2, blot2, blot2};
+ #endif
+ 
+ rastscale(to, from, scale)
+ register struct ras *to, *from;
+ double scale; {
+     register int x, y;
+     register int ct = scale;
+     register struct ras *nr;
+ 
+     /* optimization to avoid floating point */
+     x = max(from->ras_height, from->ras_width) + 10;
+     if (x > sln) {
+ 	register short *p;
+ 	if (sl)
+ 	    free(sl);
+ 	p = sl = (short *)mustmalloc(sizeof(short) * x,
+ 	    "SFP raster scale array");
+ 	sln = x;
+ 	for (x = 0, p = sl; x < sln; x++)
+ 	    *p++ = scale * x + .5;
+     }
+ 
+     clrarray(to->ras_raster, to->ras_bytes);
+ 
+     /* dumb scaling algorithm. */
+     for (y = 0; y < from->ras_height; y++)
+ 	for (x = 0; x < from->ras_width; x++) {
+ 	    if (biton(x, y, from)) {
+ 		register int sy = sl[y], sx = sl[x];
+ 		seton(sx, sy, to);
+ 
+ 		/* if scale > 1, we centre a ct*ct box on it */
+ #ifdef BLOT
+ 		if (ct) {
+ 		    register int tsx, tsy;
+ 		    register short *p = blotlist[ct-1];
+ 
+ 		    while(*p || *(p+1)) {
+ 			tsx = sx + *p++;
+ 			tsy = sy + *p++;
+ 			if (tsx < 0 || tsx >= to->ras_width ||
+ 			    tsy < 0 || tsy >= to->ras_height)
+ 			    continue;
+ 			seton(tsx, tsy, to);
+ 		    }
+ 		}
+ #else
+ 		if (ct) {
+ 		    register int tsy, tsx, limx, limy;
+ 		    limy = min(sy + ct + 1, to->ras_height);
+ 		    for (tsy = max(sy-ct,0) ; tsy < limy; tsy++) {
+ 			limx = min(sx + ct + 1, to->ras_width);
+ 			for (tsx = max(sx-ct, 0); tsx < limx; tsx++) {
+ 			}
+ 		    }
+ 		}
+ #endif
+ 	    }
+ 	}
+ 
+ }
+ 
+ #endif
Index: ./pk.c
*** /tmp/PATCHold/./pk.c	Sat May 23 22:36:55 1992
--- ./pk.c	Sat May 23 22:36:57 1992
***************
*** 13,19 ****
  #ifdef	PK
  
  #ifndef lint
! static char SCCSid[] = "@(#)pk.c 2.3 Copyright 91/02/20 09:02:17 Chris Lewis";
  #endif
  
  #define	DRAW
--- 13,19 ----
  #ifdef	PK
  
  #ifndef lint
! static char SCCSid[] = "@(#)pk.c 2.4 Copyright 92/03/12 01:11:09 Chris Lewis";
  #endif
  
  #define	DRAW
***************
*** 28,33 ****
--- 28,35 ----
  
  extern char *progname;
  
+ long sfp_hmi;		/* pitch (default HMI) from SFP font header */
+ 
  static FILE *fin;
  static char *filename;	/* name of *current* font being read */
  extern char *malloc();
***************
*** 668,676 ****
  
      p->pkp_symset = get2int();
  
!     get2int();		/* pitch - we calculate this from height */
      c = get2int();	/* retrieved *height* */
!     p->pkp_npts = c * POINT / (OUTRES*4) + .5;
  
      get2int();	/* dummy */
      get1int();	/* dummy */
--- 670,681 ----
  
      p->pkp_symset = get2int();
  
!     c = get2int();	/* pitch (default HMI) */
!     sfp_hmi = (double) c / 4 + .5;
! 
      c = get2int();	/* retrieved *height* */
!     p->pkp_ds = (c * POINT * pow2(20)) / (OUTRES*4);
!     p->pkp_npts = (p->pkp_ds / pow2(20)) + 0.5;
  
      get2int();	/* dummy */
      get1int();	/* dummy */
***************
*** 682,688 ****
      p->pkp_xomax = 0;
  
      /* These are simulated so that the PK handlers can figure the font out */
-     p->pkp_ds = p->pkp_npts * pow2(20);
      p->pkp_cs = 0;
      p->pkp_hppp = OUTRES * pow2(16) / POINT;
      p->pkp_vppp = OUTRES * pow2(16) / POINT;
--- 687,692 ----
