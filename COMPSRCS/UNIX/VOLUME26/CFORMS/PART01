Newsgroups: comp.sources.unix
From: lab@techno.sth.cgl.se (Lars Berntzon)
Subject: v26i056: cforms - forms management front end for curses(3), Part01/03
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: lab@techno.sth.cgl.se (Lars Berntzon)
Posting-Number: Volume 26, Issue 56
Archive-Name: cforms/part01

[ I tested this as well as I could without having a Sys V.4 system.  It
  looks like it will run on a Sys V.3 system, it basically only needs the
  fancy curses(3).						--vix ]

This is the cforms package ver. 1.1. Cforms is a tool for 
quickly building forms based applications. It handles things
like views, pictures, fields and literals. It is also possible
to use c-code statements for handling various function within
the fields and pictures.

	lab@techno.sth.cgl.se (Lars Berntzon)

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  MANIFEST Makefile README bin doc doc/Makefile example
#   example/Makefile example/test.frm lib patchlevel.h src
#   src/Makefile src/cforms.h src/comp.c src/comp.h src/config.h
#   src/get_ccode.c src/get_event.c src/get_literal.c
#   src/get_picture.c src/get_stmt.c src/get_viewport.c src/keys.h
#   src/skip_stmt.c src/token.h
# Wrapped by vixie@cognition.pa.dec.com on Tue May 19 19:14:28 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1057 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	
X Makefile                   1	
X README                     1	
X bin                        1	
X doc                        1	
X doc/Makefile               1	
X doc/cforms.tex             2	
X example                    1	
X example/Makefile           1	
X example/test.frm           1	
X lib                        1	
X patchlevel.h               1	
X src                        1	
X src/Makefile               1	
X src/cflib.c                3	
X src/cforms.h               1	
X src/comp.c                 1	
X src/comp.h                 1	
X src/config.h               1	
X src/get_ccode.c            1	
X src/get_event.c            1	
X src/get_field.c            2	
X src/get_literal.c          1	
X src/get_picture.c          1	
X src/get_stmt.c             1	
X src/get_viewport.c         1	
X src/keys.h                 1	
X src/output.c               2	
X src/skip_stmt.c            1	
X src/token.c                2	
X src/token.h                1	
END_OF_FILE
if test 1057 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(1461 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X#		M A K E F I L E
X#		---------------
X#
X# Description:
X#	Compiles and links CForms
X#
X# $Log:	Makefile,v $
X# Revision 1.7  92/01/25  18:41:38  lasse
X# better export
X# 
X# Revision 1.6  92/01/25  18:35:38  lasse
X# corrected make export
X# 
X# Revision 1.5  92/01/25  18:08:01  lasse
X# Use /usr/local as DEST
X# 
X# 
X# Revision 1.4  92/01/19  13:32:44  lasse
X# added export
X# 
X# Revision 1.3  92/01/19  13:22:09  lasse
X# *** empty log message ***
X# 
X# Revision 1.2  92/01/19  13:21:43  lasse
X# *** empty log message ***
X# 
X# Revision 1.1  92/01/19  13:20:21  lasse
X# Initial revision
X# 
X#
X# By Lars Berntzon (lab@cgl.se)
X#
X
X# 
X# Installation places.
X#
XDEST	    = /usr/local
X
XDESTBIN     = $(DEST)/bin
XDESTLIB     = $(DEST)/lib
XDESTINCLUDE = $(DEST)/include
X
XLATEX = latex
XCOMP  = cfc
XOS    = SYSV
X
XMAKE  = make DEST=$(DEST) DESTBIN=$(DESTBIN) DESTLIB=$(DESTLIB) DESTINCLUDE=$(DESTINCLUDE)
X
XDIRS = src doc example
X
Xdefault: src
X
Xall: src doc example
X
Xsrc: src_make
Xsrc_make:
X	(cd src; $(MAKE))
Xdoc: doc_make
Xdoc_make:
X	(cd doc; $(MAKE))
Xexample: example_make
Xexample_make:
X	(cd example; $(MAKE))
X
Xinstall:
X	for i in $(DIRS); do (cd $$i; $(MAKE) install); done
X
Xclean:
X	for i in $(DIRS); do (cd $$i; $(MAKE) clean); done
X	rm -f bin/cfc lib/libcforms.a
Xexport:
X	tar cvf cforms.tar bin lib `find . -type f ! -name RCS ! -name cforms.uu ! -name cforms.tar -print -o -name RCS -prune`
X	compress cforms.tar
X	uuencode cforms.tar.Z < cforms.tar.Z > cforms.uu
X	rm cforms.tar.Z
END_OF_FILE
if test 1461 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1554 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X	CForms Vers 1.0 By Lars Berntzon, E-Mail: lab@cgl.se
X	----------------------------------------------------
X
X	CForms is a formular manager for building applications to be used
X	for many types of terminals though it uses the {\em curses} library.
X	CForms is built up by a language that consists of the objects: modules,
X	pictures, fields, literals and events.
X
X	An application is built by one or more modules that contains one or
X	more pictures that handles the various functions in the application.
X	Each picture may contain any number of fields and text literal
X	that describes the appearance of the picture.
X
X	Fields are defined by their name and may be specified with any type,
X	size, special attributes and event handling functions.
X
X	CForms may be intermixed with C-code modules in any way.
X	See the documentation in the doc:s directory on how to compile and
X	use CForms.
X
X	Copyright stuff
X	---------------
X	Permission is hereby granted to copy, reproduce, redistribute,
X	or otherwise use this software as long as: there is no monetary
X	profit gained specifically from the use or reproduction or this
X	software, it is not sold, rented, traded or otherwise marketed,
X	and this copyright notice is included prominently in any copy
X	made.
X
X	The author make no claims as to the fitness or correctness of
X	this software for any use whatsoever, and it is provided as is. 
X	Any use of this software is at the user's own risk.
X
X	If you find any bugs though you can always mail a description to
X	me on the address above and maybe i look into it.
X
X	Have fun.
END_OF_FILE
if test 1554 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test ! -d 'bin' ; then
    echo shar: Creating directory \"'bin'\"
    mkdir 'bin'
fi
if test ! -d 'doc' ; then
    echo shar: Creating directory \"'doc'\"
    mkdir 'doc'
fi
if test -f 'doc/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/Makefile'\"
else
echo shar: Extracting \"'doc/Makefile'\" \(306 characters\)
sed "s/^X//" >'doc/Makefile' <<'END_OF_FILE'
X#
X#		M A K E F I L E
X#		---------------
X#
X# Description:
X#	Generates documentation
X#
X# $Log:	Makefile,v $
X# Revision 1.1  92/01/19  12:41:04  lasse
X# Initial revision
X# 
X# 
X#
XLATEX = latex
Xdoc:
X	$(LATEX) cforms.tex
X	$(LATEX) cforms.tex
X
Xinstall:
X
Xclean:
X	-rm -f cforms.toc cforms.log cforms.aux cforms.dvi
END_OF_FILE
if test 306 -ne `wc -c <'doc/Makefile'`; then
    echo shar: \"'doc/Makefile'\" unpacked with wrong size!
fi
# end of 'doc/Makefile'
fi
if test ! -d 'example' ; then
    echo shar: Creating directory \"'example'\"
    mkdir 'example'
fi
if test -f 'example/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'example/Makefile'\"
else
echo shar: Extracting \"'example/Makefile'\" \(589 characters\)
sed "s/^X//" >'example/Makefile' <<'END_OF_FILE'
X#
X#		M A K E F I L E
X#		---------------
X#
X# Description:
X#	Compiles and links CForms example
X#
X# $Log:	Makefile,v $
X# Revision 1.2  92/01/19  13:21:05  lasse
X# better clean
X# 
X# Revision 1.1  92/01/19  12:48:47  lasse
X# Initial revision
X# 
X# 
X#
X
X# 
X# Installation places.
X#
X
XCOMP  = ../bin/cfc
XOS    = SYSV
X
XINCLUDE  = ../src
XLIBDIR   = ../lib
XLIBS     =  -lcforms -lcurses
XOFILES   = cforms.o
X
XCFLAGS = -g -DSYS_$(OS) -I$(INCLUDE)
X
Xcforms : $(OFILES)
X	$(CC) -o cforms $(OFILES) -L$(LIBDIR) $(LIBS)
X
Xinstall:
X
Xclean:
X	rm -f cforms.o cforms cforms.c
X	
Xcforms.c : test.frm
X	$(COMP) test.frm
END_OF_FILE
if test 589 -ne `wc -c <'example/Makefile'`; then
    echo shar: \"'example/Makefile'\" unpacked with wrong size!
fi
# end of 'example/Makefile'
fi
if test -f 'example/test.frm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'example/test.frm'\"
else
echo shar: Extracting \"'example/test.frm'\" \(4560 characters\)
sed "s/^X//" >'example/test.frm' <<'END_OF_FILE'
X/*
X * Test application for CForms.
X * $Log:	test.frm,v $
XRevision 1.1  92/01/19  12:42:55  lasse
XInitial revision
X
X */
X
XCCode {
X    #include <stdio.h>
X    main()
X    {
X        if (cforms_init() != OK) {
X            fprintf(stderr, "Failed to start cforms\n");
X            exit(1);
X        }
X
X        if (pic_call(picture("main"), NULL) != OK) {
X            fprintf(stderr, "No main picture\n");
X        }
X
X        cforms_end();
X    }
X}
X
XViewport view {
X    Pos 0,0;
X    Size 80, 24;
X}
X
XEvent Key DOWN  { fld_move(fld_down(current.field));  }
XEvent Key UP    { fld_move(fld_up(current.field));    }
XEvent Key CR    { fld_move(fld_next(current.field)); }
XEvent Key TAB   { fld_move(fld_next(current.field)); }
XEvent Key HELP  { message("You're using CForms"); }
XEvent Key F8    { pic_leave(); }
X
XPicture Main Viewport View {
X    Event Entry     { fld_set(current.field, "X"); }
X    Event Exit      { fld_set(current.field, " "); }
X    Event Key LEFT  { fld_move(fld_left(current.field));  }
X    Event Key RIGHT { fld_move(fld_right(current.field)); }
X    Event Key F8 Forget;
X
X    Event Key CR {
X	if (!picture(current.field->name)) {
X	    message("Choise not available");
X	}
X	else pic_call(picture(current.field->name), NULL);
X    }
X
X    Literal 25, 1, "M a i n   M e n u";	
X    Literal 25, 2, "-----------------";	
X
X    Field List { Pos 10, 10; Type Char(1); Protected;
X	LValue "[";  RValue "] Adress book"; }
X
X    Field Play    { Pos +0, +2; Type Char(1); Protected;
X	LValue "[";  RValue "] Play Game"; }
X
X    Field Status  { Pos +0, +2; Type Char(1); Protected;
X	LValue "[";  RValue "] Status Report"; }
X
X
X    Field Reg     { Pos 40, 10; Type Char(1); Protected;
X	LValue "[";  RValue "] Registration"; }
X
X
X    Field Exit    {
X	Pos 10, 20; Type Char(1); Protected;  LValue "["; RValue "] Exit";
X	Event Key CR {
X	    pic_leave();
X	}
X    }
X}
X
Xccode {
X   int cur_row = 0;
X}
X
XPicture Welcome Viewport View {
X
X    Event Draw {
X	fld_set(field("name"), fld_get(field("list:name%d", cur_row)));
X	fld_set(field("adress"), fld_get(field("list:adress%d", cur_row)));
X    }
X
X    Event Key F8 { pic_leave(); message("Canceled"); }
X
X    Event Key F1 { 
X	fld_set(field("list:name%d", cur_row), fld_get(field("name")));
X	fld_set(field("list:adress%d", cur_row), fld_get(field("adress")));
X	message("Inserted");
X	pic_leave();
X    }
X
X    Literal 25, 1,  "Person registration";
X    Literal +0, +1, "-------------------";
X
X    Field name {
X	Pos 20, 5;
X	Type Char(20);
X	LValue "Name: ";
X	Uppercase;
X    }
X
X    Field adress {
X	Pos 20, 7;
X	Type Char(20);
X	LValue "Adress: ";
X	Uppercase;
X    }
X
X    Literal +0, +5, "(F1 - Update)    (F8 - Leave)";
X}
X
XPicture List Viewport View
X{
X    Literal 25, 1,  "List of persons";
X    Literal +0, +1, "---------------";
X
X    Event Key CR { pic_call(picture("welcome"), NULL); }
X
X    Event Key DOWN {
X	if (cur_row < 9 && !fld_isempty(current.field)) {
X	     fld_move(field("Name%d", ++cur_row));
X	}
X    }
X    Event Key UP   { if (cur_row > 0) fld_move(field("Name%d", --cur_row)); }
X    Event Key Left { return; }
X    Event Key Right { return; }
X
X    Field Name0   { Pos 10, 5;   Type Char(20); LValue "["; Protected; }
X    Field Adress0 { Pos +20, +0; Type Char(20); RValue "]"; Protected; }
X    Field Name1   { Pos -20, +1; Type Char(20); LValue "["; Protected; }
X    Field Adress1 { Pos +20, +0; Type Char(20); RValue "]"; Protected; }
X    Field Name2   { Pos -20, +1; Type Char(20); LValue "["; Protected; }
X    Field Adress2 { Pos +20, +0; Type Char(20); RValue "]"; Protected; }
X    Field Name3   { Pos -20, +1; Type Char(20); LValue "["; Protected; }
X    Field Adress3 { Pos +20, +0; Type Char(20); RValue "]"; Protected; }
X    Field Name4   { Pos -20, +1; Type Char(20); LValue "["; Protected; }
X    Field Adress4 { Pos +20, +0; Type Char(20); RValue "]"; Protected; }
X    Field Name5   { Pos -20, +1; Type Char(20); LValue "["; Protected; }
X    Field Adress5 { Pos +20, +0; Type Char(20); RValue "]"; Protected; }
X    Field Name6   { Pos -20, +1; Type Char(20); LValue "["; Protected; }
X    Field Adress6 { Pos +20, +0; Type Char(20); RValue "]"; Protected; }
X    Field Name7   { Pos -20, +1; Type Char(20); LValue "["; Protected; }
X    Field Adress7 { Pos +20, +0; Type Char(20); RValue "]"; Protected; }
X    Field Name8   { Pos -20, +1; Type Char(20); LValue "["; Protected; }
X    Field Adress8 { Pos +20, +0; Type Char(20); RValue "]"; Protected; }
X    Field Name9   { Pos -20, +1; Type Char(20); LValue "["; Protected; }
X    Field Adress9 { Pos +20, +0; Type Char(20); RValue "]"; Protected; }
X
X    Literal -20, +5, "(F8 - Leave)";
X}
END_OF_FILE
if test 4560 -ne `wc -c <'example/test.frm'`; then
    echo shar: \"'example/test.frm'\" unpacked with wrong size!
fi
# end of 'example/test.frm'
fi
if test ! -d 'lib' ; then
    echo shar: Creating directory \"'lib'\"
    mkdir 'lib'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(21 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X#define PATCHLEVEL 1
END_OF_FILE
if test 21 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
if test ! -d 'src' ; then
    echo shar: Creating directory \"'src'\"
    mkdir 'src'
fi
if test -f 'src/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/Makefile'\"
else
echo shar: Extracting \"'src/Makefile'\" \(1094 characters\)
sed "s/^X//" >'src/Makefile' <<'END_OF_FILE'
X#
X#		M A K E F I L E
X#		---------------
X#
X# Description:
X#	Compiles and links CForms
X#
X# $Log:	Makefile,v $
X# Revision 1.12  92/01/19  13:18:47  lasse
X# *** empty log message ***
X# 
X# 
X#
X
X# 
X# Installation places.
X#
XDEST	    = ..
X
XDESTBIN     = $(DEST)/bin
XDESTLIB     = $(DEST)/lib
XDESTINCLUDE = $(DEST)/include
X
XOS          = SYSV
XLIBS        = 
XCFLAGS      = -g -DSYS_$(OS)
X
X# -----------------------------------------------
X
XFORMLIB = ../lib/libcforms.a
XCFC     = ../bin/cfc
XFORMHDR = cforms.h
X
XOFILES =	comp.o get_ccode.o get_event.o get_field.o get_literal.o \
X		get_picture.o get_stmt.o get_viewport.o	output.o skip_stmt.o \
X		token.o
X
XHFILES = $(FORMHDR) comp.h token.h config.h
X
X
X
Xall: cfc lib
Xcfc: $(CFC)
Xlib: $(FORMLIB)
X
X$(CFC): $(OFILES)
X	$(CC) -o $(CFC) $(OFILES) $(LIBS)
X
Xinstall: all
X	-rm -f $(DESTBIN)/cfc; cp $(CFC) $(DESTBIN)
X	-rm -f $(DESTLIB)/$(FORMLIB); cp $(FORMLIB) $(DESTLIB)
X	-rm -f $(DESTINCLUDE)/cforms.h; cp $(FORMHDR) $(DESTINCLUDE)
X
X$(FORMLIB): $(FORMLIB)(cflib.o)
X$(FORMLIB)(cflib.o): $(HFILES)
X
Xclean:
X	-rm -f $(OFILES)
X
X$(OFILES): $(HFILES)
Xget_event.o: keys.h
END_OF_FILE
if test 1094 -ne `wc -c <'src/Makefile'`; then
    echo shar: \"'src/Makefile'\" unpacked with wrong size!
fi
# end of 'src/Makefile'
fi
if test -f 'src/cforms.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/cforms.h'\"
else
echo shar: Extracting \"'src/cforms.h'\" \(2989 characters\)
sed "s/^X//" >'src/cforms.h' <<'END_OF_FILE'
X#ifndef _CFORMS_H
X#define _CFORMS_H
X
X#ifndef OK
X#define OK	0
X#endif
X
X#ifndef FAIL
X#define FAIL	-1
X#endif
X
X#ifndef TRUE
X#define TRUE 1
X#endif
X
X#ifndef FALSE
X#define FALSE 0
X#endif
X
X#define EVENT_KEY	1
X#define EVENT_REFRESH	2
X#define EVENT_ENTRY	3
X#define EVENT_EXIT	4
X#define EVENT_DRAW	5
X#define EVENT_PREVIOUS	6
X#define EVENT_NEXT	7
X
X#define FLD_TYPE	0x000F
X#define FLD_MODIFIER	0x0FF0
X
X#define FLD_RIGHT	0x0010
X#define FLD_LEFT	0x0020
X#define FLD_UPPERCASE	0x0040
X#define FLD_PROTECTED	0x0080
X
X#define FLD_INT		0x0001
X#define FLD_STR		0x0002
X#define FLD_ALNUM	0x0003
X
Xstruct xy {
X    int x, y;
X};
X
X#ifndef _COMP_H
Xstruct event {
X    int type;
X    int code;
X    void (*func)();
X};
X
Xstruct field {
X    char *name;
X    int type;
X    int len;
X    char *data;
X    struct xy pos;
X    char *lvalue;
X    char *rvalue;
X    struct event *event;
X    int n_events;
X    int flags;
X    char modified;
X    struct picture *picture;
X};
X
Xstruct literal {
X    struct xy pos;
X    char *value;
X    int display_flags;
X};
X
Xstruct picture {
X    char *name;
X    struct field *field;
X    int n_fields;
X    struct literal *literal;
X    int n_literals;
X    struct event *event;
X    int n_events;
X    int x, y;
X    int width, height;
X};
X
Xstruct module {
X    struct picture *picture;
X    int n_pictures;
X    struct event *event;
X    int n_events;
X};
X
Xextern struct current {
X    struct picture *picture;
X    struct field *field;
X} current;
X
X/*
X * Start/stop functions.
X */
Xextern int cforms_init(void);
Xextern int cforms_end(void);
X
X/*
X * Picture functions.
X */
Xextern struct picture *picture(char *fmt, ...);
Xextern int             pic_call(struct picture *pic, char *fieldname);
Xextern int             pic_clear(struct picture *pic);
X
X/* 
X * Field functons.
X */
Xextern struct field *field(char *fmt, ...);
Xextern struct field *fld_move(struct field *fld);
Xextern struct field *fld_down(struct field *fld);
Xextern struct field *fld_up(struct field *fld);
Xextern struct field *fld_left(struct field *fld);
Xextern struct field *fld_right(struct field *fld);
Xextern struct field *fld_first(void);
Xextern struct field *fld_last(void);
Xextern struct field *fld_next(struct field *fld);
Xextern struct field *fld_previous(struct field *fld);
Xextern char         *fld_get(struct field *fld);
Xextern int           fld_set(struct field *fld, char *value);
Xextern int           fld_nset(struct field *fld, char *value, int n);
Xextern int           fld_len(struct field *fld);
Xextern int           fld_isempty(struct field *fld);
Xextern int           fld_ismodified(struct field *fld);
Xextern void          fld_touch(struct field *fld);
X
X/*
X * General functions.
X */
Xextern                 get_fld(struct field *fld, int (*check)());
Xextern int             generate_event(int ev_type, int ev_code);
Xextern int             strequ(char *s1, char *s2);
Xextern int             message(char *fmt, ...);
Xextern int             message_nr(char *fmt, ...);
X
X
Xextern struct module _module;
X
X#endif /* _COMP_H */
X
X#endif /* _CFORMS_H */
X
END_OF_FILE
if test 2989 -ne `wc -c <'src/cforms.h'`; then
    echo shar: \"'src/cforms.h'\" unpacked with wrong size!
fi
# end of 'src/cforms.h'
fi
if test -f 'src/comp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/comp.c'\"
else
echo shar: Extracting \"'src/comp.c'\" \(5422 characters\)
sed "s/^X//" >'src/comp.c' <<'END_OF_FILE'
X/*******************************************************************************
X *
X *		C O M P . C
X *		-----------
X *
X * Description:
X *	Compile a FRM-file to C-code.
X *
X * Included functions:
X *	main	- Main function
X *
X * Revision:
X *	Ver	Date	By		Reason
X *	---	----	--		------
X *	1.00	900619	Lars Berntzon	Created
X *
X ******************************************************************************/
X
X#include "config.h"
X
X#include <stdio.h>
X#include <ctype.h>
X#include <string.h>
X#include <assert.h>
X#include <signal.h>
X#ifdef STDLIB_H
X#include <stdlib.h>
X#endif
X#ifdef MALLOC_H
X#include <malloc.h>
X#endif
X
X#include "token.h"
X#include "comp.h"
X
Xstruct list list;
Xchar version[] = "1.1";
Xint n_errors = 0;
Xint n_warnings = 0;
X
Xextern int cleanup();
X
Xstatic int found_picture();
Xstatic int found_event();
Xstatic int found_viewport();
Xstatic int found_ccode();
X
Xstatic int previous_x, previous_y;
X
Xstatic struct lookup_s lookup[] = {	/* Aviable commands at top level */
X    "PICTURE",  found_picture,
X    "EVENT",    found_event,
X    "VIEWPORT", found_viewport,
X    "CCODE",    found_ccode
X};
X
X#ifdef VOID_MAIN
X    void main(int argc, char *argv[])
X#else
X    main(int argc, char *argv[])
X#endif
X{
X    char token [TOKENSIZE];
X    int i;
X    
X    if (argc != 2) usage();
X    
X    if (OpenTok(argv[1]) == NULL) fatal("Failed to open file");
X    
X    signal(SIGINT, (SIGNAL_TYPE)cleanup);
X    signal(SIGFPE, (SIGNAL_TYPE)cleanup);
X    
X    while(GetTokNC(token) != NULL) {
X    	for (i = 0; i < N_CMDS; i++) {
X    	    if (strequ(token, lookup[i].cmd) == 0)
X    	        break;
X    	}
X    	if (i < N_CMDS) {
X    	    (*lookup[i].func)();
X    	}
X    	else {
X    	    error("Unknown command");
X    	}
X    }
X    
X    if (n_errors) {
X    	fprintf(stderr, "%d errors found.\n", n_errors);
X#ifdef VOID_MAIN 
X    	return;
X#else
X    	return 1;
X#endif
X    }
X
X    /*
X     * Generate C-code.
X     */
X    output();
X    
X#ifdef VOID_MAIN 
X    return;
X#else
X    return 0;
X#endif
X}
X
Xstatic int found_viewport()
X{
X    link((struct link **)&list.viewport, &get_viewport()->link, TYPE_VIEWPORT);
X    return OK;
X}
Xstatic int found_picture()
X{
X    link((struct link **)&list.picture, &get_picture()->link, TYPE_PICTURE);
X    return OK;
X}
Xstatic int found_event()
X{
X    link((struct link **)&list.event, &get_event()->link, TYPE_EVENT);
X    return OK;
X}
Xstatic int found_ccode()
X{
X    link((struct link **)&list.ccode, &get_ccode()->link, TYPE_CCODE);
X    return OK;
X}
X
X/******************************************************************************/
Xint strequ(char *s1, char *s2)
X{
X    while(*s1 && toupper(*s1) == toupper(*s2))
X	s1++, s2++;
X
X    return toupper(*s1) - toupper(*s2);
X}
X
Xvoid usage(void)
X{
X    fprintf(stderr, "Usage: comp <file>\n");
X    exit(1);
X}
X
Xvoid fatal(char *str)
X{
X    fprintf(stderr, "fatal: %s\n", str);
X    exit(1);
X}
X
Xvoid error(char *str)
X{
X    static int old_line;
X    /*
X     * Maximize to one error per line.
X     */
X    if (line > old_line) {
X        n_errors++;
X	old_line = line;
X	fprintf(stderr, "error line %d: %s\n", line, str);
X    }
X}
X
Xvoid *_memalloc(char *file, int line, int size)
X{
X    void *p;
X    if ((p = malloc(size)) == NULL) {
X    	fprintf(stderr, "*** %s %d out of memory ***\n", file, line);
X    	exit(1);
X    }
X    memset(p, 0, size);
X
X    return p;
X}
X
Xvoid link(struct link **head, struct link *item, int type)
X{
X    if (item == NULL) return;
X    
X    item->type = type;
X
X    /*
X     * Sort by name if aviable, otherwise last in list.
X     */    
X    if (item->name) {
X    	for(; *head != NULL; head = &(*head)->next) {
X    	    if (strequ((*head)->name, item->name) > 0) break;
X    	}
X    }
X    else {
X        for(; *head != NULL; head = & (*head)->next) 
X            ;
X    }
X
X    item->next = *head;
X    *head = item;
X}
X
Xstruct link *find_name(struct link *first, char *name)
X{
X    if (name == NULL) return NULL;
X    
X    for(; first != NULL; first = first->next) {
X    	if (first->name != NULL && strequ(name, first->name) == 0) break;
X    }
X
X    return first;
X}
X
Xvoid link_name(struct link *item, char *name)
X{
X    if (item == NULL || name == NULL) return;
X
X    item->name = memalloc(strlen(name) + 1);
X    strcpy(item->name, name);
X}
X
XGetPos(int *x, int *y)
X{
X    char token[TOKENSIZE];
X    char sign = 0;
X    
X    if (GetTokNC(token) == NULL) return FAIL;
X    
X    if (token[0] == '+' || token[0] == '-') {
X    	sign = token[0];
X    	if (GetTokNC(token) == NULL) return FAIL;
X    }
X
X    if (!isdigit(token[0])) return FAIL;
X    
X    *x = atoi(token);
X    if (sign) *x = previous_x + (sign == '-' ? - *x : *x);
X    sign = 0;
X    
X    if (GetTokNC(token) == NULL || strcmp(token, ",")) return FAIL;
X    
X    if (GetTokNC(token) == NULL) return FAIL;
X    
X    if (token[0] == '+' || token[0] == '-') {
X    	sign = token[0];
X    	if (GetTokNC(token) == NULL) return FAIL;
X    }
X    if (!isdigit(token[0])) return FAIL;
X    
X    *y = atoi(token);
X    if (sign) *y = previous_y + (sign == '-' ? - *y : *y);
X    sign = 0;
X    
X    previous_x = *x;
X    previous_y = *y;
X    
X    return OK;
X}
X
Xcleanup()
X{
X    struct viewport *vp;
X    struct picture *pp;
X    struct event *ep;
X    struct ccode *cp;
X    
X    for(vp = list.viewport; vp != NULL; vp = unget_viewport(vp))
X	;
X
X    for(pp = list.picture; pp != NULL; pp = unget_picture(pp))
X	;
X
X    for(ep = list.event; ep != NULL; ep = unget_event(ep))
X	;
X
X    for(cp = list.ccode; cp != NULL; cp = unget_ccode(cp))
X	;
X	
X    exit(1);
X
X    return 0;
X}
END_OF_FILE
if test 5422 -ne `wc -c <'src/comp.c'`; then
    echo shar: \"'src/comp.c'\" unpacked with wrong size!
fi
# end of 'src/comp.c'
fi
if test -f 'src/comp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/comp.h'\"
else
echo shar: Extracting \"'src/comp.h'\" \(3258 characters\)
sed "s/^X//" >'src/comp.h' <<'END_OF_FILE'
X/*******************************************************************************
X *
X *		C O M P . H
X *		-----------
X *
X * Description:
X *	Headerfile for compiler.
X *
X * Revision:
X *	Ver	Date	By		Reason
X *	---	----	--		------
X *	1.00	900619	Lars Berntzon	Created
X *
X ******************************************************************************/
X#ifndef _COMP_H
X#define _COMP_H
X
X#include "cforms.h"
X
X#define offsetof(type, item) (((int) &( ((type *)2)->item )) - 2)
X
X#define NEXT_VIEWPORT(ptr) ((struct viewport *)ptr->link.next)
X#define NEXT_PICTURE(ptr)  ((struct picture *)ptr->link.next)
X#define NEXT_FIELD(ptr)    ((struct field *)ptr->link.next)
X#define NEXT_EVENT(ptr)    ((struct event *)ptr->link.next)
X#define NEXT_LITERAL(ptr)  ((struct literal *)ptr->link.next)
X#define NEXT_CCODE(ptr)    ((struct ccode *)ptr->link.next)
X
X#define TYPE_VIEWPORT	1
X#define TYPE_PICTURE	2
X#define TYPE_FIELD	3
X#define TYPE_EVENT	4
X#define TYPE_LITERAL	5
X#define TYPE_CCODE	6
X
X#define memalloc(size)	_memalloc(__FILE__, __LINE__, (size))
X
X#define N_KEYS	(sizeof keys / sizeof keys[0])
X#define N_CMDS	(sizeof lookup / sizeof lookup[0])
X
X/* Common used struct for command parsing */
Xstatic struct lookup_s {
X    char *cmd;
X    int (*func)();
X};
X
Xstatic struct keys_s {
X    char *key;
X    char *code;
X};
X
Xstruct stmt {
X    struct stmt *next;
X    int line;
X    char txt[1];
X};
X
Xstruct link {
X    struct link *next;
X    int type;
X    char *name;
X};
X
Xstruct literal {
X    struct link link;
X    struct xy pos;
X    int display_flags;
X};
X
Xstruct viewport {
X    struct link link;
X    struct xy pos;
X    struct xy size;
X};
X
Xstruct ccode {
X    struct link link;
X    struct stmt *stmt;
X};
X
Xstruct event {
X    struct link link;
X    char *type;
X    char *code;
X    struct stmt *stmt;
X};
X
Xstruct field {
X    struct link link;
X    struct xy pos;
X    struct event *event;
X    char *lvalue;
X    char *rvalue;
X    char *type;
X    int len;
X    int flags;
X};
X
Xstruct picture {
X    struct link link;
X    struct viewport *viewport;
X    struct field *field;
X    struct literal *literal;
X    struct event *event;
X};
X
Xstruct list {
X    struct viewport *viewport;
X    struct picture *picture;
X    struct event *event;
X    struct ccode *ccode;
X};
X
Xextern int strequ(char *s1, char *s2);	/* Case insensitive strcmp	*/
Xextern void fatal(char *str);		/* Give message and abort	*/
Xextern void usage(void);		/* Give usage message and abort	*/
Xextern void error(char *);		/* Give error message + lineno	*/
X
X	/* malloc with memory check	*/
Xextern void *_memalloc(char *file, int line, int size);
X
Xextern struct picture  *get_picture(), *unget_picture();
Xextern struct event    *get_event(), *unget_event();
Xextern struct viewport *get_viewport(), *unget_viewport();
Xextern struct field    *get_field(), *unget_field();
Xextern struct stmt     *get_stmt();
Xvoid   unget_stmt();
Xextern struct literal  *get_literal(), *unget_literal();
Xextern struct ccode    *get_ccode(), *unget_ccode();
Xextern void            link(struct link **head, struct link *item, int type);
Xextern void            link_name(struct link *item, char *name);
Xextern struct link    *find_name(struct link *first, char *name);
X
Xextern int GetPos(int *x, int *y);
Xextern struct list list;
Xextern char version[];
X
X#endif _/* COMP_H */
X
END_OF_FILE
if test 3258 -ne `wc -c <'src/comp.h'`; then
    echo shar: \"'src/comp.h'\" unpacked with wrong size!
fi
# end of 'src/comp.h'
fi
if test -f 'src/config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/config.h'\"
else
echo shar: Extracting \"'src/config.h'\" \(666 characters\)
sed "s/^X//" >'src/config.h' <<'END_OF_FILE'
X/******************************************************************************
X *
X *			C O N F I G . H
X *			---------------
X *
X * Description:
X *	Configuration file for setting up switches depending
X *	of machine type.
X * 
X * Revision:
X *	Ver	Date	By		Reason
X *	---	----	--		------
X *	1.00	900815	Lars Berntzon	Created
X *
X ****************************************************************************/
X#ifndef _CONFIG_H
X#define _CONFIG_H
X
X#ifdef SYS_AMIGA
X#define STDLIB_H
X#define VOID_MAIN
X#endif
X
X#ifdef SYS_SYSV
X#define SIGNAL_TYPE void(*)()
X#define TERMIOS
X#define MALLOC_H
X#endif
X
X#ifndef SIGNAL_TYPE
X#define SIGNAL_TYPE void(*)()
X#endif
X#endif /* _CONFIG_H */
END_OF_FILE
if test 666 -ne `wc -c <'src/config.h'`; then
    echo shar: \"'src/config.h'\" unpacked with wrong size!
fi
# end of 'src/config.h'
fi
if test -f 'src/get_ccode.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/get_ccode.c'\"
else
echo shar: Extracting \"'src/get_ccode.c'\" \(1054 characters\)
sed "s/^X//" >'src/get_ccode.c' <<'END_OF_FILE'
X/*******************************************************************************
X *
X *		G E T _ C C O D E . C
X *		---------------------
X *
X * Description:
X *	Compiles a C-code statement.
X *
X * Included functions:
X *	get_ccode	- Does the job
X *
X * Revision:
X *	Ver	Date	By		Reason
X *	---	----	--		------
X *	1.00	90730	Lars Berntzon	Created
X *
X ******************************************************************************/
X
X#include <stdio.h>
X#include <ctype.h>
X#include <string.h>
X
X#include "token.h"
X#include "comp.h"
X
Xstruct ccode *get_ccode()
X{
X    struct ccode *cp = NULL;
X    struct stmt *stmt;
X
X    if ((stmt = get_stmt()) == NULL) {
X    	error("expected C-code statements");
X    	return NULL;
X    }
X    
X    cp = memalloc(sizeof *cp);
X    cp->stmt = stmt;
X    
X    return cp;
X}
X
Xstruct ccode *unget_ccode(struct ccode *cp)
X{
X    struct ccode *next;
X    
X    if (cp == NULL) return NULL;
X    
X    next = NEXT_CCODE(cp);
X    if (cp->stmt) unget_stmt(cp->stmt);
X    if (cp->link.name) free(cp->link.name);
X    free(cp);
X    
X    return next;
X}
X    
END_OF_FILE
if test 1054 -ne `wc -c <'src/get_ccode.c'`; then
    echo shar: \"'src/get_ccode.c'\" unpacked with wrong size!
fi
# end of 'src/get_ccode.c'
fi
if test -f 'src/get_event.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/get_event.c'\"
else
echo shar: Extracting \"'src/get_event.c'\" \(4291 characters\)
sed "s/^X//" >'src/get_event.c' <<'END_OF_FILE'
X/*******************************************************************************
X *
X *		G E T _ E V E N T . C
X *		---------------------
X *
X * Description:
X *	Compiles an event statement.
X *
X * Included functions:
X *	get_event	- Does the job
X *
X * Revision:
X *	Ver	Date	By		Reason
X *	---	----	--		------
X *	1.00	900625	Lars Berntzon	Created
X *
X ******************************************************************************/
X
X#include <stdio.h>
X#include <ctype.h>
X#include <string.h>
X#include <assert.h>
X
X#include "token.h"
X#include "comp.h"
X
Xstatic int get_event_stmt(struct stmt **stmt);
X
Xstatic int found_key();
Xstatic int found_refresh();
Xstatic int found_draw();
Xstatic int found_entry();
Xstatic int found_exit();
Xstatic int found_next();
Xstatic int found_previous();
X
Xstatic struct keys_s keys[] = {
X#include "keys.h"
X};
X
Xstatic struct lookup_s lookup[] = {
X    "KEY",      found_key,
X    "REFRESH",  found_refresh,
X    "DRAW",     found_draw,
X    "ENTRY",    found_entry,
X    "EXIT",     found_exit,
X    "NEXT",     found_next,
X    "PREVIOUS", found_previous
X};
X
Xstruct event *get_event()
X{
X    char token[TOKENSIZE];
X    struct event *ep = NULL;
X    int i;
X
X    if (GetTokNC(token) == NULL) {
X    	error("expected type of event");
X    	return NULL;
X    }
X    
X    for (i = 0; i < N_CMDS; i++) {
X    	if (strequ(lookup[i].cmd, token) == 0) break;
X    }
X    
X    if (i >= N_CMDS) {
X    	error("illegal type of event");
X    	return NULL;
X    }
X    
X    ep = memalloc(sizeof *ep);
X    
X    if ((*lookup[i].func)(ep) != OK) {
X    	unget_event(ep);
X    	return NULL;
X    }
X    
X    return ep;
X}
X
Xstruct event *unget_event(struct event *ep)
X{
X    struct event *next;
X    
X    if (ep == NULL) return NULL;
X
X    next = (struct event *)ep->link.next;
X    
X    if (ep->link.name) free(ep->link.name);
X    free(ep);
X
X    return next;
X}
X
Xstatic int found_key(ep)
X    struct event *ep;
X{
X    char token[TOKENSIZE];
X    int i;
X    
X    if (GetTokNC(token) == NULL) {
X    	error("expected name of key for event");
X    	return FAIL;
X    }
X    
X    for(i = 0; i < N_KEYS; i++) {
X    	if(strequ(token, keys[i].key) == 0) break;
X    }
X
X    if (i >= N_KEYS) {
X    	error("unknown key");
X    	return FAIL;
X    }
X    
X    if (ep->link.name == NULL) {
X    	sprintf(token, "key_%s", keys[i].key);
X    	link_name(&ep->link, token);
X    }
X    
X    ep->type = "EVENT_KEY";
X    ep->code = keys[i].code;
X    if (get_event_stmt(&ep->stmt) != OK) return FAIL;
X    
X    return OK;
X}
X
Xstatic found_refresh(ep)
X    struct event *ep;
X{
X    link_name(&ep->link, "REFRESH");
X    ep->type = "EVENT_REFRESH";
X    ep->code = "0";
X    if (get_event_stmt(&ep->stmt) != OK) return FAIL;
X    return OK;
X}
X
Xstatic found_draw(ep)
X    struct event *ep;
X{
X    link_name(&ep->link, "DRAW");
X    ep->type = "EVENT_DRAW";
X    ep->code = "0";
X    if (get_event_stmt(&ep->stmt) != OK) return FAIL;
X    return OK;
X}
X
Xstatic found_next(ep)
X    struct event *ep;
X{
X    link_name(&ep->link, "NEXT");
X    ep->type = "EVENT_NEXT";
X    ep->code = "0";
X    if (get_event_stmt(&ep->stmt) != OK) return FAIL;
X    return OK;
X}
X
Xstatic found_previous(ep)
X    struct event *ep;
X{
X    link_name(&ep->link, "PREVIOUS");
X    ep->type = "EVENT_PREVIOUS";
X    ep->code = "0";
X    if (get_event_stmt(&ep->stmt) != OK) return FAIL;
X    return OK;
X}
X
Xstatic found_entry(ep)
X    struct event *ep;
X{
X    link_name(&ep->link, "ENTRY");
X    ep->type = "EVENT_ENTRY";
X    ep->code = "0";
X    if (get_event_stmt(&ep->stmt) != OK) return FAIL;
X    return OK;
X}
X
Xstatic found_exit(ep)
X    struct event *ep;
X{
X    link_name(&ep->link, "EXIT");
X    ep->type = "EVENT_EXIT";
X    ep->code = "0";
X    if (get_event_stmt(&ep->stmt) != OK) return FAIL;
X    return OK;
X}
X
Xstatic int get_event_stmt(struct stmt **stmt)
X{
X    char token[TOKENSIZE];
X    
X    assert(stmt);
X    
X    if (GetTokNC(token) == NULL) {
X    	error("expected either '{' or 'forget'");
X    	return FAIL;
X    }
X    
X    if (strcmp(token, "{") == 0) {
X    	UnGetTok("{");
X    	if (*stmt = get_stmt()) return OK;
X    	return FAIL;
X    }
X    else if (strequ(token, "forget") == 0) {
X    	*stmt = NULL;
X    	if (GetTokNC(token) == NULL ||strequ(token, ";")) {
X    	    error("expected ';'");
X    	    return FAIL;
X    	}
X    	return OK;
X    }
X    error("expected either '{' or 'forget'");
X    return FAIL;
X}
X
END_OF_FILE
if test 4291 -ne `wc -c <'src/get_event.c'`; then
    echo shar: \"'src/get_event.c'\" unpacked with wrong size!
fi
# end of 'src/get_event.c'
fi
if test -f 'src/get_literal.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/get_literal.c'\"
else
echo shar: Extracting \"'src/get_literal.c'\" \(2287 characters\)
sed "s/^X//" >'src/get_literal.c' <<'END_OF_FILE'
X/*******************************************************************************
X *
X *		G E T _ L I T E R A L . C
X *		-------------------------
X *
X * Description:
X *	Compiles a literal statemnent.
X *
X * Included functions:
X *	get_literal	- Does the job
X *
X * Revision:
X *	Ver	Date	By		Reason
X *	---	----	--		------
X *	1.00	900627	Lars Berntzon	Created
X *
X ******************************************************************************/
X
X#include <stdio.h>
X#include <ctype.h>
X#include <string.h>
X
X#include "token.h"
X#include "comp.h"
X
X#define isnormal(ch) (isalnum(ch) || (ch) == '_')
X
Xstatic int found_display();
X
Xstatic struct lookup_s lookup[] = {
X    "DISPLAY",    found_display
X};
X
Xstruct literal *get_literal()
X{
X    char token[TOKENSIZE];
X    struct literal *lp = NULL;
X    int i;
X    int x, y;
X    
X    if (GetPos(&x, &y) != OK) {
X    	error("expected a coordinate");
X    	return NULL;
X    }
X    
X    if (GetTokNC(token) == NULL || strcmp(token, ",")) {
X    	error("expected a ',' after row");
X    	return NULL;
X    }
X    
X    if (GetTokNC(token) == NULL || token[0] != '"') {
X    	error("expected literal text");
X    	return NULL;
X    }
X    
X    token[strlen(token) - 1] = 0;
X    
X    lp = memalloc(sizeof *lp);
X    link_name(&lp->link, token + 1);
X    
X    if(GetTokNC(token) == NULL ||
X       (strcmp(token, "{") != 0 &&
X        strcmp(token, ";") != 0) ) {
X        error("expected '{' ot ';'");
X        unget_literal(lp);
X        return NULL;
X    }
X    
X    lp->pos.x = x;
X    lp->pos.y = y;
X    
X    if(strcmp(token, ";") == 0) {
X    	return lp;
X    }
X    
X    while(GetTokNC(token) != NULL) {
X    	if (strcmp(token, "}") == 0) break;
X    	
X	for(i = 0; i < N_CMDS; i++) {
X	    if (strequ(token, lookup[i].cmd) == 0) break;
X	}
X	if (i < N_CMDS) {
X	    if ((*lookup[i].func)(lp) != OK) {
X		unget_literal(lp);
X		return NULL;
X	    }
X	}
X	else {
X	    fprintf(stderr, "line %d: unknown token '%s' for literal\n",
X		    line, token);
X	}
X    }
X
X    return lp;
X}
X
Xstruct literal *unget_literal(struct literal *lp)
X{
X    struct literal *next;
X    
X    if (lp == NULL) return NULL;
X    
X    next = (struct literal *)lp->link.next;
X    
X    if (lp->link.name) free(lp->link.name);
X    free(lp);
X
X    return next;
X}
X
Xstatic int found_display(lp)
X    struct literal *lp;
X{
X
X    return OK;
X}
END_OF_FILE
if test 2287 -ne `wc -c <'src/get_literal.c'`; then
    echo shar: \"'src/get_literal.c'\" unpacked with wrong size!
fi
# end of 'src/get_literal.c'
fi
if test -f 'src/get_picture.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/get_picture.c'\"
else
echo shar: Extracting \"'src/get_picture.c'\" \(3364 characters\)
sed "s/^X//" >'src/get_picture.c' <<'END_OF_FILE'
X/*******************************************************************************
X *
X *		G E T _ P I C T U R E . C
X *		-------------------------
X *
X * Description:
X *	Compiles a picture statement.
X *
X * Included functions:
X *	get_picture	- Does the job
X *
X * Revision:
X *	Ver	Date	By		Reason
X *	---	----	--		------
X *	1.00	900621	Lars Berntzon	Created
X *
X ******************************************************************************/
X
X#include <stdio.h>
X#include <ctype.h>
X#include <string.h>
X
X#include "token.h"
X#include "comp.h"
X
X#define isnormal(ch) (isalnum(ch) || (ch) == '_')
X
Xstatic int found_field();
Xstatic int found_event();
Xstatic int found_literal();
X
Xstatic struct lookup_s lookup[] = {
X    "FIELD",   found_field,
X    "LITERAL", found_literal,
X    "EVENT",   found_event
X};
X
Xstruct picture *get_picture()
X{
X    char token[TOKENSIZE];
X    struct link *lp;
X    struct picture *pp = NULL;
X    int i;
X    
X    if(GetTokNC(token) == NULL || !isnormal(token[0])) {
X    	error("expected nam of picture");
X    	return NULL;
X    }
X    
X    pp = memalloc(sizeof *pp);
X    link_name(&pp->link, token);
X    
X    /* Check that viewport is specified */
X    if (GetTokNC(token) == NULL || strequ(token, "viewport")) {
X    	error("expected viewport");
X    	unget_picture(pp);
X    	return NULL;
X    }
X    
X    if (GetTokNC(token) == NULL || !isnormal(token[0])) {
X    	error("expected name of viewport");
X    	unget_picture(pp);
X    	return NULL;
X    }
X    
X    if ((lp = find_name((struct link *)list.viewport, token)) == NULL) {
X    	error("unknown viewport");
X    	unget_picture(pp);
X    	return NULL;
X    }
X    
X    pp->viewport = (struct viewport *)lp;
X    
X    if (GetTokNC(token) == NULL || strcmp(token, "{")) {
X    	error("expected '{'");
X    	unget_picture(pp);
X    	return NULL;
X    }
X    
X    while(GetTokNC(token) != NULL) {
X    	if (strcmp(token, "}") == 0) break;
X    	
X	for(i = 0; i < N_CMDS; i++) {
X	    if (strequ(token, lookup[i].cmd) == 0) break;
X	}
X	if (i < N_CMDS) {
X	    if ((*lookup[i].func)(pp) != OK) {
X	    	unget_picture(pp);
X	    	return NULL;
X	    }
X	}
X	else {
X	    fprintf(stderr, "line %d: unknown token '%s' for picture\n", 
X	    	    line, token);
X	}
X    }
X    return pp;
X}
X
Xstruct picture *unget_picture(struct picture *pp)
X{
X    struct picture *next;
X    struct field *fp;
X    struct literal *lp;
X    struct event *ep;
X    
X    if (pp == NULL) return NULL;
X    
X    next = (struct picture *)pp->link.next;
X    
X    for(fp = pp->field; fp != NULL; fp = unget_field(fp))
X	;
X	
X    for(lp = pp->literal; lp != NULL; lp = unget_literal(lp))
X	;
X
X    for(ep = pp->event; ep != NULL; ep = unget_event(ep))
X	;
X
X    if (pp->link.name) free(pp->link.name);
X
X    free(pp);
X
X    return next;
X}
X
Xstatic int found_field(pp)
X    struct picture *pp;
X{
X    struct field *fp;
X    
X    if ((fp = get_field()) == NULL) return FAIL;
X
X    link((struct link **)&pp->field, &fp->link, TYPE_FIELD);
X
X    return OK;
X}
X
Xstatic int found_literal(pp)
X    struct picture *pp;
X{
X    struct literal *lp;
X    
X    if ((lp = get_literal()) == NULL) return FAIL;
X    
X    link((struct link **)&pp->literal, &lp->link, TYPE_LITERAL);
X
X    return OK;
X}
X
Xstatic int found_event(pp)
X    struct picture *pp;
X{
X    struct event *ep;
X    
X    if ((ep = get_event()) == NULL) return FAIL;
X    
X    link((struct link **)&pp->event, &ep->link, TYPE_EVENT);
X
X    return OK;
X}
X
END_OF_FILE
if test 3364 -ne `wc -c <'src/get_picture.c'`; then
    echo shar: \"'src/get_picture.c'\" unpacked with wrong size!
fi
# end of 'src/get_picture.c'
fi
if test -f 'src/get_stmt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/get_stmt.c'\"
else
echo shar: Extracting \"'src/get_stmt.c'\" \(2158 characters\)
sed "s/^X//" >'src/get_stmt.c' <<'END_OF_FILE'
X/*******************************************************************************
X *
X *		G E T _ S T M T . C
X *		-------------------
X *
X * Description:
X *	Compiles a C-statement block into an allocated memory chain.
X *
X * Included functions:
X *	get_stmt	- Does the job
X *
X * Revision:
X *	Ver	Date	By		Reason
X *	---	----	--		------
X *	1.00	900625	Lars Berntzon	Created
X *
X ******************************************************************************/
X
X#include "config.h"
X
X#include <stdio.h>
X#include <ctype.h>
X#include <string.h>
X
X#ifdef STDLIB_H
X#include <stdlib.h>
X#endif
X#ifdef MALLOC_H
X#include <malloc.h>
X#endif
X
X#include "token.h"
X#include "comp.h"
X
X#define isnormal(ch) (isalnum(ch) || (ch) == '_')
X
Xstruct stmt *get_stmt()
X{
X    char input[500];
X    char token[TOKENSIZE];
X    struct stmt *first = NULL, *sp = NULL, *tail = NULL;
X    int pos = 0;
X    int nesting = 1;
X    
X    if (GetTokNC(token) == NULL) {
X	error("premature end of file fot C-statement");
X	return NULL;
X    }
X    
X    if (strcmp(token, "{") != 0) {
X    	error("expected '{' for C-statement");
X    	return NULL;
X    }
X    
X    for(;;) {
X    	if (GetTokNC(token) == NULL) {
X    	    error("premature end of file for C-statement");
X    	    return NULL;
X    	}
X    	
X	if (strcmp(token, "{") == 0) nesting++;
X	else if (strcmp(token, "}") == 0) nesting--;
X	
X	if (newline || nesting == 0) {
X	    if (pos != 0) {
X	    	sp = memalloc(offsetof(struct stmt, txt[strlen(input) + 1]));
X	    	sp->line = line - newline;
X	    	strcpy(sp->txt, input);
X	    	sp->next = NULL;
X	    	if (first == NULL) {
X	    	    first = sp;
X	    	}
X	    	else {
X	    	    tail->next = sp;
X	    	}
X	    	tail = sp;
X	    }
X	    if (nesting == 0) break;
X	    
X	    pos = (nesting - 1) * 4; /* indentation */
X	    memset(input, ' ', pos);
X	    input[pos] = 0;
X	}
X	
X	if (pos != 0 && isnormal(token[0]) && isnormal(input[pos - 1])) {
X	    strcpy(input + pos, " ");
X	    pos += 1;
X	}
X	strcpy(input + pos, token);
X	pos += strlen(token);
X    }
X    return first;
X}
X
Xvoid unget_stmt(struct stmt *sp)
X{
X    struct stmt *next;
X    
X    for(; sp != NULL; sp = next) {
X    	next = sp->next;
X    	free(sp);
X    }
X}    
X    
X    
END_OF_FILE
if test 2158 -ne `wc -c <'src/get_stmt.c'`; then
    echo shar: \"'src/get_stmt.c'\" unpacked with wrong size!
fi
# end of 'src/get_stmt.c'
fi
if test -f 'src/get_viewport.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/get_viewport.c'\"
else
echo shar: Extracting \"'src/get_viewport.c'\" \(3066 characters\)
sed "s/^X//" >'src/get_viewport.c' <<'END_OF_FILE'
X/*******************************************************************************
X *
X *		G E T _ V I E W P O R T . C
X *		---------------------------
X *
X * Description:
X *	Compiles a viewport statement.
X *
X * Included functions:
X *	get_viewport	- Does the job
X *
X * Revision:
X *	Ver	Date	By		Reason
X *	---	----	--		------
X *	1.00	900619	Lars Berntzon	Created
X *
X ******************************************************************************/
X
X#include "config.h"
X
X#include <stdio.h>
X#include <ctype.h>
X#include <string.h>
X#ifdef STDLIB_H
X#include <stdlib.h>
X#endif
X#ifdef MALLOC_H
X#include <malloc.h>
X#endif
X
X#include "token.h"
X#include "comp.h"
X
X#define isnormal(ch) (isalnum(ch) || (ch) == '_')
X
Xstatic int found_pos();
Xstatic int found_size();
X
Xstatic struct lookup_s lookup[] = {
X    "POS",  found_pos,
X    "SIZE", found_size
X};
X
Xstruct viewport *get_viewport()
X{
X    char token[TOKENSIZE];
X    struct viewport *vp = NULL;
X    int i;
X    
X    if (GetTokNC(token) == NULL || !isnormal(token[0])) {
X    	error("expected name of viewport");
X    	return NULL;
X    }
X    
X    vp = memalloc(sizeof *vp);
X    link_name(&vp->link, token);
X    
X    if(GetTokNC(token) == NULL || strcmp(token, "{")) {
X    	error("expected '{'");
X    	unget_viewport(vp);
X    	return NULL;
X    }
X    
X    while(GetTokNC(token) != NULL) {
X    	if (strcmp(token, "}") == 0) break;
X    	
X	for(i = 0; i < N_CMDS; i++) {
X	    if(strequ(token, lookup[i].cmd) == 0) break;
X	}
X	if (i < N_CMDS) {
X	    if ((*lookup[i].func)(vp) != OK) {
X	        unget_viewport(vp);
X	        return NULL;
X	    }
X	}
X	else {
X	    fprintf(stderr, "line %d: unknown token '%s'\n", line, token);
X	}
X    }
X    return vp;
X}
X
Xstruct viewport *unget_viewport(struct viewport *vp)
X{
X    struct viewport *next;
X
X    if (vp == NULL) return NULL;
X    
X    next = (struct viewport *)vp->link.next;
X    if (vp->link.name) free(vp->link.name);
X    free(vp);
X    return next;
X}
X
Xstatic int found_pos(vp)
X    struct viewport *vp;
X{
X    char token[TOKENSIZE];
X    
X    if (!GetTokNC(token) || !isdigit(token[0])) {
X    	error("expected column");
X    	return FAIL;
X    }
X    vp->pos.x = atoi(token);
X    
X    if(!GetTokNC(token) || strcmp(token, ",")) {
X    	error("expected ','");
X    	return FAIL;
X    }
X    if (!GetTokNC(token) || !isdigit(token[0])) {
X    	error("expected row");
X    	return FAIL;
X    }
X    vp->pos.y = atoi(token);
X    if (!GetTokNC(token) || strcmp(token, ";")) {
X    	error("expected row");
X    	return FAIL;
X    }
X    return OK;
X}
X
Xstatic int found_size(vp)
X    struct viewport *vp;
X{
X    char token[TOKENSIZE];
X    
X    if (!GetTokNC(token) || !isdigit(token[0])) {
X    	error("expected column");
X    	return FAIL;
X    }
X    vp->size.x = atoi(token);
X    
X    if(!GetTokNC(token) || strcmp(token, ",")) {
X    	error("expected ','");
X    	return FAIL;
X    }
X
X    if (!GetTokNC(token) || !isdigit(token[0])) {
X    	error("expected row");
X    	return FAIL;
X    }
X    vp->size.y = atoi(token);
X    if (!GetTokNC(token) || strcmp(token, ";")) {
X    	error("expected row");
X    	return FAIL;
X    }
X    return OK;
X}
X
END_OF_FILE
if test 3066 -ne `wc -c <'src/get_viewport.c'`; then
    echo shar: \"'src/get_viewport.c'\" unpacked with wrong size!
fi
# end of 'src/get_viewport.c'
fi
if test -f 'src/keys.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/keys.h'\"
else
echo shar: Extracting \"'src/keys.h'\" \(5569 characters\)
sed "s/^X//" >'src/keys.h' <<'END_OF_FILE'
X    "BS",		"'\\b'",
X    "CR",		"'\\n'",
X    "TAB",		"'\t'",
X    "BREAK",		"KEY_BREAK", /* break key (unreliable) */
X    "DOWN",		"KEY_DOWN", /* Sent by terminal down arrow key */
X    "UP",		"KEY_UP", /* Sent by terminal up arrow key */
X    "LEFT",		"KEY_LEFT", /* Sent by terminal left arrow key */
X    "RIGHT",		"KEY_RIGHT", /* Sent by terminal right arrow key */
X    "HOME",		"KEY_HOME", /* Sent by home key. */
X    "BACKSPACE",	"KEY_BACKSPACE", /* Sent by backspace key */
X    "F0",		"KEY_F0", /* function key f0. */
X    "F1",	        "(KEY_F0+(1))",
X    "F2",	        "(KEY_F0+(2))",
X    "F3",	        "(KEY_F0+(3))",
X    "F4",	        "(KEY_F0+(4))",
X    "F5",	        "(KEY_F0+(5))",
X    "F6",	        "(KEY_F0+(6))",
X    "F7",	        "(KEY_F0+(7))",
X    "F8",	        "(KEY_F0+(8))",
X    "F9",	        "(KEY_F0+(9))",
X    "F10",	        "(KEY_F0+(10))",
X    "F11",	        "(KEY_F0+(11))",
X    "F12",	        "(KEY_F0+(12))",
X    "F13",	        "(KEY_F0+(13))",
X    "F14",	        "(KEY_F0+(14))",
X    "F15",	        "(KEY_F0+(15))",
X    "F16",	        "(KEY_F0+(16))",
X    "F17",	        "(KEY_F0+(17))",
X    "F18",	        "(KEY_F0+(18))",
X    "F19",	        "(KEY_F0+(19))",
X    "F20",	        "(KEY_F0+(20))",
X    "DL",		"KEY_DL", /* Sent by delete line key. */
X    "IL",		"KEY_IL", /* Sent by insert line. */
X    "DC",		"KEY_DC", /* Sent by delete character key. */
X    "IC",		"KEY_IC", /* Sent by ins char/enter ins mode key. */
X    "EIC",		"KEY_EIC", /* Sent by rmir or smir in insert mode. */
X    "CLEAR",		"KEY_CLEAR", /* Sent by clear screen or erase key. */
X    "EOS",		"KEY_EOS", /* Sent by clear-to-end-of-screen key. */
X    "EOL",		"KEY_EOL", /* Sent by clear-to-end-of-line key. */
X    "SF",		"KEY_SF", /* Sent by scroll-forward/down key */
X    "SR",		"KEY_SR", /* Sent by scroll-backward/up key */
X    "NPAGE",		"KEY_NPAGE", /* Sent by next-page key */
X    "PPAGE",		"KEY_PPAGE", /* Sent by previous-page key */
X    "STAB",		"KEY_STAB", /* Sent by set-tab key */
X    "CTAB",		"KEY_CTAB", /* Sent by clear-tab key */
X    "CATAB",		"KEY_CATAB", /* Sent by clear-all-tabs key. */
X    "ENTER",		"KEY_ENTER", /* Enter/send (unreliable) */
X    "SRESET",		"KEY_SRESET", /* soft (partial) reset (unreliable) */
X    "RESET",		"KEY_RESET", /* reset or hard reset (unreliable) */
X    "PRINT",		"KEY_PRINT", /* print or copy */
X    "LL",		"KEY_LL", /* Sent by home-down key */
X					/* The keypad is arranged like this: */
X					/*    a1    up    a3   */
X					/*   left   b2  right  */
X					/*    c1   down   c3   */
X    "A1",		"KEY_A1", /* Upper left of keypad */
X    "A3",		"KEY_A3", /* Upper right of keypad */
X    "B2",		"KEY_B2", /* Center of keypad */
X    "C1",		"KEY_C1", /* Lower left of keypad */
X    "C3",		"KEY_C3", /* Lower right of keypad */
X    "BTAB",		"KEY_BTAB", /* Back tab key */
X    "BEG",		"KEY_BEG", /* beg(inning) key */
X    "CANCEL",		"KEY_CANCEL", /* cancel key */
X    "CLOSE",		"KEY_CLOSE", /* close key */
X    "COMMAND",		"KEY_COMMAND", /* cmd (command) key */
X    "COPY",		"KEY_COPY", /* copy key */
X    "CREATE",		"KEY_CREATE", /* create key */
X    "END",		"KEY_END", /* end key */
X    "EXIT",		"KEY_EXIT", /* exit key */
X    "FIND",		"KEY_FIND", /* find key */
X    "HELP",		"KEY_HELP", /* help key */
X    "MARK",		"KEY_MARK", /* mark key */
X    "MESSAGE",		"KEY_MESSAGE", /* message key */
X    "MOVE",		"KEY_MOVE", /* move key */
X    "NEXT",		"KEY_NEXT", /* next object key */
X    "OPEN",		"KEY_OPEN", /* open key */
X    "OPTIONS",		"KEY_OPTIONS", /* options key */
X    "PREVIOUS",	"KEY_PREVIOUS", /* previous object key */
X    "REDO",		"KEY_REDO", /* redo key */
X    "REFERENCE",	"KEY_REFERENCE", /* ref(erence) key */
X    "REFRESH",		"KEY_REFRESH", /* refresh key */
X    "REPLACE",		"KEY_REPLACE", /* replace key */
X    "RESTART",		"KEY_RESTART", /* restart key */
X    "RESUME",		"KEY_RESUME", /* resume key */
X    "SAVE",		"KEY_SAVE", /* save key */
X    "SBEG",		"KEY_SBEG", /* shifted beginning key */
X    "SCANCEL",		"KEY_SCANCEL", /* shifted cancel key */
X    "SCOMMAND",	"KEY_SCOMMAND", /* shifted command key */
X    "SCOPY",		"KEY_SCOPY", /* shifted copy key */
X    "SCREATE",		"KEY_SCREATE", /* shifted create key */
X    "SDC",		"KEY_SDC", /* shifted delete char key */
X    "SDL",		"KEY_SDL", /* shifted delete line key */
X    "SELECT",		"KEY_SELECT", /* select key */
X    "SEND",		"KEY_SEND", /* shifted end key */
X    "SEOL",		"KEY_SEOL", /* shifted clear line key */
X    "SEXIT",		"KEY_SEXIT", /* shifted exit key */
X    "SFIND",		"KEY_SFIND", /* shifted find key */
X    "SHELP",		"KEY_SHELP", /* shifted help key */
X    "SHOME",		"KEY_SHOME", /* shifted home key */
X    "SIC",		"KEY_SIC", /* shifted input key */
X    "SLEFT",		"KEY_SLEFT", /* shifted left arrow key */
X    "SMESSAGE",	"KEY_SMESSAGE", /* shifted message key */
X    "SMOVE",		"KEY_SMOVE", /* shifted move key */
X    "SNEXT",		"KEY_SNEXT", /* shifted next key */
X    "SOPTIONS",	"KEY_SOPTIONS", /* shifted options key */
X    "SPREVIOUS",	"KEY_SPREVIOUS", /* shifted prev key */
X    "SPRINT",		"KEY_SPRINT", /* shifted print key */
X    "SREDO",		"KEY_SREDO", /* shifted redo key */
X    "SREPLACE",	"KEY_SREPLACE", /* shifted replace key */
X    "SRIGHT",		"KEY_SRIGHT", /* shifted right arrow */
X    "SRSUME",		"KEY_SRSUME", /* shifted resume key */
X    "SSAVE",		"KEY_SSAVE", /* shifted save key */
X    "SSUSPEND",	"KEY_SSUSPEND", /* shifted suspend key */
X    "SUNDO",		"KEY_SUNDO", /* shifted undo key */
X    "SUSPEND",		"KEY_SUSPEND", /* suspend key */
X    "UNDO",		"KEY_UNDO", /* undo key */
X    "MOUSE",		"KEY_MOUSE", /* Mouse event has occured */
END_OF_FILE
if test 5569 -ne `wc -c <'src/keys.h'`; then
    echo shar: \"'src/keys.h'\" unpacked with wrong size!
fi
# end of 'src/keys.h'
fi
if test -f 'src/skip_stmt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/skip_stmt.c'\"
else
echo shar: Extracting \"'src/skip_stmt.c'\" \(1238 characters\)
sed "s/^X//" >'src/skip_stmt.c' <<'END_OF_FILE'
X/******************************************************************************
X *
X *		S K I P _ S T M T . C
X *		---------------------
X *
X * Description:
X *	Skips a C-statement block.
X *
X * Included functions:
X *	skip_stmt	- Does the job
X *
X * Revision:
X *	Ver	Date	By		Reason
X *	---	----	--		------
X *	1.00	900625	Lars Berntzon	Created
X *
X ******************************************************************************/
X
X#include "config.h"
X
X#include <stdio.h>
X#include <ctype.h>
X#include <string.h>
X#ifdef STDLIB_H
X#include <stdlib.h>
X#endif
X#ifdef MALLOC_H
X#include <malloc.h>
X#endif
X
X#include "token.h"
X#include "comp.h"
X
X#define isnormal(ch) (isalnum(ch) || (ch) == '_')
X
Xskip_stmt()
X{
X    char token[TOKENSIZE];
X    int nesting;
X    
X    if (GetTokNC(token) == NULL) {
X    	error("premature end of file for C-statement");
X    	return FAIL;
X    }
X
X    if (strcmp(token, "{") != 0) {
X    	error("expected '{' for C-statement");
X    	return FAIL;
X    }
X    
X    for(nesting = 1; nesting != 0;) {
X    	if(GetTokNC(token) == NULL) {
X    	    error("premature end of file for C-statement");
X    	    return FAIL;
X    	}
X    	
X	if (strcmp(token, "{") == 0) nesting++;
X	else if (strcmp(token, "}") == 0) nesting--;
X    }
X
X    return OK;
X} 
END_OF_FILE
if test 1238 -ne `wc -c <'src/skip_stmt.c'`; then
    echo shar: \"'src/skip_stmt.c'\" unpacked with wrong size!
fi
# end of 'src/skip_stmt.c'
fi
if test -f 'src/token.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/token.h'\"
else
echo shar: Extracting \"'src/token.h'\" \(1004 characters\)
sed "s/^X//" >'src/token.h' <<'END_OF_FILE'
X/*******************************************************************************
X *
X *		T O K E N . H
X *		-------------
X *
X * Description:
X *	Includefile for token routines.
X *
X * Revision:
X *	Ver    Date     By		Reason
X *	---    ----     --		------
X *	1.00   900619	Lars Berntzon	Created
X *
X ******************************************************************************/
X
X
X	/* D e f i n i t i o n s */
X
X#define TOKENSIZE 200		/* Maximal size of a token		      */
X
X
X	/* G l o b a l   v a r i a b l e s */
X
Xextern int newline;		/* Number of newlines before this token       */
Xextern int line;		/* Current line number			      */
Xextern FILE *in;		/* Input file set by OpenTok()		      */
X
X
X	/* G l o b a l   f u n c t i o n s */
X
Xextern char *GetTok(char *token);	/* Get one token		      */
Xextern char *GetTokNC(char *token);	/* Get token but skip comment	      */
Xextern void UnGetTok(char *token);	/* Push back one token		      */
Xextern FILE *OpenTok(char *filename);	/* Open file for input		     */
END_OF_FILE
if test 1004 -ne `wc -c <'src/token.h'`; then
    echo shar: \"'src/token.h'\" unpacked with wrong size!
fi
# end of 'src/token.h'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
