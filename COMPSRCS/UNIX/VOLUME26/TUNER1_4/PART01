Newsgroups: comp.sources.unix
From: jack@cwi.nl (Jack Jansen)
Subject: v26i164: tuner - a Motif-based utility for "radio" reception, Part01/01
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: jack@cwi.nl (Jack Jansen)
Posting-Number: Volume 26, Issue 164
Archive-Name: tuner1.4/part01

This is tuner version 1.4, a motif-based tuner to accompany the ethernet
radio program, allowing you to select an ethernet radio station to listen
to. It is meant to work with radio 2.0, but will also work with older
releases of radio, although the playlist feature will not work.

"Radio" is a set of programs that allows you to connect an audio source
(radio, CD player) to your Sun, SGI or NeXT workstation and broadcast low-fi
(approximately AM radio quality) audio over a local area network. Other
users can then listen to your broadcasts.

Radio is distributed separately, and is posted to comp.sources.unix around
this time. It is also available for FTP access, as file /pub/radio2.0.tar.Z
on host ftp.cwi.nl. This tuner is also available there, as
/pub/tuner1.4.shar.

	Jack Jansen
	Centrum voor Wiskunde en Informatica
	Kruislaan 413
	1098 SJ  Amsterdam
	the Netherlands

	phone:    +31 20 592 4098
	fax:      +31 20 592 4199
	internet: jack@cwi.nl
	X.400:    G=Jack;S=Jansen;O=cwi;P=surf;A=400net;C=nl

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  MANIFEST Makefile README Tuner.resources customize.h
#   tuner.h tuner.man tuner_io.c tuner_main.c tuner_sl.c tuner_ui.c
#   tuner_volume.c
# Wrapped by vixie@gw.home.vix.com on Thu Apr 15 18:45:50 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(486 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X Makefile                   1	
X README                     1	
X Tuner.resources            1	
X customize.h                1	
X tuner.h                    1	
X tuner.man                  1	
X tuner_io.c                 1	
X tuner_main.c               1	
X tuner_sl.c                 1	
X tuner_ui.c                 1	
X tuner_volume.c             1	
END_OF_FILE
if test 486 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(1040 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# See file customize.h for additional customizations.
X#
X
X# Customizations for SGI, Irix 4.0:
MOTIF_INC=
MOTIF_LIB=
X
RESDIR=/ufs/jack/etc
BINDIR=/ufs/jack/bin/sgi
X
X#
TUNERFLAGS=-I/share/usr/include -DVOLUME
ALIB=-laudio
X
X#
X# Customizations for Suns with old Motif in a funny place:
X#MOTIF_INC=-DMOTIF1_0 -I/usr/local/X/usr/include/X11/motif
X#MOTIF_LIB=-L/usr/local/X/motif/lib
X
RESDIR=/ufs/jack/etc
BINDIR=/ufs/jack/bin/sgi
X
OBJS=tuner_main.o tuner_ui.o tuner_io.o tuner_sl.o tuner_volume.o
SRCS=tuner_main.c tuner_io.c tuner_ui.c tuner_sl.c tuner_volume.c
XXSRCS=README Makefile Tuner.resources tuner.man tuner.h customize.h
CFLAGS=-O -DRESOURCE_PATH=\"$(RESDIR)/Tuner.resources\" $(MOTIF_INC) \
X	$(TUNERFLAGS)
X
tuner: $(OBJS)
X	$(CC) $(CFLAGS) $(OBJS) $(MOTIF_LIB) $(ALIB) -lXm -lXt -lX11 -lm -o tuner
X
X$(OBJS): tuner.h customize.h Makefile
X
install: tuner Tuner.resources
X	cp tuner $(BINDIR)
X	cp Tuner.resources $(RESDIR)
X
clean:
X	rm -f $(OBJS)
X
shar:	tuner1.4.shar
X
tuner1.4.shar: $(XSRCS) $(SRCS)
X	shar $(XSRCS) $(SRCS) > tuner1.4.shar
END_OF_FILE
if test 1040 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(5108 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X	Tuner 1.4
X	---------
X
This is tuner version 1.4, a motif-based tuner to accompany the
ethernet radio program, allowing you to select an ethernet radio
station to listen to. It is meant to work with radio 2.0, but will
also work with older releases of radio, although the playlist feature
will not work.
X
X"Radio" is a set of programs that allows you to connect an audio
source (radio, CD player) to your Sun, SGI or NeXT workstation and
broadcast low-fi (approximately AM radio quality) audio over a local
area network. Other users can then listen to your broadcasts.
X
Radio is distributed separately, and is posted to comp.sources.unix
around this time. It is also available for FTP access, as file
X/pub/radio2.0.tar.Z on host ftp.cwi.nl. This tuner is also available
there, as /pub/tuner1.4.shar.
X
Differences with 1.3
X--------------------
X
The only functionality that has been added since tuner 1.3 are the
buttons to start radio and listen to the news.
X
Building tuner
X--------------
X
Tuner has been tested on an SGI Iris Indigo running Irix 4.0.2 with
Motif 1.1.
X
Version 1.3 also ran on a Sun Sparcstation running SunOS 4.1 with
Motif 1.0, and I have no reasons to believe this will not work anymore.
X
The Motif 1.0 user interface has some quirks (updates of the
X'playlist' list is an... uhm.... interesting process to watch:-) but
it does work.
X
Before building tuner, the Makefile, customize.h and possibly
Tuner.resources should be edited to reflect you local configuration.
X
X  The references to 'anp' need a little explanation. We have a service
X  locally where we record the hourly newsbulletin from the radio and
X  make it available to anyone at any time through the 'anp' program
X  (named after the dutch newsservice). We do not distribute this stuff
X  because it is both machine- and country-dependent (we recognize the
X  news by doing FFTs on the audio and recognizing the leader tune).
X
X  If you want to implement a similar service and make it available
X  through tuner the easiest way is to do is is:
X  - find some way to put the news in a file every hour,
X  - create a script with (roughly) the following contents:
X     #!/bin/sh
X     playaudio newsfile &
X     echo $!
X     wait
X    where 'playaudio' is your audio player. Then set ANP_COMMAND in
X    customize.h to the name of this script. The bit with echo and wait
X    is meant to make it possible for tuner to abort the news.
X
In the Makefile, edit MOTIF_INC if you have Motif 1.0 (add option
X-DMOTIF1_0) and/or if your motif include files live in a non-standard
place (add option -I<include-path>).
X
Next, add an option -L<lib-path> to the MOTIF_LIB variable if your
motif library (or X library, or Xt library) doesn't live in the
standard library path.
X
XFinally, update the RESDIR and BINDIR variables to reflect in which
directories you are going to keep the resource file and the tuner
binary.
X
In the file customize.h you have to edit the DFT_NETS define. It should
be set to all networks on which tuner should look for radio stations.
XEdit the RADIO_COMMAND to something that starts radio on your system.
XEdit ANP_COMMAND to start the newscast, or remove the definition if
you do not want this feature.
X
You might have to edit Tuner.resources to change the default
appearance of tuner. This will be the case if you use monochrome
machines (tuner will not look very nice on a monochrome machine with
the Tuner.resources file as distributed), if you don't have adobe
fonts or if you want to use a language other than English.
X
You are now ready to 'make' and 'make install' to build and install tuner.
X
Notes
X-----
X
Tuner is copyrighted but freely distributable. See the copyright
notice below. If you make changes to tuner I would like to hear from you.
X
X	Jack Jansen
X	Centrum voor Wiskunde en Informatica
X	Kruislaan 413
X	1098 SJ  Amsterdam
X	the Netherlands
X
X	phone:    +31 20 592 4098
X	fax:      +31 20 592 4199
X	internet: jack@cwi.nl
X	X.400:    G=Jack;S=Jansen;O=cwi;P=surf;A=400net;C=nl
X
X
Copyright notice
X----------------
X
Copyright 1991, 1992, 1993 by Stichting Mathematisch Centrum, Amsterdam, The
Netherlands.
X
X                        All Rights Reserved
X
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Stichting Mathematisch
Centrum or CWI not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior permission.
X
STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO
THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
XFITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE
XFOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
END_OF_FILE
if test 5108 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'Tuner.resources' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Tuner.resources'\"
else
echo shar: Extracting \"'Tuner.resources'\" \(4396 characters\)
sed "s/^X//" >'Tuner.resources' <<'END_OF_FILE'
X#
X# Section one - Resources defining layout
X#
X
Tuner*form.width:			600
Tuner*form.height:			250
X
Tuner*topAttachment:			attach_position
Tuner*bottomAttachment:			attach_position
Tuner*leftAttachment:			attach_position
Tuner*rightAttachment:			attach_position
X
Tuner*labelCurrent.topPosition:		1
Tuner*labelCurrent.bottomPosition:	10
Tuner*labelCurrent.leftPosition:	1
Tuner*labelCurrent.rightPosition:	33
X
Tuner*labelPlaylist.topPosition:	1
Tuner*labelPlaylist.bottomPosition:	10
Tuner*labelPlaylist.leftPosition:	67
Tuner*labelPlaylist.rightPosition:	99
X
Tuner*labelTuner.topPosition:		1
Tuner*labelTuner.bottomPosition:	10
Tuner*labelTuner.leftPosition:		34
Tuner*labelTuner.rightPosition:		66
X
Tuner*stationF.topPosition:		11
Tuner*stationF.bottomPosition:		21
Tuner*stationF.leftPosition:		1
Tuner*stationF.rightPosition:		33
X
Tuner*labelCurPlaying.topPosition:	22
Tuner*labelCurPlaying.bottomPosition:	32
Tuner*labelCurPlaying.leftPosition:	1
Tuner*labelCurPlaying.rightPosition:	33
X
Tuner*playingF.topPosition:		33
Tuner*playingF.bottomPosition:		43
Tuner*playingF.leftPosition:		1
Tuner*playingF.rightPosition:		33
X
Tuner*labelCurTime.topPosition:		44
Tuner*labelCurTime.bottomPosition:	54
Tuner*labelCurTime.leftPosition:	1
Tuner*labelCurTime.rightPosition:	33
X
Tuner*timeF.topPosition:		55
Tuner*timeF.bottomPosition:		65
Tuner*timeF.leftPosition:		1
Tuner*timeF.rightPosition:		33
X
Tuner*playlistSW.topPosition:		11
Tuner*playlistSW.bottomPosition:	99
Tuner*playlistSW.leftPosition:		67
Tuner*playlistSW.rightPosition:		99
X
Tuner*tunerSW.topPosition:		11
Tuner*tunerSW.bottomPosition:		89
Tuner*tunerSW.leftPosition:		34
Tuner*tunerSW.rightPosition:		66
X
Tuner*details.topPosition:		90
Tuner*details.bottomPosition:		99
Tuner*details.leftPosition:		1
Tuner*details.rightPosition:		33
X
Tuner*labelVolume.topPosition:		66
Tuner*labelVolume.bottomPosition:	76
Tuner*labelVolume.leftPosition:		1
Tuner*labelVolume.rightPosition:	9
X
Tuner*volume.topPosition:		66
Tuner*volume.bottomPosition:		76
Tuner*volume.leftPosition:		10
Tuner*volume.rightPosition:		33
Tuner*volume.orientation:		horizontal
Tuner*volume.showArrows:		false
Tuner*volume.minimum:			0
Tuner*volume.maximum:			271
Tuner*volume.sliderSize:		16
X
Tuner*mute.topPosition:			78
Tuner*mute.bottomPosition:		88
Tuner*mute.leftPosition:		1
Tuner*mute.rightPosition:		16
X
Tuner*radio.topPosition:		78
Tuner*radio.bottomPosition:		88
Tuner*radio.leftPosition:		17
Tuner*radio.rightPosition:		33
X
Tuner*revert.topPosition:		90
Tuner*revert.bottomPosition:		99
Tuner*revert.leftPosition:		34
Tuner*revert.rightPosition:		66
X
Tuner*OK.topPosition:			89
Tuner*OK.bottomPosition:		99
Tuner*OK.leftPosition:			1
Tuner*OK.rightPosition:			16
X
Tuner*anp.topPosition:			89
Tuner*anp.bottomPosition:		99
Tuner*anp.leftPosition:			17
Tuner*anp.rightPosition:		33
X
Tuner*shadowThickness:			2
Tuner*XmFrame.shadowType:		shadow_in
X
X#
X# Section 2 - Resources defining labels
X#
Tuner*labelCurrent.labelString: 	Current station:
Tuner*labelCurPlaying.labelString:	Playing:
Tuner*labelCurTime.labelString:		Since:
Tuner*labelPlaylist.labelString:	Playlist:
Tuner*labelTuner.labelString:		Choose new station:
Tuner*labelVolume.labelString:		Vol:
X
Tuner*mute.labelString:			Mute
Tuner*revert.labelString:		Previous
Tuner*OK.labelString:			Exit
Tuner*radio.labelString:		Start radio
Tuner*anp.labelString:			ANP
X
X#
X# Section 3 - Resources defining colors used.
X#
X# Scheme used: one color for 'select things', one for 'current station things',
X# one for 'new station things', one for background.
X# playlist color is selected from tuner highlight or station color.
X#
Tuner*background:			grey70
Tuner*foreground:			black
Tuner*labelCurrent.foreground:		blue
Tuner*labelTuner.foreground:		green
X
Tuner*playlist.background:		grey80
Tuner*playing.background:		grey80
Tuner*station.background:		grey80
Tuner*time.background:			grey80
Tuner*volume.background:		grey80
X
X#
X# Section 4 - Fonts used.
X#
Tuner*XmPushButton*fontList:		-adobe-courier-bold-r-*--10-*
Tuner*XmToggleButton*fontList:		-adobe-courier-bold-r-*--10-*
Tuner*XmLabel*fontList:			-adobe-courier-bold-o-*--14-*
Tuner*station*fontList:			-adobe-courier-medium-r-*--10-*
Tuner*playing*fontList:			-adobe-courier-medium-r-*--10-*
Tuner*time*fontList:			-adobe-courier-medium-r-*--10-*
Tuner*tuner*fontList:			-adobe-courier-bold-r-*--10-*
Tuner*playlist*fontList:		-adobe-helvetica-medium-r-*--8-*
END_OF_FILE
if test 4396 -ne `wc -c <'Tuner.resources'`; then
    echo shar: \"'Tuner.resources'\" unpacked with wrong size!
fi
# end of 'Tuner.resources'
fi
if test -f 'customize.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'customize.h'\"
else
echo shar: Extracting \"'customize.h'\" \(898 characters\)
sed "s/^X//" >'customize.h' <<'END_OF_FILE'
X
X/*
X** Where the default resources are.
X*/
X#ifndef RESOURCE_PATH
X#define RESOURCE_PATH	"./Tuner.resources"
X#endif
X
X/*
X** Max number of broadcast nets searched, radio stations and
X** records listed in playlist.
X*/
X#define MAXNET 5		/* Maximum number of networks to poll */
X#define MAXSTATION 20		/* Maximum number of stations */
X#define MAXPLBUF 100		/* Keep 100 last tracks */
X#define MAXNAME 64		/* Max size of all sorts of names */
X
X/*
X** Networks on which to look for radio stations
X*/
X#define DFT_NETS	"192.16.184.0", "192.16.191.0", "192.16.201.255"
X
X/*
X** Control ports for transmitter and radio programs.
X*/
X#define CTLPRT_SCALL	54317
X#define CTLPRT_XMIT	54319
X#define CTLPRT_RADIO	54320
X
X/*
X** Timeout (in seconds) waiting for replies to station locate broadcast
X*/
X#define WAIT_TIMEOUT	2
X
X#define RADIO_COMMAND	"/usr/local/radio/bin/radio &"
X#define ANP_COMMAND	"/ufs/jack/bin/sgi/anp -p"
END_OF_FILE
if test 898 -ne `wc -c <'customize.h'`; then
    echo shar: \"'customize.h'\" unpacked with wrong size!
fi
# end of 'customize.h'
fi
if test -f 'tuner.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tuner.h'\"
else
echo shar: Extracting \"'tuner.h'\" \(1620 characters\)
sed "s/^X//" >'tuner.h' <<'END_OF_FILE'
X#include <X11/Intrinsic.h>
X#include <Xm/Xm.h>
X
X#include "customize.h"
X
X#ifdef __STDC__
X#define ARGS(x) x
X#else
X#define ARGS(x) ()
X#define void int
X#endif
X
X#ifndef GLOBAL
X#define GLOBAL extern
X#endif /* GLOBAL */
X
GLOBAL int cur_tune;					/* From tuner_io */
X
GLOBAL Widget toplevel;                             /* Main widget */
X
GLOBAL Widget form;					   /* The form */
X
GLOBAL Widget currentStation, currentPlaying, currentTime; /* current station info */
GLOBAL Widget playlistBrowser;                             /* cur playlist */
GLOBAL Widget tunerBrowser;                                /* station selector */
GLOBAL Widget muteButton;                                  /* The buttons */
GLOBAL Widget detailsButton;
GLOBAL Widget revertButton;
GLOBAL Widget listenButton;
GLOBAL Widget okButton;
GLOBAL Widget radioButton;
X#ifdef ANP_COMMAND
GLOBAL Widget anpButton;
X#endif /* ANP_COMMAND */
X#ifdef VOLUME
GLOBAL Widget volumeSlider;
GLOBAL Widget labelVolume;
X#endif /* VOLUME */
X
GLOBAL Widget labelCurrent, labelTuner, labelPlaylist;
X
GLOBAL XmString *tunerData;
X
GLOBAL XmString *playlistData;                             /* The playlist */
GLOBAL int playlistDataN;
X
GLOBAL int origstation;
X
X/* From tuner_main.c */
void do_tune ARGS((int));
void do_mute ARGS((int));
void do_revert ARGS((void));
X
X/* From tuner_ui.c */
void init_ui ARGS((int *, char **));
void show_tune ARGS((int, char *, char *, char *, int));
void show_tuner ARGS((char **, int));
void show_playlist ARGS((char **, int, int));
X
X/* From tuner_io.c */
void sendsock ARGS((int, struct sockaddr_in *, char *));
char *recvsock ARGS((int));
END_OF_FILE
if test 1620 -ne `wc -c <'tuner.h'`; then
    echo shar: \"'tuner.h'\" unpacked with wrong size!
fi
# end of 'tuner.h'
fi
if test -f 'tuner.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tuner.man'\"
else
echo shar: Extracting \"'tuner.man'\" \(1909 characters\)
sed "s/^X//" >'tuner.man' <<'END_OF_FILE'
X.TH TUNER 1 "28 Jan 1993
X.SH NAME
X.B tuner
X- A motif-based tuner for ethernet radio stations
X.SH SYNOPSIS
X.B tuner
X.SH DESCRIPTION
Tuner is used in conjunction with
X.IR radio (1)
and
X.IR transmitter (1),
the CWI ethernet radio software. It allows you to browse through the
available radio stations and their playlists and to select one to
listen to.
X.LP
The window shows the name of the station you are currently listening
to, what it is playing and since when, a list of stations that are
currently in the air and the playlist of the current station (i.e. the
most recent 100 records played), if available.
If you select a new station in the
station browser the playlist browser will tune your radio to the selected
station. This also updates the playlist display.
When new stations come on the air or when the currently tuned
station changes records the display is updated accordingly.
X.LP
The
X.I `mute'
toggle sends a message to the radio program asking it to shut up (or,
if it is already muted, to continue playing).
X.LP
The
X.I `revert'
button sets the station back to what it originally was.
X.LP
The
X.I `OK'
button exits tuner.
X.LP
The
X.I `radio'
button attempts to start a radio program. No check is made whether a
radio program is already running, so use with care.
X.LP
If stored newsbulletins are available on your system the
X.I `anp'
button will play the most recent news bulletin.
X.LP
If you are using an SGI a volume slider will allow you to control the
output volume.
X
X.LP
The program uses an X resource file to control many aspects of its
appearance and behaviour, so you can change quite a few things to suit
your needs. This might especially be useful for monochrome displays,
since the default resources are tuned for color machines.
X.SH BUGS
Under Motif 1.0 updating the playlist looks weird.
X.SH "SEE ALSO"
radio(1), newcd(1), broadcast(1)
X.SH "AUTHOR"
Jack Jansen, CWI, Jack.Jansen@cwi.nl
END_OF_FILE
if test 1909 -ne `wc -c <'tuner.man'`; then
    echo shar: \"'tuner.man'\" unpacked with wrong size!
fi
# end of 'tuner.man'
fi
if test -f 'tuner_io.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tuner_io.c'\"
else
echo shar: Extracting \"'tuner_io.c'\" \(7883 characters\)
sed "s/^X//" >'tuner_io.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/time.h>
X#include <netinet/in.h>
X#include <netdb.h>
X#include <sys/stat.h>
X
X#ifndef INADDR_NONE
X#define INADDR_NONE -1
X#endif
X
X#include "tuner.h"
X
static do_stationcall();
X
char *dft_nets[] = { DFT_NETS, 0 };
X
char radio_host[64];		/* Host where radio runs */
X
int transmitter_port = CTLPRT_XMIT;	/* Default control port for transmitters */
int radio_port = CTLPRT_RADIO;		/* Default control port for radios */
struct sockaddr_in radio_addr;	/* Address of our radio */
struct sockaddr_in bcast_addrs[MAXNET];	/* Addresses of transmitters */
int num_bcast_addrs = 0;
X
struct station_info {
X    char name[MAXNAME];		/* station name */
X    int port;			/* UDP broadcast port */
X    int is_playing;		/* 1 if currently transmitting */
X    char logfile[MAXNAME];	/* Name of cdlog file */
X    int since;			/* Play time in minutes of current CD */
X    char cdname[MAXNAME];	/* Current CD name */
X};
X
struct station_info stations[MAXSTATION];
X
char *station_names[MAXSTATION];	/* Hack. Points into stations array */
int num_stations;
X
char cur_name[MAXNAME];
char cur_play[MAXNAME];
char cur_time[MAXNAME];
int cur_mute;
int cur_port;
int origtune = -1;
X
int sock;			/* Our socket */
int sc_sock;			/* Stationcall socket */
X
char plbuf[MAXPLBUF][MAXNAME];
char *playlist[MAXPLBUF];
int num_playlist;
X
init_io() {
X    struct hostent *hent;
X    int i;
X
X    for( i=0; i<MAXSTATION; i++)
X      station_names[i] = stations[i].name;
X    /*XXX Process args */
X    sock = opensock();
X    sc_sock = openscsock();
X
X    /*
X    ** Divine address struct for radio station we're controlling.
X    */
X    if ( radio_host[0] == 0 ) {
X	if ( gethostname(radio_host, sizeof(radio_host)) < 0 ) {
X	    perror("gethostname");
X	    exit(1);
X	}
X    }
X    if ( (hent=gethostbyname(radio_host)) == 0 ) {
X#ifndef sun
X	herror(radio_host);
X#else
X	fprintf(stderr, "%s: Unknown host name\n", radio_host);
X#endif
X	exit(1);
X    }
X    radio_addr.sin_family = AF_INET;
X    radio_addr.sin_port = htons(radio_port);
X    memcpy(&radio_addr.sin_addr, hent->h_addr, hent->h_length);
X    /*
X    ** Create list of broadcast addresses for locating stations.
X    */
X    if ( num_bcast_addrs == 0 ) {
X	/*
X	** No addresses in arguments. Do the defaults.
X	*/
X	char **p;
X
X	for( p=dft_nets; *p; p++ )
X	  add_bcast_addr(*p);
X    }
X    /*
X    ** Obtain station info and current station.
X    */
X    get_stations();
X    get_curinfo();
X    origstation = cur_tune;
X    show_tuner(station_names, num_stations);
X    show_tune(cur_tune, cur_name, cur_play, cur_time, cur_mute);
X    show_playlist(playlist, num_playlist,1);
X    watch_socket(sc_sock, do_stationcall);
X}
X
get_stations() {
X    int i;
X    char *s;
X    struct station_info *p;
X
X    /*
X    ** Clear old stations.
X    */
X    num_stations = 0;
X    /*
X    ** Broadcast info request.
X    */
X    for(i=0; i<num_bcast_addrs; i++)
X      sendsock(sock, &bcast_addrs[i], "radio:s");
X    /*
X    ** Receive replies.
X    */
X    while ( (s=recvsock(sock)) ) {
X	p = stations + num_stations;
X	if ( parse_stationcall(p, s) )
X	  num_stations++;
X    }
X}
X
static
do_stationcall(d1, d2, d3)
X    int d1, d2, d3;
X{
X    char *s;
X    struct station_info sistr;
X    int i;
X
X    if ( (s=recvsock(sc_sock)) == NULL ) {
X	fprintf(stderr, "tuner: stationcall event without data?\n");
X	return;
X    }
X    if ( !parse_stationcall(&sistr, s) )
X      return;
X    for ( i=0; i<num_stations; i++)
X      if ( stations[i].port == sistr.port ) {
X	  stations[i] = sistr;
X	  if ( sistr.port == cur_port ) {
X	      if( get_curinfo() )
X		show_playlist(playlist, num_playlist,1);
X	      show_tune(cur_tune, cur_name, cur_play, cur_time, cur_mute);
X	  }
X	  return;
X      }
X    stations[num_stations] = sistr;
X    num_stations++;
X    show_tuner(station_names, num_stations);
X}
X    
parse_stationcall(p, s)
X    struct station_info *p;
X    char *s;
X{
X    int port;
X    char name[MAXNAME], logname[MAXNAME], cdname[MAXNAME];
X    int is_playing, since;
X    int i;
X
X    is_playing = 1;
X    since = -1;
X    cdname[0] = '\0';
X    logname[0] = '\0';
X    i = sscanf(s, "radio:S:%[^:]:%d:%d:%[^:]:%d:%[^\n]", name, &port,
X	       &is_playing, logname, &since, cdname);
X    if ( i >= 2 ) {
X	strncpy(p->name, name, MAXNAME);
X	p->port = port;
X	p->is_playing = is_playing;
X	strncpy(p->logfile, logname, MAXNAME);
X	p->since = since;
X	strncpy(p->cdname, cdname, MAXNAME);
X	return 1;
X    }
X    fprintf(stderr, "Ill-formatted station call(%d): '%s'\n",i,  s);
X    return 0;
X}
X
add_bcast_addr(addr)
X    char *addr;
X{
X    struct sockaddr_in *sp;
X    unsigned long iaddr;
X
X    sp = &bcast_addrs[num_bcast_addrs++];
X    if ( (iaddr=inet_addr(addr)) == INADDR_NONE) {
X	fprintf(stderr, "Ill-formatted address %s\n", addr);
X	exit(1);
X    }
X	
X    sp->sin_family = AF_INET;
X    sp->sin_addr.s_addr = iaddr;
X    sp->sin_port = htons(transmitter_port);
X}
X
get_curinfo() {
X    char *s;
X    int n;
X    int port, muteoff;
X    int i;
X    FILE *fp;
X    char buf[128];
X    int t;
X
X    sendsock(sock, &radio_addr, "radio:i");
X    num_playlist = 0;
X    if ( s = recvsock(sock) ) {
X	/*
X	** Parsing is funny, because older radio programs didn't have the
X	** mute feature (so only send a single number, the port).
X	*/
X	n = sscanf(s, "radio:I:%d:%d", &muteoff, &port);
X	if ( n == 0 ) {
X	    fprintf(stderr, "Funny reply from radio program: %s\n", s);
X	    return 1;
X	}
X	if ( n == 1 ) {
X	    port = muteoff;
X	    muteoff = 1;
X	}
X	cur_mute = !muteoff;
X	cur_port = port;
X	/*
X	** Try to find the corresponding station
X	*/
X	for(i=0; i<num_stations; i++) {
X	    if ( cur_port == stations[i].port ) {
X		cur_tune = i+1;
X		strcpy(cur_name, stations[i].name);
X		strcpy(cur_play, stations[i].cdname);
X		t = stations[i].since / 60;
X		if ( t == 0 )
X		  cur_time[0] = '\0';
X		else if ( t < 60 )
X		  sprintf(cur_time, "%d minutes", t);
X		else
X		  sprintf(cur_time, "%d hours", t/60);
X		if ( !stations[i].is_playing )
X		  strcat(cur_time, "(Silent)");
X		if ( stations[i].logfile[0] )
X		  return get_playlist(stations[i].logfile);
X		return 1;
X	    }
X	}
X	if ( i == num_stations ) {
X	    /* Couldn't find the station number */
X	    cur_tune = 0;
X	    sprintf(cur_name, "Unknown (port %d)", cur_port);
X	    strcpy(cur_play, "?");
X	    strcpy(cur_time, "?");
X	    return 1;
X	}
X    }
X    fprintf(stderr, "Warning: radio program not responding\n");
X    strcpy(cur_name, "?");
X    strcpy(cur_time, "?");
X    strcpy(cur_play, "?");
X    cur_tune = 0;
X    return 1;
X}
X
void
do_tune(station)
X    int station;
X{
X    char buf[32];
X
X    if ( station == 0 ) return;
X    sprintf(buf, "radio:t:%d", stations[station-1].port);
X    sendsock(sock, &radio_addr, buf);
X    get_curinfo();
X    show_tune(cur_tune, cur_name, cur_play, cur_time, cur_mute);
X    show_playlist(playlist, num_playlist,1);
X}
X
X/*
X** do_mute - Mute radio
X*/
void
do_mute(onoff)
X    int onoff;
X{
X    sendsock(sock, &radio_addr, onoff?"radio:0":"radio:1");
X}
X
X/*
X** get last MAXPLBUF entries of playlist file.
X*/
get_playlist(file)
X    char *file;
X{
X    FILE *fp;
X    int i, j;
X    static char fnbuf[MAXNAME];
X    struct stat sb;
X    static int mtime, saved_num_playlist;
X
X    if ( strncmp(file, fnbuf, MAXNAME) == 0 ) {
X	if ( stat(file, &sb) >= 0 && sb.st_mtime == mtime ) {
X	    /* Yes, cached copy still ok */
X	    num_playlist = saved_num_playlist;
X	    return 0;
X	}
X    }
X
X    if ( (fp=fopen(file, "r")) == 0 )
X      return;
X
X    strncpy(fnbuf, file, MAXNAME);
X    stat(file, &sb);
X    mtime = sb.st_mtime;
X
X    i = 0;
X    while( (fgets(plbuf[i%MAXPLBUF], MAXNAME, fp)) ) i++;
X    if ( i == 0 ) {
X	num_playlist = 0;
X	saved_num_playlist = 0;
X	return;
X    }
X    i--;
X
X    if ( i < MAXPLBUF ) {
X	num_playlist = i+1;
X	while ( i >= 0 ) {
X	    playlist[i] = plbuf[i];
X	    i--;
X	}
X    }
X    else {
X	for ( j=0; j<MAXPLBUF; j++) playlist[j] = plbuf[(i+j+1) % MAXPLBUF];
X	num_playlist = MAXPLBUF;
X    }
X    saved_num_playlist = num_playlist;
X    fclose(fp);
X    return 1;
X}
END_OF_FILE
if test 7883 -ne `wc -c <'tuner_io.c'`; then
    echo shar: \"'tuner_io.c'\" unpacked with wrong size!
fi
# end of 'tuner_io.c'
fi
if test -f 'tuner_main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tuner_main.c'\"
else
echo shar: Extracting \"'tuner_main.c'\" \(514 characters\)
sed "s/^X//" >'tuner_main.c' <<'END_OF_FILE'
X#include <stdio.h>
X
X#define GLOBAL
X#include "tuner.h"
X
char *getenv();
X
main(argc, argv)
X    int argc;
X    char **argv;
X{
X
X    if ( getenv("XENVIRONMENT") == 0 )
X#ifdef __STDC__
X      putenv("XENVIRONMENT=" RESOURCE_PATH);
X#else
X      putenv(strcat("XENVIRONMENT=", RESOURCE_PATH));
X#endif
X    
X    init_ui(&argc, argv);
X
X    init_io(&argc, argv);
X
X    if ( argc != 1 ) {
X	fprintf(stderr, "%s: Warning: extraneous args ignored\n", argv[0]);
X	exit(1);
X    }
X    
X    XtRealizeWidget(toplevel);
X
X    XtMainLoop();
X}
END_OF_FILE
if test 514 -ne `wc -c <'tuner_main.c'`; then
    echo shar: \"'tuner_main.c'\" unpacked with wrong size!
fi
# end of 'tuner_main.c'
fi
if test -f 'tuner_sl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tuner_sl.c'\"
else
echo shar: Extracting \"'tuner_sl.c'\" \(2957 characters\)
sed "s/^X//" >'tuner_sl.c' <<'END_OF_FILE'
X/***********************************************************
Copyright 1991 by Stichting Mathematisch Centrum, Amsterdam, The
Netherlands.
X
X                        All Rights Reserved
X
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Stichting Mathematisch
Centrum or CWI not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior permission.
X
STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO
THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
XFITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE
XFOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X
X******************************************************************/
X
X/* Socket-related subroutines shared by broadcast and radio */
X
X#include <stdio.h>
X#include <errno.h>
X#include <stdlib.h>
X#include <fcntl.h>
X#include <netdb.h>
X
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/time.h>
X#include <netinet/in.h>
X
X#include "tuner.h"
X
X#define MSG_BUFSIZE 128				/* Message size */
X
int
opensock()
X{
X	int s;
X	int on = 1;
X
X	s = socket(AF_INET, SOCK_DGRAM, 0);
X	if (s < 0) {
X		perror("socket()");
X		exit(1);
X	}
X
X	if (setsockopt(s, SOL_SOCKET, SO_BROADCAST,
X			&on, sizeof (on)) < 0) {
X		perror("setsockopt(SO_BROADCAST)");
X		exit(1);
X	}
X	return s;
X}
X
int
openscsock()
X{
X    int s;
X    int on = 1;
X    struct sockaddr_in sin;
X
X    s = socket(AF_INET, SOCK_DGRAM, 0);
X#ifdef SO_REUSEPORT
X    (void)setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &on, sizeof(on));
X#endif
X    bzero((char *)&sin, sizeof sin);
X    sin.sin_addr.s_addr = INADDR_ANY;
X    sin.sin_family = AF_INET;
X    sin.sin_port = htons(CTLPRT_SCALL);
X    if ( bind(s, &sin, sizeof sin) < 0) {
X	perror("bind(stationcallsocket)");
X	exit(1);
X    }
X    return s;
X}
X
char *
recvsock(s)
X    int s;
X{
X    fd_set fdset;
X    int rv;
X    struct timeval tv;
X    static char buf[MSG_BUFSIZE];
X
X    FD_ZERO(&fdset);
X    FD_SET(s, &fdset);
X    tv.tv_sec = WAIT_TIMEOUT;
X    tv.tv_usec = 0;
X    if( (rv = select(s+1, &fdset, (fd_set *)0, (fd_set *)0, &tv)) < 0 ) {
X	perror("select(socket)");
X	exit(1);
X    }
X    if ( rv == 0 )
X      return NULL;
X    if ( (rv=recv(s, buf, sizeof(buf), 0)) < 0 ) {
X	perror("recv()");
X	exit(1);
X    }
X    buf[rv] = 0;
X    return buf;
X}
X  
X
void
sendsock(s, to, msg)
X    int s;
X    struct sockaddr_in *to;
X    char *msg;
X{
X    if ( sendto(s, msg, strlen(msg), 0, to, sizeof(*to)) < 0 ) {
X	perror("sendto()");
X	exit(1);
X    }
X}
END_OF_FILE
if test 2957 -ne `wc -c <'tuner_sl.c'`; then
    echo shar: \"'tuner_sl.c'\" unpacked with wrong size!
fi
# end of 'tuner_sl.c'
fi
if test -f 'tuner_ui.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tuner_ui.c'\"
else
echo shar: Extracting \"'tuner_ui.c'\" \(8557 characters\)
sed "s/^X//" >'tuner_ui.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <sys/types.h>
X#include <signal.h>
X#include <Xm/Label.h>
X#include <Xm/PushB.h>
X#include <Xm/ToggleB.h>
X#include <Xm/MainW.h>
X#include <Xm/List.h>
X#include <Xm/Form.h>
X#include <Xm/RowColumn.h>
X#include <Xm/Separator.h>
X#include <Xm/Frame.h>
X#include <Xm/ScrollBar.h>
X
X#include "tuner.h"
X
X#define LABEL(args, n, name, parent) \
X  XtCreateManagedWidget(name, xmLabelWidgetClass, parent, NULL, 0)
X
static void cb_tuner(), cb_mute(), cb_details(), cb_revert(), cb_ok(),
X  cb_playlist(), cb_radio();
X#ifdef ANP_COMMAND
static void cb_anp();
X#endif /* ANP_COMMAND */
X#ifdef VOLUME
static void cb_volume();
X#endif /* VOLUME */
X
int initialized;
char *kept_message;		/* Message to be displayed after init */
X
int tuner_pos = 0, prev_pos = 0;
X
void
init_ui(argcp, argv)
X    int *argcp;
X    char **argv;
X{
X    Arg args[20];
X    int n = 0;
X    XmString str1;
X    char str[100];
X    int i;
X
X    toplevel = XtInitialize(argv[0], "Tuner", NULL, 0, argcp, argv);
X
X    n = 0;
X    form = XtCreateManagedWidget("form", xmFormWidgetClass,
X				toplevel, args, n);
X
X    labelCurrent = LABEL(args, n, "labelCurrent", form);
X
X    n = 0;
X    currentStation = XtCreateManagedWidget("stationF", xmFrameWidgetClass,
X					   form, args, n);
X    
X    n = 0;
X    currentStation = XtCreateManagedWidget("station", xmLabelWidgetClass,
X					   currentStation, args, n);
X
X    (void)LABEL(args, n, "labelCurPlaying", form);
X
X    n = 0;
X    currentPlaying = XtCreateManagedWidget("playingF", xmFrameWidgetClass,
X					   form, args, n);
X    
X    n = 0;
X    currentPlaying = XtCreateManagedWidget("playing", xmLabelWidgetClass,
X					   currentPlaying, args, n);
X
X    (void)LABEL(args, n, "labelCurTime", form);
X
X    n = 0;
X    currentTime = XtCreateManagedWidget("timeF", xmFrameWidgetClass,
X					   form, args, n);
X    
X    n = 0;
X    currentTime = XtCreateManagedWidget("time", xmLabelWidgetClass,
X					currentTime, args, n);
X    
X    labelPlaylist = LABEL(args, n, "labelPlaylist", form);
X    
X    n = 0;
X    playlistBrowser = XmCreateScrolledList(form, "playlist", args, n);
X    XtAddCallback(playlistBrowser, XmNbrowseSelectionCallback, cb_playlist, 0);
X    XtManageChild(playlistBrowser);
X
X    labelTuner = LABEL(args, n, "labelTuner", form);
X
X    n = 0;
X    tunerBrowser = XmCreateScrolledList(form, "tuner", args, n);
X    XtAddCallback(tunerBrowser, XmNbrowseSelectionCallback, cb_tuner, 0);
X    XtManageChild(tunerBrowser);
X
X#ifdef VOLUME
X
X    labelVolume = LABEL(args, n, "labelVolume", form);
X    
X    n = 0;
X    volumeSlider = XtCreateManagedWidget("volume", xmScrollBarWidgetClass,
X				       form, args, n);
X    XtAddCallback(volumeSlider, XmNvalueChangedCallback, cb_volume, 0);
X    show_volume(getvolume());
X#endif /* VOLUME */
X
X    n = 0;
X    muteButton = XtCreateManagedWidget("mute", xmToggleButtonWidgetClass,
X				       form, args, n);
X    XtAddCallback(muteButton, XmNvalueChangedCallback, cb_mute, 0);
X
X    n = 0;
X    revertButton = XtCreateManagedWidget("revert", xmPushButtonWidgetClass,
X					 form, args, n);
X    XtAddCallback(revertButton, XmNactivateCallback, cb_revert, 0);
X
X    n = 0;
X    okButton = XtCreateManagedWidget("OK", xmPushButtonWidgetClass,
X				     form, args, n);
X    XtAddCallback(okButton, XmNactivateCallback, cb_ok, 0);
X
X#ifdef ANP_COMMAND
X    n = 0;
X    anpButton = XtCreateManagedWidget("anp", xmToggleButtonWidgetClass,
X				       form, args, n);
X    XtAddCallback(anpButton, XmNvalueChangedCallback, cb_anp, 0);
X#endif /* ANP_COMMAND */
X
X    n = 0;
X    radioButton = XtCreateManagedWidget("radio", xmPushButtonWidgetClass,
X				     form, args, n);
X    XtAddCallback(radioButton, XmNactivateCallback, cb_radio, 0);
X}
X
static void
cb_playlist(w, udata, wdata)
X    Widget *w;
X    XmListCallbackStruct *wdata;
X    void *udata;
X{
X    XmListDeselectAllItems(playlistBrowser);
X} 
X
static void
cb_tuner(w, udata, wdata)
X    Widget *w;
X    XmListCallbackStruct *wdata;
X    void *udata;
X{
X    prev_pos = tuner_pos;
X    tuner_pos = wdata->item_position;
X    do_tune(tuner_pos);
X} 
X
static void
cb_mute(w, udata, wdata)
X    Widget *w;
X    XmToggleButtonCallbackStruct *wdata;
X    void *udata;
X{
X    do_mute(wdata->set);
X}
X
static void
cb_details(w, udata, wdata)
X    Widget *w;
X    void *wdata;
X    void *udata;
X{
X}
X
static void
cb_revert(w, udata, wdata)
X    Widget *w;
X    void *wdata;
X    void *udata;
X{
X    int i;
X
X    i = prev_pos;
X    prev_pos = tuner_pos;
X    tuner_pos = i;
X    do_tune(tuner_pos);
X}
X
static void
cb_ok(w, udata, wdata)
X    Widget *w;
X    void *wdata;
X    void *udata;
X{
X    exit(0);
X}
X
X#ifdef ANP_COMMAND
int anp_pid = -1;
XFILE *anp_fp;
XXtInputId anp_id;
X
static void
cb_anpdone()
X{
X    do_mute(0);
X    anp_pid = -1;
X    pclose(anp_fp);
X    XtRemoveInput(anp_id);
X}
X
static void
cb_anp(w, udata, wdata)
X    Widget *w;
X    XmToggleButtonCallbackStruct *wdata;
X    void *udata;
X{
X    char dbuf[10];
X    
X    if ( wdata->set ) {
X	if ( anp_pid > 0) {
X	    fprintf(stderr, "tuner: anp already active\n");
X	    return;
X	}
X	do_mute(1);
X	if ( (anp_fp=popen(ANP_COMMAND, "r")) == NULL ) {
X	    perror(ANP_COMMAND);
X	    return;
X	}
X	if ( fgets(dbuf, 10, anp_fp) == NULL
X	    			|| sscanf(dbuf, "%d", &anp_pid) != 1) {
X	    fprintf(stderr, "tuner: anp command did not give pid\n");
X	    fclose(anp_fp);
X	    anp_pid = -1;
X	    return;
X	}
X	anp_id = XtAddInput(fileno(anp_fp), XtInputReadMask, cb_anpdone, 0);
X    } else {
X	if ( anp_pid < 0 ) {
X	    fprintf(stderr, "tuner: anp not active\n");
X	    return;
X	}
X	if ( kill(anp_pid, SIGTERM) < 0 ) {
X	    fprintf(stderr, "kill %d:", anp_pid);
X	    perror("");
X	}	
X	cb_anpdone();
X    }
X}
X#endif /* ANP_COMMAND */
X
static void
cb_radio(w, udata, wdata)
X    Widget *w;
X    void *wdata;
X    void *udata;
X{
X    system(RADIO_COMMAND);
X}
X
X#ifdef VOLUME
static void
cb_volume(w, udata, wdata)
X    Widget *w;
X    XmScrollBarCallbackStruct *wdata;
X    void *udata;
X{
X    setvolume(wdata->value);
X}
X
void
show_volume(value)
X    int value;
X{
X    Arg args[2];
X    int n;
X
X    n = 0;
X    XtSetArg(args[n], XmNvalue, value); n++;
X    XtSetValues(volumeSlider, args, n);
X}
X#endif /* VOLUME */
X
X/*
X** show_tune - Show which station we're tuned to
X*/
void
show_tune(station, name, playing, since, mute)
X    int station;
X    char *name, *playing, *since;
X    int mute;
X{
X    Arg args[2];
X    int n;
X    XmString str;
X    
X    XmListDeselectAllItems(tunerBrowser);
X    if ( station ) {
X      XmListSelectPos(tunerBrowser, station, 0);
X      if ( prev_pos == 0 )
X	prev_pos = station;
X  }
X
X    n = 0;
X    str = XmStringCreateLtoR(name, XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(args[n], XmNlabelString, str); n++;
X    XtSetValues(currentStation, args, n);
X    
X    n = 0;
X    str = XmStringCreateLtoR(playing, XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(args[n], XmNlabelString, str); n++;
X    XtSetValues(currentPlaying, args, n);
X    
X    n = 0;
X    str = XmStringCreateLtoR(since, XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(args[n], XmNlabelString, str); n++;
X    XtSetValues(currentTime, args, n);
X
X    n = 0;
X    XtSetArg(args[n], XmNset, mute); n++;
X    XtSetValues(muteButton, args, n);
X    
X}
X
X/*
X** show_stations - Show new station list.
X*/
static void
new_browser(browser, slist, nitems)
X    Widget browser;
X    char **slist;
X    int nitems;
X{
X    XmString *list;
X    int i;
X
X    /* XXX Should we free old items here? */
X    XmListDeselectAllItems(browser);
X#ifndef MOTIF1_0
X    XmListDeleteAllItems(browser);
X#else
X    {
X	Arg args[1];
X	XtSetArg(args[0], XmNitemCount, NULL);
X	XtGetValues(browser, args, 1);
X	for(i=0; i<(int)args[0].value; i++)
X	  XmListDeletePos(browser, 1);
X    }
X#endif
X    list = (XmString *)XtMalloc(sizeof(XmString)*nitems);
X    for ( i=0; i<nitems; i++)
X	list[i] = XmStringCreate(slist[i], XmSTRING_DEFAULT_CHARSET);
X#ifdef MOTIF1_0
X    for (i=0; i<nitems; i++)
X      XmListAddItem(browser, list[i], i+1);
X#else
X    XmListAddItems(browser, list, nitems, 0);
X#endif
X    for ( i=0; i<nitems; i++) {
X        XtFree(list[i]);
X
X    }
X    XtFree(list);
X}
X
void
show_tuner(slist, nitems)
X    char **slist;
X    int nitems;
X{
X    new_browser(tunerBrowser, slist, nitems);
X}
X
void
show_playlist(slist, nitems, col)
X    char **slist;
X    int nitems;
X{
X    static Arg arg[1];
X
X    new_browser(playlistBrowser, slist, nitems);
X    XmListSetBottomPos(playlistBrowser, 0);
X    XtSetArg(arg[0], XmNforeground, 0);
X    if ( col ) {
X	XtGetValues(labelCurrent, arg, 1);
X    } else {
X	XtGetValues(labelTuner, arg, 1);
X    }
X    XtSetValues(labelPlaylist, arg, 1);
X}
X
watch_socket(sock, cback)
X    int sock;
X    int (*cback)();
X{
X    (void)XtAddInput(sock, XtInputReadMask, cback, 0);
X}
END_OF_FILE
if test 8557 -ne `wc -c <'tuner_ui.c'`; then
    echo shar: \"'tuner_ui.c'\" unpacked with wrong size!
fi
# end of 'tuner_ui.c'
fi
if test -f 'tuner_volume.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tuner_volume.c'\"
else
echo shar: Extracting \"'tuner_volume.c'\" \(481 characters\)
sed "s/^X//" >'tuner_volume.c' <<'END_OF_FILE'
X#include "tuner.h"
X
X#ifdef VOLUME
X
X#include <audio.h>
X
setvolume(value)
X    int value;
X{
X    long par[4];
X
X    par[0] = AL_LEFT_SPEAKER_GAIN;
X    par[1] = value;
X    par[2] = AL_RIGHT_SPEAKER_GAIN;
X    par[3] = value;
X    ALsetparams(AL_DEFAULT_DEVICE, par, 4);
X}
X
getvolume()
X{
X    long par[4];
X    int value;
X
X    par[0] = AL_LEFT_SPEAKER_GAIN;
X    par[2] = AL_RIGHT_SPEAKER_GAIN;
X    ALgetparams(AL_DEFAULT_DEVICE, par, 4);
X    return (par[1]+par[3]) / 2;
X}
X#endif /* VOLUME */
END_OF_FILE
if test 481 -ne `wc -c <'tuner_volume.c'`; then
    echo shar: \"'tuner_volume.c'\" unpacked with wrong size!
fi
# end of 'tuner_volume.c'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
