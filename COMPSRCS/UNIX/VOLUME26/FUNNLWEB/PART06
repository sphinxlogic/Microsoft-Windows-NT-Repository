Newsgroups: comp.sources.unix
From: ross@spam.adelaide.edu.au (Ross Williams)
Subject: v26i126: funnelweb - a tool for literate programming in C, Part06/20
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: ross@spam.adelaide.edu.au (Ross Williams)
Posting-Number: Volume 26, Issue 126
Archive-Name: funnelweb/part06

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 20)."
# Contents:  answers/pr01.lis answers/pr03.lis answers/sc17.lis
#   answers/sc28.lis answers/wv01.tex sources/machin.h
#   sources/memory.c sources/style.h
# Wrapped by vixie@gw.home.vix.com on Sun Apr 11 11:00:18 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'answers/pr01.lis' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'answers/pr01.lis'\"
else
echo shar: Extracting \"'answers/pr01.lis'\" \(14686 characters\)
sed "s/^X//" >'answers/pr01.lis' <<'END_OF_FILE'
XFUNNELWEB LISTING FILE
X======================
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 50 52 30 31 3A 20 54 65 73 74 20 74 68 65 20 69 | PR01: Test the i |
X| 6E 6C 69 6E 65 20 74 79 70 65 73 65 74 74 69 6E | nline typesettin |
X| 67 20 66 65 61 74 75 72 65 73 2E 0A 0A 31 2E 20 | g features...1.  |
X| 46 69 72 73 74 20 77 65 20 74 65 73 74 20 74 68 | First we test th |
X| 65 20 6C 65 67 61 6C 20 75 73 65 20 6F 66 20 74 | e legal use of t |
X| 68 65 20 40 7B 6C 69 74 65 72 61 6C 40 7D 20 63 | he @{literal@} c |
X| 6F 6E 73 74 72 75 63 74 2E 0A 0A 32 2E 54 65 73 | onstruct...2.Tes |
X| 74 20 40 7B 40 7D 20 28 69 6C 6C 65 67 61 6C 29 | t @{@} (illegal) |
X| 2E 0A 40 41 40 3C 45 72 72 6F 72 20 52 65 63 6F | ..@A@<Error Reco |
X| 76 65 72 79 20 50 6F 69 6E 74 40 3E 0A 0A 33 2E | very Point@>..3. |
X| 20 54 65 73 74 20 74 68 65 20 63 6F 6E 73 74 72 |  Test the constr |
X| 75 63 74 20 40 7B 61 63 72 6F 73 73 0A 20 20 20 | uct @{across.    |
X| 6D 6F 72 65 20 74 68 61 6E 20 6F 6E 65 20 6C 69 | more than one li |
X| 6E 65 40 7D 2E 0A 0A 34 2E 20 4E 6F 77 20 77 65 | ne@}...4. Now we |
X| 20 74 65 73 74 20 74 68 65 20 63 6F 6E 73 74 72 |  test the constr |
X| 75 63 74 20 77 69 74 68 20 6E 6F 6E 2D 74 65 78 | uct with non-tex |
X| 74 20 66 6F 6C 6C 6F 77 69 6E 67 20 69 74 2E 0A | t following it.. |
X| 20 20 20 40 7B 40 3C 73 6C 6F 74 68 40 3E 40 7D |    @{@<sloth@>@} |
X| 0A 40 41 40 3C 45 72 72 6F 72 20 52 65 63 6F 76 | .@A@<Error Recov |
X| 65 72 79 20 50 6F 69 6E 74 40 3E 0A 20 20 20 40 | ery Point@>.   @ |
X| 7B 20 20 20 20 20 40 3E 20 20 20 40 7D 0A 40 41 | {     @>   @}.@A |
X| 40 3C 45 72 72 6F 72 20 52 65 63 6F 76 65 72 79 | @<Error Recovery |
X| 20 50 6F 69 6E 74 40 3E 0A 0A 35 2E 20 54 65 73 |  Point@>..5. Tes |
X| 74 20 74 68 65 20 6C 65 67 61 6C 20 75 73 65 20 | t the legal use  |
X| 6F 66 20 74 68 65 20 40 2F 65 6D 70 68 61 73 69 | of the @/emphasi |
X| 73 40 2F 20 63 6F 6E 73 74 72 75 63 74 2E 0A 0A | s@/ construct... |
X| 36 2E 54 65 73 74 20 40 2F 40 2F 20 28 69 6C 6C | 6.Test @/@/ (ill |
X| 65 67 61 6C 29 2E 0A 40 41 40 3C 45 72 72 6F 72 | egal)..@A@<Error |
X| 20 52 65 63 6F 76 65 72 79 20 50 6F 69 6E 74 40 |  Recovery Point@ |
X| 3E 0A 0A 37 2E 20 54 65 73 74 20 74 68 65 20 63 | >..7. Test the c |
X| 6F 6E 73 74 72 75 63 74 20 40 2F 61 63 72 6F 73 | onstruct @/acros |
X| 73 0A 20 20 20 6D 6F 72 65 20 74 68 61 6E 20 6F | s.   more than o |
X| 6E 65 20 6C 69 6E 65 40 2F 2E 0A 0A 38 2E 20 4E | ne line@/...8. N |
X| 6F 77 20 77 65 20 74 65 73 74 20 74 68 65 20 63 | ow we test the c |
X| 6F 6E 73 74 72 75 63 74 20 77 69 74 68 20 6E 6F | onstruct with no |
X| 6E 2D 74 65 78 74 20 66 6F 6C 6C 6F 77 69 6E 67 | n-text following |
X| 20 69 74 2E 0A 20 20 20 40 2F 40 3C 73 6C 6F 74 |  it..   @/@<slot |
X| 68 40 3E 40 2F 0A 40 41 40 3C 45 72 72 6F 72 20 | h@>@/.@A@<Error  |
X| 52 65 63 6F 76 65 72 79 20 50 6F 69 6E 74 40 3E | Recovery Point@> |
X| 0A 20 20 20 40 2F 20 20 20 20 20 40 3C 20 20 20 | .   @/     @<    |
X| 40 2F 0A 0A 0A 0A                               | @/....           |
X+-------------------------------------------------+------------------+
X
X
X=========================== Start of LINE LIST DUMP ============================
X
Globl Local| Text
X-----------+--------------------------------------------------------------------
X00001 00001| PR01: Test the inline typesetting features.<010>
X00002 00002| <010>
X00003 00003| 1. First we test the legal use of the @{literal@} construct.<010>
X00004 00004| <010>
X00005 00005| 2.Test @{@} (illegal).<010>
X00006 00006| @A@<Error Recovery Point@><010>
X00007 00007| <010>
X00008 00008| 3. Test the construct @{across<010>
X00009 00009|    more than one line@}.<010>
X00010 00010| <010>
X00011 00011| 4. Now we test the construct with non-text following it.<010>
X00012 00012|    @{@<sloth@>@}<010>
X00013 00013| @A@<Error Recovery Point@><010>
X00014 00014|    @{     @>   @}<010>
X00015 00015| @A@<Error Recovery Point@><010>
X00016 00016| <010>
X00017 00017| 5. Test the legal use of the @/emphasis@/ construct.<010>
X00018 00018| <010>
X00019 00019| 6.Test @/@/ (illegal).<010>
X00020 00020| @A@<Error Recovery Point@><010>
X00021 00021| <010>
X00022 00022| 7. Test the construct @/across<010>
X00023 00023|    more than one line@/.<010>
X00024 00024| <010>
X00025 00025| 8. Now we test the construct with non-text following it.<010>
X00026 00026|    @/@<sloth@>@/<010>
X00027 00027| @A@<Error Recovery Point@><010>
X00028 00028|    @/     @<   @/<010>
X00029 00029| <010>
X00030 00030| <010>
X00031 00031| <010>
X00032 00032| <End-Of-File><010>
X-----------+--------------------------------------------------------------------
Globl Local| Text
X
X============================ End of LINE LIST DUMP =============================
X
X
X=========================== Start of TOKEN LIST DUMP ===========================
X
Summary: There are 73 tokens in the token list.
X
Line[Column]: Token Description
X-------------------------------
X
X0001[01]: Text. Text scrap[Grey]="PR01: Test the inline typesetting features.<010>
X<010>
X1. First we test the legal use of the "
X0003[39]: @{ Open defn. 
X0003[41]: Text. Text scrap[Grey]="literal"
X0003[48]: @} Close defn. 
X0003[50]: Text. Text scrap[Grey]=" construct.<010>
X<010>
X2.Test "
X0005[08]: @{ Open defn. 
X0005[10]: @} Close defn. 
X0005[12]: Text. Text scrap[Grey]=" (illegal).<010>
X"
X0006[01]: @A New section (Level 1). 
X0006[03]: @< Open name. 
X0006[05]: Text. Text scrap[Grey]="Error Recovery Point"
X0006[25]: @> Close name. 
X0006[27]: Text. Text scrap[Grey]="<010>
X<010>
X3. Test the construct "
X0008[23]: @{ Open defn. 
X0008[25]: Text. Text scrap[Grey]="across<010>
X   more than one line"
X0009[22]: @} Close defn. 
X0009[24]: Text. Text scrap[Grey]=".<010>
X<010>
X4. Now we test the construct with non-text following it.<010>
X   "
X0012[04]: @{ Open defn. 
X0012[06]: @< Open name. 
X0012[08]: Text. Text scrap[Grey]="sloth"
X0012[13]: @> Close name. 
X0012[15]: @} Close defn. 
X0012[17]: Text. Text scrap[White]="<010>
X"
X0013[01]: @A New section (Level 1). 
X0013[03]: @< Open name. 
X0013[05]: Text. Text scrap[Grey]="Error Recovery Point"
X0013[25]: @> Close name. 
X0013[27]: Text. Text scrap[White]="<010>
X   "
X0014[04]: @{ Open defn. 
X0014[06]: Text. Text scrap[White]="     "
X0014[11]: @> Close name. 
X0014[13]: Text. Text scrap[White]="   "
X0014[16]: @} Close defn. 
X0014[18]: Text. Text scrap[White]="<010>
X"
X0015[01]: @A New section (Level 1). 
X0015[03]: @< Open name. 
X0015[05]: Text. Text scrap[Grey]="Error Recovery Point"
X0015[25]: @> Close name. 
X0015[27]: Text. Text scrap[Grey]="<010>
X<010>
X5. Test the legal use of the "
X0017[30]: @/ Emphasise. 
X0017[32]: Text. Text scrap[Grey]="emphasis"
X0017[40]: @/ Emphasise. 
X0017[42]: Text. Text scrap[Grey]=" construct.<010>
X<010>
X6.Test "
X0019[08]: @/ Emphasise. 
X0019[10]: @/ Emphasise. 
X0019[12]: Text. Text scrap[Grey]=" (illegal).<010>
X"
X0020[01]: @A New section (Level 1). 
X0020[03]: @< Open name. 
X0020[05]: Text. Text scrap[Grey]="Error Recovery Point"
X0020[25]: @> Close name. 
X0020[27]: Text. Text scrap[Grey]="<010>
X<010>
X7. Test the construct "
X0022[23]: @/ Emphasise. 
X0022[25]: Text. Text scrap[Grey]="across<010>
X   more than one line"
X0023[22]: @/ Emphasise. 
X0023[24]: Text. Text scrap[Grey]=".<010>
X<010>
X8. Now we test the construct with non-text following it.<010>
X   "
X0026[04]: @/ Emphasise. 
X0026[06]: @< Open name. 
X0026[08]: Text. Text scrap[Grey]="sloth"
X0026[13]: @> Close name. 
X0026[15]: @/ Emphasise. 
X0026[17]: Text. Text scrap[White]="<010>
X"
X0027[01]: @A New section (Level 1). 
X0027[03]: @< Open name. 
X0027[05]: Text. Text scrap[Grey]="Error Recovery Point"
X0027[25]: @> Close name. 
X0027[27]: Text. Text scrap[White]="<010>
X   "
X0028[04]: @/ Emphasise. 
X0028[06]: Text. Text scrap[White]="     "
X0028[11]: @< Open name. 
X0028[13]: Text. Text scrap[White]="   "
X0028[16]: @/ Emphasise. 
X0028[18]: Text. Text scrap[White]="<010>
X<010>
X<010>
X<010>
X"
X0032[01]: End Of File. 
X============================ End of TOKEN LIST DUMP ============================
X
X
X========================== Start of MACRO TABLE DUMP ===========================
X
X
X=========================== End of MACRO TABLE DUMP ============================
X
X
X========================= Start of DOCUMENT LIST DUMP ==========================
X
X
TEXT COMPONENT: Pos(L,C)=(1,1). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="PR01: Test the inline typesetting features.<010>
X<010>
X1. First we test the legal use of the "
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT:    Open  literal.
X
TEXT COMPONENT: Pos(L,C)=(3,41). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="literal"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT:    Close literal.
X
TEXT COMPONENT: Pos(L,C)=(3,50). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]=" construct.<010>
X<010>
X2.Test "
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT:    Open  literal.
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "1", Section name="Error Recovery Point".
X
TEXT COMPONENT: Pos(L,C)=(6,27). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="<010>
X<010>
X3. Test the construct "
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT:    Open  literal.
X
TEXT COMPONENT: Pos(L,C)=(8,25). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="across<010>
X   more than one line"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT:    Close literal.
X
TEXT COMPONENT: Pos(L,C)=(9,24). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]=".<010>
X<010>
X4. Now we test the construct with non-text following it.<010>
X   "
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT:    Open  literal.
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "2", Section name="Error Recovery Point".
X
TEXT COMPONENT: Pos(L,C)=(13,27). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X   "
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT:    Open  literal.
X
TEXT COMPONENT: Pos(L,C)=(14,6). 
X
X-- Start of Text Scrap List --
Text scrap[White]="     "
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "3", Section name="Error Recovery Point".
X
TEXT COMPONENT: Pos(L,C)=(15,27). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="<010>
X<010>
X5. Test the legal use of the "
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT:    Open emphasise.
X
TEXT COMPONENT: Pos(L,C)=(17,32). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="emphasis"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT:    Close emphasise.
X
TEXT COMPONENT: Pos(L,C)=(17,42). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]=" construct.<010>
X<010>
X6.Test "
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT:    Open emphasise.
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "4", Section name="Error Recovery Point".
X
TEXT COMPONENT: Pos(L,C)=(20,27). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="<010>
X<010>
X7. Test the construct "
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT:    Open emphasise.
X
TEXT COMPONENT: Pos(L,C)=(22,25). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="across<010>
X   more than one line"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT:    Close emphasise.
X
TEXT COMPONENT: Pos(L,C)=(23,24). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]=".<010>
X<010>
X8. Now we test the construct with non-text following it.<010>
X   "
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT:    Open emphasise.
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "5", Section name="Error Recovery Point".
X
TEXT COMPONENT: Pos(L,C)=(27,27). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X   "
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT:    Open emphasise.
X
TEXT COMPONENT: Pos(L,C)=(28,6). 
X
X-- Start of Text Scrap List --
Text scrap[White]="     "
X--- End of Text Scrap List ---
X
X
X========================== End of DOCUMENT LIST DUMP ===========================
X
X
Global Local| Input File
X------------+-------------------------------------------------------------------
X     1     1| PR01: Test the inline typesetting features.
X     2     2| 
X     3     3| 1. First we test the legal use of the @{literal@} construct.
X     4     4| 
X     5     5| 2.Test @{@} (illegal).
X       Error|..........^Text expected after open literal token "@{".
X            |..........^Sorry, empty literal strings are not allowed.
X            |..........^Skipping after error to the next major construct...
X     6     6| @A@<Error Recovery Point@>
X            |.^...skipped to here after the error.
X     7     7| 
X     8     8| 3. Test the construct @{across
X     9     9|    more than one line@}.
X    10    10| 
X    11    11| 4. Now we test the construct with non-text following it.
X    12    12|    @{@<sloth@>@}
X       Error|......^Text expected after open literal token "@{".
X            |......^Skipping after error to the next major construct...
X    13    13| @A@<Error Recovery Point@>
X            |.^...skipped to here after the error.
X    14    14|    @{     @>   @}
X       Error|...........^Expecting '@}'.
X            |...........^Skipping after error to the next major construct...
X    15    15| @A@<Error Recovery Point@>
X            |.^...skipped to here after the error.
X    16    16| 
X    17    17| 5. Test the legal use of the @/emphasis@/ construct.
X    18    18| 
X    19    19| 6.Test @/@/ (illegal).
X       Error|..........^Text expected after open emphasise token "@/".
X            |..........^Sorry, empty emphasised strings are not allowed.
X            |..........^Skipping after error to the next major construct...
X    20    20| @A@<Error Recovery Point@>
X            |.^...skipped to here after the error.
X    21    21| 
X    22    22| 7. Test the construct @/across
X    23    23|    more than one line@/.
X    24    24| 
X    25    25| 8. Now we test the construct with non-text following it.
X    26    26|    @/@<sloth@>@/
X       Error|......^Text expected after open emphasise token "@/".
X            |......^Skipping after error to the next major construct...
X    27    27| @A@<Error Recovery Point@>
X            |.^...skipped to here after the error.
X    28    28|    @/     @<   @/
X       Error|...........^Expecting '@/'.
X            |...........^Skipping after error to the next major construct...
X    29    29| 
X    30    30| 
X    31    31| 
X            | <End-Of-File>
X            |.^...skipped to here after the error.
X------------+-------------------------------------------------------------------
X
There were 6 Errors.
END_OF_FILE
if test 14686 -ne `wc -c <'answers/pr01.lis'`; then
    echo shar: \"'answers/pr01.lis'\" unpacked with wrong size!
fi
# end of 'answers/pr01.lis'
fi
if test -f 'answers/pr03.lis' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'answers/pr03.lis'\"
else
echo shar: Extracting \"'answers/pr03.lis'\" \(14101 characters\)
sed "s/^X//" >'answers/pr03.lis' <<'END_OF_FILE'
XFUNNELWEB LISTING FILE
X======================
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 50 52 30 33 3A 20 54 65 73 74 20 74 68 65 20 70 | PR03: Test the p |
X| 61 72 73 69 6E 67 20 61 6E 64 20 73 65 6D 61 6E | arsing and seman |
X| 74 69 63 73 20 6F 66 20 73 65 63 74 69 6F 6E 73 | tics of sections |
X| 2E 0A 0A 34 2E 20 54 65 73 74 20 66 69 72 73 74 | ...4. Test first |
X| 20 73 65 63 74 69 6F 6E 20 6F 66 20 64 6F 63 75 |  section of docu |
X| 6D 65 6E 74 20 69 73 20 6E 6F 74 20 3C 73 70 65 | ment is not <spe |
X| 63 69 61 6C 3E 41 2E 0A 40 42 40 3C 54 68 69 73 | cial>A..@B@<This |
X| 20 73 65 63 74 69 6F 6E 20 69 73 20 6F 75 74 20 |  section is out  |
X| 6F 66 20 6F 72 64 65 72 20 28 61 6E 64 20 73 6F | of order (and so |
X| 20 69 73 20 74 68 69 73 20 74 65 73 74 21 29 40 |  is this test!)@ |
X| 3E 0A 0A 31 2E 20 54 65 73 74 20 73 65 63 74 69 | >..1. Test secti |
X| 6F 6E 20 77 69 74 68 20 6E 6F 20 6E 61 6D 65 2E | on with no name. |
X| 0A 40 41 20 54 68 69 73 20 73 65 63 74 69 6F 6E | .@A This section |
X| 20 68 61 73 20 6E 6F 20 6E 61 6D 65 2E 0A 40 24 |  has no name..@$ |
X| 40 3C 54 68 65 20 73 65 63 74 69 6F 6E 20 6E 61 | @<The section na |
X| 6D 65 20 69 6E 68 65 72 69 74 73 20 74 68 65 20 | me inherits the  |
X| 6E 61 6D 65 20 6F 66 20 74 68 69 73 20 6D 61 63 | name of this mac |
X| 72 6F 40 3E 40 7B 57 61 6C 72 75 73 40 7D 0A 0A | ro@>@{Walrus@}.. |
X| 32 2E 20 54 65 73 74 20 73 65 63 74 69 6F 6E 20 | 2. Test section  |
X| 77 69 74 68 20 61 20 6E 61 6D 65 0A 40 41 40 3C | with a name.@A@< |
X| 54 68 69 73 20 73 65 63 74 69 6F 6E 20 68 61 73 | This section has |
X| 20 6E 6F 20 6E 61 6D 65 2E 40 3E 0A 0A 33 2E 20 |  no name.@>..3.  |
X| 54 65 73 74 20 74 68 65 20 65 6E 74 69 72 65 20 | Test the entire  |
X| 68 69 65 72 61 72 63 68 79 2E 0A 40 41 40 3C 4F | hierarchy..@A@<O |
X| 6E 65 40 3E 0A 40 42 40 3C 54 77 6F 40 3E 0A 40 | ne@>.@B@<Two@>.@ |
X| 43 40 3C 54 68 72 65 65 40 3E 0A 40 44 40 3C 46 | C@<Three@>.@D@<F |
X| 6F 75 72 40 3E 0A 40 45 40 3C 46 69 76 65 40 3E | our@>.@E@<Five@> |
X| 0A 0A 35 2E 20 54 65 73 74 20 64 65 74 65 63 74 | ..5. Test detect |
X| 69 6F 6E 20 6F 66 20 64 69 73 63 6F 6E 74 69 6E | ion of discontin |
X| 75 69 74 79 20 69 6E 20 6C 65 76 65 6C 73 2E 0A | uity in levels.. |
X| 40 41 40 3C 4F 6E 65 40 3E 0A 40 43 40 3C 54 68 | @A@<One@>.@C@<Th |
X| 72 65 65 40 3E 0A 40 45 40 3C 46 69 76 65 40 3E | ree@>.@E@<Five@> |
X| 0A 0A 40 41 40 3C 4F 6E 65 40 3E 0A 40 42 40 3C | ..@A@<One@>.@B@< |
X| 54 68 72 65 65 40 3E 0A 40 44 40 3C 46 69 76 65 | Three@>.@D@<Five |
X| 40 3E 0A                                        | @>.              |
X+-------------------------------------------------+------------------+
X
X
X=========================== Start of LINE LIST DUMP ============================
X
Globl Local| Text
X-----------+--------------------------------------------------------------------
X00001 00001| PR03: Test the parsing and semantics of sections.<010>
X00002 00002| <010>
X00003 00003| 4. Test first section of document is not <special>A.<010>
X00004 00004| @B@<This section is out of order (and so is this test!)@><010>
X00005 00005| <010>
X00006 00006| 1. Test section with no name.<010>
X00007 00007| @A This section has no name.<010>
X00008 00008| @$@<The section name inherits the name of this macro@>@{Walrus@}<010>
X00009 00009| <010>
X00010 00010| 2. Test section with a name<010>
X00011 00011| @A@<This section has no name.@><010>
X00012 00012| <010>
X00013 00013| 3. Test the entire hierarchy.<010>
X00014 00014| @A@<One@><010>
X00015 00015| @B@<Two@><010>
X00016 00016| @C@<Three@><010>
X00017 00017| @D@<Four@><010>
X00018 00018| @E@<Five@><010>
X00019 00019| <010>
X00020 00020| 5. Test detection of discontinuity in levels.<010>
X00021 00021| @A@<One@><010>
X00022 00022| @C@<Three@><010>
X00023 00023| @E@<Five@><010>
X00024 00024| <010>
X00025 00025| @A@<One@><010>
X00026 00026| @B@<Three@><010>
X00027 00027| @D@<Five@><010>
X00028 00028| <End-Of-File><010>
X-----------+--------------------------------------------------------------------
Globl Local| Text
X
X============================ End of LINE LIST DUMP =============================
X
X
X=========================== Start of TOKEN LIST DUMP ===========================
X
Summary: There are 77 tokens in the token list.
X
Line[Column]: Token Description
X-------------------------------
X
X0001[01]: Text. Text scrap[Grey]="PR03: Test the parsing and semantics of sections.<010>
X<010>
X4. Test first section of document is not <special>A.<010>
X"
X0004[01]: @B New section (Level 2). 
X0004[03]: @< Open name. 
X0004[05]: Text. Text scrap[Grey]="This section is out of order (and so is this test!)"
X0004[56]: @> Close name. 
X0004[58]: Text. Text scrap[Grey]="<010>
X<010>
X1. Test section with no name.<010>
X"
X0007[01]: @A New section (Level 1). 
X0007[03]: Text. Text scrap[Grey]=" This section has no name.<010>
X"
X0008[01]: @$ Macro defn. 
X0008[03]: @< Open name. 
X0008[05]: Text. Text scrap[Grey]="The section name inherits the name of this macro"
X0008[53]: @> Close name. 
X0008[55]: @{ Open defn. 
X0008[57]: Text. Text scrap[Grey]="Walrus"
X0008[63]: @} Close defn. 
X0008[65]: Text. Text scrap[Grey]="<010>
X<010>
X2. Test section with a name<010>
X"
X0011[01]: @A New section (Level 1). 
X0011[03]: @< Open name. 
X0011[05]: Text. Text scrap[Grey]="This section has no name."
X0011[30]: @> Close name. 
X0011[32]: Text. Text scrap[Grey]="<010>
X<010>
X3. Test the entire hierarchy.<010>
X"
X0014[01]: @A New section (Level 1). 
X0014[03]: @< Open name. 
X0014[05]: Text. Text scrap[Grey]="One"
X0014[08]: @> Close name. 
X0014[10]: Text. Text scrap[White]="<010>
X"
X0015[01]: @B New section (Level 2). 
X0015[03]: @< Open name. 
X0015[05]: Text. Text scrap[Grey]="Two"
X0015[08]: @> Close name. 
X0015[10]: Text. Text scrap[White]="<010>
X"
X0016[01]: @C New section (Level 3). 
X0016[03]: @< Open name. 
X0016[05]: Text. Text scrap[Grey]="Three"
X0016[10]: @> Close name. 
X0016[12]: Text. Text scrap[White]="<010>
X"
X0017[01]: @D New section (Level 4). 
X0017[03]: @< Open name. 
X0017[05]: Text. Text scrap[Grey]="Four"
X0017[09]: @> Close name. 
X0017[11]: Text. Text scrap[White]="<010>
X"
X0018[01]: @E New section (Level 5). 
X0018[03]: @< Open name. 
X0018[05]: Text. Text scrap[Grey]="Five"
X0018[09]: @> Close name. 
X0018[11]: Text. Text scrap[Grey]="<010>
X<010>
X5. Test detection of discontinuity in levels.<010>
X"
X0021[01]: @A New section (Level 1). 
X0021[03]: @< Open name. 
X0021[05]: Text. Text scrap[Grey]="One"
X0021[08]: @> Close name. 
X0021[10]: Text. Text scrap[White]="<010>
X"
X0022[01]: @C New section (Level 3). 
X0022[03]: @< Open name. 
X0022[05]: Text. Text scrap[Grey]="Three"
X0022[10]: @> Close name. 
X0022[12]: Text. Text scrap[White]="<010>
X"
X0023[01]: @E New section (Level 5). 
X0023[03]: @< Open name. 
X0023[05]: Text. Text scrap[Grey]="Five"
X0023[09]: @> Close name. 
X0023[11]: Text. Text scrap[White]="<010>
X<010>
X"
X0025[01]: @A New section (Level 1). 
X0025[03]: @< Open name. 
X0025[05]: Text. Text scrap[Grey]="One"
X0025[08]: @> Close name. 
X0025[10]: Text. Text scrap[White]="<010>
X"
X0026[01]: @B New section (Level 2). 
X0026[03]: @< Open name. 
X0026[05]: Text. Text scrap[Grey]="Three"
X0026[10]: @> Close name. 
X0026[12]: Text. Text scrap[White]="<010>
X"
X0027[01]: @D New section (Level 4). 
X0027[03]: @< Open name. 
X0027[05]: Text. Text scrap[Grey]="Five"
X0027[09]: @> Close name. 
X0027[11]: Text. Text scrap[White]="<010>
X"
X0028[01]: End Of File. 
X============================ End of TOKEN LIST DUMP ============================
X
X
X========================== Start of MACRO TABLE DUMP ===========================
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "The section name inherits the name of this macro"
Defined?    : Yes.
Parameters  : 0
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 1 body part.
Body part 1: Seqnum=1, Pos(L,C)=(8,3), Expression follows:
X
X---- Start of Expression ----
X
X----- Start Text Element -----
Text scrap[Grey]="Walrus"
X------ End Text Element ------
X
X----- End of Expression -----
X
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X=========================== End of MACRO TABLE DUMP ============================
X
X
X========================= Start of DOCUMENT LIST DUMP ==========================
X
X
TEXT COMPONENT: Pos(L,C)=(1,1). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="PR03: Test the parsing and semantics of sections.<010>
X<010>
X4. Test first section of document is not <special>A.<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "1.2", Section name="This section is out of order (and so is this test!)".
X
TEXT COMPONENT: Pos(L,C)=(4,58). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="<010>
X<010>
X1. Test section with no name.<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "2", Section name="The section name inherits the name of this macro".
X
TEXT COMPONENT: Pos(L,C)=(7,3). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]=" This section has no name.<010>
X"
X--- End of Text Scrap List ---
X
X
MACRO DEFINITION COMPONENT: Pos(L,C)=(8,1). 
Part 1 of macro @<The section name inherits the name of this macro@>.
X
TEXT COMPONENT: Pos(L,C)=(8,65). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="<010>
X<010>
X2. Test section with a name<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "3", Section name="This section has no name.".
X
TEXT COMPONENT: Pos(L,C)=(11,32). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="<010>
X<010>
X3. Test the entire hierarchy.<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "4", Section name="One".
X
TEXT COMPONENT: Pos(L,C)=(14,10). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "4.1", Section name="Two".
X
TEXT COMPONENT: Pos(L,C)=(15,10). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "4.1.1", Section name="Three".
X
TEXT COMPONENT: Pos(L,C)=(16,12). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "4.1.1.1", Section name="Four".
X
TEXT COMPONENT: Pos(L,C)=(17,11). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "4.1.1.1.1", Section name="Five".
X
TEXT COMPONENT: Pos(L,C)=(18,11). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="<010>
X<010>
X5. Test detection of discontinuity in levels.<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "5", Section name="One".
X
TEXT COMPONENT: Pos(L,C)=(21,10). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "1.1.2", Section name="Three".
X
TEXT COMPONENT: Pos(L,C)=(22,12). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "1.1.1.1.2", Section name="Five".
X
TEXT COMPONENT: Pos(L,C)=(23,11). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "2", Section name="One".
X
TEXT COMPONENT: Pos(L,C)=(25,10). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "2.1", Section name="Three".
X
TEXT COMPONENT: Pos(L,C)=(26,12). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "1.1.1.2", Section name="Five".
X
TEXT COMPONENT: Pos(L,C)=(27,11). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
X========================== End of DOCUMENT LIST DUMP ===========================
X
X
Global Local| Input File
X------------+-------------------------------------------------------------------
X     1     1| PR03: Test the parsing and semantics of sections.
X     2     2| 
X     3     3| 4. Test first section of document is not <special>A.
X     4     4| @B@<This section is out of order (and so is this test!)@>
X       Error|.^The first section in a document must be an @A section.
X     5     5| 
X     6     6| 1. Test section with no name.
X     7     7| @A This section has no name.
X     8     8| @$@<The section name inherits the name of this macro@>@{Walrus@}
X     9     9| 
X    10    10| 2. Test section with a name
X    11    11| @A@<This section has no name.@>
X    12    12| 
X    13    13| 3. Test the entire hierarchy.
X    14    14| @A@<One@>
X    15    15| @B@<Two@>
X    16    16| @C@<Three@>
X    17    17| @D@<Four@>
X    18    18| @E@<Five@>
X    19    19| 
X    20    20| 5. Test detection of discontinuity in levels.
X    21    21| @A@<One@>
X            |.^The next section (at line 22) is too deep.
X    22    22| @C@<Three@>
X       Error|.^This section is more than one level deeper than the last
X            |.^section (at line 21). Example: @B followed by @D is not allowed.
X            |.^The next section (at line 23) is too deep.
X    23    23| @E@<Five@>
X       Error|.^This section is more than one level deeper than the last
X            |.^section (at line 22). Example: @B followed by @D is not allowed.
X    24    24| 
X    25    25| @A@<One@>
X    26    26| @B@<Three@>
X            |.^The next section (at line 27) is too deep.
X    27    27| @D@<Five@>
X       Error|.^This section is more than one level deeper than the last
X            |.^section (at line 26). Example: @B followed by @D is not allowed.
X            | <End-Of-File>
X------------+-------------------------------------------------------------------
X
There were 4 Errors.
END_OF_FILE
if test 14101 -ne `wc -c <'answers/pr03.lis'`; then
    echo shar: \"'answers/pr03.lis'\" unpacked with wrong size!
fi
# end of 'answers/pr03.lis'
fi
if test -f 'answers/sc17.lis' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'answers/sc17.lis'\"
else
echo shar: Extracting \"'answers/sc17.lis'\" \(14128 characters\)
sed "s/^X//" >'answers/sc17.lis' <<'END_OF_FILE'
XFUNNELWEB LISTING FILE
X======================
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 31 37 3A 20 54 65 73 74 20 3C 73 70 65 63 | SC17: Test <spec |
X| 69 61 6C 3E 23 2E 0A 0A 46 69 72 73 74 20 77 65 | ial>#...First we |
X| 20 74 72 69 70 20 75 70 20 74 68 65 20 73 63 61 |  trip up the sca |
X| 6E 6E 65 72 20 73 6F 20 6E 6F 20 66 75 72 74 68 | nner so no furth |
X| 65 72 20 70 61 73 73 65 73 20 74 61 6B 65 20 70 | er passes take p |
X| 6C 61 63 65 2E 0A 0A 40 0A 0A 31 2E 20 54 65 73 | lace...@..1. Tes |
X| 74 20 77 69 74 68 20 61 6C 6C 20 70 6F 73 73 69 | t with all possi |
X| 62 6C 65 20 70 72 69 6E 74 61 62 6C 65 20 63 68 | ble printable ch |
X| 61 72 61 63 74 65 72 73 2E 0A 0A 40 23 21 20 40 | aracters...@#! @ |
X| 23 22 20 40 23 23 20 40 23 24 20 40 23 25 20 40 | #" @## @#$ @#% @ |
X| 23 26 20 40 23 27 20 40 23 28 20 40 23 29 20 40 | #& @#' @#( @#) @ |
X| 23 2A 20 40 23 2B 20 40 23 2C 20 40 23 2D 20 40 | #* @#+ @#, @#- @ |
X| 23 2E 20 40 23 2F 0A 40 23 30 20 40 23 31 20 40 | #. @#/.@#0 @#1 @ |
X| 23 32 20 40 23 33 20 40 23 34 20 40 23 35 20 40 | #2 @#3 @#4 @#5 @ |
X| 23 36 20 40 23 37 20 40 23 38 20 40 23 39 20 40 | #6 @#7 @#8 @#9 @ |
X| 23 3A 20 40 23 3B 20 40 23 3C 20 40 23 3D 20 40 | #: @#; @#< @#= @ |
X| 23 3E 0A 40 23 3F 20 40 23 40 20 40 23 41 20 40 | #>.@#? @#@ @#A @ |
X| 23 42 20 40 23 43 20 40 23 44 20 40 23 45 20 40 | #B @#C @#D @#E @ |
X| 23 46 20 40 23 47 20 40 23 48 20 40 23 49 20 40 | #F @#G @#H @#I @ |
X| 23 4A 20 40 23 4B 20 40 23 4C 20 40 23 4D 0A 40 | #J @#K @#L @#M.@ |
X| 23 4E 20 40 23 4F 20 40 23 50 20 40 23 51 20 40 | #N @#O @#P @#Q @ |
X| 23 52 20 40 23 53 20 40 23 54 20 40 23 55 20 40 | #R @#S @#T @#U @ |
X| 23 56 20 40 23 57 20 40 23 58 20 40 23 59 20 40 | #V @#W @#X @#Y @ |
X| 23 5A 20 40 23 5B 20 40 23 5C 0A 40 23 5D 20 40 | #Z @#[ @#\.@#] @ |
X| 23 5E 20 40 23 5F 20 40 23 60 20 40 23 61 20 40 | #^ @#_ @#` @#a @ |
X| 23 62 20 40 23 63 20 40 23 64 20 40 23 65 20 40 | #b @#c @#d @#e @ |
X| 23 66 20 40 23 67 20 40 23 68 20 40 23 69 20 40 | #f @#g @#h @#i @ |
X| 23 6A 20 40 23 6B 0A 40 23 6C 20 40 23 6D 20 40 | #j @#k.@#l @#m @ |
X| 23 6E 20 40 23 6F 20 40 23 70 20 40 23 71 20 40 | #n @#o @#p @#q @ |
X| 23 72 20 40 23 73 20 40 23 74 20 40 23 75 20 40 | #r @#s @#t @#u @ |
X| 23 76 20 40 23 77 20 40 23 78 20 40 23 79 20 40 | #v @#w @#x @#y @ |
X| 23 7A 0A 40 23 7B 20 40 23 7C 20 40 23 7D 20 40 | #z.@#{ @#| @#} @ |
X| 23 7E 0A 0A 32 2E 20 54 65 73 74 20 74 68 61 74 | #~..2. Test that |
X| 20 3C 73 70 65 63 69 61 6C 3E 23 3C 73 70 61 63 |  <special>#<spac |
X| 65 3E 20 69 73 20 66 6C 61 67 67 65 64 20 61 73 | e> is flagged as |
X| 20 61 6E 20 65 72 72 6F 72 2E 0A 0A 20 20 20 40 |  an error...   @ |
X| 23 20 20 20 20 20 40 21 20 53 68 6F 75 6C 64 20 | #     @! Should  |
X| 62 65 20 66 6C 61 67 67 65 64 20 61 73 20 61 6E | be flagged as an |
X| 20 65 72 72 6F 72 2E 0A 0A 33 2E 20 54 65 73 74 |  error...3. Test |
X| 20 74 68 61 74 20 3C 73 70 65 63 69 61 6C 3E 23 |  that <special># |
X| 45 4F 4C 20 69 73 20 66 6C 61 67 67 65 64 20 61 | EOL is flagged a |
X| 73 20 61 6E 20 65 72 72 6F 72 2E 0A 0A 20 20 20 | s an error...    |
X| 40 23 0A 0A                                     | @#..             |
X+-------------------------------------------------+------------------+
X
X
X=========================== Start of LINE LIST DUMP ============================
X
Globl Local| Text
X-----------+--------------------------------------------------------------------
X00001 00001| SC17: Test <special>#.<010>
X00002 00002| <010>
X00003 00003| First we trip up the scanner so no further passes take place.<010>
X00004 00004| <010>
X00005 00005| @<010>
X00006 00006| <010>
X00007 00007| 1. Test with all possible printable characters.<010>
X00008 00008| <010>
X00009 00009| @#! @#" @## @#$ @#% @#& @#' @#( @#) @#* @#+ @#, @#- @#. @#/<010>
X00010 00010| @#0 @#1 @#2 @#3 @#4 @#5 @#6 @#7 @#8 @#9 @#: @#; @#< @#= @#><010>
X00011 00011| @#? @#@ @#A @#B @#C @#D @#E @#F @#G @#H @#I @#J @#K @#L @#M<010>
X00012 00012| @#N @#O @#P @#Q @#R @#S @#T @#U @#V @#W @#X @#Y @#Z @#[ @#\<010>
X00013 00013| @#] @#^ @#_ @#` @#a @#b @#c @#d @#e @#f @#g @#h @#i @#j @#k<010>
X00014 00014| @#l @#m @#n @#o @#p @#q @#r @#s @#t @#u @#v @#w @#x @#y @#z<010>
X00015 00015| @#{ @#| @#} @#~<010>
X00016 00016| <010>
X00017 00017| 2. Test that <special>#<space> is flagged as an error.<010>
X00018 00018| <010>
X00019 00019|    @#     @! Should be flagged as an error.<010>
X00020 00020| <010>
X00021 00021| 3. Test that <special>#EOL is flagged as an error.<010>
X00022 00022| <010>
X00023 00023|    @#<010>
X00024 00024| <010>
X00025 00025| <End-Of-File><010>
X-----------+--------------------------------------------------------------------
Globl Local| Text
X
X============================ End of LINE LIST DUMP =============================
X
X
X=========================== Start of TOKEN LIST DUMP ===========================
X
Summary: There are 194 tokens in the token list.
X
Line[Column]: Token Description
X-------------------------------
X
X0001[01]: Text. Text scrap[Grey]="SC17: Test <special>#.<010>
X<010>
XFirst we trip up the scanner so no further passes take place.<010>
X<010>
X"
X0006[01]: Text. Text scrap[Grey]="<010>
X1. Test with all possible printable characters.<010>
X<010>
X"
X0009[01]: @# Name. Character='!'.
X0009[04]: Text. Text scrap[White]=" "
X0009[05]: @# Name. Character='"'.
X0009[08]: Text. Text scrap[White]=" "
X0009[09]: @# Name. Character='#'.
X0009[12]: Text. Text scrap[White]=" "
X0009[13]: @# Name. Character='$'.
X0009[16]: Text. Text scrap[White]=" "
X0009[17]: @# Name. Character='%'.
X0009[20]: Text. Text scrap[White]=" "
X0009[21]: @# Name. Character='&'.
X0009[24]: Text. Text scrap[White]=" "
X0009[25]: @# Name. Character='''.
X0009[28]: Text. Text scrap[White]=" "
X0009[29]: @# Name. Character='('.
X0009[32]: Text. Text scrap[White]=" "
X0009[33]: @# Name. Character=')'.
X0009[36]: Text. Text scrap[White]=" "
X0009[37]: @# Name. Character='*'.
X0009[40]: Text. Text scrap[White]=" "
X0009[41]: @# Name. Character='+'.
X0009[44]: Text. Text scrap[White]=" "
X0009[45]: @# Name. Character=','.
X0009[48]: Text. Text scrap[White]=" "
X0009[49]: @# Name. Character='-'.
X0009[52]: Text. Text scrap[White]=" "
X0009[53]: @# Name. Character='.'.
X0009[56]: Text. Text scrap[White]=" "
X0009[57]: @# Name. Character='/'.
X0009[60]: Text. Text scrap[White]="<010>
X"
X0010[01]: @# Name. Character='0'.
X0010[04]: Text. Text scrap[White]=" "
X0010[05]: @# Name. Character='1'.
X0010[08]: Text. Text scrap[White]=" "
X0010[09]: @# Name. Character='2'.
X0010[12]: Text. Text scrap[White]=" "
X0010[13]: @# Name. Character='3'.
X0010[16]: Text. Text scrap[White]=" "
X0010[17]: @# Name. Character='4'.
X0010[20]: Text. Text scrap[White]=" "
X0010[21]: @# Name. Character='5'.
X0010[24]: Text. Text scrap[White]=" "
X0010[25]: @# Name. Character='6'.
X0010[28]: Text. Text scrap[White]=" "
X0010[29]: @# Name. Character='7'.
X0010[32]: Text. Text scrap[White]=" "
X0010[33]: @# Name. Character='8'.
X0010[36]: Text. Text scrap[White]=" "
X0010[37]: @# Name. Character='9'.
X0010[40]: Text. Text scrap[White]=" "
X0010[41]: @# Name. Character=':'.
X0010[44]: Text. Text scrap[White]=" "
X0010[45]: @# Name. Character=';'.
X0010[48]: Text. Text scrap[White]=" "
X0010[49]: @# Name. Character='<'.
X0010[52]: Text. Text scrap[White]=" "
X0010[53]: @# Name. Character='='.
X0010[56]: Text. Text scrap[White]=" "
X0010[57]: @# Name. Character='>'.
X0010[60]: Text. Text scrap[White]="<010>
X"
X0011[01]: @# Name. Character='?'.
X0011[04]: Text. Text scrap[White]=" "
X0011[05]: @# Name. Character='@'.
X0011[08]: Text. Text scrap[White]=" "
X0011[09]: @# Name. Character='A'.
X0011[12]: Text. Text scrap[White]=" "
X0011[13]: @# Name. Character='B'.
X0011[16]: Text. Text scrap[White]=" "
X0011[17]: @# Name. Character='C'.
X0011[20]: Text. Text scrap[White]=" "
X0011[21]: @# Name. Character='D'.
X0011[24]: Text. Text scrap[White]=" "
X0011[25]: @# Name. Character='E'.
X0011[28]: Text. Text scrap[White]=" "
X0011[29]: @# Name. Character='F'.
X0011[32]: Text. Text scrap[White]=" "
X0011[33]: @# Name. Character='G'.
X0011[36]: Text. Text scrap[White]=" "
X0011[37]: @# Name. Character='H'.
X0011[40]: Text. Text scrap[White]=" "
X0011[41]: @# Name. Character='I'.
X0011[44]: Text. Text scrap[White]=" "
X0011[45]: @# Name. Character='J'.
X0011[48]: Text. Text scrap[White]=" "
X0011[49]: @# Name. Character='K'.
X0011[52]: Text. Text scrap[White]=" "
X0011[53]: @# Name. Character='L'.
X0011[56]: Text. Text scrap[White]=" "
X0011[57]: @# Name. Character='M'.
X0011[60]: Text. Text scrap[White]="<010>
X"
X0012[01]: @# Name. Character='N'.
X0012[04]: Text. Text scrap[White]=" "
X0012[05]: @# Name. Character='O'.
X0012[08]: Text. Text scrap[White]=" "
X0012[09]: @# Name. Character='P'.
X0012[12]: Text. Text scrap[White]=" "
X0012[13]: @# Name. Character='Q'.
X0012[16]: Text. Text scrap[White]=" "
X0012[17]: @# Name. Character='R'.
X0012[20]: Text. Text scrap[White]=" "
X0012[21]: @# Name. Character='S'.
X0012[24]: Text. Text scrap[White]=" "
X0012[25]: @# Name. Character='T'.
X0012[28]: Text. Text scrap[White]=" "
X0012[29]: @# Name. Character='U'.
X0012[32]: Text. Text scrap[White]=" "
X0012[33]: @# Name. Character='V'.
X0012[36]: Text. Text scrap[White]=" "
X0012[37]: @# Name. Character='W'.
X0012[40]: Text. Text scrap[White]=" "
X0012[41]: @# Name. Character='X'.
X0012[44]: Text. Text scrap[White]=" "
X0012[45]: @# Name. Character='Y'.
X0012[48]: Text. Text scrap[White]=" "
X0012[49]: @# Name. Character='Z'.
X0012[52]: Text. Text scrap[White]=" "
X0012[53]: @# Name. Character='['.
X0012[56]: Text. Text scrap[White]=" "
X0012[57]: @# Name. Character='\'.
X0012[60]: Text. Text scrap[White]="<010>
X"
X0013[01]: @# Name. Character=']'.
X0013[04]: Text. Text scrap[White]=" "
X0013[05]: @# Name. Character='^'.
X0013[08]: Text. Text scrap[White]=" "
X0013[09]: @# Name. Character='_'.
X0013[12]: Text. Text scrap[White]=" "
X0013[13]: @# Name. Character='`'.
X0013[16]: Text. Text scrap[White]=" "
X0013[17]: @# Name. Character='a'.
X0013[20]: Text. Text scrap[White]=" "
X0013[21]: @# Name. Character='b'.
X0013[24]: Text. Text scrap[White]=" "
X0013[25]: @# Name. Character='c'.
X0013[28]: Text. Text scrap[White]=" "
X0013[29]: @# Name. Character='d'.
X0013[32]: Text. Text scrap[White]=" "
X0013[33]: @# Name. Character='e'.
X0013[36]: Text. Text scrap[White]=" "
X0013[37]: @# Name. Character='f'.
X0013[40]: Text. Text scrap[White]=" "
X0013[41]: @# Name. Character='g'.
X0013[44]: Text. Text scrap[White]=" "
X0013[45]: @# Name. Character='h'.
X0013[48]: Text. Text scrap[White]=" "
X0013[49]: @# Name. Character='i'.
X0013[52]: Text. Text scrap[White]=" "
X0013[53]: @# Name. Character='j'.
X0013[56]: Text. Text scrap[White]=" "
X0013[57]: @# Name. Character='k'.
X0013[60]: Text. Text scrap[White]="<010>
X"
X0014[01]: @# Name. Character='l'.
X0014[04]: Text. Text scrap[White]=" "
X0014[05]: @# Name. Character='m'.
X0014[08]: Text. Text scrap[White]=" "
X0014[09]: @# Name. Character='n'.
X0014[12]: Text. Text scrap[White]=" "
X0014[13]: @# Name. Character='o'.
X0014[16]: Text. Text scrap[White]=" "
X0014[17]: @# Name. Character='p'.
X0014[20]: Text. Text scrap[White]=" "
X0014[21]: @# Name. Character='q'.
X0014[24]: Text. Text scrap[White]=" "
X0014[25]: @# Name. Character='r'.
X0014[28]: Text. Text scrap[White]=" "
X0014[29]: @# Name. Character='s'.
X0014[32]: Text. Text scrap[White]=" "
X0014[33]: @# Name. Character='t'.
X0014[36]: Text. Text scrap[White]=" "
X0014[37]: @# Name. Character='u'.
X0014[40]: Text. Text scrap[White]=" "
X0014[41]: @# Name. Character='v'.
X0014[44]: Text. Text scrap[White]=" "
X0014[45]: @# Name. Character='w'.
X0014[48]: Text. Text scrap[White]=" "
X0014[49]: @# Name. Character='x'.
X0014[52]: Text. Text scrap[White]=" "
X0014[53]: @# Name. Character='y'.
X0014[56]: Text. Text scrap[White]=" "
X0014[57]: @# Name. Character='z'.
X0014[60]: Text. Text scrap[White]="<010>
X"
X0015[01]: @# Name. Character='{'.
X0015[04]: Text. Text scrap[White]=" "
X0015[05]: @# Name. Character='|'.
X0015[08]: Text. Text scrap[White]=" "
X0015[09]: @# Name. Character='}'.
X0015[12]: Text. Text scrap[White]=" "
X0015[13]: @# Name. Character='~'.
X0015[16]: Text. Text scrap[Grey]="<010>
X<010>
X2. Test that <special>#<space> is flagged as an error.<010>
X<010>
X   "
X0019[07]: Text. Text scrap[White]="    "
X0020[01]: Text. Text scrap[Grey]="<010>
X3. Test that <special>#EOL is flagged as an error.<010>
X<010>
X   "
X0024[01]: Text. Text scrap[White]="<010>
X"
X0025[01]: End Of File. 
X============================ End of TOKEN LIST DUMP ============================
X
Macro table dump skipped (Parser was not invoked).
Document list dump skipped (Parser was not invoked).
X
Global Local| Input File
X------------+-------------------------------------------------------------------
X     1     1| SC17: Test <special>#.
X     2     2| 
X     3     3| First we trip up the scanner so no further passes take place.
X     4     4| 
X     5     5| @
X       Error|.^<special><endofline> is not a legal special sequence.
X     6     6| 
X     7     7| 1. Test with all possible printable characters.
X     8     8| 
X     9     9| @#! @#" @## @#$ @#% @#& @#' @#( @#) @#* @#+ @#, @#- @#. @#/
X    10    10| @#0 @#1 @#2 @#3 @#4 @#5 @#6 @#7 @#8 @#9 @#: @#; @#< @#= @#>
X    11    11| @#? @#@ @#A @#B @#C @#D @#E @#F @#G @#H @#I @#J @#K @#L @#M
X    12    12| @#N @#O @#P @#Q @#R @#S @#T @#U @#V @#W @#X @#Y @#Z @#[ @#\
X    13    13| @#] @#^ @#_ @#` @#a @#b @#c @#d @#e @#f @#g @#h @#i @#j @#k
X    14    14| @#l @#m @#n @#o @#p @#q @#r @#s @#t @#u @#v @#w @#x @#y @#z
X    15    15| @#{ @#| @#} @#~
X    16    16| 
X    17    17| 2. Test that <special>#<space> is flagged as an error.
X    18    18| 
X    19    19|    @#     @! Should be flagged as an error.
X       Error|......^Expecting a printable character.
X    20    20| 
X    21    21| 3. Test that <special>#EOL is flagged as an error.
X    22    22| 
X    23    23|    @#
X       Error|......^Expecting a printable character.
X    24    24| 
X            | <End-Of-File>
X------------+-------------------------------------------------------------------
X
There were 3 Errors.
END_OF_FILE
if test 14128 -ne `wc -c <'answers/sc17.lis'`; then
    echo shar: \"'answers/sc17.lis'\" unpacked with wrong size!
fi
# end of 'answers/sc17.lis'
fi
if test -f 'answers/sc28.lis' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'answers/sc28.lis'\"
else
echo shar: Extracting \"'answers/sc28.lis'\" \(13334 characters\)
sed "s/^X//" >'answers/sc28.lis' <<'END_OF_FILE'
XFUNNELWEB LISTING FILE
X======================
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 32 38 3A 20 54 65 73 74 20 73 79 6E 74 61 | SC28: Test synta |
X| 78 20 63 68 65 63 6B 69 6E 67 20 6F 66 20 74 69 | x checking of ti |
X| 74 6C 65 20 74 79 70 65 73 65 74 74 69 6E 67 20 | tle typesetting  |
X| 64 69 72 65 63 74 69 76 65 2E 0A 0A 31 2E 20 54 | directive...1. T |
X| 65 73 74 20 6C 65 73 73 20 74 68 61 6E 20 66 6F | est less than fo |
X| 75 72 20 61 72 67 75 6D 65 6E 74 73 20 28 69 6E | ur arguments (in |
X| 63 6C 75 64 65 73 20 74 69 74 6C 65 29 2E 0A 4E | cludes title)..N |
X| 6F 74 65 3A 20 54 68 65 20 74 69 74 6C 65 20 63 | ote: The title c |
X| 6F 6D 6D 61 6E 64 20 70 75 6C 6C 73 20 61 20 68 | ommand pulls a h |
X| 61 63 6B 20 74 72 65 61 74 69 6E 67 20 74 68 65 | ack treating the |
X| 20 72 65 73 74 20 6F 66 20 74 68 65 20 6C 69 6E |  rest of the lin |
X| 65 20 61 66 74 65 72 0A 74 77 6F 20 61 72 67 75 | e after.two argu |
X| 6D 65 6E 74 73 20 61 73 20 74 68 65 20 73 74 72 | ments as the str |
X| 69 6E 67 2E 20 53 6F 20 69 74 20 63 61 6E 27 74 | ing. So it can't |
X| 20 64 65 74 65 63 74 20 61 6E 20 45 58 43 45 53 |  detect an EXCES |
X| 53 20 6F 66 20 61 72 67 75 6D 65 6E 74 73 21 0A | S of arguments!. |
X| 40 74 20 74 69 74 6C 65 0A 40 74 20 74 69 74 6C | @t title.@t titl |
X| 65 20 74 77 6F 0A 40 74 20 74 69 74 6C 65 20 74 | e two.@t title t |
X| 77 6F 20 74 68 72 65 65 0A 0A 32 2E 20 54 65 73 | wo three..2. Tes |
X| 74 20 6F 75 74 20 62 61 64 20 66 6F 6E 74 2E 0A | t out bad font.. |
X| 40 74 20 74 69 74 6C 65 20 73 6C 6F 74 68 66 6F | @t title slothfo |
X| 6E 74 20 6C 65 66 74 20 22 53 6C 6F 74 68 22 0A | nt left "Sloth". |
X| 0A 33 2E 20 54 65 73 74 20 6F 75 74 20 62 61 64 | .3. Test out bad |
X| 20 61 6C 69 67 6E 6D 65 6E 74 2E 0A 40 74 20 74 |  alignment..@t t |
X| 69 74 6C 65 20 74 69 74 6C 65 66 6F 6E 74 20 77 | itle titlefont w |
X| 65 73 74 77 61 72 64 20 22 53 6C 6F 74 68 22 0A | estward "Sloth". |
X| 0A 34 2E 20 54 65 73 74 20 6F 75 74 20 66 75 6E | .4. Test out fun |
X| 6E 79 20 73 74 72 69 6E 67 73 2E 0A 40 74 20 74 | ny strings..@t t |
X| 69 74 6C 65 20 74 69 74 6C 65 66 6F 6E 74 20 6C | itle titlefont l |
X| 65 66 74 20 22 0A 40 74 20 74 69 74 6C 65 20 74 | eft ".@t title t |
X| 69 74 6C 65 66 6F 6E 74 20 6C 65 66 74 20 22 22 | itlefont left "" |
X| 0A 40 21 20 4E 6F 74 65 3A 20 54 68 65 20 66 6F | .@! Note: The fo |
X| 6C 6C 6F 77 69 6E 67 2C 20 62 65 6C 69 65 76 65 | llowing, believe |
X| 20 69 74 20 6F 72 20 6E 6F 74 2C 20 69 73 20 61 |  it or not, is a |
X| 63 74 75 61 6C 6C 79 20 4C 45 47 41 4C 21 0A 40 | ctually LEGAL!.@ |
X| 74 20 74 69 74 6C 65 20 74 69 74 6C 65 66 6F 6E | t title titlefon |
X| 74 20 6C 65 66 74 20 22 73 6C 6F 74 68 22 73 6C | t left "sloth"sl |
X| 6F 74 68 22 0A 0A 35 2E 20 54 65 73 74 20 6F 75 | oth"..5. Test ou |
X| 74 20 61 6C 6C 20 63 6F 6D 62 69 6E 61 74 69 6F | t all combinatio |
X| 6E 73 20 6F 66 20 66 6F 6E 74 20 61 6E 64 20 61 | ns of font and a |
X| 6C 69 67 6E 6D 65 6E 74 2E 0A 40 74 20 74 69 74 | lignment..@t tit |
X| 6C 65 20 74 69 74 6C 65 66 6F 6E 74 20 20 20 20 | le titlefont     |
X| 20 20 6C 65 66 74 20 20 20 22 53 6C 6F 74 68 22 |   left   "Sloth" |
X| 0A 40 74 20 74 69 74 6C 65 20 74 69 74 6C 65 66 | .@t title titlef |
X| 6F 6E 74 20 20 20 20 20 20 63 65 6E 74 72 65 20 | ont      centre  |
X| 22 53 6C 6F 74 68 22 0A 40 74 20 74 69 74 6C 65 | "Sloth".@t title |
X| 20 74 69 74 6C 65 66 6F 6E 74 20 20 20 20 20 20 |  titlefont       |
X| 72 69 67 68 74 20 20 22 53 6C 6F 74 68 22 0A 40 | right  "Sloth".@ |
X| 74 20 74 69 74 6C 65 20 73 6D 61 6C 6C 74 69 74 | t title smalltit |
X| 6C 65 66 6F 6E 74 20 6C 65 66 74 20 20 20 22 53 | lefont left   "S |
X| 6C 6F 74 68 22 0A 40 74 20 74 69 74 6C 65 20 73 | loth".@t title s |
X| 6D 61 6C 6C 74 69 74 6C 65 66 6F 6E 74 20 63 65 | malltitlefont ce |
X| 6E 74 72 65 20 22 53 6C 6F 74 68 22 0A 40 74 20 | ntre "Sloth".@t  |
X| 74 69 74 6C 65 20 73 6D 61 6C 6C 74 69 74 6C 65 | title smalltitle |
X| 66 6F 6E 74 20 72 69 67 68 74 20 20 22 53 6C 6F | font right  "Slo |
X| 74 68 22 0A 40 74 20 74 69 74 6C 65 20 6E 6F 72 | th".@t title nor |
X| 6D 61 6C 66 6F 6E 74 20 20 20 20 20 6C 65 66 74 | malfont     left |
X| 20 20 20 22 53 6C 6F 74 68 22 0A 40 74 20 74 69 |    "Sloth".@t ti |
X| 74 6C 65 20 6E 6F 72 6D 61 6C 66 6F 6E 74 20 20 | tle normalfont   |
X| 20 20 20 63 65 6E 74 72 65 20 22 53 6C 6F 74 68 |    centre "Sloth |
X| 22 0A 40 74 20 74 69 74 6C 65 20 6E 6F 72 6D 61 | ".@t title norma |
X| 6C 66 6F 6E 74 20 20 20 20 20 72 69 67 68 74 20 | lfont     right  |
X| 20 22 53 6C 6F 74 68 22 0A 0A 36 2E 20 54 65 73 |  "Sloth"..6. Tes |
X| 74 20 6D 69 73 73 70 65 6C 6C 69 6E 67 20 6F 66 | t misspelling of |
X| 20 63 65 6E 74 72 65 20 28 52 6F 73 73 27 73 20 |  centre (Ross's  |
X| 72 65 76 65 6E 67 65 29 2E 0A 40 74 20 74 69 74 | revenge)..@t tit |
X| 6C 65 20 6E 6F 72 6D 61 6C 66 6F 6E 74 20 20 20 | le normalfont    |
X| 20 20 63 65 6E 74 65 72 20 22 53 6C 6F 74 68 22 |   center "Sloth" |
X| 0A                                              | .                |
X+-------------------------------------------------+------------------+
X
X
X=========================== Start of LINE LIST DUMP ============================
X
Globl Local| Text
X-----------+--------------------------------------------------------------------
X00001 00001| SC28: Test syntax checking of title typesetting directive.<010>
X00002 00002| <010>
X00003 00003| 1. Test less than four arguments (includes title).<010>
X00004 00004| Note: The title command pulls a hack treating the rest of the line after<010>
X00005 00005| two arguments as the string. So it can't detect an EXCESS of arguments!<010>
X00006 00006| @t title<010>
X00007 00007| @t title two<010>
X00008 00008| @t title two three<010>
X00009 00009| <010>
X00010 00010| 2. Test out bad font.<010>
X00011 00011| @t title slothfont left "Sloth"<010>
X00012 00012| <010>
X00013 00013| 3. Test out bad alignment.<010>
X00014 00014| @t title titlefont westward "Sloth"<010>
X00015 00015| <010>
X00016 00016| 4. Test out funny strings.<010>
X00017 00017| @t title titlefont left "<010>
X00018 00018| @t title titlefont left ""<010>
X00019 00019| @! Note: The following, believe it or not, is actually LEGAL!<010>
X00020 00020| @t title titlefont left "sloth"sloth"<010>
X00021 00021| <010>
X00022 00022| 5. Test out all combinations of font and alignment.<010>
X00023 00023| @t title titlefont      left   "Sloth"<010>
X00024 00024| @t title titlefont      centre "Sloth"<010>
X00025 00025| @t title titlefont      right  "Sloth"<010>
X00026 00026| @t title smalltitlefont left   "Sloth"<010>
X00027 00027| @t title smalltitlefont centre "Sloth"<010>
X00028 00028| @t title smalltitlefont right  "Sloth"<010>
X00029 00029| @t title normalfont     left   "Sloth"<010>
X00030 00030| @t title normalfont     centre "Sloth"<010>
X00031 00031| @t title normalfont     right  "Sloth"<010>
X00032 00032| <010>
X00033 00033| 6. Test misspelling of centre (Ross's revenge).<010>
X00034 00034| @t title normalfont     center "Sloth"<010>
X00035 00035| <End-Of-File><010>
X-----------+--------------------------------------------------------------------
Globl Local| Text
X
X============================ End of LINE LIST DUMP =============================
X
X
X=========================== Start of TOKEN LIST DUMP ===========================
X
Summary: There are 18 tokens in the token list.
X
Line[Column]: Token Description
X-------------------------------
X
X0001[01]: Text. Text scrap[Grey]="SC28: Test syntax checking of title typesetting directive.<010>
X<010>
X1. Test less than four arguments (includes title).<010>
Note: The title command pulls a hack treating the rest of the line after<010>
two arguments as the string. So it can't detect an EXCESS of arguments!<010>
X"
X0009[01]: Text. Text scrap[Grey]="<010>
X2. Test out bad font.<010>
X"
X0012[01]: Text. Text scrap[Grey]="<010>
X3. Test out bad alignment.<010>
X"
X0015[01]: Text. Text scrap[Grey]="<010>
X4. Test out funny strings.<010>
X"
X0018[01]: @t.. Title. Font=Title, Alignment=Left. Title text follows:
Text scrap[Grey]=""
X0020[01]: @t.. Title. Font=Title, Alignment=Left. Title text follows:
Text scrap[Grey]="sloth"sloth"
X0021[01]: Text. Text scrap[Grey]="<010>
X5. Test out all combinations of font and alignment.<010>
X"
X0023[01]: @t.. Title. Font=Title, Alignment=Left. Title text follows:
Text scrap[Grey]="Sloth"
X0024[01]: @t.. Title. Font=Title, Alignment=Centre. Title text follows:
Text scrap[Grey]="Sloth"
X0025[01]: @t.. Title. Font=Title, Alignment=Right. Title text follows:
Text scrap[Grey]="Sloth"
X0026[01]: @t.. Title. Font=Small Title, Alignment=Left. Title text follows:
Text scrap[Grey]="Sloth"
X0027[01]: @t.. Title. Font=Small Title, Alignment=Centre. Title text follows:
Text scrap[Grey]="Sloth"
X0028[01]: @t.. Title. Font=Small Title, Alignment=Right. Title text follows:
Text scrap[Grey]="Sloth"
X0029[01]: @t.. Title. Font=Normal, Alignment=Left. Title text follows:
Text scrap[Grey]="Sloth"
X0030[01]: @t.. Title. Font=Normal, Alignment=Centre. Title text follows:
Text scrap[Grey]="Sloth"
X0031[01]: @t.. Title. Font=Normal, Alignment=Right. Title text follows:
Text scrap[Grey]="Sloth"
X0032[01]: Text. Text scrap[Grey]="<010>
X6. Test misspelling of centre (Ross's revenge).<010>
X"
X0035[01]: End Of File. 
X============================ End of TOKEN LIST DUMP ============================
X
Macro table dump skipped (Parser was not invoked).
Document list dump skipped (Parser was not invoked).
X
Global Local| Input File
X------------+-------------------------------------------------------------------
X     1     1| SC28: Test syntax checking of title typesetting directive.
X     2     2| 
X     3     3| 1. Test less than four arguments (includes title).
X     4     4| Note: The title command pulls a hack treating the rest of the line after
X     5     5| two arguments as the string. So it can't detect an EXCESS of arguments!
X     6     6| @t title
X       Error|.^This directive has too few arguments.
X            |.^The correct format is: "@t title <font> <align> <text>".
X            |.^   where <font>  = titlefont | smalltitlefont | normalfont.
X            |.^   and   <align> = left | centre | right.
X            |.^   and   <text>  = text delimited by double quotes.
X            |.^Directive ignored.
X     7     7| @t title two
X       Error|.^This directive has too few arguments.
X            |.^The correct format is: "@t title <font> <align> <text>".
X            |.^   where <font>  = titlefont | smalltitlefont | normalfont.
X            |.^   and   <align> = left | centre | right.
X            |.^   and   <text>  = text delimited by double quotes.
X            |.^Directive ignored.
X     8     8| @t title two three
X       Error|.^This directive has too few arguments.
X            |.^The correct format is: "@t title <font> <align> <text>".
X            |.^   where <font>  = titlefont | smalltitlefont | normalfont.
X            |.^   and   <align> = left | centre | right.
X            |.^   and   <text>  = text delimited by double quotes.
X            |.^Directive ignored.
X     9     9| 
X    10    10| 2. Test out bad font.
X    11    11| @t title slothfont left "Sloth"
X       Error|..........^Expecting one of {titlefont,smalltitlefont,normalfont}.
X            |..........^Directive ignored.
X    12    12| 
X    13    13| 3. Test out bad alignment.
X    14    14| @t title titlefont westward "Sloth"
X       Error|....................^Expecting one of {left,right,centre}.
X            |....................^Directive ignored.
X    15    15| 
X    16    16| 4. Test out funny strings.
X    17    17| @t title titlefont left "
X       Error|.........................^Text argument must be delimited by double quotes.
X            |.........................^Directive ignored.
X    18    18| @t title titlefont left ""
X    19    19| @! Note: The following, believe it or not, is actually LEGAL!
X    20    20| @t title titlefont left "sloth"sloth"
X    21    21| 
X    22    22| 5. Test out all combinations of font and alignment.
X    23    23| @t title titlefont      left   "Sloth"
X    24    24| @t title titlefont      centre "Sloth"
X    25    25| @t title titlefont      right  "Sloth"
X    26    26| @t title smalltitlefont left   "Sloth"
X    27    27| @t title smalltitlefont centre "Sloth"
X    28    28| @t title smalltitlefont right  "Sloth"
X    29    29| @t title normalfont     left   "Sloth"
X    30    30| @t title normalfont     centre "Sloth"
X    31    31| @t title normalfont     right  "Sloth"
X    32    32| 
X    33    33| 6. Test misspelling of centre (Ross's revenge).
X    34    34| @t title normalfont     center "Sloth"
X       Error|.........................^Expecting one of {left,right,centre}.
X            |.........................^Note: Centre is spelt centRE, not centER.
X            |.........................^      This is my revenge for years of getting error messages
X            |.........................^      from TeX whenever I accidentally wrote \centreline - Ross Williams.
X            |.........................^Directive ignored.
X            | <End-Of-File>
X------------+-------------------------------------------------------------------
X
There were 7 Errors.
END_OF_FILE
if test 13334 -ne `wc -c <'answers/sc28.lis'`; then
    echo shar: \"'answers/sc28.lis'\" unpacked with wrong size!
fi
# end of 'answers/sc28.lis'
fi
if test -f 'answers/wv01.tex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'answers/wv01.tex'\"
else
echo shar: Extracting \"'answers/wv01.tex'\" \(15563 characters\)
sed "s/^X//" >'answers/wv01.tex' <<'END_OF_FILE'
X
X%*******************************************************************************
X%*                    START OF AUTOMATICALLY GENERATED TEX FILE                *
X%*******************************************************************************
X%*                                                                             *
X%* This TeX file was automatically generated by the FunnelWeb preprocessor.    *
X%* You can typeset this file to produce printed documentation by running it    *
X%* through the TeX typesetter using a command such as:                         *
X%*    tex thisfilename                                                         *
X%* The resultant file thisfilename.dvi can be printed using a command such as: *
X%*    lpr -Pcslw -d thisfilename.dvi                                           *
X%*                                                                             *
X%* FunnelWeb is a preprocessor that allows programmers to weave programs and   *
X%* their documentation together in a single document. The FunnelWeb program    *
X%* analyses such documents producing both program files and typeset            *
X%* documentation such as this TeX file.                                        *
X%* FunnelWeb was created by Ross Williams.                                     *
X%*                                                                             *
X%* For more information on FunnelWeb look in the following FTP archive:        *
X%*    Machine  : sirius.itd.adelaide.edu.au [IP=129.127.40.3].                 *
X%*    Directory: ~pub/funnelweb/                                               *
X%*               (or some other appropriately named directory).                *
X%* or email Ross Williams at ross@spam.adelaide.edu.au                         *
X%*                                                                             *
X%*******************************************************************************
X
X
X%===================== Start of FunnelWeb TeX Definitions ======================
X
X
X% Version
X% -------
X% This is FunnelWeb TeX Macro Library Version 1.0.
X
X
X% Copyright
X% ---------
X% This set of FunnelWeb TeX definitions was written by Ross Williams and was
X% originally Copyright (C) 1992 Ross N. Williams.  However, I, Ross Williams,
X% hereby forego any claim to Copyright in this set of FunnelWeb TeX definitions
X% and hereby authorize that the set of TeX definitions pass into the public
X% domain. -- Ross N. Williams, 3:41pm 07-May-1992, Adelaide, Australia.
X
X
X% Modification
X% ------------
X% Please record all modifications to these TeX definitions here. Unless
X% otherwise specified, all modified definitions fall in the public domain too.
X%
X% Programmers:
X%    RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X%
X% Changes:
X%    07-May-1992  RNW  Prepared this work for public domain release.
X%
X
X
X% General Comments
X% ----------------
X% This set of TeX definitions exists for two reasons:
X%
X%    1. To shorten and neaten the FunnelWeb TeX output.
X%    2. To allow users to fiddle with the output format in their input files
X%       (by inserting redefining "\def"s) without having to resort to
X%       modifying the FunnelWeb code.
X%
X% The user is warned that these definitions may be changed from time to time
X% (but probably not much). The user should not be too sneaky. In particular,
X% users wishing to redefine some of these macros should do so in an explicitly
X% defined section at the top of their input file. This will mean that in the
X% event of problems, that section can simply be deleted or commented out to
X% allow the document to at least be typeset in the default format. Users should
X% limit themselves to redefining these macros in such a section and should
X% refrain from using the macros throughout their documents.
X
X
X% Environment Parameters
X% ----------------------
X% \tolerance tells TeX how tolerant it should be about making bad line and
X% page breaks. Here we set it to it's maximum, as
X%   1) Computer programs are likely to cause lots of bad breaks.
X%   2) In most cases the user would probably rather get the TeX file through
X%      TeX without any errors than fiddle with spacings for perfection.
X\tolerance=10000
X
X% I don't like indentation as it makes the page look more busy. Instead,
X% paragraphs are separated by a little space (see next).
X\parindent=0pt
X
X% In many cases, users will produce documents with long runs of paragraphs.
X% In order to space out these paragraphs, it is convenient to maintain a
X% prevailing non-zero \parskip (end-of-paragaph skip). The only trouble is
X% that the skip becomes a problem in macro definitions which require no skip
X% and so we have to turn the skip on and off. The following two macros
X% simplify this process.
X\def\fwparskipon{\parskip=\medskipamount}
X\def\fwparskipoff{\parskip=0pt}
X\fwparskipon
X
X% Setting raggedbottom allows TeX to leave a bit of space at the bottom of the
X% page in order to better vertically align the rest of the page (e.g. skips
X% won't stretch as much). It also means that headings are less likely to be
X% isolated at the bottom of the page without any following text.
X\raggedbottom
X
X
X% Fonts
X% -----
X% Most of the typeset output is set in 10pt roman and 10pt tt font.
X% The major extra font needs spring from titles and headings.
X% For portability's sake we use only the following fonts:
X%    cmr10
X%    cmbx10
X%    cmtt10
X% and some enlargements of them. These fonts are all "standard" fonts
X% in Plain TeX. See The TeXbook p.350.
X\font\fwfontnote=cmr7
X
X\font\fwfontnorm=cmr10
X\font\fwfontnorma=cmr10 scaled \magstep1
X\font\fwfontnormb=cmr10 scaled \magstep2
X
X\font\fwfontbold=cmbx10
X\font\fwfontbolda=cmbx10 scaled \magstep1
X\font\fwfontboldb=cmbx10 scaled \magstep2
X\font\fwfontboldc=cmbx10 scaled \magstep3
X\font\fwfontboldd=cmbx10 scaled \magstep4
X
X
X% Macros for Stylistic Details
X% ----------------------------
X% This section contains all the fiddly little macros for setting the details
X% of each macro definition.
X
X% Macro definitions are sandwiched by calls to these macros which can be used
X% to sort out the spacing before and after the macro definition.
X\def\fwbeginmacro{\fwparskipoff\bigskip}
X\def\fwendmacro{\fwparskipon\par}
X
X% These macros deal with the macro name and definition line.
X\def\fwmacroname#1#2{{\sl #1\/}$\lbrack$#2$\rbrack$}
X\def\fwfilename#1#2{{\bf #1}$\lbrack$#2$\rbrack$}
X\def\fwzero#1{{\bf Z}}
X\def\fwmany#1{{\bf M}}
X\def\fwequals{ $\equiv$}
X\def\fwplusequals{ $+\equiv$}
X
X% Now for the actual body of the definition. It looks nice to have the tt
X% code indented a little. Again, we use macros instead of writing direct TeX,
X% so as to allow the user to fiddle this stuff to taste without having to
X% modify the FunnelWeb C code.
X\def\fwodef{\parindent=15pt\vskip0pt$\lbrace$\parindent=20pt}
X\def\fwcdef{$\rbrace$\vskip0pt\parindent=0pt}
X\def\fwoquote{`}
X\def\fwcquote{'}
X\def\fwoparen{$($}
X\def\fwcomma{$,$}
X\def\fwcparen{$)$}
X\def\fwparam#1{$\diamond #1$}
X\def\fwparams#1{$(\diamond #1)$}
X
X% These macros deal with the notes that are appended at the end of each
X% macro definition. Note that even though \fwisafile,\fwusedin, and \fwseealso
X% have the same definition, they are given different names so as to allow the
X% user to redefine these macros to typeset each kind of information differently
X% if desired.
X\def\fwbeginmacronotes{\begingroup\baselineskip=9pt\smallskip}
X\def\fwnote#1{{\fwfontnote #1}\par}
X\def\fwisafile#1{\fwnote{#1}}
X\def\fwusedin#1{\fwnote{#1}}
X\def\fwseealso#1{\fwnote{#1}}
X\def\fwendmacronotes{\endgroup}
X
X
X% Macros to Typeset Program Code Verbatim
X% ---------------------------------------
X% This is by far the hairiest and most difficult part of the typesetting task
X% because we have to turn off most of TeX's natural instincts in order to
X% typeset the program text exactly as it appears in the input file.
X% Two macros are defined to pull this off: \fwbtx and \fwverbatimgobble.
X% Their code was inspired by the following sections of "The TeXbook":
X%    Appendix D: Dirty Tricks, 3.Verbatim listing, p.380-382.
X%    Appendix E: Example Formats, p.421.
X% The \fwbtx[ (for "FunnelWeb Begin TeXt") macro does most of the hard work.
X% The liberal use of "%" is because I don't understand TeX well enough to
X% understand when an end of line will cause trouble, and I am playing it safe.
X
X% Before defining the main \fwbtx macro, we have to stash away some definitions
X% in the hidden part of TeX's environment. Let's hope that these "hidden"
X% definitions don't affect anything except what is desired to be affected.
X
X% The tt font in which we wish to set the text has two Latin lurking ligatures!
X% These are ?` and !`. To disable them, we define the left quote when ACTIVE
X% to be defined in such a way as to prevent ligatures. The main TeX text will
X% normally not be exposed to this definition because normally the leftquote
X% character is not active. The \fwbtx macro temporarily makes the left quote
X% character active thus activating the deactivation of left quote ligatures.
X% See The TeXbook p.381.
X{\catcode`\`=\active \gdef`{\relax\lq}}
X
X% TeX is fairly carefree about spaces and so we have to make it more serious.
X% To do so we pull the same trick as above, setting up a definition for active
X% space, but only making space active during the span of the verbatim text.
X% In Plain TeX the active space is defined to be simply a space, but here we
X% define it to be a control space. This ensures that the space cannot
X% be gobbled up by one of TeX's mysterious mechanisms when activated.
X% See The TeXbook, p.381 and p.352.
X{\obeyspaces\global\let =\ }
X
X% Here is the main \fwbtx verbatim text macro.
X% Note: The order in which all these pieces of business have to be done is
X% still a partial mystery to me. Don't fiddle with this stuff unless you
X% think you know what you are doing.
X\def\fwbtx[{%
X%
X% The funnies involved in getting verbatim output are safely housed inside
X% this \begingroup, and the \endgroup in \fwverbatimgobble. Groups are used
X% instead of curly braces because we have to be able to signal the end of
X% this macro with a curly brace.
X\begingroup%
X%
X% \pars at the end of empty lines in the verbatim text won't come out normally
X% because TeX is in vertical mode and they get gobbled up. To prevent this,
X% we force \par to exit vertical mode first. See The TeXbook p.381.
X\def\par{\leavevmode\endgraf}%
X%
X% Activate the leftquote character so as to avoid ligatures (see above).
X\catcode`\`=\active%
X%
X% The \obeylines macro simply defines end of line (^M) to be \par. This ensures
X% that TeX will treat each verbatim line as a new paragraph.
X\obeylines%
X%
X% To get verbatim output, we have to desex all the special characters. This
X% is explained in detail in The TeXbook p.380.
X\def\do##1{\catcode`##1=12 }\dospecials%
X%
X% Activate the space character so as to make TeX treat blanks seriously.
X% This activation invokes an eralier definition (see above).
X\obeyspaces
X%
X% Interparagraph skips do not help the cause.
X% Note: We have to preserve the indentation though, as the code is actually
X% indented in the final output. See \fwodef in an earlier section.
X\parskip=0pt%
X%
X% We typeset the verbatim text in tt font (courier on the Macintosh) for a
X% number of reasons:
X%    - tt font has the same horizontal spacing for each character.
X%    - tt font covers the ASCII character set.
X%    - tt font doesn't have many surprises (e.g. ligatures).
X%    - tt font looks much what you might see on a computer terminal screen.
X\tt%
X%
X% Having set up an environment for verbatim, we are ready to use it.
X% By invoking \fwverbatimgobble, this \fwbtx macro gobbles up text verbatim (as
X% part of the parameter of \fwverbatimgobble) until it sees the termination
X% string "]fwetx=" (the "=" was thrown in to add obscurity as this sequence
X% must never occur in the verbatim text).
X\fwverbatimgobble}
X
X% The \fwverbatimgobble macro exists to allow \fwbtx to bracket verbatim text.
X\def\fwverbatimgobble#1]fwetx={#1\endgroup}
X
X
X% Table of Contents
X% -----------------
X% The five levels of table of contents that FunnelWeb supports are identified
X% by the five letters [A..E]. These are used throughout the following macros.
X
X% The following macros are utilities to the TOC macros to follow.
X\def\fwrule{\medskip\hrule\medskip}
X\def\fwqh{\hskip1.5em\relax}
X\def\fwbeforesec{\penalty-200\bigskip\medskip\par}
X
X% The following macros are used to typeset the table of contents.
X\def\fwtocstart#1{\fwrule\leftline{\fwfontbolda Table of Contents}\fwrule}
X\def\fwtoca#1#2{\leftline{{\bf #1 #2}}}
X\def\fwtocb#1#2{\leftline{\fwqh #1 #2}}
X\def\fwtocc#1#2{\leftline{\fwqh\fwqh #1 #2}}
X\def\fwtocd#1#2{\leftline{\fwqh\fwqh\fwqh #1 #2}}
X\def\fwtoce#1#2{\leftline{\fwqh\fwqh\fwqh\fwqh #1 #2}}
X\def\fwtocfinish#1{\fwrule}
X
X% The following "library" macros define five different strengths of headings
X% which can be used later in the section macros.
X\def\fwliba#1#2{\vfill\eject{\fwfontboldc #1 #2}\penalty200\smallskip}
X\def\fwlibb#1#2{\fwbeforesec{\fwfontboldb #1 #2}\penalty200\smallskip}
X\def\fwlibc#1#2{\fwbeforesec{\fwfontnormb #1 #2}\penalty200\smallskip}
X\def\fwlibd#1#2{\fwbeforesec{\bf          #1 #2}\penalty200}
X\def\fwlibe#1#2{\fwbeforesec{\bf          #1 #2}}
X
X% Here are the macros that actually typeset the section headings throughout
X% the document. The fwlib system has been employed so as to easily allow the
X% user to redefine the strengths of headings to taste. For example, the
X% user could insert in the input document a similar set of definitions to these
X% but with the b..e headings set to \fwlibc. This would tone down the output.
X\def\fwseca#1#2{\fwliba{#1}{#2}}
X\def\fwsecb#1#2{\fwlibb{#1}{#2}}
X\def\fwsecc#1#2{\fwlibc{#1}{#2}}
X\def\fwsecd#1#2{\fwlibd{#1}{#2}}
X\def\fwsece#1#2{\fwlibe{#1}{#2}}
X
X
X% Support for Explicit Typesetting
X% --------------------------------
X% FunnelWeb supports pragmas and other constructs that allow
X% typesetter-independent typesetting commands to be given. The
X% following macros support these features.
X
X% The in-text literal @{sloth@} and emphasise @[walrus@] features.
X\def\fwlit#1{{\tt #1}}
X\def\fwemp#1{{\it #1}}
X
X% The "@p new_page" pragma.
X\def\fwnewpage{\vfill\eject}
X
X% The "@p vskip Nmm" pragma.
X\def\fwvskip#1{\null\vskip #1mm}
X
X% The "@p title <font> <align> <text>" pragma.
X\def\fwfontnormal#1{{\fwfontnorm {#1}}}
X\def\fwfonttitle#1{{\fwfontboldd {#1}}}
X\def\fwfontsmalltitle#1{{\fwfontboldb {#1}}}
X\def\fwleftline#1{\leftline{#1}}
X\def\fwcenterline#1{\centerline{#1}}
X\def\fwrightline#1{\rightline{#1}}
X
X
X% Support for Old FunnelWeb
X% -------------------------
X% The following macros were used extensively in the first version of
X% FunnelWeb and are retained so that these older input files will still
X% typeset cleanly.
X\def\p#1{{\tt #1}}  % P for Program text.
X\def\flagpage#1#2{
X   \null
X   \vfill
X   \centerline{\fwfontboldd #1}
X   \vskip 1cm
X   \centerline{\fwfontboldd #2}
X   \vfill
X   \null
X   \vfill
X}
X
X%====================== End of FunnelWeb TeX Definitions =======================
WV01: Test basic typeset file output mechanism.
X
X\fwseca{1}{A section for no particular reason}
X
X\fwbeginmacro
X\fwfilename{wv01.out}{1}\fwequals \fwodef \fwbtx[Some text for no particular reason.
X]fwetx=%
X\fwcdef 
X\fwbeginmacronotes
X\fwisafile{This macro is attached to an output file.}
X\fwendmacronotes
X\fwendmacro
X
X\bye
X
X
X%*******************************************************************************
X%*                    END OF AUTOMATICALLY GENERATED TEX FILE                  *
X%*******************************************************************************
X
END_OF_FILE
if test 15563 -ne `wc -c <'answers/wv01.tex'`; then
    echo shar: \"'answers/wv01.tex'\" unpacked with wrong size!
fi
# end of 'answers/wv01.tex'
fi
if test -f 'sources/machin.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sources/machin.h'\"
else
echo shar: Extracting \"'sources/machin.h'\" \(14389 characters\)
sed "s/^X//" >'sources/machin.h' <<'END_OF_FILE'
X/*##############################################################################
X
XFUNNNELWEB COPYRIGHT
X====================
XFunnelWeb is a literate-programming macro preprocessor.
X
Copyright (C) 1992 Ross N. Williams.
X
X   Ross N. Williams
X   ross@spam.adelaide.edu.au
X   16 Lerwick Avenue, Hazelwood Park 5066, Australia.
X
This program is free software; you can redistribute it and/or modify
it under the terms of Version 2 of the GNU General Public License as
published by the Free Software Foundation.
X
This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See Version 2 of the GNU General Public License for more details.
X
You should have received a copy of Version 2 of the GNU General Public
License along with this program. If not, you can FTP the license from
prep.ai.mit.edu/pub/gnu/COPYING-2 or write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Section 2a of the license requires that all changes to this file be
recorded prominently in this file. Please record all changes here.
X
Programmers:
X   RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X
Changes:
X   07-May-1992  RNW  Program prepared for release under GNU GPL V2.
X
X##############################################################################*/
X
X
X/******************************************************************************/
X/*                                    MACHIN.H                                */
X/******************************************************************************/
X/*                                                                            */
X/* WARNING: DO NOT ADD ANY PROGRAM DEPENDENT DEFINITIONS.                     */
X/*                                                                            */
X/* This module (machin.h and machin.c) contains definitions and objects       */
X/* whose values depends directly on the compilation and execution             */
X/* environment, but are otherwise independent from any particular computer    */
X/* program.                                                                   */
X/*                                                                            */
X/* The only difference between the purpose of this module and the "environ"   */
X/* module is that the "environ" module contains the "essentials" whereas this */
X/* module contains extra machine specific definitions and objects that will   */
X/* not be required by most user modules.                                      */
X/*                                                                            */
X/******************************************************************************/
X
X/* Ensure that the body of this header file is included at most once.         */
X#ifndef DONE_FWMACHIN
X#define DONE_FWMACHIN
X
X/******************************************************************************/
X
X#include <time.h>
X#include "style.h"
X
X/******************************************************************************/
X
X/* Machine Alignment Constraints                                              */
X/* -----------------------------                                              */
X/* Some machines require that objects of particular lengths be aligned in     */
X/* memory. For example, the 68000 will trap any attempt to access a word      */
X/* (16 bits or an int in THINK C) at an odd address. It is important that C   */
X/* programs that deal with memory at a low level be aware of such             */
X/* constraints. As the constraints are always at a power of two, we defined   */
X/* ALIGN_POWER to be the minimum power of two at which it is both safe and    */
X/* efficient to operate.                                                      */
X
X/* The Macintosh requires words and longs to be aligned on word boundaries.   */
X/* The PC is not fussy about alignment, but operates more efficiently at word */
X/* boundaries.                                                                */
X#if MAC | PC
X#define ALIGN_POWER (1L)
X#endif
X
X/* The Sun requires objects to be aligned on longword boundaries (=2^2).      */
X/* The VMS VAX doesn't care about alignment, but operates more efficiently on */
X/* longword boundaries.                                                       */
X#if SUN | VMS
X#define ALIGN_POWER (2L)
X#endif
X
X/******************************************************************************/
X
X/* Filenames                                                                  */
X/* ---------                                                                  */
X/* The length and structure of filenames varies from machine to machine. The  */
X/* differences addressed here are:                                            */
X/*    1) The character used to separate directory specs from filenames.       */
X/*    2) The maximum length of a filename.                                    */
X
X/* FN_DELIM must contain the character that separates directory specs from    */
X/* filenames. Notice that in the VMS case, it is "]", not "."                 */
X
X#if MAC
X#define FN_DELIM ':'
X#endif
X
X#if SUN
X#define FN_DELIM '/'
X#endif
X
X#if VAX
X#define FN_DELIM ']'
X#endif
X
X#if PC
X#define FN_DELIM '\\'
X#endif
X
X/* The rest of this section shouldn't have to be changed, unless you          */
X/* encounter a funny with your system's definition of FILENAME_MAX.           */
X
X/* FILENAME_MAX tells the maximum number of characters allowed in a filename  */
X/* on the target machine. This symbol is supposed to be defined in stdio.h    */
X/* (ANSI S7.9.1) so we don't want to override that. However, if it isn't, we  */
X/* need to define a safe default length.                                      */
X#ifndef FILENAME_MAX
X#define FILENAME_MAX 300
X#endif
X
X/* Some VAX compilers define FILENAME_MAX to be 39, which is the maximum      */
X/* length of the NAME part of a VMS filename. This is not appropriate, so we  */
X/* override it.                                                               */
X#if VMS
X#undef FILENAME_MAX
X#define FILENAME_MAX 255        /* Should really be NAM$C_MAXRSS              */
X#endif
X
X/* Now we can use the constant to define a filename type.                     */
X/* Note: For a while I defined "typedef fn_t *p_fn_t". However, this is a     */
X/* pointer to an array rather than (char *) and it caused no end of problems. */
typedef char fn_t[FILENAME_MAX+1];
typedef char *p_fn_t;
X
X/******************************************************************************/
X
X/* Command Lines                                                              */
X/* -------------                                                              */
X/* The maximum length of command line varies from machine to machine and we   */
X/* define symbols to reflect this. The reason why we don't just set this to a */
X/* high value and forget about it is that FunnelWeb sometimes places          */
X/* command line variables on the stack, and some machines (e.g. MAC under     */
X/* THINK-C don't provide much stack space. So we have to minimize this        */
X/* variable on those machines.                                                */
X
X/* We choose a small maximum command line on the Macintosh so as to avoid     */
X/* chewing up stack space when command lines have to be pushed.               */
X#if MAC
X#define COMLINE_MAX 300
X#endif
X
X/* On the Sun, 1024 is a normal command line and 2048 is safe. */
X#if SUN
X#define COMLINE_MAX 2048
X#endif
X
X/* On the VMS, 1024 is usually adequate. */
X#if VMS
X#define COMLINE_MAX 1024
X#endif
X
X/* On a PC, we assume this is enough. */
X#if PC
X#define COMLINE_MAX 300
X#endif
X
X/* Make sure that the value is not too low. */
X/* The value 300 is guaranteed by the command interpreter. */
X#if COMLINE_MAX < 300
X   #error COMLINE_MAX must be at least 300.
X#endif
X
X/* Now define a type for command lines.                                       */
X/* Note: For a while I defined "typedef cl_t *p_cl_t". However, this is a     */
X/* pointer to an array rather than (char *) and it caused no end of problems. */
typedef char cl_t[COMLINE_MAX+1];
typedef char *p_cl_t;
X
X/******************************************************************************/
X
X/* Line Termination                                                           */
X/* ----------------                                                           */
X
X/* FunnelWeb has special-case code to make reading input files faster on      */
X/* machines where the format of text files corresponds to the internal C      */
X/* text stream model. The UNIX_EOL #define should be activated if and only    */
X/* the host environment has text files consisting of a stream of bytes with   */
X/* a single LF (ASCII,decimal-10,hex-0A) character being used to terminate    */
X/* each line, and no special character to indicate end of file.               */
X/* This is the same format as is used in the Unix operating system.           */
X/* If you are in doubt about this, play it safe and define your environment   */
X/* to be non-Unix, as non-Unix will work on ALL systems (including Unix).     */
X
X#if MAC | VMS | PC
X/* These systems do NOT use Unix EOLs. */
X#define UNIX_EOL 0
X#endif
X
X#if SUN
X/* This should really be 1 on a SUN, but I haven't got around to debugging    */
X/* FunnelWeb with UNIX_EOL==1.                                                */
X#define UNIX_EOL 0
X#endif
X
X/******************************************************************************/
X
X/* MIssing Prototypes                                                         */
X/* ----------------                                                           */
X/* Compilers that are fussy about prototypes sometimes complain about calls   */
X/* to the standard libraries. These declarations solve this problem.          */
X
X#if SUN
int     fclose  P_((FILE *stream));
int     fputs   P_((const char *s, FILE *stream));
int     fputc   P_((int c, FILE *stream));
int     fflush  P_((FILE *stream));
int     remove  P_((const char *filename));
int     rename  P_((const char *oldname, const char *newname));
int     toupper P_((int));
int     sscanf  P_(());
int     fprintf P_(());
int     _filbuf P_(());
void    *memcpy P_((void *s1, void *s2, size_t n));
void    *memset P_((void *s,     int c, size_t n));
int     memcmp  P_((void *s1, void *s2, size_t n));
size_t  fread   P_((void *ptr, size_t size, size_t nobj, FILE *stream));
size_t  fwrite  P_((const void *ptr, size_t size, size_t nobj, FILE *stream));
clock_t clock   P_((void));
time_t  time    P_((time_t *tp));
int     printf  P_(());
X#endif
X
X/******************************************************************************/
X
XEXPORT void fn_ins P_((p_fn_t,char *));
X/* - The name stands for FileName INSert.                                     */
X/* - The first argument must be a pointer to an object of type fn_t           */
X/*   (containing an ordinary C character string).                             */
X/* - The second argument must be a pointer to an ordinary C character string. */
X/* - Both arguments must contain a full, partial, or empty filename spec.     */
X/* - We will refer to the arguments as f1 and f2.                             */
X/* - If there is a syntax error in either spec, fn_ins does nothing.          */
X/* - Otherwise, it:                                                           */
X/*      1. Analyses the two filename specifications into filename field .     */
X/*      2. Replaces each field in f1 by the corresponding field in f2, but    */
X/*         only if the corresponding field in f2 is non-empty.                */
X/*      3. Optionally [concession to VMS] it may then replace blank fields    */
X/*         in the resulting file spec in f1 by fields from the current        */
X/*         global "default" directory spec.                                   */
X/* The structure and fields of filenames will vary from machine to machine    */
X/* and so this is not important. However, every implementation must structure */
X/* the filename so that it will at least RECOGNISE a file extension           */
X/* (e.g. ".lis") field.                                                       */
X
X/******************************************************************************/
X
XEXPORT void getcline P_((int,char **,char *));
X/* Operating system environments vary a lot in the way in which their command */
X/* language interfaces are set up. The approach taken in FunnelWeb is to      */
X/* define a "standard" Unix-like command line syntax and then insist that     */
X/* other environments deliver such a command line as a single string.         */
X/* This function getcline must extract such a standard command line from its  */
X/* environment and copy it as a single string of not more than COMLINE_MAX    */
X/* characters into its third argument. A description of the "standard"        */
X/* command line can be found in the options package.                          */
X/* The first  argument is given to getcline and is argc from main().          */
X/* The second argument is given to getcline and is argv from main().          */
X/* These two arguments are given in case getcline needs them to assemble the  */
X/* command line (as opposed to calling e.g. VMS CLI routines).                */
X/* The third argument is the string into which the result should be placed.   */
X
X/******************************************************************************/
X
XEXPORT float tim_real P_((void));
X/* Returns the number of seconds between the present and an unspecified, but  */
X/* statically fixed time in the past.                                         */
X/* Returns 0.0 if this information is unavailable                             */
X
XEXPORT float tim_cpu P_((void));
X/* Returns the number of CPU seconds consumed between the present and an      */
X/* unspecified, but statically fixed time in the past.                        */
X/* Returns 0.0 if this information is unavailable                             */
X
X/******************************************************************************/
X
X/* For #ifndef preventing multiple inclusion of the body of this header file. */
X#endif
X
X/******************************************************************************/
X/*                                End of MACHIN.H                             */
X/******************************************************************************/
END_OF_FILE
if test 14389 -ne `wc -c <'sources/machin.h'`; then
    echo shar: \"'sources/machin.h'\" unpacked with wrong size!
fi
# end of 'sources/machin.h'
fi
if test -f 'sources/memory.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sources/memory.c'\"
else
echo shar: Extracting \"'sources/memory.c'\" \(14661 characters\)
sed "s/^X//" >'sources/memory.c' <<'END_OF_FILE'
X/*##############################################################################
X
XFUNNNELWEB COPYRIGHT
X====================
XFunnelWeb is a literate-programming macro preprocessor.
X
Copyright (C) 1992 Ross N. Williams.
X
X   Ross N. Williams
X   ross@spam.adelaide.edu.au
X   16 Lerwick Avenue, Hazelwood Park 5066, Australia.
X
This program is free software; you can redistribute it and/or modify
it under the terms of Version 2 of the GNU General Public License as
published by the Free Software Foundation.
X
This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See Version 2 of the GNU General Public License for more details.
X
You should have received a copy of Version 2 of the GNU General Public
License along with this program. If not, you can FTP the license from
prep.ai.mit.edu/pub/gnu/COPYING-2 or write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Section 2a of the license requires that all changes to this file be
recorded prominently in this file. Please record all changes here.
X
Programmers:
X   RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X
Changes:
X   07-May-1992  RNW  Program prepared for release under GNU GPL V2.
X
X##############################################################################*/
X
X
X/******************************************************************************/
X/*                                  MEMORY.C                                  */
X/******************************************************************************/
X/*                                                                            */
X/* Implementation Overview                                                    */
X/* -----------------------                                                    */
X/* One of the tasks of this Memory Management (MM) package is to keep track   */
X/* of the memory that it has allocated so that it can all be deallocated      */
X/* later, in one go. To do this, the package keeps a linked list whose        */
X/* elements describe the blocks allocated. Two linked lists are kept, one for */
X/* temporary blocks and one for permanent blocks. Only the list for the       */
X/* temporary blocks is used for deallocation. Permanent blocks are arranged   */
X/* in a list so that the code for temporary blocks is also applicable.        */
X/*                                                                            */
X/* In order to avoid many calls to malloc() for small blocks of memory        */
X/* (legend has it that some implementations of malloc() are very slow in this */
X/* case), the MM package keeps a spare temporary and permanent block of       */
X/* length MM_BLOCK from which it allocates small blocks. Small is defined as  */
X/* <=MM_BLOCK/16. A separate malloc call is made for "Large" blocks greater   */
X/* than MM_BLOCK bytes. "Large" blocks less than MM_BLOCK bytes may or may    */
X/* not be allocated from a buffer block, depending on how much space is       */
X/* available. See the code for the full details.                              */
X/*                                                                            */
X/******************************************************************************/
X
X#include "style.h"
X
X#include "as.h"
X#include "machin.h"
X#include "memory.h"
X
X/******************************************************************************/
X
X/* The environ.h file contains a definition for ALIGN_POWER which is the      */
X/* exponent of the power of two corresponding to the machine's alignment      */
X/* requirements. The following two constants convert that constant to more    */
X/* useful forms. These definitions should never need to be changed.           */
X#define ALIGN_SIZE (1L<<ALIGN_POWER)
X#define ALIGN_MASK (ALIGN_SIZE-1)
X
X/* Because standard malloc() can be slow on some systems for large numbers of */
X/* calls requesting small blocks of memory, FunnelWeb's memory management     */
X/* package MM_* allocates memory in sizeable blocks and then allocates        */
X/* smaller blocks from these big blocks without reference to malloc(). The    */
X/* following #define tells the MM package how big the sizeable allocated      */
X/* blocks should be. The rule is then: if the requested block is greater than */
X/* MM_BLOCK/16, allocate it directly using malloc(), otherwise peel off some  */
X/* memory from the latest sizeable block allocated.                           */
X/* In practice, MM_BLOCK should be chosen to be about 1/10 to 1/20 of the     */
X/* memory available to FunnelWeb. The disadvantage of making it big is that   */
X/* when memory is tight, MM will be unable to allocate a full block and about */
X/* half a block of memory will be unusable. The disadvantage of making it too */
X/* small is that the linked lists tracking memory allocations will grow long  */
X/* and it will take a long time to free up memory between invocations of      */
X/* FunnelWeb proper. The value is not critical. A value of 31K should work    */
X/* well on most systems. 31K is chosen instead of 32K just to be on the safe  */
X/* side of 16 bits (so who's paranoid?).                                      */
X#define MM_BLOCK (31L*1024L)
X
X/* This definition provides the definition of the size of a "big" block; that */
X/* is, one that should possibly be treated differently from the others.       */
X/* The rule we use is that a big block is 1/16 of the standard block size.    */
X/* This results in a maximum memory wastage of 1/16 or about 7%.              */
X#define MM_BIG (MM_BLOCK >> 4)
X
X/* Magic numbers help us to detect corruptions. */
X#define MAGIC_HEAD  (83716343L)
X#define MAGIC_TAIL  (11172363L)
X
X/* Set MEMTRACE to TRUE to trace all memory operations. */
X#define MEMTRACE FALSE
X
X/******************************************************************************/
X
X/* The following structures define a type for the linked lists that keep      */
X/* track of the allocated blocks.                                             */
typedef struct mm_t_
X  {
X   ulong         mm_mhead; /* Magic number protecting beginning of record.    */
X   ubyte_       *mm_pblok; /* Pointer to the allocated block.                 */
X   ubyte_       *mm_pfree; /* Pointer to next free byte in block (ALIGNED).   */
X   ulong         mm_nfree; /* Number of unused bytes available in the block.  */
X   struct mm_t_ *mm_pnext; /* Pointer to the header for the next block.       */
X   ulong         mm_mtail; /* Magic number protecting end of record.          */
X  } mm_t;
X
typedef mm_t *p_mm_t;      /* Handy to have a pointer type too.               */
X
X/* The following two local variables point to the head of the temporary and   */
X/* permanent block lists. The first block in each list is that list's buffer. */
LOCVAR p_mm_t p_perm = NULL;
LOCVAR p_mm_t p_temp = NULL;
X
X/******************************************************************************/
X
LOCAL void mm_check P_((p_mm_t));
LOCAL void mm_check(p_mm)
X/* Checks the magic numbers in the specified block header object. */
p_mm_t p_mm;
X{
X as_cold(p_mm!=NULL,"mm_check: Null pointer.");
X as_cold(p_mm->mm_mhead==MAGIC_HEAD,"mm_check: Corrupted header.");
X as_cold(p_mm->mm_mtail==MAGIC_TAIL,"mm_check: Corrupted trailer.");
X}
X
X/******************************************************************************/
X
LOCAL void mm_align P_((p_mm_t));
LOCAL void mm_align(p_mm)
X/* Some machines are very fussy about the memory alignment of allocated       */
X/* objects. To solve this problem, the mm_pfree pointer is always kept at an  */
X/* "aligned" address. This function accepts a pointer to the header of a      */
X/* block whose mm_pfree pointer is possibly unaligned and consumes bytes      */
X/* until mm_pfree is aligned.                                                 */
p_mm_t p_mm;
X{
X ubyte bump;
X ubyte consume;
X
X mm_check(p_mm);
X
X /* Work out how many bytes are sticking out over the alignment boundary. */
X bump = ((ulong) p_mm->mm_pfree) & ALIGN_MASK;
X
X /* Return if the block is already aligned. */
X if (bump==0) return;
X
X /* Otherwise work out how many bytes we have to consume to become realigned. */
X consume=ALIGN_SIZE-bump;
X
X /* If there are not enough bytes left in the block to allow the free pointer */
X /* to be aligned, then simply set the available bytes to zero and return. It */
X /* doesn't matter if we don't achieve alignment in this case as if           */
X /* mm_nfree==0, nothing can ever be allocated at the misaligned address.     */
X if (consume>p_mm->mm_nfree) {p_mm->mm_nfree=0; return;}
X
X /* Consume the bytes required to align the free pointer. */
X p_mm->mm_pfree += consume;
X p_mm->mm_nfree -= consume;
X
X /* Check that we have properly aligned the free pointer. */
X as_cold((((ulong) p_mm->mm_pfree) & ALIGN_MASK)==0,
X         "mm_align: Failed to align.");
X}
X
X/******************************************************************************/
X
LOCAL p_mm_t mm_newblk P_((size_t));
LOCAL p_mm_t mm_newblk(blk_len)
X/* Creates a new block containing (after alignment) at least blk_len bytes.   */
X/* Returns a pointer to the header for the block.                             */
size_t blk_len;
X{
X p_mm_t  p_mm;
X ubyte_ *p_bl;
X
X /* Allocate the header and the block itself. Because we are guaranteeing     */
X /* that the resultant block will have at least blk_len bytes free, we have   */
X /* to take into account alignment and add in ALIGN_SIZE when requesting mem. */
X p_mm=(p_mm_t  ) malloc((size_t)         sizeof(mm_t));
X p_bl=(ubyte_ *) malloc((size_t) (blk_len+ALIGN_SIZE));
X if (p_mm==NULL || p_bl==NULL)
X   {
X    fprintf(stderr,"mm_newblk: Out of memory!\n");
X    fprintf(stderr,"FunnelWeb doesn't cope well when it runs out of memory.\n");
X    fprintf(stderr,"It falls in a heap just as it is about to now.\n");
X    as_bomb("Stand by for an ungraceful termination!");
X   }
X
X /* Fill in the fields of the block header. */
X p_mm->mm_mhead = MAGIC_HEAD;
X p_mm->mm_pblok = p_bl;
X p_mm->mm_pfree = p_bl;
X p_mm->mm_nfree = blk_len+ALIGN_SIZE;
X p_mm->mm_pnext = NULL;
X p_mm->mm_mtail = MAGIC_TAIL;
X
X /* Align the free pointer in the header block. */
X mm_align(p_mm);
X
X /* Return a pointer to the header block we created. */
X return p_mm;
X}
X
X/******************************************************************************/
X
LOCAL p_void mm_alloc P_((p_mm_t *,size_t));
LOCAL p_void mm_alloc(pp_mm,bytes)
X/* 'pp_mm' must be a pointer to either p_perm or p_temp.                      */
X/* 'bytes' is the number of bytes required.                                   */
X/* Allocates the required memory and returns an aligned pointer to it.        */
X/* Bombs the program if the memory is not available.                          */
p_mm_t *pp_mm;
size_t bytes;
X{
X p_mm_t p_from;    /* Pointer to header for block from which we finally alloc.*/
X ubyte_ *p_result; /* The result pointer returned to the caller.              */
X
X /* If the list is empty, create a "buffer block" and put it in the list.     */
X if (*pp_mm==NULL) *pp_mm=mm_newblk((size_t) MM_BLOCK);
X
X /* If there is room in the current buffer block, we can allocate directly.   */
X /* Note that we may be allocating a "big" block here, but as long as it fits */
X /* into the free space of the current buffer block, we don't care.           */
X if ((*pp_mm)->mm_nfree >= bytes) {p_from = *pp_mm; goto dole_out;}
X
X /* At this point we know that there is not enough space in the current       */
X /* buffer block. This could mean that we have an extra big allocation on our */
X /* hands in which case, we should malloc up a block specially for this       */
X /* request. It could also mean that we are running out of space in our       */
X /* buffer block in which case a new one must be allocated.                   */
X if (bytes >= MM_BIG)
X   {
X    /* If the request is BIG, allocate a special block for it and insert the  */
X    /* block in the block list just after the buffer block, leaving the       */
X    /* buffer block the first in the block list.                              */
X    p_mm_t p_tmp=mm_newblk(bytes);
X    p_tmp->mm_pnext=(*pp_mm)->mm_pnext;
X    (*pp_mm)->mm_pnext=p_tmp;
X    p_from=p_tmp;
X   }
X else
X   {
X    /* If the request is not big, our buffer block is probably too empty and  */
X    /* so it is time to create a new one. Allocate a new buffer block and     */
X    /* make it the new head of this block list. Note that by giving up on the */
X    /* previous buffer, we waste at most 1/16 of the block we are giving up   */
X    /* on. This cost is reasonable in exchange for all the speed this gives.  */
X    p_mm_t p_tmp=mm_newblk((size_t) MM_BLOCK);
X    p_tmp->mm_pnext=(*pp_mm);
X    (*pp_mm)=p_tmp;
X    p_from=p_tmp;
X   }
X
X dole_out:
X /* Jump here to dole out 'bytes' bytes from block 'p_from'. */
X p_result=p_from->mm_pfree;
X p_from->mm_pfree += bytes;
X p_from->mm_nfree -= bytes;
X mm_align(p_from);
X
X /* Ensure that the pointer being returned is properly aligned. */
X as_cold((((ulong) p_result) & ALIGN_MASK)==0,
X         "mm_alloc: Result is misaligned.");
X
X /* Return the result. */
X return (p_void) p_result;
X}
X
X/******************************************************************************/
X
XEXPORT p_void mm_perm(bytes)
size_t bytes;
X{
X#if MEMTRACE
X printf("TRACE: mm_perm: Allocating %lu bytes of permanent memory.\n",
X(ulong) bytes);
X#endif
X return mm_alloc(&p_perm,bytes);
X}
X
X/******************************************************************************/
X
XEXPORT p_void mm_temp(bytes)
size_t bytes;
X{
X#if MEMTRACE
X printf("TRACE: mm_temp: Allocating %lu bytes of temporary memory.\n",
X(ulong) bytes);
X#endif
X return mm_alloc(&p_temp,bytes);
X}
X
X/******************************************************************************/
X
XEXPORT void mm_zapt()
X/* This function frees all the memory blocks recorded in the temporary        */
X/* memory list. We choose to free them rather than merely re-using them       */
X/* directly because they may not all be the same size, and we want to give    */
X/* the built-in memory manager a chance to smooth out the heap.               */
X{
X#if MEMTRACE
X printf("TRACE: mm_zapt: Attempting to release all temporary memory.\n");
X#endif
X
X while (p_temp != NULL)
X   {
X    p_mm_t p_mm=p_temp;
X    mm_check(p_temp);
X#if MEMTRACE
X    printf("TRACE: mm_zapt: Deallocating a big chunk of temporary memory.\n");
X#endif
X    free(p_temp->mm_pblok);
X    p_temp=p_temp->mm_pnext;
X    free(p_mm);
X   }
X}
X
X/******************************************************************************/
X/*                             End of MEMORY.C                                */
X/******************************************************************************/
END_OF_FILE
if test 14661 -ne `wc -c <'sources/memory.c'`; then
    echo shar: \"'sources/memory.c'\" unpacked with wrong size!
fi
# end of 'sources/memory.c'
fi
if test -f 'sources/style.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sources/style.h'\"
else
echo shar: Extracting \"'sources/style.h'\" \(13281 characters\)
sed "s/^X//" >'sources/style.h' <<'END_OF_FILE'
X/*##############################################################################
X
XFUNNNELWEB COPYRIGHT
X====================
XFunnelWeb is a literate-programming macro preprocessor.
X
Copyright (C) 1992 Ross N. Williams.
X
X   Ross N. Williams
X   ross@spam.adelaide.edu.au
X   16 Lerwick Avenue, Hazelwood Park 5066, Australia.
X
This program is free software; you can redistribute it and/or modify
it under the terms of Version 2 of the GNU General Public License as
published by the Free Software Foundation.
X
This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See Version 2 of the GNU General Public License for more details.
X
You should have received a copy of Version 2 of the GNU General Public
License along with this program. If not, you can FTP the license from
prep.ai.mit.edu/pub/gnu/COPYING-2 or write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Section 2a of the license requires that all changes to this file be
recorded prominently in this file. Please record all changes here.
X
Programmers:
X   RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X
Changes:
X   07-May-1992  RNW  Program prepared for release under GNU GPL V2.
X
X##############################################################################*/
X
X
X/******************************************************************************/
X/*                                    STYLE.H                                 */
X/******************************************************************************/
X/*                                                                            */
X/* WARNING: DO NOT ADD ANY MACHINE OR PROGRAM DEPENDENT DEFINITIONS.          */
X/*                                                                            */
X/* This style.h file contains program-independent, machine-independent        */
X/* definitions that assist C programming in general. Nothing in this file     */
X/* should require modification if this file is moved to a new machine or used */
X/* in a new computer program. However, it may use abstracted second-order     */
X/* definitions from the machine-dependent, program independent module         */
X/* "environ".                                                                 */
X/*                                                                            */
X/******************************************************************************/
X
X/* Ensure that the body of this header file is included at most once.         */
X#ifndef DONE_STYLE
X#define DONE_STYLE
X
X/******************************************************************************/
X
X/* System File Inclusions                                                     */
X/* ----------------------                                                     */
X/* In order to support a readable programming style, symbols such as TRUE and */
X/* NULL are essential. However, environments differ as to whether and where   */
X/* these symbols are defined. This can lead to multiple definition errors     */
X/* where (say) this style.h file is included in a .C file before <stdlib.h>.  */
X/* I did a quick survey of all the .C FunnelWeb modules and found the         */
X/* following:                                                                 */
X/*                                                                            */
X/*    Total files     = 54                                                    */
X/*    Number .C files = 22                                                    */
X/*    Number .H files = 32                                                    */
X/*    Used <stdlib.h> = 19                                                    */
X/*    Used <stdio.h>  = 16                                                    */
X/*    Used <string.h> = 12                                                    */
X/*    Used <ctype.h>  =  6                                                    */
X/*    Used <stddef.h> =  4                                                    */
X/*    Used <limits.h> =  2                                                    */
X/*    Used <setjmp.h> =  1                                                    */
X/*                                                                            */
X/* Most of these inclusions were in the .C files.                             */
X/* It therefore seemed sensible to include some very commonly used system     */
X/* header files here and header files that cause problems if not included     */
X/* before style.h (<stddef.h>).                                               */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <stddef.h>
X
X/******************************************************************************/
X
X/* Although this file is machine independent, it still needs some generic     */
X/* definitions whose values vary from machine to machine (see above).         */
X#include "environ.h"
X
X/******************************************************************************/
X
X/* The following types provide a clear and consistent collection of names for */
X/* C's arithmetic types. Each name describes only the portable range that the */
X/* underlying type supports. As in C, there are no guarantees about the       */
X/* MAXIMUM size of each underlying type and these types can provide no        */
X/* guarantees either. In the normal case, they translate to the most speed    */
X/* efficient type that will support the specified range. However, to support  */
X/* the situations where space efficiency is required, types ending in         */
X/* underscores have been defined that strive to conserve memory.              */
X/* Note: The signedness of a type does not change when an _ is added.         */
X/*                                                                            */
X/* The following terminology may be a touch vaxcentric, but it works for me.  */
X/*    A BYTE is an  8 bit quantity.                                           */
X/*    A WORD is a  16 bit quantity.                                           */
X/*    A LONG is a  32 bit quantity.                                           */
X
typedef unsigned        ubyte  ; /* Unsigned, [0,255].                        */
typedef unsigned char   ubyte_ ; /* Unsigned, [0,255].         Space first.   */
typedef int             word   ; /* Signed  , [-32767,+32767].                */
typedef short           word_  ; /* Signed  , [-32767,+32767]. Space first.   */
typedef unsigned        uword  ; /* Unsigned, [0,65535].                      */
typedef unsigned short  uword_ ; /* Unsigned, [0,+65535].      Space first.   */
typedef unsigned long   ulong  ; /* Unsigned, [0,(2^32)-1].                   */
X
typedef unsigned        bool   ; /* Unsigned, [0,1].                          */
typedef unsigned char   bool_  ; /* Unsigned, [0,1].           Space first.   */
X
typedef int             sign   ; /* Signed  , [-1,0,1].                       */
X
X/******************************************************************************/
X
X/* C overloads the attribute keyword "static" horribly giving it meaning on   */
X/* both the scoping and lifetime dimensions.  This section gives definitions  */
X/* that clarify its use. If these macros are used, there should be no need    */
X/* for the keyword "static" in programs using this style file.                */
X
X/* The following macros assist in making the scope of functions clearer. In   */
X/* deciding on the names of these macros, I chose from the following lists:   */
X/*    file    scope: PRIVATE, LOCAL, HIDDEN.                                  */
X/*    program scope: EXPORT, PUBLIC, GLOBAL.                                  */
X/* In the end I chose LOCAL and EXPORT. Note: I didn't want to allow more     */
X/* than one form as that would have created too much confusion.               */
X#define LOCAL  static
X#define EXPORT
X
X/* It is desirable to use separate keywords for variables. This makes it      */
X/* easier to search for them without stopping at every function. There are    */
X/* four classes of variable that we wish to tag, along the two dimensions     */
X/* scope:(local,global) and lifetime:(permanent,temporary). In C, all         */
X/* variables declared outside of functions have permanent lifetime and so     */
X/* the following two names (which should be used only to tag variables not    */
X/* declared within a function) have been designed to emphasise the scope      */
X/* dimension which is the principal concern for these variables.              */
X#define LOCVAR static
X#define GLOVAR
X
X/* Variables local to functions always have local scope and so the dimension  */
X/* to emphasise is the lifetime. Automatic variables are the most common in   */
X/* C and it would be messy to declare them all using a keyword. Far better    */
X/* just to tag static local variables, emphasising their lifetime (STAtic).   */
X#define STAVAR static
X
X/******************************************************************************/
X
X/* The following definitions are useful for dealing with void.                */
X/* The typedefed definition "p_void" should always be used instead of         */
X/* "void *" so as to improve portability.                                     */
X/* The definition of "void" and "p_void" come from environ.h                  */
typedef p_void *p_p_void;
X#define PV     (p_void)
X#define PPV    (p_p_void)
X
X/******************************************************************************/
X
X/* The following symbols are more mnemonic than character escape sequences.   */
X#define EOS '\0'
X#define EOL '\n'
X
X/******************************************************************************/
X
X/* The ANSI library functions use many different techniques for returning     */
X/* status information. For example, fopen returns NULL upon failure, but      */
X/* fclose returns EOF upon failure. The result is that it is hard to          */
X/* proofread calls to these routines without constantly referring to the      */
X/* library manual. To avoid this problem, we define symbols with helpful      */
X/* names for the different values returned. This makes the code obvious.      */
X
X/* 07-Feb-1992: During porting I ran into a problem here with FPUTS_S. I had  */
X/* defined it to be zero, as stated in the THINK C V4 ANSI library guide.     */
X/* However, it turned out that fputs() returns EOF (-1) on failure and the    */
X/* value that it returns on success is non negative! (See ANSI (7.9.7.4)).    */
X/* Caught by an overspecification by the THINK C people! The lesson is that   */
X/* it is very important to make sure that each function's status check symbol */
X/* is defined on the "right" side (success or failure) - that is, the side    */
X/* for which a single value for that status is guaranteed portably.           */
X/* The following values have all been checked for this.                       */
X
X/* Note: _F=Failure, _S=Success, _FE=Failure or End of File.                  */
X
X#define FOPEN_F  (NULL)
X#define FSEEK_S     (0)
X#define FTELL_F   (-1L)
X#define FGETC_FE  (EOF)
X#define FGETS_FE (NULL)
X#define FPUTC_F   (EOF)
X#define FPUTS_F   (EOF)
X#define FFLUSH_S    (0)
X#define FCLOSE_F  (EOF)
X#define REMOVE_S    (0)
X#define RENAME_S    (0)
X#define MALLOC_F (NULL)
X
X/******************************************************************************/
X
X/* The following macro functions are handy. However, be sure not to hand them */
X/* an argument with a non-idempotent side effect!!! (e.g. MAX(a++,b)).        */
X#define MIN(A,B) ((A)<(B) ? (A) : (B))
X#define MAX(A,B) ((A)>(B) ? (A) : (B))
X
X/******************************************************************************/
X
X/* Some environments don't define some stuff we need so we do it here.        */
X/* Cautiously!                                                                */
X
X#ifndef FALSE
X#define FALSE (0)
X#endif
X
X#ifndef TRUE
X#define TRUE (1)
X#endif
X
X#ifndef EXIT_FAILURE
X#define EXIT_FAILURE (-1)
X#endif
X
X#ifndef EXIT_SUCCESS
X#define EXIT_SUCCESS (0)
X#endif
X
X/******************************************************************************/
X
X/* The standard library macro/function "isprint" can be too loose in some     */
X/* circumstances on some machines and it is convenient to define a macro      */
X/* that provides a more strict 7-bit ASCII definition of "printable".         */
X#define isascprn(ch) ((' '<=ch) && (ch<='~'))
X
X/******************************************************************************/
X
X/* Some compilers (GCC at least) complain about characters as a type in a     */
X/* function argument. The following typedef is a quick hack that lets me say  */
X/* that I really wanted the function argument to be a character, while        */
X/* actually supplying an integer.                                             */
typedef int intchar;
X
X/******************************************************************************/
X/* For #ifndef preventing multiple inclusion of the body of this header file. */
X#endif
X
X/******************************************************************************/
X/*                                End of STYLE.H                              */
X/******************************************************************************/
X
END_OF_FILE
if test 13281 -ne `wc -c <'sources/style.h'`; then
    echo shar: \"'sources/style.h'\" unpacked with wrong size!
fi
# end of 'sources/style.h'
fi
echo shar: End of archive 6 \(of 20\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 20 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
