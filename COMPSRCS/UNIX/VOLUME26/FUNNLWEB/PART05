Newsgroups: comp.sources.unix
From: ross@spam.adelaide.edu.au (Ross Williams)
Subject: v26i125: funnelweb - a tool for literate programming in C, Part05/20
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: ross@spam.adelaide.edu.au (Ross Williams)
Posting-Number: Volume 26, Issue 125
Archive-Name: funnelweb/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 20)."
# Contents:  answers/pr10.lis answers/sc18.lis sources/analyse.c
#   sources/environ.h sources/list.h sources/lister.c sources/machin.c
#   sources/texhead.tex sources/writfile.h userman/u_manual.toc
# Wrapped by vixie@gw.home.vix.com on Sun Apr 11 11:00:16 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'answers/pr10.lis' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'answers/pr10.lis'\"
else
echo shar: Extracting \"'answers/pr10.lis'\" \(12685 characters\)
sed "s/^X//" >'answers/pr10.lis' <<'END_OF_FILE'
XFUNNELWEB LISTING FILE
X======================
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 50 52 31 30 3A 20 54 65 73 74 20 73 79 6E 74 61 | PR10: Test synta |
X| 63 74 69 63 20 65 72 72 6F 72 20 72 65 63 6F 76 | ctic error recov |
X| 65 72 79 2E 0A 0A 31 2E 20 54 65 73 74 20 72 65 | ery...1. Test re |
X| 63 6F 76 65 72 79 20 61 74 20 74 6F 70 20 70 61 | covery at top pa |
X| 72 73 69 6E 67 20 6C 65 76 65 6C 2E 0A 40 3C 0A | rsing level..@<. |
X| 0A 40 41 40 3C 45 72 72 6F 72 20 72 65 63 6F 76 | .@A@<Error recov |
X| 65 72 79 20 70 6F 69 6E 74 40 3E 0A 0A 32 2E 20 | ery point@>..2.  |
X| 54 65 73 74 20 72 65 63 6F 76 65 72 79 20 69 6E | Test recovery in |
X| 73 69 64 65 20 6D 61 63 72 6F 20 64 65 66 69 6E | side macro defin |
X| 69 74 69 6F 6E 2E 0A 0A 40 24 40 3C 53 6C 6F 74 | ition...@$@<Slot |
X| 68 31 40 3E 40 3E 3D 3D 40 7B 0A 57 61 6C 72 75 | h1@>@>==@{.Walru |
X| 73 40 7D 0A 0A 40 24 40 3C 53 6C 6F 74 68 32 40 | s@}..@$@<Sloth2@ |
X| 3E 3D 3D 40 7B 0A 40 3C 57 61 6C 72 75 73 40 3C | >==@{.@<Walrus@< |
X| 0A 40 7D 0A 40 41 40 3C 45 72 72 6F 72 20 72 65 | .@}.@A@<Error re |
X| 63 6F 76 65 72 79 20 70 6F 69 6E 74 40 3E 0A 0A | covery point@>.. |
X| 33 2E 20 54 65 73 74 20 72 65 63 6F 76 65 72 79 | 3. Test recovery |
X| 20 69 6E 73 69 64 65 20 61 63 74 75 61 6C 20 70 |  inside actual p |
X| 61 72 61 6D 65 74 65 72 20 6C 69 73 74 20 69 6E | arameter list in |
X| 20 6D 61 63 72 6F 20 64 65 66 69 6E 69 74 69 6F |  macro definitio |
X| 6E 2E 0A 40 24 40 3C 53 6C 6F 74 68 33 40 3E 3D | n..@$@<Sloth3@>= |
X| 3D 40 7B 0A 40 3C 57 61 6C 72 75 73 40 3E 40 28 | =@{.@<Walrus@>@( |
X| 40 22 61 61 72 64 76 61 72 6B 40 3E 0A 40 7D 0A | @"aardvark@>.@}. |
X| 40 41 40 3C 45 72 72 6F 72 20 72 65 63 6F 76 65 | @A@<Error recove |
X| 72 79 20 70 6F 69 6E 74 40 3E 0A 0A 34 2E 20 54 | ry point@>..4. T |
X| 65 73 74 20 45 4F 46 20 69 6E 20 74 68 65 20 6D | est EOF in the m |
X| 69 64 64 6C 65 20 6F 66 20 61 20 63 6F 6D 70 6C | iddle of a compl |
X| 69 63 61 74 65 64 20 63 6F 6E 73 74 72 75 63 74 | icated construct |
X| 2E 0A 54 68 65 20 66 6F 6C 6C 6F 77 69 6E 67 20 | ..The following  |
X| 6D 61 6B 65 73 20 74 68 65 20 65 6E 64 20 6F 66 | makes the end of |
X| 20 74 68 65 20 66 69 6C 65 20 6C 6F 6F 6B 65 64 |  the file looked |
X| 20 63 68 6F 70 70 65 64 20 6F 66 66 2C 20 62 75 |  chopped off, bu |
X| 74 20 69 74 20 69 73 0A 61 63 74 75 61 6C 6C 79 | t it is.actually |
X| 20 69 6E 74 65 6E 74 69 6F 6E 61 6C 2E 0A 40 24 |  intentional..@$ |
X| 40 3C 53 6C 6F 74 68 34 40 3E 3D 3D 40 7B 0A 40 | @<Sloth4@>==@{.@ |
X| 3C 57 61 6C 72 75 73 40 3E 40 28 40 22 61 61 72 | <Walrus@>@(@"aar |
X| 64 76 61 0A                                     | dva.             |
X+-------------------------------------------------+------------------+
X
X
X=========================== Start of LINE LIST DUMP ============================
X
Globl Local| Text
X-----------+--------------------------------------------------------------------
X00001 00001| PR10: Test syntactic error recovery.<010>
X00002 00002| <010>
X00003 00003| 1. Test recovery at top parsing level.<010>
X00004 00004| @<<010>
X00005 00005| <010>
X00006 00006| @A@<Error recovery point@><010>
X00007 00007| <010>
X00008 00008| 2. Test recovery inside macro definition.<010>
X00009 00009| <010>
X00010 00010| @$@<Sloth1@>@>==@{<010>
X00011 00011| Walrus@}<010>
X00012 00012| <010>
X00013 00013| @$@<Sloth2@>==@{<010>
X00014 00014| @<Walrus@<<010>
X00015 00015| @}<010>
X00016 00016| @A@<Error recovery point@><010>
X00017 00017| <010>
X00018 00018| 3. Test recovery inside actual parameter list in macro definition.<010>
X00019 00019| @$@<Sloth3@>==@{<010>
X00020 00020| @<Walrus@>@(@"aardvark@><010>
X00021 00021| @}<010>
X00022 00022| @A@<Error recovery point@><010>
X00023 00023| <010>
X00024 00024| 4. Test EOF in the middle of a complicated construct.<010>
X00025 00025| The following makes the end of the file looked chopped off, but it is<010>
X00026 00026| actually intentional.<010>
X00027 00027| @$@<Sloth4@>==@{<010>
X00028 00028| @<Walrus@>@(@"aardva<010>
X00029 00029| <End-Of-File><010>
X-----------+--------------------------------------------------------------------
Globl Local| Text
X
X============================ End of LINE LIST DUMP =============================
X
X
X=========================== Start of TOKEN LIST DUMP ===========================
X
Summary: There are 72 tokens in the token list.
X
Line[Column]: Token Description
X-------------------------------
X
X0001[01]: Text. Text scrap[Grey]="PR10: Test syntactic error recovery.<010>
X<010>
X1. Test recovery at top parsing level.<010>
X"
X0004[01]: @< Open name. 
X0004[03]: Text. Text scrap[White]="<010>
X<010>
X"
X0006[01]: @A New section (Level 1). 
X0006[03]: @< Open name. 
X0006[05]: Text. Text scrap[Grey]="Error recovery point"
X0006[25]: @> Close name. 
X0006[27]: Text. Text scrap[Grey]="<010>
X<010>
X2. Test recovery inside macro definition.<010>
X<010>
X"
X0010[01]: @$ Macro defn. 
X0010[03]: @< Open name. 
X0010[05]: Text. Text scrap[Grey]="Sloth1"
X0010[11]: @> Close name. 
X0010[13]: @> Close name. 
X0010[15]: Text. Text scrap[Grey]="=="
X0010[17]: @{ Open defn. 
X0010[19]: Text. Text scrap[Grey]="<010>
Walrus"
X0011[07]: @} Close defn. 
X0011[09]: Text. Text scrap[White]="<010>
X<010>
X"
X0013[01]: @$ Macro defn. 
X0013[03]: @< Open name. 
X0013[05]: Text. Text scrap[Grey]="Sloth2"
X0013[11]: @> Close name. 
X0013[13]: Text. Text scrap[Grey]="=="
X0013[15]: @{ Open defn. 
X0013[17]: Text. Text scrap[White]="<010>
X"
X0014[01]: @< Open name. 
X0014[03]: Text. Text scrap[Grey]="Walrus"
X0014[09]: @< Open name. 
X0014[11]: Text. Text scrap[White]="<010>
X"
X0015[01]: @} Close defn. 
X0015[03]: Text. Text scrap[White]="<010>
X"
X0016[01]: @A New section (Level 1). 
X0016[03]: @< Open name. 
X0016[05]: Text. Text scrap[Grey]="Error recovery point"
X0016[25]: @> Close name. 
X0016[27]: Text. Text scrap[Grey]="<010>
X<010>
X3. Test recovery inside actual parameter list in macro definition.<010>
X"
X0019[01]: @$ Macro defn. 
X0019[03]: @< Open name. 
X0019[05]: Text. Text scrap[Grey]="Sloth3"
X0019[11]: @> Close name. 
X0019[13]: Text. Text scrap[Grey]="=="
X0019[15]: @{ Open defn. 
X0019[17]: Text. Text scrap[White]="<010>
X"
X0020[01]: @< Open name. 
X0020[03]: Text. Text scrap[Grey]="Walrus"
X0020[09]: @> Close name. 
X0020[11]: @( Open param. 
X0020[13]: @" Quote. 
X0020[15]: Text. Text scrap[Grey]="aardvark"
X0020[23]: @> Close name. 
X0020[25]: Text. Text scrap[White]="<010>
X"
X0021[01]: @} Close defn. 
X0021[03]: Text. Text scrap[White]="<010>
X"
X0022[01]: @A New section (Level 1). 
X0022[03]: @< Open name. 
X0022[05]: Text. Text scrap[Grey]="Error recovery point"
X0022[25]: @> Close name. 
X0022[27]: Text. Text scrap[Grey]="<010>
X<010>
X4. Test EOF in the middle of a complicated construct.<010>
The following makes the end of the file looked chopped off, but it is<010>
actually intentional.<010>
X"
X0027[01]: @$ Macro defn. 
X0027[03]: @< Open name. 
X0027[05]: Text. Text scrap[Grey]="Sloth4"
X0027[11]: @> Close name. 
X0027[13]: Text. Text scrap[Grey]="=="
X0027[15]: @{ Open defn. 
X0027[17]: Text. Text scrap[White]="<010>
X"
X0028[01]: @< Open name. 
X0028[03]: Text. Text scrap[Grey]="Walrus"
X0028[09]: @> Close name. 
X0028[11]: @( Open param. 
X0028[13]: @" Quote. 
X0028[15]: Text. Text scrap[Grey]="aardva<010>
X"
X0029[01]: End Of File. 
X============================ End of TOKEN LIST DUMP ============================
X
X
X========================== Start of MACRO TABLE DUMP ===========================
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth1"
Defined?    : Yes.
Parameters  : 0
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 0 body parts.
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth2"
Defined?    : Yes.
Parameters  : 0
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 0 body parts.
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth3"
Defined?    : Yes.
Parameters  : 0
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 0 body parts.
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth4"
Defined?    : Yes.
Parameters  : 0
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 0 body parts.
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X=========================== End of MACRO TABLE DUMP ============================
X
X
X========================= Start of DOCUMENT LIST DUMP ==========================
X
X
TEXT COMPONENT: Pos(L,C)=(1,1). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="PR10: Test syntactic error recovery.<010>
X<010>
X1. Test recovery at top parsing level.<010>
X"
X--- End of Text Scrap List ---
X
X
TEXT COMPONENT: Pos(L,C)=(4,3). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "1", Section name="Error recovery point".
X
TEXT COMPONENT: Pos(L,C)=(6,27). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="<010>
X<010>
X2. Test recovery inside macro definition.<010>
X<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "2", Section name="Error recovery point".
X
TEXT COMPONENT: Pos(L,C)=(16,27). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="<010>
X<010>
X3. Test recovery inside actual parameter list in macro definition.<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "3", Section name="Error recovery point".
X
TEXT COMPONENT: Pos(L,C)=(22,27). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="<010>
X<010>
X4. Test EOF in the middle of a complicated construct.<010>
The following makes the end of the file looked chopped off, but it is<010>
actually intentional.<010>
X"
X--- End of Text Scrap List ---
X
X
X========================== End of DOCUMENT LIST DUMP ===========================
X
X
Global Local| Input File
X------------+-------------------------------------------------------------------
X     1     1| PR10: Test syntactic error recovery.
X     2     2| 
X     3     3| 1. Test recovery at top parsing level.
X     4     4| @<
X       Error|.^The parser was at the top level and was expecting
X            |.^one of: {Directive, Text, Macro definition, EOF}.
X     5     5| 
X     6     6| @A@<Error recovery point@>
X     7     7| 
X     8     8| 2. Test recovery inside macro definition.
X     9     9| 
X    10    10| @$@<Sloth1@>@>==@{
X       Error|.............^Expecting '@{'.
X            |.............^Skipping after error to the next major construct...
X    11    11| Walrus@}
X    12    12| 
X    13    13| @$@<Sloth2@>==@{
X            |.^...skipped to here after the error.
X    14    14| @<Walrus@<
X       Error|.........^Illegal character or symbol in name.
X            |.........^Skipping after error to the next major construct...
X    15    15| @}
X    16    16| @A@<Error recovery point@>
X            |.^...skipped to here after the error.
X    17    17| 
X    18    18| 3. Test recovery inside actual parameter list in macro definition.
X    19    19| @$@<Sloth3@>==@{
X    20    20| @<Walrus@>@(@"aardvark@>
X       Error|.......................^Expecting '@"'.
X            |.......................^Skipping after error to the next major construct...
X    21    21| @}
X    22    22| @A@<Error recovery point@>
X            |.^...skipped to here after the error.
X    23    23| 
X    24    24| 4. Test EOF in the middle of a complicated construct.
X    25    25| The following makes the end of the file looked chopped off, but it is
X    26    26| actually intentional.
X    27    27| @$@<Sloth4@>==@{
X    28    28| @<Walrus@>@(@"aardva
X            | <End-Of-File>
X       Error|.^Expecting '@"'.
X            |.^Skipping after error to the next major construct...
X            |.^...skipped to here after the error.
X------------+-------------------------------------------------------------------
X
There were 5 Errors.
END_OF_FILE
if test 12685 -ne `wc -c <'answers/pr10.lis'`; then
    echo shar: \"'answers/pr10.lis'\" unpacked with wrong size!
fi
# end of 'answers/pr10.lis'
fi
if test -f 'answers/sc18.lis' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'answers/sc18.lis'\"
else
echo shar: Extracting \"'answers/sc18.lis'\" \(11098 characters\)
sed "s/^X//" >'answers/sc18.lis' <<'END_OF_FILE'
XFUNNELWEB LISTING FILE
X======================
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 31 38 3A 20 54 65 73 74 20 3C 73 70 65 63 | SC18: Test <spec |
X| 69 61 6C 3E 23 3D 0A 0A 46 69 72 73 74 20 77 65 | ial>#=..First we |
X| 20 74 72 69 70 20 75 70 20 74 68 65 20 73 63 61 |  trip up the sca |
X| 6E 6E 65 72 20 73 6F 20 6E 6F 20 66 75 72 74 68 | nner so no furth |
X| 65 72 20 70 61 73 73 65 73 20 74 61 6B 65 20 70 | er passes take p |
X| 6C 61 63 65 2E 0A 0A 40 0A 0A 31 2E 20 54 65 73 | lace...@..1. Tes |
X| 74 20 77 69 74 68 20 61 6C 6C 20 70 6F 73 73 69 | t with all possi |
X| 62 6C 65 20 70 72 69 6E 74 61 62 6C 65 20 63 68 | ble printable ch |
X| 61 72 61 63 74 65 72 73 2E 0A 0A 40 3D 21 20 21 | aracters...@=! ! |
X| 3D 22 20 22 3D 23 20 23 3D 24 20 24 3D 25 20 25 | =" "=# #=$ $=% % |
X| 3D 26 20 26 3D 27 20 27 3D 28 20 28 3D 29 20 29 | =& &=' '=( (=) ) |
X| 3D 2A 20 2A 3D 2B 20 2B 3D 2C 20 2C 3D 2D 20 2D | =* *=+ +=, ,=- - |
X| 3D 2E 20 2E 3D 2F 0A 2F 3D 30 20 30 3D 31 20 31 | =. .=/./=0 0=1 1 |
X| 3D 32 20 32 3D 33 20 33 3D 34 20 34 3D 35 20 35 | =2 2=3 3=4 4=5 5 |
X| 3D 36 20 36 3D 37 20 37 3D 38 20 38 3D 39 20 39 | =6 6=7 7=8 8=9 9 |
X| 3D 3A 20 3A 3D 3B 20 3B 3D 3C 20 3C 3D 3D 20 3D | =: :=; ;=< <== = |
X| 3D 3E 0A 3E 3D 3F 20 3F 3D 40 20 40 3D 41 20 41 | =>.>=? ?=@ @=A A |
X| 3D 42 20 42 3D 43 20 43 3D 44 20 44 3D 45 20 45 | =B B=C C=D D=E E |
X| 3D 46 20 46 3D 47 20 47 3D 48 20 48 3D 49 20 49 | =F F=G G=H H=I I |
X| 3D 4A 20 4A 3D 4B 20 4B 3D 4C 20 4C 3D 4D 0A 4D | =J J=K K=L L=M.M |
X| 3D 4E 20 4E 3D 4F 20 4F 3D 50 20 50 3D 51 20 51 | =N N=O O=P P=Q Q |
X| 3D 52 20 52 3D 53 20 53 3D 54 20 54 3D 55 20 55 | =R R=S S=T T=U U |
X| 3D 56 20 56 3D 57 20 57 3D 58 20 58 3D 59 20 59 | =V V=W W=X X=Y Y |
X| 3D 5A 20 5A 3D 5B 20 5B 3D 5C 0A 5C 3D 5D 20 5D | =Z Z=[ [=\.\=] ] |
X| 3D 5E 20 5E 3D 5F 20 5F 3D 60 20 60 3D 61 20 61 | =^ ^=_ _=` `=a a |
X| 3D 62 20 62 3D 63 20 63 3D 64 20 64 3D 65 20 65 | =b b=c c=d d=e e |
X| 3D 66 20 66 3D 67 20 67 3D 68 20 68 3D 69 20 69 | =f f=g g=h h=i i |
X| 3D 6A 20 6A 3D 6B 0A 6B 3D 6C 20 6C 3D 6D 20 6D | =j j=k.k=l l=m m |
X| 3D 6E 20 6E 3D 6F 20 6F 3D 70 20 70 3D 71 20 71 | =n n=o o=p p=q q |
X| 3D 72 20 72 3D 73 20 73 3D 74 20 74 3D 75 20 75 | =r r=s s=t t=u u |
X| 3D 76 20 76 3D 77 20 77 3D 78 20 78 3D 79 20 79 | =v v=w w=x x=y y |
X| 3D 7A 0A 7A 3D 7B 20 7B 3D 7C 20 7C 3D 7D 20 7D | =z.z={ {=| |=} } |
X| 3D 7E 20 7E 3D 40 0A 0A 32 2E 20 54 65 73 74 20 | =~ ~=@..2. Test  |
X| 74 68 61 74 20 3C 73 70 65 63 69 61 6C 3E 3D 3C | that <special>=< |
X| 73 70 61 63 65 3E 20 69 73 20 66 6C 61 67 67 65 | space> is flagge |
X| 64 20 61 73 20 61 6E 20 65 72 72 6F 72 2E 0A 0A | d as an error... |
X| 20 20 20 40 3D 20 20 20 20 20 40 21 20 53 68 6F |    @=     @! Sho |
X| 75 6C 64 20 62 65 20 66 6C 61 67 67 65 64 20 61 | uld be flagged a |
X| 73 20 61 6E 20 65 72 72 6F 72 2E 0A 0A 33 2E 20 | s an error...3.  |
X| 54 65 73 74 20 74 68 61 74 20 3C 73 70 65 63 69 | Test that <speci |
X| 61 6C 3E 3D 45 4F 4C 20 69 73 20 66 6C 61 67 67 | al>=EOL is flagg |
X| 65 64 20 61 73 20 61 6E 20 65 72 72 6F 72 2E 0A | ed as an error.. |
X| 0A 20 20 20 40 3D 0A 0A                         | .   @=..         |
X+-------------------------------------------------+------------------+
X
X
X=========================== Start of LINE LIST DUMP ============================
X
Globl Local| Text
X-----------+--------------------------------------------------------------------
X00001 00001| SC18: Test <special>#=<010>
X00002 00002| <010>
X00003 00003| First we trip up the scanner so no further passes take place.<010>
X00004 00004| <010>
X00005 00005| @<010>
X00006 00006| <010>
X00007 00007| 1. Test with all possible printable characters.<010>
X00008 00008| <010>
X00009 00009| @=! !=" "=# #=$ $=% %=& &=' '=( (=) )=* *=+ +=, ,=- -=. .=/<010>
X00010 00010| /=0 0=1 1=2 2=3 3=4 4=5 5=6 6=7 7=8 8=9 9=: :=; ;=< <== ==><010>
X00011 00011| >=? ?=@ @=A A=B B=C C=D D=E E=F F=G G=H H=I I=J J=K K=L L=M<010>
X00012 00012| M=N N=O O=P P=Q Q=R R=S S=T T=U U=V V=W W=X X=Y Y=Z Z=[ [=\<010>
X00013 00013| \=] ]=^ ^=_ _=` `=a a=b b=c c=d d=e e=f f=g g=h h=i i=j j=k<010>
X00014 00014| k=l l=m m=n n=o o=p p=q q=r r=s s=t t=u u=v v=w w=x x=y y=z<010>
X00015 00015| z={ {=| |=} }=~ ~=@<010>
X00016 00016| <010>
X00017 00017| 2. Test that <special>=<space> is flagged as an error.<010>
X00018 00018| <010>
X00019 00019|    @=     @! Should be flagged as an error.<010>
X00020 00020| <010>
X00021 00021| 3. Test that <special>=EOL is flagged as an error.<010>
X00022 00022| <010>
X00023 00023|    @=<010>
X00024 00024| <010>
X00025 00025| <End-Of-File><010>
X-----------+--------------------------------------------------------------------
Globl Local| Text
X
X============================ End of LINE LIST DUMP =============================
X
X
X=========================== Start of TOKEN LIST DUMP ===========================
X
Summary: There are 101 tokens in the token list.
X
Line[Column]: Token Description
X-------------------------------
X
X0001[01]: Text. Text scrap[Grey]="SC18: Test <special>#=<010>
X<010>
XFirst we trip up the scanner so no further passes take place.<010>
X<010>
X"
X0006[01]: Text. Text scrap[Grey]="<010>
X1. Test with all possible printable characters.<010>
X<010>
X"
X0009[04]: Text. Text scrap[White]=" "
X0009[08]: Text. Text scrap[White]=" "
X0009[12]: Text. Text scrap[White]=" "
X0009[16]: Text. Text scrap[White]=" "
X0009[20]: Text. Text scrap[White]=" "
X0009[24]: Text. Text scrap[White]=" "
X0009[28]: Text. Text scrap[White]=" "
X0009[32]: Text. Text scrap[White]=" "
X0009[36]: Text. Text scrap[White]=" "
X0009[40]: Text. Text scrap[White]=" "
X0009[44]: Text. Text scrap[White]=" "
X0009[48]: Text. Text scrap[White]=" "
X0009[52]: Text. Text scrap[White]=" "
X0009[56]: Text. Text scrap[White]=" "
X0009[60]: Text. Text scrap[White]="<010>
X"
X0010[04]: Text. Text scrap[White]=" "
X0010[08]: Text. Text scrap[White]=" "
X0010[12]: Text. Text scrap[White]=" "
X0010[16]: Text. Text scrap[White]=" "
X0010[20]: Text. Text scrap[White]=" "
X0010[24]: Text. Text scrap[White]=" "
X0010[28]: Text. Text scrap[White]=" "
X0010[32]: Text. Text scrap[White]=" "
X0010[36]: Text. Text scrap[White]=" "
X0010[40]: Text. Text scrap[White]=" "
X0010[44]: Text. Text scrap[White]=" "
X0010[48]: Text. Text scrap[White]=" "
X0010[52]: Text. Text scrap[White]=" "
X0010[56]: Text. Text scrap[White]=" "
X0010[60]: Text. Text scrap[White]="<010>
X"
X0011[04]: Text. Text scrap[White]=" "
X0011[08]: Text. Text scrap[White]=" "
X0011[12]: Text. Text scrap[White]=" "
X0011[16]: Text. Text scrap[White]=" "
X0011[20]: Text. Text scrap[White]=" "
X0011[24]: Text. Text scrap[White]=" "
X0011[28]: Text. Text scrap[White]=" "
X0011[32]: Text. Text scrap[White]=" "
X0011[36]: Text. Text scrap[White]=" "
X0011[40]: Text. Text scrap[White]=" "
X0011[44]: Text. Text scrap[White]=" "
X0011[48]: Text. Text scrap[White]=" "
X0011[52]: Text. Text scrap[White]=" "
X0011[56]: Text. Text scrap[White]=" "
X0011[60]: Text. Text scrap[White]="<010>
X"
X0012[04]: Text. Text scrap[White]=" "
X0012[08]: Text. Text scrap[White]=" "
X0012[12]: Text. Text scrap[White]=" "
X0012[16]: Text. Text scrap[White]=" "
X0012[20]: Text. Text scrap[White]=" "
X0012[24]: Text. Text scrap[White]=" "
X0012[28]: Text. Text scrap[White]=" "
X0012[32]: Text. Text scrap[White]=" "
X0012[36]: Text. Text scrap[White]=" "
X0012[40]: Text. Text scrap[White]=" "
X0012[44]: Text. Text scrap[White]=" "
X0012[48]: Text. Text scrap[White]=" "
X0012[52]: Text. Text scrap[White]=" "
X0012[56]: Text. Text scrap[White]=" "
X0012[60]: Text. Text scrap[White]="<010>
X"
X0013[04]: Text. Text scrap[White]=" "
X0013[08]: Text. Text scrap[White]=" "
X0013[12]: Text. Text scrap[White]=" "
X0013[16]: Text. Text scrap[White]=" "
X0013[20]: Text. Text scrap[White]=" "
X0013[24]: Text. Text scrap[White]=" "
X0013[28]: Text. Text scrap[White]=" "
X0013[32]: Text. Text scrap[White]=" "
X0013[36]: Text. Text scrap[White]=" "
X0013[40]: Text. Text scrap[White]=" "
X0013[44]: Text. Text scrap[White]=" "
X0013[48]: Text. Text scrap[White]=" "
X0013[52]: Text. Text scrap[White]=" "
X0013[56]: Text. Text scrap[White]=" "
X0013[60]: Text. Text scrap[White]="<010>
X"
X0014[04]: Text. Text scrap[White]=" "
X0014[08]: Text. Text scrap[White]=" "
X0014[12]: Text. Text scrap[White]=" "
X0014[16]: Text. Text scrap[White]=" "
X0014[20]: Text. Text scrap[White]=" "
X0014[24]: Text. Text scrap[White]=" "
X0014[28]: Text. Text scrap[White]=" "
X0014[32]: Text. Text scrap[White]=" "
X0014[36]: Text. Text scrap[White]=" "
X0014[40]: Text. Text scrap[White]=" "
X0014[44]: Text. Text scrap[White]=" "
X0014[48]: Text. Text scrap[White]=" "
X0014[52]: Text. Text scrap[White]=" "
X0014[56]: Text. Text scrap[White]=" "
X0014[60]: Text. Text scrap[White]="<010>
X"
X0015[04]: Text. Text scrap[White]=" "
X0015[08]: Text. Text scrap[White]=" "
X0015[12]: Text. Text scrap[White]=" "
X0015[16]: Text. Text scrap[White]=" "
X0015[20]: Text. Text scrap[Grey]="<010>
X<010>
X2. Test that <special>=<space> is flagged as an error.<010>
X<010>
X   "
X0019[07]: Text. Text scrap[White]="    "
X0020[01]: Text. Text scrap[Grey]="<010>
X3. Test that <special>=EOL is flagged as an error.<010>
X<010>
X   "
X0024[01]: Text. Text scrap[White]="<010>
X"
X0025[01]: End Of File. 
X============================ End of TOKEN LIST DUMP ============================
X
Macro table dump skipped (Parser was not invoked).
Document list dump skipped (Parser was not invoked).
X
Global Local| Input File
X------------+-------------------------------------------------------------------
X     1     1| SC18: Test <special>#=
X     2     2| 
X     3     3| First we trip up the scanner so no further passes take place.
X     4     4| 
X     5     5| @
X       Error|.^<special><endofline> is not a legal special sequence.
X     6     6| 
X     7     7| 1. Test with all possible printable characters.
X     8     8| 
X     9     9| @=! !=" "=# #=$ $=% %=& &=' '=( (=) )=* *=+ +=, ,=- -=. .=/
X    10    10| /=0 0=1 1=2 2=3 3=4 4=5 5=6 6=7 7=8 8=9 9=: :=; ;=< <== ==>
X    11    11| >=? ?=@ @=A A=B B=C C=D D=E E=F F=G G=H H=I I=J J=K K=L L=M
X    12    12| M=N N=O O=P P=Q Q=R R=S S=T T=U U=V V=W W=X X=Y Y=Z Z=[ [=\
X    13    13| \=] ]=^ ^=_ _=` `=a a=b b=c c=d d=e e=f f=g g=h h=i i=j j=k
X    14    14| k=l l=m m=n n=o o=p p=q q=r r=s s=t t=u u=v v=w w=x x=y y=z
X    15    15| z={ {=| |=} }=~ ~=@
X    16    16| 
X    17    17| 2. Test that <special>=<space> is flagged as an error.
X    18    18| 
X    19    19|    @=     @! Should be flagged as an error.
X       Error|....^You cannot set the special character to <space>!
X            |....^Special sequence ignored.
X    20    20| 
X    21    21| 3. Test that <special>=EOL is flagged as an error.
X    22    22| 
X    23    23|    @=
X       Error|....^You cannot set the special character to <endofline>!
X            |....^Special sequence ignored.
X    24    24| 
X            | <End-Of-File>
X------------+-------------------------------------------------------------------
X
There were 3 Errors.
END_OF_FILE
if test 11098 -ne `wc -c <'answers/sc18.lis'`; then
    echo shar: \"'answers/sc18.lis'\" unpacked with wrong size!
fi
# end of 'answers/sc18.lis'
fi
if test -f 'sources/analyse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sources/analyse.c'\"
else
echo shar: Extracting \"'sources/analyse.c'\" \(11750 characters\)
sed "s/^X//" >'sources/analyse.c' <<'END_OF_FILE'
X/*##############################################################################
X
XFUNNNELWEB COPYRIGHT
X====================
XFunnelWeb is a literate-programming macro preprocessor.
X
Copyright (C) 1992 Ross N. Williams.
X
X   Ross N. Williams
X   ross@spam.adelaide.edu.au
X   16 Lerwick Avenue, Hazelwood Park 5066, Australia.
X
This program is free software; you can redistribute it and/or modify
it under the terms of Version 2 of the GNU General Public License as
published by the Free Software Foundation.
X
This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See Version 2 of the GNU General Public License for more details.
X
You should have received a copy of Version 2 of the GNU General Public
License along with this program. If not, you can FTP the license from
prep.ai.mit.edu/pub/gnu/COPYING-2 or write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Section 2a of the license requires that all changes to this file be
recorded prominently in this file. Please record all changes here.
X
Programmers:
X   RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X
Changes:
X   07-May-1992  RNW  Program prepared for release under GNU GPL V2.
X
X##############################################################################*/
X
X
X/******************************************************************************/
X/*                                   ANALYSE.C                                */
X/******************************************************************************/
X
X#include "style.h"
X
X#include "analyse.h"
X#include "as.h"
X#include "data.h"
X#include "lister.h"
X#include "misc.h"
X#include "table.h"
X
X/******************************************************************************/
X
LOCAL void chk_mac P_((p_ma_t));
LOCAL void chk_mac (p_ma)
p_ma_t p_ma;
X{
X mc_t *call;
X
X /* Deal with undefined macros by flagging the first invocation. */
X if (!p_ma->ma_defn.md_isdef)
X   {
X    ls_loo(p_ma->ma_calls,(ulong) 1,PPV &call);
X    as_cold(call!=NULL,"check_macro: No instances of \"undefined\" macro!");
X    lr_err(&call->mc_ps,"Call to undefined macro.");
X    return;
X   }
X
X /* Assert: The macro has a definition. */
X
X /* Check that all the calls to the macro have the correct number of params. */
X ls_fir(p_ma->ma_calls);
X ls_nxt(p_ma->ma_calls,PPV &call);
X while (call!=NULL)
X    {
X     if (call->mc_npar != p_ma->ma_defn.md_npar)
X       {
X        sprintf(linet1,"Call has %lu parameter%s, but the macro",
X                (ulong) call->mc_npar,
X                call->mc_npar==1 ? "" : "s");
X        lr_err(&(call->mc_ps),linet1);
X        sprintf(linet1,"definition at line %lu specifies %lu parameter%s.",
X                (ulong) p_ma->ma_defn.md_ps.ps_line,
X                (ulong) p_ma->ma_defn.md_npar,
X                p_ma->ma_defn.md_npar==1 ? "" : "s");
X        lr_mes(&(call->mc_ps),linet1);
X        if (p_ma->ma_defn.md_npar==0 && call->mc_npar==1)
X          {
X           lr_mes(&(call->mc_ps),"Note: If your call looks like this: @<Macro@>@(@) then you");
X           lr_mes(&(call->mc_ps),"should be aware that FunnelWeb treats this as a call with");
X           lr_mes(&(call->mc_ps),"a single parameter consisting of the empty string. This");
X           lr_mes(&(call->mc_ps),"is a consequence of parameter delimiters @\"@\" being optional.");
X          }
X       }
X     ls_nxt(p_ma->ma_calls,PPV &call);
X    }
X
X /* Check that the number of calls of the macro is legal. */
X if (p_ma->ma_defn.md_isfil)
X   {
X    /* Flag all calls to a file macro as errors. */
X    if (ls_len(p_ma->ma_calls)>0)
X      {
X       lr_mes(&p_ma->ma_defn.md_ps,
X              "This file macro is called one or more times.");
X       lr_mes(&p_ma->ma_defn.md_ps,
X              "Each call has been flagged with an error message.");
X      }
X    ls_fir(p_ma->ma_calls);
X    ls_nxt(p_ma->ma_calls,PPV &call);
X    while (call!=NULL)
X      {
X       lr_err(&(call->mc_ps),"Calls to file macros are not allowed.");
X       lr_mes(&(call->mc_ps),"Reason: It should be possible to comment out a");
X       lr_mes(&(call->mc_ps),"file macro without a big fuss. Calling a file macro");
X       lr_mes(&(call->mc_ps),"just tangles it up in the macro structure,");
X       lr_mes(&(call->mc_ps),"making it more difficult to comment out later.");
X       ls_nxt(p_ma->ma_calls,PPV &call);
X      }
X   }
X else
X   {
X    /* Non-file macros. */
X    if (ls_len(p_ma->ma_calls)==0 && !p_ma->ma_defn.md_iszer)
X       lr_err(&p_ma->ma_defn.md_ps,
X              "This macro is never used (and has no @Z).");
X
X    if (ls_len(p_ma->ma_calls)>1 && !p_ma->ma_defn.md_isman)
X       lr_err(&p_ma->ma_defn.md_ps,
X              "This macro is used more than once (and has no @M).");
X   }
X}
X
X/******************************************************************************/
X
LOCAL void chk_rec P_((void));
LOCAL void chk_rec()
X/* This macro analyses the calls between the macros in the macro              */
X/* table and flags all recursive macros with an error message.                */
X/*                                                                            */
X/* Def: A macro is a "level 0 macro" if it does not call any macros.          */
X/* Def: A macro is a "level n macro" if it calls at least one macro of level  */
X/*      n-1, but does not call any macros of level n or higher.               */
X/* Def: A macro is a "level infinity macro" if it directly or indirectly      */
X/*      calls itself.                                                         */
X/*                                                                            */
X/* This function totally ignores undefined macros. This means that it can be  */
X/* invoked even if problems are detected by the other checks.                 */
X/*                                                                            */
X/* Although the actions of this may seem rather time expensive, they may not  */
X/* be. The function repeatedly runs through the macro table and each macro's  */
X/* bodypart list and expression lists. However, there are not likely to be    */
X/* many macros and each definition expression list is likely to be quite      */
X/* short, as each macro will be mainly text.                                  */
X/* Even if this stuff does take a while, it is better to detect recursion now */
X/* than at tangle time!                                                       */
X{
X p_ma_t p_ma;        /* General purpose pointer to macro.                     */
X name_t dummy_name;  /* Dummy name variable acts as a placeholder in calls.   */
X uword  level;       /* Level of macro currently being tagged.                */
X bool   gotone;      /* TRUE iff current loop iteration tagged >0 macros.     */
X
X/* We need a concrete number to stand for level infinity. */
X/* 30000 is a nice, large 15 bit number.                  */
X#define LEVINF 30000
X
X /* Make sure that our idea of infinity is big enough. */
X as_cold(tb_len(macro_table)<LEVINF,"ana_rec: too many macros.");
X
X /* Tag all the macros as being at level infinity.                            */
X /* This could be done in the parser, but it's neater to do it here.          */
X tb_fir(macro_table);
X while (tb_rea(macro_table,PV dummy_name,PV &p_ma))
X    if (p_ma->ma_defn.md_isdef)
X       p_ma->ma_level=LEVINF;
X
X gotone=TRUE;
X /* Work from level 0 upwards identifying macros of successive levels.        */
X for (level=0; level<LEVINF && gotone; level++)
X   {
X    /* Identify all macros of level 'level'. */
X    /* Gotone tells us if we managed to tag a macro during this iteration. */
X    gotone=FALSE;
X
X    /* Run through table tagging all macros at level 'level'. */
X    tb_fir(macro_table);
X    while (tb_rea(macro_table,PV dummy_name,PV &p_ma))
X      {
X       if (p_ma->ma_defn.md_isdef && p_ma->ma_level == LEVINF)
X         {
X          p_bpls_t p_bpls = p_ma->ma_defn.md_body;
X          /* Run through each body part of the macro. */
X          ls_fir(p_bpls);
X          while (TRUE)
X            {
X             p_bp_t p_bp;
X             ls_nxt(p_bpls,PPV &p_bp);
X             if (p_bp==NULL) break;
X             /* Run through the list of expression elements. */
X             ls_fir(p_bp->bp_ex);
X             while (TRUE)
X               {
X                p_el_t p_el;
X                ls_nxt(p_bp->bp_ex,PPV &p_el);
X                if (p_el==NULL) break;
X                /* Don't tag anything that calls anything that isn't tagged. */
X                if ((p_el->el_kind==EL_INVC          ) &&
X                    (p_el->el_p_mac->ma_defn.md_isdef) &&
X
X    (p_el->el_p_mac->ma_level==LEVINF))
X                   goto nextmacro;
X               }
X            }
X          /* If we got this far, then our macro must have called nothing but  */
X          /* macros of levels [0,level-1]. Thus, we can tag it level 'level'. */
X          p_ma->ma_level=level;
X          gotone=TRUE;
X         } /* End if */
X       nextmacro:;
X      } /* End while */
X   } /* End for loop. */
X
X /* At this point, we have tagged all macros with their level number. Note    */
X /* that level infinity macros are discovered simply because they do not get  */
X /* tagged. The following loop flags all such recursive macros with errors.   */
X tb_fir(macro_table);
X while (tb_rea(macro_table,PV dummy_name,PV &p_ma))
X    if (p_ma->ma_defn.md_isdef && p_ma->ma_level==LEVINF)
X       lr_err(&p_ma->ma_defn.md_ps,"This macro has an infinite expansion.");
X
X /* Note: The above message is not "This macro is defined recursively",       */
X /* because this function catches not only recursive macros, but also all the */
X /* non-recursive macros that call the recursive macros!! To detect only      */
X /* the recursive macros, we really ought to use Tarjan's algorithm for the   */
X /* detection of strongly connected components. However, I don't have the     */
X /* reference handy right now and I want to finish this version of FunnelWeb  */
X /* soon, so I'll leave the installation of Tarjan's algorithm as a possible  */
X /* future enhancement. Then the error message can be changed.                */
X}
X
X/******************************************************************************/
X
XEXPORT void analyse()
X{
X name_t dummy_name;
X p_ma_t p_ma;
X
X /* Issue an error if there are no macros. */
X if (tb_len(macro_table)==0)
X   {
X    char *m="E: No macros defined.";
X    wl_l(m);
X    if (option.op_s_b)
X       wl_sj(m);
X    num_err++;
X   }
X
X /* Issue an error if there are no product (output) files. */
X if (tb_len(file_table)==0)
X   {
X    char *m="E: No output files specified.";
X    wl_l(m);
X    if (option.op_s_b)
X       wl_sj(m);
X    num_err++;
X   }
X
X /* Take a look at each macro and issue appropriate diagnostics. */
X tb_fir(macro_table);
X while (tb_rea(macro_table,PV dummy_name,PV &p_ma))
X    chk_mac(p_ma);
X
X /* Check for recursive macros. */
X chk_rec();
X
X /* Run through the document list and flag any sections that still have not   */
X /* been given names.                                                         */
X ls_fir(document_list);
X while (TRUE)
X   {
X    p_dc_t p_dc;
X    ls_nxt(document_list,PPV &p_dc);
X    if (p_dc==NULL) break;
X    if (p_dc->dc_kind==DC_TYPE &&
X        p_dc->dc_ty.ty_kind==TY_NSEC &&
X        !p_dc->dc_ty.ty_isnam)
X      {
X       lr_err(&p_dc->dc_ps,"This section has no name.");
X       lr_mes(&p_dc->dc_ps,"You can give it one explicitly (As in @A@<Sloth@>) or implicitly by");
X       lr_mes(&p_dc->dc_ps,"defining a macro (whose name will be inherited) within the section.");
X      }
X   }
X}
X
X/******************************************************************************/
X/*                               End of ANALYSE.C                             */
X/******************************************************************************/
END_OF_FILE
if test 11750 -ne `wc -c <'sources/analyse.c'`; then
    echo shar: \"'sources/analyse.c'\" unpacked with wrong size!
fi
# end of 'sources/analyse.c'
fi
if test -f 'sources/environ.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sources/environ.h'\"
else
echo shar: Extracting \"'sources/environ.h'\" \(11366 characters\)
sed "s/^X//" >'sources/environ.h' <<'END_OF_FILE'
X/*##############################################################################
X
XFUNNNELWEB COPYRIGHT
X====================
XFunnelWeb is a literate-programming macro preprocessor.
X
Copyright (C) 1992 Ross N. Williams.
X
X   Ross N. Williams
X   ross@spam.adelaide.edu.au
X   16 Lerwick Avenue, Hazelwood Park 5066, Australia.
X
This program is free software; you can redistribute it and/or modify
it under the terms of Version 2 of the GNU General Public License as
published by the Free Software Foundation.
X
This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See Version 2 of the GNU General Public License for more details.
X
You should have received a copy of Version 2 of the GNU General Public
License along with this program. If not, you can FTP the license from
prep.ai.mit.edu/pub/gnu/COPYING-2 or write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Section 2a of the license requires that all changes to this file be
recorded prominently in this file. Please record all changes here.
X
Programmers:
X   RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X
Changes:
X   07-May-1992  RNW  Program prepared for release under GNU GPL V2.
X
X##############################################################################*/
X
X
X/******************************************************************************/
X/*                                   ENVIRON.H                                */
X/******************************************************************************/
X/*                                                                            */
X/* WARNING: DO NOT ADD ANY PROGRAM-DEPENDENT DEFINITIONS.                     */
X/*                                                                            */
X/* This header file environ.h contains definitions and objects whose values   */
X/* depends directly on the compilation and execution environment, but are     */
X/* otherwise independent of any particular computer program.                  */
X/*                                                                            */
X/* This is one of two machine-dependent, program-independent modules. The     */
X/* other module is machin (machin.h,machin.c). This "environ" module contains */
X/* definitions and objects that are considered essential. The "machin" module */
X/* contains less essential definitions. Motivation for the division came from */
X/* the fact that style.h (used by almost every module) includes environ.h     */
X/* (this file), and from the need for the stuff in style.h by some            */
X/* environment-dependent definitions.                                         */
X/*                                                                            */
X/* There seems to be two ways to organize a module such as this one. The      */
X/* first is to have a different version of this module for each target        */
X/* environment. The second is to have a single file that uses #defines and    */
X/* #ifs to select between code for each target environment. I have chosen the */
X/* latter method as this allows many different environments to share the same */
X/* definitions.                                                               */
X/*                                                                            */
X/******************************************************************************/
X
X/* Ensure that the body of this header file is included at most once.         */
X#ifndef DONE_ENVIRON
X#define DONE_ENVIRON
X
X/******************************************************************************/
X
X/* Select An Environment                                                      */
X/* ---------------------                                                      */
X/* Choose the environment in which the program will be compiled and executed. */
X/* This may be the only change you need to make to get FunnelWeb to compile.  */
X/*                                                                            */
X/* If your exact environment is not listed, try one that is close.            */
X/* If problems arise, an attempt should be made to solve them                 */
X/* without creating a new environment definition.  However, if this is not    */
X/* possible, define a new environment below and "implement" it by going       */
X/* through environ.h and machin.h and machin.c and adding appropriate         */
X/* definitions.                                                               */
X/*                                                                            */
X/* The following table lists real/defined environment pairs under which       */
X/* FunnelWeb is known to compile cleanly.                                     */
X/*                                                                            */
X/* Symbol = Processor  Machine       OS            Compiler                   */
X/* ------   ---------  -------       --            --------                   */
X/*    MAC = 68000      Macintosh-SE  Mac           THINK-C V4.0.5             */
X/*    SUN = SPARC      SUN ELC       Unix(SunOS)   GNUC                       */
X/*    VMS = VAX        VAXStation    VMS           VAXC                       */
X/*     PC = 386        IBM PC Clone  MSDOS5.0      Borland C++                */
X/*                                                                            */
X/* Set exactly one of the following environments to 1, the others to 0.       */
X
X#define MAC 0
X#define SUN 1
X#define VMS 0
X#define PC  0
X
X/* Ensure that exactly one environment has been selected.                     */
X#if MAC+SUN+VMS+PC != 1
X   #error Error: You must choose exactly one machine in ENVIRON.H.
X#endif
X
X/******************************************************************************/
X
X/* Establish Presence or Absence of __STDC__                                  */
X/* -----------------------------------------                                  */
X/* The __STDC__ symbol is very useful for determining if the compiler is      */
X/* ANSI. However, some "nearly ANSI" compilers don't set this symbol, and     */
X/* experience shows that things turn out better if it is set.                 */
X/* This section decides if __STDC__ should be defined.                        */
X
X/* The Macintosh THINK C compiler seems to be ANSI standard but, strangely    */
X/* does not define the standard preprocessor symbol __STDC__ that indicates   */
X/* this. Instead it defines THINK_C. Here, we execute the link manually.      */
X/* For more information see the THINK C User's Manual, Chapter 57: "Language  */
X/* Reference", Section 12.10, p.442.                                          */
X#ifdef THINK_C
X#define __STDC__ 1
X#endif
X
X/* The problem seems to exist with VAX C too. */
X#if VMS
X#define __STDC__ 1
X#endif
X
X/******************************************************************************/
X
X/* Switch From Definedness to Boolean Symbols                                 */
X/* ------------------------------------------                                 */
X/* Use of the definedness of a preprocessor symbol to detect a condition is   */
X/* convenient if it is desired that only one condition be tested at a time.   */
X/* However, if we want to OR conditions, it is more convenient to use defined */
X/* symbols that are either 0 or 1. This section contains ifdefs that do this. */
X
X#ifdef __STDC__
X#define STDC 1
X#else
X#define STDC 0
X#endif
X
X/* Note: If THINK_C is predefined, it is predefined to be 1. */
X#ifndef THINK_C
X#define THINK_C 0
X#endif
X
X/******************************************************************************/
X
X/* Void                                                                       */
X/* ----                                                                       */
X/* Define void if necessary and define pointer to void.                       */
X/* This idea from the book "Portable C", p.41.                                */
X/* If necessary, add a boolean condition to cover your environment.           */
X/* Note: The "| SUN" is a last minute desperate hack.                         */
X#if STDC | SUN
typedef void   *p_void;
X#else
typedef int       void;
typedef char   *p_void;
X#endif
X
X/* The following function is here solely to act as a first tripping point for */
X/* environments with no "void" so that the users trying to port this code     */
X/* will look here first instead of starting to delete voids in the program.   */
extern void test_void();
X
X/******************************************************************************/
X
X/* Const                                                                      */
X/* -----                                                                      */
X/* It's useful to be able to specify that certain objects are constants.      */
X/* Unfortunately, the "const" construct is only available in ANSI C and so we */
X/* have to have a macro so as to cope with non-ANSI compilers.                */
X/* Note: THINK-C is nearly ANSI, but does not support "const".                */
X#if STDC & !THINK_C
X#define CONST const
X#else
X#define CONST
X#endif
X
X/******************************************************************************/
X
X/* Prototypes                                                                 */
X/* ----------                                                                 */
X/* Define a macro to wrap around prototype parameter lists so as to support   */
X/* compilers with and without prototypes.                                     */
X/* This idea came from the book "Portable C", S3.1, p.32.                     */
X#if STDC
X#define P_(A) A
X#else
X#define P_(A) ()
X#endif
X
X/******************************************************************************/
X
X/* Structure Assignments                                                      */
X/* ---------------------                                                      */
X/* Structure assignments are not supported on some of the older compilers and */
X/* so we use a macro to perform such operations.                              */
X/* This idea came from the book "Portable C", S8.2.2, p.184.                  */
X#if STDC
X#define ASSIGN(a,b) ((a)=(b))
X#else
X#define ASSIGN(a,b) (memcpy((char *)&(a),(char *)&(b),sizeof(a)))
X#endif
X
X/******************************************************************************/
X
X/* VMS EXIT STATUS */
X/* --------------- */
X/* The VAX C compiler I used doesn't seem to be ANSI. This means that the    */
X/* exit symbols aren't set up properly. Furthermore, the sensible defaults   */
X/* in the style.h file don't work for VMS. The upshot is that we have to do  */
X/* a special case. Note: The top bit set in a VMS exit status means suppress */
X/* diagnostic message. Even status means failure. Odd means success.         */
X#if VMS
X#undef  EXIT_SUCCESS
X#undef  EXIT_FAILURE
X#define EXIT_SUCCESS 1
X#define EXIT_FAILURE (0x10000002)
X#endif
X
X/******************************************************************************/
X
X/* For #ifndef preventing multiple inclusion of the body of this header file. */
X#endif
X
X/******************************************************************************/
X/*                                End of ENVIRON.H                            */
X/******************************************************************************/
END_OF_FILE
if test 11366 -ne `wc -c <'sources/environ.h'`; then
    echo shar: \"'sources/environ.h'\" unpacked with wrong size!
fi
# end of 'sources/environ.h'
fi
if test -f 'sources/list.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sources/list.h'\"
else
echo shar: Extracting \"'sources/list.h'\" \(12123 characters\)
sed "s/^X//" >'sources/list.h' <<'END_OF_FILE'
X/*##############################################################################
X
XFUNNNELWEB COPYRIGHT
X====================
XFunnelWeb is a literate-programming macro preprocessor.
X
Copyright (C) 1992 Ross N. Williams.
X
X   Ross N. Williams
X   ross@spam.adelaide.edu.au
X   16 Lerwick Avenue, Hazelwood Park 5066, Australia.
X
This program is free software; you can redistribute it and/or modify
it under the terms of Version 2 of the GNU General Public License as
published by the Free Software Foundation.
X
This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See Version 2 of the GNU General Public License for more details.
X
You should have received a copy of Version 2 of the GNU General Public
License along with this program. If not, you can FTP the license from
prep.ai.mit.edu/pub/gnu/COPYING-2 or write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Section 2a of the license requires that all changes to this file be
recorded prominently in this file. Please record all changes here.
X
Programmers:
X   RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X
Changes:
X   07-May-1992  RNW  Program prepared for release under GNU GPL V2.
X
X##############################################################################*/
X
X
X/******************************************************************************/
X/*                                  LIST.H                                    */
X/******************************************************************************/
X/*                                                                            */
X/* Introduction                                                               */
X/* ------------                                                               */
X/* This list package (list.h and list.c) implements a list abstraction.       */
X/*                                                                            */
X/* Facts about Lists                                                          */
X/* -----------------                                                          */
X/* - A LIST stores zero or more LIST ELEMENTS.                                */
X/* - The user decides the type of element to be stored in each list.          */
X/* - Each list stores only one type of list element; lists are homogeneous.   */
X/* - Lists store copies of elements rather than pointers to elements.         */
X/* - Each list can hold from zero to about 2^31 elements.                     */
X/* - Each list has a HEAD end and a TAIL end.                                 */
X/* - Elements can be appended and deleted only at the tail of the list.       */
X/* - The elements of a list can be read sequentially from head to tail.       */
X/* - A MARKER stores the current position in the list for sequential reading. */
X/* - Upon list creation, the marker is positioned at the tail of the list.    */
X/* - In a list of n elements, elements are numbered from 1 to n.              */
X/* - Element 1 is at the head of the list. Element n is at the tail.          */
X/* - The identifier "ls" is used as an abbreviation for "list".               */
X/* - The identifier "el" is used as an abbreviation for "element".            */
X/* - Longer names are desirable, but shorter ones have been used so as to     */
X/*   enhance the portability of the package.                                  */
X/* - IMPORTANT: Lists get all their memory using mm_temp calls.               */
X/*                                                                            */
X/* How To Use This List Package                                               */
X/* ----------------------------                                               */
X/* 1. Include this .H file in your program file.                              */
X/* 2. Identify the type of elements to be placed in the list.                 */
X/* 3. Define a variable of type p_ls as a view to a list.                     */
X/* 4. Use the ls_* functions to perform the desired operations.               */
X/*    Start with a call to ls_cre and (optionally) end with a call to ls_des. */
X/*                                                                            */
X/******************************************************************************/
X
X/* Ensure that the body of this header file is included at most once.         */
X#ifndef DONE_LIST
X#define DONE_LIST
X
X/******************************************************************************/
X
X#include "style.h"
X
X/******************************************************************************/
X
X/* Users manipulate lists through pointers to lists (p_ls_t). The following   */
X/* declaration serves the list user of the package while hiding the           */
X/* implementation details (which appear in a similar declaration in list.c).  */
X/* The #ifndef stops list.c from seeing these public declarations.            */
X#ifndef INLISTC
typedef struct {word NEVER_USE_THIS_FIELD_UQJTKC;} ls_yqwx; /* Don't use! */
typedef ls_yqwx *p_ls_t;
typedef p_void p_lsel_t;
typedef p_lsel_t *pp_lsel_t;
X#endif
X
X/******************************************************************************/
X/*                                                                            */
X/* General Notes About These Functions                                        */
X/* -----------------------------------                                        */
X/* - All lists and elements are passed by pointer. Whether a parameter is     */
X/*   read or written is determined by it's function's description.            */
X/* - Each function (except ls_cre) accepts a single pointer to a list and     */
X/*   each function's description is assumed to be referring to the list.      */
X/* - "Raising an error" means calling the external function "error" to        */
X/*   write out a message and bomb the program.                                */
X/* - You must create a list using ls_cre before performing any operations     */
X/*   upon it. A list function will usually raise an error if it is            */
X/*   handed a pointer that does not point to a properly CREated list.         */
X/*                                                                            */
X/* WARNING: This package copies values into its internal data structures      */
X/* (through ls_add), but returns only POINTERS to elements when asked to      */
X/* retrieve them. These pointers are valid only so long as the element        */
X/* that they point to remains in the list. If the element is deleted somehow, */
X/* the pointer points to garbage and becomes dangerous.                       */
X/* So, if you have been handed a pointer to an element in a list (ls_nxt,     */
X/* ls_loo), do not subsequently delete the element (ls_lop, ls_emp, ls_des)   */
X/* and then attempt to access the element through the pointer.                */
X/* One sure way to avoid the problem is always to use the pointer handed back */
X/* by ls_nxt or ls_loo to copy the element immediately.                       */
X
X/* The Functions                                                              */
X/* -------------                                                              */
XEXPORT p_ls_t ls_cre P_((size_t));
X/* CREate. Creates a new list and returns a pointer to the new list. The user */
X/* must specify in the parameter the size of elements that are to be stored   */
X/* in the list. Specify the size of elements in bytes (usually using sizeof). */
X/* The sequential reading marker is set to position n+1=1=tail of the list.   */
X
XEXPORT void ls_add P_((p_ls_t,p_lsel_t));
X/* ADD. Adds a new element onto the tail of the list (at position n+1).       */
X/* The user must supply in the second parameter a pointer to the element to   */
X/* be added. ls_add takes a copy of the element (it knows from the earlier    */
X/* call to ls_cre how many bytes to copy) and stores the copy in its own      */
X/* internal data structures.                                                  */
X
XEXPORT void ls_lop P_((p_ls_t));
X/* LOP. Removes (lops) element n from the tail of the list.                   */
X/* Raises an error if the list is empty.                                      */
X
XEXPORT ulong ls_len P_((p_ls_t));
X/* LENgth. Returns the number of elements in the list (n).                    */
X
XEXPORT void ls_fir P_((p_ls_t));
X/* FIRst. Sets the sequential reading marker to element 1.                    */
X/* If the list is empty (n=0) the marker is placed at the tail of the list    */
X/* and subsequent calls to ls_add will leave it there until the next call to  */
X/* ls_fir.                                                                    */
X
XEXPORT void ls_nxt P_((p_ls_t,pp_lsel_t));
X/* NeXT. Returns the list element under the marker and advances the marker    */
X/* one position towards the tail of the list.                                 */
X/* The method of returning the list element is a little messy. The user       */
X/* supplies a pointer to a pointer in the second parameter, and the function  */
X/* writes the address of the element in the list into the pointer.            */
X/* If the marker is at position n+1 upon entry to ls_nxt, the marker position */
X/* doesn't change and NULL is written to the argument pointer.                */
X
XEXPORT void ls_loo P_((p_ls_t,ulong,pp_lsel_t));
X/* LOOkup. Returns (using the same mechanism as ls_nxt) the k'th element of   */
X/* the specified list where k is the second (ulong) parameter and the first   */
X/* element (at the head of the list) is numbered number one (1).              */
X/* Raises an error if the index k is out of the range [1,n].                  */
X
XEXPORT void ls_tai P_((p_ls_t,pp_lsel_t));
X/* Lookup TAIl. Returns (using the same mechanism as ls_nxt) the tail element */
X/* of the specified list.                                                     */
X/* Raises an error if the list is empty.                                      */
X
XEXPORT void ls_emp P_((p_ls_t));
X/* EMPty. Empties the specified list, deallocating all the space used by the  */
X/* list elements. Upon completion, the list will be empty and the list marker */
X/* will be positioned at the tail of the list.                                */
X
XEXPORT void ls_des P_((p_ls_t));
X/* DEStroy. Destroys a list, destroying all its elements and deallocating all */
X/* the memory used by the list.                                               */
X
X/* Marker Functions */
X/* ---------------- */
X/* The following two functions ls_mar and ls_set were hacked in to this list  */
X/* package when it was discovered that the tangler sometimes needs to run     */
X/* more than one context down a list at the same time. The two new functions  */
X/* allow the list package user to save and restore the current mark.          */
X/* These functions are not tightly controlled and so care must be taken in    */
X/* their use.                                                                 */
X
XEXPORT p_void ls_mar P_((p_ls_t));
X/* Returns a representation of the current list marker. */
X
XEXPORT void ls_set P_((p_ls_t,p_void));
X/* Sets the position of the marker to an earlier saved position.              */
X/* Calls to this function should satisfy the following conditions:            */
X/*    1. The marker argument (p_void) must be the result of an earlier call   */
X/*       to ls_mar with the same list as an argument.                         */
X/*    2. No part of the list should have been modified in the interim. In     */
X/*       particular, this means that no calls to ls_add, ls_lop, ls_emp or    */
X/*       ls_des can be made between linked calls to ls_mar and ls_set.        */
X
X/******************************************************************************/
X
X/* For #ifndef preventing multiple inclusion of the body of this header file. */
X#endif
X
X/******************************************************************************/
X/*                               End of LIST.H                                */
X/******************************************************************************/
END_OF_FILE
if test 12123 -ne `wc -c <'sources/list.h'`; then
    echo shar: \"'sources/list.h'\" unpacked with wrong size!
fi
# end of 'sources/list.h'
fi
if test -f 'sources/lister.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sources/lister.c'\"
else
echo shar: Extracting \"'sources/lister.c'\" \(11799 characters\)
sed "s/^X//" >'sources/lister.c' <<'END_OF_FILE'
X/*##############################################################################
X
XFUNNNELWEB COPYRIGHT
X====================
XFunnelWeb is a literate-programming macro preprocessor.
X
Copyright (C) 1992 Ross N. Williams.
X
X   Ross N. Williams
X   ross@spam.adelaide.edu.au
X   16 Lerwick Avenue, Hazelwood Park 5066, Australia.
X
This program is free software; you can redistribute it and/or modify
it under the terms of Version 2 of the GNU General Public License as
published by the Free Software Foundation.
X
This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See Version 2 of the GNU General Public License for more details.
X
You should have received a copy of Version 2 of the GNU General Public
License along with this program. If not, you can FTP the license from
prep.ai.mit.edu/pub/gnu/COPYING-2 or write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Section 2a of the license requires that all changes to this file be
recorded prominently in this file. Please record all changes here.
X
Programmers:
X   RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X
Changes:
X   07-May-1992  RNW  Program prepared for release under GNU GPL V2.
X
X##############################################################################*/
X
X
X/******************************************************************************/
X/*                                    LISTER.C                                */
X/******************************************************************************/
X
X#include "style.h"
X
X#include "as.h"
X#include "data.h"
X#include "list.h"
X#include "lister.h"
X#include "machin.h"
X#include "misc.h"
X#include "table.h"
X#include "writfile.h"
X
X/******************************************************************************/
X
X#define LISTWIDTH     80  /* Nominal width of listing file. Can be wider.     */
X#define INDENTQ        3  /* Indentation quantum for include files.           */
X#define MESSMAXCH    200  /* Maximum number of characters in a message.       */
X#define CTXINF       100  /* Special value that signals infinite context.     */
X#define MAXLINES   10000  /* Maximum number of lines in input file.           */
X
X/******************************************************************************/
X
X/* The following #defines and typedef define an enumerated type for message   */
X/* kinds. There are four kinds of message, and we need a type for storing     */
X/* this information. mess_k_t stands for message_kind_type.                   */
X/* We use #defines instead of enums as enums are not portable enough.         */
X#define MESS_MES 1
X#define MESS_WAR 2
X#define MESS_ERR 3
X#define MESS_SEV 4
typedef ubyte mess_k_t;
X
X/* We wish to store messages in a table with message positions as keys.       */
X/* However, the table package will not tolerate duplicate keys. To solve this */
X/* problem, we create a new type 'unqpos_t' (unique position type) which has  */
X/* not only a position but a serial number as well.                           */
typedef struct
X  {
X   ps_t  up_pos;
X   ulong up_serial;
X  } unqpos_t;
X
X/* The following structure stores a single message. As we are storing COPIES  */
X/* of the messages, we impose a maximum limit (MESSMAXCH) to their length.    */
typedef struct
X  {
X   mess_k_t ms_kind;
X   char     ms_text[MESSMAXCH+1];
X  } mess_t;
X
X/******************************************************************************/
X
LOCVAR p_tb_t p_msgtab;           /* The message table storing diagnostics.   */
LOCVAR ulong  serial_next;        /* Serial number for numbering messages.    */
X
X/******************************************************************************/
X
LOCAL int cmpuqpos P_((unqpos_t *,unqpos_t *));
LOCAL int cmpuqpos(p1,p2)
X/* Compare two unique positions for the table package and returns [-1,0,1].   */
unqpos_t *p1;
unqpos_t *p2;
X{
X long  diff;
X ubyte i;
X
X for (i=1; i<=3; i++)
X   {
X    switch (i)
X      {
X       case 1: diff= p1->up_pos.ps_line   - p2->up_pos.ps_line;   break;
X       case 2: diff= p1->up_pos.ps_column - p2->up_pos.ps_column; break;
X       case 3: diff= p1->up_serial        - p2->up_serial;  break;
X       default: as_bomb("cmpuqpos: Case defaulted.");
X      }
X    if (diff<0)
X       return -1;
X    else
X       if (diff>0)
X          return 1;
X   }
X return 0;
X}
X
X/******************************************************************************/
X
X/* Converts a value of message kind type into a representative string. */
X/* This routine unused at present.
LOCAL char *mess_let P_((mess_k_t));
LOCAL char *mess_let (mess_k)
mess_k_t mess_k;
X{
X switch (mess_k)
X   {
X    case MESS_MES : return "M";
X    case MESS_WAR : return "W";
X    case MESS_ERR : return "E";
X    case MESS_SEV : return "S";
X    default: as_bomb("mess_let: Case defaulted.");
X   }
X as_bomb("mess_let: Switch dropped out.");
X return "Failure";
X}
X*/
X
X/******************************************************************************/
X
X#define DUPMAX 200
X
LOCAL char *dup P_((int,uword));
LOCAL char *dup(ch,count)
X/* Returns a pointer to a STAVAR string containing 'count' copies of 'ch'.    */
X/* Count must be in the range [0,DUPMAX]. The pointer returned always points  */
X/* to the same address which is a 'STAVAR' inside this function.              */
int   ch;
uword count;
X{
X STAVAR char buffer[DUPMAX+1];
X
X as_cold(count<DUPMAX,"lister.dup: count>=DUPMAX");
X /* The IF in the following is just in case 'memset' is brain damaged. */
X if (count>0) memset(&buffer[0],ch,(size_t) count);
X buffer[count]=EOS;
X return &buffer[0];
X}
X
X/******************************************************************************/
X
LOCAL void mess_wri P_((p_wf_t,mess_t *,uword,uword));
LOCAL void mess_wri(p_wf,p_mess,indent,column)
X/* Writes message p_mess to file p_wf indented by INDENTQ*indent+column.      */
p_wf_t p_wf;
mess_t *p_mess;
uword  indent;
uword  column;
X{
X switch (p_mess->ms_kind)
X   {
X    case MESS_MES : wf_wr(p_wf,"            "); break;
X    case MESS_WAR : wf_wr(p_wf,"     Warning"); break;
X    case MESS_ERR : wf_wr(p_wf,"       Error"); break;
X    case MESS_SEV : wf_wr(p_wf,"      Severe"); break;
X    default: as_bomb("mess_let: Case defaulted.");
X   }
X wf_wr(p_wf,"|.");
X wf_wr(p_wf,dup('.',indent*INDENTQ));
X wf_wr(p_wf,dup('.',column-1));
X wf_wr(p_wf,"^");
X wf_wr(p_wf,&p_mess->ms_text[0]);
X wf_wr(p_wf,"\n");
X}
X
X/******************************************************************************/
X
LOCAL void line_wri P_((p_wf_t,ln_t *));
LOCAL void line_wri(p_wf,p_line)
X/* Writes the given line to the given output stream. */
p_wf_t  p_wf;
ln_t   *p_line;
X{
X char buffer[100];
X
X /* The last line of the line list is the EOF marker line and to indicate     */
X /* that it is not really part of the input file, we omit it's line number.   */
X if (p_line->ln_global==ls_len(line_list))
X                 /*" 12345 12345| "*/
X    sprintf(buffer,"            | ");
X else
X    sprintf(buffer," %5lu %5lu| ",
X                   (unsigned long) p_line->ln_global,
X                   (unsigned long) p_line->ln_local);
X wf_wr(p_wf,buffer);
X wf_blk(p_wf,p_line->ln_body.sc_first,(size_t)
X     (p_line->ln_body.sc_last-p_line->ln_body.sc_first+1));
X}
X
X/******************************************************************************/
X
LOCAL void add_mess P_((ps_t *,mess_k_t,char *));
LOCAL void add_mess(p_pos,messkind,p_string)
X/* Creates a message record and places the message information in the         */
X/* argument into the record. Inserts the record into the message table.       */
ps_t      *p_pos;
mess_k_t   messkind;
char      *p_string;
X{
X mess_t   tempmess;
X unqpos_t unqpos;
X
X tempmess.ms_kind=messkind;
X as_cold(strlen(p_string)<=MESSMAXCH,
X         "lister.add_mess: Parameter message is too long.");
X strcpy(tempmess.ms_text,p_string);
X ASSIGN(unqpos.up_pos,*p_pos);
X unqpos.up_serial=serial_next++;
X tb_ins(p_msgtab,PV &unqpos,PV &tempmess);
X}
X
X/******************************************************************************/
X
XEXPORT void lr_ini P_((void))
X{
X /* Create a brand new empty message table. */
X p_msgtab=tb_cre(sizeof(unqpos_t),sizeof(mess_t),(p_kycm_t) cmpuqpos);
X
X /* Start the serial numbers at zero again. */
X serial_next=0;
X}
X
X/******************************************************************************/
X
XEXPORT void lr_mes(p_pos,s)
ps_t *p_pos;
char *s;
X{
X add_mess(p_pos,MESS_MES,s);
X}
X
X/******************************************************************************/
X
XEXPORT void lr_war(p_pos,s)
ps_t *p_pos;
char *s;
X{
X add_mess(p_pos,MESS_WAR,s);
X num_war++;
X}
X
X/******************************************************************************/
X
XEXPORT void lr_err(p_pos,s)
ps_t *p_pos;
char *s;
X{
X add_mess(p_pos,MESS_ERR,s);
X num_err++;
X}
X
X/******************************************************************************/
X
XEXPORT void lr_sev(p_pos,s)
ps_t *p_pos;
char *s;
X{
X add_mess(p_pos,MESS_SEV,s);
X num_sev++;
X}
X
X/******************************************************************************/
X
XEXPORT void lr_gen(p_wf,ctx)
p_wf_t p_wf;
uword  ctx;
X{
X unqpos_t next_pos; /* Position of next message.                              */
X mess_t   next_mes; /* Content  of next message.                              */
X long     prev_no;  /* Global line number of previous message.                */
X long     next_no;  /* Global line number of next     message.                */
X bool     ingap;    /* Controls issuance of gap markers in the listing.       */
X long     context=ctx; /* Signed version of the parameter.                    */
X
X /* A context of CTXINF signals an infinite context. */
X if (context==CTXINF) context=MAXLINES;
X
X /* Write listing header. */
X wf_wr(p_wf,"\nGlobal Local| Input File\n");
X wf_wr(p_wf,dup('-',12));wf_wr(p_wf,"+");
X wf_wr(p_wf,dup('-',LISTWIDTH-13));wf_wr(p_wf,"\n");
X
X /* Reset the line list and message table for reading. */
X ls_fir(line_list);
X tb_fir(p_msgtab);
X
X /* Prime the variables ingap, prev_no, next_no, next_pos, and next_mes. */
X ingap=FALSE; prev_no = -(context+1);
X if (tb_rea(p_msgtab,PV &next_pos,PV &next_mes))
X    next_no=next_pos.up_pos.ps_line;
X else
X    next_no=MAXLINES+context+1;
X
X while (TRUE)
X   {/* Process a single line per iteration. */
X    ln_t *p_line;
X
X    /* Grab the next line from the line list. */
X    ls_nxt(line_list,PPV &p_line);
X    if (p_line==NULL) break;
X
X    /* List the line if it is within context range of prev or next message. */
X    if ((((long) p_line->ln_global) <= prev_no+context) ||
X        (((long) p_line->ln_global) >= next_no-context))
X       {line_wri(p_wf,p_line);ingap=FALSE;}
X    else
X       if (!ingap)
X          {wf_wr(p_wf,".................\n");ingap=TRUE;}
X
X    /* Issue any messages that are about this line. */
X    while (next_no == p_line->ln_global)
X      {
X       /* Write the current message. */
X       mess_wri(p_wf,&next_mes,(uword) 0,
X                (uword) next_pos.up_pos.ps_column);
X                
X       /* Read the next message from the table. */
X       prev_no=next_no;
X       if (tb_rea(p_msgtab,PV &next_pos,PV &next_mes))
X          next_no=next_pos.up_pos.ps_line;
X       else
X          next_no=MAXLINES+context+1;
X      }
X   } /* End while */
X
X /* Make sure that we have read to the end of the message table. */
X {bool result;
X  result=tb_rea(p_msgtab,PV &next_pos,PV &next_mes);
X  as_cold(!result,
X          "lr_gen: Messages remaining in message table after listing.");
X }
X
X /* Write listing trailer. */
X wf_wr(p_wf,dup('-',12));wf_wr(p_wf,"+");
X wf_wr(p_wf,dup('-',LISTWIDTH-13));wf_wr(p_wf,"\n");
X wf_wl(p_wf,"");
X}
X
X/******************************************************************************/
X/*                               End of LISTER.C                              */
X/******************************************************************************/
END_OF_FILE
if test 11799 -ne `wc -c <'sources/lister.c'`; then
    echo shar: \"'sources/lister.c'\" unpacked with wrong size!
fi
# end of 'sources/lister.c'
fi
if test -f 'sources/machin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sources/machin.c'\"
else
echo shar: Extracting \"'sources/machin.c'\" \(11580 characters\)
sed "s/^X//" >'sources/machin.c' <<'END_OF_FILE'
X/*##############################################################################
X
XFUNNNELWEB COPYRIGHT
X====================
XFunnelWeb is a literate-programming macro preprocessor.
X
Copyright (C) 1992 Ross N. Williams.
X
X   Ross N. Williams
X   ross@spam.adelaide.edu.au
X   16 Lerwick Avenue, Hazelwood Park 5066, Australia.
X
This program is free software; you can redistribute it and/or modify
it under the terms of Version 2 of the GNU General Public License as
published by the Free Software Foundation.
X
This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See Version 2 of the GNU General Public License for more details.
X
You should have received a copy of Version 2 of the GNU General Public
License along with this program. If not, you can FTP the license from
prep.ai.mit.edu/pub/gnu/COPYING-2 or write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Section 2a of the license requires that all changes to this file be
recorded prominently in this file. Please record all changes here.
X
Programmers:
X   RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X
Changes:
X   07-May-1992  RNW  Program prepared for release under GNU GPL V2.
X
X##############################################################################*/
X
X
X/******************************************************************************/
X/*                                    MACHIN.C                                */
X/******************************************************************************/
X/*                                                                            */
X/* WARNING: DO NOT ADD ANY PROGRAM DEPENDENT DEFINITIONS.                     */
X/*                                                                            */
X/* This file contains machine-dependent, program-independent stuff that       */
X/* implements the functionality promised in MACHIN.H.                         */
X/*                                                                            */
X/* Note: As usual, the full definitions of functions in the .H file are not   */
X/*       repeated here.                                                       */
X/*                                                                            */
X/******************************************************************************/
X
X#include <time.h>
X#include "style.h"
X
X#include "as.h"
X#include "machin.h"
X
X/* The Macintosh's doesn't have a command language, and so we have to prompt  */
X/* for a command line. This requires a special package.                       */
X#if MAC
X#include <console.h>
X#endif
X
X/* Under VMS, we need RMS to get at stuff to do with filenames.               */
X#if VMS
X#include RMS
X#endif
X
X/******************************************************************************/
X/*                           LOCAL FUNCTIONS                                  */
X/******************************************************************************/
X
LOCAL void mconcat P_((int,char **,char *));
LOCAL void mconcat(argc,argv,result)
X/* Given argc and argv, as passed to main(), this function appends all the    */
X/* arguments together (separated by spaces) into the string "result".         */
X/* This function assists in reconstructing the command line.                  */
X/* This function is actually portable, so you shouldn't have to change it.    */
X/* Note: "mconcat" stands for Multiple CONCATenation.                         */
int    argc;
char **argv;
char *result;
X{
X uword i;
X strcpy(&result[0],argv[0]);
X for (i=1;i<argc;i++)
X   {
X    strcat(&result[0]," "    );
X    strcat(&result[0],argv[i]);
X   }
X}
X
X/******************************************************************************/
X
X#if MAC | SUN | PC
LOCAL void fn_split P_((p_fn_t,p_fn_t,p_fn_t,p_fn_t));
LOCAL void fn_split(p_fn,p_path,p_name,p_ext)
X/* Accepts a filename in p_fn and writes the path, name, and extension        */
X/* components of the filename to the strings p_path, p_name, and p_ext.       */
p_fn_t p_fn;
p_fn_t p_path;
p_fn_t p_name;
p_fn_t p_ext;
X{
X char *p,*q;
X
X /* Make sure that the input filename is a sensible length. */
X as_cold(strlen(p_fn)<=FILENAME_MAX,"fn_split: Filename is too long.");
X
X /* Extract the path from the input string by searching for the last */
X /* occurrance of the special character used for directories.        */
X
X /* Find the last directory/filename separator. */
X p=strrchr(p_fn,FN_DELIM);
X if (p==NULL)
X   {strcpy(p_path,""); p=p_fn;}
X else
X   {
X    memcpy(p_path,p_fn,(size_t) (p-p_fn+1));
X    p_path[(size_t) (p-p_fn+1)]=EOS;
X    p++;
X   }
X
X /* Assert: p now points to the first character of the name field. */
X
X /* Now locate the file extension. */
X q=strrchr(p_fn,'.');
X if (q==NULL)
X   {strcpy(p_ext,""); q = &p_fn[strlen(p_fn)];}
X else
X   {strcpy(p_ext,q);}
X
X /* Assert: q now points to the '.' preceding the extension field. */
X
X /* Now anything between p and q must be the filename proper. */
X for (;p<q;p++)
X    *p_name++ = *p;
X *p_name=EOS;
X}
X#endif
X
X/******************************************************************************/
X
X#if MAC | SUN | PC
LOCAL void fn_join P_((p_fn_t,p_fn_t,p_fn_t,p_fn_t));
LOCAL void fn_join(p_fn,p_path,p_name,p_ext)
X/* This function sets p_fn to the empty string and then successively appends  */
X/* p_path, p_name, and p_ext. Before doing this, it checks to make sure that  */
X/* there will be enough room and bombs the program if there isn't.            */
p_fn_t p_fn;
p_fn_t p_path;
p_fn_t p_name;
p_fn_t p_ext;
X{
X as_cold(strlen(p_path)+strlen(p_name)+strlen(p_ext) <= FILENAME_MAX,
X         "fn_join: Constructed filename is too long.");
X strcpy(p_fn,p_path);
X strcat(p_fn,p_name);
X strcat(p_fn,p_ext);
X}
X#endif
X
X/******************************************************************************/
X/*                              EXPORTED FUNCTIONS                            */
X/******************************************************************************/
X
X#if MAC | SUN | PC
XEXPORT void fn_ins(p_cur,p_add)
p_fn_t p_cur;
p_fn_t p_add;
X{
X fn_t cur_path, add_path;
X fn_t cur_name, add_name;
X fn_t cur_extn, add_extn;
X
X /* Split the argument file names into their component parts. */
X fn_split(p_cur,cur_path,cur_name,cur_extn);
X fn_split(p_add,add_path,add_name,add_extn);
X
X /* Perform the inheriting on a field by field basis. */
X if (strlen(add_path) > 0) strcpy(cur_path,add_path);
X if (strlen(add_name) > 0) strcpy(cur_name,add_name);
X if (strlen(add_extn) > 0) strcpy(cur_extn,add_extn);
X
X /* Put the fields back together again to yield the final result. */
X fn_join(p_cur,cur_path,cur_name,cur_extn);
X}
X#endif
X
X#if VMS
XEXPORT void fn_ins(p_cur,p_add)
X/* This VMS version of fn_ins was written with the assistance of:             */
X/*    Jeremy Begg (jeremy@vsm.com.au) of VSM Software Services. Thanks!       */
X/* The VMS version is messy because VMS has highly structured filenames and   */
X/* highly ingrained rituals for manipulating them.                            */
p_fn_t p_cur;
p_fn_t p_add;
X{
X struct FAB cur_fab;   /* FAB    for SYS$PARSE */
X struct NAM cur_nam;   /* NAM    for SYS$PARSE */
X fn_t expanded;        /* Result of  SYS$PARSE */
X long rms_status;      /* Status of  SYS$PARSE */
X
X /*
X printf("\nTRACE: Call of fn_ins(...).\n");
X printf("   Current spec = \"%s\".\n",p_cur);
X printf("   Add     spec = \"%s\".\n",p_add);
X */
X
X /* Initialize the FAB and NAM block to something sensible. */
X cur_fab = cc$rms_fab;
X cur_nam = cc$rms_nam;
X
X /* (fna,fns) is address and size of input file spec in FAB block. */
X cur_fab.fab$l_fna = p_add;
X cur_fab.fab$b_fns = strlen(p_add);
X
X /* (dna,dns) is address and size of default file spec in FAB block. */
X cur_fab.fab$l_dna = p_cur;
X cur_fab.fab$b_dns = strlen(p_cur);
X
X /* Connect the NAM block to the FAB block. */
X cur_fab.fab$l_nam = &cur_nam;
X
X /* Point the NAM block's target name fields to the target namechar array. */
X cur_nam.nam$l_esa = &expanded;
X cur_nam.nam$b_ess = FILENAME_MAX;  /* Reserve last char for NULL terminator */
X
X /* PWD => put the password from a DECnet Access Control String in the filespec
X  * SYNCHK => check syntax only, don't search for the file on disk
X  */
X cur_nam.nam$b_nop = NAM$M_PWD + NAM$M_SYNCHK;
X
X /* Perform the parse. */
X rms_status = sys$parse(&cur_fab);
X if (rms_status & 1)
X   {
X    expanded[cur_nam.nam$b_esl]=EOS; /* Terminate VMS string. */
X    strcpy(p_cur,expanded);
X   }
X else
X   {
X    printf("Note: RMS parse failed. Could be a syntax error, could be a bug!\n");
X   }
X
X /* TRACE printf("   Result  spec = \"%s\".",p_cur); */
X}
X#endif
X
X/******************************************************************************/
X
XEXPORT void getcline(argc,argv,p_comline)
X/* Given, argc and argv, writes a command line string in p_comline.           */
X/* See machin.h for a thorough definition of this function.                   */
int   argc;
char **argv;
char *p_comline;
X{
X int    argc2;
X char **argv2;
X
X#if MAC
X /* On the Macintosh there is no command language and therefore no command    */
X /* line. Therefore we cannot trust the argc and argv handed to us by main()  */
X /* and have to obtain a command line from other sources.                     */
X /* The "ccommand" function comes from <console.h> of the THINK C libraries.  */
X argc2=ccommand(&argv2);
X#endif
X
X/* The other systems work like Unix. */
X#if SUN | VMS | PC
argc2=argc;
argv2=argv;
X#endif
X
X /* The command line is currently in pieces. Reassemble it. That's all!       */
X mconcat(argc2,argv2,p_comline);
X}
X
X/******************************************************************************/
X
XEXPORT float tim_real()
X{
X STAVAR bool   init=FALSE;
X STAVAR time_t base;
X
X /* The first time this routine is called, we establish a base real time      */
X /* from which real time differences are calculated. There are two reasons    */
X /* for doing this. The first is that difftime seems to be the only way to    */
X /* get ANSI C to hand over a calibrated arithmetic type holding the real     */
X /* time. The second is that we don't want to have to deal with large         */
X /* absolute times anyway.                                                    */
X if (!init)
X   {
X    /* Returns -1 if the time is not available (ANSI 7.12.2.4). */
X    base=time(NULL);
X    init=TRUE;
X   }
X
X /* Return the elapsed time since the base time. */
X
X/* Macintosh, VMS, and PC have difftime. */
X#if MAC | VMS | PC
X if (base == -1)
X    return 0.0;
X else
X    return (float) difftime(time(NULL),base);
X#endif
X
X/* Sun does not have difftime. */
X#if SUN
X return 0.0;
X#endif
X
X/* The timing functions are only used to generate performance statistics and  */
X/* are not critical to FunnelWeb. There is not much harm in returning 0.0.    */
X}
X
X/******************************************************************************/
X
XEXPORT float tim_cpu()
X{
X clock_t t=clock();
X
X/* Make sure that we have a definition for CLOCKS_PER_SEC. */
X#ifndef CLOCKS_PER_SEC
X#ifdef CLK_TCK
X#define CLOCKS_PER_SEC CLK_TCK
X#else
X/* Assume one million ticks per second. */
X#define CLOCKS_PER_SEC (1000000L)
X#endif
X#endif
X
X /* The clock() function returns -1 if the CPU time is not available. */
X /* Otherwise it returns the number of "clocks" since power-up.       */
X if (t == -1)
X    return 0.0;
X else
X    return ((float) t) / ((float) CLOCKS_PER_SEC);
X}
X
X/******************************************************************************/
X/*                              End of MACHIN.C                               */
X/******************************************************************************/
END_OF_FILE
if test 11580 -ne `wc -c <'sources/machin.c'`; then
    echo shar: \"'sources/machin.c'\" unpacked with wrong size!
fi
# end of 'sources/machin.c'
fi
if test -f 'sources/texhead.tex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sources/texhead.tex'\"
else
echo shar: Extracting \"'sources/texhead.tex'\" \(13048 characters\)
sed "s/^X//" >'sources/texhead.tex' <<'END_OF_FILE'
X%===================== Start of FunnelWeb TeX Definitions ======================
X
X
X% Version
X% -------
X% This is FunnelWeb TeX Macro Library Version 1.0.
X
X
X% Copyright
X% ---------
X% This set of FunnelWeb TeX definitions was written by Ross Williams and was
X% originally Copyright (C) 1992 Ross N. Williams.  However, I, Ross Williams,
X% hereby forego any claim to Copyright in this set of FunnelWeb TeX definitions
X% and hereby authorize that the set of TeX definitions pass into the public
X% domain. -- Ross N. Williams, 3:41pm 07-May-1992, Adelaide, Australia.
X
X
X% Modification
X% ------------
X% Please record all modifications to these TeX definitions here. Unless
X% otherwise specified, all modified definitions fall in the public domain too.
X%
X% Programmers:
X%    RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X%
X% Changes:
X%    07-May-1992  RNW  Prepared this work for public domain release.
X%
X
X
X% General Comments
X% ----------------
X% This set of TeX definitions exists for two reasons:
X%
X%    1. To shorten and neaten the FunnelWeb TeX output.
X%    2. To allow users to fiddle with the output format in their input files
X%       (by inserting redefining "\def"s) without having to resort to
X%       modifying the FunnelWeb code.
X%
X% The user is warned that these definitions may be changed from time to time
X% (but probably not much). The user should not be too sneaky. In particular,
X% users wishing to redefine some of these macros should do so in an explicitly
X% defined section at the top of their input file. This will mean that in the
X% event of problems, that section can simply be deleted or commented out to
X% allow the document to at least be typeset in the default format. Users should
X% limit themselves to redefining these macros in such a section and should
X% refrain from using the macros throughout their documents.
X
X
X% Environment Parameters
X% ----------------------
X% \tolerance tells TeX how tolerant it should be about making bad line and
X% page breaks. Here we set it to it's maximum, as
X%   1) Computer programs are likely to cause lots of bad breaks.
X%   2) In most cases the user would probably rather get the TeX file through
X%      TeX without any errors than fiddle with spacings for perfection.
X\tolerance=10000
X
X% I don't like indentation as it makes the page look more busy. Instead,
X% paragraphs are separated by a little space (see next).
X\parindent=0pt
X
X% In many cases, users will produce documents with long runs of paragraphs.
X% In order to space out these paragraphs, it is convenient to maintain a
X% prevailing non-zero \parskip (end-of-paragaph skip). The only trouble is
X% that the skip becomes a problem in macro definitions which require no skip
X% and so we have to turn the skip on and off. The following two macros
X% simplify this process.
X\def\fwparskipon{\parskip=\medskipamount}
X\def\fwparskipoff{\parskip=0pt}
X\fwparskipon
X
X% Setting raggedbottom allows TeX to leave a bit of space at the bottom of the
X% page in order to better vertically align the rest of the page (e.g. skips
X% won't stretch as much). It also means that headings are less likely to be
X% isolated at the bottom of the page without any following text.
X\raggedbottom
X
X
X% Fonts
X% -----
X% Most of the typeset output is set in 10pt roman and 10pt tt font.
X% The major extra font needs spring from titles and headings.
X% For portability's sake we use only the following fonts:
X%    cmr10
X%    cmbx10
X%    cmtt10
X% and some enlargements of them. These fonts are all "standard" fonts
X% in Plain TeX. See The TeXbook p.350.
X\font\fwfontnote=cmr7
X
X\font\fwfontnorm=cmr10
X\font\fwfontnorma=cmr10 scaled \magstep1
X\font\fwfontnormb=cmr10 scaled \magstep2
X
X\font\fwfontbold=cmbx10
X\font\fwfontbolda=cmbx10 scaled \magstep1
X\font\fwfontboldb=cmbx10 scaled \magstep2
X\font\fwfontboldc=cmbx10 scaled \magstep3
X\font\fwfontboldd=cmbx10 scaled \magstep4
X
X
X% Macros for Stylistic Details
X% ----------------------------
X% This section contains all the fiddly little macros for setting the details
X% of each macro definition.
X
X% Macro definitions are sandwiched by calls to these macros which can be used
X% to sort out the spacing before and after the macro definition.
X\def\fwbeginmacro{\fwparskipoff\bigskip}
X\def\fwendmacro{\fwparskipon\par}
X
X% These macros deal with the macro name and definition line.
X\def\fwmacroname#1#2{{\sl #1\/}$\lbrack$#2$\rbrack$}
X\def\fwfilename#1#2{{\bf #1}$\lbrack$#2$\rbrack$}
X\def\fwzero#1{{\bf Z}}
X\def\fwmany#1{{\bf M}}
X\def\fwequals{ $\equiv$}
X\def\fwplusequals{ $+\equiv$}
X
X% Now for the actual body of the definition. It looks nice to have the tt
X% code indented a little. Again, we use macros instead of writing direct TeX,
X% so as to allow the user to fiddle this stuff to taste without having to
X% modify the FunnelWeb C code.
X\def\fwodef{\parindent=15pt\vskip0pt$\lbrace$\parindent=20pt}
X\def\fwcdef{$\rbrace$\vskip0pt\parindent=0pt}
X\def\fwoquote{`}
X\def\fwcquote{'}
X\def\fwoparen{$($}
X\def\fwcomma{$,$}
X\def\fwcparen{$)$}
X\def\fwparam#1{$\diamond #1$}
X\def\fwparams#1{$(\diamond #1)$}
X
X% These macros deal with the notes that are appended at the end of each
X% macro definition. Note that even though \fwisafile,\fwusedin, and \fwseealso
X% have the same definition, they are given different names so as to allow the
X% user to redefine these macros to typeset each kind of information differently
X% if desired.
X\def\fwbeginmacronotes{\begingroup\baselineskip=9pt\smallskip}
X\def\fwnote#1{{\fwfontnote #1}\par}
X\def\fwisafile#1{\fwnote{#1}}
X\def\fwusedin#1{\fwnote{#1}}
X\def\fwseealso#1{\fwnote{#1}}
X\def\fwendmacronotes{\endgroup}
X
X
X% Macros to Typeset Program Code Verbatim
X% ---------------------------------------
X% This is by far the hairiest and most difficult part of the typesetting task
X% because we have to turn off most of TeX's natural instincts in order to
X% typeset the program text exactly as it appears in the input file.
X% Two macros are defined to pull this off: \fwbtx and \fwverbatimgobble.
X% Their code was inspired by the following sections of "The TeXbook":
X%    Appendix D: Dirty Tricks, 3.Verbatim listing, p.380-382.
X%    Appendix E: Example Formats, p.421.
X% The \fwbtx[ (for "FunnelWeb Begin TeXt") macro does most of the hard work.
X% The liberal use of "%" is because I don't understand TeX well enough to
X% understand when an end of line will cause trouble, and I am playing it safe.
X
X% Before defining the main \fwbtx macro, we have to stash away some definitions
X% in the hidden part of TeX's environment. Let's hope that these "hidden"
X% definitions don't affect anything except what is desired to be affected.
X
X% The tt font in which we wish to set the text has two Latin lurking ligatures!
X% These are ?` and !`. To disable them, we define the left quote when ACTIVE
X% to be defined in such a way as to prevent ligatures. The main TeX text will
X% normally not be exposed to this definition because normally the leftquote
X% character is not active. The \fwbtx macro temporarily makes the left quote
X% character active thus activating the deactivation of left quote ligatures.
X% See The TeXbook p.381.
X{\catcode`\`=\active \gdef`{\relax\lq}}
X
X% TeX is fairly carefree about spaces and so we have to make it more serious.
X% To do so we pull the same trick as above, setting up a definition for active
X% space, but only making space active during the span of the verbatim text.
X% In Plain TeX the active space is defined to be simply a space, but here we
X% define it to be a control space. This ensures that the space cannot
X% be gobbled up by one of TeX's mysterious mechanisms when activated.
X% See The TeXbook, p.381 and p.352.
X{\obeyspaces\global\let =\ }
X
X% Here is the main \fwbtx verbatim text macro.
X% Note: The order in which all these pieces of business have to be done is
X% still a partial mystery to me. Don't fiddle with this stuff unless you
X% think you know what you are doing.
X\def\fwbtx[{%
X%
X% The funnies involved in getting verbatim output are safely housed inside
X% this \begingroup, and the \endgroup in \fwverbatimgobble. Groups are used
X% instead of curly braces because we have to be able to signal the end of
X% this macro with a curly brace.
X\begingroup%
X%
X% \pars at the end of empty lines in the verbatim text won't come out normally
X% because TeX is in vertical mode and they get gobbled up. To prevent this,
X% we force \par to exit vertical mode first. See The TeXbook p.381.
X\def\par{\leavevmode\endgraf}%
X%
X% Activate the leftquote character so as to avoid ligatures (see above).
X\catcode`\`=\active%
X%
X% The \obeylines macro simply defines end of line (^M) to be \par. This ensures
X% that TeX will treat each verbatim line as a new paragraph.
X\obeylines%
X%
X% To get verbatim output, we have to desex all the special characters. This
X% is explained in detail in The TeXbook p.380.
X\def\do##1{\catcode`##1=12 }\dospecials%
X%
X% Activate the space character so as to make TeX treat blanks seriously.
X% This activation invokes an eralier definition (see above).
X\obeyspaces
X%
X% Interparagraph skips do not help the cause.
X% Note: We have to preserve the indentation though, as the code is actually
X% indented in the final output. See \fwodef in an earlier section.
X\parskip=0pt%
X%
X% We typeset the verbatim text in tt font (courier on the Macintosh) for a
X% number of reasons:
X%    - tt font has the same horizontal spacing for each character.
X%    - tt font covers the ASCII character set.
X%    - tt font doesn't have many surprises (e.g. ligatures).
X%    - tt font looks much what you might see on a computer terminal screen.
X\tt%
X%
X% Having set up an environment for verbatim, we are ready to use it.
X% By invoking \fwverbatimgobble, this \fwbtx macro gobbles up text verbatim (as
X% part of the parameter of \fwverbatimgobble) until it sees the termination
X% string "]fwetx=" (the "=" was thrown in to add obscurity as this sequence
X% must never occur in the verbatim text).
X\fwverbatimgobble}
X
X% The \fwverbatimgobble macro exists to allow \fwbtx to bracket verbatim text.
X\def\fwverbatimgobble#1]fwetx={#1\endgroup}
X
X
X% Table of Contents
X% -----------------
X% The five levels of table of contents that FunnelWeb supports are identified
X% by the five letters [A..E]. These are used throughout the following macros.
X
X% The following macros are utilities to the TOC macros to follow.
X\def\fwrule{\medskip\hrule\medskip}
X\def\fwqh{\hskip1.5em\relax}
X\def\fwbeforesec{\penalty-200\bigskip\medskip\par}
X
X% The following macros are used to typeset the table of contents.
X\def\fwtocstart#1{\fwrule\leftline{\fwfontbolda Table of Contents}\fwrule}
X\def\fwtoca#1#2{\leftline{{\bf #1 #2}}}
X\def\fwtocb#1#2{\leftline{\fwqh #1 #2}}
X\def\fwtocc#1#2{\leftline{\fwqh\fwqh #1 #2}}
X\def\fwtocd#1#2{\leftline{\fwqh\fwqh\fwqh #1 #2}}
X\def\fwtoce#1#2{\leftline{\fwqh\fwqh\fwqh\fwqh #1 #2}}
X\def\fwtocfinish#1{\fwrule}
X
X% The following "library" macros define five different strengths of headings
X% which can be used later in the section macros.
X\def\fwliba#1#2{\vfill\eject{\fwfontboldc #1 #2}\penalty200\smallskip}
X\def\fwlibb#1#2{\fwbeforesec{\fwfontboldb #1 #2}\penalty200\smallskip}
X\def\fwlibc#1#2{\fwbeforesec{\fwfontnormb #1 #2}\penalty200\smallskip}
X\def\fwlibd#1#2{\fwbeforesec{\bf          #1 #2}\penalty200}
X\def\fwlibe#1#2{\fwbeforesec{\bf          #1 #2}}
X
X% Here are the macros that actually typeset the section headings throughout
X% the document. The fwlib system has been employed so as to easily allow the
X% user to redefine the strengths of headings to taste. For example, the
X% user could insert in the input document a similar set of definitions to these
X% but with the b..e headings set to \fwlibc. This would tone down the output.
X\def\fwseca#1#2{\fwliba{#1}{#2}}
X\def\fwsecb#1#2{\fwlibb{#1}{#2}}
X\def\fwsecc#1#2{\fwlibc{#1}{#2}}
X\def\fwsecd#1#2{\fwlibd{#1}{#2}}
X\def\fwsece#1#2{\fwlibe{#1}{#2}}
X
X
X% Support for Explicit Typesetting
X% --------------------------------
X% FunnelWeb supports pragmas and other constructs that allow
X% typesetter-independent typesetting commands to be given. The
X% following macros support these features.
X
X% The in-text literal @{sloth@} and emphasise @[walrus@] features.
X\def\fwlit#1{{\tt #1}}
X\def\fwemp#1{{\it #1}}
X
X% The "@p new_page" pragma.
X\def\fwnewpage{\vfill\eject}
X
X% The "@p vskip Nmm" pragma.
X\def\fwvskip#1{\null\vskip #1mm}
X
X% The "@p title <font> <align> <text>" pragma.
X\def\fwfontnormal#1{{\fwfontnorm {#1}}}
X\def\fwfonttitle#1{{\fwfontboldd {#1}}}
X\def\fwfontsmalltitle#1{{\fwfontboldb {#1}}}
X\def\fwleftline#1{\leftline{#1}}
X\def\fwcenterline#1{\centerline{#1}}
X\def\fwrightline#1{\rightline{#1}}
X
X
X% Support for Old FunnelWeb
X% -------------------------
X% The following macros were used extensively in the first version of
X% FunnelWeb and are retained so that these older input files will still
X% typeset cleanly.
X\def\p#1{{\tt #1}}  % P for Program text.
X\def\flagpage#1#2{
X   \null
X   \vfill
X   \centerline{\fwfontboldd #1}
X   \vskip 1cm
X   \centerline{\fwfontboldd #2}
X   \vfill
X   \null
X   \vfill
X}
X
X%====================== End of FunnelWeb TeX Definitions =======================
END_OF_FILE
if test 13048 -ne `wc -c <'sources/texhead.tex'`; then
    echo shar: \"'sources/texhead.tex'\" unpacked with wrong size!
fi
# end of 'sources/texhead.tex'
fi
if test -f 'sources/writfile.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sources/writfile.h'\"
else
echo shar: Extracting \"'sources/writfile.h'\" \(11225 characters\)
sed "s/^X//" >'sources/writfile.h' <<'END_OF_FILE'
X/*##############################################################################
X
XFUNNNELWEB COPYRIGHT
X====================
XFunnelWeb is a literate-programming macro preprocessor.
X
Copyright (C) 1992 Ross N. Williams.
X
X   Ross N. Williams
X   ross@spam.adelaide.edu.au
X   16 Lerwick Avenue, Hazelwood Park 5066, Australia.
X
This program is free software; you can redistribute it and/or modify
it under the terms of Version 2 of the GNU General Public License as
published by the Free Software Foundation.
X
This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See Version 2 of the GNU General Public License for more details.
X
You should have received a copy of Version 2 of the GNU General Public
License along with this program. If not, you can FTP the license from
prep.ai.mit.edu/pub/gnu/COPYING-2 or write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Section 2a of the license requires that all changes to this file be
recorded prominently in this file. Please record all changes here.
X
Programmers:
X   RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X
Changes:
X   07-May-1992  RNW  Program prepared for release under GNU GPL V2.
X
X##############################################################################*/
X
X
X/******************************************************************************/
X/*                                   WRITFILE.H                               */
X/******************************************************************************/
X/*                                                                            */
X/* Introduction                                                               */
X/* ------------                                                               */
X/* This package performs all of FunnelWeb's file output.                      */
X/* FunnelWeb performs lots of output to lots of different files:              */
X/*                                                                            */
X/*    - Standard output (to write to the screen).                             */
X/*    - The journal file.                                                     */
X/*    - The listing file.                                                     */
X/*    - The tangle output files.                                              */
X/*    - The weave output file.                                                */
X/*                                                                            */
X/* Error Detection                                                            */
X/* ---------------                                                            */
X/* As we are serious about detecting errors, every call to every IO function  */
X/* must have its status checked. Unfortunately this makes everything very     */
X/* messy. Having to check result statuses and react to them can be very       */
X/* awkward in deeply nested pieces of code, particularly as C does not have   */
X/* exceptions. As a result, the policy adopted in FunnelWeb is to RECORD when */
X/* an error occurs on an output stream and silently shut down that stream.    */
X/* Then later, at a convenient time, the error status of the stream can be    */
X/* checked, and an error message issued.                                      */
X/*                                                                            */
X/* The C libraries make an effort to be helpful here by providing the ferror  */
X/* function. However, it is not useful here for two reasons:                  */
X/*                                                                            */
X/*    1. Some calls (e.g. fwrite) are not listed as setting the error status. */
X/*    2. It is not guaranteed that IO calls to a stream with error status     */
X/*       will not cause a crash.                                              */
X/*    3. Even if ferror were used, it may not be supported by older compilers.*/
X/*                                                                            */
X/* This package was created to take care of the vexing problems of IO errors  */
X/* in output streams. It is a layer above the ANSI file library that provides */
X/* the elementary calls for writing. It differs in that if an error occurs,   */
X/* the package records that fact and simply ignores all further operations    */
X/* on the file. At any time, it is possible to find out whether a file is in  */
X/* normal mode or error mode. All this means that a piece of code can use     */
X/* this package to create and write to a file without worrying about errors.  */
X/* Then later, when the dust settles, the package can check the status  of    */
X/* the file, and take appropriate action if an error has been detected.       */
X/*                                                                            */
X/* Text vs Binary                                                             */
X/* --------------                                                             */
X/* This package translates all '\n' (contained in the data it has been given  */
X/* to write) into the appropriate environment specific representation.        */
X/*                                                                            */
X/* Facts About WF Objects                                                     */
X/* ----------------------                                                     */
X/* - A WF object is either in NORMAL or ERROR mode.                           */
X/* - A WF object in NORMAL mode is also either in OPEN or CLOSED mode.        */
X/* - The term "raise an error" means bomb the program with a message.         */
X/* - The comments attached to the functions given below are meant to be read  */
X/*   sequentially with each action or check being performed before the next.  */
X/* - This package can not guarantee to detect uninitialized WF objects. The   */
X/*   reason is that policing is performed using magic number mechanism and it */
X/*   is possible that a piece of random memory may contain just the right     */
X/*   numbers to fool the package.                                             */
X/*                                                                            */
X/******************************************************************************/
X
X/* Ensure that the body of this header file is included at most once.         */
X#ifndef DONE_WRITFILE
X#define DONE_WRITFILE
X
X/******************************************************************************/
X
X#include "style.h"
X
X/******************************************************************************/
X
X/* We really don't want to show all the guts of this record here, but as      */
X/* users of the package have to be able to declare objects of this type and   */
X/* make them the right size, it seems as if we have no choice.                */
typedef struct
X  {
X   ulong  wf_mhead;   /* Helps detect uninitialized and corrupted records.    */
X   bool   wf_iserr;   /* TRUE=>ERROR,   FALSE=>NORMAL.                        */
X   bool   wf_isope;   /* TRUE=>OPEN,    FALSE=>CLOSED.                        */
X   bool   wf_istxt;   /* TRUE=>TEXT,    FALSE=>BINARY.                        */
X   FILE  *wf_pfile;   /* Pointer to the file object.                          */
X   ulong  wf_mtail;   /* Helps detect uninitialized and  corrupted records.   */
X  } wf_t;
X
typedef wf_t *p_wf_t;
X
X/******************************************************************************/
X
XEXPORT void wf_ini P_((p_wf_t,bool));
X/* Initializes a WF to a well defined state in accordance with the boolean.   */
X/*    FALSE => State=(ERROR).                                                 */
X/*    TRUE  => State=(NORMAL,CLOSED).                                         */
X/* wf_ini must be applied to a WF before any other operation.                 */
X/* It can be re-applied repeatedly.                                           */
X
XEXPORT void wf_att P_((p_wf_t,FILE *));
X/* If WF is uninitialized, raises an error (probably).                        */
X/* If WF is in ERROR mode, returns with no effect.                            */
X/* If WF is OPEN, raises an error.                                            */
X/* Attaches an already opened output file to the specified FW object.         */
X/* Changes the WF to the OPEN state.                                          */
X/* The memory that the second parameter points to must be stable.             */
X
XEXPORT void wf_ope P_((p_wf_t,char *));
X/* If WF is uninitialized, raises an error (probably).                        */
X/* If WF is in ERROR mode, returns with no effect.                            */
X/* If WF is OPEN, raises an error.                                            */
X/* Creates an output file of the specified name and prepares it for writing.  */
X/* Changes the WF to the OPEN state.                                          */
X/* Sets the WF to the ERROR state if the file cannot be opened for writing.   */
X
XEXPORT void wf_chr P_((p_wf_t,intchar));
X/* If WF is uninitialized, raises an error (probably).                        */
X/* If WF is in ERROR mode, returns with no effect.                            */
X/* If WF is CLOSED, raises an error.                                          */
X/* Writes the specified character to the output file associated with WF.      */
X/* Sets WF to the ERROR state if an error occurs during the write.            */
X
XEXPORT void wf_wr P_((p_wf_t,char *));
X/* Same as wf_chr except that it writes an entire string.                     */
X
XEXPORT void wf_wl P_((p_wf_t,char *));
X/* Same as wf_wr except that appends a '\n'.                                  */
X
XEXPORT void wf_blk P_((p_wf_t,char *,size_t));
X/* Same as wf_wr but writes a block of bytes whose address is given by the    */
X/* second parameter and whose length (in bytes) is given by the third         */
X/* parameter.                                                                 */
X
XEXPORT void wf_clo P_((p_wf_t));
X/* If WF is uninitialized, raises an error (probably).                        */
X/* If WF is in ERROR mode, returns with no effect.                            */
X/* If WF is CLOSED, raises an error.                                          */
X/* Flushes and closes the output file attached to WF.                         */
X/* Sets WF to the CLOSED state.                                               */
X/* Sets WF to the ERROR state if an error occurs during the close.            */
X
XEXPORT bool wf_err P_((p_wf_t));
X/* If WF is uninitialized, raises an error (probably).                        */
X/* Returns TRUE iff WF is in the ERROR state, otherwise FALSE.                */
X/* This function can be called at any time so long as the WF is initialized.  */
X
X/******************************************************************************/
X
X/* For #ifndef preventing multiple inclusion of the body of this header file. */
X#endif
X
X/******************************************************************************/
X/*                              End of WRITFILE.H                             */
X/******************************************************************************/
END_OF_FILE
if test 11225 -ne `wc -c <'sources/writfile.h'`; then
    echo shar: \"'sources/writfile.h'\" unpacked with wrong size!
fi
# end of 'sources/writfile.h'
fi
if test -f 'userman/u_manual.toc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'userman/u_manual.toc'\"
else
echo shar: Extracting \"'userman/u_manual.toc'\" \(11191 characters\)
sed "s/^X//" >'userman/u_manual.toc' <<'END_OF_FILE'
X\contentsline {chapter}{Preface}{9}
X\contentsline {chapter}{Acknowledgements}{11}
X\contentsline {chapter}{Presentation Notes}{13}
X\contentsline {chapter}{\numberline {1}A Tutorial Introduction}{15}
X\contentsline {section}{\numberline {1.1}What is Literate Programming?}{15}
X\contentsline {section}{\numberline {1.2}What is FunnelWeb?}{18}
X\contentsline {section}{\numberline {1.3}The Name FunnelWeb}{19}
X\contentsline {section}{\numberline {1.4}A FunnelWeb Tutorial}{19}
X\contentsline {section}{\numberline {1.5}A Hello World Document}{20}
X\contentsline {section}{\numberline {1.6}Macro Facilities}{22}
X\contentsline {subsection}{\numberline {1.6.1}Simple Macros}{22}
X\contentsline {subsection}{\numberline {1.6.2}Number of Times Called}{23}
X\contentsline {subsection}{\numberline {1.6.3}Indentation}{25}
X\contentsline {subsection}{\numberline {1.6.4}Additive Macros}{26}
X\contentsline {subsection}{\numberline {1.6.5}Parameterized Macros}{28}
X\contentsline {subsection}{\numberline {1.6.6}Macro Expansion}{30}
X\contentsline {subsection}{\numberline {1.6.7}Include Files}{30}
X\contentsline {section}{\numberline {1.7}Typesetting Facilities}{32}
X\contentsline {subsection}{\numberline {1.7.1}Overview}{32}
X\contentsline {subsection}{\numberline {1.7.2}Typesetter Independence}{34}
X\contentsline {subsection}{\numberline {1.7.3}Hierarchical Structure}{34}
X\contentsline {subsection}{\numberline {1.7.4}Understanding the Printed Documentation}{35}
X\contentsline {subsection}{\numberline {1.7.5}Literals and Emphasis}{37}
X\contentsline {subsection}{\numberline {1.7.6}Adding a Header Page}{37}
X\contentsline {subsection}{\numberline {1.7.7}Comments}{37}
X\contentsline {section}{\numberline {1.8}A Complete Example}{38}
X\contentsline {section}{\numberline {1.9}Summary}{39}
X\contentsline {chapter}{\numberline {2}FunnelWeb Hints}{41}
X\contentsline {section}{\numberline {2.1}Macro Names}{41}
X\contentsline {section}{\numberline {2.2}Quick Names}{42}
X\contentsline {section}{\numberline {2.3}FunnelWeb the Martinet}{42}
X\contentsline {section}{\numberline {2.4}Fiddling With End of Lines}{43}
X\contentsline {section}{\numberline {2.5}Fudging Conditionals}{44}
X\contentsline {section}{\numberline {2.6}Changing the Strength of Headings}{46}
X\contentsline {section}{\numberline {2.7}Efficiency Notes}{47}
X\contentsline {section}{\numberline {2.8}Interactive Mode}{47}
X\contentsline {section}{\numberline {2.9}Setting Up Default Options}{49}
X\contentsline {section}{\numberline {2.10}FunnelWeb and Make}{49}
X\contentsline {section}{\numberline {2.11}The Dangers of FunnelWeb}{50}
X\contentsline {section}{\numberline {2.12}Wholistic Debugging}{53}
X\contentsline {section}{\numberline {2.13}Examples of FunnelWeb Applications}{53}
X\contentsline {subsection}{\numberline {2.13.1}Analyzing the Monster Postscript Header File}{54}
X\contentsline {subsection}{\numberline {2.13.2}Making Ada ADTs more A}{55}
X\contentsline {subsection}{\numberline {2.13.3}Multiple Language Systems}{55}
X\contentsline {subsection}{\numberline {2.13.4}The Case of the Small Function}{56}
X\contentsline {subsection}{\numberline {2.13.5}When Comments are Bad}{57}
X\contentsline {subsection}{\numberline {2.13.6}Documents That Share Text}{58}
X\contentsline {subsection}{\numberline {2.13.7}Generics}{59}
X\contentsline {section}{\numberline {2.14}Summary}{62}
X\contentsline {chapter}{\numberline {3}FunnelWeb Definition}{63}
X\contentsline {section}{\numberline {3.1}Introduction}{63}
X\contentsline {section}{\numberline {3.2}Notation}{63}
X\contentsline {section}{\numberline {3.3}Terminology}{63}
X\contentsline {section}{\numberline {3.4}An Architectural Overview}{64}
X\contentsline {section}{\numberline {3.5}Diagnostics}{65}
X\contentsline {section}{\numberline {3.6}Typesetter Independence}{65}
X\contentsline {section}{\numberline {3.7}Command Line Interface}{66}
X\contentsline {subsection}{\numberline {3.7.1}Invoking FunnelWeb}{66}
X\contentsline {subsection}{\numberline {3.7.2}Command Line Arguments}{67}
X\contentsline {subsection}{\numberline {3.7.3}Options}{68}
X\contentsline {section}{\numberline {3.8}File Name Inheritance}{70}
X\contentsline {section}{\numberline {3.9}FunnelWeb Startup}{70}
X\contentsline {section}{\numberline {3.10}Scanner}{71}
X\contentsline {subsection}{\numberline {3.10.1}Basic Input File Processing}{71}
X\contentsline {subsection}{\numberline {3.10.2}Special Sequences}{72}
X\contentsline {subsection}{\numberline {3.10.3}Setting the Special Character}{74}
X\contentsline {subsection}{\numberline {3.10.4}Inserting the Special Character into the Text}{74}
X\contentsline {subsection}{\numberline {3.10.5}Inserting Arbitrary Characters into the Text}{74}
X\contentsline {subsection}{\numberline {3.10.6}Comments}{75}
X\contentsline {subsection}{\numberline {3.10.7}Quick Names}{76}
X\contentsline {subsection}{\numberline {3.10.8}Inserting End of Line Markers}{76}
X\contentsline {subsection}{\numberline {3.10.9}Suppressing End of Line Markers}{77}
X\contentsline {subsection}{\numberline {3.10.10}Include Files}{77}
X\contentsline {subsection}{\numberline {3.10.11}Pragmas}{78}
X\contentsline {subsubsection}{\numberline {3.10.11.1}Indentation}{78}
X\contentsline {subsubsection}{\numberline {3.10.11.2}Maximum Input Line Length}{79}
X\contentsline {subsubsection}{\numberline {3.10.11.3}Maximum Output File Line Length}{79}
X\contentsline {subsubsection}{\numberline {3.10.11.4}Typesetter}{80}
X\contentsline {subsection}{\numberline {3.10.12}Freestanding Typesetter Directives}{81}
X\contentsline {subsubsection}{\numberline {3.10.12.1}New Page}{81}
X\contentsline {subsubsection}{\numberline {3.10.12.2}Table of Contents}{81}
X\contentsline {subsubsection}{\numberline {3.10.12.3}Vertical Skip}{81}
X\contentsline {subsubsection}{\numberline {3.10.12.4}Title}{82}
X\contentsline {subsection}{\numberline {3.10.13}Scanner/Parser Interface}{82}
X\contentsline {section}{\numberline {3.11}Parser}{82}
X\contentsline {subsection}{\numberline {3.11.1}High Level Structure}{82}
X\contentsline {subsection}{\numberline {3.11.2}Free Text}{83}
X\contentsline {subsection}{\numberline {3.11.3}Typesetter Directives}{83}
X\contentsline {subsubsection}{\numberline {3.11.3.1}Section}{83}
X\contentsline {subsubsection}{\numberline {3.11.3.2}Literal Directive}{84}
X\contentsline {subsubsection}{\numberline {3.11.3.3}Emphasis Directive}{85}
X\contentsline {subsection}{\numberline {3.11.4}Macros}{85}
X\contentsline {subsubsection}{\numberline {3.11.4.1}Names}{86}
X\contentsline {subsubsection}{\numberline {3.11.4.2}Formal Parameter Lists}{86}
X\contentsline {subsection}{\numberline {3.11.5}Expressions}{86}
X\contentsline {subsection}{\numberline {3.11.6}Macro Calls}{86}
X\contentsline {subsection}{\numberline {3.11.7}Formal Parameters}{87}
X\contentsline {subsection}{\numberline {3.11.8}Macros are Static}{87}
X\contentsline {section}{\numberline {3.12}Analyser}{88}
X\contentsline {section}{\numberline {3.13}Tangle}{88}
X\contentsline {section}{\numberline {3.14}Weave}{89}
X\contentsline {subsection}{\numberline {3.14.1}Target Typesetter}{89}
X\contentsline {subsection}{\numberline {3.14.2}Cross Reference Numbering}{89}
X\contentsline {section}{\numberline {3.15}FunnelWeb Shell}{90}
X\contentsline {subsection}{\numberline {3.15.1}Introduction}{90}
X\contentsline {subsection}{\numberline {3.15.2}Return Statuses}{90}
X\contentsline {subsection}{\numberline {3.15.3}Command Line Length}{91}
X\contentsline {subsection}{\numberline {3.15.4}String Substitution}{91}
X\contentsline {subsection}{\numberline {3.15.5}How a Command Line is Processed}{92}
X\contentsline {subsection}{\numberline {3.15.6}Options}{92}
X\contentsline {subsection}{\numberline {3.15.7}Shell Commands}{93}
X\contentsline {subsubsection}{\numberline {3.15.7.1}Absent}{93}
X\contentsline {subsubsection}{\numberline {3.15.7.2}Codify}{93}
X\contentsline {subsubsection}{\numberline {3.15.7.3}Compare}{93}
X\contentsline {subsubsection}{\numberline {3.15.7.4}Define}{94}
X\contentsline {subsubsection}{\numberline {3.15.7.5}Diff}{94}
X\contentsline {subsubsection}{\numberline {3.15.7.6}Diffsummary}{95}
X\contentsline {subsubsection}{\numberline {3.15.7.7}Diffzero}{95}
X\contentsline {subsubsection}{\numberline {3.15.7.8}Eneo}{95}
X\contentsline {subsubsection}{\numberline {3.15.7.9}Execute}{96}
X\contentsline {subsubsection}{\numberline {3.15.7.10}Exists}{96}
X\contentsline {subsubsection}{\numberline {3.15.7.11}Fixeols}{96}
X\contentsline {subsubsection}{\numberline {3.15.7.12}Fw}{97}
X\contentsline {subsubsection}{\numberline {3.15.7.13}Help}{97}
X\contentsline {subsubsection}{\numberline {3.15.7.14}Here}{98}
X\contentsline {subsubsection}{\numberline {3.15.7.15}Quit}{98}
X\contentsline {subsubsection}{\numberline {3.15.7.16}Set}{98}
X\contentsline {subsubsection}{\numberline {3.15.7.17}Show}{98}
X\contentsline {subsubsection}{\numberline {3.15.7.18}Skipto}{98}
X\contentsline {subsubsection}{\numberline {3.15.7.19}Status}{99}
X\contentsline {subsubsection}{\numberline {3.15.7.20}Tolerate}{100}
X\contentsline {subsubsection}{\numberline {3.15.7.21}Trace}{100}
X\contentsline {subsubsection}{\numberline {3.15.7.22}Write}{100}
X\contentsline {subsubsection}{\numberline {3.15.7.23}Writeu}{100}
X\contentsline {section}{\numberline {3.16}Concluding Remarks}{100}
X\contentsline {chapter}{\numberline {4}FunnelWeb Installation}{101}
X\contentsline {section}{\numberline {4.1}Obtaining a Copy of FunnelWeb}{101}
X\contentsline {section}{\numberline {4.2}Establishing The Directory Tree}{102}
X\contentsline {subsection}{\numberline {4.2.1}Admin Directory}{102}
X\contentsline {subsection}{\numberline {4.2.2}Answers Directory}{102}
X\contentsline {subsection}{\numberline {4.2.3}Hackman Directory}{103}
X\contentsline {subsection}{\numberline {4.2.4}Results Directory}{103}
X\contentsline {subsection}{\numberline {4.2.5}Scripts Directory}{103}
X\contentsline {subsection}{\numberline {4.2.6}Sources Directory}{103}
X\contentsline {subsection}{\numberline {4.2.7}Tests Directory}{104}
X\contentsline {subsection}{\numberline {4.2.8}Userman Directory}{105}
X\contentsline {section}{\numberline {4.3}Compiling FunnelWeb}{105}
X\contentsline {section}{\numberline {4.4}Testing FunnelWeb}{105}
X\contentsline {section}{\numberline {4.5}Installing FunnelWeb}{106}
X\contentsline {section}{\numberline {4.6}Printing Manuals}{107}
X\contentsline {section}{\numberline {4.7}Installation Problems?}{107}
X\contentsline {chapter}{\numberline {5}FunnelWeb Administration}{109}
X\contentsline {section}{\numberline {5.1}Introduction}{109}
X\contentsline {section}{\numberline {5.2}The User's Commitment To FunnelWeb}{109}
X\contentsline {section}{\numberline {5.3}Documentation}{110}
X\contentsline {section}{\numberline {5.4}Registration}{110}
X\contentsline {section}{\numberline {5.5}Support}{110}
X\contentsline {section}{\numberline {5.6}Copyright}{112}
X\contentsline {section}{\numberline {5.7}Nowarranty}{112}
X\contentsline {section}{\numberline {5.8}Distribution}{113}
X\contentsline {section}{\numberline {5.9}Modification}{113}
X\contentsline {section}{\numberline {5.10}Versions}{114}
X\contentsline {section}{\numberline {5.11}FTP Archive and Author}{114}
X\contentsline {chapter}{\numberline {A}Glossary}{115}
X\contentsline {chapter}{\numberline {B}References}{117}
X\contentsline {chapter}{Index}{117}
END_OF_FILE
if test 11191 -ne `wc -c <'userman/u_manual.toc'`; then
    echo shar: \"'userman/u_manual.toc'\" unpacked with wrong size!
fi
# end of 'userman/u_manual.toc'
fi
echo shar: End of archive 5 \(of 20\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 20 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
