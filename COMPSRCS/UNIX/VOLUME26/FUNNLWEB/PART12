Newsgroups: comp.sources.unix
From: ross@spam.adelaide.edu.au (Ross Williams)
Subject: v26i132: funnelweb - a tool for literate programming in C, Part12/20
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: ross@spam.adelaide.edu.au (Ross Williams)
Posting-Number: Volume 26, Issue 132
Archive-Name: funnelweb/part12

[ several files in this archive will unpack with the wrong size, due to
  length restrictions in NNTP.  --vix ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 20)."
# Contents:  answers/sc11.lis answers/sc14.lis hackman/h_ch3.tex
#   sources/data.h sources/dump.c
# Wrapped by vixie@gw.home.vix.com on Sun Apr 11 11:00:27 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'answers/sc11.lis' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'answers/sc11.lis'\"
else
echo shar: Extracting \"'answers/sc11.lis'\" \(23578 characters\)
sed "s/^X//" >'answers/sc11.lis' <<'END_OF_FILE'
XFUNNELWEB LISTING FILE
X======================
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 31 31 3A 20 53 79 6E 74 61 78 20 6F 66 20 | SC11: Syntax of  |
X| 74 68 65 20 69 6E 63 6C 75 64 65 20 70 72 61 67 | the include prag |
X| 6D 61 2E 0A 0A 31 2E 20 54 65 73 74 20 69 6E 63 | ma...1. Test inc |
X| 6C 75 64 65 20 70 72 61 67 6D 61 20 6E 6F 74 20 | lude pragma not  |
X| 61 74 20 73 74 61 72 74 20 6F 66 20 6C 69 6E 65 | at start of line |
X| 2E 0A 0A 20 20 20 40 69 0A 0A 32 2E 20 54 65 73 | ...   @i..2. Tes |
X| 74 20 41 54 69 20 6E 6F 74 20 66 6F 6C 6C 6F 77 | t ATi not follow |
X| 65 64 20 62 79 20 61 20 62 6C 61 6E 6B 2E 0A 0A | ed by a blank... |
X| 40 69 78 0A 0A 33 2E 20 54 65 73 74 20 69 6E 63 | @ix..3. Test inc |
X| 6C 75 64 65 20 66 69 6C 65 6E 61 6D 65 20 69 73 | lude filename is |
X| 20 74 6F 6F 20 6C 6F 6E 67 2E 20 54 68 65 20 6D |  too long. The m |
X| 61 78 69 6D 75 6D 20 6F 6E 20 74 68 65 20 4D 61 | aximum on the Ma |
X| 63 69 6E 74 6F 73 68 20 69 73 0A 20 20 20 32 35 | cintosh is.   25 |
X| 35 20 62 75 74 20 77 65 20 77 69 6C 6C 20 75 73 | 5 but we will us |
X| 65 20 61 20 66 69 6C 65 6E 61 6D 65 20 6F 66 20 | e a filename of  |
X| 6F 76 65 72 20 31 30 32 34 20 63 68 61 72 61 63 | over 1024 charac |
X| 74 65 72 73 20 73 6F 20 61 73 20 74 6F 20 6D 61 | ters so as to ma |
X| 6B 65 0A 20 20 20 74 68 65 20 74 65 73 74 20 70 | ke.   the test p |
X| 6F 72 74 61 62 6C 65 2E 20 54 68 65 20 61 63 74 | ortable. The act |
X| 75 61 6C 20 6C 65 6E 67 74 68 20 75 73 65 64 20 | ual length used  |
X| 69 73 20 31 31 30 30 20 63 68 61 72 61 63 74 65 | is 1100 characte |
X| 72 73 20 69 6E 20 74 68 65 0A 20 20 20 66 69 6C | rs in the.   fil |
X| 65 6E 61 6D 65 2E 0A 0A 20 20 20 20 20 20 20 20 | ename...         |
X| 20 20 20 20 31 20 20 20 20 20 20 20 20 20 32 20 |     1         2  |
X| 20 20 20 20 20 20 20 20 33 20 20 20 20 20 20 20 |         3        |
X| 20 20 34 20 20 20 20 20 20 20 20 20 35 20 20 20 |   4         5    |
X| 20 20 20 20 20 20 36 20 20 20 20 20 20 20 20 20 |       6          |
X| 37 20 20 20 20 20 20 20 20 20 38 20 20 20 20 20 | 7         8      |
X| 20 20 20 20 39 20 20 20 20 20 20 20 20 20 30 20 |     9         0  |
X| 20 20 20 20 20 20 20 20 31 20 20 20 20 20 20 20 |         1        |
X| 20 20 32 20 20 20 20 20 20 20 20 20 33 20 20 20 |   2         3    |
X| 20 20 20 20 20 20 34 20 20 20 20 20 20 20 20 20 |       4          |
X| 35 20 20 20 20 20 20 20 20 20 36 20 20 20 20 20 | 5         6      |
X| 20 20 20 20 37 20 20 20 20 20 20 20 20 20 38 20 |     7         8  |
X| 20 20 20 20 20 20 20 20 39 20 20 20 20 20 20 20 |         9        |
X| 20 20 30 20 20 20 20 20 20 20 20 20 31 20 20 20 |   0         1    |
X| 20 20 20 20 20 20 32 20 20 20 20 20 20 20 20 20 |       2          |
X| 33 20 20 20 20 20 20 20 20 20 34 20 20 20 20 20 | 3         4      |
X| 20 20 20 20 35 20 20 20 20 20 20 20 20 20 36 20 |     5         6  |
X| 20 20 20 20 20 20 20 20 37 20 20 20 20 20 20 20 |         7        |
X| 20 20 38 20 20 20 20 20 20 20 20 20 39 20 20 20 |   8         9    |
X| 20 20 20 20 20 20 30 20 20 20 20 20 20 20 20 20 |       0          |
X| 31 20 20 20 20 20 20 20 20 20 32 20 20 20 20 20 | 1         2      |
X| 20 20 20 20 33 20 20 20 20 20 20 20 20 20 34 20 |     3         4  |
X| 20 20 20 20 20 20 20 20 35 20 20 20 20 20 20 20 |         5        |
X| 20 20 36 20 20 20 20 20 20 20 20 20 37 20 20 20 |   6         7    |
X| 20 20 20 20 20 20 38 20 20 20 20 20 20 20 20 20 |       8          |
X| 39 20 20 20 20 20 20 20 20 20 30 20 20 20 20 20 | 9         0      |
X| 20 20 20 20 31 20 20 20 20 20 20 20 20 20 32 20 |     1         2  |
X| 20 20 20 20 20 20 20 20 33 20 20 20 20 20 20 20 |         3        |
X| 20 20 34 20 20 20 20 20 20 20 20 20 35 20 20 20 |   4         5    |
X| 20 20 20 20 20 20 36 20 20 20 20 20 20 20 20 20 |       6          |
X| 37 20 20 20 20 20 20 20 20 20 38 20 20 20 20 20 | 7         8      |
X| 20 20 20 20 39 20 20 20 20 20 20 20 20 20 30 20 |     9         0  |
X| 20 20 20 20 20 20 20 20 31 20 20 20 20 20 20 20 |         1        |
X| 20 20 32 20 20 20 20 20 20 20 20 20 33 20 20 20 |   2         3    |
X| 20 20 20 20 20 20 34 20 20 20 20 20 20 20 20 20 |       4          |
X| 35 20 20 20 20 20 20 20 20 20 36 20 20 20 20 20 | 5         6      |
X| 20 20 20 20 37 20 20 20 20 20 20 20 20 20 38 20 |     7         8  |
X| 20 20 20 20 20 20 20 20 39 20 20 20 20 20 20 20 |         9        |
X| 20 20 30 20 20 20 20 20 20 20 20 20 31 20 20 20 |   0         1    |
X| 20 20 20 20 20 20 32 20 20 20 20 20 20 20 20 20 |       2          |
X| 33 20 20 20 20 20 20 20 20 20 34 20 20 20 20 20 | 3         4      |
X| 20 20 20 20 35 20 20 20 20 20 20 20 20 20 36 20 |     5         6  |
X| 20 20 20 20 20 20 20 20 37 20 20 20 20 20 20 20 |         7        |
X| 20 20 38 20 20 20 20 20 20 20 20 20 39 20 20 20 |   8         9    |
X| 20 20 20 20 20 20 30 20 20 20 20 20 20 20 20 20 |       0          |
X| 31 20 20 20 20 20 20 20 20 20 32 20 20 20 20 20 | 1         2      |
X| 20 20 20 20 33 20 20 20 20 20 20 20 20 20 34 20 |     3         4  |
X| 20 20 20 20 20 20 20 20 35 20 20 20 20 20 20 20 |         5        |
X| 20 20 36 20 20 20 20 20 20 20 20 20 37 20 20 20 |   6         7    |
X| 20 20 20 20 20 20 38 20 20 20 20 20 20 20 20 20 |       8          |
X| 39 20 20 20 20 20 20 20 20 20 30 20 20 20 20 20 | 9         0      |
X| 20 20 20 20 31 20 20 20 20 20 20 20 20 20 32 20 |     1         2  |
X| 20 20 20 20 20 20 20 20 33 20 20 20 20 20 20 20 |         3        |
X| 20 20 34 20 20 20 20 20 20 20 20 20 35 20 20 20 |   4         5    |
X| 20 20 20 20 20 20 36 20 20 20 20 20 20 20 20 20 |       6          |
X| 37 20 20 20 20 20 20 20 20 20 38 20 20 20 20 20 | 7         8      |
X| 20 20 20 20 39 20 20 20 20 20 20 20 20 20 30 20 |     9         0  |
X| 20 20 20 20 20 20 20 20 31 20 20 20 20 20 20 20 |         1        |
X| 20 20 32 20 20 20 20 20 20 20 20 20 33 20 20 20 |   2         3    |
X| 20 20 20 20 20 20 34 20 20 20 20 20 20 20 20 20 |       4          |
X| 35 20 20 20 20 20 20 20 20 20 36 20 20 20 20 20 | 5         6      |
X| 20 20 20 20 37 20 20 20 20 20 20 20 20 20 38 20 |     7         8  |
X| 20 20 20 20 20 20 20 20 39 20 20 20 20 20 20 20 |         9        |
X| 20 20 30 20 20 20 20 20 20 20 20 20 31 20 20 20 |   0         1    |
X| 20 20 20 20 20 20 32 20 20 20 20 20 20 20 20 20 |       2          |
X| 33 20 20 20 20 20 20 20 20 20 34 20 20 20 20 20 | 3         4      |
X| 20 20 20 20 35 20 20 20 20 20 20 20 20 20 36 20 |     5         6  |
X| 20 20 20 20 20 20 20 20 37 20 20 20 20 20 20 20 |         7        |
X| 20 20 38 20 20 20 20 20 20 20 20 20 39 20 20 20 |   8         9    |
X| 20 20 20 20 20 20 30 0A 40 69 20 31 32 33 34 35 |       0.@i 12345 |
X| 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 | 6789012345678901 |
X| 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 | 2345678901234567 |
X| 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 | 8901234567890123 |
X| 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 | 4567890123456789 |
X| 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 | 0123456789012345 |
X| 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 | 6789012345678901 |
X| 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 | 2345678901234567 |
X| 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 | 8901234567890123 |
X| 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 | 4567890123456789 |
X| 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 | 0123456789012345 |
X| 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 | 6789012345678901 |
X| 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 | 2345678901234567 |
X| 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 | 8901234567890123 |
X| 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 | 4567890123456789 |
X| 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 | 0123456789012345 |
X| 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 | 6789012345678901 |
X| 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 | 2345678901234567 |
X| 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 | 8901234567890123 |
X| 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 | 4567890123456789 |
X| 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 | 0123456789012345 |
X| 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 | 6789012345678901 |
X| 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 | 2345678901234567 |
X| 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 | 8901234567890123 |
X| 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 | 4567890123456789 |
X| 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 | 0123456789012345 |
X| 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 | 6789012345678901 |
X| 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 | 2345678901234567 |
X| 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 | 8901234567890123 |
X| 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 | 4567890123456789 |
X| 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 | 0123456789012345 |
X| 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 | 6789012345678901 |
X| 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 | 2345678901234567 |
X| 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 | 8901234567890123 |
X| 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 | 4567890123456789 |
X| 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 | 0123456789012345 |
X| 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 | 6789012345678901 |
X| 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 | 2345678901234567 |
X| 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 | 8901234567890123 |
X| 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 | 4567890123456789 |
X| 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 | 0123456789012345 |
X| 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 | 6789012345678901 |
X| 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 | 2345678901234567 |
X| 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 | 8901234567890123 |
X| 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 | 4567890123456789 |
X| 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 | 0123456789012345 |
X| 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 | 6789012345678901 |
X| 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 | 2345678901234567 |
X| 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 | 8901234567890123 |
X| 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 | 4567890123456789 |
X| 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 | 0123456789012345 |
X| 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 | 6789012345678901 |
X| 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 | 2345678901234567 |
X| 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 | 8901234567890123 |
X| 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 | 4567890123456789 |
X| 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 | 0123456789012345 |
X| 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 | 6789012345678901 |
X| 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 | 2345678901234567 |
X| 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 | 8901234567890123 |
X| 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 | 4567890123456789 |
X| 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 | 0123456789012345 |
X| 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 | 6789012345678901 |
X| 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 | 2345678901234567 |
X| 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 | 8901234567890123 |
X| 34 35 36 37 38 39 30 31 32 33 34 35 36 37 38 39 | 4567890123456789 |
X| 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 | 0123456789012345 |
X| 36 37 38 39 30 31 32 33 34 35 36 37 38 39 30 31 | 6789012345678901 |
X| 32 33 34 35 36 37 38 39 30 31 32 33 34 35 36 37 | 2345678901234567 |
X| 38 39 30 31 32 33 34 35 36 37 38 39 30 31 32 33 | 8901234567890123 |
X| 34 35 36 37 38 39 30 0A 0A 34 2E 20 49 6E 63 6C | 4567890..4. Incl |
X| 75 64 65 20 70 72 61 67 6D 61 20 68 61 73 20 61 | ude pragma has a |
X| 6E 20 65 6D 70 74 79 20 66 69 6C 65 6E 61 6D 65 | n empty filename |
X| 2E 20 4E 6F 74 65 3A 20 42 65 63 61 75 73 65 20 | . Note: Because  |
X| 74 68 65 20 41 54 69 20 68 61 73 20 74 6F 20 62 | the ATi has to b |
X| 65 0A 20 20 20 66 6F 6C 6C 6F 77 65 64 20 62 79 | e.   followed by |
X| 20 61 20 62 6C 61 6E 6B 2C 20 77 65 20 68 61 76 |  a blank, we hav |
X| 65 20 74 6F 20 69 6E 63 75 72 20 61 20 74 72 61 | e to incur a tra |
X| 69 6C 69 6E 67 20 62 6C 61 6E 6B 20 65 72 72 6F | iling blank erro |
X| 72 20 68 65 72 65 20 69 6E 0A 20 20 20 6F 72 64 | r here in.   ord |
X| 65 72 20 74 6F 20 70 72 6F 76 6F 6B 65 20 74 68 | er to provoke th |
X| 65 20 65 72 72 6F 72 20 77 65 20 72 65 61 6C 6C | e error we reall |
X| 79 20 77 61 6E 74 20 74 6F 20 73 65 65 2E 0A 0A | y want to see... |
X| 40 69 20 0A 0A                                  | @i ..            |
X+-------------------------------------------------+------------------+
X
X
X=========================== Start of LINE LIST DUMP ============================
X
Globl Local| Text
X-----------+--------------------------------------------------------------------
X00001 00001| SC11: Syntax of the include pragma.<010>
X00002 00002| <010>
X00003 00003| 1. Test include pragma not at start of line.<010>
X00004 00004| <010>
X00005 00005|    @i<010>
X00006 00006| <010>
X00007 00007| 2. Test ATi not followed by a blank.<010>
X00008 00008| <010>
X00009 00009| @ix<010>
X00010 00010| <010>
X00011 00011| 3. Test include filename is too long. The maximum on the Macintosh is<010>
X00012 00012|    255 but we will use a filename of over 1024 characters so as to make<010>
X00013 00013|    the test portable. The actual length used is 1100 characters in the<010>
X00014 00014|    filename.<010>
X00015 00015| <010>
X00016 00016|             1         2         (elided by comp.sources.unix moderator)7         8         9         0<010>
X00017 00017| @i 1234567890(elided by comp.sources.unix moderator)1234567890<010>
X00018 00018| <010>
X00019 00019| 4. Include pragma has an empty filename. Note: Because the ATi has to be<010>
X00020 00020|    followed by a blank, we have to incur a trailing blank error here in<010>
X00021 00021|    order to provoke the error we really want to see.<010>
X00022 00022| <010>
X00023 00023| @i <010>
X00024 00024| <010>
X00025 00025| <End-Of-File><010>
X-----------+--------------------------------------------------------------------
Globl Local| Text
X
X============================ End of LINE LIST DUMP =============================
X
X
X=========================== Start of TOKEN LIST DUMP ===========================
X
Summary: There are 6 tokens in the token list.
X
Line[Column]: Token Description
X-------------------------------
X
X0001[01]: Text. Text scrap[Grey]="SC11: Syntax of the include pragma.<010>
X<010>
X1. Test include pragma not at start of line.<010>
X<010>
X   "
X0006[01]: Text. Text scrap[Grey]="<010>
X2. Test ATi not followed by a blank.<010>
X<010>
X"
X0010[01]: Text. Text scrap[Grey]="<010>
X3. Test include filename is too long. The maximum on the Macintosh is<010>
X   255 but we will use a filename of over 1024 characters so as to make<010>
X   the test portable. The actual length used is 1100 characters in the<010>
X   filename.<010>
X<010>
X            1         2         (elided by comp.sources.unix moderator)7         8         9         0<010>
X"
X0018[01]: Text. Text scrap[Grey]="<010>
X4. Include pragma has an empty filename. Note: Because the ATi has to be<010>
X   followed by a blank, we have to incur a trailing blank error here in<010>
X   order to provoke the error we really want to see.<010>
X<010>
X"
X0024[01]: Text. Text scrap[White]="<010>
X"
X0025[01]: End Of File. 
X============================ End of TOKEN LIST DUMP ============================
X
Macro table dump skipped (Parser was not invoked).
Document list dump skipped (Parser was not invoked).
X
Global Local| Input File
X------------+-------------------------------------------------------------------
X     1     1| SC11: Syntax of the include pragma.
X     2     2| 
X     3     3| 1. Test include pragma not at start of line.
X     4     4| 
X     5     5|    @i
X       Error|....^Include sequence must be at the beginning of a line.
X            |....^Include ignored.
X     6     6| 
X     7     7| 2. Test ATi not followed by a blank.
X     8     8| 
X     9     9| @ix
X       Error|...^Include sequence (@i) must be followed by a blank.
X            |...^Example include: @i macros.fwi
X            |...^Include ignored.
X    10    10| 
X    11    11| 3. Test include filename is too long. The maximum on the Macintosh is
X    12    12|    255 but we will use a filename of over 1024 characters so as to make
X    13    13|    the test portable. The actual length used is 1100 characters in the
X    14    14|    filename.
X    15    15| 
X    16    16|             1         2        (elided by comp.sources.unix moderator) 7         8         9         0
X       Error|.................................................................................^Input line is too long (this character is the first offender).
X            |.................................................................................^Currently, the maximum allowable input line length is 80.
X            |.................................................................................^Note: You can change this using a pragma directive (@p).
X    17    17| @i 1234567890(elided by comp.sources.unix moderator)1234567890
X       Error|.^This include command's file specification is too long.
X            |.^The maximum file name length is <<Suppressed>> characters.
X            |.^Include ignored.
X       Error|.................................................................................^Input line is too long (this character is the first offender).
X            |.................................................................................^Currently, the maximum allowable input line length is 80.
X            |.................................................................................^Note: You can change this using a pragma directive (@p).
X    18    18| 
X    19    19| 4. Include pragma has an empty filename. Note: Because the ATi has to be
X    20    20|    followed by a blank, we have to incur a trailing blank error here in
X    21    21|    order to provoke the error we really want to see.
X    22    22| 
X    23    23| @i 
X     Warning|...^Line has trailing spaces up to and including this space.
X       Error|....^Expecting the name of a file to include.
X    24    24| 
X            | <End-Of-File>
X------------+-------------------------------------------------------------------
X
There were 6 Errors and 1 Warning.
END_OF_FILE
if test 23578 -ne `wc -c <'answers/sc11.lis'`; then
    echo shar: \"'answers/sc11.lis'\" unpacked with wrong size!
fi
# end of 'answers/sc11.lis'
fi
if test -f 'answers/sc14.lis' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'answers/sc14.lis'\"
else
echo shar: Extracting \"'answers/sc14.lis'\" \(22685 characters\)
sed "s/^X//" >'answers/sc14.lis' <<'END_OF_FILE'
XFUNNELWEB LISTING FILE
X======================
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 31 34 3A 20 54 65 73 74 20 74 68 61 74 20 | SC14: Test that  |
X| 74 68 65 20 6D 61 78 69 6D 75 6D 20 6E 75 6D 62 | the maximum numb |
X| 65 72 20 6F 66 20 6C 65 76 65 6C 73 20 6F 66 20 | er of levels of  |
X| 69 6E 63 6C 75 64 65 20 66 69 6C 65 20 69 73 20 | include file is  |
X| 31 30 2E 0A 54 68 69 73 20 69 73 20 6D 6F 73 74 | 10..This is most |
X| 20 65 61 73 69 6C 79 20 64 6F 6E 65 20 77 69 74 |  easily done wit |
X| 68 20 61 20 72 65 63 75 72 73 69 76 65 20 69 6E | h a recursive in |
X| 63 6C 75 73 69 6F 6E 2E 0A 0A 42 65 66 6F 72 65 | clusion...Before |
X| 20 74 68 65 20 69 6E 63 6C 75 64 65 0A 40 69 20 |  the include.@i  |
X| 73 63 31 34 2E 66 77 0A 41 66 74 65 72 20 74 68 | sc14.fw.After th |
X| 65 20 69 6E 63 6C 75 64 65 0A                   | e include.       |
X+-------------------------------------------------+------------------+
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 31 34 3A 20 54 65 73 74 20 74 68 61 74 20 | SC14: Test that  |
X| 74 68 65 20 6D 61 78 69 6D 75 6D 20 6E 75 6D 62 | the maximum numb |
X| 65 72 20 6F 66 20 6C 65 76 65 6C 73 20 6F 66 20 | er of levels of  |
X| 69 6E 63 6C 75 64 65 20 66 69 6C 65 20 69 73 20 | include file is  |
X| 31 30 2E 0A 54 68 69 73 20 69 73 20 6D 6F 73 74 | 10..This is most |
X| 20 65 61 73 69 6C 79 20 64 6F 6E 65 20 77 69 74 |  easily done wit |
X| 68 20 61 20 72 65 63 75 72 73 69 76 65 20 69 6E | h a recursive in |
X| 63 6C 75 73 69 6F 6E 2E 0A 0A 42 65 66 6F 72 65 | clusion...Before |
X| 20 74 68 65 20 69 6E 63 6C 75 64 65 0A 40 69 20 |  the include.@i  |
X| 73 63 31 34 2E 66 77 0A 41 66 74 65 72 20 74 68 | sc14.fw.After th |
X| 65 20 69 6E 63 6C 75 64 65 0A                   | e include.       |
X+-------------------------------------------------+------------------+
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 31 34 3A 20 54 65 73 74 20 74 68 61 74 20 | SC14: Test that  |
X| 74 68 65 20 6D 61 78 69 6D 75 6D 20 6E 75 6D 62 | the maximum numb |
X| 65 72 20 6F 66 20 6C 65 76 65 6C 73 20 6F 66 20 | er of levels of  |
X| 69 6E 63 6C 75 64 65 20 66 69 6C 65 20 69 73 20 | include file is  |
X| 31 30 2E 0A 54 68 69 73 20 69 73 20 6D 6F 73 74 | 10..This is most |
X| 20 65 61 73 69 6C 79 20 64 6F 6E 65 20 77 69 74 |  easily done wit |
X| 68 20 61 20 72 65 63 75 72 73 69 76 65 20 69 6E | h a recursive in |
X| 63 6C 75 73 69 6F 6E 2E 0A 0A 42 65 66 6F 72 65 | clusion...Before |
X| 20 74 68 65 20 69 6E 63 6C 75 64 65 0A 40 69 20 |  the include.@i  |
X| 73 63 31 34 2E 66 77 0A 41 66 74 65 72 20 74 68 | sc14.fw.After th |
X| 65 20 69 6E 63 6C 75 64 65 0A                   | e include.       |
X+-------------------------------------------------+------------------+
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 31 34 3A 20 54 65 73 74 20 74 68 61 74 20 | SC14: Test that  |
X| 74 68 65 20 6D 61 78 69 6D 75 6D 20 6E 75 6D 62 | the maximum numb |
X| 65 72 20 6F 66 20 6C 65 76 65 6C 73 20 6F 66 20 | er of levels of  |
X| 69 6E 63 6C 75 64 65 20 66 69 6C 65 20 69 73 20 | include file is  |
X| 31 30 2E 0A 54 68 69 73 20 69 73 20 6D 6F 73 74 | 10..This is most |
X| 20 65 61 73 69 6C 79 20 64 6F 6E 65 20 77 69 74 |  easily done wit |
X| 68 20 61 20 72 65 63 75 72 73 69 76 65 20 69 6E | h a recursive in |
X| 63 6C 75 73 69 6F 6E 2E 0A 0A 42 65 66 6F 72 65 | clusion...Before |
X| 20 74 68 65 20 69 6E 63 6C 75 64 65 0A 40 69 20 |  the include.@i  |
X| 73 63 31 34 2E 66 77 0A 41 66 74 65 72 20 74 68 | sc14.fw.After th |
X| 65 20 69 6E 63 6C 75 64 65 0A                   | e include.       |
X+-------------------------------------------------+------------------+
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 31 34 3A 20 54 65 73 74 20 74 68 61 74 20 | SC14: Test that  |
X| 74 68 65 20 6D 61 78 69 6D 75 6D 20 6E 75 6D 62 | the maximum numb |
X| 65 72 20 6F 66 20 6C 65 76 65 6C 73 20 6F 66 20 | er of levels of  |
X| 69 6E 63 6C 75 64 65 20 66 69 6C 65 20 69 73 20 | include file is  |
X| 31 30 2E 0A 54 68 69 73 20 69 73 20 6D 6F 73 74 | 10..This is most |
X| 20 65 61 73 69 6C 79 20 64 6F 6E 65 20 77 69 74 |  easily done wit |
X| 68 20 61 20 72 65 63 75 72 73 69 76 65 20 69 6E | h a recursive in |
X| 63 6C 75 73 69 6F 6E 2E 0A 0A 42 65 66 6F 72 65 | clusion...Before |
X| 20 74 68 65 20 69 6E 63 6C 75 64 65 0A 40 69 20 |  the include.@i  |
X| 73 63 31 34 2E 66 77 0A 41 66 74 65 72 20 74 68 | sc14.fw.After th |
X| 65 20 69 6E 63 6C 75 64 65 0A                   | e include.       |
X+-------------------------------------------------+------------------+
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 31 34 3A 20 54 65 73 74 20 74 68 61 74 20 | SC14: Test that  |
X| 74 68 65 20 6D 61 78 69 6D 75 6D 20 6E 75 6D 62 | the maximum numb |
X| 65 72 20 6F 66 20 6C 65 76 65 6C 73 20 6F 66 20 | er of levels of  |
X| 69 6E 63 6C 75 64 65 20 66 69 6C 65 20 69 73 20 | include file is  |
X| 31 30 2E 0A 54 68 69 73 20 69 73 20 6D 6F 73 74 | 10..This is most |
X| 20 65 61 73 69 6C 79 20 64 6F 6E 65 20 77 69 74 |  easily done wit |
X| 68 20 61 20 72 65 63 75 72 73 69 76 65 20 69 6E | h a recursive in |
X| 63 6C 75 73 69 6F 6E 2E 0A 0A 42 65 66 6F 72 65 | clusion...Before |
X| 20 74 68 65 20 69 6E 63 6C 75 64 65 0A 40 69 20 |  the include.@i  |
X| 73 63 31 34 2E 66 77 0A 41 66 74 65 72 20 74 68 | sc14.fw.After th |
X| 65 20 69 6E 63 6C 75 64 65 0A                   | e include.       |
X+-------------------------------------------------+------------------+
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 31 34 3A 20 54 65 73 74 20 74 68 61 74 20 | SC14: Test that  |
X| 74 68 65 20 6D 61 78 69 6D 75 6D 20 6E 75 6D 62 | the maximum numb |
X| 65 72 20 6F 66 20 6C 65 76 65 6C 73 20 6F 66 20 | er of levels of  |
X| 69 6E 63 6C 75 64 65 20 66 69 6C 65 20 69 73 20 | include file is  |
X| 31 30 2E 0A 54 68 69 73 20 69 73 20 6D 6F 73 74 | 10..This is most |
X| 20 65 61 73 69 6C 79 20 64 6F 6E 65 20 77 69 74 |  easily done wit |
X| 68 20 61 20 72 65 63 75 72 73 69 76 65 20 69 6E | h a recursive in |
X| 63 6C 75 73 69 6F 6E 2E 0A 0A 42 65 66 6F 72 65 | clusion...Before |
X| 20 74 68 65 20 69 6E 63 6C 75 64 65 0A 40 69 20 |  the include.@i  |
X| 73 63 31 34 2E 66 77 0A 41 66 74 65 72 20 74 68 | sc14.fw.After th |
X| 65 20 69 6E 63 6C 75 64 65 0A                   | e include.       |
X+-------------------------------------------------+------------------+
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 31 34 3A 20 54 65 73 74 20 74 68 61 74 20 | SC14: Test that  |
X| 74 68 65 20 6D 61 78 69 6D 75 6D 20 6E 75 6D 62 | the maximum numb |
X| 65 72 20 6F 66 20 6C 65 76 65 6C 73 20 6F 66 20 | er of levels of  |
X| 69 6E 63 6C 75 64 65 20 66 69 6C 65 20 69 73 20 | include file is  |
X| 31 30 2E 0A 54 68 69 73 20 69 73 20 6D 6F 73 74 | 10..This is most |
X| 20 65 61 73 69 6C 79 20 64 6F 6E 65 20 77 69 74 |  easily done wit |
X| 68 20 61 20 72 65 63 75 72 73 69 76 65 20 69 6E | h a recursive in |
X| 63 6C 75 73 69 6F 6E 2E 0A 0A 42 65 66 6F 72 65 | clusion...Before |
X| 20 74 68 65 20 69 6E 63 6C 75 64 65 0A 40 69 20 |  the include.@i  |
X| 73 63 31 34 2E 66 77 0A 41 66 74 65 72 20 74 68 | sc14.fw.After th |
X| 65 20 69 6E 63 6C 75 64 65 0A                   | e include.       |
X+-------------------------------------------------+------------------+
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 31 34 3A 20 54 65 73 74 20 74 68 61 74 20 | SC14: Test that  |
X| 74 68 65 20 6D 61 78 69 6D 75 6D 20 6E 75 6D 62 | the maximum numb |
X| 65 72 20 6F 66 20 6C 65 76 65 6C 73 20 6F 66 20 | er of levels of  |
X| 69 6E 63 6C 75 64 65 20 66 69 6C 65 20 69 73 20 | include file is  |
X| 31 30 2E 0A 54 68 69 73 20 69 73 20 6D 6F 73 74 | 10..This is most |
X| 20 65 61 73 69 6C 79 20 64 6F 6E 65 20 77 69 74 |  easily done wit |
X| 68 20 61 20 72 65 63 75 72 73 69 76 65 20 69 6E | h a recursive in |
X| 63 6C 75 73 69 6F 6E 2E 0A 0A 42 65 66 6F 72 65 | clusion...Before |
X| 20 74 68 65 20 69 6E 63 6C 75 64 65 0A 40 69 20 |  the include.@i  |
X| 73 63 31 34 2E 66 77 0A 41 66 74 65 72 20 74 68 | sc14.fw.After th |
X| 65 20 69 6E 63 6C 75 64 65 0A                   | e include.       |
X+-------------------------------------------------+------------------+
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 31 34 3A 20 54 65 73 74 20 74 68 61 74 20 | SC14: Test that  |
X| 74 68 65 20 6D 61 78 69 6D 75 6D 20 6E 75 6D 62 | the maximum numb |
X| 65 72 20 6F 66 20 6C 65 76 65 6C 73 20 6F 66 20 | er of levels of  |
X| 69 6E 63 6C 75 64 65 20 66 69 6C 65 20 69 73 20 | include file is  |
X| 31 30 2E 0A 54 68 69 73 20 69 73 20 6D 6F 73 74 | 10..This is most |
X| 20 65 61 73 69 6C 79 20 64 6F 6E 65 20 77 69 74 |  easily done wit |
X| 68 20 61 20 72 65 63 75 72 73 69 76 65 20 69 6E | h a recursive in |
X| 63 6C 75 73 69 6F 6E 2E 0A 0A 42 65 66 6F 72 65 | clusion...Before |
X| 20 74 68 65 20 69 6E 63 6C 75 64 65 0A 40 69 20 |  the include.@i  |
X| 73 63 31 34 2E 66 77 0A 41 66 74 65 72 20 74 68 | sc14.fw.After th |
X| 65 20 69 6E 63 6C 75 64 65 0A                   | e include.       |
X+-------------------------------------------------+------------------+
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 53 43 31 34 3A 20 54 65 73 74 20 74 68 61 74 20 | SC14: Test that  |
X| 74 68 65 20 6D 61 78 69 6D 75 6D 20 6E 75 6D 62 | the maximum numb |
X| 65 72 20 6F 66 20 6C 65 76 65 6C 73 20 6F 66 20 | er of levels of  |
X| 69 6E 63 6C 75 64 65 20 66 69 6C 65 20 69 73 20 | include file is  |
X| 31 30 2E 0A 54 68 69 73 20 69 73 20 6D 6F 73 74 | 10..This is most |
X| 20 65 61 73 69 6C 79 20 64 6F 6E 65 20 77 69 74 |  easily done wit |
X| 68 20 61 20 72 65 63 75 72 73 69 76 65 20 69 6E | h a recursive in |
X| 63 6C 75 73 69 6F 6E 2E 0A 0A 42 65 66 6F 72 65 | clusion...Before |
X| 20 74 68 65 20 69 6E 63 6C 75 64 65 0A 40 69 20 |  the include.@i  |
X| 73 63 31 34 2E 66 77 0A 41 66 74 65 72 20 74 68 | sc14.fw.After th |
X| 65 20 69 6E 63 6C 75 64 65 0A                   | e include.       |
X+-------------------------------------------------+------------------+
X
X
X=========================== Start of LINE LIST DUMP ============================
X
Globl Local| Text
X-----------+--------------------------------------------------------------------
X00001 00001| SC14: Test that the maximum number of levels of include file is 10.<010>
X00002 00002| This is most easily done with a recursive inclusion.<010>
X00003 00003| <010>
X00004 00004| Before the include<010>
X00005 00005| @i sc14.fw<010>
X00006 00001| SC14: Test that the maximum number of levels of include file is 10.<010>
X00007 00002| This is most easily done with a recursive inclusion.<010>
X00008 00003| <010>
X00009 00004| Before the include<010>
X00010 00005| @i sc14.fw<010>
X00011 00001| SC14: Test that the maximum number of levels of include file is 10.<010>
X00012 00002| This is most easily done with a recursive inclusion.<010>
X00013 00003| <010>
X00014 00004| Before the include<010>
X00015 00005| @i sc14.fw<010>
X00016 00001| SC14: Test that the maximum number of levels of include file is 10.<010>
X00017 00002| This is most easily done with a recursive inclusion.<010>
X00018 00003| <010>
X00019 00004| Before the include<010>
X00020 00005| @i sc14.fw<010>
X00021 00001| SC14: Test that the maximum number of levels of include file is 10.<010>
X00022 00002| This is most easily done with a recursive inclusion.<010>
X00023 00003| <010>
X00024 00004| Before the include<010>
X00025 00005| @i sc14.fw<010>
X00026 00001| SC14: Test that the maximum number of levels of include file is 10.<010>
X00027 00002| This is most easily done with a recursive inclusion.<010>
X00028 00003| <010>
X00029 00004| Before the include<010>
X00030 00005| @i sc14.fw<010>
X00031 00001| SC14: Test that the maximum number of levels of include file is 10.<010>
X00032 00002| This is most easily done with a recursive inclusion.<010>
X00033 00003| <010>
X00034 00004| Before the include<010>
X00035 00005| @i sc14.fw<010>
X00036 00001| SC14: Test that the maximum number of levels of include file is 10.<010>
X00037 00002| This is most easily done with a recursive inclusion.<010>
X00038 00003| <010>
X00039 00004| Before the include<010>
X00040 00005| @i sc14.fw<010>
X00041 00001| SC14: Test that the maximum number of levels of include file is 10.<010>
X00042 00002| This is most easily done with a recursive inclusion.<010>
X00043 00003| <010>
X00044 00004| Before the include<010>
X00045 00005| @i sc14.fw<010>
X00046 00001| SC14: Test that the maximum number of levels of include file is 10.<010>
X00047 00002| This is most easily done with a recursive inclusion.<010>
X00048 00003| <010>
X00049 00004| Before the include<010>
X00050 00005| @i sc14.fw<010>
X00051 00001| SC14: Test that the maximum number of levels of include file is 10.<010>
X00052 00002| This is most easily done with a recursive inclusion.<010>
X00053 00003| <010>
X00054 00004| Before the include<010>
X00055 00005| @i sc14.fw<010>
X00056 00006| After the include<010>
X00057 00006| After the include<010>
X00058 00006| After the include<010>
X00059 00006| After the include<010>
X00060 00006| After the include<010>
X00061 00006| After the include<010>
X00062 00006| After the include<010>
X00063 00006| After the include<010>
X00064 00006| After the include<010>
X00065 00006| After the include<010>
X00066 00006| After the include<010>
X00067 00007| <End-Of-File><010>
X-----------+--------------------------------------------------------------------
Globl Local| Text
X
X============================ End of LINE LIST DUMP =============================
X
X
X=========================== Start of TOKEN LIST DUMP ===========================
X
Summary: There are 23 tokens in the token list.
X
Line[Column]: Token Description
X-------------------------------
X
X0001[01]: Text. Text scrap[Grey]="SC14: Test that the maximum number of levels of include file is 10.<010>
This is most easily done with a recursive inclusion.<010>
X<010>
Before the include<010>
X"
X0006[01]: Text. Text scrap[Grey]="SC14: Test that the maximum number of levels of include file is 10.<010>
This is most easily done with a recursive inclusion.<010>
X<010>
Before the include<010>
X"
X0011[01]: Text. Text scrap[Grey]="SC14: Test that the maximum number of levels of include file is 10.<010>
This is most easily done with a recursive inclusion.<010>
X<010>
Before the include<010>
X"
X0016[01]: Text. Text scrap[Grey]="SC14: Test that the maximum number of levels of include file is 10.<010>
This is most easily done with a recursive inclusion.<010>
X<010>
Before the include<010>
X"
X0021[01]: Text. Text scrap[Grey]="SC14: Test that the maximum number of levels of include file is 10.<010>
This is most easily done with a recursive inclusion.<010>
X<010>
Before the include<010>
X"
X0026[01]: Text. Text scrap[Grey]="SC14: Test that the maximum number of levels of include file is 10.<010>
This is most easily done with a recursive inclusion.<010>
X<010>
Before the include<010>
X"
X0031[01]: Text. Text scrap[Grey]="SC14: Test that the maximum number of levels of include file is 10.<010>
This is most easily done with a recursive inclusion.<010>
X<010>
Before the include<010>
X"
X0036[01]: Text. Text scrap[Grey]="SC14: Test that the maximum number of levels of include file is 10.<010>
This is most easily done with a recursive inclusion.<010>
X<010>
Before the include<010>
X"
X0041[01]: Text. Text scrap[Grey]="SC14: Test that the maximum number of levels of include file is 10.<010>
This is most easily done with a recursive inclusion.<010>
X<010>
Before the include<010>
X"
X0046[01]: Text. Text scrap[Grey]="SC14: Test that the maximum number of levels of include file is 10.<010>
This is most easily done with a recursive inclusion.<010>
X<010>
Before the include<010>
X"
X0051[01]: Text. Text scrap[Grey]="SC14: Test that the maximum number of levels of include file is 10.<010>
This is most easily done with a recursive inclusion.<010>
X<010>
Before the include<010>
X"
X0056[01]: Text. Text scrap[Grey]="After the include<010>
X"
X0057[01]: Text. Text scrap[Grey]="After the include<010>
X"
X0058[01]: Text. Text scrap[Grey]="After the include<010>
X"
X0059[01]: Text. Text scrap[Grey]="After the include<010>
X"
X0060[01]: Text. Text scrap[Grey]="After the include<010>
X"
X0061[01]: Text. Text scrap[Grey]="After the include<010>
X"
X0062[01]: Text. Text scrap[Grey]="After the include<010>
X"
X0063[01]: Text. Text scrap[Grey]="After the include<010>
X"
X0064[01]: Text. Text scrap[Grey]="After the include<010>
X"
X0065[01]: Text. Text scrap[Grey]="After the include<010>
X"
X0066[01]: Text. Text scrap[Grey]="After the include<010>
X"
X0067[01]: End Of File. 
X============================ End of TOKEN LIST DUMP ============================
X
Macro table dump skipped (Parser was not invoked).
Document list dump skipped (Parser was not invoked).
X
Global Local| Input File
X------------+-------------------------------------------------------------------
X     1     1| SC14: Test that the maximum number of levels of include file is 10.
X     2     2| This is most easily done with a recursive inclusion.
X     3     3| 
X     4     4| Before the include
X     5     5| @i sc14.fw
X     6     1| SC14: Test that the maximum number of levels of include file is 10.
X     7     2| This is most easily done with a recursive inclusion.
X     8     3| 
X     9     4| Before the include
X    10     5| @i sc14.fw
X    11     1| SC14: Test that the maximum number of levels of include file is 10.
X    12     2| This is most easily done with a recursive inclusion.
X    13     3| 
X    14     4| Before the include
X    15     5| @i sc14.fw
X    16     1| SC14: Test that the maximum number of levels of include file is 10.
X    17     2| This is most easily done with a recursive inclusion.
X    18     3| 
X    19     4| Before the include
X    20     5| @i sc14.fw
X    21     1| SC14: Test that the maximum number of levels of include file is 10.
X    22     2| This is most easily done with a recursive inclusion.
X    23     3| 
X    24     4| Before the include
X    25     5| @i sc14.fw
X    26     1| SC14: Test that the maximum number of levels of include file is 10.
X    27     2| This is most easily done with a recursive inclusion.
X    28     3| 
X    29     4| Before the include
X    30     5| @i sc14.fw
X    31     1| SC14: Test that the maximum number of levels of include file is 10.
X    32     2| This is most easily done with a recursive inclusion.
X    33     3| 
X    34     4| Before the include
X    35     5| @i sc14.fw
X    36     1| SC14: Test that the maximum number of levels of include file is 10.
X    37     2| This is most easily done with a recursive inclusion.
X    38     3| 
X    39     4| Before the include
X    40     5| @i sc14.fw
X    41     1| SC14: Test that the maximum number of levels of include file is 10.
X    42     2| This is most easily done with a recursive inclusion.
X    43     3| 
X    44     4| Before the include
X    45     5| @i sc14.fw
X    46     1| SC14: Test that the maximum number of levels of include file is 10.
X    47     2| This is most easily done with a recursive inclusion.
X    48     3| 
X    49     4| Before the include
X    50     5| @i sc14.fw
X    51     1| SC14: Test that the maximum number of levels of include file is 10.
X    52     2| This is most easily done with a recursive inclusion.
X    53     3| 
X    54     4| Before the include
X    55     5| @i sc14.fw
X       Error|.^This include file is nested too deeply. It's probably recursive.
X            |.^The maximum level of nested includes is 10.
X            |.^Include ignored.
X    56     6| After the include
X    57     6| After the include
X    58     6| After the include
X    59     6| After the include
X    60     6| After the include
X    61     6| After the include
X    62     6| After the include
X    63     6| After the include
X    64     6| After the include
X    65     6| After the include
X    66     6| After the include
X            | <End-Of-File>
X------------+-------------------------------------------------------------------
X
There was 1 Error.
END_OF_FILE
if test 22685 -ne `wc -c <'answers/sc14.lis'`; then
    echo shar: \"'answers/sc14.lis'\" unpacked with wrong size!
fi
# end of 'answers/sc14.lis'
fi
if test -f 'hackman/h_ch3.tex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hackman/h_ch3.tex'\"
else
echo shar: Extracting \"'hackman/h_ch3.tex'\" \(25736 characters\)
sed "s/^X//" >'hackman/h_ch3.tex' <<'END_OF_FILE'
X%==============================================================================%
X%                              Start of Ch3.tex                                %
X%==============================================================================%
X%
X% Copyright
X% ---------
X% Copyright (C) 1992 Ross N. Williams.
X% This file contains a chapter of the FunnelWeb Hacker's Manual.
X% See the main TeX file for this manual for further information.
X%
X%==============================================================================%
X
X\chapter{FunnelWeb Modification}
X\label{chapmod}\xx{FunnelWeb}{modification}
X
X\section{Introduction}
X
This chapter deals with modifications to FunnelWeb. Although the
GNU license\xx{GNU}{license}
under which FunnelWeb is distributed allows anyone to
modify FunnelWeb and distribute the modified versions, there are a number of
dangers in doing this. This chapter explains the dangers and presents
some issues that you should think about if you intend to
distribute modified versions of FunnelWeb.
X
X\section{The Danger of Modifying Languages}
X\xx{changes}{dangers}\xx{languages}{dangers}
X
Whenever someone modifies a computer program they should always ask
themselves \dq{what is the impact of these changes going to be on
users}. For mature products, the degree of impact is largely determined
by the investment that users have made in particular file formats
supported by the product.
X
At the two extremes, there are the video game\x{video game} and the
compiler.\x{compiler}
If one changes a video game, the change affects only the future games
played. However, if one changes a compiler in particular ways,
it is likely that thousands of users will be forced to change millions
of source files to accommodate the new version. Thus the impact of changes
to a program depends largely on the investment made by users, in
source files, training, and even muscle memory!
X
XFunnelWeb lies very much at the compiler end of this spectrum. In fact
it lies even further. Not only does it implement a language, but it is
currently the \i{only} implementation of that language! This means that,
although they shouldn't, people will be tempted to treat the FunnelWeb
program as the definition of its input language instead of
the definition chapter in the \i{FunnelWeb User's Manual},
which takes precedence.
X
Because FunnelWeb defines an input language, and people will write programs
using that language, particular kinds of changes in the language will
impact severely on users. Three different kinds of change are discussed
below.
X
X\narrowthing{Removing features:}{Removal\xx{removing}{features}
of features (featurectomy) is extremely
difficult once the user base has started using them. If a feature is
removed, users of the program will have to go through all their
programs and find a way to simulate the effect of the removed feature
with other features. Often this is so unthinkable, that bad language
constructs are tolerated far beyond their useful lifetime.}
X
X\narrowthing{Modifying features:}{Modification\xx{features}{modification}
of features has less
direct impact than the removal of features, but can cause more subtle errors.
XFor example, consider the sorts of subtle errors that might arise if the
semantics of the FunnelWeb comment \p{@!} were changed so that it no
longer includes the end of line marker. Anyone modifying features should
be sure that they are not inadvertently laying traps.}
X
X\narrowthing{Adding features:}{Although\xx{features}{adding}
the addition of features is
generally the most painless for the user community, as Hoare points
out, it is also the most dangerous in the long run.}
X
X\begin{quotation}
X\dq{When any new language design project is nearing completion, there is
always a mad rush to get new features added before standardization.
The rush is mad indeed, because it leads into a trap from which there is
no escape. A feature which is omitted can always be added later, when its
design and its implications are well understood. A feature which is
included before it is fully understood can never be removed
later.}\paper{Hoare80}
X\end{quotation}
X
These problems exist even when there is a central authority.
If we consider the case where there is no central authority, and
users modify a language and its implementations and distribute the
modified versions, the result is even worse. For a start, the
structure of the genealogy of the program\xx{genealogy}{program}
changes from a list to a tree.
This makes it impossible to impose an ordering on the different versions
and makes it difficult to merge them once they diverge. Second, it
reduces the portability of files created under different versions.
Third, it makes adding features hazardous. If a feature is added in
one version, files will be created that use it. These files will
immediately become non-portable. Furthermore, two programmers may
introduce different features that use the same syntactical constructs,
thus preventing the two versions from ever being merged. Worse, two
programmers could introduce \i{similar} features that use the
same syntactical constructs, producing even more subtle problems.
X
The only way to avoid all these problems is to create some sort of
central design authority,\xx{design}{authority}
X(or, at the very least, some sort of design
synchronization) that controls the language and its implementation.
X
The benefits of tight control over the language are enormous.
X
X\narrowthing{Universal portability:}{Source files can be treated as portable.
If all the language
implementations in the world are singing the same tune, then someone
in Sydney could send a file to someone in New York and be
sure that it will be successfully processed.}
X
X\narrowthing{Clear semantics:}{Doubt about the semantics of the
language will be greatly minimized.
So long as more than one slightly differing version of a language exists,
there will be confusion over the semantics of its constructs. A good
example is the confusion between the AT\&T Unix\x{Unix}
and Berkeley Unix shell languages.}
X
While changes to the language supported by a piece of software is the
most serious problem associated with multiple versions of software,
the lesser problem of keeping track of changes that don't affect the
language that the software implements can also cause trouble. Merging
different versions of software is extremely tedious as anyone who
has tried it will verify. However, changes not affecting the
language are far less serious because they impact only on the program
itself, not on the far more numerous source files that depend on it.
X
X\section{Authority vs User Security}
X\xx{security}{authority}
X
There are a number of ways of providing the
strong central design authority required to produce
the portability and semantic security desired by users,
X
X\begin{itemize}
X
X\item Trade mark\x{trademark}
the name of the language. Publish a specification of the
language under the trade name. Warn all users not to trust any
implementation that does not guarantee that it implements the language.
Then control implementations by only licensing the trade mark to conforming
implementations.
X
X\item Create a single implementation of the language. Do not release
the source code to the implementation. Release only binary executables.
X
X\item Release the source code to the implementation, but under a license
that prohibits the distribution of modified versions.
X
X\end{itemize}
X
Many other variations on these themes are possible, but they are all
based on the idea of regulating either the \dq{official}
definition of the language
or all of its existing implementations.
X
At about this stage, a conflict arises. While users want the language
they are using to be tightly controlled, they also want to feel secure
about the availability of its implementations. If hundreds of source
files are to be created in the language, there had better be one or
more translators available when the time comes to use them.
X
In the case of widely-used programming languages such as~C, the problem of
securing implementations does not arise. If you don't get your
compiler from Borland, you can get it from Microsoft. However, in the
case of a newly introduced language such as FunnelWeb, there may be
very few implementations, or even just one implementation,
and this poses a danger to the
user who is committing to that format. Despite the best intentions of the
copyright owner, there are a variety of ways in which a computer
program can suddenly become
unavailable.\xx{program}{availability} Here are some examples:
X
X\begin{itemize}
X
X\item If the program is owned by a company and the company goes broke,
the liquidators may not bother to place the software in the public domain.
X
X\item If the program is owned by a kindly individual who issues licenses
for free, and that individual suddenly dies, users might suddenly find
themselves negotiating with hard-nosed estate executors for the rights
to continue using the program.
X
X\item If whoever owns the program does not upgrade the program every so
often, it is actually possible for the released
executables to \dq{expire} when new operating system upgrades appear.
X
X\end{itemize}
X
These possibilities mean that users about to invest in a newly
introduced programming
tool such as FunnelWeb have legitimate concerns when they worry
about the tool's availability. For non-commercially
distributed  tools such as FunnelWeb, the simplest solution to this
problem is to make the source code available, either by placing it
into the public domain, or by releasing it under some kind of
public license, such as a GNU license.
The trouble with releasing the source code
is that it removes control from the design
authority. Once the code is \dq{out} there is no stopping anyone
from modifying the program and distributing modified versions.
All chaos can ensue.
X
One solution to this conflict is to take the trade mark approach. This
separates the right of the design authority to control the language and
its implementations, and the right of the users to use the source
code in any way they like (but they may have to change its name!).
However, the trade mark approach is expensive.
X
The solution that I (Ross Williams (\p{ross@spam.adelaide.edu.au}))
have adopted is to release the FunnelWeb source code under a GNU license
and then to write this chapter in the \i{FunnelWeb
Hacker's Manual} to dissuade possible hackers from
releasing modified versions under the FunnelWeb name.
This is about as close to the GNU/trademark approach
I can get without forking out about \$1200 for a US trademark
or paying even more to get a lawyer to attempt to draft a contract
stating \dq{thou shalt not modify the FunnelWeb language}.
X
X\section{What I Want to Protect}
X\xx{protection}{FunnelWeb}\xx{protection}{file extension}
X
The concerns expressed in the previous section about modifications to the
XFunnelWeb program do not preclude modifications. They merely imply that
some conditions be observed when modifications are made.
In fact,
having formally released the sources under GNU, there is nothing that
I can do to stop people distributing modified versions and the conditions
to be described must be imposed voluntarily.
X
In the end there are two things that I want to protect/maintain:
X
X\begin{enumerate}
X
X\item Restriction of the name \dq{FunnelWeb} only to computer programs
that exactly implement my \dq{official} definition of the language.
X
X\item Restriction of the FunnelWeb source file extensions \dqp{.fw}
X(input files) and \dqp{.fwi} (include files) only
to source files that conform to my \dq{official} definition of the
language.
X
X\end{enumerate}
X
So long as these conditions hold, source files created under \dq{FunnelWeb}
will be portable, and the language will have the potential to
be stable and well-defined. Here are my suggestions for how to
obey these rules. These suggestions are in addition to the GNU license
rules about documenting any changes that you make in the source files.
X
X\narrowthing{Modifications that do not affect functionality:}{If you
change the FunnelWeb program in a manner that does not
affect the functionality of the program in any way (\eg{}port
it to a new machine, or just speed it up),
then you should modify the program to write out a message when it
starts up saying that
it is a modified version of FunnelWeb. No other actions need be taken.}
X
X\narrowthing{Modifications that affect functionality:}{If you make changes
to FunnelWeb that affect its functionality (\eg{}changes to command line
options, the command language, or the input language)
you should change the name of the program so that the name
no longer contains the word
X\dq{FunnelWeb}, and should choose alternative input and include-file
file extensions (the current ones are \dqp{.fw} and \dqp{.fwi}). For example,
you might call your program \dq{BananaWeb} and use the file extensions
X\dqp{.bw} and \dqp{.bwi}.}
X
These rules are not very restrictive. Basically you can do what you like
so long as you change the name of the resulting program. I do not wish to
restrict anyone who might want to use FunnelWeb as a foundation for a more
sophisticated literate programming system. My sole aim here is to
protect the integrity of what already exists.
X
X\section{Modifying the Manuals}
X\xx{modifying}{manuals}
X
While it is permitted to modify the FunnelWeb program, no license has been
granted
to modify its documentation (\i{The FunnelWeb User's Manual} and
X\i{The FunnelWeb Hacker's Manual}). The only operation that can be
performed on the FunnelWeb documentation is a verbatim copy in any medium.
X
If you have created a modified version of FunnelWeb and wish to document it,
either write your own manual from scratch, or write a manual that can be
used in conjunction with the existing manuals.
X
X\section{How Copyright Law Works}
X\xx{copyright}{law}
X
In order to understand the next section, some understanding of copyright
law is required. The assertions made in this section are not legal opinions;
they are merely approximations of the law, based on my understanding of it.
X
By default, whoever creates a \newterm{work} owns \newterm{copyright}
over it. This means that by default, that person is the only person in the
world who has the legal right to make copies of the work.
X
Copyright over a work usually covers all direct derivations of this work.
XFor example, if someone owns the source code to a computer program
then they also own any direct derivations such as the binary executable.
X
More than one person may own copyright over a work. If this is the case,
then the work cannot be copied without the permission of all of the people
owning the copyright.
X
A person (or group) owning copyright over a work
can \newterm{license} the right to make copies
of the work to anyone he likes under any conditions he likes.
X
If a work is modified, the result is called a \newterm{derived work}.
X
If copyright on a work is owned by $A$ is the work is modified by $B$,
copyright on the derived work is owned by both $A$ and $B$.
X
Copyright is not ownership over particular configurations of information,
but rather is the right to restrict the copying of information derived
from particular sources. For example, if two people point their cameras
out a window and take identical photographs, each person has the right
to restrict the copying of \i{their} photograph regardless of the
fact that the other person has copyright over an identical photograph.
In the unlikely event that two people wrote
novels that were letter for letter identical and it could be proven that
there was no contact between the two people when they wrote the novels,
then copyright law would each protect the right of each person to
restrict the copying of the novel originating from \i{them}. In practice,
the probability of such an event occurring is so low that the law
assumes that if two works are close or identical, that there has been
some information interchange at some point.
X
Thus, if I own copyright on computer program $X$, and I create
an identical copy of $X$
called $Y$ and distribute it under the terms of a license agreement,
then that license agreement does not cover the copy $X$. Once the
license agreement is signed, there is nothing I can do to undo the
license; $Y$ has gone. However, I still have total control over $X$.
X
Version~2 of the GNU General Public License\xx{GNU}{license}
X(under which FunnelWeb is
released) specifies (in a nutshell) that software can be copied freely
so long as it is not sold, and that it can be modified and copied
freely so long as the modifications are logged and it is not sold.
In both cases, it requires that the
result of the copy or modification operation
be copied only under the conditions of the license.
X
Once a declaration is issued licensing a copy of a program under GNU
license, that license cannot be retracted.
X
X\section{Management of the Official FunnelWeb}
X\xx{FunnelWeb}{management}\xx{FunnelWeb}{official}
X
I intend to maintain an official copy of FunnelWeb and release it under
GNU license from time to time so that everyone can use it. Unfortunately
its going to be a little messy.
X
XFor a variety of reasons, I want to maintain
total control over \i{my} copy of the official version of FunnelWeb.
Some of the reasons are:
X
X\begin{itemize}
X
X\item If it turns out that there is an enormous demand for
XFunnelWeb (unlikely) then
I want to be able to create a business based on it, or at least
be able to bundle it with other products.
This would be difficult if the only up-to-date copy available was a GNU copy.
Note: If this happens, all the GNU releases of FunnelWeb will remain
valid.
X
X\item I want to be able to copy code from my version of FunnelWeb
into commercial products without having to worry about the GNU license.
X
X\end{itemize}
X
The trouble is that (in my understanding of copyright law),
once a copy of FunnelWeb has been released under GNU license, then it
and any works derived from it fall under GNU license too. This means that
if you modify a GNU release of 
XFunnelWeb and send me your modifications, and I incorporate
them into my version, then I no longer own copyright on the version I
modified. Basically, if GNU touches a work, then that copy is gone forever.
X
My solution to the problem is to keep a copy of FunnelWeb that is
GNU-clean and only make modifications to it that are GNU-clean. So
long as my official copy is GNU clean, any modifications that I make
myself will be GNU clean. The problem comes when someone else modifies
the GNU version and then wants me to incorporate the modifications into
my official version. As I understand the law, by default, the programmer
owns the modifications (because he made them), but the result of making
the modifications falls under GNU license. What I propose is that those
who want their modifications included in the official copy of FunnelWeb
sign an agreement transferring copyright of the modifications over to
me on condition that the result be released under GNU license within
a certain time period. \figlicense{} demonstrates the process.
X
X\begin{figure}[htbp]
X\begin{verbatim}
X
X  +---------->----------+--------------<-------------+
X  |(modifications by    |                            |
X  | me)                 V                            |
X  |     +----------------------------------+         |
X  +--<--|  My Official Copy of FunnelWeb   |         |
X        |   Copyright (C) Ross Williams    |         |
X        +----------------------------------+         |
X                        | (Periodic releases)       / \
X                        V                          /   \  Programmers
X              +------------------+                /Legal\ sign away
X              | GNU Release Copy |                \Filte/ copyright on
X              +------------------+                 \ r /  modifications
X                        |                           \ /
X                        | (Modifications made by     |
X                        V  random programmers) --->--+
X             +-----------------------+
X             | Modified GNU Version  |
X             +-----------------------+
X
X\end{verbatim}
X\mylabel{\figlicense{}: How I am going to maintain copyright over FunnelWeb.}{%
X%
Once a work is released under GNU license, all derived works fall under
GNU license. However, this diagram shows how copyright can be maintained
over a work, while still making it available under GNU license.
Unfortunately, this scheme requires that copyright on
modifications to FunnelWeb be signed off by the people who make the
modifications.
X%
X}
X\end{figure}
X
There are two main disadvantages to this scheme:
X
X\begin{enumerate}
X
X\item Getting each person who contributes modifications to FunnelWeb
to sign and send a piece of paper signing away copyright will be tedious.
X
X\item Programmers may be reluctant to sign away copyright on modifications
because the result could be used by me for commercial purposes
by me at a later date (Note: But it must be released under GNU as well).
X
X\end{enumerate}
X
These disadvantages are regrettable consequences of my decision to retain
total control over the \dq{official} version of FunnelWeb.
X
The upshot of all this is that:
X
X\begin{itemize}
X
X\item I will never allow any code from a GNU release of FunnelWeb to
touch my official copy. Only modifications will be acceptable.
X
X\item If you make a modification to FunnelWeb and send it to me for
inclusion in the official version, I will not incorporate your
modification until I have received a signed declaration transferring copyright.
I will prepare such a contract when the first person sends me a worthy
modification!
X
X\item If you intend to make changes to FunnelWeb that are so massive that they
will involve wide-scale modification of the source files, and you want
the modification to be part of the official version,
it might be a good idea to contact me before doing so. There are two
reasons for doing this. First, it allows me a chance to comment on your
proposed modifications and give my opinion on whether they are likely to be
incorporated into the official version. Second, I can send you a copy
X(under special license) of the GNU-clean official version to work on. This will
allow you to ship back your changes as files rather than as change sections.
X
X\end{itemize}
X
As a separate point from the legal issues, I am likely to turn out to be
pretty picky about what modifications I will incorporate into the
official copy. Whether a modification will be accepted will depend,
amongst other things, on the following criteria.
X
X\begin{itemize}
X
X\item Does the modification fit in with the design goals of FunnelWeb, or
is it just a case of creeping featurism?
X
X\item How well coded is the modification? Would it reduce the quality of the
code?
X
X\item If the modification changes FunnelWeb's functionality, is this a
desirable change? How will it impact on existing users?
X
X\item Would it be quicker for me to make the modification myself than
to work out how to incorporate the submitted modification?
X
X\end{itemize}
X
It is my goal to guard the integrity of the design and code of the
official version of FunnelWeb and so I will probably be rather
fussy about what I regard as a worthwhile modification. I do not wish to
lose control of the code, either technically or legally.
X
X\section{A GNU Version?}
X\xx{GNU}{version}
X
The controls on the official version of FunnelWeb described in the previous
section will have at most a minor impact on FunnelWeb development if
XFunnelWeb already serves the needs of most of its users. However, if it
turns out that FunnelWeb is both popular, \i{and} needs
widespread modifications and enhancements, then the official feedback loop
described in the previous section will become unworkable, and there will be
a GNU breakout.
X
A \newterm{GNU breakout}\xs{breakout}{GNU}
will occur if FunnelWeb users become
organized enough and annoyed enough (at the official development cycle)
to start maintaining a coherent version of FunnelWeb that
diverges from the official version.
If a GNU breakout occurs, I would appreciate, as requested earlier, that
a different name and file extensions be chosen for the diverging version.
X
X\section{Summary}
X
Decentralized modifications to a programming language and its implementations
can seriously damage the language's portability and semantic clarity.
Unfortunately, there is a tension between centralizing control of a
programming language and providing source code security to nervous users.
In FunnelWeb, this trade-off has been resolved to some extent by
releasing the source code along with a request
that if the functionality of the program is modified,
that the program's name be changed and a different file
extension be chosen for input files created under the modified program.
The author of FunnelWeb has decided to maintain an official version of
XFunnelWeb over which he will own copyright, but which he will release
under GNU license from time to time. This means that copyright
on all changes to FunnelWeb must be signed over to the author before they
have a chance of being incorporated in the official version. Finally, it is
possible that this reluctance of the author to remove his copyrighted
version from the development cycle of the official version
will result in a GNU breakout in which a diverging GNU
version of FunnelWeb will be maintained by the GNU community. The author
hopes this won't be necessary and requests,
if this happens, that the diverging GNU version be renamed.
X
X%==============================================================================%
X%                              Start of Ch3.tex                                %
X%==============================================================================%
END_OF_FILE
if test 25736 -ne `wc -c <'hackman/h_ch3.tex'`; then
    echo shar: \"'hackman/h_ch3.tex'\" unpacked with wrong size!
fi
# end of 'hackman/h_ch3.tex'
fi
if test -f 'sources/data.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sources/data.h'\"
else
echo shar: Extracting \"'sources/data.h'\" \(26371 characters\)
sed "s/^X//" >'sources/data.h' <<'END_OF_FILE'
X/*##############################################################################
X
XFUNNNELWEB COPYRIGHT
X====================
XFunnelWeb is a literate-programming macro preprocessor.
X
Copyright (C) 1992 Ross N. Williams.
X
X   Ross N. Williams
X   ross@spam.adelaide.edu.au
X   16 Lerwick Avenue, Hazelwood Park 5066, Australia.
X
This program is free software; you can redistribute it and/or modify
it under the terms of Version 2 of the GNU General Public License as
published by the Free Software Foundation.
X
This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See Version 2 of the GNU General Public License for more details.
X
You should have received a copy of Version 2 of the GNU General Public
License along with this program. If not, you can FTP the license from
prep.ai.mit.edu/pub/gnu/COPYING-2 or write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Section 2a of the license requires that all changes to this file be
recorded prominently in this file. Please record all changes here.
X
Programmers:
X   RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X
Changes:
X   07-May-1992  RNW  Program prepared for release under GNU GPL V2.
X
X##############################################################################*/
X
X
X/******************************************************************************/
X/*                                    DATA.H                                  */
X/******************************************************************************/
X/*                                                                            */
X/* This package (data.h, data.c) contains ALL of the global variables in      */
X/* FunnelWeb. Some of the FunnelWeb packages (e.g. the lister) harbour hidden */
X/* static state variables which could be considered to be a global variable,  */
X/* but, these aside, this package contains all the variables that are used    */
X/* directly by more than one package. In many programs, it would likely be    */
X/* appropriate to have a separate package for each distinct group of shared   */
X/* data so that only those packages needing a particular group of data need   */
X/* see it. However, in FunnelWeb's case, the variables are so few, and their  */
X/* use so widespread that they are clustered here in one package for all to   */
X/* see.                                                                       */
X/*                                                                            */
X/* This package also contains type definitions for the central FunnelWeb data */
X/* structures.                                                                */
X/*                                                                            */
X/******************************************************************************/
X
X/* Ensure that the body of this header file is included at most once.         */
X#ifndef DONE_DATA
X#define DONE_DATA
X
X/******************************************************************************/
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <limits.h>
X#include "style.h"
X#include "clock.h"
X#include "list.h"
X#include "table.h"
X#include "option.h"
X#include "section.h"
X#include "writfile.h"
X
X/******************************************************************************/
X/*                                                                            */
X/* DATA TYPES                                                                 */
X/* ==========                                                                 */
X/* The following section contains all the data types of the global variables. */
X/*                                                                            */
X/******************************************************************************/
X
X/* The following structure defines a position in the global listing of the    */
X/* input data by storing a line number and a column number. The line number   */
X/* is a global line number meaning that it increases continuously through     */
X/* the lines of included files. The first line is line number 1. The first    */
X/* (leftmost) column is column number 1.                                      */
typedef
X   struct
X     {
X      ulong ps_line;
X      ulong ps_column;
X     } ps_t ;
X
typedef ps_t *p_ps_t;  /* A pointer to a position is handy too! */
X
X/******************************************************************************/
X
X/* A macro name is represented simply as a character array. */
X#define NAME_MAX 80
typedef char name_t[NAME_MAX+1];
typedef name_t *p_name_t;
X
X/******************************************************************************/
X
X/* SC stands for SCrap of text. A scrap of text is a contiguous group of      */
X/* printable bytes in memory. The following structure defines such a group by */
X/* storing a pointer to the first and last character of the scrap.            */
X/* The scrap must contain at least one character (i.e. sc_last>=sc_first).    */
typedef
X   struct
X     {
X      char *sc_first; /* Pointer to the first byte of the scrap.              */
X      char *sc_last;  /* Pointer to the last  byte of the scrap.              */
X      bool  sc_white; /* TRUE iff the scrap consists entirely of whitespace.  */
X     } sc_t;
X
typedef sc_t *p_sc_t;
X
X/******************************************************************************/
X
X/* LN stands for LiNe. This record holds global and local line numbers as     */
X/* well as a scrap that points to the line in question. The scanner (which    */
X/* generates this list) guarantees that the last character of the line scrap  */
X/* is an EOL.                                                                 */
typedef
X   struct
X     {
X      sc_t  ln_body;    /* Scrap pointing to the line. Line ends in EOL.      */
X      ulong ln_global;  /* Global line number of this line.                   */
X      ulong ln_local;   /* Local  line number of this line.                   */
X     } ln_t;
X
X/* The global line list is simply a list of lines of the following type.      */
typedef p_ls_t p_lnls_t;
X
X/******************************************************************************/
X
X/* The following enumerated type identifies a font. */
X#define FT_NORM 1
X#define FT_TITL 2
X#define FT_STIT 3
X
X/* The following enumerated type identifies a horizontal alignment. */
X#define LR_LEFT 1
X#define LR_RIGH 2
X#define LR_CENT 3
X
X/* We want to pack a font and an alignment into the tk_gen byte of the token  */
X/* record (we could create a new field, but as none of the other token kinds  */
X/* require an extra field, we choose to pack instead. The formula is this:    */
X/* Packed byte=LRFT_PACK*FONT+ALIGNMENT.                                      */
X#define LRFT_PACK 10
X
X/******************************************************************************/
X
X/* The following enumerated type identifies the kind of a token. */
X#define TK_TEXT  1   /*      Text segment.          */
X#define TK_NSEC  2   /*  @A..New section.           */
X#define TK_MDEF  3   /*  @$  Macro definition.      */
X#define TK_FDEF  4   /*  @F  File definition.       */
X#define TK_ONAM  5   /*  @<  Open name.             */
X#define TK_CNAM  6   /*  @>  Close name.            */
X#define TK_ODEF  7   /*  @{  Open definition.       */
X#define TK_CDEF  8   /*  @}  Close definition.      */
X#define TK_OPAR  9   /*  @(  Open parameter list.   */
X#define TK_CPAR 10   /*  @)  Close parameter list.  */
X#define TK_COMA 11   /*  @,  Comma.                 */
X#define TK_QUOT 12   /*  @"  Quote.                 */
X#define TK_PARM 13   /*  @1  Parameter.             */
X#define TK_ZERO 14   /*  @Z  Zero calls allowed.    */
X#define TK_MANY 15   /*  @M  Many calls allowed.    */
X#define TK_NAME 16   /*  @#  Self contained name.   */
X#define TK_EMPH 17   /*  @/  Emphasize text.        */
X#define TK_NPAG 18   /*  @t..Newpage.               */
X#define TK_TOCS 19   /*  @t..Table of contents.     */
X#define TK_SKIP 20   /*  @t..Vertical skip.         */
X#define TK_TITL 21   /*  @t..Title text.            */
X#define TK_EOF  22   /*      End of file.           */
typedef ubyte tk_k_t;
X
X/* The following structure conveys all the information about a single token.  */
X/* As well as the kind of token, the parser needs to know where the token is  */
X/* in the input file and what the text of the token is if it is a text token. */
X/* Some other tokens have a numeric attribute associated with them and the    */
X/* tk_gen field provides a place for this. The attributes are:                */
X/*    TK_PARM - The number of the parameter [1,9].                            */
X/*    TK_NAME - The number of the character forming the name [0,255].         */
X/*    TK_NSEC - The level of the section [0,5]. 0=@*, 1=@A, 2=@B,..,5=@E.     */
X/*    TK_SKIP - Number of millimetres to skip vertically [0,255].             */
X/*    TK_TITL - Font and alignment packed into byte as specified earlier.     */
X/*              tk_sc is the text to be set as a title.                       */
typedef
X   struct
X     {
X      tk_k_t tk_kind;  /* Kind of this token.                                 */
X      ps_t   tk_ps;    /* Position of the first character of this token.      */
X      sc_t   tk_sc;    /* Scrap constituting token.                           */
X      ubyte  tk_gen;   /* General token attribute.                            */
X     } tk_t;
X
typedef p_ls_t p_tkls_t;  /* A list of tokens. */
X
X/******************************************************************************/
X
typedef p_ls_t p_scls_t;  /* List of scraps.                                  */
typedef p_ls_t p_scll_t;  /* List of list of scraps =TEXT.                    */
X
typedef p_ls_t p_ells_t;  /* List of pointers to elements = EXPRESSION.       */
typedef p_ls_t p_elll_t;  /* List of list of pointers to elements.            */
typedef p_ls_t p_ell3_t;  /* List of list of list of pointers to elements.    */
X
X/******************************************************************************/
X
X/* This structure's signature is BP for Body Part. FunnelWeb macros can       */
X/* be defined in a series of "+=" definitions scattered through the input     */
X/* file. The definition of the macro is the concatenation of all the parts.   */
X/* The contributory part of a part consists of a single expression.           */
X/* Throughout the document, body parts (definition parts) are numbered        */
X/* sequentially by a sequence number.                                         */
typedef
X   struct
X    {
X     p_ells_t bp_ex;  /* Expression that is logically appended to definition. */
X     ulong    bp_seq; /* Sequence number of body part.                        */
X     ps_t     bp_ps;  /* Position at which the definition appears.            */
X    } bp_t;
X
typedef bp_t *p_bp_t;
X
X/* A list of body parts constitutes the full body of a macro. */
typedef p_ls_t p_bpls_t;
X
X/******************************************************************************/
X
X/* The following structure summarizes a macro CALL. Each macro table entry    */
X/* contains a field ma_calls which contains a list of these structures. The   */
X/* list is used to generate diagnostics (e.g. if a call has the wrong number  */
X/* of parameters) and also to give cross reference information in the typeset */
X/* documentation.                                                             */
typedef
X   struct
X     {
X      ulong mc_seq;   /* Sequence number of body part containing call.        */
X      ps_t  mc_ps;    /* Position at which the call occurred.                 */
X      ulong mc_npar;  /* Number of parameters in call.                        */
X     } mc_t;
X
typedef mc_t *p_mc_t;
X
X/* A list of calls summarizes the entire usage of a macro in a document.      */
typedef p_ls_t p_mcls_t;
X
X/******************************************************************************/
X
X/* This structure stores the definition of a single macro. The first field    */
X/* md_isdef indicates whether a definition for this macro has so far been     */
X/* seen. If it has, md_isdef=TRUE and the remaining fields are well defined.  */
typedef
X   struct
X     {
X      bool     md_isdef;  /* TRUE iff the macro is defined.                   */
X      ps_t     md_ps;     /* isdef=> Position of first definition part.       */
X      ubyte    md_npar;   /* isdef=> Number of params specified in defn.      */
X      bool     md_isadd;  /* isdef=> TRUE iff additively defined.             */
X      bool     md_iszer;  /* isdef=> TRUE iff zero calls allowed.             */
X      bool     md_isman;  /* isdef=> TRUE iff many calls allowed.             */
X      bool     md_isfil;  /* isdef=> TRUE iff macro is bound to an outp file. */
X      p_bpls_t md_body;   /* isdef=> Body of the macro (list of parts).       */
X     } md_t;
X
X/******************************************************************************/
X
X/* The following structure contains the full information about a macro.       */
typedef
X   struct
X     {
X      name_t   ma_name;   /* Name of the macro.                               */
X      p_mcls_t ma_calls;  /* List of calls of this macro in the document.     */
X      md_t     ma_defn;   /* Definition of this macro.                        */
X      p_ell3_t ma_actn;   /* Used by tangle. List of actual parameter lists.  */
X      uword    ma_level;  /* Used by analyser. Depth of deepest call.         */
X     } ma_t;
X
X/* A pointer to the comprehensive macro structure defined above is the way    */
X/* that FunnelWeb refers to macros internally.                                */
typedef ma_t *p_ma_t;
X
X/******************************************************************************/
X
X/* An expression consists of a sequence of ELEMENTS each of which can         */
X/* be one of three kinds:                                                     */
X/*                                                                            */
X/*    1. A block of text.                                                     */
X/*    2. An invocation of another macro.                                      */
X/*    3. A parameter of the current macro.                                    */
X/*                                                                            */
X/* The following enumerated type identifies one of these three alternatives.  */
X#define EL_TEXT 1
X#define EL_INVC 2
X#define EL_PARM 3
typedef ubyte el_k_t;
X
X/* The following rather messy structure contains information about a single   */
X/* element. As mentioned above, an element can be one of three kinds and the  */
X/* following structure should, strictly speaking, be defined as a C union so  */
X/* as to emphasize the mutually exclusive nature of most of its fields.       */
X/* At one stage this structure did contain a union, however, it introduced    */
X/* more mess than it brought clarity (because of the extra two subnames) and  */
X/* was eventually dropped.                                                    */
X/* A few fields deserve some explanation:                                     */
X/*    el_pretx and el_postx hold the exact whitespace appearing between       */
X/*       actual parameters in a macro call. This enables the call to be       */
X/*       formatted properly in the typeset output.                            */
X/*    el_which is part of the macro parameter element (e.g. @1) and points to */
X/*       the macro within which the @1 appears. Strictly speaking this should */
X/*       not be necessary, but it is convenient for the tangler to have this  */
X/*       information when it is half way through expanding an expression.     */
typedef
X   struct
X     {
X      el_k_t   el_kind;  /* Indicates what kind of element structure holds.   */
X
X      p_scls_t el_text;  /* EL_TEXT => List of scraps forming a text chunk.   */
X
X      p_ma_t   el_p_mac; /* EL_INVC => Pointer to macro being invoked.        */
X      p_elll_t el_parls; /* EL_INVC => List of actual parameters.             */
X      p_scll_t el_pretx; /* EL_INVC => Text before each parameter.            */
X      p_scll_t el_postx; /* EL_INVC => Text after  each parameter.            */
X
X      p_ma_t   el_which; /* EL_PARM => Macro in which this element appears.   */
X      ubyte    el_parno; /* EL_PARM => Parameter number of this actual param. */
X     } el_t;
X
typedef el_t *p_el_t;
X
X/******************************************************************************/
X
X/* A document component (represented by the DC_ data structures (see below)   */
X/* can be one of three things: a lump of text, a typesetter-generic           */
X/* typesetting directive, or a macro definition. The second of these consists */
X/* of a whole collection of typesetting commands and so rather than           */
X/* cluttering up the dc_ record, they have been separated out here.           */
X#define TY_NSEC 1   /* New section.                                           */
X#define TY_OLIT 2   /* Open  literal.                                         */
X#define TY_CLIT 3   /* Close literal.                                         */
X#define TY_OEMP 4   /* Open  emphasise.                                       */
X#define TY_CEMP 5   /* Close emphasise.                                       */
X#define TY_NPAG 6   /* New page.                                              */
X#define TY_TOCS 7   /* Table of contents.                                     */
X#define TY_SKIP 8   /* Skip vertical.                                         */
X#define TY_TITL 9   /* Title.                                                 */
typedef ubyte ty_k_t;
X
typedef
X   struct
X     {
X      ty_k_t   ty_kind;  /* Kind of this typesetting directive.               */
X      sn_t     ty_sn;    /* TY_NSEC=> Hierarchical section number.            */
X      bool     ty_isnam; /* TY_NSEC=> TRUE iff the section is named.          */
X      name_t   ty_name;  /* TY_NSEC=> ty_isnam=> Name of section.             */
X
X      uword    ty_mm;    /* TY_SKIP=> Millimetres to skip.                    */
X
X      ubyte    ty_font;  /* TY_TITL=> Font in which to write title.           */
X      ubyte    ty_align; /* TY_TITL=> Alignment with which to write title.    */
X      sc_t     ty_sc;    /* TY_TITL=> Scrap that is title text.               */
X     } ty_t;
X
typedef ty_t *p_ty_t;
X
X/******************************************************************************/
X
X/* The document list contains a representation of the input document in the   */
X/* form in which it was fed to FunnelWeb. This structured representation of   */
X/* the input is used by the weaver to generate the typeset output.            */
X/* Here, a document is represented by a list of DOCUMENT COMPONENTs (DC) each */
X/* of which contains information about a major chunk of the document. The     */
X/* following enumerated type dc_k_t (document component kind type) is used to */
X/* indicate which kind of component each list element contains.               */
X#define DC_TEXT 1   /* Text component consists of a block of text.            */
X#define DC_TYPE 2   /* Typesettting component affecting document typesetting. */
X#define DC_MACR 3   /* A MACRo definition.                                    */
typedef ubyte dc_k_t;
X
X/* The following structure stores a single document component. Like the el_t  */
X/* type, the dc_t type should really be a union type, but a union construct   */
X/* has been avoided to make the naming simpler.                               */
typedef
X   struct
X     {
X      ps_t     dc_ps;    /* Position of this component.                       */
X      dc_k_t   dc_kind;  /* Kind of this component.                           */
X
X      p_scls_t dc_text;  /* DC_TEXT=> Text segment constituting this compnt.  */
X
X      ty_t     dc_ty;    /* DC_TYPE=> Typesetting object record.              */
X
X      p_ma_t   dc_p_ma;  /* DC_MACR=> Pointer to the macro defined.           */
X      ulong    dc_part;  /* DC_MACR=> Part number of this part of macro defn. */
X     } dc_t;
X
typedef dc_t *p_dc_t;
X
X/* A list of document components constitutes the global document list         */
X/* declared later.                                                            */
typedef p_ls_t p_dcls_t;
X
X/******************************************************************************/
X
X/* This enumerated type identifies a typesetter.                              */
X/*    TR_NONE - No specific typesetter specified.                             */
X/*    TR_TEX  - The TeX typesetter.                                           */
X#define TR_NONE 1
X#define TR_TEX  2
X/* Add more typesetters here later. */
typedef ubyte tr_k_t;
X
X
X/******************************************************************************/
X/*                                                                            */
X/* VARIABLES                                                                  */
X/* =========                                                                  */
X/* This section contains external declarations of the global variables.       */
X/* The global variables themselves appear in DATA.C.                          */
X/*                                                                            */
X/******************************************************************************/
X
X/* This #ifndef is part of a mechanism that makes the following definitions   */
X/* visible to other modules declared as "extern", and visible to data.c       */
X/* declared as ordinary declarations. This prevents inconsistencies.          */
X#ifndef EXTERN
X#define EXTERN extern
X#endif
X
X/* This global options variable holds the options that were transmitted to    */
X/* FunnelWeb proper through the command line.                                 */
XEXTERN GLOVAR op_t option;
X
X/* The following option variable is set by the scanner and is used by the     */
X/* tangler. It determines whether the tangler will use natural indenting.     */
X/* TRUE => Tangler should use space indenting. FALSE=>No indenting.           */
XEXTERN GLOVAR bool tgindent;
X
X/* The following option variable is set by the scanner and is used by the     */
X/* tangler. It sets a limit on the length of the lines of the product files   */
X/* generated by tangle. A value of TGMAXINF indicates that no checking need   */
X/* be performed.                                                              */
X#define TGMAXINF (ULONG_MAX)
XEXTERN GLOVAR ulong tglinmax;
X
X/* The following variable is written by the scanner and read by weave. It     */
X/* stores the typesetter format possibly specified by the user in the input.  */
XEXTERN GLOVAR tr_k_t tr_codes;
X
X/* The following five lists and tables constitute the major data structures   */
X/* that are communicated between the major components of FunnelWeb.           */
X/* The TOKEN_LIST contains a tokenized representation of the input file.      */
X/* The LINE_LIST contains a list of the lines of the input file.              */
X/* The DOCUMENT_LIST contains a structured representation of the input file.  */
X/* The MACRO_TABLE describes the macros defined in the input file.            */
X/* The FILE_TABLE identifies macros that are connected to product files.      */
X/*                                        Created By  Used By                 */
X/*                                        ----------  -------                 */
XEXTERN GLOVAR p_tkls_t token_list;     /*    Scanner  Parser                  */
XEXTERN GLOVAR p_lnls_t line_list;      /*    Scanner  Lister                  */
XEXTERN GLOVAR p_dcls_t document_list;  /*     Parser  Weaver                  */
XEXTERN GLOVAR p_tb_t   macro_table;    /*     Parser  Tangler, Weaver         */
XEXTERN GLOVAR p_tb_t   file_table;     /*     Parser  Tangler, Weaver         */
X
X/* Three output streams are accessible globally.                              */
X/* The SCREEN FILE is connected to standard output (the user screen).         */
X/* The JOURNAL FILE logs FunnelWeb command language transactions.             */
X/* The LISTING FILE is created by an single invocation of FunnelWeb proper.   */
XEXTERN GLOVAR wf_t f_s;  /* Screen  file. */
XEXTERN GLOVAR wf_t f_j;  /* Journal file. */
XEXTERN GLOVAR wf_t f_l;  /* Listing file. */
X
X/* Many of the FunnelWeb IO functions accept a single string as a parameter.  */
X/* This means that sprintf and a temporary string must be used in order to    */
X/* produce parameterized formatted output. Rather than declare temporary      */
X/* strings in each local function, we declare them globally.                  */
XEXTERN GLOVAR char linet1[2000];
X
X/* Definitions of Diagnostic Levels                                           */
X/* --------------------------------                                           */
X/* A WARNING has no effect except to cause a message to be issued.            */
X/* An ERROR causes FunnelWeb to abort to the shell at the end of the phase.   */
X/*    Example: An error during scanning means that the FunnelWeb run will     */
X/*    terminate to the shell at the end of the scanning phase.                */
X/* A SEVERE ERROR causes FunnelWeb to abort to the shell immediately.         */
X/* A FATAL ERROR causes FunnelWeb to abort to the OS immediately.             */
X
X/* The following variables count diagnostics over a single FunnelWeb run.     */
XEXTERN GLOVAR ulong num_war;  /* Number of      warnings.                     */
XEXTERN GLOVAR ulong num_err;  /* Number of        errors.                     */
XEXTERN GLOVAR ulong num_sev;  /* Number of severe errors.                     */
X
X/* The following variables count diagnostics over multiple FunnelWeb runs.    */
XEXTERN GLOVAR ulong sum_war;  /* Number of      warnings.                     */
XEXTERN GLOVAR ulong sum_err;  /* Number of        errors.                     */
XEXTERN GLOVAR ulong sum_sev;  /* Number of severe errors.                     */
XEXTERN GLOVAR ulong sum_fat;  /* Number of fatal  errors.                     */
X
X/******************************************************************************/
X
X/* For #ifndef preventing multiple inclusion of the body of this header file. */
X#endif
X
X/******************************************************************************/
X/*                                 End of DATA.H                              */
X/******************************************************************************/
END_OF_FILE
if test 26371 -ne `wc -c <'sources/data.h'`; then
    echo shar: \"'sources/data.h'\" unpacked with wrong size!
fi
# end of 'sources/data.h'
fi
if test -f 'sources/dump.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sources/dump.c'\"
else
echo shar: Extracting \"'sources/dump.c'\" \(24980 characters\)
sed "s/^X//" >'sources/dump.c' <<'END_OF_FILE'
X/*##############################################################################
X
XFUNNNELWEB COPYRIGHT
X====================
XFunnelWeb is a literate-programming macro preprocessor.
X
Copyright (C) 1992 Ross N. Williams.
X
X   Ross N. Williams
X   ross@spam.adelaide.edu.au
X   16 Lerwick Avenue, Hazelwood Park 5066, Australia.
X
This program is free software; you can redistribute it and/or modify
it under the terms of Version 2 of the GNU General Public License as
published by the Free Software Foundation.
X
This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See Version 2 of the GNU General Public License for more details.
X
You should have received a copy of Version 2 of the GNU General Public
License along with this program. If not, you can FTP the license from
prep.ai.mit.edu/pub/gnu/COPYING-2 or write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Section 2a of the license requires that all changes to this file be
recorded prominently in this file. Please record all changes here.
X
Programmers:
X   RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X
Changes:
X   07-May-1992  RNW  Program prepared for release under GNU GPL V2.
X
X##############################################################################*/
X
X
X/******************************************************************************/
X/*                                    DUMP.C                                  */
X/******************************************************************************/
X
X#include <ctype.h>
X#include "style.h"
X
X#include "as.h"
X#include "clock.h"
X#include "data.h"
X#include "dump.h"
X#include "misc.h"
X
X/******************************************************************************/
X
X#define DUMP_WIDTH (80)
X
X/******************************************************************************/
X
X/* The following advance declarations are required because of recursion. */
LOCAL void dm_ex P_((p_wf_t,p_ells_t));
X
X/******************************************************************************/
X
LOCAL void centerln P_((p_wf_t,uword,int,char *));
LOCAL void centerln(p_wf,width,ch,s)
X/* Writes string s in a line surrounded by character ch to specified width.   */
X/* Example: centerln(*,20,'-',"sloth") would write: "------ sloth -------"    */
p_wf_t p_wf;
uword  width;
int ch;
char   *s;
X{
X uword sidebar,i;
X char  linet2[100];
X /* Warning: linet2 can't be too big, or it will blow the Mac's limited       */
X /* stack space. Perhaps it should be put in the heap with a static pointer.  */
X
X as_cold(width>=5,"centerln: Width is too small.");
X as_cold(width<=80,"centerln: Width is too large.");
X as_cold(strlen(s) <= width-4,"centerln: Width is too narrow for string.");
X
X /* Construct a sidebar string. */
X sidebar=(width-strlen(s)-2)/2;
X for (i=0;i<sidebar;i++) linet2[i]=ch;
X linet2[sidebar]=EOS;
X
X /* Now construct the result string. */
X strcpy(linet1,linet2);
X strcat(linet1," ");
X strcat(linet1,s);
X strcat(linet1," ");
X strcat(linet1,linet2);
X
X /* If the sidebar division removed a character, and the line is long enough  */
X /* for the user not to notice the imbalance, tack a character on the end.    */
X if (width>40 && strlen(linet1)==width-1)
X   {
X    uword len=strlen(linet1);
X    linet1[len]=ch;
X    linet1[len+1]=EOS;
X   }
X
X /* Write the result string to the specified stream. */
X wf_wl(p_wf,linet1);
X}
X
X/******************************************************************************/
X
LOCAL char * fontname P_((ubyte));
LOCAL char * fontname(font)
X/* Given a font number, returns a pointer to a static string containing the   */
X/* name of the font.                                                          */
ubyte font;
X{
X switch (font)
X   {
X    case FT_NORM: return "Normal";
X    case FT_TITL: return "Title";
X    case FT_STIT: return "Small Title";
X    default     : as_bomb("fontname: Font switch defaulted.");
X   }
X /* Keep GCC warnings happy. */
X as_bomb("fontname: Dropped out of switch.");
X return "Failure";
X}
X
X/******************************************************************************/
X
LOCAL char * alignname P_((ubyte));
LOCAL char * alignname(align)
X/* Given an alignment number, returns a pointer to a static string containing */
X/* the name of the alignment.                                                 */
ubyte align;
X{
X switch (align)
X   {
X    case LR_LEFT: return "Left";
X    case LR_RIGH: return "Right";
X    case LR_CENT: return "Centre";
X    default     : as_bomb("alignname: Alignment switch defaulted.");
X   }
X /* Keep GCC warnings happy. */
X as_bomb("alignnamename: Dropped out of switch.");
X return "Failure";
X}
X
X/******************************************************************************/
X
XEXPORT void dm_mem(p_wf,p_mem,length)
p_wf_t  p_wf;
char   *p_mem;
ulong   length;
X{
X ubyte_ *p_base = (ubyte_ *) p_mem;
X long   len     = length;
X
X wf_wl(p_wf,"");
X wf_wl(p_wf,"MEMORY DUMP OF MAPPED FILE");
X wf_wl(p_wf,"==========================");
X wf_wl(p_wf,"");
X wf_wr(p_wf,"+-------------------------------------------------+------------------+\n");
X wf_wr(p_wf,"| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |\n");
X wf_wr(p_wf,"+-------------------------------------------------+------------------+\n");
X
X while (len>0)
X   {/* Write a single line of 16 bytes per iteration. */
X    uword j;
X    wf_wr(p_wf,"| ");
X    for (j=0;j<16;j++)
X       if (j>=len)
X          wf_wr(p_wf,"   ");
X       else
X         {
X          char s[10];
X          sprintf(s,"%02X ",(unsigned int) p_base[j]);
X          wf_wr(p_wf,s);
X         }
X    wf_wr(p_wf,"| ");
X    for (j=0;j<16;j++)
X       if (j>=len)
X          wf_chr(p_wf,' ');
X       else
X        {
X         char ch=p_base[j];
X         /* DON'T use library function "isprint" - it is too loose. */
X         /* e.g. The vax "isprint" accepts top bit characters. */
X         if (!isascprn(ch)) ch='.';
X         wf_chr(p_wf,ch);
X        }
X    wf_wr(p_wf," |\n");
X    p_base+=16;
X    len-=16;
X   } /* End while */
X
X wf_wr(p_wf,"+-------------------------------------------------+------------------+\n");
X wf_wl(p_wf,"");
X}
X
X/******************************************************************************/
X
LOCAL void dm_byte P_((p_wf_t,ubyte));
LOCAL void dm_byte(p_wf,b)
X/* Dumps a text representation of the given byte to the specified stream.     */
p_wf_t p_wf;
ubyte  b;
X{
X char t[10];
X /* DON'T use library function "isprint" - it is too loose. */
X /* e.g. The vax "isprint" accepts top bit characters. */
X if (isascprn(b))
X    sprintf(t,"%c",(char) b);
X else
X    sprintf(t,"<%03u>",(unsigned) b);
X wf_wr(p_wf,t);
X}
X
X/******************************************************************************/
X
XEXPORT void dm_lnls(p_wf)
p_wf_t p_wf;
X{
X wf_wl(p_wf,"");
X centerln(p_wf,DUMP_WIDTH,'=',"Start of LINE LIST DUMP");
X wf_wl(p_wf,"");
X           /*12345678901234567890123456789012345678901234567890123456789012345678901234567890*/
X wf_wl(p_wf,"Globl Local| Text");
X wf_wl(p_wf,"-----------+--------------------------------------------------------------------");
X ls_fir(line_list);
X while (TRUE)
X   {
X    ln_t *p_line;
X    char *p;
X    ls_nxt(line_list,PPV &p_line);
X    if (p_line==NULL) break;
X    sprintf(linet1,"%05lu %05lu| ",
X            (ulong) p_line->ln_global,
X            (ulong) p_line->ln_local);
X    wf_wr(p_wf,linet1);
X    for (p=p_line->ln_body.sc_first; p<=p_line->ln_body.sc_last; p++)
X       dm_byte(p_wf,*((ubyte_ *)p));
X    wf_wl(p_wf,"");
X   }
X wf_wl(p_wf,"-----------+--------------------------------------------------------------------");
X wf_wl(p_wf,"Globl Local| Text");
X wf_wl(p_wf,"");
X centerln(p_wf,DUMP_WIDTH,'=',"End of LINE LIST DUMP");
X wf_wl(p_wf,"");
X}
X
X/******************************************************************************/
X
LOCAL void dm_sc P_((p_wf_t,p_sc_t));
LOCAL void dm_sc(p_wf,p_sc)
X/* Dumps the specified scrap to the specified stream. */
p_wf_t p_wf;
p_sc_t p_sc;
X{
X char *p;
X
X as_cold(p_sc->sc_first !=NULL,"dm_sc: NULL ptr1.");
X as_cold(p_sc->sc_last  !=NULL,"dm_sc: NULL ptr2.");
X
X if (p_sc->sc_white)
X    wf_wr(p_wf,"Text scrap[White]=");
X else
X    wf_wr(p_wf,"Text scrap[Grey]=");
X wf_wr(p_wf,"\"");
X for (p=p_sc->sc_first; p<=p_sc->sc_last; p++)
X   {
X    dm_byte(p_wf,*((ubyte_ *) p));
X    if (*p=='\n')
X       wf_wl(p_wf,"");
X   }
X wf_wl(p_wf,"\"");
X}
X
X/******************************************************************************/
X
LOCAL void dm_scls P_((p_wf_t,p_scls_t));
LOCAL void dm_scls(p_wf,p_scls)
X/* Dumps the specified scrap list to the specified stream. */
p_wf_t   p_wf;
p_scls_t p_scls;
X{
X wf_wl(p_wf,"");
X centerln(p_wf,30,'-',"Start of Text Scrap List");
X ls_fir(p_scls);
X while (TRUE)
X   {
X    p_sc_t p_sc;
X    ls_nxt(p_scls,PPV &p_sc);
X    if (p_sc==NULL) break;
X    dm_sc(p_wf,p_sc);
X   }
X centerln(p_wf,30,'-',"End of Text Scrap List");
X wf_wl(p_wf,"");
X}
X
X/******************************************************************************/
X
XEXPORT void dm_tkls(p_wf)
p_wf_t p_wf;
X{
X tk_t *token;
X char *m;
X ubyte font;
X ubyte align;
X
X wf_wl(p_wf,"");
X centerln(p_wf,DUMP_WIDTH,'=',"Start of TOKEN LIST DUMP");
X wf_wl(p_wf,"");
X sprintf(linet1,"Summary: There are %lu tokens in the token list.",
X                (ulong) ls_len(token_list));
X wf_wl(p_wf,linet1);
X wf_wl(p_wf,"");
X wf_wl(p_wf,"Line[Column]: Token Description");
X wf_wl(p_wf,"-------------------------------");
X wf_wl(p_wf,"");
X
X ls_fir(token_list);
X ls_nxt(token_list,PPV &token);
X while (token != NULL)
X   {
X    sprintf(linet1,"%04lu[%02lu]: ",
X                   (ulong) token->tk_ps.ps_line,
X                   (ulong) token->tk_ps.ps_column);
X    wf_wr(p_wf,linet1);
X    switch (token->tk_kind)
X      {
X       case TK_TEXT: m="Text."              ; break;
X       case TK_MDEF: m="@$ Macro defn."     ; break;
X       case TK_FDEF: m="@F File defn."      ; break;
X       case TK_ONAM: m="@< Open name."      ; break;
X       case TK_CNAM: m="@> Close name."     ; break;
X       case TK_ODEF: m="@{ Open defn."      ; break;
X       case TK_CDEF: m="@} Close defn."     ; break;
X       case TK_OPAR: m="@( Open param."     ; break;
X       case TK_CPAR: m="@} Close param."    ; break;
X       case TK_COMA: m="@, Comma."          ; break;
X       case TK_QUOT: m="@\" Quote."         ; break;
X       case TK_PARM: m="@n Parameter."      ; break;
X       case TK_ZERO: m="@Z Zero calls."     ; break;
X       case TK_MANY: m="@M Many calls."     ; break;
X       case TK_NAME: m="@# Name."           ; break;
X       case TK_EMPH: m="@/ Emphasise."      ; break;
X       case TK_NPAG: m="@t.. Newpage."      ; break;
X       case TK_TOCS: m="@t.. TOC."          ; break;
X       case TK_SKIP: m="@t.. Vertical skip."; break;
X       case TK_TITL: m="@t.. Title."        ; break;
X       case TK_EOF : m="End Of File."       ; break;
X       case TK_NSEC:
X          switch (token->tk_gen)
X            {
X             case 0: m="@* New section (Level 0)."; break;
X             case 1: m="@A New section (Level 1)."; break;
X             case 2: m="@B New section (Level 2)."; break;
X             case 3: m="@C New section (Level 3)."; break;
X             case 4: m="@D New section (Level 4)."; break;
X             case 5: m="@E New section (Level 5)."; break;
X             default: as_bomb("dmtkls: Level case defaulted.");
X            }
X          break;
X       default: as_bomb("dmtkls: Token case defaulted.");
X      }
X    wf_wr(p_wf,m);
X    wf_wr(p_wf," ");
X    switch (token->tk_kind)
X      {
X       case TK_PARM:
X          sprintf(linet1,"Parameterno=%u.",(unsigned) token->tk_gen);
X          wf_wl(p_wf,linet1);
X          break;
X       case TK_NAME:
X          wf_wr(p_wf,"Character='");
X          dm_byte(p_wf,token->tk_gen);
X          wf_wl(p_wf,"'.");
X          break;
X       case TK_TEXT:
X          dm_sc(p_wf,&token->tk_sc);
X          break;
X       case TK_SKIP:
X          sprintf(linet1,"Vertical space skipped=%lumm.",
X                  (ulong) token->tk_gen);
X          wf_wl(p_wf,linet1);
X          break;
X       case TK_TITL:
X          font  = token->tk_gen / LRFT_PACK;
X          align = token->tk_gen % LRFT_PACK;
X          wf_wr(p_wf,"Font=");        wf_wr(p_wf,fontname(font));
X          wf_wr(p_wf,", Alignment="); wf_wr(p_wf,alignname(align));
X          wf_wl(p_wf,". Title text follows:");
X          dm_sc(p_wf,&token->tk_sc);
X          break;
X       default: wf_wl(p_wf,""); break;
X      }
X    ls_nxt(token_list,PPV &token);
X   } /* End of while loop. */
X
X centerln(p_wf,DUMP_WIDTH,'=',"End of TOKEN LIST DUMP");
X wf_wl(p_wf,"");
X}
X
X/******************************************************************************/
X
LOCAL void dm_eltx P_((p_wf_t,p_el_t));
LOCAL void dm_eltx (p_wf,p_el)
X/* Dumps the specified text element to the specified stream. */
p_wf_t p_wf;
p_el_t p_el;
X{
X p_sc_t p_sc;
X
X wf_wl(p_wf,"");
X centerln(p_wf,30,'-',"Start Text Element");
X
X ls_fir(p_el->el_text);
X ls_nxt(p_el->el_text,PPV &p_sc);
X while (p_sc != NULL)
X   {
X    dm_sc(p_wf,p_sc);
X    ls_nxt(p_el->el_text,PPV &p_sc);
X   }
X centerln(p_wf,30,'-',"End Text Element");
X wf_wl(p_wf,"");
X}
X
X/******************************************************************************/
X
LOCAL void dm_elin P_((p_wf_t,p_el_t));
LOCAL void dm_elin(p_wf,p_el)
X/* Dumps the specified invocation element to the specified stream. */
p_wf_t p_wf;
p_el_t p_el;
X{
X ulong    parno;
X p_ells_t *pp_ex;
X p_ells_t p_ex;
X p_elll_t p_elll = p_el->el_parls;
X
X wf_wl(p_wf,"");
X centerln(p_wf,30,'-',"Begin Invocation Element");
X
X sprintf(linet1,"Invocation of macro @<%s@>",&p_el->el_p_mac->ma_name[0]);
X wf_wl(p_wf,linet1);
X
X if (ls_len(p_elll)==0)
X    wf_wl(p_wf,"No actual parameters.");
X else
X   {
X    sprintf(linet1,"This invocation has %lu actual parameters.",
X            (ulong) ls_len(p_elll));
X    wf_wl(p_wf,linet1);
X    wf_wl(p_wf,
X    "Actual parameter list follows as a sequence of expressions:");
X    wf_wl(p_wf,"(Text crud before and after parameter has been omitted).");
X    parno=1;
X    ls_fir(p_elll);
X    while (TRUE)
X      {
X       ls_nxt(p_elll,PPV &pp_ex);
X       if (pp_ex==NULL) break;
X       p_ex = *pp_ex;
X       sprintf(linet1,"Expression for parameter number %lu:",(ulong) parno);
X       wf_wl(p_wf,linet1);
X       dm_ex(p_wf,p_ex);
X       parno++;
X      }
X   }
X
X centerln(p_wf,30,'-',"End Invocation Element");
X wf_wl(p_wf,"");
X}
X
X/******************************************************************************/
X
LOCAL void dm_elpr P_((p_wf_t,p_el_t));
LOCAL void dm_elpr(p_wf,p_el)
X/* Dumps the specified parameter element to the specified stream. */
p_wf_t p_wf;
p_el_t p_el;
X{
X wf_wl(p_wf,"");
X centerln(p_wf,30,'-',"Start Parameter Element");
X sprintf(linet1,"Parameter number=%lu.",(ulong) p_el->el_parno);
X wf_wl(p_wf,linet1);
X sprintf(linet1,"Parameter is of macro \"%s\".",
X         &p_el->el_which->ma_name[0]);
X wf_wl(p_wf,linet1);
X centerln(p_wf,30,'-',"End Parameter Element");
X wf_wl(p_wf,"");
X}
X
X/******************************************************************************/
X
LOCAL void dm_ex(p_wf,p_ex)
X/* Dumps the specified expression to the specified stream. */
p_wf_t   p_wf;
p_ells_t p_ex;
X{
X p_el_t p_el;
X
X wf_wl(p_wf,"");
X centerln(p_wf,30,'-',"Start of Expression");
X ls_fir(p_ex);
X ls_nxt(p_ex,PPV &p_el);
X while (p_el != NULL)
X   {
X    switch (p_el->el_kind)
X      {
X       case EL_TEXT: dm_eltx(p_wf,p_el); break;
X       case EL_INVC: dm_elin(p_wf,p_el); break;
X       case EL_PARM: dm_elpr(p_wf,p_el); break;
X       default     : as_bomb("dm_ex: Case defaulted.");
X      }
X    ls_nxt(p_ex,PPV &p_el);
X   }
X centerln(p_wf,30,'-',"End of Expression");
X wf_wl(p_wf,"");
X}
X
X/******************************************************************************/
X
LOCAL void dm_macro P_((p_wf_t,p_ma_t));
LOCAL void dm_macro(p_wf,p_ma)
X/* Dump all the information on the specified macro. */
p_wf_t p_wf;
p_ma_t p_ma;
X{
X wf_wl(p_wf,"");
X centerln(p_wf,DUMP_WIDTH-20,'-',"Start of Macro Dump");
X
X /* A macro can't exist in the macro table without a name. */
X sprintf(linet1,"Macro Name  : \"%s\"",p_ma->ma_name); wf_wl(p_wf,linet1);
X
X /* Is the macro defined? */
X if (!p_ma->ma_defn.md_isdef) wf_wl(p_wf,"Defined?    : No.");
X                         else wf_wl(p_wf,"Defined?    : Yes.");
X
X /* Defined macros carry lots more information. */
X if (p_ma->ma_defn.md_isdef)
X   {
X    /* Number of parameters the macro has. */
X    sprintf(linet1,"Parameters  : %lu",(ulong) p_ma->ma_defn.md_npar);
X    wf_wl(p_wf,linet1);
X
X    /* Is the macro additive? */
X    if (p_ma->ma_defn.md_isadd) wf_wl(p_wf,"Additive?   : Yes.");
X                           else wf_wl(p_wf,"Additive?   : No.");
X
X    /* Is the macro allowed to be called zero times? */
X    if (p_ma->ma_defn.md_iszer) wf_wl(p_wf,"Zero Calls? : Yes.");
X                           else wf_wl(p_wf,"Zero Calls? : No.");
X
X    /* Is the macro allowed to be called many times? */
X    if (p_ma->ma_defn.md_isman) wf_wl(p_wf,"Many Calls? : Yes.");
X                           else wf_wl(p_wf,"Many Calls? : No.");
X
X    /* Is the macro connected to an product file? */
X    if (p_ma->ma_defn.md_isfil) wf_wl(p_wf,"Output File?: Yes.");
X                           else wf_wl(p_wf,"Output File?: No.");
X
X    /* Dump a list of all the calls to the macro. */
X    {
X     p_mc_t p_mc;
X     ulong  mcnum;
X     wf_wl(p_wf,"Call list   :");
X     ls_fir(p_ma->ma_calls);
X     ls_nxt(p_ma->ma_calls,PPV &p_mc);
X     mcnum=1;
X     while (p_mc != NULL)
X       {
X        sprintf(linet1,
X "   Call %lu: Parameters=%lu, Sequence num=%lu, Position(L,C)=(%lu,%lu).",
X                (ulong) mcnum,
X                (ulong) p_mc->mc_npar,
X                (ulong) p_mc->mc_seq,
X                (ulong) p_mc->mc_ps.ps_line,
X                (ulong) p_mc->mc_ps.ps_column);
X        wf_wl(p_wf,linet1);
X        ls_nxt(p_ma->ma_calls,PPV &p_mc);
X        mcnum++;
X       }
X    }
X
X    /* Dump a list of the body parts of the macro. */
X    {
X     p_bp_t p_bp;
X     ulong  bpnum;
X     ulong  bptot = ls_len(p_ma->ma_defn.md_body);
X     wf_wl(p_wf,"Macro body  :");
X     wf_wl(p_wf,"");
X     wf_wl(p_wf,"--Start of List of Body Parts--");
X     sprintf(linet1,"This macro has %lu body part",(ulong) bptot);
X     if (bptot!=1) strcat(linet1,"s");
X     strcat(linet1,".");
X     wf_wl(p_wf,linet1);
X     bpnum=1;
X     ls_fir(p_ma->ma_defn.md_body);
X     ls_nxt(p_ma->ma_defn.md_body,PPV &p_bp);
X     while (p_bp != NULL)
X       {
X        sprintf(linet1,
X        "Body part %lu: Seqnum=%lu, Pos(L,C)=(%lu,%lu), Expression follows:",
X                (ulong) bpnum,
X                (ulong) p_bp->bp_seq,
X                (ulong) p_bp->bp_ps.ps_line,
X                (ulong) p_bp->bp_ps.ps_column);
X        wf_wl(p_wf,linet1);
X        dm_ex(p_wf,p_bp->bp_ex);
X        ls_nxt(p_ma->ma_defn.md_body,PPV &p_bp);
X        bpnum++;
X       }
X     wf_wl(p_wf,"---End of List of Body Parts---");
X     wf_wl(p_wf,"");
X    }
X
X   } /* End of IF defined. */
X
X centerln(p_wf,DUMP_WIDTH-20,'-',"End of Macro Dump");
X wf_wl(p_wf,"");
X}
X
X/******************************************************************************/
X
XEXPORT void dm_matb P_((p_wf_t));
XEXPORT void dm_matb(p_wf)
p_wf_t p_wf;
X{
X wf_wl(p_wf,"");
X centerln(p_wf,DUMP_WIDTH,'=',"Start of MACRO TABLE DUMP");
X wf_wl(p_wf,"");
X tb_fir(macro_table);
X while (TRUE)
X   {
X    name_t name;
X    p_ma_t p_ma;
X    if (!tb_rea(macro_table,PV &name[0],PV &p_ma)) break;
X    dm_macro(p_wf,p_ma);
X    wf_wl(p_wf,"");
X   }
X wf_wl(p_wf,"");
X centerln(p_wf,DUMP_WIDTH,'=',"End of MACRO TABLE DUMP");
X wf_wl(p_wf,"");
X}
X
X/******************************************************************************/
X
LOCAL void dm_ty P_((p_wf_t,p_ty_t));
LOCAL void dm_ty(p_wf,p_ty)
p_wf_t p_wf;
p_ty_t p_ty;
X{
X char linet2[200];
X char linet3[200];
X
X switch (p_ty->ty_kind)
X   {
X    case TY_NSEC:
X       sn_str(&p_ty->ty_sn,linet2);
X       strcpy(linet3,"<No name>");
X       if (p_ty->ty_isnam) strcpy(linet3,&p_ty->ty_name[0]);
X       sprintf(linet1,"   Section \"%s\", Section name=\"%s\".",linet2,linet3);
X       wf_wl(p_wf,"");
X       wf_wl(p_wf,linet1);
X       break;
X    case TY_OLIT: wf_wl(p_wf,"   Open  literal."    ); break;
X    case TY_CLIT: wf_wl(p_wf,"   Close literal."    ); break;
X    case TY_OEMP: wf_wl(p_wf,"   Open emphasise."   ); break;
X    case TY_CEMP: wf_wl(p_wf,"   Close emphasise."  ); break;
X    case TY_NPAG: wf_wl(p_wf,"   New page."         ); break;
X    case TY_TOCS: wf_wl(p_wf,"   Table of contents."); break;
X    case TY_SKIP:
X       sprintf(linet1,"   Vertical skip by %lu mm.",(ulong) p_ty->ty_mm);
X       wf_wl(p_wf,linet1);
X       break;
X    case TY_TITL:
X       wf_wr(p_wf,"Font=");        wf_wr(p_wf,fontname(p_ty->ty_font));
X       wf_wr(p_wf,", Alignment="); wf_wr(p_wf,alignname(p_ty->ty_align));
X       wf_wl(p_wf,". Title text follows:");
X       dm_sc(p_wf,&p_ty->ty_sc);
X       break;
X    default: as_bomb("dm_ty: Typesetter directive switch defaulted.");
X   }
X}
X
X/******************************************************************************/
X
XEXPORT void dm_dcls(p_wf)
X/* Dumps a text representation of the document list to the given stream.      */
p_wf_t p_wf;
X{
X wf_wl(p_wf,"");
X centerln(p_wf,DUMP_WIDTH,'=',"Start of DOCUMENT LIST DUMP");
X wf_wl(p_wf,"");
X
X ls_fir(document_list);
X while (TRUE)
X   {
X    p_dc_t p_dc;
X    ls_nxt(document_list,PPV &p_dc);
X    if (p_dc == NULL) break;
X    wf_wl(p_wf,"");
X    sprintf(linet1,"Pos(L,C)=(%lu,%lu). ",
X            p_dc->dc_ps.ps_line,
X            p_dc->dc_ps.ps_column);
X    switch (p_dc->dc_kind)
X      {
X       case DC_TEXT:
X          wf_wr(p_wf,"TEXT COMPONENT: "); wf_wl(p_wf,linet1);
X          dm_scls(p_wf,p_dc->dc_text);
X          break;
X
X       case DC_TYPE:
X          wf_wr(p_wf,"TYPESETTER DIRECTIVE COMPONENT: ");
X          dm_ty(p_wf,&p_dc->dc_ty);
X          break;
X
X       case DC_MACR:
X          wf_wr(p_wf,"MACRO DEFINITION COMPONENT: "); wf_wl(p_wf,linet1);
X          sprintf(linet1,"Part %lu of macro @<%s@>.",
X                  p_dc->dc_part,
X                  &p_dc->dc_p_ma->ma_name[0]);
X          wf_wl(p_wf,linet1);
X          break;
X
X       default: as_bomb("dm_scls: Case defaulted.");
X      }
X   }
X
X wf_wl(p_wf,"");
X centerln(p_wf,DUMP_WIDTH,'=',"End of DOCUMENT LIST DUMP");
X wf_wl(p_wf,"");
X}
X
X/******************************************************************************/
X
LOCAL void tm_for P_((p_wf_t,char *,p_ck_t,p_ck_t));
LOCAL void tm_for(p_wf,s,p_val,p_tot)
X/* This rather ragged function simplifies the formatting in dm_times.         */
p_wf_t p_wf;
char   *s;
p_ck_t p_val;
p_ck_t p_tot;
X{
X sprintf(linet1,"|%s| %3d%% | %8.2f | %8.2f | %3d%% |",
X         s,
X         (int)   ((100.0*ck_cpu(p_val))/ck_cpu(p_tot)),
X         (float) ck_cpu(p_val),
X         (float) ck_real(p_val),
X         (int)   ((100.0*ck_real(p_val))/ck_real(p_tot))
X        );
X wf_wl(p_wf,linet1);
X}
X
X/******************************************************************************/
X
XEXPORT void dm_times(p_wf,
X                     p_mapp,p_scan,p_pars,p_anal,
X                     p_dump,p_lstr,p_tang,p_weav,p_totl)
p_wf_t p_wf;
p_ck_t p_mapp;
p_ck_t p_scan;
p_ck_t p_pars;
p_ck_t p_anal;
p_ck_t p_dump;
p_ck_t p_lstr;
p_ck_t p_tang;
p_ck_t p_weav;
p_ck_t p_totl;
X{
X float cputot;
X float realtot;
X float cpuerr;
X float realerr;
X
X cputot = ck_cpu(p_mapp) + ck_cpu(p_scan) + ck_cpu(p_pars) +
X          ck_cpu(p_anal) + ck_cpu(p_dump) + ck_cpu(p_lstr) +
X          ck_cpu(p_tang) + ck_cpu(p_weav);
X
X realtot = ck_real(p_mapp) + ck_real(p_scan) + ck_real(p_pars) +
X           ck_real(p_anal) + ck_real(p_dump) + ck_real(p_lstr) +
X           ck_real(p_tang) + ck_real(p_weav);
X
X cpuerr  = ck_cpu (p_totl)-cputot;
X realerr = ck_real(p_totl)-realtot;
X
X wf_wl(p_wf,"");
X wf_wl(p_wf,"Summary of time used by each subsystem of Funnelweb (seconds).");
X wf_wl(p_wf,"");
X wf_wl(p_wf,    "+------------+------+----------+----------+------+");
X wf_wl(p_wf,    "| Subsystem  | CPU% | CPU Time | RealTime |  RT% |");
X wf_wl(p_wf,    "+------------+------+----------+----------+------+");
X tm_for(p_wf," Mapper     ",p_mapp,p_totl);
X tm_for(p_wf," Scanner    ",p_scan,p_totl);
X tm_for(p_wf," Parser     ",p_pars,p_totl);
X tm_for(p_wf," Analyser   ",p_anal,p_totl);
X tm_for(p_wf," Dumper     ",p_dump,p_totl);
X tm_for(p_wf," Lister     ",p_lstr,p_totl);
X tm_for(p_wf," Tangler    ",p_tang,p_totl);
X tm_for(p_wf," Weaver     ",p_weav,p_totl);
X sprintf(linet1,"|%s| %3d%% | %8.2f | %8.2f | %3d%% |",
X         " Clock Err  ",
X         (int)   ((100.0*cpuerr )/ck_cpu (p_totl)),
X         (float)                            cpuerr,
X         (float)                           realerr,
X         (int)   ((100.0*realerr)/ck_real(p_totl))
X        );
X wf_wl(p_wf,linet1);
X
X wf_wl(p_wf,    "+------------+------+----------+----------+------+");
X tm_for(p_wf," Total      ",p_totl,p_totl);
X wf_wl(p_wf,    "+------------+------+----------+----------+------+");
X wf_wl(p_wf,"");
X}
X
X/******************************************************************************/
X/*                                 End of DUMP.C                              */
X/******************************************************************************/
END_OF_FILE
if test 24980 -ne `wc -c <'sources/dump.c'`; then
    echo shar: \"'sources/dump.c'\" unpacked with wrong size!
fi
# end of 'sources/dump.c'
fi
echo shar: End of archive 12 \(of 20\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 20 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
