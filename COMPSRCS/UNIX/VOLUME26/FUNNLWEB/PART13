Newsgroups: comp.sources.unix
From: ross@spam.adelaide.edu.au (Ross Williams)
Subject: v26i133: funnelweb - a tool for literate programming in C, Part13/20
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: ross@spam.adelaide.edu.au (Ross Williams)
Posting-Number: Volume 26, Issue 133
Archive-Name: funnelweb/part13

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 13 (of 20)."
# Contents:  answers/pr05.lis sources/help.c sources/weave.c
#   userman/u_manual.sin
# Wrapped by vixie@gw.home.vix.com on Sun Apr 11 11:00:28 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'answers/pr05.lis' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'answers/pr05.lis'\"
else
echo shar: Extracting \"'answers/pr05.lis'\" \(28430 characters\)
sed "s/^X//" >'answers/pr05.lis' <<'END_OF_FILE'
XFUNNELWEB LISTING FILE
X======================
X
Dump of mapped file "<<Suppressed>>".
X
MEMORY DUMP OF MAPPED FILE
X==========================
X
X+-------------------------------------------------+------------------+
X| 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | 0123456789ABCDEF |
X+-------------------------------------------------+------------------+
X| 50 52 30 35 3A 20 54 65 73 74 20 74 68 65 20 70 | PR05: Test the p |
X| 61 72 73 69 6E 67 20 6F 66 20 66 6F 72 6D 61 6C | arsing of formal |
X| 20 70 61 72 61 6D 65 74 65 72 20 6C 69 73 74 73 |  parameter lists |
X| 2E 0A 0A 46 69 72 73 74 20 74 72 69 70 20 74 68 | ...First trip th |
X| 65 20 70 61 72 73 65 72 20 73 6F 20 77 65 20 64 | e parser so we d |
X| 6F 6E 27 74 20 67 65 74 20 70 61 73 74 20 74 68 | on't get past th |
X| 65 20 70 61 72 73 65 72 2E 0A 40 3E 0A 0A 31 2E | e parser..@>..1. |
X| 20 54 65 73 74 20 6D 61 63 72 6F 20 64 65 66 69 |  Test macro defi |
X| 6E 69 74 69 6F 6E 20 77 69 74 68 20 6E 6F 20 66 | nition with no f |
X| 6F 72 6D 61 6C 20 70 61 72 61 6D 65 74 65 72 73 | ormal parameters |
X| 2E 0A 40 24 40 3C 53 6C 6F 74 68 40 3E 40 7B 53 | ..@$@<Sloth@>@{S |
X| 6C 6F 74 68 74 65 78 74 40 7D 0A 0A 32 2E 20 54 | lothtext@}..2. T |
X| 65 73 74 20 6D 61 63 72 6F 20 64 65 66 69 6E 69 | est macro defini |
X| 74 69 6F 6E 20 77 69 74 68 20 6F 6E 65 20 66 6F | tion with one fo |
X| 72 6D 61 6C 20 70 61 72 61 6D 65 74 65 72 2E 0A | rmal parameter.. |
X| 40 24 40 3C 53 6C 6F 74 68 20 77 69 74 68 20 6F | @$@<Sloth with o |
X| 6E 65 40 3E 40 28 40 31 40 29 40 7B 53 6C 6F 74 | ne@>@(@1@)@{Slot |
X| 68 74 65 78 74 40 7D 0A 0A 33 2E 20 54 65 73 74 | htext@}..3. Test |
X| 20 6D 61 63 72 6F 20 64 65 66 69 6E 69 74 69 6F |  macro definitio |
X| 6E 20 77 69 74 68 20 6D 61 6E 79 20 66 6F 72 6D | n with many form |
X| 61 6C 20 70 61 72 61 6D 65 74 65 72 73 2E 0A 40 | al parameters..@ |
X| 24 40 3C 53 6C 6F 74 68 20 77 69 74 68 20 32 40 | $@<Sloth with 2@ |
X| 3E 40 28 40 32 40 29 40 7B 53 6C 6F 74 68 74 65 | >@(@2@)@{Slothte |
X| 78 74 40 7D 0A 40 24 40 3C 53 6C 6F 74 68 20 77 | xt@}.@$@<Sloth w |
X| 69 74 68 20 33 40 3E 40 28 40 33 40 29 40 7B 53 | ith 3@>@(@3@)@{S |
X| 6C 6F 74 68 74 65 78 74 40 7D 0A 40 24 40 3C 53 | lothtext@}.@$@<S |
X| 6C 6F 74 68 20 77 69 74 68 20 34 40 3E 40 28 40 | loth with 4@>@(@ |
X| 34 40 29 40 7B 53 6C 6F 74 68 74 65 78 74 40 7D | 4@)@{Slothtext@} |
X| 0A 40 24 40 3C 53 6C 6F 74 68 20 77 69 74 68 20 | .@$@<Sloth with  |
X| 35 40 3E 40 28 40 35 40 29 40 7B 53 6C 6F 74 68 | 5@>@(@5@)@{Sloth |
X| 74 65 78 74 40 7D 0A 40 24 40 3C 53 6C 6F 74 68 | text@}.@$@<Sloth |
X| 20 77 69 74 68 20 36 40 3E 40 28 40 36 40 29 40 |  with 6@>@(@6@)@ |
X| 7B 53 6C 6F 74 68 74 65 78 74 40 7D 0A 40 24 40 | {Slothtext@}.@$@ |
X| 3C 53 6C 6F 74 68 20 77 69 74 68 20 37 40 3E 40 | <Sloth with 7@>@ |
X| 28 40 37 40 29 40 7B 53 6C 6F 74 68 74 65 78 74 | (@7@)@{Slothtext |
X| 40 7D 0A 40 24 40 3C 53 6C 6F 74 68 20 77 69 74 | @}.@$@<Sloth wit |
X| 68 20 38 40 3E 40 28 40 38 40 29 40 7B 53 6C 6F | h 8@>@(@8@)@{Slo |
X| 74 68 74 65 78 74 40 7D 0A 40 24 40 3C 53 6C 6F | thtext@}.@$@<Slo |
X| 74 68 20 77 69 74 68 20 39 40 3E 40 28 40 39 40 | th with 9@>@(@9@ |
X| 29 40 7B 53 6C 6F 74 68 74 65 78 74 40 7D 0A 0A | )@{Slothtext@}.. |
X| 34 2E 20 54 65 73 74 20 77 69 74 68 20 73 79 6E | 4. Test with syn |
X| 74 61 78 20 65 72 72 6F 72 73 20 69 6E 20 74 68 | tax errors in th |
X| 65 20 70 61 72 61 6D 65 74 65 72 20 6C 69 73 74 | e parameter list |
X| 2E 0A 0A 40 24 40 3C 53 6C 6F 74 68 20 61 40 3E | ...@$@<Sloth a@> |
X| 40 28 40 2B 40 39 40 29 40 7B 53 6C 6F 74 68 74 | @(@+@9@)@{Slotht |
X| 65 78 74 40 7D 0A 40 41 40 3C 45 72 72 6F 72 20 | ext@}.@A@<Error  |
X| 72 65 63 6F 76 65 72 79 20 70 6F 69 6E 74 40 3E | recovery point@> |
X| 0A 0A 40 24 40 3C 53 6C 6F 74 68 20 62 40 3E 40 | ..@$@<Sloth b@>@ |
X| 39 40 29 40 7B 53 6C 6F 74 68 74 65 78 74 40 7D | 9@)@{Slothtext@} |
X| 0A 40 41 40 3C 45 72 72 6F 72 20 72 65 63 6F 76 | .@A@<Error recov |
X| 65 72 79 20 70 6F 69 6E 74 40 3E 0A 0A 40 24 40 | ery point@>..@$@ |
X| 3C 53 6C 6F 74 68 20 63 40 3E 40 28 39 40 29 40 | <Sloth c@>@(9@)@ |
X| 7B 53 6C 6F 74 68 74 65 78 74 40 7D 0A 40 41 40 | {Slothtext@}.@A@ |
X| 3C 45 72 72 6F 72 20 72 65 63 6F 76 65 72 79 20 | <Error recovery  |
X| 70 6F 69 6E 74 40 3E 0A 0A 40 24 40 3C 53 6C 6F | point@>..@$@<Slo |
X| 74 68 20 64 40 3E 40 39 40 29 40 7B 53 6C 6F 74 | th d@>@9@)@{Slot |
X| 68 74 65 78 74 40 7D 0A 40 41 40 3C 45 72 72 6F | htext@}.@A@<Erro |
X| 72 20 72 65 63 6F 76 65 72 79 20 70 6F 69 6E 74 | r recovery point |
X| 40 3E 0A 0A 40 24 40 3C 53 6C 6F 74 68 20 65 40 | @>..@$@<Sloth e@ |
X| 3E 40 28 40 39 40 29 40 29 40 7B 53 6C 6F 74 68 | >@(@9@)@)@{Sloth |
X| 74 65 78 74 40 7D 0A 40 41 40 3C 45 72 72 6F 72 | text@}.@A@<Error |
X| 20 72 65 63 6F 76 65 72 79 20 70 6F 69 6E 74 40 |  recovery point@ |
X| 3E 0A 0A 0A 0A                                  | >....            |
X+-------------------------------------------------+------------------+
X
X
X=========================== Start of LINE LIST DUMP ============================
X
Globl Local| Text
X-----------+--------------------------------------------------------------------
X00001 00001| PR05: Test the parsing of formal parameter lists.<010>
X00002 00002| <010>
X00003 00003| First trip the parser so we don't get past the parser.<010>
X00004 00004| @><010>
X00005 00005| <010>
X00006 00006| 1. Test macro definition with no formal parameters.<010>
X00007 00007| @$@<Sloth@>@{Slothtext@}<010>
X00008 00008| <010>
X00009 00009| 2. Test macro definition with one formal parameter.<010>
X00010 00010| @$@<Sloth with one@>@(@1@)@{Slothtext@}<010>
X00011 00011| <010>
X00012 00012| 3. Test macro definition with many formal parameters.<010>
X00013 00013| @$@<Sloth with 2@>@(@2@)@{Slothtext@}<010>
X00014 00014| @$@<Sloth with 3@>@(@3@)@{Slothtext@}<010>
X00015 00015| @$@<Sloth with 4@>@(@4@)@{Slothtext@}<010>
X00016 00016| @$@<Sloth with 5@>@(@5@)@{Slothtext@}<010>
X00017 00017| @$@<Sloth with 6@>@(@6@)@{Slothtext@}<010>
X00018 00018| @$@<Sloth with 7@>@(@7@)@{Slothtext@}<010>
X00019 00019| @$@<Sloth with 8@>@(@8@)@{Slothtext@}<010>
X00020 00020| @$@<Sloth with 9@>@(@9@)@{Slothtext@}<010>
X00021 00021| <010>
X00022 00022| 4. Test with syntax errors in the parameter list.<010>
X00023 00023| <010>
X00024 00024| @$@<Sloth a@>@(@+@9@)@{Slothtext@}<010>
X00025 00025| @A@<Error recovery point@><010>
X00026 00026| <010>
X00027 00027| @$@<Sloth b@>@9@)@{Slothtext@}<010>
X00028 00028| @A@<Error recovery point@><010>
X00029 00029| <010>
X00030 00030| @$@<Sloth c@>@(9@)@{Slothtext@}<010>
X00031 00031| @A@<Error recovery point@><010>
X00032 00032| <010>
X00033 00033| @$@<Sloth d@>@9@)@{Slothtext@}<010>
X00034 00034| @A@<Error recovery point@><010>
X00035 00035| <010>
X00036 00036| @$@<Sloth e@>@(@9@)@)@{Slothtext@}<010>
X00037 00037| @A@<Error recovery point@><010>
X00038 00038| <010>
X00039 00039| <010>
X00040 00040| <010>
X00041 00041| <End-Of-File><010>
X-----------+--------------------------------------------------------------------
Globl Local| Text
X
X============================ End of LINE LIST DUMP =============================
X
X
X=========================== Start of TOKEN LIST DUMP ===========================
X
Summary: There are 191 tokens in the token list.
X
Line[Column]: Token Description
X-------------------------------
X
X0001[01]: Text. Text scrap[Grey]="PR05: Test the parsing of formal parameter lists.<010>
X<010>
XFirst trip the parser so we don't get past the parser.<010>
X"
X0004[01]: @> Close name. 
X0004[03]: Text. Text scrap[Grey]="<010>
X<010>
X1. Test macro definition with no formal parameters.<010>
X"
X0007[01]: @$ Macro defn. 
X0007[03]: @< Open name. 
X0007[05]: Text. Text scrap[Grey]="Sloth"
X0007[10]: @> Close name. 
X0007[12]: @{ Open defn. 
X0007[14]: Text. Text scrap[Grey]="Slothtext"
X0007[23]: @} Close defn. 
X0007[25]: Text. Text scrap[Grey]="<010>
X<010>
X2. Test macro definition with one formal parameter.<010>
X"
X0010[01]: @$ Macro defn. 
X0010[03]: @< Open name. 
X0010[05]: Text. Text scrap[Grey]="Sloth with one"
X0010[19]: @> Close name. 
X0010[21]: @( Open param. 
X0010[23]: @n Parameter. Parameterno=1.
X0010[25]: @} Close param. 
X0010[27]: @{ Open defn. 
X0010[29]: Text. Text scrap[Grey]="Slothtext"
X0010[38]: @} Close defn. 
X0010[40]: Text. Text scrap[Grey]="<010>
X<010>
X3. Test macro definition with many formal parameters.<010>
X"
X0013[01]: @$ Macro defn. 
X0013[03]: @< Open name. 
X0013[05]: Text. Text scrap[Grey]="Sloth with 2"
X0013[17]: @> Close name. 
X0013[19]: @( Open param. 
X0013[21]: @n Parameter. Parameterno=2.
X0013[23]: @} Close param. 
X0013[25]: @{ Open defn. 
X0013[27]: Text. Text scrap[Grey]="Slothtext"
X0013[36]: @} Close defn. 
X0013[38]: Text. Text scrap[White]="<010>
X"
X0014[01]: @$ Macro defn. 
X0014[03]: @< Open name. 
X0014[05]: Text. Text scrap[Grey]="Sloth with 3"
X0014[17]: @> Close name. 
X0014[19]: @( Open param. 
X0014[21]: @n Parameter. Parameterno=3.
X0014[23]: @} Close param. 
X0014[25]: @{ Open defn. 
X0014[27]: Text. Text scrap[Grey]="Slothtext"
X0014[36]: @} Close defn. 
X0014[38]: Text. Text scrap[White]="<010>
X"
X0015[01]: @$ Macro defn. 
X0015[03]: @< Open name. 
X0015[05]: Text. Text scrap[Grey]="Sloth with 4"
X0015[17]: @> Close name. 
X0015[19]: @( Open param. 
X0015[21]: @n Parameter. Parameterno=4.
X0015[23]: @} Close param. 
X0015[25]: @{ Open defn. 
X0015[27]: Text. Text scrap[Grey]="Slothtext"
X0015[36]: @} Close defn. 
X0015[38]: Text. Text scrap[White]="<010>
X"
X0016[01]: @$ Macro defn. 
X0016[03]: @< Open name. 
X0016[05]: Text. Text scrap[Grey]="Sloth with 5"
X0016[17]: @> Close name. 
X0016[19]: @( Open param. 
X0016[21]: @n Parameter. Parameterno=5.
X0016[23]: @} Close param. 
X0016[25]: @{ Open defn. 
X0016[27]: Text. Text scrap[Grey]="Slothtext"
X0016[36]: @} Close defn. 
X0016[38]: Text. Text scrap[White]="<010>
X"
X0017[01]: @$ Macro defn. 
X0017[03]: @< Open name. 
X0017[05]: Text. Text scrap[Grey]="Sloth with 6"
X0017[17]: @> Close name. 
X0017[19]: @( Open param. 
X0017[21]: @n Parameter. Parameterno=6.
X0017[23]: @} Close param. 
X0017[25]: @{ Open defn. 
X0017[27]: Text. Text scrap[Grey]="Slothtext"
X0017[36]: @} Close defn. 
X0017[38]: Text. Text scrap[White]="<010>
X"
X0018[01]: @$ Macro defn. 
X0018[03]: @< Open name. 
X0018[05]: Text. Text scrap[Grey]="Sloth with 7"
X0018[17]: @> Close name. 
X0018[19]: @( Open param. 
X0018[21]: @n Parameter. Parameterno=7.
X0018[23]: @} Close param. 
X0018[25]: @{ Open defn. 
X0018[27]: Text. Text scrap[Grey]="Slothtext"
X0018[36]: @} Close defn. 
X0018[38]: Text. Text scrap[White]="<010>
X"
X0019[01]: @$ Macro defn. 
X0019[03]: @< Open name. 
X0019[05]: Text. Text scrap[Grey]="Sloth with 8"
X0019[17]: @> Close name. 
X0019[19]: @( Open param. 
X0019[21]: @n Parameter. Parameterno=8.
X0019[23]: @} Close param. 
X0019[25]: @{ Open defn. 
X0019[27]: Text. Text scrap[Grey]="Slothtext"
X0019[36]: @} Close defn. 
X0019[38]: Text. Text scrap[White]="<010>
X"
X0020[01]: @$ Macro defn. 
X0020[03]: @< Open name. 
X0020[05]: Text. Text scrap[Grey]="Sloth with 9"
X0020[17]: @> Close name. 
X0020[19]: @( Open param. 
X0020[21]: @n Parameter. Parameterno=9.
X0020[23]: @} Close param. 
X0020[25]: @{ Open defn. 
X0020[27]: Text. Text scrap[Grey]="Slothtext"
X0020[36]: @} Close defn. 
X0020[38]: Text. Text scrap[Grey]="<010>
X<010>
X4. Test with syntax errors in the parameter list.<010>
X<010>
X"
X0024[01]: @$ Macro defn. 
X0024[03]: @< Open name. 
X0024[05]: Text. Text scrap[Grey]="Sloth a"
X0024[12]: @> Close name. 
X0024[14]: @( Open param. 
X0024[16]: Text. Text scrap[White]="<010>
X"
X0024[18]: @n Parameter. Parameterno=9.
X0024[20]: @} Close param. 
X0024[22]: @{ Open defn. 
X0024[24]: Text. Text scrap[Grey]="Slothtext"
X0024[33]: @} Close defn. 
X0024[35]: Text. Text scrap[White]="<010>
X"
X0025[01]: @A New section (Level 1). 
X0025[03]: @< Open name. 
X0025[05]: Text. Text scrap[Grey]="Error recovery point"
X0025[25]: @> Close name. 
X0025[27]: Text. Text scrap[White]="<010>
X<010>
X"
X0027[01]: @$ Macro defn. 
X0027[03]: @< Open name. 
X0027[05]: Text. Text scrap[Grey]="Sloth b"
X0027[12]: @> Close name. 
X0027[14]: @n Parameter. Parameterno=9.
X0027[16]: @} Close param. 
X0027[18]: @{ Open defn. 
X0027[20]: Text. Text scrap[Grey]="Slothtext"
X0027[29]: @} Close defn. 
X0027[31]: Text. Text scrap[White]="<010>
X"
X0028[01]: @A New section (Level 1). 
X0028[03]: @< Open name. 
X0028[05]: Text. Text scrap[Grey]="Error recovery point"
X0028[25]: @> Close name. 
X0028[27]: Text. Text scrap[White]="<010>
X<010>
X"
X0030[01]: @$ Macro defn. 
X0030[03]: @< Open name. 
X0030[05]: Text. Text scrap[Grey]="Sloth c"
X0030[12]: @> Close name. 
X0030[14]: @( Open param. 
X0030[16]: Text. Text scrap[Grey]="9"
X0030[17]: @} Close param. 
X0030[19]: @{ Open defn. 
X0030[21]: Text. Text scrap[Grey]="Slothtext"
X0030[30]: @} Close defn. 
X0030[32]: Text. Text scrap[White]="<010>
X"
X0031[01]: @A New section (Level 1). 
X0031[03]: @< Open name. 
X0031[05]: Text. Text scrap[Grey]="Error recovery point"
X0031[25]: @> Close name. 
X0031[27]: Text. Text scrap[White]="<010>
X<010>
X"
X0033[01]: @$ Macro defn. 
X0033[03]: @< Open name. 
X0033[05]: Text. Text scrap[Grey]="Sloth d"
X0033[12]: @> Close name. 
X0033[14]: @n Parameter. Parameterno=9.
X0033[16]: @} Close param. 
X0033[18]: @{ Open defn. 
X0033[20]: Text. Text scrap[Grey]="Slothtext"
X0033[29]: @} Close defn. 
X0033[31]: Text. Text scrap[White]="<010>
X"
X0034[01]: @A New section (Level 1). 
X0034[03]: @< Open name. 
X0034[05]: Text. Text scrap[Grey]="Error recovery point"
X0034[25]: @> Close name. 
X0034[27]: Text. Text scrap[White]="<010>
X<010>
X"
X0036[01]: @$ Macro defn. 
X0036[03]: @< Open name. 
X0036[05]: Text. Text scrap[Grey]="Sloth e"
X0036[12]: @> Close name. 
X0036[14]: @( Open param. 
X0036[16]: @n Parameter. Parameterno=9.
X0036[18]: @} Close param. 
X0036[20]: @} Close param. 
X0036[22]: @{ Open defn. 
X0036[24]: Text. Text scrap[Grey]="Slothtext"
X0036[33]: @} Close defn. 
X0036[35]: Text. Text scrap[White]="<010>
X"
X0037[01]: @A New section (Level 1). 
X0037[03]: @< Open name. 
X0037[05]: Text. Text scrap[Grey]="Error recovery point"
X0037[25]: @> Close name. 
X0037[27]: Text. Text scrap[White]="<010>
X<010>
X<010>
X<010>
X"
X0041[01]: End Of File. 
X============================ End of TOKEN LIST DUMP ============================
X
X
X========================== Start of MACRO TABLE DUMP ===========================
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth"
Defined?    : Yes.
Parameters  : 0
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 1 body part.
Body part 1: Seqnum=1, Pos(L,C)=(7,3), Expression follows:
X
X---- Start of Expression ----
X
X----- Start Text Element -----
Text scrap[Grey]="Slothtext"
X------ End Text Element ------
X
X----- End of Expression -----
X
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth a"
Defined?    : No.
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth b"
Defined?    : Yes.
Parameters  : 0
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 0 body parts.
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth c"
Defined?    : No.
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth d"
Defined?    : Yes.
Parameters  : 0
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 0 body parts.
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth e"
Defined?    : Yes.
Parameters  : 9
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 0 body parts.
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth with 2"
Defined?    : Yes.
Parameters  : 2
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 1 body part.
Body part 1: Seqnum=3, Pos(L,C)=(13,3), Expression follows:
X
X---- Start of Expression ----
X
X----- Start Text Element -----
Text scrap[Grey]="Slothtext"
X------ End Text Element ------
X
X----- End of Expression -----
X
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth with 3"
Defined?    : Yes.
Parameters  : 3
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 1 body part.
Body part 1: Seqnum=4, Pos(L,C)=(14,3), Expression follows:
X
X---- Start of Expression ----
X
X----- Start Text Element -----
Text scrap[Grey]="Slothtext"
X------ End Text Element ------
X
X----- End of Expression -----
X
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth with 4"
Defined?    : Yes.
Parameters  : 4
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 1 body part.
Body part 1: Seqnum=5, Pos(L,C)=(15,3), Expression follows:
X
X---- Start of Expression ----
X
X----- Start Text Element -----
Text scrap[Grey]="Slothtext"
X------ End Text Element ------
X
X----- End of Expression -----
X
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth with 5"
Defined?    : Yes.
Parameters  : 5
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 1 body part.
Body part 1: Seqnum=6, Pos(L,C)=(16,3), Expression follows:
X
X---- Start of Expression ----
X
X----- Start Text Element -----
Text scrap[Grey]="Slothtext"
X------ End Text Element ------
X
X----- End of Expression -----
X
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth with 6"
Defined?    : Yes.
Parameters  : 6
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 1 body part.
Body part 1: Seqnum=7, Pos(L,C)=(17,3), Expression follows:
X
X---- Start of Expression ----
X
X----- Start Text Element -----
Text scrap[Grey]="Slothtext"
X------ End Text Element ------
X
X----- End of Expression -----
X
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth with 7"
Defined?    : Yes.
Parameters  : 7
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 1 body part.
Body part 1: Seqnum=8, Pos(L,C)=(18,3), Expression follows:
X
X---- Start of Expression ----
X
X----- Start Text Element -----
Text scrap[Grey]="Slothtext"
X------ End Text Element ------
X
X----- End of Expression -----
X
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth with 8"
Defined?    : Yes.
Parameters  : 8
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 1 body part.
Body part 1: Seqnum=9, Pos(L,C)=(19,3), Expression follows:
X
X---- Start of Expression ----
X
X----- Start Text Element -----
Text scrap[Grey]="Slothtext"
X------ End Text Element ------
X
X----- End of Expression -----
X
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth with 9"
Defined?    : Yes.
Parameters  : 9
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 1 body part.
Body part 1: Seqnum=10, Pos(L,C)=(20,3), Expression follows:
X
X---- Start of Expression ----
X
X----- Start Text Element -----
Text scrap[Grey]="Slothtext"
X------ End Text Element ------
X
X----- End of Expression -----
X
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X------------------- Start of Macro Dump --------------------
Macro Name  : "Sloth with one"
Defined?    : Yes.
Parameters  : 1
Additive?   : No.
Zero Calls? : No.
Many Calls? : No.
Output File?: No.
Call list   :
Macro body  :
X
X--Start of List of Body Parts--
This macro has 1 body part.
Body part 1: Seqnum=2, Pos(L,C)=(10,3), Expression follows:
X
X---- Start of Expression ----
X
X----- Start Text Element -----
Text scrap[Grey]="Slothtext"
X------ End Text Element ------
X
X----- End of Expression -----
X
X---End of List of Body Parts---
X
X-------------------- End of Macro Dump ---------------------
X
X
X
X=========================== End of MACRO TABLE DUMP ============================
X
X
X========================= Start of DOCUMENT LIST DUMP ==========================
X
X
TEXT COMPONENT: Pos(L,C)=(1,1). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="PR05: Test the parsing of formal parameter lists.<010>
X<010>
XFirst trip the parser so we don't get past the parser.<010>
X"
X--- End of Text Scrap List ---
X
X
TEXT COMPONENT: Pos(L,C)=(4,3). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="<010>
X<010>
X1. Test macro definition with no formal parameters.<010>
X"
X--- End of Text Scrap List ---
X
X
MACRO DEFINITION COMPONENT: Pos(L,C)=(7,1). 
Part 1 of macro @<Sloth@>.
X
TEXT COMPONENT: Pos(L,C)=(7,25). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="<010>
X<010>
X2. Test macro definition with one formal parameter.<010>
X"
X--- End of Text Scrap List ---
X
X
MACRO DEFINITION COMPONENT: Pos(L,C)=(10,1). 
Part 1 of macro @<Sloth with one@>.
X
TEXT COMPONENT: Pos(L,C)=(10,40). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="<010>
X<010>
X3. Test macro definition with many formal parameters.<010>
X"
X--- End of Text Scrap List ---
X
X
MACRO DEFINITION COMPONENT: Pos(L,C)=(13,1). 
Part 1 of macro @<Sloth with 2@>.
X
TEXT COMPONENT: Pos(L,C)=(13,38). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
MACRO DEFINITION COMPONENT: Pos(L,C)=(14,1). 
Part 1 of macro @<Sloth with 3@>.
X
TEXT COMPONENT: Pos(L,C)=(14,38). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
MACRO DEFINITION COMPONENT: Pos(L,C)=(15,1). 
Part 1 of macro @<Sloth with 4@>.
X
TEXT COMPONENT: Pos(L,C)=(15,38). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
MACRO DEFINITION COMPONENT: Pos(L,C)=(16,1). 
Part 1 of macro @<Sloth with 5@>.
X
TEXT COMPONENT: Pos(L,C)=(16,38). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
MACRO DEFINITION COMPONENT: Pos(L,C)=(17,1). 
Part 1 of macro @<Sloth with 6@>.
X
TEXT COMPONENT: Pos(L,C)=(17,38). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
MACRO DEFINITION COMPONENT: Pos(L,C)=(18,1). 
Part 1 of macro @<Sloth with 7@>.
X
TEXT COMPONENT: Pos(L,C)=(18,38). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
MACRO DEFINITION COMPONENT: Pos(L,C)=(19,1). 
Part 1 of macro @<Sloth with 8@>.
X
TEXT COMPONENT: Pos(L,C)=(19,38). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X"
X--- End of Text Scrap List ---
X
X
MACRO DEFINITION COMPONENT: Pos(L,C)=(20,1). 
Part 1 of macro @<Sloth with 9@>.
X
TEXT COMPONENT: Pos(L,C)=(20,38). 
X
X-- Start of Text Scrap List --
Text scrap[Grey]="<010>
X<010>
X4. Test with syntax errors in the parameter list.<010>
X<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "1", Section name="Error recovery point".
X
TEXT COMPONENT: Pos(L,C)=(25,27). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "2", Section name="Error recovery point".
X
TEXT COMPONENT: Pos(L,C)=(28,27). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "3", Section name="Error recovery point".
X
TEXT COMPONENT: Pos(L,C)=(31,27). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "4", Section name="Error recovery point".
X
TEXT COMPONENT: Pos(L,C)=(34,27). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X<010>
X"
X--- End of Text Scrap List ---
X
X
TYPESETTER DIRECTIVE COMPONENT: 
X   Section "5", Section name="Error recovery point".
X
TEXT COMPONENT: Pos(L,C)=(37,27). 
X
X-- Start of Text Scrap List --
Text scrap[White]="<010>
X<010>
X<010>
X<010>
X"
X--- End of Text Scrap List ---
X
X
X========================== End of DOCUMENT LIST DUMP ===========================
X
X
Global Local| Input File
X------------+-------------------------------------------------------------------
X     1     1| PR05: Test the parsing of formal parameter lists.
X     2     2| 
X     3     3| First trip the parser so we don't get past the parser.
X     4     4| @>
X       Error|.^The parser was at the top level and was expecting
X            |.^one of: {Directive, Text, Macro definition, EOF}.
X     5     5| 
X     6     6| 1. Test macro definition with no formal parameters.
X     7     7| @$@<Sloth@>@{Slothtext@}
X     8     8| 
X     9     9| 2. Test macro definition with one formal parameter.
X    10    10| @$@<Sloth with one@>@(@1@)@{Slothtext@}
X    11    11| 
X    12    12| 3. Test macro definition with many formal parameters.
X    13    13| @$@<Sloth with 2@>@(@2@)@{Slothtext@}
X    14    14| @$@<Sloth with 3@>@(@3@)@{Slothtext@}
X    15    15| @$@<Sloth with 4@>@(@4@)@{Slothtext@}
X    16    16| @$@<Sloth with 5@>@(@5@)@{Slothtext@}
X    17    17| @$@<Sloth with 6@>@(@6@)@{Slothtext@}
X    18    18| @$@<Sloth with 7@>@(@7@)@{Slothtext@}
X    19    19| @$@<Sloth with 8@>@(@8@)@{Slothtext@}
X    20    20| @$@<Sloth with 9@>@(@9@)@{Slothtext@}
X    21    21| 
X    22    22| 4. Test with syntax errors in the parameter list.
X    23    23| 
X    24    24| @$@<Sloth a@>@(@+@9@)@{Slothtext@}
X       Error|................^Expecting one of [@1..@9].
X            |................^Skipping after error to the next major construct...
X    25    25| @A@<Error recovery point@>
X            |.^...skipped to here after the error.
X    26    26| 
X    27    27| @$@<Sloth b@>@9@)@{Slothtext@}
X       Error|..............^Expecting '@{'.
X            |..............^Skipping after error to the next major construct...
X    28    28| @A@<Error recovery point@>
X            |.^...skipped to here after the error.
X    29    29| 
X    30    30| @$@<Sloth c@>@(9@)@{Slothtext@}
X       Error|................^Expecting one of [@1..@9].
X            |................^Skipping after error to the next major construct...
X    31    31| @A@<Error recovery point@>
X            |.^...skipped to here after the error.
X    32    32| 
X    33    33| @$@<Sloth d@>@9@)@{Slothtext@}
X       Error|..............^Expecting '@{'.
X            |..............^Skipping after error to the next major construct...
X    34    34| @A@<Error recovery point@>
X            |.^...skipped to here after the error.
X    35    35| 
X    36    36| @$@<Sloth e@>@(@9@)@)@{Slothtext@}
X       Error|....................^Expecting '@{'.
X            |....................^Skipping after error to the next major construct...
X    37    37| @A@<Error recovery point@>
X            |.^...skipped to here after the error.
X    38    38| 
X    39    39| 
X    40    40| 
X            | <End-Of-File>
X------------+-------------------------------------------------------------------
X
There were 6 Errors.
END_OF_FILE
if test 28430 -ne `wc -c <'answers/pr05.lis'`; then
    echo shar: \"'answers/pr05.lis'\" unpacked with wrong size!
fi
# end of 'answers/pr05.lis'
fi
if test -f 'sources/help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sources/help.c'\"
else
echo shar: Extracting \"'sources/help.c'\" \(29770 characters\)
sed "s/^X//" >'sources/help.c' <<'END_OF_FILE'
X/*##############################################################################
X
XFUNNNELWEB COPYRIGHT
X====================
XFunnelWeb is a literate-programming macro preprocessor.
X
Copyright (C) 1992 Ross N. Williams.
X
X   Ross N. Williams
X   ross@spam.adelaide.edu.au
X   16 Lerwick Avenue, Hazelwood Park 5066, Australia.
X
This program is free software; you can redistribute it and/or modify
it under the terms of Version 2 of the GNU General Public License as
published by the Free Software Foundation.
X
This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See Version 2 of the GNU General Public License for more details.
X
You should have received a copy of Version 2 of the GNU General Public
License along with this program. If not, you can FTP the license from
prep.ai.mit.edu/pub/gnu/COPYING-2 or write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Section 2a of the license requires that all changes to this file be
recorded prominently in this file. Please record all changes here.
X
Programmers:
X   RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X
Changes:
X   07-May-1992  RNW  Program prepared for release under GNU GPL V2.
X
X##############################################################################*/
X
X
X/******************************************************************************/
X/*                                   HELP.C                                   */
X/******************************************************************************/
X/*                                                                            */
X/* REPRESENTING MESSAGES AS C CODE                                            */
X/* ===============================                                            */
X/* Experience has shown that it is much more reliable to code text messages   */
X/* into a program than to expect the program to track down text files         */
X/* containing the messages at run time. Worthwhile for smallish files (such   */
X/* as these help messages) at least. For this reason, most the messages in    */
X/* this module are represented by code (e.g. as in printf statements).        */
X/*                                                                            */
X/* The only exception is the 18K Gnu license message which is a bit too big   */
X/* to be done by hand. It has been moved to the help_gnu module.              */
X/*                                                                            */
X/******************************************************************************/
X
X#include <ctype.h>
X#include "style.h"
X
X#include "as.h"
X#include "help.h"
X#include "help_gnu.h"
X#include "misc.h"
X#include "option.h"
X
X/******************************************************************************/
X
X/* This module contains many many output statements that call an output       */
X/* function. To neaten up all these calls, we define a global variable to     */
X/* hold a pointer to the function and simple macro to write output using      */
X/* the function.                                                              */
LOCVAR void (*pf) P_((char *));
X
X#define WX(STR) (*pf)(STR)
X
X/******************************************************************************/
X
LOCAL void hel_men P_((void));
LOCAL void hel_men ()
X{
X WX("\n");
X WX("FunnelWeb Help Messages\n");
X WX("-----------------------\n");
X WX("Introduction  - Introduction to FunnelWeb.\n");
X WX("DOcumentation - How to obtain FunnelWeb documentation.\n");
X WX("Options       - Command line options.\n");
X WX("DEfoptions    - Default command line options.\n");
X WX("COMmands      - Interactive commands.\n");
X WX("Registration  - How to register as an \"official\" FunnelWeb user.\n");
X WX("Support       - How you can help support FunnelWeb development.\n");
X WX("COPyright     - Copyright notice.\n");
X WX("License       - The license under which this software is distributed (long).\n");
X WX("Nowarranty    - Extract from the GNU license concerning lack of warranty.\n");
X WX("DIstribution  - Extract from the GNU license concerning distribution.\n");
X WX("MOdification  - Read this message if you intend to modify FunnelWeb.\n");
X WX("Versions      - A list of existing versions of FunnelWeb.\n");
X WX("Acknowledge   - Thanks to people who helped with FunnelWeb development.\n");
X WX("MEnu          - The message you are reading (the default help message).\n");
X WX("\n");
X WX("To display a message, give its (optionally abbreviated) name in a help command.\n");
X WX("To capture a message to a file, add +J<filename> to the fw command. Examples:\n");
X WX("\n");
X WX("          fw +Hintroduction +Jintro.txt   -- From the operating system level.\n");
X WX("          help introduction               -- From FunnelWeb interactive mode.\n");
X}
X
X/******************************************************************************/
X
LOCAL void hel_int P_((void));
LOCAL void hel_int ()
X{
X WX("\n");
X WX("FunnelWeb Introduction\n");
X WX("----------------------\n");
X WX("Welcome to FunnelWeb, a literate-programming macro preprocessor.\n");
X WX("\n");
X WX("Traditional computer programs are primarily written for computers and consist\n");
X WX("of code laced with comments. In contrast, literate programs are primarily\n");
X WX("written for humans and consist of comments laced with code.  While simple, the\n");
X WX("effect of this inversion can be so profound as to change one's whole approach\n");
X WX("to programming.  The literate programmer focuses on conveying meaning to other\n");
X WX("intelligent beings rather than merely convincing the computer to behave in a\n");
X WX("particular way. It is the difference between performing and exposing a magic\n");
X WX("trick.\n");
X WX("\n");
X WX("FunnelWeb is a production-quality literate-programming tool that emphasises\n");
X WX("simplicity and reliability. It provides a macro facility, and assists in the\n");
X WX("production of typeset documentation. FunnelWeb runs on most popular machines\n");
X WX("(Sun, VAX, Mac, PC) and its highly portable source code in C is freely\n");
X WX("available under a GNU license.\n");
X WX("\n");
X WX("To get started with FunnelWeb, obtain a printed copy of the \"FunnelWeb User's\n");
X WX("Manual\" (see the \"DOCUMENTATION\" help message). Read the introduction and work\n");
X WX("through the tutorial. The manual contains an overview of FunnelWeb, an\n");
X WX("introductory tutorial, and a comprehensive reference manual. Try it!\n");
X}
X
X/******************************************************************************/
X
LOCAL void hel_opt P_((void));
LOCAL void hel_opt ()
X{
X WX("\n");
X WX("FunnelWeb Command Line Options\n");
X WX("------------------------------\n");
X WX("Options are of the form (\"+\" | \"=\" | \"-\") <letter> [<string>].\n");
X WX("+ turns on an option. - turns it off. = doesn't affect it's onoffedness.\n");
X WX("The case (e.g. upper or lower) of <letter> does not matter.\n");
X WX("<string> is usually a filename or directory, but sometimes a number.\n");
X WX("Convention: f=filename, n=decimal number, h=help message name.\n");
X WX("\n");
X WX("Example: fw sloth +L +Jaardvark.xxx +W80 -Q =Twalrus.tex\n");
X WX("\n");
X WX("Action options: (choose at least one when you invoke FunnelWeb from the OS).\n");
X WX("If you choose more than one, they will be executed in the order given here.\n");
X WX("   +Xf   Execute specified Funnelweb script.\n");
X WX("   +Ff   Process specified input file.\n");
X WX("   +Hh   Display specified help message.\n");
X WX("   +K    Invoke FunnelWeb's interative mode.\n");
X WX("\n");
X WX("Other options:\n");
X WX("   +B1   Diagnostic: Dump image of input file    to listing file.\n");
X WX("   +B2   Diagnostic: Dump scanner's line list    to listing file.\n");
X WX("   +B3   Diagnostic: Dump scanner's token list   to listing file.\n");
X WX("   +B4   Diagnostic: Dump parser's macro table   to listing file.\n");
X WX("   +B5   Diagnostic: Dump parser's document list to listing file.\n");
X WX("   +B6   Diagnostic: Dump time breakdown report  to listing file.\n");
X WX("   +B7   Diagnostic: Suppress non-deterministic output.\n");
X WX("   +Cn   Number of lines of context around diagnostics in listing file.\n");
X WX("   +D    Delete each output file identical to its previous version.\n");
X WX("   +If   Default file specification for include files.\n");
X WX("   +Jf   Generate journal file.  Default file specification.\n");
X WX("   +Lf   Generate listing file.  Default file specification.\n");
X WX("   +Of   Generate product files. Default file specification.\n");
X WX("   +Q    Quiet mode. Only really important messages displayed on console.\n");
X WX("   +Tf   Generate typesetter file. Default file specification.\n");
X WX("   +Sn   Send errors to console with specified number of lines of context.\n");
X WX("   +Wn   Set maximum length of lines in product files.\n");
X WX("\n");
X WX("If an option appears more than once, the rightmost one dominates.\n");
X WX("For more detailed information, refer to the FunnelWeb User's Manual.\n");
X WX("For default values refer to the \"DEFOPTIONS\" help message.\n");
X}
X
X/******************************************************************************/
X
LOCAL void hel_dop P_((void));
LOCAL void hel_dop ()
X{
X op_t defop;
X
X WX("\n");
X WX("FunnelWeb Default Option Settings\n");
X WX("---------------------------------\n");
X WX("These are the settings FunnelWeb STARTS UP with.\n");
X op_ini(&defop);
X WX("\n");
X op_wri(&defop,pf);
X WX("\n");
X WX("See the OPTIONS help message for a brief description of these options.\n");
X WX("For more detailed information, refer to the FunnelWeb User's Manual.\n");
X}
X
X/******************************************************************************/
X
LOCAL void hel_com P_((void));
LOCAL void hel_com ()
X{
X WX("\n");
X WX("FunnelWeb Interactive Commands\n");
X WX("------------------------------\n");
X WX("   !                       - Comment. Ignores the whole line.             \n");
X WX("   ABSENT fn               - Aborts if specified file exists.             \n");
X WX("   CODIFY ftext fC         - Convert text file into C code to write text. \n");
X WX("   COMPARE f1 f2           - Aborts if two files are different.           \n");
X WX("   DEFINE n \"text\"         - Defines $n to translate to text.             \n");
X WX("   DIFF f1 f2 logf [ABORT] - Writes differences between f1 and f2 to logf.\n");
X WX("                           - Severe if different and ABORT is present.    \n");
X WX("   DIFFSUMMARY             - Summary of differences done since DIFFZERO.  \n");
X WX("   DIFFZERO                - Zeros differences counters.                  \n");
X WX("   ENEO fn                 - Establish Non Existence Of file.             \n");
X WX("   EXECUTE fn              - Execute commands in specified file.          \n");
X WX("   EXISTS fn               - Aborts if file does not exist.               \n");
X WX("   FIXEOLS fn [outf]       - Fixes up EOL markers in specified file.      \n");
X WX("   FW options              - Invoke FunnelWeb-proper once.                \n");
X WX("   HELP [name]             - Displays specified help message.             \n");
X WX("   HERE                    - Terminates effect of SKIPTO command.         \n");
X WX("   QUIT                    - Quits FunnelWeb.                             \n");
X WX("   SET options             - Sets options.                                \n");
X WX("   SHOW                    - Displays currently active options.           \n");
X WX("   SKIPTO                  - Ignore commands until HERE command.          \n");
X WX("   STATUS                  - Write out status and diagnostic counts.      \n");
X WX("   STATUS [Sn] [En] [Wn]   - Aborts if status is not as specified.        \n");
X WX("   TOLERATE                - Don't abort script if next commmand gens err.\n");
X WX("   TRACE ON | OFF          - Turns command tracing ON or OFF.             \n");
X WX("   WRITE \"text\"            - Writes specified text to screen and journal. \n");
X WX("   WRITEU \"text\"           - Same as WRITE but underlines text.           \n");
X WX("\n");
X WX("More detailed information can be found in the FunnelWeb User's Manual.\n");
X WX("\n");
X WX("Most of these commands were created to support regression testing and\n");
X WX("can be ignored by most users. In fact most users will never need to invoke\n");
X WX("FunnelWeb's interactive mode at all. If you are just getting started\n");
X WX("with FunnelWeb, it's probably best to run FunnelWeb directly from your\n");
X WX("command interface and ignore the +K command line option for now.\n");
X}
X
X/******************************************************************************/
X
LOCAL void hel_doc P_((void));
LOCAL void hel_doc ()
X{
X WX("\n");
X WX("FunnelWeb Documentation\n");
X WX("-----------------------\n");
X WX("The following FunnelWeb documentation is available:\n");
X WX("\n");
X WX("   \"FunnelWeb User's   Manual\": Tutorial, Hints, Reference Manual.\n");
X WX("   \"FunnelWeb Hacker's Manual\": Notes on Design and Implementation.\n");
X WX("\n");
X WX("Everyone involved with FunnelWeb should read the User's Manual.\n");
X WX("It contains everything you need to learn how to use FunnelWeb.\n");
X WX("\n");
X WX("The Hacker's Manual is for those who want to install, modify, fix,\n");
X WX("fiddle with, and generally hack the FunnelWeb C source code.\n");
X WX("\n");
X WX("Both of these manuals are shipped with the FunnelWeb distribution\n");
X WX("kit, and should be available on your machine in the form of LaTeX text\n");
X WX("files. If you cannot find them, you can obtain them by FTP from:\n");
X WX("\n");
X WX("    Machine  : sirius.itd.adelaide.edu.au [IP=129.127.40.3].\n");
X WX("    Directory: ~pub/funnelweb/   (or a directory of similar name).\n");
X WX("\n");
X}
X
X/******************************************************************************/
X
LOCAL void hel_reg P_((void));
LOCAL void hel_reg ()
X{
X WX("FunnelWeb Registration\n");
X WX("----------------------\n");
X WX("If you install or use FunnelWeb, please fill in and return this form:\n");
X WX("\n");
X WX("   +----------------------FunnelWeb Registration Form----------------------+\n");
X WX("   | 1. Date:                                                              |\n");
X WX("   | 2. Title and name:                                                    |\n");
X WX("   | 3. Internet email address:                                            |\n");
X WX("   | 4. Snail mail address:                                                |\n");
X WX("   | 5. Work phone number (country,area,number):                           |\n");
X WX("   | 6. Which category of FunnelWeb user best describes you?               |\n");
X WX("   |       Latent    - Installed FunnelWeb, but don't intend to use it.    |\n");
X WX("   |       Beginner  - Haven't used FunnelWeb much yet; have an open mind. |\n");
X WX("   |       Casual    - Use FunnelWeb occasionally.                         |\n");
X WX("   |       Convert   - Use FunnelWeb to do most programming.               |\n");
X WX("   |       Fanatic   - FunnelWeb has become a way of life.                 |\n");
X WX("   | 7. What changes or new features would you like to see in FunnelWeb?   |\n");
X WX("   | 8. Do you want to be kept informed of new FunnelWeb developments?     |\n");
X WX("   | 9. Email this form to \"ross@spam.adelaide.edu.au\", OR snail mail to   |\n");
X WX("   |    Ross Williams, 16 Lerwick Avenue, Hazelwood Park 5066, Australia.  |\n");
X WX("   +-----------------------------------------------------------------------+\n");
X WX("To write this form to a file, use \"fw +hreg +jregform.txt\".\n");
X WX("You may wish to make a contribution when you register. See SUPPORT.\n");
X}
X
X/******************************************************************************/
X
LOCAL void hel_cop P_((void));
LOCAL void hel_cop ()
X{
X WX("\n");
X WX("FunnelWeb Copyright\n");
X WX("-------------------\n");
X WX("Copyright (C) 1992 Ross Williams.\n");
X WX("\n");
X WX("However, FunnelWeb has been released by the author and copyright owner Ross\n");
X WX("Williams (ross@spam.adelaide.edu.au) under Version 2 of the GNU General Public\n");
X WX("License published by the Free Software Foundation. This means that you can\n");
X WX("redistribute FunnelWeb and/or modify it under the terms of the license.\n");
X WX("\n");
X WX("Note: This program is distributed WITHOUT ANY WARRANTY; without even the\n");
X WX("implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
X WX("\n");
X WX("The following help messages provide further information:\n");
X WX("\n");
X WX("   License       - The license under which this software is distributed (long).\n");
X WX("   DIstribution  - Extract from the GNU license concerning distribution.\n");
X WX("   Nowarranty    - Extract from the GNU license concerning lack of warranty.\n");
X WX("   MOdification  - Read this message if you intend to modify FunnelWeb.\n");
X WX("   Registration  - How to register as an \"official\" FunnelWeb user.\n");
X WX("\n");
X}
X
X/******************************************************************************/
X
LOCAL void hel_now P_((void));
LOCAL void hel_now ()
X{
X WX("\n");
X WX("FunnelWeb Comes With No Warranty\n");
X WX("--------------------------------\n");
X WX("Here is an extract from the GNU General Public License Version 2, under which\n");
X WX("FunnelWeb is distributed. See help message \"LICENSE\" for the full license.\n");
X WX("\n");
X WX("     11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\n");
X WX("   FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\n");
X WX("   OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\n");
X WX("   PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\n");
X WX("   OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n");
X WX("   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\n");
X WX("   TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\n");
X WX("   PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\n");
X WX("   REPAIR OR CORRECTION.\n");
X WX("\n");
X WX("     12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\n");
X WX("   WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\n");
X WX("   REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\n");
X WX("   INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\n");
X WX("   OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\n");
X WX("   TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\n");
X WX("   YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\n");
X WX("   PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\n");
X WX("   POSSIBILITY OF SUCH DAMAGES.\n");
X}
X
X/******************************************************************************/
X
LOCAL void hel_dis P_((void));
LOCAL void hel_dis ()
X{
X WX("\n");
X WX("FunnelWeb Distribution\n");
X WX("----------------------\n");
X WX("The following is an extract from the GNU General Public License Version 2,\n");
X WX("under which FunnelWeb is distributed.\n");
X WX("\n");
X WX("     1. You may copy and distribute verbatim copies of the Program's\n");
X WX("   source code as you receive it, in any medium, provided that you\n");
X WX("   conspicuously and appropriately publish on each copy an appropriate\n");
X WX("   copyright notice and disclaimer of warranty; keep intact all the\n");
X WX("   notices that refer to this License and to the absence of any warranty;\n");
X WX("   and give any other recipients of the Program a copy of this License\n");
X WX("   along with the Program.\n");
X WX("\n");
X WX("   You may charge a fee for the physical act of transferring a copy, and\n");
X WX("   you may at your option offer warranty protection in exchange for a fee.\n");
X WX("\n");
X WX("The license also allows you other freedoms.  For more information refer\n");
X WX("to the full text of the license in the help message \"LICENSE\".\n");
X}
X
X/******************************************************************************/
X
LOCAL void hel_ack P_((void));
LOCAL void hel_ack ()
X{
X WX("\n");
X WX("FunnelWeb Acknowledgements\n");
X WX("--------------------------\n");
X WX("The following people assisted with the preparation of FunnelWeb V3.0.\n");
X WX("\n");
X WX("Many thanks go to DAVID HULSE (dave@cs.adelaide.edu.au) who translated the 1986\n");
X WX("version of FunnelWeb (V1) written in Ada into a public domain C version (V2).\n");
X WX("The C code written by David formed the basis of V3 of FunnelWeb, but was\n");
X WX("entirely rewritten during the intensive refinement and feature-injection\n");
X WX("period leading up to this release (V3 is about 3 times the size of V2).\n");
X WX("\n");
X WX("Thanks go to SIMON HACKETT (simon@internode.com.au) of Internode Systems\n");
X WX("Pty Ltd for the use of his Sun, Mac, and PC, for assistance in porting\n");
X WX("FunnelWeb to the Sun and PC, and for helpful discussions.\n");
X WX("\n");
X WX("Thanks go to JEREMY BEGG (jeremy@vsm.com.au) of VSM Software Services\n");
X WX("for the use of his VAX, and for assistance with the VMS-specific code.\n");
X WX("\n");
X WX("Ross Williams (ross@spam.adelaide.edu.au), 12 May 1992.\n");
X}
X
X/******************************************************************************/
X
LOCAL void hel_ver P_((void));
LOCAL void hel_ver ()
X{
X WX("\n");
X WX("FunnelWeb Versions\n");
X WX("------------------\n");
X WX("FunnelWeb was created in 1986 and was used extensively by Ross Williams\n");
X WX("(ross@spam.adelaide.edu.au) for three years. However, Version 1.0 was written\n");
X WX("in Ada and was not very portable (it was fairly VAX/VMS specific). David Hulse\n");
X WX("(dave@cs.adelaide.edu.au) took the first step towards a release by translating\n");
X WX("the Ada code into C. Ross Williams then extensively reworked the C code, making\n");
X WX("it robust and portable, adding new features, and polishing it to its current\n");
X WX("form.\n");
X WX("\n");
X WX("Vers  Lang  Created  Released   Author          Copyright      Licensing      \n");
X WX("----  ----  -------  --------   --------------  -------------  ---------      \n");
X WX("V1.0  Ada   1986     Never      Ross  Williams  Ross Williams                 \n");
X WX("V2.0  C     1989     Never      David Hulse     Public domain  No restriction.\n");
X WX("V3.0  C     1992     May-1992   Ross  Williams  Ross Williams  GNU release.   \n");
X WX("\n");
X WX("This is FunnelWeb Version 3.0. Unless otherwise specified, all references\n");
X WX("in this release to \"FunnelWeb\" refer either to the abstract identity\n");
X WX("of FunnelWeb, or to this version, FunnelWeb Version 3.0.\n");
X}
X
X/******************************************************************************/
X
LOCAL void hel_sup P_((void));
LOCAL void hel_sup ()
X{
X WX("\n");
X WX("FunnelWeb Support\n");
X WX("-----------------\n");
X WX("FunnelWeb is released \"as is\" under a GNU license, and no formal support\n");
X WX("is available. You have the right to make changes to FunnelWeb and to use\n");
X WX("the modified versions created by random programmers. However, this is\n");
X WX("discouraged (see the MODIFICATION help message).\n");
X WX("\n");
X WX("In fact the support that is most needed is your financial support for the\n");
X WX("FunnelWeb developers! It has taken MONTHS of full-time UNPAID work to bring\n");
X WX("FunnelWeb to you in its current form. I don't want to inconvenience users\n");
X WX("who install FunnelWeb, play with it, and then hardly ever use it. If you are\n");
X WX("in this category, please register, but don't bother contributing. However,\n");
X WX("if you find that FunnelWeb has become a useful programming tool, a contribution\n");
X WX("of some positive multiple of US$50 would be appreciated.\n");
X WX("\n");
X WX("To make a contribution, send payment with a completed registration form\n");
X WX("(see the REGISTRATION help message) to:\n");
X WX("\n");
X WX("   Renaissance Software Pty Ltd\n");
X WX("   Email: ross@spam.adelaide.edu.au\n");
X WX("   Snail: 16 Lerwick Avenue, Hazelwood Park 5066, Australia.\n");
X WX("\n");
X WX("Payment can be by personal or bank cheque to any bank in the world or by\n");
X WX("Visa or Mastercard. Please give the card name, number, expiry date, and\n");
X WX("the amount to be paid in US dollars. All contributions will be appreciated\n");
X WX("and will encourage further FunnelWeb development. However, no undertaking\n");
X WX("is made whatsoever about how the money will be used.\n");
X WX("\n");
X WX("Ross Williams (ross@spam.adelaide.edu.au), 12 May 1992.\n");
X}
X
X/******************************************************************************/
X
LOCAL void hel_mod P_((void));
LOCAL void hel_mod ()
X{
X WX("\n");
X WX("FunnelWeb Modifications\n");
X WX("-----------------------\n");
X WX("FunnelWeb is distributed under a GNU license, and you are free to modify the\n");
X WX("source code and distribute modified copies (see the help message LICENSE).\n");
X WX("However, there are good reasons why you should avoid doing this.\n");
X WX("\n");
X WX("   1) If you distribute modified versions of FunnelWeb, you run the risk of\n");
X WX("   creating a version that will diverge from the \"official\" version of\n");
X WX("   FunnelWeb which I intend to maintain.\n");
X WX("\n");
X WX("   2) If you release a version of FunnelWeb with a changed input language,\n");
X WX("   users of your modified version will create source files that will no\n");
X WX("   longer work on other versions of FunnelWeb. The result will be chaos.\n");
X WX("\n");
X WX("For these reasons I request that you do not distribute modified versions of\n");
X WX("FunnelWeb, particularly versions with a modified language. However, if you must\n");
X WX("distribute a version with a modified language, PLEASE CHANGE ITS NAME (i.e.\n");
X WX("from \"FunnelWeb\" to something else). Please also allocate a new file extension\n");
X WX("to replace \".fw\" as the extension for source files written in the modified\n");
X WX("language. For more information, refer to the FunnelWeb Hacker's Manual.\n");
X WX("\n");
X WX("Ross Williams (ross@spam.adelaide.edu.au), 12 May 1992.\n");
X}
X
X/******************************************************************************/
X
LOCAL bool prefeq P_((char *,char *));
LOCAL bool prefeq (p_pref,p_target)
X/* Returns TRUE iff string p_pref is a case insensitive prefix of p_target.   */
char *p_pref;
char *p_target;
X{
X char *p,*q;
X
X if (strlen(p_pref) > strlen(p_target))
X    return FALSE;
X
X p=p_pref;
X q=p_target;
X while (*p != EOS)
X   {
X    if (toupper(*p) != toupper(*q)) return FALSE;
X    p++;
X    q++;
X   }
X return TRUE;
X}
X
X/******************************************************************************/
X
XEXPORT uword hel_num (p_name)
char *p_name;
X{
X uword matches = 0;
X uword messnum;
X
X /* We want to be fairly lenient on the user here as the user is trying to    */
X /* obtain help and will probably get annoyed and give up if it doesn't work, */
X /* so we perform case insensitive prefix matching.  However, we don't want   */
X /* to match if the user inputs a prefix that matches two message names. This */
X /* means we can't just return when we find a match; we have to see if there  */
X /* are any others as well.                                                   */
X
X if (prefeq(p_name,"MENU"         )) {messnum=HL_MEN; matches++;}
X if (prefeq(p_name,"INTRODUCTION" )) {messnum=HL_INT; matches++;}
X if (prefeq(p_name,"OPTIONS"      )) {messnum=HL_OPT; matches++;}
X if (prefeq(p_name,"DEFOPTIONS"   )) {messnum=HL_DOP; matches++;}
X if (prefeq(p_name,"COMMANDS"     )) {messnum=HL_COM; matches++;}
X if (prefeq(p_name,"DOCUMENTATION")) {messnum=HL_DOC; matches++;}
X if (prefeq(p_name,"REGISTRATION" )) {messnum=HL_REG; matches++;}
X if (prefeq(p_name,"LICENSE"      )) {messnum=HL_GNU; matches++;}
X if (prefeq(p_name,"COPYRIGHT"    )) {messnum=HL_COP; matches++;}
X if (prefeq(p_name,"NOWARRANTY"   )) {messnum=HL_NOW; matches++;}
X if (prefeq(p_name,"DISTRIBUTION" )) {messnum=HL_DIS; matches++;}
X if (prefeq(p_name,"ACKNOWLEDGE"  )) {messnum=HL_ACK; matches++;}
X if (prefeq(p_name,"VERSIONS"     )) {messnum=HL_VER; matches++;}
X if (prefeq(p_name,"SUPPORT"      )) {messnum=HL_SUP; matches++;}
X if (prefeq(p_name,"MODIFICATION" )) {messnum=HL_MOD; matches++;}
X
X if (matches != 1) return HL_ERR;
X
X return messnum;
X}
X
X/******************************************************************************/
X
XEXPORT void hel_wri (p_outf,messno)
void (*p_outf) P_((char *));
uword messno;
X{
X as_cold(     1 <= messno, "hel_wri: Message number is zero.");
X as_cold(messno <= HL_MAX, "hel_wri: Message number is greater than HL_MAX.");
X
X /* Set the global output function pointer. */
X pf=p_outf;
X
X switch(messno)
X   {
X    case HL_MEN: hel_men(); break;
X    case HL_INT: hel_int(); break;
X    case HL_OPT: hel_opt(); break;
X    case HL_DOP: hel_dop(); break;
X    case HL_COM: hel_com(); break;
X    case HL_DOC: hel_doc(); break;
X    case HL_REG: hel_reg(); break;
X    case HL_GNU: hel_gnu(p_outf); break; /* Calling another module. */
X    case HL_COP: hel_cop(); break;
X    case HL_NOW: hel_now(); break;
X    case HL_DIS: hel_dis(); break;
X    case HL_ACK: hel_ack(); break;
X    case HL_VER: hel_ver(); break;
X    case HL_SUP: hel_sup(); break;
X    case HL_MOD: hel_mod(); break;
X    default    : as_bomb("hel_wri: switch defaulted.");
X   }
X}
X
X/******************************************************************************/
X/*                               End of HELP.C                                */
X/******************************************************************************/
END_OF_FILE
if test 29770 -ne `wc -c <'sources/help.c'`; then
    echo shar: \"'sources/help.c'\" unpacked with wrong size!
fi
# end of 'sources/help.c'
fi
if test -f 'sources/weave.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sources/weave.c'\"
else
echo shar: Extracting \"'sources/weave.c'\" \(31376 characters\)
sed "s/^X//" >'sources/weave.c' <<'END_OF_FILE'
X/*##############################################################################
X
XFUNNNELWEB COPYRIGHT
X====================
XFunnelWeb is a literate-programming macro preprocessor.
X
Copyright (C) 1992 Ross N. Williams.
X
X   Ross N. Williams
X   ross@spam.adelaide.edu.au
X   16 Lerwick Avenue, Hazelwood Park 5066, Australia.
X
This program is free software; you can redistribute it and/or modify
it under the terms of Version 2 of the GNU General Public License as
published by the Free Software Foundation.
X
This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See Version 2 of the GNU General Public License for more details.
X
You should have received a copy of Version 2 of the GNU General Public
License along with this program. If not, you can FTP the license from
prep.ai.mit.edu/pub/gnu/COPYING-2 or write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Section 2a of the license requires that all changes to this file be
recorded prominently in this file. Please record all changes here.
X
Programmers:
X   RNW  Ross N. Williams  ross@spam.adelaide.edu.au
X
Changes:
X   07-May-1992  RNW  Program prepared for release under GNU GPL V2.
X
X##############################################################################*/
X
X
X/******************************************************************************/
X/*                                   WEAVE.C                                  */
X/******************************************************************************/
X
X#include <ctype.h>
X#include "style.h"
X
X#include "as.h"
X#include "data.h"
X#include "lister.h"
X#include "machin.h"
X#include "misc.h"
X#include "table.h"
X#include "texhead.h"
X#include "weave.h"
X
X/* IMPORTANT WARNING: The Macintosh THINK C compiler sets up strings that     */
X/* start with \p or \P as PASCAL strings rather than C strings. So be very    */
X/* careful not to start any strings with \p or \P.                            */
X
X/******************************************************************************/
X
LOCVAR wf_t f_t;          /* Variable representing documentation file.        */
LOCVAR bool literal;      /* True if we are inside a literal @{.              */
X
X/******************************************************************************/
X
LOCAL void wv_ex P_((p_ells_t));
X
X/******************************************************************************/
X
LOCAL char * fn_nodir P_((char *));
LOCAL char * fn_nodir (p)
X/* Given a pointer to a string, returns a pointer to the character just past  */
X/* the last occurrance of FN_DELIM, or a pointer to the start of the string   */
X/* if it does not occur. In other words, given a filename, return a pointer   */
X/* to the start of the name field.                                            */
char *p;
X{
X char *q = strrchr(p,FN_DELIM);
X if (q==NULL)
X    return p;
X else
X    return q+1;
X}
X
X/******************************************************************************/
X
LOCAL void wf_dec P_((p_wf_t,ulong));
LOCAL void wf_dec(p_wf,n)
X/* Writes the unsigned number n to the specified output stream as a decimal.  */
X/* This function has been named wf_dec so that it can be moved to the wf      */
X/* package if it turns out to be popular.                                     */
p_wf_t p_wf;
ulong  n;
X{
X char t[20];
X sprintf(t,"%lu",n);
X wf_wr(p_wf,t);
X}
X
X/******************************************************************************/
X
LOCAL void wv_ugch P_((int));
LOCAL void wv_ugch(ch)
X/* WeaVe UGly CHaracter.                                                      */
X/* Sometimes it is necessary to output text without causing the typesetting   */
X/* program (TeX) to interpret it as control sequences and generate errors.    */
X/* There are two ways of doing this. First, we can get the typesetter to do   */
X/* the work by making it less sensitive. This has been done with the          */
X/* typesetting of the main macro text. The other approach is to convert each  */
X/* offending character into the typesetter control sequence that will simply  */
X/* output the character. For example, in TeX, "$" becomes "\$". This function */
X/* accepts a single character and writes out its safe equivalent.             */
X/* The term "ugly" is used to describe potentially harmful text/characters.   */
int ch;
X{
X /* End of lines are the only non-printable allowed. */
X if (ch==EOL) {wf_chr(&f_t,EOL); return;}
X
X /* All other non-printables result in a bullet. In the absence of bugs, the  */
X /* only way a non-printable can get to us here is as a result of the user    */
X /* explicitly inserting one using the scanner's @^ control sequence.         */
X if (!isascprn(ch))
X    {
X     wf_wr(&f_t,"$\\bullet$");
X     return;
X    }
X /* If it IS printable, then print it ... carefully! */
X switch (ch)
X   {
X    /* Go through the printables in ASCII order. */
X    /*   ' ':  is an ordinary character. */
X    /*   '!':  is an ordinary character. */
X    case '\"':  wf_wr(&f_t,"\\char`\\\"");  break;
X    case '#':  wf_wr(&f_t,"\\#");  break;
X    case '$':  wf_wr(&f_t,"\\$");  break;
X    /* Note: The string "\\%" triggers a unknown sequence "\%" in GNUC.       */
X    case '%':  wf_chr(&f_t,'\\'); wf_chr(&f_t,'%'); break;
X    case '&':  wf_wr(&f_t,"\\&");  break;
X    /*   ''': is an ordinary character. */
X    /*   '(': is an ordinary character. */
X    /*   ')': is an ordinary character. */
X    /*   '*': is an ordinary character. */
X    /*   '+': is an ordinary character. */
X    /*   ',': is an ordinary character. */
X    /*   '-': is an ordinary character. */
X    /*   '.': is an ordinary character. */
X    /*   '/': is an ordinary character. */
X    /* '0-9': are   ordinary characters.*/
X    /*   ':': is an ordinary character. */
X    /*   ';': is an ordinary character. */
X              /* Note: Some \chars work well in roman. Others don't. */
X    case '<': if (literal)
X                 wf_wr(&f_t,"\\char`\\<");
X              else
X                 wf_wr(&f_t,"$<$");
X              break;
X    /*   '=': is an ordinary character. */
X    case '>': if (literal)
X                 wf_wr(&f_t,"\\char`\\>");
X              else
X                 wf_wr(&f_t,"$>$");
X              break;
X    /*   '?': is an ordinary character. */
X    /*   '@': is an ordinary character. */
X    /* 'A-Z': are   ordinary characters.*/
X    /*   '[': is an ordinary character. */
X    case '\\': if (literal)
X                  wf_wr(&f_t,"\\char`\\\\");
X               else
X                  wf_wr(&f_t,"$\\backslash$");
X               break;
X    /*   ']': is an ordinary character. */
X    case '^':  wf_wr(&f_t,"\\char`\\^");  break;
X    case '_':  wf_wr(&f_t,"\\_");  break;
X    /*   '`': is an ordinary character. */
X    /* 'a-z': are   ordinary characters.*/
X    case '{':  if (literal)
X                  wf_wr(&f_t,"\\char`\\{");
X               else
X                  wf_wr(&f_t,"$\\{$");
X               break;
X    case '|':  if (literal)
X                  wf_wr(&f_t,"\\char`\\|");
X               else
X                  wf_wr(&f_t,"$|$");
X               break;
X    case '}':  if (literal)
X                  wf_wr(&f_t,"\\char`\\}");
X               else
X                  wf_wr(&f_t,"$\\}$");
X               break;
X    case '~':  wf_wr(&f_t,"\\char`\\~");  break;
X    default:   wf_chr(&f_t,ch);    break;
X   }
X}
X
X/******************************************************************************/
X
LOCAL void wv_ugstr P_((char *));
LOCAL void wv_ugstr(s)
X/* Writes out a potentially ugly string. */
char *s;
X{
X while (*s != EOS)
X    wv_ugch(*s++);
X}
X
X/******************************************************************************/
X
LOCAL void wv_ugsc P_((p_sc_t));
LOCAL void wv_ugsc(p_sc)
X/* Writes out a potentially ugly text scrap. */
p_sc_t p_sc;
X{
X char *p      = p_sc->sc_first;
X char *p_last = p_sc->sc_last;
X
X while (p<=p_last)
X    wv_ugch(*p++);
X}
X
X/******************************************************************************/
X
LOCAL void wv_ugscls P_((p_scls_t));
LOCAL void wv_ugscls(p_scls)
X/* This function writes the specified text list to the output stream. It      */
X/* writes it cleaning up all ugly characters.                                 */
p_scls_t p_scls;
X{
X ls_fir(p_scls);
X while (TRUE)
X   {
X    p_sc_t p_sc;
X    ls_nxt(p_scls,PPV &p_sc);
X    if (p_sc==NULL) break;
X    wv_ugsc(p_sc);
X   }
X}
X
X/******************************************************************************/
X
LOCAL void wv_manm P_((p_ma_t,ulong));
LOCAL void wv_manm(p_ma,part)
X/* This function writes the specified macro name and number. */
X/* The part number is the part to write out.                 */
p_ma_t p_ma;
ulong part;
X{
X p_bp_t p_bp;
X
X if (p_ma->ma_defn.md_isfil)
X    wf_wr(&f_t,"\\fwfilename{");
X else
X    wf_wr(&f_t,"\\fwmacroname{");
X wv_ugstr(p_ma->ma_name);
X wf_wr(&f_t,"}{");
X ls_loo(p_ma->ma_defn.md_body,part,PPV &p_bp);
X wf_dec(&f_t,(ulong) p_bp->bp_seq);
X wf_wr(&f_t,"}");
X}
X
X/******************************************************************************/
X
LOCAL void wv_secnn P_((p_ty_t));
LOCAL void wv_secnn(p_ty)
X/* Write out the section number and name, each in curly braces. */
p_ty_t p_ty;
X{
X /* Write as arguments the section number and name. */
X wf_chr(&f_t,'{');
X sn_str(&p_ty->ty_sn,linet1);
X wf_wr(&f_t,linet1);
X wf_wr(&f_t,"}{");
X wv_ugstr(p_ty->ty_name);
X wf_chr(&f_t,'}');
X}
X
X/******************************************************************************/
X
LOCAL void wv_echo P_((p_scls_t));
LOCAL void wv_echo(p_scls)
X/* This function writes the specified text list to the output stream. It      */
X/* writes it just as it is, with no modifications whatsoever.                 */
p_scls_t p_scls;
X{
X ls_fir(p_scls);
X while (TRUE)
X   {
X    p_sc_t p_sc;
X    ls_nxt(p_scls,PPV &p_sc);
X    if (p_sc==NULL) break;
X    wf_blk(&f_t,p_sc->sc_first,(size_t)
X   (p_sc->sc_last-p_sc->sc_first+1));
X   }
X}
X
X/******************************************************************************/
X
LOCAL void wv_verb P_((p_scls_t));
LOCAL void wv_verb(p_scls)
X/* Writes a text list verbetim, but brackets it with sequences that instruct  */
X/* the typesetter not to interpret the text in any special way.               */
p_scls_t p_scls;
X{
X if (ls_len(p_scls) > 0)
X   {
X    wf_wr(&f_t,"\\fwbtx[");
X    wv_echo(p_scls);
X    wf_wl(&f_t,"]fwetx=%");
X   }
X}
X
X/******************************************************************************/
X
LOCAL void wv_head P_((void));
LOCAL void wv_head()
X{
X wf_wl(&f_t,"");
X wf_wl(&f_t,"%*******************************************************************************");
X wf_wl(&f_t,"%*                    START OF AUTOMATICALLY GENERATED TEX FILE                *");
X wf_wl(&f_t,"%*******************************************************************************");
X wf_wl(&f_t,"%*                                                                             *");
X wf_wl(&f_t,"%* This TeX file was automatically generated by the FunnelWeb preprocessor.    *");
X wf_wl(&f_t,"%* You can typeset this file to produce printed documentation by running it    *");
X wf_wl(&f_t,"%* through the TeX typesetter using a command such as:                         *");
X wf_wl(&f_t,"%*    tex thisfilename                                                         *");
X wf_wl(&f_t,"%* The resultant file thisfilename.dvi can be printed using a command such as: *");
X wf_wl(&f_t,"%*    lpr -Pcslw -d thisfilename.dvi                                           *");
X wf_wl(&f_t,"%*                                                                             *");
X wf_wl(&f_t,"%* FunnelWeb is a preprocessor that allows programmers to weave programs and   *");
X wf_wl(&f_t,"%* their documentation together in a single document. The FunnelWeb program    *");
X wf_wl(&f_t,"%* analyses such documents producing both program files and typeset            *");
X wf_wl(&f_t,"%* documentation such as this TeX file.                                        *");
X wf_wl(&f_t,"%* FunnelWeb was created by Ross Williams.                                     *");
X wf_wl(&f_t,"%*                                                                             *");
X wf_wl(&f_t,"%* For more information on FunnelWeb look in the following FTP archive:        *");
X wf_wl(&f_t,"%*    Machine  : sirius.itd.adelaide.edu.au [IP=129.127.40.3].                 *");
X wf_wl(&f_t,"%*    Directory: ~pub/funnelweb/                                               *");
X wf_wl(&f_t,"%*               (or some other appropriately named directory).                *");
X wf_wl(&f_t,"%* or email Ross Williams at ross@spam.adelaide.edu.au                         *");
X wf_wl(&f_t,"%*                                                                             *");
X wf_wl(&f_t,"%*******************************************************************************");
X wf_wl(&f_t,"");
X wf_wl(&f_t,"");
X}
X
X/******************************************************************************/
X
LOCAL void wv_tail P_((void));
LOCAL void wv_tail()
X{
X wf_wl(&f_t,"");
X wf_wl(&f_t,"");
X wf_wl(&f_t,"%*******************************************************************************");
X wf_wl(&f_t,"%*                    END OF AUTOMATICALLY GENERATED TEX FILE                  *");
X wf_wl(&f_t,"%*******************************************************************************");
X wf_wl(&f_t,"");
X}
X
X/******************************************************************************/
X
LOCAL void wv_nsec P_((p_ty_t));
LOCAL void wv_nsec(p_ty)
X/* Weaves the start of a new section. */
p_ty_t p_ty;
X{
X as_cold(p_ty->ty_kind==TY_NSEC,"wv_nsec: Not a section!");
X
X /* Work out what kind of section macro should be used. */
X switch (sn_lev(&p_ty->ty_sn))
X   {
X    case 1: wf_wr(&f_t,"\\fwseca"); break;
X    case 2: wf_wr(&f_t,"\\fwsecb"); break;
X    case 3: wf_wr(&f_t,"\\fwsecc"); break;
X    case 4: wf_wr(&f_t,"\\fwsecd"); break;
X    case 5: wf_wr(&f_t,"\\fwsece"); break;
X    default: as_bomb("wv_nsec:case defaulted.");
X   }
X
X /* Write out the section number and name. */
X wv_secnn(p_ty);
X}
X
X/******************************************************************************/
X
LOCAL void wv_olit P_((p_ty_t));
LOCAL void wv_olit(p_ty)
p_ty_t p_ty;
X{
X as_cold(p_ty->ty_kind==TY_OLIT,"wv_olit: Not an open literal!");
X wf_wr(&f_t,"\\fwlit{");
X literal=TRUE;
X}
X
X/******************************************************************************/
X
LOCAL void wv_clit P_((p_ty_t));
LOCAL void wv_clit(p_ty)
p_ty_t p_ty;
X{
X as_cold(p_ty->ty_kind==TY_CLIT,"wv_clit: Not a close literal!");
X wf_wr(&f_t,"}");
X literal=FALSE;
X}
X
X/******************************************************************************/
X
LOCAL void wv_oemp P_((p_ty_t));
LOCAL void wv_oemp(p_ty)
p_ty_t p_ty;
X{
X as_cold(p_ty->ty_kind==TY_OEMP,"wv_oemp: Not an open emphasize!");
X wf_wr(&f_t,"\\fwemp{");
X}
X
X/******************************************************************************/
X
LOCAL void wv_cemp P_((p_ty_t));
LOCAL void wv_cemp(p_ty)
p_ty_t p_ty;
X{
X as_cold(p_ty->ty_kind==TY_CEMP,"wv_cemp: Not a close emphasize!");
X wf_wr(&f_t,"}");
X}
X
X/******************************************************************************/
X
LOCAL void wv_npag P_((p_ty_t));
LOCAL void wv_npag(p_ty)
p_ty_t p_ty;
X{
X as_cold(p_ty->ty_kind==TY_NPAG,"wv_npag: Not a new page!");
X wf_wl(&f_t,"");
X wf_wl(&f_t,"\\fwnewpage");
X wf_wl(&f_t,"");
X}
X
X/******************************************************************************/
X
LOCAL void wv_tocs P_((p_ty_t));
LOCAL void wv_tocs(p_ty)
X/* Writes a table of contents to the weave output file. */
p_ty_t p_ty;
X{
X /* We need to save the document list position as the rest of the weaver is   */
X /* in the process of traversing it!!!                                        */
X p_void p_mark = ls_mar(document_list);
X
X as_cold(p_ty->ty_kind==TY_TOCS,"wv_tocs: Not a table of contents!");
X
X wf_wl(&f_t,"");
X wf_wl(&f_t,"\\fwtocstart{}");
X ls_fir(document_list);
X while (TRUE)
X   {
X    p_dc_t p_dc;
X    ls_nxt(document_list,PPV &p_dc);
X    if (p_dc == NULL) break;
X    if (p_dc->dc_kind==DC_TYPE && p_dc->dc_ty.ty_kind==TY_NSEC)
X      {
X       switch(sn_lev(&p_dc->dc_ty.ty_sn))
X         {
X          case 1: wf_wr(&f_t,"\\fwtoca"); break;
X          case 2: wf_wr(&f_t,"\\fwtocb"); break;
X          case 3: wf_wr(&f_t,"\\fwtocc"); break;
X          case 4: wf_wr(&f_t,"\\fwtocd"); break;
X          case 5: wf_wr(&f_t,"\\fwtoce"); break;
X          default: as_bomb("wv_toc: switch defaulted.");
X         }
X       wv_secnn(&p_dc->dc_ty);
X       wf_wl(&f_t,"");
X      }
X   }
X wf_wl(&f_t,"\\fwtocfinish{}");
X wf_wl(&f_t,"");
X
X /* Restore the document list position. */
X ls_set(document_list,p_mark);
X}
X
X/******************************************************************************/
X
LOCAL void wv_skip P_((p_ty_t));
LOCAL void wv_skip(p_ty)
X/* Writes a vertical space to the output file. */
p_ty_t p_ty;
X{
X as_cold(p_ty->ty_kind==TY_SKIP,"wv_skip: Not a skip directive!");
X
X sprintf(linet1,"\\fwvskip{%lu}",(ulong) p_ty->ty_mm);
X wf_wl(&f_t,linet1);
X}
X
X/******************************************************************************/
X
LOCAL void wv_titl P_((p_ty_t));
LOCAL void wv_titl(p_ty)
X/* Writes a title line to the output file. */
p_ty_t p_ty;
X{
X as_cold(p_ty->ty_kind==TY_TITL,"wv_titl: Not a title!");
X
X switch(p_ty->ty_align)
X   {
X    case LR_LEFT: wf_wr(&f_t,"\\fwleftline{");   break;
X    case LR_RIGH: wf_wr(&f_t,"\\fwrightline{");  break;
X    case LR_CENT: wf_wr(&f_t,"\\fwcenterline{"); break;
X    default: as_bomb("wv_title: Alignment switch defaulted.");
X   }
X switch(p_ty->ty_font)
X   {
X    case FT_NORM: wf_wr(&f_t,"\\fwfontnormal{");     break;
X    case FT_TITL: wf_wr(&f_t,"\\fwfonttitle{");      break;
X    case FT_STIT: wf_wr(&f_t,"\\fwfontsmalltitle{"); break;
X    default: as_bomb("wv_title: Font switch defaulted.");
X   }
X wv_ugsc(&p_ty->ty_sc);
X wf_wl(&f_t,"}}");
X}
X
X/******************************************************************************/
X
LOCAL void wv_dcty P_((p_dc_t));
LOCAL void wv_dcty(p_dc)
X/* Weaves a document typesetter element. */
p_dc_t p_dc;
X{
X p_ty_t p_ty = &p_dc->dc_ty;
X
X as_cold(p_dc->dc_kind==DC_TYPE,"wv_dcty: Not a typesetter component!");
X
X switch (p_ty->ty_kind)
X   {
X    case TY_NSEC: wv_nsec(p_ty); break;
X    case TY_OLIT: wv_olit(p_ty); break;
X    case TY_CLIT: wv_clit(p_ty); break;
X    case TY_OEMP: wv_oemp(p_ty); break;
X    case TY_CEMP: wv_cemp(p_ty); break;
X    case TY_NPAG: wv_npag(p_ty); break;
X    case TY_TOCS: wv_tocs(p_ty); break;
X    case TY_SKIP: wv_skip(p_ty); break;
X    case TY_TITL: wv_titl(p_ty); break;
X    default     : as_bomb("wv_dcty: Switch defaulted.");
X   }
X}
X
X/******************************************************************************/
X
LOCAL void wv_dctx P_((p_dc_t));
LOCAL void wv_dctx(p_dc)
X/* Write out a document text item. */
p_dc_t p_dc;
X{
X as_cold(p_dc->dc_kind==DC_TEXT,"wv_dctx: Not text.");
X
X if (literal || tr_codes==TR_NONE)
X    wv_ugscls(p_dc->dc_text);
X else
X    wv_echo(p_dc->dc_text);
X}
X
X/******************************************************************************/
X
LOCAL void wv_eltx P_((p_el_t));
LOCAL void wv_eltx(p_el)
X/* Weaves a text element. */
p_el_t p_el;
X{
X as_cold(p_el->el_kind==EL_TEXT,"wv_eltx: Not text.");
X wv_verb(p_el->el_text);
X}
X
X/******************************************************************************/
X
LOCAL void wv_elin P_((p_el_t));
LOCAL void wv_elin(p_el)
X/* Weaves a invocation element. */
p_el_t p_el;
X{
X as_cold(p_el->el_kind==EL_INVC,"wv_elin: Not an invocation.");
X
X /* Write out the macro call proper. */
X wv_manm(p_el->el_p_mac,1L);
X
X /* Write out the actual parameter list, if any. */
X if (ls_len(p_el->el_parls) > 0)
X   {
X    ulong    parnum;
X    wf_wr(&f_t,"\\fwoparen ");
X    ls_fir(p_el->el_parls);  /* List of actual parameter expressions. */
X    ls_fir(p_el->el_pretx);  /* List of crud before each expression.  */
X    ls_fir(p_el->el_postx);  /* List of crud after  each expression.  */
X    parnum=1;
X    while (TRUE)
X      {
X       p_ells_t *pp_exp;
X       p_scls_t *pp_scls1;
X       p_scls_t *pp_scls2;
X       ls_nxt(p_el->el_parls,PPV &pp_exp);
X       ls_nxt(p_el->el_pretx,PPV &pp_scls1);
X       ls_nxt(p_el->el_postx,PPV &pp_scls2);
X       if (pp_exp==NULL) break;
X       if (parnum++>1) wf_wr(&f_t,"\\fwcomma ");
X       wv_verb(*pp_scls1);
X       wf_wr(&f_t,"\\fwoquote"); wv_ex(*pp_exp); wf_wr(&f_t,"\\fwcquote");
X       wv_verb(*pp_scls2);
X      }
X    wf_wr(&f_t,"\\fwcparen ");
X   }
X}
X
X/******************************************************************************/
X
LOCAL void wv_elpr P_((p_el_t));
LOCAL void wv_elpr(p_el)
X/* Weaves a parameter element. */
p_el_t p_el;
X{
X as_cold(p_el->el_kind==EL_PARM,"wv_elpr: Not a parameter.");
X wf_wr (&f_t,"\\fwparam{");
X wf_dec(&f_t,(ulong) p_el->el_parno);
X wf_wr (&f_t,"}");
X}
X
X
X/******************************************************************************/
X
LOCAL void wv_ex(p_exp)
X/* Weaves a expression. */
p_ells_t p_exp;
X{
X
X ls_fir(p_exp);
X while (TRUE)
X   {
X    p_el_t p_el;
X    ls_nxt(p_exp,PPV &p_el);
X    if (p_el==NULL) break;
X    switch (p_el->el_kind)
X      {
X       case EL_TEXT: wv_eltx(p_el); break;
X       case EL_INVC: wv_elin(p_el); break;
X       case EL_PARM: wv_elpr(p_el); break;
X       default: as_bomb("wv_ex: Case defaulted.");
X      }
X   }
X}
X
X/******************************************************************************/
X
LOCAL void wv_usage P_((p_ma_t));
LOCAL void wv_usage(p_ma)
X/* Weaves a list of all the sections in which the specified macro is used. */
p_ma_t p_ma;
X{
X ulong  no_calls = ls_len(p_ma->ma_calls);
X ulong  callno;
X
X /* If it is a file macro then it is not allowed to be called. */
X if (p_ma->ma_defn.md_isfil)
X   {
X    wf_wl(&f_t,"\\fwisafile{This macro is attached to an output file.}");
X    return;
X   }
X
X if (no_calls==0)
X   {
X    wf_wl(&f_t,"\\fwusedin{This macro is NEVER invoked.}");
X    return;
X   }
X
X wf_wr(&f_t,"\\fwusedin{This macro is invoked in definition");
X if (no_calls>1) wf_chr(&f_t,'s');
X wf_chr(&f_t,' ');
X ls_fir(p_ma->ma_calls);
X for (callno=1;callno<=no_calls;callno++)
X   {
X    p_mc_t p_mc;
X    ls_nxt(p_ma->ma_calls,PPV &p_mc); as_cold(p_mc!=NULL,"wv_usage: Awk!");
X    wf_dec(&f_t,(ulong) p_mc->mc_seq);
X    if (callno < no_calls-1)
X       wf_wr(&f_t,", ");
X    else
X       if (callno==no_calls-1)
X          if (no_calls>2)
X             wf_wr(&f_t,", and ");
X          else
X             wf_wr(&f_t," and ");
X   }
X wf_wl(&f_t,".}");
X}
X
X/******************************************************************************/
X
LOCAL void wv_defin P_((p_ma_t));
LOCAL void wv_defin(p_ma)
X/* Just after each macro body part definition comes a note listing the        */
X/* containing the macro's body parts. This function weaves that list.         */
p_ma_t p_ma;
X{
X ulong  no_parts = ls_len(p_ma->ma_defn.md_body);
X ulong  partno;
X
X /* If it's not an additive macro, we don't write anything. */
X if (!p_ma->ma_defn.md_isadd) return;
X
X wf_wr(&f_t,"\\fwseealso{This macro is defined in definitions ");
X ls_fir(p_ma->ma_defn.md_body);
X for (partno=1;partno<=no_parts;partno++)
X   {
X    p_bp_t p_bp;
X    ls_nxt(p_ma->ma_defn.md_body,PPV &p_bp);
X    as_cold(p_bp!=NULL,"wv_defin: Awk!");
X    wf_dec(&f_t,(ulong) p_bp->bp_seq);
X    if (partno<no_parts-1)
X       wf_wr(&f_t,", ");
X    else
X       if (partno==no_parts-1)
X          if (no_parts>2)
X             wf_wr(&f_t,", and ");
X          else
X             wf_wr(&f_t," and ");
X   }
X wf_wl(&f_t,".}");
X}
X
X/******************************************************************************/
X
LOCAL void wv_dcma P_((p_dc_t));
LOCAL void wv_dcma(p_dc)
X/* Weaves a macro definition. */
p_dc_t p_dc;
X{
X p_bp_t p_bp;
X
X /* Macro calls sandwich the definition itsef. */
X wf_wl(&f_t,"\\fwbeginmacro");
X
X /* Write out the macro's name. */
X wv_manm(p_dc->dc_p_ma,p_dc->dc_part);
X
X /* Write the formal parameter list. */
X if (p_dc->dc_p_ma->ma_defn.md_npar>0)
X   {
X    wf_wr(&f_t,"\\fwparams{");
X    wf_dec(&f_t,(ulong) p_dc->dc_p_ma->ma_defn.md_npar);
X    wf_wr(&f_t,"}");
X   }
X
X /* Zero and many options are indicated by bold letters. */
X if (p_dc->dc_p_ma->ma_defn.md_iszer) wf_wr(&f_t,"\\fwzero{}");
X if (p_dc->dc_p_ma->ma_defn.md_isman) wf_wr(&f_t,"\\fwmany{}");
X
X /* Write the "equals". */
X if (p_dc->dc_p_ma->ma_defn.md_isadd)
X    wf_wr(&f_t,"\\fwplusequals ");
X else
X    wf_wr(&f_t,"\\fwequals ");
X
X /* Write out this particular body part. */
X ls_loo(p_dc->dc_p_ma->ma_defn.md_body,p_dc->dc_part,PPV &p_bp);
X wf_wr(&f_t,"\\fwodef ");
X wv_ex(p_bp->bp_ex);
X wf_wl(&f_t,"\\fwcdef ");
X
X /* After the macro definition, write out notes on the macro. */
X wf_wl(&f_t,"\\fwbeginmacronotes");
X wv_defin(p_dc->dc_p_ma);            /* A list of the macro's body parts.  */
X wv_usage(p_dc->dc_p_ma);            /* A list of where the macro is used. */
X wf_wl(&f_t,"\\fwendmacronotes");
X
X /* The macro definition is sandwiched by macro calls. */
X wf_wl(&f_t,"\\fwendmacro");
X}
X
X/******************************************************************************/
X
LOCAL void wv_dc P_((p_dc_t));
LOCAL void wv_dc(p_dc)
X/* Weaves a document component (p_dc). */
p_dc_t p_dc;
X{
X switch (p_dc->dc_kind)
X   {
X    case DC_TEXT: wv_dctx(p_dc); break;
X    case DC_TYPE: wv_dcty(p_dc); break;
X    case DC_MACR: wv_dcma(p_dc); break;
X    default     : as_bomb("wv_dc: Case defaulted.");
X   }
X}
X
X/******************************************************************************/
X
LOCAL void wv_docnt P_((void));
LOCAL void wv_docnt()
X/* Weaves the entire document. This functions and most functions above assume */
X/* that the output stream f_t is prepared for writing.                        */
X{
X /* Write the typeset header. */
X wv_head();
X
X /* Writes the library macros. */
X tex_head(&f_t);
X
X ls_fir(document_list);
X literal=FALSE;
X while (TRUE)
X   {
X    p_dc_t p_dc;
X    ls_nxt(document_list,PPV &p_dc);
X    if (p_dc == NULL) break;
X    wv_dc(p_dc);
X   }
X wf_wl(&f_t,"\\bye");
X
X /* Write the typeset trailer. */
X wv_tail();
X}
X
X/******************************************************************************/
X
XEXPORT void weave()
X/* Writes out the documentation file. */
X{
X fn_t  fn_tmp;   /* Name of temporary file.                                   */
X fn_t  fn_targ;  /* Name of documentation file.                               */
X bool  renfil;   /* Do we wish to rename output file?                         */
X bool  istarg;   /* Does a target file already exist?                         */
X
X /* Writing the documentation file differs from some other output files. With */
X /* non critical files such as the listing file that are really just logs,    */
X /* generation of half a listing file is acceptable if not desirable. However */
X /* in the case of the documentation file, it is very bad to generate half an */
X /* output file; far better to generate none at all. For this reason, and     */
X /* also because of the presence of the D option (which prevents the writing  */
X /* of output files identical to existing files (to prevent MAKE              */
X /* propagations)) it is best to write a temporary file and then rename it.   */
X
X /* We shouldn't be here if the weave option is off! */
X as_cold(option.op_t_b,"weave: option.op_t_b==FALSE!");
X
X /* Work out what the typeset file's name should be.                          */
X strcpy(fn_targ,"");              /* Start with an empty string.              */
X fn_ins(fn_targ,option.op_f_s);
X fn_ins(fn_targ,".tex");
X fn_ins(fn_targ,option.op_t_s);
X
X /* The temporary file has to inherit too, because the output directory may   */
X /* not be the default directory and some computers can't rename across       */
X /* directories (and we have to rename it later).                             */
X strcpy(fn_tmp,fn_targ);
X fn_ins(fn_tmp,fn_temp());
X
X /* Expand the macro to the temporary file. */
X wf_ini(&f_t,TRUE);
X wf_ope(&f_t,fn_tmp);
X if (wf_err(&f_t))
X   {
X    sprintf(linet1,"Error creating temporary documentation file \"%s\".",&fn_tmp[0]);
X    wl_sjl(linet1);
X    (void) remove(fn_tmp);
X    goto severe;
X   }
X
X wv_docnt();
X
X /* Make sure that there weren't any errors writing to the temporary file. */
X if (wf_err(&f_t))
X   {
X    sprintf(linet1,"Error writing to temporary documentation file \"%s\".",&fn_tmp[0]);
X    wl_sjl(linet1);
X    (void) remove(fn_tmp);
X    goto severe;
X   }
X
X /* Close the temporary file. */
X wf_clo(&f_t);
X if (wf_err(&f_t))
X   {
X    sprintf(linet1,"Error closing temporary documentation file \"%s\".",&fn_tmp[0]);
X    wl_sjl(linet1);
X    remove(fn_tmp);
X    goto severe;
X   }
X
X /* The rest of the code in this function copes with the renaming. */
X
X /* By default, we wish to rename the temporary file. */
X renfil=TRUE;
X
X /* Deal with any existing file of the target name. */
X istarg=fexists(fn_targ);
X if (istarg && option.op_d_b)
X   {
X    /* A target already exists, and the D option is on. If the target is      */
X    /* identical to the temporary, we can simply delete the temporary!        */
X    char *errstr;
X    bool  same;
X    errstr=eq_files(fn_tmp,fn_targ,&same);
X    if (errstr != NULL)
X      {
X       wl_sjl("Error comparing temporary file with previous documentation file.");
X       wl_sjl("(A comparison was attempted because the D option was turned on.)");
X       wl_sjl("Error from comparison routine was as follows (first=temp):");
X       wr_sjl("   ");wl_sjl(errstr);
X       sprintf(linet1,"Temporary file name was \"%s\".",&fn_tmp[0]);
X       wl_sjl(linet1);
X       sprintf(linet1,"Output    file name was \"%s\".",&fn_targ[0]);
X       wl_sjl(linet1);
X       wl_sjl("FunnelWeb will leave both files intact so you can look at them.");
X       goto severe;
X      }
X    /* If the two files are the same, we can simply delete the temporary. */
X    if (same)
X      {
X       int status;
X       status=remove(fn_tmp);
X       if (status != REMOVE_S)
X         {
X          sprintf(linet1,"Error deleting (under +D option) temporary file \"%s\".",&fn_tmp[0]);
X          wl_sjl(linet1);
X          goto severe;
X         }
X       sprintf(linet1,"Deleted identical documentation file \"%s\".",&fn_targ[0]);
X       wl_sjl(linet1);
X       renfil=FALSE;
X      }
X   }
X
X if (renfil)
X   {
X    int status;
X    /* We need to delete any existing file of the target name. */
X    if (istarg)
X      {
X       status=remove(fn_targ);
X       if (status != REMOVE_S)
X         {
X          sprintf(linet1,"Error deleting existing documentation file \"%s\".",&fn_targ[0]);
X          wl_sjl(linet1);
X          goto severe;
X         }
X      }
X    /* Rename the temporary file to the output file. */
X    status=rename(fn_tmp,fn_targ);
X    if (status != RENAME_S)
X      {
X       wl_sjl("Error renaming temporary documentation file to documentation file.");
X       sprintf(linet1,"Temporary file name was \"%s\".",&fn_tmp[0]);
X       wl_sjl(linet1);
X       sprintf(linet1,"Output    file name was \"%s\".",&fn_targ[0]);
X       wl_sjl(linet1);
X       wl_sjl("FunnelWeb will leave both files intact so you can look at them.");
X       goto severe;
X      }
X   }
X
X /* Tell everyone that we have written an output file. */
X sprintf(linet1,"Weave : Completed %s.",fn_nodir(&fn_targ[0]));
X wl_s(linet1);
X if (option.op_b7_b)
X    sprintf(linet1,"Weave: Completed %s.",SUPPNAME);
X wl_j(linet1);
X wl_l(linet1);
X return;
X
X /* Jump here is a nasty file error occurs. */
X severe:
X sprintf(linet1,"A problem occurred during the generation of documentation file \"%s\".",&fn_targ[0]);
X wl_sjl(linet1);
X wl_sjl("S: Aborting...");
X num_sev++;
X return;
X}
X
X/******************************************************************************/
X
END_OF_FILE
if test 31376 -ne `wc -c <'sources/weave.c'`; then
    echo shar: \"'sources/weave.c'\" unpacked with wrong size!
fi
# end of 'sources/weave.c'
fi
if test -f 'userman/u_manual.sin' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'userman/u_manual.sin'\"
else
echo shar: Extracting \"'userman/u_manual.sin'\" \(33582 characters\)
sed "s/^X//" >'userman/u_manual.sin' <<'END_OF_FILE'
X\indexentry{+= tutorial}{26}
X\indexentry{+=}{85}
X\indexentry{2167A}{51}
X\indexentry{== tutorial}{26}
X\indexentry{==}{85}
X\indexentry{@!}{37}
X\indexentry{@!}{75}
X\indexentry{@"}{29}
X\indexentry{@(}{29}
X\indexentry{@)}{29}
X\indexentry{@+}{20}
X\indexentry{@+}{76}
X\indexentry{@,}{29}
X\indexentry{@-}{23}
X\indexentry{@-}{77}
X\indexentry{@1...}{28}
X\indexentry{@1...}{86}
X\indexentry{@<}{20}
X\indexentry{@=}{20}
X\indexentry{@>}{20}
X\indexentry{@A...}{34}
X\indexentry{@braces}{20}
X\indexentry{@braces}{37}
X\indexentry{@circumflex}{74}
X\indexentry{@dollar}{22}
X\indexentry{@hash}{76}
X\indexentry{@i}{30}
X\indexentry{@i}{77}
X\indexentry{@M tutorial}{24}
X\indexentry{@M}{85}
X\indexentry{@O}{20}
X\indexentry{@O}{22}
X\indexentry{@slash}{37}
X\indexentry{@Z tutorial}{24}
X\indexentry{@Z}{85}
X\indexentry{absent command}{93}
X\indexentry{abstract data type}{55}
X\indexentry{abstraction code}{56}
X\indexentry{abstraction data}{26}
X\indexentry{abstraction set}{59}
X\indexentry{abuse comments}{57}
X\indexentry{access random}{50}
X\indexentry{acknowledgements}{11}
X\indexentry{action execution order}{71}
X\indexentry{Action options}{70}
X\indexentry{actual parameters}{29}
X\indexentry{Ada}{11}
X\indexentry{Ada}{44}
X\indexentry{Ada}{49}
X\indexentry{Ada}{51}
X\indexentry{Ada}{55}
X\indexentry{additive macros}{26}
X\indexentry{additive macro}{26}
X\indexentry{additively defined}{85}
X\indexentry{Adelaide University}{59}
X\indexentry{admin directory}{102}
X\indexentry{administration FunnelWeb}{109}
X\indexentry{ADT}{55}
X\indexentry{alias}{49}
X\indexentry{Analyser}{115}
X\indexentry{analyser}{65}
X\indexentry{analyser}{88}
X\indexentry{analysis static}{88}
X\indexentry{Andrew Trevorrow}{13}
X\indexentry{animal poem}{30}
X\indexentry{annual report}{58}
X\indexentry{anonymous ftp}{101}
X\indexentry{ANSI}{109}
X\indexentry{ANSI}{117}
X\indexentry{answers correct}{102}
X\indexentry{answers directory}{102}
X\indexentry{ANZE}{117}
X\indexentry{ANZE}{19}
X\indexentry{applications FunnelWeb}{53}
X\indexentry{arbitrary characters inserting into text}{74}
X\indexentry{architecture semantic}{64}
X\indexentry{archive ftp}{114}
X\indexentry{archive FunnelWeb}{114}
X\indexentry{argument command line}{67}
X\indexentry{arguments}{67}
X\indexentry{Argument}{115}
X\indexentry{assertion severity}{65}
X\indexentry{assertion status}{90}
X\indexentry{Atrax robustus}{19}
X\indexentry{attributes macro}{85}
X\indexentry{author contacting}{114}
X\indexentry{B option}{68}
X\indexentry{Barry Dwyer}{11}
X\indexentry{Barry Dwyer}{59}
X\indexentry{Barry Humphries}{19}
X\indexentry{BASIC}{57}
X\indexentry{Begg Jeremy}{11}
X\indexentry{binding problems}{57}
X\indexentry{bindings macro}{22}
X\indexentry{blank indentation}{78}
X\indexentry{blank indentation}{78}
X\indexentry{blanks trailing}{42}
X\indexentry{boring organization}{50}
X\indexentry{Brissenden Roger}{11}
X\indexentry{BSI82}{117}
X\indexentry{BSI82}{15}
X\indexentry{BSI82}{18}
X\indexentry{C header}{57}
X\indexentry{C option}{68}
X\indexentry{C preprocessor}{20}
X\indexentry{C preprocessor}{57}
X\indexentry{calls macro}{86}
X\indexentry{calls number}{23}
X\indexentry{camera poem}{30}
X\indexentry{case dependence}{67}
X\indexentry{changing special character}{31}
X\indexentry{characters control}{42}
X\indexentry{characters non-printable}{96}
X\indexentry{characters unprintable}{71}
X\indexentry{checks macro}{88}
X\indexentry{cheer hacker's}{35}
X\indexentry{cheer programmer's}{35}
X\indexentry{code abstraction}{56}
X\indexentry{code explaining}{17}
X\indexentry{code gardening}{53}
X\indexentry{code vs documentation}{32}
X\indexentry{codify command}{93}
X\indexentry{command absent}{93}
X\indexentry{command codify}{93}
X\indexentry{command compare}{93}
X\indexentry{command define}{91}
X\indexentry{command define}{94}
X\indexentry{command diffsummary}{95}
X\indexentry{command diffzero}{95}
X\indexentry{command diff}{94}
X\indexentry{command eneo}{95}
X\indexentry{command execute}{96}
X\indexentry{command exists}{96}
X\indexentry{command fixeols}{96}
X\indexentry{command fw}{97}
X\indexentry{command help}{97}
X\indexentry{command here}{98}
X\indexentry{command interpreter}{47}
X\indexentry{command length}{91}
X\indexentry{command line argument}{67}
X\indexentry{command line interface}{66}
X\indexentry{command line options syntax}{67}
X\indexentry{command line parsing}{66}
X\indexentry{command line processing}{66}
X\indexentry{command line processing}{92}
X\indexentry{command line syntax}{67}
X\indexentry{command options}{92}
X\indexentry{command quit}{98}
X\indexentry{command set}{48}
X\indexentry{command set}{98}
X\indexentry{command shell FunnelWeb}{90}
X\indexentry{command show}{48}
X\indexentry{command show}{98}
X\indexentry{command skipto}{98}
X\indexentry{command status}{99}
X\indexentry{command tolerate}{100}
X\indexentry{command trace on}{48}
X\indexentry{command trace}{100}
X\indexentry{command verb fw}{66}
X\indexentry{command writeu}{100}
X\indexentry{command write}{100}
X\indexentry{commands FunnelWeb}{90}
X\indexentry{commands shell}{93}
X\indexentry{commands useful}{47}
X\indexentry{comments abuse}{57}
X\indexentry{comments eliminating}{57}
X\indexentry{comments FunnelWeb}{75}
X\indexentry{comments}{37}
X\indexentry{commitment FunnelWeb}{109}
X\indexentry{compare command}{93}
X\indexentry{compilers Fortran}{42}
X\indexentry{compiling FunnelWeb}{105}
X\indexentry{complete example}{38}
X\indexentry{conditionals fudging}{44}
X\indexentry{console output suppress}{69}
X\indexentry{constructs section}{83}
X\indexentry{contacting author}{114}
X\indexentry{contents table of}{81}
X\indexentry{context infinite}{68}
X\indexentry{context listing file}{68}
X\indexentry{context}{69}
X\indexentry{control characters inserting into text}{74}
X\indexentry{control characters}{42}
X\indexentry{controllability}{18}
X\indexentry{copyright FunnelWeb}{112}
X\indexentry{copyright notice}{1}
X\indexentry{correct answers}{102}
X\indexentry{cross reference numbering}{89}
X\indexentry{cross referencing}{17}
X\indexentry{cross referencing}{89}
X\indexentry{cryptic text files}{55}
X\indexentry{D option}{49}
X\indexentry{D option}{68}
X\indexentry{dangers FunnelWeb}{50}
X\indexentry{data abstraction}{26}
X\indexentry{David Hulse}{11}
X\indexentry{debugger}{53}
X\indexentry{debugging wholistic}{53}
X\indexentry{default options}{49}
X\indexentry{default options}{92}
X\indexentry{default special character}{72}
X\indexentry{define command}{91}
X\indexentry{define command}{94}
X\indexentry{definition FunnelWeb}{63}
X\indexentry{definition macro}{85}
X\indexentry{definition macro}{87}
X\indexentry{delete output files}{49}
X\indexentry{delete output option}{68}
X\indexentry{delimiting macro parameter}{87}
X\indexentry{dependence case}{67}
X\indexentry{dependencies file}{49}
X\indexentry{development time}{17}
X\indexentry{diagnostics levels of}{65}
X\indexentry{diagnostics}{65}
X\indexentry{dictionary hacker's}{35}
X\indexentry{diff command}{94}
X\indexentry{differences file}{94}
X\indexentry{diffsummary command}{95}
X\indexentry{diffzero command}{95}
X\indexentry{directive emphasis}{85}
X\indexentry{directive literal}{84}
X\indexentry{directive newpage}{37}
X\indexentry{directive table of contents}{37}
X\indexentry{directive title}{37}
X\indexentry{directive vskip}{37}
X\indexentry{directives typesetter}{81}
X\indexentry{directives}{32}
X\indexentry{directives}{83}
X\indexentry{Directive}{115}
X\indexentry{directory admin}{102}
X\indexentry{directory answers}{102}
X\indexentry{directory hackman}{103}
X\indexentry{directory results}{103}
X\indexentry{directory scripts}{103}
X\indexentry{directory sources}{103}
X\indexentry{directory tests}{104}
X\indexentry{directory tree}{102}
X\indexentry{directory userman}{105}
X\indexentry{directory}{70}
X\indexentry{Distribution FunnelWeb}{113}
X\indexentry{document list dump}{68}
X\indexentry{document list}{64}
X\indexentry{documentation duplicate}{51}
X\indexentry{documentation examples}{58}
X\indexentry{Documentation file}{115}
X\indexentry{documentation file}{18}
X\indexentry{documentation FunnelWeb}{110}
X\indexentry{documentation interdependent}{50}
X\indexentry{documentation over}{51}
X\indexentry{documentation pavlov}{51}
X\indexentry{documentation vs code}{32}
X\indexentry{Documentation}{115}
X\indexentry{documentation}{64}
X\indexentry{DOD83}{55}
X\indexentry{Donald Knuth}{11}
X\indexentry{Donald Knuth}{50}
X\indexentry{Donald Knuth}{9}
X\indexentry{dump document list}{68}
X\indexentry{dump global line list}{68}
X\indexentry{dump macro table}{68}
X\indexentry{dump mapped file}{68}
X\indexentry{dump option}{68}
X\indexentry{dump times}{68}
X\indexentry{dump token list}{68}
X\indexentry{duplicate documentation}{51}
X\indexentry{Dwyer Barry}{11}
X\indexentry{Dwyer Barry}{59}
X\indexentry{EBNF syntax}{63}
X\indexentry{editors text}{42}
X\indexentry{Edna Everage}{19}
X\indexentry{efficiency FunnelWeb}{47}
X\indexentry{efficiency notes}{47}
X\indexentry{eliminating comments}{57}
X\indexentry{emphasis construct}{37}
X\indexentry{emphasis directive}{85}
X\indexentry{empty name}{42}
X\indexentry{end-of-line fiddling with}{43}
X\indexentry{eneo command}{95}
X\indexentry{EOL fiddling with}{43}
X\indexentry{EOL markers inserting}{76}
X\indexentry{EOL markers suppressing}{77}
X\indexentry{EOL suppression}{23}
X\indexentry{error severity}{65}
X\indexentry{error status}{90}
X\indexentry{errors shell}{90}
X\indexentry{Everage Edna}{19}
X\indexentry{example applications FunnelWeb}{53}
X\indexentry{example complete}{38}
X\indexentry{example filename inheritance}{70}
X\indexentry{Example FunnelWeb}{38}
X\indexentry{examples documentation}{58}
X\indexentry{executable FunnelWeb}{106}
X\indexentry{execute command}{96}
X\indexentry{execute script option}{69}
X\indexentry{execution phases}{64}
X\indexentry{exists command}{96}
X\indexentry{expansion macro}{30}
X\indexentry{expansion macro}{47}
X\indexentry{expansion macro}{87}
X\indexentry{explaining code}{17}
X\indexentry{expressions macro}{86}
X\indexentry{expression}{85}
X\indexentry{extension}{70}
X\indexentry{F option}{68}
X\indexentry{fatal severity}{65}
X\indexentry{fatal status}{90}
X\indexentry{fiddling with end-of-line}{43}
X\indexentry{fiddling with EOL}{43}
X\indexentry{fields filename}{70}
X\indexentry{file dependencies}{49}
X\indexentry{file differences}{94}
X\indexentry{file include}{69}
X\indexentry{file journal}{69}
X\indexentry{file listing}{69}
X\indexentry{file suppression}{49}
X\indexentry{file termination}{71}
X\indexentry{file typeset}{69}
X\indexentry{filename fields}{70}
X\indexentry{filename inheritance example}{70}
X\indexentry{filename inheritance}{70}
X\indexentry{files header}{57}
X\indexentry{files include}{30}
X\indexentry{files include}{77}
X\indexentry{files input}{47}
X\indexentry{fixeols command}{96}
X\indexentry{font size}{46}
X\indexentry{formal parameter lists}{86}
X\indexentry{formal parameters}{28}
X\indexentry{formal parameters}{28}
X\indexentry{formal parameters}{87}
X\indexentry{Fortran compilers}{42}
X\indexentry{Free text}{115}
X\indexentry{free text}{32}
X\indexentry{Free text}{83}
X\indexentry{free text}{83}
X\indexentry{freestanding typesetter directives}{83}
X\indexentry{freestanding}{81}
X\indexentry{ftp anonymous}{101}
X\indexentry{ftp archive}{114}
X\indexentry{fudging conditionals}{44}
X\indexentry{fudging generics}{59}
X\indexentry{functions small}{56}
X\indexentry{Funnel-web spider}{19}
X\indexentry{FunnelWeb administration}{109}
X\indexentry{FunnelWeb applications}{53}
X\indexentry{FunnelWeb archive}{114}
X\indexentry{FunnelWeb command shell}{90}
X\indexentry{FunnelWeb command shell}{90}
X\indexentry{FunnelWeb commands}{90}
X\indexentry{FunnelWeb comments}{75}
X\indexentry{FunnelWeb commitment}{109}
X\indexentry{FunnelWeb compiling}{105}
X\indexentry{FunnelWeb copyright}{112}
X\indexentry{FunnelWeb dangers}{50}
X\indexentry{FunnelWeb definition}{63}
X\indexentry{FunnelWeb Distribution}{113}
X\indexentry{FunnelWeb documentation}{110}
X\indexentry{FunnelWeb efficiency}{47}
X\indexentry{FunnelWeb example applications}{53}
X\indexentry{FunnelWeb Example}{38}
X\indexentry{FunnelWeb executable}{106}
X\indexentry{FunnelWeb file}{115}
X\indexentry{FunnelWeb file}{64}
X\indexentry{FunnelWeb hints}{41}
X\indexentry{FunnelWeb initialization}{70}
X\indexentry{FunnelWeb installation}{101}
X\indexentry{FunnelWeb installing}{106}
X\indexentry{FunnelWeb invoking}{66}
X\indexentry{FunnelWeb language}{115}
X\indexentry{FunnelWeb license}{112}
X\indexentry{FunnelWeb martinet}{42}
X\indexentry{FunnelWeb name}{19}
X\indexentry{FunnelWeb obtaining}{101}
X\indexentry{FunnelWeb overview}{18}
X\indexentry{FunnelWeb overview}{64}
X\indexentry{FunnelWeb pitfalls}{50}
X\indexentry{FunnelWeb program}{65}
X\indexentry{FunnelWeb proper}{115}
X\indexentry{FunnelWeb proper}{48}
X\indexentry{FunnelWeb proper}{65}
X\indexentry{FunnelWeb registration}{110}
X\indexentry{FunnelWeb rules}{42}
X\indexentry{FunnelWeb running}{66}
X\indexentry{FunnelWeb shell}{90}
X\indexentry{FunnelWeb startup}{70}
X\indexentry{FunnelWeb support}{110}
X\indexentry{FunnelWeb testing}{105}
X\indexentry{FunnelWeb two main aspects}{21}
X\indexentry{FunnelWeb versions}{114}
X\indexentry{FunnelWeb}{115}
X\indexentry{fw command verb}{66}
X\indexentry{fw command}{97}
X\indexentry{fwinit.fws}{49}
X\indexentry{fwinit.fws}{71}
X\indexentry{FW}{115}
X\indexentry{gardening code}{53}
X\indexentry{generics fudging}{59}
X\indexentry{generics typesafe}{61}
X\indexentry{global line list dump}{68}
X\indexentry{glossary}{115}
X\indexentry{GNU license}{112}
X\indexentry{GNU license}{18}
X\indexentry{GNU license}{9}
X\indexentry{good old days}{57}
X\indexentry{Gries81}{117}
X\indexentry{Gries81}{51}
X\indexentry{H option}{68}
X\indexentry{hacker's cheer}{35}
X\indexentry{hacker's dictionary}{35}
X\indexentry{Hackett Simon}{11}
X\indexentry{hackman directory}{103}
X\indexentry{header C}{57}
X\indexentry{header file postscript}{54}
X\indexentry{header files}{57}
X\indexentry{header page}{37}
X\indexentry{headings section}{34}
X\indexentry{headings strength}{46}
X\indexentry{Hello Northern Hemisphere Program}{21}
X\indexentry{hello world document}{20}
X\indexentry{help command}{97}
X\indexentry{help option}{68}
X\indexentry{here command}{98}
X\indexentry{hierarchical structure}{34}
X\indexentry{high level syntax}{82}
X\indexentry{hints FunnelWeb}{41}
X\indexentry{Hulse David}{11}
X\indexentry{Humphries Barry}{19}
X\indexentry{Humphries91}{117}
X\indexentry{Humphries91}{19}
X\indexentry{hypertext}{15}
X\indexentry{I option}{69}
X\indexentry{identifiers macro}{41}
X\indexentry{include file option}{69}
X\indexentry{include files recursive}{31}
X\indexentry{include files}{30}
X\indexentry{include files}{77}
X\indexentry{include files}{77}
X\indexentry{Include file}{115}
X\indexentry{include file}{69}
X\indexentry{indentation blank}{78}
X\indexentry{indentation macro calls}{25}
X\indexentry{indentation macro expansion}{78}
X\indexentry{indentation none}{78}
X\indexentry{independence language}{18}
X\indexentry{independence typesetter}{18}
X\indexentry{independence typesetter}{34}
X\indexentry{independence typesetter}{65}
X\indexentry{independence typesetter}{80}
X\indexentry{infinite context}{68}
X\indexentry{inheritance filename}{70}
X\indexentry{inheritance section name}{35}
X\indexentry{initialization FunnelWeb}{70}
X\indexentry{initialization script}{49}
X\indexentry{initialization script}{71}
X\indexentry{inline typesetter directives}{83}
X\indexentry{inline}{81}
X\indexentry{input file option}{68}
X\indexentry{input files}{47}
X\indexentry{Input file}{115}
X\indexentry{input file}{18}
X\indexentry{input file}{64}
X\indexentry{input file}{77}
X\indexentry{input line length maximum}{79}
X\indexentry{input line length pragma}{79}
X\indexentry{input line length}{42}
X\indexentry{input line length}{79}
X\indexentry{inserting EOL markers}{76}
X\indexentry{inserting into text arbitrary characters}{74}
X\indexentry{inserting into text control characters}{74}
X\indexentry{inserting into text special character}{74}
X\indexentry{installation FunnelWeb}{101}
X\indexentry{installation problems}{107}
X\indexentry{installing FunnelWeb}{106}
X\indexentry{interactive mode}{47}
X\indexentry{interactive option}{69}
X\indexentry{interdependent documentation}{50}
X\indexentry{interface command line}{66}
X\indexentry{interpreter command}{47}
X\indexentry{introduction tutorial}{19}
X\indexentry{invisible pragmas}{78}
X\indexentry{invocation number}{23}
X\indexentry{invocations number}{42}
X\indexentry{invoking FunnelWeb}{20}
X\indexentry{invoking FunnelWeb}{66}
X\indexentry{J option}{69}
X\indexentry{Jeremy Begg}{11}
X\indexentry{journal file option}{69}
X\indexentry{Journal file}{115}
X\indexentry{journal file}{64}
X\indexentry{journal file}{69}
X\indexentry{K option}{69}
X\indexentry{Kernighan88}{117}
X\indexentry{Kernighan88}{65}
X\indexentry{keyboard mode}{47}
X\indexentry{keyboard option}{69}
X\indexentry{Knuth Donald}{11}
X\indexentry{Knuth Donald}{50}
X\indexentry{Knuth Donald}{9}
X\indexentry{Knuth83}{117}
X\indexentry{Knuth83}{17}
X\indexentry{Knuth83}{25}
X\indexentry{Knuth83}{25}
X\indexentry{Knuth83}{9}
X\indexentry{Knuth84}{117}
X\indexentry{Knuth84}{117}
X\indexentry{Knuth84}{13}
X\indexentry{Knuth84}{17}
X\indexentry{Knuth84}{18}
X\indexentry{L option}{69}
X\indexentry{Lamport86}{117}
X\indexentry{Lamport86}{13}
X\indexentry{language independence}{18}
X\indexentry{languages multiple}{55}
X\indexentry{laser printer}{55}
X\indexentry{LaTeX}{13}
X\indexentry{LaTeX}{84}
X\indexentry{layout program}{22}
X\indexentry{layout program}{28}
X\indexentry{length command}{91}
X\indexentry{length input line}{42}
X\indexentry{length line}{71}
X\indexentry{length output line}{42}
X\indexentry{letter}{67}
X\indexentry{levels of diagnostics}{65}
X\indexentry{libraries macro}{31}
X\indexentry{license FunnelWeb}{112}
X\indexentry{license GNU}{112}
X\indexentry{license GNU}{18}
X\indexentry{license GNU}{9}
X\indexentry{line length input}{79}
X\indexentry{line length}{71}
X\indexentry{line termination}{71}
X\indexentry{list document}{64}
X\indexentry{list options}{68}
X\indexentry{list shell commands}{93}
X\indexentry{listing file context}{68}
X\indexentry{listing file option}{69}
X\indexentry{Listing file}{115}
X\indexentry{listing file}{64}
X\indexentry{listing file}{69}
X\indexentry{literal construct}{37}
X\indexentry{literal directive}{84}
X\indexentry{literate programming tools}{15}
X\indexentry{literate programming, facilities}{15}
X\indexentry{literate programming, most significant benefit}{17}
X\indexentry{literate programming}{15}
X\indexentry{literate programming}{15}
X\indexentry{literate programming}{50}
X\indexentry{MacDraw}{54}
X\indexentry{Macintosh}{13}
X\indexentry{Macintosh}{54}
X\indexentry{macro attributes}{85}
X\indexentry{macro bindings}{22}
X\indexentry{macro body}{85}
X\indexentry{macro calls indentation}{25}
X\indexentry{macro calls}{86}
X\indexentry{macro checks}{88}
X\indexentry{macro definitions}{32}
X\indexentry{Macro definition}{116}
X\indexentry{macro definition}{85}
X\indexentry{macro definition}{87}
X\indexentry{macro expansion indentation}{78}
X\indexentry{macro expansion}{30}
X\indexentry{macro expansion}{47}
X\indexentry{macro expansion}{87}
X\indexentry{macro expressions}{86}
X\indexentry{macro facilities tutorial}{22}
X\indexentry{macro identifiers}{41}
X\indexentry{macro libraries}{31}
X\indexentry{macro names}{41}
X\indexentry{macro names}{86}
X\indexentry{macro name}{85}
X\indexentry{macro parameter delimiting}{87}
X\indexentry{macro recursion}{43}
X\indexentry{macro recursion}{88}
X\indexentry{macro table dump}{68}
X\indexentry{macro table}{64}
X\indexentry{macros additive}{26}
X\indexentry{macros parameterized}{28}
X\indexentry{macros simple tutorial}{22}
X\indexentry{macros static}{87}
X\indexentry{Macro}{115}
X\indexentry{magic trick}{15}
X\indexentry{maintenance programmer}{50}
X\indexentry{make utility}{49}
X\indexentry{manuals printing}{107}
X\indexentry{mapped file dump}{68}
X\indexentry{Mapper}{116}
X\indexentry{mapper}{71}
X\indexentry{martinet FunnelWeb}{42}
X\indexentry{maximum input line length}{79}
X\indexentry{maximum output file line length pragma}{79}
X\indexentry{maximum output file line length}{79}
X\indexentry{maximum product file line length pragma}{79}
X\indexentry{maximum product file line length}{79}
X\indexentry{medicine wholistic}{53}
X\indexentry{memory use of}{30}
X\indexentry{memory}{47}
X\indexentry{MIL-STD-2167A}{51}
X\indexentry{monster file postscript}{54}
X\indexentry{multiple languages}{55}
X\indexentry{name empty}{42}
X\indexentry{name FunnelWeb}{19}
X\indexentry{name section}{34}
X\indexentry{name section}{84}
X\indexentry{names macro}{41}
X\indexentry{names macro}{86}
X\indexentry{names quick}{42}
X\indexentry{names quick}{76}
X\indexentry{names section}{86}
X\indexentry{names}{86}
X\indexentry{name}{70}
X\indexentry{new page pragma}{81}
X\indexentry{new page}{81}
X\indexentry{newpage directive}{37}
X\indexentry{no indentation}{78}
X\indexentry{non-determinism}{68}
X\indexentry{non-printable characters}{96}
X\indexentry{none indentation}{78}
X\indexentry{notation}{63}
X\indexentry{notes efficiency}{47}
X\indexentry{notice copyright}{1}
X\indexentry{novels}{50}
X\indexentry{number calls}{23}
X\indexentry{number invocations}{42}
X\indexentry{number invocation}{23}
X\indexentry{number of times called}{23}
X\indexentry{numbering cross reference}{89}
X\indexentry{numbering section}{89}
X\indexentry{object code}{26}
X\indexentry{obtaining FunnelWeb}{101}
X\indexentry{open systems}{55}
X\indexentry{option B}{68}
X\indexentry{option C}{68}
X\indexentry{option delete output}{68}
X\indexentry{option dump}{68}
X\indexentry{option D}{49}
X\indexentry{option D}{68}
X\indexentry{option execute script}{69}
X\indexentry{option F}{68}
X\indexentry{option help}{68}
X\indexentry{option H}{68}
X\indexentry{option include file}{69}
X\indexentry{option input file}{68}
X\indexentry{option interactive}{69}
X\indexentry{option I}{69}
X\indexentry{option journal file}{69}
X\indexentry{option J}{69}
X\indexentry{option keyboard}{69}
X\indexentry{option K}{69}
X\indexentry{option listing file}{69}
X\indexentry{option L}{69}
X\indexentry{option quiet}{69}
X\indexentry{option Q}{69}
X\indexentry{option screen}{69}
X\indexentry{option S}{69}
X\indexentry{option typeset}{69}
X\indexentry{option T}{69}
X\indexentry{option width}{69}
X\indexentry{option W}{69}
X\indexentry{option X}{69}
X\indexentry{options command}{92}
X\indexentry{options default}{49}
X\indexentry{options default}{92}
X\indexentry{options list}{68}
X\indexentry{options setting defaults}{49}
X\indexentry{options syntax}{67}
X\indexentry{options tracedump}{68}
X\indexentry{options}{67}
X\indexentry{options}{68}
X\indexentry{Option}{116}
X\indexentry{order action execution}{71}
X\indexentry{order program}{22}
X\indexentry{ordering program}{15}
X\indexentry{Ordinary options}{70}
X\indexentry{organization boring}{50}
X\indexentry{organization spaghetti}{50}
X\indexentry{output file line length maximum}{79}
X\indexentry{output files delete}{49}
X\indexentry{output files}{18}
X\indexentry{output files}{64}
X\indexentry{Output file}{116}
X\indexentry{output line length}{42}
X\indexentry{output WEB}{25}
X\indexentry{over documentation}{51}
X\indexentry{overhead procedure call}{57}
X\indexentry{overview FunnelWeb}{18}
X\indexentry{overview FunnelWeb}{64}
X\indexentry{overview typesetting}{32}
X\indexentry{OzTeX}{13}
X\indexentry{package}{55}
X\indexentry{parameter list, absent}{29}
X\indexentry{parameter lists formal}{86}
X\indexentry{parameterized macros}{28}
X\indexentry{parameters actual}{29}
X\indexentry{parameters formal}{28}
X\indexentry{parameters formal}{28}
X\indexentry{parameters formal}{87}
X\indexentry{Parser}{116}
X\indexentry{parser}{64}
X\indexentry{parser}{82}
X\indexentry{parsing command line}{66}
X\indexentry{Pascal}{15}
X\indexentry{Pascal}{25}
X\indexentry{Pascal}{26}
X\indexentry{Pascal}{57}
X\indexentry{Pascal}{59}
X\indexentry{Pat Scannel}{29}
X\indexentry{pavlov documentation}{51}
X\indexentry{phases execution}{64}
X\indexentry{phases}{64}
X\indexentry{PhD thesis}{54}
X\indexentry{pitfalls FunnelWeb}{50}
X\indexentry{poem animal}{30}
X\indexentry{poem camera}{30}
X\indexentry{portability}{18}
X\indexentry{postscript header file}{54}
X\indexentry{postscript monster file}{54}
X\indexentry{PostScript}{54}
X\indexentry{postscript}{57}
X\indexentry{pragma input line length}{79}
X\indexentry{pragma maximum output file line length}{79}
X\indexentry{pragma maximum product file line length}{79}
X\indexentry{pragma new page}{81}
X\indexentry{pragma table of contents}{81}
X\indexentry{pragma title}{82}
X\indexentry{pragma typesetter}{80}
X\indexentry{pragma vskip}{81}
X\indexentry{pragmas invisible}{78}
X\indexentry{pragmas visible}{78}
X\indexentry{pragmas}{78}
X\indexentry{Pragma}{116}
X\indexentry{pragma}{25}
X\indexentry{pragma}{78}
X\indexentry{preface}{9}
X\indexentry{preprocessor C}{20}
X\indexentry{preprocessor C}{57}
X\indexentry{presentation notes}{13}
X\indexentry{Printed documentation}{116}
X\indexentry{printer laser}{55}
X\indexentry{printing manuals}{107}
X\indexentry{printing system}{55}
X\indexentry{problems binding}{57}
X\indexentry{problems installation}{107}
X\indexentry{procedure call overhead}{57}
X\indexentry{processing command line}{66}
X\indexentry{processing command line}{92}
X\indexentry{product file line length maximum}{79}
X\indexentry{product file width}{69}
X\indexentry{product files}{18}
X\indexentry{product files}{64}
X\indexentry{Product file}{116}
X\indexentry{production tool}{19}
X\indexentry{program layout}{22}
X\indexentry{program layout}{28}
X\indexentry{program ordering}{15}
X\indexentry{program order}{22}
X\indexentry{programmer maintenance}{50}
X\indexentry{programmer's cheer}{35}
X\indexentry{programming literate}{50}
X\indexentry{Q option}{69}
X\indexentry{quick names}{42}
X\indexentry{quick names}{76}
X\indexentry{quick name}{42}
X\indexentry{quick name}{76}
X\indexentry{quiet option}{69}
X\indexentry{quit command}{98}
X\indexentry{random access}{50}
X\indexentry{rec.humor.funny}{29}
X\indexentry{recursion macro}{43}
X\indexentry{recursion macro}{88}
X\indexentry{recursive include files}{31}
X\indexentry{references}{117}
X\indexentry{referencing cross}{89}
X\indexentry{registration FunnelWeb}{110}
X\indexentry{regression testing}{103}
X\indexentry{regression testing}{47}
X\indexentry{reliability}{18}
X\indexentry{REM statement}{57}
X\indexentry{report annual}{58}
X\indexentry{results directory}{103}
X\indexentry{return status}{65}
X\indexentry{Roger Brissenden}{11}
X\indexentry{Rosovsky90}{117}
X\indexentry{Rosovsky90}{17}
X\indexentry{Ross Williams}{1}
X\indexentry{rule simple}{20}
X\indexentry{rules FunnelWeb}{42}
X\indexentry{running FunnelWeb}{66}
X\indexentry{S option}{69}
X\indexentry{Scannel Pat}{29}
X\indexentry{Scanner}{116}
X\indexentry{scanner}{64}
X\indexentry{scanner}{71}
X\indexentry{screen option}{69}
X\indexentry{script initialization}{49}
X\indexentry{script initialization}{71}
X\indexentry{script startup}{49}
X\indexentry{scripts directory}{103}
X\indexentry{Script}{116}
X\indexentry{section constructs}{83}
X\indexentry{section headings}{34}
X\indexentry{section name inheritance}{35}
X\indexentry{section names}{86}
X\indexentry{section name}{34}
X\indexentry{section name}{84}
X\indexentry{section numbering}{89}
X\indexentry{section strength}{46}
X\indexentry{semantic architecture}{64}
X\indexentry{sequences special}{72}
X\indexentry{set abstraction}{59}
X\indexentry{set command}{48}
X\indexentry{set command}{98}
X\indexentry{setting defaults options}{49}
X\indexentry{setting special character}{74}
X\indexentry{severe severity}{65}
X\indexentry{severe status}{90}
X\indexentry{severity assertion}{65}
X\indexentry{severity error}{65}
X\indexentry{severity fatal}{65}
X\indexentry{severity severe}{65}
X\indexentry{severity warning}{65}
X\indexentry{severity}{65}
X\indexentry{sharing information}{56}
X\indexentry{sharing text}{58}
X\indexentry{shark white pointer}{19}
X\indexentry{shell commands list}{93}
X\indexentry{shell commands}{93}
X\indexentry{shell errors}{90}
X\indexentry{shell FunnelWeb}{90}
X\indexentry{shell uses}{90}
X\indexentry{Shell}{116}
X\indexentry{shooting}{31}
X\indexentry{show command}{48}
X\indexentry{show command}{98}
X\indexentry{sign}{67}
X\indexentry{Simon Hackett}{11}
X\indexentry{simple macros tutorial}{22}
X\indexentry{simple rule}{20}
X\indexentry{simple sequence}{72}
X\indexentry{simplicity}{18}
X\indexentry{size font}{46}
X\indexentry{skip vertical}{81}
X\indexentry{skipto command}{98}
X\indexentry{small functions}{56}
X\indexentry{Smith91}{117}
X\indexentry{Smith91}{17}
X\indexentry{snake tiger}{19}
X\indexentry{song}{29}
X\indexentry{sources directory}{103}
X\indexentry{spacing}{43}
X\indexentry{spaghetti organization}{50}
X\indexentry{special character changing}{31}
X\indexentry{special character default}{72}
X\indexentry{special character inserting into text}{74}
X\indexentry{special character setting}{74}
X\indexentry{Special character}{116}
X\indexentry{special character}{20}
X\indexentry{special character}{72}
X\indexentry{special sequences}{72}
X\indexentry{Special sequence}{116}
X\indexentry{special sequence}{20}
X\indexentry{special sequence}{72}
X\indexentry{special tokens}{82}
X\indexentry{speed}{47}
X\indexentry{spider Funnel-web}{19}
X\indexentry{startup FunnelWeb}{70}
X\indexentry{startup script}{49}
X\indexentry{statement REM}{57}
X\indexentry{static analysis}{88}
X\indexentry{static macros}{87}
X\indexentry{status assertion}{90}
X\indexentry{status command}{99}
X\indexentry{status error}{90}
X\indexentry{status fatal}{90}
X\indexentry{status return}{65}
X\indexentry{status severe}{90}
X\indexentry{status success}{90}
X\indexentry{status warning}{90}
X\indexentry{stream of consciousness}{50}
X\indexentry{strength headings}{46}
X\indexentry{strength section}{46}
X\indexentry{strength typesetting}{46}
X\indexentry{string substitution}{91}
X\indexentry{string substitution}{94}
X\indexentry{string}{67}
X\indexentry{structure hierarchical}{34}
X\indexentry{structure tree}{83}
X\indexentry{Strunk79}{117}
X\indexentry{Strunk79}{51}
X\indexentry{substitution string}{91}
X\indexentry{substitution string}{94}
X\indexentry{success status}{90}
X\indexentry{support FunnelWeb}{110}
X\indexentry{suppress console output}{69}
X\indexentry{suppressing EOL markers}{77}
X\indexentry{suppression EOL}{23}
X\indexentry{suppression file}{49}
X\indexentry{Sydney}{19}
X\indexentry{syntax command line options}{67}
X\indexentry{syntax command line}{67}
X\indexentry{syntax EBNF}{63}
X\indexentry{syntax high level}{82}
X\indexentry{syntax options}{67}
X\indexentry{system printing}{55}
X\indexentry{T option}{69}
X\indexentry{table macro}{64}
X\indexentry{table of contents directive}{37}
X\indexentry{table of contents pragma}{81}
X\indexentry{table of contents}{81}
X\indexentry{tabs}{42}
X\indexentry{Tangle}{116}
X\indexentry{tangle}{65}
X\indexentry{tangle}{88}
X\indexentry{Tangling}{21}
X\indexentry{target typesetter}{89}
X\indexentry{termination file}{71}
X\indexentry{termination line}{71}
X\indexentry{terminology}{63}
X\indexentry{testing FunnelWeb}{105}
X\indexentry{testing regression}{103}
X\indexentry{testing regression}{47}
X\indexentry{tests directory}{104}
X\indexentry{text editors}{42}
X\indexentry{text files cryptic}{55}
X\indexentry{text free}{83}
X\indexentry{text sharing}{58}
X\indexentry{text tokens}{82}
X\indexentry{TeX}{13}
X\indexentry{TeX}{18}
X\indexentry{TeX}{22}
X\indexentry{TeX}{54}
X\indexentry{thesis PhD}{54}
X\indexentry{tiger snake}{19}
X\indexentry{time development}{17}
X\indexentry{times dump}{68}
X\indexentry{title directive}{37}
X\indexentry{title pragma}{82}
X\indexentry{title}{82}
X\indexentry{token list dump}{68}
X\indexentry{tolerate command}{100}
X\indexentry{tools literate programming}{15}
X\indexentry{trace command}{100}
X\indexentry{trace on command}{48}
X\indexentry{tracedump options}{68}
X\indexentry{trailing blanks}{42}
X\indexentry{tree directory}{102}
X\indexentry{tree structure}{83}
X\indexentry{Trevorrow Andrew}{13}
X\indexentry{tutorial +=}{26}
X\indexentry{tutorial ==}{26}
X\indexentry{tutorial @M}{24}
X\indexentry{tutorial @Z}{24}
X\indexentry{tutorial introduction}{19}
X\indexentry{tutorial macro facilities}{22}
X\indexentry{tutorial macros simple}{22}
X\indexentry{tutorial simple macros}{22}
X\indexentry{tutorial typesetting}{32}
X\indexentry{tutorial}{15}
X\indexentry{tutorial}{19}
X\indexentry{twelve bugs of christmas}{29}
X\indexentry{two main aspects FunnelWeb}{21}
X\indexentry{typesafe generics}{61}
X\indexentry{typeset file}{69}
X\indexentry{typeset option}{69}
X\indexentry{typesetter directive tokens}{82}
X\indexentry{typesetter directives}{66}
X\indexentry{typesetter directives}{81}
X\indexentry{typesetter independence}{18}
X\indexentry{typesetter independence}{34}
X\indexentry{typesetter independence}{65}
X\indexentry{typesetter independence}{80}
X\indexentry{typesetter independent}{34}
X\indexentry{typesetter pragma}{80}
X\indexentry{typesetter target}{89}
X\indexentry{Typesetting directive}{116}
X\indexentry{typesetting overview}{32}
X\indexentry{typesetting strength}{46}
X\indexentry{typesetting tutorial}{32}
X\indexentry{typesetting}{13}
X\indexentry{typesetting}{89}
X\indexentry{universities}{17}
X\indexentry{University Adelaide}{59}
X\indexentry{Unix newline}{75}
X\indexentry{Unix}{67}
X\indexentry{unprintable characters}{71}
X\indexentry{USDOD83}{117}
X\indexentry{use of memory}{30}
X\indexentry{useful commands}{47}
X\indexentry{userman directory}{105}
X\indexentry{uses shell}{90}
X\indexentry{versions FunnelWeb}{114}
X\indexentry{vertical skip}{81}
X\indexentry{visible pragmas}{78}
X\indexentry{vskip directive}{37}
X\indexentry{vskip pragma}{81}
X\indexentry{W option}{69}
X\indexentry{warning severity}{65}
X\indexentry{warning status}{90}
X\indexentry{warranty}{112}
X\indexentry{Weave}{116}
X\indexentry{weave}{65}
X\indexentry{weave}{89}
X\indexentry{Weaving}{21}
X\indexentry{WEB output}{25}
X\indexentry{WEB}{21}
X\indexentry{WEB}{25}
X\indexentry{Web}{9}
X\indexentry{white pointer shark}{19}
X\indexentry{wholistic debugging}{53}
X\indexentry{wholistic debugging}{53}
X\indexentry{wholistic medicine}{53}
X\indexentry{width option}{69}
X\indexentry{width product file}{69}
X\indexentry{Williams Ross}{1}
X\indexentry{workstations}{48}
X\indexentry{workstation}{90}
X\indexentry{write command}{100}
X\indexentry{writeu command}{100}
X\indexentry{X option}{69}
END_OF_FILE
if test 33582 -ne `wc -c <'userman/u_manual.sin'`; then
    echo shar: \"'userman/u_manual.sin'\" unpacked with wrong size!
fi
# end of 'userman/u_manual.sin'
fi
echo shar: End of archive 13 \(of 20\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 20 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
