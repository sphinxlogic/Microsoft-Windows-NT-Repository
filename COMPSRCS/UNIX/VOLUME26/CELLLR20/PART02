Newsgroups: comp.sources.unix
From: dana@rucs.faculty.cs.runet.edu (J Dana Eckart)
Subject: v26i089: cellular-2.0 - a cellular automata language, Part02/03
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: dana@rucs.faculty.cs.runet.edu (J Dana Eckart)
Posting-Number: Volume 26, Issue 89
Archive-Name: cellular-2.0/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 3)."
# Contents:  COPYING compiler/Cellang.tex compiler/scanner.c
#   driver/pe-scam.man viewer/cellview.man viewer/view.c viewer/x11.c
# Wrapped by vixie@gw.home.vix.com on Sat Apr  3 01:27:39 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'COPYING' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'COPYING'\"
else
echo shar: Extracting \"'COPYING'\" \(12488 characters\)
sed "s/^X//" >'COPYING' <<'END_OF_FILE'
X
X		    GNU GENERAL PUBLIC LICENSE
X		     Version 1, February 1989
X
X Copyright (C) 1989 Free Software Foundation, Inc.
X                    675 Mass Ave, Cambridge, MA 02139, USA
X Everyone is permitted to copy and distribute verbatim copies
X of this license document, but changing it is not allowed.
X
X			    Preamble
X
X  The license agreements of most software companies try to keep users
at the mercy of those companies.  By contrast, our General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  The
General Public License applies to the Free Software Foundation's
software and to any other program whose authors commit to using it.
You can use it for your programs, too.
X
X  When we speak of free software, we are referring to freedom, not
price.  Specifically, the General Public License is designed to make
sure that you have the freedom to give away or sell copies of free
software, that you receive source code or can get it if you want it,
that you can change the software or use pieces of it in new free
programs; and that you know you can do these things.
X
X  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.
X
X  For example, if you distribute copies of a such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.
X
X  We protect your rights with two steps: (1) copyright the software, and
X(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.
X
X  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.
X
X  The precise terms and conditions for copying, distribution and
modification follow.
X
X		    GNU GENERAL PUBLIC LICENSE
X   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
X
X  0. This License Agreement applies to any program or other work which
contains a notice placed by the copyright holder saying it may be
distributed under the terms of this General Public License.  The
X"Program", below, refers to any such program or work, and a "work based
on the Program" means either the Program or any work containing the
Program or a portion of it, either verbatim or with modifications.  Each
licensee is addressed as "you".
X
X  1. You may copy and distribute verbatim copies of the Program's source
code as you receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice and
disclaimer of warranty; keep intact all the notices that refer to this
General Public License and to the absence of any warranty; and give any
other recipients of the Program a copy of this General Public License
along with the Program.  You may charge a fee for the physical act of
transferring a copy.
X
X  2. You may modify your copy or copies of the Program or any portion of
it, and copy and distribute such modifications under the terms of Paragraph
X1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating that
X    you changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish, that
X    in whole or in part contains the Program or any part thereof, either
X    with or without modifications, to be licensed at no charge to all
X    third parties under the terms of this General Public License (except
X    that you may choose to grant warranty protection to some or all
X    third parties, at your option).
X
X    c) If the modified program normally reads commands interactively when
X    run, you must cause it, when started running for such interactive use
X    in the simplest and most usual way, to print or display an
X    announcement including an appropriate copyright notice and a notice
X    that there is no warranty (or else, saying that you provide a
X    warranty) and that users may redistribute the program under these
X    conditions, and telling the user how to view a copy of this General
X    Public License.
X
X    d) You may charge a fee for the physical act of transferring a
X    copy, and you may at your option offer warranty protection in
X    exchange for a fee.
X
Mere aggregation of another independent work with the Program (or its
derivative) on a volume of a storage or distribution medium does not bring
the other work under the scope of these terms.
X
X  3. You may copy and distribute the Program (or a portion or derivative of
it, under Paragraph 2) in object code or executable form under the terms of
Paragraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    b) accompany it with a written offer, valid for at least three
X    years, to give any third party free (except for a nominal charge
X    for the cost of distribution) a complete machine-readable copy of the
X    corresponding source code, to be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    c) accompany it with the information you received as to where the
X    corresponding source code may be obtained.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form alone.)
X
Source code for a work means the preferred form of the work for making
modifications to it.  For an executable file, complete source code means
all the source code for all modules it contains; but, as a special
exception, it need not include source code for modules which are standard
libraries that accompany the operating system on which the executable
file runs, or for standard header files or definitions files that
accompany that operating system.
X
X  4. You may not copy, modify, sublicense, distribute or transfer the
Program except as expressly provided under this General Public License.
Any attempt otherwise to copy, modify, sublicense, distribute or transfer
the Program is void, and will automatically terminate your rights to use
the Program under this License.  However, parties who have received
copies, or rights to use copies, from you under this General Public
License will not have their licenses terminated so long as such parties
remain in full compliance.
X
X  5. By copying, distributing or modifying the Program (or any work based
on the Program) you indicate your acceptance of this license to do so,
and all its terms and conditions.
X
X  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the original
licensor to copy, distribute or modify the Program subject to these
terms and conditions.  You may not impose any further restrictions on the
recipients' exercise of the rights granted herein.
X
X  7. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.
X
XEach version is given a distinguishing version number.  If the Program
specifies a version number of the license which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
the license, you may choose any version ever published by the Free Software
XFoundation.
X
X  8. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.
X
X			    NO WARRANTY
X
X  9. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
XFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.
X
X  10. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.
X
X		     END OF TERMS AND CONDITIONS
X
X	Appendix: How to Apply These Terms to Your New Programs
X
X  If you develop a new program, and you want it to be of the greatest
possible use to humanity, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.
X
X  To do so, attach the following notices to the program.  It is safest to
attach them to the start of each source file to most effectively convey
the exclusion of warranty; and each file should have at least the
X"copyright" line and a pointer to where the full notice is found.
X
X    <one line to give the program's name and a brief idea of what it does.>
X    Copyright (C) 19yy  <name of author>
X
X    This program is free software; you can redistribute it and/or modify
X    it under the terms of the GNU General Public License as published by
X    the Free Software Foundation; either version 1, or (at your option)
X    any later version.
X
X    This program is distributed in the hope that it will be useful,
X    but WITHOUT ANY WARRANTY; without even the implied warranty of
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X    GNU General Public License for more details.
X
X    You should have received a copy of the GNU General Public License
X    along with this program; if not, write to the Free Software
X    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Also add information on how to contact you by electronic and paper mail.
X
If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:
X
X    Gnomovision version 69, Copyright (C) 19xx name of author
X    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
X    This is free software, and you are welcome to redistribute it
X    under certain conditions; type `show c' for details.
X
The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.
X
You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here a sample; alter the names:
X
X  Yoyodyne, Inc., hereby disclaims all copyright interest in the
X  program `Gnomovision' (a program to direct compilers to make passes
X  at assemblers) written by James Hacker.
X
X  <signature of Ty Coon>, 1 April 1989
X  Ty Coon, President of Vice
X
That's all there is to it!
END_OF_FILE
if test 12488 -ne `wc -c <'COPYING'`; then
    echo shar: \"'COPYING'\" unpacked with wrong size!
fi
# end of 'COPYING'
fi
if test -f 'compiler/Cellang.tex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'compiler/Cellang.tex'\"
else
echo shar: Extracting \"'compiler/Cellang.tex'\" \(21705 characters\)
sed "s/^X//" >'compiler/Cellang.tex' <<'END_OF_FILE'
X%  Cellang.tex
X%  Copyright (C) 1992  J Dana Eckart
X%
X%  This program is free software; you can redistribute it and/or modify
X%  it under the terms of the GNU General Public License as published by
X%  the Free Software Foundation; either version 1, or (at your option)
X%  any later version.
X%
X%  This program is distributed in the hope that it will be useful,
X%  but WITHOUT ANY WARRANTY; without even the implied warranty of
X%  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X%  GNU General Public License for more details.
X%
X%  You should have received a copy of the GNU General Public License
X%  along with CELLULAR-2.0; see the file COPYING.  If not, write to the 
X%  Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X\documentstyle[twocolumn]{article}
X
X% Setup the desired page style.
X\pagestyle{plain}
X\setlength{\textwidth}{6.5in}
X\setlength{\textheight}{8.75in}
X\setlength{\oddsidemargin}{0mm}
X\setlength{\evensidemargin}{0mm}
X\setlength{\topmargin}{0mm}
X\setlength{\headheight}{0mm}
X\setlength{\headsep}{0mm}
X
X\setlength{\columnsep}{5mm}
X
X% Setup the desired paragraph style.
X\setlength{\parindent}{0mm}
X\setlength{\parskip}{3mm}
X\begin{document}
X
X% A new command to define a constant tabbing distance for code examples.
X\newcommand{\tab}{\hspace{5mm}}
X
X\title{Cellang 2.0: Language Reference Manual}
X\author{J Dana Eckart\\
X 	Radford University}
X\date{13 April 1992}
X\maketitle
X
X
X\section{Introduction}
The Cellang programming language is a special purpose
programming language for the programming of a wide variety of cellular
automata.  The language is quite small and simple.  During
its design, care was taken to create a language that would be expressive
enough to allow a wide variety of cellular automata to be written
while restricting the possible programs to those considered truly cellular
in nature.
Cellang is intended both as an aid in introducing university students to
the wonderful world of cellular automata as well as a common language in
which to describe such systems for both teaching and research purposes.
X
This reference manual specifies the form and meaning of Cellang programs.  
Its purpose is to ensure the portability of Cellang programs.  Thus
the set of accepted programs and the set of rejected programs should
be identical for all Cellang compilers.
XFurthermore, the proper execution of an accepted program should produce 
the same result regardless of the compiler used.
X
X\subsection{Language Summary}
Cellang programs are composed of comments, statements and a
cell declaration.  The cell declaration indicates the number of dimensions
of the automata, the number of field values
contained within each cell of the automata, and the range of values
associated with each field.  The cell declaration
must appear before any statements are given.
Statements are either selections
or assignments and provide the only mechanism whereby cells can change
state.
Variables are implicitly declared at the point of first assignment and
correspond to either a complete set of field values associated with a cell
or to the only builtin data type, integer.  
X
X\subsection{Syntax Notation}
A variant of Backus--Naur--Form is used to describe the form of Cellang 
programs.  Narrative rules describe both the effects of each 
construct and the composition rules for constructs.
The particular variations of Backus--Naur--Form used are:
X\begin{enumerate}
X\item
Lower case words, possibly containing underscores, are used to denote
syntactic categories.
Whenever the name of a syntactic category is used apart from the syntax rules
themselves, spaces take the place of the underscores.
X
X\item
Boldface is used to denote reserved keywords.
X
X\item
Alternatives are separated by right arrows ($\rightarrow$).
X
X\item
Curly braces enclose items that may appear zero or more times.
X
X\end{enumerate}
X
X\section{Lexical Elements}
Programs are represented by collections of lexical elements.  Lexical
elements are one of: comments, reserved keywords, identifiers, 
operators, separators or numeric literals.  Lexical elements, in turn, are
collections of ASCII (American Standard Code for Information Interchange)
characters.
X
X\subsection{Comments}
A comment starts with a sharp (\#) and extends to the end of the line.
A comment can appear anywhere within a program.  The presence or absence
of comments has no influence on whether a program is legal or illegal.
XFurthermore, comments do not influence the effect of a program.
Any character
may appear within a comment, except of course any character denoting the
end of a line.
X
X\subsection{Reserved Keywords}
XFor readability of this manual, the reserved keywords appear in lower 
case boldface.  The reserved keywords are:
X\begin{center}
X\begin{tabular}{lll}
X{\bf dimensions}& {\bf elsif}	& {\bf otherwise } \\
X{\bf end} 	& {\bf if}	& {\bf then} \\
X{\bf else}	& {\bf of}	& {\bf when} \\
X\end{tabular}
X\end{center}
The case of the alphabetic characters that form a reserved keyword is
ignored, thus {\tt ELsE} and {\tt eLSe} both represent the keyword {\bf else}.
X
X\subsection{Identifiers}
Identifiers are used as names.  Identifiers must consist of at least
one character, but are otherwise unlimited in length.  
X\begin{center}
X\begin{tabbing}
underscore\_option \=$\rightarrow$ \kill
X
identifier 		\>$\rightarrow$ letter \{ \= underscore\_option \\
X			\>\>letter\_or\_digit \}\\
X \\
underscore\_option 	\>$\rightarrow$ underscore \\
X			\>$\rightarrow$ $\lambda$\\
X\end{tabbing}
X\end{center}
Any identifier constructed from the above rules are legal except when it 
also names
a reserved keyword.  In this case the lexical element is a reserved
keyword.  All characters of an identifier are significant, including 
any underscore characters; however, as with reserved keywords,
the case of the alphabetic characters that form an identifier are ignored.
All non-reserved identifiers represent variables.  There are two predefined
identifiers: {\tt cell} and {\tt time}.
While {\tt time} can only be used within expressions (i.e. not assigned),
X{\tt cell} can be used within expressions as well as assigned new values
and refers to the cell with relative
index {\tt [0, ..., 0]}.  The first lexical appearance of an 
identifier, on the left hand side of an assignment statement,
implicitly declares it as a variable.
X
X\subsection{Operators and Separators}
The simple (one character) operators are:
X\begin{center}
X* \ / \ + \  -- \ \% \ = \ $<$ \ $>$ \ \& \ $|$ \ !\\
X\end{center}
and the compound (two character) operators are:
X\begin{center}
X$<=$ \ \ $>=$ \ \ $!=$ \\
X\end{center}
X
In some cases an explicit separator is required to separate adjacent
lexical elements (namely, when without separation, interpretation as a single
lexical element is possible).  A separator is any of:
X\begin{center}
X[ \ ] \ , \ . \ := \ ..\\
X\end{center}
Space characters, format effectors, and the end of a line are also
separators.  A space character is a separator
except within a comment.
XFormat effectors other than horizontal tabulation are always separators.
Horizontal tabulation is a separator except within a comment.
One or more separators are allowed before, after or between lexical elements.
X
The end of a line is always a separator.  The language does not define
what causes the end of a line.  However if, for a given implementation,
the end of a line is signified by one or more characters, then these
characters must be format effectors.
X
X\subsection{Numeric Literals}
A numeric literal is expressed in the conventional integer decimal notation.
Underlines are ignored in determining the value of the numeric literal, thus
they can be used to increase readability.
X\begin{center}
numeric\_literal $\rightarrow$ digit \{ underscore\_option digit \}\\
X\end{center}
X
X\section{Syntax and Semantics}
The lexical elements of the previous section are combined in accordance
with the rules given in this section to form correct programs.  The
semantics of these programs are also described.  Examples are used to
clarify rules that might otherwise be confusing.
X
X\subsection{Cell Declaration}
The cell declaration
X describes the entire set of cells that make up the cellular automata.
The declaration must appear only once in the program, and must precede
any statements.
X\begin{center}
X\begin{tabbing}
cell\_declaration \=$\rightarrow$ \= \tab \=\kill
X
cell\_declaration \>$\rightarrow$ numeric\_literal {\bf dimensions } {\bf of} \\
X		\>\>\>field\_list\\
X \\
field\_list     \>$\rightarrow$ range\\
X	        \>$\rightarrow$ field \{ field \} {\bf end}\\
X \\
field		\>$\rightarrow$ ident\_list {\bf of} range\\
X \\
range 		\>$\rightarrow$ integer .. integer\\
X \\
ident\_list 	\>$\rightarrow$ identifier \{ , identifier \} \\
X \\
integer		\>$\rightarrow$ sign numeric\_literal\\
X \\
sign		\>$\rightarrow$ +\\
X	        \>$\rightarrow$ --\\
X	        \>$\rightarrow$ $\lambda$\\
X
X\end{tabbing}
X\end{center}
The numeric literal appearing before {\bf dimensions} specifies the
number of dimensions, in a discrete cartesian space, to be used in 
computations.  The maximum number of dimensions allowed, and the size of
each, is determined by the implementation.  The field list gives a
description of the information associated with each cell of the automata.
If only a single field is given, then no field name (identifier) is needed.
When more than one field is used, then each field is represented by an
identifier and associated range.  An ident list allows a number of
identifers to be associated with a single range.
X
A range defines an inclusive set of integer values.  The
first is the lower bound and must be less than or equal to the second 
which is the upper bound of the range.  A range indicates the permissible
values that a field can be assigned.  It is an error to assign 
a field a value outside of its associated range.  The maximal size and allowed
bounds of a range are determined by the implementation.
X
XExamples:
X\begin{center}
X\begin{tabbing}
X\tab \= \tab \= \tab \= \tab \= \tab \=\kill
X\>2 {\bf dimensions} {\bf of} 0..255\\
X \\
X\>3 {\bf dimensions} {\bf of}\\
X\>\>x, y {\bf of} --9..9\\
X\>\>distance {\bf of} 0..999\\
X\>{\bf end}\\
X\end{tabbing}
X\end{center}
X
X\subsection{Expressions}
An expression is a formula that defines a computation.
X\begin{center}
X\begin{tabbing}
field\_reference \=$\rightarrow$ \tab \= \kill
X
expression \>$\rightarrow$ expression\\
X				\>\>\{ binary\_op expression \}\\
X           \>$\rightarrow$ unary\_op expression\\
X           \>$\rightarrow$ ( expression )\\
X           \>$\rightarrow$ primary\\
X \\
unary\_op  \>$\rightarrow$ +\\
X           \>$\rightarrow$ --\\
X \\
binary\_op \>$\rightarrow$ +\\
X           \>$\rightarrow$ --\\
X           \>$\rightarrow$ * \\
X           \>$\rightarrow$ / \\
X           \>$\rightarrow$ \% \\
X           \>$\rightarrow$ \& \\
X           \>$\rightarrow$ $|$ \\
X           \>$\rightarrow$ ! \\
X           \>$\rightarrow$ = \\
X           \>$\rightarrow$ $<$ \\
X           \>$\rightarrow$ $>$ \\
X           \>$\rightarrow$ $<=$ \\
X           \>$\rightarrow$ $>=$ \\
X           \>$\rightarrow$ != \\
X \\
primary    \>$\rightarrow$ numeric\_literal\\
X           \>$\rightarrow$ identifier field\_reference\\
X           \>$\rightarrow$ [ index \{ , index \} ] field\_reference\\
X \\
field\_reference \>$\rightarrow$ . identifier \\
X           \>$\rightarrow$ $\lambda$\\
X \\
index      \>$\rightarrow$ integer\\
X\end{tabbing}
X\end{center}
The predefined identifier {\tt time} evaluates to
the current step of the execution.  The initial value of {\tt time} is
zero (0), and is increased by one (1) each time all of the cells in the
automata have been updated.
The predefined identifier {\tt cell} yields the value of the current
cell, which is also the value of {\tt [0, ..., 0]}
X
There are 6 levels of precedence for the unary and binary operators.
Operators belonging to the same level are evaluated from
left to right.  The precedence levels, from highest to lowest are:
X\begin{center}
X\begin{enumerate}
X\item
X(unary) + \ --
X\item
X* \ / \ \% (remainder)
X\item
X(binary) + \ --
X\item
X= \ $<$ \ $>$ \ $!=$ \ $<=$ \ $>=$
X\item
X\& (logical and) \ $|$ (logical or)
X\item
X! (logical negation)
X\end{enumerate}
X\end{center}
The relational and logical operations return integer values, with a zero value
being returned when the condition is false and a non--zero value when the
condition is true.  Note, however, that no assumption can be made about the
non--zero value returned.  In particular, the non--zero values
can be different for each evaluation of the same condition.  If no fields,
of a multi--field value,
are specified then only the equal (=) and not equal (!=) operations are
applicable.  In this case, all the fields are used in the comparison.
X
When referencing a neighboring cell (using an index list contained within
X[ \ ]), the number of indices given must match exactly the number of dimensions
indicated by the cell declaration.  
Such a reference is taken relative to
the current cell of computation.  Since it is possible that adding the index 
to the current cell location might give an index value outside the range of
that dimension, ``wrap around'' is used to insure that the reference is
a legal one.  Thus neighboring cell references can ``wrap around'' the edge
of the cells of the automata.  
XFurthermore, each relative indice must
have an absolute value no larger than the size of the corresponding dimension
X(as determined by the implemenatation). 
The optional field reference should only be
used if a named field was declared in the cell declaration.  The field
reference indicates which field value to use.
X
X\subsection{Statements}
A statement defines an action to be performed; the process by which
a statement achieves its action is called execution of the statement.
Cellang programs may contain any number of statements.
X\begin{center}
X\begin{tabbing}
statement                \=$\rightarrow$ \kill
X
statement                \>$\rightarrow$ assignment\_statement \\
X                         \>$\rightarrow$ if\_statement \\
X\end{tabbing}
X\end{center}
All of the statements in a Cellang program are performed for each cell,
once during each {\bf time} value.  Programs whose behavior depends on
the relative order of statement execution between cells of the automata
are erroneous.
X
X\subsubsection{Assignment Statement}
An assignment statement permits the value of the variable on the
left hand side of the first := to be set or changed.
X\begin{center}
X\begin{tabbing}
assignment\_statement \=$\rightarrow$ \= \tab \= \tab \=\kill
X
assignment\_statement 	\>$\rightarrow$ identifier field\_reference \\
X			\>\>\>:= expression \\
X			\>\>\>\>rest\_expression \\
X \\
rest\_expression 	\>$\rightarrow$ rest\_when \\
X                 	\>$\rightarrow$ $\lambda$\\
X \\
rest\_when              \>$\rightarrow$ {\bf when} expression \\
X			\>\>\>:= expression \\
X			\>\>\>\>rest\_when \\
X                        \>$\rightarrow$ {\bf when} expression \\
X		 	\>$\rightarrow$ {\bf otherwise} \\
X\end{tabbing}
X\end{center}
If no field reference is given and if the identifier has
not previously appeared on the left hand side of an assignment statement,
then the identifier is implicitly declared as a variable.  The variable
is (statically) declared as either a single or multiple field variable 
depending upon the value of the provided expression(s).  This implies that
the expressions of the assignment statement must be either all single field
or all multi--field expressions.  The range of values that can be assigned
to the field(s) of a variable is determined by the implementation, but must
be at least as large as the union of all field ranges given in the 
cell declaration.  Programs which assign the field(s) of variable values 
outside of its associated range are erroneous, though compilers are not
required to generate run--time checks to detect such occurrences.
X
If a single expression (or a single expression followed by {\bf otherwise} )
appears to the right of the := then that expression
is assigned to the entity on the left hand side of the :=.  In the case that
one or more {\bf when} clauses appear then the expression to the right
of {\bf when} is evaluated first, if it is non--zero the value of the expression
to the left of {\bf when} is assigned and execution of the assignment statement
is complete.  In the case that the expression to the right of {\bf when}
evaluates to zero, then successive {\bf when} clauses are tried in order.  
If all
expressions to the right of {\bf when} in all such clauses yield a zero value
and if an expression to the left of {\bf otherwise} appears, its value
is assigned.  If none of the {\bf when} conditions yield a non--zero value
and if no {\bf otherwise} appears, then the value is unchanged.
X
Assigning a value to {\tt cell} causes the value of the current cell to
become that value.  This is the only way that the value of cells
of the automata can be altered.  Note, however, that that assignment(s) to
X{\tt cell} determine the value that the current cell will have beginning with
the next {\bf time} value.  Thus an assignment to {\tt cell} will NOT alter the
value that {\tt cell} yields in an expression, for computations performed
during the same {\bf time} value.  The variable {\tt cell} is the only variable
that expresses this dual nature of present versus future value.
X
If fields were declared for the cells of the automata, and if no field
reference was specified for a multi--field value, then all of the fields 
are assigned.
X
XExamples:
X\begin{center}
X\begin{tabbing}
X\tab\=maybe \=:= \kill
X\>value \>:= max\_value -- 1\\
X \\
X\>shade \>:= blue {\bf otherwise}\\
X \\
X\>cell 	\>:= blue {\bf when} time = 0\\
X	\>\>:= orange {\bf otherwise}\\
X \\
X\>maybe \>:= 1 {\bf when} random = x\\
X	\>\>:= 2 {\bf when} random = y\\
X \\
X\>max	\>:= north\\
X\>max	\>:= south when south $>$ max\\
X\>max	\>:= east when east $>$ max\\
X\end{tabbing}
X\end{center}
X
X\subsubsection{If Statements}
An if statement selects for execution one or none of the enclosed
statement lists, depending on the value of one or more conditions.
X\begin{center}
X\begin{tabbing}
if\_statement \=$\rightarrow$ \= \tab \=\kill
X
if\_statement 	\>$\rightarrow$ {\bf if} expression {\bf then}\\
X	      	\>\>\>statement\_list\\
X	      	\>\>\{ {\bf elsif} expression {\bf then}\\
X	      	\>\>\>statement\_list \}\\
X	      	\>\>else\_option\\
X	      	\>\>{\bf end} \\
X \\
else\_option  	\>$\rightarrow$ {\bf else} statement\_list \\
X		\>$\rightarrow$ $\lambda$\\
X\end{tabbing}
X\end{center}
XFor the execution of an if statement, the condition specified after {\bf if},
and any conditions specified after {\bf elsif}, are evaluated in succession
X(treating a final ``{\bf else}'' as ``{\bf elsif} non--zero {\bf then}''), 
until one
evaluates to a non--zero value or all conditions are evaluated and yield 
zero values.  If
a condition evaluates to non--zero, then the corresponding statement
list is executed; otherwise none of the statement lists are executed.
X
XExample:
X\begin{center}
X\begin{tabbing}
X\tab \= \tab \= \tab \= \tab \= \tab \=\kill
X
X\>{\bf if} neigbor\_count = 4 {\bf then}\\
X\>\>cell := 0\\
X\>{\bf elsif} neigbor\_count = 3 {\bf then}\\
X\>\>cell := 1\\
X\>\>count := count + 1\\
X\>{\bf else}\\
X\>\>cell := 0\\
X\>{\bf end}\\
X\end{tabbing}
X\end{center}
X
X\section{Input and Output}
The form of the input and output for Cellang programs is identical.
X\begin{center}
X\begin{tabbing}
time\_block	\=$\rightarrow$ \= \tab \=\kill
X
i/o\_form 	\>$\rightarrow$ \{ time\_block \}\\
X \\
time\_block	\> $\rightarrow$ time \{ cell\_value \}\\
X \\
cell\_value  	\>$\rightarrow$ [ integer \{ , integer \} ] = value\_list\\
X \\
value\_list	\>$\rightarrow$ field\_value \{ , field\_value \}\\
X \\
field\_value 	\>$\rightarrow$ integer \\
X		\>$\rightarrow$ $\lambda$\\
X \\
time  		\>$\rightarrow$ numeric\_literal \\
X\end{tabbing}
X\end{center}
The time must be a non--negative number, which should be strictly larger
than any previous time that has appeared in the input (for input) or
output (for output).  The cell value is an absolute reference to a cell
within the cells of the automata\footnote{
X		The absolute index values for a dimension always
X		begin at zero (0) and extend in the positive direction.
X	}
with the field values of the indicated cell taken as the respective numeric
literal values given by the value list.  These are associated with the fields in
the same order as the field identifiers were given in the cell declaration.
The number of numeric literals in the value list must be no greater than the 
number of fields given in the cell declaration.
X
As input, the cell values appearing after a time (and before the next time)
give the new field values
for all of the indicated cells; beginning at the specified time.
The field values of
all cells at time zero (0) is zero (0) unless otherwise specified.  No
cells other than those specified by a cell value
have their values altered and only those fields specified (indicated by
supplying an integer value) are assigned new values.
X
In the output, cell values appearing after a specific time indicate the 
field value of cells at the beginning of that time.  The field value(s)
given are the field value(s) of the cell at that time.  As with the 
input, the initial
value of all cells of the automata zero (0) unless otherwise indicated.
X
Unlike the syntax for programs, the syntax of the input
X(output) must also be given (appear) in a line oriented fashion.  In
particular the time and cell value information must each reside on a
single line of input (output) with no intervening blank lines.\footnote{
X		This syntactic restriction makes the 
X		construction of filter programs easier.
X	}
X
X\end{document}
END_OF_FILE
if test 21705 -ne `wc -c <'compiler/Cellang.tex'`; then
    echo shar: \"'compiler/Cellang.tex'\" unpacked with wrong size!
fi
# end of 'compiler/Cellang.tex'
fi
if test -f 'compiler/scanner.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'compiler/scanner.c'\"
else
echo shar: Extracting \"'compiler/scanner.c'\" \(6838 characters\)
sed "s/^X//" >'compiler/scanner.c' <<'END_OF_FILE'
X/* scanner.c
X   Copyright (C) 1992  J Dana Eckart
X  
X   This program is free software; you can redistribute it and/or modify
X   it under the terms of the GNU General Public License as published by
X   the Free Software Foundation; either version 1, or (at your option)
X   any later version.
X  
X   This program is distributed in the hope that it will be useful,
X   but WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X   GNU General Public License for more details.
X  
X   You should have received a copy of the GNU General Public License
X   along with CELLULAR-2.0; see the file COPYING.  If not, write to the 
X   Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X*/
X
X/* This is a hand coded scanner for cellang. */
X
X#include <stdio.h>
X#include "scanner.h"
X#include "error.h"
X#include "io.h"
X
X#define MAX_TOKEN_LENGTH 	256 	/* Maximum size of any token. */
X
char yytext[MAX_TOKEN_LENGTH];		/* Saved text of a token. */
int yyleng;				/* Length of the saved text. */
X
int c;
X
boolean save_c = false;	/* True iff a character should be reused. */
X
int linenumber; 	/* Current line number in the input stream. */
X
boolean scan_error;	/* True iff a scanning error was encountered. */
X
boolean one_error;	/* Used to limit one scanner error notice per token. */
X
X/* Performs the initialization to begin scanning a new file. */
void startscan() {
X	linenumber = 1;
X	c = ' ';
X	fprintf(file_c, "\n#line %d\n", linenumber);
X}
X
X/* Gets the next character.  Responsible for updating "linenumber". */
int get_char() {
X	if (!save_c) {
X		if (c == '\n') {
X			linenumber++;
X			fprintf(file_c, "\n#line %d\n", linenumber);
X		}
X		c = getc(stdin);
X	}
X	else save_c = false;
X	return (c);
X}
X
X/* Prints out the prefix that appears before all compiler generated
X   error messages.  The form of the prefix is:
X		"line line_number: "
X   where line_number is replaced with the appropriate information.
X*/
void error_prefix() {
X	fprintf(stderr, "line %d: ", linenumber);
X}
X
X/* Takes a string format and a string with which to build an
X   error message.  The message is automatically prepended with
X   the current linenumber.
X*/
void lex_error(format, string) char *format, *string; {
X	if (one_error) return;
X	one_error = true;
X	scan_error = true;
X	error_prefix();
X	fprintf(stderr, format, string);
X	fprintf(stderr, "\n");
X}
X
X/* Saves the character c in yytext.  Checks to insure that the maximum
X   token length has not been exceeded.
X*/
void save(c) char c; {
X	if (yyleng == 256 && !one_error) {
X		one_error = true;
X		yytext[yyleng] = '\0';
X		lex_error("Token '%s' is too long", yytext);
X	}
X	else yytext[yyleng++] = c;
X}
X
X/* Recognizes comments: #[^#"\n"]"\n"
X   No text is saved.
X*/
void comment() {
X	c = get_char();
X	while (c != '\n') c = get_char();
X}
X
X/* Skips comments, blanks, tabs and new lines. */
void skip_white_space() {
X	while (c >= 0) {
X		if (c == '#') comment();
X		else if (c <= 32 || c == 127) c = get_char();
X		else break;
X	}
X}
X
X/* Recognizes numeric literals: [0-9]+(_[0-9]+)* 
X   Underscores are stripped out.
X*/
void integer() {
X	boolean error;
X	error = false;
X	while ('0' <= c && c <= '9') {
X		save(c);
X		c = get_char();
X		if (c == '_') {
X			c = get_char();
X			if (c < '0' || '9' > c) error = true;
X		}
X	}
X	save_c = true;
X	yytext[yyleng] = '\0';
X	if (error) lex_error("Illegal underscore in '%s'", yytext);
X}
X
X
X/* Recognizes identifiers (and keywords): [A-Za-z][A-Za-z0-9]*(_[A-Za-z0-9]+)*
X   Identifiers (and keywords) are converted to lower case.
X*/
void identifier() {
X	boolean error;
X	error = false;
X	while (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') ||
X	       ('0' <= c && c <= '9')) {
X		if ('A' <= c && c <= 'Z') c = 'a' + (c - 'A');
X		save(c);
X		c = get_char();
X		if (c == '_') {
X			save(c);
X			c = get_char();
X			if (c == '_') error = true;
X		}
X	}
X	save_c = true;
X	yytext[yyleng] = '\0';
X	if (error) lex_error("Illegal underscore in '%s'", yytext);
X}
X
X/* The record "string_number" associates a reserved word with its token
X   number.  The "table" is a collection of these associations.  The 
X   function "lookup" uses the table to determine whether or not yytext
X   contains a reserved word.  If it does it's token number is returned,
X   else the token number of an identifier is returned.
X*/
X
typedef struct {
X	char *string;
X	int number;
X} string_number;
X
X#define MAX_TABLE 9
X
static string_number table[MAX_TABLE] = {
X	{"dimensions", DIMENSIONS},
X	{"else", ELSE},
X	{"elsif", ELSIF},
X	{"end", END},
X	{"if", IF},
X	{"of", OF},
X	{"otherwise", OTHERWISE},
X	{"then", THEN},
X	{"when", WHEN}
X};
X
X#include <strings.h>
X
X/* Performs a binary search to determine if the identifier is a
X   reserved word.
X*/
int lookup() {
X	int upper, middle, lower;
X	upper = MAX_TABLE - 1;
X	lower = 0;
X	while (lower <= upper) {
X		int cmp;
X		middle = (upper + lower) / 2;
X		cmp = strcmp(yytext, table[middle].string);
X		if (cmp < 0) upper = middle - 1;
X		else if (cmp > 0) lower = middle + 1;
X		else return table[middle].number;
X	}
X	return IDENTIFIER;
X}
X
X/* This is the procedure called by the parser generated by bison.  It
X   returns integer token numbers that depend upon the token read.  
X   White space that occurs between tokens is always skipped.  A legal
X   token is always returned, even if several errors occur while scan-
X   ning such a token. 
X*/
int yylex() {
X	while (1) {	/* Search until you find something. */
X		yyleng = 0;
X		one_error = false;
X		c = get_char();
X		skip_white_space();
X		if (c < 0) return(c);
X		else if ('0' <= c && c <= '9') {
X			integer();
X			return(NUMERICLITERAL);
X		}
X		else if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {
X			identifier();
X			return(lookup());
X		}
X		else switch(c) {
X		case '+':	return(PLUS);
X		case '-':	return(MINUS);
X		case '*':	return(TIMES);
X		case '/':	return(DIVIDE);
X		case '%':	return(MOD);
X		case '&':	return(AND);
X		case '|':	return(OR);
X		case '!':	c = get_char();
X				if (c == '=') return(NOTEQ);
X				else {
X					save_c = true;
X					return(NOT);
X				}
X		case '=':	return(EQUAL);
X		case '<':	c = get_char();
X				if (c == '=') return(LESSEQ);
X				else {
X					save_c = true;
X					return(LESSER);
X				}
X		case '>':	c = get_char();
X				if (c == '=') return(GREATEQ);
X				else {
X					save_c = true;
X					return(GREATER);
X				}
X		case '(':	return(LEFTPAREN);
X		case ')':	return(RIGHTPAREN);
X		case '[':	return(LEFTBRACKET);
X		case ']':	return(RIGHTBRACKET);
X		case ':':	save(c);
X				c = get_char();
X				if (c == '=') return(ASSIGN);
X				else {
X					save_c = true;
X					yytext[yyleng] = '\0';
X					lex_error("Illegal use of '%s'", 
X						  yytext);
X				}
X		case ',':	return(COMMA);
X		case '.':	c = get_char();
X				if (c == '.') return(DOTS);
X				else {
X					save_c = true;
X					return(DOT);
X				}
X		default:	save(c);
X				yytext[yyleng] = '\0';
X				lex_error("Illegal use of '%s'", yytext);
X		}
X	}
X}
END_OF_FILE
if test 6838 -ne `wc -c <'compiler/scanner.c'`; then
    echo shar: \"'compiler/scanner.c'\" unpacked with wrong size!
fi
# end of 'compiler/scanner.c'
fi
if test -f 'driver/pe-scam.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'driver/pe-scam.man'\"
else
echo shar: Extracting \"'driver/pe-scam.man'\" \(7186 characters\)
sed "s/^X//" >'driver/pe-scam.man' <<'END_OF_FILE'
X.TH pe-scam 1
X.SH NAME
pe-scam \- 
X.I "Cellang 2.0"
X(cellular automata) machine driver
X.SH SYNOPSIS
X.B pe-scam
X[
X.B \-r " timefile"
X] 
X[
X.B \-c " codefile"
X]
X(
X.B \-o
X|
X[
X.B \-curses
X|
X.B \-x11
X[
X.BI \-display " connection"
X]
X]
X[
X.BI \-p " n"
X]
X[
X.BI \-s " (n|n,n)"
X]
X[
X.BI \-map " file"
X]
X[
X.BI \-f " n"
X]
X[
X.BI \-dim " (n|n..n){,n|,n..n}"
X]
X)
X.SH DESCRIPTION
X.I pe-scam
is the driver which controls the pe-scam architecture for running cellular
automata programs.  It can either display the results of the run in the
same fashion as
X.I cellview
or it can place the cell values on the standard output (
X.B \-o
X).  In either case, the input to the automata is taken from standard input.
X.TP
X.B \-c " codefile"
Specifies the program to run, where
X.B codefile
contains the pe-scam object code for some Cellang 2.0 program.  The default
file to use is 
X.I a.pe-scam.
X.TP
X.B \-r " timefile"
Indicates when cell values should be reported/sampled.
A 
X.B timefile 
is a list of time indications given one per line.  A number indicates a
time when the values should be
reported.  If a ``+'' appears before the number, this causes values to be 
produced at the indicated time intervals.  If a ``!'' appearing after
the number, this indicates the time at which the last set of values should 
be produced and the simulation stops.
Note that a 
X.B timefile 
need not contain a ``!'' entry.
X.TP
X.B \-o
Place the cell values on the standard output rather than viewing them.  The
default is to view them in the manner of
X.I cellview
X.
X.TP
X.B \-curses
View the output in character mode.  This makes it possible to view the
output of Cellang programs on most ordinary terminals.  The
X.B \-x11
option is more desirable, however, when working on a graphics terminal
or workstation.  This option is the default.  To quit, you must kill the
process (probably ^C).
X.TP
X.B \-x11
View the output in the X-Windows windowing environment.  A window is opened
and the output shown using colors rather than characters (see the
X.B \-curses
option).  This is the preferred way to examine the output of Cellang programs.
The following key stroke commands are available:
X.bf
X.nf
X
X       q or Q to quit
X       s or S to stop (temporarily)
X       c or C to continue (from a stop)
X       n or N to toggle neighborhood window display
X
X.fi
Within the focus of the neighborhood window, typing a single digit will
change the size of the displayed neighborhood.  The values shown in the
neighborhood window are those centered about the chosen cursor location
inside the main viewing window.  Cursor locations are chosen by clicking
any of the mouse points when the cursor is positioned at the desired point.
The initial cursor location is taken to be the center of the viewing area.
Note that whenever a value is too large to be shown, hyphens
are displayed instead of the value.
X.TP
X.BI \-display " connection"
Connect to the X server display,
X.IR connection.
X.TP
X.BI \-p " n"
If 
X.I n 
is positive, then this will cause an 
X.I n 
second delay between displaying
the cells of the universe of each time step.  Negative values of 
X.I n 
are ignored.  The default pause time is 0.
X.TP
X.BI \-s " (n|n,n)"
XFor the first option, if
X.I n
is positive, it is taken as the size of each cell (i.e. the number of pixels
used for each side of a displayed cell) when
the results are first displayed; provided that using this value will
allow all of the cells to be displayed.  The second option allows both
the width and height of displayed cells to be specified.  If neither the
width nor the height are, a default value of 1 is used.
X.TP
X.BI \-map " file"
Uses the map contained in 
X.I file 
when displaying cell values.  Entries in the 
X.I file 
appear one per line, with the first entry being either an
integer value or an increasing range of integer values (e.g. -12..100).
The second entry is either a character (for use with the
X.B \-curses
option) or a color indication
X(for use with the
X.B \-x11
option).  
The color indication is either a triplet of unsigned (positive) 
integers (0..65535) associated with 
the amount of red, green and blue "pigment" to use to represent the color 
or it is a 0 or 1 (representing white and black respectively) when using
monochrome displays.
When giving the character values for use by the
X.B \-curses
option, the character may appear either within single quotes or given
as the decimal ascii code.
Comments about a particular value mapping may appear on the
remainder of the line.
X.TP
X.BI \-f " n"
Indicates which field of the cell values should be used for display.  The
default is to use the first field (
X.BI \-f " 1"
X).
X.TP
X.BI \-dim " (n|n..n){,n|,n..n}"
Indicates which of the dimensions are to be used for viewing as well as
which parts of that dimension to display.  The dimensions must be given
in the order they appear in the input.  A single number indicates a
projection on that dimension, while ranges of the form
X.I n..n
indicate which cells of the specified dimension to display.  The range must be
increasing.
No spaces should appear anywhere within the dimension indicator.
The number of ranges given for display can be zero (0), one (1) or
two (2); but the number of dimensions specified must be the same as those
given in the input.  The default for curses is
X.BI \-dim 0..20,0..20
while the default for x11 is
X.BI \-dim 0..MAX_DIM_SIZE,0..MAX_DIM_SIZE
X.br
X.ne 5
X.SH FILES
file                            file of color/character maps
LIB_DIR/curses-map       default map for curses option
LIB_DIR/color-map        default color map for x11 option
LIB_DIR/bw-map           default black/white map for x11 option
X.SH "SEE ALSO"
cellc(MAN_EXT), cellview(MAN_EXT)
X.br
J Dana Eckart,
X.I "A Cellular Automata Simulation System: Version 2.0"
X(1992)
X.br
J Dana Eckart,
X.I "Cellang 2.0: Language Reference Manual"
X(1992)
X.SH DIAGNOSTICS
The diagnostics produced by cellview are intended to be
self-explanatory.
X.SH BUGS
X.PP
All values, including intermediate values, of the cellular automata
computation are limited to the range 0..255 inclusive.
X.PP
The maximum size of a color/character map is 256 entries.  
X.PP
Key stroke commands (i.e. quitting) should be permitted with the curses 
viewing option.  Unfortunately
this cannot be done since the standard input is already being used for
reading in the cell values.
X.PP
When the
X.B \-curses
option is chosen, the maximum number of cells which can be displayed
is determined by the size of the screen.  The choice of the
X.B \-x11
option however permits the size to be scaled to fit the display, with
the largest cell size limited to 256 pixels square.  Ultimately, both
options should allow the window to be moved over the cells of the
universe so that no such limitations would be present.
X.PP
When using the
X.B \-x11
option, the two first dimensions are displayed by default.  If a different
view is desired, the
X.B \-o
option should be chosen, and its output sent to cellview(MAN_EXT).
X.PP
The maximum size of a neighborhood which can be examined using the neighborhood
sub-window is 9, which encompasses a 19 x 19 region centered about the selected
cell.  In addition, only neighbor values between -999 and 999 can be displayed.
END_OF_FILE
if test 7186 -ne `wc -c <'driver/pe-scam.man'`; then
    echo shar: \"'driver/pe-scam.man'\" unpacked with wrong size!
fi
# end of 'driver/pe-scam.man'
fi
if test -f 'viewer/cellview.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'viewer/cellview.man'\"
else
echo shar: Extracting \"'viewer/cellview.man'\" \(6243 characters\)
sed "s/^X//" >'viewer/cellview.man' <<'END_OF_FILE'
X.TH cellview 1
X.SH NAME
cellview \- cellular automata viewer
X.SH SYNOPSIS
X.B cellview
X[
X.B \-curses
X|
X.B \-x11
X[
X.BI \-display " connection"
X]
X]
X[
X.BI \-p " n"
X]
X[
X.BI \-s " (n|n,n)"
X]
X[
X.BI \-map " file"
X]
X[
X.BI \-f " n"
X]
X.BI \-dim " (n|n..n){,n|,n..n}"
X.SH DESCRIPTION
X.I cellview
is the viewer for looking at the output of Cellang programs.
X.I cellview
uses a map of values to colors (characters when the -curses option is
used) to display one (1) or two (2) dimensions of the output of a Cellang 
program;
even though the output of the Cellang program may contain far more than 
two (2) dimensions.  The input to
X.I cellview
is always taken from standard input.
Upon display, the lower left hand corner of the view corresponds to the
first index in each (if more than one) range of the dimension(s) being 
displayed.
At time zero (0) all cells default to the color/character mapped from the
zero (0) value, except when specified otherwise by the input.  The current
time is displayed in the lower left hand corner.
X.TP
X.B \-curses
View the output in character mode.  This makes it possible to view the
output of Cellang programs on most ordinary terminals.  The
X.B \-x11
option is more desirable, however, when working on a graphics terminal
or workstation.  This option is the default.  To quit, you must kill the
process (probably ^C).
X.TP
X.B \-x11
View the output in the X-Windows windowing environment.  A window is opened
and the output shown using colors rather than characters (see the
X.B \-curses
option).  This is the preferred way to examine the output of Cellang programs.
The following key stroke commands are available:
X.bf
X.nf
X
X       q or Q to quit
X       s or S to stop (temporarily)
X       c or C to continue (from a stop)
X       n or N to toggle neighborhood window display
X
X.fi
Within the focus of the neighborhood window, typing a single digit will
change the size of the displayed neighborhood.  The values shown in the
neighborhood window are those centered about the chosen cursor location
inside the main viewing window.  Cursor locations are chosen by clicking
any of the mouse points when the cursor is positioned at the desired point.
The initial cursor location is taken to be the center of the viewing area.
Note that whenever a value is too large to be shown, hyphens
are displayed instead of the value.
X.TP
X.BI \-display " connection"
Connect to the X server display,
X.IR connection.
X.TP
X.BI \-p " n"
If 
X.I n 
is positive, then this will cause an 
X.I n 
second delay between displaying
the cells of the universe of each time step.  Negative values of 
X.I n 
are ignored.  The default pause time is 0.
X.TP
X.BI \-s " (n|n,n)"
XFor the first option, if
X.I n
is positive, it is taken as the size of each cell (i.e. the number of pixels 
used for each side of a displayed cell) when
the results are first displayed; provided that using this value will
allow all of the cells to be displayed.  The second option allows both 
the width and height of displayed cells to be specified.  If neither the 
width nor the height are, a default value of 1 is used.
X.TP
X.BI \-map " file"
Uses the map contained in 
X.I file 
when displaying cell values.  Entries in the 
X.I file 
appear one per line, with the first entry being either an
integer value or an increasing range of integer values (e.g. -12..100).
The second entry is either a character (for use with the
X.B \-curses
option) or a color indication
X(for use with the
X.B \-x11
option).  
The color indication is either a triplet of unsigned (positive) 
integers (0..65535) associated with 
the amount of red, green and blue "pigment" to use to represent the color 
or it is a 0 or 1 (representing white and black respectively) when using
monochrome displays.
When giving the character values for use by the
X.B \-curses
option, the character may appear either within single quotes or given
as the decimal ascii code.
Comments about a particular value mapping may appear on the
remainder of the line.
X.TP
X.BI \-f " n"
Indicates which field of the cell values should be used for display.  The
default is to use the first field (
X.BI -f " 1"
X).
X.TP
X.BI \-dim " [n|n..n]{,n|,n..n}"
Indicates which of the dimensions are to be used for viewing as well as
which parts of that dimension to display.  The dimensions must be given
in the order they appear in the input.  A single number indicates a
projection on that dimension, while ranges of the form
X.I n..n
indicate which cells of the specified dimension to display.  The range must be
increasing.
No spaces should appear anywhere within the dimension indicator.
The number of ranges given for display can be zero (0), one (1) or 
two (2); but the number of dimensions specified must be the same as those
given in the input.
X.br
X.ne 5
X.SH FILES
file                            file of color/character maps
LIB_DIR/curses-map       default map for curses option
LIB_DIR/color-map        default color map for x11 option
LIB_DIR/bw-map           default black/white map for x11 option
X.SH "SEE ALSO"
cellc(MAN_EXT), pe-scam(MAN_EXT)
X.br
J Dana Eckart,
X.I "A Cellular Automata Simulation System: Version 2.0"
X(1992)
X.br
J Dana Eckart,
X.I "Cellang 2.0: Language Reference Manual"
X(1992)
X.SH DIAGNOSTICS
The diagnostics produced by cellview are intended to be
self-explanatory.
X.SH BUGS
X.PP
The maximum size of a color/character map is 256 entries.  
X.PP
Key stroke commands (i.e. quitting) should be permitted with the curses 
viewing option.  Unfortunately
this cannot be done since the standard input is already being used for
reading in the cell values.
X.PP
When the
X.B \-curses
option is chosen, the maximum number of cells which can be displayed
is determined by the size of the screen.  The choice of the
X.B \-x11
option however permits the size to be scaled to fit the display, with
the largest cell size limited to 256 pixels square.  Ultimately, both
options should allow the window to be moved over the cells of the
universe so that no such limitations would be present.
X.PP
The maximum size of a neighborhood which can be examined using the neighborhood
sub-window is 9, which encompasses a 19 x 19 region centered about the selected
cell.  In addition, only neighbor values between -999 and 999 can be displayed.
END_OF_FILE
if test 6243 -ne `wc -c <'viewer/cellview.man'`; then
    echo shar: \"'viewer/cellview.man'\" unpacked with wrong size!
fi
# end of 'viewer/cellview.man'
fi
if test -f 'viewer/view.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'viewer/view.c'\"
else
echo shar: Extracting \"'viewer/view.c'\" \(15058 characters\)
sed "s/^X//" >'viewer/view.c' <<'END_OF_FILE'
X/* view.c
X   Copyright (C) 1992  J Dana Eckart
X  
X   This program is free software; you can redistribute it and/or modify
X   it under the terms of the GNU General Public License as published by
X   the Free Software Foundation; either version 1, or (at your option)
X   any later version.
X  
X   This program is distributed in the hope that it will be useful,
X   but WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X   GNU General Public License for more details.
X  
X   You should have received a copy of the GNU General Public License
X   along with CELLULAR-2.0; see the file COPYING.  If not, write to the 
X   Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X*/
X
X/* This is the default display type. */
X#define DEFAULT_DISPLAY		curses_option
X
X#include <stdio.h>
X#include <signal.h>
X#include <stdlib.h>
X#include <malloc.h>
X#include <string.h>
X#include "view.h"
X#include "curses.h"
X#include "boolean.h"
X
X/* The cellular universe which contains the colors/characters that
X   correspond to the cell values which are read.
X*/
celltype *cell_vals;
X
X/* The number of dimensions specified to display. */
int dim_given = 0;
X
X#if !COMBINED
X/* Contains the current time. */
unsigned long int _time = 0;
X
X/* Contains the time of the next block of cell value entries. */
long int next_time = 0;
X#endif
X
X/* The default amount of time to pause between displaying time steps. */
long int pause_time = 0;
X
X/* Contains the current entry number within a particular block of
X   cell value entries.  It's only purpose is in error messages to
X   better indicate their location within the input.
X*/
long int entry = 0;
X
X/* The values of the following variables determine which method of
X   display has been chosen.
X*/
short curses_option = false, x11_option = false;
X
X/* Global variable set in "main", which is the name of this program. */
char *command = NULL;
X
X/* Decides which cleanup actions to perform. */
void finish_up() {
X	/* Do whichever cleanup is necessary. */
X	if (curses_option) finish_curses();
X	else if (x11_option) finish_x11();
X}
X
X/* Performs the actions desired when a kill signal is received. */
void exit_signaled() {
X	finish_up();
X	exit(0);
X}
X
X/* Prints out the error message in a standard format and exits.  This
X   format is intended for use when the problem is with other than the
X   input.
X*/
void error(format, string) char *format, *string; {
X	char error_msg[MAX_STRING_SIZE];
X	sprintf(error_msg, format, string);
X	fprintf(stderr, "%s: %s.\n", command, error_msg);
X	exit(1);
X}
X
X/* Prints out the error message in a standard format and exits.  This
X   format is intended for use when there is a problem with the input.
X*/
void input_error(format, string) char *format, *string; {
X	char error_msg[MAX_STRING_SIZE];
X	sprintf(error_msg, format, string);
X	fprintf(stderr, "%s: time %d, entry %d: %s.\n",
X		command, _time, entry, error_msg);
X	finish_up();
X	exit(1);
X}
X
X/* Array of ranges and associated colors (i.e. the map). */
struct {
X	int lower, upper;
X	celltype color;
X		
X} map[MAX_MAP_SIZE];
X
X/* Number of map entries given. */
int max_map_entry = 0;
X
X/* Read in the color map from the map_name file. */
void read_map(map_name, black_and_white) char *map_name; int black_and_white; {
X	FILE *map_file = fopen(map_name, "r");
X
X	if (NULL == map_file)
X		error("Unable to open map file '%s'", map_name);
X
X	/* Read in all the map entries from the file. */
X	while (1) {
X		int c;
X		int lower, upper;
X		int count;
X		int red, blue, green;
X
X		/* Read the next entry, but if there are no more, quit. */
X		count = fscanf(map_file, " %d", &lower);
X		if (0 == count || EOF == count)
X			break;
X		count = fscanf(map_file, "..%d", &upper);
X		if (0 == count)
X			upper = lower;
X		else if (EOF == count)
X			error("Map entry %d is incomplete",
X			      (char*) max_map_entry+1); 
X
X		/* Make sure not too many entries are used. */
X		if (max_map_entry >= MAX_MAP_SIZE)
X			error("More than %d color map entries used",
X			      (char*) MAX_MAP_SIZE); 
X
X		/* Set the new map entry value range. */
X		map[max_map_entry].lower = lower;
X		map[max_map_entry].upper = upper;
X
X		/* Read and set the color/character. */
X		if (curses_option) {
X			char c;
X			count = fscanf(map_file, " '%c'", &c);
X			map[max_map_entry].color = (celltype) c;
X			if (0 == count) {
X				/* Numeric ASCII value was given. */
X				int tmp_int;
X				count = fscanf(map_file, " %d", &tmp_int);
X				map[max_map_entry].color = 
X						(celltype) tmp_int;
X			}
X			/* Check for legality of map entry. */
X			if (1 != count)
X				error("Entry %d of curses map file is illegal",
X				      (char*) max_map_entry);
X		}
X		else if (black_and_white) {
X			/* A black/white display. */
X			int tmp_int;
X			count = fscanf(map_file, " %d", &tmp_int);
X
X			/* Check for legality of map entry. */
X			if (1 != count)
X				error("Entry %d of b&w map file is illegal",
X				      (char*) max_map_entry);
X
X			map[max_map_entry].color = 
X						(celltype) tmp_int;
X		}
X		else {
X			/* A color display. */
X			count = fscanf(map_file, " %d %d %d",
X					&red, &green, &blue);
X
X			/* Check for legality of map entry. */
X			if (3 != count)
X				error("Entry %d of b&w map file is illegal",
X				      (char*) max_map_entry);
X
X			map[max_map_entry].color = 
X					setcolor(red, green, blue, 
X						 max_map_entry);
X		}
X
X		max_map_entry++;
X
X		/* Skip to the end of the line. */
X		while ((c = getc(map_file)) != '\n' && c != EOF);
X		if (EOF == c) break;
X	}
X	fclose(map_file);
X}
X
X/* Maps the given (cell) value to the desired color/character display value. */
celltype map_value(value) long int value; {
X	int i;
X	for (i = 0; i < max_map_entry; i++)
X		if (map[i].lower <= value && value <= map[i].upper)
X			return map[i].color;
X	
X	/* If an appropriate map value wasn't found, then complain
X	   and die.
X	*/
X	input_error("No color/character for cell value %d", (char*) value);
X}
X
X/* The following variables are the lower and upper bounds of the dimensions
X   given on the command line.  The range of each dimension is then calculated.
X*/
long int lower[MAX_DIMS], upper[MAX_DIMS], range[MAX_DIMS];
X
X/* The indices of the above arrays which correspond to the dimensions
X   which contain a non-zero range (i.e. lower and upper bounds differ).
X*/
int range_dim_1_index = -1;
int range_dim_2_index = -1;
X
X/* Total number of dimensions with non-trivial ranges. */
int range_dim_given = 0;
X
X/* Indicates the cell field value to use. */
int field;
X
X/* Set the cell value and have it displayed. */
void set_cell_entry(dim_index_1, dim_index_2, cell_value)
long int dim_index_1, dim_index_2, cell_value; {
X	/* Set cell value. */
X	cell_vals[(dim_index_1 - lower[range_dim_1_index])
X					* range[range_dim_2_index] +
X	      dim_index_2 - lower[range_dim_2_index]] 
X							= cell_value;
X
X	/* Update the appropriate display. */
X	if (curses_option) 
X		update_curses(dim_index_1, dim_index_2, map_value(cell_value));
X	else 
X		update_x11(dim_index_1, dim_index_2, map_value(cell_value));
X}
X
X#if !COMBINED
X/* Reads in a single cell and value entry from standard input.  If
X   the dimensional indices fall outside of the desired display range
X   the entry is ignored.
X*/
void read_cell_entry() {
X	int i;
X	celltype cell_color;
X	long int cell_value;
X 	long int dim_index_1 = 0, dim_index_2 = 0;
X
X	/* Read in the (up to 2) indices for the dimensional ranges. */
X	scanf(" [ ");
X	for (i = 0; i < dim_given; i++) {
X		long int index;
X
X		/* Read the index value. */
X		if (scanf(" %ld ", &index) != 1)
X			input_error("Too few dimensions in input", 
X				    (char*) NULL);
X
X		/* Only consider the desired dimensional projections. 
X		   If either the index is out of range or is not the
X		   desired value, then skip to the next line of input
X		   and return.
X		*/
X		if (range[i] == 1 && index != lower[i]) {
X			while (getchar() != '\n');
X			return;
X		}
X		else if (range[i] > 1 && 
X				(index < lower[i] || index > upper[i])) {
X			while (getchar() != '\n');
X			return;
X		}
X
X		/* Remember the indices of range projected dimensions. */
X		if (i == range_dim_1_index) dim_index_1 = index;
X		else if (i == range_dim_2_index) dim_index_2 = index;
X
X		if (i < dim_given - 1) scanf(" , ");
X	}
X	scanf(" ] ");
X
X	/* Read in the cell field value. */
X	if (1 != scanf(" = %ld ", &cell_value))
X		input_error("read error", (char*) NULL);
X	for (i = 1; i < field; i++)
X		if (1 != scanf(", %ld", &cell_value))
X			input_error("read error", (char*) NULL);
X
X	set_cell_entry(dim_index_1, dim_index_2, cell_value);
X
X	/* Ignore the remaining values, if any. */
X	while (1 == scanf(", %ld", &cell_value));
X}
X
X/* Read an entire block of cell entries.  When complete, the value
X   of next_time will either be strictly greater than the current
X   _time (old value of next_time) or it will equal -1 (indicating
X   that the input is exhausted).
X*/
void read_cell_block() {
X	entry = 0;
X	while (next_time == _time) {
X		int count;
X
X		/* Assume that a time specification is next on the input.
X		   If it isn't (and the input is non-empty), then read a 
X		   cell entry instead.  If a new time specification is
X		   present, make sure it is legal.
X		*/
X		count = scanf(" %ld ", &next_time);
X		if (0 == count) {
X			entry++;
X			read_cell_entry();
X		}
X		else if (EOF == count) {
X			/* End of input. */
X			next_time = -1;
X			break;
X		}
X		else if (next_time < _time)
X			/* Check legality of new _time. */
X			input_error("Time went backwards at %d", (char*) _time);
X	}
X}
X#endif
X
X/* Print out the correct usage. */
void usage() {
X	fprintf(stderr, 
X#if COMBINED
X		"usage: [ ... | ] %s ( [-curses | -x11 [-display connection]]\n\t[-r file] [-p n] [-s (n|n,n)] [-map file] [-f n] -dim [n|n..n]{,n|,n..n} ]\n\t\t|\n\t[-r file] -o )\n",
X#else
X		"usage: [ ... | ] %s [-curses | -x11 [-display connection]]\n\t[-p n] [-s (n|n,n)] [-map file] [-f n] -dim [n|n..n]{,n|,n..n}\n",
X#endif
X		command); 
X	exit(1);
X}
X
X/* The main driver for everything. */
void main(argc, argv) int argc; char *argv[]; {
X#if COMBINED
X	boolean output = false;
X	extern FILE *time_file;
X#endif
X	int i, cell_size_x = 1, cell_size_y = 1;
X	celltype value_for_0;
X	char *map_name = NULL, *x11_display = NULL;
X
X	field = 1;	/* Look at the first cell field value by default. */
X
X	command = argv[0];
X
X	/* Check for proper usage and options. */
X	i = 0;
X	while (++i <= argc-1)
X		if (strcmp(argv[i], "-curses") == 0)
X			curses_option = true;
X		else if (strcmp(argv[i], "-x11") == 0)
X			x11_option = true;
X		else if (strcmp(argv[i], "-display") == 0)
X			x11_display = argv[++i];
X		else if (strcmp(argv[i], "-f") == 0) {
X			field = atoi(argv[++i]);
X			if (field < 1)
X				error("Field must be integer > 0",
X					(char*) NULL);
X		}
X#if COMBINED
X		else if (strcmp(argv[i], "-o") == 0)
X			output = true;
X#endif
X		else if (strcmp(argv[i], "-p") == 0) {
X			if (sscanf(argv[++i], "%ld", &pause_time) != 1)
X				error("Pause time must be an integer",
X					(char*) NULL);
X		}
X#if COMBINED
X		else if (strcmp(argv[i], "-r") == 0)
X			time_file = fopen(argv[++i], "r");
X#endif
X		else if (strcmp(argv[i], "-s") == 0) {
X			int sides = sscanf(argv[++i], 
X					"%ld,%ld", &cell_size_x, &cell_size_y);
X			if (sides < 1)
X				error("Cell size(s) must be integer",
X					(char*) NULL);
X			if (sides == 1) cell_size_y = cell_size_x;
X			if (cell_size_x < 1) cell_size_x = 1;
X			if (cell_size_y < 1) cell_size_y = 1;
X		}
X		else if (strcmp(argv[i], "-map") == 0)
X			if (i == argc-1)
X				usage();
X			else
X				map_name = argv[++i];
X		else if (strcmp(argv[i], "-dim") == 0) {
X			int count;
X			char *dim_token;
X			if (i == argc-1)
X				usage();
X
X			/* Give dim, lower and upper reasonable defaults. */
X			for (count = 0; count < MAX_DIMS; count++)
X				lower[count] = upper[count] = 0;
X
X			/* Read/parse the dimensions. */
X			dim_token = strtok(argv[++i], ",");
X			while (dim_token != NULL) {
X				if (strchr(dim_token, '.') == NULL)
X					lower[dim_given] = upper[dim_given]
X							= atoi(dim_token);
X				else {
X					if (2 != sscanf(dim_token, 
X							" %ld .. %ld ", 
X							&lower[dim_given],
X							&upper[dim_given]))
X						usage();
X
X					/* A "true" range was given. */
X					if (lower[dim_given] != 
X							upper[dim_given])
X						if (range_dim_1_index < 0)
X							range_dim_1_index = 
X								dim_given;
X						else
X							range_dim_2_index = 
X								dim_given;
X				
X				}
X				dim_given++;
X				dim_token = strtok((char*) NULL, ",");
X			}
X
X			/* Establish default ranges if necessary. */
X			if (range_dim_1_index < 0) 
X				range_dim_1_index = 0;
X			if (range_dim_2_index < 0) 
X				range_dim_2_index = MAX_DIMS - 1;
X		}
X		else
X			fprintf(stderr, "%s: Unknown option '%s' ignored.\n",
X				command, argv[i]);
X
X	/* Can't give both of these options. */
X	if (curses_option && x11_option)
X		usage();
X
X	/* If neither option was explicitly given, then default to curses. */
X	if (!(curses_option || x11_option))
X		DEFAULT_DISPLAY = true;
X
X	/* Can only request a paritcular display for x11. */
X	if (x11_display != NULL && !x11_option)
X		error("Must use the -display option with the -x11 option",
X			(char*) NULL);
X
X	/* Check that dimensions were described. */
X#if COMBINED
X	if (0 == dim_given && !output)
X#else
X	if (0 == dim_given)
X#endif
X		usage();
X
X	/* Determine and check ranges. */
X	for (i = 0; i < MAX_DIMS; i++) {
X		range[i] = upper[i] - lower[i] + 1;
X		if (range[i] <= 0) {
X			char msg[MAX_STRING_SIZE];
X			sprintf(msg, 
X				"Dimension %d has decreasing range of indices",
X				i+1);
X			error(msg, (char*) NULL);
X		}
X		else if (range[i] > 1)
X			range_dim_given++;
X	}
X
X	/* Determine if too many or too few ranges were given. */
X	if (range_dim_given > 2)
X		error("A maximum of 2 dimension ranges can be given", (char*) NULL);
X
X#if COMBINED
X	/* If output is requested, then don't display in either curses
X	   of X11 modes.
X	*/
X	if (output) {
X		curses_option = false;
X		x11_option = false;
X	}
X#endif
X
X	/* Set the signal so things can be cleaned up when the program
X	   is terminated.
X	*/
X	signal(SIGINT, exit_signaled);
X
X	/* Do setup for the necessary display mode. */
X	if (curses_option)
X		setup_curses(map_name);
X	else if (x11_option)
X		setup_x11(map_name, x11_display, cell_size_x, cell_size_y);
X
X#if !COMBINED
X	/* Read the first time from the input. */
X	i = scanf("%ld", &next_time);
X	if (0 == i)
X		input_error("Missing time specification", (char*) NULL);
X	else if (EOF == i)
X		/* End of input. */
X		next_time = -1;
X	else if (next_time < 0)
X		/* Check legality of new _time. */
X		input_error("Time must be >= 0", (char*) NULL);
X#endif
X
X	/* Allocate the space for the cell_vals. */
X	cell_vals = (celltype*) calloc((unsigned int) 
X					(range[range_dim_1_index] * 
X						range[range_dim_2_index]), 
X				   (unsigned int) sizeof(celltype));
X	if (cell_vals == NULL) {
X		finish_up();
X		error("Insufficient memory", (char*) NULL);
X	}
X
X	/* Initialize cell_vals to be 0. */
X	for(i = range[range_dim_1_index] * range[range_dim_2_index];i > 0; i--)
X         	cell_vals[i-1] = 0;
X
X#if COMBINED
X	/* Initialize the cell universe. */
X	init_cells();
X#endif
X
X	/* Start displaying stuff! */
X	if (curses_option) display_curses(field-1);
X	else if (x11_option) display_x11(field-1);
X#if COMBINED
X	else cellang_main(output, field-1);
X#endif
X}
END_OF_FILE
if test 15058 -ne `wc -c <'viewer/view.c'`; then
    echo shar: \"'viewer/view.c'\" unpacked with wrong size!
fi
# end of 'viewer/view.c'
fi
if test -f 'viewer/x11.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'viewer/x11.c'\"
else
echo shar: Extracting \"'viewer/x11.c'\" \(21295 characters\)
sed "s/^X//" >'viewer/x11.c' <<'END_OF_FILE'
X/* x11.c
X   Copyright (C) 1992  J Dana Eckart
X  
X   This program is free software; you can redistribute it and/or modify
X   it under the terms of the GNU General Public License as published by
X   the Free Software Foundation; either version 1, or (at your option)
X   any later version.
X  
X   This program is distributed in the hope that it will be useful,
X   but WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X   GNU General Public License for more details.
X  
X   You should have received a copy of the GNU General Public License
X   along with CELLULAR-2.0; see the file COPYING.  If not, write to the 
X   Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X*/
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <malloc.h>
X#include <math.h>
X#include <X11/Xos.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/cursorfont.h>
X#include "view.h"
X
X/* Font for displaying the time in the time window. */
X#define FONT  "10x20"
X
X/* Maximum setttings for x11. */
X#define MAX_CELL_SIDE	256
X
X/* Maximum width of the largest cell value. */
X#define MAX_VALUE_WIDTH	4
X
X/* Variables used by all the windows. */
static XFontStruct 	*font_info;
static Display 		*dpy;
static int		screen;
static GC		gc;
X
static Colormap cmap;
static unsigned long int pixels[MAX_MAP_SIZE];
static unsigned long int Black_Pixel, White_Pixel;
X
static Pixmap cell_pixmap;
X
X/* Variables for controlling the main viewing window. */
static Window  mainWindow;
static XSetWindowAttributes 	xswa;
static int			cell_side_x = MAX_CELL_SIDE;
static int			cell_side_y = MAX_CELL_SIDE;
static float			cell_side_ratio = 1.0;
static int 			time_window_height = 0;
static int			mainWidth = 0, mainHeight = 0;
X
X/* Variables for controlling the neighborhood sub-window. */
static Window   neighborWindow = NULL;
static int 	neighborhood = 1;		/* size of the neighborhood. */
static 		int neighbor_x, neighbor_y;	/* x, y neighborhood viewing 
X								co-ordinates. */
static 		int neighborWidth, neighborHeight;
X
X
X/* Create the sub-window dedicated to showing the numeric values of a
X   neighborhood.
X*/
void CreateNeighborWindow() {
X	int charheight = font_info->ascent + font_info->descent;
X	XSizeHints sizehints;
X
X	neighborWidth = (2*neighborhood+1) * charheight * MAX_VALUE_WIDTH;
X	neighborHeight = (range_dim_given > 1 ? neighborWidth :
X					        charheight*MAX_VALUE_WIDTH);
X
X	/* Configure the window size hints. */
X	sizehints.flags = PMinSize | PMaxSize | PPosition | PSize;
X	sizehints.x = 0;
X	sizehints.y = 0;
X	sizehints.width = neighborWidth;
X	sizehints.height = neighborHeight;
X	sizehints.min_width = sizehints.width;
X	sizehints.min_height = sizehints.height;
X	sizehints.max_width = sizehints.width;
X	sizehints.max_height = sizehints.height;
X
X	neighborWindow = 
X		XCreateWindow(
X			dpy, 
X			RootWindow(dpy, screen),
X			0, 0,
X			sizehints.width, sizehints.height,
X			1,
X			DefaultDepth(dpy, screen),
X			InputOutput,
X			DefaultVisual(dpy, screen),
X			CWEventMask | CWBackPixel | CWBorderPixel | CWColormap,
X			&xswa);
X
X	if (!neighborWindow) {
X		error("Unable to open a neighborhood window", (char*) NULL);
X		return;
X	}
X
X	/* Define the window's name. */
X	XSetStandardProperties(dpy, neighborWindow, 
X			       "neighborhood", "neighborhood",
X			       None, NULL, 0, &sizehints);
X
X	XMapRaised(dpy, neighborWindow);
X 	XSelectInput(dpy, neighborWindow, ExposureMask | StructureNotifyMask |
X                     KeyPressMask | VisibilityChangeMask);
X}
X
X/* Display the values of the appropriate neighborhood. */
void display_neighbor_values() {
X	int charheight = font_info->ascent + font_info->descent;
X	int i, j;
X
X	/* Clear the contents of the window. */
X	XSetForeground(dpy, gc, Black_Pixel);
X	XFillRectangle(dpy, neighborWindow, gc, 
X		       0, 0, neighborWidth, neighborHeight);
X
X	XSetForeground(dpy, gc, White_Pixel);
X
X	/* Draw the horizontal lines (if need be). */
X	if (range_dim_given > 1) for (i = 2*neighborhood; i > 0; i--)
X		XDrawLine(dpy, neighborWindow, gc,
X			  0, i*charheight*MAX_VALUE_WIDTH,
X			  neighborWidth, i*charheight*MAX_VALUE_WIDTH);
X
X	/* Draw the vertical lines. */
X	for (i = 2*neighborhood; i > 0; i--)
X		XDrawLine(dpy, neighborWindow, gc,
X			  i*charheight*MAX_VALUE_WIDTH, 0,
X			  i*charheight*MAX_VALUE_WIDTH, neighborHeight);
X
X	/* Display the neighbor values. */
X	for (i = -neighborhood; i <= neighborhood; i++)
X		for (j = -neighborhood; j <= neighborhood; j++) {
X			int x = (neighbor_x + i + range[range_dim_1_index]) %
X						range[range_dim_1_index];
X			int y = (neighbor_y + j + range[range_dim_2_index]) %
X						range[range_dim_2_index];
X			char string[MAX_VALUE_WIDTH];
X			celltype value = cell_vals[x*range[range_dim_2_index]+y];
X
X			/* If a range of indices was only given for 1
X			   dimension, then don't print the extra values
X			   above and below.
X			*/
X			if (range_dim_given <= 1 && j != 0) continue;
X
X			/* Make sure the value will fit.  If it won't then
X			   display hyphens in place of the value.
X			*/
X			if (value == 0 ||
X			    (value < 0 ? log10(-value):log10(value)) 
X							<= MAX_VALUE_WIDTH)
X				sprintf(string, "%ld", value);
X			else {
X				int i;
X				string[0] = '\0';
X				for (i = 0; i < MAX_VALUE_WIDTH; i++)
X					strcat(string, "-");
X			}
X			XDrawString(dpy, neighborWindow, gc, 
X		    		(neighborhood+i)*charheight*MAX_VALUE_WIDTH +
X					charheight,
X		    		(neighborhood-j)*charheight*MAX_VALUE_WIDTH +
X					(MAX_VALUE_WIDTH/2)*charheight +
X					charheight/2,
X	            		string, strlen(string));
X		}
X
X	XFlush(dpy);
X}
X
X/* Resize the neighborhood sub-window. */
void resize_neighborhood() {
X	int charheight = font_info->ascent + font_info->descent;
X
X	neighborWidth = (2*neighborhood+1) * charheight * MAX_VALUE_WIDTH;
X	neighborHeight = (range_dim_given > 1 ? neighborWidth :
X					        charheight*MAX_VALUE_WIDTH);
X
X	XResizeWindow(dpy, neighborWindow, neighborWidth, neighborHeight);
X}
X
X/* Do any cleanup for x11 windows and quit. */
void finish_x11() {
X	XFreeColormap(dpy, cmap);
X	XCloseDisplay(dpy);
X}
X
X/* Display the current time step at the bottom of the window. */
void display_time() {
X	char time_string[MAX_STRING_SIZE];
X
X	/* Clear the time display part of the window. */
X	XSetForeground(dpy, gc, White_Pixel);
X	XFillRectangle(dpy, mainWindow, gc, 
X		       0, cell_side_y*range[range_dim_2_index] + 1,
X		       cell_side_x*range[range_dim_1_index], time_window_height);
X
X	/* Display the new current time step. */
X	XSetForeground(dpy, gc, Black_Pixel);
X	sprintf(time_string, "time = %d", _time);
X	XDrawString(dpy, mainWindow, gc, 
X		    time_window_height/2,
X		    cell_side_y * range[range_dim_2_index] + 
X				(int) (0.75 * time_window_height), 
X	            time_string, strlen(time_string));
X	XFlush(dpy);
X}
X
X/* Display all the cell_vals in the universe. */
void display_x11_cells() {
X	XCopyArea(dpy, cell_pixmap, mainWindow, gc, 0, 0,
X		  range[range_dim_1_index]*cell_side_x, 
X		  range[range_dim_2_index]*cell_side_y, 0, 0);
X	XFlush(dpy);
X
X	/* May need to update the neighbor values too. */
X	if (neighborWindow) display_neighbor_values();
X}
X
X/* Reset the pixel map with cell "colors". */
void redisplay_cells() {
X	int i, j;
X
X	/* Draw the cells onto the pixmap. */
X	for (i = 0; i < range[range_dim_1_index]; i++)
X		for (j = 0; j < range[range_dim_2_index]; j++) {
X			XSetForeground(dpy, gc, 
X					(unsigned long) 
X					map_value(cell_vals[i*range[range_dim_2_index]+j]));
X			XFillRectangle(dpy, cell_pixmap, gc, 
X					i*cell_side_x, 
X					(range[range_dim_2_index]-1-j)*cell_side_y, 
X					cell_side_x, cell_side_y);
X		}
X	display_x11_cells();
X}
X
X/* Handle the events for the neighborhood sub-window. */
void sub_window_event(event) XEvent *event; {
X	XExposeEvent *ee = (XExposeEvent*) event;
X	XKeyPressedEvent *ke = (XKeyPressedEvent *) event;
X	char keybuff[10];
X        int nchar;
X
X	switch(event->type) {
X       	case ConfigureNotify:
X		/* Don't resize this window. */
X		break;
X
X	case Expose:
X		if (ee->count) break;
X
X	case VisibilityNotify:
X		display_neighbor_values();
X       		break;
X
X	case ButtonPress:
X       		break;
X
X	case KeyPress:
X		nchar = XLookupString(ke, keybuff, 1, NULL, NULL);
X               	if (nchar > 0) {
X               		switch (keybuff[0]) {
X                       	case '0':
X                       	case '1':
X                       	case '2':
X                       	case '3':
X                       	case '4':
X                       	case '5':
X                       	case '6':
X                       	case '7':
X                       	case '8':
X                       	case '9':
X				neighborhood = keybuff[0]-'0';
X				resize_neighborhood();
X				display_neighbor_values();
X				break;
X
X			default:
X				break;
X                       	}
X       	       	}
X       	       	break;
X
X	default:
X		break;
X	}
X}
X
X/* Handle the events for the main window. */
void main_window_event(stopped, event) int *stopped; XEvent *event; {
X	XExposeEvent *ee = (XExposeEvent*) event;
X        XConfigureEvent *ce = (XConfigureEvent*) event;
X	XButtonPressedEvent *be = (XButtonPressedEvent *) event;
X	XKeyPressedEvent *ke = (XKeyPressedEvent *) event;
X	char keybuff[10];
X        int nchar;
X
X	switch(event->type) {
X       	case ConfigureNotify:
X		/* Don't resize the window if both the width and
X		   the height are the same.
X		*/
X		if (ce->width == mainWidth && ce->height == mainHeight)
X			break;
X
X		/* The window needs to be resized. */
X		ce->height -= (time_window_height + 1);
X		cell_side_x = (ce->width / range[range_dim_1_index] > 
X				ce->height / range[range_dim_2_index] ?
X				ce->height / range[range_dim_2_index] : 
X				ce->width / range[range_dim_1_index]);
X
X		if (cell_side_ratio < 1) {
X			if (cell_side_x > MAX_CELL_SIDE) 
X				cell_side_x = MAX_CELL_SIDE;
X
X			/* Make sure cell_vals are "visible". */
X			if (cell_side_x <= 0) cell_side_x = 1;
X
X			cell_side_y = cell_side_x * cell_side_ratio;
X		}
X		else {
X			cell_side_y = cell_side_x * cell_side_ratio;
X
X			if (cell_side_y > MAX_CELL_SIDE) 
X				cell_side_y = MAX_CELL_SIDE;
X
X			/* Make sure cell_vals are "visible". */
X			if (cell_side_y <= 0) cell_side_y = 1;
X
X			cell_side_x = cell_side_y / cell_side_ratio;
X		}
X
X		/* Since the size just chosen for the window may
X		   not yield an integer number of pixels for the
X		   sides of cells, reset the window size to just
X		   fit the new cell_side_x and cell_side_y values.
X		*/
X		mainWidth = range[range_dim_1_index]*cell_side_x;
X		mainHeight = range[range_dim_2_index]*cell_side_y + 
X			      	time_window_height + 1;
X		XResizeWindow(dpy, mainWindow, 
X			      mainWidth, mainHeight);
X
X		/* Free and create a new pixel map. */
X		XFreePixmap(dpy, cell_pixmap);
X		cell_pixmap = 
X			XCreatePixmap(dpy, mainWindow,
X				    range[range_dim_1_index]*cell_side_x,
X				    range[range_dim_2_index]*cell_side_y,
X				    DefaultDepth(dpy, screen));
X
X		redisplay_cells();
X		display_time();
X       		break;
X
X	case Expose:
X		if (ee->count) break;
X
X	case VisibilityNotify:
X		display_x11_cells();
X		display_time();
X       		break;
X
X	case ButtonPress:
X		if (neighborWindow != NULL) {
X			neighbor_x = (be->x/cell_side_x + 
X					range[range_dim_1_index]) %
X						range[range_dim_1_index];
X			neighbor_y = (-be->y/cell_side_y - 1 + 
X					range[range_dim_2_index]) %
X						range[range_dim_2_index];
X			display_neighbor_values();
X		}
X		break;
X
X	case KeyPress:
X		nchar = XLookupString(ke, keybuff, 1, NULL, NULL);
X               	if (nchar > 0) {
X               		switch (keybuff[0]) {
X                       	case 'n':
X                       	case 'N':
X				/* Neighborhood window */
X				if (!neighborWindow)
X					CreateNeighborWindow();
X				else {
X					XDestroyWindow(
X						dpy, neighborWindow);
X					neighborWindow = NULL;
X				}
X				break;
X               		case 'q':
X               		case 'Q':
X				/* Quit */
X				finish_x11();
X                       		exit(0);
X               		case 's':
X               		case 'S':
X				/* Stop */
X                       		*stopped = true;
X				break;
X               		case 'c':
X               		case 'C':
X				/* Continue */
X                       		*stopped = false;
X				break;
X			default:
X				break;
X                       	}
X       	       	}
X       	       	break;
X
X	default:
X		break;
X	}
X}
X
X/* Check for, and perform events as they arise. */
void do_event() {
X	XEvent event;
X	boolean stopped = false;
X
X	/* If there are events, handled them. */
X	while (XPending(dpy) || stopped) {
X		XNextEvent(dpy, &event);
X		if (event.xany.window == neighborWindow)
X			sub_window_event(&event);
X		else if (event.xany.window == mainWindow)
X			main_window_event(&stopped, &event);
X	}
X}
X
X/* Update (display) the color of a single cell. */
void update_x11(x, y, color_index) long int x, y; celltype color_index; {
X	long int i = x - lower[range_dim_1_index];
X	long int j = y - lower[range_dim_2_index];
X	XSetForeground(dpy, gc, (unsigned long) color_index);
X	XFillRectangle(dpy, cell_pixmap, gc, 
X		       i*cell_side_x, (range[range_dim_2_index]-1-j)*cell_side_y, 
X		       cell_side_x, cell_side_y);
X}
X
X/* Stores the red, green and blue portions that make up a color. */
celltype setcolor(red, green, blue, index) int red, green, blue, index; {
X	XColor color;
X	color.pixel = pixels[index];
X	color.red = red;
X	color.green = green;
X	color.blue = blue;
X	color.flags = DoRed | DoGreen | DoBlue;
X	XStoreColor(dpy, cmap, &color);
X	return color.pixel;
X}
X
X/* Set the values for Black_Pixel and White_Pixel. */
void Black_and_White_Pixels(max_colors) int max_colors; {
X	if (max_colors <= 2) {
X		Black_Pixel = BlackPixel(dpy, screen);
X		White_Pixel = WhitePixel(dpy, screen);
X	}
X	else {
X		/* Assume that the darkest pixels are given first and
X		   the lightest in color are given last.  In either
X		   case, both should be sufficiently different in color
X		   to be readable.
X		*/
X		White_Pixel = pixels[max_colors-1];
X		Black_Pixel = pixels[0];
X	}
X}
X
X/* Returns the number of lines in the file denoted by file_name. */
int file_size(file_name) char *file_name; {
X	int c, lines = 0;
X	FILE *file = fopen(file_name, "r");
X
X	if (NULL == file)
X		error("Unable to open map file '%s'", file_name);
X
X	/* Count the lines in the file. */
X	while ((c = getc(file)) != EOF) if ('\n' == c) lines++;
X
X	fclose(file);
X	return lines;
X}
X
X/* Do all the setup and housekeeping for starting an x11 window. */
void setup_x11(map_name, display, first_cell_side_x, first_cell_side_y) 
char *map_name, *display; int first_cell_side_x, first_cell_side_y; {
X	Visual *visual;
X	XSizeHints sizehints;
X	int max_x_pixels, max_y_pixels, ncolors, depth;
X	char *default_file;
X
X	if ((dpy = XOpenDisplay(display)) == NULL)
X	    	error("Can't open display '%s'", display);
X
X	screen = XDefaultScreen(dpy);
X
X	/* Do setup for displaying the time in the time window. */
X	font_info = XLoadQueryFont(dpy, FONT);
X	if (NULL == font_info)
X		error("Unable to load font '%s'", FONT);
X	time_window_height = 1.5*(font_info->ascent + font_info->descent);
X
X	/* Get the height and width of the screen in pixels. */
X	max_x_pixels = XDisplayWidth(dpy, screen);
X	max_y_pixels = XDisplayHeight(dpy, screen) - time_window_height - 1;
X
X	cell_side_ratio = (float) first_cell_side_y / (float) first_cell_side_x;
X
X	/* Determine the size of the sides of each displayed cell. */
X	cell_side_x = (max_x_pixels / range[range_dim_1_index] > 
X				max_y_pixels / range[range_dim_2_index] ?
X			max_y_pixels / range[range_dim_2_index] : 
X			max_x_pixels / range[range_dim_1_index]);
X
X	if (cell_side_ratio < 1) {
X		if (cell_side_x > MAX_CELL_SIDE) 
X			cell_side_x = MAX_CELL_SIDE;
X
X		/* Make sure cell_vals are "visible". */
X		if (cell_side_x <= 0)
X			error("Too many cells to display on screen", 
X				(char*) NULL);
X
X		cell_side_y = cell_side_x * cell_side_ratio;
X	}
X	else {
X		cell_side_y = cell_side_x * cell_side_ratio;
X
X		if (cell_side_y > MAX_CELL_SIDE) 
X			cell_side_y = MAX_CELL_SIDE;
X
X		/* Make sure cell_vals are "visible". */
X		if (cell_side_y <= 0)
X			error("Too many cells to display on screen", 
X				(char*) NULL);
X
X		cell_side_x = cell_side_y / cell_side_ratio;
X	}
X
X	/* Go with the prefered size if possible. */
X	if (cell_side_x > first_cell_side_x) cell_side_x = first_cell_side_x;
X	if (cell_side_y > first_cell_side_y) cell_side_y = first_cell_side_y;
X
X	mainWidth = range[range_dim_1_index]*cell_side_x;
X	mainHeight = range[range_dim_2_index]*cell_side_y + 
X		      	time_window_height + 1;
X
X	/* Get the default display inforamtion. */
X	visual = DefaultVisual(dpy, screen);
X	depth =	DefaultDepth(dpy,screen);
X        cmap = DefaultColormap(dpy, screen);
X
X	/* If a map file was given, read it; otherwise use the default. */
X	if (NULL == map_name) {
X		if (DisplayCells(dpy, screen) > 2) default_file = "color-map";
X		else default_file = "bw-map";
X
X		map_name = (char*) malloc((unsigned int) (strlen(LIB_DIR) + 
X						strlen(default_file) + 2));
X		if (NULL == map_name)
X			error("Out of memory", (char*) NULL);
X		sprintf(map_name, "%s/%s", LIB_DIR, default_file);
X	}
X	ncolors = file_size(map_name);
X
X	/* Set up a color map. */
X	if (DisplayCells(dpy, screen) > 2) {
X		/* Create a new colormap if not a black/white display. */
X		XVisualInfo     vinfo;
X		int planes = DisplayPlanes(dpy,screen);
X 		if (!(XMatchVisualInfo(dpy, screen, planes, PseudoColor, &vinfo)
X	              || 
X		      XMatchVisualInfo(dpy, screen, planes, GrayScale, &vinfo)
X                      || 
X		      XMatchVisualInfo(dpy, screen, planes, DirectColor, &vinfo)))
X			error("Unable to set up the color mapping",
X	 			(char*) NULL);
X
X		visual = vinfo.visual;
X		depth = vinfo.depth;
X
X		/* Only create a new colormap, if the current one doesn't
X		   have enough room in it for the map read in.
X		*/
X		if (! XAllocColorCells(dpy, cmap, False, NULL, 0, 
X				       pixels, ncolors)) {
X			cmap = XCreateColormap(dpy, RootWindow(dpy, screen),
X						visual, AllocNone);
X
X			/* Get the color cells. */
X			if (! XAllocColorCells(dpy, cmap, False, NULL, 0, 
X					       pixels, ncolors))
X				error("Unable to allocate %d colors", 
X					(char*) ncolors);
X		}
X	}
X	else if (ncolors > 2)
X		error("This display can only show %d colors", 
X			(char*) DisplayCells(dpy, screen));
X
X	printf("Using %d colors...\n", ncolors);
X	read_map(map_name, (ncolors <= 2 ? 1 : 0));
X	Black_and_White_Pixels(ncolors);
X
X	/* Create the palette main window and set its standard properties. */
X	xswa.event_mask = KeyPressMask | StructureNotifyMask | ExposureMask
X				| ButtonPressMask;
X	xswa.border_pixel = Black_Pixel;
X	xswa.background_pixel = Black_Pixel;
X	xswa.colormap = cmap;
X
X	/* Configure the window size hints. */
X	sizehints.flags = PMinSize | PPosition | PSize;
X	sizehints.x = 0;
X	sizehints.y = 0;
X	sizehints.min_width = range[range_dim_1_index];
X	sizehints.min_height = range[range_dim_2_index] + 
X						time_window_height + 1;
X	sizehints.width = range[range_dim_1_index] * cell_side_x;
X	sizehints.height = range[range_dim_2_index] * cell_side_y + 
X							time_window_height + 1;
X
X	/* Create the window. */
X	mainWindow = XCreateWindow(dpy, RootWindow(dpy, screen),
X			           sizehints.x, sizehints.y,
X			           sizehints.width, sizehints.height,
X			           1 /* Border Width */,
X				   depth,
X			           InputOutput,
X			           visual,
X			           CWEventMask | CWBackPixel | CWBorderPixel
X					| CWColormap,
X			           &xswa);
X
X	/* Define the window's name. */
X	XSetStandardProperties(dpy, mainWindow, "cellview", "cellview",
X			       None, NULL, 0, &sizehints);
X
X	XMapRaised(dpy, mainWindow);
X 	XSelectInput(dpy, mainWindow, ExposureMask | StructureNotifyMask |
X                     KeyPressMask | VisibilityChangeMask | ButtonPressMask);
X        gc = XCreateGC(dpy, mainWindow, 0, NULL);
X	XSetFont(dpy, gc, font_info->fid);
X	XFreeFontInfo(NULL, font_info, 1);
X	cell_pixmap = XCreatePixmap(dpy, mainWindow,
X				    range[range_dim_1_index]*cell_side_x,
X				    range[range_dim_2_index]*cell_side_y,
X				    depth);
X
X	/* Get a more accurate looking cursor. */
X	XDefineCursor(dpy, mainWindow,  XCreateFontCursor(dpy, XC_crosshair));
X
X	/* Assign intial values for the cursor location to be used for
X	   neighborhood value viewing within a sub-window.
X	*/
X	neighbor_x = range[range_dim_1_index]/2;
X	if (range_dim_given > 1)
X		neighbor_y = range[range_dim_2_index]/2;
X}
X
X/* Start displaying the cell_vals. */
void display_x11(field) int field; {
X	int i, j;
X
X	/* Initialize the cell_vals to the color values. */
X        for (i = lower[range_dim_1_index]; i <= upper[range_dim_1_index]; i++)
X                for (j = lower[range_dim_2_index]; j <= upper[range_dim_2_index] ; j++)
X                        update_x11(i, j,
X                                      map_value(cell_vals[(i -
X                                                lower[range_dim_1_index]) *
X                                                range[range_dim_2_index] +
X                                            j - lower[range_dim_2_index]]));
X
X	/* Initializes pixel map. */
X	redisplay_cells();
X
X	/* Wait for the first event. */
X	while (!XPending(dpy));
X
X	/* Display cell_vals for the rest of time. */
X	while (1) {
X		do_event();
X#if !COMBINED
X		if (next_time >= 0) 
X#endif
X		{
X			display_time();
X#if COMBINED
X			cellang_main(false, field);
X#else
X			read_cell_block();
X#endif
X			display_x11_cells();
X
X#if !COMBINED
X			if (next_time >= 0) _time++;
X#endif
X	
X			/* Pause times of 0 or less are ignored. */
X			if (pause_time > 0) sleep((unsigned int) pause_time);
X		}
X	}
X}
END_OF_FILE
if test 21295 -ne `wc -c <'viewer/x11.c'`; then
    echo shar: \"'viewer/x11.c'\" unpacked with wrong size!
fi
# end of 'viewer/x11.c'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
