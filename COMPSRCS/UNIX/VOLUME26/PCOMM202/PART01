Newsgroups: comp.sources.unix
From: fthood!egray@uxc.cso.uiuc.edu (Emmet Gray)
Subject: v26i153: pcomm-2.0.2 - a serial communications program (clone of ProComm), Part01/06
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: fthood!egray@uxc.cso.uiuc.edu (Emmet Gray)
Posting-Number: Volume 26, Issue 153
Archive-Name: pcomm-2.0.2/part01

This package will supercede Pcomm v1.2.4 that appeared in comp.sources.unix
as v20i067 thru v20i075 around the 27th of October 1989.

Pcomm is a public domain, menu driven, telecommunication program for Unix
designed to operate similarily to the popular MSDOS program, ProComm.  Some
of its features are:

	o Large dialing directory
	o Full scripting feature
	o Automatic redial feature
	o Six built-in file transfer protocols
	o External file transfer program support
	o Data logging (log of the terminal session)
	o Printer logging
	o Screen dump to file
	o Shell escapes to Unix
	o Help screen
	o Keyboard macros
	o User customization
	o Optional modem configuration per dialing directory entry
	o Administrative logging of phone calls
	o Administrative limits on long distance access

The following is a copy of the Pcomm help screen:

	 Major Functions        Utility Functions        File Functions

    Dialing Directory. ^A-D  Program Info .... ^A-I  Send Files .... ^A-<up>
    Auto Redial ...... ^A-R  Setup Screen .... ^A-S  Receive Files . ^A-<down>
    Keyboard Macros .. ^A-M  Change Directory. ^A-B  Pass Thru Mode. ^A-T
    Line Settings .... ^A-P  Clear Screen .... ^A-C  Directory ..... ^A-F
    Exit Pcomm ....... ^A-X  Toggle Duplex ... ^A-E  Screen Dump ... ^A-G
    Unix Gateway ..... ^A-4  Hang Up Phone ... ^A-H  Start Data Log. ^A-1
    Script Commands .. ^A-5  Printer On/Off .. ^A-L  Toggle Log .... ^A-2
			     Toggle CR-CR/LF . ^A-3
			     Break Key ....... ^A-7

New in this release...

        1) Uses poll() or select() for faster operation with lower
        CPU overhead.

        2) Configure.sh shell script that will glean information about
        your system.

        3) New Q_and_A (questions and answers) file to provide help on
        diagnosing common problems.

        4) "True" scripting capabilities.  Anything you can do from
        inside Pcomm, you can also do from a script.

        5) Modem configuration per dialing directory entry.  This allows
        you to tailor the modem to match what is expected at the other
        end of the connection.

        6) Pcomm now supports DTE baud rates up to 38400 plus "connected"
        baud rates for V.32bis (7200, 12000, and 14400).

Emmet P. Gray				US Army, HQ III Corps & Fort Hood
...!uunet!uiucuxc!fthood!egray		Attn: AFZF-DE-ENV
fthood!egray@uxc.cso.uiuc.edu		Directorate of Engineering & Housing
					Environmental Management Office
					Fort Hood, TX 76544-5057

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 6)."
# Contents:  Convert.sh MANIFEST Matches.1 Pcomm.dial_dir Pcomm.extrnl
#   Pcomm.modem Pcomm.param README Release.notes Sample Waitfor.1
#   chg_dir.c cmd.h config.h d_delete.c d_manual.c data_log.c
#   di_delay.c dial_dir.h expand.c extrnl.h getcwd.c getopt.c help.c
#   info.c init.c ipc.h ipc_att.c ipc_ucb.c list_dir.c matches.c
#   misc.h modem.h n_shell.c param.h passthru.c patchlevel.h pexit.c
#   redial.c screen.c st_line.c status.h vcs.h waitfor.c x_extrnl.c
#   x_win.c xmodem.h
# Wrapped by vixie@gw.home.vix.com on Wed Apr 14 00:38:40 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Convert.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Convert.sh'\"
else
echo shar: Extracting \"'Convert.sh'\" \(778 characters\)
sed "s/^X//" >'Convert.sh' <<'END_OF_FILE'
X:
echo This shell script will convert your pre-v2.0 Pcomm support files.
echo You obviously must have write permissions on the files.
echo 
echo "Enter the directory where the files are found : \c"
read DIR
if [ ! -d "$DIR" ] ;then
X	echo oops... \"$DIR\" is not a directory
X	exit
fi
if [ ! -f "$DIR/pcomm.param" ] ;then
X	echo humm... no pcomm.param support file found in \"$DIR\"
X	exit
fi
cd $DIR
echo editing pcomm.param...
ex - pcomm.param << "EOF"
X1,$s/D_DBITS=/D_DATA_BITS=/
X1,$s/D_SBITS=/D_STOP_BITS=/
X1,$s/^HOT=/HOT_KEY=/
X1,$s/FLOW=/FLOW_CTRL=/
X1,$s/LECHO=/LOCAL_ECHO=/
w
q
XEOF
if [ ! -f "$DIR/pcomm.modem" ] ;then
X	echo humm... no pcomm.modem support file found in \"$DIR\"
X	exit
fi
echo editing pcomm.modem...
ex - pcomm.modem << "EOF"
X1,$g/MODEM_[1-9]b=/s/$/;/
w
q
XEOF
END_OF_FILE
if test 778 -ne `wc -c <'Convert.sh'`; then
    echo shar: \"'Convert.sh'\" unpacked with wrong size!
fi
# end of 'Convert.sh'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2997 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Configure.sh               2	
X Convert.sh                 1	
X Doc.me                     6	
X MANIFEST                   1	This shipping list
X Makefile                   3	
X Matches.1                  1	
X Pcomm.1                    4	
X Pcomm.dial_dir             1	
X Pcomm.extrnl               1	
X Pcomm.modem                1	
X Pcomm.param                1	
X Pcomm_cmd.1                2	
X Q_and_A                    2	
X README                     1	
X Release.notes              1	
X Sample                     1	
X Unixpc.shar                5	
X Waitfor.1                  1	
X admin.c                    2	
X chg_dir.c                  1	
X cmd.c                      3	
X cmd.h                      1	
X config.h                   1	
X curses.c                   4	
X d_delete.c                 1	
X d_lib.c                    3	
X d_manual.c                 1	
X d_menu.c                   3	
X d_print.c                  2	
X d_prompt.c                 2	
X d_revise.c                 2	
X data_log.c                 1	
X di_delay.c                 1	
X di_win.c                   4	
X dial.c                     4	
X dial_dir.h                 1	
X e_lib.c                    2	
X expand.c                   1	
X extrnl.h                   1	
X getcwd.c                   1	
X getopt.c                   1	
X help.c                     1	
X info.c                     1	
X init.c                     1	
X input.c                    3	
X ipc.h                      1	
X ipc_att.c                  1	
X ipc_ucb.c                  1	
X list_dir.c                 1	
X ls_menu.c                  2	
X m_lib.c                    4	
X macro.c                    2	
X main.c                     4	
X matches.c                  1	
X misc.h                     1	
X modem.h                    1	
X n_shell.c                  1	
X p_lib.c                    3	
X param.h                    1	
X passthru.c                 1	
X patchlevel.h               1	
X pcomm_cmd.c                5	
X pexit.c                    1	
X port.c                     5	
X redial.c                   1	
X s_axfer.c                  2	
X s_extrnl.c                 2	
X s_gen.c                    2	
X s_menu.c                   2	
X s_modem.c                  3	
X s_prompt.c                 2	
X s_term.c                   2	
X s_tty.c                    2	
X screen.c                   1	
X script.c                   2	
X st_line.c                  1	
X status.h                   1	
X strings.c                  2	
X terminal.c                 3	
X tty_att.c                  2	
X tty_ucb.c                  2	
X vcs.c                      4	
X vcs.h                      1	
X waitfor.c                  1	
X x_ascii.c                  3	
X x_batch.c                  3	
X x_extrnl.c                 1	
X x_menu.c                   3	
X x_rcv.c                    4	
X x_send.c                   4	
X x_win.c                    1	
X xmodem.c                   3	
X xmodem.h                   1	
END_OF_FILE
if test 2997 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Matches.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Matches.1'\"
else
echo shar: Extracting \"'Matches.1'\" \(651 characters\)
sed "s/^X//" >'Matches.1' <<'END_OF_FILE'
X.TH matches L
X.SH NAME
matches \- test if string2 is contained in string1
X.SH SYNOPSIS
X.B matches string1 string2
X.SH DESCRIPTION
X.I Matches
returns a 0 if string2 is contained in string1, otherwise it returns a 1.
X.PP
X.I Matches
is designed to be used by
X.I Pcomm
inside a shell script for automating keyboard input to log user onto a
remote system.
X.PP
X.SH EXAMPLE
X.nf
X.RS 5
X# read some input
read junk
X# test to see the string matches 'login failed'
matches $junk 'login failed'
X# test the exit code of the matches command
if [ $? \-eq 0 ]
then
X.RS 5
X	exit 1
X.RE
fi
X.RE
X.fi
X.SH "SEE ALSO"
pcomm(1), pcomm_cmd(1), waitfor(1), Pcomm Reference Manual
END_OF_FILE
if test 651 -ne `wc -c <'Matches.1'`; then
    echo shar: \"'Matches.1'\" unpacked with wrong size!
fi
# end of 'Matches.1'
fi
if test -f 'Pcomm.dial_dir' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Pcomm.dial_dir'\"
else
echo shar: Extracting \"'Pcomm.dial_dir'\" \(333 characters\)
sed "s/^X//" >'Pcomm.dial_dir' <<'END_OF_FILE'
DIR_1=Abbey Road;1 (512) 590-6036;2400-N-8-1;F;
DIR_2=Tel-Med-Com;555-8686;9600-E-7-1;F;TELEBIT_V.32
DIR_3=C Board;1 (619) 722-8724;2400-N-8-1;F;
DIR_4=Crest;1 (213) 471-2518;2400-N-8-1;F;Sample
DIR_5=Last Chance;1 (219) 762-8411;2400-E-7-1;F;
DIR_6=Killer;1 (214) 827-1994;1200-E-7-1;F;
DIR_7=System A (direct);;19200-E-7-1;F;tty12
END_OF_FILE
if test 333 -ne `wc -c <'Pcomm.dial_dir'`; then
    echo shar: \"'Pcomm.dial_dir'\" unpacked with wrong size!
fi
# end of 'Pcomm.dial_dir'
fi
if test -f 'Pcomm.extrnl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Pcomm.extrnl'\"
else
echo shar: Extracting \"'Pcomm.extrnl'\" \(113 characters\)
sed "s/^X//" >'Pcomm.extrnl' <<'END_OF_FILE'
SEND_1=zmodem;sz;Y
SEND_2=kermit;kermit -ivs;Y
SEND_3=;;N
RCV_1=zmodem;rz;N
RCV_2=kermit;kermit -ivr;Y
RCV_3=;;N
END_OF_FILE
if test 113 -ne `wc -c <'Pcomm.extrnl'`; then
    echo shar: \"'Pcomm.extrnl'\" unpacked with wrong size!
fi
# end of 'Pcomm.extrnl'
fi
if test -f 'Pcomm.modem' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Pcomm.modem'\"
else
echo shar: Extracting \"'Pcomm.modem'\" \(826 characters\)
sed "s/^X//" >'Pcomm.modem' <<'END_OF_FILE'
TTY_1=tty10;HAYES;0
TTY_2=tty11;HAYES;0
TTY_3=tty12;DIRECT;0
TTY_4=tty13;TELEBIT;38400
TTY_5=tty13;TELEBIT_V.32;38400
TTY_6=tty13;TELEBIT_PEP;38400
MODEM_1a=HAYES;ATS7=60S11=70E0Q0V1X4&D2!;ATDT;!;~~+++~~ATH0!
MODEM_1b=Y;CONNECT!;CONNECT 1200;CONNECT 2400;;;;
MODEM_1c=BUSY;VOICE;NO CARRIER;
MODEM_2a=DIRECT;;;;
MODEM_2b=N;;;;;;;
MODEM_2c=;;;
MODEM_3a=TELEBIT;ATZ!~~;ATDT;!;~~+++~~ATH0!
MODEM_3b=Y;CONNECT 300;CONNECT 1200;CONNECT 2400;CONNECT 4800;CONNECT 9600;CONNECT FAST;
MODEM_3c=BUSY;ERROR;NO CARRIER;NO DIALTONE
MODEM_4a=TELEBIT_V.32;ATZ!~~;ATS180=0S50=6DT;!;~~+++~~ATH0!
MODEM_4b=Y;CONNECT 300;CONNECT 1200;CONNECT 2400;CONNECT 4800;CONNECT 9600;;
MODEM_4c=BUSY;ERROR;NO CARRIER;NO DIALTONE
MODEM_5a=TELEBIT_PEP;ATZ!~~;ATS50=255DT;!;~~+++~~ATH0!
MODEM_5b=Y;;;;;;CONNECT FAST;
MODEM_5c=BUSY;ERROR;NO CARRIER;NO DIALTONE
END_OF_FILE
if test 826 -ne `wc -c <'Pcomm.modem'`; then
    echo shar: \"'Pcomm.modem'\" unpacked with wrong size!
fi
# end of 'Pcomm.modem'
fi
if test -f 'Pcomm.param' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Pcomm.param'\"
else
echo shar: Extracting \"'Pcomm.param'\" \(487 characters\)
sed "s/^X//" >'Pcomm.param' <<'END_OF_FILE'
D_BAUD=1200
D_PARITY=E
D_DATA_BITS=7
D_STOP_BITS=1
HOT_KEY=1
ASCII_HOT=^A
D_DUPLEX=FULL
XFLOW_CTRL=XON/XOFF
CR_IN=CR
CR_OUT=CR
LOGFILE=pcomm.log
DUMPFILE=pcomm.dump
STRIP=YES
PAUSE_CHAR=~
CR_CHAR=!
CTRL_CHAR=^
XESC_CHAR=|
BRK_CHAR=%
ABORT=KEEP
C_DELAY=35
R_DELAY=5
LOCAL_ECHO=NO
XEXPAND=NO
CR_DELAY=0
PACE=NO
CR_UP=NONE
LF_UP=ADD CR
TIMER=5
CR_DN=STRIP
LF_DN=NONE
LD_PLUS=
LD_MINUS=
LD_AT=8,
LD_POUND=9
MAC_1=ls -alRF \| more!
MAC_2=
MAC_3=
MAC_4=
MAC_5=
MAC_6=
MAC_7=
MAC_8=
MAC_9=
MAC_0=
END_OF_FILE
if test 487 -ne `wc -c <'Pcomm.param'`; then
    echo shar: \"'Pcomm.param'\" unpacked with wrong size!
fi
# end of 'Pcomm.param'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(14243 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
X				  Pcomm
X		      A Unix Telecommunication Program
X
Things to do first:
X
X	1) Figure out what files you need.  There is a shell archive
X	called "Unixpc.shar" that contains additional (and replacement)
X	files for users of the AT&T Unix PC 7300/3b1.
X
X	2) Create a default directory where the Pcomm support files will
X	go.  A good location might be /usr/local/lib/pcomm.
X
X	3) Edit the Makefile to reflect the location of the default
X	directory (PCOMM_LIB), the location of the executable programs
X	(BIN_DIR), and the location and file extension of the on-line
X	manuals (MAN_DIR) and (MAN_EXT).
X
X	4) Install the four sample support files Pcomm.dial_dir,
X	Pcomm.extrnl, Pcomm.modem, and Pcomm.param to the default
X	directory by typing "make install_support".  Please remember
X	these are just sample files...
X
X	5) Install the on-line manual pages Pcomm.1, Pcomm_cmd.1,
X	Matches.1, and Waitfor.1 to the proper /usr/man directory by
X	typing "make install_man".  For those without access to nroff,
X	I've included the output files called Pcomm.out, Pcomm_cmd.out,
X	Matches.out, and Waitfor.out in the last shell archive.
X
X[ moderator's note: comp.sources.unix does not publish pre-formatted man pages;
X  if you need a man-page-formatter we suggest "groff" or henry spencer's cute
X  awk script that does a credible "nroff -man" imitation.		--vix ]
X
X	6) Print the Pcomm Reference Manual.  The Doc.me file is the
X	nroff input which should be run thru tbl and the "me" macro
X	package, as in:
X
X		tbl Doc.me | nroff -me -Twhatever | lp
X
X	For those without access to nroff, I've included the output file
X	called Doc.out in the last shell archive.
X
X[ moderator's note: see above.						--vix ]
X
X	The "me" macro package appears to be freely available and is
X	included in the Berkeley 4.3 public distribution.
X
How to compile Pcomm:
X
X	1) There is a shell script called "Configure.sh" that should
X	provide some information about your system.  It does *not* edit
X	the "Makefile" or" config.h" files...
X
X	2) Edit the "config.h" file to suit your system's needs and your
X	personal taste.  Sites running HoneyDanBer (HDB) UUCP should pay
X	particular attention to the LOCK_DIR and ASCII_PID definitions.
X	The definitions in config.h are:
X
X	BSD		Define if you're using a Berkeley flavor of Unix.
X			You will also have to edit the Makefile in
X			several places.
X
X	UNIXPC		If defined, use the dial(3) routines specific
X			to the AT&T Unix PC 7300/3b1.  Useful only if
X			the On Board Modem (OBM) is to be used.
X
X	OLDCURSES	If defined, use the older version of curses(3).
X			(uses termcap in lieu of terminfo).
X
X	NOPROMOTE	If defined, do not promote missing video
X			attributes to standout.  Normally, curses(3)
X			attempts to compensate for missing attributes.
X
X	LOG_CALLS	If defined, Pcomm will keep an administrative log
X			of all calls.  The log contains the name of the
X			person making the call, the phone number, and a
X			date/time stamp.  Useful for verifying long
X			distance phone bills.
X
X	LOGFILE		The path to the log file (if LOG_CALLS is
X			defined).  It should have write permission to
X			all or be writeable under set-user/group-id
X			conditions.
X
X	LIMIT_LD	If defined, Pcomm will limit long distance
X			(toll) calls to a privileged group.  The file
X			"admin.c" may require tweaking to detect long
X			distance numbers.
X
X	GROUP_NAME	The name of the group that is allowed to make
X			long distance calls (if LIMIT_LD is defined).
X
X	LPR		The path to the line printer program (this is
X			not the name of the device).
X
X	LPRINT		The path to the "pretty" line printer program.
X			If none exist, use "pr | lp".
X
X	DEFAULT_DIR	The path to the directory that contains the
X			default Pcomm support files.
X
X	LOCK_DIR	The path to the directory where the UUCP lock
X			files are found.  On HDB systems this would
X			probably be /usr/spool/locks.
X
X	ASCII_PID	If defined, the lock files will contain an ASCII
X			encoded process id (PID).  On HDB systems this
X			is the default.
X
X	XENIX_LOCKS	If defined, the last letter of the device name
X			is folded to lower case when creating the lock
X			file.  Newer version of XENIX may require this.
X
X	SVR4_LOCKS	If defined, the new UUCP lockfile format
X			introduced in SVR4 will be used.
X
X	XMC_BROKE	Does the status line scroll up when using "magic
X			cookie" terminals?  Some Pyramid and AT&T
X			systems may require this to be defined.  Find a
X			magic cookie terminal (a Wyse 50 for example),
X			and see what happens.
X
X	WGETCH_BROKE	Does the alarm() system call work correctly with
X			the wgetch() function?  Symptom:  the initial
X			screen doesn't go away by itself after 5
X			seconds.
X
X	O_NDELAY_BROKE	Does the fnctl() to turn off the O_NDELAY mode
X			sometimes fail to work?  Symptom: no response
X			from the modem.
X
X	CLIST_SIZ	The size of the serial port character buffer.
X			The default is 64.
X
X	INPUT_BUF	The size of the input buffer (should be about the
X			same size as CLIST_SIZ).  The default is 64.
X
X	OUTPUT_BUF	The size of the output buffer (should be about
X			one half INPUT_BUF).  The default is 32.  Systems
X			without dedicated I/O processors may require a
X			small INPUT_BUF value to avoid the problem of a
X			"choppy" display.
X
X	MEMMOVE		The name of the memory copy routine. The default
X			is memmove(), although memcpy() or bcopy() will
X			work (if they correctly handle target and source
X			overlap).
X
X	SETUID_BROKE	Does your version of Unix allow you to flip-flop
X			back and forth between the real and effective
X			user (or group) ID?  Some Masscomp systems will
X			require this to be set.
X
X	HAVE_STRSTR	Does your system have the strstr() function?
X			Most Berkeley systems will require this to be
X			#undef.
X
X	HAVE_USLEEP	Does your system have the usleep() function?
X			Most non-Sun system will require this to be
X			#undef.
X
X	HAVE_TRUNCATE	Does your system have the truncate() system call?
X			Most modern systems do.
X
X	3) Edit the Makefile.  There are provisions in the Makefile to
X	include getcwd(3) and getopt(3) routines if they are missing
X	from your system.  You may want to customize the CFLAGS and
X	LDFLAGS assignments to suit your needs.
X
X	If compiling under Berkeley Unix, you will have to edit the
X	Makefile on the following lines:
X
X		#for old curses(3) or Berkeley systems
X		CURSES = -lcurses -ltermcap
X		#CURSES = -lcurses
X
X		#for System V or Berkeley TTY interface
X		TTY.C = tty_ucb.c
X		TTY.O = tty_ucb.o
X		#TTY.C = tty_att.c
X		#TTY.O = tty_att.o
X
X		#for System V poll() or Berkeley select()
X		IPC.C = ipc_ucb.c
X		IPC.O = ipc_ucb.o
X		#IPC.C = ipc_att.c
X		#IPC.O = ipc_att.o
X
X	All the defaults in config.h assume a AT&T flavor of Unix, sorry
X	about that...
X
X	4) Compile pcomm.  Type "make".  The "make install" option will
X	attempt to copy "pcomm" into the BIN_DIR directory given in the
X	Makefile.  However, those sites running HDB UUCP software may
X	require that you to change the mode of "pcomm" to be set-user-id
X	to uucp.
X
X	Three external programs (pcomm_cmd, waitfor, and matches) are
X	included in the distribution to help in creating auto-login
X	shell scripts.
X
How to configure Pcomm:
X
X	Please remember that the Pcomm support files provided are just
X	examples.  They must be modification by you.
X
X        1) Determine the names of the devices that Pcomm will be using.
X        Pcomm must use the same device names that UUCP uses.  For
X        example, if your system has two names for the same device such
X        as "ttya" and "cua0", then use the one that UUCP uses, not the
X        one that getty uses.  Some systems use "tty01h" to designate a
X        bi-directional tty line used by both getty and UUCP.
X
X	2) Get out the books that came with your modems.  You're gonna
X	have to know a lot about your modems in order to configure them
X	correctly to suit both Pcomm's needs and the needs of your
X	getty/UUCP settings.
X
X	3) Here are the "real life" settings for my Telebit Worldblazer
X	on a Dell SVR4 box running uugetty.
X
X        My Telebit WorldBlazer modem for my dialin/dialout port is set
X        with the following commands.
X
X		&F 	Restores factory settings
X		L1	Low speaker volume
X		X2	Detailed result codes (connect speeds)
X		Q2	Turns on result codes only when dialing out
X		&C1	DCD follows the carrier
X		&D3	Hard reset on loss of DTR
X		S0=1	Answer on first ring
X		S7=60	60 second wait for carrier
X		S51=6	Interface speed set to 38400 bps
X		S58=2	Full duplex RTS/CTS flow control
X		S59=15	Result code extensions
X		S61=0	Pass modem breaks to the other end
X		&W	Save in NVM
X
X	AT&V
X	WorldBlazer - SA - Version LA5.00W- Active Configuration
X	 B1  E1  L1  M1  P   Q2  V1  X2  Y0 
X	&C1 &D3 &G0 &J0 &L0 &Q0 &R3 &S0 &T4 &X0 
X	S000:1   S001=0   S002=43  S003=13  S004=10  S005=8   S006=2   S007:60 
X	S008=2   S009=6   S010=14  S011=70  S012=50  S018=0   S025=5   S026=1  
X	S038=0   S041=0   S045=0   S046=0   S047=4   S048=0   S050=0   S051:6  
X	S056=17  S057=19  S058:2   S059:15  S060=0   S061:0   S062=15  S063=0  
X	S064=0   S068=255 S069=0   S090=0   S092=0   S093=8   S094=1   S100=0  
X	S104=0   S105=1   S111=255 S112=1   S151=4   S155=0   S180=2   S181=1  
X	S183=25  S190=1   S191=7   S253=10  S254=255 S255=255 
X
X	/usr/local/lib/pcomm/pcomm.modem:
X
X	TTY_1=tty01h;TELEBIT;38400
X	MODEM_1a=TELEBIT;ATZ!~~!;ATDT;!;~~+++~~ATH0!
X	MODEM_1b=Y;CONNECT 300;CONNECT 1200;CONNECT 2400;CONNECT 4800;CONNECT 9600;CONNECT FAST;
X	MODEM_1c=BUSY;NO CARRIER;NO DIALTONE;ERROR
X
X	/etc/uucp/Dialers:
X
X	wblazer   =W-,	"" \M\dATZ OK ATDT\T CONNECT \m\c
X
X	/etc/uucp/Devices:
X
X	ACU tty01h,M - 38400 wblazer
X
X	/etc/uucp/Systems:
X
X	system Any ACU 38400 5551212 "" \r ogin: mylogin assword: mypassword
X
X	/etc/inittab:
X
X	01h:23:respawn:/usr/lib/uucp/uugetty -t60 tty01h wblazer
X
X	/etc/gettydefs:
X
X	wblazer# B38400 SANE HUPCL # B38400 SANE IXANY TAB3 #login: #wblazer
X
X	4) Update the sample modem/TTY database.  I know I'm asking the
X	impossible, but...  Read section 3 and the Appendices of the Doc
X	file first.  Then run Pcomm to update the modem/TTY database by
X	using the TTY Setup and the Modem Setup menues.
X
X	5) There is a Question and Answer file (called Q_and_A) that may
X	help diagnose problems.
X
Portability considerations:
X
X	1) Pcomm makes use of the bold, blinking and standout video
X	attributes.  My concept of "standout" and "reverse" might be
X	different than yours (I like "standout" to be a brighter version
X	of "reverse").  Some very old versions of curses will ignore the
X	standout mode if you're on a magic cookie terminal.
X
X	2) The "port.c" file has a place where you can include your own
X	routine to toggle the getty process on a port (if required).
X
X	3) If you compile Pcomm with LOG_CALLS defined, you'll have to
X	look at the code in "admin.c" to see if the long distance
X	detection routine is correct for your site.
X
X	4) There is a "typedef SIG_TYPE" in the config.h file to help
X	silence the compiler's warning messages about the signal()
X	return value.
X
Notes for Sun users...  There are several problems that apparently only
surface with SunOS 4.x.  Here are some notes to help out.
X
X        1) Pcomm was really designed to work in an AT&T world.  If you
X        compile the code with the /usr/5bin/cc compiler, you'll end up
X        with a better product.  To do so, you'll need to use default
X        AT&T parameters in config.h (undef OLDCURSES and undef BSD, etc)
X        plus the default AT&T parameters in Makefile for (CURSES, TTY.C,
X        and TTY.O).  You'll also have to change the CC and LD variables
X        in the Makefile to reflect /usr/5bin/cc.
X
X        However, SunOS 4.x doesn't like the AT&T versions of IPC.C and
X        IPC.O, so use the Berkely ones.  This is contrary to what the
X        Configure.sh script will tell you!  Perhaps SunOS 5.0 will fix
X        all this...
X
X        2) SunOS 4.x no longer supports the AT&T version of the times()
X        system call, so usleep() should be used to generate the delay.
X	Edit config.h to #define HAVE_USLEEP.
X
Notes for some 4.2BSD and Ultrix 1.2 systems:
X
X	Apparently, there is a bug in the /usr/include/curses.h file on
X	some systems that does not define the nl() and nonl() macros
X	correctly.  If this is the case with your system, edit
X	/usr/include/curses.h to include the following:
X
X	#undef nl
X	#undef nonl
X	#define nl()	(_tty.sg_flags |= CRMOD,_pfast = _rawmode,stty(_tty_ch, &_tty))
X	#define nonl()	(_tty.sg_flags &= ~CRMOD, _pfast = TRUE, stty(_tty_ch, &_tty))
X
Notes for some 386 versions of Unix:
X
X        It seems that a lot of the early versions of Unix for "DOS
X        boxes" have bugs in their terminfo database for AT386 (the
X        default terminal type).  Here is one that works:
X
AT386|at386|386AT|386at|at/386 console,
X	am, eo, xon,
X	colors#8, cols#80, lines#25, ncv#3, pairs#64,
X	acsc=``a1fxgqh0jYk?lZm@nEooppqDrrsstCu4vAwBx3yyzz{{||}}~~,
X        bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z, clear=\E[2J\E[H,
X        cr=\r, cub=\E[%p1%dD, cub1=\E[D, cud=\E[%p1%dB, cud1=\E[B,
X        cuf=\E[%p1%dC, cuf1=\E[C, cup=\E[%i%p1%02d;%p2%02dH,
X        cuu=\E[%p1%dA, cuu1=\E[A, dch=\E[%p1%dP, dch1=\E[P, dim=\E[8;1m,
X        dl=\E[%p1%dM, dl1=\E[1M, ech=\E[%p1%dX, ed=\E[J, el=\E[K,
X        el1=\E[1K\E[X, flash=^G, home=\E[H, hpa=\E[%i%p1%dG,
X        ich=\E[%p1%d@, ich1=\E[1@, il=\E[%p1%dL, il1=\E[1L, ind=\E[S,
X        indn=\E[%p1%dS, invis=\E[8m, is2=\E[0;10, kbs=\b, kcbt=^],
X        kclr=\E[2J, kcub1=\E[D, kcud1=\E[B, kcuf1=\E[C, kcuu1=\E[A,
X        kdch1=^?, kend=\E[Y, kf1=\EOP, kf10=\EOY, kf11=\EOZ, kf12=\EOA,
X        kf2=\EOQ, kf3=\EOR, kf4=\EOS, kf5=\EOT, kf6=\EOU, kf7=\EOV,
X        kf8=\EOW, kf9=\EOX, khome=\E[H, kich1=\E[@, knp=\E[U, kpp=\E[V,
X        krmir=\E0, op=\E[0m, pfx=\EQ%p1%{1}%-%d'%p2%s', rev=\E[7;1m,
X        ri=\E[T, rin=\E[%p1%dT, rmacs=\E[10m, rmso=\E[m, rs1=\E[0;10m,
X        setab=\E[4%p1%dm, setaf=\E[3%p1%dm,
X        setb=\E[4%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
X        setf=\E[3%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
X        sgr=\E[10m\E[0%?%p1%p3%|%t;7%;%?%p2%t;4%;%?%p4%t;5%;%?%p6%t;1%;%?%p9%t;12%;%?%p7%t;9%;m,
X        sgr0=\E[0;10m, smacs=\E[12m, smso=\E[7m,
X
XEmmet P. Gray				US Army, HQ III Corps & Fort Hood
X...!uunet!uiucuxc!fthood!egray		Attn: AFZF-DE-ENV
fthood!egray@uxc.cso.uiuc.edu		Directorate of Engineering & Housing
X					Environmental Management Office
X					Fort Hood, TX 76544-5057
END_OF_FILE
if test 14243 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'Release.notes' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Release.notes'\"
else
echo shar: Extracting \"'Release.notes'\" \(2639 characters\)
sed "s/^X//" >'Release.notes' <<'END_OF_FILE'
Patch #2, 6 Nov 92
X
This patch will fix a few problems with possible loss of the inherited
environment for child processes, and a bug in the data and print logging
when used during scripts.
X
X-----------------------------------------------------------------------------
Patch #1, 6 Sep 92
X
This patch will correct a minor bug with the external protocol option
X(when running under SVR3.2) that prevented Pcomm from detecting the
death of the child process.
X
The rather large size of this patch is do to the numerous changes to the
Doc.me file.
X
X------------------------------------------------------------------------------
X			     Pcomm version 2.0
X				 18 Jul 92
X
Compatibilities with v1.2:
X
X	The pcomm.modem and pcomm.param support files under v1.2 are not
X	compatible with the new release.  There is a shell script called
X	Convert.sh that will convert these files to the new format.
X
X	The Script/TTY field of the dialing directory is now called
X	the Auxiliary field.  It now has one of three functions...
X		1) to specify a script to be played
X		2) to force a particular TTY to be selected
X		3) to select a modem configuration
X
Things that have changed:
X
X        This version of Pcomm requires a pseudo-tty driver and System V
X        poll() or Berkeley select().  Pre-SRV3.2 versions of AT&T Unix
X        are out-of-luck...  sorry.
X
X	There is a shell script called Configure.sh that will help you
X	to configure Pcomm correctly for your system.  I've added a
X	Q_and_A file to provide help on diagnosing common problems.
X	
X	There is no longer a "pcomm_input" program, those functions are
X	now supported by the use of multiplexed I/O within the "pcomm"
X	program.  The external "modem_break" command has been removed.
X	You might want to "search and destroy" those binaries.
X
X	A new external command called "pcomm_cmd" has been added to
X	allow "true" scripting capabilities.  There is a manual page for
X	pcomm_cmd that further describes its features.
X
X        Each dialing directory entry can specify a modem configuration
X        via the newly renamed Auxiliary field.  This allows you to
X        tailor the modem to match what is expected at the other end of
X        the connection.
X
X        Pcomm now supports DTE baud rates up to 38400 plus "connected"
X        baud rates for V.32bis (7200, 12000, and 14400).
X
XFuture directions:
X
X	Add zmodem as an internal protocol, since Omen Technologies
X	deliberately broke sz/rz so that it wouldn't work from inside 
X	another program.
X
X        Add the ability to "dial into" a machine via a network LAN
X        rather than the serial port.
X
X	xpcomm - a version of Pcomm using the X window toolkits.
END_OF_FILE
if test 2639 -ne `wc -c <'Release.notes'`; then
    echo shar: \"'Release.notes'\" unpacked with wrong size!
fi
# end of 'Release.notes'
fi
if test -f 'Sample' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Sample'\"
else
echo shar: Extracting \"'Sample'\" \(1004 characters\)
sed "s/^X//" >'Sample' <<'END_OF_FILE'
X:
X#
X# This is a sample Bourne shell script to log a user onto a remote system.
X# Things to remember:
X#	1) Script files should have permissions of 700, to prevent others
X#	from gaining access to your passwords to remote systems.
X#	2) The return codes for waitfor are: 0=success, 1=timed out, and
X#	-1=error.
X#
echo ""
try=0
X# loop until done
while true
do
X	# wait 5 seconds for the login prompt
X	waitfor -5 ogin:
X	# test the exit code of the waitfor command
X	if [ "$?" -eq 0 ]
X	then
X		# send my user ID and exit the loop
X		echo "egray"
X		break
X	fi
X
X	# increment the number of attempts
X	try=`expr $try + 1`
X	# test to see if we should give up
X	if [ "$try" -eq 5 ]
X	then
X		exit 1
X	fi
X
X	# send a modem break and loop again
X	pcomm_cmd modem_break
X	echo ""
done
X# wait 5 seconds for the password prompt
waitfor -5 assword:
X# test the return code from waifor
if [ "$?" -eq 0 ]
then
X	# send my password (you're crazy if you think that's my real password)
X	echo "abcdefg"
else
X	exit 1
fi
X# return to Pcomm
exit 0
END_OF_FILE
if test 1004 -ne `wc -c <'Sample'`; then
    echo shar: \"'Sample'\" unpacked with wrong size!
fi
# end of 'Sample'
fi
if test -f 'Waitfor.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Waitfor.1'\"
else
echo shar: Extracting \"'Waitfor.1'\" \(888 characters\)
sed "s/^X//" >'Waitfor.1' <<'END_OF_FILE'
X.TH waitfor L
X.SH NAME
waitfor \- wait for a string to appear on the stdin
X.SH SYNOPSIS
X.B waitfor
X[
X.B \-n
X]
X.B string
X.SH DESCRIPTION
X.I Waitfor
reads the standard input and returns a 0 if the string argument is
found, returns a 1 if the strings did not appear within the allotted
time, or returns a \-1 on error.  If the string is found,
X.I waitfor
returns immediately.
X.PP
X.I Waitfor
is designed to be used by
X.I Pcomm
inside a shell script for automating keyboard input to log a user onto a
remote system.
X.PP
The
X.I \-n
option is used to specify the length of time in seconds to wait.  The
default is 10 seconds.
X.SH EXAMPLE
X.nf
X.RS 5
X# wait 5 seconds for the login prompt
waitfor \-5 login:
X# test the exit code of the waitfor command
if [ $? \-eq 0 ]
then
X.RS 5
X# send my user ID
echo egray
X.RE
fi
X.RE
X.fi
X.SH "SEE ALSO"
pcomm(1), pcomm_cmd(1), matches(1), Pcomm Reference Manual
END_OF_FILE
if test 888 -ne `wc -c <'Waitfor.1'`; then
    echo shar: \"'Waitfor.1'\" unpacked with wrong size!
fi
# end of 'Waitfor.1'
fi
if test -f 'chg_dir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'chg_dir.c'\"
else
echo shar: Extracting \"'chg_dir.c'\" \(1514 characters\)
sed "s/^X//" >'chg_dir.c' <<'END_OF_FILE'
X/*
X * Open a window to prompt for a new directory.  Checks to see you have
X * search permission.
X */
X
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X
void
chg_dir()
X{
X	extern int fd;
X	WINDOW *ch_win, *newwin();
X	char *ans, *dir, *expand(), *cwd, *getcwd(), cwdbuf[200];
X	char *get_str();
X
X	cwd = getcwd(cwdbuf, 200);
X
X	ch_win = newwin(6, 70, 5, 5);
X
X	mvwprintw(ch_win, 2, 4, "Current directory: %s", cwd);
X	mvwaddstr(ch_win, 3, 4, "New directory: ");
X	box(ch_win, VERT, HORZ);
X
X	mvwattrstr(ch_win, 0, 3, A_BOLD, " Change Directory ");
X	wmove(ch_win, 3, 19);
X	wrefresh(ch_win);
X					/* get the answer */
X	while ((ans = get_str(ch_win, 80, "", " \t\n")) != NULL) {
X					/* a CR means no change */
X		if (*ans == '\0')
X			break;
X					/* expand the input */
X		dir = expand(ans);
X					/* if you have search permission */
X		if (!access(dir, 1)) {
X			if (!chdir(dir))
X				break;
X		}
X		beep();
X		mvwattrstr(ch_win, 4, 15, A_BOLD, "No such directory or no access permission");
X		wrefresh(ch_win);
X		wait_key(ch_win, 3);
X					/* clean up the mess */
X		clear_line(ch_win, 3, 19, TRUE);
X		clear_line(ch_win, 4, 14, TRUE);
X		wmove(ch_win, 3, 19);
X		wrefresh(ch_win);
X	}
X	if (fd == -1) {
X		werase(ch_win);
X		wrefresh(ch_win);
X	}
X	delwin(ch_win);
X	return;
X}
X
X#ifdef BSD
X/*
X * Get the current working directory, AT&T style.  Well... not really, it
X * doesn't handle a NULL pointer for the buffer.
X */
X
X/* ARGSUSED */
char *
getcwd(buf, len)
char *buf;
int len;
X{
X	char *getwd();
X
X	return(getwd(buf));
X}
X#endif /* BSD */
END_OF_FILE
if test 1514 -ne `wc -c <'chg_dir.c'`; then
    echo shar: \"'chg_dir.c'\" unpacked with wrong size!
fi
# end of 'chg_dir.c'
fi
if test -f 'cmd.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cmd.h'\"
else
echo shar: Extracting \"'cmd.h'\" \(2290 characters\)
sed "s/^X//" >'cmd.h' <<'END_OF_FILE'
X/*
X * Definitions for the pcomm_cmd program used inside script files.
X */
X
X/* the commands */
X
X#define SET		0	/* set a parameter */
X#define QUERY		1	/* ask a "string" question */
X#define IF		2	/* ask a binary question */
X#define DIAL		3	/* dial */
X#define REDIAL		4	/* redial queue */
X#define EXIT		5	/* exit Pcomm */
X#define CLEAR_SCREEN	6	/* clear the local screen */
X#define CHG_DIR		7	/* change the local directory */
X#define HANG_UP		8	/* hang up the phone */
X#define PRINTER		9	/* control printer logging */
X#define MODEM_BREAK	10	/* send a modem break */
X#define SEND		11	/* send a file */
X#define RECEIVE		12	/* recieve a file */
X#define SCREEN_DUMP	13	/* dump the screen contents to a file */
X#define DATA_LOG	14	/* control data logging */
X
X/* the SET arguments */
X
X#define BAUD		0	/* baud rate */
X#define PARITY		1	/* parity (EVEN, ODD, or NONE) */
X#define DATA_BITS	2	/* data bits (7 or 8) */
X#define STOP_BITS	3	/* stop bits (1 or 2) */
X#define DUPLEX		4	/* duplex mode (FULL or HALF) */
X#define AUX		5	/* the name of the auxiliary file */
X#define HOT_KEY		6	/* the "hot" key (numeric) */
X#define ASCII_HOT	7	/* ascii representation of hot key */
X#define FLOW_CTRL	8	/* flow control (XON/XOFF or NONE) */
X#define CR_IN		9	/* send as carriage return */
X#define CR_OUT		10	/* receive carriage return as */
X#define LOGFILE		11	/* default log file */
X#define DUMPFILE	12	/* default screen dump file */
X#define STRIP		13	/* strip high bit (translate table) */
X#define LOCAL_ECHO	14	/* ASCII xfer - echo locally? */
X#define EXPAND		15	/* ASCII xfer - expand blank lines? */
X#define CR_DELAY	16	/* ASCII xfer - carriage return delay (ms) */
X#define PACE		17	/* ASCII xfer - pace the output? */
X#define CR_UP		18	/* ASCII xfer - send carriage return as */
X#define LF_UP		19	/* ASCII xfer - send line feed as */
X#define TIMER		20	/* ASCII xfer - transfer timeout */
X#define CR_DN		21	/* ASCII xfer - receive carriage return as */
X#define LF_DN		22	/* ASCII xfer - receive line feed as */
X
X/* the QUERY arguments */
X#define TTY_NAME	0	/* what is the current tty? */
X#define MODEM_NAME	1	/* what modem do we have? */
X
X/* the IF arguments */
X
X#define CONNECTED	0	/* are we connected? */
X#define LOG_STATUS	1	/* status of log option */
X#define PRINTER_STATUS	2	/* status of print option */
X
END_OF_FILE
if test 2290 -ne `wc -c <'cmd.h'`; then
    echo shar: \"'cmd.h'\" unpacked with wrong size!
fi
# end of 'cmd.h'
fi
if test -f 'config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h'\"
else
echo shar: Extracting \"'config.h'\" \(2452 characters\)
sed "s/^X//" >'config.h' <<'END_OF_FILE'
X/*
X * Various tunable parameters.  This should appear before any other local
X * header file.
X */
X
X/* Are you using a Berkeley flavor of Unix? */
X#undef	BSD
X
X/* Use the dialing routines specific to the AT&T Unix PC 7300/3b1 */
X#undef	UNIXPC
X
X/* Older versions of curses(3) use termcap in lieu of terminfo */
X#undef	OLDCURSES
X
X/* Should a missing video attribute be promoted to standout? */
X#define	NOPROMOTE
X
X/* Should Pcomm make a log of all phone calls? */
X#undef	LOG_CALLS
X
X/* The name of the log file (if used).  */
X#define	LOG_FILE	"/usr/adm/phone.calls"
X
X/* Should long distance (toll) calls be limited to a specific group? */
X#undef	LIMIT_LD
X
X/* The name of the privileged group for limiting long distance calls */
X#define	GROUP_NAME	"uucp"
X
X/* The path to the line printer program */
X#define	LPR		"lp -s"
X
X/* The path to the "pretty" printer program (if none, use "pr | lp") */
X#define	LPRINT		"pr | lp -s"
X
X/* The path to the default directory containing the Pcomm support files */
X#define	DEFAULT_DIR	"/usr/local/lib/pcomm"
X
X/* The path to the directory where UUCP locks are found */
X#define	LOCK_DIR	"/var/spool/locks"
X
X/* Do the lock files use ASCII encoded PID's? */
X#define	ASCII_PID
X
X/* Fold the last character of the lock to lower case? */
X#undef	XENIX_LOCKS
X
X/* Use the new SVR4 lock format? */
X#define	SVR4_LOCKS
X
X/* Does the status line scroll up on "magic cookie" terminals? */
X#undef	XMC_BROKE
X
X/* Does the alarm() system call work correctly with the wgetch() function? */
X#undef	WGETCH_BROKE
X
X/* Does the O_NDELAY mode tend to stick around when asked to leave? */
X#undef	O_NDELAY_BROKE
X
X/* The size of the serial port character buffer (or Stream buffer) */
X#define	CLIST_SIZ	64
X
X/* The size of the input buffer (should be about the same as CLIST_SIZ) */
X#define	INPUT_BUF	64
X
X/* The size of the output buffer (should be about one half INPUT_BUF) */
X#define	OUTPUT_BUF	32
X
X/* Does memmove() exist or is memcpy() well behaved when overlapping? */
X#define	MEMMOVE(a,b,c)	memmove(a,b,c)
X/* #define	MEMMOVE(a,b,c)	memcpy(a,b,c) */
X/* #define	MEMMOVE(a,b,c)	bcopy(b,a,c) */
X
X/* Does your Unix allow flip-flop between real and effective user IDs? */
X#undef	SETUID_BROKE
X
X/* Does your system have the strstr() function? */
X#define	HAVE_STRSTR
X
X/* Does your system have the usleep() function? */
X#undef	HAVE_USLEEP
X
typedef void SIG_TYPE;
X/* typedef int SIG_TYPE; */
X
X#ifdef BSD
X#define	strchr	index
X#define	strrchr	rindex
X#endif /* BSD */
END_OF_FILE
if test 2452 -ne `wc -c <'config.h'`; then
    echo shar: \"'config.h'\" unpacked with wrong size!
fi
# end of 'config.h'
fi
if test -f 'd_delete.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'d_delete.c'\"
else
echo shar: Extracting \"'d_delete.c'\" \(2005 characters\)
sed "s/^X//" >'d_delete.c' <<'END_OF_FILE'
X/*
X * The delete option of the dialing directory.  Prompts for saving
X * changes to disk.  A non-zero return code means that entries were deleted.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "dial_dir.h"
X#include "misc.h"
X#include "param.h"
X
int
delete()
X{
X	extern char *null_ptr;
X	WINDOW *d_win, *newwin();
X	int i, first, last;
X	void free_ptr();
X
X	d_win = newwin(6, 32, 10, 15);
X
X	mvwaddstr(d_win, 2, 2, "Delete entry:     thru:");
X	box(d_win, VERT, HORZ);
X	wmove(d_win, 2, 16);
X	wrefresh(d_win);
X					/* get the first of the range */
X	while ((first = get_num(d_win, 3)) != -1) {
X		if (first > 0 && first <= NUM_DIR)
X			break;
X		mvwaddstr(d_win, 2, 16, "   ");
X		wmove(d_win, 2, 16);
X		beep();
X		wrefresh(d_win);
X	}
X	if (first == -1) {
X		delwin(d_win);
X		return(0);
X	}
X					/* get the last of the range */
X	wmove(d_win, 2, 26);
X	wrefresh(d_win);
X	while ((last = get_num(d_win, 3)) != -1) {
X		if ((first <= last && last <= NUM_DIR) || last == 0)
X			break;
X		mvwaddstr(d_win, 2, 26, "   ");
X		wmove(d_win, 2, 26);
X		beep();
X		wrefresh(d_win);
X	}
X	if (last == -1) {
X		delwin(d_win);
X		return(0);
X	}
X					/* if "last" omitted, echo "first" */
X	if (!last) {
X		last = first;
X		mvwprintw(d_win, 2, 26, "%d", first);
X		wrefresh(d_win);
X	}
X					/* save to disk? */
X	if (yes_prompt(d_win, 3, 2, A_BOLD, "Are you sure")) {
X					/* delete from the physical file */
X		if (del_dir(first, last)) {
X			touchwin(d_win);
X			wrefresh(d_win);
X		}
X		/*
X		 * We don't really care if del_dir() fails because we still
X		 * change the version in memory.
X		 */
X		for (i=first; i<=last; i++) {
X			free_ptr(dir->name[i]);
X			free_ptr(dir->number[i]);
X			free_ptr(dir->aux[i]);
X			dir->name[i] = null_ptr;
X			dir->number[i] = null_ptr;
X			dir->baud[i] = param->d_baud;
X			dir->parity[i] = param->d_parity;
X			dir->data_bits[i] = param->d_data_bits;
X			dir->stop_bits[i] = param->d_stop_bits;
X			dir->duplex[i] = *param->d_duplex;
X			dir->aux[i] = null_ptr;
X		}
X		delwin(d_win);
X		return(1);
X	}
X	delwin(d_win);
X	return(0);
X}
END_OF_FILE
if test 2005 -ne `wc -c <'d_delete.c'`; then
    echo shar: \"'d_delete.c'\" unpacked with wrong size!
fi
# end of 'd_delete.c'
fi
if test -f 'd_manual.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'d_manual.c'\"
else
echo shar: Extracting \"'d_manual.c'\" \(1951 characters\)
sed "s/^X//" >'d_manual.c' <<'END_OF_FILE'
X/*
X * The manual dial option of the dialing directory.  A non-zero return code
X * means we're ready to dial.  Dialing directory entry 0 is reserved
X * for the manual dial option.  No sanity checking is done on the input.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "dial_dir.h"
X#include "misc.h"
X
static void fix_xmc();
X
int
manual()
X{
X	extern int xmc;
X	extern char *null_ptr;
X	WINDOW *m_win, *newwin();
X	char *number, *str_rep(), *get_str(), *strchr();
X	void free_ptr();
X
X	m_win = newwin(5, 50, 0, 20);
X
X	box(m_win, VERT, HORZ);
X	mvwaddstr(m_win, 2, 3, "Phone Number: ");
X	wrefresh(m_win);
X					/* get a phone number */
X	if ((number = get_str(m_win, 30, "", "\n")) == NULL) {
X		werase(m_win);
X		wrefresh(m_win);
X		delwin(m_win);
X		if (xmc > 0)
X			fix_xmc();
X		return(0);
X	}
X					/* is first char an LD code? */
X	dir->q_ld[0] = '\0';
X	if (strchr("+-@#", *number)) {
X		dir->q_ld[0] = *number;
X		number++;
X	}
X					/* put it in the queue */
X	dir->q_num[0] = 0;
X	dir->q_num[1] = -1;
X	dir->d_cur = 0;
X					/* build the entry zero */
X	dir->name[0] = str_rep(dir->name[0], number);
X	free_ptr(dir->aux[0]);
X	dir->aux[0] = null_ptr;
X					/* if space, change to null_ptr */
X	if (!strcmp(number, " ")) {
X		free_ptr(dir->number[0]);
X		dir->number[0] = null_ptr;
X	}
X	else
X		dir->number[0] = str_rep(dir->number[0], number);
X					/* it overlaps dm_win, so erase it */
X	werase(m_win);
X	wrefresh(m_win);
X	delwin(m_win);
X	if (xmc > 0)
X		fix_xmc();
X	return(1);
X}
X
X/*
X * Clear the end of the physical screen where the magic cookie got shifted
X * Geez, I hate magic cookie terminals...  Wyse, are you listening?
X */
X
static void
fix_xmc()
X{
X	WINDOW *cl_win, *newwin();
X
X	/*
X	 * Since the cookie got shifted off the window, we have to
X	 * create a new window to cover where the cookie ended up.
X	 */
X	cl_win = newwin(1, 2, 4, 78);
X					/* have to touch, otherwise nothing! */
X	touchwin(cl_win);
X	wrefresh(cl_win);
X	delwin(cl_win);
X
X	return;
X}
END_OF_FILE
if test 1951 -ne `wc -c <'d_manual.c'`; then
    echo shar: \"'d_manual.c'\" unpacked with wrong size!
fi
# end of 'd_manual.c'
fi
if test -f 'data_log.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data_log.c'\"
else
echo shar: Extracting \"'data_log.c'\" \(1475 characters\)
sed "s/^X//" >'data_log.c' <<'END_OF_FILE'
X/*
X * Open a window to prompt for a path name to be used for the data logging
X * feature.  Also turns on the data logging.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "misc.h"
X#include "param.h"
X#include "status.h"
X
void
data_logging()
X{
X	extern int fd;
X	WINDOW *dl_win, *newwin();
X	char *ans, *path, *expand(), *get_str(), *str_rep();
X	void log_toggle();
X
X	dl_win = newwin(6, 70, 5, 5);
X
X	mvwprintw(dl_win, 2, 4, "Default log file: %s", param->logfile);
X	mvwaddstr(dl_win, 3, 4, "New log file: ");
X	box(dl_win, VERT, HORZ);
X
X	mvwattrstr(dl_win, 0, 3, A_BOLD, " Start Data Logging ");
X	wmove(dl_win, 3, 18);
X	wrefresh(dl_win);
X					/* get the path */
X	while ((ans = get_str(dl_win, 128, "", " \t\n")) != NULL) {
X					/* give 'em the default */
X		if (*ans == '\0')
X			path = param->logfile;
X		else
X			path = expand(ans);
X
X					/* test write permission */
X		if (can_write(path)) {
X			status->log_path = str_rep(status->log_path, path);
X			/* 
X			 * If already on, then cycle it off to close
X			 * the old (and perhaps different) logfile.
X			 */
X			if (status->log_status)
X				log_toggle();
X			log_toggle();
X			break;
X		}
X
X		beep();
X		mvwattrstr(dl_win, 4, 24, A_BOLD, "No write permission");
X		wrefresh(dl_win);
X		wait_key(dl_win, 3);
X					/* clean up the mess */
X		clear_line(dl_win, 3, 18, TRUE);
X		clear_line(dl_win, 4, 24, TRUE);
X		wmove(dl_win, 3, 18);
X		wrefresh(dl_win);
X	}
X	if (fd == -1) {
X		werase(dl_win);
X		wrefresh(dl_win);
X	}
X	delwin(dl_win);
X
X	return;
X}
END_OF_FILE
if test 1475 -ne `wc -c <'data_log.c'`; then
    echo shar: \"'data_log.c'\" unpacked with wrong size!
fi
# end of 'data_log.c'
fi
if test -f 'di_delay.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'di_delay.c'\"
else
echo shar: Extracting \"'di_delay.c'\" \(1958 characters\)
sed "s/^X//" >'di_delay.c' <<'END_OF_FILE'
X/*
X * Prompt for new delay times during a dialing session.  Also, prompts
X * if changes should be saved to disk.  Dialing is suspended during
X * this routine.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "misc.h"
X#include "param.h"
X
void
delay_times()
X{
X	WINDOW *dt_win, *newwin();
X	int cdelay, rdelay;
X
X	dt_win = newwin(9, 45, 7, 15);
X
X	mvwprintw(dt_win, 2, 4, "Current connect delay time: %d", param->c_delay);
X	mvwprintw(dt_win, 3, 4, "Current redial delay time: %d", param->r_delay);
X	mvwaddstr(dt_win, 5, 4, "New connect delay: ");
X	mvwaddstr(dt_win, 6, 4, "New redial delay: ");
X	box(dt_win, VERT, HORZ);
X
X	mvwattrstr(dt_win, 0, 3, A_BOLD, " Change Delay Times ");
X	wmove(dt_win, 5, 23);
X	wrefresh(dt_win);
X					/* get the cdelay number */
X	if ((cdelay = get_num(dt_win, 3)) == -1) {
X		delwin(dt_win);
X		return;
X	}
X					/* give 'em the current settings */
X	if (!cdelay) {
X		cdelay = param->c_delay;
X		wprintw(dt_win, "%-3d", cdelay);
X	}
X	else {
X					/* some reasonable limit */
X		if (cdelay > MAX_CDELAY || cdelay < MIN_CDELAY) {
X			beep();
X			if (cdelay > MAX_CDELAY)
X				cdelay = MAX_CDELAY;
X			else
X				cdelay = MIN_CDELAY;
X			mvwprintw(dt_win, 5, 23, "%-3d", cdelay);
X		}
X	}
X					/* get the rdelay number */
X	wmove(dt_win, 6, 22);
X	wrefresh(dt_win);
X	if ((rdelay = get_num(dt_win, 3)) == -1) {
X		delwin(dt_win);
X		return;
X	}
X					/* give 'em the current settings */
X	if (!rdelay) {
X		rdelay = param->r_delay;
X		wprintw(dt_win, "%-3d", rdelay);
X	}
X	else {
X					/* some reasonable limit */
X		if (rdelay > MAX_PAUSE || rdelay < MIN_PAUSE) {
X			beep();
X			if (rdelay > MAX_PAUSE)
X				rdelay = MAX_PAUSE;
X			else
X				rdelay = MIN_PAUSE;
X			mvwprintw(dt_win, 6, 22, "%-3d", rdelay);
X		}
X	}
X					/* set 'em */
X	param->c_delay = cdelay;
X	param->r_delay = rdelay;
X					/* save 'em to disk? */
X	if (yes_prompt(dt_win, 7, 12, A_BOLD, "Save to disk")) {
X		if (up_param()) {
X			touchwin(dt_win);
X			wrefresh(dt_win);
X		}
X	}
X
X	delwin(dt_win);
X	return;
X}
END_OF_FILE
if test 1958 -ne `wc -c <'di_delay.c'`; then
    echo shar: \"'di_delay.c'\" unpacked with wrong size!
fi
# end of 'di_delay.c'
fi
if test -f 'dial_dir.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dial_dir.h'\"
else
echo shar: Extracting \"'dial_dir.h'\" \(958 characters\)
sed "s/^X//" >'dial_dir.h' <<'END_OF_FILE'
X/*
X * The dialing directory structure.  The first eight elements are
X * contained in the pcomm.dial_dir file.
X */
X
X#define NUM_DIR		100
X#define NUM_QUEUE	10
X#define FAST		0
X#define SLOW		1
X#define QUIET		0
X#define VERBOSE		1
X
struct DIAL_DIR {
X	char	*name[NUM_DIR+1];	/* name of system being called */
X	char	*number[NUM_DIR+1];	/* phone number */
X	unsigned int	baud[NUM_DIR+1];/* baud rate */
X	char	parity[NUM_DIR+1];	/* parity */
X	int	data_bits[NUM_DIR+1];	/* data bits */
X	int	stop_bits[NUM_DIR+1];	/* stop bits */
X	char	duplex[NUM_DIR+1];	/* duplex (F = full, H = half) */
X	char	*aux[NUM_DIR+1];	/* auxiliary (script, TTY, or modem) */
X
X	int	q_num[NUM_QUEUE];	/* entry numbers in the queue */
X	char	q_ld[NUM_QUEUE];	/* LD codes in the queue */
X
X	int	d_entries;		/* number of entries in the file */
X	int	d_cur;			/* the current entry */
X
X	char	*d_path;		/* path to the pcomm.dial_dir file */
X};
X
X#ifndef MAIN
extern struct DIAL_DIR *dir;
X#endif /* MAIN */
END_OF_FILE
if test 958 -ne `wc -c <'dial_dir.h'`; then
    echo shar: \"'dial_dir.h'\" unpacked with wrong size!
fi
# end of 'dial_dir.h'
fi
if test -f 'expand.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'expand.c'\"
else
echo shar: Extracting \"'expand.c'\" \(2891 characters\)
sed "s/^X//" >'expand.c' <<'END_OF_FILE'
X/*
X * Do file name expansion with "native" shell.  Using the native shell
X * (as described in the SHELL environmental variable) allows for csh or
X * ksh abbreviations that sh doesn't recognize.  Returns a pointer to
X * a static area.
X */
X
X#define EXPAND_BUF	2048
X
X#include <stdio.h>
X#include <signal.h>
X#include <fcntl.h>
X#include "config.h"
X
X#ifdef BSD
X#include <sys/file.h>
X#endif /* BSD */
X
char *
expand(input)
char *input;
X{
X	extern char *null_ptr;
X	FILE *pfp, *n_popen();
X	int last;
X	char buf[1024], *strpbrk(), *strcpy();
X	static char ans[EXPAND_BUF];
X
X					/* same rules as str_dup() */
X	if (input == NULL)
X		return(NULL);
X	if (*input == '\0')
X		return(null_ptr);
X					/* any thing to expand? */
X	if (!strpbrk(input, "$*{}[]\\?~")) {
X		strcpy(ans, input);
X		return(ans);
X	}
X					/* popen an echo */
X	sprintf(buf, "echo %s", input);
X
X	pfp = n_popen(buf, "r");
X	fgets(ans, EXPAND_BUF, pfp);
X	n_pclose(pfp);
X
X	if (!strlen(ans)) {
X		strcpy(ans, input);
X		return(ans);
X	}
X	/*
X	 * A horrible kludge...  if the last character is not a line
X	 * feed, then the csh has returned an error message.  Otherwise
X	 * zap the line feed.
X	 */
X	last = strlen(ans) -1;
X	if (ans[last] != '\n') {
X		strcpy(ans, input);
X		return(ans);
X	}
X	else
X		ans[last] = '\0';
X
X	return(ans);
X}
X
X#define	tst(a,b) (*mode == 'r'? (b) : (a))
X#define	RDR	0
X#define	WTR	1
static int popen_pid[20];
X
XFILE *
n_popen(cmd, mode)
char *cmd, *mode;
X{
X	int myside, hisside, ppid, p[2];
X	char *shellpath, *shell, *flags, *getenv(), *strrchr();
X	void _exit();
X
X	if (pipe(p) < 0)
X		return NULL;
X
X	myside = tst(p[WTR], p[RDR]);
X	hisside = tst(p[RDR], p[WTR]);
X					/* get the environmental variable */
X	shellpath = getenv("SHELL");
X	if (shellpath == NULL || *shellpath == '\0')
X		shellpath = "/bin/sh";
X
X	if (shell = strrchr(shellpath, '/'))
X		shell++;
X	else {
X		shellpath = "/bin/sh";
X		shell = "sh";
X	}
X					/* fix up the flags */
X	if (!strcmp(shell, "csh"))
X		flags = "-fc";
X	else
X		flags = "-c";		/* Korn shell too */
X
X	if (!(ppid = fork())) {
X		int stdio;
X					/* no error messages please */
X		close(2);
X		open("/dev/null", O_WRONLY);
X
X		setgid(getgid());
X		setuid(getuid());
X
X		stdio = tst(0, 1);
X		close(myside);
X		close(stdio);
X		fcntl(hisside, F_DUPFD, stdio);
X		close(hisside);
X
X		execl(shellpath, shell, flags, cmd, (char *) 0);
X		_exit(1);
X	}
X	if (ppid == -1) {
X		close(myside);
X		close(hisside);
X		return NULL;
X	}
X
X	popen_pid[myside] = ppid;
X
X	close(hisside);
X	return(fdopen(myside, mode));
X}
X
n_pclose(ptr)
XFILE *ptr;
X{
X	SIG_TYPE (*hstat)(), (*istat)(), (*qstat)();
X	int f, r, sig_status;
X
X	f = fileno(ptr);
X	fclose(ptr);
X	istat = signal(SIGINT, SIG_IGN);
X	qstat = signal(SIGQUIT, SIG_IGN);
X	hstat = signal(SIGHUP, SIG_IGN);
X
X	while ((r = wait(&sig_status)) != popen_pid[f] && r != -1)
X		;
X
X	if (r == -1)
X		sig_status = -1;
X
X	signal(SIGINT, istat);
X	signal(SIGQUIT, qstat);
X	signal(SIGHUP, hstat);
X	return(sig_status);
X}
END_OF_FILE
if test 2891 -ne `wc -c <'expand.c'`; then
    echo shar: \"'expand.c'\" unpacked with wrong size!
fi
# end of 'expand.c'
fi
if test -f 'extrnl.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extrnl.h'\"
else
echo shar: Extracting \"'extrnl.h'\" \(623 characters\)
sed "s/^X//" >'extrnl.h' <<'END_OF_FILE'
X/*
X * The external file transfer program database.  The list is limited to
X * 3 uploads and 3 downloads because the xfer_menu() routine uses single
X * character input (and these selections become 7, 8, and 9).
X */
X
struct EXTRNL {
X	char	*name[2][3];		/* program name (for display only) */
X	char	*command[2][3];		/* the command line */
X	char	prompt[2][3];		/* need to prompt for names? */
X
X	int	up_entries;		/* number of up entries in the file */
X	int	dn_entries;		/* number of down entries in the file */
X
X	char	*e_path;		/* path to the pcomm.extrnl file */
X};
X
X#ifndef MAIN
extern struct EXTRNL *extrnl;
X#endif /* MAIN */
END_OF_FILE
if test 623 -ne `wc -c <'extrnl.h'`; then
    echo shar: \"'extrnl.h'\" unpacked with wrong size!
fi
# end of 'extrnl.h'
fi
if test -f 'getcwd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getcwd.c'\"
else
echo shar: Extracting \"'getcwd.c'\" \(393 characters\)
sed "s/^X//" >'getcwd.c' <<'END_OF_FILE'
X/*
X * Can you believe it???  Masscomps don't have a function to return the
X * current working directory while in the AT&T universe!
X */
X
X#include <stdio.h>
X
char *
getcwd(buf, size)
char *buf;
int size;
X{
X	FILE *pfp, *n_popen();
X
X	if (!(pfp = n_popen("pwd", "r")))
X		return(".");
X
X	fgets(buf, size, pfp);
X	n_pclose(pfp);
X					/* zap the new line */
X	buf[strlen(buf)-1] = '\0';
X	return(buf);
X}
END_OF_FILE
if test 393 -ne `wc -c <'getcwd.c'`; then
    echo shar: \"'getcwd.c'\" unpacked with wrong size!
fi
# end of 'getcwd.c'
fi
if test -f 'getopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getopt.c'\"
else
echo shar: Extracting \"'getopt.c'\" \(1055 characters\)
sed "s/^X//" >'getopt.c' <<'END_OF_FILE'
X/*
X * Parse the command line and return option flags and arguments
X */
X
X#include <stdio.h>
X#include "config.h"
X
int optind = 1;
char *optarg;
X
int
getopt(argc, argv, opts)
int argc;
char *argv[];
char *opts;
X{
X	static int sp = 1;
X	int c, strcmp();
X	char *cp, *strchr();
X
X	if (sp == 1) {
X		if (optind >= argc || argv[optind][0] != '-' || argv[optind][1] == '\0')
X			return(EOF);
X		else if (strcmp(argv[optind], "--") == 0) {
X			optind++;
X			return(EOF);
X		}
X	}
X	c = argv[optind][sp];
X	if (c == ':' || (cp=strchr(opts, c)) == NULL) {
X		fprintf(stderr, "%s: illegal option \"%c\"\n", argv[0], c);
X		if (argv[optind][++sp] == '\0') {
X			optind++;
X			sp = 1;
X		}
X		return('?');
X	}
X	if (*++cp == ':') {
X		if (argv[optind][sp+1] != '\0')
X			optarg = &argv[optind++][sp+1];
X		else if (++optind >= argc) {
X			fprintf(stderr, "%s: option \"%c\" requires an argument\n", argv[0], c);
X			sp = 1;
X			return('?');
X		} else
X			optarg = argv[optind++];
X		sp = 1;
X	} else {
X		if (argv[optind][++sp] == '\0') {
X			sp = 1;
X			optind++;
X		}
X		optarg = NULL;
X	}
X	return(c);
X}
END_OF_FILE
if test 1055 -ne `wc -c <'getopt.c'`; then
    echo shar: \"'getopt.c'\" unpacked with wrong size!
fi
# end of 'getopt.c'
fi
if test -f 'help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help.c'\"
else
echo shar: Extracting \"'help.c'\" \(2115 characters\)
sed "s/^X//" >'help.c' <<'END_OF_FILE'
X/*
X * Display the help screen.  Press any key to continue.  If the ascii_hot
X * string is more than 4 characters wide, this screen will look silly.
X * Maybe one day, this will also contain full page descriptions of each
X * command.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X
void
help_screen(hot)
char *hot;
X{
X	extern int fd;
X	WINDOW *h_win, *newwin();
X
X	h_win = newwin(17, 80, 0, 0);
X
X	mvwattrstr(h_win, 1, 29, A_BOLD, "P C O M M       H E L P\n");
X	horizontal(h_win, 2, 0, 80);
X	mvwattrstr(h_win, 4, 0, A_BOLD, "       Major Functions          Utility Functions         File Functions\n\n");
X#ifdef OLDCURSES
X	mvwprintw(h_win,  6,  2, "Dialing Directory.%4.4s-D  Program Info ....%4.4s-I  Send Files ....%4.4s-U", hot, hot, hot);
X	mvwprintw(h_win,  7,  2, "Auto Redial ......%4.4s-R  Setup Screen ....%4.4s-S  Receive Files .%4.4s-N", hot, hot, hot);
X#else /* OLDCURSES */
X	mvwprintw(h_win,  6,  2, "Dialing Directory.%4.4s-D  Program Info ....%4.4s-I  Send Files ....%4.4s-<up>", hot, hot, hot);
X	mvwprintw(h_win,  7,  2, "Auto Redial ......%4.4s-R  Setup Screen ....%4.4s-S  Receive Files .%4.4s-<down>", hot, hot, hot);
X#endif /* OLDCURSES */
X	mvwprintw(h_win,  8,  2, "Keyboard Macros ..%4.4s-M  Change Directory.%4.4s-B  Pass Thru Mode.%4.4s-T", hot, hot, hot);
X	mvwprintw(h_win,  9,  2, "Line Settings ....%4.4s-P  Clear Screen ....%4.4s-C  Directory .....%4.4s-F", hot, hot, hot);
X	mvwprintw(h_win, 10,  2, "Exit Pcomm .......%4.4s-X  Toggle Duplex ...%4.4s-E  Screen Dump ...%4.4s-G", hot, hot, hot);
X	mvwprintw(h_win, 11,  2, "Unix Gateway .....%4.4s-4  Hang Up Phone ...%4.4s-H  Start Data Log.%4.4s-1", hot, hot, hot);
X	mvwprintw(h_win, 12,  2, "Command Files ....%4.4s-5  Printer On/Off ..%4.4s-L  Toggle Log ....%4.4s-2", hot, hot, hot);
X	mvwprintw(h_win, 13, 28, "Toggle CR-CR/LF .%4.4s-3", hot);
X	mvwprintw(h_win, 14, 28, "Break Key .......%4.4s-7", hot);
X
X	box(h_win, VERT, HORZ);
X	mvwaddstr(h_win, 16, 26, " Press any key to continue ");
X	wrefresh(h_win);
X
X	wgetch(h_win);
X	if (fd == -1) {
X		werase(h_win);
X		wrefresh(h_win);
X	}
X	delwin(h_win);
X	return;
X}
END_OF_FILE
if test 2115 -ne `wc -c <'help.c'`; then
    echo shar: \"'help.c'\" unpacked with wrong size!
fi
# end of 'help.c'
fi
if test -f 'info.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'info.c'\"
else
echo shar: Extracting \"'info.c'\" \(1585 characters\)
sed "s/^X//" >'info.c' <<'END_OF_FILE'
X/*
X * Display the initial welcome screen (to include all of the proper
X * acknowledgements).  Press any key to continue.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "patchlevel.h"
X
void
info(auto_clear)
int auto_clear;
X{
X	extern int fd;
X	WINDOW *w_win, *newwin();
X	char buf[80];
X					/* display the welcome screen */
X	w_win = newwin(23, 80, 0, 0);
X	mvwaddstr(w_win, 3, 18, "PPPPPP    CCCC    OOOO    MM   MM   MM   MM");
X	mvwaddstr(w_win, 4, 18, "P    P   C       O    O   M M M M   M M M M");
X	mvwaddstr(w_win, 5, 18, "PPPPPP   C       O    O   M  M  M   M  M  M");
X	mvwaddstr(w_win, 6, 18, "P        C       O    O   M     M   M     M");
X	mvwaddstr(w_win, 7, 18, "P         CCCC    OOOO    M     M   M     M");
X
X	sprintf(buf, ">>> Pcomm Version %s <<<", VERSION);
X	mvwaddstr(w_win, 10, (80-strlen(buf))/2, buf);
X	sprintf(buf, "Release date: %s", DATE);
X	mvwaddstr(w_win, 11, (80-strlen(buf))/2, buf);
X
X	mvwaddstr(w_win, 13, 8, "Pcomm is a public domain telecommunication program for Unix that");
X	mvwaddstr(w_win, 14, 8, "is designed to operate similarly to the MSDOS program, ProComm.");
X	mvwaddstr(w_win, 15, 8, "ProComm (TM) is copyrighted by Datastorm Technologies, Inc.");
X	mvwaddstr(w_win, 19, 45, "Emmet P. Gray");
X	mvwaddstr(w_win, 20, 45, "...!uunet!uiucuxc!fthood!egray");
X	mvwaddstr(w_win, 21, 45, "fthood!egray@uxc.cso.uiuc.edu");
X	wmove(w_win, 22, 79);
X	wrefresh(w_win);
X					/* delay so you can read the herald */
X	if (auto_clear)
X		wait_key(w_win, 5);
X	else
X		wgetch(w_win);
X
X	if (fd == -1) {
X		werase(w_win);
X		wrefresh(w_win);
X	}
X	delwin(w_win);
X	return;
X}
END_OF_FILE
if test 1585 -ne `wc -c <'info.c'`; then
    echo shar: \"'info.c'\" unpacked with wrong size!
fi
# end of 'info.c'
fi
if test -f 'init.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'init.c'\"
else
echo shar: Extracting \"'init.c'\" \(1911 characters\)
sed "s/^X//" >'init.c' <<'END_OF_FILE'
X/*
X * Display the welcome screen and find the Pcomm support files.  Returns a
X * pointer to a static area containing the STATUS structure.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X#include "status.h"
X
static char *extra_dir;
X
struct STATUS *
init(extra)
char *extra;
X{
X	int i;
X	char *memset(), *str_dup();
X	static struct STATUS s;
X					/* some defaults */
X	s.dup_fd = -1;
X	s.cmd_ipc = -1;
X	s.connected = 0;
X	s.log_status = 0;
X	s.log_path = str_dup("NOT_DEFINED");
X	s.print_status = 0;
X	s.row = 0;
X	s.col = 0;
X	for (i=0; i<MAX_ROW; i++)
X		memset(s.vs[i], '\0', MAX_COL);
X	s.max_row = (LINES > MAX_ROW) ? MAX_ROW : LINES; 
X	s.max_col = (COLS >= MAX_COL) ? MAX_COL -1 : COLS; 
X
X	extra_dir = str_dup(extra);
X	return(&s);
X}
X
X/*
X * Search the extra directory (supplied on the command line), then the
X * directory in the PCOMM environmental variable, then the current working
X * directory, and lastly, the default directory.
X */
X
char *
findfile(name)
char *name;
X{
X	int i;
X	char *pcomm, *getenv(), *path, pbuf[200], *getcwd(), *str_dup();
X	char temp[200];
X
X					/* see if PCOMM variable is set */
X	pcomm = getenv("PCOMM");
X	if (pcomm == NULL || *pcomm == '\0')
X		pcomm = NULL;
X	else {
X					/* zap the trailing separator */
X		if (pcomm[strlen(pcomm)-1] == '/')
X			pcomm[strlen(pcomm)-1] = '\0';
X	}
X
X	for (i=0; i<4; i++) {
X					/* directory search order */
X		switch (i) {
X			case 0:		/* extra directory from command line */
X				path = extra_dir;
X				break;
X			case 1:		/* PCOMM environmental variable */
X				path = pcomm;
X				break;
X			case 2:		/* current working directory */
X				path = getcwd(pbuf, 200);
X				break;
X			case 3:		/* Pcomm's default directory */
X				path = DEFAULT_DIR;
X				break;
X		}
X		if (path == NULL)
X			continue;
X
X		sprintf(temp, "%s/%s", path, name);
X					/* read permission checked */
X		if (!access(temp, 4))
X			return(str_dup(temp));
X	}
X	return(NULL);
X}
END_OF_FILE
if test 1911 -ne `wc -c <'init.c'`; then
    echo shar: \"'init.c'\" unpacked with wrong size!
fi
# end of 'init.c'
fi
if test -f 'ipc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ipc.h'\"
else
echo shar: Extracting \"'ipc.h'\" \(108 characters\)
sed "s/^X//" >'ipc.h' <<'END_OF_FILE'
X/*
X * Header for the mupliplexed I/O stuff
X */
X
X#define KEY_READY	1
X#define TTY_READY	2
X#define CMD_READY	4
END_OF_FILE
if test 108 -ne `wc -c <'ipc.h'`; then
    echo shar: \"'ipc.h'\" unpacked with wrong size!
fi
# end of 'ipc.h'
fi
if test -f 'ipc_att.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ipc_att.c'\"
else
echo shar: Extracting \"'ipc_att.c'\" \(2183 characters\)
sed "s/^X//" >'ipc_att.c' <<'END_OF_FILE'
X/*
X * The IPC and multiplexed I/O routines for AT&T flavors of Unix
X */
X
X#include <stdio.h>
X#ifndef MAIN
X#include <stropts.h>
X#include <poll.h>
X#include <fcntl.h>
X#include <sys/stream.h>
X#include "ipc.h"
X
X#define PSEUDO_TTY	"/dev/ptmx"
X
static struct pollfd fds[3];
static int time_out;
X
void
ipc_init(tty_fd, cmd_fd)
int tty_fd, cmd_fd;
X{
X	fds[0].fd = 0;			/* the keyboard */
X	fds[0].events = POLLIN;
X	fds[0].revents = 0;
X	fds[1].fd = tty_fd;		/* the TTY */
X	fds[1].events = POLLIN;
X	fds[1].revents = 0;
X	fds[2].fd = cmd_fd;		/* the shell script */
X	fds[2].events = POLLIN;
X	fds[2].revents = 0;
X					/* 1 sec loop, or wait forever */
X	if (cmd_fd != -1)
X		time_out = 1000000;
X	else
X		time_out = -1;
X	return;
X}
X
X/* ARGSUSED */
int
ipc_poll(tty_fd, cmd_fd)
int tty_fd, cmd_fd;
X{
X	int ret_code;
X
X	poll(fds, 3, time_out);
X
X	ret_code = 0;
X	if (fds[0].revents & POLLIN)
X		ret_code |= KEY_READY;
X
X	if (fds[1].revents & POLLIN)
X		ret_code |= TTY_READY;
X
X	if (fds[2].revents & POLLIN)
X		ret_code |= CMD_READY;
X
X	return(ret_code);
X}
X
X/*
X * Update the file descriptors for poll()/select() that might have changed.
X */
X
void
ipc_update(tty_fd, cmd_fd)
int tty_fd, cmd_fd;
X{
X	fds[1].fd = tty_fd;
X	fds[2].fd = cmd_fd;
X
X	if (cmd_fd != -1)
X		time_out = 1000000;
X	else
X		time_out = -1;
X	return;
X}
X
X/*
X * Open an IPC "channel"
X */
X
int
ipc_open()
X{
X	int fd;
X
X	if ((fd = open(PSEUDO_TTY, O_RDWR)) < 0)
X		return(-1);
X
X	grantpt(fd);
X	unlockpt(fd);
X	return(fd);
X}
X
X/*
X * Close an IPC channel
X */
X
int
ipc_close(fd)
int fd;
X{
X	return(close(fd));
X}
X
X/*
X * Return a unique "key" to pass to the child process 
X */
X
char *
ipc_key(fd)
int fd;
X{
X	char *ptsname();
X
X	return(ptsname(fd));
X}
X#endif /* MAIN */
X
X/*
X * Attach to an existing IPC channel
X */
X
int
ipc_attach(dev, mode)
char *dev;
int mode;
X{
X	return(open(dev, mode));
X}
X
X/*
X * Detach from an IPC channel
X */
X
int
ipc_detach(fd)
int fd;
X{
X	return(close(fd));
X}
X
X/*
X * Read from an IPC channel
X */
X
int
ipc_read(fd, buf, n)
int fd;
char *buf;
int n;
X{
X	if (read(fd, buf, n) != n)
X		return(1);
X	return(0);
X}
X
X/*
X * Write to an IPC channel
X */
X
int
ipc_write(fd, buf, n)
int fd;
char *buf;
int n;
X{
X	if (write(fd, buf, n) != n)
X		return(1);
X	return(0);
X}
END_OF_FILE
if test 2183 -ne `wc -c <'ipc_att.c'`; then
    echo shar: \"'ipc_att.c'\" unpacked with wrong size!
fi
# end of 'ipc_att.c'
fi
if test -f 'ipc_ucb.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ipc_ucb.c'\"
else
echo shar: Extracting \"'ipc_ucb.c'\" \(2903 characters\)
sed "s/^X//" >'ipc_ucb.c' <<'END_OF_FILE'
X/*
X * The IPC and multiplexed I/O routines for Berkeley flavors of Unix
X */
X
X#include <stdio.h>
X#ifndef MAIN
X#include <fcntl.h>
X#include <sys/time.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <sys/file.h>
X#include "ipc.h"
X
static char pty_name[12];
static int fdin_mask, num_fds;
static struct timeval time_out = {1L, 0L};
static struct timeval *tp;
X
void
ipc_init(tty_fd, cmd_fd)
int tty_fd, cmd_fd;
X{
X	int fdout, fdin, fdex;
X
X	fdout = 0;
X	fdex = 0;
X	fdin_mask = 1;			/* the keyboard */
X	num_fds = 1;
X	if (tty_fd != -1) {		/* the TTY */
X		fdin_mask |= (1 << tty_fd);
X		num_fds = tty_fd +1;
X	}
X	if (cmd_fd != -1) {		/* the shell script */
X		fdin_mask |= (1 << cmd_fd);
X		if (cmd_fd > tty_fd)
X			num_fds = cmd_fd +1;
X		tp = &time_out;
X	}
X	else
X		tp = (struct timeval *) NULL;
X	return;
X}
X
int
ipc_poll(tty_fd, cmd_fd)
int tty_fd, cmd_fd;
X{
X	int ret_code, fdout, fdin, fdex;
X
X	ret_code = 0;
X	fdin = fdin_mask;
X	select(num_fds, &fdin, &fdout, &fdex, tp);
X
X	if (fdin & 1)
X		ret_code |= KEY_READY;
X
X	if (tty_fd != -1 && (fdin & (1 << tty_fd)))
X		ret_code |= TTY_READY;
X
X	if (cmd_fd != -1 && (fdin & (1 << cmd_fd)))
X		ret_code |= CMD_READY;
X
X	return(ret_code);
X}
X
X/*
X * Update the file descriptors for poll()/select() that might have changed.
X */
X
void
ipc_update(tty_fd, cmd_fd)
int tty_fd, cmd_fd;
X{
X	fdin_mask = 1;
X	num_fds = 1;
X	if (tty_fd != -1) {
X		fdin_mask |= (1 << tty_fd);
X		num_fds = tty_fd +1;
X	}
X	if (cmd_fd != -1) {
X		fdin_mask |= (1 << cmd_fd);
X		if (cmd_fd > tty_fd)
X			num_fds = cmd_fd +1;
X		tp = &time_out;
X	}
X	else
X		tp = (struct timeval *) NULL;
X	return;
X}
X
X/*
X * Open an IPC "channel"
X */
X
int
ipc_open()
X{
X	int fd, i, j;
X	char *p, *strcpy();
X	struct stat sbuf;
X	static char letters[] = "pqrs";
X	static char hex_num[] = "0123456789abcdef";
X
X	strcpy(pty_name, "/dev/ptyxx");
X
X	for (i=0; i<4; i++) {
X		pty_name[8] = letters[i];
X		for (j=0; j<16; j++) {
X			pty_name[9] = hex_num[j];
X					/* if it doesn't exist, quit */
X			if (stat(pty_name, &sbuf) < 0)
X				return(-1);
X
X			if ((fd = open(pty_name, O_RDWR)) >= 0)
X				return(fd);
X		}
X	}
X	return(-1);
X}
X
X/*
X * Close an IPC channel
X */
X
int
ipc_close(fd)
int fd;
X{
X	return(close(fd));
X}
X
X/*
X * Return a unique "key" to pass to the child process 
X */
X
X/* ARGSUSED */
char *
ipc_key(fd)
int fd;
X{
X	static char tty_name[12];
X	char *strcpy();
X
X	strcpy(tty_name, pty_name);
X	tty_name[5] = 't';
X	return(tty_name);
X}
X#endif /* MAIN */
X
X/*
X * Attach to an existing IPC channel
X */
X
int
ipc_attach(dev, mode)
char *dev;
int mode;
X{
X	return(open(dev, mode));
X}
X
X/*
X * Detach from an IPC channel
X */
X
int
ipc_detach(fd)
int fd;
X{
X	return(close(fd));
X}
X
X/*
X * Read from an IPC channel
X */
X
int
ipc_read(fd, buf, n)
int fd;
char *buf;
int n;
X{
X	if (read(fd, buf, n) != n)
X		return(1);
X	return(0);
X}
X
X/*
X * Write to an IPC channel
X */
X
int
ipc_write(fd, buf, n)
int fd;
char *buf;
int n;
X{
X	if (write(fd, buf, n) != n)
X		return(1);
X	return(0);
X}
END_OF_FILE
if test 2903 -ne `wc -c <'ipc_ucb.c'`; then
    echo shar: \"'ipc_ucb.c'\" unpacked with wrong size!
fi
# end of 'ipc_ucb.c'
fi
if test -f 'list_dir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'list_dir.c'\"
else
echo shar: Extracting \"'list_dir.c'\" \(1615 characters\)
sed "s/^X//" >'list_dir.c' <<'END_OF_FILE'
X/*
X * Do a shell escape with the "ls" command.  Additional command line options
X * are allowed at run time.
X */
X
X#define LS_CMD "ls -aC"
X
X#include <stdio.h>
X#include <curses.h>
X#include "misc.h"
X
void
list_dir()
X{
X	extern int fd;
X	WINDOW *ls_win, *newwin();
X	FILE *pfp, *n_popen();
X	int lines, oops;
X	char *ans, *cwd, *getcwd(), buf[200], *get_str();
X
X	ls_win = newwin(6, 70, 8, 5);
X
X	cwd = getcwd(buf, 200);
X
X	mvwprintw(ls_win, 2, 4, "Current directory: %s", cwd);
X	mvwaddstr(ls_win, 3, 4, "File spec (wildcards allowed): ");
X	box(ls_win, VERT, HORZ);
X
X	mvwattrstr(ls_win, 0, 3, A_BOLD, " List Directory ");
X	wmove(ls_win, 3, 35);
X	wrefresh(ls_win);
X
X	if ((ans = get_str(ls_win, 80, "", "\n")) == NULL) {
X		if (fd == -1) {
X			werase(ls_win);
X			wrefresh(ls_win);
X		}
X		delwin(ls_win);
X		return;
X	}
X					/* popen() an ls */
X	sprintf(buf, "%s %s", LS_CMD, ans);
X	pfp = n_popen(buf, "r");
X					/* make a bigger window */
X	werase(ls_win);
X	wrefresh(ls_win);
X	delwin(ls_win);
X	ls_win = newwin(LINES-1, COLS, 0, 0);
X	touchwin(ls_win);
X					/* a crude kind of paging */
X	oops = 0;
X	lines = 0;
X	while (fgets(buf, BUFSIZ, pfp) != NULL) {
X		waddstr(ls_win, buf);
X		lines++;
X		if (lines == LINES-2) {
X			lines = 0;
X			mvwaddstr(ls_win, LINES-2, 28, "Press any key for more");
X			wrefresh(ls_win);
X			if (wgetch(ls_win) == ESC) {
X				oops++;
X				break;
X			}
X			werase(ls_win);
X			wrefresh(ls_win);
X		}
X	}
X	n_pclose(pfp);
X
X	if (!oops) {
X		mvwaddstr(ls_win, LINES-2, 25, "Press any key to continue");
X		wrefresh(ls_win);
X		wgetch(ls_win);
X	}
X	if (fd == -1) {
X		werase(ls_win);
X		wrefresh(ls_win);
X	}
X	delwin(ls_win);
X	return;
X}
END_OF_FILE
if test 1615 -ne `wc -c <'list_dir.c'`; then
    echo shar: \"'list_dir.c'\" unpacked with wrong size!
fi
# end of 'list_dir.c'
fi
if test -f 'matches.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'matches.c'\"
else
echo shar: Extracting \"'matches.c'\" \(770 characters\)
sed "s/^X//" >'matches.c' <<'END_OF_FILE'
X/*
X * See if two strings match.  Returns a 0 on success, and a 1 on failure.
X * This is an external program to be used in shell scripts.
X */
X
X#include <stdio.h>
X#include "config.h"
X
main(argc, argv)
int argc;
char *argv[];
X{
X	char *strstr();
X	void exit();
X
X	if (argc != 3) {
X		fprintf(stderr, "Usage: matches string1 string2\n");
X		exit(-1);
X	}
X
X	if (strstr(argv[1], argv[2]))
X		exit(0);
X	exit(1);
X}
X
X#ifndef HAVE_STRSTR
X/*
X * Return a pointer to the first occurrence of string str2 in str1.
X * Returns a NULL if str2 is not in str1.
X */
X
char *
strstr(str1, str2)
char *str1, *str2;
X{
X	int len;
X
X	len = strlen(str2);
X	while (*str1) {
X		if (*str2 == *str1) {
X			if (!strncmp(str2, str1, len))
X				return(str1);
X		}
X		str1++;
X	}
X	return(NULL);
X}
X#endif /* HAVE_STRSTR */
END_OF_FILE
if test 770 -ne `wc -c <'matches.c'`; then
    echo shar: \"'matches.c'\" unpacked with wrong size!
fi
# end of 'matches.c'
fi
if test -f 'misc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc.h'\"
else
echo shar: Extracting \"'misc.h'\" \(1465 characters\)
sed "s/^X//" >'misc.h' <<'END_OF_FILE'
X/*
X * Definitions to support the home-grown curses(3) functions and to make
X * the old curses(3) routines happy.
X */
X
X#define mvwattrstr(w,y,x,a,s)	(wmove(w,y,x)==ERR?ERR:wattrstr(w,a,s))
X#define mvwattrch(w,y,x,a,c)	(wmove(w,y,x)==ERR?ERR:wattrch(w,a,c))
X#define mvwattrnum(w,y,x,a,n)	(wmove(w,y,x)==ERR?ERR:wattrnum(w,a,n))
X#define mvattrstr(y,x,a,s)	(wmove(stdscr,y,x)==ERR?ERR:wattrstr(stdscr,a,s))
X#define mvattrch(y,x,a,c)	(wmove(stdscr,y,x)==ERR?ERR:wattrch(stdscr,a,c))
X#define mvattrnum(y,x,a,n)	(wmove(stdscr,y,x)==ERR?ERR:wattrnum(stdscr,a,n))
X#define attrstr(a,s)		wattrstr(stdscr,a,s)
X#define attrch(a,c)		wattrch(stdscr,a,c)
X#define attrnum(a,n)		wattrnum(stdscr,a,n)
X
X#ifndef A_BOLD
X#ifdef NOPROMOTE
X#define A_BOLD		0
X#define A_BLINK		0
X#define A_REVERSE	1
X#define A_DIM		0
X#define A_STANDOUT	1
X#define A_UNDERLINE	0
X#else /* NOPROMOTE */
X#define A_BOLD		1
X#define A_BLINK		1
X#define A_REVERSE	1
X#define A_DIM		1
X#define A_STANDOUT	1
X#define A_UNDERLINE	1
X#endif /* NOPROMOTE */
typedef char chtype;
X#endif /* A_BOLD */
X
X#ifdef ACS_HLINE
X#define VERT		(chtype)0
X#define HORZ		(chtype)0
X#else /* ACS_HLINE */
X#define VERT		(chtype)'|'
X#define HORZ		(chtype)'-'
X#define ACS_VLINE	(chtype)'|'
X#define ACS_HLINE	(chtype)'-'
X#endif /* ACS_HLINE */
X
X/*
X * Other miscellaneous stuff
X */
X
X#define BEL		7
X#define BS		8
X#define ESC		27
X#define DEL		127
X
X#define MANUAL_CLEAR	0
X#define AUTO_CLEAR	1
X
X#define DENIED		0
X#define WRITE_OK	1
X#define OK_BUT_EXISTS	2
END_OF_FILE
if test 1465 -ne `wc -c <'misc.h'`; then
    echo shar: \"'misc.h'\" unpacked with wrong size!
fi
# end of 'misc.h'
fi
if test -f 'modem.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'modem.h'\"
else
echo shar: Extracting \"'modem.h'\" \(1652 characters\)
sed "s/^X//" >'modem.h' <<'END_OF_FILE'
X/*
X * The modem and TTY databases.  The first 3 elements make up the TTY
X * database, the next 16 make up the modem database.  A "tname" in common
X * with a "mname" link the two together.
X */
X
X#define NUM_TTY		10
X#define NUM_MODEM	10
X
X#define IS_SCRIPT	0
X#define IS_TTY		1
X#define IS_MODEM	2
X
struct MODEM {
X	char	*tty[NUM_TTY];		/* TTY names */
X	char	*tname[NUM_TTY];	/* modem name */
X	int	lock_sp[NUM_TTY];	/* DTE locked baud rate */
X
X	char	*mname[NUM_MODEM];	/* modem name (matches tname above) */
X	char	*init[NUM_MODEM];	/* initialization */
X	char	*dial[NUM_MODEM];	/* dial command */
X	char	*suffix[NUM_MODEM];	/* dialing command suffix */
X	char	*hang_up[NUM_MODEM];	/* hang up the modem */
X	char	auto_baud[NUM_MODEM];	/* should we sync baud rates? */
X	char	*con_3[NUM_MODEM];	/* 300 baud connect message */
X	char	*con_12[NUM_MODEM];	/* 1200 baud connect message */
X	char	*con_24[NUM_MODEM];	/* 2400 baud connect message */
X	char	*con_48[NUM_MODEM];	/* 4800 baud connect message */
X	char	*con_96[NUM_MODEM];	/* 9600 baud connect message */
X	char	*con_192[NUM_MODEM];	/* 19200 baud connect message */
X	char	*con_384[NUM_MODEM];	/* 38400 baud connect message */
X	char	*no_con1[NUM_MODEM];	/* no connect #1 */
X	char	*no_con2[NUM_MODEM];	/* no connect #2 */
X	char	*no_con3[NUM_MODEM];	/* no connect #3 */
X	char	*no_con4[NUM_MODEM];	/* no connect #4 */
X
X	int	t_entries;		/* number of TTY entries */
X	int	m_entries;		/* number of modem entries */
X	int	t_cur;			/* current TTY entry number */
X	int	m_cur;			/* current modem entry number */
X
X	char	*m_path;		/* path to the pcomm.modem file */
X};
X
X#ifndef MAIN
extern struct MODEM *modem;
X#endif /* MAIN */
END_OF_FILE
if test 1652 -ne `wc -c <'modem.h'`; then
    echo shar: \"'modem.h'\" unpacked with wrong size!
fi
# end of 'modem.h'
fi
if test -f 'n_shell.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'n_shell.c'\"
else
echo shar: Extracting \"'n_shell.c'\" \(1302 characters\)
sed "s/^X//" >'n_shell.c' <<'END_OF_FILE'
X/*
X * Spawn a "native" shell.  Native means the shell found in the SHELL
X * environmental variable.
X */
X
X#include <stdio.h>
X#include <signal.h>
X#include <curses.h>
X#include "config.h"
X
void
n_shell()
X{
X	WINDOW *sh_win, *newwin();
X	SIG_TYPE (*istat)(), (*qstat)();
X	int sig_status, spid, w;
X	char *shell, *shellpath, *getenv(), *strrchr();
X	unsigned int sleep();
X	void _exit();
X					/* a full window */
X	sh_win = newwin(LINES, COLS, 0, 0);
X
X	touchwin(sh_win);
X	waddstr(sh_win, "Pcomm <=> Unix gateway, use ^D or 'exit' to return\n");
X	wrefresh(sh_win);
X					/* out of curses mode */
X	resetterm();
X
X	shellpath = getenv("SHELL");
X	if (shellpath == NULL || *shellpath == '\0')
X		shellpath = "/bin/sh";
X
X	if (shell = strrchr(shellpath, '/'))
X		shell++;
X	else {
X		shellpath = "/bin/sh";
X		shell = "sh";
X	}
X
X	if (!(spid = fork())) {
X		signal(SIGINT, SIG_DFL);
X		signal(SIGQUIT, SIG_DFL);
X
X		setgid(getgid());
X		setuid(getuid());
X
X		execl(shellpath, shell, "-i", (char *) 0);
X		_exit(1);
X	}
X	istat = signal(SIGINT, SIG_IGN);
X	qstat = signal(SIGQUIT, SIG_IGN);
X
X	while ((w = wait(&sig_status)) != spid && w != -1)
X		;
X
X	signal(SIGINT, istat);
X	signal(SIGQUIT, qstat);
X					/* back to curses mode */
X	sleep(1);
X	fixterm();
X
X	clearok(curscr, TRUE);
X	werase(sh_win);
X	wrefresh(sh_win);
X	delwin(sh_win);
X	return;
X}
END_OF_FILE
if test 1302 -ne `wc -c <'n_shell.c'`; then
    echo shar: \"'n_shell.c'\" unpacked with wrong size!
fi
# end of 'n_shell.c'
fi
if test -f 'param.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'param.h'\"
else
echo shar: Extracting \"'param.h'\" \(2784 characters\)
sed "s/^X//" >'param.h' <<'END_OF_FILE'
X/*
X * The standard Pcomm parameters.  Everything can be altered by using one
X * of Pcomm's menus.  Although editing by hand is not encouraged, the
X * pcomm.param file is just an ASCII file.
X */
X
X#define MAX_CDELAY	120
X#define MIN_CDELAY	10
X#define MAX_PAUSE	120
X#define MIN_PAUSE	1
X#define MAX_TIMER	20
X#define MIN_TIMER	2
X
X#define NUM_PARAM	44
X#define LINE_SET	0
X#define TERM_SETUP	4
X#define GEN_SETUP	10
X#define DELAY_TIMES	19
X#define ASCII_SETUP	21
X#define LD_CODES	30
X#define MACROS		34
X
struct PARAM {
X				/* 0-3 used in ls_menu() */
X	unsigned int	d_baud;		/* default baud rate */
X	char	d_parity;		/* default parity */
X	int	d_data_bits;		/* default data bits */
X	int	d_stop_bits;		/* default stop bits */
X
X				/* 4-9 used in term_setup() */
X	int	hot_key;		/* the decimal code for the hot key */
X	char	*ascii_hot;		/* ascii representation of hot key */
X	char	*d_duplex;		/* default duplex */
X	char	*flow_ctrl;		/* flow control */
X	char	*cr_in;			/* send as carriage return */
X	char	*cr_out;		/* receive carriage return as */
X
X				/* 10-18 used in gen_setup() */
X	char	*logfile;		/* default log file */
X	char	*dumpfile;		/* default screen dump file */
X	char	*strip;			/* strip high bit (translate table) */
X	char	pause_char;		/* pause char synonym */
X	char	cr_char;		/* carriage return char synonym */
X	char	ctrl_char;		/* ctrl char synonym */
X	char	esc_char;		/* escape char synonym */
X	char	brk_char;		/* modem break synonym */
X	char	*abort;			/* destination of aborted downloads */
X
X				/* 19-20 used in gen_setup() & delay_times() */
X	int	c_delay;		/* connect delay time */
X	int	r_delay;		/* redial delay time */
X
X				/* 21-29 used in axfer_setup() */
X	char	*local_echo;		/* echo locally? */
X	char	*expand;		/* expand blank lines? */
X	int	cr_delay;		/* carriage return delay (ms) */
X	char	*pace;			/* pace the output? */
X	char	*cr_up;			/* send carriage return as */
X	char	*lf_up;			/* send line feed as */
X	int	timer;			/* transfer timeout */
X	char	*cr_dn;			/* receive carriage return as */
X	char	*lf_dn;			/* receive line feed as */
X
X				/* 30-33 used in d_revise() */
X	char	*ld_plus;		/* + long distance code */
X	char	*ld_minus;		/* - long distance code */
X	char	*ld_at;			/* @ long distance code */
X	char	*ld_pound;		/* # long distance code */
X
X				/* 34-43 used in macro() */
X	char	*mac_1;			/* shifted 1 macro */
X	char	*mac_2;			/* shifted 2 macro */
X	char	*mac_3;			/* shifted 3 macro */
X	char	*mac_4;			/* shifted 4 macro */
X	char	*mac_5;			/* shifted 5 macro */
X	char	*mac_6;			/* shifted 6 macro */
X	char	*mac_7;			/* shifted 7 macro */
X	char	*mac_8;			/* shifted 8 macro */
X	char	*mac_9;			/* shifted 9 macro */
X	char	*mac_0;			/* shifted 0 macro */
X
X	char	*p_path;		/* path to the pcomm.param file */
X};
X
X#ifndef MAIN
extern struct PARAM *param;
X#endif /* MAIN */
END_OF_FILE
if test 2784 -ne `wc -c <'param.h'`; then
    echo shar: \"'param.h'\" unpacked with wrong size!
fi
# end of 'param.h'
fi
if test -f 'passthru.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'passthru.c'\"
else
echo shar: Extracting \"'passthru.c'\" \(2488 characters\)
sed "s/^X//" >'passthru.c' <<'END_OF_FILE'
X/*
X * A transparent "pass-thru" mode, designed to allow binary transfers
X * between 3 machines (with the middle machine in the pass-thru mode).
X */
X
X#include <stdio.h>
X#include <signal.h>
X#include <curses.h>
X#include "config.h"
X#include "misc.h"
X
X#ifdef BSD
X#include <setjmp.h>
jmp_buf cp_buf;
X#endif /* BSD */
X
static void cpio();
X
void
pass_thru()
X{
X	extern int fd;
X	WINDOW *pt_win, *newwin();
X	int num;
X	void error_win();
X
X	pt_win = newwin(5, 70, 5, 5);
X
X	mvwaddstr(pt_win, 2, 4, "Enter the expiration time (5-60 sec): ");
X	box(pt_win, VERT, HORZ);
X
X	mvwattrstr(pt_win, 0, 3, A_BOLD, " Pass Through Mode ");
X	wmove(pt_win, 2, 43);
X	wrefresh(pt_win);
X					/* get the answer */
X	while ((num = get_num(pt_win, 2)) != -1) {
X					/* out of bounds */
X		if (num < 5 || num > 60) {
X			beep();
X			clear_line(pt_win, 2, 43, TRUE);
X			wmove(pt_win, 2, 43);
X			wrefresh(pt_win);
X		}
X		else {
X			werase(pt_win);
X			wrefresh(pt_win);
X			delwin(pt_win);
X
X			if (fd == -1) {
X				error_win(0, "Not currently connected to any host", "");
X				return;
X			}
X
X			touchwin(stdscr);
X			refresh();
X
X			cpio((unsigned int) num);
X			return;
X		}
X	}
X	if (fd == -1) {
X		werase(pt_win);
X		wrefresh(pt_win);
X	}
X	delwin(pt_win);
X	return;
X}
X
X/*
X * Copy the stdin to the TTYout and copy the TTYin to the stdout.  Uses
X * multi character reads.  I'm not too concerned about the excess baggage
X * caused by the entire image being forked... this feature won't be used
X * that often.
X */
X
static int cp_flag;
static int cp_force();
X
static void
cpio(num)
unsigned int num;
X{
X	extern int fd;
X	int cpid, n;
X	char buf[CLIST_SIZ];
X	unsigned int alarm(), sleep();
X	void line_set(), xmodem_mode();
X
X					/* out of curses mode */
X	resetterm();
X
X	xmodem_mode(0);
X	xmodem_mode(fd);
X
X					/* copy the TTYin to stdout */
X	if (!(cpid = fork())) {
X		/* CONSTCOND */
X		while (1) {
X			n = read(fd, buf, CLIST_SIZ);
X			write(1, buf, n);
X		}
X	}
X
X	cp_flag = 0;
X	signal(SIGALRM, (SIG_TYPE(*) ()) cp_force);
X					/* copy the stdin to TTYout */
X	/* CONSTCOND */
X	while (1) {
X		alarm(num);
X#ifdef BSD
X		if (setjmp(cp_buf))
X			break;
X#endif /* BSD */
X		n = read(0, buf, CLIST_SIZ);
X		if (cp_flag)
X			break;
X		write(fd, buf, n);
X	}
X	kill(cpid, SIGKILL);
X					/* back to curses mode */
X	sleep(1);
X	fixterm();
X	beep();
X	line_set();
X	clearok(curscr, TRUE);
X	return;
X}
X
X/* ARGSUSED */
static int
cp_force(dummy)
X{
X#ifdef BSD
X	longjmp(cp_buf, 1);
X#else /* BSD */
X	signal(SIGALRM, (SIG_TYPE(*) ()) cp_force);
X	cp_flag = 1;
X	return(0);
X#endif /* BSD */
X}
END_OF_FILE
if test 2488 -ne `wc -c <'passthru.c'`; then
    echo shar: \"'passthru.c'\" unpacked with wrong size!
fi
# end of 'passthru.c'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(48 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X#define VERSION "2.0.2"
X#define DATE "6 Nov 92"
END_OF_FILE
if test 48 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
if test -f 'pexit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pexit.c'\"
else
echo shar: Extracting \"'pexit.c'\" \(2176 characters\)
sed "s/^X//" >'pexit.c' <<'END_OF_FILE'
X/*
X * Exit Pcomm.  A user requested abort.  There are a lot of things to do
X * before we exit!
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "dial_dir.h"
X#include "misc.h"
X#include "param.h"
X#include "status.h"
X
void
pexit()
X{
X	extern int fd;
X	WINDOW *ex_win, *newwin();
X	void cleanup(), st_line();
X
X	ex_win = newwin(5, 33, 3, 7);
X
X	box(ex_win, VERT, HORZ);
X	mvwattrstr(ex_win, 0, 3, A_BOLD, " Exit ");
X	if (yes_prompt(ex_win, 2, 4, A_BLINK, "Exit to Unix")) {
X		st_line("   exiting");
X		cleanup(0);
X	}
X	if (fd == -1) {
X		werase(ex_win);
X		wrefresh(ex_win);
X	}
X	delwin(ex_win);
X	return;
X}
X
X/*
X * Do the clean up detail before we exit.  Only the status structure
X * is guaranteed to exit.
X */
X
void
cleanup(val)
int val;
X{
X	extern int msg_status;
X	void release_port(), exit();
X	char *mytty, *ttyname();
X					/* release the port */
X	release_port(QUIET);
X
X	/*
X	 * If we die an un-natural death (such as a SIGHUP on the loss of
X	 * the controlling terminal) we won't have a terminal to mess with.
X	 */
X	if (isatty(0)) {
X		touchwin(stdscr);
X		clear();
X		refresh();
X		endwin();
X					/* return the TTY chmod */
X		if (mytty = ttyname(0))
X			chmod(mytty, msg_status);
X	}
X	exit(val);
X}
X
X/*
X * Open a window to display an error message.  Handles both fatal and
X * non-fatal errors
X */
X
void
error_win(code, line_one, line_two)
int code;
char *line_one, *line_two;
X{
X	WINDOW *e_win, *newwin();
X	void cleanup(), st_line();
X
X					/* make sure we're in curses mode */
X	fixterm();
X	e_win = newwin(7, 70, 9, 5);
X					/* display the nasty note */
X	mvwaddstr(e_win, 2, 4, line_one);
X	mvwaddstr(e_win, 3, 4, line_two);
X	box(e_win, VERT, HORZ);
X
X	if (code) {
X		mvwattrstr(e_win, 0, 4, A_BOLD, " Error ");
X		mvwattrstr(e_win, 5, 24, A_BLINK, "Press any key to exit");
X		wmove(e_win, 5, 46);
X	}
X	else {
X		mvwattrstr(e_win, 0, 4, A_BOLD, " Warning ");
X		mvwattrstr(e_win, 5, 22, A_BLINK, "Press any key to continue");
X		wmove(e_win, 5, 48);
X	}
X	beep();
X	wrefresh(e_win);
X					/* if inside a script */
X	if (status->dup_fd != -1)
X		wait_key(e_win, 5);
X	else
X		wgetch(e_win);
X	werase(e_win);
X	wrefresh(e_win);
X	delwin(e_win);
X
X	if (code) {
X		st_line("   exiting");
X		cleanup(code);
X	}
X	return;
X}
END_OF_FILE
if test 2176 -ne `wc -c <'pexit.c'`; then
    echo shar: \"'pexit.c'\" unpacked with wrong size!
fi
# end of 'pexit.c'
fi
if test -f 'redial.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'redial.c'\"
else
echo shar: Extracting \"'redial.c'\" \(2378 characters\)
sed "s/^X//" >'redial.c' <<'END_OF_FILE'
X/*
X * The redial option (actually a misnomer, it's really a queuing system).
X * We expect a space-separated list of dialing directory entries (although
X * new users always try to put in a phone number).  A non-zero return code
X * means we're ready to dial.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "dial_dir.h"
X#include "misc.h"
X
int
redial()
X{
X	extern int fd;
X	WINDOW *rd_win, *newwin();
X	char *ans, *entry, *get_str(), *strchr(), *strtok(), ld_code, buf[256];
X	int i, oops, number, ret_code;
X
X	rd_win = newwin(6, 70, 5, 5);
X
X	mvwaddstr(rd_win, 4, 23, "(<CR> for previous numbers)");
X	mvwaddstr(rd_win, 2, 4, "Directory Entry Number(s): ");
X	box(rd_win, VERT, HORZ);
X
X	mvwattrstr(rd_win, 0, 3, A_BOLD, " Redial Queue ");
X	wmove(rd_win, 2, 31);
X	wrefresh(rd_win);
X					/* get the string of numbers */
X	ret_code = 0;
X	while ((ans = get_str(rd_win, 35, "0123456789+-@# ", "")) != NULL) {
X		oops = 0;
X		if (*ans == '\0') {
X					/* use previous queue */
X			if (dir->q_num[0] != -1) {
X				ret_code++;
X				break;
X			}
X					/* there is no previous queue */
X			beep();
X			mvwattrstr(rd_win, 3, 4, A_BOLD, "No previous numbers");
X			wrefresh(rd_win);
X			wait_key(rd_win, 3);
X			clear_line(rd_win, 3, 4, TRUE);
X			wmove(rd_win, 2, 31);
X			wrefresh(rd_win);
X			continue;
X		}
X					/* parse the queue values */
X		entry = strtok(ans, " \t");
X		for (i=0; i<NUM_QUEUE; i++) {
X			if (entry == NULL) {
X				dir->q_num[i] = -1;
X				continue;
X			}
X					/* is there a LD code? */
X			ld_code = '\0';
X			if (strchr("+-@#", *entry)) {
X				ld_code = *entry;
X				entry++;
X			}
X
X			/*
X			 * Zero is valid here, because it means use
X			 * the current entry information.
X			 */
X			number = atoi(entry);
X			if (number > NUM_DIR || *dir->number[number] == '\0') {
X				beep();
X				sprintf(buf, "Invalid or empty directory entry number %d", number);
X				mvwattrstr(rd_win, 3, 14, A_BOLD, buf);
X				wrefresh(rd_win);
X				wait_key(rd_win, 3);
X				clear_line(rd_win, 3, 4, TRUE);
X				clear_line(rd_win, 2, 31, TRUE);
X				wrefresh(rd_win);
X				oops++;
X				break;
X			}
X					/* store the number in the queue */
X			dir->q_ld[i] = ld_code;
X			dir->q_num[i] = number;
X			entry = strtok((char *) NULL, " \t");
X		}
X		if (oops) {
X			dir->q_num[0] = -1;
X			continue;
X		}
X		ret_code++;
X		break;
X	}
X	if (fd == -1) {
X		werase(rd_win);
X		wrefresh(rd_win);
X	}
X	delwin(rd_win);
X	return(ret_code);
X}
END_OF_FILE
if test 2378 -ne `wc -c <'redial.c'`; then
    echo shar: \"'redial.c'\" unpacked with wrong size!
fi
# end of 'redial.c'
fi
if test -f 'screen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screen.c'\"
else
echo shar: Extracting \"'screen.c'\" \(1213 characters\)
sed "s/^X//" >'screen.c' <<'END_OF_FILE'
X/*
X * Routines to read and copy the virtual screen image file.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "param.h"
X#include "status.h"
X
X/*
X * Do a screen dump.  Actually, the screen is already dumped, all we
X * do is copy the file.
X */
X
void
screen_dump()
X{
X	FILE *fp_out, *uid_fopen();
X	char buf[128];
X	void error_win();
X	int i;
X					/* open for append */
X	if (!(fp_out = uid_fopen(param->dumpfile, "a"))) {
X		sprintf(buf, "\"%s\" for write", param->dumpfile);
X		error_win(0, "Can't open screen dump file", buf);
X		return;
X	}
X	for (i=0; i<status->max_row; i++)
X		fprintf(fp_out, "%s\n", status->vs[i]);
X
X	fclose(fp_out);
X
X	return;
X}
X
X/*
X * Read the virtual screen and paint its contents to the stdscr using
X * curses(3).  Move the cursor where it belongs.
X */
X
void
load_vs()
X{
X	register int i;
X
X	clearok(curscr, TRUE);
X	erase();
X
X	for (i=0; i<status->max_row; i++)
X		mvaddstr(i, 0, status->vs[i]);
X
X	move(status->row, status->col);
X
X	refresh();
X	return;
X}
X
X/*
X * Clear the virtual screen.
X */
X
void
vs_clear(start_row)
int start_row;
X{
X	int i;
X	char *memset();
X
X	for (i=0; i<status->max_row; i++)
X		memset(status->vs[i], ' ', status->max_col);
X
X	status->row = start_row;
X	status->col = 0;
X	return;
X}
END_OF_FILE
if test 1213 -ne `wc -c <'screen.c'`; then
    echo shar: \"'screen.c'\" unpacked with wrong size!
fi
# end of 'screen.c'
fi
if test -f 'st_line.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'st_line.c'\"
else
echo shar: Extracting \"'st_line.c'\" \(2072 characters\)
sed "s/^X//" >'st_line.c' <<'END_OF_FILE'
X/*
X * Display the status line.  Up to now, we've never really cared how
X * large the physical screen was... but now we want the status line
X * on the bottom.
X */
X
X#include <curses.h>
X#include "config.h"
X#include "dial_dir.h"
X#include "misc.h"
X#include "modem.h"
X#include "param.h"
X#include "status.h"
X
void
st_line(message)
char *message;
X{
X	extern int xmc;
X	WINDOW *sl_win, *newwin();
X	int d, x, y;
X	static char *dn[2] = {"FDX", "HDX"};
X	static char *ln[2] = {"LOG OFF", "LOG ON"};
X	static char *pn[2] = {"PTR OFF", "PTR ON "};
X	char buf[80], field_one[15], *cur_tty;
X
X					/* is anybody missing? */
X	if (dir == NULL || modem == NULL || param == NULL)
X		return;
X					/* remember where we parked the car.. */
X	getyx(stdscr, y, x);
X
X	sl_win = newwin(1, 80, LINES-1, 0);
X					/* duplex message */
X	d = 0;
X	if (dir->duplex[0] == 'H')
X		d++;
X					/* the current TTY */
X	cur_tty = "No TTY";
X	if (modem->t_cur != -1)
X		cur_tty = modem->tty[modem->t_cur];
X
X	/*
X	 * The philosophy is:  If you press a command sequence that
X	 * doesn't generate a window on the screen, then show the user
X	 * what's going on in the status line.
X	 */
X	if (*message == '\0')
X		sprintf(field_one, " %4.4s-0 HELP  ", param->ascii_hot);
X	else
X		sprintf(field_one, " %-13.13s", message);
X
X#ifdef XMC_BROKE
X	if (xmc > 0)
X		sprintf(buf, "%s | %-9.9s| %s | %5d %c%d%d | %-7.7s | %-7.7s | %-5.5s|%-5.5s",
X		 field_one, cur_tty, dn[d], dir->baud[0], dir->parity[0],
X		 dir->data_bits[0], dir->stop_bits[0], ln[status->log_status],
X		 pn[status->print_status], param->cr_in, param->cr_out);
X	else
X#endif /* XMC_BROKE */
X		sprintf(buf, "%s | %-9.9s| %s | %5d %c%d%d | %-7.7s | %-7.7s | %-5.5s| %-5.5s",
X		 field_one, cur_tty, dn[d], dir->baud[0], dir->parity[0],
X		 dir->data_bits[0], dir->stop_bits[0], ln[status->log_status],
X		 pn[status->print_status], param->cr_in, param->cr_out);
X
X	if (xmc > 0) {
X		touchwin(sl_win);
X		werase(sl_win);
X		wrefresh(sl_win);
X	}
X	wattrstr(sl_win, A_STANDOUT, buf);
X	wrefresh(sl_win);
X					/* go ahead and delete it now */
X	delwin(sl_win);
X	move(y, x);
X	refresh();
X	return;
X}
END_OF_FILE
if test 2072 -ne `wc -c <'st_line.c'`; then
    echo shar: \"'st_line.c'\" unpacked with wrong size!
fi
# end of 'st_line.c'
fi
if test -f 'status.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'status.h'\"
else
echo shar: Extracting \"'status.h'\" \(701 characters\)
sed "s/^X//" >'status.h' <<'END_OF_FILE'
X/*
X * The status flags, and other various changeable things.
X */
X
X#define MAX_ROW		64
X#define MAX_COL		133
X
struct STATUS {
X	int	dup_fd;			/* fd for duplicating input */
X	int	cmd_ipc;		/* IPC for shell scripts */
X	int	connected;		/* are we connected to a remote? */
X	int	log_status;		/* status of log option */
X	char	*log_path;		/* data logging file */
X	int	print_status;		/* status of print option */
X	int	row;			/* cursor row position */
X	int	col;			/* cursor column position */
X	char	vs[MAX_ROW][MAX_COL];	/* the virtual screen */
X	int	max_row;		/* the virtual screen demensions */
X	int	max_col;		/* the virtual screen demensions */
X};
X
X#ifndef MAIN
extern struct STATUS *status;
X#endif /* MAIN */
END_OF_FILE
if test 701 -ne `wc -c <'status.h'`; then
    echo shar: \"'status.h'\" unpacked with wrong size!
fi
# end of 'status.h'
fi
if test -f 'vcs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vcs.h'\"
else
echo shar: Extracting \"'vcs.h'\" \(330 characters\)
sed "s/^X//" >'vcs.h' <<'END_OF_FILE'
X/*
X * Definitions to support the detection of video command sequences
X */
X
X#define VCS_SIZE	25
X#define NUM_VCS		9
X
X#define HOME		0
X#define CLR_EOL		1
X#define CLR_EOS		2
X#define CLEAR		3
X#define MV_UP		4
X#define MV_DOWN		5
X#define MV_RIGHT	6
X#define MV_LEFT		7
X#define MV_DIRECT	8
X
X#define YES		1
X#define NO		0
X#define MAYBE		(-1)
END_OF_FILE
if test 330 -ne `wc -c <'vcs.h'`; then
    echo shar: \"'vcs.h'\" unpacked with wrong size!
fi
# end of 'vcs.h'
fi
if test -f 'waitfor.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'waitfor.c'\"
else
echo shar: Extracting \"'waitfor.c'\" \(1891 characters\)
sed "s/^X//" >'waitfor.c' <<'END_OF_FILE'
X/*
X * Wait for a string on the stdin.  Returns a 0 on success, 1 on failure
X * and -1 on error.  This is an external program designed to be used in
X * shell scripts.
X */
X
X#define TIMEOUT	10
X#define BUF_SIZ	1024
X
X#include <stdio.h>
X#include <signal.h>
X#include "config.h"
X
X#ifdef BSD
X#include <setjmp.h>
jmp_buf wf_buf;
X#endif /* BSD */
X
main(argc, argv)
int argc;
char *argv[];
X{
X	int i, j, timeout, diff, length;
X	char c, buf[BUF_SIZ], *string, *strcmp(), *strncpy();
X	long t, time();
X	void exit();
X
X	if (argc < 2 || argc > 3) {
X		fprintf(stderr, "Usage: waitfor -n string\n");
X		exit(-1);
X	}
X
X	if (argv[1][0] == '-') {
X		timeout = atoi(&argv[1][1]);
X		if (argc != 3) {
X			fprintf(stderr, "Usage: waitfor -n string\n");
X			exit(-1);
X		}
X		string = argv[2];
X	}
X	else {
X		timeout = TIMEOUT;
X		string = argv[1];
X	}
X					/* here we go.. */
X	i = 0;
X	length = strlen(string);
X	time(&t);
X	while ((time((long *) 0) - t) < timeout) {
X		if ((j = getc_line()) != -1) {
X			c = j & 0x7f;
X					/* no NULLs please */
X			if (c == '\0')
X				continue;
X
X			buf[i++] = c;
X			buf[i] = '\0';
X					/* roll the buffer over */
X			if (i == BUF_SIZ -1) {
X				strncpy(buf, &buf[BUF_SIZ/2], BUF_SIZ/2);
X				i = BUF_SIZ/2;
X			}
X					/* is it possible? */
X			diff = i - length;
X			if (diff < 0)
X				continue;
X
X			if (!strcmp(&buf[diff], string))
X				exit(0);
X		}
X	}
X	exit(1);
X}
X
static int wf_flag;
static int wf_force();
X
int
getc_line()
X{
X	char c;
X	unsigned int alarm();
X
X	signal(SIGALRM, (SIG_TYPE(*) ()) wf_force);
X	wf_flag = 0;
X
X	alarm(1);
X
X#ifdef BSD
X	if (setjmp(wf_buf))
X		return(-1);
X#endif /* BSD */
X
X	if (read(0, &c, 1) <= 0) {
X		alarm(0);
X		return(-1);
X	}
X	if (wf_flag)
X		return(-1);
X	alarm(0);
X	return(c & 0xff);
X}
X
X/* ARGSUSED */
static int
wf_force(dummy)
int dummy;
X{
X#ifdef BSD
X	longjmp(wf_buf, 1);
X#else /* BSD */
X	signal(SIGALRM, (SIG_TYPE(*) ()) wf_force);
X	wf_flag = 1;
X	return(0);
X#endif /* BSD */
X}
END_OF_FILE
if test 1891 -ne `wc -c <'waitfor.c'`; then
    echo shar: \"'waitfor.c'\" unpacked with wrong size!
fi
# end of 'waitfor.c'
fi
if test -f 'x_extrnl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'x_extrnl.c'\"
else
echo shar: Extracting \"'x_extrnl.c'\" \(2107 characters\)
sed "s/^X//" >'x_extrnl.c' <<'END_OF_FILE'
X/*
X * Spawn a shell with the stdin and stdout swapped with the remote
X * system, ie:
X *                               +----------+
X *    TTYin ------------> stdin  |          |
X *                               |  shell   |
X *    TTYout <---------- stdout  |          |
X *                               +----------+
X *
X * An undocumented feature:  The external protocol gateway
X * can be used to pipe the output of a normal Unix command to the
X * remote system.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include <signal.h>
X#include <errno.h>
X#include "config.h"
X
void
do_extrnl(cmd)
char *cmd;
X{
X	extern int fd, errno;
X	WINDOW *xt_win, *newwin();
X	int epid, want_out, dummy;
X	unsigned int sleep();
X	void _exit(), line_set();
X
X					/* a full window */
X	xt_win = newwin(LINES, COLS, 0, 0);
X	nl();
X	touchwin(xt_win);
X	wrefresh(xt_win);
X
X	if (!(epid = fork())) {
X					/* create a new process group ID */
X#ifdef BSD
X		setpgrp(0, getpid());
X#else /* BSD */
X		setpgrp();
X#endif /* BSD */
X					/* swap the stdin and stdout */
X		close(0);
X		dup(fd);
X		close(1);
X		dup(fd);
X
X		setgid(getgid());
X		setuid(getuid());
X
X		execl("/bin/sh", "sh", "-c", cmd, (char *) 0);
X		_exit(1);
X	}
X
X	/*
X	 * Check the keyboard while the external program is running.  If
X	 * the user hits the <ESC> key, then kill the entire process
X	 * group associated with the new shell.
X	 */
X	want_out = 0;
X	/* CONSTCOND */
X	while(1) {
X		switch(wait_key(stdscr, 1)) {
X			case -1:	/* timed out */
X				break;
X			case 27:	/* a user abort */
X#ifdef BSD
X				killpg(epid, SIGKILL);
X#else /* BSD */
X				kill(-epid, SIGKILL);
X#endif /* BSD */
X				want_out++;
X				break;
X			default:
X				beep();
X				break;
X		}
X		if (want_out)
X			break;
X					/* see if the process it still active */
X#ifdef BSD
X		if ((kill(epid, 0) == -1) && errno == ESRCH) 
X#else /* BSD */
X		if ((kill(-epid, 0) == -1) && errno == ESRCH) 
X#endif /* BSD */
X			break;
X	}
X					/* no zombies please */
X	wait(&dummy);
X					/* the tty may have been clobbered */
X	sleep(1);
X	fixterm();
X	line_set();
X	nonl();
X
X	clearok(curscr, TRUE);
X	werase(xt_win);
X	wrefresh(xt_win);
X	delwin(xt_win);
X	return;
X}
END_OF_FILE
if test 2107 -ne `wc -c <'x_extrnl.c'`; then
    echo shar: \"'x_extrnl.c'\" unpacked with wrong size!
fi
# end of 'x_extrnl.c'
fi
if test -f 'x_win.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'x_win.c'\"
else
echo shar: Extracting \"'x_win.c'\" \(1944 characters\)
sed "s/^X//" >'x_win.c' <<'END_OF_FILE'
X/*
X * Display the file transfer window, and invoke the transfer protocol.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "dial_dir.h"
X#include "misc.h"
X#include "status.h"
X#include "xmodem.h"
X
void
xfer_win(list, up, type)
char *list;
int up, type;
X{
X	extern int fd;
X	WINDOW *xf_win, *newwin();
X	int ack_error;
X	void xmodem_mode(), line_set(), st_line();
X
X	touchwin(stdscr);
X	refresh();
X	st_line("");
X
X	xf_win = newwin(15, 44, 2, 30);
X	/*
X	 * This window should be in the non-blocking mode, so we can
X	 * scan the keyboard for input while transferring a file.
X	 */
X	tty_noblock(0, TRUE);
X					/* basic window stuff */
X	mvwaddstr(xf_win, 2, 14, "Protocol:");
X	mvwaddstr(xf_win, 3, 13, "File name:");
X	mvwaddstr(xf_win, 4, 13, "File size:");
X	mvwaddstr(xf_win, 5, 4, "Error check method:");
X	mvwaddstr(xf_win, 6, 5, "Est transfer time:");
X	mvwaddstr(xf_win, 7, 11, "Block count:");
X	mvwaddstr(xf_win, 8, 6, "Percent complete:");
X	mvwaddstr(xf_win, 9, 5, "Bytes transferred:");
X	mvwaddstr(xf_win, 10, 5, "Errors this block:");
X	mvwaddstr(xf_win, 11, 5, "Total error count:");
X	mvwaddstr(xf_win, 12, 10, "Last message: NONE");
X	box(xf_win, VERT, HORZ);
X
X	if (up)
X		mvwattrstr(xf_win, 0, 17, A_BOLD, " Uploading ");
X	else
X		mvwattrstr(xf_win, 0, 16, A_BOLD, " Downloading ");
X
X	mvwaddstr(xf_win, 14, 11, " Press <ESC> to abort ");
X	wrefresh(xf_win);
X					/* fix up the terminal mode */
X	xmodem_mode(fd);
X
X	if (up)
X		ack_error = send_xmodem(xf_win, list, type);
X	else
X		ack_error = rcv_xmodem(xf_win, list, type);
X
X	tty_noblock(0, FALSE);
X					/* prompt for a key on errors */
X	if (ack_error) {
X		beep();
X		clear_line(xf_win, 13, 9, TRUE);
X		wattrstr(xf_win, A_BOLD, "Press any key to continue");
X		wrefresh(xf_win);
X					/* if inside a script */
X		if (status->dup_fd != -1)
X			wait_key(xf_win, 5);
X		else
X			wgetch(xf_win);
X	}
X	werase(xf_win);
X	wrefresh(xf_win);
X	delwin(xf_win);
X					/* undo what xmodem_mode() did */
X	line_set();
X	return;
X}
END_OF_FILE
if test 1944 -ne `wc -c <'x_win.c'`; then
    echo shar: \"'x_win.c'\" unpacked with wrong size!
fi
# end of 'x_win.c'
fi
if test -f 'xmodem.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xmodem.h'\"
else
echo shar: Extracting \"'xmodem.h'\" \(562 characters\)
sed "s/^X//" >'xmodem.h' <<'END_OF_FILE'
X/*
X * Definitions for the xmodem stuff.
X */
X
X#define MAX_ERRORS	10
X
X#define SOH		1
X#define STX		2
X#define EOT		4
X#define ACK		6
X#define NAK		21
X#define CAN		24
X#define CTRLZ		26
X
X#define NUM_INTERNAL	6
X#define XMODEM		1
X#define XMODEM_1k	2
X#define MODEM7		3
X#define YMODEM		4
X#define YMODEM_G	5
X#define XASCII		6
X#define EXT_1		7
X#define EXT_2		8
X#define EXT_3		9
X#define EXT_MANUAL	10
X
X#define ABORT		(-1)
X#define ERROR		(-2)
X#define CANCEL		(-3)
X
X#define CHECKSUM	0
X#define CRC_CHECKSUM	1
X#define CRC		2
X#define NONE		3
X
X#define DOWN_LOAD	0
X#define UP_LOAD		1
END_OF_FILE
if test 562 -ne `wc -c <'xmodem.h'`; then
    echo shar: \"'xmodem.h'\" unpacked with wrong size!
fi
# end of 'xmodem.h'
fi
echo shar: End of archive 1 \(of 6\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
