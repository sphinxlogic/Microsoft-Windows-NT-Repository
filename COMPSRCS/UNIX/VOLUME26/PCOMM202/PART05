Newsgroups: comp.sources.unix
From: fthood!egray@uxc.cso.uiuc.edu (Emmet Gray)
Subject: v26i157: pcomm-2.0.2 - a serial communications program (clone of ProComm), Part05/06
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: fthood!egray@uxc.cso.uiuc.edu (Emmet Gray)
Posting-Number: Volume 26, Issue 157
Archive-Name: pcomm-2.0.2/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 6)."
# Contents:  Unixpc.shar pcomm_cmd.c port.c
# Wrapped by vixie@gw.home.vix.com on Wed Apr 14 00:38:43 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Unixpc.shar' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Unixpc.shar'\"
else
echo shar: Extracting \"'Unixpc.shar'\" \(19535 characters\)
sed "s/^X//" >'Unixpc.shar' <<'END_OF_FILE'
X#! /bin/sh
X# This is a shell archive, meaning:
X# 1. Remove everything above the #! /bin/sh line.
X# 2. Save the resulting text in a file.
X# 3. Execute the file with /bin/sh (not csh) to create:
X#	Makefile
X#	Pcomm.modem
X#	Readme.7300
X#	Setup.sh
X#	config.h
X# This archive created: Sun Sep  6 13:04:17 1992
export PATH; PATH=/bin:/usr/bin:$PATH
echo shar: "extracting 'Makefile'" '(6665 characters)'
if test -f 'Makefile'
then
X	echo shar: "will not over-write existing file 'Makefile'"
else
sed 's/^X//' << \SHAR_EOF > 'Makefile'
XX#				PCOMM v2.0
XX#			for AT&T Unix PC 7300/3b1
XX
XX#for 80286 versions of SCO Xenix
XX#CFLAGS = -Od -DM_TERMINFO -Mle2 -LARGE
XX#LDFLAGS = -SEG 1000 -F 5000 -Mle2
XX#CURSES = -ltinfo -lx
XX
XX#for 80386 versions of SCO Xenix
XX#CFLAGS = -O -DM_TERMINFO
XX#LDFLAGS = -s
XX#CURSES = -ltinfo -lx
XX
XX#for the AT&T Unix PC 7300/3b1
XXLD = ld
XXSHLIB = /lib/crt0s.o /lib/shlib_c.ifile
XXOTHER = /lib/setvbuf.o /lib/doprnt.o -luipc
XX
XX#for Sun OS (using the System V compiler)
XX#CC = /usr/5bin/cc
XX#LD = /usr/5bin/cc
XX
XX#for SVR3.2
XX#SHLIB = -lc_s
XX#OTHER = -lpt
XX
XX#LD = cc
XX#SHLIB =
XX#OTHER =
XXCFLAGS = -O
XXLDFLAGS = -s
XXSHAR = shar -a
XX
XXBIN_DIR = /home/egray/bin
XXMAN_DIR = /usr/man1
XXMAN_EXT = 1
XXPCOMM_LIB = /local/lib/pcomm
XX
XX#for old curses (i.e. Berkeley systems)
XX#CURSES = -lcurses -ltermcap
XXCURSES = -lcurses
XX
XX#for systems without getcwd(3) or getopt(3)
XX#GETCWD.O = getcwd.o
XX#GETCWD.C = getcwd.c
XX#GETOPT.O = getopt.o
XX#GETOPT.C = getopt.c
XX
XX#for System V or Berkeley TTY interface
XX#TTY.O = tty_ucb.o
XX#TTY.C = tty_ucb.c
XXTTY.O = tty_att.o
XXTTY.C = tty_att.c
XX
XX#for System V poll() or Berkeley select()
XXIPC.O = ipc_ucb.o
XXIPC.C = ipc_ucb.c
XX#IPC.O = ipc_att.o
XX#IPC.C = ipc_att.c
XX
XXPCOMM = $(GETCWD.O) $(GETOPT.O) $(TTY.O) $(IPC.O) admin.o chg_dir.o cmd.o \
XX	curses.o d_delete.o d_lib.o d_manual.o d_menu.o d_print.o \
XX	d_prompt.o d_revise.o data_log.o di_delay.o di_win.o dial.o \
XX	e_lib.o expand.o help.o info.o init.o input.o list_dir.o ls_menu.o \
XX	m_lib.o macro.o main.o n_shell.o p_lib.o passthru.o pexit.o \
XX	port.o redial.o s_axfer.o s_extrnl.o s_gen.o s_menu.o s_modem.o \
XX	s_prompt.o s_term.o s_tty.o screen.o script.o st_line.o \
XX	strings.o terminal.o vcs.o x_ascii.o x_batch.o x_extrnl.o \
XX	x_menu.o x_rcv.o x_send.o x_win.o xmodem.o
XX
XXall:	pcomm waitfor matches pcomm_cmd
XX
XXpcomm:	$(PCOMM)
XX	$(LD) $(LDFLAGS) $(PCOMM) $(OTHER) -o pcomm $(CURSES) $(SHLIB)
XX
XXwaitfor: waitfor.o
XX	$(LD) $(LDFLAGS) waitfor.o -o waitfor $(SHLIB)
XX
XXmatches: matches.o
XX	$(LD) $(LDFLAGS) matches.o -o matches $(SHLIB)
XX
XXpcomm_cmd: pcomm_cmd.o
XX	$(LD) $(LDFLAGS) pcomm_cmd.o -o pcomm_cmd $(SHLIB)
XX
XXpcomm_cmd.o:
XX	$(CC) $(CFLAGS) -DIPC=\"$(IPC.C)\" -c pcomm_cmd.c
XX
XXinstall:
XX	cp pcomm waitfor matches pcomm_cmd $(BIN_DIR)
XX#	obviously this requires super-user privelidges...
XX#	chmod 4755 $(BIN_DIR)/pcomm
XX#	chown uucp $(BIN_DIR)/pcomm
XX
XXinstall_man:
XX	cp Pcomm.1 $(MAN_DIR)/pcomm.$(MAN_EXT)
XX	cp Pcomm_cmd.1 $(MAN_DIR)/pcomm_cmd.$(MAN_EXT)
XX	cp Waitfor.1 $(MAN_DIR)/waitfor.$(MAN_EXT)
XX	cp Matches.1 $(MAN_DIR)/matches.$(MAN_EXT)
XX
XXinstall_support:
XX	cp Pcomm.dial_dir $(PCOMM_LIB)/pcomm.dial_dir
XX	cp Pcomm.modem $(PCOMM_LIB)/pcomm.modem
XX	cp Pcomm.param $(PCOMM_LIB)/pcomm.param
XX	cp Pcomm.extrnl $(PCOMM_LIB)/pcomm.extrnl
XX
XXclean:
XX	rm pcomm waitfor matches pcomm_cmd
XX
XXlint:
XX	lint -p -Dlint $(GETCWD.C) $(GETOPT.C) $(TTY.C) $(IPC.C) admin.c \
XX	chg_dir.c cmd.c curses.c d_delete.c d_lib.c d_manual.c d_menu.c \
XX	d_print.c d_prompt.c d_revise.c data_log.c di_delay.c di_win.c \
XX	dial.c e_lib.c expand.c help.c info.c init.c input.c list_dir.c \
XX	ls_menu.c m_lib.c macro.c main.c n_shell.c p_lib.c passthru.c \
XX	pexit.c port.c redial.c s_axfer.c s_extrnl.c s_gen.c s_menu.c \
XX	s_modem.c s_prompt.c s_term.c s_tty.c screen.c script.c \
XX	st_line.c strings.c terminal.c vcs.c x_ascii.c x_batch.c \
XX	x_extrnl.c x_menu.c x_rcv.c x_send.c x_win.c xmodem.c $(CURSES)
XX	lint -p -Dlint -DIPC=\"$(IPC.C)\" pcomm_cmd.c
XX	lint -p -Dlint waitfor.c
XX	lint -p -Dlint matches.c
XX
XXshar:
XX	$(SHAR) Doc.me > pcomm_sh.1
XX	$(SHAR) Configure.sh Convert.sh Makefile Matches.1 Pcomm.1 \
XX	Pcomm.dial_dir Pcomm.extrnl Pcomm.modem Pcomm.param Pcomm_cmd.1 \
XX	Q_and_A Readme Release.notes Sample > pcomm_sh.2
XX	$(SHAR) Unixpc.shar Waitfor.1 admin.c chg_dir.c cmd.c cmd.h \
XX	config.h curses.c d_delete.c d_lib.c d_manual.c > pcomm_sh.3
XX	$(SHAR) d_menu.c d_print.c d_prompt.c d_revise.c data_log.c \
XX	di_delay.c di_win.c dial.c dial_dir.h e_lib.c expand.c extrnl.h \
XX	getcwd.c getopt.c help.c > pcomm_sh.4
XX	$(SHAR) info.c init.c input.c ipc.h ipc_att.c ipc_ucb.c \
XX	list_dir.c ls_menu.c m_lib.c macro.c main.c matches.c misc.h \
XX	modem.h n_shell.c > pcomm_sh.5
XX	$(SHAR) p_lib.c param.h passthru.c patchlevel.h pcomm_cmd.c \
XX	pexit.c port.c redial.c s_axfer.c s_extrnl.c s_gen.c > pcomm_sh.6
XX	$(SHAR) s_menu.c s_modem.c s_prompt.c s_term.c s_tty.c screen.c \
XX	script.c st_line.c status.h strings.c terminal.c tty_att.c \
XX	tty_ucb.c > pcomm_sh.7
XX	$(SHAR) vcs.c vcs.h waitfor.c x_ascii.c x_batch.c x_extrnl.c \
XX	x_menu.c x_rcv.c > pcomm_sh.8
XX	$(SHAR) x_send.c x_win.c xmodem.c xmodem.h > pcomm_sh.9
XX#	$(SHAR) Doc.out Matches.out Pcomm.out Pcomm_cmd.out Waitfor.out \
XX#	> pcomm_sh.10
XX
XXadmin.o:	config.h dial_dir.h param.h
XXchg_dir.o:	config.h misc.h
XXcmd.o:		cmd.h config.h dial_dir.h extrnl.h modem.h param.h status.h xmodem.h
XXcurses.o:	config.h misc.h status.h
XXd_delete.o:	dial_dir.h misc.h param.h
XXd_lib.o:	dial_dir.h param.h
XXd_manual.o:	config.h dial_dir.h misc.h
XXd_menu.o:	config.h dial_dir.h misc.h param.h
XXd_print.o:	config.h dial_dir.h misc.h
XXd_prompt.o:	dial_dir.h misc.h
XXd_revise.o:	dial_dir.h misc.h param.h
XXdata_log.o:	misc.h param.h status.h
XXdi_delay.o:	misc.h param.h
XXdi_win.o:	dial_dir.h misc.h modem.h param.h status.h
XXdial.o:		config.h dial_dir.h misc.h modem.h param.h
XXe_lib.o:	extrnl.h
XXexpand.o:	config.h
XXgetopt.o:	config.h
XXhelp.o:		config.h misc.h
XXinfo.o:		patchlevel.h
XXinit.o:		config.h misc.h status.h
XXinput.o:	config.h misc.h param.h status.h vcs.h
XXipc_att.o:	ipc.h
XXipc_ucb.o:	ipc.h
XXlist_dir.o:	misc.h
XXls_menu.o:	dial_dir.h misc.h param.h
XXm_lib.o:	modem.h
XXmacro.o:	misc.h param.h
XXmain.o:		config.h dial_dir.h extrnl.h misc.h modem.h param.h status.h
XXn_shell.o:	config.h
XXp_lib.o:	param.h
XXpassthru.o:	config.h misc.h
XXpexit.o:	dial_dir.h misc.h param.h status.h
XXport.o:		config.h dial_dir.h modem.h status.h
XXredial.o:	config.h dial_dir.h misc.h
XXs_axfer.o:	misc.h param.h
XXs_extrnl.o:	extrnl.h misc.h
XXs_gen.o:	misc.h param.h
XXs_menu.o:	misc.h
XXs_modem.o:	misc.h modem.h
XXs_prompt.o:	misc.h
XXs_term.o:	dial_dir.h misc.h param.h
XXs_tty.o:	misc.h modem.h
XXscreen.o:	param.h status.h
XXscript.o:	config.h dial_dir.h misc.h modem.h status.h 
XXst_line.o:	config.h dial_dir.h misc.h modem.h param.h status.h
XXstrings.o:	config.h
XXterminal.o:	config.h dial_dir.h ipc.h misc.h modem.h param.h status.h xmodem.h
XXtty_att.o:	dial_dir.h modem.h param.h
XXtty_ucb.o:	dial_dir.h modem.h param.h
XXvcs.o:		config.h status.h vcs.h
XXx_ascii.o:	config.h misc.h param.h
XXx_batch.o:	config.h misc.h xmodem.h
XXx_extrnl.o:	config.h
XXx_menu.o:	extrnl.h misc.h xmodem.h
XXx_rcv.o:	config.h dial_dir.h misc.h xmodem.h
XXx_send.o:	config.h dial_dir.h misc.h xmodem.h
XXx_win.o:	dial_dir.h misc.h status.h xmodem.h
XXxmodem.o:	config.h misc.h param.h xmodem.h
XX
XXpcomm_cmd.o:	config.h cmd.h $(IPC.C)
XXmatches.o:	config.h
XXwaitfor.o:	config.h
SHAR_EOF
if test 6665 -ne "`wc -c < 'Makefile'`"
then
X	echo shar: "error transmitting 'Makefile'" '(should have been 6665 characters)'
fi
fi
echo shar: "extracting 'Pcomm.modem'" '(153 characters)'
if test -f 'Pcomm.modem'
then
X	echo shar: "will not over-write existing file 'Pcomm.modem'"
else
sed 's/^X//' << \SHAR_EOF > 'Pcomm.modem'
XXTTY_1=ph1;OBM;0
XXTTY_2=tty000;DIRECT;0
XXMODEM_1a=OBM;;%;@;
XXMODEM_1b=N;CONNECT;CONNECT;;;;;
XXMODEM_1c=;;;
XXMODEM_2a=DIRECT;;;;
XXMODEM_2b=N;;;;;;;
XXMODEM_2c=;;;
SHAR_EOF
if test 153 -ne "`wc -c < 'Pcomm.modem'`"
then
X	echo shar: "error transmitting 'Pcomm.modem'" '(should have been 153 characters)'
fi
fi
echo shar: "extracting 'Readme.7300'" '(5766 characters)'
if test -f 'Readme.7300'
then
X	echo shar: "will not over-write existing file 'Readme.7300'"
else
sed 's/^X//' << \SHAR_EOF > 'Readme.7300'
XX				  Pcomm v2.0
XX			 Additional Notes for users of
XX			     AT&T Unix PC 7300/3b1
XX
XX	1) This version of Pcomm *REQUIRES* the pseudo-tty and socket
XX	emulation library called "uipc" found on osu-cis.
XX
XX	2) You must run the Setup.sh shell script (as root) before
XX	attempting to compile Pcomm.  The shell script will create a 
XX	new link directive file, extract a few missing objects from
XX	the C library, and create a new sys/time.h header.
XX
XX	3) The shared libraries on your system contain Terminal Access
XX	Method (TAM) routines in lieu of curses(3) routines.  However,
XX	many of the routines have the same names!  This means that
XX	curses library is not compatible with the shared library.  So,
XX	to circumvent the problem, an alternate shared library "link
XX	directive file" is needed.  The Setup.sh script creates this
XX	file.
XX
XX	4) Before Pcomm can be compiled, the curses library routines
XX	must be installed on your system.  The diskette labeled
XX	"Curses/Terminfo Programmer's Package" is a part of the "Unix
XX	Development Set".  Likewise, before Pcomm can be used, the
XX	terminfo database must be installed.  The diskettes labeled
XX	"Curses/Terminfo End User Package" and "Terminfo Database" are
XX	a part of the "Unix Foundation Set"
XX
XX	5) Did you know that your system can use DEC vt100 style line
XX	drawing character?  Curses automatically uses the "alternate"
XX	character set (if found) to draw the boxes and lines rather than
XX	using the "-" and "|" characters.  To allow your system to use
XX	this feature, there are two things you must do:
XX
XX		1) Load the line drawing font in slot 1 prior to running
XX		a program requiring them.  This can be done by typing:
XX
XX			setf /usr/lib/wfont/BLD.ft 1
XX
XX		...or permanently install this font in slot 1 by adding
XX		the following two lines to the end of the /etc/rc file:
XX
XX			sfont /usr/lib/wfont/BLD.ft 1
XX			setf /usr/lib/wfont/BLD.ft 1
XX
XX		2) Tell curses(3) about the alternate character set by
XX		editing the terminfo database.
XX
XX		To get a copy of the terminfo entry to play with,
XX		you type:
XX
XX			infocmp -I s4 > s4.ti
XX
XX		now add the following line (with a leading tab) to the
XX		"s4.ti" file:
XX
XX			acsc=+h\,g.e-fjjkkllmmnnqqttuuvvwwxx,
XX
XX		recompile the new entry:
XX
XX			tic s4.ti
XX
XX	There is one disadvantage...  Sometimes line noise will switch
XX	you to the line drawing character set while you're communicating
XX	with a remote!
XX
XX	6) The "tset" command is broken on every version of Unix this
XX	box has ever seen (it is commented out of /etc/profile for a
XX	good reason).  One of tset's functions was to send a string to
XX	initialize the settings of the terminal and to set the tab
XX	stops.  The fact that this program isn't used is often
XX	overlooked because the console (as well as a lot of other
XX	terminals) doesn't require any initialization.  However, if you
XX	call into your system from a remote terminal that *does* require
XX	initialization, you've got trouble.
XX
XX	For example, curses(3) looks at the terminfo database to see if
XX	your terminal has "hardware tabs", if so, it expects the tab
XX	stops to be set.  Ignoring tabs by using "stty -tabs" (to
XX	convert tabs to spaces) won't work, in fact, curses(3) RESETS
XX	things as if you had typed "stty tabs"!
XX
XX	Likewise, my terminfo entry for PCPLUS v1.1's emulation of a
XX	vt102 has "^[)0" in the initialization string to load the line
XX	drawing character set.  It needs to be sent to the terminal
XX	before running Pcomm.
XX
XX	Some versions of Unix have a "init" option to the "tput" command
XX	to perform all the initialization.  If so, you should edit the
XX	/etc/profile to add the following commands at the bottom:
XX
XX		tput init
XX		tabs
XX
XX	If your version of tput doesn't recognize the "init" option, a
XX	somewhat longer solution is to edit /etc/profile and add the
XX	following commands at the bottom:
XX
XX		eval `tput iprog`
XX		tput is1
XX		tput is2
XX		if [ -n "`tput hts`" ] ;then
XX			stty tabs
XX		else
XX			stty -tabs
XX		fi
XX		tabs
XX		cat -s "`tput if`"
XX		tput is3
XX		echo "\r\c"
XX
XX	7) Pcomm makes (an arrogant) assumption that the phone line for
XX	the OBM is already configured in the DATA mode.  Users with only
XX	one phone line attached to ph0 will have to manually switch the
XX	line to the DATA mode before using Pcomm and then switch it back
XX	to VOICE afterwards.  To aid in this task, the following shell
XX	script could be used:
XX
XX		phtoggle
XX		sleep 1
XX		/usr/local/bin/pcomm $*
XX		phtoggle
XX
XX	Users with one phone line attached to ph0 will have to change
XX	the TTY setup since the default Pcomm.modem file assumes that
XX	ph1 is being used.
XX
XX	If you only have one phone line but *always* use it in the DATA
XX	mode, there is another solution.  Did you know that you can fool
XX	your machine into having a one-line system in the DATA mode?
XX	All you have to do is re-configure the Telephone Setup and tell
XX	the machine that you've got two lines (one line to be shared
XX	between VOICE and DATA on ph0, and one line to be DATA only on
XX	ph1).  Then you just never plug the phone line into ph0, you use
XX	ph1 instead.  The Telephone Setup menu is reached through the
XX	Office of install, Administration, Hardware Setup menues.
XX
XX	8. The SETUID_BROKE pre-processor variable was designed to take
XX	care of systems that aren't able to switch back and forth
XX	between the real and effective user id.  On the Unix PC, this
XX	problem only exists if the program is set-group-id.  So, if
XX	you're running HDB UUCP and have Pcomm set-user-id to uucp, you
XX	don't need to have SETUID_BROKE defined.
XX
XX	9. The default tunable parameters for the size of INPUT_BUF and
XX	OUTPUT_BUF for the Unix PC are rather small in order to prevent a
XX	"choppy" appearance on the screen.  However, if you have
XX	installed the serial patch (called "serial_pat.Z" on osu-cis),
XX	then the nominal sizes of 64 and 32 for INPUT_BUF and OUTPUT_BUF
XX	will provide much better performance.
SHAR_EOF
if test 5766 -ne "`wc -c < 'Readme.7300'`"
then
X	echo shar: "error transmitting 'Readme.7300'" '(should have been 5766 characters)'
fi
fi
echo shar: "extracting 'Setup.sh'" '(1852 characters)'
if test -f 'Setup.sh'
then
X	echo shar: "will not over-write existing file 'Setup.sh'"
else
sed 's/^X//' << \SHAR_EOF > 'Setup.sh'
XXecho This shell script will create a new link directive file, extract
XXecho a few missing objects from the C libraries, and create a new
XXecho sys/time.h header file.
XX
XXecho
XXecho cd /lib
XXcd /lib
XX
XXecho cp shlib.ifile shlib_c.ifile
XXcp shlib.ifile shlib_c.ifile
XX
XXecho editing shlib_c.ifile
XXex - shlib_c.ifile << "EOF"
XX1,$s/^PC/xPC/
XX1,$s/^BC/xBC/
XX1,$s/^UP/xUP/
XX1,$s/^ospeed/xospeed/
XX1,$s/^LINES/xLINES/
XX1,$s/^COLS/xCOLS/
XX1,$s/^tgetflag/xtgetflag/
XX1,$s/^tgetent/xtgetent/
XX1,$s/^tgetstr/xtgetstr/
XX1,$s/^tgetnum/xtgetnum/
XX1,$s/^tgoto/xtgoto/
XX1,$s/^tputs/xtputs/
XX1,$s/^wrefresh/xwrefresh/
XX1,$s/^initscr/xinitscr/
XX1,$s/^cbreak/xcbreak/
XX1,$s/^nl/xnl/
XX1,$s/^flushinp/xflushinp/
XX1,$s/^noecho/xnoecho/
XX1,$s/^savetty/xsavetty/
XX1,$s/^resetty/xresetty/
XX1,$s/^echo/xecho/
XX1,$s/^nocbreak/xnocbreak/
XX1,$s/^nonl/xnonl/
XX1,$s/^keypad/xkeypad/
XX1,$s/^endwin/xendwin/
XX1,$s/^printw/xprintw/
XX1,$s/^fixterm/xfixterm/
XX1,$s/^resetterm/xresetterm/
XX1,$s/^setterm/xsetterm/
XX1,$s/^baudrate/xbaudrate/
XXw
XXq
XXEOF
XX
XXecho ar x libc.a doprnt.o setvbuf.o
XXar x libc.a doprnt.o setvbuf.o
XX
XXecho creating /usr/include/sys/time.h
XXcat > /usr/include/sys/time.h << "EOF"
XX/*
XX * The sys/time.h stuff extracted from select.h in the UIPC code.
XX */
XX
XX#ifndef sys_time_h
XX#define sys_time_h
XX
XXstruct timeval {
XX	long	tv_sec;		/* seconds */
XX	long	tv_usec;	/* and microseconds */
XX};
XX
XX/*
XX * Operations on timevals.
XX *
XX * NB: timercmp does not work for >= or <=.
XX */
XX#define	timerisset(tvp)		((tvp)->tv_sec || (tvp)->tv_usec)
XX#define	timercmp(tvp, uvp, cmp)	\
XX	((tvp)->tv_sec cmp (uvp)->tv_sec || \
XX	 (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec)
XX#define	timerclear(tvp)		(tvp)->tv_sec = (tvp)->tv_usec = 0
XX
XX#endif
XXEOF
XX
XXif [ ! -f /lib/libuipc.a -a ! -f /usr/lib/libuipc.a ] ;then
XX	echo "Can't find the uipc library..."
XX	echo "Pcomm v2.0 *REQUIRES* this public domain socket emulation library"
XXfi
SHAR_EOF
if test 1852 -ne "`wc -c < 'Setup.sh'`"
then
X	echo shar: "error transmitting 'Setup.sh'" '(should have been 1852 characters)'
fi
fi
echo shar: "extracting 'config.h'" '(2524 characters)'
if test -f 'config.h'
then
X	echo shar: "will not over-write existing file 'config.h'"
else
sed 's/^X//' << \SHAR_EOF > 'config.h'
XX/*
XX * Various tunable parameters.  This should appear before any other local
XX * header file.
XX */
XX
XX/* Are you using a Berkeley flavor of Unix? */
XX#undef	BSD
XX
XX/* Use the dialing routines specific to the AT&T Unix PC 7300/3b1 */
XX#define	UNIXPC
XX
XX/* Older versions of curses(3) use termcap in lieu of terminfo */
XX#undef	OLDCURSES
XX
XX/* Should a missing video attribute be promoted to standout? */
XX#define	NOPROMOTE
XX
XX/* Should Pcomm make a log of all phone calls? */
XX#define	LOG_CALLS
XX
XX/* The name of the log file (if used).  */
XX#define	LOG_FILE	"/usr/adm/phone.calls"
XX
XX/* Should long distance (toll) calls be limited to a specific group? */
XX#undef	LIMIT_LD
XX
XX/* The name of the privileged group for limiting long distance calls */
XX#define	GROUP_NAME	"uucp"
XX
XX/* The path to the line printer program */
XX#define	LPR		"lp -s"
XX
XX/* The path to the "pretty" printer program (if none, use "pr | lp") */
XX#define	LPRINT		"pr | lp -s"
XX
XX/* The path to the default directory containing the Pcomm support files */
XX#define	DEFAULT_DIR	"/local/lib/pcomm"
XX
XX/* The path to the directory where UUCP locks are found */
XX#define	LOCK_DIR	"/usr/spool/uucp"
XX
XX/* Do the lock files use ASCII encoded PID's? */
XX#undef	ASCII_PID
XX
XX/* Fold the last character of the lock to lower case? */
XX#undef	XENIX_LOCKS
XX
XX/* Use the new SVR4 lock format? */
XX#undef	SVR4_LOCKS
XX
XX/* Does the status line scroll up on "magic cookie" terminals? */
XX#undef	XMC_BROKE
XX
XX/* Does the alarm() system call work correctly with the wgetch() function? */
XX#undef	WGETCH_BROKE
XX
XX/* Does the O_NDELAY mode tend to stick around when asked to leave? */
XX#undef	O_NDELAY_BROKE
XX
XX/* The size of the serial port character buffer (or Stream buffer) */
XX#define	CLIST_SIZ	64
XX
XX/* The size of the input buffer (should be about the same as CLIST_SIZ) */
XX#define	INPUT_BUF	64
XX
XX/* The size of the output buffer (should be about one half INPUT_BUF) */
XX#define	OUTPUT_BUF	32
XX
XX/* Does memmove() exist or is memcpy() well behaved when overlapping? */
XX/* #define	MEMMOVE(a,b,c)	memmove(a,b,c) */
XX#define	MEMMOVE(a,b,c)	memcpy(a,b,c)
XX/* #define	MEMMOVE(a,b,c)	bcopy(b,a,c) */
XX
XX/* Does your Unix allow flip-flop between real and effective user IDs? */
XX#undef	SETUID_BROKE
XX
XX/* Does your system have the strstr() function? */
XX#undef	HAVE_STRSTR
XX
XX/* Does your system have the usleep() function? */
XX#undef	HAVE_USLEEP
XX
XX/* Does your system have the truncate() system call? */
XX#undef	HAVE_TRUNCATE
XX
XX/* typedef void SIG_TYPE; */
XXtypedef int SIG_TYPE;
XX
XX#ifdef BSD
XX#define	strchr	index
XX#define	strrchr	rindex
XX#endif /* BSD */
SHAR_EOF
if test 2524 -ne "`wc -c < 'config.h'`"
then
X	echo shar: "error transmitting 'config.h'" '(should have been 2524 characters)'
fi
fi
exit 0
X#	End of shell archive
END_OF_FILE
if test 19535 -ne `wc -c <'Unixpc.shar'`; then
    echo shar: \"'Unixpc.shar'\" unpacked with wrong size!
fi
# end of 'Unixpc.shar'
fi
if test -f 'pcomm_cmd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pcomm_cmd.c'\"
else
echo shar: Extracting \"'pcomm_cmd.c'\" \(13550 characters\)
sed "s/^X//" >'pcomm_cmd.c' <<'END_OF_FILE'
X/*
X * An external command facility for Pcomm.  All of the "sanity checking"
X * is done at this end, so virtually no checking is done at Pcomm's end.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "config.h"
X#include "cmd.h"
X
X#ifdef BSD
X#include <sys/file.h>
X#else /* BSD */
X#include <fcntl.h>
X#endif /* BSD */
X
int cmd_ipc;
X
main(argc, argv)
int argc;
char *argv[];
X{
X	static char *cmds[] = {"SET", "QUERY", "IF", "DIAL", "REDIAL", "EXIT",
X	"CLEAR_SCREEN", "CHG_DIR", "HANG_UP", "PRINTER", "MODEM_BREAK", "SEND",
X	"RECEIVE", "SCREEN_DUMP", "DATA_LOG", 0};
X	static char *set_args[] = {"BAUD", "PARITY", "DATA_BITS", "STOP_BITS",
X	"DUPLEX", "AUX", "HOT_KEY", "ASCII_HOT", "FLOW_CTRL", "CR_IN",
X	"CR_OUT", "LOGFILE", "DUMPFILE", "STRIP", "LOCAL_ECHO", "EXPAND",
X	"CR_DELAY", "PACE", "CR_UP", "LF_UP", "TIMER", "CR_DN", "LF_DN", 0};
X	static char *qry_args[] = {"TTY_NAME", "MODEM_NAME", 0};
X	static char *if_args[] = {"CONNECTED", "LOG_STATUS", "PRINTER_STATUS",
X	0};
X	static char *xfer_args[] = {"XMODEM", "XMODEM_1K", "MODEM7", "YMODEM",
X	"YMODEM_G", "ASCII", "EXT_1", "EXT_2", "EXT_3", 0};
X	char *command, buf[256], *mkupper(), *arg1, *arg2, *s, *strchr();
X	char *pcomm_cmd, *getenv();
X	int cmd_num, i, arg_num, got_it;
X	unsigned int ui;
X	void send_cmd(), get_value(), exit(), cmd_exit();
X
X					/* get the environmental variable */
X	pcomm_cmd = getenv("PCOMM_CMD");
X	if (argc == 1 || pcomm_cmd == NULL || *pcomm_cmd == '\0') {
X		fprintf(stderr, "%s: This is a Pcomm support program.  It is intended for use inside\n", argv[0]);
X		fprintf(stderr, "an auto-login shell script\n");
X		exit(1);
X	}
X					/* parse the command line */
X	command = mkupper(argv[1]);
X	if (argc > 2)
X		arg1 = mkupper(argv[2]);
X	else
X		arg1 = "";
X	if (argc > 3)
X		arg2 = mkupper(argv[3]);
X	else
X		arg2 = "";
X					/* convert command to a number */
X	cmd_num = 0;
X	while (cmds[cmd_num] != NULL) {
X		if (!strcmp(command, cmds[cmd_num]))
X			break;
X		cmd_num++;
X	}
X					/* attach to the IPC channel */
X	if ((cmd_ipc = ipc_attach(pcomm_cmd, O_RDWR)) < 0) {
X		fprintf(stderr, "%s: Can't attach to IPC channel\n", argv[0]);
X		exit(1);
X	}
X					/* do it! */
X	switch(cmd_num) {
X		case SET:
X			if (argc < 4) {
X				fprintf(stderr, "%s: SET command requires 2 arguments\n", argv[0]);
X				cmd_exit(1);
X			}
X				
X			arg_num = 0;
X			while (set_args[arg_num] != NULL) {
X				if (!strcmp(arg1, set_args[arg_num]))
X					break;
X				arg_num++;
X			}
X			switch(arg_num) {
X				case BAUD:
X					ui = (unsigned int) atoi(arg2);
X					switch(ui) {
X						case 300:
X						case 1200:
X						case 2400:
X						case 4800:
X						case 9600:
X						case 19200:
X						case 38400:
X							break;
X						default:
X							fprintf(stderr, "%s: bad value '%s' for SET BAUD command\n", argv[0], argv[3]);
X							cmd_exit(1);
X					}
X					sprintf(buf, "%d", ui);
X					send_cmd(SET, BAUD, buf);
X					break;
X				case PARITY:
X					if (strcmp(arg2, "EVEN") && strcmp(arg2, "ODD") && strcmp(arg2, "NONE")) {
X						fprintf(stderr, "%s: bad value '%s' for SET PARITY command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					send_cmd(SET, PARITY, arg2);
X					break;
X				case DATA_BITS:
X					i = atoi(arg2);
X					if (i != 7 && i != 8) {
X						fprintf(stderr, "%s: bad value '%s' for SET DATA_BITS command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					sprintf(buf, "%d", i);
X					send_cmd(SET, DATA_BITS, buf);
X					break;
X				case STOP_BITS:
X					i = atoi(arg2);
X					if (i != 1 && i != 2) {
X						fprintf(stderr, "%s: bad value '%s' for SET STOP_BITS command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					sprintf(buf, "%d", i);
X					send_cmd(SET, STOP_BITS, buf);
X					break;
X				case DUPLEX:
X					if (strcmp(arg2, "FULL") && strcmp(arg2, "HALF")) {
X						fprintf(stderr, "%s: bad value '%s' for SET DUPLEX command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					send_cmd(SET, DUPLEX, arg2);
X					break;	
X				case AUX:
X					send_cmd(SET, AUX, argv[3]);
X					break;
X				case HOT_KEY:
X					i = atoi(arg2);
X					if (i <= 0 || i > 256) {
X						fprintf(stderr, "%s: bad value '%s' for SET HOT_KEY command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					send_cmd(SET, HOT_KEY, arg2);
X					break;
X				case ASCII_HOT:
X					send_cmd(SET, ASCII_HOT, argv[3]);
X					break;
X				case FLOW_CTRL:
X					if (strcmp(arg2, "XON/XOFF") && strcmp(arg2, "NONE")) {
X						fprintf(stderr, "%s: bad value '%s' for SET FLOW_CTRL command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					send_cmd(SET, FLOW_CTRL, arg2);
X					break;
X				case CR_IN:	
X					if (strcmp(arg2, "CR") && strcmp(arg2, "CR/LF")) {
X						fprintf(stderr, "%s: bad value '%s' for SET CR_IN command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					send_cmd(SET, CR_IN, arg2);
X					break;
X				case CR_OUT:
X					if (strcmp(arg2, "CR") && strcmp(arg2, "CR/LF")) {
X						fprintf(stderr, "%s: bad value '%s' for SET CR_OUT command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					send_cmd(SET, CR_OUT, arg2);
X					break;
X				case LOGFILE:
X					send_cmd(SET, LOGFILE, argv[3]);
X					break;
X				case DUMPFILE:
X					send_cmd(SET, DUMPFILE, argv[3]);
X					break;
X				case STRIP:	
X					if (strcmp(arg2, "YES") && strcmp(arg2, "NO")) {
X						fprintf(stderr, "%s: bad value '%s' for SET STRIP command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					send_cmd(SET, STRIP, arg2);
X					break;
X				case LOCAL_ECHO:	
X					if (strcmp(arg2, "YES") && strcmp(arg2, "NO")) {
X						fprintf(stderr, "%s: bad value '%s' for SET LOCAL_ECHO command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					send_cmd(SET, LOCAL_ECHO, arg2);
X					break;
X				case EXPAND:
X					if (strcmp(arg2, "YES") && strcmp(arg2, "NO")) {
X						fprintf(stderr, "%s: bad value '%s' for SET EXPAND command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					send_cmd(SET, EXPAND, arg2);
X					break;
X				case CR_DELAY:
X					i = atoi(arg2);
X					if (i != 0 && i != 100 && i != 150) {
X						fprintf(stderr, "%s: bad value '%s' for SET CR_DELAY command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					sprintf(buf, "%d", i);
X					send_cmd(SET, CR_DELAY, buf);
X					break;
X				case PACE:
X					if (strcmp(arg2, "YES") && strcmp(arg2, "NO")) {
X						fprintf(stderr, "%s: bad value '%s' for SET PACE command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					send_cmd(SET, PACE, arg2);
X					break;
X				case CR_UP:
X					if (strcmp(arg2, "NONE") && strcmp(arg2, "ADD_LF") && strcmp(arg2, "STRIP")) {
X						fprintf(stderr, "%s: bad value '%s' for SET CR_UP command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					send_cmd(SET, CR_UP, arg2);
X					break;
X				case LF_UP:
X					if (strcmp(arg2, "NONE") && strcmp(arg2, "ADD_CR") && strcmp(arg2, "STRIP")) {
X						fprintf(stderr, "%s: bad value '%s' for SET LF_UP command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					send_cmd(SET, LF_UP, arg2);
X					break;
X				case TIMER:
X					i = atoi(arg2);
X					if (i < 5 || i > 150) {
X						fprintf(stderr, "%s: bad value '%s' for SET TIMER command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					sprintf(buf, "%d", i);
X					send_cmd(SET, CR_DN, buf);
X					break;
X				case CR_DN:
X					if (strcmp(arg2, "NONE") && strcmp(arg2, "ADD_LF") && strcmp(arg2, "STRIP")) {
X						fprintf(stderr, "%s: bad value '%s' for SET CR_DN command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					send_cmd(SET, CR_DN, arg2);
X					break;
X				case LF_DN:	
X					if (strcmp(arg2, "NONE") && strcmp(arg2, "ADD_CR") && strcmp(arg2, "STRIP")) {
X						fprintf(stderr, "%s: bad value '%s' for SET LF_DN command\n", argv[0], argv[3]);
X						cmd_exit(1);
X					}
X					send_cmd(SET, LF_DN, arg2);
X					break;
X				default:
X					fprintf(stderr, "%s: Illegal argument '%s' for SET command\n", argv[0], argv[2]);
X					cmd_exit(1);
X					break;
X			}
X			break;
X		case QUERY:		/* the QUERY commands */
X			if (argc < 3) {
X				fprintf(stderr, "%s: QUERY command requires an argument\n", argv[0]);
X				cmd_exit(1);
X			}
X				
X			arg_num = 0;
X			while (qry_args[arg_num] != NULL) {
X				if (!strcmp(arg1, qry_args[arg_num]))
X					break;
X				arg_num++;
X			}
X
X			switch(arg_num) {
X				case TTY_NAME:
X					send_cmd(QUERY, TTY_NAME, "dummy");
X					get_value();
X					break;
X				case MODEM_NAME:
X					send_cmd(QUERY, MODEM_NAME, "dummy");
X					get_value();
X					break;
X				default:
X					fprintf(stderr, "%s: Illegal argument '%s' for QUERY command\n", argv[0], argv[2]);
X					cmd_exit(1);
X					break;
X			}
X			break;
X		case IF:		/* the IF commands */
X			if (argc < 3) {
X				fprintf(stderr, "%s: IF command requires an argument\n", argv[0]);
X				cmd_exit(1);
X			}
X				
X			arg_num = 0;
X			while (if_args[arg_num] != NULL) {
X				if (!strcmp(arg1, if_args[arg_num]))
X					break;
X				arg_num++;
X			}
X
X			switch(arg_num) {
X				case CONNECTED:
X					send_cmd(IF, CONNECTED, "dummy");
X					break;
X				case LOG_STATUS:
X					send_cmd(IF, LOG_STATUS, "dummy");
X					break;
X				case PRINTER_STATUS:
X					send_cmd(IF, PRINTER_STATUS, "dummy");
X					break;
X				default:
X					fprintf(stderr, "%s: Illegal argument '%s' for IF command\n", argv[0], argv[2]);
X					cmd_exit(1);
X					break;
X			}
X			break;
X		case DIAL:
X			if (argc < 3) {
X				fprintf(stderr, "%s: DIAL command requires an argument\n", argv[0]);
X				cmd_exit(1);
X			}
X			if (!strcmp(arg1, "MANUAL")) {
X				if (argc < 4) {
X					fprintf(stderr, "%s: DIAL MANUAL command requires an argument\n", argv[0]);
X					cmd_exit(1);
X				}
X				send_cmd(DIAL, 1, argv[3]);
X			}
X			else {
X				if (s = strchr("+-@#", *argv[2]))
X					i = atoi(++s);
X				else
X					i = atoi(argv[2]);
X				if (i < 1 || i > 100) {
X					fprintf(stderr, "%s: bad value '%s' for DIAL command\n", argv[0], argv[2]);
X					cmd_exit(1);
X				}
X				send_cmd(DIAL, 0, argv[2]);
X			}
X			break;
X		case REDIAL:
X			if (argc < 3) {
X				fprintf(stderr, "%s: REDIAL command requires at least 1 argument\n", argv[0]);
X				cmd_exit(1);
X			}
X			send_cmd(REDIAL, 0, argv[2]);
X			break;
X		case EXIT:
X			send_cmd(EXIT, 0, "dummy");
X			/*
X			 * Don't wait for a return code... Pcomm won't be
X			 * around to send it!  So, assume it got there OK.
X			 */
X			cmd_exit(0);
X			break;
X		case CLEAR_SCREEN:
X			send_cmd(CLEAR_SCREEN, 0, "dummy");
X			break;
X		case CHG_DIR:
X			if (argc < 3) {
X				fprintf(stderr, "%s: CHG_DIR command requires an argument\n", argv[0]);
X				cmd_exit(1);
X			}
X			send_cmd(CHG_DIR, 0, argv[2]);
X			break;
X		case HANG_UP:
X			send_cmd(HANG_UP, 0, "dummy");
X			break;
X		case PRINTER:
X			if (argc < 3) {
X				fprintf(stderr, "%s: PRINTER command requires an argument\n", argv[0]);
X				cmd_exit(1);
X			}
X			if (strcmp(arg1, "ON") && strcmp(arg1, "OFF")) {
X				fprintf(stderr, "%s: bad value '%s' for PRINTER command\n", argv[0], argv[2]);
X				cmd_exit(1);
X			}
X			if (!strcmp(arg1, "ON"))
X				send_cmd(PRINTER, 1, "dummy");
X			else
X				send_cmd(PRINTER, 0, "dummy");
X			break;
X		case MODEM_BREAK:
X			send_cmd(MODEM_BREAK, 0, "dummy");
X			break;
X		case SEND:
X			if (argc < 4) {
X				fprintf(stderr, "%s: SEND command requires 2 arguments\n", argv[0]);
X				cmd_exit(1);
X			}
X			arg_num = 0;
X			got_it = 0;
X			while (xfer_args[arg_num] != NULL) {
X				if (!strcmp(xfer_args[arg_num], arg1)) {
X					got_it++;
X					break;
X				}
X				arg_num++;
X			}
X			if (!got_it) {
X				fprintf(stderr, "%s: Illegal argument '%s' for SEND command\n", argv[0], argv[2]);
X				cmd_exit(1);
X			}
X			send_cmd(SEND, ++arg_num, argv[3]);
X			break;
X		case RECEIVE:
X			if (argc < 3) {
X				fprintf(stderr, "%s: RECEIVE command requires at least 1 argument\n", argv[0]);
X				cmd_exit(1);
X			}
X			arg_num = 0;
X			got_it = 0;
X			while (xfer_args[arg_num] != NULL) {
X				if (!strcmp(xfer_args[arg_num], arg1)) {
X					got_it++;
X					break;
X				}
X				arg_num++;
X			}
X			if (!got_it) {
X				fprintf(stderr, "%s: Illegal argument '%s' for RECEIVE command\n", argv[0], argv[2]);
X				cmd_exit(1);
X			}
X			if (argc < 4)
X				send_cmd(RECEIVE, ++arg_num, "dummy");
X			else
X				send_cmd(RECEIVE, ++arg_num, argv[3]);
X			break;
X		case SCREEN_DUMP:
X			send_cmd(SCREEN_DUMP, 0, "dummy");
X			break;
X		case DATA_LOG:
X			if (!strcmp(arg1, "ON"))
X				send_cmd(DATA_LOG, 1, "dummy");
X			else
X				send_cmd(DATA_LOG, 0, "dummy");
X			break;
X		default:
X			fprintf(stderr, "%s: Illegal command '%s'\n", argv[0], argv[1]);
X			cmd_exit(1);
X			break;
X	}
X					/* get the return status */
X	if (ipc_read(cmd_ipc, buf, 256)) {
X#ifndef sparc
X		fprintf(stderr, "Can't read from IPC\n");
X#endif /* sparc */
X		cmd_exit(1);
X	}
X	cmd_exit(atoi(buf));
X}
X
X/*
X * Copy and convert a string to all upper case 
X */
X
char *
mkupper(string)
char *string;
X{
X	int i;
X	char buf[80], *ans, *strcpy(), *malloc();
X	void exit();
X
X	i = 0;
X	while (*string != '\0') {
X		if (islower(*string))
X			buf[i++] = toupper(*string);
X		else
X			buf[i++] = *string;
X		string++;
X		if (i == 79)
X			break;
X	}
X	buf[i] = '\0';
X	if ((ans = malloc((unsigned int) strlen(buf)+1)) == NULL) {
X		fprintf(stderr, "out of memory!\n");
X		exit(1);
X	}
X	strcpy(ans, buf);
X	
X	return(ans);
X}
X
X/*
X * Get a return value from a command, (and therefore exit prematurely).
X */
X
void 
get_value()
X{
X	char *s, *strchr(), buf[256];
X	void cmd_exit();
X
X	if (ipc_read(cmd_ipc, buf, 256)) {
X		fprintf(stderr, "Can't read from IPC\n");
X		cmd_exit(1);
X	}
X
X	if (s = strchr(buf, '\n'))
X		*++s = '\0';
X
X	printf("%s", buf);
X	cmd_exit(0);
X}
X
X/*
X * Send a command to the Pcomm process
X */
X
void
send_cmd(cmd, arg1, arg2)
int cmd, arg1;
char *arg2;
X{
X	char buf[256];
X	void cmd_exit();
X
X	sprintf(buf, "%d %d %249.249s\n", cmd, arg1, arg2);
X	if (ipc_write(cmd_ipc, buf, 256)) {
X		fprintf(stderr, "Can't write to IPC\n");
X		cmd_exit(1);
X	}
X	return;
X}
X
X/*
X * Clean up and go home...
X */
X
void
cmd_exit(n)
int n;
X{
X	void exit();
X
X	ipc_detach(cmd_ipc);
X	exit(n);
X}
X
X#define MAIN
X#include IPC
END_OF_FILE
if test 13550 -ne `wc -c <'pcomm_cmd.c'`; then
    echo shar: \"'pcomm_cmd.c'\" unpacked with wrong size!
fi
# end of 'pcomm_cmd.c'
fi
if test -f 'port.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'port.c'\"
else
echo shar: Extracting \"'port.c'\" \(13371 characters\)
sed "s/^X//" >'port.c' <<'END_OF_FILE'
X/*
X * Routines to get or release a TTY port.
X */
X
X#define MAX_PID	30000
X#define TRUE	1
X#define FALSE	0
X
X#include <stdio.h>
X#include <errno.h>
X#include "config.h"
X#include "dial_dir.h"
X#include "modem.h"
X#include "status.h"
X
X#ifdef BSD
X#include <sys/file.h>
X#else /* BSD */
X#include <fcntl.h>
X#endif /* BSD */
X
X#ifdef UNIXPC
X#include <sys/phone.h>
X#endif /* UNIXPC */
X
X#ifdef XENIX_LOCKS
X#include <ctype.h>
X#endif /* XENIX_LOCKS */
X
X#ifdef SVR4_LOCKS
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <sys/mkdev.h>
X#endif /* SVR4_LOCKS */
X
static int getty_status = 0;
static char *lock_path = NULL;
static int set_getty(), checklock(), ck_speed();
X
X/*
X * Finds a free (or requested) serial port.  Creates a lock file to hold
X * for our use.  Loads the modem database.  A non-zero return code means
X * all ports (or the requested port) are busy.
X */
X
int
get_port()
X{
X	extern int fd, errno;
X	register int i;
X	int j, k, lfd, list[NUM_TTY], cmask, aux,  progpid, keep_it, trash_it;
X	char file[80], buf[80], message[80], *str_rep();
X	void error_win(), line_set(), release_port(), send_str(), ipc_update();
X#ifdef XENIX_LOCKS
X	char *last_c;
X#endif /* XENIX_LOCKS */
X
X	aux = chk_aux(dir->aux[dir->d_cur]);
X	/*
X	 * If you already have a port, see if it is good enough for the
X	 * current request.
X	 */
X	if (fd != -1) {
X		keep_it = 0;
X		trash_it = 0;
X					/* got the requested TTY ? */
X		if (aux == IS_TTY) {
X			if (!strcmp(dir->aux[dir->d_cur], modem->tty[modem->t_cur]))
X				keep_it++;
X			else
X				trash_it++;
X		}
X					/* got the requested Modem? */
X		if (aux == IS_MODEM) {
X			if (!strcmp(dir->aux[dir->d_cur], modem->tname[modem->t_cur]))
X				keep_it++;
X			else
X				trash_it++;
X		}
X					/* can it handle the request baud? */
X		if (ck_speed(modem->t_cur, dir->baud[dir->d_cur]))
X			keep_it++;
X
X		if (keep_it && !trash_it) {
X			/*
X			 * Reset the line parameters, because baud rate,
X			 * etc. may have changed.
X			 */
X			if (dir->d_cur != 0) {
X				dir->baud[0] = dir->baud[dir->d_cur];
X				dir->parity[0] = dir->parity[dir->d_cur];
X				dir->data_bits[0] = dir->data_bits[dir->d_cur];
X				dir->stop_bits[0] = dir->stop_bits[dir->d_cur];
X				dir->duplex[0] = dir->duplex[dir->d_cur];
X				dir->aux[0] = str_rep(dir->aux[0], dir->aux[dir->d_cur]);
X			}
X			line_set();
X			return(0);
X		}
X	}
X
X	/*
X	 * If we have a script running, we can't swap TTY ports, because
X	 * we've already forked the child process with "fd" as an open
X	 * file descriptor.  Changing "fd" in the parent won't change the
X	 * "fd" in the child.
X	 */
X	if (fd != -1 && status->dup_fd != -1) {
X		error_win(0, "Can't change TTYs while a script is being played", "dial aborted");
X		return(1);
X	}
X
X	release_port(VERBOSE);
X
X	list[0] = -1;
X	/*
X	 * See if you want a specific TTY port.  If the auxiliary field in
X	 * the dialing directory is a valid device name, then use that TTY.
X	 */
X	if (aux == IS_TTY) {
X		for (i=0; i<modem->t_entries; i++) {
X					/* and it exists in modem database */
X			if (!strcmp(dir->aux[dir->d_cur], modem->tty[i])) {
X				list[0] = i;
X				list[1] = -1;
X				break;
X			}
X		}
X					/* oops... we don't know that port */
X		if (list[0] == -1) {
X			sprintf(message, "Device \"%s\" in the auxiliary field doesn't exist in", dir->aux[dir->d_cur]);
X			sprintf(buf, "modem/TTY database \"%s\"", modem->m_path);
X			error_win(0, message, buf);
X			return(1);
X		}
X	}
X
X	/*
X	 * If we haven't specified a port, create a list of acceptable TTYs.
X	 * It searches the modem database for the requested baud rate.
X	 */
X	k = 0;
X	if (list[0] == -1) {
X		for (i=0; i<modem->t_entries; i++) {
X					/* skip ports with no modems */
X			if (!strcmp(modem->tname[i], "DIRECT"))
X				continue;
X
X					/* weed out the modems we don't want */
X			if (aux == IS_MODEM) {
X				if (strcmp(modem->tname[i], dir->aux[dir->d_cur]))
X					continue;
X			}
X					/* can handle requested baud rate? */
X			if (ck_speed(i, dir->baud[dir->d_cur]))
X				list[k++] = i;
X		}
X					/* the end of list marker */
X		list[k] = -1;
X	}
X					/* empty list? */
X	if (list[0] == -1) {
X		if (aux == IS_MODEM) {
X			sprintf(message, "The requested modem \"%s\" does not exists", dir->aux[dir->d_cur]);
X			sprintf(buf, "or does not support the requested baud rate %d", dir->baud[dir->d_cur]);
X		}
X		else {
X			sprintf(message, "No modem at a %d baud rating exists in the", dir->baud[dir->d_cur]);
X			sprintf(buf, "modem database \"%s\"", modem->m_path);
X		}
X		error_win(0, message, buf);
X		return(1);
X	}
X					/* check the list for a free port */
X	i = 0;
X	while (list[i] != -1) {
X					/* create a lock file name */
X#ifdef SVR4_LOCKS
X		struct stat sbuf;
X		sprintf(buf, "/dev/%s", modem->tty[list[i]]);
X		stat(buf, &sbuf);
X		sprintf(file, "%s/LK.%03d.%03d.%03d", LOCK_DIR, major(sbuf.st_dev), major(sbuf.st_rdev), minor(sbuf.st_rdev));
X#else /* SVR4_LOCKS */
X		sprintf(file, "%s/LCK..%s", LOCK_DIR, modem->tty[list[i]]);
X#endif /* SVR4_LOCKS */
X
X#ifdef XENIX_LOCKS
X		last_c = file + strlen(file)-1;
X		if (isupper(*last_c))
X			*last_c = tolower(*last_c);
X#endif /* XENIX_LOCKS */
X
X#ifdef DEBUG
X		fprintf(stderr, "get_port: checking '/dev/%s'\n", modem->tty[list[i]]);
X#endif /* DEBUG */
X
X					/* no lock exists or it is dead */
X		if (checklock(file)) {
X			getty_status = set_getty(modem->tty[list[i]], FALSE);
X
X			cmask = umask(0);
X			if ((lfd = open(file, O_CREAT|O_EXCL|O_WRONLY, 0666)) < 0) {
X				if (getty_status)
X					set_getty(modem->tty[list[i]], TRUE);
X				sprintf(buf, "\"%s\"", file);
X				error_win(0, "Can't create the lockfile", buf);
X				return(1);
X			}
X			umask(cmask);
X			progpid = getpid();
X#ifdef ASCII_PID
X			sprintf(buf, "%10d\n", progpid);
X			write(lfd, buf, 11);
X#else /* ASCII_PID */
X			write(lfd, (char *) &progpid, sizeof(int));
X#endif /* ASCII_PID */
X			close(lfd);
X					/* store the new values */
X			lock_path = str_rep(lock_path, file);
X			modem->t_cur = list[i];
X
X					/* load the modem data base */
X			modem->m_cur = -1;
X			for (j=0; j<modem->m_entries; j++) {
X				if (!strcmp(modem->tname[modem->t_cur], modem->mname[j])) {
X					modem->m_cur = j;
X					break;
X				}
X			}
X			if (modem->m_cur == -1) {
X				sprintf(buf, "Modem name \"%s\" in TTY database",
X				 modem->tname[modem->t_cur]);
X				error_win(0, buf, "does not exist in modem database");
X				modem->t_cur = -1;
X				return(1);
X			}
X
X					/* open the device (ignore DCD) */
X			sprintf(buf, "/dev/%s", modem->tty[modem->t_cur]);
X			if ((fd = open(buf, O_RDWR|O_NDELAY)) < 0) {
X				if (getty_status)
X					set_getty(modem->tty[modem->t_cur], TRUE);
X				/*
X				 * For systems that use flock() instead of
X				 * UUCP lock files
X				 */
X				if (errno == EBUSY) {
X					unlink(lock_path);
X					modem->m_cur = -1;
X					modem->t_cur = -1;
X					i++;
X					continue;
X				}
X				sprintf(file, "Can't open port \"%s\" for read and write", buf);
X				error_win(0, file, "");
X				modem->m_cur = -1;
X				modem->t_cur = -1;
X				return(1);
X			}
X					/* change line settings */
X			if (dir->d_cur != 0) {
X				dir->baud[0] = dir->baud[dir->d_cur];
X				dir->parity[0] = dir->parity[dir->d_cur];
X				dir->data_bits[0] = dir->data_bits[dir->d_cur];
X				dir->stop_bits[0] = dir->stop_bits[dir->d_cur];
X				dir->duplex[0] = dir->duplex[dir->d_cur];
X				dir->aux[0] = str_rep(dir->aux[0], dir->aux[dir->d_cur]);
X			}
X			line_set();
X
X					/* turn off the O_NDELAY setting */
X			tty_noblock(fd, FALSE);
X
X			/*
X			 * For some reason, the following witchcraft is
X			 * often required.
X			 */
X#ifdef O_NDELAY_BROKE
X			close(open(buf, O_RDWR));
X#endif /* O_NDELAY_BROKE */
X
X					/* initialize the modem */
X			send_str(modem->init[modem->m_cur], SLOW);
X					/* update the poll()/select() values */
X			ipc_update(fd, status->cmd_ipc);
X			return(0);
X		}
X		i++;
X	}
X	if (aux == IS_TTY) {
X		sprintf(buf, "The requested port \"%s\", is busy", modem->tty[modem->t_cur]);
X		error_win(0, buf, "Try again later");
X	}
X	else
X		error_win(0, "All ports are busy now, try again later", "");
X	return(1);
X}
X
X/*
X * Release the port.  Closes the file descriptor and removes the
X * lock file
X */
X
void
release_port(verbose)
int verbose;
X{
X	extern int fd;
X	extern char *null_ptr;
X	char buf[80];
X	void free_ptr(), hang_up(), reset_line(), error_win(), ipc_update();
X
X	/*
X	 * The modem structure can't be guaranteed to exist yet.  For example,
X	 * an error in reading one of the other support files would cause
X	 * this routine to be used before the MODEM structure gets allocated.
X	 */
X	if (modem == NULL)
X		return;
X					/* close the port */
X	if (fd != -1) {
X		tty_flush(fd, 2);
X		/*
X		 * Since HUPCL is set, the close() should drop the DTR and
X		 * hang up the modem (provided you've got the modem to
X		 * respond to DTR).  Since this is not guaranteed, we send
X		 * the hang_up string first.
X		 */
X		hang_up(verbose);
X		reset_line();
X		close(fd);
X	}
X					/* remove the lock */
X	if (lock_path != NULL && *lock_path != '\0') {
X		if (unlink(lock_path)) {
X			sprintf(buf, "\"%s\"", lock_path);
X			error_win(0, "Can't remove the lock file", buf);
X		}
X		free_ptr(lock_path);
X		lock_path = null_ptr;
X	}
X					/* turn the getty back on? */
X	if (getty_status && modem->t_cur != -1)
X		set_getty(modem->tty[modem->t_cur], TRUE);
X					/* clean up the structure */
X	fd = -1;
X	modem->m_cur = -1;
X	modem->t_cur = -1;
X	ipc_update(fd, status->cmd_ipc);
X	return;
X}
X
X/*
X * Turn the /etc/getty on or off for the specified port.  A non-zero return
X * code means that the getty was on.  Systems with uugetty() or dedicated
X * dialout ports won't need this routine.
X */
X
X/* ARGSUSED */
static int
set_getty(tty, on)
char *tty;
int on;
X{
X#ifdef UNIXPC
X	int i, ret_code;
X	char buf[40];
X	unsigned int sleep();
X					/* the last three characters */
X	i = strlen(tty) -3;
X
X	ret_code = 0;
X	if (on) {
X		sprintf(buf, "setgetty %s 1", tty+i);
X		system(buf);
X	}
X	else {
X		sprintf(buf, "setgetty %s 0", tty+i);
X		if (system(buf) == 512)
X			ret_code++;
X		sleep(1);
X	}
X	return(ret_code);
X#else /* UNIXPC */
X	/*
X	 * If you don't have one of these cute little routines, you
X	 * might wanna write one.  It should check for an existing lock
X	 * file, edit the /etc/inittab file, and issue an init -q.
X	 * The return code should tell if there was a getty or not.
X	 * Obviously the program would be suid to root.
X	 */
X	return(0);
X#endif /* UNIXPC */
X}
X
X/*
X * Check the lock file for a valid pid value.  Error conditions such
X * as not being able to open the lock file or not being able to interpret
X * the contents of the lock file cause the code to assume that the lock
X * file is valid.  Let the user worry about weird special cases.  A 
X * non-zero return code means the lock is dead or doesn't exist.
X */
X
static int
checklock(lockfile)
char *lockfile;
X{
X	extern int errno;
X	int lfd, lckpid;
X	unsigned int sleep();
X#ifdef ASCII_PID
X	int n;
X	char buf[40];
X#endif /* ASCII_PID */
X					/* doesn't exist */
X	if (access(lockfile, 0))
X		return(1);
X					/* can't open the lock file */
X	if ((lfd = open(lockfile, 0)) < 0)
X		return(0);
X
X#ifdef ASCII_PID
X	if ((n = read(lfd, buf, 40)) <= 0) {
X		close(lfd);
X		return(0);
X	}
X	close(lfd);
X	buf[n--] = '\0';
X	lckpid = atoi(buf);
X#else /* ASCII_PID */
X	if (read(lfd, (char *) &lckpid, sizeof(int)) != sizeof(int)) {
X		close(lfd);
X		return(0);
X	}
X	close(lfd);
X#endif /* ASCII_PID */
X					/* invalid pid? */
X	if (lckpid <= 0 || lckpid > MAX_PID)
X		return(0);
X
X	if ((kill(lckpid, 0) == -1) && (errno == ESRCH)) {
X		/*
X		 * If the kill was unsuccessful due to an ESRCH error,
X		 * that means the process is no longer active and the
X		 * lock file can be safely removed.
X		 */
X		unlink(lockfile);
X		sleep(1);
X		return(1);
X	}
X	/*
X	 * If the kill() was successful, that means the process must
X	 * still be active.
X	 */
X	return(0);
X}
X
X/*
X * Check to see if the desired baud rate can be handled by the modem.
X * Uses the connect strings to make this determination.  The first
X * argument is the index into the TTY database.  A non-zero return code
X * means "yes it can".
X */
X
static int
ck_speed(tty, baud)
int tty;
unsigned int baud;
X{
X	int i, mod;
X	char buf[60];
X	void error_win();
X					/* find the modem database */
X	mod = -1;
X	for (i=0; i<modem->m_entries; i++) {
X		if (!strcmp(modem->mname[i], modem->tname[tty])) {
X			mod = i;
X			break;
X		}
X	}
X	if (mod == -1) {
X		sprintf(buf, "Modem name \"%s\" in TTY database", modem->tname[tty]);
X		error_win(1, buf, "does not exist in modem database");
X	}
X
X#ifdef DEBUG
X	fprintf(stderr, "ck_speed: checking modem \"%s\" for %d baud\n", modem->mname[mod], baud);
X#endif /* DEBUG */
X
X	switch (baud) {
X		case 300:
X			if (*modem->con_3[mod] != '\0')
X				return(1);
X			break;
X		case 1200:
X			if (*modem->con_12[mod] != '\0')
X				return(1);
X			break;
X		case 2400:
X			if (*modem->con_24[mod] != '\0')
X				return(1);
X			break;
X		case 4800:
X			if (*modem->con_48[mod] != '\0')
X				return(1);
X			break;
X		case 7200:
X		case 9600:
X			if (*modem->con_96[mod] != '\0')
X				return(1);
X			break;
X		case 12000:
X		case 14400:
X		case 19200:
X			if (*modem->con_192[mod] != '\0')
X				return(1);
X			break;
X		case 38400:
X			if (*modem->con_384[mod] != '\0')
X				return(1);
X			break;
X	}
X	return(0);
X}
X
X/*
X * Check to see if the auxiliary field contains a valid TTY or modem name.
X */
X
chk_aux(aux)
char *aux;
X{
X	int i;
X	char buf[80], *strcpy(), *strcat();
X
X	if (*aux == '\0')
X		return(0);
X
X	strcpy(buf, "/dev/");
X	strcat(buf, aux);
X
X	if (!access(buf, 0))
X		return(IS_TTY);
X
X	for (i=0; i<modem->m_entries; i++) {
X		if (!strcmp(modem->mname[i], aux))
X			return(IS_MODEM);
X	}
X				  	/* Well, is not a TTY or modem */
X	return(IS_SCRIPT);
X}
END_OF_FILE
if test 13371 -ne `wc -c <'port.c'`; then
    echo shar: \"'port.c'\" unpacked with wrong size!
fi
# end of 'port.c'
fi
echo shar: End of archive 5 \(of 6\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
