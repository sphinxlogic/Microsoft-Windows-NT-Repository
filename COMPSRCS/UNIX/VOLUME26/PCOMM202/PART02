Newsgroups: comp.sources.unix
From: fthood!egray@uxc.cso.uiuc.edu (Emmet Gray)
Subject: v26i154: pcomm-2.0.2 - a serial communications program (clone of ProComm), Part02/06
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: fthood!egray@uxc.cso.uiuc.edu (Emmet Gray)
Posting-Number: Volume 26, Issue 154
Archive-Name: pcomm-2.0.2/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 6)."
# Contents:  Configure.sh Pcomm_cmd.1 Q_and_A admin.c d_print.c
#   d_prompt.c d_revise.c e_lib.c ls_menu.c macro.c s_axfer.c
#   s_extrnl.c s_gen.c s_menu.c s_prompt.c s_term.c s_tty.c script.c
#   strings.c tty_att.c tty_ucb.c
# Wrapped by vixie@gw.home.vix.com on Wed Apr 14 00:38:41 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Configure.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Configure.sh'\"
else
echo shar: Extracting \"'Configure.sh'\" \(3789 characters\)
sed "s/^X//" >'Configure.sh' <<'END_OF_FILE'
X:
X: what version of UUCP do you have?
if [ -f /usr/lib/uucp/Systems -o -f /etc/uucp/Systems ] ;then
X	echo "You've got the HoneyDanBer (HDB) version of UUCP"
X	echo "Therefore you need:	#define ASCII_PID"
else
X	if [ -f /usr/lib/uucp/L.sys ] ;then
X		echo "You've got the older version of UUCP (not HDB)"
X		echo "Therefore you need:	#undef ASCII_PID"
X	else
X		echo "Can't determine the UUCP version"
X	fi
fi
X:
X: check the location of the UUCP lock files
if [ -d /usr/spool/locks ] ;then
X	echo "Your UUCP lock files go in /usr/spool/locks"
X	echo "Therefore you need:	#define LOCK_DIR \"/usr/spool/locks\""
else
X	if [ -d /usr/spool/uucp/LCK ]; then
X		echo "Your UUCP lock files go in /usr/spool/uucp/LCK"
X		echo "Therefore you need:	#define LOCK_DIR \"/usr/spool/uucp/LCK\""
X	else
X		echo "Your UUCP lock files go in /usr/spool/uucp"
X		echo "Therefore you need:	#define LOCK_DIR \"/usr/spool/uucp\""
X	fi
fi
X:
X: check the version of curses
GOT_IT=0
if [ -f /usr/5include/curses.h ] ;then
X	GOT_IT=/usr/5include/curses.h
X	echo "You've got a System 5 compatibility library... use it!"
X	echo "Edit the Makefile:	CC=/usr/5bin/cc and LD=/usr/5bin/cc"
else
X	if [ -f /usr/include/curses.h ] ;then
X		GOT_IT=/usr/include/curses.h
X	else
X		echo "Can't determine your version of curses"
X	fi
fi
if [ "$GOT_IT" -eq 0 ] ;then
X	if [ `grep -c ACS_HLINE $GOT_IT` -gt 0 ] ;then
X		echo "You've got the newer version of curses"
X		echo "Therefore you need:	#undef OLDCURSES"
X	else
X		echo "You've got and old version of curses"
X		echo "Therefore you need:	#define OLDCURSES"
X	fi
fi
X:
X: check the libraries
echo checking your C library....
if [ -f /usr/5lib/libc.a ] ;then
X	ar t /usr/5lib/libc.a > /tmp/config.$$
else
X	if [ -f /usr/lib/libc.a ] ;then
X		ar t /usr/lib/libc.a > /tmp/config.$$
X	else
X		if [ -f /lib/libc.a ] ;then
X			ar t /lib/libc.a > /tmp/config.$$
X		else
X			if [ -f /usr/ccs/lib/libc.a ] ;then
X				ar t /usr/ccs/lib/libc.a > /tmp/config.$$
X			fi
X		fi
X	fi
fi
if [ -f /tmp/config.$$ ] ;then
X	if [ `grep -c "^poll.o" /tmp/config.$$` -eq 1 ] ;then
X		echo "You've got the poll() function"
X		echo "Edit the Makefile:	IPC.O=ipc_att.o and IPC.C=ipc_att.c"
X	else
X		if [ `grep -c "^select.o" /tmp/config.$$` -eq 1 ] ;then
X			echo "You've got the select() function"
X			echo "Edit the Makefile:	IPC.O=ipc_ucb.o and IPC.C=ipc_ucb.c"
X		else
X			echo "You don't seem to have either poll() or select()"
X			echo "Perhaps they are in another library?"
X		fi
X	fi
X	if [ `grep -c "^usleep.o" /tmp/config.$$` -eq 1 ] ;then
X		echo "You've got the usleep() function"
X		echo "Therefore you need:	#define HAVE_USLEEP"
X	else
X		echo "You don't have the usleep() function"
X		echo "Therefore you need:	#undef HAVE_USLEEP"
X	fi
X	if [ `grep -c "^strstr.o" /tmp/config.$$` -eq 1 ] ;then
X		echo "You've got the strstr() function"
X		echo "Therefore you need:	#define HAVE_STRSTR"
X	else
X		echo "You don't have the strstr() function"
X		echo "Therefore you need:	#undef HAVE_STRSTR"
X	fi
X	if [ `grep -c "^memmove.o" /tmp/config.$$` -eq 1 ] ;then
X		echo "You've got the memmove() function"
X		echo "Therefore you need:	#define MEMMOVE(a,b,c) memmove(a,b,c)"
X	else
X		if [ `grep -c "^memcpy.o" /tmp/config.$$` -eq 1 ] ;then
X			echo "You've got the memcpy() function"
X			echo "Therefore you need:	#define MEMMOVE(a,b,c) memcpy(a,b,c)"
X		else
X			if [ `grep -c "^bcopy.o" /tmp/config.$$` -eq 1 ] ;then
X				echo "You've got the bcopy() function"
X				echo "Therefore you need:	#define MEMMOVE(a,b,c) bcopy(b,a,c)"
X			fi
X		fi
X	fi
X	if [ `grep -c "^truncate.o" /tmp/config.$$` -eq 1 ] ;then
X		echo "You've got the truncate() function"
X		echo "Therefore you need:	#define HAVE_TRUNCATE"
X	else
X		echo "You don't have the truncate() function"
X		echo "Therefore you need:	#undef HAVE_TRUNCATE"
X	fi
X	rm /tmp/config.$$
else
X	echo "Can't determine your C functions"
fi
END_OF_FILE
if test 3789 -ne `wc -c <'Configure.sh'`; then
    echo shar: \"'Configure.sh'\" unpacked with wrong size!
fi
# end of 'Configure.sh'
fi
if test -f 'Pcomm_cmd.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Pcomm_cmd.1'\"
else
echo shar: Extracting \"'Pcomm_cmd.1'\" \(6127 characters\)
sed "s/^X//" >'Pcomm_cmd.1' <<'END_OF_FILE'
X.if n .ds rq ""
X.el .ds rq ''
X.if n .ds lq ""
X.el .ds lq ``
X.TH pcomm_cmd L
X.SH NAME
pcomm_cmd \- send a command to Pcomm
X.SH SYNOPSIS
X.B pcomm_cmd
X[ command ] [ options ] [ arguments ]
X.SH DESCRIPTION
X.I Pcomm_cmd
is a Pcomm support program.  It is used from inside shell scripts to access
Pcomm commands, such as
X.I \*(lqpcomm_cmd send xmodem junk\*(rq
for sending the file \*(lqjunk\*(rq to the remote using the xmodem file
transfer protocol.
X.PP
The following command line options are supported.
X.TP
SET BAUD [ 300 | 1200 | 2400 | 4800 | 9600 | 19200 | 38400 ]
Set the baud rate for the current connection.  This feature is for use
with the DIAL MANUAL command, since the baud rate information in the
dialing directory entries overrides this value. 
X.TP
SET PARITY [ EVEN | ODD | NONE ]
Set the parity for the current connection.  For use with the DIAL MANUAL
command.
X.TP
SET DATA_BITS [ 7 | 8 ]
The number of data bits (word length) used for the current connection.
XFor use with the DIAL MANUAL command.
X.TP
SET STOP_BITS [ 1 | 2 ]
The number of stop bits for the current connection.  For use with the
DIAL MANUAL command.
X.TP
SET DUPLEX [ HALF | FULL ]
Set the duplex mode (local echo).  The HALF option is used if the remote
system does not echo characters as they are typed.
X.TP
SET AUX filename
Use the argument as the auxiliary file associated with the current
connection.  Since chaining of scripts is not supported, this feature
would only be used to set the TTY or modem.
X.TP
SET HOT_KEY [1-256]
Change the decimal value of the \*(lqhot key\*(rq to this value.
X.TP
SET ASCII_HOT string
Change the ASCII representation of the hot key to the given argument.  The
length of the string must be no more than 4 characters wide.
X.TP
SET FLOW_CTRL [ XON/XOFF | NONE ]
Set the flow control between the local and remote systems to either XON/XOFF
or NONE.
X.TP
SET CR_IN [ CR | CR/LF ]
Translate in-comming carriage returns carriage return followed by a line
feed, or pass the carriage return through unchanged.
X.TP
SET CR_OUT [ CR | CR/LF ]
Translate out-going carriage returns to CR or CR/LF.
X.TP
SET LOGFILE filename
Change the name of the default log file.  For use with the DATA_LOG command.
X.TP
SET DUMPFILE filename
Change the name of the screen dump file.  For use with the SCREEN_DUMP 
command.
X.TP
SET STRIP [ YES | NO ]
Should the in-comming data be stripped to 7 bits?
X.TP
SET LOCAL_ECHO [ YES | NO ]
Should data be shown on the screen during ASCII uploads?
X.TP
SET EXPAND [ YES | NO ]
Should blank lines be \*(lqexpanded\*(rq to a line with a single space?
XFor use only during ASCII uploads.
X.TP
SET CR_DELAY [ 0 | 100 | 150 ]
Set the delay for the carraige returns for ASCII uploads.
X.TP
SET PACE [ YES | NO ]
Should the entire upload be artifically slowed down?  For use during ASCII
uploads.
X.TP
SET CR_UP [ NONE | ADD_LF | STRIP ]
Controls the translation of carraige returns during ASCII uploads.
X.TP
SET LF_UP [ NONE | ADD_CR | STRIP ]
Controls the translation of line feeds during ASCII uploads.
X.TP
SET TIMER [5-150]
Controls the timer (in seconds) that detects the end of an ASCII download.
X.TP
SET CR_DN [ NONE | ADD_LF | STRIP ]
Controls the translation of carraige returns during ASCII downloads.
X.TP
SET LF_DN [ NONE | ADD_CR | STRIP ]
Controls the translation of line feeds during ASCII downloads.
X.TP
QUERY TTY_NAME
Returns the name of the current TTY in use or NONE.
X.TP
QUERY MODEM_NAME
Returns the name of the current modem in use or NONE.
X.TP
IF CONNECTED
Returns a 1 if Pcomm is currently connected to a remote, otherwise a 0.
X.TP
IF LOG_STATUS
Returns a 1 if the data logging feature is turned on, otherwise 0.
X.TP
IF PRINTER_STATUS
Returns a 1 if the printer is turned on, otherwise 0.
X.TP
DIAL [ MANUAL phone_number ] entry_number
Dial an entry from the dialing directory.  The MANUAL option is used to
optionaly dial a phone number without the use of the dialing directory.
DIAL returns after 1 attempt.  A return code of 1 means a connection
was made.
X.ft I
The dial function will not be allowed to switch TTY ports.  If the current
TTY is not suitable (i.e. not attached to the correct modem), the script
will be terminated.
X.ft
X.TP
REDIAL entry_number
Similar to the DIAL command, but 10 attempts are made.
X.TP
XEXIT
Hang up the phone and exit from Pcomm.
X.TP
CLEAR_SCREEN
Clear the screen.
X.TP
CHG_DIR directory
Change the current working directory to the given directory.
X.TP
HANG_UP
Hang up the phone, but remain in Pcomm.
X.TP
PRINTER [ ON | OFF ]
Control the logging of data to the printer.
X.TP
MODEM_BREAK
Send a modem break to the remote system.  This is typically used to
tell the remote to switch to a different baud rate.
X.TP
SEND protocol filename
Send a file to the remote.  The valid protocols are XMODEM, XMODEM_1K,
MODEM7, YMODEM, YMODEM_G, ASCII, EXT_1, EXT_2, and EXT_3.
X.TP
RECEIVE protocol filename
Receive a file from the remote.  The valid protocols are XMODEM,
XXMODEM_1K, MODEM7, YMODEM, YMODEM_G, ASCII, EXT_1, EXT_2, and EXT_3.
X.TP
SCREEN_DUMP
Dump the current contents of the screen to the DUMPFILE.  If the file
already exists, the new contents are appended to the file.
X.TP
DATA_LOG [ ON | OFF ]
Control logging of the terminal session to the LOGFILE.  If the file
already exists, the new contents are appended to the file.
X.SH EXAMLES
The following is an example of a shell script that will dial a system,
log a user on, transfer a file called "junk" using xmodem, log out, and
exit Pcomm.
X.PP
X.nf
X.RS 5
X# dial entry number 23 in my dialing directory
pcomm_cmd dial 23
X# wait for the login prompt
waitfor ogin:
X# send my user id
echo egray
X# wait for the password prompt
waitfor assword:
X# send my passwd
echo abcdefg
X# wait for terminal type prompt
waitfor vt100
X# echo my type
echo vt100
X# wait for a Unix prompt
waitfor $
X# start up an xmodem file transfer
echo sx junk
X# wait for the sx command to say its ready
waitfor now
sleep 1
X# do a file transfer
pcomm_cmd receive xmodem junk
X# wait for the prompt
waitfor $
X# log me out
echo "^D"
sleep 1
X# exit pcomm
pcomm_cmd exit
X.fi
X.RE
X.SH "SEE ALSO"
pcomm(1), waitfor(1), matches(1), Pcomm Reference Manual
END_OF_FILE
if test 6127 -ne `wc -c <'Pcomm_cmd.1'`; then
    echo shar: \"'Pcomm_cmd.1'\" unpacked with wrong size!
fi
# end of 'Pcomm_cmd.1'
fi
if test -f 'Q_and_A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Q_and_A'\"
else
echo shar: Extracting \"'Q_and_A'\" \(3301 characters\)
sed "s/^X//" >'Q_and_A' <<'END_OF_FILE'
X			Questions and Answers
X		for the most common Pcomm problems.
X
X1) The "elpase time" doesn't increment during a dialing attempt.
X
X	This is a symptom of a bug in the wgetch() routine in the curses
X	library.  The work-around is to set WGETCH_BROKE in the config.h
X	file and recompile.
X
X2) I can't get Pcomm to dial, it just sits there.
X
X	This typically is due to the wrong device name for the tty port.
X	Some systems have more than one name (different minor device
X	numbers) for the same tty port.  UUCP may use the device name
X	that has "modem control" enabled; if so, that is the one Pcomm
X	needs to use.
X
X3) How do you make Sun's dial in and out on the same port?
X
X	Sun Sparc boxes don't come configured for doing dialin and dialout
X	on the same serial port.  However, there is a blurb in the printed
X	manual that tells you what to do...
X
X	Make a new device (cua0 for ttya, and/or cua1 for ttyb)
X		mknod /dev/cua0 c 12 128
X		mknod /dev/cua1 c 12 129
X
X	Edit /etc/ttytab.  Change the ttya (or ttyb) line to look like
X	the following.  Look in the /etc/gettytab file for the choices
X	for the second field (std.38400, in this example).
X		ttya   "/usr/etc/getty std.38400"  dialup    on remote secure
X		ttyb   "/usr/etc/getty std.38400"  dialup    on remote secure
X
X	Edit /etc/uucp/Devices.  Add a line for each speed your modem
X	supports.  The dialer field (hayes, in this example) must match
X	whatever you've got in /etc/uucp/Dialers.
X		ACU cua0 cua0 1200 hayes
X		ACU cua0 cua0 2400 hayes
X		ACU cua0 cua0 9600 hayes
X		ACU cua0 cua0 19200 hayes
X		ACU cua0 cua0 38400 hayes
X
X4) I get a measage that tells me I can't create the lockfile (or can't
open the tty port).
X
X	Pcomm is typically configured to be set-user-id to uucp.  To do
X	this, you type (as root):
X		chown uucp pcomm
X		chmod 4755 pcomm
X		
X5) As soon as I am connected, the modem lights go crazy.
X
X	This is probably caused by an improper UUCP lock file.  Pcomm
X	understands several variations of UUCP lock files, but must
X	match the one used by your UUCP.  Read the Readme file and check
X	the LOCK_DIR, ASCII_PID, SVR4_LOCKS, and XENIX_LOCKS in the
X	config.h file.
X
X6) I've got a V.32bis modem but without locked DTE speeds, how do I
setup Pcomm for this?
X
X	Change the tty database so that the "locked speed" entry is set
X	to zero.  Then change the "auto-baud detect" flag in the modem
X	database to 'N'.
X
X	In this configuration, the modem will always use the DTE speed
X	as specified in the dialing directory.  The status line will
X	show this speed, regardless of the actual connected baud rate.
X
X7) Some of the Pcomm screens appear messed up.
X
X	Yes, that's unfortunately quite common...  It's a bug in either
X	the curses library or the termcap/terminfo database.  I've
X	included a terminfo entry for AT386 in the Readme file, that
X	seemed to fix the problem for my 386 box.
X
X8) Where do I get xmodem/ymodem/zmodem stand-alone programs for Unix?
X
X	I use Xmodem v3.8 by Steve Grandi, and an older version of rzsz
X	by Omen Technologies.  Both of these should be available at a
X	neighboring archive site.
X
X9) I can't get the external zmodem programs "rz" and "sz" to work from
inside Pcomm.
X
X	The authors of rz and sz have deliberately broken the program so
X	that it will not work from inside another program.  See if you
X	can find an older version.
END_OF_FILE
if test 3301 -ne `wc -c <'Q_and_A'`; then
    echo shar: \"'Q_and_A'\" unpacked with wrong size!
fi
# end of 'Q_and_A'
fi
if test -f 'admin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'admin.c'\"
else
echo shar: Extracting \"'admin.c'\" \(2942 characters\)
sed "s/^X//" >'admin.c' <<'END_OF_FILE'
X/*
X * Perform administrative functions.  Check to see if the user has
X * permission to make long distance calls, and record all phone calls
X * made by Pcomm.
X */
X
X#include <stdio.h>
X#include <grp.h>
X#include "config.h"
X#include "dial_dir.h"
X#include "param.h"
X
static char *build_num();
X
X/*
X * Make a log of all calls made by Pcomm.  The argument is the index
X * into the queue.
X */
X
X/* ARGSUSED */
void
log_calls(i)
int i;
X{
X#ifdef LOG_CALLS
X	FILE *fp;
X	char *number, *date, *ctime(), *getlogin(), buf[80];
X	long now, time();
X	void error_win();
X					/* build the complete phone number */
X	number = build_num(i);
X					/* build date and time */
X	time(&now);
X	date = ctime(&now);
X	date[10] = '\0';
X	date[16] = '\0';
X
X	if (!(fp = fopen(LOG_FILE, "a+"))) {
X					/* fatal! (to prevent hanky panky) */
X		sprintf(buf, "Can't open log file \"%s\"", LOG_FILE);
X		error_win(1, buf, "Contact your system administrator");
X	}
X
X	fprintf(fp, "pcomm: %s called %s at %s on %s\n", getlogin(), number, &date[11], date);
X	fclose(fp);
X#endif /* LOG_CALLS */
X	return;
X}
X
X/*
X * Check to see if long distance (toll) call is authorized.  The argument
X * is the index into the queue.
X */
X
X/* ARGSUSED */
int
limit_ld(i)
int i;
X{
X#ifdef LIMIT_LD
X	char *number, *name, *getlogin();
X	struct group *getgrnam(), *grpbuf;
X
X					/* if no group, don't bother */
X	grpbuf = getgrnam(GROUP_NAME);
X	if (grpbuf == NULL || *grpbuf->gr_mem == '\0')
X		return(0);
X					/* are you in the group? */
X	name = getlogin();
X	for (; *grpbuf->gr_mem!='\0'; grpbuf->gr_mem++) {
X		if (!strcmp(*grpbuf->gr_mem, name))
X			return(0);
X	}
X					/* numbers only... */
X	number = build_num(i);
X
X	/*
X	 * VERY SITE SPECIFIC!!!  We use a "9" to get an outside line,
X	 * so any 9 followed by a 1 is a toll call (except for 1-800
X	 * numbers).
X	 */
X	if (!strncmp(number, "91", 2) && strncmp(number, "91800", 5)) {
X		error_win(0, "You are not authorized to place long distance (toll) calls", "");
X		return(1);
X	}
X
X	if (*number == '\0') {
X		error_win(0, "You are not authorized direct access to the line", "Use the automatic dialing feature");
X		return(1);
X	}
X#endif /* LIMIT_LD */
X	return(0);
X}
X
X#if defined(LOG_CALLS) || defined(LIMIT_LD)
X/*
X * Put together the complete phone number but strip out the extraneous
X * characters.
X */
X
static char *
build_num(i)
int i;
X{
X	int j;
X	char *t, temp[80], *strcpy(), *strcat();
X	static char ans[80];
X
X	temp[0] = '\0';
X					/* add LD codes? */
X	switch (dir->q_ld[i]) {
X		case 0:
X			break;
X		case '+':
X			strcpy(temp, param->ld_plus);
X			break;
X		case '-':
X			strcpy(temp, param->ld_minus);
X			break;
X		case '@':
X			strcpy(temp, param->ld_at);
X			break;
X		case '#':
X			strcpy(temp, param->ld_pound);
X			break;
X	}
X					/* add the number */
X	strcat(temp, dir->number[dir->q_num[i]]);
X
X					/* copy only digits */
X	j = 0;
X	t = temp;
X	while (*t) {
X		if (*t >= '0' && *t <= '9')
X			ans[j++] = *t;
X		t++;
X	}
X	ans[j] = '\0';
X
X	return(ans);
X}
X#endif /* LOG_CALLS || LIMIT_LD */
END_OF_FILE
if test 2942 -ne `wc -c <'admin.c'`; then
    echo shar: \"'admin.c'\" unpacked with wrong size!
fi
# end of 'admin.c'
fi
if test -f 'd_print.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'d_print.c'\"
else
echo shar: Extracting \"'d_print.c'\" \(3986 characters\)
sed "s/^X//" >'d_print.c' <<'END_OF_FILE'
X/*
X * The print option of the dialing directory.  A carriage return will
X * send the dialing directory to the print spool program, otherwise the
X * selected file will be used.
X */
X
X#define MAX_STRING	80
X
X#include <stdio.h>
X#include <curses.h>
X#include "config.h"
X#include "dial_dir.h"
X#include "misc.h"
X
static char *e_get_str();
X
void
print_dir()
X{
X	FILE *fp, *n_popen(), *uid_fopen();
X	WINDOW *p_win, *newwin();
X	char *ans, *file, buf[100], *expand();
X	int is_printer, i;
X	void error_win();
X	unsigned int sleep();
X
X	p_win = newwin(5, 54, 0, 26);
X
X	mvwaddstr(p_win, 2, 3, "Print to: (printer)");
X	box(p_win, VERT, HORZ);
X	wmove(p_win, 2, 13);
X	wrefresh(p_win);
X
X	/*
X	 * This is a special version of get_str() that looks at the
X	 * first character to see if it should erase the default answer
X	 * already on the screen.
X	 */
X	if ((ans = e_get_str(p_win, 80)) == NULL) {
X					/* erase because it overlaps dm_win */
X		werase(p_win);
X		wrefresh(p_win);
X		delwin(p_win);
X		return;
X	}
X	file = expand(ans);
X	is_printer = 0;
X					/* the default (printer) */
X	if (*file == '\0') {
X		if (!(fp = n_popen(LPRINT, "w"))) {
X			sprintf(buf, "\"%s\"", LPRINT);
X			error_win(0, "Can't open printer program", buf);
X			werase(p_win);
X			wrefresh(p_win);
X			delwin(p_win);
X			return;
X		}
X		is_printer++;
X	}
X					/* the requested file */
X	else {
X		/*
X		 * Check to see if the file already exists (and if you
X		 * have write permission too).  Currently only allows
X		 * you to bail out or overwrite the file (no append).
X		 */
X		switch(can_write(file)) {
X			case DENIED:
X				sprintf(buf, "\"%s\"", file);
X				error_win(0, "No write permission on file", buf);
X				werase(p_win);
X				wrefresh(p_win);
X				delwin(p_win);
X				return;
X			case OK_BUT_EXISTS:
X				werase(p_win);
X				mvwprintw(p_win, 2, 3, "File \"%s\" already exists!", file);
X				beep();
X				box(p_win, VERT, HORZ);
X				if (!yes_prompt(p_win, 3, 3, A_BOLD, "Overwrite")) {
X					werase(p_win);
X					wrefresh(p_win);
X					delwin(p_win);
X					return;
X				}
X				/* FALLTHRU */
X			case WRITE_OK:
X				if (!(fp = uid_fopen(file, "w"))) {
X					sprintf(buf, "\"%s\"", file);
X					error_win(0, "Can't open file", buf);
X					werase(p_win);
X					wrefresh(p_win);
X					delwin(p_win);
X					return;
X				}
X				break;
X		}
X	}
X
X	werase(p_win);
X	mvwaddstr(p_win, 2, 13, "Printing Pcomm directory");
X	box(p_win, VERT, HORZ);
X	wrefresh(p_win);
X
X	/*
X	 * Only prints up to the end of the physical file, not the entire
X	 * structure.  I gave some thought about not printing empty entries,
X	 * but...
X	 */
X	for (i=1; i<=dir->d_entries; i++)
X		fprintf(fp, "%4d- %-20.20s %18.18s  %5d-%c-%d-%d  %c  %-14.14s\n",
X		 i, dir->name[i], dir->number[i], dir->baud[i], dir->parity[i],
X		 dir->data_bits[i], dir->stop_bits[i], dir->duplex[i],
X		 dir->aux[i]);
X
X	if (is_printer)
X		n_pclose(fp);
X	else {
X					/* a dramatic delay... */
X		sleep(1);
X		fclose(fp);
X	}
X
X	werase(p_win);
X	wrefresh(p_win);
X	delwin(p_win);
X	return;
X}
X
X/*
X * Get a string from a window but erase the line first.
X */
X
static char *
e_get_str(win, num)
WINDOW *win;
int num;
X{
X	int count, x, y, done_it;
X	char ans;
X	static char buf[MAX_STRING];
X
X	done_it = 0;
X	count = 0;
X	while ((ans = wgetch(win)) != '\r') {
X					/* do our own backspace */
X		if (ans == BS || ans == DEL) {
X			if (!count) {
X				beep();
X				continue;
X			}
X			count--;
X			buf[count] = '\0';
X			getyx(win, y, x);
X			x--;
X			wmove(win, y, x);
X			waddch(win, (chtype) ' ');
X			wmove(win, y, x);
X			wrefresh(win);
X			continue;
X		}
X					/* exceeded the max? */
X		if (count >= num || count >= MAX_STRING) {
X			beep();
X			continue;
X		}
X					/* illegal character? */
X		if (ans == '\n') {
X			beep();
X			continue;
X		}
X					/* an <ESC> anywhere in the string */
X		if (ans == ESC)
X			return(NULL);
X					/* erase the default answer */
X		if (!done_it) {
X			waddstr(win, "         ");
X			wmove(win, 2, 13);
X			wrefresh(win);
X			done_it++;
X		}
X
X		buf[count] = ans;
X		waddch(win, (chtype) ans);
X		wrefresh(win);
X		count++;
X	}
X	buf[count] = '\0';
X	return(buf);
X}
END_OF_FILE
if test 3986 -ne `wc -c <'d_print.c'`; then
    echo shar: \"'d_print.c'\" unpacked with wrong size!
fi
# end of 'd_print.c'
fi
if test -f 'd_prompt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'d_prompt.c'\"
else
echo shar: Extracting \"'d_prompt.c'\" \(6131 characters\)
sed "s/^X//" >'d_prompt.c' <<'END_OF_FILE'
X/*
X * Prompt for directory entry changes.  Copies the original values in
X * case you change your mind half way thru.  A non-zero return code means
X * the entry was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "dial_dir.h"
X#include "misc.h"
X
int
prompt_lib(win, i)
WINDOW *win;
int i;
X{
X	extern int xmc;
X	extern char *null_ptr;
X	int n, dbits, sbits, spot;
X	unsigned int baud;
X	static unsigned int valid_baud[7] = {300, 1200, 2400, 4800, 9600,
X	19200, 38400};
X	static char *valid_parity[3] = {"Even", "Odd", "None"};
X	char *ans, *get_str(), c, temp, name[40], number[40], aux[40];
X	char parity, duplex, *str_rep(), *strcpy(), buf[40];
X	void free_ptr();
X					/* make copies */
X	strcpy(name, dir->name[i]);
X	strcpy(number, dir->number[i]);
X	baud = dir->baud[i];
X	parity = dir->parity[i];
X	dbits = dir->data_bits[i];
X	sbits = dir->stop_bits[i];
X	duplex = dir->duplex[i];
X	strcpy(aux, dir->aux[i]);
X					/* display original values */
X	werase(win);
X	mvwprintw(win, 2, 5, "%-20.20s %18.18s  %5d-%c-%d-%d  %c  %-14.14s\n",
X	 dir->name[i], dir->number[i], dir->baud[i], dir->parity[i],
X	 dir->data_bits[i], dir->stop_bits[i], dir->duplex[i], dir->aux[i]);
X	box(win, VERT, HORZ);
X
X					/* prompt for name */
X	mvwaddstr(win, 4, 4, "Name: ");
X	wrefresh(win);
X
X	if ((ans = get_str(win, 20, "", ";\n")) == NULL)
X		return(0);
X	if (*ans != '\0') {
X		strcpy(name, ans);
X		mvwaddstr(win, 2, 5, "                    ");
X		wrefresh(win);
X		mvwattrstr(win, 2, 5, A_BOLD, name);
X	}
X					/* prompt for number */
X	clear_line(win, 4, 4, TRUE);
X	waddstr(win, "Number: ");
X	wrefresh(win);
X
X	if ((ans = get_str(win, 18, "", ";\n")) == NULL)
X		return(0);
X	if (*ans != '\0') {
X		strcpy(number, ans);
X		mvwaddstr(win, 2, 26, "                  ");
X		wrefresh(win);
X		/*
X		 * Should be right justified, but we don't wanna have
X		 * the attribute turned on for blanks.
X		 */
X		spot = 26 + 18 - strlen(number);
X		mvwattrstr(win, 2, spot, A_BOLD, number);
X	}
X					/* template for next few */
X	clear_line(win, 4, 4, TRUE);
X	mvwaddstr(win, 4, 31, "(Any key to change, <CR> to accept)");
X
X	/*
X	 * These next few prompts display a series of choices and allow
X	 * the user to hit <CR> to accept the currently showing value
X	 * or any other key to see the next choice.  The first value
X	 * displayed is always the current value.
X	 */
X					/* choose from baud menu */
X	for (n=0; n<7; n++) {
X		if (valid_baud[n] == baud)
X			break;
X	}
X	mvwprintw(win, 4, 4, "Baud: %-5d", valid_baud[n]);
X	wmove(win, 4, 10);
X	wrefresh(win);
X
X	while ((c = wgetch(win)) != '\r') {
X		if (c == ESC)
X			return(0);
X		n = (n == 6) ? 0 : n+1;
X		mvwprintw(win, 4, 4, "Baud: %-5d", valid_baud[n]);
X		wmove(win, 4, 10);
X		wrefresh(win);
X	}
X	if (baud != valid_baud[n]) {
X		baud = valid_baud[n];
X		sprintf(buf, "%5d", baud);
X		if (xmc > 0) {
X			sprintf(buf, "%5d-%c-%d-%d", baud, parity, dbits, sbits);
X			mvwaddstr(win, 2, 46, "           ");
X			wrefresh(win);
X		}
X		mvwattrstr(win, 2, 46, A_BOLD, buf);
X	}
X					/* choose from parity menu */
X	for (n=0; n<3; n++) {
X		if (*valid_parity[n] == parity)
X			break;
X	}
X	mvwprintw(win, 4, 4, "Parity: %-5.5s", valid_parity[n]);
X	wmove(win, 4, 12);
X	wrefresh(win);
X
X	while ((c = wgetch(win)) != '\r') {
X		if (c == ESC)
X			return(0);
X		n = (n == 2) ? 0 : n+1;
X		mvwprintw(win, 4, 4, "Parity: %-5.5s", valid_parity[n]);
X		wmove(win, 4, 12);
X		wrefresh(win);
X	}
X	if (parity != *valid_parity[n]) {
X		parity = *valid_parity[n];
X		if (xmc > 0) {
X			sprintf(buf, "%5d-%c-%d-%d", baud, parity, dbits, sbits);
X			mvwaddstr(win, 2, 46, "           ");
X			wrefresh(win);
X			mvwattrstr(win, 2, 46, A_BOLD, buf);
X		}
X		else
X			mvwattrch(win, 2, 52, A_BOLD, parity);
X	}
X					/* choose from data bits menu */
X	n = dbits;
X	mvwprintw(win, 4, 4, "Data Bits: %d    ", n);
X	wmove(win, 4, 15);
X	wrefresh(win);
X
X	while ((c = wgetch(win)) != '\r') {
X		if (c == ESC)
X			return(0);
X		n = (n == 8) ? 7 : 8;
X		mvwprintw(win, 4, 4, "Data Bits: %d    ", n);
X		wmove(win, 4, 15);
X		wrefresh(win);
X	}
X	if (dbits != n) {
X		dbits = n;
X		if (xmc > 0) {
X			sprintf(buf, "%5d-%c-%d-%d", baud, parity, dbits, sbits);
X			mvwaddstr(win, 2, 46, "           ");
X			wrefresh(win);
X			mvwattrstr(win, 2, 46, A_BOLD, buf);
X		}
X		else
X			mvwattrnum(win, 2, 54, A_BOLD, dbits);
X	}
X					/* choose from stop bits menu */
X	n = sbits;
X	mvwprintw(win, 4, 4, "Stop Bits: %d    ", n);
X	wmove(win, 4, 15);
X	wrefresh(win);
X
X	while ((c = wgetch(win)) != '\r') {
X		if (c == ESC)
X			return(0);
X		n = (n == 2) ? 1 : 2;
X		mvwprintw(win, 4, 4, "Stop Bits: %d    ", n);
X		wmove(win, 4, 15);
X		wrefresh(win);
X	}
X	if (sbits != n) {
X		sbits = n;
X		if (xmc > 0) {
X			sprintf(buf, "%5d-%c-%d-%d", baud, parity, dbits, sbits);
X			mvwaddstr(win, 2, 46, "           ");
X			wrefresh(win);
X			mvwattrstr(win, 2, 46, A_BOLD, buf);
X		}
X		else
X			mvwattrnum(win, 2, 56, A_BOLD, sbits);
X	}
X					/* choose from duplex menu */
X	temp = duplex;
X	mvwprintw(win, 4, 4, "Duplex: %c    ", temp);
X	wmove(win, 4, 12);
X	wrefresh(win);
X
X	while ((c = wgetch(win)) != '\r') {
X		if (c == ESC)
X			return(0);
X		temp = (temp == 'F') ? 'H' : 'F';
X		mvwprintw(win, 4, 4, "Duplex: %c    ", temp);
X		wmove(win, 4, 12);
X		wrefresh(win);
X	}
X	if (duplex != temp) {
X		duplex = temp;
X		mvwattrch(win, 2, 59, A_BOLD, duplex);
X	}
X					/* prompt for script, TTY, or modem */
X	clear_line(win, 4, 4, TRUE);
X	waddstr(win, "Auxiliary file: ");
X	wrefresh(win);
X
X	if ((ans = get_str(win, 17, "", ";\n")) == NULL)
X		return(0);
X
X	if (*ans != '\0') {
X		strcpy(aux, ans);
X		mvwaddstr(win, 2, 62, "              ");
X		wrefresh(win);
X		mvwattrstr(win, 2, 62, A_BOLD, aux);
X	}
X					/* store 'em for real */
X
X	if (!strcmp(name, " ")) {
X		free_ptr(dir->name[i]);
X		dir->name[i] = null_ptr;
X	}
X	else
X		dir->name[i] = str_rep(dir->name[i], name);
X
X	if (!strcmp(number, " ")) {
X		free_ptr(dir->number[i]);
X		dir->number[i] = null_ptr;
X	}
X	else
X		dir->number[i] = str_rep(dir->number[i], number);
X
X	dir->baud[i] = baud;
X	dir->parity[i] = parity;
X	dir->data_bits[i] = dbits;
X	dir->stop_bits[i] = sbits;
X	dir->duplex[i] = duplex;
X
X	if (!strcmp(aux, " ")) {
X		free_ptr(dir->aux[i]);
X		dir->aux[i] = null_ptr;
X	}
X	else
X		dir->aux[i] = str_rep(dir->aux[i], aux);
X
X	return(1);
X}
END_OF_FILE
if test 6131 -ne `wc -c <'d_prompt.c'`; then
    echo shar: \"'d_prompt.c'\" unpacked with wrong size!
fi
# end of 'd_prompt.c'
fi
if test -f 'd_revise.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'d_revise.c'\"
else
echo shar: Extracting \"'d_revise.c'\" \(4002 characters\)
sed "s/^X//" >'d_revise.c' <<'END_OF_FILE'
X/*
X * The revise option of the dialing directory.  A non-zero return code
X * means that something was updated.  Prompts for saving changes to disk.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "dial_dir.h"
X#include "misc.h"
X#include "param.h"
X
static char *ld_prompt();
X
int
revise()
X{
X	WINDOW *r_win, *newwin();
X	int count, dir_flag, param_flag, num, x, y, save;
X	char ans, buf[40], *ld, *str_rep();
X
X	r_win = newwin(7, 77, 7, 2);
X
X	mvwaddstr(r_win, 3, 6, "Entry to revise?");
X	mvwaddstr(r_win, 3, 35, "(Entry Number, +, -, @, #)");
X	box(r_win, VERT, HORZ);
X	wmove(r_win, 3, 23);
X	wrefresh(r_win);
X
X	dir_flag = 0;
X	param_flag = 0;
X	count = 0;
X
X	/*
X	 * Can't use my home-grown get_str() and get_num() functions
X	 * here, because we are prompting for an entry number or a
X	 * long distance code.  This routine echoes numbers only.
X	 */
X	while ((ans = wgetch(r_win)) != ESC) {
X		if (ans >= '0' && ans <= '9') {
X			if (count == 3) {
X				beep();
X				continue;
X			}
X			buf[count] = ans;
X			waddch(r_win, (chtype) ans);
X			wrefresh(r_win);
X			count++;
X			continue;
X		}
X					/* terminating CR */
X		if (ans == '\r') {
X			if (!count) {
X				beep();
X				continue;
X			}
X			buf[count] = '\0';
X			num = atoi(buf);
X					/* valid range of numbers? */
X			if (num == 0 || num > NUM_DIR) {
X				beep();
X				mvwaddstr(r_win, 3, 23, "   ");
X				wmove(r_win, 3, 23);
X				wrefresh(r_win);
X				count = 0;
X				continue;
X			}
X					/* prompt for that entry */
X			if (prompt_lib(r_win, num)) {
X				dir_flag++;
X				break;
X			}
X			delwin(r_win);
X			return(0);
X		}
X					/* do our own backspace */
X		if (ans == BS || ans == DEL) {
X			if (!count) {
X				beep();
X				continue;
X			}
X			count--;
X			buf[count] = '\0';
X			getyx(r_win, y, x);
X			x--;
X			wmove(r_win, y, x);
X			waddch(r_win, (chtype) ' ');
X			wmove(r_win, y, x);
X			wrefresh(r_win);
X			continue;
X		}
X					/* non-number after number is error */
X		if (count) {
X			beep();
X			continue;
X		}
X					/* prompt for LD codes */
X		switch (ans) {
X			case '+':
X				if ((ld = ld_prompt(r_win, param->ld_plus, ans)) != NULL) {
X					param->ld_plus = str_rep(param->ld_plus, ld);
X					param_flag++;
X				}
X				break;
X			case '-':
X				if ((ld = ld_prompt(r_win, param->ld_minus, ans)) != NULL) {
X					param->ld_minus = str_rep(param->ld_minus, ld);
X					param_flag++;
X				}
X				break;
X			case '@':
X				if ((ld = ld_prompt(r_win, param->ld_at, ans)) != NULL) {
X					param->ld_at = str_rep(param->ld_at, ld);
X					param_flag++;
X				}
X				break;
X			case '#':
X				if ((ld = ld_prompt(r_win, param->ld_pound, ans)) != NULL) {
X					param->ld_pound = str_rep(param->ld_pound, ld);
X					param_flag++;
X				}
X				break;
X			default:
X				beep();
X				continue;
X		}
X		break;
X	}
X					/* if nothing changed */
X	if (!param_flag && !dir_flag) {
X		delwin(r_win);
X		return(0);
X	}
X					/* save to disk? */
X	clear_line(r_win, 4, 4, TRUE);
X	if (dir_flag) {
X		sprintf(buf, "Save entry %d to disk", num);
X		save = yes_prompt(r_win, 4, 4, A_BOLD, buf);
X	}
X	else
X		save = yes_prompt(r_win, 4, 4, A_BOLD, "Save to disk");
X
X					/* update the files */
X	if (save && dir_flag) {
X		if (up_dir(num)) {
X			touchwin(r_win);
X			wrefresh(r_win);
X		}
X	}
X	if (save && param_flag) {
X		if (up_param()) {
X			touchwin(r_win);
X			wrefresh(r_win);
X		}
X	}
X	delwin(r_win);
X	return(1);
X}
X
X/*
X * Prompt for long distance code changes.  If new string is a space,
X * change it to null_ptr.  Returns NULL on escape.  Since it uses
X * get_str(), the return value is a pointer to a static area.
X */
X
static char *
ld_prompt(win, current_ld, name)
WINDOW *win;
char *current_ld, name;
X{
X	extern char *null_ptr;
X	char *ans, *get_str();
X
X	werase(win);
X	mvwprintw(win, 2, 4, "%-20.20s", current_ld);
X	mvwprintw(win, 4, 4, "New LD code for %c: ", name);
X	box(win, VERT, HORZ);
X	wrefresh(win);
X
X	if ((ans = get_str(win, 20, "", "\n")) == NULL)
X		return(NULL);
X					/* if space, change to null_ptr */
X	if (!strcmp(ans, " "))
X		ans = null_ptr;
X					/* display new value */
X	clear_line(win, 2, 4, TRUE);
X	wattrstr(win, A_BOLD, ans);
X
X	return(ans);
X}
END_OF_FILE
if test 4002 -ne `wc -c <'d_revise.c'`; then
    echo shar: \"'d_revise.c'\" unpacked with wrong size!
fi
# end of 'd_revise.c'
fi
if test -f 'e_lib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'e_lib.c'\"
else
echo shar: Extracting \"'e_lib.c'\" \(3907 characters\)
sed "s/^X//" >'e_lib.c' <<'END_OF_FILE'
X/*
X * Routines to manipulate the pcomm.extrnl file
X */
X
X#include <stdio.h>
X#include "extrnl.h"
X
X/*
X * Read the external file transfer program database.  Returns a pointer
X * to a static area containing the EXTRNL structure.  This support file is 
X * optional.
X */
X
struct EXTRNL *
read_extrnl()
X{
X	extern char *null_ptr;
X	FILE *fp, *uid_fopen();
X	int i, line, up, entry, oops;
X	char *str_dup(), buf[200], message[80], token[40], *str_tok(), *str;
X	char *sep, *temp_token, *findfile();
X	static struct EXTRNL e;
X	void error_win();
X
X	if ((e.e_path = findfile("pcomm.extrnl")) == NULL) {
X					/* not required to exist */
X		for (i=0; i<3; i++) {
X			e.name[0][i] = null_ptr;
X			e.command[0][i] = null_ptr;
X			e.prompt[0][i] = 'N';
X			e.name[1][i] = null_ptr;
X			e.command[1][i] = null_ptr;
X			e.prompt[1][i] = 'N';
X		}
X		e.up_entries = 0;
X		e.dn_entries = 0;
X
X		return(&e);
X	}
X
X	if (!(fp = uid_fopen(e.e_path, "r"))) {
X		sprintf(buf, "\"%s\" for read", e.e_path);
X		error_win(1, "Can't open external program file", buf);
X	}
X
X	sep = ";;\n";
X	line = 0;
X	up = 1;
X	oops = 0;
X	while (fgets(buf, 200, fp) != NULL) {
X		line++;
X		if (line <= 3)
X			entry = line-1;
X		else {
X			up = 0;
X			entry = line-4;
X		}
X					/* get the token */
X		if (!(temp_token = str_tok(buf, '='))) {
X			sprintf(message, "is missing a token at line %d", line);
X			oops++;
X			break;
X		}
X		/*
X		 * Parse the rest of the line.  This is similar to using
X		 * the "real" strtok() function, but this version returns
X		 * a pointer to NULL if the token is missing.  Note the
X		 * use of the array of separators.
X		 */
X		for (i=0; i<3; i++) {
X			if (!(str = str_tok((char *) NULL, sep[i]))) {
X				sprintf(message, "is missing a parameter at line %d", line);
X				oops++;
X				break;
X			}
X			switch(i) {
X				case 0:
X					e.name[up][entry] = str_dup(str);
X					break;
X				case 1:
X					e.command[up][entry] = str_dup(str);
X					break;
X				case 2:
X					e.prompt[up][entry] = *str;
X					break;
X			}
X		}
X		if (oops)
X			break;
X
X					/* sanity checking */
X		if (up)
X			sprintf(token, "SEND_%d", entry+1);
X		else
X			sprintf(token, "RCV_%d", entry+1);
X
X		if (strcmp(temp_token, token)) {
X			sprintf(message, "is corrupted at line %d", line);
X			oops++;
X			break;
X		}
X	}
X	fclose(fp);
X
X	if (oops) {
X		sprintf(buf, "External program file \"%s\"", e.e_path);
X		error_win(1, buf, message);
X	}
X					/* find number of upload entries */
X	for (i=0; i<3; i++) {
X		if (e.name[1][i] == null_ptr)
X			break;
X	}
X	e.up_entries = i;
X					/* find number of download entries */
X	for (i=0; i<3; i++) {
X		if (e.name[0][i] == null_ptr)
X			break;
X	}
X	e.dn_entries = i;
X					/* if empty database */
X	if (!e.up_entries || !e.dn_entries) {
X		sprintf(buf, "External program file \"%s\"", e.e_path);
X		error_win(0, buf, "has no data");
X	}
X
X	return(&e);
X}
X
X/*
X * Update the external file transfer program database.  A non-zero return
X * code means a non-fatal error.
X */
X
int
up_extrnl()
X{
X	FILE *fp, *uid_fopen();
X	int i, up, entry;
X	char buf[200];
X	void error_win();
X
X	/* 
X	 * I don't remember why I made this file optional.  For the next
X	 * release, it will be mandatory!  The following is kludge to tell
X	 * the user that there is no file to save anything to.
X	 */
X	if (extrnl->e_path == NULL) {
X		error_win(0, "No \"pcomm.extrnl\" file in use", "");
X		return(1);
X	}
X					/* open for write */
X	if (!(fp = uid_fopen(extrnl->e_path, "w"))) {
X		sprintf(buf, "\"%s\"", extrnl->e_path);
X		error_win(0, "No write permission on external program file", buf);
X		return(1);
X	}
X					/* put 'em back */
X	up = 1;
X	for (i=0; i<6; i++) {
X		if (i < 3)
X			entry = i;
X		else {
X			up = 0;
X			entry = i-3;
X		}
X		if (up)
X			fprintf(fp, "SEND_%d=%s;%s;%c\n", entry+1, extrnl->name[up][entry], extrnl->command[up][entry], extrnl->prompt[up][entry]);
X		else
X			fprintf(fp, "RCV_%d=%s;%s;%c\n", entry+1, extrnl->name[up][entry], extrnl->command[up][entry], extrnl->prompt[up][entry]);
X	}
X
X	fclose(fp);
X	return(0);
X}
END_OF_FILE
if test 3907 -ne `wc -c <'e_lib.c'`; then
    echo shar: \"'e_lib.c'\" unpacked with wrong size!
fi
# end of 'e_lib.c'
fi
if test -f 'ls_menu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ls_menu.c'\"
else
echo shar: Extracting \"'ls_menu.c'\" \(4713 characters\)
sed "s/^X//" >'ls_menu.c' <<'END_OF_FILE'
X/*
X * Routines for displaying current line settings and prompting for changes.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "dial_dir.h"
X#include "misc.h"
X#include "param.h"
X
static void disp_settings();
X
X/*
X * Display the current line settings and prompt for changes.  A non-zero
X * return code means settings were changed.
X */
X
int
ls_menu()
X{
X	extern int fd;
X	WINDOW *l_win, *newwin();
X	int num, ret_code;
X
X	l_win = newwin(21, 47, 0, 16);
X
X	mvwattrstr(l_win, 1, 16, A_BOLD, "Line Settings");
X	horizontal(l_win, 2, 0, 47);
X	mvwaddstr(l_win, 6, 5, "1)     300,E,7,1     8)     300,N,8,1");
X	mvwaddstr(l_win, 7, 5, "2)    1200,E,7,1     9)    1200,N,8,1");
X	mvwaddstr(l_win, 8, 5, "3)    2400,E,7,1    10)    2400,N,8,1");
X	mvwaddstr(l_win, 9, 5, "4)    4800,E,7,1    11)    4800,N,8,1");
X	mvwaddstr(l_win, 10, 5, "5)    9600,E,7,1    12)    9600,N,8,1");
X	mvwaddstr(l_win, 11, 5, "6)   19200,E,7,1    13)   19200,N,8,1");
X	mvwaddstr(l_win, 12, 5, "7)   38400,E,7,1    14)   38400,N,8,1");
X	mvwaddstr(l_win, 14, 4, "Parity        Data Bits       Stop Bits");
X	mvwaddstr(l_win, 15, 4, "15) Odd       16) 7 bits      18) 1 bit");
X	mvwaddstr(l_win, 16, 18, "17) 8 bits      19) 2 bits");
X	mvwaddstr(l_win, 18, 4, "20) Save Changes");
X	mvwattrstr(l_win, 18, 28, A_BOLD, "YOUR CHOICE:");
X	wmove(l_win, 18, 41);
X	box(l_win, VERT, HORZ);
X
X	mvwaddstr(l_win, 20, 13, " Press <ESC> to return ");
X					/* display current settings */
X	disp_settings(l_win);
X	wmove(l_win, 18, 41);
X	wrefresh(l_win);
X					/* get the options */
X	ret_code = 0;
X	while ((num = get_num(l_win, 2)) != -1) {
X		switch (num) {
X			case 1:
X				dir->baud[0] = 300;
X				dir->parity[0] = 'E';
X				dir->data_bits[0] = 7;
X				dir->stop_bits[0] = 1;
X				break;
X			case 2:
X				dir->baud[0] = 1200;
X				dir->parity[0] = 'E';
X				dir->data_bits[0] = 7;
X				dir->stop_bits[0] = 1;
X				break;
X			case 3:
X				dir->baud[0] = 2400;
X				dir->parity[0] = 'E';
X				dir->data_bits[0] = 7;
X				dir->stop_bits[0] = 1;
X				break;
X			case 4:
X				dir->baud[0] = 4800;
X				dir->parity[0] = 'E';
X				dir->data_bits[0] = 7;
X				dir->stop_bits[0] = 1;
X				break;
X			case 5:
X				dir->baud[0] = 9600;
X				dir->parity[0] = 'E';
X				dir->data_bits[0] = 7;
X				dir->stop_bits[0] = 1;
X				break;
X			case 6:
X				dir->baud[0] = 19200;
X				dir->parity[0] = 'E';
X				dir->data_bits[0] = 7;
X				dir->stop_bits[0] = 1;
X				break;
X			case 7:
X				dir->baud[0] = 38400;
X				dir->parity[0] = 'E';
X				dir->data_bits[0] = 7;
X				dir->stop_bits[0] = 1;
X				break;
X			case 8:
X				dir->baud[0] = 300;
X				dir->parity[0] = 'N';
X				dir->data_bits[0] = 8;
X				dir->stop_bits[0] = 1;
X				break;
X			case 9:
X				dir->baud[0] = 1200;
X				dir->parity[0] = 'N';
X				dir->data_bits[0] = 8;
X				dir->stop_bits[0] = 1;
X				break;
X			case 10:
X				dir->baud[0] = 2400;
X				dir->parity[0] = 'N';
X				dir->data_bits[0] = 8;
X				dir->stop_bits[0] = 1;
X				break;
X			case 11:
X				dir->baud[0] = 4800;
X				dir->parity[0] = 'N';
X				dir->data_bits[0] = 8;
X				dir->stop_bits[0] = 1;
X				break;
X			case 12:
X				dir->baud[0] = 9600;
X				dir->parity[0] = 'N';
X				dir->data_bits[0] = 8;
X				dir->stop_bits[0] = 1;
X				break;
X			case 13:
X				dir->baud[0] = 19200;
X				dir->parity[0] = 'N';
X				dir->data_bits[0] = 8;
X				dir->stop_bits[0] = 1;
X				break;
X			case 14:
X				dir->baud[0] = 38400;
X				dir->parity[0] = 'N';
X				dir->data_bits[0] = 8;
X				dir->stop_bits[0] = 1;
X				break;
X			case 15:
X				dir->parity[0] = 'O';
X				break;
X			case 16:
X				dir->data_bits[0] = 7;
X				break;
X			case 17:
X				dir->data_bits[0] = 8;
X				break;
X			case 18:
X				dir->stop_bits[0] = 1;
X				break;
X			case 19:
X				dir->stop_bits[0] = 2;
X				break;
X			case 20:
X					/* copy the current settings */
X				param->d_baud = dir->baud[0];
X				param->d_parity = dir->parity[0];
X				param->d_data_bits = dir->data_bits[0];
X				param->d_stop_bits = dir->stop_bits[0];
X				/*
X				 * We've changed the values in memory even
X				 * if the update fails.
X				 */
X				if (up_param()) {
X					touchwin(l_win);
X					wrefresh(l_win);
X				}
X				break;
X			default:
X				beep();
X		}
X		ret_code++;
X		disp_settings(l_win);
X		mvwaddstr(l_win, 17, 41, "    ");
X		wmove(l_win, 18, 41);
X		wrefresh(l_win);
X	}
X	if (fd == -1) {
X		werase(l_win);
X		wrefresh(l_win);
X	}
X	delwin(l_win);
X	return(ret_code);
X}
X
X/*
X * Display the current settings.  Formats the entire string at one
X * time, in case you've got a magic cookie terminal.
X */
X
static void
disp_settings(win)
WINDOW *win;
X{
X	extern int xmc;
X	char buf[40];
X
X	sprintf(buf, "Current Settings: %5d,%c,%d,%d", dir->baud[0],
X	 dir->parity[0], dir->data_bits[0], dir->stop_bits[0]);
X
X	if (xmc > 0) {
X		touchwin(win);
X		clear_line(win, 4, 8, TRUE);
X		wrefresh(win);
X	}
X	mvwattrstr(win, 4, 8, A_BOLD, buf);
X	return;
X}
END_OF_FILE
if test 4713 -ne `wc -c <'ls_menu.c'`; then
    echo shar: \"'ls_menu.c'\" unpacked with wrong size!
fi
# end of 'ls_menu.c'
fi
if test -f 'macro.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'macro.c'\"
else
echo shar: Extracting \"'macro.c'\" \(5244 characters\)
sed "s/^X//" >'macro.c' <<'END_OF_FILE'
X/*
X * The keyboard macro feature.  Displays (and prompts for editing) the
X * macros assigned to the shifted number keys.  Prompts for saving
X * changes to disk.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "misc.h"
X#include "param.h"
X
static char *mac_prompt();
X
void
macro()
X{
X	extern int fd;
X	WINDOW *ma_win, *newwin();
X	int ans, changed;
X	char *mac, *str_rep();
X
X	ma_win = newwin(18, 65, 2, 15);
X	mvwattrstr(ma_win, 1, 25, A_BOLD, "Keyboard Macros");
X	horizontal(ma_win, 2, 0, 65);
X	mvwprintw(ma_win, 4, 0, " %4.4s-!  %-50.50s\n", param->ascii_hot, param->mac_1);
X	wprintw(ma_win, " %4.4s-@  %-50.50s\n", param->ascii_hot, param->mac_2);
X	wprintw(ma_win, " %4.4s-#  %-50.50s\n", param->ascii_hot, param->mac_3);
X	wprintw(ma_win, " %4.4s-$  %-50.50s\n", param->ascii_hot, param->mac_4);
X	wprintw(ma_win, " %4.4s-%%  %-50.50s\n", param->ascii_hot, param->mac_5);
X	wprintw(ma_win, " %4.4s-^  %-50.50s\n", param->ascii_hot, param->mac_6);
X	wprintw(ma_win, " %4.4s-&  %-50.50s\n", param->ascii_hot, param->mac_7);
X	wprintw(ma_win, " %4.4s-*  %-50.50s\n", param->ascii_hot, param->mac_8);
X	wprintw(ma_win, " %4.4s-(  %-50.50s\n", param->ascii_hot, param->mac_9);
X	wprintw(ma_win, " %4.4s-)  %-50.50s\n", param->ascii_hot, param->mac_0);
X	mvwaddstr(ma_win, 15, 5, "Macro key to revise:");
X	box(ma_win, VERT, HORZ);
X					/* on the bottom line */
X	mvwaddstr(ma_win, 17, 21, " Press <ESC> to continue ");
X	wmove(ma_win, 15, 26);
X	wrefresh(ma_win);
X
X	changed = 0;
X
X	while ((ans = wgetch(ma_win)) != ESC) {
X		switch (ans) {
X			case '!':	/* shifted 1 */
X				if ((mac = mac_prompt(ans, param->mac_1)) != NULL) {
X					param->mac_1 = str_rep(param->mac_1, mac);
X					clear_line(ma_win, 4, 9, TRUE);
X					mvwattrstr(ma_win, 4, 9, A_BOLD, mac);
X					changed++;
X				}
X				break;
X			case '@':	/* shifted 2 */
X				if ((mac = mac_prompt(ans, param->mac_2)) != NULL) {
X					param->mac_2 = str_rep(param->mac_2, mac);
X					clear_line(ma_win, 5, 9, TRUE);
X					mvwattrstr(ma_win, 5, 9, A_BOLD, mac);
X					changed++;
X				}
X				break;
X			case '#':	/* shifted 3 */
X				if ((mac = mac_prompt(ans, param->mac_3)) != NULL) {
X					param->mac_3 = str_rep(param->mac_3, mac);
X					clear_line(ma_win, 6, 9, TRUE);
X					mvwattrstr(ma_win, 6, 9, A_BOLD, mac);
X					changed++;
X				}
X				break;
X			case '$':	/* shifted 4 */
X				if ((mac = mac_prompt(ans, param->mac_4)) != NULL) {
X					param->mac_4 = str_rep(param->mac_4, mac);
X					clear_line(ma_win, 7, 9, TRUE);
X					mvwattrstr(ma_win, 7, 9, A_BOLD, mac);
X					changed++;
X				}
X				break;
X			case '%':	/* shifted 5 */
X				if ((mac = mac_prompt(ans, param->mac_5)) != NULL) {
X					param->mac_5 = str_rep(param->mac_5, mac);
X					clear_line(ma_win, 8, 9, TRUE);
X					mvwattrstr(ma_win, 8, 9, A_BOLD, mac);
X					changed++;
X				}
X				break;
X			case '^':	/* shifted 6 */
X				if ((mac = mac_prompt(ans, param->mac_6)) != NULL) {
X					param->mac_6 = str_rep(param->mac_6, mac);
X					clear_line(ma_win, 9, 9, TRUE);
X					mvwattrstr(ma_win, 9, 9, A_BOLD, mac);
X					changed++;
X				}
X				break;
X			case '&':	/* shifted 7 */
X				if ((mac = mac_prompt(ans, param->mac_7)) != NULL) {
X					param->mac_7 = str_rep(param->mac_7, mac);
X					clear_line(ma_win, 10, 9, TRUE);
X					mvwattrstr(ma_win, 10, 9, A_BOLD, mac);
X					changed++;
X				}
X				break;
X			case '*':	/* shifted 8 */
X				if ((mac = mac_prompt(ans, param->mac_8)) != NULL) {
X					param->mac_8 = str_rep(param->mac_8, mac);
X					clear_line(ma_win, 11, 9, TRUE);
X					mvwattrstr(ma_win, 11, 9, A_BOLD, mac);
X					changed++;
X				}
X				break;
X			case '(':	/* shifted 9 */
X				if ((mac = mac_prompt(ans, param->mac_9)) != NULL) {
X					param->mac_9 = str_rep(param->mac_9, mac);
X					clear_line(ma_win, 12, 9, TRUE);
X					mvwattrstr(ma_win, 12, 9, A_BOLD, mac);
X					changed++;
X				}
X				break;
X			case ')':	/* shifted 0 */
X				if ((mac = mac_prompt(ans, param->mac_0)) != NULL) {
X					param->mac_0 = str_rep(param->mac_0, mac);
X					clear_line(ma_win, 13, 9, TRUE);
X					mvwattrstr(ma_win, 13, 9, A_BOLD, mac);
X					changed++;
X				}
X				break;
X			default:
X				beep();
X				break;
X		}
X		touchwin(ma_win);
X		wmove(ma_win, 15, 26);
X		wrefresh(ma_win);
X	}
X					/* if something changed */
X	if (changed) {
X					/* save to disk? */
X		if (yes_prompt(ma_win, 15, 30, A_BOLD, "Save to disk")) {
X			if (up_param()) {
X				touchwin(ma_win);
X				wrefresh(ma_win);
X			}
X		}
X	}
X	if (fd == -1) {
X		werase(ma_win);
X		wrefresh(ma_win);
X	}
X	delwin(ma_win);
X	return;
X}
X
X/*
X * Sounds like McDonalds doesn't it?  Actually, it opens a new window
X * and prompts for the new macro.  Returns a pointer to the new string.
X * Since it uses get_str(), the return value points to a static area.
X */
X
static char *
mac_prompt(key, string)
char key, *string;
X{
X	extern char *null_ptr;
X	WINDOW *mp_win, *newwin();
X	char *new, *get_str();
X
X	mp_win = newwin(6, 65, 8, 0);
X	mvwprintw(mp_win, 2, 3, "%4.4s-%c  %-50.50s", param->ascii_hot, key, string);
X	mvwaddstr(mp_win, 3, 5, "New : ");
X	box(mp_win, VERT, HORZ);
X	wrefresh(mp_win);
X
X	if ((new = get_str(mp_win, 50, "", "\n")) != NULL) {
X					/* if CR, return NULL */
X		if (*new == '\0')
X			new = NULL;
X					/* if space, change to null_ptr */
X		else if (!strcmp(new, " "))
X			new = null_ptr;
X	}
X
X	werase(mp_win);
X	wrefresh(mp_win);
X	delwin(mp_win);
X	return(new);
X}
END_OF_FILE
if test 5244 -ne `wc -c <'macro.c'`; then
    echo shar: \"'macro.c'\" unpacked with wrong size!
fi
# end of 'macro.c'
fi
if test -f 's_axfer.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'s_axfer.c'\"
else
echo shar: Extracting \"'s_axfer.c'\" \(3830 characters\)
sed "s/^X//" >'s_axfer.c' <<'END_OF_FILE'
X/*
X * Display the ASCII transfer setup, query for changes.  A non-zero return
X * code means something was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "misc.h"
X#include "param.h"
X
int
axfer_setup()
X{
X	extern char *v_yes[];
X	WINDOW *x_win, *newwin();
X	int i, ret_code, num;
X	char *ans, *menu_prompt(), *str_rep();
X	static char *v_cr[4] = {"NONE", "STRIP", "ADD LF", NULL};
X	static char *v_lf[4] = {"NONE", "STRIP", "ADD CR", NULL};
X	static char *v_delay[4] = {"0", "100", "150", NULL};
X
X	x_win = newwin(23, 80, 0, 0);
X
X	horizontal(x_win, 0, 0, 28);
X	mvwattrstr(x_win, 0, 29, A_BOLD, "ASCII Transfer Setup");
X	horizontal(x_win, 0, 50, 29);
X	mvwaddstr(x_win, 3, 33, "ASCII UPLOAD");
X	mvwprintw(x_win, 5, 22, "1) Echo locally ........... %s", param->local_echo);
X	mvwprintw(x_win, 6, 22, "2) Expand blank lines ..... %s", param->expand);
X	mvwprintw(x_win, 7, 22, "3) CR delay (ms) .......... %d", param->cr_delay);
X	mvwprintw(x_win, 8, 22, "4) Pace the output ........ %s", param->pace);
X	mvwprintw(x_win, 9, 22, "5) CR translation ......... %s", param->cr_up);
X	mvwprintw(x_win, 10, 22, "6) LF translation ......... %s", param->lf_up);
X	mvwaddstr(x_win, 12, 32, "ASCII DOWNLOAD");
X	mvwprintw(x_win, 14, 22, "7) Transfer timeout (sec) . %d", param->timer);
X	mvwprintw(x_win, 15, 22, "8) CR translation ......... %s", param->cr_dn);
X	mvwprintw(x_win, 16, 22, "9) LF translation ......... %s", param->lf_dn);
X	horizontal(x_win, 19, 0, 80);
X	mvwattrstr(x_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(x_win, 20, 58, "Press <ESC> to return");
X	wmove(x_win, 20, 12);
X	touchwin(x_win);
X	wrefresh(x_win);
X					/* get the option number */
X	ret_code = 0;
X	while ((i = get_num(x_win, 1)) != -1) {
X		switch (i) {
X			case 1:
X				if ((ans = menu_prompt(x_win, 5, 50, "Echo locally", v_yes)) != NULL) {
X					param->local_echo = str_rep(param->local_echo, ans);
X					ret_code++;
X				}
X				break;
X			case 2:
X				if ((ans = menu_prompt(x_win, 6, 50, "Expand blank lines", v_yes)) != NULL) {
X					param->expand = str_rep(param->expand, ans);
X					ret_code++;
X				}
X				break;
X			case 3:
X				if ((ans = menu_prompt(x_win, 7, 50, "CR delay (ms)", v_delay)) != NULL) {
X					param->cr_delay = atoi(ans);
X					ret_code++;
X				}
X				break;
X			case 4:
X				if ((ans = menu_prompt(x_win, 8, 50, "Pace the output", v_yes)) != NULL) {
X					param->pace = str_rep(param->pace, ans);
X					ret_code++;
X				}
X				break;
X			case 5:
X				if ((ans = menu_prompt(x_win, 9, 50, "CR translation (upload)", v_cr)) != NULL) {
X					param->cr_up = str_rep(param->cr_up, ans);
X					ret_code++;
X				}
X				break;
X			case 6:
X				if ((ans = menu_prompt(x_win, 10, 50, "LF translation (upload)", v_lf)) != NULL) {
X					param->lf_up = str_rep(param->lf_up, ans);
X					ret_code++;
X				}
X				break;
X			case 7:
X				if ((num = num_prompt(x_win, 14, 50, "Transfer timeout", "(in seconds)")) != -1) {
X					if (num > MAX_TIMER || num < MIN_TIMER) {
X						beep();
X					/* some reasonable range of values */
X						if (num < MIN_TIMER)
X							num = MIN_TIMER;
X						else
X							num = MAX_TIMER;
X						mvwaddstr(x_win, 14, 50, "   ");
X						wrefresh(x_win);
X						mvwattrnum(x_win, 14, 50, A_BOLD, num);
X						wrefresh(x_win);
X					}
X					param->timer = num;
X					ret_code++;
X				}
X				break;
X			case 8:
X				if ((ans = menu_prompt(x_win, 15, 50, "CR translation (download)", v_cr)) != NULL) {
X					param->cr_dn = str_rep(param->cr_dn, ans);
X					ret_code++;
X				}
X				break;
X			case 9:
X				if ((ans = menu_prompt(x_win, 16, 50, "LF translation (download)", v_lf)) != NULL) {
X					param->lf_dn = str_rep(param->lf_dn, ans);
X					ret_code++;
X				}
X				break;
X			default:
X				beep();
X		}
X		mvwaddch(x_win, 20, 12, (chtype) ' ');
X		clear_line(x_win, 21, 0, FALSE);
X		clear_line(x_win, 22, 0, FALSE);
X		wmove(x_win, 20, 12);
X		wrefresh(x_win);
X	}
X	delwin(x_win);
X	return(ret_code);
X}
END_OF_FILE
if test 3830 -ne `wc -c <'s_axfer.c'`; then
    echo shar: \"'s_axfer.c'\" unpacked with wrong size!
fi
# end of 's_axfer.c'
fi
if test -f 's_extrnl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'s_extrnl.c'\"
else
echo shar: Extracting \"'s_extrnl.c'\" \(4098 characters\)
sed "s/^X//" >'s_extrnl.c' <<'END_OF_FILE'
X/*
X * Display the external protocol setup, query for changes.  A non-zero
X * return code means something was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "extrnl.h"
X#include "misc.h"
X
static int ext_prompt();
static void disp_ext();
X
int
ext_setup()
X{
X	extern char *null_ptr;
X	WINDOW *ext_win, *newwin();
X	int i, ret_code;
X	char *str, *get_str();
X
X	ext_win = newwin(23, 80, 0, 0);
X
X	horizontal(ext_win, 0, 0, 27);
X	mvwattrstr(ext_win, 0, 28, A_BOLD, "External Protocol Setup");
X	horizontal(ext_win, 0, 52, 27);
X	mvwaddstr(ext_win, 3, 36, "UPLOAD");
X	mvwaddstr(ext_win, 5, 8, "Name");
X	mvwaddstr(ext_win, 5, 21, "Command line");
X	mvwaddstr(ext_win, 5, 54, "Requires file list?");
X	mvwaddstr(ext_win, 10, 35, "DOWNLOAD");
X	mvwaddstr(ext_win, 12, 8, "Name");
X	mvwaddstr(ext_win, 12, 21, "Command line");
X	mvwaddstr(ext_win, 12, 54, "Requires file list?");
X					/* display the current list */
X	disp_ext(ext_win);
X
X	horizontal(ext_win, 19, 0, 80);
X	mvwattrstr(ext_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(ext_win, 20, 58, "Press <ESC> to return");
X	wmove(ext_win, 20, 12);
X	touchwin(ext_win);
X	wrefresh(ext_win);
X					/* get the option */
X	ret_code = 0;
X	while ((str = get_str(ext_win, 1, "1234356", "")) != NULL) {
X		switch(*str) {
X			case '1':
X				if (ext_prompt(ext_win, 1, 0, 6))
X					ret_code++;
X				break;
X			case '2':
X				if (ext_prompt(ext_win, 1, 1, 7))
X					ret_code++;
X				break;
X			case '3':
X				if (ext_prompt(ext_win, 1, 2, 8))
X					ret_code++;
X				break;
X			case '4':
X				if (ext_prompt(ext_win, 0, 0, 13))
X					ret_code++;
X				break;
X			case '5':
X				if (ext_prompt(ext_win, 0, 1, 14))
X					ret_code++;
X				break;
X			case '6':
X				if (ext_prompt(ext_win, 0, 2, 15))
X					ret_code++;
X				break;
X		}
X		mvwaddstr(ext_win, 20, 12, "  ");
X		clear_line(ext_win, 21, 0, FALSE);
X		clear_line(ext_win, 22, 0, FALSE);
X		wmove(ext_win, 20, 12);
X		wrefresh(ext_win);
X	}
X	/*
X	 * Recalculate the number of entries.  Please notice that if you
X	 * create an empty entry (a hole), all entries after that are ignored.  
X	 * The software doesn't compact the holes out.. you're on your own.
X	 */
X	if (ret_code) {
X		for (i=0; i<3; i++) {
X			if (extrnl->name[1][i] == null_ptr)
X				break;
X		}
X		extrnl->up_entries = i;
X
X		for (i=0; i<3; i++) {
X			if (extrnl->name[0][i] == null_ptr)
X				break;
X		}
X		extrnl->dn_entries = i;
X	}
X	delwin(ext_win);
X	return(ret_code);
X}
X
X/*
X * Display the current list of external file transfer programs.
X */
X
static void
disp_ext(win)
WINDOW *win;
X{
X	int i, up, entry, line;
X
X	up = 1;
X	line = 6;
X	for (i=0; i<6; i++) {
X		if (i < 3)
X			entry = i;
X		else {
X			up = 0;
X			entry = i-3;
X			line = 10;
X		}
X		mvwprintw(win, i+line, 5, "%d) %-12.12s %-40.40s  %c\n",
X		 i+1, extrnl->name[up][entry], extrnl->command[up][entry],
X		 extrnl->prompt[up][entry]);
X	}
X	return;
X}
X
X/*
X * Prompt for the info in the database.  A non-zero return code means
X * that something was changed.  To delete the line, you enter a single
X * space character at the first prompt.
X */
X
static int
ext_prompt(win, up, entry, line)
WINDOW *win;
int up, entry, line;
X{
X	extern char *v_yn[], *null_ptr;
X	char *ans, t_name[80], t_command[80], *str_prompt(), *str_rep();
X	char *strcpy(), *menu_prompt();
X
X					/* get temp name */
X	if ((ans = str_prompt(win, line, 8, "Protocol name", "")) == NULL)
X		return(0);
X
X	strcpy(t_name, ans);
X	clear_line(win, 21, 0, FALSE);
X					/* are we zapping the line */
X	if (ans == null_ptr) {
X		extrnl->name[up][entry] = null_ptr;
X		extrnl->command[up][entry] = null_ptr;
X		extrnl->prompt[up][entry] = 'N';
X		return(1);
X	}
X					/* get temp command */
X	if ((ans = str_prompt(win, line, 21, "Command line", "")) == NULL)
X		return(0);
X
X	strcpy(t_command, ans);
X	clear_line(win, 21, 0, FALSE);
X
X					/* get temp prompt */
X	if ((ans = menu_prompt(win, line, 63, "Does it require a file list", v_yn)) == NULL)
X		return(0);
X
X	wrefresh(win);
X					/* store 'em for real */
X	extrnl->name[up][entry] = str_rep(extrnl->name[up][entry], t_name);
X	extrnl->command[up][entry] = str_rep(extrnl->command[up][entry], t_command);
X	extrnl->prompt[up][entry] = *ans;
X
X	return(1);
X}
END_OF_FILE
if test 4098 -ne `wc -c <'s_extrnl.c'`; then
    echo shar: \"'s_extrnl.c'\" unpacked with wrong size!
fi
# end of 's_extrnl.c'
fi
if test -f 's_gen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'s_gen.c'\"
else
echo shar: Extracting \"'s_gen.c'\" \(4393 characters\)
sed "s/^X//" >'s_gen.c' <<'END_OF_FILE'
X/*
X * Display the general setup, query for changes.  A non-zero return code
X * means something was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "misc.h"
X#include "param.h"
X
int
gen_setup()
X{
X	extern char *v_yes[];
X	WINDOW *g_win, *newwin();
X	int i, num, ret_code;
X	char c, *ans, *str_prompt(), *menu_prompt(), chr_prompt();
X	char *str_rep();
X	void line_set();
X	static char *v_abort[3] = {"KEEP", "DELETE", NULL};
X
X	g_win = newwin(23, 80, 0, 0);
X
X	horizontal(g_win, 0, 0, 32);
X	mvwattrstr(g_win, 0, 33, A_BOLD, "General Setup");
X	horizontal(g_win, 0, 47, 32);
X	mvwprintw(g_win, 3, 22, "1) Default log file ....... %s", param->logfile);
X	mvwprintw(g_win, 4, 22, "2) Screen dump file ....... %s", param->dumpfile);
X	mvwprintw(g_win, 6, 22, "3) Strip high bit  ........ %s", param->strip);
X	mvwprintw(g_win, 8, 22, "4) Pause character ........ %c", param->pause_char);
X	mvwprintw(g_win, 9, 22, "5) CR character ........... %c", param->cr_char);
X	mvwprintw(g_win, 10, 22, "6) CTRL character ......... %c", param->ctrl_char);
X	mvwprintw(g_win, 11, 22, "7) ESC character .......... %c", param->esc_char);
X	mvwprintw(g_win, 12, 22, "8) Break character ........ %c", param->brk_char);
X	mvwprintw(g_win, 14, 22, "9) Aborted downloads ...... %s", param->abort);
X	mvwprintw(g_win, 16, 21, "10) Connect delay (sec) .... %d", param->c_delay);
X	mvwprintw(g_win, 17, 21, "11) Redial delay (sec) ..... %d", param->r_delay);
X	horizontal(g_win, 19, 0, 80);
X	mvwattrstr(g_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(g_win, 20, 58, "Press <ESC> to return");
X	wmove(g_win, 20, 12);
X	touchwin(g_win);
X	wrefresh(g_win);
X					/* get the option number */
X	ret_code = 0;
X	while ((i = get_num(g_win, 2)) != -1) {
X		switch (i) {
X			case 1:
X				if ((ans = str_prompt(g_win, 3, 50, "Default log file", "")) != NULL) {
X					param->logfile = str_rep(param->logfile, ans);
X					ret_code++;
X				}
X				break;
X			case 2:
X				if ((ans = str_prompt(g_win, 4, 50, "Default screen dump file", "")) != NULL) {
X					param->dumpfile = str_rep(param->dumpfile, ans);
X					ret_code++;
X				}
X				break;
X			case 3:
X				if ((ans = menu_prompt(g_win, 6, 50, "Strip high bit?", v_yes)) != NULL) {
X					param->strip = str_rep(param->strip, ans);
X					line_set();
X					ret_code++;
X				}
X				break;
X			case 4:
X				if ((c = chr_prompt(g_win, 8, 50, "Pause character", "1 second")) != '\0') {
X					param->pause_char = c;
X					ret_code++;
X				}
X				break;
X			case 5:
X				if ((c = chr_prompt(g_win, 9, 50, "CR character", "(carriage return)")) != '\0') {
X					param->cr_char = c;
X					ret_code++;
X				}
X				break;
X			case 6:
X				if ((c = chr_prompt(g_win, 10, 50, "CTRL character", "(control)")) != '\0') {
X					param->ctrl_char = c;
X					ret_code++;
X				}
X				break;
X			case 7:
X				if ((c = chr_prompt(g_win, 11, 50, "ESC character", "(escape)")) != '\0') {
X					param->esc_char = c;
X					ret_code++;
X				}
X				break;
X			case 8:
X				if ((c = chr_prompt(g_win, 12, 50, "Break character", "")) != '\0') {
X					param->brk_char = c;
X					ret_code++;
X				}
X				break;
X			case 9:
X				if ((ans = menu_prompt(g_win, 14, 50, "Aborted downloads", v_abort)) != NULL) {
X					param->abort = str_rep(param->abort, ans);
X					ret_code++;
X				}
X				break;
X			case 10:
X				if ((num = num_prompt(g_win, 16, 50, "Connect delay time", "(in seconds)")) != -1) {
X					if (num > MAX_CDELAY || num < MIN_CDELAY) {
X						beep();
X					/* some reasonable range of values */
X						if (num < MIN_CDELAY)
X							num = MIN_CDELAY;
X						else
X							num = MAX_CDELAY;
X						mvwaddstr(g_win, 16, 50, "   ");
X						wrefresh(g_win);
X						mvwattrnum(g_win, 16, 50, A_BOLD, num);
X						wrefresh(g_win);
X					}
X					param->c_delay = num;
X					ret_code++;
X				}
X				break;
X			case 11:
X				if ((num = num_prompt(g_win, 17, 50, "Redial delay time", "(in seconds)")) != -1) {
X					if (num > MAX_PAUSE || num < MIN_PAUSE) {
X						beep();
X					/* some reasonable range */
X						if (num < MIN_PAUSE)
X							num = MIN_PAUSE;
X						else
X							num = MAX_PAUSE;
X						mvwaddstr(g_win, 17, 50, "    ");
X						wrefresh(g_win);
X						mvwattrnum(g_win, 17, 50, A_BOLD, num);
X						wrefresh(g_win);
X					}
X					param->r_delay = num;
X					ret_code++;
X				}
X				break;
X			default:
X				beep();
X		}
X		mvwaddstr(g_win, 20, 12, "  ");
X		clear_line(g_win, 21, 0, FALSE);
X		clear_line(g_win, 22, 0, FALSE);
X		wmove(g_win, 20, 12);
X		wrefresh(g_win);
X	}
X	delwin(g_win);
X	return(ret_code);
X}
END_OF_FILE
if test 4393 -ne `wc -c <'s_gen.c'`; then
    echo shar: \"'s_gen.c'\" unpacked with wrong size!
fi
# end of 's_gen.c'
fi
if test -f 's_menu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'s_menu.c'\"
else
echo shar: Extracting \"'s_menu.c'\" \(2972 characters\)
sed "s/^X//" >'s_menu.c' <<'END_OF_FILE'
X/*
X * Display the setup menu, prompts for a bunch of other menus. 
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "misc.h"
X
static void top_line();
X
void
setup_menu()
X{
X	extern int fd, xmc;
X	WINDOW *s_win, *newwin();
X	char *ans, *get_str();
X	static int param_flag = 0, modem_flag = 0, ext_flag = 0;
X
X	s_win = newwin(LINES-1, COLS, 0, 0);
X
X	top_line(s_win);
X	mvwaddstr(s_win, 3, 29, "1) TTY Setup");
X	mvwaddstr(s_win, 5, 29, "2) Modem Setup");
X	mvwaddstr(s_win, 7, 29, "3) Terminal Setup");
X	mvwaddstr(s_win, 9, 29, "4) General Setup");
X	mvwaddstr(s_win, 11, 29, "5) ASCII Transfer Setup");
X	mvwaddstr(s_win, 13, 29, "6) External Protocol Setup");
X	mvwaddstr(s_win, 15, 29, "S) Save setup to disk");
X	horizontal(s_win, 19, 0, 80);
X	mvwattrstr(s_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(s_win, 20, 58, "  Press <ESC> to exit");
X	wmove(s_win, 20, 12);
X	touchwin(s_win);
X	wrefresh(s_win);
X
X					/* get the options */
X	while ((ans = get_str(s_win, 1, "123456Ss", "")) != NULL) {
X		if (xmc > 0) {
X			clear_line(s_win, 0, 0, FALSE);
X			wrefresh(s_win);
X		}
X		switch (*ans) {
X			case '1':
X				if (tty_setup())
X					modem_flag++;
X				break;
X			case '2':
X				if (modem_setup())
X					modem_flag++;
X				break;
X			case '3':
X				if (term_setup())
X					param_flag++;
X				break;
X			case '4':
X				if (gen_setup())
X					param_flag++;
X				break;
X			case '5':
X				if (axfer_setup())
X					param_flag++;
X				break;
X			case '6':
X				if (ext_setup())
X					ext_flag++;
X				break;
X			case 's':
X			case 'S':
X				if (xmc > 0)
X					top_line(s_win);
X				/*
X				 * Writes to disk are not critical, since
X				 * the changes are made in memory.
X				 */
X				if (param_flag) {
X					mvwattrstr(s_win, 22, 27, A_BLINK, "Updating Parameter File");
X					wrefresh(s_win);
X					wait_key(s_win, 3);
X					if (up_param()) {
X						touchwin(s_win);
X						wrefresh(s_win);
X					}
X					else
X						param_flag = 0;
X				}
X				if (modem_flag) {
X					mvwattrstr(s_win, 22, 27, A_BLINK, "Updating Modem Database");
X					wrefresh(s_win);
X					wait_key(s_win, 3);
X					if (up_modem()) {
X						touchwin(s_win);
X						wrefresh(s_win);
X					}
X					else
X						modem_flag = 0;
X				}
X				if (ext_flag) {
X					mvwattrstr(s_win, 22, 25, A_BLINK, "Updating External Protocols");
X					wrefresh(s_win);
X					wait_key(s_win, 3);
X					if (up_extrnl()) {
X						touchwin(s_win);
X						wrefresh(s_win);
X					}
X					else
X						ext_flag = 0;
X				}
X				clear_line(s_win, 22, 25, FALSE);
X				wrefresh(s_win);
X				break;
X			default:
X				beep();
X		}
X		touchwin(s_win);
X		if (xmc > 0)
X			top_line(s_win);
X
X		mvwaddch(s_win, 20, 12, (chtype) ' ');
X		wmove(s_win, 20, 12);
X		wrefresh(s_win);
X	}
X	if (fd == -1) {
X		werase(s_win);
X		wrefresh(s_win);
X	}
X	delwin(s_win);
X	return;
X}
X
X/*
X * Put the top line on the window.
X */
X
static void
top_line(win)
WINDOW *win;
X{
X	clear_line(win, 0, 0, FALSE);
X	wrefresh(win);
X	horizontal(win, 0, 0, 33);
X	mvwattrstr(win, 0, 34, A_BOLD, "Setup Menu");
X	horizontal(win, 0, 45, 34);
X	wrefresh(win);
X	return;
X}
END_OF_FILE
if test 2972 -ne `wc -c <'s_menu.c'`; then
    echo shar: \"'s_menu.c'\" unpacked with wrong size!
fi
# end of 's_menu.c'
fi
if test -f 's_prompt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'s_prompt.c'\"
else
echo shar: Extracting \"'s_prompt.c'\" \(3077 characters\)
sed "s/^X//" >'s_prompt.c' <<'END_OF_FILE'
X/*
X * Prompting routines used in the setup menus.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "misc.h"
X
X/*
X * Prompt for a string at line 21 (with optional line 22 for additional
X * information).  Display the new string in bold at its original location
X * in the menu.  Used in virtually all of the *_setup() routines.  Since
X * it uses get_str(), the return value points to a static area.
X */
X
char *
str_prompt(win, y, x, p1, p2)
WINDOW *win;
int y, x;
char *p1, *p2;
X{
X	extern char *null_ptr;
X	char *ans, *get_str();
X					/* print first prompt last */
X	mvwaddstr(win, 22, 0, p2);
X	mvwaddstr(win, 21, 0, p1);
X	waddstr(win, ": ");
X	wrefresh(win);
X
X	if ((ans = get_str(win, 80, "", ";\n")) == NULL)
X		return(NULL);
X					/* check the value */
X	if (!strcmp(ans, " "))
X		ans = null_ptr;
X					/* display the value in bold */
X	clear_line(win, y, x, FALSE);
X	wattrstr(win, A_BOLD, ans);
X
X	return(ans);
X}
X
X/*
X * Same as above, except we return a single character.
X */
X
char
chr_prompt(win, y, x, p1, p2)
WINDOW *win;
int y, x;
char *p1, *p2;
X{
X	char *ans, *get_str();
X					/* print first prompt last */
X	mvwaddstr(win, 22, 0, p2);
X	mvwaddstr(win, 21, 0, p1);
X	waddstr(win, ": ");
X	wrefresh(win);
X
X	if ((ans = get_str(win, 1, "", "\n")) == NULL)
X		return('\0');
X					/* display the value in bold */
X	mvwaddstr(win, y, x, "  ");
X	wrefresh(win);
X	mvwattrstr(win, y, x, A_BOLD, ans);
X
X	return((char) *ans);
X}
X
X/*
X * Same as above, except that it prompts for a three digit number.
X */
X
int
num_prompt(win, y, x, p1, p2)
WINDOW *win;
int y, x;
char *p1, *p2;
X{
X	int i;
X					/* print first prompt last */
X	mvwaddstr(win, 22, 0, p2);
X	mvwaddstr(win, 21, 0, p1);
X	waddstr(win, ": ");
X	wrefresh(win);
X
X	if ((i = get_num(win, 3)) == -1)
X		return(-1);
X					/* display the value in bold */
X	mvwaddstr(win, y, x, "    ");
X	wrefresh(win);
X	mvwattrnum(win, y, x, A_BOLD, i);
X					/* return the number */
X	return(i);
X}
X
X/*
X * Prompts for a selection from a menu.  We display the prompt lines,
X * and show the choices one at a time.  The user selects the currently
X * showing choice by hitting a carriage return.  Unlike the similar
X * routines in d_prompt(), the first choice shown is not necessarily
X * the current.
X */
X
char *v_yes[3] = {"YES", "NO", NULL};
char *v_yn[3] = {"Y", "N", NULL};
X
char *
menu_prompt(win, y, x, p, menu)
WINDOW *win;
int y, x;
char *p, *menu[];
X{
X	char ans;
X	int i, cy, cx;
X					/* print first prompt last */
X	mvwaddstr(win, 22, 0, "Press any key to change, or <CR> to accept");
X	mvwaddstr(win, 21, 0, p);
X	waddstr(win, ": ");
X					/* show first choice */
X	i = 0;
X	getyx(win, cy, cx);
X	mvwprintw(win, cy, cx, "%-30.30s", menu[i]);
X	wmove(win, cy, cx);
X	wrefresh(win);
X					/* show the choices one at a time */
X	while ((ans = wgetch(win)) != '\r') {
X		i++;
X		if (menu[i] == NULL)
X			i = 0;
X		if (ans == ESC)
X			return(NULL);
X		mvwprintw(win, cy, cx, "%-30.30s", menu[i]);
X		wmove(win, cy, cx);
X		wrefresh(win);
X	}
X					/* display the value in bold */
X	clear_line(win, y, x, FALSE);
X	wattrstr(win, A_BOLD, menu[i]);
X					/* return the value */
X	return(menu[i]);
X}
END_OF_FILE
if test 3077 -ne `wc -c <'s_prompt.c'`; then
    echo shar: \"'s_prompt.c'\" unpacked with wrong size!
fi
# end of 's_prompt.c'
fi
if test -f 's_term.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'s_term.c'\"
else
echo shar: Extracting \"'s_term.c'\" \(2909 characters\)
sed "s/^X//" >'s_term.c' <<'END_OF_FILE'
X/*
X * Display the terminal setup, query for changes.  A non-zero return
X * means something was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "dial_dir.h"
X#include "misc.h"
X#include "param.h"
X
int
term_setup()
X{
X	WINDOW *t_win, *newwin();
X	int i, num, ret_code;
X	char *ans, *str_rep(), *str_prompt(), *menu_prompt();
X	void line_set();
X	static char *v_crio[3] = {"CR", "CR/LF", NULL};
X	static char *v_duplex[3] = {"FULL", "HALF", NULL};
X	static char *v_flow[3] = {"NONE", "XON/XOFF", NULL};
X
X	t_win = newwin(23, 80, 0, 0);
X
X	horizontal(t_win, 0, 0, 32);
X	mvwattrstr(t_win, 0, 33, A_BOLD, "Terminal Setup");
X	horizontal(t_win, 0, 48, 32);
X	mvwprintw(t_win, 4, 22, "1) Hot key (decimal) ...... %d", param->hot_key);
X	mvwprintw(t_win, 6, 22, "2) ASCII version of hot ... %s", param->ascii_hot);
X	mvwprintw(t_win, 9, 22, "3) Duplex ................. %s", param->d_duplex);
X	mvwprintw(t_win, 11, 22, "4) Flow control ........... %s", param->flow_ctrl);
X	mvwprintw(t_win, 13, 22, "5) CR translation (in) .... %s", param->cr_in);
X	mvwprintw(t_win, 15, 22, "6) CR translation (out) ... %s", param->cr_out);
X	horizontal(t_win, 19, 0, 80);
X	mvwattrstr(t_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(t_win, 20, 58, "Press <ESC> to return");
X	wmove(t_win, 20, 12);
X	touchwin(t_win);
X	wrefresh(t_win);
X					/* get the option number */
X	ret_code = 0;
X	while ((i = get_num(t_win, 1)) != -1) {
X		switch (i) {
X			case 1:
X				if ((num = num_prompt(t_win, 4, 50, "Hot key", "decimal code for the hot key")) != -1) {
X					param->hot_key = num;
X					ret_code++;
X				}
X				break;
X			case 2:
X				again:
X				ans = str_prompt(t_win, 6, 50, "ASCII version of hot key", "(printable version, max of 4 characters)");
X				if (ans != NULL) {
X					if (strlen(ans) > 4) {
X						beep();
X						clear_line(t_win, 21, 0, 0);
X						goto again;
X					}
X					param->ascii_hot = str_rep(param->ascii_hot, ans);
X					ret_code++;
X				}
X				break;
X			case 3:
X				if ((ans = menu_prompt(t_win, 9, 50, "Duplex", v_duplex)) != NULL) {
X					param->d_duplex = str_rep(param->d_duplex, ans);
X					dir->duplex[0] = *param->d_duplex;
X					ret_code++;
X				}
X				break;
X			case 4:
X				if ((ans = menu_prompt(t_win, 11, 50, "Flow control", v_flow)) != NULL) {
X					param->flow_ctrl = str_rep(param->flow_ctrl, ans);
X					line_set();
X					ret_code++;
X				}
X				break;
X			case 5:
X				if ((ans = menu_prompt(t_win, 13, 50, "CR translation (in)", v_crio)) != NULL) {
X
X					param->cr_in = str_rep(param->cr_in, ans);
X					ret_code++;
X				}
X				break;
X			case 6:
X				if ((ans = menu_prompt(t_win, 15, 50, "CR translation (out)", v_crio)) != NULL) {
X					param->cr_out = str_rep(param->cr_out, ans);
X					ret_code++;
X				}
X				break;
X			default:
X				beep();
X		}
X		mvwaddch(t_win, 20, 12, (chtype) ' ');
X		clear_line(t_win, 21, 0, FALSE);
X		clear_line(t_win, 22, 0, FALSE);
X		wmove(t_win, 20, 12);
X		wrefresh(t_win);
X	}
X	delwin(t_win);
X	return(ret_code);
X}
END_OF_FILE
if test 2909 -ne `wc -c <'s_term.c'`; then
    echo shar: \"'s_term.c'\" unpacked with wrong size!
fi
# end of 's_term.c'
fi
if test -f 's_tty.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'s_tty.c'\"
else
echo shar: Extracting \"'s_tty.c'\" \(4931 characters\)
sed "s/^X//" >'s_tty.c' <<'END_OF_FILE'
X/*
X * Display the TTY setup, query for changes.  A non-zero return code
X * means something was changed.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include "misc.h"
X#include "modem.h"
X
static int tty_prompt();
static void disp_tty(), del_tty();
X
int
tty_setup()
X{
X	WINDOW *tt_win, *newwin();
X	char message[80], *str, *get_str();
X	int num, i, j, ret_code;
X	void create_modem(), del_modem(), error_win();
X
X	tt_win = newwin(23, 80, 0, 0);
X
X	horizontal(tt_win, 0, 0, 34);
X	mvwattrstr(tt_win, 0, 35, A_BOLD, "TTY Setup");
X	horizontal(tt_win, 0, 45, 34);
X	mvwaddstr(tt_win, 2, 22, "TTY name");
X	mvwaddstr(tt_win, 2, 37, "Modem name");
X	mvwaddstr(tt_win, 2, 50, "Locked speed");
X					/* display the current TTY list */
X	disp_tty(tt_win);
X					/* prompt for options */
X	mvwaddstr(tt_win, 15, 20, "A) Add a TTY entry");
X	mvwaddstr(tt_win, 16, 20, "D) Delete a TTY entry");
X	horizontal(tt_win, 19, 0, 80);
X	mvwattrstr(tt_win, 20, 0, A_BOLD, "OPTION ==> ");
X	mvwaddstr(tt_win, 20, 58, "Press <ESC> to return");
X	wmove(tt_win, 20, 12);
X	touchwin(tt_win);
X	wrefresh(tt_win);
X					/* get the option */
X	ret_code = 0;
X	while ((str = get_str(tt_win, 2, "01234356789AaDd", "")) != NULL) {
X		switch(*str) {
X			case '0':
X			case '1':
X			case '2':
X			case '3':
X			case '4':
X			case '5':
X			case '6':
X			case '7':
X			case '8':
X			case '9':
X				i = atoi(str);
X					/* if beyond t_entries */
X				if (i > modem->t_entries) {
X					beep();
X					break;
X				}
X
X					/* change the entry  */
X				if (tty_prompt(tt_win, i-1)) {
X
X					/* requires modem update? */
X					create_modem(modem->tname[i-1]);
X					del_modem();
X					ret_code++;
X				}
X				break;
X			case 'a':
X			case 'A':	/* add an entry */
X				if (modem->t_entries == NUM_TTY) {
X					sprintf(message, "\"%s\"", modem->m_path);
X					error_win(0, "No empty TTY slots in modem/TTY database", message);
X					break;
X				}
X					/* prompt for info */
X				j = modem->t_entries;
X				if (tty_prompt(tt_win, j)) {
X
X					/* add modem entry? */
X					modem->t_entries++;
X					create_modem(modem->tname[j]);
X					ret_code++;
X				}
X				break;
X			case 'd':
X			case 'D':	/* delete an entry */
X				mvwaddstr(tt_win, 21, 0, "Entry number to delete: ");
X				wrefresh(tt_win);
X				while ((num = get_num(tt_win, 4)) != -1) {
X					/* valid range */
X					if (!num || num>modem->t_entries) {
X						beep();
X						mvwaddstr(tt_win, 21, 24, "   ");
X						wmove(tt_win, 21, 24);
X						wrefresh(tt_win);
X						continue;
X					}
X					del_tty(num-1);
X					del_modem();
X
X					/* show the new list */
X					disp_tty(tt_win);
X					ret_code++;
X					break;
X				}
X				break;
X			default:
X				beep();
X				break;
X		}
X		mvwaddstr(tt_win, 20, 12, "  ");
X		clear_line(tt_win, 21, 0, FALSE);
X		clear_line(tt_win, 22, 0, FALSE);
X		wmove(tt_win, 20, 12);
X		wrefresh(tt_win);
X	}
X	delwin(tt_win);
X	return(ret_code);
X}
X
X/*
X * Display the current TTY list.  No scrolling yet, so if your NUM_TTY is
X * greater than ten, this routine will need some work.
X */
X
static void
disp_tty(win)
WINDOW *win;
X{
X	int i;
X
X	for (i=0; i<NUM_TTY; i++)
X		mvwprintw(win, i+4, 20, "%2d) %-14.14s %-14.14s  %d\n",
X		 i+1, modem->tty[i], modem->tname[i], modem->lock_sp[i]);
X	return;
X}
X
X/*
X * Prompt the user for the TTY database info.  A non-zero return code means
X * something was changed.  The second argument is the zero based index.
X */
X
static int
tty_prompt(win, i)
WINDOW *win;
int i;
X{
X	char *ans, t_tty[80], t_tname[80], *str_prompt(), *menu_prompt();
X	char *str_rep(), *strcpy();
X	static char *v_baud[9] = {"0", "300", "1200", "2400", "4800", "9600",
X	 "19200", "38400", NULL};
X					/* get temp TTY */
X	if ((ans = str_prompt(win, i+4, 24, "TTY name", "")) == NULL)
X		return(0);
X
X	strcpy(t_tty, ans);
X	clear_line(win, 21, 0, FALSE);
X
X					/* get temp tname */
X	if ((ans = str_prompt(win, i+4, 39, "Modem name", "")) == NULL)
X		return(0);
X
X	strcpy(t_tname, ans);
X	clear_line(win, 21, 0, FALSE);
X
X					/* get DTE locked baud */
X	if ((ans = menu_prompt(win, i+4, 55, "Locked speed", v_baud)) == NULL)
X		return(0);
X
X	wrefresh(win);
X					/* store 'em for real */
X	modem->tty[i] = str_rep(modem->tty[i], t_tty);
X	modem->tname[i] = str_rep(modem->tname[i], t_tname);
X	modem->lock_sp[i] = atoi(ans);
X
X	return(1);
X}
X
X/*
X * Delete a TTY entry.  Since the list must be contiguous, we collapse the
X * list to cover the hole we made.
X */
X
static void
del_tty(i)
int i;
X{
X	extern char *null_ptr;
X	int j;
X	char *str_rep();
X	void free_ptr();
X					/* collapse the list */
X	for (j=i; j<modem->t_entries-1; j++) {
X		modem->tty[j] = str_rep(modem->tty[j], modem->tty[j+1]);
X		modem->tname[j] = str_rep(modem->tname[j], modem->tname[j+1]);
X		modem->lock_sp[j] = modem->lock_sp[j+1];
X	}
X	j = modem->t_entries-1;
X					/* zap the entry */
X	free_ptr(modem->tty[j]);
X	free_ptr(modem->tname[j]);
X	modem->tty[j] = null_ptr;
X	modem->tname[j] = null_ptr;
X	modem->lock_sp[j] = 0;
X					/* update the count */
X	modem->t_entries--;
X	if (modem->t_cur >= modem->t_entries)
X		modem->t_cur = -1;
X	return;
X}
END_OF_FILE
if test 4931 -ne `wc -c <'s_tty.c'`; then
    echo shar: \"'s_tty.c'\" unpacked with wrong size!
fi
# end of 's_tty.c'
fi
if test -f 'script.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'script.c'\"
else
echo shar: Extracting \"'script.c'\" \(5952 characters\)
sed "s/^X//" >'script.c' <<'END_OF_FILE'
X/*
X * Spawn a shell with file descriptors that look like this:
X *
X *                   + ---> screen (& virtual screen)
X *                   |
X *              +---------+                     +-----------+
X *              |         | <---> cmd IPC <---> | pcomm_cmd |
X *              |  Pcomm  |                     +-----------+
X *   TTYin ---> |         | ---> pipe --> stdin |           |
X *              +---------+                     |   shell   |
X *   TTYout <--------------------------- stdout |           |
X *                                              +-----------+
X *
X * This allows the characters to appear on the screen *and* be interpreted
X * by the shell script.
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include <signal.h>
X#include <errno.h>
X#include "config.h"
X#include "dial_dir.h"
X#include "misc.h"
X#include "modem.h"
X#include "status.h"
X
static int epid, dup_pipe[2];
static char **fixup_env();
X
void
do_script(script)
char *script;
X{
X	extern int fd;
X	char buf[80], *path, *findfile(), **envp, *ipc_key(), *strcpy();
X	void _exit(), error_win(), ipc_update();
X
X	if (*script == '\0')
X		return;
X	/*
X	 * Chaining of scripts, is not allowed.  If a script performs the
X	 * "pcomm_cmd dial" command and that dialing directory entry has
X	 * something in the script field, then ignore the second script.
X	 */
X	if (status->dup_fd != -1)
X		return;
X					/* find the script file */
X	if ((path = findfile(script)) == NULL) {
X		/*
X		 * Fail quietly, if the script is actually a TTY or a
X		 * modem 
X		 */
X		if (chk_aux(script) != IS_SCRIPT)
X			return;
X
X		sprintf(buf, "Can't locate script \"%s\"", script);
X		error_win(0, buf, "");
X		return;
X	}
X					/* execute permission ? */
X	if (access(path, 1)) {
X		sprintf(buf, "\"%s\"", path);
X		error_win(0, "No execute permission on script file", buf);
X		return;
X	}
X	/*
X	 * If a script is invoked prior to dialing, then we need to 
X	 * pass a valid "fd" to the child process.  If the script
X	 * then does a "pcomm_cmd dial", it *must* use that fd.
X	 */
X	if (fd == -1) {
X		dir->d_cur = 0;
X		dir->q_num[0] = 0;
X		if (get_port())
X			return;
X	}
X					/* create a fd for duplicating input */
X	if (pipe(dup_pipe) < 0) {
X		error_win(0, "Out of pipe resources", "");
X		return;
X	}
X
X	status->dup_fd = dup_pipe[1];
X					/* open an IPC channel */
X	if ((status->cmd_ipc = ipc_open()) < 0) {
X		close(dup_pipe[0]);
X		close(dup_pipe[1]);
X		status->dup_fd = -1;
X		error_win(0, "Can't open IPC channel", "");
X		return;
X	}
X	ipc_update(fd, status->cmd_ipc);
X					/* pass the "key" in the environment */
X	strcpy(buf, ipc_key(status->cmd_ipc));
X	envp = fixup_env(buf);
X
X	if (!(epid = fork())) {
X					/* create a new process group ID */
X#ifdef BSD
X		setpgrp(0, getpid());
X#else /* BSD */
X		setpgrp();
X#endif /* BSD */
X					/* swap the stdin and stdout */
X		close(0);
X		dup(dup_pipe[0]);
X		close(1);
X		dup(fd);
X
X		setgid(getgid());
X		setuid(getuid());
X
X		execle("/bin/sh", "sh", "-c", path, (char *) 0, envp);
X		_exit(1);
X	}
X	return;
X}
X
X/*
X * See if the script process is still active
X */
X
void
is_active()
X{
X	extern int errno, fd;
X	int dummy;
X	void ipc_update();
X
X#ifdef BSD
X	if ((kill(epid, 0) == -1) && errno == ESRCH) {
X#else /* BSD */
X	if ((kill(-epid, 0) == -1) && errno == ESRCH) {
X#endif /* BSD */
X					/* shut down the duplication of input */
X		close(dup_pipe[0]);
X		close(dup_pipe[1]);
X		ipc_close(status->cmd_ipc);
X
X		status->dup_fd = -1;
X		status->cmd_ipc = -1;
X		ipc_update(fd, status->cmd_ipc);
X
X		wait(&dummy);
X		beep();
X	}
X	return;
X}
X
X/*
X * Abort the script prematurely.
X */
X
void
stop_script()
X{
X	extern int fd;
X	int dummy;
X	unsigned int sleep();
X	void ipc_update();
X
X#ifdef BSD
X	killpg(epid, SIGKILL);
X#else /* BSD */
X	kill(-epid, SIGKILL);
X#endif /* BSD */
X
X	sleep(1);
X
X	close(dup_pipe[0]);
X	close(dup_pipe[1]);
X	ipc_close(status->cmd_ipc);
X
X	status->dup_fd = -1;
X	status->cmd_ipc = -1;
X	ipc_update(fd, status->cmd_ipc);
X
X	wait(&dummy);
X	return;
X}
X
X/*
X * Prompt the user for a shell script.
X */
X
char *
script_menu()
X{
X	extern int fd;
X	WINDOW *sc_win, *newwin();
X	char *ans, *script, *get_str(), *findfile(), *str_dup(), *path;
X	char *strchr(), buf[80], *strcpy();
X	void free_ptr(), error_win();
X
X	if (status->dup_fd != -1) {
X		error_win(0, "A script is already running", "Concurrent scripts are not allowed");
X		return(NULL);
X	}
X
X	sc_win = newwin(5, 55, 4, 7);
X
X	box(sc_win, VERT, HORZ);
X	mvwaddstr(sc_win, 2, 4, "Shell script: ");
X	mvwattrstr(sc_win, 0, 3, A_BOLD, " Command Files ");
X	wmove(sc_win, 2, 18);
X	wrefresh(sc_win);
X
X	script = NULL;
X	strcpy(buf, "Shell script not found");
X					/* get the answer */
X	while ((ans = get_str(sc_win, 80, "", " \t\n")) != NULL) {
X					/* a CR means exit */
X		if (*ans == '\0')
X			break;
X					/* see if we can find it */
X		if ((path = findfile(ans)) != NULL) {
X			if (!access(path, 1)) {
X				free_ptr(path);
X				script = str_dup(ans);
X				break;
X			}
X			else
X				strcpy(buf, "No execute permission");
X		}
X
X		beep();
X		if (strchr(ans, '/'))
X			strcpy(buf, "Don't include the path");
X
X		mvwattrstr(sc_win, 3, 16, A_BOLD, buf);
X		wrefresh(sc_win);
X		wait_key(sc_win, 3);
X					/* clean up the mess */
X		clear_line(sc_win, 2, 18, TRUE);
X		clear_line(sc_win, 3, 16, TRUE);
X		wmove(sc_win, 2, 18);
X		wrefresh(sc_win);
X
X		free_ptr(path);
X	}
X	if (fd == -1) {
X		werase(sc_win);
X		wrefresh(sc_win);
X	}
X	delwin(sc_win);
X	return(script);
X}
X
X/*
X * Put PCOMM_CMD into a new environmental variable array.
X */
X
static char **
fixup_env(key)
char *key;
X{
X	int n;
X	extern char **environ;
X	char **envp, buf[80], **old, **new, *malloc(), *str_dup();
X
X					/* how many variables do we have? */
X	old = environ;
X	n = 0;
X	while (*old != NULL) {
X		n++;
X		old++;
X	}
X
X	envp = (char **) malloc((n+2) * sizeof(char *));
X	new = envp;
X	old = environ;
X	while (*old != NULL) {
X					/* don't copy an old value */
X		if (strncmp(*old, "PCOMM_CMD=", 10)) {
X			*new = str_dup(*old);
X			new++;
X		}
X		old++;
X	}
X	sprintf(buf, "PCOMM_CMD=%s", key);
X	*new = str_dup(buf);
X	new++;
X	*new = NULL;
X	return(envp);
X}
END_OF_FILE
if test 5952 -ne `wc -c <'script.c'`; then
    echo shar: \"'script.c'\" unpacked with wrong size!
fi
# end of 'script.c'
fi
if test -f 'strings.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'strings.c'\"
else
echo shar: Extracting \"'strings.c'\" \(4196 characters\)
sed "s/^X//" >'strings.c' <<'END_OF_FILE'
X/*
X * Miscellaneous string routines.
X */
X
X#include <stdio.h>
X#include "config.h"
X
X/*
X * Do a fancy string copy.  If NULL, return null.  If pointer to NULL, then
X * return the special "null_ptr" variable.  If a normal copy, allocate
X * memory first.
X */
X
char *
str_dup(str)
char *str;
X{
X	extern char *null_ptr;
X	char *ret, *malloc(), *strcpy();
X	void error_win();
X
X	if (str == NULL)
X		return(NULL);
X					/* if pointer to null */
X	if (*str == '\0')
X		return(null_ptr);
X
X	if (!(ret = malloc((unsigned int) strlen(str)+1)))
X		error_win(1, "Out of memory", "");
X
X	strcpy(ret, str);
X	return(ret);
X}
X
X/*
X * Perform the free(2) function, but check for NULL and the special
X * "null_ptr" variable first.
X */
X
void
free_ptr(str)
char *str;
X{
X	extern char *null_ptr;
X	void free();
X
X	if (str != NULL && str != null_ptr)
X		free(str);
X	return;
X}
X
X/*
X * Replace a string.  Follows the same convention as str_dup(), except
X * that realloc() is used instead of malloc().  Returns a pointer to
X * the new string (which may have moved).
X */
X
char *
str_rep(s1, s2)
char *s1, *s2;
X{
X	extern char *null_ptr;
X	void free_ptr(), error_win();
X	char *s, *malloc(), *realloc(), *strcpy();
X
X					/* copy null pointer ? */
X	if (s2 == NULL) {
X		free_ptr(s1);
X		return(NULL);
X	}
X	if (s2 == '\0') {
X		free_ptr(s1);
X		return(null_ptr);
X	}
X					/* use realloc()? */
X	if (s1 == NULL || s1 == null_ptr) {
X		if (!(s = malloc((unsigned int) strlen(s2)+1)))
X			error_win(1, "Out of memory", "");
X	}
X	else {
X		if (!(s = realloc(s1, (unsigned int) strlen(s2)+1)))
X			error_win(1, "Out of memory", "");
X	}
X
X	strcpy(s, s2);
X	return(s);
X}
X
X/*
X * This routine is similar to strtok(3).  But this version handles missing
X * tokens by returning a pointer to null.  Also it takes a single separator
X * character as an argument.  Returns a NULL on end of string or error.
X */
X
char *
str_tok(str, c)
char *str, c;
X{
X	char *strchr();
X	static char *ptr, *sep;
X					/* start at beginning */
X	if (str != NULL)
X		ptr = str;
X	else
X		ptr = sep;
X					/* at the end? */
X	if (*ptr == '\0')
X		return(NULL);
X					/* no separator? */
X	if (!(sep = strchr(ptr, c)))
X		return(NULL);
X					/* zap the sep, move past it */
X	*sep = '\0';
X	sep++;
X
X	return(ptr);
X}
X
X#ifndef HAVE_STRSTR
X/*
X * Return a pointer to the first occurrence of string str2 in str1.
X * Returns a NULL if str2 is not in str1.
X */
X
char *
strstr(str1, str2)
char *str1, *str2;
X{
X	int len;
X
X	len = strlen(str2);
X	while (*str1) {
X		if (*str2 == *str1) {
X			if (!strncmp(str2, str1, len))
X				return(str1);
X		}
X		str1++;
X	}
X	return(NULL);
X}
X#endif /* HAVE_STRSTR */
X
X#ifdef BSD
X/*
X * Returns the length of the initial segment of string which consists
X * entirely of characters from charset.
X */
X
int
strspn(string, charset)
char	*string;
register char	*charset;
X{
X	register char *p, *q;
X
X	for(q=string; *q != '\0'; ++q) {
X		for(p=charset; *p != '\0' && *p != *q; ++p)
X			;
X		if(*p == '\0')
X			break;
X	}
X	return(q-string);
X}
X
X/*
X * Strtok considers string to consist of a sequence of zero or more
X * text tokens separated by spans of one or more characters from sepset.
X */
X
char *
strtok(string, sepset)
char	*string, *sepset;
X{
X	register char	*p, *q, *r;
X	static char	*savept;
X	char *strpbrk();
X
X	/*first or subsequent call*/
X	p = (string == NULL)? savept: string;
X
X	if(p == 0)		/* return if no tokens remaining */
X		return(NULL);
X
X	q = p + strspn(p, sepset);	/* skip leading separators */
X
X	if(*q == '\0')		/* return if no tokens remaining */
X		return(NULL);
X
X	if((r = strpbrk(q, sepset)) == NULL)	/* move past token */
X		savept = 0;	/* indicate this is last token */
X	else {
X		*r = '\0';
X		savept = ++r;
X	}
X	return(q);
X}
X
X/*
X * Return ptr to first occurrence of any character from `brkset'
X * in the character string `string'; NULL if none exists.
X */
X
char *
strpbrk(string, brkset)
register char *string, *brkset;
X{
X	register char *p;
X
X	if(!string || !brkset)
X		return(0);
X	do {
X		for(p=brkset; *p != '\0' && *p != *string; ++p)
X			;
X		if(*p != '\0')
X			return(string);
X	}
X	while(*string++);
X	return(0);
X}
X
X/*
X * Copies the character c, n times to string s
X */
X
char *
memset(s, c, n)
char *s, c;
int n;
X{
X	char *s1 = s;
X
X	while (n > 0) {
X		--n;
X		*s++ = c;
X	}
X	return(s1);
X}
X#endif /* BSD */
END_OF_FILE
if test 4196 -ne `wc -c <'strings.c'`; then
    echo shar: \"'strings.c'\" unpacked with wrong size!
fi
# end of 'strings.c'
fi
if test -f 'tty_att.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tty_att.c'\"
else
echo shar: Extracting \"'tty_att.c'\" \(5206 characters\)
sed "s/^X//" >'tty_att.c' <<'END_OF_FILE'
X/*
X * System V specific routines for manipulating the TTY
X */
X
X#include <stdio.h>
X#include <termio.h>
X#include <fcntl.h>
X#include "dial_dir.h"
X#include "modem.h"
X#include "param.h"
X
static struct termio hold;
X
X/*
X * Change the communication line settings to the new values.
X */
X
void
line_set()
X{
X	static int first = 1;
X	extern int fd;
X	struct termio tbuf;
X	unsigned int baud;
X					/* nothing to do! */
X	if (fd == -1)
X		return;
X
X	if (first) {
X		ioctl(fd, TCGETA, &hold);
X		first = 0;
X	}
X					/* get the current settings */
X	ioctl(fd, TCGETA, &tbuf);
X					/* set some beginning values */
X	tbuf.c_cc[4] = 1;		/* VMIN */
X	tbuf.c_cc[5] = 1;		/* VTIME */
X	tbuf.c_oflag = 0;
X	tbuf.c_iflag = 0;
X	tbuf.c_cflag = (CREAD|HUPCL|CLOCAL);
X	tbuf.c_lflag = 0;
X
X	if (*param->flow_ctrl == 'X')
X		tbuf.c_iflag |= (IXON|IXOFF);
X					/* strip high bit? */
X	if (*param->strip == 'Y')
X		tbuf.c_iflag |= ISTRIP;
X
X	/*
X	 * If the DTE speed is locked, then ignore all request to 
X	 * change the speed.
X	 */
X	baud = modem->lock_sp[modem->t_cur];
X	if (baud == 0)
X		baud = dir->baud[0];
X					/* the baud rate */
X	switch (baud) {
X		case 300:
X			tbuf.c_cflag |= B300;
X			break;
X		case 1200:
X			tbuf.c_cflag |= B1200;
X			break;
X		case 2400:
X			tbuf.c_cflag |= B2400;
X			break;
X		case 4800:
X			tbuf.c_cflag |= B4800;
X			break;
X		case 9600:
X			tbuf.c_cflag |= B9600;
X			break;
X		case 19200:
X#ifdef B19200
X			tbuf.c_cflag |= B19200;
X#else /* B19200 */
X#ifdef EXTA
X			tbuf.c_cflag |= EXTA;
X#endif /* EXTA */
X#endif /* B19200 */
X			break;
X		case 38400:
X#ifdef B38400
X			tbuf.c_cflag |= B38400;
X#else /* B38400 */
X#ifdef EXTB
X			tbuf.c_cflag |= EXTB;
X#endif /* EXTB */
X#endif /* B38400 */
X			break;
X	}
X					/* the parity */
X	switch (dir->parity[0]) {
X		case 'N':
X			break;
X		case 'O':
X			tbuf.c_cflag |= (PARENB|PARODD);
X			break;
X		case 'E':
X			tbuf.c_cflag |= PARENB;
X			break;
X	}
X					/* the data bits */
X	if (dir->data_bits[0] == 8)
X		tbuf.c_cflag |= CS8;
X	else
X		tbuf.c_cflag |= CS7;
X					/* the stop bits */
X	if (dir->stop_bits[0] == 2)
X		tbuf.c_cflag |= CSTOPB;
X
X					/* now set 'em! */
X	ioctl(fd, TCSETAF, &tbuf);
X	return;
X}
X
X/*
X * Put things back the way they were.
X */
X
void
reset_line()
X{
X	extern int fd;
X
X	ioctl(fd, TCSETAF, &hold);
X	return;
X}
X
X/*
X * Put the stdin/stdout in terminal mode.  We've divided up the
X * responsibility for the line settings options between the serial port
X * and the stdin and stdout.
X */
X
void
term_mode()
X{
X	struct termio tbuf;
X
X	ioctl(0, TCGETA, &tbuf);
X
X	tbuf.c_cc[4] = 1;		/* VMIN */
X	tbuf.c_cc[5] = 0;		/* VTIME */
X	tbuf.c_iflag = 0;
X	tbuf.c_oflag = 0;
X	tbuf.c_lflag = 0;
X					/* duplex */
X	if (dir->duplex[0] == 'H')
X		tbuf.c_lflag = ECHO;
X
X	ioctl(0, TCSETAF, &tbuf);
X	return;
X}
X
X/*
X * Put the TTY driver in the mode suitable for xmodem transfers.
X */
X
void
xmodem_mode(fds)
int fds;
X{
X	struct termio tbuf;
X
X	ioctl(fds, TCGETA, &tbuf);
X	/*
X	 * Turn off the XON/XOFF flow control, turn off echoing, and
X	 * switch to 8 bit no parity.
X	 */
X	tbuf.c_cc[4] = 1;		/* VMIN */
X	tbuf.c_cc[5] = 0;		/* VTIME */
X	tbuf.c_iflag = 0;		/* no flow control or mapping */
X	tbuf.c_oflag = 0;		/* no char mapping or delays */
X	tbuf.c_lflag = 0;		/* no echo or signals */
X	tbuf.c_cflag &= ~(PARENB|CSIZE);/* no parity */
X	tbuf.c_cflag |= CS8;		/* 8 bit */
X
X	ioctl(fds, TCSETAF, &tbuf);
X	return;
X}
X
X/*
X * Put the TTY line in a mode suitable for the ASCII transfer.  Puts the
X * terminal in the raw, non-blocking mode.
X */
X
void
ascii_mode(up)
int up;
X{
X	extern int fd;
X	struct termio tbuf;
X
X	ioctl(fd, TCGETA, &tbuf);
X	tbuf.c_oflag = 0;
X					/* flow control & 8th bit stripping */
X	if (up) {
X		tbuf.c_iflag = (ISTRIP|IXON);
X
X					/* if no CR's, use NL delays */
X		if (!strcmp(param->cr_up, "STRIP"))
X			tbuf.c_oflag = (OPOST|ONLRET);
X
X					/* CR delay times */
X		switch (param->cr_delay) {
X			case 0:
X				break;
X			case 100:
X				tbuf.c_oflag |= (OPOST|CR2);
X				break;
X			case 150:
X				tbuf.c_oflag |= (OPOST|CR3);
X				break;
X		}
X	}
X					/* if down loading */
X	else
X		tbuf.c_iflag = (ISTRIP|IXOFF);
X
X	ioctl(fd, TCSETAF, &tbuf);
X	return;
X}
X
X/*
X * Flush the file descriptor
X */
X
int
tty_flush(fds, mode)
int fds, mode;
X{
X	return(ioctl(fds, TCFLSH, mode));
X}
X
X/*
X * Wait for the output to drain
X */
X
int
tty_drain(fds)
int fds;
X{
X	return(ioctl(fds, TCSBRK, 1));
X}
X
X/*
X * Send a modem break
X */
X
int
tty_break(fds)
int fds;
X{
X	return(ioctl(fds, TCSBRK, 0));
X}
X
X/*
X * Fix the file descriptor so that a read is satisfied immediately.  When
X * read() is called it returns the character in the queue, or an error if
X * no key was pressed.
X */
X
int
tty_noblock(fds, on)
int fds, on;
X{
X	int current;
X
X	current = fcntl(fds, F_GETFL, 0);
X	if (on)
X		return(fcntl(fds, F_SETFL, current | O_NDELAY));
X	else
X		return(fcntl(fds, F_SETFL, current & ~O_NDELAY));
X}
X
X/*
X * Get the current baud rate of the terminal
X */
X
int
my_speed()
X{
X	static unsigned int speed[16] = {0, 50, 75, 110, 134, 150, 200, 300,
X	600, 1200, 1800, 2400, 4800, 9600, 19200, 38400};
X	struct termio tbuf;
X
X	ioctl(0, TCGETA, &tbuf);
X	return(speed[tbuf.c_cflag & CBAUD]);
X}
X
X/*
X * Restart any XON/XOFF flow control that may have stopped the tty 
X */
X
void
tty_restart()
X{
X	extern int fd;
X
X	if (fd != -1 && *param->flow_ctrl == 'X')
X		ioctl(fd, TCXONC, 1);
X	return;
X}
END_OF_FILE
if test 5206 -ne `wc -c <'tty_att.c'`; then
    echo shar: \"'tty_att.c'\" unpacked with wrong size!
fi
# end of 'tty_att.c'
fi
if test -f 'tty_ucb.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tty_ucb.c'\"
else
echo shar: Extracting \"'tty_ucb.c'\" \(5184 characters\)
sed "s/^X//" >'tty_ucb.c' <<'END_OF_FILE'
X/*
X * Berkeley specific routines for manipulating the TTY
X */
X
X#include <stdio.h>
X#include <sgtty.h>
X#include <fcntl.h>
X#include "dial_dir.h"
X#include "modem.h"
X#include "param.h"
X
static struct sgttyb hold;
X
X/*
X * Change the communication line settings to the new values.
X */
X
void
line_set()
X{
X	static int first = 1;
X	extern int fd;
X	struct sgttyb tbuf;
X	unsigned int baud;
X					/* nothing to do! */
X	if (fd == -1)
X		return;
X
X	if (first) {
X		ioctl(fd, TIOCGETP, &hold);
X		first = 0;
X	}
X					/* get the current settings */
X	ioctl(fd, TIOCGETP, &tbuf);
X					/* set some beginning values */
X	tbuf.sg_flags = CBREAK;
X
X	if (*param->flow_ctrl == 'X')
X		tbuf.sg_flags |= TANDEM;
X	/*
X	 * If the DTE speed is locked, then ignore all request to change
X	 * the speed.
X	 */
X	baud = modem->lock_sp[modem->t_cur];
X	if (baud == 0)
X		baud = dir->baud[0];
X					/* the baud rate */
X	switch (baud) {
X		case 300:
X			tbuf.sg_ispeed = B300;
X			tbuf.sg_ospeed = B300;
X			break;
X		case 1200:
X			tbuf.sg_ispeed = B1200;
X			tbuf.sg_ospeed = B1200;
X			break;
X		case 2400:
X			tbuf.sg_ispeed = B2400;
X			tbuf.sg_ospeed = B2400;
X			break;
X		case 4800:
X			tbuf.sg_ispeed = B4800;
X			tbuf.sg_ospeed = B4800;
X			break;
X		case 9600:
X			tbuf.sg_ispeed = B9600;
X			tbuf.sg_ospeed = B9600;
X			break;
X		case 19200:
X#ifdef B19200
X			tbuf.sg_ispeed = B19200;
X			tbuf.sg_ospeed = B19200;
X#else /* B19200 */
X#ifdef EXTA
X			tbuf.sg_ispeed = EXTA;
X			tbuf.sg_ospeed = EXTA;
X#endif /* EXTA */
X#endif /* B19200 */
X			break;
X		case 38400:
X#ifdef B38400
X			tbuf.sg_ispeed = B38400;
X			tbuf.sg_ospeed = B38400;
X#else /* B38400 */
X#ifdef EXTB
X			tbuf.sg_ispeed = EXTB;
X			tbuf.sg_ospeed = EXTB;
X#endif /* EXTB */
X#endif /* B38400 */
X			break;
X	}
X					/* the parity */
X	switch (dir->parity[0]) {
X		case 'N':
X			tbuf.sg_flags |= ANYP;
X			break;
X		case 'O':
X			tbuf.sg_flags |= ODDP;
X			break;
X		case 'E':
X			tbuf.sg_flags |= EVENP;
X			break;
X	}
X					/* now set 'em! */
X	ioctl(fd, TIOCSETP, &tbuf);
X	ioctl(fd, TIOCHPCL, 0);
X	return;
X}
X
X/*
X * Put things back the way they were.
X */
X
void
reset_line()
X{
X	extern int fd;
X
X	ioctl(fd, TIOCSETP, &hold);
X	return;
X}
X
X/*
X * Put the stdin/stdout in terminal mode.  We've divided up the
X * responsibility for the line settings options between the serial port
X * and the stdin and stdout.
X */
X
void
term_mode()
X{
X	struct sgttyb tbuf;
X
X	ioctl(0, TIOCGETP, &tbuf);
X	
X	tbuf.sg_flags |= RAW;
X	tbuf.sg_flags &= ~(CRMOD|ECHO);
X
X	if (dir->duplex[0] == 'H')
X		tbuf.sg_flags |= ECHO;
X
X	ioctl(0, TIOCSETP, &tbuf);
X	return;
X}
X
X/*
X * Put the TTY driver in the mode suitable for xmodem transfers.
X */
X
void
xmodem_mode(fds)
int fds;
X{
X	struct sgttyb tbuf;
X
X	ioctl(fds, TIOCGETP, &tbuf);
X	/*
X	 * Turn off the XON/XOFF flow control, turn off echoing, and
X	 * switch to 8 bit no parity.
X	 */
X	tbuf.sg_flags |= (RAW|ANYP);
X	tbuf.sg_flags &= ~ECHO;
X	ioctl(fds, TIOCSETP, &tbuf);
X	return;
X}
X
X/*
X * Put the TTY line in a mode suitable for the ASCII transfer.
X */
X
void
ascii_mode(up)
int up;
X{
X	extern int fd;
X	struct sgttyb tbuf;
X
X	ioctl(fd, TIOCGETP, &tbuf);
X
X	tbuf.sg_flags |= (CBREAK|TANDEM);
X	tbuf.sg_flags &= ~(RAW|CRMOD|ECHO|CRDELAY);
X
X	if (up) {
X					/* CR delay times */
X		switch (param->cr_delay) {
X			case 0:
X				break;
X			case 100:
X				tbuf.sg_flags |= CR1;
X				break;
X			case 150:
X				tbuf.sg_flags |= CR2;
X				break;
X		}
X	}
X
X	ioctl(fd, TIOCSETP, &tbuf);
X	return;
X}
X
X/*
X * Flush the file descriptor.  Very messy... flushing the input causes a
X * wait for the output to drain, and there is no output flushing.
X */
X
int
tty_flush(fds, mode)
int fds, mode;
X{
X	int ret_code = 0;
X	struct sgttyb tbuf;
X
X	switch(mode) {
X		case 0:			/* flush input queue */
X			ioctl(fds, TIOCGETP, &tbuf);
X			ioctl(fds, TIOCSETP, &tbuf);
X			break;
X		case 1:			/* flush output queue */
X			/* sorry! */
X			break;
X		case 2:			/* flush both input and output */
X			ioctl(fds, TIOCFLUSH, 0);
X			break;
X		default:
X			ret_code++;
X			break;
X	}
X	return(ret_code);
X}
X
X/*
X * Wait for the output to drain
X */
X
int
tty_drain(fds)
int fds;
X{
X	struct sgttyb tbuf;
X					/* this flushes the input too */
X	ioctl(fds, TIOCGETP, &tbuf);
X	return(ioctl(fds, TIOCSETP, &tbuf));
X}
X
X/*
X * Send a modem break
X */
X
int
tty_break(fds)
int fds;
X{
X	unsigned int sleep();
X
X	ioctl(fds, TIOCSBRK, (struct sgttyb *) 0);
X	sleep(1);
X	return(ioctl(fds, TIOCCBRK, (struct sgttyb *) 0));
X}
X
X/*
X * Fix the file descriptor so that a read is satisfied immediately.  When
X * read() is called it returns the character in the queue, or an error if
X * no key was pressed.
X */
X
int
tty_noblock(fds, on)
int fds, on;
X{
X	int current;
X
X	current = fcntl(fds, F_GETFL, 0);
X	if (on)
X		return(fcntl(fds, F_SETFL, current | FNDELAY));
X	else
X		return(fcntl(fds, F_SETFL, current & ~FNDELAY));
X}
X
X/*
X * Get the current baud rate of the terminal
X */
X
int
my_speed()
X{
X	static unsigned int speed[16] = {0, 50, 75, 110, 134, 150, 200, 300,
X	600, 1200, 1800, 2400, 4800, 9600, 19200, 38400};
X	struct sgttyb tbuf;
X
X	ioctl(0, TIOCGETP, &tbuf);
X	return(speed[tbuf.sg_ispeed]);
X}
X
X/*
X * Restart any XON/XOFF flow control that may have stopped the tty 
X */
X
void
tty_restart()
X{
X	extern int fd;
X
X	if (fd != -1 && *param->flow_ctrl == 'X')
X		ioctl(fd, TIOCFLUSH, (struct sgttyb *) 0);
X	return;
X}
END_OF_FILE
if test 5184 -ne `wc -c <'tty_ucb.c'`; then
    echo shar: \"'tty_ucb.c'\" unpacked with wrong size!
fi
# end of 'tty_ucb.c'
fi
echo shar: End of archive 2 \(of 6\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
