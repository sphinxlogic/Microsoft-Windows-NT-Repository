Newsgroups: comp.sources.unix
From: mcooper@usc.edu (Michael A. Cooper)
Subject: v26i114: [REPOST] sysinfo-1.0 - Show system information, Part01/01
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: mcooper@usc.edu (Michael A. Cooper)
Posting-Number: Volume 26, Issue 114
Archive-Name: sysinfo-1.0/part01

[ the author sent me a last-minute revision to this which i neglected
  to include the first time out.  this is the second and official version
  of v26i114.								--vix ]

This is version 1.0 of sysinfo.  Sysinfo is a program which shows
various pieces of information about a system.  The original version
was written to simply determine the model name of a system for use in
/etc/motd.  It also supported a few other pieces of information that
were simple to obtain, but the method used to obtain the information
on various different OS's varied.  The current version shows many
different "general" bits of system information as well as fairly
detailed information on system devices such as disk drives, frame
buffers, tape drives, and many others.  A lot of the information
sysinfo displays is difficult, if not impossible, to determine by
normal OS commands and/or files after boot time on many OS's.

Michael A. Cooper, University Computing Services, U of Southern California
  INTERNET: mcooper@usc.edu	            PHONE: (213) 740-2957
  UUCP: ...!uunet!usc!mcooper              BITNET: mcooper@ramoth

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  README sysinfo.man Makefile sysinfo.c devices.c memory.c
#   kernel.c run.c KVM.c kvm.c kvm.h patchlevel.h strcasecmp.c
#   strdup.c strerror.c options.c options.h system.h defs.h netif.c
#   info-netif.c os-mach.c info-mach.c os-sunos.c info-sunos.c
#   os-ultrix.c info-ultrix.c info-ultrix.h os-next.c info-next.c
#   os-alliant.c info-alliant.c os-bsd43.c info-bsd43.c os-aix.c
#   info-aix.c options.3 Mkfile.cpp
# Wrapped by mcooper@acamar.usc.edu on Mon Jun  1 15:45:17 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f README -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"README\"
else
echo shar: Extracting \"README\" \(3243 characters\)
sed "s/^X//" >README <<'END_OF_README'
X
X			    SYSINFO 1.0
X
X			 Michael A. Cooper
X	       Research, Development, and Systems Group
X		    University Computing Services
X		  University of Southern California
X			  mcooper@usc.edu
X
X
XGENERAL INFORMATION
X
XThis is version 1.0 of sysinfo.  Sysinfo is a program which shows
Xvarious pieces of information about a system.  The original version
Xwas written to simply determine the model name of a system for use in
X/etc/motd.  It also supported a few other pieces of information that
Xwere simple to obtain, but the method used to obtain the information
Xon various different OS's varied.  The current version shows many
Xdifferent "general" bits of system information as well as fairly
Xdetailed information on system devices such as disk drives, frame
Xbuffers, tape drives, and many others.  A lot of the information
Xsysinfo displays is difficult, if not impossible, to determine by
Xnormal OS commands and/or files after boot time on many OS's.
X
XMost of the OS specific information was determined by groveling
X/usr/include/{sys,machine,*dev}/*.h files, section 4 man pages, and
Xreverse engineering the output from various commands like devinfo
X(SunOS) and using the trace(2) facility.  Some of the network (netif)
Xcode was inspired by the sources to the 4.3BSD netstat and ifconfig
Xcommands.
X
XSUPPORTTED PLATFORMS
X
XSysinfo has been tested on the platforms listed below.  Porting to
Xother BSD based Unix's is fairly straight-forward.
X
X	Sun-3			SunOS 4.0.3, 4.1.1
X	Sun-386			SunOS 4.0.1
X	Sun-4			SunOS 4.0.3, 4.1.1, 4.1.2
X	SPARCbook-1		Solaris 1.0.1 SPARCbook Version A.3
X	Solbourne Series5E	OS/MP 4.1A
X	DEC MIPS		Ultrix 4.1, 4.2
X	NeXT			NeXT 2.1
X	IBM RS6000		*AIX 3.1
X	Alliant 		*Concentrix 5.X, *Concentrix-2800 2.0
X	HP300			*MORE/bsd 4.3 (BSD)
X
X		* - No device information support
X
X
XINSTALLATION
X
XInstalling on one of the platforms listed above should just be a
Xmatter of editing Makefile and running "make".
X
XRun "make install" to install the sysinfo binary and "make
Xinstall.man" to install the man page.
X
XBUG FIXES
X
XPlease send bug fixes, suggestions, and comments to mcooper@usc.edu.
X
XWHERE TO GET IT
X
XThe latest/greatest version of sysinfo is available via anonymous ftp
Xon usc.edu in /pub/sysinfo.
X
XPLATFORM SPECIFIC NOTES
X
XThe following are notes regarding specific platforms:
X
XSunOS	Sysinfo should be compiled for each kernel architecture machine
X	you wish to run it on.  It is normally installed into /usr/kvm
X	and symlinked into something like /usr/local/bin.
X
X	Sun386i device support is shakey, at best.  No SCSI disk info
X	is found.  The kernel device init table doesn't seem to have
X	any of the disk info in it.  I haven't had time to track this
X	down.
X
XNeXT	The C compiler under NeXT 2.1 is an old version of GCC (1.34).
X	That version is broken and will not compile sysinfo.  We installed
X	GCC 2.0 without problem under NeXT 2.1 and it seems to work
X	very well with sysinfo.
X
X	Network address info for network interfaces is not working.  There
X	is currently no debugger that works with GCC 2.0 so I haven't spent
X	time on this.
X
XOTHER KNOWN PROBLEMS
X
XSPARCbook "id" DISKS
X	The label on "id" disks on the SPARCbook-1 cannot be read.  This
X	appears to be because the definition of IDE_READ in 
X	<taddev/ide_drvr_def.h> is incorrect.
END_OF_README
if test 3243 -ne `wc -c <README`; then
    echo shar: \"README\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f sysinfo.man -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"sysinfo.man\"
else
echo shar: Extracting \"sysinfo.man\" \(3518 characters\)
sed "s/^X//" >sysinfo.man <<'END_OF_sysinfo.man'
X.\"
X.\" Copyright (c) 1992 Michael A. Cooper.
X.\" This software may be freely distributed provided it is not sold for 
X.\" profit and the author is credited appropriately.
X.\"
X.\" $Header: /src/common/usc/bin/sysinfo/RCS/sysinfo.man,v 1.9 1992/04/26 23:31:36 mcooper Exp $
X.\" 
X.TH SYSINFO 1 "26 April 1992"
X.ds ]W USC-UCS
X.SH NAME
Xsysinfo \- Display system information
X.SH SYNOPSIS
Xsysinfo
X[
X.B +|\-all
X] 
X[
X.B \-level
X.I level1,level2,...
X]
X[
X.B \-show
X.I item1,item2,...
X] 
X[
X.B +|\-terse
X] 
X[
X.B +|\-unknown
X] 
X.br
X.sp
Xsysinfo 
X.B \-list
X[
X.B level|show
X]
X.br
X.sp
Xsysinfo 
X.B \-version
X.SH DESCRIPTION
X.I Sysinfo
Xdisplays certain pieces of system information for the current host.
XBy default, 
X.I sysinfo
Xdisplays all system information it knows about in verbose mode.
XThis includes:
X.IP *
XHost name
X.IP *
XHost name aliases
X.IP *
XHost network addresses
X.IP *
XHost ID
X.IP *
XSystem serial number
X.IP *
XManufacturer of the system's hardware
X.IP *
XCPU model name
X.IP *
XCPU type
X.IP *
XApplication architecture
X.IP *
XKernel architecture
X.IP *
XAmount of main memory
X.IP *
XOperating system name
X.IP *
XOperating system version
X.IP *
XKernel version
X.IP *
XA variety of information about devices.
X.PP
XBy default,
X.B sysinfo
Xwill display most info items it knows about.
XSpecific items may be exclusively shown by using the
X.B \-show
Xoption and specifying a comma seperated list of items.
X.SH OPTIONS
X.IP "\fB+|-all\fP"
XEnable (\fB+all\fP) or disable (\fB\-all\fP) displaying all known information.
XThis option is enabled by default.
X.IP "\fB\-level \fIlevels\fR"
XSet the show level.
X.I levels
Xis a comma seperated list of values used to determine what
Xlevels of information will be displayed.
XUse the
X.B "\-list level"
Xoption to get a list of valid 
X.I levels.
X.IP "\fB\-list [ level|show ]\fR"
XList all the possible values that may be used with an option.
XSpecifying
X.B "\-list show"
Xwill list possible values for use with the
X.B \-show
Xoption.
XSpecifying
X.B "\-list level"
Xwill list possible values for use with the
X.B \-level
Xoption.
X.IP "\fB+|-terse\fP"
XEnable (\fB+terse\fP) or disable (\fB\-terse\fP) showing items in
Xterse format.
XWhen enabled this 
Xusually means that the field label for each item is not displayed.
XThis option is disabled by default.
X.IP "\fB\-show \fIitem1,item2,...\fR"
XShow information only about each comma seperated item.
XA current list of valid item names can be determined by using the
X.B "\-list show"
Xoption.
X.IP "\fB+|-unknown\fP"
XEnable (\fB+unknown\fP) or disable (\fB\-unknown\fP) showing devices
Xthat appear to be present on the system, but are not "known" to sysinfo.
XThis option is disabled by default.
X.IP "\fB-version\fP"
XShow version
Xinformation for
X.I sysinfo.
X.SH AUTHOR
XMichael A. Cooper, 
X.br
XUniversity Computing Services, 
X.br
XUniversity of Southern California.
X.SH FILES
X.sp
X/etc/cpumodel.name	\- Explicitly set the CPU model name
X.SH SEE ALSO
Xgethostid(2), gethostname(2), gethostbyname(3)
X.SH DIAGNOSTICS
X.IP "\fI%x: Unknown CPU type.\fP"
XThe CPU model for the current host could not be determined.
X.IP "(unknown)"
XInformation could not be determined for this item.
X.SH BUGS
XNot all operating systems support interfaces to various pieces of
Xinformation that sysinfo supports.
X.PP
XSome devices, mostly devices that use 
Xremovable media such as
Xtape drives and floppy disks, are only indicated (shown) as
Xpresent if media is loaded in the device and it's on-line.
XThis occurs because the OS does not provide a software
Xinterface to query the device when media is not loaded.
END_OF_sysinfo.man
if test 3518 -ne `wc -c <sysinfo.man`; then
    echo shar: \"sysinfo.man\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Makefile -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Makefile\"
else
echo shar: Extracting \"Makefile\" \(3784 characters\)
sed "s/^X//" >Makefile <<'END_OF_Makefile'
X#
X# Copyright (c) 1992 Michael A. Cooper.
X# This software may be freely distributed provided it is not sold for 
X# profit and the author is credited appropriately.
X#
X# $Header: /src/common/usc/bin/sysinfo/RCS/Makefile,v 1.8 1992/04/26 23:31:36 mcooper Exp $
X#
X# Makefile for sysinfo
X#
X
X#
X# Location of your Kernel specific directory.
X# This is usually only for SunOS.  If you don't have
X# one, set this to nothing
X#
XKVM		= /usr/kvm
X
X#
X# The bin directory that user's will run the program from.
X# For systems with a $(KVM) (above), a symlink will be put 
X# in $(BIN) pointing to ${KVM}/sysinfo.  On systems without 
X# a $(KVM), the program will be copied to $(BIN).
X#
X# A good place is something like /usr/local/bin.
X#
XBIN 		= /usr/local/bin
X
X#
X# Directory to install man page in.
X#
XMAN 		= /usr/local/man/man1
X
X#
X# The name of the kvm library to use.
X# For SunOS this should be "-lkvm".  For others it should be "kvm.c"
X#
XLIBKVM		= -lkvm
X
X#
X# SunOS 4.0 -> 4.0.3 requires using the System V cc and libc
X# in order to get uname().
X#
X#CC		= /usr/5bin/cc
X#LIBS 		= /usr/5lib/libc.a
X#
X# The C compiler (gcc) under NeXT 2.1 and earlier is broken.
X# You need GCC 2.0 or later.
X#
X#CC		= gcc
X
X#
X# Defines.
X#
X# SunOS needs:
X#	-D`/bin/arch -k`
X#
XDEFINES		= -D`/bin/arch -k`
X
X#
X# Optimization or debugging flag
X#
XOPT		= -g
X
X#
X# Include directories
X#
XINCLUDES	= -I.
X
XCFLAGS 		= ${OPT} ${INCLUDES} ${DEFINES}
X
XNETIFFILES	= netif.c info-netif.c
XMACHFILES	= os-mach.c info-mach.c
X
X#
X# Select the OS specific files to compile
X#
X# SunOS
XOSFILES		= os-sunos.c info-sunos.c ${NETIFFILES}
X# Ultrix
X#OSFILES	= os-ultrix.c info-ultrix.c ${NETIFFILES}
X# NeXT
X#OSFILES	= os-next.c info-next.c ${MACHFILES} ${NETIFFILES}
X# Alliant
X#OSFILES	= os-alliant.c info-alliant.c
X# AIX
X#OSFILES	= os-aix.c info-aix.c
X# HP300's running 4.3BSD (MORE/bsd)
X#OSFILES	= os-bsd43.c info-bsd43.c
X
X#
X# Misc files
X#
X# List of files of things your system may not have.
X# This may include strcasecmp.c, strdup.c, and strerror.c.
X#
XMISCFILES	= strdup.c
X
X#
X# Installation options
X#
X# Sysinfo needs to be able to read your unix image (/vmunix usually),
X# /dev/kmem, and device files in /dev for things like disk drives and tapes.
X# Under SunOS, /dev/kmem is owned by group "kmem", but the disk files
X# (e.g. /dev/rsd0a) are owned by group "operator".  Therefor, you usually
X# can't make setgid to a group, but need it setuid root.
X#
X# You should set the INSTALLOPTS appropriately to allow sysinfo to read
X# everything it needs to.  Try running "sysinfo -debug" to find out the
X# special files it reads.
X#
XINSTALLOPTS 	= -m 4555 -o root -g wheel
X
XBASE 		= sysinfo
XPROG 		= ${BASE}
XSRCS 		= ${BASE}.c devices.c memory.c kernel.c run.c KVM.c options.c \
X			${MISCFILES} ${OSFILES}
XOBJS		= $(SRCS:%.c=$(VARIANT)%.o)
X
Xall: ${PROG}
X
X${PROG}: ${OBJS}
X	${CC} ${CFLAGS} -o $@ ${OBJS} ${LIBS} ${LIBKVM}
X
X#
X# CenterLine support
X#
Xccenter_src: ${SRCS}
X	#load ${CFLAGS} ${SRCS} ${LIBS} ${LIBKVM}
X
Xccenter_obj: ${OBJS}
X	#load ${CFLAGS} ${OBJS} ${LIBS} ${LIBKVM}
X
Xinstall: ${PROG}
X	@if [ "${KVM}" ]; then \
X		echo "install -c ${INSTALLOPTS} ${PROG} ${KVM}/${BASE}"; \
X		install -c ${INSTALLOPTS} ${PROG} ${KVM}/${BASE}; \
X		echo "cd ${BIN} && rm -f ${BASE} && ln -s ${KVM}/${BASE} ${BASE}"; \
X		(cd ${BIN} && rm -f ${BASE} && ln -s ${KVM}/${BASE} ${BASE}); \
X	else \
X		echo install -c ${INSTALLOPTS} ${PROG} ${BIN}/${BASE}; \
X		install -c ${INSTALLOPTS} ${PROG} ${BIN}/${BASE}; \
X	fi
X
Xinstall.man: ${BASE}.man
X	install -c -m 444 -o bin -g bin ${BASE}.man ${MAN}/${BASE}.1
X
Xinstall.compat:
X	install -c -m 555 -o bin -g bin cpumodel.sh /usr/lsd/etc/cpumodel
X	rm -f $MAN/${BASE}.8 $MAN/cpumodel.1
X	(cd /usr/usc/bin; rm -f sysinfo; ln -s ${BIN}/sysinfo)
X
Xclean:
X	rm -f *.o ${PROG} *~ *% \#* core a.out sysinfo.tar sysinfo.tar.Z
X
X${OBJS}: system.h defs.h
END_OF_Makefile
if test 3784 -ne `wc -c <Makefile`; then
    echo shar: \"Makefile\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f sysinfo.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"sysinfo.c\"
else
echo shar: Extracting \"sysinfo.c\" \(26266 characters\)
sed "s/^X//" >sysinfo.c <<'END_OF_sysinfo.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/sysinfo.c,v 1.47 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: sysinfo.c,v $
X * Revision 1.47  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.46  1992/04/17  23:27:51  mcooper
X * Add support for ROM Version information (Sun only for now).
X *
X * Revision 1.45  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.44  1992/04/16  02:25:39  mcooper
X * Bug fixes, de-linting, and other changes found with CodeCenter.
X *
X * Revision 1.43  1992/04/15  02:07:45  mcooper
X * Fixed problem with "-show man +terse".
X *
X * Revision 1.42  1992/04/15  02:00:36  mcooper
X * Major re-write and simplification of command line options.
X *
X * Revision 1.41  1992/03/31  18:57:40  mcooper
X * - Don't stomp on Kernel Version strings.
X * - Change "verbose" to "Show".
X *
X * Revision 1.40  1992/03/25  02:29:51  mcooper
X * Add verbose keywords.
X *
X * Revision 1.39  1992/03/22  00:56:12  mcooper
X * Updates for NeXT.
X *
X * Revision 1.38  1992/03/22  00:20:10  mcooper
X * Major cleanup and re-org.
X *
X * Revision 1.37  1992/03/03  23:57:23  mcooper
X * Make HAVE_KVM and HAVE_NLIST consistant.
X *
X * Revision 1.36  1992/03/03  02:51:07  mcooper
X * Move strdup() to strdup.c
X *
X * Revision 1.35  1992/03/01  23:27:30  mcooper
X * Move bulk of OS specific routines to OS specific files.
X *
X * Revision 1.34  1992/03/01  20:30:06  mcooper
X * Cleanup handling of general info.
X *
X * Revision 1.33  1992/03/01  19:00:55  mcooper
X * Fixed memory size code to be more portable.
X *
X * Revision 1.32  1992/02/22  02:18:20  mcooper
X * Use new KVM() calling convention.
X *
X * Revision 1.31  1992/02/17  01:00:51  mcooper
X * Changes for devices and "general" info.
X *
X * Revision 1.30  1992/02/13  22:37:18  mcooper
X * Add 4/25 hostid.
X *
X * Revision 1.29  1992/02/10  21:06:22  mcooper
X * Cleanup, add support for Sun4m and devices.
X *
X * Revision 1.28  1991/11/10  01:13:41  mcooper
X * Use math function floor() instead of rnddown().
X *
X * Revision 1.27  1991/10/14  21:09:39  mcooper
X * Fix get_memory() bug that caused incorrect
X * results when bytes%DIV_BYTES==0.
X *
X * Revision 1.26  1991/10/14  20:29:59  mcooper
X * Fixed get_memory() for Sun's the RIGHT WAY.
X *
X * Revision 1.25  1991/10/12  02:13:16  mcooper
X * Fix memory page counting on Suns again and
X * add -debug option.
X *
X * Revision 1.24  1991/10/10  00:44:54  mcooper
X * Fixed memory calculation.
X *
X * Revision 1.23  1991/10/09  03:37:17  mcooper
X * Add support for getting serial number
X * and model name directly from system on
X * Alliant FX80 series.
X *
X * Revision 1.22  1991/10/01  01:49:15  mcooper
X * Add new system serial number code.
X *
X * Revision 1.21  1991/09/30  05:21:57  mcooper
X * Add support for getting memory and model
X * number on Alliant 2800's.
X *
X * Revision 1.20  1991/09/30  04:33:45  mcooper
X * - Move system dependant stuff to system.h.
X * - Create error() function.
X *
X * Revision 1.19  1991/09/30  04:04:50  mcooper
X * Cleanup Solbourne stuff.
X *
X * Revision 1.18  1991/09/30  01:57:46  mcooper
X * Sun's now use SUN?_ARCH for determining
X * kernel architecture from gethostid().
X *
X * Revision 1.17  1991/09/28  03:42:24  mcooper
X * Fixed Sun 386i model names.
X *
X * Revision 1.16  1991/09/28  03:36:32  mcooper
X * Fixed get_memory() when converting bytes to MB.
X *
X * Revision 1.15  1991/09/28  03:20:00  mcooper
X * Fixed NULL cast problem.
X *
X * Revision 1.14  1991/09/28  03:13:38  mcooper
X * - Cleanup kvm stuff.
X * - Now works on FX alliants.
X *
X * Revision 1.13  1991/09/27  23:03:12  mcooper
X * Major cleanup/re-write.
X *
X * Revision 1.12  1991/09/26  05:24:22  mcooper
X * - Added memory lookup support for Sun's.
X * - Added printing kernel version string.
X *
X * Revision 1.11  1991/09/22  23:50:23  mcooper
X * Use new NeXT/Mach host_info() calls.
X *
X * Revision 1.10  1991/08/31  03:25:50  mcooper
X * Add defines for SPARCstation ELC and IPX.
X *
X * Revision 1.9  1991/03/12  01:26:03  mcooper
X * Changes for AIX on the RS6000.
X *
X * Revision 1.8  1991/02/27  20:14:15  mcooper
X * Add back in the 4_460.  Need both that
X * and 4_470 since Sun changed to 4_470 in 4.1.1.
X *
X * Revision 1.7  1991/02/27  19:25:04  mcooper
X * Change CPU_SUN4_460 to CPU_SUN4_470.
X *
X * Revision 1.6  1991/02/21  02:20:25  mcooper
X * Add OS name and OS version stuff.
X *
X * Revision 1.5  1991/02/20  20:24:16  mcooper
X * Re-arrange default output order.
X *
X * Revision 1.4  1991/02/20  20:19:34  mcooper
X * If any item is enabled from the command
X * line (via a + option), then only print selected
X * item(s) in non verbose mode.
X *
X * Revision 1.3  1991/02/12  17:27:08  root
X * Ported to NeXT 2.0.
X *
X * Revision 1.2  91/02/11  21:58:35  mcooper
X * - Add new routines to print host name, host
X *   name aliases, network addresses, and hostid.
X * - Make verbose format easier to read with new
X *   PrintLabel() function.
X * 
X * Revision 1.1  1991/02/09  01:33:40  mcooper
X * Initial revision
X *
X */
X
X/*
X * Display System Information
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <arpa/inet.h>
X#include <netdb.h>
X
X#include "system.h"
X#include "defs.h"
X
X#if	defined(HAVE_UNAME)
X#include <sys/utsname.h>
X#endif	/* HAVE_UNAME */
X
X/*
X * Local declarations
X */
Xextern char		       *AppArchCmds[];
Xextern char		       *KernArchCmds[];
Xextern char		       *ArchFiles[];
Xextern char		       *CPUFiles[];
X
Xint 				DoPrintAll = TRUE;
Xint 				DoPrintUnknown = FALSE;
Xint 				DoPrintVersion = FALSE;
Xint 				Level = L_BRIEF;
Xint 				Terse = FALSE;
Xint 				Debug = 0;
Xchar 			       *ShowStr = NULL;
Xchar 			       *LevelStr = NULL;
Xchar 			       *ListStr = NULL;
X
X#if	defined(OPTION_COMPAT)
X/*
X * Old options here for backwards compatibility
X */
Xint				DoPrintCPU = FALSE;
Xint				DoPrintAppArch = FALSE;
Xint				DoPrintHostID = FALSE;
Xint				DoPrintHostName = FALSE;
Xint				DoPrintHostAlias = FALSE;
Xint				DoPrintHostAddrs = FALSE;
Xint				DoPrintKernArch = FALSE;
Xint				DoPrintKernVer = FALSE;
Xint				DoPrintMan = FALSE;
Xint				DoPrintModel = FALSE;
Xint				DoPrintMemory = FALSE;
Xint				DoPrintOSName = FALSE;
Xint				DoPrintOSVer = FALSE;
Xint				DoPrintSerialNo = FALSE;
X#endif	/* OPTION_COMPAT */
X
X/*
X * Command line options table.
X */
XOptionDescRec Opts[] = {
X    {"+all", 	NoArg,		OptBool, 	__ &DoPrintAll,		"1",
X	 NULL,	"Print all information"},
X    {"-all", 	NoArg,		OptBool, 	__ &DoPrintAll,		"0",
X	 NULL,	"Don't print all information"},
X    {"-level",	SepArg,		OptStr, 	__ &LevelStr,		NULL,
X	 "<see \"-list level\">",	"Level names"},
X    {"-list",	SepArg,		OptStr, 	__ &ListStr,		"-",
X	 "level,show",	"List information about values"},
X    {"-show",	SepArg,		OptStr, 	__ &ShowStr,		NULL,
X	 "<see \"-list show\">",	"Show names"},
X    {"+terse", 	NoArg,		OptBool, 	__ &Terse,		"1",
X	 NULL,	"Print info in terse format"},
X    {"-terse", 	NoArg,		OptBool, 	__ &Terse,		"0",
X	 NULL,	"Don't print info in terse format"},
X    {"+unknown",NoArg,		OptBool, 	__ &DoPrintUnknown,	"1",
X	 NULL,	"Print unknown devices"},
X    {"-unknown",NoArg,		OptBool, 	__ &DoPrintUnknown,	"0",
X	 NULL,	"Don't print unknown devices"},
X    {"-version",NoArg,		OptBool, 	__ &DoPrintVersion,	"1",
X	 NULL,	"Print version of this program" },
X    {"-debug",ArgHidden|SepArg,	OptInt, 	__ &Debug,		"1",
X	 NULL,	"Enable debugging"},
X#if	defined(OPTION_COMPAT)
X    {"+cpu", 	NoArg|ArgHidden,OptBool,__ &DoPrintCPU,		"1" },
X    {"-cpu", 	NoArg|ArgHidden,OptBool,__ &DoPrintCPU,		"0" },
X    {"+arch", 	NoArg|ArgHidden,OptBool,__ &DoPrintAppArch,	"1" },
X    {"-arch", 	NoArg|ArgHidden,OptBool,__ &DoPrintAppArch,	"0" },
X    {"+hostid",	NoArg|ArgHidden,OptBool,__ &DoPrintHostID,	"1" },
X    {"-hostid",	NoArg|ArgHidden,OptBool,__ &DoPrintHostID,	"0" },
X    {"+hostname",NoArg|ArgHidden,OptBool,__ &DoPrintHostName,	"1" },
X    {"-hostname",NoArg|ArgHidden,OptBool,__ &DoPrintHostName,	"0" },
X    {"+hostaliases",NoArg|ArgHidden,OptBool,__ &DoPrintHostAlias,"1" },
X    {"-hostaliases",NoArg|ArgHidden,OptBool,__ &DoPrintHostAlias,"0" },
X    {"+hostaddrs",NoArg|ArgHidden,OptBool,__ &DoPrintHostAddrs,	"1" },
X    {"-hostaddrs",NoArg|ArgHidden,OptBool,__ &DoPrintHostAddrs,	"0" },
X    {"+karch", 	NoArg|ArgHidden,OptBool,__ &DoPrintKernArch,	"1" },
X    {"-karch", 	NoArg|ArgHidden,OptBool,__ &DoPrintKernArch,	"0" },
X    {"+kernver",NoArg|ArgHidden,OptBool,__ &DoPrintKernVer,	"1" },
X    {"-kernver",NoArg|ArgHidden,OptBool,__ &DoPrintKernVer,	"0" },
X    {"+man", 	NoArg|ArgHidden,OptBool,__ &DoPrintMan,		"1" },
X    {"-man", 	NoArg|ArgHidden,OptBool,__ &DoPrintMan,		"0" },
X    {"+model", 	NoArg|ArgHidden,OptBool,__ &DoPrintModel,	"1" },
X    {"-model", 	NoArg|ArgHidden,OptBool,__ &DoPrintModel,	"0" },
X    {"+memory",	NoArg|ArgHidden,OptBool,__ &DoPrintMemory,	"1" },
X    {"-memory",	NoArg|ArgHidden,OptBool,__ &DoPrintMemory,	"0" },
X    {"+osname",	NoArg|ArgHidden,OptBool,__ &DoPrintOSName,	"1" },
X    {"-osname",	NoArg|ArgHidden,OptBool,__ &DoPrintOSName,	"0" },
X    {"+osvers",	NoArg|ArgHidden,OptBool,__ &DoPrintOSVer,	"1" },
X    {"-osvers",	NoArg|ArgHidden,OptBool,__ &DoPrintOSVer,	"0" },
X    {"+serial",	NoArg|ArgHidden,OptBool,__ &DoPrintSerialNo,	"1" },
X    {"-serial",	NoArg|ArgHidden,OptBool,__ &DoPrintSerialNo,	"0" },
X#endif	/* OPTION_COMPAT */
X};
X
X/*
X * Option compatibility support
X */
X#if	defined(OPTION_COMPAT)
Xstatic void			SetOptionCompat();
X#define OptCom(v) v
X#else
X#define OptCom(v) 0
X#endif
X
XSHOWINFO ShowInfo[] = {
X    { S_GEN, "general",	"GENERAL INFORMATION",	ShowGeneral },
X    { S_GEN, "hostname",	"Host Name",		NULL, GetHostName,
X						OptCom(&DoPrintHostName) },
X    { S_GEN, "hostaliases",	"Host Aliases",		NULL, GetHostAliases,
X						OptCom(&DoPrintHostAlias) },
X    { S_GEN, "hostaddrs",	"Host Address(es)",	NULL, GetHostAddrs,
X						OptCom(&DoPrintHostAddrs) },
X    { S_GEN, "hostid",		"Host ID",		NULL, GetHostID,
X						OptCom(&DoPrintHostID) },
X    { S_GEN, "serial",		"Serial Number",	NULL, GetSerialNo,
X						OptCom(&DoPrintSerialNo) },
X    { S_GEN, "man",		"Manufacturer",		NULL, GetMan,
X						OptCom(&DoPrintMan) },
X    { S_GEN, "model",		"System Model",		NULL, GetModel,
X						OptCom(&DoPrintModel) },
X    { S_GEN, "memory",		"Main Memory",		NULL, GetMemory,
X						OptCom(&DoPrintMemory) },
X    { S_GEN, "romver",		"ROM Version",		NULL, GetRomVer },
X    { S_GEN, "cpu",		"CPU Type",		NULL, GetCPU,
X						OptCom(&DoPrintCPU) },
X    { S_GEN, "arch",		"App Architecture",	NULL, GetAppArch,
X						OptCom(&DoPrintAppArch) },
X    { S_GEN, "karch",		"Kernel Architecture",	NULL, GetKernArch,
X						OptCom(&DoPrintKernArch) },
X    { S_GEN, "osname",		"OS Name",		NULL, GetOSName,
X						OptCom(&DoPrintOSName) },
X    { S_GEN, "osvers",		"OS Version",		NULL, GetOSVersion,
X						OptCom(&DoPrintOSVer) },
X    { S_GEN, "kernver",		"Kernel Version",	NULL, GetKernelVersion,
X						OptCom(&DoPrintKernVer) },
X    { S_DEV, "devices",	"DEVICE INFORMATION",	ShowDevices },
X    { 0 },
X};
X
X/*
X * Values and names of levels
X */
XNAMETAB LevelNames[] = {
X    { L_BRIEF,		"brief" },
X    { L_GENERAL,	"general" },
X    { L_DESC,		"descriptions" },
X    { L_CONFIG,		"config" },
X    { L_ALL,		"all" },
X    { L_DEBUG,		"debug" },
X    { 0 },
X};
X
X/*
X * List table
X */
Xstruct listtab {
X    char		       *Name;
X    char		       *Desc;
X    void		      (*Func)();
X};
Xtypedef struct listtab LISTTAB;
X
Xstatic void			List();
Xstatic void			ListLevel();
Xstatic void			ListShow();
X
XLISTTAB ListTab[] = {
X    { "level",		"Values for -level option",	ListLevel },
X    { "show",		"Values for -show option",	ListShow },
X    { 0 },
X};
X
X/*
X * Print a label and an argument
X */
Xstatic void PrintLabel(Lbl, Str)
X     char 		       *Lbl;
X     char 		       *Str;
X{
X    if (!Terse)
X	printf("%-*s: ", 20, Lbl);
X    printf("%s\n", (Str && *Str) ? Str : "");
X}
X
X/*
X * Print general info
X */
Xextern void ShowGeneral(MyInfo, SpecInfo)
X    SHOWINFO		       *MyInfo;
X    SHOWINFO		       *SpecInfo;
X{
X    register int		i;
X    int				ShowAll = TRUE;
X
X    /*
X     * Do a specific info item
X     */
X    if (SpecInfo) {
X	PrintLabel(SpecInfo->Label, (*SpecInfo->GetFunc)());
X	SpecInfo->Enable = FALSE;
X	return;
X    }
X
X    /*
X     * See if we are going to show all items
X     */
X    if (!DoPrintAll)
X	for (i = 0; ShowInfo[i].Name; i++)
X	    if (ShowInfo[i].Type == MyInfo->Type && 
X		ShowInfo[i].GetFunc && !ShowInfo[i].Enable) {
X		ShowAll = FALSE;
X		break;
X	    }
X
X    if (MyInfo && (DoPrintAll || ShowAll || MyInfo->Enable))
X	printf("\n\n\t%s\n\n", MyInfo->Label);
X
X    /*
X     * Print each enabled item of our type
X     */
X    for (i = 0; ShowInfo[i].Name; i++)
X	if ((ShowInfo[i].Type == MyInfo->Type) &&
X	    (ShowInfo[i].Enable || MyInfo->Enable) && ShowInfo[i].GetFunc) {
X	    PrintLabel(ShowInfo[i].Label, (*ShowInfo[i].GetFunc)());
X	    ShowInfo[i].Enable = FALSE;
X	}
X
X    if (MyInfo)
X	MyInfo->Enable = FALSE;
X}
X
X/*
X * List Show values
X */
Xstatic void ListShow()
X{
X    register int		i;
X
X    printf(
X	"The following values may be specified with the \"-show\" option:\n");
X    printf("\t%-20s %s\n", "VALUE", "DESCRIPTION");
X
X    for (i = 0; ShowInfo[i].Name; i++)
X	printf("\t%-20s %s%s\n",
X	       ShowInfo[i].Name,
X	       (ShowInfo[i].ShowFunc) ? "Show all " : "",
X	       ShowInfo[i].Label
X	       );
X}
X
X/*
X * List Level values
X */
Xstatic void ListLevel()
X{
X    register int		i;
X
X    printf(
X	"The following values may be specified with the \"-level\" option:\n");
X    printf("\t%-20s\n", "VALUE");
X
X    for (i = 0; LevelNames[i].name; i++) {
X	printf("\t%s\n", LevelNames[i].name);
X    }
X}
X
X/*
X * List list values
X */
Xstatic void ListList()
X{
X    register int		i;
X
X    printf(
X	"The following values may be specified with the \"-list\" option:\n");
X    printf("\t%-20s %s\n", "VALUE", "DESCRIPTION");
X
X    for (i = 0; ListTab[i].Name; i++) {
X	printf("\t%-20s %s\n",
X	       ListTab[i].Name,
X	       ListTab[i].Desc
X	       );
X    }
X}
X
X/*
X * List information about each word found in Str.
X */
Xstatic void List(Str)
X    char		       *Str;
X{
X    register int		i;
X    char		       *Word;
X    int				Found;
X
X    if (EQ(Str, "-")) {
X	ListList();
X	return;
X    }
X
X    for (Word = strtok(Str, ","); Word; Word = strtok((char *)NULL, ",")) {
X	for (i = 0, Found = FALSE; ListTab[i].Name && !Found; i++)
X	    if (EQ(Word, ListTab[i].Name)) {
X		Found = TRUE;
X		(*ListTab[i].Func)();
X	    }
X
X	if (!Found) {
X	    Error("The word \"%s\" is invalid.", Word);
X	    ListList();
X	    return;
X	}
X    }
X}
X
X/*
X * Get argument number "arg" from "str".
X */
Xstatic char *GetArg(Str, ArgNum)
X    char 		       *Str;
X    int 			ArgNum;
X{
X    register char 	       *p, *start;
X    register int 		c;
X
X    for (c = 1, p = Str; p && *p; ++c) {
X	/* set start of word */
X	start = p; 
X
X	/* skip over word */
X	while (p && *p && *p != ' ' && *p != '\t' && *p != '\n')
X	    ++p;
X
X	/* is this what we want? */
X	if (c == ArgNum) {
X	    if (p) *p = C_NULL;
X	    break;
X	}
X
X	/* skip white space */
X	while (*p == ' ' || *p == '\t')
X	    ++p;
X    }
X
X    return(start);
X}
X
X/*
X * Convert integer to ASCII
X */
Xchar *itoa(Num)
X    int 			Num;
X{
X    static char 		Buf[BUFSIZ];
X
X    (void) sprintf(Buf, "%d", Num);
X
X    return(Buf);
X}
X
X/*
X * Get kernel version string
X */
Xextern char *GetKernelVersion()
X{
X    static char		       *Ptr = NULL;
X    char		       *GetKernelVersionStr();
X
X    /*
X     * See if we already know the answer
X     */
X    if (Ptr)
X	return(Ptr);
X
X    return(Ptr = GetKernelVersionStr());
X}
X
X#if	defined(HAVE_UNAME)
X/*
X * Get name of OS using uname()
X */
Xextern char *GetOSNameFromUname()
X{
X    static struct utsname 	un;
X
X    if (uname(&un) != 0)
X	return((char *) NULL);
X    else
X	return(un.sysname);
X}
X#endif	/* HAVE_UNAME */
X
X/*
X * Get Operating System name.
X */
Xextern char *GetOSName()
X{
X#if	defined(OS_NAME)
X    return(OS_NAME);
X#else
X    return(GetOSNameStr());
X#endif	/* OS_NAME */
X}
X
X#if	defined(HAVE_UNAME)
X/*
X * Get OS version number using uname()
X */
Xextern char *GetOSVersionFromUname()
X{
X    static char			Buf[BUFSIZ];
X    struct utsname 		un;
X
X    if (uname(&un) != 0) {
X	return((char *) NULL);
X    }
X
X    /*
X     * Vendors don't all do the same thing for storing
X     * version numbers via uname().
X     */
X#if	defined(UNAME_REL_VER_COMB)
X    (void) sprintf(Buf, "%s.%s", un.version, un.release);
X#else
X    (void) sprintf(Buf, "%s", un.release);
X#endif 	/* UNAME_REL_VER_COMB */
X
X    return(Buf);
X}
X#endif	/* HAVE_UNAME */
X
X#if	defined(OSVERS_FROM_KERNVER)
X/*
X * Get OS version by reading an a specific argument out of
X * the kernel version string.
X */
Xextern char *GetOSVersionFromKernVer()
X{
X    static char			Buf[BUFSIZ];
X    register char	       *p;
X
X    if (!(p = GetKernelVersion()))
X	return((char *) NULL);
X
X    (void) strcpy(Buf, p);
X    p = GetArg(Buf, OSVERS_FROM_KERNVER);
X    (void) strcpy(Buf, p);
X    if ((p = index(Buf, ':')) != NULL)
X	*p = C_NULL;
X
X    return(Buf);
X}
X#endif	/* OSVERS_FROM_KERNVER */
X
X/*
X * Get Operating System version
X */
Xextern char *GetOSVersion()
X{
X#if	defined(OS_VERSION)
X    return(OS_VERSION);
X#else
X    char 		       *Str;
X    char 		       *p;
X
X    if (!(Str = GetOSVersionStr()))
X	return(Str);
X
X    /*
X     * Zap "*-PL*".
X     */
X    if (*Str && 
X	((p = rindex(Str, '-')) != NULL) && (strncmp(p, "-PL", 3) == 0))
X	*p = C_NULL;
X
X    return(Str);
X#endif	/* !OS_VERSION */
X}
X
X/*
X * Get our hostname
X */
Xextern char *GetHostName()
X{
X    static char 		Buf[MAXHOSTNAMLEN+1];
X
X    gethostname(Buf, sizeof(Buf));
X
X    return((Buf[0]) ? Buf : (char *) NULL);
X}
X
X/*
X * Get aliases for this hostname
X */
Xextern char *GetHostAliases()
X{
X    static char 		Buf[BUFSIZ];
X    struct hostent 	       *hp;
X    register char	      **pp;
X    char 		       *HName;
X
X    if ((HName = GetHostName()) == NULL)
X	return((char *) NULL);
X
X    if ((hp = gethostbyname(HName)) == NULL) {
X	Error("Cannot find lookup host info for \"%s\": %s", HName, SYSERR);
X	return((char *) NULL);
X    }
X
X    for (pp = hp->h_aliases, Buf[0] = C_NULL; pp && *pp; ++pp) {
X	(void) strcat(Buf, *pp);
X	(void) strcat(Buf, " ");
X    }
X
X    return((Buf[0]) ? Buf : (char *) NULL);
X}
X
X/*
X * Get addresses for this host
X */
Xextern char *GetHostAddrs()
X{
X    static char 		Buf[BUFSIZ];
X    struct hostent 	       *hp;
X    register char	      **pp;
X    char 		       *HName;
X
X    if ((HName = GetHostName()) == NULL)
X	return((char *) NULL);
X
X    if ((hp = gethostbyname(HName)) == NULL) {
X	Error("Cannot find lookup host info for \"%s\": %s", HName, SYSERR);
X	return((char *) NULL);
X    }
X
X    for (pp = hp->h_addr_list, Buf[0] = C_NULL; pp && *pp; ++pp) {
X	if (hp->h_addrtype == AF_INET) {
X	    (void) strcat(Buf, (char *) inet_ntoa(*(struct in_addr *)*pp));
X	    (void) strcat(Buf, " ");
X	}
X    }
X
X    return((Buf[0]) ? Buf : (char *) NULL);
X}
X
X/*
X * Get system model
X */
Xextern char *GetModel()
X{
X    int 			Len;
X    FILE 		       *fd;
X    char 			Buf[BUFSIZ];
X    char		       *GetModelName();
X#if	defined(MODEL_COMMAND)
X    extern char 	       *ModelCommand[];
X#endif	/* MODEL_COMMAND */
X
X    /*
X     * Use model file if it exists.
X     */
X    if ((fd = fopen(MODELFILE, "r")) != NULL) {
X	fgets(Buf, sizeof(Buf), fd);
X	Len = strlen(Buf);
X	if (Buf[Len-1] == '\n') 
X	    Buf[Len-1] = C_NULL;
X	return(Buf);
X    }
X
X    /*
X     * If a command to get model name has been defined, try it.
X     */
X#if	defined(MODEL_COMMAND)
X    if (p = RunCmds(ModelCommand))
X	return(p);
X#endif	/* MODEL_COMMAND */
X
X    /*
X     * Use a method specific to this OS
X     */
X    return(GetModelName());
X}
X
X/*
X * Get the short manufacturer name
X */
Xstatic char *GetManShort()
X{
X    return(MAN_SHORT);
X}
X
X/*
X * Get the long manufacturer name
X */
Xstatic char *GetManLong()
X{
X    return(MAN_LONG);
X}
X
X/*
X * Get the manufacturer info.
X */
Xextern char *GetMan()
X{
X    char 		       *ms, *ml;
X    static char 		Buf[BUFSIZ];
X
X    ms = GetManShort();
X    ml = GetManLong();
X
X    if (!Terse)
X	(void) sprintf(Buf, "%s (%s)", ms, ml);
X    else
X	(void) sprintf(Buf, "%s", ms);
X
X    return(Buf);
X}
X
X/*
X * Get application architecture.
X */
Xextern char *GetAppArch()
X{
X    char 		       *arch = NULL;
X
X#if	defined(ARCH_TYPE)
X    /*
X     * Use predefined name if present.
X     */
X    if (!arch)
X	return(ARCH_TYPE);
X#endif	/* ARCH_TYPE */
X
X#if	defined(HAVE_AARCHNAME)
X    /*
X     * Use OS specific method
X     */
X    if (arch = (char *) GetAppArchName())
X	return(arch);
X#endif	/* HAVE_AARCHNAME */
X
X    /*
X     * Try running App Arch commands
X     */
X    if (arch = RunCmds(AppArchCmds))
X	return(arch);
X
X    /*
X     * Try testing Architecture files
X     */
X    if (arch = RunTestFiles(ArchFiles))
X	return(arch);
X
X    return(arch);
X}
X
X/*
X * Get kernel architecture
X */
Xextern char *GetKernArch()
X{
X    char 		       *arch = NULL;
X
X#if	defined(KARCH_TYPE)
X    /*
X     * If there's a predefined KArch name, use it.
X     */
X    if (!arch)
X	return(KARCH_TYPE);
X#endif	/* KARCH_TYPE */
X
X#if	defined(HAVE_KARCHNAME)
X    /*
X     * Try OS specific method
X     */
X    if (arch = GetKernArchName())
X	return(arch);
X#endif	/* HAVE_KARCHNAME */
X
X    /*
X     * Try running the KArch test commands
X     */
X    if (arch = RunCmds(KernArchCmds))
X	return(arch);
X
X    /*
X     * We're desperate, so try using the Application Architecture
X     */
X    if (arch = GetAppArch())
X	return(arch);
X
X    return((char *) NULL);
X}
X
X/*
X * Get host ID
X */
Xextern char *GetHostID()
X{
X    static char 		Buf[100];
X
X    (void) sprintf(Buf, "%08x", gethostid());
X
X    return(Buf);
X}
X
X/*
X * Get system serial number
X */
Xextern char *GetSerialNo()
X{
X    return(GetSerialNoStr());
X}
X
X/*
X * Get CPU type
X */
Xextern char *GetCPU()
X{
X    char 		       *cpu = NULL;
X
X#if	defined(CPU_NAME)
X    cpu = CPU_NAME;
X#else
X#if	defined(HAVE_HOST_INFO)
X    /*
X     * Try the Mach method.
X     * This should be in os-mach.c, but this is the only
X     * OS specific case so far.
X     */
X    cpu = (char *) GetCpuTypeFromHostInfo();
X#endif 	/* HAVE_HOST_INFO */
X#endif 	/* CPU_NAME */
X
X    if (!cpu) {
X	cpu = RunTestFiles(CPUFiles);
X
X	/*
X	 * If that didn't work, try the architecture commands.
X	 */
X	if (!cpu)
X	    cpu = RunCmds(AppArchCmds);
X    }
X
X    return(cpu);
X}
X
X/*
X * Print error message
X */
X#if	defined(HAVE_VARARGS)
X#include <varargs.h>
X/*
X * Varargs version of Error()
X */
Xextern void Error(va_alist)
X    va_dcl
X{
X    va_list 			args;
X    char 		       *fmt;
X    extern char 	       *ProgramName;
X
X    (void) fprintf(stderr, "%s: ", ProgramName);
X    va_start(args);
X    fmt = (char *) va_arg(args, char *);
X    (void) vfprintf(stderr, fmt, args);
X    va_end(args);
X    (void) fprintf(stderr, "\n");
X}
X#else
X/*
X * Non-Varargs version of Error()
X */
Xextern void Error(fmt, a1, a2, a3, a4, a5, a6)
X    char 		       *fmt;
X{
X    extern char 	       *ProgramName;
X
X    (void) fprintf(stderr, "%s: ", ProgramName);
X    (void) fprintf(stderr, fmt, a1, a2, a3, a4, a5, a6);
X    (void) fprintf(stderr, "\n");
X}
X#endif 	/* !HAVE_VARARGS */
X
X/*
X * Parse and set the level keyword list
X */
Xstatic int ParseLevel(Str)
X    char		       *Str;
X{
X    register int		i;
X    char		       *Word;
X    int				Found;
X
X    /*
X     * Check each word in the LevelNames table
X     */
X    for (Word = strtok(Str, ","); Word; Word = strtok((char *)NULL, ",")) {
X	for (i = 0, Found = FALSE; LevelNames[i].name && !Found; i++) {
X	    if (strncasecmp(Word, LevelNames[i].name, strlen(Word)) == 0) {
X		Level |= LevelNames[i].value;
X		Found = TRUE;
X	    }
X	}
X	if (!Found) {
X	    Error("The word \"%s\" is not a valid verbosity level.", Word);
X	    return(-1);
X	}
X    }
X
X    return(0);
X}
X
X/*
X * Parse and set the showinfo items
X */
Xstatic int ParseShow(Str)
X    char		       *Str;
X{
X    register int		x;
X    char		       *Word;
X    int				Found;
X
X    /*
X     * Check each word.
X     */
X    for (Word = strtok(Str, ","); Word; Word = strtok((char *)NULL, ",")) {
X	/*
X	 * Search the ShowInfo entries for a match.
X	 */
X	for (x = 0, Found = FALSE; !Found && ShowInfo[x].Name; x++)
X	    if (EQ(Word, ShowInfo[x].Name)) {
X		ShowInfo[x].Enable = TRUE;
X		DoPrintAll = FALSE;
X		Found = TRUE;
X	    }
X
X	if (!Found) {
X	    Error("The word \"%s\" is not valid.", Word);
X	    ListShow();
X	    return(-1);
X	}
X    }
X
X    return(0);
X}
X
X/*
X * Front end to calloc()
X */
Xchar *xcalloc(nele, esize)
X    int 			nele;
X    int 			esize;
X{
X    char 		       *p, *calloc();
X
X    if ((p = calloc(nele, esize)) == NULL) {
X	Error("calloc(%d, %d) failed.", nele, esize);
X	return((char *) NULL);
X    }
X
X    return(p);
X}
X
X#if	defined(OPTION_COMPAT)
X/*
X * Set option compatibility
X */
Xstatic void SetOptionCompat()
X{
X    register int		i;
X
X    /*
X     * For every OptCompat that's TRUE, enable the real value
X     */
X    for (i = 0; ShowInfo[i].Name; i++) 
X	if (ShowInfo[i].OptCompat && *ShowInfo[i].OptCompat) {
X	    ShowInfo[i].Enable = TRUE;
X	    /*
X	     * These is also part of the old behavior
X	     */
X	    DoPrintAll = FALSE;
X	    Terse = TRUE;
X	}
X
X}
X#endif	/* OPTION_COMPAT */
X
X/*
X * The beginning
X */
Xmain(Argc, Argv)
X    int 			Argc;
X    char 		      **Argv;
X{
X    register int		i;
X
X    if (ParseOptions(Opts, Num_Opts(Opts), Argc, Argv) < 0) {
X	    exit(1);
X    }
X
X    /*
X     * Show version info
X     */
X    if (DoPrintVersion) {
X	printf("Sysinfo version %s.%d\n", VERSION_STR, PATCHLEVEL);
X	exit(0);
X    }
X 
X    /*
X     * Do any list commands and exit
X     */
X    if (ListStr) {
X	List(ListStr);
X	exit(0);
X    }
X
X#if	defined(OPTION_COMPAT)
X    SetOptionCompat();
X#endif
X
X    /*
X     * Set verbosity strings
X     */
X    if (LevelStr && ParseLevel(LevelStr))
X	exit(1);
X
X    if (ShowStr && ParseShow(ShowStr))
X	exit(1);
X
X    /*
X     * Run down the main topics
X     */
X    for (i = 0; ShowInfo[i].Name; i++) {
X	if (!(DoPrintAll || ShowInfo[i].Enable))
X	    continue;
X
X	if (ShowInfo[i].ShowFunc) {
X	    /*
X	     * The item has a show function
X	     */
X	    (*ShowInfo[i].ShowFunc)(&ShowInfo[i], NULL);
X	} else {
X	    register int	x;
X	    int			Found;
X
X	    /*
X	     * Search for and call a search function for this type of item
X	     */
X	    for (x = 0, Found = FALSE; !Found && ShowInfo[x].Name; x++)
X		if ((ShowInfo[x].Type == ShowInfo[i].Type) &&
X		    ShowInfo[x].ShowFunc) {
X		    Found = TRUE;
X		    (*ShowInfo[x].ShowFunc)(&ShowInfo[x], &ShowInfo[i]);
X		}
X	    if (!Found) {
X		Error("No show function exists for \"%s\".", 
X		      ShowInfo[i].Name);
X		exit(1);
X	    }
X	}
X    }
X
X    exit(0);
X}
END_OF_sysinfo.c
if test 26266 -ne `wc -c <sysinfo.c`; then
    echo shar: \"sysinfo.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f devices.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"devices.c\"
else
echo shar: Extracting \"devices.c\" \(22686 characters\)
sed "s/^X//" >devices.c <<'END_OF_devices.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/devices.c,v 1.18 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: devices.c,v $
X * Revision 1.18  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.17  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.16  1992/04/16  02:25:39  mcooper
X * Bug fixes, de-linting, and other changes found with CodeCenter.
X *
X * Revision 1.15  1992/04/15  02:41:37  mcooper
X * Change AddDevice() to check to make sure device doesn't already exist.
X *
X * Revision 1.14  1992/04/12  22:01:11  mcooper
X * Remove kludge for "id".
X *
X * Revision 1.12  1992/03/22  02:03:31  mcooper
X * Call BuildDevicesNeXT().
X *
X * Revision 1.11  1992/03/22  00:20:10  mcooper
X * Major cleanup and re-org.
X *
X * Revision 1.10  1992/03/09  01:25:24  mcooper
X * Print device description on first line if no other info is available.
X *
X * Revision 1.9  1992/03/08  04:57:36  mcooper
X * - Add support for multiple address per netif.
X * - Move probe_generic() here for os-sunos.c.
X *
X * Revision 1.8  1992/03/06  18:36:55  mcooper
X * Move some general functions here from sunos.c.
X *
X * Revision 1.7  1992/03/05  22:36:35  mcooper
X * Cleanup format.
X *
X * Revision 1.6  1992/03/01  21:30:37  mcooper
X * Use dd_secsize from DISKDRIVE instead of SECSIZE macro.
X *
X * Revision 1.5  1992/02/25  00:16:14  mcooper
X * - Major cleanup of printing.
X * - Init new device int's to -1.
X * - Add new device type's.
X *
X * Revision 1.4  1992/02/22  02:20:19  mcooper
X * Major changes to support scanning kernel mainbus and
X * openprom data for device's.
X *
X * Revision 1.3  1992/02/16  23:50:47  mcooper
X * Cleanup newline printing and add verbosity level checking.
X *
X * Revision 1.2  1992/02/16  22:46:03  mcooper
X * Add network interface support.
X *
X * Revision 1.1  1991/11/30  23:28:53  mcooper
X * Initial revision
X *
X */
X
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X#define OFFSET 4
X
Xstatic void PrintDiskdrive();
Xstatic void PrintFrameBuffer();
Xstatic void PrintNetIf();
Xstatic void PrintDevice();
Xstatic void PrintGeneric();
X
Xstruct devicetype {
X    int				 dt_dtype;	/* Device type */
X    char			*dt_desc;	/* Description */
X    void		       (*dt_prfunc)();	/* Print function */
X};
Xtypedef struct devicetype DEVTYPE;
X
XDEVTYPE DevTypes[] = {
X    { DT_GENERIC,	NULL,			PrintGeneric },
X    { DT_DISKDRIVE,	"disk drive",		PrintDiskdrive },
X    { DT_DISKCTLR,	"disk controller",	PrintGeneric },
X    { DT_TAPEDRIVE,	"tape drive",		PrintGeneric },
X    { DT_TAPECTLR,	"tape controller",	PrintGeneric },
X    { DT_FRAMEBUFFER,	"frame buffer",		PrintFrameBuffer },
X    { DT_NETIF,		"network interface",	PrintNetIf },
X    { DT_BUS,		"system bus",		PrintGeneric },
X    { DT_PSEUDO,	"pseudo device",	PrintGeneric },
X    { 0 },
X};
X
Xstatic float 			TotalDisk = 0;
X
X/*
X * Get a device type.
X */
Xstatic DEVTYPE *GetDevType(Device)
X    DEVICE 		       *Device;
X{
X    register int 		i;
X
X    if (!Device)
X	return((DEVTYPE *) NULL);
X
X    for (i = 0; DevTypes[i].dt_prfunc; ++i)
X	if (DevTypes[i].dt_dtype == Device->dv_type)
X	    return(&DevTypes[i]);
X
X    return((DEVTYPE *) NULL);
X}
X
X/*
X * Print all device info
X */
Xextern void ShowDevices(MyInfo, SpecInfo)
X    SHOWINFO		       *MyInfo;
X    SHOWINFO		       *SpecInfo;	/* ARGSUSED */
X{
X    static DEVICE 	       *RootDev;
X
X#if	defined(sun)
X    if (BuildDevicesSunOS(&RootDev) != 0)
X	return;
X#endif	/* sun */
X
X#if	defined(ultrix)
X    if (BuildDevicesUltrix(&RootDev) != 0)
X	return;
X#endif	/* ultrix */
X
X#if	defined(NeXT)
X    if (BuildDevicesNeXT(&RootDev) != 0)
X	return;
X#endif	/* NeXT */
X
X    if (!RootDev) {
X	if (Debug)
X	    printf("No devices were found.\n");
X	return;
X    }
X
X    printf("\n\n\t%s\n\n", MyInfo->Label);
X
X    TotalDisk = 0;
X
X    PrintDevice(RootDev, 0);
X
X    if (VL_DESC && TotalDisk > 0)
X	printf("\nTotal Disk Capacity is %.2f MB.\n", 
X	       (float) bytes_to_mbytes(TotalDisk));
X}
X
X/*
X * --RECURSE--
X * Print info about a device.  Recursively calls itself for slaves and
X * next elements
X */
Xstatic void PrintDevice(Device, OffSet)
X    DEVICE 		       *Device;
X    int 			OffSet;
X{
X    DEVTYPE 		       *DevType;
X
X    /*
X     * If device->dv_name is not set, this is the root of the device tree
X     */
X
X    if (Device->dv_name) {
X	if (DevType = GetDevType(Device))
X	    (*DevType->dt_prfunc)(Device, DevType, OffSet);
X	else
X	    PrintGeneric(Device, DevType, OffSet);
X    }
X
X    /*
X     * Descend
X     */
X    if (Device->dv_slaves)
X	PrintDevice(Device->dv_slaves, (Device->dv_name) ? OffSet+OFFSET : 0);
X
X    /*
X     * Traverse
X     */
X    if (Device->dv_nxt)
X	PrintDevice(Device->dv_nxt, (Device->dv_name) ? OffSet : 0);
X}
X
X/*
X * Print Off Set space
X */
Xstatic void PrOffSet(cnt)
X    int 			cnt;
X{
X    printf("%*s", cnt, "");
X}
X
X/*
X * Print a device label
X */
Xstatic void PrDevLabel(Name, OffSet)
X    char 		       *Name;
X    int 			OffSet;
X{
X    PrOffSet(OffSet);
X    if (VL_CONFIG)
X	printf("%*s%-18s:", OFFSET, "", Name);
X    else
X	printf("%*s%18s:", OFFSET, "", Name);
X}
X
X/*
X * Print general device information
X */
Xstatic void PrintDeviceInfo(Device, DevType, OffSet)
X    DEVICE 		       *Device;
X    DEVTYPE 		       *DevType;
X    int 			OffSet;
X{     
X    DEVTYPE 		       *mdt;
X
X    if (!Device->dv_name)
X	return;
X
X    if (VL_CONFIG) printf("\n");
X    PrOffSet(OffSet);
X    printf("Device %s", Device->dv_name);
X
X    if (Device->dv_model || (DevType && DevType->dt_desc)) {
X	printf(" is a");
X	if (Device->dv_model)
X	    printf(" \"%s\"", Device->dv_model);
X
X	if (DevType && DevType->dt_desc)
X	    printf(" %s", DevType->dt_desc);
X    } else if (Device->dv_desc) {
X	printf(" is a");
X	printf(" %s", Device->dv_desc);
X    }
X
X    if (Device->dv_name)
X	printf(".\n");
X
X    if (VL_DESC || VL_CONFIG) {
X	if (Device->dv_desc) {
X	    PrDevLabel("Description", OffSet);
X	    printf(" %s\n", Device->dv_desc);
X	} else if ((mdt = GetDevType(Device)) && mdt && mdt->dt_desc) {
X	    PrDevLabel("Description", OffSet);
X	    printf(" %s\n", mdt->dt_desc);
X	}
X
X	if (Device->dv_master && Device->dv_master->dv_name) {
X	    PrDevLabel("Description", OffSet);
X	    if (Device->dv_master->dv_name)
X		printf(" Connected to %s", Device->dv_master->dv_name);
X	    else if (Device->dv_master->dv_model) {
X		printf(" Connected to %s", Device->dv_master->dv_model);
X		if (mdt = GetDevType(Device->dv_master))
X		    printf(" %s", mdt->dt_desc);
X	    }
X	    printf("\n");
X	}
X    }
X}
X
X/*
X * Print info about a generic device
X */
Xstatic void PrintGeneric(Device, DevType, OffSet)
X    DEVICE 		       *Device;
X    DEVTYPE 		       *DevType;
X    int 			OffSet;
X{
X    register DEVICE 	       *pd;
X
X    PrintDeviceInfo(Device, DevType, OffSet);
X
X    if (VL_CONFIG) {
X	if (Device->dv_unit >= 0 || Device->dv_addr >= 0 || 
X	    Device->dv_prio >= 0 || Device->dv_vec >= 0) {
X	    PrDevLabel("Configuration", OffSet);
X	    if (Device->dv_unit >= 0)
X		printf(" Unit %d", Device->dv_unit);
X	    if (Device->dv_addr >= 0)
X		printf(" Address 0x%x", Device->dv_addr);
X	    if (Device->dv_prio >= 0)
X		printf(" Priority %d", Device->dv_prio);
X	    if (Device->dv_vec >= 0)
X		printf(" Vector %d", Device->dv_vec);
X	    printf("\n");
X	}
X    }
X
X    if (VL_CONFIG) {
X	if (Device->dv_slaves && (Device->dv_name || Device->dv_model || 
X				  (DevType && DevType->dt_desc))) {
X	    PrDevLabel("Attached Device(s)", OffSet);
X	    for (pd = Device->dv_slaves; pd; pd = pd->dv_nxt)
X		printf(" %s", pd->dv_name);
X	    printf("\n");
X	}
X    }
X}
X
X/*
X * Print info about disk partitioning.
X */
Xstatic void PrintDiskPart(Disk, OffSet)
X    DISKDRIVE 		       *Disk;
X    int 			OffSet;
X{
X    register DISKPART 	       *pp;
X
X    printf("\n");
X    PrOffSet(OffSet);
X    printf("%50s\n", "Partition Information");
X
X    PrOffSet(OffSet);
X    printf("%20s %10s %10s %9s\n",
X	   "", "START", "NUMBER OF", "SIZE");
X
X    PrOffSet(OffSet);
X    printf("%20s %10s %10s %9s %s\n",
X	   "PART", "SECTOR", "SECTORS", "(MB)", "USAGE");
X
X    for (pp = Disk->dd_part; pp; pp = pp->dp_nxt) {
X	PrOffSet(OffSet);
X	printf("%20s %10d %10d %9.2f %s\n",
X	       pp->dp_name,
X	       pp->dp_stsect,
X	       pp->dp_nsect,
X	       bytes_to_mbytes(nsect_to_bytes(pp->dp_nsect, Disk->dd_secsize)),
X	       (pp->dp_mnt) ? pp->dp_mnt : ""
X	       );
X    }
X}
X
X/*
X * Print info about a disk device.
X */
Xstatic void PrintDiskdrive(Device, DevType, OffSet)
X    DEVICE 		       *Device;
X    DEVTYPE 		       *DevType;
X    int 			OffSet;
X{
X    DISKDRIVE 		       *Disk;
X
X    PrintDeviceInfo(Device, DevType, OffSet);
X
X    if (!Device->dv_devspec)
X	return;
X
X    Disk = (DISKDRIVE *) Device->dv_devspec;
X
X    TotalDisk += (float) Disk->dd_size;
X
X    if (VL_CONFIG) {
X	PrDevLabel("Configuration", OffSet);
X	if (FLAGS_ON(Disk->dd_flags, DF_HEXUNIT))
X	    printf(" Unit %3.3x", Disk->dd_unit);
X	else
X	    printf(" Unit %3d", Disk->dd_unit);
X
X	printf("  Slave %2d  RPM %d  APC %d  Interleave %d\n", 
X	       Disk->dd_slave, Disk->dd_rpm, Disk->dd_apc, Disk->dd_intrlv);
X
X	PrDevLabel("Configuration", OffSet);
X	printf(" %4d Physical Cylinders  %2d Alternate Cylinders\n", 
X	       Disk->dd_pcyl, Disk->dd_acyl);
X
X	PrDevLabel("Geometry", OffSet);
X	printf(" %4d Data Cylinders      %2d Heads  %3d Sectors/Track\n",
X	       Disk->dd_dcyl, Disk->dd_heads, Disk->dd_sect);
X
X	if (Disk->dd_psect || Disk->dd_promrev) {
X	    PrDevLabel("Hardware Info", OffSet);
X	    printf(" %4d Hard Sectors  PROM Revision %d\n",
X		   Disk->dd_psect, Disk->dd_promrev);
X	}
X    }
X
X    if (VL_ALL && Disk->dd_part)
X	PrintDiskPart(Disk, OffSet);
X}
X
X/*
X * Print info about a frame buffer.
X */
Xstatic void PrintFrameBuffer(Device, DevType, OffSet)
X    DEVICE 		       *Device;
X    DEVTYPE 		       *DevType;
X    int 			OffSet;
X{
X    FRAMEBUFFER 	       *fb;
X
X    PrintDeviceInfo(Device, DevType, OffSet);
X
X    if (!Device->dv_devspec)
X	return;
X
X    fb = (FRAMEBUFFER *) Device->dv_devspec;
X
X    if (VL_CONFIG) {
X	PrDevLabel("Screen Size", OffSet);
X	printf(" %d KB  Height %d  Width %d  Depth %d-bit%s\n",
X	       bytes_to_kbytes(fb->fb_size),
X	       fb->fb_height, fb->fb_width, fb->fb_depth,
X	       (fb->fb_depth == 1) ? "" : "s");
X
X	if (fb->fb_vmsize || fb->fb_cmsize) {
X	    PrDevLabel("Configuration", OffSet);
X	    if (fb->fb_vmsize)
X		printf(" Video Memory %d KB ", bytes_to_kbytes(fb->fb_vmsize));
X	    if (fb->fb_cmsize)
X		printf(" Color Map Size is %d", fb->fb_cmsize);
X	    printf("\n");
X	}
X    }
X}
X
X/*
X * Print info about a network interface
X */
Xstatic void PrintNetIf(Device, DevType, OffSet)
X    DEVICE 		       *Device;
X    DEVTYPE 		       *DevType;
X    int 			OffSet;
X{
X    register NETIF	       *ni;
X
X    PrintDeviceInfo(Device, DevType, OffSet);
X
X    if (!Device->dv_devspec)
X	return;
X
X    if (VL_CONFIG) {
X	for (ni = (NETIF *) Device->dv_devspec; ni; ni = ni->ni_nxt) {
X	    if (ni->ni_typename) {
X		printf("\n");
X		PrDevLabel("Address Type", OffSet);
X		printf(" %s\n", ni->ni_typename);
X	    }
X
X	    if (ni->ni_hostaddr) {
X		PrDevLabel("Host Address", OffSet);
X		printf(" %-18s [%s]\n", ni->ni_hostaddr,
X		       (ni->ni_hostname) ? ni->ni_hostname : "<unknown>");
X	    }
X
X	    if (ni->ni_netaddr) {
X		PrDevLabel("Network Address", OffSet);
X		printf(" %-18s [%s]\n", ni->ni_netaddr, 
X		       (ni->ni_netname) ? ni->ni_netname : "<unknown>");
X	    }
X
X	    if (ni->ni_macaddr) {
X		PrDevLabel("MAC Address", OffSet);
X		printf(" %-18s [%s]\n", ni->ni_macaddr,
X		       (ni->ni_macname && ni->ni_macname[0]) 
X		       ? ni->ni_macname : "<unknown>");
X	    }
X	}
X    }
X}
X
X/*
X * --RECURSE--
X * Create a new DEVICE and optionally copy an old DEVICE.
X */
Xextern DEVICE *NewDevice(Old)
X    DEVICE 		       *Old;
X{
X    register DEVICE 	       *SlavePtr, *Slave;
X    DEVICE 		       *New = NULL;
X
X    New = (DEVICE *) xcalloc(1, sizeof(DEVICE));
X
X    /* Set int's to -1 */
X    New->dv_type = New->dv_unit = New->dv_addr = New->dv_prio = 
X	New->dv_vec = -1;
X
X    if (!Old)
X	return(New);
X
X    /* Bulk copy what we can */
X    bcopy((char *) Old, (char *) New, sizeof(DEVICE));
X
X    New->dv_nxt = NULL;
X
X    /* Copy contents of pointers */
X    if (Old->dv_name)	New->dv_name = strdup(Old->dv_name);
X    if (Old->dv_model)	New->dv_model = strdup(Old->dv_model);
X    if (Old->dv_desc)	New->dv_desc = strdup(Old->dv_desc);
X
X    /* Copy Slave info */
X    for (Slave = Old->dv_slaves; Slave; Slave = Slave->dv_nxt) {
X	/* Find last slave */
X	for (SlavePtr = New->dv_slaves; SlavePtr && SlavePtr->dv_nxt; 
X	     SlavePtr = SlavePtr->dv_nxt);
X	/* Copy Old slave to last new slave device */
X	SlavePtr = NewDevice(Slave);
X    }
X
X    return(New);
X}
X
X/*
X * Create a new DISKPART and optionally copy an old DISKPART.
X */
Xextern DISKPART *NewDiskPart(Old)
X    DISKPART 		       *Old;
X{
X    DISKPART 		       *New = NULL;
X
X    New = (DISKPART *) xcalloc(1, sizeof(DISKPART));
X
X    if (!Old)
X	return(New);
X
X    /* Bulk copy what we can */
X    bcopy((char *) Old, (char *) New, sizeof(DISKPART));
X
X    New->dp_nxt = NULL;
X
X    /* Copy contents of pointers */
X    if (Old->dp_name)	New->dp_name = strdup(Old->dp_name);
X    if (Old->dp_mnt)	New->dp_mnt = strdup(Old->dp_mnt);
X
X    return(New);
X}
X
X/*
X * --RECURSE--
X * Create a new DISKDRIVE and optionally copy an old DISKDRIVE.
X */
Xextern DISKDRIVE *NewDiskDrive(Old)
X    DISKDRIVE 		       *Old;
X{
X    register DISKPART 	       *dp, *pdp;
X    DISKDRIVE 		       *New = NULL;
X
X    New = (DISKDRIVE *) xcalloc(1, sizeof(DISKDRIVE));
X
X    if (!Old)
X	return(New);
X
X    /* Bulk copy what we can */
X    bcopy((char *) Old, (char *) New, sizeof(DISKDRIVE));
X
X    New->dd_nxt = NULL;
X
X    /* Copy contents of pointers */
X    if (Old->dd_label)	New->dd_label = strdup(Old->dd_label);
X    if (Old->dd_ctlr) 	New->dd_ctlr = NewDevice(Old->dd_ctlr);
X
X    /* Copy partition info */
X    for (dp = Old->dd_part; dp; dp = dp->dp_nxt) {
X	/* Find last DISKPART */
X	for (pdp = New->dd_part; pdp && pdp->dp_nxt; pdp = pdp->dp_nxt);
X	/* Copy old DISKPART to last New DISKPART */
X	pdp = NewDiskPart(dp);
X    }
X
X    return(New);
X}
X
X/*
X * Create a new FRAMEBUFFER and optionally copy an old FRAMEBUFFER.
X */
Xextern FRAMEBUFFER *NewFrameBuffer(Old)
X    FRAMEBUFFER 	       *Old;
X{
X    FRAMEBUFFER 	       *New = NULL;
X
X    New = (FRAMEBUFFER *) xcalloc(1, sizeof(FRAMEBUFFER));
X
X    if (!Old)
X	return(New);
X
X    /* Bulk copy what we can */
X    bcopy((char *) Old, (char *) New, sizeof(FRAMEBUFFER));
X
X    return(New);
X}
X
X/*
X * Create a new NETIF and optionally copy an old NETIF.
X */
Xextern NETIF *NewNetif(Old)
X    NETIF 		       *Old;
X{
X    NETIF 		       *New = NULL;
X
X    New = (NETIF *) xcalloc(1, sizeof(NETIF));
X
X    if (!Old)
X	return(New);
X
X    /* Copy */
X    New->ni_hostaddr = strdup(Old->ni_hostaddr);
X    New->ni_hostname = strdup(Old->ni_hostname);
X    New->ni_macaddr = strdup(Old->ni_macaddr);
X    New->ni_macname = strdup(Old->ni_macname);
X    New->ni_netaddr = strdup(Old->ni_netaddr);
X    New->ni_netname = strdup(Old->ni_netname);
X
X    return(New);
X}
X
X/*
X * --RECURSE--
X * Find device named "name" in tree "treeptr".
X * This function recursively calls itself looking for 
X * the device "name".
X */
Xextern DEVICE *FindDeviceByName(Name, TreePtr)
X    char 		       *Name;
X    DEVICE 		       *TreePtr;
X{
X    DEVICE 		       *Ptr;
X
X    if (!Name || !TreePtr)
X	return((DEVICE *) NULL);
X
X    if (TreePtr->dv_name && Name && EQ(TreePtr->dv_name, Name))
X	return(TreePtr);
X
X    if (TreePtr->dv_slaves)
X	if (Ptr = FindDeviceByName(Name, TreePtr->dv_slaves))
X	    return(Ptr);
X
X    if (TreePtr->dv_nxt)
X	if (Ptr = FindDeviceByName(Name, TreePtr->dv_nxt))
X	    return(Ptr);
X
X    return((DEVICE *) NULL);
X}
X
X/*
X * Check to see if device's dev1 and dev2 are consistant.
X * If there is a discrepancy between the two due to one
X * device not having it's value set, then set it to the
X * other device's value.  Basically this "fills in the blanks".
X */
Xstatic void CheckDevice(Dev1, Dev2)
X     DEVICE 		       *Dev1;
X     DEVICE 		       *Dev2;
X{
X#define CHECK(a,b) \
X    if (a != b) { \
X	if (a) \
X	    b = a; \
X	else if (b) \
X	    a = b; \
X    }
X
X    CHECK(Dev1->dv_type, 	Dev2->dv_type);
X    CHECK(Dev1->dv_model, 	Dev2->dv_model);
X    CHECK(Dev1->dv_desc, 	Dev2->dv_desc);
X    CHECK(Dev1->dv_unit, 	Dev2->dv_unit);
X    CHECK(Dev1->dv_addr, 	Dev2->dv_addr);
X    CHECK(Dev1->dv_prio, 	Dev2->dv_prio);
X    CHECK(Dev1->dv_vec, 	Dev2->dv_vec);
X    CHECK(Dev1->dv_devspec, 	Dev2->dv_devspec);
X    CHECK(Dev1->dv_master, 	Dev2->dv_master);
X
X#undef CHECK
X}
X
X/*
X * --RECURSE--
X * Add a device to a device list.
X */
Xextern int AddDevice(Device, TreePtr)
X    DEVICE 		       *Device;
X    DEVICE 		      **TreePtr;
X{
X    register DEVICE 	       *master = NULL, *mp = NULL;
X
X    if (!Device || !TreePtr) {
X	Error("Invalid parameter passed to AddDevice()");
X	return(-1);
X    }
X
X    /*
X     * Make sure device hasn't already been added
X     */
X    if (FindDeviceByName(Device->dv_name, *TreePtr)) {
X	if (Debug) 
X	    printf("AddDevice: Device '%s' already exists; master = '%s'\n",
X		   Device->dv_name, (master) ? master->dv_name : "?");
X	return(-1);
X    }
X
X    if (Device->dv_name)
X	Device->dv_name = strdup(Device->dv_name);
X
X    /*
X     * If the device has a master, find the master device.
X     * If one doesn't exist in the tree, then add it by recursively
X     * calling this function.
X     */
X    if (Device->dv_master) {
X	if (*TreePtr) {
X	    master = FindDeviceByName(Device->dv_master->dv_name, *TreePtr);
X	    if (master && EQ(master->dv_name, Device->dv_master->dv_name))
X		/* Check and fix any differences in info between master's */
X		CheckDevice(master, Device->dv_master);
X	} else
X	    master = NULL;
X	if (!master) {
X	    if (AddDevice(Device->dv_master, TreePtr) != 0) {
X		Error("Cannot add master '%s' to device tree.", 
X		      master->dv_name);
X		return(-1);
X	    }
X	    master = Device->dv_master;
X	}
X    } else {
X	if (!*TreePtr)
X	    *TreePtr = NewDevice((DEVICE *)NULL);
X	master = *TreePtr;
X    }
X
X    if (master->dv_name)
X	master->dv_name = strdup(master->dv_name);
X
X    if (master->dv_slaves) {
X	/* Add to existing list of slaves */
X	for (mp = master->dv_slaves; mp && mp->dv_nxt; mp = mp->dv_nxt);
X	mp->dv_nxt = Device;
X    } else
X	/* Create first slave */
X	master->dv_slaves = Device;
X
X    return(0);
X}
X
X/*
X * Get device data tab entry for "name"
X */
Xextern DEVDATATAB *GetDevDataTab(Name)
X    char 		       *Name;
X{
X    extern DEVDATATAB 	 	DevDataTab[];
X    register int 		i;
X
X    for (i = 0; DevDataTab[i].ddt_name; ++i) {
X	if (EQN(Name, DevDataTab[i].ddt_name, 
X		strlen(DevDataTab[i].ddt_name))) {
X	    return(&DevDataTab[i]);
X	}
X    }
X
X    return((DEVDATATAB *) NULL);
X}
X
X/*
X * Create a device entry for a generic device
X */
Xextern DEVICE *ProbeGeneric(Name, DevData, DevDataTab)
X     /*ARGSUSED*/
X    char 		       *Name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB	 	       *DevDataTab;
X{
X    DEVICE		       *Device;
X
X    /*
X     * DT_GENERIC devices MUST be marked alive to proceed
X     */
X    if (DevDataTab->ddt_type == DT_GENERIC && 
X	!(FLAGS_ON(DevData->dd_flags, DD_IS_ALIVE) ||
X	  FLAGS_ON(DevData->dd_flags, DD_MAYBE_ALIVE)))
X	return((DEVICE *) NULL);
X
X    Device = NewDevice((DEVICE *) NULL);
X    if (Name)
X	Device->dv_name = strdup(Name);
X    else
X	Device->dv_name = strdup(MkDevName(DevData->dd_devname, 
X					   DevData->dd_devunit,
X					   DevDataTab->ddt_type));
X    Device->dv_type = DevDataTab->ddt_type;
X    Device->dv_model = DevDataTab->ddt_model;
X    Device->dv_desc = DevDataTab->ddt_desc;
X    Device->dv_unit = DevData->dd_devunit;
X    Device->dv_master = MkMasterFromDevData(DevData);
X
X    return(Device);
X}
X
X/*
X * Search for and call an appropriate probe function for this 
X * device
X */
Xextern DEVICE *ProbeDevice(DevData, TreePtr)
X    DEVDATA 		       *DevData;
X    DEVICE 		      **TreePtr;
X{
X    register DEVDATATAB        *pddt;
X    register char 	       *Name;
X    DEVICE 		       *ProbeUnknown();
X
X    if (pddt = GetDevDataTab(DevData->dd_devname)) {
X	Name = MkDevName(DevData->dd_devname, DevData->dd_devunit,
X			 pddt->ddt_type);
X	if (FindDeviceByName(Name, *TreePtr)) {
X	    if (Debug) printf("Device %s already exists.\n", Name);
X	    return((DEVICE *) NULL);
X	}
X	return((*pddt->ddt_probe)(Name, DevData, pddt));
X    }
X
X    /*
X     * The device is unknown to us.  If it's definetly alive,
X     * return a minimal device entry for it.  If it's not alive,
X     * ignore it.
X     */
X    if (DoPrintUnknown && DevData->dd_devname && 
X	FLAGS_ON(DevData->dd_flags, DD_IS_ALIVE))
X	return(ProbeUnknown(Name, DevData));
X
X    if (Debug)
X	printf("Device `%s' is not defined.\n", DevData->dd_devname);
X
X    return((DEVICE *) NULL);
X}
X
X
X/*
X * Make a master device from a DevData controller
X */
Xextern DEVICE *MkMasterFromDevData(DevData)
X    DEVDATA 		       *DevData;
X{
X    register DEVICE 	       *Device = NULL;
X    register DEVDATATAB        *ddt;
X    int 			type = 0;
X
X    if (DevData->dd_ctlrname) {
X	Device = NewDevice(NULL);
X	if (ddt = GetDevDataTab(DevData->dd_ctlrname)) {
X	    type = ddt->ddt_type;
X	    Device->dv_desc = ddt->ddt_desc;
X	    Device->dv_model = ddt->ddt_model;
X	}
X	Device->dv_name = MkDevName(DevData->dd_ctlrname,
X				    DevData->dd_ctlrunit, 
X				    type);
X    }
X
X    return(Device);
X}
X
X/*
X * Make the file name of the raw device
X */
Xextern char *GetRawFile(Name, Part)
X    char 		       *Name;
X    char 		       *Part;
X{
X    static char 		rfile[BUFSIZ];
X
X    if (!Name)
X	return((char *) NULL);
X
X    (void) sprintf(rfile, "/dev/r%s%s", Name, (Part) ? Part : "");
X
X    return(rfile);
X}
X
X/*
X * Make the file name of the character device
X */
Xextern char *GetCharFile(Name, Part)
X    char 		       *Name;
X    char 		       *Part;
X{
X    static char 		file[BUFSIZ];
X
X    if (!Name)
X	return((char *) NULL);
X
X    (void) sprintf(file, "/dev/%s%s", Name, (Part) ? Part : "");
X
X    return(file);
X}
X
X/*
X * Make device name
X */
Xextern char *MkDevName(Name, Unit, Type)
X    char 		       *Name;
X    int 			Unit;
X    int 			Type;
X{
X    static char			Buf[BUFSIZ];
X
X    /*
X     * Don't attach unit number if this is a pseudo device.
X     */
X    if (Type == DT_PSEUDO)
X	sprintf(Buf, "%s", Name);
X    else
X	sprintf(Buf, "%s%d", Name, Unit);
X
X    return(strdup(Buf));
X}
X
X/*
X * Create a minimal device type for an unknown device.
X */
Xextern DEVICE *ProbeUnknown(Name, DevData)
X     /*ARGSUSED*/
X    char 		       *Name;
X    DEVDATA 		       *DevData;
X{
X    DEVICE		       *Device;
X
X    Device = NewDevice((DEVICE *) NULL);
X    Device->dv_name = strdup(MkDevName(DevData->dd_devname, 
X				       DevData->dd_devunit,
X				       -1));
X    Device->dv_type = DT_GENERIC;
X    Device->dv_desc = "unknown device type";
X    Device->dv_unit = DevData->dd_devunit;
X    Device->dv_master = MkMasterFromDevData(DevData);
X
X    return(Device);
X}
END_OF_devices.c
if test 22686 -ne `wc -c <devices.c`; then
    echo shar: \"devices.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f memory.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"memory.c\"
else
echo shar: Extracting \"memory.c\" \(2645 characters\)
sed "s/^X//" >memory.c <<'END_OF_memory.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/memory.c,v 1.9 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: memory.c,v $
X * Revision 1.9  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.8  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.7  1992/04/16  02:25:39  mcooper
X * Bug fixes, de-linting, and other changes found with CodeCenter.
X *
X * Revision 1.6  1992/03/31  02:35:53  mcooper
X * Change "nl" to "PhysmemNL".
X *
X * Revision 1.5  1992/03/31  01:55:17  mcooper
X * Use new CheckNlist to check nlist success.
X *
X * Revision 1.4  1992/03/31  00:22:54  mcooper
X * Add ctob() comment.
X *
X * Revision 1.3  1992/03/31  00:15:09  mcooper
X * Add error check for nlist.n_type.
X *
X * Revision 1.2  1992/03/28  23:13:07  mcooper
X * Don't set memory if == 0.
X *
X * Revision 1.1  1992/03/22  00:20:10  mcooper
X * Initial revision
X *
X */
X
X
X/*
X * Memory related functions.
X */
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X/*
X * Divide and Round Up
X */
Xstatic int DivRndUp(Num, Div)
X    unsigned long 		Num;
X    unsigned long 		Div;
X{
X    int 			i;
X
X    i = Num / Div;
X
X    return((Num % Div) ? i+1 : i);
X}
X
X#if	defined(HAVE_KVM) && defined(HAVE_NLIST)
X
X#include <fcntl.h>
X#include <nlist.h>
X
Xstatic struct nlist PhysmemNL[] = {
X#if 		defined(COFF)
X    { "physmem" },
X#else
X    { "_physmem" },
X#endif		/* COFF */
X    { 0 },
X};
X
X/*
X * Common method of determining amount of physical memory in a
X * BSD Unix machine.
X *
X * Get memory by reading the variable "physmem" from the kernel
X * and the system page size.
X */ 
Xextern char *GetMemoryFromPhysmem()
X{
X    static char 		Buf[BUFSIZ];
X    unsigned long 		NPages, Bytes;
X    int		 		Amount = -1;
X    kvm_t		       *kd;
X
X    if (kd = KVM_open(PhysmemNL)) {
X	/*
X	 * See if we got a valid entry
X	 */
X	if (CheckNlist(&PhysmemNL[0]))
X	    return((char *) NULL);
X
X	if (KVM_read(kd, PhysmemNL[0].n_value, (char *)&NPages,
X		     sizeof(NPages)) >= 0) {
X	    /*
X	     * Could use ctob() instead of "Page Size * Num Pages",
X	     * but this is more portable.
X	     */
X	    Bytes = (long) (getpagesize() * NPages);
X	    if (Debug)
X		printf("Bytes = %d NPages = %d pagesize = %d\n", 
X		       Bytes, NPages, getpagesize());
X	    Amount = DivRndUp(Bytes, MBYTES);
X	}
X    }
X
X    if (kd)
X	KVM_close(kd);
X
X    if (Amount > 0) {
X	(void) sprintf(Buf, "%d MB", Amount);
X	return(Buf);
X    } else
X	return((char *) NULL);
X}
X#endif	/* HAVE_KVM && HAVE_NLIST */
END_OF_memory.c
if test 2645 -ne `wc -c <memory.c`; then
    echo shar: \"memory.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f kernel.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"kernel.c\"
else
echo shar: Extracting \"kernel.c\" \(2262 characters\)
sed "s/^X//" >kernel.c <<'END_OF_kernel.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/kernel.c,v 1.8 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: kernel.c,v $
X * Revision 1.8  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.7  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.6  1992/04/16  02:25:39  mcooper
X * Bug fixes, de-linting, and other changes found with CodeCenter.
X *
X * Revision 1.5  1992/03/31  02:36:06  mcooper
X * Change "nl" to "VersionNL".
X *
X * Revision 1.4  1992/03/31  01:55:17  mcooper
X * Use new CheckNlist to check nlist success.
X *
X * Revision 1.3  1992/03/31  00:15:09  mcooper
X * Add error check for nlist.n_type.
X *
X * Revision 1.2  1992/03/22  00:55:41  mcooper
X * Use new GetNlName() to get n_name out of a struct nlist.
X *
X * Revision 1.1  1992/03/22  00:20:10  mcooper
X * Initial revision
X *
X */
X
X
X/*
X * Kernel related functions.
X */
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X#if	defined(HAVE_NLIST)
X#include <fcntl.h>
X#include <nlist.h>
X
Xstruct nlist VersionNL[] = {
X#define 	N_VERSION	   0
X#if	defined(COFF)
X    { "version" },		/* 0 */
X#else
X    { "_version" },
X#endif	/* COFF */
X    { 0 },
X};
X
X#if	defined(HAVE_KVM)
X/*
X * Get kernel version string by reading the
X * symbol "version" from the kernel.
X */
Xextern char *GetKernelVersionFromVersion()
X{
X    static char			Buf[BUFSIZ];
X    register char	       *p;
X    kvm_t		       *kd;
X
X    if (kd = KVM_open(VersionNL)) {
X	/*
X	 * See if we got a valid entry
X	 */
X	if (CheckNlist(&VersionNL[N_VERSION]))
X	    return((char *) NULL);
X
X	if (KVM_read(kd, VersionNL[N_VERSION].n_value, (char *) Buf, 
X		     sizeof(Buf))) {
X	    if (Debug) Error("Read of \"%s\" from kernel failed.",
X			     GetNlName(VersionNL[N_VERSION]));
X	    Buf[0] = C_NULL;
X	}
X    }
X
X    if (kd)
X	KVM_close(kd);
X
X#if	defined(KERNSTR_END)
X    /*
X     * Truncate extraneous info
X     */
X    if (Buf[0])
X	if ((p = index(Buf, KERNSTR_END)) != NULL)
X	    *p = C_NULL;
X#endif	/* KERNSTR_END */
X
X    return( (Buf[0]) ? Buf : (char *) NULL);
X}
X#endif	/* HAVE_KVM */
X#endif	/* HAVE_NLIST */
END_OF_kernel.c
if test 2262 -ne `wc -c <kernel.c`; then
    echo shar: \"kernel.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f run.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"run.c\"
else
echo shar: Extracting \"run.c\" \(3651 characters\)
sed "s/^X//" >run.c <<'END_OF_run.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/run.c,v 1.4 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: run.c,v $
X * Revision 1.4  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.3  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.2  1992/04/16  02:25:39  mcooper
X * Bug fixes, de-linting, and other changes found with CodeCenter.
X *
X * Revision 1.1  1992/03/22  00:20:10  mcooper
X * Initial revision
X *
X */
X
X
X/*
X * Things related to running system commands.
X */
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X/*
X * Specific command to determine our model name.
X */
X#if	defined(MODEL_COMMAND)
Xchar *ModelCommand[] = { MODEL_COMMAND, NULL };
X#endif	/* MODEL_COMMAND */
X
X/*
X * Application architecture commands.  
X * These commands should print the system's application architecture.
X */
Xchar *AppArchCmds[] = { 
X    "/bin/arch", 
X    "/bin/mach", 
X    "/bin/machine", 
X    NULL };
X
X/*
X * Kernel architecture commands.  
X * These commands should print the system's kernel architecture.
X */
Xchar *KernArchCmds[] = { 
X    "/bin/arch -k", 
X    "/bin/mach",
X    "/bin/machine", 
X    NULL };
X
X/*
X * Architecture test files.
X * Each test file is run and if the exit status is 0, 
X * the basename of the command is the name of the system architecture. 
X */
Xchar *ArchFiles[] = { 
X    "/bin/alliant", 
X    "/bin/vax", 
X    "/bin/sun", 
X    NULL };
X
X/*
X * CPU type test files.
X * Each test file is run and if the exit status is 0, 
X * the basename of the command is the name of the system CPU type. 
X */
Xchar *CPUFiles[] = { 
X	"/bin/sparc",
X	"/bin/mc68010",
X	"/bin/mc68020",
X	"/bin/mc68030",
X	"/bin/mc68040",
X	"/bin/m68k",
X	"/bin/vax",
X	"/bin/alliant",
X	"/bin/i386", 
X	"/bin/i860", 
X	"/bin/iAPX286",
X	"/bin/pdp11",
X	"/bin/u370",
X	"/bin/u3b15",
X	"/bin/u3b2",
X	"/bin/u3b5",
X	"/bin/u3b",
X	NULL };
X
X/*
X * Run a list of commands (found in cmds) and return command output.
X */
Xextern char *RunCmds(Cmds)
X    char 		      **Cmds;
X{
X    static char			Buf[BUFSIZ];
X    int 			l;
X    FILE 		       *pf;
X    register char 	       *p;
X    char 		      **Cmd;
X
X    for (Cmd = Cmds; Cmd != NULL && *Cmd != NULL; ++Cmd) {
X	/*
X	 * If this command has any args, nuke them for the access() test.
X	 */
X	strcpy(Buf, *Cmd);
X	p = index(Buf, ' ');
X	if (p != NULL)
X	    *p = C_NULL;
X
X	if (access(Buf, X_OK) != 0)
X	    continue;
X
X	if ((pf = popen(*Cmd, "r")) == NULL)
X	    continue;
X	if (fgets(Buf, sizeof(Buf), pf) == NULL) {
X	    pclose(pf);
X	    continue;
X	}
X	pclose(pf);
X
X	l = strlen(Buf);
X	if (Buf[l-1] == '\n') 
X	    Buf[l-1] = C_NULL;
X
X	return(Buf);
X    }
X
X    return((char *) NULL);
X}
X
X/*
X * Run a list of test files.  Each test file is run and if the
X * exit status is 0, we return the basename of the command.
X * e.g. If "/bin/vax" exists and returns status 0, return string "vax".
X */
Xextern char *RunTestFiles(Cmds)
X    char 		      **Cmds;
X{
X    char 		      **Cmd;
X    register char	       *p;
X    static char			Buf[BUFSIZ];
X
X    for (Cmd = Cmds; Cmd != NULL && *Cmd != NULL; ++Cmd) {
X	/*
X	 * If this command has any args, nuke them for the access() test.
X	 */
X	strcpy(Buf, *Cmd);
X	p = index(Buf, ' ');
X	if (p != NULL)
X	    *p = C_NULL;
X
X	if (access(Buf, X_OK) != 0)
X	    continue;
X
X	if (system(*Cmd) != 0)
X	    continue;
X
X	/*
X	 * The name of this architecture is the last part of the Cmd name.
X	 */
X	strcpy(Buf, *Cmd);
X	p = rindex(Buf, '/');
X	if (p != NULL)
X	    ++p;
X	return(p);
X    }
X
X    return(NULL);
X}
X
END_OF_run.c
if test 3651 -ne `wc -c <run.c`; then
    echo shar: \"run.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f KVM.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"KVM.c\"
else
echo shar: Extracting \"KVM.c\" \(3098 characters\)
sed "s/^X//" >KVM.c <<'END_OF_KVM.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/KVM.c,v 1.15 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: KVM.c,v $
X * Revision 1.15  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.13  1992/04/17  23:28:33  mcooper
X * Fixed NULL deref bug.
X *
X * Revision 1.12  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.11  1992/04/16  02:25:39  mcooper
X * Bug fixes, de-linting, and other changes found with CodeCenter.
X *
X * Revision 1.10  1992/03/31  03:10:17  mcooper
X * Put frontend macro around CheckNlist() to avoid
X * broken things in Ultrix.
X *
X * Revision 1.9  1992/03/31  02:44:20  mcooper
X * Add BROKEN_NLIST_CHECK define.
X *
X * Revision 1.8  1992/03/31  01:54:50  mcooper
X * Add CheckNlist().
X *
X * Revision 1.7  1992/03/31  00:34:42  mcooper
X * Make GetNlName() a macro.
X *
X * Revision 1.6  1992/03/30  23:44:05  mcooper
X * *** empty log message ***
X *
X */
X
X
X/*
X * Frontend functions for kvm_*() functions
X *
X * It is assumed we HAVE_NLIST if we HAVE_KVM.
X */
X
X#include <stdio.h>
X#include "system.h"
X
X#if	defined(HAVE_KVM)
X
X#include "defs.h"
X
X#include <fcntl.h>
X#if	defined(HAVE_NLIST)
X#include <nlist.h>
X#endif	/* HAVE_NLIST */
X
X/*
X * Perform a kvm_close().  Really just hear to be compatible.
X */
Xextern void KVM_close(kd)
X    kvm_t 		       *kd;
X{
X    if (kd)
X	(void) kvm_close(kd);
X}
X
X/*
X * Perform a kvm_open() and then a kvm_nlist().
X */
X#if	defined(HAVE_NLIST)
X/*
X * Do a kvm_open()
X */
Xextern kvm_t *KVM_open(PtrNL)
X    struct nlist 	       *PtrNL;
X#else
Xetern kvm_t *KVM_open()
X#endif	/* HAVE_NLIST */
X{
X    kvm_t 		       *kd = NULL;
X    extern char 	       *ProgramName;
X
X    if ((kd = kvm_open((char *)NULL, (char *)NULL, (char *)NULL, O_RDONLY,
X		       ProgramName)) == NULL) {
X	if (Debug) Error("kvm_open failed: %s.", SYSERR);
X	return((kvm_t *) NULL);
X    }
X
X#if	defined(HAVE_NLIST)
X    if (PtrNL)
X	if (kvm_nlist(kd, PtrNL) != 0) {
X	    if (Debug) Error("kvm_nlist name \"%s\" failed: %s.", 
X			     GetNlNamePtr(PtrNL), SYSERR);
X	    KVM_close(kd);
X	    return((kvm_t *) NULL);
X	}
X#endif	/* HAVE_NLIST */
X
X    return(kd);
X}
X
X/*
X * Perform a kvm_read().
X */
Xextern int KVM_read(kd, Addr, Buf, NumBytes)
X    kvm_t 		       *kd;
X    u_long	 		Addr;
X    char 		       *Buf;
X    unsigned 		        NumBytes;
X{
X    int				Count;
X
X    if (!kd)
X	return(-1);
X
X    if ((Count = kvm_read(kd, Addr, Buf, NumBytes)) != NumBytes) {
X	if (Debug) Error("kvm_read failed (expected %d, got %d): %s.", 
X			 NumBytes, Count, SYSERR);
X	return(-1);
X    }
X
X    return(0);
X}
X
X/*
X * Check to see if PtrNL is valid.
X */
Xextern int _CheckNlist(PtrNL)
X    struct nlist	       *PtrNL;
X{
X    /*
X     * Should use n_type, but that's not set
X     * correctly on some OS's.
X     */
X    if (!PtrNL || !PtrNL->n_value) {
X	if (Debug) Error("Kernel symbol \"%s\" not found.", 
X			 GetNlNamePtr(PtrNL));
X	return(-1);
X    }
X
X    return(0);
X}
X
X#endif /* HAVE_KVM */
END_OF_KVM.c
if test 3098 -ne `wc -c <KVM.c`; then
    echo shar: \"KVM.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f kvm.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"kvm.c\"
else
echo shar: Extracting \"kvm.c\" \(4463 characters\)
sed "s/^X//" >kvm.c <<'END_OF_kvm.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/kvm.c,v 1.11 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: kvm.c,v $
X * Revision 1.11  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.10  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.9  1992/03/22  00:20:10  mcooper
X * Major cleanup and re-org.
X *
X * Revision 1.8  1992/03/13  00:24:41  mcooper
X * Always copy vmfile and namelist because we free()
X * them in kvm_close().  GCC compiled stuff blows up
X * if we free() a constant.
X *
X * Revision 1.7  1992/03/12  02:03:33  mcooper
X * Change unix image to be /mach on NeXT machines.
X *
X * Revision 1.6  1992/03/04  00:01:59  mcooper
X * Make HAVE_KVM and HAVE_NLIST consistant.
X *
X * Revision 1.5  1992/03/03  03:18:59  mcooper
X * Seperate and cleanup KVM*() from kvm*().
X *
X * Revision 1.4  1992/03/01  23:28:33  mcooper
X * Add kvm_close() support and changed to work with picky
X * Alliant compiler.
X *
X * Revision 1.3  1992/02/22  02:20:19  mcooper
X * Major changes to support scanning kernel mainbus and
X * openprom data for device's.
X *
X * Revision 1.2  1992/02/10  04:13:18  mcooper
X * Move strdup() to sysinfo.c
X *
X * Revision 1.1  1991/09/28  03:14:49  mcooper
X * Initial revision
X *
X */
X
X#include "system.h"
X
X#if defined(NEED_KVM)
X
X#include <stdio.h>
X#include <sys/errno.h>
X#include "kvm.h"
X
X#ifndef SYSFAIL
X#define SYSFAIL -1
X#endif
X
X#if defined(DEBUG) && !defined(SYSERR)
Xextern int errno;
Xextern char sys_errlist[];
X#define SYSERR sys_errlist[errno]
X#endif
X
Xchar *strdup();
X
X#if defined(alliant) || defined(_AIX)
X#define NAMELIST	"/unix"
X#else
X#if defined(NeXT)
X#define NAMELIST	"/mach"
X#else
X#define NAMELIST	"/vmunix"
X#endif
X#endif
X#define MEMFILE		"/dev/mem"
X#define KMEMFILE	"/dev/kmem"
X
X/*
X * Close things down.
X */
Xextern int kvm_close(kd)
X    kvm_t 		       *kd;
X{
X    if (!kd)
X	return(-1);
X
X    if (kd->kmemd)
X	close(kd->kmemd);
X    if (kd->namelist)
X	free(kd->namelist);
X    if (kd->vmfile)
X	free(kd->vmfile);
X
X    free(kd);
X
X    return(0);
X}
X
X/*
X * Open things up.
X */
Xextern kvm_t *kvm_open(NameList, CoreFile, SwapFile, Flag, ErrStr)
X    char 		       *NameList;
X    char 		       *CoreFile;
X    char 		       *SwapFile;
X    int 			Flag;
X    char 		       *ErrStr;
X{
X    kvm_t *kd;
X
X    if ((kd = (kvm_t *) malloc(sizeof(kvm_t))) == NULL) {
X#ifdef DEBUG
X	fprintf(stderr, "kvm_open() malloc %d bytes failed!\n", sizeof(kvm_t));
X#endif
X	return((kvm_t *) NULL);
X    }
X
X    if (NameList)
X	kd->namelist = strdup(NameList);
X    else
X	kd->namelist = strdup(NAMELIST);
X
X    if (CoreFile)
X	kd->vmfile = strdup(CoreFile);
X    else
X	kd->vmfile = strdup(KMEMFILE);
X
X    if ((kd->kmemd = open(kd->vmfile, Flag, 0)) == SYSFAIL) {
X#ifdef DEBUG
X	fprintf(stderr, "kvm_open() open '%s' failed: %s.\n", kd->vmfile, 
X		SYSERR);
X#endif
X	return((kvm_t *) NULL);
X    }
X
X    return(kd);
X}
X
X/*
X * KVM read function
X */
Xextern int kvm_read(kd, Addr, Buf, NBytes)
X     kvm_t 		       *kd;
X     unsigned long 		Addr;
X     char 		       *Buf;
X     unsigned 			NBytes;
X{
X    unsigned 			ret;
X
X    if (!kd) {
X#ifdef DEBUG
X	fprintf(stderr, "kvm_read(): invalid kd param.\n");
X#endif
X	return(SYSFAIL);
X    }
X
X    if (lseek(kd->kmemd, Addr, 0) == SYSFAIL) {
X#ifdef DEBUG
X	fprintf(stderr, "kvm_read(): lseek failed (desc %d addr 0x%x): %s.\n",
X		kd->kmemd, Addr, SYSERR);
X#endif
X	return(SYSFAIL);
X    }
X
X    if ((ret = read(kd->kmemd, Buf, NBytes)) != NBytes) {
X#ifdef DEBUG
X	fprintf(stderr, 
X		"kvm_read(): read failed (desc %d buf 0x%x size %d): %s.\n",
X		kd->kmemd, Buf, NBytes, SYSERR);
X#endif
X	return(SYSFAIL);
X    }
X
X    return(ret);
X}
X
X/*
X * KVM write function
X */
Xextern int kvm_write(kd, Addr, Buf, NBytes)
X     kvm_t 		       *kd;
X     unsigned long 		Addr;
X     char 		       *Buf;
X     unsigned 			NBytes;
X{
X    unsigned 			ret;
X
X    if (!kd) {
X	return(SYSFAIL);
X    }
X
X    if (lseek(kd->kmemd, Addr, 0) == SYSFAIL) {
X	return(SYSFAIL);
X    }
X
X    if ((ret = write(kd->kmemd, Buf, NBytes)) != NBytes) {
X	return(SYSFAIL);
X    }
X
X    return(ret);
X}
X
X/*
X * Perform an nlist()
X */
X#if	defined(HAVE_NLIST)
Xextern int kvm_nlist(kd, nl)
X     kvm_t 		       *kd;
X     struct nlist 	       *nl;
X{
X    if (!kd) {
X	return(SYSFAIL);
X    }
X
X    return(nlist(kd->namelist, nl));
X}
X#endif	/* HAVE_NLIST */
X
X#endif /* NEED_KVM */
END_OF_kvm.c
if test 4463 -ne `wc -c <kvm.c`; then
    echo shar: \"kvm.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f kvm.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"kvm.h\"
else
echo shar: Extracting \"kvm.h\" \(729 characters\)
sed "s/^X//" >kvm.h <<'END_OF_kvm.h'
X#ifndef __kvm_h__
X#define __kvm_h__
X/*
X * $Header: /src/common/usc/bin/sysinfo/RCS/kvm.h,v 1.3 1992/06/01 22:43:53 mcooper Exp $
X *
X * $Log: kvm.h,v $
X * Revision 1.3  1992/06/01  22:43:53  mcooper
X * Cleanup.
X *
X * Revision 1.2  1992/03/01  23:19:55  mcooper
X * Put surrounding #ifndef around file to avoid multiple include
X * problems.  Also move struct _kvmd here from kvm.c.
X *
X * Revision 1.1  1991/09/28  03:14:49  mcooper
X * Initial revision
X *
X */
X
Xstruct _kvmd {
X    int			kmemd;
X    char	       *namelist;
X    char	       *vmfile;
X};
Xtypedef struct _kvmd kvm_t;
X
Xextern kvm_t	       *kvm_open();
Xextern int		kvm_close();
Xextern int		kvm_nlist();
Xextern int		kvm_read();
Xextern int		kvm_write();
X
X#endif /* __kvm_h__ */
END_OF_kvm.h
if test 729 -ne `wc -c <kvm.h`; then
    echo shar: \"kvm.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f patchlevel.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"patchlevel.h\"
else
echo shar: Extracting \"patchlevel.h\" \(50 characters\)
sed "s/^X//" >patchlevel.h <<'END_OF_patchlevel.h'
X/*
X * Patch level values
X */
X#define PATCHLEVEL 0
END_OF_patchlevel.h
if test 50 -ne `wc -c <patchlevel.h`; then
    echo shar: \"patchlevel.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f strcasecmp.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"strcasecmp.c\"
else
echo shar: Extracting \"strcasecmp.c\" \(3312 characters\)
sed "s/^X//" >strcasecmp.c <<'END_OF_strcasecmp.c'
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/lib/libgen/RCS/strcasecmp.c,v 1.3 1989/10/26 19:13:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: strcasecmp.c,v $
X * Revision 1.3  1989/10/26  19:13:06  mcooper
X * This is the BSD version.
X *
X * Revision 1.3  1989/10/26  19:13:06  mcooper
X * This is the BSD version.
X *
X */
X
X#ifndef lint
Xstatic char sccsid[] = "@(#)strcasecmp.c 1.1 89/05/19 SMI"; /* from UCB 1.3 8/3/87 */
X#endif
X
X/*
X * Copyright (c) 1987 Regents of the University of California.
X * All rights reserved.  The Berkeley software License Agreement
X * specifies the terms and conditions for redistribution.
X */
X
X/*
X * This array is designed for mapping upper and lower case letter
X * together for a case independent comparison.  The mappings are
X * based upon ascii character sequences.
X */
Xstatic char charmap[] = {
X	'\000', '\001', '\002', '\003', '\004', '\005', '\006', '\007',
X	'\010', '\011', '\012', '\013', '\014', '\015', '\016', '\017',
X	'\020', '\021', '\022', '\023', '\024', '\025', '\026', '\027',
X	'\030', '\031', '\032', '\033', '\034', '\035', '\036', '\037',
X	'\040', '\041', '\042', '\043', '\044', '\045', '\046', '\047',
X	'\050', '\051', '\052', '\053', '\054', '\055', '\056', '\057',
X	'\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
X	'\070', '\071', '\072', '\073', '\074', '\075', '\076', '\077',
X	'\100', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
X	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
X	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
X	'\170', '\171', '\172', '\133', '\134', '\135', '\136', '\137',
X	'\140', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
X	'\150', '\151', '\152', '\153', '\154', '\155', '\156', '\157',
X	'\160', '\161', '\162', '\163', '\164', '\165', '\166', '\167',
X	'\170', '\171', '\172', '\173', '\174', '\175', '\176', '\177',
X	'\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
X	'\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217',
X	'\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227',
X	'\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237',
X	'\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247',
X	'\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
X	'\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
X	'\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
X	'\300', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
X	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
X	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
X	'\370', '\371', '\372', '\333', '\334', '\335', '\336', '\337',
X	'\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347',
X	'\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357',
X	'\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
X	'\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
X};
X
Xstrcasecmp(s1, s2)
X	register char *s1, *s2;
X{
X	register char *cm = charmap;
X
X	while (cm[*s1] == cm[*s2++])
X		if (*s1++ == '\0')
X			return(0);
X	return(cm[*s1] - cm[*--s2]);
X}
X
Xstrncasecmp(s1, s2, n)
X	register char *s1, *s2;
X	register int n;
X{
X	register char *cm = charmap;
X
X	while (--n >= 0 && cm[*s1] == cm[*s2++])
X		if (*s1++ == '\0')
X			return(0);
X	return(n < 0 ? 0 : cm[*s1] - cm[*--s2]);
X}
END_OF_strcasecmp.c
if test 3312 -ne `wc -c <strcasecmp.c`; then
    echo shar: \"strcasecmp.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f strdup.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"strdup.c\"
else
echo shar: Extracting \"strdup.c\" \(684 characters\)
sed "s/^X//" >strdup.c <<'END_OF_strdup.c'
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/lib/libgen/RCS/strdup.c,v 1.2 1992/04/16 01:28:02 mcooper Exp $";
X#endif
X
X/*
X * $Log: strdup.c,v $
X * Revision 1.2  1992/04/16  01:28:02  mcooper
X * Some de-linting.
X *
X * Revision 1.2  1992/04/16  01:28:02  mcooper
X * Some de-linting.
X *
X * Revision 1.1  1992/03/21  02:48:11  mcooper
X * Initial revision
X *
X */
X
X
X#include <stdio.h>
X
X/*
X * Most systems don't have this (yet)
X */
Xchar *strdup(str)
X     char *str;
X{
X    char 		       *p;
X    extern char		       *malloc();
X    extern char		       *strcpy();
X
X    if ((p = malloc(strlen(str)+1)) == NULL)
X	return((char *) NULL);
X
X    (void) strcpy(p, str);
X
X    return(p);
X}
END_OF_strdup.c
if test 684 -ne `wc -c <strdup.c`; then
    echo shar: \"strdup.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f strerror.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"strerror.c\"
else
echo shar: Extracting \"strerror.c\" \(683 characters\)
sed "s/^X//" >strerror.c <<'END_OF_strerror.c'
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/lib/libgen/RCS/strerror.c,v 1.1 1992/03/21 02:48:11 mcooper Exp $";
X#endif
X
X/*
X * $Log: strerror.c,v $
X * Revision 1.1  1992/03/21  02:48:11  mcooper
X * Initial revision
X *
X * Revision 1.1  1992/03/21  02:48:11  mcooper
X * Initial revision
X *
X */
X
X#include <stdio.h>
X#include <sys/errno.h>
X
X/*
X * Return string for system error number "Num".
X */
Xchar *strerror(Num)
X     int			Num;
X{
X    extern int 			sys_nerr;
X    extern char 	       *sys_errlist[];
X    static char 		Unknown[100];
X
X    if (Num < 0 || Num > sys_nerr) {
X	(void) sprintf(Unknown, "Error %d", Num);
X	return(Unknown);
X    } else
X	return(sys_errlist[Num]);
X}
END_OF_strerror.c
if test 683 -ne `wc -c <strerror.c`; then
    echo shar: \"strerror.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f options.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"options.c\"
else
echo shar: Extracting \"options.c\" \(11038 characters\)
sed "s/^X//" >options.c <<'END_OF_options.c'
X/*
X * Copyright (c) 1990 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/lib/libgen/RCS/options.c,v 1.14 1992/04/16 01:28:02 mcooper Exp $";
X#endif
X
X/*
X * $Log: options.c,v $
X * Revision 1.14  1992/04/16  01:28:02  mcooper
X * Some de-linting.
X *
X * Revision 1.14  1992/04/16  01:28:02  mcooper
X * Some de-linting.
X *
X * Revision 1.13  1990/12/15  18:13:28  mcooper
X * Add copywrite notice.
X *
X * Revision 1.12  90/12/15  17:51:46  mcooper
X * Add #ifdef HAS_VARARGS around include for <varargs>.
X * 
X * Revision 1.11  90/11/13  16:39:28  mcooper
X * Add #ifdef HAS_VARARGS for systems without
X * varargs.
X * 
X * Revision 1.10  90/11/13  15:28:01  mcooper
X * - Add OptBool cvtarg routine.
X * - Print default values in HelpOptions() 
X *   when appropriate.
X * 
X * Revision 1.9  90/11/13  15:19:00  mcooper
X * Added supported for options being both
X * SepArg and StickyArg.
X * 
X * Revision 1.8  90/10/30  21:02:31  mcooper
X * Need to exit() if -help is specified.
X * 
X * Revision 1.7  90/10/30  20:24:33  mcooper
X * Fixed bug in UsageString().
X * 
X * Revision 1.6  90/10/30  19:53:05  mcooper
X * Cleaned up some NeXT cc and lint stuff.
X * 
X * Revision 1.5  90/10/30  19:45:31  mcooper
X * Remove unneeded paramter to HelpOptions().
X * 
X * Revision 1.4  90/10/29  14:47:42  mcooper
X * Added real function UsageString() to
X * handle formating usage option strings.
X * 
X * Revision 1.3  90/10/29  14:17:00  mcooper
X * Allow options to be abbreviated 
X * (for all non StickArg options).
X * 
X * Revision 1.2  90/10/26  15:56:11  mcooper
X * - Fix bug in SepArg code that ate arguments.
X * - Cleanup help message.
X * - Add ArgHidden code.
X * 
X * Revision 1.1  90/10/26  14:42:51  mcooper
X * Initial revision
X * 
X */
X
X/*
X * Functions to parse options.
X */
X
X#include "options.h"
X#ifdef HAS_VARARGS
X#include <varargs.h>
X#endif
X
Xchar *OptionChars = "-+";	/* Default option switching characters */
Xchar *ProgramName = NULL;	/* Name of this program */
Xchar *UsageString();
Xstatic int isopt();
Xstatic int suppress_help_msg = 0;
Xchar *strcat();
X
X/*
X * ParseOptions - Parse options found in argv using "options".
X *		  Returns the number of options parsed if there
X *		  were no errors.  Returns -1 if an error occurs.
X */
Xint ParseOptions(options, num_options, argc, argv)
X     OptionDescRec *options;
X     int num_options;
X     int argc;
X     char **argv;
X{
X    OptionDescRec *opt;
X    register int x;
X    char *p;
X
X    if (ProgramName == NULL)
X	ProgramName = argv[0];
X
X#ifdef OPTION_DEBUG
X    (void) printf("Option list is:\n");
X    for (x = 0; x < num_options; ++x) {
X	opt = &options[x];
X	(void) printf("%s\n", opt->option);
X    }
X
X    (void) printf("Arguments (%d):", argc);
X    for (x = 0; x < argc; ++x) {
X	(void) printf(" %s", argv[x]);
X    }
X    (void) printf("\n");
X#endif /* OPTION_DEBUG */
X
X    for (x = 1; x < argc; ++x) {
X	if (strcmp(HELPSTR, argv[x]) == 0) {
X	    HelpOptions(options, num_options, (char **)NULL);
X	    exit(0);
X	}
X
X	opt = FindOption(options, num_options, argv[x]);
X	if (opt == NULL) {
X	    if (isopt(argv[x])) { /* this was suppose to be an option */
X		UsageOptions(options, num_options, argv[x]);
X		return(-1);
X	    } else { /* must be end of options */
X		break;
X	    }
X	}
X
X	if (opt->flags & NoArg) {
X	    if (!(*opt->cvtarg)(opt, opt->value, FALSE)) {
X		UsageOptions(options, num_options, opt->option);
X		return(-1);
X	    }
X	} else if (opt->flags & IsArg) {
X	    if (!(*opt->cvtarg)(opt, opt->option, FALSE)) {
X		UsageOptions(options, num_options, opt->option);
X		return(-1);
X	    }
X	} else if ((opt->flags & StickyArg) && (opt->flags & SepArg)) {
X	    p = (char *) &argv[x][strlen(opt->option)];
X	    if (!*p) {		/*** SepArg ***/
X		if (x + 1 >= argc || isopt(argv[x+1])) {
X		    if (opt->value == (caddr_t) NULL) {
X			UserError("%s: Option requires an argument.", argv[x]);
X			UsageOptions(options, num_options, opt->option);
X			return(-1);
X		    }
X		    p = opt->value;
X		} else {
X		    p = argv[++x];
X		}
X	    }
X	    if (!(*opt->cvtarg)(opt, p, TRUE)) {
X		UsageOptions(options, num_options, opt->option);
X		return(-1);
X	    }
X	} else if (opt->flags & StickyArg) {
X	    p = (char *) &argv[x][strlen(opt->option)];
X	    if (!*p) {
X		if (opt->value == (caddr_t) NULL) {
X		    UserError("%s: Option requires an argument.", argv[x]);
X		    UsageOptions(options, num_options, opt->option);
X		    return(-1);
X		} else {
X		    p = opt->value;
X		}
X	    }
X	    if (!(*opt->cvtarg)(opt, p, TRUE)) {
X		UsageOptions(options, num_options, opt->option);
X		return(-1);
X	    }
X	} else if (opt->flags & SepArg) {
X	    if (x + 1 >= argc || isopt(argv[x+1])) {
X		if (opt->value == (caddr_t) NULL) {
X		    UserError("%s: Option requires an argument.", argv[x]);
X		    UsageOptions(options, num_options, opt->option);
X		    return(-1);
X		} else {
X		    p = opt->value;
X		}
X	    } else {
X		p = argv[++x];
X	    }
X	    if (!(*opt->cvtarg)(opt, p, TRUE)) {
X		UsageOptions(options, num_options, opt->option);
X		return(-1);
X	    }
X	} else if (opt->flags & SkipArg) {
X	    x += 2;
X	} else if (opt->flags & SkipLine) {
X	    return(x);
X	} else if (opt->flags & SkipNArgs) {
X	    if (opt->value) {
X		x += atoi(opt->value);
X	    } else {
X		UserError("Internal Error: No 'value' set for SkipNArgs.");
X		return(-1);
X	    }
X	} else {
X	    UserError("Internal Error: Unknown argument type for option '%s'.",
X		     opt->option);
X	    return(-1);
X	}
X    }
X
X    return(x);
X}
X
X/*
X * FindOption - Find "option" in "options".  Returns NULL if not found.
X */
XOptionDescRec *FindOption(options, num_options, option)
X     OptionDescRec *options;
X     int num_options;
X     char *option;
X{
X    OptionDescRec *opt;
X    register int x;
X
X    for (x = 0; x < num_options; ++x) {
X	opt = &options[x];
X	if (opt->flags & StickyArg) {
X	    if (strncmp(option, opt->option, strlen(opt->option)) == 0)
X		return(opt);
X	} else {
X	    if (strncmp(option, opt->option, strlen(option)) == 0)
X		return(opt);
X	}
X    }
X
X    return(NULL);
X}
X
X/*
X * isopt - Is "str" an option string?  Compare first char of str against
X *	   list of option switch characters.  Returns TRUE if it is an option.
X */
Xstatic int isopt(str)
X     char *str;
X{
X    register char *p;
X
X    for (p = OptionChars; p && *p; ++p) {
X	if (*str == *p) {
X	    return(TRUE);
X	}
X    }
X
X    return(FALSE);
X}
X
X/*
X * UsageOptions - Print a usage message based on "options".
X */
Xvoid UsageOptions(options, num_opts, badOption)
X     OptionDescRec *options;
X     int num_opts;
X     char *badOption;
X{
X    OptionDescRec *opt;
X    char *optstr;
X    register int x;
X    int col, len;
X
X    if (badOption) 
X	(void) fprintf (stderr, "%s:  bad command line option \"%s\"\r\n\n",
X			ProgramName, badOption);
X
X    (void) fprintf (stderr, "usage:  %s", ProgramName);
X    col = 8 + strlen(ProgramName);
X    for (x = 0; x < num_opts; x++) {
X	opt = &options[x];
X	if (opt->flags & ArgHidden)
X	    continue;
X	optstr = UsageString(opt);
X	len = strlen(optstr) + 3;	/* space [ string ] */
X	if (col + len > 79) {
X	    (void) fprintf (stderr, "\r\n   ");  /* 3 spaces */
X	    col = 3;
X	}
X	(void) fprintf (stderr, " [%s]", optstr);
X	col += len;
X    }
X
X    if (suppress_help_msg)
X	(void) fprintf(stderr, "\r\n\n");
X    else
X	(void) fprintf(stderr, 
X		       "\r\n\nType \"%s %s\" for a full description.\r\n\n",
X		       ProgramName, HELPSTR);
X}
X
X/*
X * HelpOptions - Print a nice help/usage message based on options.
X */
Xvoid HelpOptions(options, num_opts, message)
X     OptionDescRec *options;
X     int num_opts;
X     char **message;
X{
X    OptionDescRec *opt;
X    register int x;
X    char **cpp;
X
X    suppress_help_msg = 1;
X    UsageOptions(options, num_opts, (char *)NULL);
X    suppress_help_msg = 0;
X
X    (void) fprintf (stderr, "where options include:\n");
X    for (x = 0; x < num_opts; x++) {
X	opt = &options[x];
X	if (opt->flags & ArgHidden)
X	    continue;
X	(void) fprintf (stderr, "    %-28s %s\n", UsageString(opt), 
X		 (opt->desc) ? opt->desc : "");
X	if (opt->value && opt->cvtarg != OptBool)
X	    (void) fprintf (stderr, "    %-28s [ Default value is %s ]\n", 
X			    "", opt->value);
X    }
X
X    if (message) {
X	(void) putc ('\n', stderr);
X	for (cpp = message; *cpp; cpp++) {
X	    (void) fputs (*cpp, stderr);
X	    (void) putc ('\n', stderr);
X	}
X	(void) putc ('\n', stderr);
X    }
X}
X
X/*
X * UserError - Print a user error.
X */
X#ifdef HAS_VARARGS
Xvoid UserError(va_alist)
X     va_dcl
X{
X    va_list args;
X    char *fmt;
X
X    va_start(args);
X    if (ProgramName)
X	(void) fprintf(stderr, "%s: ", ProgramName);
X    fmt = (char *) va_arg(args, char *);
X    (void) vfprintf(stderr, fmt, args);
X    va_end(args);
X    (void) fprintf(stderr, "\n");
X}
X#else
Xvoid UserError(fmt, a1, a2, a3, a4, a5, a6)
X     char *fmt;
X{
X    if (ProgramName)
X	(void) fprintf(stderr, "%s: ", ProgramName);
X    (void) fprintf(stderr, fmt, a1, a2, a3, a4, a5, a6);
X    (void) fprintf(stderr, "\n");
X}
X#endif
X
XOptBool(opt, value, docopy)
X     OptionDescRec *opt;
X     caddr_t value;
X     int docopy; /*ARGSUSED*/
X{
X    char *vpp;
X
X    *(int *) opt->valp = (int) strtol(value, &vpp, 0);
X    if (*vpp) {
X	UserError("Invalid integer argument for '%s'.", opt->option);
X	return(FALSE);
X    } else {
X	return(TRUE);
X    }
X}
X
XOptInt(opt, value, docopy)
X     OptionDescRec *opt;
X     caddr_t value;
X     int docopy; /*ARGSUSED*/
X{
X    char *vpp;
X
X    *(int *) opt->valp = (int) strtol(value, &vpp, 0);
X    if (*vpp) {
X	UserError("Invalid integer argument for '%s'.", opt->option);
X	return(FALSE);
X    } else {
X	return(TRUE);
X    }
X}
X
XOptShort(opt, value, docopy)
X     OptionDescRec *opt;
X     caddr_t value;
X     int docopy; /*ARGSUSED*/
X{
X    char *vpp;
X
X    *(short *) opt->valp = (short) strtol(value, &vpp, 0);
X    if (*vpp) {
X	UserError("Invalid integer argument for '%s'.", opt->option);
X	return(FALSE);
X    } else {
X	return(TRUE);
X    }
X}
X
XOptLong(opt, value, docopy)
X     OptionDescRec *opt;
X     caddr_t value;
X     int docopy; /*ARGSUSED*/
X{
X    char *vpp;
X
X    *(long *) opt->valp = (long) strtol(value, &vpp, 0);
X    if (*vpp) {
X	UserError("Invalid integer argument for '%s'.", opt->option);
X	return(FALSE);
X    } else {
X	return(TRUE);
X    }
X}
X
XOptStr(opt, value, docopy)
X     OptionDescRec *opt;
X     caddr_t value;
X     int docopy;
X{
X    char *p;
X
X    if (docopy) {
X	if ((p = (char *) malloc((unsigned)strlen(value)+1)) == NULL) {
X	    UserError("Cannot malloc memory: %s", SYSERR);
X	    return(FALSE);
X	}
X	(void) strcpy(p, value);
X    } else {
X	p = value;
X    }
X
X    *(char **) opt->valp = p;
X
X    return(TRUE);
X}
X
Xstatic char *UsageString(opt)
X     OptionDescRec *opt;
X{
X    static char buf[BUFSIZ], buf2[BUFSIZ];
X
X    (void) sprintf(buf, opt->option);
X    (void) strcpy(buf2, "");
X    if (opt->usage) {
X	(void) sprintf(buf2, "%s%s%s%s",
X		       ((opt->flags & StickyArg) && 
X			!((opt->flags & StickyArg) && (opt->flags & SepArg))) 
X		       ? "" : " ",
X		       (opt->value) ? "[" : "",
X		       opt->usage,
X		       (opt->value) ? "]" : ""
X		       );
X    }
X    (void) strcat(buf, buf2);
X
X    return(buf);
X}
END_OF_options.c
if test 11038 -ne `wc -c <options.c`; then
    echo shar: \"options.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f options.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"options.h\"
else
echo shar: Extracting \"options.h\" \(2596 characters\)
sed "s/^X//" >options.h <<'END_OF_options.h'
X/*
X * Copyright (c) 1990 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Header: /src/common/usc/lib/libgen/RCS/options.h,v 1.7 1990/12/15 18:13:30 mcooper Exp mcooper $
X *
X * $Log: options.h,v $
X * Revision 1.7  1990/12/15  18:13:30  mcooper
X * Add copywrite notice.
X *
X * Revision 1.6  90/11/13  15:28:39  mcooper
X * Add OptBool cvtarg routine.
X * 
X * Revision 1.5  90/10/29  19:34:03  mcooper
X * Fixed comment for NoArg.
X * 
X * Revision 1.4  90/10/29  18:48:43  mcooper
X * Cleanup some comments.
X * 
X * Revision 1.3  90/10/29  14:47:29  mcooper
X * UsageString is now a real function.
X * 
X * Revision 1.2  90/10/26  15:55:44  mcooper
X * Add defines for "__" and ArgHidden.
X * 
X * Revision 1.1  90/10/26  14:42:53  mcooper
X * Initial revision
X * 
X */
X
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/errno.h>
X
X#define Num_Opts(o)	(sizeof(o)/sizeof(OptionDescRec))
X#define HELPSTR		"-help"
X#define __		(caddr_t)
X
X#ifndef SYSERR
X#define SYSERR		sys_errlist[errno]
X#endif
X#ifndef TRUE
X#define TRUE	1
X#endif
X#ifndef FALSE
X#define FALSE	0
X#endif
X
X/*
X * Values for OptionDescRec.flags.
X */
X#define NoArg		0x001	/* No argument for this option.  Use
X				   OptionDescRec.value. */
X#define IsArg		0x002	/* Value is the option string itself */
X#define SepArg		0x004	/* Value is in next argument in argv */
X#define StickyArg	0x008	/* Value is characters immediately following 
X				   option */
X#define SkipArg		0x010	/* Ignore this option and the next argument in 
X				   argv */
X#define SkipLine	0x020	/* Ignore this option and the rest of argv */
X#define SkipNArgs	0x040	/* Ignore this option and the next 
X				   OptionDescRes.value arguments in argv */
X#define ArgHidden	0x080	/* Don't show in usage or help messages */
X
X/*
X * Option description record.
X */
Xtypedef struct {
X    char	*option;		/* Option string in argv	    */
X    int		 flags;			/* Flag bits			    */
X    int		(*cvtarg)();		/* Function to convert argument     */
X    caddr_t	 valp;			/* Variable to set		    */
X    caddr_t	 value;			/* Default value to provide	    */
X    char	*usage;			/* Usage message		    */
X    char	*desc;			/* Description message		    */
X} OptionDescRec, *OptionDescList;
X
Xvoid UsageOptions();
Xvoid HelpOptions();
Xvoid UserError();
Xint ParseOptions();
XOptionDescRec *FindOption();
X
Xint OptBool();
Xint OptInt();
Xint OptLong();
Xint OptShort();
Xint OptStr();
X
Xextern char *OptionChars;
Xextern int errno;
Xextern char *sys_errlist[];
Xextern long strtol();
Xextern char *malloc();
Xextern char *strcpy();
END_OF_options.h
if test 2596 -ne `wc -c <options.h`; then
    echo shar: \"options.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f system.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"system.h\"
else
echo shar: Extracting \"system.h\" \(6582 characters\)
sed "s/^X//" >system.h <<'END_OF_system.h'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Header: /src/common/usc/bin/sysinfo/RCS/system.h,v 1.23 1992/04/26 23:32:06 mcooper Exp $
X *
X * $Log: system.h,v $
X * Revision 1.23  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.22  1992/04/18  20:47:43  mcooper
X * Merge Solbourne stuff back into main "sun" area.
X *
X * Revision 1.20  1992/04/17  01:08:56  mcooper
X * BROKEN_NLIST_CHECK is no longer needed.
X *
X * Revision 1.19  1992/04/12  22:02:15  mcooper
X * - Add Tadpole support.
X * - Remove obsolete MODEL_SHIFTVAL.
X * - Update solbourne to current "sun" stuff.
X *
X * Revision 1.17  1992/03/31  02:44:32  mcooper
X * Add BROKEN_NLIST_CHECK to hp300.
X *
X * Revision 1.16  1992/03/22  00:27:11  mcooper
X * Remove obsolete items.
X *
X * Revision 1.15  1992/03/09  01:08:10  mcooper
X * Ultrix now has HAVE_MODELNAME.
X *
X * Revision 1.14  1992/03/08  23:10:27  mcooper
X * Add HAVE_PACKETFILTER to Ultrix.
X *
X * Revision 1.13  1992/03/08  04:56:17  mcooper
X * Add NEED_SOCKIO for suns and HAVE_IF_VERSION for ultrix.
X *
X * Revision 1.12  1992/03/06  18:39:55  mcooper
X * - Add HAVE_NLIST where needed.
X * - Add ultrix stuff for devices.
X * - Define HAVE_KVM if NEED_KVM is defined.
X *
X * Revision 1.11  1992/03/01  23:29:39  mcooper
X * Add new MODELNAME and ?ARCHNAME stuff.
X *
X * Revision 1.10  1992/02/27  00:09:36  mcooper
X * Update solbourne to have HAVE_MAINBUS and HAVE_OPENPROM.
X *
X * Revision 1.9  1992/02/22  02:18:44  mcooper
X * Add definitions for sun HAVE_MAINBUS and HAVE_OPENPROM.
X *
X * Revision 1.8  1992/02/17  01:00:14  mcooper
X * Update solbourne.
X *
X * Revision 1.7  1992/02/10  21:04:51  mcooper
X * - Add #ifdef's for HAVE_IPI
X * - Change sun #include <arch/cpu.h> to <machine/cpu.h
X * - Define SECSIZE, HAVE_DK_IOCTL, and HAVE_NIT.
X *
X * Revision 1.6  1991/10/09  03:37:17  mcooper
X * Add support for getting serial number
X * and model name directly from system on
X * Alliant FX80 series.
X *
X * Revision 1.5  1991/10/01  01:48:56  mcooper
X * Add HAVE_SERIALNUM for Alliant 2800.
X *
X * Revision 1.4  1991/09/30  05:28:34  mcooper
X * Set OSVERS_FROM_KERNVER correctly for alliant 2800.
X *
X * Revision 1.3  1991/09/30  05:21:57  mcooper
X * Add support for getting memory and model
X * number on Alliant 2800's.
X *
X * Revision 1.2  1991/09/30  04:48:10  mcooper
X * Don't need to define COFF for Sun386i
X * since it is predefined.
X *
X * Revision 1.1  1991/09/30  04:32:36  mcooper
X * Initial revision
X *
X */
X
X#ifndef __sysinfo_system__
X#define __sysinfo_system__
X
X/*
X * System dependant information
X */
X
X#if defined(sun)
X#	include <sys/param.h>
X#	include <sys/file.h>
X#	include <machine/cpu.h>
X	/*
X	 * What manufacturer is this?
X	 */
X#	if defined(TAD_SPBK_ARCH)
X#		define MAN_SHORT	"Tadpole"
X#		define MAN_LONG		"Tadpole Technology Inc"
X#		define TADPOLE
X#	elif defined(CPU_TYPE_SERIES4) || defined(CPU_TYPE_SERIES5) || \
X    	     defined(CPU_TYPE_SERIES5E) || defined(CPU_TYPE_SERIES6)
X#		define MAN_SHORT	"Solbourne"
X#		define MAN_LONG		"Solbourne Computer Corporation"
X#		define SOLBOURNE
X#	else
X#		define MAN_SHORT	"Sun"
X#		define MAN_LONG		"Sun Microsystems Incorporated"
X#		define HAVE_SUNROMVEC
X#	endif
X
X#	if defined(mc68020)
X#		define ARCH_TYPE 	"sun3"
X#		define HAVE_IPI
X#		define HAVE_MAINBUS
X#	endif
X#	if defined(sparc)
X#		define ARCH_TYPE 	"sun4"
X#		if !defined(TADPOLE) && !defined(SOLBOURNE)
X#			define HAVE_IPI
X#		endif
X#		if !defined(TADPOLE)
X#			define HAVE_MAINBUS
X#		endif
X#	endif
X#	if defined(i386)
X#		define ARCH_TYPE 	"sun386"
X#		define HAVE_MAINBUS
X#	endif
X#	if defined(OPENPROMS)
X#		define HAVE_OPENPROM
X#	endif
X#	define NEED_SOCKIO
X#	define HAVE_IDMETHOD
X#	define HAVE_VARARGS
X#	define HAVE_UNAME
X#	define HAVE_KVM
X#	define HAVE_NLIST
X#	define HAVE_NIT
X#	define HAVE_KARCHNAME
X#	if !defined(SECSIZE)
X#		define SECSIZE	512		/* Size of a disk sector */
X#	endif
X#	define KERNSTR_END	'\n'
X/*
X * This is to get around an error on Sun386i's in <sun386/cpu.h>
X */
X#if defined(SUN386_ARCH) && !defined(I386_ARCH)
X#define I386_ARCH SUN386_ARCH
X#endif
X#endif /* sun */
X
X#if defined(ultrix) || defined(vax)
X#	if defined(ultrix)
X#		define HAVE_UNAME
X#		include <unistd.h>
X#	else
X#		include <sys/file.h>
X#		define OS_NAME	"BSD"
X#	endif
X#	define MAN_SHORT	"DEC"
X#	define MAN_LONG		"Digital Equipment Corporation"
X#	define HAVE_VARARGS
X#	define HAVE_UBA
X#	define HAVE_IF_VERSION
X#	define HAVE_PACKETFILTER
X#	define HAVE_NLIST
X#	define NEED_KVM
X#	define KERNSTR_END	'\n'
X#	if !defined(SECSIZE)
X#		define SECSIZE	512		/* Size of a disk sector */
X#	endif
X#endif /* ultrix || vax */
X
X#if defined(hp300)
X#	include <sys/file.h>
X#	include <sys/param.h>
X#	define MAN_SHORT	"HP"
X#	define MAN_LONG		"Hewlett Packard"
X#	define OS_NAME		"BSD"
X#	if defined(BSD) && BSD == 43
X#		define OS_VERSION	"4.3"
X#	endif
X#	define CPU_NAME		"MC68030"
X#	define HAVE_VARARGS
X#	define HAVE_NLIST
X#	define KERNSTR_END	'\n'
X#	define NEED_KVM
X#endif /* hp300 */
X
X#if defined(alliant)
X#	include <sys/file.h>
X#	define MAN_SHORT	"Alliant"
X#	define MAN_LONG		"Alliant Computer Corporation"
X#	if defined(i860)
X#		include <sys/alliant2800.h>
X#		define CPU_NAME		"i860"
X#		define ARCH_TYPE 	"alliant2800"
X#		define OS_NAME		"Concentrix 2800"
X#		define HAVE_MODELNUM
X#		define HAVE_MEMORYSIZE
X#		define HAVE_SERIALNUM
X#		define OSVERS_FROM_KERNVER 4
X#	else
X#		include <sys/param.h>
X#		include <machine/vmparam.h>
X#		include <machine/bpb.h>
X#		define OS_NAME		"Concentrix"
X#		define ARCH_TYPE 	"alliant"
X#		define HAVE_LIB_SYSCFG
X#		define HAVE_USERETC
X#		define OSVERS_FROM_KERNVER 3
X#	endif
X#	define HAVE_NLIST
X#	define NEED_KVM
X#endif /* alliant */
X
X#if defined(NeXT)
X#	include <sys/file.h>
X#	include <kern/mach_host.h>
X#	define MAN_SHORT	"NeXT"
X#	define MAN_LONG		"NeXT Computer"
X#	define OS_NAME		"NeXT Mach"
X#	define HAVE_VARARGS
X#	define HAVE_HOST_INFO
X#	define HAVE_KARCHNAME
X#	define HAVE_AARCHNAME
X#	define HAVE_NLIST
X#	define NEED_KVM
X#	define KERNSTR_END	';'
X#	if !defined(mc68k)
X#		define mc68k
X#	endif
X#endif /* NeXT */
X
X#if defined(_AIX)
X#	include <sys/file.h>
X#	define MAN_SHORT	"IBM"
X#	define MAN_LONG		"International Business Machines Corporation"
X#	ifdef _IBMR2
X#		define CPU_NAME	"rios"
X#	endif
X#	define ARCH_TYPE	"rs6000"
X#	define KARCH_TYPE	ARCH_TYPE
X#	define HAVE_VARARGS
X#	define HAVE_UNAME
X#	define UNAME_REL_VER_COMB
X#	define HAVE_NLIST
X#	define NEED_KVM
X#endif /* _AIX */
X
X/*
X * Everything depends on HAVE_KVM
X */
X#if	defined(NEED_KVM) && !defined(HAVE_KVM)
X#define HAVE_KVM
X#endif
X
X#endif /* __sysinfo_system__ */
END_OF_system.h
if test 6582 -ne `wc -c <system.h`; then
    echo shar: \"system.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f defs.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"defs.h\"
else
echo shar: Extracting \"defs.h\" \(13978 characters\)
sed "s/^X//" >defs.h <<'END_OF_defs.h'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Header: /src/common/usc/bin/sysinfo/RCS/defs.h,v 1.30 1992/04/26 23:32:06 mcooper Exp $
X *
X * $Log: defs.h,v $
X * Revision 1.30  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.29  1992/04/17  23:27:51  mcooper
X * Add support for ROM Version information (Sun only for now).
X *
X * Revision 1.28  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.27  1992/04/16  02:25:39  mcooper
X * Bug fixes, de-linting, and other changes found with CodeCenter.
X *
X * Revision 1.26  1992/04/15  02:00:36  mcooper
X * Major re-write and simplification of command line options.
X *
X * Revision 1.25  1992/03/31  18:58:16  mcooper
X * Change "verbose" to "Show".
X *
X * Revision 1.24  1992/03/31  03:10:17  mcooper
X * Put frontend macro around CheckNlist() to avoid
X * broken things in Ultrix.
X *
X * Revision 1.23  1992/03/31  00:34:59  mcooper
X * Add new GetNlName() and GetNlNamePtr() macros.
X *
X * Revision 1.22  1992/03/31  00:15:55  mcooper
X * Make GetNlName() global.
X *
X * Revision 1.21  1992/03/28  22:01:16  mcooper
X * Add dd_slave to DEVDATA.
X *
X * Revision 1.20  1992/03/25  03:31:28  mcooper
X * Fix verbose flags.
X *
X * Revision 1.19  1992/03/25  03:18:52  mcooper
X * Convert verbosity levels to bit flags.
X *
X * Revision 1.18  1992/03/22  00:54:53  mcooper
X * Add GetNlName().
X *
X * Revision 1.17  1992/03/22  00:20:10  mcooper
X * Major cleanup and re-org.
X *
X * Revision 1.16  1992/03/08  05:00:40  mcooper
X * Remove obsolete NETIFTAB.
X *
X * Revision 1.15  1992/03/08  04:55:42  mcooper
X * Add support for address families and multiple addresses
X * per network interface.
X *
X * Revision 1.14  1992/03/06  18:36:06  mcooper
X * Add new NAMETAB to replace other similiar types.
X *
X * Revision 1.13  1992/03/03  03:18:59  mcooper
X * Seperate and cleanup KVM*() from kvm*().
X *
X * Revision 1.12  1992/03/01  23:29:19  mcooper
X * Move kvm_t to kvm.h.
X *
X * Revision 1.11  1992/03/01  22:51:02  mcooper
X * Add kvm_t structure.
X *
X * Revision 1.10  1992/03/01  21:34:07  mcooper
X * Put #ifdef HAVE_KVM around KVM_*() function declarations.
X *
X * Revision 1.9  1992/03/01  21:30:18  mcooper
X * Add dd_secsize to DISKDRIVE and add new MODELTAB.
X *
X * Revision 1.8  1992/02/27  22:01:22  mcooper
X * Add support for getting CPU info for sun4m.
X *
X * Revision 1.7  1992/02/27  02:42:33  mcooper
X * Cleanup.
X *
X * Revision 1.6  1992/02/25  00:59:35  mcooper
X * Move tape info to local MTINFO.
X *
X * Revision 1.5  1992/02/25  00:15:56  mcooper
X * Update DT_* and other misc.
X *
X * Revision 1.4  1992/02/22  02:20:19  mcooper
X * Major changes to support scanning kernel mainbus and
X * openprom data for device's.
X *
X * Revision 1.3  1992/02/16  23:50:23  mcooper
X * Add verbosity level macros.
X *
X * Revision 1.2  1992/02/16  23:03:51  mcooper
X * Declare extern verbose.
X *
X * Revision 1.1  1992/02/16  22:53:52  mcooper
X * Initial revision
X *
X */
X
X#ifndef __sysinfo_defs__
X#define __sysinfo_defs__ 
X
X/* Need to include options.h before errno.h */
X#include "options.h"
X#include <errno.h>
X#include "patchlevel.h"
X
X/*
X * Version of this program
X */
X#define VERSION_STR		"1.0"
X
X#if	defined(NEED_KVM)
X#include "kvm.h"
X#else
X#if	defined(HAVE_KVM)
X#include <kvm.h>
X#endif	/* HAVE_KVM */
X#endif	/* NEED_KVM */
X
X/*
X * File containing our CPU model name.  Overrides all other methods
X * for determing model name.
X */
X#ifndef MODELFILE
X#define MODELFILE 		"/etc/sysmodel"
X#endif
X
X/*
X * System call failure value
X */
X#ifndef SYSFAIL
X#define SYSFAIL			-1
X#endif
X
X#define C_NULL			'\0'
X
X/*
X * System error numbers and message strings
X */
Xextern int errno;
X
X#ifdef SYSERR
X#undef SYSERR
X#endif
X
X#if	defined(HAVE_STRERROR)
X#define SYSERR			strerror(errno)
X#else
Xextern char *sys_errmsg[];
X#define SYSERR	 		sys_errlist[errno]
X#endif	/* HAVE_STRERROR */
X
X#ifndef MAXHOSTNAMLEN
X#define MAXHOSTNAMLEN 		256
X#endif
X
X#define MBYTES			1048576			/* Megabytes */
X
X/*
X * Misc macros
X */
X#define EQ(a,b)			(strcasecmp(a,b)==0)
X#define EQN(a,b,n)		(strncasecmp(a,b,n)==0)
X
X/*
X * CheckNlist() breaks in a variety of ways on
X * various OS's.
X */
X#if 	!defined(BROKEN_NLIST_CHECK)
X#define CheckNlist(p) 		_CheckNlist(p)
X#else
X#define CheckNlist(p) 		0
X#endif
X
X/*
X * Get nlist n_name
X */
X#if	defined(__MACH__)
X#define GetNlName(n)		(n.n_un.n_name)
X#define GetNlNamePtr(n)		(n->n_un.n_name)
X#else
X#define GetNlName(n)		(n.n_name)
X#define GetNlNamePtr(n)		(n->n_name)
X#endif	/* __MACH__ */
X
X/*
X * Conversion macros
X */
X#define bytes_to_mbytes(n)	((float) n / (float) 1048576)
X#define bytes_to_kbytes(n)	((u_long)(n / 1024))
X#define mbytes_to_bytes(n)	((u_long)((u_long) n * 1048576))
X#define kbytes_to_mbytes(n)	((u_long)((u_long) n * 1024))
X#define nsect_to_bytes(n,s)  	((((float) n) / (float) (1024 / s)) * 1024)
X
X/*
X * Are flags f set in b?
X */
X#define FLAGS_ON(b,f)		((b != 0) && (b & f))
X
X/*
X * Verbosity levels
X */
X#define L_BRIEF			0x01		/* Briefest */
X#define L_GENERAL		0x02		/* General verbosity */
X#define L_DESC			0x04		/* Description info */
X#define L_CONFIG		0x10		/* Configuratin info */
X#define L_DEBUG			0x20		/* Debug info */
X#define L_ALL (L_BRIEF|L_GENERAL|L_DESC|L_CONFIG)
X/*
X * Verbosity macros
X */
X#define VL_BRIEF		(Level & L_BRIEF)
X#define VL_GENERAL		(Level & L_GENERAL)
X#define VL_DESC			(Level & L_DESC)
X#define VL_CONFIG		(Level & L_CONFIG)
X#define VL_ALL			(Level == L_ALL)
X#define VL_DEBUG		(Level & L_DEBUG)
X
X/*
X * Show info
X */
Xstruct ShowInfo {
X    int				Type;
X    char		       *Name;
X    char		       *Label;
X    void		      (*ShowFunc)();
X    char		     *(*GetFunc)();
X    int			       *OptCompat;
X    int				Enable;
X};
Xtypedef struct ShowInfo SHOWINFO;
X
X/*
X * ShowInfo types (ShowInfo.Type)
X */
X#define S_GEN			1		/* General info */
X#define S_DEV			2		/* Device info */
X
X/*
X * Main Device information
X *
X * Used after device info has been obtained 
X */
Xstruct _device {
X    char		*dv_name;		/* Name (e.g. cgtwo0) */
X    char	       **dv_files;		/* Device files */
X    int			 dv_type;		/* Device type (eg DT_TAPE) */
X    char		*dv_model;		/* Model */
X    char		*dv_desc;		/* Description */
X    int			 dv_unit;		/* Unit number */
X    int			 dv_addr;		/* Address */
X    int			 dv_prio;		/* Priority */
X    int			 dv_vec;		/* Vector */
X    char		*dv_mastername;		/* Name of master */
X    caddr_t		*dv_devspec;		/* Device specific info */
X    struct _device	*dv_master;		/* Device controller */
X    struct _device	*dv_slaves;		/* Devices on this device */
X    struct _device	*dv_nxt;		/* Pointer to next device */
X};
Xtypedef struct _device DEVICE;
X
X/*
X * Device types (DEVICE.dv_type)
X */
X#define DT_GENERIC		 1		/* Generic Device */
X#define DT_DISKDRIVE		 2		/* Disk Drive */
X#define DT_DISKCTLR		 3		/* Disk Controller */
X#define DT_TAPEDRIVE		 4		/* Tape Drive */
X#define DT_TAPECTLR		 5		/* Tape Controller */
X#define DT_FRAMEBUFFER		 6		/* Frame Buffer */
X#define DT_NETIF		 7		/* Network Interface */
X#define DT_BUS			 9		/* System Bus */
X#define DT_PSEUDO		10		/* Pseudo Device */
X#define DT_CPU			11		/* CPU */
X
X/*
X * Disk Partition information.
X */
Xstruct _dkpart {
X    char		*dp_name;		/* Partition name */
X    char		*dp_mnt;		/* Mount information */
X    int			 dp_stsect;		/* Starting sector */
X    int			 dp_nsect;		/* Number of sectors */
X    struct _dkpart	*dp_nxt;		/* Pointer to next DISKPART */
X};
Xtypedef struct _dkpart DISKPART;
X
X/*
X * Disk Drive specific data
X */
Xstruct _dkdrive {
X    char		*dd_label;		/* Disk label */
X    int			 dd_unit;		/* Unit number */
X    int			 dd_slave;		/* Slave number */
X    int			 dd_dcyl;		/* # data cylinders */
X    int			 dd_pcyl;		/* # physical cylinders */
X    int			 dd_acyl;		/* # alternate cylinders */
X    int			 dd_heads;		/* Number of heads */
X    int			 dd_sect;		/* Number of sectors */
X    int			 dd_psect;		/* Number of physical sector */
X    int			 dd_promrev;		/* PROM Revision */
X    int			 dd_apc;		/* Alternates / Cyl (SCSI) */
X    int			 dd_rpm;		/* Revolutions Per Minute */
X    int			 dd_intrlv;		/* Interleave factor */
X    int			 dd_secsize;		/* Size of Sector (bytes) */
X    u_long		 dd_size;		/* Size of disk in bytes */
X    int			 dd_flags;		/* Info flags */
X    DEVICE		*dd_ctlr;		/* Controller disk is on */
X    struct _dkpart	*dd_part;		/* Partition information */
X    struct _dkdrive	*dd_nxt;		/* Pointer to next disk */
X};
Xtypedef struct _dkdrive DISKDRIVE;
X
X/*
X * Disk Flags (DISKDRIVE.dd_flags)
X */
X#define DF_HEXUNIT	0x01			/* Unit is prt 3 hex digits */
X
X/*
X * Generic Name/Value table
X */
Xstruct _nametab {
X    int			value;			/* Value field */
X    char       	       *name;			/* Corresponding name */
X    char       	       *valuestr;		/* Value string field */
X};
Xtypedef struct _nametab NAMETAB;
X
X/*
X * Disk Controller Table
X */
Xstruct dkctlrtab {
X    u_short			 ct_ctype;	/* Ctlr type index */
X    char			*ct_model;	/* Ctlr model name */
X    int				 ct_rdcmd;	/* Read command flag */
X};
Xtypedef struct dkctlrtab DKCTLRTAB;
X
X/*
X * FrameBuffer specific data
X */
Xstruct _framebuffer {
X    int			 fb_height;		/* Height (in pixels) */
X    int			 fb_width;		/* Width (in pixels) */
X    int			 fb_depth;		/* Depth (bits/pixel) */
X    u_long		 fb_size;		/* Total size (in bytes) */
X    u_long		 fb_vmsize;		/* Video memory (in bytes) */
X    int			 fb_cmsize;		/* Color Map Size (#entries) */
X};
Xtypedef struct _framebuffer FRAMEBUFFER;
X
X/*
X * Network Interface specific data
X */
Xstruct _netif {
X    char		*ni_typename;		/* Name of address type */
X    char		*ni_hostaddr;		/* Host address */
X    char		*ni_hostname;		/* Host name */
X    char		*ni_macaddr;		/* MAC address */
X    char		*ni_macname;		/* MAC name */
X    char		*ni_netaddr;		/* Network address */
X    char		*ni_netname;		/* Network name */
X    struct _netif	*ni_nxt;		/* Pointer to next element */
X};
Xtypedef struct _netif NETIF;
X
X/*
X * Address family table
X */
Xstruct _aftab {
X    int			af_type;		/* Type value */
X    char	       *af_name;		/* Name value */
X    NETIF	     *(*af_getnetif)();		/* Function to get netif */
X};
Xtypedef struct _aftab AFTAB;
X
X/*
X * Table of devices
X */
Xstruct devicetab {
X    int			 d_type;		/* Device type */
X    char	       **d_list;		/* List of devices */
X    DEVICE	      *(*d_query)();		/* Query function */
X};
X
X/*
X * Basic device data
X *
X * Used when searching for initial list of devices
X */
Xstruct _devdata {
X    char		*dd_devname;		/* Name of device */
X    int			 dd_devunit;		/* Device specific unit # */
X    int			 dd_slave;		/* Slave number */
X    char		*dd_ctlrname;		/* Name of Controller */
X    int			 dd_ctlrunit;		/* Controller # */
X    int			 dd_flags;		/* Device flags */
X};
Xtypedef struct _devdata DEVDATA;
X
X/*
X * Flags for DEVDATA.dd_flags
X */
X#define DD_MAYBE_ALIVE	0x1			/* Device may be alive */
X#define DD_IS_ALIVE	0x2			/* Device is alive */
X
X/*
X * Device Data Table structure
X */
Xstruct _devdatatab {
X    char		*ddt_name;		/* Name of device */
X    int			 ddt_type;		/* Type of device */
X    char		*ddt_model;		/* Model */
X    char		*ddt_desc;		/* Description */
X    DEVICE	      *(*ddt_probe)();		/* Probe device */
X};
Xtypedef struct _devdatatab DEVDATATAB;
X
X/*
X * Declarations
X */
Xextern int 			DoPrintUnknown;
Xextern int 			Debug;
Xextern int 			Level;
X
Xchar 			       *index();
Xchar		 	       *rindex();
Xchar 			       *strdup();
Xchar 			       *strcat();
Xchar 			       *strtok();
X
Xchar			       *itoa();
Xchar	 		       *xmalloc();
Xchar	 		       *xcalloc();
X
Xextern DEVDATATAB	       *GetDevDataTab();
Xextern DEVICE	 	       *NewDevice();
Xextern DEVICE	 	       *ProbeCPU();
Xextern DEVICE	 	       *ProbeDiskDrive();
Xextern DEVICE	 	       *ProbeFrameBuffer();
Xextern DEVICE	 	       *ProbeGeneric();
Xextern DEVICE	 	       *ProbeNetif();
Xextern DEVICE	 	       *ProbeTapeDrive();
Xextern DEVICE 		       *MkMasterFromDevData();
Xextern DEVICE 		       *ProbeDevice();
Xextern DEVICE 		       *ProbeUnknown();
Xextern DISKDRIVE               *NewDiskDrive();
Xextern DISKPART  	       *NewDiskPart();
Xextern FRAMEBUFFER 	       *NewFrameBuffer();
Xextern NETIF	 	       *NewNetif();
Xextern char		       *GetHostName();
Xextern char		       *GetKernArch();
Xextern char		       *GetKernArchName();
Xextern char		       *GetKernelVersionFromVersion();
Xextern char		       *GetKernelVersionStr();
Xextern char		       *GetModelName();
Xextern char		       *GetNameTabName();
Xextern char		       *GetOSNameStr();
Xextern char		       *GetOSVersionStr();
Xextern char		       *GetSerialNoStr();
Xextern char		       *MkDevName();
Xextern char		       *RunCmds();
Xextern char		       *RunTestFiles();
Xextern char	 	       *GetAppArchFromHostInfo();
Xextern char	 	       *GetCpuTypeFromHostInfo();
Xextern char	 	       *GetKernArchFromHostInfo();
Xextern char	 	       *GetKernelVersionFromHostInfo();
Xextern char	 	       *GetMemoryFromHostInfo();
Xextern char	 	       *GetMemoryFromPhysmem();
Xextern char	 	       *GetModelFromHostInfo();
Xextern char	 	       *GetOSNameFromUname();
Xextern char	 	       *GetOSVersionFromHostInfo();
Xextern char	 	       *GetOSVersionFromKernVer();
Xextern char	 	       *GetOSVersionFromUname();
Xextern char	 	       *MkDevName();
Xextern char 		       *GetAppArch();	
Xextern char 		       *GetCPU();
Xextern char 		       *GetCharFile();
Xextern char 		       *GetHostAddrs();
Xextern char 		       *GetHostAliases();
Xextern char 		       *GetHostID();
Xextern char 		       *GetKernelVersion();
Xextern char 		       *GetMan();
Xextern char 		       *GetMemory();
Xextern char 		       *GetModel();
Xextern char 		       *GetOSName();
Xextern char 		       *GetOSVersion();
Xextern char 		       *GetRawFile();
Xextern char 		       *GetRomVer();
Xextern char 		       *GetSerialNo();
Xextern int		        AddDevice();
Xextern void			Error();
Xextern void		        ShowDevices();
Xextern void 		        ShowGeneral();
X
X#if	defined(HAVE_KVM)
Xextern kvm_t 		       *KVM_open();
Xextern void			KVM_close();
Xextern int			KVM_read();
X#endif	/* HAVE_KVM */
X
X#endif /* __sysinfo_defs__ */
END_OF_defs.h
if test 13978 -ne `wc -c <defs.h`; then
    echo shar: \"defs.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f netif.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"netif.c\"
else
echo shar: Extracting \"netif.c\" \(9874 characters\)
sed "s/^X//" >netif.c <<'END_OF_netif.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/netif.c,v 1.18 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: netif.c,v $
X * Revision 1.18  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.17  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.16  1992/04/16  02:25:39  mcooper
X * Bug fixes, de-linting, and other changes found with CodeCenter.
X *
X * Revision 1.15  1992/03/31  01:55:17  mcooper
X * Use new CheckNlist to check nlist success.
X *
X * Revision 1.14  1992/03/31  00:15:09  mcooper
X * Add error check for nlist.n_type.
X *
X * Revision 1.13  1992/03/28  21:29:38  mcooper
X * Initial port to NeXT.  Only works partially.
X *
X * Revision 1.12  1992/03/22  00:20:10  mcooper
X * Major cleanup and re-org.
X *
X * Revision 1.11  1992/03/09  01:24:05  mcooper
X * Remove HAVE_NIT stuff.
X *
X * Revision 1.10  1992/03/08  23:09:18  mcooper
X * - Cleanup set_macinfo() code to support Ultrix packetfilter.
X * - Pass device down to set_macinfo().
X *
X * Revision 1.9  1992/03/08  04:53:39  mcooper
X * Major re-write to clean things up and add better
X * support for multiple addresses per interface.
X *
X * Revision 1.8  1992/03/05  22:36:35  mcooper
X * Cleanup format.
X *
X * Revision 1.7  1992/03/05  22:11:02  mcooper
X * Cleanup variable declarations.
X *
X * Revision 1.6  1992/02/25  23:36:58  mcooper
X * Remove NULL garbage at end of source file.
X *
X * Revision 1.5  1992/02/25  03:08:43  mcooper
X * Fix gethostbyaddr() stuff for sun3/sun386.
X *
X * Revision 1.4  1992/02/25  00:16:57  mcooper
X * Use new mkmaster_from_devdata().
X *
X * Revision 1.3  1992/02/22  02:20:19  mcooper
X * Major changes to support scanning kernel mainbus and
X * openprom data for device's.
X *
X * Revision 1.2  1992/02/20  04:15:16  mcooper
X * Update known interfaces.
X *
X * Revision 1.1  1992/02/16  22:48:39  mcooper
X * Initial revision
X *
X */
X
X
X/*
X * Portions of code found in this file are based on the 4.3BSD 
X * netstat(8) program.
X */
X
X/*
X * Network Interface routines
X */
X
X#include <stdio.h>
X#include "system.h"
X
X#include <fcntl.h>
X#include <nlist.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#if	defined(NEED_SOCKIO)
X#include <sys/sockio.h>
X#endif	/* NEED_SOCKIO */
X#include <sys/param.h>
X#include <sys/errno.h>
X#include <net/if.h>
X#include <netinet/in.h>
X#include <netinet/in_var.h>
X#include <netinet/if_ether.h>
X#include <netdb.h>
X
X#include "defs.h"
X
X/*
X * Network Interface name list
X */
Xstruct nlist NetifNL[] = {
X#if	defined(COFF)
X    { "ifnet" },
X#else
X    { "_ifnet" },
X#endif	/* COFF */
X    { 0 },
X};
X
Xstatic struct netent 	       *GetNet();
Xstatic void 			SetMacInfo();
X
X/*
X * Interface Address union
X */
Xunion {
X    struct ifaddr 	ifa;
X    struct in_ifaddr 	in;
X} 				ifaddr;
X
X/*
X * Create a DEVICE for a network interface.
X */
Xstatic DEVICE *CreateNetif(FullName, IfNet, DevData, DevDataTab)
X    char		       *FullName;
X    struct ifnet               *IfNet;
X    DEVDATA		       *DevData;
X    DEVDATATAB		       *DevDataTab;
X{
X    DEVICE		       *dev;
X
X    dev = NewDevice(NULL);
X
X    dev->dv_name 	= strdup(FullName);
X    dev->dv_type 	= DT_NETIF;
X    dev->dv_unit 	= IfNet->if_unit;
X    dev->dv_master 	= MkMasterFromDevData(DevData);
X
X#if	defined(HAVE_IF_VERSION)
X    if (IfNet->if_version && IfNet->if_version[0])
X	dev->dv_model 	= strdup(IfNet->if_version);
X    else
X#endif	/* HAVE_IF_VERSION */
X	dev->dv_model 	= DevDataTab->ddt_model;
X
X    dev->dv_desc 	= DevDataTab->ddt_desc;
X
X    return(dev);
X}
X
X/*
X * Get NETIF for an Internet address
X */
Xextern NETIF *GetNetifINET(aftab)
X    AFTAB		       *aftab;
X{
X    struct in_addr		in_addr;
X    struct netent 	       *np;
X    struct hostent 	       *hp;
X    struct sockaddr_in 	       *sin;
X    char		       *inet_ntoa();
X    NETIF		       *ni;
X
X    ni = NewNetif(NULL);
X
X    np = GetNet(htonl(ifaddr.in.ia_subnet), ifaddr.in.ia_subnetmask);
X    in_addr.s_addr = ntohl(ifaddr.in.ia_subnet);
X    ni->ni_netaddr = strdup(inet_ntoa(in_addr));
X    if (np)
X	ni->ni_netname = strdup(np->n_name);
X	    
X    sin = (struct sockaddr_in *)&ifaddr.in.ia_addr;
X    ni->ni_hostaddr = strdup(inet_ntoa(sin->sin_addr));
X    hp = gethostbyaddr((char *) &(sin->sin_addr),
X		       sizeof(struct in_addr),
X		       AF_INET);
X    if (hp)
X	ni->ni_hostname = strdup(hp->h_name);
X
X    if (aftab)
X	ni->ni_typename = aftab->af_name;
X
X    return(ni);
X}
X
X/*
X * Get NETIF for an unknown address type
X */
Xextern NETIF *GetNetifUnknown(aftab)
X    AFTAB		       *aftab;
X{
X    NETIF		       *ni = NULL;
X
X    ni = NewNetif(NULL);
X    ni->ni_hostaddr = "<unknown>";
X    if (aftab) {
X	ni->ni_typename = aftab->af_name;
X    }
X
X    return(ni);
X}
X
X/*
X * Get an Address Family table entry
X */
Xstatic AFTAB *GetAFTab(type)
X    int				type;
X{
X    extern AFTAB		AFTab[];
X    register int		i;
X
X    for (i = 0; AFTab[i].af_name; ++i)
X	if (AFTab[i].af_type == type)
X	    return(&AFTab[i]);
X
X    return((AFTAB *) NULL);
X}
X
X/*
X * Get a linked list of NETIF's for each address starting at 'startaddr'.
X */
Xstatic NETIF *GetNetifAddrs(kd, startaddr, FullName, Device)
X    kvm_t		       *kd;
X    off_t			startaddr;
X    char		       *FullName;
X    DEVICE		       *Device;
X{
X    u_long			addr;
X    NETIF		       *base = NULL;
X    register NETIF	       *ni, *pni;
X    AFTAB		       *paftab;
X
X    for (addr = startaddr; addr; addr = (off_t) ifaddr.ifa.ifa_next) {
X	/*
X	 * Read the ifaddr structure from kernel space
X	 */
X	if (KVM_read(kd, addr, (char *) &ifaddr, sizeof(ifaddr))) {
X	    Error("cannot read if address");
X	    continue;
X	}
X
X	/*
X	 * Now get and call the Address Family specific routine
X	 * to extract a NETIF.
X	 */
X	if (paftab = GetAFTab(ifaddr.ifa.ifa_addr.sa_family)) {
X	    if (ni = (*paftab->af_getnetif)(paftab))
X		SetMacInfo(FullName, ni, Device);
X	} else {
X	    if (Debug) Error("Address family %d is not defined.", 
X			     ifaddr.ifa.ifa_addr.sa_family);
X	    continue;
X	}
X
X	/*
X	 * Add the new NETIF to the base of the linked list.
X	 */
X	if (base) {
X	    for (pni = base; pni && pni->ni_nxt; pni = pni->ni_nxt);
X	    pni->ni_nxt = ni;
X	} else {
X	    base = ni;
X	}
X    }
X
X    return(base);
X}
X
X/*
X * Find and set the MAC info
X */
Xstatic void SetMacInfo(DevName, NetIf, Device)
X    char 		       *DevName;
X    NETIF 		       *NetIf;
X    DEVICE		       *Device;	/* ARGSUSED */
X{
X#if	defined(HAVE_NIT)
X    extern void 		SetMacInfoNIT();
X
X    SetMacInfoNIT(DevName, NetIf);
X    return;
X#endif	/* HAVE_NIT */
X
X#if	defined(HAVE_PACKETFILTER)
X    extern void			SetMacInfoPacketFilter();
X
X    SetMacInfoPacketFilter(DevName, NetIf, Device);
X    return;
X#endif	/* HAVE_PACKETFILTER */
X}
X
X/*
X * Return the netent of the network whose address is given.
X * The address is assumed to be that of a net or subnet, not a host.
X */
Xstatic struct netent *GetNet(inaddr, mask)
X    u_long 			inaddr;
X    u_long 			mask;
X{
X    u_long 			net;
X    register u_long 		i, netaddr;
X    int 			subnetshift;
X    static struct in_addr 	in;
X
X    if (in.s_addr = ntohl(inaddr)) {
X	i = in.s_addr;
X	if (mask == 0) {
X	    if (IN_CLASSA(i)) {
X		mask = IN_CLASSA_NET;
X		subnetshift = 8;
X	    } else if (IN_CLASSB(i)) {
X		mask = IN_CLASSB_NET;
X		subnetshift = 8;
X	    } else {
X		mask = IN_CLASSC_NET;
X		subnetshift = 4;
X	    }
X	    /*
X	     * If there are more bits than the standard mask
X	     * would suggest, subnets must be in use.
X	     * Guess at the subnet mask, assuming reasonable
X	     * width subnet fields.
X	     */
X	    while (in.s_addr &~ mask)
X		mask = (long)mask >> subnetshift;
X	}
X	net = in.s_addr & mask;
X	while ((mask & 1) == 0)
X	    mask >>= 1, net >>= 1;
X	netaddr = net;
X    } else {
X	netaddr = inaddr;
X    }
X
X    return(getnetbyaddr(netaddr, AF_INET));
X}
X
X/*
X * Query/find network interface devices and add them to devicelist
X */
Xextern DEVICE *ProbeNetif(name, DevData, DevDataTab)
X    char 		       *name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB	 	       *DevDataTab;
X{
X    DEVICE 		       *dev = NULL;
X    static struct ifnet         ifnet;
X    static char 		ifname[16], FullName[17];
X    register char	       *p;
X    u_long 		        ifnetaddr;
X    kvm_t 		       *kd;
X
X    if (!(kd = KVM_open(NetifNL))) {
X	if (Debug) Error("Cannot read ifnet from kernel");
X	return((DEVICE *) NULL);
X    }
X
X    /*
X     * See if we got a valid entry
X     */
X    if (CheckNlist(&NetifNL[0]))
X	return((DEVICE *) NULL);
X
X    /*
X     * Read address of ifnet structure from kernel space
X     */
X    if (KVM_read(kd, NetifNL[0].n_value, (char *) &ifnetaddr, 
X		 sizeof(ifnetaddr))) {
X	if (Debug) Error("kvm_read ifnetaddr failed");
X	KVM_close(kd);
X	return((DEVICE *) NULL);
X    }
X
X    /*
X     * Read and then check each ifnet entry we found.
X     */
X    for (; ifnetaddr; ifnetaddr = (off_t) ifnet.if_next) {
X	/*
X	 * Read the ifnet structure
X	 */
X	if (KVM_read(kd, ifnetaddr, (char *)&ifnet, sizeof(ifnet))) {
X	    if (Debug) Error("kvm_read ifnetaddr ifnet failed");
X	    continue;
X	}
X
X	/*
X	 * Read if_name from kernel space
X	 */
X	if (KVM_read(kd, (u_long)ifnet.if_name, ifname, sizeof(ifname))) {
X	    if (Debug) Error("kvm_read ifname failed");
X	    continue;
X	}
X
X	/*
X	 * Copy if_name to 'FullName' and add unit number
X	 */
X	strncpy(FullName, ifname, sizeof(ifname));
X	p = (char *) index(FullName, C_NULL);
X	*p++ = ifnet.if_unit + '0';
X	*p = C_NULL;
X	ifname[sizeof(ifname)-1] = C_NULL;
X
X	/*
X	 * Check to see if this is the interface we want.
X	 */
X	if (!EQ(FullName, name))
X	    continue;
X
X	/*
X	 * Create and set device
X	 */
X	dev = CreateNetif(FullName, &ifnet, DevData, DevDataTab);
X
X	/*
X	 * Get and set address info
X	 */
X	if (ifnet.if_addrlist) {
X	    NETIF 	       *ni;
X
X	    if (ni = GetNetifAddrs(kd, (off_t) ifnet.if_addrlist, 
X				   FullName, dev))
X		dev->dv_devspec = (caddr_t *) ni;
X	}
X    }
X
X    KVM_close(kd);
X
X    return(dev);
X}
END_OF_netif.c
if test 9874 -ne `wc -c <netif.c`; then
    echo shar: \"netif.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f info-netif.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"info-netif.c\"
else
echo shar: Extracting \"info-netif.c\" \(2385 characters\)
sed "s/^X//" >info-netif.c <<'END_OF_info-netif.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/info-netif.c,v 1.3 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: info-netif.c,v $
X * Revision 1.3  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.2  1992/03/22  00:20:10  mcooper
X * Major cleanup and re-org.
X *
X * Revision 1.1  1992/03/08  04:55:33  mcooper
X * Initial revision
X *
X */
X
X/*
X * This file contains information specific to network interfaces that
X * will need periodic updating.
X */
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X#include <sys/types.h>
X#include <sys/socket.h>
X
X/*
X * Address family table
X */
XNETIF *GetNetifINET();
XNETIF *GetNetifUnknown();
X
XAFTAB AFTab[] = {
X#ifdef AF_INET
X    {  AF_INET,		"Internet",		GetNetifINET },
X#endif
X#ifdef AF_UNSPEC
X    {  AF_UNSPEC,	"Unspecified",		GetNetifUnknown },
X#endif
X#ifdef AF_DECnet
X    {  AF_DECnet,	"DECnet",		GetNetifUnknown },
X#endif
X#ifdef AF_LAT
X    {  AF_LAT,		"LAT",			GetNetifUnknown },
X#endif
X#ifdef AF_GOSIP
X    {  AF_GOSIP,	"GOSIP",		GetNetifUnknown },
X#endif
X#ifdef AF_PUP
X    {  AF_PUP,		"PUP",			GetNetifUnknown },
X#endif
X#ifdef AF_CHAOS
X    {  AF_CHAOS,	"CHAOS",		GetNetifUnknown },
X#endif
X#ifdef AF_NS
X    {  AF_NS,		"XEROX NS",		GetNetifUnknown },
X#endif
X#ifdef AF_NBS
X    {  AF_NBS,		"NBS",			GetNetifUnknown },
X#endif
X#ifdef AF_ECMA
X    {  AF_ECMA,		"ECMA",			GetNetifUnknown },
X#endif
X#ifdef AF_DATAKIT
X    {  AF_DATAKIT,	"DATAKIT",		GetNetifUnknown },
X#endif
X#ifdef AF_CCITT
X    {  AF_CCITT,	"CCITT",		GetNetifUnknown },
X#endif
X#ifdef AF_LYLINK
X    {  AF_LYLINK,	"LYLINK",		GetNetifUnknown },
X#endif
X#ifdef AF_APPLETALK
X    {  AF_APPLETALK,	"APPLETALK",		GetNetifUnknown },
X#endif
X#ifdef AF_BSC
X    {  AF_BSC,		"BSC",			GetNetifUnknown },
X#endif
X#ifdef AF_DSS
X    {  AF_DSS,		"DSS",			GetNetifUnknown },
X#endif
X#ifdef AF_OSI
X    {  AF_OSI,		"OSI",			GetNetifUnknown },
X#endif
X#ifdef AF_NETMAN
X    {  AF_NETMAN,	"NETMAN",		GetNetifUnknown },
X#endif
X#ifdef AF_X25
X    {  AF_X25,		"X25",			GetNetifUnknown },
X#endif
X    {  0 },
X};
X
END_OF_info-netif.c
if test 2385 -ne `wc -c <info-netif.c`; then
    echo shar: \"info-netif.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f os-mach.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"os-mach.c\"
else
echo shar: Extracting \"os-mach.c\" \(3462 characters\)
sed "s/^X//" >os-mach.c <<'END_OF_os-mach.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/os-mach.c,v 1.4 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: os-mach.c,v $
X * Revision 1.4  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.3  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.2  1992/03/22  01:05:09  mcooper
X * Major cleanup and re-org.
X *
X * Revision 1.1  1992/03/01  23:28:16  mcooper
X * Initial revision
X *
X */
X
X/*
X * Mach specific functions
X */
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X#if	defined(HAVE_HOST_INFO)
X#include <sys/host_info.h>
X
X/*
X * Use the host_info() call to obtain type of CPU.
X */
Xextern char *GetCpuTypeFromHostInfo()
X{
X    extern NAMETAB 		CpuTypeTab[];
X    struct host_basic_info 	basic_info;
X    unsigned int 		count = HOST_BASIC_INFO_COUNT;
X    register int 		i;
X
X    if (host_info(host_self(), HOST_BASIC_INFO, 
X		  (host_info_t) &basic_info, &count) != KERN_SUCCESS) {
X	return((char *)NULL);
X    }
X
X    for (i = 0; CpuTypeTab[i].name; ++i) {
X	if (CpuTypeTab[i].value == basic_info.cpu_type)
X	    return(CpuTypeTab[i].name);
X    }
X
X    return((char *) NULL);
X}
X
X/*
X * Use the host_info() call to obtain the model of CPU.
X */
Xextern char *GetModelFromHostInfo()
X{
X    extern NAMETAB 		ModelTabMach[];
X    struct host_basic_info 	basic_info;
X    unsigned int 		count = HOST_BASIC_INFO_COUNT;
X    register int 		i;
X
X    if (host_info(host_self(), HOST_BASIC_INFO, 
X		  (host_info_t) &basic_info, &count) != KERN_SUCCESS) {
X	return((char *)NULL);
X    }
X
X    for (i = 0; ModelTabMach[i].name; ++i) {
X	if (ModelTabMach[i].value == basic_info.cpu_subtype)
X	    return(ModelTabMach[i].name);
X    }
X
X    return((char *) NULL);
X}
X
X/*
X * Get our application architecture name.
X */
Xextern char *GetAppArchFromHostInfo()
X{
X    return(GetCpuTypeFromHostInfo());
X}
X
X/*
X * Get our kernel architecture name.
X */
Xextern char *GetKernArchFromHostInfo()
X{
X    return(GetCpuTypeFromHostInfo());
X}
X
X/*
X * Get amount of memory.
X */
Xextern char *GetMemoryFromHostInfo()
X{
X    struct host_basic_info 	BasicInfo;
X    unsigned int 		count = HOST_BASIC_INFO_COUNT;
X    static char			Buf[BUFSIZ];
X    int				Amount = -1;
X
X    if (host_info(host_self(), HOST_BASIC_INFO, 
X		  (host_info_t) &BasicInfo, &count) == KERN_SUCCESS) {
X	Amount = BasicInfo.memory_size / MBYTES;
X	(void) sprintf(Buf, "%d MB", Amount);
X	return(Buf);
X    } else
X	return((char *) NULL);
X}
X
X/*
X * Get kernel version string.
X */
Xextern char *GetKernelVersionFromHostInfo()
X{
X    static char 		Version[BUFSIZ];
X    register char 	       *p;
X
X    Version[0] = C_NULL;
X    if (host_kernel_version(host_self(), Version) != KERN_SUCCESS) {
X	if (Debug) Error("host_kernel_version() failed: %s.\n", SYSERR);
X    }
X
X#if	defined(KERNSTR_END)
X    if (Version[0])
X	if ((p = index(Version, KERNSTR_END)) != NULL)
X	    *p = C_NULL;
X#endif	/* KERNSTR_END */
X
X    return((Version[0]) ? Version : (char *) NULL);
X}
X
X/*
X * Get OS version
X */
Xextern char *GetOSVersionFromHostInfo()
X{
X    static char			Buf[BUFSIZ];
X    struct machine_info 	Info;
X
X    if (xxx_host_info(host_self(), (machine_info_t) &Info) == KERN_SUCCESS) {
X	(void) sprintf(Buf, "%d.%d", Info.major_version, Info.minor_version);
X	return(Buf);
X    }
X
X    return((char *) NULL);
X}
X
X#endif	/* HAVE_HOST_INFO */
END_OF_os-mach.c
if test 3462 -ne `wc -c <os-mach.c`; then
    echo shar: \"os-mach.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f info-mach.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"info-mach.c\"
else
echo shar: Extracting \"info-mach.c\" \(4077 characters\)
sed "s/^X//" >info-mach.c <<'END_OF_info-mach.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/info-mach.c,v 1.4 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: info-mach.c,v $
X * Revision 1.4  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.3  1992/03/22  01:05:09  mcooper
X * Major cleanup and re-org.
X *
X * Revision 1.3  1992/03/22  01:05:09  mcooper
X * Major cleanup and re-org.
X *
X * Revision 1.2  1992/03/22  00:20:10  mcooper
X * Major cleanup and re-org.
X *
X * Revision 1.1  1992/03/01  23:28:16  mcooper
X * Initial revision
X *
X */
X
X/*
X * Mach specific information
X */
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X/*
X * Table of system models
X */
XNAMETAB ModelTabMach[] = {
X#if	defined(vax)
X#ifdef CPU_SUBTYPE_VAX780
X    {  CPU_SUBTYPE_VAX780,		"VAX-11/780" },
X#endif
X#ifdef CPU_SUBTYPE_VAX785
X    {  CPU_SUBTYPE_VAX785,		"VAX-11/785" },
X#endif
X#ifdef CPU_SUBTYPE_VAX750
X    {  CPU_SUBTYPE_VAX750,		"VAX-11/750" },
X#endif
X#ifdef CPU_SUBTYPE_VAX730
X    {  CPU_SUBTYPE_VAX730,		"VAX-11/730" },
X#endif
X#ifdef CPU_SUBTYPE_UVAXI
X    {  CPU_SUBTYPE_UVAXI,		"MicroVAX-I" },
X#endif
X#ifdef CPU_SUBTYPE_UVAXII
X    {  CPU_SUBTYPE_UVAXII,		"MicroVAX-II" },
X#endif
X#ifdef CPU_SUBTYPE_VAX8200
X    {  CPU_SUBTYPE_VAX8200,		"VAX-8200" },
X#endif
X#ifdef CPU_SUBTYPE_VAX8500
X    {  CPU_SUBTYPE_VAX8500,		"VAX-8500" },
X#endif
X#ifdef CPU_SUBTYPE_VAX8600
X    {  CPU_SUBTYPE_VAX8600,		"VAX-8600" },
X#endif
X#ifdef CPU_SUBTYPE_VAX8650
X    {  CPU_SUBTYPE_VAX8650,		"VAX-8650" },
X#endif
X#ifdef CPU_SUBTYPE_VAX8800
X    {  CPU_SUBTYPE_VAX8800,		"VAX-8800" },
X#endif
X#ifdef CPU_SUBTYPE_UVAXIII
X    {  CPU_SUBTYPE_UVAXIII,		"MicroVAX-III" },
X#endif
X#endif	/* vax */
X#if	defined(ibm)
X#ifdef CPU_SUBTYPE_RT_PC
X    {  CPU_SUBTYPE_RT_PC,		"RT/PC" },
X#endif
X#ifdef CPU_SUBTYPE_RT_APC
X    {  CPU_SUBTYPE_RT_APC,		"RT/APC" },
X#endif
X#ifdef CPU_SUBTYPE_RT_135
X    {  CPU_SUBTYPE_RT_135,		"RT/135" },
X#endif
X#endif	/* ibm */
X#if	defined(mips)
X#ifdef CPU_SUBTYPE_MIPS_R2300
X    {  CPU_SUBTYPE_MIPS_R2300,		"MIPS R2300" },
X#endif
X#ifdef CPU_SUBTYPE_MIPS_R2600
X    {  CPU_SUBTYPE_MIPS_R2600,		"MIPS R2600" },
X#endif
X#ifdef CPU_SUBTYPE_MIPS_R2800
X    {  CPU_SUBTYPE_MIPS_R2800,		"MIPS R2800" },
X#endif
X#ifdef CPU_SUBTYPE_MIPS_R2000a
X    {  CPU_SUBTYPE_MIPS_R2000a,		"MIPS R2000a" },
X#endif
X#endif	/* mips */
X#if	defined(mc68k)
X#ifdef CPU_SUBTYPE_MC68030
X    {  CPU_SUBTYPE_MC68030,		"MC68030" },
X#endif
X#ifdef CPU_SUBTYPE_MC68040
X    {  CPU_SUBTYPE_MC68040,		"MC68040" },
X#endif
X#endif	/* mc68k */
X#if	defined(hp)
X#ifdef CPU_SUBTYPE_HPPA_825
X    {  CPU_SUBTYPE_HPPA_825,		"9000/825" },
X#endif
X#ifdef CPU_SUBTYPE_HPPA_835
X    {  CPU_SUBTYPE_HPPA_835,		"9000/835" },
X#endif
X#ifdef CPU_SUBTYPE_HPPA_840
X    {  CPU_SUBTYPE_HPPA_840,		"9000/840" },
X#endif
X#ifdef CPU_SUBTYPE_HPPA_850
X    {  CPU_SUBTYPE_HPPA_850,		"9000/850" },
X#endif
X#ifdef CPU_SUBTYPE_HPPA_855
X    {  CPU_SUBTYPE_HPPA_855,		"9000/855" },
X#endif
X#endif	/* hp */
X#if	defined(sun)
X#ifdef CPU_SUBTYPE_SUN4_260
X    {  CPU_SUBTYPE_SUN4_260,		"4/200" },
X#endif
X#ifdef CPU_SUBTYPE_SUN4_110
X    {  CPU_SUBTYPE_SUN4_110,		"4/110" },
X#endif
X#endif	/* sun */
X    {  0 },
X};
X
X/*
X * Table of CPU Types
X */
XNAMETAB CpuTypeTab[] = {
X#ifdef CPU_TYPE_VAX
X    {  CPU_TYPE_VAX,			"VAX" },
X#endif
X#ifdef CPU_TYPE_ROMP
X    {  CPU_TYPE_ROMP,			"ROMP" },
X#endif
X#ifdef CPU_TYPE_NS32032
X    {  CPU_TYPE_NS32032,		"NS32032" },
X#endif
X#ifdef CPU_TYPE_NS32332
X    {  CPU_TYPE_NS32332,		"NS32332" },
X#endif
X#ifdef CPU_TYPE_MC680x0
X    {  CPU_TYPE_MC680x0,		"MC680X0" },
X#endif
X#ifdef CPU_TYPE_I386
X    {  CPU_TYPE_I386,			"i386" },
X#endif
X#ifdef CPU_TYPE_NS32532
X    {  CPU_TYPE_NS32532,		"NS32532" },
X#endif
X#ifdef CPU_TYPE_HPPA
X    {  CPU_TYPE_HPPA,			"HPPA" },
X#endif
X#ifdef CPU_TYPE_ARM
X    {  CPU_TYPE_ARM,			"ARM" },
X#endif
X#ifdef CPU_TYPE_MC88000
X    {  CPU_TYPE_MC88000,		"MC88000" },
X#endif
X#ifdef CPU_TYPE_SPARC
X    {  CPU_TYPE_SPARC,			"SPARC" },
X#endif
X    {  0 },
X};
END_OF_info-mach.c
if test 4077 -ne `wc -c <info-mach.c`; then
    echo shar: \"info-mach.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f os-sunos.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"os-sunos.c\"
else
echo shar: Extracting \"os-sunos.c\" \(38554 characters\)
sed "s/^X//" >os-sunos.c <<'END_OF_os-sunos.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/os-sunos.c,v 1.30 1992/04/26 23:51:53 mcooper Exp $";
X#endif
X
X/*
X * $Log: os-sunos.c,v $
X * Revision 1.30  1992/04/26  23:51:53  mcooper
X * Add some comments.
X *
X * Revision 1.28  1992/04/19  23:17:46  mcooper
X * Suppress CodeCenter warning about "romp".
X *
X * Revision 1.27  1992/04/19  23:07:23  mcooper
X * Update GetRomVer() to be more portable.
X *
X * Revision 1.26  1992/04/18  20:48:18  mcooper
X * Add #ifdef HAVE_SUNROMVEC around GetRomVer.
X *
X * Revision 1.25  1992/04/17  23:27:51  mcooper
X * Add support for ROM Version information (Sun only for now).
X *
X * Revision 1.24  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.23  1992/04/16  02:25:39  mcooper
X * Bug fixes, de-linting, and other changes found with CodeCenter.
X *
X * Revision 1.22  1992/04/15  02:46:34  mcooper
X * - Add better MainBus() and OPENPROM() build debug messages.
X * - Make GetKernArchName() use "cpu" kernel symbol like GetModelName().
X *
X * Revision 1.21  1992/04/15  02:02:17  mcooper
X * Change GetMemoryStr() to GetMemory().
X *
X * Revision 1.20  1992/04/12  22:03:56  mcooper
X * - Change GetModelName() to use kernel symbol "cpu" instead
X *   of gethostid() to be more portable to other SPARC clones.
X * - Update GetKernArchName() to support Solbourne CPU_TYPE.
X * - Add HAVE_IPI kludge for "id" disks.
X * - Various other cleanup bits.
X *
X * Revision 1.19  1992/03/31  01:55:17  mcooper
X * Use new CheckNlist to check nlist success.
X *
X * Revision 1.18  1992/03/31  00:45:27  mcooper
X * Fixed GetKernArchName() to use CPU_ARCH mask.
X *
X * Revision 1.17  1992/03/31  00:15:09  mcooper
X * Add error check for nlist.n_type.
X *
X * Revision 1.16  1992/03/25  03:28:32  mcooper
X * Skip partitions that have 0 size.
X *
X * Revision 1.15  1992/03/25  03:20:14  mcooper
X * Only read partition info we we're going to print it later.
X *
X * Revision 1.14  1992/03/22  00:20:10  mcooper
X * Major cleanup and re-org.
X *
X * Revision 1.13  1992/03/09  01:23:42  mcooper
X * Add need include files for NIT stuff.
X *
X * Revision 1.12  1992/03/08  04:58:30  mcooper
X * Move probe_generic() to devices.c.
X *
X * Revision 1.11  1992/03/06  18:37:26  mcooper
X * Move some general functions to devices.c.
X *
X * Revision 1.10  1992/03/05  22:36:35  mcooper
X * Cleanup format.
X *
X * Revision 1.9  1992/03/05  05:12:10  mcooper
X * Cleanup build_mainbus().
X *
X * Revision 1.8  1992/03/01  23:30:15  mcooper
X * More more SunOS specific code from sysinfo.c to here.
X *
X * Revision 1.7  1992/02/27  22:01:22  mcooper
X * Add support for getting CPU info for sun4m.
X *
X * Revision 1.6  1992/02/27  20:36:52  mcooper
X * Remove \n from error() messages.
X *
X * Revision 1.5  1992/02/26  19:07:21  mcooper
X * Add a debug statement.
X *
X * Revision 1.4  1992/02/25  00:59:35  mcooper
X * Move tape info to local MTINFO.
X *
X * Revision 1.3  1992/02/25  00:17:45  mcooper
X * Lots of fixes and changes.
X *
X * Revision 1.2  1992/02/22  02:30:29  mcooper
X * Fix fbtab stuff.
X *
X * Revision 1.1  1992/02/22  02:20:19  mcooper
X * Initial revision
X *
X * Revision 1.5  1992/02/19  22:30:44  mcooper
X * Fix calling problem.
X *
X * Revision 1.4  1992/02/17  01:00:23  mcooper
X * - More portability and support for solbourne.
X *
X * Revision 1.3  1992/02/17  00:24:22  mcooper
X * Update frame buffers.
X *
X * Revision 1.2  1992/02/16  22:55:44  mcooper
X * Add netif support.
X *
X * Revision 1.1  1991/11/30  23:28:53  mcooper
X * Initial revision
X *
X */
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X#include <mntent.h>
X#include <nlist.h>
X#include <sys/param.h>
X#include <sys/types.h>
X#include <sys/buf.h>
X#include <sys/stat.h>
X#include <sys/mtio.h>
X#include <sun/dkio.h>
X#include <sun/dklabel.h>
X#include <sun/fbio.h>
X
X/*
X * Name of frame buffer "indirect" device.
X */
X#define FBDEVICE	"fb"
X
X/*
X * Name of generic magnetic tape device.
X */
X#define MTNAME		"mt"
X
X/*
X * Generally used variables
X */
Xstatic kvm_t 			*kd = NULL;
Xstatic struct stat 		 StatBuf;
Xstatic DEVICE 			*Device;
Xstatic char 			 Buf[BUFSIZ];
X
X#if	defined(HAVE_MAINBUS)
X/*
X * Build a device tree by searching the MainBus
X */
X#include <sundev/mbvar.h>
X
X#define DV_SIZE	(sizeof(struct mb_device))
X#define DR_SIZE (sizeof(struct mb_driver))
X
X/*
X * Build device tree by looking at mainbus (mb) devices
X */
Xstatic int BuildMainBus(TreePtr)
X    DEVICE 		       **TreePtr;
X{
X    extern struct nlist 	 MainBusNL[];
X    static struct mb_device 	 Device;
X    static struct mb_driver 	 Driver;
X    static char 		 CtlrName[BUFSIZ], DevName[BUFSIZ];
X    static DEVDATA 		 DevData;
X    u_long 			 Addr, DeviceAddr;
X    DEVICE 			*Dev;
X
X    /*
X     * Read table address from kernel
X     */
X    if (!(kd = KVM_open(MainBusNL))) {
X	if (Debug) Error("Cannot open & nlist mainbus device table.");
X	return(-1);
X    }
X
X    /*
X     * See if we got a valid entry
X     */
X    if (CheckNlist(&MainBusNL[0]))
X	return(-1);
X
X    /*
X     * Read each device table entry.  A NULL device.mb_driver
X     * indicates that we're at the end of the table.
X     */
X    for (DeviceAddr = MainBusNL[0].n_value; DeviceAddr; 
X	 DeviceAddr += DV_SIZE) {
X
X	/*
X	 * Read this device
X	 */
X	if (KVM_read(kd, DeviceAddr, (char *) &Device, DV_SIZE)) {
X	    if (Debug) 
X		Error("Cannot read mainbus device from address 0x%x.", 
X		      DeviceAddr);
X	    KVM_close(kd);
X	    return(-1);
X	}
X
X	/*
X	 * See if we're done.
X	 */
X	if (!Device.md_driver)
X	    break;
X
X	/*
X	 * Read the driver structure
X	 */
X	Addr = (u_long) Device.md_driver;
X	if (KVM_read(kd, Addr, (char *) &Driver, DR_SIZE)) {
X	    if (Debug) 
X		Error("Cannot read driver for mainbus address 0x%x.", Addr);
X	    continue;
X	}
X
X	/*
X	 * Get the device name
X	 */
X	if (Addr = (u_long) Driver.mdr_dname) {
X	    if (KVM_read(kd, Addr, (char *) DevName, sizeof(DevName))) {
X		if (Debug)
X		    Error("Cannot read device name from address 0x%x.", Addr);
X		continue;
X	    }
X	} else
X	    DevName[0] = C_NULL;
X
X	/*
X	 * Get the controller name
X	 */
X	if (Addr = (u_long) Driver.mdr_cname) {
X	    if (KVM_read(kd, Addr, (char *) CtlrName, sizeof(CtlrName))) {
X		if (Debug)
X		    Error(
X		      "Cannot read controller name from address 0x%x.", Addr);
X		continue;
X	    }
X	} else
X	    CtlrName[0] = C_NULL;
X
X	/* Make sure devdata is clean */
X	bzero(&DevData, sizeof(DEVDATA));
X
X	/* Set what we know */
X	if (DevName[0]) {
X	    DevData.dd_devname = strdup(DevName);
X	    DevData.dd_devunit = Device.md_unit;
X	}
X	if (CtlrName[0]) {
X	    DevData.dd_ctlrname = strdup(CtlrName);
X	    DevData.dd_ctlrunit = Device.md_ctlr;
X	}
X	/* 
X	 * Mainbus devices such, as SCSI targets, may not exist
X	 * but the controller reports them as present
X	 */
X	if (Device.md_alive)
X	    DevData.dd_flags |= DD_MAYBE_ALIVE;
X
X	if (Debug)
X	    printf("MainBus: Found \"%s\" (Unit %d) on \"%s\" (Unit %d) %s\n", 
X		   DevData.dd_devname, DevData.dd_devunit,
X		   DevData.dd_ctlrname, DevData.dd_ctlrunit,
X		   (DevData.dd_flags & DD_MAYBE_ALIVE) ? "[MAYBE-ALIVE]" : "");
X
X	/* Probe and add device */
X	if (Dev = ProbeDevice(&DevData, TreePtr))
X	    AddDevice(Dev, TreePtr);
X    }
X
X    KVM_close(kd);
X    return(0);
X}
X#endif	/* HAVE_MAINBUS */
X
X#if 	defined(HAVE_OPENPROM)
X/*
X * OpenPROM stuff
X */
X#include <sun/openprom.h>
X
X/*
X * Build device tree by looking at OpenPROM (op)
X */
Xstatic int BuildOpenPROM(TreePtr)
X    DEVICE 		      **TreePtr;
X{
X    static struct dev_info 	Root, *PtrRoot;
X    extern struct nlist 	OpenPROMNL[];
X    u_long 			Addr;
X
X    if (!(kd = KVM_open(OpenPROMNL))) {
X	if (Debug) Error("Cannot open kernel and read openprom devinfo");
X	return(-1);
X    }
X
X    /*
X     * See if we got a valid entry
X     */
X    if (CheckNlist(&OpenPROMNL[0]))
X	return(-1);
X
X    /*
X     * Read pointer to "top_devinfo" from kernel
X     */
X    Addr = OpenPROMNL[0].n_value;
X    if (KVM_read(kd, Addr, (char *) &PtrRoot, sizeof(struct dev_info *))) {
X	if (Debug) Error("Cannot read openprom devinfo pointer from kernel");
X	return(-1);
X    }
X
X    if (KVM_read(kd, (u_long)PtrRoot, (char *)&Root, 
X		 sizeof(struct dev_info))) {
X	if (Debug) Error("Cannot read openprom devinfo root from kernel");
X	return(-1);
X    }
X
X    return(OpenPROMTraverse(&Root, NULL, TreePtr));
X}
X
X/*
X * Check an OpenPROM device.
X */
Xstatic int CheckOpenPROMDevice(DevInfo, Parent, TreePtr)
X    struct dev_info 		*DevInfo;
X    struct dev_info 		*Parent;
X    DEVICE 		       **TreePtr;
X{
X    static DEVDATA 		 DevData;
X    DEVICE 			*Device;	
X
X    /* Make sure devdata is clean */
X    bzero(&DevData, sizeof(DEVDATA));
X
X    /* Set what we know */
X    if (DevInfo && DevInfo->devi_name) {
X	DevData.dd_devname = DevInfo->devi_name;
X	DevData.dd_devunit = DevInfo->devi_unit;
X    }
X    if (Parent && Parent->devi_name) {
X	DevData.dd_ctlrname = Parent->devi_name;
X	DevData.dd_ctlrunit = Parent->devi_unit;
X    }
X    /* 
X     * OpenPROM nodes that have a driver ALWAYS exist.
X     * Some nodes may exist, without a driver, however.
X     */
X    if (DevInfo->devi_driver)
X	DevData.dd_flags |= DD_IS_ALIVE;
X
X    if (Debug)
X	printf("OPENPROM: Found \"%s\" (Unit %d) on \"%s\" (Unit %d) %s\n", 
X	       DevData.dd_devname, DevData.dd_devunit,
X	       DevData.dd_ctlrname, DevData.dd_ctlrunit,
X	       (DevData.dd_flags & DD_IS_ALIVE) ? "[ALIVE]" : "");
X
X    /* Probe and add device */
X    if (Device = (DEVICE *) ProbeDevice(&DevData, TreePtr))
X	AddDevice(Device, TreePtr);
X}
X
X/*
X * Recursively traverse and descend the OpenPROM devinfo tree.
X */
Xstatic int OpenPROMTraverse(DevPtr, Parent, TreePtr)
X    struct dev_info 		*DevPtr;
X    struct dev_info 		*Parent;
X    DEVICE 		       **TreePtr;
X{
X    static char 		 Name[BUFSIZ];
X    struct dev_info 		*Ptr;
X
X    /*
X     * If node name is a valid pointer, read the name from kernel space
X     * and call openprom_probe to handle checking the device.
X     */
X    if (DevPtr->devi_name) {
X	if (KVM_read(kd, (u_long) DevPtr->devi_name, (char *) Name, 
X		     sizeof(Name))) {
X	    Error("Cannot read openprom device name.");
X	    Name[0] = C_NULL;
X	} else {
X	    DevPtr->devi_name = (char *) strdup(Name);
X	    CheckOpenPROMDevice(DevPtr, Parent, TreePtr);
X	}
X    }
X
X    /*
X     * If this node has slaves, read the slave data from kernel space
X     * and descend.
X     */
X    if (DevPtr->devi_slaves) {
X	Ptr = (struct dev_info *) xcalloc(1, sizeof(struct dev_info));
X	if (KVM_read(kd, (u_long) DevPtr->devi_slaves, (char *) Ptr,
X		     sizeof(struct dev_info))) {
X	    Error("Cannot read openprom slave data for %s.", Name);
X	} else {
X	    DevPtr->devi_slaves = (struct dev_info *) Ptr;
X	    OpenPROMTraverse(DevPtr->devi_slaves, DevPtr, TreePtr);
X	}
X    }
X
X    /*
X     * If this node has a next pointer, read the next data from kernel space
X     * and traverse.
X     */
X    if (DevPtr->devi_next) {
X	Ptr = (struct dev_info *) xcalloc(1, sizeof(struct dev_info));
X	if (KVM_read(kd, (u_long) DevPtr->devi_next, (char *) Ptr,
X		     sizeof(struct dev_info))) {
X	    Error("Cannot read openprom next data for %s.", Name);
X	} else {
X	    DevPtr->devi_next = (struct dev_info *) Ptr;
X	    OpenPROMTraverse(DevPtr->devi_next, Parent, TreePtr);
X	}
X    }
X
X    return(0);
X}
X#endif /* HAVE_OPENPROM */
X
X/*
X * Build device tree using TreePtr.
X * Calls bus and method specific functions to
X * search for devices.
X */
Xextern int BuildDevicesSunOS(TreePtr)
X    DEVICE 		       **TreePtr;
X{
X    int 			 Found = 1;
X
X#if	defined(HAVE_OPENPROM)
X    if (BuildOpenPROM(TreePtr) == 0)
X	Found = 0;
X#endif	/* HAVE_OPENPROM */
X
X#if	defined(HAVE_MAINBUS)
X    if (BuildMainBus(TreePtr) == 0)
X	Found = 0;
X#endif	/* HAVE_MAINBUS */
X
X    return(Found);
X}
X
X/*
X * Scan the Disk Controller table looking for
X * a specific type.
X */
Xstatic DKCTLRTAB *GetDkCtlrTab(DkCtrlType)
X    int 			DkCtrlType;
X{
X    extern DKCTLRTAB 		DkCtlrTab[];
X    register int 		i;
X
X    for (i = 0; DkCtlrTab[i].ct_model; ++i) {
X	if (DkCtrlType == DkCtlrTab[i].ct_ctype)
X	    return(&DkCtlrTab[i]);
X    }
X
X    return((DKCTLRTAB *) NULL);
X}
X
X/*
X * Scan the Frame Buffer table looking for 
X * a specific fb type.
X */
Xstatic NAMETAB *GetFBTab(FBType)
X    int 			FBType;
X{
X    extern NAMETAB 		FBTab[];
X    register int 		i;
X
X    for (i = 0; FBTab[i].name; ++i) {
X	if (FBType == FBTab[i].value)
X	    return(&FBTab[i]);
X    }
X
X    return((NAMETAB *) NULL);
X}
X
X/*
X * Get disk info structure.
X */
Xstatic struct dk_info *GETdk_info(d, file)
X    int 			d;
X    char 		       *file;
X{
X    static struct dk_info 	dk_info;
X
X    if (ioctl(d, DKIOCINFO, &dk_info) < 0) {
X	if (Debug) Error("%s: DKIOCINFO: %s.", file, SYSERR);
X	return(NULL);
X    }
X
X    return(&dk_info);
X}
X
X/*
X * Get disk configuration structure.
X */
Xstatic struct dk_conf *GETdk_conf(d, file)
X    int 			d;
X    char 		       *file;
X{
X    static struct dk_conf 	dk_conf;
X
X    if (ioctl(d, DKIOCGCONF, &dk_conf) < 0) {
X	if (Debug) Error("%s: DKIOCGCONF: %s.", file, SYSERR);
X	return(NULL);
X    }
X
X    return(&dk_conf);
X}
X
X/*
X * Get disk geometry structure.
X */
Xstatic struct dk_geom *GETdk_geom(d, file)
X    int 			d;
X    char 		       *file;
X{
X    static struct dk_geom 	dk_geom;
X
X    if (ioctl(d, DKIOCGGEOM, &dk_geom) < 0) {
X	if (Debug) Error("%s: DKIOCGGEOM: %s.", file, SYSERR);
X	return(NULL);
X    }
X
X    return(&dk_geom);
X}
X
X/*
X * Get disk type structure.
X */
Xstatic struct dk_type *GETdk_type(d, file)
X    int 			d;
X    char 		       *file;
X{
X    static struct dk_type 	dk_type;
X
X    if (ioctl(d, DKIOCGTYPE, &dk_type) < 0) {
X	if (errno != ENOTTY)
X	    if (Debug) Error("%s: DKIOCGTYPE: %s.", file, SYSERR);
X	return(NULL);
X    }
X
X    return(&dk_type);
X}
X
X/*
X * Check the checksum of a disklabel.
X */
Xstatic int DkLblCheckSum(DkLabel)
X    struct dk_label 	       *DkLabel;
X{
X    register short 	       *Ptr, Sum = 0;
X    register short 		Count;
X
X    Count = (sizeof (struct dk_label)) / (sizeof (short));
X    Ptr = (short *)DkLabel;
X
X    /*
X     * Take the xor of all the half-words in the label.
X     */
X    while (Count--)
X	Sum ^= *Ptr++;
X
X    /*
X     * The total should be zero for a correct checksum
X     */
X    return(Sum);
X}
X
X/*
X * Get label information from label on disk.
X * The label is stored in the first sector of the disk.
X * We use the driver specific "read" flag with the DKIOCSCMD
X * ioctl to read the first sector.  There should be a special
X * ioctl to just read the label.
X */
Xstatic struct dk_label *GETdk_label(d, file, dk_info)
X    int 			d;
X    char 		       *file;
X    struct dk_info 	       *dk_info;
X{
X    static struct dk_label 	dk_label;
X    struct dk_cmd 		dk_cmd;
X    struct dkctlrtab 	       *pct;
X
X    if (!file || !dk_info)
X	return((struct dk_label *) NULL);
X
X    if (!(pct = GetDkCtlrTab((int) dk_info->dki_ctype))) {
X	Error("Controller type %d is unknown.", 
X	      dk_info->dki_ctype);
X	return((struct dk_label *) NULL);
X    }
X
X    if (pct->ct_rdcmd < 0) {
X	if (Debug)
X	    Error("Read block on controller type \"%s\" is unsupported.",
X		  pct->ct_model);
X	return((struct dk_label *) NULL);
X    }
X
X    bzero((char *) &dk_cmd, sizeof(dk_cmd));
X    dk_cmd.dkc_cmd = pct->ct_rdcmd;
X    dk_cmd.dkc_flags = DK_SILENT | DK_ISOLATE;
X    dk_cmd.dkc_blkno = (daddr_t)0;
X    dk_cmd.dkc_secnt = 1;
X    dk_cmd.dkc_bufaddr = (char *) &dk_label;
X    dk_cmd.dkc_buflen = SECSIZE;
X
X    if (ioctl(d, DKIOCSCMD, &dk_cmd) < 0) {
X	if (Debug) Error("%s: DKIOCSCMD: %s.", file, SYSERR);
X	return((struct dk_label *) NULL);
X    }
X
X    if (dk_label.dkl_magic != DKL_MAGIC) {
X	Error("%s: Disk not labeled.", file);
X	return((struct dk_label *) NULL);
X    }
X
X    if (DkLblCheckSum(&dk_label)) {
X	Error("%s: Bad label checksum.", file);
X	return((struct dk_label *) NULL);
X    }
X
X    return(&dk_label);
X}
X
X/*
X * Get the name of a disk (i.e. sd0).
X */
Xstatic char *GetDiskName(name, dk_conf, dk_info)
X    char 		       *name;
X    struct dk_conf 	       *dk_conf;
X    struct dk_info 	       *dk_info;
X{
X    if (!dk_conf || !dk_info) {
X	if (name)
X	    return(name);
X	return((char *) NULL);
X    }
X
X#if	defined(DKI_HEXUNIT)
X    if (FLAGS_ON(dk_info->dki_flags, DKI_HEXUNIT))
X	(void) sprintf(Buf, "%s%3.3x", dk_conf->dkc_dname, dk_conf->dkc_unit);
X    else
X#endif 	/* DKI_HEXUNIT */
X	(void) sprintf(Buf, "%s%d", dk_conf->dkc_dname, dk_conf->dkc_unit);
X
X    return(strdup(Buf));
X}
X
X/*
X * Get the name of the controller for a disk.
X */
Xstatic char *GetDkCtlrName(dk_conf)
X    struct dk_conf 	       *dk_conf;
X{
X    if (!dk_conf)
X	return((char *) NULL);
X
X    (void) sprintf(Buf, "%s%d", dk_conf->dkc_cname, dk_conf->dkc_cnum);
X
X    return(strdup(Buf));
X}
X
X/*
X * Get the disk controller model name from a disk.
X */
Xstatic char *GetDkCtlrModel(dk_info)
X    struct dk_info 	       *dk_info;
X{
X    struct dkctlrtab 	       *pct;
X
X    if (!dk_info)
X	return((char *) NULL);
X
X    if (!(pct = GetDkCtlrTab(dk_info->dki_ctype)))
X	return(NULL);
X
X    return(pct->ct_model);
X}
X
X/*
X * Get a disk controller device from disk info.
X */
Xstatic DEVICE *GetDkCtlrDevice(DevData, dk_info, dk_conf)
X    DEVDATA 		       *DevData;
X    struct dk_info 	       *dk_info;
X    struct dk_conf 	       *dk_conf;
X{
X    DEVICE 		       *MkMasterFromDevData();
X    DEVICE 		       *dkctlr;
X
X    if ((dkctlr = NewDevice(NULL)) == NULL)
X	return((DEVICE *) NULL);
X
X    bzero((char *) dkctlr, sizeof(*dkctlr));
X
X    dkctlr->dv_type = DT_DISKCTLR;
X
X    /*
X     * Get name of controller from devdata if available
X     */
X    if (DevData && DevData->dd_ctlrname) {
X	dkctlr = MkMasterFromDevData(DevData);
X    }
X
X    if (dk_conf) {
X	if (!dkctlr->dv_name) {
X	    dkctlr->dv_name = GetDkCtlrName(dk_conf);
X	    dkctlr->dv_unit = dk_conf->dkc_cnum;
X	}
X	dkctlr->dv_addr = dk_conf->dkc_addr;
X	dkctlr->dv_prio = dk_conf->dkc_prio;
X	dkctlr->dv_vec = dk_conf->dkc_vec;
X    }
X
X    if (dk_info) {
X	dkctlr->dv_model = GetDkCtlrModel(dk_info);
X    }
X
X    return(dkctlr);
X}
X
X/*
X * Get disk label info from the extracted dk_label info.
X */
Xstatic char *GetDiskLabel(dk_label)
X    struct dk_label 	       *dk_label;
X{
X    register char 	       *p;
X
X    if (!dk_label)
X	return((char *) NULL);
X
X    (void) strcpy(Buf, dk_label->dkl_asciilabel);
X
X    /*
X     * The label normally has geometry information in it we don't want
X     * to see, so we trim out anything starting with " cyl".
X     */
X    for (p = Buf; p && *p; ++p) {
X	if (*p == ' ' && strncasecmp(p, " cyl", 4) == 0)
X	    *p = C_NULL;
X    }
X
X    return(strdup(Buf));
X}
X
X/*
X * Get filesystem mount info for a partition.
X */
Xstatic char *GetMountInfo(name, part)
X    char 		       *name;
X    char 		       *part;
X{
X    FILE 		       *mf;
X    struct mntent 	       *mntent;
X    char 		       *file;
X
X    if (!name)
X	return((char *) NULL);
X
X    file = GetCharFile(name, part);
X
X    if ((mf = setmntent(MNTTAB, "r")) == NULL) {
X	Error("%s: Cannot open for reading: %s.", MNTTAB, SYSERR);
X	return(NULL);
X    }
X
X    while (mntent = getmntent(mf)) {
X	if (strcmp(mntent->mnt_fsname, file) == 0)
X	    break;
X    }
X
X    endmntent(mf);
X
X    return((mntent) ? mntent->mnt_dir : (char *) NULL);
X}
X
X/*
X * Extract the disk partition info from a disk.
X */
Xstatic DISKPART *ExtractDiskPart(name, part, dk_conf, dk_geom)
X    char 		       *name;
X    char 		       *part;
X    struct dk_conf 	       *dk_conf;
X    struct dk_geom 	       *dk_geom;
X{
X    static DISKPART 		diskpart;
X    struct dk_map 		dk_map;
X    char 		       *file;
X    char 		       *p;
X    int 			d;
X
X    if (!name || !dk_conf || !dk_geom)
X	return((DISKPART *) NULL);
X
X    file = GetRawFile(name, part);
X
X    if (stat(file, &StatBuf) != 0) {
X	if (Debug) Error("%s: No such partition.", file);
X	return((DISKPART *) NULL);
X    }
X
X    if ((d = open(file, O_RDONLY)) < 0) {
X	if (Debug)
X	    Error("%s: Cannot open for read: %s.", file, SYSERR);
X	return((DISKPART *) NULL);
X    }
X
X    if (ioctl(d, DKIOCGPART, &dk_map) != 0) {
X	Error("%s: Cannot extract partition info: %s.", 
X		file, SYSERR);
X	return((DISKPART *) NULL);
X    }
X 
X    (void) close(d);
X
X    /*
X     * Skip empty partitions
X     */
X    if (!dk_map.dkl_nblk) {
X	if (Debug) Error("%s: partition has no size.", file);
X	return((DISKPART *) NULL);
X    }
X
X    bzero((char *) &diskpart, sizeof(DISKPART));
X
X    diskpart.dp_name = strdup(part);
X
X    if (p = GetMountInfo(name, part))
X	diskpart.dp_mnt = strdup(p);
X    /* 
X     * If this is the "b" partition on the root device, 
X     *  then assume it's swap 
X     */
X    else if (dk_conf->dkc_unit == 0 && strcmp(part, "b") == 0)
X	diskpart.dp_mnt = "swap";
X
X    diskpart.dp_stsect = dk_map.dkl_cylno *
X	(dk_geom->dkg_nhead * dk_geom->dkg_nsect);
X    diskpart.dp_nsect = dk_map.dkl_nblk;
X
X    return(&diskpart);
X}
X
X/*
X * Translate disk partition information from basic
X * extracted disk info.
X */
Xstatic DISKPART *GetDiskPart(name, dk_conf, dk_geom)
X    char 		       *name;
X    struct dk_conf 	       *dk_conf;
X    struct dk_geom 	       *dk_geom;
X{
X    extern char 		PartChars[];
X    register DISKPART 	       *pdp, *dp;
X    register int 		i;
X    static char 		pname[2];
X    DISKPART 		       *base = NULL;
X
X    if (!name || !dk_conf || !dk_geom)
X	return((DISKPART *) NULL);
X
X    pname[1] = C_NULL;
X    for (i = 0; PartChars[i]; ++i) {
X	pname[0] = PartChars[i];
X	if (dp = ExtractDiskPart(name, pname, dk_conf, dk_geom)) {
X	    if (base) {
X		for (pdp = base; pdp && pdp->dp_nxt; pdp = pdp->dp_nxt);
X		pdp->dp_nxt = NewDiskPart(dp);
X	    } else {
X		base = NewDiskPart(dp);
X	    }
X	}
X    }
X
X    return(base);
X}
X
X/*
X * Convert all we've learned about a disk to a DEVICE.
X */
Xstatic DEVICE *dkToDiskDevice(name, DevData,
X			      dk_info, dk_label, dk_conf, dk_geom, dk_type)
X    char 		       *name;
X    DEVDATA 		       *DevData;
X    struct dk_info 	       *dk_info;
X    struct dk_label 	       *dk_label;
X    struct dk_conf 	       *dk_conf;
X    struct dk_geom 	       *dk_geom;
X    struct dk_type 	       *dk_type;
X{
X    DEVICE 		       *Device, *dkctlr;
X    DISKDRIVE 		       *diskdrive;
X
X    if ((Device = NewDevice(NULL)) == NULL) {
X	Error("Cannot create new device entry.");
X	return((DEVICE *) NULL);
X    }
X
X    if ((dkctlr = NewDevice(NULL)) == NULL) {
X	Error("Cannot create new dkctlr device entry.");
X	return((DEVICE *) NULL);
X    }
X
X    if ((diskdrive = NewDiskDrive(NULL)) == NULL) {
X	Error("Cannot create new diskdrive entry.");
X	return((DEVICE *) NULL);
X    }
X
X    Device->dv_name = GetDiskName(name, dk_conf, dk_info);
X    Device->dv_type = DT_DISKDRIVE;
X    /*
X     * Only read partition info we we're going to print it later.
X     */
X    if (VL_ALL)
X	diskdrive->dd_part = GetDiskPart(name, dk_conf, dk_geom);
X    diskdrive->dd_label = GetDiskLabel(dk_label);
X    Device->dv_model = diskdrive->dd_label;
X
X    if (dk_conf) {
X	diskdrive->dd_unit = dk_conf->dkc_unit;
X	diskdrive->dd_slave = dk_conf->dkc_slave;;
X    }
X    if (dk_geom) {
X	diskdrive->dd_dcyl = dk_geom->dkg_ncyl;
X	diskdrive->dd_pcyl = dk_geom->dkg_pcyl;
X	diskdrive->dd_acyl = dk_geom->dkg_acyl;
X	diskdrive->dd_heads = dk_geom->dkg_nhead;
X	diskdrive->dd_sect = dk_geom->dkg_nsect;
X	diskdrive->dd_apc = dk_geom->dkg_apc;
X	diskdrive->dd_rpm = dk_geom->dkg_rpm;
X	diskdrive->dd_intrlv = dk_geom->dkg_intrlv;
X    }
X    if (dk_type) {
X	diskdrive->dd_psect = dk_type->dkt_hsect;
X	diskdrive->dd_promrev = dk_type->dkt_promrev;
X    }
X    if (dk_info) {
X#if	defined(DKI_HEXUNIT)
X	if (FLAGS_ON(dk_info->dki_flags, DKI_HEXUNIT))
X	    diskdrive->dd_flags |= DF_HEXUNIT;
X#endif 	/* DKI_HEXUNIT */
X    }
X
X    diskdrive->dd_secsize = SECSIZE;
X    if (diskdrive->dd_dcyl && diskdrive->dd_sect && diskdrive->dd_heads) {
X	static char Buf[BUFSIZ];
X
X	diskdrive->dd_size = nsect_to_bytes(diskdrive->dd_dcyl * 
X					     diskdrive->dd_sect * 
X					     diskdrive->dd_heads, 
X					    diskdrive->dd_secsize);
X
X	(void) sprintf(Buf, "%.2f MB capacity", 
X		       (float) bytes_to_mbytes(diskdrive->dd_size));
X	Device->dv_desc = strdup(Buf);
X    }
X
X    dkctlr = GetDkCtlrDevice(DevData, dk_info, dk_conf);
X
X    Device->dv_devspec = (caddr_t *) diskdrive;
X    Device->dv_master = dkctlr;
X
X    return(Device);
X}
X
X/*
X * Query and learn about a disk.
X */
Xextern DEVICE *ProbeDiskDrive(name, DevData, DevDataTab)
X     /*ARGSUSED*/
X    char 		       *name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB 	     	       *DevDataTab;
X{
X    DEVICE 		       *diskdevice;
X    struct dk_info 	       *dk_info = NULL;
X    struct dk_conf 	       *dk_conf = NULL;
X    struct dk_type 	       *dk_type = NULL;
X    struct dk_label 	       *dk_label = NULL;
X    struct dk_geom 	       *dk_geom = NULL;
X    char 		       *rfile;
X    int 			d;
X
X    if (!name)
X	return((DEVICE *) NULL);
X
X#if	defined(HAVE_IPI)
X    /*
X     * XXX - Kludge for IPI "id" disks.
X     */
X    if (EQ(DevData->dd_devname, "id")) {
X	static char		Buf[BUFSIZ];
X
X	(void) sprintf(Buf, "%s%3.3x", 
X		       DevData->dd_devname, DevData->dd_devunit);
X	name = Buf;
X    }
X#endif	/* HAVE_IPI */
X
X    if (stat(rfile = GetRawFile(name, NULL), &StatBuf) != 0) {
X	/*
X	 * Get the name of the whole disk raw device.
X	 */
X	rfile = GetRawFile(name, "c");
X    }
X
X    if ((d = open(rfile, O_RDONLY)) < 0) {
X	if (Debug) Error("%s: Cannot open for reading: %s.", rfile, SYSERR);
X	/*
X	 * If we know for sure this drive is present and we
X	 * know something about it, then create a minimal device.
X	 */
X	if ((DevDataTab->ddt_model || DevDataTab->ddt_desc) &&
X	    FLAGS_ON(DevData->dd_flags, DD_IS_ALIVE)) {
X	    Device = NewDevice((DEVICE *) NULL);
X	    Device->dv_name = strdup(name);
X	    Device->dv_unit = DevData->dd_devunit;
X	    Device->dv_master = MkMasterFromDevData(DevData);
X	    Device->dv_type = DT_DISKDRIVE;
X	    Device->dv_model = DevDataTab->ddt_model;
X	    Device->dv_desc = DevDataTab->ddt_desc;
X	    return(Device);
X	} else
X	    return((DEVICE *) NULL);
X    }
X
X    if ((dk_conf = GETdk_conf(d, rfile)) == NULL) {
X	if (Debug) Error("%s: get dk_conf failed.", rfile);
X    }
X
X    if ((dk_info = GETdk_info(d, rfile)) == NULL) {
X	if (Debug) Error("%s: get dk_info failed.", rfile);
X    }
X
X    if ((dk_geom = GETdk_geom(d, rfile)) == NULL) {
X	if (Debug) Error("%s: get dk_geom failed.", rfile);
X    }
X
X    if ((dk_label = GETdk_label(d, rfile, dk_info)) == NULL) {
X	if (Debug) Error("%s: get dk_label failed.", rfile);
X    }
X
X    /*
X     * Not all controllers support dk_type
X     */
X    dk_type = GETdk_type(d, rfile);
X
X    close(d);
X
X    if (!(diskdevice = dkToDiskDevice(name, DevData,
X					dk_info, dk_label, 
X					dk_conf, dk_geom, dk_type))) {
X	Error("%s: Cannot convert diskdrive information.", name);
X	return((DEVICE *) NULL);
X    }
X
X    return(diskdevice);
X}
X
X/*
X * Probe a tape device
X */
Xextern DEVICE *ProbeTapeDrive(name, DevData, DevDataTab)
X     /*ARGSUSED*/
X    char 		       *name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB	 	       *DevDataTab;
X{
X    extern NAMETAB		MtInfo[];
X    DEVICE 		       *Device;
X    char 		       *file;
X    char 		       *model = NULL;
X    static char 		Buf[BUFSIZ];
X    struct mtget 		mtget;
X    register int 		i;
X    int 			d;
X
X    file = GetRawFile(name, NULL);
X
X    if ((d = open(file, O_RDONLY)) < 0) {
X	if (Debug)
X	    Error("%s Cannot open for read: %s.", file, SYSERR);
X
X	/*
X	 * --RECURSE--
X	 * If we haven't tried the "mt" name yet, try it now
X	 */
X	if (strncmp(name, MTNAME, strlen(MTNAME)) != 0) {
X	    (void) sprintf(Buf, "%s%d", MTNAME, DevData->dd_devunit);
X	    Device = ProbeTapeDrive(Buf, DevData, DevDataTab);
X	    if (Device)
X		return(Device);
X	}
X
X	/*
X	 * If we know for sure this drive is present and we
X	 * know something about it, then create a minimal device.
X	 */
X	if ((DevDataTab->ddt_model || DevDataTab->ddt_desc) &&
X	    FLAGS_ON(DevData->dd_flags, DD_IS_ALIVE)) {
X	    Device = NewDevice((DEVICE *) NULL);
X	    /* 
X	     * Recreate name from devdata since we might have had to
X	     * call ourself with name "rmt?"
X	     */
X	    (void) sprintf(Buf, "%s%d", DevData->dd_devname, 
X			   DevData->dd_devunit);
X	    Device->dv_name = strdup(Buf);
X	    Device->dv_unit = DevData->dd_devunit;
X	    Device->dv_master = MkMasterFromDevData(DevData);
X	    Device->dv_type = DT_TAPEDRIVE;
X	    Device->dv_model = DevDataTab->ddt_model;
X	    Device->dv_desc = DevDataTab->ddt_desc;
X	    return(Device);
X	} else
X	    return((DEVICE *) NULL);
X    }
X
X    if (ioctl(d, MTIOCGET, &mtget) != 0) {
X	Error("%s: Cannot extract tape status: %s.", file, SYSERR);
X	return((DEVICE *) NULL);
X    }
X
X    (void) close(d);
X
X    model = "unknown";
X
X    for (i = 0; MtInfo[i].name; ++i) {
X	if ((MtInfo[i].value == mtget.mt_type)) {
X	    model = MtInfo[i].name;
X	    break;
X	}
X    }
X
X    /*
X     * Create and set device info
X     */
X    Device = NewDevice(NULL);
X    Device->dv_name = strdup(name);
X    Device->dv_type = DT_TAPEDRIVE;
X    if (model)
X	Device->dv_model = model;
X    else
X	Device->dv_model = DevDataTab->ddt_model;
X    Device->dv_desc = DevDataTab->ddt_desc;
X    Device->dv_unit = DevData->dd_devunit;
X    Device->dv_master = MkMasterFromDevData(DevData);
X
X    return(Device);
X}
X
X/*
X * Probe a CPU.  
X *
X * This function really "fakes" up an entry.
X *
X * Currently the info only comes from the OpenPROM.  We could
X * use the kernel mach_info and mod_info structures, but they
X * don't provide the model of CPU.  Maybe in a future release.
X */
Xextern DEVICE *ProbeCPU(name, DevData, DevDataTab)
X     /*ARGSUSED*/
X    char 		       *name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB	 	       *DevDataTab;
X{
X    static int 			num_cpus = 0;
X
X    Device = NewDevice(NULL);
X    (void) sprintf(Buf, "cpu%d", num_cpus++);
X    Device->dv_name = strdup(Buf);
X    Device->dv_type = DT_CPU;
X    Device->dv_model = strdup(name);
X    Device->dv_desc = DevDataTab->ddt_desc;
X    Device->dv_master = MkMasterFromDevData(DevData);
X
X    return(Device);
X}
X
X/*
X * Probe a FrameBuffer.
X */
Xextern DEVICE *ProbeFrameBuffer(name, DevData, DevDataTab)
X    char 		       *name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB	 	       *DevDataTab;
X{
X    DEVICE 		       *fbdevice;
X    FRAMEBUFFER 	       *fb;
X    NAMETAB 		       *fbtab;
X    struct fbgattr 		fbattr;
X#ifdef FBIOGXINFO
X    struct cg6_info 		cg6_info;
X#endif
X    char 		       *file, Buf[BUFSIZ];
X    int 			d;
X
X    if (!name)
X	return((DEVICE *) NULL);
X
X    /*
X     * Check the device file.  If the stat fails because
X     * the device doesn't exist, trying the default framebuffer
X     * device /dev/fb.
X     */
X    file = GetCharFile(name, NULL);
X    if (stat(file, &StatBuf) != 0) {
X	if (errno == ENOENT && !EQ(name, FBDEVICE)) {
X	    if (Debug) 
X		Error("Framebuffer device %s does not exist.  Trying `fb'.",
X		      name);
X	    return(ProbeFrameBuffer(FBDEVICE, DevData, DevDataTab));
X	}
X    }
X
X    if ((d = open(file, O_RDONLY)) < 0) {
X	if (Debug) Error("%s: Cannot open for reading: %s.", file, SYSERR);
X	return((DEVICE *) NULL);
X    }
X
X    if (ioctl(d, FBIOGATTR, &fbattr) != 0) {
X	if (ioctl(d, FBIOGTYPE, &fbattr.fbtype) != 0) {
X	    if (Debug) Error("%s: FBIOGATTR/FBIOGTYPE: %s.", 
X			     file, SYSERR);
X	    return((DEVICE *) NULL);
X	}
X    }
X
X    Buf[0] = C_NULL;
X#if	defined(FBIOGXINFO)
X    if (ioctl(d, FBIOGXINFO, &cg6_info) == 0) {
X	sprintf(Buf, "SBus Slot %d, Revision %d",
X		cg6_info.slot, cg6_info.boardrev);
X	if (cg6_info.hdb_capable)
X	    (void) strcat(Buf, ", double buffered");
X	else
X	    (void) strcat(Buf, ", single buffered");
X    } else {
X	bzero((char *) &cg6_info, sizeof(struct cg6_info));
X	if (Debug) Error("%s: FBIOGXINFO: %s.", file, SYSERR);
X    }
X#endif 	/* FBIOGXINFO */
X
X    close(d);
X
X    if (!(fb = NewFrameBuffer(NULL))) {
X	Error("Cannot create new frame buffer.");
X	return((DEVICE *) NULL);
X    }
X
X    if (!(fbdevice = NewDevice(NULL))) {
X	Error("Cannot create new frame buffer device entry.");
X	return((DEVICE *) NULL);
X    }
X
X    if (!(fbtab = GetFBTab(fbattr.fbtype.fb_type))) {
X	Error("Device %s is an unknown type (%d) of frame buffer.",
X	      name, fbattr.fbtype.fb_type);
X    }
X
X    fbdevice->dv_name = name;
X    fbdevice->dv_type = DT_FRAMEBUFFER;
X    fbdevice->dv_devspec = (caddr_t *) fb;
X
X    if (Buf[0])
X	fbdevice->dv_desc = strdup(Buf);
X
X    if (fbtab) {
X	fbdevice->dv_model = fbtab->name;
X    } else {
X	fbdevice->dv_model = "UNKNOWN";
X    }
X
X    fb->fb_height = fbattr.fbtype.fb_height;
X    fb->fb_width = fbattr.fbtype.fb_width;
X    fb->fb_depth = fbattr.fbtype.fb_depth;
X    fb->fb_size = fbattr.fbtype.fb_size;
X    fb->fb_cmsize = fbattr.fbtype.fb_cmsize;
X#if	defined(FBIOGXINFO)
X    if (cg6_info.vmsize)
X	fb->fb_vmsize = mbytes_to_bytes(cg6_info.vmsize);
X#endif /* FBIOGXINFO */
X
X    fbdevice->dv_master = MkMasterFromDevData(DevData);
X
X    return(fbdevice);
X}
X
X/*
X * Determine our cpu model name.
X *
X * We lookup the kernel symbol "cpu" instead of using gethostid()
X * because some SPARC vendors do not encode cpu/model info in gethostid().
X */
Xextern char *GetModelName()
X{
X    extern NAMETAB 		ModelTab[];
X    extern struct nlist		CpuNL[];
X    register int 		i;
X    int				Cpu;
X    kvm_t		       *kd;
X
X    if (!(kd = KVM_open(CpuNL))) {
X	if (Debug) Error("Cannot find cpu symbol in kernel.");
X	return((char *) NULL);
X    }
X
X    /*
X     * See if we got a valid entry
X     */
X    if (CheckNlist(&CpuNL[0]))
X	return((char *) NULL);
X
X    if (KVM_read(kd, (u_long) CpuNL[0].n_value, (char *) &Cpu, sizeof(Cpu))) {
X	if (Debug) Error("Cannot read cpu from kernel.");
X	return((char *) NULL);
X    }
X
X    KVM_close(kd);
X
X    for (i = 0; ModelTab[i].name; ++i)
X	if (Cpu == ModelTab[i].value)
X	    return(ModelTab[i].name);
X
X    if (Debug)
X	Error("No model found; CPU = 0x%x.", Cpu);
X
X    return((char *) NULL);
X}
X
X#if 	defined(CPU_ARCH) /* Sun */
X#define	ARCH_MASK CPU_ARCH
X#endif	/* CPU_ARCH */
X#if 	defined(CPU_TYPE) /* Solbourne */
X#define ARCH_MASK CPU_TYPE
X#endif	/* CPU_TYPE */
X/*
X * Determine our kernel architecture name from our hostid.
X */
Xextern char *GetKernArchName()
X{
X#if	defined(ARCH_MASK)
X    extern NAMETAB 		KernArchTab[];
X    extern struct nlist		CpuNL[];
X    kvm_t		       *kd;
X    int				Cpu;
X    register int 		i;
X
X    if (!(kd = KVM_open(CpuNL))) {
X	if (Debug) Error("Cannot find cpu symbol in kernel.");
X	return((char *) NULL);
X    }
X
X    /*
X     * See if we got a valid entry
X     */
X    if (CheckNlist(&CpuNL[0]))
X	return((char *) NULL);
X
X    if (KVM_read(kd, (u_long) CpuNL[0].n_value, (char *) &Cpu, sizeof(Cpu))) {
X	if (Debug) Error("Cannot read cpu from kernel.");
X	return((char *) NULL);
X    }
X
X    KVM_close(kd);
X
X    for (i = 0; KernArchTab[i].name; ++i)
X	if ((Cpu & ARCH_MASK) == KernArchTab[i].value)
X	    return(KernArchTab[i].name);
X
X    if (Debug)
X	Error("Kernel Arch 0x%x not defined; Cpu = 0x%x Mask = 0x%x", 
X	      Cpu & ARCH_MASK, Cpu, ARCH_MASK);
X#endif	/* ARCH_MASK */
X
X    return((char *) NULL);
X}
X
X#if	defined(HAVE_NIT)
X
X#include <sys/time.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <net/if.h>
X#include <net/nit_if.h>
X
X/*
X * Find and set the MAC info using the Network Interface Tap (NIT)
X */
Xextern void SetMacInfoNIT(DevName, NetIf)
X    char 		       *DevName;
X    NETIF 		       *NetIf;
X{
X    register struct sockaddr   *SockAddr;
X    struct ifreq 	        ifreq;
X    char 		       *ether_ntoa(), Buf[MAXHOSTNAMLEN+1];
X    int 		        Desc;
X
X    if (!NetIf)
X	return;
X
X    if ((Desc = open("/dev/nit", O_RDONLY)) == SYSFAIL) {
X	if (Debug) Error("open /dev/nit failed");
X	return;
X    }
X
X    /*
X     * Bind to NIT for DevName
X     */
X    strncpy(ifreq.ifr_name, DevName, sizeof ifreq.ifr_name);
X    if (ioctl(Desc, NIOCBIND, (caddr_t) &ifreq) < 0) {
X	if (Debug) Error("ioctl:  NIOCBIND");
X	return;
X    }
X
X    /*
X     * Get address
X     */
X    if (ioctl(Desc, SIOCGIFADDR, (caddr_t)&ifreq) < 0) {
X	if (Debug) Error("ioctl (SIOCGIFADDR)");
X	return;
X    }
X
X    (void) close(Desc);
X
X    SockAddr = (struct sockaddr *)&ifreq.ifr_addr;
X    NetIf->ni_macaddr = strdup(ether_ntoa((struct ether_addr *) 
X					  SockAddr->sa_data));
X
X    if (ether_ntohost(Buf, (struct ether_addr *) SockAddr->sa_data) == 0)
X	NetIf->ni_macname = strdup(Buf);
X}
X#endif	/* HAVE_NIT */
X
X/*
X * Get kernel version string from kernel symbol "version".
X */
Xextern char *GetKernelVersionStr()
X{
X    return(GetKernelVersionFromVersion());
X}
X
X/*
X * Get amount of physical memory using kernel symbol "physmem".
X */
Xextern char *GetMemory()
X{
X    return(GetMemoryFromPhysmem());
X}
X
X/*
X * Get system serial number
X */
Xextern char *GetSerialNoStr()
X{
X    /* No support */
X    return((char *) NULL);
X}
X
X/*
X * Get name of OS
X */
Xextern char *GetOSNameStr()
X{
X    return(GetOSNameFromUname());
X}
X
X/*
X * Get version of OS
X */
Xextern char *GetOSVersionStr()
X{
X    return(GetOSVersionFromUname());
X}
X
X#if	defined(HAVE_SUNROMVEC)
X/*
X * Be backwards compatible with pre-4.1.2 code
X */
X#include <mon/sunromvec.h>
X#if	defined(OPENPROMS) && !(defined(ROMVEC_VERSION) && \
X				(ROMVEC_VERSION == 0 || ROMVEC_VERSION == 1))
X#define v_mon_id op_mon_id
X#endif
X#endif	/* HAVE_SUNROMVEC */
X
X/*
X * Get ROM Version number
X *
X * If "romp" is "defined" (in <mon/sunromvec.h>), then take that
X * as the address of the kernel pointer to "rom" (struct sunromvec).
X * Otherwise, nlist "romp" from the kernel.
X */
Xextern char *GetRomVer()
X{
X    static char			RomRev[16];
X#if	defined(HAVE_SUNROMVEC)
X    static struct sunromvec	Rom;
X    register char	       *p;
X    register char	       *Addr;
X    kvm_t		       *kd;
X#if	!defined(romp)
X    struct sunromvec	       *romp;
X    extern struct nlist		RomVecNL[];
X
X    if (!(kd = KVM_open(RomVecNL))) {
X	if (Debug) Error("Cannot find romvec symbol in kernel.");
X	return((char *) NULL);
X    }
X
X    /*
X     * See if we got a valid entry
X     */
X    if (CheckNlist(&RomVecNL[0]))
X	return((char *) NULL);
X
X    /*
X     * Read the kernel pointer to the sunromvec structure.
X     */
X    if (KVM_read(kd, (u_long) RomVecNL[0].n_value, (char *) &romp, 
X		 sizeof(romp))) {
X	if (Debug) Error("Cannot read sunromvec pointer from kernel.");
X	return((char *) NULL);
X    }
X
X#else	/* romp */
X
X    if (!(kd = KVM_open((struct nlist *) NULL))) {
X	if (Debug) Error("KVM_open failed.");
X	return((char *) NULL);
X    }
X
X#endif	/* romp */
X
X    /*
X     * Read the sunromvec structure from the kernel
X     */
X    /*SUPPRESS 25*/
X    if (KVM_read(kd, (u_long) romp, (char *) &Rom, sizeof(struct sunromvec))) {
X	if (Debug) Error("Cannot read sunromvec from kernel.");
X	return((char *) NULL);
X    }
X
X#if	!defined(romp)
X
X    /*
X     * XXX Hardcoded values
X     */
X    (void) sprintf(RomRev, "%d.%d", Rom.v_mon_id >> 16, Rom.v_mon_id & 0xFFFF);
X
X#else	/* romp */
X
X    /*
X     * Read the version string from the address indicated by Rom.v_mon_id.
X     * Read 1 byte at a time until '\0' is encountered.
X     */
X    p = RomRev;
X    Addr = Rom.v_mon_id;
X    do {
X	if (KVM_read(kd, (u_long) Addr++, p, 1))
X	    break;
X    } while (p < &RomRev[sizeof(RomRev)-1] && *p++);
X    *p = C_NULL;
X
X#endif	/* romp */
X
X    KVM_close(kd);
X
X#endif	/* HAVE_SUNROMVEC */
X
X    return((RomRev[0]) ? RomRev : (char *) NULL);
X}
END_OF_os-sunos.c
if test 38554 -ne `wc -c <os-sunos.c`; then
    echo shar: \"os-sunos.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f info-sunos.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"info-sunos.c\"
else
echo shar: Extracting \"info-sunos.c\" \(16354 characters\)
sed "s/^X//" >info-sunos.c <<'END_OF_info-sunos.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/info-sunos.c,v 1.19 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: info-sunos.c,v $
X * Revision 1.19  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.18  1992/04/19  18:44:59  mcooper
X * Change around GS framebuffer definition according to Greg Earle.
X *
X * Revision 1.17  1992/04/17  23:33:04  mcooper
X * Add RomVecNL.
X *
X * Revision 1.16  1992/04/17  01:10:11  mcooper
X * Moved DEVICE *() function declares to defs.h.
X *
X * Revision 1.15  1992/04/15  02:42:12  mcooper
X * Change "ipi3sc" to DT_GENERIC.
X *
X * Revision 1.14  1992/04/12  22:03:13  mcooper
X * - Add Tadpole/SPARCbook support.
X * - Add Solbourne models and arch's.
X *
X * Revision 1.13  1992/03/31  00:44:40  mcooper
X * Add sun386 kernel arch.
X *
X * Revision 1.12  1992/03/28  21:29:24  mcooper
X * Move NetifNL to netif.c.
X *
X * Revision 1.11  1992/03/22  00:20:10  mcooper
X * Major cleanup and re-org.
X *
X * Revision 1.10  1992/03/08  04:58:56  mcooper
X * The old NETIFTAB has been removed by placing the old data
X * directly in the devdatatab.
X *
X * Revision 1.9  1992/03/06  18:34:02  mcooper
X * - Use new NAMETAB whenever possible.
X * - Replace _size vars with { 0 } entries.
X *
X * Revision 1.8  1992/03/01  23:30:15  mcooper
X * More more SunOS specific code from sysinfo.c to here.
X *
X * Revision 1.7  1992/02/27  22:01:22  mcooper
X * Add support for getting CPU info for sun4m.
X *
X * Revision 1.6  1992/02/27  20:37:59  mcooper
X * Move netif names in devdatatab to top to avoid conflicts
X * of "fd" and "fddi".
X *
X * Revision 1.5  1992/02/27  00:14:22  mcooper
X * Add "ei" (Solbourne ethernet interface) to devdatatab.
X *
X * Revision 1.4  1992/02/26  19:07:02  mcooper
X * Add more random Sun devices.
X *
X * Revision 1.3  1992/02/25  00:59:35  mcooper
X * Move tape info to local MTINFO.
X *
X * Revision 1.2  1992/02/25  00:23:29  mcooper
X * - Cleanup framebuffers.
X * - Add mt info.
X * - Update device table.
X *
X * Revision 1.1  1992/02/22  02:20:19  mcooper
X * Initial revision
X *
X */
X
X
X/*
X * SunOS specific device info
X */
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X#include <nlist.h>
X#include <sys/types.h>
X#include <sys/buf.h>
X#include <sys/mtio.h>
X#include <sun/dkio.h>
X#include <sun/fbio.h>
X
X#if 	defined(TADPOLE)
X#include <taddev/ide_drvr_def.h>
X#else	/* !TADPOLE */
X#	if 	defined(HAVE_IPI)
X#		include <sundev/ipvar.h>
X#	endif 	/* HAVE_IPI */
X#	include <sundev/xdreg.h>
X#	include <sundev/xyreg.h>
X#	include <sundev/scsi.h>
X#	if 	defined(i386)
X#		include <sundev/sdreg.h>
X#	endif
X#endif	/* TADPOLE */
X
X/*
X * Characters for disk partitions
X */
Xchar PartChars[] = "abcdefgh";
X
X/*
X * CPU (model) symbol
X */
Xstruct nlist CpuNL[] = {
X#if	defined(COFF)
X    { "cpu" },
X#else
X    { "_cpu" },
X#endif	/* COFF */
X    { 0 },
X};
X
X#if	defined(HAVE_MAINBUS)
X/*
X * MainBus name list
X */
Xstruct nlist MainBusNL[] = {
X#if	defined(COFF)
X    { "mbdinit" },
X#else
X    { "_mbdinit" },
X#endif	/* COFF */
X    { 0 },
X};
X#endif	/* HAVE_MAINBUS */
X
X#if	defined(HAVE_OPENPROM)
X/*
X * OpenPROM name list
X */
Xstruct nlist OpenPROMNL[] = {
X#if	defined(COFF)
X    { "top_devinfo" },
X#else
X    { "_top_devinfo" },
X#endif	/* COFF */
X    { 0 },
X};
X#endif	/* HAVE_OPENPROM */
X
X/*
X * RomVec
X */
Xstruct nlist RomVecNL[] = {
X#if	defined(COFF)
X    { "romp" },
X#else
X    { "_romp" },
X#endif	/* COFF */
X    { 0 },
X};
X
X/*
X * Sun system model table
X *
X * Not all values are real machines.  What is found below is
X * extracted from /usr/include/{sun3,sun3x,sun4,sun4c,sun4m}/cpu.h.
X */
XNAMETAB ModelTab[] = {
X/*
X * Sun-3 CPU's
X */
X#ifdef CPU_SUN3_50
X    {  CPU_SUN3_50,	 	"3/50" },
X#endif
X#ifdef CPU_SUN3_60
X    {  CPU_SUN3_60,	 	"3/60" },
X#endif
X#ifdef CPU_SUN3_E
X    {  CPU_SUN3_E,	    	"3/Eurocard" },
X#endif
X#ifdef CPU_SUN3_110
X    {  CPU_SUN3_110,	    	"3/110" },
X#endif
X#ifdef CPU_SUN3_160
X    {  CPU_SUN3_160,	    	"3/100 Series" },
X#endif
X#ifdef CPU_SUN3_260
X    {  CPU_SUN3_260,	    	"3/200 Series" },
X#endif
X
X/*
X * Sun-3x CPU's
X */
X#ifdef CPU_SUN3X_80:
X    {  CPU_SUN3X_80,		"3/80" },
X#endif
X#ifdef CPU_SUN3X_470
X    {  CPU_SUN3X_470,		"3/400 Series" },
X#endif
X
X/*
X * Sun-4c CPU's.
X */
X#ifdef CPU_SUN4C_05:
X    {  CPU_SUN4C_05,		"4/05" },
X#endif
X#ifdef CPU_SUN4C_10:
X    {  CPU_SUN4C_10,		"4/10" },
X#endif
X#ifdef CPU_SUN4C_20:
X    {  CPU_SUN4C_20,		"4/20 (SPARCstation SLC)" },
X#endif
X/*
X * XXX The 4/25 and 4/30 are both ELC's depending on your OS
X */
X#ifdef CPU_SUN4C_25:
X    {  CPU_SUN4C_25,		"4/25 (SPARCstation ELC)" },
X#endif
X#ifdef CPU_SUN4C_30:
X    {  CPU_SUN4C_30,		"4/30 (SPARCstation ELC)" },
X#endif
X#ifdef CPU_SUN4C_32:
X    {  CPU_SUN4C_32,		"4/32" },
X#endif
X#ifdef CPU_SUN4C_40:
X    {  CPU_SUN4C_40,		"4/40 (SPARCstation IPC)" },
X#endif
X#ifdef CPU_SUN4C_45:
X    {  CPU_SUN4C_45,		"4/45" },
X#endif
X#ifdef CPU_SUN4C_50:
X    {  CPU_SUN4C_50,		"4/50 (SPARCstation IPX)" },
X#endif
X#ifdef CPU_SUN4C_60:
X    {  CPU_SUN4C_60,		"4/60 (SPARCstation 1)" },
X#endif
X#ifdef CPU_SUN4C_65:
X    {  CPU_SUN4C_65,		"4/65 (SPARCstation 1+)" },
X#endif
X#ifdef CPU_SUN4C_70:
X    {  CPU_SUN4C_70,		"4/70" },
X#endif
X#ifdef CPU_SUN4C_75:
X    {  CPU_SUN4C_75,		"4/75 (SPARCstation 2)" },
X#endif
X#ifdef CPU_SUN4C_80:
X    {  CPU_SUN4C_80,		"4/80" },
X#endif
X#ifdef CPU_SUN4C_85:
X    {  CPU_SUN4C_85,		"4/85" },
X#endif
X
X/*
X * Sun-4 CPU's
X */
X#ifdef CPU_SUN4_110
X    {  CPU_SUN4_110,	    	"4/110" },
X#endif
X#ifdef CPU_SUN4_260
X    {  CPU_SUN4_260,	    	"SPARCsystem 200" },
X#endif
X#ifdef CPU_SUN4_330
X    {  CPU_SUN4_330,		"SPARCsystem 300" },
X#endif
X#ifdef CPU_SUN4_460	/* Sun changed the 4_460 to 4_470 in 4.1.1 */
X    {  CPU_SUN4_460,		"SPARCsystem 400" },
X#endif
X#ifdef CPU_SUN4_470
X    {  CPU_SUN4_470,		"SPARCsystem 400" },
X#endif
X
X/*
X * Sun-4m CPU's
X */
X#ifdef CPU_SUN4M_690
X    {  CPU_SUN4M_690,	    	"SPARCsystem 600" },
X#endif
X
X/*
X * Sun-386i CPU's
X */
X#ifdef CPU_SUN386_MB1
X    {  CPU_SUN386_MB1,		"386i (MB1)" },
X#endif
X#ifdef CPU_SUN386_150
X    /* The 386i/150 and 386i/250 are the same */
X    {  CPU_SUN386_150,		"386i" },
X#endif
X
X/*
X * Solbourne CPU's
X */
X#ifdef CPU_SERIES4_500
X    {  CPU_SERIES4_500,		"Series4/500" },
X#endif
X#ifdef CPU_SERIES4_600
X    {  CPU_SERIES4_600,		"Series4/600" },
X#endif
X#ifdef CPU_SERIES5_500
X    {  CPU_SERIES5_500,		"Series5/500" },
X#endif
X#ifdef CPU_SERIES5_600
X    {  CPU_SERIES5_600,		"Series5/600" },
X#endif
X#ifdef CPU_SERIES5_900
X    {  CPU_SERIES5_900,		"Series5/900" },
X#endif
X#ifdef CPU_SERIES5E_500
X    {  CPU_SERIES5E_500,	"Series5E/500" },
X#endif
X#ifdef CPU_SERIES5E_600
X    {  CPU_SERIES5E_600,	"Series5E/600" },
X#endif
X#ifdef CPU_SERIES5E_900
X    {  CPU_SERIES5E_900,	"Series5E/900" },
X#endif
X#ifdef CPU_SERIES6_500
X    {  CPU_SERIES6_500,		"Series6/500" },
X#endif
X#ifdef CPU_SERIES6_600
X    {  CPU_SERIES6_600,		"Series6/600" },
X#endif
X#ifdef CPU_SERIES6_900
X    {  CPU_SERIES6_900,		"Series6/900" },
X#endif
X
X/*
X * TadPole CPU's
X */
X#ifdef CPU_TAD_SPBK_S1
X    {  CPU_TAD_SPBK_S1,		"SPARCbook-1" },
X#endif
X
X    { 0 },
X};
X
X/*
X * Kernel Architecture table
X */
XNAMETAB KernArchTab[] = {
X#ifdef SUN386_ARCH
X    {  SUN386_ARCH,		"sun386" },
X#endif
X#ifdef SUN3_ARCH
X    {  SUN3_ARCH,		"sun3" },
X#endif
X#ifdef SUN3X_ARCH
X    {  SUN3X_ARCH,		"sun3x" },
X#endif
X#ifdef SUN4_ARCH
X    {  SUN4_ARCH,		"sun4" },
X#endif
X#ifdef SUN4C_ARCH
X    {  SUN4C_ARCH,		"sun4c" },
X#endif
X#ifdef SUN4M_ARCH
X    {  SUN4M_ARCH,		"sun4m" },
X#endif
X/*
X * Tadpole
X */
X#ifdef TAD_SPBK_ARCH
X    {  TAD_SPBK_ARCH,		"SPARCbook" },
X#endif
X/*
X * Solbourne
X */
X#ifdef CPU_TYPE_SERIES4
X    {  CPU_TYPE_SERIES4,	"Series4" },
X#endif
X#ifdef CPU_TYPE_SERIES5
X    {  CPU_TYPE_SERIES5,	"Series5" },
X#endif
X#ifdef CPU_TYPE_SERIES5E
X    {  CPU_TYPE_SERIES5E,	"Series5E" },
X#endif
X#ifdef CPU_TYPE_SERIES6
X    {  CPU_TYPE_SERIES6,	"Series6" },
X#endif
X#ifdef CPU_TYPE_KAP_M2
X    {  CPU_TYPE_KAP_M2,		"KAP_M2" },
X#endif
X    { 0 },
X};
X
X/*
X * Device Data Table
X *
X * Compares are done by the length of the string appearing in
X * the first columns.  Therefore, longer names must appear before
X * any shorter names that are not unique.  e.g. "lebuffer" needs to
X * be before "le".
X */
XDEVDATATAB DevDataTab[] = {
X    { "ie",		0,	"Intel 82586 LAN Co-Processor",	
X	  			"10Mb/sec Ethernet",	ProbeNetif },
X    { "ei",		0,	"Solbourne IOASIC AMD Lance Am7990",	
X	  			"10Mb/sec Ethernet",	ProbeNetif },
X    { "lebuffer", 	DT_PSEUDO,	NULL,	NULL,	ProbeGeneric },
X    { "le",		0,	"AMD Lance Am7990",
X	  			"10Mb/sec Ethernet",	ProbeNetif },
X    { "ne",		0,	"Interphase NC400",
X	  			"10Mb/sec Ethernet",	ProbeNetif },
X    { "fddi",		0,	"Sun FDDI",
X	  			"100Mb/sec FDDI",	ProbeNetif },
X    { "sd",		0,		NULL,	NULL,	ProbeDiskDrive },
X    { "xd",		0,		NULL,	NULL,	ProbeDiskDrive },
X    { "xy",		0,		NULL,	NULL,	ProbeDiskDrive },
X    { "id",		0,		NULL,	NULL,	ProbeDiskDrive },
X    { "sr",		0,	    "CD-ROM",	NULL,	ProbeDiskDrive },
X    { "fd",		0,	    "Floppy",	NULL,	ProbeDiskDrive },
X    { "bwone",		0,		NULL,	NULL,	ProbeFrameBuffer },
X    { "bwtwo",		0,		NULL,	NULL,	ProbeFrameBuffer },
X    { "cgone",		0,		NULL,	NULL,	ProbeFrameBuffer },
X    { "cgtwo",		0,		NULL,	NULL,	ProbeFrameBuffer },
X    { "cgthree",	0,		NULL,	NULL,	ProbeFrameBuffer },
X    { "cgfour",		0,		NULL,	NULL,	ProbeFrameBuffer },
X    { "cgsix",		0,		NULL,	NULL,	ProbeFrameBuffer },
X    { "cgeight",	0,		NULL,	NULL,	ProbeFrameBuffer },
X    { "cgnine",		0,		NULL,	NULL,	ProbeFrameBuffer },
X    { "cgtwelve",	0,		NULL,	NULL,	ProbeFrameBuffer },
X    { "gpone",		0,		NULL,	NULL,	ProbeFrameBuffer },
X    { "gt",		0,		NULL,	NULL,	ProbeFrameBuffer },
X    { "taac",		0,		NULL,	NULL,	ProbeFrameBuffer },
X    { "vx",		0,		NULL,	NULL,	ProbeFrameBuffer },
X    { "Cypress,CY",	0,		NULL,	"CPU",	ProbeCPU },
X    { "sbus",		DT_BUS,		NULL,	NULL,	ProbeGeneric },
X    { "vme",		DT_BUS,		NULL,	NULL,	ProbeGeneric },
X    { "obio",		DT_BUS,		NULL,	"OnBoard I/O",	
X							ProbeGeneric },
X    { "obmem",		DT_BUS,		NULL,	"OnBoard Memory",
X	  						ProbeGeneric },
X    { "iommu",		DT_BUS,		NULL,	NULL,	ProbeGeneric },
X    { "dma",		DT_PSEUDO,	NULL,	NULL,	ProbeGeneric },
X    { "openprom", 	DT_PSEUDO,	NULL,	NULL,	ProbeGeneric },
X    /* Old OpenPROMs say "Sun 4/60" instead of "SUNW,Sun 4/60" */
X    { "Sun ", 		DT_PSEUDO,	NULL,	NULL,	ProbeGeneric },
X    { "SUNW,Sun", 	DT_PSEUDO,	NULL,	NULL,	ProbeGeneric },
X    { "SUNW,pn", 	DT_PSEUDO,	NULL,	NULL,	ProbeGeneric },
X    { "ipi3sc", 	DT_GENERIC,	NULL,	NULL,	ProbeGeneric },
X    { "esp",		DT_DISKCTLR,	"Emulex SCSI interface",	
X	  NULL,						ProbeGeneric },
X    { "st",		DT_TAPEDRIVE, 	"SCSI",
X	NULL,						ProbeTapeDrive },
X    { "xtc",		DT_TAPECTLR, 	"Xylogics 472",
X	"1/2 inch tape controller", 			ProbeGeneric },
X    { "xt",		DT_TAPEDRIVE, 	"Fujitsu M2444",
X	"1/2 inch tape drive",				ProbeTapeDrive },
X    { "audio", 		DT_GENERIC,	"AM79C30A DSC",	
X	  "telephone quality audio",			ProbeGeneric },
X    { "zs", 		DT_GENERIC,	"Zilog 8530",	
X	  "serial communications chip",			ProbeGeneric },
X    { "mti", 		DT_GENERIC,	"ALM-1 (Systech MTI-1600)",	
X	  "16-line terminal multiplexer",		ProbeGeneric },
X    { "mcp", 		DT_GENERIC,	"ALM-2 (Sun MCP/ALM)",	
X	  "16-line terminal multiplexer",		ProbeGeneric },
X    { "fpa", 		DT_GENERIC,	"Wietek FPA",	
X	  "floating point accelerator",			ProbeGeneric },
X    { "des", 		DT_GENERIC,	"AmZ8068 Data Ciphering Processor",
X	  "NBS Data Encryption Standard",		ProbeGeneric },
X    { "vpc", 		DT_GENERIC,	"Systech VPC-2200",	
X	  "Versatec & Centronics printer/plotter interface", ProbeGeneric },
X    { "pp", 		DT_GENERIC,	"Parallel Port",
X	  "Centronics-compatible parallel printer port", ProbeGeneric },
X    { "SUNW,bpp",	DT_GENERIC,	"SBus Printer Card",
X	  "bidirectional parallel port", 		ProbeGeneric },
X    { "SUNW,lpvi",	DT_GENERIC,	"SBus Printer Card",
X	  "laser printer video interface", 		ProbeGeneric },
X    { "db",		DT_GENERIC,	"Sun Dials Box",
X	  NULL, 	ProbeGeneric },
X    { "pr", 		DT_GENERIC,	"PrestoServe",
X	  "file system accelerator", 			ProbeGeneric },
X    /* 
X     * Tadpole devices
X     */
X    { "nice",		0,	"NICE Ethernet Co-processor",
X	  			"10Mb/sec Ethernet",	ProbeNetif },
X    { "par", 		DT_GENERIC,	"Parallel Port",
X	  "Centronics-compatible parallel printer port", ProbeGeneric },
X    { "modem", 		DT_GENERIC,	NULL,
X	  "Hayes compatible modem", 			ProbeGeneric },
X    { "urt", 		DT_GENERIC,	NULL,	
X	  "serial communications chip",			ProbeGeneric },
X    { "vga",		0,		NULL,	NULL,	ProbeFrameBuffer },
X    { 0 },
X};
X
X/*
X * Table of known Sun Disk Controllers.
X */
XDKCTLRTAB DkCtlrTab[] = {
X#if defined(DKC_XY450) && defined(XY_READ)
X    {  DKC_XY450,	"Xylogics 450/451 SMD",		XY_READ },
X#endif
X#if defined(DKC_ACB4000) && defined(SC_READ)
X    {  DKC_ACB4000,	"Adaptec ACB4000 SCSI",		SC_READ },
X#endif
X#if defined(DKC_MD21) && defined(SC_READ)
X    {  DKC_MD21,	"Emulex MD21 SCSI",		SC_READ },
X#endif
X#if defined(DKC_NCRFLOPPY) && defined(SC_READ)
X    {  DKC_NCRFLOPPY,	"NCR Floppy SCSI",		SC_READ },
X#endif
X#if defined(DKC_XD7053) && defined(XD_READ)
X    {  DKC_XD7053,	"Xylogics 7053/753 SMD",	XD_READ },
X#endif
X#if defined(DKC_SMSFLOPPY) && defined(SC_READ)
X    {  DKC_SMSFLOPPY,	"SMS Floppy SCSI",		SC_READ },
X#endif
X#if defined(DKC_SCSI_CCS) && defined(SC_READ)
X    {  DKC_SCSI_CCS,	"SCSI CCS",			SC_READ },
X#endif
X#if defined(DKC_CCS) && defined(SC_READ)
X    {  DKC_CCS,		"CCS SCSI",			SC_READ },
X#endif
X#if defined(DKC_NEC765)
X    {  DKC_NEC765,	"NEC 765 Floppy",		-1 },
X#endif
X#if defined(DKC_INTEL82072)
X    {  DKC_INTEL82072,	"Intel 82072 Floppy",	 	-1 },
X#endif
X#if defined(DKC_PANTHER) && defined(IP_READ)
X    {  DKC_PANTHER,	"Sun ISP-80 (Panther) IPI-2",	IP_READ },
X#endif
X#if defined(DKC_XD753_IPI) && defined(XD_READ)
X/*
X * Solbourne
X */
X    {  DKC_XD753_IPI,	"Xylogics SV-{67}800 IPI",	XD_READ },
X#endif
X#if	defined(TADPOLE)
X/*
X * Tadpole
X */
X    { 19,		"PC IDE",			IDE_READ },
X#endif	/* TADPOLE */
X    { 0 },
X};
X
X/*
X * Table of known Sun Frame Buffers
X */
XNAMETAB FBTab[] = {
X#ifdef FBTYPE_SUN2BW
X    {  FBTYPE_SUN2BW,		"Black & White memory (bwtwo)" },
X#endif
X#ifdef FBTYPE_SUN2COLOR
X    {  FBTYPE_SUN2COLOR,	"Color Graphics w/rasterop (cgtwo)" },
X#endif
X#ifdef FBTYPE_SUN2GP
X    {  FBTYPE_SUN2GP,		"GS Graphics Processor (cgtwelve)" },
X#endif
X#ifdef FBTYPE_SUN5COLOR
X    {  FBTYPE_SUN5COLOR,	"Sun-386i Accelerated Color" },
X#endif
X#ifdef FBTYPE_SUN3COLOR
X    {  FBTYPE_SUN3COLOR,	"8-bit Color (cgthree)" },
X#endif
X#ifdef FBTYPE_MEMCOLOR
X    {  FBTYPE_MEMCOLOR,		"B&W memory overlay plane (bwtwo)" },
X#endif
X#ifdef FBTYPE_SUN4COLOR
X    {  FBTYPE_SUN4COLOR,	"Color memory w/overlay (cgfour)" },
X#endif
X#ifdef FBTYPE_SUNFAST_COLOR
X    {  FBTYPE_SUNFAST_COLOR,	"GX 8-bit Accelerated Color (cgsix)" },
X#endif
X#ifdef FBTYPE_SUNROP_COLOR
X    {  FBTYPE_SUNROP_COLOR,	"24-bit Color w/rasterop" },
X#endif
X#ifdef FBTYPE_SUNFB_VIDEO
X    {  FBTYPE_SUNFB_VIDEO,	"Video Mixing" },
X#endif
X#ifdef FBTYPE_SUNGIFB
X    {  FBTYPE_SUNGIFB,		"Medical Imaging" },
X#endif
X#ifdef FBTYPE_SUNGPLAS
X    {  FBTYPE_SUNGPLAS,		"Plasma Panel" },
X#endif
X#ifdef FBTYPE_SUNGP3
X    {  FBTYPE_SUNGP3,		"24-bit Accelerated GPSI Color" },
X#endif
X#ifdef FBTYPE_SUNGT
X    {  FBTYPE_SUNGT,		"24-bit Color Graphics Accelerator (gt)" },
X#endif
X/*
X * Tadpole frame buffer's
X */
X#if	defined(TADPOLE)
X#ifdef FBTYPE_NOTSUN1
X    {  FBTYPE_NOTSUN1,		"VGA Graphics Card" },
X#endif
X#endif	/* TADPOLE */
X    { 0 },
X};
X
X/*
X * Magnetic Tape Info.
X *
X * This info is based on <sys/mtio.h>.  It would be nice to just
X * use that info, but not all systems have MT_TAPE_INFO.
X */
XNAMETAB MtInfo[] = {
X#ifdef MT_ISCPC
X    {  MT_ISCPC,		"TapeMaster 1/2-inch" },
X#endif
X#ifdef MT_ISXY
X    {  MT_ISXY,			"Xylogics 472 1/2-inch" },
X#endif
X#ifdef MT_ISAR
X    {  MT_ISAR,			"Archive QIC-11" },
X#endif
X#ifdef MT_ISSYSGEN11
X    {  MT_ISSYSGEN11,		"Sysgen QIC-11" },
X#endif
X#ifdef MT_ISSYSGEN
X    {  MT_ISSYSGEN,		"Sysgen QIC-24" },
X#endif
X#ifdef MT_ISMT02
X    {  MT_ISMT02,		"Emulex MT-02 QIC-24" },
X#endif
X#ifdef MT_ISVIPER1
X    {  MT_ISVIPER1,		"Archive QIC-150" },
X#endif
X#ifdef MT_ISWANGTEK1
X    {  MT_ISWANGTEK1,		"Wangtek QIC-150" },
X#endif
X#ifdef MT_ISKENNEDY
X    {  MT_ISKENNEDY,		"Kennedy 9612 1/2-inch" },
X#endif
X#ifdef MT_ISHP
X    {  MT_ISHP,			"HP 88780 1/2-inch" },
X#endif
X#ifdef MT_ISEXABYTE
X    {  MT_ISEXABYTE,		"Exabyte EXB-8200 8mm" },
X#endif
X#ifdef MT_ISEXB8500
X    {  MT_ISEXB8500,		"Exabyte EXB-8500 8mm" },
X#endif
X    { 0 },
X};
END_OF_info-sunos.c
if test 16354 -ne `wc -c <info-sunos.c`; then
    echo shar: \"info-sunos.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f os-ultrix.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"os-ultrix.c\"
else
echo shar: Extracting \"os-ultrix.c\" \(19334 characters\)
sed "s/^X//" >os-ultrix.c <<'END_OF_os-ultrix.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/os-ultrix.c,v 1.14 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: os-ultrix.c,v $
X * Revision 1.14  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.13  1992/04/17  23:27:51  mcooper
X * Add support for ROM Version information (Sun only for now).
X *
X * Revision 1.12  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.11  1992/04/16  19:56:24  mcooper
X * De-linting stuff.
X *
X * Revision 1.10  1992/04/15  02:04:16  mcooper
X * Change GetMemoryStr() to GetMemory().
X *
X * Revision 1.9  1992/03/31  02:22:03  mcooper
X * Fix failed return value from CheckNlist().
X *
X * Revision 1.8  1992/03/31  01:55:17  mcooper
X * Use new CheckNlist to check nlist success.
X *
X * Revision 1.7  1992/03/31  00:15:09  mcooper
X * Add error check for nlist.n_type.
X *
X * Revision 1.6  1992/03/22  00:20:10  mcooper
X * Major cleanup and re-org.
X *
X * Revision 1.5  1992/03/09  01:07:50  mcooper
X * Add support for determining system model type.
X *
X * Revision 1.4  1992/03/08  23:08:41  mcooper
X * - Add new set_macinfo_packetfilter().
X * - Remove unneeded get_bus().
X *
X * Revision 1.3  1992/03/08  04:57:09  mcooper
X * Set DT_TAPEDRIVE in probe_tapedrive().
X *
X * Revision 1.2  1992/03/08  01:11:39  mcooper
X * Add tape drive support.
X *
X * Revision 1.1  1992/03/06  18:35:40  mcooper
X * Initial revision
X *
X */
X
X/*
X * Ultrix specific functions
X */
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X#include <fcntl.h>
X#include <nlist.h>
X#include <fstab.h>
X#include <sys/types.h>
X#include <sys/param.h>
X#include <sys/fs.h>
X#include <sys/ioctl.h>
X#include <sys/buf.h>
X#include <sys/stat.h>
X
X#include <machine/cpuconf.h>
X
X#include <sys/devio.h>
X#include <sys/mtio.h>
X
X#include "info-ultrix.h"
X
X#if	defined(HAVE_UBA)
X/*
X * UBA (UniBus Adapter) specific code
X */
X#include <io/uba/ubavar.h>
X
X/*
X * Probe specific structure
X */
Xstruct _probespec {
X    struct uba_device		*uba_device;
X};
Xtypedef struct _probespec PROBESPEC;
X
X#define DV_SIZE		(sizeof(struct uba_device))
X#define CR_SIZE		(sizeof(struct uba_ctlr))
X
X/*
X * Build a device tree by searching Unibus Adapters
X */
Xstatic int BuildUBA(TreePtr)
X    DEVICE 		      **TreePtr;
X{
X    extern struct nlist 	UniBusNL[];
X    static struct uba_device 	Device;
X    static struct uba_ctlr 	Ctlr;
X    static char 		CtlrName[BUFSIZ], DevName[BUFSIZ];
X    u_long 			Addr, DeviceAddr;
X    static DEVDATA 		DevData;
X    static PROBESPEC		ProbeSpec;
X    DEVICE 		       *dev;
X    kvm_t		       *kd;
X    int 			cnum;
X
X    /*
X     * Read table address from kernel
X     */
X    if (!(kd = KVM_open(UniBusNL))) {
X	if (Debug) Error("Cannot read unibus device table from kernel.");
X	return(-1);
X    }
X
X    /*
X     * See if we got a valid entry
X     */
X    if (CheckNlist(&UniBusNL[0]))
X	return(-1);
X
X    /*
X     * Read each device table entry.  A NULL device.ui_driver
X     * indicates that we're at the end of the table.
X     */
X    for (DeviceAddr = UniBusNL[0].n_value; DeviceAddr; 
X	 DeviceAddr += DV_SIZE) {
X
X	/*
X	 * Read this device
X	 */
X	if (KVM_read(kd, DeviceAddr, (char *) &Device, DV_SIZE)) {
X	    if (Debug) 
X		Error("Cannot read unibus device from address 0x%x.", 
X		      DeviceAddr);
X	    KVM_close(kd);
X	    return(-1);
X	}
X
X	/*
X	 * See if we're done.
X	 */
X	if (!Device.ui_driver)
X	    break;
X
X	/*
X	 * Get the device name
X	 */
X	DevName[0] = C_NULL;
X	if (Addr = (u_long) Device.ui_devname) {
X	    if (KVM_read(kd, Addr, (char *) DevName, sizeof(DevName))) {
X		if (Debug)
X		    Error("Cannot read device name from address 0x%x.", Addr);
X		continue;
X	    }
X	}
X
X	/*
X	 * Get the controller info
X	 */
X	CtlrName[0] = C_NULL;
X	cnum = -1;
X	if (Addr = (u_long) Device.ui_mi) {
X	    if (KVM_read(kd, Addr, (char *) &Ctlr, CR_SIZE)) {
X		if (Debug) 
X		    Error("Cannot read controller from address 0x%x.", Addr);
X	    } else {
X		/*
X		 * Get the controller name
X		 */
X		if (Addr = (u_long) Ctlr.um_ctlrname) {
X		    if (KVM_read(kd, Addr, CtlrName, sizeof(CtlrName))) {
X			if (Debug)
X			    Error(
X		  "Cannot read controller name from driver address 0x%x.",
X				  Addr);
X			continue;
X		    }
X		}
X		cnum = Ctlr.um_ctlr;
X	    }
X	}
X
X	if (Debug)
X	    printf("build_unibus(): Found '%s' on '%s'.\n", DevName, CtlrName);
X
X	/* Make sure devdata is clean */
X	bzero(&DevData, sizeof(DEVDATA));
X
X	/* Set what we know */
X	if (DevName[0]) {
X	    DevData.dd_devname = strdup(DevName);
X	    DevData.dd_devunit = Device.ui_unit;
X	}
X	if (CtlrName[0]) {
X	    DevData.dd_ctlrname = strdup(CtlrName);
X	    DevData.dd_ctlrunit = cnum;
X	}
X
X	/* 
X	 * Unibus devices should always exist.
X	 */
X	if (Device.ui_alive)
X	    DevData.dd_flags |= DD_IS_ALIVE;
X
X	ProbeSpec.uba_device = &Device;
X
X	/* Probe and add device */
X	if (dev = (DEVICE *) ProbeDevice(&DevData, TreePtr, &ProbeSpec))
X	    AddDevice(dev, TreePtr);
X    }
X
X    KVM_close(kd);
X
X    return(0);
X}
X#endif	/* HAVE_UBA */
X
X/*
X * Build list of Ultrix devices
X */
Xextern int BuildDevicesUltrix(TreePtr)
X    DEVICE 		      **TreePtr;
X{
X    int				Found = 1;
X
X#if	defined(HAVE_UBA)
X    if (BuildUBA(TreePtr) == 0)
X	Found = 0;
X#endif	/* HAVE_UBA */
X
X    return(Found);
X}
X
X/*
X * Get Device Info structure from device.
X */
Xstatic struct devget *GETdevget(File, FileD)
X    char		       *File;
X    int 			FileD;
X{
X    static struct devget 	devget;
X
X    if (ioctl(FileD, DEVIOCGET, &devget) == SYSFAIL) {
X	if (Debug) Error("%s: ioctl DEVIOCGET failed: %s.", File, SYSERR);
X	return((struct devget *) NULL);
X    }
X
X    return(&devget);
X}
X
X/*
X * Get Device Geometry structure from device.
X */
Xstatic DEVGEOMST *GETdevgeom(File, FileD)
X    char		       *File;
X    int 			FileD;
X{
X    static DEVGEOMST 		devgeom;
X
X    if (ioctl(FileD, DEVGETGEOM, &devgeom) == SYSFAIL) {
X	if (Debug) Error("%s: ioctl DEVGETGEOM failed: %s.", File, SYSERR);
X	return((DEVGEOMST *) NULL);
X    }
X
X    return(&devgeom);
X}
X
X/*
X * Lookup a category type.
X */
Xstatic char *GetCategory(val)
X    int				val;
X{
X    extern NAMETAB	        Categorys[];
X    register int 		i;
X
X    for (i = 0; Categorys[i].name; ++i)
X	if (val == Categorys[i].value)
X	    return(Categorys[i].name);
X
X    return((char *) NULL);
X}
X
X/*
X * Convert a 'devget' to a 'device'.
X */
Xstatic DEVICE *devgetToDEVICE(DevGet, DevData, ProbeSpec)
X    struct devget	       *DevGet;
X    DEVDATA		       *DevData;
X    PROBESPEC		       *ProbeSpec;
X{
X    DEVICE		       *Device;
X
X    if (!(Device = NewDevice(NULL)))
X	return(Device);
X
X    Device->dv_name	= strdup(MkDevName(DevData->dd_devname,
X					   DevData->dd_devunit));
X    Device->dv_model	= strdup(DevGet->device);
X    Device->dv_desc	= GetCategory(DevGet->category);
X    Device->dv_unit	= DevGet->unit_num;
X
X    /*
X     * Set master/controller info
X     */
X    if (Device->dv_master = MkMasterFromDevData(DevData))
X	Device->dv_master->dv_model = strdup(DevGet->interface);
X
X    return(Device);
X}
X
X/*
X * Check a device by trying to perform a devget on it.
X */
Xstatic struct devget *CheckDevice(File)
X    char		       *File;
X{
X    struct devget	       *DevGet;
X    int				d;
X
X    if ((d = open(File, O_RDONLY|O_NDELAY)) < 0) {
X	if (Debug) Error("%s: Cannot open: %s.", File, SYSERR);
X	return((struct devget *) NULL);
X    }
X
X    /*
X     * Get generic device info
X     */
X    if (!(DevGet = GETdevget(File, d))) {
X	if (Debug) Error("%s: GETdevget failed.", File);
X	close(d);
X	return((struct devget *) NULL);
X    }
X
X    close(d);
X
X    return(DevGet);
X}
X
X/*
X * Retrieve disk partition information from a device file.
X */
Xstatic struct pt *ExtractDiskPart(File)
X    char		       *File;
X{
X    static struct pt		pt;
X    int				d;
X
X    if ((d = open(File, O_RDONLY|O_NDELAY)) < 0) {
X	if (Debug) Error("%s: open failed: %s.", File, SYSERR);
X	return((struct pt *) NULL);
X    }
X
X    if (ioctl(d, DIOCGETPT, &pt) < 0) {
X	if (Debug) Error("%s: ioctl DIOCGETPT failed: %s.", File, SYSERR);
X	close(d);
X	return((struct pt *) NULL);
X    }
X
X    close(d);
X
X    return(&pt);
X}
X
X/*
X * Get the mount point for a filesystem.
X */
Xstatic char *GetMountInfo(Name, Part)
X    char		       *Name;
X    char		       *Part;
X{
X    char		       *File;
X    struct fstab	       *fstab;
X
X    File = GetCharFile(Name, Part);
X    if (fstab = getfsspec(File)) {
X	if (strcmp(fstab->fs_type, FSTAB_SW) == 0)
X	    return("swap");
X	return(fstab->fs_file);
X    }
X
X    return((char *) NULL);
X}
X
X/*
X * Get the partition information for a disk device.
X */
Xstatic DISKPART *GetPartInfo(Name, Device)
X    char 		       *Name;
X    DEVICE		       *Device;
X{
X    static DISKPART	        diskpart;
X    static char			Buf[BUFSIZ], part[2];
X    register DISKPART	       *pdp, *dp;
X    register char	       *p;
X    DISKPART		       *base = NULL;
X    struct pt		       *pt;
X    register int		i;
X
X    /*
X     * First get the partition info.
X     */
X    (void) sprintf(Buf, "/dev/r%sa", Name);
X    if (!(pt = ExtractDiskPart(Buf)))
X	return((DISKPART *) NULL);
X
X    part[1] = C_NULL;
X
X    /*
X     * Now deal with each partition.
X     */
X    for (i = 0; i < MAX_DISK_PARTS; ++i) {
X	/* Ignore partitions that have no size */
X	if (!pt->pt_part[i].pi_nblocks)
X	    continue;
X
X	part[0] = 'a' + i;
X
X	/* Make a clean slate */
X	bzero((char *) &diskpart, sizeof(DISKPART));
X
X	/* Fill in what we know */
X	diskpart.dp_name = strdup(part);
X	diskpart.dp_stsect = pt->pt_part[i].pi_blkoff;
X	diskpart.dp_nsect = pt->pt_part[i].pi_nblocks;
X
X	/* 
X	 * Get the mount point name.
X	 * If this is the "b" partition on the 
X	 * root device, then assume it's swap 
X	 */
X	if (p = GetMountInfo(Name, part))
X	    diskpart.dp_mnt = strdup(p);
X	else if (Device->dv_unit == 0 && strcmp(part, "b") == 0)
X	    diskpart.dp_mnt = "swap";
X
X	/*
X	 * Add this partition to the linked list.
X	 */
X	if (base) {
X	    for (pdp = base; pdp && pdp->dp_nxt; pdp = pdp->dp_nxt);
X	    pdp->dp_nxt = NewDiskPart(&diskpart);
X	} else {
X	    base = NewDiskPart(&diskpart);
X	}
X    }
X
X    return(base);
X}
X
X/*
X * Probe a disk drive
X */
Xextern DEVICE *ProbeDiskDrive(Name, DevData, DevDataTab, ProbeSpec)
X    char		       *Name;
X    DEVDATA		       *DevData;
X    DEVDATATAB		       *DevDataTab;
X    PROBESPEC		       *ProbeSpec;
X{
X    DEVICE		       *Device;
X    DISKDRIVE		       *DiskDrive;
X    DEVGEOMST		       *DevGeom;
X    struct devget	       *DevGet;
X    char		       *File;
X    int				Desc;
X
X    if (!Name)
X	return((DEVICE *) NULL);
X
X    File = GetRawFile(Name, "c");
X    if ((Desc = open(File, O_RDONLY|O_NDELAY)) < 0) {
X	if (Debug) Error("%s: open failed: %s.", File, SYSERR);
X	/*
X	 * If we know for sure this drive is present and we
X	 * know something about it, then create a minimal device.
X	 */
X	if ((DevDataTab->ddt_model || DevDataTab->ddt_desc) &&
X	    FLAGS_ON(DevData->dd_flags, DD_IS_ALIVE)) {
X	    Device = NewDevice((DEVICE *) NULL);
X	    Device->dv_name = strdup(Name);
X	    Device->dv_unit = DevData->dd_devunit;
X	    Device->dv_master = MkMasterFromDevData(DevData);
X	    Device->dv_type = DT_DISKDRIVE;
X	    Device->dv_model = DevDataTab->ddt_model;
X	    Device->dv_desc = DevDataTab->ddt_desc;
X	    return(Device);
X	} else
X	    return((DEVICE *) NULL);
X    }
X
X    /*
X     * Get generic device info
X     */
X    if (!(DevGet = GETdevget(File, Desc))) {
X	if (Debug) Error("%s: GETdevget failed.", File);
X	close(Desc);
X	return((DEVICE *) NULL);
X    }
X
X    /*
X     * Get geometry of device
X     */
X    if (!(DevGeom = GETdevgeom(File, Desc))) {
X	if (Debug) Error("%s: get_geomst failed.", File);
X    }
X
X    close(Desc);
X
X    /*
X     * Convert devget info to a device struct
X     */
X    if (!(Device = devgetToDEVICE(DevGet, DevData, ProbeSpec))) {
X	if (Debug) Error("%s: Cannot convert devget to device.");
X	return((DEVICE *) NULL);
X    }
X
X    /*
X     * Disks should be on disk controllers.
X     */
X    if (Device->dv_master)
X	Device->dv_master->dv_type = DT_DISKCTLR;
X
X    /*
X     * Set the disk drive specific info
X     */
X
X    if ((DiskDrive = NewDiskDrive(NULL)) == NULL) {
X	Error("Cannot create new diskdrive entry.");
X	return((DEVICE *) NULL);
X    }
X
X    Device->dv_type 		= DT_DISKDRIVE;
X    if (DevGet->device)
X	DiskDrive->dd_label 	= strdup(DevGet->device);
X
X    /*
X     * Convert Geometry
X     */
X    if (DevGeom) {
X	/*
X	 * If this is a removable device, indicate so.
X	 */
X	if (FLAGS_ON(DevGeom->geom_info.attributes, DEVGEOM_REMOVE)) {
X	    if (Device->dv_desc) {
X		char Buf[BUFSIZ];
X
X		(void) sprintf(Buf, "Removable %s", Device->dv_desc);
X		(void) free(Device->dv_desc);
X		Device->dv_desc = strdup(Buf);
X	    } else {
X		Device->dv_desc = "Removable disk drive";
X	    }
X	}
X
X	DiskDrive->dd_unit 	= DevGet->unit_num;
X	DiskDrive->dd_slave 	= DevGet->slave_num;
X	DiskDrive->dd_part 	= GetPartInfo(Name, Device);
X	DiskDrive->dd_dcyl 	= DevGeom->geom_info.ncylinders;
X	DiskDrive->dd_heads 	= DevGeom->geom_info.ntracks;
X	DiskDrive->dd_sect 	= DevGeom->geom_info.nsectors;
X	DiskDrive->dd_secsize 	= SECSIZE;
X
X	if (DiskDrive->dd_dcyl && DiskDrive->dd_sect && DiskDrive->dd_heads) {
X	    static char Buf[BUFSIZ];
X
X	    DiskDrive->dd_size = nsect_to_bytes(DiskDrive->dd_dcyl * 
X						DiskDrive->dd_sect * 
X						DiskDrive->dd_heads, 
X						DiskDrive->dd_secsize);
X
X	    (void) sprintf(Buf, "%.2f MB capacity", 
X			   (float) bytes_to_mbytes(DiskDrive->dd_size));
X	    Device->dv_desc = strdup(Buf);
X	}
X    }
X    Device->dv_devspec = (caddr_t *) DiskDrive;
X
X    return(Device);
X}
X
X/*
X * Lookup info about a tape drive.
X */
Xstatic char *GetTapeInfo(Flag)
X    int				Flag;
X{
X    extern NAMETAB		TapeInfo[];
X    static char			Buf[BUFSIZ];
X    register int		i;
X
X    if (!Flag)
X	return((char *) NULL);
X
X    Buf[0] = C_NULL;
X
X    /*
X     * Values are flag bits and are appended together.
X     */
X    for (i = 0; TapeInfo[i].name; i++) {
X	if (Flag & TapeInfo[i].value) {
X	    if (Buf[0]) {
X		(void) strcat(Buf, ", ");
X		(void) strcat(Buf, TapeInfo[i].name);
X	    } else
X		(void) strcpy(Buf, TapeInfo[i].name);
X	}
X    }
X
X    return(Buf);
X}
X
X/*
X * Probe a tape drive
X */
Xextern DEVICE *ProbeTapeDrive(Name, DevData, DevDataTab, ProbeSpec)
X    char		       *Name;
X    DEVDATA		       *DevData;
X    DEVDATATAB		       *DevDataTab;
X    PROBESPEC		       *ProbeSpec;
X{
X    struct devget	       *DevGet;
X    DEVICE		       *Device;
X    char		       *File;
X    char		       *p;
X    char		        Buf[BUFSIZ];
X    register int		i;
X
X    /*
X     * XXX Kludge Alert! ! !
X     *
X     * Ultrix tape device files are numbered independently of actual
X     * unit number.  Additionally, not all tape devices support the same
X     * set of minor devices types, so we can't look at the minor device 
X     * number.  
X     *
X     * The code below will open(), ioctl(), close() all tape
X     * devices between 0 and MAXTAPES until a matching unit number is found.
X     * This means that on systems with lots of tape drives, this can be 
X     * very slow.
X     */
X    for (i = 0; i < MAXTAPES; ++i) {
X	(void) sprintf(Buf, "/dev/nrmt%dh", i);
X	if ((DevGet = CheckDevice(Buf)) && 
X	    (DevGet->unit_num == DevData->dd_devunit))
X	    break;
X    }
X
X    if (!DevGet) {
X	if (Debug) Error("%s: Cannot find device file.", Name);
X	return((DEVICE *) NULL);
X    }
X
X    /*
X     * Convert devget info to a device struct
X     */
X    if (!(Device = devgetToDEVICE(DevGet, DevData, ProbeSpec))) {
X	if (Debug) Error("%s: Cannot convert devget to device.");
X	return((DEVICE *) NULL);
X    }
X
X    /*
X     * Set our device type
X     */
X    Device->dv_type = DT_TAPEDRIVE;
X
X    /*
X     * Get and add Tape Info
X     */
X    if (p = GetTapeInfo(DevGet->category_stat)) {
X	if (Device->dv_desc) {
X	    (void) sprintf(Buf, "%s %s", p, Device->dv_desc);
X	    free(Device->dv_desc);
X	    Device->dv_desc = strdup(Buf);
X	} else {
X	    Device->dv_desc = p;
X	}
X    }
X
X    /*
X     * Tapes should be on tape controllers.
X     */
X    if (Device->dv_master)
X	Device->dv_master->dv_type = DT_TAPECTLR;
X
X    return(Device);
X}
X
X/*
X * Get network type information
X */
Xstatic char *GetNetType(type)
X    int				type;
X{
X    extern NAMETAB		NetTypes[];
X    register int		i;
X
X    for (i = 0; NetTypes[i].name; i++)
X	if (NetTypes[i].value == type)
X	    return(NetTypes[i].name);
X
X    return((char *) NULL);
X}
X
X
X#if	defined(HAVE_PACKETFILTER)
X
X#include <sys/time.h>
X#include <net/pfilt.h>
X
X#include <sys/socket.h>
X#include <net/if.h>
X#include <netinet/in.h>
X#include <netinet/if_ether.h>
X
X/*
X * Find and set the MAC info using the Packet Filter
X */
Xextern void SetMacInfoPacketFilter(DevName, Netif, Device)
X     char 		       *DevName;
X     NETIF 		       *Netif;
X     DEVICE		       *Device;
X{
X    struct endevp		endevp;
X    struct ether_addr		ether_addr;
X    char 		       *ether_ntoa(), HostBuf[MAXHOSTNAMLEN+1];
X    char 		       *p;
X    int 		        Desc;
X
X    if (!DevName || !Netif)
X	return;
X
X    /*
X     * Open this device using the packet filter
X     */
X    if ((Desc = pfopen(DevName, O_RDONLY)) < 0) {
X	if (Debug) Error("pfopen %s failed: %s.", DevName, SYSERR);
X	return;
X    }
X
X    /*
X     * Retrieve info
X     */
X    if (ioctl(Desc, EIOCDEVP, &endevp) < 0) {
X	if (Debug) Error("ioctl EIOCDEVP of %s failed: %s.", DevName, SYSERR);
X	return;
X    }
X
X    close(Desc);
X
X    /*
X     * Convert address into ethers(5) format
X     */
X    bcopy((char *) endevp.end_addr,
X	  (char *) ether_addr.ether_addr_octet,
X	  endevp.end_addr_len);
X
X    /*
X     * Set what we now know.
X     */
X    if (p = ether_ntoa(&ether_addr))
X	Netif->ni_macaddr = strdup(p);
X
X    if (ether_ntohost(HostBuf, &ether_addr) == 0)
X	Netif->ni_macname = strdup(HostBuf);
X
X    if (Device && (p = GetNetType(endevp.end_dev_type)))
X	Device->dv_desc = p;
X}
X#endif	/* HAVE_PACKETFILTER */
X
X/*
X * Get the system model name.  Ultrix keeps the system type
X * in a kernel structure called cpusw as cpusw.system_type.
X * The system types are defined in <machine/cpuconf.h>.
X */
Xextern char *GetModelName()
X{
X    extern NAMETAB		ModelTab[];
X    extern struct nlist		CpuSwNL[];
X    static struct cpusw	        CpuSw;
X    register int		i;
X    kvm_t		       *kd;
X
X    if (!(kd = KVM_open(CpuSwNL))) {
X	if (Debug) Error("Cannot find cpusw symbol in kernel.");
X	return((char *) NULL);
X    }
X
X    /*
X     * See if we got a valid entry
X     */
X    if (CheckNlist(&CpuSwNL[0]))
X	return((char *) NULL);
X
X    if (KVM_read(kd, (u_long) CpuSwNL[0].n_value, (char *) &CpuSw,
X		 sizeof(struct cpusw))) {
X	if (Debug) Error("Cannot read cpusw from kernel.");
X	return((char *) NULL);
X    }
X
X    KVM_close(kd);
X
X    for (i = 0; ModelTab[i].name; ++i)
X	if (ModelTab[i].value == CpuSw.system_type)
X	    return(ModelTab[i].name);
X
X    if (Debug)
X	printf("system model/type %d is unknown.\n", CpuSw.system_type);
X
X    return((char *) NULL);
X}
X
X/*
X * Get kernel version string from kernel symbol "version".
X */
Xextern char *GetKernelVersionStr()
X{
X    return(GetKernelVersionFromVersion());
X}
X
X/*
X * Get amount of physical memory using kernel symbol "physmem".
X */
Xextern char *GetMemory()
X{
X    return(GetMemoryFromPhysmem());
X}
X
X/*
X * Get system serial number
X */
Xextern char *GetSerialNoStr()
X{
X    /* No support */
X    return((char *) NULL);
X}
X
X/*
X * Get name of OS
X */
Xextern char *GetOSNameStr()
X{
X    return(GetOSNameFromUname());
X}
X
X/*
X * Get version of OS
X */
Xextern char *GetOSVersionStr()
X{
X    return(GetOSVersionFromUname());
X}
X
X/*
X * Get ROM Version
X */
Xextern char *GetRomVer()
X{
X    /* No support */
X    return((char *) NULL);
X}
END_OF_os-ultrix.c
if test 19334 -ne `wc -c <os-ultrix.c`; then
    echo shar: \"os-ultrix.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f info-ultrix.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"info-ultrix.c\"
else
echo shar: Extracting \"info-ultrix.c\" \(8452 characters\)
sed "s/^X//" >info-ultrix.c <<'END_OF_info-ultrix.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/info-ultrix.c,v 1.8 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: info-ultrix.c,v $
X * Revision 1.8  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.7  1992/04/17  01:10:11  mcooper
X * Moved DEVICE *() function declares to defs.h.
X *
X * Revision 1.6  1992/03/28  21:29:24  mcooper
X * Move NetifNL to netif.c.
X *
X * Revision 1.5  1992/03/22  00:20:10  mcooper
X * Major cleanup and re-org.
X *
X * Revision 1.4  1992/03/09  01:07:50  mcooper
X * Add support for determining system model type.
X *
X * Revision 1.3  1992/03/08  23:08:18  mcooper
X * Make things safe with #ifdef's.
X *
X * Revision 1.2  1992/03/08  04:56:52  mcooper
X * Add network interface devices.
X *
X * Revision 1.1  1992/03/06  18:35:31  mcooper
X * Initial revision
X *
X */
X
X/*
X * Ultrix related information
X */
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X#include <machine/cpuconf.h>
X
X#if	defined(HAVE_PACKETFILTER)
X#include <sys/time.h>
X#include <net/pfilt.h>
X#endif	/* HAVE_PACKETFILTER */
X
X#include <nlist.h>
X#include <sys/devio.h>
X
X/*
X * CPU Switch symbol
X */
Xstruct nlist CpuSwNL[] = {
X#if	defined(COFF)
X    { "cpusw" },
X#else
X    { "_cpusw" },
X#endif	/* COFF */
X    { 0 },
X};
X
X#if	defined(HAVE_UBA)
X/*
X * UniBus name list
X */
Xstruct nlist UniBusNL[] = {
X#if	defined(COFF)
X    { "ubdinit" },
X#else
X    { "_ubdinit" },
X#endif	/* COFF */
X    { 0 },
X};
X#endif	/* HAVE_UBA */
X
X/*
X * Device Data Table
X *
X * Compares are done by the length of the string appearing in
X * the first columns.  Therefore, longer names must appear before
X * any shorter names that are not unique.  e.g. "lebuffer" needs to
X * be before "le".
X */
XDEVDATATAB DevDataTab[] = {
X    /*
X     * Disk Drives
X     */
X    { "fd",		0,		NULL,	NULL,	ProbeDiskDrive },
X    { "ra",		0,		NULL,	NULL,	ProbeDiskDrive },
X    { "rz",		0,		NULL,	NULL,	ProbeDiskDrive },
X    /*
X     * Tape Drives
X     */
X    { "mu",		0,		NULL,	NULL,	ProbeTapeDrive },
X    { "stc",		0,		NULL,	NULL,	ProbeTapeDrive },
X    { "tms",		0,		NULL,	NULL,	ProbeTapeDrive },
X    { "ts",		0,		NULL,	NULL,	ProbeTapeDrive },
X    { "tu",		0,		NULL,	NULL,	ProbeTapeDrive },
X    { "tz",		0,		NULL,	NULL,	ProbeTapeDrive },
X    /*
X     * Network Interfaces
X     */
X    { "ln",		0,  		"LANCE Ethernet",
X	  				"10Mb/sec Ethernet",	ProbeNetif },
X    { "de",		0,  		"DEC Ethernet",
X	  				"10Mb/sec Ethernet",	ProbeNetif },
X    { "ni",		0,  		"DEC Ethernet",		
X					"10Mb/sec Ethernet",	ProbeNetif },
X    { "qe",		0,  		"DEQNA/DELQA Ethernet",	
X					"10Mb/sec Ethernet",	ProbeNetif },
X    { "ne",		0,  		"Second Generation Ethernet",	
X					"10Mb/sec Ethernet",	ProbeNetif },
X    { "xna",		0,  		"DEBNI/DEMNA Ethernet",
X					"10Mb/sec Ethernet",	ProbeNetif },
X    { "fza",		0,  		"DEFZA FDDI",
X	  				"100Mb/sec FDDI",	ProbeNetif },
X    /*
X     * I don't know anything about Ultrix frame buffers
X     */
X    { "cfb",		0,  		NULL,
X	  "Color Frame Buffer",				ProbeGeneric },
X    { "pm",		0,  		NULL,
X	  "Graphics Device",				ProbeGeneric },
X    { "px",		0,  		NULL,
X	  "Graphics Device",				ProbeGeneric },
X    { "ga",		0,  		NULL,
X	  "Graphics Device",				ProbeGeneric },
X    { "gq",		0,  		NULL,
X	  "Graphics Device",				ProbeGeneric },
X    { "fb",		0,  		NULL,
X	  "Graphics Device",				ProbeGeneric },
X    /*
X     * PrestoServe card (untested).
X     */
X    { "presto",		DT_GENERIC,	
X	  "PrestoServe",	
X	  "NFS accelerator card",			ProbeGeneric },
X    /*
X     * Serial line controllers
X     */
X    { "dc",		DT_GENERIC,	
X	  NULL,	
X	  "4-port serial line controller",		ProbeGeneric },
X    { "mdc",		DT_GENERIC,	
X	  "DS5100",	
X	  "4-port serial line controller",		ProbeGeneric },
X    { "scc",		DT_GENERIC,	
X	  "SCC",	
X	  "2-port serial line controller",		ProbeGeneric },
X    { "cxa",		DT_GENERIC,	
X	  "CXA16",	
X	  "16-line serial communications interface",	ProbeGeneric },
X    { "cxy",		DT_GENERIC,	
X	  "CXY08",	
X	  "8-line serial communications interface",	ProbeGeneric },
X    { "dhv",		DT_GENERIC,	
X	  "DHV11",	
X	  "8-line serial communications interface",	ProbeGeneric },
X    { "dmb",		DT_GENERIC,	
X	  "DMB32",	
X	  "8-line serial communications interface",	ProbeGeneric },
X    { "dhq",		DT_GENERIC,	
X	  "DHQ11",	
X	  "8-line serial communications interface",	ProbeGeneric },
X    { 0 },
X};
X
X/*
X * Models of DEC machines as defined in <machine/cpuconf.h>
X */
XNAMETAB ModelTab[] = {
X#ifdef VAX_780
X    {  VAX_780,		"VAX-11/780" },
X#endif
X#ifdef VAX_750
X    {  VAX_750,		"VAX-11/750" },
X#endif
X#ifdef VAX_730
X    {  VAX_730,		"VAX-11/730" },
X#endif
X#ifdef VAX_8600
X    {  VAX_8600,	"VAX-8600" },
X#endif
X#ifdef VAX_8200
X    {  VAX_8200,	"VAX-8200" },
X#endif
X#ifdef VAX_8800
X    {  VAX_8800,	"VAX-8800" },
X#endif
X#ifdef MVAX_I
X    {  MVAX_I,		"MicroVAX-I" },
X#endif
X#ifdef MVAX_II
X    {  MVAX_II,		"MicroVAX-II" },
X#endif
X#ifdef V_VAX
X    {  V_VAX,		"Virtual VAX" },	/* This can't be real 	*/
X#endif
X#ifdef VAX_3600
X    {  VAX_3600,	"VAX-3600" },		/* Mayfair I		*/
X#endif
X#ifdef VAX_6200
X    {  VAX_6200,	"VAX-6200" },		/* CVAX/Calypso		*/
X#endif
X#ifdef VAX_3400
X    {  VAX_3400,	"VAX-3400" },		/* Mayfair II		*/
X#endif
X#ifdef C_VAXSTAR
X    {  C_VAXSTAR,	"VAX-3100" },		/* PVAX			*/
X#endif
X#ifdef VAX_60
X    {  VAX_60,		"VAX-60" },		/* Firefox		*/
X#endif
X#ifdef VAX_3900
X    {  VAX_3900,	"VAX-3900" },		/* Mayfair III		*/
X#endif
X#ifdef DS_3100
X    {  DS_3100,		"DECsystem-3100" },	/* PMAX			*/
X#endif
X#ifdef VAX_8820
X    {  VAX_8820,	"VAX-8820" },		/* SID for Polarstar	*/
X#endif
X#ifdef DS_5400
X    {  DS_5400,		"DECsystem-5400" },	/* MIPSfair		*/
X#endif
X#ifdef DS_5800
X    {  DS_5800,		"DECsystem-5800" },	/* ISIS			*/
X#endif
X#ifdef DS_5000
X    {  DS_5000,		"DECsystem-5000" },
X#endif
X#ifdef DS_CMAX
X    {  DS_CMAX,		"DECsystem-CMAX" },
X#endif
X#ifdef VAX_6400
X    {  VAX_6400,	"VAX-6400" },		/* RIGEL/Calypso	*/
X#endif
X#ifdef VAXSTAR
X    {  VAXSTAR,		"VAXSTAR" },
X#endif
X#ifdef DS_5500
X    {  DS_5500,		"DECsystem-5500" },	/* MIPSFAIR-2		*/
X#endif
X#ifdef DS_5100
X    {  DS_5100,		"DECsystem-5100" },	/* MIPSMATE		*/
X#endif
X#ifdef VAX_9000
X    {  VAX_9000,	"VAX-9000" },		/* VAX9000		*/
X#endif
X#ifdef DS_5000_100
X    {  DS_5000_100,	"DECsystem-5000/100" },	/* 3MIN			*/
X#endif
X#ifdef DS_5000_300
X    {  DS_5000_300,	"DECsystem-5000/300" },	/* 3MAX+		*/
X#endif
X#ifdef DS_MAXINE
X    {  DS_MAXINE,	"DECsystem-MAXINE" },	/* MAXine		*/
X#endif
X    {  0 },
X};
X
X/*
X * Tape info as defined in <sys/devio.h>.
X */
XNAMETAB TapeInfo[] = {
X#ifdef DEV_800BPI
X    {  DEV_800BPI,	"800 bpi density" },
X#endif
X#ifdef DEV_1600BPI
X    {  DEV_1600BPI,	"1600 bpi density" },
X#endif
X#ifdef DEV_6250BPI
X    {  DEV_6250BPI,	"6250 bpi density" },
X#endif
X#ifdef DEV_6666BPI
X    {  DEV_6666BPI,	"6666 bpi density" },
X#endif
X#ifdef DEV_10240BPI
X    {  DEV_10240BPI,	"10240 bpi density" },
X#endif
X#ifdef DEV_38000BPI
X    {  DEV_38000BPI,	"38000 bpi density" },
X#endif
X#ifdef DEV_LOADER
X    {  DEV_LOADER,	"media loader present" },
X#endif
X#ifdef DEV_38000_CP
X    {  DEV_38000_CP,	"38000 bpi compacted density" },
X#endif
X#ifdef DEV_76000BPI
X    {  DEV_76000BPI,	"76000 bpi density" },
X#endif
X#ifdef DEV_76000_CP
X    {  DEV_76000_CP,	"76000 bpi compacted density" },
X#endif
X#ifdef DEV_8000_BPI
X    {  DEV_8000_BPI,	"QIC-24 9 track" },
X#endif
X#ifdef DEV_10000_BPI
X    {  DEV_10000_BPI,	"QIC-120 15trk and QIC-150 18trk" },
X#endif
X#ifdef DEV_16000_BPI
X    {  DEV_16000_BPI,	"QIC-320/525 26 track" },
X#endif
X#ifdef DEV_61000_BPI
X    {  DEV_61000_BPI,	"4mm tape cartridge" },
X#endif
X#ifdef DEV_54000_BPI
X    {  DEV_54000_BPI,	"8mm tape cartridge" },
X#endif
X    { 0 },
X};
X
X/*
X * Category types as defined in <sys/devio.h>
X */
XNAMETAB Categorys[] = {
X#ifdef DEV_TAPE
X    {  DEV_TAPE,	"Tape drive" },
X#endif
X#ifdef DEV_DISK
X    {  DEV_DISK,	"Disk drive" },
X#endif
X#ifdef DEV_TERMINAL
X    {  DEV_TERMINAL,	"Terminal" },
X#endif
X#ifdef DEV_PRINTER
X    {  DEV_PRINTER,	"Printer" },
X#endif
X#ifdef DEV_SPECIAL
X    {  DEV_SPECIAL,	"Special" },
X#endif
X    {  0 },
X};
X
X/*
X * Network types table as defined in <net/pfilt.h>
X */
XNAMETAB NetTypes[] = {
X#ifdef ENDT_3MB
X    {  ENDT_3MB,	"3Mb/sec Ethernet" },
X#endif
X#ifdef ENDT_BS3MB
X    {  ENDT_BS3MB,	"Byte Swapped 3Mb/sec Ethernet" },
X#endif
X#ifdef ENDT_10MB
X    {  ENDT_10MB,	"10Mb/sec Ethernet" },
X#endif
X#ifdef ENDT_FDDI
X    {  ENDT_FDDI,	"100Mb/sec FDDI" },
X#endif
X    {  0 },
X};
END_OF_info-ultrix.c
if test 8452 -ne `wc -c <info-ultrix.c`; then
    echo shar: \"info-ultrix.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f info-ultrix.h -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"info-ultrix.h\"
else
echo shar: Extracting \"info-ultrix.h\" \(759 characters\)
sed "s/^X//" >info-ultrix.h <<'END_OF_info-ultrix.h'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X/*
X * $Header: /src/common/usc/bin/sysinfo/RCS/info-ultrix.h,v 1.3 1992/04/26 23:32:06 mcooper Exp $
X *
X * $Log: info-ultrix.h,v $
X * Revision 1.3  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.2  1992/03/08  01:11:58  mcooper
X * Add MAX_DISK_PARTS.
X *
X * Revision 1.2  1992/03/08  01:11:58  mcooper
X * Add MAX_DISK_PARTS.
X *
X * Revision 1.1  1992/03/06  18:35:31  mcooper
X * Initial revision
X *
X */
X
X
X/*
X * Maximium number of tape drives that Ultrix supports
X */
X#define MAXTAPES		32
X
X/*
X * Maximium number of partitions per disk
X */
X#define MAX_DISK_PARTS		8
END_OF_info-ultrix.h
if test 759 -ne `wc -c <info-ultrix.h`; then
    echo shar: \"info-ultrix.h\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f os-next.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"os-next.c\"
else
echo shar: Extracting \"os-next.c\" \(12325 characters\)
sed "s/^X//" >os-next.c <<'END_OF_os-next.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/os-next.c,v 1.10 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: os-next.c,v $
X * Revision 1.10  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.9  1992/04/17  23:27:51  mcooper
X * Add support for ROM Version information (Sun only for now).
X *
X * Revision 1.8  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.7  1992/04/15  02:04:16  mcooper
X * Change GetMemoryStr() to GetMemory().
X *
X * Revision 1.6  1992/03/31  02:22:03  mcooper
X * Fix failed return value from CheckNlist().
X *
X * Revision 1.5  1992/03/31  01:55:17  mcooper
X * Use new CheckNlist to check nlist success.
X *
X * Revision 1.4  1992/03/31  00:15:09  mcooper
X * Add error check for nlist.n_type.
X *
X * Revision 1.3  1992/03/28  21:59:28  mcooper
X * Implemented disk and netif device probing.
X *
X * Revision 1.2  1992/03/22  02:03:48  mcooper
X * Add Build*NeXT*() functions.
X *
X * Revision 1.1  1992/03/22  01:04:34  mcooper
X * Initial revision
X *
X */
X
X
X/*
X * NeXT specific functions
X */
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X#include <nlist.h>
X#include <mntent.h>
X#include <nextdev/disk.h>
X#include <nextdev/busvar.h>
X
X#define DV_SIZE		(sizeof(struct bus_device))
X#define DR_SIZE		(sizeof(struct bus_driver))
X#define CR_SIZE		(sizeof(struct bus_ctrl))
X
X/*
X * Build a device tree by searching NeXTBus
X */
Xstatic int BuildNeXTBus(TreePtr)
X    DEVICE 		      **TreePtr;
X{
X    extern struct nlist 	NeXTBusNL[];
X    static struct bus_device 	Device;
X    static struct bus_driver 	Driver;
X    static struct bus_ctrl 	Ctlr;
X    static char 		CtlrName[BUFSIZ], DevName[BUFSIZ];
X    u_long 			Addr, DeviceAddr;
X    static DEVDATA 		DevData;
X    DEVICE 		       *Dev;
X    kvm_t		       *kd;
X
X    /*
X     * Read table address from kernel
X     */
X    if (!(kd = KVM_open(NeXTBusNL))) {
X	if (Debug) Error("Cannot read NeXTBus device table from kernel.");
X	return(-1);
X    }
X
X    /*
X     * See if we got a valid entry
X     */
X    if (CheckNlist(&NeXTBusNL[0]))
X	return(-1);
X
X    /*
X     * Read each device table entry.  A NULL device.bd_driver
X     * indicates that we're at the end of the table.
X     */
X    for (DeviceAddr = NeXTBusNL[0].n_value; DeviceAddr; 
X	 DeviceAddr += DV_SIZE) {
X
X	/*
X	 * Read this device
X	 */
X	if (KVM_read(kd, DeviceAddr, (char *) &Device, DV_SIZE)) {
X	    if (Debug) 
X		Error("Cannot read NeXTbus device from address 0x%x.", 
X		      DeviceAddr);
X	    KVM_close(kd);
X	    return(-1);
X	}
X
X	/*
X	 * See if we're done.
X	 */
X	if (!Device.bd_driver)
X	    break;
X
X	/*
X	 * Get the device name
X	 */
X	DevName[0] = C_NULL;
X	if (Addr = (u_long) Device.bd_name) {
X	    if (KVM_read(kd, Addr, (char *) DevName, sizeof(DevName))) {
X		if (Debug)
X		    Error("Cannot read device name from address 0x%x.", Addr);
X		continue;
X	    }
X	}
X
X	/*
X	 * Get the controller info
X	 */
X	CtlrName[0] = C_NULL;
X	/*
X	 * First read the controller structure in
X	 */
X	if (Addr = (u_long) Device.bd_bc) {
X	    if (KVM_read(kd, Addr, (char *) &Ctlr, CR_SIZE)) {
X		if (Debug) 
X		    Error("Cannot read controller from address 0x%x.", Addr);
X	    } else if (Addr = (u_long) Ctlr.bc_driver) {
X		/*
X		 * Get the controller driver
X		 */
X		if (KVM_read(kd, Addr, (char *) &Driver, DR_SIZE)) {
X		    if (Debug)
X			Error(
X			    "Cannot read controller driver from address 0x%x.",
X			      Addr);
X		    continue;
X		}
X		/*
X		 * Read the name of the controller from the driver
X		 */
X		if (!(Addr = (u_long) Driver.br_cname)) {
X		    if (Debug)
X			Error("No name for controller at address 0x%x.",
X			      Ctlr.bc_driver);
X		    continue;
X		}
X		if (KVM_read(kd, Addr, CtlrName, sizeof(CtlrName))) {
X		    if (Debug)
X			Error("Read controller name failed (address 0x%x).",
X			      Addr);
X		    continue;
X		}
X	    }
X	}
X
X	if (Debug)
X	    printf("NeXTbus: Found '%s' on '%s'.\n", DevName, CtlrName);
X
X	/* Make sure devdata is clean */
X	bzero(&DevData, sizeof(DEVDATA));
X
X	/* Set what we know */
X	if (DevName[0]) {
X	    DevData.dd_devname = strdup(DevName);
X	    DevData.dd_devunit = Device.bd_unit;
X	    DevData.dd_slave = Device.bd_slave;
X	}
X	if (CtlrName[0]) {
X	    DevData.dd_ctlrname = strdup(CtlrName);
X	    DevData.dd_ctlrunit = Ctlr.bc_ctrl;
X	}
X
X	/* 
X	 * NeXTbus devices should always exist.
X	 */
X	if (Device.bd_alive)
X	    DevData.dd_flags |= DD_IS_ALIVE;
X
X	/* Probe and add device */
X	if (Dev = (DEVICE *) ProbeDevice(&DevData, TreePtr, NULL))
X	    AddDevice(Dev, TreePtr);
X    }
X
X    KVM_close(kd);
X
X    return(0);
X}
X
X/*
X * Build list of NeXT devices
X */
Xextern int BuildDevicesNeXT(TreePtr)
X    DEVICE 		      **TreePtr;
X{
X    int				Found = 1;
X
X    if (BuildNeXTBus(TreePtr) == 0)
X	Found = 0;
X
X    return(Found);
X}
X
X/*
X * Get the system model name.  NeXT keeps the system type
X * in a kernel variable called machine_type.
X * The system types are defined in <next/scr.h>.
X */
Xextern char *GetModelName()
X{
X    extern NAMETAB		ModelTab[];
X    extern struct nlist		MachineTypeNL[];
X    u_char			MachineType;
X    register int		i;
X    kvm_t		       *kd;
X
X    if (!(kd = KVM_open(MachineTypeNL))) {
X	if (Debug) Error("Cannot find machine_type symbol in kernel.");
X	return((char *) NULL);
X    }
X
X    /*
X     * See if we got a valid entry
X     */
X    if (CheckNlist(&MachineTypeNL[0]))
X	return((char *) NULL);
X
X    if (KVM_read(kd, (u_long) MachineTypeNL[0].n_value, 
X		 (char *) &MachineType, sizeof(MachineType))) {
X	if (Debug) Error("Cannot read \"%s\" from kernel.", 
X			 GetNlName(MachineTypeNL[0]));
X	return((char *) NULL);
X    }
X
X    KVM_close(kd);
X
X    for (i = 0; ModelTab[i].name; ++i)
X	if (ModelTab[i].value == MachineType)
X	    return(ModelTab[i].name);
X
X    if (Debug)
X	printf("system model/type %d is unknown.\n", MachineType);
X
X    return((char *) NULL);
X}
X
X/*
X * Get kernel version string using Mach HostInfo method
X */
Xextern char *GetKernelVersionStr()
X{
X    return(GetKernelVersionFromHostInfo());
X}
X
X/*
X * Get amount of physical memory using Mach HostInfo method
X */
Xextern char *GetMemory()
X{
X    return(GetMemoryFromHostInfo());
X}
X
X/*
X * Get application architecture name using Mach HostInfo method.
X */
Xextern char *GetAppArchName()
X{
X    return(GetAppArchFromHostInfo());
X}
X
X/*
X * Get kernel architecture name using Mach HostInfo method.
X */
Xextern char *GetKernArchName()
X{
X    return(GetKernArchFromHostInfo());
X}
X
X/*
X * Get system serial number
X */
Xextern char *GetSerialNoStr()
X{
X    /* No support */
X    return((char *) NULL);
X}
X
X/*
X * Get OS version using Mach HostInfo method.
X */
Xextern char *GetOSVersionStr()
X{
X    return(GetOSVersionFromHostInfo());
X}
X
X/*
X * Get filesystem mount info for a partition.
X */
Xstatic char *GetMountInfo(Name, Part)
X    char 		       *Name;
X    char 		       *Part;
X{
X    FILE 		       *mf;
X    struct mntent 	       *mntent;
X    char 		       *file;
X
X    if (!Name)
X	return((char *) NULL);
X
X    file = GetCharFile(Name, Part);
X
X    if ((mf = setmntent(MNTTAB, "r")) == NULL) {
X	Error("%s: Cannot open for reading: %s.", MNTTAB, SYSERR);
X	return(NULL);
X    }
X
X    while (mntent = getmntent(mf)) {
X	if (strcmp(mntent->mnt_fsname, file) == 0)
X	    break;
X    }
X
X    endmntent(mf);
X
X    return((mntent) ? mntent->mnt_dir : (char *) NULL);
X}
X
X/*
X * Get disk partition information
X */
Xstatic DISKPART *GetDiskPart(Name, DiskLabel)
X    char		       *Name;
X    struct disk_label	       *DiskLabel;
X{
X    register int		i;
X    register DISKPART	       *Ptr;
X    DISKPART		       *Base = NULL;
X    DISKPART			DiskPart;
X    static char			Part[2];
X    register char	       *p;
X
X    Part[1] = C_NULL;
X
X    /*
X     * Now handle each partition
X     */
X    for (i = 0; i < NPART; i++) {
X	/* Ingore partitins that have no size */
X	if (DiskLabel->dl_dt.d_partitions[i].p_size <= 0)
X	    continue;
X
X	Part[0] = 'a' + i;
X
X	/* Make a clean slate */
X	bzero((char *) &DiskPart, sizeof(DISKPART));
X
X	/* Fill in the blanks */
X	DiskPart.dp_name = strdup(Part);
X	DiskPart.dp_stsect = DiskLabel->dl_dt.d_partitions[i].p_base;
X	DiskPart.dp_nsect = DiskLabel->dl_dt.d_partitions[i].p_size;
X
X	/* 
X	 * Get the mount point name.
X	 */
X	if (p = GetMountInfo(Name, Part))
X	    DiskPart.dp_mnt = strdup(p);
X
X	/*
X	 * Add this partition to the linked list.
X	 */
X	if (Base) {
X	    for (Ptr = Base; Ptr && Ptr->dp_nxt; Ptr = Ptr->dp_nxt);
X	    Ptr->dp_nxt = NewDiskPart(&DiskPart);
X	} else {
X	    Base = NewDiskPart(&DiskPart);
X	}
X    }
X
X    return(Base);
X}
X
X/*
X * Convert disk info into a DEVICE entry.
X */
Xstatic DEVICE *diskToDiskDrive(Name, DevData, DevDataTab, DiskLabel, DriveInfo)
X    char		       *Name;
X    DEVDATA		       *DevData;
X    DEVDATATAB		       *DevDataTab;
X    struct disk_label	       *DiskLabel;
X    struct drive_info	       *DriveInfo;
X{
X    DEVICE		       *Device;
X    DISKDRIVE		       *DiskDrive;
X    static char 		Buf[BUFSIZ];
X
X    if ((Device = NewDevice(NULL)) == NULL) {
X	Error("Cannot create new device entry.");
X	return((DEVICE *) NULL);
X    }
X
X    if ((DiskDrive = NewDiskDrive(NULL)) == NULL) {
X	Error("Cannot create new diskdrive entry.");
X	return((DEVICE *) NULL);
X    }
X
X    Device->dv_name 		= strdup(Name);
X    Device->dv_type 		= DT_DISKDRIVE;
X    DiskDrive->dd_label 	= strdup(DriveInfo->di_name);
X    Device->dv_model 		= DiskDrive->dd_label;
X    DiskDrive->dd_unit 		= DevData->dd_devunit;
X    DiskDrive->dd_slave 	= DevData->dd_slave;
X    DiskDrive->dd_dcyl 		= DiskLabel->dl_ncyl;
X    DiskDrive->dd_heads 	= DiskLabel->dl_ntrack;
X    DiskDrive->dd_sect 		= DiskLabel->dl_nsect;
X    DiskDrive->dd_apc 		= DiskLabel->dl_ngroups;
X    DiskDrive->dd_rpm 		= DiskLabel->dl_rpm;
X    DiskDrive->dd_secsize 	= DiskLabel->dl_secsize;
X    /*
X     * Only get partition info we we're going to print it later.
X     */
X    if (VL_ALL)
X	DiskDrive->dd_part 	= GetDiskPart(Name, DiskLabel);
X
X    /*
X     * Determine size (capacity) of media
X     */
X    if (DiskDrive->dd_dcyl && DiskDrive->dd_sect && DiskDrive->dd_heads)
X	DiskDrive->dd_size = nsect_to_bytes(DiskDrive->dd_dcyl * 
X					    DiskDrive->dd_sect * 
X					    DiskDrive->dd_heads, 
X					    DiskDrive->dd_secsize);
X
X    /*
X     * Create the description
X     */
X    if (DiskDrive->dd_size > 0) {
X	(void) sprintf(Buf, "%.2f MB capacity", 
X		       (float) bytes_to_mbytes(DiskDrive->dd_size));
X	Device->dv_desc = strdup(Buf);
X    }
X
X    Device->dv_devspec = (caddr_t *) DiskDrive;
X    Device->dv_master = MkMasterFromDevData(DevData);
X
X    return(Device);
X}
X
X/*
X * Query and learn about a disk.
X */
Xextern DEVICE *ProbeDiskDrive(Name, DevData, DevDataTab)
X    /*ARGSUSED*/
X    char 		       *Name;
X    DEVDATA 		       *DevData;
X    DEVDATATAB 	     	       *DevDataTab;
X{
X    static struct disk_label    DiskLabel;
X    static struct drive_info 	DriveInfo;
X    int				Desc;
X    char		       *File;
X    DEVICE		       *Device;
X
X    File = GetRawFile(Name, "a");
X
X    if ((Desc = open(File, O_RDONLY|O_NDELAY)) < 0) {
X	if (Debug) Error("%s: Cannot open for read: %s.\n", File, SYSERR);
X	/*
X	 * If we know for sure this drive is present and we
X	 * know something about it, then create a minimal device.
X	 */
X	if ((DevDataTab->ddt_model || DevDataTab->ddt_desc) &&
X	    FLAGS_ON(DevData->dd_flags, DD_IS_ALIVE)) {
X	    Device = NewDevice((DEVICE *) NULL);
X	    Device->dv_name = strdup(Name);
X	    Device->dv_unit = DevData->dd_devunit;
X	    Device->dv_master = MkMasterFromDevData(DevData);
X	    Device->dv_type = DT_DISKDRIVE;
X	    Device->dv_model = DevDataTab->ddt_model;
X	    Device->dv_desc = DevDataTab->ddt_desc;
X	    return(Device);
X	} else
X	    return((DEVICE *) NULL);
X    }
X
X    /*
X     * Read disk label
X     */
X    if (ioctl(Desc, DKIOCGLABEL, &DiskLabel) < 0) {
X	if (Debug) Error("%s: DKIOCGLABEL: %s.", File, SYSERR);
X	return((DEVICE *) NULL);
X    }
X
X    /*
X     * Read drive info
X     */
X    if (ioctl(Desc, DKIOCINFO, &DriveInfo) < 0) {
X	if (Debug) Error("%s: DKIOCINFO: %s.", File, SYSERR);
X	return((DEVICE *) NULL);
X    }
X
X    close(Desc);
X
X    if (!(Device = diskToDiskDrive(Name, DevData, DevDataTab, 
X				   &DiskLabel, &DriveInfo))) {
X	Error("%s: Cannot convert diskdrive info.", Name);
X	return((DEVICE *) NULL);
X    }
X
X    return(Device);
X}
X
X/*
X * Get ROM Version
X */
Xextern char *GetRomVer()
X{
X    /* No support */
X    return((char *) NULL);
X}
END_OF_os-next.c
if test 12325 -ne `wc -c <os-next.c`; then
    echo shar: \"os-next.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f info-next.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"info-next.c\"
else
echo shar: Extracting \"info-next.c\" \(2289 characters\)
sed "s/^X//" >info-next.c <<'END_OF_info-next.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/info-next.c,v 1.5 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: info-next.c,v $
X * Revision 1.5  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.4  1992/04/17  01:10:11  mcooper
X * Moved DEVICE *() function declares to defs.h.
X *
X * Revision 1.3  1992/03/28  21:59:28  mcooper
X * Implemented disk and netif device probing.
X *
X * Revision 1.2  1992/03/22  02:02:26  mcooper
X * Add NeXTBusNL nlist.
X *
X * Revision 1.1  1992/03/22  01:04:34  mcooper
X * Initial revision
X *
X */
X
X
X/*
X * NeXT related information
X */
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X#include <nlist.h>
X
X/*
X * Kernel variable containing model number.
X */
Xstruct nlist MachineTypeNL[] = {
X#if	!defined(COFF)
X    { "_machine_type" },
X#else
X    { "machine_type" },
X#endif	/* COFF */
X    { 0 },
X};
X
X/*
X * Kernel symbol for the device table
X */
Xstruct nlist NeXTBusNL[] = {
X#if	!defined(COFF)
X    { "_bus_dinit" },
X#else
X    { "bus_dinit" },
X#endif	/* COFF */
X    { 0 },
X};
X
X/*
X * Models of NeXT machines as defined in <next/scr.h>
X */
X#include <next/scr.h>
XNAMETAB ModelTab[] = {
X#ifdef NeXT_CUBE
X    {  NeXT_CUBE, 	"NeXTCube (MC68030)" },
X#endif
X#ifdef NeXT_WARP9
X    {  NeXT_WARP9,	"NeXTStation" },
X#endif
X#ifdef NeXT_X15
X    {  NeXT_X15,	"NeXTCube (MC68040)" },
X#endif
X#ifdef NeXT_WARP9C
X    {  NeXT_WARP9C,	"NeXTWarp9C" },
X#endif
X    {  0 },
X};
X
X/*
X * Device Data Table
X *
X * Compares are done by the length of the string appearing in
X * the first columns.  Therefore, longer names must appear before
X * any shorter names that are not unique.  e.g. "lebuffer" needs to
X * be before "le".
X */
XDEVDATATAB DevDataTab[] = {
X    { "sc",		0,	NULL,	"SCSI Controller", 		NULL },
X    { "odc",		0,	NULL,	"Optical Disk Controller", 	NULL },
X    { "fdc",		0,	NULL,	"Floppy Disk Controller", 	NULL },
X    { "sd",		0,	NULL,	NULL,		ProbeDiskDrive },
X    { "od",		0,	NULL,	NULL,		ProbeDiskDrive },
X    { "fd",		0,	NULL,	NULL,		ProbeDiskDrive },
X    { "en",		0,	
X	  "EtherNet Interface",	"10Mb/sec Ethernet",	ProbeNetif },
X    {  0 },
X};
END_OF_info-next.c
if test 2289 -ne `wc -c <info-next.c`; then
    echo shar: \"info-next.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f os-alliant.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"os-alliant.c\"
else
echo shar: Extracting \"os-alliant.c\" \(4553 characters\)
sed "s/^X//" >os-alliant.c <<'END_OF_os-alliant.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/os-alliant.c,v 1.9 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: os-alliant.c,v $
X * Revision 1.9  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.8  1992/04/17  23:27:51  mcooper
X * Add support for ROM Version information (Sun only for now).
X *
X * Revision 1.7  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.6  1992/04/15  02:04:16  mcooper
X * Change GetMemoryStr() to GetMemory().
X *
X * Revision 1.5  1992/03/31  19:00:15  mcooper
X * A working version.
X *
X * Revision 1.4  1992/03/31  02:22:03  mcooper
X * Fix failed return value from CheckNlist().
X *
X * Revision 1.3  1992/03/31  01:55:17  mcooper
X * Use new CheckNlist to check nlist success.
X *
X * Revision 1.2  1992/03/31  00:15:09  mcooper
X * Add error check for nlist.n_type.
X *
X * Revision 1.1  1992/03/01  23:28:16  mcooper
X * Initial revision
X *
X */
X
X/*
X * Alliant specific functions
X */
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X#include <fcntl.h>
X#include <nlist.h>
X
X/*
X * All the wonderful global extern declarations
X */
X#if	defined(HAVE_USERETC)
Xstruct bpb 		       *useretc = (struct bpb *)USERETC;
X#endif	/* HAVE_USERETC */
X#if	defined(HAVE_MODELNUM)
Xextern int			modelnum;
X#endif	/* HAVE_MODELNUM */
X#if	defined(HAVE_MEMORYSIZE)
Xextern int			memorysize;
X#endif	/* HAVE_MEMORYSIZE */
X#if	defined(HAVE_SERIALNUM)
Xextern int			serialnum;
X#endif	/* HAVE_SERIALNUM */
X
X/*
X * Lookup a model value (val) and returns it's name.
X */
Xextern char *GetModelName()
X{
X    register int 		i;
X    register int		Num = -1;
X    extern NAMETAB 		ModelTab[];
X
X#if	defined(HAVE_MODELNUM)
X    /*
X     * Alliant 2800's have an external variable
X     * called "modelnum".
X     */
X    Num = modelnum;
X#endif	/* HAVE_MODELNUM */
X#if	defined(HAVE_USERETC)
X    /*
X     * Alliant FX/80's have an external variable
X     * called "useretc".
X     */
X    Num = useretc->bp_model;
X#endif	/* HAVE_USERETC */
X
X    for (i = 0; ModelTab[i].name; ++i) {
X	if (ModelTab[i].value == Num)
X	    return(ModelTab[i].name);
X    }
X
X    return((char *) NULL);
X}
X
X/*
X * Get amount of memory.
X */
Xextern char *GetMemory()
X{
X    static char			Buf[BUFSIZ];
X    int				Amount = -1;
X#if	defined(HAVE_LIB_SYSCFG)
X    int 			mem, ip, ce, det, att;
X
X    lib_syscfg(&mem, &ip, &ce, &det, &att);
X    Amount = mem;
X#endif	/* HAVE_LIB_SYSCFG */
X#if	defined(HAVE_MEMORYSIZE)
X    Amount = memorysize;
X#endif	/* HAVE_MEMORYSIZE */
X
X    if (Amount > 0) {
X	(void) sprintf(Buf, "%d MB", Amount);
X	return(Buf);
X    } else
X	return((char *) NULL);
X}
X
X/*
X * Get kernel version string from kernel.
X */
Xextern char *GetKernelVersionStr()
X{
X    extern struct nlist		VersionInfoNL[];
X    static char			Version[BUFSIZ];
X    static char			VerName[BUFSIZ], VerDate[BUFSIZ];
X    register char	       *p;
X    kvm_t		       *kd;
X
X    Version[0] = C_NULL;
X
X    if (!(kd = KVM_open(VersionInfoNL))) {
X	if (Debug) Error("GetKernelVersionStr() KVM_open failed.");
X	return((char *) NULL);
X    }
X
X    /*
X     * See if we got a valid entry
X     */
X    if (CheckNlist(&VersionInfoNL[0]) || CheckNlist(&VersionInfoNL[1]))
X	return((char *) NULL);
X
X    if (KVM_read(kd, VersionInfoNL[0].n_value, (char *) VerName, 
X		 sizeof(VerName))) {
X	if (Debug) Error("GetKernelVersionStr() KVM_read versionname failed.");
X	return((char *) NULL);
X    }
X
X    if (KVM_read(kd, VersionInfoNL[1].n_value, (char *) VerDate, 
X		  sizeof(VerDate))) {
X	if (Debug) Error("GetKernelVersionStr() KVM_read versiondate failed.");
X	return((char *) NULL);
X    }
X
X    if (kd)
X	KVM_close(kd);
X
X    /*
X     * Zap trailing white space
X     */
X    p = VerName;
X    p = p + strlen(VerName) - 1;
X    while (*p == ' ') {
X	*p = C_NULL;
X	*--p;
X    }
X
X    (void) sprintf(Version, "%s: %s", VerName, VerDate);
X
X    return(Version);
X}
X
X/*
X * Get system serial number.
X */
Xextern char *GetSerialNoStr()
X{
X#if	defined(HAVE_SERIALNUM)
X    /*
X     * Use global variable "serialnum"
X     */
X    return(itoa(serialnum));
X#endif	/* HAVE_SERIALNUM */
X#if	defined(HAVE_USERETC)
X    /*
X     * Use global variable "useretc"
X     */
X    return(itoa(useretc->bp_serialnum));
X#endif 	/* HAVE_USERETC */
X}
X
X/*
X * Get OS Version string
X */
Xextern char *GetOSVersionStr()
X{
X    return(GetOSVersionFromKernVer());
X}
X
X/*
X * Get ROM Version
X */
Xextern char *GetRomVer()
X{
X    /* No support */
X    return((char *) NULL);
X}
END_OF_os-alliant.c
if test 4553 -ne `wc -c <os-alliant.c`; then
    echo shar: \"os-alliant.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f info-alliant.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"info-alliant.c\"
else
echo shar: Extracting \"info-alliant.c\" \(1404 characters\)
sed "s/^X//" >info-alliant.c <<'END_OF_info-alliant.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/info-alliant.c,v 1.3 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: info-alliant.c,v $
X * Revision 1.3  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.2  1992/03/31  19:00:15  mcooper
X * A working version.
X *
X * Revision 1.2  1992/03/31  19:00:15  mcooper
X * A working version.
X *
X * Revision 1.1  1992/03/01  23:28:16  mcooper
X * Initial revision
X *
X */
X
X/*
X * Alliant specific information
X */
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X#include <nlist.h>
X
X/*
X * Kernel version symbols
X */
Xstruct nlist VersionInfoNL[] = {
X    { "_versionname" },
X    { "_versiondate" },
X    { 0 },
X};
X
X/*
X * Table of Alliant system models
X */ 
XNAMETAB ModelTab[] = {
X#ifdef MODELNUM_FX2800
X    {  MODELNUM_FX2800,		"FX2800" },
X#endif
X#ifdef MODELNUM_FX800
X    {  MODELNUM_FX800,		"FX800" },
X#endif
X#ifdef BPB_FX1
X    {  BPB_FX1,			"FX1" },
X#endif
X#ifdef BPB_FX4
X    {  BPB_FX4,			"FX4" },
X#endif
X#ifdef BPB_FX40
X    {  BPB_FX40,		"FX40" },
X#endif
X#ifdef BPB_FX8
X    {  BPB_FX8,			"FX80" },
X#endif
X#ifdef BPB_FX80
X    {  BPB_FX80,		"FX80" },
X#endif
X};
X
X/*
X * No device support
X */
XDEVDATATAB DevDataTab[] = {
X    { 0 },
X};
END_OF_info-alliant.c
if test 1404 -ne `wc -c <info-alliant.c`; then
    echo shar: \"info-alliant.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f os-bsd43.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"os-bsd43.c\"
else
echo shar: Extracting \"os-bsd43.c\" \(2474 characters\)
sed "s/^X//" >os-bsd43.c <<'END_OF_os-bsd43.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/os-bsd43.c,v 1.6 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: os-bsd43.c,v $
X * Revision 1.6  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.5  1992/04/17  23:27:51  mcooper
X * Add support for ROM Version information (Sun only for now).
X *
X * Revision 1.4  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.3  1992/04/16  19:58:12  mcooper
X * De-linting stuff.
X *
X * Revision 1.2  1992/04/15  02:04:16  mcooper
X * Change GetMemoryStr() to GetMemory().
X *
X * Revision 1.1  1992/03/31  02:39:03  mcooper
X * Initial revision
X *
X */
X
X
X/*
X * 4.3BSD specific functions
X */
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X#include <sys/types.h>
X#include <nlist.h>
X
X/*
X * Get the system model name.  
X * 4.3BSD (MtXinu) keeps a kernel variable "machineid" which
X * is the type of machine as defined in <machine/cpu.h>.
X */
Xextern char *GetModelName()
X{
X    extern NAMETAB		ModelTab[];
X    extern struct nlist		MachineIDNL[];
X    static int			machineid;
X    register int		i;
X    kvm_t		       *kd;
X
X    if (!(kd = KVM_open(MachineIDNL))) {
X	if (Debug) Error("Cannot find MachineID symbol in kernel.");
X	return((char *) NULL);
X    }
X
X    /*
X     * See if we got a valid entry
X     */
X    if (CheckNlist(&MachineIDNL[0]))
X	return((char *) NULL);
X
X    if (KVM_read(kd, (u_long) MachineIDNL[0].n_value, (char *) &machineid,
X		 sizeof(machineid))) {
X	if (Debug) Error("Cannot read machineid from kernel.");
X	return((char *) NULL);
X    }
X
X    KVM_close(kd);
X
X    for (i = 0; ModelTab[i].name; ++i)
X	if (ModelTab[i].value == machineid)
X	    return(ModelTab[i].name);
X
X    if (Debug)
X	printf("system model/type %d is unknown.\n", machineid);
X
X    return((char *) NULL);
X}
X
X/*
X * Get kernel version string from kernel symbol "version".
X */
Xextern char *GetKernelVersionStr()
X{
X    return(GetKernelVersionFromVersion());
X}
X
X/*
X * Get amount of physical memory using kernel symbol "physmem".
X */
Xextern char *GetMemory()
X{
X    return(GetMemoryFromPhysmem());
X}
X
X/*
X * Get system serial number
X */
Xextern char *GetSerialNoStr()
X{
X    /* No support */
X    return((char *) NULL);
X}
X
X/*
X * Get ROM Version
X */
Xextern char *GetRomVer()
X{
X    /* No support */
X    return((char *) NULL);
X}
END_OF_os-bsd43.c
if test 2474 -ne `wc -c <os-bsd43.c`; then
    echo shar: \"os-bsd43.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f info-bsd43.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"info-bsd43.c\"
else
echo shar: Extracting \"info-bsd43.c\" \(1379 characters\)
sed "s/^X//" >info-bsd43.c <<'END_OF_info-bsd43.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/info-bsd43.c,v 1.2 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: info-bsd43.c,v $
X * Revision 1.2  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.1  1992/03/31  02:39:03  mcooper
X * Initial revision
X *
X * Revision 1.1  1992/03/31  02:39:03  mcooper
X * Initial revision
X *
X */
X
X
X/*
X * 4.3BSD specific info
X */
X
X#include "system.h"
X#include "defs.h"
X
X#include <sys/types.h>
X#include <machine/cpu.h>
X#include <nlist.h>
X
X/*
X * No device support
X */
XDEVDATATAB DevDataTab[] = {
X    { 0 },
X};
X
X/*
X * MachineID symbol
X */
Xstruct nlist MachineIDNL[] = {
X#if	defined(COFF)
X    { "machineid" },
X#else
X    { "_machineid" },
X#endif	/* COFF */
X    { 0 },
X};
X
X/*
X * Model's as found in kernel variable "machineid" and
X * defined in <machine/cpu.h>.
X */
XNAMETAB ModelTab[] = {
X#ifdef HP_320
X    {  HP_320,		"HP9000/320" },
X#endif
X#ifdef HP_330
X    {  HP_330,		"HP9000/330" },
X#endif
X#ifdef HP_340
X    {  HP_340,		"HP9000/340" },
X#endif
X#ifdef HP_350
X    {  HP_350,		"HP9000/350" },
X#endif
X#ifdef HP_360
X    {  HP_360,		"HP9000/360" },
X#endif
X#ifdef HP_370
X    {  HP_370,		"HP9000/370" },
X#endif
X    {  0 },
X};
X
END_OF_info-bsd43.c
if test 1379 -ne `wc -c <info-bsd43.c`; then
    echo shar: \"info-bsd43.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f os-aix.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"os-aix.c\"
else
echo shar: Extracting \"os-aix.c\" \(2552 characters\)
sed "s/^X//" >os-aix.c <<'END_OF_os-aix.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/os-aix.c,v 1.5 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: os-aix.c,v $
X * Revision 1.5  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.4  1992/04/17  23:27:51  mcooper
X * Add support for ROM Version information (Sun only for now).
X *
X * Revision 1.3  1992/04/17  01:07:59  mcooper
X * More de-linting
X *
X * Revision 1.2  1992/04/15  02:04:16  mcooper
X * Change GetMemoryStr() to GetMemory().
X *
X * Revision 1.1  1992/03/28  23:57:38  mcooper
X * Initial revision
X *
X */
X
X
X/*
X * AIX specific functions
X */
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X#include <sys/utsname.h>
X
X/*
X * Get the system model name.
X */
Xextern char *GetModelName()
X{
X    extern NAMETAB		ModelTab[];
X    struct utsname		utsname;
X    register int		i, type;
X    register char	       *p;
X
X    if (uname(&utsname) == SYSFAIL) {
X	if (Debug) Error("uname() failed: %s.", SYSERR);
X	return((char *) NULL);
X    }
X
X    /*
X     * XXX HARDCODED value
X     *
X     * The following assumes that utsname.machine is of format
X     *
X     *	xxyyyyyyMMss
X     *
X     *		xx  	= 00 (always)
X     *		yyyyyy	= unique CPU ID
X     *		MM	= model number
X     *		ss	= 00 (always)
X     */
X    if (strlen(utsname.machine) != 12) {
X	if (Debug) Error("The format of utsname.machine has changed!");
X	return((char *) NULL);
X    }
X    p = utsname.machine;
X    p += 8;
X    if (strlen(p) > 2)
X	*(p+2) = (char)NULL;
X
X    for (i = 0; ModelTab[i].name; ++i)
X	if (EQ(p, ModelTab[i].valuestr))
X	    return(ModelTab[i].name);
X
X    if (Debug)
X	Error("system model/type %s is unknown.\n", p);
X
X    return((char *) NULL);
X}
X
X/*
X * Get kernel version string from kernel symbol "version".
X */
Xextern char *GetKernelVersionStr()
X{
X    return(GetKernelVersionFromVersion());
X}
X
X/*
X * Get amount of physical memory using kernel symbol "physmem".
X */
Xextern char *GetMemory()
X{
X    return(GetMemoryFromPhysmem());
X}
X
X/*
X * Get system serial number
X */
Xextern char *GetSerialNoStr()
X{
X    /* No support */
X    return((char *) NULL);
X}
X
X/*
X * Get name of OS
X */
Xextern char *GetOSNameStr()
X{
X    return(GetOSNameFromUname());
X}
X
X/*
X * Get version of OS
X */
Xextern char *GetOSVersionStr()
X{
X    return(GetOSVersionFromUname());
X}
X
X/*
X * Get ROM Version
X */
Xextern char *GetRomVer()
X{
X    /* No support */
X    return((char *) NULL);
X}
END_OF_os-aix.c
if test 2552 -ne `wc -c <os-aix.c`; then
    echo shar: \"os-aix.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f info-aix.c -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"info-aix.c\"
else
echo shar: Extracting \"info-aix.c\" \(1088 characters\)
sed "s/^X//" >info-aix.c <<'END_OF_info-aix.c'
X/*
X * Copyright (c) 1992 Michael A. Cooper.
X * This software may be freely distributed provided it is not sold for 
X * profit and the author is credited appropriately.
X */
X
X#ifndef lint
Xstatic char *RCSid = "$Header: /src/common/usc/bin/sysinfo/RCS/info-aix.c,v 1.2 1992/04/26 23:32:06 mcooper Exp $";
X#endif
X
X/*
X * $Log: info-aix.c,v $
X * Revision 1.2  1992/04/26  23:32:06  mcooper
X * Add Copyright notice
X *
X * Revision 1.1  1992/03/28  23:57:38  mcooper
X * Initial revision
X *
X */
X
X
X/*
X * AIX related information
X */
X
X#include <stdio.h>
X#include "system.h"
X#include "defs.h"
X
X/*
X * These values were gleamed from a copy of the
X * AIXpert magazine.
X */
XNAMETAB ModelTab[] = {
X    { 0, "RS6000/320",			"31" },
X    { 0, "RS6000/320H",			"35" },
X    { 0, "RS6000/520",			"30" },
X    { 0, "RS6000/[57]30",		"10" },
X    { 0, "RS6000/530H",			"18" },
X    { 0, "RS6000/540",			"14" },
X    { 0, "RS6000/550",			"1C" },
X    { 0, "RS6000/930",			"20" },
X    { 0, "RS6000/950",			"2E" },
X    { 0 },
X};
X
X/*
X * Device Data Table (Not implemented yet)
X */
XDEVDATATAB DevDataTab[] = {
X    {  0 },
X};
END_OF_info-aix.c
if test 1088 -ne `wc -c <info-aix.c`; then
    echo shar: \"info-aix.c\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f options.3 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"options.3\"
else
echo shar: Extracting \"options.3\" \(7383 characters\)
sed "s/^X//" >options.3 <<'END_OF_options.3'
X.\"
X.\" Copyright (c) 1990 Michael A. Cooper.
X.\" This software may be freely distributed provided it is not sold for 
X.\" profit and the author is credited appropriately.
X.\"
X.\" $Header: /src/common/usc/lib/libgen/RCS/options.3,v 1.4 1991/02/22 02:30:06 mcooper Exp $
X.\"
X.TH PARSEOPTIONS 3 "30 October 1990"
X.ds ]W USC-UCS
X.SH NAME
XParseOptions, UsageOptions, HelpOptions, Num_Opts \- Parse command line options
X.SH SYNOPSIS
X.LP
X.nf
X.ft B
X#include "/usr/usc/include/options.h"
X.ft
X.fi
X.LP
X.nf
X.ft B
Xint ParseOptions(options, num_options, argc, argv)
XOptionDescRec *options;
Xint num_options;
Xint argc;
Xchar **argv;
X.ft
X.fi
X.LP
X.nf
X.ft B
Xvoid UsageOptions(options, num_options, badoption)
XOptionDescRec *options;
Xint num_options;
Xchar *badoption;
X.ft
X.fi
X.LP
X.nf
X.ft B
Xvoid HelpOptions(options, num_options, message)
XOptionDescRec *options;
Xint num_options;
Xchar **message;
X.ft
X.fi
X.LP
X.nf
X.ft B
Xint Num_Opts(options)
XOptionDescRec *options;
X.ft
X.fi
X.LP
X.nf
X.ft B
Xextern char *OptionChars;
Xextern char *ProgramName;
X.ft
X.fi
X.SH DESCRIPTION
X.LP
X.BR ParseOptions(\|)
Xparses a given set of options found in
X.B argv.
XThe
X.B argc
Xparameter is the count of the number of string pointers
Xin 
X.B argv.
XBoth 
X.B argc
Xand
X.B argv
Xare typically passed directly from a
X.B main(\|)
Xfunction.
XThe
X.B argv
Xparameter should contain an array of strings that
Xneed to be parsed.
X.B ParseOptions(\|)
Xreturns the number of entries in
X.B argv
Xthat were successfully parsed or -1 upon error.
X.LP
XThe
X.B options
Xstructure should contain a valid description list of options.
XThe type
X.B OptionDescRec
Xis defined as the following in the
X.B "options.h"
Xheader file:
X.RS
X.LP
X.nf
X.ft B
Xtypedef struct {
X    char      *option;     /* Option string in argv */
X    int       flags;       /* Flag bits */
X    int       (*cvtarg)(); /* Function to convert argument */
X    caddr_t   valp;        /* Variable to set */
X    caddr_t   value;       /* Default value to provide */
X    char      *usage;      /* Usage message */
X    char      *desc;       /* Description message */
X} OptionDescRec, *OptionDescList;
X.ft R
X.fi
X.RE
X.LP
XThe order of
X.I options
Xis important because
Xthe first partial match found in
X.I options 
Xis used.
XThis allows abbreviations (except if the option is a
X.I StickArg
X[see below]).
XFor instance, a user may specify only "\-n" for "\-number" provided
Xthat "\-n" is unique to
X.I options
Xor that "\-number" is placed before any other "\-n*" options in
X.I options.
X.LP
XThe
X.I option
Xmember of
X.B OptionDescRec
Xis the string name of the option.
XThis is typically something like
X.RS
X.ft B
X.nf
X.sp
X"\-c"
X"+c"
X"\-file"
X.fi
X.sp
X.ft
X.RE
XThe first character of 
X.I option
Xis special.  It must be one of the characters know to be the
Xstart of an option.
XThe default list of starting option characters is "\-+".
XThis indicates that an option can start with either a "\-" or
Xa "+".  This list of characters may be changed by setting
Xthe variable
X.B OptionChars
Xto point to a string of custom starting option characters.
X.LP
XThe
X.I flags
Xmember is used to set bits to describe how an option
Xis to be interpreted.
XValid flags are defined in the
X.I "options.h"
Xheader file:
X.RS
X.IP NoArg
XNo argument for this option.  
XUse the value in 
X.I OptionDescRec.value 
Xto set the value in the
X.I valp
Xmember of 
X.B OptionDescRec.
X.IP IsArg
XValue is the option string itself.
X.IP SepArg
XValue is in next argument in argv.
X.IP StickyArg
XValue is the characters immediately following 
Xthe option.
X.IP SkipArg
XIgnore this option and the next argument in argv.
X.IP SkipLine
XIgnore this option and the rest of argv.
X.IP SkipNArgs
XIgnore this option and the next 
X.I OptionDescRes.value 
Xarguments in argv.
X.IP ArgHidden
XDon't show this option in usage or help messages.
X.RE
X.LP
XThe next member of
X.B OptionDescRec
Xis
X.I cvtarg.
XThis should be a pointer to a function that knows how to
Xconvert the given argument into the correct type.
XThe predefined functions are as follows:
X.RS
X.IP OptBool
XConverts a boolean.
X.IP OptInt
XConverts an integer.
X.IP OptShort
XConverts a short.
X.IP OptLong
XConverts a long.
X.IP OptStr
XConverts a string.
X.RE
X.LP
XThe
X.I valp
Xmember should be a pointer
Xto the variable that needs to be set.
X.I valp
Xshould accept whatever type
X.I cvtarg
Xis expected to return.
X.LP
XThe
X.I value
Xmember should contain a default value to
Xbe used if no value is given for an option or
Xthis type of option does not require an argument
X(according to the 
X.I flags
Xbits).
XIf 
X.I value 
Xis
X.B NULL
Xthen an argument for this option
Xis optional.
X.LP
X.I usage
Xis used to build usage and help messages.
XIt should be a string containing a description of any arguments
Xthat may be used for this option.
XThe option string itself should not be a part of 
X.I usage.
XThe 
X.B UsageOptions(\|)
Xand 
X.B HelpOptions(\|)
Xfunctions combine the
X.I option
Xfield with
X.I usage
Xand interpret the
X.I flags
Xbits to build a usage string.
XIf this field is 
X.B NULL,
Xthen just the
X.I option
Xfield itself is used for usage and help messages.
X.LP
XThe
X.I desc
Xmember is used to build a help message for this option.
XThis should be a string containing a brief description on what this
Xoption does.
X.LP
XThe
X.B num_options
Xparameter should be the number of 
X.B OptionDescRec's
Xfound in 
X.B options.
XThe function
X.BR Num_Opts(\|)
Xwill return the number of 
X.B OptionDescRec's.
X.LP
XThe
X.B UsageOptions(\|)
Xfunction
Xprints a usage message.
XIf
X.I badoption
Xis not 
X.B NULL, 
Xthen an initial message is displayed indicating that 
X.I badoption
Xis not a valid option.
X.LP
XThe
X.B HelpOptions(\|)
Xfunction
Xprints a nicely formatted message describing all options.
XIf
X.I message
Xis not 
X.B NULL
Xit is taken to be a message that is displayed in the output of
Xa "\-help" option.
X.SH EXAMPLE
X.LP
XHere is an example program:
X.nf
X.sp
X.ft B
X#include "options.h"
X
Xchar *filename = NULL;
Xint number = \-1;
Xint foo = \-1;
Xint I = \-1;
Xlong L = \-1;
Xshort S = \-1;
X
XOptionDescRec opts[] = {
X    {"\-foo",	NoArg,		OptBool, (caddr_t) &foo,	"0",
X     (char *)NULL,	"Disable foo bar"},
X    {"+foo",	NoArg,		OptBool, (caddr_t) &foo,       	"1",
X     (char *)NULL,	"Enable foo bar"},
X    {"\-I",	StickyArg,	OptInt, (caddr_t) &I,		(caddr_t) NULL,
X     (char *)NULL,	"Set value of I"},
X    {"\-L",	StickyArg,	OptLong, (caddr_t) &L,		(caddr_t) NULL,
X     (char *)NULL,	"Set value of L"},
X    {"\-S",	SepArg,		OptShort, (caddr_t) &S,		(caddr_t) NULL,
X     (char *)NULL,	"Set value of S"},
X    {"\-C",	StickyArg,	OptStr, (caddr_t) &filename,	(caddr_t) NULL,
X     (char *)NULL,	"Alternate file to use"},
X    {"\-number",	SepArg, 	OptInt, (caddr_t) &number,	"66",
X     "interval",	NULL},
X    {"\-file",	SepArg, 	OptStr, (caddr_t) &filename,	(caddr_t) NULL,
X     "filename",	"Specify alternate file to use"},
X};
X
Xmain(argc, argv)
X     int argc;
X     char **argv;
X{
X    int c;
X
X    c = ParseOptions(opts, Num_Opts(opts), argc, argv);
X    printf("Count = %d of %d\n", c, argc);
X}
X.ft
X.fi
X.SH "RETURN VALUES"
X.B ParseOptions(\|)
Xreturns the number of arguments parsed or -1 upon error.
X.SH NOTES
X.LP
XThe
X.I \-help
Xoption is automatically built into 
X.B ParseOptions(\|).
X.LP
XAll error messages are sent to 
X.B stderr.
X.LP
XAn option may be both 
X.I StickyArg
Xand
X.I SepArg.
XIf both are set for one option, preference is given to
X.I SepArg
Xparsing.
XAlso, no appreviations are allowed.
X.SH AUTHOR
XMichael A. Cooper, 
X.br
XUniversity Computing Services, 
X.br
XUniversity of Southern California.
END_OF_options.3
if test 7383 -ne `wc -c <options.3`; then
    echo shar: \"options.3\" unpacked with wrong size!
fi
# end of overwriting check
fi
if test -f Mkfile.cpp -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"Mkfile.cpp\"
else
echo shar: Extracting \"Mkfile.cpp\" \(3024 characters\)
sed "s/^X//" >Mkfile.cpp <<'END_OF_Mkfile.cpp'
X#
X# $Header: /src/common/usc/bin/sysinfo/RCS/Mkfile.cpp,v 1.24 1992/06/01 22:38:55 mcooper Exp $
X#
X
X#define USE_KARCH
X#include "/usr/usc/include/mk/all.h"
X
XKVM		= /usr/kvm/lsd
XBIN 		= /usr/lsd/bin
XMAN 		= /usr/usc/man/man1
X
X#if defined(sun)
XLIBKVM		= -lkvm
X#else
XLIBKVM		=
X#endif
X
X#if defined(sun) && defined(OSVERSION) && OSVERSION == 40
XCC		= /usr/5bin/cc
XLIBS 		= /usr/5lib/libc.a -L/usr/usc/lib -lgen $LIBKVM
X#else
XLIBS 		= -L/usr/usc/lib -lgen $LIBKVM
X#endif
X#if defined(alliant)
XCC		= cc
XLIBS 		= /usr/usc/lib/libgen.a -lcommon $LIBKVM
X#endif
X#if defined(NeXT)
XCC		= gcc
X#endif
X
XNETIFOBJS	= ${O}netif.o ${O}info-netif.o
XMACHOBJS	= ${O}os-"mach".o ${O}info-"mach".o
X#ifdef sun
XOSFILES		= ${O}os-"sunos".o ${O}info-"sunos".o $NETIFOBJS
XOSDEFS		= -D`/bin/arch -k`
X#endif
X#ifdef ultrix
XOSFILES		= ${O}os-"ultrix".o ${O}info-"ultrix".o $NETIFOBJS
X#endif
X#ifdef NeXT
XOSFILES		= ${O}os-"next".o ${O}info-"next".o $MACHOBJS $NETIFOBJS
X#endif
X#ifdef alliant
XOSFILES		= ${O}os-"alliant.o" ${O}info-"alliant".o
X#endif
X#ifdef _AIX
XOSFILES		= ${O}os-"aix.o" ${O}info-"aix".o
X#endif
X/* Should use something besides hp300 */
X#ifdef hp300
XOSFILES		= ${O}os-"bsd43.o" ${O}info-"bsd43".o
X#endif
X
XOPT		= -g
X#ifdef sun
XINCLUDES	= -I/usr/usc/include
X#else
XINCLUDES	= -I/usr/usc/include -I.
X#endif
XDEFINES		= -DOPTION_COMPAT $OSDEFS
XCFLAGS 		= $OPT $INCLUDES $DEFINES
X
X
XNPROC 		= 4
XBASE 		= sysinfo
XPROG 		= ${O}sysinfo
XOBJS 		= ${O}sysinfo.o ${O}devices.o ${O}memory.o ${O}kernel.o \
X			${O}run.o ${O}KVM.o ${O}kvm.o ${O}strdup.o $OSFILES
XSRCS		= "`echo $OBJS | sed -e "s;$O;;g" -e 's;\.o;.c;g'`"
XALLSRCS		= sysinfo.c devices.c memory.c kernel.c\
X			run.c KVM.c kvm.c kvm.h patchlevel.h \
X			strcasecmp.c strdup.c strerror.c \
X			options.c options.h \
X			system.h defs.h \
X			netif.c info-netif.c \
X			os-mach.c info-mach.c \
X			os-sunos.c info-sunos.c \
X			os-ultrix.c info-ultrix.c info-ultrix.h \
X			os-next.c info-next.c \
X			os-alliant.c info-alliant.c \
X			os-bsd43.c info-bsd43.c \
X			os-aix.c info-aix.c
X
Xall: $PROG
X
X$PROG: $OBJS $LIBS
X	$CC $CFLAGS -o ${target} $OBJS $LIBS
X
X#if	defined(sun)
Xinstall: ${PROG}
X	install -c -m 4555 -o root -g wheel $PROG $KVM/$BASE
X	(cd $BIN && rm -f $BASE && ln -s $KVM/$BASE $BASE)
X#else
Xinstall: ${PROG}
X	install -c -m 4555 -o root -g wheel $PROG $BIN/$BASE
X#endif	/* sun */
X
Xinstall.man: ${BASE}.man
X	install -c -m 444 -o bin -g bin ${BASE}.man $MAN/$BASE.1
X
Xinstall.compat:
X	install -c -m 555 -o bin -g bin cpumodel.sh /usr/lsd/etc/cpumodel
X	rm -f $MAN/${BASE}.8 $MAN/cpumodel.1
X	(cd /usr/usc/bin; rm -f sysinfo; ln -s ${BIN}/sysinfo)
X
X#
X# Centerline stuff
X#
X#ifdef sun /* Some platforms don't like the #load below */
Xcc_src:
X	#load $CFLAGS $SRCS $LIBS $LIBKVM
X
Xcc_obj:
X	#load $CFLAGS $OBJS $LIBS $LIBKVM
X#endif
X
Xclean:
X	rm -f ${PROG} *~ *% \#* core a.out ${O}*.o
X
X$OBJS: system.h defs.h
X
XDISTFILES = README sysinfo.man Makefile $ALLSRCS options.3 Mkfile.cpp
X
Xsysinfo.tar: $DISTFILES
X	rm -f $target
X	tar chf $target $DISTFILES
X
Xsysinfo.shar: $DISTFILES
X	rm -f $target
X	shar $DISTFILES > $target
END_OF_Mkfile.cpp
if test 3024 -ne `wc -c <Mkfile.cpp`; then
    echo shar: \"Mkfile.cpp\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of shell archive.
exit 0
