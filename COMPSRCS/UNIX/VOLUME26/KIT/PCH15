Newsgroups: comp.sources.unix
From: ram@acri.fr (Raphael Manfredi)
Subject: v26i220: kit - the ultimate mailing kit, Patch15
Sender: unix-sources-moderator@efficacy.home.vix.com
Approved: WhoAmI@efficacy.home.vix.com

Submitted-By: ram@acri.fr (Raphael Manfredi)
Posting-Number: Volume 26, Issue 220
Archive-Name: kit/pch15

[The latest patch for kit version 2.0 is #28.]

System: kit version 2.0
Patch #: 15
Priority: LOW
Subject: fixed a typo in Configure
Subject: acknowledgment section in README updated
Subject: now creates directories before installing
Subject: added support for -a option
Subject: stamping now includes user and host infos
Subject: error checking improved
Subject: kit will no longer remove existing kit parts
Subject: added the bulk Precedence and X-Mailer headers
Subject: fixed incorrect help message regarding -l
Subject: changed verbose messages for consistency with other scripts
Subject: minikit now extracted via a .SH file
Subject: added acknowledgment support
Subject: replaced space indentation with tabs
Subject: documents the new -a option
Subject: older kits will not honor -a or -M (new paragraph in BUGS)
Subject: determination of user and host no longer uses a sub-shell
Date: Mon Apr 20 17:45:17 PDT 1992
From: Raphael Manfredi <ram@eiffel.com>

Description:
	All the Makefiles now create directories before installing. Apparently
	this caused some problems with peculiar installations. This bug and
	was reported by Dr Robert M. Cothren <rim@marvin.ri.ccf.org>. Thank you!

	Minikit is now created via a .SH file, because it carries patchlevel
	and version informations.

	Stamping of kit files now includes user and host infos, like usual
	shell archivers do.

	Error checking in kit improved, as suggested by Christian Bertin
	<bertin@acri.fr>. Kit will now abort with an error message if the
	current directory is not writable and will force you to use -d.

	Kit will no longer remove existing kit parts.

	All the mails sent by mailkit now carry a 'Precedence: bulk' and
	an X-Mailer headers. The former will avoid vacation-like messages
	and the latter helps debugging.

	Fixed incorrect help message regarding -l option in mailkit. The -l
	option directs mailkit to include addresses from a specified file,
	but any address included on the command line will still be honored.

	Changed verbose messages in mailkit for consistency with other scripts.

	Added acknowledgment support. This is the most "flashy" change since
	the last patch. By adding a '-a <address>' option on the kit command
	line, you direct the remote 'unkit' to send you an acknowledgment when
	the archive is successfully unkit'ed. However, since this is a new
	feature, older kits will not honor -a (see new paragraph in BUGS).
	This means you will not get any acknowledgments until your party
	updates to kit 2.0 PL15. The acknowledgment is mentionned in the
	leading part of each kit files. There is no way to suppress its
	sending (other than hitting ^C), but is there a need for that?


Fix:	From rn, say "| patch -p -N -d DIR", where DIR is your kit source
	directory.  Outside of rn, say "cd DIR; patch -p -N <thisarticle".
	If you don't have the patch program, apply the following by hand,
	or get patch (version 2.0, latest patchlevel).

	After patching:
		rm kit/minikit	# Replaced by kit/minikit.SH
		Configure -d
		make
		make install

	If patch indicates that patchlevel is the wrong version, you may need
	to apply one or more previous patches, or the patch may already
	have been applied.  See the patchlevel.h file to find out what has or
	has not been applied.  In any event, don't continue with the patch.

	If you are missing previous patches they can be obtained from me:

		Raphael Manfredi <ram@eiffel.com>

	If you send a mail message of the following form it will greatly speed
	processing:

		Subject: Command
		@SH mailpatch PATH kit 2.0 LIST
			   ^ note the c

	where PATH is a return path FROM ME TO YOU either in Internet notation,
	or in bang notation from some well-known host, and LIST is the number
	of one or more patches you need, separated by spaces, commas, and/or
	hyphens.  Saying 35- says everything from 35 to the end.

	To get some more detailed instructions, send me the following mail:

		Subject: Command
		@SH mailhelp PATH


Index: patchlevel.h
Prereq: 14
2c2
< #define PATCHLEVEL 14
---
> #define PATCHLEVEL 15

Index: kit/kit.SH
Prereq: 2.0.1.8
*** kit/kit.SH.old	Mon Apr 20 17:44:29 1992
--- kit/kit.SH	Mon Apr 20 17:44:30 1992
***************
*** 26,34 ****
  !GROK!THIS!
  $spitshell >>kit <<'!NO!SUBS!'
  
! # $Id: kit.SH,v 2.0.1.8 92/01/13 14:13:59 ram Exp $
  #
  # $Log:	kit.SH,v $
  # Revision 2.0.1.8  92/01/13  14:13:59  ram
  # patch13: fixed the option parsing code
  # 
--- 26,40 ----
  !GROK!THIS!
  $spitshell >>kit <<'!NO!SUBS!'
  
! # $Id: kit.SH,v 2.0.1.9 92/04/20 17:35:03 ram Exp $
  #
  # $Log:	kit.SH,v $
+ # Revision 2.0.1.9  92/04/20  17:35:03  ram
+ # patch15: added support for -a option
+ # patch15: stamping now includes user and host infos
+ # patch15: error checking improved
+ # patch15: kit will no longer remove existing kit parts
+ # 
  # Revision 2.0.1.8  92/01/13  14:13:59  ram
  # patch13: fixed the option parsing code
  # 
***************
*** 74,81 ****
  tmpdir="."					# Temporary directory used
  partname="Kit"				# Default part name used
  minikit=''					# Do not include minikit
! mininame=''					# File where minikit's name is stored
! instruct=''					# Instrucutions for minikit usage
  
  # Mailkit options
  mailopt=""
--- 80,89 ----
  tmpdir="."					# Temporary directory used
  partname="Kit"				# Default part name used
  minikit=''					# Do not include minikit
! others=''					# Other files to be included
! instruct=''					# Added instrucutions (minikit / acknowledgment)
! ack=''						# Acknowledgment file
! ackto=''					# Acknowledgment address
  
  # Mailkit options
  mailopt=""
***************
*** 87,94 ****
  
  # Old Bourne shells do not have functions
  usage='
! echo "Usage: kit [-BEFHMVXefhpx] [-d dir] [-k key] [-m address] [-n basename]";
! echo " "" "" "" "" "" "" [-l file] [-s name] dirs | files";
  echo " "" -B : use btoa encoding (default).";
  echo " "" -E : edit instructions for part #0 (passed to mailkit).";
  echo " "" -F : feed instructions from stdin to part #0 (passed to mailkit).";
--- 95,102 ----
  
  # Old Bourne shells do not have functions
  usage='
! echo "Usage: kit [-BEFHMVXefhpx] [-a address] [-d dir] [-k key] [-m address]";
! echo " "" "" "" "" "" "" [-n basename] [-l file] [-s name] dirs | files";
  echo " "" -B : use btoa encoding (default).";
  echo " "" -E : edit instructions for part #0 (passed to mailkit).";
  echo " "" -F : feed instructions from stdin to part #0 (passed to mailkit).";
***************
*** 96,101 ****
--- 104,110 ----
  echo " "" -M : include minikit in the distribution.";
  echo " "" -V : print version and patch-level.";
  echo " "" -X : use Electronic Code Block DES encryption.";
+ echo " "" -a : acknowledgment requested upon archive extraction.";
  echo " "" -d : put temporary files in the specified directory.";
  echo " "" -e : edit instructions to add in each part (passed to mailkit).";
  echo " "" -f : feed instructions from stdin in each part (passed to mailkit).";
***************
*** 140,145 ****
--- 149,159 ----
  		mode="zec"
  		shift
  		;;
+ 	-a) ackto="$2"
+ 		ack='zzz.ack'
+ 		shift
+ 		shift
+ 		;;
  	-d) tmpdir="$2"
  		shift
  		shift
***************
*** 195,201 ****
  	eval $usage
  fi
  
! rm -f $tmpdir/$partname??			# Make sure no parts already exist
  
  # If DES is to be performed, do it before ASCII coding
  case "$mode" in
--- 209,233 ----
  	eval $usage
  fi
  
! # Check the writing permissions in the tmp directory. Also ifsome Kit parts are
! # detected, complain and abort.
! if test -w "$tmpdir" -a -d "$tmpdir"; then
! 	if test -f $tmpdir/${partname}01; then
! echo >&2 "kit: directory '$tmpdir' already holds a file named '${partname}01'."
! 		exit 1
! 	fi
! else
! 	if test -d "$tmpdir"; then
! 		echo >&2 "kit: you lack write permissions in the '$tmpdir' directory."
! 	else
! 		echo >&2 "kit: '$tmpdir' is not a directory."
! 	fi
! 	exit 1
! fi
! 
! # Make sure no parts already exist. Due to the above check, existing parts will
! # be removed only if they are named with extensions from 02 to 99.
! rm -f $tmpdir/$partname??
  
  # If DES is to be performed, do it before ASCII coding
  case "$mode" in
***************
*** 204,209 ****
--- 236,246 ----
  	coding="des $desopt | "$coding;;
  esac
  
+ # Subject is user-provided or the first file name is used
+ case "$subject" in
+ '') subject=$1
+ esac
+ 
  # We have two encoding methods for binary datas:
  # - hexencode: brute force (mogenix)
  # - btoa: binary to ascii (ram)
***************
*** 222,231 ****
  
  # In case we are interrupted
  trap "rm -f $tmpfile; cd $tmpdir; rm -f $partname?? ${split_file}* \
! 	$minikit $partname??.$$; echo >&2 'Aborted.'; exit 1" 1 2 3 15
  
  # We have to use a tmp file to avoid des prompting while tar is running
  tar cvf - $@ | compress -v > $tmpfile
  
  cd $tmpdir
  
--- 259,275 ----
  
  # In case we are interrupted
  trap "rm -f $tmpfile; cd $tmpdir; rm -f $partname?? ${split_file}* \
! 	$others $partname??.$$; echo >&2 'Aborted.'; exit 1" 1 2 3 15
  
  # We have to use a tmp file to avoid des prompting while tar is running
  tar cvf - $@ | compress -v > $tmpfile
+ case $? in
+ 0) break;;
+ *) echo >&2 "kit: archiving failed."
+ 	rm -f $tmpfile
+ 	exit 1
+ 	;;
+ esac
  
  cd $tmpdir
  
***************
*** 237,243 ****
  		# Name of the minikit program is passed along to unkit, so that the
  		# script may be removed when unkit is ran...
  		echo "$minikit" > zzz.minikit
! 		mininame=zzz.minikit
  		# Prepare instructions for later
  		instruct=">>
  >> In case you do not have unkit, you may proceeed as follows:
--- 281,287 ----
  		# Name of the minikit program is passed along to unkit, so that the
  		# script may be removed when unkit is ran...
  		echo "$minikit" > zzz.minikit
! 		others="zzz.minikit $minikit"
  		# Prepare instructions for later
  		instruct=">>
  >> In case you do not have unkit, you may proceeed as follows:
***************
*** 246,252 ****
  >> - Run the '$minikit' program, and the kit will be extracted for you.
  >>   If the extraction is successful, all the temporary files previously
  >>   extracted will be removed, including $minikit.
- 
  "
  	else
  		echo >&2 "$0: cannot find minikit in $libdir"
--- 290,295 ----
***************
*** 254,275 ****
  	fi
  fi
  
  # Check whether we can use cshar or not
  if (makekit -v) >/dev/null 2>&1; then
! 	makekit="makekit -k100 -n $partname ${split_file}* $minikit $mininame"
  else
! 	makekit="$libdir/makeshar -n $partname ${split_file}* $minikit $mininame"
  fi
  
  echo "Coding with $coding"
  # Beware: 'eval $coding < $tmpfile' is not portable
  cat $tmpfile | eval $coding |
  split -600 - $split_file &&
! eval $makekit &&
! rm ${split_file}* $minikit $mininame $tmpfile
! 
! case "$subject" in
! '') subject=$1
  esac
  
  # Stamp the files, stating they are kit files and not shell archives
--- 297,340 ----
  	fi
  fi
  
+ # If acknowledgment is wanted, write address in zzz.ack and add this file to
+ # zzz.minikit to ensure its final removal by unkit.
+ if test "$ack"; then
+ 	echo "$ackto" >> zzz.ack
+ 	echo "$subject" >> zzz.subject
+ 	echo "zzz.ack" >> zzz.minikit
+ 	echo "zzz.subject" >> zzz.minikit
+ 	others="$others zzz.subject zzz.ack"
+ 	case "$others" in
+ 	*zzz.minikit*);;
+ 	*) others="$others zzz.minikit";;
+ 	esac
+ 	instruct="$instruct>>
+ >> An acknowledgment will be automatically sent by unkit upon successful
+ >> extraction to the following address: $ackto.
+ "
+ fi
+ 
  # Check whether we can use cshar or not
  if (makekit -v) >/dev/null 2>&1; then
! 	makekit="makekit -k100 -n $partname ${split_file}* $others"
  else
! 	makekit="$libdir/makeshar -n $partname ${split_file}* $others"
  fi
  
  echo "Coding with $coding"
  # Beware: 'eval $coding < $tmpfile' is not portable
+ status=1
  cat $tmpfile | eval $coding |
  split -600 - $split_file &&
! eval $makekit && status=0
! rm ${split_file}* $others $tmpfile
! case "$status" in
! 0);;
! *) echo >&2 "kit: sharing failed."
! 	rm -f $tmpdir/$partname??
! 	exit 1
! 	;;
  esac
  
  # Stamp the files, stating they are kit files and not shell archives
***************
*** 276,281 ****
--- 341,348 ----
  set X $partname??
  shift
  nfiles=$#
+ user=`(logname) 2>/dev/null || whoami`
+ host=`(uname -n) 2>/dev/null || hostname`
  for file in $partname??
  do
  	# Extract part number
***************
*** 284,290 ****
  	part_num=`expr $part + 0`
  	# Write kit header stamp message
  	echo "Stamping kit $part_num..."
! 	genstamp=">> Generated by kit $version PL$pl on `date`"
  	if test $nfiles -gt 1; then
  		cat >$file.$$ <<EOH
  >> This is a kit file (part #$part_num out of $nfiles). To unkit, save this message
--- 351,357 ----
  	part_num=`expr $part + 0`
  	# Write kit header stamp message
  	echo "Stamping kit $part_num..."
! 	genstamp=">> Wrapped by $user@$host on `date` [kit $version PL$pl]"
  	if test $nfiles -gt 1; then
  		cat >$file.$$ <<EOH
  >> This is a kit file (part #$part_num out of $nfiles). To unkit, save this message

Index: man/kit.SH
Prereq: 2.0.1.7
*** man/kit.SH.old	Mon Apr 20 17:44:56 1992
--- man/kit.SH	Mon Apr 20 17:44:58 1992
***************
*** 18,26 ****
  .TH KIT $manext ram
  ''' @(#) Manual page for mailing kit -- (c) ram July 1990
  '''
! ''' $Id: kit.SH,v 2.0.1.7 92/01/13 14:21:42 ram Exp $
  '''
  ''' $Log:	kit.SH,v $
  ''' Revision 2.0.1.7  92/01/13  14:21:42  ram
  ''' patch13: the built-in unshar in unkit may now be used alone
  ''' 
--- 18,30 ----
  .TH KIT $manext ram
  ''' @(#) Manual page for mailing kit -- (c) ram July 1990
  '''
! ''' $Id: kit.SH,v 2.0.1.8 92/04/20 17:42:36 ram Exp $
  '''
  ''' $Log:	kit.SH,v $
+ ''' Revision 2.0.1.8  92/04/20  17:42:36  ram
+ ''' patch15: documents the new -a option
+ ''' patch15: older kits will not honor -a or -M (new paragraph in BUGS)
+ ''' 
  ''' Revision 2.0.1.7  92/01/13  14:21:42  ram
  ''' patch13: the built-in unshar in unkit may now be used alone
  ''' 
***************
*** 58,64 ****
  .SH NAME
  kit, mailkit, unkit \- the ultimate mailing tools
  .SH SYNOPSIS
! \fBkit\fR [ \fB\-EFHMBVXefhpx\fR ] [ \fB\-k\fI key\fR]
  [ \fB\-d\fI dir\fR ] [ \fB\-m\fI address\fR ] [ \fB\-n\fI basename\fR ]
  [ \fB\-l\fI file\fR ] [ \fB\-s\fI name\fR ] \fIdirectories\fR | \fIfiles\fR
  .br
--- 62,68 ----
  .SH NAME
  kit, mailkit, unkit \- the ultimate mailing tools
  .SH SYNOPSIS
! \fBkit\fR [ \fB\-EFHMBVXefhpx\fR ] [ \fB\-a\fI address\fR] [ \fB\-k\fI key\fR]
  [ \fB\-d\fI dir\fR ] [ \fB\-m\fI address\fR ] [ \fB\-n\fI basename\fR ]
  [ \fB\-l\fI file\fR ] [ \fB\-s\fI name\fR ] \fIdirectories\fR | \fIfiles\fR
  .br
***************
*** 75,83 ****
  (option \fB\-H\fR) or ASCII-encoded with \fIbtoa\fR(1)
  (option \fB\-B\fR, which is used by default) before being shell-archived.
  \fIKit\fR produces files that match "Kit*" regular expression.
! This default base name can be changed thanks to \fB\-n\fR option.
! On invocation, it removes all previously existing "Kit*" files.
! With \fB\-m\fR option, it is possible to give one mail address, and
  \fIkit\fR will invoke \fImailkit\fR to send the archive. There may be
  as many \fB\-m\fR options as needed (to send the same archive to more
  than a single person).
--- 79,86 ----
  (option \fB\-H\fR) or ASCII-encoded with \fIbtoa\fR(1)
  (option \fB\-B\fR, which is used by default) before being shell-archived.
  \fIKit\fR produces files that match "Kit*" regular expression.
! This default base name can be changed thanks to the \fB\-n\fR option.
! With the \fB\-m\fR option, it is possible to give one mail address, and
  \fIkit\fR will invoke \fImailkit\fR to send the archive. There may be
  as many \fB\-m\fR options as needed (to send the same archive to more
  than a single person).
***************
*** 101,113 ****
  for one. If you use the \fB\-k\fR option, \fB\-x\fR is assumed.
  .PP
  It may happen that there are no write permissions in the directory
! where the root directory to be kitted lies. The \fB-d\fR option enables
  you to specify another directory, where all the temporary files will be
  stored. If you use something like \fI/tmp\fR, you must be careful to use
  \fB\-n\fR to change the base name used (in case someone else is doing
! the same thing, otherwise files may get mangled).
  .PP
! When you send a kit to someone which may not have \fIkit\fR, the \fB\-M\fR
  option may be used to include a \fIminikit\fR script, which is a minimal
  set of commands to unkit an unencrypted ASCII-encoded kit. The overhead is
  small (around 4K) and some instructions are provided in the header of every
--- 104,119 ----
  for one. If you use the \fB\-k\fR option, \fB\-x\fR is assumed.
  .PP
  It may happen that there are no write permissions in the directory
! where the root directory to be kitted lies. The \fB\-d\fR option enables
  you to specify another directory, where all the temporary files will be
  stored. If you use something like \fI/tmp\fR, you must be careful to use
  \fB\-n\fR to change the base name used (in case someone else is doing
! the same thing, otherwise files may get mangled). To prevent common mistakes,
! \fIkit\fR will stop and give an error message if the argument of \fB\-d\fR is
! not a directory, if the directory is not writable by the user, or if
! a kit file is present in the temporary directory (same base name).
  .PP
! When you send a kit to someone who may not have \fIkit\fR, the \fB\-M\fR
  option may be used to include a \fIminikit\fR script, which is a minimal
  set of commands to unkit an unencrypted ASCII-encoded kit. The overhead is
  small (around 4K) and some instructions are provided in the header of every
***************
*** 117,122 ****
--- 123,134 ----
  a unique name of the form \fImkitXXXXX\fR will be generated (XXXXX stands
  for the PID of the \fIkit\fR process).
  .PP
+ By using the \fB\-a\fR option, you ask the remote \fIunkit\fR program to send
+ an automatic acknowledgment to the specified e-mail address upon successful
+ archive extraction. However, this feature is only supported if the remote
+ end has at least the 2.0 PL15 release. You will receive a short message with
+ a \fIjunk\fR precedence, telling you who extracted the archive and when.
+ .PP
  \fIMailkit\fR takes "Kit*" files and sends them to a list of addresses.
  The \fB\-n\fR option can be used to change that base name, if necessary.
  Each message sent corresponds to one part and has its \`Subject:'
***************
*** 169,178 ****
  a little help message with the syntax and the meaning of the options.
  .SH FILES
  .PD 0
! .TP 20
! Kit*
! files generated by \fIkit\fR
! .TP
  {zag,zcb,zec}.hex.*
  temporary files used by \fIkit\fR and \fIunkit\fR for datas which
  are hex-encoded.
--- 181,187 ----
  a little help message with the syntax and the meaning of the options.
  .SH FILES
  .PD 0
! .TP 15
  {zag,zcb,zec}.hex.*
  temporary files used by \fIkit\fR and \fIunkit\fR for datas which
  are hex-encoded.
***************
*** 181,198 ****
  temporary files used by \fIkit\fR and \fIunkit\fR for datas which
  are ASCII-encoded.
  .TP
  zag*
! non encrypted files.
  .TP
  zcb*
  data encrypted using CBC mode.
  .TP
! zec
  data encrypted using ECB mode.
  .TP
  zzz.minikit
! file holding the name of the provided minikit script.
  .TP
  $privlib/minikit
  the script which may be used to unkit a distribution when the kit
  package is not available.
--- 190,216 ----
  temporary files used by \fIkit\fR and \fIunkit\fR for datas which
  are ASCII-encoded.
  .TP
+ Kit*
+ files generated by \fIkit\fR
+ .TP
  zag*
! non encrypted temporary files.
  .TP
  zcb*
  data encrypted using CBC mode.
  .TP
! zec*
  data encrypted using ECB mode.
  .TP
  zzz.minikit
! file holding the name of the extras files added by kit.
! .TP
! zzz.ack
! contains the address where acknowledgment should be sent.
  .TP
+ zzz.subject
+ contains the name of kit archive for acknowledgment purposes.
+ .TP
  $privlib/minikit
  the script which may be used to unkit a distribution when the kit
  package is not available.
***************
*** 203,209 ****
  $privlib/rshar
  a simple shell archive maker.
  .PD
! .SH NOTE
  .PP
  Kit may now be used as a standalone package, i.e. without the help of
  the \fIcshar\fR distribution.
--- 221,227 ----
  $privlib/rshar
  a simple shell archive maker.
  .PD
! .SH NOTES
  .PP
  Kit may now be used as a standalone package, i.e. without the help of
  the \fIcshar\fR distribution.
***************
*** 269,274 ****
--- 287,305 ----
  .PP
  Some systems cannot extract tar archives with overwriting of ownership
  informations (usually this is done with tar option -o).
+ .PP
+ The
+ .B \-M
+ option is unknown to versions of
+ .I kit
+ prior to 2.0 PL9, which means the remote
+ .I unkit
+ program will not be able to clean-up the extras files. Similarly,
+ the automatic acknowledgment feature was added at 2.0 PL15. Fortunately,
+ .I kit
+ programs newer than 2.0 PL9 will know how to deal with the extras files,
+ although the acknowledgment feature itself will only be handled by 2.0 PL15 and
+ later versions.
  .SH "SEE ALSO"
  atob($manext), btoa($manext), cshar(1), makekit(1).
  .SH AUTHOR

Index: badtar/Makefile.SH
Prereq: 2.0.1.1
*** badtar/Makefile.SH.old	Mon Apr 20 17:44:10 1992
--- badtar/Makefile.SH	Mon Apr 20 17:44:11 1992
***************
*** 18,26 ****
  # Makefile for kit (sub-directory badtar)
  #
  
! # $Id: Makefile.SH,v 2.0.1.1 92/01/11 19:11:57 ram Exp $
  #
  # $Log:	Makefile.SH,v $
  # Revision 2.0.1.1  92/01/11  19:11:57  ram
  # patch11: created
  # 
--- 18,29 ----
  # Makefile for kit (sub-directory badtar)
  #
  
! # $Id: Makefile.SH,v 2.0.1.2 92/04/20 17:31:53 ram Exp $
  #
  # $Log:	Makefile.SH,v $
+ # Revision 2.0.1.2  92/04/20  17:31:53  ram
+ # patch15: now creates directories before installing
+ # 
  # Revision 2.0.1.1  92/01/11  19:11:57  ram
  # patch11: created
  # 
***************
*** 47,54 ****
  	/bin/sh badtar.SH
  
  install: badtar $(manpage)
  	../install -s -m 755 badtar $(bin)
! 	../install -m 444 $(manpage) $(man)
  
  clean:
  	rm -f *.o badtar $(manpage)
--- 50,61 ----
  	/bin/sh badtar.SH
  
  install: badtar $(manpage)
+ 	../install -d $(bin)
  	../install -s -m 755 badtar $(bin)
! 	-if test "$(man)"; then \
! 		../install -d $(man); \
! 		../install -m 444 $(manpage) $(man); \
! 	fi
  
  clean:
  	rm -f *.o badtar $(manpage)

Index: btoa/Makefile.SH
Prereq: 2.0.1.1
*** btoa/Makefile.SH.old	Mon Apr 20 17:44:14 1992
--- btoa/Makefile.SH	Mon Apr 20 17:44:15 1992
***************
*** 18,26 ****
  # Makefile for kit (sub-directory btoa)
  #
  
! # $Id: Makefile.SH,v 2.0.1.1 91/05/27 14:14:41 ram Exp $
  #
  # $Log:	Makefile.SH,v $
  # Revision 2.0.1.1  91/05/27  14:14:41  ram
  # patch5: some dumb make failed on previous makefile
  # 
--- 18,29 ----
  # Makefile for kit (sub-directory btoa)
  #
  
! # $Id: Makefile.SH,v 2.0.1.2 92/04/20 17:32:09 ram Exp $
  #
  # $Log:	Makefile.SH,v $
+ # Revision 2.0.1.2  92/04/20  17:32:09  ram
+ # patch15: now creates directories before installing
+ # 
  # Revision 2.0.1.1  91/05/27  14:14:41  ram
  # patch5: some dumb make failed on previous makefile
  # 
***************
*** 54,59 ****
--- 57,63 ----
  	$(CC) $(CFLAGS) -o $@ $@.c
  
  install: $(BIN)
+ 	../install -d $(bin)
  	-for file in $(BIN); do \
  		../install -s -m 755 $$file $(bin); \
  	done

Index: des/Makefile.SH
Prereq: 2.0.1.4
*** des/Makefile.SH.old	Mon Apr 20 17:44:18 1992
--- des/Makefile.SH	Mon Apr 20 17:44:19 1992
***************
*** 18,26 ****
  # Makefile for kit (sub-directory des)
  #
  
! # $Id: Makefile.SH,v 2.0.1.4 92/01/11 19:13:59 ram Exp $
  #
  # $Log:	Makefile.SH,v $
  # Revision 2.0.1.4  92/01/11  19:13:59  ram
  # patch11: now depends on the 'hasdes' configuration variable
  # 
--- 18,29 ----
  # Makefile for kit (sub-directory des)
  #
  
! # $Id: Makefile.SH,v 2.0.1.5 92/04/20 17:32:21 ram Exp $
  #
  # $Log:	Makefile.SH,v $
+ # Revision 2.0.1.5  92/04/20  17:32:21  ram
+ # patch15: now creates directories before installing
+ # 
  # Revision 2.0.1.4  92/01/11  19:13:59  ram
  # patch11: now depends on the 'hasdes' configuration variable
  # 
***************
*** 60,65 ****
--- 63,69 ----
  	if ./descert < testdata; then touch certify; $(RM) descert descert.o; fi
  
  install: des
+ 	../install -d $(bin)
  	../install -s -m 755 des $(bin)
  	@echo "	Warning: manual pages for des not installed."
  

Index: kit/Makefile.SH
Prereq: 2.0.1.3
*** kit/Makefile.SH.old	Mon Apr 20 17:44:24 1992
--- kit/Makefile.SH	Mon Apr 20 17:44:24 1992
***************
*** 18,26 ****
  # Makefile for kit (sub-directory kit)
  #
  
! # $Id: Makefile.SH,v 2.0.1.3 91/11/25 15:49:18 ram Exp $
  #
  # $Log:	Makefile.SH,v $
  # Revision 2.0.1.3  91/11/25  15:49:18  ram
  # patch9: now installs minikit in the private kit library
  # 
--- 18,30 ----
  # Makefile for kit (sub-directory kit)
  #
  
! # $Id: Makefile.SH,v 2.0.1.4 92/04/20 17:32:57 ram Exp $
  #
  # $Log:	Makefile.SH,v $
+ # Revision 2.0.1.4  92/04/20  17:32:57  ram
+ # patch15: now creates directories before installing
+ # patch15: minikit is now created via a .SH file
+ # 
  # Revision 2.0.1.3  91/11/25  15:49:18  ram
  # patch9: now installs minikit in the private kit library
  # 
***************
*** 42,49 ****
  
  !GROK!THIS!
  $spitshell >>Makefile <<'!NO!SUBS!'
! scripts = kit mailkit unkit
! scriptsh = kit.SH mailkit.SH unkit.SH
  added = Makefile config.sh
  
  all: $(scripts)
--- 46,54 ----
  
  !GROK!THIS!
  $spitshell >>Makefile <<'!NO!SUBS!'
! bin = kit mailkit unkit
! scripts = $(bin) minikit
! scriptsh = kit.SH mailkit.SH unkit.SH minikit.SH
  added = Makefile config.sh
  
  all: $(scripts)
***************
*** 57,66 ****
  unkit: unkit.SH
  	sh $@.SH
  
  install: $(scripts)
! 	-for file in $(scripts); do \
  		../install -m 755 $$file $(binsh); \
  	done
  	../install -m 644 minikit $(libdir)
  
  clean:
--- 62,76 ----
  unkit: unkit.SH
  	sh $@.SH
  
+ minikit: minikit.SH
+ 	sh $@.SH
+ 
  install: $(scripts)
! 	../install -d $(binsh)
! 	-for file in $(bin); do \
  		../install -m 755 $$file $(binsh); \
  	done
+ 	../install -d $(libdir)
  	../install -m 644 minikit $(libdir)
  
  clean:

Index: man/Makefile.SH
Prereq: 2.0.1.2
*** man/Makefile.SH.old	Mon Apr 20 17:44:50 1992
--- man/Makefile.SH	Mon Apr 20 17:44:51 1992
***************
*** 18,26 ****
  # Makefile for kit (sub-directory man)
  #
  
! # $Id: Makefile.SH,v 2.0.1.2 91/05/27 14:30:53 ram Exp $
  #
  # $Log:	Makefile.SH,v $
  # Revision 2.0.1.2  91/05/27  14:30:53  ram
  # patch5: search for config.sh is now silent
  # 
--- 18,29 ----
  # Makefile for kit (sub-directory man)
  #
  
! # $Id: Makefile.SH,v 2.0.1.3 92/04/20 17:39:21 ram Exp $
  #
  # $Log:	Makefile.SH,v $
+ # Revision 2.0.1.3  92/04/20  17:39:21  ram
+ # patch15: now creates directories before installing
+ # 
  # Revision 2.0.1.2  91/05/27  14:30:53  ram
  # patch5: search for config.sh is now silent
  # 
***************
*** 54,59 ****
--- 57,63 ----
  
  install: all
  	-if test "$(man)"; then \
+ 		../install -d $(man); \
  		for file in $(manpage); do \
  			../install -m 444 $$file $(man); \
  		done; \

Index: shar/Makefile.SH
Prereq: 2.0.1.1
*** shar/Makefile.SH.old	Mon Apr 20 17:45:01 1992
--- shar/Makefile.SH	Mon Apr 20 17:45:03 1992
***************
*** 18,26 ****
  # Makefile for kit (sub-directory shar)
  #
  
! # $Id: Makefile.SH,v 2.0.1.1 92/01/11 19:22:47 ram Exp $
  #
  # $Log:	Makefile.SH,v $
  # Revision 2.0.1.1  92/01/11  19:22:47  ram
  # patch11: created
  # 
--- 18,29 ----
  # Makefile for kit (sub-directory shar)
  #
  
! # $Id: Makefile.SH,v 2.0.1.2 92/04/20 17:42:50 ram Exp $
  #
  # $Log:	Makefile.SH,v $
+ # Revision 2.0.1.2  92/04/20  17:42:50  ram
+ # patch15: now creates directories before installing
+ # 
  # Revision 2.0.1.1  92/01/11  19:22:47  ram
  # patch11: created
  # 
***************
*** 45,50 ****
--- 48,54 ----
  	sh $@.SH
  
  install: $(scripts)
+ 	../install -d $(libdir)
  	-for file in $(scripts); do \
  		../install -m 555 $$file $(libdir); \
  	done

Index: kit/minikit.SH
*** kit/minikit.SH.old	Mon Apr 20 17:44:40 1992
--- kit/minikit.SH	Mon Apr 20 17:44:41 1992
***************
*** 0 ****
--- 1,187 ----
+ case $CONFIG in
+ '')
+ 	if test ! -f config.sh; then
+ 		ln ../config.sh . || \
+ 		ln ../../config.sh . || \
+ 		ln ../../../config.sh . || \
+ 		(echo "Can't find config.sh."; exit 1)
+ 	fi 2>/dev/null
+ 	. ./config.sh
+ 	;;
+ esac
+ case "$0" in
+ */*) cd `expr X$0 : 'X\(.*\)/'` ;;
+ esac
+ 
+ # $Id: minikit.SH,v 2.0.1.1 92/04/20 17:38:35 ram Exp $
+ #
+ # $Log:	minikit.SH,v $
+ # Revision 2.0.1.1  92/04/20  17:38:35  ram
+ # patch15: minikit now extracted via a .SH file
+ # patch15: added acknowledgment support
+ # patch15: replaced space indentation with tabs
+ # 
+ 
+ echo "Extracting kit/minikit (with variable substitutions)"
+ $spitshell >minikit <<!GROK!THIS!
+ #! /bin/sh
+ export PATH || exec sh \$0
+ ver='$VERSION'
+ pl='$PATCHLEVEL'
+ !GROK!THIS!
+ 
+ $spitshell >>minikit <<'!NO!SUBS!'
+ trap "rm -f mini_unkit mini_code.c core mini_code; exit 1" 1 2 3 15
+ echo "Minikit [version $ver PL$pl]"
+ echo "Extracting mini kit..."
+ cat >mini_code.c <<'EOP'
+ #include <stdio.h>
+ #define reg register
+ #define streq(s0, s1)  strcmp(s0, s1) == 0
+ #define times85(x)	((((((x<<2)+x)<<2)+x)<<2)+x)
+ #define DE(c) ((c) - '!')
+ long int Ceor = 0;
+ long int Csum = 0;
+ long int Crot = 0;
+ long int w = 0;
+ long int b = 0;
+ fatal()
+ {
+ 	fprintf(stderr, "bad format or Csum to atob\n");
+ 	exit(1);
+ }
+ decode(c) reg c;
+ {
+ 	if (c == 'z') {
+ 		if (b != 0) {
+ 			fatal();
+ 		} else {
+ 			bo(0); bo(0); bo(0); bo(0);
+ 		}
+ 	} else if ((c >= '!') && (c < ('!' + 85))) {
+ 		if (b == 0) {
+ 			w = DE(c);
+ 			++b;
+ 		} else if (b < 4) {
+ 			w = times85(w);
+ 			w += DE(c);
+ 			++b;
+ 		} else {
+ 			w = times85(w) + DE(c);
+ 			bo((int)((w >> 24) & 255));
+ 			bo((int)((w >> 16) & 255));
+ 			bo((int)((w >> 8) & 255));
+ 			bo((int)(w & 255));
+ 			w = 0;
+ 			b = 0;
+ 		}
+ 	} else {
+ 		fatal();
+ 	}
+ }
+ FILE *t;
+ bo(c) reg c;
+ {
+ 	Ceor ^= c;
+ 	Csum += c;
+ 	Csum += 1;
+ 	if ((Crot & 0x80000000)) {
+ 		Crot <<= 1;
+ 		Crot += 1;
+ 	} else
+ 		Crot <<= 1;
+ 	Crot += c;
+ 	putc(c, t);
+ }
+ main(argc, argv) char **argv;
+ {
+ 	reg c;
+ 	reg long int i;
+ 	char n[100];
+ 	char buf[100];
+ 	long int n1, n2, oeor, osum, orot;
+ 
+ 	if (argc != 1) {
+ 		fprintf(stderr,"bad args to %s\n", argv[0]);
+ 		exit(2);
+ 	}
+ 	sprintf(n, "/usr/tmp/atob.%x", getpid());
+ 	t = fopen(n, "w+");
+ 	if (t == NULL)
+ 		fatal();
+ 	unlink(n);
+ 	for (;;) {
+ 		if (fgets(buf, sizeof buf, stdin) == NULL)
+ 			fatal();
+ 		if (streq(buf, "xbtoa Begin\n"))
+ 			break;
+ 	}
+ 
+ 	while ((c = getchar()) != EOF) {
+ 		if (c == '\n')
+ 			continue;
+ 		else if (c == 'x')
+ 			break;
+ 		else
+ 			decode(c);
+ 	}
+ 	if(scanf("btoa End N %ld %lx E %lx S %lx R %lx\n",&n1,&n2,&oeor,&osum,&orot)!=5)
+ 		fatal();
+ 	if ((n1 != n2) || (oeor != Ceor) || (osum != Csum) || (orot != Crot))
+ 		fatal();
+ 	else {
+ 		fseek(t, 0L, 0);
+ 		for (i = n1; --i >= 0;)
+ 			putchar(getc(t));
+ 	}
+ 	exit(0);
+ }
+ EOP
+ cat >mini_unkit<<EOP
+ ver='$ver'
+ pl='$pl'
+ EOP
+ cat >>mini_unkit <<'EOP'
+ if tar -cf - /dev/null 2>/dev/null | tar -xof - >/dev/null 2>&1; then
+ 	tar_opt='xvof'
+ else
+ 	tar_opt='xvf'
+ fi
+ if test -f zag.ba.aa; then
+ 	cat `ls zag.ba.??` | ./mini_code | zcat | tar $tar_opt - || exit 1
+ else
+ 	echo >&2 "Sorry, I can only deal with plain ascii-encoded kits"
+ 	exit 1
+ fi
+ if test -f zzz.ack -a -f /usr/lib/sendmail; then
+ 	s=`cat zzz.ack`
+ 	sb=`cat zzz.subject`
+ 	echo "Sending acknowledgment to $s..."
+ 	u=`(logname) 2>/dev/null || whoami`
+ 	h=`(uname -n) 2>/dev/null || hostname 2>/dev/null`
+ 	d=`date`
+ 	/usr/lib/sendmail $s <<EOM
+ Subject: Kit received [$sb]
+ To: $s
+ Precedence: junk
+ X-Mailer: minikit [version $ver PL$pl]
+ 
+ Your kit archive labeled '$sb' has been
+ unpacked by $u@$h on $d.
+ EOM
+ fi
+ test -f zzz.minikit && rm -f `cat zzz.minikit` zzz.minikit
+ rm -f z??.[hb][ea]*.??
+ EOP
+ echo "Compiling mini kit..."
+ if cc -o mini_code mini_code.c >/dev/null 2>&1; then
+ 	echo "Running mini kit..."
+ 	sh mini_unkit
+ else
+ 	echo "Error in C compilation--aborting."
+ fi
+ rm -f core mini_code mini_code.c mini_unkit
+ echo "Done."
+ !NO!SUBS!
+ chmod 755 minikit
+ $eunicefix minikit

Index: kit/mailkit.SH
Prereq: 2.0.1.6
*** kit/mailkit.SH.old	Mon Apr 20 17:44:36 1992
--- kit/mailkit.SH	Mon Apr 20 17:44:37 1992
***************
*** 18,26 ****
  # @(#) Mailer for kit files
  # @(#) (c) R. Manfredi, 1990 1991
  
! # $Id: mailkit.SH,v 2.0.1.6 92/01/13 14:14:21 ram Exp $
  #
  # $Log:	mailkit.SH,v $
  # Revision 2.0.1.6  92/01/13  14:14:21  ram
  # patch13: fixed the option parsing code
  # 
--- 18,31 ----
  # @(#) Mailer for kit files
  # @(#) (c) R. Manfredi, 1990 1991
  
! # $Id: mailkit.SH,v 2.0.1.7 92/04/20 17:37:36 ram Exp $
  #
  # $Log:	mailkit.SH,v $
+ # Revision 2.0.1.7  92/04/20  17:37:36  ram
+ # patch15: added the bulk Precedence and X-Mailer headers
+ # patch15: fixed incorrect help message regarding -l
+ # patch15: changed verbose messages for consistency with other scripts
+ # 
  # Revision 2.0.1.6  92/01/13  14:14:21  ram
  # patch13: fixed the option parsing code
  # 
***************
*** 80,86 ****
  echo " "" -e : edit a message that will be added to every part";
  echo " "" -f : feed message from stdin to every part";
  echo " "" -h : to print this help message.";
! echo " "" -l : get recipients from a file (address_list is ignored).";
  echo " "" -n : set the basename of parts to be sent (default is $partname).";
  echo " "" -p : preserve files sent.";
  exit 1;
--- 85,91 ----
  echo " "" -e : edit a message that will be added to every part";
  echo " "" -f : feed message from stdin to every part";
  echo " "" -h : to print this help message.";
! echo " "" -l : get recipients from a file.";
  echo " "" -n : set the basename of parts to be sent (default is $partname).";
  echo " "" -p : preserve files sent.";
  exit 1;
***************
*** 244,255 ****
  	# Protect against unexisting/unreadable files matching "$partname*"
  	if  test -f $i -a -r $i
  	then
! 		echo Mailing $i \($prog_name\)
  		# System V /bin/mail does not recognize header correctly, unless the
  		# first line is a subject. Oh well...
  		cat > $topmsg <<EOH
  Subject: $prog_name - kit #$part_num / $nfiles
  To: $address
  
  EOH
  		# Has edit been requested ?
--- 249,262 ----
  	# Protect against unexisting/unreadable files matching "$partname*"
  	if  test -f $i -a -r $i
  	then
! 		echo "Mailing $i..."
  		# System V /bin/mail does not recognize header correctly, unless the
  		# first line is a subject. Oh well...
  		cat > $topmsg <<EOH
  Subject: $prog_name - kit #$part_num / $nfiles
  To: $address
+ Precedence: bulk
+ X-Mailer: mailkit [version $version PL$pl]
  
  EOH
  		# Has edit been requested ?
***************
*** 273,279 ****
  		$mailer $address < $topmsg
  		rm -f $topmsg
  	else
! 		echo $this_prog: could not open $i >&2
  	fi
  done
  
--- 280,286 ----
  		$mailer $address < $topmsg
  		rm -f $topmsg
  	else
! 		echo "$this_prog: could not open $i" >&2
  	fi
  done
  
***************
*** 283,294 ****
  	cat > $topmsg <<EOM
  Subject: $prog_name - kit #0 / $nfiles
  To: $address
  
  [ This is an instruction message for the $prog_name kit ]
  
  EOM
  	cat >>$topmsg <$message
! 	echo Mailing instructions \($prog_name\)
  	$mailer $address < $topmsg
  	rm -f $topmsg
  fi
--- 290,303 ----
  	cat > $topmsg <<EOM
  Subject: $prog_name - kit #0 / $nfiles
  To: $address
+ Precedence: bulk
+ X-Mailer: mailkit [version $version PL$pl]
  
  [ This is an instruction message for the $prog_name kit ]
  
  EOM
  	cat >>$topmsg <$message
! 	echo "Mailing instructions..."
  	$mailer $address < $topmsg
  	rm -f $topmsg
  fi

Index: kit/unkit.SH
Prereq: 2.0.1.9
*** kit/unkit.SH.old	Mon Apr 20 17:44:45 1992
--- kit/unkit.SH	Mon Apr 20 17:44:47 1992
***************
*** 19,27 ****
  # @(#) (c) E. Mogenet April 1990
  # @(#) (c) R. Manfredi, 1990 1991
  
! # $Id: unkit.SH,v 2.0.1.9 92/01/13 14:20:37 ram Exp $
  #
  # $Log:	unkit.SH,v $
  # Revision 2.0.1.9  92/01/13  14:20:37  ram
  # patch13: fixed the option parsing code
  # patch13: unkit may be used to actually do an unshar
--- 19,30 ----
  # @(#) (c) E. Mogenet April 1990
  # @(#) (c) R. Manfredi, 1990 1991
  
! # $Id: unkit.SH,v 2.0.1.10 92/04/20 17:39:08 ram Exp $
  #
  # $Log:	unkit.SH,v $
+ # Revision 2.0.1.10  92/04/20  17:39:08  ram
+ # patch15: added support for acknowledgment
+ # 
  # Revision 2.0.1.9  92/01/13  14:20:37  ram
  # patch13: fixed the option parsing code
  # patch13: unkit may be used to actually do an unshar
***************
*** 68,73 ****
--- 71,79 ----
  
  # Tar options to be used
  badtar='$needbtar'
+ 
+ # Mailer to be used for acknowledgments
+ mailer="$mailer"
  !GROK!THIS!
  
  case "$d_portable" in
***************
*** 193,202 ****
  
  echo "Decoding with $decoding | zcat | $tarcmd"
  
  cat `ls z??.[hb][ea]*.??` |
  eval $decoding		|
  zcat				|
! eval "$tarcmd"
  
  test -f zzz.minikit && rm -f `cat zzz.minikit` zzz.minikit
  rm -f z??.[hb][ea]*.??
--- 199,230 ----
  
  echo "Decoding with $decoding | zcat | $tarcmd"
  
+ status=1
  cat `ls z??.[hb][ea]*.??` |
  eval $decoding		|
  zcat				|
! eval "$tarcmd" && status=0
! 
! # Send acknowledgment only when unpacking was successful.
! if test -f zzz.ack -a $status -eq 0; then
! 	sender=`cat zzz.ack`
! 	subject=`cat zzz.subject`
! 	echo "Sending acknowledgment to $sender..."
! 	# There has to be a space between the two '(' for ksh.
! 	user=`(logname) 2>/dev/null || whoami`
! 	host=`(uname -n) 2>/dev/null || hostname 2>/dev/null`
! 	date=`date`
! 	$mailer $sender <<EOM
! Subject: Kit received [$subject]
! To: $sender
! Precedence: junk
! X-Mailer: unkit [version $version PL$pl]
! 
! Your kit archive labeled '$subject' has been
! unpacked by $user@$host on $date.
! EOM
! 	echo "Done."
! fi
  
  test -f zzz.minikit && rm -f `cat zzz.minikit` zzz.minikit
  rm -f z??.[hb][ea]*.??

Index: shar/rshar.SH
Prereq: 2.0.1.3
*** shar/rshar.SH.old	Mon Apr 20 17:45:08 1992
--- shar/rshar.SH	Mon Apr 20 17:45:08 1992
***************
*** 17,25 ****
  $startsh
  # (c) Raphael Manfredi, December 25th 1991
  
! # $Id: rshar.SH,v 2.0.1.3 92/03/24 13:46:04 ram Exp $
  #
  # $Log:	rshar.SH,v $
  # Revision 2.0.1.3  92/03/24  13:46:04  ram
  # patch14: determination of user name made more portable
  # patch14: a missing quote led to a syntactically incorrect archive
--- 17,28 ----
  $startsh
  # (c) Raphael Manfredi, December 25th 1991
  
! # $Id: rshar.SH,v 2.0.1.4 92/04/20 17:43:22 ram Exp $
  #
  # $Log:	rshar.SH,v $
+ # Revision 2.0.1.4  92/04/20  17:43:22  ram
+ # patch15: determination of user and host no longer uses a sub-shell
+ # 
  # Revision 2.0.1.3  92/03/24  13:46:04  ram
  # patch14: determination of user name made more portable
  # patch14: a missing quote led to a syntactically incorrect archive
***************
*** 70,78 ****
  	esac
  done
  
! # Who and where am I? -- white space between '(' is needed in case ksh is used
! user=`( (logname) || whoami) 2>/dev/null`
! host=`( (uname -n) || hostname) 2>/dev/null`
  
  echo '#! /bin/sh
  # This is a shell archive.  Remove anything before this line, then feed it
--- 73,81 ----
  	esac
  done
  
! # Who and where am I?
! user=`(logname) 2>/dev/null || whoami`
! host=`(uname -n) 2>/dev/null || hostname`
  
  echo '#! /bin/sh
  # This is a shell archive.  Remove anything before this line, then feed it

Index: Configure
Prereq: 2.0.1.5
*** Configure.old	Mon Apr 20 17:43:55 1992
--- Configure	Mon Apr 20 17:43:57 1992
***************
*** 16,22 ****
  # Write to ram@eiffel.com (Raphael Manfredi) and I will send you the
  # latest revision of the dist package, which includes metaconfig.)
  
! # $Id: Configure,v 2.0.1.5 92/01/11 19:08:09 ram Exp $
  #
  # Generated on Sat Jan 11 19:03:07 PST 1992 [metaconfig 2.8 PL13]
  
--- 16,22 ----
  # Write to ram@eiffel.com (Raphael Manfredi) and I will send you the
  # latest revision of the dist package, which includes metaconfig.)
  
! # $Id: Configure,v 2.0.1.6 92/04/20 17:30:40 ram Exp $
  #
  # Generated on Sat Jan 11 19:03:07 PST 1992 [metaconfig 2.8 PL13]
  
***************
*** 2223,2229 ****
  	dflt='y'
  	rp='Would you like to have badtar installed?'
  	. myread
! 	case "$and" in
  	n*|N*) wantbtar='false';;
  	esac
  	;;
--- 2223,2229 ----
  	dflt='y'
  	rp='Would you like to have badtar installed?'
  	. myread
! 	case "$ans" in
  	n*|N*) wantbtar='false';;
  	esac
  	;;

Index: MANIFEST
*** MANIFEST.old	Mon Apr 20 17:45:12 1992
--- MANIFEST	Mon Apr 20 17:45:13 1992
***************
*** 27,33 ****
  kit/Makefile.SH            Makefile for scripts
  kit/kit.SH                 The main script-shell
  kit/mailkit.SH             Mails parts generated by "kit"
! kit/minikit                The minikit script for kit extraction
  kit/unkit.SH               Reversal of "kit"
  man/Makefile.SH            Makefile for manual pages
  man/atob.SH                Manual page for "atob"
--- 27,33 ----
  kit/Makefile.SH            Makefile for scripts
  kit/kit.SH                 The main script-shell
  kit/mailkit.SH             Mails parts generated by "kit"
! kit/minikit.SH             The minikit script for kit extraction
  kit/unkit.SH               Reversal of "kit"
  man/Makefile.SH            Makefile for manual pages
  man/atob.SH                Manual page for "atob"

Index: README
*** README.old	Mon Apr 20 17:44:06 1992
--- README	Mon Apr 20 17:44:06 1992
***************
*** 81,90 ****
--- 81,93 ----
  ACKNOWLEDGMENTS
  
  I would like to thank:
+ 
  	Gary Casterline <casterln@are.berkeley.edu>
+ 	Robert M. Cothren <rim@marvin.ri.ccf.org>
  	Michael Fischer <fischer-michael@cs.yale.edu>
  	Gurvan Lullien <lullien@inf.enst.fr>
  	Monty Solomon <roscom!monty@think.com>
+ 
  for their bug reports and comments.
  
  The criticism of Tim Kuehn <timk@wynnds.xenitec.on.ca> was also much

*** End of Patch 15 ***
