Newsgroups: comp.sources.unix
From: mlschroe@immd4.informatik.uni-erlangen.de (Michael Schroeder)
Subject: v26i306: screen-3.5 - screen manager with VT100/ANSI terminal emulation, V3.5, Part07/10
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: mlschroe@immd4.informatik.uni-erlangen.de (Michael Schroeder)
Posting-Number: Volume 26, Issue 306
Archive-Name: screen-3.5/part07

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 10)."
# Contents:  configure process.c
# Wrapped by vixie@gw.home.vix.com on Sun Jul 25 12:57:23 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'configure' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'configure'\"
else
echo shar: Extracting \"'configure'\" \(52835 characters\)
sed "s/^X//" >'configure' <<'END_OF_FILE'
X#!/bin/sh
X# Guess values for system-dependent variables and create Makefiles.
X# Generated automatically using autoconf.
X# Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.
X
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this program; if not, write to the Free Software
X# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X# Usage: configure [--srcdir=DIR] [--host=HOST] [--gas] [--nfp] [--no-create]
X#        [--prefix=PREFIX] [--exec-prefix=PREFIX] [--with-PACKAGE] [TARGET]
X# Ignores all args except --srcdir, --prefix, --exec-prefix, --no-create, and
X# --with-PACKAGE unless this script has special code to handle it.
X
X
Xfor arg
Xdo
X  # Handle --exec-prefix with a space before the argument.
X  if test x$next_exec_prefix = xyes; then exec_prefix=$arg; next_exec_prefix=
X  # Handle --host with a space before the argument.
X  elif test x$next_host = xyes; then next_host=
X  # Handle --prefix with a space before the argument.
X  elif test x$next_prefix = xyes; then prefix=$arg; next_prefix=
X  # Handle --srcdir with a space before the argument.
X  elif test x$next_srcdir = xyes; then srcdir=$arg; next_srcdir=
X  else
X    case $arg in
X     # For backward compatibility, also recognize exact --exec_prefix.
X     -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* | --exec=* | --exe=* | --ex=* | --e=*)
X	exec_prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- | --exec | --exe | --ex | --e)
X	next_exec_prefix=yes ;;
X
X     -gas | --gas | --ga | --g) ;;
X
X     -host=* | --host=* | --hos=* | --ho=* | --h=*) ;;
X     -host | --host | --hos | --ho | --h)
X	next_host=yes ;;
X
X     -nfp | --nfp | --nf) ;;
X
X     -no-create | --no-create | --no-creat | --no-crea | --no-cre | --no-cr | --no-c | --no- | --no)
X        no_create=1 ;;
X
X     -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
X	prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
X	next_prefix=yes ;;
X
X     -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=* | --s=*)
X	srcdir=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -srcdir | --srcdir | --srcdi | --srcd | --src | --sr | --s)
X	next_srcdir=yes ;;
X
X     -with-* | --with-*)
X       package=`echo $arg|sed 's/-*with-//'`
X       # Delete all the valid chars; see if any are left.
X       if test -n "`echo $package|sed 's/[-a-zA-Z0-9_]*//g'`"; then
X         echo "configure: $package: invalid package name" >&2; exit 1
X       fi
X       eval "with_`echo $package|sed s/-/_/g`=1" ;;
X
X     *) ;;
X    esac
X  fi
Xdone
X
Xtrap 'rm -f conftest* core; exit 1' 1 3 15
X
Xrm -f conftest*
Xcompile='${CC-cc} $DEFS conftest.c -o conftest $LIBS >/dev/null 2>&1'
X
X# A filename unique to this package, relative to the directory that
X# configure is in, which we can look for to find out if srcdir is correct.
Xunique_file=screen.c
X
X# Find the source files, if location was not specified.
Xif test -z "$srcdir"; then
X  srcdirdefaulted=yes
X  # Try the directory containing this script, then `..'.
X  prog=$0
X  confdir=`echo $prog|sed 's%/[^/][^/]*$%%'`
X  test "X$confdir" = "X$prog" && confdir=.
X  srcdir=$confdir
X  if test ! -r $srcdir/$unique_file; then
X    srcdir=..
X  fi
Xfi
Xif test ! -r $srcdir/$unique_file; then
X  if test x$srcdirdefaulted = xyes; then
X    echo "configure: Can not find sources in \`${confdir}' or \`..'." 1>&2
X  else
X    echo "configure: Can not find sources in \`${srcdir}'." 1>&2
X  fi
X  exit 1
Xfi
X# Preserve a srcdir of `.' to avoid automounter screwups with pwd.
X# But we can't avoid them for `..', to make subdirectories work.
Xcase $srcdir in
X  .|/*|~*) ;;
X  *) srcdir=`cd $srcdir; pwd` ;; # Make relative path absolute.
Xesac
X
X
X
X
Xrev=`sed < patchlevel.h -n -e '/#define REV/s/#define REV  *//p'`
Xvers=`sed < patchlevel.h -n -e '/#define VERS/s/#define VERS  *//p'`
Xpat=`sed < patchlevel.h -n -e '/#define PATCHLEVEL/s/#define PATCHLEVEL  *//p'`
XVERSION="$rev.$vers.$pat"
Xecho "this is screen version $VERSION"
X
X
Xif test -z "$CC"; then
X  echo checking for gcc
X  saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    if test -f $dir/gcc; then
X      CC="gcc"
X      break
X    fi
X  done
X  IFS="$saveifs"
Xfi
Xtest -z "$CC" && CC="cc"
X
X# Find out if we are using GNU C, under whatever name.
Xcat > conftest.c <<EOF
X#ifdef __GNUC__
X  yes
X#endif
XEOF
X${CC-cc} -E conftest.c > conftest.out 2>&1
Xif egrep yes conftest.out >/dev/null 2>&1; then
X  GCC=1 # For later tests.
Xfi
Xrm -f conftest*
X
Xecho checking how to run the C preprocessor
Xif test -z "$CPP"; then
X  CPP='${CC-cc} -E'
X  cat > conftest.c <<EOF
X#include <stdio.h>
XEOF
Xerr=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
Xif test -z "$err"; then
X  :
Xelse
X  CPP=/lib/cpp
Xfi
Xrm -f conftest*
Xfi
X
Xif test -n "$GCC"; then
X  echo checking whether -traditional is needed
X  pattern="Autoconf.*'x'"
X  prog='#include <sgtty.h>
XAutoconf TIOCGETP'
X  cat > conftest.c <<EOF
X$prog
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "$pattern" conftest.out >/dev/null 2>&1; then
X  need_trad=1
Xfi
Xrm -f conftest*
X
X
X  if test -z "$need_trad"; then
X    prog='#include <termio.h>
XAutoconf TCGETA'
X    cat > conftest.c <<EOF
X$prog
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "$pattern" conftest.out >/dev/null 2>&1; then
X  need_trad=1
Xfi
Xrm -f conftest*
X
X  fi
X  test -n "$need_trad" && CC="$CC -traditional"
Xfi
X
Xecho checking for POSIXized ISC
Xif test -d /etc/conf/kconfig.d &&
X  grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
Xthen
X  ISC=1 # If later tests want to check for ISC.
X  DEFS="$DEFS -D_POSIX_SOURCE=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}_POSIX_SOURCE\${SEDdB}_POSIX_SOURCE\${SEDdC}1\${SEDdD}
X\${SEDuA}_POSIX_SOURCE\${SEDuB}_POSIX_SOURCE\${SEDuC}1\${SEDuD}
X\${SEDeA}_POSIX_SOURCE\${SEDeB}_POSIX_SOURCE\${SEDeC}1\${SEDeD}
X"
X  if test -n "$GCC"; then
X    CC="$CC -posix"
X  else
X    CC="$CC -Xp"
X  fi
Xfi
X
X
X
Xcat > conftest.c <<EOF
Xmain(){exit(0);}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  :
Xelse
X  echo "Can't run the compiler - sorry";exit
Xfi
Xrm -f conftest*
Xfor p in mawk gawk nawk awk
Xdo
Xif test -z "$AWK"; then
X  echo checking for $p
X  saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    if test -f $dir/$p; then
X      AWK="$p"
X      break
X    fi
X  done
X  IFS="$saveifs"
Xfi
Xtest -z "$AWK" && AWK=""
X
Xtest -n "$AWK" && break
Xdone
X
X
X# Make sure to not get the incompatible SysV /etc/install and
X# /usr/sbin/install, which might be in PATH before a BSD-like install,
X# or the SunOS /usr/etc/install directory, or the AIX /bin/install,
X# or the AFS install, which mishandles nonexistent args.  (Sigh.)
Xif test -z "$INSTALL"; then
X  echo checking for install
X  saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    case $dir in
X    /etc|/usr/sbin|/usr/etc|/usr/afsws/bin) ;;
X    *)
X      if test -f $dir/install; then
X	if grep dspmsg $dir/install >/dev/null 2>&1; then
X	  : # AIX
X	else
X	  INSTALL="$dir/install -c"
X	  INSTALL_PROGRAM='$(INSTALL)'
X	  INSTALL_DATA='$(INSTALL) -m 644'
X	  break
X	fi
X      fi
X      ;;
X    esac
X  done
X  IFS="$saveifs"
Xfi
XINSTALL=${INSTALL-cp}
XINSTALL_PROGRAM=${INSTALL_PROGRAM-'$(INSTALL)'}
XINSTALL_DATA=${INSTALL_DATA-'$(INSTALL)'}
X
X
Xif test -n "$ISC"; then
X  DEFS="$DEFS -DISC=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}ISC\${SEDdB}ISC\${SEDdC}1\${SEDdD}
X\${SEDuA}ISC\${SEDuB}ISC\${SEDuC}1\${SEDuD}
X\${SEDeA}ISC\${SEDeB}ISC\${SEDeC}1\${SEDeD}
X" LIBS="$LIBS -linet"
Xfi
X
Xecho checking for MIPS
Xif test -f /lib/libmld.a || test -f /usr/lib/libmld.a || test -f /usr/lib/cmplrs/cc/libmld.a; then
XDEFS="$DEFS -DMIPS=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}MIPS\${SEDdB}MIPS\${SEDdC}1\${SEDdD}
X\${SEDuA}MIPS\${SEDuB}MIPS\${SEDuC}1\${SEDuD}
X\${SEDeA}MIPS\${SEDeB}MIPS\${SEDeC}1\${SEDeD}
X" LIBS="$LIBS -lmld" # for nlist.
Xecho checking for wait3
Xcat > conftest.c <<EOF
X
Xmain() { exit(0); } 
Xt() { wait3(); }
XEOF
Xif eval $compile; then
X  :
Xelse
X  echo checking for wait2
Xcat > conftest.c <<EOF
X
Xmain() { exit(0); } 
Xt() { wait2(); }
XEOF
Xif eval $compile; then
X  DEFS="$DEFS -DUSE_WAIT2=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}USE_WAIT2\${SEDdB}USE_WAIT2\${SEDdC}1\${SEDdD}
X\${SEDuA}USE_WAIT2\${SEDuB}USE_WAIT2\${SEDuC}1\${SEDuD}
X\${SEDeA}USE_WAIT2\${SEDeB}USE_WAIT2\${SEDeC}1\${SEDeD}
X" LIBS="$LIBS -lbsd" ; CC="$CC -I/usr/include/bsd"
X
Xfi
Xrm -f conftest*
X
Xfi
Xrm -f conftest*
X
Xfi
X
Xecho checking for Ultrix
Xcat > conftest.c <<EOF
X#if defined(ultrix) || defined(__ultrix)
X  yes
X#endif
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  ULTRIX=1
Xfi
Xrm -f conftest*
X
X
Xif test -n "$ULTRIX"; then
X  test -z "$GCC" && CC="$CC -YBSD"
Xelse
X  # POSIX termios is broken on Ultrix so don't look for it.
Xecho checking for POSIX.1
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <unistd.h>
Xmain () {
X#ifdef _POSIX_VERSION
X  yes
X#endif
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  echo "- you have a POSIX system";DEFS="$DEFS -DPOSIX=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}POSIX\${SEDdB}POSIX\${SEDdC}1\${SEDdD}
X\${SEDuA}POSIX\${SEDuB}POSIX\${SEDuC}1\${SEDuD}
X\${SEDeA}POSIX\${SEDeB}POSIX\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
Xfi
X
Xecho checking for System V
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <signal.h>
X#include <fcntl.h>
Xmain() { exit(0); } 
Xt() { int x = SIGCHLD | FNDELAY; }
XEOF
Xif eval $compile; then
X  :
Xelse
X  DEFS="$DEFS -DSYSV=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SYSV\${SEDdB}SYSV\${SEDdC}1\${SEDdD}
X\${SEDuA}SYSV\${SEDuB}SYSV\${SEDuC}1\${SEDuD}
X\${SEDeA}SYSV\${SEDeB}SYSV\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for sequent/ptx
Xcat > conftest.c <<EOF
X#ifdef _SEQUENT_
X  yes
X#endif
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  LIBS="$LIBS -lsocket -linet";seqptx=1
Xfi
Xrm -f conftest*
X
X
Xoldlibs="$LIBS"
XLIBS="$LIBS -lelf"
Xecho checking for SVR4
Xcat > conftest.c <<EOF
X
Xmain() { exit(0); } 
Xt() {  }
XEOF
Xif eval $compile; then
X  echo checking for dwarf.h
Xcat > conftest.c <<EOF
X#include <dwarf.h>
XEOF
Xerr=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
Xif test -z "$err"; then
X  DEFS="$DEFS -DSVR4=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SVR4\${SEDdB}SVR4\${SEDdC}1\${SEDdD}
X\${SEDuA}SVR4\${SEDuB}SVR4\${SEDuC}1\${SEDuD}
X\${SEDeA}SVR4\${SEDeB}SVR4\${SEDeC}1\${SEDeD}
X" ; DEFS="$DEFS -DBUGGYGETLOGIN=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}BUGGYGETLOGIN\${SEDdB}BUGGYGETLOGIN\${SEDdC}1\${SEDdD}
X\${SEDuA}BUGGYGETLOGIN\${SEDuB}BUGGYGETLOGIN\${SEDuC}1\${SEDuD}
X\${SEDeA}BUGGYGETLOGIN\${SEDeB}BUGGYGETLOGIN\${SEDeC}1\${SEDeD}
X" ; LIBS="$LIBS -lelf"
Xelse
X  echo checking for elf.h
Xcat > conftest.c <<EOF
X#include <elf.h>
XEOF
Xerr=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
Xif test -z "$err"; then
X  DEFS="$DEFS -DSVR4=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SVR4\${SEDdB}SVR4\${SEDdC}1\${SEDdD}
X\${SEDuA}SVR4\${SEDuB}SVR4\${SEDuC}1\${SEDuD}
X\${SEDeA}SVR4\${SEDeB}SVR4\${SEDeC}1\${SEDeD}
X" ; DEFS="$DEFS -DBUGGYGETLOGIN=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}BUGGYGETLOGIN\${SEDdB}BUGGYGETLOGIN\${SEDdC}1\${SEDdD}
X\${SEDuA}BUGGYGETLOGIN\${SEDuB}BUGGYGETLOGIN\${SEDuC}1\${SEDuD}
X\${SEDeA}BUGGYGETLOGIN\${SEDeB}BUGGYGETLOGIN\${SEDeC}1\${SEDeD}
X" ; LIBS="$LIBS -lelf"
Xfi
Xrm -f conftest*
X
Xfi
Xrm -f conftest*
X
X
Xelse
X  LIBS="$oldlibs"
Xfi
Xrm -f conftest*
X
X
X
X
Xecho checking for putenv declaration
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <unistd.h>
X#include <stdlib.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "putenv( |	|\()" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DPUTENV_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}PUTENV_DECLARED\${SEDdB}PUTENV_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}PUTENV_DECLARED\${SEDuB}PUTENV_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}PUTENV_DECLARED\${SEDeB}PUTENV_DECLARED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for getdtablesize declaration
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <unistd.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "getdtablesize( |	|\()" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DGETDTABLESIZE_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}GETDTABLESIZE_DECLARED\${SEDdB}GETDTABLESIZE_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}GETDTABLESIZE_DECLARED\${SEDuB}GETDTABLESIZE_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}GETDTABLESIZE_DECLARED\${SEDeB}GETDTABLESIZE_DECLARED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for select declaration
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <sys/time.h>
X#include <unistd.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "select( |	|\()" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DSELECT_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SELECT_DECLARED\${SEDdB}SELECT_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}SELECT_DECLARED\${SEDuB}SELECT_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}SELECT_DECLARED\${SEDeB}SELECT_DECLARED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for vsprintf declaration
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <stdio.h>
X#ifdef __STDC__
X#include <stdarg.h>
X#else
X#include <varargs.h>
X#endif
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "vsprintf( |	|\()" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DVPRNT_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}VPRNT_DECLARED\${SEDdB}VPRNT_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}VPRNT_DECLARED\${SEDuB}VPRNT_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}VPRNT_DECLARED\${SEDeB}VPRNT_DECLARED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for setreuid declaration
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <unistd.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "setres?uid( |	|\()" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DREUID_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}REUID_DECLARED\${SEDdB}REUID_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}REUID_DECLARED\${SEDuB}REUID_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}REUID_DECLARED\${SEDeB}REUID_DECLARED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for wait declaration
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <signal.h>
X#include <sys/wait.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "wait( |	|\()" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DWAITSTUFF_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}WAITSTUFF_DECLARED\${SEDdB}WAITSTUFF_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}WAITSTUFF_DECLARED\${SEDuB}WAITSTUFF_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}WAITSTUFF_DECLARED\${SEDeB}WAITSTUFF_DECLARED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for memfuncs declaration
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <unistd.h>
X#include <string.h>
X#include <strings.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "(memcpy|memmove|bcopy)( |	|\()" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DMEMFUNCS_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}MEMFUNCS_DECLARED\${SEDdB}MEMFUNCS_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}MEMFUNCS_DECLARED\${SEDuB}MEMFUNCS_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}MEMFUNCS_DECLARED\${SEDeB}MEMFUNCS_DECLARED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for index declaration
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <strings.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "index( |	|\()" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DINDEX_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}INDEX_DECLARED\${SEDdB}INDEX_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}INDEX_DECLARED\${SEDuB}INDEX_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}INDEX_DECLARED\${SEDeB}INDEX_DECLARED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for crypt declaration
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <unistd.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "crypt( |	|\()" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DCRYPT_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}CRYPT_DECLARED\${SEDdB}CRYPT_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}CRYPT_DECLARED\${SEDuB}CRYPT_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}CRYPT_DECLARED\${SEDeB}CRYPT_DECLARED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for mknod declaration
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <sys/stat.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "mknod( |	|\()" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DMKNOD_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}MKNOD_DECLARED\${SEDdB}MKNOD_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}MKNOD_DECLARED\${SEDuB}MKNOD_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}MKNOD_DECLARED\${SEDeB}MKNOD_DECLARED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for setpgid declaration
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <unistd.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "setpgid( |	|\()" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DSETPGID_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SETPGID_DECLARED\${SEDdB}SETPGID_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}SETPGID_DECLARED\${SEDuB}SETPGID_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}SETPGID_DECLARED\${SEDeB}SETPGID_DECLARED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for kill declaration
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <unistd.h>
X#include <signal.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "kill( |	|\()" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DKILLSTUFF_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}KILLSTUFF_DECLARED\${SEDdB}KILLSTUFF_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}KILLSTUFF_DECLARED\${SEDuB}KILLSTUFF_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}KILLSTUFF_DECLARED\${SEDeB}KILLSTUFF_DECLARED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for gethostname declaration
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <unistd.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "gethostname( |	|\()" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DGETHOSTNAME_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}GETHOSTNAME_DECLARED\${SEDdB}GETHOSTNAME_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}GETHOSTNAME_DECLARED\${SEDuB}GETHOSTNAME_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}GETHOSTNAME_DECLARED\${SEDeB}GETHOSTNAME_DECLARED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for pid_t
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "pid_t" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DPID_T_DEFINED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}PID_T_DEFINED\${SEDdB}PID_T_DEFINED\${SEDdC}1\${SEDdD}
X\${SEDuA}PID_T_DEFINED\${SEDuB}PID_T_DEFINED\${SEDuC}1\${SEDuD}
X\${SEDeA}PID_T_DEFINED\${SEDeB}PID_T_DEFINED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for sig_t
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <signal.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "sig_t" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DSIG_T_DEFINED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SIG_T_DEFINED\${SEDdB}SIG_T_DEFINED\${SEDdC}1\${SEDdD}
X\${SEDuA}SIG_T_DEFINED\${SEDuB}SIG_T_DEFINED\${SEDuC}1\${SEDuD}
X\${SEDeA}SIG_T_DEFINED\${SEDeB}SIG_T_DEFINED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for uid_t
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "uid_t" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DUID_T_DEFINED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}UID_T_DEFINED\${SEDdB}UID_T_DEFINED\${SEDdC}1\${SEDdD}
X\${SEDuA}UID_T_DEFINED\${SEDuB}UID_T_DEFINED\${SEDuC}1\${SEDuD}
X\${SEDeA}UID_T_DEFINED\${SEDeB}UID_T_DEFINED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
X
Xecho checking for BSD job control
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <sys/ioctl.h>
X
Xmain() { exit(0); } 
Xt() { 
X#ifdef POSIX
Xtcsetpgrp(0, 0);
X#else
Xint x = TIOCSPGRP;
X#ifdef SYSV
Xsetpgrp();
X#else
Xint y = TIOCNOTTY;
X#endif
X#endif
X }
XEOF
Xif eval $compile; then
X  echo "- you have jobcontrol";DEFS="$DEFS -DBSDJOBS=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}BSDJOBS\${SEDdB}BSDJOBS\${SEDdC}1\${SEDdD}
X\${SEDuA}BSDJOBS\${SEDuB}BSDJOBS\${SEDuC}1\${SEDuD}
X\${SEDeA}BSDJOBS\${SEDeB}BSDJOBS\${SEDeC}1\${SEDeD}
X"
Xelse
X  echo "- you don't have jobcontrol"
Xfi
Xrm -f conftest*
X
X
Xecho checking for setreuid
Xcat > conftest.c <<EOF
X
Xmain() { exit(0); } 
Xt() { 
X#ifdef hpux
Xsetresuid(0, 0, 0);
X#else
Xsetreuid(0, 0);
X#endif
X }
XEOF
Xif eval $compile; then
X  :
Xelse
X  DEFS="$DEFS -DNOREUID=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NOREUID\${SEDdB}NOREUID\${SEDdC}1\${SEDdD}
X\${SEDuA}NOREUID\${SEDuB}NOREUID\${SEDuC}1\${SEDuD}
X\${SEDeA}NOREUID\${SEDeB}NOREUID\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
X
X
Xecho checking for select
Xcat > conftest.c <<EOF
X
Xmain() { exit(0); } 
Xt() { select(0, 0, 0, 0, 0); }
XEOF
Xif eval $compile; then
X  :
Xelse
X  LIBS="$LIBS -lnet -lnsl"
Xecho checking for select with $LIBS
Xcat > conftest.c <<EOF
X
Xmain() { exit(0); } 
Xt() { select(0, 0, 0, 0, 0); }
XEOF
Xif eval $compile; then
X  :
Xelse
X  echo '!!! no select - no screen';exit
Xfi
Xrm -f conftest*
X
X
Xfi
Xrm -f conftest*
X
X
Xecho checking fifos
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <fcntl.h>
X
X#ifndef O_NDELAY
X#define O_NDELAY O_NONBLOCK
X#endif
X#ifndef S_IFIFO
X#define S_IFIFO 0010000
X#endif
X
Xchar *fin = "/tmp/conftest$$";
X
Xmain()
X{
X  struct stat stb;
X  int f;
X
X  (void)alarm(5);
X  if (mknod(fin, S_IFIFO|0777, 0))
X    exit(1);
X  if (stat(fin, &stb) || (stb.st_mode & S_IFIFO) != S_IFIFO)
X    exit(1);
X  close(0);
X  if (open(fin, O_RDWR | O_NDELAY))
X    exit(1);
X  if (write(0, "TEST", 4) == -1)
X    exit(1);
X  f = 1;
X  if (select(1, &f, 0, 0, 0) == -1)
X    exit(1);
X  exit(0);
X}
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  echo "- your fifos are usable"; fifo=1
Xelse
X  echo "- your fifos are not usable"
Xfi
Xrm -f conftest*
Xrm -f /tmp/conftest*
X
Xif test -n "$fifo"; then
Xecho "checking for broken fifo implementation"
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <fcntl.h>
X#include <sys/time.h>
X#include <sys/stat.h>
X
X#ifndef O_NDELAY
X#define O_NDELAY O_NONBLOCK
X#endif
X#ifndef S_IFIFO
X#define S_IFIFO 0010000
X#endif
X
Xchar *fin = "/tmp/conftest$$";
X
Xmain()
X{
X  struct timeval tv;
X  int r, x;
X
X  if (mknod(fin, S_IFIFO|0600))
X    exit(1);
X  close(0);
X  if (open(fin, O_RDONLY|O_NDELAY))
X    exit(1);
X  r = 1;
X  tv.tv_sec = 1;
X  tv.tv_usec = 0;
X  if (select(1, &r, 0, 0, &tv))
X    exit(1);
X  exit(0);
X}
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  echo "- your implementation is ok"
Xelse
X  echo "- you have a broken implementation";DEFS="$DEFS -DBROKEN_PIPE=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}BROKEN_PIPE\${SEDdB}BROKEN_PIPE\${SEDdC}1\${SEDdD}
X\${SEDuA}BROKEN_PIPE\${SEDuB}BROKEN_PIPE\${SEDuC}1\${SEDuD}
X\${SEDeA}BROKEN_PIPE\${SEDeB}BROKEN_PIPE\${SEDeC}1\${SEDeD}
X";fifobr=1
Xfi
Xrm -f conftest*
Xrm -f /tmp/conftest*
Xfi
X
X
Xecho checking sockets
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/un.h>
X#include <fcntl.h>
X
X#ifndef O_NDELAY
X#define O_NDELAY O_NONBLOCK
X#endif
X#ifndef FNDELAY
X#define FNDELAY O_NDELAY
X#endif
X
Xchar *son = "/tmp/conftest$$";
X
Xmain()
X{
X  int s1, s2, s3, l;
X  struct sockaddr_un a;
X
X  (void)alarm(5);
X  if ((s1 = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
X    exit(1);
X  a.sun_family = AF_UNIX;
X  strcpy(a.sun_path, son);
X  (void) unlink(son);
X  if (bind(s1, (struct sockaddr *) &a, strlen(son)+2) == -1)
X    exit(1);
X  if (listen(s1, 2))
X    exit(1);
X  if (fork() == 0)
X    {
X      if ((s2 = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
X	kill(getppid(), 3);
X      (void)connect(s2, &a, strlen(son) + 2);
X      if (write(s2, "HELLO", 5) == -1)
X	kill(getppid(), 3);
X      exit(0);
X    }
X  l = sizeof(a);
X  close(0);
X  if (accept(s1, &a, &l))
X    exit(1);
X  l = 1;
X  if (select(1, &l, 0, 0, 0) == -1)
X    exit(1);
X  exit(0);
X}
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  echo "- your sockets are usable"; sock=1
Xelse
X  echo "- your sockets are not usable"
Xfi
Xrm -f conftest*
Xrm -f /tmp/conftest*
X
Xif test -n "$sock"; then
Xecho "checking socket implementation"
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <sys/socket.h>
X#include <sys/un.h>
X
Xchar *son = "/tmp/conftest$$";
X
Xmain()
X{
X  int s;
X  struct stat stb;
X  struct sockaddr_un a;
X  if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
X    exit(0);
X  a.sun_family = AF_UNIX;
X  strcpy(a.sun_path, son);
X  (void) unlink(son);
X  if (bind(s, (struct sockaddr *) &a, strlen(son)+2) == -1)
X    exit(0);
X  if (stat(son, &stb))
X    exit(1);
X  close(s);
X  exit(0);
X}
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  echo "- you are normal"
Xelse
X  echo "- unix domain sockets are not kept in the filesystem";DEFS="$DEFS -DSOCK_NOT_IN_FS=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SOCK_NOT_IN_FS\${SEDdB}SOCK_NOT_IN_FS\${SEDdC}1\${SEDdD}
X\${SEDuA}SOCK_NOT_IN_FS\${SEDuB}SOCK_NOT_IN_FS\${SEDuC}1\${SEDuD}
X\${SEDeA}SOCK_NOT_IN_FS\${SEDeB}SOCK_NOT_IN_FS\${SEDeC}1\${SEDeD}
X";socknofs=1
Xfi
Xrm -f conftest*
Xrm -f /tmp/conftest*
Xfi
X
X
Xif test -n "$fifo"; then
X  if test -n "$sock"; then
X    if test -n "$nore"; then
X      echo "- hmmm... better take the fifos"
X      DEFS="$DEFS -DNAMEDPIPE=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NAMEDPIPE\${SEDdB}NAMEDPIPE\${SEDdC}1\${SEDdD}
X\${SEDuA}NAMEDPIPE\${SEDuB}NAMEDPIPE\${SEDuC}1\${SEDuD}
X\${SEDeA}NAMEDPIPE\${SEDeB}NAMEDPIPE\${SEDeC}1\${SEDeD}
X"
X    elif test -n "$fifobr"; then
X      echo "- as your fifos are broken lets use the sockets."
X    else
X      echo "- both sockets and fifos usable. let's take fifos."
X      DEFS="$DEFS -DNAMEDPIPE=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NAMEDPIPE\${SEDdB}NAMEDPIPE\${SEDdC}1\${SEDdD}
X\${SEDuA}NAMEDPIPE\${SEDuB}NAMEDPIPE\${SEDuC}1\${SEDuD}
X\${SEDeA}NAMEDPIPE\${SEDeB}NAMEDPIPE\${SEDeC}1\${SEDeD}
X"
X    fi
X  else
X    echo "- using named pipes, of course"
X    DEFS="$DEFS -DNAMEDPIPE=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NAMEDPIPE\${SEDdB}NAMEDPIPE\${SEDdC}1\${SEDdD}
X\${SEDuA}NAMEDPIPE\${SEDuB}NAMEDPIPE\${SEDuC}1\${SEDuD}
X\${SEDeA}NAMEDPIPE\${SEDeB}NAMEDPIPE\${SEDeC}1\${SEDeD}
X"
X  fi
Xelif test -n "$sock"; then
X  echo "- using unix-domain sockets, of course"
Xelse
X  echo "!!! you have neither usable sockets nor usable pipes -> no screen"
X  exit
Xfi
X
X
Xecho "checking select return value"
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <fcntl.h>
X
Xchar *nam = "/tmp/conftest$$";
X
X#ifdef NAMEDPIPE
X
X#ifndef O_NDELAY
X#define O_NDELAY O_NONBLOCK
X#endif
X#ifndef S_IFIFO
X#define S_IFIFO 0010000
X#endif
X
X
Xmain()
X{
X  int l;
X
X  (void)alarm(5);
X  if (mknod(nam, S_IFIFO|0777, 0))
X    exit(1);
X  close(0);
X  if (open(nam, O_RDWR | O_NDELAY))
X    exit(1);
X  if (write(0, "TEST", 4) == -1)
X    exit(1);
X
X#else
X
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/un.h>
X
Xmain()
X{
X  int s1, s2, s3, l;
X  struct sockaddr_un a;
X
X  (void)alarm(5);
X  if ((s1 = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
X    exit(1);
X  a.sun_family = AF_UNIX;
X  strcpy(a.sun_path, nam);
X  (void) unlink(nam);
X  if (bind(s1, (struct sockaddr *) &a, strlen(nam)+2) == -1)
X    exit(1);
X  if (listen(s1, 2))
X    exit(1);
X  if (fork() == 0)
X    {
X      if ((s2 = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
X	kill(getppid(), 3);
X      (void)connect(s2, &a, strlen(nam) + 2);
X      if (write(s2, "HELLO", 5) == -1)
X	kill(getppid(), 3);
X      exit(0);
X    }
X  l = sizeof(a);
X  close(0);
X  if (accept(s1, &a, &l))
X    exit(1);
X#endif
X
X
X  l = 1;
X  if (select(1, &l, 0, 0, 0) == -1)
X    exit(1);
X  if (select(1, &l, &l, 0, 0) != 2)
X    exit(1);
X  exit(0);
X}
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  echo "- select is ok"
Xelse
X  echo "- it is not usable";DEFS="$DEFS -DSELECT_BROKEN=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SELECT_BROKEN\${SEDdB}SELECT_BROKEN\${SEDdC}1\${SEDdD}
X\${SEDuA}SELECT_BROKEN\${SEDuB}SELECT_BROKEN\${SEDuC}1\${SEDuD}
X\${SEDeA}SELECT_BROKEN\${SEDeB}SELECT_BROKEN\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
Xecho searching for tgetent
Xolibs="$LIBS"
XLIBS="-ltermcap $LIBS"
Xecho checking for libtermcap
Xcat > conftest.c <<EOF
X
Xmain() { exit(0); } 
Xt() { tgetent((char *)0, (char *)0); }
XEOF
Xif eval $compile; then
X  :
Xelse
X  LIBS="-lcurses $olibs"
Xecho checking for libcurses
Xcat > conftest.c <<EOF
X
Xmain() { exit(0); } 
Xt() { tgetent((char *)0, (char *)0); }
XEOF
Xif eval $compile; then
X  :
Xelse
X  echo "!!! no tgetent - no screen";exit
Xfi
Xrm -f conftest*
X
X
Xfi
Xrm -f conftest*
X
XTERMCAP="xx|scrdumm:xx:"
XTERM=scrdumm
Xexport TERMCAP
Xexport TERM
Xcat > conftest.c <<EOF
X
Xmain()
X{
X  char buf[1024];
X  if (tgetent(buf, "scrdumm") != 1)
X    exit(1);
X  exit(0);
X}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  echo "- you use the termcap database"
Xelse
X  echo "- you use the terminfo database";DEFS="$DEFS -DTERMINFO=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}TERMINFO\${SEDdB}TERMINFO\${SEDdC}1\${SEDdD}
X\${SEDuA}TERMINFO\${SEDuB}TERMINFO\${SEDuC}1\${SEDuD}
X\${SEDeA}TERMINFO\${SEDeB}TERMINFO\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
Xecho checking for ospeed
Xcat > conftest.c <<EOF
Xextern short ospeed;
Xmain() { exit(0); } 
Xt() { ospeed=5; }
XEOF
Xif eval $compile; then
X  :
Xelse
X  DEFS="$DEFS -DNEED_OSPEED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NEED_OSPEED\${SEDdB}NEED_OSPEED\${SEDdC}1\${SEDdD}
X\${SEDuA}NEED_OSPEED\${SEDuB}NEED_OSPEED\${SEDuC}1\${SEDuD}
X\${SEDeA}NEED_OSPEED\${SEDeB}NEED_OSPEED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for ptyranges
Xif test -d /dev/ptym ; then
Xpdir='/dev/ptym'
Xelse
Xpdir='/dev'
Xfi
Xptys=`echo $pdir/pty??`
Xif test "$ptys" != "$pdir/pty??" ; then
Xp0=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\).$/\1/g' | tr ' ' '\012' | sort -u | sed -n -e H -e g -e 's/\n//g' -e '$p'`
Xp1=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\)$/\1/g' | tr ' ' '\012' | sort -u | sed -n -e H -e g -e 's/\n//g' -e '$p'`
XDEFS="$DEFS -DPTYRANGE0=\"$p0\""
XSEDDEFS="${SEDDEFS}\${SEDdA}PTYRANGE0\${SEDdB}PTYRANGE0\${SEDdC}\"$p0\"\${SEDdD}
X\${SEDuA}PTYRANGE0\${SEDuB}PTYRANGE0\${SEDuC}\"$p0\"\${SEDuD}
X\${SEDeA}PTYRANGE0\${SEDeB}PTYRANGE0\${SEDeC}\"$p0\"\${SEDeD}
X"
XDEFS="$DEFS -DPTYRANGE1=\"$p1\""
XSEDDEFS="${SEDDEFS}\${SEDdA}PTYRANGE1\${SEDdB}PTYRANGE1\${SEDdC}\"$p1\"\${SEDdD}
X\${SEDuA}PTYRANGE1\${SEDuB}PTYRANGE1\${SEDuC}\"$p1\"\${SEDuD}
X\${SEDeA}PTYRANGE1\${SEDeB}PTYRANGE1\${SEDeC}\"$p1\"\${SEDeD}
X"
Xfi
X
X
Xecho checking for getutent
Xcat > conftest.c <<EOF
X#include <time.h> /* to get time_t on SCO */
X#include <sys/types.h>
X#ifdef SVR4
X#include <utmpx.h>
X#else
X#include <utmp.h>
X#endif
X#ifdef hpux
X#define pututline _pututline
X#endif
X
Xmain() { exit(0); } 
Xt() { int x = DEAD_PROCESS; struct utmp *y = pututline((struct utmp *)0); getutent(); }
XEOF
Xif eval $compile; then
X  DEFS="$DEFS -DGETUTENT=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}GETUTENT\${SEDdB}GETUTENT\${SEDdC}1\${SEDdD}
X\${SEDuA}GETUTENT\${SEDuB}GETUTENT\${SEDuC}1\${SEDuD}
X\${SEDeA}GETUTENT\${SEDeB}GETUTENT\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
Xecho checking for ut_host
Xcat > conftest.c <<EOF
X#include <time.h>
X#include <sys/types.h>
X#ifdef SVR4
X#include <utmpx.h>
X#else
X#include <utmp.h>
X#endif
X
Xmain() { exit(0); } 
Xt() { struct utmp u; u.ut_host[0] = 0; }
XEOF
Xif eval $compile; then
X  DEFS="$DEFS -DUTHOST=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}UTHOST\${SEDdB}UTHOST\${SEDdC}1\${SEDdD}
X\${SEDuA}UTHOST\${SEDuB}UTHOST\${SEDuC}1\${SEDuD}
X\${SEDeA}UTHOST\${SEDeB}UTHOST\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
X
Xecho "checking for libutil(s)"
Xtest -f /usr/lib/libutils.a && LIBS="$LIBS -lutils"
Xtest -f /usr/lib/libutil.a && LIBS="$LIBS -lutil"
X
Xecho checking for getloadavg
Xcat > conftest.c <<EOF
X
Xmain() { exit(0); } 
Xt() { getloadavg((double *)0, 0); }
XEOF
Xif eval $compile; then
X  DEFS="$DEFS -DLOADAV_GETLOADAVG=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}LOADAV_GETLOADAVG\${SEDdB}LOADAV_GETLOADAVG\${SEDdC}1\${SEDdD}
X\${SEDuA}LOADAV_GETLOADAVG\${SEDuB}LOADAV_GETLOADAVG\${SEDuC}1\${SEDuD}
X\${SEDeA}LOADAV_GETLOADAVG\${SEDeB}LOADAV_GETLOADAVG\${SEDeC}1\${SEDeD}
X";load=1
Xfi
Xrm -f conftest*
X
Xif test -z "$load" ; then
Xcat > conftest.c <<EOF
X#if defined(NeXT) || defined(apollo) || defined(linux)
X  yes
X#endif
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  load=1
Xfi
Xrm -f conftest*
X
Xfi
Xif test -z "$load" ; then
Xecho "searching for kernelfile"
Xfor core in /unix /vmunix /dynix /hp-ux /xelos /386bsd /kernel/unix ; do
X  if test -f $core ; then
X    break
X  fi
Xdone
Xif test ! -f $core ; then
X  echo "- no kernelfile found"
Xelse
X  echo "- using kernelfile '$core'"
X  DEFS="$DEFS -DLOADAV_UNIX=\"$core\""
XSEDDEFS="${SEDDEFS}\${SEDdA}LOADAV_UNIX\${SEDdB}LOADAV_UNIX\${SEDdC}\"$core\"\${SEDdD}
X\${SEDuA}LOADAV_UNIX\${SEDuB}LOADAV_UNIX\${SEDuC}\"$core\"\${SEDuD}
X\${SEDeA}LOADAV_UNIX\${SEDeB}LOADAV_UNIX\${SEDeC}\"$core\"\${SEDeD}
X"
X  echo checking for nlist.h
Xcat > conftest.c <<EOF
X#include <nlist.h>
XEOF
Xerr=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
Xif test -z "$err"; then
X  DEFS="$DEFS -DNLIST_STRUCT=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NLIST_STRUCT\${SEDdB}NLIST_STRUCT\${SEDdC}1\${SEDdD}
X\${SEDuA}NLIST_STRUCT\${SEDuB}NLIST_STRUCT\${SEDuC}1\${SEDuD}
X\${SEDeA}NLIST_STRUCT\${SEDeB}NLIST_STRUCT\${SEDeC}1\${SEDeD}
X"
X     echo checking for n_un in struct nlist
Xcat > conftest.c <<EOF
X#include <nlist.h>
Xmain() { exit(0); } 
Xt() { struct nlist n; n.n_un.n_name = 0; }
XEOF
Xif eval $compile; then
X  DEFS="$DEFS -DNLIST_NAME_UNION=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NLIST_NAME_UNION\${SEDdB}NLIST_NAME_UNION\${SEDdC}1\${SEDdD}
X\${SEDuA}NLIST_NAME_UNION\${SEDuB}NLIST_NAME_UNION\${SEDuC}1\${SEDuD}
X\${SEDeA}NLIST_NAME_UNION\${SEDeB}NLIST_NAME_UNION\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
Xfi
Xrm -f conftest*
X
X
X  echo checking for nlist declaration
X  cat > conftest.c <<EOF
X
X#ifdef NLIST_STRUCT
X# include <nlist.h>
X#else
X# include <a.out.h>
X#endif
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "nlist( |	|\()" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DNLIST_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NLIST_DECLARED\${SEDdB}NLIST_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}NLIST_DECLARED\${SEDuB}NLIST_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}NLIST_DECLARED\${SEDeB}NLIST_DECLARED\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
X  echo searching for avenrun symbol
X  for av in avenrun _avenrun _Loadavg ; do
X  cat > conftest.c <<EOF
X
X#include <sys/types.h>
X#ifdef NLIST_STRUCT
X#include <nlist.h>
X#else
X#include <a.out.h>
X#endif
X
Xstruct nlist nl[2];
X
Xmain()
X{
X#ifdef NLIST_NAME_UNION
X  nl[0].n_un.n_name = "$av";
X#else
X  nl[0].n_name = "$av";
X#endif
X  nlist(LOADAV_UNIX, nl);
X  if (nl[0].n_value == 0)
X    exit(1);
X  exit(0);
X}
X  
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  avensym=$av;break
Xfi
Xrm -f conftest*
X  done
X  if test -z "$avensym" ; then
X    echo "- no avenrun symbol found"
X  else
X    echo "- using avenrun symbol '$avensym'"
X    DEFS="$DEFS -DLOADAV_AVENRUN=\"$avensym\""
XSEDDEFS="${SEDDEFS}\${SEDdA}LOADAV_AVENRUN\${SEDdB}LOADAV_AVENRUN\${SEDdC}\"$avensym\"\${SEDdD}
X\${SEDuA}LOADAV_AVENRUN\${SEDuB}LOADAV_AVENRUN\${SEDuC}\"$avensym\"\${SEDuD}
X\${SEDeA}LOADAV_AVENRUN\${SEDeB}LOADAV_AVENRUN\${SEDeC}\"$avensym\"\${SEDeD}
X";
X    load=1
X  fi
Xfi
Xfi
X
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <sys/param.h>
X
X_CUT_HERE_
X
X#if ((defined(hp300) && !defined(hpux)) || defined(sun) || (defined(ultrix) && defined(mips)) || defined(_SEQUENT_) || defined(sgi) || defined(SVR4) || defined(sony_news))
Xloadtype=long
X# ifdef apollo
Xloadscale=65536
X# else
X#  ifdef FSCALE
X#   undef FSCALE
Xloadscale=FSCALE
X#  else
X#   ifdef sgi
Xloadscale=1024
X#   else
X#    if defined(MIPS) || defined(SVR4)
Xloadscale=256
X#    else /* not MIPS */
Xloadscale=1000 	/* our default value */
X#    endif /* MIPS */
X#   endif /* sgi */
X#  endif /* not FSCALE */
X# endif /* not apollo */
X#else
Xloadtype=double
Xloadscale=1
X#endif
X#ifdef alliant
Xloadnum=4
X#else
Xloadnum=3
X#endif
X
XEOF
Xeval "$CPP $DEFS conftest.c 2>/dev/null | sed -e '1,/_CUT_HERE_/d' > conftest.out"
X. ./conftest.out
Xrm -f conftest*
X
X
Xif test -n "$load" ; then DEFS="$DEFS -DLOADAV=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}LOADAV\${SEDdB}LOADAV\${SEDdC}1\${SEDdD}
X\${SEDuA}LOADAV\${SEDuB}LOADAV\${SEDuC}1\${SEDuD}
X\${SEDeA}LOADAV\${SEDeB}LOADAV\${SEDeC}1\${SEDeD}
X" ; fi
Xif test -n "$loadtype" ; then DEFS="$DEFS -DLOADAV_TYPE=$loadtype"
XSEDDEFS="${SEDDEFS}\${SEDdA}LOADAV_TYPE\${SEDdB}LOADAV_TYPE\${SEDdC}$loadtype\${SEDdD}
X\${SEDuA}LOADAV_TYPE\${SEDuB}LOADAV_TYPE\${SEDuC}$loadtype\${SEDuD}
X\${SEDeA}LOADAV_TYPE\${SEDeB}LOADAV_TYPE\${SEDeC}$loadtype\${SEDeD}
X" ; fi
Xif test -n "$loadnum" ; then DEFS="$DEFS -DLOADAV_NUM=$loadnum"
XSEDDEFS="${SEDDEFS}\${SEDdA}LOADAV_NUM\${SEDdB}LOADAV_NUM\${SEDdC}$loadnum\${SEDdD}
X\${SEDuA}LOADAV_NUM\${SEDuB}LOADAV_NUM\${SEDuC}$loadnum\${SEDuD}
X\${SEDeA}LOADAV_NUM\${SEDeB}LOADAV_NUM\${SEDeC}$loadnum\${SEDeD}
X" ; fi
Xif test -n "$loadscale" ; then DEFS="$DEFS -DLOADAV_SCALE=$loadscale"
XSEDDEFS="${SEDDEFS}\${SEDdA}LOADAV_SCALE\${SEDdB}LOADAV_SCALE\${SEDdC}$loadscale\${SEDdD}
X\${SEDuA}LOADAV_SCALE\${SEDuB}LOADAV_SCALE\${SEDuC}$loadscale\${SEDuD}
X\${SEDeA}LOADAV_SCALE\${SEDeB}LOADAV_SCALE\${SEDeC}$loadscale\${SEDeD}
X" ; fi
X
X
Xecho '#include <signal.h>' > conftest.c
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "(void|sighandler_t).*signal" conftest.out >/dev/null 2>&1; then
X  DEFS="$DEFS -DSIGVOID=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SIGVOID\${SEDdB}SIGVOID\${SEDdC}1\${SEDdD}
X\${SEDuA}SIGVOID\${SEDuB}SIGVOID\${SEDuC}1\${SEDuD}
X\${SEDeA}SIGVOID\${SEDeB}SIGVOID\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
Xecho checking for sigset
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <signal.h>
X
Xmain() { exit(0); } 
Xt() { 
X#ifdef SIGVOID
Xsigset(0, (void (*)())0);
X#else
Xsigset(0, (int (*)())0);
X#endif
X }
XEOF
Xif eval $compile; then
X  DEFS="$DEFS -DUSESIGSET=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}USESIGSET\${SEDdB}USESIGSET\${SEDdC}1\${SEDdD}
X\${SEDuA}USESIGSET\${SEDuB}USESIGSET\${SEDuC}1\${SEDuD}
X\${SEDeA}USESIGSET\${SEDeB}USESIGSET\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
Xecho checking signal implementation
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <signal.h>
X
X#ifndef SIGCHLD
X#define SIGCHLD SIGCLD
X#endif
X#ifdef USESIGSET
X#define signal sigset
X#endif
X
Xint got;
X
X#ifdef SIGVOID
Xvoid
X#endif
Xhand()
X{
X  got++;
X}
X
Xmain()
X{
X  (void)signal(SIGCHLD, hand);
X  kill(getpid(), SIGCHLD);
X  kill(getpid(), SIGCHLD);
X  if (got < 2)
X    exit(1);
X  exit(0);
X}
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  :
Xelse
X  DEFS="$DEFS -DSYSVSIGS=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SYSVSIGS\${SEDdB}SYSVSIGS\${SEDdC}1\${SEDdD}
X\${SEDuA}SYSVSIGS\${SEDuB}SYSVSIGS\${SEDuC}1\${SEDuD}
X\${SEDeA}SYSVSIGS\${SEDeB}SYSVSIGS\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for crypt and sec libraries
Xtest -f /lib/libcrypt_d.a || test -f /usr/lib/libcrypt_d.a && LIBS="$LIBS -lcrypt_d"
Xtest -f /lib/libcrypt.a || test -f /usr/lib/libcrypt.a && LIBS="$LIBS -lcrypt"
Xtest -f /lib/libsec.a || test -f /usr/lib/libsec.a && LIBS="$LIBS -lsec"
X
Xoldlibs="$LIBS"
XLIBS="$LIBS -lsun"
Xecho checking for IRIX sun library
Xcat > conftest.c <<EOF
X
Xmain() { exit(0); } 
Xt() {  }
XEOF
Xif eval $compile; then
X  :
Xelse
X  LIBS="$oldlibs"
Xfi
Xrm -f conftest*
X
X
X
Xecho checking for wait union
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <sys/wait.h>
X
Xmain() { exit(0); } 
Xt() { 
X  union wait x;
X  int y;
X#ifdef WEXITSTATUS
X  y = WEXITSTATUS(x);
X#endif
X }
XEOF
Xif eval $compile; then
X  DEFS="$DEFS -DBSDWAIT=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}BSDWAIT\${SEDdB}BSDWAIT\${SEDdC}1\${SEDdD}
X\${SEDuA}BSDWAIT\${SEDuB}BSDWAIT\${SEDuC}1\${SEDuD}
X\${SEDeA}BSDWAIT\${SEDeB}BSDWAIT\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for termio or termios
Xcat > conftest.c <<EOF
X#include <termios.h>
XEOF
Xerr=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
Xif test -z "$err"; then
X  DEFS="$DEFS -DTERMIO=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}TERMIO\${SEDdB}TERMIO\${SEDdC}1\${SEDdD}
X\${SEDuA}TERMIO\${SEDuB}TERMIO\${SEDuC}1\${SEDuD}
X\${SEDeA}TERMIO\${SEDeB}TERMIO\${SEDeC}1\${SEDeD}
X"
Xelse
X  cat > conftest.c <<EOF
X#include <termio.h>
XEOF
Xerr=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
Xif test -z "$err"; then
X  DEFS="$DEFS -DTERMIO=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}TERMIO\${SEDdB}TERMIO\${SEDdC}1\${SEDdD}
X\${SEDuA}TERMIO\${SEDuB}TERMIO\${SEDuC}1\${SEDuD}
X\${SEDeA}TERMIO\${SEDeB}TERMIO\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
Xfi
Xrm -f conftest*
X
Xecho checking for getspnam
Xcat > conftest.c <<EOF
X#include <shadow.h>
Xmain() { exit(0); } 
Xt() { getspnam(); }
XEOF
Xif eval $compile; then
X  DEFS="$DEFS -DSHADOWPW=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SHADOWPW\${SEDdB}SHADOWPW\${SEDdC}1\${SEDdD}
X\${SEDuA}SHADOWPW\${SEDuB}SHADOWPW\${SEDuC}1\${SEDuD}
X\${SEDeA}SHADOWPW\${SEDeB}SHADOWPW\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for getttyent
Xcat > conftest.c <<EOF
X
Xmain() { exit(0); } 
Xt() { getttyent(); }
XEOF
Xif eval $compile; then
X  DEFS="$DEFS -DGETTTYENT=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}GETTTYENT\${SEDdB}GETTTYENT\${SEDdC}1\${SEDdD}
X\${SEDuA}GETTTYENT\${SEDuB}GETTTYENT\${SEDuC}1\${SEDuD}
X\${SEDeA}GETTTYENT\${SEDeB}GETTTYENT\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking whether memcpy/memmove/bcopy handles overlapping arguments
Xcat > conftest.c <<EOF
X
Xmain() {
X  char buf[10];
X  strcpy(buf, "abcdefghi");
X  bcopy(buf, buf + 2, 3);
X  if (strncmp(buf, "ababcf", 6))
X    exit(1);
X  strcpy(buf, "abcdefghi");
X  bcopy(buf + 2, buf, 3);
X  if (strncmp(buf, "cdedef", 6))
X    exit(1);
X  exit(0); /* libc version works properly.  */
X}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  DEFS="$DEFS -DUSEBCOPY=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}USEBCOPY\${SEDdB}USEBCOPY\${SEDdC}1\${SEDdD}
X\${SEDuA}USEBCOPY\${SEDuB}USEBCOPY\${SEDuC}1\${SEDuD}
X\${SEDeA}USEBCOPY\${SEDeB}USEBCOPY\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
Xcat > conftest.c <<EOF
X
X#define bcopy(s,d,l) memmove(d,s,l)
Xmain() {
X  char buf[10];
X  strcpy(buf, "abcdefghi");
X  bcopy(buf, buf + 2, 3);
X  if (strncmp(buf, "ababcf", 6))
X    exit(1);
X  strcpy(buf, "abcdefghi");
X  bcopy(buf + 2, buf, 3);
X  if (strncmp(buf, "cdedef", 6))
X    exit(1);
X  exit(0); /* libc version works properly.  */
X}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  DEFS="$DEFS -DUSEMEMMOVE=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}USEMEMMOVE\${SEDdB}USEMEMMOVE\${SEDdC}1\${SEDdD}
X\${SEDuA}USEMEMMOVE\${SEDuB}USEMEMMOVE\${SEDuC}1\${SEDuD}
X\${SEDeA}USEMEMMOVE\${SEDeB}USEMEMMOVE\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xcat > conftest.c <<EOF
X
X#define bcopy(s,d,l) memcpy(d,s,l)
Xmain() {
X  char buf[10];
X  strcpy(buf, "abcdefghi");
X  bcopy(buf, buf + 2, 3);
X  if (strncmp(buf, "ababcf", 6))
X    exit(1);
X  strcpy(buf, "abcdefghi");
X  bcopy(buf + 2, buf, 3);
X  if (strncmp(buf, "cdedef", 6))
X    exit(1);
X  exit(0); /* libc version works properly.  */
X}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  DEFS="$DEFS -DUSEMEMCPY=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}USEMEMCPY\${SEDdB}USEMEMCPY\${SEDdC}1\${SEDdD}
X\${SEDuA}USEMEMCPY\${SEDuB}USEMEMCPY\${SEDuC}1\${SEDuD}
X\${SEDeA}USEMEMCPY\${SEDeB}USEMEMCPY\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
Xecho checking for long file names
X(echo 1 > /tmp/conftest9012345) 2>/dev/null
X(echo 2 > /tmp/conftest9012346) 2>/dev/null
Xval=`cat /tmp/conftest9012345 2>/dev/null`
Xif test -f /tmp/conftest9012345 && test "$val" = 1; then :
Xelse DEFS="$DEFS -DNAME_MAX=14"
XSEDDEFS="${SEDDEFS}\${SEDdA}NAME_MAX\${SEDdB}NAME_MAX\${SEDdC}14\${SEDdD}
X\${SEDuA}NAME_MAX\${SEDuB}NAME_MAX\${SEDuC}14\${SEDuD}
X\${SEDeA}NAME_MAX\${SEDeB}NAME_MAX\${SEDeC}14\${SEDeD}
X"
Xfi
Xrm -f /tmp/conftest*
X
Xecho checking for vsprintf
Xcat > conftest.c <<EOF
X#include <varargs.h>
X#include <stdio.h>
Xmain() { exit(0); } 
Xt() { vsprintf(); }
XEOF
Xif eval $compile; then
X  DEFS="$DEFS -DUSEVARARGS=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}USEVARARGS\${SEDdB}USEVARARGS\${SEDdC}1\${SEDdD}
X\${SEDuA}USEVARARGS\${SEDuB}USEVARARGS\${SEDuC}1\${SEDuD}
X\${SEDeA}USEVARARGS\${SEDeB}USEVARARGS\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
X
Xecho checking for directory library header
Xecho checking for dirent.h
Xcat > conftest.c <<EOF
X#include <dirent.h>
XEOF
Xerr=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
Xif test -z "$err"; then
X  DEFS="$DEFS -DDIRENT=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}DIRENT\${SEDdB}DIRENT\${SEDdC}1\${SEDdD}
X\${SEDuA}DIRENT\${SEDuB}DIRENT\${SEDuC}1\${SEDuD}
X\${SEDeA}DIRENT\${SEDeB}DIRENT\${SEDeC}1\${SEDeD}
X" dirheader=dirent.h
Xfi
Xrm -f conftest*
X
Xif test -z "$dirheader"; then
Xecho checking for sys/ndir.h
Xcat > conftest.c <<EOF
X#include <sys/ndir.h>
XEOF
Xerr=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
Xif test -z "$err"; then
X  DEFS="$DEFS -DSYSNDIR=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SYSNDIR\${SEDdB}SYSNDIR\${SEDdC}1\${SEDdD}
X\${SEDuA}SYSNDIR\${SEDuB}SYSNDIR\${SEDuC}1\${SEDuD}
X\${SEDeA}SYSNDIR\${SEDeB}SYSNDIR\${SEDeC}1\${SEDeD}
X" dirheader=sys/ndir.h
Xfi
Xrm -f conftest*
X
Xfi
Xif test -z "$dirheader"; then
Xecho checking for sys/dir.h
Xcat > conftest.c <<EOF
X#include <sys/dir.h>
XEOF
Xerr=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
Xif test -z "$err"; then
X  DEFS="$DEFS -DSYSDIR=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SYSDIR\${SEDdB}SYSDIR\${SEDdC}1\${SEDdD}
X\${SEDuA}SYSDIR\${SEDuB}SYSDIR\${SEDuC}1\${SEDuD}
X\${SEDeA}SYSDIR\${SEDeB}SYSDIR\${SEDeC}1\${SEDeD}
X" dirheader=sys/dir.h
Xfi
Xrm -f conftest*
X
Xfi
Xif test -z "$dirheader"; then
Xecho checking for ndir.h
Xcat > conftest.c <<EOF
X#include <ndir.h>
XEOF
Xerr=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
Xif test -z "$err"; then
X  DEFS="$DEFS -DNDIR=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NDIR\${SEDdB}NDIR\${SEDdC}1\${SEDdD}
X\${SEDuA}NDIR\${SEDuB}NDIR\${SEDuC}1\${SEDuD}
X\${SEDeA}NDIR\${SEDeB}NDIR\${SEDeC}1\${SEDeD}
X" dirheader=ndir.h
Xfi
Xrm -f conftest*
X
Xfi
X
Xecho checking for closedir return value
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <$dirheader>
Xint closedir(); main() { exit(0); }
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  :
Xelse
X  DEFS="$DEFS -DVOID_CLOSEDIR=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}VOID_CLOSEDIR\${SEDdB}VOID_CLOSEDIR\${SEDdC}1\${SEDdD}
X\${SEDuA}VOID_CLOSEDIR\${SEDuB}VOID_CLOSEDIR\${SEDuC}1\${SEDuD}
X\${SEDeA}VOID_CLOSEDIR\${SEDeB}VOID_CLOSEDIR\${SEDeC}1\${SEDeD}
X"
Xfi
Xrm -f conftest*
X
Xecho checking for Xenix
Xcat > conftest.c <<EOF
X#if defined(M_XENIX) && !defined(M_UNIX)
X  yes
X#endif
X
XEOF
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  XENIX=1
Xfi
Xrm -f conftest*
X
Xif test -n "$XENIX"; then
X  DEFS="$DEFS -DVOID_CLOSEDIR=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}VOID_CLOSEDIR\${SEDdB}VOID_CLOSEDIR\${SEDdC}1\${SEDdD}
X\${SEDuA}VOID_CLOSEDIR\${SEDuB}VOID_CLOSEDIR\${SEDuC}1\${SEDuD}
X\${SEDeA}VOID_CLOSEDIR\${SEDeB}VOID_CLOSEDIR\${SEDeC}1\${SEDeD}
X"
X  LIBS="$LIBS -lx"
X  case "$DEFS" in
X  *SYSNDIR*) ;;
X  *) LIBS="-ldir $LIBS" ;; # Make sure -ldir precedes any -lx.
X  esac
Xfi
X
X
Xecho checking for setenv
Xcat > conftest.c <<EOF
X
Xmain() { exit(0); } 
Xt() { setenv((char *)0,(char *)0);unsetenv((char *)0); }
XEOF
Xif eval $compile; then
X  DEFS="$DEFS -DUSESETENV=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}USESETENV\${SEDdB}USESETENV\${SEDdC}1\${SEDdD}
X\${SEDuA}USESETENV\${SEDuB}USESETENV\${SEDuC}1\${SEDuD}
X\${SEDeA}USESETENV\${SEDeB}USESETENV\${SEDeC}1\${SEDeD}
X"
Xelse
X  echo checking for putenv
Xcat > conftest.c <<EOF
X
Xmain() { exit(0); } 
Xt() { putenv((char *)0);unsetenv((char *)0); }
XEOF
Xif eval $compile; then
X  :
Xelse
X  DEFS="$DEFS -DNEEDPUTENV=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NEEDPUTENV\${SEDdB}NEEDPUTENV\${SEDdC}1\${SEDdD}
X\${SEDuA}NEEDPUTENV\${SEDuB}NEEDPUTENV\${SEDuC}1\${SEDuD}
X\${SEDeA}NEEDPUTENV\${SEDeB}NEEDPUTENV\${SEDeC}1\${SEDeD}
X"
X
Xfi
Xrm -f conftest*
X
Xfi
Xrm -f conftest*
X
X
Xtest -n "$seqptx" && LIBS="-ltermcap -lc -lsocket -linet -lsec -lseq"
X
Xcat > conftest.c <<EOF
Xmain(){exit(0);}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  :
Xelse
X  echo "Can't run the compiler - internal error. Sorry.";exit
Xfi
Xrm -f conftest*
Xif test -n "$prefix"; then
X  test -z "$exec_prefix" && exec_prefix='${prefix}'
X  prsub="s%^prefix\\([ 	]*\\)=\\([ 	]*\\).*$%prefix\\1=\\2$prefix%"
Xfi
Xif test -n "$exec_prefix"; then
X  prsub="$prsub
Xs%^exec_prefix\\([ 	]*\\)=\\([ 	]*\\).*$%\
Xexec_prefix\\1=\\2$exec_prefix%"
Xfi
X
Xtrap 'rm -f config.status; exit 1' 1 3 15
Xecho creating config.status
Xrm -f config.status
Xcat > config.status <<EOF
X#!/bin/sh
X# Generated automatically by configure.
X# Run this file to recreate the current configuration.
X# This directory was configured as follows,
X# on host `(hostname || uname -n) 2>/dev/null`:
X#
X# $0 $*
X
Xfor arg
Xdo
X  case "\$arg" in
X    -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
X    exec /bin/sh $0 $* ;;
X    *) echo "Usage: config.status --recheck" 2>&1; exit 1 ;;
X  esac
Xdone
X
Xtrap 'rm -f Makefile config.h conftest*; exit 1' 1 3 15
XVERSION='$VERSION'
XCC='$CC'
XCPP='$CPP'
XAWK='$AWK'
XINSTALL='$INSTALL'
XINSTALL_PROGRAM='$INSTALL_PROGRAM'
XINSTALL_DATA='$INSTALL_DATA'
XLIBS='$LIBS'
Xsrcdir='$srcdir'
Xprefix='$prefix'
Xexec_prefix='$exec_prefix'
Xprsub='$prsub'
XEOF
Xcat >> config.status <<\EOF
X
Xtop_srcdir=$srcdir
Xfor file in .. Makefile; do if [ "x$file" != "x.." ]; then
X  srcdir=$top_srcdir
X  # Remove last slash and all that follows it.  Not all systems have dirname.
X  dir=`echo $file|sed 's%/[^/][^/]*$%%'`
X  if test "$dir" != "$file"; then
X    test "$top_srcdir" != . && srcdir=$top_srcdir/$dir
X    test ! -d $dir && mkdir $dir
X  fi
X  echo creating $file
X  rm -f $file
X  echo "# Generated automatically from `echo $file|sed 's|.*/||'`.in by configure." > $file
X  sed -e "
X$prsub
Xs%@VERSION@%$VERSION%g
Xs%@CC@%$CC%g
Xs%@CPP@%$CPP%g
Xs%@AWK@%$AWK%g
Xs%@INSTALL@%$INSTALL%g
Xs%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
Xs%@INSTALL_DATA@%$INSTALL_DATA%g
Xs%@LIBS@%$LIBS%g
Xs%@srcdir@%$srcdir%g
Xs%@DEFS@%-DHAVE_CONFIG_H%" $top_srcdir/${file}.in >> $file
Xfi; done
X
Xecho creating config.h
X# These sed commands are put into SEDDEFS when defining a macro.
X# They are broken into pieces to make the sed script easier to manage.
X# They are passed to sed as "A NAME B NAME C VALUE D", where NAME
X# is the cpp macro being defined and VALUE is the value it is being given.
X# Each defining turns into a single global substitution command.
X#
X# SEDd sets the value in "#define NAME VALUE" lines.
XSEDdA='s@^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
XSEDdB='\([ 	][ 	]*\)[^ 	]*@\1#\2'
XSEDdC='\3'
XSEDdD='@g'
X# SEDu turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
XSEDuA='s@^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
XSEDuB='\([ 	]\)@\1#\2define\3'
XSEDuC=' '
XSEDuD='\4@g'
X# SEDe turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
XSEDeA='s@^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
XSEDeB='$@\1#\2define\3'
XSEDeC=' '
XSEDeD='@g'
Xrm -f conftest.sed
Xcat > conftest.sed <<CONFEOF
XEOF
X# Turn off quoting long enough to insert the sed commands.
Xcat >> config.status <<EOF
X$SEDDEFS
XEOF
Xcat >> config.status <<\EOF
XCONFEOF
Xrm -f conftest.h
X# Break up the sed commands because old seds have small limits.
Xcp $top_srcdir/config.h.in conftest.h1
Xwhile :
Xdo
X  lines=`grep -c . conftest.sed`
X  if test -z "$lines" || test "$lines" -eq 0; then break; fi
X  rm -f conftest.s1 conftest.s2 conftest.h2
X  sed 30q conftest.sed > conftest.s1 # Like head -30.
X  sed 1,30d conftest.sed > conftest.s2 # Like tail +31.
X  sed -f conftest.s1 < conftest.h1 > conftest.h2
X  rm -f conftest.s1 conftest.h1 conftest.sed
X  mv conftest.h2 conftest.h1
X  mv conftest.s2 conftest.sed
Xdone
Xrm -f conftest.sed conftest.h
Xecho "/* config.h.  Generated automatically by configure.  */" > conftest.h
Xcat conftest.h1 >> conftest.h
Xrm -f conftest.h1
Xif cmp -s config.h conftest.h 2>/dev/null; then
X  # The file exists and we would not be changing it.
X  rm -f conftest.h
Xelse
X  rm -f config.h
X  mv conftest.h config.h
Xfi
X
XEOF
Xchmod +x config.status
Xtest -n "$no_create" || ./config.status
X
X
X# a hook for preserving undef directive in config.h
Xif test -z "$no_create" ; then
Xmv config.h conftest
Xsed -e 's@^\(.*\)defin.\( .*\) .*/\*\(.*KEEP_UNDEF_HERE\)@\1undef\2	/\*\3@' < conftest > config.h
Xrm -f conftest
Xfi
Xcat >> config.status << EOF
Xmv config.h conftest
Xsed -e 's@^\(.*\)defin.\( .*\) .*/\*\(.*KEEP_UNDEF_HERE\)@\1undef\2	/\*\3@' < conftest > config.h
Xrm -f conftest
XEOF
X
Xecho ""
Xif test -z "$AWK"; then
Xecho "!!! Since you have no awk you must copy the files 'comm.h.dist'"
Xecho "!!! and 'term.h.dist' to 'comm.h' and 'term.h'."
Xecho "!!! Do _not_ change the user configuration section in config.h!"
Xecho "Please check the pathnames in the Makefile."
Xelse
Xecho "Now please check the pathnames in the Makefile and the user"
Xecho "configuration section in config.h."
Xfi
Xecho "Then type 'make' to make screen. Good luck."
Xecho ""
END_OF_FILE
if test 52835 -ne `wc -c <'configure'`; then
    echo shar: \"'configure'\" unpacked with wrong size!
fi
chmod +x 'configure'
# end of 'configure'
fi
if test -f 'process.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'process.c'\"
else
echo shar: Extracting \"'process.c'\" \(52175 characters\)
sed "s/^X//" >'process.c' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X */
X
X#include "rcs.h"
XRCS_ID("$Id: process.c,v 1.12 1993/07/21 15:43:19 mlschroe Exp $ FAU")
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <signal.h>
X#include <fcntl.h>
X#if !defined(sun) && !defined(B43) && !defined(ISC) && !defined(pyr) && !defined(_CX_UX)
X# include <time.h>
X#endif
X#include <sys/time.h>
X#ifndef sun
X#include <sys/ioctl.h>
X#endif
X
X
X#include "config.h"
X#include "screen.h"
X#include "extern.h"
X
X#if defined(sun) && defined(SVR4)
X# include <sys/stropts.h>
X#endif
X
Xextern struct comm comms[];
Xextern char *rc_name;
Xextern char *RcFileName, *home, *extra_incap, *extra_outcap;
Xextern char *BellString, *ActivityString, *ShellProg, *ShellArgs[];
Xextern char *hardcopydir, *screenlogdir;
Xextern char *VisualBellString;
Xextern int VBellWait, MsgWait, MsgMinWait, SilenceWait;
Xextern char Esc, MetaEsc;
Xextern char SockPath[], *SockNamePtr;
Xextern int TtyMode, auto_detach;
Xextern int iflag;
Xextern int default_wrap;
Xextern int use_hardstatus, visual_bell, default_monitor;
Xextern int default_startup;
Xextern int slowpaste, defobuflimit;
X#ifdef AUTO_NUKE
Xextern int defautonuke;
X#endif
Xextern char screenterm[];
Xextern int intrc, origintrc; /* display? */
Xextern struct NewWindow nwin_default, nwin_undef;
X#ifdef COPY_PASTE
Xextern int join_with_cr;
Xextern char mark_key_tab[];
Xextern char *BufferFile;
X#endif
X#ifdef POW_DETACH
Xextern char *BufferFile, *PowDetachString;
X#endif
Xextern time_t Now;
X
X
Xstatic int  CheckArgNum __P((int, char **));
Xstatic void FreeKey __P((int));
Xstatic int  NextWindow __P((void));
Xstatic int  PreviousWindow __P((void));
Xstatic int  MoreWindows __P((void));
Xstatic void LogToggle __P((int));
Xstatic void ShowTime __P((void));
Xstatic void ShowInfo __P((void));
Xstatic void SwitchWindow __P((int));
Xstatic char **SaveArgs __P((char **));
Xstatic struct win *WindowByName __P((char *));
Xstatic int  ParseSwitch __P((struct action *, int *));
Xstatic int  ParseOnOff __P((struct action *, int *));
Xstatic int  ParseSaveStr __P((struct action *act, char **));
Xstatic int  ParseNum __P((struct action *act, int *));
Xstatic int  ParseWinNum __P((struct action *act, int *));
Xstatic int  ParseOct __P((struct action *act, int *));
Xstatic char *ParseChar __P((char *, char *));
Xstatic int  IsNum __P((char *, int));
Xstatic int  IsNumColon __P((char *, int, char *, int));
Xstatic void InputColon __P((void));
Xstatic void Colonfin __P((char *, int));
Xstatic void InputSelect __P((void));
Xstatic void InputAKA __P((void));
Xstatic void AKAfin __P((char *, int));
X#ifdef COPY_PASTE
Xstatic void copy_reg_fn __P((char *, int));
Xstatic void ins_reg_fn __P((char *, int));
X#endif
Xstatic void process_fn __P((char *, int));
X#ifdef PASSWORD
Xstatic void pass1 __P((char *, int));
Xstatic void pass2 __P((char *, int));
X#endif
X#ifdef POW_DETACH
Xstatic void pow_detach_fn __P((char *, int));
X#endif
X
X
X
Xextern struct display *display, *displays;
Xextern struct win *fore, *console_window, *windows;
X
Xextern char screenterm[], HostName[], version[];
Xextern struct NewWindow nwin_undef, nwin_default;
Xextern struct LayFuncs WinLf;
Xextern struct layer BlankLayer;
X
Xextern int Z0width, Z1width;
Xextern int real_uid, real_gid;
Xextern int visual_bell, default_monitor;
X
X#ifdef NETHACK
Xextern int nethackflag;
X#endif
X
X
Xstruct win *wtab[MAXWIN];	/* window table */
Xstruct action ktab[256];	/* command key translation table */
X
X
X#ifdef MULTIUSER
Xextern char *multi;
X#endif
X#ifdef PASSWORD
Xint CheckPassword;
Xchar Password[20];
X#endif
X
X#define MAX_PLOP_DEFS 256
X
Xstatic struct plop
X{
X  char *buf;
X  int len;
X} plop_tab[MAX_PLOP_DEFS];
X
X
Xchar Esc = Ctrl('a');
Xchar MetaEsc = 'a';
X#ifdef PTYMODE
Xint TtyMode = PTYMODE;
X#else
Xint TtyMode = 0622;
X#endif
Xint hardcopy_append = 0;
Xint all_norefresh = 0;
X
X
Xchar *noargs[1];
X
Xvoid
XInitKeytab()
X{
X  register unsigned int i;
X
X  for (i = 0; i < sizeof(ktab)/sizeof(*ktab); i++)
X    {
X      ktab[i].nr = RC_ILLEGAL;
X      ktab[i].args = noargs;
X    }
X
X  ktab['h'].nr = ktab[Ctrl('h')].nr = RC_HARDCOPY;
X#ifdef BSDJOBS
X  ktab['z'].nr = ktab[Ctrl('z')].nr = RC_SUSPEND;
X#endif
X  ktab['c'].nr = ktab[Ctrl('c')].nr = RC_SCREEN;
X  ktab[' '].nr = ktab[Ctrl(' ')].nr =
X    ktab['n'].nr = ktab[Ctrl('n')].nr = RC_NEXT;
X  ktab['N'].nr = RC_NUMBER;
X  ktab[Ctrl('h')].nr = ktab[0177].nr = ktab['p'].nr = ktab[Ctrl('p')].nr = RC_PREV;
X  ktab['k'].nr = ktab[Ctrl('k')].nr = RC_KILL;
X  ktab['l'].nr = ktab[Ctrl('l')].nr = RC_REDISPLAY;
X  ktab['w'].nr = ktab[Ctrl('w')].nr = RC_WINDOWS;
X  ktab['v'].nr = ktab[Ctrl('v')].nr = RC_VERSION;
X  ktab['q'].nr = ktab[Ctrl('q')].nr = RC_XON;
X  ktab['s'].nr = ktab[Ctrl('s')].nr = RC_XOFF;
X  ktab['t'].nr = ktab[Ctrl('t')].nr = RC_TIME;
X  ktab['i'].nr = ktab[Ctrl('i')].nr = RC_INFO;
X  ktab['m'].nr = ktab[Ctrl('m')].nr = RC_LASTMSG;
X  ktab['A'].nr = RC_AKA;
X#ifdef UTMPOK
X  ktab['L'].nr = RC_LOGIN;
X#endif
X  ktab[','].nr = RC_LICENSE;
X  ktab['W'].nr = RC_WIDTH;
X  ktab['.'].nr = RC_DUMPTERMCAP;
X  ktab[Ctrl('\\')].nr = RC_QUIT;
X  ktab['d'].nr = ktab[Ctrl('d')].nr = RC_DETACH;
X  ktab['r'].nr = ktab[Ctrl('r')].nr = RC_WRAP;
X  ktab['f'].nr = ktab[Ctrl('f')].nr = RC_FLOW;
X  ktab['C'].nr = RC_CLEAR;
X  ktab['Z'].nr = RC_RESET;
X  ktab['H'].nr = RC_LOG;
X  ktab[(unsigned int)Esc].nr = RC_OTHER;
X  ktab[(unsigned int)MetaEsc].nr = RC_META;
X  ktab['M'].nr = RC_MONITOR;
X  ktab['?'].nr = RC_HELP;
X  for (i = 0; i < ((MAXWIN < 10) ? MAXWIN : 10); i++)
X    {
X      char *args[2], arg1[10];
X      args[0] = arg1;
X      args[1] = 0;
X      sprintf(arg1, "%d", i);
X      ktab['0' + i].nr = RC_SELECT;
X      ktab['0' + i].args = SaveArgs(args);
X    }
X  ktab[Ctrl('G')].nr = RC_VBELL;
X  ktab[':'].nr = RC_COLON;
X#ifdef COPY_PASTE
X  ktab['['].nr = ktab[Ctrl('[')].nr = RC_COPY;
X  ktab[']'].nr = ktab[Ctrl(']')].nr = RC_PASTE;
X  ktab['{'].nr = RC_HISTORY;
X  ktab['}'].nr = RC_HISTORY;
X  ktab['>'].nr = RC_WRITEBUF;
X  ktab['<'].nr = RC_READBUF;
X  ktab['='].nr = RC_REMOVEBUF;
X  ktab['\''].nr = ktab['"'].nr = RC_SELECT; /* calling a window by name */
X#endif
X#ifdef POW_DETACH
X  ktab['D'].nr = RC_POW_DETACH;
X#endif
X#ifdef LOCK
X  ktab['x'].nr = ktab[Ctrl('x')].nr = RC_LOCKSCREEN;
X#endif
X  ktab['b'].nr = ktab[Ctrl('b')].nr = RC_BREAK;
X  ktab['B'].nr = RC_POW_BREAK;
X  ktab['_'].nr = RC_SILENCE;
X}
X
Xstatic void
XFreeKey(key)
Xint key;
X{
X  char **p;
X
X  struct action *act = &ktab[key];
X  if (act->nr == RC_ILLEGAL)
X    return;
X  act->nr = RC_ILLEGAL;
X  if (act->args == noargs)
X    return;
X  for (p = act->args; *p; p++)
X    free(*p);
X  free(act->args);
X  act->args = noargs;
X}
X
Xvoid
XProcessInput(ibuf, ilen)
Xchar *ibuf;
Xint ilen;
X{
X  char *s;
X  int slen;
X
X  while (display)
X    {
X      fore = d_fore;
X      slen = ilen;
X      s = ibuf;
X      while (ilen > 0)
X	{
X	  if (*s++ == Esc)
X	    break;
X	  ilen--;
X	}
X      slen -= ilen;
X      while (slen)
X	Process(&ibuf, &slen);
X      if (--ilen == 0)
X	d_ESCseen = 1;
X      if (ilen <= 0)
X	return;
X      DoAction(&ktab[(int)(unsigned char)*s], (int)(unsigned char)*s);
X      ibuf = s + 1;
X      ilen--;
X    }
X}
X
Xint
XFindCommnr(str)
Xchar *str;
X{
X  int x, m, l = 0, r = RC_LAST;
X  while (l <= r)
X    {
X      m = (l + r) / 2;
X      x = strcmp(str, comms[m].name);
X      if (x > 0)
X	l = m + 1;
X      else if (x < 0)
X	r = m - 1;
X      else
X	return m;
X    }
X  return RC_ILLEGAL;
X}
X
Xstatic int
XCheckArgNum(nr, args)
Xint nr;
Xchar **args;
X{
X  int i, n;
X  static char *argss[] = {"no", "one", "two", "three"};
X
X  n = comms[nr].flags & ARGS_MASK;
X  for (i = 0; args[i]; i++)
X    ;
X  if (comms[nr].flags & ARGS_ORMORE)
X    {
X      if (i < n)
X	{
X	  Msg(0, "%s: %s: at least %s argument%s required", rc_name, comms[nr].name, argss[n], n != 1 ? "s" : "");
X	  return -1;
X	}
X    }
X  else if (comms[nr].flags & ARGS_PLUSONE)
X    {
X      if (i != n && i != n + 1)
X	{
X	  Msg(0, "%s: %s: %s or %s argument%s required", rc_name, comms[nr].name, argss[n], argss[n + 1], n != 0 ? "s" : "");
X          return -1;
X	}
X    }
X  else if (i != n)
X    {
X      Msg(0, "%s: %s: %s argument%s required", rc_name, comms[nr].name, argss[n], n != 1 ? "s" : "");
X      return -1;
X    }
X  return 0;
X}
X
X/*ARGSUSED*/
Xvoid
XDoAction(act, key)
Xstruct action *act;
Xint key;
X{
X  int nr = act->nr;
X  char **args = act->args;
X  struct win *p;
X  int i, n, msgok;
X  char *s;
X  char ch;
X
X  if (nr == RC_ILLEGAL)
X    {
X      debug1("key '%c': No action\n", key);
X      return;
X    }
X  n = comms[nr].flags;
X  if ((n & NEED_DISPLAY) && display == 0)
X    {
X      Msg(0, "%s: %s: display required", rc_name, comms[nr].name);
X      return;
X    }
X  if ((n & NEED_FORE) && fore == 0)
X    {
X      Msg(0, "%s: %s: window required", rc_name, comms[nr].name);
X      return;
X    }
X  if (CheckArgNum(nr, args))
X    return;
X#ifdef MULTIUSER
X  if (multi && display)
X    {
X      if (AclCheckPermCmd(d_user, ACL_EXEC, &comms[nr]))
X	return;
X    }
X#endif /* MULTIUSER */
X  msgok = display && !*rc_name;
X  switch(nr)
X    {
X    case RC_SELECT:
X      if (!*args)
X        InputSelect();
X      else if (ParseWinNum(act, &n) == 0)
X        SwitchWindow(n);
X      break;
X#ifdef AUTO_NUKE
X    case RC_DEFAUTONUKE:
X      if (ParseOnOff(act, &defautonuke) == 0 && msgok)
X	Msg(0, "Default autonuke turned %s", defautonuke ? "on" : "off");
X      if (display && *rc_name)
X	d_auto_nuke = defautonuke;
X      break;
X    case RC_AUTONUKE:
X      if (ParseOnOff(act, &d_auto_nuke) == 0 && msgok)
X	Msg(0, "Autonuke turned %s", d_auto_nuke ? "on" : "off");
X      break;
X#endif
X    case RC_DUPLICATE:
X      if (!*args)
X	{
X	  if (fore->w_dupto >= 0)
X	    Msg(0, "Duplicating output to window %d", fore->w_dupto);
X	  else
X	    Msg(0, "No duplicate from here\n");
X	  break;
X	}
X      if (!strcmp(*args, "off"))
X        {
X	  fore->w_dupto = -1;
X	  break;
X	}
X      while (*args)
X        {
X	  n = WindowByNoN(*args++);
X          if (n < 0)
X	    {
X	      Msg(0, "Invalid window description");
X	      continue;
X	    }
X	  if ((p = wtab[n]) == 0)
X	    {
X	      Msg(0, "Window %d does not exist", n);
X	      continue;
X	    }
X	  for (nr = fore->w_number; wtab[nr] && wtab[nr]->w_dupto >= 0;nr = wtab[nr]->w_dupto)
X	    {
X	      if (wtab[nr]->w_dupto == n)
X		{
X		  Msg(0, "Cyclic dup detected\n");
X		  return;
X		}
X	    }
X	  wtab[n]->w_dupto = fore->w_number;
X	}
X      break;
X    case RC_DEFOBUFLIMIT:
X      if (ParseNum(act, &defobuflimit) == 0 && msgok)
X	Msg(0, "Default limit set to %d", defobuflimit);
X      if (display && *rc_name)
X	d_obufmax = defobuflimit;
X      break;
X    case RC_OBUFLIMIT:
X      if (*args == 0)
X	Msg(0, "Limit is %d, current buffer size is %d", d_obufmax, d_obuflen);
X      else if (ParseNum(act, &d_obufmax) == 0 && msgok)
X	Msg(0, "Limit set to %d", d_obufmax);
X      break;
X    case RC_DUMPTERMCAP:
X      WriteFile(DUMP_TERMCAP);
X      break;
X    case RC_HARDCOPY:
X      WriteFile(DUMP_HARDCOPY);
X      break;
X    case RC_LOG:
X      n = fore->w_logfp ? 1 : 0;
X      ParseSwitch(act, &n);
X      LogToggle(n);
X      break;
X#ifdef BSDJOBS
X    case RC_SUSPEND:
X      Detach(D_STOP);
X      break;
X#endif
X    case RC_NEXT:
X      if (MoreWindows())
X	SwitchWindow(NextWindow());
X      break;
X    case RC_PREV:
X      if (MoreWindows())
X	SwitchWindow(PreviousWindow());
X      break;
X    case RC_KILL:
X      {
X	char *name;
X
X	n = fore->w_number;
X#ifdef PSEUDOS
X	if (fore->w_pwin)
X	  {
X	    FreePseudowin(fore);
X#ifdef NETHACK
X	    if (nethackflag)
X	      Msg(0, "You have a sad feeling for a moment...");
X	    else
X#endif
X	    Msg(0, "Filter removed.");
X	    break;
X	  }
X#endif
X	name = SaveStr(fore->w_aka);
X	KillWindow(fore);
X#ifdef NETHACK
X	if (nethackflag)
X	  Msg(0, "You destroy poor window %d (%s).", n, name);
X	else
X#endif
X	Msg(0, "Window %d (%s) killed.", n, name);
X	if (name)
X	  free(name);
X	break;
X      }
X    case RC_QUIT:
X      Finit(0);
X      /* NOTREACHED */
X    case RC_DETACH:
X      Detach(D_DETACH);
X      break;
X#ifdef POW_DETACH
X    case RC_POW_DETACH:
X      if (key >= 0)
X	{
X	  static char buf[2];
X
X	  buf[0] = key;
X	  Input(buf, 1, pow_detach_fn, INP_RAW);
X	}
X      else
X        Detach(D_POWER); /* detach and kill Attacher's parent */
X      break;
X#endif
X#ifdef COPY_PASTE
X    case RC_COPY_REG:
X      if ((s = *args) == NULL)
X	{
X	  Input("Copy to register:", 1, copy_reg_fn, INP_RAW);
X	  break;
X	}
X      if ((s = ParseChar(s, &ch)) == NULL || *s)
X	{
X	  Msg(0, "%s: copy_reg: character, ^x, or (octal) \\032 expected.",
X	      rc_name);
X	  break;
X	}
X      copy_reg_fn(&ch, 0);
X      break;
X    case RC_INS_REG:
X      if ((s = *args) == NULL)
X	{
X	  Input("Insert from register:", 1, ins_reg_fn, INP_RAW);
X	  break;
X	}
X      if ((s = ParseChar(s, &ch)) == NULL || *s)
X	{
X	  Msg(0, "%s: ins_reg: character, ^x, or (octal) \\032 expected.",
X	      rc_name);
X	  break;
X	}
X      ins_reg_fn(&ch, 0);
X      break;
X#endif
X    case RC_REGISTER:
X      if ((s = ParseChar(*args, &ch)) == NULL || *s)
X	Msg(0, "%s: register: character, ^x, or (octal) \\032 expected.",
X	    rc_name);
X      else
X	{
X	  struct plop *plp = plop_tab + (int)(unsigned char)ch;
X
X	  if (plp->buf)
X	    free(plp->buf);
X	  plp->buf = SaveStr(args[1]);
X	  plp->len = strlen(args[1]);
X	}
X      break;
X    case RC_PROCESS:
X      if ((s = *args) == NULL)
X	{
X	  Input("Process register:", 1, process_fn, INP_RAW);
X	  break;
X	}
X      if ((s = ParseChar(s, &ch)) == NULL || *s)
X	{
X	  Msg(0, "%s: process: character, ^x, or (octal) \\032 expected.",
X	      rc_name);
X	  break;
X	}
X      process_fn(&ch, 0);
X      break;
X    case RC_REDISPLAY:
X      Activate(-1);
X      break;
X    case RC_WINDOWS:
X      ShowWindows();
X      break;
X    case RC_VERSION:
X      Msg(0, "screen %s", version);
X      break;
X    case RC_TIME:
X      ShowTime();
X      break;
X    case RC_INFO:
X      ShowInfo();
X      break;
X    case RC_OTHER:
X      if (MoreWindows())
X	SwitchWindow(d_other ? d_other->w_number : NextWindow());
X      break;
X    case RC_META:
X      ch = Esc;
X      s = &ch;
X      n = 1;
X      Process(&s, &n);
X      break;
X    case RC_XON:
X      ch = Ctrl('q');
X      s = &ch;
X      n = 1;
X      Process(&s, &n);
X      break;
X    case RC_XOFF:
X      ch = Ctrl('s');
X      s = &ch;
X      n = 1;
X      Process(&s, &n);
X      break;
X    case RC_POW_BREAK:
X    case RC_BREAK:
X      n = 0;
X      if (*args && ParseNum(act, &n))
X	break;
X      SendBreak(fore, n, nr == RC_POW_BREAK);
X      break;
X#ifdef LOCK
X    case RC_LOCKSCREEN:
X      Detach(D_LOCK);
X      break;
X#endif
X    case RC_WIDTH:
X      if (*args)
X	{
X	  if (ParseNum(act, &n))
X	    break;
X	}
X      else
X	{
X	  if (d_width == Z0width)
X	    n = Z1width;
X	  else if (d_width == Z1width)
X	    n = Z0width;
X	  else if (d_width > (Z0width + Z1width) / 2)
X	    n = Z0width;
X	  else
X	    n = Z1width;
X	}
X      if (n <= 0)
X        {
X	  Msg(0, "Illegal width");
X	  break;
X	}
X      if (n == d_width)
X	break;
X      if (ResizeDisplay(n, d_height) == 0)
X	{
X	  DoResize(d_width, d_height);
X	  Activate(d_fore ? d_fore->w_norefresh : 0);
X	}
X      else
X	Msg(0, "Your termcap does not specify how to change the terminal's width to %d.", n);
X      break;
X    case RC_HEIGHT:
X      if (*args)
X	{
X	  if (ParseNum(act, &n))
X	    break;
X	}
X      else
X	{
X#define H0height 42
X#define H1height 24
X	  if (d_height == H0height)
X	    n = H1height;
X	  else if (d_height == H1height)
X	    n = H0height;
X	  else if (d_height > (H0height + H1height) / 2)
X	    n = H0height;
X	  else
X	    n = H1height;
X	}
X      if (n <= 0)
X        {
X	  Msg(0, "Illegal height");
X	  break;
X	}
X      if (n == d_height)
X	break;
X      if (ResizeDisplay(d_width, n) == 0)
X	{
X	  DoResize(d_width, d_height);
X	  Activate(d_fore ? d_fore->w_norefresh : 0);
X	}
X      else
X	Msg(0, "Your termcap does not specify how to change the terminal's height to %d.", n);
X      break;
X    case RC_AKA:
X      if (*args == 0)
X	InputAKA();
X      else
X	ChangeAKA(fore, *args, 20);
X      break;
X    case RC_COLON:
X      InputColon();
X      break;
X    case RC_LASTMSG:
X      if (d_status_lastmsg)
X	Msg(0, "%s", d_status_lastmsg);
X      break;
X    case RC_SCREEN:
X      DoScreen("key", args);
X      break;
X    case RC_WRAP:
X      if (ParseSwitch(act, &fore->w_wrap) == 0 && msgok)
X        Msg(0, "%cwrap", fore->w_wrap ? '+' : '-');
X      break;
X    case RC_FLOW:
X      if (*args)
X	{
X	  if (args[0][0] == 'a')
X	    {
X	      fore->w_flow = (fore->w_flow & FLOW_AUTO) ? FLOW_AUTOFLAG |FLOW_AUTO|FLOW_NOW : FLOW_AUTOFLAG;
X	    }
X	  else
X	    {
X	      if (ParseOnOff(act, &n))
X		break;
X	      fore->w_flow = (fore->w_flow & FLOW_AUTO) | n;
X	    }
X	}
X      else
X	{
X	  if (fore->w_flow & FLOW_AUTOFLAG)
X	    fore->w_flow = (fore->w_flow & FLOW_AUTO) | FLOW_NOW;
X	  else if (fore->w_flow & FLOW_NOW)
X	    fore->w_flow &= ~FLOW_NOW;
X	  else
X	    fore->w_flow = fore->w_flow ? FLOW_AUTOFLAG|FLOW_AUTO|FLOW_NOW : FLOW_AUTOFLAG;
X	}
X      SetFlow(fore->w_flow & FLOW_NOW);
X      if (msgok)
X	Msg(0, "%cflow%s", (fore->w_flow & FLOW_NOW) ? '+' : '-',
X	    (fore->w_flow & FLOW_AUTOFLAG) ? "(auto)" : "");
X      break;
X    case RC_WRITELOCK:
X      if (*args)
X	{
X	  if (args[0][0] == 'a')
X	    {
X	      fore->w_wlock = WLOCK_AUTO;
X	    }
X	  else
X	    {
X	      if (ParseOnOff(act, &n))
X		break;
X	      fore->w_wlock = n ? WLOCK_ON : WLOCK_OFF;
X	    }
X	}
X      fore->w_wlockuser = d_user;
X      Msg(0, "writelock %s", (fore->w_wlock == WLOCK_AUTO) ? "auto" :
X	  ((fore->w_wlock == WLOCK_OFF) ? "off" : "on"));
X      break;
X    case RC_CLEAR:
X      if (fore->w_state == LIT)
X	WriteString(fore, "\033[H\033[J", 6);
X      break;
X    case RC_RESET:
X      if (fore->w_state == LIT)
X	WriteString(fore, "\033c", 2);
X      break;
X    case RC_MONITOR:
X      n = fore->w_monitor == MON_ON;
X      if (ParseSwitch(act, &n))
X	break;
X      if (n)
X	{
X	  fore->w_monitor = MON_ON;
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "You feel like someone is watching you...");
X	  else
X#endif
X	    Msg(0, "Window %d (%s) is now being monitored for all activity.", 
X		fore->w_number, fore->w_aka);
X	}
X      else
X	{
X	  fore->w_monitor = MON_OFF;
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "You no longer sense the watcher's presence.");
X	  else
X#endif
X	    Msg(0, "Window %d (%s) is no longer being monitored for activity.", 
X		fore->w_number, fore->w_aka);
X	}
X      break;
X    case RC_HELP:
X      display_help();
X      break;
X    case RC_LICENSE:
X      display_copyright();
X      break;
X#ifdef COPY_PASTE
X    case RC_COPY:
X      if (d_layfn != &WinLf)
X	{
X	  Msg(0, "Must be on a window layer");
X	  break;
X	}
X      MarkRoutine();
X      break;
X    case RC_HISTORY:
X      if (d_layfn != &WinLf)
X	{
X	  Msg(0, "Must be on a window layer");
X	  break;
X	}
X      if (GetHistory())
X	if (d_copybuffer != NULL)
X	  {
X	    fore->w_pastebuffer = d_copybuffer;
X	    fore->w_pastelen = d_copylen;
X	  }
X      break;
X    case RC_PASTE:
X      if (d_copybuffer == NULL)
X	{
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "Nothing happens.");
X	  else
X#endif
X	  Msg(0, "empty buffer");
X	  break;
X	}
X      fore->w_pastebuffer = d_copybuffer;
X      fore->w_pastelen = d_copylen;
X      break;
X    case RC_WRITEBUF:
X      if (d_copybuffer == NULL)
X	{
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "Nothing happens.");
X	  else
X#endif
X	  Msg(0, "empty buffer");
X	  break;
X	}
X      WriteFile(DUMP_EXCHANGE);
X      break;
X    case RC_READBUF:
X      ReadFile();
X      break;
X    case RC_REMOVEBUF:
X      KillBuffers();
X      break;
X#endif				/* COPY_PASTE */
X    case RC_ESCAPE:
X      FreeKey((int)(unsigned char)Esc);
X      FreeKey((int)(unsigned char)MetaEsc);
X      if (ParseEscape(*args))
X	{
X	  Msg(0, "%s: two characters required after escape.", rc_name);
X	  break;
X	}
X      FreeKey((int)(unsigned char)Esc);
X      FreeKey((int)(unsigned char)MetaEsc);
X      ktab[(int)(unsigned char)Esc].nr = RC_OTHER;
X      ktab[(int)(unsigned char)MetaEsc].nr = RC_META;
X      break;
X    case RC_CHDIR:
X      s = *args ? *args : home;
X      if (chdir(s) == -1)
X	Msg(errno, "%s", s);
X      break;
X    case RC_SHELL:
X      if (ParseSaveStr(act, &ShellProg) == 0)
X        ShellArgs[0] = ShellProg;
X      break;
X    case RC_HARDCOPYDIR:
X      (void)ParseSaveStr(act, &hardcopydir);
X      break;
X    case RC_LOGDIR:
X      (void)ParseSaveStr(act, &screenlogdir);
X      break;
X    case RC_SHELLAKA:
X      (void)ParseSaveStr(act, &nwin_default.aka);
X      break;
X    case RC_SLEEP:
X    case RC_TERMCAP:
X    case RC_TERMINFO:
X      break;			/* Already handled */
X    case RC_TERM:
X      s = NULL;
X      if (ParseSaveStr(act, &s))
X	break;
X      if (strlen(s) >= 20)
X	{
X	  Msg(0,"%s: term: argument too long ( < 20)", rc_name);
X	  free(s);
X	  break;
X	}
X      strcpy(screenterm, s);
X      free(s);
X      debug1("screenterm set to %s\n", screenterm);
X      MakeTermcap(display == 0);
X      debug("new termcap made\n");
X      break;
X    case RC_ECHO:
X      if (msgok)
X	{
X	  /*
X	   * d_user typed ^A:echo... well, echo isn't FinishRc's job,
X	   * but as he wanted to test us, we show good will
X	   */
X	  if (*args && (args[1] == 0 || (strcmp(args[1], "-n") == 0 && args[2] == 0)))
X	    Msg(0, "%s", args[1] ? args[1] : *args);
X	  else
X 	    Msg(0, "%s: 'echo [-n] \"string\"' expected.", rc_name);
X	}
X      break;
X    case RC_BELL:
X      (void)ParseSaveStr(act, &BellString);
X      break;
X#ifdef COPY_PASTE
X    case RC_BUFFERFILE:
X      if (*args == 0)
X	BufferFile = SaveStr(DEFAULT_BUFFERFILE);
X      else if (ParseSaveStr(act, &BufferFile))
X        break;
X      if (msgok)
X        Msg(0, "Bufferfile is now '%s'\n", BufferFile);
X      break;
X#endif
X    case RC_ACTIVITY:
X      (void)ParseSaveStr(act, &ActivityString);
X      break;
X#ifdef POW_DETACH
X    case RC_POW_DETACH_MSG:
X      (void)ParseSaveStr(act, &PowDetachString);
X      break;
X#endif
X#ifdef UTMPOK
X    case RC_DEFLOGIN:
X      (void)ParseOnOff(act, &nwin_default.lflag);
X      break;
X    case RC_LOGIN:
X      n = fore->w_slot != (slot_t)-1;
X      if (ParseSwitch(act, &n) == 0)
X        SlotToggle(n);
X      break;
X#endif
X    case RC_DEFFLOW:
X      if (args[0] && args[1] && args[1][0] == 'i')
X	{
X	  iflag = 1;
X	  if ((intrc == VDISABLE) && (origintrc != VDISABLE))
X	    {
X#if defined(TERMIO) || defined(POSIX)
X	      intrc = d_NewMode.tio.c_cc[VINTR] = origintrc;
X	      d_NewMode.tio.c_lflag |= ISIG;
X#else /* TERMIO || POSIX */
X	      intrc = d_NewMode.m_tchars.t_intrc = origintrc;
X#endif /* TERMIO || POSIX */
X
X	      if (display)
X		SetTTY(d_userfd, &d_NewMode);
X	    }
X	}
X      if (args[0] && args[0][0] == 'a')
X	nwin_default.flowflag = FLOW_AUTOFLAG;
X      else
X	(void)ParseOnOff(act, &nwin_default.flowflag);
X      break;
X    case RC_DEFWRAP:
X      (void)ParseOnOff(act, &default_wrap);
X      break;
X    case RC_HARDSTATUS:
X      RemoveStatus();
X      (void)ParseSwitch(act, &use_hardstatus);
X      break;
X    case RC_DEFMONITOR:
X      if (ParseOnOff(act, &n) == 0)
X        default_monitor = (n == 0) ? MON_OFF : MON_ON;
X      break;
X    case RC_CONSOLE:
X      n = (console_window != 0);
X      if (ParseSwitch(act, &n))
X        break;
X      if (TtyGrabConsole(fore->w_ptyfd, n, rc_name))
X	break;
X      if (n == 0)
X	  Msg(0, "%s: releasing console %s", rc_name, HostName);
X      else if (console_window)
X	  Msg(0, "%s: stealing console %s from window %d (%s)", rc_name, 
X	      HostName, console_window->w_number, console_window->w_aka);
X      else
X	  Msg(0, "%s: grabbing console %s", rc_name, HostName);
X      console_window = n ? fore : 0;
X      break;
X    case RC_ALLPARTIAL:
X      if (ParseOnOff(act, &all_norefresh))
X	break;
X      if (all_norefresh)
X	Msg(0, "No refresh on window change!\n");
X      else
X	{
X	  if (fore)
X	    Activate(-1);
X	  Msg(0, "Window specific refresh\n");
X	}
X      break;
X    case RC_PARTIAL:
X      (void)ParseSwitch(act, &n);
X      fore->w_norefresh = n;
X      break;
X    case RC_VBELL:
X      if (ParseSwitch(act, &visual_bell) || !msgok)
X        break;
X      if (visual_bell == 0)
X	{
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "Suddenly you can't see your bell!");
X	  else
X#endif
X	  Msg(0, "switched to audible bell.");
X	}
X      else
X	{
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "Your bell is no longer invisible.");
X	  else
X#endif
X	  Msg(0, "switched to visual bell.");
X	}
X      break;
X    case RC_VBELLWAIT:
X      if (ParseNum(act, &VBellWait) == 0 && msgok)
X        Msg(0, "vbellwait set to %d seconds", VBellWait);
X      break;
X    case RC_MSGWAIT:
X      if (ParseNum(act, &MsgWait) == 0 && msgok)
X        Msg(0, "msgwait set to %d seconds", MsgWait);
X      break;
X    case RC_MSGMINWAIT:
X      if (ParseNum(act, &MsgMinWait) == 0 && msgok)
X        Msg(0, "msgminwait set to %d seconds", MsgMinWait);
X      break;
X    case RC_SILENCEWAIT:
X      if ((ParseNum(act, &SilenceWait) == 0) && msgok)
X        {
X	  if (SilenceWait < 1)
X	    SilenceWait = 1;
X	  for (p = windows; p; p = p->w_next)
X	    if (p->w_tstamp.seconds)
X	      p->w_tstamp.seconds = SilenceWait;
X	  Msg(0, "silencewait set to %d seconds", SilenceWait);
X	}
X      break;
X    case RC_NUMBER:
X      if (*args == 0)
X        Msg(0, "This is window %d (%s).\n", fore->w_number, fore->w_aka);
X      else
X        {
X	  int old = fore->w_number;
X
X	  if (ParseNum(act, &n) || n >= MAXWIN)
X	    break;
X	  p = wtab[n];
X	  wtab[n] = fore;
X	  fore->w_number = n;
X	  wtab[old] = p;
X	  if (p)
X	    p->w_number = old;
X#ifdef MULTIUSER
X	  AclWinSwap(old, n);
X#endif
X	}
X      break;
X    case RC_SILENCE:
X      n = fore->w_tstamp.seconds != 0;
X      i = SilenceWait;
X      if (args[0] && 
X          (args[0][0] == '-' || (args[0][0] >= '0' && args[0][0] <= '9')))
X        {
X	  if (ParseNum(act, &i))
X	    break;
X	  n = i;
X	}
X      else if (ParseSwitch(act, &n))
X        break;
X      if (n)
X        {
X	  fore->w_tstamp.lastio = time(0);
X	  fore->w_tstamp.seconds = i;
X	  if (!msgok)
X	    break;
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "You feel like someone is waiting for %d sec. silence...",
X	        fore->w_tstamp.seconds);
X	  else
X#endif
X	    Msg(0, "Window %d (%s) is now being monitored for %d sec. silence.",
X	    	fore->w_number, fore->w_aka, fore->w_tstamp.seconds);
X	}
X      else
X        {
X	  fore->w_tstamp.lastio = (time_t)0;
X	  fore->w_tstamp.seconds = 0;
X	  if (!msgok)
X	    break;
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "You no longer sense the watcher's silence.");
X	  else
X#endif
X	    Msg(0, "Window %d (%s) is no longer being monitored for silence.", 
X		fore->w_number, fore->w_aka);
X	}
X      break;
X#ifdef COPY_PASTE
X    case RC_DEFSCROLLBACK:
X      (void)ParseNum(act, &nwin_default.histheight);
X      break;
X    case RC_SCROLLBACK:
X      (void)ParseNum(act, &n);
X      ChangeScrollback(fore, n, d_width);
X      if (msgok)
X	Msg(0, "scrollback set to %d", fore->w_histheight);
X      break;
X#endif
X    case RC_SESSIONNAME:
X      if (*args == 0)
X	Msg(0, "This session is named '%s'\n", SockNamePtr);
X      else
X	{
X	  char buf[MAXPATHLEN];
X
X	  s = NULL;
X	  if (ParseSaveStr(act, &s))
X	    break;
X	  if (!*s || strlen(s) > MAXPATHLEN - 13)
X	    {
X	      Msg(0, "%s: bad session name '%s'\n", rc_name, s);
X	      free(s);
X	      break;
X	    }
X	  sprintf(buf, "%s", SockPath);
X	  sprintf(buf + (SockNamePtr - SockPath), "%d.%s", getpid(), s); 
X	  free(s);
X	  if ((access(buf, F_OK) == 0) || (errno != ENOENT))
X	    {
X	      Msg(0, "%s: inappropriate path: '%s'.", rc_name, buf);
X	      break;
X	    }
X	  if (rename(SockPath, buf))
X	    {
X	      Msg(errno, "%s: failed to rename(%s, %s)", rc_name, SockPath, buf);
X	      break;
X	    }
X	  debug2("rename(%s, %s) done\n", SockPath, buf);
X	  sprintf(SockPath, "%s", buf);
X	  MakeNewEnv();
X	}
X      break;
X    case RC_SETENV:
X#ifndef USESETENV
X	{
X	  char *buf;
X	  int l;
X
X	  if ((buf = (char *)malloc((l = strlen(args[0])) + 
X				     strlen(args[1]) + 2)) == NULL)
X	    {
X	      Msg(0, strnomem);
X	      break;
X	    }
X	  strcpy(buf, args[0]);
X	  buf[l] = '=';
X	  strcpy(buf + l + 1, args[1]);
X	  putenv(buf);
X# ifdef NEEDPUTENV
X	  /*
X	   * we use our own putenv(), knowing that it does a malloc()
X	   * the string space, we can free our buf now. 
X	   */
X	  free(buf);
X# else /* NEEDSETENV */
X	  /*
X	   * For all sysv-ish systems that link a standard putenv() 
X	   * the string-space buf is added to the environment and must not
X	   * be freed, or modified.
X	   * We are sorry to say that memory is lost here, when setting 
X	   * the same variable again and again.
X	   */
X# endif /* NEEDSETENV */
X	}
X#else /* USESETENV */
X# if defined(linux) || defined(__386BSD__) || defined(BSDI)
X      setenv(args[0], args[1], 0);
X# else
X      setenv(args[0], args[1]);
X# endif /* linux || __386BSD__ || BSDI */
X#endif /* USESETENV */
X      MakeNewEnv();
X      break;
X    case RC_UNSETENV:
X      unsetenv(*args);
X      MakeNewEnv();
X      break;
X    case RC_SLOWPASTE:
X      if (ParseNum(act, &slowpaste) == 0 && msgok)
X	Msg(0, "slowpaste set to %d milliseconds", slowpaste);
X      break;
X#ifdef COPY_PASTE
X    case RC_MARKKEYS:
X      s = NULL;
X      if (ParseSaveStr(act, &s))
X        break;
X      if (CompileKeys(s, mark_key_tab))
X	{
X	  Msg(0, "%s: markkeys: syntax error.", rc_name);
X	  free(s);
X	  break;
X	}
X      debug1("markkeys %s\n", *args);
X      free(s);
X      break;
X#endif
X#ifdef NETHACK
X    case RC_NETHACK:
X      (void)ParseOnOff(act, &nethackflag);
X      break;
X#endif
X    case RC_HARDCOPY_APPEND:
X      (void)ParseOnOff(act, &hardcopy_append);
X      break;
X    case RC_VBELL_MSG:
X      (void)ParseSaveStr(act, &VisualBellString);
X      debug1(" new vbellstr '%s'\n", VisualBellString);
X      break;
X    case RC_DEFMODE:
X      if (ParseOct(act, &n))
X        break;
X      if (n < 0 || n > 0777)
X	{
X	  Msg(0, "%s: mode: Invalid tty mode %o", rc_name, n);
X          break;
X	}
X      TtyMode = n;
X      if (msgok)
X	Msg(0, "Ttymode set to %03o", TtyMode);
X      break;
X#ifdef COPY_PASTE
X    case RC_CRLF:
X      (void)ParseOnOff(act, &join_with_cr);
X      break;
X#endif
X    case RC_AUTODETACH:
X      (void)ParseOnOff(act, &auto_detach);
X      break;
X    case RC_STARTUP_MESSAGE:
X      (void)ParseOnOff(act, &default_startup);
X      break;
X#ifdef PASSWORD
X    case RC_PASSWORD:
X      CheckPassword = 1;
X      if (*args)
X	{
X	  strncpy(Password, *args, sizeof(Password) - 1);
X	  if (!strcmp(Password, "none"))
X	    CheckPassword = 0;
X	}
X      else
X	{
X	  if (display == 0)
X	    {
X	      debug("prompting for password on no display???\n");
X	      break;
X	    }
X	  Input("New screen password:", sizeof(Password) - 1, pass1, 
X		INP_NOECHO);
X	}
X      break;
X#endif				/* PASSWORD */
X    case RC_BIND:
X      if ((s = ParseChar(*args, &ch)) == NULL || *s)
X	{
X	  Msg(0, "%s: bind: character, ^x, or (octal) \\032 expected.",
X	      rc_name);
X	  break;
X	}
X      n = (unsigned char)ch;
X      FreeKey(n);
X      if (args[1])
X	{
X	  if ((i = FindCommnr(args[1])) == RC_ILLEGAL)
X	    {
X	      Msg(0, "%s: bind: unknown command '%s'", rc_name, args[1]);
X	      break;
X	    }
X	  if (CheckArgNum(i, args + 2))
X	    break;
X	  ktab[n].nr = i;
X	  if (args[2])
X	    ktab[n].args = SaveArgs(args + 2);
X	}
X      break;
X#ifdef MULTIUSER
X    case RC_ACLCHG:
X    case RC_ACLADD:
X	{
X	  struct user **u;
X	  
X	  u = FindUserPtr(args[0]);
X	  UserAdd(args[0], NULL, u);
X	  if (args[1] && args[2])
X	    AclSetPerm(*u, args[1], args[2]);
X	  else
X	    AclSetPerm(*u, "+rwx", "#?"); 
X	  break;
X	}
X    case RC_ACLDEL:
X        {
X	  if (UserDel(args[0], NULL))
X	    break;
X	  if (msgok)
X	    Msg(0, "%s removed from acl database", args[0]);
X	  break;
X        }
X    case RC_ACLGRP:
X        {
X	  break;
X	}
X    case RC_MULTIUSER:
X      if (ParseOnOff(act, &n))
X	break;
X      multi = n ? "" : 0;
X      chsock();
X      if (msgok)
X	Msg(0, "Multiuser mode %s", multi ? "enabled" : "disabled");
X      break;
X#endif /* MULTIUSER */
X#ifdef PSEUDOS
X    case RC_EXEC:
X      winexec(args);
X      break;
X#endif
X#ifdef MULTI
X    case RC_CLONE:
X      execclone(args);
X      break;
X#endif
X    default:
X      break;
X    }
X}
X
Xstatic char **
XSaveArgs(args)
Xchar **args;
X{
X  register char **ap, **pp;
X  register int argc = 0;
X
X  while (args[argc])
X    argc++;
X  if ((pp = ap = (char **) malloc((unsigned) (argc + 1) * sizeof(char **))) == 0)
X    Panic(0, strnomem);
X  while (argc--)
X    {
X      *pp++ = SaveStr(*args++);
X    }
X  *pp = 0;
X  return ap;
X}
X
Xint 
XParse(buf, args)
Xchar *buf, **args;
X{
X  register char *p = buf, **ap = args;
X  register int delim, argc;
X
X  argc = 0;
X  for (;;)
X    {
X      while (*p && (*p == ' ' || *p == '\t'))
X	++p;
X#ifdef PSEUDOS
X      if (argc == 0 && (*p == '!' || *p == '|'))
X	{
X	  *ap++ = "exec";
X	  if (*p == '!')
X	    p++;
X	  while (*p == ' ')
X	    p++;
X	  argc++;
X	}
X#endif
X      if (*p == '\0' || *p == '#')
X	{
X	  *p = '\0';
X	  args[argc] = 0;
X	  return argc;
X	}
X      if (++argc >= MAXARGS)
X	{
X	  Msg(0, "%s: too many tokens.", rc_name);
X	  return 0;
X	}
X      delim = 0;
X      if (*p == '"' || *p == '\'')
X	delim = *p++;
X      *ap++ = p;
X      while (*p && !(delim ? *p == delim : (*p == ' ' || *p == '\t')))
X	++p;
X      if (*p == '\0')
X	{
X	  if (delim)
X	    {
X	      Msg(0, "%s: Missing quote.", rc_name);
X	      return 0;
X	    }
X	}
X      else
X        *p++ = '\0';
X    }
X}
X
Xint 
XParseEscape(p)
Xchar *p;
X{
X  if ((p = ParseChar(p, &Esc)) == NULL ||
X      (p = ParseChar(p, &MetaEsc)) == NULL || *p)
X    return -1;
X  return 0;
X}
X
Xstatic int
XParseSwitch(act, var)
Xstruct action *act;
Xint *var;
X{
X  if (*act->args == 0)
X    {
X      *var ^= 1;
X      return 0;
X    }
X  return ParseOnOff(act, var);
X}
X
Xstatic int
XParseOnOff(act, var)
Xstruct action *act;
Xint *var;
X{
X  register int num = -1;
X  char **args = act->args;
X
X  if (args[1] == 0)
X    {
X      if (strcmp(args[0], "on") == 0)
X	num = 1;
X      else if (strcmp(args[0], "off") == 0)
X	num = 0;
X    }
X  if (num < 0)
X    {
X      Msg(0, "%s: %s: invalid argument. Give 'on' or 'off'", rc_name, comms[act->nr].name);
X      return -1;
X    }
X  *var = num;
X  return 0;
X}
X
Xstatic int
XParseSaveStr(act, var)
Xstruct action *act;
Xchar **var;
X{
X  char **args = act->args;
X  if (*args == 0 || args[1])
X    {
X      Msg(0, "%s: %s: one argument required.", rc_name, comms[act->nr].name);
X      return -1;
X    }
X  if (*var)
X    free(*var);
X  *var = SaveStr(*args);
X  return 0;
X}
X
Xstatic int
XParseNum(act, var)
Xstruct action *act;
Xint *var;
X{
X  int i;
X  char *p, **args = act->args;
X
X  p = *args;
X  if (p == 0 || *p == 0 || args[1])
X    {
X      Msg(0, "%s: %s: invalid argument. Give one argument.",
X          rc_name, comms[act->nr].name);
X      return -1;
X    }
X  i = 0; 
X  while (*p)
X    {
X      if (*p >= '0' && *p <= '9')
X	i = 10 * i + (*p - '0');
X      else
X	{
X	  Msg(0, "%s: %s: invalid argument. Give numeric argument.",
X	      rc_name, comms[act->nr].name);
X	  return -1;
X	}    
X      p++;
X    }
X  debug1("ParseNum got %d\n", i);
X  *var = i;
X  return 0;
X}
X
Xstatic struct win *
XWindowByName(s)
Xchar *s;
X{
X  struct win *p;
X
X  for (p = windows; p; p = p->w_next)
X    if (!strncmp(p->w_aka, s, strlen(s)))
X      return p;
X  return NULL;
X}
X
X/* 
X * Get window number from Name or Number string.
X * Numbers are tried first, then names, a prefix match suffices.
X * Be careful when assigning numeric strings as WindowTitles.
X */
Xint
XWindowByNoN(str)
Xchar *str;
X{
X  int i;
X  char *s;
X  struct win *p;
X  
X  for (i = 0, s = str; *s; s++)
X    {
X      if (*s < '0' || *s > '9')
X	break;
X      i = i * 10 + (*s - '0');
X    }
X  if (*s || i < 0 || i >= MAXWIN)
X    {
X      if ((p = WindowByName(str)))
X	return p->w_number;
X      return -1;
X    }
X  return i;
X}
X
Xstatic int
XParseWinNum(act, var)
Xstruct action *act;
Xint *var;
X{
X  char **args = act->args;
X  int i = 0;
X
X  if (*args == 0 || args[1])
X    {
X      Msg(0, "%s: %s: one argument required.", rc_name, comms[act->nr].name);
X      return -1;
X    }
X  
X  i = WindowByNoN(*args);
X  if (i < 0)
X    {
X      Msg(0, "%s: %s: invalid argument. Give window number or name.",
X          rc_name, comms[act->nr].name);
X      return -1;
X    }
X  debug1("ParseWinNum got %d\n", i);
X  *var = i;
X  return 0;
X}
X
Xstatic int
XParseOct(act, var)
Xstruct action *act;
Xint *var;
X{
X  char *p, **args = act->args;
X  int i = 0; 
X
X  p = *args;
X  if (p == 0 || *p == 0 || args[1])
X    {
X      Msg(0, "%s: %s: invalid argument. Give one octal argument.",
X          rc_name, comms[act->nr].name);
X      return -1;
X    }
X  while (*p)
X    {
X      if (*p >= '0' && *p <= '7')
X	i = 8 * i + (*p - '0');
X      else
X	{
X	  Msg(0, "%s: %s: invalid argument. Give octal argument.",
X	      rc_name, comms[act->nr].name);
X	  return -1;
X	}    
X      p++;
X    }
X  debug1("ParseOct got %d\n", i);
X  *var = i;
X  return 0;
X}
X
Xstatic char *
XParseChar(p, cp)
Xchar *p, *cp;
X{
X  if (*p == 0)
X    return 0;
X  if (*p == '^')
X    {
X      if (*++p == '?')
X        *cp = '\177';
X      else if (*p >= '@')
X        *cp = Ctrl(*p);
X      else
X        return 0;
X      ++p;
X    }
X  else if (*p == '\\' && *++p <= '7' && *p >= '0')
X    {
X      *cp = 0;
X      do
X        *cp = *cp * 8 + *p - '0';
X      while (*++p <= '7' && *p >= '0');
X    }
X  else
X    *cp = *p++;
X  return p;
X}
X
X
Xstatic
Xint IsNum(s, base)
Xregister char *s;
Xregister int base;
X{
X  for (base += '0'; *s; ++s)
X    if (*s < '0' || *s > base)
X      return 0;
X  return 1;
X}
X
Xstatic int
XIsNumColon(s, base, p, psize)
Xint base, psize;
Xchar *s, *p;
X{
X  char *q;
X  if ((q = rindex(s, ':')) != NULL)
X    {
X      strncpy(p, q + 1, psize - 1);
X      p[psize - 1] = '\0';
X      *q = '\0';
X    }
X  else
X    *p = '\0';
X  return IsNum(s, base);
X}
X
Xstatic void
XSwitchWindow(n)
Xint n;
X{
X  struct win *p;
X
X  debug1("SwitchWindow %d\n", n);
X  if (display == 0)
X    return;
X  if (n < 0 || n >= MAXWIN || (p = wtab[n]) == 0)
X    {
X      ShowWindows();
X      return;
X    }
X  if (p == d_fore)
X    {
X      Msg(0, "This IS window %d (%s).", n, p->w_aka);
X      return;
X    }
X  if (p->w_display)
X    {
X      Msg(0, "Window %d (%s) is on another display.", n, p->w_aka);
X      return;
X    }
X  SetForeWindow(p);
X  Activate(fore->w_norefresh);  
X}  
X
Xvoid
XSetForeWindow(wi)
Xstruct win *wi;
X{
X  struct win *p, **pp;
X  struct layer *l;
X  /*
X   * If we come from another window, make it inactive.
X   */
X  if (display)
X    {
X      fore = d_fore;
X      if (fore)
X	{
X	  /* release auto writelock when user has no other display here */
X	  if (fore->w_wlock == WLOCK_AUTO && fore->w_wlockuser == d_user)
X	    {
X	      struct display *d;
X
X	      for (d = displays; d; d = d->_d_next)
X	        if (( d != display) && (d->_d_fore == fore))
X		  break;
X	      debug3("%s %s autolock on win %d\n", 
X	             d_user->u_name, d?"keeps":"releases", fore->w_number);
X	      if (!d)
X	        fore->w_wlockuser = NULL;
X	    }
X	  /* deactivate old window. */
X	  if (fore->w_tstamp.seconds)
X	    fore->w_tstamp.lastio = Now;
X	  d_other = fore;
X	  fore->w_active = 0;
X	  fore->w_display = 0;
X	}
X      else
X	{
X	  /* put all the display layers on the window. */
X	  for (l = d_lay; l; l = l->l_next)
X	    if (l->l_next == &BlankLayer)
X	      {
X		l->l_next = wi->w_lay;
X		wi->w_lay = d_lay;
X		for (l = d_lay; l != wi->w_lay; l = l->l_next)
X		  l->l_block |= wi->w_lay->l_block;
X		break;
X	      }
X	}
X      d_fore = wi;
X      if (d_other == wi)
X	d_other = 0;
X      d_lay = wi->w_lay;
X      d_layfn = d_lay->l_layfn;
X      if ((wi->w_wlock == WLOCK_AUTO) && !wi->w_wlockuser)
X        {
X	  debug2("%s obtained auto writelock for window %d\n",
X	  	 d_user->u_name, wi->w_number);
X          wi->w_wlockuser = d_user;
X        }
X    }
X  fore = wi;
X  fore->w_display = display;
X  if (!fore->w_lay)
X    fore->w_active = 1;
X  /*
X   * Place the window at the head of the most-recently-used list.
X   */
X  for (pp = &windows; (p = *pp); pp = &p->w_next)
X    if (p == wi)
X      break;
X  ASSERT(p);
X  *pp = p->w_next;
X  p->w_next = windows;
X  windows = p;
X}
X
Xstatic int
XNextWindow()
X{
X  register struct win **pp;
X  int n = fore ? fore->w_number : 0;
X
X  for (pp = wtab + n + 1; pp != wtab + n; pp++)
X    {
X      if (pp == wtab + MAXWIN)
X	pp = wtab;
X      if (*pp)
X	break;
X    }
X  return pp - wtab;
X}
X
Xstatic int
XPreviousWindow()
X{
X  register struct win **pp;
X  int n = fore ? fore->w_number : MAXWIN - 1;
X
X  for (pp = wtab + n - 1; pp != wtab + n; pp--)
X    {
X      if (pp < wtab)
X	pp = wtab + MAXWIN - 1;
X      if (*pp)
X	break;
X    }
X  return pp - wtab;
X}
X
Xstatic int
XMoreWindows()
X{
X  if (windows && windows->w_next)
X    return 1;
X  if (fore == 0)
X    {
X      Msg(0, "No window available");
X      return 0;
X    }
X#ifdef NETHACK
X  if (nethackflag)
X    Msg(0, "You cannot escape from window %d!", fore->w_number);
X  else
X#endif
X  Msg(0, "No other window.");
X  return 0;
X}
X
Xvoid
XKillWindow(wi)
Xstruct win *wi;
X{
X  struct win **pp, *p;
X
X  display = wi->w_display;
X  if (display)
X    {
X      if (wi == d_fore)
X	{
X	  RemoveStatus();
X	  if (d_lay != &wi->w_winlay)
X	    ExitOverlayPage();
X	  d_fore = 0;
X	  d_lay = &BlankLayer;
X	  d_layfn = BlankLayer.l_layfn;
X	}
X    }
X
X  for (pp = &windows; (p = *pp); pp = &p->w_next)
X    if (p == wi)
X      break;
X  ASSERT(p);
X  *pp = p->w_next;
X  /*
X   * Remove window from linked list.
X   */
X  wi->w_inlen = 0;
X  wtab[wi->w_number] = 0;
X  FreeWindow(wi);
X  /*
X   * If the foreground window disappeared check the head of the linked list
X   * of windows for the most recently used window. If no window is alive at
X   * all, exit.
X   */
X  if (display && d_fore)
X    return;
X  if (windows == 0)
X    Finit(0);
X  SwitchWindow(windows->w_number);
X}
X
Xstatic void
XLogToggle(on)
Xint on;
X{
X  char buf[1024];
X
X  if ((fore->w_logfp != 0) == on)
X    {
X      if (display && !*rc_name)
X	Msg(0, "You are %s logging.", on ? "already" : "not");
X      return;
X    }
X  if (screenlogdir)
X    sprintf(buf, "%s/screenlog.%d", screenlogdir, fore->w_number);
X  else
X    sprintf(buf, "screenlog.%d", fore->w_number);
X  if (fore->w_logfp != NULL)
X    {
X#ifdef NETHACK
X      if (nethackflag)
X	Msg(0, "You put away your scroll of logging named \"%s\".", buf);
X      else
X#endif
X      Msg(0, "Logfile \"%s\" closed.", buf);
X      fclose(fore->w_logfp);
X      fore->w_logfp = NULL;
X      return;
X    }
X  if ((fore->w_logfp = secfopen(buf, "a")) == NULL)
X    {
X#ifdef NETHACK
X      if (nethackflag)
X	Msg(0, "You don't seem to have a scroll of logging named \"%s\".", buf);
X      else
X#endif
X      Msg(errno, "Error opening logfile \"%s\"", buf);
X      return;
X    }
X#ifdef NETHACK
X  if (nethackflag)
X    Msg(0, "You %s your scroll of logging named \"%s\".",
X	ftell(fore->w_logfp) ? "add to" : "start writing on", buf);
X  else
X#endif
X  Msg(0, "%s logfile \"%s\"", ftell(fore->w_logfp) ? "Appending to" : "Creating", buf);
X}
X
Xvoid
XShowWindows()
X{
X  char buf[1024];
X  register char *s, *ss;
X  register struct win **pp, *p;
X  register char *cmd;
X
X  ASSERT(display);
X  s = ss = buf;
X  for (pp = wtab; pp < wtab + MAXWIN; pp++)
X    {
X      if ((p = *pp) == 0)
X	continue;
X
X      cmd = p->w_aka;
X      if (s - buf + strlen(cmd) > sizeof(buf) - 6)
X	break;
X      if (s > buf)
X	{
X	  *s++ = ' ';
X	  *s++ = ' ';
X	}
X      sprintf(s, "%d", p->w_number);
X      s += strlen(s);
X      if (p == fore)
X	{
X	  ss = s;
X	  *s++ = '*';
X	}
X      else if (p == d_other)
X	*s++ = '-';
X      if (p->w_display && p->w_display != display)
X	*s++ = '&';
X      if (p->w_monitor == MON_DONE || p->w_monitor == MON_MSG)
X	*s++ = '@';
X      if (p->w_bell == BELL_DONE || p->w_bell == BELL_MSG)
X	*s++ = '!';
X#ifdef UTMPOK
X      if (p->w_slot != (slot_t) 0 && p->w_slot != (slot_t) -1)
X	*s++ = '$';
X#endif
X      if (p->w_logfp != NULL)
X	{
X	  strcpy(s, "(L)");
X	  s += 3;
X	}
X      *s++ = ' ';
X      strcpy(s, cmd);
X      s += strlen(s);
X      if (p == fore)
X	{
X	  /* 
X	   * this is usually done by Activate(), but when looking
X	   * on your current window, you may get annoyed, as there is still
X	   * that temporal '!' and '@' displayed.
X	   * So we remove that after displaying it once.
X	   */
X	  p->w_bell = BELL_OFF;
X	  if (p->w_monitor != MON_OFF)
X	    p->w_monitor = MON_ON;
X	}
X    }
X  *s++ = ' ';
X  *s = '\0';
X  if (ss - buf > d_width / 2)
X    {
X      ss -= d_width / 2;
X      if (s - ss < d_width)
X	{
X	  ss = s - d_width;
X	  if (ss < buf)
X	    ss = buf;
X	}
X    }
X  else
X    ss = buf;
X  Msg(0, "%s", ss);
X}
X
X
Xstatic void
XShowTime()
X{
X  char buf[512];
X  struct tm *tp;
X  time_t now;
X
X  (void) time(&now);
X  tp = localtime(&now);
X  sprintf(buf, "%2d:%02d:%02d %s", tp->tm_hour, tp->tm_min, tp->tm_sec,
X	  HostName);
X#ifdef LOADAV
X  AddLoadav(buf + strlen(buf));
X#endif /* LOADAV */
X  Msg(0, "%s", buf);
X}
X
Xstatic void
XShowInfo()
X{
X  char buf[512], *p;
X  register struct win *wp = fore;
X  register int i;
X
X  if (wp == 0)
X    {
X      Msg(0, "(%d,%d)/(%d,%d) no window", d_x + 1, d_y + 1, d_width, d_height);
X      return;
X    }
X#ifdef COPY_PASTE
X  sprintf(buf, "(%d,%d)/(%d,%d)+%d %c%sflow %cins %corg %cwrap %capp %clog %cmon %cr",
X#else
X  sprintf(buf, "(%d,%d)/(%d,%d) %c%sflow %cins %corg %cwrap %capp %clog %cmon %cr",
X#endif
X	  wp->w_x + 1, wp->w_y + 1, wp->w_width, wp->w_height,
X#ifdef COPY_PASTE
X	  wp->w_histheight,
X#endif
X	  (wp->w_flow & FLOW_NOW) ? '+' : '-',
X	  (wp->w_flow & FLOW_AUTOFLAG) ? "" : ((wp->w_flow & FLOW_AUTO) ? "(+)" : "(-)"),
X	  wp->w_insert ? '+' : '-', wp->w_origin ? '+' : '-',
X	  wp->w_wrap ? '+' : '-', wp->w_keypad ? '+' : '-',
X	  (wp->w_logfp != NULL) ? '+' : '-',
X	  (wp->w_monitor != MON_OFF) ? '+' : '-',
X	  wp->w_norefresh ? '-' : '+');
X  if (CG0)
X    {
X      p = buf + strlen(buf);
X      sprintf(p, " G%1d [", wp->w_Charset);
X      for (i = 0; i < 4; i++)
X	p[i + 5] = wp->w_charsets[i] ? wp->w_charsets[i] : 'B';
X      p[9] = ']';
X      p[10] = '\0';
X    }
X  Msg(0, "%s", buf);
X}
X
X
Xstatic void
XAKAfin(buf, len)
Xchar *buf;
Xint len;
X{
X  ASSERT(display);
X  if (len && fore)
X    ChangeAKA(fore, buf, 20);
X}
X
Xstatic void
XInputAKA()
X{
X  Input("Set window's a.k.a. to: ", 20, AKAfin, INP_COOKED);
X}
X
Xstatic void
XColonfin(buf, len)
Xchar *buf;
Xint len;
X{
X  if (len)
X    RcLine(buf);
X}
X
Xstatic void
XInputColon()
X{
X  Input(":", 100, Colonfin, INP_COOKED);
X}
X
Xstatic void
XSelectFin(buf, len)
Xchar *buf;
Xint len;
X{
X  int n;
X
X  if (!len || !display)
X    return;
X  if ((n = WindowByNoN(buf)) < 0)
X    return;
X  SwitchWindow(n);
X}
X    
Xstatic void
XInputSelect()
X{
X  Input("Switch to window: ", 20, SelectFin, INP_COOKED);
X}
X
Xvoid
XDoScreen(fn, av)
Xchar *fn, **av;
X{
X  struct NewWindow nwin;
X  register int num;
X  char buf[20];
X  char termbuf[25];
X
X  nwin = nwin_undef;
X  termbuf[0] = '\0';
X  while (av && *av && av[0][0] == '-')
X    {
X      switch (av[0][1])
X	{
X	case 'f':
X	  switch (av[0][2])
X	    {
X	    case 'n':
X	    case '0':
X	      nwin.flowflag = FLOW_NOW * 0;
X	      break;
X	    case 'y':
X	    case '1':
X	    case '\0':
X	      nwin.flowflag = FLOW_NOW * 1;
X	      break;
X	    case 'a':
X	      nwin.flowflag = FLOW_AUTOFLAG;
X	      break;
X	    default:
X	      break;
X	    }
X	  break;
X	case 'k':
X	case 't':
X	  if (av[0][2])
X	    nwin.aka = &av[0][2];
X	  else if (*++av)
X	    nwin.aka = *av;
X	  else
X	    --av;
X	  break;
X	case 'T':
X	  if (av[0][2])
X	    nwin.term = &av[0][2];
X	  else if (*++av)
X	    nwin.term = *av;
X	  else
X	    --av;
X	  break;
X	case 'h':
X	  if (av[0][2])
X	    nwin.histheight = atoi(av[0] + 2);
X	  else if (*++av)
X	    nwin.histheight = atoi(*av);
X	  else 
X	    --av;
X	  break;
X	case 'l':
X	  switch (av[0][2])
X	    {
X	    case 'n':
X	    case '0':
X	      nwin.lflag = 0;
X	      break;
X	    case 'y':
X	    case '1':
X	    case '\0':
X	      nwin.lflag = 1;
X	      break;
X	    default:
X	      break;
X	    }
X	  break;
X	case 'a':
X	  nwin.aflag = 1;
X	  break;
X	case 'M':
X	  nwin.monitor = MON_ON;
Xdebug("nwin.monitor = MON_ON;\n");
X	  break;
X	default:
X	  Msg(0, "%s: screen: invalid option -%c.", fn, av[0][1]);
X	  break;
X	}
X      ++av;
X    }
X  num = 0;
X  if (av && *av && IsNumColon(*av, 10, buf, sizeof(buf)))
X    {
X      if (*buf != '\0')
X	nwin.aka = buf;
X      num = atoi(*av);
X      if (num < 0 || num > MAXWIN - 1)
X	{
X	  Msg(0, "%s: illegal screen number %d.", fn, num);
X	  num = 0;
X	}
X      nwin.StartAt = num;
X      ++av;
X    }
X  if (av && *av)
X    {
X      nwin.args = av;
X      if (!nwin.aka)
X        nwin.aka = Filename(*av);
X    }
X  MakeWindow(&nwin);
X}
X
X#ifdef COPY_PASTE
X/*
X * CompileKeys must be called before Markroutine is first used.
X * to initialise the keys with defaults, call CompileKeys(NULL, mark_key_tab);
X *
X * s is an ascii string in a termcap-like syntax. It looks like
X *   "j=u:k=d:l=r:h=l: =.:" and so on...
X * this example rebinds the cursormovement to the keys u (up), d (down),
X * l (left), r (right). placing a mark will now be done with ".".
X */
Xint
XCompileKeys(s, array)
Xchar *s, *array;
X{
X  int i;
X  unsigned char key, value;
X
X  if (!s || !*s)
X    {
X      for (i = 0; i < 256; i++)
X        array[i] = i;
X      return 0;
X    }
X  debug1("CompileKeys: '%s'\n", s);
X  while (*s)
X    {
X      s = ParseChar(s, (char *) &key);
X      if (*s != '=')
X	return -1;
X      do 
X	{
X          s = ParseChar(++s, (char *) &value);
X	  array[value] = key;
X	}
X      while (*s == '=');
X      if (!*s) 
X	break;
X      if (*s++ != ':')
X	return -1;
X    }
X  return 0;
X}
X#endif /* COPY_PASTE */
X
X/*
X *  Asynchronous input functions
X */
X
X#ifdef POW_DETACH
Xstatic void
Xpow_detach_fn(buf, len)
Xchar *buf;
Xint len;
X{
X  if (len)
X    {
X      *buf = 0;
X      return;
X    }
X  if (ktab[(int)(unsigned char)*buf].nr != RC_POW_DETACH)
X    {
X      if (display)
X        write(d_userfd, "\007", 1);
X#ifdef NETHACK
X      if (nethackflag)
X	 Msg(0, "The blast of disintegration whizzes by you!");
X#endif
X    }
X  else
X    Detach(D_POWER);
X}
X#endif /* POW_DETACH */
X
X#ifdef COPY_PASTE
Xstatic void
Xcopy_reg_fn(buf, len)
Xchar *buf;
Xint len;
X{
X  struct plop *pp = plop_tab + (int)(unsigned char)*buf;
X
X  if (len)
X    {
X      *buf = 0;
X      return;
X    }
X  if (pp->buf)
X    free(pp->buf);
X  if ((pp->buf = (char *)malloc(d_copylen)) == NULL)
X    {
X      Msg(0, strnomem);
X      return;
X    }
X  bcopy(d_copybuffer, pp->buf, d_copylen);
X  pp->len = d_copylen;
X  Msg(0, "Copied %d characters into register %c", d_copylen, *buf);
X}
X
Xstatic void
Xins_reg_fn(buf, len)
Xchar *buf;
Xint len;
X{
X  struct plop *pp = plop_tab + (int)(unsigned char)*buf;
X
X  if (len)
X    {
X      *buf = 0;
X      return;
X    }
X  if (pp->buf)
X    {
X      fore->w_pastebuffer  = pp->buf;
X      fore->w_pastelen = pp->len;
X      return;
X    }
X#ifdef NETHACK
X  if (nethackflag)
X    Msg(0, "Nothing happens.");
X  else
X#endif
X  Msg(0, "Empty register.");
X}
X#endif /* COPY_PASTE */
X
Xstatic void
Xprocess_fn(buf, len)
Xchar *buf;
Xint len;
X{
X  struct plop *pp = plop_tab + (int)(unsigned char)*buf;
X
X  if (len)
X    {
X      *buf = 0;
X      return;
X    }
X  if (pp->buf)
X    {
X      ProcessInput(pp->buf, pp->len);
X      return;
X    }
X#ifdef NETHACK
X  if (nethackflag)
X    Msg(0, "Nothing happens.");
X  else
X#endif
X  Msg(0, "Empty register.");
X}
X
X
X#ifdef PASSWORD
X
X/* ARGSUSED */
Xstatic void
Xpass1(buf, len)
Xchar *buf;
Xint len;
X{
X  strncpy(Password, buf, sizeof(Password) - 1);
X  Input("Retype new password:", sizeof(Password) - 1, pass2, 1);
X}
X
X/* ARGSUSED */
Xstatic void
Xpass2(buf, len)
Xchar *buf;
Xint len;
X{
X  int st;
X  char salt[2];
X
X  if (buf == 0 || strcmp(Password, buf))
X    {
X#ifdef NETHACK
X      if (nethackflag)
X	Msg(0, "[ Passwords don't match - your armor crumbles away ]");
X      else
X#endif /* NETHACK */
X        Msg(0, "[ Passwords don't match - checking turned off ]");
X      CheckPassword = 0;
X    }
X  if (Password[0] == '\0')
X    {
X      Msg(0, "[ No password - no secure ]");
X      CheckPassword = 0;
X    }
X  for (st = 0; st < 2; st++)
X    salt[st] = 'A' + (int)((time(0) >> 6 * st) % 26);
X  strncpy(Password, crypt(Password, salt), sizeof(Password));
X  if (CheckPassword)
X    {
X#ifdef COPY_PASTE
X      if (d_copybuffer)
X	free(d_copybuffer);
X      d_copylen = strlen(Password);
X      if ((d_copybuffer = (char *) malloc(d_copylen + 1)) == NULL)
X	{
X	  Msg(0, strnomem);
X          d_copylen = 0;
X	}
X      else
X	{
X	  strcpy(d_copybuffer, Password);
X	  Msg(0, "[ Password moved into copybuffer ]");
X	}
X#else				/* COPY_PASTE */
X      Msg(0, "[ Crypted password is \"%s\" ]", Password);
X#endif				/* COPY_PASTE */
X    }
X  if (buf)
X    bzero(buf, strlen(buf));
X}
X#endif /* PASSWORD */
X
END_OF_FILE
if test 52175 -ne `wc -c <'process.c'`; then
    echo shar: \"'process.c'\" unpacked with wrong size!
fi
# end of 'process.c'
fi
echo shar: End of archive 7 \(of 10\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
