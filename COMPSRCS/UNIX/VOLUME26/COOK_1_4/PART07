Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v26i215: cook-1.4 - a file construction tool (like "make"), Part07/11
Sender: unix-sources-moderator@efficacy.home.vix.com
Approved: WhoAmI@efficacy.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 26, Issue 215
Archive-Name: cook-1.4/part07

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 11)."
# Contents:  Makefile common/version.c cook/id.c cook/match.c
#   cook/stmt.c
# Wrapped by vixie@efficacy.home.vix.com on Tue May  4 01:36:41 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(16134 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# You may need to change this for your system.
X# The ``h'' directory supplements your system, not replacing it.
X# The first variation is for gcc when it isn't the native complier,
X# the second variation is for systems with missing ANSI C include files,
X# the third variation is for conforming ANSI C implementations.
X#
X# H = -I/usr/local/lib/gcc-include -I/usr/include -Ih
X# H = -I/usr/include -Ih
XH =
X# H =				# SunOS
X# H =				# ConvexOS
X# H =				# dgux
X# H =				# dcosx
X# H =				# ULTRIX
X
X#
X# the name of the compiler to use
X#
XCC = cc
X# CC = gcc
X# CC = cc			# SunOS
X# CC = cc			# ConvexOS
X# CC = rcc			# SCO
X# CC = cc			# dgux
X# CC = /usr/ucb/cc		# dcosx
X# CC = cc			# ULTRIX
X
X#
X# The compiler flags to use, except for include path.
X#
XCFLAGS = -O
X# CFLAGS = -g
X# CFLAGS = -O			# SunOS
X# CFLAGS = -O			# ConvexOS
X# CFLAGS = -O			# dgux
X# CFLAGS = -O -Xt -U__STDC__	# dcosx
X# CFLAGS = -O -Wall -ansi	# gcc
X# CFLAGS = -O			# ULTRIX
X
X#
X# where to put the library directory
X#
XLIB = /usr/local/lib/cook
X
X#
X# where to put the executables
X#
XBIN = /usr/local/bin
X
X#
X# where to put the manuals
X#
XMAN = /usr/local/man
X
X#
X# Which yacc to use
X#
XYACC = yacc
X# YACC = bison -y		# GNU
X# YACC = byacc			# Berkeley yacc
X
X#
X# extra libraries required for your system
X#
XLIBRARIES =
X# LIBRARIES =			# SunOS
X# LIBRARIES =			# ConvexOS
X# LIBRARIES =			# dgux
X# LIBRARIES = -lucb		# dcosx
X# LIBRARIES =			# ULTRIX
X# LIBRARIES = -lbsd
X
X#
X# shell to use to run tests and commands
X#	Make sure there are no spaces after the definition,
X#	many falavours of make(1) can't cope with them.
X#
XSHELL = /bin/sh
X# SHELL = /bin/sh		# SunOS
X# SHELL = /bin/sh		# ConvexOS
X# SHELL = /bin/sh		# dgux
X# SHELL = /bin/sh		# dcosx
X# SHELL = /bin/sh5		# ULTRIX
X
X# You should not need to alter anything below this point.
X#------------------------------------------------------------
X
Xall: bin/cook bin/c_incl bin/find_libs bin/roffpp bin/cooktime
X
X
Xc_incl/cache.o: c_incl/cache.c common/arglex.h common/main.h \
X		c_incl/cache.h common/str.h common/s-v-arg.h \
X		common/word.h common/error.h common/mem.h c_incl/os.h 
X	$(CC) $(CFLAGS) -Ic_incl -Icommon $(H) -c c_incl/cache.c
X	mv cache.o c_incl
X
Xc_incl/lang_c.o: c_incl/lang_c.c common/error.h common/main.h \
X		common/mem.h c_incl/sniff.h common/trace.h \
X		common/word.h common/str.h common/s-v-arg.h 
X	$(CC) $(CFLAGS) -Ic_incl -Icommon $(H) -c c_incl/lang_c.c
X	mv lang_c.o c_incl
X
Xc_incl/lang_roff.o: c_incl/lang_roff.c common/error.h common/main.h \
X		common/mem.h c_incl/sniff.h common/trace.h \
X		common/word.h common/str.h common/s-v-arg.h 
X	$(CC) $(CFLAGS) -Ic_incl -Icommon $(H) -c c_incl/lang_roff.c
X	mv lang_roff.o c_incl
X
Xc_incl/main.o: c_incl/main.c common/arglex.h common/main.h \
X		c_incl/cache.h common/str.h common/s-v-arg.h \
X		common/word.h common/error.h common/help.h \
X		c_incl/sniff.h common/trace.h common/version.h 
X	$(CC) $(CFLAGS) -Ic_incl -Icommon $(H) -c c_incl/main.c
X	mv main.o c_incl
X
Xc_incl/os.o: c_incl/os.c common/error.h common/main.h c_incl/os.h
X	$(CC) $(CFLAGS) -Ic_incl -Icommon $(H) -c c_incl/os.c
X	mv os.o c_incl
X
Xc_incl/sniff.o: c_incl/sniff.c c_incl/cache.h common/main.h \
X		common/str.h common/s-v-arg.h common/word.h \
X		common/error.h common/mem.h c_incl/os.h c_incl/sniff.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Ic_incl -Icommon $(H) -c c_incl/sniff.c
X	mv sniff.o c_incl
X
Xcommon/ansi.o: common/ansi.c common/main.h
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/ansi.c
X	mv ansi.o common
X
Xcommon/arglex.o: common/arglex.c common/main.h common/arglex.h \
X		common/error.h common/word.h common/str.h \
X		common/s-v-arg.h common/mem.h common/trace.h 
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/arglex.c
X	mv arglex.o common
X
Xcommon/error.o: common/error.c common/arglex.h common/main.h \
X		common/error.h common/s-v-arg.h 
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/error.c
X	mv error.o common
X
Xcommon/help.o: common/help.c common/arglex.h common/main.h \
X		common/error.h common/help.h common/patchlevel.h 
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/help.c
X	mv help.o common
X
Xcommon/mem.o: common/mem.c common/mem.h common/main.h common/error.h
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/mem.c
X	mv mem.o common
X
Xcommon/str.o: common/str.c common/error.h common/main.h common/mem.h \
X		common/s-v-arg.h common/str.h 
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/str.c
X	mv str.o common
X
Xcommon/trace.o: common/trace.c common/error.h common/main.h \
X		common/mem.h common/arglex.h common/s-v-arg.h \
X		common/str.h common/trace.h 
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/trace.c
X	mv trace.o common
X
Xcommon/version.o: common/version.c common/arglex.h common/main.h \
X		common/error.h common/help.h common/str.h \
X		common/s-v-arg.h common/version.h 
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/version.c
X	mv version.o common
X
Xcommon/word.o: common/word.c common/error.h common/main.h common/mem.h \
X		common/str.h common/s-v-arg.h common/word.h 
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/word.c
X	mv word.o common
X
Xcook/builtin.o: cook/builtin.c cook/builtin.h common/main.h cook/cook.h \
X		cook/expr.h common/str.h common/s-v-arg.h common/word.h \
X		cook/stmt.h common/error.h cook/glob.h cook/id.h \
X		cook/match.h common/mem.h cook/option.h cook/os.h 
X	$(CC) $(CFLAGS)  -Icook -Icommon $(H) -c cook/builtin.c
X	mv builtin.o cook
X
Xcook/cook.o: cook/cook.c cook/cook.h common/main.h cook/expr.h \
X		common/str.h common/s-v-arg.h common/word.h cook/stmt.h \
X		common/error.h cook/id.h cook/match.h common/mem.h \
X		cook/option.h cook/os.h common/trace.h 
X	$(CC) $(CFLAGS)  -Icook -Icommon $(H) -c cook/cook.c
X	mv cook.o cook
X
Xcook/env.o: cook/env.c common/main.h cook/env.h common/mem.h \
X		common/error.h 
X	$(CC) $(CFLAGS)  -Icook -Icommon $(H) -c cook/env.c
X	mv env.o cook
X
Xcook/expr.o: cook/expr.c cook/builtin.h common/main.h cook/cook.h \
X		cook/expr.h common/str.h common/s-v-arg.h common/word.h \
X		cook/stmt.h common/error.h cook/id.h cook/lex.h \
X		cook/match.h common/mem.h cook/option.h common/trace.h 
X	$(CC) $(CFLAGS)  -Icook -Icommon $(H) -c cook/expr.c
X	mv expr.o cook
X
Xcook/glob.o: cook/glob.c cook/glob.h common/main.h common/word.h \
X		common/str.h common/s-v-arg.h common/trace.h \
X		common/mem.h common/error.h 
X	$(CC) $(CFLAGS)  -Icook -Icommon $(H) -c cook/glob.c
X	mv glob.o cook
X
Xcook/hashline.gen.c cook/hashline.gen.h: cook/hashline.y
X	$(YACC) -d cook/hashline.y
X	sed -e 's/[yY][yY]/hashline_/g' y.tab.c > cook/hashline.gen.c
X	sed -e 's/[yY][yY]/hashline_/g' y.tab.h > cook/hashline.gen.h
X	rm y.tab.c y.tab.h
X
Xcook/hashline.gen.o: cook/hashline.gen.c common/error.h common/main.h \
X		cook/expr.h common/str.h common/s-v-arg.h common/word.h \
X		cook/hashline.h cook/lex.h common/mem.h cook/option.h \
X		cook/os.h common/trace.h 
X	$(CC) $(CFLAGS) -Icook -Icommon $(H) -c cook/hashline.gen.c
X	mv hashline.gen.o cook/hashline.gen.o
X
Xcook/id.o: cook/id.c common/error.h common/main.h common/help.h \
X		cook/id.h common/str.h common/s-v-arg.h common/word.h \
X		common/mem.h cook/option.h 
X	$(CC) $(CFLAGS)  -Icook -Icommon $(H) -c cook/id.c
X	mv id.o cook
X
Xcook/lex.o: cook/lex.c common/error.h common/main.h cook/expr.h \
X		common/str.h common/s-v-arg.h common/word.h \
X		cook/hashline.h cook/id.h cook/lex.h common/mem.h \
X		cook/option.h cook/stmt.h common/trace.h \
X		cook/parse.gen.h cook/hashline.gen.h 
X	$(CC) $(CFLAGS)  -Icook -Icommon $(H) -c cook/lex.c
X	mv lex.o cook
X
Xcook/listing.o: cook/listing.c common/error.h common/main.h \
X		cook/listing.h cook/os.h common/str.h common/s-v-arg.h \
X		common/word.h cook/option.h common/trace.h 
X	$(CC) $(CFLAGS)  -Icook -Icommon $(H) -c cook/listing.c
X	mv listing.o cook
X
Xcook/main.o: cook/main.c common/arglex.h common/main.h cook/builtin.h \
X		cook/cook.h cook/expr.h common/str.h common/s-v-arg.h \
X		common/word.h cook/stmt.h cook/env.h common/error.h \
X		common/help.h cook/id.h cook/lex.h cook/listing.h \
X		cook/option.h cook/parse.h common/trace.h \
X		common/version.h 
X	$(CC) $(CFLAGS)  -Icook -Icommon $(H) -c cook/main.c
X	mv main.o cook
X
Xcook/match.o: cook/match.c common/main.h common/str.h common/s-v-arg.h \
X		cook/match.h common/word.h common/error.h common/mem.h \
X		common/trace.h 
X	$(CC) $(CFLAGS)  -Icook -Icommon $(H) -c cook/match.c
X	mv match.o cook
X
Xcook/option.o: cook/option.c common/main.h cook/option.h common/str.h \
X		common/s-v-arg.h common/word.h common/error.h cook/os.h \
X		common/mem.h 
X	$(CC) $(CFLAGS) -D'LIBDIR="$(LIB)"' -Icook -Icommon $(H) -c \
X		cook/option.c 
X	mv option.o cook
X
Xcook/os.o: cook/os.c common/error.h common/main.h cook/id.h \
X		common/str.h common/s-v-arg.h common/word.h \
X		common/mem.h cook/option.h cook/os.h common/trace.h 
X	$(CC) $(CFLAGS)  -Icook -Icommon $(H) -c cook/os.c
X	mv os.o cook
X
Xcook/parse.gen.c cook/parse.gen.h: cook/parse.y
X	$(YACC) -d cook/parse.y
X	sed -e 's/[yY][yY]/parse_/g' y.tab.c > cook/parse.gen.c
X	sed -e 's/[yY][yY]/parse_/g' y.tab.h > cook/parse.gen.h
X	rm y.tab.c y.tab.h
X
Xcook/parse.gen.o: cook/parse.gen.c cook/cook.h common/main.h \
X		cook/expr.h common/str.h common/s-v-arg.h common/word.h \
X		cook/stmt.h cook/id.h cook/lex.h common/mem.h \
X		cook/option.h cook/parse.h common/trace.h 
X	$(CC) $(CFLAGS) -Icook -Icommon $(H) -c cook/parse.gen.c
X	mv parse.gen.o cook/parse.gen.o
X
Xcook/stmt.o: cook/stmt.c cook/cook.h common/main.h cook/expr.h \
X		common/str.h common/s-v-arg.h common/word.h cook/stmt.h \
X		cook/env.h common/error.h cook/id.h cook/match.h \
X		common/mem.h cook/option.h cook/os.h common/trace.h 
X	$(CC) $(CFLAGS)  -Icook -Icommon $(H) -c cook/stmt.c
X	mv stmt.o cook
X
Xcooktime/date.gen.c cooktime/date.gen.h: cooktime/date.y
X	$(YACC) -d cooktime/date.y
X	sed -e 's/[yY][yY]/date_/g' y.tab.c > cooktime/date.gen.c
X	sed -e 's/[yY][yY]/date_/g' y.tab.h > cooktime/date.gen.h
X	rm y.tab.c y.tab.h
X
Xcooktime/date.gen.o: cooktime/date.gen.c cooktime/date.h common/main.h \
X		common/s-v-arg.h common/trace.h 
X	$(CC) $(CFLAGS) -Icooktime -Icommon $(H) -c cooktime/date.gen.c
X	mv date.gen.o cooktime/date.gen.o
X
Xcooktime/main.o: cooktime/main.c common/arglex.h common/main.h \
X		cooktime/date.h common/error.h common/help.h \
X		common/str.h common/s-v-arg.h common/trace.h \
X		common/version.h common/word.h 
X	$(CC) $(CFLAGS) -Icooktime -Icommon $(H) -c cooktime/main.c
X	mv main.o cooktime
X
Xfind_libs/main.o: find_libs/main.c common/arglex.h common/main.h \
X		common/error.h common/help.h common/mem.h \
X		find_libs/os.h common/str.h common/s-v-arg.h \
X		common/version.h 
X	$(CC) $(CFLAGS) -Ifind_libs -Icommon $(H) -c find_libs/main.c
X	mv main.o find_libs
X
Xfind_libs/os.o: find_libs/os.c common/error.h common/main.h \
X		find_libs/os.h 
X	$(CC) $(CFLAGS) -Ifind_libs -Icommon $(H) -c find_libs/os.c
X	mv os.o find_libs
X
Xroffpp/main.o: roffpp/main.c common/arglex.h common/main.h \
X		common/error.h common/help.h roffpp/preprocess.h \
X		common/str.h common/s-v-arg.h common/trace.h \
X		common/version.h 
X	$(CC) $(CFLAGS) -Iroffpp -Icommon $(H) -c roffpp/main.c
X	mv main.o roffpp
X
Xroffpp/preprocess.o: roffpp/preprocess.c common/error.h common/main.h \
X		common/mem.h roffpp/preprocess.h common/str.h \
X		common/s-v-arg.h common/trace.h common/word.h 
X	$(CC) $(CFLAGS) -Iroffpp -Icommon $(H) -c roffpp/preprocess.c
X	mv preprocess.o roffpp
X
Xt0001a: all test/00/t0001a.sh
X	$(SHELL) test/00/t0001a.sh
X
Xt0002a: all test/00/t0002a.sh
X	$(SHELL) test/00/t0002a.sh
X
Xt0003a: all test/00/t0003a.sh
X	$(SHELL) test/00/t0003a.sh
X
Xt0004a: all test/00/t0004a.sh
X	$(SHELL) test/00/t0004a.sh
X
Xt0005a: all test/00/t0005a.sh
X	$(SHELL) test/00/t0005a.sh
X
Xt0006a: all test/00/t0006a.sh
X	$(SHELL) test/00/t0006a.sh
X
Xt0007a: all test/00/t0007a.sh
X	$(SHELL) test/00/t0007a.sh
X
Xt0008a: all test/00/t0008a.sh
X	$(SHELL) test/00/t0008a.sh
X
Xt0009a: all test/00/t0009a.sh
X	$(SHELL) test/00/t0009a.sh
X
Xt0010a: all test/00/t0010a.sh
X	$(SHELL) test/00/t0010a.sh
X
Xt0011a: all test/00/t0011a.sh
X	$(SHELL) test/00/t0011a.sh
X
Xt0012a: all test/00/t0012a.sh
X	$(SHELL) test/00/t0012a.sh
X
Xt0013a: all test/00/t0013a.sh
X	$(SHELL) test/00/t0013a.sh
X
Xt0014a: all test/00/t0014a.sh
X	$(SHELL) test/00/t0014a.sh
X
Xt0015a: all test/00/t0015a.sh
X	$(SHELL) test/00/t0015a.sh
X
Xt0016a: all test/00/t0016a.sh
X	$(SHELL) test/00/t0016a.sh
X
Xt0017a: all test/00/t0017a.sh
X	$(SHELL) test/00/t0017a.sh
X
Xt0018a: all test/00/t0018a.sh
X	$(SHELL) test/00/t0018a.sh
X
Xt0019a: all test/00/t0019a.sh
X	$(SHELL) test/00/t0019a.sh
X
Xt0020a: all test/00/t0020a.sh
X	$(SHELL) test/00/t0020a.sh
X
Xt0021a: all test/00/t0021a.sh
X	$(SHELL) test/00/t0021a.sh
X
Xt0022a: all test/00/t0022a.sh
X	$(SHELL) test/00/t0022a.sh
X
Xt0023a: all test/00/t0023a.sh
X	$(SHELL) test/00/t0023a.sh
X
Xt0024a: all test/00/t0024a.sh
X	$(SHELL) test/00/t0024a.sh
X
Xt0025a: all test/00/t0025a.sh
X	$(SHELL) test/00/t0025a.sh
X
Xt0026a: all test/00/t0026a.sh
X	$(SHELL) test/00/t0026a.sh
X
Xt0027a: all test/00/t0027a.sh
X	$(SHELL) test/00/t0027a.sh
X
Xt0028a: all test/00/t0028a.sh
X	$(SHELL) test/00/t0028a.sh
X
Xt0029a: all test/00/t0029a.sh
X	$(SHELL) test/00/t0029a.sh
X
Xt0030a: all test/00/t0030a.sh
X	$(SHELL) test/00/t0030a.sh
X
Xt0031a: all test/00/t0031a.sh
X	$(SHELL) test/00/t0031a.sh
X
Xt0032a: all test/00/t0032a.sh
X	$(SHELL) test/00/t0032a.sh
X
Xt0033a: all test/00/t0033a.sh
X	$(SHELL) test/00/t0033a.sh
X
Xt0034a: all test/00/t0034a.sh
X	$(SHELL) test/00/t0034a.sh
X
Xt0035a: all test/00/t0035a.sh
X	$(SHELL) test/00/t0035a.sh
X
Xt0036a: all test/00/t0036a.sh
X	$(SHELL) test/00/t0036a.sh
X
Xt0037a: all test/00/t0037a.sh
X	$(SHELL) test/00/t0037a.sh
X
Xt0038a: all test/00/t0038a.sh
X	$(SHELL) test/00/t0038a.sh
X
Xt0039a: all test/00/t0039a.sh
X	$(SHELL) test/00/t0039a.sh
X
Xt0040a: all test/00/t0040a.sh
X	$(SHELL) test/00/t0040a.sh
X
Xt0041a: all test/00/t0041a.sh
X	$(SHELL) test/00/t0041a.sh
X
XCookObj = cook/builtin.o cook/cook.o cook/env.o cook/expr.o cook/glob.o \
X		cook/hashline.gen.o cook/id.o cook/lex.o cook/listing.o \
X		cook/main.o cook/match.o cook/option.o cook/os.o \
X		cook/parse.gen.o cook/stmt.o 
X
XCommonObj = common/ansi.o common/arglex.o common/error.o common/help.o \
X		common/mem.o common/str.o common/trace.o \
X		common/version.o common/word.o 
X
XCInclObj = c_incl/cache.o c_incl/lang_c.o c_incl/lang_roff.o \
X		c_incl/main.o c_incl/os.o c_incl/sniff.o 
X
XFindLibsObj = find_libs/main.o find_libs/os.o
X
XRoffppObj = roffpp/main.o roffpp/preprocess.o
X
XCooktimeObj = cooktime/date.gen.o cooktime/main.o
X
Xbin/cook: $(CookObj) $(CommonObj)
X	-if [ ! -d bin ]; then mkdir bin; fi
X	$(CC) -o bin/cook $(CookObj) $(CommonObj) $(LIBRARIES)
X
Xbin/c_incl: $(CInclObj) $(CommonObj)
X	-if [ ! -d bin ]; then mkdir bin; fi
X	$(CC) -o bin/c_incl $(CInclObj) $(CommonObj) $(LIBRARIES)
X
Xbin/find_libs: $(FindLibsObj) $(CommonObj)
X	-if [ ! -d bin ]; then mkdir bin; fi
X	$(CC) -o bin/find_libs $(FindLibsObj) $(CommonObj) $(LIBRARIES)
X
Xbin/roffpp: $(RoffppObj) $(CommonObj)
X	-if [ ! -d bin ]; then mkdir bin; fi
X	$(CC) -o bin/roffpp $(RoffppObj) $(CommonObj) $(LIBRARIES)
X
Xbin/cooktime: $(CooktimeObj) $(CommonObj)
X	-if [ ! -d bin ]; then mkdir bin; fi
X	$(CC) -o bin/cooktime $(CooktimeObj) $(CommonObj) $(LIBRARIES)
X
Xsure: t0001a t0002a t0003a t0004a t0005a t0006a t0007a t0008a t0009a \
X		t0010a t0011a t0012a t0013a t0014a t0015a t0016a t0017a \
X		t0018a t0019a t0020a t0021a t0022a t0023a t0024a t0025a \
X		t0026a t0027a t0028a t0029a t0030a t0031a t0032a t0033a \
X		t0034a t0035a t0036a t0037a t0038a t0039a t0040a t0041a 
X	@echo Passed All Tests
X
Xclean:
X	rm -f core c_incl/cache.o c_incl/lang_c.o c_incl/lang_roff.o \
X		c_incl/main.o c_incl/os.o c_incl/sniff.o common/ansi.o \
X		common/arglex.o common/error.o common/help.o \
X		common/mem.o common/str.o common/trace.o \
X		common/version.o common/word.o cook/builtin.o \
X		cook/cook.o cook/env.o cook/expr.o cook/glob.o \
X		cook/hashline.gen.c cook/hashline.gen.h \
X		cook/hashline.gen.o cook/id.o cook/lex.o cook/listing.o \
X		cook/main.o cook/match.o cook/option.o cook/os.o \
X		cook/parse.gen.c cook/parse.gen.h cook/parse.gen.o \
X		cook/stmt.o cooktime/date.gen.c cooktime/date.gen.h \
X		cooktime/date.gen.o cooktime/main.o find_libs/main.o \
X		find_libs/os.o roffpp/main.o roffpp/preprocess.o 
X
Xclobber: clean
X	rm -f bin/cook bin/c_incl bin/find_libs bin/roffpp bin/cooktime
X
Xinstall: all
X	chmod a+x bin/*
X	cp bin/* $(BIN)
X	$(SHELL) man1/install.sh $(MAN)/man1
X	-mkdir $(LIB)
X	-chmod a+rx $(LIB)
X	chmod a+r lib/*
X	cp lib/* $(LIB)
END_OF_FILE
if test 16134 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'common/version.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/version.c'\"
else
echo shar: Extracting \"'common/version.c'\" \(17634 characters\)
sed "s/^X//" >'common/version.c' <<'END_OF_FILE'
X/*
X *	cook - a program construction tool
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to provide common -VERSion behaviour
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X
X#include <arglex.h>
X#include <error.h>
X#include <help.h>
X#include <str.h>
X/* #include <trace.h> */
X#include <version.h>
X
X
Xstatic void version_copyright _((void));
X
Xstatic void
Xversion_copyright()
X{
X	static char *text[] =
X	{
X		"%C",
X	};
X	help(text, SIZEOF(text), (void (*)_((void)))0);
X}
X
X
Xstatic void version_redistribution _((void));
X
Xstatic void
Xversion_redistribution()
X{
X	static char *text[] =
X	{
X"		    GNU GENERAL PUBLIC LICENSE",
X"   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION",
X"",
X"  0. This License applies to any program or other work which contains",
X"a notice placed by the copyright holder saying it may be distributed",
X"under the terms of this General Public License.  The \"Program\", below,",
X"refers to any such program or work, and a \"work based on the Program\"",
X"means either the Program or any derivative work under copyright law:",
X"that is to say, a work containing the Program or a portion of it,",
X"either verbatim or with modifications and/or translated into another",
X"language.  (Hereinafter, translation is included without limitation in",
X"the term \"modification\".)  Each licensee is addressed as \"you\".",
X"",
X"Activities other than copying, distribution and modification are not",
X"covered by this License; they are outside its scope.  The act of",
X"running the Program is not restricted, and the output from the Program",
X"is covered only if its contents constitute a work based on the",
X"Program (independent of having been made by running the Program).",
X"Whether that is true depends on what the Program does.",
X"",
X"  1. You may copy and distribute verbatim copies of the Program's",
X"source code as you receive it, in any medium, provided that you",
X"conspicuously and appropriately publish on each copy an appropriate",
X"copyright notice and disclaimer of warranty; keep intact all the",
X"notices that refer to this License and to the absence of any warranty;",
X"and give any other recipients of the Program a copy of this License",
X"along with the Program.",
X"",
X"You may charge a fee for the physical act of transferring a copy, and",
X"you may at your option offer warranty protection in exchange for a fee.",
X"",
X"  2. You may modify your copy or copies of the Program or any portion",
X"of it, thus forming a work based on the Program, and copy and",
X"distribute such modifications or work under the terms of Section 1",
X"above, provided that you also meet all of these conditions:",
X"",
X"    a) You must cause the modified files to carry prominent notices",
X"    stating that you changed the files and the date of any change.",
X"",
X"    b) You must cause any work that you distribute or publish, that in",
X"    whole or in part contains or is derived from the Program or any",
X"    part thereof, to be licensed as a whole at no charge to all third",
X"    parties under the terms of this License.",
X"",
X"    c) If the modified program normally reads commands interactively",
X"    when run, you must cause it, when started running for such",
X"    interactive use in the most ordinary way, to print or display an",
X"    announcement including an appropriate copyright notice and a",
X"    notice that there is no warranty (or else, saying that you provide",
X"    a warranty) and that users may redistribute the program under",
X"    these conditions, and telling the user how to view a copy of this",
X"    License.  (Exception: if the Program itself is interactive but",
X"    does not normally print such an announcement, your work based on",
X"    the Program is not required to print an announcement.)",
X"",
X"These requirements apply to the modified work as a whole.  If",
X"identifiable sections of that work are not derived from the Program,",
X"and can be reasonably considered independent and separate works in",
X"themselves, then this License, and its terms, do not apply to those",
X"sections when you distribute them as separate works.  But when you",
X"distribute the same sections as part of a whole which is a work based",
X"on the Program, the distribution of the whole must be on the terms of",
X"this License, whose permissions for other licensees extend to the",
X"entire whole, and thus to each and every part regardless of who wrote it.",
X"",
X"Thus, it is not the intent of this section to claim rights or contest",
X"your rights to work written entirely by you; rather, the intent is to",
X"exercise the right to control the distribution of derivative or",
X"collective works based on the Program.",
X"",
X"In addition, mere aggregation of another work not based on the Program",
X"with the Program (or with a work based on the Program) on a volume of",
X"a storage or distribution medium does not bring the other work under",
X"the scope of this License.",
X"",
X"  3. You may copy and distribute the Program (or a work based on it,",
X"under Section 2) in object code or executable form under the terms of",
X"Sections 1 and 2 above provided that you also do one of the following:",
X"",
X"    a) Accompany it with the complete corresponding machine-readable",
X"    source code, which must be distributed under the terms of Sections",
X"    1 and 2 above on a medium customarily used for software interchange; or,",
X"",
X"    b) Accompany it with a written offer, valid for at least three",
X"    years, to give any third party, for a charge no more than your",
X"    cost of physically performing source distribution, a complete",
X"    machine-readable copy of the corresponding source code, to be",
X"    distributed under the terms of Sections 1 and 2 above on a medium",
X"    customarily used for software interchange; or,",
X"",
X"    c) Accompany it with the information you received as to the offer",
X"    to distribute corresponding source code.  (This alternative is",
X"    allowed only for noncommercial distribution and only if you",
X"    received the program in object code or executable form with such",
X"    an offer, in accord with Subsection b above.)",
X"",
X"The source code for a work means the preferred form of the work for",
X"making modifications to it.  For an executable work, complete source",
X"code means all the source code for all modules it contains, plus any",
X"associated interface definition files, plus the scripts used to",
X"control compilation and installation of the executable.  However, as a",
X"special exception, the source code distributed need not include",
X"anything that is normally distributed (in either source or binary",
X"form) with the major components (compiler, kernel, and so on) of the",
X"operating system on which the executable runs, unless that component",
X"itself accompanies the executable.",
X"",
X"If distribution of executable or object code is made by offering",
X"access to copy from a designated place, then offering equivalent",
X"access to copy the source code from the same place counts as",
X"distribution of the source code, even though third parties are not",
X"compelled to copy the source along with the object code.",
X"",
X"  4. You may not copy, modify, sublicense, or distribute the Program",
X"except as expressly provided under this License.  Any attempt",
X"otherwise to copy, modify, sublicense or distribute the Program is",
X"void, and will automatically terminate your rights under this License.",
X"However, parties who have received copies, or rights, from you under",
X"this License will not have their licenses terminated so long as such",
X"parties remain in full compliance.",
X"",
X"  5. You are not required to accept this License, since you have not",
X"signed it.  However, nothing else grants you permission to modify or",
X"distribute the Program or its derivative works.  These actions are",
X"prohibited by law if you do not accept this License.  Therefore, by",
X"modifying or distributing the Program (or any work based on the",
X"Program), you indicate your acceptance of this License to do so, and",
X"all its terms and conditions for copying, distributing or modifying",
X"the Program or works based on it.",
X"",
X"  6. Each time you redistribute the Program (or any work based on the",
X"Program), the recipient automatically receives a license from the",
X"original licensor to copy, distribute or modify the Program subject to",
X"these terms and conditions.  You may not impose any further",
X"restrictions on the recipients' exercise of the rights granted herein.",
X"You are not responsible for enforcing compliance by third parties to",
X"this License.",
X"",
X"  7. If, as a consequence of a court judgment or allegation of patent",
X"infringement or for any other reason (not limited to patent issues),",
X"conditions are imposed on you (whether by court order, agreement or",
X"otherwise) that contradict the conditions of this License, they do not",
X"excuse you from the conditions of this License.  If you cannot",
X"distribute so as to satisfy simultaneously your obligations under this",
X"License and any other pertinent obligations, then as a consequence you",
X"may not distribute the Program at all.  For example, if a patent",
X"license would not permit royalty-free redistribution of the Program by",
X"all those who receive copies directly or indirectly through you, then",
X"the only way you could satisfy both it and this License would be to",
X"refrain entirely from distribution of the Program.",
X"",
X"If any portion of this section is held invalid or unenforceable under",
X"any particular circumstance, the balance of the section is intended to",
X"apply and the section as a whole is intended to apply in other",
X"circumstances.",
X"",
X"It is not the purpose of this section to induce you to infringe any",
X"patents or other property right claims or to contest validity of any",
X"such claims; this section has the sole purpose of protecting the",
X"integrity of the free software distribution system, which is",
X"implemented by public license practices.  Many people have made",
X"generous contributions to the wide range of software distributed",
X"through that system in reliance on consistent application of that",
X"system; it is up to the author/donor to decide if he or she is willing",
X"to distribute software through any other system and a licensee cannot",
X"impose that choice.",
X"",
X"This section is intended to make thoroughly clear what is believed to",
X"be a consequence of the rest of this License.",
X"",
X"  8. If the distribution and/or use of the Program is restricted in",
X"certain countries either by patents or by copyrighted interfaces, the",
X"original copyright holder who places the Program under this License",
X"may add an explicit geographical distribution limitation excluding",
X"those countries, so that distribution is permitted only in or among",
X"countries not thus excluded.  In such case, this License incorporates",
X"the limitation as if written in the body of this License.",
X"",
X"  9. The Free Software Foundation may publish revised and/or new versions",
X"of the General Public License from time to time.  Such new versions will",
X"be similar in spirit to the present version, but may differ in detail to",
X"address new problems or concerns.",
X"",
X"Each version is given a distinguishing version number.  If the Program",
X"specifies a version number of this License which applies to it and \"any",
X"later version\", you have the option of following the terms and conditions",
X"either of that version or of any later version published by the Free",
X"Software Foundation.  If the Program does not specify a version number of",
X"this License, you may choose any version ever published by the Free Software",
X"Foundation.",
X"",
X"  10. If you wish to incorporate parts of the Program into other free",
X"programs whose distribution conditions are different, write to the author",
X"to ask for permission.  For software which is copyrighted by the Free",
X"Software Foundation, write to the Free Software Foundation; we sometimes",
X"make exceptions for this.  Our decision will be guided by the two goals",
X"of preserving the free status of all derivatives of our free software and",
X"of promoting the sharing and reuse of software generally.",
X	};
X	help(text, SIZEOF(text), (void (*)_((void)))0);
X}
X
X
Xstatic void version_warranty _((void));
X
Xstatic void
Xversion_warranty()
X{
X	static char *text[] =
X	{
X"			    NO WARRANTY",
X"",
X"  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY",
X"FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN",
X"OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES",
X"PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED",
X"OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF",
X"MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS",
X"TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE",
X"PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,",
X"REPAIR OR CORRECTION.",
X"",
X"  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING",
X"WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR",
X"REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,",
X"INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING",
X"OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED",
X"TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY",
X"YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER",
X"PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE",
X"POSSIBILITY OF SUCH DAMAGES.",
X	};
X
X	help(text, SIZEOF(text), (void (*)_((void)))0);
X}
X
X
Xstatic void version_usage _((void));
X
Xstatic void
Xversion_usage()
X{
X	fprintf(stderr, "usage: %s -VERSion [ <info-name> ]\n", progname);
X	fprintf(stderr, "       %s -VERSion -Help\n", progname);
X	exit(1);
X}
X
X
Xtypedef struct table_ty table_ty;
Xstruct table_ty
X{
X	char	*name;
X	void	(*func)_((void));
X};
X
X
Xstatic table_ty table[] =
X{
X	{ "Copyright",		version_copyright,	},
X	{ "Redistribution",	version_redistribution,	},
X	{ "Warranty",		version_warranty,	},
X};
X
X
Xstatic void version_main _((void));
X
Xstatic void
Xversion_main()
X{
X	void	(*func)_((void));
X
X	/* trace(("version_main()\n{\n"/ *}* /)); */
X	if (arglex_token == arglex_token_string)
X	{
X		int		nhit;
X		table_ty	*tp;
X		string_ty	*s1;
X		string_ty	*s2;
X		table_ty	*hit[SIZEOF(table)];
X		int		j;
X
X		nhit = 0;
X		for (tp = table; tp < ENDOF(table); ++tp)
X		{
X			if (arglex_compare(tp->name, arglex_value.alv_string))
X				hit[nhit++] = tp;
X		}
X		switch (nhit)
X		{
X		case 0:
X			fatal
X			(
X				"version information name \"%s\" unknown",
X				arglex_value.alv_string
X			);
X	
X		case 1:
X			break;
X	
X		default:
X			s1 = str_from_c(hit[0]->name);
X			for (j = 1; j < nhit; ++j)
X			{
X				s2 = str_format("%S, %s", s1, hit[j]->name);
X				str_free(s1);
X				s1 = s2;
X			}
X			fatal("version information name \"%s\" ambiguous (%s)", arglex_value.alv_string, s1->str_text);
X		}
X		arglex();
X		func = hit[0]->func;
X	}
X	else
X		func = version_copyright;
X	if (arglex_token != arglex_token_eoln)
X	{
X		error
X		(
X			"misplaced \"%s\" command line argument",
X			arglex_value.alv_string
X		);
X		version_usage();
X	}
X
X	func();
X	/* trace((/ *{* /"}\n")); */
X}
X
X
Xstatic void version_help _((void));
X
Xstatic void
Xversion_help()
X{
X	static char *text[] = 
X	{
X"NAME",
X"	%s -VERSion - give version information",
X"",
X"SYNOPSIS",
X"	%s -VERSion [ <info-name> ]",
X"	%s -VERSion -Help",
X"",
X"DESCRIPTION",
X"	The %s -VERSion command is used to give version",
X"	information and conditions of use.",
X"",
X"	There are a number of possible info-names, as follow",
X"	(abbreviations as for command line options):",
X"",
X"	Copyright",
X"		The copyright notice for the %s program.  Version",
X"		information will also be printed.",
X"		This is the default.",
X"",
X"	Redistribution",
X"		Print the conditions of use and redistribution.",
X"",
X"	Warranty",
X"		Print the limited warranty.",
X"",
X"OPTIONS",
X"	The following options are understood:",
X"",
X"	-Help",
X"		This option may be used to obtain more",
X"		information about how to use the %s program.",
X"",
X"	All options are case insensitive.  Options may be",
X"	abbreviated; the abbreviation is the upper case letters.",
X"	Options and other command line arguments may be mixed",
X"	arbitrarily on the command line.",
X"",
X"ERRORS",
X"	It is an error if the info-name given is unknown.",
X"",
X"EXIT STATUS",
X"	The %s command will exit with a status of 1 on any",
X"	error.	The %s command will only exit with a status of",
X"	0 if there are no errors.",
X"",
X"COPYRIGHT",
X"	%C",
X"",
X"AUTHOR",
X"	%A",
X	};
X
X	help(text, SIZEOF(text), version_usage);
X}
X
X
Xvoid
Xversion()
X{
X	/* trace(("version()\n{\n"/ *}* /)); */
X	switch (arglex())
X	{
X	default:
X		version_main();
X		break;
X
X	case arglex_token_help:
X		version_help();
X		break;
X	}
X	/* trace((/ *{* /"}\n")); */
X}
END_OF_FILE
if test 17634 -ne `wc -c <'common/version.c'`; then
    echo shar: \"'common/version.c'\" unpacked with wrong size!
fi
# end of 'common/version.c'
fi
if test -f 'cook/id.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/id.c'\"
else
echo shar: Extracting \"'cook/id.c'\" \(15314 characters\)
sed "s/^X//" >'cook/id.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate the symbol table
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#include <stddef.h>
X#include <stdlib.h>
X
X#include <error.h>
X#include <help.h>
X#include <id.h>
X#include <mem.h>
X#include <option.h>
X#include <word.h>
X
X/*
X * identifier manipulation functions
X *
X * This file contains the functions for
X * assigning and referencing variables.
X */
X
X
X#define HEADER				\
X	string_ty	*id_name;	\
X	str_hash_ty	id_hash;	\
X	id		*id_next;	\
X	id_class_ty	id_class;
X
Xtypedef struct id id;
Xstruct id
X{
X	HEADER
X};
X
Xtypedef struct id_wlist id_wlist;
Xstruct id_wlist
X{
X	HEADER
X	wlist		id_value;
X};
X
Xtypedef struct id_bifp id_bifp;
Xstruct id_bifp
X{
X	HEADER
X	bifp		id_value;
X};
X
Xtypedef struct id_stat id_stat;
Xstruct id_stat
X{
X	HEADER
X	struct stat	id_value;
X};
X
Xtypedef struct id_int id_int;
Xstruct id_int
X{
X	HEADER
X	int		id_value;
X};
X
X	string_ty	*id_need;
X	string_ty	*id_younger;
X	string_ty	*id_target;
X	string_ty	*id_friend;
X	string_ty	*id_search_list;
Xstatic	id		**hash_table;
Xstatic	str_hash_ty	hash_modulus;
Xstatic	str_hash_ty	hash_cutover;
Xstatic	str_hash_ty	hash_cutover_mask;
Xstatic	str_hash_ty	hash_cutover_split_mask;
Xstatic	str_hash_ty	hash_split;
Xstatic	str_hash_ty	hash_load;
X
X
X/*
X * NAME
X *	id_initialize - start up symbol table
X *
X * SYNOPSIS
X *	void id_initialize(void);
X *
X * DESCRIPTION
X *	The id_initialize function is used to create the hash table.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	Assumes the str_initialize function has been called already.
X */
X
Xvoid
Xid_initialize()
X{
X	str_hash_ty	j;
X	wlist		wl;
X	string_ty	*s;
X
X	id_need = str_from_c("need");
X	id_younger = str_from_c("younger");
X	id_target = str_from_c("target");
X	id_friend = str_from_c("targets");
X	id_search_list = str_from_c("search_list");
X
X	hash_modulus = 1 << 8; /* MUST be a power of 2 */
X	hash_cutover = hash_modulus;
X	hash_split = hash_modulus - hash_cutover;
X	hash_cutover_mask = hash_cutover - 1;
X	hash_cutover_split_mask = (hash_cutover * 2) - 1;
X	hash_load = 0;
X	hash_table = (id **)mem_alloc(hash_modulus * sizeof(id*));
X	for (j = 0; j < hash_modulus; ++j)
X		hash_table[j] = 0;
X
X	/*
X	 * set the "version" predefined variable
X	 */
X	wl_zero(&wl);
X	s = str_from_c("version");
X	wl_append(&wl, s);
X	str_free(s);
X	s = str_from_c(version_stamp());
X	wl_append(&wl, s);
X	str_free(s);
X	s = str_from_c("version");
X	id_assign(s, ID_CLASS_VARIABLE, &wl);
X	str_free(s);
X	wl_free(&wl);
X
X	/*
X	 * set the "self" predefined variable
X	 */
X	s = str_from_c(progname);
X	wl_append(&wl, s);
X	str_free(s);
X	s = str_from_c("self");
X	id_assign(s, ID_CLASS_VARIABLE, &wl);
X	str_free(s);
X	wl_free(&wl);
X
X#ifdef __STDC__
X	/*
X	 * This symbol is only defined if we have a conforming C
X	 * compiler.  This is support for the C recipes.
X	 */
X	wl_append(&wl, str_true);
X	s = str_from_c("__STDC__");
X	id_assign(s, ID_CLASS_VARIABLE, &wl);
X	str_free(s);
X	wl_free(&wl);
X#endif
X	
X	/*
X	 * set the default search list
X	 * in the "search_list" predefined variable
X	 */
X	s = str_from_c(".");
X	wl_append(&wl, s);
X	str_free(s);
X	id_assign(id_search_list, ID_CLASS_VARIABLE, &wl);
X	wl_free(&wl);
X}
X
X
X/*
X * NAME
X *	split - reduce symbol table load
X *
X * SYNOPSIS
X *	void split(void);
X *
X * DESCRIPTION
X *	The split function is used to split symbols in the bucket indicated by
X *	the split point.  The symbols are split between that bucket and the one
X *	after the current end of the table.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	It is only sensable to do this when the symbol table load exceeds some
X *	reasonable threshold.  A threshold of 80% is suggested.
X */
X
Xstatic void split _((void));
X
Xstatic void
Xsplit()
X{
X	id		*p;
X	id		**ipp;
X	id		*p2;
X	str_hash_ty	index;
X
X	/*
X	 * get the list to be split across buckets 
X	 */
X	p = hash_table[hash_split];
X	hash_table[hash_split] = 0;
X
X	/*
X	 * increase the modulus by one
X	 */
X	hash_modulus++;
X	mem_change_size((char **)&hash_table, hash_modulus * sizeof(id*));
X	hash_table[hash_modulus - 1] = 0;
X	hash_split = hash_modulus - hash_cutover;
X	if (hash_split >= hash_cutover)
X	{
X		hash_cutover = hash_modulus;
X		hash_split = 0;
X		hash_cutover_mask = hash_cutover - 1;
X		hash_cutover_split_mask = (hash_cutover * 2) - 1;
X	}
X
X	/*
X	 * now redistribute the list elements
X	 *
X	 * It is important to preserve the order of the links because they can be
X	 * push-down stacks, and to simply add them to the head of the list will
X	 * reverse the order of the stack!
X	 */
X	while (p)
X	{
X		p2 = p;
X		p = p2->id_next;
X		p2->id_next = 0;
X
X		index = p2->id_hash & hash_cutover_mask;
X		if (index < hash_split)
X			index = p2->id_hash & hash_cutover_split_mask;
X		for (ipp = &hash_table[index]; *ipp; ipp = &(*ipp)->id_next)
X			;
X		*ipp = p2;
X	}
X}
X
X
X/*
X * NAME
X *	copy - copy a symbol value
X *
X * SYNOPSIS
X *	void copy(id *p, void *arg);
X *
X * DESCRIPTION
X *	The copy function is used to copy the passed value of a symbol into the
X *	storage of that symbol.
X *
X * RETURNS
X *	void
X */
X
Xstatic void copy _((id *, void *));
X
Xstatic void
Xcopy(p, arg)
X	id		*p;
X	void		*arg;
X{
X	switch ((int)p->id_class)
X	{
X	default:
X		fatal("illegal id class %d (bug)", p->id_class);
X
X	case ID_CLASS_VARIABLE:
X		{
X			id_wlist	*ip;
X			wlist		*value;
X
X			ip = (id_wlist *)p;
X			value = (wlist *)arg;
X			wl_zero(value);
X			wl_copy(value, &ip->id_value);
X		}
X		break;
X
X	case ID_CLASS_ALREADY:
X	case ID_CLASS_FLAGS:
X	case ID_CLASS_HASH_KEYWORD:
X	case ID_CLASS_PARSE_KEYWORD:
X		{
X			id_int		*ip;
X			int		*value;
X
X			ip = (id_int *)p;
X			value = (int *)arg;
X			*value = ip->id_value;
X		}
X		break;
X
X	case ID_CLASS_BUILTIN:
X		{
X			id_bifp		*ip;
X			bifp		*value;
X
X			ip = (id_bifp *)p;
X			value = (bifp *)arg;
X			*value = ip->id_value;
X		}
X		break;
X
X	case ID_CLASS_STAT:
X		{
X			id_stat		*ip;
X			struct stat	*value;
X
X			ip = (id_stat *)p;
X			value = (struct stat *)arg;
X			*value = ip->id_value;
X		}
X		break;
X	}
X}
X
X
X/*
X * NAME
X *	id_search - search for a variable
X *
X * SYNOPSIS
X *	int id_search(string_ty *name, wlist *value);
X *
X * DESCRIPTION
X *	Id_search is used to reference a variable.
X *
X * RETURNS
X *	If the variable has been defined, the function returns a non-zero value
X *	and the value is returned through the 'value' pointer.
X *	If the variable has not been defined, it returns zero,
X *	and 'value' is unaltered.
X *
X * CAVEAT
X *	The value returned from this function, when returned, is allocated
X *	in dynamic memory (it is a copy of the value remembered by this module).
X *	It is the responsibility of the caller to free it when finished with,
X *	by a wl_free() call.
X */
X
X/*VARARGS2*/
Xint
Xid_search(name, class, arg)
X	string_ty	*name;
X	id_class_ty	class;
X	void		*arg;
X{
X	str_hash_ty	myhash;
X	str_hash_ty	index;
X	id		*p;
X
X	myhash = name->str_hash + (int)class;
X	index = myhash & hash_cutover_mask;
X	if (index < hash_split)
X		index = myhash & hash_cutover_split_mask;
X	for (p = hash_table[index]; p; p = p->id_next)
X	{
X		if (p->id_class == class && str_equal(name, p->id_name))
X		{
X			copy(p, arg);
X			return 1;
X		}
X	}
X	return 0;
X}
X
X
X/*
X * NAME
X *	stomp - release symbol value
X *
X * SYNOPSIS
X *	void stomp(id *p);
X *
X * DESCRIPTION
X *	The stomp function is used to release the value of a symbol.
X *
X * RETURNS
X *	void
X */
X
Xstatic void stomp _((id *));
X
Xstatic void
Xstomp(p)
X	id		*p;
X{
X	switch ((int)p->id_class)
X	{
X	default:
X		fatal("illegal id class %d (bug)", p->id_class);
X
X	case ID_CLASS_VARIABLE:
X		{
X			id_wlist	*ip;
X
X			ip = (id_wlist*)p;
X			wl_free(&ip->id_value);
X		}
X		break;
X
X	case ID_CLASS_ALREADY:
X	case ID_CLASS_BUILTIN:
X	case ID_CLASS_FLAGS:
X	case ID_CLASS_HASH_KEYWORD:
X	case ID_CLASS_PARSE_KEYWORD:
X	case ID_CLASS_STAT:
X		break;
X	}
X}
X
X
X/*
X * NAME
X *	assign - set value of symbol
X *
X * SYNOPSIS
X *	void assign(id *p, void *arg);
X *
X * DESCRIPTION
X *	The assign function is used to change the value of a symbol.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	The value is not released first, so use stomp if necessary.
X */
X
Xstatic void assign _((id *, void *));
X
Xstatic void
Xassign(p, arg)
X	id		*p;
X	void		*arg;
X{
X	switch ((int)p->id_class)
X	{
X	default:
X		fatal("illegal id class %d (bug)", p->id_class);
X
X	case ID_CLASS_VARIABLE:
X		{
X			id_wlist	*ip;
X			wlist		*value;
X
X			value = (wlist *)arg;
X			ip = (id_wlist *)p;
X			wl_copy(&ip->id_value, value);
X		}
X		break;
X
X	case ID_CLASS_ALREADY:
X	case ID_CLASS_FLAGS:
X	case ID_CLASS_HASH_KEYWORD:
X	case ID_CLASS_PARSE_KEYWORD:
X		{
X			id_int		*ip;
X			int		*value;
X
X			value = (int *)arg;
X			ip = (id_int *)p;
X			ip->id_value = *value;
X		}
X		break;
X
X	case ID_CLASS_BUILTIN:
X		{
X			id_bifp		*ip;
X			bifp		value;
X
X			value = (bifp)arg;
X			ip = (id_bifp *)p;
X			ip->id_value = value;
X		}
X		break;
X
X	case ID_CLASS_STAT:
X		{
X			id_stat		*ip;
X			struct stat	*value;
X
X			value = (struct stat *)arg;
X			ip = (id_stat*)p;
X			ip->id_value = *value;
X		}
X		break;
X	}
X}
X
X
X/*
X * NAME
X *	size_by_class - determine symbol size
X *
X * SYNOPSIS
X *	void size_by_class(id_class_ty class);
X *
X * DESCRIPTION
X *	The size_by_class function is used to determine the correct size to
X *	allocate for symbol storage.
X *
X * RETURNS
X *	size_t: the correct size to malloc.
X *
X * CAVEAT
X *	Never malloc(sizeof(id)) as this will be too small.
X */
X
Xstatic size_t size_by_class _((id_class_ty));
X
Xstatic size_t
Xsize_by_class(class)
X	id_class_ty	class;
X{
X	switch ((int)class)
X	{
X	default:
X		fatal("illegal id class %d (bug)", class);
X
X	case ID_CLASS_VARIABLE:
X		return sizeof(id_wlist);
X
X	case ID_CLASS_BUILTIN:
X		return sizeof(id_bifp);
X
X	case ID_CLASS_STAT:
X		return sizeof(id_stat);
X
X	case ID_CLASS_ALREADY:
X	case ID_CLASS_FLAGS:
X	case ID_CLASS_HASH_KEYWORD:
X	case ID_CLASS_PARSE_KEYWORD:
X		return sizeof(id_int);
X	}
X}
X
X
X/*
X * NAME
X *	id_assign - assign a variable
X *
X * SYNOPSIS
X *	void id_assign(string_ty *name, id_class_ty class, ...);
X *
X * DESCRIPTION
X *	Id_assign is used to assign a value to a given variable.
X *
X * CAVEAT
X *	The name and value are copied by id_assign, so the user may
X *	modify or free them at a later date without affecting the
X *	variable.
X */
X
X/*VARARGS2*/
Xvoid
Xid_assign(name, class, arg)
X	string_ty	*name;
X	id_class_ty	class;
X	void		*arg;
X{
X	str_hash_ty	myhash;
X	str_hash_ty	index;
X	id		*p;
X
X	myhash = name->str_hash + (int)class;
X	index = myhash & hash_cutover_mask;
X	if (index < hash_split)
X		index = myhash & hash_cutover_split_mask;
X
X	for (p = hash_table[index]; p; p = p->id_next)
X	{
X		if (p->id_class == class && str_equal(name, p->id_name))
X		{
X			stomp(p);
X			assign(p, arg);
X			return;
X		}
X	}
X
X	p = (id *)mem_alloc_clear(size_by_class(class));
X	p->id_name = str_copy(name);
X	p->id_next = hash_table[index];
X	p->id_class = class;
X	p->id_hash = myhash;
X	hash_table[index] = p;
X	assign(p, arg);
X
X	hash_load++;
X	while (hash_load * 10 >= hash_modulus * 8)
X		split();
X}
X
X
X/*
X * NAME
X *	id_assign_push - assign a variable, remembering old value
X *
X * SYNOPSIS
X *	void id_assign_push(string_ty *name, id_class_ty class, ...);
X *
X * DESCRIPTION
X *	Id_assign is used to assign a value to a given variable.
X *
X * CAVEAT
X *	The name and value are copied by id_assign, so the user may
X *	modify or free them at a later date without affecting the
X *	variable.
X */
X
X/*VARARGS2*/
Xvoid
Xid_assign_push(name, class, arg)
X	string_ty	*name;
X	id_class_ty	class;
X	void		*arg;
X{
X	str_hash_ty	myhash;
X	str_hash_ty	index;
X	id		*p;
X
X	myhash = name->str_hash + (int)class;
X	index = myhash & hash_cutover_mask;
X	if (index < hash_split)
X		index = myhash & hash_cutover_split_mask;
X
X	p = (id *)mem_alloc_clear(size_by_class(class));
X	p->id_name = str_copy(name);
X	p->id_next = hash_table[index];
X	p->id_class = class;
X	p->id_hash = myhash;
X	hash_table[index] = p;
X	assign(p, arg);
X
X	hash_load++;
X	while (hash_load * 10 >= hash_modulus * 8)
X		split();
X}
X
X
X/*
X * NAME
X *	id_delete - delete a variable
X *
X * SYNOPSIS
X *	void id_delete(string_ty *name, id_class_ty class);
X *
X * DESCRIPTION
X *	Id_delete is used to delete variables.
X *
X * CAVEAT
X *	No complaint is made if the variable does not exist,
X *	since the user wanted it to not exist.
X */
X
Xvoid
Xid_delete(name, class)
X	string_ty	*name;
X	id_class_ty	class;
X{
X	str_hash_ty	myhash;
X	str_hash_ty	index;
X	id		**idpp;
X
X	myhash = name->str_hash + (int)class;
X	index = myhash & hash_cutover_mask;
X	if (index < hash_split)
X		index = myhash & hash_cutover_split_mask;
X
X	idpp = &hash_table[index];
X	for (;;)
X	{
X		id	*p;
X
X		p = *idpp;
X		if (!p)
X			break;
X		if (p->id_class == class && str_equal(name, p->id_name))
X		{
X			stomp(p);
X			str_free(p->id_name);
X			*idpp = p->id_next;
X			free(p);
X			hash_load--;
X			break;
X		}
X		idpp = &p->id_next;
X	}
X}
X
X
X/*
X * NAME
X *	id_dump - dump id table
X *
X * SYNOPSIS
X *	void id_dump(char *title, int mask);
X *
X * DESCRIPTION
X *	The id_dump function is used to dump the contents of the id table.
X *	The title will be used to indicate why the table was dumped.  The mask
X *	may be used to selectively dump the table, 0 means everything, bits
X *	correspond directly with ID_CLASS defines.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	This function is only available when symbol DEBUG is defined.
X */
X
X#ifdef DEBUG
X
Xvoid
Xid_dump(s, mask)
X	char		*s;
X	int		mask;
X{
X	int		j;
X	id		*p;
X
X	if (!mask)
X		mask = ~0;
X	error("id table %s = {", s);
X	for (j = 0; j < hash_modulus; ++j)
X	{
X		for (p = hash_table[j]; p; p = p->id_next)
X		{
X			if (mask & (1<< (int)p->id_class))
X			switch ((int)p->id_class)
X			{
X			default:
X				error
X				(
X					"name = \"%s\", class = %d",
X					p->id_name->str_text,
X					p->id_class
X				);
X				break;
X
X			case ID_CLASS_VARIABLE:
X				{
X					id_wlist	*ip;
X					string_ty	*str;
X		
X					ip = (id_wlist*)p;
X					str = wl2str(&ip->id_value, 0, 32767);
X					error
X					(
X				    "name = \"%s\", class = %d, value = \"%s\"",
X						p->id_name->str_text,
X						p->id_class,
X						str->str_text
X					);
X					str_free(str);
X				}
X				break;
X		
X			case ID_CLASS_ALREADY:
X			case ID_CLASS_FLAGS:
X			case ID_CLASS_HASH_KEYWORD:
X			case ID_CLASS_PARSE_KEYWORD:
X				{
X					id_int		*ip;
X		
X					ip = (id_int*)p;
X					error
X					(
X					"name = \"%s\", class = %d, value = %d",
X						p->id_name->str_text,
X						p->id_class,
X						ip->id_value
X					);
X				}
X				break;
X		
X			case ID_CLASS_BUILTIN:
X				{
X					id_bifp		*ip;
X		
X					ip = (id_bifp*)p;
X					error
X					(
X				      "name = \"%s\", class = %d, value = %08X",
X						p->id_name->str_text,
X						p->id_class,
X						ip->id_value
X					);
X				}
X				break;
X		
X			case ID_CLASS_STAT:
X				{
X					id_stat		*ip;
X		
X					ip = (id_stat*)p;
X					error
X					(
X		"name = \"%s\", class = %d, value = {ino = %04X, mtime = %08X}",
X						p->id_name->str_text,
X						p->id_class,
X						ip->id_value.st_ino,
X						ip->id_value.st_mtime
X					);
X				}
X				break;
X			}
X		}
X	}
X	error("}");
X}
X
X#endif
END_OF_FILE
if test 15314 -ne `wc -c <'cook/id.c'`; then
    echo shar: \"'cook/id.c'\" unpacked with wrong size!
fi
# end of 'cook/id.c'
fi
if test -f 'cook/match.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/match.c'\"
else
echo shar: Extracting \"'cook/match.c'\" \(13567 characters\)
sed "s/^X//" >'cook/match.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to perform recipe pattern matching
X *
X * This is in the inner loop, so it must perform well.
X * A free list of match structures is maintained to avoid malloc calls;
X * malloc is only called when this free list is empty.
X *
X * The tough part about designing a pattern matcher for something like cook is
X * that the patterns must be reversible.  That is, it must be possible to use
X * the same string both as a pattern to be matched against and as a template
X * for building a string once a pattern has matched.  Rather like the
X * difference between the left and right sides of an editor search-and-replace
X * command using the same description for both the search pattern and the
X * replace template.  This is why classic regular expressions have not been
X * used.  They tend to be slow to match, too.
X *
X * This matcher has eleven match "fields", referenced as % and %0 to %9.
X * The % character can be escaped as %%.  The % and %1 to %9 forms match any
X * character except '/'.  The %0 form matches all characters, but must be
X * either empty, or have whole path components, including the trailing '/' on
X * each component.  A few examples will make this clearer:
X *	"%.c" matches "fred.c" with %="fred"
X *	"%.c" failes to match "snot/fred.c"
X *	"%1/%2.c"matches "snot/fred.c" with %1="snot" and %2="fred"
X *	"%1/%2.c" fails to match "etc/boo/fred.c"
X *	"%0%5.c" matches "fred.c" with %0="" and %5="fred"
X *	"%0%6.c" matches "snot/fred.c" with %0="snot/" and %6="fred"
X *	"%0%7.c" matches "etc/boo/fred.c" with %0="etc/boo/" and %7="fred"
X *	"/usr/%1/%1%2/%3.%2%4" matches "/usr/man/man1/fred.1x" with %1="man",
X *		%2="1", %3="fred" and %4="x".
X * The %0 behaviour is designed to allow patterns to range over subtrees in a
X * controlled manner.  Note that the use of this sort of pattern in a recipe
X * will result in deeper seraches than the naive recipe designer would expect.
X */
X
X#include <stddef.h>
X#include <string.h>
X#include <stdlib.h>
X
X#include <main.h>
X#include <str.h>
X#include <match.h>
X#include <error.h>
X#include <mem.h>
X#include <trace.h>
X
X
X#define ABSENT_MARKER ((string_ty *)-1)
X
Xstatic match_ty *match_free_list;
Xstatic match_ty *stack;
X
X
X/*
X * NAME
X *	illegal_pattern - complain
X *
X * SYNOPSIS
X *	void illegal_pattern(char *s);
X *
X * DESCRIPTION
X *	The illegal_pattern function is used to complain about errors in
X *	pattern secifications.
X *
X * RETURNS
X *	void
X */
X
Xstatic void illegal_pattern _((char *, int));
X
Xstatic void
Xillegal_pattern(s, why)
X	char		*s;
X	int		why;
X{
X	if (why < 0)
X	{
X		fatal
X		(
X			"illegal position of '%c0' in \"%s\" pattern",
X			MATCH_CHAR,
X			s
X		);
X	}
X	if (why >= 10)
X		fatal("illegal use of '%c' in \"%s\" pattern", MATCH_CHAR, s);
X	fatal("illegal use of '%c%d' in \"%s\" pattern", MATCH_CHAR, why, s);
X}
X
X
X/*
X * NAME
X *	match_alloc - allocate match structure
X *
X * SYNOPSIS
X *	match_ty *match_alloc(void);
X *
X * DESCRIPTION
X *	The match_alloc function is used to allocate a match structure.
X *	The returned structure will be all zeros.
X *
X * RETURNS
X *	match_ty * - a pointer to the match structure in dynamic memory
X *
X * CAVEAT
X *	When finished with it should be disposed of by calling the match_free
X *	function.
X */
X
Xstatic match_ty *match_alloc _((void));
X
Xstatic match_ty *
Xmatch_alloc()
X{
X	match_ty	*result;
X	int		j;
X
X	if (match_free_list)
X	{
X		result = match_free_list;
X		match_free_list = result->next;
X	}
X	else
X		result = (match_ty *)mem_alloc(sizeof(match_ty));
X	for (j = 0; j < SIZEOF(result->fill); ++j)
X		result->fill[j] = 0;
X	result->next = 0;
X	return result;
X}
X
X
X/*
X * NAME
X *	match_free - dispose of match structure
X *
X * SYNOPSIS
X *	void match_free(match_ty *);
X *
X * DESCRIPTION
X *	The match_free function is used to dispose of a match structure
X *	allocated by the match_alloc function.
X *
X * RETURNS
X *	void
X */
X
Xvoid
Xmatch_free(field)
X	match_ty	*field;
X{
X	int		j;
X
X	trace(("match_free(field = %08X)\n{\n"/*}*/, field));
X	for (j = 0; j < SIZEOF(field->fill); ++j)
X	{
X		if (field->fill[j])
X		{
X			str_free(field->fill[j]);
X			field->fill[j] = 0;
X		}
X	}
X	field->next = match_free_list;
X	match_free_list = field;
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	matcher - match pattern to string
X *
X * SYNOPSIS
X *	int matcher(char *original_patn, char *patn, char *str, match_ty *field);
X *
X * DESCRIPTION
X *	The matcher function is used to match up a pattern with a string,
X *	filling in the fields as it goes.
X *
X * RETURNS
X *	int: zero if does not match, nonzero if does match.
X *
X * CAVEAT
X *	The field structure is not allocated here.
X */
X
Xstatic int matcher _((char *, char *, char *, match_ty *));
X
Xstatic int
Xmatcher(op, p, s, field)
X	char		*op;	/* original pattern */
X	char		*p;
X	char		*s;
X	match_ty	*field;
X{
X	size_t		index;
X	string_ty	*sp;
X	int		result;
X
X	trace(("matcher(op = %08lX, p = %08lX, s = %08lX, field = %08X)\n{\n"/*}*/, op, p, s, field));
X	trace_string(op);
X	trace_string(p);
X	trace_string(s);
X	for (;;)
X	{
X		switch (*p)
X		{
X		case 0:
X			result = !*s;
X			goto ret;
X
X		case MATCH_CHAR:
X			if (p[1] == MATCH_CHAR)
X			{
X				if (*s++ != MATCH_CHAR)
X				{
X					result = 0;
X					goto ret;
X				}
X				p += 2;
X				break;
X			}
X			if (p[1] >= '0' && p[1] <= '9')
X			{
X				index = p[1] - '0';
X				p += 2;
X			}
X			else
X			{
X				index = 10;
X				++p;
X			}
X			if
X			(
X				!index
X			&&
X				(
X					(p - 2 != op && p[-3] != '/')
X				||
X					(!*p || *p == '/')
X				)
X			)
X				illegal_pattern(op, -1);
X			sp = field->fill[index];
X			if (sp)
X			{
X				char	*q;
X
X				q = sp->str_text;
X				while (*q)
X				{
X					if (*q++ != *s++)
X					{
X						result = 0;
X						goto ret;
X					}
X				}
X			}
X			else
X			{
X				char *q;
X
X				if (index)
X				{
X					q = strchr(s, '/');
X					if (!q)
X						q = s + strlen(s);
X					if (q == s)
X					{
X						result = 0;
X						goto ret;
X					}
X				}
X				else
X				{
X					q = strrchr(s, '/');
X					if (!q || *s == '/')
X						q = s;
X					else
X						q++;
X				}
X				while (q >= s)
X				{
X					field->fill[index] = str_n_from_c(s, q - s);
X					trace_long_unsigned(index);
X					trace_string(field->fill[index]->str_text);
X					if (matcher(op, p, q, field))
X					{
X						result = 1;
X						goto ret;
X					}
X					str_free(field->fill[index]);
X					field->fill[index] = 0;
X					--q;
X					if (!index)
X						while (q >= s)
X						{
X							if (q > s && q[-1] == '/')
X								break;
X							--q;
X						}
X				}
X				result = 0;
X				goto ret;
X			}
X			break;
X
X		default:
X			if (*p++ != *s++)
X			{
X				result = 0;
X				goto ret;
X			}
X			break;
X		}
X	}
Xret:
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	match - attempt to
X *
X * SYNOPSIS
X *	match_ty *match(string_ty *pattern, string_ty *string);
X *
X * DESCRIPTION
X *	The match function is used to match a pattern with a string.
X *	The matching fields are filled in in the returned structure.
X *
X * RETURNS
X *	match_ty *: a pointer to a match structure in dynamic memory with the
X *	match fields set as appropriate.  A NULL pointer is returned if the
X *	string does not match the pattern.
X *
X * CAVEAT
X *	The match structure should be releaseed by calling match_free.,
X */
X
Xmatch_ty *
Xmatch(pattern, string)
X	string_ty	*pattern;
X	string_ty	*string;
X{
X	match_ty	*field;
X
X	trace(("match(pattern = %08lX, string = %08lX)\n{\n"/*}*/, pattern, string));
X	trace_string(pattern->str_text);
X	trace_string(string->str_text);
X	field = match_alloc();
X	if (!matcher(pattern->str_text, pattern->str_text, string->str_text, field))
X	{
X		match_free(field);
X		field = 0;
X	}
X	trace(("retrurn %08lX;\n", field));
X	trace((/*{*/"}\n"));
X	return field;
X}
X
X
X/*
X * NAME
X *	reconstruct - make string from pattern
X *
X * SYNOPSIS
X *	string_ty *reconstruct(string_ty *pattern, match_ty *field);
X *
X * DESCRIPTION
X *	The reconstruct function is used to rebuild a string from a replacement
X *	pattern and the match field values.
X *
X * RETURNS
X *	string_ty *
X *
X * CAVEAT
X *	It is a fatal error for the pattern to reference fields not set by the
X *	pattern match which created the fields match structure.
X */
X
Xstring_ty *
Xreconstruct(pattern, field)
X	string_ty	*pattern;
X	match_ty	*field;
X{
X	static char	*tmp;
X	static size_t	tmplen;
X	size_t		length;
X	char		*p;
X	string_ty	*s;
X	char		*pos;
X	int		index;
X
X	trace(("reconstruct(pattern = %08lX, field = %08X)\n{\n"/*}*/, pattern, field));
X	trace_string(pattern->str_text);
X	length = 0;
X	for (p = pattern->str_text; *p; ++p)
X	{
X		if (*p == MATCH_CHAR)
X		{
X			if (p[1] == MATCH_CHAR)
X			{
X				++length;
X				++p;
X				continue;
X			}
X			if (p[1] >= '0' && p[1] <= '9')
X			{
X				index = p[1] - '0';
X				++p;
X			}
X			else
X				index = 10;
X			s = field->fill[index];
X			if (!s)
X				illegal_pattern(pattern->str_text, index);
X			length += s->str_length;
X		}
X		else
X			++length;
X	}
X
X	if (!tmp)
X	{
X		tmplen = length;
X		if (tmplen < 16)
X			tmplen = 16;
X		tmp = mem_alloc(tmplen);
X	}
X	else
X	{
X		if (tmplen < length)
X		{
X			tmplen = length;
X			mem_change_size(&tmp, tmplen);
X		}
X	}
X
X	pos = tmp;
X	for (p = pattern->str_text; *p; ++p)
X	{
X		if (*p == MATCH_CHAR)
X		{
X			if (p[1] == MATCH_CHAR)
X			{
X				*pos++ = MATCH_CHAR;
X				++p;
X				continue;
X			}
X			if (p[1] >= '0' && p[1] <= '9')
X			{
X				index = p[1] - '0';
X				++p;
X			}
X			else
X				index = 10;
X			s = field->fill[index];
X			memcpy(pos, s->str_text, s->str_length);
X			pos += s->str_length;
X		}
X		else
X			*pos++ = *p;
X	}
X
X	s = str_n_from_c(tmp, length);
X	trace_string(s->str_text);
X	trace(("return %08lX;\n", s));
X	trace((/*{*/"}\n"));
X	return s;
X}
X
X
X/*
X * NAME
X *	match_push - patch match fields
X *
X * SYNOPSIS
X *	void match_push(match_ty *field);
X *
X * DESCRIPTION
X *	The match_push function is used to push a pattern onto the stack of
X *	match fields.  A NULL pointer may be pushed.  This mechanism is used by
X *	the chef (cook.c) to indicate implicit and explicit recipe replacements.
X *
X * RETURNS
X *	void
X */
X
Xvoid
Xmatch_push(field)
X	match_ty	*field;
X{
X	trace(("match_push(field = %08X)\n{\n"/*}*/, field));
X	if (!field)
X	{
X		field = match_alloc();
X		field->fill[0] = ABSENT_MARKER;
X	}
X	field->next = stack;
X	stack= field;
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	match_top - top of match stack
X *
X * SYNOPSIS
X *	match_ty *match_top(void);
X *
X * DESCRIPTION
X *	The match function is used to indicate the top of the match stack.
X *
X * RETURNS
X *	match_ty * - a pointer to a match strcuture, or NULL if the stack is
X *	empty, or a NULL was pashed to mak an exlpicit recipe.
X */
X
Xmatch_ty *
Xmatch_top()
X{
X	match_ty	*result;
X
X	if (stack && stack->fill[0] == ABSENT_MARKER)
X		result = 0;
X	else
X		result = stack;
X	return result;
X}
X
X
X/*
X * NAME
X *	match_pop - shorten stack
X *
X * SYNOPSIS
X *	match_ty *match_pop(void);
X *
X * DESCRIPTION
X *	The match_pop function is used to pop a match structure from the match
X *	stack.
X *
X * RETURNS
X *	match_ty * - a pointer to a match strcuture, or NULL if the stack is
X *	empty, or a NULL was pashed to mak an exlpicit recipe.
X *
X * CAVEAT
X *	It is an error for the stack to be empty.
X */
X
Xmatch_ty *
Xmatch_pop()
X{
X	match_ty	*field;
X
X	trace(("match_pop()\n{\n"/*}*/));
X	assert(stack);
X	field = stack;
X	stack = stack->next;
X	if (field->fill[0] == ABSENT_MARKER)
X	{
X		free(field);
X		field = 0;
X	}
X	trace(("return %08X;\n", field));
X	trace((/*{*/"}\n"));
X	return field;
X}
X
X
X/*
X * NAME
X *	wl_match - find a pattern in a word list
X *
X * SYNOPSIS
X *	match_ty *wl_match(wlist *pattern, string_ty *target);
X *
X * DESCRIPTION
X *	Wl_match is used to determine whether any one of the words in
X *	the wordlist (wlp) match the pattern given.
X *
X * RETURNS
X *	A zero is returned if not one of the words matches the pattern;
X *	otherwise a pointer to a "match structure" is returned,
X *	in a similar fashion to match().
X *
X * CAVEAT
X *	The information returned resides in dynamic memory.
X *	It is the responsibility of the
X *	caller to ensure that it is freed when it is finished with,
X *	by a call to match_free();
X */
X
Xmatch_ty *
Xwl_match(pattern, target)
X	wlist		*pattern;
X	string_ty	*target;
X{
X	int		j;
X	match_ty	*retval;
X
X	for (j = 0; j < pattern->wl_nwords; j++)
X	{
X		retval = match(pattern->wl_word[j], target);
X		if (retval)
X			return retval;
X	}
X	return 0;
X}
X
X
X/*
X * NAME
X *	wl_reconstruct - reconstruct a word list
X *
X * SYNOPSIS
X *	void wl_reconstruct(wlist *to, wlist *from, match_ty *field)
X *
X * DESCRIPTION
X *	Wl_reconstruct is used to reconstruct an entire word list,
X *	sort of the convers of wl_match().
X *
X * RETURNS
X *	'To' is a word list of reconstructed strings.
X *
X * CAVEAT
X *	It is the responsibility of the caller to ensire that the
X *	reconstructed word list in 'to' is freed when finished with,
X *	by a call to wl_free().
X */
X
Xvoid
Xwl_reconstruct(to, from, field)
X	wlist		*to;
X	wlist		*from;
X	match_ty	*field;
X{
X	int		j;
X
X	wl_zero(to);
X	for (j = 0; j < from->wl_nwords; j++)
X	{
X		string_ty *s;
X
X		s = reconstruct(from->wl_word[j], field);
X		wl_append(to, s);
X		str_free(s);
X	}
X}
END_OF_FILE
if test 13567 -ne `wc -c <'cook/match.c'`; then
    echo shar: \"'cook/match.c'\" unpacked with wrong size!
fi
# end of 'cook/match.c'
fi
if test -f 'cook/stmt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/stmt.c'\"
else
echo shar: Extracting \"'cook/stmt.c'\" \(13734 characters\)
sed "s/^X//" >'cook/stmt.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manage statement trees
X *
X * This file contains the functions for manipulating statement trees,
X * allocating, interpreting and releasing.
X */
X
X#include <stddef.h>
X#include <string.h>
X#include <time.h>
X
X#include <cook.h>
X#include <env.h>
X#include <error.h>
X#include <expr.h>
X#include <id.h>
X#include <main.h>
X#include <match.h>
X#include <mem.h>
X#include <option.h>
X#include <os.h>
X#include <stmt.h>
X#include <trace.h>
X#include <word.h>
X
X
X/*
X *  NAME
X *	stmt_alloc - allocate a statement structure
X *
X *  SYNOPSIS
X *	stmt *stmt_alloc(void);
X *
X *  DESCRIPTION
X *	Allocates a statement structure, initializing it to zeroes.
X *
X *  RETURNS
X *	A pointer to the dynamically allocated space is returned.
X *
X *  CAVEAT
X *	It is the responsibility of the caller to ensure that the space is
X *	freed when finished with, by a call to stmt_free().
X */
X
Xstmt *
Xstmt_alloc()
X{
X	stmt		*sp;
X
X	trace(("stmt_alloc()\n{\n"/*}*/));
X	sp = (stmt *)mem_alloc_clear(sizeof(stmt));
X	sp->s_references = 1;
X	trace(("return %08lX;\n", sp));
X	trace((/*{*/"}\n"));
X	return sp;
X}
X
X
X/*
X *  NAME
X *      stmt_copy - copy statement tree
X *
X *  SYNOPSIS
X *      stmt *stmt_copy(stmt *);
X *
X *  DESCRIPTION
X *      The stmt_copy function is used to make a copy of a statement tree.
X *
X *  RETURNS
X *      stmt* - pointer to the root of the copied statement tree in dynamic
X *      memory.
X *
X *  CAVEAT
X *      Use the stmt_free function to release the tree when finished with.
X */
X
Xstmt *
Xstmt_copy(sp)
X	stmt		*sp;
X{
X	trace(("stmt_copy(sp = %08X)\n{\n"/*}*/, sp));
X	sp->s_references++;
X	trace(("return %08X;\n", sp));
X	trace((/*{*/"}\n"));
X	return sp;
X}
X
X
X/*
X *  NAME
X *	stmt_free - free a statement tree
X *
X *  SYNOPSIS
X *	void stmt_free(stmt *sp);
X *
X *  DESCRIPTION
X *	Frees a statement structure after it has been executed.
X *
X *  CAVEAT
X *	It is assumed that the statement tree is in dynamic memory.
X */
X
Xvoid
Xstmt_free(sp)
X	stmt		*sp;
X{
X	trace(("stmt_free(sp = %08X)\n{\n"/*}*/, sp));
X	assert(sp);
X	sp->s_references--;
X	if (sp->s_references > 0)
X		goto ret;
X	assert(sp->s_references == 0);
X	switch ((int)sp->s_op)
X	{
X	default:
X		fatal("bad statement selector %d (bug)", sp->s_op);
X
X	case OP_ASSIGN:
X		el_free(&sp->s_assign.a_name);
X		el_free(&sp->s_assign.a_value);
X		break;
X
X	case OP_COMMAND:
X		el_free(&sp->s_cmd.c_args);
X		if (sp->s_cmd.c_input)
X			expr_free(sp->s_cmd.c_input);
X		break;
X
X	case OP_TOUCH:
X	case OP_UNSETENV:
X		el_free(&sp->s_cmd.c_args);
X		break;
X
X	case OP_COMPOUND:
X		sl_free(&sp->s_list);
X		break;
X
X	case OP_SET:
X	case OP_LOOPSTOP:
X	case OP_NOP:
X	case OP_FAIL:
X	case OP_FAIL_DK:
X		break;
X
X	case OP_IF:
X		expr_free(sp->s_if.sif_cond);
X		stmt_free(sp->s_if.sif_true);
X		stmt_free(sp->s_if.sif_false);
X		break;
X
X	case OP_LOOP:
X		stmt_free(sp->s_loop);
X		break;
X
X	case OP_RECIPE:
X		el_free(&sp->s_recipe.sr_target);
X		el_free(&sp->s_recipe.sr_need);
X		el_free(&sp->s_recipe.sr_need2);
X		if (sp->s_recipe.sr_precondition)
X			expr_free(sp->s_recipe.sr_precondition);
X		if (sp->s_recipe.sr_action)
X			stmt_free(sp->s_recipe.sr_action);
X		if (sp->s_recipe.sr_use_action)
X			stmt_free(sp->s_recipe.sr_use_action);
X		str_free(sp->s_recipe.sr_position.pos_name);
X		break;
X	}
X	mem_free((char *)sp);
Xret:
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X *  NAME
X *	stmt_eval - evaluate a statement
X *
X *  SYNOPSIS
X *	int stmt_eval(stmt *sp);
X *
X *  DESCRIPTION
X *	Stmt_eval is used to evaluate a statement tree.
X *	It performs the actions so implied.
X *
X *  RETURNS
X *	The value returned indicates why the statement evaluation terminated.
X *	    STMT_OK	normal termination, success
X *	    STMT_LSTOP	a loopstop statement was encountered
X *	    STMT_ERROR	an execution error in a command was encountered
X *	There is also the posibility of internal subroutines;
X *	If an when this happens, an additional STMT_RET value could be returned.
X *
X *  CAVEAT
X *	The explicit and implicit recipes need to copy the statement
X *	bound to them.
X *
X *	The explicit and implicit recipes need to overwrite recipes with
X *	identical target and prerequisite lists. The best place to do this
X *	is in rl_append().
X */
X
Xint
Xstmt_eval(sp)
X	stmt		*sp;
X{
X	int		status;
X
X	trace(("stmt_eval(sp = %08X)\n{\n"/*}*/, sp));
X	assert(sp);
X	if (desist)
X	{
X		status = STMT_ERROR;
X		goto ret;
X	}
X	status = STMT_OK;
X	switch ((int)sp->s_op)
X	{
X	default:
X		error("bad statement selector %d (bug)", sp->s_op);
X		option_set_errors();
X		status = STMT_ERROR;
X		break;
X
X	case OP_ASSIGN:
X		{
X			wlist		name;
X			wlist		value;
X			static string_ty	*setenv_word;
X			static string_ty	*mtime_word;
X
X			/*
X			 * The grammar has the assignment as an expression list.
X			 * Evaluate the expression list into a word list.
X			 * This word list is the value to assign.
X			 */
X			if (!setenv_word)
X				setenv_word = str_from_c("setenv");
X			if (!mtime_word)
X				mtime_word = str_from_c("mtime");
X			wl_zero(&name);
X			if (el2wl(&name, &sp->s_assign.a_name))
X			{
X				status = STMT_ERROR;
X				break;
X			}
X			switch (name.wl_nwords)
X			{
X			case 0:
X				error("lefthand side of assignment is empty");
X				option_set_errors();
X				status = STMT_ERROR;
X				break;
X
X			case 1:
X				if (el2wl(&value, &sp->s_assign.a_value))
X				{
X					status = STMT_ERROR;
X					break;
X				}
X				id_assign
X				(
X					name.wl_word[0],
X					ID_CLASS_VARIABLE,
X					&value
X				);
X				wl_free(&value);
X				break;
X
X			case 2:
X				if (str_equal(name.wl_word[0], setenv_word))
X				{
X					string_ty *s;
X
X					if (el2wl(&value, &sp->s_assign.a_value))
X					{
X						status = STMT_ERROR;
X						break;
X					}
X					s = wl2str(&value, 0, 32767);
X					wl_free(&value);
X					env_set
X					(
X						name.wl_word[1]->str_text,
X						s->str_text
X					);
X					str_free(s);
X					break;
X				}
X#if 0
X				if (str_equal(name.wl_word[0], mtime_word))
X				{
X					mtime_pattern
X					(
X						name.wl_word[1],
X						&sp->s_assign.a_value
X					);
X					break;
X				}
X#endif
X				/* fall through... */
X
X			default:
X				error
X				(
X			     "lefthand side of assignment is more than one word"
X				);
X				option_set_errors();
X				status = STMT_ERROR;
X				break;
X			}
X			wl_free(&name);
X		}
X		break;
X
X	case OP_UNSETENV:
X		{
X			wlist		wl;
X			int		j;
X
X			wl_zero(&wl);
X			if (el2wl(&wl, &sp->s_cmd.c_args))
X			{
X				status = STMT_ERROR;
X				break;
X			}
X			if (!wl.wl_nwords)
X			{
X				error("unsetenv was given no words");
X				option_set_errors();
X				status = STMT_ERROR;
X			}
X			for (j = 0; j < wl.wl_nwords; ++j)
X				env_unset(wl.wl_word[j]->str_text);
X			wl_free(&wl);
X		}
X		break;
X
X	case OP_COMMAND:
X		{
X			wlist	wl;
X			int		metering;
X
X			/*
X			 * The grammar has the command as an expression list.
X			 * Evaluate the expression list into a word list.
X			 * This word list is the command to execute.
X			 */
X			if (el2wl(&wl, &sp->s_cmd.c_args))
X			{
X				status = STMT_ERROR;
X				break;
X			}
X			cook_flags(sp->s_cmd.c_flags, OPTION_LEVEL_EXECUTE);
X			if (!option_test(OPTION_SILENT))
X			{
X				string_ty *cp;
X
X				/*
X				 * If the command has not been silenced,
X				 * form it into a string and echo it.
X				 */
X				cp = wl2str(&wl, 0, 32767);
X				error("%s", cp->str_text);
X				str_free(cp);
X				metering = option_test(OPTION_METER);
X			}
X			else
X			{
X				/* no metering if silent */
X				metering = 0;
X			}
X			if (option_test(OPTION_ACTION))
X			{
X				string_ty *s;
X
X				if (sp->s_cmd.c_input)
X				{
X					wlist	 input;
X
X					wl_zero(&input);
X					if (expr_eval(&input, sp->s_cmd.c_input))
X					{
X						status = STMT_ERROR;
X						break;
X					}
X					s = wl2str(&input, 0, 32767);
X					wl_free(&input);
X				}
X				else
X					s = 0;
X				if (metering)
X					os_meter_begin();
X				switch (os_execute(&wl, s))
X				{
X				case -1:
X					status = STMT_ERROR;
X					break;
X
X				case 0:
X					break;
X
X				default:
X					if (!option_test(OPTION_ERROK))
X						status = STMT_ERROR;
X					break;
X				}
X				if (metering)
X					os_meter_end();
X				if (s)
X					str_free(s);
X			}
X			if (option_test(OPTION_INVALIDATE_STAT_CACHE))
X			{
X				int		j;
X
X				for (j = 0; j < wl.wl_nwords; ++j)
X					if (os_clear_stat(wl.wl_word[j]))
X						status = STMT_ERROR;
X			}
X			wl_free(&wl);
X			option_undo_level(OPTION_LEVEL_EXECUTE);
X		}
X		break;
X
X	case OP_SET:
X		cook_flags(sp->s_cmd.c_flags, OPTION_LEVEL_COOKBOOK);
X		break;
X
X	case OP_FAIL:
X		status = STMT_ERROR;
X		break;
X
X	case OP_FAIL_DK:
X		status = STMT_BACKTRACK;
X		break;
X
X	case OP_COMPOUND:
X		{
X			int		j;
X
X			for (j = 0; j < sp->s_list.sl_nstmts; j++)
X			{
X				status = stmt_eval(sp->s_list.sl_stmt[j]);
X				if (status != STMT_OK)
X					break;
X			}
X		}
X		break;
X
X	case OP_IF:
X		switch (expr_eval_condition(sp->s_if.sif_cond))
X		{
X		case -1:
X			status = STMT_ERROR;
X			break;
X
X		case 0:
X			status = stmt_eval(sp->s_if.sif_false);
X			break;
X
X		default:
X			status = stmt_eval(sp->s_if.sif_true);
X			break;
X		}
X		break;
X
X	case OP_LOOP:
X		do
X			status = stmt_eval(sp->s_loop);
X		while
X			(status == STMT_OK);
X		if (status == STMT_LSTOP)
X			status = STMT_OK;
X		break;
X
X	case OP_LOOPSTOP:
X		status = STMT_LSTOP;
X		break;
X
X	case OP_NOP:
X		break;
X
X	case OP_RECIPE:
X		{
X			recipe		r;
X			int		j;
X			int		imp;
X
X			/*
X			 * A recipe in the grammar has expression lists for
X			 * both targets and prerequisites.  These must be
X			 * evaluated into word lists when the recipes are
X			 * instanciated.
X			 */
X			if (el2wl(&r.r_target, &sp->s_recipe.sr_target))
X			{
X				status = STMT_ERROR;
X				break;
X			}
X			if (r.r_target.wl_nwords == 0)
X			{
X				error
X				(
X			"%s: %d: attempt to instanciate recipe with no targets",
X					sp->s_recipe.sr_position.pos_name
X						->str_text,
X					sp->s_recipe.sr_position.pos_line
X				);
X				option_set_errors();
X				status = STMT_ERROR;
X				break;
X			}
X			el_copy(&r.r_need, &sp->s_recipe.sr_need);
X			el_copy(&r.r_need2, &sp->s_recipe.sr_need2);
X			r.r_precondition =
X				(
X					sp->s_recipe.sr_precondition
X				?
X					expr_copy(sp->s_recipe.sr_precondition)
X				:
X					(expr*)0
X				);
X			r.r_flags = sp->s_recipe.sr_flags;
X			r.r_action =
X				(
X					sp->s_recipe.sr_action
X				?
X					stmt_copy(sp->s_recipe.sr_action)
X				:
X					(stmt*)0
X				);
X			r.r_use_action =
X				(
X					sp->s_recipe.sr_use_action
X				?
X					stmt_copy(sp->s_recipe.sr_use_action)
X				:
X					(stmt*)0
X				);
X			r.r_tag = recipe_tag();
X			r.r_multiple = sp->s_recipe.sr_multiple;
X
X			/*
X			 * is it implicit or explicit?
X			 */
X			imp = 0;
X			for (j = 0; j < r.r_target.wl_nwords; ++j)
X			{
X				if (strchr(r.r_target.wl_word[j]->str_text, MATCH_CHAR))
X				{
X					imp = 1;
X					break;
X				}
X			}
X
X			/*
X			 * add it to the list
X			 */
X			if (imp)
X			{
X				rl_append(&implicit, &r);
X#if 0
X				if (!r.r_need.el_nexprs)
X				{
X					error
X					(
X				     "%s: %d: implicit recipe must have action",
X						sp->s_recipe.sr_position
X							.pos_name->str_text,
X						sp->s_recipe.sr_position
X							.pos_line
X					);
X					option_set_errors();
X				}
X#endif
X			}
X			else
X				rl_append(&explicit, &r);
X
X			/*
X			 * emit trace information, if enabled
X			 */
X			if (option_test(OPTION_TRACE))
X			{
X				error
X				(
X				    "%s: %d: %s recipe %d instanciated (trace)",
X					sp->s_recipe.sr_position.pos_name
X						->str_text,
X					sp->s_recipe.sr_position.pos_line,
X					imp ? "implicit" : "explicit",
X					r.r_tag
X				);
X			}
X		}
X		break;
X
X	case OP_TOUCH:
X		{
X			wlist	 wl;
X
X			/*
X			 * The grammar has the command as an expression list.
X			 * Evaluate the expression list into a word list.
X			 * This word list is the command to execute.
X			 */
X			if (el2wl(&wl, &sp->s_cmd.c_args))
X			{
X				status = STMT_ERROR;
X				break;
X			}
X			if (!option_test(OPTION_SILENT))
X			{
X				string_ty *s;
X
X				/*
X				 * If the command has not been silenced,
X				 * form it into a string and echo it.
X				 */
X				s = wl2str(&wl, 0, 32767);
X				error("touch %s", s->str_text);
X				str_free(s);
X			}
X			if (option_test(OPTION_ACTION))
X			{
X				int		j;
X
X				for (j = 0; j < wl.wl_nwords; j++)
X					if (os_touch(wl.wl_word[j]))
X						status = STMT_ERROR;
X			}
X			wl_free(&wl);
X		}
X		break;
X	}
Xret:
X	trace(("return %d;\n", status));
X	trace((/*{*/"}\n"));
X	return status;
X}
X
X
X/*
X *  NAME
X *	sl_append - append to a statement list
X *
X *  SYNOPSIS
X *	void sl_append(slist *slp, stmt *sp);
X *
X *  DESCRIPTION
X *	Sl_append is used to append a statement to a statement list.
X */
X
Xvoid
Xsl_append(sl, s)
X	slist		*sl;
X	stmt		*s;
X{
X	trace(("sl_append(sl = %08X, s = %08X)\n{\n"/*}*/, sl, s));
X	*(stmt **)
X	enlarge
X	(
X		&sl->sl_nstmts,
X		(char**)&sl->sl_stmt,
X		sizeof(stmt *)
X	) = stmt_copy(s);
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X *  NAME
X *      sl_free - free statement list
X *
X *  SYNOPSIS
X *      void sl_free(slist *);
X *
X *  DESCRIPTION
X *      The sl_free function is used to free the list of statement trees.
X *
X *  RETURNS
X *      void
X */
X
Xvoid
Xsl_free(sl)
X	slist		*sl;
X{
X	int		j;
X
X	trace(("sl_free(sl = %08X)\n{\n"/*}*/, sl));
X	for (j = 0; j < sl->sl_nstmts; ++j)
X		stmt_free(sl->sl_stmt[j]);
X	if (sl->sl_nstmts)
X		mem_free((char *)sl->sl_stmt);
X	sl->sl_nstmts = 0;
X	sl->sl_stmt = 0;
X	trace((/*{*/"}\n"));
X}
X
Xvoid
Xsl_zero(slp)
X	slist		*slp;
X{
X	slp->sl_nstmts = 0;
X	slp->sl_stmt = 0;
X}
END_OF_FILE
if test 13734 -ne `wc -c <'cook/stmt.c'`; then
    echo shar: \"'cook/stmt.c'\" unpacked with wrong size!
fi
# end of 'cook/stmt.c'
fi
echo shar: End of archive 7 \(of 11\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
