Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v26i213: cook-1.4 - a file construction tool (like "make"), Part05/11
Sender: unix-sources-moderator@efficacy.home.vix.com
Approved: WhoAmI@efficacy.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 26, Issue 213
Archive-Name: cook-1.4/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 11)."
# Contents:  aux/BUILDING.man aux/Howto.cook aux/Makefile.sh
#   common/error.c cook/glob.c cook/parse.y doc/builtin doc/system
#   roffpp/preprocess.c
# Wrapped by vixie@efficacy.home.vix.com on Tue May  4 01:36:39 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'aux/BUILDING.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aux/BUILDING.man'\"
else
echo shar: Extracting \"'aux/BUILDING.man'\" \(9227 characters\)
sed "s/^X//" >'aux/BUILDING.man' <<'END_OF_FILE'
X'\" t
X.\"	cook - file construction tool
X.\"	Copyright (C) 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: source of the BUILDING file
X.\"
X.TH building cook
X.if n .hy 0
X.if n .ad l
X.if n .nr IN 8n
X.SH NAME
Xcook \- a file construction tool
X.SH SPACE REQUIREMENTS
XYou will need about 5MB to unpack and build the
X.I cook
Xprogram.
XYour milage may vary.
X.br
X.ne 1i
X.SH SITE CONFIGURATION
XThe file
X.I common/conf.h
Xneeds to be created to match your site.
XSelect an appropriate file from the
X.I conf
Xdirectory.
XThe files in this directory are named for the various systems
Xencountered to date by the author.
XThe file most closely resembling your system should be copied into the
X.I common/conf.h
Xfile.
XYou can copy it or use a symbolic link;
Xcopying is recommended because you may need to edit.
X.PP
XA file which may require editing is the
X.I Makefile
Xfile.
XThe first few lines contain comments describing what may require changing.
XIn general these changes will relate to the name of your favorite
XC compiler,
Xand where it keeps its include files.
X.br
X.ne 1i
X.SH KNOWN SYSTEMS
XThis distribution of
X.I cook
Xis known to build on the following systems:
X.TP 8n
XSCO 3.2
X.br
XYou will need to set the compiler to
X.I rcc
Xin the
X.I Makefile
Xfile.
X.TP 8n
XSunOS 4.1
X.br
XThe native
X.IR cc (1)
Xand also
X.IR gcc (1)
Xare known to work.
XThe appropriate configuration is contained in the
X.I conf/SunOS-4.1
Xfile.
X.TP 8n
XConvexOS 10.0
X.br
XThe native
X.IR cc (1)
Xis known to work.
XThe appropriate configuration is contained in the
X.I conf/ConvexOS-10
Xfile.
X.TP
Xdgux 5.4.1
X.br
XThe native
X.I cc (1)
Xcompiler is known to work.
XThe appropriate configuration is contained in the
X.I conf/dgux-5.4.1
Xfile.
X.TP
XPyramid SMP DC/OSx 1.0-92b023
X.br
XThis system is revolting!
XThe Berkeley
X.I cc (1)
Xcompiler variant is known to work.
XThe appropriate configuration is contained in the
X.I conf/dcosx
Xfile.
XMake sure you read the
X.I Makefile
Xfile very carefully.
X.TP
XULTRIX 4.2
X.br
XThe native
X.I cc (1)
Xcompiler is known to work.
XThe appropriate configuration is contained in the
X.I conf/ULTRIX-4.2
Xfile.
XMake sure you set the
X.I SHELL
Xmacro in the
X.I Makefile
Xfile.
X.PP
XIf any of the above systems do not work for you,
Xafter you have double-checked everything,
Xthe author wants to know.
X.SH UNKNOWN SYSTEMS
XPlease let the author know of any other systems you get
X.I cook
Xworking on,
Xand the modifications necessary.
XPlease include the changes to the
X.I Makefile
Xfile,
Xthe relevant
X.I common/conf.h
Xfile used,
Xand the output of the "uname -rs" command.
X.PP
XThe
X.I cook
Xprogram was developed using gcc,
Xhowever this is not the default in the
X.I Makefile
Xfile.
XThe
X.I cook
Xprogram source attempts to use ANSI C features without compromising the ability
Xto be compiled on older C compilers.
XFunctions mandated by the ANSI C standard are used,
Xbecause many systems provided them, one way or another.
XPlease let the author know of any others you think should
Xbe added to the
X.I common/ansi.c
Xfile.
X.PP
XYou may need to use some ANSI C header files which the
X.I cook
Xcode uses,
Xbut which some systems (as yet) fail to provide.
XYou will find lines at the top of the
X.I Makefile
Xfile similar to
X.RS
X.ft CW
XH = -I/usr/include -Ih
X.ft R
X.RE
XChange this to suit your system and your compiler.
XThe "h" directory must be searched last as it is
Xintended to suplement your system,
Xnot replace it.
X.PP
XYou will need to check the include files in the "h" directory
Xto see that they are suitable for your system.
XYou may want to delete any that your system already has.
X.br
X.ne 1i
X.SH BUILDING COOK
XAll you should need to do is use the
X.RS
X.ft CW
X.nf
X% make
X\fI\&...lots of output...\fP
X%
X.fi
X.ft R
X.RE
Xcommand and wait.
XWhen this finishes you should see a directory called
X.I bin
Xcontaining three files:
X.IR cook ,
X.IR c_incl
Xand
X.IR find_libs .
XThe
X.I c_incl
Xprogram is a utility distributed with
X.I cook
Xwhich examines C files and determines all the files it includes
Xdirectly and indirectly.
XThe
X.I find_libs
Xprogram is a utility distributed with
X.I cook
Xwhich tracks doen the names of library files,
Xgiven cc-style library options (-L and -l).
X.br
X.ne 1i
X.SH TESTING
XThe
X.I cook
Xprogram comes with a test suite.
XTo run this test suite, use the command
X.RS
X.ft CW
X.nf
X% make sure
X\fI\&...lots of output...\fP
XPassed All Tests
X%
X.fi
X.ft R
X.RE
X.PP
XThe tests take a few seconds each,
Xwith a few very fast,
Xand a couple very slow,
Xbut it varies greatly depending on your CPU.
X.PP
XIf all went well, the message
X.RS
X.ft CW
XPassed All Tests
X.ft R
X.RE
Xshould appear at the end of the make.
X.br
X.ne 1i
X.SH INSTALLING COOK
XPut the
X.I cook
Xprogram and utilities somewhere where users will automatically pick it up,
Xsuch as in the
X.I /usr/local/bin
Xdirectory.
XUse the command
X.RS
X.ft CW
X.nf
X# cp bin/* /usr/local/bin
X#
X.fi
X.ft R
X.RE
X.PP
XThe manuals can be installed using the commands
X.RS
X.ft CW
X.nf
X# sh man1/install.sh \fI/usr/local/man/man1\fP
X#
X.fi
X.ft R
X.RE
XThis is very site-specific.
XYou can install the manuals in a different directory
Xby using a different last argument.
X.PP
XBy default,
X.I cook
Xis configured to use
X.I /usr/local/lib/cook
Xas the place it stores various system recipe files
X.RS
X.ft CW
X.nf
X# mkdir /usr/local/lib/cook
X# cp lib/* /usr/local/lib/cook
X#
X.fi
X.ft R
X.RE
XThese paths are only example, where to install things tends
Xto be very system specific, and I won't even try to guess.
XControl of the placement of this directory may be found in the first
Xfew lines of the
X.I Makefile
Xfile.
X.PP
XAll of the above install can be done automatically,
Xusing the "\f(CWmake install\fP" command.
XControl of the directories used may be found in the first
Xfew lines of the
X.I Makefile
Xfile.
X.br
X.ne 1i
X.SH PRINTED MANUALS
XThis distribution contains the sources to
Xall of the documentation for
X.IR cook .
XThe author used the GNU groff package
Xand a postscript printer to prepare the documentation.
XIf you do not have this software,
Xyou will need to substitute commands appropriate to your site.
X.PP
XTo print copies of the
X.I README
Xand
X.I BUILDING
Xfiles,
Xthe following commands may be used
X.RS
X.ft CW
X.nf
X% cd aux
X% groff -s -t -man *.man | lpr
X% cd ..
X%
X.fi
X.ft R
X.RE
XThis will produce about 4 pages.
XThe "-s" flag means preprocess with
X.IR soelim (1),
Xand the "-t" flag means preprocess with
X.IR tbl (1).
X.PP
XTo print copies of the manual entries,
Xthe following commands may be used
X.RS
X.ft CW
X.nf
X% cd man1
X% groff -s -t -man *.1 | lpr
X% cd ..
X%
X.fi
X.ft R
X.RE
XThis will produce about 8 pages.
XThe "-s" flag means preprocess with
X.IR soelim (1),
Xand the "-t" flag means preprocess with
X.IR tbl (1).
X.PP
XTo print a copy of the Reference Manual,
Xthe following commands may be used
X.RS
X.ft CW
X.nf
X% cd doc
X% groff -s -t -mm refman.t | lpr
X% cd ..
X%
X.fi
X.ft R
X.RE
XThis will produce about 35 pages.
XThe "-s" flag means preprocess with
X.IR soelim (1),
Xthe "-t" flag means preprocess with
X.IR tbl (1).
XAlternatively,
Xyou could get a PostScript copy of the Reference Manual from the archive site.
X.br
X.ne 1i
X.SH GETTING HELP
XIf you need assistance with the
X.I cook
Xprogram,
Xplease do not hesitate to contact the author at
X.RS
X.ft CW
XPeter Miller <pmiller@bmr.gov.au>
X.ft R
X.RE
XAny and all feedback is welcome.
X.PP
XWhen reporting problems,
Xplease include the version number
Xgiven by the
X.RS
X.ft CW
X.nf
X% cook -version
Xcook version \fIa.b.cccc\fP
X\&...
X%
X.fi
X.ft R
X.RE
Xcommand.
X.PP
XIn the
X.I common/main.h
Xfile, there is a define of
X.I DEBUG
Xin comments.
XIf the comments are removed,
Xextensive debugging is turned on.
XThis causes some performance loss,
Xbut performs much run-time checking
Xand adds the
X.B -TRACIng
Xcommand line option.
X.PP
XWhen the
X.B -TRACing
Xoption is followed by one or more file names,
Xit turns on execution traces in those source files.
XIt is best to put this option on the end of the command,
Xso that the names of the files to be traced are not confused
Xwith any other filenames or strings on the command line.
X.br
X.ne 2i
X.SH COPYRIGHT
X.I cook
Xversion
X.so ../doc/version.so
X.br
XCopyright
X.if n (C)
X.if t \(co
X1988, 1989, 1990, 1991, 1992, 1993 Peter Miller.
X.br
XAll rights reserved.
X.PP
XThe
X.I cook
Xpackage is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY;
Xwithout even the implied warranty of MERCHANTABILITY or
XFITNESS FOR A PARTICULAR PURPOSE.
XSee the GNU General Public License for more details.
X.PP
XIt should be in the
X.I LICENSE
Xfile included with this distribution.
X.br
X.ne 1i
X.SH AUTHOR
X.TS
Xtab(;);
Xl l l.
XPeter Miller;UUCP;uunet!munnari!bmr.gov.au!pmiller
X\f(CW/\e/\e*\fP;Internet;pmiller@bmr.gov.au
X.TE
END_OF_FILE
if test 9227 -ne `wc -c <'aux/BUILDING.man'`; then
    echo shar: \"'aux/BUILDING.man'\" unpacked with wrong size!
fi
# end of 'aux/BUILDING.man'
fi
if test -f 'aux/Howto.cook' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aux/Howto.cook'\"
else
echo shar: Extracting \"'aux/Howto.cook'\" \(10497 characters\)
sed "s/^X//" >'aux/Howto.cook' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: instructions to cook, how to build project
X */
X
X
X/*
X * You may want to change some of these options.
X * ([debug] must be defined, even if empty, use comments.)
X *
X * If you want to turn the DEBUG compile flag on,
X * edit the common/main.h file.
X */
Xdebug = /* -g */ ;
Xoption_flags = -D\'LIBDIR\=\"/usr/local/lib/cook\"\';
X
X/*
X * Make sure the [project], [change] and [version] variables are set.
X */
X#ifndef project
Xecho "The [project] variable was not set from the command line." set silent;
Xecho "If you want to do a build with is not a development build" set silent;
Xecho "or an integration build, use the make command, not cook." set silent;
Xfail;
X#endif
X#ifndef change
Xecho "The [change] variable was not set from the command line." set silent;
Xecho "If you want to do a build with is not a development build" set silent;
Xecho "or an integration build, use the make command, not cook." set silent;
Xfail;
X#endif
X#ifndef version
Xecho "The [version] variable was not set from the command line." set silent;
Xecho "If you want to do a build with is not a development build" set silent;
Xecho "or an integration build, use the make command, not cook." set silent;
Xfail;
X#endif
X
X/*
X * find the baseline
X */
Xif [match_mask %1C%2 [version]] then
X{
X	baseline = [collect aegis -cd -bl -p [project]];
X	search_list = . [baseline];
X}
X
X/*
X * The source files.
X * This is given to us by aegis.
X */
Xvs_file = common/patchlevel.h;
Xchange_files =
X	[collect aegis -l chafil -ter -p [project] -c [change]]
X	[vs_file] doc/version.so
X	;
Xproject_files =
X	[collect aegis -l profil -ter -p [project] -c [change]]
X	;
Xsource_files =
X	[sort [stringset [project_files] [change_files]]]
X	;
Xcommon_obj =
X	[fromto common/%.c common/%.o [match_mask common/%.c [source_files]]]
X	;
Xcook_obj =
X	[fromto cook/%.y cook/%.gen.o [match_mask cook/%.y [source_files]] ]
X	[fromto cook/%.c cook/%.o [match_mask cook/%.c [source_files]] ]
X	[common_obj]
X	;
Xc_incl_obj =
X	[fromto c_incl/%.c c_incl/%.o [match_mask c_incl/%.c [source_files]] ]
X	[common_obj]
X	;
Xfind_libs_obj =
X	[fromto
X		find_libs/%.c
X		find_libs/%.o
X		[match_mask find_libs/%.c [source_files]]
X	]
X	[common_obj]
X	;
Xroffpp_obj =
X	[fromto roffpp/%.c roffpp/%.o [match_mask roffpp/%.c [source_files]] ]
X	[common_obj]
X	;
Xcooktime_obj =
X	[fromto
X		cooktime/%.y
X		cooktime/%.gen.o
X		[match_mask cooktime/%.y [source_files]]
X	]
X	[fromto
X		cooktime/%.c
X		cooktime/%.o
X		[match_mask cooktime/%.c [source_files]]
X	]
X	[common_obj]
X	;
Xlib_srcs =
X	[match_mask lib/% [source_files]]
X	;
X
X/*
X * how to compile C sources
X */
Xcc = cc;
Xcc_flags = -O [debug];
Xcc_include_flags = ;
X
X/*
X * this next section is for gcc
X *	comment it out if you don't have gcc
X *
X * The gcc include files MUST be first.
X */
Xcc = gcc;
Xcc_include_flags = -I/usr/local/lib/gcc-include [cc_include_flags];
Xcc_flags = [cc_flags] -ansi -Wall -Wstrict-prototypes -Wmissing-prototypes;
X
X/*
X * include files from the common directory.
X */
Xcc_include_flags = [cc_include_flags] [prepost "-I" "/common" [search_list]];
X
X/*
X * Need to look at the ANSI include files which come with cook,
X * but only after the system files.
X * (Since they supplement system files, not replace them.)
X * /
Xcc_include_flags = [cc_include_flags] [prepost "-I" "/h" [search_list]];
X */
X
X
X/*
X * Build %.o from %.c
X */
X%1/%2.o: %1/%2.c: [collect c_incl -eia -s [stringset [prepost "-I" "/%1"
X	[search_list]] [cc_include_flags]] [resolve %1/%2.c]]
X{
X	if [not [exists %1]] then
X		mkdir %1
X			set clearstat;
X	if [exists %1/%2.o] then
X		rm %1/%2.o
X			set clearstat;
X	if [defined %2_flags] then
X		extra = [%2_flags];
X	else
X		extra = ;
X	[cc] [cc_flags] [extra] [stringset [prepost "-I" "/%1" [search_list]]
X		[cc_include_flags]] -c [resolve %1/%2.c];
X	mv %2.o %1/%2.o;
X}
X
X
X/*
X * How to use yacc sources.
X */
Xyacc = yacc;
Xyacc_flags = ;
X
X%1/%2.gen.c %1/%2.gen.h: %1/%2.y
X{
X	if [not [exists %1]] then
X		mkdir %1
X			set clearstat;
X	if [exists %1/%2.list] then
X		rm %1/%2.list
X			set clearstat;
X	if [exists y.output] then
X		rm y.output
X			set clearstat;
X	if [exists %1/%2.gen.c] then
X		rm %1/%2.gen.c
X			set clearstat;
X	if [exists %1/%2.gen.h] then
X		rm %1/%2.gen.h
X			set clearstat;
X	[yacc] -d [yacc_flags] [resolve %1/%2.y];
X	sed -e \'s/\[yY\]\[yY\]/%2_/g\' y.tab.c > %1/%2.gen.c;
X	rm y.tab.c;
X	sed -e \'s/\[yY\]\[yY\]/%2_/g\' y.tab.h > %1/%2.gen.h;
X	rm y.tab.h;
X	if [exists y.output] then
X		mv y.output %1/%2.list
X			set clearstat;
X}
X
X
X/*
X * The default recipe
X */
Xall = doc.targets bin/cook bin/c_incl bin/find_libs bin/roffpp bin/cooktime;
X
X/*
X * Integration builds also make the shar files for distribution.
X */
Xif [not [defined baseline]] then
X	all = [all] archive/Part.01.Z archive/[project].tar.Z
X		archive/[project].patch.Z;
X
Xall: [all];
X
X
X/*
X * build the programs
X */
Xbin/%: [%_obj]
X{
X	if [not [exists bin]] then
X		mkdir bin
X			set clearstat;
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X
X	[cc] -o [target] [resolve [%_obj]];
X	chmod og\=u-w [target];
X}
X
X
X/*
X * The version stamp is to be updated for every 
X * integration and development build.
X * It is be be empty for archaeology builds (this isn't ideal,
X * but avoids, for now, the distinction between archaeology fr the
X * most recent build (probably for distribution) and for regression
X * testing).
X *
X * The dependency on . means it will be re-built a little more
X * often than strictly essential.
X */
X
X#ifndef baseline
X
Xif [exists [vs_file]] then
X	rm [vs_file]
X		set clearstat;
Xif [exists doc/version.so] then
X	rm doc/version.so
X		set clearstat;
X
X#endif
X
Xif [not [exists [vs_file]]] then
X{
X	if [not [exists [dirname [vs_file]]]] then
X		mkdir [dirname [vs_file]]
X			set clearstat;
X	echo "'#define PATCHLEVEL \""[version]"\"'" > [vs_file]
X		set clearstat;
X}
Xif [not [exists doc/version.so]] then
X{
X	if [not [exists doc]] then
X		mkdir doc
X			set clearstat;
X	echo "'"[version]"'" > doc/version.so
X		set clearstat;
X	cooktime -m 2-Jan-70 doc/version.so;
X}
X
X
X/*
X * These recipes are only expected to be exercised in an integration build.
X * They will work sort-of-OK for a development build, but are incapable
X * of constructing a useful development build Makefile.
X */
XMakefile: aux/Makefile.sh aux/Makefile.awk [vs_file]
X{
X	if [exists Makefile] then
X		rm Makefile
X			set clearstat;
X	sh [resolve aux/Makefile.sh] [resolve [source_files]]
X		| awk -f [resolve aux/Makefile.awk] > Makefile;
X}
X
Xsource_file_order =
X	README
X	[sort
X		[stringset
X			BUILDING MANIFEST Makefile CHANGES [source_files]
X		-
X			README
X		]
X	]
X	;
X
Xarchive/Part.01.Z: [source_file_order]
X{
X	if [not [exists archive]] then
X		mkdir archive
X			set clearstat;
X	parts = [glob "archive/Part.*"];
X	if [parts] then
X		rm [parts]
X			set clearstat;
X	/* assumes shar.3.49 available */
X	shar -n[project] -a -c -oarchive/Part -L50
X		-s "'Peter Miller <pmiller@bmr.gov.au>'"
X		[resolve [source_file_order]];
X	compress -v archive/Part.*;
X}
X
Xarchive/[project].tar.Z: [source_file_order]
X{
X	if [not [exists archive]] then
X		mkdir archive
X			set clearstat;
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X	tar cf - [resolve [source_file_order]] |
X	tardy -unu 0 -gnu 0 -una Peter -gna Miller -p [project] -ms 0644 -mc 022
X		> archive/[project].tar;
X	compress -v archive/[project].tar;
X}
X
XCHANGES: aux/CHANGES.sh [vs_file]
X{
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X	sh [resolve aux/CHANGES.sh] [project] > [target];
X}
X
X%: aux/%.man
X{
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X	roffpp [prepost "-I" "/doc" [search_list]] [resolve [need]]
X		| groff -Tascii -t -P-hub -man > [target];
X}
X
X/*
X * link to the correct config file
X */
X
X#ifndef baseline
X
Xif [exists common/conf.h] then
X	rm common/conf.h
X		set clearstat;
X
X#endif
X
Xif [not [exists common/conf.h]] then
X{
X	if [not [exists common]] then
X		mkdir common;
X	uname-os = [collect uname -s];
X	uname-rel = [collect uname -r];
X	echo "'#include <../conf/"[uname-os]-[uname-rel]">'" > common/conf.h;
X	cooktime -m 2-Jan-70 common/conf.h
X		set clearstat;
X}
X
X/*
X * formatting documents and manual entries
X */
Xdoc.targets: cat txt special;
X
X/*
X * manual entries
X */
Xcat = [fromto man%1/%2.%1 cat%1/%2.%1 [match_mask man%1/%2.%1 [source_files]]];
Xcat: [cat];
X
Xcat%1/%2.%1: man%1/%2.%1: [collect c_incl -r -eia [prepost "-I" "/man%1"
X	[search_list]] [resolve man%1/%2.%1]]
X{
X	if [not [exists cat%1]] then
X		mkdir cat%1
X			set clearstat;
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X	roffpp [prepost "-I" "/man%1" [search_list]] [resolve man%1/%2.%1]
X		| groff -Tascii -t -P-h -man > [target];
X}
X
X
X/*
X * user manuals
X */
X
Xtxt = [fromto doc/%.t doc/%.ps.Z [match_mask doc/%.t [source_files]]];
Xtxt: [txt];
X
Xdoc/%.ps.Z: doc/%.t: [collect c_incl -r -eia [prepost "-I" "/doc"
X	[search_list]] [resolve doc/%.t]]
X{
X	if [not [exists doc]] then
X		mkdir doc
X			set clearstat;
X	if [exists [target]] then
X		rm -f [target]
X			set clearstat;
X	roffpp [prepost "-I" "/doc" [search_list]] [resolve doc/%.t]
X		| groff -p -t -mm | compress > doc/%.ps.Z; 
X}
X
X
X/*
X * specials
X */
X
Xspecial = [fromto aux/%.man % [match_mask aux/%.man [source_files]]];
Xspecial: [special];
X
X%: aux/%.man: [collect c_incl -r -eia [prepost "-I" "/aux" [search_list]]
X	[resolve aux/%.man]]
X{
X	if [exists [target]] then
X		rm -f [target]
X			set clearstat;
X	roffpp [prepost "-I" "/aux" [search_list]] [resolve aux/%.man]
X		| tbl | nroff -man > %; 
X}
X
XMANIFEST: [source_files]
X{
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X	sh [resolve aux/MANIFEST.sh] [resolve [source_file_order]] > [target];
X}
X
Xarchive/[project].patch.Z: [source_file_order]
X{
X	if [not [exists archive]] then
X		mkdir archive
X			set clearstat;
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X	sh [resolve aux/patches.sh] [project] [change] | compress > [target];
X}
END_OF_FILE
if test 10497 -ne `wc -c <'aux/Howto.cook'`; then
    echo shar: \"'aux/Howto.cook'\" unpacked with wrong size!
fi
# end of 'aux/Howto.cook'
fi
if test -f 'aux/Makefile.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aux/Makefile.sh'\"
else
echo shar: Extracting \"'aux/Makefile.sh'\" \(8871 characters\)
sed "s/^X//" >'aux/Makefile.sh' <<'END_OF_FILE'
X#! /bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: shell script to generate Makefile file
X#
Xcook_files=
Xc_incl_files=
Xfind_libs_files=
Xroffpp_files=
Xcooktime_files=
Xcommon=
Xtest_files=
Xclean_files=core
Xecho  "#"
Xecho  "# You may need to change this for your system."
Xecho  "# The \`\`h'' directory supplements your system, not replacing it."
Xecho  "# The first variation is for gcc when it isn't the native complier,"
Xecho  "# the second variation is for systems with missing ANSI C include files,"
Xecho  "# the third variation is for conforming ANSI C implementations."
Xecho  "#"
Xecho  "# H = -I/usr/local/lib/gcc-include -I/usr/include -Ih"
Xecho  "# H = -I/usr/include -Ih"
Xecho  "H ="
Xecho  "# H =				# SunOS"
Xecho  "# H =				# ConvexOS"
Xecho  "# H =				# dgux"
Xecho  "# H =				# dcosx"
Xecho  "# H =				# ULTRIX"
Xecho  ""
Xecho  "#"
Xecho  "# the name of the compiler to use"
Xecho  "#"
Xecho  "CC = cc"
Xecho  "# CC = gcc"
Xecho  "# CC = cc			# SunOS"
Xecho  "# CC = cc			# ConvexOS"
Xecho  "# CC = rcc			# SCO"
Xecho  "# CC = cc			# dgux"
Xecho  "# CC = /usr/ucb/cc		# dcosx"
Xecho  "# CC = cc			# ULTRIX"
Xecho
Xecho  "#"
Xecho  "# The compiler flags to use, except for include path."
Xecho  "#"
Xecho  "CFLAGS = -O"
Xecho  "# CFLAGS = -g"
Xecho  "# CFLAGS = -O			# SunOS"
Xecho  "# CFLAGS = -O			# ConvexOS"
Xecho  "# CFLAGS = -O			# dgux"
Xecho  "# CFLAGS = -O -Xt -U__STDC__	# dcosx"
Xecho  "# CFLAGS = -O -Wall -ansi	# gcc"
Xecho  "# CFLAGS = -O			# ULTRIX"
Xecho  ""
Xecho  "#"
Xecho  "# where to put the library directory"
Xecho  "#"
Xecho  "LIB = /usr/local/lib/cook"
Xecho  ""
Xecho  "#"
Xecho  "# where to put the executables"
Xecho  "#"
Xecho  "BIN = /usr/local/bin"
Xecho  ""
Xecho  "#"
Xecho  "# where to put the manuals"
Xecho  "#"
Xecho  "MAN = /usr/local/man"
Xecho  ""
Xecho  "#"
Xecho  "# Which yacc to use"
Xecho  "#"
Xecho  "YACC = yacc"
Xecho  "# YACC = bison -y		# GNU"
Xecho  "# YACC = byacc			# Berkeley yacc"
Xecho  ""
Xecho  "#"
Xecho  "# extra libraries required for your system"
Xecho  "#"
Xecho  "LIBRARIES ="
Xecho  "# LIBRARIES =			# SunOS"
Xecho  "# LIBRARIES =			# ConvexOS"
Xecho  "# LIBRARIES =			# dgux"
Xecho  "# LIBRARIES = -lucb		# dcosx"
Xecho  "# LIBRARIES =			# ULTRIX"
Xecho  "# LIBRARIES = -lbsd"
Xecho  ""
Xecho  "#"
Xecho  "# shell to use to run tests and commands"
Xecho  "#	Make sure there are no spaces after the definition,"
Xecho  "#	many falavours of make(1) can't cope with them."
Xecho  "#"
Xecho  "SHELL = /bin/sh"
Xecho  "# SHELL = /bin/sh		# SunOS"
Xecho  "# SHELL = /bin/sh		# ConvexOS"
Xecho  "# SHELL = /bin/sh		# dgux"
Xecho  "# SHELL = /bin/sh		# dcosx"
Xecho  "# SHELL = /bin/sh5		# ULTRIX"
Xecho  ""
Xecho  "# You should not need to alter anything below this point."
Xecho  "#------------------------------------------------------------"
Xecho  ""
Xecho  "all: bin/cook bin/c_incl bin/find_libs bin/roffpp bin/cooktime"
Xecho  ""
Xrm common/conf.h
Xfor file in $*
Xdo
X	case $file in
X
X	cook/*.y)
X		root=`basename $file .y`
X		dep=`bin/c_incl -Icook -Icommon -ns -nc $file`
X		echo ""
X		echo "cook/${root}.gen.c cook/${root}.gen.h: $file"
X		echo "	$(YACC) -d $file"
X		echo "	sed -e 's/[yY][yY]/${root}_/g' y.tab.c > cook/${root}.gen.c"
X		echo "	sed -e 's/[yY][yY]/${root}_/g' y.tab.h > cook/${root}.gen.h"
X		echo "	rm y.tab.c y.tab.h"
X		clean_files="$clean_files cook/${root}.gen.c cook/${root}.gen.h"
X
X		echo ""
X		echo "cook/${root}.gen.o: cook/${root}.gen.c" $dep
X		echo "	$(CC) $(CFLAGS) -Icook -Icommon $(H) -c cook/${root}.gen.c"
X		echo "	mv ${root}.gen.o cook/${root}.gen.o"
X		cook_files="$cook_files cook/${root}.gen.o"
X		clean_files="$clean_files cook/${root}.gen.o"
X		;;
X
X	cook/*.c)
X		root=`basename $file .c`
X		dep=`bin/c_incl -nc -Icook -Icommon -ns $file`
X		if [ ${root} = option ]
X		then
X			libdir="-D'LIBDIR=\"$(LIB)\"'"
X		else
X			libdir=
X		fi
X		echo ""
X		echo "cook/${root}.o: $file" $dep
X		echo "	$(CC) $(CFLAGS) $libdir -Icook -Icommon $(H) -c $file"
X		echo "	mv ${root}.o cook"
X		cook_files="$cook_files cook/${root}.o"
X		clean_files="$clean_files cook/${root}.o"
X		;;
X
X	c_incl/*.c)
X		root=`basename $file .c`
X		dep=`bin/c_incl -nc -Ic_incl -Icommon -ns $file`
X		echo ""
X		echo "c_incl/${root}.o: $file" $dep
X		echo "	$(CC) $(CFLAGS) -Ic_incl -Icommon $(H) -c $file"
X		echo "	mv ${root}.o c_incl"
X		c_incl_files="$c_incl_files c_incl/${root}.o"
X		clean_files="$clean_files c_incl/${root}.o"
X		;;
X
X	find_libs/*.c)
X		root=`basename $file .c`
X		dep=`bin/c_incl -nc -Ifind_libs -Icommon -ns $file`
X		echo ""
X		echo "find_libs/${root}.o: $file" $dep
X		echo "	$(CC) $(CFLAGS) -Ifind_libs -Icommon $(H) -c $file"
X		echo "	mv ${root}.o find_libs"
X		find_libs_files="$find_libs_files find_libs/${root}.o"
X		clean_files="$clean_files find_libs/${root}.o"
X		;;
X
X	roffpp/*.c)
X		root=`basename $file .c`
X		dep=`bin/c_incl -nc -Iroffpp -Icommon -ns $file`
X		echo ""
X		echo "roffpp/${root}.o: $file" $dep
X		echo "	$(CC) $(CFLAGS) -Iroffpp -Icommon $(H) -c $file"
X		echo "	mv ${root}.o roffpp"
X		roffpp_files="$roffpp_files roffpp/${root}.o"
X		clean_files="$clean_files roffpp/${root}.o"
X		;;
X
X	cooktime/*.y)
X		root=`basename $file .y`
X		dep=`bin/c_incl -Icooktime -Icommon -ns -nc $file`
X		echo ""
X		echo "cooktime/${root}.gen.c cooktime/${root}.gen.h: $file"
X		echo "	$(YACC) -d $file"
X		echo "	sed -e 's/[yY][yY]/${root}_/g' y.tab.c > cooktime/${root}.gen.c"
X		echo "	sed -e 's/[yY][yY]/${root}_/g' y.tab.h > cooktime/${root}.gen.h"
X		echo "	rm y.tab.c y.tab.h"
X		clean_files="$clean_files cooktime/${root}.gen.c cooktime/${root}.gen.h"
X
X		echo ""
X		echo "cooktime/${root}.gen.o: cooktime/${root}.gen.c" $dep
X		echo "	$(CC) $(CFLAGS) -Icooktime -Icommon $(H) -c cooktime/${root}.gen.c"
X		echo "	mv ${root}.gen.o cooktime/${root}.gen.o"
X		cooktime_files="$cooktime_files cooktime/${root}.gen.o"
X		clean_files="$clean_files cooktime/${root}.gen.o"
X		;;
X
X	cooktime/*.c)
X		root=`basename $file .c`
X		dep=`bin/c_incl -nc -Icooktime -Icommon -ns $file`
X		echo ""
X		echo "cooktime/${root}.o: $file" $dep
X		echo "	$(CC) $(CFLAGS) -Icooktime -Icommon $(H) -c $file"
X		echo "	mv ${root}.o cooktime"
X		cooktime_files="$cooktime_files cooktime/${root}.o"
X		clean_files="$clean_files cooktime/${root}.o"
X		;;
X
X	common/*.c)
X		root=`basename $file .c`
X		dep=`bin/c_incl -nc -Icommon -ns $file`
X		echo ""
X		echo "common/${root}.o: $file" $dep
X		echo "	$(CC) $(CFLAGS) -Icommon $(H) -c $file"
X		echo "	mv ${root}.o common"
X		common_files="$common_files common/${root}.o"
X		clean_files="$clean_files common/${root}.o"
X		;;
X
X	test/*/*)
X		root=`basename $file .sh`
X		echo ""
X		echo "${root}: all $file"
X		echo "	$(SHELL) $file"
X		test_files="$test_files ${root}"
X		;;
X
X	*)
X		;;
X	esac
Xdone
X
Xecho ""
Xecho "CookObj =" $cook_files
X
Xecho ""
Xecho "CommonObj =" $common_files
X
Xecho ""
Xecho "CInclObj =" $c_incl_files
X
Xecho ""
Xecho "FindLibsObj =" $find_libs_files
X
Xecho ""
Xecho "RoffppObj =" $roffpp_files
X
Xecho ""
Xecho "CooktimeObj =" $cooktime_files
X
Xecho ""
Xecho "bin/cook: $(CookObj) $(CommonObj)"
Xecho "	-if [ ! -d bin ]; then mkdir bin; fi"
Xecho "	$(CC) -o bin/cook $(CookObj) $(CommonObj) $(LIBRARIES)"
X
Xecho ""
Xecho "bin/c_incl: $(CInclObj) $(CommonObj)"
Xecho "	-if [ ! -d bin ]; then mkdir bin; fi"
Xecho "	$(CC) -o bin/c_incl $(CInclObj) $(CommonObj) $(LIBRARIES)"
X
Xecho ""
Xecho "bin/find_libs: $(FindLibsObj) $(CommonObj)"
Xecho "	-if [ ! -d bin ]; then mkdir bin; fi"
Xecho "	$(CC) -o bin/find_libs $(FindLibsObj) $(CommonObj) $(LIBRARIES)"
X
Xecho ""
Xecho "bin/roffpp: $(RoffppObj) $(CommonObj)"
Xecho "	-if [ ! -d bin ]; then mkdir bin; fi"
Xecho "	$(CC) -o bin/roffpp $(RoffppObj) $(CommonObj) $(LIBRARIES)"
X
Xecho ""
Xecho "bin/cooktime: $(CooktimeObj) $(CommonObj)"
Xecho "	-if [ ! -d bin ]; then mkdir bin; fi"
Xecho "	$(CC) -o bin/cooktime $(CooktimeObj) $(CommonObj) $(LIBRARIES)"
X
Xecho ""
Xecho "sure:" $test_files
Xecho "	@echo Passed All Tests"
X
Xecho ""
Xecho "clean:"
Xecho "	rm -f" $clean_files
X
Xecho ""
Xecho "clobber: clean"
Xecho "	rm -f bin/cook bin/c_incl bin/find_libs bin/roffpp bin/cooktime"
X
Xecho ""
Xecho "install: all"
Xecho "	chmod a+x bin/*"
Xecho "	cp bin/* $(BIN)"
Xecho "	$(SHELL) man1/install.sh $(MAN)/man1"
Xecho "	-mkdir $(LIB)"
Xecho "	-chmod a+rx $(LIB)"
Xecho "	chmod a+r lib/*"
Xecho "	cp lib/* $(LIB)"
X
Xexit 0
END_OF_FILE
if test 8871 -ne `wc -c <'aux/Makefile.sh'`; then
    echo shar: \"'aux/Makefile.sh'\" unpacked with wrong size!
fi
# end of 'aux/Makefile.sh'
fi
if test -f 'common/error.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/error.c'\"
else
echo shar: Extracting \"'common/error.c'\" \(8777 characters\)
sed "s/^X//" >'common/error.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to report errors
X */
X
X#include <ctype.h>
X#include <errno.h>
X#include <stddef.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X
X#include <arglex.h>
X#include <error.h>
X#include <s-v-arg.h>
X
X
Xstatic char *huge_buffer;
X
X
Xstatic void make_huge_buffer _((void));
X
Xstatic void
Xmake_huge_buffer()
X{
X	static int entry_count;
X	
X	if (huge_buffer)
X		return;
X	entry_count++;
X	if (entry_count != 1)
X	{
X		static char small_buffer[100];
X
X		/* just enuf for "out of memory" message */
X		huge_buffer = small_buffer;
X	}
X	else
X	{
X		huge_buffer = malloc(100000L);
X		if (!huge_buffer)
X			fatal("can't alloc buffer for error messages");
X	}
X	entry_count--;
X}
X
X
X/*
X * NAME
X *	wrap - wrap s string over lines
X *
X * SYNOPSIS
X *	void wrap(char *);
X *
X * DESCRIPTION
X *	The wrap function is used to print error messages onto stderr
X *	wrapping ling lines.
X *
X * CAVEATS
X *	Line length is assumed to be 80 characters.
X */
X
X#define PAGE_WIDTH 79
X
Xstatic void wrap _((char *));
X
Xstatic void
Xwrap(s)
X	char	*s;
X{
X	static char escapes[] = "\rr\nn\ff\bb\tt";
X	char	tmp[PAGE_WIDTH + 2];
X	int	first_line;
X	char	*tp;
X	int	bomb_later;
X	
X	/*
X	 * Flush stdout so that errors are in sync with the output.
X	 * If you get an error doing this, whinge about it _after_ reporting
X	 * the originating error.  Also, clear the error on stdout to 
X	 * avoid getting caught in an infinite loop.
X	 */
X	if (fflush(stdout) || ferror(stdout))
X	{
X		bomb_later = errno;
X		clearerr(stdout);
X	}
X	else
X		bomb_later = 0;
X
X	first_line = 1;
X	while (*s)
X	{
X		char	*ep;
X		int	ocol;
X
X		/*
X		 * Work out how many characters fit on the line.
X		 */
X		if (first_line)
X			ocol = strlen(progname) + 2;
X		else
X			ocol = 8;
X		for (ep = s; *ep; ++ep)
X		{
X			int	cw;
X			int	c;
X
X			c = (unsigned char)*ep;
X			if (isprint(c))
X				cw = 1 + (c == '\\');
X			else
X				cw = (strchr(escapes, c) ? 2 : 4);
X			if (ocol + cw > PAGE_WIDTH)
X				break;
X			ocol += cw;
X		}
X
X		/*
X		 * see if there is a better place to break the line
X		 */
X		if (*ep && *ep != ' ')
X		{
X			char	*mp;
X
X			for (mp = ep; mp > s; --mp)
X			{
X				if (strchr(" /", mp[-1]))
X				{
X					ep = mp;
X					break;
X				}
X			}
X		}
X
X		/*
X		 * ignore trailing blanks
X		 */
X		while (ep > s && ep[-1] == ' ')
X			ep--;
X		
X		/*
X		 * print the line
X		 */
X		if (first_line)
X			sprintf(tmp, "%s: ", progname);
X		else
X			strcpy(tmp, "\t");
X		tp = tmp + strlen(tmp);
X		while (s < ep)
X		{
X			int	c;
X
X			c = (unsigned char)*s++;
X			if (isprint(c))
X			{
X				if (c == '\\')
X					*tp++ = '\\';
X				*tp++ = c;
X			}
X			else
X			{
X				char	*esc;
X
X				esc = strchr(escapes, c);
X				if (esc)
X				{
X					*tp++ = '\\';
X					*tp++ = esc[1];
X				}
X				else
X				{
X					sprintf(tp, "\\%3.3o", c);
X					tp += strlen(tp);
X				}
X			}
X		}
X		*tp++ = '\n';
X		*tp = 0;
X		fputs(tmp, stderr);
X		if (ferror(stderr))
X			break;
X
X		/*
X		 * skip leading spaces for subsequent lines
X		 */
X		while (*s == ' ')
X			s++;
X		first_line = 0;
X	}
X	if (fflush(stderr) || ferror(stderr))
X	{
X		/* don't print why, there is no point! */
X		quit(1);
X	}
X	if (bomb_later)
X	{
X		errno = bomb_later;
X		nfatal("(stdout)");
X	}
X}
X
X
X/*
X * NAME
X *	error - place a message on the error stream
X *
X * SYNOPSIS
X *	void error(char *s, ...);
X *
X * DESCRIPTION
X *	Error places a message on the error output stream.
X *	The first argument is a printf-like format string,
X *	optionally followed by other arguments.
X *	The message will be prefixed by the program name and a colon,
X *	and will be terminated with a newline, automatically.
X *
X * CAVEAT
X *	Things like "error(filename)" blow up if the filename
X *	contains a '%' character.
X */
X
X/*VARARGS1*/
Xvoid
Xerror(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X
X	make_huge_buffer();
X	sva_init(ap, s);
X	vsprintf(huge_buffer, s, ap);
X	va_end(ap);
X	wrap(huge_buffer);
X}
X
X
X/*
X * NAME
X *	nerror - place a system fault message on the error stream
X *
X * SYNOPSIS
X *	void nerror(char *s, ...);
X *
X * DESCRIPTION
X *	Nerror places a message on the error output stream.
X *	The first argument is a printf-like format string,
X *	optionally followed by other arguments.
X *	The message will be prefixed by the program name and a colon,
X *	and will be terminated with a text description of the error
X *	indicated by the 'errno' global variable, automatically.
X *
X * CAVEAT
X *	Things like "nerror(filename)" blow up if the filename
X *	contains a '%' character.
X */
X
X/*VARARGS1*/
Xvoid
Xnerror(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	int		n;
X
X	n = errno;
X	make_huge_buffer();
X	sva_init(ap, s);
X	vsprintf(huge_buffer, s, ap);
X	va_end(ap);
X	strcat(huge_buffer, ": ");
X	strcat(huge_buffer, strerror(n));
X	wrap(huge_buffer);
X}
X
X
X/*
X * NAME
X *	nfatal - place a system fault message on the error stream and exit
X *
X * SYNOPSIS
X *	void nfatal(char *s, ...);
X *
X * DESCRIPTION
X *	Nfatal places a message on the error output stream and exits.
X *	The first argument is a printf-like format string,
X *	optionally followed by other arguments.
X *	The message will be prefixed by the program name and a colon,
X *	and will be terminated with a text description of the error
X *	indicated by the 'errno' global variable, automatically.
X *
X * CAVEAT
X *	Things like "nfatal(filename)" blow up if the filename
X *	contains a '%' character.
X *
X *	This function does NOT return.
X */
X
X/*VARARGS1*/
Xvoid
Xnfatal(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	int		n;
X
X	n = errno;
X	make_huge_buffer();
X	sva_init(ap, s);
X	vsprintf(huge_buffer, s, ap);
X	va_end(ap);
X	strcat(huge_buffer, ": ");
X	strcat(huge_buffer, strerror(n));
X	wrap(huge_buffer);
X	quit(1);
X}
X
X
X/*
X * NAME
X *	fatal - place a message on the error stream and exit
X *
X * SYNOPSIS
X *	void fatal(char *s, ...);
X *
X * DESCRIPTION
X *	Fatal places a message on the error output stream and exits.
X *	The first argument is a printf-like format string,
X *	optionally followed by other arguments.
X *	The message will be prefixed by the program name and a colon,
X *	and will be terminated with a newline, automatically.
X *
X * CAVEAT
X *	Things like "error(filename)" blow up if the filename
X *	contains a '%' character.
X *
X *	This function does NOT return.
X */
X
X/*VARARGS1*/
Xvoid
Xfatal(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X
X	make_huge_buffer();
X	sva_init(ap, s);
X	vsprintf(huge_buffer, s, ap);
X	va_end(ap);
X	wrap(huge_buffer);
X	quit(1);
X}
X
X
X/*
X * NAME
X *	assert - make an assertion
X *
X * SYNOPSIS
X *	void assert(int condition);
X *
X * DESCRIPTION
X *	Assert is a handy tool for a programmer to guarantee the internal
X *	consistency of their program.  If "-DDEBUG" is specified on
X *	the compiler's command line, then assert will generate code to verify
X *	the assertios made. If no DEBUG is defined, assertions will generate
X *	no code.
X *
X * CAVEAT
X *	If the assertion fails, a fatal diagnostic is issued.
X *
X *	The #define's which control the compilation may be found in "error.h".
X *
X */
X
X#ifdef	DEBUG
X
Xvoid
Xcook_assert(c, s, file, line)
X	int	c;
X	char	*s;
X	char	*file;
X	int	line;
X{
X	if (c)
X		return;
X	error("%s: %d: assertion \"%s\" failed (bug)", file, line, s);
X	abort();
X}
X
X#endif /* DEBUG */
X
X
X/*
X * NAME
X *	quit_handler
X *
X * SYNOPSIS
X *	int quit_handler(quit_ty);
X *
X * DESCRIPTION
X *	The quit_handler function registers the function pointed to by func,
X *	to be called without arguments at normal program termination.
X */
X
Xstatic	quit_ty	quit_list[32];
Xstatic	int	quit_list_length;
X
Xvoid
Xquit_handler(f)
X	quit_ty	f;
X{
X	assert(quit_list_length < SIZEOF(quit_list));
X	quit_list[quit_list_length++] = f;
X}
X
X
X/*
X * NAME
X *	quit - leave program
X *
X * SYNOPSIS
X *	void quit(int status);
X *
X * DESCRIPTION
X *	The quit function causes normal program termination to occur.
X *
X *	First, all functions registered by the quit_handler function are
X *	called, in the reverse order of their registration.
X *
X *	Next, the program is terminated using the exit() function.
X *
X * CAVEAT
X *	The quit function never returns to its caller.
X */
X
Xvoid
Xquit(n)
X	int	n;
X{
X	while (quit_list_length > 0)
X		(*quit_list[--quit_list_length])();
X	exit(n);
X}
END_OF_FILE
if test 8777 -ne `wc -c <'common/error.c'`; then
    echo shar: \"'common/error.c'\" unpacked with wrong size!
fi
# end of 'common/error.c'
fi
if test -f 'cook/glob.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/glob.c'\"
else
echo shar: Extracting \"'cook/glob.c'\" \(9323 characters\)
sed "s/^X//" >'cook/glob.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to perform shell-style file pattern matching
X */
X
X#include <sys/types.h>
X#include <dirent.h>
X
X#include <stddef.h>
X#include <string.h>
X#include <errno.h>
X#include <stdlib.h>
X
X#include <conf.h>
X#include <glob.h>
X#include <trace.h>
X#include <mem.h>
X#include <error.h>
X
X
Xstatic	char	*original;
Xstatic	wlist	*where;
Xstatic	char	*tmp;
Xstatic	size_t	tmp_max;
Xstatic	size_t	tmp_len;
X
X
X/*
X * NAME
X *	tmp_char - append character
X *
X * SYNOPSIS
X *	void tmp_char(int c);
X *
X * DESCRIPTION
X *	The tmp_char function is used to append a character to the string being
X *	built by the glob function.
X *
X * RETURNS
X *	void
X */
X
Xstatic void tmp_char _((int));
X
Xstatic void
Xtmp_char(c)
X	int		c;
X{
X	if (tmp_len >= tmp_max)
X	{
X		tmp_max += 128;
X		if (!tmp)
X			tmp = mem_alloc(tmp_max);
X		else
X			mem_change_size(&tmp, tmp_max);
X	}
X	tmp[tmp_len++] = c;
X}
X
X
X/*
X * NAME
X *	gmatch - match entryname pattern
X *
X * SYNOPSIS
X *	int gmatch(char *formal, char *formal_end, char *actual);
X *
X * DESCRIPTION
X *	The formal strings is used as a template to match the given actual
X *	string against.
X *
X *	The pattern elements understood are
X *	*	match zero or more of any character
X *	?	match any single character
X *	[^xxx]	match any single character not in the set given.
X *	[xxx]	match any single character not in the set given.
X *	        The - character is understood to be a range indicator.
X *	        If the ] character is the first of the set it is considered
X *	        as part of the set, not the terminator.
X *
X * RETURNS
X *	the gmatch function returns zero if they do not match,
X *	and nonzero if they do.  Returns -1 on error.
X *
X * CAVEAT
X *	This is a limited set of the sh(1) patterns.
X *	Assumes that the `original' global variable has been initialized, it is
X *	used for error reporting.
X */
X
Xstatic int gmatch _((char *, char *, char *));
X
Xstatic int
Xgmatch(formal, formal_end, actual)
X	char		*formal;
X	char		*formal_end;
X	char		*actual;
X{
X	char		*cp;
X	int		 result;
X
X	trace(("gmatch(formal = %08lX, formal_end = %08lX, actual = %08lX)\n{\n"/*}*/, formal, formal_end, actual));
X	while (formal < formal_end)
X	{
X		trace(("formal == \"%.*s\";\n", formal_end - formal, formal));
X		trace(("actual = \"%s\";\n", actual));
X		switch (*formal)
X		{
X		default:
X			if (*actual++ != *formal++)
X			{
X				result = 0;
X				goto ret;
X			}
X			break;
X
X		case '?':
X			if (!*actual++)
X			{
X				result = 0;
X				goto ret;
X			}
X			++formal;
X			break;
X
X		case '*':
X			cp = actual + strlen(actual);
X			++formal;
X			for (;;)
X			{
X				if (gmatch(formal, formal_end, cp))
X				{
X					result = 1;
X					goto ret;
X				}
X				--cp;
X				if (cp < actual)
X				{
X					result = 0;
X					goto ret;
X				}
X			}
X
X		case '[':
X			++formal;
X			if (*formal == '^')
X			{
X				++formal;
X				for (;;)
X				{
X					if (formal >= formal_end)
X					{
X						no_close:
X						error("pattern \"%s\" missing closing ']'", original);
X						result = -1;
X						goto ret;
X					}
X					/* note: this allows leading ']' elegantly */
X					if
X					(
X						formal_end >= formal + 3
X					&&
X						formal[1] == '-'
X					&&
X						formal[2] != ']'
X					)
X					{
X						char	c1;
X						char	c2;
X
X						c1 = formal[0];
X						c2 = formal[2];
X						formal += 3;
X						if
X						(
X							c1 <= c2
X						?
X							(c1 <= *actual && *actual <= c2)
X						:
X							(c2 <= *actual && *actual <= c1)
X						)
X						{
X							result = 0;
X							goto ret;
X						}
X					}
X					else
X					if (*actual == *formal++)
X					{
X						result = 0;
X						goto ret;
X					}
X					if (*formal == ']')
X						break;
X				}
X				++formal;
X			}
X			else
X			{
X				for (;;)
X				{
X					if (formal >= formal_end)
X						goto no_close;
X					/* note: this allows leading ']' elegantly */
X					trace(("formal == \"%.*s\";\n", formal_end - formal, formal));
X					trace(("actual = \"%s\";\n", actual));
X					if
X					(
X						formal_end >= formal + 3
X					&&
X						formal[1] == '-'
X					&&
X						formal[2] != ']'
X					)
X					{
X						char	c1;
X						char	c2;
X
X						c1 = formal[0];
X						c2 = formal[2];
X						formal += 3;
X						if
X						(
X							c1 <= c2
X						?
X							(c1 <= *actual && *actual <= c2)
X						:
X							(c2 <= *actual && *actual <= c1)
X						)
X							break;
X					}
X					else
X					if (*actual == *formal++)
X						break;
X					if (*formal == ']')
X					{
X						result = 0;
X						goto ret;
X					}
X				}
X				for (;;)
X				{
X					if (formal >= formal_end)
X						goto no_close;
X					trace(("formal == \"%.*s\";\n", formal_end - formal, formal));
X					trace(("actual = \"%s\";\n", actual));
X					if (*formal++ == ']')
X						break;
X				}
X			}
X			++actual;
X			break;
X		}
X	}
X	result = (*actual == 0);
X	ret:
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	globber - file name expander
X *
X * SYNOPSIS
X *	int globber(char *formal);
X *
X * DESCRIPTION
X *	The globber function is used to generate a list of file names from the
X *	given `formal' pattern.  Results are appended to the word list pointed
X *	to the global `where' variable.
X *
X * RETURNS
X *	int; 0 on success, -1 on error.
X *
X * CAVEAT
X *	Assumes that the `where' global variable has been initialized.
X */
X
Xstatic int globber _((char *));
X
Xstatic int
Xglobber(formal)
X	char		*formal;
X{
X	char		*formal_end;
X	char		*cp;
X	int		 retval;
X
X	trace(("globber(formal = %08lX)\n{\n"/*}*/, formal));
X	trace_string(formal);
X	retval = 0;
X	for (;;)
X	{
X		while (*formal == '/')
X			tmp_char(*formal++);
X		formal_end = strchr(formal, '/');
X		if (!formal_end)
X			formal_end = formal + strlen(formal);
X		for (cp = formal; cp < formal_end; ++cp)
X			if (strchr("[?*", *cp))
X				break;
X		if (cp >= formal_end)
X		{
X			/* nothing special */
X			trace(("ordinary = \"%.*s\"", formal_end - formal, formal));
X			for (cp = formal; cp < formal_end; ++cp)
X				tmp_char(*cp);
X			if (!*cp)
X			{
X				string_ty *s;
X
X				s = str_n_from_c(tmp, tmp_len);
X				wl_append(where, s);
X				str_free(s);
X				break;
X			}
X			formal = formal_end;
X		}
X		else
X		{
X			size_t		n;
X			DIR		*dp;
X			struct dirent	*dep;
X
X			/* need to expand wild characters */
X			trace(("expand = \"%.*s\"", formal_end - formal, formal));
X			n = tmp_len;
X			tmp_char(0);
X			dp = opendir(tmp[0] ? tmp : ".");
X			if (!dp)
X			{
X				if (errno == ENOTDIR)
X					break;
X				nerror("%s", tmp);
X				retval = -1;
X				goto ret;
X			}
X			tmp_len = n;
X			for (;;)
X			{
X				char	*np;
X
X				dep = readdir(dp);
X				if (!dep)
X					break;
X				np = dep->d_name;
X#ifdef CONF_pyramid_broken_readdir
X				np -= 2;
X#endif
X				if
X				(
X					np[0] == '.'
X				&&
X					(
X						!np[1]
X					||
X						(np[1] == '.' && !np[2])
X					)  
X				)
X					continue;
X				switch (gmatch(formal, formal_end, np))
X				{
X				case 0:
X					continue;
X
X				case -1:
X					retval = -1;
X					goto ret;
X				}
X				for (cp = np; *cp; ++cp)
X					tmp_char(*cp);
X				if (!*formal_end)
X				{
X					string_ty *s;
X
X					s = str_n_from_c(tmp, tmp_len);
X					wl_append(where, s);
X					str_free(s);
X				}
X				else
X				{
X					tmp_char('/');
X					if (globber(formal_end + 1))
X					{
X						closedir(dp);
X						retval = -1;
X						goto ret;
X					}
X				}
X				tmp_len = n;
X			}
X			closedir(dp);
X			break;
X		}
X	}
X	ret:
X	trace(("return %d;\n", retval));
X	trace((/*{*/"}\n"));
X	return retval;
X}
X
X
X/*
X * NAME
X *	cmp - compare strings
X *
X * SYNOPSIS
X *	int cmp(string_ty **, string_ty **);
X *
X * DESCRIPTION
X *	The cmp function is used to compare two strings.
X *
X * RETURNS
X *	int; <0 if a<b, 0 if a==b, >0 if a>b
X *
X * CAVEAT
X *	Intended for use by qsort.
X */
X
Xstatic int cmp _((const void *, const void *));
X
Xstatic int
Xcmp(va, vb)
X	const void	*va;
X	const void	*vb;
X{
X	string_ty	*a;
X	string_ty	*b;
X
X	a = *(string_ty **)va;
X	b = *(string_ty **)vb;
X	return strcmp(a->str_text, b->str_text);
X}
X
X
X/*
X * NAME
X *	glob - builtin function for expanding file names
X *
X * SYNOPSIS
X *	void glob(wlist *result, wlist *args);
X *
X * DESCRIPTION
X *	The glob function is used to implement the "glob" builtin function of
X *	cook to expand file name patterns.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	This function is designed to be used as a "builtin" function.
X */
X
Xint
Xglob(result, args)
X	wlist		*result;
X	wlist		*args;
X{
X	int		j;
X	int		start;
X	int		retval;
X
X	trace(("glob(result = %08X, args = %08X)\n{\n"/*}*/, result, args));
X	retval = 0;
X	where = result;
X	for (j = 1; j < args->wl_nwords; ++j)
X	{
X		tmp_len = 0;
X		original = args->wl_word[j]->str_text;
X		start = result->wl_nwords;
X		if (globber(original))
X		{
X			retval = -1;
X			break;
X		}
X		qsort(result->wl_word + start, result->wl_nwords - start, sizeof(string_ty *), cmp);
X	}
X	trace(("return %d;\n", retval));
X	trace((/*{*/"}\n"));
X	return retval;
X}
END_OF_FILE
if test 9323 -ne `wc -c <'cook/glob.c'`; then
    echo shar: \"'cook/glob.c'\" unpacked with wrong size!
fi
# end of 'cook/glob.c'
fi
if test -f 'cook/parse.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/parse.y'\"
else
echo shar: Extracting \"'cook/parse.y'\" \(9370 characters\)
sed "s/^X//" >'cook/parse.y' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to parse cookbooks
X */
X
X%token	CATENATE
X%token	COLON
X%token	DATA
X%token	DATAEND
X%token	ELSE
X%token	EQUALS
X%token	FAIL
X%token	IF
X%token	LBRACE
X%token	LBRAK
X%token	LOOP
X%token	LOOPSTOP
X%token	RBRACE
X%token	RBRAK
X%token	SEMICOLON
X%token	SET
X%token	THEN
X%token	UNSETENV
X%token	WORD
X
X%right	ELSE
X%left	CATENATE
X
X%{
X#include <stddef.h>
X#include <stdlib.h>
X#include <stdio.h>
X
X#include <cook.h>
X#include <expr.h>
X#include <id.h>
X#include <lex.h>
X#include <mem.h>
X#include <option.h>
X#include <parse.h>
X#include <stmt.h>
X#include <trace.h>
X#include <word.h>
X
X#ifdef	DEBUG
X#define YYDEBUG 1
X#define printf trace_where(__FILE__, __LINE__), lex_trace
Xextern int yydebug;
X#endif
X
Xstatic	stmt    *looptemp;
X
X
X/*
X *  NAME
X *      parse_initialize - start up parser
X *
X *  SYNOPSIS
X *      void parse_initialize(void);
X *
X *  DESCRIPTION
X *      The parse_initialize function is used to add the set clause names to
X *      the symbol table.
X *
X *  RETURNS
X *      void
X *
X *  CAVEAT
X *      Must be called after symbol table is initialized.
X *      Must be called before the parse function is used.
X */
X
Xvoid
Xparse_initialize()
X{
X	typedef struct table_ty table_ty;
X	struct table_ty
X	{
X		char	*t_name;
X		int	t_mask;
X	};
X
X	static table_ty table[] =
X	{
X		{ "errok",		RF_ERROK,		},
X		{ "noerrok",		RF_ERROK_OFF,		},
X		{ "force",		RF_FORCE,		},
X		{ "forced",		RF_FORCE,		},
X		{ "noforce",		RF_FORCE_OFF,		},
X		{ "noforced",		RF_FORCE_OFF,		},
X		{ "meter",		RF_METER,		},
X		{ "nometer",		RF_METER_OFF,		},
X		{ "precious",		RF_PRECIOUS,		},
X		{ "noprecious",		RF_PRECIOUS_OFF,	},
X		{ "silent",		RF_SILENT,		},
X		{ "nosilent",		RF_SILENT_OFF,		},
X		{ "clearstat",		RF_CLEARSTAT,		},
X		{ "noclearstat",	RF_CLEARSTAT_OFF,	},
X	};
X
X	table_ty *tp;
X
X	trace(("parse_initialize()\n{\n"/*}*/));
X	for (tp = table; tp < ENDOF(table); ++tp)
X	{
X		string_ty *s;
X
X		s = str_from_c(tp->t_name);
X		id_assign(s, ID_CLASS_FLAGS, &tp->t_mask);
X		str_free(s);
X	}
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X *  NAME
X *	parse - read and process a cookbook
X *
X *  SYNOPSIS
X *	void parse(string_ty *filename);
X *
X *  DESCRIPTION
X *	Parse reads and processes a cookbook.
X *
X *  CAVEAT
X *	If any errors are found, the user will be told,
X *	and this routine will not return.
X */
X
Xvoid
Xparse(filename)
X	string_ty *filename;
X{
X	int yyparse _((void)); /* forward */
X
X	trace(("parse(filename = %08lX)\n{\n"/*}*/, filename));
X	trace_string(filename->str_text);
X	lex_open(filename);
X#if YYDEBUG
X	yydebug = trace_pretest_;
X#endif
X	yyparse();
X	lex_close();
X	trace((/*{*/"}\n"));
X}
X
X#define yyerror lex_error
X
X%}
X
X%union
X{
X	expr		*lv_expr;
X	stmt		*lv_stmt;
X	elist		lv_elist;
X	string_ty	*lv_word;
X	int		lv_flag;
X	position	lv_position;
X}
X
X%type	<lv_stmt>	statement compound_statement statements
X%type	<lv_stmt>	command simple_command loop use_clause
X%type	<lv_elist>	elist exprs
X%type	<lv_word>	WORD
X%type	<lv_expr>	expr if_clause
X%type	<lv_flag>	set_clause data lbrak mult
X%type	<lv_position>	COLON
X
X%%
X
Xcook
X	: /* empty */
X	| cook statement
X		{
X			if (stmt_eval($2))
X				yyerror("statement failed");
X			stmt_free($2);
X		}
X	| cook error
X		{
X			lex_mode(LM_NORMAL);
X		}
X	;
X
Xstatement
X	: compound_statement
X		{
X			$$ = $1;
X		}
X	| UNSETENV exprs SEMICOLON
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_UNSETENV;
X			$$->s_cmd.c_args = $2;
X		}
X	| elist EQUALS exprs SEMICOLON
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_ASSIGN;
X			$$->s_assign.a_name = $1;
X			$$->s_assign.a_value = $3;
X		}
X	| elist COLON mult exprs set_clause if_clause compound_statement
X			use_clause
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_RECIPE;
X			$$->s_recipe.sr_target = $1;
X			$$->s_recipe.sr_position = $2;
X			$$->s_recipe.sr_multiple = $3;
X			$$->s_recipe.sr_need = $4;
X			el_zero(&$$->s_recipe.sr_need2);
X			$$->s_recipe.sr_flags = $5;
X			$$->s_recipe.sr_precondition = $6;
X			$$->s_recipe.sr_action = $7;
X			$$->s_recipe.sr_use_action = $8;
X		}
X	| elist COLON mult exprs COLON exprs set_clause if_clause
X			compound_statement use_clause
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_RECIPE;
X			$$->s_recipe.sr_target = $1;
X			$$->s_recipe.sr_position = $2;
X			$$->s_recipe.sr_multiple = $3;
X			$$->s_recipe.sr_need = $4;
X			$$->s_recipe.sr_need2 = $6;
X			$$->s_recipe.sr_flags = $7;
X			$$->s_recipe.sr_precondition = $8;
X			$$->s_recipe.sr_action = $9;
X			$$->s_recipe.sr_use_action = $10;
X			str_free($5.pos_name);
X		}
X	| elist COLON mult exprs set_clause if_clause SEMICOLON
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_RECIPE;
X			$$->s_recipe.sr_target = $1;
X			$$->s_recipe.sr_position = $2;
X			$$->s_recipe.sr_need = $4;
X			el_zero(&$$->s_recipe.sr_need2);
X			$$->s_recipe.sr_flags = $5;
X			$$->s_recipe.sr_precondition = $6;
X			$$->s_recipe.sr_action = 0;
X			$$->s_recipe.sr_use_action = 0;
X			$$->s_recipe.sr_multiple = $3;
X		}
X	;
X
Xmult
X	: /* empty */
X		{
X			$$ = 0;
X		}
X	| COLON
X		{
X			$$ = 1;
X			str_free($1.pos_name);
X		}
X	;
X
Xset_clause
X	: /* empty */
X		{
X			$$ = 0;
X		}
X	| SET exprs
X		{
X			int	flag;
X			int	j;
X			wlist	wl;
X
X			wl_zero(&wl);
X			if (el2wl(&wl, &$2))
X			{
X				/* error message already emitted */
X				wl_free(&wl);
X			}
X			el_free(&$2);
X			$$ = 0;
X			if (!wl.wl_nwords)
X				yyerror("set clause has no flags");
X			for (j = 0; j < wl.wl_nwords; ++j)
X			{
X				if (id_search(wl.wl_word[j], ID_CLASS_FLAGS, &flag))
X					$$ |= flag;
X				else
X				{
X					yyerror
X					(
X				   "set clause does not understand \"%s\" flag",
X						wl.wl_word[j]->str_text
X					);
X				}
X			}
X			wl_free(&wl);
X		}
X	;
X
Xif_clause
X	: /* empty */
X		{
X			$$ = 0;
X		}
X	| IF expr
X		{
X			$$ = $2;
X		}
X	;
X
Xuse_clause
X	: /* empty */
X		{
X			$$ = 0;
X		}
X	| THEN compound_statement
X		{
X			$$ = $2;
X		}
X	;
X
Xstatement
X	: command
X		{
X			$$ = $1;
X		}
X	| IF expr THEN statement
X		%prec ELSE
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_IF;
X			$$->s_if.sif_cond = $2;
X			$$->s_if.sif_true = $4;
X			$$->s_if.sif_false = stmt_alloc();
X			$$->s_if.sif_false->s_op = OP_NOP;
X		}
X	| IF expr THEN statement ELSE statement
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_IF;
X			$$->s_if.sif_cond = $2;
X			$$->s_if.sif_true = $4;
X			$$->s_if.sif_false = $6;
X		}
X	| loop statement
X		{
X			$$ = looptemp;
X			looptemp = $1;
X			$$->s_op = OP_LOOP;
X			$$->s_loop = $2;
X		}
X	| LOOPSTOP SEMICOLON
X		{
X			$$ = stmt_alloc();
X			if (!looptemp)
X			{
X				yyerror("'loopstop' encountered outside a loop");
X				$$->s_op = OP_NOP;
X			}
X			else
X				$$->s_op = OP_LOOPSTOP;
X		}
X	| SET exprs SEMICOLON
X		{
X			int	j;
X			int	flag;
X			wlist   wl;
X
X			$$ = stmt_alloc();
X			$$->s_op = OP_SET;
X			$$->s_cmd.c_flags = 0;
X
X			wl_zero(&wl);
X			if (el2wl(&wl, &$2))
X			{
X				/* error message already emitted */
X				wl_free(&wl);
X			}
X			el_free(&$2);
X			if (!wl.wl_nwords)
X				yyerror("set statement has no flags");
X			for (j = 0; j < wl.wl_nwords; ++j)
X			{
X				if (id_search(wl.wl_word[j], ID_CLASS_FLAGS, &flag))
X					$$->s_cmd.c_flags |= flag;
X				else
X				{
X					yyerror
X					(
X				"set statement does not understand \"%s\" flag",
X						wl.wl_word[j]->str_text
X					);
X				}
X			}
X			wl_free(&wl);
X		}
X	| FAIL SEMICOLON
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_FAIL;
X		}
X	| FAIL WORD SEMICOLON
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_FAIL_DK;
X		}
X	| SEMICOLON
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_NOP;
X		}
X	;
X
Xloop
X	: LOOP
X		{
X			$$ = looptemp;
X			looptemp = stmt_alloc();
X		}
X	;
X
Xcompound_statement
X	: LBRACE statements RBRACE
X		{
X			$$ = $2;
X		}
X	;
X
Xstatements
X	: /* empty */
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_COMPOUND;
X		}
X	| statements statement
X		{
X			$$ = $1;
X			sl_append(&$$->s_list, $2);
X			stmt_free($2);
X		}
X	| statements error
X		{
X			$$ = $1;
X		}
X	;
X
Xelist
X	: expr
X		{
X			el_zero(&$$);
X			el_append(&$$, $1);
X			expr_free($1);
X		}
X	| elist expr
X		{
X			$$ = $1;
X			el_append(&$$, $2);
X			expr_free($2);
X		}
X	;
X
Xexprs
X	: /* empty */
X		{
X			el_zero(&$$);
X		}
X	| exprs expr
X		{
X			$$ = $1;
X			el_append(&$$, $2);
X			expr_free($2);
X		}
X	;
X
Xexpr
X	: WORD
X		{
X			$$ = expr_alloc();
X			$$->e_op = OP_WORD;
X			$$->e_word = $1;
X		}
X	| lbrak elist RBRAK
X		{
X			lex_mode($1);
X			$$ = expr_alloc();
X			$$->e_op = OP_FUNC;
X			$$->e_list = $2;
X		}
X	| expr CATENATE expr
X		{
X			$$ = expr_alloc();
X			$$->e_op = OP_CAT;
X			$$->e_left = $1;
X			$$->e_right = $3;
X		}
X	;
X
Xcommand
X	: simple_command
X		{
X			$$ = $1;
X		}
X	| simple_command data expr DATAEND
X		{
X			lex_mode($2);
X			$$ = $1;
X			$$->s_cmd.c_input = $3;
X		}
X	;
X
Xsimple_command
X	: elist set_clause SEMICOLON
X		{
X			$$ = stmt_alloc();
X			$$->s_op = OP_COMMAND;
X			$$->s_cmd.c_args = $1;
X			$$->s_cmd.c_flags = $2;
X		}
X	;
X
Xdata
X	: DATA
X		{
X			$$ = lex_mode(LM_DATA);
X		}
X	;
X
Xlbrak
X	: LBRAK
X		{
X			$$ = lex_mode(LM_NORMAL);
X		}
X	;
END_OF_FILE
if test 9370 -ne `wc -c <'cook/parse.y'`; then
    echo shar: \"'cook/parse.y'\" unpacked with wrong size!
fi
# end of 'cook/parse.y'
fi
if test -f 'doc/builtin' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/builtin'\"
else
echo shar: Extracting \"'doc/builtin'\" \(8061 characters\)
sed "s/^X//" >'doc/builtin' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, Built-In Functions
X.\"
X.H 1 "Built-In Functions"
XThis chapter defines each of the builtin functions of
X.IR cook .
X.P
XA builtin function is invoked by using an expression of the form
X.eB
X.fi
X.BI [ func-name
X.I arg
X.I arg
X.RB \&... ]
X.eE
Xin most places where a literal word is valid.
X.H 2 "and"
XThis function requires at least two arguments,
Xupon which it forms a logical conjunction.
XThe value returned is "1" (true) if none of the arguments are "" (false),
Xotherwise "" (false) is returned.
X.H 2 "catenate"
XThis function requires zero or more arguments.
XIf no arguments are supplied,
Xthe result is an empty word list.
XIf one or more arguments are supplied,
Xthe result is a word list of one word
Xbeing the catenation of all of the arguments.
X.H 2 "collect"
XThe arguments are interpreted as a command to be passed to the operating system.
XThe result is one word for
Xeach white-space separated word of the output of the command.
X.H 2 "collect_lines"
XThe arguments are interpreted as a command to be passed to the operating system.
XThe result one word for each
Xline of the output of the command.
X.H 2 "count"
XThis function requires zero or more arguments.
XThe result is a word list of one word containing the (decimal) length
Xof the argument word list.
X.H 2 "defined"
XThis function requires a single argument,
Xthe name of a variable to be tested for existence.
XIt returns "1" (true) if the named variable is defined and "" (false) if it
Xis not.
X.H 2 "dir"
XThis function requires one or more arguments,
Xthe names of files which will have their directory parts extracted.
XThis function may also be referred to as
X.IR dirname .
X.H 2 "downcase"
XThis function requires one or more arguments,
Xwords to be forced into lower case.
X.H 2 "entryname"
XThis function requires one or more arguments,
Xthe names of files which will have their entry name parts extracted.
X.H 2 "execute"
XThis function requires at least one argument, and
Xexecutes the command given by the arguments.
XIf the executed command returns an error code
Xthe resulting value is "" (false),
Xotherwise it is "1" (true).
X.H 2 "exists"
XThis function requires one argument,
Xbeing the name of a file to test for existence.
XThe resulting wordlist is "" (false) if the file does not exist,
Xand "1" (true) if the file does exist.
X.H 2 "find_command"
XThis function requires at least one argument,
Xbeing the names of commands to search for in $PATH.
XThe resulting word list contains either "" (false) or a fully qualified
Xpath name for each command given.
X.H 2 "fromto"
XThis function requires at least two arguments.
XFromto gives the user access to the wildcard transformations available to
X.BR cook .
XThe first argument is the "from" form,
Xthe second argument is the "to" form.
XAll other arguments are mapped from one to the other.
X.H 2 "getenv"
XEach argument is treated as the name of an environment variable.
XThe result is the value of each argument variable,
Xor "" if it does not exist.
X.H 2 "glob"
XEach argument is treated as a
X.IR sh (1)
Xfile name pattern,
Xand expanded accordingly.
X.H 2 "head"
XThis function requires zero or more arguments.
XThe wordlist returned is empty if there were no arguments,
Xor the first argument if there were arguments.
X.H 2 "if"
XThis function requires one or more arguments,
Xthe arguments before the "then" word are used as a condition.
XIf the condition is true the words between the "then" word and the
X"else" word are the result, otherwise the words after the "else" word
Xare the value.
XThe "else" clause is optional.
XThere is no way to escape the "then" and "else" words.
X.H 2 "in"
XThis function requires one or more arguments.
XThe wordlist returned is a single word: "1" (true) if the first argument is
Xequal to any of the later ones; "" (false) if not.
X.H 2 "matches"
XThis function requires one or more arguments,
Xthe first is a pattern, subsequent are strings to match against this
Xpattern.
XThe resulting wordlist contains "" (false) if did not match and "1" (true) if
Xit did.
X.H 2 "match_mask"
XThis function requires one or more arguments,
Xthe first is a pattern, subsequent are strings to match against this
Xpattern.
XThe resulting wordlist contains those arguments which mtached the pattern given
Xas the first argument.
X.H 2 "mtime"
XThis function requires one argument,
Xthe name of a file to fetch the last-modified time of.
XThe resulting wordlist is "" (false) is the file does not exist,
Xor a string containing a (comparable) representation of the date and
Xtime the files was last modified.
X.H 2 "not"
XThis function requires zero or more arguments,
Xthe value to be logically negated.
XIt returns "1" (true) if all of the arguments are "" (false),
Xor there are no arguments;
Xand returns "" (false) otherwise.
XThis is symmetric with the definition of true and false for
X.BR if .
X.H 2 "operating_system"
XThis function requires zero or more arguments.
XThe resulting wordlist contains the values of various attributes of
Xthe operating system, as named in the arguments.
XIf no attributes are named "name" is assumed.
XBelow is a list of attributes:
X.VL 1i
X.LI name
XThe generic name of the operating system
X.B cook
Xpresently being run under.
XFor example:
Xif you were running on a Berkeley 4.2BSD Unix,
Xthis would return "\f(CWunix\fP".
X.LI version
XThe specific version of operating system, within name,
X.B cook
Xis presently being run under.
XFor example: if you were running on a Berkeley 4.2BSD Unix,
Xthis would return "\f(CW4.2BSD\fP".
X.LE
XThis function may also be referred to as "os".
X.H 2 "or"
XThis function requires at least two arguments,
Xupon which it forms a logical disjunction.
XThe value returned is "1" (true) if any one of the arguments is not "" (false),
Xotherwise "" (false) is returned.
X.H 2 "pathname"
XThe function requires one or more arguments,
Xbeing files names to be replaced with their full path names.
X.H 2 "prepost"
XThis function must have at least two arguments.
XThe first argument is a prefix and the second argument is a suffix.
XThe resulting word list is
Xthe third and later arguments each given the prefix and suffix as
Xdefined by the first and second arguments.
X.H 2 "quote"
XEach argument is quoted by single quotes,
Xwith special characters escaped as necessary.
X.H 2 "resolve"
XThis builtin function is used to resolve file names when using the
X.I search_list
Xvariable to locate files.
XThis builtin function produces resolved file names as output.
XThis is useful when taking partial copies of a source
Xto perform controlled updates.
XThe targets of recipes are always cooked into the current directory.
X.H 2 "sort"
XThe arguments are sorted lexicographically.
X.H 2 "stringset"
XLogical operations are performed on sets of strings.
XThese include conjunction
X.RB ( | ),
Xdisjunction
X.RB ( & )
Xand difference
X.RB ( - ).
X.H 2 "tail"
XThis function requires zero or more arguments.
XThe word list returned will be empty if
Xthere is less than two arguments,
Xotherwise it will consist of the second and later arguments.
X.H 2 "upcase"
XThis function requires one or more arguments,
Xwords to be forced into upper case.
X.H 2 "uptodate"
XThis function requires one or more arguments,
Xfilenames to be brought up-to-date.
XThe result are true ("1") if no error occurred,
Xor false ("") if some error occurred.
END_OF_FILE
if test 8061 -ne `wc -c <'doc/builtin'`; then
    echo shar: \"'doc/builtin'\" unpacked with wrong size!
fi
# end of 'doc/builtin'
fi
if test -f 'doc/system' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/system'\"
else
echo shar: Extracting \"'doc/system'\" \(10086 characters\)
sed "s/^X//" >'doc/system' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, Supplied Cookbooks
X.\"	
X.H 1 "Supplied Cookbooks"
XA number of cookbooks are supplied with 
X.BR cook .
XTo make use of one, a preprocessor directive of the form
X.eB
X#include "\f(CIwhichone\fP"
X.eE
Xmust appear the the start of your cookbook.
X.P
X.B Cook
Xdoes not have any "builtin" recipes.
XAll recipes are stored in text files,
Xso they are more easily read, understood, copied, hacked or corrected.
XThe supplied cookbooks live in the
X.I /usr/local/lib/cook
Xdirectory.
X.P
XYou may supply your own "system" recipes,
Xby placing cookbooks into a directory called
X.IR $HOME/.cook
Xor using the 
X.B -Include
Xcommand line option,
Xpossibly in your 
X.I $COOK
Xenvironment variable.
X.H 2 "as"
XThis cookbook defines how to use the assembler.
X.H 3 "recipes"
X.VL 1i
X.LI "%.o: %.s"
XConstruct object files from assembler source files.
X.LE
X.H 3 "variables"
X.VL 1i
X.LI as
XThe assembler command.
XNot altered if already defined.
X.LI as_flags
XOptions to pass the assembler command.
XNot altered if already defined.
XThe default is empty.
X.LI as_src
XAssembler source files in the current directory.
X.LI dot_src
XSource files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_obj
XObject files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_clean
XFiles which may be removed from the current directory in a clean target.
X.LE
X.H 2 "c"
XThis cookbook describes how to work with C files.
XInclude file dependencies are automatically determined.
X.H 3 "recipes"
X.VL 1i
X.LI "%.o: %.c"
XConstruct object files form C source files,
Xwith automatic include file dependency detection.
X.LI "%.ln: %.c"
XConstruct lint object files from C source files,
Xwith automatic include file dependency detection.
X.LE
X.H 3 "variables"
X.VL 1i
X.LI c_incl
XThe C include dependency sniffer command.
XNot altered if already defined.
X.LI cc
XThe C compiler command.
XNot altered if already defined.
X.LI lint
XThe lint command.
XNot altered if already defined.
X.LI cc_flags
XOptions to pass to the C compiler command.
XNot altered if already defined.
XThe default is "-O".
X.LI cc_include_flags
XOptions passed to the C compiler and c_incl
Xcontrolling include file searching.
XNot altered if already defined.
XThe default is empty.
X.LI cc_link_flags
XOptions passed to the C compiler when linking,
Xthese are typically library search paths and libraries.
XNot altered if already defined.
XThe default is empty.
X.LI cc_src
XC source files in the current directory.
X.LI dot_src
XSource files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_obj
XObject files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_clean
XFiles which may be removed from the current directory in a clean target.
X.LI dot_lint_obj
XLint object files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LE
X.H 2 "home"
XThis cookbook defined where certain directories are,
Xand some common uses of those directories,
Xrelative to $HOME.
X.H 3 "variables"
X.VL 1i
X.LI home
XThe current users' home directory.
X.LI bin
XThe directory to place program binaries into.
X.LI include
XThe directory to place include files into.
X.LI lib
XThe directory to place libraries into.
X.LI cc_include_flags
XThe [include] directory is appended to the search options.
X.LI cc_link_flags
XThe [lib] directory is appended to the search options.
X.LE
X.H 2 "lex"
XThis cookbook describes how to work with lex files.
X.H 3 "recipes"
X.VL 1i
X.LI "%.l: %.c"
XConstruct C source files from lex source files.
X.LE
X.H 3 "variables"
X.VL 1i
X.LI lex
XThe lex command.
XNot altered if already defined.
X.LI lex_flags
XOptions to pass to the lex command.
XNot altered if already defined.
XThe default is empty.
X.LI lex_src
XLex source files in the current directory.
X.LI dot_src
XSource files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_obj
XObject files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_clean
XFiles which may be removed from the current directory in a clean target.
X.LI dot_lint_obj
XLint object files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LE
X.H 2 "library"
XThis cookbook defines how to construct a library.
X.P
XIf an include file (or files) are defined for this library,
Xyou will have to append them to [install] in your
X.I Howto.cook
Xfile.
X.H 3 "variables"
X.VL 1i
X.LI all
Xtargets of the all recipe
X.LI install
Xtargets of the install recipe
X.LI me
XThe name of the library to be constructed.
XDefaults to the last component of the pathname of the current directory.
X.LI ar
XThe archive command.
X.LI install
Xtargets of the install command.
XOnly defined if the [lib] variable is defined.
X.LE
X.H 3 "recipes"
X.VL 1i
X.LI all
Xconstruct the targets defined in [all].
X.LI clean
Xremove the files named in [dot_clean].
X.LI clobber
Xremove the files name in [dot_clean] and [all].
X.LI install
XConstruct the files named in [install].
XOnly defined if the [lib] variable is defined.
X.LI uninstall
XRemove the files named in [install].
XOnly defined if the [lib] variable is defined.
X.LE
X.H 2 "print"
XThis cookbook is used to print files.
XIt will almost certainly need to be changed for every site.
X.H 3 "recipes"
X.VL 1i
X.LI "%.lw: %.ps"
XPrint a PostScript file.
X.LI "%.lp: %"
XPrint a text file.
X.LE
X.H 3 "variables"
X.VL 1i
X.LI lp
XThe print command.
XNot altered if already defined.
X.LI lp_flags
XOptions passed to the print command.
XNot altered if already defined.
XDefaults to empty.
X.LE
X.H 2 "program"
XThis cookbook defines how to construct a program.
X.P
XIf you program uses any libraries,
Xyou will have to append them to [cc_link_flags] in your
X.I Howto.cook
Xfile.
X.H 3 "variables"
X.VL 1i
X.LI all
XTargets of the all recipe.
X.LI install
Xtargets of the install recipe
X.LI me
XThe name of the program to be constructed.
XDefaults to the last component of the pathname of the current directory.
X.LI install
Xtargets of the install command.
X.LE
X.H 3 "recipes"
X.VL 1i 
X.LI all
XConstruct the targets named in [all].
X.LI clean
XRemove the files named in [dot_clean].
X.LI clobber
XRemove the files named in [dot_clean] and [all].
X.LI install
XConstruct the files named in [install].
XOnly defined if the [lib] variable is defined.
X.LI uninstall
XRemove the files named in [install].
XOnly defined if the [lib] variable is defined.
X.LE
X.H 2 "sccs"
XThis cookbook is used to extract files from SCCS.
X.H 3 "recipes"
X.VL 1i
X.LI "%: SCCS/s.%"
XExtract files from SCCS.
X.LE
X.H 3 "variables"
X.VL 1i
X.LI get
XThe sccs get command.
X.LE
X.H 2 "text"
XThis cookbook is used to process text documents.
X.P
XInclude file dependencies are automatically detected.
XThe requirements for various preprocessors are automatically detected
X(eg eqn, tbl, pic, graf).
X.H 3 "recipes"
X.VL 1i
X.LI "%.ps: %.t"
XPostScript for generic *roff source.
X.LI "%: %.t"
XStraight text from *roff source.
X.LE
X.H 3 "variables"
X.VL 1i 
X.LI text_incl
XThe text_incl command (finds include dependencies).
XNot altered if already set.
X.LI text_roff
XThe text_roff command (finds preprocessor requirements).
XNot altered if already set.
X.LI roff_flags
XArguments passed to text_roff, and indirectly to the *roff program.
XNot altered if already set.
XDefaults to empty.
X.LE
X.H 2 "usr"
XThis cookbook defined where certain directories are,
Xrelative to /usr.
X.H 3 "variables"
X.VL 1i
X.LI bin
XThe directory to place program binaries into.
X.LI include
XThe directory to place include files into.
X.LI lib
XThe directory to place libraries into.
X.LE
X.H 2 "usr.local"
XThis cookbook defined where certain directories are,
Xand some common uses of those directories,
Xelative to /usr/local.
X .H 3 "variables"
X.VL 1i
X.LI bin
XThe directory to place program binaries into.
X.LI include
XThe directory to place include files into.
X.LI lib
XThe directory to place libraries into.
X.LI cc_include_flags
XThe [include] directory is added to the search options.
X.LI cc_link_flags
XThe [lib] directory is added to the search options.
X.LE
X.H 2 "yacc"
XThis cookbook describes how to use yacc.
X.P
XYou will have to add "-d" to the [yacc_flags] variable
Xif you want %.h files generated.
X.P
XIf a
X.I y.output
Xfile is constructed,
Xit will be moved to
X.IR %.list .
X.H 3 "recipes"
X.VL 1i
X.LI "%.c %.h: %.y"
XConstruct C source and header files from yacc source files.
XApplied if -d in [yacc_flags].
X.LI "%.c: %.y"
XConstruct C source files from yacc source files.
XApplied if -d not in [yacc_flags].
X.LE
X.H 3 "variables"
X.VL 1i
X.LI yacc_src
XYacc source files in the current directory.
X.LI dot_src
XSource files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_obj
XObject files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LI dot_clean
XFiles which may be removed from the current directory in a clean target.
X.LI dot_lint_obj
XLint object files constructable in the current directory
X(unioned with existing setting, if necessary).
X.LE
X.H 2 "yacc_many"
XThis cookbook describes how to use yacc.
XThe difference with the "yacc" cookbook is that this cookbook
Xallows you to have more that one yacc generated parser in the same
Xprogram, by using the classic sed(1) hack of the output.
END_OF_FILE
if test 10086 -ne `wc -c <'doc/system'`; then
    echo shar: \"'doc/system'\" unpacked with wrong size!
fi
# end of 'doc/system'
fi
if test -f 'roffpp/preprocess.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'roffpp/preprocess.c'\"
else
echo shar: Extracting \"'roffpp/preprocess.c'\" \(8282 characters\)
sed "s/^X//" >'roffpp/preprocess.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to eliminate include files
X */
X
X#include <ctype.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <unistd.h>
X
X#include <error.h>
X#include <mem.h>
X#include <preprocess.h>
X#include <str.h>
X#include <trace.h>
X#include <word.h>
X
Xstatic	wlist	search;
Xstatic	char	*ofn;
Xstatic	FILE	*ofp;
X
X
X/*
X * NAME
X *	preprocess_include
X *
X * SYNOPSIS
X *	void preprocess_include(char *path);
X *
X * DESCRIPTION
X *	The preprocess_include function is used to append
X *	to the include search path.
X *
X * ARGUMENTS
X *	path	- path to append
X */
X
Xvoid
Xpreprocess_include(path)
X	char		*path;
X{
X	string_ty	*s;
X
X	trace(("preprocess_include(path = \"%s\")\n{\n"/*}*/, path));
X	s = str_from_c(path);
X	wl_append_unique(&search, s);
X	str_free(s);
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	source
X *
X * SYNOPSIS
X *	int source(char *line);
X *
X * DESCRIPTION
X *	The source function is used to test if a line of tect is
X *	a .so directive, and to insert the contents of the sourced
X *	file at this point.
X *
X * ARGUMENTS
X *	line	- pointer to line of text
X *
X * RETURNS
X *	int;	zero if is not a .so directive,
X *		non-zero if it is a .so directive
X */
X
Xstatic void scan _((string_ty *)); /* forward */
X
Xstatic int source _((char *));
X
Xstatic int
Xsource(line)
X	char		*line;
X{
X	string_ty	*filename;
X	size_t		j;
X	int		result;
X	char		*ep;
X	static string_ty *dot;
X
X	/*
X	 * see if this is a .so directive
X	 */
X	if (*line != '.')
X		return 0;
X	trace(("source(line = \"%s\")\n{\n"/*}*/, line));
X	result = 0;
X	line++;
X	while (isspace(*line))
X		line++;
X	if (line[0] != 's' || line[1] != 'o' || !isspace(line[2]))
X		goto ret;
X	line += 3;
X	while (isspace(*line))
X		line++;
X	if (!*line)
X		goto ret;
X
X	/*
X	 * find the end of the argument
X	 */
X	for (ep = line + 1; *ep && !isspace(*ep); ++ep)
X		;
X	filename = str_n_from_c(line, ep - line);
X
X	/*
X	 * no need to search when it's an absolute path
X	 */
X	if (*line == '/')
X	{
X		scan(filename);
X		str_free(filename);
X		result = 1;
X		goto ret;
X	}
X
X	/*
X	 * search for the name in the search list
X	 */
X	if (!dot)
X		dot = str_from_c(".");
X	for (j = 0; j < search.wl_nwords; ++j)
X	{
X		string_ty	*s;
X		string_ty	*dir;
X
X		dir = search.wl_word[j];
X		if (str_equal(dir, dot))
X			s = str_copy(filename);
X		else
X			s = str_format("%S/%S", dir, filename);
X		if (access(s->str_text, F_OK) == 0)
X		{
X			str_free(filename);
X			scan(s);
X			str_free(s);
X			result = 1;
X			goto ret;
X		}
X		str_free(s);
X	}
X	str_free(filename);
X
X	/*
X	 * let {ps,n,t,dit,pt}roff bomb later
X	 */
X	result = 0;
X
X	/*
X	 * here for all exits
X	 */
X	ret:
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X/*
X * NAME
X *	lf_directive
X *
X * SYNOPSIS
X *	int lf_directive(char *line, string_ty **ifn, long *lino);
X *
X * DESCRIPTION
X *	The lf_directive function is used to test if a line of text is
X *	a .lf directive, and to adjust the file position to this point.
X *
X * ARGUMENTS
X *	line	- pointer to line of text
X *	ifn	- file name (ptr) if needs changing
X *	lino	- line number (ptr) if needs changing
X *
X * RETURNS
X *	int;	zero if is not a .so directive,
X *		non-zero if it is a .so directive
X */
X
Xstatic int lf_directive _((char *line, string_ty **ifn, long *lino));
X
Xstatic int
Xlf_directive(line, ifn, lino)
X	char		*line;
X	string_ty	**ifn;
X	long		*lino;
X{
X	int		result;
X	long		n;
X	string_ty	*s;
X	char		*ep;
X
X	/*
X	 * see if this is a .so directive
X	 */
X	if (*line != '.')
X		return 0;
X	trace(("source(line = \"%s\")\n{\n"/*}*/, line));
X	result = 0;
X	line++;
X	while (isspace(*line))
X		line++;
X	if (line[0] != 'l' || line[1] != 'f' || !isspace(line[2]))
X		goto ret;
X	line += 3;
X	while (isspace(*line))
X		line++;
X	if (!*line)
X		goto ret;
X
X	/*
X	 * find the line number
X	 */
X	for (ep = line + 1; *ep && !isspace(*ep); ++ep)
X		;
X	s = str_n_from_c(line, ep - line);
X	n = atol(s->str_text);
X	str_free(s);
X	if (n <= 0)
X		goto ret;
X	*lino = n - 1;
X	result = 1;
X
X	/*
X	 * find the file name
X	 */
X	line = ep;
X	while (*line && isspace(*line))
X		line++;
X	if (!*line)
X		goto ret;
X	for (ep = line + 1; *ep && !isspace(*ep); ++ep)
X		;
X	s = str_n_from_c(line, ep - line);
X	if (*ifn)
X		str_free(*ifn);
X	*ifn = s;
X
X	/*
X	 * here for all exits
X	 */
X	ret:
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	resync
X *
X * SYNOPSOS
X *	void resync(FILE *fp, char *name, long line);
X *
X * DESCRIPTION
X *	The resync function is used to emit appropriate
X *	*roff requests to resynchronize the *roff engine
X *	to the correct file name and line numner,
X *	so that error messages, etc al, are meaningful.
X *
X * ARGUMENTS
X *	fp	- file stream to print on
X *	name	- name of input file
X *	line	- num number in the input file
X */
X
Xstatic void resync _((FILE *, string_ty *, long));
X
Xstatic void
Xresync(ofp, file, line)
X	FILE		*ofp;
X	string_ty	*file;
X	long		line;
X{
X	fprintf(ofp, ".lf %ld %s\n", line, file->str_text);
X}
X
X
X/*
X * NAME
X *	scan
X *
X * SYNOPSIS
X *	void scan(char *path);
X *
X * DESCRIPTION
X *	The scan function is used to can a file, copying its contents
X *	to the output, replacing .so directives with the contents of
X *	the included files.
X *
X * ARGUMENTS
X *	path	- name of file to scan
X */
X
Xstatic void scan _((string_ty *));
X
Xstatic void
Xscan(ifn)
X	string_ty	*ifn;
X{
X	FILE		*ifp;
X	size_t		pos;
X	static size_t	max;
X	static char	*line;
X	long		lino;
X	int		c;
X	string_ty	*ifn2;
X
X	trace(("scan(ifn = \"%s\")\n{\n"/*}*/, ifn ? ifn->str_text : "-"));
X	if (ifn)
X	{
X		ifp = fopen(ifn->str_text, "r");
X		if (!ifp)
X			nfatal("open \"%s\"", ifn->str_text);
X	}
X	else
X	{
X		ifn = str_from_c("(stdin)");
X		ifp = stdin;
X	}
X	ifn2 = str_copy(ifn);
X
X	lino = 1;
X	resync(ofp, ifn2, lino);
X
X	pos = 0;
X	for (;;)
X	{
X		if (pos >= max)
X		{
X			if (!line)
X			{
X				max = 100;
X				line = mem_alloc(max);
X			}
X			else
X			{
X				max += 80;
X				mem_change_size(&line, max);
X			}
X		}
X		c = getc(ifp);
X		switch (c)
X		{
X		case EOF:
X			if (ferror(ifp))
X				nfatal("read \"%s\"", ifn->str_text);
X			if (!pos)
X				break;
X			/* fall through... */
X
X		case '\n':
X			line[pos] = 0;
X			if (source(line) || lf_directive(line, &ifn2, &lino))
X				resync(ofp, ifn2, lino + 1);
X			else
X			{
X				fputs(line, ofp);
X				putc('\n', ofp);
X			}
X			if (ferror(ofp))
X				nfatal("write \"%s\"", ofn);
X			lino++;
X			pos = 0;
X			continue;
X
X		default:
X			line[pos++] = c;
X			continue;
X		}
X		break;
X	}
X
X	if (ifp != stdin && fclose(ifp))
X		nfatal("close \"%s\"", ifn);
X	str_free(ifn2);
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	preprocess
X *
X * SYNOPSIS
X *	void preprocess(char *infile, char *outfile);
X *
X * DESCRIPTION
X *	The preprocess function is used to process an *roff file and
X *	eliminate the .so directives, replacing them with the contents
X *	of the included files.
X *
X * ARGUMENTS
X *	infile	- name of file to scan, NULL means stdin
X *	outfile	- name of file to hold result, NULL means stdout
X */
X
Xvoid
Xpreprocess(ifile, ofile)
X	char		*ifile;
X	char		*ofile;
X{
X	string_ty	*s;
X
X	/*
X	 * default the search path iff the user specified nothing
X	 */
X	trace(("preprocess(ifile = \"%s\", ofile = \"%s\")\n{\n"/*}*/,
X		ifile ? ifile : "-", ofile ? ofile : "-"));
X	if (!search.wl_nwords)
X		preprocess_include(".");
X
X	/*
X	 * open the output file
X	 */
X	if (ofile)
X	{
X		ofn = ofile;
X		ofp = fopen(ofn, "w");
X		if (!ofp)
X			nfatal("create \"%s\"", ofn);
X	}
X	else
X	{
X		ofn = "(stdout)";
X		ofp = stdout;
X	}
X
X	/*
X	 * scan the input
X	 */
X	if (ifile)
X		s = str_from_c(ifile);
X	else
X		s = 0;
X	scan(s);
X	if (s)
X		str_free(s);
X
X	/*
X	 * close up and go home
X	 */
X	if (ofp != stdout && fclose(ofp))
X		nfatal("close \"%s\"", ofn);
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 8282 -ne `wc -c <'roffpp/preprocess.c'`; then
    echo shar: \"'roffpp/preprocess.c'\" unpacked with wrong size!
fi
# end of 'roffpp/preprocess.c'
fi
echo shar: End of archive 5 \(of 11\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
