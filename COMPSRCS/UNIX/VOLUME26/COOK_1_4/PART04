Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v26i212: cook-1.4 - a file construction tool (like "make"), Part04/11
Sender: unix-sources-moderator@efficacy.home.vix.com
Approved: WhoAmI@efficacy.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 26, Issue 212
Archive-Name: cook-1.4/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 11)."
# Contents:  BUILDING aux/README.man common/trace.c common/word.c
#   cook/option.c cooktime/main.c doc/cmdline doc/how doc/intro.bb
#   find_libs/main.c man1/cook.1 roffpp/main.c
# Wrapped by vixie@efficacy.home.vix.com on Tue May  4 01:36:38 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'BUILDING' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BUILDING'\"
else
echo shar: Extracting \"'BUILDING'\" \(8016 characters\)
sed "s/^X//" >'BUILDING' <<'END_OF_FILE'
X
X
X
Xbuilding(cook)					   building(cook)
X
X
XNAME
X	cook - a file construction tool
X
XSPACE REQUIREMENTS
X	You will need about 5MB	to unpack and build the	cook
X	program.  Your milage may vary.
X
XSITE CONFIGURATION
X	The file common/conf.h needs to	be created to match your
X	site.  Select an appropriate file from the conf
X	directory.  The	files in this directory	are named for the
X	various	systems	encountered to date by the author.  The
X	file most closely resembling your system should	be copied
X	into the common/conf.h file.  You can copy it or use a
X	symbolic link; copying is recommended because you may
X	need to	edit.
X
X	A file which may require editing is the	Makefile file.
X	The first few lines contain comments describing	what may
X	require	changing.  In general these changes will relate
X	to the name of your favorite C compiler, and where it
X	keeps its include files.
X
XKNOWN SYSTEMS
X	This distribution of cook is known to build on the
X	following systems:
X
X	SCO 3.2
X		You will need to set the compiler to rcc in the
X		Makefile file.
X
X	SunOS 4.1
X		The native cc(1) and also gcc(1) are known to
X		work.  The appropriate configuration is	contained
X		in the conf/SunOS-4.1 file.
X
X	ConvexOS 10.0
X		The native cc(1) is known to work.  The
X		appropriate configuration is contained in the
X		conf/ConvexOS-10 file.
X
X	dgux 5.4.1
X		The native cc (1) compiler is known to work.  The
X		appropriate configuration is contained in the
X		conf/dgux-5.4.1	file.
X
X	Pyramid	SMP DC/OSx 1.0-92b023
X		This system is revolting!  The Berkeley	cc (1)
X		compiler variant is known to work.  The
X		appropriate configuration is contained in the
X		conf/dcosx file.  Make sure you	read the Makefile
X		file very carefully.
X
X
X
X
X
X								1
X
X
X
X
X
Xbuilding(cook)					   building(cook)
X
X
X	ULTRIX 4.2
X		The native cc (1) compiler is known to work.  The
X		appropriate configuration is contained in the
X		conf/ULTRIX-4.2	file.  Make sure you set the
X		SHELL macro in the Makefile file.
X
X	If any of the above systems do not work	for you, after
X	you have double-checked	everything, the	author wants to
X	know.
X
XUNKNOWN	SYSTEMS
X	Please let the author know of any other	systems	you get
X	cook working on, and the modifications necessary.  Please
X	include	the changes to the Makefile file, the relevant
X	common/conf.h file used, and the output	of the "uname
X	-rs" command.
X
X	The cook program was developed using gcc, however this is
X	not the	default	in the Makefile	file.  The cook	program
X	source attempts	to use ANSI C features without
X	compromising the ability to be compiled	on older C
X	compilers.  Functions mandated by the ANSI C standard are
X	used, because many systems provided them, one way or
X	another.  Please let the author	know of	any others you
X	think should be	added to the common/ansi.c file.
X
X	You may	need to	use some ANSI C	header files which the
X	cook code uses,	but which some systems (as yet)	fail to
X	provide.  You will find	lines at the top of the	Makefile
X	file similar to
X		H = -I/usr/include -Ih
X	Change this to suit your system	and your compiler.  The
X	"h" directory must be searched last as it is intended to
X	suplement your system, not replace it.
X
X	You will need to check the include files in the	"h"
X	directory to see that they are suitable	for your system.
X	You may	want to	delete any that	your system already has.
X
XBUILDING COOK
X	All you	should need to do is use the
X		% make
X		...lots	of output...
X		%
X	command	and wait.  When	this finishes you should see a
X	directory called bin containing	three files: cook, c_incl
X	and find_libs.	The c_incl program is a	utility
X	distributed with cook which examines C files and
X	determines all the files it includes directly and
X	indirectly.  The find_libs program is a	utility
X	distributed with cook which tracks doen	the names of
X	library	files, given cc-style library options (-L and
X	-l).
X
X
X
X
X								2
X
X
X
X
X
Xbuilding(cook)					   building(cook)
X
X
XTESTING
X	The cook program comes with a test suite.  To run this
X	test suite, use	the command
X		% make sure
X		...lots	of output...
X		Passed All Tests
X		%
X
X	The tests take a few seconds each, with	a few very fast,
X	and a couple very slow,	but it varies greatly depending
X	on your	CPU.
X
X	If all went well, the message
X		Passed All Tests
X	should appear at the end of the	make.
X
XINSTALLING COOK
X	Put the	cook program and utilities somewhere where users
X	will automatically pick	it up, such as in the
X	/usr/local/bin directory.  Use the command
X		# cp bin/* /usr/local/bin
X		#
X
X	The manuals can	be installed using the commands
X		# sh man1/install.sh /usr/local/man/man1
X		#
X	This is	very site-specific.  You can install the manuals
X	in a different directory by using a different last
X	argument.
X
X	By default, cook is configured to use /usr/local/lib/cook
X	as the place it	stores various system recipe files
X		# mkdir	/usr/local/lib/cook
X		# cp lib/* /usr/local/lib/cook
X		#
X	These paths are	only example, where to install things
X	tends to be very system	specific, and I	won't even try to
X	guess.	Control	of the placement of this directory may be
X	found in the first few lines of	the Makefile file.
X
X	All of the above install can be	done automatically, using
X	the "make install" command.  Control of	the directories
X	used may be found in the first few lines of the	Makefile
X	file.
X
XPRINTED	MANUALS
X	This distribution contains the sources to all of the
X	documentation for cook.	 The author used the GNU groff
X	package	and a postscript printer to prepare the
X	documentation.	If you do not have this	software, you
X	will need to substitute	commands appropriate to	your
X	site.
X
X	To print copies	of the README and BUILDING files, the
X
X
X
X								3
X
X
X
X
X
Xbuilding(cook)					   building(cook)
X
X
X	following commands may be used
X		% cd aux
X		% groff	-s -t -man *.man | lpr
X		% cd ..
X		%
X	This will produce about	4 pages.  The "-s" flag	means
X	preprocess with	soelim(1), and the "-t"	flag means
X	preprocess with	tbl(1).
X
X	To print copies	of the manual entries, the following
X	commands may be	used
X		% cd man1
X		% groff	-s -t -man *.1 | lpr
X		% cd ..
X		%
X	This will produce about	8 pages.  The "-s" flag	means
X	preprocess with	soelim(1), and the "-t"	flag means
X	preprocess with	tbl(1).
X
X	To print a copy	of the Reference Manual, the following
X	commands may be	used
X		% cd doc
X		% groff	-s -t -mm refman.t | lpr
X		% cd ..
X		%
X	This will produce about	35 pages.  The "-s" flag means
X	preprocess with	soelim(1), the "-t" flag means preprocess
X	with tbl(1).  Alternatively, you could get a PostScript
X	copy of	the Reference Manual from the archive site.
X
XGETTING	HELP
X	If you need assistance with the	cook program, please do
X	not hesitate to	contact	the author at
X		Peter Miller <pmiller@bmr.gov.au>
X	Any and	all feedback is	welcome.
X
X	When reporting problems, please	include	the version
X	number given by	the
X		% cook -version
X		cook version a.b.cccc
X		...
X		%
X	command.
X
X	In the common/main.h file, there is a define of	DEBUG in
X	comments.  If the comments are removed,	extensive
X	debugging is turned on.	 This causes some performance
X	loss, but performs much	run-time checking and adds the
X	-TRACIng command line option.
X
X	When the -TRACing option is followed by	one or more file
X	names, it turns	on execution traces in those source
X	files.	It is best to put this option on the end of the
X	command, so that the names of the files	to be traced are
X
X
X
X								4
X
X
X
X
X
Xbuilding(cook)					   building(cook)
X
X
X	not confused with any other filenames or strings on the
X	command	line.
X
XCOPYRIGHT
X	cook version 1.4.D013
X	Copyright (C) 1988, 1989, 1990,	1991, 1992, 1993 Peter
X	Miller.
X	All rights reserved.
X
X	The cook package is distributed	in the hope that it will
X	be useful, but WITHOUT ANY WARRANTY; without even the
X	implied	warranty of MERCHANTABILITY or FITNESS FOR A
X	PARTICULAR PURPOSE.  See the GNU General Public	License
X	for more details.
X
X	It should be in	the LICENSE file included with this
X	distribution.
X
XAUTHOR
X	Peter Miller   UUCP	  uunet!munnari!bmr.gov.au!pmiller
X	/\/\*	       Internet	  pmiller@bmr.gov.au
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X								5
X
X
END_OF_FILE
if test 8016 -ne `wc -c <'BUILDING'`; then
    echo shar: \"'BUILDING'\" unpacked with wrong size!
fi
# end of 'BUILDING'
fi
if test -f 'aux/README.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aux/README.man'\"
else
echo shar: Extracting \"'aux/README.man'\" \(6897 characters\)
sed "s/^X//" >'aux/README.man' <<'END_OF_FILE'
X'\" t
X.\"	cook - a file construction tool
X.\"	Copyright (C) 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: source of the README file
X.\"
X.TH readme cook
X.hy 0
X.ad l
X.SH NAME
Xcook \- a file construction tool
X.SH DESCRIPTION
XPut simply,
Xthe
X.I cook
Xprogram is yet another make-oid.
X.PP
XThe
X.I cook
Xprogram is a tool for constructing files.
XIt is given a set of files to create,
Xand recipes of how to create them.
XIn any non-trivial program there will be
Xprerequisites to performing the actions necessary to
Xcreating any file,
Xsuch as include files.
XThe
X.I cook
Xprogram provides a mechanism to define these.
X.PP
XWhen a program is being developed or maintained,
Xthe programmer will typically change one file of several which
Xcomprise the program.
XThe
X.I cook
Xprogram examines the last-modified times of the files
Xto see when the prerequisites of a file have changed,
Ximplying that the file needs to be recreated as it is logically out of date.
X.PP
XThe
X.I cook
Xprogram also provides a facility for implicit recipes,
Xallowing users to specify how to form a file with a
Xgiven suffix from a file with a different suffix.
XFor example,
Xto create
X.IR filename .o
Xfrom
X.IR filename .c
X.br
X.ne 1i
X.SH HISTORY
XThe
X.I cook
Xprogram was originally developed (starting in 1988)
Xbecause I was marooned on an operating system without
Xanything even vaguely resembling make(1).
XSince I had to write my own,
XI added a few improvements.
XWhen I finally escaped back to UNIX,
Xit took only two days to port
X.I cook
Xto SystemV.
XI have since deleted all code for that original operating system,
Xalthough clues to its identity are still present.
XThere is no prize for guessing what it was.
X.PP
XAfter I had
X.I cook
Xup on UNIX,
Xthe progress the world had made caught up with me.
XIt was gratifying that many of the
Xfeatures other make-oid authors had thought necessary were
Xeither already present,
Xor easily and seamlessly added.
X.br
X.ne 1i
X.SH ARCHIVE SITE
XThe latest version of
X.I cook
Xis available by anonymous ftp from:
X.RS 4m
X.TS
Xtab(;);
Xl l s
Xl l l.
XHost:;ftp.cse.nau.edu (134.114.64.70)
XDir:;/pub/Aegis
XFile:;README;# what is in this directory
XFile:;cook.1.4.tar.Z;# the complete source
XFile:;cook.1.4.patch.Z;# patch to take 1.3 to 1.4
XFile:;cook.1.4.ps.Z;# PostScript of the Manual
X.TE
X.RE
X.PP
XTo use anonymous ftp,
Xgive "anonymous" as the user name (omit the quotes)
Xand your email address as the password.
X.PP
XMy grateful thanks to Paul Balyoz <pab@ftp.cse.nau.edu>
Xfor his generosity in providing this archive space.
X.PP
XThis directory also contains a few other pieces of software written by me.
XPlease have a look if you are interested.
X.PP
XFor those of you without ftp,
XI recommend the use of an ftp-by-email server.
XHere is a list of a few (there are many more):
X.RS
X.nf
Xmail-server@pit-manager.mit.edu
Xftpmail@decwrl.dec.com
Xftpmail@cs.uow.edu.au
X.fi
X.RE
X.PP
XIn general, you can get a help message about how to use each system
Xby sending email with a subject of "help"
Xand a message body containing just the word "help".
X.br
X.ne 1i
X.SH MAILING LIST
XA mailing list has been created so that users of
X.I cook
Xmay exchange ideas about how to use the
X.I cook
Xprogram.
XDiscussion may include,
Xbut is not limited to:
Xbugs, enhancements, and applications.
XThe list is not moderated.
X.PP
XThe address of the mailing list is
X.RS
X.ft CW
Xcook-users@bmr.gov.au
X.ft R
X.RE
X.PP
XTo subscribe to this mailing list,
Xsend an email message to \f(CWmajordomo@bmr.gov.au\fP with
Xa message body containing the single line
X.RS
X.ft CW
Xsubscribe cook-users
X.ft R
X.RE
XPlease note that \f(CWbmr.gov.au\fP is an Internet site,
Xso if you have an address which is not readily derived from
Xyour mail headers (majordomo is only a Perl program, after all)
Xyou will need to use a message of the form:
X.RS
X.ft CW
Xsubscribe cook-users \fIaddress\fP
X.ft R
X.RE
Xwhere \fIaddress\fP is an email address which
Xmakes sense from an Internet site.
X.PP
XThe software which handles this mailing list
X.if n CANNOT
X.if t .B cannot
Xsend you a copy of the
X.I cook
Xprogram.
XPlease use ftp or ftp-by-email, instead.
X.br
X.ne 1i
X.SH NEW IN THIS RELEASE
XA number of features have been added to
X.I cook
Xwith this release.
XA few of them are detailed here:
X.PP
X.if t \(bu
X.if n *
XThe
X.I cook
Xprogram is now known to work on more systems.
XMost changes were aimed at improving portability,
Xor avoiding problems specific to some systems.
X.PP
X.if t \(bu
X.if n *
XThe GNU long option name convention is now understood.
XOption names for
X.I cook
Xwere always long,
Xso this mostly consists of ignoring the extra leading '-'.
XThe "--foo=bar" convention is also understood for options with arguments.
X.PP
X.if t \(bu
X.if n *
XTests which fail now tell you what it was they were testing for.
XThis will give the user some idea of what is happening.
X.PP
XPlus the usual crop of bug fixes and tinkering.
XFor excruciating detail,
Xand also acknowlegements of those who generously sent me feedback,
Xplease see the
X.I CHANGES
Xfile included in this distribution.
X.br
X.ne 1i
X.SH BUILDING COOK
XFull instructions for building the
X.I cook
Xprogram may be found in the
X.I BUILDING
Xfile included in this distribution.
X.br
X.ne 1i
X.SH COPYRIGHT
X.I cook
Xversion
X.so ../doc/version.so
X.br
XCopyright
X.if t \(co
X.if n (C)
X1988, 1989, 1990, 1991, 1992, 1993 Peter Miller.
X.br
XAll rights reserved.
X.PP
XThis program is free software;
Xyou can redistribute it
Xand/or modify it under the terms of the GNU General Public
XLicense as published by the Free Software Foundation;
Xeither version 2 of the License,
Xor (at your option) any later version.
X.PP
XThis program is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY;
Xwithout even the implied
Xwarranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
XPURPOSE.
XSee the GNU General Public License for more details.
X.PP
XYou should have received a copy of the GNU General Public
XLicense along with this program; if not, write to the Free
XSoftware Foundation, Inc., 675 Mass Ave, Cambridge, MA
X02139, USA.
X.PP
XIt should be in the
X.I LICENSE
Xfile included with this distribution.
X.br
X.ne 1i
X.SH AUTHOR
X.TS
Xtab(;);
Xl l l.
XPeter Miller;UUCP;uunet!munnari!bmr.gov.au!pmiller
X\f(CW/\e/\e*\fP;Internet;pmiller@bmr.gov.au
X.TE
END_OF_FILE
if test 6897 -ne `wc -c <'aux/README.man'`; then
    echo shar: \"'aux/README.man'\" unpacked with wrong size!
fi
# end of 'aux/README.man'
fi
if test -f 'common/trace.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/trace.c'\"
else
echo shar: Extracting \"'common/trace.c'\" \(7532 characters\)
sed "s/^X//" >'common/trace.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to report execution traces
X */
X
X#include <stddef.h>
X#include <stdio.h>
X#include <string.h>
X
X#include <error.h>
X#include <mem.h>
X#include <arglex.h>
X#include <s-v-arg.h>
X#include <str.h>
X#include <trace.h>
X
X
X#define INDENT 2
X#define PAGE_WIDTH 79
X
Xtypedef struct known_ty known_ty;
Xstruct known_ty
X{
X	string_ty	*filename;
X	int		flag;
X	int		*flag_p;
X	known_ty	*next;
X};
X
Xstatic	string_ty	*file_name;
Xstatic	int		line_number;
Xstatic	int		page_width;
Xstatic	known_ty	*known;
X
X
Xstatic string_ty *basename _((char *));
X
Xstatic string_ty *
Xbasename(file)
X	char		*file;
X{
X	char		*cp1;
X	char		*cp2;
X
X	cp1 = strrchr(file, '/');
X	if (cp1)
X		++cp1;
X	else
X		cp1 = file;
X	cp2 = strrchr(cp1, '.');
X	if (!cp2)
X		cp2 = cp1 + strlen(cp1);
X	if (cp2 > cp1 + 6)
X		return str_n_from_c(cp1, 6);
X	return str_n_from_c(cp1, cp2 - cp1);
X}
X
X
Xint
Xtrace_pretest(file, result)
X	char		*file;
X	int		*result;
X{
X	string_ty	*s;
X	known_ty	*kp;
X
X	s = basename(file);
X	for (kp = known; kp; kp = kp->next)
X	{
X		if (str_equal(s, kp->filename))
X		{
X			str_free(s);
X			break;
X		}
X	}
X	if (!kp)
X	{
X		kp = (known_ty *)mem_alloc(sizeof(known_ty));
X		kp->filename = s;
X		kp->next = known;
X		kp->flag = 2; /* disabled */
X		known = kp;
X	}
X	kp->flag_p = result;
X	*result = kp->flag;
X	return *result;
X}
X
X
Xvoid
Xtrace_where(file, line)
X	char		*file;
X	int		line;
X{
X	string_ty	*s;
X
X	/*
X	 * take new name fist, because will probably be same as last
X	 * thus saving a free and a malloc (which are slow)
X	 */
X	s = basename(file);
X	if (file_name)
X		str_free(file_name);
X	file_name = s;
X	line_number = line;
X}
X
X
Xstatic void trace_putchar _((int));
X
Xstatic void
Xtrace_putchar(c)
X	int		c;
X{
X	static int	depth;
X	static char	buffer[PAGE_WIDTH + 2];
X	static char	*cp;
X	static int	in_col;
X	static int	out_col;
X
X	if (!page_width)
X	{
X		page_width = PAGE_WIDTH - 24;
X		if (page_width < 8)
X			page_width = 8;
X	}
X	if (!cp)
X	{
X		strcpy(buffer, progname);
X		cp = buffer + strlen(buffer);
X		if (cp > buffer + 6)
X			cp = buffer + 6;
X		*cp++ = ':';
X		*cp++ = '\t';
X		strcpy(cp, file_name->str_text);
X		cp += file_name->str_length;
X		*cp++ = ':';
X		*cp++ = '\t';
X		sprintf(cp, "%d:\t", line_number);
X		cp += strlen(cp);
X		in_col = 0;
X		out_col = 0;
X	}
X	switch (c)
X	{
X	case '\n':
X		*cp++ = '\n';
X		*cp = 0;
X		fflush(stdout);
X		fputs(buffer, stderr);
X		fflush(stderr);
X		if (ferror(stderr))
X			nfatal("(stderr)");
X		cp = 0;
X		break;
X
X	case ' ':
X		if (out_col)
X			++in_col;
X		break;
X
X	case '\t':
X		if (out_col)
X			in_col = (in_col/INDENT + 1) * INDENT;
X		break;
X
X	case /*{*/'}':
X	case /*(*/')':
X	case /*[*/']':
X		if (depth > 0)
X		--depth;
X		/* fall through */
X
X	default:
X		if (!out_col)
X		{
X			if (c != '#')
X				/* modulo so never too long */
X				in_col = (INDENT * depth) % page_width;
X			else
X				in_col = 0;
X		}
X		if (in_col >= page_width)
X		{
X			trace_putchar('\n');
X			trace_putchar(c);
X			return;
X		}
X		while (((out_col + 8) & -8) <= in_col && out_col + 1 < in_col)
X		{
X			*cp++ = '\t';
X			out_col = (out_col + 8) & -8;
X		}
X		while (out_col < in_col)
X		{
X			*cp++ = ' ';
X			++out_col;
X		}
X		if (c == '{'/*}*/ || c == '('/*)*/ || c == '['/*]*/)
X			++depth;
X		*cp++ = c;
X		in_col++;
X		out_col++;
X		break;
X	}
X}
X
X
Xvoid
Xtrace_printf(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	char		buffer[1 << 10];
X	va_list		ap;
X
X	sva_init(ap, s);
X	vsprintf(buffer, s, ap);
X	va_end(ap);
X	for (s = buffer; *s; ++s)
X		trace_putchar(*s);
X}
X
X
Xvoid
Xtrace_enable(file)
X	char		*file;
X{
X	string_ty	*s;
X	known_ty	*kp;
X
X	s = basename(file);
X	for (kp = known; kp; kp = kp->next)
X	{
X		if (str_equal(s, kp->filename))
X		{
X			str_free(s);
X			break;
X		}
X	}
X	if (!kp)
X	{
X		kp = (known_ty *)mem_alloc(sizeof(known_ty));
X		kp->filename = s;
X		kp->flag_p = 0;
X		kp->next = known;
X		known = kp;
X	}
X	kp->flag = 3; /* enabled */
X	if (kp->flag_p)
X		*kp->flag_p = kp->flag;
X}
X
X
Xvoid
Xtrace_char_real(name, vp)
X	char		*name;
X	char		*vp;
X{
X	trace_printf("%s = '", name);
X	if (*vp < ' ' || *vp > '~' || strchr("(){}[]", *vp))
X	{
X		char	*s;
X
X		s = strchr("\bb\nn\tt\rr\ff", *vp);
X		if (s)
X		{
X			trace_putchar('\\');
X			trace_putchar(s[1]);
X		}
X		else
X			trace_printf("\\%03o", (unsigned char)*vp);
X	}
X	else
X	{
X		if (strchr("'\\", *vp))
X			trace_putchar('\\');
X		trace_putchar(*vp);
X	}
X	trace_printf("'; /* 0x%02X, %d */\n", (unsigned char)*vp, *vp);
X}
X
X
Xvoid
Xtrace_char_unsigned_real(name, vp)
X	char		*name;
X	unsigned char	*vp;
X{
X	trace_printf("%s = '", name);
X	if (*vp < ' ' || *vp > '~' || strchr("(){}[]", *vp))
X	{
X		char	*s;
X
X		s = strchr("\bb\nn\tt\rr\ff", *vp);
X		if (s)
X		{
X			trace_putchar('\\');
X			trace_putchar(s[1]);
X		}
X		else
X			trace_printf("\\%03o", *vp);
X	}
X	else
X	{
X		if (strchr("'\\", *vp))
X			trace_putchar('\\');
X		trace_putchar(*vp);
X	}
X	trace_printf("'; /* 0x%02X, %d */\n", *vp, *vp);
X}
X
X
Xvoid
Xtrace_int_real(name, vp)
X	char		*name;
X	int		*vp;
X{
X	trace_printf("%s = %d;\n", name, *vp);
X}
X
X
Xvoid
Xtrace_int_unsigned_real(name, vp)
X	char		*name;
X	unsigned int	*vp;
X{
X	trace_printf("%s = %u;\n", name, *vp);
X}
X
X
Xvoid
Xtrace_long_real(name, vp)
X	char		*name;
X	long		*vp;
X{
X	trace_printf("%s = %ld;\n", name, *vp);
X}
X
X
Xvoid
Xtrace_long_unsigned_real(name, vp)
X	char		*name;
X	unsigned long	*vp;
X{
X	trace_printf("%s = %lu;\n", name, *vp);
X}
X
X
Xvoid
Xtrace_pointer_real(name, vptrptr)
X	char		*name;
X	void		*vptrptr;
X{
X	void		**ptr_ptr = vptrptr;
X	void		*ptr;
X
X	ptr = *ptr_ptr;
X	if (!ptr)
X		trace_printf("%s = NULL;\n", name);
X	else
X		trace_printf("%s = 0x%08lX;\n", name, ptr);
X}
X
X
Xvoid
Xtrace_short_real(name, vp)
X	char		*name;
X	short		*vp;
X{
X	trace_printf("%s = %hd;\n", name, *vp);
X}
X
X
Xvoid
Xtrace_short_unsigned_real(name, vp)
X	char		*name;
X	unsigned short	*vp;
X{
X	trace_printf("%s = %hu;\n", name, *vp);
X}
X
X
Xvoid
Xtrace_string_real(name, vp)
X	char		*name;
X	char		*vp;
X{
X	char		*s;
X	long		count;
X
X	trace_printf("%s = ", name);
X	if (!vp)
X	{
X		trace_printf("NULL;\n");
X		return;
X	}
X	trace_printf("\"");
X	count = 0;
X	for (s = vp; *s; ++s)
X	{
X		switch (*s)
X		{
X		case '('/*)*/:
X		case '['/*]*/:
X		case '{'/*}*/:
X			++count;
X			break;
X
X		case /*(*/')':
X		case /*[*/']':
X		case /*{*/'}':
X			--count;
X			break;
X		}
X	}
X	if (count > 0)
X		count = -count;
X	else
X		count = 0;
X	for (s = vp; *s; ++s)
X	{
X		int	c;
X
X		c = *s;
X		if (c < ' ' || c > '~')
X		{
X			char	*cp;
X
X			cp = strchr("\bb\ff\nn\rr\tt", c);
X			if (cp)
X				trace_printf("\\%c", cp[1]);
X			else
X			{
X				escape:
X				trace_printf("\\%03o", (unsigned char)c);
X			}
X		}
X		else
X		{
X			switch (c)
X			{
X			case '('/*)*/:
X			case '['/*]*/:
X			case '{'/*}*/:
X				++count;
X				if (count <= 0)
X					goto escape;
X				break;
X	
X			case /*(*/')':
X			case /*[*/']':
X			case /*{*/'}':
X				--count;
X				if (count < 0)
X					goto escape;
X				break;
X
X			case '\\':
X			case '"':
X				trace_printf("\\");
X				break;
X			}
X			trace_printf("%c", c);
X		}
X	}
X	trace_printf("\";\n");
X}
END_OF_FILE
if test 7532 -ne `wc -c <'common/trace.c'`; then
    echo shar: \"'common/trace.c'\" unpacked with wrong size!
fi
# end of 'common/trace.c'
fi
if test -f 'common/word.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/word.c'\"
else
echo shar: Extracting \"'common/word.c'\" \(6410 characters\)
sed "s/^X//" >'common/word.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate lists of strings
X *
X * This file contains routines for mainpulating words and word lists.
X * Much of the functionality of cook uses these routines.
X */
X
X#include <stddef.h>
X#include <string.h>
X#include <stdlib.h>
X#include <time.h>
X
X#include <error.h>
X#include <main.h>
X#include <mem.h>
X/* #include <os.h> */
X#include <str.h>
X#include <word.h>
X
X
X/*
X * NAME
X *	wl_append - append to a word list
X *
X * SYNOPSIS
X *	void wl_append(wlist *wlp, string_ty *wp);
X *
X * DESCRIPTION
X *	Wl_append is used to append to a word list.
X *
X * CAVEAT
X *	The word being appended IS copied.
X */
X
Xvoid
Xwl_append(wlp, w)
X	wlist		*wlp;
X	string_ty	*w;
X{
X	assert(wlp);
X	assert(w);
X	*(string_ty**)
X	enlarge
X	(
X		&wlp->wl_nwords,
X		(char**)&wlp->wl_word,
X		sizeof(string_ty *)
X	) =
X		str_copy(w);
X}
X
Xvoid
Xwl_prepend(wlp, w)
X	wlist		*wlp;
X	string_ty	*w;
X{
X	long		j;
X
X	assert(wlp);
X	assert(w);
X	enlarge(&wlp->wl_nwords, (char**)&wlp->wl_word, sizeof(string_ty *));
X	for (j = wlp->wl_nwords - 1; j > 0; --j)
X		wlp->wl_word[j] = wlp->wl_word[j - 1];
X	wlp->wl_word[0] = str_copy(w);
X}
X
X
X/*
X * NAME
X *	wl_free - free a word list
X *
X * SYNOPSIS
X *	void wl_free(wlist *wlp);
X *
X * DESCRIPTION
X *	Wl_free is used to free the contents of a word list
X *	when it is finished with.
X *
X * CAVEAT
X *	It is assumed that the contents of the word list were all
X *	created using strdup() or similar, and grown using wl_append().
X */
X
Xvoid
Xwl_free(wlp)
X	wlist		*wlp;
X{
X	int		j;
X
X	for (j = 0; j < wlp->wl_nwords; j++)
X		str_free(wlp->wl_word[j]);
X	if (wlp->wl_nwords)
X		free(wlp->wl_word);
X	wlp->wl_nwords = 0;
X	wlp->wl_word = 0;
X}
X
X
X/*
X * NAME
X *	wl_member - word list membership
X *
X * SYNOPSIS
X *	int wl_member(wlist *wlp, string_ty *wp);
X *
X * DESCRIPTION
X *	Wl_member is used to determine if the given word is
X *	contained in the given word list.
X *
X * RETURNS
X *	A zero if the word is not in the list,
X *	and a non-zero if it is.
X */
X
Xint
Xwl_member(wlp, w)
X	wlist		*wlp;
X	string_ty	*w;
X{
X	int		j;
X
X	for (j = 0; j < wlp->wl_nwords; j++)
X		if (str_equal(wlp->wl_word[j], w))
X			return 1;
X	return 0;
X}
X
X
X/*
X * NAME
X *	wl_copy - copy a word list
X *
X * SYNOPSIS
X *	void wl_copy(wlist *to, wlist *from);
X *
X * DESCRIPTION
X *	Wl_copy is used to copy word lists.
X *
X * RETURNS
X *	A copy of the 'to' word list is placed in 'from'.
X *
X * CAVEAT
X *	It is the responsibility of the caller to ensure that the
X *	new word list is freed when finished with, by a call to wl_free().
X */
X
Xvoid
Xwl_copy(to, from)
X	wlist		*to;
X	wlist		*from;
X{
X	int		j;
X
X	wl_zero(to);
X	for (j = 0; j < from->wl_nwords; j++)
X		wl_append(to, str_copy(from->wl_word[j]));
X}
X
X
X/*
X * NAME
X *	wl2str - form a string from a word list
X *
X * SYNOPSIS
X *	string_ty *wl2str(wlist *wlp, int start, int stop);
X *
X * DESCRIPTION
X *	Wl2str is used to form a string from a word list.
X *
X * RETURNS
X *	A pointer to the newly formed string in dynamic memory.
X *
X * CAVEAT
X *	It is the responsibility of the caller to ensure that the
X *	new string is freed when finished with, by a call to free().
X */
X
Xstring_ty *
Xwl2str(wl, start, stop)
X	wlist		*wl;
X	int		start;
X	int		stop;
X{
X	int		j;
X	static char	*tmp;
X	static size_t	tmplen;
X	size_t		length;
X	char		*pos;
X	string_ty	*s;
X
X	length = 0;
X	for (j = start; j <= stop && j < wl->wl_nwords; j++)
X	{
X		s = wl->wl_word[j];
X		if (s->str_length)
X		{
X			if (length)
X				++length;
X			length += s->str_length;
X		}
X	}
X
X	if (!tmp)
X	{
X		tmplen = length;
X		if (tmplen < 16)
X			tmplen = 16;
X		tmp = mem_alloc(tmplen);
X	}
X	else
X	{
X		if (tmplen < length)
X		{
X			tmplen = length;
X			mem_change_size(&tmp, tmplen);
X		}
X	}
X
X	pos = tmp;
X	for (j = start; j <= stop && j < wl->wl_nwords; j++)
X	{
X		s = wl->wl_word[j];
X		if (s->str_length)
X		{
X			if (pos != tmp)
X				*pos++ = ' ';
X			memcpy(pos, s->str_text, s->str_length);
X			pos += s->str_length;
X		}
X	}
X
X	s = str_n_from_c(tmp, length);
X	return s;
X}
X
X
X/*
X * NAME
X *	str2wl - string to word list
X *
X * SYNOPSIS
X *	void str2wl(wlist *wlp, string_ty *s);
X *
X * DESCRIPTION
X *	Str2wl is used to form a word list from a string.
X *
X * RETURNS
X *	The string is broken on spaces into words,
X *	using strndup() and wl_append().
X *
X * CAVEAT
X *	Quoting is not understood.
X */
X
Xvoid
Xstr2wl(wlp, s)
X	wlist		*wlp;
X	string_ty	*s;
X{
X	char		*cp;
X	char		*cp1;
X
X	wl_zero(wlp);
X	cp = s->str_text;
X	while (*cp)
X	{
X		string_ty *w;
X
X		while (*cp == ' ')
X			cp++;
X		if (!*cp)
X			break;
X		cp1 = cp;
X		while (*cp && *cp != ' ')
X			cp++;
X		w = str_n_from_c(cp1, cp - cp1);
X		wl_append(wlp, w);
X		str_free(w);
X	}
X}
X
X
X/*
X * NAME
X *	wl_insert - a insert a word into a list
X *
X * SYNOPSIS
X *	void wl_insert(wlist *wlp, string_ty *wp);
X *
X * DESCRIPTION
X *	Wl_insert is similar to wl_append, however it does not
X *	append the word unless it is not already in the list.
X *
X * CAVEAT
X *	If the word is inserted it is copied.
X */
X
Xvoid
Xwl_append_unique(wlp, wp)
X	wlist		*wlp;
X	string_ty	*wp;
X{
X	int		j;
X
X	for (j = 0; j < wlp->wl_nwords; j++)
X		if (str_equal(wlp->wl_word[j], wp))
X			return;
X	wl_append(wlp, wp);
X}
X
X
X/*
X * NAME
X *	wl_delete - remove list member
X *
X * SYNOPSIS
X *	void wl_delete(wlist *wlp, string_ty *wp);
X *
X * DESCRIPTION
X *	The wl_delete function is used to delete a member of a word list.
X *
X * RETURNS
X *	void
X */
X
Xvoid
Xwl_delete(wlp, wp)
X	wlist		*wlp;
X	string_ty	*wp;
X{
X	int		j;
X	int		k;
X
X	for (j = 0; j < wlp->wl_nwords; ++j)
X	{
X		if (str_equal(wlp->wl_word[j], wp))
X		{
X			wlp->wl_nwords--;
X			for (k = j; k < wlp->wl_nwords; ++k)
X				wlp->wl_word[k] = wlp->wl_word[k + 1];
X			str_free(wp);
X			break;
X		}
X	}
X}
X
Xvoid
Xwl_zero(wlp)
X	wlist		*wlp;
X{
X	wlp->wl_nwords = 0;
X	wlp->wl_word = 0;
X}
END_OF_FILE
if test 6410 -ne `wc -c <'common/word.c'`; then
    echo shar: \"'common/word.c'\" unpacked with wrong size!
fi
# end of 'common/word.c'
fi
if test -f 'cook/option.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/option.c'\"
else
echo shar: Extracting \"'cook/option.c'\" \(7011 characters\)
sed "s/^X//" >'cook/option.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manage command line options
X *
X * The options may be set at various levels.  The level with the highest
X * precedence which has actually been set is used to determine the option
X * value at any given time.
X *
X * Each level of an option is represented by 2 bits in the flag word.  One bit
X * is used to indicate that the option has been set for that level, the other
X * bit indicates the state.  Determining the least set bit in an expression is
X * cheap (x&-x) so highest priority is the lowest numbered level.
X *
X * The COOK enviroment variable is basically a replacement for the defaults,
X * so that users can change the default behaviour.  The command line overrides
X * almost everything.  The error level is the only level with higher
X * precedence than the command line, and it is used to prevent disasters
X * after parse errors or interrupts have happened.
X */
X
X#include <ctype.h>
X#include <limits.h>
X#include <stddef.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <time.h>
X
X#include <main.h>
X#include <option.h>
X#include <error.h>
X#include <os.h>
X#include <mem.h>
X
X
Xoption_ty option;
X
X
X/*
X * NAME
X *	option_set - set an option
X *
X * SYNOPSIS
X *	void option_set(option_number_ty num, option_level_ty lvl, int state);
X *
X * DESCRIPTION
X *	The option_set function is used to set the given option at the given
X *	level to the given state.
X *
X * RETURNS
X *	void
X */
X
Xvoid
Xoption_set(o, level, state)
X	option_number_ty	o;
X	option_level_ty	level;
X	int		state;
X{
X	assert((int)o >= 0 && (int)o < (int)OPTION_max);
X	if (state)
X		option.o_flag[(size_t)o] |= 3 << (2 * (int)level);
X	else
X		option.o_flag[(size_t)o] |= 1 << (2 * (int)level);
X}
X
X
X/*
X * NAME
X *	option_already - see if an option is already set
X *
X * SYNOPSIS
X *	int option_already(option_number_ty num, option_level_ty lvl);
X *
X * DESCRIPTION
X *	The option_already function is used to test if a given option at a
X *	given level has been set.
X *
X * RETURNS
X *	int: zero if the option has not been set, nonzero if it has.
X */
X
Xint
Xoption_already(o, level)
X	option_number_ty	o;
X	option_level_ty	level;
X{
X	assert((int)o >= 0 && (int)o < (int)OPTION_max);
X	return ((option.o_flag[(size_t)o] >> (2 * (int)level)) & 1) != 0;
X}
X
X
X/*
X * NAME
X *	option_undo - remove option setting
X *
X * SYNOPSIS
X *	void option_undo(option_number_ty num, option_level_ty lvl);
X *
X * DESCRIPTION
X *	The option_undo function is used to is used to remove the option
X *	setting for the given option at the given level.
X *
X * RETURNS
X *	void
X */
X
Xvoid
Xoption_undo(o, level)
X	option_number_ty	o;
X	option_level_ty	level;
X{
X	assert((int)o >= 0 && (int)o < (int)OPTION_max);
X	option.o_flag[(size_t)o] &= ~(3 << (2 * (int)level));
X}
X
X
X/*
X * NAME
X *	option_undo_level - remove options settings
X *
X * SYNOPSIS
X *	void option_undo_level(option_level_ty lvl);
X *
X * DESCRIPTION
X *	The option_undo_level function is used to remove the settings for all
X *	options at a given level.
X *
X * RETURNS
X *	void
X */
X
Xvoid
Xoption_undo_level(level)
X	option_level_ty	level;
X{
X	int		o;
X
X	for (o = 0; o < (int)OPTION_max; ++o)
X		option_undo((option_number_ty)o, level);
X}
X
X
X/*
X * NAME
X *	option_test - test an option
X *
X * SYNOPSIS
X *	int option_test(option_number_ty num);
X *
X * DESCRIPTION
X *	The option_test function is used to test the setting of an option.
X *	The level of highest precedence which hash been set is used.
X *
X * RETURNS
X *	int: zero if the option is off, nonzero if the option is on.
X */
X
Xint
Xoption_test(o)
X	option_number_ty	o;
X{
X	unsigned	*op;
X	unsigned	mask;
X
X	assert((int)o >= 0 && (int)o < (int)OPTION_max);
X	op = &option.o_flag[(size_t)o];
X	mask = *op & 0x55555555;
X	mask &= -mask; /* get LSB */
X	return (*op & (mask << 1)) != 0;
X}
X
X
X/*
X * NAME
X *	option_tidy_up - mother hen
X *
X * SYNOPSIS
X *	void option_tidy_up(void);
X *
X * DESCRIPTION
X *	The option_tidy_up function is used to set a few defaults, and tidy up
X *	after the command line.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	Must be called after the command line has been parsed.
X */
X
X#ifndef PATH_MAX
X#define PATH_MAX 2000
X#endif
X
Xvoid
Xoption_tidy_up()
X{
X	string_ty	*s;
X	string_ty	*s1;
X
X	/*
X	 * user's library
X	 */
X	s = os_accdir();
X	assert(s);
X	s1 = str_format("%S/.%s", s, progname);
X	str_free(s);
X	wl_append_unique(&option.o_search_path, s1);
X	str_free(s1);
X
X	/*
X	 * cook's library
X	 */
X	s = str_from_c(LIBDIR);
X	wl_append_unique(&option.o_search_path, s);
X	str_free(s);
X
X	if (!option.o_book)
X	{
X		static char *name[] =
X		{
X			".how.to.%s",
X			".howto.%s",
X			"how.to.%s",
X			"howto.%s",
X			"%s.file",
X			"%sfile",
X			".%s.rc",
X			".%src",
X		};
X		int	j;
X	
X		/*
X		 * A huge range of alternative default names is given.
X		 * The first found will be used.
X		 */
X		for (j = 0; j < SIZEOF(name); j++)
X		{
X			char	format[300];
X
X			strcpy(format, name[j]);
X			floop:
X			s = str_format(format, progname);
X			switch (os_exists(s))
X			{
X			case -1:
X				exit(1);
X
X			case 0:
X				str_free(s);
X				if (islower(format[0]))
X				{
X					format[0] = toupper(format[0]);
X					goto floop;
X				}
X				continue;
X
X			case 1:
X				option.o_book = s;
X				break;
X			}
X			break;
X		}
X	}
X
X	if (!option.o_logfile && option.o_book)
X	{
X		char		*sp;
X		char		*cp;
X
X		sp = option.o_book->str_text;
X		/* skip first char in case it's a '.' */
X		cp = strrchr(sp + 1, '.');
X		if (cp)
X			s = str_n_from_c(sp, cp - sp);
X		else
X			s = str_copy(option.o_book);
X		sp = (option_test(OPTION_CMDFILE) ? "sh" : "list");
X		option.o_logfile = str_format("%S.%s", s, sp);
X		str_free(s);
X	}
X
X	option_set(OPTION_ACTION, OPTION_LEVEL_DEFAULT, 1);
X	option_set(OPTION_LOGGING, OPTION_LEVEL_DEFAULT, 1);
X	option_set(OPTION_TERMINAL, OPTION_LEVEL_DEFAULT, 1);
X}
X
X
X/*
X * NAME
X *	option_set_errors - set error flags
X *
X * SYNOPSIS
X *	void option_set_errors(void);
X *
X * DESCRIPTION
X *	The option_set_errors function is used to set the appropriate options
X *	to prevent undesirable side effects when errors occur.
X *
X * RETURNS
X *	void
X */
X
Xvoid
Xoption_set_errors()
X{
X	option_set(OPTION_SILENT, OPTION_LEVEL_ERROR, 0);
X	option_set(OPTION_ACTION, OPTION_LEVEL_ERROR, 0);
X	option_set(OPTION_ERROK, OPTION_LEVEL_ERROR, 0);
X	option_set(OPTION_METER, OPTION_LEVEL_ERROR, 0);
X	option_set(OPTION_PERSEVERE, OPTION_LEVEL_ERROR, 0);
X}
END_OF_FILE
if test 7011 -ne `wc -c <'cook/option.c'`; then
    echo shar: \"'cook/option.c'\" unpacked with wrong size!
fi
# end of 'cook/option.c'
fi
if test -f 'cooktime/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cooktime/main.c'\"
else
echo shar: Extracting \"'cooktime/main.c'\" \(7008 characters\)
sed "s/^X//" >'cooktime/main.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: operating system start point, and parse command line arguments
X */
X
X#include <stddef.h>
X#include <stdio.h>
X#include <string.h>
X#include <stdlib.h>
X#include <sys/types.h>
X#include <utime.h>
X#include <sys/stat.h>
X
X#include <arglex.h>
X#include <date.h>
X#include <error.h>
X#include <help.h>
X#include <main.h>
X#include <str.h>
X#include <trace.h>
X#include <version.h>
X#include <word.h>
X
X
Xstatic void usage _((void));
X
Xstatic void
Xusage()
X{
X	fprintf(stderr, "usage: %s [ <option>... ] <filename>\n", progname);
X	fprintf(stderr, "       %s -Help\n", progname);
X	fprintf(stderr, "       %s -VERsion\n", progname);
X	exit(1);
X}
X
X
Xstatic void main_help _((void));
X
Xstatic void
Xmain_help()
X{
X	static char *text[] =
X	{
X"NAME",
X"	%s - set file times",
X"",
X"SYNOPSIS",
X"	%s [ <option>... ] <filename>...",
X"	%s -Help",
X"	%s -VERSion",
X"",
X"DESCRIPTION",
X"	The %s program is used to set the modified time or",
X"	access time of a file. This can be used to defend",
X"	against unwanted logical dependencies when making \"minor\"",
X"	changes to files.",
X"",
X"	If no option is specified, the default action is as if",
X"	\"-Modify now\" was specified.",
X"",
X"OPTIONS",
X"	The following options are understood.",
X"",
X"	-Access <date>",
X"		This option may be used to set the last-access",
X"		time of the files.  The date is relatively free-",
X"		format; rember to use quotes to insulate spaces",
X"		from the shell.",
X"",
X"	-Modify <date>",
X"		This option may be used to set the last-modify",
X"		time of the files.  The date is relatively free-",
X"		format; rember to use quotes to insulate spaces",
X"		from the shell.",
X"",
X"	-Report",
X"		When use alone, produces a listing of access",
X"		times and modify times for the named files.  When",
X"		used with -Access or -Modify, produces a listing",
X"		of the changes made.",
X"",
X"	-Help",
X"		Give some information on how to use the %s",
X"		command.",
X"",
X"	Any other option will generate a disgnostic error.",
X"",
X"	All options may be abbreviated; the abbreviation is",
X"	documented as the upper case letters, all lower case",
X"	letters and underscores (_) are optional.  You must use",
X"	consecutive sequences of optional letters.",
X"",
X"	All options are case insensitive, you may type them in",
X"	upper case or lower case or a combination of both, case",
X"	is not important.",
X"",
X"	For example: the arguments \"-help\", \"-HEL\" and \"-h\" are",
X"	all interpreted to mean the -Help option.  The argument",
X"	\"-hlp\" will not be understood, because consecutive",
X"	optional characters were not supplied.",
X"",
X"	Options and other command line arguments may be mixed",
X"	arbitrarily on the command line.",
X"",
X"	The GNU long option names are understood.  Since all",
X"	option names for %s are long, this means ignoring",
X"	the extra leading '-'. The \"--option=value\" convention",
X"	is also understood.",
X"",
X"EXIT STATUS",
X"	The %s command will exit with a status of 1 on any",
X"	error. The %s command will only exit with a status",
X"	of 0 if there are no errors.",
X"",
X"COPYRIGHT",
X"	%C",
X"",
X"AUTHOR",
X"	%A",
X	};
X
X	trace(("c_incl_help()\n{\n"/*}*/));
X	help(text, SIZEOF(text), usage);
X	trace((/*{*/"}\n"));
X}
X
X
Xenum
X{
X	arglex_token_access,
X	arglex_token_modify,
X	arglex_token_report
X};
X
Xstatic	arglex_table_ty	argtab[] =
X{
X	{ "-Access",	(arglex_token_ty)arglex_token_access,	},
X	{ "-Modify",	(arglex_token_ty)arglex_token_modify,	},
X	{ "-Report",	(arglex_token_ty)arglex_token_report,	},
X	{ 0, (arglex_token_ty)0, }, /* end marker */
X};
X
X
Xint main _((int, char **));
X
Xint
Xmain(argc, argv)
X	int		argc;
X	char		**argv;
X{
X	wlist		filename;
X	string_ty	*s;
X	size_t		j;
X	int		mtime_set;
X	long		mtime;
X	int		atime_set;
X	long		atime;
X	int		report;
X
X	arglex_init(argc, argv, argtab);
X	str_initialize();
X	switch (arglex())
X	{
X	case arglex_token_help:
X		main_help();
X		exit(0);
X
X	case arglex_token_version:
X		version();
X		exit(0);
X
X	default:
X		break;
X	}
X
X	report = 0;
X	atime_set = 0;
X	atime = 0;
X	mtime_set = 0;
X	mtime = 0;
X	wl_zero(&filename);
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch(arglex_token)
X		{
X		default:
X			error
X			(
X				"misplaced \"%s\" command line argument",
X				arglex_value.alv_string
X			);
X			usage();
X
X		case arglex_token_string:
X			s = str_from_c(arglex_value.alv_string);
X			wl_append(&filename, s);
X			str_free(s);
X			break;
X
X		case arglex_token_report:
X			if (report)
X			{
X				duplicate:
X				fatal
X				(
X					"duplicate \"%s\" option",
X					arglex_value.alv_string
X				);
X			}
X			report++;
X			break;
X
X		case arglex_token_access:
X			if (atime_set)
X				goto duplicate;
X			if (arglex() != arglex_token_string)
X				fatal("-Access requires a string argument");
X			atime_set = 1;
X			atime = date_scan(arglex_value.alv_string);
X			if (atime < 0)
X				fatal
X				(
X					"the string \"%s\" is not a valid date",
X					arglex_value.alv_string
X				);
X			break;
X
X		case arglex_token_modify:
X			if (mtime_set)
X				goto duplicate;
X			if (arglex() != arglex_token_string)
X				fatal("-Modify requires a string argument");
X			mtime_set = 1;
X			mtime = date_scan(arglex_value.alv_string);
X			if (mtime < 0)
X				fatal
X				(
X					"the string \"%s\" is not a valid date",
X					arglex_value.alv_string
X				);
X			break;
X
X#ifdef DEBUG
X		case arglex_token_tracing:
X			if (arglex() != arglex_token_string)
X				fatal("-TRACIng requires one or more string arguments");
X			for (;;)
X			{
X				trace_enable(arglex_value.alv_string);
X				if (arglex() != arglex_token_string)
X					break;
X			}
X			continue;
X#endif
X		}
X		arglex();
X	}
X	if (!filename.wl_nwords)
X		fatal("no files named");
X	if (!report && !mtime_set && !atime_set)
X	{
X		mtime_set = 1;
X		mtime = date_scan("now");
X	}
X
X	for (j = 0; j < filename.wl_nwords; ++j)
X	{
X		struct stat	st;
X		struct utimbuf	ut;
X
X		s = filename.wl_word[j];
X		if (stat(s->str_text, &st))
X			nfatal("%s", s->str_text);
X		if (mtime_set)
X			ut.modtime = mtime;
X		else
X			ut.modtime = st.st_mtime;
X		if (atime_set)
X			ut.actime = atime;
X		else
X			ut.actime = st.st_atime;
X		if ((atime_set || mtime_set) && utime(s->str_text, &ut))
X			nfatal("%s", s->str_text);
X		if (report)
X		{
X			printf("%s\n", s->str_text);
X			printf("\taccess %s\n", date_string(ut.actime));
X			printf("\tmodify %s\n", date_string(ut.modtime));
X		}
X	}
X	exit(0);
X	return 0;
X}
END_OF_FILE
if test 7008 -ne `wc -c <'cooktime/main.c'`; then
    echo shar: \"'cooktime/main.c'\" unpacked with wrong size!
fi
# end of 'cooktime/main.c'
fi
if test -f 'doc/cmdline' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/cmdline'\"
else
echo shar: Extracting \"'doc/cmdline'\" \(6085 characters\)
sed "s/^X//" >'doc/cmdline' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, The Command Line
X.\"	
X.H 1 "The Command Line"
X.B Cook
Xmay be invoked from the
Xcommand line by a command of the form
X.DS
X.in +0.5i
X.fi
X.B cook
X[
X.IR option ...
X]
X[
X.IR filename ...
X]
X.in -0.5i
X.DE
XOptions and filenames may be arbitrarily mixed on the command line;
Xno processing is done until all options and filenames
Xon the command line have been scanned.
X.P
X.B Cook
Xwill attempt to create the named files from the recipes
Xgiven to it.
XThe recipes are contained in a file called
X.I Howto.cook
Xin the current directory.
XThis file may, in turn, include other files containing additional recipes.
X.P
XIf no
X.IR filename s
Xare given on the command line
Xthe targets of the first recipe defined are cooked.
X.H 2 "Options"
XThe valid options for
X.B cook
Xare listed below.
XAny other options
X(words on the command line beginning with `\fB-\fP')
Xwill cause a diagnostic message to be issued.
X.VL 1i
X.LI \fB-Action\fP
XExecute the commands given in the recipes.
XThis is the default.
X.LI \fB-NoAction\fP
XDo not execute the commands given in the recipes.
X.LI \fB-Continue\fP
XIf cooking a target should fail,
Xcontinue with other recipes for which the failed target is not an ingredient,
Xdirectly or indirectly.
X.LI \fB-NoContinue\fP
XIf cooking a target should fail,
X.B cook
Xwill exit.
XThis is the default.
X.LI \fB-Errok\fP
XWhen a command is executed,
Xthe exit code will be ignored.
X.LI \fB-NoErrok\fP
XWhen a command is executed,
Xif the exit code is positive
Xit will be deemed to fail,
Xand thus the recipe containing it to have failed.
XThis is the default.
X.LI \fB-Force\fP
XAlways perform the actions of recipes,
Xirrespective of the last-modified times of any of the ingredients.
X.P
XThis option is useful if something beyond the scope of the cookbook
Xhas been modified;
Xfor example, a bug fix in a compiler.
X.LI \fB-NoForce\fP
XPerform the actions of the recipes
Xif any of the ingredients are logically out of date.
XThis is the default.
X.LI \fB-Help\fP
XProvide information about how to execute
X.B cook
Xon 
X.IR stdout ,
Xand perform no other function.
X.LI "\fB-Include\fP \fIfilename\fP"
X.br
XSearch the named directory before the standard places for
Xincluded cookbooks.
XEach directory so named will be scanned in the order given.
XThe standard places are
X.I $HOME/.cook
Xthen
X.IR /usr/local/lib/cook .
X.LI \fB-List\fP
XCauses
X.B cook
Xto automatically redirect the
X.I stdout
Xand
X.I stderr
Xof the session.
XOutput will continue to come to the terminal,
Xunless 
X.B cook
Xis executing in the background.
XThe name of the file will be the name of the cookbook with any suffix
Xremoved and "\f(CW.list\fP" appended;
Xthis will usually be
X.IR Howto.list .
XThis is the default.
X.LI "\fB-List\fP \fIfilename\fP"
XCauses 
X.B cook
Xto automatically redirect the
X.I stdout 
Xand
X.I stderr
Xof the session into the named file.
XOutput will continue to come to the terminal,
Xunless 
X.B cook
Xis executing in the background.
X.LI \fB-NoList\fP
XNo automatic redirection of the session of the session will be made.
X.LI "\fB-NoList\fP \fIfilename\fP"
X.br
XNo automatic redirection of the session of the session will be made,
Xhowever subsequent
X.B -List
Xoptions will default to listing to the named file.
X.LI \fB-Meter\fP
XAfter each command is executed,
Xprint a summary of the command's CPU usage.
X.LI \fB-NoMeter\fP
XDo not print a CPU usage summary after each command.
XThis is the default.
X.LI \fB-Precious\fP
XWhen commands in the body of a recipe fail,
Xno not delete the targets of the recipe.
X.LI \fB-NoPrecious\fP
XWhen commands in the body of a recipe fail,
Xdelete the targets of the recipe.
XThis is the default.
X.LI \fB-Silent\fP
XDo not echo commands before they are executed.
X.LI \fB-NoSilent\fP
XEcho commands before they are executed.
XThis is the default.
X.LI \fB-Touch\fP
XUpdate the last-modified times of the
Xtarget files,
Xrather than execute the actions bound to recipes.
X.P
XThis can be useful if you have made a modification to a file that
Xyou know will make a
Xsystem of files logically out of date,
Xbut has no significance;
Xfor example,
Xadding a comment to a widely used include file.
X.LI \fB-NoTouch\fP
XExecute the actions bound to recipes,
Xrather than update the last-modified times of the target files.
XThis is the default.
X.LI \fB-TTy\fP
XWhen listing,
Xalso send the output stream to the terminal.
XThis is the default.
X.LI \fB-NoTTy\fP
XWhen listing,
Xdo not send the output to the terminal.
X.LI \fIname\fP\fB=\fP\fIvalue\fP
XAssign the
X.I value
Xto the named variable.
XThe value may contain spaces
Xif you can convince the shell to pass them through.
X.LE
X.P
XIn the above descriptions,
Xa shorter form is indicated by the uppercase letters;
Xfor example,
Xthe
X.B -NoTouch
Xoption may be abbreviated to
X.BR -nt .
X.B Cook
Xis case insensitive to the options,
Xso you may arbitrarily mix cases within the options.
X.P
XTwo options are provided for
Xtracing the inferences
X.B cook 
Xmakes when attempting to cook a target.
X.VL 1i
X.LI \fB-TRace\fP
X.B Cook
Xwill emit copious amounts of information
Xabout the inferences it is making when cooking targets.
XThis option may be used when you think 
X.B cook
Xis acting strangely,
Xor are just curious.
X.LI \fB-NoTRace\fP
X.B Cook
Xwill not emit information
Xabout the inferences it is making when cooking targets.
XThis is the default.
X.LE
END_OF_FILE
if test 6085 -ne `wc -c <'doc/cmdline'`; then
    echo shar: \"'doc/cmdline'\" unpacked with wrong size!
fi
# end of 'doc/cmdline'
fi
if test -f 'doc/how' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/how'\"
else
echo shar: Extracting \"'doc/how'\" \(5996 characters\)
sed "s/^X//" >'doc/how' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, Actions when Cooking
X.\"	
X.H 1 "Actions when Cooking"
XThis section describes what 
X.B cook
Xdoes when you ask it to cook something.
X.P
X.B Cook
Xperforms the following actions in the order stated.
X.H 2 "Scan the COOK Environment Variable"
XThe
X.B COOK
Xenvironment variable is looked for.
XIf it is found,
Xit is treated as if it consisted of
X.B cook
Xcommand line arguments.
XOnly the
X.B -Help
Xoption is illegal.
XThis could result is very strange behaviour if used incorrectly.
X.P
XThis feature is supplied to override
X.BR cook 's
Xdefault with your own preferences.
X.H 2 "Scan the Command Line"
XThe command line is scanned 
Xas defined in chapter 3.
X.H 2 "Locate the Cookbook"
XThe current directory is scanned for the cookbook.
XNames which a cookbook may have include
X.TS
Xcenter, tab(;);
Xc c c.
Xhowto.cook;Howto.cook;.howto.cook
Xhow.to.cook;How.to.cook;.how.to.cook
Xcookfile;Cookfile;.cookrc
Xcook.file;Cook.file;.cook.rc
X.TE
XThe first so named file found in the current directory
Xwill be used.
XThe order of search is not defined.
XYou are strongly advised to have just 
X.I one
Xof these name forms in any directory.
XThe name
X.I Howto.cook
Xis the preferred form.
X.H 2 "Form the Listing Filename"
XThe listing file,
Xif not explicitly named in the environment variable or on the command line,
Xwill be the name of the cookbook,
Xwith any suffix removed and '\f(CW.list\fP' appended.
X.H 2 "Create the Listing file"
XThe listing file is created.
XIf 
X.B cook
Xis executing in the background,
Xor the
X.B -NoTTy
Xoption has been specified,
X.I stdout
Xand
X.I stderr
Xwill be redirected into the listing file.
XIf
X.B cook
Xis executing in the foreground,
Xand the
X.B -NoTTy
Xoption has not been specified,
X.I stdout
Xand 
X.I stderr
Xwill be redirected into
Xa pipe to a
X.IR tee (1)
Xcommand;
Xwhich will, in turn, copy the output into the named file.
X.P
XA heading line with the name of the file and the date,
Xis generated.
X.H 2 "Scan the Cookbook"
XWhen 
X.B cook
Xreads the cookbook it evaluates all of the statements it
Xfinds in it.
XUsually these statements instanciate recipes,
Xalthough other things are possible.
X.P
XRecipes contain statements that are not evaluated immediately,
Xbut which are remembered for later execution when cooking a target.
XThe meaning of a cookbook is defined in chapter X.
X.H 2 "Determine targets to cook"
XIf no target files are named on the command line,
Xthe targets of the first defined explicit or ingredients recipe.
XIt is an error if this is none.
X.H 2 "Cooking a Target"
XEach of the targets,
Xin the order given,
Xare cooked.
X.P
XTo cook a target
Xeach the following steps is performed in the order given:
X.AL
X.LI
X.B Cook
Xscans through the instanciated ingredients recipes
Xin the order they were defined.
XAll ingredients recipes with the target in their target list are used.
X.P
XIf a recipe is used,
Xthen any ingredients are recursively cooked.
XIf any of the ingredients are younger than the target,
Xall other explicit or implicit recipes with the same target will
Xbe deemed to be out of date.\*F
X.FS
XA target which does not exist yet is considered to be infinitely ancient,
Xand thus everything is younger than it.
X.FE
X.LI
X.B Cook
Xthen scans through the instanciated explicit recipes
Xin the order they were defined.
XAll explicit recipes with the target in their target list are used.
X.P
XIf a recipe is a used,
Xthe ingredients are recursively cooked.
XIf any ingredients are out of date
Xthe recipe body will be performed.
X.LI
XIf the target was not in the target list of any explicit recipe,
X.B cook
Xthen scans the instanciated implicit recipes
Xin the order they were defined.
X.P
XImplicit recipe targets and ingredients may contain a wildcard
Xcharacter (\fB%\fP),
Xwhich is why they are implicit.
XWhen expressions are evaluated into word lists in an implicit recipe,
Xany word containing the wildcard character (\fB%\fP) will be expanded
Xout by the current wildcard expansion.
X.P
XIf the target matches a pattern in the targets of an implicit recipe,
Xit is a candidate.
XEach ingredient of a candidate recipe is recursively cooked.
XIf any ingredient cannot be cooked,
Xthen the implicit recipe is not used.
XIf all ingredients can be cooked,
Xthen the implicit recipe is used.
X.P
XIf an implicit recipe is a used,
Xthe forced ingredients are recursively cooked.
XIt is an error if a forced ingredient cannot be constructed.
XAfter the forced ingredients are constructed,
Xthe recipe body is performed.
X.P
XOnly the first implicit recipe to get to this point is used.
XThe scan stops at this point.
X.LI
XIf the target is not the subject of any ingredients or explicit
Xrecipe,
Xand no implicit recipes can be applied,
Xthen two things can happen.
X.BL
X.LI
XIf the file exists, then it is up to date, or
X.LI
XIf the file does not exist then 
X.B cook
Xdoesn't know how.
X.LE
X.LE
X.P
XIf a command in the body of any recipe fail, 
X.B cook
Xwill not that body any further,
Xand will not perform the body of any recipe for which the target
Xof the failed actions was an ingredient,
Xdirectly or indirectly.
X.P
X.B Cook
Xwill trap recursive looping of targets.
X.BL
X.LI
XIf the file exists, the it is up to date, or
X.LI
XIf the file does not exist then 
X.B cook
Xdoesn't know how.
X.LE
END_OF_FILE
if test 5996 -ne `wc -c <'doc/how'`; then
    echo shar: \"'doc/how'\" unpacked with wrong size!
fi
# end of 'doc/how'
fi
if test -f 'doc/intro.bb' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/intro.bb'\"
else
echo shar: Extracting \"'doc/intro.bb'\" \(6857 characters\)
sed "s/^X//" >'doc/intro.bb' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, Cook from a Cookbook
X.\"	
X.H 1 "Cook from a Cookbook"
XThis chapter describes the contents and meaning of a cookbook,
Xa file which contains information
X.B cook
Xneeds to do its job.
XIt focuses on what a cookbook looks like,
Xand touches on a few areas of how 
X.B cook
Xworks does its job.
X.H 2 "What does Cook do?"
XThe basic building block for
X.B cook
Xis the concept of a
X.IR recipe .
XA recipe has three parts:
X.AL
X.LI
Xone or more files which the recipe constructs,
Xknown as the 
X.I targets
Xof the recipe
X.LI
Xzero or more files which are used by the recipe to construct the target,
Xknown as the
X.I ingredients
Xof the recipe
X.LI
Xone or more commands to execute which construct 
Xthe targets from the ingredients,
Xknown as the
X.I body
Xof the recipe.
X.LE
X.P
XWhen a number of recipes are given,
Xsome recipes may describe how to cook the ingredients of other recipes.
XWhen
X.B cook
Xis asked to construct a particular target it
Xautomatically determines the correct order to perform the 
Xrecipe bodies to cook the requested target.
X.P
X.B Cook 
Xwould not be especially useful if you had to give explicit recipes 
Xfor how to cook every little thing.
XAs a result,
X.B cook
Xhas the concept of an
X.I implicit
Xrecipe.
XAn implicit recipe is very similar to an explicit recipe,
Xexcept that the targets and ingredients of the recipe
Xare 
X.I patterns
Xto be matched to file names,
Xrather than explicit file names.
XThis means it is possible to write a recipe,
Xfor example
Xwhich constructs a files with a name ending in `\fB.o\fP' from a file 
Xof the same name, but ending in `\fB.c\fP' rather than `\fB.o\fP'.
X.P
XIn addition to recipes,
X.B cook
Xneeds to know
X.I when
Xto construct targets from ingredients.
X.B Cook
Xhas been designed to cook as little as possible.
X"As little as possible" is determined by examining when each file was last
Xmodified,
Xand only constructing targets when that are out of date with the ingredients.
X
X.H 3 "When is Cook useful?"
XFrom the above description, 
X.B cook
Xmay be described as a tool for maintaining consistency of sets of files.
X
X.H 3 "When is Cook not useful?"
XCook is not useful for maintaining consistency of sets of things
Xwhich are 
X.I within
Xfiles and thus
X.B cook
Xis unable to determine when they were modified.
XFor example,
X.B cook
Xis not useful for
Xmaintaining consistency of sets of records within a database.
X
X.H 2 "How do I tell Cook what to do?"
XSets of recipes are gathered together into cookbooks.
XWhen
X.B cook
Xis executed it looks for a cookbook of the name
X.I Howto.cook
Xin the current directory.
XIf you did not name a file to be constructed on the command line,
Xthe first target in the cookbook will be constructed.
X.P
XThe best way to understand how to write recipes is an example.
XIn this example, a  program,
X.IR prog ,
Xis composed of three files:
X.IR foo.c ,
X.I bar.c
Xand
X.IR baz.c .
XTo inform
X.B cook
Xof this,
Xthe cookbook
X.eB
X#include "c"
X
Xprog: foo.o bar.o baz.o
X    {
X	cc -o prog foo.o bar.o baz.o;
X    }
X.eE
Xis sufficient for 
X.I prog
Xto be constructed.
X.P
XThis cookbook has two parts.
XThe line
X.eB
X#include "c"
X.eE
Xtells
X.B cook
Xto refer to a system cookbook which tells it,
Xamong other things,
Xhow to construct a 
X.IB something .o
Xfile from a
X.IB something .c
Xfile.
X.P
XThe second part is a recipe.
XThe first line of this recipe
X.eB
Xprog: foo.o bar.o baz.o
X    ...
X.eE
Xnames the target,
X.IR prog ,
Xand the ingredients,
X.IR foo.o ,
X.I bar.o
Xand
X.IR baz.o .
X.P
XThe next three lines
X.eB
X\&...
X    {
X	cc -o prog foo.o bar.o baz.o;
X    }
X.eE
Xare the recipe body,
Xwhich consists of a single
X.IR cc (1)
Xcommand to be executed.
XRecipe bodies are always within
X.B {
Xcurly braces
X.BR } ,
Xand commands always end with a semicolon
X.RB ( ; ).
X.P
XThus,
Xto update
X.I prog
Xafter any of the source files have been edited,
Xit is only necessary to issue the command
X.eB
Xcook prog
X.eE
XThis could be simplified further,
Xbecause 
X.B cook
Xwill cook the targets of the first recipe by default;
Xin this case,
X.IR prog .
X.P
XThe power of cook becomes more apparent when include files are
Xconsidered.
XIf the files
X.I foo.c
Xand
X.I baz.c
Xinclude the file
X.IR defs.h ,
Xthis would automatically be detected by
X.BR cook .
XIf 
X.I defs.h
Xwere to be edited,
Xand
X.B cook
Xre-executed,
Xthis would cause 
X.B cook
Xto recompile
Xboth
X.I foo.c
Xand
X.IR baz.c ,
Xand relink 
X.IR prog.
X.H 3 "The common program case"
XThe above example may be simplified even further.
XIf the four files
X.IR foo.c ,
X.IR bar.c ,
X.IR baz.c
Xand
X.I defs.h
Xall resided in a directory with a path of
X.IR /some/where/prog ,
Xthe the 
X.I Howto.cook
Xfile in that directory need only contain
X.eB
X#include "c"
X#include "program"
X.eE
Xfor 
X.I prog
Xto be cooked.
XThis is because the "\f(CWprogram\fP" cookbook
Xlooks for all of the 
X.IB something .c
Xfiles in the current directory,
Xcompiles them all,
Xand links them into a program named after the current directory.
X.P
XThe default target in the "\f(CWprogram\fP" cookbook is called 
X.IR all .
XThe ingredient of
X.I all
Xis the program named after the current directory.
XTwo other targets are supplied by this cookbook:
X.VL 0.5i
X.LI clean
Xremoves all of the
X.IB something .o
Xfiles from the current directory.
X.LI clobber
Xremoves the program named after the current directory,
Xand also removes all of the
X.IB something .o
Xfiles from the current directory.
X.LE
X.H 2 "Creating a Cookbook"
XTo use 
X.B cook
Xyou will usually need to define a cookbook,
Xby creating a file,
Xusually called
X.I Howto.cook
Xin the current directory,
Xwith your favorite text editor.
X.P
XThis file has a specific format.
XThe format has been designed to be easy to learn,
Xeven for the casual user.
XMuch of the power of 
X.B cook
Xis contained in how it works,
Xwithout complicating the format of the cookbook.
X.P
XExample of what a cookbook looks like are scattered throughout this
Xdocument.
XThe following example is the entire cookbook for
X.B cook
Xitself.
X.eB
X#include "c"
X#include "yacc"
X#include "usr.local"
X#include "program"
X.eE
XAs you can see,
Xeven for a complex program like
X.B cook
Xthe cookbook is remarkably simple.
END_OF_FILE
if test 6857 -ne `wc -c <'doc/intro.bb'`; then
    echo shar: \"'doc/intro.bb'\" unpacked with wrong size!
fi
# end of 'doc/intro.bb'
fi
if test -f 'find_libs/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'find_libs/main.c'\"
else
echo shar: Extracting \"'find_libs/main.c'\" \(6021 characters\)
sed "s/^X//" >'find_libs/main.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: operating system start point, and parse command line options
X */
X
X#include <stdio.h>
X#include <stddef.h>
X#include <string.h>
X#include <stdlib.h>
X
X#include <arglex.h>
X#include <error.h>
X#include <help.h>
X#include <mem.h>
X#include <os.h>
X#include <str.h>
X#include <version.h>
X
X
Xstatic void usage _((void));
X
Xstatic void
Xusage()
X{
X	fprintf(stderr, "usage: %s [ -L<path>... ] -l<name>...\n", progname);
X	fprintf(stderr, "       %s -Help\n", progname);
X	fprintf(stderr, "       %s -VERSion\n", progname);
X	exit(1);
X}
X
X
Xstatic void find_libs_help _((void));
X
Xstatic void
Xfind_libs_help()
X{
X	static char *text[] =
X	{
X"NAME",
X"	%s - find pathnames of libraries",
X"",
X"SYNOPSIS",
X"	%s [ -L<path> ... ][ -l<name> ... ]",
X"	%s -Help",
X"	%s -VERSion",
X"",
X"DESCRIPTION",
X"	The %s program is used to find the actual pathname",
X"	of a library specified on a cc(1) command line.  This",
X"	allows cook(1) to know these dependencies.",
X"",
X"OPTIONS",
X"	The following options are understood.",
X"",
X"	-L<path>",
X"		Specify a path to search for libraries on.  If",
X"		more than one is specified, they will be scanned",
X"		in the order given before the standard /usr/lib",
X"		and /lib places.  This is like the same argument",
X"		to cc(1), and the usual %s option",
X"		abbreviation rules do not apply.",
X"",
X"	-l<name>",
X"		Name a library to be searched for.  This is like",
X"		the same argument to cc(1), and the usual",
X"		%s option abbreviation rules do not apply.",
X"",
X"	-Help",
X"		Give some information on how to use the %s",
X"		command.",
X"",
X"	-VERSion",
X"		Tell the version of the %s command",
X"		currently executing.",
X"",
X"	All other options will result in a diagnostic error.",
X"",
X"	All options may be abbreviated; the abbreviation is",
X"	documented as the upper case letters, all lower case",
X"	letters and underscores (_) are optional.  You must use",
X"	consecutive sequences of optional letters.",
X"",
X"	All options are case insensitive, you may type them in",
X"	upper case or lower case or a combination of both, case",
X"	is not important.",
X"",
X"	For example: the arguments \"-help\", \"-HEL\" and \"-h\" are",
X"	all interpreted to mean the -Help option.  The argument",
X"	\"-hlp\" will not be understood, because consecutive",
X"	optional characters were not supplied.",
X"",
X"	Options and other command line arguments may be mixed",
X"	arbitrarily on the command line.",
X"",
X"	The GNU long option names are understood.  Since all",
X"	option names for %s are long, this means ignoring",
X"	the extra leading '-'.  The \"--option=value\" convention",
X"	is also understood.",
X"",
X"EXIT STATUS",
X"	The %s command will exit with a status of 1 on any",
X"	error.  The %s command will only exit with a",
X"	status of 0 if there are no errors.",
X"",
X"COPYRIGHT",
X"	%C",
X"",
X"AUTHOR",
X"	%A",
X	};
X
X	help(text, SIZEOF(text), usage);
X}
X
X
Xenum
X{
X	arglex_token_path,
X	arglex_token_search
X};
X
Xstatic arglex_table_ty argtab[] =
X{
X	{ "-\\L*",	(arglex_token_ty)arglex_token_path,	},
X	{ "-\\L",	(arglex_token_ty)arglex_token_path,	},
X	{ "-\\l*",	(arglex_token_ty)arglex_token_search,	},
X	{ "-\\l",	(arglex_token_ty)arglex_token_search,	},
X	{ 0, (arglex_token_ty)0, }, /* end marker */
X};
X
X
Xstatic char *copy_string _((char *));
X
Xstatic char *
Xcopy_string(s)
X	char	*s;
X{
X	char	*cp;
X
X	cp = mem_alloc(strlen(s) + 1);
X	strcpy(cp, s);
X	return cp;
X}
X
X
Xstatic void get_sys_libs _((int *, char **));
X
Xstatic void
Xget_sys_libs(nlibs, lib)
X	int	*nlibs;
X	char	**lib;
X{
X	char	*cp;
X	char	*start;
X
X	cp = getenv("LD_LIBRARY_PATH");
X	if (!cp)
X	{
X		lib[0] = "/usr/lib";
X		lib[1] = "/lib";
X		*nlibs = 2;
X		return;
X	}
X	*nlibs = 0;
X	start = cp;
X	for (;;)
X	{
X		if (!*cp || *cp == ':')
X		{
X			char	c;
X
X			c = *cp;
X			*cp = 0;
X			if (start < cp)
X				lib[(*nlibs)++] = copy_string(start);
X			*cp = c;
X			if (!c)
X				break;
X			start = cp + 1;
X		}
X		cp++;
X	}
X}
X
X
Xint main _((int, char **));
X
Xint
Xmain(argc, argv)
X	int	argc;
X	char	**argv;
X{
X	char	*path[1000];
X	int	npaths = 0;
X	int	k;
X	char	pathname[2000];
X	char	*syspath[100];
X	int	nsyspaths;
X
X	arglex_init(argc, argv, argtab);
X	str_initialize();
X
X	get_sys_libs(&nsyspaths, syspath);
X
X	switch (arglex())
X	{
X	case arglex_token_help:
X		find_libs_help();
X		exit(0);
X
X	case arglex_token_version:
X		version();
X		exit(0);
X
X	default:
X		break;
X	}
X
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			error
X			(
X				"misplaced \"%s\" command line argument",
X				arglex_value.alv_string
X			);
X			usage();
X	
X		case arglex_token_search:
X			if (arglex() != arglex_token_string)
X				fatal("-l requires a string argument");
X			for (k = 0; k < nsyspaths; ++k)
X				path[npaths++] = syspath[k];
X			for (k = 0; k < npaths; ++k)
X			{
X				sprintf
X				(
X					pathname,
X					"%s/lib%s.a",
X					path[k],
X					arglex_value.alv_string
X				);
X				if (os_exists(pathname))
X				{
X					printf("%s\n", pathname);
X					break;
X				}
X			}
X			if (k >= npaths)
X			{
X				fatal
X				(
X					"library \"%s\" not found",
X					arglex_value.alv_string
X				);
X			}
X			npaths -= nsyspaths;
X			break;
X	
X		case arglex_token_path:
X			if (arglex() != arglex_token_string)
X				fatal("-L requires a string argument");
X			path[npaths++] = arglex_value.alv_string;
X			break;
X		}
X		arglex();
X	}
X	exit(0);
X	return 0;
X}
END_OF_FILE
if test 6021 -ne `wc -c <'find_libs/main.c'`; then
    echo shar: \"'find_libs/main.c'\" unpacked with wrong size!
fi
# end of 'find_libs/main.c'
fi
if test -f 'man1/cook.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man1/cook.1'\"
else
echo shar: Extracting \"'man1/cook.1'\" \(7148 characters\)
sed "s/^X//" >'man1/cook.1' <<'END_OF_FILE'
X'\" t
X.\"	cook - file construction tool
X.\"	Copyright (C) 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: manual entry for the cook command
X.\" 
X.TH COOK 1
X.ds n) cook
X.if n .hy 0
X.if n .ad l
X.if n .nr IN 8n
X.SH NAME
X\*(n) \- a file construction tool
X.SH SYNOPSIS
X.B \*(n)
X[
X.IR option ...
X][
X.IR filename ...
X]
X.br
X.B \*(n)
X.B -Help
X.br
X.B \*(n)
X.B -VERSion
X.SH DESCRIPTION
XThe
X.I \*(n)
Xprogram is a tool for constructing files.
XIt is given a set of files to create,
Xand instructions detailing how to construct them.
XIn any non-trivial program
Xthere will be prerequisites to performing
Xthe actions necessary to creating any file,
Xsuch as extraction from a source-control system.
XThe
X.I \*(n)
Xprogram provides a mechanism to define these.
X.PP
XWhen a program is being developed or maintained,
Xthe programmer will typically change one file of several
Xwhich comprise the program.
XThe
X.I \*(n)
Xprogram examines the last-modified times of the files to see when
Xthe prerequisites of a file have changed,
Ximplying that the file
Xneeds to be recreated as it is logically out of date.
X.PP
XThe
X.I \*(n)
Xprogram also provides a facility for implicit recipes,
Xallowing users to specify how to form a file with a given suffix from
Xa file with a different suffix.
XFor example,
Xto create
X.IB filename .o
Xfrom
X.IB filename .c
X.PP
XOptions and filenames may be arbitrarily mixed on the command line;
Xno processing is done until all options and filenames
Xon the command line have been scanned.
X.PP
XThe
X.I \*(n)
Xprogram will attempt to create the named files from the recipes
Xgiven to it.
XThe recipes are contained in a file called
X.I Howto.cook
Xin the currect directory.
XThis file may, in turn, include other files containing additional recipes.
X.PP
XIf no
X.IR filename s
Xare given on the command line
Xthe targets of the first recipe defined are cooked.
X.br
X.ne 1i
X.SH OPTIONS
XThe valid options for
X.I \*(n)
Xare listed below.
XAny other options
X(words on the command line beginning with `\fB-\fP')
Xwill cause a diagnostic message to be issued.
X.TP 8n
X.B -Action
X.br
XExecute the commands given in the recipes.
XThis is the default.
X.TP 8n
X.B -No_Action
X.br
XDo not execute the commands given in the recipes.
X.TP 8n
X\fB-Book\fP \fIfilename\fP
X.br
XTells \*(n) to used the named cookbook,
Xrather than the default ``Howto.cook'' file.
X.TP 8n
X.B -Continue
X.br
XIf cooking a target should fail,
Xcontinue with other recipes for which the failed target is not an ingredient,
Xdirectly or indirectly.
X.TP 8n
X.B -No_Continue
X.br
XIf cooking a target should fail,
X.I \*(n)
Xwill exit.
XThis is the default.
X.TP 8n
X.B -Errok
X.br
XWhen a command is executed,
Xthe exit code will be ignored.
X.TP 8n
X.B -No_Errok
X.br
XWhen a command is executed,
Xif the exit code is positive
Xit will be deemed to fail,
Xand thus the recipe containing it to have failed.
XThis is the default.
X.TP 8n
X.B -Force
X.br
XAlways perform the actions of recipes,
Xirrespective of the last-modified times of any of the ingredients.
XThis option is useful if something beyond the scope of the cookbook
Xhas been modified;
Xfor example, a bug fix in a compiler.
X.TP 8n
X.B -No_Force
X.br
XPerform the actions of the recipes
Xif any of the ingredients are logically out of date.
XThis is the default.
X.TP 8n
X.B -Help
X.br
XProvide information about how to execute
X.I \*(n)
Xon 
X.IR stdout ,
Xand perform no other function.
X.TP 8n
X.BI -Include " filename"
X.br
XSearch the named directory before the standard places for
Xincluded cookbooks.
XEach directory so named will be scanned in the order given.
XThe standard places are
X.I $HOME/.cook
Xthen
X.IR /usr/local/lib/cook .
X.TP 8n
X.B -List
X.br
XCauses
X.I \*(n)
Xto automatically redirect the
X.I stdout
Xand
X.I stderr
Xof the session.
XOutput will continue to come to the terminal,
Xunless 
X.I \*(n)
Xis executing in the background.
XThe name of the file will be the name of the cookbook with any suffix
Xremoved and "\f(CW.list\fP" appended;
Xthis will usually be
X.IR Howto.list .
XThis is the default.
X.TP 8n
X.BI -List " filename"
X.br
XCauses 
X.I \*(n)
Xto automatically redirect the
X.I stdout 
Xand
X.I stderr
Xof the session into the named file.
XOutput will continue to come to the terminal,
Xunless 
X.I \*(n)
Xis executing in the background.
X.TP 8n
X.B -No_List
X.br
XNo automatic redirection of the output of the session will be made.
X.TP 8n
X.BI -No_List " filename"
X.br
XNo automatic redirection of the output of the session will be made,
Xhowever subsequent
X.B -List
Xoptions will default to listing to the named file.
X.TP 8n
X.B -Meter
X.br
XAfter each command is executed,
Xprint a summary of the command's CPU usage.
X.TP 8n
X.B -No_Meter
X.br
XDo not print a CPU usage summary after each command.
XThis is the default.
X.TP 8n
X.B -Precious
X.br
XWhen commands in the body of a recipe fail,
Xdo not delete the targets of the recipe.
X.TP 8n
X.B -No_Precious
X.br
XWhen commands in the body of a recipe fail,
Xdelete the targets of the recipe.
XThis is the default.
X.TP 8n
X.B -Silent
X.br
XDo not echo commands before they are executed.
X.TP 8n
X.B -No_Silent
X.br
XEcho commands before they are executed.
XThis is the default.
X.TP 8n
X.B -Touch
X.br
XUpdate the last-modified times of the
Xtarget files,
Xrather than execute the actions bound to recipes.
XThis can be useful if you have made a modification to a file that
Xyou know will make a
Xsystem of files logically out of date,
Xbut has no significance;
Xfor example,
Xadding a comment to a widely used include file.
X.TP 8n
X.B -No_Touch
X.br
XExecute the actions bound to recipes,
Xrather than update the last-modified times of the target files.
XThis is the default.
X.TP 8n
X.B -TErminal
X.br
XWhen listing,
Xalso send the output stream to the terminal.
XThis is the default.
X.TP 8n
X.B -No_TErminal
X.br
XWhen listing,
Xdo not send the output to the terminal.
X.TP 8n
X.IB name = value
X.br
XAssign the
X.I value
Xto the named variable.
XThe value may contain spaces
Xif you can convince the shell to pass them through.
X.TP 8n
X.B -TRace
X.br
XTwo options are provided for
Xtracing the inferences
X.B \*(n) 
Xmakes when attempting to cook a target.
XThe
X.B -TRace
Xoption will cause
X.I \*(n)
Xwill emit copious amounts of information
Xabout the inferences it is making when cooking targets.
XThis option may be used when you think 
X.B \*(n)
Xis acting strangely,
Xor are just curious.
X.TP 8n
X.B -No_TRace
X.br
XThis option may be used to cause
X.I \*(n)
Xwill not emit information
Xabout the inferences it is making when cooking targets.
XThis is the default.
X.so o__rules.so
X.so copyright.so
END_OF_FILE
if test 7148 -ne `wc -c <'man1/cook.1'`; then
    echo shar: \"'man1/cook.1'\" unpacked with wrong size!
fi
# end of 'man1/cook.1'
fi
if test -f 'roffpp/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'roffpp/main.c'\"
else
echo shar: Extracting \"'roffpp/main.c'\" \(6911 characters\)
sed "s/^X//" >'roffpp/main.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: operating system start point, and parse command line arguments
X */
X
X#include <stdio.h>
X#include <stddef.h>
X#include <string.h>
X#include <stdlib.h>
X
X#include <arglex.h>
X#include <error.h>
X#include <help.h>
X#include <preprocess.h>
X#include <str.h>
X#include <trace.h>
X#include <version.h>
X
X
Xstatic void usage _((void));
X
Xstatic void
Xusage()
X{
X	fprintf(stderr, "usage: %s [ <option>... ][ <infile> [ <outfile> ]]\n", progname);
X	fprintf(stderr, "       %s -Help\n", progname);
X	fprintf(stderr, "       %s -VERSion\n", progname);
X	exit(1);
X}
X
X
Xstatic void main_help _((void));
X
Xstatic void
Xmain_help()
X{
X	static char *text[] =
X	{
X"NAME",
X"	%s - replace .so requests within *roff sources",
X"",
X"SYNOPSIS",
X"	%s [ <option>... ][ <infile> [ <outfile> ]]",
X"	%s -Help",
X"	%s -VERSion",
X"",
X"DESCRIPTION",
X"	The %s command may be used to copies the input file",
X"	to the output file, including files named using .so",
X"	directives along the way, and removing the .so",
X"	directives.",
X"",
X"	This is useful when processing large multi-file documents",
X"	with filters such as tbl(1) or eqn(1) which do not",
X"	understand the .so directive.  The .nx directive is not",
X"	understood.  The %s program is not a general *roff",
X"	interpreter, so many constructs will be beyond it,",
X"	fortunately, most of them have nothing to do with include",
X"	files.  Include files which cannot be found, probably",
X"	from uninterpreted *roff constructs, if the files really",
X"	does exist, will simply be passed through unchanged, for",
X"	*roff to interpret at a later time.",
X"",
X"	The %s program also allows the user to specify an",
X"	include search path.  This allows, for example, common",
X"	files to be kept in a central location.",
X"",
X"	Only directives of the form",
X"		.so filename",
X"	are processed.  If the directive is introduced using the",
X"	single quote form, or the dot is not the first character",
X"	of the line, the directive will be ignored.",
X"",
X"	Any extra arguments on the line are ignored, and quoting",
X"	is not understood.  All characters are interpreted",
X"	literally.",
X"",
X"	Examples of directives which will be ignored include",
X"		'so /usr/lib/tmac/tmac.an",
X"		.if n .so yuck",
X"	This list is not exhaustive.",
X"",
X"	The special file name `-' on the command line means the",
X"	standard input or standard output, as appropriate.  Files",
X"	which are omitted are also assumed to be the standard",
X"	input or standard output, as appropriate.",
X"",
X"	The output attempts to keep file names and line numbers",
X"	in sync by using the .lf directive.  The .lf directive is",
X"	also understood as input.  This is compatible with",
X"	groff(1) and the other GNU text utilities included in the",
X"	groff package.",
X"",
X"OPTIONS",
X"	The following options are understood.",
X"",
X"	-I<path>",
X"		Specify include path, a la cc(1).  Include paths",
X"		are searched in the order specified.  The include",
X"		search path defaults to the current directory if",
X"		and only if the user does not specify any include",
X"		search paths.",
X"",
X"	-Help",
X"		Give information on how to use %s.",
X"",
X"	-VERSion",
X"		Tell what version of %s is being run.",
X"",
X"	Any other option will generate a diagnostic error.",
X"",
X"	All options may be abbreviated; the abbreviation is",
X"	documented as the upper case letters, all lower case",
X"	letters and underscores (_) are optional.  You must use",
X"	consecutive sequences of optional letters.",
X"",
X"	All options are case insensitive, you may type them in",
X"	upper case or lower case or a combination of both, case",
X"	is not important.",
X"",
X"	For example: the arguments \"-help\", \"-HEL\" and \"-h\" are",
X"	all interpreted to mean the -Help option.  The argument",
X"	\"-hlp\" will not be understood, because consecutive",
X"	optional characters were not supplied.",
X"",
X"	Options and other command line arguments may be mixed",
X"	arbitrarily on the command line.",
X"",
X"	The GNU long option names are understood.  Since all",
X"	option names for %s are long, this means ignoring the",
X"	extra leading '-'.  The \"--option=value\" convention is",
X"	also understood.",
X"",
X"EXIT STATUS",
X"	The %s command will exit with a status of 1 on any",
X"	error.  The %s command will only exit with a status",
X"	of 0 if there are no errors.",
X"",
X"COPYRIGHT",
X"	%C",
X"",
X"AUTHOR",
X"	%A",
X	};
X
X	help(text, SIZEOF(text), usage);
X}
X
X
Xenum
X{
X	arglex_token_include
X};
X
Xstatic arglex_table_ty argtab[] =
X{
X	{ "-\\I*",	(arglex_token_ty)arglex_token_include,	},
X	{ "-Include",	(arglex_token_ty)arglex_token_include,	},
X	{ 0, (arglex_token_ty)0, }, /* end marker */
X};
X
X
Xint main _((int, char **));
X
Xint
Xmain(argc, argv)
X	int	argc;
X	char	**argv;
X{
X	char	*infile;
X	char	*outfile;
X
X	arglex_init(argc, argv, argtab);
X	str_initialize();
X
X	switch (arglex())
X	{
X	case arglex_token_help:
X		main_help();
X		exit(0);
X
X	case arglex_token_version:
X		version();
X		exit(0);
X
X	default:
X		break;
X	}
X
X	infile = 0;
X	outfile = 0;
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			error
X			(
X				"misplaced \"%s\" command line argument",
X				arglex_value.alv_string
X			);
X			usage();
X	
X		case arglex_token_string:
X			if (!infile)
X				infile = arglex_value.alv_string;
X			else if (!outfile)
X				outfile = arglex_value.alv_string;
X			else
X				fatal("too many file names specified");
X			break;
X	
X		case arglex_token_stdio:
X			if (!infile)
X				infile = "";
X			else if (!outfile)
X				outfile = "";
X			else
X				fatal("too many file names specified");
X			break;
X	
X		case arglex_token_include:
X			if (arglex() != arglex_token_string)
X				fatal("-Include requires a string argument");
X			preprocess_include(arglex_value.alv_string);
X			break;
X
X#ifdef DEBUG
X		case arglex_token_tracing:
X			if (arglex() != arglex_token_string)
X				fatal("-TRACIng requires ore or more string arguments");
X			for (;;)
X			{
X				trace_enable(arglex_value.alv_string);
X				if (arglex() != arglex_token_string);
X					break;
X			}
X			continue;
X#endif
X		}
X		arglex();
X	}
X	if (infile && !*infile)
X		infile = 0;
X	if (outfile && !*outfile)
X		outfile = 0;
X	preprocess(infile, outfile);
X	exit(0);
X	return 0;
X}
END_OF_FILE
if test 6911 -ne `wc -c <'roffpp/main.c'`; then
    echo shar: \"'roffpp/main.c'\" unpacked with wrong size!
fi
# end of 'roffpp/main.c'
fi
echo shar: End of archive 4 \(of 11\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
